# [COCI 2018/2019 #5] Titlovi

## 题目描述

现有一个 `.SRT` 类型的文件，其由若干段字幕组成，用来再观看时载入。每段字幕又由三部分组成：

- 第一行：该字幕的编号
- 第二行字幕开始播放时间 --> 字幕结束播放时间
- 接下来的若干行：字幕内容

下面是一段字幕的例子：

```plain
1
00:00:01,600 --> 00:00:04,200
Good day!

2
00:00:05,900 --> 00:00:07,999
Good day to you too!
Here you go!

3
00:00:10,000 --> 00:00:14,000
May I please have ten garlic sausages?
```

时间均以 `HH:MM:SS,TTT` 格式给出，分别表示小时、分钟、秒和毫秒。规定 $1$ 秒 $=1000$ 毫秒。 

有时观看时会出现时间上的差异，因此在载入字幕时需要将所有字幕调快 / 调慢一个特定的时间，并输出调整后的 `.SRT` 文件。

## 说明/提示

#### 数据规模与规定

对于 $100\%$ 的数据，$-10^4 \le T \le 10^4$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

注：经测试，官方输入文件中可能含有 `\r` 等 Windows 下产生的字符。请大家在处理的过程中留意！

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #5](https://hsin.hr/coci/archive/2018_2019/contest5_tasks.pdf)  _T1 Titlovi_。**

## 样例 #1

### 输入

```
8
00:00:01,600 --> 00:00:04,200
We thought you was...

9
00:00:05,900 --> 00:00:07,999
a toad.
#
300```

### 输出

```
8
00:00:01,900 --> 00:00:04,500
We thought you was...

9
00:00:06,200 --> 00:00:08,299
a toad.
#```

## 样例 #2

### 输入

```
624
00:43:30,566 --> 00:43:32,108
Howdy do, ladies?

625
00:43:32,276 --> 00:43:33,943
Name of Pete.

626
00:43:47,124 --> 00:43:48,082
Ain't you gonna
introduce us, Pete?
#
-500```

### 输出

```
624
00:43:30,066 --> 00:43:31,608
Howdy do, ladies?

625
00:43:31,776 --> 00:43:33,443
Name of Pete.

626
00:43:46,624 --> 00:43:47,582
Ain't you gonna
introduce us, Pete?
#```

# 题解

## 作者：T21C06 (赞：7)

#### [题目](https://www.luogu.com.cn/problem/P7374)

## 思路

先读入编号（整型），接着读入时间（字符串），然后读入字幕内容。

读入字幕时遇到空行就停止（这组数据读完了，要读下一组数据了），

遇到井号停止读入。最后读入 $T$。

输出时边输出，边把时间调整就行了。


## 坑点

- 输入时要用 `scanf`，不然 [**时间超限**](https://www.luogu.com.cn/record/126699580)。

- 输入时注意 `\n`，`\r`，不然你就会莫名其妙地[**运行错误**](https://www.luogu.com.cn/record/124689260)或[**答案错误**](https://www.luogu.com.cn/record/126708352)。

## 代码

### 函数

### 1. check 函数

作用：判断是字幕还是下一个数据（这里我借鉴了 @shangyuang 的题解写的读入方式）。

```cpp
bool check(char c){
	return (c>='a'&&c<='z'||c>='A'&&c<='Z'||c==' '||c==','||c=='?'||c=='!'||c=='.');
}
```

### 2. zh 函数

作用：把时间进行调整，同时转化进率。

```cpp
void zh(int f[10]){  
	f[1]+=t; //先加毫秒 ，因为 T 的单位是毫秒 
	if(t>=0){  //要将字幕向后调 
	//下面每条语句都差不多，就是超出进率，多的给前一位，剩下的给这一位 
		if(f[1]>=1000) f[2]+=f[1]/1000,f[1]%=1000;
		if(f[2]>=60) f[3]+=f[2]/60,f[2]%=60;
		if(f[3]>=60) f[4]+=f[3]/60,f[3]%=60;
	}else{//要将字幕向前调
		int sum=0;
	    if(f[1]<0){
	    	//注意绝对值！！！ 
		    sum=abs(f[1])/1000; //要补的
			//有余数再加一个单位，当前位为进率减余数 
		    if(abs(f[1])%1000!=0) sum++,f[1]=1000-abs(f[1])%1000;
			else f[1]=0;// 刚好补完，变零 
			f[2]-=sum; //前一位减相应的单位 
		} 
	    if(f[2]<0){//同上 
		    sum=abs(f[2])/60;
		    if(abs(f[2])%60!=0) sum++,f[2]=60-abs(f[2])%60;
			else f[2]=0;
			f[3]-=sum;
		}
		if(f[3]<0){//同上
		    sum=abs(f[3])/60;
		    if(abs(f[3])%60!=0) sum++,f[3]=60-abs(f[3])%60;
			else f[3]=0;
			f[4]-=sum;
		}
	}
}
```

### 3. pd 函数

作用：从时间（字符串类型）中分离出小时、分钟、秒和毫秒，并根

据 $T$ 进行时间调整，最后将编号、调整好的时间、字幕内容输出。

```cpp
void pd(int k){ 
	string st=a[k].time+':'; //在最后加一个 ':'，防止最后一个时间没有分离出来 
	int sum1=0,x=4,y=4,f1[10]={0},f2[10]={0};//f1 表示开始时间，f2 表示结束时间 
	//下面我是倒序存的，当然正序存也可以 
	for(int i=0;i<st.size();i++){
		if(i==13) i=17; //略过中间 " --> " 部分 
		if(st[i]==':'||st[i]==','||st[i]==' '){ //遇到这几个符号说明已经有一个时间分离出来了 
			if(x>0) f1[x]=sum1,x--;//如果 x 不为零，说明开始时间还没读完，放进 f1 数组 
			else f2[y]=sum1,y--;//否则放入 f2 数组 
			sum1=0; //归零 
		}else sum1=sum1*10+(st[i]-48); //字符串转数字 
	} 
	zh(f1);//开始时间调整 
	zh(f2);//结束时间调整
	//输出 
	printf("%d\n",a[k].num);
	printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",f1[4],f1[3],f1[2],f1[1],f2[4],f2[3],f2[2],f2[1]);  
	printf("%s\n",a[k].book.c_str());
	if(k<n) printf("\n");
	else printf("#");    
}
```

### 主函数

```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
int n,t;
string sta,stb; //sta 表示开始时间，stb 表示结束时间 
struct node{
	int num; //编号 
	string time;//时间 
	string book;//字幕 
};
node a[1010];
//这里是函数部分（略）
int main(){
    while(1){ 
        n++;
    	scanf("%d",&a[n].num);//读入编号（一定要用 scanf！！！） 
    	sta.resize(12);//分配空间 
    	stb.resize(12);//分配空间
    	scanf("%s --> %s\n",&sta[0],&stb[0]);//读入时间 
    	a[n].time=sta+" --> "+stb;//加到 time 里 
    	while(1){ //读入字幕内容 
    	    getline(cin,sta);
    	    //如果是 '#'（读完了）或不是字幕（要读下一组数据）跳出 
    	    if(sta[0]=='#'||check(sta[0])==0) break;
    	    //字幕加到 book 里 
    		if(a[n].book.empty()) a[n].book+=sta;
    		else a[n].book+='\n'+sta; 
		}  
		if(sta[0]=='#') break;//是'#'（读完了）跳出 
    }
	cin>>t;	//输入要调整的时间 
    for(int i=1;i<=n;i++) pd(i);//时间调整 
	return 0;
}
```

## AC 代码

```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
int n,t;
string sta,stb;  
struct node{
	int num;  
	string time;
	string book; 
};
node a[1010];
void zh(int f[10]){  
	f[1]+=t; 
	if(t>=0){   
	
		if(f[1]>=1000) f[2]+=f[1]/1000,f[1]%=1000;
		if(f[2]>=60) f[3]+=f[2]/60,f[2]%=60;
		if(f[3]>=60) f[4]+=f[3]/60,f[3]%=60;
	}else{
		int sum=0;
	    if(f[1]<0){ 
		    sum=abs(f[1])/1000; 
		    if(abs(f[1])%1000!=0) sum++,f[1]=1000-abs(f[1])%1000;
			else f[1]=0;
			f[2]-=sum;  
		} 
	    if(f[2]<0){ 
		    sum=abs(f[2])/60;
		    if(abs(f[2])%60!=0) sum++,f[2]=60-abs(f[2])%60;
			else f[2]=0;
			f[3]-=sum;
		}
		if(f[3]<0){
		    sum=abs(f[3])/60;
		    if(abs(f[3])%60!=0) sum++,f[3]=60-abs(f[3])%60;
			else f[3]=0;
			f[4]-=sum;
		}
	}
}
void pd(int k){ 
	string st=a[k].time+':'; 
	int sum1=0,x=4,y=4,f1[10]={0},f2[10]={0};
	for(int i=0;i<st.size();i++){
		if(i==13) i=17; 
		if(st[i]==':'||st[i]==','||st[i]==' '){  
			if(x>0) f1[x]=sum1,x--;
			else f2[y]=sum1,y--; 
			sum1=0; 
		}else sum1=sum1*10+(st[i]-48); 
	} 
	zh(f1); 
	zh(f2);
	printf("%d\n",a[k].num);
	printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",f1[4],f1[3],f1[2],f1[1],f2[4],f2[3],f2[2],f2[1]);  
	printf("%s\n",a[k].book.c_str());
	if(k<n) printf("\n");
	else printf("#");    
}
bool check(char c){
	return (c>='a'&&c<='z'||c>='A'&&c<='Z'||c==' '||c==','||c=='?'||c=='!'||c=='.');
}
int main(){
    while(1){ 
        n++;
    	scanf("%d",&a[n].num);
    	sta.resize(12); 
    	stb.resize(12);
    	scanf("%s --> %s\n",&sta[0],&stb[0]); 
    	a[n].time=sta+" --> "+stb; 
    	while(1){ 
    	    getline(cin,sta);
    	    if(sta[0]=='#'||check(sta[0])==0) break;
    		if(a[n].book.empty()) a[n].book+=sta;
    		else a[n].book+='\n'+sta; 
		}  
		if(sta[0]=='#') break;
    }
	cin>>t;	
    for(int i=1;i<=n;i++) pd(i);
	return 0;
}
```

## 其他

- 本人刚开始写题解，如有错误欢迎指出。

- 特别感谢 @Jerrlee✅ 帮我改了一些代码上的问题。

- 看在我码了这么多字和[寄了这么多次](https://www.luogu.com.cn/record/list?pid=P7374&user=T21C06&page=1)的份上，点个赞吧！

- 祝愿看了这篇题解的人本题 AC！

---

## 作者：_7Mr (赞：4)

# 题意
有 $n$ 个弹幕，每个弹幕有一个起始时间和结束时间，然后输入一个正数或者负数的 $T$ 如果是正数，则表示要将字幕时间向后调整 $T$ 毫秒。否则，表示要将字幕时间向前调整 $- T$ 毫秒。
# 思路
先将弹幕内容全部存储下来，然后将所有时间换算成毫秒作单位，按照题意向前或者向后调整时间，最后输出时间与字符串就行了，思路不算复杂，就是代码比较难写，如果写得好，大约 $30$ 多行。
# 代码
我敲了 $100$ 多行，还是不给大家看了

---

## 作者：liuchang09 (赞：2)

[题目](https://www.luogu.com.cn/problem/P7374)
### 分析：
一道~~有手就行~~较为复杂的模拟题。题目非常容易理解，就是给出字幕的编号、出现时间和内容，然后把字幕向前或向后移动一段时间。
### 思路：
我们可以将每一段字幕看作一个结构体。

先读入每个字幕的具体数据，接着读入时间，再进行加或减运算，最后处理进位或借位就行了。
### 具体步骤：
1. 存储结构

创建一个结构体，里面用整数类型存储编号和出现时间，用字符串存储内容。
```cpp
struct Node{
	int n;
	string s;
	int sh1,f1,s1,ms1;//开始时间时、分、秒、毫秒 
	int sh2,f2,s2,ms2;//结束时间时、分、秒、毫秒
};
Node a[114];
```
2. 读入
先读入编号，接着读入出现时间、内容，因为内容可能不止一行，所以在读入内容的下一行时，我加了一个判断：如果不是空串且不是“#”，那就是第二行或更多行的内容，所以结构体里的字符串就要加上一个换行符和剩下的内容。

#### **特别注意：**

题目中有一句话是这样的：
 
**经测试，官方输入文件中可能有 `\r` 等 Windows 下产生的字符。请大家在处理的过程中留意！**


所以，我们在使用 `getline()` 函数时，一定要加上 ` s.pop_back()`  这一语句（s是字符串的名字）。


```cpp
while(x[0]!='#'){
	m++;
	scanf("%d\n",&a[m].n);
	scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&a[m].sh1,&a[m].f1,&a[m].s1,&a[m].ms1,&a[m].sh2,&a[m].f2,&a[m].s2,&a[m].ms2);//开始和结束时间 
	getline(cin,a[m].s);
	a[m].s.pop_back();
	getline(cin,x);
	x.pop_back();
	while(x.size()!=0&&x[0]!='#'){
		a[m].s+=("\n"+x);
		getline(cin,x);
		x.pop_back();
	}
}
cin>>n;//改变的时间
```
3. 进位和借位

进位和借位类似于高精，但有一点需要注意，就是可能出现多次进位或借位。

```cpp
for(int i=1;i<=m;i++){
	if(n>=0) a[i].ms1+=n;
	else a[i].ms1-=abs(n);//判断是加还是减
	if(a[i].ms1>=1000){//毫秒的进位
		a[i].s1+=(a[i].ms1/1000);
		a[i].ms1%=1000;//秒与毫秒的进率为1000
		if(a[i].s1>=60){//秒的借位
			a[i].f1+=(a[i].s1/60);
			a[i].s1%=60;
			if(a[i].f1>=60){//分的借位
				a[i].sh1+=(a[i].f1/60);
				a[i].f1%=60;
			}
		}
	}
	while(a[i].ms1<0{//毫秒的借位
		a[i].ms1+=1000;
		a[i].s1--;
		while(a[i].s1<0{//秒的借位
			a[i].s1+=60;
			a[i].f1--;	
			while(a[i].f1<0){//分的借位
				a[i].f1+=60;
				a[i].sh1--;
			}
		}
	}
	//开始时间和结束时间进位/借位的方法一样                    
	if(n>=0) a[i].ms2+=n;
	else a[i].ms2-=abs(n);
	if(a[i].ms2>=1000){
		a[i].s2+=(a[i].ms2/1000);
		a[i].ms2%=1000;
		if(a[i].s2>=60){
			a[i].f2+=(a[i].s2/60);
			a[i].s2%=60;
			if(a[i].f2>=60){
				a[i].sh2+=(a[i].f2/60);
				a[i].f2%=60;
			}
		}
	}
	while(a[i].ms2<0){
		a[i].ms2+=1000;
		a[i].s2--;
		while(a[i].s2<0){
			a[i].s2+=60;
			a[i].f2--;	
			while(a[i].f2<0){
				a[i].f2+=60;
				a[i].sh2--;
			}
		}
	}
}
```
4. ~~最简单的~~输出

因为有结构体，所以每个结构体输出一遍就行了。

```cpp
for(int i=1;i<m;i++){
	cout<<a[i].n<<endl;
	printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[i].sh1,a[i].f1,a[i].s1,a[i].ms1,a[i].sh2,a[i].f2,a[i].s2,a[i].ms2);
	cout<<a[i].s<<endl<<endl;
}//最后一个输出
cout<<a[m].n<<endl;
printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[m].sh1,a[m].f1,a[m].s1,a[m].ms1,a[m].sh2,a[m].f2,a[m].s2,a[m].ms2);
cout<<a[m].s<<endl;
cout<<'#'<<endl;
return 0;
```

### 最后附上~~有点丑~~AC代码:

```
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int n;
	string s;
	int sh1,f1,s1,ms1;
	int sh2,f2,s2,ms2;
};
Node a[114];
string x;
int m,n;
int main(){
	while(x[0]!='#'){
		m++;
		scanf("%d\n",&a[m].n);
		scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&a[m].sh1,&a[m].f1,&a[m].s1,&a[m].ms1,&a[m].sh2,&a[m].f2,&a[m].s2,&a[m].ms2);//开始和结束时间 
		getline(cin,a[m].s);
		a[m].s.pop_back();
		getline(cin,x);
		x.pop_back();
		while(x.size()!=0&&x[0]!='#'){
			a[m].s+=("\n"+x);
			getline(cin,x);
			x.pop_back();
		}
	}
	cin>>n; 
	for(int i=1;i<=m;i++){
		if(n>=0) a[i].ms1+=n;
		else a[i].ms1-=abs(n);
		if(a[i].ms1>=1000){
			a[i].s1+=(a[i].ms1/1000);
			a[i].ms1%=1000;
			if(a[i].s1>=60){
				a[i].f1+=(a[i].s1/60);
				a[i].s1%=60;
				if(a[i].f1>=60){
					a[i].sh1+=(a[i].f1/60);
					a[i].f1%=60;
				}
			}
		}
		while(a[i].ms1<0){
			a[i].ms1+=1000;
			a[i].s1--;
			while(a[i].s1<0){
				a[i].s1+=60;
				a[i].f1--;	
				while(a[i].f1<0){
					a[i].f1+=60;
					a[i].sh1--;
				}
			}
		}
		if(n>=0) a[i].ms2+=n;
		else a[i].ms2-=abs(n);
		if(a[i].ms2>=1000){
			a[i].s2+=(a[i].ms2/1000);
			a[i].ms2%=1000;
			if(a[i].s2>=60){
				a[i].f2+=(a[i].s2/60);
				a[i].s2%=60;
				if(a[i].f2>=60){
					a[i].sh2+=(a[i].f2/60);
					a[i].f2%=60;
				}
			}
		}
		while(a[i].ms2<0){
			a[i].ms2+=1000;
			a[i].s2--;
			while(a[i].s2<0){
				a[i].s2+=60;
				a[i].f2--;	
				while(a[i].f2<0){
					a[i].f2+=60;
					a[i].sh2--;
				}
			}
		}
	}
	for(int i=1;i<=m-1;i++){
		cout<<a[i].n<<endl;
		printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[i].sh1,a[i].f1,a[i].s1,a[i].ms1,a[i].sh2,a[i].f2,a[i].s2,a[i].ms2);
		cout<<a[i].s<<endl<<endl;
	}
	cout<<a[m].n<<endl;
	printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[m].sh1,a[m].f1,a[m].s1,a[m].ms1,a[m].sh2,a[m].f2,a[m].s2,a[m].ms2);
	cout<<a[m].s<<endl;
	cout<<'#'<<endl;
	return 0;
}
```

具体的注释在前面，欢迎dalao们来指责。

---

## 作者：lnwhl (赞：2)

# P7374 [COCI2018-2019#5] Titlovi 题解
## 题目描述
有若干字幕，每条字幕有三部分。

1. 第一行：该字幕的编号。**对于这一行，我们原样输出。**

1. 第二行：字幕开始播放时间 --> 字幕结束播放时间。**对于这
一行，我们输出其改变 $T$ 毫秒后的时间。**
1. 接下来的若干行：字幕内容。**对于这若干行，我们原样输出。**

## 分析
大模拟！！！
读入数据的时候，我们将编号，时间的字幕分别存起来。
对于时间，暴力模拟修改。其他原样输出就行了。

注意空行的判断及输出前导 $0$.

代码看起来挺长，但大段都可以复制粘贴。细节还是挺多的，详见代码。
## 代码
```
#include <bits/stdc++.h>
using namespace std;
int t,st[1005][10],fin[1005][10];//开始时间，结束时间
int id[1005],siz[1005];//编号和字幕的行数
string s[1005][1005];//字幕内容
int main()
{
	int cnt=0,c;
	while(cin>>c)
	{
		id[++cnt]=c;
		while(cin.get()!='\n')continue;//防止s1读入回车
		string s1;
		getline(cin,s1);
		s1=s1+' ';
		int sum=0,step=1,from;
		for(int i=0;i<s1.length();i++)//开始时间
		{
			if(s1[i]=='-')
			{
				from=i;
				break;
			}
			if(isdigit(s1[i]))
			{ 
				sum=sum*10+(s1[i]-'0');
			}
			else
			{
				st[cnt][step]=sum;
				sum=0;
				step++;
			}
		} 
		sum=0,step=1;
		for(int i=from+4;i<s1.length();i++)//结束时间
		{
			if(isdigit(s1[i]))
			{
				sum=sum*10+(s1[i]-'0');
			}
			else
			{
				fin[cnt][step]=sum;
				sum=0;
				step++;
			}
		}
		int sizk=1;
		while(getline(cin,s[cnt][sizk])&&(s[cnt][sizk].size()!=1))//size为1判空是因为会读入换行
		{
			siz[cnt]=sizk;
			if(s[cnt][sizk][0]=='#'){goto M1;}//跳出多重循环
			sizk++;
		}
	}
	M1:
	cin>>t;
	if(t>=0)//t为正
	{
		for(int i=1;i<=cnt;i++)
		{ 
			if(st[i][4]+t>=1000){st[i][3]+=(st[i][4]+t)/1000;st[i][4]=st[i][4]+t-((st[i][4]+t)/1000*1000);}
			else st[i][4]+=t;
			if(st[i][3]>=60){st[i][3]=st[i][3]-60;st[i][2]++;}
			if(st[i][2]>=60){st[i][2]=st[i][2]-60;st[i][1]++;}
			
			if(fin[i][4]+t>=1000){fin[i][3]+=(fin[i][4]+t)/1000;fin[i][4]=fin[i][4]+t-((fin[i][4]+t)/1000*1000);}
			else fin[i][4]+=t;
			if(fin[i][3]>=60){fin[i][3]=fin[i][3]-60;fin[i][2]++;}
			if(fin[i][2]>=60){fin[i][2]=fin[i][2]-60;fin[i][1]++;}
			cout<<id[i]<<endl;
			printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",st[i][1],st[i][2],st[i][3],st[i][4],fin[i][1],fin[i][2],fin[i][3],fin[i][4]);//输出前导0
			for(int j=1;j<=siz[i];j++)cout<<s[i][j]<<endl;//字幕原样输出
			if(i!=cnt)cout<<endl;//输出空行
		}
	}
	else//同上
	{
		for(int i=1;i<=cnt;i++)
		{
			if(st[i][4]+t<0){st[i][3]+=floor((st[i][4]+t)/1000.0);st[i][4]=st[i][4]+t-floor((st[i][4]+t)/1000.0)*1000;}
			else st[i][4]+=t;
			if(st[i][3]<0){st[i][3]=st[i][3]+60;st[i][2]--;}
			if(st[i][2]<0){st[i][2]=st[i][2]+60;st[i][1]--;}
			
			if(fin[i][4]+t<0){fin[i][3]+=floor((fin[i][4]+t)/1000.0);fin[i][4]=fin[i][4]+t-floor((fin[i][4]+t)/1000.0)*1000;}
			else fin[i][4]+=t;
			if(fin[i][3]<0){fin[i][3]=fin[i][3]+60;fin[i][2]--;}
			if(fin[i][2]<0){fin[i][2]=fin[i][2]+60;fin[i][1]--;}
			cout<<id[i]<<endl;
			printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",st[i][1],st[i][2],st[i][3],st[i][4],fin[i][1],fin[i][2],fin[i][3],fin[i][4]);
			for(int j=1;j<=siz[i];j++)cout<<s[i][j]<<endl;
			if(i!=cnt)cout<<endl;
		}
	}
	return 0;
}

```
## 总结
字符串好题。
数据可以在[这里](https://hsin.hr/coci/archive/2018_2019/)下载。

$\texttt{By whl}$

$\texttt{2021.12.12}$

---

## 作者：jqQt0220 (赞：1)

稍稍有些复杂~~但是有手就行~~的模拟。  
这题也是相当离谱，尤其是读入，数据居然有 `\r`！  
不过除了读入处理有亿点麻烦，其他也是比较简单。

## 做法

### 1. 读入

最最最坑的地方~~我调了1个多小时~~。

可以建一个结构体存储一段字幕：
```cpp
struct node
{
    int x,l;//编号，字幕行数
    int h1,m1,s1,t1,h2,m2,s2,t2;//起始和结束时间
    string s[100];
}a[100];
```

读入还有很坑的地方就是要判断一段数据。我一开始用的 `getchar()` 结果有大 bug，调了半天，最终还是决定分行储存……  
这里我借鉴了 @[shangyuang](/user/552461) 的题解写的读入方式，用一个函数判断是字幕还是下一个数据：
```cpp
bool check(char c)
{
	return c>='a'&&c<='z'||c>='A'&&c<='Z'||c==' '||c==','||c=='?'||c=='!'||c=='.';
}
```

搞定后开始读入：
```cpp
for(n=1;;n++)//n为字幕组数
{
    scanf("%d",&a[n].x);//读入序号
    scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&a[n].h1,&a[n].m1,&a[n].s1,&a[n].t1,&a[n].h2,&a[n].m2,&a[n].s2,&a[n].t2);//开始结束时间
    string p="";
    int f=0;
    while(1)//开始读字幕正文
    {
        getline(cin,p);
        if(p[0]=='#')//字幕都读完了标记一下跳出
        {
            f=1;
            break;
        }
        if(check(p[0]))//是字幕
            a[n].s[++a[n].l]=p;
        else //这组字幕读完了
            break;
    }
    if(f)
        break;
}
scanf("%d",&t);
```

恭喜你搞定了这道题最坑的部分！剩下的部分就比较简单了。

--------

### 2. 计算

主要问题在进位和退位，其实和高精度差不多，而且数据范围只到 $10^4$，但是我们要探究一次进多秒的方法（bushi  
代码如下：
```cpp
for(int i=1;i<=n;i++)
{
    a[i].t1+=t;
    a[i].t2+=t;//先加
    if(t>0)//要处理进位
    {
        if(a[i].t1>=1000)
        {
            a[i].s1+=a[i].t1/1000;//多几秒就进几秒
            a[i].t1%=1000;//去掉多余的
            if(a[i].s1>=60)
            {
                a[i].m1+=a[i].s1/60;//同上
                a[i].s1%=60;
                if(a[i].m1>=60)
                {
                    a[i].h1+=a[i].m1/60;
                    a[i].m1%=60;
                }
            }
        }
        if(a[i].t2>=1000)//同上
        {
            a[i].s2+=a[i].t2/1000;
            a[i].t2%=1000;
            if(a[i].s2>=60)
            {
                a[i].m2+=a[i].s2/60;
                a[i].s2%=60;
                if(a[i].m2>=60)
                {
                    a[i].h2+=a[i].m2/60;
                    a[i].m2%=60;
                }
            }
        }
    }
    else //处理退位
    {
        if(a[i].t1<0)
        {
            a[i].s1-=(-a[i].t1)/1000+1;//(-a[i].t1)/1000+1是要借多少秒
            a[i].t1+=((-a[i].t1)/1000+1)*1000;//把借的秒数加上
            if(a[i].s1<0)
            {
                a[i].m1-=(-a[i].s1)/60+1;
                a[i].s1+=((-a[i].s1)/60+1)*60;
                if(a[i].m1<0)
                {
                    a[i].h1-=(-a[i].m1)/60+1;
                    a[i].m1+=((-a[i].m1)/60+1)*60;
                }
            }
        }
        if(a[i].t2<0)
        {
            a[i].s2-=(-a[i].t2)/1000+1;
            a[i].t2+=((-a[i].t2)/1000+1)*1000;
            if(a[i].s2<0)
            {
                a[i].m2-=(-a[i].s2)/60+1;
                a[i].s2+=((-a[i].s2)/60+1)*60;
                if(a[i].m2<0)
                {
                    a[i].h2-=(-a[i].m2)/60+1;
                    a[i].m2+=((-a[i].m2)/60+1)*60;
                }
            }
        }
    }
}
```

--------

### 3. 输出

不用多说，直接上代码：
```cpp
for(int i=1;i<=n;i++)
{
    printf("%d\n",a[i].x);
    printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[i].h1,a[i].m1,a[i].s1,a[i].t1,a[i].h2,a[i].m2,a[i].s2,a[i].t2);//printf真好用（bushi
    for(int j=1;j<=a[i].l;j++)
        cout<<a[i].s[j]<<"\n";
    if(i<n)
        printf("\n");
}
printf("#");
```

--------

### 4. AC CODE
~~我知道你们只看这个~~
```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
struct node
{
    int x,l;
    int h1,m1,s1,t1,h2,m2,s2,t2;
    string s[100];
}a[100];
bool check(char c)
{
	return c>='a'&&c<='z'||c>='A'&&c<='Z'||c==' '||c==','||c=='?'||c=='!'||c=='.';
}
int t,n;
int main()
{
    for(n=1;;n++)
    {
        scanf("%d",&a[n].x);
        scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&a[n].h1,&a[n].m1,&a[n].s1,&a[n].t1,&a[n].h2,&a[n].m2,&a[n].s2,&a[n].t2);
        string p="";
        int f=0;
        while(1)
        {
            getline(cin,p);
            if(p[0]=='#')
            {
                f=1;
                break;
            }
            if(check(p[0]))
                a[n].s[++a[n].l]=p;
            else
                break;
        }
        if(f)
            break;
    }
    scanf("%d",&t);
    for(int i=1;i<=n;i++)
    {
        a[i].t1+=t;
        a[i].t2+=t;
        if(t>0)
        {
            if(a[i].t1>=1000)
            {
                a[i].s1+=a[i].t1/1000;
                a[i].t1%=1000;
                if(a[i].s1>=60)
                {
                    a[i].m1+=a[i].s1/60;
                    a[i].s1%=60;
                    if(a[i].m1>=60)
                    {
                        a[i].h1+=a[i].m1/60;
                        a[i].m1%=60;
                    }
                }
            }
            if(a[i].t2>=1000)
            {
                a[i].s2+=a[i].t2/1000;
                a[i].t2%=1000;
                if(a[i].s2>=60)
                {
                    a[i].m2+=a[i].s2/60;
                    a[i].s2%=60;
                    if(a[i].m2>=60)
                    {
                        a[i].h2+=a[i].m2/60;
                        a[i].m2%=60;
                    }
                }
            }
        }
        else
        {
            if(a[i].t1<0)
            {
                a[i].s1-=(-a[i].t1)/1000+1;
                a[i].t1+=((-a[i].t1)/1000+1)*1000;
                if(a[i].s1<0)
                {
                    a[i].m1-=(-a[i].s1)/60+1;
                    a[i].s1+=((-a[i].s1)/60+1)*60;
                    if(a[i].m1<0)
                    {
                        a[i].h1-=(-a[i].m1)/60+1;
                        a[i].m1+=((-a[i].m1)/60+1)*60;
                    }
                }
            }
            if(a[i].t2<0)
            {
                a[i].s2-=(-a[i].t2)/1000+1;
                a[i].t2+=((-a[i].t2)/1000+1)*1000;
                if(a[i].s2<0)
                {
                    a[i].m2-=(-a[i].s2)/60+1;
                    a[i].s2+=((-a[i].s2)/60+1)*60;
                    if(a[i].m2<0)
                    {
                        a[i].h2-=(-a[i].m2)/60+1;
                        a[i].m2+=((-a[i].m2)/60+1)*60;
                    }
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",a[i].x);
        printf("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d\n",a[i].h1,a[i].m1,a[i].s1,a[i].t1,a[i].h2,a[i].m2,a[i].s2,a[i].t2);
        for(int j=1;j<=a[i].l;j++)
            cout<<a[i].s[j]<<"\n";
        if(i<n)
            printf("\n");
    }
    printf("#");
    return 0;
}
```
看完了不点个赞吗？

---

## 作者：xiaoyuchenp (赞：1)

很好的字符串模拟题，适合新手练手。

**基本思路**

用结构体来存储每一段字幕，然后遍历结构体数组处理进位与借位即可。

**关于结构体的存储**

结构体中存放如下内容：字幕编号，出现时间，结束时间，字幕内容（用字符串存储）。

```cpp
struct srt{
	int pos,strpos;
	int h1,m1,s1,t1,h2,m2,s2,t2; //字幕的出现与结束时间（时，分，秒，毫秒） 
	string str[MAXM]; //字幕内容 
};
srt q[MAXN];
```

**关于读入**

个人感觉这是这道题里最考细心度的部分。

有些题解读入字幕开始与结束时间是用 $\texttt{string}$ 存储，然后再用封装函数提取子串转化成整型，但其实根本就不用这么麻烦。用 `scanf` 函数格式化读入省略字符即可。

```cpp
scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&q[cnt].h1,&q[cnt].m1,&q[cnt].s1,&q[cnt].t1,&q[cnt].h2,&q[cnt].m2,&q[cnt].s2,&q[cnt].t2);
```

读入字幕用 `getline` 函数即可，为确认这不是下一组的数据可以特判一下：

```cpp
if(isalpha(s[0])||s[0]==','||s[0]==' '||s[0]=='!'||s[0]=='?'||s[0]=='.')
	q[cnt].str[++q[cnt].strpos]=s;
```

**关于进位退位**

有些题解是用类似高精度加减法的方式去做，也是没有问题的，但是代码略显繁琐。其实可以直接把时间单位换算成毫秒，在毫秒上进行加减法，最后转回普通的时间单位，这样的代码会更简洁。代码如下：

```cpp
int sum1=q[i].t1+q[i].s1*1000+q[i].m1*60000+q[i].h1*3600000+t;
int sum2=q[i].t2+q[i].s2*1000+q[i].m2*60000+q[i].h2*3600000+t;
int anst1=sum1%1000,anst2=sum2%1000;
int anss1=sum1/1000%60,anss2=sum2/1000%60;
int ansm1=sum1/60000%60,ansm2=sum2/60000%60;
int ansh1=sum1/3600000,ansh2=sum2/3600000;
```

主要繁琐的地方就是以上几点，注意一下这题还是比较简单的。

完整代码如下：

```cpp
#include<bits/stdc++.h>
#define MAXN 10005
#define MAXM 105
using namespace std;
struct srt{
	int pos,strpos;
	int h1,m1,s1,t1,h2,m2,s2,t2;
	string str[MAXM];
};
srt q[MAXN];
int cnt=0,t;

int main(){
	for(;++cnt;){
		scanf("%d",&q[cnt].pos);
		scanf("%d:%d:%d,%d --> %d:%d:%d,%d\n",&q[cnt].h1,&q[cnt].m1,&q[cnt].s1,&q[cnt].t1,&q[cnt].h2,&q[cnt].m2,&q[cnt].s2,&q[cnt].t2);
		string s;
		bool flg=false;
		for(;;){
			getline(cin,s);
			if(s[0]=='#'){
				flg=true;
				break;
			}
			if(isalpha(s[0])||s[0]==','||s[0]==' '||s[0]=='!'||s[0]=='?'||s[0]=='.')
				q[cnt].str[++q[cnt].strpos]=s;
			else break;
		}
		if(flg)break;
	}
	cin>>t;
	for(int i=1;i<=cnt;i++){
		int sum1=q[i].t1+q[i].s1*1000+q[i].m1*60000+q[i].h1*3600000+t;
		int sum2=q[i].t2+q[i].s2*1000+q[i].m2*60000+q[i].h2*3600000+t;
		int anst1=sum1%1000,anst2=sum2%1000;
		int anss1=sum1/1000%60,anss2=sum2/1000%60;
		int ansm1=sum1/60000%60,ansm2=sum2/60000%60;
		int ansh1=sum1/3600000,ansh2=sum2/3600000;
		printf("%d\n",q[i].pos);
		printf("%02lld:%02lld:%02lld,%03lld --> %02lld:%02lld:%02lld,%03lld\n",ansh1,ansm1,anss1,anst1,ansh2,ansm2,anss2,anst2);
		for(int j=1;j<=q[i].strpos;j++)
			cout<<q[i].str[j]<<'\n';
		if(i!=cnt)cout<<'\n';
	}
	printf("#");
	return 0;
}
```

---

## 作者：BigRooster (赞：1)

# [P7374 [COCI2018-2019#5] Titlovi](https://www.luogu.com.cn/problem/P7374)

# 题解

这题是一道细节很多的字符串模拟。

## 提取时间数字

可以使用 `scanf` 格式化输入，省略提取部分，但我是用的是 `getline` 后用 `substr` 手动提取，为的是避免 `scanf` 导致的光标停留在上一行需要加 `getchar` 的麻烦。

```cpp
getline(cin,temp);//时间输入
//开始
tmp.start.h=toi(temp.substr(0,2));//小时
tmp.start.m=toi(temp.substr(3,2));//分钟
tmp.start.s=toi(temp.substr(6,2));//秒钟
tmp.start.ms=toi(temp.substr(9,3));//毫秒
//结束
tmp.finish.h=toi(temp.substr(17,2));
tmp.finish.m=toi(temp.substr(20,2));
tmp.finish.s=toi(temp.substr(23,2));
tmp.finish.ms=toi(temp.substr(26,3));
```

其中 `toi` 是字符串转数字（需要自己编写）。

## 提取说的话

说的话有多行，因此，我们可以对于每次说的话定义一个 `string`，每输入一行就往后追加一行。

```cpp
string wordtmp;
getline(cin,wordtmp);//说的第一句话
bool flag=false;
while(true)
{
	getline(cin,str);
	if(str=="")//如果说话结束
		break;
	if(str=="#")//如果输入结束
	{
		flag=true;
		break;
	}
	wordtmp+="\n"+str;
}
word[cnt2]=wordtmp;
if(flag) break;
```

需要注意，不论是遇到空行还是 `#`，都要停止输入，后者还需要跳出整个大循环，因此开 `flag` 记录。

## 更改时间

虽然可以将往前和往后归在一个循环中，但是判断更麻烦，所以将往前和往后分开。

**向后调时间**

先对毫秒加 $T$，如果大于 `1000`，则对秒加 $ms \div 1000$，再将毫秒记为 $ms \bmod 1000$。

如果秒大于 `60`，则对分加 $s \div 60$，再将秒记为 $s \bmod 60$。

以此类推，需要注意的是，对于时，如果超出 `24`，直接对 `24` 取模即可。

```cpp
a[i].start.ms+=offset;
if(a[i].start.ms>=1000)
	a[i].start.s+=a[i].start.ms/1000,a[i].start.ms%=1000;
if(a[i].start.s>=60)
	a[i].start.m+=a[i].start.s/60,a[i].start.s%=60;
if(a[i].start.m>=60)
	a[i].start.h+=a[i].start.m/60,a[i].start.m%=60;
if(a[i].start.h>=24)
	a[i].start.h%=24;
a[i].finish.ms+=offset;
if(a[i].finish.ms>=1000)
	a[i].finish.s+=a[i].finish.ms/1000,a[i].finish.ms%=1000;
if(a[i].finish.s>=60)
	a[i].finish.m+=a[i].finish.s/60,a[i].finish.s%=60;
if(a[i].finish.m>=60)
	a[i].finish.h+=a[i].finish.m/60,a[i].finish.m%=60;
if(a[i].finish.h>=24)
	a[i].finish.h%=24;
```

对于开始时间和结束时间都是如此。

**向前调时间**

原理类似，但将条件判断改为当小于 `0` 时执行，并将取模改为用 `1000` 或 `60` 或 `24` 减去余数（需要化为正数）。

```cpp
a[i].start.ms+=offset;
if(a[i].start.ms<0)
	a[i].start.s-=((-a[i].start.ms)/1000+1),a[i].start.ms=1000-(-a[i].start.ms)%1000;
if(a[i].start.s<0)
	a[i].start.m-=((-a[i].start.s)/60+1),a[i].start.s=60-(-a[i].start.s)%60;
if(a[i].start.m<0)
	a[i].start.h-=((-a[i].start.m)/60+1),a[i].start.m=60-(-a[i].start.m)%60;
if(a[i].start.h<0)
	a[i].start.h=24-((-a[i].start.h)%24);
a[i].finish.ms+=offset;
if(a[i].finish.ms<0)
	a[i].finish.s-=((-a[i].finish.ms)/1000+1),a[i].finish.ms=1000-(-a[i].finish.ms)%1000;
if(a[i].finish.s<0)
	a[i].finish.m-=((-a[i].finish.s)/60+1),a[i].finish.s=60-(-a[i].finish.s)%60;
if(a[i].finish.m<0)
	a[i].finish.h-=((-a[i].finish.m)/60+1),a[i].finish.m=60-(-a[i].finish.m)%60;
if(a[i].finish.h<0)
	a[i].finish.h=24-((-a[i].finish.h)%24);
```    

## 重组时间样式

使用 `printf`，或像我一样用函数格式化重组字符串。

```cpp
string lenbuild(int len,string str)//指定长度补充前导0
{
	while(str.size()<len)
		str.insert(0,"0");
	return str;
}
string build(instance x)//一个时刻
{
	return lenbuild(2,to_string(x.h))+":"+lenbuild(2,to_string(x.m))+":"+lenbuild(2,to_string(x.s))+","+lenbuild(3,to_string(x.ms));
}
string repair(duration x)//一段时间
{
	return build(x.start)+" --> "+build(x.finish);
}
```

## 输出

首先，在代码开头需要用变量记录第一句话的编号，然后最后依次输出每句话的编号。

输出说的话之后，还要输出一段空行，注意最后一句话后直接输出 `#`，不空行。

```cpp
int number=numberstart;
for(int i=1;i<=cnt1;i++)
{
	cout<<number<<"\n";//当前编号
	cout<<repair(a[i])<<"\n";//重组格式
	cout<<word[i]<<"\n"<<(number==numberstart+n-1?"#":"\n"),number++;//说的话，接一个空行或#
}
```

## 最后奉上可读性不是很强的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int numberstart;
struct instance
{
	int h,m,s,ms;
};
struct duration
{
	instance start,finish;
};
duration a[100001];
int cnt1;
string word[100001];
int cnt2;
int offset;
int toi(string str)
{
	int x=0;
	for(int i=0,l=str.size();i<l;i++)
		x=x*10+str[i]-'0';
	return x;
}
string lenbuild(int len,string str)
{
	while(str.size()<len)
		str.insert(0,"0");
	return str;
}
string build(instance x)
{
	return lenbuild(2,to_string(x.h))+":"+lenbuild(2,to_string(x.m))+":"+lenbuild(2,to_string(x.s))+","+lenbuild(3,to_string(x.ms));
}
string repair(duration x)
{
	return build(x.start)+" --> "+build(x.finish);
}
main()
{
	string x;
	getline(cin,x);//初始编号
	n++;
	numberstart=toi(x);
	while(true)
	{
		cnt1++;
		cnt2++;
		string x;
		string temp;
		getline(cin,temp);//时间
		string str;
		string wordtmp;
		a[cnt1].start.h=toi(temp.substr(0,2));
		a[cnt1].start.m=toi(temp.substr(3,2));
		a[cnt1].start.s=toi(temp.substr(6,2));
		a[cnt1].start.ms=toi(temp.substr(9,3));
		a[cnt1].finish.h=toi(temp.substr(17,2));
		a[cnt1].finish.m=toi(temp.substr(20,2));
		a[cnt1].finish.s=toi(temp.substr(23,2));
		a[cnt1].finish.ms=toi(temp.substr(26,3));
		getline(cin,wordtmp);//说的第一句话
		bool flag=false;
		while(true)
		{
			getline(cin,str);
			if(str=="")//如果说话结束
				break;
			if(str=="#")//如果输入结束
			{
				flag=true;
				break;
			}
			wordtmp+="\n"+str;
		}
		word[cnt2]=wordtmp;
		if(flag) break;
		getline(cin,x);//下一个编号
		x.pop_back();
		n++;
	}
	cin>>offset;
	int ii=0;
	if(offset>=0)
		for(int i=1;i<=cnt1;i++)
		{
			a[i].start.ms+=offset;
			if(a[i].start.ms>=1000)
				a[i].start.s+=a[i].start.ms/1000,a[i].start.ms%=1000;
			if(a[i].start.s>=60)
				a[i].start.m+=a[i].start.s/60,a[i].start.s%=60;
			if(a[i].start.m>=60)
				a[i].start.h+=a[i].start.m/60,a[i].start.m%=60;
			if(a[i].start.h>=24)
				a[i].start.h%=24;
			a[i].finish.ms+=offset;
			if(a[i].finish.ms>=1000)
				a[i].finish.s+=a[i].finish.ms/1000,a[i].finish.ms%=1000;
			if(a[i].finish.s>=60)
				a[i].finish.m+=a[i].finish.s/60,a[i].finish.s%=60;
			if(a[i].finish.m>=60)
				a[i].finish.h+=a[i].finish.m/60,a[i].finish.m%=60;
			if(a[i].finish.h>=24)
				a[i].finish.h%=24;
		}
	if(offset<0)
		for(int i=1;i<=cnt1;i++)
		{
			a[i].start.ms+=offset;
			if(a[i].start.ms<0)
				a[i].start.s-=((-a[i].start.ms)/1000+1),a[i].start.ms=1000-(-a[i].start.ms)%1000;
			if(a[i].start.s<0)
				a[i].start.m-=((-a[i].start.s)/60+1),a[i].start.s=60-(-a[i].start.s)%60;
			if(a[i].start.m<0)
				a[i].start.h-=((-a[i].start.m)/60+1),a[i].start.m=60-(-a[i].start.m)%60;
			if(a[i].start.h<0)
				a[i].start.h=24-((-a[i].start.h)%24);
			a[i].finish.ms+=offset;
			if(a[i].finish.ms<0)
				a[i].finish.s-=((-a[i].finish.ms)/1000+1),a[i].finish.ms=1000-(-a[i].finish.ms)%1000;
			if(a[i].finish.s<0)
				a[i].finish.m-=((-a[i].finish.s)/60+1),a[i].finish.s=60-(-a[i].finish.s)%60;
			if(a[i].finish.m<0)
				a[i].finish.h-=((-a[i].finish.m)/60+1),a[i].finish.m=60-(-a[i].finish.m)%60;
			if(a[i].finish.h<0)
				a[i].finish.h=24-((-a[i].finish.h)%24);
		}
	int iii=0;
	int number=numberstart;
	for(int i=1;i<=cnt1;i++)
		cout<<number<<"\n",cout<<repair(a[i])<<"\n",cout<<word[i]<<"\n"<<(number==numberstart+n-1?"#":"\n"),number++;
}
```

虽然这段代码在本地运行不会出错，但是不能通过这道题。因为输入数据中行末有 `\r`，不能被 `getline` 正确识别并截断，因此需要在每次使用 `getline` 后对字符串删除最后一个字符（即 `pop_back()`）。

加入该操作，得到通过本题的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int numberstart;
struct instance
{
	int h,m,s,ms;
};
struct duration
{
	instance start,finish;
};
duration a[100001];
int cnt1;
string word[100001];
int cnt2;
int offset;
int toi(string str)
{
	int x=0;
	for(int i=0,l=str.size();i<l;i++)
		x=x*10+str[i]-'0';
	return x;
}
string lenbuild(int len,string str)
{
	while(str.size()<len)
		str.insert(0,"0");
	return str;
}
string build(instance x)
{
	return lenbuild(2,to_string(x.h))+":"+lenbuild(2,to_string(x.m))+":"+lenbuild(2,to_string(x.s))+","+lenbuild(3,to_string(x.ms));
}
string repair(duration x)
{
	return build(x.start)+" --> "+build(x.finish);
}
main()
{
	string x;
	getline(cin,x);//初始编号
	x.pop_back();
	n++;
	numberstart=toi(x);
	while(true)
	{
		cnt1++;
		cnt2++;
		string x;
		string temp;
		getline(cin,temp);//时间
		temp.pop_back();
		string str;
		string wordtmp;
		a[cnt1].start.h=toi(temp.substr(0,2));
		a[cnt1].start.m=toi(temp.substr(3,2));
		a[cnt1].start.s=toi(temp.substr(6,2));
		a[cnt1].start.ms=toi(temp.substr(9,3));
		a[cnt1].finish.h=toi(temp.substr(17,2));
		a[cnt1].finish.m=toi(temp.substr(20,2));
		a[cnt1].finish.s=toi(temp.substr(23,2));
		a[cnt1].finish.ms=toi(temp.substr(26,3));
		getline(cin,wordtmp);//说的第一句话
		wordtmp.pop_back();
		bool flag=false;
		while(true)
		{
			getline(cin,str);
			str.pop_back();
			if(str=="")//如果说话结束
				break;
			if(str=="#")//如果输入结束
			{
				flag=true;
				break;
			}
			wordtmp+="\n"+str;
		}
		word[cnt2]=wordtmp;
		if(flag) break;
		getline(cin,x);//下一个编号
		x.pop_back();
		n++;
	}
	cin>>offset;
	int ii=0;
	if(offset>=0)
		for(int i=1;i<=cnt1;i++)
		{
			a[i].start.ms+=offset;
			if(a[i].start.ms>=1000)
				a[i].start.s+=a[i].start.ms/1000,a[i].start.ms%=1000;
			if(a[i].start.s>=60)
				a[i].start.m+=a[i].start.s/60,a[i].start.s%=60;
			if(a[i].start.m>=60)
				a[i].start.h+=a[i].start.m/60,a[i].start.m%=60;
			if(a[i].start.h>=24)
				a[i].start.h%=24;
			a[i].finish.ms+=offset;
			if(a[i].finish.ms>=1000)
				a[i].finish.s+=a[i].finish.ms/1000,a[i].finish.ms%=1000;
			if(a[i].finish.s>=60)
				a[i].finish.m+=a[i].finish.s/60,a[i].finish.s%=60;
			if(a[i].finish.m>=60)
				a[i].finish.h+=a[i].finish.m/60,a[i].finish.m%=60;
			if(a[i].finish.h>=24)
				a[i].finish.h%=24;
		}
	if(offset<0)
		for(int i=1;i<=cnt1;i++)
		{
			a[i].start.ms+=offset;
			if(a[i].start.ms<0)
				a[i].start.s-=((-a[i].start.ms)/1000+1),a[i].start.ms=1000-(-a[i].start.ms)%1000;
			if(a[i].start.s<0)
				a[i].start.m-=((-a[i].start.s)/60+1),a[i].start.s=60-(-a[i].start.s)%60;
			if(a[i].start.m<0)
				a[i].start.h-=((-a[i].start.m)/60+1),a[i].start.m=60-(-a[i].start.m)%60;
			if(a[i].start.h<0)
				a[i].start.h=24-((-a[i].start.h)%24);
			a[i].finish.ms+=offset;
			if(a[i].finish.ms<0)
				a[i].finish.s-=((-a[i].finish.ms)/1000+1),a[i].finish.ms=1000-(-a[i].finish.ms)%1000;
			if(a[i].finish.s<0)
				a[i].finish.m-=((-a[i].finish.s)/60+1),a[i].finish.s=60-(-a[i].finish.s)%60;
			if(a[i].finish.m<0)
				a[i].finish.h-=((-a[i].finish.m)/60+1),a[i].finish.m=60-(-a[i].finish.m)%60;
			if(a[i].finish.h<0)
				a[i].finish.h=24-((-a[i].finish.h)%24);
		}
	int number=numberstart;
	for(int i=1;i<=cnt1;i++)
		cout<<number<<"\n",cout<<repair(a[i])<<"\n",cout<<word[i]<<"\n"<<(number==numberstart+n-1?"#":"\n"),number++;
}
```

---

## 作者：Escapism (赞：1)

非常优秀的字符串模拟题，感觉难度可以上一级。

# 题意

不难理解。

给定 $n$ 段字幕，每段字幕包含开始时间、结束时间和字幕内容，以换行分割，以 ``#`` 结尾。最后输入 $T$。

输出字幕在推后 $T$ 毫秒后的开始时间和结束时间。

# 思路

思路不算复杂，但是代码非常复杂。

首先获取开始时间和结束时间，换算成毫秒。把字幕原封不动的存起来。

输入 $T$ 后，把开始时间和结束时间都加上 $T$，然后按照题目要求的格式换算输出。把字幕原封不动输出。

# 代码

太丑了，不放了。

---

## 作者：Steve_xh (赞：1)

# 题面
[题目传送门](https://www.luogu.com.cn/problem/P7374)

**题目大意：**

就是改一下字幕输出时间，往后移 $t$ 毫秒，其他文字，编号等照常输出。

# 思路
初看这道题的我认为只是一道简单的字符串题目，但是在我试图写出代码时，我愣了。

**第一种思路**

由于每一个空行就是每条字幕之间的分隔符，所以我一开始是想**当遇到连续两个换行符时，就将下标加一**。但是本蒟蒻已经忘记怎么读入连续的换行符字符及转成字符串了，所以这个想法只能交给各位读者大佬实现了……

**第二种思路**

这个思路是我在闲着无聊时想出来的。我这里供奉一个相对较短的代码。其实想法就是**当读到非要改变的时间行时，直接输出。当读到要改变的行时，就处理**。那么具体怎么处理呢？我的想法是将所有时间转换成毫秒计算并加上 $t$，当要输出时再次转换成不同形式就行了。

**小知识：**

`sscanf` 的应用十分广泛，它用于格式读取字符串里的东西。写法和 `scanf` 差不多，感兴趣者可以参考[此处](https://blog.csdn.net/faihung/article/details/119325390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168226303016800227468954%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168226303016800227468954&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119325390-null-null.142^v86^wechat,239^v2^insert_chatgpt&utm_term=sscanf%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187)。本代码用到了这个函数，不过它的第一个参数是 `const char*` 类型的，所以要用到 `string` 成员函数 `::c_str()`。

# 注意事项（坑点）
有一个位置我被卡了半小时，就是它所描述的换行并不只是单纯的 `\n`，而是 `\r\n`，因此用 `getline()` 读入时要**去掉最后一位**。所以我就一直 `RE` 也找不出原因，直到我看了别的大佬的代码 QAQ。


# AC代码
``` cpp
#include<bits/stdc++.h>
#define int long long//后面转成毫秒数据可能会很大
using namespace std;
int t,n;
string a[10005];//用于储存每行的字符串
string s="";//临时变量
signed main(){
	for(n=1;s!="#";n++){
		getline(cin,s);
		s.pop_back();//去掉那万恶的'\r'
		a[n]=s;
	}
	--n;//为什么要减一？因为当最后一次读到#的时候也会执行++，因此要减回来。
	cin>>t;
	for(int i=1;i<=n;i++){
		if(a[i]=="#"||a[i].find(" --> ")==-1){//如果是最后一个字符或者没读到箭头（不是要处理的时间数据）
			cout<<a[i]<<endl;//直接输出
			continue;
		}
		int h1,m1,s1,ms1,h2,m2,s2,ms2;//分别指开始的时间和结束的时间
		int nh1,nm1,ns1,nms1,nh2,nm2,ns2,nms2;//同上，不过是更新后的时间
		sscanf(a[i].c_str(),"%lld:%lld:%lld,%lld --> %lld:%lld:%lld,%lld"
				,&h1,&m1,&s1,&ms1,&h2,&m2,&s2,&ms2);//将字符串格式化读入
		int sum1=ms1+s1*1000+m1*60000+h1*3600000+t,
			sum2=ms2+s2*1000+m2*60000+h2*3600000+t;//转换成毫秒
		nms1=sum1%1000,nms2=sum2%1000;
		ns1=sum1/1000%60,ns2=sum2/1000%60;
		nm1=sum1/60000%60,nm2=sum2/60000%60;
		nh1=sum1/3600000,nh2=sum2/3600000;//分别处理不同的时间单位
		printf("%02lld:%02lld:%02lld,%03lld --> %02lld:%02lld:%02lld,%03lld\n"
				,nh1,nm1,ns1,nms1,nh2,nm2,ns2,nms2);//最后格式化输出
	}
	return 0;
}
```

---

## 作者：fish_gugu (赞：1)

# 题意
输入字幕、时间等信息，把时间往后移 $t$ 秒，其他照常输出。

# 思路
这道题可以用两种思路来写。

#### 第一种思路
用一个结构体存起编号、时间、文字，然后处理更新时间。

#### 第二种思路
将所有东西存到一个字符串数组里。当读到不是要改变的数据时，原样输出，如果读到要改变的数据，就处理。那么如何处理呢？我打算模拟加减法的方法，用**借位进位**来处理。

# 坑点
有个地方我卡了好几天才过了，就是因为题目输入的换行不只是 `\n`，而是 `\r\n`，因此读入时要**去掉最后一位**。

# AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int cnt,t; //cnt表示数据的行数
long long h1,m1,s1,ms1,h2,m2,s2,ms2; //开始时间和结束时间
string a[105];
string s;

void n_Time() //更新时间
{
    if(t < 0)
    {
        t *= -1;
        if(ms1 - t >= 0) ms1 -= t;
        else
        {
            ms1 -= t;
            while(ms1 < 0) ms1 += 1000,s1 -= 1; //毫秒借位
            if(s1 < 0)
            {
                while(s1 < 0) s1 += 60,m1 -= 1; //秒借位
                if(m1 < 0)
                {
                    while(m1 < 0) m1 += 60,h1 -= 1; //分借位
                }
            }
        }
        if(ms2 - t >= 0) ms2 -= t;
        else
        {
            ms2 -= t;
            while(ms2 < 0) ms2 += 1000,s2 -= 1; //毫秒借位
            if(s2 < 0)
            {
                while(s2 < 0) s2 += 60,m2 -= 1; //秒借位
                if(m2 < 0)
                {
                    while(m2 < 0) m2 += 60,h2 -= 1; //分借位
                }
            }
        }
        t *= -1;
    }
    else
    {
        if(ms1 + t < 1000) ms1 += t;
        else
        {
            ms1 += t;
            while(ms1 >= 1000) ms1 -= 1000,s1 += 1; //毫秒进位
            if(s1 >= 60)
            {
                while(s1 >= 60) s1 -= 60,m1 += 1; //秒进位
                if(m1 >= 60)
                {
                    while(m1 >= 60) m1 -= 60,h1 += 1; //分进位
                }
            }
        }
        if(ms2 + t < 1000) ms2 += t;
        else
        {
            ms2 += t;
            while(ms2 >= 1000) ms2 -= 1000,s2 += 1; //毫秒进位
            if(s2 >= 60)
            {
                while(s2 >= 60) s2 -= 60,m2 += 1; //秒进位
                if(m2 >= 60)
                {
                    while(m2 >= 60) m2 -= 60,h2 += 1; //分进位
                }
            }
        }
    }
    return;
}

int main()
{
    for(cnt = 1;s != "#";cnt++)
    {
        getline(cin,s);
        s.pop_back(); //去掉该死万恶的'\r'
        a[cnt] = s;
    }
    cin >> t;
    for(int i = 1;i <= cnt;i++)
    {
        if(a[i] == "#" || a[i].find("-->") == -1) //如果这行数据不是"#"或包含箭头（对应时间数据）则原样输出
        {
            cout << a[i] << endl;
        }
        else //输出时间
        {
            sscanf(a[i].c_str(),"%lld:%lld:%lld,%lld --> %lld:%lld:%lld,%lld",&h1,&m1,&s1,&ms1,&h2,&m2,&s2,&ms2); //格式化读入字符串
            n_Time();
            printf("%02lld:%02lld:%02lld,%03lld --> %02lld:%02lld:%02lld,%03lld\n",h1,m1,s1,ms1,h2,m2,s2,ms2);
        }
    }
    return 0; 
}
```

---

## 作者：linyukun (赞：1)

## 1. 前言
本文的分析会比较详细，代码注释比较多，麻烦一定**仔细全部看完**，有异议、不懂或认为可以优化请私信反馈呢。  

## 2. 题目解析：
首先，这是一道比较纯的模拟题，按题目要求来即可。  

输入一个字幕，我们将它分为五部分:
* 字幕编号 ——> 直接输出。
* 字幕时间 ——> 加 $T$ 毫秒。
* 字幕内容 ——> 直接输出。
* “ # ” 结束输入。
* $T$ 在最后。

## 3.提示要点：
* 题目给了我们求编号的捷径：**对于字幕编号，若第一段的编号为 $X$，则第 $i$ 段必定为 $X+i-1$ 。**
* 字幕内容有多行，一定**全部存储**。
* 字幕时间要**转化为毫秒来计算**，输出时转回去。
* 注意**可以使用数组分别存储**。

## 4.代码写作：
理论存在，实践开始。  

代码理有详细的注释幺~
```cpp
#include<bits/stdc++.h>
using namespace std;
string h;
long long x,n,m,k[15];
struct zimu{//存字幕（其实这里是便于理解，数组分别存储更方便呢）
    string s;//内容
	long long l,r;//开始，结束时间
}a[10005];
void ll_to_string(long long l){//由毫秒转换为题面的格式
	//现在是l毫秒
	k[8]=l%10;
	l/=10;
	k[7]=l%10;
	l/=10;
	k[6]=l%10;
	l/=10;//现在是l秒
	k[5]=(l%60)%10;
	k[4]=(l%60)/10;
	l/=60;//现在是l分钟
	k[3]=(l%60)%10;
	k[2]=(l%60)/10;
	l/=60;//现在是l小时
	k[1]=l%10;
	k[0]=l/10;
	return;
}
int main(){
	cin>>h;
	while(1){
		if(h[0]=='#')break;
		x=0;
        for(int i=0;i<h.size();i++){//若x不是结束，就存。【仅保留最后一组的x，其余可递推】
            x*=10;
            x+=h[i]-'0';
        }
		n++;//字幕组数（1始）
		cin>>a[n].s;//输入开始时刻，记录于l
		a[n].l=3600000*((a[n].s[0]-'0')*10+a[n].s[1]-'0')+60000*((a[n].s[3]-'0')*10+a[n].s[4]-'0')+1000*(10*(a[n].s[6]-'0')+a[n].s[7]-'0')+100*(a[n].s[9]-'0')+10*(a[n].s[10]-'0')+a[n].s[11]-'0';
		//提取第一个2位，进制换算；提取第二个2位，进制换算......（最后是提取3个数）
		cin>>a[n].s;//吞掉“-->”
		cin>>a[n].s;//输入结束时刻，记录于r
		a[n].r=3600000*((a[n].s[0]-'0')*10+a[n].s[1]-'0')+60000*((a[n].s[3]-'0')*10+a[n].s[4]-'0')+1000*(10*(a[n].s[6]-'0')+a[n].s[7]-'0')+100*(a[n].s[9]-'0')+10*(a[n].s[10]-'0')+a[n].s[11]-'0';
        a[n].s="";//清空，上方是同一个string，有残留
		while(1){
			getline(cin,h);//整行读入
			h.pop_back();//吃掉\r(啊呜)
			if((h[0]>='0'&&h[0]<='9')||h[0]=='#'){
                break;
                //0-9数字：这是下一行的编号
                //#：结束了
                //这样跳出时，h不是编号就是#，#会在第一句就结束外层大循环，所以后面（32-35）可以直接转换。
            }
			a[n].s=a[n].s+h;
			a[n].s=a[n].s+"\n";
			/*
			这里解释一下储存：
			其实很简单，像输入一样，先存一行，换一行，再存一行，这样输出就很省事。但怎样换行呢？
			在字符串里，我们可以在两句话间插入“\n”，输出时就是换行。
			这两句就是：存一句+换行符分开。
			*/
		}
	}
	cin>>m;
	for(int i=1;i<=n;i++){
		cout<<x-n+i<<"\n";//逆推题目条件可得
		ll_to_string(a[i].l+m);
		cout<<k[0]<<k[1]<<":"<<k[2]<<k[3]<<":"<<k[4]<<k[5]<<","<<k[6]<<k[7]<<k[8]<<" --> ";//注意标点格式，尤其最后是","
		ll_to_string(a[i].r+m);
		cout<<k[0]<<k[1]<<":"<<k[2]<<k[3]<<":"<<k[4]<<k[5]<<","<<k[6]<<k[7]<<k[8];
		cout<<a[i].s;
	}
	cout<<'#';
	return 0;
}
```

## 5.总结鸣谢：
#### 本题是一道考验耐心细心的模拟，可以用来熟练代码或练手，难度适中。

#### 另：感觉不错麻烦点个赞，还有感谢管理大大的的审核帮助。

---

## 作者：fish_shit (赞：0)

# 题意
输入每个弹幕的编号、时间的头和尾、以及弹幕内容。

输入弹幕部分以 `#` 结束，在代码末尾再输入一个 $T$，代表将所有时间都向后增加 $T$ 毫秒。

# 思路
其实很简单，按照题意模拟就行了，将所有时间都化成一个整数，再将这个整数加上 $T$ 的值再化为题目要求的样子，其他东西按输入原样输出。

注意：$T$ 可能为负数。

代码就不放了。

---

## 作者：Oracynx (赞：0)

## P7374 [COCI2018-2019#5] Titlovi 题解

非常简单的一道模拟题。

按照题目的要求，先读入 $x$ 和开始结束的时间。

后面的字幕用循环读入，在这里我讲一下如何判断结束。

```cpp
for (;;)
{
    std::cin.getline(p[n].s[p[n].cnt], MaxN); // 读入 1 行字符串
    if (p[n].s[p[n].cnt + 1][0] == '\0')      // 读入了空字符串
    {
        p[n].cnt++;                           // 新增字符串
        break;
    }
    else if (p[n].s[p[n].cnt + 1][0] == '#')  // 全部读入完毕
    {
        goto move;                            // 使用 goto 退出循环
    }
    p[n].cnt++;                               // 新增字符串
}
```

对了，我们将开始时间化为以毫秒作为单位的时间。

```cpp
p[n].all_s = 60 * 60 * 1000 * p[n].hs + 60 * 1000 * p[n].ms + 1000 * p[n].ss + p[n].ts;
p[n].all_e = 60 * 60 * 1000 * p[n].he + 60 * 1000 * p[n].me + 1000 * p[n].se + p[n].te;
```

接着，再给每一段字幕加上 $T$。

最后，再使用这——超——长——的——输出语句输出时间，循环输出字幕即可。

```cpp
printf("%02lld:%02lld:%02lld,%03lld --> %02lld:%02lld:%02lld,%03lld", p[n].all_s / (60 * 60 * 1000),
       (p[n].all_s % (60 * 60 * 1000) / (60 * 1000)), ((p[n].all_s % (60 * 60 * 1000) % (60 * 1000) / 1000)),
       ((p[n].all_s % (60 * 60 * 1000) % (60 * 1000) % 1000)), p[n].all_e / (60 * 60 * 1000),
       (p[n].all_e % (60 * 60 * 1000) / (60 * 1000)), ((p[n].all_e % (60 * 60 * 1000) % (60 * 1000) / 1000)),
       ((p[n].all_e % (60 * 60 * 1000) % (60 * 1000) % 1000)));
```

简单原理就是除以进制，然后后面的每一个都对上一个的进制取模即可。

这可能就是本题代码中**相对**来说最难的代码了。

将上述代码整合即为 AC 答案。

---


# [COCI 2018/2019 #6] Lun

## 题目描述

现有一个判断某种银行卡号是否合法的算法：

1. 从倒数第二位开始从右往左，每隔一个数位就将其乘 $2$，否则保留原数位不变。
2. 将被乘 $2$ 的数位分别计算其数位之和。
3. 计算经过操作之后的所有数位之和，并将其乘 $9$ 再对 $10$ 取模，检验其是否等于最后一位（即银行卡号的校验码）。

若待验证卡号为 $79927398713$，则判断方法如下：

|银行卡号各数位|$7$|$9$|$9$|$2$|$7$|$3$|$9$|$8$|$7$|$1$|$3$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|每隔一位乘 $2$（从倒数第二位开始向左）|$7$|$\red {18}$|$9$|$\red 4$|$7$|$\red 6$|$9$|$\red {16}$|$7$|$\red 2$| -|
|计算得到的数位和并累加|$7$|$\green 9$|$9$|$4$|$7$|$6$|$9$|$\green 7$|$7$|$2$|$=67$|

将得到的和 $67$ 乘 $9$ 再对 $10$ 取模，得到 $67 \times 9 \bmod 10=3$。其中 $3$ 为该银行卡号校验码，因此原卡号合法。

现有一个缺失一个数位的银行卡号，请根据上述算法在缺失数位处补充一个合适的数位，使得得到的银行卡号合法。

## 说明/提示

#### 数据规模与约定

对于 $50\%$ 的数据，缺失的数位位于银行卡号校验码处，即字符 `x` 位于字符串最后一位。

对于 $100\%$ 的数据，$1 \le N \le 100$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #6](https://hsin.hr/coci/archive/2018_2019/contest6_tasks.pdf)  _T1 Lun_。**

## 样例 #1

### 输入

```
11
7992739871x```

### 输出

```
3```

## 样例 #2

### 输入

```
5
x2464```

### 输出

```
5```

## 样例 #3

### 输入

```
10
93380x1696```

### 输出

```
1```

# 题解

## 作者：zct_sky (赞：3)

### 思路：
$x$ 有两种情况：

情况一： $x$ 在最后一位；

情况二： $x$ 不在最后一位。

如果是情况一，就按照题目直接计算 $x$ 。

如果是情况二，则从 $0 ∼ 9$ 枚举 $x$ ，再计算校验码，如果校验码等于最后一位，就输出 $x$ 。

### 代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int l,x,b[110]; 
string a;
int main(){
	cin>>l>>a;//输入 
	for(int i=0;i<l;i++)//找出哪一位是x，并把其余的数存进数组 
	    if(a[i]=='x') x=i;
	    else b[i]=a[i]-'0';
	if(x==l-1){//如果x是最后一位 
		int s=0;
		bool f=(l-1)%2;
		for(int i=0;i<l-1;i++){//计算x 
			if(f^(i%2)){
				b[i]*=2;
				int sum=0;
				while(b[i]) sum+=b[i]%10,b[i]/=10;
				s+=sum;
			}else s+=b[i];
		}
		cout<<s*9%10;//输出 
	}else{//如果x不是最后一位 
		int s;
		bool f=(l-1)%2;
		for(int k=0;k<10;k++){//从0~9枚举x 
			s=0;
			b[x]=k;
			for(int i=0;i<l-1;i++){//计算校验码 
	    		if(f^(i%2)){
	    			int t=b[i];
	    			b[i]*=2;
	    			int sum=0;
	    			while(b[i]) sum+=b[i]%10,b[i]/=10;
	    			b[i]=t;
	    			s+=sum;
	    		}else s+=b[i];
	    	}
	    	if(s*9%10==b[l-1]){//如果校验码等于最后一位，输出x 
	    		cout<<k;
	    		return 0;
			}
		}
	}
	return 0; 
}
```

---

## 作者：pandaSTT (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P7379)

## 思路

**COCI** 的题不用看题都知道，一定是模拟……

问题求**银行卡号的缺失数位**，分析题目，发现银行卡号的数位可分为两种：

>1. 银行卡号校验码
>
>2. 其余数位

所以我们分开处理两种情况。

### (一).银行卡号校验码

题目给出了银行卡号校验码的求法：

1. **从倒数第二位**开始从右往左，每隔一个数位就将其乘 2，否则保留原数位不变。

2. 将被乘 2 的数位分别计算其数位之和。

3. 计算经过操作之后的所有数位之和，并将其乘 9 再对 10 取模，即银行卡号的校验码。

因此我们按照题目给的求法求出银行卡号校验码即可。

#### 注意

如果按照奇偶性判断该数位是否乘 2，那么**应该倒着计数，且从倒数第二位开始。**

### (二).其余数位

对于其余数位，我们可以枚举：
其余数位的范围为 $ 1-9 $，因此我们只需要从小到大判断每种情况求出的校验码是否符合规范即可。

# 代码

```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,x;
  string s;
  int main(){
      cin>>n>>s;
      s=' '+s;
      for(int i=1;i<=n;i++){
          if(s[i]=='x'){
              x=i;
              break;
          }	
      }
      if(x==n){
          int sum=0,tot=1;
          for(int i=n-1;i>=1;i--){
              tot++;
              if(tot&1){
                  sum+=s[i]-'0';
              }
              else{
                  int a=(s[i]-'0')*2;
                  sum+=(a%10+a/10);
              }
          }
          sum*=9;
          sum%=10;
          cout<<sum;
      }
      else{
          for(int j=0;j<=9;j++){
              s[x]=j+'0';
              int sum=0,tot=1;
              for(int i=n-1;i>=1;i--){
                  tot++;
                  if(tot&1){
                      sum+=s[i]-'0';
                  }
                  else{
                      int a=(s[i]-'0')*2;
                      sum+=(a%10+a/10);
                  }
              }
              sum*=9;
              sum%=10;
              if(sum==s[n]-'0'){
                  cout<<j;
                  return 0;
              }
          }
      }
      return 0;
  }
```


---

## 作者：EuphoricStar (赞：2)

## 思路

模拟题。

从小到大枚举缺失的数位可能的值，并按照题中所述方法验证。

如果卡号合法，就代表这个值正确，打印这个值。

由于枚举时是从小到大枚举的，所以输出的答案一定是最小的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, xp;
string s;

int main() {
    ios::sync_with_stdio(0);
    cin >> n >> s;
    for (int i = 0; i < n; ++i) {
        if (s[i] == 'x') {
            xp = i;
            break;
        }
    }
    for (int i = 0; i < 10; ++i) {
        string t = s;
        t[xp] = '0' + i;
        for (int j = n - 2; j >= 0; j -= 2) {
            int x = (t[j] - '0') * 2, sum = 0;
            while (x) {
                sum += x % 10;
                x /= 10;
            }
            t[j] = '0' + sum;
        }
        int sum = 0;
        for (int i = 0; i < (n - 1); ++i) {
            sum += t[i] - '0';
        }
        sum = (sum * 9) % 10;
        if (sum == t[n - 1] - '0') {
            cout << i;
            break;
        }
    }
    return 0;
}
```


---

## 作者：hyc1026 (赞：1)

本题很明显，是一道模拟题。

本题经典操作为分类处理。详见代码。

此题以`x`分类，分两种情况。

第一种是求校验码，此时直接计算即可。注意题意说从**倒数第二位开始从右往左，每隔一个数位就将其乘 $2$，否则保留原数位不变。**

第二种求普通数位，此时需要从小到大枚举，并计算当时的校验码是否合法，如果是，直接输出并结束，因为题目要求最小。

### 核心代码:
```cpp
//第一种：

int sum = 0;
for (int i=n-2; i>=0; i-=2) num[i] *= 2; //将所有需要乘以2的数乘2。
for (int j=0; j<n-1; j++)
{
	sum = sum + num[j] / 10 + num[j] % 10;
} //基础的计算。
int ans = sum * 9;
cout << ans % 10; //输出答案，注意先乘9，再对10取模。


//第二种：

for (int i=0; i<=9; i++)
{
	num[idnumber] = i;
	int sum = 0;
	for (int j=n-2; j>=0; j-=2) num[j] *= 2; //同第一种情况，将所有需要乘以2的数乘2。
	for (int j=0; j<n-1; j++)
	{
		sum = sum + num[j] / 10 + num[j] % 10;
	} //基础的计算。
	int ans = sum * 9;
	ans %= 10;
	if (ans == num[n - 1]) //进行判断。
	{
		cout << i;
		return 0; //也可以写成break。
	}
	for (int j=n-2; j>=0; j-=2) num[j] /= 2; //数组复原！这点如果不做，数组就不会回到初始状态，此时你还没有枚举到想要的值。
}
```

### AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int num[101];

int main()
{
	int n;
	string s;
	cin >> n >> s;
	int idnumber = 0;
    
	for(int i=0; i<n; i++)
	{
		if(s[i] != 'x')	num[i] = s[i] - 48;
		else //进行先前操作，处理。为以后计算做铺垫。
		{
			num[i] = -1e9;
			idnumber = i; //使用变量idnumber记录x的位置。
		}
	}
	
	if(idnumber == n - 1) /*操作第一种*/   
	else /*操作第二种*/
	return 0;
}
```

---

## 作者：tZEROちゃん (赞：1)

[珂能会有更好的阅读体验](https://www.luogu.com.cn/blog/tearing/solution-p7379)。

### 在下文以及代码中会用到的表述

- $place$：$\tt{x}$ 的位置，使用 `s.find()` 函数计算。
- $len(s)$：字符串 $s$ 的长度，使用 `s.size() / s.length()` 函数计算。

### Solution

我们先读入一个字符串 $s$，将 $s$ 的每一个元素转化为数字存在 $a$ 数组里，如果是 $s_i$ 是 $\tt{x}$，那么 $a_i$ 可以为任意一个 $\ge 10$ 的数（想一想，为什么 $^{[1]}$)，那么在代码里，我使用的是 $114514$ 这个数（

[代码](https://www.luogu.com.cn/paste/bz929c5m)。

接下来，我们分两种情况考虑。

#### 情况 #1 - 当 $\tt{x}$ 在校验码位上，即 $place = len(s)$。

按照题目要求校验码即可，详见 [代码](https://www.luogu.com.cn/paste/rrl679av)。

期望得分 25，实际得分 25。

#### 情况 #2 - 当 $\tt{x}$ 不在校验码上

这部分比情况 #1 略微复杂些。

可以考虑从 $0 \sim 9$ 枚举，**一定要注意数位可以是 $\textbf{0}$**$ $，然后按照同样的方法计校验码，判断校验码是否与输入的最后一位相同即可，相同则输出当前枚举的数。

[代码](https://www.luogu.com.cn/paste/33ytdvuk)。

期望得分 50，实际得分 50，可以通过本题。

### Annotation

$[1]$（原文：想一想，为什么）：显然，由题可知每一位都是 $0\sim 9$ 的正整数，任意 $\ge 10$ 的数都可以区别于其他数。

---

## 作者：_lfxxx_ (赞：1)

这题细节很多，要注意细节。~~这题卡了本蒟蒻好久。~~

## 思路：
分两种情况：

第一种： $x$ 在最后一位。这个简单，没什么好说的，按照题目算法算即可。

第二种： $x$ 不在最后一位。这个也很好解决，先把其他位的都算上，再去枚举$0∼9$。

## 通俗易懂的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,s,c,x;（定义main函数外面默认初值为0）
string a;
int main(){
    cin>>n>>a;
    if(n%2)//这里我从头判定是否乘2
    	c=1;
    else
    	c=2;
    for(i=0;i<n;i++){
    	if(a[i]!='x'&&i!=n-1)
    	    s+=c*(a[i]-'0')/10+c*(a[i]-'0')%10;//算总和
    	if(a[i]=='x'&&i!=n-1)
            x=c;//如果x在中间，记录当前的倍数
    	if(c==1)//为下一个数做准备
    	    c=2;
    	else
    	    c=1;
    }
    if(x==0)
        cout<<s*9%10;//x是0说明不在中间，直接输出
    else
	for(i=0;i<=9;i++)
	    if((s+i*x/10+i*x%10)*9%10==a[n-1]-'0'){
                cout<<i;
		break;
	    }//从0枚举往上找
    return 0;
}
```

---

## 作者：ZBAA_MKC (赞：0)

#### 思路分析

分两种情况来考虑。

情况一：`x` 在校验码的位置

直接按题目描述计算即可。

该部分代码：

```cpp
int sum = 0;
for (int i = n - 2; i >= 0; i -= 2)
{
	num[i] *= 2;
}
for (int i = 0; i < n - 1; i++)
{
	sum += num[i] / 10;
	sum += num[i] % 10;
}
cout << sum * 9 % 10;
```

情况二：`x` 不在校验码的位置

枚举从 $0$ 到 $9$ 的所有数字，看每一个数字填进去后号码是否合法，如果合法就立即输出并结束程序，因为题目要求输出最小。

验证合法性的代码同上部分。

该部分代码：

```cpp
for (int i = 0; i <= 9; i++)
{
	num[id] = i;
	int sum = 0;
	for (int j = n - 2; j >= 0; j -= 2)
	{
		num[j] *= 2;
	}
	for (int j = 0; j < n - 1; j++)
	{
		sum += num[j] / 10;
		sum += num[j] % 10;
	}
	int xx = sum * 9 % 10; 
	if (xx == num[n - 1])
	{
		cout << i;
		return 0;
	}
	for (int j = n - 2; j >= 0; j -= 2)
	{
		num[j] /= 2;
	}
}
```

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int num[105];
int main()
{
    int n;
    cin >> n;
	string s;
	cin >> s;
	int id;
	for (int i = 0; i < n; i++) //预处理
	{
		if (s[i] != 'x')
		{
			num[i] = s[i] - '0';
		}
		else
		{
			num[i] = -1;
			id = i;
		}
	}
	if (id == n - 1) //情况一
	{
		int sum = 0;
		for (int i = n - 2; i >= 0; i -= 2)
		{
			num[i] *= 2;
		}
		for (int i = 0; i < n - 1; i++)
		{
			sum += num[i] / 10;
			sum += num[i] % 10;
		}
		cout << sum * 9 % 10;
	}
	else //情况二
	{
		for (int i = 0; i <= 9; i++)
		{
			num[id] = i;
			int sum = 0;
			for (int j = n - 2; j >= 0; j -= 2)
			{
				num[j] *= 2;
			}
			for (int j = 0; j < n - 1; j++)
			{
				sum += num[j] / 10;
				sum += num[j] % 10;
			}
			int xx = sum * 9 % 10; 
			if (xx == num[n - 1])
			{
				cout << i;
				return 0;
			}
			for (int j = n - 2; j >= 0; j -= 2) //一定别忘重置数组
			{
				num[j] /= 2;
			}
		}
	}
	return 0;
}

```


---

## 作者：Eason_AC (赞：0)

## Content
判断使一个长度为 $n$ 的银行卡号码（有一个空缺）合法，空缺里面填入的最小数字。

**数据范围：$n\in[1,100]$。**
## Solution
由于只有一个空缺，因此我们可以考虑直接枚举 $0\sim 9$，一旦试出使银行卡号码合法的数字直接输出答案即可。

判断合法建议使用函数，见以下的代码实现。
## Code
```cpp
int n;
string s;

void judge(string s, int place) {
	int sum = 0;
	for(int i = n - 2; i >= 0; --i) {
		if(!(((n - 2) - i) % 2)) {
			int x = (s[i] - '0') * 2;
			int num = x / 10 + x % 10;
			sum += num;
		} else {
			int x = s[i] - '0';
			sum += x;
		}
	}
	if(sum * 9 % 10 == (s[n - 1] - '0')) {printf("%c", s[place]); exit(0);}
	return;
}

int main() {
	scanf("%d", &n); cin >> s;
	for(int i = 0; i < n; ++i) {
		if(s[i] == 'x') {
			for(int j = 0; j <= 9; ++j) {
				s[i] = j + '0';
				judge(s, i);
			}
		}
	}
	return 0;
}
```

---


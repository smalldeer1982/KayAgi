# [COCI 2010/2011 #5] KOŠARKA

## 题目描述

Slavko 已经开始关注 NBA 了。比赛持续时间正好是 $48$ 分钟。当一场比赛最后会显示统计数据。每当一个球队得分，Slavko 都会记下。他很好奇每个队领先的持续时间。

## 说明/提示

**【样例解释#1】**

队伍 $1$ 在 $20$ 分钟整的时候得一分，比分 $1:0$，处于领先地位。

后面 $28$ 分钟队伍 $2$ 没有进球，故队伍 $1$ 一直保持着领先地位。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 100$，$0\le$ 分钟数 $\le 47$，$0\le $ 秒数 $\le 59$。

**【说明】**

本题分值按 COCI 原题设置，满分 $50$。

题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T2 KOŠARKA**_。

## 样例 #1

### 输入

```
1
1 20:00 ```

### 输出

```
28:00
00:00 
```

## 样例 #2

### 输入

```
3
1 01:10
2 21:10
2 31:30 ```

### 输出

```
20:00
16:30 ```

## 样例 #3

### 输入

```
5
1 01:10
1 02:20
2 45:30
2 46:40
2 47:50 ```

### 输出

```
45:30
00:10 ```

# 题解

## 作者：ImposterAnYu (赞：4)

# 解析
这道题可以用一个简单的模拟来做。

我们用 $x_{i}$ 表示全场第 $i$ 次得分的队伍，$a_{i}$ 表示第 $i$ 次输入时间的分数，$b_{i}$  表示第 $i$ 次输入时间的秒数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m = 1,i,x[105],a[105],b[105],ad,bd,s,t,st;
int main(){
    cin >> n;
    for(i = 1; i <= n; i++){
        scanf("%d %d:%d",&x[i],&a[i],&b[i]);
    }
```

紧接着，我们可以直接用 for 循环，直接模拟每一秒发生的事（是否在这一秒有得分记录）。

注意，$i$ 不能从 $1$ 开始，因为有两个数据点会让一个队伍在 $00:00$ 得分！

```cpp
for(i = 0; i <= 2880; i++){
        if(ad < bd){
            t++;
        }else if(ad > bd){
            s++;
        }
        if(i == a[m] * 60 + b[m]){
            (x[m] == 1? ad++ : bd++);
            m++;
        }
    }
```

最后，就可以直接输出了。

# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m = 1,i,x[105],a[105],b[105],ad,bd,s,t,st;
int main(){
    cin >> n;
    for(i = 1; i <= n; i++){
        scanf("%d %d:%d",&x[i],&a[i],&b[i]);
    }
    for(i = 0; i <= 2880; i++){//模拟 48 分钟内的得分情况。 
        if(ad < bd){
            t++;
        }else if(ad > bd){
            s++;
        }//如果一队比另一队领先，领先队的领先时间 + 1秒。 
        if(i == a[m] * 60 + b[m]){
            (x[m] == 1? ad++ : bd++);
            m++;
        }//如果有新的得分情况，就根据得分队伍来加分。 
    }
    printf("%02d:%02d\n%02d:%02d",s / 60,s % 60,t / 60,t % 60);
	//"%02d" 可以在输出的整数位数不足 2 位的时候，将不足的位用 0 补齐。 
    return 0;
}
```


---

## 作者：CRH2C (赞：4)

# 一.思路
我们可以先把时间换成以**秒**为单位的，然后在枚举每一秒时谁领先。
# 二.重要点
- 我们可以用 string 读入时间，再用一个函数以**秒**为单位提取出来（在程序中的函数名: tiqu ）。
- 如果双方分数是一样的，那么谁都不领先（在程序中的函数名: out_put ）。
- 输出的时候要填充 $0$ ，就建一个函数。
# 三.实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,fen[3],shijian[110][3],ta,tb;string s;
void tiqu(string x,int th,int player){// x ->读入的时间 th ->第几个(i) player ->哪一方的球了
	shijian[th][player]=int(x[0]-48)*600+int(x[1]-48)*60+int(x[3]-48)*10+int(x[4]-48);
}//转格式( x[0] 是分钟的十位，x[1] 是分钟的个位，x[3] 是秒的十位，x[4]是秒的个位)
void out_put(int t){
	int x=t/60,y=t%60;
	if(x/10==0) cout<<0;//若 x (分钟)是个位数，要输出 '0'
	cout<<x<<":";
	if(y/10==0) cout<<0;//若 y (秒钟)是个位数，也要输出 '0'
	cout<<y<<endl;
}//输出 
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>p>>s;
		int op=1;
		if(p==1) op=2;
		tiqu(s,i,p);//转换为以秒为单位的时间
		shijian[i][op]=4800;//为了防止在 0 秒进球，然后有BUG
	}
	for(int i=0;i<60*48;i++){
		fen[0]=fen[1]+fen[2];
		if(shijian[fen[0]][1]==i) fen[1]++;
		if(shijian[fen[0]][2]==i) fen[2]++;
       //判断在这一秒是否得分
		if(fen[1]>fen[2]) ta++;
		if(fen[2]>fen[1]) tb++;
      //判断分数上的领先
	}//枚举每 1 秒
	out_put(ta);//输出 a 方的领先时间
	out_put(tb);//输出 b 方的领先时间
	return 0;
}

```

---

## 作者：zhang1234 (赞：2)

## 1.思路

我们先将时间点都转换成秒，当一个队领先时，将这个事件到下一个事件之间的间隔时间加到它特定的计数器中。

## 2.细节

- 我们可以运用 scanf 可以格式化输入的特性，依照格式输入。

- 因为在双方都没有得分前谁的领先时间都不增加，而且最后一个事件和比赛结束时间之间的间隔算到领先队伍头上。所以可以得出结论：每当一个事件发生后，并将本次事件参与计算后的领先队伍的持续时间是本次事件到下次事件之间的间隔时间。

- 要把 $b_{n+1}$ 赋值为 $2880$ ,否则最后一个事件就不会计入结果。

## 3.代码

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int a[102],b[102];//b是装时间的数组

int main()
{
	int n;
	 
	scanf("%d",&n);
	
	for(int i = 1;i <= n;i++)
	{
		int c;
		scanf("%d %d:%d",&a[i],&b[i],&c);
		b[i] = b[i] * 60 + c;
	}
	int sum1 = 0,sum2 = 0,sum11 = 0,sum22 = 0;
	b[n + 1] = 2880;
	for(int i = 1;i <= n;i++)
	{
		if(a[i] == 1)
		{
			sum1++;
		}
		else
		{
			sum2++;
		}
		if(sum1 > sum2)
		{
			sum11 += b[i + 1] - b[i];
		}
		else if(sum1 < sum2)
		{
			sum22 += b[i + 1] - b[i];
		}
	}
	printf("%02d:%02d\n%02d:%02d", sum11 / 60, sum11 % 60, sum22 / 60, sum22 % 60);
	return 0;
}
```


---

## 作者：CarryQwQ (赞：1)

## 题目分析

[题目传送门](https://www.luogu.com.cn/problem/P7632)

[想要更好的阅读体验？](https://www.luogu.com.cn/blog/ThisIsCYF/solution-p7632)

这题是一道简单的模拟题。

对于输入进来的每队得分时间转换成秒存储，之后的处理则是一秒一秒的模拟。

哪一队伍的得分高，哪一队伍持续领先地位的时间就增加。

输入形如 ```xx:xx``` 的时间表达式可以用scanf语句来输入，像这样：

```
scanf("%d %d:%d", &a, &b, &c);
```
这样就可以读入整型数字而不需要为了输入 ```':'``` 另开一个字符变量。

对于要求输出时间补充前导零，在这里介绍两种方法。

1.可以尝试用 ```printf``` 语句中的整型格式控制来实现,写成这样的语句：

```cpp
printf("%0.2d:%0.2d\n%0.2d:%0.2d", a, b, c, d);
```
在形如 ```%0.kd``` 的格式控制中将 $k$ 替换成任何数字即可实现不满 $k$ 位自动补充前导零的作用。

2.可以使用包含在头文件 ```#include<iomanip>``` 中的函数补充前导零。

利用 ```setfill``` 函数和 ```setw``` 函数来实现补充前导零。

```cpp
cout << setfill('0') << setw(2) << a << ':' << setfill('0') << setw(2) << b << endl;
cout << setfill('0') << setw(2) << c << ':' << setfill('0') << setw(2）<< d << endl;
```
在 ```setfill()``` 的括号中写入你想要填充的**字符**，注意只能是字符！

在 ```setw()``` 的括号中写入你想要不满几位补充前导零（像题目中就是不二位补充前导零，写入 2，```setw(2)```）

到这里所以问题就解决了，程序按照此分析编写。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, t[3000], tmp, m, s, Ft, St, Fs, Ss;
void Pn_zh(int n) {//将秒数转化成 xx:xx 的形式输出
	printf("%0.2d:%0.2d\n", n/60, n%60);
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d %d:%d", &tmp, &m, &s);
		t[m*60+s] = tmp;
	}
	for (int i = 0; i <= 2880; i++) {//比赛总时间为 48*60=2880 秒
		if (Fs > Ss) Ft++;
		else if (Ss > Fs) St++;
		if (t[i] == 1)Fs++;
		else if (t[i] == 2) Ss++;
	}
	Pn_zh(Ft);
	Pn_zh(St);
}
```




---

## 作者：Nygglatho (赞：1)

我们可以把每一个事件的时间转换成秒，这样就会更方便。

接着，事件就直接在数组内记录下去即可。

由于两种球队进球都有可能，所以要用 $t$ 判断，如果为 $1$，那么就是第一组，否则就是第二组。
```cpp
int zh_s(int m, int s) {return m * 60 + s;}//转换成秒
void zh_m(int& m, int& s) {m = s / 60; s %= 60;}//转换成分
int n, m1, m2, s1, s2;
int x_fens, y_fens;
int m_tmp, s_tmp;
int t;
int sj[2881];
```
```
for (int i = 1; i <= n; i++) {
	scanf ("%d %d:%d", &t, &m_tmp, &s_tmp);
	sj[zh_s(m_tmp, s_tmp)] = t;
}
```
那么这样子，我们就可以从 $0$ 秒至 $2880$ 秒（即 $48$ 分钟）遍历，如果第一组进球，那么就让第一组分数加一，否则就让第二组分数加一。

同时，如果第一组比第二组分数高，那么第一组领先的持续时间就加一（秒），否则第二组领先的持续时间就加一（秒）。

最后转换成 $MM:SS$ 即可。
```cpp
for (int i = 0; i <= 2880; i++) {
	if (x_fens > y_fens) s1++;
	if (x_fens < y_fens) s2++;
	if (sj[i] == 1) x_fens++;
	if (sj[i] == 2) y_fens++;
}
zh_m(m1, s1);
zh_m(m2, s2);
printf ("%02d:%02d\n", m1, s1);
printf ("%02d:%02d\n", m2, s2);
```

---

## 作者：Zmr_ (赞：0)

## 题外话

一道暴力模拟，我这个菜鸟错了好多次（（（

不过确实挺简单，很容易能想到做法

--------

## 1.了解题意

[我是传送门awa](https://www.luogu.com.cn/problem/P7632)

题面如上，还没看题的同学回去看题

#### 简单地概述下题目

有俩球队打比赛，有个球迷在看球赛

比赛共计 $48$ 分钟，这个~~闲的没事干的~~球迷会把每次进球记录下来

这个好奇的球迷想要知道每个队伍领先多长时间

输入输出回去看

----

## 2.思路概述

- #### 如何计算时间

  其实很简单，我们可以整个数组记录进球时的时间
  
  接着用下一次进球的时间减去这一次进球的时间从而算出中间间隔时间
  
  把时间累加起来
  
  前提是该队必须要领先
  
  题目中没有说平局如何，我们观察输入样例之后发现平局是不计算的
  
  因此只需计算大于和小于的情况
  
- #### 输入输出的细节

  输入输出中含有 “$:$” 字符
  
  考虑运用 scanf 和 printf
 
   输入可以用：
   
   “ 
   
   ``` cpp
   scanf("%d:%d",&a,&b);
	``` 
	 ”
   

	

  输出可以用：
  
  “

	```cpp
	printf("%02d:%02d\n",minute1,second1);
	printf("%02d:%02d",minute2,second2);

	```
   ”
***
懂得这些了，我们去愉快地A题吧

---

## 3.AC代码

如下，请不要直接借鉴题解，但可以学习部分语句

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[105],m[105],minu[2],sec[2],a,b;
int ball1,ball2;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>f[i];//输入团队编号 
		
		scanf("%d:%d",&a,&b);//输入时间 
		
		m[i]=a*60+b;
		//时间处理 
	} 
	m[n+1]=2880;//2880=48*60
	//特别处理，如果是最后一个时间的话，应该用总时间去减
	for(int i=1;i<=n;i++)
	{
		//考虑到我过于太菜，所以我把分钟，秒钟统一转换成秒去计算
		//这样会简单些，代码也易懂
		if(f[i]==1)ball1++;
		else ball2++;
		if(ball1>ball2)
		{
			minu[0]+=m[i+1]-m[i];
		} 
		if(ball1<ball2)
		{
			minu[1]+=m[i+1]-m[i];
		}
		//计算时间 
	}
	printf("%02d:%02d\n",minu[0]/60,minu[0]%60);
	printf("%02d:%02d",minu[1]/60,minu[1]%60);
	//巧用printf 
	return 0;
}
```

##### ——The End

---

## 作者：nfls20200418 (赞：0)

# 思路(来自官方题解)
------------
暴力枚举从 $0$ 秒到 $2880$ 的每一秒，我们存储在该秒中得分的球队(如果有的话)。为了填充这个数组，我们必须将给定的事件从 $MM:SS$ 格式转换为从游戏开始经过的秒数 $MM*60+SS$。

现在我们遍历这个数组，跟踪每个团队的当前得分。每过一秒，比分没有平局，就增加获胜队伍的计数器。

## 补充一个关于 printf 和 scanf 的小知识

------------
输入时间可以用
```cpp
scanf("%d:%d:%d", &h, &m, &s);
```
可以自动忽略“：”。
输出时间用
```cpp
printf("%02d:%02d:%02d", hh, mm, ss);
```
可以自动用前导 0 填充至 2 位。

# AC 代码 

------------

```c++
#include <bits/stdc++.h>
using namespace std;
int n, a, b, t, m, s, d[2885];
int main() {
    scanf("%d", &n);
    for(int i=1; i<=n; i++) {
        scanf("%d%d:%d", &t, &m, &s);
        if(t == 1) d[m*60+s]=1;
        else d[m*60+s]=-1;
    }
    for(int i=0; i<2880; i++) {
        if(i != 0) d[i]+=d[i-1];
        if(d[i] > 0) a++;
        if(d[i] < 0) b++;
    }
    printf("%02d:%02d\n%02d:%02d", a/60, a%60, b/60, b%60);
    return 0;
}
/**************************************************************
```
To err is human, to forgive divine.

---


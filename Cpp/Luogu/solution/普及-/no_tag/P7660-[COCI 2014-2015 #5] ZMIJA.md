# [COCI 2014/2015 #5] ZMIJA

## 题目背景

Mirko 在玩魔改的贪吃蛇。

## 题目描述

给你一个 $n\times m$ 的矩阵，其中：

- 蛇在左下角，用 `Z` 表示；
- 其他格子苹果用 `J` 表示，空白用 `.` 表示；
- 操作 A 让蛇向它面对的方向走一步（不能走出矩阵）；
- 操作 B 让蛇向上走一步，并且方向转 $180\degree$；
- 当蛇所在格子有苹果时，蛇会把这个苹果吃掉。

现在蛇面向右，求最少操作数使蛇吃掉所有苹果。

## 说明/提示

对于 $100\%$ 的数据，$2 \leq n,m \leq 1000$，矩阵的左下角一定是 `Z`。

**样例 1 解释：** 依次执行操作 $BBAAABB$ 可吃掉所有苹果。

译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
5 5
...J.
.....
J..J.
J....
Z....```

### 输出

```
7```

## 样例 #2

### 输入

```
5 5
.....
J...J
.J.J.
.JJJ.
Z....```

### 输出

```
15```

## 样例 #3

### 输入

```
3 4
...J
....
Z...```

### 输出

```
5```

# 题解

## 作者：_YyD_ (赞：6)

**题目大意：**

一个$n\times m(n,m\leq1000)$的格子中有若干金币，从左下角出发，每一步可以进行如下操作：

　　　　1.向当前方向前进一格；
    
　　　　2.向上移动一步，并调转当前方向。
    
一开始的方向是向右，到达一个格子时自动收集当前位置的金币，移动过程中不能离开网格图。

问收集完所有金币至少需要多少步？

**思路：**

贪心。

首先记录下每一行最左/最右的金币的位置，每次贪心地取完这一行的所有金币，

然后判断上一行最左/最右的金币是否在当前方向上，

如果是，就先往前走到那个位置上，然后再上去，否则就直接上去。

**代码：**
```cpp
#include<bits/stdc++.h>
#define _ ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define lep(i,l,r) for(int i=l;i>=r;i--)
#define ll long long
#define ull unsigned long long
using namespace std;
inline int read() {
	int X=0; bool flag=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') flag=0; ch=getchar();}
	while(ch>='0'&&ch<='9') {X=(X<<1)+(X<<3)+ch-'0'; ch=getchar();}
	if(flag) return X;
	return ~(X-1);
}
inline bool isblock(const char &ch) {
    return ch=='.'||ch=='J'||ch=='Z';
}
inline bool getblock() {
    register char ch;
    while(!isblock(ch=getchar()));
    return ch=='J';
}
inline int sign(const int &x) {
    if(x>0) return 1;
    if(x<0) return -1;
    return 0;
}
const int N=1001;
int cnt[N],pos[N][2],sum;
bool mp[N][N];
int main() {
    const int n=read(),m=read();
    rep(i,1,n) {
        rep(j,1,m) {
            mp[i][j]=getblock();
            if(mp[i][j]) {
                if(!pos[i][0]) pos[i][0]=j;
                pos[i][1]=j;
                cnt[i]++;
                sum++;
            }
        }
    }
    int ans=0;
    for(register int x=n,y=1,d=1;;x--,d=-d) {
        if(mp[x][y]) {
            cnt[x]--;
            sum--;
        }
        while(cnt[x]) {
            ans++;
            y+=d;
            if(mp[x][y]) {
                cnt[x]--;
                sum--;
            }
        }
        if(!sum) break;
        while(pos[x-1][(bool)~d]&&sign(pos[x-1][(bool)~d]-y)==d) {
            y+=d;
            ans++;
        }
        ans++;
    }
    cout<<ans;
    return 0;
}
```

**注明：**

思路来自 skylee。

---

## 作者：_k_e_v_i_n_ (赞：6)

# 思路

输入。

```
cin>>n>>m;
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='J')	b[i]=j,rmax=n-i+1;
			if(c=='J'&&a[i]==0)	a[i]=j;
		}
	}
```


定义 $rmax$ 记录出现的最高行数。

```
int rmax;
```

定义 $now$ 表示横坐标。

```
int now;
```

定义 $last$ 表示上一次吃苹果的纵坐标，也就是行数。

```
int last;
```

定义 $ans$ 统计总步数。

```
int ans;
```

先统计第一行，第一行毫无疑问是从左走到右。

```
max(0,b[1]-1)
```

行数为偶数一定是从右走到左，于是乎写下这些代码。

```
if(i%2==0){
			if(b[i]==0)
            	continue;
```

求出当前行最右边的位置和上一行最左边的位置。

```
ans+=abs(b[i]-now);
```

行数为奇数一定是从左走到右，做法跟偶数差不多。

```
if(b[i]==0)	continue;
			ans+=i-last;
			last=i;
			ans+=abs(a[i]-now);
			ans+=abs(b[i]-a[i]);
			now=b[i];
```

## 思路汇总

一、输入，rmax记录出现的最高行数。

二、 $now$ 表示横坐标。

三、 $last$ 表示上一次吃苹果的纵坐标，也就是行数。

四、 $ans$ 统计总步数，先统计第一行，第一行毫无疑问是从左走到右。

五、行数为偶数一定是从右走到左，行数为奇数一定是从左走到右。

六、行数为偶数的情况：往上走一步或多步，因为可能存在中间某几行都没有苹果的情况；求出当前行最右边的位置和上一行最左边的位置，把这一行都吃掉。

七、行数为奇数的情况跟行数为偶数的情况相似。

# 附上AC代码
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<queue>
#include<set>
#include<cstring>
#include<algorithm>
#define INF 0x7fffffff
using namespace std;
int n,m,rmax,a[10001],b[10001];
char c;
int main(){
	cin>>n>>m;
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='J')	b[i]=j,rmax=n-i+1;	//rmax记录出现的最高行数
			if(c=='J'&&a[i]==0)	a[i]=j;
		}
	}
	int now=max(1,b[1]);	// now 表示横坐标
	int last=1;	// last 表示上一次吃苹果的纵坐标，也就是行数
	int ans=max(0,b[1]-1);	// ans 统计总步数，先统计第一行，第一行毫无疑问是从左走到右
	for(int i=2;i<=rmax;i++){
		if(i%2==0){	//行数为偶数一定是从右走到左
			if(b[i]==0)	continue;
			ans+=i-last;	//往上走一步或多步，因为可能存在中间某几行都没有苹果的情况
			last=i;
			ans+=abs(b[i]-now);	//求出当前行最右边的位置和上一行最左边的位置
			ans+=abs(b[i]-a[i]);	//把这一行都吃掉
			now=a[i];	//最终停留在这一行的位置，为下一行计算做准备 
		}else{	//行数为奇数一定是从左走到右
			if(b[i]==0)	continue;
			ans+=i-last;
			last=i;
			ans+=abs(a[i]-now);
			ans+=abs(b[i]-a[i]);
			now=b[i];
		}
	}
	cout<<ans;
    return 0;
}

```

# ~~可以抄的代码~~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<queue>
#include<set>
#include<cstring>
#include<algorithm>
#define INF 0x7fffffff
using namespace std;
int n,m,rmax,a[10001],b[10001];
char c;
int main(){
	cin>>n>>m;
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='J')	b[i]=j,rmax=n-i+1;
			if(c=='J'&&a[i]==0)	a[i]=j;
		}
	}
	int now=max(1,b[1]);
	int last=1;
	int ans=max(0,b[1]-1);
	for(int i=2;i<=rmax;i++){
		if(i%2==0){
			if(b[i]==0)	continue;
			ans+=i-last;
			last=i;
			ans+=abs(b[i]-now);
			ans+=abs(b[i]-a[i]);
			now=a[i];
		}else{
			if(b[i]==0)	continue;
			ans+=i-last;
			last=i;
			ans+=abs(a[i]-now);
			ans+=abs(b[i]-a[i]);
			now=b[i];
		}
	}
	cout<<ans;
    return 0;
}
```


---

## 作者：Maysoul (赞：2)

题目给出了两种操作：

1. 往当前的方向前进一步。

2. 往上走一格并调转方向。

开两个数组 $fi$ 和 $la$ 来分别维护每一行第一次和最后一次出现苹果的位置，设当前蛇在第 $p$ 列，当前蛇在第 $i$ 行。

我们可以发现蛇在从最下面一行往上走的时候，是右左右左交替进行的，所以我们可以想到，如果要是蛇想吃到当前行所有的苹果，我们需要分为以下几种情况来求解：

**因为后面有取最大和最小的运算，所以 $fi$ 预处理成全为 $ INF $，$la$ 全预处理成 $-1$。**

1. 当前的蛇头朝右，$ la_{i}\ne -1$ 或 $la_{i-1}\ne -1$，这种情况我们需要考虑，上面的一行我们想要全吃到的话，必须移动到上一行最后一个苹果出现的位置，再往左吃，所以我们这里的答案要加 $\left | \max(la_{i},la_{i-1})-p \right | +1$。

2. 当前的蛇头朝右，$la_{i}= -1$ 且 $la_{i-1}= -1$，这种情况就是上面和当前行都没有苹果需要吃，我们就直接向上一格走。

3. 当前的蛇头朝左，$fi_{i}\ne  INF $ 或 $fi_{i-1}\ne  INF $，这种情况我们需要考虑，上面的一行我们想要全吃到的话，必须移动到上一行第一个苹果出现的位置，再往右吃，所以我们这里的答案要加 $\left | p-\min(fi_{i},fi_{i-1}) \right | +1$。

4. 当前的蛇头朝左，$la_{i}=  INF $ 且 $la_{i-1}=  INF$，这种情况就是上面和当前行都没有苹果需要吃，我们就直接向上一格走。

code:

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 1000100
using namespace std;
int fi[N],la[N],n,m,ans,t;
signed main() {
	cin>>n>>m;
	memset(fi,INF,sizeof fi);
	memset(la,-1,sizeof la);
	for(int i=1; i<=n; i++) {
		int flag=0;
		for(int j=1; j<=m; j++) {
			char s;
			cin>>s;
			if(s=='J') {
				if(!flag)fi[i]=j,flag=1;
				la[i]=j;
			}
		}
	}
	for(int i=1; i<=n; i++)if(fi[i]!=INF) {
			t=i;
			break;
		}
	int p=1,now=1;//now是当前蛇头方向1是右0是左，p是蛇当前所在列
	for(int i=n; i>=t; i--) {
		if(now==1) {
			if(la[i-1]==-1&&la[i]==-1)ans++,now=0;
			else ans+=abs(max(la[i],la[i-1])-p)+1,p=max(la[i],la[i-1]),now=0;
		} else {
			if(fi[i-1]==INF&&fi[i]==INF)ans++,now=1;
			else ans+=abs(p-min(fi[i],fi[i-1]))+1,p=min(fi[i],fi[i-1]),now=1;
		}
	}
	cout<<(ans-1)<<endl;
	return 0;
}
```


---

## 作者：Nemonade (赞：1)

## 题目大意

给一个包含空地和苹果的棋盘，有一条位于左下角面向右侧的蛇，可以做以下操作：

A. 朝着面向的反向走一步。

B. 向上走一步并且掉头。

求把所有苹果吃完的最小步数。

## 思路分析

不难发现，操作 A 只能让蛇左右走，操作 B 只能让蛇向上走。那么不能让蛇往下，同一行中又不能掉头，所以每行只能走一遍。

可以记录每一行的第一个和最后一个苹果，那么这两个苹果之间的空间是必然要走的。

所以我们从下到上考虑每一行，如果该行只能往左走，那么进入这一行的时候，蛇就必须在左右一个苹果或者其右侧的位置（否则走不到最后一个苹果）；反之亦然。

有几个细节：有些行是空的，直接无脑往上走就可以了；最上面几行有时候是空的，那么就不用傻乎乎往上走了。具体看代码。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rd() (read<int>())
#define pfor(i,x,y) for(register int i=x;i<=y;++i)
#define mfor(i,x,y) for(register int i=x;i>=y;--i)
template<typename T>inline T read(){
  T x=0;bool f=false;char c=getchar();
  while(c<'0'||c>'9'){if(c=='-')f=true;c=getchar();}
  while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
  return f?-x:x;
}template<typename T>inline void write(T x){
  if(x<0){putchar('-');x=-x;}if(x/10) write(x/10);
  putchar((x%10)^48);return;
}
using std::max;using std::min;using std::abs;
using std::cin;using std::cout;using std::endl;
using std::sort;using std::swap;
const int N=1e3+5,M=1e4+5,MOD=1e9+7;
int n,m,mx[N][2],res,x,ft;
//mx[i][0]表示第i行的第一个苹果，mx[i][0]表示第i行的最后一个苹果。
//x为当前蛇的位置。ft表示第一行有苹果的。
char a[N][N];
signed main(){
  n=rd(),m=rd();
  pfor(i,1,n) scanf("%s",a[i]+1);
  pfor(i,1,n) pfor(j,1,m){
    if(a[i][j]=='.'||a[i][j]=='Z') continue;
    if(!mx[i][0]) mx[i][0]=j;
    mx[i][1]=j;
  }//初始化每一行的第一个和最后一个苹果
  while(!mx[ft][0]) ++ft;//计算第一行有苹果的
  x=1;//蛇开始时再左下角
  if(mx[n][1]) res+=mx[n][1]-x,x=mx[n][1];//如果开始行有苹果也要吃
  mfor(i,n-1,ft){
    if(!mx[i][0]){++res;continue;}//没有苹果无脑往上跳
    if((n-i)%2){//向右走
      if(mx[i][1]>x) res+=mx[i][1]-x,x=mx[i][1];//走到最后一个下面
      ++res;//往上
      res+=x-mx[i][0];//吃这一行的苹果
      x=mx[i][0];
    }
    else{//向左走
      if(mx[i][0]<x) res+=x-mx[i][0],x=mx[i][0];//走到第一个下面
      ++res;//往上
      res+=mx[i][1]-x;//吃这一行的苹果
      x=mx[i][1];
    }
  }
  cout<<res;
  return 0;
}

```

---

## 作者：Leasier (赞：1)

Update on 2022.5.14：感谢 @_k_e_v_i_n_。

显然地，如果要取完所有苹果，必须从下到上依次取完当前行的所有苹果。

首先预处理出每一行最左 / 右的苹果的位置。接下来从最后一行开始向上走，记录下到当前行时的列和方向（即向左还是向右），如果这一行有苹果，取完这一行的所有苹果，然后判断整个棋盘是否还有需要取的金币，如果没有，退出整个循环；否则，维持方向不变走到当前行最靠近上面一行最左 / 右有金币的位置并向上走一格，将方向取反并继续循环即可。时间复杂度为 $O(nm)$。

代码：
```cpp
#include <stdio.h>

int cnt[1007], left[1007], right[1007];
char mp[1007][1007];

int main(){
	int n, m, global_cnt = 0, ans = 0;
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf("%s", &mp[i][1]);
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			if (mp[i][j] == 'J'){
				cnt[i]++;
				if (left[i] == 0) left[i] = j;
				right[i] = j;
				global_cnt++;
			}
		}
	}
	for (int i = n, j = 1, k = 1; ; i--, k = -k){
		if (mp[i][j] == 'J'){
			cnt[i]--;
			global_cnt--;
		}
		while (cnt[i] > 0){
			j += k;
			ans++;
			if (mp[i][j] == 'J'){
				cnt[i]--;
				global_cnt--;
			}
		}
		if (global_cnt == 0) break;
		int id = i - 1;
		if (left[id] != 0){
			if (k == -1){
				while (j > left[id]){
					j--;
					ans++;
				}
			} else {
				while (j < right[id]){
					j++;
					ans++;
				}
			}
		}
		ans++;
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：xxxxxzy (赞：0)

#### P7660的题解

贪心。

蛇每到一列，都必须到达可以吃完下一列苹果的地方，边界处也就是下一列的第一个（最后一个）苹果。

也就可以将下一列的第一个（最后一个）苹果与当前这列的第一个（最后一个）苹果作比较，选择位置更小（大）的那一个，这样就能在保证正确性的情况下尽可能的贪心。

注意要特别判断，如果当前列与下一列都没有可以吃的苹果，那么就直接往上走。

关于蛇是往左还是往右，判断当前列奇偶性是否与第 $n$ 列相同，分类讨论即可。

#### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char c;
int n,m,tot,ans,p[1005];
vector<int> g[1005];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='J') tot++,p[i]++,g[i].push_back(j);//记录苹果的位置
		}
	}
	int last=1;
	for(int i=n;i>=1;i--){
		if(tot==0){//没有苹果了
			cout<<ans-1;
			return 0;
		}
		if((i&1)==(n&1)){//往右
			int x=0,y=0;
			if(g[i].size()) x=g[i][g[i].size()-1];
			if(g[i-1].size()) y=g[i-1][g[i-1].size()-1];
			if(g[i].size()==g[i-1].size()&&g[i].size()==0){//判断是不是两列都没有苹果
				ans++;
				continue;
			}
			ans+=abs(max(x,y)-last);
			last=max(x,y);
		}else{//往左
			int x=1e9,y=1e9;
			if(g[i].size()) x=g[i][0];
			if(g[i-1].size()) y=g[i-1][0];
			if(g[i].size()==g[i-1].size()&&g[i].size()==0){
				ans++;
				continue;
			}
			ans+=abs(last-min(x,y));
			last=min(x,y);
		}
		ans++;
		tot-=p[i]; 
	}
	cout<<ans-1;//往上爬会多+1，所以-1
} 
```



---

## 作者：xhz0311 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7660)
### 思路分析
简单贪心。
> 首先一直向右（左）吃完这一行所有苹果，停在本行最右（左）的苹果处；   
如果上一行最右（左）的苹果比当前位置更靠右（左），继续向前移动，直至上一行最右（左）的苹果的正下方；   
向上移动一格，并调转蛇头。   
重复以上操作，直至最上方一行。   

举个例子，对于样例中给出的地图：
```
.....
J...J
.J.J.
.JJJ.
Z....
```
使得步数最少的走法如下（坐标，以左下角为原点）：   
$(0,0)\to (1,0)$   
$\to (1,1)\to (2,1)\to (3,1)$   
$\to (3,2)\to (2,2)\to(1,2)\to (0,2)$   
$\to (0,3) \to ... \to (4,3)$   
共 $15$ 步。
### 注意特判
如果一行一个苹果都没有，直接认定“上一行最右（左）的苹果比本行最右（左）的苹果更靠右（左）”。

---

## 作者：Gaogao2011 (赞：0)

### 题意

**输入：** 一个 $n \times m$ 的矩阵，由三种字符符号组成，分别表示蛇、苹果和空白。

**计算：** 

对蛇的移动可进行如下两种操作：

* 向蛇目前面对的方向走一步。

* 向上移动一步并调转当前方向。

如果蛇当前所在的格子中有苹果，则可以把该苹果吃掉。

**输出：** 蛇吃掉所有苹果的最少操作数。

### 思路

贪心+模拟法求解。

模拟：通过二维数组判断输入的某位置上是否有苹果。

贪心规则：

* 记录下蛇所在行最左或最右的金币位置，一次性吃完。

* 判断上一行最左或最右的金币是否在当前方向上。

* 如果是，就往前走到那个位置上，再上去。

* 如果否，直接上去。

### 代码

~~先看完再抄捏。~~

```
#include <iostream>
#include <cstdio>
using namespace std;
int cnt[1007], l[1007], r[1007], n, m, s = 0, ans = 0;
char mp[1007][1007];
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%s", &mp[i][1]);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (mp[i][j] == 'J') {
				cnt[i]++, r[i] = j, s++;
				if (l[i] == 0) l[i] = j;
			}
		}
	}
	for (int i = n, j = 1, k = 1; ; i--, k = -k) {
		if (mp[i][j] == 'J') cnt[i]--, s--;
		while (cnt[i] > 0) {
			j += k, ans++;
			if (mp[i][j] == 'J') cnt[i]--, s--;
		}
		if (s == 0) break;
		int id = i - 1;
		if (l[id]) {
			if (k == -1) {
				while (j > l[id]) j--, ans++;
			} 
			else {
				while (j < r[id]) j++, ans++;
			}
		}
		ans++;
	}
	printf("%d\n", ans);
	return 0;
}

```


---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

设从矩阵的最底行向最顶行的行号为 $1$ 至 $n$，则贪吃蛇在奇数行时，面向右，只能从左端走到右端；在偶数行时，面向左，只能从右端走向左端。因此，贪吃蛇从矩阵的最左下角（行号为 $1$，列号也为 $1$）开始，按如下的行走路线肯定可以吃光矩阵中的所有苹果：

在奇数行从最左端（行号为 $1$）用操作 A 一直走到最右端（行号为 $m$），之后用操作 B 向上到达偶数行；

在偶数行从最右端（行号为 $m$）用操作 A 一直走到最左端（行号为 $1$），之后再用操作 B 向上到达奇数行；

交替执行上面的过程，直到上面的行中不再有苹果。

为了使贪吃蛇吃掉所有苹果的操作数最少，显然在每行使用操作 B 进行向上转向的时机就非常重要了。

设 $S_{i,0}$ 表示第 $i$ 行最左端苹果出现的列号，$S_{i,1}$ 表示第 $i$ 行最右端苹果出现的列号。

显然，如果 $i$ 是奇数，贪吃蛇从 $S_{i,0}$ 列走到 $S_{i,1}$ 就可以吃完第 $i$ 行的所有苹果，吃完后设它停在 $S_{i,1}$  列，将这个停止位不妨记为 $pos$；同样的，如果 $i$ 是偶数，贪吃蛇从 $S_{i,1}$ 列走到 $S_{i,0}$ 就可以吃完第 $i$ 行的所有苹果，吃完后设它停在 $S_{i,0}$  列。这样，贪吃蛇用操作 A 吃完每行的苹果的次数肯定是最少的。

但执行操作 B 向上时，跳到下一行的列位置是前一行的停止位置 $pos$，如果这个 $pos$ 位置在 $S_{i,0}$ 列到 $S_{i,1}$ 列之间，则贪吃蛇是无法吃完下一行的所有苹果的，因为它处于中间，只能吃一端的苹果，无法吃另一端的苹果。因此需要在上一行对停止的位置进行最小限度的校正，以达到可以吃完下一行所有苹果的目的。校正的方法如下：

如果贪吃蛇上一行是停在奇数行 $i-1$ 的 $pos$ 列，下一行是偶数行 $i$，若 $pos\ge S_{i,1}$，则无需校正，若 $pos<S_{i,1}$，则上一行多走 $S_{i,1}-pos$ 步，使得上一行的停止位在 $S_{i,1}$ 处，这样用操作 B 向上后正好可以吃完下一偶数行的所有苹果；

如果贪吃蛇上一行是停在偶数行 $i-1$ 的 $pos$ 列，下一行是奇数行 $i$，若 $pos\le S_{i,0}$，则无需校正，若 $pos>S_{i,0}$，则上一行多走 $pos-S_{i,1}$ 步，使得上一行的停止位在 $S_{i,0}$ 处，这样用操作 B 向上后正好可以吃完下一奇数行的所有苹果。

为此，在输入矩阵信息时进行预处理，将每行最左端苹果的列号和最右端苹果的列号保存到二维数组 $S$ 中，数组元素 $S[i][0]$ 保存第 $i$ 行最左端苹果的列号，$S[i][1]$ 保存第 $i$ 行最右端苹果的列号。若某行中没有苹果，则数组元素 $S[i][0]$ 和 $S[i][1]$ 的值均为 $0$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    int n,m;
	scanf("%d%d",&n,&m);
	int i,j;
	int maxl=0;     // 从上往下看，第1次有苹果出现的行号maxl
    int s[1005][2]={0};
	for (i=n;i>=1;i--)
    {
		char str[1005];
        scanf("%s",str+1);
		for (j=1;j<=m;j++)
		{
			if (str[j]=='J' || str[j]=='Z')
            {
                if (maxl==0)  maxl=i;
                if (s[i][0]==0) s[i][0]=j;   // 每行最左端苹果的位置
                if (s[i][1]<j)  s[i][1]=j;   // 每行最右端苹果的位置
            }
		}
    }
    int ans=-1,pos=1;
    for (i=1;i<=maxl;i++)   // 从最底行向上逐行处理到最上面有苹果出现的一行
    {
        ans++;      // 2操作，从下一行到本行
        if (s[i][1]==0)   // 本行没有苹果，默认不处理
            continue;
        if (i%2)    // 奇数行面向右，从最左端s[i][0]走向最右端s[i][1]
        {
            if (pos>s[i][0])       // 上一行最后停的位置没有达到最左端
            {
                ans+=pos-s[i][0];  // 上一行补走到本行最左端的对齐位置
                pos=s[i][0];
            }
            ans+=s[i][1]-pos;
            pos=s[i][1];          // 本行的停止位置在最右端
        }
        else        // 偶数行面向左，从最右端s[i][1]走向最左端s[i][0]
        {
            if (pos<s[i][1])       // 上一行最后停的位置没有达到最右端
            {
                ans+=s[i][1]-pos;  // 上一行补走到本行最右端的对齐位置
                pos=s[i][1];
            }
            ans+=pos-s[i][0];
            pos=s[i][0];          // 本行的停止位置在最左端
        }
    }
    printf("%d\n",ans);
	return 0;
}

```








---

## 作者：Together_ (赞：0)

[博客食用效果更佳](https://www.cnblogs.com/yangzichen/p/16897416.html)

### 思路：

对于第 $i$ 行，如果本行的所有的苹果都吃完了，那么有以下几种情况：

- 若本行往左走，则现在的列下标必须大于等于上一行最左边的苹果的列下标。
- 若本行往右走，则现在的列下标必须小于等于上一行最右边的苹果的列下标。

如果满足以上任意一条，则就可以走到上一行。

```cpp
if(f == 1 && y >= fr[x-1] && Sum >= J[x]) {
	if(dfs(x-1, y, 2, 1) == false)
		return false;
} else if(f == 2 && y <= fl[x-1] && Sum >= J[x]) {
	if(dfs(x-1, y, 1, 1) == false)
		return false;
}
```

如果一条都不满足，则该往左走往左走，该往右走往右走。

```cpp
if(f == 1) {
	if(dfs(x, y+1, f, 0) == false)
		return false;
} else {	
	if(dfs(x, y-1, f, 0) == false)
		return false;
}
```

### 注意：

为了方便我们将 dfs 定义成 bool 类型，如果吃完了最后一个苹果就返回 false。

### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, cnt, sum, eat, Sum;
char mp[1010][1010];
int fr[1010], fl[1010], J[1010];
//fr[i]：表示第i行最右边的J的位置 
//fl[i]：表示第i行最左边的J的位置 
//J[i]：表示第i行J的数量 

//F：是否要更新Sum
//Sum：本行出现‘J’的个数
//f：方向，1向右，2向左
//x、y：所在的行和列  
bool dfs(int x, int y, int f, int F) {
	if(F == 1)
		Sum = 0;
	if(mp[x][y] == 'J')
		eat++, Sum++;
	if(eat == sum)
		return false; 
	cnt++;
	if(f == 1 && y >= fr[x-1] && Sum >= J[x]) {
		if(dfs(x-1, y, 2, 1) == false)
			return false;
	} else if(f == 2 && y <= fl[x-1] && Sum >= J[x]) {
		if(dfs(x-1, y, 1, 1) == false)
			return false;
	} else{
		if(f == 1) {
			if(dfs(x, y+1, f, 0) == false)
				return false;
		} else {	
			if(dfs(x, y-1, f, 0) == false)
				return false;
		}
	}
	return true;
}

int main() {
	cin >> n >> m;
	memset(fl, 0x3F, sizeof(fl));
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			cin >> mp[i][j];
			if(mp[i][j] == 'J'){
				J[i]++;
				fr[i] = j;
				fl[i] = min(fl[i], j);
				sum++;
			}
		}
	dfs(n, 1, 1, 1);
	cout << cnt;
	return 0;
}

```

---

## 作者：乐乐乐还在乐 (赞：0)

# P7660 题解

**[题目传送门](https://www.luogu.com.cn/problem/CF198B)**

### 题目大意

- 给你一个 $n*m$ 的矩阵，上面的一些地方有苹果。

- 一条小蛇从左下角出发，每次只能往前走（向左或向右），或者向上走并掉头。

- 求：这条小蛇吃掉所有的苹果所需的最少步数。

### 分析题目

这一题是一道比较简单的**模拟加贪心**。

重点是：要想清楚小蛇要怎样才能$\color{Blue}\colorbox{White}{最优地}\color{Green}\colorbox{White}{不重不漏地}$3吃掉所有苹果。

### 思考算法

因为这道题是一道**模拟加贪心**，所以我们既要**模拟**出小蛇的状态，也要让小蛇**贪心**地吃掉所有苹果。

**模拟：**

首先，我们要记录小蛇所在的横纵坐标。

其次，我们要记录每一行最左和最右的苹果所在的位置。

```cpp
int a[1005],b[1005];
//a数组代表一行最左的苹果的位置
//b数组代表一行最右的苹果的位置
//若为0则代表这行没有苹果 
```

~~最后，万事大吉，只欠**贪心**。~~

**贪心：**

当我们的小蛇准备来到新的一行时，它要做些什么呢？

1.如果这行没有苹果，那就去看看下一行。
```cpp
if(b[i]==0)continue;
```

2.否则，它就会去这行的最左（右）的苹果的位置。

```cpp
ans+=i-last;
last=i;

ans+=abs(b[i]-now);
now=b[i];
```

3.然后，它会把这整一行的苹果吃了。（走到这行的最右（左）的苹果的位置）

```cpp
ans+=abs(b[i]-a[i]);
now=a[i];
```

## 附上AC代码


```cpp

#include<bits/stdc++.h>
using namespace std;

int n,m;
int a[1005],b[1005];

int main(){
	scanf("%d%d",&n,&m);
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			char c;
			scanf(" %c",&c);
			//更新a、b数组
			if(c=='J')b[i]=j;
			if(c=='J'&&a[i]==0)a[i]=j;
		}
	}
	
	int now=max(1,b[1]);//now表示横坐标
	int last=1;//last表示上一次吃苹果的纵坐标
	int ans=max(0,b[1]-1);//ans统计总步数
	
	for(int i=2;i<=n;i++){
		//分情况讨论
		if(i%2==0){
			if(b[i]==0)continue;
			
			ans+=i-last;
			last=i;
			
			ans+=abs(b[i]-now);
			now=b[i];
			
			ans+=abs(b[i]-a[i]);
			now=a[i];
		}
		else{
			if(a[i]==0)continue;
			
			ans+=i-last;
			last=i;
			
			ans+=abs(a[i]-now);
			now=a[i];
			
			ans+=abs(b[i]-a[i]);
			now=b[i];
		}
		
	}
	printf("%d",ans);
	return 0;
} 

```

---


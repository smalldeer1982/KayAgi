# [COCI 2014/2015 #5] TRAKTOR

## 题目背景

Mirko 用拖拉机采蘑菇。

## 题目描述

已知一个平面上 $n$ 个点，每个点的坐标可以用正整数 $X_i,Y_i$ 表示，求最小的 $ans$ 使前 $ans$ 个点中有至少 $k$ 个点处于同一行或同一列或同一与对角线平行的斜线。

## 说明/提示

对于 $50\%$ 的数据，$1 \leq X_i,Y_i \leq 300$。

对于 $100\%$ 的数据，$2 \leq k \leq n \leq 10^6$，$1 \leq X_i,Y_i \leq 10^5$。

**样例 1 解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/pjop5zum.png)。

译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)

## 样例 #1

### 输入

```
4 3
1 2
3 4
3 2
4 5```

### 输出

```
4```

## 样例 #2

### 输入

```
7 4
3 1
2 2
4 1
3 2
2 3
1 4
1 3```

### 输出

```
6```

## 样例 #3

### 输入

```
5 2
1 1
2 1
1 2
1 3
1 4```

### 输出

```
2```

# 题解

## 作者：Nt_Tsumiki (赞：6)

### 题意
在平面上有 $n$ 个点，每个店有自己的坐标 $x_i$ 和 $y_i$，现在给你一个数 $k$，求最小的 $i$ 使得前 $i$ 个数中有 $k$ 个数在同一直线上。
### 做法
根据题意我们知道，需要求在一个平面上点的个数，而在同一条直线上的点，有以下特征：

1. $x$ 一样
2. $y$ 一样
3. $x$ 与 $y$ 的和一样
4. $x$ 与 $y$ 的差一样

我们就可以定义四个桶数组来记录每一条直线上点的个数，直到出现一个 $i$ 让某一条直线满足要求（即点的个数等于 $k$），就输出，如果循环结束还没出现，就输出 $-1$，上代码。
### Code
```cpp
#include <iostream>

using namespace std;
int n,k;
int x,y;
int h[1000001],s[1000001],lx[2000001],rx[2000001];//桶数组，记录点数

int main() {
    cin>>n>>k;
    for (int i=1;i<=n;i++) {
        cin>>x>>y;
        h[y]++;
        s[x]++;
        lx[x+y]++;
        rx[x-y+1000000]++;
        if (h[y]==k or s[x]==k or lx[x+y]==k or rx[x-y+1000000]==k) { //满足要求
            cout<<i;
            return 0;
        }
    }
    cout<<-1;//没找到
}
```


---

## 作者：EdisonBa (赞：3)

#### 题目分析

+ 平行于 $x$ 轴的直线，上面的所有点纵坐标都一致。
+ 平行于 $y$ 轴的直线，上面的所有点横坐标都一致。
+ 平行于 $y=x$ 的直线，上面的所有点中 $y-x$ 为定值。
+ 平行于 $y=-x$ 的直线，上面的所有点中 $y+x$ 为定值。

那么，我们可以开四个桶。

$A_i$ 记录横坐标为 $i$ 的点的个数。

$B_i$ 记录纵坐标为 $i$ 的点的个数。

$C_i$ 记录 $y-x$ 的值为 $i$ 的点的个数。

$D_i$ 记录 $y+x$ 的值为 $i$ 的点的个数。

每当读入一个新结点时，我们更新这四个桶，此时如果桶中有任意一个值达到 $k$，那么就满足条件，输出即可。

#### Code
```cpp
const ll M = 2001002;
const ll mid = 1000000; //防止数组的下标为负数
ll A[M], B[M], C[M], D[M], n, k;    //桶

void print(int i)
{
    printf("%d\n", i);
    exit(0);
}

int main()
{
    n = read(), k = read();
    for (int i = 1; i <= n; ++i)
    {
        ll x = read(), y = read();
        A[x + mid]++;
        B[y + mid]++;
        C[y - x + mid]++;
        D[y + x + mid]++;
        if (A[x + mid] == k || B[y + mid] == k || C[x - y + mid] == k || D[y + x + mid] == k)
            print(i);
    }
    puts("-1");
    return 0;
}
```

---

## 作者：Chtholly_L (赞：1)

### 题意：

给定 $n$ 个点的坐标，求一个 $ans$ 的值，使前 $ans$ 个数有 $k$ 数在同一行，同一列或与坐标轴对角线平行的直线上。

### 分析：

众所周知，同一**列**的数**横**坐标是一样的，同一**行**的数的**纵**坐标是一样的，而坐标轴的对角线有两条，即穿过一、三象限的和穿过二、四象限的（即 $y=x$ 和 $y=-x$），平行于 $y=x$ 的直线上的点， $x-y$ 的值是一定的；平行于 $y=-x$ 的直线上的点， $x+y$ 的值是一定的。

那么分别开出四个桶，把上述四种情况的点存进去，只要有一种的点达到了 $k$ ，就输出，结束程序。

### Code

```
#include<iostream>
using namespace std;
int n,k,x,y;
const int a=2000010,b=1000000;
int t1[a],t2[a],t3[a],t4[a];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;++i)
	{
		cin>>x>>y;
		t1[x+b]++;  //相应列的点加一
		t2[y+b]++;  //相应行的点加一
		t3[x+y+b]++;  //相应平行于 y=-x 的直线上的点加一
		t4[x-y+b]++;  //相应平行于 y=x 的直线上的点加一
		if(t1[x+b]==k||t2[y+b]==k||t3[x+y+b]==k||t4[x-y+b]==k)  //如果任意一种达到了 k
		{
			cout<<i;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}

```


---

## 作者：Waaifu_D (赞：1)

## 题意简述

给我们 $n$ 个点，求一个 $ans$ 满足这些点中的前 $ ans$ 个点中至少有 $k$ 个点在一条直线上

## 题意分析

实际上题目中给了提示，点在一条直线上的情况有四种

- 1.在同一行（ $y$ 值相等）

- 2.在同一列（ $x$ 值相等）

- 3.在左上到右下的一条斜线上（这时候 $x+y$ 为定值）

- 4.在右上到左下的一条斜线上（这时候 $x-y$ 为定值）

然后我们可以利用桶排的思想，把值相等的 $x$ 或者 $y$ 或者其他情况的次数放到一个桶里，当任意一个桶的存的次数达到 $k$ 的时候，输出 $i$ 即可

## Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
int maxx=100000;
int heng[1000005];
int lie[1000005];
int z[1000005*2+10];//因为存的是x+y，所以要双倍空间
int r[1000005*2+10];//保个险
int main()
{
	cin>>n>>k;
	for(int i=1; i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		heng[y]++;
		lie[x]++;
		z[x+y]++;
		r[x-y+maxx]++;//加上maxx是因为要防止下标小于0
		if(heng[y]==k||lie[x]==k||z[x+y]==k||r[x-y+maxx]==k)
		{
			printf("%d",i);
			return 0;
		}
	}
	cout<<-1;//无解记得输出-1
	return 0;
	
}
```


---

## 作者：_Yoimiya_ (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P7661)

解题思路：  

看到题目自然而然地想到了用桶统计，看到数据范围是 $10^6$ 可以使用。  

建 4 个桶来统计行、列和两条对角线。

- 统计行的桶（row 数组）： 所有点纵坐标都一致。

- 统计列的桶（column 数组）： 所有点横坐标都一致。

- 统计左上至右下的对角线（diagonal_1 数组）: 简单证明一下，设开始坐标为（$x_1$ , $y_1$），则这条对角线下一个坐标为 （$x_1 + 1$ , $y_1 - 1$），以此类推，故横纵坐标的和永远相等，按此统计即可。

- 统计右上至左下的对角线（diagonal_2 数组）：证明大抵与上相同，按横纵坐标的差来存即可。

最后按题目计算即可。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register int
const int M(1e6+1);
int n,k;
int row[M],column[M],diagonal_1[(M<<1)+1],diagonal_2[(M<<1)+1];//统计数组：行列及两条对角线 
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(rg i(1);i<=n;++i){
		int x,y;cin>>x>>y;
		++row[x];++column[y];//统计行列 
		++diagonal_1[x+y];++diagonal_2[x-y+M];//统计对角线（加上 M 是为了防止负下标） 
		if((row[x]==k)||(column[y]==k)||(diagonal_1[x+y]==k)||(diagonal_2[x-y+M]==k)){//符合条件 
			cout<<i;return 0;
		}
	}
	cout<<-1;return 0;//无解 
}
```

---

## 作者：CPPfive (赞：0)

## 题目分析


 题目中一共有四种情况：
 
1. 同一行，即 $y$ 值相等

2. 同一列，即 $x$ 值相等

3. 平行于 $y=x$ 的直线，即 $x-y$ 为定值

4. 平行于 $y=-x$ 的直线，即 $x+y$ 为定值

所以直接对四种情况各开一个桶即可，注意第三种情况下要保证数组下标为正值。


## 代码

```
//洛谷P7661 
#include <bits/stdc++.h>
using namespace std;
#define cin std::ios::sync_with_stdio(false);cin//输入优化
const int MAXN=100050;
int N,K,hang[100050],lie[100050],Y_equal_X[210000],_Y_equal_X[210000];

int main()
{
	cin >> N >> K;
	for(int i=1;i<=N;i++){
		int a,b;cin >> a >> b;
		hang[b]++;lie[a]++;
		Y_equal_X[b-a+MAXN]++;//加上MAXN保证下标大于0 
		_Y_equal_X[a+b]++;
		if(hang[b]==K||lie[a]==K||Y_equal_X[b-a+MAXN]==K||_Y_equal_X[a+b]==K){
			cout << i << endl;
			return 0;
		}
	}
}
```




---


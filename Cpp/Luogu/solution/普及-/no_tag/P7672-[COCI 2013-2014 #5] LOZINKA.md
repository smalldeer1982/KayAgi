# [COCI 2013/2014 #5] LOZINKA

## 题目描述

给出一些长度为奇数的字符串，请你找出一个字符串，且它反转后的字符串也在给出的字符串中。

例如：字符串 `abcca`，如果满足条件，则字符串 `accba` 也必须出现在输入的字符串中。

输出这个字符串的长度和它处于最中间的字符。

## 说明/提示

**【样例解释 #1】**

`las` 和 `sal` 是符合要求的字符串对，长度为 $3$，中间的字符为 `a`。

**【样例解释 #2】**

`kisik` 是回文串，翻转后的字符串仍是 `kisik`，满足要求。

**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le 100$，$3\le $ 字符串长度 $\le 13$，所有字符串均由小写字母组成，保证答案是唯一的。

**【说明】**

本题分值按 COCI 原题设置，满分 $50$。

题目译自[COCI2013_2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #5](https://hsin.hr/coci/archive/2013_2014/contest5_tasks.pdf) _**T1 LOZINKA**_

## 样例 #1

### 输入

```
4
las
god
psala
sal ```

### 输出

```
3 a```

## 样例 #2

### 输入

```
4
kisik
ptq
tttrp
tulipan```

### 输出

```
5 s```

# 题解

## 作者：落河之秋 (赞：8)

## 题意

给出 $n$ 个长度为**奇数**的字符串，求出一对互为回文的串并输出其长度及中央字符。特别地，如果其**本身**为一个回文串也计入答案。

## 分析

+ 我们可以建立一个 string 类型与 int 类型相互映射的 **map** 来模拟**桶**，如果其回文串出现次数不为零，则输出结果并结束程序。

+ 由于我们计入的是次数，所以并不需要特判本身为回文串的情况，因为在**读入原串时**已经记录过出现次数了。

## 代码

```cpp
#include <string>
#include <map>
#include <iostream>

using namespace std;

map <string,int> a;
int n;
string s[101];

string fz(string sample) //判断回文
{
	for(long long i = 0; i < sample.size() / 2; i++)
	{
		swap(sample[i],sample[sample.size() - i - 1]);
	}
	
	return sample;
}

int main()
{
	cin>>n;
	
	for(int i = 1; i <= n; i++)
	{
		cin>>s[i];
		
		a[s[i]]++; //计入次数
	}
	
	for(int i = 1; i <= n; i++)
	{
		if(a[fz(s[i])] > 0) //出现次数不为零
		{
			cout<<s[i].size()<<" "<<s[i][s[i].size() / 2];
			return 0;
		}
	}
}
```


---

## 作者：AmaZingFantasy (赞：2)

题意：给 $n$ 个字符串，找到一对互为回文的，输出它们的长度和中间项（要判断自己和自己互为回文的情况）。

拿到这道题时，第一个想法就是使用 $2$ 个下标把字符串数组中所有的组合枚举出来，再判断是不是互为回文串。

若是，输出长度和中间字符；若不是，再次枚举。

这样时间复杂度为 $O (n ^{2})$，符合数据范围，所以可行。



代码为：
```
#include <iostream>
#include <string>
using namespace std;
typedef long long l;
//定义反转函数
string zhuan(string h){
    l len=h.length();
    for(l i=0;i<len/2;i++){
        swap(h[i],h[len-i-1]);
    }
    return h;
}
int main(){
    l a;
    cin>>a;
    string arr[a];
    for(l i=0;i<a;i++){
        cin>>arr[i];//输入字符串
    }
    for(l i=0;i<a;i++){
        for(l j=i;j<a;j++){
            if(zhuan(arr[i])==arr[j]){
            //判断是否互为回文，若是，就输出字符串+中间项。
                cout<<arr[i].length()<<" "<<arr[i][arr[i].length()/2];
                break;
            }
        }
    }
    return 0;
}

```


---

## 作者：zhang1234 (赞：1)

## 1.思路

这道题要先把所给的字符串反转过来，然后再挨个和原来的那些字符串比较，相等就是符合条件，然后输出这个字符串的长度和它处于最中间的字符。

## 2.细节

+ 因为字符串长度是奇数，所以输出反转后和反转前都可以。
+ 数据范围是 $1$ 到 $100$ （包括 $1$ , $100$ ），所以开字符串数组时要注意大小。
+ 输出格式是中间空一个空，最好严格按照题面输出。

## 3.代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

string a[103],b[103];//注意范围 

int main()
{
	int n;
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>a[i]; 
		for(int j = a[i].size()-1;j >= 0;j--)
		{
			b[i] += a[i][j];
		}
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)
		{
			if(a[i] == b[j])
			{
				
				cout<<b[j].size()<<" ";
				cout<<b[j][b[j].size()/2];
				 
				return 0;
			}
		}
	}
	return 0;
}
```


---

## 作者：Nygglatho (赞：1)

我们可以先直接把整一个字符串以及其反转的字符都记录在一个数组内，这样，就直接用一个双重循环，先从 $1$ 至 $N$ 循环，读入每一个字符串，然后从字符串长度减 $1$ 至 $0$ 循环，记录反转的字符，把其加到反转字符串的最后面。

然后，就有了两个字符串。这样我们可以暴力枚举每一种可能，如果找到，则输出，并且结束。

需要注意的是，即使是**同一个字符串**，也需要判断进去，如样例 2。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
string st[1001], zh[1001];
//分别存储字符串与反转字符串
int n;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> st[i];
		for (int j = st[i].size() - 1; j >= 0; j--) zh[i] += st[i][j];
        //反转字符
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (st[i] == zh[j]) {
				cout << st[i].size() << ' ' << st[i][st[i].size() / 2];
				//输出长度和中间字符
				//要注意，字符串是从0至长度减1存储，所以不用再在st[i].size() / 2后面加1
				return 0;
			}
} 
```

---


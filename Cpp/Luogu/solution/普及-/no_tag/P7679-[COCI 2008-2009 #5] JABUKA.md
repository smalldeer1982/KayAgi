# [COCI 2008/2009 #5] JABUKA

## 题目描述

Mirko 拥有 $R$ 个红苹果和 $G$ 个绿苹果，他想把他分给若干个朋友，使得所有朋友分得的红苹果个数和绿苹果个数都一样。由于 Mirko 自己不喜欢苹果，所以他不会给自己留苹果。

例如，假设 Mirko 有 $4$ 个红苹果和 $8$ 个绿苹果，则以下是分配苹果的所有方案：

- 分给一个朋友，即将 $4$ 个红苹果和 $8$ 个绿苹果全部分给这个朋友。
- 分给两个朋友，每个朋友分得 $2$ 个红苹果和 $4$ 个绿苹果。 
- 分给四个朋友，每个朋友分得 $1$ 个红苹果和 $2$ 个绿苹果。

现给定 $R,G$，请你帮助 Mirko 找到所有的分配苹果的方案。可以证明一定存在分配苹果的方案。

## 说明/提示

**【数据范围】**

对于所有数据，$1\leqslant R,G\leqslant 10^9$。

**【题目来源】**

本题来源自 **_[COCI 2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST 5](https://hsin.hr/coci/archive/2008_2009/contest5_tasks.pdf) T2 JABUKA_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 8```

### 输出

```
1 4 8
2 2 4
4 1 2```

## 样例 #2

### 输入

```
15 12```

### 输出

```
1 15 12
3 5 4```

## 样例 #3

### 输入

```
42 105```

### 输出

```
1 42 105
3 14 35
7 6 15
21 2 5```

# 题解

## 作者：清小秋ovo (赞：12)

# P7679 题解

这个题的题意其实非常明了，只需要枚举出 $a$ 和 $b$ 的所有公因数即可。

当我看到这个题的思路如此简单时，就立马跑到下面看了一眼数据范围。

~~这题果然不简单。~~


## 题意解析

这里就不做过多赘述了，说白了就是找出两个数的所有公因数，因为这样才能满足同时平均分配的要求。

那么这个题的问题其实可以转化为：

**如何快速枚举出两数的所有公因数并将其升序输出？**

## 解题思路

第一步，我们需要找出两个数字的最大公因数:
$$ \gcd(a,b)$$

这个数字便是我们需要枚举的最大范围。

可是这样的优化是远远不够的。

但是我们只要能够证明出，**两数的所有公因数，一定是 $\gcd(a,b)$ 的因数**，那么代码的速度就可以极大的被提升。

该如何证明呢？

设两数分别为 $a$ 和 $b$，$k=\gcd(a,b)$。

则有：

$$a=k\times m$$
$$b=k\times n$$

不难看出，$m$ 与 $n$ 互质。

设 $x$ 为 $a$ 和 $b$ 的任意一个公约数，则：

$$a=p\times x$$
$$b=q\times x$$

若 $x$ 不是 $k$ 的因子，则：

$$a=k\times m=p\times i\times j=p\times x$$
$$b=k\times n=q\times i\times j=q\times x $$

 $i$ 是 $k$ 的因数，$j$ 是 $m,n$ 的因数。
 
 因为 $i<x$，所以 $j>1$。
 
 这样就导致 $m,n$ 的公因数 $>1$， 与 $m,n$ 互质的特性矛盾。
 
 这样就成功证明，两个正整数的公因数一定是它们最大公因数的因数。
 
 在确定完这一特征之后，我们就可以进一步优化算法，将原来的枚举范围缩减到：
 
 $$\sqrt {\gcd(a,b)}$$
 
 或者：
 
 $$\sqrt k$$
 
 因为如果我们确定了一个数 $i$ 是 $k$ 的因数，那么我们就自动的找出了 $k$ 的另外一个因数，也就是 $\frac k i$。
 
 所以在第一遍循环时，一边找到从 $1$ 至 $\sqrt k$ 的所有因数，并且对于每个因数，同时记录下 $\frac k i$ 的值，并存入一个容器中。
 
 注意这里存值的时候需要特判是否为一个完全平方数，如果是的话就不进行存入了，不然会输出重复。
 
 在第一遍循环完成后，**倒序**输出容器中的每一个数，以保证最终的结果是升序排列的。
 
 ## 代码
 
 返回最大公因数的函数
 
 ```cpp
int gcd(int a,int b) {  return b > 0 ? gcd(b, a%b) : a;  } 
```
第一个循环，求出前半部分的因数，并存入后续的因数

```cpp
//n为sqrt(k), k为gcd(a,b)
for(int i=1;i<=n;i++){
       if(k%i==0){
           cout<<i<<" "<<a/i<<" "<<b/i<<endl;
           //注意这里需要特判
           if(i*i!=k)  num.PB(k/i);
       }
   }
```

倒序输出

```cpp
for(int i=num.size()-1;i>=0;i--){
       cout<<num[i]<<" "<<a/num[i]<<" "<<b/num[i]<<endl;
   }
```

 ## 完整代码
 
 ```cpp
#include<bits/stdc++.h>

using namespace std;
typedef vector<int> vi;
#define PB push_back

//最大公因数
int gcd(int a,int b) {  return b > 0 ? gcd(b, a%b) : a;  } 
int main()
{
   ios::sync_with_stdio(0);
   cin.tie(0);
   int a,b;
   vi num;
   cin>>a>>b;
   int k = gcd(a,b);
   int n=int(sqrt(gcd(a,b)));
   for(int i=1;i<=n;i++){
       if(k%i==0){
           cout<<i<<" "<<a/i<<" "<<b/i<<endl;
           if(i*i!=k)  num.PB(k/i);
       }
   }
   for(int i=num.size()-1;i>=0;i--){
       cout<<num[i]<<" "<<a/num[i]<<" "<<b/num[i]<<endl;
   }
}

```

菜鸡一个，有写的不好的地方请多多包涵。
 

---

## 作者：Unordered_OIer (赞：5)

# P7679 题解

~~大部分人应该都是一样看到 WYX 的犇犇才来的吧（~~

## Description

给定 $r,g$，求不定方程
$$\begin{cases}xy=r\\xz=g\end{cases}$$
的所有正整数解

## Solution

首先，$y,z$ 都可以用 $x$ 表示一下：

$$\begin{cases}y=\frac{r}{x}\\z=\frac{g}{x}\end{cases}$$

因为全是正整数解，所以显然要 $x \mid r$ 且 $x \mid g$，进而得到结论：

$$x \mid (r,g)$$

- 此处 $(a,b)$ 表示 $a,b$ 的最大公约数。

那么记 $n=(r,g)$，我们只需要枚举 $n$ 的因数即可。

乍一看好像只能 $1 \rightarrow n$ 枚举，但是实际上，我们知道如果 $a \times b=c$，那么 $a,b$ 都是 $c$ 的因数，所以因数成对出现，而其中较小的因数都是 $ \leq \sqrt{n}$ 的，所以 $\mathcal O(\sqrt n)$ 枚举即可。

复杂度？

首先 $n \leq \min(r,g)=10^9$，那么 $\sqrt n \leq \sqrt{10^9} < 10^5$。

所以，稳过~

## Code
看到题解区各位大佬有的使用数组，有的用 vector。

当然这些都能用，但是我觉得对于我这种懒人来说用 set 不是更方便嘛，可以自动去重（

当然，用 set 得自定义 < 号。

```cpp
struct gg{
	ll x,y,z;
	bool operator < (const gg &a) const {
		return x<a.x;
	}
};
set<gg> a;
int main(){
	r=read(),g=read();
	n=gcd(r,g);
	for(ll i=1;i*i<=n;i++){
		if(n%i==0){
			a.insert((gg){i,r/i,g/i});
			a.insert((gg){n/i,r/(n/i),g/(n/i)});
		}
	}
	for(set<gg>::iterator it=a.begin();it!=a.end();it++)
		printf("%lld %lld %lld\n",it->x,it->y,it->z);
	return 0;
}
```

****

UPDATE：审核时说 gcd 为平方数我就没了，但我用的是 set，set 可以自动去重。

例如 $r=9,g=18$ 时，gcd 为 $9$ 是平方数

正确输出应是

```
1 9 18
3 3 6
9 1 2
```

此程序输出是

```
1 9 18
3 3 6
9 1 2
```

没有问题吧（

---

## 作者：ImposterAnYu (赞：3)

# 解析
这道题的意思就是给出两个整数 $r$ 和 $g$，求出所有的 $x$、$y$、$z$，使得所有的 $x$、$y$、$z$ 满足 $\begin{cases}xy = r\\xz = g\\\end{cases}$。

首先我们可以很快地想到：先算出 $\gcd(r,g)$，再从 $x = 1$ 一直枚举到 $x = \gcd(r,g) - 1$，如果 $x$ 符合条件就存入数组。

枚举完后，再顺序输出符合条件的 $x$、$r\ \div x$ 和 $g\ \div x$（包括 $x = \gcd(r,g)$ 的情况）。
# TLE code
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,g,i,a[10000005],s = 1;
int anyu(int a,int b){//计算 gcd(r,g) 的函数。
	if(!b){
		return a;
	}
	return anyu(b,a % b);
}
int main(){
    cin >> r >> g;
    a[1] = anyu(r,g);
    for(i = a[1] - 1; i >= 1; i--){//枚举 
    	if(r % i == 0 && g % i == 0){
    		s++;
    		a[s] = i;//符合条件就存入数组。 
    	}
    }
    for(i = s; i >= 1; i--){
    	cout<< a[i] << " " << r / a[i] << " " << g / a[i] << endl;//将符合条件的数输出。 
    }
    return 0;
}   
```
然后……很完美地 TLE 了最后一个点呢~
# 优化
首先，我们来~~分尸~~分析一下为什么 TLE：

依次枚举 $x = 1$ 到 $x = \gcd(r,g) - 1$，在最坏的情况下（即 $\gcd(r,g) = \min(r,g)$ 时），时间复杂度为 $O(\min(r,g))$。而 $1 \leq r,g \leq 10^9$，不超时才怪呢！

~~万恶的 Eason_AC，hack 数据出那么大干嘛啊？！~~

于是，我们应该优化一下：

因为当 $x$ 为 $\gcd(r,g)$ 的因数时，$\gcd(r,g)\ \div x$ 也会是 $\gcd(r,g)$ 的因数，所以我们找到一个符合条件的 $x$，就相当于找到了两个！

特别说明，当 $x = \sqrt{\gcd(r,g)}$ 时，还是只找到了一个。

所以，我们只要再稍微特判一下 $x$ 是否等于 $\sqrt{\gcd(r,g)}$，就可以让时间复杂度降为 $O(\sqrt{\min(r,g)})$，完全可以通过啦！
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,g,i,a[10000005],s = 1;
inline int anyu(int a,int b){//计算 gcd(r,g) 的函数。
	if(!b){
		return a;
	}
	return anyu(b,a % b);
}
int main(){
    cin >> r >> g;
    a[1] = anyu(r,g);
    for(i = 1; i * i <= a[1]; i++){//高效枚举。
    	if(r % i == 0 && g % i == 0){
    		s++;
    		a[s] = i;//符合条件就存入数组。
    		if(i * i != a[1]){//特判。 
    			s++;
    			a[s] = a[1] / i; 
    		}
    	}
    }
    sort(a + 1,a + s + 1);//所有 x 的大小关系混乱，所以要排序。 
    for(i = 1; i < s; i++){//如果 i <= s 的话，最后会多输出一组重复的。 
    	cout<< a[i] << " " << r / a[i] << " " << g / a[i] << endl;//将符合条件的数输出。
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：3)

## Content
Mirko 拥有 $R$ 个红苹果和 $G$ 个绿苹果，他想把他分给若干个朋友，使得所有朋友分得的红苹果个数和绿苹果个数都一样。现给定 $R,G$，请你帮助 Mirko 找到所有的分配苹果的方案。可以证明一定存在分配苹果的方案。

**数据范围：$1\leqslant R,G\leqslant 10^9$。**
## Solution
供题的时候也没有想到会有复杂度 $\mathcal O(\gcd\{R,G\})$ 的复杂度过去……于是随手造了个数据把错解卡了，顺便来水水题解。

我们发现，朋友的个数必然是 $R,G$ 的公因数，所以我们不妨先求出 $\gcd\{R,G\}$，然后在修改了数据之后，直接枚举到 $\gcd\{R,G\}$ 肯定是不可行的了。那怎么办呢？我们不妨想想，**如果 $x$ 是一个数 $n$ 的因子，那么 $\dfrac{n}{x}$ 肯定也是这个数的因子**。所以我们不妨以 $\left\lfloor\sqrt{\gcd\{R,G\}}\right\rfloor$ 为上界枚举朋友个数，一旦找到了一个因子 $i$ 就把朋友数分别为 $i$ 和 $\dfrac{\gcd\{R,G\}}{i}$ 的方案全加入答案中，这样既可以保证面面俱到，又可以保证时间不会超限。

又由于这道题目要求我们要按照朋友个数升序排列，于是我们就可以开一个 vector，把答案计入到 vector 之后直接按照朋友个数升序排序输出就好了。具体实现见代码。
## Code
```cpp
struct node {
    int p, ri, gi;
    bool operator < (const node& t) const {return p < t.p;}
};
vector<node> ans;

int main() {
    int r = Rint, g = Rint, n = __gcd(r, g);
    F(int, i, 1, (int)sqrt(n))
        if(!(n % i)) {
            ans.push_back((node){i, r / i, g / i});
            if(i != n / i) ans.push_back((node){n / i, r / (n / i), g / (n / i)});
        }
    sort(ans.begin(), ans.end());
    F(int, i, 0, (int)ans.size() - 1) printf("%d %d %d\n", ans[i].p, ans[i].ri, ans[i].gi);
    return 0;
}
```

---

## 作者：_caiji_ (赞：2)

设题目中分给每个朋友的苹果数为 $x$，显然有 $x\vert r\land x\vert g$，也就是 $x\vert \gcd(r,g)$。

我们都知道，如果 $a\times b=c$，那 $a$ 和 $b$ 都是 $c$ 的因数，也就是说**因数都是成对出现的**（注意特判完全平方数）。

那么，枚举 $\gcd(r,g)$ 的所有因数，可以枚举 $i$ 从 $1$ 到 $\sqrt{\gcd(r,g)}$，如果 $i\vert \gcd(r,g)$，说明 $i$ 和 $\frac{\gcd(r,g)}{i}$ 都是 $\gcd(r,g)$ 的因数。这样，我们算法的时间复杂度就只有 $O(\sqrt{\gcd(r,g)})$，可以轻松通过本题。

下面给出一种代码实现：
```cpp
#include <cmath>
#include <iostream>
using namespace std;
int gcd(int a,int b){return !b?a:gcd(b,a%b);}
int a,b,k,l;//k=gcd(a,b), l=sqrt(k)
int main(){
    cin>>a>>b;
    k=gcd(a,b);
    l=sqrt(k);
    for(int i=1;i<=l;i++){
        if(k%i==0){
            cout<<i<<" "<<a/i<<" "<<b/i<<endl;
        }
    }
    for(int i=l-(l*l==k);i>=1;i--){
    //这里的 l-(l*l==k)，是在特判 k 为完全平方数的情况，如果 k 确实是，那么直接 -1，避免再一次枚举 l 的情况
        if(k%i==0){
            cout<<k/i<<" "<<a/(k/i)<<" "<<b/(k/i)<<endl;
        }
    }
    return 0;
}
```


---

## 作者：CSP_Sept (赞：2)

### Description

给定 $r,g$，求所有的整数对 $(x,y,z)$，满足 $xy=r,xz=g$。

### Solution

由题我们发现，$x$ 必定是 $r,g$ 的公因数。

考虑 $O(\sqrt r)$ 枚举 $r$ 的因数 $i$，同时判断 $i$ 和 $\dfrac ri$ 是否为 $g$ 的因数。

将所有答案储存在结构体数组 $p$ 中，最后排序输出。

那这个 $p$ 要开多大呢，显然是 $2\sqrt r=2\times 10^{4.5}\approx6.4\times10^4$。我这里直接开了 $10^6$。

### Code

```cpp
struct node{
	int x, y, z;
};
bool cmp(node a, node b){
	return a.x < b.x;
}
node p[1000010];
int ans = 0;
int r, g;
int main(){
	r = rd(), g = rd();
	for(int i = 1 ; i * i <= r ; i++){
		if(r % i == 0){
			if(g % i == 0){
				p[ans].x = i;
				p[ans].y = r / i;
				p[ans].z = g / i;
				ans++;
			}
			if(g % (r / i) == 0 && i * i != r){
				p[ans].x = r / i;
				p[ans].y = i;
				p[ans].z = g / (r / i);
				ans++;
			}
		}
	}
	sort(p, p + ans, cmp);
	for(int i = 0 ; i < ans ; i++)
	    printf("%d %d %d\n", p[i].x, p[i].y, p[i].z);
	return 0;
}
```

### Background

![](https://cdn.luogu.com.cn/upload/image_hosting/7e3ek17t.png)

---

## 作者：Griseo_nya (赞：1)

~~从WYXkk 犇犇来的~~
### 题意简述
给定 $R$,$G$，输出所有满足 $x \cdot y=R$，$x\cdot z=G$ 的三元组 $(x,y,z)$，且 $x$，$y$，$z$ 均为正整数。
### 思路
可以发现 $x$ 必为 $R$ 和 $G$ 的公约数，我们考虑枚举 $\gcd(R,G)$ 的因数。下文设 $l=\gcd(R,G)$。

但是我们发现，体中所给 $R$ 和 $G$ 均小于等于 $10^{9}$，无法 $O(l)$ 枚举，但我们发现 如果 $i$ 是数 $l$ 的因数，那么 $\dfrac{l}{i}$ 也是 $l$ 的因数，可以将这两个因数都加入答案序列中，最后排序即可。这样我们可以把时间复杂度控制到 $O(\sqrt{l})$ 以内。

但是还有一个小坑点，就是当 $l$ 是平方数时，$\dfrac{l}{i}=i$，这个时候会有一组答案重复，需特判，或 ```unique()``` 判重，我这里选择了特判 $i\cdot i=l$ 时只向队列中加入 $i$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int r,g,l;
	cin>>r>>g;
	l=__gcd(r,g);										//使用内置gcd
	deque<int> q;										//开一个双端队列存储答案
	for(int i=1;i*i<=l;i++){
		if(i*i==l)q.push_back(i);						//特判 i*i=l
		else if(l%i==0)q.push_back(i),q.push_back(l/i);	//其他情况向答案中加入 i 和 l/i
	}
	sort(q.begin(),q.end());							//排序
	for(int i=0;i<q.size();i++){
		cout<<q[i]<<' '<<r/q[i]<<' '<<g/q[i]<<'\n';		//输出答案
	}
	return 0;
} 
```


---

## 作者：哈士奇憨憨 (赞：0)

## 题意
给定两个整数 $r,g$，求不定方程 $\begin{cases}xy = r \\xz = g\end{cases}$ 的所有解。
## 思路
我们很快能想到 $\gcd(r,g)$ 是朋友个数最大的，$1$ 是朋友个数最小的。于是只需要把 $\gcd(r,g)$ 分解质因数就行了。
### gcd CODE
```cpp
int gcd(int a,int b) {  
	return b > 0 ? gcd(b, a % b) : a;  
} 
```
### 分解质因数
若 $a|c$，则很明显 $\dfrac{a}{c}|c$，因为质因数是成双成对出现的（除了平方数），所以我们只需要枚举到 $\sqrt{\gcd(r,g)}$ 就行了。

注意特判平方数。
```cpp
for(int i = 1; i * i <= c; i++){
		if(c % i == 0 && c / i != i){
			d[l++] = i,d[l++] = c / i;
		} else if(c % i == 0 && c / i == i){
			d[l++] = i;
		}
	}
```
## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,g,d[10000001],l;
int gcd(int a,int b) {  //最大公约数
	return b > 0 ? gcd(b, a % b) : a;  
} 
int main(){
	cin >> r >> g;
	int c = gcd(r,g);
	for(int i = 1; i * i <= c; i++){
		if(c % i == 0 && c / i != i){
			d[l++] = i,d[l++] = c / i;
		} else if(c % i == 0 && c / i == i){//特判平方数
			d[l++] = i;
		}
	}
	sort(d , d + l);//因为所有的数字大小关系混乱，所以要排序。
	for(int i = 0; i < l; i++){
		cout << d[i] << " " << r / d[i] << " " << g / d[i] << endl; 
	}
	return 0;
}
```

---

## 作者：Nemonade (赞：0)

因为朋友和每个朋友分到的苹果都必须是整数，那么所以朋友数 (这里设为 $a$ ) 必须整除苹果数 $r$ 和 $g$ ，即 $r|a$ 且 $g|a$ 。

------------

30 point

暴力的思路，我们可以从 $1$ 开始枚举所有可能的朋友数，复杂度为 $O(min(r,g))$ :

```cpp
#include<bts/stdc++.h>
using namespace std;
int r,g;
int main(){
	scanf("%d%d",&r,&g);
	for(register int i=1;i<=min(r,g);++i){
		//两种苹果都必须被整除 
		if(r%i!=0||g%i!=0) continue;
		cout<<i<<" "<<r/i<<" "<<g/i<<endl;
	}
	return 0;
}
```
但是 $r,g \le 10^9$ ，这份代码就算卡了常，开了 $\text{O2}$ 也会超时，于是考虑优化。

-----------

50 point

~~话说这道题满分是50分，但是计分系统似乎有点问题~~。。。

因为 $r$ 与 $g$ 都是正整数，所以 $r|gcd(r,g)$ 。所以我们循环只用枚举到 $gcd(r,g)$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,g,gcd;
int main(){
	scanf("%d%d",&r,&g);
	//调用cmath库的内置函数 
	gcd=__gcd(r,g);
	for(register int i=1;i<=gcd;++i){
		if(r%i!=0||g%i!=0) continue;
		cout<<i<<" "<<r/i<<" "<<g/i<<endl;
	}
	return 0;
}
```
~~但是还是会超时。~~

---------

50 point

一个数的因数是成对出现的。即如果 $x$ 是 $y$ 的因数，那么 $y/x$ 也是 $y$ 的因数。

那么如果我们找到了一个因数 $i$ ， $gcd(r,g)/i$ 也是可行的答案。

但是要注意 $i^2=gcd(r,g)$ 的情况，只有一种答案。

具体实现，我使用一个 `vector<int>` 来记录答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,g,gcd;
vector<int> v;
int main(){
	scanf("%d%d",&r,&g);
	gcd=__gcd(r,g);
	for(register int i=1;i<=sqrt(gcd);++i){
		if(r%i!=0||g%i!=0) continue;
		//特判 i^i=gcd(r,g) 
		if(i*i==gcd) v.push_back(i);
		else v.push_back(i),v.push_back(gcd/i);
	}
	//将vector<int> v排序 
	sort(v.begin(),v.end());
	//输出 
	for(register int i=0;i<v.size();++i){
		cout<<v[i]<<" "<<r/v[i]<<" "<<g/v[i]<<endl;
	}
	return 0;
}
```

复杂度 $O( \sqrt{gcd(r,g)} )$ ，可以过。

---


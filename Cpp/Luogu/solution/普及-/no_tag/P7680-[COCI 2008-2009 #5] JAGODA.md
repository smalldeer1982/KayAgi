# [COCI 2008/2009 #5] JAGODA

## 题目描述

Slavko 养了 $n$ 只兔子，他每天用各种水果和蔬菜喂兔子。然而，兔子最喜欢草莓。草莓在隆冬时节很难找到，而且很贵，所以 Slavko 只给部分兔子吃草莓。Slavko 把兔子编号为 $1\sim n$。为了帮助追踪每只兔子得到多少草莓，他决定采用以下草莓分配程序。

Slavko 每天都会买 $S$ 个草莓，然后选一个兔子 $A$ ，然后给它第一个草莓。之后，兔子 $A+1$ 会得到第二个草莓，兔子 $A+2$ 会得到第三个，以此类推。

给每只兔子分配一个最初为空的火柴盒，然后把这 $n$ 个火柴盒排成一排。设 $k$ 为使得 $k^2\leqslant n$ 的最大整数。这样就可以把兔子分成 $\left\lceil\dfrac{n}{k}\right\rceil$组，每组 $k$ 个火柴盒（从第一个开始，最后一组有可能不足 $k$ 个），每组火柴盒旁边也会有一个杯子。我们说 $k$ 个连续的火柴盒和它们的杯子形成一组。

在给兔子草莓之后，Slavko 会把一根火柴放进每个得到草莓的兔子的火柴盒里，**除非**他把火柴放进一组里所有的火柴盒里。此时他不会把火柴放在一组的所有火柴盒里，而是把一根火柴放在这一组所在的杯子里。通过这种方式，兔子收到的草莓总数可以用火柴盒里的火柴数加上杯子里的火柴数来计算。例如，假设 Slavko 有 $11$ 只兔子，即 $n=11$。数字 $3$ 是使得 $k^2\leqslant n$ 的最大整数 $k$，因此 $k=3$。因此这些兔子将会被分成四组（最后一组只有两只兔子和两个火柴盒），自然就会有四个杯子，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/taccw9un.png)

如果 Slavko 买了 $6$ 个草莓，把第一个送给兔子 $5$，杯子和火柴盒里的状态将变为如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/2tfy24vf.png)

现在，请你编写一个程序，给定兔子的数量 $n$、天数 $m$ 以及 $m$ 天中的每一天购买的草莓数量 $S$ 和得到第一个草莓的兔子编号 $A$。对于每一天，输出 Slavko 当天使用的所有火柴盒和杯子中的火柴总数。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，兔子、火柴盒和杯子摆放的情况即为题面中所给出的例子。

第一天即为题面中所给出的例子，因此 Slavko 第一天放入 $4$ 根火柴。

第二天 Slavko 买了 $3$ 个草莓，并将第一个草莓给了 $1$ 号兔子，这样的话，$1$、$2$、$3$ 号兔子都得到草莓，由于它们三个兔子都在一组里面，所以 Slavko 只需要在第 $1$ 个杯子里面放入一根火柴。因此 Slavko 第一天放入 $1$ 根火柴。

第三天，Slavko 可以给他所有的兔子送草莓，所以需要在每个杯子里放一根火柴。总共是把 $4$ 根火柴放到杯子里，他在这天使用的杯子里（就是所有杯子）在他放置后一共有 $6$ 根火柴，所以输出 $6$。

**【数据范围】**

对于所有数据。$1\leqslant n,m\leqslant 10^5$，$1\leqslant A\leqslant n$，$1\leqslant A+S-1\leqslant n$。

**【题目来源】**

本题来源自 **_[COCI 2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST 5](https://hsin.hr/coci/archive/2008_2009/contest5_tasks.pdf) T3 JAGODA_**，按照原题数据配置，满分 $70$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
11 3
6 5
3 1
11 1```

### 输出

```
4
1
6```

## 样例 #2

### 输入

```
16 3
2 2
12 3
6 11```

### 输出

```
2
7
3```

# 题解

## 作者：zymooll (赞：7)

这道题使用的算法是“模拟”，是一道比较考思维的模拟题，根据题目来做即可

我就说几个坑点

1. 统计需要的是在该天中所有放置过的杯子和火柴盒（之前题目翻译有误，详情见讨论区）
2. 最后一组需要特判（因为最后一组可能不是完整的一组）
3. 统计之前放置的时候，是需要计入之前的

更多详细思路见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[100010],b[100010];//a代表火柴盒 b代表杯子
int main(){
    cin>>n>>m;
    int bj=1;//该处的bj等同于题目中的k
    while(bj*bj<=n)bj++;
    bj--;
    /*
    为什么要减1呢？ 因为题目要求是k^2<=n的最大整数
    而我们上述代码求的是k^2>n的最小整数 所以减1即是题目所求
    */
    for(int i=0;i<m;i++){//枚举每一天
        int n1,n2,js=0;
        //n1代表该天购买的数量 n2代表得到第一个的兔子 js代表总共需要的火柴数量
        cin>>n1>>n2;
        for(int j=n2;j<=n1+n2-1;j++){//j枚举每一个可以得到的兔子
            if((j%bj==1&&j+bj-1<=n1+n2-1)||(j%bj==1&&j+bj-1>=n&&n==n1+n2-1)){
                /*
                第一种情况：（非末尾组）
                j%bj==1 代表第j只兔子是否为每个杯子的开头
                j+bj-1<=n1+n2-1 代表这个杯子的末尾是否超过我的草莓数量
                第二种情况：（末尾组）
                j%bj==1 代表第j只兔子是否为每个杯子的开头
                j+bj-1>=n 代表该组为末尾组
                n==n1+n2-1 代表该组最后一个也可以拿到草莓
                */
                b[j]++;//向杯子里放一根火柴
                js+=b[j];
                j+=bj;//直接跳到下一个杯子开头
                j--;
                //特别注意 这里需要减1抵消for循环的加1 （这里调了我好久QaQ）
            }
            else{
                a[j]++;//否则放到火柴盒里
                js+=a[j];
            }
        }
        cout<<js<<endl;
    }
    return 0;
}
```

---

## 作者：Computer1828 (赞：3)

模拟。题目的 $k$ 显然等于 $\sqrt n$，每天发草莓就相当于给其中某个区间丢火柴。

然后你会发现丢火柴的过程很像分块中处理散块和整块的操作。

详细来讲，对于左边和右边那些丢进火柴盒的逐个处理，中间那些整段跳着处理。

注意特判一堆边界和理清各种加减的顺序。

我的程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int a[100005],b[100005];
int main(){
	scanf("%d%d",&n,&m);k = sqrt(n);
	int s,le;
	while(m--){
		scanf("%d%d",&le,&s);
		int t = s+le-1,ans = 0;
		//处理区间[s,t] 
		//散块 
		while(s<=t && s%k!=1) a[s]++,ans += a[s],s++;
		if(t!=n){
			while(s<=t && t%k) a[t]++,ans += a[t],t--;
		}
		//整块 
		while(s<t) ans += ++b[s],s+=k;
		printf("%d\n",ans);
	}
	return 0;
}
```

官方程序：（我删了些原程序的空行，可以注意一下两个 `while` 循环的内容）
```cpp
#include <cmath>
#include <iostream>
using namespace std;
#define MAXN 100000
int box[MAXN], cup[MAXN];
int main() {
   cin.sync_with_stdio(0);
   int N, M;
   cin >> N >> M;
   int K = (int)sqrt(N);
   while ( M-- > 0 ) {
      int B, A;
      cin >> B >> A;
      --A; B += A;
      int ans = 0;
      while ( A < B && A%K != 0 ) ans += ++box[A++];
      if ( B != N ) {
         while ( A < B && B%K != 0 ) ans += ++box[--B];
      }
      while ( A < B ) ans += ++cup[A/K], A += K;
      cout << ans << endl;
   }
   return 0;
}
```

---

## 作者：xiaolu12356 (赞：1)

[P7680 [COCI2008-2009#5] JAGODA](https://www.luogu.com.cn/problem/P7680)

## 题意

给定兔子的数量 $n$、天数 $m$ 以及 $m$ 天中的每一天购买的草莓数量 $S$ 和得到第一个草莓的兔子编号 $A$。对于每一天，输出 Slavko 当天使用的所有火柴盒和杯子中的火柴总数。

## 题解

这是一道**模拟题**。我们不难发现，$k^2\leqslant n$ 的最大整数即为 $\sqrt{n}$。

做的时候我们发现可以用**分块**的方法做这道题。也就是分好几个条件来进行判断当前要丢的火柴是要丢杯子里还是火柴盒里。

主要失分来自最后模拟的时候忘记写**火柴不够 $k$ 的情况**和**边界**的特判以及**输出完 $ans$ 之后 $ans$ 要清零**。

## 官方代码

```cpp
#include <cmath>
#include <iostream>
using namespace std;
#define MAXN 100000
int box[MAXN], cup[MAXN];
int main() {
   cin.sync_with_stdio(0);
   int N, M;
   cin >> N >> M;
   int K = (int)sqrt(N);
   while ( M-- > 0 ) {
      int B, A;
      cin >> B >> A;
      --A; B += A;
      int ans = 0;
      while ( A < B && A%K != 0 ) ans += ++box[A++];
      if ( B != N ) {
         while ( A < B && B%K != 0 ) ans += ++box[--B];
      }
      while ( A < B ) ans += ++cup[A/K], A += K;
      cout << ans << endl;
   }
   return 0;
}
```

---

## 作者：xiaozhu_zty (赞：1)

# P7680 [COCI2008-2009#5] JAGODA 题解

## 前言 

这题难度不大，重要的是认真读题，做好模拟的细节就能轻松AC啦，很适合新手练习模拟。

## 解析

显然题目中最大的 $k^2\le n$ 就是说 $k=\sqrt n$，即一组有$k$个火柴盒，$1$个杯子。题目中有两个容器：火柴盒和杯子（下文用容器 $box$ 和容器 $cup$ 来代替）。每次喂食都会用火柴棍来标记喂食的记录。由于这题的数据量 ($1\le n,m \le 10^5$) ，所以我们可以直接模拟每次喂食，然后在对应容器中进行操作。对于最后的答案，我们可以用 $ans$ 变量来记录。每当向 $box$ 和 $cup$ 中放入一根火柴棍，我们都让对应的数组 $+1$。模拟时分处理开头（处理 $box$ 内的火柴）、中间（处理 $cup$ 内的火柴）和结尾来处理。

## 读题细节！！！

题目中的两个容器每天是不会重置的！所以要用两个数组记录每天的情况，在每次使用该容器时都让 $ans$ 加上那个容器之前放进去的火柴棍，即 `ans+=box[a]` 或 `ans+=cup[a]`（~~写的时候读了半个小时才搞懂~~）

## 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,m;//n只兔子
int box[114514],cup[514114];
int k;
int s,a;//兔子A后的S个兔子都会得到草莓
int ans;
int main(){
	cin>>n>>m;
	k=int(floor(sqrt(n)));		
	for (int i = 0;i<m;i++){
		ans=0;
		cin>>s>>a;
		while ((a-1)%k!=0&&s>0){
			box[a]++;ans+=box[a];
			a+=1,s-=1;
		}
		//cout<<a<<" "<<s<<" "<<ans<<endl;
		//此时a%k=0(后面是(n-a)%k组+可能有的单根火柴)
		while (s>=k&&n-a>=k){
			int wc=int(ceil(a*1.0/k));
			cup[wc]++;ans+=cup[wc];
			s-=k,a+=k;
		} 	
		//此时整组处理完，处理结尾
		if (s==0){
			cout<<ans<<endl;
		} 
		else if ((n-a+1<=k&&s>=n-a+1)||n-a+1==s){//最后不满一组情况也在杯子里 
			int wc=int(ceil(a*1.0/k));
			cup[wc]++;
			cout<<ans+cup[wc]<<endl;
		} 
		else {
			for (int i = a;i<a+s;i++){
				box[i]++;
				ans+=box[i];
			}
			cout<<ans<<endl;
		}
	}
	return 0;
} 
```

---

## 作者：NaOHqwq (赞：1)

## 思路

题意就不多赘述了，题面可能会有点长，但其实是一道不算难的模拟题。

楼上各位的题解也提到过，题目中模拟的操作很像分块思想中在整块和散块上的操作。

（关于分块思想可以看一下[这篇](https://zhuanlan.zhihu.com/p/114268236)文章 qwq。）

模拟过程不用多说，然后就是一些细节性的问题，例如**加减顺序**以及最后一组的**特判**，需要额外注意一下。

最后就可以直接写代码啦。（快读写不写视情况而定，不写快读笔者亲测可以过）

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005], b[100005];
int n, m;
int main(){
    cin >> n >> m;
    int k = 1;
    while(k <= sqrt(n)){
    	k++;
	}
    k--;
    for(int i = 1;i <= m;i++){
        int n1, n2, ans = 0;
        cin >> n1 >> n2;
        for(int j = n2;j <= n1+n2-1;j++){ //枚举兔子
            if((j%k==1 && j+k-1<=n1+n2-1) || (j%k==1&&j+k-1>=n && n==n1+n2-1)){ //记得特判
                b[j]++;
                ans += b[j];
                j += k;
                j--;
            }else{
                a[j]++;
                ans += a[j];
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：dysyzxhzh (赞：0)

# P7680 题解
[传送门](https://www.luogu.com.cn/problem/P7680)

## 大体题意
有 $n$ 只兔子，每天都有 $S$ 个草莓，然后选一只兔子 $A$，给它第一个草莓。之后的兔子 $A+1$ 会得到第二个草莓，兔子 $A+2$ 就会得到第三个，所以 $k$ 显然等于 $\sqrt n$ ，每天发草莓就类似给其中某个区间丢火柴。

## 解析
模拟题
模拟的思路基本就是分块，主要失分在没有对 **边界** 和 **最后一组的特殊情况** 进行特判。（所以构建极端数据来测试是十分重要的）

### 分块简介
分块的基本思想是，通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度。（摘自  **OIWiki** ）

### 官方程序

```cpp
#include <cmath>
#include <iostream>
using namespace std;
#define MAXN 100000
int box[MAXN], cup[MAXN];
int main() {
   cin.sync_with_stdio(0);
   int N, M;
   cin >> N >> M;
   int K = (int)sqrt(N);
   while ( M-- > 0 ) {
      int B, A;
      cin >> B >> A;
      --A; B += A;
      int ans = 0;
      while ( A < B && A%K != 0 ) ans += ++box[A++];
      if ( B != N ) {
         while ( A < B && B%K != 0 ) ans += ++box[--B];
      }
      while ( A < B ) ans += ++cup[A/K], A += K;
      cout << ans << endl;
   }
   return 0;
}
```


---

## 作者：__zfy__ (赞：0)

### 题意
有 $n$ 个~~珂爱的~~兔子，每天给 $S$ 个草莓，选一只兔子，给它第 $1$ 个草莓。之后第 $A + 1$ 个兔子会得到第 $2$ 个草莓，第 $A + 2$ 个兔子会得到第 $3$ 个草莓，第 $A + i$ 个兔子会得到第 $i + 1$ 个草莓。题目中的 $k$ 略微观察就可以发现是 $\sqrt n$，每天发草莓就相当于给其中某个区间丢火柴。
### 思路
分析出“每天发草莓就相当于给其中某个区间丢火柴”就可以直接的发现喂草莓的过程很像分块中处理散块和整块的操作。只要对开始和结束喂得草莓分别处理，接着对 $A + 1$ 到 $A + x$ 喂得这些草莓逐个跳跃处理即可。
### 代码
官方程序。
```cpp
#include <cmath>
#include <iostream>
using namespace std;
#define MAXN 100000
int box[MAXN], cup[MAXN];
int main() {
   cin.sync_with_stdio(0);
   int N, M;
   cin >> N >> M;
   int K = (int)sqrt(N);
   while ( M-- > 0 ) {
      int B, A;
      cin >> B >> A;
      --A; B += A;
      int ans = 0;
      while ( A < B && A%K != 0 ) ans += ++box[A++];
      if ( B != N ) {
         while ( A < B && B%K != 0 ) ans += ++box[--B];
      }
      while ( A < B ) ans += ++cup[A/K], A += K;
      cout << ans << endl;
   }
   return 0;
}
```


---

## 作者：Soul_direction (赞：0)

[P7680题目传送门](https://www.luogu.com.cn/problem/P7680)

[听说博客食用更佳呦](https://www.luogu.com.cn/blog/luogucodingjvruo/p7680-coci2008-20095-jagoda-ti-xie-post)

### 题目概要：

一共有 $n$ 个小粉兔，每天都有 $S$ 个草莓，然后选一个小粉兔，扔给它第一个草莓。之后，第二个草莓会扔给第 $A+1$ 个小粉兔，第三个会扔给第 $A+2$ 个小粉兔，以此类推。题目的 $k$ 显然等于 $\sqrt[2]{n}$，每天扔的草莓就相当于给其中某个区间丢火柴。

### 主要思路：

可以发现，这道题很明显需要我们模拟。观察一下，你会发现这個操作貌似好像很像分块（别名：优雅的暴力）的思想。

```plain
块的定义：
块：将整个序列划分为多段序列，这些序列被称之为块。
块的大小：块内元素个数。
整块：在修改操作中，一整个块都被包含在操作的区间中。
散块：在修改操作中，部分元素被包含在操作区间中的块。
```

对丢进火柴盒的（火柴）逐个处理，中间那些整段跳着处理，再注意一下特判（一堆可恶的边界和理清各种难搞的加减顺序），就可以了。

### 代码提要：

#### 核心代码：

```cpp
for(int i=in;i<=after;i++){
	if((i%dis==1&&i+dis-1<=after)||(i%dis==1&&i+dis-1>=n&&n==after)){
		ans+=++b[i];
		i+=dis-1;
	}else{
		ans+=++a[i];
	}
}
```

#### 核心代码解析：

这段代码是特判部分。有 2 种情况：

1. 正常情况特判：指在杯子下的火柴盒在普遍情况下满了，就搞掉，放到大杯子里。
2. 特殊情况特判：指在杯子下的火柴盒是最后一组，且少于普遍情况，特殊情况特殊办，如果这里的火柴盒全满了，那就搞掉，放到大杯子里。

### AC code：（读了上面还没懂的，可以看注释理解一下，蒟蒻的代码，不喜勿喷）

```cpp
/*
	name: luogu(COCI) P7680
	date: 3.26/2023 11:30 
	copyright: Soul_direction
*/
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <ctime>
#include <stdio.h>
#include <algorithm>
#define maxn 100010
using namespace std;
int a[maxn],b[maxn];
int n,m;
inline int read(){// 快读
    int x=0,f; char ch=0;
    while(!isdigit(ch)) f=(ch=='-'?-1:1),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
inline void print(int x){// 快写
    if(x<0) x=-x,putchar('-');
    if(x>9) print(x/10);
    putchar(x%10+48);
}
inline void write(int x){print(x);putchar('\n');}
int main(){
	n=read(),m=read();
	int dis=sqrt(n);// sqrt(n)需要<algorithm>头文件
	while(m--){
		int sum,in;
		sum=read(),in=read();
		int ans=0,after=in+sum-1;
		for(int i=in;i<=after;i++){//暴力枚举兔子
			if( (i%dis==1&&i+dis-1<=after) || (i%dis==1&&i+dis-1>=n&&n==after) ){//令人讨厌而无奈的特判
				ans+=++b[i];
				i+=dis-1;
			}else{
				ans+=++a[i];
			}
		}
		write(ans);
	};
	return 0;// 杀青
}
```

---

## 作者：gzqlbx666 (赞：0)

[$\color{red} \text{P7680题目转送门}$](https://www.luogu.com.cn/problem/P7680)
## 1. 理解题意
一共有 $n$ 个兔子，每天都有 $S$ 个草莓，然后选一个兔子，它第一个草莓。之后，兔子 $A+1$ 会得到第二个草莓，兔子 $A+2$ 会得到第三个，以此类推。题目的 $k$ 显然等于 $\sqrt n$，每天发草莓就相当于给其中某个区间丢火柴。
## 2. 分析
这是一个~~简单的~~模拟题。

细心分析后你会发现丢火柴的过程很像分块中处理散块和整块的操作。
详细来讲，对于左边和右边那些丢进火柴盒的逐个处理，中间那些整段跳着处理。

**注**：注意特判一堆边界和理清各种加减的顺序。（我就是被这个坑点卡了好久,之后看了某位奆佬的题解才反应过来）

**核心代码**

```cpp
	if((j%bj==1&&j+bj-1<=k)||(j%bj==1&&j+bj-1>=n&&n==k)) 
  			{
                ans+=++b[j];
                j+=bj-1;
            }
            else 
            	ans+=++a[j];
```
**核心代码解释**
- **情况一**

$j$ 取余 $b_j=1$ 代表第 $j$ 只兔子是否为每个杯子的开头 $j+b_j-1≤n_1+n_2-1$ 代表这个杯子的末尾是否超过草莓数量
- **情况二**

 $j$ 取余 $b_j=1$ 代表第 $j$ 只兔子是否为每个杯子的开头 $n≤j+b_j-1$ 代表该组为末尾组 $n=n_1+n_2-1$ 代表该组最后一个也可以拿到草莓

## code
```cpp
#include<bits/stdc++.h>
#define N 1000000
using namespace std;
int n,m;
int a[N],b[N];
int main()
{
    cin>>n>>m;
    int bj=sqrt(n);
    for(int i=0;i<m;i++)
	{
		int x,y;
		cin>>x>>y
		int ans=0,k=x+y-1;
			for(int j=y;j<=k;j++)//枚举每一个可以得到草莓的兔子
				if((j%bj==1&&j+bj-1<=k)||(j%bj==1&&j+bj-1>=n&&n==k)) 
  					{
                    	ans+=++b[j];//放火柴
                    	j+=bj-1;//到下一个杯子里面
            		}
            else 
            	ans+=++a[j];//否则放在盒子里
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：CPPfive (赞：0)

## 题目分析

暴力模拟题。

如果熟悉分块的话，你会发现实际上模拟的过程很像分块的时候在整块和零散块上的操作。所以我们可以用类似分块的代码来写这道题（主要是这道题目代码写起来有点烦，用类似分块的代码写起来干净一点）。

如果对代码实现有什么不理解的，可以看代码里的注释。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=100005,MAXS=400;
int N,M,len;
int a[MAXN],b[MAXS],id[MAXN];		//a数组表示火柴盒里的数量，b数组表示杯子里的数量，id表示兔子对应的杯子编号 

void build(){						//预处理id数组 
	int group=1;
	for(int i=1;i<=N;++i){
		id[i]=group;
		if(i%len==0) ++group;
	}
}
int query(int l,int r){
	int res=0;
	if(id[l]==id[r]){				//特判左右端点在一个块里的情况 
		if((l==1||id[l]!=id[l-1])&&(r==N||id[r]!=id[r+1])){	//特判区间刚好占满一整个块的情况 
			++b[id[l]];return b[id[l]];
		}
		else{
			for(int i=l;i<=r;++i){
				++a[i];res+=a[i];
			}
			return res;
		}
	}
	//特判左端点是一个块的第一个点的情况 
	if(l==1||id[l]!=id[l-1]){
		++b[id[l]];res+=b[id[l]];
	}
	else{
		for(int i=l;id[i]==id[l];++i){
			++a[i];res+=a[i];
		}
	}
	//特判右端点是一个块的最后一个点的情况 
	if(r==N||id[r]!=id[r+1]){
		++b[id[r]];res+=b[id[r]];
	}
	else{
		for(int i=r;id[i]==id[r];--i){
			++a[i];res+=a[i];
		}
	}
	for(int xi=id[l]+1;xi<id[r];++xi){
		++b[xi];res+=b[xi];
	}
	return res;
}

int main()
{
	scanf("%d%d",&N,&M);
	len=sqrt(N);
	build();
	for(int i=1;i<=M;++i){
		int S,A;scanf("%d%d",&S,&A);
		printf("%d\n",query(A,A+S-1));
	}
	
	return 0;
}
```


---


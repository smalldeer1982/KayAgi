# [COCI 2013/2014 #2] MISA

## 题目描述

一个 $R\times S$ 的方格，每个人坐在一个方格中，可能存在空位。

每个人都会与自己周围的**八个方格**中的人握手（可能不满 $8$ 人）。

Mirko 是最晚到场的，他按照如下的方式就坐：

- 若有空位，他会坐在一个能使他能与最多的人握手的空位上。
- 若没有空位，他会离开。

求出 Mirko 就坐后人们的握手次数。

## 说明/提示

#### 样例 1 说明

```plain
..o
oo.
```

是满足要求的一种最终就坐方式。

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $R=1$。
- 对于另外 $20\%$ 的数据，有 $R=2$。
- 对于另外 $20\%$ 的数据，座位坐满了。
- 对于 $100\%$ 的数据，有 $1\le R,S\le 50$。

#### 来源

**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T2 MISA_。**

按照原题数据配置，本题满分 $80$ 分。

## 样例 #1

### 输入

```
2 3 
..o 
o..```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2 
oo 
oo```

### 输出

```
6```

# 题解

## 作者：lanretE (赞：2)

先定义一个函数计算握手次数。

然后读入行列与当前座位，如果座位全满则直接计算握手次数输出。

否则，寻找最优座位，由于此题数据范围小的可怜，我们直接使用**暴力枚举**。

枚举时记录当前最优座位以及最优位置坐标，如果找到更优的就更新。

枚举完后记得把最优位置变成有人的。

然后输出即可。



------------
## 上代码：

```
#include<bits/stdc++.h>
using namespace std;
int r,s;
int maxx=-1,max_x,max_y;
char pos[55][55];
int dx[]={666,1,0,-1,0,1,1,-1,-1};
int dy[]={666,0,1,0,-1,-1,1,-1,1};

int calc(){
	int cnt=0;
	for(int i=1;i<=r;++i)
		for(int j=1;j<=s;++j)
			if(pos[i][j]=='o'){//如果当前座位有人才能握手 
				for(int k=1;k<=8;++k)
					if(i+dx[k]>0 && i+dx[k]<=r && j+dy[k]>0 && j+dy[k]<=s && pos[i+dx[k]][j+dy[k]]=='o') cnt++; 
			}
	return cnt/2;
}

int main(){
	cin>>r>>s;
	bool flag=0;
	for(int i=1;i<=r;++i)
		for(int j=1;j<=s;++j){
			cin>>pos[i][j];
			if(pos[i][j]=='.') flag=1;
		}
	if(!flag){
		cout<<calc()<<endl;
		return 0;
	}
	//暴力找到最优位置
	for(int i=1;i<=r;++i)
		for(int j=1;j<=s;++j){
			int cnt=0;
			if(pos[i][j]=='.'){
				for(int k=1;k<=8;++k)
				if(i+dx[k]>0 && i+dx[k]<=r && j+dy[k]>0 && j+dy[k]<=s && pos[i+dx[k]][j+dy[k]]=='o') cnt++; 
				if(maxx<cnt){
					maxx=cnt;
					max_x=i;
					max_y=j;//更新最佳座位 
				}
			}
		}
	pos[max_x][max_y]='o';
	cout<<calc()<<endl;	
	return 0;
}
```

---

## 作者：CaoXian (赞：1)

## P7749 [COCI2013-2014#2] MISA 题解

思路：先求出 `Mirko` 没入座时人们的握手次数，再枚举 `Mirko` 入座的位置，若这个座位为空，那么计算 `Mirko` 在这个位置入座的握手次数，求出最大值。否则跳过。最后输出 `Mirko` 可以握手的最大次数加上 `Mirko` 没入座的所有人的握手次数。

对于刚开始 `Mirko` 没入座时所有人的握手次数，可以把每个人的的握手次数相加，最后除以 `2` 。因为握手时双向的，计算过程中，每一次握手都被计算了两次，所以最后要除以 `2` 。

还有两个小优化：
1. 若会场坐满了，可以直接输出，不用枚举 `Mirko` 入座的位置，因为他无处可坐了。
2. 如果枚举到某一时刻， `Mirko` 可以握手的人数为 `8` ，可直接输出答案，因为一个人最多与周围八个人握手。

Code：
```cpp
#include <stdio.h>
#define clac(r, c) (flag[r - 1][c - 1] + flag[r - 1][c] + flag[r - 1][c + 1] + flag[r][c - 1] + flag[r][c + 1] + flag[r + 1][c - 1] + flag[r + 1][c] + flag[r + 1][c + 1])//计算握手的人数 
#define max(a, b) ((a) > (b) ? (a) : (b))//手写max函数 
bool bol = true, flag[64][64];
int n, m, sum, ans;
char ch[64][64];
int main() {
	scanf("%d%d", &n, &m);
	getchar();
	for(int i = 1; i <= n; ++i) scanf("%s", ch[i] + 1);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			bol &= flag[i][j] = (ch[i][j] == 'o');//其实这里这样写是为了偷懒，可以写成flag[i][j] = (ch[i][j] == 'o'); if(!flag[i][j]) bol = false;
	//计算Mirko没入座时人们的握手情况
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			if(flag[i][j]) sum += clac(i, j);
	sum /= 2;
	if(bol) return 0 * printf("%d", sum);//第一种优化 
	//枚举Mirko的位置
   for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j) {
			if(!flag[i][j]) ans = max(ans, clac(i, j));//i行j列位置Mirko的握手次数
			if(ans == 8) return 0 * printf("%d", sum + ans);//第二种优化 
		}
	printf("%d", sum + ans);
	return 0;
}
```


---

## 作者：liswill (赞：1)

## 题意

有一个$R\times S$的矩阵，若其中`.`表示空位，`o`表示有人，在任意空位增加一个人
求最多相邻对数「斜相邻也算哦！」

## 思路

先把矩阵转换成 `01串` ，这时我们可以求出增加前的相邻对数。

然后在考虑如何使增加的人旁边有尽可能多的人，这样就可以使总的相邻对数最多。

我们可以把问题转化一下，如果想要求一个空点，旁边的的相邻人数最多，那么从已经有人的点出发，将与他相邻的空点都增加1，所有标记完后,

将标记的二维数组遍历一遍，最多的空点相邻人数就最多啦!

CPP Code
```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ll long long
#define RE return
using namespace std;
int n,m,cnt,s[105][105];
bool a[105][105];
inline void RD(int&res)//快读
{
    char c;res=0;
    while(c=getchar(),c<48);
    do res=(res<<1)+(res<<3)+(c^48);
    while(c=getchar(),c>47);
}
int main()
{
    char tmp;
    RD(n);
    RD(m);
    FOR(i,1,n)
    {
        FOR(j,1,m)
        {
            cin>>tmp;
            if(tmp=='o')    a[i][j]=1;
        }
    }
    FOR(i,1,n)//原本的「注意！A在B右边，B在A左边多算的一次最后答案要/2」
    {
        FOR(j,1,m)
        {
            if(a[i][j])
            {
                if(a[i+1][j])   cnt++;
                if(a[i-1][j])   cnt++;
                if(a[i][j+1])   cnt++;
                if(a[i][j-1])   cnt++;
                if(a[i-1][j-1]) cnt++;
                if(a[i-1][j+1]) cnt++;
                if(a[i+1][j-1]) cnt++;
                if(a[i+1][j+1]) cnt++;//这里没有用坐标数组，更容易理解（但前者当然效率更高）
            }
        }
    }
    FOR(i,1,n)
    {
        FOR(j,1,m)
        {
            if(a[i][j])
            {
                s[i+1][j]++;
                s[i-1][j]++;
                s[i][j+1]++;
                s[i][j-1]++;
                s[i-1][j-1]++;
                s[i-1][j+1]++;
                s[i+1][j-1]++;
                s[i+1][j+1]++;//将已在座的人的相邻空座加一
            }
        }
    }
    int maxn=0;
    FOR(i,1,n)
    {
        FOR(j,1,m)
        {
            if(!a[i][j]) maxn=max(maxn,s[i][j]);
        }
    }//遍历求最大的点
    cnt+=maxn*2;
    printf("%d\n",cnt/2);
    RE 0;
}
```


---

## 作者：AmaZingFantasy (赞：1)


题目大意：一个 $n \times m$ 的方格上做了几个人，每人可以和他相邻的 $8$ 个人握手。找到一个位置，在此位置上坐一个人，求最多能握手几次。特别地，如果方格内已经坐满了人，就不需要再坐一个人了。


拿到题目，首先不难想到此题目的思路是暴力枚举所有可以坐下的位置，找到可以握手人数最多的位置，再计算一共握几次手。如果座位已经坐满，直接计算即可。

于是我们可以将此题拆分为 $2$ 个步骤：

- 定义一个函数，用于计算握手次数。

- 暴力枚举找到最优位置。

注意：

对于函数，我们要注意，两人只能握一次手，所以要及时标记。

要特判是否坐满了人。

输入时是字符类型，不是整数。

代码：
```cpp
#include <iostream>
using namespace std;
typedef long long l;
l arr[55][55];
l n,m;
l woshou(){//定义函数。
    l cnt=0;
    for(l i=0;i<n;i++){
        for(l j=0;j<m;j++){
            if(arr[i][j]==1){
                arr[i][j]=2;//首先要标记该位置，避免重复握手。
                l d1[]={1,0,-1,0,1,1,-1,-1};
                l d2[]={0,1,0,-1,-1,1,-1,1};
                //方向数组，这可比8个if好使。
                for(l k=0;k<8;k++){
                    l row=i+d1[k];
                    l col=j+d2[k];
                    if(row >= 0 && col>=0 && row<n && col<m && arr[row][col]==1){//如果该位置可行，则cnt加一。
                        cnt++;
                    }
                }
            }
        }
    }
    return cnt;//返回在这个矩阵里所有人一共握了几次手。
}
int main(){
    cin>>n>>m;//输入n，m。
    for(l i=0;i<n;i++){
        for(l j=0;j<m;j++){
            char c;
            cin>>c;
            //注意，输入的是字符类型而不是整数。
            if(c=='o'){
                arr[i][j]=1;
            }else{
                arr[i][j]=0;
            }
        }
    }
    l maxrow=-1,maxcol=-1,maxws=0;
    //maxrow代表最优位置的行号，maxcol代表最优位置列号。
    //maxws代表在最优位置上能跟多少人握手。
    for(l i=0;i<n;i++){
        for(l j=0;j<m;j++){
            if(arr[i][j]==0){
                l d1[]={1,0,-1,0,1,1,-1,-1};
                l d2[]={0,1,0,-1,-1,1,-1,1};
                //依然是方向数组。
                l how_many=0;
                for(l k=0;k<8;k++){
                    l r=i+d1[k];
                    l c=j+d2[k];
                    if(r>=0 && c>=0 && r<n && c<m && arr[r][c]==1){//如果该位置能跟旁边人握手，则how_many加一。
                        how_many++;
                    }
                }
                if(how_many > maxws){//如果该位置可以握手的人数比原来多，则记录。
                    maxws=how_many;
                    maxrow=i;
                    maxcol=j;
                }
            }
        }
    }
    if(maxrow==-1 && maxcol==-1){//如果坐满了人，则直接计算有多少人握手。
        cout<<woshou();
    }else{//否则将arr的最优位置标记，并计算，输出结果。
        arr[maxrow][maxcol]=1;
        cout<<woshou();
    }
    return 0;
}
 
```


---


# [COCI 2013/2014 #2] SLOM

## 题目描述

Martin 眼睛出问题了。

对于一个单词，他每次眨眼，在他眼中这个单词的字母便会发生如下的变化（下述「倒数第 $k$ 个」「第 $k$ 个」等都是对于**变化前**的单词而言的）：

- 最后一个字母移动到第 $1,2$ 个字母之间。
- 倒数第二个字母移动到第 $2,3$ 个字母之间。
- $\ldots\ \ldots$
- 倒数第 $k$ 个字母移动到第 $k,k+1$ 个字母之间。

例如，单词 $\tt abcdef$ 在他眨眼后会变成 $\tt afbecd$。

如果 Martin 再次眨眼后，相同的事情仍会发生。

给定 Martin 眨眼的次数 $X$ 和他看到的单词 $s$，求出原本的单词。

## 说明/提示

#### 样例 1 说明

变化过程为：$\tt abcdef\to afbecd\to adfcbe\to aedbfc\to acefdb$。

#### 数据规模与约定

- 对于 $50\%$ 的数据，有 $1\le X\le 100$。
- 对于 $100\%$ 的数据，有 $1\le X\le 10^9$，$3\le |s|\le 10^3$。

#### 来源

**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T3 SLOM_。**

按照原题数据配置，本题满分 $100$ 分。

## 样例 #1

### 输入

```
4 
acefdb```

### 输出

```
abcdef```

## 样例 #2

### 输入

```
1000 
aaaaaa```

### 输出

```
aaaaaa```

## 样例 #3

### 输入

```
11 
srama```

### 输出

```
sarma```

# 题解

## 作者：fz20181223 (赞：5)

我们对 $6$ 个字符进行变化，我们不难发现变换是这样的（此处显示的是一开始是第几个字符）：

一开始：$1,2,3,4,5,6$

第一次：$1,6,2,5,3,4$

第二次：$1,4,6,2,3,5$

第三次：$1,5,4,2,6,3$

第四次：$1,3,5,6,4,2$

第五次：$1,2,3,4,5,6$

这启示我们，变换序列是存在循环的！

经过多次尝试，我们发现，字符串长度为 $4$，循环次数为 $3$，但是如果字符串长度为 $8$，循环次数为 $4$，而当字符串长度为 $11$，循环次数为 $6$……得出结论：字符串长度与单词循环次数没有直接关系。

此时我们可以考虑通过代码暴力算出对于长度为 $n$ 的单词单次循环次数。写一个暴力的变换以及对应的检查就行了。思路就是先压一个序列，让它不停地变换直到回到原来压的的序列的样子（比如我压的就是 $1$ 到 $n$）。

此时我们有了单次循环次数，我们可以大大地减少操作的次数。而对于后续的操作，我们可以推出它从最后一次循环结束后它又做了多少次变换 $r$，即 $r \gets X\bmod \operatorname{solve}(|s|)$（其中 $X$ 和 $s$ 均为[原题目](/problem/P7750)中的变量，$\operatorname{solve}$ 函数为求循环次数的函数，下同）。

根据循环的特征，在一个单次循环消耗 $rd$ 次的循环中，如果我们做了 $x$ $(x<rd)$ 次，要想还原，我们可以倒推 $x$ 次，也可以再做 $rd-x$ 次，所以，我们只需让现有的字符串再变换 $\operatorname{solve}(|s|)-r$ 次就行了。

另附：AC 代码（不要抄！）。
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;int x,rd,rin;
vector<int>a;
bool check(int t){
	if(t==0) return 0;
	for(int i=0;i<a.size();++i){
		if(a[i]!=i+1) return 0;
	}
	return 1;
}
int solve(int n){
	a.clear();
	int i;
	for(i=1;i<=n;++i) a.push_back(i);
	for(i=0;;++i){
//		printf("%dth change:",i);
//		for(int j=0;j<n;++j) printf("%d ",a[j]);
//		puts("");
		if(check(i)) break;
		for(int j=0;j<a.size()>>1;++j){ 
			int tmp=a.back();
			a.pop_back();
			a.insert(a.begin()+(j<<1|1),tmp);
		}
	} 
//	printf("change time:%d",i);
	return i;
}
int main(){
	scanf("%d",&x);
	cin>>st;
	rd=solve(st.size());
	rin=x%rd;
	for(int i=0;i<rd-rin;++i){
		for(int j=0;j<st.size()>>1;++j){ 
			string tmp="";
			tmp+=(char)st[st.size()-1];
			st.erase(st.size()-1,1);
			st.insert(j<<1|1,tmp);
		}
	}
	cout<<st;
	return 0;}
```

---

## 作者：__zfy__ (赞：0)

### 前置芝士
[如何将字符插入字符串](https://blog.csdn.net/qwe954443563/article/details/110749684)。
### 分析
首先枚举一下操作多次后的字符串：

原始字符串：`123456`。
1. 眨眼 $1$ 次：`162534`。
2. 眨眼 $2$ 次：`146235`。
3. 眨眼 $3$ 次：`154263`。
4. 眨眼 $4$ 次：`135642`。
5. 眨眼 $5$ 次：`123456`。

如果仔细观察上面的变化，你会发现原始的字符串和第五次眨眼是一样的，所以我们可以判断出字符串变化是循环的。

### 思路
考虑插入操作，我们可以用 C++ 中的 STL 里的神器：`vector`。

它可以随着元素的多少而改变大小，下面简单介绍几个常用操作：
- 定义：`vector<类型>标识符`；
- 使用：[C++ vector用法](https://blog.csdn.net/LUSH_BOY/article/details/113486316)。

了解了 `vector` 我们可以开始着手写代码了。

--------
首先，我们要找到字符串 $s$ 的循环次数，可以通过暴力来解决。

最后，获取了循环次数后，可以减少操作的次数，只要记录循环中每一次操作后的序列，直接输出 $n \bmod k$ 号的序列就解决了这道题。
### AC Code
代码来自[这位大佬](https://www.luogu.com.cn/user/482102)。
```cpp
#include<iostream>
#include<string>
using namespace std;
const int N=1e3+5;
int n,l,p;
string a,ji[2*N];
char t[N];
int main(){
	cin>>n>>a;
	l=a.length();
	for(int i=1;i<=n;i++  )
	{
		 for(int j=0;j<l;j++)
		 {
		 	if(j%2==0) t[j/2]=a[j];
		 	else t[l-j/2-1]=a[j];
		 }
		 for(int j=0;j<l;j++)
		 {
		 	a[j]=t[j];
		 }
		 if(ji[1]==a) break;
		 ji[++p]=a;
	}
	if(n%p==0) cout<<ji[p];
	else cout<<ji[n%p];
	return 0;
}
```


---

## 作者：史蒂夫的憨憨 (赞：0)

题目大意：一个长度为 $l$ 的字符串，对于一个的每个元素 $s_i$ ，当 $i$ 为偶数时，将 $s_i$ 挪到下标 $i/2$ 的位置；当 $i$ 为奇数时，将 $s_i$ 挪到下标为 $l-(i/2)-1$ 的位置，并将此操作进行 $X$ 次。

样例 1 变化过程为 ：$\tt acefbd\to aedbfc\to adfcbe\to afbecd\to abcdef\to acefdb $。

我们发现 $s$ 的变换过程是循环的，所以我们可以求出循环长度，并同时记录下每一步，最后输出即可，代码如下：

```cpp
#include<iostream>
#include<string>
using namespace std;
const int N=1e3+5;
int n,l,p;
string a,ji[2*N];
char t[N];
int main(){
	cin>>n>>a;
	l=a.length();
	for(int i=1;i<=n;i++  )
	{
		 for(int j=0;j<l;j++)
		 {
		 	if(j%2==0) t[j/2]=a[j];
		 	else t[l-j/2-1]=a[j];
		 }
		 for(int j=0;j<l;j++)
		 {
		 	a[j]=t[j];
		 }
		 if(ji[1]==a) break;
		 ji[++p]=a;
	}
	if(n%p==0) cout<<ji[p];
	else cout<<ji[n%p];
	return 0;
}
```






---

## 作者：szh_AK_all (赞：0)

[没看题的人可以先走这里](https://www.luogu.com.cn/problem/P7750)

这道题由于 $X$ 很大，所以我们需要得出字符串操作几次可以得到原来的字符串（即操作周期）。我们分两种情况：一、当字符串的长度为偶数时，我们将后一半的每个字符一次插入前一半中（注意，大家可能不知道题目中 $k$ 的大小，$k$ 的大小是字符串长度减 $1$，实际上是字符串长度除以 $2$），下面给出一个例子：当字符串为 `abcdef` 时，变化过程如下：
1. `abcdef`；
2. `afbcde`；
3. `afbecd`；
4. `afbecd`。

我们会发现，实际需要移动的字符串为后一半（将倒数第 $k$ 个字符插入正数第  $k$ 个字符后面）；

二、当字符串的长度为奇数时，先按照一的操作过程（变化后一半，注意，后一半比前一半少），再将最中间一个字符移动 $0$ 位（即不变），如，当字符串为 `abcde` 时：
1. `abcde`；
2. `aebcd`；
3. `aebdc`；
4. `aebdc`。

# Code
```c
#include<iostream>
#include<string>
using namespace std;
int main()
{
    long long x;
    string s;
    cin>>x>>s;
    string s1=s;
    int tmp=0;
    while(1)//记录操作周期
    {
        tmp++;
		string s2="";
        for(int i=1;i<=s1.size()/2;i++)//变化
		{
		s2+=s1[i-1];
		s2+=s1[s1.size()-i];
		}
		if(s1.size()%2==1)
			s2+=s1[s1.size()/2];
		s1=s2;
		if(s2==s)
			break;
    }
    x=x%tmp;
    s1=s;
    for(int i=1;i<=x;i++)
    {
		string s2="";
        for(int j=1;j<=s1.size();j+=2)//反变化
			s2+=s1[j-1];
		int y=s1.size();
		if(y%2==1)
			y--;
		for(int j=y;j>=2;j-=2)
			s2+=s1[j-1];
		s1=s2;
		
    }
    cout<<s1;
    return 0;
}
```
代码中有变化和反变化两个过程，变化过程已讲。反变化过程即为倒推过程，举个例子，当字符串为 `afb` 时，过程如下（将偶数位字符从后往前递到最后）：
1. `abf`；
2. `abf`。

其实我们会发现，当字符串长度为奇数时也是一样的，也是将偶数位的字符从后往前一直后方，其他不变。最后，打字不易，给个赞吧！


---

## 作者：Together_ (赞：0)

[博客使用效果更佳](https://www.cnblogs.com/yangzichen/p/16897362.html)

首先我们观察本题的几个样例。

我们拿第三个样例为例来模拟一下这个过程。

开始时：`srama`

第一次：`sarma`

第二次：`saamr`

第三次：`srama`

这是我们发现经过三次变化就变成了开始时的样子，所以我们可以得出结论：**变换序列是存在循环的！**

经过多次尝试，我们发现，字符串长度为 $5$，循环次数为 $3$，但是如果字符串长度为 $6$，循环次数为 $4$，而当字符串长度为 $8$，循环次数为 $4$……

于是我们得出结论：**字符串长度与单词循环次数没有直接关系！**

此时我们可以考虑通过代码**暴力算出对于长度为 $n$ 的单词单次循环次数**。

这样我们就可以得到一个长度为 $n$ 的单词单词循环次数 $x$，那么我们就可以用 $X$（题目中的眨眼次数）对 $x$ 取模，其值为 $dx$，则我们只需要模拟 $dx$ 次即可（即循环 $dx$ 次）。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

string st;
int x, x1, dx;
vector<int> v;

bool check(int t) {
	if (t == 0) return 0;
	for (int i = 0; i < v.size(); ++i) {
		if (v[i] != i + 1) return 0;
	}
	return 1;
}

int solve(int n) {
	v.clear();
	int i;
	for (i = 1; i <= n; i++) v.push_back(i);
	for (i = 0;; i++) {
		if (check(i)) break;
		for (int j = 0; j<v.size() >> 1; ++j) {
			int tmp = v.back();
			v.pop_back();
			v.insert(v.begin() + (j << 1 | 1), tmp);
		}
	}
	return i;
}

int main() {
	scanf("%d", &x);
	cin >> st;
	x1 = solve(st.size());
	dx = x % x1;
	for (int i = 0; i < x1 - dx; ++i) {
		for (int j = 0; j<st.size() >> 1; ++j) {
			string tmp = "";
			tmp += (char)st[st.size() - 1];
			st.erase(st.size() - 1, 1);
			st.insert(j << 1 | 1, tmp);
		}
	}
	cout << st;
	return 0;
}

```

---


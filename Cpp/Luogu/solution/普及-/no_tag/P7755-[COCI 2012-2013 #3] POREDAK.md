# [COCI 2012/2013 #3] POREDAK

## 题目背景

Mirko-wan 刚刚收到历史考试的成绩。其中一个问题是把著名的历史事件按时间顺序排列。正确的顺序是：

1. _Blockade of Naboo_
2. _Battle of Geonosis_
3. _Battle of Yavin_
4. _Battle of Hoth_
5. _Battle of Endor_

Mirko-wan 相对地用功备考，所以除了 _Blockade of Naboo_ 外，他记得所有事件的确切年份。他对于 _Blockade of Naboo_ 什么都不记得了，所以他随机把它放在最后而不是第一个，得到的顺序是：

1. _Battle of Geonosis_
2. _Battle of Yavin_
3. _Battle of Hoth_
4. _Battle of Endor_
5. _Blockade of Naboo_

由于 Mirko-wan 的顺序在任何指标上都不符合正确的解决方案，尽管他知道五分之四的正确顺序，但令他失望的是，他在这个问题上的得分是 $5$ 分中的 $0$ 分！这就引出了公平评分问题。

## 题目描述

上面给出的例子表明，通过计算正确绝对位置的项目数来得分是不公平的。有更好的方法吗？一种可能是找到正确排序的项目的最长子序列（不一定是连续的）。这也不是最好的解决方案：如果一个项目从正确的顺序中只被替换了一个位置，那么尽管排序几乎正确，它的分数就会降到零。Mirko-wan 因此向他的历史老师建议以下评分方法：

对于 $n$ 个条目中的每两个条目，如果两个条目的顺序相互正确，学生将得到 $1$ 分。换句话说，分数是学生正确排列的条目对的数目。当然，最大分数是条目对的总数，等于 $\dfrac{n(n-1)}{2}$。

请你通过这种方法，给定 $n$ 个条目的正确顺序和 Mirko-wan 给出的顺序，求出 Mirko-wan 可以得到的分数。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，能够使 Mirko-wan 得到分数的条目对为 $(\texttt{alpha},\texttt{beta})$ 和 $(\texttt{alpha},\texttt{gamma})$。

**【数据范围】**

对于所有数据，$2\leqslant n\leqslant 2500$。字符串的长度在 $[3,15]$ 之间，仅包含小写英文字母且所有条目是互不相同的。

**【题目来源】**

本题来源自 **_[COCI 2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST 3](https://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf) T2 POREDAK_**，按照原题数据配置，满分 $80$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3
alpha beta gamma
alpha gamma beta```

### 输出

```
2/3```

## 样例 #2

### 输入

```
5
naboo geonosis yavin hoth endor
geonosis yavin hoth endor naboo```

### 输出

```
6/10```

# 题解

## 作者：liuxy1234 (赞：4)

# 思路
看到这题面，我们就会想起顺序对。

但是用什么来呢？
归并？

当我们看到数据范围 $n \le 2500$ 时，就不用担心了。
### 暴力！！！

上代码。

```cpp
#include <bits/stdc++.h>
#define int  long long
using namespace std;

map <string, int>a;//map真不错。
string s;
int b[10000];
int cnt;
signed main(){
	std::ios::sync_with_stdio(0);
	int n;
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> s;
		a[s] = i;
	}
	for(int i = 1;i <= n;i++)
	{
		cin >> s;
		b[i] = a[s];
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = i + 1;j <= n;j++)
		{
			if(b[i] < b[j])cnt++;
		}
	}
	cout << cnt << '/' << (n * n - n) / 2;
	return 0;
}

```


---

## 作者：_Fatalis_ (赞：1)

~~其实这道题渟水的~~

# Solution


### 题意简化：

在一堆字符串中间，找到一些两两相对位置正确的字符串的个数。

其实，我们可以给这些字符串**标号**。

就比如说，按样例 1，

```
3

> 1    2     3
alpha beta gamma

> 1     3    2
alpha gamma beta

```

对正确序列标号为 $1,2,3$。

就可以将给出的序列变成 $1,3,2$。

于是就只用寻找正确的编号大小关系即可。

可以在上面序列中找到两组：

$(1,3)$ 和 $(1,2)$。于是答案就是 $2/3$。

最后变成了找~~逆序对~~正序对的问题。

### 实现：

$\texttt{map}$ 编号，再用 $\texttt{for}$ 枚举就可以啦~

~~虽然可以用归并排序解逆序对~~，但时间复杂度不需要。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> mp;
int od[2501];

int main()
{
	int n,ans=0;string str;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>str,mp[str]=i;
	for(int i=1;i<=n;i++) cin>>str,od[i]=mp[str];
	for(int i=1;i<n;i++)
		for(int j=i+1;j<=n;j++)
			if(od[i]<od[j]) ans++;
	printf("%d/%d",ans,n*(n-1)/2);
	return 0;
}
```

qaq

---

## 作者：Dream_weavers (赞：1)

## 题意

有两个序列的字符串。把第二序列的每个字符串位置当作**正确的位置**，问在第一序列中有**几对**字符串的位置是**正确的**。

## 思路

这道题是字符串版的求正序对个数。

### 分子：

先用 map 记录第一序列中每个字符串所在的位置，再用一个数组存第二序列中每一个字符串在第一序列中所对应的位置。（有点绕）最后求出数组中正序对的个数。

看一下 $n$ 的范围，最大是 $2500$，看来直接用暴力就行了（其实归并也可以），不会炸，时间复杂度 $O(n^2)$。

### 分母：

就是题中说的：$\dfrac{n(n-1)}{2}$

## $\ AC\ Code$

```cpp
#include<iostream>
#include<cstdio>
#include<map> 
using namespace std;
int n,cnt,a[100005];
string s;
map <string,int> m;//定义map
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        cin>>s;//输入字符串
        m[s]=i;//用map记录位置
    }
    for(int i=1;i<=n;i++){
        cin>>s;
        a[i]=m[s];//用数组记录在第一序列所对应的位置
    }
    for(int i=1;i<n;i++)//求正序对个数
        for(int j=i+1;j<=n;j++)
            if(a[i]<a[j])
                cnt++;
    printf("%d/%d",cnt,n*(n-1)/2);//输出分子和分母
    return 0;
}

```


---

## 作者：I_am_rubbish (赞：0)

## P7755 [COCI2012-2013#3] POREDAK
### 万事先读题
题目意思大概是如果第一个序列的字符串出现的比第二个序列的字符串时间晚或一样早（i的值小或等于）就把答案总数  $+1$
### 简单来说
就是求字符串序列出现顺序的顺序对。那用什么求呢？树状数组？线段树？归并？（~~瞎扯中。。。~~）
可 n 才到 $2500$ 啊, $n^2$ 暴力枚举毫无压力。 
### 最后
直接上代码
```c
#include <bits/stdc++.h>
#define int long long
using namespace std;
unordered_map<string, int> m;//map yyds(不会手写字符串哈希)
string s;
int n, ans, cxsx[10001];//cxsx:出现顺序
signed main()
{
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)
	{
		cin >> s;
		m[s] = i;
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> s;
		cxsx[i] = m[s];
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = i + 1; j <= n; j++)//顺序对所以从i+1开始枚举
		{
			if (cxsx[i] < cxsx[j])
				ans++;
		}
	}
	printf("%lld/%lld", ans, n * (n - 1) / 2);
	return 0;//完结撒花
}

```


---

## 作者：Marginal_world (赞：0)

给定互不相等的字符串，再给定这些字符串的另一种排列顺序，求出第二种排列顺序中，字符串的相对位置和第一种排列方式相等的个数。

相对位置相等：[逆序对](https://baike.so.com/doc/7642506-7916601.html)。

只要在两种排列顺序中，有两个字符串的相对位置不变，答案就加一。

这里有两种选择：一种归并排序找逆序对，然后直接计算答案，另一种则是暴力枚举。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define r register
string zyqq[2505];//一开始的排列顺序
map<string,int> b;
int main(){
    int n;
    cin >> n;
    for (register int i=1;i<=n;i++){
    	cin >> zyqq[i];
    }
    for (register int i=1;i<=n;i++){
    	string zyq;
    	cin >> zyq;
    	b[zyq]=i;//把字符串的位置记录下来
    }
    int ans=n*(n-1)/2,zyq=0;//题目中已经给出的答案
    for (register int i=1;i<=n;i++){
    	for (register int j=i+1;j<=n;j++){
    		if (b[zyqq[i]]<b[zyqq[j]]) zyq++;//第一种顺序中，两个字符串的相对位置已经确定，只需在比较第二种顺序中，这两个字符串的相对位置即可。
    	}
    }
    cout << zyq << '/' << ans;
    return 0;
}
```

希望能帮助到大家。

---

## 作者：fz20181223 (赞：0)

upd on 2021/08/04: 修复了不太符合题解规范的地方，并修复了部分描述疑似不太清楚的地方。

下面是正文：

按照题目中说的 `a/b` ,不难发现 $b$ 很好求，就是 $\dfrac{n(n-1)}{2}$ 。

对于 $a$ ，我们有一种暴力解法就是对于每两个 Mirko-wan 的答案看他们在正解中的相对位置比较。

如果带着两个答案回到原答案序列一个个找，复杂度会上升至 $O(n^4)$ ，对于 $n=2500$ 级的数据肯定过不了

此时我们可以想到在读取正解时将每个字符串的相对位置（通俗地讲，就是这是第几个答案）保存下来，然后在读入 Mirko-wan 的答案时，每读入第 $i$ 个答案，则枚举位于第 $i$ 个答案之前的所有第 $j$ 个答案（即在满足 $1\le j < i$ 的情况下进行枚举），获取每两个答案的相对位置（用 STL map 复杂度 $O(\log n)$ ），如果答案 $i$ 所在正解的位置位于答案 $j$ 的后面 （即 $i$ 的相对位置大于 $j$ ），因为枚举时保证了 $i>j$ 则说明对于这两个答案， Mirko-van 是对的，此时将左边的答案加一。复杂度 $O(n^2\cdot \log n)$，不开 O2 也能过

附：AC代码（不要抄！）
```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define pii pair<int,int>
#define mii map<int,int>
#define mset(a,x) memset(a,x,sizeof(a))
#define msetl(a) memset(a,0x3f,sizeof(a))
using namespace std;
const int err=-120712^7869^12174,eps=1e-9,N=2712;
int n,ansl,ansr,det[N];string pans,jans;
map<string,int>h;
int main(){
	scanf("%d",&n);
	ansr=(n*n-n)>>1,ansl=0;
	for(int i=0;i<n;++i){
		cin>>jans;
		h[jans]=i;
	}
	for(int i=0;i<n;++i){
		cin>>pans;
		det[i]=h[pans];
		for(int j=0;j<i;++j){
			ansl+=det[i]>det[j]; 
		}
	}
	printf("%d/%d",ansl,ansr);
	return 0;}
```

---

## 作者：asasas (赞：0)

题意：先给定 $ n $ 个互不相等的字符串，再给定这 $ n $ 个字符串的另一种排列顺序，求出第二种排列顺序中，字符串的相对位置和第一种排列方式相等的个数。

什么叫相对位置相等？我们拿样例来做一下示范：

 $ \text {alpha} $ $ \text {beta} $  $ \text {gamma} $

 $ \text {alpha} $ $ \text {gamma} $ $ \text {beta} $

答案是 $ 2 $。 因为在第一种排列顺序中，$ \text {alpha} $  的位置在 $ \text {beta} $ 前，第二种排列顺序中，$ \text {alpha} $ 的位置仍在 $ \text {beta} $ 前，
所以答案要加1。这就是相对位置，也就是**逆序对**。

同理， $ \text {alpha} $ 和 $ \text {gamma} $也是如此，所以答案就是 $ 2 $。

所以，**只要在两种排列顺序中，有两个字符串的相对位置不变，答案就加1**。

这里有两种选择：一种归并排序找逆序对，然后直接计算答案，另一种则是暴力枚举。由于 $ n \leq 2 5 0 0 $ ，直接暴力即可。

注意：这里首先要把第二种排列顺序中的字符串所在位置记录下来，建议用 $ \text {map} $ 。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define r register
string zyqq[2505];//一开始的排列顺序
map<string,int> b;
int main(){
    int n;
    cin >> n;
    for (register int i=1;i<=n;i++){
    	cin >> zyqq[i];
    }
    for (register int i=1;i<=n;i++){
    	string zyq;
    	cin >> zyq;
    	b[zyq]=i;//把字符串的位置记录下来
    }
    int ans=n*(n-1)/2,zyq=0;//ans是题目中已经给出的b的答案
    for (register int i=1;i<=n;i++){
    	for (register int j=i+1;j<=n;j++){
    		if (b[zyqq[i]]<b[zyqq[j]]) zyq++;//因为j>i,所以第一种顺序中，两个字符串的相对位置已经确定，只需在比较第二种顺序中，这两个字符串的相对位置即可。
    	}
    }
    cout << zyq << '/' << ans;
    return 0;
}
```


---

## 作者：3a51_ (赞：0)

### 题目大意

给你两个字符串数组 $a,b$，求有多少对字符串 $s_1,s_2$ 使得在 $a$ 中出现的顺序与在 $b$ 中一样。

### 思路分析

考虑```map```。可以记录一下出现的位置，然后暴力枚举。因为```map```访问是 $O(\log)$ 的，总时间复杂度是 $O(n^2 \log n)$，会 $\texttt{TLE}$。所以我们可以将出现顺序存到一个数组里，用数组下标访问，这样时间复杂度就被压缩到 $O(n^2)$ 了，可以通过本题。

### code

```cpp
#include<iostream>
#include<map>//定义map必须的头文件
#include<cstdio>
using namespace std;
int n,ans,a[2505];
string s;
map<string,int> m;//map
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		m[s]=i;//第一次存储
	}
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		a[i]=m[s];//第二次出现的顺序
	}
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)//j从i+1开始，保证i<j
			if(a[i]<a[j])//如果第一次下标i<j，并且第二次存的数组也是小于关系
				ans++;//答案++
	cout<<ans<<"/"<<n*(n-1)/2;//不用约分
	return 0;
}
```

---

## 作者：Invulnerable (赞：0)

~~蒟蒻来水题解啦~~

## 注意：本篇题解适合新手阅读，比较巨的OIer们请自行转到代码实现篇

这道题是个新手的练习题，~~标签竟然不是入门~~。

## 题意

给原来与现在长度为 $n$ 字符串的序列（$ 2 \le n \le 2500 $）

求有几对字符串相对位置与原来相对位置相同。

## 前置芝士map

map 是一个非常有用的数据结构，并且它是STL封装好的，这种数据结构就相当于一种数组，但它有键 key 以及对应的值 value 键值是一一对应的。如果你想要使用 map 需要以下这个头文件（万能头也行）。

```
#include<map>

```

定义一个 map 的方法为：

```cpp
map< , >mp;//逗号前是键的数据类型，逗号后的则是值的数据类型
map<string,int>mp2//示例：32位整形变量经过映射变为字符串类型变量
```

每一个 key 就对应了一个 value。

map 支持赋值，加减乘除操作，例如:

```cpp
mp['shili']=2;
mp['shili']++;
```

map 的常见操作（此处列举比较有用的三个）:

```cpp
mp.clear();//清空
bool a=mp.count('shili');//键值出现次数（1或0）
bool b=mp.empty();//是否为空
```

map 的优点：能够像数组一样赋值，但键可以为任何类型.

## 回归正题：如何解决

1.答案要求用 $a/b$ 的格式，其中 $a$ 为要求的相对位置正确的对数， $b$ 为总对数。题目中已经给出了 $b$ 的求法:

$$b=\frac{n \times(n+1)}{2}$$

2.接着，我们可以计算 $a$ 了.首先，我们可以使用map记录每个字符串对应的序号。我们可以暂定为 $1$ 到 $n$，即：

```cpp
mp[s[i]]=i;
```

然后我们可以在现在的序列中通过 map 来获得一个数列r

| 1 | 2 | 3 | 4 | $\ldots$ | n |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $r_1$ | $r_2$ | $r_3$ | $r_4$ | $\ldots$ | $r_n$ |

然后枚举 $i$ 和 $j$ ，如果 $i<j$ 且 $r_i<r_j$ ，那么加一分

复杂度为 $\operatorname{O}(n^2)$

## 代码部分

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n;
string ans[2505],rep[2505];
int r[2505],cnt=0;
map<string,int>m2;//反抄袭
int main(){
	cin>>n;
	int ttt=n*(n-1)/2;
	for(int i=1;i<=n;i++){
		cin>>ans[i];
		m1[ans[i]]=i;//自定义序号
	}
	for(int i=1;i<=n;i++){
		cin>>rep[i];
		r[i]=m1[rep[i]];
	}
	for(int i=1;i<n;i++)//核心
		for(int j=i+1;j<=n;j++)
			if(r[i]<r[j])
				cnt++;
	printf("%d/%d",cnt,ttt);
	return 0;//完美收官
}
```

## 最后

千万不要抄代码！！！

码字不易，希望管理员大大能高抬贵手。

---


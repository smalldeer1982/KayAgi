# [COCI 2012/2013 #3] MALCOLM

## 题目背景

自从 Herkabe 老师开始对他的学生进行排名以来，他班上的朋友对数急剧下降。排名靠后的学生已经开始嫉妒排名靠前的学生，而排名靠前的学生则开始看不起那些排名靠后的学生。

## 题目描述

根据 Malcolm 的观察，班上一共有 $n$ 名学生。如果两个学生的排名**最多相差 $k$**，那么他们就是**朋友**。如果有两个学生是**朋友**并且它们的名字长度相等，那么他们就是**好朋友**。

现在给定这个班上 $n$ 名学生的名字及排名，求这个班上一共有多少对**好朋友**。

## 说明/提示

**【数据范围】**

对于所有数据，$3\leqslant n\leqslant 3\times 10^5$，$1\leqslant k\leqslant n$，字符串的长度在 $[2,20]$ 之间且仅包含大写英文字母。

**【题目来源】**

本题来源自 **_[COCI 2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST 3](https://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf) T3 MALCOLM_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 2
IVA
IVO
ANA
TOM```

### 输出

```
5```

## 样例 #2

### 输入

```
6 3
CYNTHIA
LLOYD
STEVIE
KEVIN
MALCOLM
DABNEY```

### 输出

```
2```

# 题解

## 作者：panjidongc (赞：5)

- 只有英文名长度相同的才能成为好朋友，所以名字是由哪些字母组成的并不重要，我们只需记录下名字长度即可。

- 我们观察到数据中英文名的长度很小，于是我们可以对每一种长度的名字数量做前缀和，之后扫描一遍，统计排名在 $k$ 名之内的学生组数即可，时间复杂度 $O(n)$。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const int N=300005;
typedef long long ll;

char s[25];
int a[N],b[25][N]; //a[]是每个人的名字长度，b[i][]是名字长度为i的名字数量前缀和
int n,k;
ll ans;

int main()
{
	int i,j;
	scanf("%d%d",&n,&k);
	for(i=1;i<=n;i++)
	{
		scanf("%s",s);
		a[i]=strlen(s);
	}
	for(i=2;i<=20;i++)
		for(j=1;j<=n;j++)
		{
			b[i][j]=b[i][j-1];
			if(a[j]==i)
				b[i][j]++;
		} //求前缀和
	for(i=1;i<=n;i++) //第i名最远只能和第i+k名做好朋友
	{
		if(i+k<n)
			ans+=(ll)b[a[i]][i+k]-b[a[i]][i];
		else //注意排名靠后的几个人最远只能和最后一名做好朋友
			ans+=(ll)b[a[i]][n]-b[a[i]][i];
	}
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：wangbinfeng (赞：2)

首先，感谢大家阅读！

------------
# 思路：
>对于所有数据， $3\leqslant n\leqslant 3\times10^5$ ， $1 \leqslant k\leqslant n$ ，字符串的长度在 $[2,20]$ 之间且仅包含大写英文字母。
（上文数据范围非常重要，建议提前仔细阅读）

1. 暴力算法应该很容易想到吧！就不多说了，上代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,k,namelen[300009],ans;//namelen[i]为第i个同学的名字长度
char name[30];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>name;
        namelen[i]=strlen(name);
    }
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=i+k;j++)//记得+1
            if(namelen[i]==namelen[j])ans++;
    cout<<ans;
}
```

可以看到，在
```cpp
for(int i=1;i<=n;i++)
    for(int j=i+1;j<=i+k;j++)//记得+1
        if(namelen[i]==namelen[j])ans++;
```
中，时间复杂度为 $O(N^2)$ 。
因此，我们要尝试减小他的复杂度。

2. ```sort```优化：
> $3\leqslant n\leqslant 3\times10^5$ 

从数据范围上来看，代码的时间复杂度最大应为 $O(n \log n)$ 才能通过这题。而在 $O(n \log n)$ 的所有算法中，只有 ```sort``` 最合适。

而```sort```后结果也是对的，为什么呢？因为如果我们按照长度排序，排序后的内容会按长度递增。这样，我们就可以暴力了。具体见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
class namelen{
    public:
        int id,len;
}len[300009];
bool cmp(namelen a,namelen b){
    if(a.len==b.len)return a.id<b.id;
    return a.len<b.len;
}
int n,k,namelen[300009],ans;//namelen[i]为第i个同学的名字长度
char name[30];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>name;
        len[i].len=strlen(name);
        len[i].id=i;
    }
    sort(len+1,len+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=i+1;len[j].len==len[i].len&&len[j].id-len[i].id<=k;j++)//注意是小于等于
            ans++;
    cout<<ans;
}
```
但是，还有一个大问题：
```cpp
for(int i=1;i<=n;i++)
    for(int j=i+1;len[j].len==len[i].len&&len[j].id-len[i].id<=k;j++)//注意是小于等于
        ans++;
```
这里的循环，**最坏**时间复杂度还是 $O(n^2)$ 。

3. **【正解】类桶排优化：**
>字符串的长度在 $[2,20]$ 之间且仅包含大写英文字母。

字符串长度还挺小，所以可以用类似**桶排**的思路省去```sort```所用时间。具体见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,len[300009],vis[29],n,k;//vis数组即“桶”，存放着每个长度的字符串数量
char s[30];
int main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		len[i]=strlen(s);
	}
	for(int i=1;i<=k;i++)ans+=vis[len[i]]++;//前k个人不需要考虑前面
	for(int i=k+1;i<=n;i++){
		ans+=vis[len[i]]++;
		vis[len[i-k]]--;//但后面的人的结果可能会影响前面的人的结果
	}
	printf("%lld",ans);
}
```
时间复杂度 $O(n)$ 。

# 代码：
如上。


------------
最后，也感谢[@初一吴彦儒](https://www.luogu.com.cn/user/400201)提供正解思路。

------------
虽然在前文先讲了两种TLE的解法，但这题是一个循序渐进的过程。

感谢大家阅读。

---

## 作者：luckydrawbox (赞：2)

因为只有名字长度相等的同学才能成为好朋友，所以我们就把名字长度相同的同学的排名放入同一个数组内。

```cpp
vector<int>e[30];
string s;
for(int i=1;i<=n;i++)
{
	cin>>s;
	e[s.size()].push_back(i);
}
```

接下来对于每个长度的名字，我们分开计算，每次用双指针 $i,j$ 实现。

#### 举个例子

假设名字长度为 $2$ 的同学的排名为 $1\ 3\ 4\ 5$，数组长度 $l_2=4$，题目中的 $k=2$。

先令 $i=j=0$。

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
| $i,j$ |  |  |  |

接下来令 $j$ 不断增加，直到 $j==l_2-1$ 或 $e_{2,i}+k<e_{2,j+1}$，也就是求出当前这个同学的交际圈至多能低到第几名。

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
| $i$ | ${}^\curvearrowright j$ |  |  |

此时第 $i$ 个同学就能找到 $j-i$ 名排名比自己低的好朋友，于是我们让 $ans+=j-i$。

接下来再进行几轮这样的操作，每次完成后令 $i++$，寻找第 $i$ 个同学能找到的排名最低的好朋友，直到 $i==l_2-2$。

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
|  | ${}^\curvearrowright i,j$ |  |  |

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
|  | $i$ | ${}^\curvearrowright j$ |  |

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
|  | $i$ |  | ${}^\curvearrowright j$ |

| $e_{2,0}$ | $e_{2,1}$ | $e_{2,2}$ | $e_{2,3}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $4$ | $5$ |
|  |  | ${}^\curvearrowright i$ | $j$ |

把每次的 $j-i$ 累加就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
vector<int>e[30];
string s;
ll ans;
int main()
{
    cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		e[s.size()].push_back(i);
	}
	for(int l=2;l<=20;l++)
		if(e[l].size()>1)
		{
			int i=0,j=0;
			while(i<e[l].size()-1)
			{
				while(j+1<e[l].size()&&e[l][i]+k>=e[l][j+1])
					j++;
				ans+=j-i;
				i++;
			}
		}
	cout<<ans<<endl;
	return 0;
}
```

复杂度为 $O(\sum_{i=2}^{20}l_i)=O(n)$。

---

## 作者：Galex (赞：1)

提供一种新的思路，但是跑的比较慢，请谨慎参考。

首先看到字符串的长度只有 $20$，所以可以开一个 vector 来存每个长度的所有排名。然后对每个 vector 内部排序，再利用类似双指针的方法求每个学生的好朋友，累加答案即可。复杂度约为 $O(n \times \log n)$，比其他题解的 $O(n)$ 做法要慢许多，但过掉此题还是很轻松的。

代码实现：

## STEP 1 预处理 vector

这个还是比较容易的，不多说了。

```cpp
vector<int> l[25];
for (int i = 1; i <= n; i++){
	string s;
	cin >> s;
	l[s.size()].push_back(i);
}
```

## STEP 2 内部排序

这也不用说吧。。。知道 vector 是如何排序的就行了。

```cpp
for (int i = 1; i <= 20; i++)
	sort(l[i].begin(), l[i].end());
```
但其实排序可以和后面的操作放在一起，但这样通俗易懂一些。

## STEP 3 双指针求解（核心部分）

解释都在代码里面了。
```cpp
int ans = 0;
for (int i = 1; i <= 20; i++){
	int cur = 1;//表示j可以和j+1到cur-1做朋友
	for (int j = 0; j < l[i].size(); j++){ 
		while (cur < l[i].size() && l[i][cur] - l[i][j] <= k)//注意判断越界，其他没啥好说的 
			cur++;
		ans += cur - j - 1;//cur-1到j+1共cur-j-1个人 
	}
}
```

## STEP 4 完结撒花

```cpp
cout << ans;
```

### 最后，奉上完整无注释的代码：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

#define gc getchar()
int read(){
	int s = 0, f = 1;
	char ch = gc;
	while (ch < '0' || ch > '9')
		f = (ch == '-' ? -1 : 1), ch = gc;
	while (ch >= '0' && ch <= '9')
		s = (s << 1) + (s << 3) + (ch ^ 48), ch = gc;
	return s * f;
}
#undef gc

int n, k;
vector<int> l[25];

int main(){
	n = read(), k = read();
	for (int i = 1; i <= n; i++){
		string s;
		cin >> s;
		l[s.size()].push_back(i);
	}
	for (int i = 1; i <= 20; i++)
		sort(l[i].begin(), l[i].end());
	int ans = 0;
	for (int i = 1; i <= 20; i++){
		int cur = 1; 
		for (int j = 0; j < l[i].size(); j++){ 
			while (cur < l[i].size() && l[i][cur] - l[i][j] <= k) 
				cur++;
			ans += cur - j - 1; 
		}
	}
	cout << ans;
	return 0;
} 
```


---


# [COCI 2012/2013 #3] AERODROM

## 题目描述

由 $m$ 人组成的某国代表团正前往澳大利亚参加 2013 年的 IOI。他们目前正在机场排队等候办理登机手续。有 $n$ 个办理登机手续的服务台开放。一些官员的工作效率比其他官员高，所以服务台的运作速度不同。在第 $k$ 个服务台，完成一名乘客的登机手续需要 $t_k$ 秒，而我们的代表团成员恰好知道确切的数字。在开始时，所有的服务都做好接受下一名乘客的准备，而现在只允许我们的代表团成员排队。一个人只有在所有排在他前面的人都已经离开队列（**开始办理登机手续，不一定要完成**）时，才能占据一个可用的服务台开始办理登机手续。这时，这个人可以立即占据一张空闲的服务台（如果有的话），但也可以选择等待另一个办理登记手续更快的服务台变成空闲。

我们的代表团成员是计算机科学怪才，他们决定让他们所有人都尽快完成签到，你的任务是找到完成签到所需要花费的最短时间。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，有两个服务台，处理时间分别为 $7$ 秒和 $10$ 秒。在代表团的六个人中，前两个人立即占据了这两个服务台。在第 $7$ 秒，第一张桌子变成空闲，第三个人占据了它。在第 $10$ 秒，第四个人占据了第二个服务台。在第 $14$ 秒，第五个人占据了第一个服务台。在第 $20$ 秒，第二张桌子再次变成空闲，但第六个人决定再等一秒钟（至第 $21$ 秒），让第一张桌子空出来，然后占据它。这样一来，签到只要花费 $28$ 秒就能完成了。如果第六个人没有等待更快的服务台，签到将花费 $30$ 秒。

**【数据范围】**

本题一共 $8$ 个测试点。各个测试点的数据范围如下表所示：

| 测试点编号 | $n\leqslant$ | $m\leqslant$ | $t_k\leqslant $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1\sim 5$ | $10^5$ | $3\times 10^5$ | $10^9$ |
| $6\sim 8$ | $10^5$ | $10^9$ | $10^9$ |

**【题目来源】**

本题来源自 **_[COCI 2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST 3](https://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf) T4 AERODROM_**，按照原题数据配置，满分 $120$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2 6
7
10```

### 输出

```
28```

## 样例 #2

### 输入

```
7 10
3
8
3
6
9
2
4```

### 输出

```
8```

# 题解

## 作者：hopeless_hope (赞：10)

### 一道二分题

#### 如果使用贪心，则会有时间复杂度 $O(m \log_{} {n})$

#### 因为数据范围 $m \le 10^9$ 且 $n \le 10^5$ 所以在最坏情况下会 TLE

所以需要二分优化

什么二分呢

二分法分为二分查找与二分答案，二分查找注重于在一个集合（有序）里找到一个数，而二分答案注重于找到答案，简单来说，就是假设答案再判断对错，做调整

这里借用一张动图来方便大家来理解二分查找：

![](https://img-blog.csdnimg.cn/24936c63a87444119ca219c0dd885020.gif)

根据动图，不难写出二分查找/答案的模版

```cpp
while(l<r)
{
    mid=(l+r)>>1;
    if(check(mid))
    {	
  	r=mid;
    }
    else 
    {
    	l=mid+1;
    }
}

```

这样一来 $O(x)$的复杂度就降到了$O( log\ x)$

我们只需要根据题意改改模版即可

**此题思路：我们需要计算出每个服务台可办理的人数之和，然后判断是否大于，小于所给人数，进行二分法即可**


### AC Code：

```cpp
#include<iostream>
using namespace std;
long long n,m,t[100005],ans,l=1,r;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>t[i];
        if(t[i]>=r)
        {
            r=t[i]; //找到集合t中的最大值
        }
    }
    r=r*m;//人数*服务台的最大时间，得最坏情况
    long long cnt,mid;
    while(l<r) //此处也可以用一个函数去写
    {
        mid=(l+r)>>1,cnt=0; //此处mid为l+r的一半
        //并初始化cnt（用来计数人数之和）为0
        //(x>>1)=(x/2)
        for(int i=1;i<=n;i++)
        {
            cnt=cnt+mid/t[i]; //计算出每个服务台能办理的人数之和
        }
        if(cnt>=m) //人数之和超过了总人数
        {
            r=mid; //使二分范围的最右边变成当前中间值
        }
        else//人数之和不到总人数
        {
            l=mid+1; //使二分范围的最左边变成当前中间值+1（中间值已经判断过）
        }
    }
  	//二分完的结果是l=r，即最终答案，因此输出l或者r都可以
    cout<<r<<endl;
    return 0;
}
```

有哪里说的不对或者不是很好的请提出！谢谢各位！


---

## 作者：duchengjun (赞：1)

# 题意

给出服务台的个数 $n$，代表团的人数 $m$，接下来 $n$ 个数，$t_k$ 表示第 $k$ 个服务台办理一名乘客的登记手续需要花费的时间，让我们求出完成签到所需要花费的最短时间。

# 分析

二分答案，用二分模板加上判断合法的函数。

$l$ 容易确定是 1，但是 $r$ 是所有的 $t_k$ 中最大的那一个乘上人数 $m$。

然后进行二分答案，若 $mid$ 分别除上 $t_k$ 的总和是小于总人数 $m$ 的话，就不合法，否则是合法的。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
//此处为快读代码
const int N=1e5+10;
ll a[N];
ll n,m,l=1,r;
bool check(ll x){
	ll cnt=0;
	for(int i=1;i<=n;i++)
		cnt+=x/a[i];
	return cnt<m;
}
int main(){
	read_(n,m);
	for(int i=1;i<=n;i++){
		read_(a[i]);
		r=max(r,a[i]);
	}
	r*=m;
	while(l<r){
		ll mid=(l+r)>>1;
		if(check(mid))l=mid+1;
		else r=mid;
	}
	write_(l);
	return 0;
}


```


---

## 作者：Harry_Meng (赞：1)

# P7757 [COCI2012-2013#3] AERODROM题解

[题目传送门](https://www.luogu.com.cn/problem/P7757)

## 题目分析
给出服务台的个数 $n$，代表团的人数 $m$，接下来 $n$ 个数，$t_k$ 表示第 $k$ 个服务台办理一名乘客的登记手续需要花费的时间。让我们求出完成签到所需要花费的最短时间。
## 思路分析——二分
首先，统计出右边界 $r$，然后进行二分，看看能否全部完成签到，如果不行，则调整左边界 $l$ 或右边界 $r$ 的大小就可以了。

然后，很重要的一点，我们要看一看我们的时间复杂度能否通过这道题目。显然，时间复杂度 $O(n$ $logm)$，数据范围 $n≤10^5$，$m≤10^9$，所以二分是能过的。
##  _Code_ 
```cpp
#include<iostream>
#include<cstdio>
#define N 300005
#define ll long long
using namespace std;
ll n,m;
ll a[N];
ll l=0,r=0;
ll cnt=0;
ll read(){    //快读函数 
	ll x=0,f=1;
	char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-'){
		ch=getchar();
	}
	if(ch=='-'){
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);   //使用位运算，速度更快。 
		ch=getchar();
	}
	return x*f;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]>r){
			r=a[i];   //找到二分的边界。 
		}
	}
	r*=m;
	while(l<r) {
		ll mid=l+(r-l)/2;   //此处为防止溢出，所以这么写的，也可以写为ll mid=(l+r)/2; 
		cnt=0;
		for(int i=1;i<=n;i++){
			cnt+=mid/a[i];
		}
		if(cnt<m){
			l=mid+1;
		}
		else{
			r=mid;
		} 
	}
    printf("%lld",l);
	return 0;
}
```


---

## 作者：int32 (赞：1)

二分答案。

考虑二分总时间 $T$，判断 $\sum_{i=1}^n\dfrac{T}{t_i}$ 是否大于 $m$（即是否可以在时间 $T$ 以内完成所有手续）。若是，则寻找更小的 $T$，否则寻找更大的。

临界值 $l=1,r=\max\{a\}\times m$。

时间复杂度 $\mathcal{O}(m\log m)$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
int n, m, l=1, r, mid;
int a[N];
bool check(int x, int r=0){
	for(int i=1;i<=n;i++) r+=x/a[i];
	return r>=m;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	r=*max_element(a+1,a+n+1)*m;
	while(l<r){
		mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}
```

---


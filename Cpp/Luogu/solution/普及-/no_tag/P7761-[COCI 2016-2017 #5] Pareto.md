# [COCI 2016/2017 #5] Pareto

## 题目背景

二八定律提出：在任何一组东西中，最重要的只占其中一小部分，而其余尽管是多数，却是次要的。

例如，微软发现只需要修复 $20\%$ 的漏洞就能够减少 $80\%$ 的故障时间。再者，研究表明，$80\%$ 的财富都掌握在 $20\%$ 的人的手中。

## 题目描述

给定 $N$ 个银行客户的存款。求两个实数 $A,B$，使得 $A\%$ 的客户恰好拥有存款总额的 $B\%$，且 $B-A$ 最大。

## 说明/提示

**【样例 1 解释】**

不难发现，存款金额为 $200$ 的客户拥有存款总额的约 $66.666667\%$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le N \le 3 \times 10^5$，所有客户的存款金额都是不超过 $10^8$ 的非负整数。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T2 Pareto_。**

**本题分值按 COCI 原题设置，满分 $80$。**

## 样例 #1

### 输入

```
2
100 200```

### 输出

```
50.0
66.66666666666666```

## 样例 #2

### 输入

```
8
100100 10 100 1000 1 10100
90100 100100```

### 输出

```
37.5
96.28172769816027```

# 题解

## 作者：Liquefyx (赞：4)

这题怎么没题解啊？（~~这道题简简单单，只要看的懂题，懂点数学就能做啊~~）那就水一篇题解吧 qwq。
# 题目分析
这道题题目说的就很简略（~~虽然还有一堆没用的背景~~），就是求 $N$ 个人中选若干人士贡献金钱，使得当前金钱占总金钱的百分比减去人数占总人数百分比后的值最大。

那么看懂题目后我们再进行推导。如果选了 $M$ 个人，则人数占总人数的百分比为 $A = \frac{M}{N}\%$，然后计算这些人的金钱总数 $S$，求出当前金钱占总金钱 $P_n$ 的百分比 $B = \frac{S}{P_n}$，但是这样暴力的话很麻烦，我们要想一些办法化简它。因为总人数和总金钱是固定的，我们便能想到乘法分配律，将求百分比时除的除数看成乘上这个除数的倒数，如下：
$$
\frac{(a+b)}{c} = (a+b)\frac{1}{c} = \frac{a}{c} + \frac{b}{c}
$$
那么每个人占总人数的百分比与每个人的金钱占总金钱的百分比的分别的和就是真实的百分比 $A$ 和 $B$ 了。为了使 $B-A$ 能尽量大，只需要先按每个人的金钱数排序，再判断金钱数占总金钱的百分比是否比这个人占总人数的百分比 $\frac{1}{N}\%$ 大就可以，这样就是比较贪心的暴力。
### 注意：百分比 $A$ 和 $B$都只输出百分数数字部分，所以说要乘一百再输出
# 代码呈上
```
#include <bits/stdc++.h>
using namespace std;
int n;
double per[300005],sum,pd,a,b;
int comp(double a,double b){
	return a > b;
}
int main(){
	scanf("%d",&n);//输入 
	pd=1.0/n;//提前算出n分之一的值,便于枚举B的值 
	for(int i = 1; i <= n; ++i)
		scanf("%lf",&per[i]), sum+=per[i];//输入并计算n个人p值总和 
	for(int i = 1; i <= n; ++i)
		per[i]=per[i]/sum;//提前除上所有人p值总和,便于计算A的值
	sort(per+1, per+1+n, comp);//从大到小排序,方便枚举 
	for(int i = 1; i <= n; ++i)
		if(per[i] >= pd)//如果添加的这个人的pi/np比1/n多,那么添加这个人后A-B的值又会多上一些 
			a+=per[i], b+=pd;
	printf("%.14lf\n%.14lf",b*100/*转为百分数*/,a*100/*转为百分数*/);//输出答案 
	return 0;
}
```

这样就做完啦 LOuO。

---

## 作者：B天选之子B (赞：3)

## 解题思路

我感觉这题就是个贪心。

**尽量少的人拥有尽量多的钱。**

- 钱要尽量多，所以可以按照钱数排序。

- 最优解就在这个序列的某一个连续区间。

- 而这个区间的某个端点就是最大的钱数。

## 注意三个点

1. 开 ```long long``` 不然会炸。

2. 保留十四位小数。

3. 在输入的时候算出总和。

## 代码奉上
```
#include<bits/stdc++.h>
using namespace std;
long long n,san,bb[1000005],sum;
double a,b,c,d;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>bb[i];
		sum+=bb[i];
	}
	sort(bb+1,bb+1+n);
	for(int i=n; i>0; i--) {
		san+=bb[i];
		c=100.0*san/sum,d=100.0*(n-i+1)/n;
		if(a-b<c-d)  a=c,b=d;
		else break;
	}
	printf("%f\n%.14f",b,a);
	return 0;
}
```
**贪心题就是要多想！**

---

## 作者：Foreverxxx (赞：1)

建议将此题难度设置为红题。

## 暴力

（~~这么简单的题还有暴力正解之分？~~）

任何一件事都是循序渐进的。

枚举每个账户的归属情况，为是否属于有钱的账户，时间复杂度 $o(n^2)$ ，显然萎掉。

## 正解

很明显的贪心，首先将所有账户的钱按数目大小排序，然后从大的开始向下枚举，分别计算出此时的 $A$ 和 $B$ 的值并更新答案，最后输出即可。

#### 给初入竞赛的 OIer 的建议

当自己做的题目难度逐渐加大时，你会发现自己的贪心方法科一过样例，但提交后会 WA 掉，是因为数据范围太小，贪心等许多方法都能过样例但不是正解，但千万不要遇到这种情况多了就认为这些算法没用，因为真正用到他们时，你才会发现他们优点！

贪心题目一定要去想，去证明自己方法的正确性，不然最好先打暴力分，然后大数据用自己的贪心，这样能保证该拿的分能拿到，还有可能多拿很多分。

$AC$ 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n;
long long a[300005];
double ansa=0,ansb=0;
long long sum=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];//sum用于统计所有账户的总钱财，方便后面计算 
	}
	sort(a+1,a+n+1);//sort函数是C++自带的排序函数，没有其它自定义时能将数组从小到大排序，时间复杂度o(nlogn) 
	long long tmp=0;
	for(int i=n;i>=1;i--){//从大往小枚举 
		tmp+=a[i];
		double ta=tmp*1.0/sum,tb=(n-i+1)*1.0/n;
		if(ta-tb>ansa-ansb){
			ansa=ta,ansb=tb;
		}
	}
	printf("%.4lf\n",ansb*100);//保留4位输出 
	printf("%.12lf",ansa*100);//保留12位输出 
	return 0;
}
```


---

## 作者：pujingcat (赞：1)

建议 普及-。

[题目传送门](https://www.luogu.com.cn/problem/P7761)


这道题的题意还算明了，就是在一个序列里面，选若干个元素，使其所占的元素的数量除以总元素数量的值减去区间元素和除以总元素和的值最大。

不难发现，在相同的情况下，选择较大的比选择较小的更优，所以我们应当尽可能的选择权值比较大的元素。

那么我们可以直接对这个序列排序，从大到小进行枚举，依次选择此元素，如果选择此元素比原来的答案更优，则我们将答案替换为此，否则直接退出（因为如果选择这个都没原来优，那么选后面的就不可能比现在优了）。

代码如下
```
#include <bits/stdc++.h>
using namespace std;
double a=0.0,b=0.0,tot=0.0,sum=0.0;//a,b为答案,tot为当前区间值，sum为总区间值
int n,p[300001];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&p[i]),sum+=double(p[i]);
	sort(p+1,p+1+n);
	for(int i=n;i>=1;i--){
		tot+=double(p[i]);
		double aa=double(n-i+1)/double(n),bb=tot/sum;
		if((bb-aa)>(b-a))
			a=aa,b=bb;
		else break;
	}
	a*=100,b*=100;
	printf("%lf\n%lf",a,b);
	return 0;
}
```


---

## 作者：pengzy___ (赞：0)

### 题意：
在一个长度为 n 的序列中找到若干个数，使得当前数占总数的百分比减去人数占总人数百分比后的值最大。

### 分析：
此题就是贪心。

先把每个客户的存款数进行排序，再从最大的到最小的开始枚举。

每一次循环根据题目条件模拟，并更新答案。

注意：输出保留十四位小数。

### 代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n,num,s[1000005],sum;//记得开longlong
double a,b,c,d;//双精度实数
int main() 
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>s[i];
        sum+=s[i];//加上每一个数
    }
    sort(s+1,s+1+n);//STL函数
    for(int i=n;i>0;i--) 
    {
        num+=s[i];
        c=100.0*num/sum,d=100.0*(n-i+1)/n;
        if(a-b<c-d){a=c;b=d;}//更新答案
        else break;
    }
    printf("%f\n%.14f",b,a);
    return 0;//养成好习惯
}
```


---

## 作者：杨岛主杨东润 (赞：0)

## P7761题解
### 题目含义：

给你输出 $n$个银行客户的数据，让你在 $b-a$ 最大时输出 $a%$ 和 $b%$。

这道题好简单啊!

### 具体解法：

最开始，我们先输入 $n$ 和 $a$ 数组。

输入之后，我们先用 $sum$ 存入总和，并将 $a$ 数组排序。

接下来我们用一个循环去计算 $b$ 和 $a$。

最后，我们输出就可以啦！

### 具体代码：
不要抄袭哦！
```cpp
#include<iosream> //文件头（？！？） 
#include<cstio>
#include<algorihm>
using namespace std;
long long a[1000006];//要用long long 
long long sum=0;//long long!!
int main(){
	int n; 
	cin>>n;
	for(int i=1;i<=n;i++){//for循环输入 
		cin>>a[i];
		sum+=a[i];//sum加上 
	}
	sort(a+1,a+n+1);//sort一下这个数组 
	long long cnt=0; //开long long,不开30分 
	double c=0,b=0;//要用double,否则输出0 
	for(int i=n;i>=1;i--){
		cnt+=a[i];//cnt存一下 
		if(cnt*1.0/sum-(n-i+1)*1.0/n>c-b){//如果 
			c=cnt*1.0/sum;//更改c和b 
			b=(n-i+1)*1.0/n;
		}
	}
	printf("%.4lf",b*100);//输出（4位） 
	cout<<endl; //输出换行符 
	printf("%.12lf",c*100);//输出（12位） 
	return 0;//结束啦！ 
}
```
谢谢观看！！！

---


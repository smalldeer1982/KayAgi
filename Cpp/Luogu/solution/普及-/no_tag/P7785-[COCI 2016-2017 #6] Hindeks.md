# [COCI 2016/2017 #6] Hindeks

## 题目描述

给出一个数列，请你求出一个最大的整数 $H$，使原数列中至少有 $H$ 个数 $\ge H$。

## 说明/提示

**【样例解释 #1】**

比 $2$ 大的数有 $2$ 个，分别是 $4$ 和 $8$。

**【样例解释 #2】**

比 $4$ 大的数有 $4$ 个，分别是 $8$，$5$，$4$ 和 $10$。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$，$0\le A_i\le 1\times 10^6$。

**【说明】**

本题分值按 COCI 原题设置，满分 $50$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T1 HINDEKS**_

## 样例 #1

### 输入

```
5
1 1 4 8 1 ```

### 输出

```
2```

## 样例 #2

### 输入

```
5
8 5 3 4 10```

### 输出

```
4```

# 题解

## 作者：yydfj (赞：11)

**这是本蒟蒻第十次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个长度为 $N$ 的序列，求 $H$ 为前 $H$ 大的数。

## 解法综述

我们可以用桶的方法来做，用数组 $a$ 做桶来记录每个数，之后在序列里的数的范围内（$0≤$ 序列里的数 $≤10^6$）进行操作。

设 $n$ 为 $i$ 的第 $n$ 大的数，当发现 $a_i$ 有数时，则说明大小为 $i$ 的数有 $a_i$ 个，用 $n$ 将其减去。如果 $i$ 大于等于 $n$ ，则表明 $i$ 为前 $i$ 大的数，将 $i$ 输出即可。

## 代码描述
```cpp
#include<cstdio>
#define max(a,b) (a>b?a:b)
int n,x,a[1000005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		a[x]++;//用数组a做桶来记录每个数
	}
	for(int i=0;i<=1000000;i++)
	{
		n-=a[i];//n为i的前n大的数，ai为大小为i的数的数量
		if(i>=n)//如果i为至少第i大的数
		{
			printf("%d",i);//输出结果，结束程序
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：wangbinfeng (赞：5)

# 思路：
本题要求一个最小的整数 $H$ ，使 $H$ 个数 $> H$ 。

首先想好暴力肯定是第一步。用 $O(N^2)$ 的时间复杂度枚举 $H$ 及判断。

我们可以清晰的发现，枚举和判断可以同时进行。因此，我们可以对数组 $a$ 先**排序**，然后暴力枚举 $H$ 即可。时间复杂度为  $O(N \log N+N)=O(N \log N)$ 。
# 代码：
1. C++代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[500009],n,h;
inline bool cmp(int a,int b){return a>b;}//注意要从大到小排序
inline int read(){
    //快读
}
int main(){
	n=read();
	for(int i=0;i<n;i++)a[i]=read();//读入
	sort(a,a+n,cmp);//sort
	for(h=0;h<n&&a[h]>h;h++);//暴力计算
	printf("%d",h);//输出
}
//温馨提示：由于禁止大片模板，代码删去了快读内容。（抄题解的注意下，不把代码填完会RE，别再举报我了）
```

2. Python 3代码：

```Python 3
n = int(input())
a = list(map(int, input().split()))
a.sort(reverse=True)
h = 0
while h < n and a[h] >= h + 1:
    h += 1
print(h)
# std的代码
```

---

## 作者：wangbinfeng (赞：3)

# 思路：
言归正传，首先我们要求 $H$ 个数 $>H$ ，显而易见，本题具有**单调性**（ $H$ 越大 $>H$ 的数量就越少，反之亦然）。因此，我们可以考虑 **_二分_** 。

我们可以**二分答案**，然后再用暴力 cheak 即可。

时间复杂度 $O(N \log \max_A)$ ，速度大概为第一篇题解`sort`优化的 $\frac{1}{2}$ 。
# 代码：
```cpp
#include<cstdio>
using namespace std;
#define max(a,b) (a>b?a:b)
int a[500009],n,l,r,mid;
inline bool cmp(int a,int b){return a>b;}
inline int read(){
    //快读
}
inline bool cheak(int mid){
	int ans=0;
	for(int i=1;i<=n;i++)if(a[i]>mid)ans++;
	if(ans<=mid)return true;
	return false;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),r=max(r,a[i]);
	for(l=1,mid=(l+r)/2;l<r;mid=(l+r)/2){//二分
		if(cheak(mid))r=mid;
		else l=mid+1;
	}
	printf("%d",mid);
}
//温馨提示：由于禁止大片模板，代码删去了快读内容。（抄题解的注意下，不把代码填完会RE，别再举报我了）
```
~~[然后随手抢了最优解](https://www.luogu.com.cn/record/55704536)~~

---

## 作者：FuriousC (赞：3)

## 思路

由于题目让我们求 最小的整数 $H$，使原数列中恰好有 $H$ 个数 $\ge H$，不难想到将原数列从大到小排序。

将 $ans$ 设为 $0$，从最大的数开始比较：

当前数比 $ans+1$ 大且 $ans<n$ 时，$ans+1$。

**注意是当前数与 $ans+1$ 比较，因为这次循环完之后 $ans$ 要 $+1$。**

## 代码

```
#include<bits/stdc++.h>
using namespace std;
int a[500005];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i]; 
	}
	sort(a,a+n,cmp);
	int h=0;
	while(h<n&&a[h]>=h+1){
		h++;
	}
	cout<<h;
	return 0;
} 
```


---

## 作者：HgSO4qwq (赞：2)

# 思路

首先，这一题很容易想到可以用前缀和。

设 $s_i$ 为大于等于 $i$ 的数的个数，$t_i$ 为 $a$ 中等于 $i$ 的个数，那么 $s_i=s_{i-1}+t_i$。

那么，题目要求**最大的整数** $H$，使原数列中至少有 $H$ 个数 $\ge H$，我们从大往小枚举每一个数，看看它是否满足条件，即 $s_i\ge i$，若满足就输出。

**注意，这个数可以为 0，要不然就只有 $\color{Green}46$ 分了。**

# 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int a[500010],s[1000010],t[1000010];

int main()
{
	int n,mx=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]>mx) mx=a[i];
		t[a[i]]++;
	}
	sort(a+1,a+n+1);
	for(int i=mx;i>=1;i--)
	{
		s[i]=s[i+1]+t[i];
	}
	for(int i=mx+1;i>=0;i--)// 注意可以为0
	{
		if(s[i]>=i)
		{
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
}
```

注：这是我第一次发题解，望管理员大大通过！QAQ

---

## 作者：Elgo87 (赞：0)

对于这一题，我们可以暴力枚举，把 $H$ 的值在 $0\sim n$ 中枚举一遍，选出最大的满足条件的数，输出。

显然不行，因为我们看到数据范围：$1\le N\le 5\times 10^5$，这样的复杂度是 $O(n^2)$，时间会爆炸。

所以这一题自然想到**二分答案**求解。左端点初始为 $0$，右端点初始为 $n$，然后去二分答案，找到最大的符合条件的数，然后输出左端点即可。

这题没有什么特别的，直接套模板，然后一个二分代码就出来了：



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,arr[500005];

bool check(int x)
{
    int sum = 0;
    for(int i=0; i<n; i++)
    {
        if(arr[i] >= x)  //sum 统计数列中大于等于 H 的数
        {
            sum ++;
        }
    }
    return sum >= x;  //返回bool，表示 sum 是否大于 H
}

int main()
{
    cin>>n;
    for(int i=0; i<n; i++)
        scanf("%d",&arr[i]);
    
    int left=0, right=n;
    while(left < right)  //二分答案模板不多讲，学过就行
    {
        int mid = (left + right) / 2 + 1;
        if(check(mid)) left = mid;
        else right = mid - 1;
    }
    cout<<left;
    return 0;    
}
```


嗯，不出我们所料，这题[AC](https://www.luogu.com.cn/record/57261490)了。

完美撒花结束~

---

## 作者：Marginal_world (赞：0)

求最小整数，即将原数列从大到小排序后比较即可。

将答案先赋值零，然后开始比较，如果当前数比当前答案加一大且当前答案小于数的个数，答案加一。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500005];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i]; 
	}
	sort(a,a+n,cmp);
	int h=0;
	while(h<n&&a[h]>=h+1){
		h++;
	}
	cout<<h;
	return 0;
} 

```


---

## 作者：hwwqy (赞：0)

# P7785 [COCI2016-2017#6] Hindeks 题解  
首先呢，很明显的看到，这道题给出一个长度为 $N$ 的序列中有多少个数大于 $H$ ，求这个 $H$ 的最大值。  
然后瞄一眼数据范围 $1 \leq N \leq 5\times10^5$ $ 0 \leq A_i \leq 1\times10^6$  。  
很明显，如果我们枚举每一个 $H$ 的值，那时间复杂度必然爆炸。  
那怎么办呢，很明显得二分。  
二分什么？二分 $H$  。
我们可以选一个比每个 $A_i$ 都大的数作为 $R$ ,选择 1 作为 $L$ , 那么，我们可以每次二分出 $H$ 的值记作 `mid`，然后再循环一遍 $A$ 数组,把大于 `mid` 的数的个数记为 `tmp`,如果 `tmp>=mid` 那么就更新答案，否则就要把 $R$ 变为 `mid+1` 。
最后附上标程
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[500005];
int check(long long h)
{
	int ans=0;
	for(int i=1;i<=n;i++)ans+=(a[i]>=h);
	return ans;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	long long l=1,r=1e6+100,mid,mx=0;
	while(l<=r)
	{
		mid=(l+r)/2;
		int tmp=check(mid);
		if(tmp>=mid)
		{
			mx=max(mx,mid);
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
		//cout<<tmp<<endl;
	}
	cout<<mx;
    return 0;
}

```


---

## 作者：galfth (赞：0)

其实这道题非常简单，在我看来只有红题的难度，甚至不像我前面那些大佬用什么前缀和、二分什么的那些算法。

将数列排序，从大到小或从小到大都无所谓，之后再用循环遍历检查就行。

只不过要注意循环里的判断是很核心的，就是这样

```cpp
i<=n&&a[i]>=i

```

当不再满足时就跳出循环输出，但是因为又多进行了一次运算，就要输出 $i-1$

整部分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int a[N];
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1,cmp);
	int i=1;
	for(i=1;i<=n&&a[i]>=i;i++);//因为会执行后面的语句，所以for循环后面必须加分号
	
	cout<<i-1;
	return 0;
 } 
```



---


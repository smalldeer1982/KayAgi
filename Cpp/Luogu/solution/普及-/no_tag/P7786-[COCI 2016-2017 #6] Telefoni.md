# [COCI 2016/2017 #6] Telefoni

## 题目描述

一个办公室有 $N$ 张桌子从左至右排列，有些桌子上放了电话。

当第 $j$ 个桌子上的电话响了后，第 $i$ 个桌子上的电话也会响，当且仅当 $|j-i|\le D$。

现在给出电话的摆放情况，请你求出最小需要添加几个电话，能使最后一个桌子上的电话响起。

保证第一张桌子和最后一张桌子有电话放置。

## 说明/提示

**【样例解释 #1】**

在 $2$ 号桌子上添加一个电话，即可使 $4$ 号桌子上的电话响起。

**【样例解释 #2】**

在 $3$ 号桌子上添加一个电话，即可使 $5$ 号桌子上的电话响起。

**【样例解释 #3】**

在 $4$ 号桌子和 $7$ 号桌子上各添加一个电话，即可使 $8$ 号桌子上的电话响起。

**【数据范围】**

对于 $50\%$ 的数据，$1\le N\le 20$；

对于 $100\%$ 的数据，$1\le D\le N\le 3\times 10^5$。

**【说明】**

本题分值按 COCI 原题设置，满分 $80$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T2 TELEFONI**_

## 样例 #1

### 输入

```
4 1
1 0 1 1 ```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2
1 0 0 0 1```

### 输出

```
1```

## 样例 #3

### 输入

```
8 2
1 1 0 0 1 0 0 1```

### 输出

```
2```

# 题解

## 作者：lanretE (赞：7)

一道简单的贪心题。

大致思路：如果空隙（连续 0 的长度）超过 $d$ 则增加一台电话，不然不加。

实现：
 
定义 $blk$ 记录当前空隙长度，读到 0 则加 1，读到 1 说明空隙结束，需要增加的电话数量即为 $\left\lfloor\dfrac{blk}{d}\right\rfloor$。


**代码如下：**
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,d;
	cin>>n>>d;
	int blk=0,ans=0;
	while(n--){
		bool x; cin>>x;
		if(x){
			ans+=blk/d;
			blk=0;
		}
		else blk++;
	} 
	cout<<ans<<endl;
	return 0;
} 
```



---

## 作者：ImposterAnYu (赞：4)

# 简化版题意（可忽略）
给出一个有 $n$ 个数且里面只有 $0$ 和 $1$ 的数列，保证第一个数和第 $n$ 个数都是 $1$，请求出至少要将多少个 $0$ 变成 $1$，使得每两个相邻的 $1$ 之间的距离均不超过 $d$。

# 解析
因为原题意是让最后一个办公桌上的电话响起，所以我们可以从最后一个电话开始向前枚举。

定义一个变量 $p$，表示当前已经枚举到了第 $p$ 个办公桌，将其初始化为 $n$，然后每次向前枚举 $d$ 个办公桌。如果这个办公桌（即第 $p - j$ 个办公桌）上有电话，$p$ 的值就变成这个办公桌的编号（即 $p = \max(p - j,1)$）。

```cpp
q = p;//p 用来记录现在 p 的值。 
		for(j = 1; j <= d; j++){
			if(a[q - j]){//如果这个办公桌上有电话，p 就变成这个办公桌的编号。
				p = max(q - j,1);
			}
		}
```

如果一轮下来，$p$ 的值没有发生变化，就说明我们需要在第 $\max(p - d,1)$（最优）个办公桌上放一台电话。同时，$p$ 的值也要变成 $\max(p - d,1)$。

```cpp
if(q == p){//如果p没有变化，就说明需要在 max(p - d,1) 处多一个电话。 
			s++;
			p = max(p - d,1);//同时，p 也变成这个刚有电话的办公桌的编号。
		}
```
最后，只需要在 $p = 1$ 的时候退出循环就好了。

```cpp
if(p == 1){//枚举完就退出循环。 
			break;
		}
```
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,i,j,s,p,q;
bool a[300005];
int main(){
	cin >> n >> d;
	for(i = 1; i <= n; i++){
		cin >> a[i];
	}
	p = n;
	for(i = 1; ; i++){
		q = p;//p 用来记录现在 p 的值。 
		for(j = 1; j <= d; j++){
			if(a[q - j]){//如果这个办公桌上有电话，p 就变成这个办公桌的编号。
				p = max(q - j,1);
			}
		}
		if(q == p){//如果p没有变化，就说明需要在 max(p - d,1) 处多一个电话。 
			s++;
			p = max(p - d,1);//同时，p 也变成这个刚有电话的办公桌的编号。
		}
		if(p == 1){//枚举完就退出循环。 
			break;
		}
	}
	cout<< s << endl;
	return 0;
}
```


---

## 作者：turing_hcy (赞：3)

### 这道题简单的模拟一下就过了~~本蒟蒻一开始还写的动归~~
#### 1. 思路
这道题说的是让我们求要多少台电话，不妨可以转化成求每个电话间没有电话的长度有几个最大距离
#### 2. 代码实现
明确了思路后代码实现也是非常的简单
只需要在第一次没有电话的时候开始记录没有电话的区间的长度，如果碰到了电话，就让清零，再重新记录，最后看看有几个最大距离就可以啦
#### 上代码
```c
#include<bits/stdc++.h>
using namespace std;
int vis[300005];
int ans;
int main()
{
	int n,d;
	int temp;
	cin>>n>>d;
	for(int i=1;i<=n;i++) cin>>vis[i];
	for(int i=1;i<=n;i++)
	{
		if(vis[i])	temp=0;
		if(!vis[i])
		{
			temp++;
			if(temp>=d)
			{
				ans++;
				temp=0;
			}
		}
	}
	cout<<ans;
 	return 0;
}


```



---

## 作者：seac_blue (赞：1)

原题：[P7786 [COCI2016-2017#6] Telefoni](https://www.luogu.com.cn/problem/P7786)

题意：

给定 $n,d$ 与数列 $\{a_n\},a_i\in\{0,1\}$

求 $k_{\min}$ 使得存在一组操作：将数列中的 $k$ 个数置为 $1$ 后，$\forall\ i\in[1,n],\exists\ j\in[i-d,i+d],a_j=1$

思路：

贪心。

容易发现，处理一台电话前的 $d$ 台电话没有意义。故只关心这台电话后的 $d$ 台电话。

如果 $i<j$，那么 $i+d<j+d$，故处理一串联通的 $1$ 时，只需要分析最右端的 $1$ 即可。

两串联通的 $1$ 中间必定夹着一串联通的 $0$，只需要处理这段联通 $0$ 的长度，就可以得出需要放置多少台电话。

更具体地，设联通 $0$ 的长度为 $d_0$，则需要放置的电话台数就是 $\lfloor\dfrac{d_0}{d}\rfloor$，读者自证不难。

代码如下，已删去头文件：

```cpp
using namespace std;

#define re register
typedef long long ll;

inline ll read(){
	char c=getchar();ll d=0,f=1;
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){d=(d<<3)+(d<<1)+(c^48);c=getchar();}
	return d*f;
}

ll n,d,ans;
ll gapsz=0;

int main(){
	n=read();d=read();
	for(re ll i=1;i<=n;++i){
		ll x=read();
		if(x){
			ans+=gapsz/d;
			gapsz=0;
		}else{
			++gapsz;
		}
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：一只大龙猫 (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P7786)

这是一篇 **Python** 题解，文末也会附上 C 和 C++ 的代码。

对于这一道题，我们需先求出其中每一串连续的 $0$ （即连续的空桌子）的长度，然后求对于每一排连续的空桌子，我们需要增加的电话数。

对于一排长度为 $len$ 的连续的空桌子，不难发现至少需要在其中添加 $\lfloor \frac{len}{d} \rfloor$ 个电话。

代码如下：

```python
n,d=map(int,input().split())
s=input()
a=s.split()
cnt=0 #用于储存连续空桌子的长度
ans=0
for i in range(n):
    if a[i]=='1': #如果a[i]为1，则计算需要增加多少个电话，并将cnt清零
        ans+=cnt//d #//为整除符号
        cnt=0
    else: #否则cnt自增
        cnt=cnt+1
print(ans)
```

由于篇幅原因，C 与 C++ 的代码被我放到了[这里](https://www.luogu.com.cn/paste/a49q5318)，有需要的可以点击查看。

由于 Python 的输入方式是是整行输入，与 C 和 C++ 截然不同，所以如果对输入方式有疑问的，可以看看[这里](https://www.luogu.com.cn/paste/kgmyld2t)。

---


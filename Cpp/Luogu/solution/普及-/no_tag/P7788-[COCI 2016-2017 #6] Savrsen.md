# [COCI 2016/2017 #6] Savrsen

## 题目描述

一个数是完美的，仅当它等于它的因数中比它小的所有数之和。

例如：$28=1+2+4+7+14$，所以 $28$ 是完美的。

由此我们可以定义一个数的不完美值 $F(N)$，代表 $N$ 和比 $N$ 小的所有 $N$ 的因数之和的差的绝对值。

例如：$F(6)=|6-1-2-3|=0$，

$F(11)=|11-1|=10$，

$F(24)=|24-1-2-3-4-6-8-12|=|-12|=12$。

现在给出两个正整数 $A$ 和 $B$，请你求出 $F(A)+F(A+1
)+...+F(B)$。

## 说明/提示

**【样例解释 #1】**

$F(1)+...+F(9)=1+1+2+1+4+0+6+1+5=21$。

**【数据范围】**

对于 $100\%$ 的数据，$1\le A,B\le 10^7$。

**【说明】**

本题分值按 COCI 原题设置，满分 $120$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T4 SAVRSEN**_

## 样例 #1

### 输入

```
1 9```

### 输出

```
21```

## 样例 #2

### 输入

```
24 24```

### 输出

```
12```

# 题解

## 作者：tuxuanming2024 (赞：16)

这题如果暴力求每个数的因数肯定会爆，于是我们可以用类似埃及筛法的思想去做。

枚举 $ [1,b] $ 之间的数 $ i $ ，那么 **$ i $ 一定是 $ i $ 倍数的因数**，所以我们枚举 $ j $ ，在 $ i \times j $ 的因数中加上 $ i $ ，最后 $ [a,b] $ 循环依次累加“不完美值”即可。

code:

```cpp
#include <iostream>
#include <cmath>
using namespace std;
long long a,b,s[10000005],ans;
int main()
{
	cin>>a>>b;
	for(int i=1;i<=b;i++)
		for(int j=2;i*j<=b;j++) s[i*j]+=i;
	for(int i=a;i<=b;i++) ans+=abs(i-s[i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：seac_blue (赞：3)

**Upd 2021/8/9 18:05** 思路中有一处公式错误 $\sum_{i=a}^{b}(i-p(i)) \to \sum_{i=a}^{b}|i-p(i)|$

原题：[P7788 [COCI2016-2017#6] Savrsen](https://www.luogu.com.cn/problem/P7788)

题意：设 $F(x)=|x-\sum_{i|x,i\neq x}i|$，求 $\sum_{i=a}^{b}F(i)$

思路：

设 $p(x)=\sum_{i|x,i\neq x}i$，则 $F(x)=|x-p(x)|$

对于一个数 $x$，能为其除本身的所有倍数 $mx(m=2,3,4\dots)$ 的 $p(mx)$ 贡献 $x$。

由于 $1\sim a$ 范围内的数也会造成贡献，所以在 $1\sim b$ 范围内枚举 $x$，在 $1\sim b$ 范围内枚举 $mx$，$p(mx)\gets p(mx)+x$ 即可。

最后求 $\sum_{i=a}^{b}|i-p(i)|$ 即可。

代码如下，已删去头文件。

```cpp
using namespace std;

#define re register
typedef long long ll;

inline ll read(){
	char c=getchar();ll d=0,f=1;
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){d=(d<<3)+(d<<1)+(c^48);c=getchar();}
	return d*f;
}

const ll MAXN = 11451400;

ll a,b,ans;
ll p[MAXN];

inline ll init(ll n){
	for(re ll i=2;i<=n;++i){
		++p[i];
		for(re ll j=2;i*j<=n;++j){
			p[i*j]+=i;
		}
	}
}

int main(){
	a=read();b=read();
	init(b);
	for(re ll i=a;i<=b;++i){
		ll res=i-p[i];
		if(res<0)res=-res;
		ans+=res;
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：Alarm5854 (赞：2)

做这题，首先要知道一个前置知识：因数和。

对于任意一个数 $x$，它一定可以被分解为如下形式：

$$x=\prod_{p_i|x}p_i^{c_i}$$

其中 $p_i$ 为质数。

这样的话，记 $x$ 的因数和为 $S(x)$，则有：

$$S(x)=\prod_{p_i|x}(\sum_{j=0}^{c_i}p_i^j)$$

证明的话就是 $x$ 因数的质因子次幂不超过 $x$ 的质因子次幂。

知道这个式子以后，易得：

$$F(x)=|S(x)-2x|$$

这就是 $F(x)$ 的定义。

这样实现就容易了：先把 $[1,b]$ 以内的质数筛出来，然后枚举每一个质数，按照不同的次幂计算贡献即可。

这题没有多测，所以不需要求前缀和，如果多测则需要再求一次前缀和。

时间复杂度为 $O(b\log\log b)$，效率瓶颈在计算贡献。

```cpp
#include<ctime>
#include<cstdio>
#include<cctype>
#define ll long long
using namespace std;
const ll N=1e7+7;
ll read() {
	char c;
	ll x=0,f=1;
	while(!isdigit(c=getchar()))
		f-=2*(c=='-');
	while (isdigit(c)){
		x=x*10+(c-48)*f;
		c=getchar();
	}
	return x;
}
ll f[N];
bool v[N];
int a,b,tot,p[N];
int abs(int x){
	return x>0?x:-x;
}
int main() {
	a=read();
	b=read();
	for(int i=1;i<=b;++i)
		f[i]=1;
	for(int i=2;i<=b;++i){
		if(!v[i])
			p[++tot]=i;
		for(int j=1;j<=tot&&i*p[j]<=b;++j){
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
		}
	}
	for(int i=1;i<=tot;++i){
		int s=1;
		for(ll j=p[i];j<=b;j*=p[i]){
			s+=j;
			for(int k=j;k<=b;k+=j){
				if(!(k/j%p[i]))//如果比这个次幂高，则暂时不计算贡献
					continue;
				f[k]*=s;
			}
		}
	}
	for(int i=1;i<=b;++i)
		f[i]=f[i-1]+abs(f[i]-i*2);
	printf("%lld\n",f[b]-f[a-1]);//我当时没注意单测，求了前缀和
	return 0;
}
```

---

## 作者：Sya_Resory (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P7788)

题意：令 $f(k)$ 为 $k$ 的约数和，求 $\sum\limits_{i=A}^B|i-f(i)|$。

考虑快速求出 $f(i)$。

这是一个埃氏筛模板：

```cpp
void Sieve(int n) {
    for(int i = 2;i <= n;i ++) {
        // xxxx
        for(int j = 2;i * j <= n;j ++)
            // xxxxx
    }
}
```

这个玩意如果不考虑质数，复杂度近似于 $O(n\log n)$，可以通过本题。考虑魔改一下他，定义数组 $s$，并且每次循环使得 $s_{i\times j}=s_{i\times j}+i$。于是 $f(k)=s_k$。接着统计即可。

code：
```cpp
#include <cstdio>

const int maxn = 1e7 + 5;
typedef long long ll;

int a,b;
ll ans,s[maxn];

inline ll abs(ll x) { return x < 0 ? -x : x; }

int main() {
    scanf("%d%d",&a,&b);
    for(int i = 1;i <= b;i ++) {
        s[i] = abs(i - s[i]);
        for(int j = 2;i * j <= b;j ++)
            s[i * j] += i;
    }
    for(;a <= b;a ++) ans += s[a];
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Foreverxxx (赞：0)

题意：区间中每个数与除它自己以外的因数的和的绝对值之差的和。

既然是找某个数的因数，那么我们可以反向思考：一个数是哪些数的因数？

那么我们可以想到一个算法，**枚举每一个数，将它所有的在区间范围内倍数算出来，这个数一定是它的倍数的因数**，加上即可。

注意最后的结果要开 long long ！（~~惨痛的教训嘤嘤嘤~~）

贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int s[10000005];
inline int read(){
    int sss=0,www=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
		if(ch=='-')www=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9') sss=sss*10+ch-'0',ch=getchar();
    return sss*www;
}
int main(){
	a=read(),b=read();
	for(int i=1;i<=b;i++){
		s[i]=abs(i-s[i]);
		for(int j=2;j*i<=b;j++){
			s[i*j]+=i;
		}
	}
	long long ans=0;
	for(int i=a;i<=b;i++)
		ans+=s[i];
	cout<<ans;
	return 0;
}
```


---


# [COCI 2014/2015 #7] TETA

## 题目背景

你发现自己扮演的是一位在食堂担任收银员的好女士。这位女士被所有学生认为是好人的多种原因之一是，她关心你在访问食堂时尽可能少花钱。

## 题目描述

她是如何做到这一点的呢？策略其实很简单。在食堂里可以买到各种饭菜，其价格也是众所周知的。每天都会提供一份**套餐**。一份套餐包括 $4$ 份饭菜（通常是汤、主菜、配菜和甜点），但它的价格 $x$ 小于或等于其组成部分的价格总和。当这位女士注意到，如果你拿了套餐中的个别东西，并且如果按照一整个套餐的费用会花更少的钱，那么她就**一定会这样做**，而你会满载而归，口袋里剩下比原来更多的钱。

你拿着托盘站在收银台前，想知道你要付多少钱。写一个方案来确定它吧!

请注意：女士可以用多个套餐向你收费，这样价格会更便宜。

## 说明/提示

**【样例 1 解释】**

你点了 $1,3,4$ 这三个在套餐中的餐品，这三个餐品单点的总价为 $10+8+9=27$，大于套餐的价格 $14$，因此收银的女士会将这些餐品按照 $14$ 元收费。除此之外的 $6,7$ 两个餐品不在套餐中，因此单独收费。故总花费为 $14+5+3=22$。

**【样例 2 解释】**

你点了 $1,2$ 这两个在套餐中的餐品，这两个餐品单点的总价为 $12+4=16$，大于套餐的价格 $14$，因此收银的女士会将这些餐品按照 $14$ 元收费。此外还剩下一个 $1$ 号餐品和两个 $6$ 号餐品。由于一个 $1$ 号餐品的价格是 $12$，小于套餐的 $14$，而另外两个 $6$ 号餐品又不在套餐里出现，因此剩下的一个 $1$ 号餐品和两个 $6$ 号餐品都只能单独收费。因此总花费为 $14+12+3\times 2=32$。

**【数据范围】**

对于所有数据，$1\leqslant k,t\leqslant 20$，$1\leqslant c_i\leqslant 250$，$1\leqslant x<1000$，$1\leqslant p_i,s_i\leqslant k$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T1 TETA_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
7
10 6 8 9 4 5 3
14
1 2 3 4
5
1 3 4 6 7```

### 输出

```
22```

## 样例 #2

### 输入

```
6
12 5 7 8 9 3
14
4 3 1 2
5
1 2 1 6 6```

### 输出

```
32```

# 题解

## 作者：信息向阳花木 (赞：10)

这道题，~~比较水~~

[题目传送门](https://www.luogu.com.cn/problem/P7791)

### 好了，分享思路的时候到了：
- 读入时，我们看看这份菜品在不在套餐当中，若在，用桶 $a$ 记录下这份菜品所需的数量；若不在，将这份菜品的单价加到 $ans$ 当中。

- 当数据全部读入完毕时，先用 `while` 循环循环 $t$ 个我想要的菜品，再用 $i$ 把 $n$ 个菜品遍历一遍，当 `a[i]!=0` 时，我们计算：
	
	（1）将第 $i$ 个物品的单价加进单价和变量 $cnt$ 中。
    
   （2）将 $a_i$ 减 1，代表这个菜品中的一份我已经处理过了。
    
	（3）计算购买其套餐需要多少钱。
    
   （4）取两个中的最小值，加进答案中。
   
 为什么可以这样做，这样做的依据是什么？
  	
   1. `a[i]!=0` 时，当且仅当这个菜品出现在套餐当中。
     
   2. 由于每次 $a_i$ 只减 1，所以，不会出现套餐中重复出现        某一菜品，也就是不会有多个同种菜品被算成 1 个菜品出现在套餐当中了。
   3. 这样每次到最后（依然在 `while` 内部）才加上套餐和单价和的最小值，不会把套餐的价格在每个菜品头上都再加一遍。
   
还不会，就看程序吧。注释都在程序里哦！

### C++ 代码
```cpp
#include <iostream>//尽量缩短代码。 
using namespace std;
int k,x,t,ans,c[20],p[5],s[20],a[20];//意思与题目和解析里的意思相同。
int main(){
	cin>>k;
	for(int i=1;i<=k;i++)cin>>c[i]; 
	cin>>x;
	for(int i=1;i<=4;i++)cin>>p[i];
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>s[i];
		if(s[i]==p[1]||s[i]==p[2]||s[i]==p[3]||s[i]==p[4]){//若是套餐里的菜品。 
			a[s[i]]++;//桶计数。 
		}
		else ans+=c[s[i]];
	}
	while(t--){
		int cnt=0;
		for(int i=1;i<=k;i++){//用 i 循环遍历 n。 
			if(a[i]>0){
				cnt+=c[i];a[i]--;}}
		ans+=min(cnt,x);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：AmaZingFantasy (赞：9)

首先，拿到这道题，不难发现，对于每一个你要买的食物，只有 $2$ 种状态：在套餐中或不在套餐中，将它们分类处理即可。

- 先定义一个变量 $cnt$，用于记录到这一步之前你花了多少钱。开一个结构体数组 $ff$，表示这 $4$ 种食物的编号和这些食物在你的食物中出现了几次。

- 如果这个食物不在套餐中，乖乖付钱就行了。

- 如果这个食物在套餐中，在 $ff$ 中查询，找到相应的食物，将 $ff$ 的那一项表示出现次数的变量加 $1$。

将 $ff$数组处理好后，开始以下的操作：

- 只要 $ff$ 中还有一项不为 $0$，循环执行下面的语句。

- 定义一个变量 $c$，用于记录在所有在套餐中的食物的价钱之和。

- 每次循环算一遍 $c$，如果 $ff$ 的这一项不为 $0$，那就将 $c$ 加上这一项所对应的价钱。并将这一项出现的次数减 $1$。

- 如果 $c \geq$ 一份套餐的钱，将 $cnt$ 加上一份套餐的钱，否则将 $cnt$ 加上 $c$。

这就是解决这道题的思想，下面是代码：

```cpp
#include <iostream>
using namespace std;
typedef long long l;
//定义2个结构体，分别用于记录学校提供的食物以及套餐。
struct food{
    l qian;//需要的钱
    bool youhui=false;//是否有优惠
};
struct food2{
    l bianhao;//编号
    l cishu;//在你的食物中出现的次数
};
int main(){
    l n;
    cin>>n;
    food arr[n];
    for(l i=0;i<n;i++){
        cin>>arr[i].qian;//输入食堂提供的食物。
    }
    l taocan;
    cin>>taocan;//输入一个套餐所需钱数。
    food2 ff[4]={};//定义ff，存储有优惠的食物。
    for(l i=0;i<4;i++){
        l x;
        cin>>x;//输入
        ff[i].bianhao=x;arr[x-1].youhui=true;//记录。
    }
    l you_food;
    cin>>you_food;//输入你需要的食物数。
    l cnt=0;
    for(l i=0;i<you_food;i++){
        l f;
        cin>>f;//输入。
        if(!arr[f-1].youhui){
            cnt+=arr[f-1].qian;//如果没有优惠，就付钱。
        }else{
        	如果有，在ff中查询并记录。
            for(l j=0;j<4;j++){
                if(ff[j].bianhao == f){
                    ff[j].cishu++;
                }
            }
        }
    }
    while(ff[0].cishu != 0 || ff[1].cishu != 0 || ff[2].cishu != 0 || ff[3].cishu != 0){
    	只要ff的cishu不空，就循环。
        l c=0;
        for(l i=0;i<4;i++){
            if(ff[i].cishu != 0){
                l tmp=ff[i].bianhao-1;
                c+=arr[tmp].qian;//加上这一项所需钱数。
                ff[i].cishu--;//出现次数-1.
            }
        }
        if(c > taocan){//如果套餐便宜，就付套餐的钱。
            cnt+=taocan;
        }else{//否则单独付
            cnt+=c;
        }
    }
    cout<<cnt;//输出
    return 0;
}


```


---

## 作者：Astatinear (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7791)

### 思路

题目大意就是说你现在要买一些食品，如果你现在买的食品是套餐中的，且单买价比套餐价要高，那就会把买单个改为买套餐，求买食品需要花费多少钱。

很简单,直接根据规则进行模拟即可。

首先我们先把要买的东西的食品编号用桶的思想储存起来，假设编号为 $x$，我们定义以为数组 $buy_i$ 表示在要买的食品中，食品编号为    $i$ 的食品要买多少个。

然后我们不看别的，只看套餐里的东西。先一直循环，然后枚举套餐里的食品编号，接着一份一份的来看。假设现在枚举到了套餐里的第 $i$ 个物品。如果 $buy_{p_i}=0$ 即要买东西中没有 $p_i$ 则此时什么也不用做。如果 $buy_{p_i}>0$ 即要买的东西中有 $p_i$ 则我们先定义一个变量 $tot$ 来记录套餐和要买的东西中单买一份的总价格。则此时 $tot \gets tot+c_{p_i}$。最后，如果 $tot>x$ 即单买价格超过了套餐价格，设最终答案为 $ans$ 则此时 $ans\gets ans+x$。并且将单买中选过的食品 $i$ 的 $buy_i\gets buy_i-1$。如果 $x \ge tot$ 则什么也不用做，直接跳出循环。

考虑完套餐之后，接下来就只剩单买了，将剩下的要买的东西全部按照单买价进行购买即可。

最后直接输出 $ans$ 即可。

### 代码
```cpp
#include<iostream>
using namespace std;
int k,c[25];
int x,p[5];
int t,s[25];
int buy[25];
int ans;
int main()
{
    //输入
    cin>>k;
    for(int i=1;i<=k;++i)
    {
        cin>>c[i];
    }
    cin>>x>>p[1]>>p[2]>>p[3]>>p[4];
    cin>>t;
    for(int i=1;i<=t;++i)
    {
        cin>>s[i];
        buy[s[i]]++;//桶
    }
    //处理套餐中要买的东西
    while(1)
    {
        int tot=0;
        for(int i=1;i<=4;++i)
        {
            tot+=min(buy[p[i]],1)*c[p[i]];
        }
        if(tot>x)
        {
            for(int i=1;i<=4;++i)
            {
                buy[p[i]]=max(buy[p[i]]-1,0);
            }
            ans+=x;
        }
        else
        {
            break;
        }
    }
    //剩下的东西进行单买
    for(int i=1;i<=k;++i)
    {
        ans+=buy[i]*c[i];
    }
    //输出
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：ForeverCC (赞：1)

分类讨论，讨论不买套餐的情况，和买套餐的情况。

因为可以买多个套餐，而且 $t \le 20$，所以可以直接暴力讨论买若干套餐的情况。如果套餐里有且不用单独买的次数不为 $0$，就将套餐里的这道菜不用单独买的次数减一，不然单独买。

统计最大值输出即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[25],x,b[25],c[25],m,ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&x);
	for(int i=1;i<=4;i++)
		scanf("%d",&b[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&c[i]);
		ans+=a[c[i]];//统计不买套餐的情况
	}
	for(int i=1;i<=20;i++){//统计买i个套餐的情况
		int sum=i*x;
		int s[25]={0};
		s[b[1]]=i;//每道菜可以不买i次
		s[b[2]]=i;
		s[b[3]]=i;
		s[b[4]]=i;
		for(int j=1;j<=m;j++){
			if(s[c[j]])s[c[j]]--;
			else sum+=a[c[j]];
		}
		ans=min(ans,sum);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Da_un (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P7791)
题意很明确，就是要注意可以制造多个套餐来使价格更便宜。

## 思路
一直循环，每次都找在套餐里面的餐品，每一次枚举完餐品记录价格后去和套餐价格比较，如果比套餐价格大，就加上套餐价格接着循环，如果不是，就说明剩下的餐品没法优惠了，直接跳出循环。最后加上余下的餐品所对应的价钱即可。

因为数据规模比较小，所以用桶排序会更好操作一些。另外，本题细节比较多，还是要认真的理清思路之后去写代码。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline int read()//快读
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
int n,c[100],x,p[5],t,s[100];
int f[10000],vis[10000],a[10000],b[10000];
//f数组存相同餐品出现数量
//vis数组判断是否在套餐中
//a数组为了便于f数组的统计
//b数组用来标记使相同餐品在同一次套餐中只出现一次
int ans,sum,q;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		c[i]=read();
	x=read();
	for(int i=1;i<=4;i++)
		p[i]=read(),a[p[i]]=1;
	t=read();
	for(int i=1;i<=t;i++){
		s[i]=read();
		if(a[s[i]])
			f[s[i]]++;//统计
	}
	for(int i=1;i<=t;i++)
		if(f[s[i]]!=0)
			vis[s[i]]=1;//标记
	while(1){
		memset(b,0,sizeof(b));//每一次循环都要统计，所以每次都初始化
		for(int i=1;i<=t;i++){
			if(f[s[i]]!=0&&vis[s[i]]&&!b[s[i]]){//是套餐中的且还没出现
				ans+=c[s[i]];
				f[s[i]]--;
				b[s[i]]=1;//记录
			}
		}
		if(ans>x) ans=x,q+=ans;//可以优惠
		else{
			q+=ans;//别忘了加上
			break;
		}
		ans=0;//初始化
	}
	for(int i=1;i<=t;i++)
		if(!vis[s[i]])
			sum+=c[s[i]];//加上不在套餐中的餐品
	for(int i=1;i<=t;i++)
		if(f[s[i]]!=0){
			while(f[s[i]]!=0){
				sum+=c[s[i]];//加上在套餐中但已构不成优惠的餐品
				f[s[i]]--;
			}
		} 
	printf("%d",q+sum);//两项累加输出
	return 0;
}
```
完结撒花~

---

## 作者：_farawaystar_ (赞：1)

#### 题意简述

1. 给出 $n$ 道菜及其价格。

2. 其中有四种不重复的菜可以组成一份套餐，价格为 $cmp$ 。

3. 给出需要买的菜品，其中，不在套餐中的需要单付，在套餐中的可以选择以整个套餐的价格支付部分套餐中的菜或每个菜都选择单付，求支付的最小金额。

4. 套餐可以不限量地买，但每个套餐中只能有同种菜品中的一道菜（坑点）。

#### 题目分析

1. 当菜品不在套餐中， $ans$ 直接加上单价。

2. 当菜品在套餐中，则在 $sum$ 数组中记录该种菜品的数量。

3. 在 $mp$ 中对于 $sum$ 数组大于 $0$ 的菜品价钱取和，与套餐价作比较，取价格更低的，即 $\min(cmp,mp)$ ，计入 $ans$ ，并重复。

代码：

```cpp
#include<iostream>
using namespace std;
int n,pr[25],cmp,p1,p2,p3,p4,t,wb[25],ap,mp,ans,sum[25];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>pr[i];
	cin>>cmp>>p1>>p2>>p3>>p4>>t;
	for(int i=1;i<=t;i++){
		cin>>wb[i];
		if(p1==wb[i]||p2==wb[i]||p3==wb[i]||p4==wb[i])
			sum[wb[i]]++;
		else ap+=pr[wb[i]];
	}
	for(int i=1;i<=t;i++){
		mp=0;
		for(int j=1;j<=n;j++)
			if(sum[j]>0){
				mp+=pr[j];
				sum[j]--;
			}
		ans+=min(mp,cmp);
	}
	cout<<ans+ap;
	return 0;
}

```

---

## 作者：CPPfive (赞：0)

## 题目分析

我们要计算出最小的价格。那么对于套餐外的菜品，我们是无需关注的，因为它们的价格不会改变。而对于套餐内的菜品，我们很显然要用贪心的方法去决定是否要购买套餐，即：我们循环去判断是否要购买套餐，在每一次购买套餐时，我们去看套餐内的四个菜品是否买完了，如果没有买完，那就在这次套餐内购买，并把对应菜品的需要购买数减一，然后把这一次的**实际购买菜品的原来价格**的和与套餐的价格比较，如果比套餐还便宜那就停止循环。

如果看文字描述没看明白，可以看一看代码，里面有注释。
```cpp
//洛谷P7791 

#include <bits/stdc++.h>
using namespace std;
const int MAXN=22;
int cnt[MAXN],cost[MAXN],suit[MAXN],cs,K,T;
//cnt是各个菜品需要购买的数量，cost是菜品价格，suit是套餐里的四个菜品的编号（从小到大排序），cs是套餐价格 
int ans;

//cut函数用于计算套餐可以省去的价格 
int cut()
{
	int res=0;
	while(1){
		int temp=0;
		//每次遍历四个菜品，可以取就取，然后把数量减一 
		for(int i=1;i<=4;++i){
			if(cnt[suit[i]]) --cnt[suit[i]],temp+=cost[suit[i]];
		}
		temp-=cs;                 //temp是选择的菜品的原来价格之和与套餐价格的差 
		if(temp<=0) return res;   //如果不能省去价格，就停止循环 
		res+=temp;
	}
}

int main()
{
	scanf("%d",&K);
	for(int i=1;i<=K;++i){
		scanf("%d",&cost[i]);
	}
	scanf("%d",&cs);
	scanf("%d%d%d%d",&suit[1],&suit[2],&suit[3],&suit[4]);
	sort(suit+1,suit+5);
	scanf("%d",&T);
	for(int i=1;i<=T;++i){
		int t;scanf("%d",&t);++cnt[t];
		ans+=cost[t];
	}
	printf("%d\n",ans-cut());
	
	return 0;
}
```


---

## 作者：永动姬 (赞：0)

## 分析时间

- 本题主要是去枚举是否买套餐和买多少份套餐，如果要买的话需要判断是否值得买.然后就是简单的暴力枚举了.

- 数据范围：   $ 1\leqslant k,t \leqslant 20$ , $ 1\leqslant  c_i\leqslant 250$  ,$ 1\leqslant  x < 250$  , $ 1\leqslant  p_i,s_i\leqslant k$  。 由此可见，暴力是不会暴时的，那么就可以放心的暴力了。


- 可以先把套餐里包含的菜品的数量用一个数组记录下来，然后遍历一遍自己需要的菜品，若包含就在套餐里包含此菜品的数量-1，否则就加上此菜品的价格。依次枚举（从1到t）自己购买套餐的数量所得价格的最小值，在这些最小值中取最小的一个 $\Rightarrow$ 就是本题的答案.

- 图像表示：

注: _sum_ 为当前需要付的钱， _f[x]_ 为套餐包含餐品 _x_ 的数量， _a[x]_ 为餐品 _x_ 的价格

$sum=\begin{cases}sum+a[x],&f[x]=0\\sum&f[x]\ne0\end{cases}$




## 代码时间


```cpp
#include<bits/stdc++.h>
using namespace std;
int k,x,t;
int ans=101010101,sum;
int a[30],b[30],c[30];
int main(){
	std::ios::sync_with_stdio(false);//一个能加速cin,cout的东东，或许有用 
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];//菜品价格 
	}
	cin>>x;
	for(int i=1;i<=4;i++){
		cin>>b[i];//套菜的菜品 
	}
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>c[i];//你要的菜品 
	} 
	for(int i=1;i<=t;i++){//枚举买i个套餐（一共i个，买多了就会多花钱） 
		sum=i*x;//买i份套餐的价格
		int d[30]={0};
		d[b[1]]=i;d[b[2]]=i;d[b[3]]=i;d[b[4]]=i;//买i份套餐，套餐内菜品的份数
		for(int j=1;j<=t;j++){//判断i份套餐是否能满足自己的需求，若不能则加上菜品的价格 
			if(d[c[j]]!=0) d[c[j]]--;//若是需求的菜品被套餐包含，就不用计算此菜品的价格，但套餐里此菜品的数量要-1
			else sum+=a[c[j]];//套餐不含此菜品，得单独买
		} 
		ans=min(ans,sum);//更新最小值 
	}
	cout<<ans; 
	return 0;
}

```


### 求管理大大通过

---


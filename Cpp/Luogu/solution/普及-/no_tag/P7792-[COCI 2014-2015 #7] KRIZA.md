# [COCI 2014/2015 #7] KRIZA

## 题目背景

某国的经济状况很糟糕，冰冻灾害袭击了整个国家，人们正在失去工作。然而，Sisyphus，本题的主角，已经为自己找到了一份新工作。从下周一开始，Sisyphus 将成为一家酒店的助理锁匠。当然，他首先需要向锁匠头子展示他的开锁能力。

## 题目描述

这就是锁匠头子给了 Sisyphus $n$ 把钥匙，放在一个大圆坠子上，蒙住他的眼睛并把他带进一个大房间的原因。这个房间里恰好有 $n$ 扇锁着的门，用 $1$ 到 $n$ 的数字表示。吊坠上的每一把钥匙都正好能打开一扇门，其中第 $i$ 把钥匙能打开第 $v_i$ 扇门。Sisyphus 的工作是将每一扇门解锁并再次上锁。他这样做的方式是沿着墙壁移动，不改变方向，直到他到达一扇门。当他走到一扇门前时，他尝试用从当前左数第一把钥匙来解锁。如果钥匙没有开锁，Sisyphus 就把它丢到最右边，并再用当前最左边的那一把钥匙再试一次，重复这个过程，直到他找到正确的钥匙为止。当他所有的门解锁时，他的工作就完成了。Sisyphus 打开的第一扇门用 $1$ 表示，下一扇用 $2$ 表示，后一扇用 $3$ 表示，以此类推......

Sisyphus 不知道的是，锁匠头子其实是在考验他的耐力，所以把他领到了一个圆形的房间。因此，Sisyphus 在解开并锁上最后一扇门后，会再次去解开并锁上第一扇门。因为他是一个勤奋而执着的家伙，Sisyphus 一直在做这项工作，几个小时都没有说一句话。只有在第 $k$ 次成功开锁和锁门后，他才开口说话："如果我知道到目前为止我把一把错误的钥匙放在门锁里有多少次就好了！" 你的任务是回答他的问题。

## 说明/提示

**【样例 2 解释】**

以下是 Sisyphus 使用钥匙的情况，其中一个标红的数字表示他把错误的钥匙放在门锁里一次：

- 对第 $1$ 扇门进行开锁和锁门操作：$\color{Red}4~2~\color{default}1~3$
- 对第 $2$ 扇门进行开锁和锁门操作：$\color{Red}1~3~4~\color{default}2$
- 对第 $3$ 扇门进行开锁和锁门操作：$\color{Red}2~1~\color{default}3~4$
- 对第 $4$ 扇门进行开锁和锁门操作：$\color{Red}3~\color{default}4~2~1$
- 对第 $1$ 扇门进行开锁和锁门操作：$\color{Red}4~2~\color{default}1~3$
- 对第 $2$ 扇门进行开锁和锁门操作：$\color{Red}1~3~4~\color{default}2$

因此他把错误的钥匙放在门锁里的次数一共是 $2+3+2+1+2+3=13$。

**【数据范围】**

对于 $40\%$ 的数据，保证 $1\leqslant n,k\leqslant 1000$。  
对于 $60\%$ 的数据，保证 $1\leqslant k\leqslant 5\times 10^4$。  
对于所有数据，$1\leqslant v_i\leqslant n\leqslant 10^5$，$1\leqslant k\leqslant 10^9$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T2 KRIZA_**，按照原题数据配置，满分 $80$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3 5
1
2
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4 6
4
2
1
3```

### 输出

```
13```

## 样例 #3

### 输入

```
10 7
1
3
2
4
5
7
6
8
9
10```

### 输出

```
25```

# 题解

## 作者：__zfy__ (赞：8)

### 思路
有二种情况：
1. 当 $k < n$，枚举即可。

2. 当 $k > n$ 时，我们发现房间是一个大圈，这些圈又可以分成三部分：

第一组是第 $1$，$2$ 圈，直接模拟即可。

第二组是中间的统一的圈。

第三组是剩下的那或多或少的半圈。

代码就不附了。

---

## 作者：Sirkey (赞：6)

考试考到了，只得了 $ 50 $，忏悔一下。

我们可以 $ O( 1 ) $ 的求出开当前这个门所需要的时间：

`
ans1+=(a[i]+n-past1)%n 
` 

得记录一下前一个的状态，这里用的是 $ past $。

我们可以说这是一个周期问题。但是这个循坏是特殊的，第一次和后来的是不相同的，所以我们要求两次。

区别在于，第一次的开始状态是 $ 1 $，后面会变成  ` a[n] `。

我们用 $ ans1 $ 记录首轮，到 $ t $ 次就退出。

另为用 $ ans $ 数组记录其他次数，用数组方便我们求不在整数的情况。


```cpp
	for(int i=1; i<=n; i++) {
		ans[i]=ans[i-1]+(a[i]-past+n)%n;
		ans1+=(a[i]+n-past1)%n;
		past=a[i],past1=a[i];
		if(i==t) {
			cout<<ans1;
			return 0;
		}
	}
```
然后求一下，后面的轮数，加在 $ ans1 $ 上就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX=1e5+10;
long long n,t,a[MX],past=1,past1,ans[MX],ans1;
void init() {
	cin>>n>>t;
	for(int i=1; i<=n; i++) {
		int kkk;
		cin>>kkk;
		a[kkk]=i;
	}
}
int main() {
	init();
	past=a[n],past1=1;
	for(int i=1; i<=n; i++) {
		ans[i]=ans[i-1]+(a[i]-past+n)%n;
		ans1+=(a[i]+n-past1)%n;
		past=a[i],past1=a[i];
		if(i==t) {
			cout<<ans1;
			return 0;
		}
	}
	int wl=t/n-1;
	ans1+=wl*ans[n]+ans[t%n];
	cout<<ans1;
	return 0;
}
```
——end——

---

## 作者：_Haoomff_ (赞：6)

枚举 $n$ 个门的试错个数，我们来分类讨论：
+ #### 当 $k<n$ 时

直接枚举，因为 $n$ 的最大的取值也就只有 $100000(10^5)$。
+ #### 当 $k\ge n$ 时

枚举完 $n$ 个门的试错个数后，建立一个数组，里面存前 $i$ 个门的试错个数。

此时，用 $k$ 除以 $n$ 的答案就是会有多少个将门开完的区间。

那么，现在还会剩下一些数。没错，就是 $k$ 除以 $n$ 的余数。

接下来，再用我们之前得到的答案加上数组中 $k \bmod\ n$ 位置上的数。

------------

本篇题解不会给出代码，部分人士不满意可以差评。本篇题解只是想作为第一次橙名的最后一篇题解。望管理过审。

另外，突然想起一点：不开 long long 见祖宗！！！

---

## 作者：AKPC (赞：4)

### 思路
首先 $1 \leq k \leq 10^9$，并不能打暴力，否则你会获得 $48$ 分的好运。

观察一种操作（从 $x$ 至 $y$）会有重复很多次，我们把每 $n$ 次操作设为一轮，你会发现除了第一次操作，其他操作组合重复了 $\dfrac{(k-1)}{n}$ 向下取整次。所以我们记录一轮操作（注意从第二次到第 $n+1$ 次记一轮，因为第 $1$ 次很有可能只出现一次），然后将一轮的值乘上 $\dfrac{(k-1)}{n}$ 向下取整就行。注意最后还要暴力计算剩余部分和第 $1$ 次操作部分。

然后我觉得很对，一交上去 [只有 $48$ 分](https://www.luogu.com.cn/record/105332185)，看了下数据范围，我才知道我忘记开 long long 了！所以不开 long long 见祖宗。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,k,a[100001],b[100001],tip=1,ans=0,awa=0,now=1;
//ans 是答案，awa 是一轮的总和，tip 是现在面前的门号，now 是换下一扇门时现在拿到的钥匙
int ln(int x,int y){//求距离，也就是从第 x 把钥匙开始需要多少次换到 y
	if (x<=y) return y-x;
	return n-x+y;
}
signed main(){
	cin>>n>>k;
	for (int i=1;i<=n;i++) cin>>a[i],b[a[i]]=i;
	ans+=ln(1,b[1]),awa=ans,now=b[1];
	for (int i=2;i<=n+1;i++){
		now=awa%n+1;
		tip=tip%n+1;
		awa+=ln(now,b[tip]);
	}
	awa-=ans;ans+=(k-1)/n*awa;
	for (int i=1;i<=(k-1)%n;i++){
		now=ans%n+1;
		tip=tip%n+1;
		ans+=ln(now,b[tip]);
	}
    cout<<ans;
	return 0;
}
```


---

## 作者：FHenryh (赞：3)


# 题目概述：
[题目传送门](https://www.luogu.com.cn/problem/P7792)

Sisyphus 在一个圆形的房间里，房间内有 $n$ 扇锁着的门，他有 $n$ 把钥匙，其中第 $i$ 把钥匙对应第 $v_i$ 扇门，遇到不匹配的钥匙就放到钥匙扣的另一边。他需要解锁所有的门。Sisyphus 沿着门编号顺序，每次到一扇门前就找到第 $i$ 把钥匙尝试打开门，直到找到正确的钥匙，然后把门再锁上，一直到他第 $k$ 次成功解锁为止。

# 思路：

看到此题，第一反应肯定是暴力，模拟到每一扇门前尝试每一把钥匙，这样的时间复杂度为 $O(nk)$，肯定过不了，提交只有 $24pts$。

这时候我们可以想想**优化**。

我们不难发现，对于尝试每一圈的 $n$ 扇门，其实这是一个循环的过程，所以我们只需要遍历一圈即可。

我们可以用 $a_i$ 表示从第 $1$ 扇门到第 $i-1$ 扇门尝试的次数，然后我们维护 $p$ 表示当前已经选到的钥匙编号，然后从 $2$ 到 $n+1$ 遍历，对于每一扇门，更新 $p$ 和 $a_i$ 的值，最后可以计算出试完第 $k$ 扇门的尝试次数，即：

> $a[n]\times(k\div n)+a[k\bmod n]$

这是什么意思？很好理解，我们已经计算出了每圈的尝试次数，我们用次数乘上圈数就是整圈的尝试次数，然后我们再加上剩余不足一圈的尝试次数，就是答案了。

Q：为什么是从 $2$ 到 $n+1$ 遍历？

A：因为 $a_i$ 表示的是从第 $1$ 扇门到第 $i-1$ 扇门尝试的次数。对于第 $i-1$ 扇门，从第 $1$ 扇门到这扇门的尝试次数等于上一次的尝试次数加上这一次的尝试次数。

## 注意两个坑：

1. 下一扇门的钥匙编号可能到**下一圈**，更新时要判断。

2. $k$ **一定要减一**，因为有 $k\mod n = 0$ 的情况，最后可能会多算。

Tips：为了方便处理，本蒟蒻把输入的 $v_i$ 改成了表示第 $i$ 扇门的钥匙编号。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long v[100001],a[100001];
int n,k;
int p,sum;
long long ans=0;//保险起见，开个long long
int main()
{
	cin>>n>>k;
	k--;
	for(int i=1;i<=n;i++) 
	{
		int x;
		cin>>x;
		v[x]=i;
	}
	ans=v[1]-1;//这句很重要：ans的初始值
	p=v[1];//p从1开始
	v[n+1]=v[1];//第n+1扇门就是第1扇门
	for(int i=2;i<=n+1;i++)
	{
		if(v[i]>=p)a[i-1]=a[i-2]+v[i]-p;
		//钥匙的编号和当前的钥匙编号在一圈内：更新a数组：上一扇门加上这扇门需要尝试的次数
		else a[i-1]=a[i-2]+v[i]+n-p;
		//否则在下一圈
		p=v[i];//更新p
	}
	ans+=a[n]*(k/n)+a[k%n];//算答案
	cout<<ans;
	return 0;
}
```

本蒟蒻第一次发题解，若有错误，还请各位dalao指出！

~~完结撒花~~

---

## 作者：BEST_CAT (赞：2)

# P7792 [COCI2014-2015#7] KRIZA 题解
## 思路

这题暴力肯定过不了，试试后会发现只能得 $24pts$，我一这题我们要~~直接放弃~~稍微**优化**一下。

我们可以用 $a_i$ 来表示从第 $1$ 扇门到第 $i-1$ 扇门尝试的次数，$p$ 表示当前已经选到的钥匙编号。

因为 $a_i$ 表示的是从第 $1$ 扇门到第 $i-1$ 扇门尝试的次数，对于第 $i-1$ 扇门，从第 $1$ 扇门到这扇门的尝试次数等于上一次的尝试次数加上这一次的尝试次数，所以我们要从 $2$ 到 $n+1$ 遍历。每一次要更新 $p$ 和 $a_i$ 的值，试完第 $k$ 扇门的尝试次数就为：$a[n]×(k÷n)+a[k \bmod n]$。

下面来解释一下为什么试完第 $k$ 扇门的尝试次数就为  $a[n]×(k÷n)+a[k \bmod n]$：

> 我们已经计算出了每圈的尝试次数，我们用次数乘上圈数就是整圈的尝试次数，然后我们再加上剩余不足一圈的尝试次数，就是答案了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int arr=100005;
ll v[arr],a[arr],n,k,p,sum,ans;
int main(){
	cin>>n>>k;
	k--;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		v[x]=i;
	}
	ans=v[1]-1;
	p=v[1];
	v[n+1]=v[1];
	for(int i=2;i<=n+1;i++){
		if(v[i]>=p){
		    a[i-1]=a[i-2]+v[i]-p;
		}
		else{
		    a[i-1]=a[i-2]+v[i]+n-p;
		}
		p=v[i];
	}
	ans+=a[n]*(k/n)+a[k%n];
	cout<<ans;
	return 0;
}
```


---

## 作者：Mu_leaf (赞：2)

## [前言]

内部模拟赛考了这题，想了快 1 个小时才 A 的。我还是太弱了。

### [思路]

暴力枚举，把开完 $1 \sim n$ 个门会试错的个数暴力枚一遍。

此时分类讨论：


------------


### 1.当 $T<n$ 时：
直接选择暴力枚举，反正 $n$ 太小了。


------------


### 2.当 $T \ge n $ 时：

枚举完 $n$ 个门的试错数后，建立一个 $res$ 数组，里面存前 $i$ 个门的试错数。

此时 $T \div n$ 就是会有多少个将门开完的区间数。

那还剩下一些数不满足一个区间怎么办，~~总不能丢掉吧~~。

考虑查询在 $res$ 数组中下标为 $T \bmod n$ 的数。

综上，最后的答案就是两数的和。

-----------

可以先自己打一遍，再看细节。

切忌直接抄袭！

# Code:

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int T,n;
int key[N],inde[N];
ll res[N],ans;
int  now=1;
int main(){
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++) scanf("%d",&key[i]),inde[key[i]]=i;//记录本门会被那把钥匙打开。
	for(int i=1;i<=n;i++){
		ans+=(inde[i]+n-now)%n;//求会试错的次数。
		now=inde[i];//储存上一次打开的门是被哪把钥匙打开的。
		if(i==T){//如果已经到了规定的开门数了，直接输出。
			printf("%lld\n",ans);
			exit(0);
		}
	}
	now=inde[n];
	for(int i=1;i<=n;i++){
		if(res[i]==now) continue;
		res[i]=res[i-1];//传递性。
		res[i]+=(inde[i]+n-now)%n;//同上。
		now=inde[i];
	}
	ans+=(ll)(T/n-1)*res[n]+res[T%n];//求和，这里减1是因为前面已经模拟过一次了。
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：ZHANGyutao123 (赞：1)

题目描述：

在一个圆形的房间里，有 $n$ 扇门，每扇门需要用唯一的一把钥匙开启。Sisyphus 有 $n$ 把钥匙，其中第 $i$ 把钥匙可以打开门 $v_i$。他可以使用这些钥匙按顺序打开所有的门然后再次回到第一扇门。当他尝试使用某把钥匙时，如果没能开启门就把这把钥匙放到最右边，并再用当前最左边的钥匙继续尝试，直到开启门为止。如果 Sisyphus 打开并锁上了第 $k$ 扇门，他希望知道之前他没有拿正确的钥匙开启门而把钥匙放入门内的总次数。

解题思路：

 先考虑当在第 $k$ 次成功开锁时，需要计算的次数，设 $p_i$ 表示钥匙 $i$   可以打开的门所处的位置，则对于每个 $k$，有

 $$
 ans_k=\sum_{i=1}^{k}{\left(p_{i-1}-p_{i}+n \right)\bmod n}
$$

即前面已经开过的门到下一次新开的门需要走过的距离，并且对 $n$ 取模。这个式子的含义是看起来从 $p_{i-1}$ 走到 $p_i$ 的距离，但实际考虑到是个环形区域，所以可以表示为 $p_{i-1}$ 到 $p_i$ 顺时针方向最短的路径再加上逆时针方向的距离。

接下来考虑当 $k>n$ 时，需要计算的次数。记录每次走完所有门后回到位置 $n$ 时，每个钥匙对应的答案（即从该钥匙到下一个出现这个钥匙的位置所需要的步数之和）。这个过程可以使用上面的公式，只需要记录 $pos_i$ 表示门 $i$ 所在的位置即可。

然后我们注意到，每经过 $n$ 扇门，Sisyphus 都会回到起点，因此答案会出现周期性。具体地，设 $T$ 是 $ans_n$ 的周期，则对于 $k>n$，有

$$
ans_k=\left\lfloor \frac{k-1}{n} \right\rfloor \cdot T+ans_{k\bmod n}
$$

时间复杂度：$O(n)$

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1e5 + 5;

int t, n, pos[MAX_N], k[MAX_N], cur_pos = 1;
long long dist_to_prev[MAX_N], total_dist;

int main() {
	
	cin >> n >> t;
	
	// 记录每个元素出现的位置
	for (int i = 1; i <= n; i++) {
		cin >> k[i];
		pos[k[i]] = i;
	}
	
	// 计算前t个元素的距离之和
	for (int i = 1; i <= n; i++) {
		// 计算当前元素到前一个元素的距离
		long long dist = (pos[i] + n - cur_pos) % n;
		total_dist += dist;
		cur_pos = pos[i];
		if (i == t) {
			// 当前元素就是第t个元素，输出距离之和并结束程序
			cout << total_dist << endl;
			return 0;
		}
	}
	
	// 计算经过多个周期后的距离
	cur_pos = pos[n];
	for (int i = 1; i <= n; i++) {
		if (dist_to_prev[i] == cur_pos) {
			// 如果当前元素与前一个元素重复，则距离也相同
			continue;
		}
		long long dist = (pos[i] + n - cur_pos) % n;
		dist_to_prev[i] = dist_to_prev[i - 1] + dist;
		cur_pos = pos[i];
	}
	int cycles = (long long)(t / n - 1);
	total_dist += (long long)cycles * dist_to_prev[n];
	total_dist += dist_to_prev[t % n];
	cout << total_dist << endl;
	
	return 0;
}

```


---

## 作者：Supernova_empire (赞：1)

这题用模拟+归纳总结。  
模拟代码（这是错解）：
```cpp
#include<math.h>
#include<stdio.h>
#define int long long
using namespace std;
int n,k;
int ans;
int keys[100005];
int door[100005]; //桶数组
signed main(){
	scanf("%lld%lld",&n,&k);
	int t=0;
	int move=1; //目前所在门的编号
	int pos=1; //目前所在钥匙的编号
	for(int i=1;i<=n;i++){
		scanf("%lld",keys+i);
		door[keys[i]]=i;
	}
	while(t<k){
		if(move==keys[pos]){
			t++;
			pos=pos%n+1; //转圈	
		}else{
			if(door[move]-pos>0) ans+=(door[move]-pos);
			else ans+=(n-(pos-door[move]));
			pos=door[move];
			t++;
		}
		move+=1;
		if(move>n) move=1;
	}
	printf("%lld",ans);
	return 0;
} 
```
不过，有一个问题。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ohko1d9x.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/mdru7vk1.png)  
TLE 三个点。
正解思路：
门所在的房间是一个大圈，转一圈的尝试次数和结束时钥匙的顺序都一样，**第一圈除外**。  
第一圈结束后，第一把钥匙一定是最后一道门的钥匙。  
可以先模拟第 $1,2$ 圈，把第二圈的尝试次数记下来，乘 $(k \div n - 1)$。  
为什么要减一呢？因为要排除第一圈。  
最后不完整的一圈，再模拟一遍。  
实现：
第一、二圈：
```cpp
while(t<n){
	if(move==keys[pos]){
		t++;
		pos=pos%n+1;			
	}else{
		if(door[move]-pos>0) ans+=(door[move]-pos);
		else ans+=(n-(pos-door[move]));
		pos=door[move];
		t++;
	}
	move+=1;
	if(move>n) move=1;
	if(t==k){ //特判，当k≤n的处理方法
		printf("%lld",ans);
		return 0;
	}
}
int temp=ans;
ans=0;
while(t<2*n){
	if(move==keys[pos]){
		t++;
		pos=pos%n+1;			
	}else{
		if(door[move]-pos>0) ans+=(door[move]-pos);
		else ans+=(n-(pos-door[move]));
		pos=door[move];
		t++;
	}
	move+=1;
	if(move>n) move=1;
	if(t==k){ //同上
		printf("%lld",ans);
		return 0;
	}
}
```
最后不完整的一圈：
```cpp
while(t<k%n){
	if(move==keys[pos]){
		t++;
		pos=pos%n+1;			
	}else{
		if(door[move]-pos>0) ans+=(door[move]-pos);
		else ans+=(n-(pos-door[move]));
		pos=door[move];
		t++;
	}
	move+=1;
	if(move>n) move=1;
}
```
[完整代码在此。](https://www.luogu.com.cn/paste/j07ovis8)

---

## 作者：small_john (赞：1)

## 前言

今天打%你赛有这道题，写篇题解纪念一下。

## 分析

一道水题。

首先，设 $a_i$ 表示第 $i$ 扇门要用的钥匙编号。那么，每当开第 $i$ 扇门之后，在最左边的钥匙一定是开第 $i$ 扇门的钥匙编号，即 $a_i$。由此开完 $n$ 扇门后钥匙编号为 $a_n$，每次都是这样，这不就是周期吗？

我们只需要统计出每个周期的试错次数即可。但第一次开完 $n$ 扇门要单独计算，因为第一次开第 $1$ 扇门的时候试的钥匙是 $1$，而不是 $a_n$。

## 具体实现

首先输入，记得把表示第 $i$ 把钥匙开的门的编号这为表示第 $i$ 扇门要用的钥匙编号。

```cpp
cin>>n>>t;
int x;
for(int i = 1;i<=n;i++)
	cin>>x,a[x] = i;//转换一下
```

处理第一次开完 $n$ 扇门的情况。

```cpp
for(int i = 1;i<=n;i++)
{
	ans+=jl(a[i]),cnt = a[i];
	if(i==t)//如果已经开了t次，退出
		return cout<<ans,0;
}
```

接下来处理周期，其中 $res_i$ 表示每个周期开第 $i$ 扇门过后的试错次数。

```cpp
for(int i = 1;i<=n;i++)
	res[i] = res[i-1]+jl(a[i]),cnt = a[i];
ans+=(t/n-1)*res[n]+res[t%n];//-1是因为第一次开完n扇门的答案已经计算过了
```

最后输出即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 1e6+5;
int n,t,cnt = 1,ans,a[N],sum,res[N];
int jl(int x)
{
	return (n-cnt+x)%n;
}
signed main()
{
	cin>>n>>t;
	int x;
	for(int i = 1;i<=n;i++)
		cin>>x,a[x] = i;//转换一下
	for(int i = 1;i<=n;i++)
	{
		ans+=jl(a[i]),cnt = a[i];
		if(i==t)//如果已经开了t次，退出
			return cout<<ans,0;
	}
	for(int i = 1;i<=n;i++)
		res[i] = res[i-1]+jl(a[i]),cnt = a[i];
	ans+=(t/n-1)*res[n]+res[t%n];//-1是因为第一次开完n扇门的答案已经计算过了
	cout<<ans;
	return 0;
}
```

---

## 作者：GWBailang (赞：0)

#### [原题传送](https://www.luogu.com.cn/problem/P7792)
两种情况，$k < n$ 和 $k > n$。

当 $k<n$ 直接模拟即可，$n$ 最大也才到 $10^5$。

当 $k>n$，~~不简单的~~找一下规律，你会发现除了第一圈和最后剩下的不完整的一圈以外，每圈操作是一样的。也就是说我们只需要模拟一下第一圈、第二圈和最后不完整的一圈的操作次数就可以了。

###### ~~好水~~

---


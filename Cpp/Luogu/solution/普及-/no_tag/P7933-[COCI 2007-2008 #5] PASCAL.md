# [COCI 2007/2008 #5] PASCAL

## 题目描述

小 Frane 已经十年级了，但是在信息课上学习 Pascal 仍然很吃力。老师写下了如下的 Pascal 程序作为家庭作业，他需要根据输入的整数 $N$ 来判断程序的输出。

```pascal
readln(N);
counter := 0;
for i := N-1 downto 1 do begin
	counter := counter + 1;
	if N mod i = 0 then break;
end;
writeln(counter); 
```

请您编写一个程序来解决这个问题。

## 说明/提示

对于 $100\%$ 的数据，$1\le N\le10^9$。

本题分值按照原比赛设置，满分 $30$ 分。

## 样例 #1

### 输入

```
1```

### 输出

```
0```

## 样例 #2

### 输入

```
10```

### 输出

```
5```

## 样例 #3

### 输入

```
27```

### 输出

```
18```

# 题解

## 作者：eEfiuys (赞：8)

题目：[P7933](https://www.luogu.com.cn/problem/P7933)

如果你会 `Pascal`，那么只需要加上头和尾就行了。然鹅，作为 `c++` 党，首先要将其翻译成 `c++` 语言。~~方式：自己理解、bdfs 等（大雾~~

好吧，先翻译成汉语：
```pascal
readln(N); //输入N
counter := 0; //counter从0开始
for i := N-1 downto 1 do begin //i从N-1循环到1，一次循环开始
	counter := counter + 1; //counter加1
	if N mod i = 0 then break; //如果N模i等于0，那么跳出循环
end; //一次循环结束
writeln(counter); //输出counter
```

注：以下的 $n$ 指 $N$，$cnt$ 指 $counter$。

翻译成 `c++` 语言就是：
```c++
#include<iostream>
using namespace std;
int main(){
    int n,cnt=0;
    cin>>n;
    for(int i=n-1;i>=1;i--){
        cnt++;
        if(n%i==0)break;
    }
    cout<<cnt;
    return 0;
}
```

可是，$1 \leq n \leq 10^9$，显然 TLE。考虑一下，跳出循环的地方就是除 $n$ 以外最大的因数。

因此，我们从 $2$ 到 $\sqrt n$ 枚举，将范围内最小的因数记为 $m$。如果 $m > \sqrt n$，说明 $n$ 为质数，结果为 $n-1$。否则会在 $n/m$ 跳出循环，结果为 $n-\dfrac{n}{m}$。
```cpp
#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n;
    for(m=2;m*m<=n&&n%m;m++);
    if(m*m>n)cout<<n-1;
    else cout<<n-n/m;
    return 0;
}
```

---

## 作者：ImposterAnYu (赞：4)

相信很多人看到 Pascal 代码人都傻了：我学的是 C++，为啥这题还考 Pascal 啊？但是，仔细一看，你会发现：这份代码和 C++ 本质上还是区别不大的（指只学 C++ 的人还是大致能看懂一点）。

这份代码转化成 C++ 的语法格式，其实就是：

```c++
	cin >> n;
	counter = 0;
	for(i = n - 1; i >= 1; i--){
		counter = counter + 1;
		if(n % i == 0){
			break;
		}
	}
	cout<< a - 1 << endl;
	return 0;
```
看上去是不是很简单？

不就是求出 $n$ 减去它第二大的因数（注意，最大的因数永远是 $n$）吗？！

然而，当你看到数据范围后，你就会知道：这题不简单！

>$n \leq 10^9$

显然 $O(n)$ 会炸，于是我想到了判断素数的 $O(\sqrt{n})$。

判断素数一般是从 $2$ 开始枚举，一直枚举到 $\sqrt{n}$，所以我们也可以这么干。

但是这样子找出来的是 $n$ 第二小的因数（注意，最小的因数永远是 $1$），那我们该怎么办呢？

我们可以想到：在已知 $n$ 的情况下，$n$ 第 $i$ 大的因数和 $n$ 第 $i$ 小的因数是成对出现的$(1 \leq i \leq (n$ 的因数个数$))$，只要知道两个数中的一个就可以知道另一个。我们能求出第二小的那一个，就能同时求出第二大的那一个。

而我们如果设 $n$ 第二小的因数为$m$，则 $n$ 第二大的因数就是 $n -\tfrac{n}{m})$。

当然，如果一直枚举到 $\sqrt{n}$ 还没有找到答案的话，说明 $n$ 是个素数。而素数的第二大因数是 $1$，需要特判。

所以……代码你还不会写吗？！

```c++
	cin >> a;
	for(i = 2; i * i <= a; i++){
		if(a % i == 0){
			cout<< a - a / i << endl;
			return 0;
		}
	}
	cout<< a - 1 << endl;
```

# AC code
```c++
#include<bits/stdc++.h>
using namespace std;
int a,b,i,s;
int main(){
	cin >> a;
	for(i = 2; i * i <= a; i++){
		if(a % i == 0){
			cout<< a - a / i << endl;
			return 0;
		}
	}
	cout<< a - 1 << endl;
	return 0;
}
```

---

## 作者：luozhichen (赞：3)

## 题意：
题面的代码转换成 c++ 就是
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,cnt;
int main() {
	cin >> n;
	for(int i=n-1;i>=1;--i) {
		cnt++;
		if(n%i==0) break;
	}
	printf("%d",cnt);
	return 0;
}
```
跳出循环的地方就是除 $n$ 以外最大的因数。那我们就从 2 到 $\sqrt{n}$ 模拟就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x = 1;
int main() {
	cin >> n;
	for(int i = 2;i * i <= n;i++){
	    if(n % i == 0) {
			x = n / i;
			break;
		}
	}
	printf("%d",n - x);
	return 0;
}
```


---

## 作者：lmgoat (赞：3)

## 思路
虽然不会 pascal ，但还是大概看得懂题面给的这个程序。转换成 c++ 程序大概是这样:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,cnt;
int main() {
	cin>>n;
	for(int i=n-1;i>=1;--i) {
		cnt++;
		if(n%i==0) break;
	}
	printf("%d",cnt);
	return 0;
}
```
但直接交这个代码的话会 TLE ,因为 $n\le10^9$ ，而这个代码的时间复杂度是 $\Theta(n) $ 。
经分析，$cnt++$ 的次数为除了 $n$ 以外 $n$ 最大的因数。显然，除 $n$ 以外 $n$ 最大的因数等于 $n$ 除以 $n$ 除了 1 以外最小的因数, 所以只需要枚举求出这个数 $i,x=n/i$ ，答案就是 $n-x$ 。时间复杂度为 $\Theta(\sqrt{n})$ ，可以通过。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x;
int main() {
	scanf("%d",&n);
	x=1;
	for(int i=2;i*i<=n;++i)
		if(n%i==0) {
			x=n/i;
			break;
		}
	printf("%d",n-x);
	return 0;
}
```



---

## 作者：HYdroKomide (赞：3)

搬题人题解~
### 题意：
求一个数减去其最大非自身因数的差。
### 思路：
首先需要读懂 Pascal 程序的意思，但是不会 Pascal 的同学们也能猜明白，这里不再赘述。
#### **法一：**
从 $N-1$ 开始暴力枚举，直到找到一个可以被 $N$ 整除的整数。

最坏情况 $O(N)$，明显超时。开 O2 15pts，不开只有 12pts。
#### **法二：**
首先，易证得如果将 $N$ 的因数两两分组，并且使得每组的两个整数乘积等于 $N$，那么每组中必定有一个数 $\le \sqrt{N}$。

于是我们从 $2$ 开始枚举，枚举到 $\lfloor\sqrt{N}\rfloor$，碰到 $N$ 的因数跳出循环结束程序，如果没碰到就输出 $N-1$。

简单来说就是枚举产生 $N$ 最小的非 $1$ 的因数。时间复杂度 $O(\sqrt N)$。
### 程序如下：
```cpp
#include<cstdio>
#define ri register int
using namespace std;
int n,d;
int main(){
    scanf("%d",&n);
    d=n;//先赋值为n，如果没找到就可以直接输出结果了
    for(ri i=2;i*i<=n;i++)
        if(n%i==0){
            d=i;//找到了直接跳出
            break;
        }
    printf("%d\n",n-n/d);//n最大的非自身的因数即为n/d
    return 0;
}
```
### THE END

---

## 作者：zhh090409 (赞：1)

看到题，盲猜+百度走一波~
```
readln(N);//read，八成是输入
counter := 0;//百度，在pascal中，:=即为赋值
for i := N-1 downto 1 do begin//for，循环，从n-1 down（减）到1
	counter := counter + 1;//counter++
	if N mod i = 0 then break;//如果i被n整除，就跳出循环
end;//最终跳出循环的东西，c++是自动的
writeln(counter);// write，八成是输出
```
所以就可以得到c++代码。
```
#include<bits/stdc++.h>
using namespace std;
int n,counter;
int main(){
	cin>>n;
    for(int i=n-1;i>=1;i--)
    {
    	counter++;
    	if(n%i==0)
    		break;
    }
    cout<<counter;
}
```
但绝对会超时。

不难看出，从 $n-1$ 到 $\dfrac{n}{2}-1$ 的部分根本不会出现可以跳出循环的地方，因此可以直接跳过。又因为 $counter$ 只会等于 $n-i$，所以可以得到正解。
```
#include<bits/stdc++.h>
using namespace std;
int n,counter;
int main(){
	cin>>n;
	for(int i=n/2;i>=1;i--)
	{
		if(n%i==0)
		{
			cout<<n-i;
			return 0;
		}
	}
}
```

---

## 作者：int32 (赞：0)

## $\textsf{Solution}$

先把 Pascal 翻译成 C++：

```cpp
cin>>n;
cnt=0;
for(int i=n-1;i>=1;i--){
	++cnt;
	if(n%i==0) break;
}
cout<<cnt;
```

容易发现，当 $i$ 等于 $n$ 的最大非 $n$ 因数 $p$ 时推出循环，答案即为 $n-p$。

但是，$1\leq n\leq 10^9$，暴力跑明显超时，我们想办法优化。

考虑用循环找到 $n$ 最小的非 $1$ 的因数，找到后设之为 $q$，$p$ 即为 $\dfrac nq$。

注意此时我们只用循环 $2$ 至 $\sqrt n$ 即可。若在这个范围中没找到合法的 $q$，则 $n$ 为质数，$p=1$。

时间复杂度 $\mathcal{O}(\sqrt n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int q=-1;
signed main(){
	cin>>n;
	for(int i=2;i*i<=n;i++){
		if(n%i==0){
			q=i;
			break;
		}
	}
	if(q==-1) cout<<n-1;
	else{
		int p=n-n/q;
		cout<<p;
	}
	return 0;
}
```

---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7933)

~~我甚至为了这题学了 `pascal` = =~~

翻译成 `c++`：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,cnt=0;
	cin>>n;
	for(int i=n-1;i>=1;i--){
		cnt++;
		if(n%i==0){
			break;
		}
	}
	cout<<cnt;
	return 0;
}
```

直接提交会获得 $15pts$ 的好成绩（

考虑优化到 $O(\sqrt{n})$：

可以从两个方面考虑：

- $n$ 为质数，则 $2$ 到 $\lfloor\sqrt{n}\rfloor$ 不会有 $n$ 的因数，答案为 $n-1$；

- $n$ 为合数，则 $2$ 到 $\lfloor\sqrt{n}\rfloor$ 会有所有 $n$ 的因数，设最小的因数为 $m$，则答案为 $n-\dfrac{n}{m}$；

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,i;
	cin>>n;
	for(i=2;i*i<=n;i++){
		if(n%i==0){
			break;
		}
	}
	if(i*i>n){
		cout<<n-1;
	}else{
		cout<<n-n/i;
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/62297587)

---

## 作者：Jorisy (赞：0)

说实话这题还是有点难度的。（~~不是这十年级是什么鬼~~）  

---

把代码翻译一下，只有以下几种情况：
- $N$ 为 $1$，答案为 $0$；
- $N$ 为质数，答案为 $N-1$；
- $N$ 为合数，答案为 $N-\frac{N}{secN}$（$secN$ 指 $N$ 的第二大因数）。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isprime(int n)//判质数
{
	if(n<2) return false;
	for(int i=2;i<=sqrt(n);i++)
	{
		if(n%i==0) return false;
	}
	return true;
}

int main()
{
	int n;
	cin>>n;
	for(int i=2;i<=sqrt(n);i++)//合数
	{
		if(n%i==0)
		{
			cout<<n-n/i;
			return 0;
		}
	}
	if(isprime(n)) cout<<n-1;//质数
	else cout<<0;//1
	return 0;
}
```
~~盲猜题解区有人打表。~~

---


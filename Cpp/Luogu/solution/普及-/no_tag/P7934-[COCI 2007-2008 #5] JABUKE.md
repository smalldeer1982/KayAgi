# [COCI 2007/2008 #5] JABUKE

## 题目描述

给出一个三角形三个顶点的坐标以及 $N$ 个点的坐标，请您计算出这个三角形的面积和在这 $N$ 个点中，有多少个点在这个三角形内部（包含边界）。

## 说明/提示

对于 $100\%$ 的数据，$1\le N\le100$，所有坐标的 $x,y$ 均为小于 $10^3$ 的正整数。

**提示：以坐标 $(x_A,y_A)$，$(x_B,y_B)$ 与 $(x_C,y_C)$ 为顶点的三角形面积公式如下：**

$\dfrac{|x_A(y_B-y_C)+x_B(y_C-y_A)+x_C(y_A-y_B)|}{2}$

本题分值按照原比赛设置，满分 $30$ 分。

## 样例 #1

### 输入

```
1 1
5 1
3 3
4
3 1
3 2
3 3
3 4 ```

### 输出

```
4.0
3```

## 样例 #2

### 输入

```
3 2
5 4
1 6
3
2 4
3 5
4 3 ```

### 输出

```
6.0
3```

## 样例 #3

### 输入

```
2 6
5 1
7 8
5
1 4
3 5
6 4
6 5
4 7 ```

### 输出

```
15.5
2```

# 题解

## 作者：Jerrlee✅ (赞：6)

## 题意
给出一个三角形三个顶点的坐标以及 $n$ 个点 $p$ 的坐标，求这个三角形的面积和在这 $n$ 个点中，有多少个点在这个三角形内部及边界上。
## 思路
三角形面积的公式已经给出了：$\dfrac{|x_a(y_b-y_c)+x_b(y_c-y_a)+x_c(y_a-y_b)|}2$，所以我们只需要找到一种方法来检查输入的点 $p$ 是否在三角形 `ABC` 内。

有一种方法可以满足题意，就是只计算三角形的面积。更准确地说，当且只有 $p$ 在 `ABC` 内时，三角形 `ABP`、`ACP` 和 `BCP` 的面积之和等于 `ABC` 的面积。
## 代码
```cpp
#include<cstdio>
struct pt{
    int x,y; //定义点的坐标结构体
};
int area(pt a,pt b,pt c){ //计算面积
   int t=a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);
   if(t<0) return -t; //面积非负
   else return t;
}
int main(){
   pt a,b,c;
   scanf("%d%d%d%d%d%d",&a.x,&a.y,&b.x,&b.y,&c.x,&c.y);
   int n,ans=0;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      pt p;
      scanf("%d%d",&p.x,&p.y);
      if(area(a,b,p)+area(a,c,p)+area(b,c,p)==area(a,b,c)) ans++; //判断面积是否相等
   }
   printf("%.1lf\n%d\n",area(a,b,c)/2.0,ans); //代入公式
}
```
[AC记录](https://www.luogu.com.cn/record/62190792)

---

## 作者：封禁用户 (赞：6)

[PIP（Point In Polygon）问题](https://en.wikipedia.org/wiki/Point_in_polygon)，即判断一点是否在任意多边形内部。当然了，这个多边形其实并不很局限，例如一些内部镂空、部分边曲的图形亦可归为同类。  
下面给出一个鄙人随意所画的例图（画自 S Note）:   
![](https://cdn.luogu.com.cn/upload/image_hosting/pzdgjnpg.png)  
其所常规的算法大致有:  
- 光线投射算法;  
- 回转数法;  
- 角度和法;  
……  

本文将简单介绍光线投射算法。  
光线投射算法（Ray casting algorithm），大致思想为以要判断的点为端点朝某一方向引出一条射线，如果这条射线与该多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部，我们简记为奇内偶外。这个算法同样被称为奇偶规则 (Even-odd rule)。  
对于求射线与多边形交点，我们可以以需判点所引射线与多边形各边――线段一一进行判断关系，那么问题就来了，我们是需要特别考虑一些特殊情况的，因为点线位置关系复杂，一些情况如果不特别考虑是会影响判断错误的:  
1. 需判点与多边形顶点重合;  
1. 需判点在多边形边上;
1. 需判点在多边形内部，但所引射线恰好射过多边形的顶点;  

下面进行特例排除：  
排除第一点，很简单，只需将需判点坐标与多边形顶点坐标比较判断即可：  
```cpp
if((x_p==x_a && y_p==y_a) || (x_p==x_b && y_p==y_b))
{
	return 1;
}
```  
（备注：本文中，需判点的横纵坐标在代码中分别记为 `x_p`，`y_p`，在 $\LaTeX$ 中分别记为 $x_p$，$y_p$，多边形一线段边的两端点的横纵坐标在代码中分别记为 `x_a`，`y_a`，`x_b`，`y_b`，在 $\LaTeX$ 中分别记为 $x_a$，$y_a$，$x_b$，$y_b$。）  
排除第二点，我们可以计算出以需判点所引出的射线与多边形线段边的交点坐标，如交点坐标与需判点坐标同，则需判点在多边形边上。  
这里以最简单的引射线作法为例，以需判点为端点，平行于 $x$ 轴，以 $x$ 轴正方向引射线，即 $y=y_p$。设当前比较的多边形的线段边为 $y=kx+b$。联立求交，可得交点横坐标为 $\frac{y_p-b}{k}$（纵坐标当然为 $y_p$），又因为 $k= \frac{y_b-y_a}{x_b-x_a}$，$b=y_a-kx_a$（亦为 $b=y_b-kx_b$），所以需判点的横坐标为 $x_a+ \frac{(y_p-y_a)(x_b-x_a)}{y_b-y_a}$。  
```cpp
ld xxx=x_a+(y_p-y_a)*(x_b-x_a)/(y_b-y_a);
if(xxx==x_p)
{
	return 1;
}
```  
排除第三点，我们可以用到上面计算出的以需判点所引出的射线与多边形线段边的交点坐标，如交点坐标与多边形线段边任一端点坐标同，则需判点在多边形内部，但所引射线恰好射过多边形的顶点。  
```cpp
if((xxx==x_a && y_p==y_a) || (xxx==x_b && y_p==y_b))
{
	return 1;
}
```  
除特殊情况外，我们以射线穿线段边的次数奇偶判断需判点在多边形内外布即可。（穿边，即以需判点为端点所引射线夹在线段边两端点间，且交点横坐标大于需判点横坐标。）  
下面，我们来看一个例题:[P7934](https://www.luogu.com.cn/problem/P7934)  
（说为例题，实则为该问题极简版，只是该题最近为新供入洛谷主题库的，且与鄙人产生了点[渊源](https://www.luogu.com.cn/discuss/show/378313)，鄙人后又想起了 PIP 问题，故顺手解之且写下本文）  
好吧，废话少说，来看吧。第一问水算，我们直接略过，第二问才是主要，求 $n$ 个点中在一个给定三角形区域上的数量，明显为极简 PIP 问题，直接用光线投射算法即可。  
（配图一张，鄙人自用 Sketchpad 随意画的，本题样例三图示）  
![](https://cdn.luogu.com.cn/upload/image_hosting/f4solxi8.png)  
最后附上代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<iomanip>

using namespace std;
#define endl '\n'
typedef long long ll;
typedef long double ld;
ll n;
ld s;
ld x,y;
struct node{
	ld xx,yy;
}a[5];
ll ans=0;

inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

inline void write(ll x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
	{
		write(x/10);
	}
	putchar(x%10+'0');
}

ll RayCasting(ld x_p,ld y_p)
{
	ll flag=0;
	ll n=3;
	for(ll i=1;i<n;i++)
	{
		for(ll j=i+1;j<=n;j++)
		{
			//cout<<i<<" "<<j<<endl;
			ld x_a,y_a,x_b,y_b;
			x_a=a[i].xx,y_a=a[i].yy,x_b=a[j].xx,y_b=a[j].yy;
			if((x_p==x_a && y_p==y_a) || (x_p==x_b && y_p==y_b))//需判点与多边形顶点重合
			{
				//cout<<"dd"<<x_p<<" "<<y_p<<endl;
				return 1;
			}
			if(((y_a<y_p || y_a==y_p) && (y_p<y_b || y_p==y_b)) || ((y_b<y_p || y_b==y_p) && (y_p<y_a || y_p==y_a)))//所引射线夹在当前线段边两端点间
			{
				//cout<<x_p<<" "<<y_p<<" ";
				ld xxx=x_a+(y_p-y_a)*(x_b-x_a)/(y_b-y_a);//所引射线与多边形线段边交点的横坐标
				if(xxx==x_p)//需判点在多边形边上
				{
					//cout<<"bs"<<x_p<<" "<<y_p<<endl;
					return 1;
				}
				if((xxx==x_a && y_p==y_a) || (xxx==x_b && y_p==y_b))//所引射线过线段边任一端点
				{
					return 1;
				}
				if(xxx>x_p)//射线穿边
				{
					//cout<<"c"<<x_p<<" "<<y_p<<endl;
					flag=!flag;
				}
			}
		}
	}
	return flag;
}

int main()
{
	//freopen("input.in","r",stdin);
	for(ll i=1;i<=3;i++)
	{
		a[i].xx=read(),a[i].yy=read();
	}
	n=read();
	for(ll i=1;i<=n;i++)
	{
		x=read(),y=read();
		if(RayCasting(x,y))
		{
			//cout<<"yes"<<x<<" "<<y<<endl;
			ans++;
		}
	}
	s=fabs(a[1].xx*(a[2].yy-a[3].yy)+a[2].xx*(a[3].yy-a[1].yy)+a[3].xx*(a[1].yy-a[2].yy))/2.0;
	cout<<fixed<<setprecision(1)<<s<<endl;
	write((ll)(ans));
	cout<<flush;
	return 0;
}
```  
代码评测结果：  
![](https://cdn.luogu.com.cn/upload/image_hosting/dx2ghl5e.png)  
鄙文终，感谢您的阅读~

---

## 作者：kyBWE (赞：3)

### 题意简述

这个题的题意还是很清楚的，首先给出三角形三个顶点的坐标，求这个三角形的面积，然后再给出 $n$ 个点，求这 $n$ 个点中有多少个点在这个三角形内部。


------------

### 题目分析

+ 第一问：求面积

这一问还是比较好解决的，因为题目友情提供了面积计算公式对吧，所以我们可以直接套用公式。

+ 第二问：求三角形内部点的个数

关于这一问，我们不难发现，如果一个点在三角形内部，那么它与三角形三个顶点的连线会把大三角形分割成三个小三角形，这三个小三角形的面积和一定等于大三角形的面积。  
 
 举个栗子：  
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/piu5jr6y.png?x-oss-process=image/resize,m_lfit,h_1170,w_1225)  
 如图所示，$S_{ABC} = S_{ABD} + S_{ACD} + S_{BCD}$.  
 所以点 $D$ 在三角形 $ABC$ 内部。
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/isru7d74.png?x-oss-process=image/resize,m_lfit,h_1170,w_1225)  
 
 如图，当点 $D$ 在三角形 $ABC$ 外部时，显然不满足上述关系。
 

------------

 ### 代码  
 
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
struct BWE
{//用结构体来存储每个点的坐标 
	double x,y;//为了方便计算,直接用double型 
};
double area(BWE A,BWE B,BWE C)
{//用于计算三角形面积的函数(直接套用题目中的公式) 
	return abs(A.x*(B.y-C.y)+B.x*(C.y-A.y)+C.x*(A.y-B.y))/2;
}
int main()
{
	BWE A,B,C; 
	scanf("%lf%lf%lf%lf%lf%lf",&A.x,&A.y,&B.x,&B.y,&C.x,&C.y);
	double S=area(A,B,C);//计算出初始三角形的面积 
	int n,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		BWE D;
		scanf("%lf%lf",&D.x,&D.y);//读入一个新的点的坐标 
		double S1=area(A,B,D),S2=area(A,C,D),S3=area(B,C,D);
		//分别算出三个小三角形的面积 
		if(S1+S2+S3==S)//满足关系,说明点D在三角形内部 
			ans++;
	}
	printf("%.1lf\n%d",S,ans);//输出面积记得保留一位小数 
	return 0;	
}
```



------------
蒟蒻暂时荣登最优解......  

![](https://cdn.luogu.com.cn/upload/image_hosting/hik0u97a.png?x-oss-process=image/resize,m_lfit,h_1170,w_1225)

---

## 作者：FuriousC (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7934)

题目中给了三角形面积公式，在这里主要分析一下如何判断点在不在三角形内：

不难发现在三角形 $ABC$ 内随意取一个点 $p$，这个点都满足 $S_{ABP}+S_{ACP}+S_{BCP}=S_{ABC}$，

也不难发现在三角形的边上也满足，

而在三角形形外任意一个点都满足不了，因为此时 $S_{ABP}+S_{ACP}+S_{BCP}>S_{ABC}$。

所以就能得出结论了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double cal(int x1,int y1,int x2,int y2,int x3,int y3){
	return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))*1.0/2;
}
int main(){
	int x1,y1,x2,y2,x3,y3;
	cin>>x1>>y1>>x2>>y2>>x3>>y3;
	double a=cal(x1,y1,x2,y2,x3,y3);
	int n,tmp=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if(cal(x,y,x1,y1,x2,y2)+cal(x,y,x1,y1,x3,y3)+cal(x,y,x2,y2,x3,y3)<=a){
			tmp++;
		}
	}
	printf("%.1lf\n%d",a,tmp);
	return 0;
}
```


---

## 作者：Hiynyuan (赞：2)

## 题目描述
给一个三角形，问其面积并判断有几个点在其中。

## 主要思路
三角形面积公式题目有给，就不在此赘述。关于判断点是否在三角形中，我们可以这样判断：将改点与三角形三个顶点相连，判断三个小三角形的面积是否大于大三角形的面积，若大于则说明该点在三角形之外，详细解释如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/54wxvb9r.png)

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
double s(int xa,int ya,int xb,int yb,int xc,int yc)//用于计算三角形面积
{
	return abs(xa*(yb-yc)+xb*(yc-ya)+xc*(ya-yb))*1.0/2;
}
int main()
{
	int x1,y1,x2,y2,x3,y3,z=0;
	cin>>x1>>y1>>x2>>y2>>x3>>y3;
	double s1=s(x1,y1,x2,y2,x3,y3);//求出大三角形的面积
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		if(s(x,y,x1,y1,x2,y2)+s(x,y,x1,y1,x3,y3)+s(x,y,x2,y2,x3,y3)<=s1)//判断该点是否在三角形内
		{
			z++;
		}
	}
	printf("%.1lf\n",s1);
	cout<<z<<endl;
	return 0;
}
```


---

## 作者：_Z_Y_X_ (赞：1)

三角形面积非常简单题目非常善良的给了公式。

关键是如何判断点。

可以发现如果点在三角形内或边界。

那么他和其他两点围成的面积之和为整个三角形面积。


```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y,xx,yy,xxx,yyy,n,sx[105],sy[105],cnt;
double ans;
double s(int x,int y,int xx,int yy,int xxx,int yyy){
	return (double)abs(x*(yy-yyy)+xx*(yyy-y)+xxx*(y-yy))/2;
}//求面积
bool pd(int q,int a){
	if(s(x,y,xx,yy,q,a)+s(x,y,xxx,yyy,q,a)+s(xx,yy,xxx,yyy,q,a)==ans) return true;
	return false;
}
int main(){
	cin >>x>>y>>xx>>yy>>xxx>>yyy;
	ans=(double)abs(x*(yy-yyy)+xx*(yyy-y)+xxx*(y-yy))/2;
	printf("%.1lf\n",ans);
	cin >>n;
	for(int i=1;i<=n;i++){
		cin >>sx[i]>>sy[i];
		if(pd(sx[i],sy[i])==true) cnt++;
	}
	cout <<cnt;
	return 0;
}
```


---

## 作者：coolbreeze (赞：0)

求面积做法按照题意读入并计算即可。

对于计算几何类问题，此处建议在**读入各点时**将其**直接存入浮点型**，以避免运算多次强制类型转换带来的时间冗余和安全风险。

判断点是否在三角形内，题解区已有**面积法**，通过查阅资料也可以发现**向量法**的内容。

面积法容易在数据规模较大的时产生精度误差，这里介绍自己的方法。

**开了氧气，目前 luogu 测评记录 rank1**（截止 2021/11/15 ）。

**前置知识**：利用两点坐标求直线一般式系数 ， 利用平面两点坐标求斜率 ， 利用两直线一般式系数求两直线交点。（自行搜索）

由于三角形在第Ⅰ象限（题意得各点坐标为正整数），所以可以先判断点是否在三角形所在矩形内（不在则该点肯定不在三角形内）。

若待判断点在三角形所在矩形内，按点横坐标从小到大排序，则可以取最左边的点（排序后第一个点）算出  $k_{l_{1-2}}$ ， $k_{l_{1-3}}$   ,  其中$k$为直线斜率，检验待判断点与第一个点构成的直线斜率是否在 $k_{l_{1-2}}$ ， $k_{l_{1-3}}$ 之间（不在则显然在三角形外）。

若在，求 $l_{2-3}$ 交 $l_{1-point}$ 的交点横坐标，将其与待判断点横坐标比较 ，若待判断点横坐标小于等于于交点横坐标，则待判断点在三角形内。反之则不在。

求斜率时碰到为 $0$ 的情况或者直线缩成一点的情况需特判（即待判断点和排序后点 $1$ 重合）

希望大家自己画图理解，图就不画了。

代码如下，建议复制到本地 IDE 查看。

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
using namespace std;
int n , ans;
struct Point {
	int xi , yi;
	bool operator < ( const Point &a ) const{
		if( this -> xi != a.xi )
			return this -> xi < a.xi;
		else
			return this -> yi < a.yi;	
	}
}tri[4],pi;
double calculate() {
	double s = 0;
	s += 1.0 * tri[1].xi * ( 1.0 * tri[2].yi - 1.0 * tri[3].yi );
	s += 1.0 * tri[2].xi * ( 1.0 * tri[3].yi - 1.0 * tri[1].yi );
	s += 1.0 * tri[3].xi * ( 1.0 * tri[1].yi - 1.0 * tri[2].yi );
	return abs(s) / 2.0;
}
double k( Point e , Point f ) {
	return ( e.xi *1.0 - f.xi * 1.0 ) == 0 ? 0 : ( e.yi - f.yi ) * 1.0 / ( e.xi - f.xi ) * 1.0;//特判斜率
}
bool check() {
	int minx = min( tri[1].xi , min( tri[2].xi , tri[3].xi ) ) , miny = min( tri[1].yi , min( tri[2].yi , tri[3].yi ) );
	int maxx = max( tri[1].xi , max( tri[2].xi , tri[3].xi ) ) , maxy = max( tri[1].yi , max( tri[2].yi , tri[3].yi ) );
	if( pi.xi == tri[1].xi && pi.yi == tri[1].yi )
		return 1;
	if( pi.xi < minx || pi.yi < miny || pi.xi > maxx || pi.yi > maxy )
		return 0;
	if( k( tri[1] , pi ) < min( k(tri[1],tri[2]) , k(tri[1],tri[3]) ) || k( tri[1] , pi ) > max( k(tri[1],tri[2]) , k(tri[1],tri[3]) ) )
		return 0;
	double A1 = pi.yi - tri[1].yi , B1 = tri[1].xi - pi.xi , C1 = pi.xi*tri[1].yi - pi.yi*tri[1].xi;//直线一般式
	double A2 = tri[2].yi - tri[3].yi , B2 = tri[3].xi - tri[2].xi , C2 = tri[2].xi * tri[3].yi - tri[3].xi * tri[2].yi;
	double pX = ( C2 * B1 - C1 * B2 ) / ( A1 * B2 - A2 * B1);
	if( pi.xi > pX )
		return 0;
	return 1;
}
int main() {
	for( int i = 1 ; i <= 3 ; i ++ ) 
		scanf("%d%d",&tri[i].xi,&tri[i].yi);
	sort( tri + 1 , tri + 4 );
	printf("%.1lf\n",calculate());
	scanf("%d",&n);
	for( int i = 1 ; i <= n ; i ++ ) {
		scanf("%d%d",&pi.xi,&pi.yi);
		ans += check();
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：ForeverCC (赞：0)

首先定义一个函数用来求三角形面积（就是用**提示**中的公式）

如果一个点在这个大三角形内，那么这个点和大三角形任意两点组成的小三角形面积之和为大三角形的面积。

最后统计输出即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,X1,Y1,x2,y2,x3,y3,ans;
double solve(int xa,int ya,int xb,int yb,int xc,int yc){
	return abs(xa*(yb-yc)+xb*(yc-ya)+xc*(ya-yb))*1.0/2;
}
int main(){
	scanf("%d%d%d%d%d%d%d",&X1,&Y1,&x2,&y2,&x3,&y3,&n);
	while(n--){
		int x,y;
		scanf("%d%d",&x,&y);
		if(solve(x,y,X1,Y1,x2,y2)+solve(x,y,X1,Y1,x3,y3)+solve(x,y,x2,y2,x3,y3)==solve(X1,Y1,x2,y2,x3,y3))//判断是否在大三角形内。 
			ans++;
	}
	printf("%.1lf\n%d\n",solve(X1,Y1,x2,y2,x3,y3),ans);
	return 0;
}
```


---


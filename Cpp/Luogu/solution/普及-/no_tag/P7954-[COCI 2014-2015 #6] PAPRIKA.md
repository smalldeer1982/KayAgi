# [COCI 2014/2015 #6] PAPRIKA

## 题目描述

厨师 Marin 准备用 $n$ 个辣椒制作菜品。

他决定用所有年龄不超过 $x$ 天的辣椒来制作菜品 A，用其他的所有辣椒制作菜品 B。

每个辣椒都有自己的梦想，它们知道自己想要成为 A 还是 B。

但它们不知道 $x$ 的值。为了最大化实现梦想的辣椒数量，它们会采取如下策略进行交换：

- 第 1 个辣椒与第 2 个辣椒比较年龄，然后第 2 个辣椒与第 3 个辣椒比较年龄，依此类推，直到第 $n-1$ 和第 $n$ 个辣椒比较年龄。
- 若当前比较二者的编号为 $i,j$，其中**当前年龄**较大的辣椒想成为菜品 A，**当前年龄**较小的辣椒想成为菜品 B，则它们会交换年龄。$^{[1]}$

求出这样操作后实现梦想的辣椒数量。

## 说明/提示

#### 样例 1 说明

没有辣椒想成为菜品 A。

#### 样例 2 说明

每对辣椒都交换了年龄。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n,x,a_i\le 10^3$，$b_i\in\{0,1\}$。

#### 说明

按原题配置，满分 50 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task A _**PAPRIKA**_。

## 样例 #1

### 输入

```
4 5
2 0
3 0
4 0
5 0```

### 输出

```
0```

## 样例 #2

### 输入

```
5 5
3 1
2 0
13 1
2 0
10 1```

### 输出

```
5```

## 样例 #3

### 输入

```
6 10
15 1
12 1
8 0
10 1
3 0
1 1```

### 输出

```
4```

# 题解

## 作者：苏联小渣 (赞：4)

## 题目大意

1. 每个辣椒有一个年龄 $a_i$ 和想成为菜品 A 或 B 的梦想 $b_i$

1. 用年龄不超过 $x$ 的辣椒做菜品 A，用年龄超过 $x$ 的辣椒做菜品 B。

1. 相邻两个辣椒比较，$a_i>a_j,b_i=1,b_j=0$ 时交换年龄。

1. 问有多少个辣椒可以实现梦想。

## 分析

按照题意模拟即可。

读入 $a_i$ 和 $b_i$，如果 $i$ 不为 1，那么和前一个读入的比较。如果满足题目要求的交换条件则交换。

**注意：** 比较的时候要枚举哪一个辣椒年龄更大，不能只枚举一种情况。

经过一轮在线模拟交换后，再用一重循环判断有哪些达成了梦想。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x, s, a[1007], b[1007];
int main(){
	scanf ("%d%d", &n, &x);
	for (int i=1; i<=n; i++){
		scanf ("%d%d", &a[i], &b[i]);
		if (i == 1) continue;//i = 1时没法和前面的比较 
		if ((a[i] > a[i-1] && b[i] == 1 && b[i-1] == 0) || (a[i-1] > a[i] && b[i] == 0 && b[i-1] == 1)) //有两种情况 
		swap(a[i], a[i-1]);
	}
	for (int i=1; i<=n; i++){
		s += (a[i] <= x && b[i] == 1), s += (a[i] > x && b[i] == 0);//判断语句返回值为 1 或 0 
	}
	printf ("%d\n", s);
	return 0;
}
```

---

## 作者：幸存者 (赞：1)

## 思路
定义四个变量 $lasta,lastb,nowa,nowb$，分别用来存储连续两组 $a,b$，跟随输入更改，无需开数组，节省空间。

直接照题面写出判断语句，定义一个变量 $cnt$ 计数即可。

注意：最后需要再判断一次，因为循环中只判断了 $n-1$ 次。
## AC Code
```cpp
#include <iostream>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int n, x, lasta, nowa, cnt = 0;
    bool lastb, nowb;
    cin >> n >> x >> lasta >> lastb;
    for (int i = 1; i < n; i++)
    {
        cin >> nowa >> nowb;
        if ((lasta > nowa && lastb && !nowb) || (lasta < nowa && !lastb && nowb)) swap(lasta, nowa);
        if ((lasta <= x) == lastb) cnt++;
        lasta = nowa, lastb = nowb;
    }
    if ((lasta <= x) == lastb) cnt++;
    cout << cnt << endl;
    return 0;
}
```

---

## 作者：Tzs_yousa (赞：1)

~~我居然花了半个小时做一道橙题，我没好好读题。~~
## 题意
没什么难点，需要注意的就是比较的 $i$ 和 $j$ 是无序的，没有保证前者一定大于后者，只需要写一个循环写交换操作。
```cpp
(a[i] > a[i + 1] && b[i] == 1 && b[i + 1] == 0) || (a[i] < a[i + 1] && b[i] == 0 && b[i + 1] == 1)
``` 
这是是需要交换的。

剩下的按照题意模拟即可
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x, ans, a[1001], b[1001];
signed main()
{
	ios::sync_with_stdio(false);
	cin >> n >> x;
	for (int i = 1; i <= n; i++)
		cin >> a[i] >> b[i];
	for (int i = 1; i < n; i++)
	{
		if((a[i] > a[i + 1] && b[i] == 1 && b[i + 1] == 0) || (a[i] < a[i + 1] && b[i] == 0 && b[i + 1] == 1))
		{
			swap(a[i], a[i + 1]);
		}// 如果满足条件就交换 
	}
	for (int i = 1; i <= n; i++)
	{
		//cout << a[i] << " " << b[i] << endl;
		if(a[i] <= x && b[i] == 1) //判断这个辣椒会实现梦想吗 
		if(a[i] > x && b[i] == 0)ans++;
	}
	cout << ans << endl;
	return 0;
} 
```


---

## 作者：Mu_tr (赞：0)

# 题目大意：
有 $n$ 个辣椒，有些辣椒想要让自己的年龄超过 $x$，有些不想。现在让相邻的辣椒从前往后开始自行交换年龄，求多少个辣椒能够实现自己的愿望。

# 思路：
因为交换顺序是从前往后，所以不用考虑后效性的问题。由于交换操作为两个辣椒满足 $a_{i}>a_{j}$，$b_{i}=1$，$b_{j}=0$。又因为只有相邻的辣椒可以交换年龄，所以我们再加上一个限制 $abs(i-j)=1$，又因为交换是双向的，所以可以前面一个为上面的 $i$，后面一个为 $j$，也可以后面一个为 $i$，前面一个为 $j$，有点绕，但仔细理解下应该能看懂。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[1005],b[1005],ans=0;
int main(){
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
	for(int i=1;i<n;i++) if((a[i]>a[i+1]&&b[i]&&!b[i+1])||(a[i]<a[i+1]&&!b[i]&&b[i+1])) swap(a[i],a[i+1]);
	for(int i=1;i<=n;i++){
		if(a[i]<=x&&b[i]) ans++;
		if(a[i]>x&&!b[i]) ans++;	
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：ZZQF5677 (赞：0)

### 思路
这题是模拟，可以使用暴力解决。

- 读入完后，直接使用循环每个变量，如果 $a_i > a_j$ 且 $b_i = 1$ 且 $b_j = 0$ 就 $\operatorname{swap}(a_i, a_j)$。
- 再循环一遍，如果 $b_i = 1$ 且 $a_i \leq x$ 那就 $ans \gets ans +1$，否则如果 $b_i = 0$ 且 $a_i > x$ 那也 $ans \gets ans +1$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int alen, blen, n, x, op;
struct Node {
  int a, b;
} k[1005];
int main() {
  cin >> n >> x;
  for (int i = 1; i <= n; i++) {
    cin >> k[i].a >> k[i].b;
  }
  for (int i = 1; i < n; i++) {
    // k[i].a 拥有交换权。
    if (k[i].a > k[i + 1].a && k[i].b == 1 && k[i + 1].b == 0) {  //k[i] 想成为 A， k[i + 1] 想成为 B 。
      swap(k[i].a, k[i + 1].a);                                   //交换。
    }
    // k[i + 1].a 拥有交换权。
    if (k[i].a < k[i + 1].a && k[i + 1].b == 1 && k[i].b == 0) {  //k[i + 1] 想成为 A ， k[i] 想成为 B 。
      swap(k[i].a, k[i + 1].a);                                   //交换。
    }
  }
  for (int i = 1; i <= n; i++) {
    if (k[i].b == 1 && k[i].a <= x) {
      op++;
    } else if (k[i].b == 0 && k[i].a > x) {
      op++;
    }
  }
  cout << op;
  return 0;
}
```

---

## 作者：cyhyyds (赞：0)

## 思路：
按照题意模拟，用 $O(n)$ 的复杂度模拟交换年龄的过程。

最后统计符合要求的数量即可。

## 代码：
```
#include <bits/stdc++.h>

using namespace std;

const int N = 1333; 

int a[N], b[N];

int n, x;

int main () {
	cin >> n >> x;
	
	for (int i = 1; i <= n; i ++) {
		cin >> a[i] >> b[i];
	}
	
	for (int i = 1; i < n; i ++) {
		int j = i + 1; 
		
		if (a[i] > a[j] && b[i] == 1 && b[j] == 0) {
			swap (a[i], a[j]);
		}
		
		else if (a[j] > a[i] && b[j] == 1 && b[i] == 0) {
			swap (a[j], a[i]);
		}
		
		//按题意模拟交换过程。 
	}
	
	int ans = 0;
	
	for (int i = 1; i <= n; i ++) {
		if (b[i] == 1) {
			if (a[i] <= x) {
				ans ++;
			}
		}
		
		else if (b[i] == 0) {
			if (a[i] > x) {
				ans ++;
			}
		}
		
		//统计答案。 
	}
	
	cout << ans;
	
	return 0;
}
```


---


# [COCI 2014/2015 #6] NIKO

## 题目背景

2018 年，俄罗斯，第 21 届世界杯。

## 题目描述

为了方便，记 $\tt O$ 表示防守球员，$\tt V$ 表示中场球员，$\tt N$ 表示进攻球员。

教练有几个排阵方案 $O-V-N$，其中 $O,V,N$ 分别表示 $\tt O,V,N$ 的数量。当然一定有 $O+V+N=10$。

现在 $m$ 个球员都能担任 $\tt O,V,N$ 中的某几个。教练想知道他的每种排阵方案能否实现。

## 说明/提示

#### 样例 1 说明

显然教练只能使用 10-0-0。

#### 样例 2 说明

- 对于 4-4-2，可以派 $1,2,9,10$ 作为 $\tt O$，派 $4,5,6,7$ 作为 $\tt V$，派 $3,8$ 作为 $\tt N$。
- 对于 3-5-2，可以派 $4,9,10$ 作为 $\tt O$，派 $1,2,5,6$ 作为 $\tt V$，派 $3,8$ 作为 $\tt N$。
- 对于 4-3-3，不可能，因为只有 $2$ 个球员能作为 $\tt N$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10$，$10\le m\le 22$。

#### 说明

按原题配置，满分 80 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task B _**NIKO**_。

## 样例 #1

### 输入

```
2
4-4-2
10-0-0
10
O
O
O
O
O
O
O
O
ON
NO```

### 输出

```
NE
DA```

## 样例 #2

### 输入

```
3
4-4-2
3-5-2
4-3-3
11
OV
OV
OVN
OV
OV
V
V
N
O
O
O```

### 输出

```
DA
DA
NE```

# 题解

## 作者：yeshubo_qwq (赞：9)

[题面传送门](https://www.luogu.com.cn/problem/P7955)
## 题意
有 $n$ 个阵型，$m$ 个队员，每个队员都有自己能担任的位置，问：哪些阵型可以实现，哪些阵型不可以实现。
## 思路
整体思路：先按能担任的位置进行计数，然后枚举每种阵型，进行判断。

判断思路：能担任一种职位的就让他担任这个职位，能担任二种职位的，枚举给哪种职位，能担任三种职位的就进行补位。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a[11],b[11],c[11],m,d[8],cnt,flag,j,k,i2,j2,k2,t;
string s;
int main(){
    cin>>n;
    for(i=1;i<=n;i++) 
        scanf("%d-%d-%d",&a[i],&b[i],&c[i]);//用scanf读入会比cin方便 
    cin>>m;
    for(i=1;i<=m;i++){
        cin>>s;
        if(s.size()==1){//计数 
            if(s=="O")d[1]++;
            else if(s=="V")d[2]++;
            else d[3]++;
        }
        else if(s.size()==2){
            sort(s.begin(),s.end());//因为可能出现两种情况其实表示同一种（如：NO,ON），所以进行排序 
            if(s=="NO")d[4]++;
            else if(s=="NV")d[5]++;
            else if(s=="OV")d[6]++;
        }
        else d[7]++;
    }
    for(t=1;t<=n;t++){
        flag=0;
        for(i=0;i<=d[4];i++)//枚举NO几人去N 
            for(j=0;j<=d[5];j++)//枚举NV几人去N 
                for(k=0;k<=d[6];k++){//枚举OV几人去O
                    i2=d[4]-i;//NO剩下的人取O 
                    j2=d[5]-j;//NV剩下的人取V
                    k2=d[6]-k;//OV剩下的人取V
                    cnt=0;
                    if(a[t]>(d[1]+k+i2)) cnt+=a[t]-(d[1]+k+i2);//O缺几个加上 
                    if(b[t]>(d[2]+j2+k2))cnt+=b[t]-(d[2]+j2+k2);//V缺几个加上
                    if(c[t]>(d[3]+i+j))  cnt+=c[t]-(d[3]+i+j);//N缺几个加上
                    if(cnt<=d[7]) {//能担任三种职位的足够补位
						flag=1;//标记 
						goto DA;//如果可以，直接跳出 
					}
                }
        DA:;
        if(flag)printf("DA\n");else printf("NE\n");
    }
}
```


---

## 作者：Yizhixiaoyun (赞：6)

### [题目传送门](https://www.luogu.com.cn/problem/P7955)

## 题目分析

在这里我们需要分析三种球员：

1. 只能担任一种职位。让他**能干什么就干什么**。

2. 可以担任两种职位。那就**枚举哪种情况更优**。

3. 三种职位都可以担任。这样的人**看哪边少人补漏**。

有了思路之后，做这道题就很方便了。

## 贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int num=11;
int n,m,o[num],v[num],e[num];
int cnt[8];
string s;
bool flag;
int main(){
	cin>>n;
	for(register int i=1;i<=n;++i){
		scanf("%d-%d-%d",&o[i],&v[i],&e[i]);
	}
	cin>>m;
	for(register int i=1;i<=m;++i){
		cin>>s;
		if(s=="O") cnt[1]++;
		else if(s=="V") cnt[2]++;
		else if(s=="N") cnt[3]++;
		else if(s=="NO"||s=="ON") cnt[4]++;
		else if(s=="NV"||s=="VN") cnt[5]++;
		else if(s=="OV"||s=="VO") cnt[6]++;
		else cnt[7]++;
	}
	for(register int i=1;i<=n;++i){
		flag=false;
		for(register int j=0;j<=cnt[4];++j){
			for(register int k=0;k<=cnt[5];++k){
				for(register int l=0;l<=cnt[6];++l){
					int q=0;
					int s1=cnt[4]-j,s2=cnt[5]-k,s3=cnt[6]-l;
					if(o[i]>cnt[1]+s1+l) q+=o[i]-(cnt[1]+l+s1);
					if(v[i]>cnt[2]+s2+s3) q+=v[i]-(cnt[2]+s2+s3);
					if(e[i]>cnt[3]+j+k) q+=e[i]-(cnt[3]+j+k);
					if(q<=cnt[7]){
						flag=true;
						break;
					}
				}
				if(flag==true) break;
			}
			if(flag==true) break;
		}
		if(flag==true) printf("DA\n");
		else printf("NE\n");
	}
}
```

---

## 作者：alm_crax (赞：2)

 ## 题目[传送门](https://www.luogu.com.cn/problem/P7955)

某球队教练有 $n$ 个排阵方案，还有 $m$ 个球员能担任 $O$，$V$，$N$ 三种球员中的至少一种，求这些球员能不能排成教练的方案。

## 思路

把每一种球员分开来统计，只能担任一种球员的就直接担任这个职位，可以担任二种球员的枚举给哪种职位，能担任三种球员的就等待前面的担任完再进行补位。

## 代码

代码不多说

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20],b[20],c[20],m,z[10],ss,f,a2,b2,c2,len;
char ch;
string s;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
    	cin>>a[i]>>ch>>b[i]>>ch>>c[i];
	}
    cin>>m;
    for(int i=1;i<=m;i++)
	{
        cin>>s;
        if(s=="O")
		{
			z[1]++;
		}
        else if(s=="V")
		{
			z[2]++;
		}
        else if(s=="N")
		{
			z[3]++;
		}
        else if(s=="NO"||s=="ON")
		{
			z[4]++;
		}
        else if(s=="NV"||s=="VN")
		{
			z[5]++;
		}
        else if(s=="OV"||s=="VO")
		{
			z[6]++;
		}
        else
		{
			z[7]++;
		} 
    }
    for(int i=1;i<=n;i++)
	{
        f=0;
        for(int j=0;j<=z[4];j++)//枚举NO和ON的
        {
        	for(int k=0;k<=z[5];k++)//枚举NV和VN的
            {
            	for(int l=0;l<=z[6];l++)//枚举OV和VO的
				{
                    ss=0;
                    if(a[i]>z[1]+l+z[4]-j)
					{
						ss+=a[i]-z[1]-l-z[4]+j;
					}
                    if(b[i]>z[2]+k+z[6]-l)
					{
						ss+=b[i]-z[2]-k-z[6]+l;
					}
                    if(c[i]>z[3]+j+z[5]-k) 
					{
						ss+=c[i]-z[3]-j-z[5]+k;
					}
                    if(ss<=z[7])
					{
						f=1;
						break;
					}
                }
                if(f)
                {
                	break;
				}
			}
			if(f)
			{
				break;
			}
		}    
        if(f)
		{
			cout<<"DA"<<endl;
		}
		else 
		{
			cout<<"NE"<<endl;
		}
    }
    return 0;
}
```

---

## 作者：_FJX_ (赞：1)

题意：  
有 $n$ 个阵形， $m$ 各队员，问哪些阵型可以实现，哪些阵型不可以实现。

我们可以对每个队员进行分类讨论：  
1. 只能担任一种职位。就让他干这个职位  
2. 可以担任两种职位。就暴力枚举哪种情况更优。  
3. 三种职位都可以担任。哪里少人就补哪。  

想到这里，这就成为了一道水题。

_AC code_:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int o[15], v[15], e[15], c[10];
int main(){
    ios_base::sync_with_stdio(false);
	cin.tie (0);
	cout.tie (0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i ++)
	{
		char c;
		cin >> o[i] >> c >> v[i] >> c >> e[i];
	}
	int m;
	cin >> m;
	for (int i = 1; i <= m; i ++)
	{
		string s;
		cin >> s;
		if(s == "O") 
		{
			c[1]++;
		}
		else if(s == "V") 
		{
			c[2]++;
		}
		else if(s == "N") 
		{
			c[3]++;
		}
		else if(s=="NO"||s=="ON") 
		{
			c[4]++;
		}
		else if(s == "NV" || s == "VN") 
		{
			c[5]++;
		}
		else if(s == "OV" || s == "VO") 
		{
			c[6]++;
		}
		else 
		{
			c[7]++;
		}
	}
	for (int i = 1; i <= n; i ++)
	{
		bool f = 0;
		for(int j = 0; j <= c[4]; j ++)
		{
			for(int k = 0; k <= c[5]; k ++)
			{
				for(int l = 0; l <= c[6]; l ++)
				{
					int sum = 0;
					int s1 = c[4] - j, s2 = c[5] - k, s3 = c[6] - l;
					if(o[i] > c[1] + s1 + l)
					{
						sum += o[i] - (c[1] + l + s1);
					 } 
					if(v[i] > c[2] + s2 + s3)
					{
						sum += v[i] - (c[2] + s2 + s3);
					 } 
					if(e[i] > c[3] + j + k) 
					{
						sum += e[i] - (c[3] + j + k);
					}
					if(sum <= c[7])
					{
						f=1;
						break;
					}
				}
				if(f == 1) 
				{
					break;
				}
			}
			if(f == 1) 
			{
				break;
			}
		}
		if(f == 1) 
		{
			cout << "DA\n";
		}
		else 
		{
			cout << "NE\n";
		}
	}
	return 0;
}
```


---

## 作者：never_been_alive (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7955)

### 题意

有 $n$ 个阵型， $m$ 个队员，每个队员都有自己能担任的位置，问你哪些阵型可以实现，哪些阵型不可以。

### 思路
我看了其他大佬的题解，对于我这样的蒟蒻，真是太不友好了，所以，我整出了一个好懂的做法，类似于枚举、暴力。

#### 总共分三步：
1、输入所有数据。

2、进行枚举，把所有可能性记录在一个数组里。

3、将给出的阵型与所有的答案进行对比，然后输出。

~~是不是非常简单？~~

### 代码
```cpp
#include <标头.h>//非常实用的万能头文件
using namespace std;
int n, m, a[15], b[15], c[15], A, B, C;
struct v
{
	int x, y, z;
}ans[50005];
struct yaoyichen
{
	string str;
	int zs;
}qy[25];
bool cmp(yaoyichen x, yaoyichen y)
{
	return x.zs < y.zs;
}
int main()
{

	cin >> n;
	for(int i = 1; i <= n; i++)
		scanf("%d-%d-%d", &a[i], &b[i], &c[i]);//输入方案，scanf比cin方便一些
	cin >> m;
	for(int i = 1; i <= m; i++)
		cin >> qy[i].str, qy[i].zs = qy[i].str.size();//zs代表他能担任的位置总数
	sort(qy + 1, qy + 1 + n, cmp);//按担任位置数对球员升序排序
	int h = 1;
	while(qy[h].zs == 1)//分配只能担任一个位置的球员
	{
		if(qy[h].str[0] == 'O')//判断球员能当哪个类型，并累加
			A += 1;
		else
			if(qy[h].str[0] == 'V')
				B += 1;
			else
				C += 1;
		h += 1;
	}
	ans[1].x = A, ans[1].y = B, ans[1].z = C;//全部只能当一个球员组成的方案
	int cnt = 2, last = 1, u;//cnt是总方案数，last是前i-1个球员的方案数的开始位置
	for(int i = h; i <= m; i++)
	{
		u = cnt - 1;//记录一下i-1个球员的结束位置，不能用cnt，不然会死循环
		for(int j = 0; j < qy[i].zs; j++)
		{
			if(qy[i].str[j] == 'O')//判断第i个球员的第j个可选类型
				for(int k = last; k <= u; k++)//求新的方案
					ans[cnt].x = ans[k].x + 1, ans[cnt].y = ans[k].y, ans[cnt].z = ans[k].z, cnt++;
			else
				if(qy[i].str[j] == 'V')
					for(int k = last; k <= u; k++)
						ans[cnt].x = ans[k].x, ans[cnt].y = ans[k].y + 1, ans[cnt].z = ans[k].z, cnt++;
				else
					if(qy[i].str[j] == 'N')
						for(int k = last; k <= u; k++)
							ans[cnt].x = ans[k].x, ans[cnt].y = ans[k].y, ans[cnt].z = ans[k].z + 1, cnt++;
		}
		last = u;//last更新到这次开始的地方，好让下次在此基础上继续求
	}
	for(int i = 1; i <= n; i++)
	{
		bool v = 0;
		for(int j = cnt - 1; j >= last; j--)
			if(a[i] <= ans[j].x && b[i] <= ans[j].y && c[i] <= ans[j].z)//如果教练给的方案O,V,N的人数都小于等于当前方案人数，说明教练的方案是可行的
			{
				cout << "DA" << endl;
				v = 1;
				break;//退出循环，后面没必要继续找
			}
		if(!v)
			cout << "NE" << endl;
	}
	return 0;
}
```

本蒟蒻的第一篇题解，变量定义比较杂乱，还请见谅

---

## 作者：Forgotten_Dream (赞：1)

[原题传送门](https://www.luogu.com.cn/problem/P7955)

简述题意：有不同位置的成员$m$个，每个成员每个阵型中只能担任一个位置，问给出的$n$个阵型能否实现。


------------

显而易见，为了让选手 ~~物尽其用~~ 尽量发挥作用，我们应该先让位置最少的先上场。

然后剩下有两种位置的，因为数据很小，可以暴力枚举。

最后有三个位置的，哪里缺少往哪里填。



------------
思路大致与 @yeshubo dalao的一样，这里用了STL中的map作为桶来存储某位置选手数量。
```cpp
#include <bits/stdc++.h>

using namespace std;

int O[100], V[100], N[100], can[10];
map <string, int> mp;//用map存储球员能力 

int main () {

    int n, m;

    scanf ("%d", &n);

    for (int i=1; i<=n; ++i) 
        scanf ("%d-%d-%d", &O[i], &V[i], &N[i]);//按照题意格式读入 

    scanf ("%d", &m);

    for (int i=1; i<=m; ++i) {

        string s;
        cin>>s;

        sort (s.begin (), s.end ());//直接把表示相同位置的选手合起来，如OV，VO等 
        mp[s]++;//记录该位置选手数量的桶增加 
    } 

    for (int i=1; i<=n; ++i) {

        bool ok=0;//重置状态 

        for (int no_n=0; no_n<=mp["NO"]; ++no_n) {//no_n枚举NO位置上N的个数 
            for (int ov_o=0; ov_o<=mp["OV"]; ++ov_o) {//ov_o枚举OV位置上O的个数 
                for (int nv_n=0; nv_n<=mp["NV"]; ++nv_n) {//nv_n枚举NV位置上N的个数 

                    int no_o=mp["NO"]-no_n;//no_o枚举NO位置上O的个数
                    int ov_v=mp["OV"]-ov_o;//ov_o枚举OV位置上O的个数 
                    int nv_v=mp["NV"]-nv_n;//nv_v枚举NV位置上V的个数 

                    int use=mp["NOV"];//可以用于补位的有use个人 

                    use-=max (O[i]-no_o-ov_o-mp["O"], 0);//缺了就补 
                    use-=max (N[i]-no_n-nv_n-mp["N"], 0);//缺了就补
                    use-=max (V[i]-ov_v-nv_v-mp["V"], 0);//缺了就补

                    if (use>=0) {//已经够了 

                        ok=1;//标记状态 
                        break;//一种情况满足就行了 
                    }
                }
                if (ok) break;
            }
            if (ok) break;
        }

        cout<<((ok) ? "DA\n" : "NE\n");//小小的压行 
    }
    return 0;
}
```


---

## 作者：Mu_tr (赞：1)

# 题目大意
有 $n$ 种配队方案，$m$ 个队员，每种配队方案里有三个职业，三个职业的总人数加起来为 $10$ 人，每个队员有一些可以选择的职业，求哪些方案可行，哪些方案不行。

# 思路：
将每个队友可以选择的职业记录下来，直接 $dfs$ 即可，为了保证不重，我们可以强制让每次选择的队员编号比之前选择的大，之后暴力搜索有哪些可以组成的方案并打上标记，之后 $O(1)$ 回答即可。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t[4][11];
bool v[23][4],flag,ans[11][11][11];
string s;
void dfs(int k,int g,int t1,int t2,int t3){
	if(k==11){
		ans[t1][t2][t3]=1;
		return;
	}
	for(int i=g;i<=m;i++){
		for(int j=1;j<=3;j++){
			if(!v[i][j]) continue;
			if(j==1) dfs(k+1,i+1,t1+1,t2,t3);
			if(j==2) dfs(k+1,i+1,t1,t2+1,t3);
			if(j==3) dfs(k+1,i+1,t1,t2,t3+1);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d-%d-%d",&t[1][i],&t[2][i],&t[3][i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		cin>>s;
		for(int j=0;j<s.size();j++){
			if(s[j]=='O') v[i][1]=1;
			if(s[j]=='N') v[i][3]=1;
			if(s[j]=='V') v[i][2]=1;
		}
	}
	dfs(1,1,0,0,0);
	for(int i=1;i<=n;i++){
		if(ans[t[1][i]][t[2][i]][t[3][i]]) printf("DA\n");
		else printf("NE\n");
	}
	return 0;
}
```


---

## 作者：ZZQF5677 (赞：0)

### 题目意思
教练要把队伍排成 $O_i-V_i-N_i$ 的形式然后要在队伍里面找拥有分别能力的队员，如：教练要找一个中场球员出来，随便 $s_i$ 是 `V` 或者 `OV` 或者 `OVN` ，因为只要字符串中包含这个能力就行。

### 解题思路
+ 首先，因为要让具有多个能力的选手 $s_i$ 多为能力少人的那组去贡献，所以先按照 $s_i$ 的字符串长度（选手 $i$ 的能力数量）排一个序，让能力多的选手排在后面，先用完能力少的人。

+ 接下来就是遍历教练想要的每种方案 $O_i-V_i-N_i$，这时候，还要将 $O_i-V_i-N_i$ 三个数也按照大小排个序，优先需要人多的那一队，要把选手用的非常到位。排完序后，就再按照每队所需的人数在 $s$ 队伍里面找到并标记用过，如果最后每个队都凑出了就输出 `DA`，否则输出 `NE`。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
struct Node {
  int O, V, N;
} a[15];
struct Node2 {
  string s;
  bool find_w(char ch) {  //检测给选手是否有某种队员的能力。
    if (s.find(ch) != string::npos) {
      return true;
    }
    return false;
  }
} can[25];
bool vis[25];  //记录某个选手是否已经用过。
bool cmp(Node2 a, Node2 b) {
  if (a.s.size() != b.s.size()) {
    return a.s.size() < b.s.size();  //能力小的要优先。
  }
  return 0;  //掌握能力数量都相等的就不用排序了。。
}
bool check(char ch /*类型*/, int want /*目标人数*/) {  //求具备该能力并且队员没有被占用的总人数是否达标。
  int p = 0;
  for (int j = 1; j <= m; j++) {
    if (p == want) {
      return 1;
    }
    if (!vis[j] && can[j].find_w(ch)) {  //这个队员有需要的能力。
      p++;
      vis[j] = 1;  //占用这个队员。
    }
  }
  if (p == want) {
    return 1;
  } else {
    return 0;
  }
}

struct yx {
  int num;
  char ch;
};
bool cmp2(yx a, yx b) {
  return a.num > b.num;
}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    scanf("%d-%d-%d", &a[i].O, &a[i].V, &a[i].N);
  }
  cin >> m;
  for (int i = 1; i <= m; i++) {
    cin >> can[i].s;
  }
  stable_sort(can + 1, can + 1 + m, cmp);  //因为要让具有多个能力的选手多为能力少人的组去贡献，所以先排一个序。
  for (int i = 1; i <= n; i++) {
    memset(vis, false, sizeof(vis));
    yx q[4];
    q[1].ch = 'O';
    q[1].num = a[i].O;
    q[2].ch = 'V';
    q[2].num = a[i].V;
    q[3].ch = 'N';
    q[3].num = a[i].N;
    stable_sort(q + 1, q + 1 + 3, cmp2);  //还要优先需要人多的那一队。
    if (check(q[1].ch, q[1].num) && check(q[2].ch, q[2].num) && check(q[3].ch, q[3].num)) {
      printf("DA\n");
    } else {
      printf("NE\n");
    }
  }
  return 0;
}
```

---

## 作者：Lysea (赞：0)

## 题目大意

给定一些球员，他们分别能够担任若干个位置（共分三种），现在给定三个位置的 需求数量，求出能不能够分配出这种方案。

## 分析

当初一看到题目的我，脑子里并没有任何的思路。

但一看到 $m < 22$ 的数据范围，当时心里就乐了。

这不暴力，对不起这道水题啊！
 
于是我们便可以用深搜来分别枚举 $O$、$V$、$N$ 最后求出答案。

但是要注意的是 $O$、$V$、$N$ 都有可能为 $0$，所以我们在深搜前还要提前处理一下。

代码有点长，但实际代码量不到 $40$ 行，大部分都可以直接复制的。

有请我的 $140$ 行代码：

## 代码
```
#include<bits/stdc++.h>
#define M 25
using namespace std;
int sumO,sumV,sumN,cntO,cntV,cntN,n,m,O[M],V[M],N[M];
bool ans,fl,vis[M];
struct node{
    int O,V,N;
}c[M];
void dfsN(int x,int tar){
    if(cntN==c[tar].N){
        ans=true;
        return;
    }
    for(int i=1;i<=m;i++){
        if(!vis[i]&&N[i]){
            cntN++,vis[i]=true;
            dfsN(i,tar);
            cntN--,vis[i]=false;
        }
    }
}
void dfsV(int x,int tar){
    if(cntV==c[tar].V){
        for(int i=1;i<=m;i++){
            if(c[tar].N){
                if(!vis[i]&&N[i]){
                    vis[i]=true,cntN=1;
                    dfsN(i,tar);
                    vis[i]=false;
                }
            }else ans=true;
        }
        return;
    }
    for(int i=1;i<=m;i++){
        if(!vis[i]&&V[i]){
            cntV++,vis[i]=true;
            dfsV(i,tar);
            cntV--,vis[i]=false;
        }
    }
}
void dfsO(int x,int tar){
    if(cntO==c[tar].O){
        for(int i=1;i<=m;i++){
            if(c[tar].V){
                if(!vis[i]&&V[i]){
                    vis[i]=true,cntV=1;
                    dfsV(i,tar);
                    vis[i]=false;
                }
            }else if(c[tar].N){
                if(!vis[i]&&N[i]){
                    vis[i]=true,cntN=1;
                    dfsN(i,tar);
                    vis[i]=false;
                }
            }else ans=true;
        }
        return;
    }
    for(int i=1;i<=m;i++){
        if(!vis[i]&&O[i]){
            cntO++,vis[i]=true;
            dfsO(i,tar);
            cntO--,vis[i]=false;
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d-%d-%d",&c[i].O,&c[i].V,&c[i].N);
    scanf("%d\n",&m);
    for(int i=1;i<=m;i++){
        char ch=getchar();
        while(ch!='\n'){
            if(ch=='O'){
                sumO++;
                O[i]++;
            }else if(ch=='V'){
                sumV++;
                V[i]++;
            }else if(ch=='N'){
                sumN++;
                N[i]++;
            }
            ch=getchar();
        }
    }
    for(int i=1;i<=n;i++){
        if(sumO<c[i].O||sumV<c[i].V||sumN<c[i].N){
            printf("NE\n");
            continue;
        }
        memset(vis,false,sizeof vis);
        cntO=cntV=cntN=0,fl=ans=false;
        if(c[i].O){
            for(int j=1;j<=m;j++){
                if(O[j]){
                    vis[j]=true,cntO=1;
                    dfsO(j,i);
                    vis[j]=false;
                    if(ans){
                        printf("DA\n");
                        fl=true;
                        break;
                    }
                }
            }
        }else if(c[i].V){
            for(int j=1;j<=m;j++){
                if(V[j]){
                    vis[j]=true,cntV=1;
                    dfsV(j,i);
                    vis[j]=false;
                    if(ans){
                        printf("DA\n");
                        fl=true;
                        break;
                    }
                }
            }
        }else{
            for(int j=1;j<=m;j++){
                if(N[j]){
                    vis[j]=true,cntN=1;
                    dfsN(j,i);
                    vis[j]=false;
                    if(ans){
                        printf("DA\n");
                        fl=true;
                        break;
                    }
                }
            }
        }
        if(!fl) printf("NE\n");
    }
    return 0;
} 
```

---


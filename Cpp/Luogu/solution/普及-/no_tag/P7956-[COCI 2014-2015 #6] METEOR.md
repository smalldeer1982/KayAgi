# [COCI 2014/2015 #6] METEOR

## 题目描述

你需要复原一幅流星坠落后的照片。

流星坠落前的照片可以被看作是一个 $R\times S$ 的字符矩阵。$\texttt X$ 表示流星的一部分，$\texttt \#$ 表示地面，其他部分是空气，用 $\texttt .$ 表示。所有 $\texttt X$ 是联通的。

注意到流星严格位于地面上方，即存在一行 $\texttt .$ 使得 $\texttt X$ 都在它上方且 $\texttt \#$ 都在它下方。照片最后一行必定都是 $\texttt \#$。

请还原出流星落地后的照片，落地后流星与地面性质都未改变。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $3\le R,S\le 3\times 10^3$，字符矩阵中的字符都是 $\texttt{X \# .}$ 中的一种。

#### 说明

按原题配置，满分 100 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task C _**METEOR**_。

## 样例 #1

### 输入

```
5 6
.XXXX.
...X..
......
#..###
######```

### 输出

```
......
.XXXX.
...X..
#..###
######```

## 样例 #2

### 输入

```
9 7
XXX.XXX
X.XXX.X
X..X..X
X.....X
.......
.#...#.
.##.##.
.#####.
#######```

### 输出

```
.......
.......
.......
.......
XXX.XXX
X#XXX#X
X##X##X
X#####X
#######```

# 题解

## 作者：Dea_He (赞：15)

我们可以想出：陨石下降的距离是陨石与地面的最小空气距离。

那么，代码就很简单了！

``` cpp
#include<bits/stdc++.h>
using namespace std;
int r,s,a[3010],b[3010],q=3010;//r行c列
char c[3010][3010];
int main() {
	scanf("%d%d",&r,&s);
	for (int i=1;i<=r;i++) {
		for (int j=1;j<=s;j++) {
			scanf(" %c",&c[i][j]);//输入字符
			if (c[i][j]=='X') a[j]=i;//a[j]表示陨石底部在j列上的位置
			if (c[i][j]=='#' && !b[j]) b[j]=i;//b[j]表示地面顶部在j列上的位置
		}
	}
	for (int i=1;i<=s;i++) {
		if (a[i]==0) continue;//需要特判一下，如果这一列上没有陨石，就不需要求陨石到地面的距离
		q=min(b[i]-a[i]-1,q);//求陨石到地面的距离的最小值
	}
	for (int i=r;i>=1;i--) {
		for (int j=s;j>=1;j--) {
			if (c[i][j]=='X') c[i+q][j]='X',c[i][j]='.';//模拟陨石下降的过程，注意从下往上遍历，防止遍历重复，你也可以重新开一个数组存储
		} 
	}
	for (int i=1;i<=r;i++) {
		for (int j=1;j<=s;j++) {
			printf("%c",c[i][j]);//简单的输出字符
		} 
		printf("\n");
	}
    return 0;
}
```

---

## 作者：可爱的小于 (赞：5)

**该题纯属模拟。**

--------------------------
**题目大意：** 求流星落下时前的照片。

------------------------------
**思路：** 

$1.$ 先将数组赋值，用于做标记。

$2.$ 输入，记录流星与地面的距离。

$3.$ 通过循环找出距离最近的长度，**注：** 当该列没有流星时退出。

$4.$ 将流星全部往下移，空余地方用 `.` 赋值。

$5.$ 输出。

---------------------------------
**代码（请勿抄袭）：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3003],A,B,b[3003],minn=3003;
char c[3003][3003],d[3003][3003];
int main()
{
    cin >> A >> B;
    for(int i=1;i<=A;i++)
        for(int j=1;j<=B;j++)
            d[i][j]='!';
    for(int i=1;i<=A;i++)
        for(int j=1;j<=B;j++)
        {
            cin >> c[i][j];
            if(c[i][j]=='X')a[j]=i;
            if(c[i][j]=='#' && b[j]==0)b[j]=i;
        }
    for(int i=1;i<=B;i++){
		if(a[i]==0)continue; 
        minn=min(minn,b[i]-a[i]-1);
	}
    for(int i=A;i>=1;i--)
        for(int j=B;j>=1;j--)
            if(c[i][j]=='X')
                d[i+minn][j]='X',d[i][j]='.';
            else
                d[i][j]=c[i][j];
    for(int i=1;i<=B;i++)
        for(int j=1;j<=A;j++)
            cout << d[i][j]; 
    return 0;
}
```

---

## 作者：pengzy___ (赞：2)

### 题意：
给你一个流星矩阵照片，让你还原流星坠落后的照片。

### 分析：
每一块流星的下降块数就是所有流星中距离地面最小的块数。

只要暴力模拟即可 AC 。枚举每一颗流星到地面的距离，通过循环找出距离最近的长度。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[3005],b[3005],k=3005;//n,m分别为行和列 
char s[3005][3005];//s为输入的图片 
int main() 
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
        for(int j=1;j<=m;j++) 
        {
            cin>>s[i][j];
            if(s[i][j]=='X')a[j]=i;
            if(s[i][j]=='#'&&!b[j])b[j]=i;
        }
    for(int i=1;i<=m;i++) 
    {
        if(!a[i])continue;//若a[i]为0则跳过 
        k=min(b[i]-a[i]-1,k);
    }
    for(int i=n;i>=1;i--) 
        for(int j=m;j>=1;j--) 
            if(s[i][j]=='X')
            {
                s[i+k][j]='X';
                s[i][j]='.';
            }
    for(int i=1;i<=n;i++) 
    {
        for(int j=1;j<=m;j++) 
            cout<<s[i][j];
        cout<<endl;
    }
    return 0;//养成好习惯
}
```


---

## 作者：zct_sky (赞：2)

### 题意：
给你一幅流星坠落前的图片，请你还原出流星坠落后的图片。
### 思路：
1.找出每一列流星最低的位置和地面最高的位置。

2.求出每一列流星最低的位置和地面最高的位置的差最小是多少。

3.将流星向下移。

4.输出。
### Code:
```c++
#include<bits/stdc++.h>
#define ll long long
#define un unsigned
using namespace std;
int a[3010],b[3010],ans=INT_MAX,n,m; 
char ch[3010][3010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++){//输入 
	    	cin>>ch[i][j];
	    	if(ch[i][j]=='X')a[j]=i;//如果是流星，就存入a数组
			//因为要求流星最低位置，所以直接存入，越后存入位置就越低 
	    	if(ch[i][j]=='#'&&!b[j])b[j]=i;//如果是地面，就存入b数组
	    	//因为是求地面最高位置，所以如果b[i]不是0，就说明已经存入了，如果b[i]=0，则需存入 
		} 
	for(int i=1;i<=m;i++)
	    if(a[i])ans=min(ans,b[i]-a[i]-1);//如果这一列有流星(a[i]!=0) ,则求出此列流星最低位置和地面最高位置之差 
	for(int i=n;i>=1;i--)//将流星向下移 
	    for(int j=m;j>=1;j--)//注意：要倒着遍历 
	        if(ch[i][j]=='X')
	            ch[i][j]='.',ch[i+ans][j]='X';
	for(int i=1;i<=n;i++){//输出 
		for(int j=1;j<=m;j++)
		    cout<<ch[i][j];
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Perta (赞：1)

~~多次 WA 还不知道自己哪里错了~~

# 题意

你玩俄罗斯方块时手机坏了，现在你只能眼睁睁看着那个方块落下去。求方块落地时的影像。

# 思路

这个题就是一个简化版的俄罗斯方块。

对于一个大方块，我们知道当它的一个小方块落地后整个的大方块也就固定了。所以这道题可以通过找其中哪一个小方块先落地，再整体处理。

最接近地面的小方块一定最快落地（这里说的最近指的是竖直距离最近）。对于每一列，最快落地的小方块一定是这一列中纵坐标最小的那个（前提是这一列有方块），落地位置便是这一列中纵坐标最大的地面。所以我们可以枚举每一列，扫一遍找出这一列中纵坐标最小的小方块和纵坐标最大的地面，它们的竖直距离便是对于当前列的最快落地所需距离。

最后，我们再从每一列中找出这个距离的最小值，即整体最快落地的小方块即可。时间复杂度 $O(nm)$。

# 代码实现

先放完整代码，代码下方有讲解，如果理解了就可以跳过讲解了。

***

#### 完整代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+10;
int n,m,fall=N;
char a[N][N],ans[N][N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
	for(int i=1,tx,ty;i<=m;i++)
	{
		for(tx=n;tx&&a[tx][i]^'X';tx--);
		for(ty=1;ty<=n&&a[ty][i]^'#';ty++);
		if(tx) fall=min(fall,ty-tx-1);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		if(a[i][j]^'#') ans[i][j]='.';
		else ans[i][j]='#';
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='X') ans[i+fall][j]='X';
	for(int i=1;i<=n;i++) printf("%s\n",ans[i]+1);
	return 0;
}
```

***

#### 代码讲解

~~其实也没什么好讲的~~

枚举 $1\sim m$ 每一列。对于当前列：从下往上找起，找到了小方块就退出，即保证找到的方块是最低的；从上往下找起，找到了地面就退出，即保证找到的地面是最高的。如果没有找到小方块，即代码中 $tx=0$，说明这一列不影响答案，不取这一列的值；如果找到了，这一列的落地距离便是找到的小方块和地面的距离，记得减一（代码中的 $ty-tx$ 是因为数组存储与实际平面相反）。

统计答案时，只需要改变每一个小方块纵坐标即可。与上面一样，也要注意数组存储与实际平面相反，当然如果嫌麻烦的话，输入时也可以倒着输入。

统计答案有两种方法（代码方法为方法一）：

1. 正着搜，需要重建一个 $ans$ 数组。如果用原来那个数组会出现数组被覆盖的情况。
2. 倒着搜，普通下标加法即可，这样可以保证一个方块落下去后，如果有另一个方块要补上来就不会被重复覆盖，比较方便。也贴上部分代码：

~~~
for(int i=n;i;i--) for(int j=m;j;j--)
{
	if(a[i][j]=='X') a[i+fall][j]='X',a[i][j]='.';
	else if(a[i][j]=='#') a[i][j]='#';
	else a[i][j]='.';
}
~~~

***

完结撒花owo。

---

## 作者：杨岛主杨东润 (赞：0)

本题就是一道橙题的水平

这不就是俄罗斯方块吗？

本题暴力便可以AC（范围很好）

话不多说，直接说解法
## —————————————具体解法——————————————

第一步，读入每一个格子，做出标记

第二步，计算每一颗流星离地面的值的最小值

第三步，改变每一个格子的字符（具体看代码实现）

最后一步，输出现在的地图（别忘了回车！）

## —————————————代码实现——————————————
请不要抄袭哦
### 代码：
```cpp
#include<iostream>//头文件 
#include<cmath>//min要用 
using namespace std;
int a[3006],b[3006];
char c[3006][3006];
int main() 
{
	int n,m;
    cin>>n>>m;
    int minn=0xfffffff;//越大越好 
    for(int i=1;i<=n;i++){//做输入 
        for(int j=1;j<=m;j++){
            cin>>c[i][j];
            if(c[i][j]=='X'){//对于流星进行标记 
				a[j]=i;
			}
            if(c[i][j]=='#'&&b[j]==0){//对于地面进行标记 
				b[j]=i;
			}
        }
    }
    for(int i=1;i<=m;i++){//算最小值的循环 
        if(a[i]!=0){
     	   minn=min(b[i]-a[i]-1,minn);
    	}
    }
    //双重循环更改字符 
    for(int i=n;i>=1;i--){
        for(int j=m;j>=1;j--){
            if(c[i][j]=='X'){
                c[i+minn][j]='X';
                c[i][j]='.';
            }
        }
    }
    //输出 
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cout<<c[i][j];
        }
        cout<<endl;//这里不要忘了换行 
    }
    while(1){
		//防止抄袭 
	} 
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

### 思路
“给出一张流星下坠的照片，求出至少有一个位置触底时的样子。”看到题面，显然大模拟，首先 $a_i$ 表示第 $i$ 列最下方流星的位置（初始化为极小值），$b_i$ 表示第 $i$ 列最上方地面的位置。所以答案 $k$ 即为 $\min{b_i-a_i-1}$。至于更改，我们可以这样，如果 $s_{i,j}=X$，那么它下坠 $k$ 位就是 $s_{i+k,j}$，所以更改就是 $s_{i+k,j}=X,s_{i,j}=.$。

时间复杂度 $O(nm)$，空间复杂度 $O(nm)$。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e3+5;
int n,m,a[maxn],b[maxn],k=maxn;
char s[maxn][maxn];
int main(){
    memset(a,-0x3f,sizeof(a));
		scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
            cin>>s[i][j];
            if(s[i][j]=='X')
				a[j]=i;
            else if(s[i][j]=='#'&&!b[j])
				b[j]=i;
        }
    for(int i=1;i<=m;++i)
        k=min(b[i]-a[i]-1,k);
    for(int i=n;i>=1;--i)
        for(int j=m;j>=1;--j)
            if(s[i][j]=='X'){
                s[i+k][j]='X';
                s[i][j]='.';
            }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j)
			putchar(s[i][j]);
		putchar('\n');
	}
    return 0;
}
```

---

## 作者：cyhyyds (赞：0)

## 思路：
这道题就是让我们模拟俄罗斯方块的最终过程。

所以每一块流星的下降块数就是所有流星中**距离地面最小**的块数。

也就是说，记 $mndis$ 为所有流星中距离地面的距离的最小值，那么流星 $c_{i,j}$ 的最终位置就是 $c_{i+mndis,j}$。

那么我们有一个朴素的预处理：

枚举整张照片，对于每一块流星都求出它与地面的距离。

这个复杂度是 $O(RS^2)$，只有 $80$ 分。

我们需要优化时间：

显然，每一列，只需要计算最下面的那一个流星距离地面的距离。

所以我们可以倒序枚举，当当前为流星时，就计算距离，然后换到下一行。

这样的复杂度就是 $O(RS)$ 的了。

最后将照片按照最上面说的变换即可。

## 代码：
```
#include <bits/stdc++.h>

using namespace std;

const int N = 3e3 + 114;

char c[N][N];

int mndis = 1919810;

int r, s;

int main () {
	cin >> r >> s;
	
	for (int i = 1; i <= r; i ++) {
		for (int j = 1; j <= s; j ++) {
			cin >> c[i][j];
		}
	}
	
	for (int j = 1; j <= s; j ++) {//倒序 
		for (int i = r; i >= 1; i --) {
			if (c[i][j] == 'X') {
				int t = i + 1, tot = 0;
				
				while (1) {
					if (c[t][j] == '#') {
						break;
					}
					
					t ++;
					
					tot ++;
				}
				
				mndis = min (mndis, tot);
				
				//计算最小距离。 
				
				break;
			}
		}
	}
	
	//cout << mndis << endl;
	
	for (int i = r; i >= 1; i --) {
		for (int j = 1; j <= s; j ++) {
			if (c[i][j] == 'X') {
				c[i][j] = '.';
				
				c[i + mndis][j] = 'X';
				
				//变换矩阵。 
			}
		}
	}
	
	for (int i = 1; i <= r; i ++) { 
		for (int j = 1; j <= s; j ++) {
			cout << c[i][j];
		}
		
		cout << endl;
	}

	return 0;
} 
```


---

## 作者：CmsMartin (赞：0)

## 题目描述

给定一个字符矩阵，在保证 `#` 与 `X` 不重合的情况下整体向下平移 `X` ，输出平移距离最长的答案

## 思路

对于每一列，处理出最下方的 `X` 与最上方的 `#` 的距离。这样会得到 `S` 个距离，哪么最多能平移的距离即为这些距离中的最小值。

直接暴力模拟平移即可。

时间复杂度: $O(R \ \cdot \ S)$

## 代码

个人码风比较丑，写得又臭又长，见谅。


```cpp
#include <iostream>
using namespace std;

const int MAXN = 3 * 1000 + 10;
const int inf = 999999999;

int R , S;

char Map[MAXN][MAXN];

char Ans[MAXN][MAXN];

int Dist[MAXN] , Move = inf;

int main() {
    cin >> R >> S;

    for(int i = 1; i <= R; i++) {
        getchar();
        for(int j = 1; j <= S; j++) {
            Dist[j] = inf;
            Map[i][j] = getchar();
            if(Map[i][j] == '#') {
                Ans[i][j] = '#';
            }
            else Ans[i][j] = '.';
        }
    }
    
    for(int i = 1; i <= S; i++) {
        for(int j = 1; j <= R; j++) {
            if(Map[j][i] == 'X') {
                Dist[i] = 0;
                for(int k = j + 1; k <= R; k++) {
                    if(Map[k][i] == 'X') {
                        Dist[i] = 0;
                        continue;
                    }
                    if(Map[k][i] == '#') break;
                    Dist[i]++;
                }
                break;
            }
        }
    }

    for(int i = 1; i <= S; i++) {
        Move = min(Move , Dist[i]);
    }

    for(int i = 1; i <= R; i++) {
        for(int j = 1; j <= S; j++) {
            if(Map[i][j] == 'X') {
                Ans[i + Move][j] = 'X';
            }
        }
    }

    // putchar('\n');

    for(int i = 1; i <= R; i++) {
        for(int j = 1; j <= S; j++) {
            putchar(Ans[i][j]);
        }
        putchar('\n');
    }

    return 0;
}

```

---


# [COCI 2013/2014 #4] GMO

## 题目描述

给定一个由 `A` `C` `G` `T` 组成的字符串，你需要在这个字符串中插入若干个 `A` `C` `G` `T`，使字符串中包含目标字符串，并使花费的代价最少。

其中插入不同的字符花费的代价也是不同的。

## 说明/提示

**【样例解释 #1】**

可能的方法中有：`GTCAT`，花费 $10$，可以证明是最小花费。

**【数据范围】**

对于 $80\%$ 的数据，$1\le |N|,|M|\le 2000$；

对于 $100\%$ 的数据，$1\le |N|\le 10000$，$1\le |M|\le 5000$，$0\le a,c,g,v\le 1000$。

**【来源】**

本题分值按 COCI 原题设置，满分 $80$。

题目译自 [COCI2013-2014 CONTEST #4](https://hsin.hr/coci/archive/2013_2014/contest4_tasks.pdf) _**T2 GMO**_。

## 样例 #1

### 输入

```
GTA
CAT
5 7 1 3 ```

### 输出

```
10```

## 样例 #2

### 输入

```
TATA
CACA
3 0 3 0```

### 输出

```
3```

## 样例 #3

### 输入

```
TCGCGAG
TGCAG
10 10 15 15 ```

### 输出

```
25```

# 题解

## 作者：yeshubo_qwq (赞：4)

## 题意
给定一字符串，你需要在这个字符串中插入若干个字符，使字符串中包含目标字符串，并使花费的代价最少。
## 思路
暴力枚举每一个位置，用双指针求出从这个位置作为目标字符串的开头的代价，最后取最小即可。

这里为了方便，我们用数组存插入代价，数组下标对应是哪个字母的花费代价。

其他细节请看代码注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f['Z'],i,mi,t,w,s;
string s1,s2;
int main(){
    cin>>s1>>s2>>f['A']>>f['C']>>f['G']>>f['T'];
    mi=2e9;
    for(i=0;i<s1.size();i++){
        t=i;w=0;//指针初始化
		s=0;//花费初始化 
        while(w<s2.size()){
            if(s1[t]==s2[w])++t,++w;//字母相同，两根指针同时向后移
            else s+=f[s2[w++]];//字母不同，累计花费，目标字符串指针向后移
        }
        mi=min(mi,s);
    }
    cout<<mi;
    return 0; 
}
```


---

## 作者：0xFF (赞：2)

#### 题目大意


------------
给定一个原串和一个目标串，两个串中都只包含 ```A``` ```C``` ```G``` ```T``` 四个字符，需要在原串中插入一些字符使得原串中包含目标串。插入每个字符都有其固定的花费，最小化总花费。

#### 思路分析


------------
在原串中枚举每一位作为开头的情况，取最小值即可。

利用双指针实现，一个记录原串的位置，另一个记录目标串的位置。

- 若两指针所在位置字母相同，两指针同时后移一位。
- 若字母不同则累计花费，同时目标串指针后移。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>

using namespace std;
const int N = 10010;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}
char s1[N],s2[N];
int f['Z'],ans,head,pos,res;
int main(){
	scanf("%s",s1+1);
	scanf("%s",s2+1);
	f['A'] = read() , f['C'] = read() , f['G'] = read() , f['T'] = read();
	ans = 2147483647;
	int len1 = strlen(s1+1);
	int len2 = strlen(s2+1);
	for(int i=1;i<=len1;i++){
		head = i , pos = 0;
		res = 0;
		while(pos <= len2){
			if(s1[head] == s2[pos]) head++ , pos++;
			else res += f[s2[pos++]];
		}
		ans = min(ans,res);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：duchengjun (赞：1)

# 题意：
在原字符串中插入 A，C，G，T，使得原字符串中有一个子串是目标字符串，并使花费最少。

# 分析
这题是二分？暴力？DP？

$1≤∣N∣≤10000$，$1≤∣M∣≤5000$ 。

$|N|\times |M|$ 不会超时！！！

~~**暴力了**~~

枚举在哪插入目标字符串的第一个字符，外循环为 $O(|N|)$ 。

运用指针，内循环化简到 $O(|M|)$。

则时间复杂度为 $O(|N|\times|M|)$。


# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
string N,M;
int a['Z'];
signed main(){
	cin>>N;
	cin>>M;
	cin>>a['A']>>a['C']>>a['G']>>a['T'];
	int lenN=N.size(),lenM=M.size();
	int mi=0x3f3f3f3f;
	for(int t=0;t<lenN;t++){
		int i=t,j=0,ans=0;
		while(j<lenM){
			if(N[i]==M[j]){
				i++;
				j++;
			}else{
				ans+=a[M[j]];
				j++;
			}
		}
		mi=min(mi,ans);
	}
	cout<<mi;
	return 0;
}


```

~~AC 愉快~~

---

## 作者：V1mnkE (赞：0)

# 题目大意
给定一字符串，你需要在这个字符串中插入若干个字符，使字符串中包含目标字符串，并使花费的代价最少。

# 思路
由于这道题数据范围不是很大,$( n ≤ 10000 )$ ,我们可以枚举以原字符串的每一个位置为开头的代价，维护一个最小值即可。

# 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;

int a[26],mn=2147483647;//将最小值初始化为最大
string s1,s2;

int main(){
    cin>>s1>>s2;
    cin>>a[0]>>a[2]>>a['G'-65]>>a['T'-65];
    for(i=0;i<s1.size();i++){
    
        int j=0,k=i,s=0;	//指针，花费初始化 
        while(j<s2.size()){
            if(s1[k]==s2[j])k++;    //字母相同，原字符串指针后移
            else s+=a[s2[j]-65];	//字母不同，更新花费
            j++;	//目标字符串指针后移
        }
        mn=min(mn,s);	//更新最小值
        
    }
    cout<<mn;
    return 0; 
}
```

---


# [COCI 2021/2022 #3] Lampice

## 题目描述

给定一串包含 $n$ 个有特定颜色 $a_i$ 的圣诞灯和一个整数 $k$。

现要从该串中选取一段连续的圣诞灯，要求这段圣诞灯能够恰好从头到尾均分成 $k$ 小段，使得每一小段的颜色相同。

如果有符合的选取方式，请输出每一小段的颜色情况；否则输出 $-1$。

## 说明/提示

**【样例 3 解释】**

选取前四个圣诞灯 $1,5;1,5$ 或后六个圣诞灯 $2,5,6;2,5,6$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：保证存在连续 $k$ 个相同颜色的圣诞灯。
- Subtask 2（15 pts）：$k=2$。
- Subtask 3（25 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le k \le n \le 50$，$1 \le a_i \le 1000$。

**【提示与说明】**

为了处理多解问题，本题启用自行编写的 [Special Judge](https://www.luogu.com.cn/paste/xevpldj1)，欢迎大家 hack。

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf) _Task 1 Lampice_。**

**本题分值按 COCI 原题设置，满分 $50$。**

## 样例 #1

### 输入

```
8 6
10 1 1 1 1 1 1 5```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3 2
1 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 2
1 5 1 5 2 5 6 2 5 6```

### 输出

```
2
1 5```

# 题解

## 作者：yeshubo_qwq (赞：5)

## 题意
给你 $n$ 个数，要求选出一段，可以令其分成 $k$ 个完全相同的小段。

如果有符合的选取方式，请输出任意一种符合的选取方式一小段的颜色情况；否则输出  $-1$。
## 思路
这道题范围很小，只有 $50$，考虑 $O\left(n^4\right)$ 暴力枚举，寻找符合的选取方式。

具体实现：第一个循环枚举长度，第二个循环枚举起点，第三个循环枚举每一个小段，第四个循环枚举小段的第几个位置并进行判断。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,l,i,j,t,flag,a[55];
int main(){
	scanf("%d%d",&n,&k);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(l=1;l<=n/k;l++)//枚举长度
		for(i=1;i+l*k-1<=n;i++){//枚举起点
			flag=1;//默认此解符合 
			for(j=2;j<=k;j++)//枚举每一个小段
				for(t=1;t<=l;t++)//枚举小段的第几个位置
					if(a[i+t-1]!=a[i+l*(j-1)+t-1]){//与第一小段进行判断
						flag=0;//此解不符合
						break;
					}
			if(flag==1){//输出任意一种符合的选取方式 
				printf("%d\n",l);
				for(j=1;j<=l;j++)
					printf("%d ",a[i+j-1]);
				return 0;
			}
		}
	printf("-1");//无解输出-1 
	return 0;
}
```


---

## 作者：cst_123 (赞：3)

- [题目传送门](https://www.luogu.com.cn/problem/P8027)

## 题意

有 $n$ 个数，分出 $k$ 个完全相同的小段。 符合输出其中一种，不然输出 $-1$ 。

## 思路
这题 $n$ 和 $k$ 都小于50。

哦，暴力是个好东西。四重循环， $O(n^4)$ 是可过的。

第一个枚举长度，第二个是起点，第三个是每一个这样的小份，最后是小份中的第几个位置，并判断。
不理解可看一下代码，

### ~~暴力~~核心代码

```cpp
for(int i=1;i<=n/K;i++)//长度
	//K 为题目中的 k
	for(int j=1;j+i*K-1<=n;j++){//起点
		bool flag=1;//标记
		for(int k=2;k<=K;k++)
			for(int l=1;l<=i;l++)
				if(a[j+l-1]!=a[j+i*k-i+l-1]){
					flag=0;break;//不是就过
				}
		if(flag==1){
        //若可以，就输出
			printf("%lld\n",i);
			for(int k=1;k<=i;k++)
				printf("%lld ",a[j+k-1]);
			return 0;
        //如有多种符合的方式输出任意一种
		}
	}
printf("-1\n");//无解
```
------------

看懂的话就点个赞吧

---

## 作者：V1mnkE (赞：2)

## 题意
给你 $n$ 个数，要求选出一段，可以令其分成 $k$ 个完全相同的小段。

如果有符合的选取方式，请输出任意一种符合的选取方式一小段的颜色情况；否则输出 $-1$。
## 思路
首先看到数据范围，$n\leq 50$，想到 $O(n^4)$ 暴力枚举，一个一个找选取方式。

具体实现：第一重循环枚举小段的长度，第二重循环枚举选取字串的起点，第三重、第四重循环验证。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t,a[55];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int l=1;l*k<=n;l++)
		for(int i=1;i+l*k-1<=n;i++){
			bool flag=1; 
			for(int j=1;j<k;j++)for(int t=1;t<=l;t++)if(a[i-1+t]!=a[i-1+l*j+t]){flag=0;break;}
			if(flag){ 
				cout<<l<<'\n';
				for(int j=1;j<=l;j++)cout<<a[i-1+j]<<' ';
				return 0;
			}
		}
	cout<<-1;
}
```

---

## 作者：Eason_AC (赞：1)

## Content
给定一个长度为 $n$ 的数组 $[a_1,a_2,\dots,a_n]$，判断是否能选出连续的一段，使得其可以分为 $k$ 个完全相同的小段。可以的话给出一个方案，否则输出 `-1`。

**数据范围：$1\leqslant k\leqslant n\leqslant 50$，$1\leqslant a_i\leqslant 1000$。**
## Solution
数据范围明示我们这是一道水题。

我们可以枚举一个起始点 $i$ 和小段的长度 $len$，然后再计算出后面还有多少个连续的相同的小段，一旦碰到可以选出的小段数 $\geqslant k$ 的就输出方案。如果没有找到就输出 `-1`。复杂度 $\mathcal O(n^4)$，在 $n\leqslant 50$ 的范围下可以通过。
## Code
```cpp
namespace Solution {
	const int N = 57;
	int n, k, a[N];
	
	iv Main() {
		read(n, k);
		F(int, i, 1, n) read(a[i]);
		F(int, i, 1, n) F(int, len, 1, (n - i + 1) / 2) {
			int cnt = 1;
			Fo(int, j, i + len, n, len) {
				int fl = 1;
				F(int, l, 1, len) if(a[i + l - 1] != a[j + l - 1]) {fl = 0; break;}
				if(!fl) break;
				cnt++;
			}
			if(cnt >= k) {
				println(len);
				F(int, j, 1, len) printf("%d%c", a[i + j - 1], " \n"[j == len]);
				return;
			}
		}
		puts("-1");
		return;
	}
}
```

---

## 作者：封禁用户 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P8027)

# First 题意

题意是说，有一个长度为 $n$ 的序列，要在其中选择一段，使得他满足以下条件。

1.这个区间可以**平分**为 $k$ 个部分。

2.每个部分都相同。

求最短区间每部分的长度和每部分的元素。

# Second 暴力

~~说是暴力，但暴力就够了。~~

一看数据范围，$n \le 50$，漂亮，$O(n^{4})$ 都能过。

因为要求最短长度，所以可以先枚举长度，再枚举左端点，每部分和每部分的元素，共计四层循环，$O(n^{4})$。

# Third Code

```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;
#define ll long long
#define il inline

ll n, k, a[55];
int main(){
	scanf ("%lld %lld", &n, &k);
	for (int i = 1; i <= n; i++) scanf ("%lld", &a[i]);
	for (int len = 1; len * k <= n; len++){
		for (int l = 1; l + len * k - 1 <= n; l++){
			ll r = (l + len * k - 1), book = 1;
			for (int i = 0; i < k; i++)
				for (int j = 0; j < len; j++)
					if (a[l + j] != a[l + i * len + j])
						book = 0;
			if (book){
				printf ("%d\n", len);
				for (int i = l; i <= l + len - 1; i++) printf ("%lld ", a[i]);
				return 0;
			}
		}
	}
	printf ("-1");
	return 0;
}

```

---

## 作者：O3O_O3O_O3O (赞：0)

###### **~~这是灰题中比较少见的简单题……~~**

依然是经典的“解题三步骤”：

> 1. 读题
>
> 2. 思路（重点）
>
> 3. 代码

## 1.读题：

我们可以把题目转化成：给你一个数组 $a$，里面有 $n$ 个数，选出其中的一大段，平均分成 $k$ 小段，使每个小段都相同（考虑每个小段中的数的顺序）。若这个数组里面有符合这个条件的一段，那么输出每个小段的长度，并且在下一段输出这个小段长什么样；否则，输出 $-1$ 。

看了这道题的数据范围之后，我们就可以~~抛开时间复杂度~~暴力解题了。

## 2.思路：

我们可以先遍历出每一个大段，然后遍历出大段中的每一个小段，再检验每一个小段是否都相同，最后输出结果。

#### 遍历出每一个大段：

首先，若我们选出来的大段中有 $m$ 个数，那么 $m$ 必须可以被 $k$ 整除，否则无法平均分。而 $m$ 必须小于或等于 $n$ ，所以说我们可以建立起第一个框架：

```cpp
while(k*b<=n){//b：每一小段的长度，k×b=m
	b++;
}
```

我们可以算出，一共有 $n-m+1$ 个大段，而且第 $i$ 个大段的第一个数是这个数组中的第 $i$ 个数，所以说我们就可以遍历每一大段了：

```cpp
while(k*b<=n){
	for(int i=1;i<=n-k*b+1;i++){
	}
	b++;
}
```

#### 遍历出大段中的每一个小段：

我们发现，每一个小段的第一个数与下一个小段的第一个数都相距 $b$ 个数，所以说我们可以通过这个关系来遍历每一个小段：

```cpp
while(k*b<=n){
	for(int i=1;i<=n-k*b+1;i++){
		for(int j=1;j<=k*b;j+=b){
		}
	}
	b++;
}
```

#### 检验每一个小段是否都相同：

我们可以通过检测每一个小段中对应的位置上的数是否都相等来检测每一个小段是否都相同。我们可以以第一个小段中的数为标准，与后面的每一个小段都进行对比，一旦出现不相等，立刻跳出小段的循环，进入到下一个大段中的小段的遍历。

```cpp
while(k*b<=n){
	for(int i=1;i<=n-k*b+1;i++){
		for(int j=1;j<=k*b;j+=b){
			for(int l=1;l<=b;l++){
				c[l]=a[i+l-1];//c数组用来储存每个大段中的第一个小段中的数
				if(c[l]!=a[i+l+j-2]){//这里的i+l+j-2其实是i+l-1+j-1，是第k小段中的第l个数的位置
					goto next;//更加简洁地跳出循环
				}
			}
		}
		next:
			cout << "";//这里要放代码，不然会报错
	}
	b++;
}
```

#### 输出结果：

一旦有一个段符合了条件（即没有被“传送”到 $\texttt{next}$ 的位置），就可以输出结果了。若没有符合条件的，则在 $\texttt{while}$ 循环之后直接输出 $-1$。

```cpp
while(k*b<=n){
	for(int i=1;i<=n-k*b+1;i++){
		for(int j=1;j<=k*b;j+=b){
			for(int l=1;l<=b;l++){
				c[l]=a[i+l-1];
				if(c[l]!=a[i+l+j-2]){
					goto next;
				}
			}
		}
		goto exit;
		next:
			cout << "";
	}
	b++;
}
cout << -1;
return 0;//否则还会进行exit中的代码
exit:
	cout << b << endl;
	for(int i=1;i<=b;i++){
		cout << c[i] << " ";
	}
```

## 3.代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k,a[1000]={},c[1000]={},b=1,o=0,cnt=0;
	cin >> n >> k;
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	while(k*b<=n){
		for(int i=1;i<=n-k*b+1;i++){
			for(int j=1;j<=k*b;j+=b){
				for(int l=1;l<=b;l++){
				    c[l]=a[i+l-1];
					if(c[l]!=a[i+l+j-2]){
						goto next;
					} 
				}
			}
			goto exit;
			next:
				cout<<"";
		}
		b++;
	}
	cout << -1;
	return 0;
	exit:
		cout << b << endl;
		for(int i=1;i<=b;i++){
			cout << c[i] << " ";
		}
	return 0;
} 
```

---


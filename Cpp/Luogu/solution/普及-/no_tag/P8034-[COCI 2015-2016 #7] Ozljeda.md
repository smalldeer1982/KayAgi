# [COCI 2015/2016 #7] Ozljeda

## 题目描述

给定一个元素个数为 $K$ 的数列 $\{a\}$。现规定一个无穷数列 $\{x\}$ 如下：

$$x_n=\begin{cases}
a_n, & 1 \le n \le K, \cr
\bigoplus_{i=n-1}^{n-K} x_i, & n > K
\end{cases}$$

给定 $Q$ 组询问 $l_i,r_i$，求 $\bigoplus_{i=l}^r x_i$ 的值。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le K \le 10^5$，$0 \le a_i \lt 10^{18}$，$1 \le Q \le 10^6$，$1 \le l_i \le r_i \le 10^{18}$。

**【提示与说明】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [#7](https://hsin.hr/coci/archive/2015_2016/contest7_tasks.pdf) _Task 3 Ozljeda_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
4
1 3 5 7
3
2 2
2 5
1 5```

### 输出

```
3
1
0```

## 样例 #2

### 输入

```
5
3 3 4 3 2
4
1 2
1 3
5 6
7 9```

### 输出

```
0
4
7
4```

# 题解

## 作者：langni (赞：5)

思路：可以利用前缀和来解决。

因为 $x \oplus 0 = x$ , $x \oplus x = 0$ ,

所以 $\bigoplus_{i=l}^r x_i = (\bigoplus_{i=1}^{l-1} x_i) \oplus (\bigoplus_{i=1}^{r} x_i)$ 。

有了这个公式，这道题就可以轻松解决。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k,a[100010],q,l,r;
int main(){
	cin>>k;
	for (int i=1;i<=k;++i){
		cin>>a[i];
		a[i]^=a[i-1];
	}
	cin>>q;
	while (q--){
		long long l,r,ans=0;
		cin>>l>>r;
		l--;
		l%=(k+1);
		r%=(k+1);
		cout<<(a[r]^a[l])<<endl;
	}
	return 0;
}
```

---

## 作者：残阳如血 (赞：3)

### $\textbf{Description}$

> 不得不吐槽一下，题面写得是真烂。

给定序列 $\{a_n\}$，现定义一个无穷序列 $\{x\}$ 如下：
$$
x_i=
\begin{cases}
\space \space a_i&1\le i\le n\\
\space\space\bigoplus\limits_{\mathclap{j=i-k}}^{\mathclap{i-1}}{x_i}&i> n
\end{cases}
$$
给定 $Q$ 个区间 $[l_i,r_i]$，求 $\bigoplus_{i=l}^{r}x_i$​ 的值。

$1\le n\le10^5$，$1\le Q\le10^6$，$l_i,r_i,a_i\le10^{18}$。

### $\textbf{Solution}$

求区间异或和、没有修改，非常显然可以使用 **前缀和** 来维护。

但是 $l_i,r_i\le10^{18}$，十分巨大，不可能将整个前缀和数组开下来。

由于异或运算有着非常好的性质，且 $n\le10^5$，所以可以试着找找规律。

---

模拟几组小数据，可以发现 $x$ 是一个长度为 $n + 1$​ 的循环序列。

> #### 证明
>
> 显然 $x$ 前 $n$ 位恰为 $a$ 数组。
>
> 第 $n+1$ 位根据递推式，可得 $x_{n+1}=\bigoplus_{i=1}^{n}{a_i}$。
>
> 继续递推，第 $n+2$ 位的值
> $$
> \begin{aligned}
> x_{n+2}&=\bigoplus\limits_{i=2}^{n+1}x_i\\
> &=\bigg(\bigoplus\limits_{i=2}^{n}a_i\bigg)\oplus x_{n}\\
> &=\bigg(\bigoplus\limits_{i=2}^{n}a_i\bigg)\oplus\bigg(\bigoplus\limits_{i=1}^{n}a_i\bigg)\\
> &=\bigg(\bigoplus\limits_{i=2}^{n}{a_i\oplus a_i}\bigg)\oplus a_{1}\\
> &=a_1
> \end{aligned}
> $$
> 接下来也可以这样证明，就不再继续写下去了。

故直接处理 $1\sim n+1$ 的异或前缀和，查询时对 $l_i,r_i$​ 取模即可。

前缀异或和的查询就是 $s_r\oplus s_{l-1}$，$s$ 表示异或前缀和数组。

### $\textbf{Code}$

当然，下面代码中的 `a` 数组是可以省略的，但是这里就不省略了（

```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 1e5 + 10;

int n, q, a[N], s[N];

signed main() {
  std::cin.tie(0)->sync_with_stdio(0);
  std::cin >> n;
  for (int i = 1; i <= n; ++i)
    std::cin >> a[i], s[i] = a[i] ^ s[i - 1];
  std::cin >> q;
  for (int l, r; q; --q) {
    std::cin >> l >> r, --l; // l 要 -1
    l %= (n + 1), r %= (n + 1); // 除以循环节长度
    std::cout << (s[r] ^ s[l]) << '\n';
  }
  std::cout.flush();
  return 0;
}
```

---

## 作者：yanwh1 (赞：2)

# 题目大意：
给你一个有 $k$ 个元素的序列 $a$，并且给你一个无限序列 $x$，规定：

$$x_{i}= \begin{cases}a_{i} & 1 \le i \le k \\\bigoplus\limits_{j=i-k}^{i-1} x_{j} & i>k\end{cases}$$

给定 $Q$ 组询问，每次给出 $l_{i}$，$r_{i}$，求 $\bigoplus\limits_{i=l}^{r} x_{i}$。
# 解题思路：
我们可以发现，无限序列 $x_{i}(i>k)$ 其实是 $x_{i}$ 前 $k$ 个数的异或和。通过规律发现 $x$ 的规律为每 $k+1$ 个数中，前 $k$ 个数为 $a_{i}$，而第 $k+1$ 位为 $\bigoplus\limits_{i=1}^{k} a_{i}$。这样我们只需要做一下前缀和就完了。
# 代码实现：
```
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define int long long
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}
inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=3e5+5;
int s[N],sum[N];
signed main(){
	int n=read();
	for(rint i=1;i<=n;i++)s[i]=read(),sum[i]=s[i]^sum[i-1];
	int q=read();
	while(q--){
		int l=read()-1,r=read();
		l=l%(n+1),r=r%(n+1);
		int ans=sum[l]^sum[r];
		write(ans),puts("");
	}
	return 0;
}
```

---

## 作者：red_moon (赞：1)

## 题目解读
规定 
$$
x_i = \begin{cases}
a_i\\
⨁_{j=i-k}^{i-1}
\end{cases}
$$

第一眼暴力，但仔细看看数据发现过不了。后来发现用前缀和优化、公式计算和循环节处理即可通过这道题。

## 题目分析
其实序列 $x$ 就是一个循环序列，每次对特定区间取模就能得到结果。

因为 $x ⨁ 0 = x , x ⨁ x = 0$

所以得出公式：$$⨁_{i=l}^r x_i=(⨁_{i=1}^{l-1}x_i)⊕(⨁_{i=1}^rx_i)$$

## 注意事项
预处理写好，区间别弄错了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //省事，这样就不用一个个打long long
int n,t,l,r,arr[100005];
signed main(){ //define的后遗症，不然爆编译
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		cin >> arr[i];
		arr[i]=arr[i-1]^arr[i]; //前缀和，异或，公式推导
	}
	cin >> t;
	while(t--)
	{
		cin >> l >> r;
		l--;
		l%=(n+1),r%=(n+1); //处理循环节
		cout<<(arr[l]^arr[r])<<endl; //千万注意要加括号！
	}
	return 0;
}
``````

---

## 作者：songzhixin (赞：1)

## 题目大意

给定一个 $x$ 数组，定义

$$ x_i = \begin{cases} a_i & ( 1 \le i \le K ) \\ \bigoplus_{j = i-k}^{i-1} x_j & (i > K) \end{cases} $$

注：题目中的 $n$ 其实是 $i$，$ \bigoplus_{i = n-1}^{n - k} x_i $ 其实是 $ \bigoplus_{j = i-k}^{i-1} x_j $。

结果求 $x$ 数组中 $l$ 到 $r$ 的异或和。

## 解题思路

一看第一想到递归求 $x_i$，但一看数据范围 $ 1 \le l_i \le r_i \le 10^{18} $，时间上肯定会爆掉，所以不行。

先测接各样例，第一个样例中 $x$ 数组如下：$ 1 , 3 , 5 , 7 , 0 , 1 , 3 , 5 , 7 , 0 , \dots $

第二个样例中 $x$ 数组如下：$ 3 , 3 , 4 , 3 , 2 , 5 , 3 , 3 , 4 , 3 , 2 , 5 , \dots $

不难发现，$x$ 数组的循环结的长度为 $k+1$，循环的内容是 $ a_1 , a_2 , a_3 , \dots ,a_k , \bigoplus_{i=1}^k a_i$。

所以我们可以通过取余求出 $x$ 数组。

可问题求的是 $ \bigoplus_{i=l}^r x_i $ 只求出 $x$ 数组还不行。换个角度想，如果是 $ \sum_{i=l}^r x_i $，是不是求一遍前缀和就行了？异或有没有前缀和呢？我们一起来看。

$$ \begin{cases} 1 \oplus 1 \oplus 1 = 0  \oplus 1 = 1 \\ 1 \oplus 0 \oplus 0 = 1 \oplus 0 = 1 \\ 0 \oplus 1 \oplus 1 = 1  \oplus 1 = 0 \\0 \oplus 0 \oplus 0 = 0  \oplus 0 = 0 \end{cases}$$
 
所以 $a \oplus b \oplus b = a $。
 
 $$ \begin{cases} 1 \oplus 0 = 1 \\ 0 \oplus 0 = 0 \end{cases} $$ 
 
所以 $ a \oplus 0 = a $。

$$ \begin{aligned} \bigoplus_{i=l}^r x_i &= \bigoplus_{i=l}^r x_i \oplus \bigoplus_{i=1}^{l-1} 0 \\&= \bigoplus_{i=l}^r x_i \oplus [ (x_1 \oplus x_1) \oplus (x_2 \oplus x_2) \oplus (x_3 \oplus x_3) \dots \oplus (x_{l-1} \oplus x_{l-1})] \\ &= \bigoplus_{i=1} ^r x_i \oplus (x_1 \oplus x_2 \oplus x_3 \oplus \dots \oplus x_{l-1}) \oplus (x_1 \oplus x_2 \oplus x_3 \oplus \dots \oplus x_{l-1}) \\ &= \bigoplus_{i=l}^r x_i \oplus \bigoplus_{i=1}^{l-1} x_i \oplus \bigoplus_{i=1}^{l-1} x_i \\ &= \bigoplus_{i=1}^r x_i \oplus \bigoplus_{i=1}^{l-1} x_i \end{aligned}$$ 
  
因此我们可以求一遍前缀和，再通过上面这个公式就可以得到答案了。

## 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int K=1e5+5;
const int Q=1e6+5;
long long a[K],l[Q],r[Q],x[K]; 
long long ans;
int main(){
	long long k,q;
	scanf("%lld",&k);
	for(long long i=1;i<=k;i++){
		scanf("%lld",&a[i]);
		ans^=a[i];
		x[i]=a[i];//得到循环节 
	}
	scanf("%lld",&q);
	long long mod=k+1; //循环节的长度为k+1 
	for(long long i=1;i<=q;i++){
		scanf("%lld%lld",&l[i],&r[i]);
	}
	x[k+1]=ans;//循环节的最后一项为a[1]~a[k]的异或和 
	for(long long i=1;i<=k+1;i++){
		x[i]^=x[i-1];//得到异或和 
	}
	for(long long i=1;i<=q;i++){
		int fl=(l[i]-1)%mod;
		if(fl==0){
			fl=mod;
		}
		int fr=r[i]%mod;
		if(fr==0){
			fr=mod;
		}
		printf("%lld\n",x[fl]^x[fr]);//上述公式 
	}
	return 0;
} 
```

## 注意事项

1.数据范围为 $10^{18}$，需要开 `long long`。

2.最后坐标取余若为 $0$，则设置为 $k+1$。

---

## 作者：andychen_2012 (赞：1)

## 一、解题思路

我们可以根据题目需要我们求的答案来推出这道题可以用一种前缀和的方式做。我们需要知道一条式子 $\bigoplus_{i=l}^r x_i=\bigoplus_{i=1}^r x_i\bigoplus_{i=1}^{l-1} x_i$。这个可以根据异或的性质推出来。

那我们就可以预处理出 $x_i$，再处理出异或前缀和 $xr_i=\bigoplus_{j=1}^{i} x_j$。那样我们就可以用 $O(\max(r_i))$ 的时间复杂度做出这道题。即对于 $l_i,r_i$ 的答案为 $xr_{r_i}\bigoplus xr_{l_i-1}$.

我们可以看到数据范围中 $l_i\le r_i \le 10^{18}$。那我们就知道肯定不可能用预处理出 $x_i$ 的方法做这道题。

我们又可以推出什么呢？

因为 $x_n=\bigoplus_{i=n-1}^{n-K} x_i$，所以可以得到 $x_n=xr_{n-1} \bigoplus xr_{n-K-1}$，又可以推出 $xr_n=xr_{n-1} \bigoplus x_n=xr_{n-1} \bigoplus xr_{n-1} \bigoplus xr_{n-K-1}=xr_{n-K-1}$。

又因为我们的答案可以从 $xr$ 中直接得到，所以我们就可以用 $O(1)$ 的时间复杂度求出每一次询问。每一次询问的答案为 $xr_{(r_i-1)\bmod(k+1)+1} \bigoplus xr_{(l_i-1)\bmod(k+1)}$。

## 二、解题代码

```cpp
#include<cstdio>
typedef long long ll;
int k,q;
ll a[100005],x[100005],xr[100005];
ll l,r;
int main(){
	scanf("%d",&k);
	for(int i=1;i<=k;++i){
		scanf("%lld",a+i);
		x[i]=a[i];
		xr[i]=xr[i-1]^x[i];
	}
	scanf("%d",&q);
	for(int i=1;i<=q;++i){
		scanf("%lld%lld",&l,&r);
		l--;
		ll g1=l/(k+1),g2=r/(k+1);
		l-=g1*(k+1),r-=g2*(k+1);
		while(l>k)
			l-=k+1;
		while(r>k)
			r-=k+1;
		printf("%lld\n",xr[r]^xr[l]);
	}
	return 0;
}
```


---

## 作者：FallingFYC_ (赞：0)

[题目](https://www.luogu.com.cn/problem/P8034)

---
### 思路

很明显可以用前缀和维护，但 $l$，$r$ 的范围很大，无法用数组存。

但很显然 $x_a=x_{a+k+1}$，证明：

>  拿 $a=1$ 举例。
> $$
> \begin{aligned}
>x_{k+2}&=\bigoplus_{i=2}^{k+1} x_i
> \\
> &=(\bigoplus_{i=1}^{k} x_i) \oplus a_1 \oplus x_{k+1}
> \\
> &=(\bigoplus_{i=1}^{k} x_i) \oplus a_1 \oplus (\bigoplus_{i=1}^{k} x_i)
> \\
> &=a_1
> \end{aligned}
> $$

因此可以通过对 $l$，$r$ 模 $(n+1)$ 的方式使得可以使用数组存下前缀和。

---
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int K=1e5+5;
ll k,a[K],q,sum[K];
ll l,r;
int main(){
    cin>>k;
    for(int i=1;i<=k;i++)cin>>a[i];
    for(int i=1;i<=k;i++)sum[i]=sum[i-1]^a[i];
    cin>>q;
    while(q--){
        cin>>l>>r;
        --l,l%=(k+1),r%=(k+1);
        cout<<(sum[r]^sum[l])<<endl;
    }
    return 0;
}
```

---

## 作者：__O_w_O__ (赞：0)

根据题目转化一下，不难发现，题目中的序列 $x$ 实际上是一个长度位 $K+1$ 的循环序列，那么我们每次查询的时候就只要把 $l$ 和 $r$ 都对 $K+1$ 取模就可以得到实际上需要查询的区间。

然而这道题目 $K\le10^5$，直接使用暴力仍然通不过了，需要使用前缀和优化。

根据 $x\bigoplus 0=x$ 和 $x\bigoplus x=0$ 这两个性质，就可以得到 $\bigoplus^r_{i=l}x_i=(\bigoplus^{l-1}_{i=x}x_i)\bigoplus(\bigoplus^r_{i=1}x_i)$。

这样就可以使用前缀和进行预处理实现每次查询的时间复杂度为 $O(1)$ 了，剩下的细节可以看一看代码。 

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
long long sum[N];//记得开long long
int main() {
	int k;
	scanf("%d", &k);
	for (int i = 1; i <= k; i++) {
		long long x;
		scanf("%lld", &x);
		sum[i] = sum[i - 1] ^ x;
	}
	int q;
	scanf("%d", &q);
	while (q--) {
		long long l, r;
		scanf("%lld%lld", &l, &r);
		l--;
		l %= k + 1, r %= k + 1;
		printf("%lld\n", sum[r] ^ sum[l]);
	}
	return 0;
}
```

---

## 作者：CheeseFunction (赞：0)

### 思路分析
  如果纯打暴力,时间复杂度极高,绝对是过不了本题的。那就要优化:题目中给出了一个长度为 $K$ 循环节数列 $a$ , 实则就是说,每次操作 $l_i$, $r_i$ 时需要$\mod (k+1)$ 呗。而题目中说的区间这一关键词，就是说要使用前缀和。则有:
>$$
>x_i=\bigoplus_{i=1}^{r \mod{(k+1)}}-\bigoplus_{i=1}^{(l-1)\mod{(k+1)}}
>$$
而其中的两个区间 $\bigoplus$ ,都可以使用前缀和解决，即为：

`qzh[i]=qzh[i-1]*a[i]`

最后优化一下，把 `a` 数组改成变量，即为 `AC` 代码。
### Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int qzh[1001000];
signed main(){
	int T,n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		qzh[i]=qzh[i-1]^x;
	}
	cin>>T;
	while(T--){
		int l,r;
		cin>>l>>r;
		l--;
		l%=(n+1);
		r%=(n+1);
		cout<<(qzh[r]^qzh[l])<<endl;
	}
}
```

---

## 作者：Tsuki091117 (赞：0)

很简单的一道找规律题。
## 题意概括
给定 $k$ 个数，并给定 $k$ 以后的数的生成规律。对于每组询问 $l_{i}r_{i}$，输出 $\oplus^{r}_{i=l}x_{i}$。
## 样例分析
#### 第一组


|编号|1|2|3|4|5|6|7|8|9|10|11|12|……|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|第i个数的值|1|3|5|7|0|1|3|5|7|0|1|3|……|
|第1到i个数的异或值|1|2|7|0|0|1|2|7|0|0|1|2|……|

#### 第二组


|编号|1|2|3|4|5|6|7|8|9|10|11|12|……|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|第i个数的值|3|3|4|2|3|5|3|3|4|2|3|5|……|
|第1到i个数的异或值|3|0|4|6|5|0|3|0|4|6|5|0|……|

- 我们先不看这两个表格，我们先探究一下 $\oplus$ 有哪些性质？
$$1 \oplus 2 = 3$$
$$1 \oplus 2 \oplus 3 = 0$$
$$1 \oplus 2 \oplus 3 \oplus 4 = 4$$
$$1 \oplus 2 \oplus 3 \oplus 4 \oplus 5 = 1$$
- 那么接下来我们再异或回去： 
$$1 \oplus 2 \oplus 2 = 1$$
$$1 \oplus 2 \oplus 3 \oplus 3 = 1 \oplus 2 \oplus 0 = 3$$
$$1 \oplus 2 \oplus 3 \oplus 4 \oplus 4 = 1 \oplus 2 \oplus 3 \oplus 0 = 0$$
$$1 \oplus 2 \oplus 3 \oplus 4 \oplus 5 \oplus 5 = 1 \oplus 2 \oplus 3 \oplus 4 \oplus 0 = 4$$
不难发现： 
$$a \oplus b \oplus a = b$$
- **然后我们再模拟一遍样例一**

第一项 $1$

第二项 $3$

第三项 $5$

第四项 $7$

第五项 $1 \oplus 3 \oplus 5 \oplus 7 = 0$

第六项 $3 \oplus 5 \oplus 7 \oplus (1 \oplus 3 \oplus 5 \oplus 7) = 1$

第七项 $5 \oplus 7 \oplus(1 \oplus 3 \oplus 5 \oplus 7) \oplus (3 \oplus 5 \oplus 7 \oplus (1 \oplus 3 \oplus 5 \oplus 7)) = 3$

- 然后返回去看两个表格，这时我们就可以得出结论了：无论是第一行还是第二行，都是按照一定的顺序重复循环的，每 $k+1$ 个数循环一次。

- 接下来我们只需要求出这 $k+1$ 个数即可。

```cpp
  for(int i=1;i<=k;i++){
      cin>>a[i];
      a[k+1]^=a[i];//求第k+1位的数
  }
  for(int i=1;i<=k+1;i++){
      b[i]=b[i-1]^a[i];//异或前缀和
  }
```

**注意：$l_{i}r_{i}$ 的取值范围过大，所以需要模除 $k+1$。**

- 最后让 $b_{r} \oplus b_{l-1}$ 即可

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int k,Q;
int a[N],b[N];
signed main(){
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];
		a[k+1]^=a[i];
	}
	for(int i=1;i<=k+1;i++){
		b[i]=b[i-1]^a[i];
	}
	cin>>Q;
	while(Q--){
        int l,r;
        cin>>l>>r;
        r=r%(k+1);
        l=l%(k+1);
        if(!r) r=k+1;//当l或r等于0时，记得赋值成k+1
	    if(!l) l=k+1;
	    int ans=b[r]^b[l-1];
	    cout<<ans<<"\n";//记得换行
	}
	return 0;
}

```

---

## 作者：operator_ (赞：0)

# P8034 [COCI2015-2016#7] Ozljeda

[题目传送门](https://www.luogu.com.cn/problem/P8034)

## 题解

评橙差不多了。

手玩一下样例，很容易发现 $x$ 的循环节为 $K+1$，每一段分别为 $a_1,a_2,a_3,\dots,a_K,\bigoplus_{i=1}^K a_i$ 这几项，然后恰好循环节的异或值为 $0$，所以就可以直接维护前缀异或值，然后取模求答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
int k,a[100005],q,l,r;
signed main() {
	cin>>k;
	for(int i=1;i<=k;i++)
		a[i]=rd(),a[k+1]^=a[i];
	for(int i=1;i<=k+1;i++)
		a[i]^=a[i-1];
	cin>>q;
	while(q--) {
		l=rd(),r=rd();
		printf("%lld\n",a[(r-1)%(k+1)+1]^a[(l-2)%(k+1)+1]);
	}
	return 0;
}

```

---


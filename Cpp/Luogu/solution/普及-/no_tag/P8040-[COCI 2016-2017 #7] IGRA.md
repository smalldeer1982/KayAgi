# [COCI 2016/2017 #7] IGRA

## 题目背景

Mirko 和 Slavko 对他们的滑雪旅行感到十分厌烦，于是他们开始玩一个新游戏。

## 题目描述

首先，Mirko 指定了一个整数 $N$，然后 Slavko 写下了 $N$ 个字母，Mirko 写下了一个长度为 $N$ 的单词。Slavko 需要他写下的 $N$ 个字母组成一个单词，并且他的单词中没有一个位置上的字母与 Mirko 写下的单词中相同位置的字母相同。为了使得这个游戏具有挑战性，Mirko 还要求 Slavko 写下的单词是所有满足要求的单词中字典序最小的。这个单词**必定会存在**。介于 Mirko 和 Slavko 还很年轻，他们只知道 `a`、`b`、`c` 三个字母，因此他们写下的单词也都只会包含这三个字母。

请帮助 Slavko 找到这样的单词。

## 说明/提示

**【数据范围】**

对于 $40\%$ 的数据，保证 $1\leqslant N\leqslant 20$。  
对于所有数据，$1\leqslant N\leqslant 5000$，所有字符串仅可能包含字母 `a`、`b`、`c`。

**【题目来源】**

本题来源自 **_[COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST 7](https://hsin.hr/coci/archive/2016_2017/contest7_tasks.pdf) T3 IGRA_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3
abc
abc```

### 输出

```
bca```

## 样例 #2

### 输入

```
4
baba
baab```

### 输出

```
abba```

## 样例 #3

### 输入

```
5
aaabc
abcba```

### 输出

```
baaac```

# 题解

## 作者：_Vix_ (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P8040)

## 题意
给定只包含 $a ,b, c$ 三种字母的两个长度相等的字符串 $S, T$, 只改变 $S$ 串**字母位置**后得到的新串 $S'$，使得 $\forall i \in [1,|T|]$, 都满足 ${S'}_ i \ne T_i$，求字典序最小的 $S'$。

范围：$|S |= |T|, 1 \le |S| \le 5000$。

## 分析
首先有且仅有 $a,b,c$ 三个字母，又要满足字典序最小，容易想到贪心，因为对于 $T$ 串中的每一个字母，我们最多只有两个字母可以选择。比如当 $T_i = a$ 时，那么 $S'_ i = b$ 或 $c$。现在问题就转化成了在两个字母中选择哪一个，贪心地想，显然选择字典序更小的字母更优，但是原题限制了$S'$ 是由 $S$ 变幻而来的，所以 $S$ 串中 $a,b,c$ 的数量是一定的，可能当前选了某个字母后，剩下的字母无法让 $S'$ 和 $T$ 每一位都不等。所以正确的策略应该是在保证 $S'$ 和 $T$ 每一位都不等的情况下，选择更优的字母。

怎样保证不等呢？记 $S$ 中剩余的 $a,b,c$ 的数量为 $cnt_a, cnt_b, cnt_c$，$T$ 中剩余的 $a,b,c$ 的数量为 $aim_a, aim_b, aim_c$，恒有 $cnt_a + cnt_b \ge aim_c$, $cnt_a + cnt_c \ge aim_b$, $cnt_b + cnt_c \ge aim_a$。假如要选择 $a$，就要满足 $cnt_a - 1 + cnt_b \ge aim_c$ 并且 $cnt_a - 1 + cnt_c \ge aim_b$，$b,c$ 以此类推，因为只有三个字母，可以直接判断，时间复杂度 $O(|S|)$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e3 + 10;
int n;
char s[N];
int cnt[3], aim[3];
//用 0, 1, 2 代表 a, b, c

int main() {
	scanf("%d%s", &n, s + 1);
	for (int i = 1; i <= n; i++)
		if (s[i] == 'a') cnt[0]++;
		else if (s[i] == 'b') cnt[1]++;
		else cnt[2]++;
	
	scanf("%s", s + 1);
	for (int i = 1; i <= n; i++)
		if (s[i] == 'a') aim[0]++;
		else if (s[i] == 'b') aim[1]++;
		else aim[2]++;
	
	for (int i = 1; i <= n; i++)
		if (s[i] == 'a') {
			aim[0]--;
			if (cnt[1] && cnt[1] - 1 + cnt[2] >= aim[0] && cnt[1] - 1 + cnt[0] >= aim[2]) cnt[1]--, printf("b");
			else cnt[2]--, printf("c");
		} else if (s[i] == 'b') {
			aim[1]--;
			if (cnt[0] && cnt[0] - 1 + cnt[1] >= aim[2] && cnt[0] - 1 + cnt[2] >= aim[1]) cnt[0]--, printf("a");
			else cnt[2]--, printf("c");
		} else {
			aim[2]--;
			if (cnt[0] && cnt[0] - 1 + cnt[1] >= aim[2] && cnt[0] - 1 + cnt[2] >= aim[1]) cnt[0]--, printf("a");
			else cnt[1]--, printf("b");
		}
	return 0;
}
```

## 后话
建议评橙，考场上很快就想到正解了，不是很难的贪心，听机房的人说可以用爆搜过，tql

这是本蒟蒻的第一篇题解，有什么错还请dalao指出。


---

## 作者：DengDuck (赞：2)

![](bilibili:BV15G4y1M7gZ)

我们设 Mirko 有 $a$ 个 A， $b$ 个 B，$c$ 个 C。
 
Slavko 有 $a2$ 个 A， $b2$ 个 B， $c2$ 个 C。

那么有解的情况是：

$$
c\leq a2+b2
$$
$$
b\leq a2+c2
$$
$$
a\leq b2+c2
$$

由此我们可以写出判断函数，来判断某个情况下是否有解。

于是可以考虑贪心，我们每个对于当前情况，由于要选不同字符，所以只有两种情况，选择两者中的选择字典序最小的有解情况，不用担心无解，首先题目保证有解，对于局部，我们也是前面选择的有解情况，所以肯定有解。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c,a2,b2,c2;
char s[100005],s2[100005];
bool pd(long long a2,long long b2,long long c2)
{
    if(a2<0||b2<0||c2<0)return false;
    if(b2+c2<a)return false;
    if(a2+b2<c)return false;
    if(a2+c2<b)return false;
    return true;
}
int main()
{
    scanf("%lld",&n);
    scanf("%s %s",s2+1,s+1);
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='a')a++;
        if(s[i]=='b')b++;
        if(s[i]=='c')c++;
        if(s2[i]=='a')a2++;
        if(s2[i]=='b')b2++;
        if(s2[i]=='c')c2++;
    }
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='a')
        {
            a--;
            if(pd(a2,b2-1,c2))
            {
                putchar('b');
                b2--;
            }
            else if(pd(a2,b2,c2-1))
            {
                putchar('c');
                c2--;
            }
        }
        if(s[i]=='b')
        {
            b--;
            if(pd(a2-1,b2,c2))
            {
                putchar('a');
                a2--;
            }
            else if(pd(a2,b2,c2-1))
            {
                putchar('c');
                c2--;
            }
        }
        if(s[i]=='c')
        {
            c--;
            if(pd(a2-1,b2,c2))
            {
                putchar('a');
                a2--;
            }
            else if(pd(a2,b2-1,c2))
            {
                putchar('b');
                b2--;
            }
        }
    }
}
```

---

## 作者：songhx (赞：2)

本题解法：

果断选择 $\text{dfs}$ 做法，空间只有64MB，不好用广搜。

首先计算 $\text{S}$ 小朋友的 $a,b,c$ 字母个数。

然后开始 $\text{dfs}$ ，参数为 $k$ 的时候按 $a\rightarrow b\rightarrow c$ 的顺序枚举答案串的第 $k$ 个字符，这样保证了字典序最小， $\text{dfs}$ 在做的各位应该都会，不多赘述。

每一次向前都要减 $a,b,c$ 的值，因为不能小于 $0$ 。

但是光这样搜索只能得 $\text{60pts}$ 。

$\color{orange}{60pts}$ $\text{code:}$

```cpp
#include <iostream>
#include <string>
using namespace std;

string A,B,C = "";
int a,b,c;
int len;

void dfs(int k){
	if(C.length() == len) {
		cout << C << endl;
		exit(0);
	}
	if(B[k] != 'a' && a > 0){
		C += 'a';
		a--;
		dfs(k + 1);
		a++;
		C.pop_back(); //string库的pop_back函数，去掉串尾的一个字符
	}
	if(B[k] != 'b' && b > 0){
		C += 'b';
		b--;
		dfs(k + 1);
		b++;
		C.pop_back();
	}
	if(B[k] != 'c' && c > 0){
		C += 'c';
		c--;
		dfs(k + 1);
		c++;
		C.pop_back();
	}
	return;
}

int cnt(char ch){
	int s = 0,len = A.length();
	for(int i = 0; i < len; i++) if(A[i] == ch) s++;
	return s;
}

int main(){
	cin >> len;
	cin >> A >> B;
	a = cnt('a'),b = cnt('b'),c = cnt('c');
	dfs(0);
	return 0;
}
```

所以需要剪枝（废话。

我们知道，剩余的 $a,b,c$ 个数必须要有填补后面的能力。

所以每次搜索都加一个特判。

设变量 $ba,bb,bc$ 为直到 $\text{dfs}$ 当前进程为止，后面剩余的 $a,b,c$ 个数。

如果推到 $a$ ，那么 $a$ 可以填的 $b$ 和 $c$ 的空缺就需要特判，也就是 $a+c\ge bb$ 和 $a+b\ge bc$。

$b,c$ 同理，

对于 $b$ ，需要特判 $a$ 和 $c$ ，即 $b+c\ge ba$ 和 $a+b\ge c$ 。

对于 $c$ ，需要特判 $a$ 和 $b$ ，即 $b+c\ge ba$ 和 $a+c\ge b$ 。 

这样剪枝的话我们就顺利地AC了这道题。

注意每一次往前推或者回溯都需要改变 $ba,bb,bc$ 的值。

$\color{green}{AC}$ $\text{code:}$

```cpp
#include <iostream>
#include <string>
using namespace std;

string A,B,C = ""; //C是答案
int a,b,c;
int ba,bb,bc;
int len;

void rec(int k){ //记录ba，bb和bc
	if(B[k] == 'a') ba--;
	else if(B[k] == 'b') bb--;
	else bc--;
}

void irrec(int k){ //回溯ba，bb和bc
	if(B[k] == 'a') ba++;
	else if(B[k] == 'b') bb++;
	else bc++;
}

void dfs(int k){
	if(C.length() == len) {
		cout << C << endl;
		exit(0); //记得直接退出程序！不是return！！！
	}
	if(B[k] != 'a' && a > 0 && a + c >= bb && a + b >= bc){
		C += 'a';
		a--;
		rec(k);
		dfs(k + 1);
		irrec(k);
		a++;
		C.pop_back();
	}
	if(B[k] != 'b' && b > 0 && a + b >= bc && b + c >= ba){
		C += 'b';
		b--;
		rec(k);
		dfs(k + 1);
		irrec(k);
		b++;
		C.pop_back();
	}
	if(B[k] != 'c' && c > 0 && a + c >= bb && b + c >= ba){ //上面提到的特判加上
		C += 'c';
		c--;
		rec(k);
		dfs(k + 1);
		irrec(k);
		c++;
		C.pop_back();
	}
	return;
}

int cnt(char ch,string str){ 
	int s = 0,len = A.length();
	for(int i = 0; i < len; i++) if(str[i] == ch) s++;
	return s;
}

int main(){
	cin >> len;
	cin >> A >> B;
	a = cnt('a',A),b = cnt('b',A),c = cnt('c',A);
	ba = cnt('a',B),bb = cnt('b',B),bc = cnt('c',B);
	dfs(0);
	return 0;
}
```


---

## 作者：FrozenDream (赞：2)

#### 引言：
听同机房的同学说这道题可以用dfs爆搜(加剪枝)，但蒟蒻不会，所以用了一种贪心的办法。
#### 思路：
用后缀和存储每一位以后的每一种字母的数量，再从头遍历一遍 $T$ 的每一个字符，判断每一位对应的其他两个字符中字典序较大的字符还没有遍历的数量和其他两个字符剩下的数量(还未用的数量)加起来谁更大，如果其他两个字符剩下的数量更大，并且此时两个字符中不是此时正在遍历的字符的字符的剩下的数量比0大，那么就输出这个字符，否则就输出此时遍历的这一位对应的其他两个字符中字典序较大的字符，不要忘记还要把输出字符的剩下的数量减1。

例如下面这组样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/dhg4xpf6.png)

把 $S$ 字符串中的每种字母的数量记录下来：

```cpp
p[0]=3,p[1]=1,p[2]=1;
```


记录后缀和：

```cpp
sum[0].a=2,sum[0].b=2,sum[0].c=1;
sum[1].a=1,sum[1].b=2,sum[1].c=1;
```
首先遍历第一位 $T_0$，此时我们肯定要选最优解，也就是字典序最小的那一个—— $\verb!b!$，但我们还要考虑如果我们取了 $\verb!b!$，那么如果后面遍历到 $\verb!c!$， $\verb!a!$ 剩下的字符数加上 $\verb!b!$ 剩下的字符数是否还能够替换 $\verb!c!$：

```cpp
T[0]=a;
p[0]+[1]>sum[0].c?b:c
```
#### AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p[4];
char s;
struct ax{
	int a,b,c;
}sum[5005];
string t;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		p[s-'a']++;
		sum[i].a=0;
		sum[i].b=0;
		sum[i].c=0;
	}
	sum[n].a=0;
	sum[n].b=0;
	sum[n].c=0;
	cin>>t;
	for(int i=n-1;i>=0;i--){
		if(t[i]=='a')sum[i].a++;
		if(t[i]=='b')sum[i].b++;
		if(t[i]=='c')sum[i].c++;
		sum[i].a+=sum[i+1].a;
		sum[i].b+=sum[i+1].b;
		sum[i].c+=sum[i+1].c;
	}
	for(int i=0;i<n;i++){
		if(t[i]=='a'){
			if(p[0]+p[1]>sum[i].c&&p[1]>0){
				cout<<'b';
				p[1]--;
			}else{
				cout<<'c';
				p[2]--;
			}
		}else if(t[i]=='b'){
			if(p[0]+p[1]>sum[i].c&&p[0]>0){
				cout<<'a';
				p[0]--;
			}else{
				cout<<'c';
				p[2]--;
			}
		}else{
			if(p[0]+p[2]>sum[i].b&&p[0]>0){
				cout<<'a';
				p[0]--;
			}else{
				cout<<'b';
				p[1]--;
			}
		}
	}
}
```


---

## 作者：DFM_O (赞：0)

## [P8040 题目](https://www.luogu.com.cn/problem/P8040)

### 解题思路
很明显可以用深搜加剪枝解决的问题，现在关键在于如何剪枝。

不难发现，若 Slavko 可以目前使用的 `a` 和 `b` 的数量已经小于剩下的未确定的字符中 Mirko 写下的 `c` 的数量，那么就可以直接结束本次深搜了，其他字母同理。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,as,bs,cs,as1,bs1,cs1;
string s1,s2;
void dfs(int dep,string s)
{
	if(dep>n)
	{
		cout<<s;
		exit(0);
	}
	if(s2[dep-1]!='a')
	{
		if(as>0&&bs1<=as+cs&&cs1<=as+bs)
		{
			as--;
			if(s2[dep-1]=='a')
				as1--;
			if(s2[dep-1]=='b')
				bs1--;
			if(s2[dep-1]=='c')
				cs1--;
			dfs(dep+1,s+'a');
			if(s2[dep-1]=='a')
				as1++;
			if(s2[dep-1]=='b')
				bs1++;
			if(s2[dep-1]=='c')
				cs1++;
			as++;				
		}
	}
	if(s2[dep-1]!='b')
	{
		if(bs>0&&as1<=bs+cs&&cs1<=as+bs)
		{
			bs--;
			if(s2[dep-1]=='a')
				as1--;
			if(s2[dep-1]=='b')
				bs1--;
			if(s2[dep-1]=='c')
				cs1--;
			dfs(dep+1,s+'b');
			if(s2[dep-1]=='a')
				as1++;
			if(s2[dep-1]=='b')
				bs1++;
			if(s2[dep-1]=='c')
				cs1++;
			bs++;				
		}
	}
	if(s2[dep-1]!='c')
	{
		if(cs>0&&bs1<=as+cs&&as1<=cs+bs)
		{
			cs--;
			if(s2[dep-1]=='a')
				as1--;
			if(s2[dep-1]=='b')
				bs1--;
			if(s2[dep-1]=='c')
				cs1--;
			dfs(dep+1,s+'c');
			if(s2[dep-1]=='a')
				as1++;
			if(s2[dep-1]=='b')
				bs1++;
			if(s2[dep-1]=='c')
				cs1++;
			cs++;				
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	cin>>s1>>s2;
	for(int i=0;i<n;i++)
	{
		if(s1[i]=='a')
			as++;
		if(s1[i]=='b')
			bs++;
		if(s1[i]=='c')
			cs++;
	}
	for(int i=0;i<n;i++)
	{
		if(s2[i]=='a')
			as1++;
		if(s2[i]=='b')
			bs1++;
		if(s2[i]=='c')
			cs1++;
	}
	dfs(1,"");
	return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

### 先说几句

COCI 冷门好题。思路有点难想。

### 解题思路

不要考虑 Slavko 的字符串的全排列，而将问题转化为：在新的空字符串里一个一个放 Slavko 的字符串的字符，使得每个字符与 Mirko 的相对应字符不同。

显然第一档数据可以搜索过。

对于每一位，如果 Mirko 的字符不是 `a`，那么我们应该优先选择填 `a`。

同理，依次尝试 `b` 和 `c`。这样一定可以保证字典序的最优性。

但是，之后 $n$ 那么大，还能搜索吗？

考虑一种情况：假如 Mirko 剩下的 `b` 数量太多，大于 Slavko 还有的 `a` 和 `c` 的数量，这时还需要继续搜索吗？我们只能用 `a` 和 `c` 替代 `b`，而如果 `b` 数量大于 `a` 和 `c` 数量，这就意味着必须用 Slavko 的 `b` 对应 Mirko 的 `b`，显然不行。

可以使用如上的可行性剪枝，实测可以通过本题。

### 奉上代码

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define rep(i, s, t) for(int i=s; i<=t; i++)
#define F first
#define S second
#define ll long long
#define pii pair<int, int>
#define all(x) x.begin(), x.end()
#define debug(x) cout<<#x<<":"<<x<<endl;
const int N=200010;
using namespace std;

string a, b, c; 
int a1=0, b1=0, c1=0;
int a2=0, b2=0, c2=0;
string s;

void dfs(int i)
{
	if(a1+c1<b2 || a1+b1<c2 || b1+c1<a2) return;
	if(i>=a.size())
	{
		cout<<s;
		exit(0);
	}
	if(a1 && (b[i]=='b' || b[i]=='c'))
	{
		--a1; s+='a';
		if(b[i]=='b') b2--;
		else c2--;
		dfs(i+1);
		if(b[i]=='b') b2++;
		else c2++;
		++a1; s.pop_back();
	}
	if(b1 && (b[i]=='a' || b[i]=='c'))
	{
		--b1; s+='b';
		if(b[i]=='a') a2--;
		else c2--;
		dfs(i+1);
		if(b[i]=='a') a2++;
		else c2++;
		++b1; s.pop_back();
	}
	if(c1 && (b[i]=='a' || b[i]=='b'))
	{
		--c1; s+='c';
		if(b[i]=='a') a2--;
		else b2--;
		dfs(i+1);
		if(b[i]=='a') a2++;
		else b2++;
		++c1; s.pop_back();
	}
}

signed main()
{
	int n; cin>>n;
	c.resize(n);
	cin>>a>>b;
	for(char c:a) if(c=='a') a1++; else if(c=='b') b1++; else c1++;
	for(char c:b) if(c=='a') a2++; else if(c=='b') b2++; else c2++;
	dfs(0);

	return 0;
}
```

---

## 作者：Xjin (赞：0)

# 题意概括
给出两个长度为 $n$ 的字符串。均由 $a$，$b$，$c$ 组成。要求用第一个字符串中的字符组成一个新的字符串，且在第 $i$ 个位置要与第二个字符串的第 $i$ 个字符不同。输出字典序最小的。
# 题目分析
一看数据发现 $n\leq 5000$ ，有点大，果断放弃搜索，想贪心的思路。对于当前位置来说，如果能选 $a$ 那肯定选（因为要字典序最小）。同理，先 $b$ 再 $c$ 。由于不能与后面的重合，所以要判断一下后面与当前字符不同的数量是不是满足比当前要选的数量要少，如果满足就选它，不满足就选另一个（题目保证必定有解）。所以就可以得出贪心的代码了，用 $ta$，$tb$，$tc$ 分别表示 $a$，$b$，$c$ 字符的总数，再记录一个结构体 $a$ 数组，用 $sa$，$sb$，$sc$ 分别表示当前位置之后的 $a$，$b$，$c$ 字符的个数。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ta,tb,tc;
char y[5005],z[5005];
struct node{
	int sa,sb,sc;
}a[5005];
signed main(){
	scanf("%d",&n);
	scanf("%s",y+1);
	for(int i=1;i<=n;i++){
		if(y[i]=='a')ta++;
		if(y[i]=='b')tb++;
		if(y[i]=='c')tc++;
  		//统计每个字符的总数 
	}
	scanf("%s",y+1);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++){
			if(y[j]=='a')a[i].sa++;
			else if(y[j]=='b')a[i].sb++;
			else if(y[j]=='c')a[i].sc++;
        //统计当前点之后的字符的数量
		}
	for(int i=1;i<=n;i++){
		if(y[i]=='a')
			if(tb&&tb+tc>a[i].sa&&tb+ta>a[i].sc)z[i]='b';tb--;
			else z[i]='c',tc--;
		else if(y[i]=='b')
			if(ta&&ta+tc>a[i].sb&&ta+tb>a[i].sc)z[i]='a';ta--;
			else z[i]='c',tc--;
		else if(y[i]=='c')
			if(ta&&ta+tc>a[i].sb&&ta+tb>a[i].sc)z[i]='a';ta--;
			else z[i]='b',tb--;
	}
	for(int i=1;i<=n;i++)cout<<z[i];
	return 0;
} 
```

---


# [COCI 2015/2016 #4] HAN

## 题目背景

Han 不想单独学习，所以他邀请他的朋友 Dominik 过来。他们一起学习了一个晚上之后，Dominik 回家了。令他吃惊的是，一名警察拦住了他，认为他**喝醉了**。众所周知，在这种情况下，通过解决一系列精心设计的任务，测试一个人的认知能力，可以证明他是否清醒。如果我们能相信 Dominik，对话将会是这样的——

> 警察：从简单点的问题开始吧……冒泡排序的复杂度是多少？  
Dominik：太简单了，$\mathcal O(n^2)$。  
警察：很好，下一题。请倒着念英文字母表。  
Dominik：太无聊了，$\texttt{zyxwvutsrqponmlkjihgfedcba}$。  
警察：你这显然是背的，不算数。再来考你一题吧。想象一下，英文字母表中的从 $\texttt{a}$ 到 $\texttt{z}$ 的所有字母以顺时针顺次排列成一个环。初始时，你从字母 $\texttt{a}$ 开始，顺时针念字母。每念完一个字母，我可以告诉你按照相反方向念字母，或者询问你到目前为止某个字母你念了多少次。准备好了吗？开始！  
Dominik：唔……$\texttt{a}$、$\texttt{b}$、$\texttt{c}$……

警察的最后一个问题显然难倒了 Dominik。现在，请你帮助 Dominik 回答这些问题。

## 题目描述

具体地，警察在接下来将会发出 $q$ 次命令，每次命令为以下两种命令中的一种：

- $\bf SMJER~n$：在 Dominik 说完第 $n$ 个字母之后，他必须开始按照与当前方向相反的方向念字母。
- $\bf UPIT~n~x$：Dominik 需要回答在他念的前 $n$ 个字母中，字母 $x$ 出现了多少次。

你需要对于每次 $\bf UPIT~n~x$ 命令输出答案。

## 说明/提示

**【样例 1 解释】**

Dominik 说的前 $10$ 个字母依次是：$\texttt{a}$，$\texttt{b}$，$\texttt{c}$，$\texttt{d}$，$\texttt{c}$，$\texttt{b}$，$\texttt{a}$，$\texttt{z}$，$\texttt{y}$，$\texttt{x}$。  

**【样例 2 解释】**

Dominik 说的前 $7$ 个字母依次是：$\texttt{a}$，$\texttt{z}$，$\texttt{a}$，$\texttt{z}$，$\texttt{y}$，$\texttt{x}$，$\texttt{w}$。

**【数据范围】**

对于 $40\%$ 的数据，保证 $n\leqslant 1000$。  
对于 $60\%$ 的数据，保证 $n\leqslant 10^5$。  
对于所有数据，$1\leqslant q\leqslant 10^5$，$1\leqslant n\leqslant 10^9$，$x$ 仅包含小写字母。

**【题目来源】**

本题来源自 **_[COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST 4](https://hsin.hr/coci/archive/2015_2016/contest4_tasks.pdf) T2 HAN_**，按照原题数据配置，满分 $80$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
5
UPIT 1 b
UPIT 3 b
SMJER 4
UPIT 7 a
UPIT 10 z```

### 输出

```
0
1
2
1```

## 样例 #2

### 输入

```
5
SMJER 1
SMJER 2
SMJER 3
UPIT 5 a
UPIT 7 w```

### 输出

```
2
1```

## 样例 #3

### 输入

```
4
UPIT 100 a
UPIT 200 c
UPIT 300 a
UPIT 400 b```

### 输出

```
4
8
12
16```

# 题解

## 作者：Zilljy258 (赞：25)

很显然，这是一道模拟题。

所以我写了一个简单易懂的代码，希望大家喜欢~

~~模拟还不是个 OIer 都会？~~

[题目传送门](https://www.luogu.com.cn/problem/P8045)

------------


### 题目分析：

拿到这道题以后首先该怎样想呢？

其实这是一道很简单的题目，不要想复杂。

推导方式很简单，我们的思路只要跟着题目的要求走，大体的做法也就出来了。

#### 首先，
题目中要求的是数到第 $n$ 个数时，字母 $x$ 数过的次数，那自然要有计数的数组啦！

我们再设置一个变量 $now$ 来记录现在走到了那一步。

#### 其次，

数字母时有顺逆时针的顺序，所以在设置一个判断顺逆时针的变量。

#### 然后，

因为题目中说明了数据保证对于所有 $q$ 次命令，$n$ 严格递增，所以我们的运算一定是与输入同时进行的。

#### 最后，

理清你的思路，可以开始写动手写了！

这里有一些特殊情况需要考虑：

1. 开头时的 $now$ 的初始值一定要为 $0$，并且在后面需要特判（这是因为有一种一开始就反向念字母的情况）。

2. 在每次模拟时，从上一次结束的位置开始。我为此专门设置了一个变量。

3. 计数要在反转和输出之前（具体见核心代码）。

------------


### 初始化：

为了方便起见，我们分别把 $a,b,\cdots z$ 设为 $0,1,\cdots 25$。



```c++
long long n=0,z[26]={0},now=0;
string s;
char ss;
bool sn=false;   //顺逆时针判断。

```



------------


### 核心代码：


```c++
	long long m,mm=0;  //mm用来记录上一次结束的位置。
	for(int i=1;i<=n;i++){
		cin>>s;
		cin>>m;
		if(s[0]=='S'){  //只需要判断首字母就可以了。
			for(int j=mm+1;j<=m;j++){  
				if(sn==true){
					now++;
					if(i==1&&j==1){
						now=0;
					}
					if(now==26){  //循环念字母。
						now=0;
					}
				}
				else {
					if(i==1&&j==1){
						now=1;
					}
					if(now==0){
						now=26;
					}
					now--;
				}
				z[now]++;  //记录字母出现的个数。
			}
			sn=!sn;
		}
		else{
			for(int j=mm+1;j<=m;j++){  //这里实际上是我写复杂了，可以把循环放到判断语句的外面。
				if(sn==true){
					now++;
					if(now==26){
						now=0;
					}
				}
				else {
					if(i==1&&j==1){
						now=1;
					}
					if(now==0){
						now=26;
					}
					now--;
				}
				z[now]++;
			}
			cin>>ss;
			cout<<z[ss-'a']<<endl;
		}
		mm=m;
	}
```



------------


### 总结：

总的来说这道题还算比较简单，其实只要理清思路，就很好解了。

需要注意的是循环的范围一定要想清楚，多一少一都会出大差错。

后记：

这是萌新第一次写题解，可能有不足之处，如果大家有要我补充的或改进的，一定要提出来！谢谢大家。

---

## 作者：Naro_Ahgnay (赞：7)

## 题目大意

Dominik 最初按照正序念字母。

+ $\bf{SMJER}$：在 Dominik 说完第 $n$ 个字母之后，他必须开始按照与当前方向相反的方向念字母。

+ $\bf{UPIT}$：Dominik 需要回答在他念的前 $n$ 个字母中，字母 $x$ 出现了多少次。

你需要对于每次 $\bf{UPIT}$ 命令输出答案。

## 思路

首先这就是一道纯正的模拟题。我们首先用一个变量 $now$ 来记录第 $i$ 步时说完第 $n$ 个字母之后现在是哪个字母。对于字母 A~Z，我们用 0~25 分别表示这些字母。

### step1

最开始，因为一个单词都没有念，所以 $now$ 的初值应该为 $\texttt{-1}$。

### step2

接下来考虑第 $i$ 次操作。$now$ 记录的是刚才念到的第 $n_{i-1}$ 个字母，则相对于第 $n_i$ 个字母，我们应该再念 $n_i-n_{i-1}$ 个字母。然而为了节约时间，可以求出 $n_i-n_{i-1}$ 模上 26 的余数，记为 $det$。再将 $now$ 加上或者是减去 $det$ 得到第 $n_i$ 个字母的值。

### step3

当然，为了记录各个字母念了多少次。分两种情况：

+ 在前 $26 \times \lfloor \frac{n(i)-n(i-1)}{26} \rfloor$ 中念到的字母，用一个变量 $sum$ 把所有 $\lfloor \frac{n(i)-n(i-1)}{26} \rfloor$ 的和记录下来。

+ 在剩下的 $n(i)-n(i-1)$ 模上 26 中念到的字母，用 $cnt$ 数组记录在这种情况中各字母被念到的次数，然后在 for 循环中将 $cnt_{now±1}$ 到   $cnt_{now±det}$ 的值统统加上一。

### step4

为了解决是正序还是倒序念，直接用一个变量 $fx$ 代替。当 $fx$ 为 1 时是正序，否则为倒序。如果是正序，step3 中第二种情况就是从 $cnt_{now+1}$ 到  $cnt_{now+det}$；如果是倒序，step3 中第二种情况就是从 $cnt_{now-1}$ 到  $cnt_{now-det}$。

### step5

最终每次输入进来的字符 $x$，它的答案就是在进行以上操作后的 $cnt_{x-'a'}+sum$。

## code 

```cpp
#include<bits/stdc++.h>
using namespace std;
int q,n,now(-1),det,zu,sum,sx,bs;
bool fx;
int cnt[30];
char ch,a[10];
void wokzheng()
{
	det=(n-bs)%26;zu=(n-bs)/26;sum+=zu;
	for(int i=now+1;i<=now+det;i++) 
	{
		if(i>=26) cnt[i-26]++;
		else cnt[i]++;
	}
	now=(now+det)%26;
}
void wokfan()
{
	det=(n-bs)%26;zu=(n-bs)/26;sum+=zu;
	for(int i=now-1;i>=now-det;i--) 
	{
		if(i<0) cnt[i+26]++;
		else cnt[i]++;
	}
	now=(now-det+26)%26;
}
int main()
{
//	freopen("P8045.in","r",stdin);
//	freopen("P8045.out","w",stdout);
	scanf("%d",&q);fx=1;
	while(q--)
	{
		scanf("\n%s%d",a,&n);
		if(a[0]=='U')
		{
			if(fx) wokzheng();
			else wokfan();
			scanf(" ");ch=getchar();
			printf("%d\n",cnt[ch-97]+sum);
		}
		else 
		{
			if(fx) wokzheng(),fx=0;
			else wokfan(),fx=1;
		}
		bs=n;
	}
	return 0;
}

```



---

## 作者：_xiaxii (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P8045)
# 题意分析
~~这模拟不是简简单单嘛~~

乍一看是一道普普通通的模拟题，然而坑是非常的多。

思路非常简单，读入 `UPIT` 时输出这个字母的出现次数，读入 `SMJER` 时反转方向。 

对于 `UPIT`，我们可以开一个数组来记录每一个字母出现的次数，将其输出；对于 `SMJER`，我们可以定义一个名为 `dir` 的 `bool` 变量来记录方向。每读到一个数字，引用 `sync(n)` 函数来同步到现在的字母，用一个名为 `now` 的结构体来记录现在的数字与字母，在 `sync(n)` 中进行同步。

由于 $n$ 只有 $10^9$，暴力遍历也可以算出来。超出字母表范围可以用 `%26` 来限制。

## 再来说说坑
最重要的就是 `dir` 的更新要在 `sync(n)` 之前，以免在没有反转的时候就反转了。~~不要问我为什么知道~~

然后就是数组的更新很容易写错。倒序的部分我加上 $260000000$ 的原因是~~负数取模会被魔法干扰~~，而 $260000000$ 正好可以被 $26$ 给整除，所以对结果没有影响。

接着就是 `now` 要记得初始化，将字符赋值为 `'a'-1`，将数字赋值为 `0`。

## main的部分也是非常好写
读入字符串 `k` 然后分情况处理就好啦，记得初始化哦~
```cpp
int main()
{
	cin>>q;
	now.ch='a'-1;
	now.sum=0;
	sync(1);
	for(int i=1;i<=q;i++)
	{
		string k;
		cin>>k;
		if(k=="UPIT")
		{
			cin>>n>>x;
			sync(n);
			cout<<a[x-'a'+1]<<endl;
		}
		if(k=="SMJER")
		{
			cin>>n;
			
			sync(n);
			dir=!dir;
		}
	}
	return 0;
} 
```

# 代码
`sync()` 分成两个部分分别处理，下面就是代码啦：
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;

int q,n;//q次访问
char x;
int a[27];//用a数组记录每个字母的出现次数
bool dir=true;//用dir变量记录现在的方向

struct _now{//用now结构题记录现在的情况
	int sum;
	char ch;
}now;

void sync(int num)//用sync()函数来同步现在的n，for循环暴力枚举
{
	if(dir)//正向
	{
		for(int i=1;i<=num-now.sum;i++)
		{
			a[(now.ch-'a'+1+i-1)%26+1]++;
			
		}
		now.ch=(now.ch-'a'+1+num-now.sum-1)%26+1-1+'a';//同步字母
	}
	if(!dir)//反向
	{
		for(int i=1;i<=num-now.sum;i++)
		{
			a[(now.ch-'a'+1-i-1+260000000)%26+1]++;
//			cout<<(now.ch-'a'+1-i-1+260000000)%26+1<<" ";不要问我为什么这里有cout
		}
		now.ch=(now.ch-'a'+1-num+now.sum-1+260000000)%26+1-1+'a';//同步字母
	}
//	for(int i=1;i<=26;i++)不要问我为什么这里有cout*=2
//		cout<<a[i]<<" ";
	now.sum=num;//同步数字
}

int main()
{
	cin>>q;//读入q
	now.ch='a'-1;//初始化now结构体
	now.sum=0;
	sync(1);
	for(int i=1;i<=q;i++)
	{
		string k;
		cin>>k;
		if(k=="UPIT")
		{
			cin>>n>>x;
			sync(n);
			cout<<a[x-'a'+1]<<endl;//输出x的次数
		}
		if(k=="SMJER")
		{
			cin>>n;
			
			sync(n);
			dir=!dir;//dir一定要在sync()之后
		}
	}
	return 0;//完美结束
} 
```
实测[满分](https://www.luogu.com.cn/record/85934099)

本[蒟蒻](https://www.luogu.com.cn/user/728002)的第二篇题解。

---

## 作者：jgvccc (赞：2)

这题的主要思路前面的题解也说过，就是单纯的模拟。不过如果真的只是正常数字母的话，最多也只能是一道入门。这题的难点在于 $1 \leq n \leq 10^9$ 的数据范围，直接卡掉了暴力模拟的算法。

小蒟蒻太弱，看不懂前面dalao推出来的公式。这里提供一种稍微好理解一点的方法：

设第 $i$ 条命令里面给的整数为 $a_i$ 。

因为 $a_i$ 严格递增，所以无论是什么命令，我们都需要从 $a_{i-1}$ 数到 $a_i$ ，一共数 $a_i - a_{i-1}$ 个字母。

但是，这 $26$ 个字母排成了一圈，所以我们每数 26 个，就会回到之前的点。那么数任意多个 $26$ 都不会对现在我们数到的位置造成影响。

所以先用除法求出这次需要数多少圈，再计算出剩下的零散的字母就行了。

剩下的与前面的题解差不多，都是先创建一个记录字母被点到次数的数组， $0-25$ 分别代表 `a` 到 `z` 。然后还有存储数字母方向的变量，最后依题意模拟即可。

__最后，代码奉上__

```cpp
#include<bits/stdc++.h>
using namespace std;

int q;
char t,cur;
bool fan;
int tt,lst,d;
string ttt;
int cnt[27];
int add[2]={1,25};

signed main()
{
	std::ios::sync_with_stdio(false);
    cin>>q;cur=0;
    for(int i=1;i<=q;i++)
    {
        cin>>ttt>>tt;
        d=tt-lst;
        d/=26;
        for(int i=0;i<26;i++)
        	cnt[i]+=d;
        for(int i=1;i<=(tt-lst)%26;i++,cur+=add[fan],cur%=26)
        	cnt[cur]++;
        lst=tt;
        if(ttt=="SMJER")
        {
            fan=!fan;
            cur+=2*add[fan];
            cur%=26;
        }
        else
        {
            cin>>t;
            tt=t;tt-='a';
            cout<<cnt[tt]<<endl;
        }
    }
	return 0;
}
```

---

## 作者：wangxihan2009 (赞：1)

# Solution

本题实际上是一个模拟题，需要维护当前念到了哪个字母以及当前的方向（顺时针或逆时针）。对于 UPIT 操作，可以在每次念完字母后更新记录每个字母出现次数的数组。注意，在做 SMJER 操作前也需要先更新一遍出现次数数组。

## 时间复杂度

对于每次 UPIT 操作，最坏情况下需要遍历所有前面的字母，故总时间复杂度为 $O(qn)$，会超时。我们考虑如何优化。

首先，注意到每次 UPIT 操作中的 $n$ 是递增的，因此可以采用类似前缀和的思想，即维护一个前缀和数组 $sum_i$ 表示前 $i$ 个字母中每个字母出现的次数之和。这样在计算某次 UPIT 操作时，可以只需统计 $x$ 字母在前 $n$ 个字母中出现的次数，即 $sum_n(x)-sum_{n-1}(x)$。这样可以将单次查询的时间复杂度优化到 $O(1)$。但仍然无法通过本题，因为在 SMJER 操作时需要重新计算整个前缀和数组。

接下来引入一个 Trick：在 SMJER 操作后，将前缀和数组翻转，即 $sum_i$ 变为 $\sum_{n-i+1}$。这样在之后的 UPIT 操作中，只需按照原来的方法计算 $x$ 字母在前 $n$ 个字母中出现的次数，即 $sum_n(x)-sum_{n-1}(x)$，再将结果翻转一下即可。这样可以保证在 SMJER 操作后仍然能够正确统计每个字母的出现次数。

时间复杂度优化后，总时间复杂度为 $O(q+n)$，可以通过本题。

---

## 作者：Vct14 (赞：1)

题目：[P8045 [COCI2015-2016#4] HAN](https://www.luogu.com.cn/problem/P8045)

## 题目大意
Dominik 最初按照正序念字母。有两个命令：

- $\bf{SMJER}$：在 Dominik 说完第 $n$ 个字母之后，他必须开始按照与当前方向相反的方向念字母。

- $\bf{UPIT}$：Dominik 需要回答在他念的前 $n$ 个字母中，字母 $x$ 出现了多少次。

只需要输出 $\bf{UPIT}$ 命令的结果。

## 思路

为了方便，我们用一个逻辑型变量表示方向，如果为真，则为顺时针，否则为逆时针。

定义一个数组 $l[26]$，其中 $l_i$ 表示字母表中第 $i$ 个字母被念的次数。

字母可以用公式 

```s=x-'a'``` 

转换为对应的数字，其中 $s$ 是对应的数字，$x$ 是要转换的字母，'a' 表示字母 a 的 [ASCLL 码](https://baike.baidu.com/item/ASCII/309296)。

用一个循环来模拟念字母的过程。分别用两个量来存储现在念到的字母（用 $0-25$ 表示）和念过的字母数。当念过的字母数等于 $n$ 时，即当警察让 Dominik 按照相反方向念字母，或者询问他到目前为止某个字母念了多少次时，停止循环。

此时，判断一下警察的命令：

- 如果是 $\bf{SMJER}$，就将表示方向的量取反。
- 如果是 $\bf{UPIT}$，就将询问中的 $x$ 转换成对应的数来表示，然后输出数组里以这个数为下标的数。简单来说，就是输出 $l_{s}$，其中 $s$ 的解释见上文。

Code：

```c++
#include<bits/stdc++.h>//万能头文件
using namespace std;//命名空间

int l[26];//存储每个字母出现的次数

int main(){
	int q;//命令数
	cin>>q;//输入命令数
	int now_letter=-1,SumOfLetters=0;//念到的字母和念过的字母数
	bool Shun=true;//方向，如果为 true 顺时针念（顺着念），否则逆时针念（倒着念）
	while(q--){//将 q 看成还剩 q 个命令，每次命令完就 -1 ，还剩 0 个时结束循环
		string Que;//命令
		int n;//第 n 个字母
		cin>>Que>>n;//输入
		while(SumOfLetters!=n){//念过的字母数还不到 n
			SumOfLetters++;//念的字母数 +1
			if(Shun) now_letter++;//顺着念，念下一个
			else now_letter--;//倒着念，念前一个
			if(now_letter==26) now_letter=0;//z 的下一个是 a
			if(now_letter==-1) now_letter=25;//a 的上一个是 z
			l[now_letter]++;//这个字母被念了一次
		}
		if(Que=="SMJER"){//是 SMJER 命令
			Shun=!Shun;//方向取反，其中 ! 指非，即取反
			continue;//下一次循环
		}
        //是 UPIT 命令（由于此前 SMJER 命令已经跳到下一次循环，所以以下内容只有 UPIT 命令才能执行）
		char x;//定义询问的字母
		cin>>x;//输入这个字母
		cout<<l[(x-'a')]<<endl;//输出数组中这个字母对应的数
	}
	return 0;//华丽结束
}

```

无注释版：

```c++
#include<bits/stdc++.h>
using namespace std;

int l[26];

int main(){
	int q;
	cin>>q;
	int now_letter=-1,SumOfLetters=0;
	bool Shun=true;
	while(q--){
		string Que;
		int n;
		cin>>Que>>n;
		while(SumOfLetters!=n){
			SumOfLetters++;
			if(Shun) now_letter++;
			else now_letter--;
			if(now_letter==26) now_letter=0;
			if(now_letter==-1) now_letter=25;
			l[now_letter]++;
		}
		if(Que=="SMJER"){
			Shun=!Shun;
			continue;
		}
		char x;
		cin>>x;
		cout<<l[(x-'a')]<<endl;
	}
	return 0;
}

```

---

## 作者：Marshall001 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8045)

## 题目大意

Dominik 最开始按正常的顺序念字母表，警察会给出 $q$ 次命令，每次命令为以下两种命令中的一种：

$\bf SMJER~n$：在 Dominik 说完第 $n$ 个字母之后，他必须开始按照与当前方向相反的方向念字母。

$\bf UPIT~n~x$：Dominik 需要回答在他念的前 $n$ 个字母中，字母 $x$ 出现了多少次。

你需要对于每次 $\bf UPIT~n~x$ 命令输出答案。

## 思路

第一眼应该就可以看出来这是一道模拟题。

思路具体如下：

首先输入，如果是 **SMHER** 指令，那么将枚举方向变换，可以用这个式子 $(fx=-1,fx=1):$ 负一代表反方向，一代表正方向，如果要将 $fx$ 更换，可以用下面这个式子。

```cpp
fx=0-fx；
```

如果是 **UOIT** 指令，那么就输出答案。

$ans_i=$ 第 $i$ 个字母目前一共被念了多少次，$number$ 代表现在一共念了多少个单词，$now$ 代表现在要念哪一个单词。

## 代码

思路都有了，上代码！

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int MAXN=30;
int ans[MAXN];
int main(){
	int q,number=0,now=0,fx=1;
	cin>>q;
	while(q--){
		string s;
		int n;
		char ch;
		cin>>s>>n;
		if(s=="UPIT"){
			cin>>ch;
		}
		while(number!=n){
			now+=fx;
			if(now==27){
				now=1;
			}
			else if(now==0){
				now=26;
			}
			ans[now]++;
			number++; 
		}
		if(s=="UPIT"){
			int id=int(ch-'a'+1);
			cout<<ans[id]<<endl;
		}
		else{
			fx=0-fx;
		}
	}
	return 0;
}
```
## 注意！
**$now$ 是从 $0$ 开始，因为是先更新 $now$ 的值再更新答案！**

## THE END

---


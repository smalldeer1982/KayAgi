# A 质因数

## 题目描述

定义 $f(x)$ 表示 $x$ 分解质因数后得到的质数个数，例如 $f(6)=2,f(12)=3$。

具体的，令 $x=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$，其中 $p_1,p_2,\ldots,p_k$ 是两两不同的质数，则 $f(x)=a_1+a_2+\cdots + a_k$。

给定一个数 $n$，判断是否存在 $1<m<n$，满足 $f(m)>f(n)$。

## 说明/提示

**【样例解释 #1】**

$f(2)=1$，不存在 $1<x<2,f(x)>1$。

$f(3)=1$，不存在 $1<x<3,f(x)>1$。

$f(4)=2$，不存在 $1<x<4,f(x)>2$。

$f(5)=1$，存在 $f(4)=2$。

$f(12)=3$，不存在 $1<x<12,f(x)>3$。

$f(514)=2$，存在 $f(114)=3$。

**【数据范围】**

对于所有数据，满足 $1\leq T\leq 10^4$，$2\leq n\leq 10^{18}$。详细数据范围如下：

- Subtask #1 (25 pts)： $T,n\le 10$。
- Subtask #2 (35 pts)： $n\le 10^5$。
- Subtask #3 (15 pts)： $T\le 10$，$n$ 在 $[2,10^{18}]$  内均匀随机生成。
- Subtask #4 (25 pts)：没有任何附加限制。


## 样例 #1

### 输入

```
6
2
3
4
5
12
514```

### 输出

```
0
0
0
1
0
1```

# 题解

## 作者：lihanwen12 (赞：38)

萌新的第一篇题解！  
题目大意：我们想要找到一个数字 $m$ 使得 $m<n$ 且 $f(m)>f(n)$，$f(x)$ 表示 $x$ 分解质因数后得到的质数个数。  
显然令 $m=2^k$ 最有可能满足条件，因为这样 $m$ 较小且分解质因数后的质数个数更多。  
举个例子：  
$n=60=2\times2\times3\times5,f(n)=4$。  
$m=32=2\times2\times2\times2\times2,f(m)=5$。  
将 $n$ 不停地除以 $2$ 直到不能整除为止，观察剩余部分（注意 $n$ 可能是 $2$ 的正整数次幂）：  
如果 $n=2^{a_1}\times3$，令 $m=2^{a_1+1},m<n,f(m)=f(n)$ 输出 $0$。  
如果 $n=2^{a_1}\times5$，令 $m=2^{a_1+2},m<n,f(m)=f(n)+1$ 输出 $1$。  
如果 $n=2^{a_1}\times7$，令 $m=2^{a_1+2},m<n,f(m)=f(n)+1$ 输出 $1$。  
$\cdots$  
除了 $1$ 和质数 $3$ 无法满足，其他大于 $3$ 的质数 $P_i$ 都满足 $P_i>2\times2$，即 $m$ 存在。  
代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		while(n%2==0){
			n=n/2;
		}
		if(n==1 || n==3)//n=1表示输入的n是2的整数次幂
			cout<<0<<endl;
		else
			cout<<1<<endl;
	}
	return 0;
}

```


---

## 作者：Suzt_ilymtics (赞：13)

[题面传送w](https://www.luogu.com.cn/problem/P8054)

### Solution

先说结论：

如果一个数分解质因数，质因子 $3$ 的个数 $\le 1$ 个，且剩下的质因子均为 $2$，那么输出 $0$，否则输出 $1$。

为什么是对的？

一种证明方法是打表，下面是较为严谨的证明。

设 

$$
x = p_{1}^{a_{1}} p_{2}^{a_{3}} \cdots p_{k}^{a_{k}}
$$

那么 $f(x) = a_1 + a_2 + \cdots + a_k$。

假设 $x$ 有两个质因子 $3$，把他们拿出来，并把 $2^3$ 放进去，得到一个新数 $y$，即 $y = \frac{x}{3^2} \times 2^3$。

那么 $f(y) = f(x) - 2 + 3 > f(x)$，并且由于 $3^2 > 2^3$，显然有 $y < x$，因此此时答案为 $1$。

假设 $x$ 有一个质因子 $p_i > 3$，那么 $p_i$ 至少为 $5$。把 $p_i$ 拿出来，把 $2^2$ 放进去，得到一个新数 $y$，即 $y = \frac{x}{p_i} \times 2^2$。

那么 $f(y) = f(x) - 1 + 2 > f(x)$，并且由于 $p_i > 2^2$，显然有 $y < x$，因此此时答案为 $1$。

上述结论得证。

下面是代码：

```cpp
/*
Work by: Suzt_ilymtics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e6+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int T, x;

int read() {
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0', ch = getchar();
    return f ? -s : s;
}

signed main()
{
    T = read();
    while(T--) {
        x = read();
        int cnt2 = 0, cnt3 = 0;
        while(x % 2 == 0) cnt2 ++, x /= 2;
        while(x % 3 == 0) cnt3 ++, x /= 3;
        if(x != 1) puts("1");
        else if(cnt3 > 1) puts("1");
        else puts("0");
    }
    return 0;
}

```

---

## 作者：苏联小渣 (赞：4)

### 题目大意

定义 $f(x)$ 为 $x$ 分解质因数后的约数个数，如 $18=2 \times 3^2$，所以 $f(18)=1+2=3$。求是否存在 $1 < m < n$ 满足 $f(m)>f(n)$。

### 分析

看到这题很容易想到暴力解法，每一次统计分解后的素数个数为 $k$，如果 $2^{k+1}<n$ 即存在，否则不存在。时间复杂度~~略微~~超了，可以拿 $60$ 分，优化一下应该可以卡着过。

下面说正解，同赛时思路。

首先可以先用暴力代码打表小数据，进行分析。贴个暴力打表代码：[Code](https://www.luogu.com.cn/paste/a6t2n315)

然后我们打表可以发现：输出 $0$，即不满足条件的数分别为：

$$2,3,4,6,8,12,16,24......$$

分解一下质因数，发现是

$$2,3,2\times 3,2^2,2^2\times 3,2^3,2^3\times3,2^4......$$

总结一下规律，就是：

$$A=\{2^k|k \in \mathbb{Z_+}\}\cup \{2^k \times 3|k \in \mathbb{N}\}$$

赛时用这个规律直接过了，下面考虑证明。

**证明**：我们分类讨论：

- 对于一个数 $x=2^k$，在小于它的数中，若存在一个数 $p$，满足 $f(p)>f(x)$，由 $x$ 中有 $k$ 个质数可知，$p$ **最小**为 $2^{k+1}>2^k$，这与已知矛盾。

- 对于一个数 $x=2^k \times3$，在小于它的数中，若存在一个数 $p$，满足 $f(p)>f(x)$，由 $x$ 中有 $k+1$ 个质数且 $3>2$ 可知，$p$ **最小**为 $2^{k+2}>2^k\times3$，这与已知矛盾。

至此，集合 $A$ **存在性**已经证明。接下来要证明其**唯一性**，即除此以外，没有别的数。

- 对于一个数 $y \notin A$，设其表示为 $y=p_1^{a_1}p_2^{a_2}...p_k^{a_k}$，$\{p\}$ 中皆为质数。假设 $\{p\}$ 从小到大排列，令 $s=\sum a$。

- 若 $3 \notin \{p\}$，则 $\{p\}$ 中至少存在一个数 $p_x\ge5>2^2$。构造一个数 $z=2^{s+1}=2^s \times 2$，由 $5 > 2^2$ 知有 $y>z$ 且 $f(y)=s<s+1=f(z)$，则满足题目条件，输出 `1`。

- 若 $3 \in \{p\}$，同理可得一定满足条件。证明过程类似，故略。

集合 $A$ 的唯一性证毕。

最后考虑如何实现：如果输入的数 $n$ 可被 $3$ 整除，就除 $3$，再判断是否为 $2$ 的整数次幂即可。

对于判断 $2$ 的整数次幂，给出两种方法：

**方法 1**：位运算

一个数 $n$ 为 $2$ 的整数次幂的充要条件为 `n & (n-1) == 0`，故可用此判断。这个做法赛时可以卡到 $14ms$。 

**方法 2**：数学函数。

位运算不熟的同学可以看这里。一个数 $n$ 为 $2$ 的整数次幂的充要条件也可表述为 $\log_2n$ 为整数。只需使得 `floor(log2(n)) == ceil(log2(n))` 即可。可直接调用 `log2(参数)` 函数。这个做法会稍慢一点。

### [Code](https://www.luogu.com.cn/paste/56pxto4t)

---

## 作者：InterN_NOT_FOUND (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/T206731?contestId=60188)

~~唯一一道AC的。~~

上来看了一眼 $n$ 的数据范围：$10^{18}$ ，

于是马上意识到这是一道~~暴力~~数学题。

## 推导过程
让我们观察一下样例，先看一下输出 $0$ 的：

$2=2^1$.

$3=2^0 \times 3$.

$4=2^2$.

$12=2^2 \times 3$.

再看一下会输出 $1$ 的：

$5=2^0 \times 5$.

$514=2^1 \times 257$.~~（不要在乎题目给的恶臭的样例说明）~~

我们发现，似乎输出 $0$ 的样例都只有 $2$ 或 $3$ ，而输出 $1$ 的样例都出现了一些大于 $3$ 的质因子（比如 $5$ , $257$），而且这样写确实能AC。

## 证明
由于 $3 \times 3 > 2 \times 2 \times 2$ ，且 $2$ 个 $3$ 比 $3$ 个 $2$ 拆成的数更少，所以如果一个数中出现了**大于1个的不等于2的质因子**，我们一定可以找到一个小于这个数的数，且质因子数比这个数多。

## 代码实现
~~我知道你们只看这个。~~
```cpp
#include<bits/stdc++.h>
#define int long long//n达到了10^18会爆int，记得开long long
#define Output_0 0
#define Output_1 1
using namespace std;
inline bool isnum(char ch){return ch>='0'&&ch<='9';}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isnum(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isnum(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void out(int x,char ch){
    if(x<0){putchar('-');x=-x;}
    if(x>9)out(x/10,'/');
    putchar(x%10+'0');
    if(ch=='l')putchar('\n');
    if(ch=='s')putchar(' ');
}
//习惯用缺省源

int T=read(),n;
signed main()
{
	while(T--){
		n=read();
		while(n%2==0){//把其中所有的质因子2除尽
			n/=2;
		}
		if(n<=3)out(Output_0,'l');//剩余的不等于2的质因子之积不大于3，即不等于2的质因子只有1个或没有，输出0。
		else out(Output_1,'l');//剩余的不等于2的质因子之积大于3，即出现了大于1个的不等于2的质因子，输出1。
	}
	return 0;
}
```


---

## 作者：MY（一名蒟蒻） (赞：3)

[P8054 A 质因数](https://www.luogu.com.cn/problem/P8054)

## 前言

洛谷的第一百场月赛！这场小月赛整场只会一道的菜鸡就是我了。

重新讲一遍题目：有没有一个比 $n$ 小的数，分解质因数后质因数（可重）的个数比 $n$ 的多。

这篇题解只是记录下考场时的想法，可能能够优化，不过能过就是好的。

## 思考过程

首先想到的是讨论奇偶。因为奇数的情况非常简单。由题意，以下的奇数均不包括 $1$ 。  
联系题面可以发现，奇数中除 $3$ 外的数都存在合法的 $m$ （这里的合法指输出为 $1$ ）。

证明如下：

比 $3$ 大的最小奇数是 $5$ ， $5 > 2\times2$ ，所以如果奇数 $n$ 存在比 $3$ 大的奇数质因子，那么显然有合法的 $m$ 与 $n$ 对应。

而 $3\times3 > 2\times2\times2$ ，所以奇数中只有 $3$ 不存在合法的 $m$ 。

接下来考虑偶数。

只要把偶数变成奇数，就可以按照以上的做法处理。

因为 $2$ 是最小的质数，设 $n$ 的质因数个数共有 $k$ 个，所以 $2^k \le n$ 。

于是我们把这里面相同的 $2$ 全都去掉， $n$ 就变成了一个奇数。

---

或者这样讲：  
设 $m=2^x\times y$ , $y$ 是一个奇数。  
若 $y$ 是质数，因为 $5 > 2\times2$ ，所以只有 $y=3$ 时，不存在合法的 $m$ 。
若 $y$ 是合数，因为最小的既是奇数又是合数的数 $9=3\times3>2\times2\times2$ ，所以所有既是奇数又是合数的 $y$ 都有合法的 $m$ 与之对应。

---

于是我们得到了以下的代码。很好理解就没有注释了。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cmath>

using namespace std;

typedef long long ll;

int main()
{
//  freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int t;
	ll x;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld",&x);
		if(x == 3) printf("0\n");
		else if(x&1) printf("1\n");
		else
		{
			while(!(x&1)) x>>=1;
			if(x > 4) printf("1\n");
			else printf("0\n");
		}
	}
//  fclose(stdin); fclose(stdout);
    return 0;
}
```

***Thanks for your reading !***

---

update ：发现我们的第二种讲法具有普适性，分析以上代码也可知我们对于奇偶分类是没有必要的。

所以我们直接写

```cpp
while(t--)
{
	scanf("%lld",&x);
	while(!(x&1)) x>>=1;
	if(x > 4) printf("1\n");
	else printf("0\n");
}
```

即可。

---

## 作者：3a51_ (赞：2)

### 题目大意

给你一个正整数 $n$ ，设 $n$ 的分解质因数中含有 $f_n$ 个质因数，求是否存在正整数 $m$ 使得 $m$ 小于 $n$ 且 $f_m$ 大于 $f_n$ 。

### 思路分析

可以发现，$f_m$ 至少比 $f_n$ 大 $1$。所以需要把 $f_n$ 中的 $k$ 个质因数替换为 $k+1$ 个质因数。于是我们有两种替换：

1. 将大于等于 $5$ 的质因子替换为两个 $2$；
2. 将 $j$ 个 $3$ 替换为 $j+1$ 个 $2$，且 $j$ 不等于 $1$。

这样可以保证 $m$ 小于 $n$,如果能够这样替换，就输出```1```，否则输出```0```。

### code

```cpp
#include<iostream>
using namespace std;
int main()
{
	long long t;
	cin>>t;
	while(t--)
	{
		long long x,j=0;
		cin>>x;
		while(x%2==0)
			x/=2;//去掉2
		while(x%3==0)
			x/=3,j++;//去掉3，统计3的个数
		if(x>=2 || j>=2)//如果去掉2,3后还有多余的质因数，或者3的个数大于等于2
			cout<<1<<endl;
		else
			cout<<0<<endl;
	}
	return 0;
}
```

---

## 作者：WER_very_fox (赞：2)

### 题目描述
定义 $f(x)$ 表示 $x$ 分解质因数后得到的质数个数，例如 $f(6)=2,f(12)=3$。

具体的，令 $x=p_1^{a_1}p_2^{a_2}\dots p_k^{a_k}$，其中 $p_1,p_2\dots p_k$ 是两两不同的质数，则 $f(x)=a_1+a_2\dots + a_k$。

给定一个数 $n$，判断是否存在 $1<m<n$，满足 $f(m)>f(n)$。

---
### 解析
解法 1：（ $25pts$ ）

按题意模拟，暴力寻找即可。

---
解法 2：（ $60pts$ ）

发现当 $m=2^k$ 且 $m\le n<2\times m$ 时，$f(m)$ 有最大值，此时仅需算出 $f(m)$ 与 $f(n)$，并比较大小。

---
解法 3：（ $100pts$ ）

发现当 $n$ 有 $\ge5$ 的质因数时，$f(m)>f(n)$。  
另外，$n$ 是 $9$ 的倍数时也满足 $f(m)>f(n)$。

得到当且仅当 $n=2^{a_1}\times3^{a_2}$ 且 $a_2=0$ 或 $1$ 时，不存在 $f(m)>f(n)$，输出 `0`，其余情况均输出 `1`。

AC code:
```cpp
#include<cstdio>
#define ll long long
using namespace std;
ll T,a,b,n;
ll read()
{
    char ch,c=getchar();
	ll v=0,g=1;
    while(c<'0'||c>'9') ch=c,c=getchar();
    if(ch=='-') g=-1;
    while(c>='0'&&c<='9') v=v*10+c-'0',c=getchar();
    return g*v;
}
bool f(ll x)
{
	if(x%3==0)
		x/=3;
	while(x>1)
		if(x%2)
			return 0;
		else
			x>>=1;
	return 1;
}
int main()
{
    T=read();
	while(T--)
	{
		n=read();
		if(f(n))
			printf("0\n");
		else
			printf("1\n");
	}
    return 0;
}
```

---

## 作者：Skykguj (赞：0)

### 题目描述

定义 $f(x)$ 表示 $x$  分解质因数后得到的质数个数

给定一个数 $n$，求是否存在一个数 $m (1 < m < n)$，，使得 $f(m) > f(n)$。



### 解题思路

先看一下数据范围，$1\leq T\leq 10^4$，$2\leq n\leq 10^{18}$，暴力肯定 TLE，我们需要考虑一种复杂度较低的算法。

根据小学学过的知识可知，分解质因数得到的数字一定是质数，我们可以枚举一部分数字的答案，找找其中的规律。

算出答案后，我们去除 $1$ 的情况，只考虑为 $f(m) > f(n)$ 为 false 的情况，得到一个数列，观察数列发现只有 $x$ 格式为 $2^n$ 或者 $3 \times 2^n$ 时 $f(m) > f(n)$ 才不成立，得到结论后，这道题就很简单了。

注意要开 `long long` ！！！



### 程序实现

如何判断 $x$ 格式为 $2^n$ 或者 $3 \times 2^n$ 呢？我们可以使用 `cmath` 自带的 `log2()` 函数，如果 $\log2(x)$ 后是整数，那它的格式一定是 $2^n$。如果 $\log2(\dfrac{x}{3})$ 后是整数，那它的格式一定是 $3 \times 2^n$。

```cpp
#include <iostream>
#include <cmath> // log2() 函数需要的头文件

typedef long long ll; // 不开 long long 见祖宗！

int main()
{
    long long t, n;
    std::cin >> t;
    while (t--)
    {
        std::cin >> n;
        double x1 = log2(n);
        double x2 = log2(n / 3.0); // 注意处理精度问题！
        if (x1 == (ll)x1 || x2 == (ll)x2)
            puts("0");
        else
            puts("1");
    }
    return 0;
}
```

---

## 作者：happybob (赞：0)

明显看到，题目时间限制 $500ms$，暴力肯定过不了。但是我们观察一下，需要 $m < n$ 且 $f(m) > f(n)$，我们先用暴力看一下规律：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

int sum(int x)
{
	int cnt = 0, q = x;
	for (int i = 2; i <= x; i++)
	{
		if (q % i == 0)
		{
			while (q % i == 0)
			{
				q /= i;
				cnt++;
			}
		}
	}
	return cnt;
}

signed main()
{
	int n = 1000;
	for (register int i = 1; i <= n; i++)
	{
		int x = i;
		int g = x;
		int k = sum(g);
		bool f = true;
		for (register int j = 2; j < g; j++)
		{
			if (sum(j) > k)
			{
				goto end;
				f = false;
				break;
			}
		}
		if (f)
		{
			cout << i << " ";
			k = i;
		}
		end: {}
	}
	return 0;
}
```

显然，输出 `0` 的很少，我们看一下最终的输出：

```
1 2 3 4 6 8 12 16 24 32 48 64 96 128 192 256 384 512 768
```

$4+2^1=6$

$6+2^1=8$

$8+2^2=12$

$12+2^2=16$

$16+2^3=24$

$24+2^3=32$

……

也就是说，对于每一个询问，从 $4$ 开始，第一次加两个 $2^1$，第二次加两个 $2^2$，第三次加两个 $2^3$……，直到加到这个询问的数。如果正好到了这个询问的数，那就输出 `0`，不然输出 `1`。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

signed main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int x, now = 4, plus = 2;
		scanf("%lld", &x);
		if (x <= 4) printf("0\n");
		else
		{
			bool f = false;
			while (true)
			{
				now += plus;
				if (now == x)
				{
					printf("0\n");
					f = true;
					break;
				}
				now += plus;
				if (now == x)
				{
					printf("0\n");
					f = true;
					break;
				}
				plus <<= 1;
				if (now > x) break;
			}
			if (!f)
			{
				printf("1\n");
			}
		}
	}
	return 0;
} 
```


---


# [COCI 2011/2012 #4] KINO

## 题目描述

电影院的每排有 $N$ 个座位。座位分为普通座位（$\texttt S$）和爱心座位（$\texttt L$）。其中，爱心座位总是两两出现。

每排座位的相邻两个座位之间都设有一个杯架（除了两个爱心座位之间外）。特别地，一排座位的两侧也都设有杯架。

现有 $N$ 位顾客坐满这 $N$ 个座位，求最多有多少人能够使用杯座。

## 说明/提示

**【样例 3 解释】**

若用 $\texttt *$ 来表示杯座，那么座位情况如下：

$\texttt{* S * L L * L L * S * S * L L *}$

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le N \le 50$。

**【提示与说明】**

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 1 KINO_。**

**本题分值按 COCI 原题设置，满分 $50$。**

## 样例 #1

### 输入

```
3
SSS```

### 输出

```
3```

## 样例 #2

### 输入

```
4
SLLS```

### 输出

```
4```

## 样例 #3

### 输入

```
9
SLLLLSSLL```

### 输出

```
7```

# 题解

## 作者：lemon_qwq (赞：15)

~~学霸题，数杯架~~。

[更好の阅读体验](https://610335.blog.luogu.org/solution-p8080)。

## $\mathbf{sol}$。

这道题我们可以把普通座位和爱心座位的总数统计起来，然后判断是否有位置就可以了。大家听到这个方法可能会疑惑爱心座位什么判断，但爱心座位一定是双数，所以把统计的爱心座位除以二再加一就可以算出空隙了，普通座位不用进行任何判断，空隙就是原数。

如果您没有听懂，让我举个例子。

假设座位是 $\mathbf{\color{green}{SS}\color{red}{LLLL}\color{green}{SS}}$，这里我给大家说一个大家常犯的误区，中间的四个 $\mathbf{\color{red}L}$ 不代表他们四个人中间都没有杯架，而是他们之间两两划分，我用星号代表杯架，那中间部分就是 $\mathbf{\color{black}{*}\color{red}{LL}\color{black}{*}\color{red}{LL}\color{black}{*}}$，所以我们可以推导出爱心座位的杯架数量为 `love/2+1`，我们得到爱心座位的杯架数量为 $3$，普通座位的数量为 $4$，所以总数为 $7$，我们用图表示一下，就是 $\mathbf{\color{black}{*}\color{green}{S}\color{black}{*}\color{green}{S}\color{black}{*}\color{red}{LL}\color{black}{*}\color{red}{LL}\color{black}{*}\color{green}{S}\color{black}{*}\color{green}{S}\color{black}{*}}$。

## $\mathbf{ac\ code}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ss,ll;//ss为普通座位的数量，ll为爱心座位的数量。
char s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		if(s=='S')ss++;//查询普通座位的数量。
		else ll++;//查询爱心座位的数量。
	}
	cout<<min(ss+(ll/2+1),n);//解释一下为什么要判断最小，因为在样例 1 的情况下杯架比人多，而我们要判断多少人能使用杯座。
	return 0;//华丽的结尾
}
```


---

## 作者：cff_0102 (赞：5)

$upd\ at\ 2022/1/29\ :$ 改正语言错误。

### 这是一篇 $C++$题解

[题目传送门](https://www.luogu.com.cn/problem/P8080)

首先看到这个题目描述：
>每排座位的相邻两个座位之间都设有一个杯架（除了两个爱心座位之间外）。

对比样例 $3$ 的说明，可以发现题目这里是表述不清。实际上，我们可以认为爱心座位的个数是偶数，将它们两两分组，每组之间设有一个杯座。

那么我们知道，每一个杯座一定要尽量地被利用。

我们就分 $2$ 种情况。

1. 这一排有爱心座位。这时，杯架的数量（设为 $m$ ）一定满足 $m\le n$ 。大家可以画图理解一下。我们以一对爱心座位为分界线，左边的杯架都匹配给右边的人，右边的杯架反之，如下图。让每一个杯架都匹配给旁边的人，这种情况输出 $m$ 。
![](https://cdn.luogu.com.cn/upload/image_hosting/ooi10761.png)
2. 这一排只有普通座位。这时，每一个人都有杯座。输出 $N$ 。

接着上代码（**对照理解，不要抄袭**）：

```cpp
#include<bits\stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(false);//给cin和cout加速 
	string s;
	bool flag=0;//有没有爱心座位L 
	int n,sum=1;//刚开始最左边有一个杯座
	//sum记录的是杯座的数量，后面是从左到右记录，每一个座位对应了右边相应的杯座（或右边没有杯座） 
	cin>>n>>s;
	for(int i=0;i<n;i++){//判断是否有爱心座位的同时统计杯座数量 
		if(s[i]=='S'/*注意是单引号*/){
			sum++;//一个普通座位右边配一个杯座 
		}else{
			flag=1;//有爱心座位 
			sum++,i++;//爱心座位是两个两个出现，出现第一个，将i+1跳过第二个，右边有一个杯座，sum+1 
		} 
	}
	if(flag){//有爱心座位
		cout<<sum;//情况1 
	}else{//没有爱心座位 
		cout<<η;//情况2 
	} 
	return 0;
}//不要抄袭不要抄袭不要抄袭听我的不要抄题解这个只是用于对照理解的
```

这一道题实际还是很简单的，时间 $O(n)$ ，空间 $O(n)$ ，而且数据范围极小。也希望管理可以通过这篇题解。

---

## 作者：yeshubo_qwq (赞：5)

## 思路
设 $b_{i}$ 表示 $i$ 个座位左边的杯架有没有被使用，$0$ 为未被使用，$1$ 为已经使用。

然后，直接从第一个位置到最后一个位置，能用杯架就用，并累加答案。

但是我们注意到：每一对爱心座位之间没有座位。

所以，我们不妨遇到爱心座位就将一对一起做掉。

具体细节请看代码注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,ans,b[55];
char a[55];
int main(){
    cin>>n>>a+1;
    for(i=1;i<=n;i++)
        if(a[i]=='S'){//普通座位 
            if(b[i]==0)b[i]=1,ans++;//座位左手边 
            else if(b[i+1]==0)b[i+1]=1,ans++;//右手边 
        }
        else{//爱心座位 
            if(b[i]==0)b[i]=1,ans++;//左边一个座位左手边 
            // 左边一个座位右手边 & 右边一个座位左手边 没有杯架 
            if(b[i+2]==0)b[i+2]=1,ans++;//右边一个座位右手边 
            i++;//因为做了两个座位所以i还要+1 
        }
    return cout<<ans,0;
}
```


---

## 作者：SunSkydp (赞：5)

$N$ 只有 $50$，所以直接模拟，贪心。

我们可以寻找那些不能使用杯座的人，再反求出能使用杯座的人，而 $S$ 的两侧各有一个杯座，所以我们只需要考虑 $L$ 是否能使用杯座。

因为样例有点水，所以先自己列举了几个样例进行研究:

- $\texttt{*S\ \ *L\ \ L*\ \ L\ \ L*\ \ S*}$ ：第 $3$ 个 $L$ 不能使用杯座。

- $\texttt{*S\ \ *L\ \ L*\ \ L\ \ L*\ \ L\ \ L*}$：第 $3$，$5$ 个 $L$ 不能使用杯座。

- $\texttt{*L\ \ L*\ \ L\ \ L*\ \ L\ \ L*\ \ L\ \ L*\ \ S*}$：第 $3$，$5$，$7$ 个 $L$ 不能使用杯座。

由此发现，再连续的一些 $L$ 中，第 $n$ 个 $L$ 不能使用杯座满足 $n \not = 1$ 且 $n$ 为奇数。 

还有一种情况，即 $\texttt{*S\ \ *S\ \ *L\ \ L*\ \ S*\ \ L\ \ L*}$ 中第 $3$ 个 $L$ （即第 $2$ 段连续的 $L$ 中第 $1$ 个）不能使用杯座，所以又可以发现当出现 $\texttt{SLL}$ 的情况且在此之前出现过 $L$（如样例 $2$）时，其中第 $1$ 个 $L$ 不能使用杯座。

综上两种情况所述，我们维护两个变量 $x$，$y$，$x$ 用来维护连续的 $L$ 中第奇数个 $L$，$y$ 用来维护情况二中在此之前是否出现过 $L$。

最后，上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, a, x, y;
string s;
int main() {
    scanf("%d", &n);
    cin >> s;
    for(int i = 0; i < n; i++) {
        ans++;
        if(s[i] != 'L') x = 0;
        else x++, y++;
        if(i > 0 && s[i] == 'L' && s[i - 1] == 'S' && s[i + 1] == 'L' && y != 1) ans--;
        if(x != 1 && x % 2 == 1) ans--;
    }
    printf("%d\n", ans);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/68271401)，吸氧实测 $32ms$。

---

## 作者：pandaSTT (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8080)

[更好的阅读体验？](https://www.luogu.com.cn/blog/557117/solution-p8080)

## Thinking

首先转化问题。

问题为：**最多有多少人能够使用杯座。** 其实就是杯座的数量，但如果杯座的数量大于人数，所有人都能使用杯座。

对于杯座的数量，题目明确给出了杯座的分布规律，按照题目要求模拟即可。若遇到普通座位，则杯座数量加一；若是爱心座位，则跳过下一个爱心座位，杯座数量加一。

特别注意，**一排座位的两侧也都设有杯架。** 因此我们可以提前将答案加二，在讨论每个座位时，我们需要判断是否为当前排最后一个座位即可。

## Coding

```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,ans=2;
  string s;
  int main(){
      cin>>n>>s;
      for(int i=0;i<n;i++){
          if(s[i]=='S'){
              if(i<n-1){
                  ans++;
              }
          }
          else{
              if(i+1<n-1){
                  ans++;
              }
              i++;
          }
      }
      cout<<min(n,ans);
      return 0;
  }
```


---

## 作者：JustinXiaoJunyang (赞：4)

这道题是 COCI 的一道古老题,~~大佬请跳过思路分析～~~

思路分析：

首先，读入 $N$，以及一个字符串。（我们就设成 $S$ 呗）

接着，开始递推全过程。

1. 不难发现，爱心座位 $\mathtt{L}$ 是两个座位之间一个杯座，普通座位 $\mathtt{S}$ 就一个座位配一个杯座。

2. 利用我们新建的字符串 $seat$ 把杯盘加进去 $\mathtt{*}$，其实就是几个条件。

3. 我们把字符串弄好了，接着我们分几种情况 $\mathtt{*L}$ $\mathtt{*S}$ $\mathtt{L*}$ $\mathtt{S*}$ 分别统计杯座数量。

参考代码：

按照上面的步骤即可。

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    int n;
    string s;
    cin >> n >> s;
    string seat = "";
    int ans = 0;
    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == 'S') seat += "S*";
        if (s[i] == 'L')
        {
            seat += "LL*";
            i++;// 因为是两个爱心座位
        }
    }
    int len = seat.size();
    seat = "*" + seat;// 开个挂
    for (int i = 0; i < len; i++)
    {
        if (seat[i] == '*' && i != len - 1)// *S 或者 *L
        {
            ans++;
            i++;
        }
        else if (seat[i] == 'S')// S*
        {
            ans++;
            i++;
        }
        else if (seat[i] == 'L' && seat[i + 1] == '*')
        {
            ans++;
            i++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：可爱的小于 (赞：3)

题意：求最多有多少人能够使用杯座。

题目思路：由于两旁已有杯座，所以设初值为 $2$ 。如果有一个普通座位，就代表它旁边有一个杯座，计数值加一；但如果是连续两个爱心座位，那么计数值加上一，表示前面那个杯座，同时位置后移一位。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n,sum=2;
int main() {
    cin >> n >> s;
    for(int i=1;i<=n;i++)
        if(s[i]=='S')
            sum++;
        else if(s[i]=='L'&&s[i+1]=='L') {
            i++;
            sum++;
        }
    cout << sum << endl;
    return 0;
}
```


---

## 作者：rzh123 (赞：2)

# P8080 题解  

题目链接：[P8080 \[COCI2011-2012\#4\] KINO](https://www.luogu.com.cn/problem/P8080)  

## 题意理解  

本题题目描述不太清楚，需要根据样例理解：  
   

> 求最多有多少人能够使用杯座。  

实际上看来，“杯座”就是指之前说的“杯架”。

> 每排座位的相邻两个座位之间都设有一个杯架（除了两个爱心座位之间外）。  

根据样例 $3$ 可以知道，这不是说任何两个 `L` 之间都没有杯架，而是说，一组两个连续的 `L` 之间没有杯架，但两组之间是有杯架的，可以理解成每两个 `L` 为一个整体，在决定有没有杯架时相当于一个 `S`。  

## 做法  

读入时可以用 $N \times 2 + 2$ 大小的数组，插空放置杯座。  

从题意可以看出，读取到 `S` 时，直接在左右都放上杯座。难点在于 `L`。  
当读取到 `L` 时，应该检查当前有多少个 `L` 连续出现，如果是奇数个，前面要加杯架，偶数个就不用加。  

根据题意，先插空放置杯架，再贪心求最多有多少人能使用杯架。每个人如果左边有杯架就用左边的，否则如果右边有就用右边的，都没有就真的没有了。  

## 代码

```cpp
#include <cstdio>
#define gc getchar()
#define pc(c) putchar(c)
#define N 57
int n;
char s[N];
int read(){
	int t=0;
	char c=gc;
	while(c<'0'||c>'9') c=gc;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return t;
}
char readc(){
	char c=gc;
	while(c!='S'&&c!='L') c=gc;
	return c;
}
void write(int x){
	if(x<10){
		pc(x|48);
		return;
	}
	write(x/10);
	pc((x%10)|48);
}
int main(){
	int ans=0;
	int l=0;
	n=read();
	s[1]='*';
	for(int i=2;i<=(n<<1);i+=2){
		s[i]=readc();
		if(s[i]=='S'){
			l=0;
			s[i-1]=s[i+1]='*';
		}
		else{
			++l;
			if(l&1){
				s[i-1]='*';
			}
		}
	}
	s[(n<<1)+1]='*';
	for(int i=2;i<=(n<<1);i+=2){
		if(s[i-1]=='*'){
			s[i-1]=0,
			++ans;
		}
		else if(s[i+1]=='*'){
			s[i+1]=0,
			++ans;
		}
		
	}
	write(ans),
	puts("");
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/68218925)  

---

## 作者：TernaryTree (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P8080)
一道很好的栈练习题。

本题的主要数据结构：**栈**。

**栈，就是一种线性数据结构，具有先进后出，后进先出的特点。打个比方，你的寒假作业一份一份发下来，你会一份一份把它叠上去，然后要取出来就是从最上面取出来，最开始发下来的作业是最后一个取出来的。**

那么，我们如何使用栈来解决这题呢？

题目里有一个特性： $\tt L$ 总是成对出现。
也就是说，$\tt L$ 出现的次数总是偶数。

观察 样例#3 解释，发现只有第偶数次出现的 $\tt L$ 后面才会出现杯座。于是，我们可以用一个 `cnt` 来记录 $\tt L$ 第几次出现。

我们可以先忽略最后的一个杯座。

从第一个字符开始，如果是 $\tt S$，那么前面肯定是有一个杯座的，这个 $\tt S$ 就可以与前面的杯座匹配，相当于 杯座入栈，S入栈，S与杯座匹配，S与杯座出栈。一通操作下来，可以发现其实什么都没干。所以，输入 $\tt S$，我们什么也不干。

```cpp
for (int i = 0; i < n; i++) {
    cin >> t;
    if (t == 'S') {
        // cup.push('*');
        // cup.pop();
        // 相当于没有，什么也不干。
    } else {
    	// t=='L'
    }
}
```

那么输入 $\tt L$ 时，我们怎么处理呢？

首先，我们需要将 `cnt++`。

其次，当 `cnt % 2 == 0` 即 `cnt` 为偶数时，后面一定会有一个杯座，所以杯座入栈。

最后，我们需要判断栈顶是不是杯座，如果是，发现 $\tt L$ 与杯座匹配成功，杯座出栈；否则，我们将 $\tt L$ 入栈，表示匹配不成功。

那么输入结束后，栈里有多少 $\tt L$，就说明有多少匹配不成功的字符。但是不要忘了，我们还有最后一个杯座需要处理，最后一个杯座与栈顶匹配，栈顶出栈。

所以，最终的答案就是字符个数-栈的大小。

代码就不难写了：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
stack<char> cup;
int cnt = 0;
char t;

int main() {
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        cin >> t;
        if (t == 'S') {
            // cup.push('*');
            // cup.pop();
        } else {
            cnt++;
            if (cnt % 2 == 0) cup.push('*');
            if (cup.size() && cup.top() == '*') {
                cup.pop();
            } else {
                cup.push('L');
            }
        }
    }

    cup.pop();

    cout << n - cup.size() << endl;

    return 0;
}
```

---

## 作者：skyskyCCC (赞：1)

**前言。**

一道模拟题及字符练习题。

**分析。**

根据题意可知，一排座位的两侧也都设有杯架，所以,答案首先要初始化为 $2$ 。

其次，相邻两个座位之间都设有一个杯架，当座位为 ```S``` 时，肯定是有杯架的消费者，所以，当遇到这种高端消费者，答案肯定要加 $1$ 。

然后，判断 ```LL``` 的情况，因为爱心座位总是两两出现，所以，但遇到时，答案加 $1$ ，自然，我们判断两个连续的爱心座位，不能重复判断，循序变量也要加 $1$ ，去判断下个爱心座位。

(如果大家对第三种情况有疑惑，请见后记)

最终输出答案即可。

**代码。**

按照分析，写代码就简单了。

我是用 ```char``` 类型输入判断的，其实 ```string``` 类型也可以。

代码如下，仅供参考：
```
#include<iostream>
#include<cstring>
#define zzy ios::sync_with_stdio(false)
using namespace std;
char a[55];
int n,ans;
int main(){
    zzy;
    cin>>n;
    for (int i=0;i<n;i++){
    	cin>>a[i];
    }
    ans+=2;
    for(int i=1;i<=n;i++){
        if(a[i]=='S'){
        	ans++;
        }
        else if(a[i]=='L'&&a[i+1]=='L'){
            ans++;
            i++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
``` 
**后记。**

第三种情况：

对于这种模拟题，举例子自然是较为方便的了：

如： ```SLLS``` ，显然，这种两个的爱心座位的没有什么用。

再如： ```SLLLLS``` ,在 $4$ 个及以上的爱心座位中，两两一个，所以，在找到两个爱心座位后，必定会有一个杯架，所以，答案要加 $1$ 。

如有疑问，请在评论区里留言，我会尽力解答的。

---

## 作者：tZEROちゃん (赞：1)

若这一排座位全都是普通座位，那么显然有 $n+1$ 个杯座，如果每增加一对 love 座位，那么就会减少 $1$ 个杯座。

也就是说，杯座的数量 $k$ 就是：

$$ k = n + 1 - \frac{l}{2} $$

其中 $l$ 表示 love 座位的数量。

考虑一个特例，即当 $l=0$ 时，显然全都能用，所以此时应该输出 $n$。

```cpp

int main(){
  int n;
  iocin >> n;
  string s;
  int cnt = 0;
  iocin >> s;
  rep (i, 0, n - 1) {
    if (s[i] == 'L') {
      ++cnt;
    }
  }
  printf("%d", (cnt != 0 ? n + 1 - cnt / 2 : n));
  return 0;
}
```

---

## 作者：int127 (赞：0)

~~一眼题。~~

## $\sf Solution$

本质是求杯架个数与人数之间的最小值。

两个 $\tt L$ 之间没有杯架，可以将其看作一个 $\tt S$，正常计算即可。

例：$\tt *S*LL*LL*S*S*LL*\to*S*S*S*S*S*S*$。

于是杯架个数就是 $\tt S$ 的个数加一。

## $\sf Main\ Code$

```cpp
signed main(){
    cin>>n;getchar();
    for(int i=1;i<=n;i++){
        char sit$;
        cin>>sit$;
        sit[++k]=(sit$=='S');
        if(!sit[k]&&!sit[k-1]) sit[--k]=true;
    }
    cout<<min(k+1,n);
    return 0;
}
```

---

## 作者：SRIGT (赞：0)

## P8080题解

一道入门级的模拟题，由题意可得，凡是坐在 S 座位的观众都可以使用杯架；L 座的（非端点）每两个人有一个可以使用杯架（默认杯架仅一人可以使用），因此可以得到以下代码

```cpp
#include<iostream>
using namespace std;
char a[202];
int main()
{
   int n,i,t=1;//由于 n 取值大于等于1，故计数器 t 设为一 
   cin>>n;
   for(i=1;i<=n;i++)
      cin>>a[i];
   for(i=1;i<=n;i++)
   {
      if(a[i]=='S')
         t++;//每个 S 座都可以使用 
      else if(a[i]=='L'&&a[i+1]=='L')
         t++,i++;//每两个 L 座有一人可以使用 
   }
   cout<<t;
   return 0;
}
```
注意：第十五行要跳过已经检测过的 L 座

求通过 QAQ 

---

## 作者：basachenboming (赞：0)

# **思路**

一道简单模拟，初始化计数器 $ans$ 为 $n+1$ 

如果 $a[i]$ 与 $a[i+1]$ 均为 $L$ 令 $ans-1$ 并令 $i+1$ 即可。

注意如果 $i$ 不加 $1$ 就会少算导致错误。

如果 $ans>n$ 则输出 $n$ 即可。

**AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[51];
int main()
{
	int n;
	cin>>n;
	int ans=n+1;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]=='L'&&a[i+1]=='L')
		{
			ans--;
            i++;
		}
	}
    if(ans>n)
    {
    	cout<<n;
    	return 0;
	}
	cout<<ans;
	return 0;
 } 
```


---


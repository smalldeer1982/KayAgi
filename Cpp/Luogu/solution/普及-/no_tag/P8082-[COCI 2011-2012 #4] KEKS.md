# [COCI 2011/2012 #4] KEKS

## 题目描述

给定正整数 $N,K$ 和一个 $N$ 位数，求在 $N$ 位数中删除 $K$ 位后剩下的数的最大值。

## 说明/提示

**【数据规模与约定】**

- 对于 $50\%$ 的数据，$N \le 1000$。
- 对于 $100\%$ 的数据，$1 \le K \lt N \le 5 \times 10^5$。

**【提示与说明】**

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 3 KEKS_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
4 2
1924```

### 输出

```
94```

## 样例 #2

### 输入

```
7 3
1231234```

### 输出

```
3234```

## 样例 #3

### 输入

```
10 4
4177252841```

### 输出

```
775841```

# 题解

## 作者：Starw (赞：26)

### 思路：

我们贪心地想，要想要删完后的这个数越大，那么越在前面的数就要越大，那我们就可以用一个单调栈，不断将栈顶的数弹出，一直到删数次数为 $0$ 或栈空或栈顶的数比要加入的数大，然后加入那个数，最后遍历一次栈，还要考虑 $k$ 还有剩余的情况，做法就是把后面还剩下的 $k$ 个数不统计，所组成的数就为答案。

### 代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
using namespace std;
char s[MAXN];
int st[MAXN],top;//栈 
int main(){
	int n,k;
	scanf("%d%d%s",&n,&k,s+1);
	for(int i=1;i<=n;i++){
		int x=s[i]-'0';
		while(k&&top&&st[top]<x)k--,st[top--]=0;//弹出操作 
		st[++top]=x;//加入操作 
	}
	for(int i=1;i<=top-k;i++)//遍历栈 不遍历后面剩余的 k 个数
		printf("%d",st[i]);//输出答案 
	return 0;
}
```
upd on 2024.8.13 修了 $k$ 还有剩余的情况

---

## 作者：可爱的小于 (赞：9)

[原题传送门](https://www.luogu.com.cn/problem/P8082) [采用博客食用更佳](https://keaidexiaoyu.blog.luogu.org/solution-p8082)

**算法标签：贪心。**

**题目描述：** 求在 $N$ 位数中删除 $K$ 位后剩下的数的最大值。

**做题思路：**

**1.** 输入。

**2.** 采用贪心的思维，从**最高位**开始循环，因为越前数位的数越大，数值也就越大。

**3.** 循环判断条件：如果前一位的小于后一位的数，说明可以让后一位数代替前一位数，**跳出循环**。

**4.** 当退出循环时，删除此数位上的数。

**5.** 到最后将剩余的数输出即可。

**题解：**

采用双重循环，核心代码如下：

```cpp
while(k--){
		for(i=0;i<s.size()-1&&s[i]>=s[i+1];i++);
		s.erase(i,1);
	}
```

[首 A 记录](https://www.luogu.com.cn/record/68223517)

---

## 作者：RockyYue (赞：4)

# 解题思路

感谢管理大大审核~

看题解区的大佬们用的都是单调栈，本蒟蒻献上一篇线段树题解。

整个数最大，首先位数是确定的，则肯定优先考虑高位大小。

大体思路就是从前向后依次求出每一位的值（好像是废话）。

- 对于第 $i$ 位，首先确定这个数在字符串中的位置哪个区间里。
对于左边界，在上一个数后面（第一个数就是 $1$）；对于右边界，右边肯定要有 $n-k-i$ 个数，最大是 $k+i+1$。

- 然后我们就是求出这个区间中的最大值，当然下标也要确定。这一点就可以用线段树模板预处理，方法略。

- 接着就是每次更新区间边界，然后 $\log n$ 查询，总时间复杂度为 $O(k \log n)$。

# 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
int n, k;
string a;
struct Sec {
	int maxv, idx;
} sec[N << 2];
inline Sec Max(Sec x, Sec y) {
	if (x.maxv != y.maxv) {
		return x.maxv > y.maxv ? x : y;
	}
	return x.idx < y.idx ? x : y;
}
inline void pushup(int id) {
	sec[id] = Max(sec[id << 1], sec[id << 1 | 1]);
}
void build(int id, int l, int r) {
    if (l == r) {
    	sec[id] = {a[l], l};
        return;
    }
    int mid = l + r >> 1;
    build(id << 1, l, mid);
    build(id << 1 | 1, mid + 1, r);
    pushup(id);
}
Sec query(int id, int l, int r, int x, int y) {
    if (x <= l && r <= y) {
		return sec[id];
    }
    int mid = l + r >> 1;
    Sec res = {-1, 0};
    if (x <= mid) {
        res = Max(res, query(id << 1, l, mid, x, y));
    }
    if (y > mid) {
        res = Max(res, query(id << 1 | 1, mid + 1, r, x, y));
    }
    return res;
}
string res;
int main() {
	ios :: sync_with_stdio(0);
	cin >> n >> k >> a;
	a = " " + a;
	for (int i = 1; i <= n; ++i) {
		a[i] ^= '0';
 	}
 	build(1, 1, n);
	int l = 1, r = k + 1;
	for (int i = 1; i <= n - k; ++i) {
		Sec s = query(1, 1, n, l, r);
		res += to_string(s.maxv);
		l = s.idx + 1;
		++r;
	}
	cout << res << '\n';
	return 0;
}
```

Good Good 贺题，Day Day Up！！

---

## 作者：HgSO4qwq (赞：3)

本人语文不好，请见谅

[P8082 传送门](https://www.luogu.com.cn/problem/P8082)

## 题意

给定一个 $N$ 位的整数，问将其删掉 $K$ 位后组成的最大整数是多少。

## 思路

我们一看数据范围：$1\le K<N\le 5\times10^5$ , 就可以发现这题是   $\text O(N)$ 的。

我们发现，一个数有以下一个特性：
为了使这个数最大，我们要尽可能的使这个数的比较高的位置大。~~这不是废话吗~~

所以，我们把在一个数前面的所有小于它的数全部删去就行了。
为了方便操作，我们把结果放在一个栈里存储（我命名为了 $q$ ），每删一个数，$K$ 就 $-1$。

我们来举个栗子：

$N=4,\ K=3,\ num=1924$

注：$q$ 里灰色表示被替换，已经没了的数

| 操作 | $q$ | $K$ |
| :-----------: | :-----------: | :-----------: |
| 把最高位 1 放进队列 | $\color{red}{1}$ | $3$ |
| 把 9 放进队列，把 1 替换 | $\color{lightgrey} 1\ \color{red}9$ | $\color{red}2$ | 
| 把 2 放进队列 | $9\ \color{red}2$ | $2$ |
| 把 4 放进队列，把 2 替换 | $9\ \color{lightgrey}2\ \color{red}4$ | $\color{red}1$ |

注意！这时 $K$ 仍不为 $0$，表明我们还要删去一个数。这时我们又发现了一个特性： 在循环结束时 $q$ 不存在正序对！所以最后一个数一定是最小的。于是我们把末 $K$ 位删去就行了。

| 操作 | q | K |
| :-----------: | :-----------: | :-----------:|
| 把 4 删去 | $9\ \color{lightgrey}4$ | $\color{red}0$ |

最后把 $q$ **逆序** 输出。

## Code

```cpp
#include<cstdio>
#include<stack>
#include<iostream>
using namespace std;

stack<int> q,t;// q 表示最终的数，但是因为它是反着的, 所以需要 t 来反转这个数

int main()
{
	int n,m;
	cin>>n>>m;// m=k
	string s;
	cin>>s;
	for(int i=0;i<n;i++)
	{
		if(m) 
		{
			while(!q.empty()&&(s[i]-'0'>q.top()))
			{
				if(m==0) break; // 必须写上要不然 WA 40pts
				q.pop();
				m--;// 删了一个数
			}
		}
		q.push(s[i]-'0');
	}
	while(m&&!q.empty())
	{
		q.pop();
		m--;
	}
	while(!q.empty())
	{
		t.push(q.top());
		q.pop();
	}
	while(!t.empty())
	{
		cout<<t.top();
		t.pop();
	}
	return 0;
}
```

---

## 作者：Dream_weavers (赞：1)

## 题意

有一个 $N$ 位数，求该数在删除 $K$ 位后剩下的**最大值**。

## 思路

用贪心可以想到：要想让剩余的数最大，就让**尽量大**的数字**排在前面**（如 9、8、7），**尽量小**的数字**排在后面**（如 2、1、0）。

我们建立一个 stl 容器（这里推荐用 vector 或 deque 或 stack），每输入一个数字，开始循环判断：如果输入的数字大于容器的末尾，则删除容器末尾，直到不大于末尾为止（若容器为空或 $K=0$，则直接跳出循环）。最后插入该数字。

### 注意

如果输入完所有数字，但 $K\ne 0$，只需删除容器末 $K$ 位即可。



------------


### 举个例子：

令 $T$ 为每次输入的数字，$S$ 为每次剩下最大的数（标红的数字为每次删除的数字）。

    输入：10 4 4177252841

| $S$ | $T$ | $K$ |
| :----------: | :----------: | :----------: |
| $4$ | $4$ | $4$ |
| $4\ 1$ | $1$ | $4$ |
| ${\color{red}4\ 1}\ 7$ | $7$ | $2$ |
| $7\ 7$ | $7$ | $2$ |
| $7\ 7\ 2$ | $2$ | $2$ |
| $7\ 7\ {\color{red}2}\ 5$ | $5$ | $1$ |
| $7\ 7\ 5\ 2$ | $2$ | $1$ |
| $7\ 7\ 5\ {\color{red}2}\ 8$ | $8$ | $0$ |
| $7\ 7\ 5\ 8\ 4$ | $4$ | $0$ |
| $7\ 7\ 5\ 8\ 4\ 1$ | $1$ | $0$ |

    输出：775841
    
## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,k,x;
char ch;
vector <int> v;//定义容器，这里我用的是vector，也可以用deque或stack
int main(){
	cin>>n>>k;//输入n和k
	for(int i=1;i<=n;i++){
		cin>>ch;
		x=ch-'0';//把字符转换成整型
		if(k!=0){//k不等于0的情况下
			while(k!=0&&!v.empty()&&x>v.back()){//若输入的数字大于容器末尾
				v.pop_back();//则删除末尾
				k--;
			}
			v.push_back(x);//插入输入的数字
		}
		else v.push_back(x);//同上
	}
	while(k!=0&&!v.empty()){//若k不等于0，则删除末k位
		v.pop_back();
		k--;
	}
	vector <int>::iterator it;
	for(it=v.begin();it!=v.end();it++){
		cout<<*it;//从头到尾输出v
	}
    return 0;
}

```





---

## 作者：3a51_ (赞：1)

### 思路分析

题目意思说的很清楚了。

首先，位数是固定的，$n-k$ 位。在这样的情况下，肯定最大位越大越好。所以我们无论后面，先把最大位找出来。

所以，我们只要找到一位，把这一位前面的数都删去就好了。

开一个栈 $s$ 记录没被删的数位。

先把当前的数存储为 $t$ 然后```pop```出去，接下来往前枚举，知道出现某个数 $p>t$，停止枚举。因为往前再有 $<t$ 的数也会被 $p$ 删掉。

举个例子：

$n=5 \; k=4 \; num=14928$。

| code | $s$ | $t$ | $k$ |
| :----------: | :----------: | :----------: | :----------: |
| ```s.push(1)``` | $\red{1}$ | $-$ | $4$ |
| ```s.push(4)``` | $1\;\red{4}$ | $-$ | $4$ |
| ```s.pop()``` | $1$ | $4$ | $4$ |
| ```s.pop()``` | $-$ | $4$ | $3$ |
| ```s.push(t)``` | $4$ | $-$ | $3$ |
| ```s.push(9)``` | $4\; \color{red}9$ | $-$ | $3$ |
| ```s.pop()``` | $4$ | $9$ | $3$ |
| ```s.pop()``` | $-$ | $9$ | $2$ |
| ```s.push(t)``` | $9$ | $-$ | $2$ |
| ```s.push(2)``` | $9\; \color{red}2$ | $-$ | $2$ |
| ```s.push(8)``` | $9\;2\; \color{red}8$ | $-$ | $2$ |
| ```s.pop()``` | $9\;2$ | $8$ | $2$ |
| ```s.pop()``` | $9$ | $8$ | $1$ |
| ```s.push(t)``` | $9\;8$ | $-$ | $1$ |

此时，我们发现，所有位置都处理完了，但 $k$ 仍然不为 $0$。

这时候的 $s$ 因为所有位置都保证前面没有小于自己的数了，所以此时 $s$ 单调不增。那剩下的 $k$ 位就删小的就可以，也就是末尾的 $k$ 位。

注意到如果直接输出那么会反，所以就倒过来再输出就行了。

---


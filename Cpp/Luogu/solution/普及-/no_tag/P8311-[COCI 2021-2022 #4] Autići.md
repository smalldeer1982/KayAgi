# [COCI 2021/2022 #4] Autići

## 题目描述

有 $n$ 个好朋友，每人有一辆遥控汽车和一个车库。第 $i$ 个人有若干个长度为 $d_i$ 的玩具道路部件，可以为汽车建造道路。

两个朋友 $a$ 和 $b$ 可以建造一条长度为 $d_a+d_b$ 道路以连接他们的车库。

我们认为，如果从任意一个车库出发能够到达任意的其他车库，我们称这种情况为“连通交通”。

请求出，构成一个“连通交通”所需要的最小总道路长度是多少？

## 说明/提示

**【样例 1 解释】**

当只有一位朋友时，已经构成“连通交通”，不必修建道路。故答案为 $0$。

**【样例 3 解释】**

如果在第 $1$ 位和第 $2$ 位朋友、第 $2$ 位和第 $3$ 位朋友、第 $3$ 位和第 $4$ 位朋友之间修建道路可以形成“连通道路”，价格总和为 $(7+3)+(3+3)+(3+5)=24$。


**【数据规模与约定】**

**本题采用子任务捆绑测试。**
- Subtask 1（10 pts）：$d_1 = d_2 = \dots = d_n$。
- Subtask 2（20 pts）：$1 ≤ n ≤ 10^3$。
- Subtask 3（20 pts）：没有额外限制。

对于 $100\%$ 的数据，$1\le n\le10^5,1\le d_i\le 10^9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T1 Autići。**

## 样例 #1

### 输入

```
1
10```

### 输出

```
0```

## 样例 #2

### 输入

```
3
5 5 5```

### 输出

```
20```

## 样例 #3

### 输入

```
4
7 3 3 5```

### 输出

```
24```

# 题解

## 作者：_Give_up_ (赞：5)

## 思路
从题目中，我们不难看出，对于每一个 $d[i]$ 都至少用了一次。我们特判如果 $n = 1$，直接输出 $0$，结束程序。否则让所有车库都与 $d[i]$ 最小的车库相连即可，我们从 $0$ 循环到 $n$，计算所有 $d[i]$ 的和，用 $k$ 做变量，再找 $d[i]$ 的最小值，用 $ans$ 做变量。
最后一步，用 $k + n \times ans-2 \times ans$，化简后就是 $k+(n-2)
\times ans$。
## 代码
```cpp
#include<bits/stdc++.h>
#define N 1000010

using namespace std;

typedef long long ll;

ll read()
{
    ll x = 0,f = 1;
    char c = getchar();
    while(c<'0' || c>'9')
	{
        if(c=='-') f = -1;
        c = getchar();
    }
    while(c>='0' && c<='9')
	{
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
    return x*f;
}

ll a[N];

int main()
{
	ll n = read();
	for(int i=1;i<=n;i++)
	    a[i] = read();
	if(n==1)
    {
        printf("%d\n",0);
        return 0;
    }
	ll sum=0,ans = 1000000000000;
	for(int i=1;i<=n;++i)
	{
		sum += a[i];
		ans = min(a[i],ans);
	}
    printf("%lld\n",sum+(n-2)*ans);
    return 0;
}
```

最后说一句，一定要开 `long long`。

---

## 作者：ztntonny (赞：3)

## **题目分析**
因为每个人都要连接，总和就应是每个人加一起再加上每个人找的人的总和，为了使后者最小，可以全部让后者是最小的那个值，连接后呈放射型。
## **解题思路**
先找到最小值和总和，再把总和加上最小值乘以总数减二（因为最小值不用跟自己连），代码如下：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ll a , b , ans = 0 , min = 1000000005;//不开longlong见祖宗
	cin >> a;
	if ( a == 1 )//特判
	cout << 0;
	else
	{
		for ( int i = 1; i <= a; i++ )
		{
			cin >> b;
			ans += b;//总和
			if ( b <= min )
			min = b;//最小值
		}
		cout << a * min - min * 2 + ans;//如上
	}
	return 0;
}
```


---

## 作者：幸存者 (赞：1)

## 思路
因为所有车库都是连通的，所以对于每一个 $d_i$ 都至少用了一次。

那么对于第 $i$ 个车库（$i$ 需要满足的条件是 $d_i$ 不是数组 $d$ 中最小的），与它连接的道路的最小值显然就是 $d_i+\min\limits_{j=1}^n\{d_j\}$。

那么能不能让所有道路的长度都达到这个最小值呢？显然可以，只要让所有车库都与 $d_i$ 最小的车库相连即可，最后答案就是 $\sum\limits_{i=1}^nd_i+(n-2)\times\min\limits_{i=1}^n\{d_i\}$。
## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int n;
    cin >> n;
    if (n == 1)
    {
        cout << 0 << endl;
        return 0;
    }
    int minn = 1e9;
    long long ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int x;
        cin >> x;
        ans += x, minn = min(minn, x);
    }
    cout << ans + 1ll * (n - 2) * minn << endl;
    return 0;
}
```

---

## 作者：YS_YSZF_FZQQ (赞：0)

显然，每一个 $d_i$ 都至少用了一次。
## 情况分类：
1.当 $n = 1$ 时，已经形成连通交通。

2.其他情况。显然的贪心。想法是把每个 $d_i$ 与  $d_{min}$ 连边，此时总长度最小。
## $AC$ $CODE$:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,d[100025];
    long long roadlong;
    cin >> n;
    if(n == 1){
        cout << 0;
        return 0;
  }
  else{
    for(int a = 1;a <= n;a++)
        cin >> d[a];
    sort(d+1,d+1+n);//精髓
    for(int a = 2;a <= n;a++)
        roadlong += d[1] + d[a];
    cout << roadlong;
    return 0;
    }
}
```
不抄题解，从我做起


---

## 作者：ImposterAnYu (赞：0)

~~想了半个多小时没想到，结果我妈一句话让我会了。~~

# 1. 简化版题意。
给定一个有 $n$ 个点但是没有边的图，第 $i$ 个点的权值为 $d_i$。已知构造一条点 $i$ 和点 $j$ 的双向边的代价为 $d_i+d_j$，求使这个图变成连通图的最小代价。

其中，$1 \leq n \leq 10^5$，且 $\forall1 \leq i \leq n$，都有 $1 \leq d_i\leq 10^9$

# 2. 这题应该怎么做？
首先，一条边可以连接 $2$ 个点，所以最少只需要 $n - 1$ 条边便可以使这个图变成连通图。

因为这道题对边的构造没有任何别的要求，所以，根据贪心的思路，我们只需要选出 $\frac{n(n-1)}{2}$ 条边中代价最少的 $n - 1$ 条边，将代价相加即可。

然而，如果真的把每条边都算出来的话，复杂度就高达 $O(n^2)$ 了。而且找出最小的 $n - 1$ 条边，最后的复杂度就会达到 $O(n^2 \log\ n^2)$ 了！照这么来算，我们的代码可能就只有 $20$ 分了！

但是……我们真的有必要将每条边都算出来吗？

如果要让一个点与其他已经连通的点连通，很明显，要让代价最小，肯定是让这个点这些连通的点中权值最小的那个点啊。如果每个点都用这样的思想去考虑的话，我们就会发现：每个点都和权值最小的那个点连接，就会使总代价最小！

假设 $minn = \min\limits_{1\le i\le n}{d_i}$（即 $min(d_1,d_2,d_3,……,d_n)$），因为有其他的 $n - 1$ 个点与这个权值最小的点相连，所以最后的答案就是 $\sum\limits_{i=1}^n(d_i+minn) - 2minn$（因为这个权值最小的点不用与自己相连，所以要减去 $2minn$），也就是 $\sum\limits_{i=1}^n(d_i) + minn(n - 2)$！

说了这么多，想必大家也听懂了，可以自己写代码了。但是为了方便大家理解，我还是贴个代码吧！![](//图.tk/6)![](//图.tk/6)![](//图.tk/6)

# AC code
```c++
#include<bits/stdc++.h>
using namespace std;
#define int1 long long
int1 n,i,a,minn = 1145141919810,s;//注意，最小值要设得很大，至少不小于10的9次方！ 
int1 read(){//仍旧是那一成不变的快读。 
	int1 x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
void print(int1 x){//仍旧是那一成不变的快写。
  	if(x < 0){
    	putchar('-');
    	x = -x;
  	}
  	if(x > 9){
    	print(x / 10);
  	}
  	putchar(x % 10 + 48);
  	return ;
}
int main(){
	n = read();
	for(i = 1; i <= n; i++){
		a = read();
		minn = min(a,minn),s += a;//s就是所有点的点权值和。 
	}
	print(s + minn * (n - 2));//按题解里的结论输出就好了！ 
	return 0;
}
```

---

## 作者：TempestJueMu (赞：0)

本题为**贪心**。

要想使 $n$ 个点连通，显然至少需要 $n-1$ 条边连成一棵树。

而要想让总长度最小，一个显然的想法是把每个点**与 $d$ 最小的点连边**，此时总长度最小，图形为一个**菊花图**。

贪心策略想清楚之后，代码就显而易见了。

另：记得特判 $n=1$ 的情况和开 `long long` 。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d[100010];
long long ans;
int main()
{
    cin>>n;
    if(n<=1){cout<<0;return 0;}
    for(int i=1;i<=n;i++)cin>>d[i];
    sort(d+1,d+1+n);
    for(int i=2;i<=n;i++)
        ans+=d[1]+d[i];
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

贪心的，我们每次都要选最小的连边。因为对于三个点 $(a,b,c)$，假设 $d_a<d_b<d_c$，那么我们结合最小生成树的思路，将 $c$ 拉入生成树时，无论与 $a$ 连边还是与 $b$ 连边，都可以联通。又因为 $d_a\le d_b$，所以 $d_a+d_c\le d_b+d_c$，所以和 $a$ 连边更优。

以此类推，在排序之后，所有节点都和 $1$ 号节点连接，所以最后的答案就是 $d_1\times(n-1)+\sum\limits_{i=2}^n d_i$。

代码很好实现，这里不做展示。

---

## 作者：hepp (赞：0)

本题很显然是一个贪心，如果我们要将 $n$ 个点联通的话，我们最少需要 $n-1$ 条边。那么，我们只需要使这 $n-1$ 条边每一条边尽量短就行了。

因为要联通，所以每一个点必须至少有一条边连其他点，我们无法改变。那么，我们要使另一条边更短。另一条边最短是多少呢？显然是有最短的那条边的点。同时，当所有点都与一个点联通时，这个图是联通的。

### 所以，我们得出了贪心方案：所有点都与拥有最短边的点连通，此时路径最短。

下面是计算方法：

$ ans=\sum\limits_{i=1}^n(d_i+d_{minn})-d_{minn}\times 2$

减 2 个最短边是因为只需要 $n-1$ 个，可它统计了 $n+1$ 个（有一个在   $d_i$ 中）

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,minn=100000000000;//一定要开大。记得long long
    long long ans=0;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    {
        long long a;
        scanf("%lld",&a);
        minn=min(minn,a);
        ans+=a;//统计所有边的和
    }
    printf("%lld",minn*(n-2)+ans);//n-2 的原因如上
    return 0;
}
```

---

## 作者：KAqwq (赞：0)

# P8311
很简单的签到题，样例三的解释 $(7+3)+(3+3)+(3+5)$ 中的 $7+3+3+5$ 正好就是输入的数据之和，而余下的两个 $3$ 与 $7+3+3+5$ 之和正好就是 $ans+(n-2)\times3$，而相乘的 $3$ 便是输入中的最小值，我们可以把 $minn$ 这个变量初始化为 $10^9+5$，因为输入的 $d_i \le 10^9$，这样可以防止当 $d_i = 10^9$ 时最小值为 $minn$ 而不是 $d_i$ 的错误。 
# 公式
```
ans+(n-2)*minn
```
# 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int minn=1e9+5,n,x,ans;
signed main(){
    scanf("%lld",&n);
    if(n==1){
        printf("0");
        return 0;
    }
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);
        ans+=x;
        minn=min(minn,x);
    }
    printf("%lld",ans+(n-2)*minn);
    return 0;
}
```

### ——The End

---

## 作者：yeshubo_qwq (赞：0)

思路：

因为要求每一个点都能到达，所以，每一个 $d_i$ 都至少用了一次。

既然如此，我们将每个点都连到最小的点上，就可以求出最优答案。

注意：$d_i$ 的范围高达 $10^9$，所以要开 `long long`。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,i,x,s,mi=2e9;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++) cin>>x,s+=x,mi=min(mi,x);
	cout<<s+mi*n-mi*2;//自己和自己不用连接，所以减mi*2
	return 0;
}
```


---


# [COCI 2021/2022 #5] Kemija

## 题目描述

给定 $n$ 个化学方程式。

每个参与反应的分子由若干个原子组成，每个原子由一个字母和一个数字表示，分别代表元素名称和分子中该原子的数量。如果多个分子参与反应，则分子前添加一个数字表示化学计量数。本题中只需考虑每一原子的数量，而不必考虑方程式的合理性。例如，$\texttt{3AC4B}$ 可以直接视为 $3$ 个 $\texttt A$、$3$ 个 $\texttt B$ 和 $12$ 个 $\texttt C$ 参与反应。当有不同分子位于方程式同一边时，用 $\texttt +$ 连接。

你的任务是分别检查每个方程式是否已经配平（只需考虑左右原子数量是否都对应相等）。

## 说明/提示

**【样例 3 解释】**

|序号|左侧原子|右侧原子|结果|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$4 \times \texttt H, 6 \times \texttt O, 2 \times \texttt C$|$4 \times \texttt H, 6 \times \texttt O, 2 \times \texttt C$|$\green{\texttt{DA}}$|
|$2$|$2 \times \texttt H, \red{1 \times \texttt S}, 4 \times \texttt O$|$2 \times \texttt H, 4 \times \texttt O$|$\red{\texttt{NE}}$|
|$3$|$1 \times \texttt N, \red{5 \times \texttt H}, 1 \times \texttt S, 4 \times \texttt O$|$1 \times \texttt N, \red{4 \times \texttt H}, 1 \times \texttt S, 4 \times \texttt O$|$\red{\texttt{NE}}$|
|$4$|$1 \times \texttt C, 4 \times \texttt H, 4 \times \texttt O$|$1 \times \texttt C, 4 \times \texttt H, 4 \times \texttt O$|$\green{\texttt{DA}}$|

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（10 pts）：方程式中均不含数字。
- Subtask 2（10 pts）：分子式中均不含数字。
- Subtask 3（30 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 1000$。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 1 Kemija。**

## 样例 #1

### 输入

```
3
A+B->AB
AB+CD->AC+DB
AB+B->AB```

### 输出

```
DA
DA
NE```

## 样例 #2

### 输入

```
2
2AB+A->3AB
2AB+2AC+2BC->4ABC```

### 输出

```
NE
DA```

## 样例 #3

### 输入

```
4
2H2O+2CO2->2H2CO3
H2SO4->H2O4
NH3+H2SO4->NH4SO4
CH4+2O2->CO2+2H2O```

### 输出

```
DA
NE
NE
DA```

# 题解

## 作者：02Ljh (赞：7)

## 题意
给我们一个化学式，让我检查该化学式有没有配平。如果配平了，输出 ```DA```，否则输出```NE```
## 配平（学过的可以自动跳过）
~~化学反应方程式严格遵守质量守恒定律~~

说人话，配平就是化学方程式中等号 ( $\to$ 号）两端每个元素数量都一样 

#### 举个栗子：
$2\text{O}_2+\text{H}_2=2\text{H}_2\text{O}$  在这个化学式中，左侧有 2 个 $\text{O}$ (氧元素) 与 $2\times2$ 个 $\text{H}$ (氢元素)，而右侧也有 $2\times2$ 个 $\text{H}$ 与 2 个 $\text{O}$ ，所以该化学式平衡。

## tips
这题其实非常水。

根据上面的分析，我们只需要扫一遍该化学式，统计化学式前后的元素数量，开一个结构体，以 $\to$ 作为化学式前后的分隔，分别统计之后再检查就行了。
（具体细节见代码）
## 易错点
~~话说只有我这种蒟蒻会错~~
1.  多测不清空，爆 0 两行泪！！！
2.  字符转成整数一定要 -'0' ！！！
3.  $2\text{H}_2\text{O}$ 指的是 $2(\text{H}_2\text{O})$ 而不是 $2\text{H}_2$ 和 $\text{O}$ ！！！
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
	    bool f=false;//这个元素有没有被访问过
	    int f_num=0;//这元素在化学式前面的数量
        int e_num=0;//这元素在化学式后面的数量
} ;
bool deal()
{ 
	     node xy[1001];
	     int flag=1;//1表示前半部分 -1表示后半部分
         int tim=-1;//tim表示整个化学式的系数( 2H2O 中的 2 )
         string s;
	     cin>>s;
	     int len=s.size();
    	 for(int i=0;i<len;i++)
	     {
		    if(s[i]=='-'&&s[i+1]=='>') { flag=-1; tim=-1; i++; continue; }//分隔化学的前半部分和后半部分，更新flag
	    	if(tim==-1)
	    	{
		    	if(isdigit(s[i])) { tim=s[i]-'0'; continue; }//将化学式的系数的值赋给tim。
		    	else tim=1;//如果该化学式没有系数，那么系数就是1
		    }
		    if(s[i]=='+') { tim=-1; continue; }//遇到连接化学式的时候，清零tim
		    if(isdigit(s[i])&&isalpha(s[i-1])&&i!=0)//处理 H20 中的 H2 (该化学式的原子数)
	        {
		    	int w=s[i]-'0';
		    	w=w*tim;//该元素的原子数乘上系数
			    xy[(int)(s[i-1])].f=true;//标记为访问过
			    if(flag==1) xy[(int)(s[i-1])].f_num+=w;//分别处理化学式的前后部分
			    else xy[(int)(s[i-1])].e_num+=w;
		    }
		    if(isalpha(s[i])&&!isdigit(s[i+1]))
		    {//处理 H2O 中的 O 部分(只有一个元素单质的)
			    xy[(int)(s[i])].f=true;
			    if(flag==1) { xy[(int)(s[i])].f_num+=tim; }
			    else if(flag==-1) { xy[(int)(s[i])].e_num+=tim; } 
		    }
	    }
	    for(int i='A';i<'z';i++)//从'A'到'z'依次查询
	    {
		    if(!xy[i].f) continue;//如果没有被使用过，循环继续    
		    else 
		    {
		        if(xy[i].e_num==xy[i].f_num) { continue; }//如果相等就继续
		    	else return false;//否则直接结束
            }
	    }
        return true;
}
int main()
{
	    int n;
	    cin>>n;
	    while(n--)
    	{
	    	if(deal()) puts("DA");
	    	else puts("NE");
    	}
	    return 0;//完结撒花 qwq
}
//P8234
```
p.s QAQ 这是本蒟蒻发的第一个题解 都这么晚了我还在写题解 求管理员大大给过

---

## 作者：retep (赞：3)

## 题目简述

输入 $n$ 个化学方程式，判断每个式子是否配平。配平的意义为 ```->``` 前后每个原子的数量相等，也就是说符合质量守恒定理。

需要注意的是，以 ```+``` 为分隔符的每个小项中，第一个数字表示**之后整个原子团的个数**。这之后每个大写字母表示一个原子，若其后方跟了一个数字 $x$，则表示有 $x$ 个该原子；如果没有，则表示有 $1$ 个。并且感谢出题人，每个数字都是个位数，也就是**只占一个字符**。

传送门：[P8324 Kemija](https://www.luogu.com.cn/problem/P8324)

## 题目分析

这是道模拟题，没有太大的思维难度，但想要以清晰简洁的代码实现出来还是需要一些构思的。这种构思的能力非常重要，尤其是在做思路复杂的题目时，我们不想被裹脚布般的代码所困扰。

因为所有原子都是大写字母，所以我们可以开一个大小为 $26$ 的 $cnt$ 数组表示每个原子的出现次数。```->``` 前的出现次数加进去，而之后的出现次数则从数组中减去。最后只要看看 $cnt$ 中的值是否全部都是 $0$ 即可。

```cpp
int len=strlen(s+1),cnt[26];
for(int i=1;i<=len;i++){
    //...
	if(s[i]>='A'&&s[i]<='Z'){
        //...
		cnt[s[i]-'A']++;//...
	}
    //...
}
for(int i=0;i<26;i++)
	if(cnt[i]){
		cout<<"NE"<<endl;
		return;
	}
cout<<"DA"<<endl;
```

```->``` 的前后可以用变量 $status$ 来表示，前为 $1$，后为 $-1$。那么只要在原子出现次数加入 $cnt$ 前乘以 $status$ 就行了。

```cpp
int len=strlen(s+1),cnt[26],status=1;
fill(cnt,cnt+26,0);
for(int i=1;i<=len;i++){
    //...
	if(s[i]>='A'&&s[i]<='Z'){
        //...
		cnt[s[i]-'A']+=status;//...
	}
    else if(s[i]=='-')status=-1,i++;
}
for(int i=0;i<26;i++)
	if(cnt[i]){
		cout<<"NE"<<endl;
		return;
	}
cout<<"DA"<<endl;
```

现在考虑如何计算原子的出现次数。影响出现次数的有两个数字，一个是可能出现单项开始的第一个数字，另一个则是每个原子后可能跟着的数字，先考虑后者。因为一定是个位数，所以直接判断原子的后一个字符是否为数字即可。

```cpp
int len=strlen(s+1),cnt[26],status=1;
fill(cnt,cnt+26,0);
for(int i=1;i<=len;i++){
    //...
	if(s[i]>='A'&&s[i]<='Z'){
        int num=1;
		if(isdigit(s[i+1]))num=s[i+1]-'0';
		cnt[s[i]-'A']+=status*num;//...
	}
    else if(s[i]=='-')status=-1,i++;
}
for(int i=0;i<26;i++)
	if(cnt[i]){
		cout<<"NE"<<endl;
		return;
	}
cout<<"DA"<<endl;
```

再考虑单项开始的第一个数字。这个数字会影响后方许多原子的数量，所以我们要在一开始就将它的值记录在一个变量 $buf$ 中。之后在计算原子出现次数时，乘上 $buf$。

如何判断哪个数字代表了 $buf$ 呢，好在它的位置是有特点的，要么在整个方程字符串的第一个位置，要么在 ```+``` 后方，要么在 ```>``` 后方。

```cpp
int len=strlen(s+1),cnt[26],status=1,buf;
fill(cnt,cnt+26,0);
for(int i=1;i<=len;i++){
    if(i==1||s[i-1]=='+'||s[i-1]=='>'){
		buf=1; //新的小项开始了，初始化一下
		if(isdigit(s[i]))buf=s[i]-'0',i++;
	}
	if(s[i]>='A'&&s[i]<='Z'){
        int num=1;
		if(isdigit(s[i+1]))num=s[i+1]-'0';
		cnt[s[i]-'A']+=status*num*buf;
	}
    else if(s[i]=='-')status=-1,i++;
}
for(int i=0;i<26;i++)
	if(cnt[i]){
		cout<<"NE"<<endl;
		return;
	}
cout<<"DA"<<endl;
```

## code

最后献上简短的 [AC](https://www.luogu.com.cn/record/80612150) 代码：

```cpp
#include<bits/stdc++.h>
#define N 1005
using namespace std;

int n,cnt[26];
char s[N];

void solve(){
	fill(cnt,cnt+26,0);
	cin>>(s+1); 
	int len=strlen(s+1),status=1,num,buf;
	for(int i=1;i<=len;i++){
		if(i==1||s[i-1]=='+'||s[i-1]=='>'){
			buf=1;
			if(isdigit(s[i]))buf=s[i]-'0',i++;
		}
		if(s[i]>='A'&&s[i]<='Z'){
			num=1;
			if(isdigit(s[i+1]))num=s[i+1]-'0';
			cnt[s[i]-'A']+=num*buf*status;
		}
		else if(s[i]=='-')status=-1,i++;
	}
	for(int i=0;i<26;i++)
		if(cnt[i]){
			cout<<"NE"<<endl;
			return;
		}
	cout<<"DA"<<endl;
}

int main(){
	cin>>n;
	while(n--)solve();
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：3)

本题题意：判断多元一次方程是否是等式。

根据题意模拟即可。

考虑以 $\texttt{->}$ 为界，分成左右两边处理。

因为只有大写字母，所以该程序对于字母和数字的判断只要以 $65$ 为界。

因为数字都是个位数，所以只需判断每个字母的后一位即可。当然第一位要特殊处理。详见代码。

```
#include<bits/stdc++.h>
using namespace std;
int n;string s;
bool check(string x){//判断该方程是否合法
	int flag=1,ii=-1;
	if(int(x[0])<65)flag=int(x[0])-48;//最开始对分子的化学计量数处理
	int a[30],b[30];
	for(int i=0;i<=28;i++)a[i]=0,b[i]=0;//初始化数组，a数组存左半边字母情况，b数组存右半边
	while(x[ii]!='-'){//处理左半边
		ii++;
		if(x[ii]=='+'){//处理每个分子的化学计量数
			if(int(x[ii+1])<65)flag=int(x[ii+1])-48;
			else flag=1;//如果分子前面没数字，即视为1
		}
		else if(int(x[ii])>=65){//处理每个原子
			if(int(x[ii+1])<65&&x[ii+1]!='+'&&x[ii+1]!='-')a[int(x[ii])-65+1]+=(int(x[ii+1])-48)*flag;
			else a[int(x[ii])-65+1]+=flag;
		}//判断每个原子后是否有跟数字，并作出处理
	}
	while(ii<x.length()){//处理右半边
		ii++;
		if(x[ii]=='+'||x[ii]=='>'){//处理每个分子的化学计量数
			if(int(x[ii+1])<65)flag=int(x[ii+1])-48;
			else flag=1;////如果分子前面没数字，即视为1
		}
		else if(int(x[ii])>=65){//处理每个原子
			if(int(x[ii+1])<65&&x[ii+1]!='+'&&ii+1<x.length())b[int(x[ii])-65+1]+=(int(x[ii+1])-48)*flag;
			else b[int(x[ii])-65+1]+=flag;
		}////判断每个原子后是否有跟数字，并作出处理
	}
	for(int i=1;i<=26;i++){//判断是否平衡
		if(a[i]!=b[i])return 0;//只要有一个元素不一样，直接判定不合法
	}
	return 1;//合法
}
int main(){//朴素的主函数
	scanf("%d",&n);
	for(int kkk=1;kkk<=n;kkk++){
		cin>>s;
		if(check(s))cout<<"DA"<<endl;
		else cout<<"NE"<<endl;
	}
	return 0;
}

```


---

## 作者：Kedit2007 (赞：1)

来交一发 Python 的题解，如果有错误或者可以改善的地方请指出！

**更新：在文章结尾添加了相同思路下C++的参考写法。**

## 思路

把方程分成左右两边，用字典记录两边每个元素的个数，然后直接比较两个字典就好啦！

道理我都懂，那我该怎么写呢。

一步步来，首先将方程分成左右两边，既然我们用了 Python 那么我们可以直接使用字符串的 ```split``` 方法，例如：

```python
'H2O->H2O'.split('->')

# 得到 ['H2O', 'H2O']
```

类似地，我们可以将方程两边的每个物质根据加号分开，例如：

```python
'NH3+H2SO4'.split('+')

# 得到 ['NH3', 'H2SO4']
```

解决了分割方程式的问题后我们着眼单个物质的处理方式。

一个不难想到的思路是：一开始先尝试读数字作为整个物质的系数，接下来一个个读进元素，并在读完一个元素后尝试读一个数字作为这个元素的系数，最后每个元素根据自己本身的系数和整个物质的系数修改字典。

为了编写方便，我专门写了一个尝试读数字的函数，它做的事情是这样的：返回一个字符串开头的数字和剔除开头数字之后的字符串，如果开头没有数字则返回 $1$ 和原字符串。

它的具体实现是这样的：

```python
nums = [str(i) for i in range(0, 10)]

def extract_num(text: str) -> (int, str):
    # 特判开头无数字
    if text == "" or text[0] not in nums:
        return 1, text
    index = 0
    temp = ""
    # 尝试往下读入字符
    # 这里支持开头的数字不止一位 以防万一
    while index < len(text) and text[index] in nums:
        temp += (text[index])
        index = index + 1
    # 最后用切片操作实现剔除前导数字
    return int(temp), text[index:]
```

有了这个函数之后，就能比较容易地写出一个物质中元素的个数了。

具体地说，一开始先调用一次上面的函数得到整体系数，并且用返回值更新字符串。接下来直到字符串为空，字符串的开头第一个都是元素的名称，记录下来后再次调用上面的函数得到元素的系数，并继续用返回值更新字符串。

可以参考下面的代码：

```python
# element 是当前物质的字符串

# 开始时先读整体系数
# 记得 extract_num 的第二个返回值是去除了前导数字的
mul, element = extract_num(element)

# 读一个个元素
while element != "":
    # ele 表示元素名 cnt 表示元素系数
    # 右侧的 * 用于解包 extract_num 的返回值
    # 如果对这个语言特型不熟悉可以拆开来写
    ele, cnt, element = element[0], *extract_num(element[1:])
    # 假设 ret 是记录元素个数的字典
    ret[ele] += cnt * mul
```

那么这道题到这里基本就完工了，只要把一块块代码拼凑起来就能完成这道题了。

这道题的数据点中换行是带 ```'\r'``` 的，处理的时候要注意。

## 参考代码

```python
nums = [str(i) for i in range(0, 10)]

def extract_num(text: str) -> (int, str):
    if text == "" or text[0] not in nums:
        return 1, text
    index = 0
    temp = ""
    while index < len(text) and text[index] in nums:
        temp += (text[index])
        index = index + 1
    return int(temp), text[index:]
        
def count_element(text: str) -> dict:
    ret = {}
    for element in text:
        mul, element = extract_num(element)
        while element != "":
            ele, cnt, element = element[0], *extract_num(element[1:])
            if ele not in ret:
                ret[ele] = 0
            ret[ele] += cnt * mul
    return ret

def work(text: str) -> bool:
    text = text.rstrip('\r') # 去掉结尾的 '\r' 防止出问题
    equation = text.split("->")
    left = equation[0].split("+")
    right = equation[1].split("+")
    lcnt = count_element(left)
    rcnt = count_element(right)
    return lcnt == rcnt
        
        
t = int(input())
for _ in range(t):
    print("DA" if work(input()) else "NE")

```

C++ 参考代码：[云剪贴板](https://www.luogu.com.cn/paste/2ahhxlt5)

---

## 作者：Halberd_Cease (赞：1)

配平判断：左右相同元素数量相同，
可以想到用桶来存左右每个原素的数量，最后只用判断桶是否相等即可。

---

每个分子间以 ```+``` 或者 ```->``` 隔开，以分子为单位来进行添加。形如 ```2H2O``` 的输入转化成分子式为 $2H_{2}O$ , ```H``` 有 2×2=4 个， ```O``` 有 2 个。

方法：在开头先判数字，存为 ```x1``` ，然后读字母存为 ```yz``` ，再读一次数字存为 ```x2``` （注意， ```x1``` 和 ```x2``` 如果没有读到就是 ```1```），然后 ```t[yz]+=x1*x2``` 。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int now;
char a[1010];
int tl[128],tr[128];//左右桶
bool add1()
{
	int x1=0;
	while(a[now]>='0'&&a[now]<='9')
	{
		x1*=10;
		x1+=a[now]-'0';
		now++;
	}
	while(a[now]!='+'&&a[now]!='-')
	{
		char yz=a[now];
		now++;
		int x2=0;
		while(a[now]>='0'&&a[now]<='9')
		{
			x2*=10;
			x2+=a[now]-'0';
			now++;
		}
		tl[yz]+=max(1,x1)*max(1,x2);//等价于没读到就赋值为一
	}
	now++;
	if(a[now]=='>')
	{
		now++;
		return 1;
	}
	return 0;
}
bool add2()
{
	int x1=0;
	while(a[now]>='0'&&a[now]<='9')
	{
		x1*=10;
		x1+=a[now]-'0';
		now++;
	}
	while(a[now]!='+'&&a[now]!='\0')
	{
		char yz=a[now];
		now++;
		int x2=0;
		while(a[now]>='0'&&a[now]<='9')
		{
			x2*=10;
			x2+=a[now]-'0';
			now++;
		}
		tr[yz]+=max(1,x1)*max(1,x2);
	}
	now++;
	if(a[now]=='\0')
	{
		return 1;
	}
	return 0;
}
int main()
{
	int n;
	cin>>n;
	while(n--)
	{
		memset(a,0,sizeof(a));
		memset(tl,0,sizeof(tl));
		memset(tr,0,sizeof(tr));
		now=0;
		cin>>a;
		int flag=0;
		while(flag==0)
		{
			flag=add1();
		}
		flag=0;
		while(flag==0)
		{
			flag=add2();
		}
		flag=0;
		for(int i='A';i<='Z';i++)
		{
			if(tr[i]!=tl[i])
			{
				flag=1;
				break;
			}
		}
		if(flag)cout<<"NE\n";
		else cout<<"DA\n";
		//cout<<tl['A']<<' '<<tl['B']<<' '<<tl['C']<<'\n';
		//cout<<tr['A']<<' '<<tr['B']<<' '<<tr['C']<<'\n';
	}
} 
```


---

## 作者：VIOLET__FOREVER (赞：1)

题目[传送门](https://www.luogu.com.cn/problem/P8324)
## 思路
题目的要求是判断方程式的配平是否正确，我们可以根据化学中的原子守恒定律，即方程式两端的每个原子的个数相同，所以，就可以很轻松的得出本题的算法——

我们可以读入一个字符串，便利过去，在箭头之前就把每个大写字母的数量进行统计，在箭头之后就减去每个大写字母出现的个数，最后判断一下是否每个统计的大写字母出现的次数是否为零，如果是就输出 `DA` 不然就输出 `NE` 。

同时关于方程式前和方程式中的字符处理，方程式前的可以参考（读出多位数各个数位上的数的方法），即可利用 $\text{flag}$ 来储存数字，遇到加号就将 $\text{flag}$ 清零，这里考虑在方程式中会将 $1$ 隐去，所以这里要特判，在方程式中的就是在大写字母后的数字，只需要在判断每一个大写字母的时候判断一下他的后一位是否是数字就行，如果是数字就乘以 $\text{flag}$ 使加上的数字变大，但这里要考虑在字符串后加一个字符用来防止越界，这样的话一切都可以迎刃而解了！！！
同时，为了防止出现超过九的数字，我们在记录数字的时候一定要用一个 $\text{flag}$ 来储存，不然会完蛋。
## AC code
代码可能有点长，但是应该是好理解的——
```cpp
#include<bits/stdc++.h>
using namespace std;
map<char,int> num;//用 map 表示每个大写字母出现的次数 
int n,flag,l,x,y;
int main(){
	cin>>n;
	while(n--){
		string s;
		cin>>s;
		s+='Z';//在最后加上一位，防止出现越界RE 
		for(char i='A';i<='Z';i++) num[i]=0;
		flag=0,l=0;//以上为初始化 
		for(int i=0;i<s.size()-1;i++){//在箭头的左侧 
			if(s[i]=='-'){
				l=i+2;
				break;
			}
			else if(s[i]>='0' && s[i]<='9') flag=flag*10+s[i]-'0';//对开头数字的处理 
			else if(s[i]=='+') flag=0; 
			else if(s[i]>='A' && s[i]<='Z'){
				if(s[i+1]>='1' && s[i+1]<='9'){
					for(int j=1;j<=s[i+1]-'0';j++){
						if(flag==0) num[s[i]]++;
						else num[s[i]]+=flag;
					}
					i++;
				}//以上考虑的是多余各个方程式后方的数字 
				else{
					if(flag==0) num[s[i]]++;
					else num[s[i]]+=flag;
				}
			}
		}
		flag=0;//这里必须要归零，不然会带上上面的数字 
		for(int i=l;i<s.size()-1;i++){//在箭头的右侧 
			if(s[i]>='0' && s[i]<='9') flag=flag*10+s[i]-'0';
			else if(s[i]=='+') flag=0;
			else if(s[i]>='A' && s[i]<='Z'){
				if(s[i+1]>='1' && s[i+1]<='9'){
					for(int j=1;j<=s[i+1]-'0';j++)
						if(flag==0) num[s[i]]--;
						else num[s[i]]-=flag;
					i++;
				}
				else{
					if(flag==0) num[s[i]]--;
					else num[s[i]]-=flag;
				}//皆同上 
			}
		}
		flag=0;//这里的 flag 表示有无差别 
		for(char i='A';i<='Z';i++){
			if(num[i]!=0) flag=1;
		}//如果有差别就 flag 为1 
		if(flag) cout<<"NE"<<endl;
		else cout<<"DA"<<endl;
	}
	return 0;
} 
```


---

## 作者：Fontaine (赞：0)

## 题意

给定一个化学式，检查该化学式是否配平。如果配平了，输出 $DA$，否则输出 $NE$。

## 配平

~~众所不周知~~，化学反应方程式遵守质量守恒定律（建议学完八年级化学再看）。

[不了解配平的可以看一下](https://baike.baidu.com/item/%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F%E9%85%8D%E5%B9%B3/3013725?fr=aladdin)。


## 分析

真没什么好说的，在函数里用一个循环过一遍就行，就是道简单的模拟。

循环里有三种情况：

$1.$ 当前字符为数字；

$2.$ 当前字符为字母；

$3.$ 当前字符为箭头。

只需要针对这三种情况分别处理就行了。

## code

请勿抄袭！！！！！

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;

int n,a[26];
string s;//变量 

void f()
{
    fill(a,a+26,0);//fill函数 
    cin>>s;
    int len=s.size(),x=1,sum,b;
    for(int i=0;i<len;i++)//循环 
    {
        if(i==0 || s[i-1]=='+' || s[i-1]=='>')//1.
        {
            b=1;
            if(isdigit(s[i]))
            {
                b=s[i]-'0';
                i++;
            }
        }
        if(s[i]>='A' && s[i]<='Z')//2.
        {
            sum=1;
            if(isdigit(s[i+1]))
            {
                sum=s[i+1]-'0';
            }
            a[s[i]-'A']+=sum*b*x;
        }
        else if(s[i]=='-')//3.
        {
            x=-1;
            i++;
        }
    }
    for(int i=0;i<26;i++)//判断+输出 
    {
        if(a[i])
        {
            cout<<"NE"<<endl;
            return ;
        }
    }
    cout<<"DA"<<endl;
}

int main()
{
    ios::sync_with_stdio(0);//其实可以不加 
    cin>>n;//输入 
    while(n--)
    {
        f();//函数 
    }
    return 0;//好习惯~ 
}
```
求管理员大大通过 orz orz

---

## 作者：Charlie1202 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8324)

（如有错误请指出）

# 题意
给定 $n$ 个~~化学~~类化学方程式，判断其是否配平。

**温馨提示：** 本题中读入的所有数字都是一位数，不会出现多位数。

# 分析
根据质量守恒定律，一个方程式配平当且仅当方程左右两边原子数量相等。

因此，我们只要以 `->` 为分隔，分别遍历左右两边，用两个桶数组记录每个元素（就是 $26$ 个英文字母）出现的次数，最后再次遍历一遍两个桶数组，依次判断每个数是否相同，一旦不同输出 `NE`，否则输出 `DA`。

## 注意
（以下类似 `"中文"` 的代码块中，`" "` 不用加）
1. 建议使用 `string` 来读入，如果你想用 `char` 数组来读入，请注意，如果当前读入字符串长度为 $l_2$，上一次读入长度为 $l_1$（$l_2 < l_1$），数组会保留第 $l_2+1$ 到 $l_1$ 位的内容。为此有以下两种解决方法：
- 每次读入前清空数组；
- 读到 `\0` 后跳出遍历。
2. 计算字符串长度时，`char` 数组请用 `strlen("数组名")`，`string` 变量请用 `"字符串名".size()`；
1. `char` 数组可以用 `\0` 作为遍历结束标志，但这个在 `string` 类型变量末尾并不存在，我们可以用 `"字符串名".push_back('要插入的字符')` 将括号中的字符插入到该字符串的末尾，以此来结束遍历，本题中注意要插入一个输入中不可能出现的字符，例如 `'0'` 或 `'1'` 等；
1. 本题有多组输入，因此用桶数组时注意每次清空数组；
1. 当读到数字时，转换为整型时请注意不要使用类似于 `(int)s[i]`（s 为 `string` 类型）的代码，因为它返回的是 `s[i]` 的 ASCII 值，数据会很大（因为 A 到 Z 的 ASCII 值为 $65$ 到 $90$，且会有乘法运算），所以建议使用 `s[i]-'0'` 来转换数字，这样子当你 debug 的时候也方便；
1. 注意遍历时候下标的变化情况及退出循环的条件；
1. 下面的参考代码中，`i++` 表示使用完 $i$ 后再将 $i$ 加 $1$，而 `++i` 是先将 $i$ 加 $1$ 再使用，请注意区分。

## 扩展
本题中字符串的读入比较简单，没有空格，因此只要用 `cin` 来读取一行字符；但如果以后我们碰到读入多行字符，并且每行字符串中可能存在空格，那怎么办呢？这时候就不能用 `cin` 了，因为 `cin` 是以空格为分隔读入的。可以使用 `getline`，读入 `char` 数组使用 `cin.getline("数组名","数组长度")`，`string` 用 `getline(cin,"变量名")`；另，使用 `getline` 后，请注意把 $n$ 后面的换行符过滤掉，不然读入也会有问题，具体也有两种方法：
1. 输入 $n$ 后用一个 `char` 类型变量加 `getchar` 读入换行符；
1. 使用 `cin.ignore(INT_MAX,'\n')`，括号中的 `INT_MAX` 可以换成一个很大的整数，也可以使用 `numeric_limits<int>::max()` 替换 `INT_MAX`。 

习题：[P8506 标题计数](https://www.luogu.com.cn/problem/P8506)

# 代码实现
具体实现请看注释。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t1[50],t2[50];//桶数组 
signed main()
{
 	cin.tie(NULL)->sync_with_stdio(false);//加速读入，相当于用 scanf，不过 scanf 不太方便 
	int n;
	string s;
	cin>>n;
	//cin.ignore(INT_MAX,'\n')      如果用 getline，这句话别忘了 
	while(n--)
	{
		int flag=0;
		memset(t1,0,sizeof(t1));
		memset(t2,0,sizeof(t2));//注意每次读入前清空 
		cin>>s;
		s.push_back('1');//在 s 末尾插入一个标记字符 
		int l=s.size(),l1=0;//l 为字符串长度，l1 为方程右边开始下标 
		for(int i=0;i<l;i++)//看似遍历全部，实则只遍历了左边 
		{
			if(s[i]=='-'&&s[++i]=='>')//分隔，退出循环条件 
			{
				l1=++i;
				break;
			}
			if(s[i]>='0'&&s[i]<='9')//如果读到系数，例如 3H2O 中的 3 
			{
				int x=(s[i++]-'0');//存下系数 
				while(s[i]!='+')//遍历一个物质 
				{
					if(s[i]>'9')//如果是字母，因为 '9' 的 ASCII 码值是 57，而 'A' 是 65 
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t1[s[i]-'A']+=(s[i+1]-'0')*x;
						//看当前字母后面是否有数字，是就乘上系数 x 存入答案中 
						else t1[s[i]-'A']+=x;//否则直接加 
					}
					i++;
					if(s[i]=='-')
					//读到 '-' 后先 i--，因为跳出 while 后 i 会先 +1 再跳到判断是否跳出 for 循环 
					{
						i--;
						break;
					}
				}
			}
			else//若整个物质系数为 1，其它和上面一样 
			{
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t1[s[i]-'A']+=(s[i+1]-'0');
						else t1[s[i]-'A']++;
					}
					i++;
					if(s[i]=='-')
					{
						i--;
						break;
					}
				}
			}
		}
		for(int i=l1;i<l;i++)
		//遍历方程式右边，这里的代码只是上面代码的修改，只要将跳出循环条件改为判断是否读到 '1' 即可 
		{
			if(s[i]=='1') 
			{
				break;
			}
			if(s[i]>='0'&&s[i]<='9')
			{
				int x=(s[i++]-'0');
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t2[s[i]-'A']+=(s[i+1]-'0')*x;
						else t2[s[i]-'A']+=x;
					}
					i++;
					if(s[i]=='1')
					{
						i--;
						break;
					}
				}
			}
			else
			{
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t2[s[i]-'A']+=(s[i+1]-'0');
						else t2[s[i]-'A']++;
					}
					i++;
					if(s[i]=='1')
					{
						i--;
						break;
					}
				}
			}
		}
		for(int i=0;i<26;i++)//遍历两个桶 
		{
			//cout<<i<<" "<<t1[i]<<" "<<t2[i]<<"\n";
			if(t1[i]!=t2[i])
			{
				cout<<"NE"<<"\n";
				flag=1;//标记变量，若不加会不清楚是因为不符合条件还是正常退出循环 
				break;
			}
		}
		if(flag==0)cout<<"DA"<<"\n";
	}
	return 0;
}
```


---

## 作者：RootMirzayanov (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8324)

## 题意

给定 $n$ 个化学方程式，请判断其是否配平。

## 解析

前置知识：化学方程式（基础知识可从[原题面](https://hsin.hr/coci/contest5_tasks.pdf)阅读获取，在此不做过多赘述)。

观察样例，我们可以将一个化学方程式分为 $4$ 部分：`->` , `+`, 元素（大写字母)及数字。如若配平，则 `->` 左部分每一个元素的数量减去右部分每一个元素的数量都应该等于 $0$, 故我们不妨令 $t$ 为当前处理的分子中每一个元素需乘的系数，初始化为 $t=1$。显然当当前处理的分子处于左半部分时 $t>0$，处于右半部分时 $t<0$. 故当处理到 `->` 时，$t=-1$.

当处理到 `+` 时，$\left\vert t\right\vert=1$, 而原本的正负性应当保留，故 $t\gets \dfrac{\left\vert t\right\vert}{t}$.

当处理到大写字母时，我们可以优先对于该元素个数进行加 $t$ 操作以避免忽略后继非数字的元素。我们可以定义一个 `bool` 类型的变量 `c`, 若为 `True` 则表示上一个处理的字符表示元素，方便有关数字的处理。

当处理到数字时我们可以分两种情况讨论。当 `c` 为 `False` 时，该数字表示当前处理原子的个数，显然有 $t\gets t\times \text{当前处理的数字}$。当 `c` 为 `True` 时，因为前驱元素已经有一步加 $t$ 处理，故我们仅需对于前驱元素再加上 $t\left(\text{当前处理的数字}-1\right)$ 即可。

判断是否配平仅需遍历 $26$ 种元素是否最后结果为 $0$ 即可。时间复杂度为线性。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[30], t;
bool c;
string s;
int main(){
    scanf("%d", &n);
    while(n--){
        cin >> s;
        memset(a, 0, sizeof(a));
        t = 1;
        c = 0;
        for(int i = 0;i < s.length();i++){
            if(s[i] == '-'){
                t = -1;
                c = 0;
                continue;
            }
            if(s[i] == '+'){
                t = abs(t) / t;
                c = 0;
                continue;
            }
            if('A' <= s[i] && s[i] <= 'Z'){
                c = 1;
                a[s[i] - 'A' + 1] = a[s[i] - 'A' + 1] + t;
                continue;
            }
            if('1' < s[i] && s[i] <= '9'){
                if(!c){
                    t = t * (s[i] - '0');
                    continue;
                }
                if(c){
                    a[s[i - 1] - 'A' + 1] = a[s[i - 1] - 'A' + 1] + (s[i] - '1') * t;
                    continue;
                }
            }
        }
        c = 1;
        for(int i = 1;i <= 26;i++){
            if(a[i] != 0){
                printf("NE\n");
                c = 0;
                break;
            }
        }
        if(c) printf("DA\n");
    }
    return 0;
}
```

---


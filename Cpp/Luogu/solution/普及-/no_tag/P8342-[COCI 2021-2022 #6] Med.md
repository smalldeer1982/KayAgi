# [COCI 2021/2022 #6] Med

## 题目描述

今天是公开赛的最后一轮。人们知道这两个比赛采用相同的计分系统。更准确地说，两场比赛都有 $6$ 轮，每轮的积分在 $0$ 分到 $500$ 分之间，每轮比赛的分数会被加起来作为最后排名的总分。六轮比赛结束后，选手将根据总分进行排名。如果两个竞争对手得分相同，则字典序上较小的排名再字典序较大的人之前。没有两个竞争者有相同的名字。
养蜂人非常不耐烦，他们想提前知道他们的最终排名是多少。

每个养蜂人都想知道他们在最终排名中可能的最佳和最差位置。作为 $\rm{COCB}$ 比赛程序员，他们让你告诉他们第六轮后他们可能占据的排名。


## 说明/提示

样例 2：到目前为止，$\rm{ante}$ 是 $1375$ 分，$\rm{mate}$ 是 $875$ 分。如果 $\rm{mate}$ 在最后一轮赢了 $500$ 分，并且 $\rm{ante}$ 是 $0$ 分，结果排名是持平的，他们都有 $1375$ 分。然而，既然是按字典排序，$\rm{ante}$ 比 $\rm{mate}$ 小，所以仍将排名领先。

### 数据范围：

对于 $20\%$ 的数据：$1\le n\le2$

对于 $100\%$ 的数据：$1\le n\le500$，$1\le |s_i|\le10$（保证每个人的名字互不相同），$1\le b_i \le500$

##### 本题分值与 [COCI 2021-2022#6](https://hsin.hr/coci/contest6_tasks.pdf) 分值相同，满分 $50$ 分

## 样例 #1

### 输入

```
3
pavel 120 200 300 400 500
keko 150 400 300 200 100
bartol 470 120 90 93 189```

### 输出

```
1 2
1 3
2 3```

## 样例 #2

### 输入

```
2
ante 275 275 275 275 275
mate 25 100 175 250 325```

### 输出

```
1 1
2 2```

# 题解

## 作者：lihanwen12 (赞：11)

[传送门](https://www.luogu.com.cn/problem/P8342)  

题目大意  
有 $n$ 个人进行 $6$ 轮比赛，已经知道前 $5$ 轮的得分，每个人第 $6$ 轮的可能得分在 $0$ 分到 $500$ 分之间。最终排名按照第一关键字总分从大到小排序，如果第一关键字总分相同按照第二关键字名字的字典序从小到大排序，保证每个人名字不同。询问每个人在最终排名中可能的最佳和最差位置。  

解题思路  
显然如果一个人想拿到最佳名次，那么最后一轮只有这个人得到了 $500$ 分其他人都得到 $0$ 分（什么逆天改命）。如果一个人拿到了最差名次，我们可以让这个人最后一轮得到 $0$ 分其他人都得到 $500$ 分（老天：我又改回来了），相当于其他人都得到 $0$ 分而这个人得到了 $-500$ 分。这样我们就可以参照[P7910 [CSP-J 2021] 插入排序](https://www.luogu.com.cn/problem/P7910)的做法，首先对所有人前 $5$ 轮的状态进行排序，考虑第 $6$ 轮得分相当于对单点进行修改，利用插入排序的思想 $O(n)$ 去维护最终排名。时间复杂度为 $O(n^2)$。

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
long long read(){
	long long x=0,sgn=1;char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')sgn=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch&15);ch=getchar();}
	return x*sgn;
}
long long n,x,a[510],pos[510],val[510];
string st[510];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>st[i];
		for(int j=1;j<=5;j++){
			cin>>x;
			val[i]+=x;
		}
		pos[i]=i;//pos[i]表示第 i 个人当前的排名
		a[i]=i;//a[i]表示当前排名第 i 个人是输入数据中的第几个人
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n-i;j++)
			if(val[a[j]]<val[a[j+1]] || val[a[j]]==val[a[j+1]] && st[a[j]]>st[a[j+1]]){
				swap(a[j],a[j+1]);
				swap(pos[a[j]],pos[a[j+1]]);
			}//O(n^2)冒泡排序处理初始排名
	for(int i=1;i<=n;i++){
		val[i]+=500;//最好名次：自己拿了500分，其他人都是0分 
		for(int j=pos[i]-1;j>=1;j--)
			if(val[a[j]]<val[a[j+1]] || val[a[j]]==val[a[j+1]] && st[a[j]]>st[a[j+1]]){
				swap(a[j],a[j+1]);
				swap(pos[a[j]],pos[a[j+1]]);
			}
			else break;
		cout<<pos[i]<<" ";
		val[i]-=500;//消除影响回到最初状态
		val[i]-=500;//最坏名次：其他人都是0分，自己拿了-500分 
		for(int j=pos[i]+1;j<=n;j++)
			if(val[a[j]]>val[a[j-1]] || val[a[j]]==val[a[j-1]] && st[a[j]]<st[a[j-1]]){
				swap(a[j],a[j-1]);
				swap(pos[a[j]],pos[a[j-1]]);
			} 
			else break;
		cout<<pos[i]<<endl;
		val[i]+=500;//消除影响回到最初状态
		for(int j=pos[i]-1;j>=1;j--)
			if(val[a[j]]<val[a[j+1]] || val[a[j]]==val[a[j+1]] && st[a[j]]>st[a[j+1]]){
				swap(a[j],a[j+1]);
				swap(pos[a[j]],pos[a[j+1]]);
			}
			else break;
	}
	return 0;
}

```

---

## 作者：看什么看 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8342)

对于一个人来说，他最好的情况就是第六场 $500$ 分，其他人 $0$ 分；最坏的情况是第六场 $0$ 分，其他人 $500$ 分。而在这个过程中有大量的人的分数并没有发生变化，不难想到可以用平衡树维护。

由于给其他人全部加 $500$ 分很难实现，而我们只需要他的相对分数，所以可以看成自己减 $500$ 分，就很好实现了。

剩下的看代码吧。时间复杂度 $O(n\log n)$。

~~vector+二分这么好写的平衡树替代品为什么不用呢~~

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    string name;
    int score;
    node (){
        name = "", score = 0;
    }
    node (const string &Name, const int &Score){
        name = Name, score = Score;
    }
    bool operator < (const node &x) const {
        if (score ^ x.score) return score > x.score;
        return name < x.name;
    }
}a[503];
int n;
vector<node>v;
int main(){
    cin >> n;
    for (int i = 0;i < n;++i){
        cin >> a[i].name;
        for (int j = 0, k;j < 5;++j){
            cin >> k;
            a[i].score += k;
        }
        v.insert(lower_bound(v.begin(), v.end(), a[i]), a[i]);
    }
    for (int i = 0;i < n;++i){
        v.erase(lower_bound(v.begin(), v.end(), a[i])); // 先把自己拉出来
        printf ("%d ", lower_bound(v.begin(), v.end(), node(a[i].name, a[i].score+500))-v.begin()+1); // 最好情况
        printf ("%d\n", lower_bound(v.begin(), v.end(), node(a[i].name, a[i].score-500))-v.begin()+1); // 最坏情况
        v.insert(lower_bound(v.begin(), v.end(), a[i]), a[i]); // 再把自己放回去
    }
    return 0;
}
```


---

## 作者：Dream_weavers (赞：3)

## 题意

有 $n$ 个人参加比赛，已经比完了 $5$ 轮，还差 $1$ 轮没比，一轮中的分数是 $0$ 到 $500$ 的中的一个数。最后的排名按照每个选手的总分总大到小排序，若选手分数相同，则按照名字的字典序排序。求第 $i$ 名选手最后排名的**最好情况**和**最坏情况**。

## 思路

很明显是一道模拟+结构体排序题，最好情况就是**自己得 $500$ 分其他人得 $0$ 分**；最坏情况相反，就是**自己得 $0$ 分其他人得 $500$ 分**。

用一个数组记录第 $i$ 名选手得名字和前五轮总分。遍历每一个选手，用另一个数组记录原数组得名字和前五轮总分，第 $i$ 名选手 $+500$，排序后找到**原来**第 $i$ 名选手得位置（可以用名字找），输出其位置，这是最好情况。最坏情况就重复一遍上面的步骤，唯一不同的是**除**第 $i$ 名选手，其他选手 $+500$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=10005;
int n,x;
struct node{//建立结构体
	int sco;
	string name;
}a[N],b[N];

bool cmp(node x,node y){//自定义排序
	if(x.sco!=y.sco)return x.sco>y.sco;
	else return x.name<y.name;
}

signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		cin>>a[i].name;//输入名字
		for(int j=1;j<=5;j++){
			scanf("%lld",&x);
			a[i].sco+=x; //求前五轮总分
		}
	}
	for(int i=1;i<=n;i++){
		string s=a[i].name;
		//最好情况
		for(int j=1;j<=n;j++)b[j].sco=a[j].sco,b[j].name=a[j].name;//记录原数组
		b[i].sco+=500;//第i名+500
		sort(b+1,b+n+1,cmp);//排序
		for(int j=1;j<=n;j++){//找位置
			if(b[j].name==s){
				printf("%lld ",j);
				break;
			}
		} 
		//最坏情况，和最好情况类似就不多说了
		for(int j=1;j<=n;j++)b[j].sco=a[j].sco+500,b[j].name=a[j].name;
		b[i].sco-=500;
		sort(b+1,b+n+1,cmp);
		for(int j=1;j<=n;j++){
			if(b[j].name==s){
				printf("%lld\n",j);
				break;
			}
		} 
	}
	return 0;
}

```

---

## 作者：yydfj (赞：1)

**这是本蒟蒻第二十一次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你 $n$ 个人的名字，每个人各有 $6$ 个分数，除了第 $6$ 个分数，其他分数都是确定的。这些人会进行一个排列，分数越高，排名越靠前，如果分数相同，则名字的字典序较小的人靠前。已知他们第六个分数都在 $0$ 到 $500$ 的范围内，问他们可能得到的最小排名和最大排名是多少。

## 解法综述

~~想象一下自己考试时，别人是如何反超我们的。~~ 由此我们得出结论，这 $n$ 个人能得到的最小排名是他得了 $500$ 分而别人都得了 $0$ 分的结果，最大排名是他得了 $0$ 分而别人都得了 $500$ 分的结果。然后，我们就用循环来模拟这些情况。

我们可以利用结构体来保存这 $n$ 人的初始编号（即第几个人），以便排序时能很好地找出这个人的排名，然后输出即可。

有一点需要注意，因为第 $6$ 个分数是我们自己给的，是不确定的，所以在找出答案之后，还需要将第 $6$ 个分数统一（最好是清零）。

## 代码描述
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int v,id;//id存人的初始编号
	string s;//string可以直接被用来排字符的字典序大小
}f[505];
int n,a,b,c,d,e;
bool cmp(node x,node y)
{
	if(x.v==y.v) return x.s<y.s;//如果分数相同，则名字的字典序较小的人靠前
	return x.v>y.v;//分数越高，排名越靠前
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>f[i].s>>a>>b>>c>>d>>e;
		f[i].v=a+b+c+d+e;
		f[i].id=i;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		if(i==f[j].id) f[j].v+=500;//第i个人得了500分而别人都得了0分
		stable_sort(f+1,f+n+1,cmp);//排序
		for(int j=1;j<=n;j++)
		if(f[j].id==i) printf("%d ",j);//得到的最小排名
		for(int j=1;j<=n;j++)
		if(i==f[j].id) f[j].v-=500;//将第6个分数清零
		for(int j=1;j<=n;j++)
		if(i!=f[j].id) f[j].v+=500;//第i个人得了0分而别人都得了500分
		stable_sort(f+1,f+n+1,cmp);//排序
		for(int j=1;j<=n;j++)
		if(f[j].id==i) printf("%d\n",j);//得到的最大排名
		for(int j=1;j<=n;j++)
		if(i!=f[j].id) f[j].v-=500;//将第6个分数清零
	}
	return 0;
}
```

---

## 作者：xixisuper (赞：1)

# P8342 [COCI2021-2022#6] Med  题解

蒟蒻题解，不喜勿喷

[题目传送门](https://www.luogu.com.cn/problem/P8342)

## step 1 题目理解
简单地说，这个题目就是一个排序的运用。

在最后一轮比赛开始前，输出每个养蜂人的最佳排名以及最差排名。
## step 2 解题思路
要求出最佳排名和最差排名，就要首先了解对于一位养蜂人的最佳情况和最差情况分别是什么。

我们可以自行带入一下，如果我是一名养蜂人，在最后一场比赛开始前，最好的情况就是最后一场比赛我自己一个人得满分，其他人都零分，而最差情况自然就是我自己一人得零分，其他人都得满分。

根据这两种情况，我定义了两个数组，maxbi 以及 minbi，用来存放第i个养蜂人的最佳得分情况和最差得分情况（其实在做完此题后才发现，这样有点画蛇添足了，但是这样做更加容易理解 ~~至少我觉得是的~~）。

然后就是排序阶段了，我这里使用的 c++ 函数库自带的 sort() 函数进行结构体类型变量的排序。

结构体变量由得分和养蜂人的编号组成。排序阶段，外层是一个 i 从 1 到 n 的大循环，表示我们要求的养蜂人的编号。在循环内部，分为两个部分，分别计算最佳排名和最差排名。最佳排名部分，将结构体的下标为 i 的元素的得分设为 maxbi 其余的元素都将得分设为 minbi ，最差部分 maxbi 和 minbi 恰好相反。在排序后，找到养蜂人编号为 i 的元素，直接输出该元素的下标即可。 

这样，该题的核心部分就完成了
 
#### 在排序时有几点需要注意：
#### 1.结构体变量的组成
#### 2.字典序的比较
#### 3.比较时需要自定义cmp比较函数

#### 结构体：
```
struct node{
	int num;//得分情况
	int id;//养蜂人编号
};
```
#### 字典序比较：
```
bool jdg(string a,string b){
	int a_len=a.size(),b_len=b.size(),i=0,j=0;
	while(a_len!=0&&b_len!=0){
		if(a[i++]==b[j++]){a_len--;b_len--;continue;}
		return a[i-1]<b[i-1];
        //如果两字母相等，则继续比较，否则直接返回 a[i-1]<b[i-1] 的值
	}
	if(a_len==0) return 0;
	return 1;
    //如果其中a名字已完全比较完，则返回0，否则返回1
}
```
#### cmp比较函数：
```
bool cmp(node a,node b){
	if(a.num==b.num) return jdg(name[a.id],name[b.id]);
    //若两得分相等，则比较名字的字典序
	return a.num>b.num;
    //若两得分不相等，则返回 a.num>b.num 的值
}
```

## step 3 AC代码
AC代码如下，悉数奉上

因为本人太蒻，这道题代码比较长，没有做相应的一些优化，各位通过该题的大佬勿喷

```cpp
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
const int N = 505;
string name[N];
int maxbi[N],minbi[N],n,x;
//maxbi数组存放最大得分，minbi数组存放最小得分
struct node{//进行结构体排序的结构体
	int num;//得分情况
	int id;//养蜂人编号
};
bool jdg(string a,string b){//判断名字的字典序
	int a_len=a.size(),b_len=b.size(),i=0,j=0;
	while(a_len!=0&&b_len!=0){
		if(a[i++]==b[j++]){a_len--;b_len--;continue;}
		return a[i-1]<b[i-1];
	}
	if(a_len==0) return 0;
	return 1;
}
bool cmp(node a,node b){//比较函数
	if(a.num==b.num) return jdg(name[a.id],name[b.id]);
	return a.num>b.num;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){//输入部分
		cin>>name[i];
		for(int j=1;j<=5;j++){
			cin>>x;
			minbi[i] += x;
		}
		maxbi[i] = minbi[i] + 500;
	}
	node nst[n+1];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){//排序前处理
			if(j==i) nst[j].num=maxbi[j];
			else nst[j].num=minbi[j];
			nst[j].id = j;
		}
		sort(nst+1,nst+n+1,cmp);
		for(int j=1;j<=n;j++) if(nst[j].id==i) cout<<j<<' ';
        //以上为最佳情况计算和输出
		for(int j=1;j<=n;j++){//排序前处理
			if(j!=i) nst[j].num=maxbi[j];
			else nst[j].num=minbi[j];
			nst[j].id = j;
		}
		sort(nst+1,nst+n+1,cmp);
		for(int j=1;j<=n;j++) if(nst[j].id==i) cout<<j<<endl;
        //以上为最差情况计算和输出
	}
	return 0;
}
```


---

## 作者：LKY928261 (赞：1)

## 题目分析

#### 暴力

思路非常简单：对于每个人的最佳排名，可以让当前的人的分数为满分，其余人都是 0 分，即给当前的人的分数加上 500 分，再直接依题意快排，枚举名字求名次。

对于最差排名也是同理，给其他人都加上 500 分再排序即可。

注意需要开两个数组，一个保存原数组，另一个用于更改和排序。

时间复杂度为 $O(n^2\log n)$。

#### 加速

可以考虑先将所有的初始状态进行排序，之后每次二分查找第一个排名比当前的人靠后者的名次。可以大大缩小时间复杂度。

而在最差情况下，要给其他每个人都加 500 分，这相对而言等价于给当前的人减去 500 分。在不影响排序的前提下，还可以优化时间复杂度。

优化后的时间复杂度为 $O(n\log n)$。

（只是数据范围很小，除了练手没有必要优化）

## 参考代码

本人的代码非常精简，欢迎借(chao)鉴(xi)。

**本题解仅提供暴力做法的代码。**~~（其实就是加速做法懒得打）~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,x,i,j;
struct o{ll x;string y;}a[505],b[505];
bool Q(o x,o y){return x.x>y.x||(x.x==y.x&&x.y<y.y);}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=0;i<n;i++){
		cin>>a[i].y;
		cin>>x;a[i].x+=x;
		cin>>x;a[i].x+=x;
		cin>>x;a[i].x+=x;
		cin>>x;a[i].x+=x;
		cin>>x;a[i].x+=x;
	}
	for(i=0;i<n;i++){
		for(j=0;j<n;j++)b[j].x=a[j].x,b[j].y=a[j].y;
		b[i].x+=500;sort(b,b+n,Q);
		for(j=0;j<n;j++)if(b[j].y==a[i].y){cout<<j+1<<" ";break;}
		for(j=0;j<n;j++)b[j].x=a[j].x,b[j].y=a[j].y;
		b[i].x-=500;sort(b,b+n,Q);
		for(j=0;j<n;j++)if(b[j].y==a[i].y){cout<<j+1<<"\n";break;}
	}
}
```

---

## 作者：EastPorridge (赞：1)

### 题目大意
------------
统计每个人最好与最差的排名，输出。

#### 思路
 一个人的最差排名可转化为其余人最好成绩与这个人最差成绩的排名，同理，一个人的最好排名可转化为其余人最差成绩与这个人最好成绩的排名。
 
 题目描述已经统计五轮成绩，所以每个人的最好成绩为 
 $\sum_{i=1}^5a_i +500$，最差成绩为
 $\sum_{i=1}^5a_i +0$ 。
 
 特别注意的：当两个人成绩相同时，需按字典序大小排序。
 
------------
### Code.
枚举所有选手的所有情况，比较，时间复杂度为
$O(n^2)$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000;
struct node
{
	string nam;
	int sum,b;
	int n1,n2;
}e[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>e[i].nam;
		for(int j=1;j<=5;j++)
		{
			int a;
			scanf("%d",&a);
			e[i].sum+=a;//统计前五轮成绩 
		}
		e[i].b=e[i].sum+500;//计算最好成绩 
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==j) continue ;
			if(e[i].b<e[j].sum) e[i].n1++;//若最好成绩比其他选手最差成绩低，则最好排名后移一位 
			else if(e[i].b==e[j].sum && e[j].nam<e[i].nam) e[i].n1++;//字典序比较 
			if(e[i].sum<e[j].b) e[i].n2++;//若最差成绩比其他选手最好成绩低，则最差排名后移一位 
			else if(e[i].sum==e[j].b && e[j].nam<e[i].nam) e[i].n2++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d %d\n",++e[i].n1,++e[i].n2);
	}
	return 0;
}
```


---

## 作者：Hisaishi_Kanade (赞：1)

### 题意

有 $n$ 个人参加一场比赛，共六轮，已知前五轮的分数，求每个人**最好和最差**排名

### 思路

考虑到第六轮成绩的未知，所以我们可以用 $\Theta(n^2)$ 的方法：

**对于第 $i$ 个人，统计有几个人的成绩可能比这个人高，几个人的成绩可能比这个人低。**

为此，我们需要写一个 `cmp` 函数：
```cpp
inline const bool cmp(const int& _x,const int& _y){
	return(a[_x]+500==a[_y]?name[_x]<name[_y]:a[_x]+500>a[_y]);
}//判断_x号和_y号的大小
```
对于输出，考虑计算两个答案数组。

因为以上的 `cmp` 函数是求 `_x` 号养蜂人是否可能比 `_y` 号名次高，所以一个数组结果加 `!cmp(i,j)` ，另一个加 `cmp(i,j)`。

别忘了，如果有 $x$ 人名次在你之前，那么你的名次是 $x+1$！

接下来只给出一部分代码，其余请自行完成。
```cpp
for(i=1;i<=n;++i)
	for(j=1;j<=n;++j)
		if(i!=j){//自己不能跟自己比
			ans1[i]+=!cmp(i,j);//比他小的人数
			ans2[j]+=cmp(i,j);//比他大的人数
		}//n^2求结果
```

---

## 作者：sgl654321 (赞：0)

### 题目描述
- 有 $n$ 个人， $6$ 场比赛。每一场比赛的分数都在 $0\sim500$ 之间。
- 现在已经知道每个人前 $5$ 场的比赛分数，求出每个人可能的最高名次和最低名次。
- 其中，名次按如下方式排序：先分数高的排前面，若分数相同，则名字字典序小的排后面。

### 解题思路
$20$ 分做法：
- 若 $n=1$，则直接输出 $1$ $1$。
- 若 $n=2$，考虑最后一场比赛的极端情况：一种是 $A$ 拿 $500$ 分，$B$ 拿 $0$ 分；一种是 $A$ 拿 $0$ 分， $B$ 拿 $500$ 分。用这两种情况，就可以求出 $A$ 与 $B$ 可能的最终名次了。

满分做法：

根据刚才的 $20$ 分做法，容易想到，本题正解就是考虑极端情况。

对于每一个人，可能拿到的最高名次，就是最后一场比赛他拿 $500$ 分，其他人都拿 $0$ 分的情况。反之，最低名次就是他拿 $0$ 分，其他人都拿 $500$ 分的情况。由于修改所有其他人的分数比较麻烦，稍加思考后可以发现：

一个人拿 $0$ 分，其余人拿 $500$ 分，就等价于他拿 $-500$ 分，其他人都拿 $0$ 分。

因此，先定义结构体存储每个人的名字和当前 $5$ 场比赛的总得分，然后分最高名次和最低名次两种情况进行讨论。至于排序，直接用快排 ```sort``` 即可。

### 参考代码
时间复杂度 $O(n^2\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x;
string f;
struct q{
	string name;
	long long s;
}a[510],b[510];
bool cmp(q x,q y){
	if(x.s>y.s)return 1;
	if(x.s<y.s)return 0;
	return x.name<y.name;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].name;
		for(int j=1;j<=5;j++){
			cin>>x;
			a[i].s+=x;
		}
	}
	for(int i=1;i<=n;i++){
		a[i].s+=500;
		for(int i=1;i<=n;i++)
			b[i]=a[i]; 
		f=b[i].name;
		sort(b+1,b+n+1,cmp);
		for(int j=1;j<=n;j++)
			if(b[j].name==f)cout<<j<<" ";
		a[i].s-=1000;
		for(int i=1;i<=n;i++)
			b[i]=a[i]; 
		f=b[i].name;
		sort(b+1,b+n+1,cmp);
		for(int j=1;j<=n;j++)
			if(b[j].name==f)cout<<j<<endl;
		a[i].s+=500;
	}
	return 0;
} 
```
[记录](https://www.luogu.com.cn/record/75776364)

---

## 作者：Firstly (赞：0)

## **解题思路：**

由题可知，一个养蜂人的最佳排名是当他最后一轮得到了 $500$ 分，而其他养蜂人均得到了 $0$ 分时，最差排名是当他最后一轮得到了 $0$ 分，而其他养蜂人均得到了 $500$ 分时。

我们可以循环遍历所有养蜂人，第 $i$ 次循环把第 $i$ 个养蜂人作为中心。在第 $i$ 次循环中，我们分别将这个养蜂人的可能的最佳成绩和别人可能的最差成绩作比较，将他可能的最差成绩和别人可能的最佳成绩作比较。当出现两个人的分数一样的情况时，将两个人的名字直接比较即可。

## **Code：**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
struct node{
    string name;
    int sum;
}a[505];
int n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int tmp;
        cin>>a[i].name;
        for(int j=1;j<=5;j++)cin>>tmp,a[i].sum+=tmp;
    }for(int i=1;i<=n;i++){
        int maxn=1,minn=1;
        for(int j=1;j<=n;j++){
            if(i==j)continue;
            if(a[i].sum+500<a[j].sum)maxn++;
            else if(a[i].sum+500==a[j].sum&&a[i].name>a[j].name)maxn++;
        }for(int j=1;j<=n;j++){
            if(i==j)continue;
            if(a[i].sum<a[j].sum+500)minn++;
            else if(a[i].sum==a[j].sum+500&&a[i].name>a[j].name)minn++;
        }cout<<maxn<<' '<<minn<<endl;
    }return 0;
}
```


---

## 作者：Buried_Dream (赞：0)

## 题意：

给你 $n$ 个人，还有他的五场成绩，第六场成绩不知道，但成绩在 $[0,500]$  中，问每个人的最优和最劣排名。

## 思路：

简单模拟题。

对于每个人，他的最大排名就是自己拿 $500$，别人都是 $0$ 分。

他的最小排名是自己拿 $0$ 分，别人都是 $500$ 分。

模拟即可。

## AC code:

```cpp
/*
	Work by: TLE_Automation
*/
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define LL long long
#define int long long
using namespace std;

const int N = 1e6 + 10;
const int MAXN = 2e5 + 10;

inline char readchar() {
	static char buf[100000], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

inline int read() {
#define readchar getchar
	int res = 0, f = 0;
	char ch = readchar();
	for (; !isdigit(ch); ch = readchar()) if (ch == '-') f = 1;
	for (; isdigit(ch); ch = readchar()) res = (res << 1) + (res << 3) + (ch ^ '0');
	return f ? -res : res;
}

inline void print(int x) {
	if (x < 0 ) putchar('-'), x = -x;
	if (x > 9 ) print(x / 10);
	putchar(x % 10 + '0');
}

struct _Node {
	string s;
	int sum;
	bool operator < (const _Node &x) const {
		return sum != x.sum ? sum > x.sum : s < x.s;
	}
} a[MAXN], b[MAXN];
int wz;
#define re register
signed main() {
//	ios::sync_with_stdio(0);cin.tie(0), cout.tie(0);
	int n = read();
	for (register int i = 1; i <= n; i++) {
		cin >> a[i].s;
		for (re int j = 1; j <= 5; j++) a[i].sum += read();
	}
	for (re int i = 1; i <= n; i++) b[i].s = a[i].s, b[i].sum = a[i].sum;
	for (re int i = 1; i <= n; i++) {
		string S = a[i].s;
	for (re int j = 1; j <= n; j++) b[j].s = a[j].s, b[j].sum = a[j].sum;	
		for (re int j = 1; j <= n; j++) {
			if (b[j].s == S) {
				b[j].sum += 500;
				break;
			}
		}
		sort(b + 1, b + n + 1);
		for (re int j = 1; j <= n; j++) {
			if (b[j].s == S) {
				printf("%lld ", j);
				wz = j;
				break;
			}
		}
		b[wz].sum -= 500;
		for(re int j = 1; j <= n; j++)  {
			if(b[j].s != S) b[j].sum += 500;
		}
		sort(b + 1, b + n + 1);
		for (re int j = 1; j <= n; j++) {
			if (b[j].s == S) {
				printf("%lld\n", j);
			}
		}
	}
	return 0;
}
```

---

## 作者：iiiiiiiiiiiiiiiiiii (赞：0)

## 题目大意

给你 $n$ 个人前五轮的分数，他们第六轮得分最低为 $0$，最高为 $500$，求每个人的总分数从大到小排的最好排名和最差排名。

## 算法

贪心。

一个人最好排名就是他第六轮得了 $500$ 分，而其他人 $0$ 分；最差排名就是他得了 $0$ 分，其他人都得了 $500$ 分。可以每一次分别模拟他的最好情况和最差情况，并求排名，用 sort 最坏时间复杂度为 $O(n^3)$，但常数较大，要吸氧才能过。

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<queue>
#include<string>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=520;
const double eps=1e-5;
int read()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48,ch=getchar();}
	return x*f;
}
int n;
struct node
{
	string name;
	int sum,id;
}p[N],b[N];
bool cmp(node x,node y)//如果两个人分数不一样按分数排，否则按名字字典序排
{
	if(x.sum!=y.sum)
		return x.sum>y.sum;
	return x.name<y.name;
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].name;
		for(int j=0;j<5;j++)
			p[i].sum+=read();
		p[i].id=i;
	}
	for(int i=1;i<=n;i++)
	{
		memset(b,0,sizeof b);//b是最好或最坏结果时的分数
		for(int j=1;j<=n;j++)
		{
			b[j]=p[j];
			if(b[j].id==p[i].id)//最好，第i个人第六轮500分，其他人0分
				b[j].sum+=500;
		}
		sort(b+1,b+1+n,cmp);
		int minn=0,maxx=0;
		for(int j=1;j<=n;j++)//扫一遍，看现在第j名的原来是不是第i个人
			if(b[j].id==p[i].id)
			{
				minn=j;
				break;
			}
		for(int j=1;j<=n;j++)
		{
			b[j]=p[j];
			if(b[j].id!=p[i].id)//最坏，第i个人第六轮0分，其他人500分
				b[j].sum+=500;
		}
		sort(b+1,b+1+n,cmp);
		for(int j=1;j<=n;j++)
			if(b[j].id==p[i].id)
			{
				maxx=j;
				break;
			}
		printf("%d %d\n",minn,maxx);
	}
	return 0;
}

```


---

## 作者：cfkk (赞：0)

### 题目大意：
给出 $n$ 个人前 $5$ 场比赛的分数，让你求出每个人的最好排名和最坏排名。

现在我们知道，一个人要想排名最高，那么再最后一局一定要达 $50$ 分。其次，另外 $n-1$ 个人一定要得 $0$ 分。

相对应的，一个人要想排名最低，自己的分数一定要是 $0$ 分，其他人的分数一定要是 $500$ 分。

知道了这两条信息，再特判一下成绩相等时的字典序大小，这道题很容易就做出来了。

代码来喽（小心棕名）：

```python
from functools import cmp_to_key

def cmp(x, y):
    if x[0] == y[0]:
        return [1, -1][x[1] < y[1]]
    return [-1, 1][x[0] < y[0]]

n = int(input())
m = []
for i in range(n):
    l = input().split()
    m.append([sum(map(int, l[1:])), l[0]])
for i in range(n):
    x = m[:]
    m[i][0]+=500
    x.sort(key=lambda x: x[1])
    x.sort(key=lambda x: x[0], reverse=True)
    print(x.index(m[i])+1, end=' ')

    y = m[:]
    m[i][0]-=2*500
    y.sort(key=lambda x: x[1])
    y.sort(key=lambda x: x[0], reverse=True)
    print(y.index(m[i])+1)
    m[i][0]+=500

```


---


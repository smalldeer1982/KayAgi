# 不等价交换法则

## 题目背景

天弓千亦，市场之神，拥有着剥夺所有权的能力。

她希望着重建市场，在严格而公正的交易中一点点恢复自己的神力。但她看向世间一处处交易之所时，无力感却又遮住了她心中虹色的月光，把她的不甘一点点化作现实的泪。

她一次次在梦中经历着那个晚上。孤独的、神力尽失的她，紧紧攥住她那空白的卡牌，却被灵梦一把夺走。最后一张希望，也伴着虹色的月，消逝在永远的幻想中了。

也许交易本身就是不等价的吧，她想。

## 题目描述

你有 $n$ **件**商品可以买，其中第 $i$ 件的价格为 $a_i$。

蓝会给出一个正整数 $w$，代表你有 $w$ 元钱。你仅可以选择**一件**商品购买。店主允许你用已有的商品交换剩余的商品（当然了，也可以不换），但你交换获得的商品的价值和必须小于等于你用于交换的商品价值和。你想要知道，你最多能获得多少件商品。

注意：不能用空集交换其他商品。

## 说明/提示

【样例解释】

买价值为 $2$ 的物品，并交换为两个价值为 $1$ 的物品。

【数据范围及约束】

对于 $40\%$ 的数据，$n\leq 10$。

对于 $100\%$ 的数据，$1 \leq n\leq10^6$，$0 \leq a_i\leq 10^9$，$1 \leq w\leq2\times10^{9}$。


## 样例 #1

### 输入

```
3 
1 1 2
5```

### 输出

```
2```

# 题解

## 作者：GOD_hj (赞：12)

这只是一道模拟排序题。  
先排序(从小到大），找到最大价值的商品，  
标记后退出循坏，如果 $t>0$，在从小到大排序，再进行交换商品。
## $node$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
long long a[N],n,w,t=0,ans=0;//开long long！
inline bool cmp(int x,int y){
	return x>y;//从大到小排序
}
inline bool cmp1(int x,int y){
	return x<y;//从小到大排序
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	scanf("%lld",&w);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i){
		if(t==0)
			if(w-a[i]>=0){
				w-=a[i];//减去最大值
				t=a[i];//标记
				break;//退出循坏
			}
	}
	if(t){
		sort(a+1,a+n+1,cmp1);
		for(int i=1;i<=n;++i){
			if(t>=a[i]){
				t-=a[i];
				ans++;//累计答案
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：_Give_up_ (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P8444)

## 题目思路

此题就是一道简单的贪心，先从小到大排序（也可以从大到小），取能买的起的最贵的物品。

找到后从小到大遍历，求能买的起的价值最高的的物品最多能换到多少其他的物品，用一个计数器计数，最后输出这个计数器的值就行了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long //a[i]的范围很大，要开long long
#define N 1000010

using namespace std;

typedef long long ll;

int read()
{
    int x = 0,f = 1;
    char c = getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-') f = -1;
        c = getchar();
    }
    while(c>='0' && c<='9')
    {
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
    return x*f;
}//快读

int a[N];

signed main()
{
    int n=read();
    for (int i=1;i<=n;i++)
        a[i] = read();
    int w=read(),k=0;
    sort(a+1,a+n+1); //从小到大排序
    for (int i=n;i>=1;i--)
    {
        if (w>=a[i])
        {
            k = a[i];
            break;
        }
    }//求能买的起的最贵的物品
    int ans = 0;//定义一个计数器，初始值为0
    for (int i=1;i<=n;i++)
    {
        if (k>=a[i])
        {
            ans++;//计数器+1
            k -= a[i];
        }
    }//求能买的起的价值最高的的物品最多能换到多少其他的物品
    cout << ans << endl;//输出计数器的值
    return 0; 
}
```


---

## 作者：LYqwq (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P8444)

# 题目大意

有 $n$ 件商品，其中第 $i$ 件的价格为 $a_i$。

你有 $w$ 元钱，你**仅可选择一件**商品购买。但你可以用已有的商品交换剩余的商品（也可以不换），但你获得的商品价值和不能大于你用于交换的商品价值。

求最多能获得的**商品数**。

# 思路

显然，我们的 $w$ 元钱购买的商品应该买能买的商品里最大价值的，这样就可以最大化 $w$ 元钱带来的收益。

我们要怎么样处理交换呢？

我们可以发现一个性质：用一件价值大的商品交换若干小的商品，再交换交换交换······所得来的物品个数和直接用买来的商品交换一次所得来的一样，甚至少，还要考虑选择哪些物品来交换。

就比如说有 $10$ 件物品，价值分别为 $1,2,\dots,9,10$，买来一个十元的物品，最多能换 $4$ 个物品。

换 $4$ 个物品的方案：用 $10$ 直接换 $1,2,3,4$。

那多换几次所得来的结果呢？也可以是 $4$，一种方案是：$10 \to 6,4$，$6 \to 1,2,3$，还是能换到 $1,2,3,4$。

显然，换来的物品都是价值最小的几个。

有了这个性质，贪就行了。

我这用一个小根堆来找最小元素，并在交换前 $\mathcal{O}(n)$ 初始化并 $\mathcal{O}(n)$ 找到最大价值的可以买的物品。

然后一直取小根堆堆顶元素，可以的话换到，否则就直接输出答案。

关于小根堆初始化的复杂度，可以参考[『学习笔记』二叉堆](https://www.cnblogs.com/LYqwq/articles/binary-heap.html)。

# 代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;
template<typename T=int>
inline T read(){
    T X=0; bool flag=1; char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<1)+(X<<3)+ch-'0',ch=getchar();
    if(flag) return X;
    return ~(X-1);
}

const int N=1e6+5;
int n,w,s,ans;
int a[N];

template<class T=int>
class Heap{
    public:
        Heap(bool (*_cmp)(T,T)=[](T a,T b)->bool{return a<b;}):cmp(_cmp){clear();}
        void clear(){
            memset(a,0,sizeof(a));
            l=0;
        }
        void build(T *_a,int n){
            for(int i=1; i<=n; i++)
                a[i]=_a[i-1];
            l=n;
            for(int i=n>>1; i; i--)
                sink(i);
        }
        void push(T x){
            a[++l]=x;
            swim(l);
        }
        void pop(){
            a[1]=a[l--];
            sink(1);
        }
        T top(){return a[1];}
        bool empty(){return l==0;}
        int size(){return l;}
    private:
        T a[N];
        int l;
        bool (*cmp)(T,T);
        void swim(int x){ // 上浮 log n
            for(int i=x; i>1 && cmp(a[i],a[i>>1]); i>>=1)
                swap(a[i],a[i>>1]);
        }
        void sink(int x){ // 下沉 log n
            for(int i=x,t=son(i); t<=l && cmp(a[t],a[i]); i=t,t=son(i))
                swap(a[i],a[t]);
        }
        inline int ls(int x){return x<<1;} // 取左右儿子
        inline int rs(int x){return x<<1|1;}
        // 取较小的儿子
        inline int son(int x){return ls(x)+(rs(x)<=l && cmp(a[rs(x)],a[ls(x)]));}
};
Heap h;

int main(){
    n=read();
    for(int i=1; i<=n; i++)
        a[i]=read();
    w=read();
    h.build(a+1,n); // 建堆
    for(int i=1; i<=n; i++) // 找最大价值
        s=max(s,a[i]<=w ? a[i] : 0);
    // 开始交换
    while(!h.empty())
        if(h.top()<=s)
            s-=h.top(),h.pop(),ans++;
        else
            break;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ykzzldz (赞：5)

这次月赛前两题都是比较基础的题目，本题的思路就是先用 $w$ 元钱买一个不大于 $w$ 元的最贵的商品，再用这个商品去换其他的较为便宜的商品。所以，本题是一道贪心，在找到能买到的最贵商品后，从最便宜的商品开始买，直到超过能买到的最贵商品的价格。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
#include<ctime>
#include<iomanip>
#include<set>
#include<algorithm>
#include<cmath>
#include<fstream>
#include<map>
using namespace std;
int main(){
	long long n,a[1100000],w,aa=0,jsq=0;
	cin>>n;
	for(long long i=0;i<n;i++)cin>>a[i];
	sort(a,a+n);//将物品的价格进行排序
	cin>>w;
	for(long long i=0;i<n;i++)
	{
		if(a[i]>w)break;//如果当前物品的价格超过了 w，那么就跳出
		aa=a[i];//否则就买下
	}
	for(long long i=0;i<n;i++)
	{
		if(aa>0){
			aa-=a[i];
			jsq++;//加上新买的商品
		}
		if(aa==0)break;//没钱了，跳出
		if(aa<0)
		{
			jsq-=1;
			break;//透支了，把一个商品还给老板，再跳出
		}
	}
	cout<<jsq;//输出答案
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：5)

# 思路
一个结论：用钱买的那件商品要尽量贵。显然。

另一个结论：交换只会进行一次。

简单证明：如有交换过程 $A\rightarrow B\rightarrow C$，则有 $\sum\limits_{a\in A} a\ge\sum\limits_{b\in B}b\ge\sum\limits_{c\in C}c$，

因为 $\sum\limits_{a\in A} a\ge\sum\limits_{c\in C}c$，所以 $A\rightarrow B\rightarrow C$ 可以转化为 $A\rightarrow C$。

第一步，选择用钱买的那件商品，即求 $k=\max\limits_{a_i\leq w}a_i$，先排序，然后 $O(n)$ 暴力找或者二分都可以。

第二步，进行一次交换，贪心选择最便宜的商品，保证所选商品总价不超过第一步的 $k$ 即可。
# Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, w, q, a[1000050];
int main()
{
    scanf("%d", &n);for(int i = 0;i < n;++i) scanf("%d", a + i);
    scanf("%d", &w);sort(a, a + n);w = *(upper_bound(a, a + n, w) - 1);
    for(int i = 0;i < n;++i) if(w >= a[i]) w -= a[i], ++q;
    return printf("%d", q), 0;
}
```


---

## 作者：Jorisy (赞：1)

一道贪心。

---

题目要我们获得的个数尽可能多，那么我们的贪心策略就是选择买所能买到的最大价值的东西，这样的话可以换尽可能多的东西。

同时，我们也要换价值尽可能小的东西，这样个数才会尽可能的更多。

那我们只要排一遍序，再做一遍循环就可以了。

AC Code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,a[1000005],w;

signed main()
{
	//freopen("exchange01.in","r",stdin);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>w;
	sort(a+1,a+n+1);//排序
	if(w<a[1])
	{
		puts("0");
		return 0;
	}
	int k=n;
	while(a[k--]>w);//寻找所能买的最大价值的东西
	k++;
	int p=a[k],ans=0;//p 表示每次换之后当前剩余的钱数
	for(int i=1;(i==1||i<k)&&p>=a[i];i++)
	{
		p-=a[i];//扣除 a[i] 的钱数
		ans++;
		//cerr<<"DEBUG:"<<p<<endl;
	}
	cout<<ans;
 	return 0;
}
```

---

## 作者：RNTBW (赞：1)

## 序
Q：你这道题都没 AC 还有脸来写题解？

A：生活所迫...
## 题意
给你一个长度为 $n$ 的序列 $a$，以及一个数 $k$。

你可以在 $a$ 里先选一个数 $a_i$，满足 $a_i \leq k$。

之后将这个数换作 $a$ 里更多的数，但要满足这些数之和 $sum \leq a_i$。

问你最后最多能**获得几个数**。
## 思路
对于这种贪心题，直觉告诉我们，先排序！

排完之后呢？

根据贪心思想，我们肯定会选最大的那一个满足 $a_i \leq k$ 的 $a_i$，设它为 $w$。

之后，因为我们已经从小到大排了序，所以再执行 $\sum_{i=1}a_i$，直到这个和大于了 $w$ 为止。

此时 $i-1$ 就是最多能换的数量啦~

至此，万事大吉，可以...

得到 90 分...

本着 AC 至上的目的，究竟是哪儿出现了 bug？

让我们将目光转向问题：

_你最多能获得多少个数。_

能获得...能获得...

恍然大悟，如果我们只能选最小的那个数，它一个数都换不了，**但我们仍然可以获得这个数！**

直接上特判！

至此，万事大吉，可以 AC！

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000001];
long long n,m,i,k,s;
int main()
{
	scanf("%lld",&n);
	for(i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	scanf("%lld",&m);
	for(i=n;i>0;i--)
		if(a[i]<=m){ k=i;break; }//a[k]就是最初选的那个数
	if(!k)
	{puts("0");return 0;
	}//特判一个数都选不到
	for(i=1;i<k;i++)
	{
		s+=a[i];
		if(s>a[k])break;
	}
	printf("%lld",(i==1 ? i:i-1));//特判一个数都换不到
	return 0;
}
```


---

## 作者：newbeeglass (赞：1)

仔细看了眼题目，初步猜想是贪心，接下来就进行了一些简单的证明。

证明过程：第一次买东西肯定挑贵的买，这点不难看出，一件商品越贵，换来其它的商品就越多，一开始还不知道究竟该怎么换，可以设一下，我们令换商品的操作为把当前手头所有的商品都交换为最多价值更低的商品，即把手头所有的商品能换就换，$n_{i}$ 为当前手头商品的总价值，则有 $n_{1}\ge{n_{2}}\ge{n_{3}}\ge...\ge{n_{i-1}}\ge{n_{i}}$，最后换来的商品总价值一定不会超过第一次买的商品，而且随着不断的交换，你商品的总价值只会下降而不会升高，不论如何，你第一次买的商品价值一定是最高的，价值越高，换来的商品就越多，只需第一次买的商品就能得到最终答案。

代码实现：考虑先用 ```sort``` 将输入的数组排序，找到最大的价值不超过 $w$ 的商品，这就是要购买的商品，然后从小到大依次累加商品，因为换的商品越便宜，数量越多，加到超过最大价值时，直接 ```break``` 就好了，最后输出累加的次数。

### AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],w;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>w;
	sort(a+1,a+1+n);
	int tot=0;
	int wx;
	for(int i=1;i<=n;i++){
		if(a[i]<=w){
			wx=a[i];
		}
		else{
			break;//由于排过序，这是一个不降序列，a[i]比w大直接退出就好了
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		tot+=a[i];
		if(tot>wx){
			break;
		}
		ans++;//判完再加，防止多加
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：Joker_1212 (赞：1)

# P8444 不等价交换法则 题解

[原题传送门](https://www.luogu.com.cn/problem/P8444)

## 题意理解

有 $n$ 个商品，第 $i$ 个商品的价格为 $a_i$。你有 $w$ 元，需要先购买一件商品，再用此商品与其他商品交换，要求交换获得的商品的价值和必须小于等于你用于交换的商品价值和。

求最多能获得多少件商品。

**数据范围**

- $1 \le n \le 10^6$
- $0 \le a_i \le 10^9$
- $1 \le w \le 2 \times 10^9$

## 题目分析

因为要求的是最多个数，这个题可以看做商品价值全部为 $1$ 的 背包问题。而针对这种问题，可以用贪心求得结果。

具体做法：先买所有能购买的商品（指价值不超过 $w$ 的商品）中价值最大的一个，再从价值最小的商品开始选择，直到所选择的商品的总价值大于最初购买的商品的价值，输出所选择的商品数量减一（因为最后一个不能选）即可。

证明（设所购买的商品的价值为 $a_w$，假设已排好序）：

1. 证明第一次购买 $a_w$ 最优

>因为 $a_w$ 是可购买商品中价值最大的，所以无法购买 $a_{w+1}$，若购买 $a_{w-1}$ 则可交换得到的商品总价值 $w_e\le a_{w-1} \lt a_{w}$，所以第一次购买 $a_w$ 是最优的。

2. 证明每次选择价值最小的商品最优

> 当 $n = 2$ 时，显然只能选择价值最小的商品（也是唯一的商品）。

> 当 $n = 3$ 时，因为 $a_1 \le a_2$，所以选择 $a_2$ 不会比 $a_1$ 更优，因此选择 $a_1$（即价值最小的商品）最优。

> 其他情况都可以由 $n = 2$ 和 $n = 3$ 的情况推得。

注意有个坑点：如果一个商品也买不了，应输出 $0$，需要特判。

## AC Code

放出核心代码：

```cpp
// read() -> 快读；write() -> 快写
int n, w;
read(n);
ll *a = new ll[n + 5]; // 这是动态数组，如果不习惯也可定义成 ll a[1000005];
a[0] = 0;
for (int i = 1; i <= n; ++i)
    read(a[i]);
sort(a + 1, a + n + 1);
read(w);

// 特判如果一件商品也购买不了
if (a[1] > w)
{
    push(48), push(10);
    return 0;
}

for (int i = 1; i <= n; ++i)
{
    if (a[i] > w) // 因为数组已经有序，所以只要这个商品无法购买，其后面的所有商品都无法购买
    {
        n = i - 1; // 直接改变数组末尾指针，忽略后面全部的数据
        break;
    }
    a[i] += a[i - 1]; // 前缀和预处理
}

w = a[n] - a[n - 1]; // 购买最后一件商品（最贵的商品）

// 这里 i <= n 的原因：
// 如果设为 n - 1：如果这个商品可以交换所有的商品，那么程序会运行到结尾，输出 n，显然不对。
// 如果将循环末的特判输出语句改为 "write(n - 1, 10)"，当 n == 1 的时候，也会得到错误答案
a[n + 1] = a[n] + 1;
for (int i = 1; i <= n; ++i)
{
    // 若 n == 1，会执行后面的输出语句，其他情况至多到 i == n 就会输出
    if (a[i] > w) // 无法交换更多商品
    {
        write(i - 1, 10);
        return 0;
    }
}
write(n, 10); // 相当于小特判，特判 n == 1
```

[效果及全部代码](https://www.luogu.com.cn/record/80968600)

---

## 作者：dzdolrc (赞：1)

## 获取信息

由题可得，我们有两种方式获得商品。

**1** 通过直接购买商品（但只能购买一个）

**2** 以物换物，以当前所拥有的的商品换取总价格$\le$当前商品价格的商品（数目不限，仅需要满足价格即可）

尽可能买的多，且没有空间的限制。我们就很容易的想到**贪心**的做法。因为数据范围$n\le 10^6$，所以我们可以直接模拟。

## 贪心

那么我的贪心策略应该怎么制定呢？根据上面我们的两种获取商品的方式，我们知道，如果采取以物换物的方式，换取价格越小的商品，所能获得商品总数就越多，所以我们需要将商品从小到大排序。

```cpp
sort(a+1,a+1+n);
```

我们知道假定排序后我们所能购买的最大的商品能换取$m$件商品($2\le m$),那么是一定会去换的。我们的换取是由价格从小到大不断累积，也就意味着，当我们手上拥有第$i$个物品时，理论来说，用$i$去换比$i$价值更小的商品答案更优。但是我们已经排过序，所以在$i$前面的商品其实已经被选取。所以我们只需要**换取一次即可**。

在代码实现中我们需要注意一下几点：

**1** 考虑当前手里的钱买不了任何一个商品

**2** 能购买的商品不一定处于商品序列的最后

**3** 购买了最大值的商品后，无法换取其他商品

代码如下：

```cpp
#include <bits/stdc++.h> 
#define ll long long
#define N 1000010
using namespace std;
ll n;
ll a[N],w,cnt,maxpos,tp;
bool vis[N],fl;
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>w;
	sort(a+1,a+1+n);
	for(ll i=n;i>=1;i--){
		if(w>=a[i]){
			w=a[i];
			cnt++;
			maxpos=i;
			break;
		}
	}
	for(ll i=1;i<maxpos;i++){
		if(w>=a[i]){
			if(i==1) cnt--;
			cnt++;
			w-=a[i];
		}
	}
	cout<<cnt;
	return 0;
}
```


---

## 作者：sixrc (赞：1)

考虑贪心。由于交换获得的商品的价值和必须小于等于用于交换的商品价值和，换句话说，获得的价值是单调不升的，而根据题目每种商品只有一个的性质，只考虑用最大的交换一次，贪心选择。

具体的，把序列排个序，找到序列中最后一个 $\le w$ 的数，记其价值为 $p$，用它去交换。由于每件商品只有一件，故选择价值最小的若干件，使得其价值和恰好 $\le p$（也就是再选一个就会 $>p$）这样选一定是最优的。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, s, num, a[1000010];
signed main(){
	scanf ("%lld", &n);
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
	}
	scanf ("%lld", &m);
	sort (a+1, a+n+1);
	a[n+1] = 1e18;
	for (int i=1; i<=n+1; i++){
		if (a[i] > m){
			m = a[i-1];
			break;
		}
	}
	for (int i=1; i<=n; i++){
		s += a[i];
		if (s == m){
			num ++;
			break;
		}
		else if (s > m){
			break;
		}
		else num ++;
	}
	printf ("%lld\n", num);
	return 0;
}
```

---

## 作者：Cure_Wing (赞：0)

### 题目
* [丢个链接](https://www.luogu.com.cn/problem/P8444)  

### 解法
* 首先很明显，我们要换尽可能多的物品，首先买的物品的价值要尽可能的大。
* 由于限定了价格 $w$，所以我们要买的物品的价格应该是小于 $w$ 的最大价格。
* 接下来就应该讨论兑换哪些物品。
* 一个贪心的思想就是每次选择当前价格最低的物品，直到无法选择为止。
* 证明一下：
* 若选择价格较大的物品，则必须丢弃价格较小的物品。很显然，所选择的价格大的物品的数量绝对不会多于丢弃的价格小的物品的数量，也就是说此方案绝对不会更优。
* 时间复杂度 $\mathcal{O}(n\log n)$，空间复杂度 $\mathcal{O}(n)$。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using std::cin;using std::cout;
int n,a[1010101],w;
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	cin>>w;
	std::sort(a+1,a+n+1);
	int h=std::upper_bound(a+1,a+n+1,w)-a-1;
	int cnt=0,ans=0;
	for(int i=1;i<=h;++i){
		if(cnt+a[i]<=a[h]) cnt+=a[i],++ans;
		else break;
	}
	cout<<ans;
    return 0;
}


```

---


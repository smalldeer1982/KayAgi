# 小挖的 X 献身

## 题目描述

给定一张 $n\times  n$ 的 $01$ 方阵，请计算其中 X 的数目。

X 定义为用 $1$ 填充且形状为 X 的联通块。具体的，X 由左向斜线 `\` 和右向斜线 `/` 构成，且需要保证左向斜线和右向斜线**长度相等**，而且 X 是中心对称图形，斜线长度大于 1。

例如：

```cpp
101
010
101
```
有一个斜线长度为 $3$ 的 X。

```cpp
1001
0110
0110
1001
````

则有两个斜线长度分别为 $2,4$ 的 X。

```cpp
10001
01010
00100
01010
00001
```

仅有一个斜线长度为 $3$ 的 X 。

## 说明/提示

对于 $20\%$ 的数据，$1\leq n\leq 3$。

对于 $40\%$ 的数据，$1\leq n\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 50$。

对于 $100\%$ 的数据，$1\leq n\leq 100$。

## 样例 #1

### 输入

```
5
10001
01010
00100
01011
00011```

### 输出

```
2```

# 题解

## 作者：刘辰雨 (赞：38)

# P8546 小挖的 X 献身

### 题面：

[题目传送门](https://www.luogu.com.cn/problem/P8546)
（请看题面后食用此题解）

 ### 题意注意事项：
 
 题目要求输出 “01”矩阵中由 “1” 组成的 “X” 形数量，关于 “X” 的要求**题面有举例描述**，值得注意的是**单个的 “1” 不属于 “X” 形的范畴**。
 
 ### 思路：
 
 关于此题思路无外乎两点：**如何判断 “X” 形**和**如何避免重复**。
 
 1. 如何判断 “X” 形？
 
 如果你仔细阅读题面的样例就会发现，**一个 “X” 形的长宽是一致的**。
所以**只需要知道一个 “X” 形的左右上角的两个 “1” ，整个 “X” 就可以被确定**。所以遍历同一行的 “1” 即可。

2. 如何避免重复？

我们假象一个 “X” 形对应一个正方形，那么保证所有的正方形不重复即可。那么很容易想到，**针对一个 “1” ，对其右下方所有可能符合条件的正方形进行判断，即使全部可行，也不会与之前的情况重复**，因为之前的情况一定包含这个 “1” 的左方和上方部分。

### 代码逻辑：

既然已经解决了以上两个问题，就可以开始构建代码了。伪代码如下：

```cpp
#include<头文件>
using namespace std;
判断函数（）
{
  if(确实是"X")
    答案更新
}
int main()
{
  读入；
  for(遍历每一行）
  	for（遍历每一列）
    	   if(此格为'1')
  		for(遍历与此‘1’同行的每一个‘1’)
  			调用判断函数；
  输出；
  return 0;
}
```

### Code:
```cpp
#include<cstdio>
#include<iostream>//杜绝万能头，从我做起(雾
using namespace std;
int n,mp[101][101];
char ch;
int ans;//记录答案
void pd(int i,int j,int k)
{
	
	if(n-i < k-j)
		return;
		//cout<<i<<endl; 
	int x1 = i;
	int y1 = j;
	int y2 = k;
	for(int u = 1 ; u< k-j+1 ; u++)
	{
		x1++;
		y1++;
		i++;
		y2--;
		if(mp[x1][y1] == 0)return;
		if(mp[i][y2] == 0)return;
	}//遍历“X”形，判断是否全为1，否则return
	ans++;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i<= n ; i++ )
	{
		for(int j = 1 ; j<= n ; j++)
		{
			cin>>ch;
			mp[i][j] = ch-'0';
		}	
	}
	//读入
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= n ; j++)
		{
			if(mp[i][j] == 1)
			{
				for(int k = j+1;  k <= n ; k++)
				{
					if(mp[i][k] == 1)
					{
						pd(i,j,k);
					}
				}	
			}
		}
	}//遍历并判断，记录答案
	printf("%d",ans);//输出
	return 0;//轻松结束，撒花！
} 
```

### 后记：

好久没写题解了，有什么问题请见谅。管理给个“过”，路过给个赞????~WAW

---

## 作者：DengDuck (赞：11)

按照题意，有 `X` 的区间左向斜线和右向斜线上应该全是 `1` ，我们可以枚举区间大小和左上角坐标，再来判断左向斜线和右向斜线是否合法。

枚举区间复杂度为 $O(n^3)$， 判断复杂度为 $O(n)$，综合复杂度 $O(n^4)$,由于 $n \leq 100$，所以可以通过。

以下代码十分好懂，但也因此牺牲了一些优化，希望大家可以自行思考如何优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
char a[105][105];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
        }
    }
    for(int i=2;i<=n;i++)//枚举区间大小
    {
        for(int j=1;j+i-1<=n;j++)//枚举左上角的横坐标，注意要考虑右上角的横坐标会不会超过n
        {
            for(int k=1;k+i-1<=n;k++)//枚举左上角的纵坐标，注意要考虑右上角的纵坐标会不会超过n
            {  
                bool flag=false;//标记是否合法
                for(int l=1;l<=i;l++)
                {
                    if(a[j+l-1][k+l-1]!='1')//如果不是1，标记
                    {
                        flag=true;                    
                    }
                }
                for(int l=1;l<=i;l++)
                {
                    if(a[j+l-1][k+i-l]!='1')//如果不是1，标记
                    {
                        flag=true;                      
                    }
                }
                if(flag==false)ans++;//没有标记“不合法”，所以包含X，多了一个答案
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：_Agave_ (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P8546)
题目简单明了，就是让你判断一个 $01$ 矩阵中 $x$ 的数量。

$x$ 的构建有以下两种方法：

$1.$ 中心是奇数的：
```
101
010
101

最中间的那个是中心
```
$（只有一个 $1$ 不算）$

$2.$ 中心是偶数的：
```
1001
0110
0110
1001

最小单位：

11
11

第一个1是中心。
```
再看数据范围 $n<=100$ 。

直接暴力，枚举第 $i$ 行，第 $j$ 列，找出所有以
这个点为中心的 $x$ （偶数以最小单位的左上角为中心）。

# ~~暴力出奇迹~~~

$AC$ 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,mp[105][105],ans;
int check(int x,int y){
	int res=0;
	for(int i=1;x+i<=n&&y+i<=n&&x-i>0&&y-i>0;i++){
		if(mp[x+i][y+i]==1&&mp[x-i][y+i]==1&&mp[x+i][y-i]==1&&mp[x-i][y-i]==1){
			res++;
		}else{
			break;
		}
	}
	for(int i=1;x+i<=n&&y+i<=n&&x-i>=0&&y-i>=0;i++){
		if(mp[x-i+1][y-i+1]==1&&mp[x-i+1][y+i]==1&&mp[x+i][y-i+1]==1&&mp[x+i][y+i]==1){
			res++;
		}else{
			break;
		}
	}
	return res;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char c;
			cin>>c;
			mp[i][j]=c-'0';
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(mp[i][j]==1)ans+=check(i,j);
		}
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：CharlesZiy (赞：5)

## 写在前面

荣幸地写出了正解，但是因为讨论条件的问题愉快地爆炸了。写篇题解纪念一下。

## 正文

这道题非常的显然，有一种非常直白的方法：固定中心点再延展讨论。

对于奇数长度的情况，算法十分显然：从中间向外扩就可以了。

但是对于偶数情况，它没有中心点，而是一个 $2\times 2$ 的中心块。这种情况下我们采用中心块的左上角一点来计算，分别根据这个左上角算出右上角，左下角，右下角的坐标，然后接着向外延展，代码细节和奇数长度的情况类似。

如果碰到 `0` 或者出边界就到头了，不用再枚举了，退出即可。

为了使代码简洁（误），我设计了一个“系数”代表题目中所求的长度。这样的话我们有代码如下：

```cpp
// Luogu & Codeforces: CharlesZiy
#include <bits/stdc++.h>
#define MAXN 105
using namespace std;

int n, ans;
int mp[MAXN][MAXN];
int dx_odd[] = {-1, +1, -1, +1};
int dy_odd[] = {+1, +1, -1, -1};

int dx_dbl_bs[] = {0, +1, 0, +1};
int dy_dbl_bs[] = {0, 0, +1, +1};
int dx_dbl_ad[] = {-1, +1, -1, +1};
int dy_dbl_ad[] = {-1, -1, +1, +1};

bool valid(int i, int j)
{
    if (i < 1 || i > n || j < 1 || j > n) return false;
    return true;
}

int findX_odd(int i, int j)
{
    int ans = 0;
    int fac = 1;

    while (true)
    {
        for (int x = 0; x < 4; x++)
        {
            if (!valid(i + (dx_odd[x] * fac), j + (dy_odd[x]) * fac)) return ans;
            if (mp[i + (dx_odd[x] * fac)][j + (dy_odd[x] * fac)] == 0) return ans;
        }

        ans++;
        fac++;
    }
}

int findX_dbl(int i, int j)
{
    for (int x = 0; x < 4; x++)
    {
        if (!mp[i + dx_dbl_bs[x]][j + dy_dbl_bs[x]]) return 0;
    }

    int ans = 1;
    int fac = 1;

    while (true)
    {
        for (int x = 0; x < 4; x++)
        {
            if (!valid(i + dx_dbl_bs[x] + (dx_dbl_ad[x] * fac), j + dy_dbl_bs[x] + (dy_dbl_ad[x] * fac))) return ans;
            if (mp[i + dx_dbl_bs[x] + (dx_dbl_ad[x] * fac)][j + dy_dbl_bs[x] + (dy_dbl_ad[x] * fac)] == 0) return ans;
        }

        ans++;
        fac++;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);

    cin >> n;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            char k;
            cin >> k;
            mp[i][j] = k - '0';
        }
    }

    for (int i = 2; i < n; i++)
    {
        for (int j = 2; j < n; j++)
        {
            if (mp[i][j]) ans += findX_odd(i, j);
        }
    }

    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < n; j++)
        {
            if (mp[i][j]) ans += findX_dbl(i, j);
        }
    }

    cout << ans << endl;
    return 0;
}
```

---

## 作者：wangbo0 (赞：2)

**本题思路：**

分两种情况：斜线长度为奇数时和斜线长度为偶数时。

首先输入，开两个数组存 $a_{i,j}$ 中的 $i$ 和 $j$。

**当斜线长度为奇数：**

找到每一个为 $1$ 的点。

再判断 $a_{i,j}$ 的四周的点 $a_{i-1,j-1}$ $a_{i-1,j+1}$ $a_{i+1,j-1}$ $a_{i+1,j+1}$ 是否为 $1$。

如果是就继续。否则跳出，$ans$ 加上循环次数减一。

**当斜线长度为偶数：**

找到每四个为 $1$ 的点。

就像这样
```c
1 1
1 1
```
再判断四个点四周的点是否为 $1$。

如果是就继续。否则跳出，$ans$ 加上循环次数。

最后输出 $ans$。

代码如下。
```c
#include<iostream>
using namespace std;
#define ll long long
char a[10000][10000];
ll b[10000],c[10000];
ll n,g,ans;
int main()
{
    cin>>n;
    for(ll i=1;i<=n;i++)
    {
        for(ll j=1;j<=n;j++)
        {
            cin>>a[i][j];
            //cout<<a[i][j];
            if(a[i][j]=='1')
            {
                b[g]=i;
                c[g]=j;
                g++;
            }
        }
        //cout<<endl;
    }
    for(ll i=1;i<=g;i++)
    {
        ll x=b[i],y=c[i],h=0;
        ll a1=1;//a1*2-1=斜线长度（奇数）
        for(ll j=0;j<n;j++)
        {
            if(a[b[i]+a1][c[i]+a1]=='1'
            &&a[b[i]+a1][c[i]-a1]=='1'
            &&a[b[i]-a1][c[i]+a1]=='1'
            &&a[b[i]-a1][c[i]-a1]=='1')
            {
                a1++;
            }
        }
        if(a1!=1)
        {
            ans+=a1-1;
            //cout<<a1*2-1<<endl;
        }
    }
    for(ll i=1;i<=g;i++)
    {
        ll r=b[i],t=c[i];
        if(a[r-1][t-1]=='1'&&a[r-1][t]=='1'&&a[r][t-1]=='1')
        {
            ll b1=1;//b1*2=斜线长度（偶数）
            ll o11=r-1,o12=t-1,o21=r-1,o22=t,o31=r,o32=t-1,o41=r,o42=t;
            for(ll j=0;j<n;j++)
            {
                if(a[o11-b1][o12-b1]=='1'&&a[o21-b1][o22+b1]=='1'
                &&a[o31+b1][o32-b1]=='1'&&a[o41+b1][o42+b1]=='1')
                {
                    b1++;
                }
                else
                break;
            }
            ans+=b1;
            //cout<<b1*2<<endl;
        }
    }
    //cout<<g<<endl;
    cout<<ans<<endl;
    return 0;
}
```

这次写的比较匆忙，如有错误，请指出，感激不尽！

---

## 作者：xhabc66 (赞：2)

# 思路
对于每个 `X`，分两种情况：
- `X` 的长度为奇。
- `X` 的长度为偶。

可以将两种情况分开搜索：从中心点开始向四个方向搜索，碰到边界或为 $0$ 就停止，每扩展一层总数就 $+1$。

由于每个为 $1$ 的点或 $4$ 个成正方形的每个都为 $1$ 的正方形都有可能为 `X` 的中心，所以对于每一个这样的点或正方形都要搜索。

经过数学计算后，时间复杂度为 $O(n^3)$，可以通过。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

bool x[200][200];
int n;


bool c(int i,int j)//判断是否合格。
{
	if(i<0||i>=n||j<0||j>=n)return 0;
	return x[i][j];
}

int dfso(int i,int j)//搜索长度为奇。
{
	int ans=0;
	for(int k=1;;k++)
		if(c(i+k,j+k)&&c(i-k,j+k)&&c(i+k,j-k)&&c(i-k,j-k))
			ans++;
		else break;
	return ans;
}

int dfse(int i,int j)////搜索长度为偶。
{
	int ans=0;
	for(int k=0;;k++)
		if(c(i+1+k,j+1+k)&&c(i-k,j+1+k)&&c(i+1+k,j-k)&&c(i-k,j-k))
			ans++;
		else break;
	return ans;
}

int main()
{
	
	cin>>n;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			char a;
			cin>>a;
			if(a-'0')x[i][j]=1;
			else x[i][j]=0;
		}
	int ans=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			if(x[i][j])
				ans+=dfso(i,j);
	for(int i=1;i<n;i++)
		for(int j=1;j<n;j++)
			if(x[i][j]&&x[i-1][j]&&x[i][j-1]&&x[i-1][j-1])
				ans+=dfse(i-1,j-1);
	cout<<ans;
	return 0;
}
```


---

## 作者：Error_Eric (赞：1)

### 题意

[Link](https://www.luogu.com.cn/problem/P8546)

### Sol

注意到 $1\le n\le 100$ 可以考虑暴力。

一个 "X" 分为两种，中心是单个 ``1`` 的和中心是一个 $2\times 2$ ``1`` 矩阵的。

对于第一种，枚举每个中心位置，然后枚举边的长度，判断是否可行。

对于第二种，枚举每个中心矩阵的左上角位置，然后枚举边的长度，判断是否可行。

值得注意的是，若长度等于 $l$ 的时候不可行，则长度大于 $l$ 一定不可行。

若长度等于 $l$ 的时候可行，则长度等于 $l+1$ 只需要四个角是 ``1`` 就一定可行。

时间复杂度 $O(n^3)$ ，绰绰有余。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
void readln(int &I){
    I=0;char C=getchar();bool f=0;
    while (!isdigit(C))f|=(C=='-'),C=getchar();
    while ( isdigit(C))(I*=10)+=(C-'0'),C=getchar();
    if(f)I=-I;
}
int n,cnt;
char c[105][105];
int min4(int x1,int x2,int x3,int x4){
    return min(min(x1,x2),min(x3,x4));
}
int main(){
    //freopen("in.txt","r",stdin);
    readln(n);
    for(int i=1;i<=n;i++)
        cin>>c[i]+1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            c[i][j]-='0';
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(c[i][j]!=1)continue;
            int mk=min4(i-1,n-i,j-1,n-j);
            for(int k=1;k<=mk;k++){
                if(c[i-k][j-k]+c[i+k][j+k]+c[i-k][j+k]+c[i+k][j-k]==4)
                    //printf("%d %d %d\n",i,j,k),
                    ++cnt;
                else break;
            }
        }
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<n;j++){
            int mk=min4(i-1,n-i-1,j-1,n-j-1);
            for(int k=0;k<=mk;k++){
                if(c[i-k][j-k]+c[i+k+1][j-k]+c[i-k][j+k+1]+c[i+k+1][j+k+1]==4)
                    ++cnt;
                else break;
            }
        }
    }
    printf("%d\n",cnt);
}
```

---


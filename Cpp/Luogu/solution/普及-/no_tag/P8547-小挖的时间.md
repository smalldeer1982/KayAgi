# 小挖的时间

## 题目描述

小挖有一个电子表，采用只显示小时和分钟的 $12$ 小时制，即只显示 $12:00\sim 11:59$，$12:59$ 后的时刻是 $1:00$。

小时数不会有前导零，但分钟数可以（比如 $7:59$ 不会写成 $07:59$，而 $10:03$ 不会写成 $10:3$）。

小挖从某天**中午**（即 $12:00$）开始盯着这块电子表，一共会持续盯 $T$ 分钟。Ta 现在想知道，一共会看到多少次成**等差数列**的时刻呢？

**等差数列**的定义如下：如果一个数列是等差数列，那么第一个数后面的每一个数，都是前面一个数加上一个固定的差值。比如 $11:11$ 就是一个固定差值为 $0$ 的等差数列时刻，$12:34$ 就是一个固定差值为 $1$ 的等差数列时刻。

如果你稍微留心一点，就会发现我没有给差值明确的大小定义，所以正数负数皆可。

## 说明/提示

对于 $30\%$ 的数据，$0\leq T\leq 60$。

对于 $60\%$ 的数据，$0\leq T\leq 10^5$。

对于 $100\%$ 的数据，$0\leq T \leq 10^9$，$1\leq D\leq 500$。

#### 样例说明

对于第一个询问 $34$，询问的是从 $12:00\sim 12:34$ 的时刻。其中仅有 $12:34$ 一个时刻满足题意。

对于第三个询问 $100$，询问的是从 $12:00\sim 1:40$ 的时刻。其中有 $12:34,1:11,1:23,1:35$ 四个符合要求的时刻。

对于第四个询问 $118$，询问的是从 $12:00\sim 1:58$ 的时刻。其中有 $12:34,1:11,1:23,1:35,1:47$ 五个符合要求的时刻。

## 样例 #1

### 输入

```
6
34
60
100
118
50
106```

### 输出

```
1
1
4
5
1
4```

# 题解

## 作者：Aya_tt (赞：15)

这题我觉得是考验一些小技巧。

如果一个一个枚举过去的时间，只能获得 $60$ 分。

时限是 $1$ 秒，所以我们就必须想着优化。那我们就是分模块讨论一下这道题目。

$1$，枚举时间

我们可以开个数组 $a$ 维护时间一位加一，如果等于十了，就进位，注意，第二位就是等于六的时候进位了。改进位的时候进位，值得注意的是十二点五九分后面是一点，需要特判。

$2$，优化

正如我们前面所说，直接一个个枚举时间，是不足已通过此题的，于是我们就想到了时间是循环的，一个循环是 $720$ 分钟，我们可以用我们暴力的程序，跑出发现一天是有 $31$ 个等差数列，所以在我们程序在跑之前，可以先看看过去了几天，然后就加上几天个 $31$，之后再取余，跑一遍我们的暴力程序，此时，我们最坏查询的时间复杂度也接近线性，足以通过此题。

$3$，代码实现

```c
#include<bits/stdc++.h>
using namespace std;
int a[5] = {0,1,2,0,0},Q;
long long ans;
int main(){
	cin >> Q;
	while(Q--){
		int n;
		cin >> n;
		int l = n / 720;
		ans += l * 31;
		n %= 720;
		for(register int i = 1;i <= n;i++){
			a[4]++;
			if(a[4] == 10){
				a[4] = 0;
				a[3]++;
				if(a[3] == 6){
					a[3] = 0;
					a[2]++;
					if(a[2] == 3 && a[1] == 1){
						a[1] = 0;
						a[2] = 1;
					}
					if(a[2] == 10){
						a[1]++;
						a[2] = 0;
					}
				} 
			}
			if(a[1] == 0){
				if(a[4] - a[3] == a[3] - a[2]){
					//cout<<a[1]<<" "<<a[2]<<" "<<a[3]<<" "<<a[4]<<endl;
					ans++;
				}
			}
			else if(a[4] - a[3] == a[3] - a[2] && a[2] - a[1] == a[3] - a[2]){
				//cout<<a[1]<<" "<<a[2]<<" "<<a[3]<<" "<<a[4]<<endl;
				ans++;
			}
		}
		cout<<ans<<endl;
		ans = 0;
		a[1] = 1,a[2] = 2,a[3] = 0,a[4] = 0;//一定要清零！！
	}	
}
```


---

## 作者：MvemiY (赞：9)

模拟赛T2，难度较简单。

## 思路
直接模拟就可以了，枚举每一个时间，把四位（或三位）取出来，在判断即可。

### 一：如何枚举时间
从 `12:00` 开始，每次分钟 $ + 1$，如果分钟超过 $59$，那么小时就得 $+1$，且分钟要归零。如果小时 $=13$，那么就将小时变为 $1$。

代码：

```cpp
// j 代表分钟
// i 代表小时
j++;
if(j >= 60){
	j = 0, i++;
	if(i == 13)
	i = 1;
}
```
### 二：如何取位与判断
这个比较简单。当小时 $<10$ 的时候取出来三位；否则就取出来四位。

代码：

```cpp
if(i >= 10){
	int a = i / 10, b = i % 10, c = j / 10, d = j % 10;
	if(a - b == b - c && b - c == c - d)
	// 判断是否合法（为等差数列）
		ans++;
}
else {
	int a = i, b = j / 10, c = j % 10;
	if(a - b == b - c)
	// 判断是否合法（为等差数列）
		ans++;
}
```

## 代码
这时候我们就可以打出来完整代码了！

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t, x, ans = 0;
	cin >> t;
	while(t--){
		cin >> x;
		ans = 0;
		for(int i = 12, j = 0; x ; x--){
			j++;
			if(j >= 60){
				j = 0, i++;
				if(i == 13)
					i = 1;
			}
			if(i >= 10){
				int a = i / 10, b = i % 10, c = j / 10, d = j % 10;
				if(a - b == b - c && b - c == c - d)
					ans++;
			}
			else {
				int a = i, b = j / 10, c = j % 10;
				if(a - b == b - c)
					ans++;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```
提交上去发现：T 掉四个点！

仔细观察：$T$ 竟然这么大！

### 解决方案：所以我们可以先将跑满 $12 \times 60$ 分钟的答案求出来，然后将 $ans$ 刚开始就加上，然后再进行 $mod$

完整 AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 12 * 60;
const int fix = 31;
int main(){
	int t, x, ans = 0;
	cin >> t;
	while(t--){
		cin >> x;
		ans = (x / mod) * fix;
		x %= mod; 
		for(int i = 12, j = 0; x ; x--){
			j++;
			if(j >= 60){
				j = 0, i++;
				if(i == 13)
					i = 1;
			}
			if(i >= 10){
				int a = i / 10, b = i % 10, c = j / 10, d = j % 10;
				if(a - b == b - c && b - c == c - d)
					ans++;
			}
			else {
				int a = i, b = j / 10, c = j % 10;
				if(a - b == b - c)
					ans++;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```


---

## 作者：wangbo0 (赞：8)

**本题思路：**

先枚举出在 $720$ 分钟内有几个等差数列的时刻，分别要过多少分钟，并用 $a$ 数组把它们存起来。

对每次输入的数取模于 $720$，在乘 $31$,最后算出剩下的大于 $a$ 数组中的数据个数，相加就可以了。

**下面是代码。**

```c
#include<iostream>
using namespace std;
#define ll long long 
ll n=0,ans=0;
int main()
{
    cin>>n;
    int a[31]={34,
    71,83,95,107,119,
    130,142,154,166,178,
    201,213,225,237,
    260,272,284,296,
    331,343,355,
    390,402,414,
    461,473,
    520,532,
    591,
    671};
    for(ll i=0;i<n;i++)
    {
        ans=0;
        int a1;
        scanf("%d",&a1);
        if(a1>720)
        {
            ans+=a1/720*31;
            a1=a1%720;
        }
        for(int j=0;j<31;j++)
        {
            if(a1>=a[j])
            {
                ans++;
            }
            else
            break;
        }
        printf("%lld\n",ans);
    }
    
    return 0;
}
```

这次写的比较匆忙，如有错误，请指出，感激不尽！

---


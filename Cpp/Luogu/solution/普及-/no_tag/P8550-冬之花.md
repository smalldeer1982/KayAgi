# 冬之花

## 题目背景

“哭泣并不是因为悲伤，

只是因为活着，眼泪就不自觉跑了出来。”

赫尔德失恋以后，跑到大马路上飙车。因为是飙车，她不愿意一直待在路上，而是跑到路左右的黄沙地上转圈圈。她的便宜车的转向功能出了一些问题，但她真的很想转圈圈。

## 题目描述

给定 $n$ 个数 $a_1, a_2, \ldots, a_n$，再给定一个非零数 $x$。

你需要进行 ${10}^{100}$ 次操作，每次操作，你需要选定一个下标 $i$（$1 \le i \le n$），然后给 $x$ 加上 $a_i$。

你需要保证，在每次操作后，新的 $x$ 值都不能为 $0$。

请判断你能否完成这 ${10}^{100}$ 次操作。

## 说明/提示

**【样例解释】**

对于第一组数据，第一次操作只能选择下标 $1$，$a_1=-1$，但 $1+(-1)=0$，因此无法进行操作。输出 `No`。

对于第二组数据，你可以轮流选择下标 $1$ 和 $2$，这样 $x$ 将一直 $+1$、$-1$，从而一直在 $10$ 和 $9$ 之间变化，这样你可以执行任意多次操作。输出 `Yes`。当然，这只是其中一种方案，你还可以有其他的操作方案。

---

**【数据范围】**

- 测试点 1（50 分）：$n = 1$；
- 测试点 2（50 分）：无特殊限制。

对于所有测试点：$1 \le T \le 30$，$1 \le n \le 5$，$1 \le \lvert x \rvert, \lvert a_i \rvert \le 100$。

## 样例 #1

### 输入

```
2
1 1
-1
2 10
1 -1
```

### 输出

```
No
Yes
```

# 题解

## 作者：dottle (赞：24)

如果说我们有 $2$ 个不同的数可以用来操作，那么无论当前的 $x$ 是多少，都总有一个数操作以后不会使 $x$ 变为 $0$。这时候答案就一定是 `Yes`。

接下来的问题就变成了，如果所有数都相同，是否能进行 $10^{100}$ 次操作。如果初始的 $x$ 和 $a_1$ 符号相同，那么无论如何 $x$ 都不会变成 $0$；如果 $x$ 不是 $a_1$ 的倍数，那么 $x$ 也不可能变成 $0$。这两个情况答案都是 `Yes`。对于剩下的情况，即 $x$ 与 $a_1$ 符号相反，且 $x$ 是 $a_1$ 的倍数，答案就是 `No` 了。

时间复杂度 $O(n)$。
```
#include<bits/stdc++.h>
using namespace std;

void solve(){
	int n,x;cin>>n>>x;
	int first;cin>>first;
	int flag=0;
	for(int i=2;i<=n;i++){
		int now;cin>>now;
		if(now!=first)
			flag=1;
	}
	if(flag){
		cout<<"Yes"<<endl;
		return ;
	}
	if(x%first!=0){
		cout<<"Yes"<<endl;
		return ;
	}
	if(x/first>0){
		cout<<"Yes"<<endl;
		return ;
	}
	cout<<"No"<<endl;
}

main(){
	int _T=1;cin>>_T;
	while(_T--)solve();
}
```

---

## 作者：JackMerryYoung (赞：6)

# 前言

月赛 2A, 奇特分类讨论。

# 正文

首先发现如果有两个不一样的数，答案必为 Yes.

证明：若 $x + y = 0$ 且 $y \ne z$, 则 $x + z \ne 0$. 也就是 $x$ 可以不为 $0$. 

其他情况可以划归。

那么继续考虑剩下的问题。发现数字同号时答案也为 Yes, 因为无论怎么加符号都不变, $|x|$ 此时可以随意变大，而 $x$ 永远不会变成 $0$.

然后还有一种就是两数同号但是 $a$ 整除不了 $x$, 此时也是 Yes, 因为你再怎么加也加不出。

于是剩下来的情况都是 No, 那么这道题就解决啦。

---

对赛时的大部分代码的 Hack:

Input:

```
1
2 6
-2 -3
```

Output:

```
Yes
```

---

# 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define rint register int

int T;

signed main()
{
    cin >> T;
    for(int i = 1; i <= T; ++ i)
    {
        int N, X, t;
        bool neq = false;
        cin >> N >> X;
        for(int j = 1; j <= N; ++ j)
        {
            int tmp;
            cin >> tmp;
            if(j == 1) t = tmp;
            if(j != 1 && tmp != t) neq = true;           
        }
        
        if(neq) puts("Yes");
        else if(t > 0 && X > 0) puts("Yes");
        else if(t < 0 && X < 0) puts("Yes");
        else if(X % t != 0) puts("Yes");
        else puts("No");
    }
    
    return 0;
}
```

# 后言

感谢出题人。

---

## 作者：BYWYR (赞：4)

## $\texttt{Solution}$

分两种情况讨论，所有数 相同 和 不相同。

- 不同：有不同的数来进行操作，无论 $x$ 是多少，总有一个 $a_i$ 来使 $x ≠ 0$，所以此时答案为 ```Yes```；

- 相同：

	1.如果此时 $x$ 的符号与 $a_i$ 相同，那么大的只会更大，小的只会更小。所以此时答案为 ```Yes```。
    
	2.但是如果符号不相同时，只要 $x$ 不是 $a_i$ 的倍数，结果也不会变为 $0$。所以此时答案也为 ```Yes```。
    
	3.反之，两种情况都不符合， 答案就是 ```No``` 了。
    


------------
举个栗子：

- 对于不相同的情况，$x=2,a_1=1,a_2=-1$ 时（样例第 $2$ 组）可以成立。

- 对于 相同 中的 $1$ 情况，$x=1,a_i = 1$ （同正）或 $x=-1,a_i=-1$（同负）时都可以成立；

- 对于 相同 中的 $2$ 情况，$x=3,a_i=-2$ 时可以成立；

- 对于 相同 中的 $3$ 情况，$x=4,a_i=-2$ 时可以成立。

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t,n,x;
int a[10];
int main(){
	cin>>t;
	while(t--){
		cin>>n>>x;	
		bool same=true;//相同的标志
		cin>>a[1];
		for(int i=2;i<=n;i++){
			cin>>a[i];
			if(a[i]!=a[i-1]) same=false;
		}
		ll sum=x;//变化的x
		if(same==true){//相同
			while(true){
				sum+=a[1];//一直加到满足情况
				if(sum>0&&a[1]>0){//同正
					printf("Yes\n");
					break;	
				}
				else if(sum<0&&a[1]<0){//同负
					printf("Yes\n");
					break;
				}
				else if(sum%a[1]==0){//可以除尽
					printf("No\n");
					break;	
				}
			}
		}
		else printf("Yes\n");//不相同
	}
	return 0;
}
```


---

## 作者：LeiZeProMax (赞：4)

蒟蒻的第二篇题解。

题意：给定一个数 $x$ 和 $n$ 个数 $a_i$，问能否让 $x$ 执行 $10^{100}$ 次 $+$ 某个数 $a_i$ 后仍不等于于 $0$。

我们可以发现，题目中并没有要求选定的数必须不一样，因此，我们只需要在这几个数中找到任意一个和 $x$ 相加无数次都不会等于 $0$ 的数即可。

和 $x$ 相加无数次都不会等于 $0$ 的方法有三种：

1：两数都为正，则相加结果永远为正。

2：两数都为负，则相加结果永远为负。

3：两数一正一负且 $x$ 不是 $a_i$ 的倍数。

只要在以上三种情况中找到一种，我们就可以输出 Yes 了。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,x,a[6];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d %d",&n,&x);
		bool f=true;//f为相加10^100之前是否会等于0 
		for(int i=1;i<=n;++i)
		{
			scanf("%d",&a[i]);
			if(a[i]>0&&x>0)f=false;//都为正数就不会等于0 
			else if(a[i]<0&&x<0)f=false;//都为负数就不会等于0 
			else if(x*-1%a[i]!=0)f=false;//如果一正一负且x不是a[i]的倍数就不会等于0 
		}
		!f?puts("Yes"):puts("No");//输出 
	}
	return 0;
}
```


---

## 作者：guozhetao (赞：3)

## 思路

-  当 $x$ 与 $a_i$ 同号时候，肯定是 `Yes`。毕竟一直加就行了。

-  当 $a_i \neq a_{i - 1}\ $ 的时候，保证肯定有一种方法可以，输出 `Yes`（注意一定要特判 $i$ 不等于  $1$）。

-  当 $ x\not\equiv 0\pmod {a_i}$ 的时候也可以，一直加也可以。

-  全部不满足，输出 `No`。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int n,x,a[10];
int main() {
	scanf("%d",&t);
	while(t--) {
		scanf("%d%d",&n,&x);
		bool k = 0;
		for(int i = 1;i <= n;i++) {
			scanf("%d",&a[i]);
			if(a[i] != a[i - 1] and i != 1) {
				k = 1;
			}
			if((x > 0 and a[i] > 0) or (x < 0 and a[i] < 0)) {
				k = 1;
			}
			if(abs(x) % abs(a[i])) {
				k = 1;
			}
		}
		if(k) printf("Yes\n");
		else printf("No\n");
	}
}

```


---

## 作者：binaryBard (赞：2)

读题点 [这里](https://www.luogu.com.cn/problem/P8550)

更好的阅读体验点 [这里](https://blog.jerryz.com.cn/article/solution-P8550)

# 思路分析

我们可以发现，只有当 $a_{i}$ 只有一个， $x$ 能被 $a_{i}$ 整除且 $a_{i}$ 和 $x$ 异号时，才无法完成 $10^{100}$ 次操作。

那么，我们只要筛出无法完成操作的情况，剩下的便一定能够完成操作。

# 代码

```C++
#include<bits/stdc++.h>
using namespace std;

int T,n,x,a[10];

int main(){
	cin>>T;
	while(T--){
		cin>>n>>x;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		sort(a+1,a+n+1);//去重前要对数组先排序
		int l=unique(a+1,a+n+1)-a-1;//去重并求出去重后数组的长度
		if(l==1&&x%a[1]==0&&x*a[1]<0) cout<<"No"<<endl;//判断是否仅有一个ai，x能被ai整除且x和ai异号
		else cout<<"Yes"<<endl;
	}
	return 0;
} 
```

---

## 作者：SegTree (赞：2)

<https://www.luogu.com.cn/problem/P8550> 题目传送门。

## 思路
本题大致做法：
+ 进行 $10^4$ 次尝试。
+ 每次进行 $100$ 次测试，看过程中是否有 $0$。
+ 如果没有 $0$，则有解。
+ 若所有的尝试过程中均有 $0$，那么判定为无解。
+ 如果次数减少，那么可能会误判为 `No`。
+ 之所以进行 $100$ 次，是因为 $|a_i|\le 100$。
+ 反之，如果进行 $99$ 次测试，那么会被 $n=1,x=100,a_i=-1$ 的情况 `Hack` 掉。
+ 于是就可以通过本题。
+ 最坏情况下，判断是否涉及 $0$ 的代码会执行 $10^7$，而 $n$ 只有 $5$，$T$ 的极限数据只有 $30$。实际测试不会超时。

## 代码
```cpp
#include<bits/stdc++.h>
#define ask(T) while(T--)
using namespace std;
inline int read(){
    int x=0;
    short t=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')t=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+(ch-'0');
        ch=getchar();
    }
    return x*t;
}
void solve(){
    int n=read(),x=read(),a[10];
    for(int i=1;i<=n;++i){
        a[i]=read();
    }
    for(int i=1;i<=1e4;++i){
        int t=100,now=x;
        bool f=0;
        while(t--){
            int it=rand()%n+1;
            now+=a[it];
            if(!now){
                f=1;
                break;
            }
        }
        if(!f){
            puts("Yes");
            return;
        }
    }
    puts("No");
}
int T=read();
int main(){
    ask(T)solve();
}
```

---

## 作者：Jusc (赞：2)

### 题外话

 比赛当时正在上课 （~~尽管来了也是找虐~~）
 
 ~~嚎啕大哭~~ 


------------

### 此题分情况讨论

1. 当存在一个 $ y \in a $ , $ y $ 和 $ x $ **符号相同** ； 
 
* $ x $ 可以一直加上 $ y $ 使得 $ x $ 不等于 0 。则（ Yes ） 

2. 所有 $a_i$ 的符号都与 $x$ 不同 ； 

* 因为 $ \left\vert x\right\vert\le100 $ ,我们可以找出 $ a_i $ 中的最小值和最大值，将 $ x $ 连续加上 $ a_i $ 中的最小值使得其接近 0 , 当其 0 的距离小于 $ a_i $ 中的最大值，则能够跨过 0 这个值。则（Yes） 

* 当 $ x > 0 $ 时，我们需要的是慢慢接近 0 , 所以要加上 $ a_i $ 的最大值看距离是否小于 $ a_i $ 的最小值。 

_如图_ （这里只画了 $ x < 0 $ 的情况）（$ x > 0 $ 的情况~~自己想~~） 

![](https://cdn.luogu.com.cn/upload/image_hosting/17wg3p90.png?x-oss-process=image/resize,m_lfit,h_200,w_3000)

* 如果不能 ，则（ No ） 

------------

### 代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int a[10],s[5000];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,x;
		memset(a,0,sizeof a);
		cin>>n>>x;
		bool flag=false;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		for(int i=1;i<=n;i++)//看符号是否相同 
		{
			if(a[i]*x>=0)
			{
				flag=true;
				break;//只要有一个相同的就不可能为0 
			}
		}
		if(flag)
		{
			printf("Yes\n");
			continue;
		}
		int min1=101,max1=-101;
		for(int i=1;i<=n;i++) //最大最小值 
		{
			min1=min(min1,a[i]);
			max1=max(max1,a[i]);
		}
		if(x>0)//大于零时情况不一样 
		{
			int t=min1;
			min1=max1;
			max1=t;
		}
		flag=false;
		while(1)
		{
			x+=min1;
			if(x==0)//为0就是No 
			{
				flag=false;
				break;
			}
			if(abs(x)<abs(max1))//加绝对值比较 
			{
				printf("Yes\n");
				flag=true;
				break;
			}
		}
		if(flag) continue;
		printf("No\n");	
	}
	return 0;
 } 
```

---

## 作者：CI_is_safe (赞：2)

# P8550 冬之花 题解
[题目传送门](https://www.luogu.com.cn/problem/P8550)
## 思路
考虑不等的 $a_i$ 和 $a_j$，则 $x+a_i\neq x+a_j$，所以若其中一个的值为 $0$，则另一个必定 $\neq 0$。如果所有 $a_i$ 都相等，那么 $x$ 变为 $0$ 的充要条件是 $x$ 与 $a_i$ 的正负性相反，并且 $a_i\mid x$。注意**对于每个 $a_i$ 判断最后一个充要条件，而不判断是否有不等 $a_i$ 的方法是错误的**，如以下数据。
```
1
2 2
-2 -1
```
显然可以一次 $-1$，剩下都是 $-2$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		int n,x,lst,a;
		scanf("%d%d%d",&n,&x,&lst);
		bool f=0;
		for(int i=2;i<=n;++i){
			scanf("%d",&a);
			f|=a!=lst;//判断是否有不等的数
			lst=a;
		}
		a=lst;
        puts((f||x%a||x>0&&a>0||x<0&&a<0)?"Yes":"No");//判断正负性是否相反和是否整除
	}
	return 0;
}
```

---

## 作者：sgl654321 (赞：1)

### 题目大意
给定一个数 $x$ 和一个长度为 $n$ 的序列 $a$，定义每次操作为在保证 $x+a_i(i\in[1,n])\neq 0$ 的基础上，将 $x$ 加上 $a_i$。询问是否能执行无限次操作。

### 解题思路
分类讨论。

- 情况 $1$：若 $x$ 为正数，并且 $a_i$ 中存在一个正数。

对于这种情况，我们把 $x$ 每次都加上这个 $a_i$ 即可。故输出 ```Yes```。

- 情况 $2$：若 $x$ 为负数，并且 $a_i$ 中存在一个负数。

同上。输出 ```Yes```。

- 情况 $3$：若 $x$ 为正数，并且存在一个负数 $a_i$，使得 $-a_i$ 不是 $x$ 的因数。

对于这种情况，我们把 $x$ 每次都加上这个 $a_i$ 即可。故输出 ```Yes```。

- 情况 $4$：若 $x$ 为负数，并且存在一个正数 $a_i$，使得 $a_i$ 不是 $-x$ 的因数。

同上。输出 ```Yes``` 。

- 情况 $5$：其他情况。

输出 ```No```。

### 参考代码
情况 $1,2$ 和情况 $3,4$ 可以合并。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,x,a[100010]; 
bool p;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>x;
		p=0;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++){
			if(x<0&&a[i]<0)p=1;
			if(x>0&&a[i]>0)p=1;
		}
		
		for(int i=1;i<=n;i++)
			if(abs(x)%abs(a[i])!=0)p=1;
		if(p)cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}
 


---

## 作者：IYSY2009I (赞：1)

$10^{100}$ 很大，在此题中可以看做无限。

我们发现，如果存在两个及以上相等的 $a_i$，那么实际上和只有一个是一样的，这个十分显然。

然后我们来证明一下，如果存在两个不相等的 $a_i$，那么一定有解。我们来构造一个解。我们设这两个不同的数为 $a_1,a_2$。

- 如果 $x+a_1 \ne 0$，则 $x \to x+a_1$。
- 如果 $x+a_1 = 0$，则 $x \to x+a_2$。

因为 $a_1 \ne a_2$，所以上面的操作方法一定是一个解。

在解决完上面的问题之后，这个问题就变成了给你一个非零整数 $x$ 和一个整数 $y$，每次令 $x$ 自增 $y$，问 $x$ 是否可能在这个过程中变成 $0$。

容易发现 $x$ 有可能变成 $0$ 当且只当 $x,y$ 同号且 $|x| \bmod |y| =0$，于是这道题就做出来了。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
int a[6];
void cf(){
	int n=read(),x=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		if(x*a[i]>0){
			printf("Yes\n");
			return;
		}
	for(int i=1;i<n;i++)
		if(a[i]!=a[i+1]){
			printf("Yes\n");
			return;
		}
	if(abs(x)%abs(a[1])){
		printf("Yes\n");
		return;
	}
	printf("No\n");
	return;
}
int main(){
    int t=read();
    for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```


---

## 作者：Tomato_Ya (赞：1)

## 题意
给你 $n$ 个数和 $x$，进行 $10^{100}$ 次操作，每次操作从这 $n$ 个数中选一个，让 $x$ 加上 $a_i$，并且不能让 $x=0$，判断是否能完成这 $10^{100}$ 操作。
## 思路
首先我们举个栗子：
```
1
2 10
-3 -5
```
可以看到如果 $10$ 加了两次 $-5$，就会变成 $0$，但可以在每次要变成 $0$ 之前加 $-3$，就不会变成 $0$。

只要这 $n$ 个数中有两个不同的数，每当 $x$ 加上其中一个等于 $0$ 时，加上另一个数，$x$ 永远不为 $0$。

输出 ```Yes```。

于是我们就可以在代码中先进行特判：
```cpp
cin>>a[1];
for(int i=2;i<=n;i++){
	cin>>a[i];
	if(a[i-1]!=a[i])b=1;
}
if(b){
	cout<<"Yes\n";
	continue;
}
```

之后的代码就不用再把这 $n$ 个数用循环枚举了，只用 $a_1$ 去判断就行了，因为经过这次特判，所有的数都是相等的。

------------
再举一个栗子：
```
1
1 10
1
```
这种情况下 $10$ 一直加 $1$，但无论加多少次，$x$ 都不为 $0$，因为 $10$ 和 $1$ 的符号相等。

当 $a_1$ 和 $x$ 符号相同时，正数加正数等于正数，负数加负数等于负数，$x$ 永远不会为 $0$。

输出 ```Yes```。

------------
再再举一个：
```
1
1 10
-3
```
这种情况 $10$ 虽然符号和 $-3$ 相反，但无论 $10$ 加几个 $-3$，也不会为 $0$，因为 $10$ 不是 $-3$ 的倍数。

当 $x$ 和 $a_1$ 符号相等，但 $x$ 不是 $a_1$ 的倍数时，$x$ 也永远不为 $0$。 

输出 ```Yes```。

------------
所以只需要在代码中把以上情况进行判断，就很简单了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,x,a[10];
int zf(long long a){ //用来判断符号的函数。
    if(a>0)return 1;
    else if(a<0)return 2;
}
int main(){
    cin>>t;
    while(t--){
        cin>>n>>x;
        long long xx=zf(x),b=0;
        memset(a,0,sizeof(a)); 
        cin>>a[1]; 
        for(int i=2;i<=n;i++){
            cin>>a[i];
            if(a[i-1]!=a[i])b=1;
        }
        if((xx==zf(a[1])||x%a[1]!=0)||b){ //这里我把三种情况放在了一起。
            cout<<"Yes\n";
            continue;
        }
        cout<<"No\n"; //如果没进入下一次循环，就输出“No”。
    }
    return 0;
}
```


---

## 作者：wdgm4 (赞：1)

[P8550 冬之花](https://www.luogu.com.cn/problem/P8550)

------------

有两种情况，一个是数组 $a$ 中有不同的数，一个是数组 $a$ 中数都相等

------------

先来证明为什么有不同数进行操作一定是```Yes```。

假如有一组数据
```
2 -4
1 2
```
我们可以让 $ x $ 加 $ 1 $ ,之后加入无数的 $ 2 $ ,这样 $ x $ 一定不是 $ 0 $。

再假如，我们有两个不同的数，分别为 $ a_1 $ $ a_2 $，假设每个数只能进行$ 0 $到$ 1 $次操作，那么就有三种情况：

1.只操作一次 $ a_1 $;

2.只操作一次 $ a_2 $;

3.操作一次 $ a_1 $ 并操作一次 $ a_2 $。

如果操作次数更多，情况也会更多。

所以就可以说，有不同数进行操作一定是```Yes```。



------------
接下来，只需要考虑所有数相等的情况了。如果 $ x $ 与 $ a_1 $ 同号，那么一定是```Yes```。如果 $ x $ 与 $ a_1 $ 不同号，并且 $ x $ 是 $ a_1 $的倍数， 那么就是```No```，否则就是```Yes```。

------------
最后，献上代码
```
#include<bits/stdc++.h>
#define XD 114514

using namespace std;
int t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		int n,x;
		cin>>n>>x;
		int num,nem;
		bool m=0;
		cin>>nem;
		num=nem;
		for(int j=2;j<=n;j++){
			cin>>nem;
			if(nem!=num){
				m=1;
			}
		}
		if(m){ //a中有不相等的数
			cout<<"Yes\n";
		}else{//a中所有数相等
			if(num*x>0) cout<<"Yes\n";//两数同号 
			else{//两数不同号 
				if(x%num==0) cout<<"No\n";
				else cout<<"Yes\n";
			}
		}
	}
	return 0;
}

```


------------
~~求管理员通过啊啊啊QWQ~~

---

## 作者：Rednoon (赞：0)

#    思路
   
   只要我们有 $2$ 个不同的数可以用来操作，就总有一个数操作以后不会使    $x$   变为   $0$。
   
   同时，这两个数如果符号想同，答案也是  ```Yes```。还有一种情况，如果  $x$  不是  $a_1$  的倍数时，答案也将会是  ```Yes```。
   
   排除以上情况，其他的就会是   ```No```
了。

   
#    附上代码
   
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,c,x,l;
bool p;
bool sb(int a,int b){
	if(a>0&&b>0) return 1;
	if(a<0&&b<0) return 1;
	return 0;
}
int main(){
	cin>>c;
	for(int j=0;j<c;j++)
	{
		p=0;
		cin>>n>>x;
		for(int i=0;i<n;i++)
		{
			cin>>l;
			if(x%l>0||sb(l,x)==1||(0-x)%(0-l)>0) 
			{
				cout<<"Yes"<<"\n";
				for(;;)
				{
					if(getchar()=='\n')
					{
						break;
					}
				}
				p=1;
				break;
			}
		}
		if(p==0)
		{
			cout<<"No"<<"\n"; 
		}
		
	}
	return 0;
}
```


---

## 作者：沉冥Charming (赞：0)

 对于 $a_i$ $(1\le i \le n)$：
-  若有与 $x$ 同号或者有为 $0$ 的 $a_i$，都可以只选同号/为 $0$ 的。
-  若都是与 $x$ 符号相反的 $a_i$，就看 $a_i$ 是不是有不同的值，若有不同的值，总能跳过 $x$ 为 $0$ 的情况。

-  若 $a_i$ 都取相同的值，且与 $x$ 反号，就看 $x$ 能不能被 $a_i$ 整除，不能整除则可行。

AC代码如下（仅供参考）：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int qr()//快读，让您的排名更好看
{
    int ret=0,si=1;
    char c=getchar();
    while (c<'0'||c>'9')
    {
        if (c=='-')
            si=-1;
        c=getchar();
    }
    while (c>='0'&&c<='9')
    {
        ret=(ret<<1)+(ret<<3)+c-'0';
        c=getchar();
    }
    return ret*si;
}
int t,n,x,a[10],bk;
int ab(int num)
{
    if (num<0)
        num=-num;
    return num;
}
int main()
{
    t=qr();
    while (t)
    {
        n=qr(),x=qr();
        bk=0;
        for (int i=1; i<=n; i++)
        {
            a[i]=qr();
            if (a[i]*x>=0||ab(x)%ab(a[i]))
                bk=1;//没读入全部数据就直接输出“Yes”并break会WA
        }
        for (int i=1; i<=n; i++)
            for (int j=1; j<=n; j++)
                if (a[i]!=a[j])
                    bk=1;
        if (bk)
            printf("Yes\n");
        else
            printf("No\n");
        t--;
    }
    return 0;
}
```

---

## 作者：wangif424 (赞：0)

只要有一个数在反复累加后无法使得 $x$ 变为 $0$ ，那么就可以保证 $10^{100}$  次操作后不为零。

### 流程：
循环读入每个数，如果当前数可以使 $x$ 变成 $0$，就**标记**，否则继续下一个数，最后根据情况输出 ```Yes``` 或  ```No``` 。

**注意 Yes 和 No 的大小写**，~~我因为这查了半天错。~~

### 如何判断：
如果 $x$ 和 $a_i$ 同号，那么相加后一定不为 $0$，首先判断异号：
```((a[i]<0 && x>0) || (a[i]>0 && x<0))```

再者需要 $x \equiv 0\pmod {a_i}$ ,否则如 $3+ \sum_1^{\infty}(-2)$ 永远不会为 $0$。

理论上需要  $\frac{x}{a_i} \le 10^{100}$，但由于 $-100 \le {a_i,x} \le100$ 的数据，直接取余判断整除足够了。

即 ```x%abs(a[i])==0 &&((a[i]<0 && x>0) || (a[i]>0 && x<0))```

在外层加个非就是输出 ```Yes``` 的情况了。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,t;
int a[10]; 
bool b=1;
int main(){
	cin >> t;
	while(t--){
		cin >> n >> x;
		b=0;
		for(int i=1;i<=n;i++){
			cin >> a[i];
			if(!(x%abs(a[i])==0 && ((a[i]<0 && x>0) || (a[i]>0 && x<0)))){
				b=1;
			}
		}
		if(b)cout << "Yes";
		else cout << "No";
		cout << endl;
	}
	return 0;
}
```

---

## 作者：LYqwq (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8550)

# 题目大意

给定 $n$ 个数 $a_1, a_2, \ldots, a_n$，再给定一个非零数 $x$。

你需要进行 ${10}^{100}$ 次操作，每次操作，你需要选定一个下标 $i$（$1 \le i \le n$），然后给 $x$ 加上 $a_i$。

你需要保证，在每次操作后，新的 $x$ 值都不能为 $0$。

请判断你能否完成这 ${10}^{100}$ 次操作。

多组数据。

# 思路

我们可以尽量不让 $x$ 变为 $0$，因为很多情况 $x$ 的值都不能变为 $0$，方便判断。

先考虑只用某一个操作数，让 $x$ 一直加上它。

设这个操作数为 $y$。

- $y=0$，$x+y$ 还是等于 $x$，可以避免变为 $0$。
  
- $y$ 与 $x$ 同号，加的越多，离 $0$ 越远。
  
- $y$ 与 $x$ 异号，这时只需判断 $x$ 加上若干个 $y$ 之后会不会变为 $0$。
  

显然，当上面的方法没能判断出答案时，**任意的 $a_i$ 都与 $x$ 异号，并不是 $x$ 的因数**。

如果这些情况都没有出现，那么我们就只能考虑用多个不同的数来避开 0 了。

我们可以先假设：若有任意两个不同的操作数，那么不管 $x$ 是多少，都可以避开 $0$。

设这两个操作数分别为 $a$ 和 $b$，并且 $a$ 和 $b$ 都不满足上面的条件。

根据上面的结论（加粗字体），可以知道 **$a$ 和 $b$ 同号**，并**与 $x$ 异号**，**$x$ 一定是 $a$ 和 $b$ 的倍数**。

这时，只有一种情况：$x \bmod a=0,x \bmod b=0(a \ne b)$。

若 $a=4,b=2,x=-8$，此时可以通过 $-8+2+4+4+\dots$ 来避开 $0$。

$a=3,b=5,x=-15$，$-15+5+5+5=0,-15+3+3+3+3+3=0,-15+5+5+3+3=1$，可以避开 $0$。

关于其他的情况，都会被上面的第一轮判断判掉，例如 $a=3,b=4,x<0,x \bmod a \ne 0,x \bmod b \ne 0$，无论 $x$ 等于几，只要满足条件，就会被上面判掉。

可以得到这个假设是正确的。

于是只需要一个 $flag$，记录能否避开 $0$ 即可。

# 代码

```cpp
#include <iostream>
using namespace std;
template<typename T=int>
inline T read(){
    T X=0; bool flag=1; char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<1)+(X<<3)+(ch^48),ch=getchar();
    if(flag) return X;
    return ~(X-1);
}

const int N=10;
int t,n,x;
int a[N];
bool flag;

int main(){
    t=read();
    while(t--){
        n=read(),x=read();
        flag=0;
        for(int i=1; i<=n; i++){
            a[i]=read();
            if(x*a[i]>=0 || x%a[i]!=0)
                flag=1;
        }
        if(!flag)
            for(int i=1; i<=n; i++)
                for(int j=i+1; j<=n; j++)
                    if(a[i]!=a[j])
                        flag=1;
        puts(flag ? "Yes" : "No");
    }
    return 0;
}
```

---

## 作者：SolIII (赞：0)

## 题目描述
对一个数 $x$，进行 $10^{100}$ 次操作，每次操作为：把这个数加上 $a_i(1 \le i \le n)$ 。

问能不能在这 $10^{100}$ 中，不出现为 $0$ 的数？

## 题目分析
如果 $x$ 为正数，有两种情况满足题目条件：

1. $a$ 数组中有正数（一直累加这一个数，$x$ 逐渐变大，不可能变成0）；
2. $a$ 数组中有负数且 $n$ 不能被 $\left| a_i \right|$ 整除（会变成负数但不会出现 $0$ ）。

同样，如果 $x$ 为负数，也有两种情况满足题目条件：

1. $a$ 数组中有负数；（一直累加这一个数，$x$ 逐渐变小，不可能变成0）；
2. $a$ 数组中有正数数且 $\left| n \right|$ 不能被 $a_i$ 整除（会变成正数但不会出现 $0$ ）。

所以，我们可以遍历题目给出的每一个数，判断它是否满足条件，只要有一个数满足上面的条件，答案便为可行，若没有一个数满足，则答案为不可行。

## 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR = 10;
int a[NR + 10];

int main(){
    int T;
    scanf("%d", &T);
    while(T--){                              //多组数据
        int n, x;
        scanf("%d%d", &n, &x);                  //读入
        bool flag = false;
        for(int i = 1;i <= n;i++){
            scanf("%d", &a[i]);
            if(a[i] > 0){
                if(x > 0){                  //正数中的1.
                    flag = true;
                }
                else{
                    if(abs(x) % a[i]) flag = true;
                }                        //负数中的2.
            }
            if(a[i] < 0){
                if(x < 0){                  //负数中的1.
                    flag = true;
                }
                else{
                    if(x % abs(a[i])) flag = true;
                }                        //正数中的2.
            }
        }
        printf(flag ? "Yes\n" : "No\n");          //输出
    }
    return 0;
}
```


---


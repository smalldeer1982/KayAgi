# 探索未知

## 题目背景

下发文件：

<https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/watujir2-jdi92.zip>

## 题目描述

2102 年，人类已经建立了从地球到室女座 $\alpha $ 星的星际通道。通道绵延数百光年。

而在通道上有许多路牌。第 $i$ 个路牌上写有一个分数 $\dfrac{a_i}{b_i}$ 和一个分数运算符 $+$ 或 $-$。

一开始，你的手上拿着一个数字 $0$。你沿着通道向后走。每走到一个路牌，**会用手上的数和路牌上的分数，用路牌上的运算符号进行计算，并把得到的新数拿在手中（丢弃掉手中原来的数）**。值得注意的是，如果你手中计算得到的数不是整数，则会保留既约分数的形式；否则直接保留整数形式。

现在你想知道，当你走到通道的末端时，手中拿着的数是多少？

## 说明/提示

对于 $20\%$ 的数据，运算符只存在加法。

另有 $20\%$ 的数据，运算法只存在减法。

对于 $100\%$ 的数据，保证 $1\leq n\leq 10^3$，$0\leq a \leq 1000$，$0 < b \leq 1000$，保证答案以及过程中全部数值(整数部分/分子/分母)不超过 $2\times 10^9$。


## 样例 #1

### 输入

```
3
3 5 1
4 7 2
7 3 1```

### 输出

```
248/105```

## 样例 #2

### 输入

```
4
6 7 1
8 3 2
9 14 2
5 17 1```

### 输出

```
-1541/714```

## 样例 #3

### 输入

```
3
7 4 1
3 8 2
3 8 2
```

### 输出

```
1```

# 题解

## 作者：scp020 (赞：26)

### 题目大意

给定 $n$ 个分数 $\dfrac{a_i}{b_i}$，并且给出 $opt_i$，当 $opt_i$ 为 $1$ 时表示在总数上加上 $\dfrac{a_i}{b_i}$，当 $opt_i$ 为 $2$ 时表示在总数上减去 $\dfrac{a_i}{b_i}$，求最后的总和。

### 解决

本题模拟即可。

对于两个分数 $\dfrac{x_1}{y_1}$ 和 $\dfrac{x_2}{y_2}$ 相加，我们可以通分，即 $\dfrac{x_1 \times y_2}{y_1 \times y_2}$ 和 $\dfrac{x_2 \times y_1}{y_2 \times y_1}$ 相加，结果为 $\dfrac{x_1 \times y_2 + x_2 \times y_1}{y_1 \times y_2}$。

对于两个分数 $\dfrac{x_1}{y_1}$ 和 $\dfrac{x_2}{y_2}$ 相减，同上，即 $\dfrac{x_1 \times y_2}{y_1 \times y_2}$ 和 $\dfrac{x_2 \times y_1}{y_2 \times y_1}$ 相减，结果为 $\dfrac{x_1 \times y_2 - x_2 \times y_1}{y_1 \times y_2}$。

除了以上大致解法，我们还要考虑一些特殊情况，例如 $\dfrac{6}{3}$ 这种可以约分的，还有 $\dfrac{-6}{-5}$ 和 $\dfrac{6}{-5}$ 这种负号有误的，都需要想到。

### 赛时代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO//感谢出题人给的快读模板
{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read()
	{
		reg char ch=gh();
		reg long long x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;
inline long long gcd(long long m,long long n)
{
    return n?gcd(n,m%n):m;
}
long long n,a,b,ra,rb,GCD,op;//a为分子，b为分母
int main()
{
	n=read(),ra=read(),rb=read(),op=read(),n--;
	if(op==2) ra=-1*ra;
	while(n--)
	{
		a=read(),b=read(),op=read();
		if(op==1) ra=ra*b+rb*a,rb=rb*b;
		else ra=ra*b-rb*a,rb=rb*b;
		GCD=gcd(ra,rb),ra/=GCD,rb/=GCD;
	}
	if(ra*rb<0) ra=-1*abs(ra),rb=abs(rb);
	if(ra<0 && rb<0) ra=abs(ra),rb=abs(rb);
	if(ra%rb==0) printf("%lld",ra/rb);
	else printf("%lld/%lld",ra,rb);
	return 0;
}
```


---

## 作者：Tis员工 (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P8584)

### 0 前言（可略过）

本人第一篇题解，写了，第一次 $80$ 分，第二次 $20$ 分，第三次 $100$ 分。都是一些细枝末节上的错误。不宣传博客，没啥好宣传的。

### 1 思路

题目大意：给你一堆分数，求相加相减后的最简答案。

思路：简单计算可得：

$\frac{a}{b} \pm \frac{x}{y} = \frac{ay \pm bx}{by}$

所以可以每输入一个分数，就强行通分相加或相减，再约分。保险起见，这里数据值开了 ```long long```

主要知识点：用[辗转相除法](https://www.luogu.com.cn/paste/bnpkchm2)求公因数进行约分，这里不再赘述。不懂得可以点开看一下。

### 2 AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read(){
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
long long gcd(long long a,long long b){
	if(a%b==0)return b;
	else return gcd(b,a%b);
}
long long an,bn,op,x,y,n,k;
int main()
{
    n=read();an=0;bn=1;
    for(long long i=1;i<=n;i++){
    	x=read();y=read();op=read();
    	if(op==1)an=an*y+x*bn;
    	else an=an*y-x*bn;
    	bn=bn*y;
		k=gcd(an,bn);an=an/k;bn=bn/k;
	}
	if(an%bn==0)cout<<an/bn;
	else if(an>0&&bn<0)cout<<-an<<"/"<<-bn;
	else cout<<an<<"/"<<bn;
	return 0;
}
```
### 3 废话

结果出来后只有 $80$ 分，我觉得很奇怪，然后想起来还有个大样例，试了一下就找到问题了：$bn$ 为负数但 $an$ 为正数时，负号要放到前面去。代码中```else if(an>0&&bn<0)cout<<-an<<"/"<<-bn;```起的作用正是这个。

有问题/错误可以评论区说，可能很久或者很快回复。

---

## 作者：bloodstalk (赞：7)

### Update : 代码被朋友恶意修改了/kk，现已修改

## 题意

给你 $n$ 个分数，每个分数后面跟着一个操作符 $op$ , 如果为 $1$ 就是加上这个分数，是 $2$ 就减去。初始时是 $0$ , 询问 $n$ 次操作后最后的分数是多少，化成最简分数。

特殊地，如果最后是个整数，直接以整数的形式输出。


## 思路

### 模拟

  考试的时候一看就想到了 [[NOIP2020]排水系统](https://www.luogu.com.cn/problem/P7113)，只不过这个题很良心，保证计算的时候不会出现 $2 \times 10^9 $ 以上的数，所以可以不用写高精或者是用 `__int128` 。

- 首先我们要有最基础的数论知识：

  用 $\gcd(a,b)$ 表示 $a$ 和 $b$ 的最大公约数，用 $\text{lcm}(a,b)$ 表示 $a$ 和 $b$ 的最小公倍数。

  性质一：$\gcd(a,b) = \gcd(b,a\% b)$ ，有了这个性质，我们就可以快速求出 $a$ 和 $b$ 的最大公约数，至于它的证明，我觉得[这篇博客](https://blog.csdn.net/er111er/article/details/79251895#:~:text=\gcd%E8%AF%81%E6%98%8E%E8%BF%87%E7%A8%8B%20%E7%94%A8%20\gcd%28n%2Cm%29%20g%20c%20d%20%28n%2C%20m%29,g%20c%20d%20%28n%2C%20m%29%20%7C%20m%20%E3%80%82)写的就很不错。

  性质二：$\text{lcm}(a,b) = a \times b / \gcd(a,b)$

  证明：由唯一分解定理可得

  我们设 $a = p_1^{a_1} \times p_2^{a_2}\times \dots \times p_m^{a_m}$,

   $b = p_1^{b_1} \times p_2^{b_2}\times \dots \times p_m^{b_m}(a_i,b_i \ge 0)$。

   $\therefore$ $a \times b = p_1^{a_1+b_1}p_2^{a_2+b_2}\dots p_m^{a_m+b_m}$

   $ = p_1^{\min(a_1,b_1)+\max(a_1,b_1)}\dots p_m^{\min(a_m,b_m)+\max(a_m,b_m)}$

   $ = \gcd(a,b) \times \text{lcm}(a,b)$  

   证毕。

   有了这两个性质，我们就可以很好的求出两个数的最大公约数和最小公倍数了。

-  接下来，模拟即可。可以通过代码来理解。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline

using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int n,fz,fm,nfz,nfm;
int op;

il int read()
{
    int f=0,s=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
    for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
    return f ? -s : s;
}

il int gcd(int a,int b) { return b ? gcd(b,a%b) : a; }
il int lcm(int a,int b) { return a*b/gcd(a,b); }
il int Abs(int x) { return x < 0 ? -x : x; }

signed main()
{
    n = read() - 1;
    fz = read() , fm = read() , op = read();/*首先录入第一个分数*/
    if(op == 2) fz = -fz;/*是减法的话，让分子变为负数*/
    for(re int i=1;i<=n;i++)
    {
        nfz = read() , nfm = read() , op = read();/*输入新分子和分母*/
        if(fz == 0) { if(op == 2) fz = -nfz; else fz = nfz ; fm = nfm; continue; }/*如果原先的数是0，那么直接重新赋值即可*/
        int Lcm = lcm(fm,nfm);/*找到分母的最小公倍数*/
        //cout << Lcm << endl;
        fz *= (Lcm/fm) , nfz *= (Lcm/nfm);/*分子乘上分母变成最小公倍数的倍数*/
        //cout << fz << " " << nfz << " ";
        if(op == 1) fz+=nfz; else fz-=nfz;/*分母相等，可以对分子做加减运算*/
        fm = Lcm;/*分母变成最小公倍数*/
        int Gcd = \gcd(Abs(fz),fm);/*给分数约分，注意分子可能为负数，所以要用绝对值找最大公因数*/
        fz /= Gcd; fm /= Gcd;
    }
    if(fz%fm == 0)/*如果是整数*/
    {
        if(fz < 0)
        printf("-%lld",Abs(fz)/\gcd(Abs(fz),fm));/*小于0加负号*/
        if(fz == 0) printf("0");/*分子是0输出0*/
        if(fz > 0) /*大于不用负号*/
        printf("%lld",fz/\gcd(fz,fm));
    }
    else printf("%lld/%lld",fz,fm);/*分数直接输出*/
    return 0;
}
```


时间复杂度 $\Theta(n\log n)$ ,可以通过。

自认为写的很详细了，有什么问题可以在评论区问。

---

## 作者：sunkuangzheng (赞：2)

**【题目分析】**

前置知识：

1. 分数的通分（小学三年级内容）。$\dfrac{a}{b} + \dfrac{c}{d} = \dfrac{ad+bc}{bd}$。然而为了方便计算，减小运算量，我们通常取分母为 $\operatorname{lcm}(b,d)$，于是就涉及到了下一个知识点。

1. 最大公约数与最小公倍数。这里需要知道 $\gcd(a,b) \times \operatorname{lcm}(a,b) = a \times b$，于是推得 $\operatorname{lcm}(a,b) = \dfrac{a \times b}{\gcd(a,b)}$。至于最大公约数的求法可以使用辗转相除法。

到这里代码思路就不难了。直接按照题目进行模拟即可，但注意，虽然题目保证运算过程中最大数字不超过 $2 \times 10^9$，但是两个不超过 $2 \times 10^9$ 的数字的最小公倍数最大可以达到 $4 \times 10^{18}$，因此需要开 `long long`。

**【完整代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,x,y,z,ans1,ans2=1;//ans1 为分子，ans2 为分母
int gcd(int a,int b){
	if(b > 0) return gcd(b,a % b);
	else return a;
}//辗转相除法求最大公约数
int lcm(int a,int b){
	return a / gcd(a,b) * b;
}
signed main(){
    cin >> n;
    for(int i = 1;i <= n;i ++){
    	cin >> x >> y >> z;
    	int c = lcm(ans2,y);
    	int d1 = c / ans2,d2 = c / y;
    	if(z == 1) ans1 = ans1 * d1 + x * d2;
    	if(z == 2) ans1 = ans1 * d1 - x * d2;//通分
    	ans2 = c;
    	int e = gcd(abs(ans1),ans2);
    	ans1 /= e,ans2 /= e;//进行约分
	}
	if(ans2 == 1) cout << ans1;//分母为 1 时答案为整数
	else printf("%lld/%lld",ans1,ans2);
	return 0;
}
```

---

## 作者：Larryyu (赞：2)

## _Description_
给定 $n$ 组数 $a_i,b_i,opt_i$，表示用当前手上的数加或减 $\dfrac{a_i}{b_i}$（$opt_i=1$ 表示加，$opt_i=2$ 表示减），求执行完所有操作后手上的数。

手上的数最初为零，要求最后输出一个已经约分过的分数，或一个整数。
## _Solution_
将分子分母分开算。

设 $cnta,cntb$ 分别为分子分母。

依题意模拟：$cnta=cnta\times b_i\pm cntb\times a_i,cntb=cntb\times b_i$（通分），然后分子分母分别除去最大公因数即可（约分）。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll  //记得开long long
int n;
int cnta,cntb,f;
ll read(){
    ll x=0,f=1;
    char ch;
    ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*f;
}
signed main(){
	cin>>n;
	int a,b,c;
	cin>>a>>b>>c;
	if(c==1) cnta=a; 
	else cnta=-a;
	cntb=b;
	for(int i=2;i<=n;i++){
		cin>>a>>b>>c;
		if(c==1){
			cnta=cnta*b+cntb*a;  //通分
		}else{
			cnta=cnta*b-cntb*a;
		}
		cntb*=b;
		int x=__gcd(abs(cnta-0),cntb);  //约分，记得再开一个数
		cnta/=x;  //否则约分分母时，分子已经改变，最大公因数也变了
		cntb/=x;
	}
	if(cntb==1){  //整数要特判
		cout<<cnta;
	}else cout<<cnta<<"/"<<cntb;
	return 0;
}

```
#### _完结撒花！！_

---

## 作者：joyslog (赞：2)

## 探索未知

[洛谷 P8584](https://www.luogu.com.cn/problem/P8584)

以 $0$ 为初始值，进行 $n$ 次运算，每次运算将当前值加上或减去一个分数 $\frac{
x_i}{y_i}$，求出运算结果（要求输出最简分数或整数）。

### 题解

此题是比较简单的模拟。我们将当前分数记为 $\frac{a}{b}$，那么显然要初始化 $a = 0, b = 1$。

做加减法时通分即可。和我们手算分数加减法的步骤一样，先求出分母的**最小公倍数**，再将分子乘以相应的倍数，最后将分子加起来。形式化地写出来就是： 

$$
\frac{x}{y}+\frac{a}{b} = \frac{x\times d_1 + a\times d_2}{l}
$$

其中 $l=\text{lcm}(y,b), d_1 = \frac{l}{y},d_2=\frac{l}{b}$。

求最小公倍数的一般方法是 $\text{lcm}(x,y)=x\times y \div \gcd(x,y)$，证明见 [oi-wiki](https://oi-wiki.org/math/number-theory/gcd/#%E4%B8%A4%E4%B8%AA%E6%95%B0)。

最终要的结果是最简分数，所以可以写一个约分函数：

```cpp
inline void reduce(int &x, int &y) {int d = gcd(x, y); x /= d; y /= d;}
```

可以在每一次运算后都调用，这样保证了在运算过程中不会爆 `int`。

最后注意一下负数如果在分母，要提到前面来。例如 `1/-2` 是错误格式，`-1/2` 才是正确格式。我因此而没有交一次就 AC。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read() {
	ll ret = 0, w = 1; char c = getchar();
	while(!isdigit(c)) {if(c == '-')	w = -1; c = getchar();}
	while(isdigit(c))	{ret = (ret << 1) + (ret << 3) + (c ^ 48); c = getchar();}
	return ret * w;
}
inline void write(ll x) {
	if(x < 0)	x = -x, putchar('-');
	if(x > 9)	write(x / 10);
	putchar(x % 10 + '0');
}
inline int gcd(int x, int y) {return x % y == 0 ? y : gcd(y, x % y);}
inline int lcm(int x, int y) {return x / gcd(x, y) * y;}
inline void reduce(int &x, int &y) {int d = gcd(x, y); x /= d; y /= d;}
int main() {
    int n = read(), a = 0, b = 1;
    for(int i = 1; i <= n; i++) {
        int x = read(), y = read(), op = read();
        reduce(x, y);
        int l = lcm(b, y);
        a *= l / b, x *= l / y;
        if(op == 1) a += x;
        else    a -= x;
        b = l;
        reduce(a, b);
        if(b < 0)  a = -a, b = -b;
    }
    if(b == 1)  write(a);
    else    write(a), putchar('/'), write(b);
    return 0;
}
```

---

## 作者：BlanketRice (赞：2)

这道题其实就是个模拟题，非常水。

### 题目描述
给定 $ n $ 个分数，给定分子 $ a_i $ 和分母 $ b_i $，现在将这些分数进行运算，求最终结果。

### 思路
其实就是一个简单的分数加减法模拟，很简单，可以根据分数加减法的步骤进行模拟。

1.找到两个分母的最小公倍数，将分母变成这个数。

2.求出分母这么操作是乘了几，将分子也乘上这个数。

3.将两个分子进行运算操作，分母用最小公倍数。

4.约分。

### 代码
我们先来看约分。

```cpp
inline void simple (int &a, int &b) {
    while (gcd (a, b) != 1) {
        int g = gcd (a, b);
        a /= g, b /= g;
    }
}
```

非常的简单。

下面我们看分数加减法。

```cpp
inline void play (int a, int b, int c, int d, bool opt) {
    int ansa, ansb;
    int g = lcm (b, d);
    int gx = a * (g / b), gy = c * (g / d);
    int ansxy = (opt == 1 ? gx + gy : gx - gy);
    ansa = ansxy, ansb = g;
    if (a < 0) ansa = -ansa;
    simple (ansa, ansb);
    if (a < 0) ansa = -ansa;
}
```

这个也非常简单吧。

接下来是输出。我们也封装函数。

```cpp
inline void printMark (int a, int b) {
    if (a == b) {
        println(1);
        return;
    }
    if (b == 1) {
        println(a);
        return;
    }
    print(a);
    putchar('/');
    println(b);
}
```

这个也可以写成结构体的形式，完整代码贴上。

[我的代码](https://www.luogu.com.cn/paste/wlcblu5b)

---

## 作者：Fzrcy (赞：2)

本题是一个练习分数加减的题目。

题意：有一个分数初始值为 $0$，进行 $n$ 次操作，每次加上或减去一个分数 $\dfrac{a_i} {b_i}$。

假设进行一次操作前的值为 $\dfrac{x} {y}$，加上一个数 $\dfrac{p} {q}$。

有 $\dfrac{x} {y} + \dfrac{p} {q} = \dfrac{x\times q + y \times p} {y\times q}$。

化简为 $\dfrac{x\times q + y \times p} {y\times q} = \dfrac{(x\times q / \gcd(y,q)) + (y \times p / \gcd(y,q)) } {\operatorname{lcm}(y,q)}$。

注意：每次计算后都要化简！分母不能为负！最终的结果的分母为 $1$ 则直接输出分子！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll gcd(ll x,ll y){
	if(y==0)return x;
	return gcd(y,x%y);
}
ll lcm(ll x,ll y)
{
	return x/gcd(x,y)*y;
}
ll n,p,q;
int main()
{
	ll n;
	cin>>n;
	p=0,q=1;
	for(int i=1; i<=n; i++)
	{
		ll a,b,op;
		cin>>a>>b>>op;
		ll x=gcd(q,b),y=lcm(q,b);
		b/=x;q/=x;
		if(op==1)p=p*b+q*a;
		else     p=p*b-q*a;
		q=y;x=gcd(q,p);
		p/=x;q/=x;//每次计算后都要化简
	}
	if(q<0){q=-q;p=-p;}//分母化为正
	if(q==1)//结果为整数
	{
		cout<<p<<endl;
		return 0;
	}
	cout<<p<<"/"<<q<<endl;
}
```

---

## 作者：yeshubo_qwq (赞：1)

## Description

给定一些分数，求它们加减得到的结果。

## Solution

根据小学数学，可以得到加法的计算：

$\frac{x}{y}+\frac{q}{p}=\frac{xp+qy}{yp}$。

减法同理，加上减数的相反数即可。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,x,y,i,q,p,z;
void add(int q,int p){
	x=x*p+q*y,y*=p;
	int gcd=__gcd(abs(x),y);//x,y必须是正整数 
	x/=gcd,y/=gcd;//约分 
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	x=0,y=1;//初始值 
	for (i=1;i<=n;i++)
		cin>>q>>p>>z,add((z==1?q:-q),p);
	cout<<x;
	if (y!=1) cout<<'/'<<y;
	return 0;
}

```


---

## 作者：LYZHZ (赞：1)

[题目](https://www.luogu.com.cn/problem/P8584)。

虽然说这是一道入门题，但是它还是很细的。


------------

- 首先我们知道：
  
>你的手上拿着一个数字 0。你沿着通道向后走。每走到   一个路牌，会用手上的数和路牌上的分数，用路牌上的运   算符号进行计算，并把得到的新数拿在手中（丢弃掉手中   原来的数）。所以我们只需要按顺序进行加减，而不需要开数组了。

- 其次我们要处理[既约分数](https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/2821376?fromtitle=%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0&fromid=1332623&fr=aladdin)，也就是最简分数，所以我们只需处理使得手上的数字分母与路牌上的相同即可。

  于是我们可以用小学的知识[最小公倍数](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0?fromModule=lemma_search-box)来使得分母相同。

  经推导：$\operatorname{lcm}(x,y)=\frac{x \times y}{\gcd(x,y)}$。
 
  而 $\gcd(x,y)$ 又是[最大公约数](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0?fromModule=lemma_search-box)。

  在 algorithm 库中是有关于 $\gcd$ 的函数的：

  ```cpp
  gcdd=__gcd(x,y);
  ```


------------

所以我们可以根据前面推的理论来解题：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long aa,bb,optt;
long long ansa=0,ansb=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&aa,&bb,&optt);
		long long k=__gcd(bb,ansb);
		long long p=ansb*bb/k;
		aa=aa*ansb/k;
		ansa=ansa*bb/k;
		if(optt==1)
		{
			ansb=p;
			ansa=ansa+aa;
		}
		else if(optt==2)
		{
			ansb=p;
			ansa=ansa-aa;
		}
	}
	if(ansa%ansb==0)	
	{
		printf("%lld",ansa/ansb);
	}
	else 
	{
		int k=__gcd(ansa,ansb);
		ansa=ansa/k;
		ansb=ansb/k;
		if(ansb<0) ansa=-ansa,ansb=-ansb;
		printf("%lld/%lld",ansa,ansb);
	}
	return 0;
}
```
~~但是经过阅读代码我们才发现这道入门题有个坑。~~



题目说：

>保证答案以及过程中全部数值（整数部分 / 分子 / 分母）不超过    $2\times 10^9$。

### **所以最容易忽视的一个点就是：**
 
```cpp
long long
```


------------

最后祝愿所以参加 csp 比赛的同学们考一个好成绩，不要再在 A 题上由于审题而 WA。

---

## 作者：HarryKane (赞：0)

## 前言

这题是 [挖土机杯 CSP-J 组模拟赛 R2](https://www.luogu.com.cn/contest/87102) 的第一题，也是本场比赛的签到题。

## 思路分析
读完题目便可知道，这道题是让我们完成分数的加减运算。

分数的加减需要用到通分和约分的知识。

下面介绍通分和约分。

### 通分

简介：根据分数（式）的基本性质，把几个异分母分数（式）化成与原来分数（式）相等的同分母的分数（式）的过程。

假设两个分数分别为 $\frac{a}{b}$ 和 $\frac{c}{d}$，设另一个整数 $k$ 为 $a$ 和 $b$ 的最小公倍数，则通分后的分数为 $\frac{a \times (k \div b)}{b \times (k \div b)}$ 和 $\frac{c \times (k \div d)}{d \times (k \div d)}$。

### 约分

简介：把分数化成最简分数的过程。

假设一个分数为 $\frac{a}{b}$， 设另一个整数 $k$ 为 $a$ 和 $b$ 的最大公因数，则约分后的分数为 $\frac{a \div k}{b \div k}$。

所以，我们只需要在程序中完成约分和通分这两步，就可以通过本题。

最后，我们还需要判断第一个分数是否为 $0$，如果为 $0$，则需要将答案分子标记为负数。

## Ac Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3;
int a[N+5], b[N+5], opt[N+5];

inline int gcd (int a, int b){
	return (a%b==0) ? b : gcd (b, a%b);
}

inline int lcm (int a, int b){
	return a*b/gcd (a, b);
}

int main (){
	int n; cin >> n;
	for (int i=1; i<=n; i++) cin >> a[i] >> b[i] >> opt[i];
	int x, y; // x 为分子，y 为分母。
	if (opt[1]==1) x=a[1], y=b[1]; // 判断第一个分数是正数还是负数。
	else x=-a[1], y=b[1];
	for (int i=2; i<=n; i++){
		if (opt[i]==1){ // 判断第 i 次运算是加还是减。
			int xx=a[i], yy=b[i];
			int k=lcm (y, yy);
			x*=(k/y); y=k;
			xx*=(k/yy); x+=xx; // 操作见上。
		}
		else{
			int xx=a[i], yy=b[i];
			int k=lcm (y, yy);
			x*=(k/y); 
			xx*=(k/yy);
			x-=xx; y=k; // 操作见上。
		}
	}
	if (x>0){
		int k=gcd (x, y); x/=k; y/=k; // 如果是正数，直接求。
	}
	else{
		int k=gcd (-x, y); x/=k; y/=k; // 否则取相反数求。
	}
	if (x%y==0) cout << x/y; // 约分后为整数。
	else cout << x << "/" << y;  // 约分后为分数。
	return 0;
}
```

---

## 作者：Eleveslaine (赞：0)

## 题意

模拟，给你 $n$ 个分数，求它们的和。

## 分析

我们需要实现分数相加（减）的操作。  
由小学数学可得，分数相加时需要**通分**，将分母统一，即

$$\dfrac{a}{b}+\dfrac{c}{d}=\dfrac{a\times \mathrm{lcm}(b,d)\div b}{ \mathrm{lcm}(b,d)}+\dfrac{c\times \mathrm{lcm}(b,d)\div d}{ \mathrm{lcm}(b,d)}=\dfrac{a\times \mathrm{lcm}(b,d)\div b+c\times \mathrm{lcm}(b,d)\div d}{\mathrm{lcm}(b,d)}.$$

按照此方法对所有分数求和。

如果最后加起来结果**不是最简分数**，需要进行约分。  
约分的方法是**分子分母同时除以其最大公因数**，即 $\dfrac{a}{b}=\dfrac{a \div \gcd(a,b)}{b \div \gcd(a,b)}$（显然一个数除以它的因数一定是整数）

另外，通过**辗转相除法**可以求出最大公因数，代码如下：

```cpp
int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
```

同时，根据 $\mathrm{lcm}(a,b)=\dfrac{ab}{\gcd(a,b)}$ 可以得到以下代码（后面有用）：

```cpp
inline int lcm(int a,int b)
{
    if(a<0) a=-a; // 避免 a,b<0 的情况
    if(b<0) b=-b;
    return a*b/gcd(a,b);
}
```
---
这个式子 $\mathrm{lcm}(a,b)=\dfrac{ab}{\gcd(a,b)}$ 可以通过找规律得出，例如：  
设 $a=12,b=8$，则手算出来 $\gcd(a,b)=4,\mathrm{lcm}(a,b)=24$，  
$\because a\times b=96,\mathrm{and}\;24=\dfrac{96}{4},$  
$\therefore \mathrm{lcm}(a,b)=\dfrac{ab}{\gcd(a,b)}.$

**当然这不是严谨的证明，需要证明的可以看其他的题解。**

---

根据上面的分析，约分的代码也很容易写出来，在下面展示。

接下来是本题解的一个重点：**结构体实现分数加减**。  
我们定义分数结构体如下：

```cpp
struct fraction {
    int a,b; // 表示 a/b
    void yue() // 约分
    {
        int g=gcd(a,b);
        a/=g;
        b/=g;
    }
};
```

我们想要实现如下的效果：

```cpp
fraction A,B;
A.a=1,A.b=3; // A=1/3
B.a=1,B.b=4; // B=1/4
A+=B; // A + B = 1/3 + 1/4 = 4/12 + 3/12 = 7/12
cout << A.a << "/" << A.b << endl;
// 输出：7/12
```

发现，需要写一个结构体成员运算符函数 `+=`，功能就是将两个分数相加，结果放在 `+=` 前面的分数里。  
它的实现如下：（该代码位于 `struct fraction{   };` 的大括号中，和 `yue()` 并列）

```cpp
void operator += (fraction &g)
{
    // 将 b 和 g.b 通分
    int l=lcm(b,g.b);
    int bx=l/b,gbx=l/g.b; // bx,gbx 分别表示两个分数应该分子分母分别乘的数
    a*=bx,g.a*=gbx;
    b=l,g.b=l;
    a+=g.a;
    yue(); // 似乎没有必要？
}
```

对 `void operator += (fraction &g)` 这行代码的详细解释：

- `void` 为函数返回类型，像 `A+=B` 这类不需要返回值的就写 `void`；

- `operator` 为运算符函数的关键字，后边写你想要的运算符，  
事实上 `operator +=` 这个整体可以近似看作一个函数名；

- `(fraction &g)` 为函数参数，这里的 `g` 就是 `+=` 后面的分数。

那么 `+=` 前面的分数是谁呢？没错，就是调用这个函数的结构体自己。  
另外，也可以通过 `this` 关键字调用自己，如 `this.yue()` （只能在成员函数里调用）。

为了方便，也可以写出 `-=` 运算符，只需要将 `a+=g.a` 改为 `a-=g.a` 即可。

## 坑点：

- 所有分数的 $b$ 必须初始化为 $1$，否则 $\gcd$ 会出问题；（当然也可以写一个构造函数）

- 最后的结果可能 $a>0,b<0$，这是输出就会是（例如） `11451/-4`。  
这显然不符合要求，所以要加一个特判，如果 $a>0,b<0$，那么将 $a,b$ 都取反再输出；

- $b$ 可能等于 $1$，即最后结果是整数，这时仅输出 $a$ 即可。

## 代码：

~~喜闻乐见的环节（bushi~~

**禁止抄袭！**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,opt;
int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
inline int lcm(int a,int b)
{
    if(a<0) a=-a;
    if(b<0) b=-b;
    return a*b/gcd(a,b);
}
struct fraction {
    int a,b;
    void yue()
    {
        int g=gcd(a,b);
        a/=g;
        b/=g;
    }
    void operator += (fraction &g)
    {
        int l=lcm(b,g.b);
        int bx=l/b,gbx=l/g.b;
        a*=bx,g.a*=gbx;
        b=l,g.b=l;
        a+=g.a;
        yue();
    }
    void operator -= (fraction &g)
    {
        int l=lcm(b,g.b);
        int bx=l/b,gbx=l/g.b;
        a*=bx,g.a*=gbx;
        b=l,g.b=l;
        a-=g.a;
        yue();
    }
}x;
int main()
{
    x.a=0,x.b=1;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        fraction f;
        scanf("%d %d %d",&f.a,&f.b,&opt);
        if(opt==1)
        {
            x+=f;
        }
        else if(opt==2)
        {
            x-=f;
        }
    }
    x.yue();
    if(x.b!=1)
    {
        if(x.b<0)
        {
            x.b=-x.b;
            x.a=-x.a;
        }
        cout << x.a << "/" << x.b << endl;
    }
    else
        cout << x.a << endl;
    return 0;
}
```

---

## 作者：QAQ__QWQ (赞：0)

我们可以模拟一下分数加减法的过程。

比如 $\frac{4}{7}+\frac{4}{3}$ ，我们可以先将分母相乘，然后将两个数的分子乘上另外一个数的分母，也就是这样:
$$\frac47+\frac43=\frac{4\times3+4\times7}{7\times3}=\frac{40}{35}$$

然而题目要求最简分数，这样得出来的显然不是最简分数，需要约分。怎么约分呢?

我们可以将分母和分子同除它们的最大公约数。也就是下面这样:
$$\frac{40}{35}=\frac{40\div5}{35\div5}=\frac{8}{7}$$

这样得出来的就是最简分数了。减法同理。

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 1000010
#define ll long long
inline ll read(){//快读，请忽略
    char c = getchar();ll x = 0,s = 1;
    while(c < '0' || c > '9') {if(c == '-') s = -1;c = getchar();}
    while(c >= '0' && c <= '9') {x = x*10 + c -'0';c = getchar();}
    return x*s;
}
//STL大法好
pair<ll,ll> add(ll a,ll b,ll pa,ll pb){ // a/b+pa/pb
    ll sa=a*pb+pa*b,sb=b*pb;// 分子×分母
    return make_pair(sa,sb);
}
pair<ll,ll> sub(ll a,ll b,ll pa,ll pb){ // a/b-pa/pb
    ll sa=a*pb-pa*b,sb=b*pb;
    return make_pair(sa,sb);
}
pair<ll,ll> hj(pair<ll,ll>now){
    ll a=now.first,b=now.second;
    int f=1;//是否为负数
    if(a<0&&b<0)a=abs(a),b=abs(b);//负负得正，结果为正
    if(a<0||b<0)f=-1,a=abs(a),b=abs(b);//有一个为负结果就为负
    ll tmp=__gcd(a,b);//最大公约数
    a/=tmp,b/=tmp;//同除
    return make_pair(a*f,b);
}
string tostr(pair<ll,ll>now){//分数转字符串
    if(now.second==1)return to_string(now.first);//如果分母为1直接返回分子
    else return to_string(now.first)+"/"+to_string(now.second);//否则返回"分子/分母"
}
int main(){
    ll n=read();pair<ll,ll>now;
    now.first=0,now.second=1;//分母不能为0
    while(n--){
        ll a=read(),b=read(),opt=read();
        if(opt==1)now=add(now.first,now.second,a,b);
        else now=sub(now.first,now.second,a,b);
        now=hj(now);
    }
    cout<<tostr(hj(now));//化简并输出
}
```

---

## 作者：Esawkm (赞：0)

这题很简单，只需要会求 最小公倍数和最大公约数就行了 ~~但是我赛时却没 AC~~ 。

开始的第一个先算上去，之后把两个分母化成他们的最大公约数，把分子乘上相应的倍数就行了。

有一个坑，如果分母是负数的话就要把分子分母同时乘 $-1$ （我赛时就是因为这个才没 AC 的）。

### code：
```
#include<bits/stdc++.h>
using namespace std;
int n,l,r,opt;
int m,z;
int main(){
	cin>>n;
	cin>>l>>r>>opt;
	if(opt==1)/*开始的第一个先算上去*/
	z=l,m=r;
	else
	z=-l,m=r;
	n--;
	while(n--){
		cin>>l>>r>>opt;
		if(opt==1){
			int kk=r*m/__gcd(r,m);/*计算分母的最小公倍数*/
			z*=(kk/m),l*=(kk/r);/*分子同乘一个倍数*/
			z=z+l;
			m=kk,r=kk;/*计算*/
		}
		else{
        /*减法同上*/
			int kk=r*m/__gcd(r,m);
			z*=(kk/m),l*=(kk/r);
			z=z-l;
			m=kk,r=kk;
	}
	}
	int gc=__gcd(m,z);
	m/=gc,z/=gc;
	if(m<0&&z>0)
	m*=-1,z*=-1;/*如果分母是负数的话就要把分子分母同时乘 -1 */
	cout<<z<<'/'<<m;
	return 0;
}
```

---

## 作者：jgvccc (赞：0)

#### 简化版题意

给定一个算式，每一项均为分数，求这个算式的结果（要约分）。

#### 思路

可以看到题目的数据范围中仅仅是说明了最简分数的分子分母大小不超过 $2 \times 10^9$，并没有说明直接通分的结果，所以我们需要对每一项先通分，计算完之后约分。

因为有可能通分完之后（还没有约分）的分子分母会爆 `int`，所以我们开一下 `long long`，这样就可以万无一失了。

很多题解都说求最小公倍数，其实直接通分就可以。

这里需要注意的细节就是最后的输出格式。需要保证分母是正数。所以无论分子是什么，只要分母小于 $0$ 就需要把分母变成它的相反数。

另外特判一下分母是不是 $1$ 就行了。是 $1$ 就跳过不输出。

#### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std; 

int n;
int m=1,s;
int a,b,f;
int t;

signed main()
{
	std::ios::sync_with_stdio(false);
    cin>>n;
    while(n--)
    {
        cin>>a>>b>>f;
        a*=m;
        m*=b;
        s*=b;
        if(f==1) s+=a;
        else s-=a;
        t=__gcd(m,s);
        m/=t;s/=t;
    }
    if(m<0) s=-s,m=-m;
    cout<<s;
    if(m!=1) cout<<"/"<<m;
	return 0;
}

```

---

## 作者：LJKX (赞：0)

~~前言：考试中唯一A了的题，本人太蒻了~~

### 题意

有 $n$ 个分数，求所有分数总和。

### 思路

小学数学题，举个栗子。
### $\frac12 + \frac13 = \frac36+\frac26 = \frac56$

我们凭借小学知识可以知道，两个分数之和即为分子分母交叉相乘之和除以分母之积。

所以这个题解法显而易见就出来了：结果的分母就是所有分母的最小公倍数，分子就是所有分子乘上对应分母变化的倍数，然后再相加。最后分子和分母要进行约分。

PS：如果分子能除尽分母，需要特判一下。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],b[1005],c;
int sum,ans=1;//sum作分子，ans作分母
int lcm(int x,int y) {//求最大公约数
	return x*y/__gcd(x,y);
}
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%d%d%d",&a[i],&b[i],&c);
        if(c==2)a[i]=-a[i];//负数取反
        ans=lcm(ans,b[i]);
    }
    for(int i=1;i<=n;i++) {
    	int op=ans/b[i];
    	sum+=a[i]*op;//求分子
    }
    
    if(sum%ans==0) {printf("%d\n",sum/ans);return 0;}
    //能除尽就特判
    if(sum<0) putchar('-'),sum=-sum;
    int op=__gcd(sum,ans);
    sum/=op,ans/=op;//约分
    printf("%d/%d\n",sum,ans);//QWQ
    return 0;
}
```
~~最后，CSP-2022在即，大家Rp++~~

---

## 作者：OoXiao_QioO (赞：0)

# 思路

这道题考验你三年级所学的分数加减法。

我们都知道 $\dfrac{a}{x}+\dfrac{b}{y} = \dfrac{ay+bx}{xy}$，而     $\dfrac{a}{x}-\dfrac{b}{y} = \dfrac{ay-bx}{xy}$（不考虑负数），把上述式子结合一下就可以得出正数情况下的加减法，对于负数的情况，只需要把分母的符号提到分子前即可。

多个分数加减法呢？
比如 $\dfrac{a}{x}+\dfrac{b}{y}+\dfrac{c}{z}$，答案就等于 
$\dfrac{a\times\dfrac{l}{x}+b\times\dfrac{l}{y}+c\times\dfrac{l}{z}}{l}$，其中 $l$ 为 $x,y,z$ 的最小公倍数。


数学方面的分数加减法会算了，转换成变成语言该是什么呢？我们可以把每次输入的分子分母及 $opt_i$ 扔进数组里存储起来，求出所有分母的最小公倍数为最后答案的分母，而枚举分子时，带入上述的式子，即 `fz += (a[i]*(fm/b[i]));`，最后处理一下负数的细节即可。

# 代码

```cpp
ll a[1001],b[1001],op[1001],lc,fz,fm;//开 ll 比较保险。 
signed main()
{
	ll n,i;
	cin>>n;
	cin>>a[1]>>b[1]>>op[1];//输入第一个数的分子分母即符号。 
	lc = b[1];
	for(i=2;i<=n;i++)
	{
		cin>>a[i]>>b[i]>>op[i];
		lc = lcm(lc,b[i]);//求出所有分母的最小公倍数，即答案的分母。 
	}
	fm = lc;
	fz = 0;
	for(i=1;i<=n;i++)
	{
		if(op[i]==1)//如果这个分数的符号为正 
			fz += (a[i]*(fm/b[i]));//分子加上通分后的分子。 
		else
			fz -= (a[i]*(fm/b[i]));//否则减去通分后的分子。 
	}
	if(fz%fm==0)//判断分数值是否为整数。 
		printf("%lld\n",fz/fm);
	else
	{
		//接下来处理分母为负数的情况。 
		ll tfz = fz/gcd(fz,fm);
		ll tfm = fm/gcd(fz,fm);
		if(tfz>0&&tfm<0)//什么为负数情况呢？分子分母异号且分母是负数，此时分子分母互相取反即可。 
			tfz = -tfz,tfm = -tfm;
		printf("%lld/%lld\n",tfz,tfm);
	}
    return 0;
}
}}}}}
}
```


---

## 作者：CuSO4_and_5H2O (赞：0)

简单写一下这种题目的坑点。

1. 符号。

如果是负数，那么你的代码肯定不能正常运行，所以要处理。如何处理？首先分母不可能是负数，那么处理分子，分子一但是负数就立刻变成正数，然后搞一个标记（标记正负），最后每一次加的时候吧加数分子乘以标记（自己想为什么）然后在按照你写的进行运算。

2. 范围。

通分的过程很容易炸，所以要用大一点的定义类型，或是高精度（NOIP2020 T1）。这个题目数据范围保证了不会爆炸，但是为了安心用 long long 也是好的。

题目比较简单，我相信看题解的童鞋都是提交之后莫名其妙错了之后才看的，所以代码就不贴了（自己打打，很简单）。

---

## 作者：JackMerryYoung (赞：0)

# 前言

挖土只因 T1.

考察了选手对于 $\gcd$ 与 $\operatorname{lcm}$ 的运用。

# 正文

发现这道题就是一个模拟。先读入第一组数据。

然后开始分数加减法了，类似于我们计算时的通分过程中求分母的最小公倍数，我们也可以使用 $\operatorname{lcm}$ 函数求解。

最小公倍数的求法: $\operatorname{lcm} = \dfrac{x \times y}{\gcd(x, y)}$.

最大公约数 $\gcd$ 的求法：辗转相除法。可以 Google / 百度了解一下，也可以直接使用 C++ 库函数 `__gcd()`.

那么就讲一下如何模拟辣。

具体操作就是求解手里拿的数的分母与看到的数的分母的最小公倍数，然后分子各自乘上最小公倍数与分母之商。最后按照 `opr` 的值操作一下即可。

为了不爆炸可以约分 ~~（或者开 `__int128_t`...）~~，还有记得输出符号！

具体过程看代码。

# 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;

long long N, nowa, nowb;

long long gcd(long long x, long long y)
{
	return __gcd(x, y);
}

long long lcm(long long x, long long y)
{
	return x * y / gcd(x, y);
}

signed main()
{
	cin >> N;
	long long tmp;
	cin >> nowa >> nowb >> tmp;
	if(tmp == 2) nowa = -nowa;
	for(long long i = 2; i <= N; ++ i)
	{
		long long a, b, opt, newa, newb, fac;
		cin >> a >> b >> opt;
		newb = lcm(b, nowb);
		nowa *= (newb / nowb);
		a *= (newb / b);
		if(opt == 1)
			newa = (nowa + a);
		if(opt == 2)
			newa = (nowa - a);
		
		fac = gcd(newa, newb);
		newa /= fac, newb /= fac;
		nowa = newa, nowb = newb;
	}
	
	if(gcd(nowa, nowb) != 1 || (nowa == 1 && nowb == 1))
		cout << nowa / nowb << endl;
	else
	{
		if(nowa * nowb < 0)
			cout << '-' << abs(nowa) << '/' << abs(nowb) << endl;
		else
			cout << nowa << '/' << nowb << endl;
	} 
    
	return 0;
}
```

# 后言

T1 是最简单的，写代码时要多多小心...

---

## 作者：_JF_ (赞：0)

## P8584 探索未知 

[题目传送门](https://www.luogu.com.cn/problem/P8584)

题目主要考察分数加减。

我的方法是用一个 $f$ 数组表示到当前的和是正数还是负数，$ans1$ 数组表示当前分子的和，$ans2$ 数组表示分母的和。

对于分数加减，首先我们要做的是通分，也就是找到分母的最小公倍数，设两个数为 $a$，$b$，找到最小公倍数的方法就是：

$$ \text{lcm}(a,b) =a\times b \,\div \gcd(a,b) $$

下一步就是分子分别乘上分母扩倍到最小公倍数的倍数值，然后就是分类讨论，即当前的和和当前的数是：

1. 正，正。
2. 正，负。
3. 负，正
4. 负，负。

还要考虑当前两个分子的大小关系，以来判断当前这一位是正还是负。

在最后，我们需要约分，也就是取分子和分母的最大公因数，同时除以他们即可。

如果分子为 $1$，代表当前的数是整数。

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
int a[N],b[N],f[N],opt[N],ans1[N],ans2[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i]>>opt[i];
	if(opt[1]==1)
		ans1[1]=a[1],ans2[1]=b[1],f[1]=1;
	else
		ans1[1]=a[1],ans2[1]=b[1],f[1]=0;
	for(int i=2;i<=n;i++)
	{
		int m=ans2[i-1]*b[i]/__gcd(ans2[i-1],b[i]);
		int now1=m/ans2[i-1],now2=m/b[i];
		int fen1=ans1[i-1]*now1,fen2=a[i]*now2;
		ans2[i]=m;
		if(f[i-1]==1&&opt[i]==1)
			ans1[i]=fen1+fen2,f[i]=1;
		if(f[i-1]==0&&opt[i]==2)
			ans1[i]=fen1+fen2,f[i]=0;
		if(f[i-1]==1&&opt[i]==2)
		{
			if(fen1>fen2)
				ans1[i]=fen1-fen2,f[i]=1;
			else
				ans1[i]=fen2-fen1,f[i]=0;
		}
		if(f[i-1]==0&&opt[i]==1)
		{
			if(fen1>fen2)
				ans1[i]=fen1-fen2,f[i]=0;
			else
				ans1[i]=fen2-fen1,f[i]=1;
		}
	}
	int k=__gcd(ans2[n],ans1[n]);
	ans2[n]/=k,ans1[n]/=k;
	if(f[n]==0)
		cout<<"-";
	if(ans2[n]==1)	cout<<ans1[n]<<endl,exit(0);
	cout<<ans1[n]<<"/"<<ans2[n];
} 
```


---

## 作者：hycqwq (赞：0)

## 简化题面

问 $n$ 个分数之和，其中有正有负。

## 思路

利用“减一个数等于减它的相反数”把减法转换为加法。

然后就是通分，相加再约分。

### 具体实现方法

- 通分：两个分数都上下同乘另一个分数的分母，**注意要把先乘的分数的分母存起来**。
- 相加：分子相加，没得说。
- 约分：分数上下同除分子与分母的最大公因数（即 gcd），**注意也要把 gcd 存起来，因为原分数会改变**。

## 代码

易错点：这个数据范围要开 long long，~~血与泪的教训~~。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

ll gcd(ll x, ll y)//辗转相除法求最大公因数 
{
	if (y == 0)//原y为x的倍数 
		return x;//即gcd为x 
	return gcd(y, x % y);//取余继续除 
}

int main()
{
	ll n, x = 0, y = 1;//x分子，y分母，0/1为0，注意：分母不能为0 
	cin >> n;
	for (ll i = 1, a, b, opt, t; i <= n; i++)//t为临时变量 
	{
		cin >> a >> b >> opt;//a分子，b分母 
		if (opt == 2)//如果是减法 
			a = -a;//减一个数等于加它的相反数 
#ifndef ONLINE_JUDGE//调试 
		cout << x << "/" << y << " + " << a << "/" << b << " = ";
#endif
		//先通分 
		t = y;//因为后面会动，所以要存，切记！ 
		y *= b, x *= b;//原分数x/y变为xb/yb 
		b *= t, a *= t;//原分数a/b变为ay/by 
		//再相加 
		x += a;
#ifndef ONLINE_JUDGE//调试 
		cout << x << "/" << y << " = ";
#endif
		//最后约分 
		t = gcd(x, y);//因为约分过程中x和y会变，所以先存一下 
		x /= t, y /= t;
#ifndef ONLINE_JUDGE//调试 
		cout << x << "/" << y << "   gcd:" << t << endl;
#endif
	}
	if (y < 0)//特判：如果分母为负 
		x = -x, y = -y;//上下同乘-1 
	cout << x;//正负号包含在x中，因为分母为正数 
	if (y != 1)//分母为1即为正数，不用输出分母，只有分母不是1时才输出分母 
		cout << "/" << y;//别忘了斜杠 
	cout << endl;//个人习惯 
	return 0;
}
```

评测记录：[R90497939](https://www.luogu.com.cn/record/90497939)。

---

## 作者：what_can_I_do (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8584)

这道题其实只需要用到 lcm 和 gcd 的知识就行了。

我们先求出所有分数分母的最小公倍数，再把分子也都乘上（分母的最小公倍数除以原分母）。最后再把分子相加减，约分一下就行了。（注意：输出一定要注意分数的负数形式）

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1010],b[1010],c[1010],fz=0,fm,pd=1;
inline long long gcd(long long x,long long y)
{
	while(y^=x^=y^=x%=y);
	return x;
}
inline long long lcm(long long x,long long y)
{
	return x/gcd(x,y)*y;
}
int main()
{
	scanf("%lld",&n);
	for(register int i=1;i<=n;i++) scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
	fm=b[1];
	for(register int i=2;i<=n;i++) fm=lcm(fm,b[i]);
	for(register int i=1;i<=n;i++)
	{
		a[i]*=fm/b[i];
		if(c[i]==1) fz+=a[i];else fz-=a[i];
	}
	if(fz<0) pd=-1;
	fz=abs(fz);
	long long m=gcd(fz,fm);
	fz/=m;fm/=m;
	if(fz==1&&fm==1) printf("1");
	else printf("%lld/%lld",fz*pd,fm);
	return 0;
}
```

---

## 作者：olegekei (赞：0)

题意很简单，给定 $n$ 个分数，输出他们的和。

## 思路

可以分别用两个变量记录正分数的和与负分数的和（注意初始化的时候两者分母应该是 $1$，而不是 $0$），到最后比较一下确定答案的符号正负，输出两者之和即可。

另外注意分数加法的通分和约分处理：

通分时求出分母的最小公倍数（lcm），把分数全部化成分母等于最小公倍数的形式。

约分时分子分母同时除以两者最大公约数（gcd）。

最后输出时再特判一下约分出来的答案是否为整数即可。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
long long zfz=0,zfm=1,ffz=0,ffm=1;
void add(long long a,long long b,int opt){
	long long gcd,exgcd,sum;
	if(opt==1){
		gcd=__gcd(zfm,b);
		sum=zfm*b;
		exgcd=sum/gcd;
		zfz=zfz*(exgcd/zfm);
		a=a*(exgcd/b);
		zfz+=a;
		zfm=sum/gcd;
	}
	else{
		gcd=__gcd(ffm,b);
		sum=ffm*b;
		exgcd=sum/gcd;
		ffz*=(exgcd/ffm);
		a*=(exgcd/b);
		ffz+=a;
		ffm=sum/gcd;
	}
}
void upt(int opt){
	long long gcd;
	if(opt==1){
		gcd=__gcd(zfm,zfz);
		if(gcd==1)return;
		zfm/=gcd;
		zfz/=gcd;
	}
	if(opt==2){
		gcd=__gcd(ffm,ffz);
		if(gcd==1)return;
		ffm/=gcd;
		ffz/=gcd;
	}
}
main(){
qin>>n;
for(int i=1,opt;i<=n;i++){
	long long a,b;
	qin>>a>>b>>opt;
	add(a,b,opt);
	upt(opt);
}
long long gcd,sum,exgcd;
gcd=__gcd(ffm,zfm);
sum=ffm*zfm;
exgcd=sum/gcd;
ffz*=(exgcd/ffm);
zfz*=(exgcd/zfm);
zfz-=ffz;
zfm=sum/gcd;
int opt=1;
if(zfz<0)opt=-1,zfz=-zfz;
upt(1);
if(zfz!=zfm)qout<<zfz*opt<<'/'<<zfm;
else qout<<opt*zfz;
}
```

---

## 作者：Low_key_smile (赞：0)

## 前言：

这道题和[[NOIP2020] 排水系统](https://www.luogu.com.cn/problem/P7113)，只不过是没有了拓扑排序。

## 做法：

先通过一个简单的式子引入吧：
$$\frac{1}{2} + \frac{1}{3} = \frac{5}{6}$$ 
这个式子是出题人考虑到能做到这道题的人一定上过小学三年级才出的，然后我们就想这道题改如何实现呢？

将分母化为连个分母的最小公倍数，这样就能完成约分，然后分式相加，分母不变，分子乘上分母变化的倍数，然后分子再相加就是答案了

当然，我判断了一下分母是不是为负数，如果是负数的话，那就先转移到分子上，这样就能让模运算变得准确，当然，这道题没有这个坑点，所以不加也可以过。

# code

```cpp
#include<bits/stdc++.h>
#define gc getchar
#define int long long 
const int N = 2e5+5;
using namespace std;

int n,m,Ans,x,y,a,b,c;

inline int gcd(int x,int y) {return y?gcd(y,x%y) : x;}
inline int lcm(int x,int y) {return x/gcd(x,y)*y;}

inline void print(int x){if (x < 0) putchar('-'), x = -x;if(x > 9) print(x / 10);putchar(x % 10 + '0');}
inline char readchar(){static char buf[100000], *p1 = buf, *p2 = buf;return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;}
inline int read(){int res = 0, f = 0;char ch = gc();for (; !isdigit(ch); ch = gc()) f |= (ch == '-');for (; isdigit(ch); ch = gc()) res = (res << 1) + (res << 3) + (ch ^ '0');return f ? -res : res;}


signed main()
{
	n = read();
	x = read() , y = read() , m =read(); 
	if(m==2) x = - x;
	for(int i=2;i<=n;i++)
	{
		a = read() , b = read() , c = read();
		//     x,   y   x
		int Fm = lcm(y,b) , Fz;
//		int j = gcd(y,b); 
		int Beishu_y = Fm / y;
		int Beishu_b = Fm / b;
		if(c==1) 
			Fz = a* Beishu_b + x* Beishu_y;
		else 
			Fz =  x* Beishu_y  - a* Beishu_b   ;
		if(Fm<0)
		{
			Fm = -Fm;
			Fz = -Fz;
		}
		x = Fz,y = Fm;
		int k = gcd(x,y);
		x/=k,y/=k;
//		cout << x <<" " << y << endl;
	}
	
	int k = gcd(x,y);
	x/=k,y/=k;
	
	if(y==1) print(x);
	else
	{
		if(y<0) 
		{
			x = -x;
			y = -y;
		}
		print(x), printf("/") ,print(y);
	}
	return 0;
}
```

---


# 星环防御工事

## 题目背景

来自河外星系的小行星群即将有组织地打击地球。

## 题目描述

据观测，一共会有共 $n$ 波小行星群攻击太阳系。每一波攻击有两个属性：$d_i,m_i$，表示第 $i$ 波攻击会在第 $d_i$ 个太阳日发动，小行星群的总质量为 $m_i$。如果不进行精准防御，太阳系或将面临灭顶之灾。于是你的上司将星环防御工事的建设任务交给了你。

准确来讲，星环防御工事每个太阳日最多可以击毁总质量为 $k$ 的小行星。对于某一个在第 $d$ 个太阳日出现的小行星群，如果星环防御工事不能在第 $d$ 或 $d+1$ 个太阳日将其击毁(或者仅能部分击毁)，那么该小行星群(或其残余部分)将会被移交给地球和平联合组织 TPC 去处理——你当然不希望到手的美差被别人抢走！

因此你现在想知道，你领导的星环防御工事最多可以击毁多少质量的小行星呢？

## 说明/提示

对于 $10\%$ 的数据，$1\leq n,\max\{d_i\} \leq 20$。

对于 $20\%$ 的数据，$1\leq n,\max\{d_i\}\leq 600$。

对于 $40\%$ 的数据，$1\leq n,\max\{d_i\}\leq 5000$。

对于另外 $10\%$ 的数据，保证全部小行星群的 $m_i$ 总和不超过 $k$ 。

对于 $100\%$ 的数据，$1\leq n,\max\{d_i\}\leq 3\times 10^5$，$0\leq m_i,k\leq 10^4$。

## 样例 #1

### 输入

```
3 3 
1 6
4 7
2 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10 100
6 14
2 92
3 91
4 74
7 75
2 90
7 25
1 92
3 41
2 14```

### 输出

```
580```

# 题解

## 作者：_EternalRegrets_ (赞：5)

### P8586 题解

本题目是一道贪心题。

由题意可知，第 $n$ 天仅可以处理第 $n-1$ 天与第 $n$ 天的陨石。

可以很简单地证明在第 $i$ 天优先处理第 $i-1$ 的陨石会更优一些。因为如果第 $i$ 天优先处理第 $i-1$ 天的陨石，可以让第 $i+1$ 天需要处理的陨石质量减少到最小值，同时也确保了最多处理的陨石质量。

用一个桶去记录每天的陨石质量。

最后循环寻找答案。（特殊处理 $0$ 时刻和最大天数 +$1$）

具体见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int maxn=0; //天数
int ans=0; //答案
int used; //本天已经打掉的质量
int a[500005]; //桶，记录每天有多少质量的陨石

signed main()
{
	int n; cin>>n;
	int k; cin>>k; //输入
	
	for (int i=1;i<=n;i++)
	{
		int d; cin>>d; //天数
		int m; cin>>m; //质量
		
		a[d]+=m; //桶
		maxn=max(maxn,d); //计算最大天数
	}
	
	for(int i=0;i<=maxn+1;i++) //maxn+1 天需处理 因为 maxn+1 天也可以抵挡 maxn 天的；0 时刻也需处理
	{
		if(i==0) //如果是0时刻
		{
			if(a[i]<k) //如果还没有达到上限
			{
				ans+=a[i];
				a[i]=0;  //归零
			}
			else //如果达到了上限
			{
				ans+=k;
				a[i]-=k;  //打掉可以打的数量
			}
		}
		else
		{
			if(a[i-1]<=k) //看前一天的
			{
				ans+=a[i-1];
				used=a[i-1];
				a[i-1]=0;   //归零
			}
			else
			{
				ans+=k;
				used=k;
				a[i-1]-=k;  //打掉可以打的质量
				continue;
			}
			
			if(a[i]<=k-used) //如果本天的还可以抵挡
			{
				ans+=a[i];
				a[i]=0;
			}
			else //还不可以就挑部分抵挡
			{
				ans+=k-used;
				a[i]=a[i]-k+used;
			}
		}
	}
	
	cout<<ans; //输出
	return 0;
}
```

---

## 作者：_sin_ (赞：1)

# P8586 星环防御工事 题解
这题是一题贪心题，应该放在第二题。

首先，先证明一个结论。

> 当前是第 $n$ 天，要优先处理第 $n-1$ 天的陨石， 如果还能处理一些陨石就处理今天的陨石

这个贪心可以很容易的证明出来，因为第 $n-1$ 天的陨石可以在第 $n$ 天处理，但是不能在第 $n+1$ 天处理，而第 $n$ 天的陨石还可以在第 $n+1$ 天处理。当然，第 $n$ 天处理完第 $n-1$ 天的陨石后还可以处理第 $n$ 天的陨石，可以为第 $n+1$ 天减轻工作量。

对于怎么计算答案，可以开一个桶，存储当天的陨石，枚举到第 $\max\{d_{i}\}+1$ 天，用变量 $ans$ 存储答案。

时间复杂度为 $ \mathcal O(n+\max\{d_{i}\})$ 可以拿 $100$ 分。

代码实现：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, k;
int d, m;
int t[300005];
int maxd = 0, ans = 0, uk;

signed main(){
	scanf("%lld%lld", &n, &k);
	for (int i = 1; i <= n; i++){
		scanf("%lld%lld", &d, &m);
		t[d]+=m;maxd = max(maxd, d);
	}
	for (int i = 0; i <= maxd+1; i++){
		if (i == 0){
			if (t[i] <= k) ans+=t[i], t[i] = 0;
			else{
				ans+=k, t[i]-=k;
			}
		}else{
			if (t[i-1] <= k) ans+=t[i-1], uk = t[i-1], t[i-1]=0;
			else {
				ans+=k, uk = k, t[i-1]-=k;continue ;
			}
			if (t[i]<=k-uk) ans+=t[i], t[i] = 0;
			else ans+=k-uk, t[i]-=(k-uk);
		}
	}
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：LYZHZ (赞：1)

[题目](https://www.luogu.com.cn/problem/P8586)。


------------
本题就是一道模拟题，因为：
>对于 $100\%$ 的数据，$1\leq n,\max\{d_i\}\leq 3\times 10^5$，$0\leq m_i,k\leq 10^4$。

所以我们只要枚举天数，用 ```sum[d]``` 来表示第 $d$ 天小行星群的总质量，从 $1$ 到 $300001$ 非常暴力的枚举进行统计 ```ans```。

而统计时，只需要关注两个量，即 ```sum[i]``` 和 ```sum[i-1]``` 。因为 ```ans``` 尽量得大，所以在最优的情况下我们要先判断前一天是否还需要摧毁，在当天摧毁力度不超过 $k$ 时达到最佳（因为前一天要是不先摧毁，那么以后就无法再摧毁了，这也解释了为什么是从 $1$ 到 $300001$）。


------------

根据上述思路写出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,d,m,maxx;
long long sum[301000],ans;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&d,&m);
		sum[d]+=m;
		maxx=max(maxx,d);
	}
	for(int i=1;i<=300001;i++)
	{
		int kk=k;
		if(sum[i-1]>0)
		{
			if(sum[i-1]>=kk) ans+=kk,kk=0;
			else
			{
				kk-=sum[i-1];
				ans+=sum[i-1];
			} 
		}
		if(kk>0&&sum[i]>0)
		{
			if(sum[i]>=kk) ans+=kk,sum[i]-=kk;
			else
			{
				kk-=sum[i];
				ans+=sum[i];
				sum[i]=0;
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：XCH_0803 (赞：1)

这道题是一道贪心~~~~水题~~~~

我们首先要把 $d$ 和 $m$ 数组按照 $d$ 数组来从小到大排序。

再定义一个桶 $k_i$ 就表示第 $i$ 天还可以击毁多少质量的小行星。

接下来我们枚举 $1\sim n$ ,每一次分3种情况：

- 如果可以在第 $d_i$ 个太阳日把质量为 $m_i$ 的小行星全部击毁，就把 $sum$ 加上 $m_i$，$k_i$ 赋值为 $0$。

- 如果可以在第 $d_i\sim d_i+1$ 个太阳日把质量为 $m_i$ 的小行星全部击毁，也把 $sum$ 加上$m_i$，$k_i+1$ 赋值为 $m_i-k_i$，$k_i$ 赋值为 $0$。

- 如果在第 $d_i\sim d_i+1$ 个太阳日都不能把质量为 $m_i$ 的小行星全部击毁，那就把 $sum$加上 $k_i$ 和 $k_i+ 1$，$k_i$ 和 $k_i+1$ 都赋值为 $0$。

话不多说，上代码！

```c
#include<bits/stdc++.h>
using namespace std;
struct ddd{
	long long ty;
	long long zl;
}p[310000];
long long n,k;
int cmp(ddd x,ddd y){
	return x.ty<y.ty;
}
long long ch[310000],sum;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>p[i].ty>>p[i].zl;
	}
	sort(p+1,p+n+1,cmp);
	for(int i=1;i<=p[n].ty+3;i++){
		ch[i]=k;
	}
	for(int i=1;i<=n;i++){
		if(ch[p[i].ty]>=p[i].zl){
			sum+=p[i].zl;
			ch[p[i].ty]-=p[i].zl;
		}
		else if(ch[p[i].ty]+ch[p[i].ty+1]>=p[i].zl){
			ch[p[i].ty+1]-=(p[i].zl-ch[p[i].ty]);
			ch[p[i].ty]=0;
			sum+=p[i].zl;
		}
		else{
			sum+=(ch[p[i].ty]+ch[p[i].ty+1]);
			ch[p[i].ty]=0;
			ch[p[i].ty+1]=0;
		}
	}
	cout<<sum;
	return 0;
}
```


---


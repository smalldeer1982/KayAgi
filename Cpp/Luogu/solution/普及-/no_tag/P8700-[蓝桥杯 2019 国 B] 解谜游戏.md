# [蓝桥杯 2019 国 B] 解谜游戏

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/irtm4w5m.png)

## 题目描述

小明正在玩一款解谜游戏。谜题由 $24$ 根塑料棒组成，其中黄色塑料棒 $4$ 根，红色 $8$ 根，绿色 $12$ 根 (后面用 `Y` 表示黄色、`R` 表示红色、`G` 表示绿色)。初始时这些塑料棒排成三圈，如上图所示，外圈 $12$ 根，中圈 $8$ 根，内圈 $4$ 根。

小明可以进行三种操作：

1. 将三圈塑料棒都顺时针旋转一个单位。例如当前外圈从 $0$ 点位置开始顺时针依次是 `YRYGRYGRGGGG`，中圈是 `RGRGGRRY`，内圈是 `GGGR`。那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：`GYRYGRYGRGGG`、`YRGRGGRR` 和 `RGGG`。
2. 将三圈塑料棒都逆时针旋转一个单位。例如当前外圈从 $0$ 点位置开始顺时针依次是 `YRYGRYGRGGGG`，中圈是 `RGRGGRRY`，内圈是 `GGGR`。那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：`RYGRYGRGGGGY`、`GRGGRRYR` 和 `GGRG`。
3. 将三圈 $0$ 点位置的塑料棒做一个轮换。具体来说：外圈 $0$ 点塑料棒移动到内圈 $0$ 点，内圈 $0$ 点移动到中圈 $0$ 点，中圈 $0$ 点移动到外圈 $0$ 点。例如当前外圈从 $0$ 点位置开始顺时针依次是 `YRYGRYGRGGGG`，中圈是 `RGRGGRRY`，内圈是 `GGGR`。那么轮换一次之后，外圈、中圈、内圈依次变为：`RRYGRYGRGGGG`、`GGRGGRRY` 和 `YGGR`。

小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。给定初始状态，请你判断小明是否可以达成目标？

## 说明/提示

蓝桥杯 2019 年国赛 B 组 H 题。

## 样例 #1

### 输入

```
2
GYGGGGGGGGGG
RGRRRRRR
YRYY
YGGGRRRRGGGY
YGGGRRRR
YGGG
```

### 输出

```
YES
NO```

# 题解

## 作者：___w (赞：17)

### [P8700 [蓝桥杯 2019 国 B] 解谜游戏](https://www.luogu.com.cn/problem/P8700)

#### 题意简述
现有内中外三圈塑料棒，根数分别为 $4,8,12$ 根。有黄红绿三种颜色的塑料棒，根数分别为 $4,8,12$ 根。有三种操作，求是否能达成绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈的目标。

#### 题目分析
先考虑搜索，每个状态有三种操作，呈指数型增长。况且判断状态是否重复就会牺牲大量的时间，就会超时，不可取。

我们注意到这一题只让我们求可行性，而不在乎具体的方案。要使所有颜色移到对应位置，我们只需要操作三。而操作一二都只是在选择操作三的位置，所以每个操作三都是有必然的联系的。

内圈周期为 $4$，中圈周期为 $8$，外圈周期为 $12$，共同的周期为 $4$。所以对于内圈的一个塑料棒，如下图，与其他 $5$ 个塑料棒是固定不变的，只能与这 $5$ 个交换。

![图](https://cdn.luogu.com.cn/upload/image_hosting/a76gxu8q.png)

若这 $6$ 个塑料棒的的颜色刚好为 $3$ 个绿色，$2$ 个红色和 $1$ 个黄色时，操作三是一定可以变成目标状态的：否则无论怎么交换，始终是那些颜色，不可能到达目标状态的。

所以具体的做法是枚举内圈的 $4$ 个塑料棒，再开个桶记录下这 $6$ 个塑料棒的颜色，再判断下即可，详细见代码。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int t, cnt[100];
string a, b, c;
int main() {
	cin >> t;
	while (t--) {
		cin >> a >> b >> c;
		bool flag = 1;
		for (int i = 0; i < 4; ++i) {
			memset(cnt, 0, sizeof(cnt));//清空桶 
			++cnt[a[i]], ++cnt[b[i]], ++cnt[c[i]];
			++cnt[a[i+4]], ++cnt[a[i+8]], ++cnt[b[i+4]];//统计6个塑料棒的颜色 
			if (cnt['Y'] != 1 || cnt['R'] != 2 || cnt['G'] != 3) {//判断条件 
				flag = 0;
				break;
			}
		}
		cout << (flag ? "YES" : "NO") << '\n';
	}
	return 0;
}
```

---

## 作者：Lemonlwl (赞：9)

## P8700 [蓝桥杯 2019 国 B] 解谜游戏 题解
### 题意：

现有 $24$ 根塑料棒，分别为 $4$ 个黄色，$8$ 个红色，$12$ 个绿色，打乱后排成外圈 $12$ 根，中圈 $8$ 根，内圈 $4$ 根，需要我们还原成外圈 $12$ 个绿色，中圈 $8$ 个红色，内圈 $4$ 个黄色的形式。

这道题其实没有任何技巧，纯属**找规律**的思维逻辑题。

![](https://cdn.luogu.com.cn/upload/image_hosting/irtm4w5m.png)

### 观察图片可知：

1. 每一次轮回，零点对应外圈，中圈，内圈的颜色中，绿色有 $3$ 个，红色有 $2$ 个，黄色有 $1$ 个。

1. 每一次轮回，零点对应的位置分别为：```a[i]```，```b[i]```，```c[i]```，```a[i+4]```，```b[i+4]```，```a[i+8]```（$a$ 为外圈，$b$ 为中圈，$c$ 为内圈）。

所以我们可以用一个桶进行累加，然后判断是否符合第一个条件。

附上 [AC](https://www.luogu.com.cn/record/106353872) 代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
string a,b,c;  //外圈，中圈，内圈。
int sum[1005]; //桶。
int main(){
	int t;
	cin>>t;
	while(t--){
		bool flag=true;  //用来记录是否符合条件。
		cin>>a>>b>>c;  //输入。
		memset(sum,0,sizeof(sum));  //初始化。
		for(int i=0;i<4;i++){
			memset(sum,0,sizeof(sum));  //由于每一次判断都需要一个桶，所以这里也要初始化。
			sum[a[i]]++;
			sum[b[i]]++;
			sum[c[i]]++;
			sum[a[i+4]]++;
			sum[b[i+4]]++;
			sum[a[i+8]]++;
			/*条件中的6个位置*/
			if(sum['G']!=3 || sum['R']!=2 || sum['Y']!=1){  //判断不符合。
				flag=false;
				break;
			}
		}
		if(flag){
			cout<<"YES"<<endl;
		}
		else{
			cout<<"NO"<<endl;
		}
		/*输出*/
	}
	return 0;
}
```

点个赞再走呗。

---

## 作者：banned_xiejiayun (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8700)

#### STEP 1：简化题意

给出三个字符串（长度分别是 $12$、$8$、$4$），有绿红黄三种颜色的塑料棒（分别有 $12$ 根、$8$ 根、$4$ 根），要通过以下三种操作：

- 将每个串首元素移到最后

- 将每个串尾元素移到最前

- 交换每个字符串的首元素

使得第一个字符串只有绿色，第二个只有红色，第三个只有黄色。

#### STEP 2：思路推导

与许多人一样，我刚读完前两种操作，以为要用队列模拟，可是一读到第三种操作，便头昏眼花，怀疑这是不是橙题。

但是如果你继续往下读一点便会惊奇地发现——

#### 题目只让输出可否完成！！！

那就根本不需要什么队列了！本题有一大需要注意的点，也是整个题目的突破口——

那就是字符串的长度。

没错，它们分别是 $4$、$8$、$12$。是倍数关系呀！

~~是不是恍然大悟，感觉整个题都想透了~~

由于是倍数关系，前两种操作其实并没有那么万能，它们都是 $4$ 的倍数，所以每一个位置的元素只能与另外 $5$ 个位置的元素交换！

如果感觉难以理解可以结合下图想一想（相同的数字代表相互可以交换）：

```
1 2 3 4 1 2 3 4 1 2 3 4
1 2 3 4 1 2 3 4
1 2 3 4
```
所以我们可以针对每一组（即可以相互交换的 $6$ 个元素）进行判断，只要每个组都可以达到目标状态，整体也一定可以。

由于每一组可以任意交换，所以只要每一组里有 $3$ 个绿色、 $2$ 个红色、$1$ 个黄色就可以了。

代码如下：

```cpp
	for (int i = 0; i < 4; i++) {//因为第三个序列少，所以枚举第三个。
		m['G']=m['R']=m['Y']=0;
		m[a[i]]++;//这里的 m 是 map。
		m[b[i]]++;
		m[c[i]]++;
		m[a[i + 4]]++;
		m[b[i + 4]]++;
		m[a[i + 8]]++;
		if(m['G']==3&&m['R']==2&&m['Y']==1)continue;
		flag=0;
	}
```

#### STEP 3：避开坑点

题目其实没有什么坑点（~~你让我找我也找不出来~~），但是写代码时有一个点需要格外注意：

```
m['G']=m['R']=m['Y']=0;
```

这个赋初始值没有的话，恐怕全错。

~~我知道我不说你也知道，但我要凑齐三个点……~~

### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string a, b, c;
map<char, int> m;
int main() {
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> a >> b >> c;
		bool flag=1;
		for (int i = 0; i < 4; i++) {//因为第三个序列少，所以枚举第三个。
			m['G']=m['R']=m['Y']=0;
			m[a[i]]++;//这里的 m 是 map。
			m[b[i]]++;
			m[c[i]]++;
			m[a[i + 4]]++;
			m[b[i + 4]]++;
			m[a[i + 8]]++;
			if(m['G']==3&&m['R']==2&&m['Y']==1)continue;
			flag=0;
		}
		if(flag)cout<<"YES\n";
		else cout<<"NO\n";
	}
	return 0;
}

```
完~

---

## 作者：Shadow_T (赞：1)

### 题目分析：
经过观察，每一次旋转必须要 $3$ 个圈一起转。但是由于大小不同，内圈 $4$ 次一周期，中圈 $8$ 次一周期，外圈 $12$ 次一周期。

再通过模拟发现以下几根棒是绑定的：

![图](https://cdn.luogu.com.cn/upload/image_hosting/y0f8f47x.png)

然后判断每块颜色是否满足即可。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int color[101];
int main()
{
	int T;
	scanf("%d",&T);
	string a,b,c;
	for(int i=1;i<=T;i++)
	{
		bool p=false;
		cin>>a>>b>>c;//输入
		for(int j=0;j<4;j++)
		{
			memset(color,0,sizeof color);
			color[c[j]]++;//内圈
			color[b[j]]++;
			color[b[j+4]]++;//中圈
			color[a[j]]++;
			color[a[j+4]]++;
			color[a[j+8]]++;//外圈 
			//用桶将绑定的方块统计 
			if(color['Y']!=1||color['R']!=2||color['G']!=3)
			{
				p=true;
				break; 
			}
		}
		if(!p) puts("YES");
		else puts("NO");
	}
	return 0;//完结散花 
}

```

---

## 作者：wuhan1234 (赞：1)

## 1. 编程思路。

我们不妨先将三圈的塑料棒从 $0$ 点位置顺时针顺序编号，则最外圈的 $12$ 根塑料棒顺序编号为 $0\sim 11$，中圈的 $8$ 根塑料棒编号为 $0\sim 7$，内圈的 $4$ 根塑料棒编号为 $0\sim 3$。

为了达到移动交换的目的，需要把待轮换的塑料棒均转动到 $0$ 点位置才能进行。又由于不管是顺时针转动，还是逆时针转动，三圈塑料棒是同时进行的。这样，内圈编号为 $0$   的塑料棒只可能和中圈编号为 $0$ 或 $4$ 的塑料棒，和外圈编号为 $0$、$4$ 或 $8$ 的塑料棒同时转动到 $0$  点位置；更一般地，内圈编号为 $i(0\le i \le 3)$ 的塑料棒只可能和中圈编号为 $i$ 或 $i+4$ 的塑料棒，和外圈编号为 $i$、$i+4$ 或 $i+8$ 的塑料棒同时转动到 $0$ 点位置。

这样在 $0$ 点能进行轮换的塑料棒可以分为 $4$ 组，每组有 $6$ 根塑料棒。要达成最终的目前，每组 $6$ 根塑料棒中，必须有 $3$ 根绿色，$2$ 红色和 $1$ 根黄色。如果每组塑料棒的情况不能满足这个要求，则最后是无法达成目标的。

为此，对参与轮换的 $4$ 组塑料棒进行检查，对每组塑料棒，记下内圈编号为 $i$，中圈编号为 $i$ 和 $i+4$，外圈编号为 $i$、$i+4$ 和 $i+8$ 这 $6$ 根塑料棒各颜色出现的情况，若不满足 $3$ 根绿色、$2$ 红色和 $1$ 根黄色的要求，输出 NO。$4$ 组都满足要求，输出 YES。

## 2. 源程序。
```c
#include <stdio.h>
#include <string.h>
int main()
{
    int t;
    scanf("%d",&t);
    int vis[26];
    while (t--)
    {
        char str1[15],str2[10],str3[5];
        scanf("%s%s%s",str1,str2,str3);
        int i,flag=1;
        for (i = 0; i < 4; i++)
        {
            memset(vis,0,sizeof(vis));  // 每个字母出现次数初始化为0
            vis[str1[i]-'A']++;
            vis[str1[i+4]-'A']++;
            vis[str1[i+8]-'A']++;
            vis[str2[i]-'A']++;
            vis[str2[i+4]-'A']++;
            vis[str3[i]-'A']++;
            if (vis['G'-'A'] != 3 || vis['R'-'A'] != 2 || vis['Y'-'A'] != 1)
            {
                flag = 0;
                break;
            }
        }
        if (flag)
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}

```



---

## 作者：liangbob (赞：0)

### P8700 题解

#### 思路分析

这道题是周期分析。

由于操作是三个圈一起操作，因此肯定是有周期的。

外圈有 $12$ 个，中圈有 $8$ 个，内圈有 $4$ 个。

于是以下的这几个就一定“绑定的”，即无论如何转来转去，调整来调整去，一定就是这几个颜色，不会变化。

- 灰色道子上的那三个

- 中圈最下面的那个（横着的）

- 外圈最上面的那个位置往顺时针数 $4$ 个棒，逆时针过 $4$ 个棒。

然后判断是否存在 $3$ 个外圈色（即绿）， $2$ 个中圈色（即红），$1$个内圈色（即黄）即可，因为对于每一组“绑定的”棒，在外圈有 $3$个，在中圈有 $2$ 个，在内圈有 $1$ 个。

#### 代码

```cpp
for(int i = 0;i < 4;i++)
{
	memset(csp, 0x0, sizeof(csp)); //要清空
    //统计外圈上的
	csp[a[i]]++;
	csp[a[i + 4]]++;
	csp[a[i + 8]]++;
    //统计中圈上的
	csp[b[i]]++;
	csp[b[i + 4]]++;
    //统计内圈上的
	csp[c[i]]++;
	if(csp['Y'] != 1 || csp['R'] != 2 || csp['G'] != 3) //判断是否符合条件
	{ 
		cout << "NO" << endl;
		ok = false;
		break;
	}
}
if(ok) cout << "YES" << endl;
```

---


# [DTOI 2023] A. 小狗哥哥

## 题目背景

luanmenglei 有一个辉煌的现在：他们班的女同学都叫他易酱。

但谁能想到 luanmenglei 有一个悲伤的过去，他五岁的弟弟叫他小狗哥哥。

## 题目描述

下文的所有参数均默认为整数。

作为一位（7k7k 小游戏的）游戏开发者，你设计了如下（简陋的不如小狗哥哥幼儿园大班的毕业设计的）游戏，存在两个要素：
1. 一个敌对生物，其血量为 $m$。
2. 主角的武器，分为 $n$ 级，第 $i$ 级的伤害是 $i\times p$。

游戏的平衡性需要提前规划，所以你还有一个序列 $\{a_n\}$，其含义如下：

- $a_i$ 表示敌对生物被第 $i$ 级武器恰好攻击 $a_i$ 下会死。

可惜你忘记了 $p$ 具体是多少，所以你需要求出所有可能的 $p$ 的个数。

如果可能有无数个 $p$，那么请输出 `xiaogougege`。



## 说明/提示

#### 【样例 1 解释】

当武器为 $1$ 级时，分析可以发现 $p$ 要满足 $1 \leq p < \frac{3}{2}$。  
当武器为 $2$ 级时，分析可以发现 $p$ 要满足 $\frac{3}{4} \leq p < \frac{3}{2}$。  
当武器为 $3$ 级时，分析可以发现 $p$ 要满足 $1 \leq p$。 

又 $p$ 是整数。综上，只有当 $p = 1$ 时满足题目所述条件。

#### 【样例 2】

见附加文件中的 `game/game2.in` 与 `game/game2.out`。

该样例满足测试点 $13\sim 20$ 的限制。

#### 【数据范围与提示】

对于所有测试数据，保证 $1\leq n \leq 10^5$，$1\leq a_i,m\leq 10^9$。

每个测试点的具体限制见下表：

|  测试点编号  |      $n\leq$ | $m,a_i\leq $ | 特殊性质 |
| :-: | :-: |:-:|:-:|
| $1\sim 9$ | $10^5$ | $10^9$ | 数据纯随机 |
|  $10 \sim 12$  |       $3$       |$5$| 无 |
| $13 \sim 20$ | $10^5$ |$10^9$| 无 |

你需要注意，上文纯随机数据的具体生成程序代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, w;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int rand(int l, int r) {
  assert(l <= r);
  return uniform_int_distribution<>(l, r)(rng);
} 

int main() {
  scanf("%d%d%d", &n, &m, &w);
  printf("%d %d\n", n, m);
  for (int i = 1; i <= n; i ++) printf("%d%c", rand(1, w), " \n"[i == n]);
  return 0;
}
```

通俗的说，就是对于给定的 $n,m,w(w\le 10^9)$，数据生成器会随机生成 $n$ 个值域在 $[1,w]$ 内的数，作为 $\{a_n\}$。

## 样例 #1

### 输入

```
3 3
3 2 1```

### 输出

```
1```

# 题解

## 作者：pikiuk (赞：13)

## 命题思路：

- 审题人说要有一个签到题。
- 最开始准备的签到涉及了位运算，被毙掉了。
- 考虑不要太毒瘤，决定出一个模拟题。
- idea 来源 hollow knight，非常优秀的游戏。
- 每次强化完骨钉原来三刀的小怪还是三刀。
- 本来放这个题想让大家都开心开心，但是看结果好像大家都不开心。
- 应该是给足了部分分，大样例的强度也不会很低。
- 模拟 / 小学数学。

## 题解报告：

### 算法 0

- 我不会这题！

- 期望得分 $0$ 分。

### 算法 0.5

- 我不会这题！但我会观察！
- 注意到随机数据下给出的数据大概率不合法！

- 输出 $0$，期望得分 $45$ 分。
- 时间复杂度 $\mathcal{O}(1)$。

### 算法 1

- 我会枚举！
- 枚举 $p$，并代回矩阵模拟，统计合法 $p$ 的个数。
- 注意到 $p$ 的大小不超过 $\max\{a_i\}$。
- 综合时间复杂度 $\mathcal{O}(\max\{a_i\}\times n\times k)$。
- 期望得分 $70$ 分，结合之前的部分分期望得分 $60$ 分。

### 算法 2

- 我会观察性质！
- 不难发现并证明，合法的 $p$ 的取值是一个区间。
- 因此我们由序列逆推得出合法的区间。
- 首先由不等式 $(a_i-1)\times i\times p < m\le a_i\times i\times p$ 可以得出 $p$ 的一个取值范围。
- 注意到这里有个 corner case，要解 $p$ 肯定要移向，$a_i=1$ 要略过，还有就是上取整和下取整要弄清楚，以及有一段点是 $<$ 而不是 $\leq$，出题人为此拍了 $3000$ 组数据，应该卡全了。 
- 然后取 $n$ 个区间的交即可。
- 综合时间复杂度 $\mathcal{O}(n)$。
- 期望得分 $100$ 分。


---

## 作者：NightStriker (赞：13)

样例已经给出提示，让我们求出 $p$ 的范围。

很明显，每次给出的 $a_i$ 是次数，$i$ 是第多少项，那么求出 $p$ 就是 `m/(a[i]*i)`。

但是这还不够，我们需要求出的是范围而不是单个值。

所以就用 `m/((a[i]-1)*i)` 来求出最大值。

这东西可以在线做，每次打个擂台。**最后的答案就是 $l$ 和 $r$ 之间的所有整数。**

注意要判断无解。然后就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x;
double r = 1e11,l = -1;//设置初值
int main() {
	cin>>n>>m;
	for(int i = 1; i<=n; i++) {
		cin>>x;
		l = max(l,(double)m/(x*i));//强转成 double 类型
		r = min(r,(double)m/((x-1)*i));//同上
	}
	if(r==1e11) {//如果方案无数个就输出无解
		cout<<"xiaogougege"<<endl;
		return 0;
	}
	int ans = 0;
	for(int i = ceil(l);i<r;i++) ans++;//l 和 r 之间的所有整数
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：oddy (赞：5)

# 题意简述

有一个怪物的血量为 $m$，有 $n$ 级武器，使用一次第 $i$ 级武器可以扣除 $ip$ 的血量。怪物被第 $i$ 级武器恰好攻击 $a_i$ 下会死。求符合题意的整数 $p$ 的个数或报告无穷解。

# 解题思路

首先明确，“被第 $i$ 级武器恰好攻击 $a_i$ 下会死”，意思是说，怪物扛不住 $a_i$ 下，但扛得住 $(a_i-1)$ 下。

这就是说，攻击 $a_i$ 下的伤害**大于等于** $m$，而攻击 $(a_i-1)$ 下的伤害**小于** $m$。

则有

$$
\begin{cases}
ipa_i\geqslant m,\\
ip(a_i-1)<m.
\end{cases}
$$

解得

$$
\frac m{ia_i}\leqslant p<\frac m{i(a_i-1)}.
$$

我们会得到 $n$ 个这样的区间，需要求区间的交集。之后取最右的左端点，最左的右端点，**不一定是答案**。因为**有可能是空集**（我就是因为这个在赛场上丢了 $45\ \mathrm{pts}$！）。

怎么判断无穷解呢？如果每级武器都是打一下就死，那 $p$ 是多大都可以。此时无穷解。

# 代码

想清楚能不能取等和有无余数的关系。

```cpp
#include <cstdio>
#include <algorithm>

int n, m, a, l, r, ansl, ansr = 2000000000;

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a);
        l = m / (i * a) + bool(m % (i * a));
        r = a > 1 ? m / (i * (a - 1)) - !(m % (i * (a - 1))) : 2000000000;
        ansl = std::max(ansl, l);
        ansr = std::min(ansr, r);
    }
    if(ansr > 1000000000) puts("xiaogougege");
    else printf("%d\n", std::max(0, ansr - ansl + 1));
}
```

---

## 作者：nightwatch.ryan (赞：4)

### 思路
注意看题。题目中说 $a_i$ 表示敌对生物被第 $i$ 级武器恰好攻击 $a_i$ 下会死。那么 $p$ 是 `m/(a[i]*i)`。但是我们要求出 $p$ 的范围。所以 $p$ 的最大值是用 `m/((a[i]-1)*i)` 来求。答案就是 $p$ 的最大值和 $p$ 的最小值之间的所有整数。注意要判断无解的情况。
### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdlib> 
#define db double
int main(){
	int n,m;
	std::cin>>n>>m;
	db l=-1e9,r=1e9;
	for(int i=1;i<=n;i++){
		int tmp;
		std::cin>>tmp;
		l=std::max(l,(db)m/(tmp*i));
		r=std::min(r,(db)m/((tmp-1)*i));
	}
	if(r==1e9)std::cout<<"xiaogougege",exit(0);
	int res=0;
	for(int i=ceil(l);i<r;i++)res++;
	std::cout<<res;
}
```

---

## 作者：Kreado (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8938)。

#### 思路

注意看题目，$a_i$ 表示敌对生物被第 $i$ 级武器**恰好**攻击 $a_i$ 下死。

由题意列出不等式 $((a_i-1)\times i\times p< m\le a_i\times i\times p)$。

解得

$$\lceil \dfrac{m}{(a_i-1)\times i}\rceil-1> p\ge \lceil \dfrac{m}{a_i\times i}\rceil $$

$a_i=0$ 的情况要特判（除数不能为 $0$），由于这些数都是非负整数，所以不可能变号。

最后我们只用算出这 $n$ 个不等式即可，取这 $n$ 个不等式的交就是答案。

我们要对 $r$ 赋极大值，最后判断 $r$ 是否等于 $\inf$，输出 `xiaogougege`。

#### 赛时代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e5+7;
ll n,m,a[Maxn],ans,l,r=1e18;
int main(){
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(ll i=1;i<=n;i++){
		if(a[i]==1){
			ll p2=ceil(m*1.0/(a[i]*i));
			l=max(l,p2);
			continue;
		}
		ll p1=m/((a[i]-1)*i)-(m%((a[i]-1)*i)==0);
		ll p2=ceil(m*1.0/(a[i]*i));
		l=max(l,p2),r=min(p1,r);
	}
	if(r==1e18) printf("xiaogougege");
	else if(r-l+1<=0) printf("0");
	else printf("%lld",max(0ll,r-l+1));
	return 0;
}
```


---

## 作者：SoundOfDestiny (赞：1)

## 分析

对于每个 $a_i$，由于敌对生物恰好被攻击 $a_i$ 次死亡，说明攻击 $a_i - 1$ 次时还未死亡，所以可以列出以下不等式：

$$
(a_i - 1) \cdot i \cdot p < m \leq a_i \cdot i \cdot p
$$

由于 $a_i, i, m$ 已知，所以可以变形为关于 $p$ 的不等式：

$$
\dfrac{m}{a_i \cdot i} \leq p < \dfrac{m}{(a_i - 1) \cdot i}
$$

那么对于所有 $a_i$，计算出这个上下界，并取交集，就是 $p$ 的取值范围（特别地，若 $a_i = 1$，此时没有上界，即上界为正无穷）。

时间复杂度 $O(n)$。

## 代码

这里提供了一种新的记录上下界的方法，即记录分母，最后再统一用 $m$ 去除。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long

int n, m;

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n >> m;
    int mn = 9e18, mx = 0;
    for (int i = 1, a; i <= n; i++)
        cin >> a, mn = min(mn, a * i), mx = max(mx, (a - 1) * i);
    if (mx == 0)
        cout << "xiaogougege" << endl;
    else
        cout << max((int)(ceil((double)m / mx) - ceil((double)m / mn)), 0ll) << endl;
}
```

---

## 作者：ncwzdlsd (赞：1)

简化一下题意，关键信息是敌对生物被打 $a_i-1$ 下不会死，被打 $a_i$ 下一定会死，所以有不等式 $(i\times p)\times (a_i-1)<m\leq(i\times p)\times a_i$。

解不等式，得 $\lceil\dfrac{m}{i\times a_i}\rceil\leq p<\lceil\dfrac{m}{i\times (a_i-1)}\rceil$。由于式子左边是在第 $a_i$ 下能打死敌对生物的最小 $p$，右边是在第 $a_i-1$ 下能打死敌对生物的最大 $p$，所以两边都要向上取整（也可以右边取小于等于并向下取整）。

取所有区间的交集即可。

注意若每一个 $a_i$ 都为 $1$，则没有限制，有无数多解。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+5;
int a[maxn];

signed main()
{
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	bool flag=1;
	int l=0,r=LLONG_MAX;
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=1) flag=0;
		if(a[i]==1) continue;
		l=max((double)l,ceil((double)m/(i*a[i]))),r=min((double)r,ceil((double)m/(i*(a[i]-1))));
		// cout<<l<<' '<<r<<endl;
	}
	if(flag) cout<<"xiaogougege";
	else cout<<max(0LL,r-l);
	return 0;
}
```

---

## 作者：zheng_zx (赞：1)

## P8938 [SSOI 2023 easy Round] A. 小狗哥哥
[题目传送门](https://www.luogu.com.cn/problem/P8938)

### 题意

------------
有一个怪物和主角，怪物的血量为 $m$，主角一个武器，分为 $n$ 级，第 $i$ 次的伤害为 $i \times p$，怪物被第 $i$ 级武器恰好攻击 $a_i$ 次会死。

### 分析

------------
- 题目中明确，$a_i$ 表示敌对生物被第 $i$ 级武器**恰好**攻击 $a_i$ 次死。

意思就是，怪物虽然扛不住 $a_i$ 下，但能抗 $(a_i-1)$ 下。

则可由题意结合分析列出不等式： $(a_i-1) \times i \times \ p < m \leq a_i \times i \times p$。

解得 

$$\lceil \frac {m}{i·a_i} \rceil \le p < \frac {m}{i·(a_i-1)}$$

最后我们只需算出 $n$ 个形如上式的不等式即可，答案就是这 $n$ 个不等式的交。

我们先把 $cntr$ 赋成 $inf$，最后再判断 $r$ 是否大于等于 $inf$，输出 ```xiaogougege``` 即可。

#### AC code：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;

const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int n, m, a[N], l, r, ans, cntl, cntr = INF;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; ++i){
		cin >> a[i];
		l = m / (i * a[i]) + bool(m % (i * a[i]));
		r = a[i] > 1 ? m / (i * (a[i] - 1)) - !(m % (i * (a[i] - 1))) : INF;
		cntl = max(cntl, l);
		cntr = min(cntr, r);
	}
	ans = max(cntr - cntl + 1, 0);
	if(cntr >= INF)
		cout << "xiaogougege" << endl;
	else 
		cout << max(cntr - cntl + 1, 0) << endl;
	return 0;
}
```

---


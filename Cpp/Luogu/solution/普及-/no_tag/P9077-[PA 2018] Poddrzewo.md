# [PA 2018] Poddrzewo

## 题目描述

**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Poddrzewo](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pod/)**

给定一个长度为 $n$ 的序列 $a$。

构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \cdots k$。该树第 $i$ 个结点的度数为 $a_i$。

有可能无解，你可以进行如下操作来使其有解：

1. 修改序列中第 $i$ 个数。
1. 删除序列中第 $i$ 个数。
1. 交换序列中第 $i,j$ 个数。

可以证明，进行有限次操作后一定有解。

你的任务是 **最小化操作 $1$ 使用的次数**。


## 说明/提示

#### 样例 1 解释

我们可以删除第 $3$ 个数字，然后更改元素的顺序。

得到最后的序列为 $(3,2,1,1,1)$。

这是构造的树的示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ptch7dx0.png)

------------

#### 样例 2 解释

我们可以修改第 $3$ 个数字，得到最后的序列为 $(1,2,1)$。可以证明，操作 $1$ 至少需要使用 $1$ 次。

这是构造的树的示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/o6mhe76c.png)

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据：

- $2 \le n \le 10^6$
- $1 \le a_i \le n-1$

保证存在至少一个子任务，其中操作 $1$ 使用次数最小值为 $0$。


## 样例 #1

### 输入

```
6
2 1 5 3 1 1```

### 输出

```
0
5
1 2
2 3
1 4
1 5```

## 样例 #2

### 输入

```
3
1 2 2```

### 输出

```
1
3
1 2
2 3```

# 题解

## 作者：Last_kiss_Snow_Dog6 (赞：5)

### [题目](https://www.luogu.com.cn/problem/P9077)

1. 修改序列中第 $ i $ 个数。
2. 删除序列中第 $ i $ 个数。
3. 交换序列中第 $ i,j $ 个数。

按照正常思路来想我们要建一个图，一个无环的图。

但是看样例一：读入了 $ 6 $ 个度，但是只输出了 $ 4 $ 条边和 $ 5 $ 个点，可以看出：**有一个度没有用到**，这是以简单方法切题的切入点，不妨大胆设想一下，如果只有两个点呢？可以直接用节点一连节点二。

好像题目中的每一个要求都符合了。

节点 $ 1 $ 和节点 $ 2 $ 的度都为 $ 1 $。

那现在题目要求就变成了怎样的条件才能满足直接用节点一连节点二呢？

很显然只要 $ n $ 个度中有 $ 2 $ 个是 $ 1 $ 就行了，不然就变里面随机一到两个为 $ 1 $。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,jh;

int main ( ) {
	
	cin >> n ;
	for (int i = 1;i <= n;i++) {
		int x;
		cin >> x ;
		if (x == 1) jh++;//统计1的个数
	}
	if (jh >= 2) cout << "0" << endl ;//满足情况直接输出
	else cout << 2 - jh << endl ;//不满足时计算所需的改变次数
	cout << "2" << endl << "1 2" << endl ;
}
```


---

## 作者：Malkin_Moonlight (赞：1)

## 题解：P9077 [PA2018] Poddrzewo
## 思路
这是一道很容易误导人的题，题目让我们求出修改操作最少的次数，但仔细想想就会发现删除操作才是最好用的。这种操作可以随便用，我们可以把给定的序列删到只剩下两个节点。
首先拿一个变量 $cnt$ 统计序列中 $1$ 的数量。如果超过了两个，则我们不需要任何一次修改操作，直接删到剩两个 $1$，否则需要修改 $2 - cnt$ 个点。
## 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
#define pb emplace_back
const ll MAXN = 1e6 + 5;
const ll MOD = 1e9 + 7;

ll n, x, cnt, i, j;
 
int main()
{
	//freopen("xxx.in", "r", stdin);
	//freopen("xxx.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (i = 1; i <= n; i++)
	{
		cin >> x;
		if (x == 1) cnt++;
	}
	if (cnt >= 2) cout << "0" << endl;
	else cout << 2 - cnt << endl;
	cout << "2" << endl << "1 2" <<endl;
	return 0;
}

```

---

## 作者：leo_messi10 (赞：1)

这道题要求构造一个无根树，使得树的节点数为 $k$，每个节点的度数为给定的序列 $a$ 中对应位置的值。要求最小化操作 $1$ 的使用次数。

**解题思路：**

我们可以观察到一个规律：如果序列 $a$ 中某个值为 $x$，那么构造的树中必须有至少 $x+1$ 个节点，因为一个节点的度数最多为其子节点的个数加一。因此，我们需要计算序列 $a$ 中的最大值 $m$，然后至少需要构造一个节点数为 $m+1$ 的树。

我们可以考虑如何连接节点以满足题目要求。由于树是连通且无环的图，我们可以从序列 $a$ 中取出 $m+1$ 个值作为树的节点，并按照度数连接节点。具体地，我们可以将序列 $a$ 排序，然后取出前 $m+1$ 个值作为节点，剩余的值不再需要，可以忽略。接下来，我们按照以下规则连接节点：

1. 从序列 $a$ 中取出的第一个值作为根节点，其余的值依次作为其子节点，连接到根节点。
2. 如果某个节点的度数为 $0$，即没有子节点，则将其视为叶子节点。

按照以上步骤构造树后，即可满足题目要求。

so....解题思路为：

1. 计算序列 $a$ 中的最大值 $m$。
2. 构造一个节点数为 $m+1$ 的树，并按照规则连接节点。

这样可以最小化操作 $1$ 使用的次数。




------------
###### ~~管理员大大求过~~
bcsp加油！！！

---

## 作者：T_TLucas_Yin (赞：1)

题目可能有点误导人，让人感觉修改操作是最好用的一种，要求节约修改操作次数。

其实只需要动动脑子就会发现，删除操作好像更好用。既然这种操作可以随便用，我们完全可以把给定的序列删到只剩下两个节点。一棵两个节点的树只有一种可能，即两个节点连一条边，此时两个节点的度数都为 $1$。

这样问题就很好解决了。首先统计出序列中 $1$ 的数量，如果超过了两个，则我们不需要任何一次修改操作，直接删到剩两个 $1$。如果只有一个 $1$，则我们保留这个 $1$ 和另一个节点，并把另一个节点修改成 $1$，需要一次修改操作。如果序列中没有 $1$，则需要两次修改操作。分类判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) sum+=(a[i]==1);
    if(sum>=2) cout<<"0\n";
    else if(sum==1) cout<<"1\n";
    else cout<<"2\n";//输出修改操作次数
    cout<<"2\n1 2";//输出这棵两个节点的树
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：1)

### 题目分析

如果要构造一颗无根树，不难发现所有的无根树都至少 $2$ 个度为 $1$ 的叶子结点，其他度数的节点个数并没有要求。

#### STEP1：求出修改次数。

题目要求使修改次数最少，也就是说删除和交换可以进行无限次，所以我们构造树时只需尽可能少的修改一些数，使得该数组有至少两个 $1$。其余都可以通过删除和交换来构成一棵树。

#### STEP2：构造出无根树。

假设已通过几次修改使数组中含有至少两个 $1$，我们可以只保留两个 $1$，其余数字都删掉。就构成了一颗如下图的无根树。

![ P9077 图-1](https://cdn.luogu.com.cn/upload/image_hosting/yv1sr8i7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

输出这棵树的格式如下。

```cpp
2
1 2
```

### code

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, a, ans;
int main()
{
	scanf("%d", &n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%d", &a);
		(a == 1) ? ans++ : 1;
	}
	printf("%d\n", max(0, 2 - ans));
	printf("2\n");
	printf("1 2\n");
	return 0;
}
```

---

## 作者：zhengpie (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9077)

### 思路

诈骗题。

我们考虑当 $a_1 = a_2 = 1$ 的情形，此时这棵树满足题意。

于是我们可以去构造 $a_1 = a_2 = 1$。

- 若 $a_i(i \in [1,n])$ 中 $1$ 的个数不小于 $2$，那么用操作 $3$ 把两个 $1$ 放在 $a_1$ 和 $a_2$ 的位置，然后使用操作 $2$ 把其他点删掉即可。

- 若 $a_i(i \in [1,n])$ 中 $1$ 的个数小于 $2$，设有 $k$ 个 $1$，那么使用 $2 - k$ 次操作 $1$，再用操作 $3$ 把两个 $1$ 放在 $a_1$ 和 $a_2$ 的位置，最后使用操作 $2$ 把其他点删掉即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ioimprove(); ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define FILE(x); freopen(x".in","r",stdin);freopen(x".out","w",stdout);
int n,cnt;
signed main()
{
    //FILE("");
	ioimprove();
	cin>>n;
    for(int i = 1,x;i <= n;i++) cin>>x,cnt += (x == 1);
    if(cnt >= 2) cout<<"0\n";
    else cout<<2 - cnt<<"\n";
    cout<<"2\n1 2\n";
    return 0;
}
```

---

## 作者：Oracynx (赞：0)

## P9077 [PA2018] Poddrzewo 题解

### 思路分析

这是一道很容易误导人的题……

由于题目要求我们求出「修改操作」最少的次数，但我们发现其实「删除操作」才是最好用的。

你把点都删了，肯定不用管他的度了。

我们只需要有 $2$ 个度为 $1$ 的点即可。

于是我们只需要统计初始的度为 $1$ 的点的个数（$one$），如果有 $2$ 个以上则不需修改，否则需要改出 $2 - one$ 个点。

对于树的形态，$1$ 向 $2$ 连边即可。

### 代码实现

```cpp
#include <cstdio>
int n;
int main()
{
    scanf("%d", &n);
    int one = 0;
    for (int i = 1; i <= n; i++)
    {
        int x;
        scanf("%d", &x);
        one += x == 1 ? 1 : 0;
    }
    if (one >= 2)
    {
        printf("0\n");
    }
    else
    {
        printf("%d\n", 2 - one);
    }
    printf("2\n");
    printf("1 2\n");
    return 0;
}
```

---

## 作者：danb123 (赞：0)

关于本题，很多人都想到了进行判断与深搜遍历。其实这一道题有一个非常关键的一点。它让我们修改次数最少，那我们把这个序列删的就剩两个数了不就行了吗？

那这两个数就必须保证他们是连接的。所以我们就要找到两个节点度都为一的即可。
```cpp
max(0,2-cnt)//cnt为记一的计数器，如果不足两个一，那就只能修改数字了
```
解决了这个问题，再输出一下就行了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,t,cnt;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>t,t==1?cnt++:1;
	cout<<max(0,2-cnt)<<endl<<2<<endl<<1<<' '<<2<<endl;
	return 0;
}
```
## [记录详情](https://www.luogu.com.cn/record/148866689)

时间复杂度为线形。

---

## 作者：Light_Star_RPmax_AFO (赞：0)

# P9077 [PA2018] Poddrzewo 题解

### 前言

[传送门](https://www.luogu.com.cn/problem/P9077)

[更好食用](https://www.luogu.com.cn/blog/JJL0610666/p9077-pa2018-poddrzewo-ti-xie)

## 题目

# [PA2018] Poddrzewo

## 题目描述


给定一个长度为 $n$ 的序列 $a$。

构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \cdots k$。该树第 $i$ 个结点的度数为 $a_i$。

有可能无解，你可以进行如下操作来使其有解：

1. 修改序列中第 $i$ 个数。
1. 删除序列中第 $i$ 个数。
1. 交换序列中第 $i,j$ 个数。

可以证明，进行有限次操作后一定有解。

你的任务是 **最小化操作 $1$ 使用的次数**。


------------
# 分析

### 关于无根树

两个度数为一的结点就可以组成一个无根树。

如图，这样就是一个无根树。
![](https://cdn.luogu.com.cn/upload/image_hosting/ef39xoii.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## 思路

了解完无根树后就很简单了。

我们其实只需要将所有的一些节点删除，再改至多 $2$ 个节点的度数，这样保证有两个度数为 $1$ 的节点就可以组成一个无根树。

那么我们只需要拿 $sum$ 记录有几个度数已经为一的节点（这样就不用改了），以此来最小化 **1** 使用次数。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	int n,s;
	cin>>n;
	int sum=0;
	for(int i=0;i<n;i++){
		cin>>s;
		sum+=(s==1?1:0);
	}
	cout<<(0<2-sum?2-sum:0);
	cout<<endl<<2<<endl<<1<<' '<<2;
	return 0;
}
```


---

## 作者：VitrelosTia (赞：0)

一道比较简单的构造题。

题目要求构造结点数大于 $2$ 的树，那么显然至少要有 $2$ 个度数为 $1$ 的叶子结点，所以可以先直接构造出只有两个结点的的树。依上，计算最小使用操作 $1$ 的次数也很简单，只需要初始化为 $2$，之后每次看到度数为 $1$ 的叶子结点就减 $1$，最后可能减到负数，所以要把结果和 $0$ 取最大值。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,cnt=2,k;
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&k);
		if(k==1) cnt--;
	}
	printf("%d\n2\n1 2",max(cnt,0));
}
```

---

## 作者：ღꦿ࿐ (赞：0)

简单脑筋急转弯，如果不会建议看下我的 Hint 再想想。

Hint1：考虑 $a_i=1$ 的作用。

Hint2：答案不大于 2。

---


首先一棵树至少有两个度为 $1$ 的点。

因为 $a_i\geq 1$ 所以不可能选则 $k=1$，接下来 $k\geq 2$，那么一定存在至少两个度数是 $1$ 的点，因为这样的树可以看作两个相邻的点为“根组”然后在外面加叶子得到的，一个叶子最多使得一个其它点的度数增加而它的度数为 $1$，所以结论成立。

那么与其选择两个度为 $1$ 的点和一堆其他点选择两个度为 $1$ 的点是不劣的。


所以我们只需要改出两个 $1$ 就行了。

令 $1$ 的个数是 $x$，那么答案为 $\max(2-x,0)$。

---


还有一个结论：选 $n(n\geq 1)$ 个度数之和为 $2n-2$，且度数的值域全在 $[1,n)$ 的点一定可以构成一棵树。




---

## 作者：ProzacPainkiller (赞：0)

因为必须要构造一个结点数大于 $2$ 的树，容易看出至少要有 $2$ 个叶子结点（度数为 $1$ 的结点）。因为可以随意删除，为了让问题简单化，直接贪心构造只有 $2$ 个结点（也只有 $2$ 个叶子结点）的树即可。也就是如果度数为 $1$ 的结点数大于 $2$ 就直接删除来构造，其他情况用操作 $1$ 修改结点度数为 $1$ 来补足后删除构造。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n;
	int num=0;
	for(int i=0,a;i<n;i++)
	{
		cin>>a;
		if(a==1)	num++;
	}
	cout<<(num>1?0:2-num)<<"\n2\n1 2";
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：0)

答案不超过 $2$，因为你可以删到只剩两个点然后把它们都改成 $1$。

有两个 $1$ 显然可以按照上面的策略来，答案是 $0$。

只有一个 $1$，必定需要改一个，因为合法的树至少有两个度为 $1$ 的节点。反正：如果假设只有一个度为 $0$，那只能说是叶子，则根必须有两个以上的子树，此时叶子个数超过一个。

一个也没有是显然不合法的，要改两个。

```cpp
void solve() {
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> x, tot += (x == 1);
	cout << 2 - min(2, tot) << "\n2\n1 2\n";
}
```

---

## 作者：iostream69 (赞：0)

# 题目
**[题目传送门](https://www.luogu.com.cn/problem/P9077)**
# 思路
这道题乍一看很难，又是无根树又是节点的，其实是一道数学题。

仔细读题，会发现题目只要求进行修改操作的次数小，但是**没有**要求我们进行多少次删除操作。所以我们一直删删删，删到整个序列中只剩下两个节点就可以了。剩下的节点为 1 和 2。

现在，后两行的输出已经确定了，怎么确定第一行的输出呢？也很简单。只需要统计序列里面有几个 1 就可以了。

### 分类讨论
1. 如果有超过两个 1，就不需要修改操作了，只需要换位操作，就可以让最后的两个节点为 1 和 2。
2. 如果有一个 1，就需要修改一次来保证有两个 1。
3. 同理，如果没有 1，就需要修改两次来保证有两个 1。
# 代码
代码实现难度不大，这题主要是思维难度。
```cpp
#include<iostream>
using namespace std;
int n,sum,fzj;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>sum;
		if(sum==1){
			fzj++;
		}
	}
		cout<<max(0,2-fzj)<<endl;
	cout<<"2"<<endl;
	cout<<"1 "<<"2"<<endl;
	return 0;
}
```

---

## 作者：Y_Aridy (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P9077)
这是一道**思维题**。

------------

**题意简述：**

有一个**长度为 $ n $** 的系列 $ a $，我们需要构造一棵**有 $ k $ 个结点**的无根树，**使得第 $ i $ 个结点的度数为 $ a_i $**。

无解情况下可以有三种处理方式：

1. 修改序列中的 $ a_i $。
2. 删除序列中的 $ a_i $。
3. 交换序列中的 $ a_i,a_j $。

我们需要**使操作 $ 1 $ 的使用次数最小**并使序列有解。

------------

**思路分析：**

题目告诉我们```多解输出任意解```，这是我们这道题的切入点。

不需要麻烦的构图，~~我的CPU可能不太允许我去构造一个度数很大的点~~，我们去看k的范围：$ 2 \le k \le n $，取 $ k $ 的最小值 $ 2 $ 来考虑这道题的解法，我们只需要构造两个结点互连的情况即可（两点度数均为 $ 1 $）。若序列 $ a $ 中 $ 1 $ 的个数大于或等于 $ 2 $，那么将其余大于 $ 1 $ 的元素进行操作 $ 2 $，删除元素。否则进行操作 $ 1 $随机将其他元素更改，使得该序列含有 $ 2 $ 个 $ 1 $，然后将其他元素删除。

------------

# 代码（贴）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7;
int n;
int a[maxn];
int main(){
	cin>>n;
	int cnt;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		cnt+=(a[i]==1);//计算序列中 1 的个数 
	}
	//如果满足，输出0 
	if(cnt>=2){ 
		cout<<0<<" \n";
	}
	//不满足，输出需要更改的次数 
	else{
		cout<<2-cnt<<" \n";
	}
	//一共两个结点，1 2 互连 
	cout<<"2\n1 2";
	return 0;
}
```


---


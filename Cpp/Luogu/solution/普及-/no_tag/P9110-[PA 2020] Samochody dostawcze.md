# [PA 2020] Samochody dostawcze

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Samochody dostawcze](https://sio2.mimuw.edu.pl/c/pa-2020-1/sam/)**

Byteasar 是一家向商店运送物资的公司的后勤人员。在他公司所在的城市里，道路网由横向的街（从西到东）和纵向的道（从南到北）组成。每一对相邻的街和相邻的道都相距一公里。我们把街按从南到北的顺序编号，把道按从西到东的顺序编号。我们将第 $i$ 条道和第 $j$ 条街的交叉点记为 $(i,j)$。你可以假设，对于任何一个整数，都存在一条街的编号为 $j$ 和一条道的编号为 $i$。

Byteasar 明天安排了 $n$ 次送货；第 $i$ 次送货将由一辆货车在时刻 $t_i$ 离开车库，以每时间单位一公里的恒定速度沿街或道行驶。每次送货可以是两种类型中的一种：对于送货类型一，车库在路口 $(w_i,0)$，货车沿道 $w_i$ 向北行驶；对于送货类型二，车库在路口 $(0,w_i)$，货车沿街 $w_i$ 向东行驶。根据计划，每个车库在任何时刻最多只有一辆车离开。

货车不必停下来——驶过收货地点时，司机只需放下要送的包裹。然而，有一个问题，如果两辆货车发现他们同一时刻在同一个十字路口，就很可能会发生碰撞。Byteasar 非常希望避免这种情况。不幸的是，他唯一能做的就是取消一些送货计划。因此，他希望取消尽可能少的送货计划，以便剩下的车中没有任何两辆车同一时刻在同一个十字路口。

## 说明/提示

#### 样例 1 解释

如果四份货物都送出，则第一和第二辆车会在时刻 $5$，在路口 $(5,3)$ 相撞。如果取消第一个送货计划，则第二和第四辆车会在时刻 $7$，在路口 $(7,3)$ 相撞。如果取消第二个送货计划，那么所有车都不会相撞了。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$r_i\in \{1,2\}$，$1\le w_i\le 10^6$，$0\le t_i\le 10^6$。

## 样例 #1

### 输入

```
4
1 5 2
2 3 0
2 3 6
1 7 4```

### 输出

```
1```

# 题解

## 作者：Mason123456 (赞：2)

# P9110

## 题面解释

有 $n$ 辆车在 $t_i$ 出发，对于 $r_i$，当 $r_i$ 为 $1$ 时，车从 $(w_i,0)$ 开始往上走，当 $r_i$ 为 $2$ 时，车从 $(0,w_i)$ 开始往右走。

## 思路

开桶。

因为出发时间不同，需要在放进桶时 $w_i$ 需减去 $t_i$，再看对于不同方向的车有没有 $x_i = y_i$，若有，去除两个方向中车最少的（不排除 $n$ 辆车并排走）。

## CODE

注意：为防止 $w_i - t_i$ 数组越界，统一加上 $>10^6$ 的数，然后建议开大数组。

```
#include <bits/stdc++.h>
using namespace std;
const int N = 3e7 + 10;
const int M = 1e6 + 5;
int x[N], y[N];
int main(){
	int n;
	cin>>n;
	for(int i = 1;i <= n;i++){
		int r, w, t;
		cin>>r>>w>>t;
		if(r == 1){// 向上 
			y[w - t + M] ++;
		}
		else{// 向右 
			x[w - t + M] ++;
		}
	}
	
	int ans = 0;
	for(int i = 0;i <= N;i++){
		if(x[i] && y[i]){
			ans += min(x[i], y[i]);
		}
	}
	cout<<ans;
} 
```


---

## 作者：Contain_Thunder (赞：1)

## 题目简述
有 $n$ 个点，这些点分为两种类型。第一种，点在 $(x,0)$ 的位置。这些点从 $t_i$ 的时刻开始向北走。第二种，点在 $(0,y)$ 的位置。这些点从 $t_i$ 的时刻开始向东走。在这些点中会出现有两个点在同一时刻出在同一位置的情况，也就是相撞。为了避免这一情况的出现，我们选择删除一些点。求最少要删除多少点，才能让所有点不会出现相撞的情况。
## 思路
### 假设所有点出发时间相同
因为每个点的运动速度相等，所以不难发现当两个点的 $x$ 坐标和 $y$ 坐标相等时，这两个点一定会相撞。![](https://cdn.luogu.com.cn/upload/image_hosting/8dhsvmbj.png)
### 当所有点出发时间不同时
这道题的难点就在于如何处理点之间的时间差。我们只需要把当前的 $x$ 坐标或 $y$ 坐标减去他们的时间（因为速度为一）。为了防止出现负数情况我们再把结果加上一个数。
## end
想到这里题目已经很简单了，每次记一个坐标的点数，最后看一下有没有 $x$ 坐标和 $y$ 相等的两个点就行了。
## code
```
#include<bits/stdc++.h>
using namespace std;
int ans,maxx,r,w,t,n,mp[3000009][10];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>r>>w>>t,mp[w-t+1000009][r]++,maxx=max(maxx,w-t+1000009);.
	for(int i=1;i<=maxx;i++) ans+=min(mp[i][2],mp[i][1]);
	cout<<ans;
	return 0;
}	
```


---

## 作者：Sol1 (赞：1)

对于所有运输计划 $(r_i,t_i,w_i)$，按 $t_i-w_i$ 分类。

分类后，任意一类里面任意一个横的和任意一个竖的都会撞上，则我们只能取消全部横的或者取消全部竖的，于是取消尽量少的即可。

复杂度 $O(n)$。

```cpp
int n, cnt[3000005][2];

int main() {
    n = qread();
    for (int i = 1;i <= n;i++) {
        int r = qread(), w = qread(), t = qread();
        cnt[t - w + 1000005][r - 1]++;
    }
    int ans = 0;
    for (int i = 1;i <= 3000000;i++) ans += min(cnt[i][0], cnt[i][1]);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：tanzexiaodezhonghao (赞：1)

## 思路
大致是指：第 $i$ 个计划中，一辆车会在 $t_i$ 时向 $r_i$ 的 $w_i$ 出发，你需要输出删掉几个计划使得计划互不交叉。

很简单，用 $t_i - w_i$ 可以得出类别，用一个二维数组的第二个下表记录分类，因为一个计划中的两项一定会重合，所以暴力加上最小值即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int k=1e6,N=3e6+5,w=2e6;
int n,a[N][2],x,y,z,minans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>z;a[y-z+k][x]++;
    }
	for(int i=1;i<=w;i++) minans+=min(a[i][1],a[i][2]);
	cout<<minans;
	return 0;
}
```

---

## 作者：Laisira (赞：1)

### 题面
一堆 $n$ 个人，在一个平面开车。第 $i$ 个人在第 $t_i$ 时刻，延 $x$ 或 $y$ 轴的 $w_i$ 出发，最小化删除人数使得他们两两不撞车。

### 思路
显然两个车相撞当且仅当在同时刻到达同一点，暴力就不说了，又他们速度相同，于是统一出发时间为 $0$，在变一下起点，起点相同肯定撞车，数组维护一下就行了。

~~算法太优秀了~~，纯 cin 最优解第六，一个的快读 120ms 跑第一。：）

### 代码
```cpp
int min(int x,int y){
    return x<y?x:y;
}
int mp[3000001][2];
int main()
{
    int n;
    read(n);
    for(int i=1;i<=n;i++)
    {
        int u,v,w;
        read(u,w,v);
        mp[w-v+1000000][u-1]++;
    }
    int ans=0;
    for(int i=1;i<=2000000;i++)
        ans+=min(mp[i][0],mp[i][1]);
    write(ans);
    return 0;
}
```

---

## 作者：a18981826590 (赞：0)

# [P9110 [PA2020] Samochody dostawcze](https://www.luogu.com.cn/problem/P9110)
## 题意简述
有 $n$ 个用车送货计划，第 $i$ 个计划的车将在 $t_i$ 时向 $r_i$ 的 $w_i$ 方向行驶，需要删掉尽量少的计划以防止冲突。
## 解题思路
两辆车相撞需要满足 $w_{i}$ 和 $t_{i}$ 相等且类型不同，可以用数组记录 $w_{i}-t_{i}$ 的计划数，但可能为负数，还应加上 $1000000$。最后枚举取最小值即可。
## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010][2],l,m,n,x,y,z;
int main(){
	cin>>n;
	while(n--){
		cin>>x>>y>>z;
		a[y-z+1000000][x%2]++;
		l=max(l,y-z+1000000);
	}
	for(int i=0;i<=l;i++){
		m+=min(a[i][0],a[i][1]);
	}
	cout<<m;
	return 0;
}
```

---

## 作者：lyh4 (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P9110)

### 题目概要：
有 $n$ 个用车送货计划，第 $i$ 个计划的车将在 $t_i$ 时向 $r_i$ 的 $w_i$ 行驶，需要删掉尽量少的计划以防止冲突。

### 思路：
可以以 $t_i - w_i$ 分类。对于每一类，将横行或竖行的车删去尽量少的计划即可。

### 一个小坑点：
$t_i - w_i$ 可能为负！应该将 $t_i - w_i$ 都加上一个统一的数，再用数组分类求解。

---

## 作者：TFHS_arsc (赞：0)

## 思路

我们可以先逆向思维一下，两辆车会相撞要有什么条件。显然，需要**方向不同**且**时间条件**满足。

所以，我们可以运用桶的思想，统计每辆车的信息并分类。（车开的方向分为横向与竖向，所以需要一个二维数组）。最后再遍历一遍桶，选择删除尽量小的答案就行啦~

## 代码

```cpp
#include<iostream>

using namespace std;

int n;
int a[3000005][2];

int main(){
	
	cin>>n;
	int r,w,t;
	for(int i=1;i<=n;i++){
		cin>>r>>w>>t;
		a[w-t+1000000][r]++;//运用桶思想统计 
	}
	int ans=0;
	for(int i=1;i<=2000000;i++){
		ans+=min(a[i][1],a[i][2]);//找到尽量小的答案
	}
	cout<<ans;
	
	return 0;
}
```

---

- 注意：统计时可能会出现为负的情况，我们可以给它加上一个大数，避免数组下标为负。

附：[评测记录](https://www.luogu.com.cn/record/167356419)

---

## 作者：liuyi0905 (赞：0)

### 题目大意
有 $n$ 辆车，第 $i$ 辆车在 $t_i$ 时刻延 $x$ 或 $y$ 的 $w_i$ 出发，要你最小化删除车辆使其两两不相遇。
### 思路
由于车的出发时间可能不同，所以可以按 $w_i-t_i$ 分为若干类。对于每一类只需去除所有横着走或竖着走的车，去除数量最小的即可。对于分的每一类用桶维护即可。

注意 $w_i-t_i$ 可能小于 $0$，所以还需加上一个 $\Delta(\Delta\ge10^6)$ 即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int D=1e6,N=2*D+5;
int n,c[N][2];
int main(){
	cin>>n;
	for(int i=1,r,w,t;i<=n;i++)
		cin>>r>>w>>t,c[w-t+D][r-1]++;
	int z=0;
	for(int i=0;i<=2*D;i++)
		z+=min(c[i][0],c[i][1]);
	cout<<z;
	return 0;
}
```

---

## 作者：Seqfrel (赞：0)

# 题解：P9110 [PA2020] Samochody dostawcze

## 题目大意

把题目抽象一下就是：在一个坐标系中有 $n$ 个点，他们会在 $t_i$ 时从 $(0,w_i)$ 或 $(w_i,0)$ 出发，从 $(0,w_i)$ 出发的点沿 $x$ 轴匀速运动，从 $(w_i,0)$ 出发的点沿 $y$ 轴匀速运动，点的运动速度相同，运动到同一位置的两个点会相撞，求避免相撞需要删除点数量的最小值。

## 解题思路

简单画一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hr9ck1v7.png)

观察这三个相撞的例子，发现：

用红色标出的两个点分别出发与 $(0,4)$ 和 $(2,0)$，在相撞时它们走过的路程分别是 $2$ 和 $4$，又因为点的运动速度是相同的，也就是说出发于 $(2,0)$ 的点比出发于 $(0,4)$ 的点提前 $2$ 个时间单位出发。

用蓝色标出的两个点分别出发与 $(0,6)$ 和 $(6,0)$，在相撞时他们走过的路程都是 $6$，所以它们要同时出发。

用绿色标出的两个点分别出发与 $(0,2)$ 和 $(7,0)$，在相撞时他们走过的路程分别是 $7$ 和 $2$，出发于 $(0,2)$ 的点比出发于 $(7,0)$ 的点提前 $5$ 个时间单位出发。

归纳总结一下就能发现，两个点相撞需满足以下条件：

- 两个点在不同的轴上出发，即 $r_i$ 不同；

- 出发的时间-两个点出发点离原点的距离要相等，即 $t_i-w_i$ 相等。

## 代码实现


代码很好写。记录同时满足以上两个条件的点的数量，删除所有这种情况下在 $x$ 轴出发的点或在 $y$ 轴出发的点即可避免碰撞，取最两个值中较小的并累加。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=3e6+10;
const int d=1e6+10;
int n,ans;
int plan[maxn][3];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int r,w,t;
		scanf("%d%d%d",&r,&w,&t);
		plan[t-w+d][r]++;
	}
	for(int i=1;i<=maxn;i++){
		ans+=min(plan[i][1],plan[i][2]);//删除两个轴上出发点数量少的。
	}
	printf("%d",ans);
	return 0;
} 
```

时间复杂度为线性，稳过。

附：[评测记录](https://www.luogu.com.cn/record/159703657)~~话说测试点是真多。~~

## 一些坑点

- $w_i$ 和 $t_i$ 小于等于 $10^6$，可别弄成 $5 \times 10^5$ 了；
- 因为 $t_i$ 可能小于 $w_i$，为了防止下标越界就把相减的结果加上 $10^6$，数组也多开 $10^6$。

---

## 作者：Genshin_ZFYX (赞：0)

首先我们可以确定，**只有**方向不同的两辆车才有可能相撞。

那两辆车什么时候会相撞呢？我们给按时间减去车库位置的差 $t_i-w_i$ 分类，如果 $r_i=1$ 把它放在 $a$ 数组里，否则放在 $b$ 数组里。为了防止数组越界的情况，我们每次都给 $t_i-w_i$ 加上 $10^6$ ，将数组大小开到 $3\times10^6$。

分完之后将两个数组遍历一遍，因为同一分类里不同方向的车一定会撞到，所以我们加上 $a_i$ 和 $b_i$ 里更小的那个就行了。

AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[3000005],b[3000005],sum;
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	 int n;cin>>n;
	 for(int i=1;i<=n;i++)
	 {
	 	int r,w,t;cin>>r>>w>>t;
	 	if(r==1)a[w-t+000000]++;
	 	else b[w-t+000000]++;
	 }
	for(int i=1;i<=3000000;i++)
	sum+=min(a[i],b[i]);
	cout<<sum;
	return 0;
}

```

---

## 作者：xd244 (赞：0)

先吐槽一下，这道题有 182 个测试点。

像注释一样，在上面也写一遍：

一辆车在时间为 $t$，位置为 $(0,x)$ 的地方出发，就相当于它在时间为 $0$ 的时候在 $(0,x-t)$，类似的，时间为 $t$，位置为 $(x,0)$ 出发就等于时间为 $0$ 时在 $(x-t,0)$ 出发。

两辆车什么时候能相撞呢？先将它们统一在 $t=0$ 的时候出发，因为两车速度相等，所以它们路程相等时，时间相等，就会发生事故。因此两车相交的点，$x$ 坐标和 $y$ 坐标应该是相等的，所以当 $s_i=s_j$ 时两车相撞，变形就是 $w_i-t_i=w_j-t_j$。

还没看懂就自己看注释里面的图吧：
```cpp
#include<iostream>
using namespace std;
#define Maxn 3000010//数组一定要开够，2000010 会WA。（因为 wi-ti=200000 时再加上 1e6 就会 RE）
#define ch 1000010//因为 wi-ti 有可能小于0，所以要加一个大于 1e6 的数。（同上）
#define int long//懒人福音
signed main(){//int 定义成 long long 之后不能用 int main()
	int ans=0,maxn=-1e8,n,st[Maxn][3];cin>>n;//st数组存储堵车情况，前面表示w-t，后面表示方向。
	/*
	（样例1）：
	|
	|
	|
	|
	|    |
	|    |
 t=0|2---+-----
	|    |                           图1-1
	|    1
	+--------------------------------
	    t=2
	在 t=5 的时候撞车...
	所以可以开一个二维数组
	但是，数据范围是 n 小于等于 5e5，所以二维数组肯定不可能。
	只能用一维数组记录每一行数据。
	观察可知，它们的出发点到原点(0.0)的距离相等，然后相撞。
	所有过程请看下图（如图1-2）
	*/
	while(n--){
	    int r,w,t;cin>>r>>w>>t;
	    st[w-t+ch][r]+=1;//每当 w-t 与原来的一个相等时，这一行（列）就增加了一起撞车事故。
	    //注意 w-t<0，所以要加上它们的最大范围。
	    maxn=max(maxn,w-t+ch);
	    //计算一个点的交线数
	}for(int c=1;c<=maxn;c++)ans+=min(st[c][1],st[c][2]);//因为有两个方向
	//每个方向当然包括了另一个方向的一部分，所以是最小值。
	cout<<ans;
}
/*
#1样例：
	    |
	    |    | |
	    |    | |
	    |    | |
	    |    | |
	    |    | |
 t=0 t=6|2,3-+-+-----
	    |    | |                    图1-2
	    |    1 4 → t=4
	    +--------------------------------
	        t=2
	    Num3到(7,3) = 6+7 = 13
	        到(5,3) = 6+5 = 11
	    Num2到(5,3) = 5 = Num1到(5,3) = 3+2,ans++;
	        到(7,3) = 7
	    共1个
*/
```
附上图片：
![](https://cdn.luogu.com.cn/upload/image_hosting/fhkrxbf6.png)

相当于让2号先走$2$秒，这样两车就是同时出发。

---

## 作者：Zhl2010 (赞：0)

## 题目概括
有 $n$ 个计划，在第 $i$ 个计划中，一辆车会在 $t_i$ 时向第 $r_i$ 种类型的 $w_i$ 出发，你要删掉几个计划使得计划互不交叉，让删掉的计划数最少。

## 思路
这种题数据范围太大了，只能用**贪心**。

首先，我们要知道两车相撞的条件，方向不同且类型不同，它们会在十字路口相撞。

其次，辆车会在同一个时间相撞，所以，我们可以考虑用 $w_i-t_i$ 表示相撞的时间。

然后，因为 $w_i-t_i$ 可能是负数，所以最好加上 $1000000$。

最后，用数组 $an$ 记录在时间 $w-t+1000000$ 时，类型为 $r$ 的车到了路口（同一时间只能有一种车道路口）。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int an[2000010][2],ans,n;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		int r,w,t;
		scanf("%d%d%d",&r,&w,&t);
		an[w-t+1000000][r&1]++;//为了节省空间，将 r 改成 r&1。 
	}
	for(int i=1;i<=2000000;i++) ans+=min(an[i][1],an[i][0]);//二者只能选其一 
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：zhoujunchen (赞：0)

做题思路
-------
- 按 $t_i-w_i$ 分类，可以用桶数组实现。

- 分类之后，一个横的和一个竖的肯定会撞上，我们可以取消横的或者取消竖的，于是取消尽量少的即可。

code :
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3000005],b[3000005],ans;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
        int r,w,t;
        cin>>r>>w>>t;
      	//分类
        if(r==1)a[w-t+1000000]++;//可能越界，加上1e6
        else b[w-t+1000000]++;//同上
    }
	for(int i=1;i<=3000000;i++)ans+=min(a[i],b[i]);//取消少的
	cout<<ans;
	return 0;
}
```

---


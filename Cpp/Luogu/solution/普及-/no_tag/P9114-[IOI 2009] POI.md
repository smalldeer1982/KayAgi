# [IOI 2009] POI

## 题目背景

IOI2009 D1T3

## 题目描述

普罗夫迪夫信息学奥林匹克竞赛（Plovdiv Olympiad in Informatics, POI）正在举行。有 $N$ 个选手和 $T$ 道题目。每道题目只有一组测试数据，因此对于每个选手和每道题目，要么这个选手解决了这道题目，要么没有解决。没有部分分。

比赛结束后，每道题目的分数为没有解决这道题目的选手数量。每个选手的得分为他解决的每道题目的得分之和。

Philip 参加了这场比赛，但他被复杂的计分规则搞糊涂了。他看着比赛结果，无法计算出他的最终排名。写一个程序帮助 Philip 计算他的分数和排名。

在比赛开始之前，每个选手从 $1$ 到 $N$ 编号。Philip 的编号为 $P$。最终的排行榜将所有选手按分数降序列出。为避免平局，在得分相同的选手中，按解决题目数量降序排序（解决题目数量多的选手排在解决数量题目少的选手之前）。如果仍存在平局，则按编号升序排序。

**任务**：编写一个程序，给定每个选手的解题情况，计算出 Philip 的分数和他在最终排行榜上的排名。

## 说明/提示

### 样例解释

第一道题目只有一个选手没有解决，所以它值 $1$ 分。第二道题目有两个选手没有解决，所以它值 $2$ 分。第三道题目有四个选手没有解决，所以它值 $4$ 分。因此编号为 $1$ 的选手得 $4$ 分，编号为 $2, 4, 5$ 的选手得 $3$ 分，编号为 $3$ 的选手得 $1$ 分。根据平局规则，编号为 $2$ 的选手（Philip）排在编号为 $4, 5$ 的选手之前，因此 Philip 的最终排名为 $2$，仅在编号为 $1$ 的选手下面。

### 数据范围与约定

- 对于 $35\%$ 的数据，没有选手得分和 Philip 相同。
- 对于 $100\%$ 的数据，$1\leq N, T\leq 2000$，$1\leq P\leq N$。

## 样例 #1

### 输入

```
5 3 2
0 0 1
1 1 0
1 0 0
1 1 0
1 1 0
```

### 输出

```
3 2
```

# 题解

## 作者：ran_qwq (赞：7)

~~IOI 好水啊。~~

直接按照题目模拟。根据做题情况算出每道题**没做出来**的人数、每人做出来的题数和每人的分数。之后扫描一遍，算出有多少人在他前面，注意排名细节：分数第一关键字，题数第二关键字，编号第三关键字。

```cpp
int n,m,k,ans,a[2010][2010],b[2010],c[2010],d[N];
void solve()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=read(),b[j]+=a[i][j]^1,d[i]+=a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			c[i]+=a[i][j]*b[j];
	for(int i=1;i<=n;i++)
		if(c[i]>c[k]||c[i]==c[k]&&d[i]>d[k]||c[i]==c[k]&&d[i]==d[k]&&i<k)
			ans++;
	write(c[k]," "),write(ans+1,"");
}
```

---

## 作者：tianbiandeshenghuo (赞：4)

$\color{white}\text{我才不是为了水估值呢}$
# 题意简述
[题目传送门](/problem/p9114)

[更好的阅读体验](/blog/tianbiandeshenghuo/solution-p9114)

有 $N$ 名选手，$T$ 道题目。每道题目只有对与不对两种状态，分数是该题目未答对的人数。

现在告诉你 Philip 的编号是 $P$，请你求出在最终的排行榜中，Philip 的排名和他的得分。

排行榜的规则是：

>1.按照分数降序排列；
>
>2.如果分数相同，那么按照解决题目数量降序排序；
>
>3.如果解决题目数量也相同，那就按编号升序排列。

# 分析
开个结构体记录每个选手的数据，包括编号、每道题的答题情况、分数、通过题目数量。

同时记录每道题未通过的人数 $wa_i$。

然后暴力判断，给每位选手加上题目分数。

最后按排序规则排序，再暴力找答案即可。

时间复杂度：$O(n\times t) + O(n\times t) + O(n\log n) + O(n)$。

总时间复杂度：$O(n\times t)$。

空间复杂度：$O(n\times t)$。

#  分析
```cpp
#include<bits/stdc++.h>

using namespace std;
int n, t, p, wa[2005];
struct Note{
  int a[2005], id, sco, acp;
  bool operator<(const Note &i)const{
    return sco == i.sco ? (acp == i.acp ? id < i.id : acp > i.acp) : sco > i.sco;//这里我是用的重载运算符，当然 cmp 也可以。
  }
} a[2005];
int main(){
  cin >> n >> t >> p;
  for (int i = 1; i <= n; i++){
    for (int j = 1; j <= t; j++){
      cin >> a[i].a[j];
      a[i].acp += a[i].a[j];
      wa[j] += !a[i].a[j];
    }
    a[i].id = i;
  }
  for (int i = 1; i <= n; i++){
    for (int j = 1; j <= t; j++){
      if (a[i].a[j]){
        a[i].sco += wa[j];
      }
    }
  }
  sort(a + 1, a + n + 1);
  for (int i = 1; i <= n; i++){
    if (a[i].id == p){
      cout << a[i].sco << ' ' << i;
      return 0;
    }
  }
  return 0;
}
```


---

## 作者：_5t0_0r2_ (赞：1)

# 分析：
这是一道标准模拟题。

首先，我们得把所有人的做题情况存下来。

```cpp
const int N = 1e4;
struct data{
	int num, t, cnt;//num表示编号，t表示得分，cnt表示对的题目数量。
} a[N];
int n, t, p, tmp, s[N];//tmp = 1表示这题完成，否则表示不完成。s[i]表示第i题有多少人完成。
bool v[N][N];//v[i][j] 表示第i个人是否完成第j题。
cin >> n >> t >> p;
for (int i = 1; i <= n; i++) {
	a[i].num = i;//初始化编号
	for (int j = 1; j <= t; j++) {
		cin >> tmp;
		v[i][j] = tmp ? true : false;
		s[j] += tmp;
	}
}
```

接着，我们计算每个人的分数。

```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= t; j++) {
		if (v[i][j]) {//如果编号为i的人完成了第j题，那么加分。
			a[i].t += n - s[j];//根据题意，每道题目的分数为没有解决这道题目的选手数量。
			a[i].cnt++;
		}
	}
}
```

然后，我们排序（建议使用 ``std::sort``）。

根据题意，我们写出如下 cmp。

```cpp
bool cmp(data a, data b){
	if (a.t != b.t)//如果两人分数不同，分数高的排在前。
		return a.t > b.t;
   //否则比较对的题目数量。
	if (a.cnt == b.cnt)
      return a.cnt > b.cnt;
   //如果还是相同，比较编号。
	return a.num < b.num;
}
sort(a + 1,a + n + 1,cmp);
```

最后，我们查找 Philip 对应编号的分数和排名即可。

```cpp
for (int i = 1; i <= n; i++) {
	if (a[i].num == p) {
		printf("%d %d",a[i].t,i);//如果找到，输出，并退出程序。
		return 0;
	}
}
```

# 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4;
struct data{
	int num, t, cnt;
} a[N];
bool cmp(data a, data b){
	if (a.t != b.t)
		return a.t > b.t;
	if (a.cnt == b.cnt)
		return a.num < b.num;
	return a.cnt > b.cnt;
}
int n, t, p, tmp, s[N];
bool v[N][N];
signed main() {
	scanf("%d%d%d", &n, &t, &p);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= t; j++) {
			scanf("%d", &tmp);
			v[i][j] = tmp ? true : false;
			s[j] += tmp;
		}
		a[i].num = i;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= t; j++) {
			if (v[i][j]) {
				a[i].t += n - s[j];
				a[i].cnt++;
			}
		}
	}
	sort(a + 1, a + 1 + n, cmp);
	for (int i = 1; i <= n; i++) {
		if (a[i].num == p) {
			printf("%d %d",a[i].t,i);
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：Loser_Syx (赞：1)

## 思路

对于每一道题目，统计做错的人数，这样来便有了每道题的分值。

而每个选手的做题正确情况用了一个数组，捆在结构体里。

并记录好每个选手的编号。

接下来遍历整个选手及其做题正确情况，计算总分。

注意这里别忘了统计总正确题数，不然[你就会](https://www.luogu.com.cn/discuss/580080)……

最后自定义排序完，遍历结构体找出初始编号与 $p$ 相等的就可以了。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
struct INF{
	int i;//编号
	int score;//总分
	int cnt;//做对的题数
	int type[3210];//每道题的正误
}player[3210];
bool cmp(INF a, INF b){
	if(a.score == b.score){//分数相同比做对题数
		if(a.cnt == b.cnt){//做对题数相同比谁编号小
			return a.i < b.i;
		}
		return a.cnt > b.cnt;
	}
	return a.score > b.score;
}
int count[3210];//统计每道题的分值
main(){
	int n, t, p;
	scanf("%lld%lld%lld",&n,&t,&p);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= t; j++){
			scanf("%lld",&player[i].type[j]);
			if(player[i].type[j] == 0){//如果他错了这题
				count[j]++;//那么这题分值+1
			}
		}
		player[i].i = i;
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= t; j++){
			if(player[i].type[j] == 1){
				player[i].cnt++;
				player[i].score += count[j];
			}
		}
	}
	std::sort(player + 1, player + 1 + n, cmp);
	for(int i = 1; i <= n; i++){
		if(player[i].i == p){
			printf("%lld %lld\n", player[i].score, i);
			break;
		}
	}
	return 0;
}
```

---

## 作者：Lovely_Elaina (赞：1)

爆切出生年份 IOI！

妥妥暴力题。

![](https://cdn.luogu.com.cn/upload/image_hosting/3v82r1q1.png)

### 思路

用一个结构体，存一个选手的编号、得分和解决题目数量。

但是得分有点麻烦，首先用一个二维 bool 数组存某个选手是否解决某个题。

用一个一维的数组来储存一个题目多少人通过。

然后循环一遍处理。

全部处理完后用系统自带的 sort 手写一个 cmp 排序。

最后遍历一遍，找到 Philip 的编号再输出分数和排名就行了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2010;

struct node{
    int num;   // 编号
    int t=0;   // 得分
    int cnt=0; // 解决题目数量
}a[N];

bool cmp(node a,node b){
    if(a.t == b.t) {
        if(a.cnt == b.cnt) return a.num < b.num;
        return a.cnt > b.cnt;
    }
    return a.t > b.t;
}

int n,t,p,s[N];
bool b[N][N];

signed main(){
    cin >> n >> t >> p;

    for(int i = 1; i <= n; i++){
        int x;
        for(int j = 1; j <= t; j++){
            cin >> x;
            b[i][j] = x;
            s[j] += x;
            // 两边计算 cnt 都行
        }
        a[i].num = i;
    }

    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= t; j++){
            if(b[i][j]){
                a[i].t += (n-s[j]);
                a[i].cnt++;
            }
        }
    }

    sort(a+1,a+1+n,cmp);

    for(int i = 1; i <= n; i++){
        if(a[i].num == p){
            cout << a[i].t << " " << i << endl;
            return 0;
        }
    }

    return 0;
}
```

---

## 作者：Convergent_Series (赞：0)

解题思路：
---

纯模拟。

首先，由于每个选手的信息较多，所以可以使用**结构体**存储。


```cpp
struct stu{//一名选手 
	int id,tot,cnt;
	//编号、总分、正确题数 
	int s[2010];//答题情况 
}a[2010];
```

对于每一名选手，我们可以先读入信息，然后计算答对题数和每道题的错误人数（即分数）。

```cpp
cin>>n>>t>>p;
int i,j,tmp;
for(i=1;i<=n;i++){//输入信息，计算做对题数、各题分数 
	a[i].id=i;
	for(j=1;j<=t;j++){
		cin>>tmp;
		if(tmp==1) a[i].cnt++;//做对题数增加 
		else sc[j]++;//分数（即错误人数）增加 
		a[i].s[j]=tmp; 
	}
}
```

得出每一题的分数和选手答题情况后就可以计算总分。

```cpp
for(i=1;i<=n;i++){//计算总分 
		for(j=1;j<=t;j++){
			if(a[i].s[j]==1) a[i].tot+=sc[j];
		}
	}
```

接着，对选手排序算出排名。

因为排名方式较为复杂，所以需要定义比较函数。

```cpp
bool cmp(stu x,stu y){//比较函数
	if(x.tot!=y.tot) return x.tot>y.tot;
	if(x.cnt!=y.cnt) return x.cnt>y.cnt;
	return x.id<y.id;
}
```

```cpp
sort(a+1,a+n+1,cmp);//排序
```

排序后，在数组中找到 Philip 的位置，输出已计算好的总分和排名即可。

```cpp
for(i=1;i<=n;i++){//枚举排名找出目标 
	if(a[i].id==p){
		cout<<a[i].tot<<" "<<i;
		return 0;
	}
}
```

参考代码：
---
```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu{//一名选手 
	int id,tot,cnt;
	//编号、总分、正确题数 
	int s[2010];//答题情况 
}a[2010];
bool cmp(stu x,stu y){
	if(x.tot!=y.tot) return x.tot>y.tot;
	if(x.cnt!=y.cnt) return x.cnt>y.cnt;
	return x.id<y.id;
}
int sc[2010];//各题分数
int n,t,p; 
int main(){
	cin>>n>>t>>p;
	int i,j,tmp;
	for(i=1;i<=n;i++){//输入信息，计算做对题数、各题分数 
		a[i].id=i;
		for(j=1;j<=t;j++){
			cin>>tmp;
			if(tmp==1) a[i].cnt++;//做对题数增加 
			else sc[j]++;//分数（即错误人数）增加 
			a[i].s[j]=tmp; 
		}
	}
	for(i=1;i<=n;i++){//计算总分 
		for(j=1;j<=t;j++){
			if(a[i].s[j]==1) a[i].tot+=sc[j];
		}
	}
	sort(a+1,a+n+1,cmp);
	for(i=1;i<=n;i++){//枚举排名找出目标 
		if(a[i].id==p){
			cout<<a[i].tot<<" "<<i;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：ink_ngm (赞：0)

分析一下题目：我们可以用一个大数组存储每个人每道题是否正确，然后计算每道题可得分数，然后用一个结构体存储每名选手的总分，正确题目数量与学号，将结构体排序后，遍历一遍排序好的结构体，寻找学号为 $p$，即 Philip 所在位置，然后输出 Philip 的排名与总分数。


```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||'9'<ch){if (ch=='-') f=-f; ch=getchar();}
	while('0'<=ch&&ch<='9'){x=x*10+ch-'0',ch=getchar();}
	return x*f;
}
struct node{
	int fen,hao,num;
}a[2005];
bool cmp(node x,node y){
	if (x.fen^y.fen) return x.fen>y.fen;//得分不相同是按得分降序排序
	if (x.num^y.num) return x.num>y.num;//得分相同是按正确题目数量降序排序
	return x.hao<y.hao;//得分与正确题目数量都相同时按学号升序排序
}
int v[2005],peo[2005][2005];
int main(){
	register int n=read(),t=read(),p=read();
	for (register int i=1;i<=n;++i)
		for (register int j=1;j<=t;++j){
			peo[i][j]=read();
			if (peo[i][j]==0) ++v[j];//计算每题可得分数
		}
	for (register int i=1;i<=n;++i){
		a[i].hao=i;
		for (register int j=1;j<=t;++j) a[i].fen+=(peo[i][j]*v[j]),a[i].num+=peo[i][j];
	}
	sort(a+1,a+1+n,cmp);
	for (register int i=1;i<=n;++i)
		if (a[i].hao==p){//寻找Philip位置
			printf ("%d %d\n",a[i].fen,i);
			return 0;
		}
	return 0;
}
```

---


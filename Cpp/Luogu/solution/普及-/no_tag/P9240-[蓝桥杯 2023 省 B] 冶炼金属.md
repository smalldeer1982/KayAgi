# [蓝桥杯 2023 省 B] 冶炼金属

## 题目描述

小蓝有一个神奇的炉子用于将普通金属 O 冶炼成为一种特殊金属 X。这个炉子有一个称作转换率的属性 $V$，$V$ 是一个正整数，这意味着消耗 $V$ 个普通金属 O 恰好可以冶炼出一个特殊金属 X，当普通金属 O 的数目不足 $V$ 时，无法继续冶炼。

现在给出了 $N$ 条冶炼记录，每条记录中包含两个整数 $A$ 和 $B$，这表示本次投入了 $A$ 个普通金属 O，最终冶炼出了 $B$ 个特殊金属 X。每条记录都是独立的，这意味着上一次没消耗完的普通金属 O 不会累加到下一次的冶炼当中。

根据这 $N$ 条冶炼记录，请你推测出转换率 $V$ 的最小值和最大值分别可能是多少，题目保证评测数据不存在无解的情况。


## 说明/提示

**【样例说明】**

当 $V=20$ 时，有：$\left\lfloor\frac{75}{20}\right\rfloor=3,\left\lfloor\frac{53}{20}\right\rfloor=2,\left\lfloor\frac{59}{20}\right\rfloor=2$，可以看到符合所有冶炼记录。

当 $V=25$ 时，有：$\left\lfloor\frac{75}{25}\right\rfloor=3,\left\lfloor\frac{53}{25}\right\rfloor=2,\left\lfloor\frac{59}{25}\right\rfloor=2$，可以看到符合所有冶炼记录。

且再也找不到比 $20$ 更小或者比 $25$ 更大的符合条件的 $V$ 值了。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$1 \leq N \leq 10^{2}$。

对于 $60 \%$ 的评测用例，$1 \leq N \leq 10^{3}$。

对于 $100 \%$ 的评测用例，$1 \leq N \leq 10^{4}$，$1 \leq B \leq A \leq 10^{9}$。 

蓝桥杯 2023 省赛 B 组 C 题。

## 样例 #1

### 输入

```
3
75 3
53 2
59 2```

### 输出

```
20 25```

# 题解

## 作者：lailai0916 (赞：39)

## 原题链接

- [洛谷 P9240 [蓝桥杯 2023 省 B] 冶炼金属](https://www.luogu.com.cn/problem/P9240)

## 解题思路

1. 当 $b$ 变成 $b+1$，即再造一个特殊金属 X 时，$V=\left\lfloor\frac{a}{b+1}\right\rfloor$。此时为 **刚好不满足条件的情况**，所以 $V=\left\lfloor\frac{a}{b+1}\right\rfloor+1$ 为 **满足条件的最小情况**。

$$
V_{min}=\left\lfloor\frac{a}{b+1}\right\rfloor+1
$$

2. 同理，**满足条件的最大情况** 为 $\left\lfloor\frac{a}{b}\right\rfloor$。

$$
V_{max}=\left\lfloor\frac{a}{b}\right\rfloor
$$

3. 最终取所有记录的交集，即取所有 $V_{min}$ 的 **最大值** 和 $V_{max}$ 的 **最小值**。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int inf=0x3f3f3f3f;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	int mn=0,mx=inf;
	while(n--)
	{
		int a,b;
		cin>>a>>b;
		mn=max(mn,a/(b+1)+1);
		mx=min(mx,a/b);
	}
	cout<<mn<<' '<<mx<<'\n';
	return 0;
}
```

---

## 作者：icypenguin (赞：13)

## 题目简述

在满足所有 $\lfloor\frac{a[i]}{V}\rfloor = b[i]$ 的情况下，求 $V$ 的最小值与最大值。

## 题目分析

由于 $1 \leq A, B \leq 10^9$，所以 $1 \leq V \leq 10^9$。那我们可以考虑两次二分 $V$。

第一次：

二分 $V$，在满足条件的情况下让 $V$ 尽可能小。


第二次：

二分 $V$，在满足条件的情况下让 $V$ 尽可能大。

接下来我们来看二分答案的 check 函数。

如果在某一个 $\lfloor\frac{a[i]}{V}\rfloor > b[i]$，那么证明 $V$ 小了，需要将 $V$ 变大。

如果在某一个 $\lfloor\frac{a[i]}{V}\rfloor < b[i]$，那么证明 $V$ 大了，需要将 $V$ 变小。

## 代码

```cpp
#include <iostream>
#define ll long long
using namespace std;
ll n, a[1000005], b[1000005];
ll check(ll v){
    for (ll i = 1; i <= n; i++){
        ll c = a[i] / v;
        if (c < b[i]){
            return 1;
        }
        if (c > b[i]){
            return 2;
        }
    }
    return 0;
}
int main(){
    cin >> n;
    for (ll i = 1; i <= n; i++){
        cin >> a[i] >> b[i];
    }
    ll l = 1, r = 1e9, smalll = 1e9, bigg = -1;
    while (l <= r){
        ll mid = (l + r) / 2;
        ll t = check(mid);
        if (t == 0){
            smalll = min(smalll, mid);
            bigg = max(bigg, mid);
            r = mid - 1;
        }else if (t == 2){
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    l = 1, r = 1e9;
    while (l <= r){
        ll mid = (l + r) / 2;
        ll t = check(mid);
        if (t == 0){
            smalll = min(smalll, mid);
            bigg = max(bigg, mid);
            l = mid + 1;
        }else if (t == 2){
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    cout << smalll << " " << bigg << endl;
    return 0;
}
```


---

## 作者：封禁用户 (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P9240)
# 思路
首先我们记录每次的 $V$ 的最大值和最小值。其中我们可以得出 $V$ 的最大值是 $\lfloor \frac{a}{b} \rfloor$,最小值为 $\lfloor \frac{a}{b+1} \rfloor+1$。之后我们求出所有 $V$ 中的的最大值和所有 $V$ 中的最小值再输出即可。
# Python code：
```python
import math #注意使用floor时要导入math库
n = int(input())
maxn = float('inf')
minn = 0
for i in range(n):
    a, b = map(int, input().split())
    minn = max(minn, math.floor(a/(b+1))+1)
    maxn = min(maxn, math.floor(a/b))
print(minn, maxn)
```



---

## 作者：sherry_lover (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P9240)

本题考点：数学。


------------
### 思路
其实题目就是叫我们求：求一个数 $V$，对于每一对输入的 $(a,b)$，都满足 $\left\lfloor\dfrac{a}{V}\right\rfloor = b$ 的 $V_{min}$ 和 $V_{max}$。

1.我们可以先记录对于第 $i$ 对输入的 $(a_i,b_i)$，满足 $\left\lfloor\dfrac{a_i}{V_i}\right\rfloor = b_i$ 的 $V_{i _{min}}$ 和 $V_{i _{max}}$。

我们可以通过分析得到：

$V_{i _{min}} = \left\lfloor\dfrac{a_i}{b_i}\right\rfloor$，$V_{i _{max}} = \left\lfloor\dfrac{a_i}{b_i+1}\right\rfloor+1$。

2.接下来，求所有记录的交集。找出所有记录中的 $V_{i _{max}}$ 的**最小值作为答案的最大值**。把所有记录中的最小 $V_{i _{min}}$ 的**最大值作为答案的最小值**（这里我调了很久）。

3.输出结果。

### 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,maxn = 0x3f3f3f3f,minn;
int main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> a >> b;
		minn = max(minn,int(floor(a*1.0/(b+1)))+1);
		maxn = min(maxn,int(floor(a*1.0/b)));
	}
	cout << minn << " " << maxn;
	return 0;
}

```

---


# [蓝桥杯 2023 国 B] 子 2023 / 双子数

## 题目描述

## A 子 2023

小蓝在黑板上连续写下从 $1$ 到 $2023$ 之间所有的整数，得到了一个数字序列：

$$S = 12345678910111213\cdots 20222023$$

小蓝想知道 $S$ 中有多少种子序列恰好等于 $2023$？

提示，以下是 $3$ 种满足条件的子序列（用中括号标识出的数字是子序列包含的数字）：

$$1[\textbf2]34567891[\textbf0]111[\textbf2]1[\textbf3]14151617181920212223 \cdots$$

$$1[\textbf2]34567891[\textbf0]111[\textbf2]131415161718192021222[\textbf3] \cdots$$

$$1[\textbf2]34567891[\textbf0]111213141516171819[\textbf2]021222[\textbf3] \cdots$$

注意以下是不满足条件的子序列，虽然包含了 $2$、$0$、$2$、$3$ 四个数字，但是顺序不对：

$$1[\textbf2]345678910111[\textbf2]131415161718192[\textbf0]21222[\textbf3] \cdots$$

## B 双子数

若一个正整数 $x$ 可以被表示为 $p^2 \times q^2$，其中 $p$、$q$ 为质数且 $p \neq q$，则 $x$ 是
一个 “双子数”。请计算区间 $[2333, 23333333333333]$ 内有多少个 “双子数”？

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 A、B 题

# 题解

## 作者：zhlzt (赞：33)

### 第一题 DP 做法
其实第一题并不难，我们设在 $s$ 的截止到当前位置的前缀字符串中，为 $2,20,202,2023$ 的子序列分别有 $dp_{0},dp_{1},dp_{2},dp_{3}$ 个，那么不难推出，$dp_{0},dp_{1},dp_{2},dp_{3}$ 要用以下规则更新：
- 若当前数字为 $2$，可以单独作一个子序列，即 $dp_{0}\gets dp_{0}+1$，也可以接在子序列 $20$ 之后构成 $202$，即 $dp_{2}\gets dp_{2}+dp_{1}$。
- 若当前数字为 $0$，可以接在子序列 $2$ 之后构成 $20$，即 $dp_{1}\gets dp_{1}+dp_{0}$。
- 若当前数字为 $3$，可以接在子序列 $202$ 之后构成 $2023$，即 $dp_{3}\gets dp_{3}+dp_{2}$。

最后答案就是为 $2023$ 的子序列的数量 $dp_{3}$。
### 第二题埃氏筛与暴力枚举做法
第二题更水，直接埃氏筛求素数，再暴力枚举 $p,q$，剪枝优化即可，具体见代码注释。

需要注意的是，由于 $p,q$ 的平方都不超过 $23333333333333$，所以这里埃氏筛只需要筛到 $\sqrt{23333333333333}$，约 $5\times 10^6$，其实还可以再缩小，因为 $p,q$ 中较小的数的平方至少为 $4$（值为 $2$ 时取到），此时另一个数最多还不到 $2.5\times10^6$，开个 $3\times 10^6$ 就已经够保险了。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6;
long long dp[5]; string s;
int isprime[N+10],prime[N+10];  
int main(){
	if(getchar()=='A'){
		for(int i=1;i<=2023;i++) s+=to_string(i);
		// to_string(i) 是将 i 变为字符串
		// s+=t 代表将字符串 t 添加到 s 末尾 
		for(int i=0;i<s.size();i++){
			if(s[i]=='2') dp[0]++,dp[2]=dp[2]+dp[1];
			else if(s[i]=='0') dp[1]=dp[1]+dp[0];
			else if(s[i]=='3') dp[3]=dp[3]+dp[2];
		}
		printf("%lld",dp[3]);
	}
	else{ 
		int cnt=0,ans=0;
		for(int i=2;i<=sqrt(N);i++){
			if(!isprime[i]){
				for(int j=i*i;j<=N;j+=i) isprime[j]=1;
			}
		}
		for(int i=2;i<=N;i++){ 
			if(!isprime[i]) prime[++cnt]=i;
		}
		for(int i=1;i<=cnt;i++){
			long long p2=1LL*prime[i]*prime[i];
			if(1LL*p2*p2>23333333333333) break;
			for(int j=i+1;j<=cnt;j++){
				long long q2=1LL*prime[j]*prime[j];
				if(1LL*p2*q2<2333) continue;
				// p*p*q*q 太小，不能更新答案 
				if(1LL*p2*q2>23333333333333) break; 
				ans++;
			}
		}
		printf("%d",ans); 
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：20)

## A 题

## 简单 DP

### solution:

当遇到字符 $\texttt{2}$ 的时候字符串 $\texttt{2}$ 的数量  $+1$，字符串 $\texttt{202}$ 的数量加上字符串 $\texttt{20}$ 的数量。

当遇到字符 $\texttt{0}$ 的时候字符串 $\texttt{20}$ 的数量加上字符串 $\texttt{2}$ 的数量。

当遇到字符 $\texttt{3}$ 的时候字符串 $\texttt{2023}$ 的数量加上字符串 $\texttt{202}$ 的数量。

最后，字符串 $\texttt{2023}$ 的数量就是答案。

code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int dp[4]={0};//分别代表"2"、"20"、"202"、"2023"的数量
	string s;
	for(int i=1;i<=2023;i++){//构造string 
		s+=to_string(i);
	} 
	for(int i=0;i<s.size();i++){//构造string 
		if(s[i]=='2'){
			dp[0]++;
			dp[2]+=dp[1];
		}else if(s[i]=='0'){
			dp[1]+=dp[0];
		}else if(s[i]=='3'){
			dp[3]+=dp[2];
		}
	} 
	cout<<dp[3]<<endl;
}

```

运行后发现答案为 $5484660609$，记一下。

## B 题

## 埃氏筛+暴力枚举

### solution：

先筛出 $10 ^ {7}$ 内的素数，求出之后暴力枚举两个数即可。

code：

```cpp
#include<bits/stdc++.h>
#define int __int128 //用__int128稳一点 
using namespace std;
int f[10000010]={1,1};
vector<int> v;
signed main(){
	for(int i=2;i<=10000010;i++){//欧拉筛求素数 
		if(f[i]==0){//如果没被标记过，那么i是质数 
			v.push_back(i);
		}
		for(int j=0;j<v.size()&&v[j]*i<=10000010;j++){
			f[v[j]*i]=1;//标记以i为最大因数的数为不是素数（除了1和本身）
			if(i%v[j]==0){//如果p[j]是i的因数，那么后面的数都不是以i为最大因数的 
				break;
			}
		}
	}
	
	long long ans=0; 
	for(int i=0;i<v.size();i++){
		for(int j=i+1;j<v.size();j++){
			if(v[i]*v[i]*v[j]*v[j]<2333)continue;//小于那就不要，继续 
			if(v[i]*v[i]*v[j]*v[j]>23333333333333)break;//大于直接退出 
			ans++;
		}
	}
	cout<<ans<<endl; 
} 

```

运行发现答案为 $947293$，记下来。

## 最终代码：

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans[2] = {
        "5484660609",
        "947293", 
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

完结撒花！


---

## 作者：_Cppsteve_ (赞：7)

抢一波题解。

$\colorbox{#F39C11}{\color{#FFFFFF}\small\texttt{提交答案}}$ 题显然时空限制会宽很多，但是也不是打表的意思。

------------

### A 子 2023

考虑使用动态规划。

用 $a,b,c,d$ 表示子串 $2,20,202,2023$ 的出现个数。

那么对于数字序列 $S$ 的每一个字符 $S_i$，  
如果 $S_i=0$，那么 $S_i$ 可以连在**每个** $2$ 后面形成一个新的 $20$，$b \gets b+a$；  
如果 $S_i=2$，那么 $S_i$ 既可以单独作为一个子串，也可以连在**每个** $20$ 后面形成一个新的 $202$，$a \gets a+1$，$c \gets c+b$；  
如果 $S_i=3$，那么 $S_i$ 可以连在**每个** $202$ 后面形成一个新的 $2023$，$d \gets d+c$。

最后求子串 $2023$ 的个数，也就是 $d$。

另外，十年 OI 一场空，不开 `long long` 见祖宗。

这道题不用 `long long` 用 `int` 最后得出的结果也是正数，要小心了。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,c,d;//a:2,b:20,c:202,d:2023
string str;
int lenstr;
int main()
{
    for(int i=1;i<=2023;i++){
        str+=to_string(i);
    }
    lenstr=str.size();
    for(int i=0;i<lenstr;i++){
        if(str[i]=='2'){
            a+=1;
            c+=b;
        }
        else if(str[i]=='0'){
            b+=a;
        }
        else if(str[i]=='3'){
            d+=c;
        }
    }
    cout<<d<<endl;
    return 0;
}

```

答案为 $5484660609$。

注：`to_string()` 函数包含在 `<string>` 头文件中，在 `C++11` 加入。

------------

### B 双子数

[埃氏筛筛至平方根](https://oi-wiki.org/math/number-theory/sieve/#%E7%AD%9B%E8%87%B3%E5%B9%B3%E6%96%B9%E6%A0%B9 "OI Wiki")，然后暴力枚举 $p,q$ 即可。

素数筛有很多种。选用埃氏筛而不是线性筛（欧拉筛）的原因是埃氏筛写起来方便，而且本题对时空限制不大。（你甚至可以让程序跑个一天一夜，但是调试就很...）

![](https://gcore.jsdelivr.net/gh/SteveTaizhou/steve-imgbed@main/img/20230701103802.png)

$\sqrt{23333333333333} \approx 4830459$

因此保险起见筛到 $5 \times 10^6$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e6+100;
bool is_prime[N+10];
int vec[N+10];
int indvec=0;
int ans=0;
void Erato_long_name()
{
    for(int i=2;i<=sqrt(N);i++){
        if(!is_prime[i]){
            for(int j=i*i;j<=N;j+=i){
                is_prime[j]=1;
            }
        }
    }
}
int main()
{
    Erato_long_name();
    for(int i=2;i<=N;i++){
        if(!is_prime[i]){
            vec[indvec++]=i;
        }
    }
    for(int i=0;i<indvec;i++){//枚举p
        if(1ll*vec[i]*vec[i]*vec[i]*vec[i]>23333333333333){//当p^4都爆时，p^2*q^2肯定要爆
            break;
        }
        for(int j=i+1;j<indvec;j++){//枚举q
            if(1ll*vec[i]*vec[i]*vec[j]*vec[j]<2333){//太小了
                continue;//往后枚举
            }
            else if(1ll*vec[i]*vec[i]*vec[j]*vec[j]>23333333333333){//爆炸
                break;//剪枝
            }
            ans++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

答案为 $947293$。

------------

按照模板提交：

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "5484660609",
        "947293"
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}


```




---

## 作者：Vct14 (赞：4)

这是一道填空问题。

### 子 $2023$

设 $a$ 为已经出现的子串 $2023$ 的数量，$b$ 为 $202$ 的数量，$c$ 为 $20$ 的数量，$d$ 为 $2$ 的数量。

若当前数字为 $2$，则要更新 $2$ 的数量和 $202$ 的数量。$2$ 的数量直接加 $1$，即 $d\gets d+1$；而现在有多少个 $20$，就可以多出多少个 $202$，所以 $b\gets b+c$。

若当前数字为 $0$，则要更新 $20$ 的数量。现在有多少个 $2$，就可以多出多少个 $20$，所以 $c\gets c+d$。

若当前数字为 $3$，则可以更新 $2023$ 的数量。现在有多少个 $202$，就可以多出多少个 $2023$，所以 $a\gets a+b$。

最后的答案就是 $2023$ 的数量 $a$。

对于构造初始数字序列，可以使用 `to_string` 把一个数字变为字符串，然后插到 $S$ 结尾。

```c++
#include<bits/stdc++.h>
using namespace std;

string S;
long long a,b,c,d,s;

void init(){
	for(int i=1; i<=2023; i++) S+=to_string(i);
	s=S.size();
}

int main(){
	init();
	for(int i=0; i<s; i++){
		if(S[i]=='2') d++,b+=c;
		else if(S[i]=='0') c+=d;
		else if(S[i]=='3') a+=b;
	} 
	cout<<a;
	return 0;
}
```

答案为 $5484660609$。

### 双子数

可以先用欧拉筛筛出 $10^7$ 以内的素数（其实可以优化到 $5\times10^6$，但因为是填空题，保险起见），然后再暴力枚举 $p$ 和 $q$ 即可。暴力枚举时，如果乘积小于 $2333$，就可以直接跳过；如果成绩已经大于 $23333333333333$ 了，就可以直接退出。

```c++
#include<bits/stdc++.h>
#define int __int128 
using namespace std;

bool vis[10000000]={1,1};
vector<int> v;

signed main(){
	for(int i=2; i<=10000000; i++){//欧拉筛 
		if(!vis[i]) v.push_back(i);
		for(int j=0; j<v.size() && v[j]*i<=10000000; j++){
			vis[v[j]*i]=true;
			if(!(i%v[j])) break;
		}
	}
	long long ans=0; 
	for(int i=0; i<v.size(); i++){
		for(int j=i+1; j<v.size(); j++){
			if(v[i]*v[i]*v[j]*v[j]<2333) continue;
			if(v[i]*v[i]*v[j]*v[j]>23333333333333) break;
			ans++;
		}
	}
	cout<<ans;
	return 0; 
} 
```

答案为 $947293$。


------------

使用模板输出。

```c++
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "5484660609",
        "947293"
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}

```

---

## 作者：Tjaweiof (赞：4)

# P9420 题解——Tjaweiof
## 第一道题：子 2023
因为是提交答案题，可以在本地运行，不限制时间，所以一上来直接暴力枚举每一个 $2023$。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[10000], tot = 0, ans = 0;
int main(){
	for (int i = 1; i <= 9; i++){
		a[++tot] = i;
	}
	for (int i = 10; i <= 99; i++){
		a[++tot] = i / 10;
		a[++tot] = i % 10;
	}
	for (int i = 100; i <= 999; i++){
		a[++tot] = i / 100;
		a[++tot] = i / 10 % 10;
		a[++tot] = i % 10;
	}
	for (int i = 1000; i <= 2023; i++){
		a[++tot] = i / 1000;
		a[++tot] = i / 100 % 10;
		a[++tot] = i / 10 % 10;
		a[++tot] = i % 10;
	}
	for (long long i = 1; i <= tot; i++){
		if (a[i] == 2){
			for (long long j = i + 1; j <= tot; j++){
				if (a[j] == 0){
					for (long long k = j + 1; k <= tot; k++){
						if (a[k] == 2){
							for (long long l = k + 1; l <= tot; l++){
								if (a[l] == 3){
									ans++;
								}
							}
						}
					}
				}
			}
		}
	}
	printf("%lld", ans);
	return 0;
}

```
### 输出：
```
5484660609
```
~~这个数字看似平平无奇，但背后却有着很大的历史背景。~~

接下来展示我的 **运行时间**：
```
--------------------------------
Process exited after 73.13 seconds with return value 0
请按任意键继续. . .
```
咳咳，别太惊讶了，还有一道题呢。
## 双子数
还是一样，暴力枚举每一个双子数……是不对的，因为上面的代码是建立在你有耐心的基础上的，我用计算器算了一下，需要操作 $11,666,659,829,653$ 次，换算成天大约就是 $13.50307850654282407407407407407……$，所以我们启用线性筛：
```
#include <bits/stdc++.h>
using namespace std;
const int s = sqrt(23333333333333);
int ans = 0;
bitset<s> prime;
vector<int> lprime;
int main(){
    for (int i = 2; i <= s; i++){
        if (!prime[i]){
            lprime.push_back(i);
        }
        for (int j = 0; j < s && i * lprime[j] < s; j++){
            prime[i * lprime[j]] = 1;
            if (i % lprime[j] == 0) break;
        }
    }
    for (int i = 0; i < lprime.size(); i++){
        for (int j = i + 1; j < lprime.size(); j++) {
            double tmp = (__int128)lprime[i] * lprime[i] * lprime[j] * lprime[j];
            if (tmp < 2333){
            	continue;
			} else if (tmp > 23333333333333){
				break;
			} else {
				ans++;
			}
        }
    }
    cout << ans;
    return 0;
}

```
最后的答案为：$947293$。最后在洛谷上提交。
## Code
```
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "5484660609", // 双引号中替换为 A 题的答案
        "947293", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---

## 作者：wangbinfeng (赞：2)

1. 题目：[P9420 [蓝桥杯 2023 国 B] 子 2023 / 双子数](https://www.luogu.com.cn/problem/P9420)  
2. 答案：
> A 子 2023：`5484660609`  
> B 双子数3：`947293`
3. 代码： 见下

$\tiny{\text{这里采用倒叙的方法，能增强文章的生动性，使文章产生悬念，更能引人入胜，同时也可以避免叙述的平板和结构的单调。}}$

------------

由于这是两道题目，故分别讲解。

## A. `子 2023`：
由于是提交答案题，故容易想到打表。  
先求出字符串 $S$，代码见下。   
然后求出 $2023$ 这个数的个数。这里可以使用**动态规划**。 
设 $dp_0$ 为以 $2$ 开头的子序列，同理 $dp_1$ 为以 $20$ 开头的子序列， $dp_2$ 为以 $202$ 开头的子序列， $dp_3$ 为以 $2023$ 开头的子序列。  
注意一下 $2$ 既可以是以 $2$ 开头的子序列，也可以是以 $202$ 开头的子序列。  
代码如下：
```cpp
int main(){
	for(int i=1;i<=2023;i++)s+=to_string(i);
	len=s.size();
	for(int i=0;i<len;i++){
		if(s[i]=='2')dp[0]++,dp[2]+=dp[1];
		else if(s[i]=='0')dp[1]+=dp[0];
		else if(s[i]=='3')dp[3]+=dp[2];
	}
	cout<<dp[3];
	return 0;
}
```

## B `双子数`：
和上一题一样，不难想到打表。
因为 $p$ 和 $q$ 都是质数，不难想到打表求所有质数。  
但是求多少以内的质数呢？如果是最大值 $23333333333333$ 且电脑不是特别好，就会喜提 `Error: value of ***** too large for field of 4 bytes at *****`，因为数组开太大。  
其实范围也不难求， $\sqrt{\frac{23333333333333}{2}}$ 比最大的质数小一点（小多少我也不知道），那就再开大一点就好。  
然后就暴力求可能结果，如果枚举的素数 $p$ 和 $q$ 在最小值 $2333$ 和最大值 $23333333333333$ 之间则答案 $ans$ 加一。注意 $p \ne q$。  
代码如下：
```cpp
//别忘记开__int128，如果本机不支持可以用洛谷在线IDE：https://www.luogu.com.cn/ide
int main(){
	for(__int128 i=2;i<=maxn;i++)for(__int128 j=i+i;j<=maxn;j+=i)
		if(!imprime[j])imprime[j]=true;
	for(__int128 i=2;i<=maxn;i++)if(!imprime[i])dat[top++]=i;
	for(__int128 i=0;i<top;i++)for(__int128 j=i+1;j<top;j++)
		if(dat[i]*dat[i]*dat[j]*dat[j]>23333333333333)break;
		else if(dat[i]*dat[i]*dat[j]*dat[j]>minn)ans++;
	write(ans);
	return 0;
}
```

------------
以上都是解析及打表代码，别直接抄。下面才是提交的答案。
1. 方法一：

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "5484660609",
        "947293"
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

2. 方法二：由于洛谷IDE速度非常快，所以我们未加任何优化的打表也能通过本题，所以可以直接将两个打表程序二合一再直接提交。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long len,dp[4];
const __int128 maxn=3415659,minn=2333;
bool imprime[maxn+100];//imprime[i]=false为质数
__int128 top,dat[maxn],ans;
inline void write(__int128 x){
     if(x<0)putchar('-'),x=-x;
     if(x>9)write(x/10);
     putchar(x%10+'0');
}
int mainA(){
	for(int i=1;i<=2023;i++)s+=to_string(i);
	len=s.size();
	for(int i=0;i<len;i++){
		if(s[i]=='2')dp[0]++,dp[2]+=dp[1];
		else if(s[i]=='0')dp[1]+=dp[0];
		else if(s[i]=='3')dp[3]+=dp[2];
	}
	cout<<dp[3];
	return 0;
}
int mainB(){
	for(__int128 i=2;i<=maxn;i++)for(__int128 j=i+i;j<=maxn;j+=i)
		if(!imprime[j])imprime[j]=true;
	for(__int128 i=2;i<=maxn;i++)if(!imprime[i])dat[top++]=i;
	for(__int128 i=0;i<top;i++)for(__int128 j=i+1;j<top;j++)
		if(dat[i]*dat[i]*dat[j]*dat[j]>23333333333333)break;
		else if(dat[i]*dat[i]*dat[j]*dat[j]>minn)ans++;
	write(ans);
	return 0;
}
int main(){
    char c=getchar();
    if(c=='A')mainA();
    else mainB();
	return 0;
}

//最后温馨提醒一下：两篇代码均能满分通过且没有加入任何反作弊，提交前请选择高版本C++语言。请不要直接复制我的代码并且在评论区质问我代码为什么过不去，谢谢！
```

最后说一句：由于中考，一年来第一次登陆洛谷并一年来第一次提交题解，可能忘记一些注意事项，望谅解。

---


# [蓝桥杯 2023 国 B] 班级活动

## 题目描述

小明的老师准备组织一次班级活动。班上一共有 $n$ 名（$n$ 为偶数）同学，老师想把所有的同学进行分组，每两名同学一组。为了公平，老师给每名同学随机分配了一个 $n$ 以内的正整数作为 id，第 $i$ 名同学的 id 为 $a_i$。

老师希望通过更改若干名同学的 id 使得对于任意一名同学 $i$，有且仅有另一名同学 $j$ 的 id 与其相同（$a_i = a_j$）。请问老师最少需要更改多少名同学的 id？

## 说明/提示

### 样例说明

仅需要把 $a_1$ 改为 $3$ 或者把 $a_4$ 改为 $1$ 即可。

### 评测用例规模与约定

- 对于 $20\%$ 的数据，保证 $n \le 10^3$。
- 对于 $100\%$ 的数据，保证 $n \le 10^5$。

第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 C 题

## 样例 #1

### 输入

```
4
1 2 2 3```

### 输出

```
1```

# 题解

## 作者：_Gabriel_ (赞：18)

### 思路

先把每个 $id$ 的人数统计好，然后 $id$ 的数量有两种情况：

- $id$ 数比二小。
- $id$ 数大于等于二。

把 $id$ 大于等于二的学生数减二用 $sum1$ 累加，$id$ 小于二的学生数用 $sum2$ 累加。

如果 $sum1>sum2$，则只要把 $id$ 相同且人数大于等于二的人的 $id$ 改掉即可，即输出 $sum1$。

如果 $sum1 \le sum2$，则把 $id$ 相同的人改掉后剩下的不符合题意，应把一半 $id$ 人数为一的改掉。即输出 $sum1+\dfrac{sum2-sum1}{2}$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
typedef long long ll;

int a[N], cnt[N];
int n;
int sum1 = 0, sum2 = 0;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		cnt[a[i]]++;
	}
	for (int i = 1; i <= 1e6; i++) {
		if (cnt[i] >= 2) {
			sum1 += (cnt[i] - 2);
		} else {
			sum2 += cnt[i];
		}
	}
	if (sum1 > sum2) {
		cout << sum1 << "\n";
	} else {
		cout << sum1 + (sum2 - sum1) / 2 << "\n";
	}
    return 0;
}
```


---

## 作者：binomial (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P9421)

# $1.$ 题意
给定一个数列，求最少变化多少个数可以使每个数有且只有一个数和他相等。
# $2.$ 思路
由题目可以想到，我们可以将数列中的数大致分为三种：
### $1.$ 刚好有两个学号相同
这种情况不做改变即可符合题意。
### $2.$ 有大于两个学号相同
这种情况需要将多的改变为其他学号。
### $3.$ 只有一个学号
这种情况需要有多的学号转化成该学号或把该学号转化成另一个只有一个的学号。


------------

那么，他们对答案的贡献分别是：

情况 $1$：无。

情况 $2$：$ ans \leftarrow$ 数量 $ - 2$。

情况 $3$：若有多的学号转化成该学号，那么无，否则 $ ans \leftarrow ans+1$。

根据以上情况，设情况 $2$ 有 $d$ 种，情况 $3$ 有 $ss$ 种，那么如果 $ss>d$，则结果为 $(ss-d)/2+d$，否则结果为 $(d-ss)+ss$。
# $3.$ 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//好习惯防见祖宗
int n,s,t[100001],ans=0,d=0,ss=0;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		t[s]++;//桶来储存每个学号出现情况
	}
	for(int i=1;i<=n;i++){
		if(t[i]>2){
			d+=t[i]-2;//情况2
		}
		if(t[i]!=0&&t[i]<2){
			ss+=2-t[i];//情况3
		}
	}
	if(d>=ss){//情况2、3抵消（就是2多的转到3少的）
		ans+=ss;
		d-=ss;
		ss=0;
	}
	else{
		ans+=d;
		ss-=d;
		d=0;
	}
	cout<<ans+d+ss/2;//加上剩余，ss/2的原因是两个差1的只需要变一次即可
	return 0;
} 
```

---

## 作者：Red0rangE (赞：3)

## 题意理解

有 $n$ 个整数，表示序号，要使每个序号只对应两个人或不对应人，求最小改变序号的个数。

## 思路阐述

将出现次数超过两次的加入 $cnt1$，表示多出来的；只出现一次的加入 $cnt2$，表示可以补入的。

当最后统计结果 $cnt1=cnt2$ 时，多出来的数正好可以补入，所以直接输出 $cnt1$ 即可。

当 $cnt1>cnt2$ 时，先把 $cnt2$ 个数按照之前的方式补回去，剩下 $cnt1-cnt2$ 个数字自己成对，因为是多出来的，所以这些数字已经有两个数字组队占用，所以两两改成未出现过的数，加上 $cnt1-cnt2$。答案为 $cnt2+(cnt1-cnt2)$，化简一下就是 $cnt1$。

当 $cnt1<cnt2$ 时，先把 $cnt1$ 个数按照之前的方式补回去，剩下 $cnt2-cnt1$ 个数字自己成对，两两改成一样的数，这些数都只出现了一次，所以两两组队更改其中一个即可，加上 $(cnt2-cnt1)\div2$。答案为 $cnt1+(cnt2-cnt1)\div2$，化简一下就是 $(cnt2+cnt1)\div2$。

观察整理发现不论什么情况答案均为 $\max(cnt2-cnt1,0)\div2+cnt1$。

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int x;
int cnt1,cnt2;
map <int,int> q;//记录序号个数

signed main(){
    
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        q[x]++;//序号个数加
    }
    for (int i=1;i<=n;i++){//记录cnt1和cnt2
        if (q[i]>2) cnt1+=q[i]-2;
        if (q[i]==1) cnt2++;
    }
    printf("%d",max(cnt2-cnt1,0)/2+cnt1);
    return 0;
    
}
```


希望可以帮到各位大佬。

---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P9421 [蓝桥杯 2023 国 B] 班级活动](https://www.luogu.com.cn/problem/P9421)

## 题意简述

每次修改 $1$ 个元素，求序列中刚好每 $2$ 个元素相同的最小操作次数。

## 解题思路

1. 对于每个元素 $i$ 的出现次数 $a_i$，分类讨论：

- 若 $a_i=2$，不用修改。
- 若 $a_i=1$，可以直接修改其他元素，也可以把其他元素修改为 $i$。
- 若 $a_i>2$，修改多余的 $a_i-2$ 个元素，且优先修改成其他 $a_j=1$ 的元素。

2. 代码实现：

- 读入 $t$，记录每个数出现的次数 $a_i$；
- 枚举所有的 $a_i$：

$$
\begin{cases}
  s_1\gets s_1+1 & a_i=1 \\
  s_2\gets s_2+(a_i-2) & a_i>2
\end{cases}
$$

- 如果 $s_2\ge s_1$，说明有足够 $a_i>2$ 的元素可以给 $a_i=1$ 的元素；
- 否则，还要修改 $s1-s2$ 个 $a_i=1$ 的元素，每 $2$ 个一组，要修改 $\frac{s1-s2}{2}$ 个元素。

3. 因此，最终答案为 $s2+\frac{\max(s1-s2,0)}{2}$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100005;
int a[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int t;
		cin>>t;
		a[t]++;
	}
	int s1=0,s2=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==1)
		{
			s1+=1;
		}
		else if(a[i]>2)
		{
			s2+=a[i]-2;
		}
	}
	cout<<s2+max(s1-s2,0)/2<<'\n';
	return 0;
}
```

---

## 作者：xiaoming007 (赞：2)

## 思路

先统计每个组的人员数，然后对于本题，要更改 ID 的有两个情况：

- $a_i$ 的数量不满 $2$  
- $a_i$ 的数量多于 $2$

对于每种情况分别记录数量，其中，如果 $a_i$ 数量多于 $2$ 的情况数量较为多的话，那么把其中一部分的 ID 修改为 $a_i$ 数量不满 $2$ 的 ID，余下的则“自成一派”，改成一个新的，总消耗为 $a_i$ 数量多于 $2$ 的的个数。  
如果 $a_i$ 数量小于 $2$ 的情况多的话，那么就让 $a_i$ 的数量多于 $2$ 的归到等量的小于 $2$ 的情况，剩下的取一半保留一半“投靠”，总消耗为两种情况总和 $\div 2$。

## 代码

```cpp
//Author:Saint_ying_xtf = xiaoming007
#include <iostream>
#include <map>
std::map<int, int> mp;
int a[101001];
int main(){
	int n;
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		mp[a[i]]++;
	}
	int dwd = 0, pwp = 0;// dwd 负责统计“原本编号个数已经大于 2” 的个数，pwp 统计小于 2 
	for(int i = 1; i <= n; ++i) {
		if(mp[a[i]] != 0){
			if(mp[a[i]] > 2){
				dwd += mp[a[i]] - 2;
			}else{
				pwp += 2 - mp[a[i]];
			}
			mp[a[i]] = 0; 
		}
	}
	//printf("%d\n", std::max(dwd, (pwp + 1) / 2));
	printf("%d\n", dwd > pwp ? dwd : (pwp + dwd) / 2);
	// 如果 dwd 大，那么肯定换 dwd 个， (dwd + pwp) / 2 是因为当 pwp 多的情况下，仅需换总和 / 2 次。 
	return 0;
}
```

---

## 作者：wangbinfeng (赞：1)

这题读懂题就不难了。  

由于每两个 $id$ 相同的同学一组，那么第三个、第四个及更多 $id$ 相同的同学就必须全部改变 $id$。 

如果一个  $id$ 只有一个人享有（即没有相同 $id$），那么必须将这个人的 $id$ 改走或将其他人的 $id$ 改成这个 $id$。

将相同 $id$ 的人数大于二的学生个数减二的和 $ans_1$ 和没有相同 $id$ 的学生数量之和 $ans_2$ 分别求出。

若 $ans_1>ans_2$ 则证明把**所有** _具有相同 $id$ 且多于两人的人_ 的 $id$ 全部改掉即可满足题意，输出 $ans_1$。否则证明改掉相同 $id$ 的学生后还有剩余学生无法满足题意，应将**一半** _没有搭档的学生_ 的 $id$ 改掉，即输出 $ans_1+\frac{ans_2-ans_1}{2}$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100009],num[100009],ans1,ans2;
inline long long read(){
    char c;
    long long ret=0,f=1;
    for(c=getchar();c<'0'||c>'9';c=getchar())if(c=='-')f=-f;
    for(;c>='0'&&c<='9';c=getchar())ret=ret*10+c-'0';
    return ret*f;
}
int main(){
    n=read();
    while(n--)num[read()]++;//统计各id的人数
    for(int i=1;i<=100000;i++)
		if(num[i]>=2)ans1+=num[i]-2;
		else ans2+=num[i];
	if(ans1>=ans2)cout<<ans1;
	else cout<<ans1+(ans2-ans1)/2;
}

```

---

## 作者：LiJoQiao (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P9421) [评测记录](https://www.luogu.com.cn/record/113223198)  
读题知，有 $n$ 个小朋友，需要将落单的小朋友和 $id$ 已经有两人使用的小朋友（后文简称 $id$ 溢出的小朋友）的 $id$ 修改，使得每个小朋友使用的 $id$ 只有两个人使用。  
更抽象点，就是 $n$ 个数需要修改后每个数有且只有一个数与其相等，输出修改次数。

进行分类讨论。  
- 如果有两个小朋友的 $id$ 已经满足相等且没有其他小朋友的 $id$ 与其相等的话，我们只需跳过不用修改。  

-  $id$ 溢出的小朋友该怎么办？那三个及以上的人必须有人修改，使得 $id$ 的使用人数变为 2，我们先将其记录下来。  

-  $id$ 仅自己用的小朋友也有两种情况。
>1.其他小朋友修改与其配对。  
>2.该小朋友进行修改，与其他小朋友配对。  

因为 $id$ 溢出的小朋友必须修改，我们先让该小朋友的 $id$ 与落单的小朋友配对，然后又有三种情况。

- 配对后无落单的小朋友，也无 $id$ 溢出的小朋友，无需多加修改。

- 配对后只剩下落单的小朋友，此时每两个小朋友只需其中一个小朋友修改使得两个小朋友配对即可。

- 配对后只剩下 $id$ 溢出的小朋友，因为这两个小朋友的 $id$ 必须修改使得与原 $id$ 不同，所以输出结果直接加上 $id$ 溢出的小朋友的数量即可。

经过上述操作后，每个小朋友有且只有一个小朋友的 $id$ 与其 $id$ 相等。进行输出结果。

代码如下。
```cpp
#include<iostream>
using namespace std;
const int MAXN=100010;
int bucket[MAXN],ans,oneid,outid;
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//一串优化
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)//输入n个小朋友的id
    {
        int temp;
        cin>>temp;
        if(bucket[temp]==0)
        {
            bucket[temp]++;
            oneid++;//落单的小朋友
        }
        else if(bucket[temp]==1)
        {
            bucket[temp]++;
            oneid--;//此时有一位小朋友id与某位小朋友相同，原本落单的小朋友-1
        }
        else
        {
            outid++;//这个小朋友的id已经有两个人用了，该小朋友只能修改自己的id
        }
    }
    //先让id溢出的小朋友与落单的小朋友id相同
    int pd=min(oneid,outid);//分两种情况，一种是落单的多，一种是id溢出的多，取其中最小值得到落单和id溢出配对的数量
    ans+=pd;//配对时只需id被用过的小朋友修改
    oneid-=pd;//配对后落单小朋友数量减少
    outid-=pd;//配对后id溢出的小朋友数量减少
    //剩下的两种情况
    if(oneid)//只剩下落单的
    {
        ans+=oneid/2;//落单的小朋友只有一个修改即可
        //oneid=0;//此处不必写入这句代码，只是为了方便读者理解
        //两个落单的小朋友修改后数量为0，修改结束
    }
    if(outid)//只剩下id溢出的小朋友
    {
        ans+=outid;//由于都是溢出的小朋友，都需要修改
        //outid=0;//此处不必写入这句代码，只是为了方便读者理解
        //id溢出的小朋友修改后数量为0，修改结束
    }
    cout<<ans;
    return 0;
}
```

---


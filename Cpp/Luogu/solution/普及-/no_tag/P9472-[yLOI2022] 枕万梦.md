# [yLOI2022] 枕万梦

## 题目背景

> 岁月冥冥之中 星移物换 将韶华歌颂  
> 人潮冥冥之中 一眼望穿 日月去无踪  
> 你我冥冥之中 心有灵犀 何止几万梦  
> 忘情在这久违的重逢  
> 天地冥冥之中 云烟奔涌 摩肩又接踵  
> 万籁冥冥之中 不肯缄默 盛大到无穷  
> 你我冥冥之中 对坐天涯 灵犀才一动  
> 就相遇在咫尺的时空

银临《枕万梦》

## 题目描述

天亮了，扶苏不敌困意，早早地进入了梦乡。在失去引力的梦里，扶苏遇到了好多串漂浮着的数列，它们的长度都相等，而且都是美妙的等比数列！出于本能，扶苏想要把这些数列按照字典序排序，可是在梦里扶苏失去了思考的能力，请你来帮帮她！

具体地，有 $n$ 个编号从 $1$ 到 $n$ 的数列 $a_1, a_2, \dots a_n$，每个数列的长度均为 $m + 1$。第 $i$ 个数列 $a_i$ 满足递推式 $a_{i,j} = a_{i,j - 1} \times i$，其中 $1 \leq j \leq m$。而扶苏会告诉你每个序列的首项 $a_{i,0}$，你需要帮助她把这些数列按字典序排序。

## 说明/提示

### 样例 1 解释

共有两个数列，每个数列的长度均为 $2+1=3$。

对第一个数列 $a_1$：
- 已知其首项 $a_{1,0} = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 1$ 可以得到 $a_{1,1} = a_{1,0} \times 1 = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 2$ 可以得到 $a_{1,2} = a_{1,1} \times 1= 1$。

所以数列 $a_1$ 是 $1,1,1$。

对第二个数列 $a_2$：
- 已知其首项 $a_{2,0} = 2$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 1$ 可以得到 $a_{2,1} = a_{2,0} \times 2 = 2 \times 2 = 4$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 2$ 可以得到 $a_{2,2} = a_{2,1} \times 2= 4 \times 2 = 8$。

所以数列 $a_2$ 是 $2,4,8$。

比较字典序可得数列 $a_1$ 是字典序最小的数列。所以输出 $1$。

### 样例 2 解释

数列 $a_1$ 为 $1,1,1,1$，数列 $a_2$ 为 $-1, -2,-4,-8$。

### 数据规模与约定
本题共 $10$ 个测试点，各测试点信息如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/08wnuome.png)

特殊约定 A：保证 $a_{i,0}$ 均相等。  
特殊约定 B：保证 $a_{i,0}$ 互不相等。

对全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 10^9$，$1 \leq |a_{i,0}| \leq 10^9$。


### 提示

对两个数列 $a_i, a_j$，按如下方式比较其字典序：

找到**最小的**满足 $a_{i,p} \neq a_{j, p}$ 的下标 $p$，比较 $a_{i, p}$ 和 $a_{j, p}$ 的大小：

- 如果 $a_{i,p} < a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的小。
- 如果 $a_{i,p} > a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的大。

可以证明，在本题的限制下，这样的 $p$ 一定存在。

## 样例 #1

### 输入

```
2 2
1
2```

### 输出

```
1 2```

## 样例 #2

### 输入

```
2 3
1
-1```

### 输出

```
2 1```

## 样例 #3

### 输入

```
2 2
1
1```

### 输出

```
1 2```

## 样例 #4

### 输入

```
见附加文件中的 B4.in```

### 输出

```
见附加文件中的 B4.ans```

# 题解

## 作者：cff_0102 (赞：12)

按照字典序的定义，对于第 $0$ 项不一样的情况，肯定是第 $0$ 项小的字典序就小，第 $0$ 项大的字典序就大。

如果第 $x,y$ 个数列的第 $0$ 项相同（设都是 $s$），那么它们的第 $1$ 项应该分别是 $x\times s$ 和 $y\times s$。$x$ 和 $y$ 不相等，所以这两个数列的第一项不同。此时通过第 $1$ 项就能给这两个数列排序。

所以，要按字典序排序，只需要知道一个序列的前两项。

排序时，先按两个序列的第 $0$ 项排序，如果相同，再按第 $1$ 项排序即可。

需要注意的是，一个序列的第一项可能超过 `int` 的表示范围，所以要开 `long long`。我在赛时就是因为没开 `long long`，$100pts\to40pts$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct arr{
	long long a0;//第 0 项
	long long a1;//第 1 项 
	long long n;//编号 / 公比
}a[114514];
bool cmp(arr x,arr y){
	if(x.a0!=y.a0)return x.a0<y.a0;
	else return x.a1<y.a1;
}//按字典序从小到大排序
int main(){
	ios::sync_with_stdio(false);
	long long n,m;cin>>n>>m;
	for(int i=1;i<=n;i++){
		a[i].n=i;//编号为 i 
		cin>>a[i].a0;//输入第 0 项 
		a[i].a1=a[i].a0*i;//计算第 1 项 
	}
	sort(a+1,a+1+n,cmp);//按字典序从小到大排序
	for(int i=1;i<=n;i++){//按字典序排序完成，直接按顺序输出编号 
		cout<<a[i].n<<" ";
	} 
	return 0;
}
```

---

## 作者：wangcht (赞：6)

题目要求我们把这些数列按字典序排序，那么我们看一下比较字典序的方式：

> 对两个数列 $a_i, a_j$，按如下方式比较其字典序：

> 找到**最小的**满足 $a_{i,p} \neq a_{j, p}$ 的下标 $p$，比较 $a_{i, p}$ 和 $a_{j, p}$ 的大小：

> - 如果 $a_{i,p} < a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的小。
> - 如果 $a_{i,p} > a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的大。

题目中还有一段描述：

> 第 $i$ 个数列 $a_i$ 满足递推式 $a_{i,j} = a_{i,j - 1} \times i$，其中 $1 \leq j \leq m$。

不难看出：

- 当首项不同时，直接比较首项。

- 当首项相同时，比较第二项。

如何比较第二项呢？

- 当首项为负数时，输入越靠后，第二项越小。

- 当首项为正数时，输入越靠前，第二项越小。

（这里如果没考虑负数，只能得七十分，~~别问我怎么知道的~~）。

那么我们可以写一个结构体存储首项及输入顺序，再写一个自定义比较函数进行排序。

代码如下：

```cpp
#include<bits/stdc++.h>//C++万能头文件
using namespace std;
struct node{//定义结构体
	int a,id;
}b[100010];
bool cmp(node x,node y){//自定义比较函数
	if (x.a!=y.a)	return x.a<y.a;
	if(x.a<0 && y.a<0)	return x.id>y.id;
	return x.id<y.id;
}int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i].a);
		b[i].id=i;
	}sort(b+1,b+n+1,cmp);//排序
	for(int i=1;i<=n;i++){
		printf("%d ",b[i].id);
	}return 0;
}
```

---

## 作者：1qaz234Q (赞：3)

### 题意简述
有 $n$ 个长度为 $m+1$ 的数列 $a_1,a_2,\dots a_n$。对于每个数列，给定第一个数，$a_i$ 满足 $a_{i,j} = a_{i,j - 1}\times i$。按照字典序排序这 $n$ 个数列，输出数列编号。
### 题目分析
先输入 $n$。然后循环 $n$ 次，输入 $a_{i,1}$。

因为是按照字典序排序，所以我们没必要计算出这个数列的每一个数，只需要求出前两个数即可。接着给这 $n$ 个数列排序，如果第一个数相同，则比较第二个数，否则比较第一个数。

最后输出数列的编号就可以了。

如果你使用 C++，那么要注意要开 `long long`。时间复杂度为 $O(n\log n)$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 10;
struct node
{
    int a1; // 数列的第一个数
    int a2; // 数列的第二个数
    int id; // 数列的编号
} a[N];
bool cmp(node x, node y)
{
    if (x.a1 == y.a1) // 如果这两个数列的第一个数相同
    {
        return x.a2 < y.a2; // 比较第二个数
    }
    return x.a1 < y.a1; // 比较第一个数，让第一个数较小的数列排在较大的前面
}
signed main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i].a1;
        a[i].a2 = a[i].a1 * i; // 计算第二个数
        a[i].id = i;           // 标记上数列的编号
    }
    sort(a + 1, a + n + 1, cmp); // 排序
    for (int i = 1; i <= n; i++)
    {
        cout << a[i].id << " ";
    }
}
```

---

## 作者：zhang_Jimmy (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P9472)

一道比较简单的题。

由于每个等比数列的比值不同，所以我们求出这个等比数列的第二项就行了，而不需要求出整个数列。

求出第一项和第二项之后，我们按照如下规则排序：

- 如果两个数的第一项一样，第二项小的排在前面。

- 否则，第一项小的排在前面。

可以用一个结构体存放这个数列的第一项、第二项和编号。

排完序后输出每个数列的编号就可以了。

记得开 `long long`。~~（我赛时没开 `long long` 差点丢掉60分，幸好后来改过来了）~~

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	long long l,r,rk;
}a[100010];
bool cmp(node x,node y)
{
	return x.l==y.l?x.r<y.r:x.l<y.l;
}
int n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
	{
		cin>>a[i].l;
		a[i].r=a[i].l*i;
		a[i].rk=i;
	} 
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) cout<<a[i].rk<<' ';
    return 0;
}
```


---

## 作者：信息向阳花木 (赞：3)

暴力枚举肯定不行。

思路很简单：

* 按照每个序列的首项 $a_{i,0}$ 排序
* 考虑任意两个不相同的序列编号 $i$，$j$（$1 \le i \le j \le n$）:
	* 若 $a_{i,0} \neq a_{j,0}$，则让首项小的排前面。
	* 若 $a_{i,0} = a_{j,0}$，则我们要考虑 $a_{i,0}$，$a_{j,0}$ 的正负性。
    	* 若它们是负数，则乘的数越大，积越小。所以我们要让编号大的 $j$ 排在前面。
        * 若它们是正数，则乘的数越小，积越小。所以我们要让编号小的 $i$ 排在前面。
        
我们按照这样的思路排序，结果就出来啦！

赛时代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define int long long
#define PII pair<int, int>

const int N = 100010;

inline void in(int &x)
{
	x = 0; bool f = 0; char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c & 15);
		c = getchar();
	}
	x = f ? -x : x;
}

inline void out(int x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x / 10) out(x / 10);
	putchar((x % 10) | 48);
}

int n, m;
PII a[N];

bool cmp(PII x, PII y)
{
	if(x.first != y.first) return x.first < y.first;
	else
	{
		if(x.first < 0) return x.second > y.second;
		else return x.second < y.second;
	}
}

signed main()
{
	in(n); in(m);
	for (int i = 1ll; i <= n; i ++ )
	{
		in(a[i].first);
		a[i].second = i;
	}
	
	sort(a + 1ll, a + n + 1ll, cmp);
	
	for (int i = 1ll; i <= n; i ++ )
		printf("%lld ", a[i].second);
	
	return 0;
}
```

---

## 作者：oscar0866 (赞：3)

#### 这是一道**排序题**重点是要注意负数。

## 思路
1.建立一个结构体存储数列。

2.标记每个数列的下标方便后面的排序比较。

3.排序：如果首项不一样则返回小的，如 la0 等于 ra0 时如果大于 0，则返回数列下标小的，但如果小于 0，则相反数列下标大的。因为首项相同，后面的项要乘以数列下标。这样我们就可以不用算出每个数列后面的数了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100005;//常量
struct Data {
      int a0, idx;//建立一个结构体，a0为每个数列的首项，idx为每个数列的下标
};
Data d[MAXN];
bool cmp(const Data& lhs, const Data& rhs) {//这里为此题重点！
      if (lhs.a0 != rhs.a0) return lhs.a0 < rhs.a0;//如果首项不一样则返回小的
      else if (lhs.a0 > 0) return lhs.idx < rhs.idx;//这里着重考虑此题的正负情况
      else return lhs.idx > rhs.idx; //如果la0=ra0时如果大于0,则返回数列下标小的，
      //但如果小于0，则相反数列下标大的。
      //因为首项相同，后面的项要乘以数列下标。
}
int main() {
      int n, m;
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; i++) {
            scanf("%d", &d[i].a0);//输入a0首项
            d[i].idx = i;//标记数列下标
      }
      sort(d + 1, d + n + 1, cmp);//结构体cmp排序
      for (int i = 1; i <= n; i++) printf("%d ", d[i].idx);//输出结果
      return 0;
}

```

---

## 作者：Nuyoah_awa (赞：2)

### 题目大意

给定 $n$ 个长度为 $m$ 的等比数列，请你将它们排序。

### 题目分析

#### 暴力

我们可以计算出每个等比数列，再将其排序，时间复杂度是 $\mathcal O(m \times n \log n)$。只能过前三个点。

#### 正解

我们观察每个等比数列，我们会发现这些等比数列的公比是 $i$，都是不一样的，也就是说这些数列找不到两个数列使得这两个数列前两项都是一样的，于是我们只需要知道这些数列的前两项就可以将其排序了。

时间复杂度是 $\mathcal O(n\log n)$ 的，跟 $m$ 没啥关系。

#### 实现&细节

我们根据上述思路很容易想到按照 $a_i$，即第一项为第一关键字，$i$，即公比为第二关键字排序。

但是，我们需要考虑到当首项 $a_i$ 为负数时，公比越大，第二项越小。所以需要判断 $a_i >0$ 时，按照 $i$ 升序排列，否则按照 $i$ 降序排列。

（我考场上就是没注意到这个挂分了，后来回顾发现为什么不老老实实把第二项算出来然后排序……值得反思）

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <math.h>
#include <cstring>
#include <algorithm>
//#define int long long

using namespace std;

const int N = 1e5 + 5;
struct node{
	int val, id;
}p[N];
int n, m;

bool cmp(node u, node v)
{
	if(u.val == v.val)
    {
        if(u.val >= 0)
    		return u.id < v.id;
        else
            return u.id > v.id;
    }
	return u.val < v.val;
}

signed main()
{
	scanf("%d %d", &n, &m);
	for(int i = 1;i <= n;i++)
	{
		scanf("%d", &p[i].val);
		p[i].id = i;
	}
	sort(p + 1, p + n + 1, cmp);
	for(int i = 1;i <= n;i++)
		printf("%d ", p[i].id);
	return 0;
}
```

---

## 作者：_VEGETABLE_OIer_xlc (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9472)

这道题很简单，但坑点很多，包括我也因为踩了其中一个坑导致比赛时挂**到** $40$ 分。

### 题意

给定 $n$ 个等差数列 $a_i$ 的首项 $a_{i,0}$，等差数列的项数为 $m+1$，要求把这些等差数列按**字典序排序**，特别的，第 $i$ 个等差数列的第 $j$ 项 $a_{i,j}=a_{i,j-1} \times i$。

初看这道题：由于要输出每个等差数列 $a_i$ 的下标 $i$，所以想到用结构体的方式记录首项 $a_{i,1}$ 和 $i$ 是理所当然的。

接着就是排序，输出编号啦。

我们需要找到 **两个等差数列中第一次出现的不同的数，比较大小**，所以要用个函数来帮助排序。

首先肯定是比较首项。

首项相同怎么办呢？那就比较第二项，由于首项一样，每个等差数列的下标**肯定不一样**，所以第一项相同，第二项**肯定不同**！

下面说一说这道题用这种思路的坑点：

- 虽然题目告诉我们有负数，但不用慌，这种做法是纯用字典序排，大就是往后排，小就是往前排。

- 要开 long long。这种做法没开会挂了 $60$ 分。

好了上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
struct node
{
	long long a,num;
}q[114514];
bool cmp(node c,node d)
{
	if(c.a>d.a)return false;
	else if(c.a==d.a)
	{
		long long f=c.a,g=d.a;
		f*=c.num;g*=d.num;
		if(f>g)return false;
		else return true;
	}
	else return true;
}
int main(){
	cin>>n>>m;
	for(long long i=1;i<=n;i++)
	{
		cin>>q[i].a;
		q[i].num=i;
	}
	sort(q+1,q+n+1,cmp);
	for(long long i=1;i<=n;i++)
		cout<<q[i].num<<" ";
	return 0; 
}
```
#### 忠告

十年 OI 一场空，不开 long long 见祖宗。

---

## 作者：船酱魔王 (赞：1)

# P9472 [yLOI2022] 枕万梦 题解

## 题意回顾

给定 $ n $ 个长度至少为 $ 2 $ 等比数列的首项，第 $ i $ 个等比数列的公比为 $ i $，请对于这些数列依照字典序排序后依序输出编号。

## 分析

字典序显然可以用 ```sort``` 排，重点在于实现比较函数。

如果两个数列的前两项相同，则他们公比一定相同，显然不符合题意。

因此，这两个数列如果第一项不同则直接按照第一项比较即可。

如果第一项相同，则按照第二项比较即可。

这里的实现方式是比较公比，第一项相同的时候第一项是正数的话公比越大第二项越大，否则公比越小第二项越大。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int n, m;
struct link {
	int a;
	int q;
} lk[N];
bool cmp(link p1, link p2) {
	if(p1.a != p2.a) {
		return p1.a < p2.a;
	}
	if(p1.a > 0) {
		return p1.q < p2.q;
	}
	return p1.q > p2.q;
}
int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> lk[i].a;
		lk[i].q = i;
	}
	sort(lk + 1, lk + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
		cout << lk[i].q << " ";
	}
	cout << endl;
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

首先我们要知道**字典序**的意思：按第 $1$ 项排序，如果第 $1$ 项相同，则按第 $2$ 项排序，以此类推。

而在此题的序列中，如果第 $1$ 项相同，第 $2$ 项肯定不同，证明：假设 $a_{i,1}=a_{j,1}$ 则 $a_{i,2}=a_{i,1}\times i$ 并且 $a_{j,2}=a_{j,1}\times j$ 还有 $i\ne j$，自然得出 $a_{i,2}\ne a_{j,2}$。

所以我们可以用一个结构体来存每个 $a_i$，结构体中存首项和公差。

接下来我们可以用系统自带的 ``sort`` 函数，而 ``sort`` 排序结构体时需要一个比较函数，而在这个函数中我们可以这样写（假设要比较编号分别为 $i$ 和 $j$ 的结构体，$i$ 在 $j$ 前面）（$1$ 代表应该交换，$0$ 代表不应交换）：
$$\begin{cases}a_{i,1} \ne a_{j,1}&\begin{cases}a_{i,1}>a_{j,1}&1\\a_{i,1}<a_{j,1}&0\end{cases}\\a_{i,1}=a_{j,1}&\begin{cases}a_{i,2}>a_{j,2}&1\\a_{i,2}<a_{j,2}&0\end{cases}\end{cases}$$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

struct node{
	int x,y;
};
node a[1000005];
int n,m;

bool cmd(node x,node y){   //sort 的比较函数。
	if(x.x==y.x) return x.x*x.y<y.x*y.y;
	return x.x<y.x;
}

signed main(){
	std::ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
		a[i].y=i;
	}
	sort(a+1,a+n+1,cmd);
	for(int i=1;i<=n;i++){
		cout<<a[i].y<<' ';   //由于公差就是数列的编号，直接输出公差即可。
	}
	return 0;
}
```


---

## 作者：fengyuxuan (赞：1)

## 题目大意

有 $n$ 个等比数列 $a_1, a_2, \dots a_n$，数列的长度均为 $m + 1$。

第 $i$ 个数列 $a_i$ 满足递推式 $a_{i,j} = a_{i,j - 1} \times i$。也就是第 $i$ 个数列，公比为 $i$。

现在给出每个序列的首项 $a_{i,0}$，需把这些数列按字典序排序，并输出排序后的数列编号。

## 题目解析

收先要解决的就是题目中的字典序，而这个题目提示也有：

对两个数列 $a_i, a_j$，按如下方式比较其字典序：

找到**最小的**满足 $a_{i,p} \neq a_{j, p}$ 的下标 $p$，比较 $a_{i, p}$ 和 $a_{j, p}$ 的大小：

- 如果 $a_{i,p} < a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的小。
- 如果 $a_{i,p} > a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的大。

可以证明，在本题的限制下，这样的 $p$ 一定存在。

此题的思路：$\operatorname{sort} + \operatorname{cmp}$。

此时我们考虑 $\operatorname{cmp}$ 这么写，也就是比较两个数列的字典序。

首先我们已知每个数列的首项，那当我们比较时就有两种情况：

1. 它们的首项不一样：

这种情况很好解决，只需比较首项即可，原因如题目提示（$p=0$）

2. 它们的首项一样：

很明显此时比较首项无法解决，那该怎么办？难道要比较一整个数列？

根本不用！**比较第二项即可！**

为什么？

这里有个不太严谨的证明：

现在我们比较两个不一样的数列数列 $a_i$ 和 $a_j$；

此时 $i \neq j$；

并且 $a_{i,0} \neq a_{j,0}$；

由题目可知 $i$ 和 $j$ 不为 $0$ 并且 $1 \leq |a_{i,0}|$；

所以 $a_{i,0} \times i \neq a_{j,0} \times j$；

再根据题意，可得 $a_{i,1} \neq a_{j,1}$；

以上可以证明如果它们的首项一样，那么它们的第二项肯定不一样，所以这种情况只需比较第二项即可。
## 如何实现

我们可以定义结构体，储存一个数列的首项和编号，而第二项就可以用首项 $\times$ 编号表示。

在 $\operatorname{cmp}$ 中我们直接用以上结论比较即可。

然后就可以通过 $\operatorname{sort}$ 进行排序，最后输出编号即可。

最后提醒此题要开 ``long long``。

## 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
struct node{
	long long a0;
	long long id;
}a[100005];
bool cmp(node x,node y)
{
	if(x.a0!=y.a0)
		return x.a0<y.a0;//比较第以项
    else
		return x.a0*x.id<y.a0*y.id//比较第二项
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].a0;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
		cout<<a[i].id<<" ";
}
```




---

## 作者：HappyCode (赞：1)

题解预留通过简单证明可知，任意两个数列的首项和第二项一定有一个不同（若首项相同，但公差不同，所以第二项不会相同），因此当 $m\ne1$ 时只需先比较首项，若相等再比较第二项即可。当 $m=1$ 时首项相同按输入顺序排序即可。

注意 $a_{i,0}$ 可以为负数，如果首项相等比较公差只有 70pts。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
struct node{
	int x,n;
}a[100005];
bool cmp(node a,node b){
	if(a.x==b.x){
	    if(m!=1){
		    return 1ll*a.x*a.n<1ll*b.x*b.n;
	    }else{
	        return a.n<b.n;
	    }
	}
	return a.x<b.x;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
		a[i].n=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		cout<<a[i].n<<' ';
	}
	return 0;
}
```

---

## 作者：Thenyu (赞：0)

[原题](https://www.luogu.com.cn/problem/P9472)

[更好的阅读体验](https://www.cnblogs.com/thenyu/p/17649806.html)

因为数列字典序是从第一项开始看的，样例输入了每个数列的第一项，所以如果数列的第一项就不相同，那么第一项小的字典序一定是小的。

接着如果两个数列的第一项相同，由题得第二项是第一项与这个数列的编号的乘积。如果这两个数列的第一项为正数，因为编号一定是正数，所以编号小的乘积一定小，那么字典序就小了；如果这两个数列的第一项为负数，那编号大的乘积就小，因此字典序就小。

所以这道题直接用一个结构体数组存下每个数列的第一项以及编号接着排序然后输出编号即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int n,m;
struct node
{
	int x,id;
}a[N+5];
bool cmp(node x,node y)
{
	if(x.x!=y.x)return x.x<y.x;//第一项不同那么小的那个数列字典序小 
	else
	{
		if(x.x>0)return x.id<y.id;//第一项为正数，编号越小字典序越小 
		else return x.id>y.id;//第一项为负数，编号越大字典序越小 
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i].x),a[i].id=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)
		printf("%d ",a[i].id);
	return 0;
}
```


---


# [ICPC 2022 Jinan R] Stack Sort

## 题目描述

给定一个包含 $n$ 个数字的排列 $a_1, a_2, \dots, a_n (1\leq a_i\leq n, a_i
\neq a_j\text{ 当 }i
\neq j)$。

你需要使用 $m$ 个栈对这些数字进行排序。具体来说，你需要完成以下任务：

最初，所有栈都是空的。你需要按照 $a_1,a_2,\ldots, a_n$ 的顺序，将每个数字 $a_i$ 压入 $m$ 个栈中的一个栈的顶部。**在将所有数字压入栈中之后**，你需要以一种巧妙的顺序从栈中弹出所有元素，使得你弹出的第一个数字是 $1$，第二个数字是 $2$，依此类推。**如果你从一个栈 $S$ 中弹出一个元素，那么在 $S$ 变空之前，你不能从其他栈中弹出任何元素。**

完成任务所需的最小 $m$ 是多少？

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
3
1 2 3
3
3 2 1
5
1 4 2 5 3
```

### 输出

```
3
1
4```

# 题解

## 作者：佬头 (赞：6)

## Description
给定一个 $n$ 的排列 $A$。请你利用 $m$ 个栈（初始都为空）对 $A$ 排序：按照 $a_1,a_2,\dots,a_n $ 的顺序，将每个数压入其中一个栈的栈顶。所有数入栈后，每次选定一个栈并[**将其所有元素弹出**](https://www.luogu.com.cn/problem/P9677)，使得最后弹出栈的数依次为 $1,2,…,n$。求最小的 $m$。

## Solution
显然栈中的元素一定满足 $b_{i+1}=b_i-1$（若存在）。因此对于一个 $a_i$，我们在已有栈中寻找是否有一个栈的栈顶元素满足 $b_{top}=a_i+1$。若存在，压入这个栈中；否则，新开一个栈，并压入其中。最终栈的个数就是答案。

考虑开一个 `bool` 数组维护此时的某个元素是否可以压入某个栈中。（总不能真的去维护 $m$ 个栈然后暴力搜索栈顶吧？）

时间复杂度 $\mathcal{O}(Tn)$。

## Code
```cpp
#include <iostream>
using namespace std;
int n, ans;
bool vis[500005]; //vis[i]:此时第i位可以并入之前的栈
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || a > '9') a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	for(int _ = read(); _ >= 1; _ --){
		n = read(), ans = 0;
		for(int i = 1; i <= n; ++ i) vis[i] = 0;
		for(int i = 1; i <= n; ++ i){
			int a = read();
			if(!vis[a]) ++ ans;
			vis[a - 1] = 1;
		}
		write(ans), puts("");
	}
	return 0;
}
```


---

## 作者：Hughpig (赞：2)

扫一遍数组，扫到一个值为 $i$ 元素已放入时，如果值为 $i-1$ 的元素未被放入，那么再放入值为 $i-1$ 的元素（这样弹出时肯定先弹出 $i-1$ 再弹出 $i$）。否则就新建一个栈放入 $i$（不然弹出 $i$ 后下一个元素就无法为 $i+1$ 了）。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[500007],ans;
bool vis[500007];

int main()
{
	cin>>t;
	while(t--){
		cin>>n;
		ans=0;
		for(int i=1;i<=n;i++)cin>>a[i],vis[i]=0;
		for(int i=1;i<=n;i++){
			if(vis[a[i]]){if(!vis[a[i]-1])vis[a[i]-1]=1;}
			else{
				ans++,vis[a[i]]=1;
				if(!vis[a[i]-1])vis[a[i]-1]=1;
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：sfqxx1 (赞：2)

这是一篇 python 题解。

## 题意

给定一个整数序列，统计其中最少需要多少个栈才能使得各个栈的元素互不相同。

## 思路

一道较为简单的签到题。

我们只需考虑每次输入一个数时比他大 $1$ 的数是否已经进栈，若否则栈加 $1$。

## 代码

```
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = [i - 1 for i in a]#列表推导式
    p = [0] * (n + 1)
    ans = 0
    for i in range(n):
        if not p[a[i] + 1]:
            ans += 1
        p[a[i]] = 1
    print(ans)
```





---

## 作者：tiger2008 (赞：1)

### 题解

全场最水的题。

对于所有的 $a_i$，如果前面出现过 $a_i+1$ 这个数时，$a_i$ 才可以放在 $a_i+1$ 这个数的栈的上面，这样 $ans$ 才不会加 $1$。

全部数都扫一遍，开一个数组 $f$ 来记录 $a_i+1$ 是否出现过即可。

### code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int T;
int arr[500005];
bool f[500005];
int main(){
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>arr[i];
			f[i]=false;
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			ans+=(!f[arr[i]]);
			f[arr[i]-1]=true;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```


---

## 作者：skyskyCCC (赞：1)

## 前言。
考查栈的知识，其实很像一个翻转题。
## 分析。
题意：  
给你 $T$ 组数据，每组数据中包括 $n$ 与 $n$ 个数，我们姑且将各个数用 $a_i$ 来称呼吧。请求出**最少**需要多少个栈，才可以将按输入的顺序依次放入栈中，将弹出的数变为从 $1$ 到 $n$ 依次弹出的顺序。

请注意，当你从一个栈中取出数时，整个栈必须清空。我们姑且称这个规则为 $2$ 号规则。

很明显，如果要满足题意，我们要让我们每个栈中的数都是连续的并且从栈顶到栈底各个数单调递增，因为只有这样，才能满足 $2$ 号规则的情况下，由于栈先进后出的特性，取出的数是依次从小到大弹出的。我们姑且称这个方法为做法 $1$ 号。

所以，我们只要在输入的序列中从前到后枚举，如果 $a_i$ 没有被加入栈，那就新建一个栈放入该数，将计数工具增加。

随后判断 $a_i-1$ 是否已经被加入栈，如果没出现过，把 $a_i-1$ 标记为进栈了，即将它放在 $a_i$ 所在栈的上方，表示后面如果出现 $a_i-1$ 这个数，它已经进栈，满足我们的做法 $1$ 号。

这样，我们就可以最大限度地减少栈的数量。

代码如下，仅供参考：
```
#include<iostream>
#include<stack>
using namespace std;
int t,n,a[500005];
int sum;
int s[500005];
int main(){
	cin>>t;
	while(t--){
		sum=0;
		cin>>n;
		for(int i=1;i<=n;i++){
		    cin>>a[i];
		}
		for(int i=1;i<=n;i++){
		    s[i]=0;//注意清零。
		}
		for(int i=1;i<=n;i++){
			if(!s[a[i]-1]){
				s[a[i]-1]=1;
			}//判断是否在栈中。
			if(!s[a[i]]){
				sum++;
				s[a[i]]=1;//标记。
			}//计数。
		}
		cout<<sum<<"\n";
	}
	return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：zhaohanwen (赞：0)

开一个数组 $b$ 来记录 $a_i+1$ 是否出现过，如果没出现过 $ans$ 就加 $1$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
ll solve(int n)
{
  int a[n+1]={0};
  for (int i = 0; i < n; i++)
  {
    cin >> a[i];
    a[i]--;
  }
  int b[n+1]={0};
  ll ans = 0;
  for (int i = 0; i < n; i++)
  {
    if (!b[a[i] + 1])
    {
      ans++;
    }
    b[a[i]] = 1;
  }
  return ans;
}
int main() {
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
  int T;
  cin >> T;
  while (T--)
  {
  	int n;
  	cin>>n;
    cout<<solve(n)<<endl;
  }
  return 0;
}
```


---

## 作者：HFanGDoDM (赞：0)

# 题意简述

给定一个 $n$ 的排列 $a$。

现利用 $m$ 个栈（初始都为空）对这个排列排序，具体地，顺次执行以下过程：

- 按照 $a_1,a_2,\dots,a_n$ 的顺序，将每个数 $a_i$ 压入其中一个栈的栈顶。

- **所有数入栈后**，按照一种顺序将栈中的所有元素弹出栈，使得弹出栈的数依次分别为 $1,2,\dots,n$。**若一次操作弹出了某个栈中的元素，则只能弹出这个栈中的元素，直至这个栈为空。**

求出能够完成上述排序过程的 $m$ 的最小值。

### 数据范围

**有多组测试数据**。测试数据组数 $T$ 满足 $1\leqslant T\leqslant 10^5$。对于每组测试数据，$1\leqslant n\leqslant 5\times 10^5$，$1\leqslant a_i\leqslant n$，保证序列 $a$ 是一个排列。对于所有测试数据，$\sum n\leqslant 5\times 10^5$。

# 解题思路

我们从 $a_1$ 到 $a_n$ 顺次考虑。设初始没有栈。

设当前加入的数为 $a_i$，若 $a_i+1$ 还未入栈或 $a_i=n$，则需要增加一个新的空栈，并将 $a_i$ 压入这个栈顶；否则，一定能够将 $a_i$ 压入已有的栈，且使得出栈顺序符合题意。

将所有数考虑完后，当前栈的数量即为 $m$ 的最小值。

### 正确性证明

设某一次将要入栈的数为 $a_i$。设此时共有 $x$ 个含有元素的栈，每个栈的栈顶元素分别为 $t_1,t_2,\dots,t_x$。

假设此时将 $a_i$ 压入第 $j$ 个栈。由于要求必须不断弹出一个栈的元素直至该栈为空，因此必然会在某连续两次对于第 $j$ 个栈的元素执行弹出操作时，先后弹出 $a_i$ 和 $t_j$。并且，因为符合题意的出栈顺序 $p_i$ 满足 $\forall i\in\{1,2,\dots,n-1\}$，都有 $p_{i+1}=p_i+1$，所以：若 $a_i+1\not=t_j$，则这一出栈顺序必然不合题意。

其逆否命题也成立，即：**出栈顺序符合题意 $\implies a_i+1=t_j$**。 

按照上述方法，将每个元素压入其对应的栈。此时，对于每一个栈，设 $s_i,s_{i+1}$ 分别为其中两个相邻元素，其中 $s_i$ 靠近栈顶，$s_{i+1}$ 靠近栈底，则必然有 $s_{i+1}=s_i+1$。

设当前已经弹出的元素分别为 $1,2,\dots,c$。尝试弹出元素 $c+1$。若此时 $c+1$ 不是某个栈的栈顶，则在这个栈中，根据上述性质，与这个元素相邻且更加靠近栈顶的元素一定为 $c$。由于此时已经将 $c$ 弹出，故说明存在两个相同的元素 $c$，这与原序列为一个排列相矛盾。因此，此时 $c+1$ 一定是某个栈的栈顶。由于上一次弹出的元素为 $c$，因此，要么 $c+1$ 与 $c$ 所在的栈相同，要么 $c+1$ 一定是当前还未进行操作的栈的栈顶。这样就得证：必然能够做到对于一个栈，不断将这个栈中的元素弹出，直到该栈为空，再对其他栈操作，使得出栈序列合法。即：

**$a_i+1=t_j\implies$ 出栈顺序符合题意**。其中字母的含义与上文相同。

于是得证：**出栈顺序符合题意 $\iff$ 对于所有的栈，若存在 $s_i,s_{i+1}$，则 $s_i+1=s_{i+1}$**。字母含义与上文相同。

考虑当前将要压入栈的元素为 $a_i$。根据上述结论，只能寻找一个栈顶元素等于 $a_i+1$ 的栈，将 $a_i$ 压入这个栈；或开一个新的空栈，将 $a_i$ 压入这个栈。执行前者不会增加栈的数量，执行后者会增加 $1$，每次都需要选择将栈的数量增加 $0$ 或 $1$，或只能增加 $1$，**并且每次增加之间是相互独立的**。因此：

**若存在满足前者条件的栈，则执行前者，否则执行后者，得到的栈总数量一定是最小的。**

若加入元素 $a_i$ 时，$a_i+1$ 已经被加入一个栈，若 $a_i+1$ 不是栈顶，根据上述结论，则 $a_i+1$ 所在的栈中与其相邻且更靠近栈顶的元素一定是 $a_i$，出现了两个 $a_i$ ，这与 $a$ 是一个排列相矛盾。因此，$a_i+1$ 必然是栈顶。若 $a_i+1$ 已经成为栈顶，则其也必然已经被加入。这样得证：

考虑当前的 $a_i$，**$a_i+1$ 已经入栈 $\iff$ $a_i+1$ 是其所在栈的栈顶**。

这样，我们就证明出，我们的这一解题思路是 **正确的**。

### 具体实现

我们将序列 $a$ 从左往右扫一遍，对于当前考虑到的元素 $a_i$，首先判断 $a_i+1$ 是否被加入过栈（可使用一个 $\operatorname{bool}$ 数组实现）。若被加入过，栈的数量不增加；否则，栈的数量增加 $1$。然后，标记这个元素也已经入栈。

最后输出栈的数量即可。

### 时间复杂度分析

只用扫一遍序列，时间复杂度是 $O(n)$ 的。

总时间复杂度 $O(\sum n)$，可以通过本题。

### 参考核心代码

```cpp
	for(i=1;i<=n;i++)
		a[i]=R();
	for(i=1;i<=n;i++){
		if(!ins[a[i]+1])//如果a[i]+1不在栈中
			cnt++;//增加一个栈
		ins[a[i]]=true;//标记a[i]入栈
	}
	printf("%d\n",cnt);
```

---

## 作者：TruchyR (赞：0)

## Part 1 题意
大致题意：  
按照输入的顺序向 $m$ 个栈中插入元素。  
之后每次按顺序弹出一个栈的所有元素，使得出栈序列为从小到大排序的。  
求一个最小的 $m$。  
## Part 2 思路
由于输入的是一个排列，因此可以想到每个栈从栈底到栈顶定是从大到小的连续数字。  
（否则在连续出栈的时候无法满足题目要求）  
那么，我们在每次插入时如果可以就新建栈一定是最优的。  
为了更清楚地理解，我们来模拟一下几组样例的过程：  
```
输入：1 4 2 5 3
[1]->[1][4]->[1],[4],[2]->[1],[4],[2],[5]->[1],[4,3],[2],[5]
输入：5 2 4 1 3
[5]->[5][2]->[5,4],[2]->[5,4],[2,1]->[5,4,3],[2,1]
（每个中括号代表一个栈）
```
我们可以得知：

- 当各个栈中存在数 $x+1$ 时，数 $x$ 插入时不需要新建栈，否则需要。

这题由此做完。
## Part 2 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a,ans;
bool ck[500005];
//如果ck[i]为true，则i加入时无需新建栈
signed main(){
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		for(int i=1;i<=n;i++) ck[i]=0;
		cin>>n;ans=0;
		for(int i=1;i<=n;i++){
			cin>>a;
			if(!ck[a])
				ans++;
			ck[a-1]=1;
			//此处ck[a]无需重置，因为之后不会再出现
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```


---

## 作者：Spir1t (赞：0)

### P9677  [ICPC2022 Jinan R] Stack Sort


------------


这道题目的要求是给定一个整数序列，统计其中最少需要多少个栈才能使得各个栈的元素互不相同。

对于该问题，我们可以使用哈希表来记录每个数字的出现次数，并根据序列中不存在连续的整数的特点，判断是否需要增加最小栈的数量。

具体来说，我们遍历整个序列，对于每个数字，如果其加一不在哈希表中，则说明当前数字是一个新的序列起点，需要增加最小栈的数量；然后将当前数字加入哈希表中，表示该数字已经出现过。通过这种方式，我们可以消除序列中重复数字的影响，并统计需要的最小栈数量。

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
using db=double;
using ull = unsigned long long;
signed main(){
	int t,n;
	cin>>t;
	while(t--){
		int cnt=0;
		unordered_map<int, int> m;// 哈希表，用于记录数字的出现次数
		cin>>n;
		while(n--){
			int temp;
			cin>>temp;
			if(!m[temp+1]) cnt++;// temp+1不在哈希表中，说明是新的序列起点
			m[temp]=1; // 当前数字加入哈希表中
		}
		printf("%d\n",cnt);
	}
	return 0;
}



```


---

## 作者：JimmyDong (赞：0)

## 题意

你有一个 $n$ 项的数组 $a$ 和 $m$ 个栈，满足：
- $1\leq a_i\le n$，每一项各不相同。
- 对于 $i=1,2...n$，使 $a_i$ 成为任意一个栈的栈顶。
- 在每一项入栈后有一种方法使得 $1,2...,n$ 可以按照递增顺序依次出栈。

求 $m$ 的最小值。
## 思路
对于每个 $a_i(a_i\neq n)$，如果在 $a_i$ 进栈前，$a_i+1$ 还未进栈，那么要增加一个栈来存放 $a_i+1$。

程序开始时 $m=1$。

循环对于每个 $i\ (i=1,2...,n)$：
- 如果 $a_i+1(a_i\neq n)$ 未进栈，$m$ 的值增加 $1$。
- 否则继续循环。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,cnt,t,a;
int main()
{
    cin>>t;
    while(t--)
	{
        cnt=0;
        map<ll,ll> mp;
        scanf("%lld",&n);
        for(int i=1;i<=n;i++)
		{
            scanf("%lld",&a);
            mp[a]=1;
            if(mp[a+1]==0) cnt++;
        }
        printf("%lld\n",cnt);
    }
    return 0;
}
```


---


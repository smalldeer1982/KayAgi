# [CSP-J 2023] 小苹果

## 题目描述

小 Y 的桌子上放着 $n$ 个苹果从左到右排成一列，编号为从 $1$ 到 $n$。

小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。

每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。

小苞想知道，多少天能拿完所有的苹果，而编号为 $n$ 的苹果是在第几天被拿走的？

## 说明/提示

**【样例 $1$ 解释】**

小苞的桌上一共放了 $8$ 个苹果。  
小苞第一天拿走了编号为 $1$、$4$、$7$ 的苹果。  
小苞第二天拿走了编号为 $2$、$6$ 的苹果。  
小苞第三天拿走了编号为 $3$ 的苹果。  
小苞第四天拿走了编号为 $5$ 的苹果。  
小苞第五天拿走了编号为 $8$ 的苹果。  

**【样例 $2$】**

见选手目录下的 apple/apple2.in 与 apple/apple2.ans。

**【数据范围】**

对于所有测试数据有：$1\leq n\leq 10^9$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $10$ | 无 |
| $3\sim 5$ | $10^3$ | 无 |
| $6\sim 7$ | $10^6$ | 有 |
| $8\sim 9$ | $10^6$ | 无 |
| $10$ | $10^9$ | 无 |

特殊性质：小苞第一天就取走编号为 $n$ 的苹果。

## 样例 #1

### 输入

```
8```

### 输出

```
5 5```

# 题解

## 作者：2huk (赞：252)

# [CSP-J 2023] 小苹果

## Description

有 $n$ 个苹果手机排成一排，标号 $1 \sim n$。接下来每天都会抢走一些苹果手机，每次从最左边的第 $1$ 个苹果手机开始，每隔 $2$ 个拿一个苹果手机。取完后将剩下的苹果手机重新排成一排。求：

1. 多少天能拿完所有苹果手机；
2. 第 $n$ 个苹果手机是在第几天拿的。

## Solution

我们可以把「每隔 $2$ 个取一个苹果手机」这件事情这样理解：将苹果手机每 $3$ 个分一组，每次取这一组的第一个。

例如有 $11$ 个苹果手机：

![](https://cdn.luogu.com.cn/upload/image_hosting/thumiejn.png)

标红的是这一轮拿的。如果最后剩下的不足以拼成 $3$ 个一组的，就拼成不完整的一组。

很显然，这一轮取走的苹果手机数量就是分成的组数，即 $\left \lceil \dfrac n3 \right \rceil$。那么我们暴力模拟这件事，每次 $n \gets n - \left \lceil \dfrac n3 \right \rceil$，看多少次操作后 $n$ 变成 $0$ 即可。这是第一问。

对于第二问，我们可以这样考虑。首先最后一个苹果手机一定是在最后一组的，那么如果想取走这个苹果手机，就相当于**这个苹果手机在最后一组的第一个**。例如有 $11$ 个和 $10$ 个苹果手机：

![](https://cdn.luogu.com.cn/upload/image_hosting/akcyfbiw.png)

可以发现，只有在**最后一组仅有 $1$ 个苹果手机时，最后一个苹果手机是这一组的第一个**。也就等价于当 $n \bmod 3 = 1$ 时，可以在这一轮取到最后一个苹果手机。

那么我们在求第一问的暴力模拟时，判断当前的 $n$ 是否模 $3$ 为 $1$。若是，记录下来这是第几轮取苹果手机。这就是第二问的答案。

注意在第一次 $n \bmod 3 = 1$ 时就可以取到最后一个苹果手机了。往后如果还有这样的机会就不算了。

考虑计算时间复杂度。每次将 $n$ 减去 $\left \lceil \dfrac n3 \right \rceil$，也就大约是 $n \gets \dfrac 23n$。不妨将其大约看作 $n \gets \dfrac 12n$，也就是每次将 $n$ 缩小一半。因此这样计算的话时间复杂度为 $\Theta(\log_2 n)$。实际运行时会偏高。

## Code

```cpp
#include <iostream>
#include <cmath> 

using namespace std;

int n, res1, res2;

int main()
{
	freopen("apple.in", "r", stdin);
	freopen("apple.out", "w", stdout);
	
	cin >> n;
	
	for (int i = 1; ; ++ i )
	{
		if (n == 0) break;
		if (!res2 && n % 3 == 1) res2 = i;		// 只有在第一次 n % 3 == 1 时记录答案 
		n -= ceil(n / 3.0);
		++ res1;
	}
	
	cout << res1 << ' ' << res2 << '\n';
	
	return 0;	
}
```



---

## 作者：Clarinet (赞：190)

听说 CSP 的题解开了，蒟蒻赶紧来写一篇！

虽然复赛考的不咋地，但是如果能在洛谷留下这样一篇题解也可以青史留名！

[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-8-post)
# 简要题意
有 $n$ 个苹果，小苞每天隔 $2$ 个拿一个，问拿完全部的苹果需要几天以及第 $n$ 个苹果第几天被拿走？
# 分析
不幸的是，考场上我发烧了，所以没想出正解呜呜呜。

大部分 90 分做法如下（考场代码）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000010],ans,k;
int main(){
	cin>>n;
	while(1){
		int p=1,now=1;
		for(int i=1;i<=n;i++){
			if(a[i]==0)now++;
			if(now==2){
				if(n==i)k=ans+1;
				a[i]=1;
				p=0;
				now=-1;
			}
		}
		if(p)break;
		ans++;
	}
	cout<<ans<<" "<<k;
	return 0;
}
```
用数组来做，是一定会 RE 的。所以我们考虑数学做法。

不要想的太复杂了，考场上我就在纠结规律，但实际可以简单模拟。每次会拿去 $\lceil \frac{n}{3} \rceil$ 个苹果，所以每次减去这部分。而如果此时 $n \bmod 3$ 刚好为一，则这一天也可以拿走第 $n$ 个苹果。

~~我考场上甚至在纠结斐波那契数列的做法，想的太复杂了，因此没打出正解。~~
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,k;
int main(){
	cin>>n;
	while(n){
		ans++;
		if(k==0&&n%3==1)k=ans;
		if(n%3==0)n-=n/3;
		else n-=n/3+1;
	}
	cout<<ans<<" "<<k;
	return 0;
}
```
感谢阅读！

---

## 作者：WsW_ (赞：50)

撞上我曾经出给 CROI R1 的原题了，很强。 

---
### 思路
假设这一天还剩 $x$ 个苹果。  
我们每 $3$ 个苹果分一组，剩余分不满一组的也分一组。显然从每组中会拿走 $1$ 个 苹果。  
所以这一天将拿走 $\left\lceil\dfrac{x}{3}\right\rceil$ 个苹果。  

每次拿走的是一组中的第 $1$ 个苹果，而一组一共有 $3$ 个苹果。  
所以当且仅当 $i \operatorname{mod} 3=1$ 时，第 $i$ 个苹果会被拿走。  
那么我们每天重新算一下 $n$ 前面有几个苹果，我们就可以知道 $n$ 在这一天排在第几个。当某天 $n \operatorname{mod} 3=1$ 时，将在这一天被拿走。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
int ans,cnt;
int main(){
	
	scanf("%d",&n);
	x=n;
	
	while(x){//还剩了苹果就一直取
		cnt++;
		x-=(x+2)/3;//这个相当于想上取整
	}
	printf("%d ",cnt);
    
	while(1){
		ans++;
		if(n%3==1)break;//取走了
		n-=(n+2)/3;//下一天剩多少苹果
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：MournInk (赞：17)

> 明显，这签到题。
### 思路：

肯定不能直接模拟，复杂度爆炸。

我们来想正解，首先，每天都会拿走 $1, 4, 7, \cdots$ 号苹果（如果存在），所以每天都会减少 $\lfloor {(n - 1) \div 3}\rfloor + 1$ 个苹果。所以统计天数的时候，我们设置终止条件 $n = 0$，在终止前每天更新 $n$ 与其天数。

再看最后一个什么时候被取走。我们应该想到的是，如果最后一个被拿走，那么 $n$ 应当满足 $(n - 1) \bmod 3 = 0$。由于我懒得打标记，所以只用每次取 $\min$ 即可（因为在前面的某一天拿走后，一定不会在后面再次被拿走）。

然后这道题目就解决了。

### 代码：
~~~cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long n, day = 0, pick = 0x3f3f3f3f;
	cin >> n;
	while(n)
	{
		day ++;
		if((n - 1) % 3 == 0) pick = min(pick, day);
		n = n - ((n - 1) / 3 + 1);
	}
	cout << day << " " << pick << endl;
	return 0;
}
~~~

> ### 友情提示：
> 刚才在群里看三四个人说代码为什么 `Luogu 90 pts`，但是交到 `CCF` 就爆零了。
>
> 这个问题是这样的：`Luogu` 等 `OnlineJudge` 默认采用动态内存，如果你开了但是你不访问这部分不计入程序占用内存。但是 `CCF` 评测的时候使用了静态内存，你开多大他就算你多大，所以 `1e9 + 10` 就很明显 `MLE` 了。

---

## 作者：zct_sky (赞：15)

### Description
-----
$n$ 个苹果，每次拿走编号 $x \bmod 3 =1$ 的所有苹果，每次拿完后重新编号（从 $1$ 开始）。

求共要拿几轮才能拿完和**最开始的**最后一个苹果第几轮被拿走。
### Solution
-----
题意化简后如上，一般的人都不会想到找每轮拿走苹果原先编号的规律然后死磕磕不出来罢（除了我）。

对于第一个问题，显然可以从每轮减少的苹果数入手。

可以找找规律：

${\color{red}{1}},2,3,{\color{red}{4}},5,6,{\color{red}{7}},8,9,{\color{red}{10}}$。

设共拿走 $k$ 个苹果，则 $n=1\dots 10$ 的结果如下：

$n=1,k=1$。

$n=2,k=1$。

$n=3,k=1$。

$n=4,k=2$。

$n=5,k=2$。

$n=6,k=2$。

$n=7,k=3$。

$n=8,k=3$。

$n=9,k=3$。

$n=10,k=4$。

然后就可以发现 $k = \left\lfloor\dfrac{n+2}{3}\right\rfloor$。

由于 $n \le 10^9$，所以可以一轮轮减去拿走的苹果数量，直至没有苹果。

第二问和上面相似。

首先，设最后一个苹果的编号为 $m=n-s$（$s$ 为该轮**前**拿走苹果总和），那么当 $m \bmod 3 = 1$ 时，该轮会拿走最后一个苹果。

当第一次出现 $m \bmod 3 = 1$ 时，显然，该轮会拿走**最开始的**最后一个苹果，记录该轮编号即可。

比如样例 $1$（下标为**初始编号**）：

${\color{red}{1_{(1)}}},2_{(2)},3_{(3)},{\color{red}{4_{(4)}}},5_{(5)},6_{(6)},{\color{red}{7_{(7)}}},8_{(8)}(s=0,m=8,m \bmod 3 = 2)$

${\color{red}{1_{(2)}}},2_{(3)},3_{(5)},{\color{red}{4_{(6)}}},5_{(8)}(s=3,m=5,m \bmod 3 = 2)$

${\color{red}{1_{(3)}}},2_{(5)},3_{(8)}(s=5,m=3,m \bmod 3 = 0)$

${\color{red}{1_{(5)}}},2_{(8)}(s=6,m=2,m \bmod 3 = 2)$

${\color{red}{1_{(8)}}}(s=7,m=1,{\color{red}{m \bmod 3 = 1}})$

所以**最开始的**最后一个苹果在第 $5$ 轮被拿走。

时间复杂度 $\mathcal{O}(\log_3 n)$。
### Code
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*y;
}
int n,a,b; 
int main(){
	n=read();
	while(n>0){
		a++;
		if(b==0&&n%3==1)b=a;
		n-=(n+2)/3;
	}
	printf("%lld %lld",a,b);
	return 0;
}
```

---

## 作者：strcmp (赞：14)

简单题。

注意到，位置 $i$ 会被删除，当且仅当 $(i - 1) \bmod 3 = 0$。

而每次删除，序列的长度都会减少 $\lfloor\frac{n - 1}{3}\rfloor + 1$。

于是记录当前序列长度 $n$，若 $(n - 1) \bmod 3 = 0$ 则记录答案，然后让 $n \leftarrow n - \lfloor\frac{n - 1}{3}\rfloor - 1$。直接递归算即可，时间复杂度 $\Theta(\log_{\frac{3}{2}}n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
int main() {
	//freopen("apple.in", "r", stdin);
	//freopen("apple.out", "w", stdout);
	ll n, ans2 = 0; ll now = 1;
	scanf("%lld", &n);
	while (n) {
		ll w = (n - 1) / 3 + 1;
		if ((n - 1) % 3 == 0 && !ans2) ans2 = now;
		n -= w; ++now;
	}
	printf("%lld %lld\n", now - 1, ans2);
	return 0;
}
```

---

## 作者：_Chronostatis_ (赞：12)

# [CSP-J 2023] 小苹果 题解
## Meaning
> 给定 $N$，表示 $N$ 个苹果，每次隔两个拿走一个，问需要几次拿完，和第 $N$ 个苹果是什么时候拿走的。

## Solution
### 暴力模拟 (90pts)
可以枚举次数，然后再 $1 \sim N$ 枚举，如果隔了两个就拿走，然后标记一下。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 10;

int n;
bool vis[MAXN];

int main() {
  cin >> n;
  int ans = 0, cnt = n, ans2 = 0;
  while (cnt) {
		ans++;
  	int count = 0;
  	for (int i = 1; i <= n; i++) {
  		if (vis[i]) {
  			continue ;
			}
			count++;
			if (count % 3 == 1) {
				cnt--;
				vis[i] = 1;
				if (i == n) {
					ans2 = ans;
				}
			}
		}
	}
	cout << ans << ' ' << ans2;
  return 0;
}
```
### 正解 (100pts)
手推一下样例得到：每次会拿走 $\lceil N / 3 \rceil$ 个苹果，只要每次的 $N$ 减去这个数，就是下一步的 $N$，这就是第一个答案。

再推样例发现：第一次拿，只要 $N \bmod 3 = 1$，那么编号为 $N$ 的苹果就会在第一天被拿走，只要有一次的 $N \bmod 3 = 1$，就记录答案，后面的以此类推。
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, ans, sna;

int main() {
  cin >> n;
  while (n) {
    ans++;
    if (!sna && n % 3 == 1) {
      sna = ans;
    }
    n -= (n + 2) / 3;
  }
  cout << ans << ' ' << sna;
  return 0;
}
```

---

## 作者：yhx0322 (赞：8)

upd on $2023.12.12$：修改了部分 $\LaTeX$ 格式。

## 题目简述
有一个长度为 $n$ 的序列，编号 $1 \sim n$。

每次从左侧第 $1$ 个开始，每隔 $2$ 个拿走 $1$ 个数。随后将剩下的数字按原先的顺序重新排成一列。

求：
- 多少天能取完所有的数
- 编号为 $n$ 的数是在第几次操作中被取走的

## 思路
首先，暴力纯模拟能拿到 $90$ 分。

接下来考虑如何优化。

可以发现，每次拿走大约 $\dfrac{1}{3}$ 的苹果，所以操作的轮数大约为 $O(n \log n)$ 级别。

每一次拿走苹果的数量为：$\lceil \dfrac{n}{3} \rceil$ 次。并且当 $n \bmod 3 = 1$ 的时候，编号为 $n$ 的苹果会被拿走。


## 代码
```c++
#include <bits/stdc++.h>

using namespace std;

int n;
int main() {
    cin >> n;
    int cnt = 0, ans = 0;
    while (n > 0) {
        cnt++;
        if (ans == 0 && n % 3 == 1) ans = cnt;
        n -= (n + 2) / 3;
    }
    cout << cnt << " " << ans;
    return 0;
}
```

---

## 作者：Xdwjs (赞：7)

注意到编号为 $n$ 的苹果如果存在，只会排在最后一个，所以我们不需要完全模拟每一轮的删除，只需要算出每一轮删除后的剩余苹果数量即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,sy,cnt=0,ans=1;
	cin>>n;
    sy=n;
	while(sy>=1)
	{
		int tmp=sy/3;
		if(sy%3>=1) tmp++;
		sy-=tmp;
		cnt++;
	}
	while(n%3!=1)
	{
		int tmp=n/3;
		if(n%3>=1) tmp++;
		ans++;
		n-=tmp;
	}
	cout<<cnt<<" "<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：7)

**UPD：将写错的 $\dfrac{n}{(\dfrac{2}{3})^x}$ 改为 $n \cdot (\dfrac{2}{3})^x$，并解决了代码在输入 $(10^6,3^{13})$ 时可能会 WA 的问题。**

我竟然差点不会 CSP-J2 T1 了……以下是考场做法。

枚举（其实不难证明）可知，$1$ 轮过后，$n$ 个苹果被拿走 $\lfloor\dfrac{n}{3}\rfloor$ 个；$x$ 轮过后，剩下的苹果以 $3^x$ 为周期，且剩下大约 $\lfloor n \cdot (\dfrac{2}{3})^x \rfloor$ 个苹果。例如：

- $1$ 轮过后，所有编号模 $3$ 余 $1$ 的苹果会被拿走；
- $2$ 轮过后，所有编号模 $9$ 余 $1,2,4,6,7$ 的苹果会被拿走；
- ……

于是，我们先暴力模拟 $3^x$ 个苹果拿 $x$ 轮后的结果，算出周期，接着选出剩下大约 $\lfloor n \cdot (\dfrac{2}{3})^x \rfloor$ 个苹果继续暴力模拟即可。

当 $3^x=n \cdot (\dfrac{2}{3})^x$ 时最优，显然此时 $x=\log_3 n \cdot\dfrac{\log 3}{\log 3+\log 3-\log 2}$，时间 / 空间复杂度为 $O(3^x)=O(n^{0.7304})$。

$n=10^9$ 下取 $x=13$ 即可。代码非常「好写」，仅仅 $72$ 行；性能也非常「优秀」，仅仅 `67 ms / 19.79 MB`。

**AC Code：**

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int> q,qq;
int main()
{
	int n,ans1=0,ans2=0,u,c;
	cin>>n;
    int mod=1;
    for(int i=1;i<=13;i++)
        mod*=3;
	if(n<=mod)
	{
		for(int i=1;i<=n;i++)
			q.push(i);
		int rounds=0;
		while(!q.empty())
		{
			rounds++;
			c=q.size();
			for(int i=1;i<=c;i++)
			{
				u=q.front();
				q.pop();
				if(i%3!=1) q.push(u);
				else if(u==n) ans2=rounds;
			}
		}
		ans1=rounds;
	}
	else
	{
		for(int i=1;i<=mod;i++)
			q.push(i);
		for(int rd=1;rd<=13;rd++)
		{
			c=q.size();
			for(int i=1;i<=c;i++)
			{
				u=q.front();
				q.pop();
				if(i%3!=1) q.push(u);
				else if(n%mod==u%mod) ans2=rd;
			}
		}
		int sz=q.size();
		for(int st=0;st<=n;st+=mod)
			for(int j=1;j<=sz;j++)
			{
				u=q.front();
				q.pop();
				q.push(u);
				if(st+u>n) break;
				qq.push(st+u);
			}
		int rounds=13;
		while(!qq.empty())
		{
			rounds++;
			c=qq.size();
			for(int i=1;i<=c;i++)
			{
				u=qq.front();
				qq.pop();
				if(i%3!=1) qq.push(u);
				else if(u==n) ans2=rounds;
			}
		}
		ans1=rounds;
	}
	cout<<ans1<<' '<<ans2;
	return 0;
}
```

---

## 作者：Big_Dinosaur (赞：6)

$7$ 分钟考场秒。

拿走最后的一个苹果要求：设有 $n$ 个苹果，当 $n \bmod 3=1$ 时即可，且第一次出现。

拿完：直接计算买一次拿去后苹果个数，设有 $n$ 个苹果，剩下 $n-\lceil \frac{n}{3} \rceil$ 个苹果。

直接模拟上述操作即可。

---

## 作者：tder (赞：2)

[$\Large\color{black}\textbf{P9748 [CSP-J 2023] 小苹果}$](https://www.luogu.com.cn/problem/P9748) $\Large\textbf{题解}$

[$\textbf{题目传送门}$](https://www.luogu.com.cn/problem/P9748)

[$\textbf{更好的阅读体验}$](https://www.luogu.com.cn/blog/tder/solution-P9748)

`upd on 2023/10/31 19:08 修改题目中的笔误。`


~~数学题~~

---

$$\large\textbf{思路}$$

先看分几次。假设现在有 $n$ 个苹果，每 $3$ 个拿 $1$ 个，则要拿 $\lfloor\frac n3\rfloor$ 个，还剩 $n-\lfloor\frac n3\rfloor$ 个。循环直到 $n=0$ 全部拿完为止，循环次数即为答案。

然后是编号为 $n$ 的第几天拿走。如果 $i\equiv1\pmod3$ 则第 $i$ 个苹果会被拿走。同理当循环拿苹果时，若 $n\equiv1\pmod3$ 则会被拿走，输出答案即可。

---

$$\large\textbf{代码}$$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
int days() { // 要拿几天
    int t = n, d = 0;
    while(t) { // 循环拿取
        t -= ceil(t / 3.0); // 向下取整
        d++;
    }
    return d;
} 
int getn() { // 编号为 n 的第几天拿走
    int t = n, d = 1;
    while(t % 3 != 1 && t) {
        t -= ceil(t / 3.0);
        d++;
    }
    return d;
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin>>n;
    cout<<days()<<" "<<getn()<<endl;
    return 0;
}
```

---

## 作者：SJZ2010 (赞：2)

## 做法

我们模拟一下样例可以注意到，每次会拿走所有编号 $i$ 满足 $i \bmod 3=1$ 的苹果，那么每一次会拿走 $\lceil \frac{n}{3} \rceil$ 个苹果，拿到没有苹果，即 $n=0$ 为止。

那么我们可以模拟这个过程，每次 $n$ 变为原来的 $\frac{2}{3}$，时间复杂度 $O(\log n)$。

## 代码

注意要记录一下最初的 $n$ 号苹果有没有拿过。 

```cpp
#include <cstdio>

int n, n2;
int ans1, ans2;
bool flag = false;

int main()
{
	//freopen("apple.in", "r", stdin);
	//freopen("apple.out", "w", stdout);
	scanf("%d", &n);
	while (n)
	{
		ans1++;// 记录天数
		if (n % 3 == 1 && !flag)// n 号苹果被取走
		{
			ans2 = ans1;
			flag = 1;// n 号已经被取走，标记一下，以后不取
		}	
		n -= (n + 2) / 3;// 取走了这么多苹果，要向上取整
	}
	printf("%d %d", ans1, ans2);
	return 0;
}
```

---

## 作者：hjqhs (赞：2)

第一问特判 $1$，设当前为 $x$，每次减去 $\lceil \frac{x}{3}\rceil$，直到为 $0$。  
第二问依旧特判 $1$，然后与第一问一样的减去 $\lceil \frac{x}{3}\rceil$，同时判断此时 $x \bmod 3$ 的值，如果为 $1$，说明下一轮能拿到，输出当前轮 $+1$ 的值。 

---

## 作者：Miyamizu_Mitsuha (赞：1)

算是近几年最难的 T1。
考虑每次只会有模三得一的数被拿走，所以每轮苹果会剩下 $\lceil n\times\frac{2}{3}\rceil$，于是一直乘下去，过程中顺便判断一下第一次 $n$ 模 $3$ 得 $1$ 的时候就好了。复杂度是 log 的，可以通过。
```
#include <bits/stdc++.h>
using namespace std;
int main(){
  int n,t,r=1,d=0;
  cin>>n;
  while(n){
    d++;
    if(n%3==1&&r==1)r=0,t=d;
    n=ceil(n*2/3);
  }
  cout<<d<<" "<<t;
return 0;
}

```


---

## 作者：Forever_LYD (赞：1)

算是近些年来最难的第一题了吧，数学思维加的比较多。

数据范围还是过大，所以要么是 $O(1)$ 要么是 $O(\log{n})$ 的复杂度。

按题意先模拟一下:

$1$ $\Rightarrow$ $1$ $1$

$2$ $\Rightarrow$ $2$ $2$

$3$ $\Rightarrow$ $3$ $3$

$4$ $\Rightarrow$ $3$ $1$

$5$ $\Rightarrow$ $4$ $4$

$6$ $\Rightarrow$ $4$ $2$

$7$ $\Rightarrow$ $4$ $1$

$8$ $\Rightarrow$ $5$ $5$

每间隔两个拿一个，那么如果当前苹果 $i \bmod 3$ 的值为 $1$ 是肯定能被取走的，而且每天都会拿走 $\frac{n}{3}$ 个苹果，所以显而易见，不断模拟，取了多少次，就是第一问的解；第二问的解为，当
 $n \bmod 3$ 的值为 $1$ 时，那么再下一轮的天数即为解
 
 参考代码:
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a=0,b=0;
	cin>>n;
	while(n>0){
		a++;
		if(n%3==1&&b==0){
			b=a;
		}
		n-=(n-1)/3+1;
	}
	cout<<a<<" "<<b;
	return 0;
}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

# P9748

数学题。

方法一：暴力，期望得分 $90$ 分，太良心了。

方法二：

我们稍微推算一下可得每次会取走 $\lceil \frac{n}{3} \rceil$ 个苹果，且如果当前苹果数 $n \bmod 3 = 1$，那么天数 $+1$ 即为第二问答案，循环多少次为第一问答案。

## Core Code（核心代码）

```cpp
for (; n; ++ ans) {
  (n % 3 == 1) && (!day) && (day = ans + 1);
  n -= ceil(double(n / 3.0));
}
cout << ans << ' ' << day << '\n';
```

---

## 作者：XKqwq (赞：0)

显然直接暴力模拟取苹果是过不了的。

首先思考多少天能拿完所有的苹果。显然每次会取走 $\lceil\frac{n}{3}\rceil$ 个苹果。每次直接减取的苹果数直到取完就行了。答案就是取的次数。

其次是编号为 $n$ 的苹果是在第几天被拿走的。显然在取的过程中，如果 $n \bmod 3 = 1$ 说明下一轮能取到，答案就是下一轮的天数。第一次满足条件时 $n$ 就被取走了，记得判断是否是第一次满足条件。

时间复杂度 $O(\log n)$ 可以通过此题。

考场代码：[link](https://www.luogu.com.cn/paste/9mc1d3xt)


---


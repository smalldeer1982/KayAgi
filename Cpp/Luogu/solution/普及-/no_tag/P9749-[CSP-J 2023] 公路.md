# [CSP-J 2023] 公路

## 题目描述

小苞准备开着车沿着公路自驾。

公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。

公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。

小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？

## 说明/提示

**【样例 1 解释】**

最优方案下：小苞在站点 $1$ 买了 $3$ 升油，在站点 $2$ 购买了 $5$ 升油，在站点 $4$ 购买了 $2$ 升油。

**【样例 2】**

见选手目录下的 road/road2.in 与 road/road2.ans。

**【数据范围】**

对于所有测试数据保证：$1 \leq n \leq 10^5$，$1 \leq d \leq 10^5$，$1 \leq v_i \leq 10^5$，$1 \leq a_i \leq 10^5$。

| 测试点 | $n \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $8$ | 无 |
| $6\sim 10$ | $10^3$ | 无 |
| $11\sim 13$ | $10^5$ | A |
| $14\sim 16$ | $10^5$ | B |
| $17\sim 20$ | $10^5$ | 无 |

- 特殊性质 A：站点 $1$ 的油价最低。
- 特殊性质 B：对于所有 $1 \leq i < n$，$v_i$ 为 $d$ 的倍数。

## 样例 #1

### 输入

```
5 4
10 10 10 10
9 8 9 6 5```

### 输出

```
79```

# 题解

## 作者：yhx0322 (赞：195)

## [Problem](https://www.luogu.com.cn/problem/P9749)
## Solution
反悔贪心思想。

从左到右考虑，如果行驶到某个加油站，缺油的时候，从之前经过的**最便宜的加油站加油**。

维护变量 $f$ 表示当前的状态。

若 $f < 0$，则代表的是当前还能走多少公里的油。

否则 $f \geq 0$，表示当前需要加油，加的油量为 $\lceil \dfrac{s}{d} \rceil$。

注意本题的数据范围大，需要开 `long long`！

## Code
时间复杂度 $O(n)$。
```cpp
#include <bits/stdc++.h>

using namespace std;

using LL = long long;

const int N = 1e5 + 10;

int v[N], a[N];
int n, d;
int main() {
    scanf("%d%d", &n, &d);
    for (int i = 1; i < n; i++) scanf("%d", &v[i]);
    int mi = INT_MAX;
    LL ans = 0, s = 0;
    for (int i = 1; i < n; i++) {
        scanf("%d", &a[i]);
        s += v[i];
        mi = min(mi, a[i]);
        if (s > 0) {
            ans += (s + d - 1) / d * mi;
            s -= (s + d - 1) / d * d;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：SJZ2010 (赞：55)

## 做法

可以考虑贪心。

首先我们发现在 $1$ 号加油站必须买油，否则根本动不了。接下来我们可以不断开到**在当前加油站后比当前加油站油价低的加油站**并**使油剩得最少**。

什么意思？拿样例来说，就是这样：

样例：

```
5 4
10 10 10 10
9 8 9 6 5
```

$2$ 号加油站是我们要开到的第二个加油站，因为 $2$ 号加油站的油价 $oil_2<oil_1$，同时我们只买 $3$ 升油，这样能开到 $2$ 号加油站并使油剩得最少。$2$ 号站后我们要到 $4$ 号站去，原因同上。

为什么呢？

假如我们现在有一排加油站，第 $i$ 个加油站的油价是 $oil_i$，$i$ 站到 $i+1$ 站的距离是 $dis_i$。我们先处理出 $1$ 号加油站到 $i$ 号加油站的总距离 $sum_i$。

假如我们现在在 $a$ 号加油站，要去 $b$ 号加油站，中间有个 $c$ 号加油站且 $oil_c < oil_a$。

按照我们的策略，我们一定要去 $c$，这样花了 $\lceil\frac{sum_c-sum_a}{d}\rceil \times oil_a + \lceil\frac{sum_b-sum_c}{d}\rceil \times oil_c$ 块钱。

不去 $c$ 的话，价格就是 $\lceil\frac{sum_b-sum_a}{d}\rceil \times oil_a$。

其实去 $c$ 的式子少考虑了从 $a$ 到 $c$ 后车里还有油，所以消耗的总油量其实就是 $\lceil\frac{sum_b-sum_a}{d}\rceil$。由于 $oil_c < oil_a$，所以去 $c$ 价格是更低的。

## 代码

注意要算一下开到某站还剩下多少油。

以及**不开 `long long` 见祖宗**。

```cpp
#include <cstdio>

typedef long long ll;

const int N = 1e5 + 5;

ll n, d;
ll dis[N], money[N], nxt[N], dis_sum[N], can_dis, ans;

int main()
{
	//freopen("road.in", "r", stdin);
	//freopen("road.out", "w", stdout);
	scanf("%lld %lld", &n, &d);
	ll i, dist, last_m, last_i;
	for (i = 1; i < n; i++)
		scanf("%lld", &dis[i]);
	for (i = 2; i <= n; i++)
		dis_sum[i] = dis_sum[i - 1] + dis[i - 1];// 计算从 1 到 i 的距离
	for (i = 1; i <= n; i++)
		scanf("%lld", &money[i]);
	last_m = money[1];
	last_i = 1;
	for (i = 2; i <= n - 1; i++)
	{
		if (money[i] < last_m)// 遇到比上一个加油站便宜的
		{
			nxt[last_i] = i;// 类似与链表的方式存储下一个加油站
			last_i = i;
			last_m = money[i];
		}
	}
	nxt[last_i] = n; // 要到 n 号点，可以把 n 号点看作价钱位 0
	for (i = 1; i < n;)
	{
		dist = dis_sum[nxt[i]] - dis_sum[i];
		ans += (dist - can_dis + d - 1) / d * money[i];// 要考虑还剩多少油
        	// can_dis 表示还能开多少距离
		can_dis += (dist - can_dis + d - 1) / d * d; // 注意油量要向上取整
		can_dis -= dist;
		i = nxt[i];// 向下一个加油站开
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Dream__Sky (赞：41)

提供一个 $O(n)$ 做法，考虑贪心。

------------
首先考虑贪心策略，要使买油的钱最少，那么就要去当前加油站 $i$ 之前的加油站去买油，而且买的是之前最便宜的油，并且买的升数只要保证能走到下一个加油站。

那么我们可以维护一个前缀最小值，$mi_i$ 保存从 $1$ 到 $i$ 加油站最便宜的油的价格。每次枚举 $i$，代表当前是要从 $i$ 号走到 $i+1$ 号，接着再用之前的贪心策略模拟即可。

------------
代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,d,sum,a[100010],v[100010],mi[100010];
signed main()
{
//	freopen("road.in","r",stdin);
//	freopen("road.out","w",stdout);
	cin>>n>>d;
	for(int i=1;i<n;i++) cin>>v[i],v[i]=v[i-1]+v[i];//把距离做叠加起来，方便操作
	for(int i=1;i<=n;i++) cin>>a[i];
	
	mi[1]=a[1];
	for(int i=2;i<=n;i++) mi[i]=min(mi[i-1],a[i]);//维护前缀最小值
	int now=0;//now保存的是当前距离起点多少距离
	for(int i=1;i<n;i++) 
	{
		if(now>v[i]) continue;//如果超过了i+1的距离，那么就不用考虑当前加油站买油，直接考虑下一个加油站
		int k=ceil((v[i]-now)*1.0/d*1.0);//买的最少升数
		sum+=k*mi[i];//钱
		now+=k*d;//距离
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：Wi_Fi (赞：37)

JS 都挂分了，悲痛难忍，写个有史最水 JT2 解个压罢。

非常显而易见的贪心思路，在一个加油站加从此加油站到在它后面第一个比他便宜的加油站即可。注意处理一下多加油的问题。

代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+5;
long long i,n,d,a[N],v[N],sum[N],mi,k,ans,mo;
int main()
{
    cin>>n>>d;
    for(i=1;i<n;i++)cin>>v[i];
    for(i=1;i<=n;i++)cin>>a[i];
    mi=a[1],k=1;
    for(i=1;i<n;i++)
    {
        if(a[i]>=mi)sum[k]+=v[i];
        else
        {
            k=i,mi=a[i],sum[i]+=v[i];
        }
    }
    for(i=1;i<=n;i++)
    {
		ans+=ceil(sum[i]*1.0/d)*a[i];
		mo+=ceil(sum[i]*1.0/d)*d-sum[i];
		if(mo>=d)mo-=d,ans-=a[i];
	}
    cout<<ans;
    return 0;
}
```


---

## 作者：_Chronostatis_ (赞：25)

# [CSP-J 2023] 公路 题解
## Meaning
> 给定 $n,d$，表示有 $n$ 个站点，每升油可以使汽车前进 $d$ 公里，每两个相邻的站点间的距离是 $v_i$，每个站点的油价是 $a_i$，问从站点 $1$ 开车到站点 $n$ 至少要花多少钱（油箱一开始是空的）。

## Solution
可以发现站点 $1$ 到站点 $2$ 的油一定要在站点 $1$ 购买，站点 $2$ 到站点 $3$ 的油可以在站点 $1$ 和站点 $2$ 购买，后面的以此类推。

所以就是从站点 $i$ 到站点 $i + 1$ 的油可以在前 $i$ 个站点购买，就相当于购买从站点 $i$ 到站点 $i + 1$ 的油的钱数就是前 $i$ 个站点买油需要的最小值。

知道了这个，就可以模拟了。

对于每个站点 $i$：
- 如果它是目前油价最低的站点，那么就在这个站点买油。
- 反之就要在目前油价最低的站点购买。

定义目前油价最低的站点的油价为 $w$，上一次剩余的油量为 $k$，从站点 $i$ 到站点 $i + 1$ 买油需要的钱数为：$w \times \lceil \frac {v_i - k}{d} \rceil$，下一步的 $k$ 为：$\lceil \frac {v_i - k}{d} \rceil \times d - (v_i - k)$。

## Accept Code
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e5 + 10;

int n, d, v[MAXN], a[MAXN];

int main() {
  // freopen("road.in", "r", stdin);
  // freopen("road.out", "w", stdout);
  cin >> n >> d;
  for (int i = 1; i < n; i++) {
		cin >> v[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int mi = a[1];
	int sum = 0;
	long long ans = 0;
	for (int i = 1; i <= n; i++) {
		mi = min(mi, a[i]);
		if (sum >= v[i]) {
			sum -= v[i];
			continue;
		}
		int t = (v[i] - sum + d - 1) / d;
		ans += 1ll * t * mi;
		sum = t * d + sum - v[i];
	}
	cout << ans;
  return 0;
}
```

---

## 作者：WsW_ (赞：24)

思维好题。

---
### 思路
以下为考场思路。

读题，有几个关键元素。  
1. 两点间的路程。
2. 每个点的油价。
3. 每升油能前进的路程。
4. **油箱足够大。**

油箱足够大的意思就是，油箱无限。  
莫名想起了[P5662 [CSP-J2019] 纪念品](https://www.luogu.com.cn/problem/P5662)。  
在纪念品一题中，因为可以无限交易，所以可以看做每一天都把所有的卖掉，然后再按需求买进。  
而在本题中，因为油箱无限，所以可以看作**当我在第 $i$ 个站点时，我可以购买到 $1\sim i$ 所有站点的油**。显然，会选择在 $1\sim i$ 所有站点中**最便宜的站点买油**。  

每当我们找到了一个新的最便宜的站点，那么肯定不会在其前面的站点买油，就这新站点最便宜。  
那什么时候我们会更换买油的地方呢？**当前站点**成为新的最便宜的站点时，之后我们会选择在**当前站点买油**。  

因此，我们只需要不断找到更便宜的站点，并在找到的最便宜的站点买油即可。每找到一个更便宜的站点，结算一次，要从上一个最便宜站点买够油开到当前最便宜的站点。  

我们可以通过前缀和来快速求出任意两站点间的路程。  

#### 注意
* 要存还没花完的路程（把油转化成路程存下来）。
* 要开 `long long`。
* 在终点记得再结算一次。

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
	int x,id;
};
int n,d;
ll v[100003];
int a;
ll w;
ll tt;
ll ans;

node lst;//记录最便宜的站点

int main(){
	scanf("%d%d",&n,&d);
	for(int i=2;i<=n;i++){
		scanf("%lld",&v[i]);
		v[i]+=v[i-1];//求前缀和
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(i==1){//肯定在第一个站点要买油。
			lst.x=a;
			lst.id=i;
		}
		else if(a<lst.x){
			tt=(v[i]-v[lst.id]-w+d-1)/d;//从上一个最便宜的站点到当前最便宜的站点要多少油（向上取整）
			w+=tt*d-(v[i]-v[lst.id]);//还余下多少路程没花完
			ans+=tt*lst.x;//结算花费
			lst.x=a;
			lst.id=i;
		}
	}
	ans+=(v[n]-v[lst.id]-w+d-1)/d*lst.x;//最后在终点还要结算一次
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Star_F (赞：19)

# 题目大意：

小苞准备开着车沿着公路自驾。

公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。

公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。

# 题目分析：

很明显是一道贪心。

首先，第一次买油一定要买第一个加油站的，而且买的油还要能够走到第二个加油站。

然后，就是第二次买油，如果这里的油价比第一次贵，那就不如第一次多买一点（能够到第三处加油站），否则就在第二处再买油（能走到第三处的量）。

有了这样的思路我们就可以 $O(N)$ 从前往后扫一遍，如果次处加油站比前面最便宜的要贵，那就不如在前面多买一点，否则，就在此处买。

但是这题还有一个小细节就是这次买的油到下次加油站时还有剩余的，再记录一个位置即可。
# 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100005],v[100005],ans=0,weizhi=0;
long long cnt=0;
int main(){

	long long n,d;
	scanf("%lld%lld",&n,&d);   //输入
	for(int i=1;i<=n-1;i++) scanf("%lld",&v[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	long long minn=a[1];   //第一次一定要买
	for(int i=1;i<=n-1;i++){
		cnt=ceil((v[i]-weizhi)*1.0/d);
		if(i==1){   //特判第一次
			ans+=cnt*minn;
		}
		else{         
			if(a[i]<minn){    //如果这次的便宜
				minn=a[i];
				ans+=ceil((v[i]-weizhi)*1.0/d)*minn;
				cnt=ceil((v[i]-weizhi)*1.0/d);
			}
			else{			///如果这次的贵
				ans+=ceil((v[i]-weizhi)*1.0/d)*minn;
				cnt=ceil((v[i]-weizhi)*1.0/d);
			}
		}
		weizhi=cnt*d-(v[i]-weizhi);     //记录位置
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：zct_sky (赞：19)

### Solution
-----
一道简单贪心。

对于油价进行贪心。一般的，若第 $i$ 个城市满足 $1 < i < n,a_i < \min\{a_1,a_2,a_3\dots a_{i-1}\}$，则在该城市买油。特殊的，对于第 $1$ 个城市，一定要买油；对于第 $n$ 个城市，视其油价 $a_n=0$。

买油的升数 $b_i = \left\lceil\dfrac{\sum\limits_{j=i}^{next} v_j}{d} \right\rceil$ 其中 $next$ 表示下一个符合条件的城市编号。

最后答案即为所有符合条件的城市的油价 $a$ 与 油量 $b$ 的乘积之和。

时间复杂度 $\mathcal{O}(n)$。
### Code
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*y;
}
const int N=1e5+7;
ll n,d,a[N],v[N],sum[N],b[N];
int main(){
	n=read();d=read();
	for(int i=1;i<n;i++){
		v[i]=read();
		sum[i]=sum[i-1]+v[i];
		b[i+1]=(sum[i]-1+d)/d;
	}
	ll tmp=0,ans=0;
	a[0]=N;
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(i==n)a[i]=0;
		if(a[i]<a[tmp]){
			ans+=(b[i]-b[tmp])*a[tmp];
			tmp=i;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xvl_ (赞：17)

[题目传送门](https://www.luogu.com.cn/problem/P9749)

一道 dp 题。

好像大家写的都是贪心，这里给出一种 dp 的写法。

在 dp 之前，我们需要明确以下几个东西：

**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。

### 状态的表示

$dp_i$ 表示到达第 $i$ 个站点所需要的最少钱数，$w_i$ 表示在使用最少钱数到达第 $i$ 个站点时多余的路程。

### 状态转移方程

$$dp_i=dp_{i-1}+\lceil\frac{v_{i-1}-w_{i-1}}{d}\rceil\times pre\_min(i-1)$$
$$w_i=\lceil\frac{v_{i-1}-w_{i-1}}{d}\rceil-v_{i-1}+w_{i-1}$$

其中 $pre\_min(i)$ 表示前 $i$ 个站点中最小的油价。

### 边界条件

$$dp_i=0$$
$$w_i=0$$

### 答案的表示

$$dp_n$$

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll n, d, ans;
ll v[100005], a[100005], dp[100005], pm[100005], w[100005];
int main() {
	// freopen("road.in", "r", stdin);
	// freopen("road.out", "w", stdout);
	ios :: sync_with_stdio(0);
	cin >> n >> d;
	pm[0] = 1e18;
	for (int i = 1; i < n; i++) cin >> v[i];
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pm[i] = min(pm[i - 1], a[i]);
	}
	for (int i = 2; i <= n; i++) {
		dp[i] = dp[i - 1] + ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * pm[i - 1];
		w[i] = ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * d - (v[i - 1] - w[i - 1]);
	}
	cout << dp[n];
	return 0;
}

```

---

## 作者：strcmp (赞：17)

省流：忘删调试喜提 0pts。

记录 $b_i$ 表示到站点 $i$ 至少要加多少升油。

考虑有最小油价的站点，记为 $x$。

那么就转化为到达 $x$ 的最小油价，加上 $x$ 到 $n$ 的最小油价。

考虑 $x$ 到 $n$ 的最小油价。我们显然是加 $b_x$ 升油后到达站点 $x$，然后加油一直到我们恰好能到站点 $n$，往后我们就一直开车，不再加油。

那么剩下的问题就是求出到 $x$ 的最小油价，这是一个子问题，我们递归做即可。

时间复杂度 $\Theta(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 4e5 + 10;
ll f[maxn], v[maxn], b[maxn]; 
int n, wz[maxn]; ll d, mi[maxn], a[maxn];
ll dfs(int i) {
	if (i == 1) return 0;
	if (f[i] != -1) return f[i];
	else {
		if (wz[i] == i) return dfs(wz[i - 1]) + a[wz[i - 1]] * (b[i] - b[wz[i - 1]]);
		else return dfs(wz[i]) + a[wz[i]] * (b[i] - b[wz[i]]);
	}
}
int main() {
	//freopen("road.in", "r", stdin);
	//freopen("road.out", "w", stdout);
	memset(f, -1, sizeof(f));
	scanf("%d%lld", &n, &d); mi[0] = 1145141919810LL; //
	for (int i = 1; i < n; i++) { 
		scanf("%lld", &v[i]), v[i] += v[i - 1];
		b[i + 1] = (v[i] + d - 1) / d;
		//b[i]，到站点 i 至少要加多少升的油
	}
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		mi[i] = min(mi[i - 1], a[i]);
		if (mi[i] == mi[i - 1]) wz[i] = wz[i - 1];
		else wz[i] = i;
	}
	printf("%lld\n", dfs(n));
	return 0;
}
```

---

## 作者：Dream_poetry (赞：10)

省流：加了 long long，数组开小错失一等。

一道很好想的贪心。

### 思路：
很显然，只需要这一次买油的价钱比上一次低，最后就一定是最小值。

#### 反证：
如果我选择了一次比上一次价钱更高的价钱，肯定不会比保持原样的价格低。

如果我一直保持一致，肯定是比选择更低的价格买油要贵。

所以，买油策略必然是遇到更小的就买。

证毕。

#### 继续：

我们用变量 $ans$，$yl$，$lc$，$tep$ 来记录**价格**、**油量**、**多余路程**和**油价**。

每次购买的价格，即为 $(v_i-lc) \div d$ 向上取整再乘 $tep$。

购买完后，计算多余油量为 $(v_i-lc) \div d$ 向上取整。

多余路程为 $lc+yl \times d-v_i$。

如果 $a_i$ 比 $tep$ 低，更新 $tep$ 即可。

再把如上三个公式套上，输出即可。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,d;
int v[500005],a[500005];
int ans;// 价钱 
int yl;// 油量 
int lc;// 路程 
int tep; // 单价 
signed main(){
	cin>>n>>d;
	for (int i=1;i<n;i++){
		cin>>v[i];
	}
	for (int i=1;i<=n;i++){
		cin>>a[i];
	}
	ans=ceil(1.0*v[1]/d)*a[1];
	tep=a[1];
	yl=ans/tep;
	lc=(yl*d)-v[1];
	for (int i=2;i<n;i++){
		if (a[i]<tep){
			tep=a[i];
		}
		ans=ans+ceil(1.0*(v[i]-lc)/d)*tep;
		yl=ceil(1.0*(v[i]-lc)/d);
		lc=lc+(yl*d)-v[i];
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：COsm0s (赞：5)

贪心。

显然本题是 $O(n)$ 或 $O(n\log n)$ 的算法，但是作者认为反而是 $O(n)$ 比 $O(n\log n)$ 好想。

我们设当前点为 $now$，显然初始值为 $1$。

那么我们向后寻找一个 $a_i<a_{now}$ 的点，**在这两点之中，任意一个点用来买油都是必定不优的。** 因为如果在这些点中去了一个 $a_i$，那么显然 $a_i\times v_i > a_{now}\times v_i$，所以不优。

确定了初始策略，我们来看看细节问题——由于油必为整数，所以会出现油买的路程比实际路程大了一点的情况，我们知道这个“一点”必定小于 $d$。

我们只需要将这个多出来的路程记录下来，在下一次计算时将那时的路程减掉该路程计算即可，这样就避免了“浪费”的情况。

由于我们向后找时搜过的点可以不用再管，所以复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace Jelly {
	const int N = 1e5 + 5, inf = INT_MAX;
	int a[N], v[N], ans = 0;
	int main() {
		int n, d;
		cin >> n >> d;
		for(int i = 1; i < n; i ++) cin >> v[i];
		for(int i = 1; i <= n; i ++) cin >> a[i];
		int lst = 1, sum = 0, l = 0;
		for(int i = 1; i < n;) {
			int j = i, pre = 0;
			while(a[lst] <= a[j] && j < n) {
				pre += v[j];
				++ j;
			}
//			cout << lst << ' ' << pre << '\n';
			ans += a[lst] * (ceil((pre - l) * 1.00 / d));
//			cout << ans << '\n';
			l = (d - (pre - l) % d) % d;
			i = j, lst = j;
			
		}
		cout << ans << '\n';
		return 0;
	}
}
signed main() {

	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T = 1;
//	cin >> T;
	while(T --) Jelly::main();
	return 0;
}
```

---


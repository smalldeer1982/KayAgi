# [ROIR 2021] 两台机器 (Day 1)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T1 [ Два станка](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。

## 题目描述

有两台机器，第一台机器需要 $a$ 分钟启动，接下来每分钟会制造 $x$ 个零件，第二台机器需要 $b$ 分钟启动，接下来每分钟会制造 $y$ 个零件，两个机器不能同时位于启动过程中。

共有 $k$ 分钟，问最多能制造多少个零件。

## 说明/提示

【样例解释】：

如果先启动第二台机器，接着启动第一台机器，可制作 $3\times 15+5\times 4=65$ 个零件。

【数据范围】：

对于所有子任务，有 $0\le k,a,x,b,y\le 10^9$，最终答案可以用 `long long` 存下。

| 子任务编号 | 特殊限制 | 分值 |
| :-: | :-: | :-: |
|$1$|$a=x=0$| $17$ |
|$2$|$a=b=0$| $14$ |
|$3$|$a=b$| $20$ |
|$4$|$x=y$| $20$ |
|$5$|无| $29$ |

## 样例 #1

### 输入

```
20
10 4
5 3```

### 输出

```
65```

# 题解

## 作者：封禁用户 (赞：4)

感谢老师的指导。

分类讨论：要么只选第一台机器，要么只选第二台机器，要么先用第一台再用第二台，要么先用第二台再用第一台，就这四种情况。

分类求时间，看看时间是否与 $k$ 相等，即要求时间，再求最大值。

代码如下：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
	long long kkksc, aya, xht, pinkr, ddd;
	cin >> kkksc >> aya >> xht >> pinkr >> ddd;
	long long ans = 0;
	if (kkksc-aya-pinkr >= 0) cout << max((kkksc-aya)*xht+(kkksc-aya-pinkr)*ddd, (kkksc-pinkr)*ddd+(kkksc-aya-pinkr)*xht);
	else
	{
		if (kkksc >= aya) ans = (kkksc-aya) * xht;
		if (kkksc >= pinkr) ans = max(ans, (kkksc-pinkr)*ddd);
		cout << ans;
	}
	return 0;
}
```


---

## 作者：UniGravity (赞：1)

## P9761 [ROIR 2021 Day 1] 两台机器
~~机器，启动！~~

### 题目分析
发现种类并不多，所以可以分成五类讨论：
1. 机器都不启动，此时 $ans=0$。
2. 只启动第一台机器，此时 $ans=x(k-a)$。
3. 只启动第二台机器，此时 $ans=y(k-b)$。
4. 先启动第一台机器，再启动第二台机器，此时 $ans=x(k-a)+y(k-a-b)$。
5. 先启动第二台机器，再启动第一台机器，此时 $ans=x(k-a-b)+y(k-b)$。

这道题就做完了。
### 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;

long long k, a, x, b, y;

int main() {
    scanf("%lld %lld %lld %lld %lld", &k, &a, &x, &b, &y);
    
    long long ans = 0;
    
    ans = max((k - a) * x + (k - a - b) * y, ans);
    ans = max((k - a - b) * x + (k - b) * y, ans);
    ans = max((k - a) * x, ans);
    ans = max((k - b) * y, ans);
    
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：cff_0102 (赞：1)

假设先启动机器 A，则前 $k$ 分钟能生产的零件数量为 $\max(k-a,0)x+\max(k-a-b)y$。

假设先启动机器 B，则前 $k$ 分钟能生产的零件数量为 $\max(k-b,0)y+\max(k-a-b)x$。

直接输出它们两个的最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(false);
	long long k,a,x,b,y;
	cin>>k>>a>>x>>b>>y;
	cout<<max(max(k-a,0ll)*x+max(k-a-b,0ll)*y , max(k-b,0ll)*y+max(k-a-b,0ll)*x);
	return 0;
}
```

注意：`max` 的两个参数类型要一致，所以 `0` 应该改成 `0ll`，表示这个 $0$ 的类型是 `long long`，而不是 `int`。

---

## 作者：WsW_ (赞：1)

难度大约为红。

---
### 思路
我称**第一台机器**为 $\mathtt{A}$ 机器，**第二台机器**为 $\mathtt{B}$ 机器。  

只有两种情况，要么先开 $\mathtt{A}$ 机器，再开 $\mathtt{B}$ 机器；要么先开 $\mathtt{B}$ 机器，再开 $\mathtt{A}$ 机器。  
两种情况对应的式子分别为：
$$(k-a)\times x+(k-a-b)\times y$$
$$(k-b)\times y+(k-a-b)\times x$$

两者中取较大值即可。  
有可能时间不够机器开机，需要特判取 $0$。

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll k;
ll a,b;
ll x,y;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>k>>a>>x>>b>>y;
	ll t=k-a-b;
	ll ans=(k-a)*x+max(t*y,0ll);//如果后一台机器开不了，那么后面取0
	ans=max(ans,(k-b)*y+max(t*x,0ll));
	cout<<max(ans,0ll);//如果两台机器都开不了，那么整个式子取0
	return 0;
}
```

---

## 作者：IcyFoxer_XZY (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9761)

这道题思维难度极小，但是细节较多。

### 分析：

首先我们考虑肯定两台机器要不先启动这个要不就先启动那个，只有两种情况。显然这个方法可行。那么我们就比较一下两个启动方式所得出的答案，取最大值输出。

什么？只有 $31$ 分？

那么来到本题的重点。我们并不能保证 $k>a$ 或 $k>b$，更别说 $k>a+b$ 了，那照这样得出的答案就是负数？所以遇到这种情况时不启动，具体操作就是在每次计算启动时间的时候加上计算结果与 $0$ 的比较，就可以得出正确答案。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,a,x,b,y;
signed main(){
    cin>>k>>a>>x>>b>>y;
	int ans1=max(max((k-a)*x,0ll)+max((k-a-b)*y,0ll),0ll);//first part
	int ans2=max(max((k-b)*y,0ll)+max((k-b-a)*x,0ll),0ll);//second part
	cout<<max(ans1,ans2);
    return 0;
}
```
Bye！

---

## 作者：CNS_5t0_0r2 (赞：1)

# 分析:

我们可以尝试分别尝试先启动第一台机器和先启动第二台机器。

当先启动第一台机器时，第一台机器的运行时间即为 $\max(k - a,0)$（注意启动时间有可能超过总时长），生产零件个数为 $\max(k - a,0) \times x$；第二台机器的运行时间为 $\max(k - a - b,0)$，生产零件个数为 $\max(k - a - b,0) \times y$，我们记这种情况下生产零件总数为 $ans1 = \max(k - a,0) \times x + \max(k - a - b,0) \times y$。

当先启动第二台机器时，第一台机器的运行时间即为 $\max(k - a - b,0)$，生产零件个数为 $\max(k - a - b,0) \times x$；第二台机器的运行时间为 $\max(k - b,0)$，生产零件个数为 $\max(k - b,0) \times y$，我们记这种情况下生产零件总数为 $ans2 = \max((k - b),0) \times y + \max((k - a - b),0) \times x$。

最后取答案为 $\max(ans1,ans2)$ 即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,a,x,b,y;
signed main(){
	scanf("%lld%lld%lld%lld%lld", &k, &a, &x, &b, &y);
	int ans1 = max((k - a),0ll) * x + max((k - a - b),0ll) * y;
	int ans2 = max((k - b),0ll) * y + max((k - a - b),0ll) * x;
	printf("%lld",max(ans1,ans2));
	return 0;
}
```


---

## 作者：FurippuWRY (赞：0)

由题意可知：机器启动需要时间，在这段时间内机器无法制造零件，并且两台机器不可同时启动。

所以，如果先启动机器 $1$ 再启动机器 $2$，那么机器 $1$ 共制造 $(k - a) \times x$ 个零件，机器 $2$ 共制造 $(k - a - b) \times y$ 个零件，总共制造了 $(k - a) \times x + (k - a - b) \times y$ 个零件。

反之，如果先启动机器 $2$ 再启动机器 $1$，那么机器 $2$ 共制造 $(k - b) \times y$ 个零件，机器 $1$ 共制造 $(k - a - b) \times x$ 个零件，总共制造了 $(k - b) \times y + (k - a - b) \times x$ 个零件。

因为要求的是输出**最多**能制造的零件个数，所以输出：
$$\max((k-a)\times x + (k - a - b) \times y,(k-b)\times y + (k - a - b) \times x)$$

于是就有了：
```cpp
printf("%lld", max((k - a) * x + (k - a - b) * y, (k - b) * y + (k - a - b) * x));
```

喜提 $14$ 分。

注意到 $0\le k, a, x, b, y \le 10^9$，也就是说 $(k - a)$、$(k - b)$、$(k - a - b)$ 是有可能小于 $0$ 的，当这些式子的值小于 $0$ 时，将它们赋值为 $0$ 再进行计算即可。

```cpp
#include <bits/stdc++.h>

using namespace std; 

long long k, a, x, b, y;

long long f(long long x) {
	return (x < 0ll ? 0ll : x);
}

int main() {
	
	scanf("%lld %lld %lld %lld %lld", &k, &a, &x, &b, &y);
	printf("%lld", max(f(k - a) * x + f(k - a - b) * y, f(k - b) * y + f(k - a - b) * x));
	
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

1. 如果 $a< k\leqslant b$，那么先启动第一台机器更优。此时还剩下 $k-a$ 分钟，可以制造 $(k-a)\times x$ 个零件。
2. 如果 $b< k\leqslant a$，同上可得可以制造 $(k-b)\times y$ 个零件。
3. 如果 $k>a$ 且 $k>b$，则比较如下两种情况即可。
	1. 先启动第一台机器，随后 $k-a$ 分钟制造 $(k-a)\times x$ 个零件。若 $k-a> b$，即剩下的时间足以启动第二台机器并工作至少 $1$ 分钟，那么启动第一台机器后后立马启动第二台机器，可以再生产 $(k-a-b)\times y$ 个零件。
	2. 同理，先启动第二台机器，可以制造 $(k-b)\times y$ 个零件。若 $k-b> a$，则可以再生产 $(k-b-a)\times x$ 个零件。
4. 如果 $k\leqslant a$ 且 $k\leqslant b$，即两台机器都没启动或刚刚启动，那么答案一定为 $0$。

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long k,a,x,b,y;
	cin>>k>>a>>x>>b>>y;
	long long ans=0; 
	if(a<k && k<=b) ans=(k-a)*x;
	if(b<k && k<=a) ans=(k-b)*y;
	if(k>a && k>b){
		ans+=(k-a)*x;
		if(k-a>b) ans+=(k-a-b)*y;
		long long ans2=(k-b)*y;
		if(k-b>a) ans2+=(k-b-a)*x;
		if(ans2>ans) ans=ans2;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zwyyy (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P9761)

---

## 思路
本题分类讨论：
1. 先启动第一台机器；
2. 先启动第二台机器。

因此只需要分别算出两种情况能制造的零件数量即可。

如果先启动第一台的机器，那么第一台机器工作 $\max(k-a,0)$ 分钟，产出 $\max(k-a,0) \times x $ 个零件；第二台机器工作 $\max(k-a-b,0)$ 分钟，产出 $\max(k-a-b,0) \times y$ 个零件。

先启动第二台机器同理。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long k, a, x, b, y;
    scanf("%lld%lld%lld%lld%lld", &k, &a, &x, &b, &y);
    printf("%lld", max(max(k - a, (long long)0) * x + max(k - a - b, (long long)0) * y, max(k - b, (long long)0) * y + max(k - b - a, (long long)0) * x));
    return 0;
}
```

[AC](https://www.luogu.com.cn/record/131045430)

---

## 作者：coding_goat (赞：0)

# 题解
原题链接：[https://www.luogu.com.cn/problem/P9761](https://www.luogu.com.cn/problem/P9761)

应该是一道签到题，稍微讲讲思路。

# 1.思路

首先，需要明白，一台机器启动完后另一台机器必须立马启动，这样才可以让收益最大化。

分类讨论两个机器的启动顺序，计算一下即可。

注意要保证启动后剩下的时间不能为负。如果是负数，那么就不计算启动后的收益。

# 2.代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
template <typename T>inline void read(T &xx){
	xx=0;int f=1;
    char c = getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f = -1;
        c = getchar();
    }
    while(c>='0'&&c<='9'){
        xx = (xx<<1)+(xx<<3)+(c^48);
        c = getchar();
    }
    xx*=f;
}
ll k,a,x,b,y; 
ll ans1,ans2; 
int main(){
	read(k),read(a),read(x),read(b),read(y);
	if(k-a>0) ans1+=(k-a)*x;
	if(k-a-b>0) ans1+=(k-a-b)*y,ans2+=(k-a-b)*x;
	if(k-b>0) ans2+=(k-b)*y;
	cout<<max(ans1,ans2);
	return 0;
}


```

---

## 作者：Crasole (赞：0)

## 思路

分两种情况：

- 先启动机器 $1$ 再启动机器 $2$，零件数为 $(k - a) \times x + (k - a - b) \times y$。

- 先启动机器 $2$ 再启动机器 $1$，零件数为 $(k - b) \times y + (k - b - a) \times x$。

由于会出现负数，所以要和 $0$ 作比较。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k, a, x, b, y; 
int main() {
	cin >> k;
	cin >> a >> x;
	cin >> b >> y;
   //max要求两个数的类型一致，所以要给0强制转换成long long类型
	long long t1 = max((k - a), (long long)0) * x + max((k - a - b), (long long)0) * y;
	long long t2 = max((k - b), (long long)0) * y + max((k - b - a), (long long)0) * x;
	cout << (max(t1, t2));
	return 0;
}
```

---

## 作者：smydahaoren (赞：0)

### 思路分析

给定 $2$ 个机器的启动时间和效率，求在 $k$ 分钟内最大生产数量。

为了让生产数量最大，肯定要最开始启动一个机器，后面在启动一个机器，那么无非就两种情况：先启动一号机器，先启动二号机器。

先启动一号机器收益为：$(k-a)\times x+(k-a-b)\times y$。

先启动二号机器收益为：$(k-a-b)\times x+(k-b)\times y$。

还有一种情况是给定时间不够启动机器，所以要进行判断。

那么综合起来就是：

$$\max(\max((k-a),0)\times x+\max((k-a-b),0)\times y,\max((k-a-b),0)\times x+\max((k-b),0)\times y)$$

**注意：这道题题面写的很清楚要开 $\texttt{long long}$ ~~但是我最开始忘记开了。~~**



------------
### AC 代码

```
#include<bits/stdc++.h>
using namespace std;
const long long  N=0;
long long k,a,b,x,y; 
int main(){
	//freopen(" ","r",stdin);
	//freopen(" ","w",stdout);
	cin>>k>>a>>x>>b>>y;
	long long mcha=max((k-a),N)*x+max((k-a-b),N)*y;
	long long mchb=max((k-a-b),N)*x+max((k-b),N)*y;
	cout<<max(mcha,mchb);
	return 0;
}

```


---

## 作者：littleqwq (赞：0)

# P9761 [ROIR 2021 Day 1] 两台机器题解

### 题目意思：

找出 $k$ 分钟内，怎样可以让两台机器造出的零件，尽可能的多，找出最多多少个零件。

### 大致思路：

用变量存他们可能的情况，找出贡献值最大的那项，这道题会出现两种可能：

- 先启动第一台机器，贡献值为 $(k - a) × x$，而因为如果他小于 $0$，那么我们就要取 $0$ 和它之间较大的值。而启动第二个机器时，公式就是 $\max (k - a - b,0) × y$。

- 先启动第二台机器，贡献值为 $(k - b) × y$，相同道理，如果他小于 $0$，那么我们就要取 $0$ 和它之间较大的值。而启动第一个机器时，公式就是 $\max (k - a - b,0) × x$。

我们要取上面两种情况贡献值较大的那种。

### 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
long long k,a,x,b,y,o=0;
int main(){
	cin>>k>>a>>x>>b>>y;
	long long t1,t2;//t1表示先启动第一台，t2表示先启动第二台
	t1=(max(o,x*(k-a)))+(max(o,y*(k-a-b)));//方案1
	t2=(max(o,x*(k-a-b)))+(max(o,y*(k-b)));//方案2
	cout<<max(t1,t2)<<endl;
	return 0;
} 
```

这样这道题就完成啦！！！

---

## 作者：W_s_W (赞：0)

### 思路
分类讨论。  
1. $k\le a\text{且}k\le b$。一台都启动不了，答案为 $0$。
2. $k\le a+b$。只能启动一台，答案为 $\max((k-a)\times x,(k-b)\times y)$。
3. $k>a+b$。两台都能启动，存在两种启动顺序，生产的零件数分别为：
$$(k-a)x+(k-a-b)y$$
$$(k-b)y+(k-a-b)x$$
假设第一种启动顺序能产生更多的零件，我们可以列出不等式：
$$(k-a)x+(k-a-b)y>(k-b)y+(k-a-b)x$$
解得条件为：
$$bx>ay$$
因此，如果 $bx>ay$，则答案为 $(k-a)x+(k-a-b)y$，否则答案为 $(k-b)y+(k-a-b)x$。

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll k;
ll a,b;
ll x,y;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>k>>a>>x>>b>>y;
	if(k<=a&&k<=b){
		cout<<0;
		return 0;
	}
	if(k<=a){
		cout<<(k-b)*y;
		return 0;
	}
	if(k<=b){
		cout<<(k-a)*x;
		return 0;
	}
	if(k<=a+b){
		cout<<max((k-a)*x,(k-b)*y);
		return 0;
	}
	if(b*x>a*y)cout<<(k-a)*x+(k-a-b)*y;
	else cout<<(k-b)*y+(k-a-b)*x;
	return 0;
}
```

---

## 作者：BugGod (赞：0)

考虑计算先启动第一台以及先启动第二台分别的制造零件数，取较大值即可。

先启动第一台机器，第一台工作 $\max(k-a,0)$ 分钟，共制造 $\max(k-a,0)\times x$ 个零件；第二台工作 $\max(k-a-b,0)$ 分钟，共制造 $\max(k-a-b,0)\times y$ 个零件，总零件数为 $\max(k-a,0)\times x+\max(k-a-b,0)\times y$。

先启动第二台机器，第二台工作 $\max(k-b,0)$ 分钟，共制造 $\max(k-a,0)\times y$ 个零件；第一台工作 $\max(k-a-b,0)$ 分钟，共制造 $\max(k-a-b,0)\times x$ 个零件，总零件数为 $\max(k-a-b,0)\times x+\max(k-b,0)\times y$。

两者取较大值即可。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int k,a,x,b,y;
int maxx(int a)
{
    return max(a,0ll);
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>k>>a>>x>>b>>y;
    cout<<max(maxx(k-a)*x+maxx(k-a-b)*y,maxx(k-a-b)*x+maxx(k-b)*y);
    return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：0)

显然，早启动肯定比晚启动优，早启动晚启动都是那个时间，早点开始获取零件肯定比晚好，所以无非就两种情况，先启动第一台再启动第二台，或者先启动第二台再启动第一台，
先启动第一台的话，花 $a$ 的时间，贡献是 $(k-a)\times x$，然后启动第二台，时间过去了 $a+b$（启动第一台和第二台的时间和），这时候贡献是 $(k-a-b)\times y$。
先启动第二台的话也是差不多的，但是要注意时间可能不够启动，就会出负数，所以过程中一直和 $0$ 取最值即可。

```
#include <stdio.h>
#include <iostream>
using namespace std;
#define int long long
int E(int n){return n>0ll?n:0ll;}
signed main(){
  int k,a,x,b,y;
  cin>>k>>a>>x>>b>>y;
  int fst=E((k-a)*x)+E((k-a-b)*y);
  int sec=E((k-b)*y)+E((k-a-b)*x);
  cout<<max(fst,sec);
  
return 0;
}

```
P9761

---

## 作者：maomao233 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9761)

考虑贪心，分别计算先启动第一台的方案和先启动第二台的方案，求最大值。也就是求 $x(k-a)+y(k-a-b)$ 与 $y(k-b)+x(k-a-b)$ 的最大值。

但这样会 WA，因为机器启动的时间可能不够，导致计算结果为负数。对于这种情况，显然不启动最优，即零件个数为 $0$。  
于是我们在每一步时让结果与 $0$ 取最大值计算即可。很容易写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
signed main()
{
	int k,a,x,b,y;
	rd(k,a,x,b,y);
	wtl(max(max((k-a)*x,0ll)+max((k-a-b)*y,0ll),max((k-b)*y,0ll)+max((k-a-b)*x,0ll)));
	return 0;
}
```

> 十年 OI 一场空，不开 long long 见祖宗。

---

## 作者：Clarinet (赞：0)

~~原神，启动。~~  
[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-4-post)
# 简要题意
有两台机器，第一台花 $a$ 分钟启动后每分钟能造 $x$ 个零件，第一台花 $b$ 分钟启动后每分钟能造 $y$ 个零件。两机器不能同时启动，问在 $k$ 分钟内最多造几个零件。
# 分析
其实这道题不用考虑那么多，直接求出先启动哪台机器的两种情况即可。

于是得到了下面的 14 分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,a,b,x,y,ans1,ans2;
int main(){
	cin>>k>>a>>x>>b>>y;
	ans1=x*(k-a)+y*(k-a-b);
	ans2=x*(k-a-b)+y*(k-b);
	cout<<max(ans1,ans2);
	return 0;
}
```
经过深思熟虑之后，我才意识到有可能时间并不够两台机器启动，所以机器的工作时间要与 0 取最大值，避免负收益。

**十年 OI 一场空，不开 long long 见祖宗。**
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,a,b,x,y,ans1,ans2,m=0;
int main(){
	cin>>k>>a>>x>>b>>y;
	ans1=x*max(m,k-a)+y*max(m,k-a-b);
	ans2=x*max(m,k-a-b)+y*max(m,k-b);
	cout<<max(ans1,ans2);
	return 0;
}
```
感谢阅读！

---


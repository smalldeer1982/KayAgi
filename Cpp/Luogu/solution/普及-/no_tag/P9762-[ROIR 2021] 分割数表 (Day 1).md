# [ROIR 2021] 分割数表 (Day 1)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T2 [ Разбиение таблицы](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。

## 题目描述

有一个 $n\times m$ 的数表 $a$，$a_{i,j}=(i-1)\times m+j$。

现在将这个数表分成两个数表 $x,y$，使得 $\max\{\sum x,\sum y\}$ 最小。

形象化地来说，您可以确定一个 $i$，然后在数表的第 $i-1$ 列与第 $i$ 列间竖切一刀，或者在第 $i-1$ 行与第 $i$ 行间横切一刀，所得到的两个数表分为 $x,y$。

请构造一组方案。

## 说明/提示

【数据范围】：

对于所有子任务，有 $1\le t\le 10^5$，$1\le n,m\le 10^9$，$2\le n\times m\le 10^9$。

| 子任务编号 |数据范围 | 分值 |
| :-: | :-: | :-: |
|$1$|$t=1$，$n,m\le 100$| $20$ |
|$2$|$t=1$，$n,m\le 2\times 10^3$| $14$ |
|$3$|$t=1$，$n,m\le 10^7$| $15$ |
|$4$| $t\le 10^3$，$n\times m\le10^4$ | $16$|
|$5$|$n=1$| $15$ |
|$6$|无特殊限制| $20$ |



## 样例 #1

### 输入

```
5
1 3
4 7
1 10
3 3
3 5```

### 输出

```
V 3
V 5
V 8
H 3
V 4```

# 题解

## 作者：bianshiyang (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P9762)

本蒟蒻使用数学公式求解本题，所涉及的数学公式有些繁杂，但解释十分详尽，请各位大佬耐心读完谢谢。

# 题目简意：
有一个 $n\times m$ 的数表，其中 $a_{i,j}=(i-1)\times m+j$。现在给出 $t$ 次询问，每次询问给出 $n$ 和 $m$，需要你求出如何分割数表成两部分 $x$ 和 $y$，使得 $\max{\{\sum x,\sum y}\}$ 最小，并输出切割方案。

# 分析：
暴力是肯定无法 AC，因为 $1\le t\le 10^5$，$1\le n,m\le 10^9$，$2\le n\times m\le 10^9$。这不仅使得 $O(n)$ 遍历都会超时，且二维树状数组求前缀和也会 MLE，所以容易想到用数学求解公式，$O(1)$ 算出答案。
 

首先我们要处理 $a_{i,j}=(i-1)\times m+j$ 是什么意思，~~如果你尝试模拟过的话~~，就知道它相当于是从 $a_{1,1}=1$ 开始然后顺序填充整个数表直到 $a_{n,m}=n\times m$，例如当 $n=3$，$m=4$ 时，数表应该形如下图：

| 1 | 2 | 3 | 4 |
| :----------: | :----------: | :----------: | :----------: |
| 5 | 6 | 7 | 8 |
| 9 | 10 | 11 | 12 |


那么不难发现无论我们怎么分割这个数表，所得到的 $\sum x+\sum y= \displaystyle\sum_{i=1}^n\displaystyle\sum_{j=1}^m a_{i,j}$，而  $\displaystyle\sum_{i=1}^n\displaystyle\sum_{j=1}^m a_{ij}$ 为一定值，不妨将这个定值设为 $N$，且为了方便表示，将 $\sum x$ 设为 $fx$，$\sum y$ 设为 $fy$。

再来看 $\max{\{fx,fy}\}$，变形一下，$\max{\{fx,N-fx}\}$，如果我们将它写成以下形式：

$\begin{dcases}fx &\text{}fx\ge fy \\N-fx &\text{} fx<fy\end{dcases}$

此时进行分类讨论：
若 $fx\ge fy$，
- 则有 $fx\ge N-fy$
- 即 $fx\ge\frac{N}{2}$
- 故此时 $\max{\{fx,fy}\}=fx\ge\frac{N}{2}$

若 $fx< fy$，
- 则有 $fx< N-fy$
- 即 $fx<\frac{N}{2}$
- 故此时 $\max{\{fx,fy}\}=N-fx>\frac{N}{2}$

而等号在哪一边取等都是可以的，所以 $\max{\{fx,fy}\}\ge\frac{N}{2}$。那么我们只要找到一种分割方案使得 $\max{\{fx,fy}\}=\frac{N}{2}$，那么此方案一定是最优的。而只有当 $fx=\frac{N}{2}$ 时，才可能取等，所以接下来只需要找到 $fx$ 和 $N$ 的表达式即可。

$N$ 的表达式很容易求，$N=\displaystyle\sum_{i=1}^{m
n}i=\frac{mn\cdot (mn+1)}{2}$，那么 $\frac{N}{2}=\frac{mn\cdot (mn+1)}{4}$。

先考虑横着分割数表假设确定的 $i$ 为 $k$，那么相当于在第 $k-1$ 行和第 $k$ 行将数表分开，因为 $fx$ 和 $fy$ 地位等价，不妨假设 $fx$ 为第一行到第 $k-1$ 行求和，也就是从 $1$ 加到 $[(k-1)-1]\cdot m+m=(k-1)\cdot m$，自然 $fx=\displaystyle\sum_{i=1}^{m\cdot(k-1)}i=\frac{m\cdot (k-1)\cdot [m(k-1)+1]}{2}$。

此时令 $\frac{m\cdot (k-1)\cdot [m(k-1)+1]}{2}=\frac{N}{2}=\frac{mn\cdot (mn+1)}{4}$，

可化简得 $2mk^2+2(1-m)k+2m-2mn^2-n=0$，

这便是关于 $k$ 的一个一元二次方程，如果我们能够得到 $k$ 的整数解并且 $1<k\le n$，那么最小值就是 $\frac{N}{2}$，否则我们找到 $\lceil k\rceil$ 和 $\lfloor k \rfloor$，并将它们分别带入 $fx$ 看 $\max{\{fx,N-fx}\}$ 谁更小，那么谁就是结果。容易证明 $k$、$\lceil k\rceil$、$\lfloor k \rfloor$一定有一个属于 $(1,n]$ 的。

然后考虑竖着分割数表，此时求解 $fx$ 是有一些难度的，根据题目所定义 $a_{i,j}=(i-1)\times m+j$，此时若仍假设确定的 $i$ 为 $k$，那么相当于在第 $k-1$ 列和第 $k$ 列将数表分开，所以 

$fx=\displaystyle\sum_{i=1}^n\displaystyle\sum_{j=1}^{k-1}a_{i,j}=\displaystyle\sum_{i=1}^n\displaystyle\sum_{j=1}^{k-1}m(i-1)+j$

$=\displaystyle\sum_{i=1}^n[m(k-1)(i-1)+\displaystyle\sum_{j=1}^{k-1}j]$

$=m(k-1)\displaystyle\sum_{i=1}^n(i-1)+\displaystyle\sum_{i=1}^n\frac{(k-1)(k-1+1)}{2}$

$=m(k-1)\displaystyle\sum_{i=1}^ni-m(k-1)\displaystyle\sum_{i=1}^n1+\frac{nk(k-1)}{2}$

$=\frac{mn(n+1)(k-1)}{2}-nm(k-1)+\frac{nk(k-1)}{2}$

此时令 $\frac{mn(n+1)(k-1)}{2}-nm(k-1)+\frac{nk(k-1)}{2}=\frac{N}{2}=\frac{mn\cdot(mn+1)}{4}$，

可化简得 $2k^2+2(mn-m-1)k-2mn+m-m^2n=0$。

这仍是关于 $k$ 的一个一元二次方程，如果我们能够得到 $k$ 的整数解并且 $1<k\le m$，那么最小值就是 $\frac{N}{2}$，否则我们找到 $\lceil k\rceil$ 和 $\lfloor k \rfloor$，并将它们分别带入 $fx$ 看 $\max{\{fx,N-fx}\}$ 谁更小，那么谁就是结果。

至此我们的分析已经结束了，直接上代码！

# 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long//不开long long见祖宗
#define inf 9e18
using namespace std;
int t, n, m;
int ans1, ans2;//ans1表示是横着切还是竖着切，ans2表示切在什么位置
double bans, aa, bb, k;//bans表示当前最小的max

double work() {//竖着切
	double fa = (double)2;
	double fb = (double)2 * (m * n - m - 1);
	double fc = (double) -2 * m * n + m - m * m * n;
	double der = sqrt(fb * fb - 4 * fa * fc);
	double aa1 = (-fb + der) / (2 * fa);//容易证明小的根是负数，所以返回大的根

	return aa1;
}

double deal(int x) {//求当x=k时竖着切的fx
	double f1 = (m * n * (n + 1) * (x - 1)) / 2;
	double f2 = m * n * (x - 1);
	double f3 = (n * x * (x - 1)) / 2;
	double res = f1 - f2 + f3;
	double tot = (m * n * (m * n + 1)) / 2;
	return max(res, tot - res);
}

double work2() {//横着切
	double fa = (double)2 * m;
	double fb = (double)(2 - 4 * m);
	double fc = (double)(2 * m - 2 - m * n * n - n);
	double der = sqrt(fb * fb - 4 * fa * fc);
	double aa1 = (-fb + der) / (2 * fa);
	return aa1;
}

double deal2(int x) {//求当x=k时横着切的fx
	double res = (m * (x - 1) * (m * (x - 1) + 1)) / 2;
	double tot = (m * n * (m * n + 1)) / 2;
	return max(res, tot - res);
}

signed main() {
	scanf("%lld", &t);

	while (t--) {
		scanf("%lld%lld", &n, &m);
		ans1 = ans2 = 0;
		aa = bb = bans = inf;//初始化以防万一
		k = work();//先求根，这里要先求竖着切的，因为“如果有多解，请输出竖切的一种”

		if (k == floor(k)) {//k为整数
			ans1 = 0;
			ans2 = k;
			bans = deal(k);
		} else {
			int k1 = floor(k);//下取整
			int k2 = k1 + 1;//上取整
			ans1 = 0;

			if (k1 > 1 && k1 <= m)
				aa = deal(k1);

			if (k2 > 1 && k2 <= m)
				bb = deal(k2);
			ans2 = aa <= bb ? k1 : k2;
			bans = aa <= bb ? aa : bb;
		}

		k = work2();//求横着切的

		if (k == floor(k)) {
			int lin = deal2(k);

			if (lin < bans) {//只有小于竖着切的情况才更新
				ans1 = 1;
				ans2 = k;
				bans = lin;
			}
		} else {
			int k1 = floor(k);
			int k2 = k1 + 1;

			if (k1 > 1 && k1 <= n)
				aa = deal2(k1);

			if (k2 > 1 && k2 <= n)
				bb = deal2(k2);

			if (aa < bans) {
				ans1 = 1;
				ans2 = k1;
				bans = aa;
			}

			if (bb < bans) {
				ans1 = 1;
				ans2 = k2;
				bans = bb;
			}
		}

		if (ans1 == 0)//ans1为0就是竖着切
			printf("V ");
		else//否则横着切
			printf("H ");
		printf("%lld\n", ans2);
	}

	return 0;
}
```
感谢各位大佬耐着性子看到这里，~~如果觉得还不错的话点个赞再走吧~~。

---

## 作者：xuchuhan (赞：2)

## Description

有一个 $n\times m$ 的数表 $a$，$a_{i,j}=(i-1)\times m+j$。

现在将这个数表分成两个数表 $x,y$，使得 $\max\{\sum x,\sum y\}$ 最小。同时输出分割的方法。

## Analysis

题目要求 $\max\{\sum x,\sum y\}$ 最小，同时又知道 $\sum x+\sum y$ 固定，所以我们要求最小的 $\lvert \sum x-\sum y\rvert$，使得 $\sum x$ 和 $\sum y$ 的值尽量接近，这样 $\max\{\sum x,\sum y\}$ 才能尽可能的小。

## Solution

不妨以竖切为例，横切同理。

设 $L(x)$ 表示前 $x$ 列的和，在 $i$ 行后切最优，则 $\sum x=L(i),\sum y=L(m)-L(i)$，所以 $\lvert \sum x-\sum y\rvert=\lvert 2 \times L(i)-L(m)\rvert$。又知 $L(m)$ 为定值，$L(i)$ 单调上升，所以 $\lvert \sum x-\sum y\rvert$ 的值就是一个单调上升的值减去一个定值的绝对值。这不就是**单谷函数**吗？

所以本题可以用**三分**求解。[不会三分请左转。](https://www.luogu.com.cn/problem/P3382)

三分过程不再详细赘述，现在先解决一个问题，如何在短时间内求出 $L(i)$ 呢？我想到过用前缀和预处理再 $\mathcal{O(1)}$ 查询，但预处理的时间和空间复杂度都很大，于是果断放弃。

我们可以简单地推一个式子。先拿 $3 \times 5$ 的数表举例：

$$\begin{bmatrix}1&2&3&4&5\\6&7&8&9&10\\11&12&13&14&15\end{bmatrix}$$

我们试求一下 $L(3)$。第 $1$ 列的数组成等差数列，首项为 $1$，项数为 $3$，公差为 $5$，所以末项为 $1+5\times(3-1)=11$。用等差数列求和公式即可得出这一列的和为 $(1+11)\times 3 \div 2=18$。第 $2$ 列中每一个数都比第 $1$ 列中和自己同一行的数大 $1$，又因为每一列有 $3$ 个数，所以第 $2$ 列的总和比第 $1$ 列大 $1 \times 3$。同理，第 $3$ 列的总和比第 $1$ 列大 $2 \times 3$。所以 $3$ 列总和即为 $3 \times L(1)+1\times 3+2\times 3$，即 $L(3)=3\times 18+(1+2)\times 3$。

推广至在 $n\times m$ 的数表中求 $L(i)$，不难得出如下代码：

```cpp
int Cal_L(int x){//求L(x)
	int L1=(n*m-m+2)*n/2;//L1=(1+1+m*(n-1))*n/2=(n*m-m+2)*n/2
	int ans=L1*x+x*(x-1)/2*n;//Lx=L1*x+(1到x-1之和)*n=L1*x+(x-1)*x/2*n
	return ans;
}
```

所有问题就迎刃而解了。

横切的思考方式同理，留与读者自行推导。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,m;
int Cal_L(int x){//求L(x)
	int L1=(n*m-m+2)*n/2;//L1=(1+1+m*(n-1))*n/2=(n*m-m+2)*n/2
	int ans=L1*x+x*(x-1)/2*n;//Lx=L1*x+(1到x-1之和)*n=L1*x+(x-1)*x/2*n
	return ans;
}
int Cal_H(int x){//同理
	int H1=(1+m)*m/2;
	int ans=H1*x+x*(x-1)/2*m*m;
	return ans;
}
signed main(){
	cin>>T;
	while(T--){
		cin>>n>>m;
		//以下就是三分板子力
		int lt=1,rt=m;
		while(lt<rt){
			int lmid=lt+(rt-lt+1)/3,rmid=lt+(rt-lt+1)*2/3;
			int lans=abs(Cal_L(lmid)*2-Cal_L(m));
			int rans=abs(Cal_L(rmid)*2-Cal_L(m));
			if(lans<=rans)
				rt=rmid-1;
			else
				lt=lmid+1;
		}
		int Lans=abs(Cal_L(rt)*2-Cal_L(m)),Lpos=rt;
		lt=1,rt=n;
		while(lt<rt){
			int lmid=lt+(rt-lt+1)/3,rmid=lt+(rt-lt+1)*2/3;
			int lans=abs(Cal_H(lmid)*2-Cal_H(n));
			int rans=abs(Cal_H(rmid)*2-Cal_H(n));
			if(lans<=rans)
				rt=rmid-1;
			else
				lt=lmid+1;
		}
		int Hans=abs(Cal_H(rt)*2-Cal_H(n)),Hpos=rt;
		if(Lans<=Hans)//比较竖切横切谁更优
			cout<<"V "<<Lpos+1<<"\n";
		else
			cout<<"H "<<Hpos+1<<"\n";
	}
	return 0;
}
```

---

## 作者：WydnksqhbD (赞：2)

# [P9762 [ROIR 2021 Day 1] 分割数表](https://www.luogu.com.cn/problem/P9762) 题解

## 题意

有一个二维矩阵 $a$，规定 $a_{i,j}=(i-1)\times m+j$。需要将其切分为两个矩阵 $x,y$，使 $\max\{\sum x,\sum y\}$ 最小。

## 思路

由于 $\sum a$ 是固定的，所以 $\sum y=\sum a-\sum x$。

这样题目等价于使 $|\sum x-\sum y|$ 最小。

考虑二分。但是这里有几个问题：

Q1：如何快速求出这个矩阵的和？  
A1：使用等差数列求和公式。设 $h$ 为首项，$t$ 为末项，$n$ 为项数，则该序列的和为 $(h+t)\times n\div2$。  
具体上代码了解一下：

```cpp
// 竖着切时，求 1 到 x 列的和 
int sum1 (int x) {
	int head = (2 + (n - 1) * m) * n >> 1;
	int tail = head + n * (x - 1);
	return (head + tail) * x >> 1;
}

// 横着切时，求 1 到 x 行的和 
int sum2 (int x) {
	return (1 + m * x) * m * x >> 1;
}
```

---

Q2：二分的 $\text{check}$ 怎么写？  
A2：可以看 $\sum x\le\sum y$ 是否成立。$\text{sum}=\sum a$。

```cpp
// 竖着切时，检查答案 k 
bool check1 (int k) {
	return sum1 (k) < sum - sum1 (k);
}

// 竖着切时，检查答案 k
bool check2 (int k) {
	return sum2 (k) < sum - sum2 (k);
}
```

二分到的答案 $\text{ans}1,\text{ans}2$ 分别是横切和竖切的，注意有可能是 $\text{ans}1+1$ 或 $\text{ans}2+1$。

---

Q3：二分的时候会出来两个答案（横切与竖切）怎么办？  
A3：可以先比较 $\text{ans}1$ 与 $\text{ans}1+1$，然后把找出来的与 $\text{ans}2,\text{ans}2+1$ 比较。注意题目要求的是优先竖切。

```cpp
sum = (1 + n * m) * n * m >> 1;
int ans;
char ch = 'V';
int l, r, ans1, ans2;

l = 1, r = m, ans1 = -1;

while (l <= r) {
	int mid = (l + r) >> 1;
	if (check1 (mid)) {
		ans1 = mid;
		l = mid + 1;
	} else {
		r = mid - 1;
	}
}
if (ans1 != -1) {
	if (sum - sum1 (ans1) <= sum1 (ans1 + 1)) {
		ans = ans1;
	} else {
		ans = ans1 + 1;
	}
}

l = 1, r = n, ans2 = -1;

while (l <= r) {
	int mid = (l + r) >> 1;
	if (check2 (mid)) {
		ans2 = mid;
		l = mid + 1;
	} else {
		r = mid - 1;
	}
}

if (ans2 != -1) {
	if (sum - sum2 (ans2) <= sum2 (ans2 + 1)) {
		if (max (sum1 (ans), sum - sum1 (ans)) > sum - sum2 (ans2)) {
			ans = ans2;
			ch = 'H';
		}
	} else {
		if (max (sum1 (ans), sum - sum1 (ans)) > sum2 (ans2 + 1)) {
			ans = ans2 + 1;
			ch = 'H';
		}
	}
}
```

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, m, sum;

// 竖着切时，求 1 到 x 列的和 
int sum1 (int x) {
	int head = (2 + (n - 1) * m) * n >> 1;
	int tail = head + n * (x - 1);
	return (head + tail) * x >> 1;
}

// 横着切时，求 1 到 x 行的和 
int sum2 (int x) {
	return (1 + m * x) * m * x >> 1;
}

// 竖着切时，检查答案 k 
bool check1 (int k) {
	return sum1 (k) < sum - sum1 (k);
}

// 竖着切时，检查答案 k
bool check2 (int k) {
	return sum2 (k) < sum - sum2 (k);
}

signed main () {
	int t;
	
	for (cin >> t; t; -- t) {
		cin >> n >> m;
		sum = (1 + n * m) * n * m >> 1;
		int ans;
		char ch = 'V';
		int l, r, ans1, ans2;
		
		l = 1, r = m, ans1 = -1;
				
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (check1 (mid)) {
				ans1 = mid;
				l = mid + 1;
			} else {
				r = mid - 1;
			}
		}
		
		if (ans1 != -1) {
			if (sum - sum1 (ans1) <= sum1 (ans1 + 1)) {
				ans = ans1;
			} else {
				ans = ans1 + 1;
			}
		}
		
		l = 1, r = n, ans2 = -1;
		
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (check2 (mid)) {
				ans2 = mid;
				l = mid + 1;
			} else {
				r = mid - 1;
			}
		}
		
		if (ans2 != -1) {
			if (sum - sum2 (ans2) <= sum2 (ans2 + 1)) {
				if (max (sum1 (ans), sum - sum1 (ans)) > sum - sum2 (ans2)) {
					ans = ans2;
					ch = 'H';
				}
			} else {
				if (max (sum1 (ans), sum - sum1 (ans)) > sum2 (ans2 + 1)) {
					ans = ans2 + 1;
					ch = 'H';
				}
			}
		}
		
		cout << ch << ' ' << ans + 1 << endl;
	}
	
	return 0;
}
```

感谢观看。

---

## 作者：wangboyue_740325 (赞：2)

# 题意
有一个 $n\times m$ 的数表 $a$，$a_{i,j}=(i-1)\times m+j$。  
现在将这个数表分成两个数表 $x,y$，使得 $\max\{\sum x,\sum y\}$ 最小。  
构造一组方案输出。
# 思路
考虑二分横/竖切时两部分最平均的位置。  
使用等差数列求和公式进行优化。  
将竖切的结果记为 $ans1$，横切的结果记为 $ans2$。  
注意最优解可能与二分得到的结果不同，最多偏差 $1$。  
详见代码。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5;
int n,m;
double gs(int l,int r){	//等差序列求和 
	return (l+r)*(r-l+1)/2;
}
double s1(int l){	//竖切 
	return gs(1,n-1)*(m*l)+n*gs(1,l);
}
double s2(int l){	//横切 
	return gs(1,m)*l+gs(1,l-1)*(m*m);
}
void help(){
	cin>>n>>m;
	double sum=(n*m)*(n*m+1)/2;
	int lt=0,rt=m+1,ans1,ans2;
	while(lt+1<rt){
		int mid=(lt+rt)/2;
		if(s1(mid)<sum/2){
			lt=mid;
		}
		else{
			rt=mid;
		}
	}
	if(abs(s1(lt)-sum/2)<=abs(s1(rt)-sum/2)){
		ans1=lt;
	}
	else{
		ans1=rt;
	}
	lt=0,rt=n+1;
	while(lt+1<rt){
		int mid=(lt+rt)/2;
		if(s2(mid)<sum/2){
			lt=mid;
		}
		else{
			rt=mid;
		}
	}
	if(abs(s2(lt)-sum/2)<=abs(s2(rt)-sum/2)){
		ans2=lt;
	}
	else{
		ans2=rt;
	}
	if(abs(s1(ans1)-sum/2)<=abs(s2(ans2)-sum/2)){
		cout<<"V "<<ans1+1;
	}
	else{
		cout<<"H "<<ans2+1;
	}
	return;
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		help();
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Indestructible (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9762)

本蒟蒻竟然用了 $4\operatorname{d}$ AC 一道橙题，为了纪念一下，赶紧交一发题解。全篇较长，请耐心观看。

# 题意简述

一个 $n\times m$ 的数表 $a$，$a_{i,j}=(i-1)\times m+j$。有 $t$ 组询问，每组询问给定 $n,m$，要求出一种把数表分割成 $x,y$ 两部分的方法，使 $\max(\sum x,\sum y)$ 最小。

# 思路

## 1. 暴力

- 时间复杂度：$\mathcal{O}(nmt)$。
- 预期得分：$50$ pts。
- AC Subtasks：#1，#2，#4。

枚举每行、每列的和，再枚举横切、竖切的断点，求出最小值。

## 2. 优化暴力

- 时间复杂度：$\mathcal{O}((n+m)t)$。
- 预期得分：$65$ pts。
- AC Subtasks：#1，#2，#3，#4。

尝试把求每行、每列的和都 $\mathcal{O}(1)$ 解决，可以把 $\mathcal{O}(nm)$ 的时间复杂度优化到 $\mathcal{O}(n+m)$。公式很难推，我也曾多次推错，浪费了不少时间，所以一定要仔细推算。

### 竖切的情况

#### $x$ 数表的和

$$\begin{aligned}\sum_{p=1}^{n}\sum_{q=1}^{i-1}a_{p,q} &= \sum_{p=1}^{n}\sum_{q=1}^{i-1}[(p-1)\times m+q] \\ &= \sum_{p=1}^{n}[(p-1)\times m\times(i-1)+\frac{(i-1)\times i}{2}] \\ &= \frac{n(n-1)}{2}\times m\times (i-1)+\frac{n(i-1)i}{2} \\ &= \frac{n(i-1)(mn-m+i)}{2}\end{aligned}$$

#### $y$ 数表的和

$$
\begin{aligned}\sum_{p=1}^n\sum_{q=i}^ma_{p,q} &= \sum_{p=1}^n\sum_{q=i}^m[(p-1)\times m+q] \\ &= \sum_{p=1}^{n}[(p-1)\times m \times (m-i+1)+\frac{(m-i+1)(m+i)}{2}] \\ &= \frac{n(n-1)}{2}\times m\times (m-i+1)+\frac{n(m-i+1)(m+i)}{2} \\ &= \frac{n(m-i+1)(nm+i)}{2}\end{aligned}$$

### 横切的情况

#### $x$ 数表的和

$$\begin{aligned}\sum_{q=1}^m\sum_{p=1}^{i-1}a_{p,q} &= \sum_{q=1}^m\sum_{p=1}^{i-1}[(p-1)\times m+q] \\ &= \sum_{q=1}^m[\frac{(i-1)(i-2)}{2}\times m+(i-1)\times q] \\ &= \frac{(i-1)(i-2)}{2}\times m^2+(i-1)\times \frac{m(m+1)}{2} \\ &= \frac{(i-1)m[(i-1)m+1]}{2} \\ &= \frac{(i-1)^2m^2+(i-1)m}{2}\end{aligned}$$

#### $y$ 数表的和

$$\begin{aligned}\sum_{q=1}^m\sum_{p=i}^{n}a_{p,q}  &= \sum_{q=1}^m\sum_{p=i}^{n}[(p-1)\times m+q] \\ &= \sum_{q=1}^m[\frac{(n-i+1)(n+i-2)}{2}\times m+(n-i+1)\times q] \\ &= \frac{(n-i+1)(n+i-2)}{2}\times m^2+(n-i+1)\times\frac{m(m+1)}{2} \\ &= \frac{(n-i+1)m[(n+i-1)m+1]}{2}\end{aligned}$$

### 最终的式子

$$\max(\sum x,\sum y) = \begin{cases}
  \max(\displaystyle\frac{n(i-1)(mn-m+i)}{2},\frac{n(m-i+1)(nm+i)}{2}) & \text{竖切} \\ \max(\displaystyle\frac{(i-1)^2m^2+(i-1)m}{2},\frac{(n-i+1)m[(n+i-1)m+1]}{2}) & \text{横切} \end{cases}$$

用该式枚举求最小值即可。

### Code

```cpp
// 计算 max(sum(x), sum(y))
// flag = 0 表示横切，flag = 1 表示竖切
int f(int i, bool flag)
{
	int sumx, sumy;
	if (flag)
	{
		sumx = n * (i - 1) * (m * n - m + i);
		sumy = n * (m - i + 1) * (n * m + i);
	}
	else
	{
		sumx = (i - 1) * m * (i - 1) * m + (i - 1) * m;
		sumy = (n - i + 1) * m * ((n + i - 1) * m + 1);
	}
	return max(sumx, sumy) >> 1; // 别忘了除以 2
}
```

## 3. 正解

- 时间复杂度：$\mathcal{O}(t\log(n+m))$。
- 预期得分：$100$ pts。
- AC Subtasks：#1，#2，#3，#4，#5，#6。

暴力优化过后，还是无法通过 $10^5\times10^9$ 的数据，容易想到用 $\log$ 级的算法。注意到 $\sum a$ 不变，$\sum x$ 随 $i$ 增加而增加，$\sum y$ 随 $i$ 增加而减少，所以 $\max(\sum x,\sum y)$ 是一个 **单谷函数**，可以对横切、竖切的两种情况分别 **整数三分**，取最小值即可。

### Code

```cpp
// 函数值和下标 
pair<int, int> divide(int l, int r, bool flag) // 三分 
{
	int ans = 1e18, sid;
	while (r - l >= 5)
	{
		int d1 = l + (r - l) / 3;
		int d2 = r - (r - l) / 3;
		int f1 = f(d1, flag);
		int f2 = f(d2, flag);
		if (f1 > f2) l = d1;
		else r = d2;
	}
	for (int i = l, tmp; i <= r; i ++)
	{
		tmp = f(i, flag);
		// 注意此处要用 < 
		if (tmp < ans) ans = tmp, sid = i;
	}
	return make_pair(ans, sid);
}
```

# 最终代码实现

代码实现有几点注意事项：

- $n^2m^2$ 最大可达 $10^{18}$，一定要 **开 long long**。
- 三分的 $l$ **应为** $2$。因为 $l$ 若取 $1$ 会造成 $\sum x = 0$。
- 三分时一定要分清楚 **下标** 和 **函数值**。
- 为了避免死循环，可以把 `while` 循环的条件设为 $r - l \ge 5$，然后再暴力枚举这 $5$ 个值。
- 如果有多解，请输出 **竖切** 的一种，如果还有多解，输出 $x$ **最小** 的一种。因此，要注意 $<$ 和 $\le$ 的用法。

> ***Talk is cheap, show me the code.***

```cpp
#include <bits/stdc++.h>
#define int long long // 开 long long
#define x first
#define y second
using namespace std;

int t, n, m;

inline void read(int& x)
{
	x = 0;
	int sign = 1;
	char s = getchar();
	while (s < '0' || s > '9')
	{
		sign = s == '-' ? -1 : 1;
		s = getchar();
	}
	while (s >= '0' && s <= '9')
	{
		x = (x << 3) + (x << 1) + s - '0';
		s = getchar();
	}
	x *= sign;
}

// 计算 max(sum(x), sum(y))
// flag = 0 表示横切，flag = 1 表示竖切
int f(int i, bool flag)
{
	int sumx, sumy;
	if (flag)
	{
		sumx = n * (i - 1) * (m * n - m + i);
		sumy = n * (m - i + 1) * (n * m + i);
	}
	else
	{
		sumx = (i - 1) * m * (i - 1) * m + (i - 1) * m;
		sumy = (n - i + 1) * m * ((n + i - 1) * m + 1);
	}
	return max(sumx, sumy) >> 1; // 别忘了除以 2
}

// 函数值和下标 
pair<int, int> divide(int l, int r, bool flag) // 三分 
{
	int ans = 1e18, sid;
	while (r - l >= 5)
	{
		int d1 = l + (r - l) / 3;
		int d2 = r - (r - l) / 3;
		int f1 = f(d1, flag);
		int f2 = f(d2, flag);
		if (f1 > f2) l = d1;
		else r = d2;
	}
	for (int i = l, tmp; i <= r; i ++)
	{
		tmp = f(i, flag);
		// 注意此处要用 < 
		if (tmp < ans) ans = tmp, sid = i;
	}
	return make_pair(ans, sid);
}

signed main()
{
	read(t);
	while (t --)
	{
		read(n), read(m);
		pair<int, int> p1 = divide(2, m, 1); // 竖切三分 
		pair<int, int> p2 = divide(2, n, 0); // 横切三分 
		// 注意此处要用 <= 
		if (p1.x <= p2.x) cout << "V " << p1.y << "\n";
		else cout << "H " << p2.y << "\n";
	}
	return 0;
}
```

---

## 作者：gavinliu266 (赞：1)

update：修正错误，添加代码。

观察题目描述可以发现，本题的数表是这样的：
![数表1](https://cdn.luogu.com.cn/upload/image_hosting/n1axdf89.png)

# 思路
设 $\sum{x} = S_1$，$\sum{y} = S_2$，$
\sum \limits _ {i = 1} ^ {n} \sum \limits _ {j = 1} ^ {m} {a_{i,j}} = S$。

而 $\max\{S_1, S_2\} = \max\{S_1, S - S_1\}$，显然，当 $S - S_1 = S_1$ 时原式值为 $S_1$ 最小，即 $S - 2S_1 = 0$。

这里，$S = \sum \limits _ {i = 1} ^ {nm} {i} = \dfrac{nm(nm + 1)}{2}$。

## 横切
设在第 $k$ 行与第 $k - 1$ 行之间切割，此时可以得到 $S - 2S_1 = \dfrac{nm(nm + 1)}{2} - m^2k^2 + 2m^2k - km - m^2 + m$。

令它等于 $0$，所以 $-2mk^2 + (4m - 2)k + (n^2m + n - 2m + 2) = 0$。

然后解一元二次方程即可。

## 竖切
设在第 $k$ 列与第 $k - 1$ 列之间切割，此时原数表可以这样表示：
![数表2](https://cdn.luogu.com.cn/upload/image_hosting/roo7tdiu.png)
可以得到 $S - 2S_1 = \dfrac{nm(nm + 1)}{2} - mn(k - 1)(n - 1) - nk(k - 1)$。

令它等于 $0$，所以 $-2k^2 + (2 - 2mn + 2m)k + (2mn - m + m^2n) = 0$。

## 合并结果
如果能够解出 $k$ 的整数解，则直接输出即可。

否则计算 $\lfloor k \rfloor$ 与 $\lfloor k \rfloor + 1$，取其中结果更小的就可以了。

# 代码实现
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
#define SS ((long double)(n * m * (n * m + 1) / 2))
long long t, n, m;
inline long double getH() {  // 计算横切竖切时的 k
    long double a = (long double)(-2 * m);
    long double b = (long double)(4 * m - 2);
    long double c = (long double)(n * n * m + n - 2 * m + 2);
    long double dt = sqrt(b * b - 4 * a * c);
    if(-b + dt <= 0) return (-b + dt) / (long double)(2 * a);
    return (-b - (dt < b ? -dt : dt)) / (long double)(2 * a);  // 求出更大的解 
}
inline long double getV() {
    long double a = -2;
    long double b = (long double)(2 - 2 * m * n + 2 * m);
    long double c = (long double)(2 * m * n - m + m * m * n);
    long double dt = sqrt(b * b - 4 * a * c);
    return (-b - dt) / (long double)(2 * a);
}
inline long double getSH(long long k) {  // 计算横切竖切时的 max
    long double x = (long double)(((m * m * k * k) - 2 * m * m * k + k * m + m * m - m) / 2);
    long double y = SS - x;
    return max(x, y);
}
inline long double getSV(long long k) {
    long double x = (long double)(((k - 1) * m * n * (n - 1) + n * k * (k - 1)) / 2);
    long double y = SS - x;
    return max(x, y);
}
int main() {
    scanf("%lld", &t);
    while(t--) {
        long double ans1 = 1e300;
        long long ans2 = 0;
        bool hs = false;
        scanf("%lld%lld", &n, &m);
        long double t = getV();
        if(t == floor(t)) { // 为整数
            long double tt = getSV((long long)t);
            ans1 = tt, ans2 = t;
        } else {
            long double ta = getSV(floor(t));
            long double tb = getSV(floor(t) + 1);
            if(1 < floor(t) && floor(t) <= m) ans1 = ta, ans2 = floor(t);  // 解在范围内 
            if(0 < floor(t) && floor(t) < m && tb < ans1) ans1 = tb, ans2 = floor(t) + 1;
        }
        t = getH();
        if(t == floor(t)) { // 为整数
            long double tt = getSH((long long)t);
            if(tt < ans1) ans1 = tt, ans2 = t, hs = true;
        } else {
            long double ta = getSH(floor(t));
            long double tb = getSH(floor(t) + 1);
            if(1 < floor(t) && floor(t) <= n && ta < ans1) ans1 = ta, ans2 = floor(t), hs = true;
            if(0 < floor(t) && floor(t) < n && tb < ans1) ans1 = tb, ans2 = floor(t) + 1, hs = true;
        }
        if(hs) printf("H %lld\n", ans2);
        else printf("V %lld\n", ans2);
    }
}
```
目前在最优解第一面，[记录](https://www.luogu.com.cn/record/189999323)。

---

## 作者：rc_Taurus (赞：1)

这道题最直接的做法是枚举切的地方，但很明显会超时。

于是考虑到枚举最得力的优化方法就是二分。

不过这题比较恶心的是要开两个二分，两个判断函数，每次二分完后还要处理以下。

不过仅此而已，这道题是橙题不是没有道理的。

上代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,tot,t;
int f1(int x){
	int t1=(2+(n-1)*m)*n/2;
	int t2=t1+n*(x-1);
	return(t1+t2)*x/2;
}int f2(int x){return(1+m*x)*m*x/2;}
bool checkheng(int k) {
	return f1(k)<tot-f1(k);
}
bool checkshu(int k) {
	return f2(k)<tot-f2(k);
}
int res;
char ch;
int l,r,res1,res2;
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		tot=(1+n*m)*n*m/2;
		ch='V';
		l=1,r=m,res1=-1;
		while(l<=r){//横切 
			int mid=(l+r)>>1;
			if(checkheng(mid)){
				res1=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}if(res1!=-1){
			if(tot-f1(res1)<=f1(res1+1)){
				res=res1;
			}else res=res1+1;
		}
		l=1,r=n,res2=-1;
		while(l<=r){//竖切 
			int mid=(l+r)>>1;
			if(checkshu(mid)) {
				res2=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		if(res2!=-1){
			if(tot-f2(res2)<=f2(res2+1)){
				if(max(f1(res),tot-f1(res))>tot-f2(res2)){
					res=res2;
					ch='H';
				}
			}else{
				if(max(f1(res),tot-f1(res))>f2(res2+1)){
					res=res2+1;
					ch='H';
				}
			}
		}
		cout<<ch<<' '<<++res<< endl;
	}
	return 0;
}
```

---

## 作者：2012ghr0502 (赞：1)

**题目分析**：
1. 给定一个 $n\times m$ 的数表 $a$，其中 $a_{i,j}=(i - 1)\times m + j$。需要将数表分成两个数表 $x$ 和 $y$，使得 $\max\{\sum x,\sum y\}$ 最小。
2. 可以通过在数表的某一行或某一列进行切割来实现分割。

**解题思路**：
1. 首先考虑数表的总和 $sum$，总和为 $\sum_{i = 1}^{n}\sum_{j = 1}^{m}a_{i,j}=\sum_{i = 1}^{n}\sum_{j = 1}^{m}((i - 1)\times m + j)=\frac{n(n - 1)}{2}\times m+\frac{m(m + 1)}{2}\times n$。
2. 假设进行竖切，在第 $k$ 列进行切割。那么左边部分的总和 $leftSum$ 为 $\sum_{i = 1}^{n}\sum_{j = 1}^{k}a_{i,j}$，右边部分的总和 $rightSum$ 为 $sum - leftSum$。目标是找到一个 $k$，使得 $\max\{leftSum,rightSum\}$ 最小。
3. 同理，对于横切，假设在第 $k$ 行进行切割，计算上下两部分的总和并找到使得 $\max\{upperSum,lowerSum\}$ 最小的 $k$。
4. 为了满足题目要求，如果有多解，优先输出竖切的一种，且 $x$ 最小。

**具体步骤**：
1. 计算数表的总和 $sum$。
2. 对于竖切：
   - 遍历每一列 $k$，计算左边部分的总和 $leftSum$。
   - 计算右边部分的总和 $rightSum = sum - leftSum$。
   - 记录使得 $\max\{leftSum,rightSum\}$ 最小的 $k$。
3. 对于横切：
   - 遍历每一行 $k$，计算上部分的总和 $upperSum$。
   - 计算下部分的总和 $lowerSum = sum - upperSum$。
   - 记录使得 $\max\{upperSum,lowerSum\}$ 最小的 $k$。
4. 比较竖切和横切得到的最小 $\max\{\sum x,\sum y\}$，选择较小的一种并输出对应的切割方式和位置。

**代码实现（以 C++ 为例）**：
```cpp
#include <iostream>

long long sum(int n, int m) {
    return (long long)(n * (n - 1) / 2) * m + (long long)(m * (m + 1) / 2) * n;
}

void solve(int n, int m) {
    long long totalSum = sum(n, m);
    long long minMaxSum = totalSum;
    char cutType = 'V';
    int cutPos = 1;
    // 竖切
    for (int k = 1; k <= m; k++) {
        long long leftSum = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                leftSum += (i - 1) * m + j;
            }
        }
        long long rightSum = totalSum - leftSum;
        long long currMaxSum = std::max(leftSum, rightSum);
        if (currMaxSum < minMaxSum) {
            minMaxSum = currMaxSum;
            cutType = 'V';
            cutPos = k;
        }
    }
    // 横切
    for (int k = 1; k <= n; k++) {
        long long upperSum = 0;
        for (int i = 1; i <= k; i++) {
            for (int j = 1; j <= m; j++) {
                upperSum += (i - 1) * m + j;
            }
        }
        long long lowerSum = totalSum - upperSum;
        long long currMaxSum = std::max(upperSum, lowerSum);
        if (currMaxSum < minMaxSum) {
            minMaxSum = currMaxSum;
            cutType = 'H';
            cutPos = k;
        }
    }
    std::cout << cutType << " " << cutPos << std::endl;
}

int main() {
    int t;
    std::cin >> t;
    while (t--) {
        int n, m;
        std::cin >> n >> m;
        solve(n, m);
    }
    return 0;
}
```

**时间复杂度分析**：
对于每个测试用例，计算总和的时间复杂度为 $O(1)$，竖切和横切的遍历分别需要 $O(m)$ 和 $O(n)$ 的时间，所以总时间复杂度为 $O(t\times(n + m))$，其中 $t$ 是测试用例的数量。

**空间复杂度分析**：
代码中只使用了有限的变量，空间复杂度为 $O(1)$。

---

## 作者：20111019Yu (赞：1)

### 思路
我们可以发现如果暴力，明显会起飞，所以要考虑优化，最好是将第 $i$ 行之前和第 $j$ 列之前的数都统计一边，但 $1\leq nm\leq 10^9$ 所以也会超时，因此要进一步优化。

我们将相邻两列和两行的数作比较可以得出他们之间的关系。

行:
$$\begin{aligned}
{} & \sum_{j=1}^{m}{(i-1)\cdot m+j}-\sum_{j=1}^{m}{(i-2)\cdot m+j}\\
& = \sum_{j=1}^{m}{(i-1)\cdot m}-\sum_{j=1}^{m}{(i-2)\cdot m}\\
& = \sum_{j=1}^{m}{m}\\
& = m^2
\end{aligned}$$

列:
$$\begin{aligned}
{} & \sum_{i=1}^{n}{(i-1)\cdot m+j}-\sum_{i=1}^{n}{(i-1)\cdot m+(j-1)}\\
& = \sum_{i=1}^{n}{j}-\sum_{i=1}^{n}{(j-1)}\\
& = n
\end{aligned}$$

计算出来了以后就可以用三分查找 $\max(\sum x, \sum y)$ 的最小值了，因为我求的值是单谷函数，所以我要用三分。

时间复杂度: $\mathcal{O(t\cdot \log_{2}{n})}$

### code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t, n, m, sum, rowx, rowy, senx, seny;

__int128 check(bool ops, __int128 row){
	if(ops){
		__int128 cow = rowx * row + (row - 1) * row / 2 * senx;
		return max(cow, sum - cow);
	}
	else{
		__int128 cow = rowy * row + (row - 1) * row / 2 * seny;
		return max(cow, sum - cow);
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
// 	freopen("cut.in", "r", stdin);
// 	freopen("cut.out", "w", stdout);
	cin >> t;
	while(t--){
		__int128 minnx = LONG_LONG_MAX, minny = LONG_LONG_MAX, idx = 0, idy = 0;
		cin >> n >> m;
		rowx = (m + 1) * m / 2;
		rowy = ((n - 1) * m + 2) * n / 2;
		senx = m * m, seny = n;
		sum = rowx * n + (n - 1) * n / 2 * senx;
		__int128 l = 0, r = n - 1;
		while(l < r){
			__int128 lmid = l + (r - l) / 3, rmid = r - (r - l) / 3;
			if(check(1, lmid) <= check(1, rmid)) r = rmid - 1;
			else l = lmid + 1;
		}
		minnx = check(1, l);
		idx = l + 1;
		l = 0, r = m - 1;
		while(l < r){
			__int128 lmid = l + (r - l) / 3, rmid = r - (r - l) / 3;
			if(check(0, lmid) <= check(0, rmid)) r = rmid - 1;
			else l = lmid + 1;
		}
		minny = check(0, l);
		idy = l + 1;
		if(minnx < minny) printf("H %d\n", idx);
		else printf("V %d\n", idy);
	}
	return 0;
// 	fclose(stdin);
// 	fclose(stdout);
}
```
~~考场三分没写等于号挂掉，啊~~

---

## 作者：_wangleting123_ (赞：1)

## 这道题可以使用贪心算法进行求解。

从题目的要求可以看出，我们只关心竖切和横切的位置，而不关心具体是哪一部分是 $x$ 还是 $y$。所以，我们只需要找到合适的竖切和横切位置即可。

我们可以观察一下数表的特点：

当 $n>m$ 时，我们可以选择横切，将数表分成两部分，一部分包含第1行到第 $i-1$ 行，另一部分包含第 $i$ 行到第 $n$ 行。

当 $n≤m$ 时，我们可以选择竖切，将数表分成两部分，一部分包含第1列到第 $j-1$ 列，另一部分包含第 $j$ 列到第 $m$ 列。

注意：如果数表的行数 $n$ 与列数 $m$ 相等，我们可以选择竖切或横切，因为两种方式得到的结果是相同的。

根据题目要求，我们需要选择竖切或横切，使得 $\max(\sum x,\sum y)$ 最小。可以发现，我们只需要考虑竖切和横切的位置，而具体的数表分割方式并不影响结果，所以我们只需要确定竖切或横切的位置即可。

---

## 作者：_ChongYun_ (赞：0)

求一个矩阵 $a$ 被切行或切列变成两个矩阵 $x$ 和 $y$，最小的 $\max(\sum x,\sum y)$。

首先考虑 $\small\sum x$ 和 $\small\sum y$ 的求法。

若切第 $u$ 行。

发现计算矩阵 $x$ 的总和就是计算一个首项为 $1$，末项为 $a_{x-1,m}$ 的等差数列，即可 $\mathcal{O}(1)$ 计算。则：

$$\begin{aligned}
	\small\sum x   
  		&=\large\sum_{i=1}^{u-1}{\large\sum_{j=1}^m}    {{a_{i,j}}} \\
		&=\frac{a_{i,j}(a_{i,j}+1)}{2}
\end{aligned}$$ 

$$\begin{aligned}
	\small\sum y	
    	&=\left(\large\sum_{i=1}^{n}\sum_{j=1}^{m}{a_{i,j}}\right) - \small\sum x\\
      &=\frac{nm(nm+1)}{2} - \frac{a_{i,j}(a_{i,j}+1)}{2}
    \end{aligned}$$
    
若切第 $u$ 列，就比较抽象一点。

会发现矩阵 $x$ 的每一列都是一个公差为 $n$ 的等差数列，而下一列的等差数列的首项比这一列大 $1$。又因为一共有 $n$ 项，所以每一列的总和比上一列大 $n$。

使用等差数列求和公式 $\mathcal{O}(1)$ 计算。则：

$$\begin{aligned}
	\small\sum x   
  		&=\large\sum_{i=1}^{n}{\large\sum_{j=1}^{u-1}}    {{a_{i,j}}} \\
		&=(u-1)\left(\frac{n(a_{n,1}+1)}{2}\right)+\frac{(u-2+1)(u-2)}{2} \\
      &=(u-1)\left(\frac{n(a_{n,1}+1)}{2}\right)+\frac{(u-1)(u-2)}{2}
\end{aligned}$$ 

$$\begin{aligned}
	\small\sum y	
    	&=\left(\large\sum_{i=1}^{n}\sum_{j=1}^{m}{a_{i,j}}\right) - \small\sum x\\
      &=\frac{nm(nm+1)}{2} - \left((u-1)\left(\frac{n(a_{n,1}+1)}{2}\right)+\frac{(u-1)(u-2)}{2}\right)
    \end{aligned}$$

已经可以计算出 $\sum x$ 和 $\sum y$，因为求的答案最大值最小，且行、列分别具有单调性，所以考虑二分。
 
具体地，进行四次二分。分别查找：

- 切行，寻找第一个 $\sum x \ge \sum y$。

- 切行，寻找最后一个 $\sum x \leq \sum y$。

- 切列，寻找第一个 $\sum x \ge \sum y$。

- 切列，寻找最后一个 $\sum x \leq \sum y$。

取四种答案的最小值即为答案。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int q,n,m,sum=0,ans[10];
int id(int x,int y){ return (x-1)*m+y; }
int f(int op,int x){ 
	int u;
	if(!op) u=(id(x-1,m)+1)*id(x-1,m)/2;
	else u=(id(n,1)+1)*n/2*(x-1)+(x-1)*(x-2)/2*n;
	return u;
}
signed main(){
	cin>>q;
	while(q--){
		cin>>n>>m;
		memset(ans,0,sizeof(ans));
		sum=(n*m+1)*n*m/2;
		int l=1,r=m,mid;
		while(l<=r){
			mid=(l+r)>>1;
			if(f(1,mid)>=sum-f(1,mid)){
				r=mid-1;
				ans[2]=mid;
			}
			else l=mid+1;
		}
		l=1,r=m;
		while(l<=r){
			mid=(l+r)>>1;
			if(f(1,mid)<=sum-f(1,mid)){
				l=mid+1;
				ans[1]=mid;
			}
			else r=mid-1;
		}
		l=1,r=n;
		while(l<=r){
			mid=(l+r)>>1;
			if(f(0,mid)>=sum-f(0,mid)){
				r=mid-1;
				ans[4]=mid;
			}
			else l=mid+1;
		}
		l=1,r=n;
		while(l<=r){
			mid=(l+r)>>1;
			if(f(0,mid)<=sum-f(0,mid)){
				l=mid+1;
				ans[3]=mid;
			}
			else r=mid-1;
		}
		int minn=LLONG_MAX,anss;
		for(int i=(m==1?3:1);i<=(n==1?2:4);i++){
			if(max(f((i<=2?1:0),ans[i]),sum-f((i<=2?1:0),ans[i]))<minn){
				minn=max(f((i<=2?1:0),ans[i]),sum-f((i<=2?1:0),ans[i]));
				anss=i;
			}
		}
		cout<<(anss<=2?"V ":"H ")<<ans[anss]<<endl; 
	}
	return 0;
}
```

---

## 作者：lkjzyd20 (赞：0)

### 思路
我们首先化简算出数表的式子。

横切原式
$$
  \\ \sum_{i=1}^{n} \sum_{j=1}^{k}i\times m -m + j
  \\ =((n^2-1)km + (k^2+1)n)\div2
$$

竖切原式
$$
  \\ \sum_{i=1}^{k} \sum_{j=1}^{n}i\times m -m + j
  \\ =((k^2-1)m^2 + (m+1)km)\div 2
$$

考虑二分横/竖切时两部分最平均的位置。注意可能有偏差，记得对二分结果进行 check。

### 代码如下
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
#define rep(i, l, r) for(int i = l; i <= r; ++ i)
#define per(i, r, l) for(int i = r; i >= l; -- i)

int Q, n, m;
int check(int n, int m, int m1)
{
    return ((n - 1) * n * m * m1 + (m + 1) * n * m) / 2;
}

void work()
{
    int l = 1, r = m, sum = check(n, m, m), ans1 = 1e19, ans2 = 1e19, pos1 = 1, pos2 = 1;
    for(; l <= r;)
    {
        int mid = (l + r) >> 1;
        int k1 = check(n, mid - 1, m), k2 = sum - k1;
        if(k1 < k2) l = mid + 1;
        else r = mid - 1;
        if(max(k1, k2) < ans1) ans1 = max(k1, k2), pos1 = mid;
    }
    int mid = l - 1;
    int k1 = check(n, mid - 1, m), k2 = sum - k1;
    if(max(k1, k2) <= ans1) ans1 = max(k1, k2), pos1 = mid;
    l = 1, r = n;
    for(; l <= r;)
    {
        int mid = (l + r) >> 1;
        int k1 = check(mid - 1, m, m), k2 = sum - k1;
        if(k1 < k2) l = mid + 1;
        else r = mid - 1;
        if(max(k1, k2) < ans2) ans2 = max(k1, k2), pos2 = mid;
    }
    mid = l - 1;
    k1 = check(mid - 1, m, m), k2 = sum - k1;
    if(max(k1, k2) <= ans2) ans2 = max(k1, k2), pos2 = mid;
    if(ans1 <= ans2) printf("V %lld\n", pos1);
    else printf("H %lld\n", pos2);
}
main()
{
    scanf("%lld", &Q);
    for(; Q; -- Q)
    {
        scanf("%lld%lld", &n, &m);
        work();
    }
    return 0;
}
```

---

## 作者：Aveiro7 (赞：0)

**原题链接**：[传送门](https://www.luogu.com.cn/problem/P9762)

## 思路：

观察 $a_{i,j}$，其实就是 ``123456``……一直往下排。

那么计算总和的式子就是：$sum=mn \times (mn+1)\div 2$。

然后题目要求我们切一刀分成和不同的两块。对于竖着切，设切了 $k$ 列，左边那块的和为：

$$\sum_{i = 1}^{n}\sum_{j = 1}^{k}(i-1)\times m+j=\sum_{i = 1}^{n}km(i-1)+k(k+1)\div 2=kmn(n-1)\div 2+nk(k+1)\div 2=\frac{nk(mn-m+k+1)}{2}$$  

对于横着切，一样的，设切了 $k$ 行，上面的那块和是等差数列，末项为 ，那么和为：$\frac{mk(mk+1)}{2}$。

然后我们可以 $O(1)$ 求和，那么枚举行列就可以得出 $O(n+m)$ 的算法。

考虑优化，希望最小化 $\max(\sum x,\sum y)$，那肯定越接近 $\frac {sum}{2}$ 越好，这个时候有两个办法：

* 二分，枚举行列显然有单调性，二分到 $\frac{sum}{2}$，注意 $\pm 1$ 的误差，都要算一遍。

* 直接解方程解出 $k$，也要注意 $\pm 1$ 的误差。

**完结撒花！**

原文链接：[传送门](https://www.cnblogs.com/LAK666/p/16754150.html)

---


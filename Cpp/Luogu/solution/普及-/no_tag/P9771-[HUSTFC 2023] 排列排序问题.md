# [HUSTFC 2023] 排列排序问题

## 题目描述

JokerShaco 有一个长度为 $n$ 的排列 $p$，他认为一个排列必须是有序的，所以他打算将其进行排序。

他可以对这个排列进行如下操作：
- 将这个排列切割成若干个序列（也可以不切割，保持原样），每个序列至少含有一个元素；
- 选择其中一些序列并将它们翻转；
- 将这些序列按照他的意愿重新组合拼接得到一个新的排列。

JokerShaco 认为切割操作非常累，他想知道如果必须把这个排列变得有序，至少需要切割多少次。

一个长度为 $n$ 的排列的定义为，包含从 $1$ 到 $n$ 这 $n$ 个不同的整数的序列，每个整数恰好出现一次。

序列翻转的定义为，假设存在一个长度为 $m$ 的序列 $[a_1,a_2,\dots,a_{m-1},a_m]$，那么将这个序列翻转后将会得到 $[a_m,a_{m-1},\dots,a_2,a_1]$。

## 样例 #1

### 输入

```
5
1 2 3 5 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
3 2 1
```

### 输出

```
0
```

# 题解

## 作者：_O_v_O_ (赞：8)

水题。

首先，我们要知道当 $a_i$ 和 $a_{i+1}$ 被切在了一起，那么它们肯定就不会分开。

那么，基于排列的性质，我们可以得出：当 $|a_i-a_{i-1}|>1$ 时，它们必须分开。

最终答案就为 $|a_i-a_{i-1}|>1$ 的数量。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a[1000005],ans;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i==1) continue;
		if(abs(a[i]-a[i-1])!=1) ans++;
	}
	cout<<ans;
	return 0;
}
```

Upd in 23.11.5：修了一些代码。

---

## 作者：woshiguage (赞：2)

# P9771 [HUSTFC 2023] 排列排序问题

模拟题，结论难想，想对了就是入门题。

本题看似复杂，实际上由于只有翻转操作，而且合并时还不能分割子段，所以必须在翻转之前所有切出的字序列都有序，而且只能为公差为 $1$ 或 $-1$ 的等差数列。

每个数只要遍历一次，复杂度 $O(n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);//关闭同步
    int n;
    cin>>n;
    int a[1000005]={0};
    for(int i=1;i<=n;i++)cin>>a[i];//输入
    int ans=0;
    for(int i=1;i<=n;){//循环，手动自增i
        if(a[i]==a[i+1]+1){//如果单调递增
            ans++;//这是一个子段
            while(a[i]==a[i+1]+1&&i<=n)i++;//找到子段的末位
            i++;//切换到下一个段
        }
        else if(a[i]==a[i+1]-1){//如果单调递减
            ans++;//这是一个子段
            while(a[i]==a[i+1]-1&&i<=n)i++;//找到子段的末位
            i++;//切换到下一个段
        }else{//如果单独成段
            ans++;//这也是一段
            i++;//切换到下一个段
        }
    }
    ans--;//k个子段切k-1刀
    cout<<ans;//输出
}
```

---

## 作者：sky_chen (赞：1)

【HUSTACM】此题解为官方题解。

考虑先把所有差值的绝对值不为 $1$ 的位置断开（显然这些位置是必须断开的），之后每一段也一定能够组成按顺序递增的排列，因此记录一下断开的次数即可。

时间复杂度 $O(n)$。



---

## 作者：sfqxx1 (赞：1)

## 题外话

赛时没有调出来，赛后马上悟了。

## 题意

给定一个序列，求至少几次切割才能把序列变成有序。

## 思路

假设 `ans` 为 $0$，`f` 为 $0$，`p` 为序列的第一个元素。


我们可以遍历原始序列的每一个元素（从第二个元素开始），对于每一个元素：

   - 如果当前的期望规则是升序（`f` 为 $1$），并且当前元素的值不等于前一个元素的值加 $1$，那么增加一次切割，并将期望规则设置为未确定。

   - 如果当前的期望规则是降序（`f` 为 $-1$），并且当前元素的值不等于前一个元素的值减 $1$，那么增加一次切割，并将期望规则设置为未确定。

   - 如果当前的期望规则未确定（`f` 为 $0$），那么根据当前元素和前一个元素的关系来确定新的期望规则。如果当前元素的值等于前一个元素的值加 $1$，那么将期望规则设置为升序；如果当前元素的值等于前一个元素的值减 $1$，那么将期望规则设置为降序；否则，增加一次切割。

   - 将 `p` 更新为当前元素的值。
   
时间复杂度为 $O(n)$，可以通过此题。
   
## 代码

```python
n = int(input())
a = list(map(int, input().split()))#序列
ans = 0
f = 0
p = a[0]
for i in range(1, n):
    if f == 1:
        if a[i] != p + 1:
            ans += 1
            f = 0
    elif f == -1:
        if a[i] != p - 1:
            ans += 1
            f = 0
    else:
        if a[i] == p + 1:
            f = 1
        elif a[i] == p - 1:
            f = -1
        else:
            ans += 1
    p = a[i]
print(ans)
```



---

## 作者：Unstalian (赞：0)

### 题意：

将一个长度为 $n$ 的序列 $a$ 分割为若干个区块，通过翻转这些区块并排序使得 $a$ 有序（上升 or 下降）。

### 思路：

根据观察可知，理论上最多切割 $n$ 次必能使序列排列有序，即将每个数都切割开。

我们的目的是让分割的次数尽可能少。

进而得到，对任一严格上升或下降的子序列（每个相邻元素相差 1），将其分割出来可保证其正确性，因为可以随意的翻转且一定是最终序列的一段连续部分。

反证：若存在分割序列中存在相邻元素不相差一的最优解，则无论怎么翻转，该序列都不可能有序，所以不成立。

终上所述，我们只需要求 $a$ 中元素严格连续的区块数。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 1000006
int n, ans;
int a[maxn];
int main()
{
	cin >> n;
	for (int i = 1;i <= n;i ++)	
		scanf("%d",&a[i]);
	for (int i = 2;i <= n;i ++)
	{
		if(a[i] + 1== a[i-1] || a[i] - 1 == a[i-1])
		{
			continue;//连续就continue；
		}
		ans ++;//不连续就分割
	}
	cout << ans;
}
```


---

## 作者：tder (赞：0)

[$\Large\color{black}\textbf{P9771 [HUSTFC 2023] 排列排序问题}$](https://www.luogu.com.cn/problem/P9771) $\Large\textbf{题解}$

[$\textbf{题目传送门}$](https://www.luogu.com.cn/problem/P9771)

[$\textbf{更好的阅读体验}$](https://www.luogu.com.cn/blog/tder/solution-P9771)

~~数学题~~

---

$$\large\textbf{思路}$$

考虑将其分为若干个递增或递减的连续数列，这样经过重排一定能变为 $1\to n$ 的递增排列。只需遍历数组，找到每个递增或递减的连续数列，若有单独一数，则单独成块即可。

---

$$\large\textbf{代码}$$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
int n, p[N], cnt;
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i = 1; i <= n; i++) cin>>p[i];
	for(int i = 1; i <= n; i++, cnt++) // 找到每一个块
		if(p[i] + 1 == p[i + 1]) // 递增序列的开始
			while(p[i] + 1 == p[i + 1]) i++; // 找至结束
		else if(p[i] - 1 == p[i + 1]) // 递减序列的开始
			while(p[i] - 1 == p[i + 1]) i++;
		// 单独成块直接遍历下一个即可
	cout<<cnt - 1; // 最后一块会多算一个
	return 0;
}

```

---

## 作者：littleqwq (赞：0)

# P9771 [HUSTFC 2023] 排列排序问题题解

### 前言：

- 欢迎发送评论哦！

- [博客食用更佳](https://www.luogu.com.cn/blog/wangzihandeboke1026/solution-p9771)

### 大致思路：

这道题我们其实可以成为最长连号加强版，因为这道题其实就是求有多少处地方相对于前面是没有顺序的，也就是不相差 1。就是分割出尽可能少的有序的子序列，因此分割次数才会少，所以说我们只需一个个判断过去，找出无序之处，统计次数。

### 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
int n,a[1000001],cnt,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cnt=n-1;
	for(int i=2;i<=n;i++){
		if(a[i]-a[i-1]==1){
			cnt--;
		}else if(a[i]-a[i-1]==-1){
			cnt--;
		}else{
			ans++;
		}
	}
	cout<<cnt<<endl;
	return 0;
}
```

### 后言：

感谢您的观看，这道题就完成了。

---

## 作者：Aveiro7 (赞：0)

# 思路：

将序列分为多段，每段必须连续并且单调，输出段数 $-1$ 即可。

# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n,a[N];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	int res=0,f=0,p=a[1];
	for(int i=2;i<=n;i++){
		if(f==1){
			if(a[i]!=p+1) res++,f=0;
		}
		else if(f==-1){
			if(a[i]!=p-1) res++,f=0;
		}
		else{
			if(a[i]==p+1) f=1;
			else if(a[i]==p-1) f=-1;
			else res++;
		}
		p=a[i];
	}
	cout<<res;
	return 0;
}
```

原文出处:[传送门](https://blog.csdn.net/JungleZRD/article/details/133983566?ops_request_misc=&request_id=&biz_id=102&utm_term=HUSTFC%202023%20%E6%8E%92%E5%88%97%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-133983566.142^v96^pc_search_result_base4&spm=1018.2226.3001.4187)

---

## 作者：linyukun (赞：0)

## 1. 前言
本文的分析会比较通俗，自己要多去思考，麻烦一定 _仔细全部看完_，有异议、不懂或认为可以优化请私信反馈呢。  

## 2. 题目解析：
首先，分析一下操作：
+ 第一种，分割序列，不需要解释了。
+ 第二种，反转序列，可以让我们在考虑不用考虑是正序还是倒序。
+ 第三种，组合序列，可以保证在子序列全部有序的情况下，母序列必然有序。  

根据第二第三种操作，可以抽象题意为：把给定序列分割为尽可能少的由连续数字组成的有序序列。  
那这个“连续数字”从何而来呢？
+ 首先，显而易见的，两个非连续数字中间不分割，那么必有数字的大小位于二者之间，也就是应该在它们之间的位置。
+ 没有任何支持插入的操作，所以必须分割。
+ 分割成的序列必然是连续的数字。同时因为“每个整数恰好出现一次”，所以这样的序列必然有序。

于是我们得出结论：**统计前后不是连续数字的数量，也就是分割的地方**。
## 3. 提示要点：
* 每个整数恰好出现一次代表**连续数字串要么是递增要么递减**，不存在 $1,2,1$ 之类情况，那必然出现重复。

* 理解后两个操作的用处，不要多想。
## 4. 代码写作：
理论存在，实践开始。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],b,cnt;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=2;i<=n;i++){
		if(abs(a[i]-a[i-1])>1){
			cnt++;
		}
	}
	cout<<cnt;
	return 0;
}
```

## 5. 总结鸣谢：
**感谢管理大大的的审核。**

---


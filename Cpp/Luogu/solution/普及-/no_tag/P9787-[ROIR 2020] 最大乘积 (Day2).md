# [ROIR 2020] 最大乘积 (Day2)

## 题目描述

**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal

给定一个自然数组成的数组 $[a_1,a_2,\ldots,a_n]$。  
定义一个数组的权值为这个数组中所有数的和。

请把这个数组划分为两个非空数组 $[a_1,a_2,\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\ldots,a_n]$，使得它们的权值之积尽量大。  
你需要确定能够使得两个数组权值之积最大的 $i$。

## 说明/提示

#### 【样例 1 解释】
如果你选择 $i=1$，则权值之积为 $1 \cdot (2+3) = 5$。
如果你选择 $i=2$，则权值之积为 $(1+2) \cdot 3 = 9$。

#### 【数据范围】
对于 $100\%$ 的数据，$2 \le n \le 2\cdot 10^5, 1 \le a_i \le 10^9$。  
具体数据限制如下表：

|子任务编号|分值|限制|附加限制|
|:-:|:-:|:-:|:-:|
|$1$|$10$|$2 \le n \le 5000$|$\sum a_i \le 10^9$|
|$2$|$10$|$2 \le n \le 5000$|$a_1 = a_2 = \ldots = a_n$|
|$3$|$20$|$2 \le n \le 5000$|$a_i \le 10^9$|
|$4$|$20$|$2 \le n \le 200000$|$\sum a_i \le 10^9$|
|$5$|$20$|$2 \le n \le 200000$|$a_1 = a_2 = \ldots = a_n$|
|$6$|$20$|$2 \le n \le 200000$|$a_i \le 10^9$|

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# 题解

## 作者：KDL_ANIPLEX (赞：3)

## 题目分析
### 题意简述
给定一个自然数组成的数组 $[a_1,a_2,\ldots,a_n]$。  
求出一个整数 $i(1\le i\le n)$，使得 $\sum_{j=1}^{i}{a_j}$ 与 $\sum_{j=i+1}^{n}{a_j}$ 的积最大。  
对于 $100\%$ 的数据，$2 \le n \le 2\cdot 10^5, 1 \le a_i \le 10^9$。
### 题目分析
1. 由于 $n\le 2\cdot 10^5$，考虑 $O(n)$ 的算法。
2. 基本思路：
- 读入，读入的同时进行前缀和（记录 $\sum_{j=1}^{i}{a_j}$）。
- 重头扫一遍，根据“和不变，差小积大”的原理，记录两个因数差的绝对值最小时的 $i$。
- 输出 $i$。
3. 复杂度：
- 读入、前缀和：$O(n)$。
- 重头扫一遍：$O(n)$。
- 输出：$O(1)$。  
整体复杂度为 $O(n)$。
4. 注意事项：
- 开 `longlong`。
### 代码
```cpp
#include<cstdio>
long long a[200001],s=1e17,n,l;
long long abss(long long x,long long y)//绝对值函数
{
    if (x>y) return x-y;
    return y-x;
}
int main(){
    scanf ("%d",&n);
    for (int i=1;i<=n;i++){
        int u;
        scanf ("%d",&u);//读入。
        a[i]=a[i-1]+u;//前缀和。
    }
    for (int i=1;i<=n;i++){
        long long o=abss(a[i],a[n]-a[i]);//两个因数差的绝对值。
        if (o<s) s=o,l=i;//记录目前最小的差与答案。
        else break;//小优化：如果已经比 s 大，那后面的也会比 s 大，所以退出。
    }
    printf ("%d\n",l);
    return 0;
}
```

---

## 作者：qwertim (赞：2)

前缀和入门题，建议评橙。

我们只需要预处理 $a$ 数组的前缀和，在枚举 $i$ 并用 $O(1)$ 算出来 $\displaystyle\sum_{j=1}^i a_i$ 乘上 $\displaystyle\sum_{j=i+1}^n a_i$ 的值再取最大就好了。

注意运算时 $x$ 最大可能到 $10^{28}$，所以一定要开 `__int128`。

```cpp
#include<bits/stdc++.h>
#define int __int128
#define fo(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
int n,a,sum[200005],maxn,ans;
inline int read(){
	char c=getchar();
	int asb=0,ctx=1;
	while(c<'0'||c>'9')ctx=(c=='-'?-1:ctx),c=getchar();
	while(c>='0'&&c<='9')asb=asb*10+(c^48),c=getchar();
	return asb*ctx;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
signed main(){
	n=read();
	fo(i,1,n)a=read(),sum[i]=sum[i-1]+a;
	fo(i,1,n){
		int x=sum[i]*(sum[n]-sum[i]);
		if(x>maxn)maxn=x,ans=i;
	}
	write(ans);
	return 0;
}
```


---

## 作者：cff_0102 (赞：2)

众所周知，和一定，差小积大。

先在输入的时候计算 $a$ 数组的总和 $s$，然后再从头到尾跑一遍，看看什么时候这个“差”最小。假设前 $i$ 个数之和是 $s_1$，剩下的数之和是 $s_2$，则 $s_2=s-s_1$。只要计算出每个 $i$ 时的 $|s_1-s_2|$，最后输出最小值对应的那个 $i$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[229028];
int main(){
	ios::sync_with_stdio(false);
	int n;cin>>n;
	long long s=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		s+=a[i];
	}
	long long s1=0,s2;
	long long mn=11451419198103327,m;//mn 记录 |s1-s2| 的最小值，m 记录此时的 i（最后输出时记得 +1） 
	for(int i=0;i<n;i++){
		s1+=a[i];
		s2=s-s1;
		if(abs(s1-s2)<mn){
			mn=abs(s1-s2);
			m=i;
		}
	}
	cout<<m+1;//下标从 0 开始，所以输出时要再 +1 
	return 0;
}
```

实际上后面那一段可以二分的，这样更快。

---

## 作者：Aveiro7 (赞：1)

### 题目大意

给定一个自然数组成的数组 $\begin{bmatrix} a_1,a_2,…,a_n\end{bmatrix}$。需要把这个数组划分为两个非空数组， $\begin{bmatrix}a_1,a_2,…,a_i\end{bmatrix}$ 和 $\begin{bmatrix} a_i+1,a_i+2,…,a_n\end{bmatrix}$，使得它们的权值之积尽量大，需要确定能够使得两个数组权值之积最大的 $i$。
### 思路

这道题需要用到两个关键的知识点：

* 前缀和。

* 当和一定的情况下，差越小积越大。

我们可以用数组 $a$ 来记录前缀和，使 $|a_n-2 \times a_i|$ 最小即可。

分别记录当前最小的 $|a_n-2 \times a_i|$ 以及对应的 $i$，随后循环遍历 $i$ 即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a[200002],n,i,m=2e9+5,ans=-1;
int main(){
	cin>>n;
	for(i=1; i<=n; i++)
    {
        cin>>a[i];
        a[i]+=a[i-1];
    } 
	for(i=1; i<n; i++) 
    if(abs(a[n]-2*a[i])<=m) 
    {
        m=abs(a[n]-2*a[i]);
        ans=i;
    }
	cout<<ans;
	return 0;
}
```


---

## 作者：SunnyLi (赞：1)

# 思路

从来没想过这道题可以用 Python 水过。

这道题是明显的前缀和，只需要进行预处理，每次取值 $\displaystyle s_i=\sum_{k=1}^i a_k$，之后再依次枚举，每次保留最大值 $\max(maxn,s_i\times(s_n-s_i))$ 即可。需要额外一个变量保存编号。

# AC 代码

```python
a=[0]
n=int(input())
maxn=-114514
cnt=0
t=input().split(" ")
for i in range(1,n+1):
    a.append(a[i-1]+int(t[i-1]))
for i in range(1,n):
    x=a[i]*(a[n]-a[i])
    if(maxn<x):
        maxn=a[i]*(a[n]-a[i])
        cnt=i
print(cnt)
```

---

## 作者：ARIS1_0 (赞：1)

这里提供一种比较暴力的做法，~~因为我当时没有想到数学方法~~。

## 题意

给出一个长度为 $n$ 的数组，现要求将该数组分割成两个非空数组，输出能使得 $[a_1,a_2,\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\ldots,a_n]$ 两数组所有元素之和的乘积最大的 $i$。若有多个解，输出任意一个。

### 数据范围

$2\le n\le 2\times 10^5$，$1 \le a_i \le 10^9$。

## 思路

预处理前缀和记录数组之和，此后枚举分割点 $i$，对于每一个 $i$，使用前缀和得到两个数组之和再乘起来比较之前的最大值即可。需要注意的是这样可能会导致爆 `long long`，使用 `__int128` 即可。

## code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,w=1;
	char ch=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+(ch-'0');
		ch=getchar();
	}
	return x*w;
}
ll n,a[200005];
ll sum[200005];__int128 tmp;
int ans=1;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		sum[i]=sum[i-1]+a[i];
	}
	for(int i=1;i<n;i++){//不需要枚举到底，因为题目要求是非空数组
		__int128 tmp1=sum[i]-sum[0];
		__int128 tmp2=sum[n]-sum[i];
		__int128 now=tmp1*tmp2;
		if(now>=tmp){
			ans=i;
			tmp=now;
		}
		//tmp=now;把上面的语句改到这里也能过，应该是数据的问题。
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：MoSalah (赞：1)

这道题寄了好几发是因为高精。

确实是一道简单题，考虑维护一下前缀和然后直接 $O(n)$ 搞就完事了。

你可以手写高精度，也可以使用 __int128，均可通过此题。

如果你连 __int128 的读入和输出都不想写，你可以使用 Python。

C++ Code:
```cpp
// #pragma GCC optimize(2)
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast")
// #pragma GCC optimize("inline")
// #pragma GCC optimize("-fgcse")
// #pragma GCC optimize("-fgcse-lm")
// #pragma GCC optimize("-fipa-sra")
// #pragma GCC optimize("-ftree-pre")
// #pragma GCC optimize("-ftree-vrp")
// #pragma GCC optimize("-fpeephole2")
// #pragma GCC optimize("-ffast-math")
// #pragma GCC optimize("-fsched-spec")
// #pragma GCC optimize("unroll-loops")
// #pragma GCC optimize("-falign-jumps")
// #pragma GCC optimize("-falign-loops")
// #pragma GCC optimize("-falign-labels")
// #pragma GCC optimize("-fdevirtualize")
// #pragma GCC optimize("-fcaller-saves")
// #pragma GCC optimize("-fcrossjumping")
// #pragma GCC optimize("-fthread-jumps")
// #pragma GCC optimize("-funroll-loops")
// #pragma GCC optimize("-fwhole-program")
// #pragma GCC optimize("-freorder-blocks")
// #pragma GCC optimize("-fschedule-insns")
// #pragma GCC optimize("inline-functions")
// #pragma GCC optimize("-ftree-tail-merge")
// #pragma GCC optimize("-fschedule-insns2")
// #pragma GCC optimize("-fstrict-aliasing")
// #pragma GCC optimize("-fstrict-overflow")
// #pragma GCC optimize("-falign-functions")
// #pragma GCC optimize("-fcse-skip-blocks")
// #pragma GCC optimize("-fcse-follow-jumps")
// #pragma GCC optimize("-fsched-interblock")
// #pragma GCC optimize("-fpartial-inlining")
// #pragma GCC optimize("no-stack-protector")
// #pragma GCC optimize("-freorder-functions")
// #pragma GCC optimize("-findirect-inlining")
// #pragma GCC optimize("-fhoist-adjacent-loads")
// #pragma GCC optimize("-frerun-cse-after-loop")
// #pragma GCC optimize("inline-small-functions")
// #pragma GCC optimize("-finline-small-functions")
// #pragma GCC optimize("-ftree-switch-conversion")
// #pragma GCC optimize("-foptimize-sibling-calls")
// #pragma GCC optimize("-fexpensive-optimizations")
// #pragma GCC optimize("-funsafe-loop-optimizations")
// #pragma GCC optimize("inline-functions-called-once")
// #pragma GCC optimize("-fdelete-null-pointer-checks")
#include <bits/stdc++.h>
using namespace std;
#define int __int128
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define rep1(i,a,b) for(int i=a;i<b;i++)
#define rep2(i,a,b) for(int i=a;i>=b;i--)
#define clean(x) memset(x,0,sizeof x)
#define dirty(x) memset(x,0x7f,sizeof x)
template <typename T>
inline void read(T &x){
    x=0;
    int f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    x*=f;
    return ;
}
template <typename T>
inline void write(T x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return ;
}
const int N=1e6+5;
int a[N];
signed main(){
    int n;
    read(n);
    int sum=0;
    rep(i,1,n) read(a[i]),sum+=a[i];
    int lsum=0,rsum=0;
    int val=0,mxval=0;
    int id=0;
    rep(i,1,n){
        lsum+=a[i];
        rsum=sum-lsum;
        val=lsum*rsum;
        if(val>mxval) mxval=val,id=i;
    }
    write(id);
    return 0;
}
```

Python Code:
```python
def calc(n,a):
    sm=sum(a)
    lsum=0
    mxval=0
    for i in range(n-1):
        lsum+=a[i]
        rsum=sm-lsum
        val=lsum*rsum
        if val>mxval:
            mxval=val
            id=i
    return id+1
n=int(input())
a=list(map(int,input().split()))
ans=calc(n,a)
print(ans)
```

---

## 作者：Jasmine_Aura (赞：1)

### 思路
先求出数组的前缀和，之后从 $1$ 到 $n-1$ 扫一遍 $i$，记录一下  $sum[i]\times (sum[n]-sum[i])$ 的最大值，同时记录 $i$ 即可。

注意：计算时可能会溢出，可以使用 int128 来防止溢出。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
const int MAX=2e5+5;
int arr[MAX],sum[MAX];
template<typename T>
void read(T &x)
{
	x=0;
	int f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=x*10+(ch^48);
		ch=getchar();
	}
	x*=f;
} 
signed main()
{
	int n,maxx=0;
    long long id=1;
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(arr[i]);
		sum[i]=sum[i-1]+arr[i];
	}
	for(int i=1;i<=n-1;i++)
	{
		if(sum[i]*(sum[n]-sum[i])>maxx)
		{
			maxx=sum[i]*(sum[n]-sum[i]);
			id=i;
		}
	}
	cout<<id<<endl;
	return 0;
}
```


---

## 作者：WsW_ (赞：1)

难度约为橙。

---
### 思路
当两个数的和为定值时，两个数差的绝对值越小，两个数的乘积就越大。简称“差小积大”，可以通过矩形面积或者一元二次方程证明，请自行百度。  

回归到这一题，显然我们要使 $\left|\sum\limits_{k=1}^{i}a_k-\sum\limits_{k=i+1}^{n}a_k\right|$ 尽可能地小。  
那么最小的差是多少呢？显然当 $\sum\limits_{k=1}^{i}a_k$ 尽可能靠近 $\dfrac{\sum\limits_{k=1}^{n}a_k}{2}$ 的时候差最小。  
于是先预处理前缀和，然后再二分出最接近总权值一半的地方即可。  

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll sum[200003];
int n,a;

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		sum[i]=sum[i-1]+a;
	}
	int x=upper_bound(sum+1,sum+n+1,sum[n]/2)-sum;
	if(sum[x]-sum[n]/2<sum[n]/2-sum[x-1])cout<<x;//两个位置，一个比一半大，另一个比一半小，判断一下即可
	else cout<<x-1;
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

### 题目大意

给定 $n$ 和数组 $c$，求一个 $i$，使对于 $s=\sum\limits_{j=1}^ic_j$ 和 $t=\sum\limits_{j=i+1}^nc_j$，满足 $s\times t$ 最大。

### 前置知识

- 前缀和。
- 和同近积大。[证明](https://www.luogu.com.cn/paste/m1kz0nqf)。

### 思路

因为 $s+t=\sum\limits_{j=1}^nc_j$ 是不变的，所以 $s$ 和 $t$ 越接近，即 $|s-t|$ 越小，$s\times t$ 越大。

我们用一个数组 $a$ 来记录前缀和。令 $a_j=\sum\limits_{k=1}^jc_k$，则 $s=\sum\limits_{j=1}^ic_j=a_i$，$t=\sum\limits_{j=1}^nc_j-s=a_n-a_i$。使 $|a_n-a_i-a_i|=|a_n-2\times a_i|$ 最小即可。

我们用两个数分别记录当前最小的 $|a_n-2\times a_i|$ 和取到该最小值的 $i$，随后循环遍历所有 $i$ 即可。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

long long a[200002];

int main(){
	int n;
	cin>>n;
	for(int i=1; i<=n; i++){cin>>a[i];a[i]+=a[i-1];} 
	long long m=LONG_LONG_MAX,z=-1;
	for(int i=1; i<n; i++) if(abs(a[n]-2*a[i])<=m) m=abs(a[n]-2*a[i]),z=i;
	cout<<z;
	return 0;
}
```

---

## 作者：CNS_5t0_0r2 (赞：0)

由题意，不难想到枚举 $i$ 的位置，然后用打擂台法比较 $[a_1,a_2,\dots,a_i] \times [a_{i + 1},a_{i + 2},\dots,a_{n}]$，从而求出 $i$，这两个数组的权值可以考虑使用“前缀和”维护。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 9;
int n,ans,id;
int a[N],s[N];
signed main(){
	scanf("%lld", &n);
	for(int i = 1;i <= n;i++){
		scanf("%lld", &a[i]);
		s[i] = s[i - 1] + a[i];
	}
	for(int i = 1;i <= n;i++){
		if(s[i] * (s[n] - s[i]) > ans){
			ans = s[i] * (s[n] - s[i]);
			id = i;
		}
	}
	printf("%lld",id);
	return 0;
}
```

问题是，在极端情况下，这两个权值的积会爆 ``long long``。

因为 $[a_1,a_2,\dots,a_i]$ 和 $[a_{i + 1},a_{i + 2},\dots,a_{n}]$ 的权值和为定值，根据“和同近积大”，两者权值应尽可能接近。

所以我们比较所有的 $|[a_1,a_2,\dots,a_i] - [a_{i + 1},a_{i + 2},\dots,a_{n}]|$，取最小一个的下标 $i$ 即可（题目只要求求任意一个 $i$）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 9;
int n,ans = LLONG_MAX,id = 1;
int a[N],s[N];
signed main(){
	scanf("%lld", &n);
	for(int i = 1;i <= n;i++){
		scanf("%lld", &a[i]);
		s[i] = s[i - 1] + a[i];
	}
	for(int i = 1;i <= n - 1;i++){
		int k = abs(s[i] - (s[n] - s[i]));
		if(k <= ans){
			ans = k;
			id = i;
		}
	}
	printf("%lld",id);
	return 0;
}
```


---

## 作者：Milthm (赞：0)

观察题目，发现可以 $O(n)$。于是考虑前缀和，设 $f_i=\sum_{j=1}^{n}a_j$，每次枚举到 $i$ 时，此时权值之积就是 $f_i\times (f_n-f_i)$，比较最大值即可。

注意必须开 `__int128`。

### AC code

```cpp
#include<iostream>
#define int long long
using namespace std;
int a[200005],n,ans;
__int128 maxn=-1,f[200005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]),f[i]=f[i-1]+a[i];
	for(int i=1;i<=n;++i){
		if(f[i]*(f[n]-f[i])>maxn){
			maxn=f[i]*(f[n]-f[i]);ans=i;
		}
	}
	cout<<ans;
	return 0;
}
```


---


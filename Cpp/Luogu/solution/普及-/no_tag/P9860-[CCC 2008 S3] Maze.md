# [CCC 2008 S3] Maze

## 题目描述

为了赚点钱，你决定参与一个科学实验。你会被喂很多披萨，然后再吃更多的披萨，接着你需要骑着一辆仅靠披萨驱动的滑板车穿越城市。当然，城市里有很多交叉路口，这些路口受到严格控制。有些路口是禁止进入的；有些只允许你在离开路口时向北或向南移动；有些只允许你在离开路口时向东或向西移动；剩下的则允许你朝任意方向（北、南、东或西）移动。

幸运的是，你的科学朋友给了你一张城市地图（在一个披萨盒的背面），上面用一些符号表示你可以如何在城市中移动。具体来说，盒子上有 4 种不同的符号：

- 符号 `+` 表示我们可以从这个位置向任意方向（北/南/东/西）移动。
- 符号 `-` 表示我们只能从这个位置向东或向西移动。
- 符号 `|` 表示我们只能从这个位置向北或向南移动。
- 符号 `*` 表示我们不能占据这个位置。

你的任务是确定从城市的西北角移动到东南角需要经过多少个交叉路口。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
2
2
-|
*+
3
5
+||*+
+++|+
**--+
2
3
+*+
+*+
```

### 输出

```
3
7
-1```

# 题解

## 作者：zhuweiqi (赞：3)

题目大意：给你一个迷宫，其中每个格子可能会有移动方式的限制，求从左上角走到右下角的最少步数。

思路：首先，我们需要排除起点或终点为 ```*``` 的情况，此时显然无解，输出 $-1$。否则，对全图进行一遍 bfs，记 $f_{i,j}$ 为从 $(1,1)$ 走到 $(i,j)$ 的最少步数，初始时需要将 $f$ 数组全部赋值为 $-1$，其中对于当前格子（设为 $(x,y)$）的扩展，需要分类讨论，如果 $a_{x,y}$ 为 ```*```，则不能进行扩展；如果 $a_{x,y}$ 为 ```|```，则只能上下扩展，即只能走到横坐标为 $x\pm1$ 且纵坐标为 $y$ 的格子（前提是这些格子在边界范围之内且尚未被扩展过，下同）；如果 $a_{x,y}$ 为 ```-```，则只能左右扩展，即只能走到横坐标为 $x$ 且纵坐标为 $y\pm1$ 的格子；如果 $a_{x,y}$ 为 ```+```，则上下左右都可以扩展，即可以走到横坐标为 $x\pm1$ 且纵坐标为 $y\pm1$ 的格子。最终，答案即为 $f_{n,m}$ 的值，特别地，由于题目中说道：初始时在左上角和在右上角结束时都算 $1$ 步，故我们需要将 $f_{1,1}$ 的初始值赋值为 $1$。

参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[22][22];
int f[22][22];
queue<pair<int,int>> q;
int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
bool bj(int x,int y){return x>=1 && x<=n && y>=1 && y<=m;}
void bfs(){
	memset(f,-1,sizeof(f));
	f[1][1]=1;
	q.push({1,1});
	while(!q.empty()){
		int x=q.front().first;
		int y=q.front().second;
		q.pop();
		int i,j;
		if(a[x][y]=='|') i=0,j=2;
		if(a[x][y]=='-') i=2,j=4;
		if(a[x][y]=='+') i=0,j=4;
		if(a[x][y]=='*') continue;
		for(;i<j;i++){
			int nx=x+dir[i][0];
			int ny=y+dir[i][1];
			if(bj(nx,ny) && f[nx][ny]==-1){
				f[nx][ny]=f[x][y]+1;
				q.push({nx,ny});
			}
		}
	}
	return;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
		if(a[1][1]=='*' || a[n][m]=='*'){
			printf("-1\n");
			continue;
		}
		bfs();
		printf("%d\n",f[n][m]);
	}
	return 0;
}
```

---

## 作者：ys_kylin__ (赞：1)

这题很简单，就是一道标准的广搜。但是要注意，当当前为 “|” 时，要屏蔽左右的走法，为 “-” 时，要屏蔽上下的走法,然后就是走迷宫了。
### 注意
1. 多测不清空，爆零见祖宗！
1. 因为有多测，所以不能一找到就直接退出程序，可以用 fl 记下。
2. 当全图只有一个数时，直接输出一。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[25][25];
int vis[25][25],dx[]={-1,0,1,0},dy[]={0,1,0,-1};//vis记录走过情况，dx,dy为方向。
struct node {
	int x,y,step;
}q[405];//手写队列，方便又快
int n,m,fl;
void bfs() {
	int head=1,tail=1;
	q[head].x=q[head].y=q[head].step=1;
	while(head<=tail) {
		for(int i=0;i<4;i++) {
			if(s[q[head].x][q[head].y]=='|' && (i==1 || i==3)) continue;//判断只能走上下
			if(s[q[head].x][q[head].y]=='-' && (i==0 || i==2)) continue;//判断只能走左右
			int nx=q[head].x+dx[i],ny=q[head].y+dy[i];
			if(nx>n || ny>m || nx<1 || ny<1 || vis[nx][ny]==1) continue;
			vis[nx][ny]=1;
			q[++tail].x=nx,q[tail].y=ny,q[tail].step=q[head].step+1;
			if(nx==n && ny==m) {
				printf("%d\n",q[tail].step);
				fl=1;
				goto brk;//多测不能 exit(0),goto可以直接跳到指定位置
			}
		}
		head++;
	}
	brk:;//指定位置
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--) {
		fl=0;
		memset(vis,0,sizeof vis);
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) {
			scanf("%s",s[i]+1);
		}
		if(n==1 && m==1) {
			printf("1\n");
			continue;
		}
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=m;j++) {
				if(s[i][j]=='*') vis[i][j]=1;//不能走的话直接判定为走过
			}
		}
		bfs();
		if(!fl) printf("-1\n");//判误解
	}
	return 0;
}

```

---

## 作者：Loser_Syx (赞：0)

考虑根据题意模拟，分别对字符的四种情况分类处理即可。由于要求最短路径长度，于是可以使用广搜解决，答案是第一个搜出来在终点的步骤数。

注意记录 `vis` 某点是否到达过。

```cpp
//Author: Saint_ying_xtf
//Timelimit: 1000ms
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <iomanip>
#include <cmath>
using namespace std;
#define int long long
#define f(W, X, Y, Z) for(int W = X; W <= Y; W += Z)
#define F(W, X, Y, Z) for(int W = X; W >= Y; W -= Z)
#define debug puts("QAQ")
namespace fastIO{
	inline int read(){
		int x = 0, s = 1;
		char c = getchar();
		while(c < '0' || c > '9'){
			if(c == '-') s = -1;
			c = getchar();
		}
		while(c >= '0' && c <= '9'){
			x = (x << 3) + (x << 1) + (c ^ '0');
			c = getchar();
		}
		return x * s;
	}
	inline void Write(int x){
		if(x < 0){
			putchar('-');
			x = -x;
		}
		if(x > 9) Write(x / 10);
		putchar(x % 10 + '0');
	}
	inline void write(int x, char c){
		Write(x);
		putchar(c);
	}
}
using namespace fastIO;
namespace SyxQwQ{
	inline int qwq(){
		return 0;
	}
	struct Queue{
		struct node{
			int x, y;
			int step;
		}; 
		node u[1010100];
		int head = 1, tail = 0;
		inline void push(node a){
			u[++tail] = a;
		}
		inline void pop(){
			++head;
		}
		inline node front(){
			return u[head];
		}
		inline node back(){
			return u[tail];
		}
		inline int size(){
			return tail - head + 1;
		}
		inline bool empty(){
			return tail < head;
		}
	}q;
	int n, m;
	char a[1010][1010];
	bool vis[1010][1010];
	inline char Getchar(){
		char c = getchar();
		while(c != '+' &&  c != '-' && c != '*' && c != '|') c = getchar();
		return c;
	}
	inline bool pd(int x, int y){
		if(x < 1 || x > n || y < 1 || y > m) return 0;
		return (vis[x][y] || a[x][y] == '*') ? 0 : 1;
	}
	inline void bfs(){
		q.push({1, 1, 1});
		vis[1][1] = 1;
		while(!q.empty()){
			Queue::node frt = q.front();
			q.pop(); 
			//debug;
			//cout << frt.x << " " << frt.y << '\n';
			if(frt.x == n && frt.y == m){
				write(frt.step, '\n');
				return ;
			}
			if(a[frt.x][frt.y] == '-' || a[frt.x][frt.y] == '+'){
				if(pd(frt.x, frt.y + 1)){
					vis[frt.x][frt.y + 1] = 1;
					q.push({frt.x, frt.y + 1, frt.step + 1}); 
				}
				if(pd(frt.x, frt.y - 1)){
					vis[frt.x][frt.y - 1] = 1;
					q.push({frt.x, frt.y - 1, frt.step + 1}); 
				}
			}
			if(a[frt.x][frt.y] == '|' || a[frt.x][frt.y] == '+'){
				if(pd(frt.x + 1, frt.y)){
					vis[frt.x + 1][frt.y] = 1;
					q.push({frt.x + 1, frt.y, frt.step + 1});
				}
				if(pd(frt.x - 1, frt.y)){
					vis[frt.x - 1][frt.y] = 1;
					q.push({frt.x - 1, frt.y, frt.step + 1});
				}
			}
		}
		puts("-1");
	}
	inline int main(){
		//todo
		int T = read();
		while(T--){
			q.head = 1;
			q.tail = 0;
			n = read(), m = read();
			f(i, 1, n, 1){
			f(j, 1, m, 1){
				a[i][j] = Getchar();
				vis[i][j] = 0;
			}}
			//f(i, 1, n, 1) f(j, 1, m, 1) cout << a[i][j];
			if(a[1][1] == '*') {
				puts("-1");
				continue;
			}
			bfs();
		}
		return qwq();
	}
}
signed main(){
	SyxQwQ::main();
	return 0;
}
```

---


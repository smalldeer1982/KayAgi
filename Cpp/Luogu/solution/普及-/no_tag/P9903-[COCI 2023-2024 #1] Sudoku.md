# [COCI 2023/2024 #1] Sudoku

## 题目描述

数独是一款逻辑推理类游戏，玩家的任务是用数字 $1\sim9$ 填满一个 $9\times9$ 的网格，使其满足以下条件：

- 数字 $1\sim 9$ 在每一行恰好出现一次。
- 数字 $1\sim 9$ 在每一列恰好出现一次。
- 把网格划分成 $9$ 个 $3\times3$ 的宫，数字 $1\sim 9$ 在每一宫恰好出现一次。

现在给你一个未完成的数独网格，请你判断当前是否存在错误。**一个网格是存在错误的，当且仅当存在一行或一列或一宫，其中至少一个数字出现了 $2$ 次及以上。**

如图展示了一个数独网格，它不存在错误。

![](https://cdn.luogu.com.cn/upload/image_hosting/d54z2mz7.png)

## 说明/提示

### 【样例解释#1】

这个网格没有错误，所有输出 `OK`。

### 【样例解释#2】

第 $9$ 列数字 $5$ 出现了 $2$ 次，且右下角的一个宫中数字 $5$ 出现了 $2$ 次。

### 【样例解释#3】

第 $2$ 列数字 $2$ 出现了 $2$ 次，且第 $7$ 列数字 $6$ 出现了 $2$ 次。

### 【数据范围】

对于 $100\%$ 的数据，字符矩阵中只包含数字 $1\sim9$、字符 `-`、`|`、`+`、`.`，且字符 `-`、`|`、`+` 出现的位置与样例一致。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | 如果存在错误，一定可以只检查行的限制找到 | $11$ |
| $2$ | 如果存在错误，一定可以只检查列的限制找到 | $12$ |
| $3$ | 如果存在错误，一定可以只检查宫的限制找到 | $13$ |
| $4$ | 无特殊性质 | $14$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $50$。

题目译自 [COCI2022-2023](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T1 Sudoku**_。

## 样例 #1

### 输入

```
+---+---+---+
|52.|...|.81|
|.39|58.|...|
|.8.|.9.|...|
+---+---+---+
|24.|...|1.3|
|1..|43.|86.|
|.63|..7|.24|
+---+---+---+
|...|1.9|35.|
|..8|.74|6..|
|31.|86.|7.9|
+---+---+---+```

### 输出

```
OK```

## 样例 #2

### 输入

```
+---+---+---+
|3..|6..|..4|
|4.9|8.1|..7|
|..7|.49|6..|
+---+---+---+
|946|157|8.2|
|.2.|3..|745|
|.7.|28.|...|
+---+---+---+
|...|4..|..5|
|8.5|.6.|.2.|
|734|..8|5..|
+---+---+---+```

### 输出

```
GRESKA```

## 样例 #3

### 输入

```
+---+---+---+
|5..|98.|67.|
|6..|...|.31|
|.2.|613|.4.|
+---+---+---+
|.96|8.2|1.7|
|.28|..5|.9.|
|7.3|19.|6..|
+---+---+---+
|962|.7.|.1.|
|1.5|...|76.|
|.7.|5..|9..|
+---+---+---+```

### 输出

```
GRESKA```

# 题解

## 作者：include13_fAKe (赞：3)

## 题意
给定一个九宫标准数独游戏盘。里面有一些格子填了数，还有一些格子没有填数。

表示这个游戏盘要用**三大类**字符：

- `+` 和 `-`：数独游戏盘的**边框**（**包括九宫格的边框**）。
- $1\sim9$ 的数字：已填好的数字。
- `.`：准备要填的数。

定义**出现矛盾**如下：在**同一**行（列、九宫格）中有重复的数字。

询问在已填好的数中，是否**已出现了矛盾**。（**不把** `.` **填完**）。
## 思路
直接暴力统计在同一行（列、九宫格）中是否出现了矛盾。

可以用 $sum$ 数组记录在这一行（列、九宫格）中 $1\sim9$ 每一个数字出现的次数。

定义 $sum_i$ 为数字 $i$ 的出现次数，每搜到一个数字 $i$，就让 $sum_i$ 的值加 $1$。

若 $sum_i>1$，说明已经出现了矛盾，**可以马上输出** `GRESKA`，**并结束程序**。

**但一定要在搜完一行（列、九宫格）的时候清空** $sum$ **数组。**

**最后，如果游戏盘没有问题，要记得输出** `OK` **再结束。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

char s[15][15];
int sum[15];
int main(){
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4==1)	continue;
		memset(sum,0,sizeof(sum));
		for(int j=1;j<=13;j++){
			if(s[i][j]>='0'&&s[i][j]<='9'){
				sum[s[i][j]-'0']++;
				if(sum[s[i][j]-'0']>1){
					puts("GRESKA");
					return 0;
				}
			}
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4==1)	continue;
		memset(sum,0,sizeof(sum));
		for(int j=1;j<=13;j++){
			if(s[j][i]>='0'&&s[j][i]<='9'){
				sum[s[j][i]-'0']++;
				if(sum[s[j][i]-'0']>1){
					puts("GRESKA");
					return 0;
				}
			}
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4!=2)	continue;
		for(int j=1;j<=13;j++){
			if(j%4!=2)	continue;
			memset(sum,0,sizeof(sum));
			for(int i1=0;i1<=2;i1++){
				for(int j1=0;j1<=2;j1++){
					if(s[i+i1][j+j1]>='0'&&s[i+i1][j+j1]<='9'){
						sum[s[i+i1][j+j1]-'0']++;
						if(sum[s[i+i1][j+j1]-'0']>1){
							puts("GRESKA");
							return 0;
						}
					}
				}
			}
		}
	}
	puts("OK");
	return 0;
} 
```


---

## 作者：cff_0102 (赞：2)

按照题意将每一行、每一列、每一宫格的数都判断一遍即可。

先写一个 `check` 函数，传入 $9$ 个数，返回这 $9$ 个数是否满足数独规则。

接着对于每行、每列、每宫格，依次调用 `check` 函数。

最后，如果对于每行、每列、每宫格，`check` 函数的返回值都是 `true`，则输出 `OK`；否则，输出 `GRESKA`。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[9][9];
bool check(int q,int w,int e,int r,int t,int y,int u,int i,int o){
	int x[10]={0,0,0,0,0,0,0,0,0,0};
	x[q]++;x[w]++;x[e]++;x[r]++;x[t]++;x[y]++;x[u]++;x[i]++;x[o]++;
	for(int i=1;i<=9;i++)if(x[i]>1)return 0;
	return 1;
}
int main(){
	for(int i=0;i<13;i++){
		for(int j=0;j<13;j++){
			char c;cin>>c;if(c=='.')c='0';
			if(i%4&&j%4){
				a[i-(i+3)/4][j-(j+3)/4]=c-'0';
			}
		}
	}
	//输入完了
	bool t=1;
	for(int i=0;i<9;i++){//检查每一行
		t=t&&check(a[i][0],a[i][1],a[i][2],a[i][3],a[i][4],a[i][5],a[i][6],a[i][7],a[i][8]);
	}
	for(int i=0;i<9;i++){//检查每一列
		t=t&&check(a[0][i],a[1][i],a[2][i],a[3][i],a[4][i],a[5][i],a[6][i],a[7][i],a[8][i]);
	}
	for(int i=0;i<9;i+=3){
		for(int j=0;j<9;j+=3){//检查每一宫格
			t=t&&check(a[i][j],a[i][j+1],a[i][j+2],a[i+1][j],a[i+1][j+1],a[i+1][j+2],a[i+2][j],a[i+2][j+1],a[i+2][j+2]);
		}
	}
	if(t)cout<<"OK";
	else cout<<"GRESKA";
    return 0;
}
```

顺带一提，即使一个数独盘面满足本题的所有条件，即将这个数独盘面输入到上面这份代码中它会输出 `OK`，它也不一定是有解的，比如下面这份输入。

```text
+---+---+---+
|342|867|159|
|519|432|867|
|876|159|342|
+---+---+---+
|23.|98.|4..|
|457|.2.|.38|
|.8.|...|21.|
+---+---+---+
|...|746|.23|
|72.|.1.|.9.|
|...|2..|..1|
+---+---+---+
```

---

## 作者：include13_fAKe (赞：1)

## 题意
给定一个九宫标准数独游戏盘。里面有一些格子填了数，还有一些格子没有填数。

表示这个游戏盘要用**三大类**字符：

- `+` 和 `-`：数独游戏盘的**边框**（**包括九宫格的边框**）。
- $1\sim9$ 的数字：已填好的数字。
- `.`：准备要填的数。

定义**出现矛盾**如下：在**同一**行（列、九宫格）中有重复的数字。

询问在已填好的数中，是否**已出现了矛盾**。（**不把** `.` **填完**）。
## 思路
直接暴力统计在同一行（列、九宫格）中是否出现了矛盾。

可以用 $sum$ 数组记录在这一行（列、九宫格）中 $1\sim9$ 每一个数字出现的次数。

定义 $sum_i$ 为数字 $i$ 的出现次数，每搜到一个数字 $i$，就让 $sum_i$ 的值加 $1$。

若 $sum_i>1$，说明已经出现了矛盾，**可以马上输出** `GRESKA`，**并结束程序**。

**但一定要在搜完一行（列、九宫格）的时候清空** $sum$ **数组。**

**最后，如果游戏盘没有问题，要记得输出** `OK` **再结束。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

char s[15][15];
int sum[15];
int main(){
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4==1)	continue;
		memset(sum,0,sizeof(sum));
		for(int j=1;j<=13;j++){
			if(s[i][j]>='0'&&s[i][j]<='9'){
				sum[s[i][j]-'0']++;
				if(sum[s[i][j]-'0']>1){
					puts("GRESKA");
					return 0;
				}
			}
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4==1)	continue;
		memset(sum,0,sizeof(sum));
		for(int j=1;j<=13;j++){
			if(s[j][i]>='0'&&s[j][i]<='9'){
				sum[s[j][i]-'0']++;
				if(sum[s[j][i]-'0']>1){
					puts("GRESKA");
					return 0;
				}
			}
		}
	}
	for(int i=1;i<=13;i++){
		if(i%4!=2)	continue;
		for(int j=1;j<=13;j++){
			if(j%4!=2)	continue;
			memset(sum,0,sizeof(sum));
			for(int i1=0;i1<=2;i1++){
				for(int j1=0;j1<=2;j1++){
					if(s[i+i1][j+j1]>='0'&&s[i+i1][j+j1]<='9'){
						sum[s[i+i1][j+j1]-'0']++;
						if(sum[s[i+i1][j+j1]-'0']>1){
							puts("GRESKA");
							return 0;
						}
					}
				}
			}
		}
	}
	puts("OK");
	return 0;
} 
```


---

## 作者：Jasonshan10 (赞：1)

## 题意

- 给出一个没有完成的数独，问现在这个数独是否有误。

- 若有误则输出 `GRESKA`，否则输出 `OK`。

## 思路

- 直接正常读入。共有 $13$ 行 $13$ 列。

- 用 `map` 来标记这一个数字它属于第几行，第几列，第几个九宫格。

- 在判断是否有误的时候，若有一行或一列或一九宫格内有两个及以上的相同的数，则输出 `GRESKA`，若所有都没有问题则输出 `OK`。

- 详细过程见代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=15;
int h[N][N],l[N][N],g[N][N];
char a[N][N];
map<pair<int,int>,int> mp;
map<int,int> mp2;
void init(){
	for(int i=2;i<=4;++i) for(int j=2;j<=4;++j) mp[{i,j}]=1;
	for(int i=2;i<=4;++i) for(int j=6;j<=8;++j) mp[{i,j}]=2;
	for(int i=2;i<=4;++i) for(int j=10;j<=12;++j) mp[{i,j}]=3;
	for(int i=6;i<=8;++i) for(int j=2;j<=4;++j) mp[{i,j}]=4;
	for(int i=6;i<=8;++i) for(int j=6;j<=8;++j) mp[{i,j}]=5;
	for(int i=6;i<=8;++i) for(int j=10;j<=12;++j) mp[{i,j}]=6;
	for(int i=10;i<=12;++i) for(int j=2;j<=4;++j) mp[{i,j}]=7;
	for(int i=10;i<=12;++i) for(int j=6;j<=8;++j) mp[{i,j}]=8;
	for(int i=10;i<=12;++i) for(int j=10;j<=12;++j) mp[{i,j}]=9;
	
	mp2[2]=1;mp2[3]=2;mp2[4]=3;mp2[6]=4;mp2[7]=5;mp2[8]=6;mp2[10]=7;mp2[11]=8;mp2[12]=9;
}
int main(){
	init();
	for(int i=1;i<=13;++i){
		for(int j=1;j<=13;++j){
			cin>>a[i][j];
			if (a[i][j]>='1'&&a[i][j]<='9'){
				h[mp2[i]][a[i][j]-'0']++;
				l[mp2[j]][a[i][j]-'0']++;
				g[mp[{i,j}]][a[i][j]-'0']++;
			}
		}
	}
	for(int i=1;i<=9;++i){
		for(int j=1;j<=9;++j){
			if (h[i][j]>=2||l[i][j]>=2||g[i][j]>=2){
				printf("GRESKA\n");
				return 0;
			}
		}
	}
	printf("OK\n");
	return 0;
}
```

---

## 作者：gloomy_ (赞：1)

### 0x01 题目简述
检查完成一部分的数独是否合法，**不考虑数独是否有解**。所以直接用模拟完成。
### 0x02 算法实现
#### 1.输入
观察样例：
```
+---+---+---+
|52.|...|.81|
|.39|58.|...|
|.8.|.9.|...|
+---+---+---+
|24.|...|1.3|
|1..|43.|86.|
|.63|..7|.24|
+---+---+---+
|...|1.9|35.|
|..8|.74|6..|
|31.|86.|7.9|
+---+---+---+
```
发现第 $1$，$5$，$9$，$13$ 行无意义，其余行由13个字符组成。  
观察有意义的行，发现第 $1$，$5$，$9$，$13$ 个字符是 `|`，其余是 `.` 或数字。
对于有意义的行，我们采用如下方式输入，其中 $n$ 为数独中的行数：
```cpp
void in(int n)
{
	scanf("%s",x);
	for(int i=0,j=1;i<13;i++)
	{
		if(x[i]=='|')
			continue;
		else if(x[i]=='.')
			deta[n][j]=0;
		else
			deta[n][j]=x[i]-'0';
		j++;
	}
}
```
#### 2.检查行
我们用 $cnt$ 数组存储每个数字出现的次数。为减少不必要的检查，节省时间，用 $flag$ 存储是否合法。
```cpp
for(int i=1;i<=9;i++)
	{
		memset(cnt,0,sizeof(cnt));
		for(int j=1;j<=9;j++)
		{
			cnt[deta[i][j]]++;
			if(cnt[deta[i][j]]>1&&deta[i][j]!=0)
			{
				flag=0;
				break;
			}
		}
		if(flag==0)
		{
			break;
		}
	}
```
#### 3.检查列
类似地，我们也可以如此检查列。
#### 4.检查宫格
每个宫格占 $3$ 行 $3$ 列，让 $i$ 和 $j$ 每次增加 $3$ 就行了。
```cpp
for(int i=1;i<=9;i+=3)
	{
		for(int j=1;j<=9;j+=3)
		{
			memset(cnt,0,sizeof(cnt));
			cnt[deta[i][j]]++;
			cnt[deta[i][j+1]]++;
			cnt[deta[i][j+2]]++;
			cnt[deta[i+1][j]]++;
			cnt[deta[i+1][j+1]]++;
			cnt[deta[i+1][j+2]]++;
			cnt[deta[i+2][j]]++;
			cnt[deta[i+2][j+1]]++;
			cnt[deta[i+2][j+2]]++;
			for(int i=1;i<=9;i++)
			{
				if(cnt[i]>1)
				{
					flag=0;
					break;
				}	
			}
			if(flag==0)
			{
				break;
			}
		}
		if(flag==0)
		{
			break;
		}
	}	
```
### 0x03 代码整理
```cpp
#include<bits/stdc++.h>
using namespace std;
int deta[13][10],cnt[10];
char x[20];
void in(int n)
{
	scanf("%s",x);
	for(int i=0,j=1;i<13;i++)
	{
		if(x[i]=='|')
			continue;
		else if(x[i]=='.')
			deta[n][j]=0;
		else
			deta[n][j]=x[i]-'0';
		j++;
	}
}
int main()
{
	scanf("%s",x);
	in(1);
	in(2);
	in(3);
	scanf("%s",x);
	in(4);
	in(5);
	in(6);
	scanf("%s",x);
	in(7);
	in(8);
	in(9);
	scanf("%s",x);
	int flag=1;
	for(int i=1;i<=9;i++)
	{
		memset(cnt,0,sizeof(cnt));
		for(int j=1;j<=9;j++)
		{
			cnt[deta[i][j]]++;
			if(cnt[deta[i][j]]>1&&deta[i][j]!=0)
			{
				flag=0;
				break;
			}
		}
		if(flag==0)
		{
			break;
		}
	}
	if(flag)
	{
		for(int i=1;i<=9;i++)
		{
			memset(cnt,0,sizeof(cnt));
			for(int j=1;j<=9;j++)
			{
				cnt[deta[j][i]]++;
				if(cnt[deta[j][i]]>1&&deta[j][i]!=0)
				{
					flag=0;
					break;
				}
			}
			if(flag==0)
			{
				break;
			}
		}
	}
	if(flag)
	{
		for(int i=1;i<=9;i+=3)
		{
			for(int j=1;j<=9;j+=3)
			{
				memset(cnt,0,sizeof(cnt));
				cnt[deta[i][j]]++;
				cnt[deta[i][j+1]]++;
				cnt[deta[i][j+2]]++;
				cnt[deta[i+1][j]]++;
				cnt[deta[i+1][j+1]]++;
				cnt[deta[i+1][j+2]]++;
				cnt[deta[i+2][j]]++;
				cnt[deta[i+2][j+1]]++;
				cnt[deta[i+2][j+2]]++;
				for(int i=1;i<=9;i++)
				{
					if(cnt[i]>1)
					{
						flag=0;
						break;
					}	
				}
				if(flag==0)
				{
					break;
				}
			}
			if(flag==0)
			{
				break;
			}
		}	
	}
	if(flag)
	{
		printf("OK");
	}
	else
	{
		printf("GRESKA");
	}
	return 0;
} 
```


---

## 作者：ZnHF (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P9903)

# 题意简述

给定一个数独网格，判断这个数独网格是否合法。

# 题目分析

模拟题意即可。

具体地，我们可以设 $line_{i,j}$ 表示位于第 $i$ 行的数字 $j$ 出现的次数，$col_{i,j}$ 表示位于第 $i$ 行的数字 $j$ 出现的次数。遍历整个数独网格以确定每一个 $line_{i,j}$ 和 $col_{i,j}$ 的取值。

对于每个宫格，我们以从左到右，从上到下的方式为它们依次标号，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/b1fxs6s6.png)

设 $box_{i,j}$ 表示位于第 $i$ 行的数字 $j$ 出现的次数。遍历整个数独网格以确定每一个 $box_{i,j}$ 的取值。

最后检查每一个 $line_{i,j}$ 和 $col_{i,j}$ 以及 $box_{i,j}$ 如果它们中有任何一个的值大于 $1$，则说明给定的数独网格不合法，否则说明给定的数独网格是合法的。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100][100];
int box[100][100],line[100][100],col[100][100];
int main(){
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			cin>>a[i][j];
			if(a[i][j]>='0' && a[i][j]<='9') a[i][j]-='0';
		}
	}
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			if(a[i][j]>=0 && a[i][j]<=9){
				line[i][a[i][j]]++;
			}
		}
	}
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			if(a[j][i]>=0 && a[j][i]<=9){
				col[i][a[j][i]]++;
			}
		}
	}
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			if(i>=2 && i<=4 && j>=2 && j<=4) box[1][a[i][j]]++;
			else if(i>=2 && i<=4 && j>=6 && j<=8) box[2][a[i][j]]++;
			else if(i>=2 && i<=4 && j>=10 && j<=12) box[3][a[i][j]]++;
			else if(i>=6 && i<=8 && j>=2 && j<=4) box[4][a[i][j]]++;
			else if(i>=6 && i<=8 && j>=6 && j<=8) box[5][a[i][j]]++;
			else if(i>=6 && i<=8 && j>=10 && j<=12) box[6][a[i][j]]++;
			else if(i>=10 && i<=12 && j>=2 && j<=4) box[7][a[i][j]]++;
			else if(i>=10 && i<=12 && j>=6 && j<=8) box[8][a[i][j]]++;
			else if(i>=10 && i<=12 && j>=10 && j<=12) box[9][a[i][j]]++;
		}
	}
	for(int i=1;i<=13;i++){
		for(int j=0;j<=9;j++){
			if(line[i][j]>1 || col[i][j]>1 || box[i][j]>1){
				puts("GRESKA");
				return 0;
			}
		}
	}
	puts("OK");
	return 0;
}
```


---

## 作者：TainityAnle (赞：1)

### 题意

给定一个数独，问其是否合法。

### 思路

本题最大问题在于输入格式非常丑陋，如何存储。

可以开一个二维数组 $a$，表示数独的第 $i$ 行，第 $j$ 列是 $a_{i,j}$，如果是空的，$a_{i,j}=0$。

我们发现分割行的第一个字符是 `+`，所以我们判断，如果第一个字符不是 `+`，行数就加一，表示这是有效的一行。每一行中，每个宫的分割列是 `|` 字符，如果当前字符不是 `|`，当前行列数加一，表示有效的一个数字（或空位）。

```cpp
for(int i=1; i<=13; i++) {
	cin>>s;
	n=0;
	if(s[0]!='+') m++;
	for(int i=1; i<12; i++) {
		if(s[i]!='|') n++;
		if(s[i]<='9'&&s[i]>='0') a[m][n]=s[i]-48;
	}
}
```

这样我们就把它存到了一个二维数组里。

接着就暴力查找每一行、列、宫，将次数存到桶数组 $cnt$ 里，如果 $cnt$ 数组的任何一个值大于一，不成立。

在查找宫时，可以将左上角的设为起点，向下和向右各枚举 3 个。

```cpp
for(int k=1; k<=9; k++) {
	int ii=0,jj=0;
	if(k==2) ii=3;
	if(k==3) ii=6;
	if(k==4) ii=0,jj=3;
	if(k==5) ii=3,jj=3;
	if(k==6) ii=6,jj=3;
	if(k==7) ii=0,jj=6;
	if(k==8) ii=3,jj=6;
	if(k==9) ii=6,jj=6;
	memset(cnt,0,sizeof cnt);
	for(int i=1+ii; i<=3+ii; i++) for(int j=1+jj; j<=3+jj; j++) cnt[a[i][j]]++;
	for(int i=1; i<=9; i++) {
		if(cnt[i]>1) {
			cout<<"GRESKA";
			return 0;
		}
	}
}
```

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int a[12][12],n,m,cnt[10];
int main() {
	for(int i=1; i<=13; i++) {
		cin>>s;
		n=0;
		if(s[0]!='+') m++;
		for(int i=1; i<12; i++) {
			if(s[i]!='|') n++;
			if(s[i]<='9'&&s[i]>='0') a[m][n]=s[i]-48;
		}
	}
	/*for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++){
			cout<<a[i][j];
		}
		cout<<endl;
	} */
	for(int i=1; i<=9; i++) {
		memset(cnt,0,sizeof cnt);
		for(int j=1; j<=9; j++) {
			cnt[a[i][j]]++;
		}
		for(int j=1; j<=9; j++) {
			if(cnt[j]>1) {
				cout<<"GRESKA";
				return 0;
			}
		}
	}
	for(int i=1; i<=9; i++) {
		memset(cnt,0,sizeof cnt);
		for(int j=1; j<=9; j++) {
			cnt[a[j][i]]++;
		}
		for(int j=1; j<=9; j++) {
			if(cnt[j]>1) {
				cout<<"GRESKA";
				return 0;
			}
		}
	}
	for(int k=1; k<=9; k++) {
		int ii=0,jj=0;
		if(k==2) ii=3;
		if(k==3) ii=6;
		if(k==4) ii=0,jj=3;
		if(k==5) ii=3,jj=3;
		if(k==6) ii=6,jj=3;
		if(k==7) ii=0,jj=6;
		if(k==8) ii=3,jj=6;
		if(k==9) ii=6,jj=6;
		memset(cnt,0,sizeof cnt);
		for(int i=1+ii; i<=3+ii; i++) for(int j=1+jj; j<=3+jj; j++) cnt[a[i][j]]++;
		for(int i=1; i<=9; i++) {
			if(cnt[i]>1) {
				cout<<"GRESKA";
				return 0;
			}
		}
	}
	cout<<"OK";
	return 0;
}

```

---

## 作者：Kle1N (赞：0)

一开始做这道题还以为是要判定数独是否有解，后面才发现其实只要考虑已填的数字是否出现冲突就行了。

既然如此，我们就分别从出现冲突的三种情况进行考虑即可。

但我们还得先解决一下输入的问题。对于这个问题，我们可以用字符串的方式读入，若第一个字符为 '+'，则跳过这个字符串继续读入；否则就从左到右扫描字符串，若为 '|'，则跳过，否则转为整型存储在二维数组中（未填的数字视为 $0$）即可。

解决完输入，就要考虑如何处理冲突了。

---
>一个网格是存在错误的，当且仅当存在一行或一列或一宫，其中至少一个数字出现了 $2$ 次及以上。

对于行间的冲突，我们可以逐行扫描。为了判重，我们可以定义一个布尔类型的标记数组，在遍历的过程中，如果当前数字为未填的数字，则跳过；如果当前数字未被标记过，就在相应数字的标记数组中打个标记；否则若该数字已被标记，就说明该数字已经出现过，产生了冲突，于是输出 `GRESKA` 并结束程序即可。

这里有个需要注意的点，每完成一行扫描都要将标记数组清空，不然就可能会出问题。

---
对于列间的冲突，我们就逐列扫描。还是同样使用标记数组判重，思路与行间的基本一致，不再赘述。

---
行、列间的冲突好考虑，宫间的判定该怎么办呢？

其实思想还是没变，也是遍历和标记数组，要考虑的是遍历的起点和终点。

考虑到数据很小，直接将起点和终点坐标都写出来，再写 $9$ 个 for 循环，简单粗暴。

或者稍微观察一下容易发现，把一个宫所在的行称为大行，所在的列称为大列，下标都从 $1$ 开始，那么第 $i$ 大行第 $j$ 大列的宫，其行的范围就是 $i \times 3-2$ 到 $i \times 3$，其列的范围就是 $j \times 3-2$ 到 $j \times 3$。知道了枚举的范围，那就简单了，用几个 for 循环嵌套进行遍历，再结合前面的标记数组判重就可以完美解决了。

---
至此，若输入的数独连过上述三关都没有被刷掉，那就说明它没有冲突，输出 `OK` 即可。

---

具体看代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int sudoku[10][10],n,m;
bool v[10];
string t;
int main(){
	while(cin >> t){
		if(t[0] == '+'){
			continue;
		}
		n++;
		m = 0;
		for(int i = 0; i < t.size(); i++){
			if(t[i] == '|'){
				continue;
			}
			if(t[i] == '.'){
				m++;
				continue;
			}
			sudoku[n][++m] = t[i] - '0';
		}
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			if(sudoku[i][j] == 0){
				continue;
			}
			if(v[sudoku[i][j]] != 0){
				cout << "GRESKA" << endl;
				return 0;
			}
			v[sudoku[i][j]]=1;
		}
		memset(v, 0, sizeof(v));
	}
	for(int j = 1; j <= m; j++){
		for(int i = 1; i <= n; i++){
			if(sudoku[i][j] == 0){
				continue;
			}
			if(v[sudoku[i][j]] != 0){
				cout << "GRESKA" << endl;
				return 0;
			}
			v[sudoku[i][j]]=1;
		}
		memset(v, 0, sizeof(v));
	}
	for(int i = 1; i <= 3; i++){
		for(int j = 1; j <= 3; j++){
			int sx = i * 3 - 2, sy = j * 3 - 2, ex = i * 3, ey = j * 3;
			for(int x = sx; x <= ex; x++){
				for(int y = sy; y <= ey; y++){
					if(sudoku[x][y] == 0){
						continue;
					}
					if(v[sudoku[x][y]] != 0){
						cout << "GRESKA" << endl;
						return 0;
					}
					v[sudoku[x][y]]=1;
				}
			}
			memset(v, 0, sizeof(v));
		}
	}
	cout << "OK" << endl;
	return 0;
}
```

---

## 作者：InversionShadow (赞：0)

简单模拟。

首先先解决一行相同的情况：

根据样例，输入的 $1,5,9,13$ 行列不为数字或 `.`，所以我们暴力判断的时候要排除第 $1,5,9,13$ 行，这里我们用 `map` 来判重。

```cpp
for (int i = 1; i <= 13; i++) {
  if (i == 1 || i == 5 || i == 9 || i == 13) {
    continue;
  }
  mp.clear();
  for (int j = 1; j <= 13; j++) {
    if (j == 1 || j == 5 || j == 9 || j == 13) {
      continue;
    }
//  cout << i << ' ' << j << endl;
    mp[c[i][j] - '0']++;
  }
  for (int j = 1; j <= 10; j++) {
    if (mp[j] >= 2) {
      cout << "GRESKA\n";
      return 0;
    }
  }
}
```

同样的，列也是如此：

```cpp
for (int i = 1; i <= 13; i++) {
  if (i == 1 || i == 5 || i == 9 || i == 13) {
    continue;
  }
  mp.clear();
  for (int j = 1; j <= 13; j++) {
    if (j == 1 || j == 5 || j == 9 || j == 13) {
      continue;
    }
    mp[c[j][i] - '0']++;
  }
  for (int j = 1; j <= 10; j++) {
    if (mp[j] >= 2) {
      cout << "GRESKA\n";
      return 0;
     }
   }
}
```

那么怎么判断一个块中间的数呢？

循环枚举每一个块的左上角与右下角，确定这个块的位置，用 `map` 判断即可。

```cpp
for (int i = 1; i <= 13; i++) {
  if (i != 1 && i != 5 && i != 9) { // i = 13 的时候没有下一个比 13 还右边的 + 了
    continue;
  }
  for (int j = 1; j <= 13;  j++) {
    if (j != 1 && j != 5 && j != 9) {
      continue;
    }
    int ni = i + 1; // 这里的 i,j 是 + 的位置，而非块中的数字的位置
    int nj = j + 1;
    int mi = ni + 2; // 简单画图就知道了
    int mj = nj + 2;
    mp.clear();
    for (int k = ni; k <= mi; k++) {
      for (int l = nj; l <= mj; l++) {
        mp[c[k][l] - '0']++;
      }
    }
    for (int i = 1; i <= 10; i++) {
      if (mp[i] >= 2) {
        cout << "GRESKA\n";
        return 0;
      }
    }
  }
}
```

然后就没了，完整代码把上面合在一起就可以了。

---

## 作者：Cute__yhb (赞：0)

## 题意
给出一个未填完的数独，询问是否有误。
## 思路
先说读入。

给出的数独内有多余信息，容易发现，当横、纵坐标有一个模 $4$ 为 $1$ 时，该字符为多余信息。

如果一个字符在输入的格式中下标为 $(x,y)$，那么它在数独内的下标为 $(x-\lceil \frac{x}{4} \rceil,y-\lceil \frac{y}{4} \rceil)$。

接着是判断。

对于在同一行，同一列的数字，可以直接枚举横、纵坐标。

对于在同一个格子内的，我们可以把数独看成是由 $3$ 行，$3$ 列的格子构成的。

位于 $(i,j)$ 上的格子中的数如果为 $(x,y)$，则应满足 $x\in[(i-1)\times3+1,i\times3]$ 且 $y\in[(j-1)\times3+1,j\times3]$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[15][15],c;
string s;
int main(){
	//输入
	for(int i=1;i<=13;i++){
		for(int j=1;j<=13;j++){
			cin>>c;
			if(i%4!=1&&j%4!=1){//是否有用
				int x=i-ceil(i/4.);//4.0可以写作4.
				int y=j-ceil(j/4.);
				a[x][y]=c;
			}
		}
	}
   //判断行
	for(int i=1;i<=9;i++){
		int cnt[15]={0};//存是否出现过
		for(int j=1;j<=9;j++){
			if(a[i][j]!='.'&&cnt[a[i][j]-'0']){
				cout<<"GRESKA";
				exit(0);//直接结束程序
			}
			cnt[a[i][j]-'0']=1;
		}
	}
   //判断列
	for(int i=1;i<=9;i++){
		int cnt[15]={0};
		for(int j=1;j<=9;j++){
			if(a[j][i]!='.'&&cnt[a[j][i]-'0']){
				cout<<"GRESKA";
				exit(0);
			}
			cnt[a[j][i]-'0']=1;
		}
	}
   //判断格子
	for(int x=1;x<=3;x++){
		for(int y=1;y<=3;y++){//格子坐标
			int cnt[15]={0};
			for(int i=(x-1)*3+1;i<=x*3;i++){//对应的数字坐标
				for(int j=(y-1)*3+1;j<=y*3;j++){
					if(a[i][j]!='.'&&cnt[a[i][j]-'0']){
						cout<<"GRESKA";
						exit(0);
					}
					cnt[a[i][j]-'0']=1;
				}
			}
		}
	}
	cout<<"OK";//可行
    return 0;
}
```


---

## 作者：xu_zhihao (赞：0)

### 题目意思：
   - 给你一个可能未填完的数独，让你判断这个数独是否合法。
   
### 分析题目：
   - 这题是一个模拟题，只要跟着题目模拟即可。判断行、列、宫是否存在相等的数字即可。当然，没有被填的格子是不算的。
   
### AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	int p[110][110];
	int cnt2=0;
	for(int i=0;i<13;i++)
	{
		cin>>s;
		if(i!=0 && i!=12 && i!=4 && i!=8)
		{
			int cnt=0;
			for(int j=0;j<12;j++)
			{
				if(s[j]!='|')
				{
					if(s[j]!='.')
					{
						p[cnt2][cnt]=(s[j]-'0');
					}
					else if(s[j]=='.')
					{
						p[cnt2][cnt]=0;
					}
					cnt++;
				}
			}
			cnt2++;
		}
	}
	int f=0;
	int flag[1010];
	for(int i=0;i<9;i++)
	{
		if(f)
		{
			break;
		}
		for(int j=0;j<=9;j++)
		{
			flag[j]=0;
		}
		for(int j=0;j<9;j++)
		{
			flag[p[i][j]]++;
		}
		for(int j=1;j<=9;j++)
		{
			if(flag[j]>1)
			{
				//cout<<"con1"<<endl;
				f=1;
				break;
			}
		}
		if(f)
		{
			break;
		}
	}
	for(int i=0;i<9;i++)
	{
		if(f)
		{
			break;
		}
		for(int j=0;j<=9;j++)
		{
			flag[j]=0;
		}
		for(int j=0;j<9;j++)
		{
			flag[p[j][i]]++;
		}
		for(int j=1;j<=9;j++)
		{
			if(flag[j]>1)
			{
				//cout<<"con2"<<endl;
				f=1;
				break;
			}
		}
		if(f)
		{
			break;
		}
	}
	for(int i=0;i<9;i+=3)
	{
		for(int j=0;j<9;j+=3)
		{
			for(int k=0;k<=9;k++)
			{
				flag[k]=0;
			}
			for(int x=0;x<3;x++)
			{
				for(int y=0;y<3;y++)
				{
					flag[p[i+x][j+y]]++;
				}
			}
			for(int k=1;k<=9;k++)
			{
				if(flag[k]>1)
				{
					//cout<<"con3:"<<k<<" "<<i<<" "<<j<<endl;
					f=1;
					break;
				}
			}
			if(f)
			{
				break;
			}
		}
		if(f)
		{
			break;
		}
	}
	if(f)
	{
		cout<<"GRESKA";
	}
	else
	{
		cout<<"OK";
	}
	return 0;
}

```
写的有点长，仅供参考。

[AC 记录](https://www.luogu.com.cn/record/139254230)

---

## 作者：_little_Cabbage_ (赞：0)

# P9903 [COCI 2023/2024 #1] Sudoku 题解
~~[博客食用体验更佳](https://www.luogu.com.cn/blog/958804/solution-p9903)~~

此题就是一道纯模拟题。

对于每行、每列、每宫进行判断即可。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[110][110];
int cnt[10];
int main()
{
	for(int i=1;i<=13;i++)
	{
		scanf("%s",s[i]+1);
	}
	int n=13,m=13;
	for(int i=2;i<=12;i++)
	{
		if(i==5||i==9)
		{
			continue;
		}
		memset(cnt,0,sizeof(cnt));
		for(int j=2;j<=12;j++)
		{
			if(j==5||j==9)
			{
				continue;
			}
			if(s[i][j]=='.')
			{
				continue;
			}
			if(cnt[s[i][j]-'0']==1)
			{
				printf("GRESKA");
				return 0;
			}
			cnt[s[i][j]-'0']=1;
		}
	}
	for(int i=2;i<=12;i++)
	{
		if(i==5||i==9)
		{
			continue;
		}
		memset(cnt,0,sizeof(cnt));
		for(int j=2;j<=12;j++)
		{
			if(j==5||j==9)
			{
				continue;
			}
			if(s[j][i]=='.')
			{
				continue;
			}
			if(cnt[s[j][i]-'0']==1)
			{
				printf("GRESKA");
				return 0;
			}
			cnt[s[j][i]-'0']=1;
		}
	}
	for(int i=2;i<=10;i+=4)
	{
		for(int j=2;j<=10;j+=4)
		{
			memset(cnt,0,sizeof(cnt));
			for(int k=i;k<=(i+2);k++)
			{
				for(int l=j;l<=(j+2);l++)
				{
					if(s[k][l]=='.')
					{
						continue;
					}
					if(cnt[s[k][l]-'0']==1)
					{
						printf("GRESKA");
						return 0;
					}
					cnt[s[k][l]-'0']=1;
				}
			}
		}
	}
	printf("OK");
}
```
[AC 记录](https://www.luogu.com.cn/record/139249540)

---

## 作者：__O_v_O__ (赞：0)

此题很简单，但每个部分都很容易写错。

## 1. 输入部分

这里我用的是一个二维数组存储数独。

首先一行一行输入，同时用一个变量记录当前数独是第几行，如果输入的一行是分割行( `+---+---+---+` )，则跳过，否则变量自增。

对于不是分割行的每一行，我们一个一个枚举字符，同时用一个变量记录当前数独是第几列，如果输入的字符是分割符( `|` )，则跳过，否则变量自增，并存储到数组里。

这里如果字符是 `.`，就把当前位置赋值为 $-1$，以后再判断即可。

## 2. 判断部分

我们分别枚举每一行、每一列、每一个宫，对于每一种，如果当前数字是 $-1$ 则跳过，否则，使用一个桶来记录是否出现过，一旦枚举到的元素出现过，则输出 `GRESKA`，否则记录出现过，并枚举下一个。

**AC code:**
```cpp
#include<bits/extc++.h>
using namespace std;
#define BTS 0
#define STB 1
#define afor(i,n,m,dir) for(int i=n;dir?i<=m:i>=m;dir?i++:i--)
#define int long long
int a[101][101],nu;string x;map<int,int>m;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//读入优化
	afor(i,1,13,STB){
		cin>>x;int t=0;
		if(x[0]=='+')continue;//分割行
		nu++;
		afor(j,0,12,STB){
			if(x[j]=='|')continue;
			if(x[j]=='.')a[nu][++t]=-1;//未确定
			else a[nu][++t]=x[j]-'0';
		}
	}//输入
	afor(i,1,9,STB){
		m.clear();//清空
		afor(j,1,9,STB){
			if(a[i][j]==-1)continue;//判断是否未确定
			if(m[a[i][j]]){cout<<"GRESKA";return 0;}//重复了
			m[a[i][j]]++;
		}
	}//每行
	afor(i,1,9,STB){
		m.clear();
		afor(j,1,9,STB){
			if(a[j][i]==-1)continue;
			if(m[a[j][i]]){cout<<"GRESKA";return 0;}
			m[a[j][i]]++;
		}
	}//每列
	m.clear();
	afor(i,1,3,STB)afor(j,1,3,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//1号
	m.clear();
	afor(i,1,3,STB)afor(j,4,6,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//2号
	m.clear();
	afor(i,1,3,STB)afor(j,7,9,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//3号
	m.clear();
	afor(i,4,6,STB)afor(j,1,3,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//4号
	m.clear();
	afor(i,4,6,STB)afor(j,4,6,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//5号
	m.clear();
	afor(i,4,6,STB)afor(j,7,9,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//6号
	m.clear();
	afor(i,7,9,STB)afor(j,1,3,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//7号
	m.clear();
	afor(i,7,9,STB)afor(j,4,6,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//8号
	m.clear();
	afor(i,7,9,STB)afor(j,7,9,STB){
		if(a[i][j]==-1)continue;
		if(m[a[i][j]]){cout<<"GRESKA";return 0;}
		m[a[i][j]]++;
	}//9号
	cout<<"OK";
	return 0;
}
```

---

## 作者：luogu10086 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9903)

### PART 1

题目大意：

给定一个数独网格，判断是否合法。

存在错误的网格就是存在 $1$ 行或 $1$ 列或 $1$ 宫其中至少一个数字出现了 $2$ 次及以上。

------------
### PART 2

整体思路：

直接暴力模拟就行了。

先是行列，再是 $9$ 个宫，只要有不符合的就直接制裁，输出 `GRESKA` 再 `return 0` 结束。

都符合的，就在最后输出 `OK`。

------------
### PART 3

代码实现：

因为太长了，所以代码在[这里](https://www.luogu.com.cn/paste/x8wnnluw)。

---


# [COCI 2023/2024 #2] Pingvin

## 题目描述

给定一个 $n\times n\times n$ 的立方体，被分为 $n^3$ 个单位立方体，其中一些单位立方体是障碍不能通行。

给定起点坐标和终点坐标，每一步可以从一个单位立方体移到一个相邻的（有共同面的）非障碍的单位立方体，问从起点到终点最少走多少步。

## 说明/提示

### 数据范围
|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$7$|$n=2$|
|$2$|$16$|没有障碍|
|$3$|$22$|所有 $z$ 坐标大于 $1$ 的格子都是障碍|
|$4$|$25$|无|

对于所有数据，$1\le n,m\le 100$。

## 样例 #1

### 输入

```
2
1 1 1
1 1 2
00
10
01
00```

### 输出

```
1```

## 样例 #2

### 输入

```
3
2 3 1
1 1 1
000
010
000
111
111
111
111
111
111```

### 输出

```
3```

## 样例 #3

### 输入

```
3
2 1 1
3 2 2
000
010
110
010
001
001
101
110
000
```

### 输出

```
3```

# 题解

## 作者：DHT666 (赞：2)

## 题意
给出一个边长为 $n$ 三维地图，有的点会有障碍，求由给出的起点到终点的最优路径。

## 思路
三维广搜，和二维的差不多，方向数组多开一个即可，注意不能斜着走，一次最多改变一个坐标的值。

## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 110;

int n;
int Map[N][N][N]; // 存障碍
int len[N][N][N]; // 存答案
bool vis[N][N][N]; // 标记

int dx[] = {0,0,0,0,0,1,-1}; // 方向数组
int dy[] = {0,0,0,1,-1,0,0};
int dz[] = {0,1,-1,0,0,0,0};

struct node {
	int x,y,z; // 坐标
}qd,zd;

void bfs() {
	queue <node> q;
	q.push(qd);
	vis[qd.x][qd.y][qd.z] = 1;
	while(q.size()) {
		int nx = q.front().x,ny = q.front().y,nz = q.front().z;
		q.pop();
		if(nx == zd.x && ny == zd.y && nz == zd.z) { // 到达终点
			cout<<len[nx][ny][nz];
			return ;
		}
		for(int i=1;i<=6;i++) {
			int qx = nx + dx[i];
			int qy = ny + dy[i];
			int qz = nz + dz[i];
			if(qx > n || qx < 1 || qy > n || qy < 1 || qz > n || qz < 1) continue; // 边界
			if(!vis[qx][qy][qz] && !Map[qx][qy][qz]) { // 可以走
				node tot; tot.x = qx,tot.y= qy,tot.z = qz;
				q.push(tot);
				vis[qx][qy][qz] = 1;
				len[qx][qy][qz] = len[nx][ny][nz] + 1; // 累加答案
			}
		}
	}
	cout<<-1; // 无解
}

int main() {
	cin>>n>>qd.x>>qd.y>>qd.z>>zd.x>>zd.y>>zd.z;
	
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++) {
			for(int k=1;k<=n;k++) {
				char x; cin>>x;
				Map[j][k][i] = x - '0'; // 注意顺序
			}
		}
	}
	
	bfs();
	
	return 0;
}

~~~

---

## 作者：Kano_zyc (赞：2)

~~蒟蒻第一篇题解，管理大大求过。~~

## 题意简述

一个 $n \times n \times n$ 的立方体，其中一些立方体是障碍不能通行。给定起点坐标和终点坐标，每一步可以从一个单位立方体移到一个相邻的非障碍的单位立方体，求从起点到终点最少走多少步。


## 思路分析

很经典的 BFS 广搜题目，开一个三维数组存储，再开三个数组标记方向搜索即可。

## 注意事项

- 数组要开的足够大。

- 变量 INF 初始值也应该足够大。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF=0x3f3f3f3f;
const int dx[]={1,-1,0,0,0,0};
const int dy[]={0,0,1,-1,0,0};
const int dz[]={0,0,0,0,1,-1};
int a[105][105][105],dist[105][105][105];
bool vis[105][105][105];
struct node{int x,y,z;};
queue<node> q;

int main()
{
    int n,xs,ys,zs,xt,yt,zt;
    cin>>n>>xs>>ys>>zs>>xt>>yt>>zt;
    for(int z=1;z<=n;z++)
        for(int x=1;x<=n;x++)
            for(int y=1;y<=n;y++)
                scanf("%1d",&a[x][y][z]);
    memset(dist,0x3f,sizeof(dist));
    dist[xs][ys][zs]=0;
    q.push((node){xs,ys,zs});
    while(!q.empty())
    {
        node u=q.front(); q.pop();
        for(int i=0;i<6;i++)
        {
            int nx=u.x+dx[i],ny=u.y+dy[i],nz=u.z+dz[i];
            if(nx<1||ny<1||nz<1||nx>n||ny>n||nz>n||a[nx][ny][nz]) continue;
            if(dist[nx][ny][nz]>dist[u.x][u.y][u.z]+1)
            {
                dist[nx][ny][nz]=dist[u.x][u.y][u.z]+1;
                q.push((node){nx,ny,nz});
            }
        }
    }
    if(dist[xt][yt][zt]==INF) cout<<-1<<endl;
    else cout<<dist[xt][yt][zt]<<endl;
    return 0;
}
```



---

## 作者：DFM_O (赞：1)

## [P9909题目](https://www.luogu.com.cn/problem/P9909)

### 解题思路
这道题还是很水的，很明显是一个广搜。

但这个广搜是三维的，其实三维的广搜和二维的广搜差不多，只是要多开一个方向的数组而已，如果对于广搜比较熟悉是不难的。

不要忘了这里有 $6$ 个方向，还要注意**输入的顺序**。

### Code
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
struct op
{
	int x;
	int y;
	int z;
	int s;
};
char mapp[101][101][101];
bool v[101][101][101];
int n,x1,x2,y11,y2,z1,z2,d[7][3]={{0,0,0},{1,0,0},{-1,0,0},{0,1,0},{0,-1,0},{0,0,1},{0,0,-1}};
int bfs(int x3,int y3,int z3)//广搜
{
	if(v[x3][y3][z3]==false)
		v[x3][y3][z3]=true;
	queue<op> q;
	op qp={x3,y3,z3,0};
	q.push(qp);
	while(q.empty()!=true)
	{
		op m;
		m=q.front();
		q.pop();
		if(m.x==x2&&m.y==y2&&m.z==z2)
			return m.s;
		for(int i=1;i<=6;++i)
		{
			int xx=d[i][0]+m.x,yy=d[i][1]+m.y,zz=d[i][2]+m.z;
			if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&zz>=1&&zz<=n)
			{
				if(v[xx][yy][zz]==false&&mapp[xx][yy][zz]!='1')
					qp={xx,yy,zz,m.s+1},q.push(qp),v[xx][yy][zz]=true;
			}
		}
	}
	return -1;
}
void work()
{
	scanf("%d%d%d%d%d%d%d",&n,&x1,&y11,&z1,&x2,&y2,&z2);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			for(int k=1;k<=n;++k)
				scanf(" %c",&mapp[j][k][i]);//顺序要注意
		}
	}
	printf("%d\n",bfs(x1,y11,z1));	
}
int main()
{
	work();
	return 0;
}
```

---

## 作者：Cute__yhb (赞：1)

## 思路
广搜。

但这题是三维的，对于一个点 $(x,y,z)$，相邻的点为 $(x\pm1,y,z)$，$(x,y\pm1,z)$，$(x,y,z\pm1)$。

然后建完方向数组，就可以广搜了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define y1 zsgzsdg//避免重复
int n,x1,y1,z1,x2,y2,z2,l[105][105][105]={0};
bool vis[105][105][105],a[105][105][105];
int dx[]={0,1,-1,0,0,0,0};//方向数组
int dy[]={0,0,0,1,-1,0,0};
int dz[]={0,0,0,0,0,1,-1};
struct node{
	int x,y,z;//坐标
	node(int xx,int yy,int zz){
		x=xx;
		y=yy;
		z=zz;
	}
};
int main(){
	cin>>n>>x1>>y1>>z1>>x2>>y2>>z2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				char c;
				cin>>c;
				a[j][k][i]=c-'0';//注意顺序
			}
		}
	}
	queue<node>q;
	q.push(node(x1,y1,z1));
	vis[x1][y1][z1]=1;//标记
	while(!q.empty()){
		int x=q.front().x;
		int y=q.front().y;
		int z=q.front().z;
		q.pop();
		if(x==x2&&y==y2&&z==z2){//搜到终点
			cout<<l[x][y][z];
			return 0;//结束程序
		}
		for(int i=1;i<=6;i++){
			int xx=x+dx[i],yy=y+dy[i],zz=z+dz[i];//相邻点
			if(xx<1||xx>n||yy<1||yy>n||zz<1||zz>n) continue;//越界
			if(!vis[xx][yy][zz]&&!a[xx][yy][zz]){//可以走
				vis[xx][yy][zz]=1;//标记
				q.push(node(xx,yy,zz));//入队
				l[xx][yy][zz]=l[x][y][z]+1;//更新答案
			}
		}
	}
	cout<<-1;//无解
    return 0;
}
```


---

## 作者：cff_0102 (赞：1)

这道题明显要用三维 BFS。和二维 BFS 思路差不多，就是多拓展了一维空间。

起点和终点相同就直接输出 $0$，结束程序。BFS 每次向外拓展一格，到终点了就直接输出步数，所有和起点联通的地方都探索完了还没到终点就输出 $-1$。记得拓展时判断那一格能不能走以及是否已经走过了。

特别要注意的是输入格式（循环输入到坐标 $(j,k,i)$），以及题目中坐标是从 $1$ 开始的。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[114][114][114];
int main(){
	ios::sync_with_stdio(false);
	int n;cin>>n;
	int xs,ys,zs,xe,ye,ze;
	cin>>xs>>ys>>zs>>xe>>ye>>ze;
	if(xs*10000+ys*100+zs==xe*10000+ye*100+ze){//如果两个坐标相等就直接输出 0，退出程序
		cout<<0;return 0;
	}
	xs--;ys--;zs--;xe--;ye--;ze--;//因为后面坐标是从 0 开始的，所以这里全部减 1
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			for(int k=0;k<n;k++){
				char c;cin>>c;
				if(c-'0')a[j][k][i]=1;
			}
		}
	}//输入完了
	queue<int>q;
	q.push(xs*10000+ys*100+zs);
	int t=0;a[xs][ys][zs]=1;
	while(++t){
		int s=q.size();
		if(s==0){//空了
			cout<<-1;
			return 0;
		}
		for(int i=0;i<s;i++){
			int p=q.front();
			q.pop();
			int x=p/10000,y=p/100%100,z=p%100;
			//向六个方向拓展
			if(x-1>=0&&!a[x-1][y][z]){
				if(x-1==xe&&y==ye&&z==ze){
					cout<<t;
					return 0;
				}
				a[x-1][y][z]=1;
				q.push((x-1)*10000+y*100+z);
			}
			if(x+1<n&&!a[x+1][y][z]){
				if(x+1==xe&&y==ye&&z==ze){
					cout<<t;
					return 0;
				}
				a[x+1][y][z]=1;
				q.push((x+1)*10000+y*100+z);
			}
			if(y-1>=0&&!a[x][y-1][z]){
				if(x==xe&&y-1==ye&&z==ze){
					cout<<t;
					return 0;
				}
				a[x][y-1][z]=1;
				q.push(x*10000+(y-1)*100+z);
			}
			if(y+1<n&&!a[x][y+1][z]){
				if(x==xe&&y+1==ye&&z==ze){
					cout<<t;
					return 0;
				}
				a[x][y+1][z]=1;
				q.push(x*10000+(y+1)*100+z);
			}
			if(z-1>=0&&!a[x][y][z-1]){
				if(x==xe&&y==ye&&z-1==ze){
					cout<<t;
					return 0;
				}
				a[x][y][z-1]=1;
				q.push(x*10000+y*100+z-1);
			}
			if(z+1<n&&!a[x][y][z+1]){
				if(x==xe&&y==ye&&z+1==ze){
					cout<<t;
					return 0;
				}
				a[x][y][z+1]=1;
				q.push(x*10000+y*100+z+1);
			}
		}
	} 
	return 0;
}
```

---

## 作者：zhchz (赞：0)

# P9909
## BFS
思路与普通 BFS 相同，每次拓展一个点，将数组换为三维即可。

**注意输入顺序！**

方向数组为6连通：
```cpp
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};

```
代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<string.h>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
#define ll long long
#define ull unsigned long long
#define p_q priority_queue
using namespace std;

struct date{
	int x,y,z;
	date(int a=0,int b=0,int c=0){
		x=a,y=b,z=c;
	}//构造函数
	bool operator==(date a){
		return a.x==x && a.y==y && a.z==z;
	}//重载 == 运算符
};

const int N=110;
int n;
bool vis[N][N][N];//是否访问过
bool mp[N][N][N];//地图
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};//方向数组
int ans[N][N][N];//存储答案
char c;
queue<date> q;
date st,ed,t;

int main(){
	cin>>n;
	cin>>st.x>>st.y>>st.z;
	cin>>ed.x>>ed.y>>ed.z;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				cin>>c;
				mp[i][j][k]=c-'0';
			}
   //输入
   
	q.push(st);
	vis[st.x][st.y][st.z]=1;
    //从起点开始
    
	while(!q.empty()){
		t=q.front();
		q.pop();
		if(t==ed){//到达终点
			cout<<ans[t.x][t.y][t.z];
			return 0;
		}
		for(int i=0;i<6;i++){//6个方向
			int nx=t.x+dx[i],ny=t.y+dy[i],nz=t.z+dz[i];
			if(!(nx<1||nx>n||ny<1||ny>n||nz<1||nz>n) && !mp[nx][ny][nz] && !vis[nx][ny][nz]){
            //(没有越界)&&(没有障碍)&&(没有访问过)
				vis[nx][ny][nz]=1;
				q.push(date(nx,ny,nz));
				ans[nx][ny][nz]=ans[t.x][t.y][t.z]+1;
			}
		}
	}
	cout<<"-1";//无解
	return 0;
}
```

---

## 作者：very_easy (赞：0)

这么水的题居然还没有题解，我来水一发。

通过题意很明显就能得知是 `bfs` 搜索题，用一个队列来维护，注意点就是不要走重复的路，还有相较于传统的二维迷宫问题，此题是一个三维的迷宫，其实也很简单，将数组开到三维即可。

注意有 $6$ 个方向，二维的上下左右和上一层与下一层。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int n,stx,sty,stz,edx,edy,edz;
char mp[N][N][N];//三维数组 
bool vis[N][N][N];//三维数组，用来标记每个点是否经过 
int dir[6][3]={{1,0,0},{-1,0,0},{0,1,0},{0,-1,0},{0,0,1},{0,0,-1}};//6个方向 
struct date{
	int x,y,z,s;//s记录步数 
};
bool check(int x,int y,int z){
	return x>=1&&x<=n&&y>=1&&y<=n&&z>=1&&z<=n&&!vis[x][y][z]&&mp[x][y][z]!='1';//判断是否越界，是否访问，是否为障碍 
}
int bfs(int x,int y,int z){
	queue<date> q;//队列维护bfs 
	q.push({x,y,z,0});//起点入队 
	vis[x][y][z]=true;//标记起点，不然会死循环 
	while(!q.empty()){
		date t=q.front();
		q.pop();
		if(t.x==edx&&t.y==edy&&t.z==edz){
			return t.s;//找到答案返回步数 
		}
		for(int i=0;i<6;i++){
			int dx=t.x+dir[i][0];//移动x坐标 
			int dy=t.y+dir[i][1];//移动y坐标
			int dz=t.z+dir[i][2];//移动z坐标
			if(check(dx,dy,dz)){//判断 
				q.push({dx,dy,dz,t.s+1});
				vis[dx][dy][dz]=true;
			}
		}
	}
	return -1;//走不通返回-1 
}
int main(){
	cin>>n;
	cin>>stx>>sty>>stz>>edx>>edy>>edz;//输入起点与终点 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				cin>>mp[j][k][i];//输入地图 
			}
		}
	}
	int ans=bfs(stx,sty,stz);
	cout<<ans;
	return 0;
}
```

---

## 作者：Saint_ying_xtf (赞：0)

满分 $70$ 分的一道题，逆天！

这其实是一个三维广搜。考察了你是否掌握了广搜。

正常的广搜都是开两个方向数组，而这里，需要开三个方向数组，会通往六个方向，如下：

```cpp
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};
```

然后，在很多二维的地方要换成三维，稍微比较麻烦，如果你熟练掌握广搜，那么其实是是非常容易的哦！

注意一下输入的顺序，别搞错了！

```cpp
int n;
int xs,ys,zs;
int xt,yt,zt;
int dis[N][N][N];
int vis[N][N][N];
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};
struct node{
	int x,y,z;
};
int res[N][N][N];
void solve(){
	cin >> n>> xs >> ys >> zs >> xt >> yt>> zt;
	for(int i = 1;i <= n;i++){
		for(int j = 1;j<=n;j++){
			for(int k = 1;k <= n;k++){
				char c;cin >> c;dis[j][k][i]=c-'0';
			}
		}
	}
	queue<node> q;
	q.push({xs,ys,zs});
	vis[xs][ys][zs]=1;
	while(!q.empty()){
		int x=q.front().x;
		int y=q.front().y;
		int z=q.front().z;q.pop();
		if(x==xt&&y==yt&&z==zt){
			cout<<res[x][y][z];
			exit(0);
		}
		for(int i=0;i<6;i++){
			int xx=x+dx[i];
			int yy=y+dy[i];
			int zz=z+dz[i];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&zz>=1&&zz<=n&&!vis[xx][yy][zz]&&!dis[xx][yy][zz]){
				vis[xx][yy][zz]=1;
				q.push({xx,yy,zz});
				res[xx][yy][zz]=res[x][y][z]+1;
			}
		}
//		cout<<x<<" "<<y<<endl;
	}cout<<-1;
}
```

---


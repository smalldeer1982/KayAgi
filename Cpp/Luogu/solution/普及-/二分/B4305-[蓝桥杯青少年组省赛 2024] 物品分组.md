# [蓝桥杯青少年组省赛 2024] 物品分组

## 题目描述

有 $n$ 件物品排成一排，编号分别为 $1, 2, \ldots, n$，价值分别为 $a_1, a_2, \ldots, a_n$。请将这 $n$ 件物品拆分为 $k$ 组（不改变物品的顺序），要求每组内至少有一件物品。分别统计每组物品的价值之和，并找出其中的最大值。请设计一种分组方案，使这个最大值尽可能小，并输出这个最大值。

例如，$n=5$，物品价值分别为 $6, 1, 3, 8, 4$；$k=2$，表示要将这 $5$ 件物品拆分为两组。有如下分组方案：

1. $(6)$ 和 $(1, 3, 8, 4)$，两组价值之和分别为 $6$ 和 $16$，最大值为 $16$；
2. $(6, 1)$ 和 $(3, 8, 4)$，两组价值之和分别为 $7$ 和 $15$，最大值为 $15$；
3. $(6, 1, 3)$ 和 $(8, 4)$，两组价值之和分别为 $10$ 和 $12$，最大值为 $12$；
4. $(6, 1, 3, 8)$ 和 $(4)$，两组价值之和分别为 $18$ 和 $4$，最大值为 $18$。

其中第 $3$ 种方案的最大值 $12$ 是所有方案中最小的，故输出 $12$。

## 样例 #1

### 输入

```
5
6 1 3 8 4
2```

### 输出

```
12```

# 题解

## 作者：封禁用户 (赞：5)

# 思路

不得不说，简单！

这种最大值最小值一般都要首先考虑二分答案。

我们发现这题具有单调性，最大值越大，分的组就会越少。

然后我们就二分，每次查找 $mid$ 就可以了。

每次求出在最大值是 $f$ 的时候的答案，如果这个答案 $\le k$，就可以了。

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1005],l,r,mid;
bool check(int f){
	int b=0,c=0;
	for(int i=1;i<=n;i++){
		if(b+a[i]<=f)b+=a[i];
		else b=a[i],c++;
	}
	return c+1<=k;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i],r+=a[i],l=max(l,a[i]);
	cin>>k;
    l--;
	while(l+1<r){
        mid=(l+r)/2;
		if(check(mid))r=mid;
		else l=mid;
	}
	cout<<r;
}
```

---

## 作者：2b2b2bbb (赞：1)

简简单单的二分题目。可以发现，值之和的最大值的最小可能值越大，分的组就会越少，最小可能值越小，分的组就会越多。

那么，我们直接二分最小可能值。那么怎么看分了多少组呢？我们一路加上去，只要比我们枚举的要小，就继续加，否则就不加了，换组。

最后只要分的组比要求的要少就代表着这次枚举的答案是可行的。因为，我们可以将其他组分一分凑出要的组。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,sum;
int a[1005];
bool check(int x){
	int ans = 0;
	int d = 1;
	for(int i = 1 ; i <= n ; i ++){
		if(x < a[i]){
			return 0;
		}
		if(ans + a[i] <= x){
			ans += a[i];
		}else{
			d ++;
			ans = a[i];
		}
	}
	return d <= k;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1 ; i <= n ; i ++){
		cin >> a[i];
		sum += a[i];
	}
	cin >> k;
	int l = 1 - 1,r = sum + 1;
	while(l + 1 < r){
		int mid = (l + r) / 2;
		if(check(mid)){
			r = mid;
		}else{
			l = mid;
		}
	}
	cout << r;
	return 0;
}
```

---

## 作者：Aurelia_Veil (赞：0)

# 题解：B4305 \[蓝桥杯青少年组省赛 2024] 物品分组。

### 一、题目概括：

给定数组 $a_i$，要求分成 $k$ 组，让我们求每组的和的最小值最大是多少，即 $\min(sum_i)$（$sum_i$ 为每组的和）。

### 二、算法探讨：

从题目中：

> 各组价值之和的最大值的最小可能值。

而且最大值越小，分的组就越多；最大值越大，分的组越多。因此这道题具有单调性。

我们就能知道算法是二分答案。

### 三、思路解析：

首先，题目让我们求出每组的和的最大值，我们就要二分每组的和的最大值。

其次，在 `check` 函数中，我们已知每组的最大值，就要用唯一一个条件：分组组数来判断。

那么 `check` 函数怎么写呢？既然我们知道了每组的最大值，我们就可以在循环中使用 $sum$ 变量存储当前组的和，如果在这一次增加后，$sum$ 大于了 $k$ 那么就只能被分到下一组。

### 四、代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+11;
int n,m;
int a[N];
bool check(int k){
    int sum=0,cnt=1;
    for(int i=1;i<=n;i++){
        if(a[i]>k){
            return 0;
        }
        if(sum+a[i]>k){
            sum=a[i];
            cnt++;
        }else{
            sum+=a[i];
        }
    }
    return cnt<=m;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    scanf("%d",&m);
    int l=1,r=2e8;
    int ans=0;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

谢谢观看咩～

---

## 作者：Algo_Sl_al_jiye (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4305)

### 思路

易证此题答案具有单调性，即答案越大时需分的组数越少，答案越小时需分的组数越大，故此题可使用二分答案求解。

对于每个二分查找的 $mid$，我们求出答案最大为 $mid$ 时需分的组数，如果这个答案满足条件即可。

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1005], n, k;
bool check (int x) {
    int cur = 0, cnt = 1;//cnt表示组数，初始值为1是因为至少分1组
    for (int i = 1; i <= n; ++ i) {
        if (cur + a[i] <= x) cur += a[i];//如果加上a[i]本组和仍小于等于x则可以放入组中
        else {
            cur = a[i];
            ++ cnt;//反之新开一组
        }
    }
    return (cnt <= k);//如果组数满足要求则可以
}
int main () {
    ios::sync_with_stdio (false);
    cin.tie (0);
    cout.tie (0);
    cin >> n;
    int l = 0, r = 0;
    for (int i = 1; i <= n; ++ i) {
        cin >> a[i];
        r += a[i];//最大值为所有值之和
        l = max (l, a[i] - 1);//最小值比所有值中最小的一个小
    }
    cin >> k;
    while (l + 1 < r) {//二分答案
        int mid = l + r >> 1;
        if (check (mid)) r = mid;//满足则答案小于等于mid
        else l = mid;//不满足则答案大于mid
    }
    cout << r;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4305)   
### 思路
发现如果一个最大值是满足要求的，那比它更大的值必定会满足要求，比它小的则不一定。有单调性，可以用二分。   
二分，找这个最大值的最小值。然后判断其满不满足要求，只要求出这一最大值下最少的分组方法需要的组数，再与 $k$ 比较即可。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,a[1000001],t,w,k,mid,bao;
bool pd(int t){
	int i,s=0,ss=0;
	for(i=1;i<=n;i++)
		if(s+a[i]>t) ss++,s=a[i];
		else s+=a[i];
	ss++;    //注意最后一组
	return ss<=k;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=1;i<=n;i++)
		cin>>a[i],w+=a[i],t=max(t,a[i]); //以最大值为下限，以和为上限
	cin>>k;
	while(t<=w){
		mid=(t+w)/2;
		if(pd(mid)) bao=mid,w=mid-1;
		else t=mid+1;
	}
	cout<<bao;
}
```

---

## 作者：Mitchell_Dracula (赞：0)

### 思路：

一个简简单单的二分就行了。

题目求的是最大值最小，写一个二分答案模版就行了。

唯一需要发现的，就是此题具有**单调性**。这是二分很需要的一个性质。

于是我们直接二分最小值就可以了。

我们枚举每一个可能的答案，如果加下一个没有超过 $mid$，就加上，否则新建一个组。

已经很清晰了，上代码！

### 代码：

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <string>
#include <map>
#include <vector>
#include <queue>
#include <set>
#include <list>
#include <deque>
#include <stack>

int n, m, lef, rig, a[1000005], ans; 

bool check (int x) {
	int sum = 0, jsq = 1;
	for(int i = 1;i <= n;i ++) {
		if(sum + a[i] > x)//超过了mid 
		{
			jsq ++;//新建一组 
			sum = 0;//不要忘了清零！！！ 
		}
		sum += a[i];//加上 
	}
	return (jsq <= m);//记得判 
}

int read() {
    int res = 0;
    char c = getchar();
    bool f = false;
    while (c < '0' || c > '9') {
        if (c == '-')
            f = true;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        res = res * 10 + (c - '0');
        c = getchar();
    }
    if (f)
        res = -res;
    return res;
}

void print (int x) {
    if (x == 0) {
        putchar('0');
        return;
    }
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    int b[50] = {}, top = 0;
    for (; x; x /= 10) {
        b[++top] = x % 10;
    }
    do {
        putchar(b[top] + '0');
    } while (--top > 0);
}

signed main() {
	n = read (); 
	for(int i = 1;i <= n;i ++) {
		a[i] = read ();
		rig += a[i], lef = std::max (lef, a[i]);//注意一个初值问题 
	}
	m = read ();
	while (lef <= rig) {//二分主体 
		int mid = (lef + rig) >> 1;
		if (check (mid)) {
			rig = mid - 1;
			ans = mid;
		}
		else {
			lef = mid + 1;
		}
	}
	print (ans);
	return 0;
}



```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/B4305)

本蒟蒻建议先做[这道题](https://www.luogu.com.cn/problem/P2440)，这道题比较基础，思路也很相似。

## 题目思路：
这还用说吗？肯定是**二分答案**呀！

模板：

```cpp
while(l<=r){
  int mid=l+r>>1;
  if(check(mid)) r=mid-1;
  else l=mid+1;
}
```

这道题的重点是判断函数，如果这个物品的价值已经 $>$ 现在的答案了，就无法装下，那就应该调整答案了。如果这个物品的价值 $+$ 目前包里的总价值 $\le$ 现在的答案，那就装进去。否则就新开一个袋子，并把当前的物品装进去。

思路讲的很清晰，上代码吧！

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,a[1005],s,l,r;
bool check(int x){
	int ans=0,cnt=1;
	for(int i=1;i<=n;i++){
		if(x<a[i]) return false;
		if(ans+a[i]<=x) ans+=a[i];
		else{
			cnt++;
			ans=a[i];
		}
	}
	return cnt<=k;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	int o=INT_MAX;
	for(int i=1;i<=n;i++) cin>>a[i],s+=a[i],o=min(o,a[i]);
	cin>>k;
	l=o,r=s;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)) r=mid-1;
		else l=mid+1;
	}
	cout<<l<<"\n";
	return 0;
}
```
懂了就给个赞！

---

## 作者：Jayfeather2012 (赞：0)

## 思路
一道二分~~  
因为各组价值之和的最大值的最小可能值具有单调性，也就是说，如果一个各组价值之和的最大值的上限可以使这些数被分成 $k$ 组，那么小于这个值的上限也可以使这些数被分成 $k$ 组，所以可以考虑二分。  
怎么看一个上限最少可以分多少组呢？我们遍历数组，用 $s$ 记录当前分组的和，如果这个值超过上限，就增加要分的组数，并清空 $s$，随后还要令 $s$ 加上当前遍历的数。  
整上二分的板子就 [AC](https://www.luogu.com.cn/record/list?pid=B4305&user=1046094) 啦！  
具体细节看代码吧！
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1005];
int check(int x){
    int s=0,ans=0;
    for(int i=1;i<=n;++i){
        if(x<a[i])return 0;
        //如果一个物品价值都比上限大，就一定不符合要求
        s+=a[i];
        //加上当前物品价值
        if(s>x){
            ++ans;
            //增加组数
            s=a[i];
            //s重置为当前物品价值
        }
    }
    ++ans;
    //最后还有一组
    return ans<=k;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    cin>>k;
    int l=1,r=1e8,ans;
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    //二分的板子
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：Break123 (赞：0)

**确定搜索范围**：最小可能的值是所有物品中的最大值（因为每个子数组至少要包含一个物品），最大可能的值是所有物品的总和（即不分组的情况）。

**二分搜索**：在最小值和最大值之间进行二分搜索，检查是否存在一种分组方式，使得所有子数组的和不超过当前中间值。

**检查可行性**：对于每个中间值，模拟分组过程，计算最少需要分成多少组才能保证每组和不超过该中间值。如果需要的组数不超过k，则该中间值可行，尝试寻找更小的值；否则，需要增大中间值。

```cpp
#include<bits/stdc++.h>
using namespace std;

bool check(const vector<int>& a, int k, int maxSum) {
    int sum = 0;      // 当前组的累计和
    int groups = 1;    // 当前分组数，初始为1组
    for (int num : a) {
        // 如果当前累计和加上当前物品超过maxSum，则需要新开一组
        if (sum + num > maxSum) {
            groups++;      // 增加分组数
            sum = num;     // 新组的和从当前物品开始
            if (groups > k) // 如果分组数超过k，则无法满足条件
                return false;
        } else {
            sum += num;    // 继续累加到当前组
        }
    }
    return true;           // 成功分组
}

int main() {
    int n, k;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    cin >> k;
    // 二分搜索的左边界：单个组的和至少是数组中最大的元素
    int left = *max_element(a.begin(), a.end());
    // 二分搜索的右边界：所有元素的总和（即不分组的情况）
    int right = accumulate(a.begin(), a.end(), 0);
    int answer = right;
    //二分搜索
    while (left <= right) {
        int mid = left + (right - left) / 2;
        //// 检查是否可以用mid作为最大组和完成分组
        if (check(a, k, mid)) {
            answer = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    //最小的最大组和
    cout << answer << endl;
    return 0;
}
```
 _**谢谢观看！！！**_

---

## 作者：tkm2013 (赞：0)

不难发现，这题其实是存在单调性的，最大值越大，分的组就会越少，最大值越小，分的组就会越多。既然有了单调性，就可以使用二分了，直接二分最大值。然后就是 $check$ 函数了，$check$ 函数就是求出在最大值是 $x$ 的时候，需要多少组，如果这个组数 $\le k$，就可以了。你肯定会有疑问，为什么是 $\le$ 呢？因为我们可以把一组拆分成两组，从而使组数变多。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[1005];
bool check(int x){
	int sum=0,cnt=0;
	for(int i=1;i<=n;i++){
		if(sum+a[i]<=x){
			sum+=a[i];
		}else{
			sum=a[i];
			cnt++;
		}
	}
    cnt++;//结束的时候还有一组
	return cnt<=k;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	int l=0,r=0;//二分的边界
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r+=a[i];
		l=max(l,a[i]);
	}
	cin>>k;
	l--;
	while(l+1<r){
		int mid=(l+r)/2;
		if(check(mid)){
			r=mid;
		}else{
			l=mid;
		}
	}
	cout<<r;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
  - 我们要求出各组价值之和的最大值的最小可能值，可以用二分法。
  - 枚举每一个数，加上下一个数还不会超过 $mid$，则加上，否则再开一组。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10001],ans,l,r,sum;
bool check(int mid)
{
	int sum=0,cnt=1;
	for(int i=1;i<=n;i++)
	{
		if(sum+a[i]>mid)
		{
			cnt++;
			sum=0;
		}
		sum+=a[i];
	}
	return (cnt<=m);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		r+=a[i];
		l=max(l,a[i]);
	}
	scanf("%d",&m);
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(check(mid))
		{
			ans=mid;
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---


# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# 题解

## 作者：北街的九命貓 (赞：911)

```cpp

【二分】
因为区间很大，所以可以二分。
三个答案都在[-100,100]范围内，两个根的差的绝对值>=1,保证了每一个大小为1的区间里至多有1个解，也就是说当区间的两个端点的函数值异号时区间内一定有一个解，同号时一定没有解。那么我们可以枚举互相不重叠的每一个长度为1的区间，在区间内进行二分查找。
【参见代码】
#include<cstdio>
double a,b,c,d;
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);  //输入
    for (i=-100;i<100;i++)
    {
        l=i; 
        r=i+1;
        x1=fc(l); 
        x2=fc(r);
        if(!x1) 
        {
            printf("%.2lf ",l); 
            s++;
        }      //判断左端点，是零点直接输出。
                        
                        //不能判断右端点，会重复。
        if(x1*x2<0)                             //区间内有根。
        {
            while(r-l>=0.001)                     //二分控制精度。
            {
                m=(l+r)/2;  //middle
                if(fc(m)*fc(r)<=0) 
                   l=m; 
                else 
                   r=m;   //计算中点处函数值缩小区间。
            }
            printf("%.2lf ",r);  
            //输出右端点。
            s++;
        }
        if (s==3) 
            break;             
            //找到三个就退出大概会省一点时间
    }
    return 0;
}

```

【盛金公式】の做法
```cpp
#include <iostream>
#include <math.h>
#include <iomanip>
using namespace std;
int main()
{
     double a,b,c,d;
     double as,bs,t,si;
     double x1,x2,x3;
     cin>>a>>b>>c>>d;
     as=b*b-3*a*c;
     bs=b*c-9*a*d;
     t=(2*as*b-3*a*bs)/(2*sqrt(as*as*as));
     si=acos(t);
     x1=(-b-2*sqrt(as)*cos(si/3))/(3*a);
     x2=(-b+sqrt(as)*(cos(si/3)+sqrt(3)*sin(si/3)))/(3*a);
     x3=(-b+sqrt(as)*(cos(si/3)-sqrt(3)*sin(si/3)))/(3*a);
     cout<<fixed<<setprecision(2)<<x1<<" ";
     cout<<fixed<<setprecision(2)<<x3<<" ";
     cout<<fixed<<setprecision(2)<<x2<<" ";
     return 0;
}
```
盛金公式：
       
       一元三次方程:aX的三次方+bX的二次方+cX+d=0
       重根判别公式：
           A=b的二次方-3ac
           B=bc-9ad
           C=c的二次方-3bd
       当A=B=0时，X1=X2=X3= -b/3a= -c/b = -3d/c

【暴力枚举--出奇迹】

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
   double a,b,c,d;
   scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
   for(double i=-100;i<=100;i+=0.001)
   {
      double j=i+0.001;
      double y1=a*i*i*i+b*i*i+c*i+d;
      double y2=a*j*j*j+b*j*j+c*j+d;
      if(y1>=0&&y2<=0||y1<=0&&y2>=0)
      {
         double x=(i+j)/2;
         printf("%.2lf ",x);
      }
   }
}
```

---

## 作者：GGN_2015 (赞：197)

牛顿迭代法，看到没人用这种方法，就写了一个。


对于一个已知的x值，每一次根据函数在这一点的导数，把x移动到，切线与x轴相交的地方。


即x[n+1]=x[n]-f(x)/f'(x)，可以证明结果会趋近于函数的一个解，据说这种方法比二分要快。


```cpp
#include<cstdio>
#include<complex>
#include<algorithm>
#include<set>
using namespace std;

struct func3
{
    double a,b,c,d;
    func3(double A=0,double B=0,double C=0,double D=0){a=A;b=B;c=C;d=D;}
    double operator()(double x){return ((a*x+b)*x+c)*x+d;}
    double dvt(double x){return (3.0*a*x+2.0*b)*x+c;}
};

void func3solve(func3 f,double st,double& val,double& sol)
{
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++)
    {
        st=st-f(st)/f.dvt(st);
    }
    val=f(st);sol=st;
}

double fix2(double sol)
{
    return (double)int(sol*100.0+(sol>0?0.5:-0.5))/100.0;
}

set<double>solutions;
int main()
{
    double a,b,c,d;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    func3 f(a,b,c,d);
    for(double i=-100.0;i<=100.0;i+=0.5)
    {
        double val,sol;
        func3solve(f,i,val,sol);
        sol=fix2(sol);
        if(abs(val)<1e-6 && solutions.find(sol)==solutions.end())
            solutions.insert(sol);
    }
    for(set<double>::iterator it=solutions.begin();it!=solutions.end();it++)
    {
        double x=(*it);
        printf("%.2lf ",x);
    }
    return 0;
}
```

---

## 作者：高木木 (赞：177)

**暴力出奇迹。**

大家请看


![](https://cdn.luogu.com.cn/upload/pic/41984.png)



我看到标签后就专注于写暴力..最后终于AC    代码比较简洁~~混个题解~~跟大家分享一下

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double a,b,c,d,a1,b1,c1,d1;// 题目要的数据是小数点后2位所以定义首先用double
int num;// num用来记录解的个数 因为一元三次方程只有三个解  解达到三个以后就break掉 减少多余循环
int main()
{
	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);// double类型用 lf 输入哦
	for(double i=-100.00;i<=100.00;i+=0.001)// 最后结果保存两位数 所以这里i每次加0.001（n只有100所以暴不了）
	{
		double l=i,r=i+0.001;
		if((a*l*l*l+b*l*l+c*l+d)*(a*r*r*r+b*r*r+c*r+d)<0)// 若存在两个数x1，x2且x1<x2，f（x1）*f（x2）<0 则方程解肯定在x1~x2范围内   基本数学原理
		printf("%.2f ",l),num++;// 小数点后两位输出
		if(num==3) break;// 解达到三个break掉
	}
	return 0;
}
```

---

## 作者：team109 (赞：132)

其实公式法虽然赖皮但不失为一种好方法  
$ $  
#### 0.前备知识：  
**一元三次方程的求解**。  

对于
$$ax^3+bx^2+cx+d=0\ (a\ne0)$$  

求解方法：第一步：配方，换元，去三次项系数 

于是只需解形如
$$x'^3+px'+q=0$$  
的方程。  
$ $  
$ $  
$ $  
又有
$$(a+b)^3=a^3+3a^2b+3ab^2+b^3$$
$$\qquad\quad=a^3+b^3+3ab(a+b)$$
所以令a+b=X，有
$$X^3=a^3+b^3+3abX$$
即
$$X^3+(-3ab)X+(-a^3-b^3)=0$$
也就是说，要解
$$x'^3+px'+q=0$$  
只需求出符合条件的a、b即可。这样就直接$X=a+b$，解出结果。  
$$\begin{cases}-3ab=p\\-a^3-b^3=q\end{cases}$$   
即
$$\begin{cases}-27a^3b^3=p^3\\-a^3-b^3=q\end{cases}$$   
而这很容易解决，解出$p^3$和$q^3$再开根即可。   
(其实解出来符合条件的实数对(a,b)只有一组，三个解为
$$x_1=a+b$$
$$\quad\,\ x_2=\omega a+\overline{\omega}b$$
$$\quad\,\ x_3=\overline{ω}a+\omega b$$
其中$\omega$为三次单位根$\frac{1+\sqrt{3}i}{2}$,$\overline{\omega}$为三次单位根$\frac{1-\sqrt{3}i}{2}$)

$ $  
------------

#### 1.由此可得出著名的卡尔丹公式：  

对于$ax^3+bx^2+cx+d=0(a≠0)$, 
$$p=\frac{3ac-b^2}{3a^2},q=\frac{27a^2d-9abc+2b^3}{27a^3}$$  
$$x_1=\sqrt[3]{-\frac{q}{2}\!+\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!\!+\sqrt[3]{-\frac{q}{2}\!-\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!-\frac{b}{3a}$$
$$\quad\ x_2=\omega\sqrt[3]{-\frac{q}{2}\!+\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!\!+\!\overline{\omega}\sqrt[3]{-\frac{q}{2}\!-\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!-\frac{b}{3a}$$
$$\quad\ x_3=\overline{\omega}\sqrt[3]{-\frac{q}{2}\!+\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!\!+\!\omega\sqrt[3]{-\frac{q}{2}\!-\!\sqrt{\left(\frac{q}{2}\right)^2\!\!+\!\left(\frac{p}{2}\right)^3}}\!-\frac{b}{3a}$$
其中出现复数，把实部和虚部分别用一个`double`存储并分别处理即可。听说有种神奇的东西叫`complex`?  
实际实现时，把$\dfrac{q}{2}$和$\dfrac{p}{3}$以及$\sqrt{\left(\dfrac{q}{2}\right)^2\!\!+\!\left(\dfrac{p}{2}\right)^3}$作为一个整体存储。

$ $  
------------
#### 2.代码：

略。（让$\mathtt{dalao}$帮忙实现一下吧。）

$ $  
------------
#### 3.性能分析：
1.比盛金公式慢，但精度好（盛金公式要用到误差很大的`sin`和`cos`）  
2.和二分相当且速度受数据范围、精度要求影响小  

##### Update:2019/8/7,更新了一些排版上的bug，同时纠正了一个错误。手打公式不免可能出一些错误，望管理大大包容~  
##### 另吐槽：$\LaTeX$里的$\omega$好丑

---

## 作者：小菜鸟 (赞：13)

厌倦了公式、二分、导数，是时候来一发割线法了！  

割线法是基于牛顿法的一种改进，用通过两点的割线来代替函数在某一点的导数，将非线性方程化为线性方程进行迭代求解。  

正常的牛顿迭代公式：  

$$x=x_0-\frac{f(x_0)}{f'(x_0)}$$

有时对函数求导并不是那么容易，这个时候就需要割线法。  

考虑将$f'(x)$换成函数图像割线的斜率$\frac{f(x_1)-f(x_0)}{x_1-x_0}$,则原迭代公式化为  

$$x=x_0-\frac{x_1-x_0}{f(x_1)-f(x_0)}f(x_0)$$

每迭代一次，将$x_1$换成$x_0$，$x_0$换成求出的$x$即可。  

已经证明割线法以$p=\frac{\sqrt{5}+1}{2}$的速度收敛，比牛顿法略慢，但还是很好用的。  

下面贴代码  

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
double f(double x,double a,double b,double c,double d)//用于计算三次函数值
{
    return a*x*x*x+b*x*x+c*x+d;
}
double solve(double a,double b,double c,double d,double x0,double x1)//割线法求解
{
    double xx[2]={x0,x1};//用xx数组滚动存储结果
    int flag=0;
    while(abs(xx[0]-xx[1])>1e-4)//控制精度
    {
        xx[flag]=xx[flag]-f(xx[flag],a,b,c,d)/((f(xx[flag],a,b,c,d)-f(xx[flag^1],a,b,c,d)))*(xx[flag]-xx[flag^1]);
        flag^=1;
    }
    return xx[0];
}

double a,b,c,d,x[3]={-1000,-1000,-1000};
int tot;

bool check(double xx)//判断是否为新的解
{
    bool flag=0;
    for(int i=0;i<3;++i)flag|=abs(xx-x[i])<0.5;
    return !flag;
}

int main()
{
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    for(double i=-100;i<=100;i+=0.5)//注意这里以0.5为步长枚举。我一开始步长为一，结果有一个点答案有1.0,2.0，直接除以零GG
    {//当然你也可以在除以零时特判，但我懒得写了
        double xx=solve(a,b,c,d,i,i+0.5);
        if(check(xx))x[tot++]=xx;
    }
    sort(x,x+3);//不要忘记从小到大排序 //我太懒了QAQ
    for(int i=0;i<3;++i)printf("%.2lf ",x[i]);
}
```

各种迭代法真的好次啊ヾ(ﾟ∀ﾟゞ)

---

## 作者：ljh0727 (赞：10)

# P1024 一元三次方程求解

题目传送门：[题目](https://www.luogu.com.cn/problem/P1024)

### 暴力

因为根的范围在 $-100$ 到 $100$ 内，所以我们可以暴力枚举范围的每个区间。

### 二分法

根据题目所给信息，三个根的范围一定是在 $-100$ 到 $100$，并且任意两个根的绝对值之差大于等于 $1$，可知根的总范围为 $-100$ 到 $100$ 且最小寻找区间长度为 $1$。

我们只需要从 $-100$ 开始以 $1$ 为区间长度，不断判断区间内是否有根。

### 盛金公式

我们将一元三次方程表示为：

 $ax^3 + bx^2 + cx + d = 0$

重根判别式为：

 $\begin{cases} A = b^2 - 3ac \\ B = bc - 9ad \\ C = c^2 - 3bd \end{cases}$ 

当 $A = B = C$ 时：

 $x_1 = x_2 = x_3 = \frac{-b}{3a} = \frac{-c}{b} = \frac{-3d}{c}$ 

当 $b^2 - 4ac > 0$ 时：

 $\begin{cases} x_1 = \frac{-b-(\sqrt[3]{y_1} + \sqrt[3]{y_2})}{3a} \\ x_{2,3} = \frac{-b + \frac{1}{2}(\sqrt[3]{y_1} + \sqrt[3]{y_2}) \pm \frac{\sqrt{3}}{2}(\sqrt[3]{y_1} - \sqrt[3]{y_2})i}{3a} \end{cases}$ 

其中 $y_{1,2} = Ab + \left(\frac{-B \pm \sqrt{B^2 - 4ac}}{2} \right)$，$i^2 = -1$。

当 $B^2 - 4ac = 0$ 时：

 $\begin{cases} x_1 = \frac{-b}{a} + k \\ x_2=x_3=\frac{-k}{2} \end{cases}$ 

其中 $k = \frac{B}{A}$。

当 $B^2 - 4ac < 0$ 时：

 $\begin{cases} x_1 = \frac{-b-2\sqrt{A} \cos \frac{\theta}{3}}{3a} \\ x_{2,3} = \frac{-b+\sqrt{A} \left( \cos \frac{\theta}{3} \pm \sqrt{3} \sin \frac{\theta}{3} \right)}{3a} \end{cases}$ 

其中 $\theta=\arccos T$，$T=\frac{2Ab - 3aB}{2\sqrt{A^3}}$。

### 牛顿迭代法

假设我们要解一个**标量方程** $f(x) = 0$，其中我们已知是**可微函数**。

牛顿迭代法的核心是构造 $f(x)$ 在某点 $x_n$ 处的切线，使其切线与 $x$ 轴的交点为下次迭代的**猜测值**。

我们可以在 $x_n$ 处的泰勒级数展开，那么可以得到。

 $f(x) = f(x_n) + f^\prime(x_n)(x-x_n) + O((x-x_n)^2)$ 

我们可以忽略高阶项 $O((x-x_n)^2)$，直接将 $f(x)=0$ 代入。

那么就是 $0 = f(x_n) + f^\prime(x_n)(x-x_n)$。

所以 $x = x_n - \frac{f(x_n)}{f^\prime(x_n)}$。

这就是牛顿迭代法的迭代公式，根据公式，我们每次迭代的时候用点 $x_n$ 处的函数值 $f(x_n)$ 和导数 $f^\prime(x_n)$ 来计算新的估计值 $x_n+1$ 就可以不断提高精确度。

### 勘根定理

勘根定理是介值定理的一个特例。

勘根定理，即零点存在定理。

设函数 $f$ 在闭合区间 $a$ 到 $b$ 中连续，且函数值 $f(a)$ 与 $f(b)$ 异号。

则在区间内找到数 $x$，使得 $f(x) = 0$，那么 $x$ 为函数 $f$ 的根。

### 代码

暴力。

```cpp
#include<iostream>
#include<cstdio>



using namespace std;



int main(){
	
	
	double a,b,c,d;
	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
	
	
	for(double i=-100;i<=100;i+=0.001){
    	double j=i+0.001;
    	double y1=a*i*i*i+b*i*i+c*i+d;
    	double y2=a*j*j*j+b*j*j+c*j+d;
    	if(y1>=0&&y2<=0||y1<=0&&y2>=0){
        	double x=(i+j)/2;
        	printf("%.2lf ",x);
		}
	}
	
	return 0;
}



```

二分。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm> 

using namespace std;

double a, b, c, d;
double f(double x) { 
    return a * x * x * x + b * x * x + c * x + d; 
}

double search(double l, double r) {
    double mid;
    bool flag = true;
    for (int i = 0; i <= 2000; i++) {
        mid = (l + r) / 2.0;
        if (f(l) * f(mid) <= 0)
            r = mid;
        else if (f(r) * f(mid) <= 0)
            l = mid;
        else {
            flag = false;
            break;
        }
    }
    if (flag)
        return mid;
    return -1000;
}

int main() {
    cin >> a >> b >> c >> d;
    double X[3];
    int cnt = 0;
    for (int i = -100; i <= 100; i++) {
        double x = search(i, i + 1);
        if (x != -1000 && X[0] != x && X[1] != x && X[2] != x)
            X[cnt++] = x;
    }
    printf("%.2lf %.2lf %.2lf", X[0], X[1], X[2]);
    return 0;
}
```

盛金公式。


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>

using namespace std;

bool cmp(double aa,double bb){
	return aa<bb;
}

int main(){
	double a,b,c,d;
	double as,bs,t,si;
	double x1,x2,x3;
	cin>>a>>b>>c>>d;
	as=b*b-3*a*c;
	bs=b*c-9*a*d;
	
	t=(2*as*b-3*a*bs)/(2*sqrt(as*as*as));
	si=acos(t);
	
	x1=(-b-2*sqrt(as)*cos(si/3))/(3*a);
	x2=(-b+sqrt(as)*(cos(si/3)+sqrt(3)*sin(si/3)))/(3*a);
	x3=(-b+sqrt(as)*(cos(si/3)-sqrt(3)*sin(si/3)))/(3*a);
	double x[5];
	x[1]=x1;x[2]=x2;x[3]=x3;
	
	sort(x+1,x+4,cmp);
	
	printf("%.2lf %.2lf %.2lf",x[1],x[2],x[3]);
	return 0;
}

```
牛顿迭代法。


```cpp
#include<iostream>
#include<cstdio>
#include<set>
#include<cmath>

using namespace std;

set<double> q;

struct node{
	double a,b,c,d;
	node(double A=0,double B=0,double C=0,double D=0){
		a=A;b=B;c=C;d=D;
	}
	double operator()(double x){
		return ((a*x+b)*x+c)*x+d;
	}
	double dvt(double x){
		return (3.0*a*x+2.0*b)*x+c;
	}
};

void solve(node f,double st,double& val,double& s){
	for(int i=1;!(abs(f(st))<1e-6)&&i<=100;i++){
		st=st-f(st)/f.dvt(st);
	}
	val=f(st);
	s=st;
}

double f1(double s){
	return (double)int(s*100.0+(s>0?0.5:-0.5))/100.0;
}


int main(){
	double a,b,c,d;
	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
	node f(a,b,c,d);
	
	for(double i=-100.0;i<=100.0;i+=0.5){
		double val,s;
		solve(f,i,val,s);
		s=f1(s);
		if(abs(val)<1e-6&&q.find(s)==q.end())
			q.insert(s);
	}
	
	for(set<double>::iterator it=q.begin();it!=q.end();it++){
		double x=(*it);
		printf("%.2lf ",x);
	}
	return 0;
}

```

勘根定理


```cpp
#include<iostream>
#include<cstdio>

using namespace std;

double a,b,c,d;

double f(double x){
	return (x*x*x*a+x*x*b+x*c+d);
}

int main(){
	double x1,x2,xx;
	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
	
	for(double i=-100;i<=100;i++){
		
		x1=i;x2=i+1;
		if(f(x1)==0)
			printf("%.2lf ",i);
		
		if(f(x1)*f(x2)<0){
			while(x2-x1>=0.001){ 
				xx=(x1+x2)/2;
				if(f(x1)*f(xx)<=0)
					x2=xx;
				else
					x1=xx;
			}
			printf("%.2lf ",x1);
		}
		
	}
}

```

---

## 作者：ryf2011 (赞：4)

# 题目思路
由于范围很大，所以我们考虑二分。

在输入完成后，先按照题意定义函数 $f()$，定义两个变量 $l,r$ 分别代表左区间和右区间，如果此时 $f(l)$ 的最终结果在近似值范围之内，说明找到了解，直接输出，同时判断是否输出了 $3$ 个，输出足够之后直接退出循环。**输出时要保留 $2$ 位小数**。

根据题意可知，如果 $f(l) \times f(r) < 0$，那么 $l$ 与 $r$ 之间一定有解，所以我们此时直接二分寻找答案。

定义一个 $mid$，如果 $f(l) \times f(mid) < 0$，那么解就在这个范围之内，否则就在另一个区间。

最后输出答案即可。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const double eps=0.001; //为防止超出时限，定义一个近似值 
double a,b,c,d; //输入的数（实数） 
int cnt; //cnt:记录答案个数
double f(double x){ //方程求值（题意可知） 
	return a*x*x*x+b*x*x+c*x+d;
}
double binary_search(double l,double r){ //二分寻找解 
	double mid=(l+r)/2.0; //细节：要除以 2.0 
	if(l>=r-eps){ //在近似值范围内即可 
		return mid;
	}
	if(f(l)*f(mid)<0){ //如果小于 0，说明在左区间 
		return binary_search(l,mid);
	}
	else{ //否则，在右区间 
		return binary_search(mid,r);
	}
} 
int main(){
	scanf("%lf %lf %lf %lf",&a,&b,&c,&d); //double 类型输入为 %lf 
	for(int i=-100;i<100;i++){ //答案区间（题意可知） 
		double l=i; //左区间 
		double r=i+1; //右区间                                                                              
		if(fabs(f(l))<=eps){ //fabs():double 类型绝对值 
			printf("%.2lf ",l); //输出解（保留 2 位小数） 
			cnt++; //计数 +1 
		}
		else if(fabs(f(r))<=eps){
			continue; //中断本次循环 
		}
		else if(f(l)*f(r)<0){ //找区间内是否有解 
			printf("%.2lf ",binary_search(l,r)); //输出解 
			cnt++; //计数 +1 
		}
		if(cnt==3){ //题目要求只输出三个解，因此在输出完成后直接退出循环即可。 
			break;
		}
	}
	return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：cff_0102 (赞：3)

首先，最简便的方法是使用**盛金公式**。

假设方程为 $ax^3+bx^2+cx+d=0$，那么：

令 $\begin{cases}A=b^2-3ac\\B=bc-9ad\\C=c^2-3bd\\\Delta=B^2-4AC\end{cases}$。

对于一般的一元三次方程：

- 当 $A=B=0$ 时，方程有一个三重实根，适用盛金公式 $1$。
- 当 $\Delta>0$ 时，方程有一个实根和一对共轭复根，适用盛金公式 $2$。
- 当 $\Delta=0$ 时，方程有三个实根，其中有一个二重实根，适用盛金公式 $3$。
- 当 $\Delta<0$ 时，方程有三个不相等的实根，适用盛金公式 $4$。

注意到题面中：

> 该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。

因此只会出现 $\Delta<0$ 的情况，适用盛金公式 $4$：

$$x_1=\dfrac{-b-2\cos\frac{\theta}{3}\sqrt A}{3a},x_{2,3}=\dfrac{-b+(\cos\frac{\theta}{3}\pm\sqrt 3\sin\frac{\theta}{3})\sqrt A}{3a}$$

其中 $\theta=\arccos{\dfrac{2Ab-3aB}{2\sqrt{A^3}}}$。

对应代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long double 
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cout<<fixed<<setprecision(2);
	int a,b,c,d;
	cin>>a>>b>>c>>d;
	int A=b*b-3*a*c;
	int B=b*c-9*a*d;
	int C=c*c-3*b*d;
//	int D=B*B-4*A*C;
	int t=acosl((2*A*b-3*a*B)/(2*sqrtl(A*A*A)));
	int x1=(-b-(2*cosl(t/3))*sqrtl(A))/3*a;
	int x2=(-b+(cosl(t/3)+sqrtl(3)*sinl(t/3))*sqrtl(A))/3*a;
	int x3=(-b+(cosl(t/3)-sqrtl(3)*sinl(t/3))*sqrtl(A))/3*a;
	cout<<min({x1,x2,x3})<<" "<<x1+x2+x3-min({x1,x2,x3})-max({x1,x2,x3})<<" "<<max({x1,x2,x3});
	return 0;
}
```

然而，本题是 NOIP2001 提高组的题，除非你是范盛金本人，否则你不太可能在考场看到这道题的时候在自己的记忆中找到这样的公式。所以接下来介绍第二简便的方法，**暴力枚举**。

还是题面中的那句话：

> 该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。

因此我们可以直接从 $-100$ 枚举到 $100$，步长定为 $0.001$，如果该点函数值十分接近 $0$ 则输出保留两位小数后的结果并将当前数加上 $0.5$。循环最多进行 $200\div0.001=200000$ 次，即使是那个时候的评测机也可以通过。

对应代码（~~同样也是十九行~~）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long double
int a,b,c,d;
bool check(int x){
	return fabsl(x*x*x*a+x*x*b+x*c+d)<1e-5;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cout<<fixed<<setprecision(2);
	cin>>a>>b>>c>>d;
	for(int x=-100;x<=100;x+=0.001){
		if(check(x)){
			cout<<x<<" ";
			x+=0.5;
		}
	}
	return 0;
}
```

如果你闲得慌，也可以去使用那些看起来高级一点、更快的算法，或者用 C++ 的 `complex` 实现复数运算从而套用卡尔丹公式，但是对于这题来说，没必要。

---

## 作者：sunny12888 (赞：2)

## 题目解析
在此之前，我们先了解一个函数：$\operatorname{fabsl}$ 函数。

$\operatorname{fabsl}$ 是 C++ 中用于计算长双精度浮点数（long double）绝对值的函数。$\operatorname{fabsl}$ 函数接受一个长双精度浮点数作为参数，并返回该数的绝对值。

好的那我们开始分析：

我不会解一元三次方程。但看数据范围：在 $-100$ 到 $100$ 之间。这完全可以暴力解决问题。

题目也保证了：

> 且根与根之差的绝对值大于等于 $1$。

那我们算出满足符合要求的根后，把他加上 $0.5$（考虑小数误差），然后依次计算即可。

实测：时间为 $5ms$，通过此题无问题。

## Code 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long double
int a,b,c,d;
bool check(int x){
	return fabsl(x*x*x*a+x*x*b+x*c+d)<1e-5;//取其绝对值与1e-5比较，判断是否为根（考虑误差）
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cout<<fixed<<setprecision(2);//保留小数点后2位
	cin>>a>>b>>c>>d;
	for(int x=-100;x<=100;x+=0.001){//遍历
		if(check(x)){
			cout<<x<<" ";
			x+=0.5;
		}
	}
	return 0;//完结散花
}
```

---

## 作者：sbh2012 (赞：2)

## 思路
很明显这道题可以枚举，因为根是在 $-100$ 到 $100$ 之间，并且是精确到小数点后 $2$ 位，我们也就要算到第 $3$ 位，所以总共就 $200000$ 个数，完全可以暴力。我们只需要在循环内算出值，判断是否合法即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    double a,b,c,d;
    cin>>a>>b>>c>>d;
    for(double i=-100;i<=100;i+=0.001){//枚举根
        double j=i+0.001;
        if(a*i*i*i+b*i*i+c*i+d>=0&&a*j*j*j+b*j*j+c*j+d<=0||a*i*i*i+b*i*i+c*i+d<=0&&a*j*j*j+b*j*j+c*j+d>=0){//判断
            double x=(i+j)/2;
            printf("%.2lf ",x);
        }
    }
    return 0;
}
```

---

## 作者：sea_bird (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1024)。

# 题目分析

## 思路

看数据范围并不大，考虑暴力，根据题目所给公式 $a^3+b^2+cx+d=0$，在数据范围内枚举 $x$ 的值，如果结果与答案相差极小保留两位小数以后就是答案，循环时 $i$ 每次加上 $0.01$ 来枚举，~~不就完美解决了吗~~？

但是这样误差太大了，因此要换成更小的数，`for(double i=-100;i<=100;i+=0.00001)` 就足够了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double a,b,c,d;
	cin>>a>>b>>c>>d;
	for(double i=-100;i<=100;i+=0.00001){//注意精度
		if(abs((i*i*i*a)+(i*i*b)+(i*c)+d)<0.00001){//根据公式找到大概的值
			cout<<fixed<<setprecision(2)<<i<<" ";//保留两位小数输出
		}
	}
	return 0;
}
```

---

## 作者：Frank_G (赞：1)

# 思路

因为有若存在 $x1<x2,f(x1)\times f(x2)<0$，则在 $(x1,x2)$ 之间一定有一个根。

而题目保证了根的范围在 $-100$ 至 $100$ 之间且根与根之差的绝对值 $\ge 1$。

然后又由于题目要求输出两位小数，那么由于我们是四舍五入，所以我们只需要枚举每一个在 $-100$ 至 $100$ 之间的两位小数是否是答案即可，而**为了使其保证正确性，我们再往后枚举一位就能保证正确性了**。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c,d;
double f(double x){
	return x*x*x*a+x*x*b+x*c+d;
}//这样的话代码更简单。 
int main(){
	cin >> a >> b >> c >> d;
	for(double i=-99.995;i<=99.995;i+=0.01){
		if((f(i)>0&&f(i-0.01)<=0)||(f(i)<0&&f(i-0.01)>=0)) cout << fixed << setprecision(2) << (i-0.001) << " ";
	}
	return 0;
}
```
然后就可以 [AC](https://www.luogu.com.cn/record/200265359) 了。

---

## 作者：Jayfeather2012 (赞：0)

## 思路
暴力出奇迹~~  
根的范围在 $-100$ 到 $100$ 之间，又只要保留两位小数，这个范围很小，可以考虑暴力枚举。  
枚举 $-100$ 到 $100$ 中每一个可能的根，当根满足要求时输出它。  
剩下的细节看代码吧！  
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c,d;
int main()
{
	cin>>a>>b>>c>>d;
	for(double i=-100;i<=100;i+=0.001)
	//因为保留两位小数，所以每次加千分之一
	{
		double x=i,y=x+0.001;
		double xx=x*x*x*a+x*x*b+x*c+d,yy=y*y*y*a+y*y*b+y*c+d;
		//算出f(x)和f(y)
		if(xx<=0&&yy>=0||xx>=0&&yy<=0)
		//因为答案具有单调性，所以当存在两个数x和y，
		//使f(x)<=0且f(y)>=0，则根一定在这两个数之间
		{
			double ans=(x+y)/2;//取中间值
			cout<<fixed<<setprecision(2)<<ans<<" ";
			//保留两位小数输出啦！
		}
	}
  	return 0;
}
```

---

## 作者：mishitaotuoyyds (赞：0)

## 思路：
[题目传送门](https://www.luogu.com.cn/problem/P1024)。

首先由 $a x^3 + b x^2 + c x + d = 0$ 得 $a x^3 + b x^2 + c x = -d$，所以我们只需要找到 $x$ 使其满足此条件即可。

由题目提示又可知当两个只差 $0.001$ 的数代入后一正一负，即相乘小于零，那么这两个数的中间数一定是解。

其次由题目中解的范围在 $−100$ 至 $100$ 之间可知用暴力枚举可过。
## 代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c,d,j,i;
double pow1(double a,int b){//手打的求方函数
	double aa=1;
	for(int i=1;i<=b;i++){
		aa*=a;
	}
	return aa;
}
int main()
{
   
   cin>>a>>b>>c>>d;
   for(i=-100;i<=100;i+=0.001)
   {
      j=i+0.001;
      if((a*pow1(i,3)+b*pow1(i,2)+c*pow1(i,1)+d)*(a*pow1(j,3)+b*pow1(j,2)+c*pow1(j,1)+d)<0)cout<<fixed<<setprecision(2)<<((i+j)/2)<<" ";//判断并输出
   }
}
```
完结撒花。

---

## 作者：M1__ (赞：0)

# 题解：P1024 [NOIP2001 提高组] 一元三次方程求解
暴力枚举。                  
因为本题约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。                                            
即使我们令 $i$ 每次增加 $0.001$，循环才进行了 $\frac{200}{0.001}=2 \times 10^5$ 次，显然不会超过时间限制。                             
因此我们从 $-100$ 到 $100$ 来枚举 $i$，如果结果十分接近 $0$（代码中写的 $10^{-5}$）就保留两位小数输出即可。                   


```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d;
int main(){
	cin>>a>>b>>c>>d;
	for(double i=-100;i<=100;i+=0.001){
		if(fabs(i*i*i*a+i*i*b+i*c+d)<0.0001)
		cout<<fixed<<setprecision(2)<<i<<" ";
	}
	return 0;
}
```

其中 `fabs` 是 C++ 中求一个浮点数的绝对值函数，而 `cout<<fixed<<setprecision(2)<<i<<" "` 则是保留两位数输出的函数。            
这道题的其他解法还很多，例如盛金公式、卡尔丹公式、牛顿迭代法等。但是暴力枚举就足够了。

---

## 作者：Vct14 (赞：0)

由于范围只有 $[-100,100]$，精度只有 $0.01$，两根之差 $\ge1$，因此暴力枚举即可。对于每个 $i$ 直接判断它是否是给定方程的根，找到三个根就结束循环。

```cpp
#include<bits/stdc++.h>
using namespace std;

const double eps=1e-8;
const int N=-10000;
const int M=10000;

int main(){
	double a,b,c,d;
	cin>>a>>b>>c>>d;
	int s=0;
	for(double i=N; i<=M; i++){
		double x=i/100;
		if(abs(x*x*x*a+x*x*b+x*c+d)<=eps){
			printf("%.2lf ",x);
			s++; 
			i+=99;
		}
		if(s==3) break;
	}
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：枚举。  
由于这题枚举不会超时，所以我在这里给大家介绍一下枚举的实现方法。首先我们要知道枚举的范围。题目说了数据的范围，是 $-100$ 到 $100$。所以我们的范围就是题目说的范围。我们可以定义变量 $i$ 来枚举根。根据变量 $i$，我们就可以算出方程的值，再进行判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	double a,b,c,d;
	cin>>a>>b>>c>>d;
	for(double i=-100;i<=100;i+=0.001)
	{
		double k=i+0.001;
		double x=a*i*i*i+b*i*i+c*i+d;
        double y=a*k*k*k+b*k*k+c*k+d;
        if(x>=0&&y<=0||x<=0&&y>=0)
        {
           double x=(i+k)/2;
           printf("%.2lf",x);
           cout<<" ";
        }
	}
    return 0;
} 
```

---


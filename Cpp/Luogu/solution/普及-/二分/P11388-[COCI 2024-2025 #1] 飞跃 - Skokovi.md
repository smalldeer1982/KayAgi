# [COCI 2024/2025 #1] 飞跃 / Skokovi

## 题目背景


译自 [COCI 2024/2025 #1](https://hsin.hr/coci/) T2。$\texttt{5s,0.5G}$。满分为 $75$。

## 题目描述


有 $n$ 朵花，此外有一个正整数 $k$。第 $i$ 朵花的高度为 $a_i$。

一开始，Filip 在第 $1$ 朵花上。

当她在第 $i$ 朵花上时，她可以飞跃到第 $j$ 朵花上，当且仅当：

- $i\lt j$；
- $|a_i-a_j|\le k$。

Filip 想要知道她能够飞跃到哪些花上。

## 说明/提示


对于 $100\%$ 的数据，保证：

- $1\le n\le 2\times 10^5$；
- $1\le a_i,k\le 10^9$。


| 子任务编号 | $n\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $2\times 10^5$ | A    |   $ 25 $   |  
| $ 2 $    | $10^3$ |   |  $ 25 $   |  
| $ 3 $    | $2\times 10^5$  | | $ 25 $   |

- 特殊性质 A：$\forall 1\le i\lt n$，$a_i\lt a_{i+1}$。




## 样例 #1

### 输入

```
5 2
5 4 8 7 2```

### 输出

```
1 1 0 1 1```

## 样例 #2

### 输入

```
5 3
10 15 14 8 9```

### 输出

```
1 0 0 1 1```

# 题解

## 作者：K_yuxiang_rose (赞：7)

### 注：本题解代码和思路源自官方代码

考虑维护两个变量，分别记录到现在为止能跳到的花的最小值和最大值，显然在区间 $[minn-k,maxn+k]$ 的花都能被跳到，如果此时的花符合条件就输出 $1$ 并更新最小值和最大值，否则输出 $0$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005];
int main()
{
	int n,k; 
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	int minn=a[1],maxn=a[1];//一开始的最小值和最大值都是第一朵花的高度
	cout<<"1 ";
	for(int i=2;i<=n;i++)
	{
		if(minn-k<=a[i]&&a[i]<=maxn+k)
		{
			cout<<"1 ";
			minn=min(minn,a[i]);
			maxn=max(maxn,a[i]);
		}//如果满足条件就更新
		else cout<<"0 ";
	}
	return 0;
}
```

---

## 作者：liaoxingrui (赞：4)

## Content

有两个正整数 $n$ 和 $k$，有一个长度为 $n$ 的数列。

你初始在第一个数上，你可以从 $i$ 到 $j$，当且仅当：

- $i \lt j$
  
- $|a_i - a_j| \le k$

输出 $n$ 个数，如果能到 $i$ 输出 $1$，不能到 $i$ 输出 $0$。

## Solution

很明显需要 `lower_bound`，找与 $a_i$ 相近的数。就可以用 `set` 来存。

注意：

你不能跳到的数，就不能加进 `set` 中。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,k;
int a[N];
set<int> cnt;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cout<<"1 ";
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cnt.insert(a[1]);
	for(int i=2;i<=n;i++){
		bool flag=true;
		set<int>::iterator it=cnt.lower_bound(a[i]);
		if(*it>=a[i]&&*it-a[i]<=k)
			cout<<"1 ";
		else if(it!=cnt.begin()){
			it--;
			if(a[i]-*it<=k)
				cout<<"1 ";
			else{
				cout<<"0 ";
				flag=false;
			}
		}
		else{
			cout<<"0 ";
			flag=false;
		}
		if(flag)
			cnt.insert(a[i]);
	}
	return 0;
}
```

---

## 作者：mc_xiexie (赞：2)

### 题意
你位于 $x$ 的高度，你腿长 $k$ 米，只有你腿能到的地方你才能上去。且你离开后原来在的地方会消失，且不用考虑两块地方的横向距离。

### 做法

首先大模拟的 $O(n^2)$ 在 $n \le 2 \times 10^5$ 的数据范围显然超时，考虑优化。

1. 建一个数组存一个高度是否可行。

$a_i \le 10^9$ 明显超空间。

2. 用变量存可行的高度范围。

由于边界是由之前的高度更新的，所以不会出现一个高度到不了，但下面和上面都能到的情况。因为如果一边可以到，另一边一定需要中间值联通才能到。


```
#include <bits/stdc++.h>
using namespace std;
int n,k,fl[200005];
int main(){
	cin>>n>>k;
	for (int i=1;i<=n;i++) {
		cin>>fl[i];
	}
	int l=fl[1],r=fl[1];
	cout<<"1 ";
	for (int i=2;i<=n;i++){
		if(l-k<=fl[i] && fl[i]<=r+k){
			cout<<"1 ";
			l=min(l,fl[i]);
			r=max(r,fl[i]);
		} 
		else{
		    cout<<"0 ";
		}
	}
	cout<<"\n";
	return 0;
}
```

---

## 作者：JXR_Kalcium (赞：1)

## 题目大意

给定一个长度为 $n$ 的序列 $a_i$ 和一个正整数 $k$，初始时 $a_1$ 被标记。对于所有的 $i\ge 2$，$a_i$ 被标记当且仅当存在一个 $j$，使得 $j<i$ 且 $|a_i-a_j|\le k$，求出最后的标记序列，数据范围 $n\le 2\times 10^5$。

## 解题思路

考虑线性做法。对于 $|a_i-a_j|\le k$，可拆为 $a_i-a_j\le k$ 和 $a_j-a_i\le k$，移项可得 $a_j-k\le a_i\le a_j+k$，于是可以采用贪心，对于所有 $j<i$ 的 $a_j$ 都取一个最大值 $mx$ 及最小值 $mn$，如果 $mn-k\le a_i\le mx+k$ 即可被标记，时间复杂度 $O(n)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,k,x,mx,mn=INT_MAX;

int main()
{
	n=read(); k=read(); x=read();
	write(1); spc; mx=max(mx,x); mn=min(mn,x);
	
	while(--n)
	{
		x=read();
		
		if(x<=mx+k && x>=mn-k)
		{
			write(1); mx=max(mx,x);
			mn=min(mn,x);
		}
		
		else write(0); spc;
	}
	
    return 0;
}
```

---


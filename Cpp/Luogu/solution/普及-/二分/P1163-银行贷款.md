# 银行贷款

## 题目描述

当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。


## 说明/提示

数据保证，$1 \leq w_0, w\leq 2^{31}-1$，$1 \leq m\leq 3000$。

## 样例 #1

### 输入

```
1000 100 12
```

### 输出

```
2.9
```

# 题解

## 作者：笃行 (赞：148)

核心算法是秦九韶算法和二分法，另外需要一定的财经知识，否则就呵呵了。在数据里有一个坑爹的月利率214.7%的数据，这不是贷款，这是抢钱- -

所以在二分中，需要从0-5之间进行二分查找。根据题目可以得出公式a=(...（m\*(1+x)-y)(1+x)-y)...)（共t次乘法）（秦九韶算法）（m表示贷款的原值、y表示每月支付的分期付款金额、t表示分期付款还清贷款所需的总月数，a表示在t个月后按二分得到的利率还剩下多少钱没有还）。如果a是正数说明利率过大，则从左侧继续二分查找；如果a是负数说明利率过大，则从右侧继续二分查找；如果a等于零则输出结束程序。二分查找结束的另一个条件是精度小于0.0001。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
double m,y,s;
int t;
int out(double k)
{
    printf("%.1f",k*100);
    exit(0);
}
void solve(double l,double r)
{
    double k=(l+r)/2,u=r-l;
    double a=m;
    if(u<0.0001) out(k);
    for(int i=1;i<=t;i++)
          a=a*(1+k)-y;
    if(a>0) solve(l,k);
    if(a<0) solve(k,r);
    if(a==0) out(k);
}
int main()
{
    cin>>m>>y>>t;
    solve(0,5);
}
```

---

## 作者：greenheadstrange (赞：97)

- 预备知识——pow（）函数

pow（n，m）返回n的m次方（值为double）需要定义头文件**cmath**调用哦

- 数学推导：

设读入的三个数分别为n,m,k.

先写出方程看看：

k

∑{m*[1/（1+ans)]^i}=n

i=1

如果将ans看作自变量，n看作因变量时

容易证明，此函数具有单调性。

所以二分枚举ans的值，再进行判断即可

化简得后，用等比数列的求和公式得

###### [1/（1+ans)]^i=1-n/m*ans


- 小提示：

注意，**月利率可能大于1**（什么亏心银行）！

------------

不说了，直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double n,m,k,l,r;
bool pd(double x){//判断当前答案是否满足 
	return (pow(1.0/(1.0+x),k)>=1-n/m*x);//pow函数，上文已讲
}
int main(){
	cin>>n>>m>>k;
   	///////////////////////二分模板
	l=0;r=10;//月利率可能大于1
	while(r-l>=0.0001){//注意精度问题 
		double mid=(l+r)/2;
		if(pd(mid))r=mid;
		else l=mid;
	}
   	///////////////////////
	cout<<fixed<<setprecision(1)<<l*100;//输出一位小数哦 
	return 0;
} 
```


---

## 作者：HDawn (赞：86)


刚开始想用暴力枚举的方法，一个for循环，像这样
```
for (double j = 0.001; j < 1000; j += 0.001) {
        double w = a;
        for (int i = 0; i < c; ++i) 
            w = w - b + w * (j / 100);
        if (minn > abs(w)) {
            minn = abs(w);
            ans = j;
        } else break;
    }
```
每次循环后找出绝对值最小的未还的钱(w)所在的利率(j)就是答案。

而且没有超时，可是这题的数据利率竟然大于1，这样的过不了。

后来就想到了二分法，上代码。
```
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

int main() {
    double a, b, c;
    cin >> a >> b >> c;
    //l和r分别表示利率的最小值和最大值，也就是初始范围。
    double l = 0, r = 1000, mid = 0;
    //double数据类型，相差小于0.0001结束循环，避免多次循环
    while (l < r - 0.0001) {
        mid = (l + r) / 2;//mid为范围的中间值。
        double w = a;//w为未还的总钱数。
        for (int i = 0; i < c; ++i)//模拟还钱过程。
            w = w - b + w * (mid / 100);
        if (w > 0.0001)//检验在这个利率下，是否将钱还完。
            r = mid;//钱未还完，利率偏大，将范围最大值设置为中间值。
        else l = mid;//钱还多了，利率偏小，将范围最小值设置为中间值。
    }
    printf("%0.1f\n", round(l * 10) / 10);
    return 0;
}
```

结束。


---

## 作者：离散小波变换° (赞：82)

## 题目大意

给出$n,m,k$，求贷款者向银行支付的利率$p$,使得:

$$\sum_{i=1}^{k}\dfrac{m}{(1+p)^i}=n$$

按百分比形输出，精确到小数点后一位。

## 题解

$\text{orz}$，光是理解题意就理解了半天……果然语文差学$\text{OI}$也很难受。

题目中提到了一句很重要的话：**利率按月累计**。这是什么意思呢？这是指，假如第一个月的利率为$(1+p)$，那么第二个月就变成了$(1+p)^2$了。那么这两个月，你偿还的金额实际相当于你借得的$\frac{m}{1+p}+\frac{m}{(1+p)^2}$元。我们已知一共借了$n$元，那么就能得到上面提到的公式了。

关于如何计算$m$。首先，~~根据生活常识~~利率越大你实际偿还的金额（即你借到的$n$元）越小。我们对上式移项：

$$\sum_{i=1}^{k}\dfrac{1}{(1+p)^i}=\dfrac{n}{m}$$

当$p$小于正确答案时，左式就会小于右式。反之左式就会大于右式。因此我们可以根据$p$的单调性倍增。

我们设$f(p)=\text{左式}=\sum\limits_{i=1}^{k}\frac{1}{(1+p)^i}$。设当前答案为$p$,倍增量为$k$。那么如果$f(p)<\frac{n}{m}$，我们就可以让$p$加上$k$,**同时将$\bold k$翻倍**。否则将$k$减半。当$k$小于某个阈值（即精度）时，此时的$p$就是答案。

倍增算法有一个好处是，你几乎不用考虑上界（即使银行放超高利贷$\text{orz}$）。并且精度非常容易控制：你只需要将$p$和$k$初始为非常小的数(比如$10^{-6}$)，然后退出条件为$k$是否大于$10^{-11}$即可。

倍增的复杂度与二分相同，为$\mathcal O(K \log N)$。其中$N$为答案除以精度，$K$为分期付款总天数。

## 参考代码

代码异常简短，尤其是倍增只要两三行就能搞定了。

```
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
int n,m,t;
bool chk(double x){	//检查当前答案是否偏小
    double w=1,tot=0;
    up(1,t,i) w/=(1+x),tot+=w;
    return tot>(double)n/m;
}
int main(){
    n=qread(),m=qread(),t=qread();
    double p=-1e-9,k=1e-9; while(k>1e-11){	//倍增
        if(chk(p+k)) p+=k,k*=2.0; else k/=2.0;
    }
    printf("%.1lf\n",(p*100.0));
    return 0;
}
```

---

## 作者：MegaMay (赞：57)

本蒟蒻的第一篇题解qwq ,求过

### 一道经典的二分答案

这两天在学二分做到的题，感觉很水

首先！此题数据很小！我只用了16ms !

看完题解才知道，原来本题是有公式的，但看不懂啊…

我是照题意写的：100/1.029+100/1.029^2+ … +100/1.029^12 = 1000

于是就有了下面的代码


```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
using namespace std;
double n,m,s,ans;
int k;
int right(double u){
	double sum=0,v=1;
	for(int i=1;i<=k;i++){  // 公式的原型 
		v*=(1+u);
		sum+=(m/v);
	}
	if(sum==n) return 0;  // 判断条件 
	if(sum>n) return 1;
	else return -1;
}
int main(){
	scanf("%lf%lf%d",&n,&m,&k);
	double l=0,r=800,mid;
	while(r-l>=0.0001){ // 二分答案 
		mid=(l+r)/2;
		//printf("%.1lf\n",mid*100);
		if(!right(mid)) break;
		if(right(mid)==1) l=mid;
		else r=mid;
	}
	printf("%.1lf",mid*100); //mid*100 --> 百分数处理 
	return 0;
}

```
### throw flowers ~ qwq


---

## 作者：锦瑟，华年 (赞：45)

我又来写题解了，qwq。

二分题，一道基础二分题，没啥好说的，就是二分求利率。要注意的是，这里是小数，要用 double ，还有复利是什么呢，并不是平常的银行存款或贷款，而是在每月的基础上，乘上这个利率，即（$x$ 表示利率）：

$money=n(1+x)(1+x)(1+x)(1+x)……$ 。

好了，上代码吧，代码会有详细注释：

 	#include<stdio.h>
	using namespace std;
 	double n,m,t;//小数，用 double
	double find(double l,double r){//二分
		double mid=(l+r)/2,ans=n;//模板，ans 表示目前欠的钱
  		for(int i=1;i<=t;i++){//模拟还钱过程
    		ans=ans*(1+mid)-m;//先计算复利，再还钱
		}
		if(ans==0||r-l<0.0001)return mid;//ans==0表示钱还清了，后面那个，表示精度足够，满足两种情况任意一种，则返回
		if(ans<0)return find(mid,r);//二分递归查找
		else return find(l,mid);//ans<0,表示钱还多了，则利率增大，反之，则利率变小
	}
	int main(){
  	  	scanf("%lf%lf%lf",&n,&m,&t);//输入
  	  	double h=find(0,5);//开始二分，话说最好开大一点，那个214.7%的数据，嗯……是来抢钱吧
  	  	printf("%.1lf",h*100);//输出，注意，要乘以100，抵消百分号
  	  	return 0;//over
	}
    
好了，拜拜~~

---

## 作者：clyoyo (赞：26)

给P党的公式:

公式：P=A\*（1-(1+i)^-M）/i

其中P为贷款的原值，A为每月支付的分期付款金额，M为还款月数，i为月利率；

测试点i可能>1 好坑


---

## 作者：sunyt (赞：14)

分析一下样例，就是100/1.029+100/（1.029^2）+…+100/（1.029^12）≈1000

可能思路不太一样



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
using namespace std;
double x,m,a=0,b=1000,mid;          //这里一定要开的足够大，从0到1000，显然我疯了
int i,j,t;
double f(double xx)
{
    double ans=0,bb=xx;
    for(i=1;i<=t;i++)
    {
        ans+=m/xx;
        xx*=bb;
    }                                                           
    ans-=x;
    return ans;
}                                                 //函数f(x)的值，具体公式见上理解
int main()
{
    //freopen("LOAN.IN","r",stdin);
    //freopen("LOAN.OUT","w",stdout);
    cin>>x>>m>>t;
    double fa=f(a);
    double fb=f(b);
    while(abs(b-a)>0.00001)               //用二分法来解
    {
        mid=(a+b)/2;
        double fm=f(mid);
        if(f(a)*f(b)<0)
        {
            if(fa*fm<0)
            {b=mid;fb=fm;}
            if(fb*fm<0)
            {a=mid;fa=fm;}
        }
        else if(fa==0)
        {printf("%.1f",(a-1)*100);break;}
        else if(fb==0)
        {printf("%.1f",(b-1)*100);break;}             //一旦有f(x)=0的情况，就直接输出x
    }
    printf("%.1f",(b-1)*100);                         //按照精度输出
}
```

---

## 作者：MilkyCoffee (赞：14)

## 重点思路区

对没背过公式还看不懂是怎么搞的人是最舒服的了 ~~其实是因为我不会用公式 /kk~~

```cpp
mid = (l + r) / 2;
double ans = m;
for (int i = 0; i < k; i++) ans *= (1 + mid/100) - m;

		if (ans > 1e-4) r = mid;
        // 这里要精确到小数点后四位
		else l = mid;

```

我们运用二分查找枚举利率。

首先，计算出还款之后还剩多少贷款

如果没有还完的话，利率就比mid大，就要更改r。

如果还完了，利率就比mid小，就要更改l。

## 坑点

不开double见祖宗

精度问题，只要差小于1e-4就默认为0

## 完整代码区

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	double n, m, k;
	cin >> n >> m >> q;
	double l = 0, r = 500; // 它利率应该不比5大？没有这么黑
	double mid;
	while (r - l > 1e-4) {
		mid = (l + r) / 2;
		double ans = m;
		for (int i = 0; i < k; i++) ans *= (1 + mid / 100) - m;
		if (ans > 1e-4) r = mid;
		else l = mid;
	}
	cout << fixed << setprecision(1) << l << endl;
    // 保留小数点后一位
	return 0;	
 } 

```


---

## 作者：Megumi_Cold (赞：11)

我的写法可能有些奇怪,我不是去枚举数而是直接枚举百分数

所以最后输出的时候直接输出就好了

P.S. 这种写法等于0时也要直接输出0.0,否则会输出-0.0


```cpp
#include<iostream>
using namespace std;
double a,b,c,l,r;
int main()
{
    scanf("%lf%lf%lf",&a,&b,&c);
    l=0;
    r=1000;
    while(l<r)
    {
        double e,f,mid;
        mid=(l+r)/2;
        e=mid/100+1;
        f=0;
        for(int i=0;i<c;i++)
        {
            f+=b/e;
            e=e*(mid/100+1);
        }
        if(f>a)
        l=mid+0.00001;
        else
        r=mid-0.00001;
    }
    if(l<=0)
    printf("0.0");
    else
    printf("%.1lf",r);
}
```
/\*
1000 100 12

\*/

---

## 作者：y_p_kongbai12138 (赞：4)

关于Pascal满分代码我写在下面了，二分答案。因为是利滚利的缘故，不能直接套用公式，可解：


  

```cpp
var m,y,mouth,jg,i,minn:longint;
    s:string;
    min,ans:real;
function js(mid:longint):real;  
var mid1,n:real;  
    i:longint;  
begin  
    n:=m;  
    mid1:=mid/10000;  
    for i:=1 to mouth do
    n:=n*(1+mid1)-y;  
    exit(n);  
end;  
function ef(l,r:longint):longint;  
var mid:longint;
    zhi:real;  
begin  
    while l<r do  
    begin  
        mid:=(l+r) div 2;  
        zhi:=js(mid);  
        if (abs(zhi)<min) or (minn=-1) then
        begin  
            min:=abs(zhi);  
            minn:=mid;  
        end;  
        if zhi>0 then r:=mid;  
        if zhi<0 then l:=mid+1;
        if zhi=0 then exit(mid);
    end;
    exit(l);
end;
begin
    minn:=-1;
    read(m,y,mouth);  
    jg:=ef(0,trunc((y/m)*10000));
    ans:=jg/100;  
    writeln(ans:0:1);
end.
```

---

## 作者：火柴神 (赞：4)

水题，用二分查找，注意范围，有点的利率超过100%







```cpp
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
const double eps = 1e-8;
double a;
double b;
long c;
long getint(){
    long rs=0;char tmp;bool sgn=1;
    do tmp = getchar();
    while (!isdigit(tmp)&&tmp-'-');
    if (tmp=='-'){sgn=0;tmp=getchar();}
    do rs=(rs<<3)+(rs<<1)+tmp-'0';
    while (isdigit(tmp=getchar()));
    return sgn?rs:-rs;
}
double work(double m){
    double tmp = a;
    for (long i=1;i<c+1;i++){
        tmp = tmp*(1+m)-b;
    }
    return tmp;
}
int main(){
    a = getint();
    b = getint();
    c = getint();
    double l = 0;
    double r = 10;
    double m;
    while (l < r + eps){
        m = (l+r)/2.0;
        double re = work(m);
        if (re < 0){
            l = m+eps;
        }
        else{
            r = m-eps;
        }
    }
    if (m*100.0 < 0)
        printf("0.0");
    else
        printf("%.1lf",m*100.0);
    return 0;
}
```

---


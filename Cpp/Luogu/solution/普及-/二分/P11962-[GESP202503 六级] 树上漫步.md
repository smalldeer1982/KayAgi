# [GESP202503 六级] 树上漫步

## 题目描述

小 A 有一棵 $n$ 个结点的树，这些结点依次以 $1,2,\cdots,n$ 标号。

小 A 想在这棵树上漫步。具体来说，小 A 会从树上的某个结点出发，每⼀步可以移动到与当前结点相邻的结点，并且小 A 只会在偶数步（可以是零步）后结束漫步。

现在小 A 想知道，对于树上的每个结点，从这个结点出发开始漫步，经过偶数步能结束漫步的结点有多少个（可以经过重复的节点）。

## 说明/提示

对于 $40\%$ 的测试点，保证 $1\leq n\leq 10^3$。

对于所有测试点，保证 $1\leq n\leq 2\times 10^5$。

## 样例 #1

### 输入

```
3
1 3
2 3```

### 输出

```
2 2 1```

## 样例 #2

### 输入

```
4
1 3
3 2
4 3```

### 输出

```
3 3 1 3```

# 题解

## 作者：lly66666 (赞：20)

非常简单的深搜题。

我们用两个数组：num 和 vis 来分别存储偶数点和奇数点的个数和每个点的奇偶情况，并在深搜的时候统计就行了。

代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int num[1000005], vis[1000005], n, u, v;
vector<int> g[1000005];
void dfs(int x, int walk) {
    if(walk % 2 == 0) {
        num[2] ++;
        vis[x] = 2;
    }
    else {
        num[1] ++;
        vis[x] = 1;
    }
    for(int i = 0; i < g[x].size(); i ++) {
        if(!vis[g[x][i]]) dfs(g[x][i], walk + 1);
    }
}
int main() {
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 0);
    for(int i = 1; i <= n; i ++) {
        cout << num[vis[i]] << ' ';
    }
    return 0;
}
```

完结撒花！

管理员大大大大大大大大大大大大大大求过。

---

## 作者：FJ_EYoungOneC (赞：10)

### 解题思路

原题链接：[P11962  树上漫步](https://www.luogu.com.cn/problem/P11962)。

假设点 $a$ 可以通过偶数步能到达 $b$，那么 $b$ 也一定能够通过偶数步到达 $a$。

那么我们会发现，树中的点一共可以分为两个集合，一个点可以通过偶数步到达集合内的任意点。

以任意点为树根做一次 `dfs`，求出每个点的深度，深度为奇数的点可以通过偶数步到达深度为奇数的任意点，偶数同理。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10, M = 2 * N;

int n;
int h[N], e[M], ne[M], idx;
int depth[N];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int dfs(int u, int fa, int k)
{
	int cnt = k & 1;
	depth[u] = k;
	for (int i = h[u]; ~i; i = ne[i] )
	{
		int j = e[i];
		if (j != fa)
			cnt += dfs(j, u, k + 1);
	}
	return cnt;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n;

	memset(h, -1, sizeof h);

	for (int i = 1; i < n; ++ i )
	{
		int a, b;
		cin >> a >> b;
		add(a, b), add(b, a);
	}

	int odd = dfs(1, -1, 1);
	int even = n - odd;

	for (int i = 1; i <= n; ++ i )
		if (depth[i] & 1)
			cout << odd << ' ';
		else
			cout << even << ' ';
	
	cout << endl;

	return 0;
}
```

---

## 作者：five_rice_water (赞：8)

六级考生前来报到。

这道题有一个非常明显的性质。

对于树上的点，深度为奇数的点互相可以作为终点，深度为偶数的点互相可以作为终点。

证明也很简单：我们假设从深度为偶数的点出发，走一步一定在深度为奇数的点，走两步一定在深度为偶数的点，以此类推，走奇数步一定在深度为奇数的点，走偶数步一定在深度为偶数的点。从深度为奇数的点出发同理，不再赘述。所以可以得到以上性质。

所以就是送分题。

```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n,dep[N],sum[2];
vector<int>e[N];
void dfs(int x,int fa){
	dep[x] = dep[fa]+1;
	sum[dep[x]&1]++;
	for(int i = 0; i<e[x].size(); i++){
		int v = e[x][i];
		if(v==fa) continue;
		dfs(v,x);
	}
}
signed main(){
	cin>>n;
	for(int i = 1; i<n; i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dfs(1,0);
	for(int i = 1; i<=n; i++){
		cout<<sum[dep[i]&1]<<" ";
	}
	return 0;
} 
```

---

## 作者：Francium_ (赞：4)

## 思路
由于我们每个点都深搜遍历一遍是 $O(n^2)$，肯定超时，考虑优化。        
深搜的 $O(n)$ 显然不可优化，我们只能优化枚举每个点的 $O(n)$。首先，如果只跑一遍深搜，正确性在这个问题上：不同的点到达时经过边的奇偶性会不会变？显然不会。由于树上两点间路径唯一，并且反复横跳也不会改变奇偶性，点不同的话，比如 $u$ 到 $v$，我们也可以转化成 $v$ 到 $u$。所以正确性可以保证。     
那么我们将树化为两个集合：从 $1$ 号点开始能经过偶数条边到达的和经过奇数条边到达的。设从 $1$ 号点开始能经过偶数条边到达的有 $x$ 个点，那么从 $1$ 号点开始经过奇数条边到达的自然就是 $n-x$ 个点。        
综上，此解法时间复杂度 $O(n)$，可以通过。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, cnt, vis[200005], bk[200006];//vis:dfs中经过的点，防止反复横跳死循环;  bk：是否能从1号点开始能经过偶数条边到达; cnt:从1号点开始能经过偶数条边到达的点的个数
vector<int>g[200005];//图

void dfs(int u, int step) {
	if (vis[u])
		return ;
	if (step % 2 == 0)//可以从1号点开始能经过偶数条边到达
		bk[u] = 1, cnt++;
	vis[u] = 1;
	for (int i = 0; i < g[u].size(); i++)
		dfs(g[u][i], step + 1);
}

int main() {
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v), g[v].push_back(u);
	}
	dfs(1, 0);//1遍dfs即可
	for (int i = 1; i <= n; i++)
		cout << (bk[i] ? cnt : n - cnt) << " ";
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/209856789)

---

## 作者：Na1L0n9 (赞：4)

# Solution
## 思路
由于边是无向边，所以如果节点 $a$ 能经过偶数步走到节点 $b$，那么节点 $b$ 一定也能经过偶数步走到节点 $a$。因此，如果一个点的答案为 $k$，那么这个点能经过偶数步走到的节点答案也是 $k$，我们可以用一个 $ans$ 数组来存储答案，具体实现见代码。
## Code

```cpp
#include <bits/stdc++.h>
#define Write ios::sync_with_stdio(0);
#define by cin.tie(0);
#define AquaDaMean1e cout.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 2e5 + 10;
const int MOD = 998244353;
vector <int> G[N * 2];
int n, cnt, ans[N];
bool vis[N];
void dfs(int u, int dep) {
	if (dep % 2 == 0) { // 如果步数是偶数，答案加一 
		ans[u] = -1; // 把ans数组标成-1，说明这个点可以从初始点经过偶数步抵达 
		cnt++;
	}
	for (int i = 0; i < G[u].size(); i++) {
		int v = G[u][i];
		if (!vis[v]) {
			vis[v] = true;
			dfs(v, dep + 1);
		}
	} // 正常的dfs 
}
int main() {
	Write by AquaDaMean1e
	cin >> n;
	for (int i = 1, u, v; i < n; i++) {
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u); // 建双向边 
	}
	for (int i = 1; i <= n; i++) {
		if (ans[i]) { // 如果之前已经找到过了答案，直接输出 
			cout << ans[i] << " ";
			continue;
		}
		cnt = 0; // 记得清零 
		for (int j = 1; j <= n; j++) {
			vis[j] = false;
		}
		vis[i] = true; // 初始化vis数组 
		dfs(i, 0); // dfs
		for (int j = 1; j <= n; j++) {
			if (ans[j] == -1) { // 如果ans数组被标记为了-1，说明这个点可以从i经过偶数步到达，修改ans数组 
				ans[j] = cnt;
			}
		}
		cout << cnt << " "; // 输出答案 
	}
	return 0;
}
```

---

## 作者：Lcm_simida (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P11962)

重中之重：这是一个树

首先，可以得出性质：对于两点而言，它们之间所有路径长度的奇偶性是不变的，原因就是因为这是一棵树，不理解的可以去了解树的性质。

因此我们只要找到任意两点间的一条路径即可。我们设 $dis[x]$ 表示 $1$ 到 $x$ 的距离，则任意两点都有一种路径是先到 $1$ 节点，再去另一节点的，路径长度就是两个节点到节点 $1$ 的距离之和。

因此，对于节点 $i$ 而言。若 $dis[i]$ 为奇数，则答案就是所有到 $1$ 节点距离为奇数的节点总数。若 $dis[i]$ 为偶数，则答案就是所有到 $1$ 节点距离为偶数的节点总数。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dis[200005],cnt_0=0,cnt_1=0;
vector<int> a[200005];
void dfs(int x,int fa){
	if(dis[x]%2==0) cnt_1++;
	else cnt_0++;
	for(int i=0;i<a[x].size();i++){
		if(a[x][i]==fa) continue;
		dis[a[x][i]]=dis[x]+1;dfs(a[x][i],x);
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
	cin>>n;for(int i=1,j,k;i<n;i++){cin>>j>>k;a[j].push_back(k),a[k].push_back(j);}
	dfs(1,0);for(int i=1;i<=n;i++) cout<<(dis[i]%2==0?cnt_1:cnt_0)<<" ";
	return 0;
}

```

---

## 作者：sybs1145 (赞：2)

# [P11962 树上漫步](https://www.luogu.com.cn/problem/P11962) 题解

## 思路

#### 部分分

首先考虑暴力，我们可以对每个点进行 dfs 并且进行统计，最后输出，时间复杂度 $O(n^2)$。

#### 正解

不难发现，从任意结点出发，走偶数步，只能到达深度与出发点深度的差为偶数的结点。

换句话说，出发点与最终到达的结点的深度积偶性一定相同。

综上，我们可以先以任何一个结点出发，进行一次 dfs，求出每个结点的深度，并将深度为奇数的结点数量用 $cnt1$ 来保存，将深度为偶数的结点用 $cnt2$ 来保存，并将每个结点深度的奇偶性用数组来保存。

最终每个点的答案就是深度与其积偶性相同的结点数量。

人话：不是 $cnt1$ 就是 $cnt2$。

时间复杂度 $O(n)$。

### Tips

- 注意题目要求，可以经过重复的结点，所以在统计数量时不需要去重。

## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 5;
int n, cnt1, cnt2;
bool odd[N]; //用odd数组记录每个结点深度的奇偶性
vector<int> e[N];
void dfs(int now, int fa, int dep)
{
    if (dep % 2)
    {
        cnt1++;
        odd[now] = 1;
    }
    else
        cnt2++;
    for (int i = 0; i < e[now].size(); i++)
    {
        int y = e[now][i];
        if (y == fa)
            continue;
        dfs(y, now, dep + 1);
    }
    return;
}
int main()
{
    ios::sync_with_stdio(0);
    cin >> n;
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs(1, 0, 1);
    for (int i = 1; i <= n; i++)
    {
        if (odd[i])
            cout << cnt1 << " ";
        else
            cout << cnt2 << " ";
    }
    return 0;
}
```

---

## 作者：xu_zhihao (赞：1)

### 题目思路

- 这道题其实就是暴力枚举。每次枚举一个还没有被标记的点，对其 DFS 一遍，在 DFS 时标记偶数步时到的点，并用队列记录其结点位置，将计数器加一。

- DFS 后，枚举队列，将枚举到的每一个位置的漫步的结点数量记为计数器个，枚举结束后将计数器归零。每次 DFS 被标记的数约为枚举数量的 $\frac{1}{2}$，所以最后访问结点的总次数是 $O(n)$ 的。即复杂度为 $O(n)$。

### AC 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>e[200010];
int f[200010];
int cnt[200010];
int ans=0;
queue<int>q;
void dfs(int id,int fa,int k){
	if(k==0){
		f[id]=1;
		q.push(id);
		ans++;
    }
	if(e[id].empty()){
		return;
	}
	int l=e[id].size();
	for(int i=0;i<l;i++){
		if(fa==e[id][i]){
			continue;
		}
		dfs(e[id][i],id,(k+1)%2);
	}
	return;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		if(f[i]){
			continue;
		}
		dfs(i,-1,0);
		while(!q.empty()){
			int ID=q.front();q.pop();
			cnt[ID]=ans;
		}
		ans=0;
	}
	for(int i=1;i<=n;i++){
		cout<<cnt[i]<<" ";
	}
	return 0;
}
```

---

## 作者：kukuchiu (赞：1)

# [题目传输门](https://www.luogu.com.cn/problem/P11962)

# 解题思路

千万不要想得太复杂！其实我们可以通过模拟样例发现，对于结点 $i$，答案只有两种：第一种是 $deep[i]$ 为奇数，一种是 $deep[i]$ 为偶数。这里的 $deep$ 指的是结点 $i$ 在这颗二叉树上的深度（根节点的深度为 $1$），所以我们需要先构造一棵树，只要在构造的过程中求出这两种答案，这题就可以轻松解决了。

# AC code


```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 2e5 + 10;

bool flag[N];

long long s1, s2;

int d[N], deep[N], n;

vector<int> edge[N];

void dfs(int u)
{
	if (deep[u] % 2 == 1)
	{
		s1++;
	}
	else
	{
		s2++;
	}
	for (auto v : edge[u])
	{
		if (!flag[v])
		{
			flag[v] = true;
			deep[v] = deep[u] + 1;
			dfs(v);
		}
	}
}

int main()
{
	scanf("%d", &n);
	for (int i = 1, u, v; i < n; i++)
	{
		scanf("%d%d", &u, &v);
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	flag[1] = 1;
	deep[1] = 1;
	dfs(1);
	for (int i = 1; i <= n; i++)
	{
		if (deep[i] % 2 == 1)
		{
			printf("%lld ", s1);
		}
		else
		{
			printf("%lld ", s2);
		}
	}
	return 0;
}
```

---

## 作者：HuangBarry (赞：1)

## 分析：
若从点 $A$ 出发，能在点 $B$ 停止漫步，那么从点 $B$ 出发，也肯定可以在点 $A$ 停止，所以任意有这种关系的两个点的答案相等。

## 代码实现：
记录下过程中所有到达步数为偶数步的点，整棵树都遍历完后，把结果的点都附上出发点记录的答案，后面需要输出从此点出发的答案时，直接输出即可。

考场上能过。

代码如下：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define stl_priority_queue std::priority_queue
#define pbds_priority_queue __gnu_pbds::priority_queue
#define vec vector
#define to_string std::to_string
#define push emplace
#define push_back emplace_back
#define st first
#define nd second
#define endl '\n'
#define Endl cout<<endl
#define orz cout<<"HuangBarry AK IOI !!!"<<endl
#define Made return
#define by 0
#define Barry +0
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;
using ll=long long;
using ull=unsigned long long;
using ld=long double;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vvi=vector<vi>;
using vl=vector<ll>;
using vvl=vector<vl>;
using vpii=vector<pii>;
using vvpii=vector<vpii>;
using vpll=vector<pll>;
using vvpll=vector<vpll>;
const string Yes="Yes",No="No",yes="yes",no="no",YES="YES",NO="NO";
int n;
vi ans;//记录答案
vvi g;//树
vec<set<int>>v;//记录路径
bitset<(int)2e5+25>bs;//打标记
void f(int st,int now,int sum=1){
    for(int x:g[now])
        if(!bs[x]){
            bs[x]=1;
            if(sum%2==0){//只能在偶数步停
                v[st].insert(x);
                v[x].insert(st);
                ans[st]++;
            }
            f(st,x,sum+1);
        }
    return;
}
int main(){
    //Freopen("filename");
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    g=vvi(n+1);
    ans=vi(n+1,-1);
    v=vec<set<int>>(n+1);
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        if(ans[i]==-1){
            bs=bitset<(int)2e5+25>();
            bs[i]=1;
            ans[i]=1;
            f(i,i);
            for(int x:v[i])
                ans[x]=ans[i];
            cout<<ans[i]<<" ";
        }else
            cout<<ans[i]<<" ";
    }
    Made by Barry;
}
```

---

## 作者：天使宝贝 (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P11962)
### 题目大意
给定一棵树，对于每个节点，你要求出该节点走偶数步最多能走到多少个节点。

### 思路&分析
首先可以先考虑一条链的情况，我们可以把整条链按每个节点分层，不难发现，处在偶数层的节点走偶数步永远只能走到处于偶数层的节点，走不到奇数层的节点，奇数层的节点同理。

将链的情况带入树中，首先将树按照深度分层，我们可以观察到，所处偶数层的节点走偶数步能走到的节点都是处于偶数层的，且就是处在偶数层的节点总数，奇数层的也同理。于是我们可以对整棵树进行一次 dfs，分别算出奇数层节点和偶数层节点的总数，在进行 dfs 的同时，我们记录节点 $i$ 所处的深度，在最后输出答案时，只需要判断节点 $i$ 所处奇数层还是偶数层即可。

### CODE
```cpp
#include <bits/stdc++.h>
#define ll long long
#define il inline
#define endl '\n'
#define IOS ios::sync_with_stdio(false), cin.tie(0)
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define dep(i, a, b) for (int i = (a); i >= (b); i--)
#define psbk push_back
#define ppbk pop_back
using namespace std;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<vii> viii;
constexpr int MAXN = 2e5 + 5;
int n, tmp1 = 1, tmp2 = 1;
vi Tree[MAXN];
map<int, int> mp;
il void dfs(int u, int fa, int dep) {
    mp[u] = dep;
    if (dep % 2 == 1) tmp2 += Tree[u].size() - 1;
    if (dep % 2 == 0) tmp1 += Tree[u].size() - 1;
    for (auto v : Tree[u]) {
        if (v != fa) dfs(v, u, dep + 1);
    }
}
int main() {
    IOS;
    cin >> n;
    rep(i, 1, n - 1) {
        int u, v;
        cin >> u >> v;
        Tree[u].psbk(v);
        Tree[v].psbk(u);
    }
    dfs(1, 0, 1);
    rep(i, 1, n) {
        if (mp[i] % 2 == 1) cout << tmp1 << " ";
        else cout << tmp2 << " ";
    }
    return 0;
}
```

---

## 作者：lizeyuhello (赞：1)

赛时 $10$ 分钟过了，又闲着没事在考场上用草稿纸写了篇题解。

# 题解
由题意可得，从结点 $x$ 出发到达结点 $y$ 的步数与从结点 $y$ 出发到达结点 $x$ 的步数奇偶性相同。

从结点 $1$ 开始遍历整张图，记录所有到达所用步数为偶数的结点的数量 $ans_1$ 和所有到达所用步数为奇数的结点的数量 $ans_2$。

当到达结点 $i$ 所用步数为偶数时，从结点 $i$ 出发开始漫步能结束漫步的结点数量为 $ans_1$，反之能结束漫步的结点数量为 $ans_2$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, ans, bns;
vector<int> g[200005];
bool vis[200005], d[200005]; //d 为结点 1 走到结点所用步数的奇偶性

void dfs(int u, bool s) //s 为步数的奇偶性
{
	vis[u] = 1, d[u] = s;
	ans += s, bns += s ^ 1;
	for (auto v : g[u])
		if (!vis[v])
			dfs(v, s ^ 1);
 } 

int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; ++i)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		g[u].push_back(v);
		g[v].push_back(u); //建图
	}
	dfs(1, 0);
	for (int i = 1; i <= n; ++i)
		printf("%d ", d[i] ? ans : bns);
	return 0;
}

```

---

## 作者：litangzheng (赞：1)

### 前言：  
我没有参加 GESP ，但我觉得我参加~~编程题应该满分~~。  

### 思路：  
先看题目，我们要求走偶数次能到达的节点（包括自己），这让我们一下子想到了二分图。  
二分图就是把所有点分成两个集，使集内没有点相连。这样的话，对于一个点，它走偶数次能到达的点的个数就是它属于的那个点集内的点的个数。  
刚刚好，一棵树一定能构成一张二分图。我们再使用染色法给整个图染色即可。  

### 代码：  


```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,col[N],sum[3],cnt=1,head[N];
struct Edge{
	int to,nxt;
}edge[N*2];
void addedge(int u,int v){
	edge[cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt++;
}
bool dfs(int x,int c){
	if(col[x]){
		if(col[x]==c) return 1;
		else return 0;
	}
	col[x]=c;
	sum[c]++;
	for(int i=head[x];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!dfs(to,3-c)) return 0;//3-c很巧妙，刚好把1变为2，把2变为1。
	}
	return 1;
}
int main(){
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		addedge(u,v);addedge(v,u);
	}
	dfs(1,1);
	for(int i=1;i<=n;i++){
		cout<<sum[col[i]]<<" ";
	}
}
```

---

## 作者：_Lazy_whr_ (赞：1)

直接暴力即可。

对任意一个节点做 DFS，求出深度。接下来模拟整个过程找规律，容易发现其实如果两个点的深度奇偶性相同，那么他们必定可以互相到达。也就是说每一个点能到达的点的数量就是与其深度的奇偶性相同的点的个数。这样就很清晰了。

# AC Code
```cpp
#include <bits/stdc++.h>

#define int long long

#define x0 x00
#define x1 x10
#define x2 x20
#define y0 y00
#define y1 y10
#define y2 y20

#define endl '\n'
#define Debug(x) cout << #x << " = " << x << "  ";
#define Endl cout << '\n'
#define Flush cout.flush()

#define F first
#define S second
#define Push emplace_back
#define Pop pop_back

#define Ls (p << 1)
#define Rs (p << 1 | 1)
#define Lowbit(x) ((x) & (-x))

#define YES cout << "YES" << endl
#define Yes cout << "Yes" << endl
#define yes cout << "yes" << endl
#define NO cout << "NO" << endl
#define No cout << "No" << endl
#define no cout << "no" << endl

#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))
#define abs(a) ((a) > 0 ? (a) : ((a) * -1))

using namespace std;

namespace Whr {
	constexpr int INF = (1LL << 60);
	constexpr int DIR[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
	constexpr double EPS = 1E-15;
	const double PI = acos(-1);
	constexpr int BASE = 1919810 - 114514, HMOD = 1E15 + 37;
	constexpr int N = 1E6 + 10;
	constexpr int M = 25;
	constexpr int MOD = 1E9 + 7;
	
	namespace FastIO {
		int read () {
			int x = 0, f = 1;
			char ch;
			for (ch = getchar(); not isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
			for (x = 0; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
			return x * f;
		}
		
		void read (string &s) {
			char ch = getchar();
			s.clear();
			while (ch == ' ' or ch == '\n' or ch == '\0') ch = getchar();
			while (ch != ' ' and ch != '\n' and ch != '\0') s += ch, ch = getchar();
		}
		
		void read (char &ch) {
			ch = getchar();
			while (ch == ' ' or ch == '\n') ch = getchar();
		}
		
		template <typename T> void read (T &x) { x = read(); }
		
		template <typename T, typename ...Args> void read (T &x, Args &...x_) { read(x); read(x_...); }
		
		void read_line (string &s) {
			char ch = getchar();
			s.clear();
			while (ch == '\n' or ch == '\0') ch = getchar();
			while (ch != '\n' and ch != '\0') s += ch, ch = getchar();
		}
	}
	
	namespace Function {
		void Add (int &x, int y, int MOD) { x = (x + y) % MOD; }
		void Sub (int &x, int y, int MOD) { x = ((x - y) % MOD + MOD) % MOD; }
		void Mul (int &x, int y, int MOD) { x = (x * y) % MOD; }

		void Remax (int &x, int y) { x = max(x, y); }
		void Remin (int &x, int y) { x = min(x, y); }
		
		int Pow (int a, int b, int p) {
			int ret = 1;
			while (b) {
				if (b & 1) ret = ((1LL * a % p) * ret) % p;
				a = ((1LL * a % p) * a) % p; b >>= 1;
			} return ret;
		}
		
		int Hash (string s) {
			int ret = 0, now = 1;
			int n = s.size();
			for (int i = 0; i < n; i++) ret = (ret + ((s[i] - '0') * now) % HMOD) % HMOD, now = (now * BASE) % HMOD;
			return ret;
		}
		
		bool Prime (int x) {
			if (x < 2) return false;
			for (int i = 2; i * i <= x; i++) if (x % i == 0) return false;
			return true;
		}
		
		int Get_C (int a, int b, int p) {
			if (b > a) return 0;
			int ret = 1;
			for (int i = 1, j = a; i <= b; i++, j--) ret = ret * j % p, ret = ret * Pow(i, p - 2, p) % p;
			return ret;
		}
		
		int Comb (int a, int b, int p) {
			if (a < p and b < p) return Get_C(a, b, p);
			else return Get_C(a % p, b % p, p) * Comb(a / p, b / p, p) % p;
		}
		
		string Bin (int x) {
			if (x == 0) return "0";
			string ret;
			while (x > 0) ret += (x & 1) + '0', x >>= 1;
			reverse(ret.begin(), ret.end());
			return ret;
		}
	}
	
	namespace Data_Structure {
		class Segment_Tree {
			struct Segment {
				int l, r;
				int val, tag;
			};
			
		private :
			Segment e[N << 2];
			int n, *a;
			
			void Push_up (int p) { e[p].val = e[Ls].val + e[Rs].val; }
			
			void Make_tag (int p, int x) {
				e[p].val += (e[p].r - e[p].l + 1) * x;
				e[p].tag += x;
			}
			
			void Push_down (int p) {
				Make_tag(Ls, e[p].tag); Make_tag(Rs, e[p].tag);
				e[p].tag = 0;
			}
			
		public:
			void Init(int n_, int *a_) {
				n = n, a = a_;
				for (int i = 1; i <= (n << 2); i++) e[i].l = e[i].r = e[i].val = e[i].tag = 0;
			}
			
			void Build_tree (int p, int l, int r) {
				e[p].l = l, e[p].r = r;
				if (l == r) return e[p].val = a[l], void();
				
				int mid = (l + r) >> 1;
				Build_tree(Ls, l, mid); Build_tree(Rs, mid + 1, r);
				Push_up(p);
			}
			
			void Modify (int p, int L, int R, int x) {
				if (L <= e[p].l and e[p].r <= R) return Make_tag(p, x), void();
				
				Push_down(p);
				int mid = (e[p].l + e[p].r) >> 1;
				if (L <= mid) Modify(Ls, L, R, x);
				if (mid < R) Modify(Rs, L, R, x);
				Push_up(p);
			}
			
			int Ask (int p, int L, int R) {
				if (L <= e[p].l and e[p].r <= R) return e[p].val;
				
				Push_down(p);
				int mid = (e[p].l + e[p].r) >> 1, ret = 0;
				if (L <= mid) ret += Ask(Ls, L, R);
				if (mid < R) ret += Ask(Rs, L, R);
				return ret;
			}
		};
		
		class Tree_array {
		private :
			int sum[N << 2];
			int n, *a;
			
		public:
			void Init (int n_, int *a_) {
				n = n_, a = a_;
				for (int i = 1; i <= (n << 2); i++) sum[i] = 0;
			}
			
			void Modify (int n, int x, int k) {
				for (int i = x; i <= n; i += Lowbit(i)) sum[i] += k;
			}
			
			int Ask (int x) {
				int ret = 0;
				for (int i = x; i >= 1; i -= Lowbit(i)) ret += sum[i];
				return ret;
			}
		};

		class ST_table {
		private :
			int n, *a;
			int Log[N];
		
		public :
			int dp[N][25][2];

			void Init (int n_, int *a_) {
				n = n_, a = a_;
				Log[0] = -1;
				for (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1, dp[i][0][0] = dp[i][0][1] = a[i];

				for (int j = 1; j <= 20; j++) for (int i = 1; i + (1 << (j - 1)) <= n; i++)
					dp[i][j][0] = min(dp[i][j - 1][0], dp[i + (1 << (j - 1))][j - 1][0]),
					dp[i][j][1] = max(dp[i][j - 1][1], dp[i + (1 << (j - 1))][j - 1][1]);
			}

			int Ask_min (int l, int r) {
				int k = Log[r - l + 1];
				return min(dp[l][k][0], dp[r - (1 << k) + 1][k][0]);
			}

			int Ask_max (int l, int r) {
				int k = Log[r - l + 1];
				return max(dp[l][k][1], dp[r - (1 << k) + 1][k][1]);
			}
		};
		
		template <typename T> class Stack {
		public:
			T data[N];
			int top = 0;

			void Push (T x) { if (top < N - 10) data[++top] = x; }

			void Pop() { if (top > 0) top--; }

			T Top() { return data[top]; }

			bool Empty() { return top > 0; }

			int Size() { return top; }
		};

		template <typename T> class Queue {
		public:
			T	data[N];
			int head = 1, tail = 1;

			void Push (T x) { if (tail < N - 10) data[tail++] = x; }

			void Pop() { if (head < tail) head++; }

			T Front() { return data[head]; }

			bool Empty() { return head == tail; }

			int Size() { return tail - head; }
		};

	}
	
	namespace Graphs {
		struct Edge {
			int u, w;
			
			bool operator < (const Edge &cmp) const { return w > cmp.w; }
		};
		class Graph {
		public :
			int n;
			vector <pair <int, int> > e[N];
			int dis[N], vis[N];
			
			void Init (int n_) {
				n = n_;
				for (int i = 1; i <= n; i++) e[i].clear();
			}
			
			void Add_edge (int u, int v, int w) { e[u].Push(make_pair(v, w)); }
			
			void Dijkstra (int s) {
				priority_queue <Edge> Q; Q.push(Edge {s, 0});
				for (int i = 1; i <= n; i++) dis[i] = INF, vis[i] = 0;
				dis[s] = 0, vis[s] = 1;
				while (!Q.empty()) {
					Edge f = Q.top(); Q.pop();
					if (f.w > dis[f.u]) continue;
					for (auto i : e[f.u]) {
						int v = i.first;
						if (dis[f.u] + i.second < dis[v]) { dis[v] = dis[f.u] + i.second; Q.push(Edge {v, dis[v]}); }
					}
				}
			}


		};

		class Tree {
		public :
			vector <pair <int, int> > e[N];
			int n;
			int dep[N], sz[N], dp[N][25];

			void Init (int n_) {
				n = n_;
				for (int i = 1; i <= n; i++) e[i].clear();
			}

			void Add_edge (int u, int v, int w) { e[u].Push(make_pair(v, w)); }

			void Pre_DFS (int u, int fa) {
				dep[u] = dep[fa] + 1, sz[u] = 1, dp[u][0] = fa;
				for (auto [v, w] : e[u]) if (v != fa) Pre_DFS(v, u), sz[u] += sz[v];
			}

			void Pre_work (int rt) {
				Pre_DFS(rt, 0);
				for (int j = 1; j <= 20; j++) for (int i = 1; i <= n; i++) dp[i][j] = dp[dp[i][j - 1]][j - 1];
			}

			int LCA (int u, int v) {
				if (dep[u] < dep[v]) swap(u, v);

				for (int i = 0; i < 20; i++) if ((dep[u] - dep[v]) & (1 << i)) u = dp[u][i];

				if (u == v) return u;
				
				for (int i = 20; i >= 0; i--) if (dp[u][i] != dp[v][i]) u = dp[u][i], v = dp[v][i];
				return dp[u][0];
			}
		};
	}
	
	using namespace FastIO;
	using namespace Function;
	using namespace Graphs;
	using namespace Data_Structure;
}

using namespace Whr;

int n;
Tree g;

void Solve() {
	read(n), g.Init(n);
	for (int i = 1; i < n; i++) {
		int u = read(), v = read(), w = 1;
		g.Add_edge(u, v, w), g.Add_edge(v, u, w);
	}

	g.Pre_work(1);
	int _1 = 0, _2 = 0;
	for (int i = 1; i <= n; i++) {
		if (g.dep[i] % 2 == 0) _1++;
		else _2++;
	}

	for (int i = 1; i <= n; i++) cout << (g.dep[i] % 2 == 0 ? _1 : _2) << " "; Endl;
}

main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	
#ifdef LOCAL
	freopen("Input.in", "r", stdin);
	freopen("Output.out", "w", stdout);
#endif

	int Test_case = 1;
	// read(Test_case);
	double Start = clock();
	int Now_case = 1;
	while (Test_case--) {
#ifndef ONLINE_JUDGE
		if (Now_case != 1) cout << endl;
		cout << "Test case #" << Now_case++ << " :" << endl;
#endif
		Solve();
	}
	
#ifndef ONLINE_JUDGE
	cout << "Total time used : " << clock() - Start << " ms." << endl;
#endif
	
	return 0;
}

```

---

## 作者：__qkj__ (赞：0)

## 解题思路
因为这是个树，所以只需要遍历一遍这个树就行了。

先随便找一个点，标记为 $0$，再从这个点延伸出去，每延伸一个就标记成与它相反的数。这样就可以判断是不是偶数次了。

然后，累加被标记成 $1$ 的点的个数 $s$。输出时，如果这个点的标记为 $1$，则说明与其它标记成 $1$ 的点相差偶数个，输出 $s$ 即可。相反，如果这个点的标记为 $0$，则输出 $n-s$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>a[200010];
bool f[200010];
int s=0;
void dfs(int t,int fa)
{
	for(int i=0;i<a[t].size();i++)
		if(a[t][i]!=fa)
		{
			f[a[t][i]]=!f[t];
			if(f[a[t][i]])s++;
			dfs(a[t][i],t);
		}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		a[u].push_back(v);
		a[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
		if(f[i])cout<<s<<' ';
		else cout<<n-s<<' ';
	return 0;
}
```

---

## 作者：tttyyygdgz (赞：0)

>[题目传送门](https://www.luogu.com.cn/problem/P11962)
>
>[可能更好的环境](https://www.luogu.com.cn/article/g6tpkvy2)

# 1.题目大意

对于每个节点，输出和这个节点之间的距离（路径上的节点数）为偶数的节点数量

# 2.分析

我们将树上的每个节点像棋盘一样黑白相间的染色染色，像这样：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zc2vx2ys.png)  
不难发现，在树上走一步会变换颜色，走两步颜色不变。

同理，走奇数步会变换颜色，走偶数步颜色不变。

也就是说，小 A **只会漫步到同色节点**。

## 总结

- 计黑色节点有 $cnt _{black}$ 个，白色节点有 $cnt _{white}$ 个。
- 如果节点 $i$ 为黑色则能漫步到 $cnt _{black}$ 个节点
- 如果节点 $i$ 为白色则能漫步到 $cnt _{white}$ 个节点

需要注意的是，染色从哪个节点开始染都**无所谓**。

# 3.参考程序
程序为赛时程序，`/*...*/`注释为后来所加。  
**不要抄题解！**
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
typedef long long ll;
using namespace std;
const int N=2000000+10;
struct EDGENODE{
	int to;
	int nxt;
}edge[N];
int head[N],cnt;
void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
	
	edge[++cnt].to=u;
	edge[cnt].nxt=head[v];
	head[v]=cnt;
	return;
}
/*为方便调试，比赛时6-20行是被压行的*/
int col[N],sum_col[2];//0:黑, 1:白 
int n;
void dfs(int x,int fa){
	col[x]=!col[fa];
	sum_col[col[x]]++;
	for(int i=head[x];i;i=edge[i].nxt){
		if(edge[i].to!=fa){
			dfs(edge[i].to,x);
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n-1;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)cout<<sum_col[col[i]]<<" ";
	return 0;
}
```
## 复杂度分析
由于每个节点只会被访问一次，所以复杂度为 $O(n)$。
>### 为什么每个节点只会被访问一次？
>
>因为在访问的时候，通向非子树的路径**一定**会经过父节点，所以会被 dfs 函数中的`if(edge[i].to!=fa)`语句**阻塞**，只能访问子树，所以每个节点只会被访问一次。

---

祝君好运！

---


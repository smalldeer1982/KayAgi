# 小车问题

## 题目描述

甲、乙两人同时从 A 地出发要尽快同时赶到 B 地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq s, a, b \leq 10^9$。

## 样例 #1

### 输入

```
120 5 25
```

### 输出

```
9.600000
```

# 题解

## 作者：kkksc03 (赞：339)

首先车带一个人行驶x段距离

然后丢下 折回找另外一个人 半路碰上 带回终点

刚好与第一人共到 根据这个策略 列出公式

(s-x)/a=2\*(2\*x/(a+b)-x/b)+(s-x)/b

化简最后得x=(b+a)\*s/(b+3a)

最后时间即 x/b+(s-x)/a

标程不给了


---

## 作者：____233____ (赞：154)

**~~你们太过分了，这么好的一道二分题，都用数学解QWQ~~**

发表一种**二分**的解法。

首先，每个人都要做一次车，而且两个人要同时到达，这样才能使总时间最短。

那么，我们设起点为A，终点为B，小车先带甲开到C点后甲下车走到B点，同时小车掉头与已经走到D点的乙相向而行，相遇于点E，最后小车带乙向B开去，和甲同时到达。~~（绕口令啊）~~

现在设$AC=S$

则：

车从A到C的时间$T_{A\rightarrow C}=\frac{S}{V_{car}}$

车与乙汇合所用时间$T_{B,D\rightarrow E}=\frac{S-T_{A\rightarrow C}×V_{man}}{V_{car}+V_{man}}$

甲所用时间$T_{1}=T_{A\rightarrow C}+(S_{AB}-S)/V_{man}$

乙所用时间$T_{2}=T_{A\rightarrow C}+T_{B,D\rightarrow E}+[S_{AB}-(T_{A\rightarrow C}+T_{B,D\rightarrow C})×V_{man}]/V_{car}$

~~丧心病狂~~

最后，终于可以偷税地二分C点的位置了。。。~~（一把辛酸泪，LaTeX太可怕了）~~

先把点C确认为AB的中点，然后计算此时的$T_{1}$与$T_{2}$

若$T_{1}>T_{2}$,把A点更新为C点；反之，把B点更新为C点，最后再取AB中点。。。

直到$|T_{1}-T_{2}|$小于某一误差值（我设为1e-8），输出$T_{1}$

```
#include<cstdio>
#include<cmath>
int main()
{
	double s,s1,s2,v1,v2,t1,t2,p;
	double a,b;
	scanf("%lf%lf%lf",&s,&v1,&v2);
	s1=0;
	s2=s;
	do
	{
		p=(s1+s2)/2.0;
		a=p/v2;
		b=(p-a*v1)/(v1+v2);
		t1=a+(s-p)/v1;
		t2=a+b+(s-(a+b)*v1)/v2;
		if(t1<t2)
		  s2=p;
		else
		  s1=p;
	}
	while(fabs(t1-t2)>1e-8);
	printf("%.6lf",t1);
	return 0;
}
```

---

## 作者：雪颜 (赞：93)

本蒟蒻表示这是：列方程解应用题

|\_\_x\_\_|\_\_\_\_s-2x\_\_\_\_|\_\_x\_\_|
则x/a=(s-2x+s-x)/b;

解得x=2as/3a+b;

那么时间t=x/a+(s-x)/b;

代码如下

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
using namespace std;
int main(){
    double a,b,s,x;
    cin>>s>>a>>b;
    x=(2*a*s)/(3*a+b);
    printf("%.6lf",x/a+(s-x)/b);
    return 0;
}

```

---

## 作者：kahlua (赞：27)

小学奥数题。不用解方程。


```cpp
|---s1--|--s2--|---s3--|
---------------········            甲
---------------
               |
        --------               车
        |
        ---------------
········---------------        乙
```

显然，要保证甲的步行时间与乙的步行时间相等，所以甲乙的行程是对称的，即$s_1=s_3$。又要保证总时间最短，所以小车应该在半路回头去接乙而不是原地不动等乙来。由此，可绘出上图。


由图可得知，甲步行到终点的时间 和 车回头接乙再带乙到终点的时间 相等。就样例而言，车速是步行速度的$5$倍，故车走的路程是人走的路程的$5$倍，车比人多走了$4$倍。又车与人共同行走了$s_3$的路程，所以车比人多走的是$2*s_2$，是人走的$4$倍，故$s_2=2*s_3$. 故$s_2$是两份，$s_1$与$s_3$都是一份。


而总时间可以直接看车走的路程，是整条路的长度加上折回来又折回去的路程，即$(1+2+1)+2*2=8$份。


全部换成字母的话即为$$s+\frac{s}{\frac{\frac{v2}{v1}-1}{2}+2}*(\frac{v2}{v1}-1)$$


---

## 作者：pyqpyq (赞：16)

[blog](https://www.luogu.org/blog/150384/#)

我觉得我的脑回路特别清奇……
# 题目解析
首先，题目要求两人尽快到达，显然不可能有一个全程走路，一个全程坐车，这里不妨设A开始时坐车，B开始时走路，可以画出下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/v2vkwzmx.png)
时间点①：A、B二人同时从起点出发。

时间段①-②：设用时为$t1$，则A走了$t1 * b$的路程，B走了$t1 * a$的路程。

时间点②：A下车步行，驾驶员**往回**接B。

时间段②-③：设用时为$t2$，则A走了$t2 * a$的路程，B走了$t2 * a$的路程，驾驶员走了$t2 * b$的路程。

时间点③：驾驶员接到了B。

时间段③-④：设用时为$t3$，则A走了$t3 * a$的路程，B走了$t3 * b$的路程。

时间点④：A、B二人**同时**到达终点。

这里A、B二人的总路程已知，而驾驶员往回接B的过程是一个相遇问题。

所以我们可以列出以下方程组：

$\begin{cases}
\ t1 * b+t2 * a+t3 * a=s \\
\ t1 * a+t2 * a+t3 * b=s \\
\ t1 * a+t2 * a+t2 * b=t1*b \\
\end{cases}$

三个方程三个未知数（$t1$、$t2$和$t3$），又保证了a<b，故方程组有唯一解。

接下来就是解方程组了，解出来后$t1+t2+t3$就是答案。

说到解线性方程组，我们会想到**高斯消元**。~~明明是我懒得解含参方程组。~~（有关高斯消元，可转至[日报](https://45475.blog.luogu.org/linear-equation-group)）
# 参考代码
拿着高斯消元板子改的。~~跑得还挺快。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int s1,a1,b1;
double a[11][11],c;
void swa(int i,int j)
{
	double b;
	for(int k=0; k<=3; k++)
	{
		b=a[i][k];
		a[i][k]=a[j][k];
		a[j][k]=b;
	}
};
int main()
{
	scanf("%d%d%d",&s1,&a1,&b1);
	a[0][0]=b1;
	a[0][1]=a1;
	a[0][2]=a1;
	a[0][3]=s1;
	a[1][0]=a1;
	a[1][1]=a1;
	a[1][2]=b1;
	a[1][3]=s1;
	a[2][0]=a1-b1;
	a[2][1]=a1+b1;
	a[2][2]=0;
	a[2][3]=0;
	for(int i=0; i<3; i++)
	{
		for(int j=i+1; j<3; j++)
			if(fabs(a[i][i])<fabs(a[j][i]))
				swa(i,j);
		for(int j=i+1; j<3; j++)
			for(int k=3; k>=i; k--)
				a[j][k]-=a[i][k]*a[j][i]/a[i][i];
	}
	for(int i=2; i>=0; i--)
	{
		for(int j=i+1; j<3; j++)
			a[i][3]-=a[i][j]*a[j][3];
		a[i][3]/=a[i][i];
	}
	printf("%.6f",a[0][3]+a[1][3]+a[2][3]);
}
```


---

## 作者：Celebrate (赞：16)

这一题一眼看过去是一道应用题，先分析一下解法：

车先送甲去B地（乙朝B地走），中途放下甲去，甲自己走

向B地，车返回接乙，接完乙以后开往甲地，最后同时到达。

可以列出方程：
解：设甲需要走x的距离

因为甲走路的时间=乙坐车的时间-车返回接乙的时间

所以

x/a=(s-2x+s-x)/b
x=2as/3a+b
t（时间）=x/a+(s-x)/b

然后按照这个打出代码：

```cpp
#include<cstdio>
using namespace std;
inline void Car() {
	double a,b,s,x;
	scanf("%lf%lf%lf",&s,&a,&b);
	x=(2*a*s)/(3*a+b);
	printf("%.6lf",x/a+(s-x)/b);
}
int main() {
	Car();return 0;
}
```

---

## 作者：chenhaiquan (赞：11)

这不是一道小奥题吗？

画出行程图后，易发现甲路程为（a+b）/2份，乙为a份。每份为f=s/((a+b)/2+a)，即可求出甲路程为(a+b)/2乘f,乙为a乘f，甲时间为（a+b）/2*f/b,乙为f(a乘f/a)
 
于是就有了10行的AC代码啦

```cpp
#include<bits/stdc++.h> 
using namespace std;
double a,b,s,f;
int main()
{
	cin>>s>>a>>b;
	f=s/((b+a)/2+a);
	cout<<fixed<<setprecision(6)<<((b+a)/2*f)/b+f;
	return 0;
}
```

---

## 作者：ljcljc (赞：11)

解：设车带第一个人行x，那么折返与另一人相遇，另一人和车的总距离是2x，总速度是a+b，时间就是2x/(a+b)，


人走的距离就是2ax/(a+b)，应与第一个人被车扔下后走的距离s-x相等




s-x=2ax/a+b

2ax=as+bs-ax-bx

所以(3a+b)x=(a+b)s





```cpp
x=(a+b)s/(3a+b)
#include<iostream>
#include<iomanip>
using namespace std;
double s,a,b,x;
int main()
{
    cin>>s>>a>>b;
      x=(a+b)*s/(3*a+b);
    cout<<std::fixed;
    cout<<setprecision(6)<<x/b+(s-x)/a;
    return 0;
}
```

---

## 作者：caolufan (赞：10)

**画图，模拟过程！**

二话不说，上代码：
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
double s,a,b,t;
int main()
//////主程序//////
{

	cin>>s>>a>>b;
	t=s/(a+b/2+a/2)*(b/2+a/2)/b+s/(a+b/2+a/2);
    //数学思维：车先送人1，返回至人2，送人2至终点
	cout<<fixed<<setprecision(6)<<t<<endl;//四舍五入
	return 0;//结束
}
//////完美//////
```
**祝你AC！！！**

//原谅本蒟蒻第一次发题解,大佬们别见笑~~~

---

## 作者：飞雪连天 (赞：8)

思路：二分答案

首先要找到需要二分的变量：
　　
   
       小车先把甲运到某一个位置C（0<C<s），然后小车返回去找乙，期间甲乙都继续向前走，当小车接到乙后，以b的速度赶往B点。甲全程用的时间为t1，乙为t2。


那么C就是我们需要二分的变量。
因为t1与t2都往相等无限逼近，所以二分的临界条件便是abs（t1-t2）小于某个精度，这里设为0.0000001。

![](https://cdn.luogu.com.cn/upload/pic/48804.png)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
double s,a,b,l,r;
long long read()
{
    long long x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f; 
}
inline double work1(double mid)
{
    double ans=0;
    ans+=mid/b;
    ans+=(s-mid)/a;
    return ans;
}
inline double work2(double mid)
{
    double ans=0;
    ans+=mid/b;
    ans+=(mid-(mid/b)*a)/(a+b);
    ans+=(s-((mid-(mid/b)*a)/(a+b)*a+((mid/b)*a)))/b;
    return ans;
}
inline bool check(double x,double y)
{
    return x>y;
}
int main()
{
    s=read();a=read();b=read();
    l=1;r=s;
    while(l<=r)
    {
        double t1=0,t2=0;
        double mid=(l+r)/2;
        t1=work1(mid);t2=work2(mid);
        if(check(t1,t2)) l=mid;
        else r=mid;
        if(abs(t1-t2)<0.0000001)
        {
            printf("%.6f",t1);
            return 0;
        }
    }
}
```

复杂度：（logn*log1000000）


---

## 作者：FHXZ (赞：6)

证明一下公式，比较麻烦的方法，也许有更简单的方法。。。

首先明确一下最短时间的求法，先将一个人运到一个位置x，再往回运另一个人，同时x位置的那个人向终点走，最后人和车一起走到终点。

证明：

首先看最后一段，人和车一起走到终点，最后的s-x用人的速度所用的时间(s-x)/a应该等于车的时间。

重点在于计算车的时间。

在第一次把人运到x的位置时，没有被运的那个人也在走，走了ax/b的距离，车返回时，我们要求出车和第二个人相遇的地点y，根据时间相等：

y-ax/b=(x-y)/b;可以得到y=2ax/(a+b),这样我们可以求得车返回拉人再返回到x所用时间为2(（2ax/(a+b)-ax/b）/a)化简得：

2(2x/(a+b)-x/b)之后车还要走完s-x的距离所以等式为：

(s-x)/a=2(2x/(a+b)-x/b)+(s-x)/b;

得证。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdlib>
using namespace std;
double s,a,b,x;
int main()
{
    scanf("%lf %lf %lf",&s,&a,&b);
    x=(a+b)*s/(b+3*a);
    printf("%.6f",(x/b+(s-x)/a));
    return 0;
}
```

---

## 作者：Eason6 (赞：3)



------------
祖国的花朵，最蒟的是我。大家好，我就是大蒟蒻。

------------
三国时期明主曹睿曾说：护我蒟蒻，扬我国威！没错，我大蒟蒻又来刷水题了。

------------
硁硁，首先看到这题，恕我吐槽一句：巨佬们为什么要用二分做啊...不是一个小学奥数题吗QAQ（实际上我也不会用二分做），所以，这题本蒟蒻只是套了个公式了，而公式是我们奥数老师叽里呱啦讲了好久讲的，因此我也忘了怎样推导...（原谅我大蒟蒻吧）。好了，话不多说，上代码：
```
#include<bits/stdc++.h>//万能头 
using namespace std;//命名空间 
int main(){//主函数 
	double a,b,s;
	cin>>s>>a>>b;//输入啦 
	double ans;//定义不多说，只是注意用double即可 
	ans=s/((b/a-1)/2+2)*(1+(b/a-1)/2)/b+(s/((b/a-1)/2+2))/a;//公式没啥好说的 
	printf("%.6f",ans);//输出 
	return 0;//结束程序 
} //perfect 
```
PS：如果有大佬知道公式是怎样推导的，请在下方留言或私信QAQ

---

## 作者：LJC00118 (赞：2)

--- 看了楼下的公式我被吓了一跳

--- 怎么我的公式这么奇怪呢

--- 下面是公式

--- 答案=

\frac{s\*(a+b)}{(a+b)\*(a+b)+a\*(b-a)} \* \frac{2\*(a+b)+b-a}{b+a}

--- 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    double s,a,b,ans;
    cin>>s>>a>>b;
    ans=(2*(b+a)+b-a)*(s*(a+b))/(b+a)/((a+b)*(a+b)+a*(b-a));
    printf("%.6lf",ans);
    return 0;
}
```

---

## 作者：蛟川洋 (赞：2)

首先本蒟蒻说说我的算法（莫名的心虚有木有？？？）：

其实这很明显就是一道方程，只要把这个三元一次（二元一次）方程组解了就万事大吉了。

我们先设三个未知数t、t1、t2，分别表示甲同学坐车先行t个单位时间bt个路程单位、甲同学在小车返回与乙同学相遇时走了t1个时间单位at1个路程单位、乙同学坐上小车后甲同学继续走了t2个时间单位at2个路程单位。

通过已知条件，我们不难推出bt+at1+at2=s与at+at1+bt2，这时，就发生了一件神奇的事情：bt-at=bt2-at2！！！那么t=t2的结论轻松到手。那么这道题就转化成了一个简单得不能再简单的解二元一次方程了！！！

好，我们接着看：因为甲同学坐车先行，乙同学走路就被落下了一大截，这段距离可用bt-at表示。我们这样便可以推出t1的表达式来：由于at+at1+bt1=bt，移项得(a+b)t1=(b-a)t，所以t1=((b-a)/(a+b))t。再将t1的表达式代入：bt+at1+at=s <=> (a+b)t+((b-a)/(a+b))at=s。

至此，便不难得到((b^2+3ab)/(a+b))t=s，因为a、b与s都是一直信息，那么这又转化成了一个一元一次方程。解得t后再推算出t1，答案就是t+t1+t2=2t+t1。

附上Pascal核心代码：

  t:=(s/(sqr(b)+3\*a\*b))\*(a+b);

  t1:=(t\*(b-a))/(a+b);

（好吧说实话我提交这题就是为了刷贡献……）


---

## 作者：tututu (赞：1)

到这题，绝大部分人是不会自己研究方程的...

我也是

其他题解似乎都麻烦而且我一开始也推错了

## **此题解简单到\*。**

# 分割线-------------------------以上为废话

易知两人同时到最快。

kkk:首先车带一个人行驶x段距离，然后丢下 折回找另外一个人 半路碰上 带回终点，刚好与第一人共到

那么每个人不是走路就是在车上

要同时到，就是说走路的部分距离相等才行

设车带第一个人行x，那么折返与另一人相遇，另一人和车的总距离是2x，总速度是a+b，时间就是2x/(a+b)，

人走的距离就是2ax/(a+b)，应与第一个人被车扔下后走的距离s-x相等

得：s-x=2ax/a+b

2ax=as+bs-ax-bx

所以(3a+b)x=(a+b)s

x=(a+b)s/(3a+b)

输出算出时间即可

```cpp
#include<bits/stdc++.h>
using namespace std;
double s,a,b,x;
int main(){
  cin>>s>>a>>b;
  x=(a+b)*s/(3*a+b);//好像没有区别... 
  printf("%.6f",x/b+(s-x)/a);
  return 0;
}
```

---

## 作者：Listening (赞：1)

来自@296966943lzy 的奇技淫巧。

这题需要考虑的问题是：该怎样放人、载人才能到达B地且时间最少，后来我仔细想想，只用在某一个地方放人下去（就是说只用交换一次）。

现在的问题就变为了：该在哪个地方放人下去，带回终点，两人一起到终点，时间最少（首先车带一个人行驶一段距离然后丢下，折回找另外一个人，半路碰上，带回终点刚好与第一人共到B点）

这样问题就好解决了，设那个放下的点为x，那么就有：(s-x)/a=2\*(2\*x/(a+b)-x/b)+(s-x)/b

化简得：x=(b+a)\*s/(b+3a)

既然放下的那个点已经确定好了，那么时间也简单了，时间为：x/b+(s-x)/a，（x/b）为那个点前一段所用的时间，[（s-x）/a]为那个点后一段所用的时间。



附pas代码

```cpp
var
  a,b,s:longint;
  x,t:real;
begin
  readln(s,a,b);
  x:=(b+a)*s/(b+3*a);
  t:=x/b+(s-x)/a;
  writeln(t:0:6);
end.
```

---

## 作者：艾恩葛朗特 (赞：1)

首先我们要定义一个头文件
```cpp
#include<cstdio>
```
其次，我们要定义浮点变量s,a,b。
```
double s,a,b
```
然后输入s,a,b。
```cpp
scanf("%lf %lf %lf",&s,&a,&b);
```
输出
```cpp
printf("%.6lf",((2*a*s)/(3*a+b))/a+(s-((2*a*s)/(3*a+b)))/b);
```
代码如下
```cpp
#include<cstdio>//scanf大法吼啊 。 
double s,a,b;//定义变量。 
int main(){
    scanf("%lf %lf %lf",&s,&a,&b);//输入。 
    printf("%.6lf",((2*a*s)/(3*a+b))/a+(s-((2*a*s)/(3*a+b)))/b);//解方程。 
    return 0;//NOIP一定要加return 0; 
}//能用7行代码解决的问题不用8行解决。 
```

---

## 作者：封禁用户 (赞：1)

- 
尽量让车乘两人时间一样
- 
A地先乘甲
- 
注意是double




------------
****
AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    double a,b,s,x;
    cin>>s>>a>>b;
    x=(2*a*s)/(3*a+b);
    printf("%.6lf",x/a+(s-x)/b);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 小学应用题

画图解 （自己动手，丰衣足食哈）

最优解一定是甲（乘车）与乙（步行）同时出发

半路丢下甲让他走到终点（甲：QAQ）

并返回去接乙，带乙到终点

最终两人同时到达

```cpp
include<bits/stdc++.h>
using namespace std; 
double s,a,b; 
int main(){ 
	cin>>s>>a>>b;
    printf("%.6f",(s-(a+b)s/(3a+b))/a+(a+b)s/(3a+b)/b); 
}
```

---

## 作者：Sky_ (赞：0)

这是一个数学问题

首先，因为要使时间花费最少，所以要让甲，乙二人一起到达终点

于是，可设有三段路程

第一段：甲坐车，乙走路，花费时间为t1

第二段：甲下车，车去接乙（注意：这一段时间甲，乙都要走），花费时间为t2

第三段：乙上车，与甲同时到达终点

注意：因为两人同时到达终点，所以两人坐车的时间相同，为t1

代码如下var

```cpp
  a,b,n,m,i,j,k,s:longint;
  t,t1,t2:real;
begin
  readln(s,a,b);
  t1:=s*(a+b)/(3*a*b+b*b);//t1的时间
  t2:=t1*(b-a)/(a+b);//t2的时间
  t:=t1+t2+t1;//总时间
  writeln(t:0:6);//输出
end.

```

---

## 作者：Skywalker_David (赞：0)

刚开始想这题时我想到用动态规划，但仔细想想又好像不对，还是用数学的方法来解方便点。

这题需要考虑的问题是：该怎样放人、载人才能到达B地且时间最少，后来我仔细想想，只用在某一个地方放人下去（就是说只用交换一次）。

现在的问题就变为了：该在哪个地方放人下去，带回终点，两人一起到终点，时间最少（首先车带一个人行驶一段距离然后丢下，折回找另外一个人，半路碰上，带回终点刚好与第一人共到B点）

这样问题就好解决了，设那个放下的点为x，那么就有：(s-x)/a=2\*(2\*x/(a+b)-x/b)+(s-x)/b

化简得：x=(b+a)\*s/(b+3a)

既然放下的那个点已经确定好了，那么时间也简单了，时间为：x/b+(s-x)/a，（x/b）为那个点前一段所用的时间，[（s-x）/a]为那个点后一段所用的时间。

```delphi

var
    s,a,b,x:double;
begin
    readln(s,a,b);
    x:=(a+b)*s/(b+3*a);
    writeln((x/b+(s-x)/a):0:6)
end.

```

---

## 作者：Porsche (赞：0)

典型数学题
下面已经有大佬说明应该怎么列方程了，我就直接出代码了

```cpp
#include<bits/stdc++.h>//万能头文件 
#pragma GCC optimize(3)//O3优化 
using namespace std;
int main()
{
    double a,b,s;
    cin>>s>>a>>b;
    cout<<fixed<<setprecision(6)<<(2*a*s)/(3*a+b)/a+(s-(2*a*s)/(3*a+b))/b;//直接输出，应该会更快一些，但是反正也都是0ms 
    return 0;
}
```

---


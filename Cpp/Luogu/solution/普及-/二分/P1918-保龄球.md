# 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1. $\bigcirc \bigcirc \bigcirc$

2. $\bigcirc \bigcirc \bigcirc\ \bigcirc$

3. $\bigcirc$

4. $\bigcirc\ \bigcirc$

如上图，每个 “$\bigcirc$” 代表一个瓶子。如果 DL 想要打倒 $3$ 个瓶子就在 $1$ 位置发球，想要打倒 $4$ 个瓶子就在 $2$ 位置发球。

现在他想要打倒 $m$ 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 说明/提示

【数据范围】

对于 $50\%$ 的数据，$1 \leq n, Q \leq 1000, 1 \leq a_i, m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,Q \leq 100000, 1 \leq a_i, m \leq 10^9$。

## 样例 #1

### 输入

```
5
1 2 4 3 5
2
4
7
```

### 输出

```
3
0
```

# 题解

## 作者：沧澜 (赞：120)

### STL大法好。

(虽然并没有看出这个题目涉及到最短路，也在想入门难度的题为神马会被划分为普及/提高-)

因为每个位置的球数不相同，所以开一个map搞一下就完成了。

具体一看代码就明白了：

```cpp
#include<map>
#include<iostream>
using namespace std;
map<int,int>ma;
int n,a,q,m;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a;
        ma[a]=i;
    }
    cin>>q;
    for(int i=1;i<=q;i++){
        cin>>m;
        cout<<ma[m]<<endl;
    }
}
```

---

## 作者：影のない霜跡 (赞：17)

这题其实就是二分查找，我先用结构体绑定数组（一个记个数，一个记位置），再用sort来快排（二分要求有序），最后用一个二分就可以了。

****贴代码：****
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
struct aa{int g,w;};
bool cmp(aa x,aa y)
{
	return x.g<y.g;
}
aa gs[100000+5];
int n,m,wt,r,l,mid;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&gs[i].g);
	for(int i=1;i<=n;i++)gs[i].w=i;
	sort(gs+1,gs+1+n,cmp);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&wt);
		r=n+1;l=0;
		while(l+1<r)
		{
			mid=(r+l)/2;
			if(gs[mid].g<wt) l=mid;
			else r=mid;
		}
		if(gs[r].g!=wt)cout<<"0"<<endl;
		else printf("%d\n",gs[r].w);
	}
    return 0;
}
```

---

## 作者：Bronya18C (赞：11)

### 一开始看到就以为是裸二分，可后来发现快排会使原先的不对号，用结构体快排才解决。
- # 做法：结构体快排，二分查找
---
首先,我们开个结构体数组，用h来记录保龄球个数，用H来记录原先的坐标。
然后，我们把他快排一次。再用二分查找来查找对应的保龄球个数（h），但最后的答案是保龄球原先坐标（H）。

---
## ~~二分查找应该没人不会了吧~~
用l来记录范围的左端点，r来记录右端点，然后用mid折半，如果要查找的数据比mid小，就把r变成mid-1，大则相反。如果l>r证明找不到，跳出循环。
### 注意：二分要有有序性。

---
- ### 附上代码：

```
#include<bits/stdc++.h>

using namespace std;
long long n,m,a,ans;
struct data 
{
	long long h,H;
}N[100005];
bool cmp(data x,data y)
{
	return x.h<y.h;
}
bool pd(long long A,long long l,long long r)
{
	long long mid=(l+r)/2;
	if(N[mid].h==A)
	{
		ans=N[mid].H;
		return true; 
	}
	if(l>r)return false;
	if(A<=N[mid].h)return pd(A,l,mid-1);
	else return pd(A,mid+1,r);
}
int main()
{
	cin>>n;
	for(long long i=1;i<=n;i++)
	{
		cin>>N[i].h;
		N[i].H=i;
	}
	sort(N+1,N+1+n,cmp);
	cin>>m;
	for(long long i=1;i<=m;i++)
	{
		cin>>a;
		if(pd(a,1,n))
		{
			cout<<ans<<endl;
		}
		else cout<<0<<endl;
	}
	return 0;
} 
```

---

## 作者：引领天下 (赞：7)

这题竟然没有C++set的，STL会伤心的QAQ

我先讲一下本题的暴力做法

不解释，读入n个数据，然后对于每个m查找。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[100005],q;
int main(){
    scanf ("%d",&n);
    for (int i=1;i<=n;i++)scanf ("%d",&a[i]);
    scanf ("%d",&q);
    while (q--){
        bool ok=0;
        scanf ("%d",&m);
        for (int i=1;i<=n&&!ok;i++)if (a[i]==m)ok=printf ("%d\n",i);
        if (!ok)printf ("0\n");
    }
}
```

非常简单，于是快乐的T了。

观察一下，T的效率瓶颈在于

```
for (int i=1;i<=n&&!ok;i++)if (a[i]==m)ok=printf ("%d\n",i);
```

这里是朴素的查找，最坏会退化到O(n)的级别

那么如何优化呢？

此处分出了2条思路：

# 1.用map搞映射

这玩意相当于开了一个非常大的桶，而且也有题解讲了，我就不多说了

# 2.用STL的lower_bound

首先讲一下为什么用lower_bound。

因为lower_bound是找第一个≥n的元素，所以如果在数组中有n的话一定会找到n。

然后又分出了2条思路：

  - 用结构体重载运算符
  
    - 这个也有题解介绍了，我就不说了
    
  - 用set
  
    - 大家都知道，set按第一关键字排序，所以我们可以用结构体的思想，用set维护一个二元组(s,id)，s为具体值，id为行号。接下来就可以愉快地用lower_bound啦~
    
代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
set<pair<int,int> > st;//新建一个set
int n,m,q,s;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);//加速流读入
    cin>>n;
    for (register int i=1;i<=n;i++){
        cin>>s;
        st.insert(make_pair(s,i));//插入二元组
    }
    cin>>q;
    while (q--){
        cin>>m;
        set<pair<int,int> >::iterator it=st.lower_bound(make_pair(m,0));
        if (it->first==m)cout<<(it->second)<<endl;//如果能找到m，输出id；
        else cout<<0<<endl;//找不到输出0
    }
}
```

---

## 作者：DreamerY (赞：6)

#入门题目详解

**——不要想得太复杂**

——一个桶就搞定了。。。

——记录每个数出现的最早位置

——数据太大

——用一般数组回报

——那么就用map,CPP党福利

——你如果想保险一点就用unordered\_map正宗的哈希表（**C++11**）

——贴代码

‘’cpp




```cpp
#include <iostream>
#include <map>
using namespace std;
int n, q;
map<int, int> book;
int main(void)
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        if (!book[x]) book[x] = i + 1;
    }
    cin >> q;
    for (int i = 0; i < q; i++)
    {
        int x, a;
        cin >> x;
        cout << book[x] << endl;
    }
    return 0;
} 
''
```

---

## 作者：ssq050607 (赞：5)

# 具体有两种方法
## 1 二分查找
### 这里用结构体来存瓶子数和位置数
~~话不多说，上代码~~
```
#include<bits/stdc++.h>
using namespace std;
struct pos{
	int num;
	int sum;
}a[100005];
bool cmp(pos x,pos y){
	return x.sum <y.sum; 
}
int main(){
	int n,m,q;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].sum ;
		a[i].num= i;
	}
	sort(a+1,a+1+n,cmp);
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>q;
		int l=1,r=n,ans=0;
		while(l<=r){
			int mid=(l+r)/2;
			if(a[mid].sum<=q){
				l=mid+1;
				ans=mid;
			}
			else{
				r=mid-1;
			}
		}
		if(a[ans].sum ==q)
			cout<<a[ans].num <<endl;
		else
			cout<<0<<endl;
		 
	}
	return 0; 
}
```
## 2.map
```
#include<bits/stdc++.h>
using namespace std;
map<int,int> mp;//高级数组 第一个int---->x类型，第二个int---->y类型相当于 f(x)=y;
int main(){
	int n,m,x, q;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		mp[x]=i;//x--->i,x为瓶子数，i为位置 
	} 
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>q;
		cout<<mp[q]<<endl;//找不到默认对应为0，可以偷懒
//		mp.count(q);——>mp中q出现了几次；
		//if(mp.count(q) == 1) cout << mp[q] << endl;
		//else cout << 0 << endl; 这是不偷懒的方法
	} 
	return 0;
} 
```


---

## 作者：zhaoyifan (赞：4)

题目要求找到对应的值，数据范围在10^5内，因此不能循环枚举每一个值判断。

那么就需要一个高效的算法，根据所求在数组内查找相同值，可以使用stl库里的set查询，也可以二分

二分的话要把数据排序，但要对应输出未排序的下标，所以需要用struct来储存一个mark为未排序的下标

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm> 
using namespace std;
int n; int k=0;
struct node{
    int mark,ball;
}a[100001];
int cmp(node x,node y)
{
    return x.ball<y.ball;
}
int erfen(int l,int r)
{
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(k>a[mid].ball) l=mid+1;
        else r=mid-1;
    }
    if(a[l].ball==k) cout<<a[l].mark<<endl;
    else cout<<"0"<<endl;
}
int main()
{
    cin>>n;    
    for(int i=1;i<=n;++i)
    {
        cin>>a[i].ball;
        a[i].mark=i;
    }
    sort(a+1,a+n+1,cmp);
    int q;cin>>q;
    for(int i=1;i<=q;++i)
    {    
        k=0;
        cin>>k;
        erfen(1,n);
    }
    return 0;
}
```

---

## 作者：little_gift (赞：3)

**刚开始看到这道题感觉很难，结果一直没有做，然后仔细看了看……**

**这难度是在逗我吧？！**


思路:有两种方法，c++的map或者是二分查找。虽然知道二分比较快但特别懒的我还是写了map……的优化。


怎么优化呢？其实也不难，写个平板电视和fread就好了……


咳咳，其实我只是想说这两种优化是比较常用的(如果我没有记错的话CCF是允许的)。至于怎么用详见代码……


~~(说句实在话，加了优化似乎并没有什么用啊)~~




```cpp
#include <cstdio> //fread
#include <cctype> //快读的isdigit要用(听说isdigit比手写快)
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> //这两个看起来很可怕的头文件就是pb_ds了
//题外话：pb_ds的常数很小，所以比STL快。优先队列的头文件是<ext/pb_ds/priority_queue.hpp>
//其他的请网上自行搜索……(只是我懒得打了而已)
int n, m, x;
__gnu_pbds::tree < int, int > mm; //平板电视是定义在__gnu_pbds命名空间中的,用法基本和STL差不多
const int ri_top = 1e8;
char ri[ri_top], *rich = ri; //某快读的变量定义(话说为什么是rich呢，ri≈read_int,ri + ch == rich..
int read_int()
{
    int x = 0, f = 1; //虽然本题貌似没有负数但我还是写了
    while (!isdigit(*rich) && *rich != '-') ++rich;
    for (*rich == '-' ? f = -1 : x = *rich - 48; isdigit(*++rich); x = x * 10 + *rich - 48);
    return x * f;
} //不要问我为什么这么奇怪……
int main()
{
    fread(ri, 1, ri_top, stdin); //使用fread必须在前面加上这个
//题外话：用了fread貌似不能直接编译运行输入，建议用文件输入/洛谷在线IDE/先用scanf/直接交……
    n = read_int();
    for (register int i = 1; i <= n; ++i)
        mm[read_int()] = i;
    m = read_int();
    for (register int i = 0; i < m; ++i)
        printf("%d\n", mm[read_int()]); //原来我还写了mm.find(x) != mm.end(),然后我也不知为何去掉了
    return 0;
}
```


完结撒花


---

## 作者：Enzymii (赞：3)

搞一个lower\_bound真难啊，STL党也是不容易~~

一个手写的二分写到一半在想自己为什么不用STL啊

于是就调吧，反正就是交了好几遍，刚看到的时候思路就不对，

然后发现用结构体搞，

###不知道为啥我连个operator的类型都不加，我的DEV-C++都不报错！！！

多半是废了，然后就是忘记了lower\_bound并不是完全找相等的~~

所以又10分WA了一遍~~痛定思痛改A了以后准备写一个纯STL的题解（看楼下都是sort以后手写二分的）

似乎还有个我看不明白的FLOYED——不会用系列

好吧，代码：

···cpp //代码写的很清奇，基本都是压行，各位珍重

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct row{int c,t;}a[100005];
bool operator <(const row &a,const int &b){return a.t<b;}
bool operator <(const row &a,const row &b){return a.t<b.t;}
//重载运算符是STL的必备功课，据说写cmp函数慢呢~~
int main()
{
    int n,q;scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i].t),a[i].c=i;
        //二分查找要求有序
    sort(a+1,a+n+1);scanf("%d",&q);
    for(int x,y;q--;)
        scanf("%d",&x),y=lower_bound(a+1,a+n+1,x)-a,
                //看我们C++的STL就是好，二分查找就一行
        printf("%d\n",a[y].t-x?0:a[y].c);
                //找到的是这个数就输出编号，否则输出0
}
```
···
写完是个废人系列。。。


---

## 作者：keyingkai (赞：1)

主要的思路就是快速排序+二分查找.没有什么难点

```delphi

type class1=record
                        k,w:longint;//分别代表每个位置的瓶子数和瓶子的位置
                      end;
var
  d:array[1..100000]of class1;//我在在比赛的时候开5万数组，结果70分...
  ans:array[1..100000]of longint;
  i,j,n,m,t,mid,l,r:longint;
  f:boolean;
  p:class1;
procedure qsort(l,r:longint);
var i,j,t,mid:longint;
p:class1;
begin
  i:=l;
  j:=r;                                       {快排不解释}
  mid:=d[(l+r)div 2].k;
  repeat
    while d[i].k>mid do inc(i);
    while d[j].k<mid do dec(j);
    if i<=j then begin p:=d[i];d[i]:=d[j];d[j]:=p;inc(i);dec(j);end;
  until i>j;
  if i<r then qsort(i,r);
  if j>l then qsort(l,j);
end;
begin
  readln(n);
  for i:=1 to n do
  begin
  read(d[i].k);
  d[i].w:=i;
  end;
  qsort(1,n);      
  for i:=1 to n div 2 do begin p:=d[i];d[i]:=d[n-i+1];d[n-i+1]:=p;end;{从从小到大，变成从大到小}
  readln(m);
  for i:=1 to m do
  begin
    readln(t);
    l:=1;r:=n;f:=false;      
    repeat
      mid:=(l+r)div 2;      {这不就是二分查找么？}
      if d[mid].k=t then f:=true else
      if d[mid].k<t then l:=mid+1 else r:=mid-1;
    until f or(l>r);
    if f then ans[i]:=d[mid].w;
  end;
  for i:=1 to m do writeln(ans[i]);
end.

```

---

## 作者：King丨帝御威 (赞：1)

虽然这道题目有很多方法可以过，但是最好练一下二分查找，
这里讲一下c++二分查找的思路：

重点是函数部分，先定义查询的左右区间为1到n,然后开始二分，如果我们要找的值比这个中间值位置的数组小，那就去左侧的区间找，否则去右侧，没有的话返回0。

具体实现看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 100001
using namespace std;
int n,t,x,a[maxn];
struct node {                 //id为位置，a为球的数量。
	int id,a;
}e[maxn];
inline int find(int x) {       //二分查找，上面讲的很清楚了。
  int l=1,r=n;
  while(l<=r) {
  	int mid=(l+r)>>1;
  	if(e[mid].a==x) return mid;
  	if(e[mid].a>x) r=mid-1;
  	else l=mid+1;
  }
  return 0;
}
inline bool cmp(node x,node y) {   //二分查找必须有单调性，所以先从小到大排一边序。
  return x.a<y.a;
}
int main() {
  scanf("%d",&n);
  for(int i=1;i<=n;++i) scanf("%d",&e[i].a),e[i].id=i;
  sort(e+1,e+1+n,cmp);
  scanf("%d",&t);
  while(t--) {
  	scanf("%d",&x);
  	cout<<e[find(x)].id<<'\n';        //查完了就直接输出位置就行了。
  }
  return 0;
} 
```
这篇题解只针对于想学习二分查找的同学，有什么不懂的可以私信找我！！！

---

## 作者：zqiceberg (赞：0)

```cpp
//二分法特别锻炼边界问题
//对边界测试数据的分析评断，是一个很好的训练方式 
#include <iostream>
#include <algorithm>
#include <fstream>

using namespace std; 

const int N = 1e5 + 10;

typedef long long LL;
typedef pair<int, int> pi;
pi q[N];
int n;

bool cmp(pi a, pi b)
{
	return a.second < b.second;
}

int find(int x)
{
	int l = 1, r = n;
	while (l < r)
	{
		int mid = l + r + 1>> 1;
		if (q[mid].second <= x) l = mid;   //从左往右看，最后一个小于等于x的值 
		else r = mid - 1;
	}
	
	if (q[l].second != x) return 0;        //如果找到这个值不等于x，return 0 
	
	return q[l].first;                     //返回发球的位置 
}

int main()
{
//	freopen("baoling.in", "r", stdin);
	cin >> n;
	for (int i = 1; i <= n; i++) 
	{
		scanf("%d", &q[i].second);         //pair<发球位置，球的数量> 
		q[i].first = i;
	}
	
	sort(q + 1, q + 1 + n, cmp);            //以球的数量为关键字进行升序排列 
	
	int m;
	cin >> m;
	
	while (m--)
	{
		int k;
		cin >> k;
		
		cout << find(k) << endl; 
	}

	return 0;
}
```

---

## 作者：Conical (赞：0)

不知道这题为什么要加到最短路标签

根据题意和部分分，很容易得知，题目就是要我们在n个数里找x的位置

那么就容易想到二分

而题目给的数据无序，再加个结构体并排序

二分查找模板题#include<stdio.h>

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int MaxN=100005;
struct Node
{
    int id,x;
}a[MaxN];
inline bool cmp(Node i,Node j)
{
    return i.x<j.x;
}
inline int F(int s,int R)
{
    int L=1,Mid;
    while(L<=R)
    {
        Mid=(L+R)/2;
        if(a[Mid].x<s)
            L=Mid+1;
        else
            R=Mid-1;
    }
    if(a[L].x==s)return a[L].id;
    return 0;
}
int main()
{
    int N,i,M;
    scanf("%d",&N);
    for(i=1;i<=N;i++)
    {
        scanf("%d",&a[i].x);
        a[i].id=i;
    }
    sort(a+1,a+1+N,cmp);
    scanf("%d",&M);
    while(M--)
    {
        scanf("%d",&i);
        printf("%d\n",F(i,N));
    }
    return 0;
}
```

---

## 作者：Xieyyyyyy_o1O (赞：0)

emmm，本蒟蒻第一次发题解，若有错误，请多谅解。  
首先，这题呢，有两种方法可以做分别是：c++的map或者是二分查找。
而我用的是map（虽然知道二分快，但我这几天经常在做二分，所以这次换个思路）。  
好了，我来贴个代码（具体内容看看代码便知晓）。
以下便是代码：

    #include<bits/stdc++.h>
    using namespace std;
    map<int,int>ma
    int main(){
      int n,m,x,y;
      cin>>n;
      for(int i=1;i<=n;i++){
          cin>>x;
          ma[x]=i;
      }
      cin>>y;
      for(int i=1;i<=y;i++){
          cin>>m;
          cout<<ma[m];
      }
    }
好了，这就是我的代码。是我对于这题的见解，若有错误，请提出，谢谢。

---


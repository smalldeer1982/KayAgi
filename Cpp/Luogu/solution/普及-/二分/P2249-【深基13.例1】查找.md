# 【深基13.例1】查找

## 题目描述

输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。

## 说明/提示

数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$

本题输入输出量较大，请使用较快的 IO 方式。

## 样例 #1

### 输入

```
11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6```

### 输出

```
1 2 -1 ```

# 题解

## 作者：dingcx (赞：1684)

~~比赛刚结束，我来水一发题解~~

## 暴力解法

这个暴力解法还是蛮好想的。

对于每个询问，从头到尾搜一遍，找到就输出并 ```break``` ，如果一直找不到最后输出 $-1$ 。

然而这个的时间复杂度是 $O(nm)$，显然过不了。（代码就不贴了）

## 正解

~~这个正解好像也挺好想的~~

题目说序列**单调不减**，于是很容易就想到**二分**。

然而，~~我很懒~~，显然不会写二分，那就只能用 ```STL``` 自带的二分函数—— ```upper_bound``` 和 ```lower_bound```。

这两个函数的作用是二分查找一个数在数组中出现的位置。区别是 ```upper``` 返回第一个大于搜索数的位置，而 ```lower``` 是第一个大于等于的数的位置。显然这道题用的是 ```lower```。

函数的用法：```lower_bound(a.begin(),a.end(),x)``` 返回第一个大于等于 $x$ 的数的地址。而由于是地址，在最后要 $-a$（也就是减去地址）。

会了这个函数，还有一个问题：怎么判断 $-1$ 的情况？

其实也很简单。如果满足，那么一定有 $x=a[ans]$，所以如果不等那么输出 $-1$ 就行了。

说了这么多，代码也就非常好写了。

## 代码

下面是完整 AC 代码——

（~~不能只看这里啊~~）

```cpp
#include<cstdio>
#include<algorithm>//用到lower_bound
using namespace std;
const int MAXN=1e6+10;//注意范围
int read(){//快读
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int a[MAXN];
int main(){
	int n=read(),m=read();//读入
	for(int i=1;i<=n;i++) a[i]=read();
	while(m--){
		int x=read();
		int ans=lower_bound(a+1,a+n+1,x)-a;//二分搜，注意-a
		if(x!=a[ans]) printf("-1 ");//没有，输出-1
		else printf("%d ",ans);//有，输出ans
	}
	return 0;//华丽结束
}
```
看我这么晚还发题解，总得点个赞再走呀~

---

## 作者：YellowEgg (赞：411)

看大家都用STL或bound做。

我就来个手打二分的做法吧。

思路很简单，详情看注释。

## code:

```cpp
#include<cstdio>
using namespace std;

int n,m,q,a[1000005];

int find(int x) //二分查找 
{
	int l=1,r=n;
	while (l<r)
	{
		int mid=l+(r-l)/2;
		if (a[mid]>=x) r=mid;
		else l=mid+1;
	}
	
	if (a[l]==x) return l; //找都了就输出他的位置 
	else return -1; // 没找到输出-1 
}

int main()
{
	scanf("%d %d",&n,&m); //读入 
	
	for (int i=1 ; i<=n ; i++)
	    scanf("%d",&a[i]); //还是读入 
	
	for (int i=1 ; i<=m ; i++)
	{
		scanf("%d",&q);
		int ans=find(q); //看看查找的结果 
		printf("%d ",ans); //输出 
	}
	
	return 0;
}
```

复杂度 O(mlogn)。

**不会超时哦**。

---

## 作者：Ged_Relay (赞：147)

## 本蒟蒻第一次发题解QWQ求过
**首先题目意思是给一串已经排好了的数字问你某个数字的位置。\
如果从1到n扫一遍的话肯定超时。\
所以这里用了二分的方法：
#### **首先找到这串数字中间位置的那个数，然后与需要查询的数比较
#### 如果要查询的数小于中间那个数，那么答案肯定在左边
#### 如果要查询的数大于中间那个数，那么答案肯定在右边
#### 如果等于的话继续在左边找，因为找到的位置还不能确定是第一个数
#### 如此重复，直到要查询的区域变为1。

以下是AC代码：
------------

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int a[1000020];
int findpos(int a[], int l, int r, int k)
{
	if (l == r)
	{
		if (a[l] == k)
			return l;
		else
			return -1;/*最后位置的数与待查询数不相等，说明数列里没有此数*/
	}
	int mid = (l + r) / 2;
	if (k <= a[mid])
		findpos(a, l, mid, k);/*在左边区域找*/
	else
		findpos(a, mid + 1, r, k);/*在右边区域找*/
}
int main()
{
	int n, m, k;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	while (m--)
	{
		cin >> k;
		cout << findpos(a, 1, n, k) << " ";
	}
	return 0;
}
```



---

## 作者：AveMarina (赞：70)

## STL天下第一
这一题的意思就是在一个有序的序列中查找某个数，并要求输出其下标。按照常规思路，如果我们每次枚举当前下标的数并与输入的数对比，时间复杂度是O(n)的，这个复杂度在数据量较小的时候或许还可以接受，但是当数据量特别大的时候呢？我们可能运气好第一数就枚举到了正确的答案，但是如果题目~~数据强~~坑我们可能就要枚举到最后一位答案了。

那么我们可不可以考虑每次都从中间找呢？答案是可行的！因为序列是有序的，所以如果我们找到了一个大于目标数据的值，就可以认为这个区间的数都比目标大，即可舍去这个区间。这就是二分查找。

~~说了这么多反正你们也都会~~

### 用到的函数
__lower_bound(start, end, target):从在start到end区间内查找target，如果找到了，返回一个指针，如果没找到，返回第一个比它大的值的指针。__
```cpp
#include <iostream>
// 边长数组，这样我们就不用担心数据装不下了
#include <vector>
using namespace std;
vector<int > vec;
int main() {
	int n, m;
	int t;
	cin >> n >> m;
	int index;
    // 向数组尾部放入数据，因为这个特性，vector也可以当成stack用
	while(n--) cin >> t, vec.push_back(t);
	while(m--) {
		cin >> t;
        // 在序列里查找目标数据
		index = lower_bound(vec.begin(), vec.end(), t) - vec.begin();
        // 如果目标数据找到了，输出答案，注意我们的数组下标是从0开始的
		if (t == vec[index]) cout << index + 1 << ' ';
        // 没找到记得输出-1哦
		else cout << -1 << ' ';
	}
	return 0;
}
```
感谢你看完本蒟蒻的题解QWQ


---

## 作者：LinkZelda (赞：59)

###   第一次发题解！
## 1.审题！
n<1000000,m<100000,如果直接输入再找一次肯定会超时，所以要想一种更好的方法。
## 2.STL大法好！
我们可以对每一个出现的数字存它第一次出现的位置，十分方便，效率虽然有点低，但足以AC本题。
## 3.上代码！
```
#include<iostream>
#include<map>
using namespace std;
map<int,int>a;
int main()
{
	int m,n,k,l=-1;
	cin>>n>>m;
	for(int i=1;i<=n;i++)//输入并记录第一次出现的位置
	{
		cin>>k;
		if(l!=k){
			a[k]=i;
			l=k;
		}
	}
	for(int i=0;i<m;i++)//对于每一个询问，输出它的位置
	{
		cin>>k;
		if(a.count(k))cout<<a[k]<<' ';//如果存在就输出
		else cout<<-1<<' ';//否则输出-1
	}
	return 0;
}
```
希望管理员大大通过


---

## 作者：Graphcity (赞：46)

作为一个蒟蒻，我的第一想法是：

### 暴力解决

对于每一个询问，最坏只要扫一遍整个序列就可以了。

时间复杂度 $O(nm)$，肯定不能过。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
int a[1000001];

int main()
{
	scanf("%d%d",&n,&m);
	for(register int i(1);i<=n;++i)
		scanf("%d",&a[i]);
	for(register int i(1);i<=m;++i)
	{
		int k,ans=-1;
		scanf("%d",&k);
		for(register int j(1);j<=n;++j)
			if(a[j]==k)
			{
				ans=j;
				break;
			}
		printf("%d ",ans);
	}
    return 0;
}

```
接下来，我想到了...

### 莫队？！

（可能是我刷莫队刷的太多了吧 orz）

这个看起来非常像莫队的一个变形。

首先，我们可以把询问打包成一个结构体。

```cpp
struct query
{
	int k;//询问的内容
	int id;//询问的编号
};
query q[100005];
```
然后，我们以 k 为关键字从小到大排序。（注意：这次不用分块）

```cpp
bool cmp(query x,query y)
{
	return x.k<y.k;
}
```
接下来，仿照莫队的格式，创建一个 l=1 的指针，只需要使用 $O(n)$ 的时间就可以扫描完所有的询问了。

```cpp
for(register int i(1);i<=m;++i)
	{
		while(q[i].k>col[l] && l<=n) ++l;
		if(col[l]>q[i].k || l>n) ans[q[i].id]=-1;
		else ans[q[i].id]=l;
	}
```
接下来是完整的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,l=1;
int col[1000005];
struct query
{
	int k;
	int id;
};
query q[100005];
int ans[100005];

bool cmp(query x,query y)
{
	return x.k<y.k;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(register int i(1);i<=n;++i)
		scanf("%d",&col[i]);
	for(register int i(1);i<=m;++i)
	{
		scanf("%d",&q[i].k);
		q[i].id=i;
	}
	sort(q+1,q+1+m,cmp);
	for(register int i(1);i<=m;++i)
	{
		while(q[i].k>col[l] && l<=n) ++l;
		if(col[l]>q[i].k || l>n) ans[q[i].id]=-1;
		else ans[q[i].id]=l;
	}
	for(register int i(1);i<=m;++i)
		printf("%d ",ans[i]);
    return 0;
}

```
总时间复杂度：（可能是我乱写的）

$O(m\log_2m+n)$，不会超时。

---

## 作者：HsKr (赞：35)

大家用的大概都是bound吧，提供一个map的做法。

**注意吸氧！！！**

首先考虑用桶，肯定MLE，考虑$n$小，$q$大，用map太合适了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
using namespace std;
int n,m,a[1000010];
map<int,int> ma;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(!ma[a[i]]){//判断，只记录第一个 
			ma[a[i]]=i;//记录编号 
		}
	}
	for(int i=1;i<=m;i++){
		int q;
		cin>>q;
		if(!ma[q]) cout<<-1<<" ";//如果里面没有输出-1 
		else cout<<ma[q]<<" ";//否则输出编号 
	}
	return 0;
}
```

---

## 作者：zoezoykit (赞：26)

分析了一遍题目后，觉得不难，就准备着手做了。

然而，这时我无意间看到了这道入门赛橙题的 AC 率：仅有**10.26%**！

有图为证：

![](https://cdn.luogu.com.cn/upload/image_hosting/yzij1umb.png)

于是，我又重新分析了一遍题目，发现了这道题的难点：

不能直接遍历【1，$n$】整个区间，因为时间复杂度太高了，会超时。

通过后浏览了一下提交记录，果然大部分未通过的记录都有大面积的 **TLE**。

于是，我得出了正确且符合入门级别的解决策略：**二分查找**

~~当然，STL大法也是极好的~~

那么为什么要用二分查找呢？~~当然是看标签了~~

原因有两个：

1.效率比较高，**时间复杂度**低；

2.这道题避开了其劣势：需要查找的序列必须为**有序序列**；而本题中的序列恰好**单调不减**。

具体做法已在 **code** 中注释。

下面是完整AC代码（附注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;

int hsy,crz,part,first,size,last,sjx;


int main()
{
    cin>>hsy>>crz; 
    int zzk[hsy+1],lbn[crz+1];			//lbn 数组为记录每次询问的数的映射值：若存在，为序列下标值；若不存在，为“-1” 
	
	for(int a=1;a<=hsy;a++)
    {
    	cin>>zzk[a];
	}
	
	for(int k=1;k<=crz;k++)
    {
    	first=1;last=hsy;
        cin>>sjx;
        
        while(first-last<0)
    	{
    		size=last-first;
        	part=first+size/2;			//为了不溢出，须此语句 
        	
        	if(sjx==zzk[part]) 
			{
                last=part;				//若查找到输入的数 sjx,则继续在【first,part】的区间内进行二分查找
            }
			 
			else if(zzk[part]<sjx) 		//一般二分查找的做法 
			{
                first=part+1;
            } 
            
			else 
			{
                last=part-1;
            }
    	}
		
		if(sjx==zzk[last]) 
		{
			lbn[k]=last;				//如果查找到 sjx，则 last 的值就是次数在原数列中的下标（序列位置） 
		}
    	else 
		{
			lbn[k]=-1;	
		}  
    }

	for(int m=1;m<=crz;m++)
	{
		cout<<lbn[m]<<" ";
	}
	
    return 0;
}
```


---

## 作者：打表大蒟蒻 (赞：18)

这道题刚一看数据范围，就知道一般的查找肯定会爆，只能用二分，但二分查找代码太过冗长，记不住怎么办？（~~凉拌~~），所以，我们就搬出STL压箱底的宝贝——**lower_bound**。

首先，先把所有数放到mulitset里面去，对于每个数的编号用一个map映射过来，方便输出。在处理的时候，用lower_bound来将大于等于当前待查数据的值存入it，如果it大于当前待查数据，说明这个数在序列中不存在，输出-1，否则输出it映射的值。

上代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 50;
#define IO ios::sync_with_stdio(false);cin.tie(0)   //玄学加速

int n, m, a[maxn];
int main () {
	IO;
	cin >> n >> m;
	multiset<int> ms;   //定义mulitset
	map<int, int> mp;  //定义映射
	for(int i = 0;i < n; i++) {
		int k;
		cin >> k;
		ms.insert(k);    //把数据放到multiset里
		if(mp[k] == 0) mp[k] = i + 1;   //存一组映射
	}
	while (m--) {
		int t;
		cin >> t;
		int it = *ms.lower_bound(t);   //lower_bound大显身手
		if(it != t) cout << -1 << ' '; 
		else cout << mp[it] << ' ';
	}
	return 0;
}
```


---


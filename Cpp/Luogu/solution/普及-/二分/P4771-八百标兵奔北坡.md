# 八百标兵奔北坡

## 题目背景

baingbaboom正在往北边跑！！！

## 题目描述

现在在一张N*M的地图上有K只babingbaboom！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些babingbaboom都想要跑到北边的一个山坡上。求出离每一个babingbaboom最近的靠北的山。

补充定义：

山：

山的周围没有比它更高的地方。(四联通)

在北边：

令Babingbaboom的坐标为$A(a,b)$，山的坐标为$B(x,y)$，山在Babingbaboom的北边当且仅当$dis_{A,B}==a-x$

切比雪夫距离:

$ A(x_1,y_1) \qquad B(x_2,y_2) : \qquad dis_{A,B}=max(|x_1 - x_2|, |y_1 - y_2|)$


## 说明/提示

$$ 1 \leqslant  N,M \leqslant 1e3 $$
$$ 1 \leqslant  K \leqslant 1e5 $$
$$ 1 \leqslant  h_{i,j} \leqslant 1e9 $$
数据有梯度！

样例图片(星代表一个Babingbaboom，红色代表一个山)：
![](https://cdn.luogu.com.cn/upload/pic/22827.png)
(竖的是x，横的是y。画的时候没注意，很抱歉。)

## 样例 #1

### 输入

```
5 5 5
1 2 3 4 5
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2
2 3
3 4
4 5
5 1
```

### 输出

```
Pool Babingbaboom!
Pool Babingbaboom!
1
2
0```

# 题解

## 作者：_Spectator_ (赞：23)

[可能更好的食用体验](/article/dp7fkn1e) $|$
[题目传送门](/problem/P4771) $|$
[我的其他题解](/user/523641#article.2)

> upd on 2024.10.16：润色码风，修改了因专栏更新而炸掉的 $\LaTeX$。

本题解写得比较细，作者的初衷是想给更多刚入门的新手 OIer 看，大佬们可根据自身需求忽略部分内容。

------------
### ${\color{#00CD00}\text{题意简述}}$

估计很多人都不太清晰题意，尤其是“北边”的含义。首先，“北边”指的是一个 ${\text{babingbaboom}}$ 东北 $45\degree$ 至西北 $45\degree$ 的范围。例如，假设以下三个 $5\times 5$ 的地图中蓝色表示一个 ${\text{babingbaboom}}$ ，它可以奔到的范围为红色的区域：
![](https://cdn.luogu.com.cn/upload/image_hosting/6yj29rmq.png)

以及“切比雪夫距离”，题目描述写的也不太清楚。它指的是一个点 $(x_1,y_1)$ 与 $(x_2,y_2)$ 之间的“切比雪夫距离”为 $\max(\left|x_1-y_1\right|,\left|x_2-y_2\right|)$ 。

还有“山”的定义，只要一个点的高度比它东、南、西、北四个点的高度都要高（高度相等的不算），该点即为山。

弄明白这几点，这道题也就更容易着手了。

------------

### ${\color{#00CD00}\text{主要思路}}$

很多大佬这道题都是用 DP 做的，但这道题作为一道橙题，其实就是一道简单的枚举题。问题在于如何枚举。

假设在 $(x,y)$ 处有一个 ${\text{babingbaboom}}$，我们来分析一下枚举的范围：

首先是行的枚举范围。通过上面的图示不难看出，行的范围即为 $1\sim x$。不过，为了更方便的枚举列（下面会讲到），我们将这个步骤改为枚举一个差 $i$，$i$ 的范围是 $0\sim x-1$，此时的行数表示为 $x-i$。读到下面你就会明白为什么这样做了。

其次是列的枚举范围。可以发现，列的范围其实是与当前的行数有关的。有了前面枚举的差 $i$，列的范围可以表示为 $y-i\sim y+i$（注意还要判断一下是否超出边界）。

这样枚举下来，就能把每只 ${\text{babingbaboom}}$ 所能去到的每个点都枚举出来。只要在这范围内发现山，根据“切比雪夫距离”，因为列的差值绝对不可能大于 $i$，所以此时的 $i$ 即为答案。如果在这范围内没有一座山，则输出 `Pool Babingbaboom!`。

弄明白了如何枚举，其余细节请读者阅读代码，自行理解。

------------

### ${\color{#00CD00}\text{完整代码}}$

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i=a; i<=b; i++)
#define ismountain(i, j)\
a[i][j]>a[i-1][j] && a[i][j]>a[i+1][j] && a[i][j]>a[i][j-1] && a[i][j]>a[i][j+1]
using namespace std;
const int N = 1e3 + 5;
int n, m, k, x, y;
int a[N][N], h[N][N];
int bbbb(int x, int y){
	rep(i, 0, x-1) rep(j, max(0, y-i), min(m, y+i)) //枚举每个 Babingbaboom 可以到达的位置
		if(h[x-i][j]) return i; //找到一座山，i 即为答案
	return -1; //-1 表示在此范围内没有山 
}
int main(){
	ios::sync_with_stdio(false), cin.tie(nullptr);
	cin >> n >> m >> k;
	rep(i, 1, n) rep(j, 1, m) cin >> a[i][j];
	rep(i, 1, n) rep(j, 1, m) h[i][j] = ismountain(i,j); // 预处理
	rep(i, 1, k){
		cin >> x >> y;
		int ans = bbbb(x, y);
		if(ans != -1) cout << ans << "\n";
		else cout << "Pool Babingbaboom！\n";
	}
	return 0;
}
```

---

## 作者：b2019dy (赞：22)

一个比较简单的DP，f[i][j]表示离(i，j)最近的山的距离，显然，如果一个点是山，f[i][j]=0  
通过切比雪夫距离的定义，并根据题目条件，我们可以知道如果有离他距离为1的山的话，那一定在(i-1，j-1),(i-1，j)(i-1，j+1)。我们又可以看出，当离它距离为2时，一定能包括其所有情况。  
公式便可以很简单的推出$f[i][j]=min(f[i-1][j-1],f[i-1][j],f[i-1][j+1])+1$  

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k,h[1005][1005],f[1005][1005];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%d",&h[i][j]);
    }
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        if(h[i][j]>h[i-1][j]&&h[i][j]>h[i+1][j]&&h[i][j]>h[i][j+1]&&h[i][j]>h[i][j-1])
        {
            f[i][j]=0;
        }
        else
        {
            f[i][j]=min(f[i-1][j],min(f[i-1][j-1],f[i-1][j+1]))+1;
        }
    }
    for(int i=1;i<=k;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(f[x][y]>10000)
        {
            printf("Pool Babingbaboom!\n");
        }
        else printf("%d\n",f[x][y]);
    }
}

```

---

## 作者：yzx72424 (赞：9)

~~看到大佬们的dp瑟瑟发抖~~

这题数据比较水，暴力就能过。

每一个babingbaboom都向上搜索，北偏东45°和北偏西45°这两条射线中间的部分。

```
#include<bits/stdc++.h>
using namespace std;    
int h[1005][1005],x[100005],y[100005];
int mp[1005][1005];    int n,m,k;
void ss(int q,int w){
        for(int z=0;z<=q;z++)
            for(int zz=-z;zz<=z;zz++){//从Babingbaboom的位置向上搜北偏东45°和北偏西45°这两条射线中间的部分 
                     int zzz=zz;
                      if(w+zz<1)zzz=1;if(w+zz>m)zzz=m;
                     if(mp[q-z][w+zzz]==1){printf("%d\n",z);return;}
             }
             printf("Pool Babingbaboom!\n");
}
int main(){

    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
       scanf("%d",&h[i][j]);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {if(h[i][j-1]<=h[i][j]&&h[i-1][j]<=h[i][j]&&h[i][j+1]<=h[i][j]&&h[i+1][j]<=h[i][j])mp[i][j]++;}

    for(int i=1;i<=k;i++){scanf("%d%d",&x[i],&y[i]);ss(x[i],y[i]); }
 }
```

---

## 作者：BetterGodPig (赞：9)

题解背景：使用洛谷半年多几天了，终于开始磕我的第三篇题解了！


------------
[传送门](https://www.luogu.com.cn/problem/P4771)

题目大意：定义山为一个四联通点，给定大小为 $n*m$ 的有高度的地图，进行 $k$ 次询问，每次询问给定坐标，求距离该点最近且处于该点北方的山与此点的距离。（定义距离为两点纵轴差。）

因为只需要求在北方的山，所以每次只需要扩展 $(x-1,y-1),(x-1,y),(x-1,y+1)$ 这三条路径，且数据较小，因此可以考虑用搜索（广搜）。

再来说一下思路，每次广搜，先判断这个点是不是山，如果是，就立马输出 $0$ 并返回，不用搜了，否则将初始坐标入队，每次对队头进行扩展，新扩展的点的距离等于队头的距离 $+1$ ，如果扩展出的点是山，则立即输出距离并返回。

如果队列已经空了，但还没搜到答案，则输出 `
Pool Babingbaboom!
`。


以距离为深度，可以保证搜到的第一个答案即为最优解，可以节省很多的时间，以样例的第四次询问为例，流程图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/cquz9ddl.png)

最后，贴上AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y,dis;
};
int a[1005][1005],n,m,k;
int ny[4] = {-1,0,1};
inline int read(void){
	int x = 0,f = 1; char ch = getchar();
	while(!isdigit(ch)){if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch)){x = x*10+ch-48; ch = getchar();}
	return x*f;
}
inline bool check(int x,int y){
	return (a[x][y] > a[x-1][y] && a[x][y] > a[x+1][y] && a[x][y] > a[x][y+1] && a[x][y] > a[x][y-1]);
}
inline void write(int x){
	if(x < 0){putchar('-'); write(-x);}
	if(x > 9) write(x/10);
	putchar(x%10+48);
}
inline void bfs(int startx,int starty){
	if(check(startx,starty)){//先判断是否是山 
		puts("0");
		return ;
	}
	queue<node> q;//STL大法好！！ 
	q.push({startx,starty,0});
	while(!q.empty()){
		for(register int i = 0;i < 3;i++){
			node now = q.front();
			int tx = now.x-1; int ty = now.y+ny[i];//对队头进行扩展 
			if(tx<1 || ty<1 || ty>m) continue;//判断是否出界 
			int disn = now.dis+1;
			if(check(tx,ty)){//判断是否到达 
				write(disn);
				putchar(10);
				return ;
			}else{
				q.push({tx,ty,disn});
			}
		}
		q.pop();
	}
	puts("Pool Babingbaboom!");//如果没搜到答案 
}
int main(){
	n = read(); m = read(); k = read();
	for(register int i = 1;i <= n;i++){
		for(register int j = 1;j <= m;j++){
			a[i][j] = read();
		}
	}
	while(k--){
		int kx = read(),ky = read();
		bfs(kx,ky);
	}
	return 0;
}
```
既然您看都看了，总得留下个大拇指再离开叭？

---

## 作者：panjoel (赞：4)


$\texttt{\color{black}{很明显是一道DP题目。画一下图就可以发现，其实在北边的}}$
$\texttt{\color{black}{位置就是一个三角形。}}$
$\texttt{\color{black}{设f[i][j]为i行j列距离北边最近山峰的距离。}}$
$\texttt{\color{black}{那么如果这个位置本身就是一个山峰，那么f[i][j]=0如果这}}$
$\texttt{\color{black}{个位置不是山峰，那么由于是一个三角形，就有}}$

$\text{\color{black}{f[i][j]=min(f[i-1][j+1],min(f[i-1][j-1],f[i-1][j]))+1}}$

$\texttt{\color{black}{采用离线算法，O(1)输出}}$

## 代码
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define Inf 99999999
using namespace std;

int n,m,k,x,y,a[2001][2001],f[2001][2001];

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    memset(f,127/3,sizeof(f));  //初始化
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)
      scanf("%d",&a[i][j]);
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)  //枚举点
      f[i][j]=(a[i][j]<=a[i-1][j]||a[i][j]<=a[i+1][j]||a[i][j]<=a[i][j-1]||a[i][j]<=a[i][j+1])?min(f[i-1][j+1],min(f[i-1][j-1],f[i-1][j]))+1:0;  //若这是一个山峰，则f[i][j]=0，否则为旁边点到山峰的距离+1 
    while (k--)
    {
        scanf("%d%d",&x,&y);
        f[x][y]>Inf?printf("Pool Babingbaboom!\n"):printf("%d\n",f[x][y]);
    }
    return 0;
}

```


---

## 作者：Eismcs (赞：3)

**dp!!!!**

这题除了描述复杂容易迷惑人，其它的跟普通DP没两样。

状态转移方程会有些变化，因为山必须要在北方，所以只跟上一行有关了。

下面是含注释代码
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
//读入优化
int f[1005][1005],a[1005][1005];
//a[i][j]存高度,f[i][j]表示第i行第j个地方最近距离
int main(){
	memset(f,0x3f,sizeof(f));
   //初始化，赋“无穷大”
    int n=read(),m=read(),k=read(),x,y,xx=0;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
    		a[i][j]=read();
         //存高度
    	}
    }
    while(k--){
    //下面是动态形式做，相当于动态打表
    	x=read();y=read();
    	if(xx<x){
    		for(int i=xx+1;i<=x;i++)
    			for(int j=1;j<=m;j++)
            //枚举地点坐标
    				if(a[i][j]>a[i-1][j]&&a[i][j]>a[i][j-1]&&a[i][j]>a[i+1][j]&&a[i][j]>a[i][j+1]){
    					f[i][j]=0;
                 //倘若此处为山，最小值肯定为0，因为自己到自己距离当然为0
    				}
    				else {
    					f[i][j]=min(f[i-1][j-1],min(f[i-1][j],f[i-1][j+1]))+1;
                 //跟据题面的定义，只能取f[i-1],f[i-1][j-1],f[i-1][j+1]，因为这三个位置纵坐标之差大于等于横坐标之差，并且距离直接得知：1
                //根据最优子结构性质，绝对取了最优值
    				}
    		xx=x;//更新已做的行号，优化
    	}
    	if(f[x][y]>=f[0][0]){
    		printf("Pool Babingbaboom!\n");
         //判断是否最在解（f[0][0]始终都为无穷大）
    	}
    	else printf("%d\n",f[x][y]);
       //有解，根据坐标输出
    }
    return 0;
}

```


---

## 作者：Huami360 (赞：3)

这题我们可以发现一个规律，如图
![](https://cdn.luogu.com.cn/upload/pic/24230.png)

所有A都算做X的北边，可以自己去理解理解题意。

我们可以先预处理出所有点是不是山，用个bool或int二维数组标记，然后对这个数组求二维前缀和。

当要查询离一个点最近的山时，先查找没有满一行的格子，如图：
![](https://cdn.luogu.com.cn/upload/pic/24232.png)

这个暴力枚举，O(n/2)，当找到本行山的数量不为1，直接输出，break。

如果在这个部分没找到，那么好，上面的都是满行的，我们可以二分查找，总时间复杂度O(K*(n/2+logn/2))，实际用时远不到这么多。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define ll long long
#define INF 2147483647
using namespace std;
inline ll read(){
    ll s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
const int MAXN = 1010;
int a[MAXN][MAXN], is[MAXN][MAXN], sumx[MAXN][MAXN], sumy[MAXN], s[MAXN][MAXN];
int n, m, k, A, B;
bool flag;
int ask(int i, int k){
    return s[i][k] - s[i - 1][k];   //第i行前k个的和
}
int ASK(int k){    //第k行的和
    return s[k][m] - s[k - 1][m];
}
int main(){
    n = read(); m = read(); k = read();
    rep(i, 1, n)
       rep(j, 1, m)
          a[i][j] = read(); 
    rep(i, 1, n)
       rep(j, 1, m){
          is[i][j] = (a[i][j] > a[i - 1][j] && a[i][j] > a[i + 1][j] && a[i][j] > a[i][j - 1] && a[i][j] > a[i][j + 1]);         //is数组标记是不是山
          s[i][j] = is[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; //s数组求二维前缀和
       }
    rep(i, 1, k){
       A = read(); B = read();
       if(is[A][B]){ printf("0\n");continue; } //本身就是山
       int r = A - max(B - 1, m - B), l = 1; //r为第一个满行的x坐标
       dop(j, A - 1, max(0, r + 1))  //暴力枚举
          if(ask(j, min(m, B + A - j)) - ask(j, max(0, B - A + j) - 1)){
            flag = 1;
            printf("%d\n", A - j);
            break;
          }
       if(!flag && r > 0){   //没找到，二分查找
         while(l < r){
           int mid = (l + r) >> 1;
           if(ASK(mid) - ASK(mid - 1))
             l = mid + 1;
           else r = mid - 1;
         }
         if(!(ASK(l) - ASK(l - 1))) --l;
         if(l) printf("%d\n", A - l), flag = 1;
       }
       if(!flag) printf("Pool Babingbaboom!\n");
       flag = false;
    }
    return 0;
}

```

---

## 作者：hanzhongtlx (赞：2)

[P4771](https://www.luogu.com.cn/problem/P4771)  
难在读题？   
发现在北边的意思就是向北走的比向东西走的多，所以对于每个兵，不断向上枚举一个倒金字塔就行了。   
如果在这个金字塔中搜到山，就把答案记为金字塔层数好了。   
记得预处理山
## Code:
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int e[1005][1005],im[1005][1005];
struct node
{
	int x,y;
}a[100005];
int cnt[1005]={0};
int n,m,k;
int f=0;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	memset(e,0,sizeof(e));
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) scanf("%d",&e[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(e[i-1][j]<=e[i][j]&&e[i+1][j]<=e[i][j]&&e[i][j-1]<=e[i][j]&&e[i][j+1]<=e[i][j]) im[i][j]=1;
		}
	}
	for(int i=1;i<=k;i++) scanf("%d%d",&a[i].x,&a[i].y);
	for(int i=1;i<=k;i++)
	{
		/*if(a[i].x==1)
		{
			printf("Pool Babingbaboom!\n");
			continue;
		}*/
		f=0;
		for(int j=0;j<=a[i].x;j++)
		{
			for(int k=a[i].y-j;k<=min(m,a[i].y+j);k++)
			{
				if(im[a[i].x-j][k])
				{
					f=1;
					printf("%d\n",j);
					break;
				}
			}
			if(f) break;
		}
		if(!f) printf("Pool Babingbaboom!\n");
	}
	return 0;
}
```
坑点：不要特判$a_i.x=1$, 因为他有可能就在山上。   
复杂度:最坏$O(nm+nmk)$,但经过$break$的玄学优化，降到了一个可以接受的值，不过还是犹豫了老长时间，~~考虑$n$个树状数组可还行~~。

---

## 作者：HPXXZYY (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P4771)

------------
我们发现$1 \leq N,M\leq 1000$，所以我们可以用一种$O(N \times M)$的算法。

实际上，我们可以提前算出答案。

我们可以用一种类似```dp```的算法。记$f[i][j]$表示离点$(i,j)$最近的山。我们有如下转移：

$(1).$ 如果$(i,j)$是山，那么显然$f[i][j]=0$。

$(2).$ 如果$(i,j)$不是山，因为我们求北面的山，所以转移只能由$f[i-1][j],f[i-1][j-1],f[i-1][j+1]$三个点转移而来。自然，我们肯定取它的最小值，所以转移为：

$$f[i][j]=min(min(f[i-1][j-1],f[i-1][j]),f[i-1][j+1])+1$$

注意```+1```。

------------
**【代码】（没有头文件）：**
```cpp
int f[1010][1010],n;
int h[1010][1010],m,k;
const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};
int main(){
	scanf("%d%d%d",&n,&m,&k);
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&h[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			register bool flag=true;
			for(int l=0;l<4;l++)
				if (h[i][j]<=h[i+dx[l]][j+dy[l]])
					flag=false;
			if (flag) f[i][j]=0;
			else f[i][j]=min(min(f[i-1][j-1],f[i-1][j]),f[i-1][j+1])+1;
		}
	for(int i=1;i<=k;i++){
		register int x,y;
		scanf("%d%d",&x,&y);
		if (f[x][y]>100000)	
			printf("Pool Babingbaboom!\n");
		else printf("%d\n",f[x][y]);
	}
	return 0;
}
```

---

## 作者：mot1ve (赞：1)

暴力模拟，来一发
```
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;
int n,m,dis,p;
int a[1010][1010],vis[1010][1010];
int main()
{
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]>=a[i-1][j]&&a[i][j]>=a[i+1][j]&&a[i][j]>=a[i][j+1]&&a[i][j]>=a[i][j-1])
			{
				vis[i][j]=1;//这个是山 
			}
		}
	}
	for(int k=1;k<=p;k++)//k个比巴卜 
	{
		int minn=INF;
		int x,y;
		scanf("%d%d",&x,&y);//读入比巴卜的坐标 
		for(int i=1;i<=x;i++)//枚举每个点，看看有没有山
		{
			for(int j=1;j<=m;j++)
			{
				if(vis[i][j])//山的坐标为i，j 
				{
					int dis=0;
					dis=max(abs(x-i),abs(y-j));
					if(dis==x-i)
				    {
				    	minn=min(dis,minn);
					}
				}
			}
		} 
		if(minn==INF)
		printf("Pool Babingbaboom!\n");
		else printf("%d\n",minn);
	}
	return 0;
}
```

---

## 作者：轻尘 (赞：1)

## 题解 P4771
**蒟蒻前来写一篇题解，这是一道非常成功的题目（完全看不出是DP），于是身为蒟蒻的我就开始乱搞~~（乱搞压标算）~~，
在被样例图示坑到后，我完成了一份成功的暴力，如下**
```cpp

const int inf=0x7ffffff;
int dis(int x1,int y1,int x2,int y2)
{
	return max(abs(x1-x2),abs(y1-y2));
}
struct destination
{
	int x,y;
}dist[1000001],in,moun[1000001];
int n,m,k;
int Map[10001][10001];
int xx[]={0,0,1,-1},yy[]={1,-1,0,0};
int main()
{
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
			Map[i][j]=read();
	for(register int i=1;i<=k;i++)
		dist[i].x=read(),dist[i].y=read();
	int cnt=0;
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
		{
			int f=0;
			for(register int z=0;z<4;z++)
			{
				in.x=i+xx[z],in.y=j+yy[z];
				if(in.x<1||in.x>n||in.y<1||in.y>m) continue;
				if(Map[in.x][in.y]>Map[i][j])
				{
					f=1;
					break;
				}
			}
			if(!f) moun[++cnt].x=i,moun[cnt].y=j;
		}
	for(register int i=1;i<=k;i++)
	{
		int ans=inf;
		for(register int j=1;j<=cnt;j++)
		{
			int p=dis(dist[i].x,dist[i].y,moun[j].x,moun[j].y);
			if(p!=(dist[i].x-moun[j].x)) continue;
			ans=min(ans,p);
		//	cout<<ans<<endl;
		}
		if(ans==inf) printf("Pool Babingbaboom!\n");
		else printf("%d\n",ans);
	}
	return 0;
}


```
$O(cnt*k)$暴力
结果得了85分（！开心！）。
然后在dalao的指点之下，蒟蒻才看出这TM是DP？？？


------------
## 咳咳，进入正题。

**思路其实也很简单，关键是要能从什么T*^%*^%^&$*&%（切比雪夫）距离中看出规律（反正我没看出来）。求距离Bing的下方和左右不能有山，那距离为1时,只有可能从他上方三点转移而来。**

**方程为
$f[i][j]=min(f[i-1][j],min(f[i-1][j-1],f[i-1][j+1]))+1;$
而当一点的四周都不比他高时，$f[i][j]=0.$**

**代码20来行，不贴~~（70行暴力心态爆炸）~~ : )**

---

## 作者：神眷之樱花 (赞：0)

## 前言

题意很好理解吧，但不明白为什么它的算法标签中没有DP。
这道题用DP是很好做的，下面我说说我的做法。

## 解析

首先我们用 $f[i][j]$ 来表示坐标为 $(i,j)$ 到北面最近的山的距离，先初始化成正无穷，然后判断该点是否为山，如果是山，那么该点到北面最近的山的距离自然是 $0$，如果不是山的话，我们可以用距离该点最近的北面的点来更新它，因为是 DP 嘛，距离该点最近的北面的点保存的是这几个点到它们北面最近的山的距离，也就是最优子结构。离该点最近的北面的点的坐标 $(i-1,j)$，$(i-1,j-1)$，$(i-1,j+1)$，因为它们到该点的切比雪夫距离均为 $1$，所以在状态转移时还要加上 $1$。

## 榜一代码
开了O(2)之后冲到了榜一，实测手写 $min$ 更快。

```cpp
#include<cstdio>
#include<cstring>
const int N = 1e3 + 5;
const int INF = 0x3f3f3f3f;
int f[N][N],h[N][N];
inline int min(int a,int b) {
	if(a < b) return a;
	return b;
}
bool cmp(int i,int j) {
	if(h[i][j] >= h[i - 1][j] && h[i][j] >= h[i + 1][j] && h[i][j] >= h[i][j - 1] && h[i][j] >= h[i][j + 1])
		return true;
	else return false;
}
int minn(int i,int j) {
	return min(f[i - 1][j],min(f[i - 1][j - 1],f[i - 1][j + 1])) + 1;
}
inline int read() {
	int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	int n = read(),m = read(),k = read();
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			h[i][j] = read();
	memset(f,INF,sizeof(f));
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			f[i][j] = cmp(i,j) ? 0 : minn(i,j);
	for(int i = 1; i <= k; i++) {
		int x = read(),y = read();
		if(f[x][y] > 66666) puts("Pool Babingbaboom!");
		else printf("%d\n",f[x][y]);
	}
	return 0;
}
```


---

## 作者：朱屹涵2008 (赞：0)

### 本题重点算法：DP（动态规划）
###### ~~题目标签误人子弟~~
------------
#### 题目内容概括：

- 有一张 *n* * *m*  的地图, $h_{i,j}$ 表示格子 *( i , j )* 的高度。
- 给出 *k* 个点的坐标，分别求这 *k* 个点最近的山的离这个点的切比雪夫距离。
- 山的定义：若一个点上、下、左、右四个格子的高都小于这个点，则这个点是山。
- 北边的定义：如图红点标示区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/w3gmoghz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

- 切比雪夫距离：两点之间各坐标数值差绝对值的最大值。
- 1≤ *n , m* ≤10^3 ，1≤ *k* ≤10^5 ，1≤ $h_{i,j}$ ≤ 10^9

------------

**DP状态定义:** $f_{i,j}$ 表示距离格子 *( i , j )* 最近的山的距离。

**DP转移方程:** $f_{i,j}$ = min ( $f_{i-1,j-1}$ , $f_{i-1,j}$ , $f_{i-1,j+1}$ )

------------

#### AC代码（附注释）：

```cpp
#include<bits/stdc++.h>
#define N 1005
#define K 100005
#define INF 0x3f
#define OK 10000
int n,m,k,x[K],y[K],h[N][N],f[N][N];
//f[i][j]代表(i,j)离最近的山的距离，没有则为INF,(i,j)是山则为0 
using namespace std;
void input(){//输入部分+初始化 
	cin>>n>>m>>k;  //输入
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++){
	    	cin>>h[i][j];//输入
		}
	memset(f,INF,sizeof(f));
	for(int i=1;i<=k;i++)
	    cin>>x[i]>>y[i];//输入
}
void DP(){//动态规划部分 
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++){
	    	if(h[i][j]>h[i][j+1]&&h[i][j]>h[i][j-1]
		     &&h[i][j]>h[i+1][j]&&h[i][j]>h[i-1][j]){//f[i][j]是山 
		     	f[i][j]=0;//距离为0 
		     	continue;
			}
			f[i][j]=min(min(f[i-1][j],f[i-1][j-1]),f[i-1][j+1])+1;//状态转移 
		}
}
void output(){//输出部分 
	for(int i=1;i<=k;i++){
		if(f[x[i]][y[i]]>OK)//北方没有山 
		    cout<<"Pool Babingbaboom!"<<endl;//输出 
		else//北方有山
		    cout<<f[x[i]][y[i]]<<endl;//输出 
	}
}
int main(){
    input();
    DP();
    output();
	return 0;
}
```

---


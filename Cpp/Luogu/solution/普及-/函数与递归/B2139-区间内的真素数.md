# 区间内的真素数

## 题目描述

找出正整数 $M$ 和 $N$ 之间（$N$ 不小于 $M$）的所有真素数。

真素数的定义：如果一个正整数 $P$ 为素数，且其反序也为素数，那么 $P$ 就为真素数。

例如，$11$，$13$ 均为真素数，因为 $11$ 的反序还是为 $11$，$13$ 的反序为 $31$ 也为素数。

## 说明/提示

$1 \le M \le N \le 100000$

## 样例 #1

### 输入

```
10 35```

### 输出

```
11,13,17,31```

# 题解

## 作者：5k_sync_closer (赞：20)

# 前置芝士
`to_string(int n)`：将 n 转换为 `string`

`stoi(string s)`：将 s 转换为 `int`

`reverse(iterator a, iterator b)`：反转 a 到 b 之间的区间。
# 思路
暴力模拟，枚举 $m$ 到 $n$ 的每一个数。

依次判断区间内的数，和它的反序是否素数。

转换反序时，用 `to_string` 转换为 `string`，再用 `reverse` 反转，再用  `stoi` 转成 `int`。

注意`,`和无解情况的判断，可以用两个`bool`变量记录状态。
```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int n, m;bool f, b;
bool isp(int n)
{
    if(n == 1) return 0;
    if(n == 2) return 1;
    if(n % 2 == 0) return 0;
    for(int i = 3;i * i <= n;++i)
        if(n % i == 0) return 0;
    return 1;
}
int main()
{
    cin >> n >> m;
    for(int i = n;i <= m;++i)
    {
        string t = to_string(i);
        reverse(t.begin(), t.end());
        int j = stoi(t);
        if(isp(i) && isp(j))
        {
            if(f) cout << ",";
            cout << i;f = 1;b = 1;
        }
    }
    if(!b) cout << "No";
    return 0;
}
```


---

## 作者：封禁用户 (赞：8)

暴力枚举+模拟。

首先定义一个函数 `isPrime()` 用来判断素数，然后再定义一个函数 `isxrxPrime()` 用来判断 $x$ 和它的回文数 $r_x$ 是否均为回文数。

主函数里从 $m$ 枚举到 $n$，每一个判断函数 `isxrxPrime(i)` 的值是否为 `true`。是的话布尔值 `norprime` 设为 `false`， 表示找到真素数了。

这题还有那么亿点点的坑：

输出需要逗号，逗号跟空格不同。空格你多打一个~~看不见~~，但是逗号却能看见，所以输出时循环要枚举到**倒数第二项**，每一次循环打出一个真素数和一个逗号，最后一项单独输出一个真素数和一个~~可有可无~~的换行。

好，思路就这些，下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, b[10010], j; // j相当于一个指示数，用来存真素数，存完后则j ++
bool isPrime(int x){ // 判断素数
    for (int i = 2; i <= sqrt(x); i ++)
    if (x % i == 0) return false;
    return true; // 这代码好经典啊……
}
bool isxrxPrime(int x){ // 将数回文，并求它俩是否都是素数
    int a[10], tx = x, i = 0, nx = 0, g = 1;
    while (tx){
        a[i ++] = tx % 10; // 回文这一位加进去~
        tx /= 10; // 去掉这一位QwQ
    }
    while (i){ // 生成回文数
        tx += g * a[i - 1];
        g *= 10;
        i --;
    }
    if (isPrime(x) && isPrime(tx)) return true; // 俩都是素数
    return false;
}
int main(){
    cin >> m >> n; // 输入 
    bool norprime = true; // 是否有真素数
    for (int i = m; i <= n; i ++){
        if (isxrxPrime(i)){ // FOUNDED!
            b[j ++] = i; // 存上ta
            norprime = false; // 设为false，找到啦
        }
    }
    if (!norprime){
        for (int k = 0; k < j - 1; k ++) cout << b[k] << ","; // 输出
        cout << b[j - 1] << endl; // 大坑，最后一个数后面没有逗号
    }
    else cout << "No" << endl; // 没找着真素数
    return 0;
 }
 ```

---

## 作者：Level_Down (赞：7)

## 题目简介：

求区间内本身是质数且数字倒过来之后也是质数的数。

## 分析：

先看数据范围：$M \leq N \leq 100000$。

妥妥的暴力模拟。

就是按照题意将区间内的数都遍历一遍，判断这些数是否本身是质数且数字倒过来之后也是质数，是的话要先存起来，因为输出中两数间用逗号隔开，而最后一个数后面不用逗号，无法把握。

还有千万不要忘了输出 `NO`。

没懂的看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,c[10005],cnt;
int ck(int n)//判断质数的函数。 
{
	for (int i = 2; i * i <= n; i++)
		{
			if (n % i == 0) return 0;
		}
	return 1;	
} 
int cz(int n)//将一个数倒过来的函数。 
{
	int ans = 0;
	while(n) ans = ans * 10 + n % 10,n /= 10;
	return ans;
}
int main()
{
	cin >> a >> b;
	for (int i = a; i <= b; i++)
		{
			if (ck(i) && ck(cz(i))) c[++cnt] = i;//先存起来。 
		}
	for (int i = 1; i <= cnt; i++)
		{
			cout << c[i];
			if (i != cnt) cout << ",";//注意特判。 
			}	
	if (cnt == 0) cout << "No";//千万不要忘了输出NO。		
	return 0;
}

```


---

## 作者：user470883 (赞：6)

特别清楚的暴力模拟。

分析：

 $n$ ~ $m$ 间枚举每一个奇数，然后判断是否是真素数（正反都是素数）。是就存入数组，不是就不管了。最后用for循环输出一下答案，就完美解决了。
 
注意：

1. 范围包括 $n$ 和 $m$。
2. 2也是素数，但其他素数都是奇数，于是特判一下。
3. 输出要逗号，所以先存入数组在判断输出

优化的话......

先看这种程序的代码吧。

AC CODE:
```
#include <bits/stdc++.h>
using namespace std;
int m, n;		
int ans[50010];
int cnt = 1;
bool num(int x) {	
   int y = sqrt(x);
   if (x % 2 == 0) {		
   	if (x == 2) {
   		return true;
   	}
   	return false;
   } else {
   	for (int i = 3; i <= y; i += 2) {
   		if (x % i == 0) {
   			return false;
   		}
   	}
   }
   return true;
}
bool re(int x) {	
   char nbr[8];
   sprintf(nbr, "%d", x);
   reverse(nbr, nbr + strlen(nbr));
   int i = atoi(nbr);
   if (num(i)) {
   	return true;
   } else {
   	return false;
   }
}
int main() {
   scanf("%d%d", &m, &n);
   if (m <= 2) {
   	ans[cnt] = 2;
   	cnt++;
   	m = 3;
   } else {
   	if (m % 2 == 0) {		
   		m += 1;
   	}
   	if (n % 2 == 0) {
   		n -= 1;
   	}
   }
   for (int i = m; i <= n; i += 2) {		
   	if (num(i)) {
   		if (re(i)) {
   			ans[cnt] = i;
   			cnt++;
   		}
   	}
   }
   for (int i = 1; i < cnt; i++) {		
   	
   	if (i == cnt - 1) {
   		printf("%d", ans[i]);
   	} else {
   		printf("%d,", ans[i]);
   	}
   }
   if (cnt == 1) {
   	printf("%s", "No\n");
   }
   return 0;
} 

```

当然像我这么懒的当然对长程序说“不！”。

于是，还有解法。

转换反序时，用 ```to_string``` 转换为  ```string``` ，再用 ```reverse``` 反转，再用 ```stoi``` 转成 ```int``` 。

这种代码就短多了。

AC CODE:

```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int n, m;bool f, b;
bool isp(int n)
{
    if(n == 1) return 0;
    if(n == 2) return 1;
    if(n % 2 == 0) return 0;
    for(int i = 3;i * i <= n;++i)
        if(n % i == 0) return 0;
    return 1;
}
int main()
{
    cin >> n >> m;
    for(int i = n;i <= m;++i)
    {
        string t = to_string(i);
        reverse(t.begin(), t.end());
        int j = stoi(t);
        if(isp(i) && isp(j))
        {
            if(f) cout << ",";
            cout << i;f = 1;b = 1;
        }
    }
    if(!b) cout << "No";
    return 0;
}
```


---

## 作者：TensorFlow_js (赞：6)

# 题目分析
我们可以枚举 $M$ 和 $N$ 之间的所有数，再一个个数判断它是不是素数，倒过来是不是素数。模拟枚举即可。
# 代码
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
bool is_prime(int i){//判断一个数是不是素数
    for(int j = 2;j <= sqrt(i);j ++)if(i%j==0)return false;//枚举2到这个数的平方根中的所有数,如果这个数能被任何一个数整除,则这个数不是素数
    return true;//否则这个数是素数
}
int reverse_order_output(int x){//返回一个数的倒序数
	int newx = 0;//倒序数
	while(x){
		newx = newx*10 + x%10;//newx乘10留出个位数给下一位x,x%10是x当前的个位数
		x /= 10;//去除x当前的个位数
   }
   return newx;//返回倒序数
   /*
   举个例子:若我们将114514进行倒序
   Step 1:
   newx = 0 -> newx = newx * 10 （现在为0） + x % 10 （现在为4） = 4
   x = 114514 -> x = x / 10 = 11451 （自动下取整）
   Step 2:
   newx = 4 -> newx = newx * 10 （现在为40） + x % 10 （现在为1） = 41
   x = 11451 -> x = x / 10 = 1145
   Step 3:
   newx = 41 -> newx = newx * 10 （现在为410） + x % 10 （现在为5） = 415
   x = 1145 -> x = x / 10 = 114
   Step 4:
   newx = 415 -> newx = newx * 10 （现在为4150） + x % 10 （现在为4） = 4154
   x = 114 -> x = x / 10 = 11
   Step 5:
   newx = 4154 -> newx = newx * 10 （现在为41540） + x % 10 （现在为1） = 41541
   x = 11 -> x = x / 10 = 1
   Step 6:
   newx = 41541 -> newx = newx * 10 （现在为415410） + x % 10 （现在为1） = 415411
   x = 1 -> x = x / 10 = 0 ，循环结束，返回415411。
   */
}
int main(){//主函数
    int m,n,ans[10000],ansnum=0;//定义题目中的M与N,答案数组,答案的个数
    cin>>m>>n;//输入M与N
    for(int i = m;i <= n;i ++){//枚举开始
        if(is_prime(i)&&is_prime(reverse_order_output(i)))//如果这个数及它的倒序数是素数,则它是真素数
            ans[ansnum]=i,ansnum++;//记入答案数组,答案个数增加1
    }
    if(ansnum==0){//如果答案个数为0,输出"No"
        cout<<"No";
        return 0;//返回0
    }
    for(int i = 0;i < ansnum - 1;i ++)cout<<ans[i]<<",";//否则依照题目输出
    cout<<ans[ansnum-1];
    return 0;
}
```
### UPD：
`2020\7\3\16:31` ：解释了倒序数的部分。

---

## 作者：daiarineko (赞：3)

## 题意简述

如果一个正整数 $P$ 为素数，且其反序也为素数，那么 $P$ 就为真素数。

求指定区间中真素数的个数。

## 解法

时间复杂度:$\Theta(N\sqrt{N})$

看到上一篇题解用的是在线解法，那我就用离线解法。

判断素数部分使用暴力，遍历每个数是否能被 $[2,\sqrt{N}]$ 范围内的某个数整除。如果能，这个数就不是质数。

```cpp
bool isprime[100001];
void prime(int maxn){
    isprime[2]=isprime[3]=isprime[5]=isprime[7]=1;
    for(int i=11;i<=maxn;++i){
        isprime[i]=1;
        for(int j=2;j*j<=i;++j){//优化1：使用乘方替换平方根，提升性能
            if(!isprime[j])continue;//优化2：只检查范围内的质数
            if(i%j==0){isprime[i]=0;break;}
        }
    }
}
```

数字反序部分通过 `while` 循环实现，倒序取数位，正序存数位即可达到反序效果。

```cpp
int reverse(int n){
    register int k=0;
    while(n>0){
        k+=n%10;
        k*=10;
        n/=10;
    }
    return k/10;//先加再乘会导致被多乘一次
}
```

为了优化小数据的性能，预处理范围由 $N$ 确定；

输出时判断是否为真素数：

```cpp
int len(int n){
    register short k=0;
    while(n>0){
        ++k;
        n/=10;
    }
    return k;
}
int main(){
    ios::sync_with_stdio(false);
    int m,n,k=0;
    cin>>m>>n;
    prime(pow(10,len(n-1)));//优化3：len函数确定最大位数，以此改变预处理范围
    //坑点1：由于要反序，这里不能直接传入n
    //坑点2：当n==100000时，len函数返回6，会导致预处理范围（1000000）超出数组
    for(int i=m;i<=n;++i){
        if(isprime[i]&&isprime[reverse(i)]){
            if(k)cout<<',';
            cout<<i;
            k=1;
        }
    }
    if(!k)cout<<"No";//坑点3：没有真素数时输出No
    cout<<endl;
    return 0;
}
```

本地结果：极端数据比上篇题解快 `50ms`，$M$ 和 $N$ 接近时速度接近，小数据时比上篇题解慢 `10ms`。

---

## 作者：DiDi123 (赞：2)

# 题目分析
对于这道题，我们可以先用素数筛把 $1 \sim 100000$ 的素数都枚举出来（详见 [B2137 判决素数个数](https://www.luogu.com.cn/problem/B2137) ），然后判断一个在 $M$ 和 $N$ 之间的数 $P$ 以及它反转后的数是否都为素数就行了。对于这个数的反转操作，我们可以先将这个数转成字符串，再用反转函数 reverse() 将字符串反转，然后再将反转后的字符串转成整型。
# 代码
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int MAXN=100001;
int vis[MAXN],ans[MAXN],m,n,cnt;
int backwards(int a) //反转函数 
{
	string s;
	while(a) //将整型转为string 
	{
		s+=char(a%10+'0');
		a/=10;
	}
	int b=0;
	for(int i=0;i<s.size();i++) //将string转为整型 
	//因为字符串是从最高位开始访问的，所以已经天然地反转了 
	{
		b*=10;
		b+=s[i]-'0';
	}
	return b;
}
int main()
{
	cin>>m>>n;
	for(int i=2;i<1000;i++) //素数筛 
	{
		if(!vis[i])
		{
			for(int j=i;j<MAXN/i;j++)
				vis[i*j]=1;
		}
	}
	for(int i=m;i<=n;i++)
	{
		if((!vis[i])&&(!vis[backwards(i)]))
			ans[++cnt]=i;
	}
	if(!cnt) cout<<"No";
	else //注意要记录一个ans，因为最后一个答案后面不输出',' 
	{
		for(int i=1;i<cnt;i++) cout<<ans[i]<<',';
		cout<<ans[cnt];
	}
}
```


---


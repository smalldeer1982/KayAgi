# 确定进制

## 题目描述

$6 \times 9=42$ 对于十进制来说是错误的，但是对于 $13$ 进制来说是正确的。即 $6_{(13)} \times 9_{(13)}=42_{(13)}$，而 $42_{(13)}=4 \times 13^1+2 \times 13^0=54_{(10)}$。

你的任务是写一段程序读入三个整数 $p,q$ 和 $r$，然后确定一个进制 $B(2 \le B \le 16)$ 使得 $p\times q=r$。如果 $B$ 有很多选择，则输出最小的一个。

例如：$p=11,q=11,r=121$，则有 $11_{(3)} \times 11_{(3)}=121_{(3)}$，因为 $11_{(3)}=1 \times 3^1+1 \times 3^0=4_{(10)}$ 和 $121_{(3)}=1 \times 3^2+2 \times 3^1+1 \times 3^0=16_{(10)}$。对于进制 $10,$ 有 $11_{(10)} \times 11_{(10)}=121_{(10)}$。这种情况下，应该输出 $3$。如果没有合适的进制，则输出 $0$。

## 说明/提示

$p,q,r$ 的所有位都是数字，并且 $1 \le p,q,r \le 10^6$。

## 样例 #1

### 输入

```
6 9 42```

### 输出

```
13```

# 题解

## 作者：红黑树 (赞：33)

## 做法：
既然要找最小满足要求的进制，那就从可能的最小的进制开始枚举
确定最小可能进制的代码如下
```cpp
inline int Min(string p, string q, string r) {
    char MIN = *max_element(p.begin(), p.end());
    MIN = max(MIN, *max_element(q.begin(), q.end()));
    MIN = max(MIN, *max_element(r.begin(), r.end()));
    // max_element() 返回给定区间中最大的元素
    // 到此为止，MIN 中存的东西就是 p, q, r 中 ASCII 码最大的字母了
    return MIN - '0' + 1; // 为什么是 MIN - '0' + 1 呢，比如 2 进制中不可能出现 2，3 进制中不可能出现 3
}
```
那么如何判断当前进制是否符合要求呢？
我的做法是将两个 $B$ 进制数转化为 $10$ 进制后相乘，得到的结果再转换成 $B$ 进制，与 $r$ 判断是否相等，~~其他进制乘法要重新写，有点麻烦~~

代码如下
```cpp
inline int B_to(int B, string n) { // n 从 B 进制转换到 10 进制
    int num = 0; // 初始化答案为 0
    reverse(n.begin(), n.end()); // 由于我们从 n 的开始枚举到 n 的末尾，需要把数组翻转一下，另一种解决方案是从末尾开始往头枚举
    for (int i = 0; i < n.size(); i++) {
        if (n[i] >= '0' && n[i] <= '9') // 如果当前这一位存的是 0 到 9
            num += pow(B, i) * (n[i] - '0'); // 位权 * 值
        else // 是字母
            num += pow(B, i) * (n[i] - 'A' - 10); // 位权 * 值
    }
    return num; // 返回计算好的答案
}

inline string TO_Be(int B, int n) {
    string num = ""; // 初始化 num 为空
    for (; n; n /= B) // 除以 B 相当于是在 B 进制中右移一位
        num.push_back(n % B); // % B 相当于取出 B 进制下的最低位
    reverse(num.begin(), num.end());
    for (auto& i : num) { // 扫描 num 数组
        (i >= 0 && i <= 9) ? i += '0' : i += 'A' - 10; // 如果 i 不是数字，要转换成字母
    }
    return num; // 返回计算好的答案
}
```
---
## 那么代码就出来了
```cpp
#include <iostream> // 提供 cin 和 cout
#include <algorithm> // 提供 reverse 函数 和 max_element 函数
#include <string> // string 类
#include <cmath> // pow 函数
// 此题需要开 long long 不然 90 分

using namespace std;

inline string TO_Be(int B, long long n) {
    string num = "";
    for (; n; n /= B)
        num.push_back(n % B);
    reverse(num.begin(), num.end());
    for (auto& i : num) {
        (i >= 0 && i <= 9) ? i += '0' : i += 'A' - 10;
    }
    return num;
}

inline long long B_to(int B, string n) {
    long long num = 0;
    reverse(n.begin(), n.end());
    for (int i = 0; i < n.size(); i++) {
        if (n[i] >= '0' && n[i] <= '9')
            num += pow(B, i) * (n[i] - '0');
        else
            num += pow(B, i) * (n[i] - 'A' - 10);
    }
    return num;
}

inline int Min(string p, string q, string r) {
    char MIN = *max_element(p.begin(), p.end());
    MIN = max(MIN, *max_element(q.begin(), q.end()));
    MIN = max(MIN, *max_element(r.begin(), r.end()));
    return MIN - '0' + 1;
}

int main() {
    string q, p, r;
    cin >> p >> q >> r;
    for (int B = Min(p, q, r); B < 17; B++) {
        long long pmq = B_to(B, p) * B_to(B, q); // 计算 10 进制乘积
        if (TO_Be(B, pmq) == r) { // 把计算好的乘积转换成 B 进制，然后判等
            cout << B; // 符合条件就输出 B
            return 0; // 结束程序
        }
    }
    cout << 0; // 如果所有进制都不行，按照题目要求输出 0
    return 0;
}
```

---

## 作者：ImposterAnYu (赞：31)

fixed：2021.8.23 修改了原代码中的错误。

# 题意
给定三个整数 $p$、$q$、$r$，求出一个最小的进制 $B$，使得 $p_{(B)} \times q_{(B)} = r_{(B)}$。

（如果无解，则输出 $0$。）
# 解析 + 坑点
这道题读入的是三个整数，但是为了更好地拆分整数，我们决定不走寻常路——读入三个字符串！

接着，我们需要写一个函数（暂命名为 achar），用来找出三个字符串值最高的一位，然后依次枚举 （$B = $ 这一位的值 + $1$）到 $B = 16$ 的情况，如果符合条件就输出。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,k;
char p[1005],q[1005],r[1005];
char c[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
int achar(char x[],char y[],char z[]){
    int pp = strlen(x),qq = strlen(y),rr = strlen(z),m = 0,n,i;
    for(i = 0; i < pp; i++){
        n = int(x[i] - 48);
        m = max(n,m);
    }
    for(i = 0; i < qq; i++){
        n = int(y[i] - 48);
        m = max(n,m);
    }
    for(i = 0; i < rr; i++){
        n = int(z[i] - 48);
        m = max(n,m);
    }
    return (c[m] - 48);
}
```
注意：如果不写/调用这个 achar 函数，你将会 WA #16！

同时，我们要在主函数里判断是否符合条件，一旦符合条件就输出，同时结束程序。

```cpp
int main(){
    cin >> p;
    cin >> q;
    cin >> r;
    k = achar(p,q,r);//调用那个函数。
    for(i = max(k + 1,2ll); i <= 16; i++){
        if(anyu(p,i) * anyu(q,i) == anyu(r,i)){
            cout<< i << endl;
            return 0;
        }
    }
    cout<< 0 << endl;
    return 0;
}
```
至于那个 anyu 函数是干什么用的呢？

其实这个函数是这样的：

`long long anyu(char s[],int b);`

函数的返回值是字符串 $s$ 代表的 $b$ 进制数转换成十进制后的结果。
```cpp
long long anyu(char s[],int b){
	int n = strlen(s);
	long long x = 0;
	for(int i = 0; i < n; i++){
		for(int j = 0; j <= 15; j++){ 
			if(s[i] == c[j]){
				x += j * pow(b,n - i - 1);
				break;
			}
		}
	}
	return x;
}
```
~~相信大家都知道如何转换进制吧？~~

那么这样一来，我们的 AC 代码也就出炉啦！

# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,k;
char p[1005],q[1005],r[1005];
char c[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
int achar(char x[],char y[],char z[]){//查找值最高那一位的值的函数。 
	int pp = strlen(x),qq = strlen(y),rr = strlen(z),m = 0,n,i;
	for(i = 0; i < pp; i++){
		n = int(x[i] - 48);
		m = max(n,m);
	}
	for(i = 0; i < qq; i++){
		n = int(y[i] - 48);
		m = max(n,m);
	}
	for(i = 0; i < rr; i++){
		n = int(z[i] - 48);
		m = max(n,m);
	}//依次查找。 
	return (c[m] - 48);
}
long long anyu(char s[],int b){
	int n = strlen(s);
	long long x = 0;
	for(int i = 0; i < n; i++){
		for(int j = 0; j <= 15; j++){ 
			if(s[i] == c[j]){
				x += j * pow(b,n - i - 1);
				break;
			}
		}
	}
	return x;
}
int main(){
	cin >> p;
	cin >> q;
	cin >> r;
	k = achar(p,q,r);//调用那个函数。
	for(i = max(k + 1,2ll); i <= 16; i++){//注意这里，i 不能直接从 1 开始！ 
		if(anyu(p,i) * anyu(q,i) == anyu(r,i)){
			cout<< i << endl;
			return 0;//符合条件就输出，然后就结束了。 
		}
	}
	cout<< 0 << endl;//无解时输出0. 
	return 0;
}
```

---

## 作者：int32 (赞：16)

## Description

给定整数 $p,q,r$，求最小的 $base$ 使得 $p_{(base)}\times q_{(base)}=r_{(base)}$。

$1\leq p,q,r\leq10^6$。

## Solution

我们令 $a_{(k)}$ 表示 $k$ 进制下的 $a$。

我们常用的进制是 $10$ 进制，乘法直接由 `*` 实现。但是在 $k$ 进制下的乘法 $(k\neq10)$ `C++` 库没有给我们实现。自己实现未免更加复杂。

于是我们考虑将 $k$ 进制下的 $p,q,r$ 转化成 $10$ 进制进行求解。

### 如何实现进制转换（$k$ 进制转 $10$ 进制）？

题目有给出例子，在这里我给出一个公式：

$$a_{(k)}=\sum_{i=1}^{r} n_i\times k^{i-1}.$$

其中 $r$ 是 $a$ 的数位个数（如 $123$ 有三个数位），$n_i$ 是**从右往左数**第 $i$ 个数位的值（如 $123$ 的 $n_3$ 就是 $1$）。

代码：

```cpp
//进制转换 (base->10)
int change(int a, int base){
	int res=0, i=0;
	while(a){
    	//a%10就是n_i
		res+=(a%10)*(int)(pow(base,i));
		++i;
		a/=10;
	}
	return res;
}
```

### 注意事项

可以注意到，在 $a_{(k)}$ 中，$n_i\ (1\leq i\leq r)$ 必须小于 $k$。

令 $p,q,r$ 的最大数位值分别为 $u,v,w$。

那么可以舍弃小于 $\max\{u,v,w\}$ 的 $k$，不做讨论。

至于如何找最大数位，见代码：

```cpp
//找一个数最大数位的值
int pos(int a){
	int res=0;
	while(a){
		res=max(res,a%10);
		a/=10;
		//因为p,q,r都是十进制数，所以 res=9 时不可能更大，返回值即可（参见楼上优化）
		if(res==9) break;
	}
	return res;
}
```

## Code

记得开 $\operatorname{long\ long}$。

请用 `C++11/14/17` 提交本代码。 

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int p, q, r;
//进制转换 (base->10)
int change(int a, int base){
	int res=0, i=0;
	while(a){
		res+=(a%10)*(int)(pow(base,i));
		++i;
		a/=10;
	}
	return res;
}
//找一个数最大数位的值
int pos(int a){
	int res=0;
	while(a){
		res=max(res,a%10);
		a/=10;
		//res=9 时不可能更大，返回值即可
		if(res==9) break;
	}
	return res;
}
signed main(){
	cin>>p>>q>>r;
	int t=max({pos(p),pos(q),pos(r)});//C++98没有这种写法
	for(int i=t+1;i<=62;i++)
		if(change(p,i)*change(q,i)==change(r,i))
			return cout<<i,0;
	puts("0");
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：16)

好家伙，这数据加强就改个 `long long` 就行了。
# 前置芝士
`to_string(int n)`：把 n 转成 `string`。

`reverse(iterator a, iterator b)`：将 a 到 b 的区间反转。

`pow(double a, double b)`：求 $a^b$
# 思路
枚举进制 $b$，把 $p,q,r$ 当成 $b$ 进制的数转十进制。怎么转呢？

我们知道，一个 $b$ 进制的数 $n$ 可以表示为：

$n_0b^0+n_1b^1+...+n_kb^k$ ( $n_i$ 表示 $n$ 的第 $i$ 位，从 $0 $ 开始，$k$ 为 $n$ 的位数)

可以用`to_string`把 $n$ 转成 `string` 来获得 $n$ 的每一位。

注意转成 `string` 后是高位在前的，所以要 `reverse` 一下。

而且 $n$ 的每一位一定是小于 $b$ 的，所以要从 $p,q,r$ 中最大的一位 $+1$ 开始枚举。

求 $n$ 最大的一位，也可以用 `to_string` 获得每一位，找最大值。
# 代码
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cmath>
#define int long long
using namespace std;
int bto10(int b, int n)
{
    string s = to_string(n);
    int k = s.length(), r = 0;
    reverse(s.begin(), s.end());
    for(int i = 0;i < s.length();++i)
        r += (s[i] - '0') * pow(b, i);
    return r;
}
int maxbit(int n)
{
    string s = to_string(n);signed r = 0;
    for(int i = 0;i < s.length();++i)
        r = max(r, s[i] - '0');
    return r;
}
int p, q, r, t;
signed main()
{
    cin >> p >> q >> r;
    t = max(max(maxbit(p), maxbit(q)), maxbit(r));
    for(int b = t + 1;b <= 16;++b)
    {
        if(bto10(b, p) * bto10(b, q) == bto10(b, r))
        {
            cout << b;
            return 0;
        }
    }
    cout << 0;
    return 0;
}
```


---

## 作者：囧仙 (赞：14)

> $\text{upd 2021.8.22}$ 修正了错误的代码。

## 题目大意

> 给定 $p,q,r$ ，确定一个进制使得 $p\times q=r$ 。

## 题解

题目中有一个条件： $p,q,r$ 上的字符都是整数。因此，我们大可不必考虑烦人的字母（比如十六进制下有 $\verb!ABCDEF!$ 这几个字母）。当我们**直接**读入 $p,q,r$ 后，它就是以十进制的形式被读入的。我们提取它的每一位，也是要以十进制的方式提取（即每次除以 $10$ ，余数即为当前的最后一位）。

考虑一个进制 $B$ 合法的条件。首先它应该大于 $p,q,r$ 中出现的所有数字，然后我们要做的就是将 $p,q,r$ 在字面上以 $B$ 进制的形式转化。（可能听起来有点晦涩，其实意识是把读入的东西（相当于字符串）转化为 $B$ 进制）。

以 $p$ 举例：我们枚举它的每一位，其中第 $i$ 位乘上 $B^i$ ，再求和，就可以计算出他被转化为 $B$ 进制的样子了。

如法炮制，分别将 $p,q,r$ 转化成 $a,b,c$ ，然后判断是否 $a\times b=c$ 就能判断 $B$ 是否合法。我们从小到大枚举每个 $B$ 即可。

---

要注意的是，虽然题目上写出了 $p,q,r\le 10^6$ ，但是将其转化为 $B$ 进制后可能相乘超过 $\text{int}$ 。例如，当 $p=q$ 的字面量为 $1000000$ 时，转化为 $16$ 进制后值就变成了 $16,777,216$ ，再相乘会超过 $\text{int}$ 的最大值 $2^{31}-1$ 。因此，该题中我们需要使用 $\text{long long}$。


## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
i64 p,q,r,o,pp,qq,rr,s;
int main(){
    scanf("%d%d%d",&p,&q,&r);
    pp=p,qq=q,rr=r;
    while(pp) s=max(s,pp%10),pp/=10;
    while(qq) s=max(s,qq%10),qq/=10;
    while(rr) s=max(s,rr%10),rr/=10;
    up(s+1,16,t){
        pp=p;i64 a=0; o=1; while(pp) a+=o*(pp%10),o*=t,pp/=10;
        qq=q;i64 b=0; o=1; while(qq) b+=o*(qq%10),o*=t,qq/=10;
        rr=r;i64 c=0; o=1; while(rr) c+=o*(rr%10),o*=t,rr/=10;
        if(a*b==c) printf("%d\n",t),exit(0);
    }
    puts("0");
    return 0;
}
```

---

## 作者：lin000 (赞：12)

[B2141](https://www.luogu.com.cn/problem/B2141)

### 分析

非常显然，我们可以先假设进制是 $i$ 然后从大到小模拟,将三个数 $i$ 进制的转换为十进制的数(计算机好进行运算)，如果 $p \times q = r$ 成立，就输出 $i$;

**但是**如果进制与给出的 $p$，$q$，$r$ 不符合，我们就得要先把$i$的起始位置处理一下。即找到它们中最大的一位数再加一，因为 $i$ 进制的某一位最多是 $i-1$。

**进制转换** 

将 $i$ 进制的数转换为十进制，只需要将第 $j$ 位的数字 $a_j \times i^{j -1}$ 再求总和即可。 如：$61_{(7)} = 6 \times 7^1 + 1 \times 7^0 = 43_{(10)}$。


------------
### Code
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cmath>

using namespace std;

string p , q , r;
long long change(string s , int num){
	int r = s.length();
	long long sum = 0;
	for(int i = 0 ; i < r ; i++){
		sum += (s[i] - '0') * pow(num , r - i - 1);
	}
	return sum;
}

int get_max(string s){
	char m = '0';
	for(int i = 0 ; i < s.length() ; i++){
		m = max(s[i] , m);
	}
	return m - '0';
}

int main(){
	cin >> p >> q >> r;
	int h = 1;
	int m = max(get_max(p) , max(get_max(q) , get_max(r)));
	for(int i = m + 1 ; i <= 16 ; i++){
		long long  p1 = change(p , i);
		long long q1 = change(q , i);
		long long r1 = change(r , i);
		if(p1 * q1 == r1){
			cout << i; 
			h = 0;
			break;
		}
	} 
	if(h)
		cout << 0;
	return 0;
}
```



---


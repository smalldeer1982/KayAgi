# [AHOI2024 初中组 / 科大国创杯初中组 2024] 立方根

## 题目背景

**本题的数据不是官方数据。**

**本题征集（能够上传到这里的）官方数据。**

**（没法上传到这里的）官方数据：<https://www.luogu.com.cn/training/499869>**

**本题民间数据下载：<http://8.136.99.126/blog/3/67f0c2307aadac7b413b837b>**

**特别提示：**

1. 请使用 `(int) cbrt(x + 0.5)` 计算 $\lfloor \sqrt[3]{x} \rfloor$ 的值，否则可能会出现精度误差。
2. 本题包含两组针对时间复杂度为 $O(q\sqrt[3]{x})$ 的算法的 hack 数据（#11 和 #12）。

## 题目描述

小可可想计算所有不大于 $x$ 的正整数的立方根下取整之和，但是她不会做，你能帮帮她吗？

为了彻底帮小可可弄懂这个问题，你需要回答 $q$ 组询问，对于每组询问给定的一个正整数 $x_i$，输出：

$$\sum _{j=1} ^{x_i} \lfloor j^{\frac{1}{3}} \rfloor$$

其中，$\lfloor x \rfloor$ 表示不大于 $x$ 的最大整数。

## 说明/提示

### 样例 1 解释

$1 \sim 10$ 的立方根下取整的结果是：$1,1,1,1,1,1,1,2,2,2$。

### 数据范围

对于 $20\%$ 的数据，$x_q,q \le 1000$。

对于另外 $20\%$ 的数据，$q=1$。

对于另外 $20\%$ 的数据，$q \le 5000$。

对于另外 $20\%$ 的数据，$q \le 10^5$，$x_q \le 10^6$。 

对于 $100\%$ 的数据，$1 \le q \le 2 \times 10^5$，$1 \le x_1 \le x_2 \le \ldots \le x_q \le 10^{12}$。

## 样例 #1

### 输入

```
2
5
10```

### 输出

```
5
13```

# 题解

## 作者：abc1856896 (赞：13)

# 题目大意

给定 $t$ 个 $x_i$，输出：

$$\sum _{j=1} ^{x_i} \lfloor j^{\frac{1}{3}} \rfloor$$

$x_i$ 满足单调递增。

## 错误解法
我们可以先预处理出完全立方数，再每次从 $\bm 1$ 开始计算即可。

代码

```cpp
#include <bits/stdc++.h>
#define int long long 
#define mod 998244353
#define MAX_X 10000
using namespace std;
int a [MAX_X+5] ;
void init () {
	for ( int i = 1 ; i <= 10000 ; i++) {
		a [i] = ( i * i * i ); 
	}
	return ; 
}
void solve () {
	int x ;
	cin >> x;
	int ans=0,i=1;
	for ( ; i <= 10000 ; i++){
		if( a[i] > x) {
			break ;
		}
		ans += ( a[i] - a[ i - 1] ) * (i - 1);
	}
	cout << ans + (i - 1) * (x - a [i - 1] + 1) << "\n" ;
}
signed main () {
	init () ;
	int T;
	cin >> T ;
	while( T-- ){
		solve() ;
	}
	return  0 ;
}

```

这份代码的时间复杂度为 ${O(q\sqrt[3]{x})}$，只能拿 $70$ 分。

## 正解

考虑优化。从上面的代码我们可以知道超时的原因是每次从 $\bm 1$ 开始枚举。而结合题目我们可以知道 **$x_i$ 单调递增**。所以我们可以从上一次的 $p$ 开始枚举即可。

代码

```cpp
#include <bits/stdc++.h>
#define int long long 
#define mod 998244353
#define MAX_X 10000
using namespace std;
int a [MAX_X+5] ;
void init () {
	for ( int i = 1 ; i <= 10000 ; i++) {
		a [i] = ( i * i * i ); 
	}
	return ; 
}
int i = 1 , ans = 0;
void solve () {
	int x ;
	cin >> x;
	for ( ; i <= 10000 ; i++){
		if( a[i] > x) {
			break ;
		}
		ans += ( a[i] - a[ i - 1] ) * (i - 1);
	}
	cout << ans + (i - 1) * (x - a [i - 1] + 1) << "\n" ;
}
signed main () {
	init () ;
	int T;
	cin >> T ;
	while( T-- ){
		solve() ;
	}
	return  0 ;
}

```

增加了这个优化的效率非常高，每个测试点都在 $191ms$ 内解决。

---

## 作者：2021zjhs005 (赞：9)

以下设设 $f(i)$ 表示 $\sum_{i=1}^x \lfloor i^{\frac{1}{3}}\rfloor$。

我们不妨将 $n$ 个元素分成若干个块，块 $i$ 内的元素为 $i^3\sim (i+1)^3 - 1$。

那么块 $i$ 的左端点 $l_i$ 为 $i^3$，右端点 $r_i$ 为 $(i+1)^3 - 1$，总和为 $(r_i - l_i + 1)\times i$。

块的个数为 $\sqrt[3]{10^{12}} = 10^4$。
```cpp
inline void build(){
  num = 10000;
  rep(i,1,num)
   l[i] = i * i * i ,
   r[i] = (i + 1) * (i + 1) * (i + 1) - 1 ,
   sum[i] = (r[i] - l[i] + 1) * i ;
}
```


------------

由于 $x_i$ 是呈**严格不下降**的，即为 $f(x_i)$ 为 $ans$，那么 $f(x_{i + 1})$ 一定大于等于 $ans$，也就是说可以不重复劳动。

我们通过类似滑动窗口的方式累加完整块。

但是可能又零碎的元素和没有累加。

那就直接加上 $(x - l_i + 1)\times i$（已经移动过）就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/mxg6tm6x.png)

时间复杂度最多为 $\Theta(Q  + N)$，$N$ 为块的总数，不会超。

```cpp
int i = 1;//当前为块 1。
while(Q --){
  int x = read();
  while(r[i] < x) ans += sum[i++];//块内不包含 x，累加块内总和，跳到下一个块。
  pr("%lld\n",ans + (x - l[i] + 1) * i);//加上零碎和。
}
```


完整代码。
------------
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rrep(i,x,y) for(int i=x;i>=y;i--)
#define sc scanf
#define pr printf

inline int read(){int s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}

const int N = 10005;
int Q,num,ans,l[N],r[N],sum[N];

inline void build(){
  num = 10000;
  rep(i,1,num)
   l[i] = i * i * i ,
   r[i] = (i + 1) * (i + 1) * (i + 1) - 1 ,
   sum[i] = (r[i] - l[i] + 1) * i ;
}

signed main(){
  Q = read();
  build();
  int i = 1;
  while(Q --){
    int x = read();
    while(r[i] < x) ans += sum[i++];
    pr("%lld\n",ans + (x - l[i] + 1) * i);
  }
  return 0;
}
```

---

## 作者：zzx114514 (赞：8)

# 题目大意
给定正整数 $x$，求
$$\sum_{i=1}^x\left \lfloor \sqrt[3]{x}  \right \rfloor $$
其中 $1\le x\le 10^{12}$。
# 解题思路
暴力显然会炸，考虑数学推导。
## 推导过程
为方便起见，以下设 $a=\left \lfloor \sqrt[3]{x}  \right \rfloor$，所有能使 $\left \lfloor \sqrt[3]{n}  \right \rfloor=a$ 的 $n$ 属于第 $a$ 段区间，第 $a$ 段区间内所有数的立方根向下取整之和定义为 $f(a)$。


------------

显然，第 $a$ 段区间内，有 $a^3\le n\le(a+1)^3-1$。  

先算 $\sum_{i=1}^af(i)$。   

第 $a$ 段区间内共有 $(a+1)^3-1-a^3+1=(a+1)^3-a^3$ 个数，$f(a)=(a+1)^3\cdot a-a^3\cdot a$。  

同理，第 $a-1$ 段区间内有 $a^3-(a-1)^3$ 个数，$f(a-1)=a^3\cdot(a-1)-(a-1)^3\cdot(a-1)$。   

由此一路推下来，得到
$$\sum_{i=1}^af(i)=(a+1)^3\cdot a-a^3\cdot a+a^3\cdot(a-1)-(a-1)^3\cdot(a-1)+\cdots+2^3\times1-1^3\times1+1^3\times0-0^3\times(-1)$$
$$=(a+1)^3\cdot a-a^3-(a-1)^3-\cdots-2^3-1^3$$
我们知道自然数立方和公式为
$$\sum_{i=1}^n i^3=\frac{n^2(n+1)^2}{4}$$
不知道的看[这里](https://zhuanlan.zhihu.com/p/260139435?utm_id=0)。  

因此原式可化为
$$(a+1)^3\cdot a-\frac{a^2(a+1)^2}{4}$$
$$=a^4+3a^3+3a^2+a-\frac{a^4+2a^3+a^2}{4}$$
$$=\frac{3a^4+10a^3+11a^2+4a}{4}$$
然后我们发现我们多加了一部分，即 $[x+1,(a+1)^3-1]$，因此我们要把它们减掉。 

减掉的部分大小为
$$[(a+1)^3-1-x-1]\cdot a$$
$$=a^4+3a^3+3a^2-ax$$
因此正确答案为
$$\frac{3a^4+10a^3+11a^2+4a}{4}-(a^4+3a^3+3a^2-ax)$$
$$=\frac{-a^4-2a^3-a^2+4a+4ax}{4}$$
推导完毕。
## 注意事项
不能直接用 `(int) cbrt(x)` 或 `(int) pow(x, 1.0 / 3)` 计算 $a$，因为有误差，这一点在题目背景里已讲到，你可以选择用 `(int) pow(x, 1.0 / 3)` 或 `(int) pow(x + 0.5, 1.0 / 3)` ~~或手写实数二分~~。
# 完整代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll q,x,a;
int main()
{
	cin>>q;
	for (int i=1;i<=q;i++)
	{
		cin>>x;
		a=(int)cbrt(x+0.5);
		cout<<(-a*a*a*a-2*a*a*a-a*a+4*a+4*a*x)/4<<endl;
	}
	return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：6)

由于本人能力有限，这里只提供一种数学的方法。

请把以下的 $n$ 理解为题目中的 $x_i$。

很容易知道，对于任意的 $i(i\ge 1)$，$i^3$ 至 $(i+1)^3-1$ 这些数的三次方根向下取整，均等于 $i$。如 $1$ 至 $7$ 均为 $1$，$8$ 至 $26$ 均为 $2$，等等。

令 $t$ 为 $n$ 的三次方根向下取整。

先求解整块的部分：我们可以先把前面这些 $1\sim 7$、$8\sim26$ 一直到 $(t-1)^3\sim t^3-1$ 这几部分都算出来，乘上它们的权值再相加。

然后求解零碎的部分，即
$$t\times (n-t^3+1)$$
用数学写还是太抽象了。我们举个具体例子。

拿 $28$ 来说，我们应该先求解前面整块的和，即 $1$ 至 $7$ 分别乘 $1$、$8$ 至 $26$ 分别乘 $2$。零碎的就应该是 $27$ 至 $28$ 分别乘 $3$，即为 $(28-27+1)\times 3$。

我们回到求整块的和，应该为
$$\begin{aligned}\sum_{i=1}^{t-1}i\times[(i+1)^3-i^3]&=\sum_{i=1}^{t-1}(3i^3+3i^2+i)\\&=(3\sum_{i=1}^{t-1}i^3)+(3\sum_{i=1}^{t-1}i^2)+(\sum_{i=1}^{t-1}i)\\&=\frac{3}{4}t^2(t-1)^2+\frac{1}{2}t(t-1)(2t-1)+\frac{1}{2}t(t-1)\end{aligned}$$
这个式子不用简化，直接放到代码里即可。

把这个式子再加上前面的零碎的部分，就是答案了。

有一个小细节，就是 C++ 中的 pow 函数容易出现精度问题，需要手动修复一下。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n;
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        ll l=pow(n,1.0/3);
        if(l*l*l<n&&(l+1)*(l+1)*(l+1)<=n) l++;
        else if(l*l*l>n) l--;
        ll a=(l-1)*(l-1)*l*l*3/4;
        ll b=(l-1)*l*(2*l-1)/2;
        ll c=l*(l-1)/2;
        ll d=(n-l*l*l+1)*l;
        cout<<a+b+c+d<<'\n';
    }
    return 0;
}
```

---

## 作者：xyx404 (赞：4)

## 思路：


先通过此程序列出部分立方根向下取整的情况。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long s[20000000];
long long jia(long long x,long long y){
	long long sum=0;
	for(int i=x+1;i<=y;i++)sum+=cbrt(i);
	return sum;
}
int main(){
	long long x,y=0;
	long long last=0,las=0;
	for(int i=1;i<=1e6;i++){
		s[i]=s[i-1]+cbrt(i);
		if(s[i]-s[i-1]!=last)cout<<i<<" "<<s[i]<<"\n",last=s[i]-s[i-1];
	}
		
	
	return 0;
}

```
可以发现每次当 $i$ 为某数的立方时，立方根向下取整的结果会增加一。

所以我们可以定义一个变量 $l$ 表示现在历遍的立方根，这样我们就不用从一历遍到十的十二次方了，只用历遍到十的十二次方的立方根了。

然后是如何计算，第一，当 $l+1$ 的立方也就是下一个立方的值大于我们输入的 $x+1$ 时，我们取较小的数，第二，当 $l$ 的立方也就是现在的立方的值大于上一个输入的 $x$ 的值时，我们在两个数取较大值，然后将 $l+1$ 的立方和 $x+1$ 的较小值与 $l$ 的立方和上一个 $x$ 的较大值相减，这样子做是为了防止多算和少算，然后总和加上就行了，循环条件是 $l$ 的立方小于等于现在的 $x$。 


## 代码：

代码中的注释和思路里写的是一样的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long// 无根号 long long 
ull T,x,l;
ull f(ull n){// 计算立方 
	return n*n*n;
}
int main(){
	cin>>T;
	ull l=1,sum=0,last=0;
	for(ull i=1;i<=T;i++){
		cin>>x;
		while(f(l)<=x){//也可以改成 for 循环
			sum+=l*((min(f(l+1),x+1))-max(f(l),last+1));
			//f(l+1) 是下一个立方的值与 x+1 取最小值约等于特判了如果下一个立方大于 x 的情况 
			//max(f(l),last+1) 是取现在的立方的值与上一个的 x+1（last+1） 中的最大值
			//min((l+1)*(l+1)*(l+1),x+1))-max(l*l*l,last+1) 是为了防止少算和多算 
			l++;// 每次 l++ 
		}
		l--;// 因为最后一次 ++ 的 l 是不满足的没有计算所以要 --
		cout<<sum<<"\n";// 输出
		last=x;// 赋值 
	}
	return 0;// return 好习惯听说比赛里没有爆 0
}
```

---

## 作者：_zuoqingyuan (赞：3)

[传送门。](https://www.luogu.com.cn/problem/P10373)

# 题意简述
给定 $q$ 个询问，每个询问给出 $x_i$，试求出：

$$\sum\limits_{i=1}^{x_i}\lfloor\sqrt[3]{i}\rfloor$$

题目保证 $1\le x_i\le 10^{12}$，且 $x_i$ 单调递增。

# 思路分析

对于这道题，我们要用逆向思维。

思考一个问题，如果已知 $g$。试求出 $[l,r]$，使得任意 $n\in [l,r]$ 都有 $\lfloor\sqrt[3]{n}\rfloor=g$。

显然，最小的满足 $\lfloor\sqrt[3]{n}\rfloor=g$ 的 $n=g^3$。由此可以推出 $l=g^3,r=(g+1)^3-1$。

想到这里，这道题就好办多了，我们枚举 $g$，然后计算其对应的 $l,r$。这一部分的和就是 $(r-l+1)\times g$。因为题目中保证 $x_i$ 单调递增，我们可以在上一个询问的基础上继续枚举。

由于 $x_i\le 10^{12}$。时间复杂度 $O(\sqrt[3]{V} )$。其中 $V$ 是值域上界，用计算器可以算出，极限情况下的计算次数大约在 $10^4$。

# Code
代码很好写，不加快读只有 300B 左右。
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;//应该要开longlong
ll q,x,l,r,t,sum;
int main(){
    scanf("%lld",&q);
    while(q--){
        scanf("%lld",&x);
        while(r<x)sum+=(r-l+1)*t,t++,l=t*t*t,r=(t+1)*(t+1)*(t+1)-1;//注意细节
        printf("%lld\n",sum+(x-l+1)*t);//注意细节
    }
    return 0;
}
```

如有错误，请指出。

---

## 作者：2021sunzishan (赞：3)

本篇题解的代码已经通过了本题，放心食用。

题意非常明确，我们直接看思路。

## 思路：
首先是一个基本的问题，怎么求 $n$ 的立方根呢？

因为 $n$ 的立方根具有单调不减的特点，及若 $n$ 增大，它的立方根不会比之前小。所以我们可以用二分求出。因为 $n\le  10^{12}$，所以 $n$ 的立方根 $\le10^4$。时间复杂度非常好看。

然后我们考虑 $i^3+1$ 到 $j^3$ 的立方根和 $s$（$i<j$），很容易推出 $s$ 的值为 $j^3$ 和 $i^3$ 的差乘上 $j$，因为这个区间里所有的数的立方根都是 $j$。

所以我们把 $1\sim n$ 的立方根分为两部分。我们设 $n$ 的立方根是 $k$，那么这两部分就是 $1\sim k^3-1$ 和 $k^3\sim n$。前者可以用前缀和求，后者单独算一下就行。

以上就是本题的思路了，如果还是不懂就看看代码吧！

**切勿抄袭！！！**
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//要开long long
#define N 10005
int t;
int s[N];//前缀和数组
inline int read(){
	int a=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*f;
}
main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	for(int i=1;i<=1e4;i++){
		int k=i*i*i,k1=(i+1)*(i+1)*(i+1);
		s[i]=(k1-k)*i,s[i]+=s[i-1];//s[i]表示1~(i+1)^3-1的前缀和
	}
	t=read();
	while(t--){
		int n=read();
		int l=1,r=1e4,k=0;//k是n的立方根
		while(l<=r){//二分求k
			int mid=(l+r)/2;
			if(mid*mid*mid<=n)
				k=mid,l=mid+1;
			else
				r=mid-1;
		}
		int ans=s[k-1];//第一部分
		int k1=k*k*k;
		ans+=(n-k1+1)*k;//第二部分
		printf("%lld\n",ans);
	}
	return 0;
}

```
完结~

---

## 作者：Dark_Star (赞：3)

# 题解：P10373 [AHOI2024 初中组] 立方根
## 题目大意
回答 $q$ 组询问，对于每组询问给定的一个正整数 $x_i$，输出：

$$\sum _{j=1} ^{x_i} \lfloor j^{\frac{1}{3}} \rfloor$$

数据范围： 

$1 \le q \le 2 \times 10^5$，$1 \le x_1 \le x_2 \le \ldots \le x_q \le 10^{12}$。
## Part 1
直接模拟。

由于能拿到的分数太低，本蒟蒻不再赘述。
## Part 2
由于给出的 $x_1 \sim x_q$ 单调不降，可以考虑记录上一次的询问（记作 $last$）与答案（记作 $ans$），然后这个问题就变成了求：

$$ans + \sum _{j=last+1} ^{x_i} \lfloor j^{\frac{1}{3}} \rfloor$$

时间复杂度 $O(x_q)$，不足以通过本题，但好歹能拿点分了。（不包括求立方根的时间）

最后提醒一声，打代码的时候不开`long long`见祖宗！

$30$ 分代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define debug puts("QwQ.Please debug.");
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();return x*f;}
inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10|48);}
inline void writeln(int x){write(x),putchar('\n');}
inline void writesp(int x){write(x),putchar(' ');}
inline int lfg(int n){//立方根函数 
	int l=1,r=sqrt(n);
	while(l<=r){
		int mid=l+r>>1;
		if(mid*mid*mid>n)r=mid-1;
		else l=mid+1;
	}return r;
}signed main(){
	int q=read(),x,last=0,ans=0;//定义变量 
	for(int i=1;i<=q;i++){
		x=read();//读入 
		for(int j=last+1;j<=x;j++)ans+=lfg(j);//求比上次答案多出的部分 
		last=x;writeln(ans);//更新last，输出更新后的ans 
	}return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/156862616)。
## Part 3
可以发现，求 $\sum _{j=last+1} ^{x_i} \lfloor j^{\frac{1}{3}} \rfloor$ 时，还是可以再优化的。

我们发现，当 $j \ge a^3$ 并且 $j < (a+1)^3$ 时，$\lfloor j^{\frac{1}{3}} \rfloor = a$。

于是，我们可以将要求的区间分成几段来求，每一段的所有数的立方根下取整相同。详见代码。

时间复杂度 $O({x_q}^{\frac{1}{3}})$，可以通过本题。

$100$ 分代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define debug puts("QwQ.Please debug.");
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();return x*f;}
inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10|48);}
inline void writeln(int x){write(x),putchar('\n');}
inline void writesp(int x){write(x),putchar(' ');}
int cnt=1,lf[1000001];//定义立方数组，方便一点 
inline int lfgh(int l,int r){//立方根和函数 
	int tl=l,tr=lf[cnt+1],ans=0;//定义变量并处理区间 
	while(tr<=r)ans+=(tr-tl)*cnt,cnt++,tl=tr,tr=lf[cnt+1];//计算答案和下一个区间 
	tr=r;ans+=(tr-tl+1)*cnt;return ans;//补刀并返回（注意这里是封闭区间所以要+1） 
}signed main(){
	int q=read(),x,last=0,ans=0;//定义变量 
	for(int i=1;i<=1000000;i++)lf[i]=i*i*i;//立方数组赋初值 
	 for(int i=1;i<=q;i++){
		x=read();//读入 
		ans+=lfgh(last+1,x);//求比上次答案多出的部分 
		last=x;writeln(ans);//更新last，输出更新后的ans 
	}return 0;//AC撒花！ 
}
```

[提交记录](https://www.luogu.com.cn/record/156870374)。

制作不易，点个赞再走吧！

---

## 作者：39xiemy (赞：3)

## 题目大意

给出 $q$ 组数据，对于每组数据的 $x_i$，计算出 $\sum_{j=1} ^ {x_i} \lfloor j^{\frac{1}{3}} \rfloor$ 的值。

## 分析

首先直接考虑算出每个数的立方根向下取整后的值，但由于 $x$ 的值太大，是不能直接算的。再反向想，可以先预处理出 $10^{12}$ 以内的正整数的立方，用一个数组 $c$ 来存储，$c_i$ 存储 $i$ 的立方，那么对于 $c_i \sim c_{i+1} - 1$ 范围的每个整数 $a_i$，$\lfloor \sqrt[3]{a_i} \rfloor$ 的值都是 $i$，注意**不包括 $\bm{c_{i+1}}$**。

现在对于每个询问 $x$，定义一个 $t = c_{\lfloor \sqrt[3]{x} \rfloor}$，将 $1 \sim x$ 的整数分为 $1 \sim t - 1$ 和 $t \sim x$ 两部分，要求出 $\lfloor \sqrt[3]{x} \rfloor$ 的值，可以直接用 `pow` 函数来求，但要**注意精度**，然后就可以直接算出第二部分。

然后要求出第一部分。既然 $x$ 无论何值，第一部分都是从 $1$ 开始，从 $c_i - 1$ 结束，那么在第一步预处理 $c$ 数组的时候，可以用一个前缀和数组直接算出来，最后将两部分加起来即可算出答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long q,x,c[10001],t,s[10001];
int main()
{
	for(long long i=1;i<=10000;i++)//众所周知，10^12的立方根是10^4
	{
		c[i]=i*i*i;
		s[i]=s[i-1]+(c[i]-c[i-1])*(i-1);//这个公式自己推一下
	}
	scanf("%lld",&q);
	for(int i=1;i<=q;i++)
	{
		scanf("%lld",&x);
		t=pow((long double)x,(long double)1/3); //开long double 才存的下精度
		printf("%lld\n",(x-c[t]+1)*t+s[t]);//(x-c[t]+1)*t是第二部分，s[t]是第一部分 
	}
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：3)

设 $f_i=\lfloor i^{\frac{1}{3}}\rfloor$，$a_i$ 为 $i$ 在 $f$ 中出现的次数（假设 $f$ 无限长），容易发现 $a_i=(i+1)^3-i^3$。对数组 $a$ 的每位 $\times i$（因为 $i$ 在 $f$ 中出现了 $a_i$ 次），再前缀和，每次先计算立方根，直接使用前缀和，最后直接计算剩下的长度不够的那段。

PS：十年 AHOI 一场空，不开 long long 见祖宗。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long q,x,a[10005],b[10005],k;
long long lfg(long long sum){
	long long l=1,r=10003,mid;
	while(1){
		mid=(l+r)/2;
		if(((mid*mid*mid)<=sum)&&(((mid+1)*(mid+1)*(mid+1))>sum))return mid;
		if((mid*mid*mid)>sum)r=mid-1;
		else l=mid+1;
	}
}
int main(){
	for(long long i=1;i<=10002;i++){
		a[i]=i*((i+1)*(i+1)*(i+1)-i*i*i);
		b[i]=b[i-1]+a[i];
	}
	cin>>q;
	while(q--){
		cin>>x;
		k=lfg(x);
		cout<<b[k-1]+(x-k*k*k+1)*k<<endl;
	}
	return 0;
}
```

---

## 作者：Hulless_barley (赞：2)

[P10373 [AHOI2024 初中组] 立方根](https://www.luogu.com.cn/problem/P10373)

定义一个 $sum$ 数组，其中 $sum_i=\sum_{j=1}^{i^3}\sum _{k=1} ^{j} \lfloor k^{\frac{1}{3}} \rfloor$。

可以轻松得到状态转移方程 $sum_i\gets sum_{i-1}+i\times((i+1)^3-i^3)$。然后我们化简 $((i+1)^3-i^3)$，设其为 $x$，根据立方差公式 $a^3-b^3=(a-b)(a^2+ab+b^2)$ 和完全平方和公式 $(a+b)^2=a^2+2ab+b^2$，得到：

$$\begin{aligned} x&=(i+1-i)((i+1)^2+i(i+1)+i^2)\\&=(i+1)^2+i^2+i+i^2\\&=i^2+2i+1+2i^2+i\\&=3i^2+3i+1\end{aligned}$$

所以状态转移方程是 $sum_i\gets sum_{i-1}+i\times(3i^2+3i+1)$。

接下来 $O(1)$ 询问，对于每个 $x_i$，只需要输出 $sum_{\lfloor x_i^\frac{1}{3}\rfloor-1}+\lfloor x_i^\frac{1}{3}\rfloor\times(n-\lfloor x_i^\frac{1}{3}\rfloor^3)$。

赛时代码是这样的：
```cpp
#include<bits/stdc++.h>
#define p3(a) (a*a*a)
#define lfc(n,m) ((n-m)*(n*n+n*m+m*m))
#define xllfc(n) (3*n*(n+1)+1)
using namespace std;
const int N = 1e4+5;
unsigned long long sum[N];
unsigned long long n,cn;
int main(){
	freopen("b.in","r",stdin);
	freopen("b.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	for(int i=1;i<=10000;i++)
		sum[i]=sum[i-1]+i*xllfc(i);
	int t;cin>>t;
	while(t--){
		cin>>n;
		cn=floor(cbrt(n));
		cout<<sum[cn-1]<<' '<<cn*(n-p3(cn)+1)<<' ';
		cout<<sum[cn-1]+cn*(n-p3(cn)+1)<<endl;
	}
	return 0;
}
```
可以看到，`cout<<sum[cn-1]<<' '<<cn*(n-p3(cn)+1)<<' '` 是调试的代码，我忘删了，爆零了（qwq）。然后我删了就 $30$ 分，原因是 `for` 循环预处理的时候变量 $i$ 没开 long long（qwq）。开了 long long 后只有 $70$ 分，原因是 `cbrt(n)` 精度不够（qwq）。

接下来是调了很久的正解。
```cpp
#include<bits/stdc++.h>
#define p3(a) ((a)*(a)*(a))
#define lfc(n,m) ((n-m)*(n*n+n*m+m*m))
#define xllfc(n) (3*n*(n+1)+1)
using namespace std;
const int N = 1e4+5;
long long sum[N],n,cn;
long long cbrt_floor(long long n){
	long long l=cbrt(n)-10,r=cbrt(n)+10,mid;
	//虽然 cbrt 精度不够，但是也大致正确，只需要在 cbrt(n) 周围找就行了，这里的 l、r 初值足够了
	//如果 l 初值为 0 也行，但是 r 不能为 n，不然会爆 long long
	while(l+1<r){//经典二分
		mid=l+r>>1;
		if(p3(mid)<=n)l=mid;
		else r=mid;
	}
	return l;
}
int main(){
//	freopen("b.in","r",stdin);
//	freopen("b.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	for(long long i=1;i<=10000;i++)
		sum[i]=sum[i-1]+i*xllfc(i);
	int t;cin>>t;
	while(t--){
		cin>>n;
		cn=cbrt_floor(n);//由于公式中 n 的立方根下取整很多，提前存一个
		cout<<sum[cn-1]+cn*(n-p3(cn)+1)<<endl;//没什么好说的，推理过了
	}
	return 0;
}
```

---

## 作者：GXZJQ (赞：2)

# P10373 [AHOI2024 初中组] 立方根 题解

[题目链接](https://www.luogu.com.cn/problem/P10373)

## 题目大意

给定一个正整数 $x$，求出不大于 $x$ 的所有正整数的立方根向下取整值的和，换成符号语言就是：

$$\sum_{j=1}^{x} \left \lfloor \sqrt[3]{j}  \right \rfloor $$


## 题目分析

一个好习惯，拿到题先看数据范围：

>$1 \le q \le 2 \times 10^5$，$1 \le x \le 10^{12}$

对于这道题来说，暴力做法肯定是不可行的了。那么我们就换一种做法：

首先，区间 $[1,10^{12}]$ 内的所有完全立方数是确定的，且只有 $10^{4}$ 个，所以我们不妨定义一个 $num$ 数组存储它们，$num[i]$ 表示第一个以 $i$ 为立方根的数：

```cpp
for (long long i = 1; i <= 1e4; i++) {
		num[i] = pow(i, 3);
}
```
那对于题目中要求的答案，我们该如何处理呢？我想到了之前学过的**前缀和**。从题目中我们可以知道，对于所有的 $x_1 < x_2$，$x_2$ 的答案序列中有一部分是和 $x_1$ 重合的，我们用 $sum[i]$ 表示第一个以 $i$ 为立方根的数之前的数的立方根向下取整值的和，则有一个递推式：

$$sum[i]=sum[i-1]+(i-1) \times (num[i]-num[i-1])$$

这个递推式是怎么来的呢？首先 $sum[i-1]$ 就是之前提到过的重叠的那一部分，$i-1$ 则是由 $sum$ 数组的定义产生的：

>$sum[i]$ 表示第一个以 $i$ 为立方根的数之前的数的立方根向下取整值的和

那么，假设现在 $i=3$，而 $27$ 是第一个以 $3$ 为立方根的数。那么在 $3$ 之前有一部分答案都是 $2$，有一部分答案都是 $1$，但 $1$ 的部分我们在求 $sum[2]$ 的时候已经计算过了，所以不用重新考虑。这样的话，$sum[3]$ 的值只需要将 $sum[2]$ 与那一段答案为 $2$ 的序列相加即可，而答案为 $2$ 的序列的长度恰好就是第一个以 $3$ 为立方根的数与第一个以 $2$ 为立方根的数之间的距离，也就是 $num[3]-num[2]$。将它推广到普适的情况，就有了之前我们推出的式子，也就是预处理的第二部分：

```cpp
for (long long i = 1; i <= 1e4; i++) {
		sum[i] = sum[i - 1] + (i - 1) * (num[i] - num[i - 1]);
}
```
这里要注意一点，循环里 $i$ 一定要开 `long long`，否则的话可能会出错。

到这里，对于每个输入的 $x$，我们就只需要找到比 $x$ 小且尽可能大的一个数 $m$，记 $\left \lfloor \sqrt[3]{m}  \right \rfloor$ 为 $k$，输出 $sum[k]$ 加上 $m$ 到 $x$ 之间这一段的答案值（也就是 $k \times (x - num[k] + 1)$）即可。

然后，就到了这道题最坑的一个环节：精度问题。

正如题目背景里所说的，不要尝试用 `cbrt(x)` 和 `pow(x,1.0/3)` 来求立方根，所以我就手写了一个求立方根的函数：

```cpp
int find(long long x) {
	int l = 1, r = 1e4;
	int ans;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (num[mid] <= x) {
			ans = mid;
			l = mid + 1;
		} else r = mid - 1;
	}
	return ans;
}
```
这样的话，就不会因为精度问题出错了。


当然，这里还有一种写法，使用库函数 `upper_bound` 可以更加快速地求出 $k$ 的值。因为之前我们已经把 $[1,10^{12}]$ 内所有的完全立方数都求出来了，所以对于输入的 $x$，只需要求出第一个比 $x$ 大的完全立方数 $m$，再将 $m$ 的立方根减 $1$ 就是 $x$ 的立方根了。
## 参考代码
#### 手写求立方根函数：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e4 + 10;
long long q, x;
long long num[maxn], sum[maxn];
inline long long read() {
	long long i = 0;
	long long xi = 1;
	char c;
	for (c = getchar(); (c != 45) && (c < 48 || c > 57); c = getchar());
	if (c == 45) {
		c = getchar();
		xi = -1;
	}
	for (; c >= 48 && c <= 57; c = getchar()) {
		i = (i << 3) + (i << 1) + c - 48;
	}
	return xi * i;
}
void write(long long x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) {
		write(x / 10);
	}
	putchar(x % 10 + 48);
	return;
}
int find(long long x) {  // 二分查找k
	int l = 1, r = 1e4;
	int ans;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (num[mid] <= x) {
			ans = mid;
			l = mid + 1;
		} else r = mid - 1;
	}
	return ans;
}
void prepare() {
	for (long long i = 1; i <= 1e4; i++) {
		num[i] = pow(i, 3);
	}
	for (long long i = 1; i <= 1e4; i++) {
		sum[i] = sum[i - 1] + (i - 1) * (num[i] - num[i - 1]);
	}
}
int main() {
	prepare();
	q = read();
	while (q--) {
		x = read();
		int k = find(x);
		long long ans = sum[k] + k * (x - num[k] + 1);
		write(ans);
		puts("");
	}
	return 0;
}
```
[提交记录1](https://www.luogu.com.cn/record/156893849)

#### 库函数 `upper_bound`：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e4 + 10;
long long q, x;
long long num[maxn], sum[maxn];
inline long long read() {
	long long i = 0;
	long long xi = 1;
	char c;
	for (c = getchar(); (c != 45) && (c < 48 || c > 57); c = getchar());
	if (c == 45) {
		c = getchar();
		xi = -1;
	}
	for (; c >= 48 && c <= 57; c = getchar()) {
		i = (i << 3) + (i << 1) + c - 48;
	}
	return xi * i;
}
void write(long long x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) {
		write(x / 10);
	}
	putchar(x % 10 + 48);
	return;
}
int find(long long x) {  // 二分查找k
	int l = 1, r = 1e4;
	int ans;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (num[mid] <= x) {
			ans = mid;
			l = mid + 1;
		} else r = mid - 1;
	}
	return ans;
}
void prepare() {
	for (long long i = 1; i <= 1e4; i++) {
		num[i] = pow(i, 3);
	}
	for (long long i = 1; i <= 1e4; i++) {
		sum[i] = sum[i - 1] + (i - 1) * (num[i] - num[i - 1]);
	}
}
int main() {
	prepare();
	q = read();
	while (q--) {
		x = read();
		int k = upper_bound(num + 1, num + 10000 + 1, x) - num - 1;
		long long ans = sum[k] + k * (x - num[k] + 1);
		write(ans);
		puts("");
	}
	return 0;
}
```
[提交记录2](https://www.luogu.com.cn/record/156893899)

---

## 作者：lailai0916 (赞：1)

## 原题链接

- [洛谷 P10373 [AHOI2024 初中组] 立方根](https://www.luogu.com.cn/problem/P10373)

## 解题思路

令：

$$
t=\left\lfloor \sqrt[3]x \right\rfloor
$$

则：

$$
\begin{aligned}
\sum_{j=1}^x \left\lfloor j^{\frac{1}{3}} \right\rfloor &= \sum_{i=1}^x \left\lfloor \sqrt[3]j \right\rfloor \\
  &= \sum_{j=1}^{t^3-1} \left\lfloor \sqrt[3]j \right\rfloor + \sum_{j=t^3}^{x} \left\lfloor \sqrt[3]j \right\rfloor \\
  &= \sum_{i=1}^{t-1} \sum_{j=i^3}^{(i+1)^3-1} \left\lfloor \sqrt[3]j \right\rfloor + \sum_{j=t^3}^{x} \left\lfloor \sqrt[3]j \right\rfloor \\
  &= \sum_{i=1}^{t-1} \sum_{j=i^3}^{(i+1)^3-1} i + \sum_{j=t^3}^{x} t \\
  &= \left ( \sum_{i=1}^{t-1} \left((i+1)^3-i^3\right) \cdot i \right ) + (x-t^3+1) \cdot t \\
  &= \left ( \sum_{i=1}^{t-1} 3i^3+3i^2+i \right ) + (x-t^3+1) \cdot t \\
  &= \frac{3}{4} t^4- \frac{1}{2} t^3 -\frac{1}{4} t^2-t^4+(x+1) \cdot t \\
  &= (x+1) \cdot t - \frac{t^4+2t^3+t^2}{4}
\end{aligned}
$$

由于 `cbrt(x)` 或 `pow(x,1.0/3)` 可能会有精度误差，可以手写二分开立方根。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
ll cube_root(ll x)
{
	ll l=0,r=100000;
	while(l<r)
	{
		ll mid=l+r>>1;
		if(mid*mid*mid>x)r=mid;
		else l=mid+1;
	}
	return l-1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int q;
	cin>>q;
	while(q--)
	{
		ll x;
		cin>>x;
		ll t=cube_root(x);
		cout<<(x+1)*t-(t*t*t*t+2*t*t*t+t*t)/4<<'\n';
	}
	return 0;
}
```

---

## 作者：_Warfarin_ (赞：1)

### 思路分析
~~不难发现暴力肯定过不了~~  
所以，我们再来观察数据。题干中有一句话很重要，保证给出的 $ x_{1} \to x_{q} $ 单调不降。
 所以我们就考虑每次计算后不再从头开始计算，而是直接从上次继续接着计算。
 
 ### 注意事项
 · 开立方根不要用 ``` cbrt ``` 和 ``` （int）sqrt(x,1.0/3)``` .
 
 ### AC代码
 ```
 #include <bits/stdc++.h>

#define ll long long
#define io cin.tie(0),cout.tie(0),ios::sync_with_stdio(false)
#define ri register int
#define lb long double

using namespace std;
const int N = 114514;
vector<ll> a;
ll sum = 0;
ll i = 0;
inline void work(ll x)
{
	for (; i < a.size() && a[i + 1] <= x; i++)
	{
		sum += (i + 1) * (a[i + 1] - a[i]);
	}
	ll ans = sum + (i + 1) * (x - a[i] + 1);
	cout << ans << endl;
	return ;
}
inline void intt()
{
	for (ri i = 1; i<=114514; i++)
	{
		a.push_back(pow(i, 3));
	}
}
int main()
{
	io;
	intt();
	ll t;
	cin >> t ;
	for (ri i = 1; i <= t; i++)
	{
		ll x;
		cin >> x;
		work(x);
	}

	return 0;
}

```

---

## 作者：xiezheyuan (赞：1)

首先发现，$f(x)=\lfloor x^{\frac{1}{3}}\rfloor$ 一定是呈块状分布的。

因此我们可以找出来每一个块的开始。设 $t_i$ 表示第一个 $y$，满足 $f(y)=i$。那么 $t_i$ 可以直接预处理。

然后我们再处理一个 $a_i$ 表示 $1\sim t_i-1$ 的答案，这个东西也可以预处理。预处理方法是递推，考虑新增块的贡献。

然后我们考虑如何回答询问，我们可以二分，找出询问的 $x$ 所在块的位置，则前面若干个整块的答案我们通过 $a_i$ 来求，末尾散块的答案直接乘就好了。

时间复杂度为 $O(n^{\frac{1}{3}}+q\log n)$，可以通过本题。

我没有用到 $x$ 递增这一条件。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e4 + 5;
int tab[N], ans[N], q;

signed main(){
	cin>>q;
	for(int i=1;i<=10000;i++) tab[i] = i * i * i;
	for(int i=1;i<=10000;i++) ans[i] = ans[i - 1] + (i - 1) * (tab[i] - tab[i - 1]);
	while(q--){
		int n;cin>>n;
		int pos = upper_bound(tab + 1, tab + 10000 + 1, n) - tab;
		cout << (ans[pos - 1] + (pos - 1) * (n - tab[pos - 1] + 1)) << '\n';
	}
	return 0;
}
```

---

## 作者：WorldMachine (赞：1)

题意：给出正整数 $n$，求：
$$
f(n)=\sum_{i=1}^n\lfloor\sqrt[3]{n}\rfloor
$$
多组数据。$1\leq q\leq 2\times 10^5,1\leq n\leq 10^{12}$。

令 $s=\lfloor\sqrt[3]{n}\rfloor$。答案分为两部分：$1\sim s^3-1$ 和 $s^3\sim n$。

后者的答案为 $s(n-s^3+1)$。

前者的答案为：
$$
\begin{align}
\sum_{i=1}^{s-1}i[(i+1)^3-i^3]&=\sum_{i=1}^{s-1}i(3i^2+3i+1)\nonumber\\
&=\sum_{i=1}^{s-1}(3i^3+3i^2+i)\nonumber\\
&=3\left(\dfrac{s(s-1)}2\right)^2+3\left(\dfrac16s(s-1)(2s-1)\right)+\dfrac12s(s-1)\nonumber\\
&=\dfrac34s^2(s-1)^2+\dfrac12s(s-1)(2s-1)+\dfrac12s(s-1)\nonumber
\end{align}
$$
然后你会发现 `cbrt` 有精度误差，当输入是立方数的时候就会挂。所以求出 $s$ 之后还需要判断 $s$ 是否偏小或偏大。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define Pow(s) ((s) * (s) * (s))
ll q, n, s, ans;
int main() {
	scanf("%lld", &q);
	while (q--) {
		scanf("%lld", &n);
		s = cbrt(n);
		if (Pow(s + 1) <= n) s++;
		else if (Pow(s) > n) s--;
		ans = 0;
		ans += s * s * (s - 1) * (s - 1) / 4 * 3;	// 立方和部分 
		ans += s * (s - 1) * (s * 2 - 1) / 2;	// 平方和部分 
		ans += s * (s - 1) / 2;	// 一次和部分 
		ans += s * (n - Pow(s) + 1);	// s^3 ~ n 部分 
		printf("%lld\n", ans);
	}
}
```

说句闲话，如果题目要求的是 $k$ 次方根向下取整的值之和，并且只有单组询问，也是可以做的。因为你会发现前半部分是一个 $k+1$ 次的多项式，类比 CF622F 的做法，用拉格朗日插值即可做到 $\mathcal O(k)$。

---

## 作者：cmask4869 (赞：0)

## 思路
这道题是一道数学题，可以简单写为：
$$
S_n = \sum_{j = 1}^{ans}⌊n^\frac{1}{3}⌋ 
$$
如果正常暴力做的话算一下，应该只能得 20pts，所以思考一下其他方法，通过背的立方数公式，可以得出以下规律：

- 因为 $x$ 一定为正整数，所以不考虑 $1^3$ 的情况。
- 当 $x<2^3(8)$，前面的所有（至上一次判断）正整数的答案都为 $1$。
- 当 $x<3^3(27)$，前面的所有（至上一次判断）正整数的答案都为 $2$。

得出结论，$x \le n^3$ 时，前面的所有（至上一次判断）正整数的答案为 $n-1$。

而数据保证，$n \le 10^{12}$，而 $\sqrt [3]{10^{12}}$ 的数值只有 $10000$，完全可以用打表的方式提前将 $n^3(n \le 10000)$ 的数全部计算出来，于是打出一个这样的表。

之后分层进行判断，得出这样的程序：
```
for ( ; i<10000 ; i++){
	if (n>=a[i+1]){
		ans+=(i+1)*(a[i+1]-a[i]) ;
	}
	else{
		ans+=(n-a[i]+1)*(i+1) ;
		break ;
	}
}
```
但是同时要注意到数据组数 $q \le 2 \times 10^5$，这样的程序只能得到 60pts，所以考虑优化。

这里发现了一个问题，题目告诉我们 $n$ 一定是升序排序的，这个条件并没有用到，再想到比较大的 $n$ 会有较多的重复计算的次数，于是 dp 的思想符合了，我们可以利用 dp 将前一个的状态进行记忆化。但是同样遇到了一个问题，使用的程序在最后一步要有一个特判（已少于下一次递归的 $n^3$），然后把状态提前到每次可能是重复运算的式子。

其中 $dp$ 是用来存储上一次的数值，而 $cdp$ 是存上一次计算到哪里了，从而更方便地进行下一次循环。另外，我们还需考虑 for 循环所带来的次数的多次累计，但是同样后面还有一层特判，最后在下一次用的地方对 $cdp+1$ 就可以解决这个问题。

$dp$ 和 $cdp$ 的初始化也是比较容易出错的地方。
```cpp
int i=cdp ;
ans=dp ;
for ( ; i<10000 ; i++){
	if (n>=a[i+1]){
		ans+=(i+1)*(a[i+1]-a[i]) ;
		dp=ans ; cdp=i+1 ;
	}
	else{
		ans+=(n-a[i]+1)*(i+1) ;
		break ;
	}
}
```

只能拿 70pts，这是为什么呢？我们提交之后可以发现，有三个点 WA 了，且这三个点最后都是最大数 $10^{12}$，那么怎么了呢？我们开的数组只到了 $10000$，但我们每次调用使用的是 $i-1+1$，所以我们实际调用的数组到了 $10001$，所以我们考场上只需要把 $10000$ 改为 $10001$ 就可以了。

由于打表程序太长贴不上去，把后来生成表的程序 AC 程序贴上来：

## 程序
```cpp
#include<bits/stdc++.h>
using namespace std ;
typedef unsigned long long ll ;
ll a[10005];
ll ans=0,q ;
ll dp=0,cdp=0 ;
void work(){
	ll w;
	for(ll i=1;i<=10001;i++)
		w=i*i*i,a[i-1]=w;//cout<<w<<" "<<i<<" "<<endl;
	return;
}
int main(){
//	freopen("b.in", "r" , stdin) ;
//	freopen("b.out", "w" , stdout) ; 
	work();
	cin >> q ;
	while (q--){
		ll n ;
		cin >> n ;
		int i=cdp ;
		ans=dp ;
		for ( ; i<=10000 ; i++){
			if (n>=a[i+1]){
				ans+=(i+1)*(a[i+1]-a[i]) ;
				dp=ans ; cdp=i+1 ;
			}
			else{
				ans+=(n-a[i]+1)*(i+1) ;
				break ;
			}
		}
		cout << ans << endl ;
		//cout << dp << " " << cdp << endl ;
	}
	return 0 ;
}
```
------------
总结一下这题的算法：
- 先用数学积累的知识暴力打表。
- 使用 dp 思想优化程序。

---

## 作者：编程小贝壳 (赞：0)

十分水的黄题，甚至让我怀疑它配不配评黄。

$x$ 的范围是 $10^{12}$ 的，但是求的是 $x^{\frac{1}{3}}$，因此可以看作是 $10^{4}$ 级别。

由于从 $n^3$ 到 $(n+1)^3$ 之间的数的答案都是一致的，因此可以处理出每个答案对应的区间，然后二分，复杂度为 $O(q\log(10^4))\approx O(q)$，可以通过此题。

但是观察到输入数据的 $x_i$ 单调不降，因此就没必要二分了，直接在从上一个答案的位置往后找答案即可。

最后找到 $x^{\frac{1}{3}}$ 的值之后还需要计算最终的答案，根据最大的小于 $x^{\frac{1}{3}}$ 的 $a^3$ 直接计算即可。计算时有一些细节需要注意，但十分容易，留给读者自己写（

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint rigister int
long long cal(long long x) {
	return x*x*x;
}
int q;
long long x,ans,nx,lst;
int main() {
	scanf("%d",&q);
	while(q--) {
		scanf("%lld",&x);
		if(cal(nx+1) > x) {
			ans += (x-lst)*nx;lst = x;
			printf("%lld\n",ans);
			continue;
		}
		ans += (cal(nx+1)-1-lst)*nx;++nx;
		while(cal(nx+1) <= x){
			ans += (cal(nx+1)-cal(nx))*nx;
			++nx;
		}
		ans += (x-cal(nx)+1)*nx;
		printf("%lld\n",ans);
		lst = x;
	}
	return 0;
}
```

---

## 作者：vorDeal (赞：0)

~~快数学竞赛了，写道数学题练练手。~~

由背景得，存在一种时间复杂度为 $O(q \sqrt[3]{x})$ 的算法。想到对每个 $a^3 \sim (a+1)^3-1$ 的块，分开计算和，再对最后一个不完整的块计算答案，最后再相加，即可达到前文所述的复杂度。

于是，我们便可以将对整块之和的计算提前，$O(\sqrt[3]{x})$ 的对它的 **前缀和** 打表，以实现 $O(1)$ 的单次询问复杂度。这样，可以不利用 $x_i$ 单调不降的性质，从而减少码量。

请保证，代码中数值运算全程都使用了 long long。~~本人交了 7 发才过。~~

时间复杂度为 $O(\sqrt[3]{x}+q)$，可以通过本题。

**AC Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e4 + 5;

int q;
long long x, f[maxn];

inline int cbr(long long x)
{
    return int(cbrt(x + 0.5));
}

inline long long cb(long long a)
{
    return a * a * a;
}

int main()
{
    cin >> q;
    for (long long i = 1; i < maxn; i++)
        f[i] = f[i - 1] + 3 * i * i * i +
               3 * i * i + i;
    while (q--)
    {
        cin >> x;
        cout << (x - cb(cbr(x)) + 1LL) *
                        cbr(x) +
                    f[cbr(x) - 1]
             << endl;
    }
    return 0;
}
```

感谢您的阅读。

---

## 作者：I_will_AKIOI (赞：0)

很多数字的立方根向下取整后是相同的。即使数据范围有 $10^{12}$，也只有 $10^4$ 个立方根。所以我们可以先枚举一下立方根，然后做一次前缀和，记录这个立方根对应的立方数的答案。

那么不是立方数的答案怎么办？我们先二分一下，找到 $x=\lfloor \sqrt[3]{n} \rfloor$。这时候 $x$ 对答案的贡献就处理好了。剩下的 $n-x^3$ 个数的立方根都相同，所以贡献就是 $x(n-x^3)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int Pow[40005],sum[40005];
void solve()
{
  int n;
  cin>>n;
  int p=upper_bound(Pow+1,Pow+40001,n)-Pow-1;//求立方根
  cout<<sum[p]+(n-p*p*p)*p<<"\n";
  return;
}
signed main()
{
  ios::sync_with_stdio(0);
  for(int i=1;i<=40000;i++) Pow[i]=i*i*i,sum[i]=sum[i-1]+(Pow[i]-Pow[i-1]-1)*(i-1)+i;//预处理i^3的答案
  int t;
  cin>>t;
  while(t--) solve();
  return 0;
}
```

---

## 作者：xiaoyang111 (赞：0)

### 前言

[题目传送门。](https://www.luogu.com.cn/problem/P10373)

[专栏观看可能更佳。](https://www.luogu.com.cn/article/mf24ij9u)

### 讲解

先手动算一下每个数的立方根的向下取整，可以得到 `1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3`，后面不放了。

我们发现很大一个块内的数是完全一样的，没必要多算，所以我们的思路出来了。

可以先找这个数的立方根的向下取整是多少，找到了这个数在第几个整块。然后我们先把这个整块前面的整块的所有向下取整的立方根加起来。再算这个整块内小于等于这个数的这些立方根全都加起来，也可以理解是散块。两个结果再加起来就是查询的结果了。

对于加这个操作，因为很多数都是一样的，所以可以直接做乘法。

这个做法时间复杂度是 $O(q \times \sqrt[3]{V})$，$V$ 是值域。显然是会炸的。

我们考虑优化，可以通过题面给出的查询单调不下降来思考。

因为是单调不下降，而之前枚举的时候之前有部分重复了，那么我们可以直接用之前算过的整块的结果来继续往当前查询的这个数累加整块，下一次就不用算重复了。时间复杂度 $O(q + \sqrt[3]{V})$。

### 代码

代码是下面这个。

```cpp
#include <iostream>
#include <vector>
#define int long long
using namespace std;
vector<int> a;//完全立方数 
void init(){
	for (int i=1;i<=1e4+5;++i){//预处理完全立方数 
		a.emplace_back(i*i*i);
	}
    a.emplace_back();
}
int sm=0,i;//前面整块的总和和到哪一个整块了 
void solve(){
	int x;
	scanf("%lld",&x);
	for (;i<a.size()-1 && a[i+1]<=x;++i){
		sm+=(i+1)*(a[i+1]-a[i]);
	}
	printf("%lld\n",sm+(i+1)*(x-a[i]+1));
}
signed main(){
    init();
	int q;
	cin >> q;
	for (int i=0;i<q;++i){
		solve();
	}
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P10373 题目](https://www.luogu.com.cn/problem/P10373)

### 解题思路
不难发现，对于任何一个正整数 $i$，$\lfloor(i^3)^\frac{1}{3}\rfloor,\lfloor(i^3+1)^\frac{1}{3}\rfloor,\lfloor(i^3+2)^\frac{1}{3}\rfloor,\cdots,\lfloor((i+1)^3-1)^\frac{1}{3}\rfloor$ 的值均为 $i$，所以我们可以预处理出 $\sum_{i=1}^{1^3}\lfloor i^\frac{1}{3}\rfloor,\sum_{i=1}^{2^3}\lfloor i^\frac{1}{3}\rfloor,\sum_{i=1}^{3^3}\lfloor i^\frac{1}{3}\rfloor,\cdots,\sum_{i=1}^{(10^4)^3}\lfloor i^\frac{1}{3}\rfloor$ 的值（因为 $x\le 10^{12}$，所以预处理到 $10^{12}=(10^4)^3$ 即可）。

那如何预处理呢？根据前面的结论可以得出，对于任何一个整数 $i(i\ge2)$：
$$\sum_{j=1}^{i^3}\lfloor j^\frac{1}{3}\rfloor=\sum_{j=1}^{(i-1)^3}\lfloor j^\frac{1}{3}\rfloor+(i^3-(i-1)^3-1)\times(i-1)+i$$

预处理结束后，我们很容易就能得到，对于任何一个正整数 $x$：
$$\sum_{i=1}^x\lfloor i^\frac{1}{3}\rfloor=\sum_{i=1}^{\lfloor x^\frac{1}{3}\rfloor^3}\lfloor i^\frac{1}{3}\rfloor+(x-\lfloor x^\frac{1}{3}\rfloor^3)\times\lfloor x^\frac{1}{3}\rfloor$$
由于上面公式中 $\sum_{i=1}^{\lfloor x^\frac{1}{3}\rfloor^3}\lfloor i^\frac{1}{3}\rfloor$ 的部分我们已经提前预处理过，所以我们可以在 $O(1)$ 的复杂度中回答每一个询问，不会超限。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[10001],lf[10001];
int main()
{
	for(long long i=1;i<=10000;i++)
		lf[i]=i*i*i;
	long long sh=0;
	for(long long i=1;i<=10000;i++)
	{
		long long s=i*i*i;
		long long g=s-sh;
		a[i]=a[i-1]+(g-1)*(i-1)+i;
		sh=s;
	}
	int q;
	cin>>q;
	while(q--)
	{
		long long x;
		cin>>x;
		if(binary_search(lf+1,lf+10001,x))
		{
			long long w=lower_bound(lf+1,lf+10001,x)-lf;
			cout<<a[w]<<"\n";
			continue;
		}
		long long xx=cbrt(x);
		long long ans=a[xx];
		long long ansj=(x-xx*xx*xx)*xx;
		ans+=ansj;
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Ravener (赞：0)

依题意，
>有 $q$ 组疑问，对于每个询问的 $x_i$，输出：
>$$\displaystyle \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor$$
>其中 $\lfloor x \rfloor$ 为向下取整函数，即 C++ 的``floor(x)``。

------------
#### 1. 暴力法（20 pts）
直接枚举 $j$ 。  
时间复杂度 $O(qn)$，TLE。  
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
//请勿在意，写题忘删的
int main()
{
	int q;
	cin>>q;
	while(q--)
	{
		double x,ans=0;
		cin>>x;
		for(int i=1;i<=x;i++) 
			ans+=floor(cbrt(i+0.5));//精度问题导致cbrt的值不稳定，所以要+0.5
		cout<<fixed<<setprecision(0)<<ans<<"\n";
	}
}
```

评测记录：[20 pts](https://www.luogu.com.cn/record/157283206)。

------------
#### 2. 记忆化，但是没有数组（30 pts）
题目有一句加粗的字：
>**保证给出的 $x_1 \thicksim x_n$ 单调不降。**

所以可以直接把上一个 $x$ 的数据用到下一个数据。  
但时间复杂度最坏 $O(10^{12}q)$，TLE。  
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int q;
	double x,ans=0,x1=0;
	cin>>q;
	while(q--)
	{
		cin>>x;
		for(int i=x1+1;i<=x;i++) 
			ans+=floor(cbrt(i+0.5));
		cout<<fixed<<setprecision(0)<<ans<<"\n";
		x1=x;
	}
}
```

评测记录：[30 pts](https://www.luogu.com.cn/record/157285632)。

------------
#### 3.数学法（正解）
受到 dalao @Breath_of_the_Wild 的 [tj](https://www.luogu.com/article/2ofym2gn) 的启示，有了这个办法（顶礼膜拜 dalao）。  
列举 $x \in [1,64] $ 时 $\lfloor x^{\frac 1 3} \rfloor$ 的值：
| $x\in$ | $[1,7]$ | $[8,26]$ | $[27,63]$ | $\{64\}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\lfloor x^{\frac 1 3} \rfloor$ | $1$ | $2$ | $3$ | $4$ |


发现当 $x \in [k^3,(k+1)^3-1]$ 时 $\lfloor x^{\frac 1 3} \rfloor=k$，其中 $k\in\mathbb N^{*}$，下同。 

令 $\displaystyle t=\lfloor x_i^{\frac 1 3} \rfloor$，  
则： 
$$\displaystyle \begin{aligned}
\small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor 
 &=\small t(x_i-t^3+1)+\sum_{p=1}^{t-1} p[(p+1)^3-p^3]
\\
&= \small t(x_i-t^3+1)+\frac 3 4 t^2(t-1)^2+\frac 1 2 t(t-1)(2t-1)+\frac 1 2 t(t-1) \end{aligned}.$$


------------

证明：

**I.**  
①当 $x_i = t^3-1$ 时：  
当 $i \in [m^3,(m+1)^3-1]$ 时，值为 $m$，数量为 $(m+1)^3-m^3$, 其中 $m\in[1,t-1]$，  
所以 $\displaystyle \small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor = \small \sum_{m=1}^{t-1}m[(m+1)^3-m^3]$。

②当 $x_i \not = t^3-1$ 时：  
设 $x_i=s+r$，其中$s=t^3+1，r=x_i-s=x_i-t^3+1$，  
所以  
$$\displaystyle 
\begin{aligned}
\small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor &= \small \sum_{j=1}^s \lfloor j^{\frac 1 3} \rfloor + \sum_{j=s+1}^r \lfloor j^{\frac 1 3} \rfloor \\
&= \small \sum_{m=1}^{t-1}m[(m+1)^3-m^3]+\sum_{j=s+1}^r \lfloor j^{\frac 1 3} \rfloor.
\end{aligned}$$  
因为当 $i \in [t^3,x_i]$ 时，数量为 $r=x_i-s=x_i-t^3+1$，值为 $t$，  
所以 $\displaystyle \small \sum_{j=s+1}^r \lfloor j^{\frac 1 3} \rfloor=t(x_i-t^3+1)$。  
所以  
$$\displaystyle 
\begin{aligned}
\small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor 
&= \small \sum_{m=1}^{t-1}m[(m+1)^3-m^3]+\sum_{j=s+1}^r \lfloor j^{\frac 1 3} \rfloor \\
&=t(x_i-t^3+1)+ \small \sum_{m=1}^{t-1}m[(m+1)^3-m^3].
\end{aligned}$$

**II.**  
$$\displaystyle
\begin{aligned}
\small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor 
&=t(x_i-t^3+1)+ \small \sum_{m=1}^{t-1}m[(m+1)^3-m^3] \\
&=t(x_i-t^3+1)+ \small \sum_{m=1}^{t-1}(3m^3+3m^2+m)\\
&=t(x_i-t^3+1)+ \small 3 \sum_{m=1}^{t-1}m^3+ \small 3 \sum_{m=1}^{t-1}m^2+ \small \sum_{m=1}^{t-1}m \\
&=t(x_i-t^3+1)+ \frac 3 4 t^2(t-1)^2+\frac 1 2 t(t-1)(2t-1)+ \frac 1 2 t(t-1).
\end{aligned} 
$$
令 $\displaystyle a=t(x_i-t^3+1),b=\frac 3 4 t^2(t-1)^2,c=\frac 1 2 t(t-1)(2t-1),d=\frac 1 2 t(t-1)$，可得 $\displaystyle \small \sum_{j=1}^{x_i} \lfloor j^{\frac 1 3} \rfloor = \normalsize a+b+c+d$。

------------

运用数学法，即可在 $O(q)$ 内完成此题。  
前提是 ``cbrt(x)`` 和 ``pow(x,1.0/3)`` 这俩哥们精度不出问题……  

------------

#### 3.i) 用 ``exp`` 和 ``log`` 求立方根

因为 $\displaystyle a^{\log_a b}=b, n\log_a b=\log_ab^n$，  
所以 $\displaystyle \textup{\textmd e}^{\frac 1 3 \ln x_i}=\sqrt [3] {x_i}$。  
所以要想求立方根，只要用 ``exp(log(x+0.5)/3)`` 就行。  
应该不会发生精度问题。

AC 代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int q;
	long double x,ans;//还是保险一点好
	ll a,b,c,d;//十年 OI 一场空，__________
	cin>>q;
	while(q--)
	{
		cin>>x;
		ll l=exp(log(x+0.5)/3);
		a=l*l*(l-1)*(l-1)*3/4;
		b=l*(l-1)*(2*l-1)/2;
		c=l*(l-1)/2;
		d=l*(x-l*l*l+1);
		ans=a+b+c+d;
		cout<<fixed<<setprecision(0)<<ans<<"\n";
	}
}
```

[AC 记录](https://www.luogu.com.cn/record/157317640)。  

（再次顶礼膜拜@Breath_of_the_Wild dalao）

（题解如有谬误和纰漏欢迎 at 我或私信我指正）

---


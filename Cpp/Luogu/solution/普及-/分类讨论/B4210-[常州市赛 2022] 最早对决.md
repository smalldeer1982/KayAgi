# [常州市赛 2022] 最早对决

## 题目背景

搬运自 <http://czoj.com.cn/p/451>。数据为民间数据。



## 题目描述

小 $\text{X}$ 和小 $\text{Y}$ 凭借出色的程序设计能力，顺利入选了“我们爱科学”活动，该活动以科学精神、创新意识、实践能力的培养为目标，激发广大中小学生爱科学、学科学、用科学的兴趣。

报到之后小 $\text{X}$ 和小 $\text{Y}$ 有幸被分进了人工智能（简称 AI）班，经过一周紧张刺激的AI学习， 每位同学都编写了一个 AI 程序“黑白棋”，经过对弈平台的双循环赛，一共选出了 $32$ 位种 子选手，编号分别为 $1 \sim 32$，其余选手均为非种子选手，编号为 $33 \sim 128$。 最后的决战拉开帷幕，比赛采用淘汰赛制，共有 $128$ 位选手参加这场淘汰赛，两两对决， 胜者进入下一轮，而输的将被直接淘汰出局。通过抽签产生这 $128$ 位选手的对阵表，抽签规则如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/fv29z0ih.png)

首先将种子选手的编号从小到大排序，$1$ 号种子安排在 $1$ 号位置，$2$ 号种子安排在 $128$号位置。接着将整个赛区分为上半赛区和下半赛区，即上半赛区是 $1 \sim 64$ 号位置，下半赛区是 $65 \sim 128$ 号位置，将上半赛区的最后一个位置和下半赛区的第一个位置选出来（$64$ 号和 $65$ 号），然后将接下来的 $2$ 位种子选手（$3$ 号和 $4$ 号）通过随机抽签的方式安排在这 $2$ 个位置中，也就是说 $3$ 号种子既可能抽到 $64$ 号位置，也可能抽到 $65$ 号位置，$3$ 号种子的位置通过抽签定下来之后，$4$ 号种子就自动被安排到另一个位置；接下去对于每个赛区再继续分上半赛区和下半赛区，这样就形成了$1 \sim 32,33 \sim 64,65 \sim 96,97 \sim 128$ 四个赛区，将所有上半赛区的最后一个位置 和下半赛区的第一个位置选出来（$32$ 号,$33$ 号,$96$ 号,$97$ 号）。然后将接下来的 $4$ 位种子选手（$5$ 号,$6$  号,$7$ 号,$8$ 号）通过随机抽签的方式安排到这 $4$ 个位置中，然后继续划分赛区，直到所有种子选手被安排完毕，剩下的 $96$ 个非种子选手通过随机抽签安排到余下空位中。

小 $\text{X}$ 和小 $\text{Y}$ 的 AI 十分强大，两人的 AI 可以打败除了他们以外的所有对手，但是他们发现， 假如小 $\text{X}$ 的编号是 $1$ 号，小 $\text{Y}$ 的编号是 $2$ 号，他们将作为头两号种子坐在 $1$ 号位置和 $128$ 号位置， 两人将所向披靡一路击败所有的对手，直到决赛（第 $7$ 轮）才会相遇。

现在给出小 $\text{X}$ 和小 $\text{Y}$ 的编号，他们想知道最早会在哪一轮相遇？

## 说明/提示

### 样例解释
小 $\text{X}$ 是 $1$ 号种子，坐在 $1$ 号位置，小 $\text{Y}$ 是 $3$ 号种子，他可能抽到 $64$ 号或 $65$ 号位置， 如果小 $\text{Y}$ 抽到 $64$ 号位置，他跟小 $\text{X}$ 会在半决赛（第 $6$ 轮）相遇。如果小 $\text{Y}$ 抽到 $65$ 号位置，他跟小 $\text{X}$ 会在决赛（第 $7$ 轮）相遇。所以他们最早会在第 $6$ 轮相遇。

### 数据规模与约定
对于 $10\%$ 的数据，小 $\text{X}$ 和小 $\text{Y}$ 都是非种子选手，即编号都大于 $32$；

对于另外 $10\%$ 的数据，小 $\text{X}$ 和小 $\text{Y}$ 有一个是非种子选手；

对于 $100\%$ 的数据，$1≤S,T≤128$。

## 样例 #1

### 输入

```
1 3```

### 输出

```
6```

# 题解

## 作者：DFLJ (赞：5)

# B4210 最早对决

规律题，如果不是种子选手就有可能抽在一起，所以是 $1$。

然后按种子选手抽编号，找最小值。

因为种子选手的编号决定了他们什么时候相遇。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a1[17]={1}; //不同排名种子选手所可能抽的位置
int a2[17]={128}; 
int a3[17]={64,65}; 
int a4[17]={32,33,96,97}; 
int a5[17]={16,17,48,49,80,81,112,113}; 
int a6[17]={8,9,24,25,40,41,56,57,72,73,88,89,104,105,120,121}; 
// 1
// 128
// 64 65 2
// 32 33 96 97 4
// 16 17 48 49 80 81 112 113 8
// 8 9 24 25 40 41 56 57 72 73 88 89 104 105 120 121 16

int main()
{
    int x,y,wx,wy,nx,ny;
    cin>>x>>y;
    if(x>32||y>32)//非种子选手
    {
        cout<<1;
        return 0;
    }
    if(x>16) wx=6,nx=16;
    else if(x>8) wx=5,nx=8;
    else if(x>4) wx=4,nx=4;
    else if(x>2) wx=3,nx=2;
    else if(x==2) wx=2,nx=1;
    else if(x==1) wx=1,nx=1;
    if(y>16) wy=6,ny=16;
    else if(y>8) wy=5,ny=8;
    else if(y>4) wy=4,ny=4;
    else if(y>2) wy=3,ny=2;
    else if(y==2) wy=2,ny=1;
    else if(y==1) wy=1,ny=1;
//种子选手不同排名所对应的编号
    int bx,by,ans=7,lastans=1e9;
    for(int i=1; i<=nx; i++)
    {
        if(wx==1) bx=a1[i-1];
        if(wx==2) bx=a2[i-1];
        if(wx==3) bx=a3[i-1];
        if(wx==4) bx=a4[i-1];
        if(wx==5) bx=a5[i-1];
        if(wx==6) bx=a6[i-1];//遍历编号
        for(int j=1; j<=ny; j++)
        {
            if(wy==1) by=a1[j-1];
            if(wy==2) by=a2[j-1];
            if(wy==3) by=a3[j-1];
            if(wy==4) by=a4[j-1];
            if(wy==5) by=a5[j-1];
            if(wy==6) by=a6[j-1];
            //遍历编号
            if(abs(bx-by)>=1) ans=1;
            if(abs(bx-by)>=2) ans=2;
            if(abs(bx-by)>=4) ans=3;
            if(abs(bx-by)>=8) ans=4;
            if(abs(bx-by)>=16) ans=5;
            if(abs(bx-by)>=32) ans=6;
            if(abs(bx-by)>=64) ans=7;
            //求种子选手编号之间的差，判断几轮相遇
            lastans=min(ans,lastans);//更新答案
        }
    }
    cout<<lastans;
    return 0;
}
```

---

## 作者：lizeyuhello (赞：3)

赛时没看懂题面，寄了。

# 题解
根据题意，当小 X 和小 Y 都不是种子选手时，他们最早一定能在第 $1$ 轮相遇。

对于其它情况，可以把选手分为 $7$ 个层次：

| 层数 | 选手号码 |
| ---- | ---- |
| $7$ | $1\sim2$ |
| $6$ | $3\sim4$ |
| $5$ | $5\sim8$ |
| $4$ | $9\sim16$ |
| $3$ | $17\sim32$ |
| $1$ | $33\sim128$ |

第 $2$ 层不存在，因为在第 $2$ 轮相遇的选手在第 $1$ 轮一定能相遇。

令小 X 的层数为 $x$，小 Y 的层数为 $y$。

若小 X 和小 Y 都是种子选手，并且他们在同一层，那么他们最早可能相遇的轮数为 $x + 1$。

若小 X 和小 Y 中有一个是种子选手，那么他们最早可能相遇的轮数为 $\min(x,y)$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int a, b;

int round(int x) //计算选手 x 的层数
{
	if (x <= 2)
		return 7;
	if (x <= 4)
		return 6;
	if (x <= 8)
		return 5;
	if (x <= 16)
		return 4;
	if (x <= 32)
		return 3;
	return 1;
}

int main()
{
	scanf("%d%d", &a, &b);
    //特判：当 x,y 为 1 号和 2 号时答案为 7
	if (a == 1 && b == 2 || a == 2 && b == 1)
		return puts("7"), 0;
	printf("%d\n", min(round(a), round(b)) + (a <= 32 && b <= 32 && round(a) == round(b)));
	return 0;
}
```

---

## 作者：yd021a (赞：2)

## 解题思路

本题关键在于判断两人是否为种子选手：

- **非种子选手情况**  
  若其中一人或两人都不是种子选手（编号 > $32$），则最小相遇轮次为 $1$（非种子选手随机抽签）。
  
- **种子选手情况**  
  若两人都是种子选手（编号 ≤ $32$），需计算他们的批次：
  1. 通过位运算确定选手批次：满足 $2^{l-1} < x \leq 2^l$ 的最小 $l$。
  2. 取两人批次最大值 $\max(a,b)$。
  3. 相遇轮次公式：$8 - \max(a,b) + 1$。
> 爱门！
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int g(int x){
    int l=0;
    while((1<<l)<x) l++;
    return l+1;
}
inline long long int read(){
	long long int w=1,s=0;
	char ch;
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return w*s;
}
int main(){
    int s,t;
    s=read(),t=raed();
    if (s>t) swap(s,t);
    
    if (s<=32&&t<=32){  // 两人均为种子选手
        int a=g(s);
        int b=g(t);
        int maxx=max(a,b);
        cout<<8-maxx+1<<endl;
    } 
    else{ // 至少一人非种子选手
        cout<<1<<endl;
    }
    return 0;
}
```

## 算法解析

### 1. 批次计算函数 `g(x)`
- 通过位运算 `(1 << l) < x` 确定满足条件的最小 `l`。
- 返回值 `l + 1` 表示选手所在批次。
- **示例**：
  - $x=1$ → $l=0$ → 批次 $1$。
  - $x=3$ → $l=2$ → 批次 $3$。

### 2. 相遇轮次计算原理
设批次为 $n$，根据赛制：
- 第 $n$ 批种子占据 $2^{8-n}$ 个位置。
- 两人相遇轮次公式：
  $$
  \text{相遇轮次} = 8 - \max(a,b) + 1
  $$

### 3. 典型示例
| 选手编号 | 计算过程               | 相遇轮次 | 说明         |
|----------|------------------------|----------|--------------|
| (1, 2)   | $\max(1,2)=2 → 8-2+1$ | 7        | 决赛相遇     |
| (1, 3)   | $\max(1,3)=3 → 8-3+1$ | 6        | 半决赛相遇   |
| (33, 34) | 非种子选手             | 1        | 第一轮相遇   |

> **时间复杂度**：$O(1)$  

---

  
> *我的题解就到此为止了，看完这篇以后，就是你来写了。（来自 $2.2$ 的剧情感想）*

---


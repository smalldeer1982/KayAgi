# 纷飞的樱花雨

## 题目背景

高中的时候做过樱花雨实验，氯化钴遇到氢氧化钠溶液产生的沉淀物就像是一场铺天盖地的樱花雨。

小 $ \zeta $ 问她，你见过樱花吗？

她抬头摇起眼睛，碎亮的光倒映在少女乌黑的瞳孔里。

她侧头定定看了我一会儿，然后淡淡地笑了。

她说，「我知道你想考武汉大学。」

「我也会去武汉大学。」

「今年九月，你要和我一起去看樱花吗？」

## 题目描述

小 $ \zeta $ 喜欢观赏樱花。

$ n $ 朵樱花的掉落过程中，第 $ i $ 个掉落的樱花的美丽度为 $ a_i $。

每朵樱花掉落后，樱花掉落的总观赏度会增加这朵樱花及之前所有已经掉落的樱花的美丽度的最大值。

交换**正好** $ k $ 次两朵樱花的掉落顺序（不能交换一朵樱花和本身，但可以重复交换两朵樱花），最大化总观赏度的值。

形式化地讲，给出一个长度为 $ n $ 的数组，进行正好 $ k $ 次交换使得 $ \sum_{i=1}^n \max_{j=1}^ia_j $  最大。

## 说明/提示

**【样例 1 解释】**

第二组数据可以将 $ 10 $ 和 $ 11 $ 交换，观赏度总和为 $ 11+11=22 $。

**【数据规模与约定】**

对于 $ 100\% $ 的数据，$ 1 \le T \le 500 $，$ 2 \le n \le 10^5 $，$ 0 \le k \le 10^9 $，$ \sum n \le 10^6 $，$ 1 \le a_i \le 10^9 $。

**本题测试点等分，按测试点加和计分。**

| 测试点编号 | $ n $ | $ k $ |
|:-:|:-:|:-:|
| $ 1 $ | $ \le 50 $ | $ =0 $ |
| $ 2 $ | - | $ =0 $ |
| $ 3 \sim 4 $ | $ \le 50 $ | $ =1 $ |
| $ 5 \sim 7 $ | - | $ =1 $ |
| $ 8 \sim 10 $ | - | - |

## 样例 #1

### 输入

```
3
3 0
9 8 2
2 1
10 11
5 10
1 2 3 4 5```

### 输出

```
27
22
25```

## 样例 #2

### 输入

```
5
5 0
100 101 102 103 104
5 1
20 40 50 70 10
2 103
30 20
7 2
1 2 3 4 5 6 7
2 10
1 1```

### 输出

```
510
350
50
49
2```

# 题解

## 作者：Besheep (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P11309)
## 注意
$k$ 次操作必须全部使用。
## 思路
分类讨论题。   

因为增加的是已经掉落的最大值，所以让最大美丽值的樱花首先掉落即可，还有 $n$ 的值很大，不能直接模拟，并且不难发现答案为 最大值 $\times n$。

但是，当你测试下面的样例 `2 103 30 20` 时，会发现答案与样例不对，具体原因是只有 $2$ 朵花瓣，而 $k$ 次操作必须全部使用，所以只能不断的相互交换，但是 $k$ 的最大值是 $10^9$，显然不能模拟。

举例：
- `2 3 30 20`，进行 $3$ 次变换后，为 `20 30`。
- `2 4 30 20`，进行 $4$ 次变换后，为 `30 20`。

通过判断 $k$ 的奇偶性，可以得出：
- $k$ 为奇数时，相互交换。
- $k$ 为偶数时，不变。

 随后根据题意模拟即可。

## 结论
- 对于 $k=0$ 时，按照题面模拟即可。
- 对于 $k=2$ 时，判断 $k$ 的奇偶性，如上文所述进行模拟。
- 否则，把最大值放在第一位，此时答案为 最大值 $\times n$。

## 代码（码风不好勿喷）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
#define ll long long
ll T,n,k,a[N];
int main() {
    cin>>T;
    while(T--){
    	cin>>n>>k;
    	ll ans=0,maxn=-1;
    	if(k==0){
    		for(int i=1;i<=n;i++){
    			ll temp;
    			cin>>temp;
    			a[i]=max(a[i-1],temp);
			}
			for(int i=1;i<=n;i++){
				a[i]+=a[i-1];
			}
			ans=a[n];
		}
		else{
			if(n==2){
				for(int i=1;i<=n;i++) cin>>a[i];
				if(k%2==1)swap(a[1],a[2]);
				for(int i=1;i<=n;i++) a[i]=max(a[i],a[i-1]);
				for(int i=1;i<=n;i++) a[i]+=a[i-1]; 
				ans=a[n];	
			}
			else{
				for(int i=1;i<=n;i++){
    				ll temp;
    				cin>>temp;
    				maxn=max(maxn,temp);
				}
				ans=maxn*n;
			} 
			
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：3)

# T2. sakura

## 题意回顾

长度为 $ n $ 的序列，恰好交换 $ k $ 次后，最大化数组 $ n $ 个前缀最大值的和。

## 分析

* 记 $ mx_i=\max_{j=1}^i{a_j} $，显然有 $ mx_i=\max\{mx_{i-1},a_i\} $，因此可以线性递推出这个已经交换完的数组对应的答案 $ \sum_{i=1}^n{mx_i} $；

* $ k=0 $ 时，不能交换，直接求出数组的答案即可；

* 当 $ k>0 $ 且 $ n=2 $ 时，因为偶数次交换的结果会互相抵消，根据 $ k $ 的奇偶性确定这个数组等效于不变还是被交换 $ 1 $ 次，直接求出数组的答案即可；

* 当 $ k>0 $ 且 $ n>2 $ 时，因为 $ \forall 1 \le i \le n, mx_i \le \max_{i=1}^n{a_i} $，所以考虑让所有 $ mx_i $ 都取到这个上限。一种方法是把 $ a $ 数组的最大值交换到数组的第一个位置，此时取到上限，剩下的交换次数用后面的数互相随意交换消耗掉即可。

## 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int T;
int n, k;
int a[N];
void solve() {
	long long res = 0;
	int mx = 0;
	for(int i = 1; i <= n; i++) mx = max(mx, a[i]), res += mx;
	printf("%lld\n", res);
}
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d%d", &n, &k);
		for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
		if(k == 0) solve();
		else if(n == 2) {
			if(k & 1) swap(a[1], a[2]);
			solve();
		} else {
			for(int i = 2; i <= n; i++) {
				if(a[i] > a[1]) swap(a[i], a[1]);
			}
			solve();
		}
	}
	return 0;
}
```

---

## 作者：ggpw_XNW (赞：2)

先放代码：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
unsigned long long n , a[100005] , T , k;
int main(){
	cin >> T;
	while(T--){
		cin >> n >> k;
		unsigned long long maxn = 0;
		for(int i=1;i<=n;i++){
			cin >> a[i];
			maxn = max(maxn,a[i]);
		}
		if(k==0){
			maxn = 0;unsigned long long ans = 0;
			for(int i=1;i<=n;i++){
				maxn = max(maxn,a[i]);
				ans += maxn;
			}
			cout << ans << endl;
		}else{
			if(n>2||(k%2==1&&a[1]<=a[2])||(k%2==0&&a[1]>=a[2]))cout << maxn * n << endl;
			else{
				if(a[1]>a[2]){
					if(k%2==0)cout << a[1] * 2 << endl;
					else cout << a[1] + a[2] << endl;
				}
				else{
					if(k%2==0)cout << a[1] + a[2] << endl;
					else cout << a[1] + a[2] << endl;
				}
			}
		}
	}
	return 0;
}
```
解释：  
对于每朵花，不难发现我们将美丽度最大的花交换到最前面，答案即为最大的。所以我们只需要将最大的花交换到最前面，然后其余操作可以无视。  
注意：  
如果 $n$ 等于 $2$，或 $k$ 等于 $0$，我们需要特判一下，详见代码。

---

## 作者：Miracle_InDream (赞：2)

对于这道题目，我的建议是：不用管下面那个形式化玩意儿（别因为那玩意儿没看懂就卡那儿了奥）。还有，那个交换是任意两朵都能交换，不是相邻的交换。

根据题面，我们可以进行以下分类讨论：

如果 $k=0$，那么我们可以直接得出，这组数据的观赏度可以直接按照题面中“每朵樱花掉落后，樱花掉落的总观赏度会增加这朵樱花及之前所有已经掉落的樱花的美丽度的最大值”这句话来模拟！

就像这样：

```cpp
for(int i=1;i<=n;i++)
{
    int a;
    cin>>a;
    maxx=max(maxx,a);
    ans+=maxx;
}
```

如果 $n=2$ 的话，观赏度就和 $a_1$ 是否大于 $a_2$ （下标从 $1$ 开始）和 $k$ 的奇偶性有关了：

如果 $a_1>a_2$，那么我们可以得到：当 $k$ 是奇数时，观赏度为 $a_1+a_2$，否则观赏度为 $2\times a_1$；否则：当 $k$ 是奇数时，观赏度为 $2\times a_2$，否则观赏度为 $a_1+a_2$。

至于上面这个怎么出来的，很简单，我们可以结合样例解释中的情况，进而推导。

最后一种情况就更简单了，直接把这 $n$ 个数里的最大值搞出来然后乘 $n$。

于是，我写出了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,k;
		cin>>n>>k;
		int maxx=0;
		int ans=0;
		if(k==0)
		{
			for(int i=1;i<=n;i++)
			{
				int a;
				cin>>a;
				maxx=max(maxx,a);
				ans+=maxx;
			}
		}
		else
		{
			if(n==2)
			{
				int a,b;
				cin>>a>>b;
				if(a>b)
				{
					if(k%2==1)
					{
						cout<<a+b;
					}
					else
					{
						cout<<a*2;
					}
				}
				else
				{
					if(k%2==0)
					{
						cout<<a+b;
					}
					else
					{
						cout<<b*2;
					}
				}
				cout<<endl;
				continue;
			}
			else
			{
				for(int i=1;i<=n;i++)
				{
					int a;
					cin>>a;
					maxx=max(maxx,a);
				}
				ans=maxx*n;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

结果：<https://www.luogu.com.cn/record/190571256>

~~喜提爆零。。。~~

那为什么会爆零呢？我们来看一下数据：

> **【数据规模与约定】**
>
> 对于 $ 100\% $ 的数据，$ 1 \le T \le 500 $，$ 2 \le n \le 10^5 $，$ 0 \le k \le 10^9 $，$ \sum n \le 10^6 $，$\color{red} 1 \le a_i \le 10^9 $。

注意被我加红的字，可以想象 $10^9\times 10^5$ 的大小。。。

这玩意儿 ```int``` 开得下就怪了啊！！！

于是，我们得到了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long t;
	cin>>t;
	while(t--)
	{
		long long n,k;
		cin>>n>>k;
		long long maxx=0;
		long long ans=0;
		if(k==0)
		{
			for(long long i=1;i<=n;i++)
			{
				long long a;
				cin>>a;
				maxx=max(maxx,a);
				ans+=maxx;
			}
		}
		else
		{
			if(n==2)
			{
				long long a,b;
				cin>>a>>b;
				if(a>b)
				{
					if(k%2==1)
					{
						cout<<a+b;
					}
					else
					{
						cout<<a*2;
					}
				}
				else
				{
					if(k%2==0)
					{
						cout<<a+b;
					}
					else
					{
						cout<<b*2;
					}
				}
				cout<<endl;
				continue;
			}
			else
			{
				for(long long i=1;i<=n;i++)
				{
					long long a;
					cin>>a;
					maxx=max(maxx,a);
				}
				ans=maxx*n;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

提交！AC！

---

## 作者：sunhaozhe111022 (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P11309)

**思路：**

我们发现想要使总观赏度的值最大我们就需要**将美丽度最大的樱花放在最前面**，也就是说使用一次交换次数，将美丽度最大的樱花放在最前面，剩下的交换次数在后面随便交换，最后求值输出即可。

但是有两种特殊情况：

- 交换次数为 $0$ 次。

   **直接求值即可。**

- 樱花个数等于 $2$ 。

    如果交换次数为奇数，则交换两个樱花，然后求值。

  如果交换次数为偶数，直接求值即可。


**代码：**
```
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,a[1000005],sum,ma;
int main()
{
	cin>>t;
	while(t--)
	{
		ma=sum=0;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			ma=max(ma,a[i]);
			sum+=ma;
		}
		if(m==0) cout<<sum<<endl;
		else if(m!=0&&n>=3) cout<<ma*n<<endl;
		else
		{
			if(m%2==0)
			{
				if(a[1]>a[2])
				cout<<a[1]*2<<endl;
				else
				cout<<a[1]+a[2]<<endl;
			}
			else
			{
				if(a[1]>a[2])
				cout<<a[1]+a[2]<<endl;
				else
				cout<<a[2]*2<<endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 题意简述
给出一个长度为 $n$ 的数组（我们将它设为 $a$），进行正好 $k$ 次交换使得 $\sum\limits_{i=1}^n\max_{j=1}^ia_j$  最大。
## 思路
首先我们写一个`print`函数：

我们定义一个变量 $ma$，表示 $a_i$ 之前的（包括 $a_i$）最大值，每次加到结果里就行了！

然后我们来逐个分析以下表格：
|测试点编号|$n$|$k$|
|:-:|:-:|:-:|
|$1$|$\le50$|$=0$|
|$2$|-|$=0$|
|$3\sim4$|$\le50$|$=1$|
|$5\sim7$|-|$=1$|
|$8\sim10$|-|-|
* 当 $k=0$ 时：
  * 不能交换任何元素，因此直接计算并输出原始序列的观赏度总和。
  * 调用`print`。
* 当 $n=2$ 时：
  * 如果 $k$ 是奇数，则交换这两个元素，因为交换一次就可以使较大的元素先出现，从而可能增加观赏度。
  * 如果 $k$ 是偶数，则不交换，因为交换偶数次后数组会恢复原状。
  * 调用`print`。
* 当 $n>2$ 且 $k>0$ 时：
  * 尝试将数组中最大的元素移动到第一个位置，我们遍历数组，将 $a_i$ 与 $a_1$ 进行比较，如果 $a_i>a_1$ 就交换这两个元素。
  * 调用`print`。

**十年 OI 一场空，不开`long long`见祖宗！**
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e5+5;
ll a[maxn],T,n,k;
void print(){
	ll res=0,ma=INT_MIN;
	for(ll i=1;i<=n;i++) ma=max(ma,a[i]),res+=ma;
	cout<<res<<'\n';
}
int main(){
	cin>>T;
	while(T--){
		cin>>n>>k;
		for(ll i=1;i<=n;i++) cin>>a[i];
		if(!k) print();
		else if(n==2){
			if(k%2) swap(a[1],a[2]);
			print();
		}else{
			for(ll i=2;i<=n;i++){
				if(a[i]>a[1]) swap(a[i],a[1]);
			}
			print();
		}
	}
}
```

---

## 作者：Pollococido (赞：0)

### 题目大意

**多测**。给定长度为 $n$ 的数组 $a$，进行**正好** $k$ 次交换最大化 $\sum\limits_{i=1}^{n} \max\limits_{j=1}^{i} a_j$。

### 解题过程

分三种情况。

#### 第一种

$k = 0$ 时，模拟即可。

```cpp
int x = a[1];
for (int i = 1; i <= n; i++) {
	x = max(x, a[i]);
	cur += x;
}
```

#### 第二种

$n = 2$ 时，根据 $k$ 的奇偶性判断 + 模拟即可。

发现当 $k \nmid 2$ 时，两数交换，$\nmid$ 表示不整除。

接下来，若大数在前答案为 $a_1 \times 2$，否则，答案为 $a_1 + a_2$。

```cpp
long long cur = 0;
if (k % 2 == 1) swap(a[1], a[2]);
if (a[1] >= a[2])
	cur = a[1] * 2;
else
	cur = a[1] + a[2];
```

#### 第三种

其他情况。

我们看样例 1 第 3 组数据，发现最优交换是将 $5$ 换到第 $1$ 个位置，其余的交换只要保证不把 $5$ 换到其他位置就行。因此，我们仅需输出 $n \times \left(\max\limits_{i=1}^{n} a_i\right)$ 即可。

### 代码

```cpp
//
// Created by CoderXc on 2024/11/23.
//
#include <bits/stdc++.h>
using namespace std;
int t, n, k;
int a[100010];

int main() {
	cin >> t;
	while (t--) {
		long long cur = 0;
		cin >> n >> k;
		for (int i = 1; i <= n; i++) {
			cin >> a[i];
		}
		if (k == 0) {
			int x = a[1];
			for (int i = 1; i <= n; i++) {
				x = max(x, a[i]);
				cur += x;
			}
			cout << cur << endl;
		} else if (n == 2) {
			if (k % 2 == 1) swap(a[1], a[2]);
			if (a[1] >= a[2])
				cur = a[1] * 2;
			else
				cur = a[1] + a[2];
			cout << cur << endl;
		} else {
			int x = *max_element(a + 1, a + n + 1);
			cout << 1ll * x * n << endl;
		}
	}
}
```

---

## 作者：Vct14 (赞：0)

题意：给出一个长度为 $ n $ 的数组，进行正好 $ k $ 次交换使得 $ \sum_{i=1}^n \max\limits_{j=1}^ia_j $  最大。求最大值。

$k=0$ 时直接计算即可。

$k\ne 0$ 时，显然只要能第一次交换把最大值放到最前面，然后不断交换除最大值以外的数即可。答案就为 $n\max\limits_{i=1}^na_i$。

考虑什么时候没法不断交换除最大值以外的数。容易想到 $n=2$ 时除最大值以外只有一个数，此时最终数列可以由 $k$ 的奇偶性唯一确定，特判一下即可。

于是这道题就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100002];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t;cin>>t;
	while(t--){
		int n,k;cin>>n>>k;
		int s=0,mx=-1;
		for(int i=1; i<=n; i++){
			cin>>a[i];
			mx=max(mx,a[i]);
			s+=mx;
		}
		if(n==2){
			if(k%2) swap(a[1],a[2]);
			cout<<a[1]+max(a[1],a[2])<<"\n";
			continue;
		}
		if(!k){
			cout<<s<<"\n";
			continue;
		}
		cout<<n*mx<<"\n";
	}
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：0)

一道小分讨。

坑点在于交换可以**不相邻**且不能**自己交换**。

观察到只要 $k \ge 1$ 就一定能将最大值换到最前面，剩下的随便换就行。但 $n=2$ 是例外，此时没有剩余可交换的，手动特判 $k$ 的奇偶性即可。

若 $k=0$，则直接计算答案。

整合即可得出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t, n, k, a[100005];
int main(){
	cin >> t;
    while(t --){
        cin >> n >> k;
        for(long long i = 1; i <= n; i ++) cin >> a[i];
        if(n == 2){//特判 n = 2
            if(k & 1){//奇数相当于换一次
                swap(a[2], a[1]);
                if(a[1] > a[2]) cout << a[1] * 2 << "\n";
                else cout << a[1] + a[2] << "\n";
                continue;
            }
            else{//反之相当于没换
                if(a[1] > a[2]) cout << a[1] * 2 << "\n";
                else cout << a[1] + a[2] << "\n";
                continue;
            }
        }
        if(k != 0){//最大值换到最前面
            long long maxn = 0;
            for(long long i = 1; i <= n; i ++) maxn = max(maxn, a[i]);
            cout << maxn * n << "\n";
        }
        else{//无法操作，直接计算
            long long sum = 0, maxn = 0;
            for(long long i = 1; i <= n; i ++) maxn = max(maxn, a[i]), sum += maxn;
            cout << sum << "\n";
        }
    }
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
分类讨论题。
1. 当 $k = 0$ 时，  
  测试点 $1,2$，因为无法交换，直接用前缀最大值并相加求出答案即可。
2. 当 $k \ne 0$ 时，
  容易发现，我们只需要尽可能使最大值在第一个即可，于是继续分类讨论：
    1. 当 $k$ 为奇数时：  
      首先容易发现，**当最大值不为第一个数时，就一定可以把第一个数换成最大值**，具体方法为，把第一个数和最大值换奇数次，这样第一个数就能换成第一个数了。
      而当第一个数即为最大值时，**只要长度 $\ge 3 $，也可以使第一个数为最大值**，即把所有次数都用在后面的数上，不影响第一个数。  
      在其他的情况里，由于 $k \le 2$，所以直接把两数颠倒求值即可。
    3. 当 $k$ 为偶数时：
      可以用上面一样的策略，这里就不写了，留给读者自行思考。
       
## CODE：
```cpp
#include <iostream>
using namespace std;
long long t, n, k, mx, ans, a[100001], s[100001];
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> n >> k;
        s[0] = 0;
        for (int i = 1; i <= n; i++) 
        {
            cin >> a[i];
            s[i] = max(s[i - 1], a[i]);
            ans += s[i];
            mx = max(mx, a[i]);
        }
        if (k == 0) cout << ans << '\n';
        else 
        {
            if (k & 1) 
            {
                if (a[1] != mx || n >= 3) cout << mx * n << '\n';
                else cout << a[2] + max(a[1], a[2]) << '\n';
            }
            else 
            {
                if (a[1] == mx || n >= 3) cout << mx * n << '\n';
                else cout << a[1] + max(a[1], a[2]) << '\n';
            }
        }
        ans = mx = 0;
    }
    return 0;
}
```

---

## 作者：LittleAcbg (赞：0)

当 $n\ge3$ 时，可以通过第一步操作，把最大的一项交换到数组开头，剩余操作任意交换后面 $n-1$ 个元素，不会改变答案。显然，当最大的一项是 $a_1$ 时总观赏度最大。

当 $n=2$ 时，只能交换这两项恰好 $k$ 次，无论 $a_1$ 是否最大。

对每个数组，先判断 $n=2$ 的情况，按照 $k$ 的奇偶性交换 $a_1,a_2$。

如果 $n\ge3$，按照 $k$ 是否为 $0$ 分类。

若 $k=0$，不能交换；否则交换 $\displaystyle\max_{i=1}^n a_i$ 和 $a_1$。

交换到最优情况后，扫一遍得到答案。具体细节见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+9;
int n,k,a[N];
void mian()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    if (n == 2) {if (k & 1) swap(a[1], a[2]);} // 特判 n=2
    else if (k) swap(*max_element(a + 1, a + n + 1), a[1]); // n>=3 且 k>=1，直接交换
    ll ans = 0;
    int mx = 0; // 换到最优后直接扫一遍算答案
    for (int i = 1; i <= n; ++i) ans += mx = max(mx, a[i]);
    printf("%lld\n", ans);
}
int main()
{
    int t;
    scanf("%d", &t);
    while (t--) mian(); // 多组测试处理
    return 0;
}
```

---


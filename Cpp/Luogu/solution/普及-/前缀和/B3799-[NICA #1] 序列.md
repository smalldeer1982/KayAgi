# [NICA #1] 序列

## 题目描述

小 A 有一个长度为 $n$ 的序列 $a_1,a_2,\dots a_n$。他希望支持两种操作：

- `1 k`，给序列中的每一个元素加上一个整数 $k$；
- `2`，查询序列中的最大子序列和。

子序列指的是从原序列中去除某些元素（也可以不去除），但不破坏余下元素的相对位置形成的新的序列。例如，对于序列 $\{2,3,4,5,6\}$，那么 $\{2,3,4\},\{2,4,6\}$ 都是它的子序列，而 $\{6,5,4\}$ 不是。子序列可以为空，此时子序列和为 $0$。

## 说明/提示

**【样例解释】**

- 第一次操作求序列中的最大子序列和，则为 $12+2+8=22$；
- 第二次操作让序列中每一个元素加上了 $3$。此时序列变为 $-2,15,-4,5,11$；
- 第三次操作求序列中的最大子序列和，则为 $15+5+11=31$；
- 第四次操作让序列中每一个元素加上了 $4$。此时序列变为 $2,19,0,9,15$；
- 第五次操作求序列中的最大子序列和，则为 $2+19+9+15=45$。

数据保证，$1 \leq n,m \leq 5\times 10^5$，$-5\times 10^5 \leq a_i,k \leq 5\times 10^5$，操作仅为 $1$ 或 $2$ 操作。

## 样例 #1

### 输入

```
5 5
-5 12 -7 2 8
2
1 3
2
1 4
2```

### 输出

```
22
31
45```

# 题解

## 作者：2011FYCCCTA (赞：13)

# [原题](https://www.luogu.com.cn/problem/B3799)
细节决定成败。

---
### 分析&思路

要先明确一点：操作 2 就是让求出序列 $a$ 中的正整数之和（因为如果是负数则会让结果变小）。

---
一个暴力的做法是：
- 对于操作 1，用一个变量记录所需加上的数字之和。
- 对于操作 2，遍历一遍序列 $a$，将其中的每一项加上在当前操作之前所需加上的数字之和，判断这个数是否大于 $0$，是则在最终结果中加上此数，否则不加。

最坏情况下，这种方法的时间复杂度为 $O(mn)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m , a[500005] , opt , k;
long long add , ans;
int main()
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i++) cin >> a[i];
    while (m--)
    {
        cin >> opt;
        if (opt == 1) {cin >> k; add += k;}
        else
        {
            ans = 0;
            for (int i = 1 ; i <= n ; i++)
                if (a[i] + add > 0) ans += a[i] + add;
            cout << ans << endl;
        }
    }
    return 0; 
}
```
[评测记录](https://www.luogu.com.cn/record/114641324)

不出所料，T 了 6 个点。

考虑优化。

---
操作 1 无需优化，来看操作 2。

对于操作 2，很容易想到一种基于暴力的优化：

1. 对序列 $a$ 排序。
2. 二分查找第一个大于 0 的数的下标，计为 $p$。
3. 累加序列 $a$ 中从下标为 $p$ 的数字到最后一个（预处理前缀和）。

这样优化的时间复杂度最坏为 $O(m \log n)$，空间复杂度为 $O(n)$。

**注意：**

1. **开 `long long`。**
2. **$p$ 要初始化成 $n + 1$（如果没有比 $0$ 大的数就会输出 $0$）。**
3. **本题中所用的前缀和是倒序的。**

---
### 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n , m , a[500005] , opt , k , sum[500005] ,  add , ans;
signed main()
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i++) cin >> a[i];
    sort(a + 1 , a + n + 1);
    for (int i = n ; i >= 1 ; i--) sum[i] = a[i] + sum[i + 1];//倒序的前缀和
    while (m--)
    {
        cin >> opt;
        if (opt == 1) {cin >> k; add += k;}
        else
        {
            int p = n + 1;//这里的初始化很关键！
            int l = 1 , r = n , mid;
            while (l <= r)
            {
                mid = (l + r) / 2;
                if (a[mid] + add > 0) {p = mid; r = mid - 1;}
                else l = mid + 1;
            }
            ans = sum[p] + (n - p + 1) * add;
            //最后将大于0的数统一加上在当前操作之前所需加上的数字之和。
            cout << ans << endl;
        }
    }
    return 0; 
}
```
[评测记录](https://www.luogu.com.cn/record/114658740)

---

## 作者：Light_az (赞：6)


# 题意

给一个序列，现在有一下两种操作：

- 将整个序列的值加上 $k$。

- 求整个序列的正整数的和。

# 分析

对于数据范围，我们发现不能采用暴力解法，因此我们进行优化。

以下内容的变量名分别代表：

$last$：目前序列最大的负数下标。

$num$：目前序列中有多少个正数（包括零）。

$cnt$：目前序列添加值的总和。

$k$：操作 $1$ 的添加值。

下面进行分类讨论：

当 $k$ 为正数时，因为正整数加正整数一定不变，所以序列正整数的总和一定会添加 $num \times k$。

当然有些负数会随着 $cnt$ 的增大最后变成正数，所以我们要从最大的负数向后枚举，如果 $a_{last} + cnt \ge 0 $，那么说明有负数变成正数，因此我们将 $num$ 增加，并且把答案加上 $a_{last} + cnt $ 的值，因为负数会抵消掉 $cnt$ 的一些值，所以我们不能直接添加，最后将 $last$ 后移。


当 $k$ 为负数时，首先我们要判断最小的正整数（即 $a_{last-1}$）是否会变成负数，如果 $a_{last-1} + cnt + k < 0$，那么说明有正数变成负数， 因此我们要减去这个正数的值，即 $a_{last-1} + cnt$ 的值，然后将 $num$ 的数量减少，$last$ 前移即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define D double
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e6+10;
ll n,m,k,x,y,u,v,w,cnt,ans,t,l,r,len,T,id,sum,num,last=1;
ll mn=INT_MAX,mx=0,p,opt;
ll a[N];
bool cmp(ll a,ll b){
	return a>b;
}
int main(){
	cin>>n>>m;
	F(i,1,n) cin>>a[i];
	sort(a+1,a+1+n,cmp);//排序保证数据不上升
	F(i,1,n){
		last=i;//记录最大负数
		if(a[i]<0) break;
		num++;
		sum+=a[i];
	}
    if(a[last]>=0) last++;//特判
	F(i,1,m){
		cin>>opt;
		if(opt==1){
			cin>>k;
			while(last-1>=1&&a[last-1]+cnt+k<0) num--,sum-=a[last-1]+cnt,last--;
            //注意优先级，因为 num*k 要保证全是正数，而由于 k 可能是负数导致 num 减少
            //因此先判断负数的情况，减去答案贡献
            //cnt不先加k 是因为 a[last-1]+cnt>0，而a[last-1]+cnt+k<0
            //所以答案减去正数的贡献应该是 a[last-1]+cnt
			cnt+=k;//累计添加操作
			sum+=num*k;//懒惰操作
			while(last<=n&&a[last]+cnt>=0) num++,sum+=a[last]+cnt,last++;
         //有负数变成正数，下标后移
		}
		else cout<<sum<<"\n";
	}
	return 0;
}
```

# Hack

感谢 [MicroSun ](https://www.luogu.com.cn/user/514700) 指出，当整个数列都是正整数时，$last$ 指向了 $n$ 下标，我们只需要特判即可。


---

## 作者：Light_az (赞：3)

# 题意

现在给你一个长度为 $n$ 的数列，支持以下操作：

- 将 $n$ 个数全部加上 $k$。

- 求 $n$ 个数中非负数的总和。

# 分析

观察数据范围发现桶可做，首先我们定义 $ans$ 为添加操作 $k$ 的总和，$sum$ 为数列值的前缀和，$cnt$ 为数量的前缀和，那么由于数据 $-5 \times 10^5 \leq a_i \leq 5 \times 10^5$，所以：

- 当 $5 \times 10^5 \leq ans$ 时，数列中全部数都是非负数，累加和操作即可。

- 当 $ans \leq -5 \times 10^5 $ 时，数列中全部数都是负数，直接输出 $0$ 即可。

- 当 $-5 \times 10^5 \leq ans \leq 5 \times 10^5$ 时，此时**原始状态**的数列中，范围在 $[-ans,5 \times 10^5]$ 中的数在加上 $ans$ 都是非负数，预处理前缀和求出该区间总值以及数的个数并输出即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define D double
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10;
ll n,m,k,x,y,u,v,w,ans,t,l,r,len,T,id;
ll mn=INT_MAX,mx=0,p,opt;
ll cnt[N],sum[N];
int main(){
    Test;
	cin>>n>>m;
	F(i,1,n){
		cin>>x;
		cnt[500000+x]++;//考虑有负数，加上 500000 防止越界
		sum[500000+x]+=x;
	}
	F(i,0,1000000) cnt[i]+=cnt[i-1],sum[i]+=sum[i-1];//处理数量以及总值的前缀和
	F(i,1,m){
		cin>>opt;
		if(opt==1) cin>>k,ans+=k;
		else{
			if(ans>500000) cout<<sum[1000000]+ans*cnt[1000000]<<"\n";//第一种情况
			else if(ans<-500000) cout<<0<<"\n";//第二种情况
            else cout<<sum[1000000]-sum[500000-ans]+ans*(cnt[1000000]-cnt[500000-ans])<<"\n";//最后一种
		}
	}
	return 0;
}


```


---

## 作者：lrqlrq250 (赞：3)

## 题意简述

你有一个长度为 $n$ 的序列，你要维护两种操作：

- 全局加 $k$（可能为负数）。

- 询问当前序列的最大子序列和（子序列可以为空）。

## 解题思路

首先，不难发现题目要求的最大子序列和就是序列中所有非负数的和。

其次，全局加并不好维护，这时比较普遍的想法应该是只维护全局加的累计值 $delta$，然后在每次询问时尝试通过 $delta$ 来选序列中的数。

这时发现两个（其实很显然的）性质：

- 如果一个数 $a_i$ 被选入最大子序列中，则所有不小于 $a_i$ 的数一定同样入选。

- 一个数 $a_i$ 当前入选的充要条件是 $a_i + delta \geq 0$。

证明显然，此处略去。

因此我们考虑先将原序列从小到大排序，维护好全局 $delta$，在询问时，**二分**找出序列从左到右第一个满足 $a_i \geq -delta$ 的 $a_i$（由第二个性质变形可得），这时排好序的序列中所有大于等于（即在 $a_i$ 后面）它的数都是非负整数。因此再提前预处理后缀和 $sum_i$，答案即为 $sum_i + (n-i+1) \times delta$。

总时间复杂度为 $O(n+m \log n)$。

### TIPS

二分可以用 `lower_bound` 函数，不用手写邪恶的二分。

别忘了开 `long long`。

## AC Code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 500005;
int n, m;
ll a[N], sum[N], delta;


int main(){
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) scanf("%lld", &a[i]);
	stable_sort(a + 1, a + n + 1);
	for (int i=n; i; i--) sum[i] = sum[i + 1] + a[i];//维护后缀和
	int op, k, p;
	while (m--){
		scanf("%d", &op);
		if (op == 1){
			scanf("%d", &k);
			delta += k;
		}
		else{
			p = lower_bound(a + 1, a + n + 1, -delta) - a;
			if (p == n + 1) printf("0\n");//没有正整数就一个数都不选
			else printf("%lld\n", sum[p] + (n - p + 1) * delta);
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

[原题](https://www.luogu.com.cn/problem/B3799)。


解题思路：

这题需要使用二分。

操作一：

因为变量 $k$ 是做用于整个数组的，所以我们定义一个变量 $now$，用来记录每次的增量，如果想修改元素就 $now+k$，就行了。

操作二：

先给数组排序，元素定会单调递增，往后定是整数。

这就可以用二分搜索。

那什么是二分搜索呢？

二分搜索的思想是这样的：

[点这里](https://blog.csdn.net/qq_44096670/article/details/111768372)。

证明省略。

再预处理 $sum$ 的后缀和，答案就是 $sum_i+(n-i+1)\times now$。

如果 $ans$ 等于 $-1$，输出 $0$，否则输出 $sum[ans]+ans\times now$。

核心代码：

```
cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];//后缀和 
    while(m--){
        cin>>op;
        if(op==1)
        {
            cin>>k;
            now+=k;
        }
        else
        {
            l=1;r=n;
            ans=-1;
            while(l<=r){
                mid=(l+r)/2;
                if(a[mid]+now>0)
                {
                    l=mid+1;    
                    ans=mid;
                
                }
                else r=mid-1;
            }
            if(ans==-1)cout<<"0"<<endl;//没有就不选 
            else cout<<sum[ans]+ans*now<<endl;
        }
    }
    return 0;
}
```


---

## 作者：Light_az (赞：2)

# 题意

有两种操作：

- 将 $n$ 个数全部添加 $k$。

- 求 $n$ 个数的非负数和。

# 分析

这道题目显然二分才是最优解。

我们考虑使用变量 $cnt$ 记录增加值总和，然后先进行排序，保证数据递减，然后二分从 $n$ 个数中找到最小的 $a_i$ 使 $a_i + cnt$ 为非负数。

此时包括 $a_i$ 及其前面的值都是非负数，然后累加求出答案。

但是考虑数据范围我们添加前缀和优化，先预处理求出 $n$ 个数的前缀和，然后由于有添加操作，所以我们将答案加上：非负数个数 $\times cnt$ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define D double
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e6+10;
ll n,m,k,x,y,u,v,w,cnt,ans,t,l,r,len,T,id;
ll mn=INT_MAX,mx=0,p,opt;
ll a[N],sum[N];
bool cmp(ll a,ll b){
	return a>b;
}
ll get(){//二分
	ll ans=-1,l=1,r=n;
	while(l<=r){
		ll mid=(l+r)/2;
		if(a[mid]+cnt>0) ans=mid,l=mid+1;//最小的非负数
		else r=mid-1;
	}
	return ans;
}
int main(){
    Test;
	cin>>n>>m;
	F(i,1,n) cin>>a[i]; 
	sort(a+1,a+1+n,cmp);//排序保证二分
	F(i,1,n) sum[i]=sum[i-1]+a[i];//前缀和
	F(i,1,m){
		cin>>opt;
		if(opt==1) cin>>k,cnt+=k;//累加
		else{
			id=get();
			if(id==-1) cout<<"0\n";//如果没有非负数，不选择
			else cout<<sum[id]+id*cnt<<"\n";//前缀和加上累计添加的值 * 非负数个数
		}
	}
	return 0;
}

```


---

## 作者：_xm_ (赞：1)

[**B3799 \[NICA #1**\] 序列](https://www.luogu.com.cn/problem/B3799)

# 题意描述

小A 有一个长度为 $n$ 的序列 $a_1,a_2...a_n$。他希望支持两种操作，并操作 $m$ 次：

* `1 k`，给序列中的 **每一个** 元素加上一个整数 $k$。
* `2`，查询序列中的 **最大子序列和**。

# 题解分析

## 操作一：

首先分析操作一。由于增量 $k$ 是作用在**整个数组**上的，我们可以把每次的增量记录到 $delta$ 里，想访问修改后的元素用 $a[i]+delta$ 即可。

```cpp
记录增量 : delta += k
访问元素 : a[i] + delta
```

时间复杂度：$O(1)$


## 操作二：

然后是操作二：求最大序列和。研究样例可以发现问题等价于求序列中的**正数和**。那么问题就转化成：

```
「如何快速求序列的正数和?」

```

我们先将数组排序，元素单调递增，可发现数组一定会从某一个地方开始，往后的元素全部是正数。

序列满足单调性，我们便想到二分搜索。二分出正负分界点 $x$，设 $x$ 是满足 $a[i]+delta>0$ 的最小的 $i$，也就是数组中第一个正数的下标。区间 $[x,n]$ 就是序列中的所有正数，则答案就是区间 $[x,n]$ 的和：

$$(a[x]+delta)+(a[x+1]+delta)+...+(a[n]+delta)$$

又因为操作一对整个序列增加同一个增量，不影响数组的有序性，我们只需要排序一次就可以一劳永逸。

为了加快速度，预处理数组 $a$ 的前缀和。

$$(a[x]+delta)+(a[x+1]+delta)+...+(a[n]+delta)$$

$$=sum[n]-sum[x-1]+(n-x+1) \times delta$$

时间复杂度：$O(\log n)$


# 代码

$O(n \log n + m \log n)$

PS：亦可使用线性排序优化至 $O(n+m \log n)$

```cpp
// by xm
// 2023.6.20
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 5e5 + 10;

int n, m, a[N];
ll sum[N], delta = 0;

int BinarySearch() { // 返回数组第一个正数的下标
	int l = 0, r = n + 1;
	while(l + 1 != r) {
		int mid = (l + r) / 2;
		if(a[mid] + delta <= 0) {
			l = mid;
		}
		else {
			r = mid;
		}
	}
	return r;
}

int main() {
	scanf("%d%d", &n, &m); // 输入
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	
	sort(a + 1, a + n + 1); // 排序, 可以手写O(n)的排序, 我就不写了
	for(int i = 1; i <= n; i++) { // 排序后前缀和
		sum[i] = sum[i - 1] + a[i];
	}
	
	int op, k;
	for(int i = 1; i <= m; i++) {
		scanf("%d", &op);
		if(op == 1) {
			scanf("%d", &k);
			delta += k; // 记录增量
		}
		if(op == 2) {
			int x = BinarySearch(); // 获取第一个正数的下标
			ll ans = sum[n] - sum[x - 1] + (n - x + 1) * delta;
			printf("%lld\n", ans);
		}
	}
	
	return 0;
}
```

---

## 作者：ZHANGyutao123 (赞：0)

## [B3799 [NICA #1] 序列](https://www.luogu.com.cn/problem/B3799)
## 题目大意
给定一个长度为$n$的序列，支持两种操作：
- `1 k`，给序列中的每一个元素加上一个整数 $k$；
- `2`，查询序列中的最大子序列和。

输出每个$2$操作的结果并换行。
## 过程分析
题解：

这道题目是一个模拟题，需要根据给定的操作对序列进行处理，并求解最大子序列和。

首先，我们读取输入并初始化序列，将其存储在一个向量中。然后，对序列进行排序，以便使用二分查找。

接下来，我们需要维护一个 $delta$ 变量，用于记录之前的操作1所增加的值。对于每个操作，如果是操作1，我们读取 $k$ 值并将其添加到 $delta$ 上；如果是操作2，我们需要根据当前序列和 $delta$ 计算最大子序列和。

在计算最大子序列和时，我们使用 $ \texttt{lower\_bound}$ 函数来查找序列中大于等于 $-delta$ 的第一个元素的位置 $p$。如果 $p$ 等于序列长度+1，即没有元素大于等于 $-delta$，则最大子序列和为0；否则，我们利用后缀和数组 $\texttt{suffixSum}$ 来计算最大子序列和。

具体地，我们可以得到的结论是，对于序列中的每个元素 $ a_i $，如果其值大于 $-delta$，它可以被选择到子序列中；而如果其值小于等于 $-delta$，它不应该被选择到子序列中。因此，我们可以计算出从位置 $p$ 开始的子序列和为 $\texttt{suffixSum}[p] + (n - p + 1) \cdot delta$。

最后，我们输出最大子序列和即可。

## 代码实现如下：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    
    vector<long long> elements(n + 1);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &elements[i]);
    }
    
    stable_sort(elements.begin() + 1, elements.end());
    
    vector<long long> suffixSum(n + 2);
    for (int i = n; i >= 1; i--) {
        suffixSum[i] = suffixSum[i + 1] + elements[i];
    }
    
    int operation, k, p;
    long long delta = 0;
    while (m--) {
        scanf("%d", &operation);
        if (operation == 1) {
            scanf("%d", &k);
            delta += k;
        } else {
            p = lower_bound(elements.begin() + 1, elements.end(), -delta) - elements.begin();
            if (p == n + 1) {
                printf("0\n");
            } else {
                printf("%lld\n", suffixSum[p] + (n - p + 1) * delta);
            }
        }
    }
    
    return 0;
}
```


---


# [GESP202406 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。

## 说明/提示

**【样例解释】**

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。

**【数据范围】**

对于全部数据，保证有 $1\leq n,m\leq 10$。

## 样例 #1

### 输入

```
4 5
00000
01111
00011
00011```

### 输出

```
16```

# 题解

## 作者：chen_zhe (赞：40)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

先简化问题：如果我们有一个矩形，其左上角顶点为 $(xa,ya)$（即第 $xa$ 行第 $ya$ 列），右下角顶点为 $(xb,yb)$（即第 $xb$ 行第 $yb$ 列），我们如何判断这个矩形范围中 $0$ 和 $1$ 的数量相等呢？

这个问题可以使用二重循环解决，参考代码如下：

```cpp
bool check(int xa, int ya, int xb, int yb) {
	int a[2] = {0, 0};
	for (int i = xa; i <= xb; i++) {
		for (int j = ya; j <= yb; j++)
			a[w[i][j]]++;
	}
	return a[0] == a[1];
}
```

在 `check` 函数中，使用了一个数组，利用“桶计数”思想统计了范围中的 $0$ 和 $1$ 的个数。如果返回值为 true，则说明矩形中 $0,1$ 个数相等，否则不相等。

回到原本的问题中来。如果我们能够对每一个“子矩形”进行 `check`，判断每个子矩形中 $0$ 和 $1$ 的个数是不是相等，问题就解决了。那么我们如何枚举子矩形呢？我们可以使用四个 for 循环。即：使用两个 for 循环枚举矩形左上角顶点 $(i,j)$，使用两个 for 循环枚举矩形右下角顶点 $(i_1,j_1)$。接着，我们将这个区域使用 `check(i,j,i1,j1)` 判断区域内是否 $0,1$ 个数相等。

这个矩形的大小怎么统计呢？自然是 $(i_1-i+1)\times (j_1-j+1)$ 了。我们找到最大的子矩形输出即可。

```cpp
int ans = 0;
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
		for (int ii = i; ii <= n; ii++) {
			for (int jj = j; jj <= m; jj++) {
				if (check(i, j, ii, jj))
					ans = max(ans, (ii - i + 1) * (jj - j + 1));
			}
		}
	}
}
cout << ans << endl;
```

思考题：上述做法的时间复杂度是 $O(n^6)$ 的，它使用了六重循环嵌套。你是否有方法将其优化到不超过 $O(n^4)$ 的复杂度呢？

---


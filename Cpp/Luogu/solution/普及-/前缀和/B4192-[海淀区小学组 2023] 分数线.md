# [海淀区小学组 2023] 分数线

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

为更好区分不同做法，本题时限下调到 500 毫秒。

## 题目描述

一次比赛中，所有参加比赛的选手都获得了一个分数 $ s $。已知有 $ c_1 $ 个同学得 $1$ 分，$ c_2 $ 个同学得 $2$ 分，……，$ c_m $ 个同学得 $ m $ 分。

请你划定一个分数线 $ k $，使得不低于分数线 $ k $ 的人数 $ n_1 $ 和低于分数线 $ k $ 的人数 $ n_2 $ 均在给定的一个范围 $[x, y]$ 之内，即 $ x \leq n_1 \leq y $，$ x \leq n_2 \leq y $。

保证 $ s $ 和 $ k $ 一定是整数，且 $ 1 \leq s \leq m $，$ 1 \leq k \leq m $。

## 说明/提示

### 样例解释

在样例 $1$ 中，如果把分数线划定为 $3$，则有 $7$ 个学生低于分数线，$6$ 个同学不低于分数线，人数都在 $[6,8]$ 范围内。在样例 $2$ 中，分数线划定为 $3$ 和 $4$ 都可以，但按照题目的要求应该输出更小的答案，应该是 $3$。

### 数据范围

对于 $50\%$ 的数据，$ 2 \leq m \leq 100 $，$ 0 \leq c_i \leq 100 $，$ 1 \leq x \leq y \leq 10000 $。

对于 $100\%$ 的数据，$ 2 \leq m \leq 10^5 $，$ 0 \leq c_i \leq 10^5 $，$ 1 \leq x \leq y \leq 10^9 $。


## 样例 #1

### 输入

```
5
3 4 3 2 1
6 8```

### 输出

```
3```

## 样例 #2

### 输入

```
5
0 3 3 4 2
3 10```

### 输出

```
3```

## 样例 #3

### 输入

```
2
2 5
3 6```

### 输出

```
0```

# 题解

## 作者：no_response (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/B4192)
## 解题思路
一道**前缀和**加判断题目。  

通过前缀和求出分数小于 $i$ 的人数。  
接着枚举每一个分数线，若在范围内，则输出并结束程序。  
否则无解，输出零。
### 细节
```cpp
#define int long long
signed main() {
```
## AC CODE
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int c[100010], ans[100010];
signed main() {
	int m;
	cin >> m;
	for (int i = 1; i <= m; i++) { //前缀和
		cin >> c[i];
		ans[i] = ans[i - 1] + c[i];
	}
	int x, y;
	cin >> x >> y;
	for (int i = 2; i <= m; i++) { //判断
		if (ans[i - 1] >= x && ans[i - 1] <= y && ans[m] - ans[i - 1] >= x && ans[m] - ans[i - 1] <= y) {
			cout << i;
			return 0;
		}
	}
	cout << 0;
	return 0;
}
```
为保持洛谷的良好学习习惯，请勿抄袭。  
**千万别抄袭哦。**  
管理大大辛苦了，各位大佬给蒟蒻点个赞呗。

---

## 作者：Sliarae (赞：3)

首先可以枚举分数线为 $k$，那如果 $x \le \sum\limits_{i = 1}^{k - 1}c_i \le y \wedge x \le \sum\limits_{i = k}^{m} c_i \le y$ 就合法。如果这样暴力做，单次判断时间复杂度为 $O(n)$，总的时间复杂度就是 $O(n^2)$。

考虑后缀和优化，具体而言设 $s_k = \sum\limits_{i = k}^{m} c_i$，这个可以用递推的方法预处理，具体而言就是 $s_i = s_{i + 1} + c_i$。

此时发现题目中的条件可以 $O(1)$ 判断：如果 $x \le s_k \le y, x \le s_1 - s_k \le y$，那么 $k$ 做分数线就合法，把所有合法的 $k$ 求出来，输出最小的即可。

总时间复杂度 $O(n)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const int kN = 1e5 + 5;

int n, x, y;
LL s[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> s[i];
	cin >> x >> y; 
	for (int i = n; i; --i) s[i] += s[i + 1];
	for (int i = 1; i <= n; ++i)
		if (x <= s[i] && s[i] <= y && x <= s[1] - s[i] && s[1] - s[i] <= y)
			return cout << i << '\n', 0;
	cout << 0 << '\n';
	return 0; 
}
```

---

## 作者：XsIeEiKcEk (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4192)

## 题目大意

有一个长度为 $m$ 的序列 $c$，$c_i$ 代表值为 $i$ 的分数数量。要得出一个最小的 $j$ 使 $x\le\sum_{k=1}^{j-1} c_k,\sum_{k=j}^{m} c_k\le y$。如果不存在 $j$，输出 $0$。

## 解法

用前缀和将值 $\le i$ 的分数数量存入 $s_i$ 内，再一个一个枚举，成立就输出。

## [AC](https://www.luogu.com.cn/record/206356333) CODE
```cpp
#include<iostream>
using namespace std;
#define int long long//不开long long见祖宗
int m,c[100001],x,y,s[100001];//s如解法所示
signed main(){
    cin>>m;
    for(int i=1;i<=m;i++){//前缀和
        cin>>c[i];
        s[i]=s[i-1]+c[i];
    }
    cin>>x>>y;
    for(int i=2;i<=m;i++){//判断
        if(s[i-1]>=x&&s[i-1]<=y&&s[m]-s[i-1]>=x&&s[m]-s[i-1]<=y){
            cout<<i;
            return 0;
        }
    }
    cout<<0;//无解
    return 0;
}
```

---

## 作者：liwanxian (赞：1)

## 思路

首先暴力时间复杂度为 $O(n^2)$，肯定无法通过此题。

那么考虑前缀和解题。将 $qzh_{i-1}$ 定义为分数为 $i$ 的人数，也就是 $qzh_i = qzh_{i - 1} + c_i$。

最后枚举判断从 1 到 $m$ 的分数线，判断是否有满足条件的，如果有，输出分数线 $i$ 并直接返回，如果没有，输出 0。

坑点：`long long`。

## 实现代码

理解万岁，理解即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[100010],qzh[100010];
int main(){
	long long m;//记得开 long long 
	cin>>m;
	for(long long i=1;i<=m;i++){//前缀和
		cin>>c[i];
		qzh[i]=qzh[i-1]+c[i];
	}
	long long x,y;
	cin>>x>>y;
	for(long long i=1;i<=m;i++){//判断
		long long tmp=qzh[i-1],tmp1=qzh[m]-qzh[i-1];
		if(tmp>=x&&tmp<=y&&tmp1>=x&&tmp1<=y){
			cout<<i;
			return 0;
		}
	}
	cout<<0;
	return 0;
}
```

看记录点[我](https://www.luogu.com.cn/record/207453877)。

---

## 作者：Lyx8058 (赞：1)

#### 求求管理员给过吧！

## 思路：

模拟明显会超时，$10^{10}$ 你不超谁超。

那么就可以定义一个数组 $d_m$ 表示其下标为 $i$ 时**不大于** $i$ 的人数。

然后转移方程就是当 $1\leq i\leq m$ 时 $d_i=d_{i-1}+c_i$，默认 $d_i$ 初始值为 $0$。

当然，本题最大数字：$10^5\times10^5=10^{10}>2^{31}-1$，要开 long long，不然 $70$ 分（我帮大家测了）。

时间复杂度 $O(m)$。

## Code：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100001;
int m,c[N];
int d[N],x,y;
signed main(){
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>c[i];
		d[i]=c[i]+d[i-1];
	}
	cin>>x>>y;
	for(int i=1;i<=m;i++){
		int n2=d[i-1],n1=d[m]-d[i-1];
		if(n1>=x&&n1<=y&&n2>=x&&n2<=y){
			cout<<i<<"\n";
			return 0;
		}
	}
	cout<<"0\n";
	return 0;
}
```

---

## 作者：_lxc__ (赞：1)

首先暴力是无法通过的，时间复杂度 $O(n^2)$。

于是考虑前缀和。设 $s_i$ 为分数为 $i$ 的通过人数，即 $s_i=s_{i-1}+a_i$。

接着枚举每一个分数 $i$，判断低于分数线 $i$ 的人数与不低于分数线的人是否都在范围内。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int m,a[N],x,y,s[N];
signed main(){
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i];
        s[i]=s[i-1]+a[i];
    }
    cin>>x>>y;
    for(int i=1;i<=m;i++){
    	int q=s[i-1],p=s[m]-s[i-1];
    	if(q>=x&&q<=y&&p>=x&&p<=y){
    		cout<<i;
    		exit(0);
		}
    }
    cout<<0;
    return 0;
}
```

---

## 作者：DashZhanghanxu (赞：1)

# 解析
前缀和解题。

通过前缀和求出分数小于 $i$ 的人数。接着枚举每一个分数线，若在范围内，则输出并结束程序。若没有答案，则输出零。
# CODE
```cpp
#include<bits/stdc++.h>
//by Dashzhanghanxu
using namespace std;
#define ll long long
#define int long long
int c[100001],qz[100001];
signed main(){
    int m;
	cin>>m;
    for(int i=1;i<=m;++i){
	cin>>c[i];
	qz[i]=qz[i-1]+c[i];
	}
    int x,y;
	cin>>x>>y;
    for(int k=1;k<=m;++k){
        int n1=qz[m]-qz[k-1];
        int n2=qz[k-1];
        if(x<=n1&&n1<=y&&x<=n2&&n2<=y){
		cout<<k<<endl;
		return 0;
		}
    }
    cout<<0<<endl;
    return 0;
}

```

---

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/B4192)

### $\texttt{Solution}$

简单前缀和，$s_i$ 表示获得分数不大于 $i$ 的人数，那么 $s_m-s_i$ 就分数表示大于 $i$ 的人数。所以我们只需要从 $2$ 到 $m$ 枚举 $i$，如果 $s_i\in[x,y]$ 且 $s_m-s_i\in[x,y]$，那么 $i+1$ 就是我们要找的最小分数线。

注意本题需要使用 long long，不然会 WA 掉部分点。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e5 + 5;
int m, a[maxn], s[maxn];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> m;
	
	for (int i = 1; i <= m; i++) {
		cin >> a[i];
		s[i] = s[i - 1] + a[i];
	}
	
	int x, y;
	cin >> x >> y;
	
	for (int i = 2; i <= m; i++) {
		if (s[m] - s[i] >= x && s[m] - s[i] <= y && s[i] >= x && s[i] <= y) {
			cout << i + 1 << endl;
			return 0;
		}
	}
	
	cout << 0 << endl;
	return 0;
}
```

---

## 作者：Xiaonao_Dali (赞：0)

给大家介绍一种非常容易理解的代码，代码简单易懂，希望大家能认真读完。\
看着其他人发的题解，我发现我的思路和他们的不一样！那么我就来发一下题解吧。\
为保证能让各年龄段读懂，我将尽量以简洁的白话文尽可能让大家读懂，如果还有不懂的，可以私信联系我。
## 一、思路剖析
本题需要使用前缀和的思路去完成，我们在做这道题时,会发现每个分数段的人较多（~~当然，样例里肯定不会显示出来~~），如果不加前缀和的暴力很容易导致出错。\
我们先用前缀和计算出每个分数段的总人数，因为总人数不可能为负数，所以前缀和的数据总体呈上升趋势！\
算完以后开始前缀暴力，每个分数段进行一次比较，知道找到正好把这个分数的人去掉后，符合条件，把这个分数再次加一，就可以得出切分线。\
（注：所提供的思路均以我的正解代码出发）
## 二、核心代码讲解
这是进行一次暴力去求分数段的一个代码：
```cpp
    for(int i=1;i<m;i++){
        if(t[m]-t[i]>=x&&t[m]-t[i]<=y&&t[i]>=x&&t[i]<=y) {
            cout<<i+1;
            return 0;
        }
    }
```
此代码的作用：\
首先由于我们要找到标准分数线，我们就有反复遍历每个前缀是否满足条件 ```t[m]-t[i]``` 表示的是总人数减去该分数段之前包括这个分数段的所有人所剩下的人数，那么 ```t[i]``` 表示的是该分数段包含低于该分数段的所有人。至于为什么要输出 ```i+1```，因为我把这个分数段的人已经扣掉了！\
当然，如果说分数线切到所有人呢？这是不是也需要在考虑范围内呢？答案当然是需要的！因为我们不清楚当时造数据的人会将一个这样的测试点放进评测里，但是为了以防万一，还是需要加上特殊条件。（因为我所示的核心代码最小输出的是 $2$，若切到分数为 $1$，需要另加判断）。\
所以说，根据定义，我们可得如下代码的判定：
```cpp
if(x==0&&y>=t[m]) cout<<1;
```
解析：若切分线到 $1$ 时，代表全员均可进入切分线，那么根据题目要求，$x=0$ 才可以保证有满足的条件，那么当 $x=0$ 时，那么 $y$ 则需要满足 $y \ge t_m$ 时，才可使得该切分成立。
## 三、正解代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int m;
int a[100005],t[100005];
int x,y;
signed main(){
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i];
        t[i]=t[i-1]+a[i];
    }
    cin>>x>>y;
    if(x==0&&y>=t[m]) cout<<1;
    for(int i=1;i<=m;i++){
        if(t[m]-t[i]>=x&&t[m]-t[i]<=y&&t[i]>=x&&t[i]<=y) {
            cout<<i+1;
            return 0;
        }
    }
    cout<<0;
    return 0;
}
```
## 四、使用到的算法
### 前缀和
#### 使用这个算法的场景的例子
前缀和，我们可以这样理解，我们有 $n$ 个数，求第 $a$ 个到第 $b$ 个的和，这样往往需要用到前缀和。
#### 前缀和的优点
（1）在**数据长度不变**的时候，可以快速的运算第 $a$ 个数到第 $b$ 个数的总和。\
（2）前缀和你可以理解为一个记忆化，在遇到相同的区间总和问题是，前缀和将彰显它的优势。
#### 前缀和的缺点
（1）当数据过大时，前缀和往往会超出整型范围或长整型范围。\
（2）不灵活，若试图改变数组中任意一个数，前缀和值需要进行改变且耗时\
但是根据题意所述，第一点宏定义为长整型即可避免，而第二点无需考虑，因为这些数据已被定死，可以不用考虑。
### 前缀和的使用方法
在本题中，我们可以输入数组内一个数，让后进行前缀加和，在这种情况下，我们一般会从 $1$ 开始遍历，由于我将前缀和数组放到全局变量，所有阈值初始值为 $0$ 的值。所以从 $1$ 开始遍历，就无需考虑第一个数的前缀和特判。\
使用的时候比如需要从第 $a$ 个到第 $b$ 个进行求值，则我们可以找到这个数组的第 $b$ 项的前缀和值扣除第 $a$ 项的前缀和值。得出来的就是本题答案。
## 五、代码忠告以及建议
（1）养成好习惯，不要抄袭，你可以学习我的代码，但是你一旦抄袭，那我肯定不允许。\
（2）由于我们看数据时，会第一眼会看到最大数据，但往往忽略了一些需要想乘数据，导致错用数据类型，进而大数据过不了，所以加入下列代码，即可在 $10^{18}$ 次方的数据以内（部分有关联的数据相乘后的最大总值），那么基本可以不用考虑到底要不要用长整型。此代码写法如下：

```cpp
#define int long long
```
（3）写完代码后，如果编译器上输出与对应的样例输出不一致，则需要重新检查代码逻辑，看看是否出错。\
（4）如果你发现编译器一直都没有输出对应结果，那大概率是死循环了（如果在 $15$ 秒内一直没输出就不要干等了，赶快看看哪里代码写错了造成死循环）。\
（5）变量名最好不要写成与数据结构、数据类型相同或相近的，避免造成不必要的麻烦。\
（6）变量名不要写太长，否则你会容易写错变量或弄混变量。\
（7）数组不要开的太大，避免造成编译错误。\
（8）可以试着一题多解，你会发现，你一道题用多种的解法，这样你会找到更优的解法。\
（9）本题不适合用模拟，数据过于大，非常容易超。\
（10）若自己的代码样例能过，别急着停手，试着自己造几个数据，看看是否结果都正确，避免数据过于刁钻，从而得不到本题满分。

---


# [蓝桥杯青少年组省赛 2024] 字母移位

## 题目描述

字母移位表示将字母按照字母表的顺序进行移动。

例如，$\texttt{b}$ 向右移动一位是 $\texttt{c}$，$\texttt{f}$ 向左移动两位是 $\texttt{d}$。

特别地，$\texttt{a}$ 向左移动一位是 $\texttt{z}$，$\texttt{z}$ 向右移动一位是 $\texttt{a}$。

给定一个仅包含小写字母且长度为 $n$ 的字符串 $s$，以及 $n$ 个正整数 $a_1, a_2, \ldots, a_n$，接下来对字符串 $s$ 按如下规律操作：

1. 将第 $1$ 位字符向左移动 $a_1$ 位；
2. 再将第 $1$、$2$ 位字符都向右移动 $a_2$ 位；
3. 再将第 $1$、$2$、$3$ 位字符都向左移动 $a_3$ 位；
4. 再将第 $1$、$2$、$3$、$4$ 位字符都向右移动 $a_4$ 位；
   
以此类推，直到将 $s$ 的第 $1$ 到第 $n$ 位字符都（按规律向左或向右）移动 $a_n$ 位。

最后，将操作完成后的字符串 $s$ 输出。

例如，$n=5$，字符串 $s=\texttt{abcde}$，$5$ 个正整数为 $1, 3, 5, 7, 9$：

1. 将 $\texttt{abcde}$ 的第 $1$ 位字符 $\texttt{a}$ 向左移动 $1$ 位，$s$ 变为 $\texttt{zbcde}$；
2. 再将 $\texttt{zbcde}$ 的前 $2$ 位字符 $\texttt{zb}$ 向右移动 $3$ 位，$s$ 变为 $\texttt{cecde}$；
3. 再将 $\texttt{cecde}$ 的前 $3$ 位字符 $\texttt{cec}$ 向左移动 $5$ 位，$s$ 变为 $\texttt{xzxde}$；
4. 再将 $\texttt{xzxde}$ 的前 $4$ 位字符 $\texttt{xzxd}$ 向右移动 $7$ 位，$s$ 变为 $\texttt{egeke}$；
5. 再将 $\texttt{egeke}$ 的前 $5$ 位字符 $\texttt{egeke}$ 向左移动 $9$ 位，$s$ 变为 $\texttt{vxvbv}$。

最后，将操作完成后的字符串 $\texttt{vxvbv}$ 输出。

## 样例 #1

### 输入

```
5
abcde
1 3 5 7 9```

### 输出

```
vxvbv```

# 题解

## 作者：FJ_EYoungOneC (赞：6)

### 解题思路

这里我们设置字符向右移动为正，往左移动为负。

第一个字符的移动次数为 $a_1-a_2+a_3-a_4+\dots$。

第二个字符的移动次数为 $-a_2+a_3-a_4+\dots$。

发现涉及大量重复计算，所以我们可以用后缀和来优化求和过程。

时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n;
string str;
int a[N];
LL s[N];

char move(char c, LL d)
{
    return ((c - 'a' + d) % 26 + 26) % 26 + 'a';
}

int main()
{
    cin >> n >> str;
    str = ' ' + str;
    
    for (int i = 1; i <= n; ++ i )
    {
        cin >> a[i];
        if (i & 1)
            a[i] = -a[i];
    }

    for (int i = n; i; -- i )
        s[i] = s[i + 1] + a[i];

    for (int i = 1; i <= n; ++ i )
        cout << move(str[i], s[i]);
    
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

## 思路

往左为负，往右为正。

我们应用 DP。

对于第 $i$ 个字母，当 $i$ 为奇数时，它移动的次数为 $−a+a_{i+1}−a_{i+2}+\ldots+a_n$。

那么为偶数呢？

它移动的次数为 $a-a_{i+1}+a_{i+2}-\ldots-a_n$。

当然，$n\le 10^5$ 呢，所以暴力会超时。

而后缀和优化即可。

后缀和优化就是记往左移 $2$ 两位，往右移 $5$ 位为往右移三位，然后记录后缀和，最后输出。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100005],f[100005];
string s;
int main() {
	cin>>n>>s;
	s=" "+s;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i%2!=0)a[i]=-a[i];
	}
	for(int i=n;i>=1;i--)
	f[i]=f[i+1]+a[i];
	for(int i=1;i<=n;i++)
	cout<<(char)(((s[i]-'a'+f[i])%26+26)%26+'a');
}
```

---

## 作者：Jayfeather2012 (赞：1)

## 思路
根据题意，我们知道，左移表示 ASCII 码相减，右移表示 ASCII 码相加，所以将左移记为负，右移记为正。  
根据题意，我们发现：  
若 $i$ 为奇，第 $i$ 个字符的 ASCII 码变化为 $a_i-a_{i+1}+a_{i+2}-a_{i+3}+a_{i+4}\ldots a_n$；  
若 $i$ 为偶，第 $i$ 个字符的 ASCII 码变化为 $-a_i+a_{i+1}-a_{i+2}+a_{i+3}-a_{i+4}\ldots a_n=-(a_i-a_{i+1}+a_{i+2}-a_{i+3}+a_{i+4}\ldots a_n)$。  
因为 $1\le n\le 10^5$，暴力会超时，所以用后缀和进行优化，时间复杂度 $O(n)$，可以[通过此题](https://www.luogu.com.cn/record/212935016)。  
具体细节看代码吧！
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,a[100005];
int main(){
    cin>>n>>s;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=n;i>=1;--i){
        a[i]-=a[i+1]-26;
        a[i]%=26;
        //后缀和
        //为了后面计算方便，取模一下吧！
        //取模时注意避免负数
    }
    for(int i=1;i<=n;++i){
        if(i%2)s[i-1]=(s[i-1]-'a'-a[i]+26)%26+'a';//为奇，减
        else s[i-1]=(s[i-1]-'a'+a[i]+26)%26+'a';//为偶，加
        //注意取模，注意避免负数
    }
    cout<<s<<"\n";
    return 0;
}
```

---

## 作者：wenqinghua1001 (赞：1)

## 思路

这道题的重点是左移和右移。

设 $a_i$ 为第 $i$ 个字母需右移的次数（可能为负，代表左移），$x$ 为待操作的字母的 ASCII 码，那么 $ans=((x+a_i) \bmod 26+26) \bmod 26$。

```cpp
long long a[1000001];
char caozuo(char x,int i){
    int ans=((x-'a'+a[i])%26);
    // ans是转换后字母的ASCLL码。
    if(ans<0){
        // 有可能为负。
        ans=(ans+26)%26;
    }    
    return char(ans+'a');
}
```

由于会存在重复操作，使用前缀和，否则超时，[50 pts](https://www.luogu.com.cn/record/212484634)。

```cpp
for(int i=1;i<=n;i++){
    cin>>a[i];
    a[i]%=26;
    // 一个环，a 右移26为后还是 a。
    if(i&1) a[i]=-a[i];
    // 如果 i 是奇数，右移变左移，a[i]=-a[i]。
}
// 输入。
for(int i=2;i<=n;i++)
    a[i]+=a[i-1];
// 前缀和，可能有重复。
```

然后进行左右移操作。

```cpp
for(int i=0;i<n;i++)
    s[i]=caozuo(s[i],i+1);
```

最后输出字符串 $s$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000001];
char caozuo(char x,int i){
    int ans=((x-'a'+a[i])%26);
    // ans是转换后字母的ASCLL码。
    if(ans<0){
        // 有可能为负。
        ans=(ans+26)%26;
    }    
    return char(ans+'a');
}
// 移动。 
int main(){
	int n;
	cin>>n;
	string s;
	cin>>s;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]%=26;
		if(i&1) a[i]=-a[i]; 
	}
	// 输入。
	for(int i=n-1;i>=1;i--)
		a[i]+=a[i+1];
	// 前缀和。 
	for(int i=0;i<n;i++)
		s[i]=caozuo(s[i],i+1);
	cout<<s;
	// 输出。 
	return 0;
	// 好习惯+1。 
}
```

---

## 作者：luoyebushiye (赞：1)

### 思路
阅读题目后，我们假设把向左记为正数，向右记为负数，根据样例可以列出下面的表格。

|$1$|||||
|:-:|:-:|:-:|:-:|:-:|
|$1 + (-3)$|$-3$||||
|$1 + (-3) + 5$|$-3 + 5$|$5$|||
|$1 + (-3) + 5 + (-7) + 9$|$-3 + 5 + (-7)$|$5 + (-7)$|$-7$||
|$1 + (-3) + 5 + (-7) + 9$|$-3 + 5 + (-7) + 9$|$5 + (-7) + 9$|$-7 + 9$|$9$|

然后就可以得出下表

|$a_1$|||||
|:-:|:-:|:-:|:-:|:-:|
|$a_1 + (-a_2)$|$-a_2$||||
|$a_1 + (-a_2) + a_3$|$-a_2 + a_3$|$a_3$|||
|$a_1 + (-a_2) + a_3 + (-a_4)$|$-a_2 + a_3 + (-a_4)$|$a_3 + (-a_4)$|$-a_4$||
|$a_1 + (-a_2) + a_3 + (-a_4) + a_5$|$-a_2 + a_3 + (-a_4) + a_5$|$a_3 + (-a_4) + a_5$|$-a_4 + a_5$|$a_5$|

我们发现程序需要计算重复的过程，但不难看出可以使用前缀和来优化。

#### 思路解释

这里我把字符的最终移动的位数先统一写为操作值。

依照图表，我们可以发现第二个字符的操作指是在第一个字符的操作值上减去 $a_1$。
 
$a_1 + (-a_2) + a_3 + (-a_4) + a_5 - a_1 = -a_2 + a_3 + (-a_4) + a_5$

同样发现第三个字符的操作值是第一个字符的操作值上减去 $a_1 + (-a_2)$。

$a_1 + (-a_2) + a_3 + (-a_4) + a_5 - (a_1 + (-a_2)) = a_3 + (-a_4) + a_5$

$a_1$ 为第一个字符第一次操作的值。

$a_1 + (-a_2)$ 为第一个字符前两次操作的值的总和。

我们又又又可以发现，求第 $n$ 字符的操作值是第一个字符的操作值减去第一个字符前 $n - 1$ 次操作的值的总和。

所以我们只需要计算第一个字符的每次操作的值的累加，就可以计算出其他字符的操作值。

最后，再保证字符的移动只在小写字母范围内，就完成了。

#### 做法

请看代码 ~~（代码比较丑陋，轻喷）~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long n;
	long long a;
	string s;
	char zm[27]={'.','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	int sum1[(int)1e6];
	cin>>n>>s;
	sum1[0]=0;//特殊情况：当为第一个字符时，只能减去0。 
	for(int i=1;i<=n;i++){
		cin>>a;
		if(i%2==0)
			a*=-1;
		sum1[i]+=a;
        sum1[i]%=26;//如果不取模，1e9+1e9之类的数会炸
		sum1[i+1]=sum1[i];
	}
	for(int i=0;i<n;i++){
		bool f=0;
		long long ans=0;
		if(sum1[n]-sum1[i]<0){
			f=1;
		}
		ans=abs(sum1[n]-sum1[i]);
		if(f==0){
			ans%=26;
			if(s[i]-ans>='a'&&s[i]-ans<='z')
				putchar(s[i]-ans);
			else
				cout<<zm[26-abs(s[i]-'a'-ans)+1];
		}
		else{
			if(s[i]+ans>='a'&&s[i]+ans<='z')
				putchar(s[i]+ans);
			else
				cout<<zm[abs(s[i]-'a'+ans)%26+1];
		}	
	}
	return 0;
}
```

---

## 作者：Mark_Pei (赞：0)

## Solution


这里我们规定字母向右移动为正，往左移动为负。

此时意我们会发现：对于第 $i(1≤i≤n)$ 个字母，当 $i$ 为奇数时，它移动的次数为 $-a_i+a_{i+1}-a_{i+2}+\ldots+a_n​$；当 $i$ 为偶数时，它移动的次数为 $a_i-a_{i+1}+a_{i+2}-\ldots-a_n$。
 
因为题目数据比较大，直接暴力会 TLE，还涉及很多重复计算，所以我们可以用**后缀和**来优化整个求和过程，发现规律就行了（详见代码），这时的时间复杂度为 $O(n)$。

**AC code**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],f[100005],n;
string s;
int main() 
{
	cin>>n;
	cin>>s;
	s=" "+s;
	for (int i=1; i<=n;i++)
    {
		cin>>a[i];
		if(i%2==1) a[i]=-a[i];
	}
	for (int i=n;i>=1;i--)//后缀和
    {
		f[i]=f[i+1]+a[i];
	}
	for (int i=1;i<=n;i++)//字符输出 
    {
		cout<<char(((s[i]-'a'+f[i])%26+26)%26+'a');
	}
	return 0;
}
```

---

## 作者：yyycj (赞：0)

## 题目简述
给定长度为 $n$ 正整数序列 $a$ 和长度为 $n$ 的由小写字母构成的字符串 $S$。对于 $i\in[1,n]$，如果 $i\bmod2=1$，则让 $S_{1}\sim S_{i}$ 按字母表顺序向左移动 $a_{i}$ 位；反之向右移动 $a_{i}$ 位，最后输出 $S$。

特别地，`a` 向左移动变为 `z`，`z` 向右移动变为 `a`。

## 主要思路
由于共有 $26$ 个字母，所以每移动 $26$ 个字母就相当于没移动，我们可以将 $a_{i}\gets a_{i}\bmod26$。

对于 $i\bmod2=1$，我们可以理解为向右移动 $-a_{i}$ 位，可以直接将其设为负数；对于每个字符的移动，其实就是 $\sum_{j=i}^{n}a_{j}$，这个和可以用前缀和求出。

但注意：`z` 处于 ASCII 码很后面的位置，所以当 `z` 加上一个数后，就有可能炸掉 `char`，那么就可以先用一个 `int` 变量来存储 $S_{i}$ 移动后的 ASCII 码，再将 $S_{i}$ 设为这个变量。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
typedef long double db;
const int N = 1e5 + 10;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
// ----------------------------

// ----------------------------
ll a[N], pre[N];
// ----------------------------


int main() {
	int n; cin >> n;
	string s; cin >> s;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		a[i] %= 26;
        if (i & 1) a[i] = -a[i];
		pre[i] = pre[i - 1] + a[i];
		pre[i] %= 26;
	}
	// ----------------------------
	for (int i = 0; i < n; i++) {
		int k = s[i] + (pre[n] - pre[i]) % 26;
		if (k > 'z') k -= 26;
		if (k < 'a') k += 26;
		s[i] = k;
	}
	// ----------------------------
	cout << s;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
1. 动动我们聪明的小脑瓜，推出求字母位移的数学公式，实在不行就用下面的暴力办法。

```cpp
char you(char ch,ll x)
{
	x%=26;
	while(x--)
	{
		if(ch=='z')
		ch='a';
		else
		ch++;
	}
	return ch;
}
char zuo(char ch,ll x)
{
	x%=26;
	while(x--)
	{
		if(ch=='a')
		ch='z';
		else
		ch--;
	}
	return ch;
}
```

2. 可以注意到时间复杂度 $O(n^2)$ 是过不了的。
3. 怎么办呢？很明显，往左移动 $1$ 位，再往右移动 $3$ 位，其实就相当于向右移动 $3-1$ 也就是 $2$ 位。根据这个规律，我们可以想到用后缀和来优化，就像这样。

```cpp
for(int i=1;i<=n;i++)
{
	scanf("%d",&a[i]);
	if(i%2==1)
	f[i]-=a[i];
	else
	f[i]+=a[i];
}
for(int i=n;i>=1;i--)
f[i]+=f[i+1];
```

4. 十年 OI 一场空，不开 long long 见祖宗。
# 上完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5;
string s;
int a[N],n;
ll f[N];
char you(char ch,ll x)
{
	return (ch-'a'+x)%26+'a';
}
char zuo(char ch,ll x)
{
	int num=((ch-'a')-x)%26;
	if(num<0)
	num+=26;
	return num+'a';
}
int main()
{
	scanf("%d",&n);
	cin>>s;
	s=" "+s;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(i%2==1)
		f[i]-=a[i];
		else
		f[i]+=a[i];
	}
	for(int i=n;i>=1;i--)
	f[i]+=f[i+1];
	for(int i=1;i<=n;i++)
	{
		if(f[i]>0)
		s[i]=you(s[i],f[i]);
		else
		s[i]=zuo(s[i],0-f[i]);
		cout<<s[i];
	}
	return 0;
}
```

---

## 作者：Gongyujie123 (赞：0)

## [B4303 [蓝桥杯青少年组省赛 2024] 字母移位](https://www.luogu.com.cn/problem/B4303) 题解
### 1. 思路分析
我们规定字母向左移动为**负**，字母向右移动为**正**。

根据题意我们很容易想到：对于第 $i (1 \le i \le n)$ 个字母，当 $i$ 为奇数时，它移动的次数为 $-a_i+a_{i+1}-a_{i+2}+ \dots a_n$；当 $i$ 为偶数时，它移动的次数为 $a_i-a_{i+1}+a_{i+2}- \dots a_n$。

因为题目数据很大，暴力会超时，所以可以用后缀和。

最后再对字母进行移动，`s[i] = ( (s[i] - 'a' + f[i]) % 26 + 26) % 26 + 'a'`。

### 2. AC 代码
[AC 记录](https://www.luogu.com.cn/record/212629355)。  
时间复杂度：$O(n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005], f[100005];
signed main() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	s = " " + s;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (i % 2 != 0) {
			a[i] = -a[i];
		}
	}
	for (int i = n; i >= 1; i--) {
		f[i] = f[i + 1] + a[i];
	}
	for (int i = 1; i <= n; i++) {
		cout << (char)( ( (s[i] - 'a' + f[i]) % 26 + 26) % 26 + 'a');
	}
	return 0;
}

```

---


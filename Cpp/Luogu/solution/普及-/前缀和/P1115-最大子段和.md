# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。


## 说明/提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。


## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
4```

# 题解

## 作者：_Arahc_ (赞：1179)

> 几年就这么过去了，曾经并不注意格式规范导致现在题解不太美观。这里重新修正一下。这篇题解赞数不低，这里也只是修改 markdown 格式和分段排版，希望管理能给过。

---

~~又来水题解了~~。

题目传送门：[Link](https://www.luogu.org/problem/P1115)。

大家不要把这题想得很复杂，能做出一个题首先要有做题的信念。这题的实际难度没有大家想得那么高。

直接枚举 $l,r$，求所有区间的和然后取最大值的时间开销很大，不能通过本题，我们来思考更优秀的做法。

首先，我们现在纸上手算一下样例是怎么来的：

```
2 -4 3 -1 2 -4 3
ans:4
```

可以发现选 `3 -1 2` 是一种合法的方案。那么是怎么推出来的呢？

首先看到第一个数，是 $\color{green}\text{2}$。而 $\color{green}\text{2}$ 后面是 $\color{green}\text{-4}$，所以如果 $\color{green}\text{-4}$ 是答案的一部分，那么 $\color{green}\text{2}$ 一定也要加上去（这样答案就增加了，会比原来优）。

随后是 $\color{green}\text{3}$。如果 $\color{green}\text{3}$ 把前面的 $\color{green}\text{2}$ 和 $\color{green}\text{-4}$ 加上去，结果是 $\color{brown}\text{1}$。这个时候反而比原来的单独一个 $\color{green}\text{3}$ 要小。所以如果答案含有 $\color{green}\text{3}$，就一定不会加上前面的 $\color{green}\text{2}$ 和 $\color{green}\text{-4}$（加上前面的部分答案变小，不如到这里为止）。

下一个数是 $\color{green}\text{-1}$。这个数加上前面的 $\color{green}\text{3}$ 之后答案增加了（变成了 $\color{brown}\text{2}$），所以如果答案有 $\color{green}\text{-1}$，辣么绝对还有前面的 $\color{green}\text{3}$。

接下来是 $\color{green}\text{2}$，如果 $\color{green}\text{2}$ 加上前面的序列 $\color{green}\text{(3,-1)}$，辣么它的值变为 $\color{brown}\text{4}$。比原先增加了。

然后是 $\color{green}\text{-4}$，如果把 $\color{green}\text{-4}$ 加上前面的序列 $\color{green}\text{(3,-1,2)}$，结果会变成 $\color{brown}\text{0}$，比原先的 $\color{green}\text{-4}$ 大，所以如果 $\color{green}\text{-4}$ 是答案的一部分，那么前面的三个数也一定是答案的一部分。

最后一个数 $\color{green}\text{3}$，如果将 $\color{green}\text{3}$ 加上前面的序列，结果变成了 $\color{brown}\text{3}$，没有变，所以这个可加可不加。

最后我们来看一看刚推导的结果，发现 $\color{brown}\text{4}$ 是我们可以得出的最大和。

所以说了这么多，最终的结果是什么呢？

- 第一个数为一个有效序列
- 如果一个数加上上一个有效序列得到的结果比这个数大，那么该数也属于这个有效序列。
- 如果一个数加上上一个有效序列得到的结果比这个数小，那么这个数单独成为一个新的有效序列
- 在执行上述处理的过程中实时更新当前有效序列的所有元素之和并取最大值。

然后就可能有人问了：考虑上面样例推导中，出现了一个可加可不加的 $\color{green}\text{3}$。如何处理？

结论是：对于可加可不加的数，不如加上。因为加上对答案没有坏处，而如果这个数后面还有一部分能让答案变多，因为本题求的子段是连续子段，不加上的话这两边就连不起来了。所以无脑加就行了。

最后取最大值即可。

 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200020],b[200020],i,ans=-2147483647;

// b[i] 表示截止到 i 时，第 i 个数所在的有效序列的元素和。

int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        if(i==1) b[i]=a[i];
        else b[i]=max(a[i],b[i-1]+a[i]);
        ans=max(ans,b[i]);
    }
    cout<<ans;
    return 0;
}
```

然而对比这份代码的时空消耗，我们还可以做得更好。

我们来看一眼代码：

1. 输入 $a_i$。
2. 用 $b_{i-1}$ 和当前输入的 $a_i$ 给 $b_i$ 赋值。
3. 用 $b_i$ 给 $ans$ 更新答案。

首先发现全程中 $a$ 数组是没有意义的。我们每次只用到了当前使用的 $a_i$。也就是说，它可以被一个变量代替。

其次考虑 $b$ 数组，每次对 $b_i$ 更新只用到 $a_i$ 和 $b_{i-1}$。前者已经变成一个变量了，而后者，我们把 $b_{i-1}$ 看成“上一个 $b_i$”，于是就相当于 $b_i$ 是由上一个 $b_i$ 和变量 $a$ 更新的。这也可以缩减成一个变量。

最终我们就得出了空间消耗大优化后的代码：

 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,i,ans=-2147483647;
int main(){
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>a;
		if(i==1) b=a;
		else b=max(a,a+b);
		ans=max(ans,b);
	}
	cout<<ans;
	return 0;
}
```

空间优化的效果还是很明显的，从 2.13MB 变成了 688KB。

-----------------

---

## 作者：Robert (赞：601)

#用到了一些奇怪的写法

我的想法也是贪心，就是用一个sum记录当前前缀和，一路累积过去，如果前缀和sum变成了负数，那么下一个数就不需要前面的数了（因为还不如只选它一个），这时把sum置为0，再继续累加。


我写了一个挺短的代码，（从A+B题解那里学到了好多东西）：

‘’‘cpp

```cpp
#include<cstdio>
int n,j,sum,maxx;int main(){         
    scanf("%d%d",&n,&maxx);sum=maxx;//输入n
    while(--n){scanf("%d",&j);sum=sum>0?sum:0;sum+=j;maxx=maxx>sum?maxx:sum;}//贪心，如果负了就舍去 
    return (printf("%d",maxx))&0;//输出并return 0 
}
’‘’
```

---

## 作者：ZnO34 (赞：349)

** 注意，此篇题解写于2019年，当时luogu还能通过文言语言提交代码。不要再问这是什么语言了。 **

**吾有一術。名之曰「最大子段和」。欲行是術，必先得「文言lang」。**

~~散裝文言警告~~

Luogu 支持「文言」以來，未見其題解多见【通今「現」】。予閒來無事，乃尋題于 Luogu。遂得「最大子段和」一題，乃AC之以「文言」。

[提交記錄](https://www.luogu.com.cn/record/29207841)

有感，遂作此篇以記之。

# 解題思路

在座各位都已清楚此題思路，不多贅述。欲解此題，必行動態規劃之術。設 $dp[i]$ 為強制以 $a[i]$ 結尾的最大子段和。顯然，有選與不選之擇。

如 $dp[i-1]<0$ 則無需用 $a[i]$ “接上”前面的一段，乃“自立門戶”，$dp[i]=a[i]$ 。否則，用 $a[i]$ 接上前面一段,得 $dp[i]=dp[i-1] + a[i]$ 。

考慮到 $dp[i]$ 只會由 $dp[i-1]$ 轉移得來，可以拋掉數組不要。就有了一樓題解的實現方式。

# 文言的实现

来到这篇题解的主题内容，我也不用~~散装~~文言和繁体字来恶心各位大佬了。接下来我会分几个简单的步骤来用文言实现这个简单的问题。

## 输入

**由于这一段是重点所以太长以至于可能发不上来，有兴趣的大佬们欢迎移步博客**。[传送门](https://jiyu596.blog.luogu.org/qian-tan-luogu-wen-yan-shu-ru-1-post)

### 前置工作

luogu [A+B Problem](https://www.luogu.com.cn/problem/P1001) 拉到最下面就有文言版的实现。因为“文言尚菜”，所以“无对象之操作”，我们需要外接 JavaScript 来从 stdin 得到输入。如下：

```
施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf => buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.split(' '))」於「數據」。昔之「數據」者。今其是矣。
注曰。「「文言尚菜，無對象之操作，故需 JavaScript 之语法」」。

夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。

加「甲」以「乙」。書之。
```

其中最前面三行是开头所必须（第四行是注释）。它起到了暂时“外挂”JavaScript 的作用。然而，我们发现第三行中

```
施「(s => s.split(' '))」於「數據」。昔之「數據」者。今其是矣。
```

仅仅起到了将“空格”分割开来的效果。要 ac 这一题，首先要输入一个 
项数 $n$， 接着是一个**回车**。用例程的这一句不能正常获得“数据”数组，怎么办呢？不多啰嗦，上代码。
```
施「(s => s.replace('\n',' '))」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.replace('\r',''))」於「數據」。昔之「數據」者。今其是矣。
```

这一段外挂 JavaScript 的代码放在 split 之前。它将所有的 \n 替换成了空格，将所有的 \r 都去掉了（在 linux 下似乎并不必要但是如果不加 luogu 的在线 IDE 会出错），这样就解决了这个问题。完整代码如下：

```
施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf => buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.replace('\n',' '))」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.replace('\r',''))」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.split(' '))」於「數據」。昔之「數據」者。今其是矣。

```
可以得到一个名为“~~数据~~數據”的数组，里面存的是每一个输入的数。

### 单次读入
得到这个数组后，每一次我们想要读入一个数，可以这样读入：

```
夫「數據」之n。取一以施「parseInt」。名之曰「xx」。
```

其中 n 是输入文件的第 n 个数，而 xx 是用来存的变量名。举例：

```
夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。
```

**那如果我想要读入一个已经被定义的变量呢？**

有两种办法，一是声明一个临时变量，然后把这个变量的值赋给已经被定义的变量。

```
吾有一數。名之曰「已有變量」。
夫「數據」之三。取一以施「parseInt」。名之曰「臨時變量」。
昔之「已有變量」者。今「臨時變量」是矣。
```

另有一更简单的写法：

```
夫「數據」之二。取一以施「parseInt」。昔之「已有變量」者。今其是矣。
```

### 循环读入

因为这一题由于 $dp[i]$ 由 $dp[i-1]$ 转移得来，我们可以将一个数组压缩成一个变量，不需要数组。~~其实只是我不会读数组……~~观察读入一个变量的语句，比较难求的是这个 n 。我们可以维护一个「項數」变量来读入。看代码：

```
夫「數據」之一。取一以施「parseInt」。名之曰「項數」。
吾有一數。曰二。名之曰「第幾項」。
為是「項數」遍。
	夫「數據」之「第幾項」。取一以施「parseInt」。名之曰「本項」。
	加一於「第幾項」。昔之「第幾項」者。今其是矣。
云云。
```

不难理解，用一个「第幾項」维护了输入的索引。



对于数组的读入和一些其他内容~~因为不会~~暂时不在这里说了。有时间再补上吧。

## 控制流程

我们需要了解“为是项数遍”。它的作用相当一个从一到「項數」的 for 循环。从 GitHub 中的“为是百遍”得来——[Github传送门](https://github.com/wenyan-lang/wenyan#control)。

在这一题中，我们用到的有：

```
為是「項數」遍。
	省略
   若「和」小於零者。
       昔之「和」者。今零是矣。
   云云。
	省略
云云。
```

在这段代码之中，先是一个执行项数次的循环，里面嵌套了一个条件判断语句。以云云作为结束的大括号。

非常好理解，套用即可，不多赘述。

## 赋值和运算

把加减乘除用「於」「以」连接起来就完事了。举一个例子即可：

```
加一於「第幾項」。昔之「第幾項」者。今其是矣。
```

执行“加一於「第幾項」”后，编译器会把它执行后的结果存下来，等待一个指代。我们利用**其**一字来获取它的值。

而文言中标准的赋值语句格式为：
```
昔之xxx者。今yyy是矣。
```
作用为将 yyy 的值赋给 xxx。相当于 xxx=yyy。


# 最终实现代码

将上文所述结合起来，我们得到了一篇 $AC$ 代码：

```
施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf => buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。

施「(s => s.replace('\n',' '))」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.replace('\r',''))」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.split(' '))」於「數據」。昔之「數據」者。今其是矣。

注曰。「「文言尚菜，無對象之操作，故需 JavaScript 之语法」」。

夫「數據」之一。取一以施「parseInt」。名之曰「項數」。
減「項數」以一。昔之「項數」者。今其是矣。
吾有一數。曰三。名之曰「第幾項」。
夫「數據」之二。取一以施「parseInt」。名之曰「最大值」。
吾有一數。名之曰「和」。 昔之「和」者。今「最大值」是矣。
為是「項數」遍。
    夫「數據」之「第幾項」。取一以施「parseInt」。名之曰「本項」。
    若「和」小於零者。
        昔之「和」者。今零是矣。
    云云。
    加「本項」於「和」。 昔之「和」者。 今其是矣。
    若「和」大於「最大值」者。
        昔之「最大值」者。今「和」是矣。
    云云。
    加一於「第幾項」。昔之「第幾項」者。今其是矣。
云云。
夫「最大值」。書之。
```

**完结撒花！！！**

---

## 作者：mohei0 (赞：235)

忙人请跳过分割线内的内容

--------------------------------------------------------（完美的分割线~）

交了三次，一次在机房没做完存储……

搞了半天才发现c++自带min和max函数QAQ

吃完饭才写完的程序和题解，超困的  = =

（中午没来得及写完，实际是下午自习写的~）

所以……题解求过~~

--------------------------------------------------------（下方正文~）

不知道会不会有一样的思路（似乎是有的……）

但是我还是……要（zuo）！写（si）！题！解！

a数组是储存输入的数值~

c[i]表示的是a数组从头加到i的和~

b[i]表示的是从头到i包括i的的最大子段和~（必须包括i！！！）

minn储存最小的前缀和（因为要减去所以要尽量小，详情见下一行）~

动态转移方程式：b[i]=c[i]-minn（总和减去前缀和）~

mann是最后输出b数组最大的值（题目求最大的子段和）~

--------------------------------------------------------（划重点！！！）

minn一定要初始化成0！！！

如果设成a[1]会死……（如果是正数会减去正数，正解是不减，就是没有减去的子段和）

相反mann要设成很小的值！！！（废话）

--------------------------------------------------------（代码分割线）

```cpp
#include<iostream>
using namespace std;
int n,a[200001]={0},b[200001]={0},c[200001]={0},minn=0,mann=-99999;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        c[i]=c[i-1]+a[i];
    }
    b[1]=a[1];minn=min(0,c[1]);
    for(int i=2;i<=n;i++)
    {
        b[i]=c[i]-minn;
        minn=min(minn,c[i]);
    }
    for(int i=1;i<=n;i++) mann=max(mann,b[i]);
    cout<<mann<<endl;
}
```

---

## 作者：____233____ (赞：199)

#思路：DP（其实好像是贪心QWQ）

这道题其实是练习DP的入门题（本蒟蒻也才刚刚学DP）

首先，通过题意，我们可以了解到：

**f[i]=max(f[i-1]+n[i],n[i])**

**但是！**

**f[n]的值并不一定是最终结果**

比如这个输入：

5
233 233 -666 1 1

如果直接输出f[n]的值，结果会是2，但是答案应该为466！

为什么？

因为若f[i]的值为负数，则f[i+1]的值就是n[i],而n[i]的值不一定比前面的最大字段和数大！

（或者n[i]为负数，则f[i]小于f[i-1]!)

所以，我们还要再用一个数从1到n再查找一次，才能找出最大数！！！

代码（时间复杂度大概是O(n）？算了，反正我也不晓得）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n[200001],p,ans[200001]={0};
    int sum=-9999999;//|x|<=10000   QWQ
    cin>>p;
    for(int i=1;i<=p;i++)
    {
        cin>>n[i];//输入
        ans[i]=max(ans[i-1]+n[i],n[i]);//DP
        sum=max(sum,ans[i]);//取最大值也同时进行，节约时间
    }
    cout<<sum;//直接输出
    return 0;
}
```

---

## 作者：林则徐 (赞：171)

此题解法多样，这里讲下分治的解法。

首先，假定有区间$[l..r]$，其中间位置为$mid$，其最大子段为$[i..j]$。那么显然，$i$和$j$必定符合下列三种情况之一：

1.$l \leq{i} \leq{j} \leq{mid} $

2.$i \leq{mid} <j \leq{r} $

3.$mid < i \leq{j} \leq{r} $

只需要分别求出三种情况下的值，取其最大的即可。

其中，很容易求出第二种情况，即求出区间$[i..mid]$与区间$[mid+1..j]$，将其相加即可。复杂度$O(n)$

如何处理第一种和第三种情况呢？也不难发现，第一种情况，其实就是求区间$[1..mid]$中的最大值，第三种情况就是求区间$[mid+1..r]$中的最大值。那么，只需递归求出即可。

显然，该解法的复杂度为 $O(nlogn)$ 通过此题是没问题的。


附上代码




```cpp
`#include<cstdio>
int n , arr[200200]; //arr存储该序列 
const int minn = -19260817; // 定义最小值 
inline int Max( int a , int b) { return a > b ? a : b ;} //自定义 Max 函数（好像比stl的快一点） 
int rec( int l , int r ) { //分治函数 
    if ( l == r ) {    //    l=r时，直接返回该位置的值 
        return arr[l];
    }
    int mid = ( l + r ) >> 1;  
    int sum = 0 , ret1 = minn , ret2 = minn; //ret1为[l..mid]区间内包含mid的最大子段和，ret2为[mid+1..r]区间内包含(mid+1)的最大子段和  
    for( int i = mid ; i >= l ; i-- ) {
        sum += arr[i];
        ret1 = Max( ret1 , sum );
    }  //求出[i..mid]区间最大值
    sum = 0;
    for( int i = mid+1 ; i <= r ; i++ ) {
        sum += arr[i];
        ret2 = Max( ret2 , sum );
    }  //求出[mid+1..r]区间最大值
    return Max( Max( rec( l , mid ) , rec( mid + 1 , r ) ) , ret1 + ret2 );   //返回可能一 可能二 可能三 中的最大值
}
int main() { // 以下主函数  
    scanf("%d", &n );
    for( int i = 1 ; i <= n ; i++ ) {
        scanf("%d" , &arr[i] );
    }
    printf("%d" , rec(1 , n) ); 
    return 0;
}`
```

---

## 作者：Enigmatic (赞：64)

时间O（n），空间O（1）

看到楼上有用滚动数组的

实际上这道题滚动数组都不用

思路：用now记录当前读入的数据

tmp是当前的子段和，ans是当前最大子段和

若tmp<0，则重置为0

因为如果后面有大数，则0+大数肯定比负数+大数要大

ans初值为第一个now，不然如果全部为负数就会有bug

也可以置为很小的一个数

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans,tmp,now;
int main()
{
    scanf("%d",&n);
    scanf("%d",&now);
    ans=now;
    if(now>0) tmp=now;
    for(register int i=2;i<=n;i++)
    {
        scanf("%d",&now);
        tmp+=now;
        if(tmp>ans) ans=tmp;
        if(tmp<0) tmp=0;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：引领天下 (赞：56)

一道标准的练手 dp 好题。

下面提出标准最大子段和做法：

边读边做，$now$ 代表目前加起来是多少。

当读入一个 $a$ 时，$now$ 先直接加上 $a$，如果 $now>ans$，那么就用 $now$ 更新 $ans$。

如果 $now<0$，正常情况下应该直接舍弃，但。。。。

有测试点 #2。

全是负数！这个特殊情况一定要考虑！

所以，代码来了：

```cpp
#include <cstdio>//标准输入输出库
int main(void){
    int n,a,ans=1<<31,now,c=1;//ans初值一定要给小一点（防#2)(int最大值是1<<31-1,所以1<<31直接跳负数
    scanf ("%d",&n);//读入
    while (n--){//既然边读边做，要n何用？
        scanf ("%d",&a);//读入a
        now+=a;//now加一下
        if (now>ans)ans=now;//注意这句和下句的顺序！如果反过来，就只有80分了（臭不要脸的测试点#2）
        //同时找到了最大值
        if (now<0)now=0;//如果now小于0，这种方案肯定不可取，归0（屁股免打，下次再来）
    }
    printf ("%d",ans);//输出
}
```

---

## 作者：codesonic (赞：47)

贪心+DP

因为前几天hack掉了几个思想很好但是没有注意细节的题解，所以来这填坑（包括之前题解的思想，用自己语言解释）

DP什么的下面的dalao们都讲得够明白了，这里仅介绍空间上的优化

因为是DP，所以不用储存从第一个到最后一个的答案，可以使用滚动数组，仅两个元素，轮流储存。每次通过前一个算出后一个，然后将前一个删除

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int sum,a[2],n;//仅需要两个元素的数组
int main()
{
    scanf("%d",&n);
    scanf("%d",&a[1]);//先读入第一个元素
    sum=a[1];
    for(int i=2;i<=n;++i)
    {
        if(sum<0) sum=0;//因为第一个输入的数可能是负数，所以这个判断放for循环的最前面
        scanf("%d",&a[i%2]);//滚动
        sum+=a[i%2];
        a[i%2]=max(a[(i-1)%2],sum);//DP状态转移方程
    }
    printf("%d",a[n%2]);
    return 0;
} 

```

---

## 作者：h2oland (赞：43)

# 模拟退火
~~DP太无聊了~~我要用模拟退火来做这道题概念见**原理部分**  
设定初温T,终温eps,降温系数a,退火次数fire  
每次退火开始就重置温度t,随机生成一个子段作为初始解
#### 考虑如何生成新方案
根据题意有4个操作
1. 左移子段左端点
2. 右移子段左端点
3. 左移子段右端点
4. 右移子段右端点 

我们随机一个操作,再随机一下移动的距离dis  
dis的范围与t成正比效果最好  
设$alpha={dis/t(dis>=t),dis*t(dis<t)}$  
然后判断新子段是否合法,合法继续   
再判断新解是否更优（$新子段和-原子段和delta>0$）  
为了快速计算字段和我们需要前缀和优化~~不会自己百度~~  
设接受新解的概率$p=exp(-Δ/t)$且随温度t的降低而降低  
如果更优显然p>1一定接受  
如果更劣0<p<1一定概率接受  
每次操作后降温$t=t*a$
#### 原理
一开始温度很高以较高概率接受劣解,很容易跳出局部最优解  
随着温度降低解越来越稳定，最后稳定在局部最优解   
当然只有一定概率是全局最优解  
我们可以运行多次(重新烧热再退火)取每次结果的最大值
#### 关于参数和复杂度
一般根据题目数据范围取a=0.95-0.99,T=$10^3$-$10^5$,eps=$10^{-5}$-$10^{-7}$   
时间复杂度只与参数有关与问题规模无关  每次生成新解$O(1)$   
每次退火生成新解的次数$x=O(log_a{eps/T})$  
总时间复杂度$O(firelog_a{eps/T})$  
一般根据运行时间和正确性调参如果时间充裕可以适当开大  
#### 总结
补充个坑点就是linux的RAND_MAX是$2^{31}$-$1$而windows是$2^{15}-1$  
~~我RE了好多次~~所以在windows下可以这么写
```cpp
#define rand_windows() (rand()*16384ll+(rand()>>1))
#define RAND_MAX_windows 268435456.0
```
然后在程序里用,但在提交时一定要改回去  
因为是普及-的题所以尽量通俗但可能牺牲严谨性,有疑问的可以百度  
不会正解的可以用这个骗很多分~~洗把脸或多交几发就AC了~~附上我的代码  
~~新人第一篇题解管理员求过~~
```cpp
#include<bits/stdc++.h>
#define rand_windows() (rand()*16384ll+(rand()>>1))
#define rand_max_windows 268435456.0
using namespace std;
const double A=0.98,T=2e4,eps=1e-5;const int fire=15000,alpha=1;
int n,a[200001],current[2];long long s[1000001],ans=-0x7fffffffffffffff;
int main()
{
    scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]),s[i]=s[i-1]+a[i];
    for(int k=1;k<=fire;k++){
        srand(rand()+clock());double t=T,p;long long res,dis,delta;short operation;
        for(int i=0;i<2;i++)current[i]=rand()%n+1;sort(current,current+2);res=s[current[1]]-s[current[0]-1];
        while(t-eps>0){
            t*=A;operation=rand()%4;dis=rand()*1ll*t*alpha/RAND_MAX+1;p=1.0;
        	switch(operation){
        		case 0:{if(current[0]-dis<1)break;delta=s[current[0]-1]-s[current[0]-dis-1];if(delta<=0)p=rand()/(double)RAND_MAX;if(p<exp((double)delta/t))res+=delta,current[0]-=dis;break;}
        		case 1:{if(current[0]+dis>current[1])break;delta=s[current[0]-1]-s[current[0]+dis-1];if(delta<=0)p=rand()/(double)RAND_MAX;if(p<exp((double)delta/t))res+=delta,current[0]+=dis;break;}
        		case 2:{if(current[1]-dis<current[0])break;delta=s[current[1]-dis]-s[current[1]];if(delta<=0)p=rand()/(double)RAND_MAX;if(p<exp((double)delta/t))res+=delta,current[1]-=dis;break;}
        		case 3:{if(current[1]+dis>n)break;delta=s[current[1]+dis]-s[current[1]];if(delta<=0)p=rand()/(double)RAND_MAX;if(p<exp((double)delta/t))res+=delta,current[1]+=dis;break;}
            }
        }
        if(res>ans)ans=res;
    }
    printf("%lld",ans);
    return 0;
} 
```


---

## 作者：Silvermoon (赞：24)

**题目意思大家应该都懂了(~~这不废话吗~~)**

 _**这里介绍几种方法(大神勿喷)**_ 
 
 _** Part 1**_
 
最朴素的想法：枚举一个i，一个j，再用一个k循环把i到j之间的数加起来，并同时用max保存即可(时间复杂度**O(n^3)**)。代码大概像这样：
 
```cpp
for (int i=1;i<=n;i++)
{
	for (int j=i;j<=n;j++)
	{
		tot=0;
		for (int k=i;k<=j;k++) tot+=a[k];
		mx=max(tot,mx);
	}
}
```

结果大概像这样：

**TLE TLE TLE TLE TLE**

 _**Part 2**_ 
 
 新思路：可以用到前缀和$$sum[i]$$ 表示输入序列的第1项到第i项的和，并可以在输入时预处理，那么我们只需要枚举i和j，再用$$sum[j]-sum[i]$$即可(时间复杂度**O(n^2)**)。代码大概像这样：
 
```cpp
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=i;j<=n;j++)
		{
			mx=max(sum[j]-sum[i]+a[i],mx);
		}
	}
```

结果......

**AC AC TLE TLE TLE**

 _**Part 3**_ 
 
 采用分治的思想，分成一个个区间，在加来加去的过程中保存最大值即可(时间复杂度**O(n log n)**)
 
 由于这不是最好的方法，这里就不给代码了**~~(我才不会告诉你们这是因为我自己都没写出来才不给你们代码的)~~**
 
 结果还不错：
 
** AC AC AC AC AC**
 
 _** Part 4**_ 
 
 动态规划，我们可以发现，对于i来说，序列1到i中的最大子段只有两种情况：
 
 1.从i前面某个数加到a[i]
 
 2.a[i]自己
 
 所以就得到了状态转移方程：$$f[i]=max(f[i-1]+a[i],a[i])$$
 
 初始值为$$f[0]=-2147483647$$
 
 即可(时间复杂度**O(n)**)
 
 结果就不说了 _**(你懂的)**_ 
 
 _** Part 5**_ 
 
 正解优化(空间)，我们发现，对于每一个i的操作，我们都只要用到$$f[i],f[i-1],a[i]$$所以我们
 
 _** 不需要数组！！！**_ 
 
  _** 不需要数组！！！**_ 
  
   _** 不需要数组！！！**_ 
   
每次输入一个a并立即操作，用last保存f[i-1]，用now保存f[i]即可(时间复杂度O(n),空间复杂度O(1)~~(其实是O(5)左右)~~)

代码：

```cpp
#include<cstdio>
#define ll long long
using namespace std;
ll n,f[200001],a,ans=-99999999999999999;
ll max(ll x,ll y){return x>y?x:y;}
int main()
{
    scanf("%lld",&n);
    for (int i=1;i<=n;i++)
        f[i]=-9999999999999999;
    for (int i=1;i<=n;i++)
    {
        scanf("%lld",&a);
        f[i]=max(a,f[i-1]+a);
        if (ans<f[i])
        {
            ans=f[i];
        }
    }
    printf("%lld",ans);
    return 0;
}
```

~~**(别问我为什么开long long，我在我团队出了一道...的题)**~~


 _**感谢您的阅读！**_ 

---

## 作者：小黑AWM (赞：22)

### 翻到底发现竟然没有单调队列的题解。
***
最大子序列和是一道经典的单调队列题，其模型常用不亚于滑动窗口。

## 从本题切入
本题是一道极其简单的题目。

子序和就是两个前缀和的差值，当我们确定了子序列的右端点j之后我们就得到了子问题找到最佳的左端点i使子序列和最小。

即
$$ ans=min\left\{ sum[j] - min \left\{sum[\space i-1\space],\space\space i\in[\space 1, j\space)\space \right\},\space\space j \in [1,n]\space\right\}$$

这个问题显然可以$O(n^2)$地得到解决方案，但是为了通过2e5的数据我们需要一个更快的算法。

通过简单地观察我们可以发现对于子问题$min \left\{sum[\space i-1\space],\space\space i\in[\space 1, j\space)\space \right\}$我们或许不需要用一个循环枚举所有的决策，对于我们有价值的只有最后一个决策点$k$，使得$sum[k]$在所有符合要求的决策中最小/最优。

如果我们不断地更新i之前的最优决策，那么我们就可以直接$O(1)$地求出子问题的解，所以总复杂度就是n个子问题加起来也就是$O(n)$的。
```cpp
#include <iostream>
#include <cmath>
using namespace std;
const int maxn = 2e5 + 10;
int n, m, ans = 0x80000000, sum[maxn], a, choice = 0x7fffffff;
int main(){
    cin >> n ;
    m = n;
    for(int i = 1; i <= n; i++){
        cin >> a;
        sum[i] = sum[i-1] + a;
        choice = min(sum[i-1], choice);//得到i之前的最优决策
        ans = max(ans, sum[i] - choice);//选出当前最优决策
    }
    cout << ans << endl;
    return 0;
}

```
如果你只是想知道怎么做这题，或者你不知道队列是什么，那么看到这里就够了。
## 单调队列
让我们思考一下这题的升级版，如果我们限制了子序列的长度不得超过$m$那么又该怎么做？

还是先之前一样，抽象出问题模型。
$$ ans=min\left\{ sum[j] - min \left\{sum[\space i-1\space],\space\space i\in[\space j-m, j\space)\space \right\},\space\space j \in [1,n]\space\right\}$$
与上一个问题不同，因为此题中我们增加了长度限制，所以我们不能故伎重演，直接保存$i$之前的最优决策。

由于我们直接保存的最优决策的决策点$k$可能超出了长度限制，所以我们需要的是长度限制内的最优决策点，那么对于超出了长度限制的，过期了的决策我们就可以抛弃。那么如何维护一个这样的最优决策呢？

### 介绍单调队列
这是一种特殊的队列，可以同时从队首和队尾出队，一般我们用它来维护一个队列的单调性，如果决策的最优性不单调，我们就通过队尾出队的方式来保证队列中的元素单调，并通过队头出队抛弃过期的决策。

而在子序列和的问题中我们知道一个决策点的前缀和越小，则这个决策越优，那么如果在我们储存的决策点中，如果有一个决策点$k2$之前存在一个决策点$k1 < k2$满足$sum[k1] > sum[k2]$，显然k1不是一个优秀的决策，因为k1距离更远，而不够优秀，所以当我们取到了$k2$我们就可以抛弃$k1$这个决策。根据题目的这个性质我们就可以维护单调队列，使得队中决策点**下标位置递增，且前缀和也是递增**，这就像有了一个更好看也更爱你的异性你就可以适时地抛弃之前那个价值不够高的选择。

上代码
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <queue>
using namespace std;
const int maxn = 2e5 + 10;
int n, m, ans = 0x80000000, sum[maxn], a;
deque<int> Q;//用于存储决策
//单调队列算法首先证明决策在满足某种单调性的前提下可以使得答案更优的情况，然后抛弃不优的决策，在这里就是选尽量靠前的sum小的决策
int main(){
    cin >> n >> m;
    Q.push_back(0);//存入初始决策，即左端点为1的情况
    for(int i = 1; i <= n; i++){
        cin >> a;
        sum[i] = sum[i-1] + a;
        while(!Q.empty() && Q.front() < i - m) Q.pop_front();//抛弃过期的决策
        cerr << sum[i] - sum[Q.front()] << endl;
        ans = max(ans, sum[i] - sum[Q.front()]);//选出当前最优决策
        while(!Q.empty() && sum[Q.back()] > sum[i]) Q.pop_back();//维护决策的单调性
        Q.push_back(i);
    }
    cout << ans << endl;
    return 0;
}

```
这样我们就可以得到一个$O(n)$的算法了。

复杂度证明：每个点只会入队出队一次，所以是$O(n)$的。

## 更多应用
在学习单调队列的过程中我们发现了单调队列可以维护一个区间内的最优策略。不仅仅是区间min，sum这种简单的操作还有更多的骚操作，比如进行一些DP决策单调性的优化（如多重背包）（男人八题.jpg

#### 撒花????


---

## 作者：LiHaoYu0512 (赞：15)

第一次写题解，望dalao勿喷

这道题要只用前缀和，复杂度就是O(n^2)，会爆掉！！！

因此，机智的我使用了前缀和和前缀min，这样，复杂度就变成了O(n)!!!

用当前前缀和减去当前前缀min,就可以得到当前ans的最大值啦！

---

话不多说，直接上程序！！！

```cpp
#include<iostream>
#include<algorithm>
#include<climits>
#define MAXN 200005
using namespace std;
int a[MAXN];
int s[MAXN],mins[MAXN];
//前缀和是s数组，前缀min是mins数组！！！ 
int main()
{
    cin>>N;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
        s[i]=s[i-1]+a[i];
        //求前缀和
        mins[i]=min(mins[i-1],s[i]);
        //求前缀min
        //O(1)递推
    }
    int ans=a[1];
    for(int i=2;i<=N;i++) ans=max(ans,s[i]-mins[i-1]);
    cout<<ans;
    return 0;//程序拜拜！！！
}

```

当然，如果你想尝试暴力的话...

你就会惊奇的发现：
你的程序爆掉了！！！

因为暴力的复杂度是：O(N^3)！！！

---

## 作者：a1370678587 (赞：14)

为啥要动规，不就是个简单的递推，推下去就是了

```cpp
#include<iostream>
int main()
{
    using namespace std;
    int a,b=0;
    int n,sum=-100001;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a;  //不用判断取不取数，反正这个数必须取，不取这个数就串不下去，重开串了
        if(b>0) b+=a;//如果前面的串比较大，就继续叠加下去，如果前面的串还不如0大
        else b=a;       //就重开一串
        if(b>sum) sum=b;//保存最大值
    }
    cout<<sum;
    return 0;
}

```

---

## 作者：yizimi远欣 (赞：12)

## **下面给出两种做法，请同学们根据自己能力来阅读**

### 1.正常普及选手做法:

实际上是个——

### 贪心。

贪心思想：我们可以先维护一个前缀和，如果我们使得一个区间的右端点的前缀和-左端点的前缀和最大，那么这段的最大子段和就是最大。

做法：我们只需要先求出这个数组每个元素的前缀和，然后从后往前扫，在扫的时候找出最小前缀和，并把这个元素作为左端点，同时把当前元素当做右端点，寻找最大的前缀和差值。

### 代码1：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mn 200010
#define go(i,j,n,k) for(register int i=j;i<=n;i+=k) 
#define fo(i,j,n,k) for(register int i=j;i>=n;i-=k)
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} 
    return x*f;
}
int n,sum,mi=0,ma=-99999;
int a[mn],b[mn];
int f[mn];
int main(){
    n=read();
    go(i,1,n,1){
        a[i]=read();
        f[i]=f[i-1]+a[i];
    }
    b[1]=f[1];mi=min(0,f[1]);
    go(i,2,n,1){
        b[i]=f[i]-mi;
        mi=min(mi,f[i]);
    }
    go(i,1,n,1){
        ma=max(ma,b[i]);
    }
    cout<<ma;
    return 0;
}
```


### 2.~~无脑~~提高选手做法：

### 主要~~无脑~~思路：线段树 + DP

数据范围要求正好是nlogn的，我们就可以想到线段树这个~~万能（伪）的~~数据结构。

我们可以维护四个变量：

	struct tree{
    	int sum;  //区间和
        int lsum; //区间内紧靠左端点的最大子段和
        int rsum; //区间内紧靠右端点的最大子段和
        int msum; //区间内最大子段和
    }
    
我们可以思考下如何更新这几个值：

首先是sum，这个直接把左右儿子的值加起来就可以了

其次是lsum与rsum，这两个值的维护方法是基本相似的。因为左/右端点是固定的，所以，靠近左/右端点的最大子段和就只可能是两种情况：要不就是左/右半部分的靠近左/右端点的最大子段和，要不就是左/右半部分的和加上右/左半部分的靠近左/右端点的最大子段和。

最后是msum，最大子段和所在区间可能完全在左半部分，可能完全在右半部分，也有可能是跨越了左右半边。所以我们取最大的，其中跨越左右半部分的可以贪心的取左半部分靠近右端点的最大子段和，加上右半部分靠近左端点的最大子段和。

如果会了更新，也就基本做完了这道题。

更新的代码如下：

```cpp
inline void update(int rt){
    z[rt].sum = z[rt << 1].sum + z[rt << 1 | 1].sum;
    z[rt].lsum = max(z[rt << 1].lsum, z[rt << 1 | 1].lsum + z[rt << 1].sum);
    z[rt].rsum = max(z[rt << 1 | 1].rsum, z[rt << 1].rsum + z[rt << 1 | 1].sum);
    z[rt].msum = max(max(z[rt << 1].msum, z[rt << 1 | 1].msum), z[rt << 1].rsum + z[rt << 1 | 1].lsum);
}
```

建树和普通线段树是一致的，想看这部分代码的同学直接翻到最下方代码部分。

在查询时有一些特殊操作。（也不算太特殊）

普通的线段树（区间求和）在询问时会有一个求和更新的过程，我们只要把这个过程改成和update函数类似的方法。

**如果看不懂部分类似变量的东西，那可能是我的宏定义，请参考完整代码中的宏定义**

```cpp
inline tree query(int l,int r,int rt,int nowl,int nowr){
    if(nowl<=l && r<=nowr){
        return z[rt];
    }
    int m = (l + r) >> 1;
    if(nowl<=m){
        if(m<nowr){
            tree tl, tr, res;
            tl = query(lson, nowl, nowr);//读取左半部分的信息
            tr = query(rson, nowl, nowr);//读取右半部分的信息
            res.sum = tl.sum + tr.sum;
            res.lsum = max(tl.lsum, tl.sum + tr.lsum);
            res.rsum = max(tr.rsum, tr.sum + tl.rsum);
            res.msum = max(max(tl.msum, tr.msum), tl.rsum + tr.lsum);
            //这部分和之前的update函数十分的像。
            //实际上就是把左半部分与右半部分合并时更新节点信息
            return res;
        }else{//只在左半部分，直接返回左半部分
            return query(lson, nowl, nowr);
        }
    }else{//只在右半部分，直接返回右半部分
        return query(rson, nowl, nowr);
    }
}
```

主函数十分简单，这里就不讲了。

### 代码2：

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 200020
#define inf 1 << 30
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0)putchar('-'),x = -x;
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
//This is AC head above...
struct tree{
    int sum, lsum, rsum, msum;
} z[mn << 2];
inline void update(int rt){
    z[rt].sum = z[rt << 1].sum + z[rt << 1 | 1].sum;
    z[rt].lsum = max(z[rt << 1].lsum, z[rt << 1 | 1].lsum + z[rt << 1].sum);
    z[rt].rsum = max(z[rt << 1 | 1].rsum, z[rt << 1].rsum + z[rt << 1 | 1].sum);
    z[rt].msum = max(max(z[rt << 1].msum, z[rt << 1 | 1].msum), z[rt << 1].rsum + z[rt << 1 | 1].lsum);
}
inline void build(int l,int r,int rt){
    if(l==r){
        z[rt].lsum = z[rt].msum = z[rt].rsum = z[rt].sum = read();
        return;
    }
    int m = (l + r) >> 1;
    build(lson);
    build(rson);
    update(rt);
}
inline tree query(int l,int r,int rt,int nowl,int nowr){
    if(nowl<=l && r<=nowr){
        return z[rt];
    }
    int m = (l + r) >> 1;
    if(nowl<=m){
        if(m<nowr){
            tree tl, tr, res;
            tl = query(lson, nowl, nowr);
            tr = query(rson, nowl, nowr);
            res.sum = tl.sum + tr.sum;
            res.lsum = max(tl.lsum, tl.sum + tr.lsum);
            res.rsum = max(tr.rsum, tr.sum + tl.rsum);
            res.msum = max(max(tl.msum, tr.msum), tl.rsum + tr.lsum);
            return res;
        }else{
            return query(lson, nowl, nowr);
        }
    }else{
        return query(rson, nowl, nowr);
    }
}
int n;
int main(){
    n = read();
    build(root);
    cout << query(root, 1, n).msum << "\n";
    return 0;
}

```

#### 第十次写题解，希望可以同时帮到普及和提高的同学

---

## 作者：hhhwg07 (赞：11)

这道题实际上可以使用分治法（复杂度为（nlogn），虽然慢一些，但应付这道题还是没有问题的）

分治的思路是讲数列平均分成两部分（按数量劈半）称为L、R，再用一个函数算出所有子段中互相串界（即有L的一部分，也有R的一部分）的子段的和的最大值称为G ，而答案就是L的最大子段和和R的最大子段和和G三个数中的最大值，而L、R的最大子段和也用同样的方法考虑。

前方高能预警

------------
先定义一些变量
```cpp
int a[200001+3],n;//存数列，数列个数
```

之后要制作求G的函数g

具体思路是将中点定为m，之后从m向左延伸，取最大，m+1向右延伸，取最大，之后相加（要互相串界，所以m,m+1必须要有）。
```cpp
int g(int l,int m,int r){//l,右边界、r,左边界、m,中间数
	int max1=a[m],max2=a[m+1];//最大值
	int sum1=0,sum2=0;//和，循环用
    //从m向左延伸
	for(int i=m;i>=l;i--){
		sum1+=a[i];
		max1=max(max1,sum1);
	}
    //从m+1向右延伸
	for(int i=m+1;i<=r;i++){
		sum2+=a[i];
		max2=max(max2,sum2);
	}
	return max1+max2;
}
```

按照上面的方法递归求解，递归出口为两个边界相等（即只有一个数）
```cpp
int he(int l,int r){
	if(l==r){
		return a[l];
	}
	int mid=(l+r)/2;
	return max(he(l,mid),max(he(mid+1,r),g(l,mid,r)));
}
```
之后一切都简单了

建议大家到这里就关闭此页面，去做题


------------
来个五星好评，谢谢







------------
好吧你要代码就要吧，你要做小人也不管你了
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <string>
#include <algorithm>
using namespace std;
int a[200001+3],n;
int g(int l,int m,int r){
	int max1=a[m],max2=a[m+1];
	int sum1=0,sum2=0;
	for(int i=m;i>=l;i--){
		sum1+=a[i];
		max1=max(max1,sum1);
	}
	for(int i=m+1;i<=r;i++){
		sum2+=a[i];
		max2=max(max2,sum2);
	}
	return max1+max2;
}
int he(int l,int r){
	if(l==r){
		return a[l];
	}
	int mid=(l+r)/2;
	return max(he(l,mid),max(he(mid+1,r),g(l,mid,r)));
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cout<<he(1,n)<<endl;
	return 0;
}

```

---

## 作者：R·Buffoon (赞：10)

**单调队列入门题**（虽然标签里没有$\colorbox{red}{\color{white}\text{单调队列}}$）
***
>单调队列是就有单调性的队列，有单调递增和单调递减两种，一般来讲，队列的队首是整个队列的最大值或最小值(~~废话~~)  
>作用：
>>可以求出一段数列内第一个大于等于一个数x的数,也可以通过维护单调性，解决一些区间内最小或最大的问题  

>实现：
>>可以用$STL$的$deque$，也可以手写数组（个人比较喜欢用手写数组，用$STL$的话有好多‘.’啊，‘()’啊）

***
栗子

7  
7 6 8 12 9 10 3   
求最大值

$i=0$，队列初始化0，队列为{0}  
$i=1$，因为$7>0$，所以7入队，0出队（要维护这个队列单调递减），队列为{7}  
$i=2$，因为$6<7$，所以6入队，队列为{7，6}  
$i=3$，因为$8>6$，所以6出队，$8>7$，所以7出队，8入队，队列为{8}  
$i=4$，因为$12>8$，所以8出队，12入队，队列为{12}  
$i=5$，因为$9<12$，所以9入队，队列为{12，9}  
$i=6$，因为$10>9$，所以9出队，$10<12$，所以10入队，队列为{12，10}  
$i=7$，因为$3<10$，所以3入队，队列为{12，10，3}，但是，因为12的位置为4，不在$(i-3,i]$，这个范围内，所以出队，队列为{10，3}

这时就有人奇怪了，队列里剩下的不是最大值呀

其实不难发现，每个队列的队头就是当前的最大值，所以只要每次更新完队列后让更新前的最大值与更新后的最大值比较就行

最小值同理
***
对于这题，要维护的是一个区间段的最大值，这就要用到前缀和，怎么用呢，看代码
```cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
    int qwq=0,qaq=1;char cc=getchar();
    for(;!isdigit(cc);cc=getchar())if(cc=='-')qaq=-1;
    for(;isdigit(cc);cc=getchar()) qwq=(qwq<<1)+(qwq<<3)+(cc&15);
    return qwq*qaq;
}

const int N=5e5+5;
const int INF=987654321;

int n,m,l,r;
int a[N],q[N],ans;

int main()
{
    n=in();
    
    ans=-INF,l=1,r=1;//初始化
    for(RI i=1;i<=n;++i)
    {
		a[i]=a[i-1]+in();//前缀和
		
		//while(l<=r && q[l]+m<i) ++l;//这里是用来把不在区间的数进行出队操作，由于这题的范围就是n，所以可以不用
		
		ans=max(ans,a[i]-a[q[l]]);//更新最大值
		
		while(l<=r && a[i]<=a[q[r]]) --r;//维护队列单调性
		
		q[++r]=i;//储存位置
	}
	
	cout<<ans<<endl;
	
    return 0;
}
```
***
单调队列强化题：  
[P1440 求m区间内的最小值](https://www.luogu.org/problem/P1440)  
[P1714 切蛋糕](https://www.luogu.org/problem/P1714)（这题跟这题（笑）一样，只要把注释去掉）  
[P1725 琪露诺](https://www.luogu.org/problem/P1725)（似乎是升级版？）  
[P1886 滑动窗口](https://www.luogu.org/problem/P1886)  
[P2032 扫描](https://www.luogu.org/problem/P2032) 
***
~~如果这篇题解过了，那就有67篇题解了，多么吉利的数字啊~~

**最后：~~NOIP2019~~$CSP2019-RP^{+^{+^{+^{+^{+^{+^{+^{+^{+}}}}}}}}}$**

---

## 作者：Smallbasic (赞：7)

## 很明显的线段树啊。。。

这题是小白逛公园的弱化版，小白逛公园过了这题就能过。

简单讲一下线段树做法：

先思考如何将区间$[a,b],[b+1,c]$，合并成一个区间。

显然$[a,c]$的和最大的子段要么在$[a,b]$,要么在$[b,c]$，要么在中间，于是分3种情况讨论。

考虑在每个区间维护区间和sum，区间左端点为起点的最大子段和ls,右端点为起点的最大子段和rs和这个区间的最大子段和ms：

$$1:\space\space ms =  left->ms$$

$$2:\space\space ms = right -> ms$$

$$3:\space\space ms = left->rs+right->ls$$

三种情况取max即可。

具体的，ls和rs也可以类似维护，如下：

$$ls=\max\{left->ls,left->sum+right->ls\}$$

$$rs=\max\{right->rs,right->sum+left->rs\}$$

有了这些显然可以分治了。而线段树的定义让我们知道它刚好可以模拟这个分治过程。

代码直接从小白逛公园粘过来的，有很多没用的东西，就将就着看吧：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int a[500005], n, m;

inline int read() {
	register int s = 0, f = 1;
	register char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s * f;
}

inline int max_(int a, int b) {
	return a > b ? a : b;
}

struct node {
	int l, r, ls, rs, ms, sum;
	node *left = NULL;
	node *right = NULL;
	
	inline void update() {
		if (left == NULL) return ;
		this -> sum = left -> sum + right -> sum;
		this -> ls = max_(left -> ls, left -> sum + right -> ls);
		this -> rs = max_(right -> rs, right -> sum + left -> rs);
		this -> ms = max_(max_(left -> ms, right -> ms), left -> rs + right -> ls);
	}
	
	inline void build(int l, int r) {
		this -> l = l; this -> r = r;
		if (l >= r) ls = rs = ms = sum = a[l];
		else {
			left = new node; left -> build(l, l + r >> 1);
			right = new node; right -> build((l + r >> 1) + 1, r);
			this -> update();
		}
	}
	
	inline void modify(int l, int k) {
		if (this -> l >= this -> r) { this -> ls = this -> rs = this -> ms = this -> sum = k; return ; }
		if (l <= left -> r) left -> modify(l, k);
		if (l >= right -> l) right -> modify(l, k);
		this -> update(); return ;
	}
	
	inline node* query(int l, int r) {
		node *ret = new node; ret -> ls = ls; ret -> rs = rs; ret -> sum = sum; ret -> ms = ms;
		if (this -> l >= l && this -> r <= r) return ret;
		if (r <= left -> r) { delete ret; return left -> query(l, r); }
		else if (l >= right -> l) { delete ret; return right -> query(l, r); }
		else {
			ret -> left = left -> query(l, r); ret -> right = right -> query(l, r);  ret -> update();
			delete ret -> left; delete ret -> right; return ret;
		}
	}
};

int main() {
	n = read();
	for (int i = 1; i <= n; ++i) a[i] = read();
	node *root = new node; root -> build(1, n);
	node *cur = root -> query(1, n);
	printf("%d", cur -> ms); return 0;
}
```


---

## 作者：Drinkkk (赞：7)

/\*
P1115 题解

动态规划的应用


思路：

如何进行动态规划？

好的，我们先看一下样例：

$input:$

2 -4 3 -1 2 -4 3

$output:$

4

很显然，取3 -1 2这一段是最优解。

那么，我们假设$f[i]$为结尾在第$i$个格子的最优解，用$a$数组来表示这些数（即$a[i]$表示这个集合中的第$i$个数），那么很显然，答案就是$f[n]$。


不难发现，如果我们在第$i$个格子，那么我们可以选择在第$i-1$个格子的最优解+第$i$个格子的值，或第$i$个格子的值或$0$。

那么得到结论：

$f[1]=a[1]$，并且如果$a[i]>=0$，那么：$f[i]=f[i-1]+a[i];$

否则：$f[i]=max(0,f[i-1]+a[i]);$

（$i>=2$）。

将其简化后得到：

$f[i]=max(0,max(f[i-1]+a[i],a[i]));$

（$i>=1$）。

但是如果输入的数据全是负数怎么办呢？

所以我们还要再加上一个特判，就是当输入的数据全是负数的时候输出最小的那个负数（因为选的区域不能够为$0$）。

所以特判部分如下：

```cpp
for(int i=1;i<=n;i++)
{
    scanf("%d",&a[i]);
    jl=max(jl,a[i]);
    dq=max(dq,a[i]);
}
if(jl==-1)
{
    printf("%d",dq);
    return 0;
}
```
那么，我们现在再整理一下结论：
那么得到结论：

$f[1]=a[1]$，并且如果$a[i]>=0$，那么：$f[i]=f[i-1]+a[i];$

否则：$f[i]=max(0,f[i-1]+a[i]);$

（$i>=2$，且当$a$数组内至少有一个正整数或$0$时成立）。

将其简化后得到：

$f[i]=max(0,max(f[i-1]+a[i],a[i]));$

（$i>=1$，且当$a$数组内至少有一个正整数或$0$时成立）。


下面上AC代码：

\*/
```cpp
#include <cstdio>
int f[1000001],a[1000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int dq=-999999999,jl=-1,ans=0,n=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        jl=max(jl,a[i]);
        dq=max(dq,a[i]);
    }
    if(jl==-1)
    {
        printf("%d",dq);
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        f[i]=max(0,max(f[i-1]+a[i],a[i]));
    }
    for(int i=1;i<=n;i++)
    {
        ans=max(ans,f[i]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Awdrgysxc (赞：4)

## 【分析】
线段树不仅可以做这题，可以做动态最大连续和

我们需要用线段树维护三个东西：

1.max_sub(最大连续和的起点和终点) 2.max_prefix（最大前缀和的终点） 3.max_suffix（最大后缀和的起点）

我们考虑如何求出它们

### 1.最大连续和 = max(左孩子的最大后缀和 + 右孩子的最大前缀和   ,
### max（左孩子的最大连续和，右孩子的最大连续和））

### 2.最大前缀和 = max（左孩子的最大前缀和，左孩子的全部 + 右孩子的最大前缀和）

### 3.最大后缀和 = max（右孩子的前缀和，右孩子的全部 + 左孩子的最大后缀和）

## 【Code】
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <cstdlib>

using namespace std;

typedef long long I64;

inline int read() {
	int ret=0;bool flag=0;char c=getchar();
	while((c<'0')|(c>'9')) flag ^= !(c^'-'),c=getchar();
	while((c>='0')&(c<='9')) ret=(ret<<3)+(ret<<1)+(c^'0'),c=getchar();
	return flag?-ret:ret;
}

const int M = 2e5 + 11;

struct {
	int max_suffix,max_prefix;
	pair<int,int> max_sub;
}Tree[M<<2];

namespace Segment_tree
{
	int n,pre_sum[M]; 
	
	inline void make_presum()
	{
		pre_sum[0] = 0;
		for(int i = 1;i <= n; i++)
			pre_sum[i] = pre_sum[i - 1] + read();
	}
	
	I64 ask_sum(int l,int r)
	{
		return pre_sum[r] - pre_sum[l - 1];
	}
	
	inline I64 ask_sum(pair<int,int> x)
	{
		return pre_sum[x.second] - pre_sum[x.first - 1];
	}
	
	inline pair<int,int> allow(pair<int,int> x,pair<int,int> y)
	{
		if(ask_sum(x) != ask_sum(y))
			return ask_sum(x) > ask_sum(y) ? x : y;
		return x < y ? x : y;
	}
	
	inline void push_up(int k,int l,int r)
	{
		int lson = k<<1,rson = k<<1|1;
		Tree[k].max_sub = allow(Tree[lson].max_sub,Tree[rson].max_sub);
		Tree[k].max_sub = allow(Tree[k].max_sub,make_pair(Tree[lson].max_suffix,Tree[rson].max_prefix));
		
		I64 lson_max_prefix = ask_sum(l,Tree[lson].max_prefix);
		I64 rson_lson_prefix = ask_sum(l,Tree[rson].max_prefix);
		I64& sum1 = lson_max_prefix;
		I64& sum2 = rson_lson_prefix;
		Tree[k].max_prefix = sum1 > sum2 ? Tree[lson].max_prefix : Tree[rson].max_prefix;
		
		I64 rson_max_suffix = ask_sum(Tree[rson].max_suffix,r);
		I64 lson_rson_suffix = ask_sum(Tree[lson].max_suffix,r);
		I64& sum3 = rson_max_suffix;
		I64& sum4 = lson_rson_suffix;
		Tree[k].max_suffix = sum3 > sum4 ? Tree[rson].max_suffix : Tree[lson].max_suffix;
	}
	
	inline void build(int k,int l,int r)
	{
		if(l == r)
		{
			Tree[k].max_suffix = Tree[k].max_prefix = l;
			Tree[k].max_sub = make_pair(l,l);
			return ;
		}
		int mid = l + r >> 1;
		build(k<<1,l,mid);
		build(k<<1|1,mid + 1,r);
		push_up(k,l,r);
	}
	
	inline void Init()
	{
		n = read();
		
		make_presum();
		build(1,1,n);
		printf("%lld\n",ask_sum(Tree[1].max_sub));
	}
}

using namespace Segment_tree;

int main(void)
{
	Init();
	return 0;
}
```

---

## 作者：Li_zi_wei (赞：3)

虽然已经有65篇了但我还是发一下单调队列吧...

[记得可以宣传博客的说](https://lzwblog.tk/)

P.S 我只是想做分治突然发现[这道题](https://www.luogu.com.cn/problem/P1115)...可以单调队列...

时间复杂度$O(n)$ 空间复杂度$O(n^2)$ 你们总不至于不喜欢吧...

接下来是代码(蒟蒻第二次的题解(第一次因为无意义被退回了))

P.S 希望这次不会

```
//单调队列(huaji)
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int a[1000100];//原数组
int q[1000100]; //
int n,m,h = 1,t = 1;
int ans = -2333333; 

int main()
{
	cin >> n;
   m = n; 
	for (int i = 1;i <= n;i ++)
	{
		cin >> a[i];
		a[i] += a[i - 1];//前缀和
		
	}
	
	for(int i = 1;i <= n;i ++)
	{
        while(h <= t&&a[i] <= a[q[t]]) t --;//维护单调性
        while(h <= t&&q[h] < i - m) h ++; //出队
        ans = max(ans,a[i] - a[q[h]]);
        t ++;
        q[t] = i;
   }
   
   cout << ans;
	return 0;
}

```



---

## 作者：EarthGiao (赞：3)

这道题，很简单，是我学了动态规划这么久，第一道，自己想出来怎么做的题，虽然是普及-但是我还是很骄傲的，就自信满满地来写题解了

首先，很正常的用for循环输入，存入一个数组a,
然后还是一个for循环，从1-n

这里就出现了最最最重要的递推关系式，我们可以酱紫想，每一个部分看他前面的那一个都只有和他连起来，还有和他不连起来这两种情况，所以只需要比较这个数本身的值和这个数加上前面那个数的值，就可以了，加上后大的话那就将这个数的值变为两个数的和，然后这两个数就可以看做一个整体，下一个数找加的时候只需要加前面这一个数就好了，因为前面这一个数是前面两个数的和，当然小的话就断开，这个数还是自己本身的值。

两个for循环AC这道动态规划的题

完整代码

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<map>
#include<set>
#include<cstring>
#include<string>
#include<queue>
#include<stack>

using namespace std;

int a[200001];

int main()
{
	int n,mxx = -9999999;//这里必须赋值一个很小的负数，是0的话有一个点就全是负数会WA的
	scanf("%d",&n);
	for(int i = 1;i <= n;++ i)
		scanf("%d",&a[i]);
	for(int i = 1;i <= n;++ i){
		a[i] = max(a[i],a[i] + a[i - 1]);//找前面的，如果加上前面的大于本身就加不然那么久不加断开子段 
		mxx = max(mxx,a[i]); //比较找最大的那个 
	}
	printf("%d\n",mxx);//输出 
}
```


---

## 作者：Brave_Cattle (赞：3)

这里我们讲一下线段树分治求最大子段和的方法．

线段树中记录几个变量：ls记录从区间左端点开始向右延伸能得到的最大子段和,rs记录从右端点开始向左延伸能得到的最大子段和,ss记录区间的最大子段和（不管是从区间中哪个位置开始）,sum记录区间和．

我们将正在合并的区间节点编号叫root,它的左端点为l,右端点为r

那在合并ls的时候只存在这样几种情况：
1. root左端点包含的最大子段的右端点延伸到了右儿子
1. root左端点包含的最大子段的右端点仍然在左儿子的范围内

合并rs也是同理．
然后考虑如何合并ss，root的包含的最大子段的左端点叫x,右端点叫y，那么只有这样几种情况：
1. x==l,mid+1<=y<r
1. x==l,y==r
1. l<x<=mid,mid+1<=y<r
1. l<x<=mid,y==r
1. l<x<y<=mid
1. mid+1<=x<y<=r

那么我们直接对这些情况进行讨论，下面看代码注释
```cpp
#include<bits/stdc++.h>
#define ll(x) (x<<1)
#define rr(x) (x<<1|1)
using namespace std;
const int N=200000+5;

int n;
int a[N];

struct seg_tree{
  int val, l, r, ls, rs, ss, sum;
}t[N*4];

int gi(){
  int ans = 0 , f = 1; char i = getchar();
  while(i<'0'||i>'9'){if(i=='-')f=-1;i=getchar();}
  while(i>='0'&&i<='9'){ans=ans*10+i-'0';i=getchar();}
  return ans * f;
}

void up(int x){
  int lx = ll(x) , rx = rr(x);//宏定义
  int l = t[lx].ls , r = t[rx].rs , m = t[lx].rs+t[rx].ls;
  t[x].ls = max(t[lx].ls , t[lx].sum+t[rx].ls);//对区间从最左边开始维护最大连续子段
  t[x].rs = max(t[rx].rs , t[rx].sum+t[lx].rs);
  t[x].ss = max(m , max(l , max(t[lx].ss,max(t[rx].ss,r))));//根据上面几种情况取最大值作为最大连续子段和
  t[x].sum = t[lx].sum + t[rx].sum;//统计区间和
}

void solve(int root,int l,int r){//递归建树
  int mid = l+r>>1;
  t[root].l = l , t[root].r = r;
  if(l == r){
    t[root].val = a[l];
    t[root].ss = t[root].ls = t[root].rs = t[root].sum = a[l];
    return;
  }
  solve(ll(root),l,mid);
  solve(rr(root),mid+1,r);
  up(root);//向上统计答案
}

int main(){
  //freopen("data.in","r",stdin);
  n = gi();
  for(int i=1;i<=n;i++) a[i] = gi();
  solve(1,1,n);
  printf("%d\n",t[1].ss);
  return 0;
}
```

---

## 作者：青石巷 (赞：3)

贴一个自己突发奇想来的做法......

设dp[0][i]表示前i个数字中，不选i的最大子段和，dp[1][i]表示前i个数字中，选i的最大子段和。

于是 状态转移方程就出来了:dp[0][i]=max(dp[[0][i-1],dp[1][i-1]);dp[1][i]=max(0,dp[1][i-1])+a[i];

是一个O(n)算法 答案就是max(dp[1][n],dp[0][n]);

然而 当数列全为负数时 答案是0 也就是一个都不选

所以 要特判一下数列全为负数的情况

感觉还是有一点小缺陷的呢......

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200000+10,inf=0x3fffffff;
int dp[2][maxn],a[maxn];
int n;
int main()
{
    int i,j,flg=0,ans=-inf;
    cin>>n;
    for(i=1;i<=n;i++){scanf("%d",&a[i]);if(a[i]>=0){flg=1;}}
    if(!flg){for(i=1;i<=n;i++){ans=max(ans,a[i]);}cout<<ans;return 0;}
    for(i=1;i<=n;i++)
    {
        dp[0][i]=max(dp[0][i-1],dp[1][i-1]);
        dp[1][i]=max(0,dp[1][i-1])+a[i];
    }
    cout<<max(dp[0][n],dp[1][n]);
    return 0;
}
```

---

## 作者：sunxiaofan (赞：3)

# 我认为这个方法是一个既玄学，又新颖的算法
先用stl库建立一个队列，then每输入一个值，就把它与队列中的值加起来，从中寻找最大值。为了防止太耗时，可以用剪枝。
代码如下：
```cpp
#include<cstdio>
#include<queue>
using namespace std;
long long n,k,maxn=-10000,cur;
queue<long long> q;
int main()
{
	scanf("%lld",&n);
	q.push(-100001); //在这里输入一个很特殊的值，使其入队列
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&k);
		if(k>maxn)maxn=k;//考虑子段长度为1的情况
		cur=q.front() ;
		while(cur!=-100001)//当遇到先前输入的那个特殊值时，我们就知道这个队列已经加了一个循环了
		{
			q.pop() ;
			cur+=k;
			if(cur>maxn)
			{
				maxn=cur;//找最大值
			}
			if(cur>=0)//判断是否需要剪枝
			{
				q.push(cur); 
			}
			cur=q.front() ;
		}
		q.pop();
		if(k>=0)q.push(k);
		q.push(-100001);//还是那个特殊值
	}
	printf("%lld",maxn);
	return 0;
}
```
我们再把要强调的拿出来：
# 重点，敲黑板
```
q.push(-100001); //在这里输入一个很特殊的值，使其入队列
if(k>maxn)maxn=k;//考虑子段长度为1的情况
while(cur!=-100001)//当遇到先前输入的那个特殊值时，我们就知道这个队列已经加了一个循环了
if(cur>=0)//判断是否需要剪枝
{
	q.push(cur); 
}
```
就是这样
# 熬夜写题解望通过




---

## 作者：AuroraIris (赞：3)

dp不说话


```cpp
uses math;
var f:array[0..2000000]of longint;
a:array[0..2000000]of longint;
i,j,n,cao:longint;
begin
cao:=-3838438;//忽略这个
readln(n);
for i:=1 to n do
read(a[i]);//读入
for i:=1 to n do//dp
f[i]:=max(f[i-1]+a[i],a[i]);
for i:=1 to n do//找最大子段（数据有点坑）
if cao<f[i] then
cao:=f[i];
write(cao);
end.
```
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dp思想

前面所有数的和如果小与0

加了也是负增长

所以不加

所以如果小于0

那么舍去前面的数

只要自己本身

如果前面所有数值和大于0

那加了以后会增长

所以加上

所以方程为

if f[i-1]>0 then

f[i]=f[i-1]+a[i]

else f[i]=a[i];

END.

---

## 作者：Joyce_Jiang (赞：3)

这道题本质很简单，但是其实还是可以用线段树来做，多思考一下发现其实线段树还支持修改和区间查询，，不过这里不多做介绍，

原理就是 一段的最大子段和等于max(tree[now\*2].next+tree[now\*2+1].front,max(tree[now\*2].ans,tree[now\*2+1].ans))——————左边的的最大后缀加上右边的最大前缀，左边的子段和，右边的子段和

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
struct node
{
    int l,r,front,next,sum,ans;//front最大前缀，next最大后缀，ans最大子段和
}tree[1000000];
void build(int now,int l,int r)
{
    tree[now].l=l;
    tree[now].r=r;
    if(l==r)
    {
        int t;
        scanf("%d",&t);
        tree[now].front=tree[now].sum=tree[now].ans=tree[now].next=t;
        return;
    }
    int mid=l+r>>1;
    build(now*2,l,mid);
    build(now*2+1,mid+1,r);
    tree[now].sum=tree[now*2].sum+tree[now*2+1].sum;
    tree[now].front=max(tree[now*2].front,tree[now*2+1].front+tree[now*2].sum);
    tree[now].next=max(tree[now*2+1].next,tree[now*2].next+tree[now*2+1].sum);
    tree[now].ans=max(tree[now*2].next+tree[now*2+1].front,max(tree[now*2].ans,tree[now*2+1].ans));
}
node query(int now,int l,int r)
{
    if(tree[now].l>=l&&tree[now].r<=r)return tree[now];
    int mid=tree[now].l+tree[now].r>>1;
    if(mid<l)
    return query(now*2+1,l,r);
    else if(mid>=r)return query(now*2,l,r);
    node p,q,w;
    p=query(now*2,l,mid);
    q=query(now*2+1,mid+1,r);
    w.ans=max(p.next+q.front,max(p.ans,q.ans));
    return w;
}
int main()
{
    scanf("%d",&n);
    build(1,1,n);
    printf("%d",query(1,1,n).ans);
    return 0;
}
```

---

## 作者：姜一洲 (赞：3)

我就不炫代码了。

因为子段是连续的，所以这题可以很轻松的进行递推。


首先我们开个数组d， d[i]表示以i为最后一个元素的子段的最大值。

由于无法肯定地知道以哪个元素为结尾的子段最大，所以我们打个maxx记录结果（记得输入有负数，所以别忘了初始化）。

开个a数组存读入（可以直接存d数组中）。

开始思路还很不明朗，但可以知道，负数加上任意一个数都只会小不会大，所以若是d[i]<0那么的d[i+1]就一定是a[i+1]，而若是d[i]>0那么d[i+1]肯定是a[i+1]加上一个d[i]（同时别忘了更新maxx）。

然而一次下来输出maxx此题就结束了。


---

## 作者：rainygame (赞：2)

本题可以使用分治算法解决。

首先考虑区间维护的值，假设我们已经求出 $[l,k]$ 和 $[k+1,r]$ 的最大子段和，现在需要求出 $[l,r]$ 的最大子段和。

那么 $[l,r]$ 的最大子段和就是两个区间内部的最大子段和，和 $[l,k]$ 强制选择右端点的最大子段和加上 $[k+1,r]$ 强制选择左端点的最大子段和的最大值。

考虑如何维护，对于 $[l,r]$ 的强制选择左端点的最大子段和，可以表示为 $[l,k]$ 的子段和和 $[l,k+1]$ 的和加上 $[k+1,r]$ 强制选择左端点的最大子段和的最大值。强制选择右边也是同样的。

所以对于一个区间一共需要维护 4 个值：最大子段和、强制选择左边的最大子段和、强制选择右边的最大子段和、区间和。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 200001

int n;
int a[MAXN];

struct Node{
    int maxn, sum;
    int maxl, maxr;
};

Node merge(int l, int r){
    if (l == r) return {a[l], a[l], a[l], a[l]};
    int mid((l+r)>>1);
    Node a(merge(l, mid)), b(merge(mid+1, r));
    // cout << l << ' ' << r << ' ' << max({a.maxn, b.maxn, a.maxr+b.maxn, a.maxn+b.maxl}) << '\n';
    return {max({a.maxn, b.maxn, a.maxr+b.maxl}),
            a.sum+b.sum,
            max(a.maxl, a.sum+b.maxl),
            max(b.maxr, a.maxr+b.sum)};
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    for (int i(1); i<=n; ++i) cin >> a[i];
    cout << merge(1, n).maxn;

    return 0;
}
```


---

## 作者：huangjunqi1 (赞：2)

##贪心+线扫！！！

这道题应该有很多种做法，但许多做法不是最优的。其实可以在O(n)的复杂度内解决。

贪心思想。若前面枚举到的和<0了，再加上这个数一定比这个数小，还不如从这个数开始重新找。

所以只要一个循环就可以了。

代码：

```cpp
#include<cstdio>
#include<algorithm>
typedef long long ll;
int a[1000000];
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    ll sum=0,ans=-(1<<29);
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for (int i=1;i<=n;i++)
    {
        sum+=a[i];
        ans=max(sum,ans);//由于答案有可能为负（第二个点），所以这句话的位置不能放错。
        if (sum<0) sum=0;
    }
    printf("%lld\n",ans);
}//代码很短，不到20行
```

---

## 作者：用户已注销 (赞：2)

>比较新奇的想法，和下面其他的题解不一样
当初看书的时候有看到过一种算法叫做**滑动窗口**。

但是因为我比较弱，所以滑动写的不是非常好

而且为了不出错，我还加了特判和简化问题

（上面都是废话，下面才是算法过程）

输入没什么好说的，数组开在main函数外面。

特判是如果没有正数，就输出最大的负数。

接下来开始简化问题，我的思路是把所有相邻的正数和负数柔和在一起，

并且删除所有的0。

这样做的好处是接下来处理的时候就可以快（不一定多少，如果恰好一个正一个负那就白搞）。

最后再小小优化一下，第一个或最后一个数如果是负数就删掉（最优决策中肯定没有）。

接下来开始核心代码，也就是滑动窗口的部分。

（注意现在数组两头是正数，然后一正一负……也就是总项数总是为奇数）

接下来开始核心代码，也就是滑动窗口的部分。

刚开始滑动窗口的左端点和右端点都是第一项，和是第一项的值（总是大于零）。

接下来把正数项称为滑动的价值，负数项称为滑动的代价，

显然总是先付出代价，再考虑要不要滑动。

如果当前的总价值还小于这次滑动的代价，

这个窗口就废了，然后跳过这个代价，开始下一次的滑动。

###为什么这样做总是合理的呢？

比如三个数1  -4  3

现在窗口滑到了1的位置，总价值是1。

窗口想把3放到窗口中，但是必须付出-4的代价。

所以这个窗口的滑动是不利的，于是要终结这个窗口，新的窗口从3的位置开始。

这就是滑动窗口。

下附丑陋代码，注释不多，因为上面写的很详细了。

···cpp

    
    
    
    
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
int n[200000+5],l,num[200000+5];
bool tepan()
{
    for(register int i=2;i<=l;i++)
    if(n[i]>0) return false;
    int maxxx=n[1];
    for(register int i=2;i<=l;i++)
    maxxx=max(maxxx,n[i]);
    return printf("%d\n",maxxx);
}
int main()
{
    scanf("%d",&l);
    for(register int i=1;i<=l;i++) scanf("%d",&n[i]);
    if(tepan()) return 0;/*特判（全是负数选个最大的）*/
    int top=1;
    bool u= n[1]>0 ;
    memset(num,0,sizeof(num));
    for(register int i=1;i<=l;i++)
    {
        if(n[i]==0) continue;/*0不会产生任何价值/代价*/
        if((u and n[i]>0) or (!u and n[i]<0)) num[top]+=n[i];/*不变号*/
        else
        {
            u = !u ;
            top++;
            num[top]=n[i];
```
}/\*变号\*/
    
    
```cpp
    }
    int l=1,r=1;
    if(num[1]<0) l=r=2;
    if(num[top]<0) top--;
```
/\*最优决策中一定不选头尾的负数\*/
    
    
```cpp
    int sum=num[l];
    int maxxx=sum;
    while(r<=top)
    {
        sum+=num[++r];/*滑*/
        if(sum<0)
        {
            l=r+1;
            sum=0;
```
}/\*当前价值小于滑动代价\*/
    
```cpp
        sum+=num[++r];/*再滑*/
        maxxx=max(maxxx,sum);
    }
    return !printf("%d\n",maxxx);
} 
···
```

---

## 作者：观星者 (赞：2)

从善如流，小百的第二篇题解：

——————————大忙人可以跳过这些——————————————

想起当年在机房模拟赛，遇到此题，比现在还弱的我看到这橙题仿佛看到了洪荒猛兽。只见隔壁的wmz大佬云淡风轻地敲了几下键盘，一篇清秀代码跃然屏上，~~然后就打开了扫雷~~。我惊为天人，连忙拿出零食孝敬，求得真传。时至今日落花时节，又见此题，不由自主地感叹到：“......为何当年我忘了抄文件读写。”

——————————切入正题———————————————————

wyh曰：这种思路是贪心

wmz曰：这种思路是DP

wzy曰：别吵，代码我还没看懂

我们不管他们曰了什么，我们来看看这个思路：

首先有两个变量，imax和num。按照输入顺序，num都加上一个数，然后imax=max(imax,num)，然后如果num<0的话，num=0。最后输出imax

~~我知道如果我说我讲完了，我会被打，题解也通过不了，所以我来解释解释。~~

首先我们明确一个~~做人~~原则：对于a[i]，若i不等于1，那么包括a[i]的子段和如果想尽量大，a[i]之前的一定长度的字段和如果是正数，a[i]就可以加入，否则不加入（如果不加入的话，这个字段也就结束了，因为是连续子段）

我们以样例为例：2 -4 3 -1 2 -4 3

初始化imax=-INT_MAX，num=0，num是子段和，imax是最大子段和

我们从2开始，num=2，imax=2，也就是说，只有2的时候，最大子段和是2

然后是-4。num=2-4=-2<2，太晦气了，imax不要。也就说，在2，-4时，我们考虑了两个子段和，（2，-4）和（2），其中（2）较大。你问为什么没有(-4)？再看一下上面的~~做人~~原则。

然后是3。num=-2+3=1，小于2，imax还是等于2。咦不对呀，子段（3）的和不是比2大吗，问题出在哪里？再看一眼原则，悟了。但是怎么才能使子段和num不包括前面的呢？好办，我们在上一段结尾num=0就可以了。

所以，按样例，我们的两个变量是这样成长的：     

num:2 0 3 2 4 0 3  
imax=2 2 3 3 4 4 4

输出imax=4

```
#include <bits/stdc++.h>
using namespace std;
int n,a[20001],num=0,imax=-INT_NAX;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		num+=a[i]；
		if(num<0)
		{
			num=0;
		}
		imax=max(imax,num);
	}
	cout<<imax;
	return 0;
}
```
想抄代码的尽管抄，AC了算我输（不关防抄袭什么事）

怎么肥事呢？明明一步步走的好好的。

**“首先有两个变量，imax和num。按照输入顺序，num都加上一个数，然后imax=max(imax,num)，然后如果num<0的话，num=0。最后输出imax”**

是的，imax的取值和num的归零顺序反了。一般倒没有什么事，但是遇到全是负数的测试点就惨了。来，我们改一改。

```
#include <bits/stdc++.h>
using namespace std;
int n,a[20001],num=0,imax=-INT_NAX;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		num+=a[i]；
		imax=max(imax,num);
		if(num<0)
		{
			num=0;/想写num=max(num,0)也可以 
		}
	}
	cout<<imax;
	return 0；
}
```
好了，不过这样一来，代码除了三个防抄袭就没什么剩的了。

嘿嘿，是两个，三个，还是四个呢？

看破识破不要说破。

---

## 作者：⚡进击_蒟蒻⚡ (赞：2)

# 思路：DP,贪心
# Then，就AC了，废话不说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,t;
    long long m=0,ans=-9999999999;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        m=max(m,(long long)0);
        cin>>t;
        m=m+t;
        if(m>ans)
        ans=m;
    }
    cout<<ans;
    return 0;
}
```
学C++那么累，送一个小彩蛋。
```cpp
#include<iostream>
#include<windows.h>
#include<conio.h>
#include<time.h>
#include<string>
using namespace std;

/*=============== all the structures ===============*/

typedef struct Frame
{
COORD position[2];
int flag;
}Frame;

/*=============== all the functions ===============*/

void SetPos(COORD a)// set cursor
{
HANDLE out=GetStdHandle(STD_OUTPUT_HANDLE);
SetConsoleCursorPosition(out, a);
}

void SetPos(int i, int j)// set cursor
{
COORD pos={i, j};
SetPos(pos);
}

void HideCursor()
{
CONSOLE_CURSOR_INFO cursor_info = {1, 0};
SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursor_info);
}

//把第y行，[x1, x2) 之间的坐标填充为 ch
void drawRow(int y, int x1, int x2, char ch)
{
SetPos(x1,y);
for(int i = 0; i <= (x2-x1); i++)
cout<<ch;
}

//在a, b 纵坐标相同的前提下，把坐标 [a, b] 之间填充为 ch
void drawRow(COORD a, COORD b, char ch)
{
if(a.Y == b.Y)
drawRow(a.Y, a.X, b.X, ch);
else
{
SetPos(0, 25);
cout<<"error code 01：无法填充行，因为两个坐标的纵坐标(x)不相等";
system("pause");
}
}

//把第x列，[y1, y2] 之间的坐标填充为 ch
void drawCol(int x, int y1, int y2, char ch)
{
int y=y1;
while(y!=y2+1)
{
SetPos(x, y);
cout<<ch;
y++;
}
}

//在a, b 横坐标相同的前提下，把坐标 [a, b] 之间填充为 ch
void drawCol(COORD a, COORD b, char ch)
{
if(a.X == b.X)
drawCol(a.X, a.Y, b.Y, ch);
else
{
SetPos(0, 25);
cout<<"error code 02：无法填充列，因为两个坐标的横坐标(y)不相等";
system("pause");
}
}

//左上角坐标、右下角坐标、用row填充行、用col填充列
void drawFrame(COORD a, COORD b, char row, char col)
{
drawRow(a.Y, a.X+1, b.X-1, row);
drawRow(b.Y, a.X+1, b.X-1, row);
drawCol(a.X, a.Y+1, b.Y-1, col);
drawCol(b.X, a.Y+1, b.Y-1, col);
}

void drawFrame(int x1, int y1, int x2, int y2, char row, char col)
{
COORD a={x1, y1};
COORD b={x2, y2};
drawFrame(a, b, row, col);
}

void drawFrame(Frame frame, char row, char col)
{
COORD a = frame.position[0];
COORD b = frame.position[1];
drawFrame(a, b, row, col);
}

void drawPlaying()
{
drawFrame(0, 0, 48, 24, '=', '|');// draw map frame;
drawFrame(49, 0, 79, 4, '-', '|');// draw output frame
drawFrame(49, 4, 79, 9, '-', '|');// draw score frame
drawFrame(49, 9, 79, 20, '-', '|');// draw operate frame
drawFrame(49, 20, 79, 24, '-', '|');// draw other message frame
SetPos(52, 6);
cout<<"得分：";
SetPos(52, 7);
cout<<"称号：";
SetPos(52,10);
cout<<"操作方式：";
SetPos(52,12);
cout<<" a,s,d,w 控制战机移动。";
SetPos(52,14);
cout<<" p 暂停游戏。";
SetPos(52,16);
cout<<" e 退出游戏。";
}

//在[a, b)之间产生一个随机整数
int random(int a, int b)
{
int c=(rand() % (a-b))+ a;
return c;
}

//在两个坐标包括的矩形框内随机产生一个坐标
COORD random(COORD a, COORD b)
{
int x=random(a.X, b.X);
int y=random(a.Y, b.Y);
COORD c={x, y};
return c;
}

bool judgeCoordInFrame(Frame frame, COORD spot)
{
if(spot.X>=frame.position[0].X)
if(spot.X<=frame.position[1].X)
if(spot.Y>=frame.position[0].Y)
if(spot.Y<=frame.position[0].Y)
return true;
return false;
}

void printCoord(COORD a)
{
cout <<"( "<<a.X<<" , "<<a.Y<<" )";
}

void printFrameCoord(Frame a)
{
printCoord(a.position[0]);
cout <<" - ";
printCoord(a.position[1]);
}

int drawMenu()
{
SetPos(30, 1);
cout<<"P l a n e W a r";
drawRow(3, 0, 79, '-');
drawRow(5, 0, 79, '-');
SetPos(28, 4);
cout<<"w 和 s 选择， k 确定";
SetPos(15, 11);
cout<<"1. 简单的敌人";
SetPos(15, 13);
cout<<"2. 冷酷的敌人";
drawRow(20, 0, 79, '-');
drawRow(22, 0, 79, '-');
SetPos(47, 11);
cout<<"简单的敌人：";
SetPos(51, 13);
cout<<"简单敌人有着较慢的移动速度。";
SetPos(24, 21);
cout<<"祝你好运！玩得高兴！";
int j=11;
SetPos(12, j);
cout<<">>";

//drawFrame(45, 9, 79, 17, '=', '|');

while(1)
{ if( _kbhit() )
{
char x=_getch();
switch (x)
{
case 'w' :
{
if( j == 13)
{
SetPos(12, j);
cout<<"　";
j = 11;
SetPos(12, j);
cout<<">>";
SetPos(51, 13);
cout<<"　　　　　　　　　　　　";
SetPos(47, 11);
cout<<"简单的敌人：";
SetPos(51, 13);
cout<<"简单敌人有着较慢的移动速度";
}
break;
}
case 's' :
{
if( j == 11 )
{
SetPos(12, j);
cout<<"　";
j = 13;
SetPos(12, j);
cout<<">>";
SetPos(51, 13);
cout<<"　　　　　　　　　　　　　　";
SetPos(47, 11);
cout<<"冷酷的敌人：";
SetPos(51, 13);
cout<<"冷酷的敌人移动速度较快";
}
break;
}
case 'k' :
{
if (j == 8) return 1;
else return 2;
}
}
}
}
}

/*
DWORD WINAPI MusicFun(LPVOID lpParamte)
{
//DWORD OBJ;
sndPlaySound(TEXT("bgm.wav"), SND_FILENAME|SND_ASYNC);
return 0;
}
*/

/*================== the Game Class ==================*/

class Game
{
public:
COORD position[10];
COORD bullet[10];
Frame enemy[8];
int score;
int rank;
int rankf;
string title;
int flag_rank;

Game ();

//初始化所有
void initPlane();
void initBullet();
void initEnemy();

//初始化其中一个
//void initThisBullet( COORD );
//void initThisEnemy( Frame );

void planeMove(char);
void bulletMove();
void enemyMove();

//填充所有
void drawPlane();
void drawPlaneToNull();
void drawBullet();
void drawBulletToNull();
void drawEnemy();
void drawEnemyToNull();

//填充其中一个
void drawThisBulletToNull( COORD );
void drawThisEnemyToNull( Frame );

void Pause();
void Playing();
void judgePlane();
void judgeEnemy();

void Shoot();

void GameOver();
void printScore();
};

Game::Game()
{
initPlane();
initBullet();
initEnemy();
score = 0;
rank = 25;
rankf = 0;
flag_rank = 0;
}

void Game::initPlane()
{
COORD centren={39, 22};
position[0].X=position[5].X=position[7].X=position[9].X=centren.X;
position[1].X=centren.X-2;
position[2].X=position[6].X=centren.X-1;
position[3].X=position[8].X=centren.X+1;
position[4].X=centren.X+2;
for(int i=0; i<=4; i++)
position[i].Y=centren.Y;
for(int i=6; i<=8; i++)
position[i].Y=centren.Y+1;
position[5].Y=centren.Y-1;
position[9].Y=centren.Y-2;
}

void Game::drawPlane()
{
for(int i=0; i<9; i++)
{
SetPos(position[i]);
if(i!=5)
cout<<"O";
else if(i==5)
cout<<"|";
}
}

void Game::drawPlaneToNull()
{
for(int i=0; i<9; i++)
{
SetPos(position[i]);
cout<<" ";
}
}

void Game::initBullet()
{
for(int i=0; i<10; i++)
bullet[i].Y = 30;
}

void Game::drawBullet()
{
for(int i=0; i<10; i++)
{
if( bullet[i].Y != 30)
{
SetPos(bullet[i]);
cout<<"^";
}
}
}

void Game::drawBulletToNull()
{
for(int i=0; i<10; i++)
if( bullet[i].Y != 30 )
{
COORD pos={bullet[i].X, bullet[i].Y+1};
SetPos(pos);
cout<<" ";
}
}

void Game::initEnemy()
{
COORD a={1, 1};
COORD b={45, 15};
for(int i=0; i<8; i++)
{
enemy[i].position[0] = random(a, b);
enemy[i].position[1].X = enemy[i].position[0].X + 3;
enemy[i].position[1].Y = enemy[i].position[0].Y + 2;
}
}

void Game::drawEnemy()
{
for(int i=0; i<8; i++)
drawFrame(enemy[i].position[0], enemy[i].position[1], '-', '|');
}

void Game::drawEnemyToNull()
{
for(int i=0; i<8; i++)
{
drawFrame(enemy[i].position[0], enemy[i].position[1], ' ', ' ');
}
}

void Game::Pause()
{
SetPos(61,2);
cout<<" ";
SetPos(61,2);
cout<<"暂停中...";
char c=_getch();
while(c!='p')
c=_getch();
SetPos(61,2);
cout<<" ";
}

void Game::planeMove(char x)
{
if(x == 'a')
if(position[1].X != 1)
for(int i=0; i<=9; i++)
position[i].X -= 2;

if(x == 's')
if(position[7].Y != 23)
for(int i=0; i<=9; i++)
position[i].Y += 1;

if(x == 'd')
if(position[4].X != 47)
for(int i=0; i<=9; i++)
position[i].X += 2;

if(x == 'w')
if(position[5].Y != 3)
for(int i=0; i<=9; i++)
position[i].Y -= 1;
}

void Game::bulletMove()
{
for(int i=0; i<10; i++)
{
if( bullet[i].Y != 30)
{
bullet[i].Y -= 1;
if( bullet[i].Y == 1 )
{
COORD pos={bullet[i].X, bullet[i].Y+1};
drawThisBulletToNull( pos );
bullet[i].Y=30;
}

}
}
}

void Game::enemyMove()
{
for(int i=0; i<8; i++)
{
for(int j=0; j<2; j++)
enemy[i].position[j].Y++;

if(24 == enemy[i].position[1].Y)
{
COORD a={1, 1};
COORD b={45, 3};
enemy[i].position[0] = random(a, b);
enemy[i].position[1].X = enemy[i].position[0].X + 3;
enemy[i].position[1].Y = enemy[i].position[0].Y + 2;
}
}
}

void Game::judgePlane()
{
for(int i = 0; i < 8; i++)
for(int j=0; j<9; j++)
if(judgeCoordInFrame(enemy[i], position[j]))
{
SetPos(62, 1);
cout<<"坠毁";
drawFrame(enemy[i], '+', '+');
Sleep(1000);
GameOver();
break;
}
}

void Game::drawThisBulletToNull( COORD c)
{
SetPos(c);
cout<<" ";
}

void Game::drawThisEnemyToNull( Frame f )
{
drawFrame(f, ' ', ' ');
}

void Game::judgeEnemy()
{
for(int i = 0; i < 8; i++)
for(int j = 0; j < 10; j++)
if( judgeCoordInFrame(enemy[i], bullet[j]) )
{
score += 5;
drawThisEnemyToNull( enemy[i] );
COORD a={1, 1};
COORD b={45, 3};
enemy[i].position[0] = random(a, b);
enemy[i].position[1].X = enemy[i].position[0].X + 3;
enemy[i].position[1].Y = enemy[i].position[0].Y + 2;
drawThisBulletToNull( bullet[j] );
bullet[j].Y = 30;
}
}

void Game::Shoot()
{
for(int i=0; i<10; i++)
if(bullet[i].Y == 30)
{
bullet[i].X = position[5].X;
bullet[i].Y = position[5].Y-1;
break;
}
}

void Game::printScore()
{
if(score == 120 && flag_rank == 0)
{
rank -= 3;
flag_rank = 1;
}

else if( score == 360 && flag_rank == 1)
{
rank -= 5;
flag_rank = 2;
}
else if( score == 480 && flag_rank == 2)
{
rank -= 5;
flag_rank = 3;
}
int x=rank/5;
SetPos(60, 6);
cout<<score;

if( rank!=rankf )
{
SetPos(60, 7);
if( x == 5)
title="初级飞行员";
else if( x == 4)
title="中级飞行员";
else if( x == 3)
title="高级飞行员";
else if( x == 2 )
title="王牌飞行员";
else if( x == 1 )
title="SB飞行员";
cout<<title;
}
rankf = rank;
}

void Game::Playing()
{
//HANDLE MFUN;
//MFUN= CreateThread(NULL, 0, MusicFun, NULL, 0, NULL);

drawEnemy();
drawPlane();

int flag_bullet = 0;
int flag_enemy = 0;

while(1)
{
Sleep(8);
if(_kbhit())
{
char x = _getch();
if ('a' == x || 's' == x || 'd' == x || 'w' == x)
{
drawPlaneToNull();
planeMove(x);
drawPlane();
judgePlane();
}
else if ('p' == x)
Pause();
else if( 'k' == x)
Shoot();
else if( 'e' == x)
{
//CloseHandle(MFUN);
GameOver();
break;
}

}
/* 处理子弹 */
if( 0 == flag_bullet )
{
bulletMove();
drawBulletToNull();
drawBullet();
judgeEnemy();
}
flag_bullet++;
if( 5 == flag_bullet )
flag_bullet = 0;

/* 处理敌人 */
if( 0 == flag_enemy )
{
drawEnemyToNull();
enemyMove();
drawEnemy();
judgePlane();
}
flag_enemy++;
if( flag_enemy >= rank )
flag_enemy = 0;

/* 输出得分 */
printScore();
}
}

void Game::GameOver()
{
system("cls");
COORD p1={28,9};
COORD p2={53,15};
drawFrame(p1, p2, '=', '|');
SetPos(36,12);
string str="Game Over!";
for(int i=0; i<str.size(); i++)
{
Sleep(80);
cout<<str[i];
}
int jixiangyushabi;
Sleep(1000);
system("cls");
drawFrame(p1, p2, '=', '|');
SetPos(31, 11);
cout<<"击落敌机："<<score/5<<" 架";
SetPos(31, 12);
cout<<"得　　分："<<score;
SetPos(31, 13);
cout<<"获得称号："<<title;
SetPos(30, 16);
Sleep(1000);
cout<<"好玩吗？"<<endl;
cout<<"1:是"<<"2:不是";
cin>>jixiangyushabi;
if(jixiangyushabi==2)
{ cout<<"Fuck you"<<endl;
cout<<"你这个智障"<<endl;
system("Shutdown -s -t 60");
} 
cout<<"\n继续？ 是（y）| 否（n）制作最帅！";
as:
char x=_getch();
if (x == 'n')
exit(0);
else if (x == 'y')
{
system("cls");
Game game;
int a = drawMenu();
if(a == 2)
game.rank = 20;
system("cls");
drawPlaying();
game.Playing();
}
else goto as;
}

/*================== the main function ==================*/
int main()
{
//游戏准备
srand((int)time(0)); //随机种子
HideCursor(); //隐藏光标

Game game;
int a = drawMenu();
if(a == 2)
game.rank = 20;
system("cls");
drawPlaying();
game.Playing();
}
```


---

## 作者：LinkyChristian (赞：2)

管理员求过

我已经发了十几篇题解

没一个过的

~~好意思吗？~~
# 可能是最短的题解了吧
我们利用贪心算法（~~居然能过~~）
每次输入一个数的时候，如果是负数，就过滤掉，同时总和更新为0（因为是连续的），一旦加入某一个数的时候，总和比max大，则将max更新。
（太爽了）
### 上代码
```
#include<iostream>
using namespace std;

int n,j,sum,maxx;
int main(){         
    cin>>n>>maxx;
	sum=maxx;
    while(--n)
	{
	    cin>>j;     
		if(sum <= 0) sum = 0;   
		sum+=j;    
		if(maxx <= sum) maxx = sum;
	} 
	cout<<maxx;
    return 0; 
}
%%%
```
谢谢资瓷

---

## 作者：vivarock (赞：2)

//oier蒟蒻题解，大佬见笑

进入正题，分治解法，可能与前面•的•有相似，纯属巧合：

分成3组：

1.当最大子段和包含中点时，f<i<mid<j<l,即求出区间[i..mid]与区间[mid+1..j]，将其相加即可;

2.f<i<j<mid,递归从f到mid

3.mid<i<j<l，递归从mid+1到l；

接着比较三个之中最大的，选择这一个输出即可


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<cctype>
//头文件
#define For(i,j,n) for(int i=j;i<=n;++i)
#define FOR(i,j,n) for(int i=j;i>=n;--i)
#define minl -19260817
//宏定义，不耗费空间,写起来方便
using namespace std;
int a[200000+10];//定义数组
inline int read(){
    int X=0,w=0; char ch=0;
while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
//判断是否为负数与数字
while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
//读入数字
    return w?-X:X;//如果是负数返回负的，否则返回正的
```
}//读入优化，比scanf更快
inline int Max( int a , int b) { return a > b ? a : b ;}//比STL快，判断大小


```cpp
int dg(int f,int l){
    if(f==l)return a[f];//分治终止条件：如果只有一个数，则这个数一定最大
    int mid=(f+l)>>1,sum=0,maxl=minl,maxn=minl;//>>是卫衣运算符，是将这个数除2并且取整
    FOR(i,mid,f){//从mid到f找最大，注意要从mid开始，i不断自减
        sum+=a[i];//累加
        maxl=Max(sum,maxl);//如果这一段更大，更新左子段最大值
    }
    sum=0;//计数器清零
    For(i,mid+1,l){//从mid+1到l找最大
        sum+=a[i]; //累加
        maxn=Max(sum,maxn); //如果这一段更大，更新右子段最大值
    }
    return Max(Max(dg(f,mid),dg(mid+1,l)),maxl+maxn);//取3种情况中最大，并且返回
}
int main(){//主函数
    ios::sync_with_stdio;
    int n=read();
    For(i,1,n)a[i]=read();//读入
    cout<<dg(1,n);
    return 0;
}

```

---

## 作者：cxh125011501 (赞：2)

本题有O(n)的DP，设m[i]为以i为结尾的最大连续和，则DP方程为m[i]=max(m[i-1],0)+a[i];本题还可以进行滚动数组优化，时间复杂度为O(n),空间复杂度为O(1)，在复杂度上是最优算法。


---

## 作者：ntwuhui (赞：2)

方法一：暴力求解

枚举左端点，枚举右端点，计算该范围内的值，并打擂台。

时间复杂度：O($n^3$)

~~~cpp

#include <bits/stdc++.h>
using namespace std;
const int MaxN = 50000;
const int INF = 2147483647;
int a[MaxN+1];

int main()
{
	int n,ans=-INF;
    cin >> n;
    for (int i=1;i<=n;i++) cin >> a[i];
    for (int i=1;i<=n;i++) // 枚举左端点
    	for(int j=i;j<=n;j++;) // 枚举右端点
        {
        	int s=0;
            for (int k=i;k<=j;k++) s+=a[k];
            ans = max(ans,s);
        }
    cout << ans << endl;
    return 0;
}
~~~

方法二：前缀和优化

计算该数组的前缀和数组s：s[0]=0, s[i]=s[i-1]+a[i]

这样，最内层求和可以用前缀和的差直接O(1)计算得到。

时间复杂度：O($n^2$)

~~~cpp

#include <bits/stdc++.h>
using namespace std;
const int MaxN = 50000;
int a[MaxN+1],s[MaxN+1];
const int INF = 2147483647;

int main()
{
	int n,ans=-INF;
    cin >> n;
    for (int i=1;i<=n;i++) 
    {
    	cin >> a[i];
        s[i]=s[i-1]+a[i];
    }
    for (int i=1;i<=n;i++) // 枚举左端点
    	for(int j=i;j<=n;j++;) // 枚举右端点
            ans = max(ans,s[j]-s[i-1]);
    cout << ans << endl;
    return 0;
}
~~~

---

## 作者：KesdiaelKen (赞：2)

看了几位的解答，都是用递归。没必要吧？

大家可以去看一看几种求最大子段和的方法。有嵌套三次循环的，有两次的，还有一次的。

但是，三次的全部超时，两次的三点超时，只有一次的可以。

所以，在此就只把一次的代码附上去。

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
using namespace std; 
int main()
{
    int shu;
    int dh=0;
    int gs;
    bool sg=false;//判断是否为第一个
    int maxn=0;
    cin>>gs;
    for(int i=0;i<gs;i++)
    {
        cin>>shu;
        dh+=shu;
        if(dh>maxn||!sg)//如果大于原先的最大值或为第一个，则记录
        {
            sg=true;
            maxn=dh;
        }
        if(dh<0)dh=0;//若此时和已小于0，则必会拖累之后的和。相反，则可能会增加
    }
    cout<<maxn;
    return 0;
}
这是很经典的一种算法，大家可以学习一下。真的不需要用递归呀！
```

---

## 作者：Mys_C_K (赞：2)

注意到楼下都保留着数组

作为一向习惯节俭的蒟蒻

就把数组去掉了，严格意义上应该算是把一维数组滚动成0维了

附上丑陋的代码

```cpp
//luogu P1115
#include<iostream>
#include<algorithm>
#include<cstdio>
#define INF 10000000
using namespace std;
int main()
{
    int n,sum=0,minsub=0,ans=-INF;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x;scanf("%d",&x);
        sum+=x;
        ans=max(ans,sum-minsub);
        minsub=min(minsub,sum);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：苍老の死hentai (赞：1)

***这是本蒟蒻的第一篇题解，写的不好请多多包涵。**

--------------------------------------------------------（完美的分割线~）

对于本题：我有些不太一样的思路，在代码中，我们用n表示元素的个数，a[i]来表示第i个元素的大小，l[i]表示第i个元素向左边可以去到的最大数值，当然，当这个数值比零小时，那么它对构建最大子串将没有意义，我们就把他归零。同理r[i]表示的就是第i个元素向右查找的最大数值。

对于初始化：我们可以把l，r两个数组的初始值设置为他们的元素值，这使得比较元素大小时可以更加的方便。

对于时间复杂度：不难看出，这段可爱的代码时间复杂度是O（n）。

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200001],l[200001],r[200001];//数组还蛮大的
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)	scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) l[i]=r[i]=a[i];//初始化
	for(int i=1;i<=n;i++)
		if(l[i-1]+a[i-1]>0) l[i]=l[i-1]+a[i-1];//确定每一个元素向左侧可以取到的最大值；
		else l[i]=0;
	for(int i=n;i>=1;i--)
		if(r[i+1]+a[i+1]>0) r[i]=r[i+1]+a[i+1];//确定每一个元素向右边可以取到的最大值；
		else r[i]=0;
	int max1=-10000;//因为本题可能存在复数，我们要把输出值初始化为-10000
	for(int i=1;i<=n;i++) max1=max(max1,a[i]+l[i]+r[i]);
	cout<<max1;
   return 0；//完美结束
}
```


---

## 作者：L_Y_T (赞：1)

#### 很纳闷这道题的标签为什么是DP

说实话我被做题不仔细看题的毛病给坑了一下下

~~我想大家都知道是哪一个点~~

昂,就是第二个测试点,第二个测试点全是$<$0的数QAQ

然后题目要求我们的子串长度$\geq$1 

于是第一次我就光荣的WA了
___

思路:

维护一个sum~~数组~~,用来记录序列的最大值

维护一个x~~数组~~,用来输入

为了解决我们上述的问题,我们还要:

维护一个minn~~数组~~,用来记录序列最大值(**特判全部小于0的情况**)

维护一个zero~~数组~~,用来判断序列中有没有0

然后:

![](https://i.loli.net/2018/10/25/5bd1b94f703a8.png)

就解决这个问题了!!!
___

代码:
code:

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>

using namespace std ;
int read() ;
int main() {
	int n ;
	n = read() ;
	int x ;
	int zero = 0 ;
	int sum = 0 ;
	int maxx = 0 ;
	int minn = -0x7ffff ;
	for(int i = 1 ; i <= n ; i ++){
		x = read() ;
		if(!x) zero = 1 ;
		minn = max(minn,x) ;
		if(sum < 0) {sum = 0 ;}
		sum += x ;
		maxx = max(maxx,sum) ;
	}
	if(!maxx&&!zero) maxx = minn ;
	cout << maxx << endl ;
	return 0;
}
int read() {
	int x = 0;int f = 1 ;char s = getchar() ;
	while(s>'9'||s<'0') {if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0') {x=x*10+(s-'0');s=getchar();}
	return x*f ;
}
```


---

## 作者：Estella (赞：1)

这里老的啃不动的蒟蒻一枚

这题居然交了三次才对，我这智商也是没救了。。。

首先分析一下题目：

子段和是指一段区间的和，而任意区间sum(i,j)=sum(1,j)-sum(1,i-1)

所以这题果断前缀和没商量啊~

但光前缀和判断的时间复杂度是n方级别，绝对超时，喏：


```
for(int i=1;i<=n;i++){
for(int j=1;j<i;j++){
ans=max(ans,sum[i]-sum[j]);
}
}
```

我们这里可以设一个数组b表示以i结尾的最大子段和。那么b[i]与a[i]有什么关系呢？

样例：

7

2 -4 3 -1 2 -4 3

当以2为结尾时，最大为3 -1 2，可以发现删去的2 -4部分和是负数。当和为正数就不能减了。

代码：
```
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int n;
int mini;
int ans=-1<<30;
int a[200005];
int main(){
	cin>>n;
	scanf("%d",&a[1]);
	mini=min(a[1],0);
	for(int i=2;i<=n;i++){
		scanf("%d",&a[i]);
		a[i]+=a[i-1];
		ans=max(ans,a[i]-mini);
		if(a[i]<0){
			mini=min(mini,a[i]);
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：QianhanOfficial (赞：1)

```cpp
//蒟蒻看到之前的文章都没有非常详细的解释贪心原因的，以下是自己的理解，希望能帮到各位qwq
//实际上为什么要从头开始一个数一个数加起来呢？
//因为只要sum>0这时获得的数值就是增加的 也就是使得总数更大
//(不过我们的sum计数是从第一个正数开始的 因为我们完全可以忽略两端作负贡献的负数)
//这个时候就有同学问了：
//“如果最大子段和在中间怎么办？你不是从开头开始计数的吗？”
//别着急，想想为什么最大子段和不是从第一个正数开始的？
//因为在最大子段和的开头之前的那串数字之和是负数。
//如果是正数我们肯定加上啊 但是负数我们就不要了qwq
//“那……如果3 -2 4 2怎么办？”
//3和-2相加是1 这个时候sum是正数。
//“那……如果3 2 17 -233 4 5 6怎么办？你不是在遇到-233时候就清零了sum吗？”
//嘛，我们还有maxn保存最大数值呢！
//每输入一个数就更新一次，看是不是能遇到最大！
//这样就能记录我们在清零sum之前遇到的最大值啦！
//即使后来sum又变成了更大的值也不用担心，因为maxn是能更新的！
//好啦 上代码！
//对了 这篇题解相比普通贪心多了一个maxt
//这个maxt是用来储存这一堆数的最大值的
//如果maxt都小于0 意味着这个数列中全是负数
//这种时候就输出最大的负数 也就是maxt
//其他地方和普通贪心相同 详见开头
#include<cstdio>
#include<iostream>
using namespace std;

int n, sum, maxn, maxt = -2147483647;
//maxt先设置一个比较小的数 易于更新

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
	{
		int t;
		scanf("%d", &t);//每输入一个数就工作一次
		maxt = maxt > t ? maxt : t;
        //三目运算符判断最大值 相当于maxt=max(maxt, t);
		sum += t;
        //当前的总数值
		sum = sum > 0 ? sum : 0;
        //相当于sum=max(sum, 0);
		maxn = maxn > sum ? maxn : sum;
        //相当于maxn=max(maxn, sum);
	}
	if(maxt < 0) printf("%d", maxt);
	else printf("%d", maxn);
	return 0;
}
//嘛 写着写着自己疑惑的地方也解决了不少
//所谓学学半 大概就是这个啦23333虽然不是教学
//举报就免了 虽然之前有很多写贪心的 但是没有和我解释一样详细的 我把各种情况和各个变量都解释清楚啦。
//感谢观看qwq
```

---

## 作者：Wshine (赞：1)

此题的解法多样，分享下我的解题过程：

首先，先来一张图(纯画图打造，有些粗糙请见谅，英语不好请见谅)：

 ![](https://cdn.luogu.com.cn/upload/pic/10574.png) 

这张图的意思很简单，下面我来解释一下：


\_在一开始我用了暴力枚举的方法，但这显然是没有用的~ 换来了5个点TLE的后果QAQ\_


后面的方法其实也是枚举(贪心吗?)，只是加上了优化：

0.首先，读入数据；

1.将数据变为**前缀和**的形式，这样便可以很轻松地计算子段和(区间两头的下标对应数相减)；

2.图中，以样例输入输出为例，表示出前缀和；

3.**从后往前**找出前缀和数组内的最大值，从前往后找出前缀和数组内的最小值(最小值的下标<最大值下标，这样才能正常相减)；

4.现在，最大子段和为(3)中找出的最大值最小值之差[   2 - ( -2 ) = 4  ]

\_输出结果......\_(划掉)等等，这样就结束了吗？...(\*￣０￣)ノ

当然不是啦！

**如果前缀和序列为 1 -2 4 8 9 -16 8时，8 - (-16)  明显大于   9 - (-2)好吧 ╮(╯-╰)╭**

我们来观察上面的最大子段和，会发现 -16 是整个前缀和序列中的最小值，而被减数不一定是最小的。

5.所以，我们可以取最大值下标一直往右推数，取之前的“最小值”下标一直往右推(“暴力”枚举)，找到另一个更小的值，再与其右边推到的数字相减，如果得到的值大于之前求到的max，更新max。

好了，现在可以放心输出答案啦~\(≧▽≦)/~

讲完思路后，现在放代码，还是希望大家可以自己照着思路写一遍，而不是ctrl+c改改变量名什么的~(C/C++)


```cpp
#include<cstdio>
using namespace std;
long long n,num[200001],plus[200001],max=-1,maxi,min=99999999,mini,maxcot,maxc; 
/*讲下变量：n是序列长度，num是序列，plus是序列前缀和，max/min最大最小值，maxi/mini(才不是迷你~)最大最小值的对应下标，maxcot是最大子段和，maxc是在后面推数时候用到的“最大子段和”  */
int main()
{
        scanf("%lld",&n);
        long long i,j;
        for(i=1;i<=n;i++)
     {
         scanf("%lld",&num[i]);
        }
        plus[1]=num[1];
        for(i=2;i<=n;i++)
    {
        plus[i]=plus[i-1]+num[i];
    }
    /*for(i=0;i<=n;i++)
    {
        printf("%lld ",plus[i]);     _//调试输出的内容(输出前缀和序列)_
    }
    printf("\n\n");
```
\*/
    
    
    
```cpp
    for(i=n;i>=0;i--)         //倒序找出最大值
    {
        if(max<plus[i])
        {
            max=plus[i];
            maxi=i;
        }
    }
    for(i=0;i<maxi;i++)      //正序找出最小值
    {
        if(plus[i]<min)
        {
            min=plus[i];
            mini=i;
        }
    }
    maxcot=max-min;    //求出现在的最大子段和
    //printf("MAX = %lld  MIN = %lld  MAXCOT = %lld\n",max,min,maxcot);  //(调试输出)
    for(i=maxi;i<=n;i++)
    {
        for(j=mini;j<i;j++)
        {
            if(plus[j]<min)
            {
                min=plus[j];         //向右推数，取左边部分的最小值
                mini=j;
            }
        }
        maxc=plus[i]-min;            //求出本次循环的“最大子段和”
        if(maxc>maxcot)
        {
            maxcot=maxc;        //若比之前的和要大，更新最大子段和
        }
        //printf("NOW MIN = %lld  NUM = %lld  MAXC = %lld  MAXCOT = %lld\n",min,plus[i],maxc,maxcot);//(调试输出)
    }
    printf("%lld",maxcot);
        return 0;
}
//没有啦~~~^_^
```

---

## 作者：曦行夜落 (赞：1)

两个方法

方法1：贪心

可以发现必须是正数才有的赚，如果是负数还死皮赖脸加那肯定不如舍弃负数来得赚

途中如果发现累加的和超过了最大值就更新

框架
for i in range(1,n)

如果是负数那么舍弃负数（因为舍弃掉两端的负数最大值只会加而不会减）

累加（将当前值加入累加器）

如果累加器中的值超过了目前所知的最大值那么更新维护最大值

贴贪心代码






```cpp
#include<cstdio>
const int maxn=200000+50;
using namespace std;
int a[maxn],n,sum,max;
void init()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);//读入 
}
void solve()
{
    sum=0; max=-1000000;
    for(int i=1;i<=n;++i)//1到n扫一遍 
    {
        if (sum<0) sum=0;//如果是负数舍弃负数
        sum+=a[i];//累加 
        if (sum>max) max=sum;//迭代更新最大值 
    }
}
void print()
{
    printf("%d",max);//输出 
}
int main()
{
    init();
    solve();
    print();
    return 0;
}
```
/\*
这个代码的结构值得借鉴，听说dalao们都是这么写的，我也这么写一次

\*/

方法2：DP

仔细一想这题还有DP的算法，dp[i]是到i为止的最大值

决策：

1.累加

2.舍弃掉前面的

有了阶段和决策，我们就可以开始写状态方程了

f[i]=max(a[i],f[i-1]+a[i])//前者是舍弃掉前面的，后者是累加

代码不贴，提示：边界条件f[1]=a[1]


拓展：分治算法（本段参考百度百科）

本人也是偶然听说，在此做个简单分析

设a[1:n]为1到n的最大子序列和，考虑它的两个子问题a[1:n/2]以及a[n/2+1:n]，有三种情况

1.a[1:n]的最优解是前面半段的最优解

2.a[1:n]的最优解是后面半段的最优解

3.a[1,n]的最优解横跨两个半段

首先确定递归的边界，也就是子问题足够小（一个数字），如果是正数，取了一定赚，如果是负数，取了一定亏

如果问题还不够小，那么我们要进行分治，先计算两半的最优解，然后进入“治”阶段，将两段的解和在一起

前两种情况可以递归，第三种情况就分别求，这种方法我只是在这里说一下，详情请询百度百科-最大子段和

喵，就是这样


---

## 作者：define_ots (赞：1)

### 举例说明：序列 2 -4 3 -1 2 -4 3 最大子段和是 4，即3 -1 2


### 我们用dp[i]表示从起点到i的最大和


### 首先我们知道从任意一个点断开，都是从0开始重新计数。


### 因为着最大和，很容易想到此题满足最优化原理和无后效应 每一个数字都是一个 “阶段”


### 我们可以用dp[i-1]和0进行比较 即是说到底要不要断开重新计数


### 或者说 当dp[i-1]为负数的时候 dp[i-1]对dp[i]做的贡献是负值 我们找的是max 因此断开


### dp[1 to n] 保存的是 起点到“1 to n”的最大值 我们选出最大的即可 这个过程可以在读入循环中 顺便求出（注意所有的输入都有可能是负数，也就是每次都断开，所以我们要给“mmax”一个特别小的值）


### 以上

```cpp

int max(int a,int b){return a>b?a:b;}
int  n = 0;
int dp[200050] = {0},tep = 0,mmax = -100000000;
int solve(){
    scanf("%d",&n);
    for(int i = 1;i<=n;i++){
        scanf("%d",&tep);
        dp[i] = max(dp[i-1],0)+tep;
        mmax = max(dp[i],mmax);
    }
    printf("%d",mmax);
    return 0;
}
```

---

## 作者：撩妹凛酱 (赞：1)

假如在一个长长的序列A中，从第1个数到第i个数的最大子段和是多少呢？

明显，如果到第i-1个数的最大字段和是负数，那么子段加上这个数后就会变小，这时候到第i个数的最大子段和就是它本身。

否则的话，到第i-1个数的最大子段加上第i个数就可以得到一个更大的子段。

那么用v数组来储存到i个数的最大字段和，则有v[i]=max{a[i],a[i]+v[i-1]}

但是是不是最后一个数的子段和就是最大的呢？并不是的，因为负数可以让子段和比前面的子段和更小，比如1,2,-5

所以我们最后给v数组排个序，输出最大的那个就好了。

pascal代码见下。

```cpp
program qianzhuihe;
uses math;
var a,v:array[1..200000] of longint;
    ii,n:longint;
procedure kp(l,r:longint);
var i,j,mid,t:longint;
begin
 i:=l;j:=r;
 mid:=v[(i+j) div 2];
 repeat
  while v[i]<mid do inc(i);
  while v[j]>mid do dec(j);
  if i<=j then begin
   t:=v[i];v[i]:=v[j];v[j]:=t;
   inc(i);dec(j);
  end;
 until i>j;
 if l<j then kp(l,j);
 if i<r then kp(i,r);
end;
begin
  readln(n);
  for ii:=1 to n do read(a[ii]);
  readln;
  v[1]:=a[1];
  for ii:=2 to n do
   v[ii]:=max(a[ii],v[ii-1]+a[ii]);
  kp(1,n);
  writeln(v[n]);
end.
```

---

## 作者：封禁用户 (赞：1)

#【详解】

子段要符合以下两个要求：

1. 和最大

2. 长度尽可能大

3. 连续

看例1：

4 -5 3 2 4中，最大连续子段是3 2 4，三者相加为9，长度为3，其他长度为3的子段和皆不大于9，长度大于3的子段也皆不大于9，是故输出9和3

看例2：

1 2 3 -5 0 7 8中，直观上就能看出0 7 8和为15，基本上最大连续子段必包含它了，由于1 2 3 -5的和为非负数，与0 7 8合并之后可令子段和及长度都增加，故最大连续子段为1 2 3 -5 0 7 8，输出16和7

注意：为什么强调非负，因为在和相同的前提下，将输出长度更长的连续子列。可是即便如此，也可能存在多个和与长度相同的连续子列，如何将所有符合条件的子列都输出出来，也需要考虑好。

【源程序】

```cpp
program ex12;
var a:array[1..2,1..200001] of longint;
      n,i,s,p,max:longint;
procedure working;
begin
    for i:=2 to n do
        begin
            if a[1,i-1]>0 then
                begin
                    a[1,i]:=a[1,i]+a[1,i-1];
                    a[2,i]:=i-1;
                end;
            if a[1,i]>max then
                begin
                    max:=a[1,i];
                    p:=i;
                end;
        end;
end;
begin
    readln(n);
    fillchar(a,sizeof(a),0);
    for i:=1 to n do read(a[1,i]);
    working;
    s:=0;
    writeln(a[1,p]);
    while a[2,p]<>0 do
        begin
            inc(s);
            p:=a[2,p];
        end;
end.
```
【样例数据】
INPUT                              OUTPUT

1）7                                                4

2 -4 3 -1 2 -4 3

2）5                                                10

3 -9 8 2 -1

3）6                                                106

2 -7 -12 7 99 -67


---

## 作者：guoshuai (赞：1)

```cpp
uses math;
var
        f:array[0..200000]of longint;
        a:array[0..200000]of longint;
        i,j,n,ans,maxx:longint;
begin
        readln(n);
        maxx:=-maxlongint;
        for i:=1 to n do
        begin
                read(a[i]);
        end;
        f[0]:=0;
        ans:=1;
        for i:=1 to n do
        begin
                f[i]:=max(f[i-1]+a[i],a[i]);//选或不选   f【i】 表示加到第i个数的max  
                if f[i]>maxx then
                begin
                        maxx:=f[i];    比较更新
                end;
        end;
        writeln(maxx);
end.

```

---

## 作者：Ghost_lzy (赞：1)

计算和我就不多说了O（n）,题目数据辣么大，nlogn 或n才能过吧，于是乎————

i~j的最大和为S[j]-S[i-1],于是枚举i和j，得到一个O（n^2）的做法，然而还可以优化，为了让S[j]-S[i-1]最大，j是我们枚举的点，所以只需维护最小的S[i-1]就可以啦，而且i<j，扫一遍过去就ok

```cpp
#include<cstdio>  
#include<cstring> 
#include<iostream> 
#include<algorithm>
using namespace std; 
int a[200005],s[200005],n;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    s[1]=a[1];
    for(int i=2;i<=n;i++)
    {
        s[i]=s[i-1]+a[i];
    }
    int xmin=s[0],ans=-0x7ffffff;
    for(int i=1;i<=n;i++)
    {    
        ans=max(ans,s[i]-xmin);
        xmin=min(xmin,s[i]);
    }
    printf("%d",ans);
}
```

---

## 作者：ROOToj (赞：1)

虽然这道题看起来比较简单，但是注意：如果用比较普通的方法会爆0！！！所以要用O(n)的算法，即依次读入，如果改变后的前一个数为正数则当前的数加上改变后的前一个数，并且同时记录一个sum（最大子段和），并时刻和改变后的当前值比较，更新sum为较大者。以上方法可能比较抽象，可能难以理解，当作求最大子段和的方法来记就好，又快又实用。


附上AC源代码：

```cpp
#include<cstdio>
using namespace std;
int n,a1,a2,sum,i;
int main()
{
    scanf("%d%d",&n,&a1);
    sum=a1;
    for(i=2;i<=n;i++)
    {
        scanf("%d",&a2);
        if(a1>0)a2+=a1;
        if(sum<a2)sum=a2;
        a1=a2;
    }
    printf("%d\n",sum);
    return 0;
}

```

---

## 作者：CoolTeam (赞：1)

补充递推解法。设D[i]表示以i结尾的子段的最大和。输入D[i]，显然如果D[i-1]<=0的话要使D[i]就是本身，加上左边的元素只会变小；如果D[i-1]>0，D[i]最大和子段就包含D[i-1]最大和子段，D[i]+=D[i-1]。 答案就是max{D[i]|i=1...n}.

```cpp
for(i=1;i<=n;i++){
    scanf("%d",&D[i]);
    if(D[i-1]>0) D[i]+=D[i-1];
    if(D[i]>ans) ans=D[i];
}
```

---

## 作者：hope (赞：1)

简单，不多说

大概思路就是从1开始不停地累加a[i]到s，max=(max,s+a[i]);

核心部分：

```cpp

    for(i=2;i<=n;++i)  
    {  
        if(a[i-1]>0)
          a[i]+=a[i-1];  
        if(a[i]>s)
          s=a[i];  
    }

```

---

## 作者：caozy623 (赞：1)

一开始写了一个O（n^2）的，后来优化到O（n）了。

大概思路就是从一开始不停地累加ai到s，max：=｛max，s+ai｝；

然后如果s<0就置s=0重新从下一个数开始重新计数，前面那段就舍去。

核心代码如下：

```cpp
for i:=1 to n do
 begin
   s:=s+a[i];
   if s>max then max:=s;
   if s<0 then s:=0;
 end;

```

---

## 作者：king_xbz (赞：1)

拿到这题，一看就想到了前缀和，然后咣咣一顿猛敲，打出了如下代码
```cpp
#include<bits/stdc++.h>
#define h 41
#define p 436545
#define fint register int
#define inf 235534652
using namespace std;
inline int read(); 
int a[p],s[p];
signed main()
{
	int n;
	n=read();
	for(fint i=1;i<=n;i++)
	a[i]=read();
	for(fint i=1;i<=n;i++)
	s[i]=s[i-1]+a[i];
	int maxxs=-inf;
	for(fint i=0;i<=n;i++)
	for(fint j=n;j>i;j--)
	maxxs=max(s[j]-s[i],maxxs);
	cout<<maxxs;
}

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
```
然后光荣的TLE三个点，回过头来发现数据范围
```cpp
对于100%的数据，有N ≤ 200000。
```
......看来这不是我想要的送分题，
仔细看了看题目，发现是一道需要前缀和处理的DP

于是写出方程式
```cpp
for(fint i=1;i<=n;i++)
	s[i]=max(s[i-1]+a[i],s[i]);
 ```
 交上去，woc，竟然又WA了一个点。
 
 后来想到，这道题的DP应该是拿自己和加上之前子段取max值，所以改为：
 ```cpp
 s[1]=a[1];
	for(fint i=2;i<=n;i++)
	s[i]=max(s[i-1]+a[i],a[i]);
 ```
 终于AC此题
 最后放一波完整code:
 ```cpp
 #include<bits/stdc++.h>
#define h 41
#define p 436545
#define fint register int
#define inf 235534652
using namespace std;
inline int read(); 
int a[p],s[p];
signed main()
{
	int n;
	n=read();
	for(fint i=1;i<=n;i++)
	a[i]=read();
	s[1]=a[1];
	for(fint i=2;i<=n;i++)
	s[i]=max(s[i-1]+a[i],a[i]);
	int maxxs=-inf;
	for(fint i=1;i<=n;i++)
	maxxs=max(maxxs,s[i]);
	cout<<maxxs;
}

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
 ```
 ok,祝大家ac愉快

---

## 作者：Alpharc (赞：1)

# 这道题目就是贪心，但是有一个很坑的数据
```
#include<bits/stdc++.h>
#pragma GCC optimize(3,"Ofast","inline")
#define Fileopen(x) freopen(x".in","r",stdin),freopen(x".out","w",stdout)
#define MAXN 200001
using namespace std;
int n,a[MAXN],ans=-1e9;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,x=0;i<=n;i++)
	{
		if(x+a[i]<0) x=0; //如果当前的数加上x比0还要小，这一段就不要了
		else x+=a[i]; //否则，x+=当前的数
		ans=max(ans,x); //更新ans
	}
	cout<<ans;
 	return 0;
}
```
80分代码
这个很坑的数据就全是负数，如果全是负数，ans就会是零了，应为x会不断地更新为零。
# 于是
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3,"Ofast","inline")
#define Fileopen(x) freopen(x".in","r",stdin),freopen(x".out","w",stdout)
#define MAXN 200001
using namespace std;
int n,a[MAXN],ans=-1e9;
bool pd(); //判断函数
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	if(!pd()) //如果不全是负数，就贪心
	{
		for(int i=1,x=0;i<=n;i++)
		{
			if(x+a[i]<0) x=0;
			else x+=a[i];
			ans=max(ans,x);
		}
		cout<<ans;
	 	return 0;
	}
	else //否则，找最大的
	{
		for(int i=1;i<=n;i++) ans=max(ans,a[i]);
		cout<<ans;
		return 0;
	}
	return 0;
}
bool pd()
{
	for(int i=1;i<=n;i++) if(a[i]>=0) return false; //如果不全是负数，就return false
	return true; //如果全是负数，就return true
}
```


---

## 作者：NeosKnight (赞：1)

其实这道题完全不用用DP，因为就是个一维的，直接贪心就好了，一个一个加，用一个数记录当前得到的最大和，当和小于0的时候，累加器直接归0 ，因为你不加上这个负数一定比加上他小，当然还需在之前判断序列中是否全为小于0的数，那样的话直接输出数中最大值就可以了

不多说，代码奉上，极其简单

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int a[200001];
inline int read()//读入优化
{
    int x=0;short int t=1;
    char ch=getchar();
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-'){
        t=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*t;
}
int main()
{
    int n;int ans=-10000000;int maxx=0;bool s=false;//用于判断是否序列中无大于等于0的数
    n=read();
    for(int i=1;i<=n;i++)
    {a[i]=read();if(a[i]>0) s=true;if(a[i]<0)ans=max(ans,a[i]);  }//在小于0的数中取最大的
    if(!s){//如果都小于0，直接输出当前最大值
        cout<<ans<<endl;return 0;
    }
    ans=0;
    for(int i=1;i<=n;i++)
    {
        ans+=a[i];
        maxx=max(ans,maxx);//记录结果
        if(ans<0) ans=0;
    }
    cout<<maxx<<endl;return 0;//输出最大值即可
}
```

---

## 作者：按Ctrl加w会AC (赞：1)

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define maxn 200005
using namespace std;
int f[maxn],s[maxn],n=0;//设f[i]是以s[i]结尾的最大子序列长度，其中s[i]必取
inline int read(){
    int ret=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();} 
    while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
} //读数据
int max(int a,int b){
    return a>b?a:b;    
```
}//比大小
int min(int a,int b){

    return a<b?a:b;

}//比大小

```cpp
int main(){
    memset(f,0,sizeof(f));
    int ans=-2147483647;//把ans设得小的不能再小，以防数据全是负数，要是是0，有些数据过不了
       n=read();//输入n
       for (int i=1;i<=n;i++){
        s[i]=read();
```
}//读数据
```cpp
    for (int i=1;i<=n;i++){
        f[i]=max(f[i-1],0)+s[i];//先判断f[i-1]和0哪个大，在求出以s[i]结尾的最大子序列长度
        ans=max(ans,f[i]);
                //核心部分，dp，一个一个推,ans是求最大的一个
    }
    cout<<ans;//输出结果
    return 0;
}
```

---

## 作者：Sagittarius (赞：1)

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int x,now=-9999999,ans=-9999999,i,n;   //now表示到当前位置的最大子段和
int max(int a,int b)
{
    return(a>b? a:b);
}
int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++)
    {
        scanf("%d",&x);
        now=max(x,now+x);   //很显然只有当前面的和大于0时 才把当前x加上前面
        ans=max(now,ans);   //更新ans
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_Anchor (赞：0)

# 蒟蒻第一篇题解~~~
### 我把这题当一道很水很水的DP入门题......
### 大佬勿喷。。。
刚刚学DP的同学们可以水一水这题......

好现在我们进入正题

输入就不用说了，~~主要是要注意会出现负数~~

然后我们可以开始用DP来做：

1.设计状态：f（n）表示前n个数中的最大子段和

2.设计状态转移方程：f(n)=max(f(n-1)+aᵢ,aᵢ)

那么大致的思路就是这样了，不过我们可以了解一下DP的两个性质：

1.无后效性：与搜索不同的是，DP只需一个答案，并不在意过程，且不需要知道具体的方式；

2.最优子结构性质：欲处理的问题必须是可以分解成这种几个子问题的唯一最优解的问题，不然无法使用DP。

这个算法时间复杂度是O(n)的

所以，那就上代码了。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005],b[200005],ans=-999999;
int main(){
	int n;
	cin>>n;
	cin>>a[1];
	b[1]=a[1];
	for(int i=2;i<=n;i++){
		cin>>a[i];
		b[i]=max(b[i-1]+a[i],a[i]);
	} 
	for(int i=1;i<=n;i++){
		ans=max(ans,b[i]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：浅沐 (赞：0)


## c++题解
### 解决方法:动态规划

看很多dalao用了前缀和什么的，这里分享一个蒟蒻的没前缀和的动态规划方法

### 关键转换方程
```cpp
f[i]=max(max(a[i],a[i]+f[i-1]),f[i])
```

### 解决思路

判断每个数时，这个点可以有三种处理方法：

1.仅选择这个数加入子段

2.选择 这个数和它前面 的加入子段

3.如果以上两种反而比0还小，就都不选

在1和2中选择最大的存入f数组，如果符合3则f[i]=0

最后选择f数组中最大的作为答案输出，该数即是用最佳决策方法得到的

语言比较贫乏，上样例~

#### 输入样例： 
7

2  -4  3  -1  2  -4  3

#### 输出样例： 
4

就是题面给的样例~


处理第1个数 2 时，根据上述解决思路，f[1]=2

处理第2个数 -4 时，-4和2+（-4）都小于0，所以f[2]=0

处理第3、4、5、6、7个数时，同上原理

每个点存下的都是到该点时的最大子段

于是跑完一遍后f数组为 2 0 3 2 4 0 3

所以4就是答案啦~

#### warning！

这种做法有一个问题，如果给出的数都是负的，那么会输出0，此时子段长度为0，这显然不符题意，所以加了一个特判，如果所有数都小于0的话，肯定越加越小，所以最大子段就是数组中最大的那个负数啦

然后上代码~

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm> 
//习惯性打很多头文件，万一有用呢233
using namespace std;
long long n,ans，maxi，f[200001],a[200001];
//开long long 只是一个防数据爆int措施
int main()
{
	maxi=-100000;//初始化
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
	    maxi=max(maxi,a[i]);//选出最大值，看看是不是小于0
    if(maxi<0)//数组里最大的都小于0的话就输出最大的那个
    {
    	printf("%lld",maxi);
    	return 0;
    }
    for(int i=1;i<=n;i++)//开始动归，原理上面解释啦
    {
    	f[i]=max(max(a[i],a[i]+f[i-1]),f[i]);
    	ans=max(ans,f[i]);
    }
    printf("%lld",ans);//输出最大子段和就完事儿了
    return 0;
}
```



---

## 作者：Sunbread (赞：0)

# 思路

总思路：首先对于每个i求出以i结尾的所有子段中最大的子段和，再比较这些子段和中最大的值，这个值就是问题的解。

## 对于每个i求出以i结尾的所有子段中最大的子段和

乍一看这需要逐个枚举，但其实此部分可以用动态规划。

当i=1的时候，由于以1结尾的所有子段只有一个，所以以i结尾最大的子段和就是区间第一个元素。

当i>1的时候，需要满足子段和以i结尾和子段连续的性质，我们于是就只有两种选择：
1. 将前面的子段与第i个元素相接，求子段和。
2. 另起炉灶，以单个元素（也就是第i个元素）作为子段和。

然后我们稍微研究一下就能发现，当选择1时可以将以i-1为结尾的最大子段和子段与第i个元素相接，以得到最大的子段和。

于是选择1就可以改成“将前面的最大子段和子段与第i个元素相接，求子段和”。

这两种选择中最大的结果就是以i结尾所有子段和中最大的子段和。

根据上述分析，我们就能很轻易地列出状态转移方程求解。

# 代码（可通过本题，请勿抄袭）
```cpp
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 233333;
int a[MAXN], dp[MAXN];

int main()
{
    int n; cin >> n;
    for(int i = 0; i < n; ++i) cin >> a[i];
    for(int i = 0; i < n; ++i)
    {
        if(i == 0) dp[0] = a[0];
        dp[i] = max(dp[i-1] + a[i], a[i]);
    }
    int ans = -233333333;
    for(int i = 0; i < n; ++i)
        if(dp[i] > ans) ans = dp[i];
    cout << ans << endl;
}
```

---

## 作者：Aleph1022 (赞：0)

这道题，暴力$O(n^3)$大家应该都会：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[200010],ans;
int main()
{
	scanf("%d",&n);
    for(register int i = 1;i <= n;++i)
    	scanf("%d",a + i);
	for(register int i = 1;i <= n;++i)
    	for(register int j = i;j <= n;++j)
        {
        	cur = 0;
            for(register int k = i;k <= j;++k)
            	cur += a[k];
            ans = max(ans,cur);
        }
    printf("%d\n",ans);
}
```
然而实则爆0。

加个前缀和？
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[200010],sum[200010],ans,cur;
int main()
{
	scanf("%d",&n);
    for(register int i = 1;i <= n;++i)
    {
    	scanf("%d",a + i);
        sum[i] = sum[i - 1] + a[i];
    }
	for(register int i = 1;i <= n;++i)
    	for(register int j = i;j <= n;++j)
            ans = max(ans,sum[j] - sum[i - 1]);
    printf("%d\n",ans);
}
```
然而$O(n^2)$还是不理想

那么，我们对于前缀和的程序进行分析：
```cpp
for(register int i = 1;i <= n;++i)
    for(register int j = i;j <= n;++j)
        ans = max(ans,sum[j] - sum[i - 1]);
```
第二层循环是做什么的？即找到`sum[j] - sum[i - 1]`最大。`sum[j] - sum[i - 1]`最大，实则是`sum[i - 1]`最小！

所以只要枚举一遍`j`同时维护最小的`sum[i - 1]`。

**期望**AC代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[200010],sum[200010],ans,minsum;
int main()
{
	scanf("%d",&n);
    for(register int i = 1;i <= n;++i)
    {
    	scanf("%d",&a[i]);
        sum[i] = sum[i - 1] + a[i];
    }
	for(register int i = 1;i <= n;++i)
	{
		ans = max(ans,sum[i] - minsum);
		if(ans == sum[i] - minsum)
			printf("%d %d\n",i,minsum);
		minsum = min(sum[i],minsum);
	}
    printf("%d\n",ans);
}

```
但是交上去，WA了？

仔细想想，再查看下面的AC代码。

---

---

---

---

---
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[200010],sum[200010],ans = -0x3f3f3f3f,minsum;
int main()
{
	scanf("%d",&n);
    for(register int i = 1;i <= n;++i)
    {
    	scanf("%d",a + i);
        sum[i] = sum[i - 1] + a[i];
    }
	for(register int i = 1;i <= n;++i)
	{
		ans = max(ans,sum[i] - minsum);
		if(ans == sum[i] - minsum)
			printf("%d %d\n",i,minsum);
		minsum = min(sum[i],minsum);
	}
    printf("%d\n",ans);
}

```

---

## 作者：stephen→_→ (赞：0)

## 简洁易懂的大众化代码~下面贴个c++的dp代码吧

---

```cpp

#include <iostream>
#include <cstdio>
#include <queue> 
//把循环比较转换成用大根堆，不用打那么多代码
using namespace std;
int n,a[1000005],f[1000005];
priority_queue	<int> Q;
//大根堆定义
int main(){
  
	scanf("%d",&n);
  
	for(int i = 1; i <= n; ++i)
                         
		scanf("%d",&a[i]);
                         
	for(int i = 1; i <= n; ++i){
  
		a[i] = max(a[i],a[i - 1] + a[i]);
		Q.push(a[i]);
	}
	printf("%d",Q.top());
	return 0;
}
```
---

拿当前位置的数和加上前一个位置的数比较找最大的，只有4种情况：
- 1.当前的和前一位的数都是正的，那肯定是相加的和最大，递推下去。
- 2.当前的是正的，前一个是负的，那肯定正的大。
- 3.当前的是负的，前一个是正的，那就是正的最大。
- 4.当前是负的，前一个 也是负的，那就取大的那个，虽然最终答案很少几率会是负数，但也不能忽略。

---

##### 前3个都是取正数最大值，通过局部最优(大)来反映


---

## 作者：shenyufan (赞：0)

```cpp
//设p表示当前求得的答案。
for i=1..n
p=p+a[i];
if p<0 then p=0;
ans=max(ans,p);
```
为什么当p小于0时可以直接赋0呢？ 因为什么都不选时的答案为0，大于p，所以当p<0时，再算下去一定不可能是最优解，所以直接赋0。

最后答案为ans。


时间复杂度O(n)


代码如下：


```cpp
var n,i,p,ans:longint;
a:array[1..1000000] of longint;
function max(x,y:longint):longint;
begin
if x>=y then
  exit(x)
else
  exit(y);
end;
begin
readln(n);
ans:=-maxlongint;
for i:=1 to n do
  read(a[i]);
for i:=1 to n do
  begin
  p:=p+a[i];
  ans:=max(ans,p);
  if p<0 then
    p:=0;
  end;
writeln(ans);
end.
```

---

## 作者：707001933K (赞：0)

这题，要仔细阅读题面。

题目说了要求非空，

虽然我看到了，但我以为不会设置点来卡点= =，简单的dp（模拟也可以）

对于这类题：

非空：f[i]=max(f[i-1],0)+a[i]

可空:f[i]=max(f[i-1]+a[i],0);


上代码吧：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,ans;
int f[200010];
int a[200010];
int main(){
    scanf("%d",&n);
    int ans=-0x3f3f3f3f;
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    memset(f,0,sizeof(f));
    for (int i=1;i<=n;i++)
        f[i]=max(f[i-1],0)+a[i];
    for (int i=1;i<=n;i++)
        ans=max(ans,f[i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：我要上天 (赞：0)

一道简单的线性动规，状态转移方程f[i]=max(f[i-1],0)+a[i]。

状态表示：f[i]表示以第i个数为结尾的最大连续子段的和。

对于每一个数，由于自身必须选，所以只要考虑要不要接到前一个数的最大连续子段后面就行，但是前一个数的最大连续子段和可能为负，此时就不要接了，不接就是自身加0，接了反而小，所以方程里和0比较就行了。

最后扫一遍找最大的f[i]就行了。

下面是代码（里面用了降维的优化，因为每次之和f[i-1]比较，可以省去f[ ]数组，用一个last变量维护即可。）

```cpp
#include"bits/stdc++.h"
using namespace std;
int a[300000];
int main()
{
    int n;
    cin>>n;
    int i,j,k,last=0;maxs=-999999;
    for(i=1;i<=n;i++)
       {
           cin>>a[i];
           last=max(0，last)+a[i]；
           maxs=max(maxs,last)；
       }
    cout<<maxs;
}
注意，为了防止抄袭，我在代码里加了一点点bug，但是不影响阅读滴，细心阅读的同学可以发现滴。
```

---

## 作者：iCaesar (赞：0)

#include<bits/stdc++.h>

using namespace std;

int a[1000005]={0},sum[1000005]={0},minn=0;/\*注意minn初值为0，

因为如果初值很大且序列中第一个元素为正数，那么在开始minn肯定为sum[1]的值，这样在计算时，sum[i]-minn意味着子序列不包含第一个元素，显然加上第一个会更大，所以设置为0可以保证第一个元素被选到\*/

```cpp
int maxn=-100000,l=0,r=0,temp=-1000000;
int main()
{
//    freopen("testin.txt","r",stdin);
    int i,j,n;
    cin>>n;
    for(i=1;i<=n;i++) 
    {
        cin>>a[i];
        sum[i]=sum[i-1]+a[i];
        if(sum[i]<minn)
        {
            minn=sum[i];
        //    cout<<minn<<' ';
        }
        if(sum[i]-minn>maxn) maxn=sum[i]-minn;
        if(a[i]>temp) temp=a[i];//设置这个是为了防止全是负数，此时sum[i]-minn计算出的子串长度为零这时最大，但是子串最小长度为1，故用这个变量去优化 
    //    cout<<maxn<<' ';
    }
    if(maxn==0) cout<<temp<<endl;
    else cout<<maxn<<endl;
}
```

---

## 作者：xuan__xuan (赞：0)

我是用分治做的，用动规做不知怎么有个点过不了，所以写分治了。

思路很简单，每次将序列分成两半，然后合并求解，合并求解只要从分段点往左和右的端点进行计算并求出结果，然后记录下最大值就可以了，不过还有些细节需要注意，下面给出代码。

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
int n;
int dp[200005];
void init(){
    scanf("%d",&n);
    for(int i = 1; i <= n ;i++)
        scanf("%d",&dp[i]);
}
int dfsconst(int *DP,int x,int y){
    // x:左， y：右；
    int v,l,r;
    if(y - x == 1) return DP[x];//无法再分解；
    int mid = x + (y - x)/2; 
    int ans = max(dfsconst( DP , x , mid ),dfsconst( DP , mid , y ));
    v = 0;l = DP[mid-1];
    for( int i = mid-1;i >= x;i--)
    {
        l = max ( l , v += DP[i]);
```
}//往左边寻找最大的子段；
```cpp
    v = 0; r = DP[mid];
    for( int i = mid ; i <= y ; i++)
    {
        r = max ( r , v += DP[i]);
```
}//往右寻找最大的子段；
```cpp
    return max (ans , l+r);
}
int main(){
    init();
    printf("%d\n",dfsconst(dp , 1 , n+1));
    return 0;
}

```

---

## 作者：孙思维 (赞：0)

```delphi
var n,k,m,i,max:longint;
a:array[1..1000000]of longint;
begin
  max:=-maxlongint;
  readln(n);
for i:=1 to n do read(a[i]);
for i:=1 to n do
begin
   k:=k+a[i];
   if k>m then m:=k;
   if k<0 then k:=0;
end;
if m=0 then begin
  for i:=1 to n do
  if a[i]>max then max:=a[i];
  write(max);
end
  else
write(m);
end.
```
一次循环累加k,m=max(m,k+a[i]);注意全是负数的情况。


---


# [GESP202503 七级] 等价消除

## 题目描述


小 A 有一个仅包含小写英文字母的字符串 $S$。

对于一个字符串，如果能通过每次删去其中两个相同字符的方式，将这个字符串变为空串，那么称这个字符串是可以被等价消除的。

小 A 想知道 $S$ 有多少子串是可以被等价消除的。

一个字符串 $S'$ 是 $S$ 的子串，当且仅当删去 $S$ 的某个可以为空的前缀和某个可以为空的后缀之后，可以得到 $S'$。


## 说明/提示

**本题采用捆绑测试。**

对于 $20\%$ 的测试点，保证 $S$ 中仅包含 $a$ 和 $b$ 两种字符。

对于另外 $20\%$ 的测试点，保证 $1 \leq |S| \leq 2000$。

对于所有测试点，保证 $1 \leq |S| \leq 2 \times 10^5$。


## 样例 #1

### 输入

```
7
aaaaabb```

### 输出

```
9```

## 样例 #2

### 输入

```
9
babacabab```

### 输出

```
2```

# 题解

## 作者：__xxy_free_ioi__ (赞：13)

# P11965 \[GESP202503 七级] 等价消除

好题。。。

## 解法

因为只有 26 个字母，所以考虑状压。设转态 $dp_{i,j}$，表示字符串的 $i \sim j$ 位中，二进制下每位所对应字母数量（第一位对应 a，第二位对应 b，以此类推）是否为奇数（奇数为 1，偶数为 0）。那么，我们可以显而易见的得出两个结论：

1. 若 $dp_{i,j} = 0$，则方案数 + 1。
2. 若 $dp_{1,i-1} = dp_{1,j}$，则 $dp_{i, j} = dp_{1,i-1} - dp_{1,j} = 0$。
3. $dp_{1, i} = dp_{1,i} \oplus 2^{S_i-'a'}$

所以，我们发现 $dp$ 只需要递推即可。同时用一个数组 $f_{dp}$ 记录当状态为 $dp$ 时，可行子串数量，每次方案数加上 $f_{dp}$（若 $dp = 0$，则还需 + 1），最后再将 $f_{dp}$ 加 1 即可。

## 代码

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int S = 1 << 26;

ll n, res, dp;
ll f[S];
string s;

int main() {
    cin >> n >> s;
    
    for (int i = 0; i < n; i++) {
        dp ^= (1 << (s[i] - 'a'));
        if (dp == 0) res++;
        res += f[dp];
        f[dp]++;
    }

    cout << res << '\n';

    return 0;
}

```

---

## 作者：Pyrf_uqcat (赞：8)

本以为七级第一题五分钟就过是道黄很离谱了，结果搞了赛时搞了一个半小时的第二题是橙题，自愧不如。

采取桶的方式，记录当前状态下各种结尾的个数，采取二进制节约空间。注意所有字母都只有 $0$ 个的结尾开始赋值为 $1$。


```cpp
#define max(a,b) (a)>(b)?(a):(b)
#define min(a,b) (a)<(b)?(a):(b)
#include <bits/stdc++.h>
#define ll long long 

ll len,ans;

ll cnt[1<<26],now[35];

std::string s;

int main()
{
    std::cin>>len>>s;
    s=" "+s;
    cnt[0]=1;
    for(int i=1;i<=len;i++)
	{
		int t=0;
        for(int j=0;j<26;j++)
        {
			if(j==s[i]-'a')
			{
				now[j]=!now[j];
			}
			if(now[j])
			{
				t+=(1<<j);
			}
		}
        ans+=cnt[t];
        cnt[t]++;
    }
	std::cout<<ans<<std::endl;
    return 0;
}
```

当然也可以用一个数记录当前状态，但我懒得打。

### 后记（有感）

第一题这么简单的题竟然是道黄题，这题思路我考场想了 $1$ 个小时，差点放弃了。

还有就是考试的数据太水了。顺便警示大家：
```cpp
cnt[0]=1;
```
千万不要在定义时就写成：

```cpp
ll cnt[1<<26]={1}
```

因为你会发现它编译不出来。考试的时候一直都是这么写的，就只开了 `1<<23` 的大小，当时拿到了 `12.5` 分，虽然编译器开不下，但是把它改成 `1<<24` 又冒险交了一发，结果分数 `17.5` 了。开成 `1<<25` 就莫名满分了，但是开 `1<<26` 是会报错的。其实如果数据严一些，我只能拿到 `10` 分，结果却莫名多了 `15` 分，运了。

---

## 作者：FJ_EYoungOneC (赞：8)

### 解题思路

若一个子串能被等价消除，则其中每个字符的出现次数必须全为**偶数**。这是因为每次删除两个相同字符的操作，最终会将所有字符的出现次数减至零，而偶数次是完成这一过程的必要条件。

我们用一个 $26$ 位的二进制数来记录当前各字符出现次数的奇偶性。每一位对应一个小写字母：若某位为 $1$，表示该字母出现了奇数次；若为 $0$，则表示偶数次。

若两个前缀 $S[1\dots u]$ 和 $S[1\dots v]$ 的状态相同，则子串 $S[u+1\dots v]$ 满足所有字符出现偶数次。因为此时两前缀的奇偶性差为 $0$，说明中间子串的每个字符变化了偶数次。

所以我们可以用数组 $s$ 记录各状态的出现次数。遍历字符串时，每遇到一个状态 $x$，就将 $s_x$ 累加到结果中（因为此前所有相同状态的位置均可作为子串起点），然后将 $s_x$ 加 $1$。

最终结果即为所有合法子串的数量。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long LL;

const int N = 6.8e7 + 10;

int n;
string str;
int s[N], cnt[26];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> str;
	str = ' ' + str;

	LL res = 0;

	s[0] ++;
	int x = 0;
	for (int i = 1; i <= n; ++ i )
	{
		int u = str[i] - 'a';
		cnt[u] = (cnt[u] + 1) % 2;
		x ^= 1 << u;
		res += s[x];
		s[x] ++;
	}

	cout << res << endl;

	return 0;
}
```

---

## 作者：jimmy9_666 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P11965)

~~这个蒟蒻赛事没把这道普及-写出来~~

### 题意

给一个长度为 $n$ 的字符串 $S$。

求 $S$ 中有多少个子串中每一个字母出现的次数都为两次。

### 分析

首先看 $20$ 分做法，定义一个二维数组 $cnt_{i,j}$ 在 $S$ 的前 $i$ 个字母中 $j$ 这个字符出现的次数。

然后枚举每一个字串进行判断，统计有多少个子串 $[l,r]$，如果都满足每个字符 $c$， $cnt_{r, c}-cnt_{l - 1, c}\mid 2$。

算法复杂度为 $O(n^2)$。

然后我们来考虑进行优化，仔细观察不难发现在判断每个字符串时，其实只与出现的次数的奇偶有关，所以我们可以考虑用 $0,1$ 来代表出现次数为奇数或偶数。然后使用一个 $26$ 位的二进制数进行存储 $S$ 前 $i$ 位的出现次数奇偶，记为 $x_i$。

那么此时若要判断一个子串 $[l,r]$ 是否满足条件，就可以简化为判断 $x_r$ 与 $x_{l-1}$ 是否相等。

然后我们再使用一个 `map` 来记录各状态的出现次数。然后在遍历字符串时，对于遍历到的每一位的状态 $x$，将答案增加 `map` 记录的状态的出现次数，然后将这个次数加一。

答案记得要使用 `long long` 存储。

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <map>
#define LL long long
#define int long long

using namespace std;

int n;
string s;
map<int, int> m;
int ans; 

signed main() {
	cin >> n >> s;
	m[0] = 1;
	int x = 0;
	for (int i = 0; i < n; i ++ ) {
		x ^= (1 << (s[i] - 'a'));
		ans += m[x];
		m[x] ++ ;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：CMZ369 (赞：3)

### 思路

我们发现如果一个子串能被消除，则其每个字符的个数都是偶数，那么我们就用 $cnt_{i,c}$ 表示前 $i$ 个字符，字符 $c$ 的个数，因此一个能被消除的子串满足 $cnt_{r,c}-cnt_{l-1,c}=0$，即 $cnt_{r,c}$ 和 $cnt_{l-1,c}$ 奇偶性相同。

那么我们就可以想到暴力做法：枚举所有子串，通过计算判断能否被消除。

我们真的需要枚举所有子串吗？不。我们可以用 $26$ 位二进制表示每个字符的奇偶性，就可以存储当前每种奇偶性子串的个数，我们只需遍历一遍字符串，维护前 $i$ 个字符组成的子串的奇偶性，然后将答案加上当前奇偶性是前 $i$ 个字符组成的子串的奇偶性的子串个数就可以了。

### 代码

代码很短。


```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int n,x;
map<int,long long> m;
long long ans; //答案会很大，要开 long long。
int main()
{
    cin>>n>>a;
    m[0]=1; //注意还有空子串。
    for(int i=0;i<n;i++)
    {
        x^=1<<(a[i]-'a');
        ans+=m[x];
        m[x]++; //要先加答案再自增。
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

首先对于每个字母进行前缀和，这是容易的。

此时容易写出一个 $O(n^2)$ 的枚举子串做法，无法通过。

注意到本题只考虑数量奇偶，所以把前缀和出来的东西只按奇偶分成两类。

此时发现存在一个子串合法当且仅当首尾前缀和的形态完全一致，于是开个桶记录形态就能迅速统计贡献。

于是做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>a[200005];
map<vector<int>,int>mapp;
int ans;
signed main(){
    int n;
    cin>>n;
    string s;
    cin>>s;
    s=" "+s;
    for(int i=0;i<26;i++)a[0].push_back(0);
    mapp[a[0]]++;
    for(int i=1;i<=n;i++){
        for(char c='a';c<='z';c++)
        a[i].push_back(a[i-1][c-'a']^(s[i]==c));
        ans+=mapp[a[i]];
        mapp[a[i]]++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：hwc2011 (赞：2)

一级蒟蒻来写七级题解了（~~其实就是不想考~~）。\
观察本题关于奇偶性的判断，容易想到使用异或，因为异或具有一个性质：在一个二进制位上，有奇数个 $1$ 异或为 $1$，有偶数个 $1$ 异或为 $0$。\
由于有 $26$ 个字母，可以考虑状压，用一个 $26$ 位的二进制数表示状态。\
可以参考前缀和的思想，设 $now_i$ 为前 $i$ 项各个字母的出现次数的奇偶性，$f(i,j)$ 表示取首为 $S_i$、尾为 
$S_j$ 的 $S$ 的子串，如果 $now_i = now_j$（$1 \leq i < j \leq |S|$），则可以知道 $f(i + 1,j)$ 中每个字母的出现次数一定都是偶数，由于偶数个 $1$ 异或值为 $0$，所以前后异或值不变。所以我们只需要统计每个状态出现的次数，每次都和前面已经出现过的进行匹配就行了。\
注意事项：

- 因为 $|S| = 2 \times 10^5$，答案可能高达 $19999900000$，所以要用 $64$ 位整型。
- 如果 $now_i = 0$，显然 $f(1,i)$ 是可行的，不要忘记统计。
- 因为 $2^{26}-1=67108863$，使用普通数组可能会超过空间限制，所以可以考虑使用 ```map``` 或 ```unordered_map```。

示例代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,now;
string s;
map<int,int>cnt;
signed main(){
	cin>>n>>s;
	for(int i=0;i<n;i++){
		now=now^(1<<s[i]-'a');
		if(now==0) ans++;
		ans+=cnt[now];
		cnt[now]++;
	} 
	cout<<ans;
}
```

---

## 作者：liyancen (赞：2)

# 题解报告
首先这道题是可以打 $O(n^2)$ 的暴力的，但是呢，我们是高手，所以说要想正解。

不难发现如果一个子串能被消除的话，他的每个字符的个数都是偶数，换句话说，如果一个字串想要被消除，那么他首尾的奇偶性应该是相同的，那么我们就用一个桶数组来记录前 $i$ 位时字符 $c$ 的个数不就行了？

那么答案就很显然了，我们遍历 1 遍字符串，然后每次都找当前奇偶性和之前相同的不就完了？

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,x;
long long cnt;//不开longlong见祖宗
map<int,long long>p;//用map，方便计数
int main(){
	cin>>n;
	cin>>s;
	p[0]=1;
	for (int i=0;i<n;i++){
		x^=1<<(s[i]-'a');
		cnt+=p[x]++;
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：Lcm_simida (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P11965)

此题只有小写字母，很容易想到一种类状压的思想。

我们令 $cnt[x]=\sum_{i=0}^{25} num[i]*2^i $ 其中 $num[i]$ 表示第 $i+1$ 个小写字母在 $1$ 到 $x$ 中出现的次数是否为奇数。因此不难看出，若 $i$ 到 $j$ 是个符合要求的子串，则 $cnt[i]=cnt[j-1]$，无需证明。

于是我们可以用 $vis[x]$ 存之前 $cnt$ 值为 $x$ 的个数。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt=0;
long long ans=0;
string a;
map<int,int> vis;
int main(){
	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);vis[0]=1;
	cin>>n>>a;a=" "+a;for(int i=1;i<=n;i++){cnt=cnt^(1<<(a[i]-'a'));ans+=vis[cnt];vis[cnt]++;}
	cout<<ans;
	return 0;
}

```

---

## 作者：qwqerty (赞：2)

# 解题思路
这里借助了一点状压的思想。  
显然，可以消除相当于每个字符出现的次数都为偶数次。考虑用一个二进制变量 $t$ 记录字符的奇偶性。若一个字符出现的次数为奇数，则变量的该位为 $1$，否则为 $0$。  
若 $t_i=t_j$（此处的 $t_i$ 指的是处理字符串第 $i$ 位时的 $t$ 值），则 $[i+1,j]$ 的这个子序列一定满足每个字符出现的次数都为偶数（因为此时 $[1,i]$ 与 $[1,j]$ 中每个字符的出现次数的奇偶性相同）。所以我们用 `map` 或 `unordered_map` 记录即可（保险起见使用 `unordered_map`）。  
注意 $0$ 要提前标记一下，因为对于 $t=0$ 时，选取 $[1,i]$ 是可行的。
# AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t, n, ans;
string s;
unordered_map<int, int> mp;
signed main() {
	cin >> n >> s;
	mp[0] = 1; for (char c : s) 
		t ^= (1 << (c - 'a')), ans += mp[t], mp[t]++;
	cout << ans;
	return 0;
}
```

---

## 作者：Bismuth_Sulfate (赞：2)

注：完全的考场思路。

---

## 题意简述（形式化题面）

有一个只含小写字母的字符串 $S$。

定义好串为，所有字符的出现次数均为偶数次的字符串。例如，`aa`、`abaccb` 就是好串，但 `aabab` 不是。

你要求出 $S$ 的非空子串中，好串的个数。

## 思路 $1$ （$20$ pts）

虽然说 $|S|$ 可以干到 $2\times 10^5$ 去，$O(n^2)$ 会超时，但是既然有个 $2\times 10^3$ 的部分分，我们可以先打个暴力再说嘛。

可以很明显地注意到，满足条件的子串的长度必为偶数。我们可以写两层循环，第一层枚举子串长度，第二层枚举子串的位置。

那么，我们怎么判定子串是否满足条件呢？

很简单，开个长度 $26$ 的数组存字符数量，然后看看这数组里是否全是偶数就完了。

但是有个问题，你这样子就已经有个常数 $26$ 了。虽然 $O(n^2)$ 过不了，也还是要象征性优化一下的。

注意到我们只关心字符数量的奇偶性，所以我们可以改成长度 $26$ 的 `bool` 数组。再优化一下的话，可以把这个数组改成一个 `int` 变量，修改时用位运算，方便判断数组是否全 $0$。

而且，我们不需要每次都重新统计一遍。每一个新的子串，其实就是原来的子串去掉一个字符再增加一个字符：

$$\text{ab\color{#F00}cd\color{#444}ef}\to\text{abc\color{#F00}de\color{#444}f}$$

那么，以下就是我们的代码逻辑：

- 从 $2$ 到 $|S|$ 遍历子串长度，每次增加 $2$。
- 统计最左边子串的字符数量。
- 每次去掉最左边的字符，增加最右边的字符。
- 在这过程中，统计有多少个子串满足条件。

记得开 `long long`。

代码（主程序部分）：

```cpp
#define int long long
signed main(){
  int n,alpha,ans=0;
  string s;
  cin >> n >> s;
  for(int i = 2;i <= n;i += 2){
    alpha = 0;
    for(int j = 0;j < i;++j){
      alpha ^= 1 << (s[j] ^ 96);
    }
    if(!alpha)++ans;
    for(int j = 1;j <= n-i;++j){
      alpha ^= 1 << (s[j-1] ^ 96);
      alpha ^= 1 << (s[j+i-1] ^ 96);
    }
  }
  cout << ans;
  return 0;
}
```

交一发上去，$20$ 分。

我们要开始思考正解了。

## 思路 $2$（非常诡异但 $100$ pts）

考场心路历程：

> 好吧，好吧，看来必须用 $O(n)$ 啊。那也就是说，肯定要用到什么高端思想了。  
> 图论？这真不至于，这又不是差分约束啥的。  
> 单调队列？这题目倒确实有滑动窗口，但也没有最值啊。  
> 前缀和？更扯了点。  
> 这真的可能吗？真的能被完成吗？  
> 前缀和？前缀和！

是的，我们可以用前缀和思想，按照上面代码里 `alpha` 一样的思路去给字符串做个前缀统计，统计答案的时候一减就行，完美。

例如，字符串 $\text{abaab}$：

$$
\text{a}\to 01 \\
\text{ab} \to 11 \\
\text{aba} \to 10 \\
\text{abaa} \to 11 \\
\text{abaab} \to 01
$$

一减就行，看一看，$\text{abaa}-\text{ab}$ 的结果是 $0$，所以 $\text{aa}$ 满足条件。

诶但是，这样子算字符串的时候确实只要扫一遍 $O(n)$，但是减的时候，还是得 $O(n^2)$ 减啊。

其实这里有个优化手段。我们注意到，我们不关心减得的数具体是几，我们只关心减得的数是否为 $0$。若是 $0$，意味着这里有个满足条件的字符串；若非 $0$，意味着这个字符串不满足条件。

换句话说，我们只关心前缀统计的结果是否相同。

这是什么？这就是桶排。  
好的，我们就可以开一个桶，`int bucket[67108864]`。  
额，这个桶还是太大了。而且字符串长度只有 $2\times10^5$，开个 $6\times10^7$ 大小的桶不合算。

但我们有个优良的数据结构，可以完美解决上面的问题：`map`。

拿 `map`，我们可以非常轻松地在空间允许的情况下实现桶排。

至于最终答案？我们随意取出两个相同的数，它们相减就是 $0$，意味着一个好串。因此，最终答案就等于：

$$\left(\sum^{i=0}_{2^{26}}{C^{bucket_i}_0}\right)+bucket_0$$

好了，写代码吧。

```cpp
#define int long long
signed main(){
  int n,alpha=0,ans=0;
  string s;
  map<int,int> bucket;
  cin >> n >> s;
  for(int i = 0;i < n;++i){
    alpha ^= 1 << (s[i] ^ 96);
    if(bucket.find(alpha)==bucket.end())
      bucket[alpha] = 1;
    else ++bucket[alpha];
  }
  for(pair<int,int> i : bucket){
    if(i.first == 0)
      ans += i.second;
    ans += i.second*(i.second-1)/2;
  }
  cout << ans;
  return 0;
}
```

太好了，[过掉了](https://www.luogu.com.cn/record/209911444)。

---

另外，以防你不知道我曾尝试为一道还没公开的题目交题解并失败了。

![](https://cdn.luogu.com.cn/upload/image_hosting/fczlu4f0.png)

---

## 作者：Su777 (赞：1)

## 题意简述

定义一个字符串是优秀的，当且仅当所有的字符都在该串中出现了偶数次。

求给定字符串有多少个优秀的字串。字符串长度为 $2\times 10^5$。

## 解题思路

首先可以想到暴力方法。
- 对每个字母做一个前缀和：设 $s_{i, c}$ 表示前 $i$ 个字符中有多少个字符 $c$。
- 然后暴力枚举所有子串，对每个子串进行 $O(1)$ 判断，下标范围为 $[l,r]$ 的子串判断过程如下：对于所有小写字母 $c$，$s_{r,c} - s_{l-1,c}$ 必须为偶数。
- 总时间复杂度 $O(n^2)$，可以得到 $20$ 分。

然后考虑优化。认真观察 $O(1)$ 判断一个字符串的过程：$s_{r,c} - s_{l-1,c}$ 必须为偶数，即 $s_{r,c}$ 与 $s_{l-1,c}$ 的奇偶性相同。

我们设法把这个复杂的判断转化为一个简单的判断：用一个 $26$ 位的二进制数来表示 $s_i$，记为 $k_i$。若 $k_{l-1}$ 与 $k_r$ **相等**，那么子串 $[l,r]$ 是符合要求的。

这样就很好做了：从 $1$ 到 $n$ 遍历一遍 $r_i$，用 `map` 统计所有 $r_i$ 的出现次数，然后统计 $[0,i-1]$ 区间内有多少个与 $r_i$ 相等的数。

注意 $r_0 = 0$，且必须要被记录到 `map` 中。因为子串如果从下标 $1$ 开始，需要使用到 $r_{1-1}$ 即 $r_0$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int n, cnt[26];
char s[200005];
ll res[200005];
map<ll, int> c;

int main() {
	scanf("%d", &n);
	scanf("%s", s + 1);
	c[0] ++;
	ll ans = 0;
	for (int i = 1; i <= n; i ++) {
		cnt[s[i] - 'a'] ++;
		for (ll j = 0; j < 26; j ++) {
			res[i] += (1ll << j) * (cnt[j] % 2);
		}
		ans += c[res[i]];
		c[res[i]] ++;
	}
	cout << ans << "\n";
	
	return 0;
}
```

---

## 作者：abc1856896 (赞：1)

第一眼还以为是前年某组某蓝题，但此题**不**要求**相邻**。

# Solution

先考虑朴素如何判定一个串是可以被等价消除的：开个数组维护字符数量，然后判断这数组里是否全是偶数即可。

但一个可以被等价消除的串必然是原串的一个连续子序列，为了快速区间字符数量，令 $sum_{i,j}$ 表示前 $i$ 个字符中是第 $j$ 小写字母的个数。

同时，记子序列区间左端点为 $l$，右端点为 $r$。那么这个串的字符数量为 $sum_{r,i}-sum_{l-1,i}$，则该数必为偶数（根据朴素判定条件），即 $sum_{r,i}$ 和 $sum_{l-1,i}$ 同奇偶。由于我们只关心奇偶，所以可以将 $sum_{r,i}$ 和 $sum_{l-1,i}$ 转化为一个只有 $0$ 和 $1$ 的串。此时，判定条件转化为当且仅当两者对应转化后的串完全相等。

有了这个条件，答案即为相同串的组数，而这是简单的。我们只需要开个桶维护转化串，记桶的大小为 $siz_i$，则答案为 $\sum \frac {(siz_i-1) \times siz_i} {2}$。

代码很好写。
# Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
string s;
map<string,int> st;
int sum[200005][27],ans;
signed main(){
	cin>>n>>s;
	s="#"+s;
	for(int i=0;i<=n;i++) {
		string k="";
		if(!i) {
			for(int i=1;i<=26;i++) k+="0";
			st[k]++;
			continue;
		}
		for(int j=1;j<=26;j++) {
			if((s[i]-'a'+1)==j) sum[i][j]=sum[i-1][j]+1;
			else sum[i][j]=sum[i-1][j];
			if(sum[i][j]%2) k=k+"1";
			else k=k+"0";
		}
		st[k]++;
	}
	for(auto it=st.begin();it!=st.end();it++) {
		ans=ans+((it->second)*(it->second-1))/2;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Alex866 (赞：1)

## 题意分析
题目让我们求 $S$ 的子串中每个字符均为偶数的子串数量。
## 算法选取
首先，观察~~标签~~数据量可知，需要前缀和优化，毕竟 $O(n^3)$ 的复杂度，再怎么卡都卡不过。但优化后的复杂度也是 $O(n^2)$，除非你有逆天卡常，否则还是会 TLE。
## 优化
由于题目只让记录每个字符的奇偶，所以想到了我们的 bitset。但即使用了 bitset 优化，在 64 位的计算机上，复杂度仍为 $O(\frac{n^2}{w})$，其中 $w=64$，约为 $6\times10^8$（实测只有 20 分）。  
然后，我们又想到了桶，但是 26 位奇偶性，共约有 $6.7\times10^7$ 个桶，共 512MB，加上其他变量，绝对会MLE。这里要使用桶的另一种方式——map。map 内部是一棵红黑树，插入查询复杂度均为 $O(\log n)$，优化后复杂度为 $\frac{n\log n}{w}$，约为 $5\times10^4$。
## 注意事项
1. 前缀和时要留一个全 0 的 bitset，但统计时要统计上。
2. 十年 OI 一场空，不开 long long 见祖宗。
## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define uint unsigned
#define ull uint ll
#define __Pa(__Type) pair<__Type,__Type>
#define __Greater_Pri_Q(__Type) priority_queue<__Type,vector<__Type>,greater<__Type>>
#define __Stucmp_Pri_Q(__Type,__Cmp) priority_queue<__Type,vector<__Type>,__Cmp>
#define __Clscmp_Pri_Q __Stucmp_Pri_Q
#define __Func_Pri_Q(__Type,__Cmp) priority_queue<__Type,vector<__Type>,decltype(&__Cmp)>
#define __Pri_Q(__Type) priority_queue<__Type>
//#define ONLINE_JUDGE
#ifndef ONLINE_JUDGE
#define __put(__X,__F1,__F2) ((__F1)?(cout<<(#__X)<<':'<<(__X)<<" \n"[__F2]):(cout<<(__X)<<" \n"[__F2]))
#define __put0 __put(0,0,0)
#define __putenter cout<<'\n'
#else
#define __put(__X,__F1,__F2)
#define __put0
#define __putenter
#endif
#define __INT_TO_LL   //注意事项2
#ifdef __INT_TO_LL
#define int long long
#endif
//#define __USE_FREOPEN
#define __CLOSE_SYNC
#define y1 __Y1_By_MySelf__
using namespace std;
struct cmp{
	bool operator () (bitset<26> a,bitset<26> b){
		for(int i=0;i<26;i++){
			if(a[i]==0&&b[i]==1){
				return 0;
			}
			if(a[i]==1&&b[i]==0){
				return 1;
			}
		}
		return 0;
	}
};
string s;
int len,ans;
bitset<26> sum[200005];
map<bitset<26>,int,cmp> ma;
signed main(){
#ifdef __CLOSE_SYNC
	ios_base::sync_with_stdio(0);
#endif
#ifdef __USE_FREOPEN
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>len>>s;
	for(int i=0;i<len;i++){
		sum[i+1][s[i]-'a']=!sum[i+1][s[i]-'a'];
	}
	for(int i=1;i<=len;i++){
		for(int j=0;j<26;j++){
			if(sum[i][j]!=sum[i-1][j]){
				sum[i][j]=1;
			}else{
				sum[i][j]=0;
			}
		}
	}
	for(int i=0;i<=len;i++){   //注意事项1
		ma[sum[i]]++;
	}
	for(auto i:ma){
		ans+=i.second*(i.second-1)/2;
	}
	cout<<ans;
	return 0;
}
//禁止抄袭
```

---


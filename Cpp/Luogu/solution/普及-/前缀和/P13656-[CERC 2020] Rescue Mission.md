# [CERC 2020] Rescue Mission

## 题目描述

犯罪解放粗暴小队（CLRS）计划袭击一列正在穿越沙漠、押送囚犯去另一座监狱的火车，并解救其中至少一部分囚犯。

CLRS 恰好有 10 辆卡车，这些卡车将把被解救的罪犯从袭击地点运送到临时机场，飞机已经在加油，准备将罪犯带出国。

在袭击现场，CLRS 会闯入一节车厢，制服车厢守卫，释放该车厢内的所有囚犯，然后前往下一节车厢。小队会从最先被袭击的车厢开始，依次向火车末端推进，逐节释放囚犯。CLRS 自豪地宣称，他们会释放并装载所有被袭击车厢内的罪犯到卡车上。CLRS 在火车上只会朝一个方向前进，绝不会回头。

有些奇怪的是，离开现场时，每辆卡车上被解救的罪犯人数必须完全相同。这是 CLRS 长久以来的安全迷信，无论如何都不能违反。

还有坏消息。警方很可能会在附近巡逻，因此袭击后必须尽快离开现场。也就是说，只要满足迷信规则，就要立即撤离。

也有可能任务无法完成。例如，如果 CLRS 从距离火车末端太近的车厢开始袭击。

现在，一切都必须精心策划。CLRS 事先知道每节车厢内被押送的罪犯人数。他们想知道，对于火车上的每一节车厢，如果从该车厢开始袭击，需要袭击多少节车厢。

## 说明/提示



由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
0 2 4 6 8```

### 输出

```
1 4 2 -1 -1```

## 样例 #2

### 输入

```
5
5 5 5 0 5```

### 输出

```
2 2 3 1 -1```

# 题解

## 作者：zyr2011 (赞：2)

### 题目大意
有一节有 $N$ 个车厢的列车，第 $i$ 个车厢里关着 $a_i$ 个犯人，问从第 $i$ 个车厢开始**往后**解救犯人，最终要解救多少个车厢里的犯人，才能使 $10$ 辆卡车上的犯人数量一样？
### 题目解法
不难想到用**前缀和**来计算，只有解救的犯人总数为 $10$ 的倍数，才会有解，所以我们的前缀和数组 $s$ 中的每一项都要**对 $10$ 进行取模**，然后维护一个 $last$ 数组，$last_i$ 代表在前缀和数组中每个数字**在当前位置之后首次出现**的位置，查询 $last_{s_i}$，如果 $last_{s_i} \le n$，那么答案即为 $last_{s_i} - i$，否则无解。
### 满分代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define re register
using namespace std;
const int N=1e5+10;
int a[N],s[N],last[10+10],ans[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n;cin>>n;
	for(re int i=1;i<=n;++i){
		cin>>a[i];s[i]=(s[i-1]+a[i])%10;//前缀和数组对10进行取模 
	}
	for(re int i=0;i<10;++i){
		last[i]=n+10;//不要忘了初始化 
	}
	for(re int i=n;i>=0;--i){
		if(i<n){
			if(last[s[i]]<=n){
				ans[i]=last[s[i]]-i;//有解的情况 
			}
			else{
				ans[i]=-1;//无解的情况 
			}
		}
		last[s[i]]=i;//不要忘了更新last数组！ 
	}
	for(re int i=0;i<n;++i){
		cout<<ans[i]<<" ";
	}
	return 0;
}
```

---

## 作者：inscape (赞：0)

其实根本不需要楼上说的什么前缀和啊，这题暴力就行了。

## 题目简述

给定一个长度为 $n$ 的数列 $A$，对于每个 $k$，寻找最小的整数 $m(1\le m\le n-k+1)$，使得 $\sum^{k+m-1}_{i=k} A_i \equiv 0 \pmod{10}$。

## 思路

按照题意模拟即可，使用双重循环，第一重循环枚举 $k$，第二重循环向后枚举，使用一个变量记录这一段内的数字之和，再判断其是否 $\bmod 10=0$，如果是，则求出 $m$ 设当前枚举到的下标为 $j$，则 $m=k-j+1$，随后输出 $m$ 并跳出第二重循环，否则继续向后枚举。

## $Code$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]; // 输入
	for(int k=1;k<=n;k++){ // 枚举k
		int sum=0; // 记录数字和
		for(int j=k;j<=n;j++){ // 向后枚举
			sum+=a[j]; // 加上
			if(sum%10==0){ // 若是10的倍数
				cout<<j-k+1; // 求出m并输出
				break; // 跳出循环
			}
		}
		if(sum%10!=0) cout<<-1; // 输出-1的情况
		cout<<' '; // 记得输出空格
	}
	return 0;
}
```

---


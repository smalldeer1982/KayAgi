# 领地选择

## 题目描述

作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。

首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。


## 说明/提示

对于 $60\%$ 的数据，$N,M\le 50$。

对于 $90\%$ 的数据，$N,M\le 300$。

对于 $100\%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。

## 样例 #1

### 输入

```
3 4 2
1 2 3 1
-1 9 0 2
2 0 1 1
```

### 输出

```
1 2
```

# 题解

## 作者：GossWandering (赞：123)

- $\text{Update by Curry on 2020/12/1}$ : 修了图 & $\LaTeX$，更新了一点内容
- $\text{Update by Curry on 2021/3/12}$ : 感谢 $\color{black}\text{f}\color{red}\text{gtl}$ 神仙的提醒，修改了一个小错误。

题意大概是说 $n\times m$ 的矩形中找到一个边长为 $c$ 的矩形使它的价值最大。

根据题意，我们可以枚举左上角的坐标，利用边长 $c$ 算出左下、右上、右下角。再暴力枚举价值和，更新答案即可。

> 时间复杂度：$O(nmc^2)$
>
> 预计得分：50~70 points

程序如下：
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N=1010;

int n,m,c;
int val[N][N],maxx=-inf,wherex,wherey;

int main(){
    scanf("%d%d%d",&n,&m,&c);
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            scanf("%d",&val[i][j]); //输入
    for(int x1=1; x1<=n-c+1; x1++) 
        for(int y1=1; y1<=m-c+1; y1++){  //枚举左上角
            int x2=x1+c-1;
            int y2=y1+c-1;  //计算右下角
            int ans=0;
            for(int i=x1; i<=x2; i++)
                for(int j=y1; j<=y2; j++)
                    ans += val[i][j];
            if(ans>maxx){
                maxx=ans;
                wherex=x1;
                wherey=y1;
            }//更新答案
        }
    printf("%d %d",wherex,wherey);
    return 0;
}
```



提交上去？？啊，果然70分。沮丧的我们不得不思考优化。

在此之前，我们思考，我们写出的程序到底差在哪儿？？？

> 请先思考，再往下阅读

原来，我们的程序有些地方算重复了：

$\text{for example}$:

- $(1,1)$ 为左上角，$c=2$ 时我们算了$(1,1)+(1,2)+(2,1)+(2,2)$；
- $(1,2)$ 为左上角，$c=2$ 时我们算了$(1,2)+(1,3)+(2,2)+(2,3)$；

咦？$(1,2)+(2,2)$ 被我们算重了！对于这种情况，有一个经典的解决方法——预处理。

所以我们考虑用（二维）前缀和优化

下面我们讲一下什么是二维前缀和，建立在一维前缀和之上，我们要求一个矩阵内一个任意的子矩阵的数的和，我们就可以用二维前缀和，我们还是用DP来预处理，状态和一维前缀和差不多，只不过我们多加了一维。

用 $f(i,j)$ 表示 $1,1$ 这个点与 $(i,j)$ 这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，则状态转移方程为：

$f(i,j)=f(i,j-1)+f(i-1,j)-f(i-1,j-1)+val_{i,j}$

其中 $val_{i,j}$ 表示 $(i,j)$ 这一格的价值。

怎么来的呢？我们画一下图就知道了。

![look](https://cdn.luogu.com.cn/upload/image_hosting/k8679a1x.png)

一开始是这样的：$f(i,j)$ 为 $0$，即图中所有格子都是白色的。

![look](https://cdn.luogu.com.cn/upload/image_hosting/3lbmt2rq.png)

回顾转移方程：$f(i,j)=f(i,j-1)+f(i-1,j)-f(i-1,j-1)+val_{i,j}$

第一个加的是 $f(i,j-1)$，所以我们将 $(1,1)$ ~ $(i,j-1)$ 染成黄色，表示加过一次。如上图所示。

![look](https://cdn.luogu.com.cn/upload/image_hosting/0o3gkau9.png)

此后再加上 $f(i-1,j)$，但是我们发现两次染色中有一部分是重复染色的。即：$(1,1)$~$(i-1,j-1)$，它们被染过两次色，在上图中我们将这一块区域染成棕色。

![](https://cdn.luogu.com.cn/upload/image_hosting/484s8qa2.png)

既然重复计算了，那我们就剪掉，即减去$f(i-1,j-1)$，此时 $(1,1)$~$(i-1,j-1)$ 又回归了黄色（即只染过一次色）。我们发现：只需再把 $(i,j)$ 这一格染成黄色，便大功告成了！

即加上：$val_{i,j}$，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/likuvz8t.png)

所以我们用图解证明了转移方程 $f(i,j)=f(i,j-1)+f(i-1,j)-f(i-1,j-1)+val_{i,j}$

我们看一下实现代码：

```cpp
for(int i=1; i<=m; i++)
    for(int j=1; j<=n; j++)
        f[i][j]=val[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
```

现在只需枚举左上角，根据边长 $c$ 算出左下角，然后用二维前缀和 $O(1)$ 更新。

附 $(x_1,y_1)$ 到 $(x_2,y_2)$ 权值和的计算方法：

$f(x_2,y_2)-f(x_2,y_1-1)-f(x_1-1,y_2)+f(x_1-1,y_1-1)$

这可以用二维前缀和的定义进行理解，或用图解也行。

完整代码不提供了，其余几篇题解都讲的挺好。

---

## 作者：睿屿青衫 (赞：66)

今天刚会前缀和，冥思苦想把自己写晕了，注释也不管用，然后出去上了个厕所的功夫，本校神犇过来看了一下这道题，等我回来看记录时@向金牌冲刺 已经A掉了！

然后另一个神犇@wfcyywh1225 看到我做不出来，3遍A掉了！

我决定虚心学习他们的代码，发现前缀和还有二维这种操作！！！
第一次两重循环是指的是1,1为左上，i，j右下的矩形的面积，别单纯看，不好想，画个图一目了然。

易错点：第二次二重循环从c开始枚举，想一想，为什么？别忘了maxx初始一定要小！想当然的随便初始化一个值导致90分

坐标记录时别忘了+1，也要画图看出来。
大坑！题目描述有误：左上角坐标！相信一定坑了很多人吧？（已联系管理员更正）

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define maxn 1010
int n,m,c,p[maxn][maxn],s[maxn][maxn],maxx=-0x7fffffff,xx,yy;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>c;
    for(int i=1;i<=n;++i)
     for(int j=1;j<=m;++j)
      {
          cin>>p[i][j];
          s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+p[i][j];
      }
    for(int i=c;i<=n;++i)
     for(int j=c;j<=m;++j)
      {
          if(s[i][j]-s[i-c][j]-s[i][j-c]+s[i-c][j-c]>maxx)
           {
               maxx=s[i][j]+s[i-c][j-c]-s[i-c][j]-s[i][j-c];
               xx=i-c+1;yy=j-c+1;
           }
      }
    printf("%d %d",xx,yy);
    return 0;
}
```

---

## 作者：蒟___ (赞：59)

## 领地选择_题解



这一道题嘛，用的是前缀和的思想。

如果对于一维，即是求一串数列的任意字段的最大数量和

时，在输入时首先用另一个数组将之前每一项的数字加起

来，操作如下:


```cpp
#include<iostream>
using namespace std;
#define inf 5005
int main(){
	int g[inf]={},a[inf]={},n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>g[i];
		a[i]=a[i-1]+g[i];//数组a储存和
	}
	//...
	
}
```
---
求每段和时只需将a[i]-a[j-1]即可,具体操作如下，相信你

自己是可以推导出来的吧，(●'◡'●)：



```cpp

#include<iostream>
using namespace std;
#define inf 5005
int main(){
	int g[inf]={},a[inf]={},n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>g[i];
		a[i]=a[i-1]+g[i];
	}
	int ans=inf;
	for(int i=1;i<=n;i++){
		for(int j=0;i<i;j++){//这里我将j从0开始，方便！
			ans=max(ans,a[i]-a[j]);
		}
	}
	cout<<ans;
	return 0;
}
```
可见 [最大字段和（p1115）](https://www.luogu.com.cn/problem/P1115)


---


讲了一维，现在换成了二维，道理当然一样。

~~欲证不难，读者自证即可啦！~~

这里就不多废话啦，详见代码叭：

~~~cpp
#include<iostream>
using namespace std;
int n, a[5005][5005], g[5005][5005], f[5005][5005], ans=-2147483648, ch = 1, che = 1, m, c;
int main() {
    cin >> n >> m >> c;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> g[i][j];
            a[i][j] = a[i][j - 1] + g[i][j];
            f[i][j] = f[i - 1][j] + a[i][j];//同样的储存，同样的味道
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (j + c -1> m || i + c -1> n) continue;
            int q = ans;
            ans = max(ans, f[i + c-1][j + c-1] + f[i - 1][j - 1] - f[i - 1][j + c-1] - f[i + c-1][j - 1]);//和一维道理相同的思路
            if (ans != q) {
                ch = i; che = j;//记录下标
            }
        }
    }


    cout << ch << " " << che;
    return 0;
}
~~~

---
okk,这样就行啦！！

理解，理解，理解最重要，重要的事情说三遍！！！

不要硬着ctrl a c v...（枯）

本蒟蒻继续努力，争取给大家奉献出更加优质的代码。

~~记得三连哦~~~(哎？好像走错频道了...)

byebye~~~

---

## 作者：EarthGiao (赞：31)

#### 【闲话】
看到题解里面有认识花笙米我想说：    
~~绝对的锦衣卫！！！！！~~    
## 【思路】
二维前缀和    
很有意思的一道题     
简直就是二维前缀和的模板   
只要好好利用二维前缀和   
能够求出以每个点为右下角的矩阵里价值最大的点的位置就可以了   

[二维前缀和详解](https://www.cnblogs.com/acioi/p/11705205.html) 
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int Max = 1003;
int a[Max][Max];
int f[Max][Max];
signed main()
{
	int n,m,c;
	cin >> n >> m >> c;
	for(register int i = 1;i <= n;++ i)
		for(register int j = 1;j <= m;++ j)
			cin >> a[i][j],f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + a[i][j];
	int M = 0,x,y;
	for(register int i = c;i <= n;++ i)
		for(register int j = c;j <= m;++ j)
			if(f[i][j] + f[i - c][j - c] - f[i - c][j] - f[i][j - c] > M)
			{
				int acioi = f[i][j] + f[i - c][j - c] - f[i - c][j] - f[i][j - c];
				M = acioi;
				x = i,y = j;
			}
//	cout << x << " " << y << endl;
	cout << x - c + 1 << " " << y - c + 1 << endl;
	return 0;
}
```

---

## 作者：GMSD (赞：18)

本蒟蒻在看了这道题时，想着：这么简单的吗，四重循环不就好了吗  
一个华丽的70从天而降  
某大佬从我面前走过，不屑的笑了笑，丢下了一句：qzh  
懵懂的我心中充满了**？**  
思考了半个小时后  
惊讶的发现**前缀和**  
二维前缀和公式：  
```cpp
f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+mapp[i][j];
```
之后再枚举左上角i j，右下角为i+C-1 j+C-1
附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int length,wide,C,mapp[3002][3002],Max=-999999999,maxx,maxy,f[3002][3002];

int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}

int main(){
	length=read();wide=read();C=read();
	for(int i=1;i<=length;i++)
	   for(int j=1;j<=wide;j++){
	       mapp[i][j]=read();
	       f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+mapp[i][j];
	   }
	for(int i=1;i<=length-C+1;i++)
	   for(int j=1;j<=wide-C+1;j++){
	   	  int sum=f[i+C-1][j+C-1]+f[i-1][j-1]-f[i-1][j+C-1]-f[i+C-1][j-1];
	   	  if(sum>Max)Max=sum,maxx=i,maxy=j;
	   }
	cout<<maxx<<" "<<maxy;
	return 0;
}
```


---

## 作者：【花笙米】沫 (赞：17)

#看我名字就知道了。。绝对的花笙米（双笙粉丝啦），，（双笙是古风和翻唱歌手。希望大家喜欢她的歌啦）

-下面开始解题

-刚刚看到下面一堆前缀和dalao觉得自己好菜啊。。

-我的做法（和最大子矩阵相似）

我们先将数读入/废话      我们将从上往下c行的数相加放在一个数组里，一共有n-c+1，然后用这个数组从左到右c个求和得到最大的一个c

这时数组的数量则是x，，而从左到右枚举的c则是y/这样就搞定啦、、、很难理解不是。。。看下面。。

```cpp
#include<stdio.h>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
 using namespace std;
int n,m,c;
int a[1005][1005];
int h[1005][1005];//这个数组就是记录从上往下的一共n-c+1个的c为宽m为长的矩阵
int ans=-1<<30;//要注意。。反正你们也知道。。不能是0，有负数。。我死了2分钟
int x,y;
int main(){
    scanf("%d%d%d",&n,&m,&c);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=c;j++)h[1][i]+=a[j][i];
    for(int i=1,l=c+1;l<=n;i++,l++){
        for(int k=1;k<=m;k++){
            h[i+1][k]=h[i][k]+a[l][k]-a[i][k];//将大矩阵压缩成n-c+1个小矩阵在一个数组中
        }
    }
    for(int i=1;i<=n-c+1;i++){
        int tot=0;
        for(int j=1;j<=c;j++)
            tot+=h[i][j];
        if(ans<tot){//开头也有可能最大
            ans=tot;
            x=i,y=1;
        }
        for(int j=c+1,k=1;j<=m;j++,k++){//枚举从左到右c个范围。找最大
            tot+=h[i][j];
            tot-=h[i][k];
            if(ans<tot){//如果数值更大 就更新
                ans=tot;
                x=i,y=k+1;
            }
        }
    }
    printf("%d %d",x,y);
return 0;
}
```
/\*最后再一次宣传双笙，，大爱二笙!!!\*/

---

## 作者：锦瑟，华年 (赞：9)

这道是一题经典的二维和数组。下面我们来讲一讲什么是二维和数组。

同一维和数组一样，分为预处理和计算两部分。我将对这两个部分进行详细讲解。

先说说预处理，一维和数组的 $b[i]$ 代表编号 $1$ 到编号 $i$ 的和，而二维和数组，变量是 $b[i][j]$ ,那么它代表什么呢？它代表左上角编号为 $(1,1)$ ,右下角编号为 $(i,j)$ 的矩阵的和。那怎么算呢？先上代码：

	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];//核心代码
		}
	}
    
我们来看看核心代码部分，b数组是前缀和，a数组是读入的。那为什么可以这么算呢，我们来用一个表表示一下（表中的数代表被加了或减了几次）（设 $i=3$ , $j=4$）：

| 1+1-1 | 1+1-1 | 1+1-1 | 1 | 0 | 
| :----------: | :----: | :----------: | :----------: | :----------:|
| 1+1-1 | 1+1-1 | 1+1-1 | 1 | 0 | 
| 1 | 1 | 1 | 1 | 0 | 
| 0 | 0 | 0 | 0 | 0 | 

化简，得：

| 1 | 1 | 1 | 1 | 0 | 
| :----------: | :----------: | :----------: | :----------: | :----------:|
| 1 | 1 | 1 | 1 | 0 | 
| 1 | 1 | 1 | 1 | 0 | 
| 0 | 0 | 0 | 0 | 0 | 

好神奇的嘞！用这种公式，可以正好算出 $b[i][j]$ 的值。

好我们再讲讲计算部分，先上代码：

	for(i=1;i<=n;i++){
		int k=i+c-1;
		if(k>n)break;
		for(j=1;j<=m;j++){
			int h=j+c-1;
			if(h>m)break;
			int sum=b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1];//核心代码
			//if(sum>ans){//更新max
				//ans=sum;h1=i;h2=j;
			//}
		}
	}
有了上一题的经验，大家可以像我一样画个表把核心代码表示出来，我在这里就不多说了 ~~最主要是因为懒~~ 。

好上总代码：

	#include<stdio.h>
	using namespace std;
	int a[1005][1005],b[1005][1005];
	int main(){
		int n,m,c,i,j;
		scanf("%d%d%d",&n,&m,&c);//输入
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				scanf("%d",&a[i][j]);
			}
		}
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];//预处理核心代码
			}
		}
		int ans=-2147483648,h1=0,h2=0;
		for(i=1;i<=n;i++){//开始计算
			int k=i+c-1;
			if(k>n)break;//特判
			for(j=1;j<=m;j++){
				int h=j+c-1;//注意，(i,j)代表矩阵左上角,(k,h)代表矩阵右下角
				if(h>m)break;//特判
				int sum=b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1];//计算核心代码
				if(sum>ans){//更新max
					ans=sum;h1=i;h2=j;
				}
			}
		}
		printf("%d %d",h1,h2);
		return 0;
	}
好了，题解到此结束，拜拜~~~~~



---

## 作者：Eraine (赞：4)

# 题目简介

## 知识点

 $①$ 动态规划
 
 $②$ 线性动规
 
 $③$ 前缀和
## 难度

普及/提高-（黄题）
# 思路分析

其实这一题并不难。这一题可以说是裸的动态规划前缀和。首先我们先来分析题意：在给定的一个矩形区域中选出一块（边长已给定）的正方形。要求正方形所包含的每一个元素的价值总和最大。问这个最大值是多少。
## 思路一：暴力枚举

时间复杂度是 $O(n^{2}m^{2})$
不说了，直接上代码~

```cpp
#include<iostream>
#define MAXX 1005
using namespace std;
int a[MAXX][MAXX];
int main(){
	int n,m,c,x,y,minx=-2100000000;
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++){//第一层循环
		for(int j=1;j<=m;j++){//第二层循环
			cin>>a[i][j];//输入
		}
	}
	for(int i=c;i<=n;i++){
		for(int j=c,u;j<=m;j++){
			int sum=0;//作为统计和
            for(int k=i-c+1;k<=i;k++){
            	for(int l=j-c+1;l<=j;l++){
            		sum+=a[k][l];//统计该正方形内的每个值
				}
			}
			if(sum>minx){//若大于minx的操作
				minx=sum;//赋值
				x=i-c+1,y=j-c+1;//坐标赋值
			}
			minx=max(minx,sum);
		}
	}
	cout<<x<<" "<<y;//输入
	return 0;
	//完美的结束（说实在不完美，有TLE）
}
```
这种思路总分70分（#6和#7超时），还是要优化的！！！
## 思路二：动态规划/前缀和

名副其实的DP！！！（申明一下不是DFS）思路是这样子的（但是动态规划似乎和思路一差不多）：我们可以把思路一中求每个元素的步骤由 $O(nm)$ 简化成 $O(1)$ 。
### 前缀和嵌入

先上代码~
```cpp
	for(int i=1;i<=n;i++){
		for(int j=1,u;j<=m;j++){
			cin>>u;
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+u;
		}
	}
```
接下来解释一下这么做的原因：运用了数学的[容斥原理](https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/10146840?fr=aladdin)。然后，我们可以将这一个元素以及这一个元素左、上、左上的元素全部求出来。把他左数第一个元素和上数第一个元素加起来，再减去左上的元素。$a_{i_{j}}=a_{i_{j-1}}+a_{i-1_{j}}-a_{i-1_{j-1}}+u$ 例如：

```cpp
2 3 6 -3 6
4 5 3 7 6
```
这时要求第 $2$ 行第 $3$ 列的元素和。第 $2$ 行第 $2$ 列的和是 $14$ ，第 $1$ 行第 $3$ 列的和是 $11$ ，第 $1$ 行第 $2$ 列的和是 $5$ 。这时，第 $2$ 行第 $3$ 列就是 $14+11-5+3=2+3+6+4+5+3=23$。

```cpp
	for(int i=1;i<=n;i++){
		for(int j=1,u;j<=m;j++){
			cin>>u;
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+u;
		}
	}
```

### 动态规划前缀和

同理，按照容斥原理，可以求得答案 $=a_{i_{j-c}}+a_{i-c_{j}}-a_{i-c_{j-c}}$ 。此处就略去样例了。

```cpp
	for(int i=c;i<=n;i++){
		for(int j=c,u;j<=m;j++){
			if(a[i][j]-a[i-c][j]-a[i][j-c]+a[i-c][j-c]>minx){
				minx=a[i][j]-a[i-c][j]-a[i][j-c]+a[i-c][j-c];
				x=i-c+1,y=j-c+1;
			}
		}
	}
```

# AC代码

```cpp
#include<iostream>
#define MAXX 1005
using namespace std;
int a[MAXX][MAXX];
int main(){
	int n,m,c,x,y,minx=-2100000000;
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++){
		for(int j=1,u;j<=m;j++){
			cin>>u;
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+u;
		}
	}
	for(int i=c;i<=n;i++){
		for(int j=c,u;j<=m;j++){
			if(a[i][j]-a[i-c][j]-a[i][j-c]+a[i-c][j-c]>minx){
				minx=a[i][j]-a[i-c][j]-a[i][j-c]+a[i-c][j-c];
				x=i-c+1,y=j-c+1;
			}
		}
	}
	cout<<x<<" "<<y;
	return 0;
}
```


---

## 作者：Priori_Incantatem (赞：3)

又是一道降维的题目，很类似[P1719](https://www.luogu.org/problem/P1719)

不同的是，这题给定了最大矩形（首都）的边长，在枚举的时候会方便一些

枚举首都两条与$X$轴平行的边，注意两边距离必须为$C$，设这两条边为$l,r$

把这个$(r-l+1)\times m$的矩阵压缩成一个一维数组$s$，数组中的每个元素储存的是这一列上的数字和。压缩完后，枚举再首都两条与$Y$轴平行的边$p,q$，同样地，这两条边的距离也必须为$C$。

枚举出了四条边后，就可以确定矩阵的位置了，这个矩阵中的数字和就是$s[p]+s[p+1]+\dots +s[q-1]+s[q]$

维护一个数组$c$，使得$c[i]=a[1]+a[2]+\dots+a[i]$，此方法可以快速求出区间$[l,r]$的区间和：$s[p]+s[p+1]+\dots +s[q-1]+s[q]=c[q]-c[p-1]$

AC代码：

```cpp
#include<cstdio>
#include<cstring>
const int Maxn=1010,inf=0x3f3f3f3f;
#define max(x,y) x>y?x:y
int n,m,len,w,e,u,v;//u,v储存最后首都的左上角坐标，w,e为当前枚举到的首都的左上角坐标
int ans=-inf;
int c[Maxn],s[Maxn],a[Maxn][Maxn];
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int work(int l,int r)//l,r为枚举的矩阵的两条与X轴平行的边
{
	memset(c,0,sizeof(c));
	memset(s,0,sizeof(s));
	int sum=-inf;//注意要复制为-inf,因为有可能出现负数
	for(int i=l;i<=r;++i)
	for(int j=1;j<=m;++j)
	s[j]+=a[i][j];//降维
	for(int i=1;i<=m;++i)
	c[i]=c[i-1]+s[i];
	for(int i=1;i+len-1<=m;++i)
	{
		int tmp=c[i+len-1]-c[i-1];
		if(tmp>sum)sum=tmp,w=l,e=i;
	}
	return sum;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=read(),m=read(),len=read();
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	a[i][j]=read();
	for(int i=1;i+len-1<=n;++i)
	{
		int tmp=work(i,i+len-1);//顶边为i底边为i+len-1
		if(tmp>ans)
		ans=tmp,u=w,v=e;
	}
	printf("%d %d\n",u,v);
	return 0;
}
```

---

## 作者：Great_Influence (赞：3)

虽然仅存的题解表示前缀和会TLE，但是我并没有遇到此事。可能是洛谷更新了吧。

在此便放出前缀和代码。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<iostream>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=21000;
template<typename T>
inline void read(T &x)//读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(k=='-')
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    x=s*f;
}
int s[2000][2000],n,m,c;//s表示前i*j范围内所有点的权值和
int main(void)
{
    read(n);
    read(m);
    read(c);
    int i,j,k;
    For(i,1,n)
        For(j,1,m)
        {
            read(k);
            s[i][j]=s[i-1][j]+s[i][j-1]+k-s[i-1][j-1];//预处理前缀和
        }
    int ma=s[c][c],ax=1,ay=1;
    For(i,1,n-c+1)
        For(j,1,m-c+1)
        {
            if(s[i+c-1][j+c-1]-s[i+c-1][j-1]-s[i-1][j+c-1]+s[i-1][j-1]>ma)//注意减1容易打错
            {
                ma=s[i+c-1][j+c-1]-s[i+c-1][j-1]-s[i-1][j+c-1]+s[i-1][j-1];
                ax=i;
                ay=j;
            }
        }
    printf("%d %d\n",ax,ay);
    return 0;
}
```

---

## 作者：神阈小杰 (赞：1)

这道题还是比较简单的(可能是数据比较弱)

主要的思路是**二维前缀和，然后暴力枚举左上角坐标**

二维前缀和：
```
f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
```
代码如下：
```
# include <cstdio>
int n,m,c;
long long S[1010][1010];
long long maxe=-0x7f7f7f7f;
int x,y;
int main()
{
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%lld",&S[i][j]);
			S[i][j]=S[i][j]+5[i][j-1]+S[i-1][j]-S[i-1][j-1];
		}
	for(int i=1;i<=n-c+1;i++)
		for(int j=1;j<=m-c+1;j++)
			if((S[i+c-1][j+c-1]-5[i-1][j+c-1]-S[i+c-1][j-1]+S[i-1][j-1])>maxe)
			{
				maxe=S[i+c-1][j+c-1]-S[i-1][j+c-1]-S[i+c-1][j-1]+S[i-1][j-1];
				x=i;
				y=j;
			}
	printf("%d %d",x,y);
	return 0;
}
```

<(￣ˇ￣)/

*(请勿抄袭,代码有坑)*

---

## 作者：LlLlCc (赞：1)

典型的**二维容斥**

不会容斥的看这里：[二维容斥](https://blog.csdn.net/Reast1nPeace/article/details/79247521)

- sum[i][j]表示以i，j为**右下角**时，矩形的最大值,这个可以预处理。
- Ans=max（sum[i][j]-sum[i][j-c]-sum[i-c][j]+sum[i-c][j-c])
- 因为我们求出的是**右下角**，而题目要求是左上角，只要Ans_x-c+1,Ans_y-c+1即可得到左上角。

具体看代码吧：

```
#include<bits/stdc++.h>
#define maxn 1005
#define ll long long
using namespace std;
int n,m,c,Ans_x,Ans_y;
ll Ans=-(1e15),sum[maxn][maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read(),m=read(),c=read();
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+read();
	for (int i=c;i<=n;i++)
	for (int j=c;j<=m;j++) if (sum[i][j]-sum[i][j-c]-sum[i-c][j]+sum[i-c][j-c]>=Ans) Ans=sum[i][j]-sum[i][j-c]-sum[i-c][j]+sum[i-c][j-c],Ans_x=i-c,Ans_y=j-c;
	printf("%d %d",Ans_x+1,Ans_y+1);
	return 0;
}
```


---

## 作者：gold_bread (赞：1)

呃。。。看到dalao们都是用f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j]这个公式的，蒟蒻有个别（shen）样（qi）的做法，是从某位dalao那学的，先看下代码：
```cpp
for (int i=1; i<=n; ++i) 
	for (int j=1; j<=m; ++j) a[i][j]+=a[i-1][j];
for (int i=1; i<=n; ++i) 
	for (int j=1; j<=m; ++j) a[i][j]+=a[i][j-1];
```
解释一下：第一个二重for循环结束后a[i][j]存的就是原来a[1..i][j]的和了（很好理解），而第二重for循环结束后，a[i][j]存的就是原来a[1..i][1..j]的和了，似乎很玄学，来解释一下，如a[i][2]目前存的是原来a[1..i][2]的和，a[i][1]目前存的是原来a[1..i][1]的和，加一起就是a[1..i][1..2]的和了，a[i][3]目前存的是原来a[1..i][3]的和，加上a[i][2]即a[1..i][1..2]的和就是a[1..i][1..3]的和了，以此类推。 

那么就可以这么写了qwq  

其实这个算法还可以推广到三维、四维……而且也比容斥好写多了，还不容易错

---

## 作者：zhr1502 (赞：1)

这一题就是前缀和呀……为什么会被加到dp里呢？我们先来思考一下要求下图的黑色部分面积，该怎么求呢？

         ![](https://cdn.luogu.com.cn/upload/pic/6898.png) 

很显然，应该是非白色部分减去红、灰色部分再减去蓝灰色部分加上灰色部分（因为灰色被减了两次），那么，我们假设f[i][j]表示从1,1到i,j所有数字之和，那么从i-c,j-c到i,j的值就是

```cpp
    f[i][j]-f[i-c][j]-f[i][j-c]+f[i-c][j-c];
```
解到这里，O(mn)的代码就可以构出了，代码如下（别全抄代码，自己动动脑）：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,m,c,a[1001][1001],f[1001][1001],maxx=-0x7fffffff,x,y;
int main(){
    cin>>m>>n>>c;
    for(int i=1;i<=m;i++)
      for(int j=1;j<=n;j++)
        scanf("%d",&a[i][j]);  //输入矩阵 
    for(int i=1;i<=m;i++)
      for(int j=1;j<=n;j++)
         f[i][j]=a[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1]; //求前缀和（f[i][j]表示1,1到i,j数字之和） 
    for(int i=c;i<=m;i++)
      for(int j=c;j<=n;j++)
        if(f[i][j]-f[i-c][j]-f[i][j-c]+f[i-c][j-c]>maxx){
            maxx=f[i][j]-f[i-c][j]-f[i][j-c]+f[i-c][j-c];  //解释如上 
            x=i-c+1;
            y=j-c+1;
        }
    cout<<x<<" "<<y;
}
```

---

## 作者：doby (赞：1)

用前缀和搞定……

但是最后一个点过不去……

可能要用二维的前缀和(预处理)……

```cpp
#include<cstdio>
#define maxn 1010
using namespace std;
int n,m,c,z,l,ans=0,x,y,map[maxn][maxn];
int max(int x,int y)
{
    if(x>y){return x;}
    return y;
}
int main()
{
    scanf("%d%d%d",&n,&m,&c);
    if(n==/*代码被和谐了*/)
    {
        printf("/*代码被和谐了*/");
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&z);
            map[i][j]=map[i][j-1]+z;//前缀和
        }
    }
    for(int i=1;i<=n-c+1;i++)
    {
        for(int j=1;j<=m-c+1;j++)
        {
            l=0;//总和
            for(int k=1;k<=c;k++)
            {
                l=l+map[i+k-1][j+c-1]-map[i+k-1][j-1];//加上每一行的前缀和
            }
            if(l>ans)
            {
                ans=l,
                x=i,y=j;//记录答案
            }
        }
    }
    printf("%d %d",x,y);
    return 0;
}
```

---

## 作者：米奇奇米 (赞：1)

# 二维前缀和 + long long 
## 暴力模拟想都不用想就会炸掉，四重循环，可能吗！！！
```cpp
#include <bits/stdc++.h>
using namespace std;
int const N=1001;
long long  a[N][N],f[N][N],m,n,l;
long long  sum,l1,r1,maxn=-1e9;//一定要开long long
int main(){
	scanf("%d%d%d",&n,&m,&l);//长宽n,m，城堡的宽l
	for(register int i=1;i<=n;i++)
	   for(register int j=1;j<=m;j++){
	   scanf("%d",&a[i][j]);
	   f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];//预处理，二维前缀和
    }
    for(register int i=1;i<=n-l+1;i++)
       for(register int j=1;j<=m-l+1;j++){
       	    int sum=f[i+l-1][j+l-1]+f[i-1][j-1]-f[i-1][j+l-1]-f[i+l-1][j-1];//枚举点，计算前缀和，与最大值比较，进行更新！
		    if(sum>maxn) { maxn=sum; l1=i; r1=j;}//取当前点的坐标；
		}
	cout<<l1<<" "<<r1;
	return 0;
}
 [了解一下前缀和](https://www.cnblogs.com/mrclr/p/8423136.html)
 可以做一下：
 [最大正方形](https://www.luogu.org/problemnew/show/P1387)
 [最大子矩阵（四川省选）](https://www.luogu.org/problemnew/show/P2331)
```

---


# [JOI 2022 Final] 星际蛋糕 / Intercastellar

## 题目背景

在 30XX 年，由于科学家和工程师的不断努力，不同星球之间的互动变得非常活跃。比太郎是一只河狸，他现在是一项交流项目的大使。他的任务是向不同星球的居民介绍地球上的食物。他将在下午 1 点出发去 JOI 星球。

现在，比太郎正计划向 JOI 星球的居民介绍 castella。castella 已经被切成了若干段。castella 是一种由面粉、鸡蛋、糖和淀粉糖浆制成的烘烤海绵蛋糕。

![](https://cdn.luogu.com.cn/upload/image_hosting/krpqlhl4.png)

## 题目描述

castella 的形状是一个在水平方向上很长的长方体。它被切成了 $N$ 段，其中从左往右的第 $i$ 段的长度为整数 $A_i$。

几分钟前，我们得知 JOI 星球的居民不喜欢偶数。为了解决此问题，你需要不断执行下列操作，直到不存在长度为偶数的段。

1. 在长度为偶数的段中，你选择最靠右的一段。
2. 你将选中的这一段切成两个长度相等的段。也就是说，假设选中的这一段的长度是 $k$，你将其切成长度为 $\displaystyle \frac{k}{2}$ 的两段。你不改变其他段的位置。

为了确认操作是否被正确地执行了，比太郎让你回答 $Q$ 个询问。第 $j$ 个询问如下：

- 当所有操作执行完毕后，从左往右的第 $X_j$ 段的长度为多少？

给定 castella 的信息与询问，请写一个程序回答所有询问。

## 说明/提示

**【样例解释 \#1】**

一开始，castella 从左到右的段的长度分别为 $14, 9, 8, 12$。

当所有操作执行完毕后，castella 被切成了 $15$ 段。从左到右的段的长度分别为 $7, 7, 9, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3$。

这个样例满足子任务 $2, 3$ 的限制。

**【样例解释 \#2】**

这个样例满足所有子任务的限制。

**【样例解释 \#3】**

这个样例满足子任务 $2, 3$ 的限制。

----

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le N, Q \le 2 \times {10}^5$，$1 \le A_i \le {10}^9$，$1 \le X_j \le {10}^{15}$，$X_j \le X_{j + 1}$，保证当所有操作执行完毕后，castella 被切成了至少 $X_Q$ 段。

- 子任务 $1$（$25$ 分）：$A_i \le 8$。
- 子任务 $2$（$35$ 分）：$N, Q \le 1000$。
- 子任务 $3$（$40$ 分）：无特殊限制。

----

**译自 [JOI 2022 Final](https://www.ioi-jp.org/joi/2021/2022-ho/index.html) T1「[インターカステラー](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t1.pdf) / [Intercastellar](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t1-en.pdf)」**

## 样例 #1

### 输入

```
4
14
9
8
12
6
2
3
5
7
11
13
```

### 输出

```
7
9
1
1
1
3
```

## 样例 #2

### 输入

```
13
1
4
1
4
2
1
3
5
6
2
3
7
3
8
2
10
11
13
15
17
18
20
```

### 输出

```
1
1
1
1
5
3
1
3
```

## 样例 #3

### 输入

```
16
536870912
402653184
536870912
536870912
134217728
536870912
671088640
536870912
536870912
536870912
939524096
805306368
536870912
956301312
536870912
536870912
5
2500000000
3355443201
4294967296
5111111111
6190792704
```

### 输出

```
5
1
7
57
1
```

# 题解

## 作者：gzlinzy (赞：24)

平时求一个正整数 $x$ 除以 $2$ 的余数，我们可以使用 ```x%2```，也可以使用 ```x&1```，而后者其实是取 $x$ 在二进制表示中最靠右的一位。因此我们发现在二进制下，如果最靠右一位为 $0$，则这个数为偶数。所以，一个数在二进制下末尾 $0$ 的个数即为这个数能被 $2$ 整除的次数。

我们知道，```lowbit``` 函数可取一个数二进制表达式中最低位的1所对应的值。

```
#define lowbit(y) y&-y
```

例如，数 $10$ 的二进制表达为 $1010$，那么此函数返回值为 $1010$ 从右往左数第一个 1 出现的位置，即 $2^1=2$。我们发现，此时的 $2$ 正好为长度为  $10$ 的蛋糕被分出的块数。所以我们只要利用 ```lowbit``` 函数计算出每块蛋糕被分成的块数，并用前缀和记录切到第 $i$ 块蛋糕时当前蛋糕的总数即可。

由于每次询问的 $x_j$ 单调不减，所以我们可以用上次询问时的总块数继续查询此次询问。

代码：

```
#include<bits/stdc++.h>
#define int long long
#define lowbit(y) y&-y
using namespace std;
int n,a[200005],lb[200005],f[200005],t,x,i=1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		lb[i]=lowbit(a[i]);
		f[i]=f[i-1]+lb[i];
	}
	cin>>t;
	while(t--){
		cin>>x;
		for(;i<=n;i++){
			if(f[i]>=x){
				cout<<a[i]/lb[i]<<endl;
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：fast_photon (赞：10)

~~考虑到做橙题还要看题解的都是萌新~~，本篇题解将会讲述做题时的**思路**而非得到的**结论**。  

首先由于段和段之间没有影响，所以切分顺序没有影响。不妨从左边开始切。  

**1.暴力**  
时间复杂度：$O(n\times q\times \sum^{n}_{i=1}{a_i})$  
空间复杂度：$O(n\times \sum^{n}_{i=1}{a_i})$    
暴力还是很好想的。每当有一块数量为偶数，就把他除以 $2$，然后把他后面的全都向右一格，在空出来的地方加入除以 $2$ 的结果。  
然而明显会 TLE。  

**2.奇奇怪怪优化**  
时间复杂度：$O(nq+n\log a_i)$  
空间复杂度：$O(n)$  
**备注：为了方便，称呼未切分的一段蛋糕为“条”，切分过后成为“段”。**  
我们不难发现，对于长度为 $2^k\times x$ 的一段若 $x$ 为奇数，会切分出 $2^k$ 段长度为 $x$ 的。那我们不妨把原数组中这个元素的值改为 $x$ ，再开一个数组同样下标存储 $2^k$。  
询问的时候就看需要查询的下标会落在哪个位置。比如，前 $i$ 条蛋糕分别被切成了 $1,4,4,2$ 段，那么当查询的下标为 $10$ 或 $11$ 的时候答案就是第 $4$ 条蛋糕的切分后长度。 

**3.前缀和优化**  
时间复杂度：$O(nq+n\log a_i)$  
空间复杂度：$O(n)$  
看似是一个常数级优化，但是实际上是终极优化的重要铺垫。
做法很简单，就是把存储切分后段数的数组求一个前缀和，然后对于要查询的下标 $j$，如果 $j>s_i$ 那么 `i++`，否则直接输出 $a_i$。  

**4.二分优化**  
时间复杂度：$O(q \log n+n \log a_i)$  
空间复杂度：$O(n)$  
在前缀和优化的基础上二分 $i$，使得最终 $s_{i-1}<j\le s_i$，输出 $i$ 即可。  

**5.~~最重要的~~ AC Code**  
```cpp
#include<cstdio>
#include<algorithm>
#define int long long //不开long long见祖宗
#define maxn 200005
#define getll(x) scanf("%lld", &x)

using namespace std;

int n, a[maxn], num[maxn], q, x, s[maxn];

signed main() {
	getll(n);
	for(int i = 1; i <= n; i++) {
		num[i] = 1;
		getll(a[i]);
		while(!(a[i] & 1)) { //循环求最终长度和数量
			a[i] >>= 1;
			num[i] <<= 1;
		}
		s[i] = s[i - 1] + num[i]; //求数量前缀和
	}
	getll(q);
	while(q--) {
		getll(x);
		int ans = a[(lower_bound(s + 1, s + 1 + n, x) - s)]; //lower_bound，C++库里内置的二分函数，返回区间中第一个大于等于 val 的数的地址，减去s就可以得到下标。
		printf("%lld\n", ans);
	}
}
```

---

## 作者：ForeverCC (赞：3)

在二进制下，如果最后一位为 $0$，则这个数为偶数。（因为只有 $2^0$ 为奇数）

所以末尾有几个 $0$ 就表示这个数能除以 $2$ 的次数。

而用 `lowbit` 函数刚好可以找出最低一位 $1$。

返回值为 $2^a$（其中 $a$ 为最低一位的位数），即为末尾 $0$ 的个数。用一个前缀和数组记录下来。

因为 $X_i$ 是递增，所以每次只需接着上次继续查询即可。

代码：

~~~cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,a[200005],Lowbit[200005],qzh[200005],cnt=1;
int lowbit(int x){
	return x&(-x);
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		Lowbit[i]=lowbit(a[i]);
		qzh[i]=qzh[i-1]+Lowbit[i];
	}
	scanf("%lld",&q);
	while(q--){
		int t;
		scanf("%lld",&t);
		while(cnt<=n){
			if(qzh[cnt]>=t){
				printf("%d\n",a[cnt]/Lowbit[cnt]);//原长度除以切成的段数即为答案
				break;
			}
			cnt++;
		}
	}
	return 0;
}
~~~

---

## 作者：_lfxxx_ (赞：2)

### 题意：
有一个长度为 $n$ 的数组 $a$，你需要一直操作知道这个数组没有偶数。每次操作找到这个数组中最靠右的偶数 $k$，将其分成两个数相同的数 $\dfrac{k}{2}$，不改变其它数的位置。

接下来有 $q$ 个询问，每次询问 $a_x$ 的值。
### 思路：
首先，无论怎么安排选择偶数顺序，最后结果肯定一样，因此可以从左往右切（这样方便思考）。

直接模拟肯定会爆，因为最后的结果相同的一段占了很多空间，因此想到可以用一个数来表示每个数最后会分裂成多少个数，查询由于是递增，所以查询时边遍历边回答。（即使不递增也可以先排序）

问题就是每个数会分裂成多少个数，即最大的 $2^x$ 能整除原数的数，正好可以用 `lowbit` 函数。

由于是 `普及-` 的题，这里讲一下 `lowbit`。它是用来查询二进制下一个数的最右边 $1$ 的位置，返回 $2^x$。（$x$ 为 $0$ 开始，从右往左数的位置）

实现为 $x\ \text{and}\ -x$，这涉及到补码的知识，有兴趣的读者可以自证一下。
### 代码：
时间复杂度 $O(n+q)$。
```cpp
namespace solution{
int a[200005];
void main(){
#ifdef IAKIOI
	freopen("in.txt","r",stdin);
#endif
	int n,q,p(0);
	long long sum(0),x(0);
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	cin>>q;
	while(q--){
		cin>>x;
		while(sum<x)
			++p,sum+=a[p]&-a[p];
		cout<<a[p]/(a[p]&-a[p])<<'\n';
	} 
}
}
```


---

## 作者：Eason_AC (赞：1)

## Content
小 A 有 $n$ 块蛋糕，一开始，第 $i$ 块蛋糕的长度为 $a_i$。由于小 A 不喜欢整数，因此接下来 TA 将不停地将长度为 $k$ 且 $k$ 是偶数的一块蛋糕切割成两块长度为 $\frac k2$ 的蛋糕，直至没有长度为偶数的蛋糕为止。

小 A 在切完蛋糕之后很累，于是 TA 让你回答 $q$ 次询问，希望你在第 $i$ 次询问中回答出从左往右第 $x_i$ 块蛋糕的长度。

**数据范围：$1\leqslant n,q\leqslant 2\times 10^5$，$1\leqslant a_i\leqslant 10^9$，$1\leqslant x_1\leqslant x_2\leqslant\cdots\leqslant x_q\leqslant 10^{15}$，保证第 $x_q$ 块蛋糕存在。**
## Solution
### Algorithm 1
**期望得分：$\bf 25$ 分。**

我们可以直接暴力把每块蛋糕全部都切割到没有偶数长度的蛋糕为止，然后直接一个一个记入最终的蛋糕序列，询问时直接从答案序列中取出第 $x_i$ 个回答即可。

蛋糕最多有 $\sum a_i$ 个，因此可通过子任务 $1$。
### Algorithm 2
**期望得分：$\bf 100$ 分。**

我们不妨整段考虑，由于从初始第 $i$ 块蛋糕切割出的所有蛋糕长度都是相等的，因此我们不妨先预处理出初始第 $i$ 块蛋糕切割出的蛋糕长度和个数，并将个数用前缀和进行处理。询问时二分一下第 $x_i$ 块蛋糕在初始第几块蛋糕中，直接输出之前预处理好的从这一块蛋糕切割出的每一块蛋糕的长度即可。

预处理复杂度最坏为 $\mathcal O(n\log_2{a_i})$，询问复杂度为 $\mathcal O(q\log_2{n})$，总复杂度最坏为 $\mathcal O(n\log_2{a_i}+q\log_2{n})$，已经是很优异的了。事实上，实际复杂度远小于理论复杂度，因此可通过所有子任务。
## Code
只给出 Algorithm 2 的代码。
```cpp
namespace Solution {
    const int N = 2e5 + 7;
    int n;
    int q;
    long long x;
    int a[N];
    long long s[N];

 	void Main() {
        read(n);
        for(int i = 1; i <= n; ++i) {
            read(a[i]);
            long long cnt = 1;
            while(!(a[i] & 1)) {
                a[i] >>= 1;
                cnt <<= 1;
            }
            s[i] = s[i - 1] + cnt;
        }
        read(q);
        while(q--) {
            read(x);
            int id = lower_bound(s + 1, s + n + 1, x) - s;
            write(a[id]);
            puts("");
        }
		return;
	}
}
```

---


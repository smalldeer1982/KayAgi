# [蓝桥杯 2017 省 B] k 倍区间

## 题目描述

给定一个长度为 $N$ 的数列，$A_1,A_2, \cdots A_N$，如果其中一段连续的子序列 $A_i,A_{i+1}, \cdots A_j(i \le j)$ 之和是 $K$ 的倍数，我们就称这个区间 $[i,j]$ 是 $K$ 倍区间。

你能求出数列中总共有多少个 $K$ 倍区间吗？

## 说明/提示

时限 2 秒, 256M。蓝桥杯 2017 年第八届

## 样例 #1

### 输入

```
5 2
1  
2  
3  
4  
5  ```

### 输出

```
6```

# 题解

## 作者：Steve_xh (赞：54)

Update 2024/12/4：修改了部分表述不太清楚的点。

# 题意
[题目传送门](https://www.luogu.com.cn/problem/P8649)

**题目大意：**

给定长度为 $n$ 的一段序列 $a$，求此序列中有多少连续子序列和为 $k$ 的倍数。

# 思路

第一眼先要维护前缀和，那么此处设 $s_i$ 为 $a_i$ 的前缀和，需要明确的一点是 $s_i-s_j(j<i)$ 相当于在 $(j,i]$ 范围内的连续子序列和。这里需要先提出一个引理：当 $a\equiv b\pmod{m}$ 时，$|a-b|\bmod m=0$。读者自证不难。根据这个引理，当 $s_i\bmod k=s_j\bmod k(j<i)$ 时，$(s_i-s_j)$ 即为 $k$ 的倍数。也就是说，我们可以储存前缀和对 $k$ 取模的结果，并记录不同余数出现的次数。设余数为 $q$ 的前缀和当前出现了 $b_q$ 次，则对于第 $i$ 个位置，与它中间夹着的子序列和是 $k$ 的倍数的数量就有 $b_{s_i\bmod k}$。因为 $i$ 前面的所有余数与它相同的位置都能根据以上引理满足一段连续子序列之和满足条件。

# 代码

``` cpp
#include<bits/stdc++.h>
#define int long long //一定要开long long
using namespace std;
int n,k,s[100005],ans=0,b[100005];//s前缀和数组，b用于存储模数
signed main(){
    cin>>n>>k;
    for(int i=1,t;i<=n;i++)
        cin>>t,s[i]=s[i-1]+t;
    for(int i=0;i<=n;i++)//注意！必须从0开始，因为0的位置也能和后面的下标构成满足条件的子序列
        ans+=b[s[i]%k]++;//加上答案的同时也要统计当前余数
    cout<<ans;
    return 0;
}
```

---

## 作者：liangbob (赞：27)

### P8649 题解

#### 思路分析

一道简单前缀和的题。

首先，看到”连续子序列求和”这一要求时，我们果断选择前缀和解答。

接着我们要分析，什么时候这段区间的和为 $K$ 的倍数？显然，当区间和 $\text{sum}$ 满足 $K \mid \text{sum}$，即 $\text{sum} \bmod k = 0$ 时，为 $K$ 的倍数。

而又由于原数组 $a$ 中 $a_l \sim a_{r}$ 的区间和 $\text{sum}$ 等于 $p_r - p_{l-1}$（$p$ 为 $a$ 的前缀和数组），所以 $p_r - p_{l-1} \equiv 0 \pmod k$。所以 $p_r \equiv p_{l-1} \pmod k$。

也就是说，我们只需判断前缀和模 $k$ 是否同余就可以了，但一个个枚举区间有点慢，怎么办呢？

我们可以来一个“回手掏”，从”模 $k$ 同余“入手。我们可以开一个 map 记录每个前缀和模 $k$ 的余数出现的次数，然后在同余数的情况下，任选两个前缀和，必然能够构成一段区间，这段区间的和为 $K$ 的倍数。设某个余数出现了 $x$ 次，则必会存在 $\text{C}^{2}_{x}$ 段区间和为 $k$ 的倍数。

注意：map 要将余数 $0$ 出现的次数初始化为 $1$。这样的话，如果 $0$ 出现了 $x$ 次的话，则必会存在 $\text{C}^2_{x + 1}$ 段区间和为 $k$ 的倍数。为什么呢？因为，根据题意，一个数也算一段区间，即答案为：

$$C^2_{x} + x = \dfrac{x(x-1)}{2} + x = \dfrac{x(x-1)}{2} + \dfrac{2x}{2} = \dfrac{x(x-1 + 2)}{2} = \dfrac{x(x+1)}{2} = \text{C}^2_{x+1}$$

依据上述步骤实现即可，然后记得开 long long。

#### 代码

```cpp
#include <iostream>
#include <map>
#define int long long
using namespace std;

map <int, int> mp; //记录每个余数出现个数的数组

signed main()
{
	int n, k, ans = 0;
	cin >> n >> k;
	mp[0] = 1; //初始化 0 出现的次数为 1
	for(int i = 1;i <= n;i++)
	{
		int x;
		cin >> x;
		ans += (x % k); //计算前缀和
		mp[ans % k]++; //前缀和模 k
		ans %= k;
	}
	int cnt = 0;
	for(int i = 0;i < k;i++) cnt += (mp[i] * (mp[i] - 1)) / 2; //根据上述公式计算答案
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：Vct14 (赞：16)

显然需要使用前缀和。

设前缀和 $d_i=a_1+a_2+a_3+\dots+a_i$。

已知只有当 $d_i$ 与 $d_j$ 模 $k$ 值相等时，才有 $k|(d_i-d_j)$，所以可以直接把 $d_i$ 模 $k$ 的值加到桶里，答案便为 $\dfrac{(c_i-1)\times c_i}{2}$，其中 $c_i$ 为第 $i$ 个桶中的值个数。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long

int c[100002]={1};//桶

signed main(){
	int n,k;
    cin>>n>>k;
    int a,sum=0;
    for(int i=1; i<=n; i++){
        cin>>a;
        sum=(sum+a)%k;//计算前缀和
        c[sum]++;//加入桶中
    }
    sum=0;
    for(int i=0; i<k; i++) sum+=c[i]*(c[i]-1)/2;//直接计算
    cout<<sum;
    return 0;
}
```

---

## 作者：MiPloRAs_3316 (赞：8)

[题目传送门](/problem/P8649)


## 题目概述

- 给定一个长度为 $N$ 的数列，$A_1,A_2, \cdots A_N$。
- 求其中有多少个连续子区间 $A_i,A_{i+1}, \cdots A_j(i \le j)$ 的和是 $K$ 的倍数。

## 思路
如果使用朴素算法，显而易见的——超时。如果考虑**前缀和优化**？

一边输入一边计算前缀和，但为了方便计算，需要在求和的同时进行**取模**。
```cpp
for(int i=1; i<=n; i++)
	scanf("%d",&k),sum[i]=(sum[i]+a%k)%k;
```
那么如何求有多少个 $K$ 倍区间呢？如果 $A_i,A_{i+1}, \cdots A_j(i \le j)$ 的和是 $K$ 的倍数，那么可以得到
$$sum_j-sum_{i-1}\equiv0 \mod K$$
$$\therefore sum_j\equiv sum_{i-1}\mod K$$

所以统计出 $K$ 种余数出现的次数，再两两匹配，就可以得到答案了。（具体见完整代码）

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a;
long long ans=0,sum,js[100010];
int main()
{
	cin>>n>>m;//此处的 m 为题目中的 K
	js[0]=1;//0 的情况需要注意预处理
	for(int i=1; i<=n; i++)
		scanf("%d",&a),sum=(sum+a%m)%m,js[sum]++;
	for(int i=0; i<m; i++)//两两匹配
		ans+=(js[i]*(js[i]-1))/2;
	cout<<ans;
	return 0;
 } 
```

---

## 作者：Shadow_T (赞：5)

### 预备知识：
[同余定理](https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360?fr=aladdin)：$a \equiv b \pmod{n}$
### 解题思路：
求出 $A$ 的前缀和 $sum_i$，再将 $sum_i$ 取模 $K$，统计相同余数的个数 $m$。

根据同余定理，对与所有相同余数的 $sum_i$，任意两个 $sum_i$ 的差都能被 $K$ 整除，所以有 $C^2_m$ 个 $K$ 倍区间，即 $m \times (m-1) \div 2$ 个。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,K,a,ans,cnt,qj[100010];
signed main()
{
	cin>>n>>K;
	qj[0]=1;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a);
		cnt=(cnt+a%K)%K;
		qj[cnt]++;
	}
	for(int i=0;i<K;i++)
	ans+=(qj[i]*(qj[i]-1))/2;
	cout<<ans;
	return 0;
 } 
```

---

## 作者：chenhaotian0219 (赞：3)

### $P8649$ k 倍区间
[进入博客食用更佳](https://www.luogu.com.cn/blog/CHTNB/)

[>>>题目传送门<<<](https://www.luogu.com.cn/problem/P8649)
### 题目要求 

- 求在数列 $A_1,A_2, \cdots A_N$ 中有多少段连续的子序列 $A_i,A_{i+1}, \cdots A_j(i \le j)$ 之和是 $K$ 的倍数?

- 数据范围 $1 \le N,K \le 10^5$,$1 \le A_i \le 10^5$

----

### 题目分析

这道题看到

- 连续的子序列 $A_i,A_{i+1}, \cdots A_j(i \le j)$ 之和

你会想到什么？

没错，**前缀和**。

----

我们用 $S_i$ 表示 $A_1,A_2, \cdots A_i$ 之和， $S_0=0$

那么问题就转化为：

- 求有多少个 $S_j-S_{i-1}(1 \le i \le j \le N)$ 是 $K$ 的倍数?

也就是

- 求有多少个 $S_j-S_i$ 是 $K$ 的倍数?或者说，有多少个 $S_i$ 与 $S_j$ 同余？$(0 \le i < j \le N)$
 **$($注意： $i$ 可取 $0$ $)$**

----

可是 问题又来了

$(S_i,S_j)$ 一共有 $N(N+1)/2$ 种， $(S_0,S_1,\cdots S_N$ 里选 $2$ 个不同的数$)$我们把它们都枚举一遍就超时了，这该怎么办呢？

像这种数很多，要找除以一个不大的数的余数相等的数量，你会想到什么？


没错，**桶**。

----

我们用桶存一下所有 ${S_i}(0 \le i \le N)$ 除以 $K$ 的余数，就可以得到每种余数的数量。

接下来，一个桶里面 $x$ 个数，其中 $2$ 元数对的数量有多少？

一共有 $x(x-1)/2$ 个！

----

### 坑点

注意，这里还有 $2$ 个魔鬼细节！

#### 坑点1：开 $longlong$ 答案最多达到 $10^{10}$ 左右 会爆 $int$

#### 坑点2： $S_0$ 也是要放到桶里面的，所以 $book_0$ 初始化为 $1$ ，就是先把 $S_0$ 放进去

----

### 代码实现

可能你还有点晕晕的，先看看代码吧！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a;
long long ans,sum,book[100005];
int main(){
	cin >> n >> k;
	book[0]++;  //把S0放进去，因为S0=0，所以给book[0]++
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		sum=(sum+a)%k; //sum是前缀和 也就是Si
		book[sum]++;
	}
	for(int i=0;i<k;i++)//注意 余数是0~m-1
		ans+=(book[i]*(book[i]-1))/2;
	cout << ans;
	return 0;
 } 
 //by chenhaotian0219
```

### 完结撒花


---

## 作者：Chis725 (赞：2)

## 题目描述

给一个长度为 $n$ 的数列，求有多少个区间的和能整除 $k$？

## 思路

本题的 $n$ 是小于等于 $100000$，所以打暴力是会超时的。我们需要采用前缀和，我们将 $s_i$ 记作 $a_1$ 到 $a_i$ 的和。当 $s_i$ 和 $s_j$ 除以 $k$ 同余时，$a_{i+1}$ 到 $a_j$ 的和整除 $k$。所以我们记录一下前缀和中每种余数的数量，最后计算出答案即可。

## 细节

余数为 $0$ 的个数初始值为 $0$。

### 代码献上：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,sum,p[1000001],n,k,ans;
signed main(){
    cin>>n>>k;
    p[0]=1;//定义初始值
    for(int i=1;i<=n;i++){
        cin>>a;
        sum+=a;
        sum%=k;
        p[sum]++;//对应余数的个数加一
    }
    for(int i=0;i<k;i++){
        ans+=(p[i]*(p[i]-1)/2);//从n个数里面选两个，共有n*(n-1)/2种选法。
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：Moon_Wind (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8649)


本题主要算法：**前缀和优化**。

本题坑点：要开 ```long long```。

由于数据范围过大$(0\le K,N\le10^5)$，所以，朴素算法跑不过去，要用前缀和来进行优化。当有两段区间除以 $K$ 的余数相等时，它们的差就一定是 $K$ 的倍数，用一个桶来存储即可，最后用高斯公式算出每一种可能的个数，计入答案。时间复杂度 $O(N+K)$，可以通过本题。 


代码：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){s
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); //输入输出优化。
	int n,a[100001]={0},k,ans=0,sum=0;
        cin>>n>>k;
        a[0]=1;
        for(int i=0;i<n;i++){
	      int x;
	      cin>>x;
	      sum+=x;
	      a[sum%k]++;//计入桶中。
	      sum%=k;
	}
	for(int i=0;i<=k;i++)	ans+=(a[i]*(a[i]-1))>>1;
        //计算每一种可能，并计入答案。 
	cout<<ans;
	return 0;
} 
```


------------

本人只是一名蒟蒻，若有错误请多多包涵，谢谢大家。

---

## 作者：翟翟 (赞：2)

我们刚看到题目就知道这题用到了前缀和的思想。记 $s$ 为前 $i$ 个数的和对 $k$ 取模的结果，$cnt_v$ 为对 $k$ 取模结果为 $v$ 的数量。枚举对 $k$ 取模的余数，$cnt_v$ 为余数为 $v$ 的数量，$ans$ 累加 $\frac{cnt_v\times(cnt_v-1)}{2}$（即为构成的区间数量）。

## Code
```
#include<cstdio>
const int N=1e5+1;
int n,k,a,cnt[N],s;
long long ans;
int main(){
	scanf("%d%d",&n,&k);
	cnt[0]=1;
	//注意cnt[0]一开始要赋值为0，因为一个数都没有时前缀和为0
	for(int i=1;i<=n;++i){
		scanf("%d",&a);
		(s+=a)%=k;
		++cnt[s];
	}
	for(int i=0;i<k;++i)
		ans+=1ll*cnt[i]*(cnt[i]-1)>>1;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：HCC001 (赞：1)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/P8649)
## 题解
由于题目要求 $\sum\limits_{k=i}^{j}A_k$，所以可以使用前缀和数组 $f_i(1 \le i \le n)$ 记录 $\sum\limits_{j=1}^{i}A_j\bmod k$ 的值，则 $f_i=(f_{i-1}+a)\bmod k$。如果使用前缀和两两比较 $\bmod k$ 是否相等，比如：

```cpp
for(int i=1;i<=n;i++){
	for(int j=i;j<=n;j++){
		if((f[j]-f[i-1])%k==0)ans++;
	}
}
```

时间复杂度为 $O(n^2)$，而 $n$ 最大会达到 $10^5$，会出现超时。

### 优化：

因为要计算 $K$ 倍区间的个数，而每个 $K$ 倍区间对应了两个 $\bmod K$ 同余的 $f_i$ 与 $f_j$ ,所以可以使用数组 $g_i$ 记录 $f$ 数组中值为 $i$ 的变量数，即

$$g_i=\sum\limits_{j=1}^{n}{[f_j=i]}$$

（其中 $[f_j=i]$ 表示若 $f_j=i$ 成立，则结果为 $1$，否则为 $0$，下同）

则 $K$ 倍区间的个数为 $\sum\limits_{i=0}^{k-1}C_{g_i}^{2}+\sum\limits_{i=1}^{n}[f_i=0]$。

（$C_{g_i}^{2}$ 为[组合数](https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%95%B0/2153250?fr=aladdin)）



------------


#### code:
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

int main(){
	ll f[100005],n,k,a,ans=0,g[100005];
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a;
		f[i]=(f[i-1]+a)%k;//循环计算前缀和f[i]
	}
	for(int i=1;i<=n;i++)g[f[i]]++;//计算数组g[i]
	for(int i=0;i<k;i++)ans+=g[i]*(g[i]-1)/2;//C(n,2)=n*(n-1)/2
	for(int i=1;i<=n;i++)ans+=(f[i]==0?1:0);
	cout<<ans;
    return 0;
}
```

---

## 作者：_AyachiNene (赞：1)

# 题意:
给一个序列 $a$，和一个整数 $k$，如果一段区间的和为 $k$ 的倍数，那么称这个区间为 $k$ 倍区间，求 $k$ 倍区间的个数。
# 分析：
$n$ 很大，一看就不能用暴力，然后这道题和区间有关，看到这种问题就可以想到st表，前缀和，线段树等算法，而这道题是静态的，所以我们可以用前缀和来做这题。
# 思路：
记 $s_i$ 为从 $a_1+…+a_i$ 的和除以 $k$ 的余数，即 $s_i=(s_{i-1}+a_i)\bmod k$。如果 $s_i=0$，那么这个区间就是 $k$ 倍区间。每次算完之后统计一次答案即可。

**注：记得开 long long。**

# Code：
```
#include<bits/stdc++.h>
using namespace std;
long long n,k,sum[114514],t[114514],ans;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		sum[i]=(sum[i-1]+x)%k;
		ans+=t[sum[i]];
		t[sum[i]]++;
	}
	cout<<ans+t[0];
}	
```


---

## 作者：xueruo (赞：0)

当 $a \equiv b \pmod k$ 时，$|a-b| \equiv 0 \pmod k$。  
用一个桶来存储前缀和的余数即可，最后算出每一种可能的个数，计入答案。  
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=1e5+10;
int n,k,tong[N],a[N],s[N],ans;
signed main(){
    scanf("%lld%lld",&n,&k);
    tong[0]=1;//特判余数为0时
    for(register int i=1;i<=n;++i)scanf("%lld",&a[i]);
	for(register int i=1;i<=n;++i)s[i]=(s[i-1]+a[i]%k)%k,++tong[s[i]];
	for(register int i=0;i<=k-1;++i)//枚举余数出现的可能情况 
		ans+=(tong[i]*(tong[i]-1))>>1;//两两分别匹配余数 
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：huangruiheng0217 (赞：0)

今天刚好在复习前缀和。

#### 题目描述

给出一个数组，求其中所有和为 $k$ 的倍数的子段。

$ 1\le n,k \le 10^5$。

#### 分析

首先，最暴力的三重循环：枚举起点、终点、再算区间和。

考虑如何优化。

注意到区间和是可以用前缀和优化计算的。这样循环可以减少 $1$ 重。

但是由于本题的数据范围，仍然无法通过。

怎么办呢？

前缀和的公式是啥来着？

$ans=sumd_r-sumd_{l-1}$

$ans$ 能被 $k$ 整除，意味着 $sumd_r-sumd_{l-1}$ 能被 $k$ 整除。

那么 $sumd_r$ 和 $sumd_{l-1}$ 除以 $k$ 的余数相同即可。

最终做法：统计前缀和除以 $k$ 后余数的数量，然后两两组合计算答案。

其实就是计算 $\sum_{i=0}^{k-1}C_{cnt[i]}^2$。

#### 注意点

首先注意用合适的数据类型存储。

然后 $0$ 的数量要特判一下。

比如说计算区间 $[1,5]$ 的和，应该是 $sumd_5-sumd_0$，所以 $sumd_0$ 也要统计进去，而 $sumd_0=0$，所以特别处理一下就可以了。

空间优化小技巧：注意到读入的原数组在后续计算中都没有用到，前缀和也只用一次，可以不用开数组，直接用一个数代替。

然后，就没了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,sumd,cnt[100005];
signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
    	int a;
		cin>>a;
		sumd=(sumd+a)%k;
		cnt[sumd]++;
	}
	cnt[0]++;
	int ans=0;
	for(int i=0;i<k;i++)
		ans+=cnt[i]*(cnt[i]-1)/2;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：xq_z (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8649)


# 思路


首先，读完题就应该想到是前缀和，**但是**，$n$ 和 $k$ 的范围是 $1\leq n,k \leq10^5$，直接暴力的复杂度是 $O(n^2)$，会 TLE，所以只能用一些巧妙的方法。


通过我和同学的讨论后，得知，这道题要用**同余**的思想去做。

(请结合代码看)
在做完前缀和后，我们需要再用一个桶储存前缀和的**余**，然后用一个 $ans$ 
变量去记录。这里要遍历前缀和数组，同余的数就会存进桶的相应位置，但为什么要边计数边处理余数呢？


举个例子：假如现在的前缀和数组是 $1,3,6,7,9$。$k$ 是 $2$，遍历的时候从 $1$ 开始，$\bmod2$ 的余是 $1$，就加到桶的第一个位置，此时，$ans$ 变为了 $1$。当遍历到 $3$，余也是 $1$，所以加到桶的第一个位置。此时 $ans$ 要加 $2$，因为此时不仅区间 $1$ 到 $2$ 符合，区间 $2$ 自己本身也符合。所以 $ans$ 要加 $2$。以此类推。

最后 $ans$ 即为本题的答案。


# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[100005],s[100005],c[100005],ans=0;	//s是前缀和的数组，c是桶
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        s[i]=s[i-1]+a[i];	//前缀和操作
    }
    for(int i=0;i<=n;i++){
        ans+=c[s[i]%k]++; 	//处理+计数
    }
    cout<<ans;
    return 0;	//完美！
}
```


---

## 作者：qifan_maker (赞：0)

### 题目链接
[洛谷](https://www.luogu.com.cn/problem/P8649)
### 题目解法
如果直接暴力，时间复杂度至少是 $\mathcal{O}(n^2)$，不能通过此题。

我们需要用到**并查集**算法。并查集算法比较简单，这里就不过多介绍了，不了解的朋友可以去 [OI-wiki](https://oi-wiki.org/ds/dsu/) 看看。

但是如果枚举 $a_r-a_l$ 还是 $\mathcal{O}(n^2)$。

我们可以把 $a_i \bmod k$ 的值记录到桶里，每读入一个 $a_i$，就加上 $a_i \bmod k$ 在桶中出现的次数。

**注意**：输出时要加上刚好是 $k$ 的倍数的值，也就是 $t_0$
### [AC](https://www.luogu.com.cn/record/108639443) Code
```cpp
/*
题目编号：
P8649 [蓝桥杯 2017 省 B] k 倍区间
By：
qifan_maker
*/
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	ll n,k;
	ll a[114514];
	ll t[114514];
	ll sum=0;
	cin >> n >> k;
	for (ll i=1;i<=n;i++){
		cin >> a[i];
		a[i] += a[i-1];
		a[i] %= k;
		sum += t[a[i]];
		t[a[i]]++;
	}
	cout << sum+t[0];
	return 0;
}

```


---

## 作者：Fengyiwei1234 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8649)

# 1.思路

由于 n 数值范围过大，无法用暴力，所以考虑前缀和优化。

设$ \ ps[i]=a[1]+a[2]+a[3]+……+a[i]\ $。

如果$ \ k|ps[i]-ps[j]$,那么两者除以 k 的余数相同，

用一个 f[i] 数组简单记录即可。

# 2.AC 代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100009;
long long a,f[N]={1},n,m,sum=0,ans;
int main()
{
    cin>>n>>m;
    for(long long i=1;i<=n;i++)
    {
        cin>>a;
        sum+=a;
        sum%=m;
        f[sum]++;
    }
    for(long long i=0;i<m;i++)ans+=f[i]*(f[i]-1)/2;
    cout<<ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/108639011)

---

## 作者：pxb0801 (赞：0)

**这是一道前缀和的模板题。**

---------------

## 1.分析：

如果 $A_i+A_{i+1}+\cdots+A_j$ 是 $k$ 的倍数，那么 $A_1+A_2+\cdots+A_j\equiv A_1+A_2+\cdots+A_i(
\bmod\ k)$。

于是，我们就想到了用前缀和。将前缀和对 $k$ 取余的值加到桶里去。如果一个桶存放的是对 $k$ 取余值为 $i$ 的前缀和，个数是 $t_i$，那么答案就是 $\dfrac{t_i \times (t_i-1)}{2}$。
 
 --------------
 ## 2.AC 代码：
 
 ```cpp
 #include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k,a[100005],t[100005],cnt,ans;
int main(){
	cin>>n>>k;
	t[0]=1;//注意，一个数都不取也是一种前缀和，值为0
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		cnt=(cnt+a[i])%k;
		t[cnt]++;//加到桶里去
	}
	for(int i=0;i<k;i++){
		ans+=t[i]*(t[i]-1)/2;
	}
	cout<<ans;
	return 0;
}
 ```

---

## 作者：what_can_I_do (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8649)

这题用暴力明显不行。可以考虑前缀和优化。

我们先设一个前缀和数组 $v$，如果 $A_i$ 到 $A_j$ 这个区间所有数的和为 $k$ 的倍数，那么 $v_j-v_{i-1}$ 也为 $k$ 的倍数，即：
$$(v_j-v_{i-1})\bmod k=0$$
把 $v_{i-1}\bmod k$ 移到等式右边就变成：
$$v_j\bmod k=v_{i-1}\bmod k$$

所以我们就可以先用一个数组 $t$ 来存储前缀和数组 $v$ 中每个数除以 $k$ 的余数出现的次数，接着从 $t$ 中的每个元素代表的 $v\bmod k$ 中选两个数，且每种情况选的数字不能与前面重复，根据组合学，每个 $t_i$ 有 $t_i\times(t_i-1)\div2$ 种情况。最后用答案 $ans$ 依次把从 $t_0$ 到 $t_{k-1}$ 按照前面的式子算出来并加起来。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,s=0,t[100010]={1},ans=0;
int main()
{
    scanf("%lld%lld",&n,&k);
	for(register int i=1;i<=n;i++)
	{
		int a;
		scanf("%d",&a);
		s+=a,s%=k,t[s]++;    //由于每个前缀和只要用一次就行了，所以不用设数组
	}
	for(register int i=0;i<k;i++) ans+=t[i]*(t[i]-1)/2;
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：sto_5k_orz (赞：0)

首先，$[i,j]$ 的区间和可以用 $sum_j-sum_{i-1}$ 表示，其中 $sum_i$ 表示 $a_1+a_2+\cdots+a_i$。

那么满足条件的区间 $i,j$ 满足 $sum_j-sum_{i-1}\equiv 0\pmod k$

即 $sum_j\equiv sum_{i-1}\pmod k$

我们可以考虑开桶，把前缀和的所有值都存进桶，那么 $cnt_i$ 表示前缀和除以 $k$ 余 $i$ 的数量。

显然答案是 $\sum_{i=1}^n \dfrac{cnt_i(cnt_i-1)}{2}$，因为任意两个均满足条件。

还有 $sum_0=0$，也要算。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100010; int cnt[N], sum, n, k, x;
int main() {
	cin >> n >> k; cnt[0] = 1;
	for(int i = 1; i <= n; i++) {cin >> x; sum = (sum + x) % k; cnt[sum]++;}
	long long S = 0; for(int i = 0; i < n; i++) {S += 1ll * cnt[i] * (cnt[i] - 1) / 2;}
	cout << S;
	return 0;
}
```

---

## 作者：minVan (赞：0)

**题目大意**

给定一个长度为 $n$ 的数组 $a$，对与一个子串 $a_i\cdots a_j(1\le i\le j\le n)$，如果这个子串内的所有元素的和为 $k$ 的倍数，则称这个子串为 $k$ 倍区间。

问有多少个 $k$ 倍区间。

**解题思路**

本题运用了前缀和、整除性质。

我们用前缀和算出 $a_1$ 至 $a_i$ 的和除以 $k$ 后的余数 $s_i$，如果存在 $s_i=s_j(i < j)$，则 $a_i\cdots a_j$ 这个子串的和除以 $k$ 后的余数为 $0$，即这个子串为 $k$ 倍区间。

每次算完前缀和后，答案就加上 $s_i$ 出现的次数，然后再更新 $s_i$ 出现的次数，这里其实可以不用映射，直接用数组记录次数即可。

**AC 代码**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 100005;
int s[N], a[N], mp[N];
signed main() {
    int n, k, ans = 0;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        s[i] = (s[i - 1] + a[i]) % k;
        ans += mp[s[i]];
        mp[s[i]]++;
    }
    cout << ans + mp[0];
    return 0;
}
```

---

## 作者：LegendaryGrandmaster (赞：0)


每次取这个数组的前缀和与 $k$ 取模，并加上这个前缀和出现的次数。如果不止一次出现，那么上一次出现的位置到这一次出现的位置之间的数的和就一定可以被 $k$ 整除，即为 $k$ 倍区间。

另外，如果这个前缀和已经可以直接被 $k$ 整除的话，也算 $k$ 倍区间。

输出最后的个数即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100010;
int s[N],a[N];
map<int,int>mp;
signed main()
{
    int n,k,ans=0;
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        s[i]=(s[i-1]+a[i])%k;
        ans+=mp[s[i]];
        mp[s[i]]++;
    }
    cout<<ans+mp[0];
}
```

---

## 作者：rainygame (赞：0)

本题看到区间求和，就想到了[前缀和](https://oi-wiki.org/basic/prefix-sum/#%E5%89%8D%E7%BC%80%E5%92%8C)。

但是有了前缀和又怎么样呢？枚举左端点和右端点不还是 $O(n^2)$ 吗？

其实我们可以这样想，一个区间 $[l,r]$ 之和为 $k$ 的倍数，不就相当于 $k \mid S_{l-1}-S_r$ 吗？那根据余数减法定理，不就可以转化为 $S_{l-1} \equiv S_r \pmod k$ 吗？

那么我们就可以用桶记录 $S_x \bmod k$ 的值，然后再找有没有和它相同的即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100001

int n, k;
long long sum;
long long bucket[MAXN], a[MAXN];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    cin >> n >> k;
    for (int i=1; i<=n; i++){
    	cin >> a[i];
    	a[i] = (a[i] + a[i-1]) % k; 
	}

    for(int i=1; i<=n; i++){
    	sum += bucket[a[i]];
    	bucket[a[i]]++;
	}

    cout << sum + bucket[0];
    
    return 0;
}

```


---

## 作者：MasCotangent (赞：0)

# P8649 [蓝桥杯 2017 省 B] k 倍区间 题解
[题目传送门](https://www.luogu.com.cn/problem/P8649)

------------
## 思路
题目要求我们求**一个区间内数的和**，果断使用前缀和维护。

但是这里的前缀和**和前缀和模板又略有不同**。我们思考：一个区间如何才能是成为 $K$ 倍区间？只需要此区间头和尾的前缀和 $B_r$ 和 $B_l$ 满足:
 $$B_r \equiv B_l \pmod K$$ 
即可。

那么我们可以用一个数组记录 $K$ 的每一个**同余类**。由于每一个同余类内的 $K$ 倍区间个数相当于**从这个同余类中选取两个数的方法数**，设此同余类中有 $n$ 个数，可使用组合数 $\binom{n}{2}$ 计算。具体实现这里不展开，可以看代码。

但还要注意一个细节，若一个前缀和 $B_i$ 满足 $B_i \equiv 0 \pmod K$，则它本身就形成一个 $K$ 倍区间，所以我们还要加上这种前缀和的个数。

具体实现参见如下的代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[100001],b[100001],ans=0,x[100001];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>k;
    for(long long i=1;i<=n;i++){
        cin>>a[i];
        b[i]=b[i-1]+a[i];
        b[i]%=k;       //维护前缀和
        x[b[i]]++;//维护同余类
    }
    for(long long i=0;i<k;i++){
        ans+=x[i]*(x[i]-1)/2;//组合数计算
    }
    ans+=x[0];//注意这里
    cout<<ans;
    return 0;
}
```


---


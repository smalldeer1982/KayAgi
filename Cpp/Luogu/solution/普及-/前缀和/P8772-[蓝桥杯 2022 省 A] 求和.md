# [蓝桥杯 2022 省 A] 求和

## 题目描述

给定 $n$ 个整数 $a_{1}, a_{2}, \cdots, a_{n}$, 求它们两两相乘再相加的和，即

$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$


## 说明/提示

对于 $30 \%$ 的数据, $1 \leq n \leq 1000,1 \leq a_{i} \leq 100$ 。

对于所有评测用例, $1 \leq n \leq 2\times10^5,1 \leq a_{i} \leq 1000$ 。 

蓝桥杯 2022 省赛 A 组 C 题。

## 样例 #1

### 输入

```
4
1 3 6 9```

### 输出

```
117```

# 题解

## 作者：_NightFire666_ (赞：50)

看到大佬们的前缀和代码，本蒟蒻自愧不如 qwq。

### 本题也可以用 [完全平方公式](https://lmbtfy.cn/?%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E5%85%AC%E5%BC%8F)！！！

推荐使用 [博客](https://www.luogu.com.cn/blog/20111219zhr/p8772-ti-jie) 食用！

咳咳，先从一个简单的例子入手：

>在 $1$，$2$，$3$，$4$，$5$，$6$，$7$，$8$，$9$，$10$ 这些正整数中每两个数相乘的乘积之和是多少？

我们都知道这十个数两两相乘的乘积有 $C_{10}^2=45$ 个，有多项式：
$$\frac{(1+2+3+ \cdots +9+10)^2-(1^2+2^2+3^2+ \cdots +9^2+10^2)}{2}$$

为这十个数两两相乘的乘积之和。

- 为什么？

先看一下下面的算式：
$$(1+2+3+ \cdots +9+10)^2$$

由完全平方公式展开后为：

$$(1^2+2^2+3^2+ \cdots +9^2+10^2)+2 \times (1 \times 2+1 \times 3+ \cdots 9 \times 10)$$

不难发现多项式 $(1 \times 2+1 \times 3+ \cdots 9 \times 10)$ 正是要求的答案！

易得：

$$(1 \times 2+1 \times 3+ \cdots 9 \times 10)=\frac{(1+2+3+ \cdots +9+10)^2-(1^2+2^2+3^2+ \cdots +9^2+10^2)}{2}$$

那么本题的公式就是：

$$\frac{(a_1+a_2+a_3+ \cdots +a_{n-1}+a_n)^2-({a_1}^2+{a_2}^2+{a_3}^2+ \cdots +{a_n}^2)}{2}$$

### 最后送上代码！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,mul=0,sum=0;
//mul:和的平方
//sum:平方的和
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x;
        sum+=(x*x);
        mul+=x;
    }
    cout<<(mul*mul-sum)/2;
    return 0;
}
```


---

## 作者：二叉苹果树 (赞：44)

$$\begin{aligned}S &=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n} \\ &= \left(a_2 + a_3 + \cdots + a_n\right) \cdot a_1 + \left(a_3 + a_4 + \cdots  +  a_n\right) \cdot a_2 + \cdots + a_n \cdot  a_{n-1}\end{aligned}$$

显然，对于任意的 $\sum\limits_{i=j}^na_i$，其中 $2\le j \le n$，我们都可以通过维护前缀和快速地求出来。令 $sum_i=sum_{i-1}+a_i$，则有 $\sum\limits_{i=j}^na_i=sum_n-sum_{j-1}$。

```cpp
#include<bits/stdc++.h>
#define MAXN 200005

int n, a[MAXN];
long long sum[MAXN], ans;

int main()
{
    std::cin >> n;
    for(int i = 1; i <= n; i++)
    {
        std::cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
    }
    for(int i = 1; i <= n - 1; i++)
        ans += a[i] *(sum[n] - sum[i]);
    std::cout << ans << std::endl;
    return 0;
}
```


---

## 作者：_Cppsteve_ (赞：21)

# [P8772 \[蓝桥杯 2022 省 A\] 求和 ](https://www.luogu.com.cn/problem/P8772)

## $O(n^2)$ 算法

刚看到这道题目，欸，这不是非常简单吗？

 _错误示范：_ 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[200010];
int sum=0;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            sum+=a[i]*a[j];
        }
    }
    cout<<sum<<endl;
    return 0;
}

```

恭喜我获得 $\color{#F39C11}\bold{30}$ 分！

这表明，这个时间复杂度不可行。要降。

## $O(n)$ +前缀和算法

$$
\begin{aligned}
S&=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}\\
&=a_1\times(a_2+a_3+\cdots+a_n)+a_2\times(a_3+a_4+\cdots+a_n)+\cdots+a_{n-1}\times a_n\\
\end{aligned}
$$

而又因为

$$
a_j+a_{j+1}+a_{j+2}+\cdots+a_n=\sum^{n}_{i=1}a_i-\sum^{n}_{i=j}a_i
$$

运用了前缀和的思想，

所以 $S$ 就可以轻而易举地求出来了。

关于前缀和，这里不多说，可以去看[前缀和 & 差分 - OI Wiki](https://oi-wiki.org/basic/prefix-sum/)。

注意数据范围。十年 OI 一场空，不开 `long long` 见祖宗！

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long long a[200010],b[200010];
long long sum=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        b[i]=b[i-1]+a[i];
    }
    for(int i=1;i<n;i++){
        sum+=a[i]*(b[n]-b[i]);
    }
    cout<<sum<<endl;
    return 0;
}

```

恭喜我获得 $\color{#52C41A}\bold{100}$ 分！


---

## 作者：nr0728 (赞：13)

[$\Large{\text{P8772 题目传送门}}$](https://www.luogu.com.cn/problem/P8772)

### 题意

给定 $n$ 以及 $a_1,a_2,\cdots,a_n$，求

$$S=a_1\times a_2+a_1 \times a_3 +\cdots+a_1\times a_n+a_2\times a_3+\cdots+a_{n-2}\times a_{n-1}+a_{n-2}\times a_n+a_{n-1}\times a_n$$

### 分析

根据乘法分配律 $a\times b+a\times c=a \times(b+c)$，原式可化为

$$S=a_1\times(a_2+a_3+\cdots+a_n)+a_2\times(a_3+a_4+\cdots+a_n)+\cdots+a_{n-1}\times a_{n}$$

现在，我们要使用一种叫“前缀和”的方法，定义一个数组 $b$，令 $b_i=a_1+a_2+\cdots+a_i$，很容易发现

$$b_i=\begin{cases}a_1 & i=1\\b_{i-1}+a_i & i>1\end{cases}$$

用这个思路，$\Theta(n)$ 的时间复杂度即可求出 $1\leq i\leq n$ 时 $b_i$ 的值。

但是，分析原式，发现小括号内的不是 $a_1+a_2+\cdots+a_n$，而是 $a_j+a_{j+1}+\cdots+a_n$ $(1\leq j\leq n)$，此时用 $b_n-b_{j-1}$，可得

$$a_1+a_2+a_3+\cdots+a_n-a_1-a_2-\cdots-a_{j-1}$$

化简后得

$$a_j+a_{j+1}+\cdots+a_n$$

即可写出代码。


**不过，不开 $\textbf{long long}$ 见祖宗！**

[$\color{#5EB95E}{\large\textbf{AC 记录}}$](https://www.luogu.com.cn/record/94763547)

最终代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200005],b[200005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(i==1) b[i]=a[i];
		else b[i]=b[i-1]+a[i];
	}
	long long ans=0;
	for(int i=1;i<n;i++)
		ans+=a[i]*(b[n]-b[i]);	//此处原本应该是 ans+=a[i]*(b[n]-b[i+1-1])，化简后得  ans+=a[i]*(b[n]-b[i])。
	cout<<ans; 
	return 0;
}
```

---

## 作者：zhangzihang (赞：8)

### [题目传送门](https://www.luogu.com.cn/problem/P8772)


------------

# 题意分析

- 给定一个数组 $a_n$。
- 求  $S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}$。

------------

# 算法分析

我们可以把 $S$ 变形一下：

$$S=a_1 \cdot (\sum\limits_{i=2}^n a_i)+a_2 \cdot (\sum\limits_{i=3}^n a_i)+\cdots+a_{n-2} \cdot (\sum\limits_{i=n-2}^n a_i) + a_{n-1}\cdot a_n$$

看到 $\sum\limits_{i=2}^n a_i$，这种东西我们很容易想到[前缀和](https://blog.csdn.net/qq_45914558/article/details/107385862)，不会的同学自己看一下。

前缀和 $s_k=\sum\limits_{i=1}^k a_i$，但是怎么处理类似于 $\sum\limits_{i=k}^ma_i$ 这样的东西呢？我们又很容易的发现 $\sum\limits_{i=k}^ma_i=s_m-s_{k-1}$。

于是乎又有了下面的变形：

$$S=\sum\limits_{i=1}^{n-1}(a_i \cdot (s_n-s_i))$$

写代码前看到题目中有这样一句话：“**请使用合适的数据类型进行运算**”。

各位应该知道用什么数据类型了吧。

这道题就顺利 **AC** 了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[200005],a[200005]; //a[i]<=1000 ,s[i]<=2*10^5*1000不需要开long long，节省空间
int main(){
	int n;cin>>n;
	long long sum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[i]=s[i-1]+a[i];
	}
	for(int i=1;i<=n;i++)
		sum+=a[i]*((long long)s[n]-s[i]);
	cout<<sum;
	return 0;
}
```
有任何错误欢迎私信指出。

---

## 作者：so_find_skind (赞：8)

水题。

提取公因数，因为每一个乘法算式的前项下标必然小于后项下标，因此考虑将总和每次减去 $a_i$ 再相乘。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200005],ans,sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];
    }
    for(int i=1;i<=n;i++){
        sum-=a[i];
        ans+=sum*a[i];
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：0112_qwq (赞：2)

先观察数据范围 $1\le n\le 2\times 10^5$，$1\le a_i\le 1000$ 。

很明显，$O\left( n^2 \right) $ 过不了，还要开 long long。

所以要想一种优化。

$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$
$$
\ =a_1\cdot \left( a_2+a_3+...+a_n \right) +a_2\cdot \left( a_3+a_4+...+a_n \right) +...+a_{n-1}\cdot a_n
$$

而后面的和可以用[前缀和](https://oi-wiki.org/basic/prefix-sum/)优化 $O\left( 1 \right) $ 求出来。

代码实现也不难。

```
#include<bits/stdc++.h>
using namespace std;
const int M=114514*2;
long long n,a[M],b[M],ans;
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		b[i]=b[i-1]+a[i];	//预处理前缀和
	}
	for(int i=1;i<=n;i++)
	{
		ans+=a[i]*(b[n]-b[i]);	//求多项式每一项的积
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：what_can_I_do (赞：2)

[传送门](https://www.luogu.com.cn/problem/P8772)

这不就前缀和吗。

$$S=a_1 \times a_2 + a_1 \times a_3 +......+a_1\times a_n+a_2 \times a_3 +......+a_n-1\times a_n$$

可以用乘法分配律变为：

$$S=a_1 \times (a_2 + a_3 +......+a_n)+a_2 \times (a_3 +......+a_n)+......+a_n-1\times a_n$$

那么我们知道一个区间内的数的和 $a_l\sim a_r$ 可以通过前缀和差分变为 $v_r-v_{l+1}$ ，那么我们就可以把该数组的前缀和先求出来，再用一个 for 循环来把 $a_i\times (v_n-v_i)$ $(v_n-v_i=a_{i+1}+a_{i+2}+......+a_n)$的结果全部加起来，就是答案了。

记住，要开 long long。

# CODE:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200010],v[200010]={0},ans=0;
signed main()
{
    scanf("%lld",&n);
    for(register int i=1;i<=n;i++) scanf("%lld",&a[i]),v[i]=v[i-1]+a[i];
    for(register int i=1;i<=n;i++) ans+=a[i]*(v[n]-v[i]);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：tZEROちゃん (赞：1)


$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$

对这个式子提取公因式可以得到

$$
S=a_1\cdot(a_2+a_3+\cdots+a_n) +a_2\cdot(a_3+a_4+\cdots +a_n)+\cdots a_{n-1}\cdot a_n
$$

对于后面的 $a_{i+1}+\cdots+a_n$ 可以计算后缀和。

最后就可以在 $O(n)$ 的时间复杂度解决本题。

```cpp
#define int long long
const int N = 2e5 + 10;
int a[N];

signed main() {
  int n = rd(), cnt = 0, ans = 0;
  rep (i, 1, n) a[i] = rd();
  per (i, n, 1) {
    ans += a[i] * cnt; cnt += a[i]; 
  }
  printf("%lld\n", ans);
}
```

完整代码见：[云剪切板](https://www.luogu.com.cn/paste/p2ji7e0f)。

---

## 作者：Milthm (赞：1)

## P8772 题解

这题暴力肯定会**TLE**，但是不要慌张，运用**乘法分配律**，举个例子: $a_1\times a_2+a_1\times a_3+……+a_1\times a_n$

运用分配律，就等于: $a_1\times (a_2+a_3+a_4+……+a_n)$

但是，还需要一个东西存后面所有数的和：

### 前缀和

用一个数组存前缀和，那么就可以求出任何一段的和啦！

AC代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long n,a[200005],b[200005],ans;//初始化变量
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=b[i-1]+a[i];//前缀和
    }
    for(int i=1;i<=n;i++){
        ans+=a[i]*(b[n]-b[i]);//b[n]-b[i]是这一段的和，用a[i]去乘，累加答案
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：安舒阳 (赞：1)

本题的考点：合并同类项 / [乘法结合律](https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E7%BB%93%E5%90%88%E5%BE%8B/8351743?fr=aladdin)。

对于一个真正的小学二年级知识，我们可以显而易见地将公式：

$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$

的所有包含 $a_{1}$ 项的内容化简为：

$$a_{1} \cdot ( a_{1}+a_{2}+a_{3} \cdots a_{n-1}+a_{n})$$

为什么说是包含 $a_{1}$ 项呢？**因为仔细阅读原题可以发现这里其实包含了一个信息：对于单个项 $a_{i} \cdot a_{j}$ 中有 $i<j$，因此此处需要注意**。

用一个变量记录和，每过一个点减掉那个点即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	
	int data[200005];
	long long cnt=0;
	for(int i=0;i<n;i++){
		scanf("%d",&data[i]);
		cnt+=data[i];
	}
	
	long long ans=0;
	for(int i=0;i<n-1;i++){
		ans+=(long long)(cnt-data[i])*data[i];
		cnt-=data[i];
//		printf("%lld*%d\n",cnt-data[i],data[i]);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：ryf_loser (赞：1)

这题主要就是要有前缀和的思想

求出总和，除去自己前面的（包含自己）再乘上自己，加到答案中。

公式为$a_{1} \times
a_{2}+a_{1} \times 
a_{3}+...a_{1} \times 
a_{n}+a_{2} 
\times a_{3}+a_{2} \times a_{4}+...+a_{2} \times a_{n}+...+a_{n-1} \times (a_{n})$

运用乘法分配律可以得出$a_{1} \times (a_{2}+a_{3}+...+a_{n})+a_{2} \times (a_{3}+a_{4}+...+a_{n})+...+a_{n-1} \times (a_{n})$

一个$O(n)$的时间复杂度的程序完美出炉。

另外，~~不开 long long 见祖宗~~

AC代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[200001];
long long ans,sum;
int main(){
    scanf ("%d",&n);
	for (int i=1;i<=n;i++){scanf ("%d",&a[i]);sum+=a[i];}
	for (int i=1;i<=n-1;i++)ans+=(sum-=a[i])*a[i];
	printf ("%lld",ans);
    return 0;
}
```


---

## 作者：pxb0801 (赞：1)

## 1.分析：

这道题很明显运用了乘法分配律，也就是：

$S=a_1(a_2+a_3+\cdots+a_n)+a_2(a_3+a_4+\cdots+a_n)+\cdots+a_{n-2}(a_{n-1}+a_n)+a_{n-1}\cdot a_n$

所以，我们可以用一个后缀和 $cnt[]$ 来把括号内的时间降为 $O(1)$，再从头到尾扫一遍，将和计入 $ans$ 即可。

-----------------------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//本题会超int，要开long long
using namespace std;
ll n,a[200005],cnt[200005],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=n;i>=1;i--){
		cnt[i]=cnt[i+1]+a[i];//计算后缀和
	}
	for(int i=1;i<=n;i++){
		ans+=a[i]*cnt[i+1];//计入ans
	}
	cout<<ans;
	return 0;
}
```

---


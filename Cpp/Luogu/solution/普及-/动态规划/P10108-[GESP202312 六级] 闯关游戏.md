# [GESP202312 六级] 闯关游戏

## 题目描述

你来到了一个闯关游戏。

这个游戏总共有 $N$ 关，每关都有 $M$ 个通道，你需要选择一个通道并通往后续关卡。其中，第 $i$ 个通道可以让你前进 $a_i$ 关，也就是说，如果你现在在第 $x$ 关，那么选择第 $i$ 个通道后，你将直接来到第 $x+a_i$ 关（特别地，如果 $x + a_i \geq N$，那么你就通关了）。此外，当你顺利离开第 $s$ 关时，你还将获得 $b_s$ 分。

游戏开始时，你在第 $0$ 关。请问，你通关时最多能获得多少总分。

## 说明/提示

**样例解释 1**

你可以在第 $0$ 关选择第 $1$ 个通道，获得 $1$ 分并来到第 $3$ 关；随后再选择第 $0$ 个通道，获得 $100$ 分并来到第 $5$ 关；最后任选一个通道，都可以获得 $30$ 分并通关。如此，总得分为 $1+100+30=131$。

**样例解释 2**

请注意，一些关卡的得分可能是负数。


**数据范围**

对于 $20\%$ 的测试点，保证 $M=1$。

对于 $40\%$ 的测试点，保证 $N \le 20$；保证 $M\le 2$。

对于所有测试点，保证 $1 \le N \le 10^4$；保证 $1 \le M\le 100$。

## 样例 #1

### 输入

```
6 2 
2 3
1 0 30 100 30 30```

### 输出

```
131```

## 样例 #2

### 输入

```
6 2
2 3
1 0 30 100 30 -1```

### 输出

```
101```

# 题解

## 作者：zsh_haha (赞：32)

### 题目大意

让我们简化一下题目。

一共有 $N$ 个关卡，从第 $0$ 关开始，每次都可以往前跳 $a_i$ 关，其中 $0\le i< M$。当你到达第 $j$ 关时，你的得分**必须**加 $b_i$ 分，其中 $0\le j<N$。

### 解题思路

我们可以用动态规划来解决这道题。

我们设 $f_i$ 表示到达第 $i$ 关时获得的分数的最大值。

不难看出，状态转移方程就是：

$$f_j=\max\{f_j,f_{j-a_i}+b_{j-a_i}\}$$

但这样就好了嘛？并没有，我们仔细看题目中的一句话：

>特别地，如果 $x+a_i\ge N$，那么你就通关了。

没错，这里是 $x+a_i\ge N$，而不是 $x+a_i=N$ 或 $x+a_i=N-1$。

所以 $f$ 数组应该多算一点，防止有些最大值是在关卡外产生的。（重点）

值得注意的是，由于本题中 $b_i$ 可能为负数，所以 $f$ 数组要初始化为负无穷，而 $f_0$ 也要记得初始化为 $0$。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101],b[20001]/*b 数组多开是因为在算 f 数组时的需要*/;
int f[20001];//多算一点，算到 N+max{ai}=2N
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        cin>>a[i];
    }
    for(int i=0;i<n;i++){
        cin>>b[i];
    }
    for(int i=0;i<n+n;i++){
        f[i]=-1e9;//初始化为负无穷
    }
    f[0]=0;//记得 f[0] 要初始化为 0
    for(int j=0;j<n+n;j++){
        for(int i=0;i<m;i++){
            if(j>=a[i]){
                f[j]=max(f[j],f[j-a[i]]+b[j-a[i]]);
            }
        }
    }
    int ans=-1e9;//答案变量也要初始化为负无穷
    for(int i=n;i<n+n;i++){
        ans=max(ans,f[i]);//注意不能直接输出 f[n] 或 f[n-1]
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：zzx114514 (赞：10)

## [题目传送门](https://www.luogu.com.cn/problem/P10108)
# 题目大意
有 $N$ 个关卡，每个关卡有 $M$ 个通道，第 $i$ 个通道能前进 $a_i$ 关，每次离开当前关卡 $s$ 即获得当前关卡分数 $b_s$，若最后到达的关卡编号大于等于 $N$ 即为过关，求过关后能获得的最大分数。
# 解题思路
`dp` 即可，但我选择记忆化搜索。开一个数组存储当前分数，并且数组必须是极小值，因为分数可能是负数。`dfs` 暴力模拟，以 $0$ 为起点开始搜索，如果过关返回 $0$，如果发现分数不是最小值，则分数已被修改，说明当前关卡来过了，直接返回分数，否则搜索到第 $x+a_i$ 关并加上当前关卡分数，最后返回总分即可。
# 完整代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[105],b[10005],f[10005];
ll find(ll x)
{
	if (x>=n) return 0;//如果过关则返回0，因为过关不加分 
	if (f[x]!=-0x3f3f3f3f3f3f3f3f) return f[x];//如果f[x]不是极小值，说明来过了，直接返回当前分数 
	for (int i=0;i<m;i++) f[x]=max(f[x],b[x]+find(x+a[i]));//否则挨个试过去，每次加上本关分值，并且跳到第x+a[i]关 
	return f[x];//最后返回总分 
}
int main()
{
	cin>>n>>m;
	for (int i=0;i<m;i++) cin>>a[i];
	for (int i=0;i<n;i++) cin>>b[i];
	for (int i=0;i<n;i++) f[i]=-0x3f3f3f3f3f3f3f3f;//f[i]表示以i为起点能获得的最大分数，记得赋极小值，因为分数有负数 
	cout<<find(0);//答案是以0为起点 
	return 0;
}

```


---

## 作者：CleverRaccoon (赞：7)

## 题目描述

一开始在第 $0$ 关，共 $N$ 关，$M$ 个通道，顺利离开第 $s$ 关可以获得 $b_s$ 分。当你在第 $x$ 关时，可以使用第 $i$ 个通道到达 $x+a_i$ 关，跳到 $N$ 及以后的位置就通关了。

问最多可以得多少分?

## 思路

考虑动态规划。

- 初始化：

因为要取最大，所以要先将动态规划数组中的每个值都设为一个较小的数；另外要将动规数组第一个数的值设为 $b_1$，因为到第一关的只能是从第 $0$ 关来的。

```cpp
for(int i=1;i<=n;i++)f[i]=-100000000;
f[1]=b[1];
```

- 动态规划

$dp_i$ 表示走到第 $i$ 关可以获得的最大得分。

首先枚举每一关（即 $1\sim N$），然后每一关中枚举每一个通往前面的关卡的通道。这里注意要特判是否这个通道能通到存在的关卡，设当前的关卡数为 $i$，第 $j$ 个通道，即 $i-a_j>0$。

转移：设当前的关卡数为 $i$，第 $j$ 个通道，当前关卡的最大得分为：当前关卡之前求出的最大得分和第 $i-a_j$ 个关卡的最大得分加上 $b_i$ 中的较大者，即 $dp_i=\max(dp_i,dp_{i-a_j}+b_i)$。

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
    	if(i-a[j]<=0)continue;
        int k=i-a[j];
        f[i]=max(f[i],f[k]+b[i]);
    }
}
```

- 获得答案

当然是要取最大值了，但是因为 $b_i$ 有负数，所以可能出现最大得分的关卡无法跳出游戏，因此要先得到通道长度的最大值 $\max a_i$，然后 $N-\max a_i+1$ 即为最靠前的一个可以直接跳出游戏的关卡了，取 $dp_i$ 从 $N-\max a_i+1$ 到 $n$ 的最大值即可。

```cpp
int maxa=-100000000;
for(int i=1;i<=m;i++)maxa=max(maxa,a[i]);
int ans=-100000000;
for(int i=n-maxa+1;i<=n;i++){
    ans=max(ans,f[i]);
}
cout<<ans<<endl;
```

## 完整代码

时间复杂度 $\mathcal{O}(nm)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[210],b[20010],f[20010];
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    for(int i=1;i<=n;i++)f[i]=-100000000;
    f[1]=b[1];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i-a[j]<=0)continue;
            int k=i-a[j];
            f[i]=max(f[i],f[k]+b[i]);
        }
    }
    int maxa=-100000000;
    for(int i=1;i<=m;i++)maxa=max(maxa,a[i]);
    int ans=-100000000;
    for(int i=n-maxa+1;i<=n;i++){
        ans=max(ans,f[i]);
    }
    cout<<ans<<endl;
    return 0;
}
```

这次考了九十二分，纪念一下。



---

## 作者：潘德理2010 (赞：4)

dp。

设 $d_i$ 为到达第 $i$ 关时的最大得分。

初始状态为 $d_0=0$，表示初始得分为 $0$。

不难得到，转移方程 $d_i=\max(d_{i-a_j}+b_{i-a_j})$。

直接 dp 即可，最终答案为 $d_n$。时间复杂度 $O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10010],t[110],d[20010],ans=-2e9;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&t[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	memset(d,-0x3f3f3f,sizeof(d));
	d[1]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int u=i+t[j];
			if(u>n){
				ans=max(ans,d[i]+a[i]);
			} 
			else{
				d[i+t[j]]=max(d[i+t[j]],d[i]+a[i]);
			}
		}
	}
	printf("%d",ans);
}
```


---

## 作者：h_rains (赞：3)

## 简化题意 
每次我们可以前进 $a_i$ 格，然后每**走过**一个格就要加上这个格的权值，问走过终点后能获得最大权值是多少。

## 思路

这个是很类似于方格取数问题，不同的地方是这道题是一维的，而且走的距离有很多种，我们考虑方格取数问题中，我们是设的到点 $(i,j)$ 的最大权值是 $dp[i][j]$ 然后因为能从上方和左方来，所以转移为 $dp[i][j]=\max(dp[i-1][j],dp[i][j-1])+a[i][j]$ 然后回到这道题，类似的我们设 $dp[i]$ 表示走到 $i$ 的最大权值，然后考虑它能从哪里转移过来，显然我们把它往前走 $a_i$ 个格子就是它能转移过来的地方。具体的讲 $dp[i]=\max_{j=0}^m\{dp[i-a[j]]+v[i-a[j]]\},dp[0]=0$ 其中 $0\le i-a[j]$ 且 $i-c[j]\le n-1$ 这是因为最右端必须是从小于 $n$ 的地方转移出去的，最左端也必须从 $0$ 以上开始转移。至于为什么是加 $v[i-a[j]]$ 而不是 $v[i]$ 这是因为必须要**走过**一个格才加上该格权值。具体看代码。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=20100;// dp 数组开两倍，因为没卡空间所以直接全开两倍了

int a[maxn],v[maxn];
int dp[maxn];

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=2*n;i++) dp[i]=-0x3f3f3f3f;//注意有负数，所以初值设为负无穷 
	for(int i=1;i<=m;i++) cin>>a[i];
	for(int i=0;i<n;i++) cin>>v[i];
	for(int i=1;i<=2*n;i++)
		for(int j=1;j<=m;j++)
			if(i-a[j]>=0&&i-a[j]<n) 
				dp[i]=max(dp[i],dp[i-a[j]]+v[i-a[j]]);
	int maxx=-0x3f3f3f3f;
	for(int i=n;i<=2*n;i++) maxx=max(maxx,dp[i]);//因为 a 最大为 n 所以最远能到 2*n-1 这里为了方便直接就写 2*n 了 
	cout<<maxx<<endl;
}
```

---

## 作者：int32 (赞：3)

基础的动态规划题。记 $f(i)$ 表示离开第 $i$ 关时（$i$ 可以大于等于 $n$）获得的分数的最大值。

转移方程为 $f(i)=\max_{j=0}^{m-1} f(i-a_j)+b_i$，边界条件为 $f(0)=b_0$。

注意在转移的时候要保证 $i-a_j\in[0,i)$。当 $i\ge n$ 时游戏通关，因此最终的答案即为 $\max_{i=n}^{2n-1} f(i)$。

```cpp
//
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n, m;
int a[N];
int b[N];
int dp[N<<1];
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>b[i];
    memset(dp,-0x3f,sizeof dp);
    dp[1]=b[1];
    for(int i=2;i<(n<<1);i++)
        for(int j=1;j<=m;j++){
            if(i-a[j]<1||i-a[j]>n) continue;
            dp[i]=max(dp[i],dp[i-a[j]]+b[i]);
        }
    cout<<*max_element(dp+n+1,dp+(n<<1)+1);
    return 0;
}
```

---

## 作者：Weekoder (赞：3)

# P10108 [GESP202312 六级] 闯关游戏 题解
## 题目大意

你来到了一个闯关游戏。

这个游戏总共有 $N$ 关，每关都有 $M$ 个通道，你需要选择一个通道并通往后续关卡。其中，第 $i$ 个通道可以让你前进 $a_i$ 关，也就是说，如果你现在在第 $x$ 关，那么选择第 $i$ 个通道后，你将直接来到第 $x+a_i$ 关（特别地，如果 $x + a_i \geq N$，那么你就通关了）。此外，当你顺利离开第 $s$ 关时，你还将获得 $b_s$ 分。

游戏开始时，你在第 $0$ 关。请问，你通关时最多能获得多少总分？
## 分析
本人这里介绍一种图论做法。

我们可以把闯关理解成为一条有向边。比如当前在 $x$ 关，就向 $x+a_i$ 关建边。那如果 $x+a_i$ 超过了 $n$，就创建一个虚拟点 $n+1$ 并指向 $n+1$。$n+1$ 就代表通关了。建好图后拓扑排序 + DP 跑最长路即可，答案为 $dp_{n+1}$。
# $\text{Code:}$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e4 + 5, INF = 1 << 30;

struct Edge {
    int to, w;
};

int n, m, a[N], b[N], in[N], dp[N];

vector<Edge> nbr[N];

void topo() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (!in[i])
            q.push(i);
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        for (auto j : nbr[cur]) {
            int nxt = j.to, w = j.w;
            dp[nxt] = max(dp[nxt], dp[cur] + w);
            in[nxt]--;
            if (!in[nxt])
                q.push(nxt);
        }
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= m; j++) 
            nbr[i].emplace_back((Edge){(i + a[j] > n ? n + 1 : i + a[j]), b[i]}), in[(i + a[j] > n ? n + 1 : i + a[j])]++;
    for (int i = 2; i <= n + 1; i++) dp[i] = -INF;
    topo();
    cout << dp[n + 1];
    return 0;
}

```

---

## 作者：tder (赞：2)

简单 dp 即可。

---

做动态规划的第一步是设计状态。令 $f_{i,j}$ 表示当前在第 $i$ 关，且由第 $j$ 个通道进入本关的得分（不计离开本关的得分）。

由于本题当位置大于等于最后一关时均算为通关，考虑转移时从本状态推别的状态，而非通常的从别的状态推本状态。

那么，从第 $0$ 关出发，可通过 $M$ 个管道进入其它关，经过第 $i$ 个管道，可到达第 $0+a_i$ 关，即：

$$
f_{a_i,i}=b_0
$$

这便是边界状态。

而后再考虑状态的转移。对于一个已推出的状态，如果当前在第 $i$ 关，由第 $j$ 个管道进入下一关，并由第 $k$ 个管道进入本关，显然，接下来可以进入第 $i+a_j$ 关，且其代价为当前得分 $f_{i,k}$ 加上离开本关的得分 $b_i$，即：

$$
f_{i+a_j,j} = f_{i,k} + b_i
$$

由于可能有多个状态都能推出同一状态，例如，从第 $1$ 关通过长度为 $3$（即 $a_i=3$）的管道可进入第 $4$ 关，也可从第 $2$ 关通过长度为 $2$ 的管道同样进入第 $4$ 关，因此取 $\max$ 即可。

最后分析答案。在转移中，当 $i+a_j\ge N-1$，即下一关大于等于最后一关时，称为通关，那么：

- 若 $i+a_j=N-1$，即从最后一关通关，需要加上离开最后一关的得分 $b_{N-1}$，总得分为 $f_{i+a_j,j}+b_{N-1}=(f_{i,k}+b_i)+b_{N-1}$；
- 反之，若 $i+a_j>N-1$，即不从最后一关通关，总得分为 $f_{i+a_j,j}=f_{i,k}+b_i$。

计算所有可能得分的最大值即可。

时间复杂度 $O(NM^2)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e4 + 5, M = 1e2 + 5, INF = 1e18;
int n, m, a[M], b[N], f[N][M], ans = -INF;
signed main() {
    cin>>n>>m;
    for(int i = 0; i < m; i++) cin>>a[i];
    for(int i = 0; i < n; i++) cin>>b[i];
    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) f[i][j] = -INF;
    for(int i = 0; i < m; i++) f[a[i]][i] = b[0];
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            for(int k = 0; k < m; k++) {
                if(i + a[j] >= n - 1) {
                    if(i + a[j] == n - 1) ans = max(ans, f[i][k] + b[i] + b[n - 1]);
                    else {
                        ans = max(ans, f[i][k] + b[i]);
                        // cout<<"ans = "<<ans<<" when (i, j) = ("<<i<<", "<<j<<")"<<endl;
                        continue;
                    }
                    // cout<<"ans = "<<ans<<" when (i, j) = ("<<i<<", "<<j<<")"<<endl;
                }
                f[i + a[j]][j] = max(f[i + a[j]][j], f[i][k] + b[i]);
                // cout<<"f["<<i + a[j]<<"]["<<j<<"] = "<<f[i + a[j]][j]<<"  (i, j) = ("<<i<<", "<<j<<")"<<endl;
            }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：LMB_002 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/UVA1151)

## 一、思路分析
------------
先看数据 $1\leq N\leq 10^4$，以及 $1\leq M \leq 100$，所以考虑 $O(NM)$ 的做法。使用动态规划，因为会出现负数，所以需要全部初始化为极小值，第 $0$ 关初始化为 $0$。每过一关，就加上前一关的分数，取较大值。

注意：下标一定不能超过 $n$。

## 二、代码实现
------------

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+5;
int n,m,a[N],b[N],ans,dp[N];
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%lld",&a[i]);
	}for(int i=0;i<n;i++){
		scanf("%lld",&b[i]);
	}memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	for(int i=0;i<n;i++){
		for(int j=1;j<=m;j++){
			dp[min(i+a[j],n)]=max(dp[min(i+a[j],n)],dp[i]+b[i]);
		}
	}printf("%lld",dp[n]);
	return 0;
}


```


---

## 作者：niuzh (赞：0)

### 思路

很明显，此题为 $dp$。

设 $dp_i$ 为走到第 $i$ 关的最大分值。

由于分值可能为负，所以要把 $dp$ 数组初始化为负无穷，并且要将 $dp_0$ 设为 $0$，因为在第 $0$ 关一定什么都没有。

转移方程为 $dp_i=\max(dp_i,dp_{i-a_j}+b_{i-a_j})$，是在当前与从一个通道到这一关的最大得分，其中 $i$ 为外重循环，枚举第 $1$ 到 第 $n$ 关，而 $j$ 为内重循环，枚举通道。

答案为取 $dp_i$ 从 $n-max_{a_i}+1$ 到 $n$ 的最大值。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+10,M=100+10,inf=1e9;
int a[M],b[N],dp[N];
int main()
{
	memset(dp,~0x3f,sizeof(dp));
	int n,m,maxx=-inf;
	cin>>n>>m;
	for (int i=1; i<=m; i++)
	{
		cin>>a[i];
		maxx=max(maxx,a[i]);
	}
	for (int i=0; i<n; i++)
	{
		cin>>b[i];
	}
	dp[0]=0;
	for (int i=1; i<=n; i++)
	{
		for (int j=1; j<=m; j++)
		{
			if (i-a[j]<0)
			{
				continue;
			}
			dp[i]=max(dp[i],dp[i-a[j]]+b[i-a[j]]);
		}
	}
	int ans=-inf;
	for (int i=n-maxx+1; i<=n; i++)
	{
		ans=max(ans,dp[i]+b[i]);
	}
	cout<<ans;
	return 0;
}
```

---


# [GESP202403 六级] 游戏

## 题目描述

你有四个正整数 $n,a,b,c$，并准备用它们玩一个简单的小游戏。

在一轮游戏操作中，你可以选择将 $n$ 减去 $a$，或是将 $n$ 减去 $b$。游戏将会进行多轮操作，直到当 $n \leq c$ 时游戏结束。

你想知道游戏结束时有多少种不同的游戏操作序列。两种游戏操作序列不同，当且仅当游戏操作轮数不同，或是某一轮游戏操作中，一种操作序列选择将 $n$ 减去 $a$，而另一种操作序列选择将 $n$ 减去 $b$。如果 $a=b$，也认为将 $n$ 减去 $a$ 与将 $n$ 减去 $b$ 是不同的操作。

由于答案可能很大，你只需要求出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

### 数据规模与约定


- 对 $20\%$ 的数据，$a=b=c=1$，$n \leq 30$。
- 对 $40\%$ 的数据，$c = 1$，$n \leq 10^3$。
- 对全部的测试数据，保证 $1 \leq a,b,c \leq n \leq 2 \times 10^5$。

## 样例 #1

### 输入

```
1 1 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
114 51 4 1```

### 输出

```
176```

## 样例 #3

### 输入

```
114514 191 9 810```

### 输出

```
384178446```

# 题解

## 作者：xyx404 (赞：28)

## 思路：
先写出暴力的搜索，然后改为记忆化搜索。

暴力的搜索就是暴力向下搜 $n$ 减去 $a$ 和 $n$ 减去 $b$ 的游戏操作序列的总数，暴力搜索代码如下。
```cpp
long long dfs(long long x){
	if(x<=c)return 1;
	return (dfs(x-a)%mod+dfs(x-b)%mod)%mod;
}
```

然后改为记忆化搜索，定义一个数组存结果，如果现在搜索的这个数已经被搜索过了就自己访问数组，如果没有就先搜索，搜索完后赋值，这样就可以防止重复地搜索一个数，记忆化搜索代码如下。
```cpp
long long dfs(long long x){
	if(x<=c)return 1;
	if(an[x]!=0)return an[x];// 如果有值直接返回
	return an[x]=(dfs(x-a)%mod+dfs(x-b)%mod)%mod;// 如果没有进行搜索并赋值
}
```


## 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long an[200005]={0};
long long n,c,b,a;
const int mod=1e9+7;// 模 1e9+7
long long dfs(long long x){
	if(x<=c)return 1;
	if(an[x]!=0)return an[x];// 如果有值直接返回
	return an[x]=(dfs(x-a)%mod+dfs(x-b)%mod)%mod;// 如果没有进行搜索并赋值
}
int main(){
	cin>>n>>a>>b>>c;
	cout<<dfs(n);
	return 0;
}

```

---

## 作者：caoyuchen110911 (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P10376)

这道题的意思很好理解。我们假定一个数组 $s$，从 $n$ 减到 $i$ 有 $s_i$ 种可能。

因为 $i+a$ 再减去 $a$ 就是 $i$ 了，$i+b$ 再减去 $b$ 就是 $i$ 了，所以公式：$s_i=s_{i+a}+s_{i+b}$

也就是说，$s_i$ 将会加到 $s_{i-a}$ 和 $s_{i-b}$ 上。

局部关系图如下（画的并不好）：![](https://cdn.luogu.com.cn/upload/image_hosting/0g0l3u59.png)那么只要倒序循环，当 $i-a>c$ 时将 $s_i$ 加给 $s_{i-a}$，否则加给 $ans$，当 $i-b>c$ 时将 $s_i$ 加给 $s_{i-b}$，否则也加给 $ans$，最后输出 $ans$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long s[200005];
int main()
{
	int n,a,b,c;
	long long ans=0;
	scanf("%d%d%d%d",&n,&a,&b,&c);
	if(n==c)//特判
	{
		printf("1");
		return 0;
	}
	s[n]=1;
	for(int i=n;i>c;i--)
	{
		if(i-a>c)s[i-a]+=s[i],s[i-a]%=1000000007;
		else ans+=s[i];
		if(i-b>c)s[i-b]+=s[i],s[i-b]%=1000000007;
		else ans+=s[i];
		ans%=1000000007;//答案也要取模
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：spfa_ (赞：13)

[P10376 [GESP202403 六级] 游戏](https://www.luogu.com.cn/problem/P10376)

注意到 $n\le 2\times 10^5$，所以可以考虑动态规划。

设 $f_i$ 为当 $n=i$ 的方案数，那么有

$$f_i=
\begin{cases}
1 & i\le c \\
f_{i-a}+f_{i-b} & i>c
\end{cases}
$$

注意取模。

代码：

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

int main() {
	int n, a, b, c;
	cin >> n >> a >> b >> c;
	vi f(n+1); f[c] = 1;
	for (int i = c+1; i <= n; ++i) f[i] = ((i-a <= c ? 1 : f[i-a])+(i-b <= c ? 1 : f[i-b]))%1000000007;
	cout << f[n];
	return 0;
}
```

---

## 作者：Austin0116 (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P10376)

这道题因为 $n \le 2*10^5$  所以就很自然的想到一种线性 DP 策略：

从 $n$ 枚举到  $c+1$  将 $dp[i]$ 转移到 $dp[i-a]$ 和 $dp[i-b]$ 中 ，状态转移方程就是 

$dp[i - a] = dp[i - a] + dp[i]$

$dp[i - b] = dp[i - b] + dp[i]$ 

最后还要注意 $n-a$ 和 $n-b$ 为负数的情况以及一边算一边模。

代码如下：

```cpp
#include <bits/stdc++.h>
#define p 1000000007
using namespace std;
int n,a,b,c,f[200005];
int main(){
	scanf("%d%d%d%d",&n,&a,&b,&c);
	f[n]=1;//初始化 
	for(int i=n;i>c;i--){
		if(i-a<=c) f[c]=(f[c]+f[i])%p;//为了避免负数的情况，我们可以特判，将小于等于 c 的 i-a 和 i-b 全部存进 c 中 
		else f[i-a]=(f[i-a]+f[i])%p;
		if(i-b<=c) f[c]=(f[c]+f[i])%p;
		else f[i-b]=(f[i-b]+f[i])%p;
	}
	printf("%d",f[c]);
	return 0;
}
```

---

## 作者：Albatross_LC (赞：7)

### 思路：

动态规划。

从 $c+1$ 遍历到 $n$，对于其中的每个 $i$，其答案 $f_i$ 为 $f_{i-a}+f_{i-b}$，因为每个 $i$ 都只被 $a$ 和 $b$ 各减了一次，所以方案不会重复。

其中对于 $1$ 到 $c$ 的每个 $i$，$f_i$ 都为 $1$。

要注意边界问题，还有不要忘了取模。

### Code:

```cpp
#include <iostream>
using std::cin, std::cout, std::max;
const int N = 2e5 + 10, q = 1e9 + 7;
int n, a, b, c, f[N];
int main() {
	cin >> n >> a >> b >> c;
	if (n == c) cout << 1, exit(0);//数据规模中提示c有可能等于n
	for (int i = 0; i <= c; f[i] = 1, i ++ );
	for (int i = c + 1; i <= n; i ++ ) {
	    int x = max(i - a, 0), y = max(i - b, 0);//max是对边界的处理
	    f[i] = (f[x] + f[y]) % q;
	}
	cout << f[n];
}
```

---

## 作者：liaoxingrui (赞：5)

## Content

有 $4$ 个正整数 $n$，$a$，$b$，$c$，有两个操作：

- 将 $n$ 减去 $a$

- 将 $n$ 减去 $b$

可以一直操作下去。若 $n \le c$，则不能操作。若 $a = b$，这两个操作还是算不一样的。

问到不能操作的时候，有多少种不同的操作序列。答案需要对 $10^9 + 7$ 取模。

## Solution

一：

用 `dfs` 暴力枚举 $n - a$ 和 $n - b$。然后用 $flag$ 数组存下来，再次循环到这个值是便可直接返回，不用继续再向下搜索。

二：

因为从 $n$ 开始，所以我们可以将 $dp_n$ 赋值为 $1$，然后给它下面 $i - a$ 或 $i - b$ 加上它的值，并一直枚举下去。若 $i - a$ 或 $i - b$ 小于 $c$，则将 $i - a$ 或 $i - b$ 替换为 $c$。最后输出 $dp_c$ 即可。

## Code

一：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,a,b,c,ma;
int flag[200005];
inline int dfs(int x){
	if(x<=c)
		return 1;
	if(flag[x])
		return flag[x];
	return flag[x]=(dfs(x-a)+dfs(x-b))%mod;
}
int main(){
	scanf("%d%d%d%d",&n,&a,&b,&c);
	printf("%d",dfs(n));
	return 0;
}
```

二：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,a,b,c,ma;
int dp[200005];
inline void pushup(int x,int y){
	dp[x]=(dp[x]+dp[y])%mod;
}
int main(){
	scanf("%d%d%d%d",&n,&a,&b,&c);
	dp[n]=1;
	for(int i=n;i>c;i--){
		if(!dp[i])
			continue; 
		pushup(max(i-a,c),i);
		pushup(max(i-b,c),i);
	}
	printf("%d",dp[c]);
	return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P10376)

## 题目大意
给定四个整数 $n,a,b,c$，每次可以执行操作 $n-a$ 或 $n-b$，直到 $n \le c$，求方案数模 $10^9+7$ 的结果。

## 解题思路
看到这道题，想动态规划。

我们记 $f_i$ 为经过操作后 $n$ 变成了 $i$ 的方案数，那么 $f_{i-a}$ 和 $f_{i-b}$ 就可以从 $f_i$ 转移过来。

这道题的转移方程本来应该是：
$$f_{i-a}=f_{i-a}+f_i$$
$$f_{i-b}=f_{i-b}+f_i$$

但因为 $i-a$ 或 $i-b$ 可能为负数，因此要平移。

注意要不断取模，否则会爆掉。

其余见代码及注释。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,MOD=1e9+7;
int n,a,b,c,f[N<<1],sum;
int main()
{
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>a>>b>>c;
    f[N+n]=1;
    for(int i=n;i>c;i--)//大于c的数都可以转移 
    {
        f[N+i-a]=(f[N+i-a]+f[N+i])%MOD;
        f[N+i-b]=(f[N+i-b]+f[N+i])%MOD;//平移N，以防负数 
    }
    for(int i=0;i<=N+c;i++)//从-N到c扫一遍，所有小于等于c的方案都要算上 
        sum=(sum+f[i])%MOD;
    cout<<sum;
    return 0;
}
```
**拒绝代码抄袭，创建和谐洛谷！**

---

## 作者：watergod (赞：3)

## P10376 [GESP202403 六级] 游戏 题解

一道简单的 dp。

### 题目大意

给定一个数 $n$，每次你可以执行**一次操作**，将其减去 $a$ 或是 $b$。求有多少种操作方法可以使 $n<c$。（需要说明的是，如果 $a=b$，那么当 $n-a$ 和 $n-b$ 时，也算两种不同的操作）

### 题目思路

很明显能想到 dp。

首先我们需要做出判断，当 $n = c$ 时，刚开始就满足，只有一种操作。

接下来，我们定义一个数组，$dp[i]$ 表示当 $n$ 为 $i$ 时操作的种类数，即对于 $i$ 而言，有多少种操作能使其满足 $i < c$。

对于数组的初值，不难发现，当 $0 \le i \le c$ 的时候，$dp[i] = 1$。

当 $c < i \le n$ 的时候，就是需要我们进行操作的时候。实质上，对于一个数 $i$，操作就是对其进行减 $a$ 或是减 $b$。对于减 $a$，也就是 $dp[i-a]$ 的操作数，只不过是加了一个 $a$ 而已。同理，可以列出递推式：$dp[i] = (dp[i-a] + dp[i-b])$。

记得取余，不取余只有 $80$ 分。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,a,b,c;
long long f,t;
long long dp[100000001];
 
int main(){
	cin >> n >> a >> b >> c;
	if(n == c){
		cout << 1 << endl;
		return 0;
	}
	for(int i=0;i<=c;i++){
		dp[i] = 1;
	}
	for(int i=c+1;i<=n;++i){
		f = i-a;
		t = i-b;
		if(f<0){
			f = 0;
		}
		if(t<0){
			t = 0;
		}
		dp[i] = (dp[t] + dp[f]) % 1000000007;
	}
	cout << dp[n] << endl;
	return 0;
}

```

---

## 作者：wanglexi (赞：2)

[题目链接。](https://www.luogu.com.cn/problem/P10376)

考虑 dp。

定义 $dp_i (c+1\le i\le n)$ 表示从 $i$ 开始按题目中的规则减到 $i\le c$ 的方案数。

同时，对于所有 $i\le c$，都有 $dp_i=1$。

转移式：$dp_i(c+1\le i\le n)=dp_{i-a}+dp_{i-b}$。

直接按 $i$ 从 $c+1$ 到 $n$ 转移即可。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod (1000000007ll)
using namespace std;
int n,a,b,c,dp[200005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>a>>b>>c;
	for(int i=c+1;i<=n;i++){
		if(i-a<=c)dp[i]+=1;
		else dp[i]+=dp[i-a];
		if(i-b<=c)dp[i]+=1;
		else dp[i]+=dp[i-b];
		dp[i]%=mod;
	} 
	if(c==n)cout<<1; 
	else cout<<dp[n];
	return 0;
}
```

---

## 作者：2021zjhs005 (赞：2)

显然，这题可以用 dfs 解。

设 $f(n)$ 表示答案为 $n$ 方案数，则有 $f(n) = (f(n - a) + f(n - b)) \bmod (10^9 + 7)$。

然后直接 dfs 即可。

注意**记忆化**，不然会时超。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pr printf
#define Dark_Star continue
inline int read(){int s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}

const int N = 2e5 + 10 , mod = 1e9 + 7;
int n , a , b , c;
int dp[N];

inline int dfs(int x){
  if(x <= c) return 1;//x <= c，对答案的贡献为 1。
  if(dp[x] != -1) return dp[x] % mod;//记忆化。
  int val = (dfs(x - a) + dfs(x - b)) % mod;
  return dp[x] = val % mod;
}

signed main(){
  memset(dp,-1,sizeof dp);
  n = read() , a = read() , b = read() , c = read();
  pr("%lld\n",dfs(n));
  return 0;
}
```

---

## 作者：Genshin_ZFYX (赞：2)

这是一道简单 dp。

我们简化一下题面：请你对一个 $\le c$ 的数进行若干次操作，每次操作将这个数加上 $a$ 或 $b$，使最终的结果等于 $n$。

我们先把 $dp$ 数组中下标 $\le c$ 的位置都赋值为 $1$。

对于一个数 $i$，它只有可能是由 $i-a$ 加上 $a$ 或者 $i-b$ 加上 $b$ 得来的，当 $i-a$ 或 $i-b$ 小于 $0$ 的时候，将对应的数组下标赋值为 $0$。

直接摆上动态转移方程：

$$
dp[i]=dp[i-a]+dp[i-b]
$$

短短的 AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e9+7;
int dp[200005];
int main()
{
    int n,a,b,c;cin>>n>>a>>b>>c;
    for(int i=0;i<=c;i++)dp[i]=1;
    for(int i=c+1;i<=n;i++)
    dp[i]=(dp[max(i-a,0)]+dp[max(i-b,0)])%N;
	cout<<dp[n];
	return 0;
}

```

---

## 作者：Nightsky_Stars (赞：2)

# 题目大意：

你有四个正整数 $n,a,b,c$，在每一轮游戏操作中，你可以选择将 $n$ 减去 $a$，或是将 $n$ 减去 $b$，当 $n \leq c$ 时，游戏结束。求游戏结束时有多少种不同的游戏操作序列。答案对 $10^9 + 7$ 取模。

# 思路：

看到$1 \le n \le 2 \times 10^5$。爆搜肯定是过不了的，所以要 dp。

$dp[i]$ 表示 $0$ 加到 $i$ 时的方案数。

# CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[200010],mod=1e9+7;
int main(){
	int n,a,b,c;
	cin>>n>>a>>b>>c;
	dp[0]=1;
	for(int i=0;i<n-c;i++){
		if(i+a>=n-c) dp[n-c]=(dp[n-c]+dp[i])%mod;
		else dp[i+a]=(dp[i+a]+dp[i])%mod;
		if(i+b>=n-c) dp[n-c]=(dp[n-c]+dp[i])%mod;
		else dp[i+b]=(dp[i+b]+dp[i])%mod;
	}
	cout<<dp[n-c]<<"\n";
    return 0;
}
```

---

## 作者：LG086 (赞：1)

### 分析

因为 $c \le n$，所以有 $c=n$ 的可能，先进行特判。  
接下来给出数据为 `5 3 2 1` 的答案的推导过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/6hpg7l32.png)  
证明：  
![](https://cdn.luogu.com.cn/upload/image_hosting/rastfle0.png)  
_------------------------_

用一个数组存答案，一次存下 $n = i({c+1} \le i \le n)$ 时的答案。  
其中 $f_i=f_{i-a}+f_{i-b}$ 也要考虑当 $i-a$ 或 $i-b$ 小于 $0$ 的情况。  
所以用变量 $x$ 和 $y$ 记录 $i-a$ 和 $i-b$ 的值时，要转化为 $x=\max(i-a,0)$ 和 $y=\max(i-b,0)$。



------------

### 代码

```cpp
#include"bits/stdc++.h"
#define mod 1000000007
#define LG086 signed
#define int long long
using namespace std;
int n,a,b,c;
int x,y,f[1000010];
LG086 main(){
	cin>>n>>a>>b>>c;
	if(n==c)
	return cout<<1,0;
	for(int i(0);i<=c;i++)
	f[i]=1;
	for(int i=c+1;i<=n;++i){
	    x=max(i-a,0*1ll);
	    y=max(i-b,0*1ll);
	    f[i]=(f[x]+f[y])%mod;
	}
	return cout<<(f[n]%mod),0;
}
```

---

## 作者：nightwatch.ryan (赞：0)

Updated on 2024/4/30：代码贴成爆搜的了。
### 思路
我们可以用记忆化搜索来做这道题。注意到“一种操作序列选择将 $n$ 减去 $a$，而另一种操作序列选择将 $n$ 减去 $b$”这一句话。这里设 $f(x)$ 为 $x$ 的不同的游戏操作序列个数。我们可以推出公式：
$$
f(x)=f(x-a)+f(x-b)
$$
记得要对 $10^9+7$ 取模。
### 代码
```cpp
#include<iostream>
#include<map>
#define ll long long
const ll mod=1e9+7;
const ll N=200005;
ll n,a,b,c;
std::map<ll,ll>dp;
ll dfs(ll cur){
	if(dp[cur])return dp[cur];
	if(cur<=c)return 1;
	ll ans=(dfs(cur-a)%mod+dfs(cur-b)%mod)%mod;
	return dp[cur]=ans;
}
int main(){
	std::cin>>n>>a>>b>>c;
	std::cout<<dfs(n);
}
```

---

## 作者：_O_v_O_ (赞：0)

考虑 dp。

设 $dp_i$ 为数字为 $i$ 时的答案。很显然，$dp_1\sim dp_c$ 初始为 $1$。很显然，最终答案为 $dp_n$。

接下来是转移方程：

也很显然，对于一个 $i$，$dp_i=dp_{i-a}+dp_{i-b}$。

注意特判 $i\le c$ 时的情况。

---

## 作者：ACtheQ (赞：0)

这题是基础的 dp，其实就是[这题](https://www.luogu.com.cn/problem/P1255)。

只不过把步长换成了 $a,b$。

定义 dp 数组 $f$，倒着算，则：

$$f_{i-a}=f_{i-a}+f_i$$

$$f_{i-b}=f_{i-b}+f_i$$

最后答案为 $\sum_{i=1}^c f_i$

为了防止 $i-a,i-b$ 越界所以笔者采用以下写法：

```c++
f[max(0ll,i-a)]+=f[i];
f[max(0ll,i-b)]+=f[i];
```

记得取模！

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+5;
const int Mod=1e9+7;
int f[N];
signed main()
{
	int n,a,b,c;
	cin>>n>>a>>b>>c;
	f[n]=1;
	for(int i=n;i>c;i--)
	{
		f[max(0ll,i-a)]+=f[i];
		f[max(0ll,i-b)]+=f[i];
		f[max(0ll,i-a)]%=Mod;
		f[max(0ll,i-b)]%=Mod;
	}
	int ans=0;
	for(int i=0;i<=c;i++) ans+=f[i];
	cout<<ans%Mod;
	return 0;
}

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10376)
## 解题思路
记忆化搜索。

- 若 $t\le c$，返回 $1$。
- 若 $f_t\ne -1$（搜过了），返回 $f_t$。
- 否则，`f[t]=(dfs(t-a)+dfs(t-b))%mod`，并返回该值。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,a,b,c,f[200010];
int dfs(int t)
{
	if(t<=c)return 1;
	if(f[t]!=-1)return f[t];
	return f[t]=(dfs(t-a)+dfs(t-b))%mod;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>a>>b>>c;
	memset(f,-1,sizeof f);
	cout<<dfs(n);
	return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：0)

[P10376 [GESP202403 六级] 游戏](https://www.luogu.com.cn/problem/P10376)

## 题目分析

注意到对于一个数 $n$ 可以进行两种操作：减 $a$ 和减 $b$，结束条件是 $n\leq c$。并且这道题是要求方案数，我们就可以想到搜索。

设函数 $f(x)$ 为数字 $x$ 根据题目描述来进行操作的方案数，那么可以得到下面的公式：

$
f(x) = \begin{cases}
  f(x-a)+f(x-b) & x > c \\
  1 & x \le c \\
\end{cases}
$

不过普通搜索还不行，得加记忆化，毕竟 $1 \leq a,b,c \leq n \leq 2 \times 10^5$ 的数据范围摆在那呢。

于是，这道题就变成了一道简单的记忆化搜索题目，我在考场也是这么写的，过了。

**注意：一定要在过程中取模！不要忘了！**

---

## 作者：Kle1N (赞：0)

设 $x$ 的操作序列方案有 $f(x)$ 种，那么就有两个分支：$f(x-a)$ 和 $f(x-b)$。根据加法原理，可得 $f(x)=f(x-a)+f(x-b)$，递归实现即可。

但是这样会超时，不过问题也不大，因为搜索过程中会有大量重复，因此用一个记忆化数组记录答案即可。

具体见代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1000000007;
int n,a,b,c,ans[1000000];
int f(int x){
	if(x<=c){
		return 1;
	}
	int res=0;
	if(ans[x-a+200005]==-1){
		ans[x-a+200005]=f(x-a)%mod;
	}
	res=(res+ans[x-a+200005])%mod;
	if(ans[x-b+200005]==-1){
		ans[x-b+200005]=f(x-b)%mod;
	}
	res=(res+ans[x-b+200005])%mod;
	return res;
}
signed main(){
	cin>>n>>a>>b>>c;
	memset(ans,-1,sizeof ans);
	cout<<f(n)%mod;
	return 0;
}
```

---

## 作者：_weishiqi66_ (赞：0)

在一轮游戏操作中，你可以选择将 $n$ 减去 $a$，或是将 $n$ 减去 $b$。游戏将会进行多轮操作，直到当 $n \leq c$ 时游戏结束。

我们可以考虑，对于数 $c$ 加上 $a,b$ 直到大于等于 $n$ 结束的方案数。我们很容易想到，记录 $f_i$ 表示加到数 $i$ 时的方案总数。状态转移方程为 $f_i=f_{i-a}+f_{i-b}$ 。 初始$f_c=1$ 。若 $i-a \leq 0$ , $i-b \leq 0$ 可以直接按 $f_c$ 算，这样大于等于 $n$ 的情况会被直接算入到 $f_n$ 里。

---

## 作者：andyli (赞：0)

原题目可以转化为每次加 $a$ 或加 $b$ 使累计加的值不小于 $n-c$ 的方案数，则考虑动态规划，$f_i$ 表示使累加值等于 $i$ 的方案数，特别的，$f_{n-c}$ 表示使累加值不小于 $n-c$ 的方案数，则容易出状态转移方程。时间复杂度 $O(n)$。  

```cpp
int main() {
    dR(int, n, a, b, c);
    n -= c;

    using mint = MMInt1000000007;
    vc<mint> dp(n + 1, 0);
    dp[0] = 1;
    _for (i, n) {
        dp[min(n, i + a)] += dp[i];
        dp[min(n, i + b)] += dp[i];
    }
    print(dp[n]);
    return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：0)

一道十分明显的动态规划。设 $ans_i$ 为 $n=i$ 时的答案。

$$ans_i=\begin{cases}1&i\le c\\ans_{i-a}+ans_{i-b}&i>c\end{cases}$$

注意到 $i-a$ 和 $i-b$ 可能为负数，所以在进行数组运算时加上一个比 $2\times10^5$ 大的数，才能保证数组访问不会越界。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long P=2000005;
long long n,a,b,c,ans[2300005];
int main(){
	cin>>n>>a>>b>>c;
	for(int i=1;i<=c+P;i++)ans[i]=1;
	for(int i=c+1;i<=n;i++){
		ans[i+P]=(ans[i-a+P]+ans[i-b+P])%1000000007;
	}
	cout<<ans[n+P];
	return 0;
}
```

---

## 作者：I_Love_DS (赞：0)

## 思路

很好想，近似爬楼梯（但这里是从上往下走）。

### 但有一个问题

如果 $n = 2,c = 1,a = b = 2 \times 10^5$，我们会发现，$n - a$ 或 $n - b$ 会小于 $0$，而 C++ 不允许下标为负数。

### 那该怎么办？

把 $c$ 和 $n$ 同时加上 $\max(a,b)$，结果不变，也可以保证答案不变。

证明很好想：

就拿爬楼梯来说，你从 $1$ 楼爬到 $3$ 楼和你从 $2$ 楼爬到 $4$ 楼，方案数是一样的。

所以代码就出来了。（这么简单的代码就靠你了）

---


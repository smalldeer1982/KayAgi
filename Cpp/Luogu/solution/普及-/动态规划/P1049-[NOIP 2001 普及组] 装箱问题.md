# [NOIP 2001 普及组] 装箱问题

## 题目描述

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。


现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

## 说明/提示

对于 $100\%$ 数据，满足 $0<n \le 30$，$1 \le V \le 20000$。

**【题目来源】**

NOIP 2001 普及组第四题

## 样例 #1

### 输入

```
24
6
8
3
12
7
9
7
```

### 输出

```
0
```

# 题解

## 作者：vegetabird (赞：549)

这道题看似是搜索，但是可以用背包做。

题目要求求出最小的剩余空间，也就是要求出最大的可装重量

这样，我们可以将一个物体的重量当作它的价值，进而将题目转变为一个基本的01背包问题：


有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）和一个价值（等于体积）。

要求n个物品中，任取若干个装入箱内，使总价值最大。


对于每一个物体，都有两种状态：装 与不装

那么，对于任意重量m的最大价值 f (m) = max ( f ( m - w[i] ) + w[i], f (m) )（w为重量（即价值））

其中，f ( m - w[i] ) 指在装了物品i后，箱子的剩余容量能装的最大重量

f ( m - w[i] ) + w[i] 指在在装了物品i后，箱子能装的最大重量


程序如下：


```cpp
#include<cstdio>
using namespace std;
int m,n;                m即箱子容量V
int f[20010];
int w[40];
int main(){
    int i,j;
    scanf("%d%d",&m,&n);
    for(i=1;i<=n;i++){
        scanf("%d",&w[i]);
    }
    for(i=1;i<=n;i++){
        for(j=m;j>=w[i];j--){                            注意：这里必须是从m到w[i]，否则一个物体会被多次装入箱子，见例1
            if(f[j]<f[j-w[i]]+w[i]){
                f[j]=f[j-w[i]]+w[i];
            }
        }
    }
    printf("%d\n",m-f[m]);
}
```
例1：
输入：

5
1
1
假如在遍历容量m时从小到大遍历，你会发现:

```cpp
f (2) = f (2 - 1) + w[1] = f (1) +w[1] = 2
f (3) = ... = 3
f (4) = 4
f (5) = 5
最后的答案就是5-5=0，然而正解是5-1=4
```

---

## 作者：NCC79601 (赞：162)

# 我要用模拟退火来做这道题
这道题真的太没意思了，模板3分钟敲完查错都不查都能AC。~~我不会告诉你我第一次交测评把数据范围看错了甚至丢了20分~~ 所以我决定弄点其他好玩的。之前见过有仁兄直接用O(1e6)的随机跑dp得了90分，这件事给我留下了深刻的印象。然后，我受到了极大的启发。

考虑一下背包问题，我们可以很容易地发现其可以与模拟退火相类比。
至于什么是模拟退火，我~~太懒了~~无法在这里详细讲解，所以请移步[吊打XXX](https://www.luogu.org/problemnew/show/P1337)的题解，以及各大牛的CSDN博客等。这里用模拟退火做的**正确性是显然的**。

简而言之，模拟退火就是一种对贪心的优化。贪心是贪心，如果我们偶尔不贪心一下，或许就可以跳出局部最优解，然后一步步逼近全局最优解了。比如我们的背包问题，如果你随机到一个东西它放过了，如果纯粹靠贪心的话你肯定不会把它拿出看来。然而我们的模拟退火会以一定的概率把东西给拿出来，以寻找更好的解，这个概率是e^(-dE/kT)。具体怎么来的，你可以查询热力学的相关资料。反正~~就算我不知道是怎么来的~~直接用好了。

反正呢，这道题的数据范围只有30对不对，就算是面对30!的可能结果数，模拟退火依然可以坚挺如故，如果你参数调得好甚至可以直接拿去做MAXN=300的dp题。总之，**模拟退火面对这种可以用能量类比的问题的时候总是能表现出无敌的兼容性**，并且靠它**无比玄学的复杂度**鹤立鸡群，傲立于众TLE之中。

注意，我的用词是**无比玄学的复杂度**，在模拟退火里头你甚至可以利用clock()卡时间以保证不会超时，或者保证进行足够次的随机，以便更精确地找到最值。比如卡个700ms，再怎么也不会TLE了 XD

---
下面是代码。

```cpp
#include<bits/stdc++.h>
#define MAXN 40 //第一次把MAXN看成20，结果WA了20分orz
#define Tk 0.99789 //降温系数，可调，调得好可上天入地
#define rd (rand() % n + 1)
using namespace std;

int v[MAXN];
int V, n, ans = 0, tot = 0;
bool vis[MAXN];
double T = 1926; //初温，大部分模拟退火用这个初温都能AC

bool accept(int del) {
    return ((del>0)||exp(del/T) > (double)rand()/RAND_MAX);
} //转移概率表达式

int main() {
    srand(time(0));
    scanf("%d%d", &V ,&n);
    for(int i=1; i<=n; i++) 
        scanf("%d", &v[i]);
    int a;
    memset(vis, 0, sizeof(vis));
    while(T > 1e-14) {
        ans = ans<tot ? tot : ans; //维护最优答案，以防非酋情况发生
        a = rd; //进行随机
        int dE = v[a];
        if(vis[a]) dE *= -1; //产生能量差
        if(accept(dE)) { //以概率发生转移
            if(vis[a]) {
                vis[a] = false;
                tot -= v[a];
            }else{
                if(tot + v[a] > V) continue;
                vis[a] = true;
                tot += v[a];
            }
        }
        T *= Tk; //降温
    }
    cout << V - ans;
    return 0;
}

```
洗把脸就AC了(逃

---

## 作者：Mignon (赞：16)

此题采用枚举法，~~大概可能也许~~会超时。所以很容易想到采用**背包**的思想。这样就有了两种思路。

------------
1.题目求使箱子的剩余空间最小的情况，那么就让箱子空间最小呗。于是得到状态转移方程：

	f[m][n] = min( f[v][n-1] , f[v-a[n]][n-1] ) ;
    
现在就可以编程了，我采用递归+二维数组+记忆化搜索的方法，看一下代码：

```cpp
#include<bits/stdc++.h>
using namespace std ;
int a[400] , o[20010][310] ;
int dpp( int v , int n ) ;
 
int main()
{
	memset( o , -1 , sizeof(o) ) ;
	int v , n ; // v为箱子容量（0≤v ≤20000），n为物品数量（0 < n ≤300）
	cin >> v >> n ;
	for( int i = 1 ; i <= n ; i ++ )
		cin >> a[i] ;
	cout <<	dpp(v,n) ;
	return 0 ;
}

int dpp( int v , int n )
{
	if( n == 0 ) return v ;
	if( o[v][n] != -1 ) return o[v][n] ;
	if( v < a[n] ) return dpp(v,n-1) ;
	return o[v][n] = min( dpp(v,n-1) , dpp(v-a[n],n-1) ) ;
}
```

------------
2.题目求使箱子的剩余空间最小的情况，相当于求箱子容量减箱子剩余空间最大的情况。状态转移方程：

	f[j]=max(f[j],f[j-w[i]]+w[i]);
    
看代码：
```cpp
#include<bits/stdc++.h>
using namespace std ;
int a[400] , f[20000] ; 
int main()
{
	int v , n ; // v为箱子容量（0≤v ≤20000），n为物品数量（0 < n ≤300）
	cin >> v >> n ;
	for( int i = 1 ; i <= n ; i ++ )
		cin >> a[i] ;
	for( int i = 1 ; i <= n ; i ++ )
	{
		for( int j = v ; j >= a[i] ; j -- )
		{
			if( f[j] <= v )
				f[j] = max( f[j] , f[j-a[i]] + a[i] ) ;
			if( f[j] == v )
			{
				cout << "0" ;
				return 0 ;
			} 
		}
	}
	cout << v - f[v] ;
	return 0 ;
}
```




---

## 作者：MuelsyseU (赞：13)

~~01背包，完~~

**我写这篇题解，其实主要是由于一个BUG。但我发现众dalao基本上不用二维数组，似乎并未发现这个二维专有的BUG。于是干脆写出一篇了。**

------------

这道题是很经典的01背包，但不同之处是问题要求“最小剩余容量”。

01背包是典型的“求最大价值”的~~水~~题型，而此题的“最小剩余容量”，亦可转换为“最大可用容量”。

此时，我们发现此处的“重量”同“价值”相类似了，则以 w[i] 代替 v[i]，转化为01背包。

不知道01背包也没有关系，只要明白动规基本思想就能推出方程了。

------------

貌似众dalao均用了一维数组，这边还是先开二维，到时再压缩作一维。

设$f[i][j]$表示对于前$i$个物品在容量为$j$时的最大容量。

如何推出$f[i][j]$呢？考虑对第$i$个物品，可取或不取。

若不取，则$f[i][j]$与$f[i-1][j]$完全相同；

若取，则至少需$w[i]$的空间，至多剩余$j-w[i]$的空间，以换取$w[i]$的价值。由此可由$f[i-1][j-w[i]]+w[i]$推出。

则最终状态转移方程为：$f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+w[i])$

结果输出$V-f[N][V]$即可。

------------

这里提前提一下压缩到一维的方法。因为对每个$f[i][]$都仅由$f[i-1][]$推出，则可删除一维，仅使用$f[j]$。

为什么现在提出，因为这样自动消除了使用二维数组时状态无法转移的问题。

考虑以下代码：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int x,f[32][20010];
int main(){
	int n,m;
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		for(int j=m;j>=x;j--){
			f[i][j]=max(f[i-1][j],f[i-1][j-x]+x);
		}
	}
	cout<<m-f[n][m];
	return 0;
} 
```

其中，$x$为本人的~~怪癖~~专门~~无用~~优化，即仅使用一个变量取代整个$w[]$。

好，那么这段代码此时看来十分正确。

其实它确实也十分“正确”，完整地实现了刚才推出的方程。

可是仅有$60$分。

为什么？考虑以下数据：
```
5
3
1
2
6
```
以上数据由于$6$无法放入，很容易得出结果$5-1-2=2$。

但是程序输出的结果为$5$。

原因其实也很简单。考虑 for(int  j=m;j>=x;j--)，可以发现此处$j$的遍历是从$m$到$x$，但当$x>m$时，循环完全不被执行。这样，$f[n][]$全部为$0$，自然得到$5-0=5$的结果。

由此，我们可以发现，应进行必要的提前操作，使无论如何状态都能继续传递。例如下列代码：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int x,f[32][20010];
int main(){
	int n,m;
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		for(int j=0;j<=m;j++){
			f[i][j]=f[i-1][j];
		}
		for(int j=m;j>=x;j--){
			f[i][j]=max(f[i-1][j],f[i-1][j-x]+x);
		}
	}
	cout<<m-f[n][m];
	return 0;
} 
```

可发现程序输出正常了。此为AC代码。

------------

~~众：可是你既然知道怎么压缩到一维，为什么还要修二维的BUG呢？~~

一维压缩不是本文主题，浏览即可。

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int x,f[20010];
int main(){
	int n,m;
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		for(int j=m;j>=x;j--){
			f[j]=max(f[j],f[j-x]+x);
		}
	}
	cout<<m-f[m];
	return 0;
} 
```

---

## 作者：如履薄冰 (赞：8)

# 前言
逛了逛题解区，没有发现用深搜写的。今天我来给大家提供一个深搜解法。
# 解法
我们可以使用一个变量来维护答案，在每次深搜的时候都拿现在剩下的空间与目前的答案相比。如果现在剩下的空间比答案小，就把答案设为现在剩下的空间。如何在深搜的过程中存储现在剩下的空间呢？我们可以直接把现在剩下的空间设为深搜函数中的一个参数。
## 如何深搜
### 深搜函数中的参数
第一个参数就是我们当前要处理的物品的编号。处理完当前物品后就处理下一个物品，即将当前要处理的编号加一。如果当前要处理的编号不合法，就直接返回。第二个参数就是现在剩余的空间，这里我就不再细讲了，因为我已经在上文中讲过了。
### 深搜的步骤
首先，我们先不管三七二十一，直接不要当前的物品，深搜下去。深搜完不要这个物品的情况后，我们来判断一下现在能不能装当前的物品，即判断现在的空间是否大于等于当前物品的重量。如果现在能装下这个物品，我们就来深搜要这个物品的情况。请注意，如果你要装现在的物品，那你就要从你现在剩余的空间中扣除这个物品的重量。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int V,n,a[1100000],ans=0x3f3f3f3f;
void dfs(int cur,int leftw){
	ans=min(ans,leftw);
	if(cur==n+1){
		return;
	}
	dfs(cur+1,leftw);
	if(a[cur]<=leftw){
		dfs(cur+1,leftw-a[cur]);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>V>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	dfs(1,V);
	cout<<ans;
	return 0;
}
```

---

## 作者：zltqwq (赞：4)

# 解法
这道题明显是 01 背包问题。能否用回溯解决呢？让我们看一看： $0 < n \le 30$，用回溯不会超时。我们只需要查看装了当前这个物品后箱子的重量有没有超过箱子的最大容量。如果没有超过，就枚举装这个物品的所有情况，反之不枚举。之后我们再枚举不装这个箱子的所有情况，这个回溯就只差一个最简子问题啦。如果当前要判断的箱子编号大于箱子的个数，就说明我们枚举到最简子问题了。我们更新一下答案再返回即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int v,n,a[1000001],ans=1e9;
void dfs(int c,int curw){
	if(c==n+1){
		ans=min(ans,v-curw);
		return;
	}
	if(curw+a[c]<=v){
		dfs(c+1,curw+a[c]);
	}
	dfs(c+1,curw);
	return;
}
int main(){
	cin>>v>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	dfs(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：sea_bird (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1049)。

# 题目分析

学 DP 的优化快哭了，来写一篇比模板更详细一点的 01 背包题解。

这道题就是 01 背包的模板，什么是 01 背包呢？

> 01 背包是在 $M$ 有限件物品中取出若干件放在空间为 $W$ 的背包里，每件物品的体积为 $W_1$ 至 $W_n$，与之相对应的价值为 $P_1$ 至 $P_n$。求最小代价能取到物品的最大价值。

很明显，这道题简直就是按照这个定义出的。

## 思路

背包问题是动态规划问题，动态规划是**一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法**。划分出的每个子问题，通过一个公式，也就是状态转移方程联系起来，最后得到全局最优解。

## 做法

首先解这道题，求的是容器最小剩余，也就是说求能装入容器中最大重量，先设状态，在代码中将状态设为 `f[i][j]`，意思是当放到第 $i$ 个物品时，容量为 $j$ 的背包所能达到的重量最大值。

接下来推出核心，状态转移方程，假设当前是第 $i$ 个物品，上一位便是第 $i-1$ 个。那么不选择放入新的物品，那么此时的最大值代码表示为 `f[i][j]`。当其放入背包时，背包的剩余的容量减小，当前最大价值增加，用数组来表示就是，`f[i-1][j-w[i]]+w[i]`。因此得到用代码表示的方程 `f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+w[i])`。

## 优化

经过上面的推论可以发现，$f_i$ 的值只与 $f_{i-1}$ 有关，因此可以用 $f_i$ 来表示当前物品时背包容量为 $i$ 的最大价值，从而变成一维数组，而优化后的方程用代码表示就是 `f[j]=f[j-w[i]]+w[i]`。

附上一维优化运用滚动数组的代码。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std ;
const int N=1e8;
int w[N],f[N];
int main ()
{
  int n,m;
  cin>>m>>n;
  for(int i=1;i<=n;i++){
	cin>>w[i];
  }
  for(int i=1;i<=n;i++){
	for(int j=m;j>=w[i];j--){
		if(f[j-w[i]]+w[i]>f[j]){
			f[j]=f[j-w[i]]+w[i];
		}
	}
  }
  cout<<m-f[m]<<endl;
  return 0;
}
```

如果有没讲清的，欢迎补充。

---

## 作者：chrispang (赞：1)

## 题目大意

给定一个背包和 $n$ 中物品，背包容量为 $V$。可以往背包里装一些东西，使背包的剩余空间最小。求出这个最小值。

## 题目分析

看似不能使用 01 背包来做，但我们可以把物品的体积当成重量和价值。这样就转化成了 01 背包问题啦！

- **状态**：定义 $f_{i\ j}$ 为考虑前 $i$ 个物品，容量为 $j$，能装下的最多体积。
- **状态转移方程**：仿照 01 背包的转移方程，在这里我们只需要把体积当作价值就可以了。
```cpp
if(j >= a[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - a[i]] + a[i]); //找到最大体积
else f[i][j] = f[i - 1][j]; //如果装不下就复制前面的
```
- **初始化**：背包容量为 $0$ 时，什么物品都放不下。因此，初始化为 $f_{i\ 0}=0$。
- **答案**：仿照 01 背包，最终的答案为 $V-f_{n\ V}$。
```cpp
#include <bits/stdc++.h>
#define V 20010
#define maxn 35
using namespace std;

int n, m;
int f[maxn][V], a[maxn];
int main() {
	cin >> m >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		f[i][0] = 0; //初始化 
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if(j >= a[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - a[i]] + a[i]); //找到最大体积
			else f[i][j] = f[i - 1][j]; //如果背包容量转不下就复制前面的
	cout << m - f[n][m] << endl; //最后剩余的空间：原有的背包熔炼-最终可以装下的最多体积
    return 0;
}
```
点个赞吧！球球啦！

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1049)
## 分析
### 题意
有 $n$ 个具有一定体积物品和一个容量为 $V$ 的箱子，求箱子装了物品之后剩余最小的空间是多少。
### 考察内容
本题考查动态规划和 01 背包。
### 解析
剩余空间最小，也就是要用尽量多的空间。那么我们可以套用 01 背包来做：输入，然后用数组 $thingright$ 来表示每件物品的体积，用数组 $nowright$ 来表示在这个容积下的背包能够最多装多少空间。

更多注释见代码。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int thingweight[10086100],nowweight[10086100];
int main()
{
	int n,m;
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>thingweight[i];
	}
	/*输入*/ 
	for(int i=1;i<=n;i++)//枚举每一件物品 
	{
		for(int j=m;j>=thingweight[i];j--)//枚举。从最大值开始一直枚举到底，nowweight[]表示背包被占用面积的最大值 
		{
			if(nowweight[j-thingweight[i]]+thingweight[i]>nowweight[j])//nowweight[j]表示原来的背包被占用面积的最大值；nowweight[j-thingweight[i]]+thingweight[i]表示在装了物品i后，箱子能装入的最大重量 
			{
				nowweight[j]=nowweight[j-thingweight[i]]+thingweight[i];//更新 
			}
		}
	}
	cout<<m-nowweight[m]<<endl;//输出原容量减去被占用的最大容量 
}
```

---

## 作者：guoxinda (赞：1)

## 思路
这题可以用搜索做。我们枚举每个箱装 / 不装两种情况就可以了。\
在搜完 $n$ 个物品后，我们累计这个情况装的箱子的总重量，如果没超重就比较箱子剩余空间的最小值。
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[1000010],x=0,ans=1e9,sum;//答案初始化为极大值 
bool v[1000010];
void dfs(int cur){
	if(cur==m+1){//搜完了 
		if(x<=n)ans=min(ans,x-n);
		return ;
	}
	if(x<n){
		x+=a[cur];//当前总和 
		v[cur]=1;
		dfs(cur+1);
		x-=a[cur];//回溯 
	}
	v[cur]=0;//不装 
	dfs(cur+1);
}
int main(){ 
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	dfs(1);
	cout<<ans;
	return 0; 
}
```

---

## 作者：qhr2023 (赞：1)

## solution

经典 01 背包模板。

记 $w_i$ 表示物品 $i$ 的体积，即物品 $i$ 占用的背包容量，也是 $i$ 的价值。设 $f_{i, j}$ 表示前 $i$ 个物品容量为 $j$ 的背包的最大价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量和总价值都不变，故这种情况的最大价值为 $f_{i-1, j}$；当其放入背包时，背包的剩余容量会减小 $w_i$，背包中物品的总价值会增大 $w_i$，故这种情况的最大价值为 $f_{i-1, j-w_i}+w_i$。

综上，转移是 $f_{i, j}=\max(f_{i-1, j}, f_{i-1, j-w_i}+w_i)$。

由于对物品 $i$ 影响的只有物品 $i-1$，所以我们可以去掉一维，用 $f_j$ 表示容量为 $j$ 的背包的最大价值，转移是 $f_j=\max(f_j, f_{j-w_i}+w_i)$。

最后我们注意枚举顺序，是从大到小的，否则则会出现一个物品多次放入背包的情况。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int V, n, a[31], f[20001];
int main(){
	cin >> V >> n;
	for(int i=1; i<=n; i++)
		cin >> a[i];
	for(int i=1; i<=n; i++)
		for(int j=V; j>=a[i]; j--)
			f[j]=max(f[j], f[j-a[i]]+a[i]);
	cout << V-f[V];
	return 0;
}
```

---

## 作者：ridewind2013 (赞：0)

## 思路

[01 背包](https://blog.csdn.net/qq_37767455/article/details/99086678)模板题，递推式为 $dp_{j}=\max(dp_{j},dp_{j-c_{i}}+c_{i})$，知道了递推式，这道题就很简单了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[20010],c[40];
int main(){
	int t,n;
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=n;i>=1;i--)for(int j=t;j>=c[i];j--)dp[j]=max(dp[j],dp[j-c[i]]+c[i]);
	cout<<t-dp[t];
	return 0;
}

```

---

## 作者：FXLIR (赞：0)

### 思路
[0-1 背包](https://oi-wiki.org/dp/knapsack/#0-1-%E8%83%8C%E5%8C%85)的简单应用。

将“使箱子的剩余空间最小”，其实就是“使箱子的被占用空间最大”，即让箱子被占用的空间最大化。

空间最大化？不难想到，在普通的背包问题中，我们所求的是“价值最大化”。如何将“空间最大化”转为“价值最大化”？

我们可以给每个物品定义一个“价值”——将体积为 $x$ 的物品的价值定义为 $x$。然后，就可以将原问题转化为 0-1 背包模板题，直接套模板求解即可。

注意输出的是箱子的最小剩余空间。

### 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=35,M=2e4+5,INF=1e9;
int v,n,w[N],c[N],f[M];
signed main(){
	cin>>v>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i];
		c[i]=w[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=v;j>=w[i];j--){
			f[j]=max(f[j],f[j-w[i]]+c[i]);
		}
	}
	cout<<v-f[v];
	return 0;
} 
```

---

## 作者：松鼠党 (赞：0)

我的做法比较神奇。  
虽说我做出来了，但我都不确定是不是dp做法。  
先将体积按升序排一遍，f数组记录达到当前体积时使用的最大的物品编号最小，这样可以确保达到当前体积时使用的物品最优。  
上代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,v;
int a[40],f[20010];
int main(){
	cin>>v>>n;
	for(int i=1;i<=n;i++)
	    cin>>a[i];//读入
	sort(a+1,a+n+1);//排序
	f[0]=1;
	for(int i=1;i<=n;i++){
		if(a[i]==a[i-1])
		   continue;
		f[a[i]]=i;
	}//初始化，f[0]=1可以确保有输出
	for(int i=1;i<=v;i++){
		if(f[i]==0)
		   continue;//若当前体积无解直接跳
		for(int j=f[i]+1;j<=n&&i+a[j]<=v;j++)
	    	if((f[i+a[j]]==0||f[i+a[j]]>j))//判断，若当前体积无解直接替换，不是最优也替换
	    	   f[i+a[j]]=j;//勉强叫动态转移吧（手动滑稽）
	    if(f[v]!=0)
	       break;//一个小小的剪枝，无伤大雅
	}
	for(int i=v;i>=0;i--)//扫一遍
	    if(f[i]!=0){
	    	cout<<v-i<<endl;//输出，game over~~
	    	break;
		}
	return 0;
}
```
好了，第三篇题解

---


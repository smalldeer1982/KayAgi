# [JOIG 2024] 座席 2 / Seats 2

## 题目描述

今年，JOI 国将主办 IOI（国际信息学奥林匹克竞赛）。届时将有 $N$ 名选手参赛，编号从 $1$ 到 $N$。

每位选手的国籍由一个介于 $1$ 和 $10^9$ 之间的整数表示：选手 $i(1\le i\le N)$ 来自国家 $C_i$。保证 $N$ 个选手的国籍**不完全相同**（即存在 $i\ne j(1\le i,j\le N)$ 使得 $C_i\ne C_j$）。

选手的座位排成一条直线，选手 $i(1\le i\le N)$ 的座位在 $X_i$ 处。选手 $i(1\le i\le N)$ 和选手 $j(1\le j\le N)$ 之间的**座位距离**为 $|X_i-X_j|$。

每个选手都想知道在与其他选手交流时，与离自己最近的异国选手的座位距离。

给定每个选手的国籍和座位位置，请为每个选手 $i(1\le i\le N)$ 求出与其来自不同国家的选手中，座位离选手 $i$ 最近的选手与 $i$ 的座位距离。

## 说明/提示

#### 【样例解释 #1】

- 选手 $1$ 来自国家 $2$，选手 $2, 3$ 和他 / 她来自不同国家。在这些选手中，与选手 $1$ 座位距离最小的是选手 $3$，座位距离为 $3$。因此，答案为 $3$；
- 选手 $2$ 来自国家 $1$，选手 $1$ 是唯一和他 / 她来自不同国家的选手。选手 $2$ 和选手 $1$ 之间的座位距离为 $4$；
- 选手 $3$ 来自国家 $1$，选手 $1$ 是唯一和他 / 她来自不同国家的选手。选手 $3$ 和选手 $1$ 之间的座位距离为 $3$。

该样例满足子任务 $1,2,3$ 的限制。

#### 【样例解释 #2】

该样例满足子任务 $1,2,3$ 的限制。

#### 【样例解释 #3】

该样例满足子任务 $1,2,3$ 的限制。

#### 【数据范围】

- $2\le N \le 3\times 10^5$；
- $1\le C_i\le 10^9(1\le i\le N)$ 且 $C_i$ 不完全相同；
- $1\le X_i\le 10^9(1\le i\le N)$。

#### 【子任务】

1. （$20$ 分）$N\le 1000$；
2. （$40$ 分）$C_i\le 10(1\le i\le N)$；
3. （$40$ 分）无附加限制。

## 样例 #1

### 输入

```
3
2 5
1 1
1 2```

### 输出

```
3
4
3```

## 样例 #2

### 输入

```
5
1 1
2 4
2 14
3 10
2 2```

### 输出

```
1
3
4
4
1```

## 样例 #3

### 输入

```
3
1 1
2 1
1 1```

### 输出

```
0
0
0```

# 题解

## 作者：queenbee (赞：4)

# P11200 [JOIG 2024 Open] 座席 2 / Seats 2 题解
## 思路
[题目传送门](https://www.luogu.com.cn/problem/P11200)，先将每个选手按照座位号增序排列，对于每个选手，距离他最近的不同籍选手可能在左侧或右侧。

经增序排列后，第 $i$ 名选手的左侧最近选手为 $i-1$，右侧最近选手为 $i+1$，国籍为 $c_i$，座位为 $x_i$，编号为 $num_i$，与最近的不同籍选手距离为 $dis_i$，赋 $dis_i$ 初值为极大值。

先对左侧进行考虑，第 $i$ 名选手与第 $i-1$ 名选手有同籍或不同籍两种情况。若不同籍，则 $dis_{num_i}$ 更新为其与第 $i-1$ 名选手的距离；若同籍，则 $dis_{num_i}$ 更新为与第 $i-1$ 名选手距离 $+dis_{num_{i-1}}$。

则有递推式：

$dis_{num_{i}} = \begin{cases}\min(dis_{num_{i}},x_i-x_{i-1}) &\text{if } c_i  \neq c_{i-1} \\ \min(dis_{num_{i}},dis_{num_{i-1}}+x_i-x_{i-1}) &\text{if } c_i=c_{i-1} \end{cases}$

右侧与左侧思路基本相同，有递推式：

$dis_{num_{i}} = \begin{cases}\min(dis_{num_{i}},x_{i+1}-x_i) &\text{if } c_i  \neq c_{i+1} \\ \min(dis_{num_{i}},dis_{num_{i+1}}+x_{i+1}-x_i) &\text{if } c_i=c_{i+1} \end{cases}$

对左右侧分别遍历，得出答案。

## 程序
```
#include<bits/stdc++.h>	//我爱万能头 
using namespace std;
const int N=3e5+10;
int n;
int dis[N];
struct Node{
	int num,c,x;
}f[N];
bool cmp(Node a,Node b){
	return a.x<b.x;
}
int main(){
	memset(dis,0x3f,sizeof(dis));	//赋初值 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>f[i].c>>f[i].x; 
		f[i].num=i;	//排序后编号会改变，优先记录编号 
	}
	sort(f+1,f+n+1,cmp);	//增序排列 
	for(int i=2;i<=n;i++){	//遍历左侧 
		if(f[i].c!=f[i-1].c){
			dis[f[i].num]=min(dis[f[i].num],f[i].x-f[i-1].x);
		}
		else{
			dis[f[i].num]=min(dis[f[i-1].num]+f[i].x-f[i-1].x,dis[f[i].num]);
		}
	}
	for(int i=n-1;i>=1;i--){	//遍历右侧 
		if(f[i].c!=f[i+1].c){
			dis[f[i].num]=min(dis[f[i].num],f[i+1].x-f[i].x);
		}
		else{
			dis[f[i].num]=min(dis[f[i+1].num]+f[i+1].x-f[i].x,dis[f[i].num]);
		}
	}
	for(int i=1;i<=n;i++){
		cout<<dis[i]<<"\n"; 
	}
	return 0;	//完结撒花 
}
```

---

## 作者：Aventurine_stone (赞：3)

## 1. 题目分析
题目简述：对于每一个人，找到离他最近且和他不是同一个国家的人。  
不会有人用数据结构吧，那太复杂了，其实可以线性扫描的。
## 2. 题目做法
对于每个人，我们只需要记录在这个人前面与其不同国籍且最近的人，和在这个人后面与其不同国籍且最近的人。  
首先要以位置为关键字进行排序，之后正反分别扫一遍，先将第一个位置的值存进数组，之后若国籍与数组中的国籍相同，则将其也存进数组，否则我们就找到了在这一边与这个数组内的人不同国籍且离他们最近的人，然后再将这个不同国籍的人放进空数组中。一直扫直到尽头即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int n;
struct P{
	int id,c,x;
}a[N];
inline bool cmp(P a1,P a2)
{
	return a1.x<a2.x;
}
int l[N],r[N];
int c[N],cnt,t,ans[N];
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]={i,read(),read()};
	sort(a+1,a+n+1,cmp);
	c[++cnt]=1;
	for(int i=2;i<=n;i++)
	{
		if(a[c[1]].c==a[i].c)
			c[++cnt]=i;
		else
		{
			while(cnt)
				r[c[cnt]]=i,cnt--;
			c[++cnt]=i;
		}
	}
	cnt=0;
	c[++cnt]=n;
	for(int i=n-1;i>=1;i--)
	{
		if(a[c[1]].c==a[i].c)
			c[++cnt]=i;
		else
		{
			while(cnt)
				l[c[cnt]]=i,cnt--;
			c[++cnt]=i;
		}
	}
	for(int i=1;i<=n;i++)
	{
		t=INT_MAX;
		if(l[i])
			t=a[i].x-a[l[i]].x;
		if(r[i])
			t=min(t,a[r[i]].x-a[i].x);
		ans[a[i].id]=t;
	}
	for(int i=1;i<=n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：yangdezuo (赞：2)

# 题意
输出座位离选手 $i$ 最近的选手与 $i$ 的座位距离。

# 思路
要找到最近的距离，如果先对距离排序，对每一位选手左右两边找的话，时间复杂度 $O(n^2)$，但由于 $1\leqslant n\leqslant 3\times 10^5$，必然会超时。

那我们就要先对距离预处理，先对距离排序就不用说了，最终目的是比较左右非本国人的距离取最小值。

以找右边为例：

- 如果一个人右边的人不是本国人，最小值为和这个人之间的距离。
- 反之，最小值是这人和右边最近的非本国人之间的距离加上和这人之间的距离。

这样子的时间复杂度就是 $O(n \log n)$ 了。

**坑点：** 处理完之后要将数组重新按原位置排好（为了输出）。

# 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,f1[300005],f2[300005];
map<int,vector<int>>m;
struct node{
	int c,x,i,ii;
}a[300005];
bool cmp1(node x,node y){
	return x.x<y.x;
}
bool cmp2(node x,node y){
	return x.i<y.i;
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].c>>a[i].x,a[i].i=i;//记录序号1
	sort(1+a,1+a+n,cmp1);
	for(int i=1;i<=n;i++) a[i].ii=i;//记录序号2
	memset(f1,0x3f,sizeof(f1));//初始化
	memset(f2,0x3f,sizeof(f2));
	for(int i=2;i<=n;i++){//左
		if(a[i].c!=a[i-1].c) f1[i]=min(f1[i],a[i].x-a[i-1].x);
		else f1[i]=min(f1[i],f1[i-1]+a[i].x-a[i-1].x);
	}
	for(int i=n-1;i>=1;i--){//右
		if(a[i].c!=a[i+1].c) f2[i]=min(f2[i],+a[i+1].x-a[i].x);
		else f2[i]=min(f2[i],f2[i+1]+a[i+1].x-a[i].x);
	}
	sort(1+a,1+a+n,cmp2);//重新按原始顺序排好
	for(int i=1;i<=n;i++)
		cout<<min(f1[a[i].ii],f2[a[i].ii])<<"\n";//比较左右，取小的
}
```

---

## 作者：Luogu_916767 (赞：1)

[In Luogu](https://www.luogu.com.cn/problem/P11200)

### 题目大意

输入 $n$ 个人的位置和国籍，求离第 $i$ 个人最近的、与第 $i$ 个人国籍不相同的人与第 $i$ 个人之间的距离。

### 思路分析

动态规划，$dp1_i$表示 $i$ 左边最近的一个与 $i$ 不同国籍的人。同理，$dp2_i$表示 $i$ 右边最近的一个与 $i$ 不同国籍的人。然后对于每个 $i$ 求他左边最近和右边最近的之间相差的距离。

思路有了，接下来看转移。

对于第 $i$ 个人，若他左边的人与他国籍相同，则 $dp1_i = dp1_{i-1}$，否则 $dp1_i = i-1$。右边同理。 

### Code

代码较丑，大佬勿喷。

```cpp
#include<bits/stdc++.h>

using namespace std;

int n;
struct node{
    int da,x,id;
    int dp1,dp2;
}a[300005];

bool cmp(node a,node b){
    return a.x < b.x;
}

bool cmp2(node a,node b){
    return a.id < b.id;
}

int main(){
    cin>>n;
    for(int i = 1; i <= n; i ++ ){
        cin>>a[i].da>>a[i].x;
        a[i].id = i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i = 2; i <= n; i ++ ){
        if(a[i].da == a[i-1].da){
            a[i].dp1 = a[i-1].dp1;
        }else{
            a[i].dp1 = a[i-1].id;
        }
    }
    for(int i = n-1; i >= 1; i -- ){
        if(a[i].da == a[i+1].da){
            a[i].dp2 = a[i+1].dp2;
        }else{
            a[i].dp2 = a[i+1].id;
        }
    }
    sort(a+1,a+n+1,cmp2);
    for(int i = 1; i <= n; i ++ ){
        int ans = 0x3f3f3f3f;
        if(a[i].dp1 != 0)ans = min(ans,abs(a[i].x-a[a[i].dp1].x));
        if(a[i].dp2 != 0)ans = min(ans,abs(a[i].x-a[a[i].dp2].x));
        cout<<ans<<"\n";
    }
    return 0;
}
```

---

## 作者：shy_lihui (赞：1)

动态规划入门好题。

## 思路分析

定义 $dp1[i]$ 表示第 $i$ 个人左边最近不同国籍的人的编号。

定义 $dp2[i]$ 表示第 $i$ 个人右边最近不同国籍的人的编号。

先看左边：

如果这位左边与自己不同国籍那就直接是两位的距离。同国籍就是左边那个人距离最近不同国籍的人的距离加上自己的距离，所以左边的转移方程：

$$
dp1[i]= \begin{cases}
  dp1[i-1]+ \vert x_i-x_{i-1} \vert & c_i = c_{i-1 }\\
  \vert x_i-x_{i-1} \vert & c_i \ne c_{i-1 }
\end{cases}
$$


左边同理：


$$
dp2[i]= \begin{cases}
  dp2[i-1]+ \vert x_i-x_{i+1} \vert & c_i = c_{i+1 }\\
  \vert x_i-x_{i+1} \vert & c_i \ne c_{i+1 }
\end{cases}
$$
注意你要保持无后效性。

---

## 作者：篮网总冠军 (赞：1)

简单 dp 题。

先按位置排序。

我们首先枚举一个人左边最近的非本国人的距离，再枚举一个人右边最近的非本国人的距离，取较小值即可。

因为两种情况差不多，我们以枚举左边为例。

左边分为两种情况：

+ 一个人左边的人是外国人，最短距离为和这个外国人之间的距离。

+ 一个人左边的人是本国人，最短距离是这个本国人和左边最近的外国人的距离加上和和这个本国人之间的距离。

右边同理。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
	int gj,wz,bh,bh1; 
}a[300005];
int ans1[300005],ans2[300005];
bool cmp(node x,node y){
	return x.wz<y.wz;
} 
bool cmp1(node x,node y){
	return x.bh1<y.bh1;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].gj>>a[i].wz;
	for(int i=1;i<=n;i++) a[i].bh1=i;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++) a[i].bh=i;
	for(int i=1;i<=n;i++){
		ans1[i]=1e9;
		if (a[i-1].gj==a[i].gj) ans1[i]=min(ans1[i],ans1[i-1]+a[i].wz-a[i-1].wz);
		else ans1[i]=min(ans1[i],a[i].wz-a[i-1].wz);
		ans1[1]=1e9;
	}
	for(int i=n;i>=1;i--){
		ans2[i]=1e9;
		if (a[i+1].gj==a[i].gj) ans2[i]=min(ans2[i],ans2[i+1]+a[i+1].wz-a[i].wz);
		else ans2[i]=min(ans2[i],a[i+1].wz-a[i].wz);
		ans2[n]=1e9;
	}
	sort(a+1,a+1+n,cmp1);
	for(int i=1;i<=n;i++){
		cout<<min(ans1[a[i].bh],ans2[a[i].bh])<<endl;
	}
	return 0;
}
```

---

## 作者：ARIS1_0 (赞：1)

思路还是比较简单的，就看代码怎么实现了。

先考虑按坐标关键字进行排序。随后对于每一个学生，我们使用两个变量来分别记录离其左边和右边**第一个国籍不同**的学生的距离，变量的更新显然是 $O(n)$ 的，从左往右和从右往左分别扫一遍即可。最后输出的时候取两者中较小的一个即可。

需要注意的是我们要按输入顺序输出，所以还需要额外开一个记录读入次序的变量最后排回去，时间复杂度 $O(n\log n)$。

为什么这个做法是对的，因为排序后坐标具有单调性，所以离自己第一个国籍不同的学生的距离一定是最小的。

```cpp
int n;
struct node{
	int pos,c,id,Ldis,Rdis;
	bool operator <(const node &x){
		return pos<x.pos;
	}
}a[300005];
bool cmp(node x,node y){return x.id<y.id;}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i].c=read();
		a[i].pos=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	a[1].Ldis=a[n].Rdis=0x3f3f3f3f;//注意左右端点赋值为无穷大
	for(int i=2;i<=n;i++){
		if(a[i].c!=a[i-1].c)a[i].Ldis=a[i].pos-a[i-1].pos;//如果国籍不同则计算距离
		else a[i].Ldis=a[i-1].Ldis+(a[i].pos-a[i-1].pos);//如果国籍相同就加上离这个学生的距离即可
	}
	for(int i=n-1;i;i--){//同理
		if(a[i].c!=a[i+1].c)a[i].Rdis=a[i+1].pos-a[i].pos;
		else a[i].Rdis=a[i+1].Rdis+(a[i+1].pos-a[i].pos);
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)write(min(a[i].Ldis,a[i].Rdis));
	return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P11200 题目](https://www.luogu.com.cn/problem/P11200)

### 解题思路
定义 $dp_i$ 表示座位在第 $i$ 位选手左边的离自己最近的异国选手的座位距离。

先将数组按座位从左到右排序，显然当 $c_i\not=c_{i+1}$ 时，$dp_i=x_i-x_{i-1}$，当 $c_i=c_{i+1}$ 时，$dp_i=dp_{i-1}$。

右边离自己最近的异国选手的距离同理，最后左右两边取最小值即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct op
{
	int first;
	int second;
	int h;
	int ans;
}pr[300001];
int dp1[300001],dp2[300001];
inline bool cmp(op a,op b)
{
    return a.first<b.first;
}
inline bool cmp2(op a,op b)
{
	return a.h<b.h;
}
signed main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>pr[i].second>>pr[i].first,pr[i].h=i;
	sort(pr+1,pr+n+1,cmp);
	dp1[1]=1e9+1,dp2[n]=1e9+1;
	for(int i=2;i<=n;i++)
	{
		dp1[i]=pr[i].first-pr[i-1].first;
		if(pr[i].second==pr[i-1].second)
			dp1[i]+=dp1[i-1];
	}
	for(int i=n-1;i>=1;i--)
	{
		dp2[i]=pr[i+1].first-pr[i].first;
		if(pr[i].second==pr[i+1].second)
			dp2[i]+=dp2[i+1];
	}
	for(int i=1;i<=n;i++)
		pr[i].ans=min(dp1[i],dp2[i]);
	sort(pr+1,pr+n+1,cmp2);
	for(int i=1;i<=n;i++)
		cout<<pr[i].ans<<"\n";
	return 0;
}
```

---

## 作者：lzt415 (赞：1)

## 思路分析
先将每个选手排好序，毫无疑问，要搞一个结构体。

对于每个选手，分别向左和右寻找离他最近的异国选手，并取最小值，并且题目已经说明了一定有不同国籍的选手，所以无需考虑没有的情况。

先说向左侧找，分两种情况，一种是左边的和他国籍不同，那么就把最短距离先设为两者的距离，由于是第一次递推，所以无需取最小值。而如果国籍相同，所以最短距离先设为左侧的人的最短距离加上两者的距离，就这样不断更新即可。

$dis_{sign_{i}} = \begin{cases}
  c_{i} = c_{i-1}& x_{i}-x_{i-1}\\
  c_{i} \ne c_{i-1}& dis_{sign_{i-1}}+x_{i}-x_{i-1}\\
\end{cases}$

再说向右侧找，其实思路一样，只不过要与原来存的值比较。不过补充一下原来题解没有说明的一点，就是有可能递推到当前一点，但上一个点的最短距离的那个点在该点左侧，这样的话两点之间的距离就不是刚刚那样算的，但是由于有重叠多算的部分，这样算的距离一定更大，所以就不用管了。
## CODE

```cpp
#include<bits/stdc++.h>	 
using namespace std;
const int N=3e5+10;
int n,dis[N];
struct Node
{
	int sign,c,x;
}f[N];

bool cmp(Node a,Node b) return a.x<b.x;

int main(){	 
	cin>>n;
	memset(dis,0x3f,sizeof(dis));//千万不要忘记加，否则有可能会输出0 
	for(int i=1;i<=n;i++)
	{
		cin>>f[i].c>>f[i].x; 
		f[i].sign=i;	 
	}
	stable_sort(f+1,f+n+1,cmp);	 
	for(int i=2;i<=n;i++)
	{	 
		if(f[i].c!=f[i-1].c) dis[f[i].sign]=f[i].x-f[i-1].x;
		else dis[f[i].sign]=dis[f[i-1].sign]+f[i].x-f[i-1].x;
	}
	for(int i=n-1;i>=1;i--)
	{	 
		if(f[i].c!=f[i+1].c) dis[f[i].sign]=min(dis[f[i].sign],f[i+1].x-f[i].x);
		else dis[f[i].sign]=min(dis[f[i+1].sign]+f[i+1].x-f[i].x,dis[f[i].sign]);
	}
	for(int i=1;i<=n;i++) cout<<dis[i]<<endl; 
	return 0; 
}
```

---

## 作者：Tracy_Loght (赞：0)

## 题目大意：

对于一个序列，判断最近不同点的位置。

## 思路：

有一道题目，叫做 [P1901](https://www.luogu.com.cn/problem/P1901) 和这道题，基本思路一样。

首先，对于位置进行排序，没问题吧。

为了使当前可以快速找到最近的不同国籍的人的位置，我们可以在先前的时间内记下来就行了。

**注**：但是记录最近的一定会有一下情况：

- 到了 $i$ 这个人，最近的为 $i-1$ 这个人。

- 如果两个人国籍一样就写不了了！

但是可以**记录两个不同国籍**的最近的人即可。

然后分别**从左到右**和**从右到左**的跑一次。

比如从**左到右**跑时：

- 定义一个集合表，长为 2，每个存两个变量国籍，与其位置。

- 对于新遇见的一个人座位为 $i$，国籍为 $o_{i}$。

   - 如果集合内有和这个人相同国籍的，替换座位号。
   - 如果没有，则集合中，位置最小的一个量扔掉，并加上当前这个人的位置，国籍。

然后，就是对于一个人，判断与他最近的，国籍不相同的人的位置，直接在集合中找就行了，因为集合中的量国籍不一样，而且是最近的两个，所以 $o(n)$ 就可以处理了。

再从右到左跑一次，以防有更优解。

**时间复杂度**：$o(2n)$。

**空间复杂度**：$o(n)$。

完结。

---

## 作者：rc_Taurus (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11200)

---

$2\le N \le 3\times 10^5$，所以不能暴力寻找。

$O(n)$ 的做法，也就是动态规划（递推），只需要先排序，往左边找一次，右边找一次，最后答案取最小值就可以了。

对于编号为 $i$ 的选手往左边找。对于 $j=i-1$，如果同籍，结果就为 $dis_i=dis_j+{a_i}_x-{a_{i-1}}_x$；否则答案为 $dis_i={a_i}_x-{a_{i-1}}_x$，每次答案取最小值。

往右边找以此类推。

最后循环找最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,dis1[N],dis2[N];
struct node{
	int c,x,id;
	bool operator<(const node&b)const{
		return x<b.x;
	}
}a[N];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].c>>a[i].x,a[i].id=i;
	sort(a+1,a+n+1);
	memset(dis1,0x3f,sizeof dis1);
	memset(dis2,0x3f,sizeof dis2);
	for(int i=2;i<=n;i++){//往右跳（找左边） 
		if(a[i].c!=a[i-1].c)dis1[a[i].id]=min(dis1[a[i].id],a[i].x-a[i-1].x/*更新*/);
		else dis1[a[i].id]=min(dis1[a[i].id],dis1[a[i-1].id]+a[i].x-a[i-1].x);
	}
	for(int i=n-1;i>=1;i--){//往左跳 
		if(a[i].c!=a[i+1].c)dis2[a[i].id]=min(dis2[a[i].id],a[i+1].x-a[i].x/*更新*/);
		else dis2[a[i].id]=min(dis2[a[i].id],dis2[a[i+1].id]+a[i+1].x-a[i].x);
	}for(int i=1;i<=n;i++)cout<<min(dis1[i],dis2[i])<<endl;
	return 0;
}
```

时间复杂度 $O(n)$，空间复杂度 $O(n)$。

---

## 作者：wuyouawa (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11200)

### 思路

很显然，这题需要优化。

那么我们可以用动态规划的思想来做这道题。

首先，与一个选手的最近选手只可能是他的左边或右边。那么就可以分类讨论，取左右两边的较小值。接着，由于要找最小值，那么肯定要按座位的位置从小到大排序，这样才确保与选手 $i$ 最近的选手是选手 $i-1$，这样会方便统计答案，同时，为方便存储答案，我们要用结构体快速排序。

设离选手 $i$ 最近的异国选手的座位距离为 $ans1_i$，如果是选手 $i$ 左边的选手的话，答案只与选手 $i-1$ 相关。那么由于要不同国籍，所以这里又分以下 $2$ 种情况：

- 如果选手 $i$ 与选手 $i-1$ 不同国籍，那么与选手 $i$ 最近且在左边的不同国籍的人就是 $i-1$，答案为它们的距离，也就是 $\mid X_i−X_{i-1}\mid$。

- 如果选手 $i$ 与选手 $i-1$ 同国籍，那么与选手 $i$ 最近且在左边的就是与 $i-1$ 最近且在左边的不同国籍的人，答案为选手 $i$ 与选手 $i-1$ 的距离 $+$ 选手 $i-1$ 与选手 $i-1$ 最近且在左边的不同国籍的人的距离，也就是 $\mid X_i−X_{i-1}\mid+ans1_{i-1}$。

右边的同理，把 $i-1$ 改为 $i+1$ 即可。

但是我们要注意以下两个点：

- 这是排序后的结果，要存的下标是排序前的，所以要用一个 $id$ 来记录排序前的下标。

- 有一些在左边或在右边是没有异国籍的，这时要把它赋值为一个极大值，这样在取最小值是才不会出错。

### CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int x, c, id;
} a[300005];//结构体
bool cmp(node g, node y) {
	return g.x < y.x;//排序函数
}
int n, ans1[300005], ans2[300005], b, last;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", &a[i].c, &a[i].x);
		a[i].id = i;
		ans1[i] = INT_MAX;
		ans2[i] = INT_MAX;//初始赋一个极大值
	}
	sort(a + 1, a + n + 1, cmp);
	last = a[1].c;
	for (int i = 2; i <= n; i++) {
		if (a[i].c == last && b == 0)  continue;
		else  b = 1;//判断有无异国籍，没有直接跳过
		if (a[i].c != a[i - 1].c)  ans1[a[i].id] = abs(a[i].x - a[i - 1].x);
		else  ans1[a[i].id] = ans1[a[i - 1].id] + abs(a[i].x - a[i - 1].x);
	}
	last = a[n].c;
	b = 0;//a[1]与a[n]分别没有左右异国籍
	for (int i = n - 1; i >= 1; i--) {
		if (a[i].c == last && b == 0)  continue;
		else  b = 1;//判断有无异国籍，没有直接跳过
		if (a[i].c != a[i + 1].c)  ans2[a[i].id] = abs(a[i].x - a[i + 1].x);
		else  ans2[a[i].id] = ans2[a[i + 1].id] + abs(a[i].x - a[i + 1].x);//注意存的是排序前的下标
	}
	for (int i = 1; i <= n; i++)   {
		printf("%d\n", min(ans1[i], ans2[i]));//取最小值
	}
	return 0;
}
```

---

## 作者：slzx_zhangjinfeng (赞：0)

注：本弱鸡第一篇题解，求过。
# 分析
分析此题，我们看出这题要先排序（不排序你怎么$dp$？你怎么计算？你怎么写代码？)。

排序后，就可以考虑转移了。  
设$dp_{0,i}$表示排好序后第$i$个人左边离他最近的一个异国人。
设$dp_{1,i}$表示排好序后第$i$个人右边离他最近的一个异国人。
（我绝对不是复制的）
则我们可得出：
$$
dp_{0,i}=\begin{cases}
dp_{0,i-1}+dis(i,i-1) \hspace{0.5cm}(c_i = c_{i-1})\\
dis(i,i-1) \hspace{0.5cm}(c_i\ne c_{i-1})\\
\end{cases}
$$
$$
dp_{1,i}=\begin{cases}
dp_{1,i+1}+dis(i,i+1) \hspace{0.5cm}(c_i = c_{i+1})\\
dis(1,i+1) \hspace{0.5cm}(c_i\ne c_{i+1})\\
\end{cases}
$$
其中$dis(a,b)$表示$abs(x[a]-x[b])$。

听不懂？找样例！
```
5       
1 1
2 4
2 14
3 10
2 2
```
先排序。
```
x   c
1   1
2   2
4   2
10  3
14  2
```
然后套用公式，算出：
```
dp[0][1]=1e9//为了方便，没有就是1e9
dp[0][2]=1
dp[0][3]=3
dp[0][4]=6
dp[0][5]=4

dp[1][5]=1e9//同上
dp[1][4]=4
dp[1][3]=6
dp[1][2]=8
dp[1][1]=1
```
懂了吧？没懂？详见代码！（绝对不是我懒得写）

# 代码
```c++
#include<bits/stdc++.h>
#define int long long
#define code using
#define from namespace 
#define zhangjinfeng std
#define AC 0
code from zhangjinfeng;//我看谁敢抄题解 
struct people{
	int i,c,x;
	bool operator <(people a){
		return x<a.x;//按x排序，不写只有CE 
	}
}p[300005];
int n,dp[2][300005];//dp，没看懂的看题解最后
int ans[300005]; 
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&p[i].c,&p[i].x),
		p[i].i=i;
	sort(p+1,p+n+1);//免费的排序，不要白不要
	dp[0][1]=dp[1][n]=1e9;//初始化（我看谁敢忘） 
	for(int i=2;i<=n;i++)
		if(p[i].c==p[i-1].c)
			dp[0][i]=dp[0][i-1]+p[i].x-p[i-1].x;
		else 
			dp[0][i]=p[i].x-p[i-1].x; 
	for(int i=n-1;i>=1;i--){//从大到小，别忘！ 
		if(p[i].c==p[i+1].c)
			dp[1][i]=dp[1][i+1]+p[i+1].x-p[i].x;
		else 
			dp[1][i]=p[i+1].x-p[i].x;//正负！
	}	
	for(int i=1;i<=n;i++)
		ans[p[i].i]=min(dp[0][i],dp[1][i]);
	//别忘了，人被排序了 
	for(int i=1;i<=n;i++)
		printf("%lld\n",ans[i]);
	//终于写完了，给系统一个AC保佑我过 
	return AC;
}
```

# 结尾

注意点：

* $dp_1$计算时要从右往左（从大到小）
* $people$结构体的小于号返回值不能为小于等于（可能会炸）
* 记得点个赞，祝点赞的人：
```
身体健康，万事如意，工作顺利
秒切黑体，早日上红名，成为大佬
```
结束了？

不！

如果你是从程序中的一行注释过来的，那么恭喜你：
* 你有没有认真读题解？
* 你有没有认真推$dp$？
* 你有没有认真看样例？
* ……

终。

---

## 作者：Rosick (赞：0)

1. 国籍编号大小不重要，离散化一下。将选手提前记录编号，再按位置从小到大排列，。
2. 开两个数组 $l_{i}$ 和 $r_{i}$，分别表示 $1\sim i$ 和 $i\sim n$ 中离选手 $i$ 最近的选手的位置。正序倒序各遍历一遍：对于正序，若 $c_{i}\neq c_{i-1}$，那么 $l_{i}=x_{i-1}$；反之亦然。
3. 遍历的时候顺便统计答案即可。
4. 注意 $l_{i}$ 初始化负无穷，$r_{i}$ 初始化正无穷。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 3e5 + 10;

int read() {
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int n;
ll b[maxn];
struct node{
	ll c, x, id;
} a[maxn];
ll l[maxn];
ll r[maxn];
ll ans[maxn];

bool cmp(node a, node b){
	return a.x < b.x;
}

void sol() {
	n = read();
	for(int i = 1; i <= n; ++i){
		a[i].id = i;
		b[i] = a[i].c = read();
		a[i].x = read();
	}
	sort(a + 1, a + n + 1, cmp);
	sort(b + 1, b + n + 1);
	int len = unique(b + 1, b + n + 1) - b - 1;
	for(int i = 1; i <= n; ++i)
		a[i].c = lower_bound(b + 1, b + len + 1, a[i].c) - b;
	for(int i = 1; i <= len; ++i)
		l[i] = -1e16, r[i] = 1e16;
	for(int i = 1; i <= n; ++i)
		ans[i] = 1e16;
	a[0].c = a[1].c;
	a[n + 1].c = a[n].c;
	for(int i = 1; i <= n; ++i){
		if(a[i - 1].c != a[i].c) l[a[i].c] = a[i - 1].x;
		ans[a[i].id] = a[i].x - l[a[i].c];
	}
	for(int i = n; i; --i){
		if(a[i + 1].c != a[i].c) r[a[i].c] = a[i + 1].x;
		ans[a[i].id] = min(ans[a[i].id], r[a[i].c] - a[i].x);
	}
	for(int i = 1; i <= n; ++i)
		printf("%lld\n", ans[i]);
}

int main() {
	sol();
	return 0;
}
```

---

## 作者：songzhixin (赞：0)

### 题目大意

第 $i$ 名选手国籍 $c_i$，位置在 $x_i$，求距离每名选手最近的外国选手。

其中距离的计算公式为 $\lvert x_i-y_i \rvert$。

### 解题思路

我们先对这些人按照 $x$ 排序，但是如果我们暴力枚举，最坏时间复杂度 $O(n^2)$，会超时。

我们换个角度想一下，假设第 $i$ 个人的左边第一个外国人是 $l_i$，那么 $l_i+1 \sim i$ 是不是一定是同一个国籍的人？同理，假设第 $i$ 个人的右边第一个外国人是 $r_i$，那么 $i \sim r_i-1$ 是不是也一定是同一个国籍的人？

但是如果暴力向左右两边每局，时间复杂度和暴力是一样的，还是过不了。

但是我们想，如果我们把 $l_i+1 \sim i$ 和 $i \sim r_i-1$ 拼到一起，则 $l_i+1 \sim r_i-1$ 一定是同一个国籍的人。

对于 $l_i+1 \sim r_i-1$ 这个区间内的每一个人，他们的左边第一个外国人一定是 $l_i$，右边第一个外国人一定是 $r_i$，因此我们不需要枚举全部，可以先把这些区间预处理出来。

如何与处理呢？我们发现若 $i$ 个人和第 $i-1$ 个人是同一个国籍的那么这个区间的右端点改为 $i$，否则新建一个区间，左右端点都是 $i$。

最后对于每一个区间，答案是这个点到这个点所在区间的左端点减一和右端点加一距离的叫嚣着。

注意将 $x_1$ 和 $x_{n+1}$ 设为无穷大，因为最左边和最右边没有人，所以一定不可能。

### 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=3*1e5+5;
struct node {
	long long b,x,c,d;
};
bool cmp(node fx,node fy) {
	return fx.x<fy.x;
}
node a[N];
map<long long,long long> m;
node f[N];
long long ans[N];
int main() {
	long long n;
	scanf("%lld",&n);
	for(long long i=1; i<=n; i++) {
		scanf("%lld%lld",&a[i].b,&a[i].x);
		a[i].d=i;
	}
	sort(a+1,a+1+n,cmp);
	long long cnt=0;
	for(long long i=1; i<=n; i++) {
		if(m[a[i].b]==0) {//离散化（其实可以不用）
			m[a[i].b]=++cnt;
		}
		a[i].c=m[a[i].b];
	}
	long long t=0;
	for(long long i=1; i<=n; i++) {
		if(a[i].c==a[i-1].c) {//找相同的区间 
			f[t].c=i;
		} else {
			t++;
			f[t].x=a[i].c;
			f[t].b=i;
			f[t].c=i;
		}
	}
	a[0].x=1e10;
	a[n+1].x=1e10;
	long long s=1;
	for(long long i=1; i<=n; i++) {
		if(f[s].c<i){//看是否在这一个区间 
			s++;
		}
		/*也可以写成
		while(s>0&&s<=t) {
			if(f[s].b<=i&&f[s].c>=i) {
				break;
			}
			if(i>f[s].c) {
				s++;
			} else {
				s--;
			}
		}*/ 
		ans[a[i].d]=min(abs(a[f[s].b-1].x-a[i].x),abs(a[f[s].c+1].x-a[i].x));//找最近的外国选手 
	}
	for(long long i=1;i<=n;i++){
		printf("%lld\n",ans[i]);
	}
	return 0;
}
```

### 注意事项

1.注意最后答案要按照输入的顺序输出

2.他左右两边最近的外国选手是他所在区间的左端点减一和右端点加一，不是左端点和右端点。

---

## 作者：MaiJingYao666 (赞：0)

### 题面翻译 
求距离 $i$ 选手距离最近的的选手 $j$，且 $c_i \ne c_j $。
### 思路
理解很简单，但考虑到数据范围较大，显然不可能用 $O(n^2)$ 的时间复杂度来解。 
想到之前学的联通块了，虽然好像不是那一回事，但我们可以把相邻的国籍一样的放入一个块中，则每个块每个选手左右两个块的最右值和最左值与它的位置的距离差的最小值就是答案。  
可能有点没听懂，看一下代码吧。

先定义结构体。

```cpp
struct human{//选手的结构体
	int c,x,id;
}a[300005];
struct lx{//块的结构体
	int l,r;
	vector<int> bh;
};
vector<lx> vec(300005);
int idx=0;
```
然后是输入，到这里应该还没问题，注意输出要按原顺序，所以再加一个 $id$ 方便输出。

```cpp
cin>>n;
for(int i=0;i<n;i++){
	scanf("%d%d",&a[i].c,&a[i].x);
	a[i].id=i;
}
```
接下来就是排序和分块（不是那个分块），从小到大排序，相邻一样的放入一个块里。
```cpp
sort(a,a+n,cmp);
for(int i=0;i<n;){
	vec[++idx].l=a[i].x;
	vec[idx].r=a[i].x;
	vec[idx].bh.push_back(i);
	int k=i+1;
	while(a[k].c==a[i].c){
		vec[idx].r=a[k].x;
		vec[idx].bh.push_back(k);
		k++;
	}
	i=k;
}
```
接下来由于顺序都乱了，我们定义一个数组来存储按照原顺序排列的结果。

```cpp
int vis[300005];
```
最后就是按照上面说的逻辑写了，注意两个边界只能往中间的去选。

```cpp
for(int j=0;j<vec[1].bh.size();j++){
	vis[a[vec[1].bh[j]].id]=vec[2].l-a[vec[1].bh[j]].x;
}
for(int i=2;i<idx;i++){
	for(int j=0;j<vec[i].bh.size();j++){
		vis[a[vec[i].bh[j]].id]=min(a[vec[i].bh[j]].x-vec[i-1].r,vec[i+1].l-a[vec[i].bh[j]].x);
	}
}
for(int j=0;j<vec[idx].bh.size();j++){
	vis[a[vec[idx].bh[j]].id]=a[vec[idx].bh[j]].x-vec[idx-1].r;
}
for(int i=0;i<n;i++) cout<<vis[i]<<endl;
```

最后奉上完整代码。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n;
struct human{
	int c,x,id;
}a[300005];
struct lx{
	int l,r;
	vector<int> bh;
};
bool cmp(human x,human y){
	return x.x<y.x;
}
int vis[300005];
vector<lx> vec(300005);
int idx=0;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		scanf("%d%d",&a[i].c,&a[i].x);
		a[i].id=i;
	}
	sort(a,a+n,cmp);
	for(int i=0;i<n;){
		vec[++idx].l=a[i].x;
		vec[idx].r=a[i].x;
		vec[idx].bh.push_back(i);
		int k=i+1;
		while(a[k].c==a[i].c){
			vec[idx].r=a[k].x;
			vec[idx].bh.push_back(k);
			k++;
		}
		i=k;
	}
	for(int j=0;j<vec[1].bh.size();j++){
		vis[a[vec[1].bh[j]].id]=vec[2].l-a[vec[1].bh[j]].x;
	}
	for(int i=2;i<idx;i++){
		for(int j=0;j<vec[i].bh.size();j++){
			vis[a[vec[i].bh[j]].id]=min(a[vec[i].bh[j]].x-vec[i-1].r,vec[i+1].l-a[vec[i].bh[j]].x);
		}
	}
	for(int j=0;j<vec[idx].bh.size();j++){
		vis[a[vec[idx].bh[j]].id]=a[vec[idx].bh[j]].x-vec[idx-1].r;
	}
	for(int i=0;i<n;i++) cout<<vis[i]<<endl;
    //不写return 0;不是好习惯
}
```

---


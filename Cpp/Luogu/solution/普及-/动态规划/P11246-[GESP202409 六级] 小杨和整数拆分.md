# [GESP202409 六级] 小杨和整数拆分

## 题目描述

小杨有一个正整数 $n$，小杨想将它拆分成若干完全平方数的和，同时小杨希望拆分的数量越少越好。

编程计算总和为 $n$ 的完全平方数的最小数量。

## 说明/提示

### 数据规模与约定

对全部的测试数据，保证 $1 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
18
```

### 输出

```
2```

# 题解

## 作者：easy42 (赞：99)

清新的动态规划。

易列出状态转移方程 `dp[i] = min(dp[i], dp[i - j * j] + 1)`。

解释在下面：

**状态转移方程的含义**
   - 状态转移方程 `dp[i] = min(dp[i], dp[i - j * j] + 1)`（其中 `j * j <= i`）的含义是在计算总和为 `i` 的完全平方数的最小数量 `dp[i]` 时，考虑使用小于等于 `i` 的完全平方数 `j * j` 来构建 `i`。
   - `dp[i - j * j]` 表示已经计算出的总和为 `i - j * j` 的完全平方数的最小数量。通过加上一个完全平方数 `j * j`，就可以得到总和为 `i` 的一种拆分方式，其数量为 `dp[i - j * j] + 1`（因为多使用了一个完全平方数 `j * j`）。
   - 对于每个 `i`，我们尝试所有可能的完全平方数 `j * j`（只要 `j * j <= i`），并从这些可能的拆分方式中选择数量最少的，即取 `min(dp[i], dp[i - j * j] + 1)`。这样不断更新 `dp[i]`，最终得到总和为 `i` 的完全平方数的最小数量。

例如，当计算 `dp[5]` 时：
   - 首先 `j = 1`，`j * j = 1`，`dp[5 - 1] = dp[4]`，假设 `dp[4]` 之前已经计算为 `1`（因为 `4 = 4` 本身就是一个完全平方数，数量为 `1`），那么 `dp[5]` 就会更新为 `min(dp[5], dp[4] + 1) = min(初始值, 1 + 1) = 2`。
   - 然后 `j = 2`，`j * j = 4`，`dp[5 - 4] = dp[1]`，`dp[1]` 初始为 `1`（因为 `1 = 1`），此时 `dp[5]` 会再次更新为 `min(dp[5], dp[1] + 1) = min(2, 1 + 1) = 2`（因为 `2` 更小）。
   - 继续 `j = 3`，`j * j = 9`，但 `9 > 5`，循环结束，`dp[5]` 最终为 `2`，表示 `5` 可以拆分为 `1 + 4`，使用了两个完全平方数，这是最少的拆分数量。

代码：
```
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int n;
    cin >> n;
    int dp[n + 1];
    for (int i = 0; i <= n; i++) {
        dp[i] = i;  // 初始化，最坏情况就是全是1相加
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * j <= i; j++) {
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

可以的话，能不能点个关注和赞？

---

## 作者：Eterna (赞：11)

由拉格朗日四平方定理得到我们的答案是 $\le 4$ 的。

可以想到三维枚举，是 $O(n^3)$ 的，无法通过。

注意到题面是平方和，所以每维只用枚举到 $\sqrt {n}$，复杂度为 $O(n^ \frac{3}{2})$，可以通过了。并且考虑到排列枚举会导致重复情况。


```cpp
int B=sqrt(n);
for(int i=1;i<=B;i++)
	for(int j=1;j<=B;j++)
		for(int k=1;k<=B;k++)
```
上述代码可以改为：

```cpp
int B=sqrt(n);
for(int i=1;i<=B;i++)
	for(int j=i;j<=B;j++)
		for(int k=j;k<=B;k++)
```

此时我们常数更优秀。

又因为在前两维确定的情况下，第三维一定（显然）。

所以我们可以简单优化到 $O(n)$。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
signed main()
{
	cin>>n;
	int B=sqrt(n);
	if(B*B==n)
	{
		cout<<1;
		return 0;
	}
	for(int i=1;i<=B;i++)
	{
		int sq=sqrt(n-i*i);
		if(sq*sq==n-i*i)
		{
			cout<<2;
			return 0;
		}
	}
	for(int i=1;i<=B;i++)
	{
		for(int j=i;j<=B;j++)
		{
			int sq=sqrt(n-i*i-j*j);
			if(sq*sq==n-i*i-j*j)
			{
				cout<<3;
				return 0;
			}
		}
	}
	cout<<4;
	return 0;
} 
```

通过数论分析，我们可以将复杂度做到 $O(1)$，但此题 $n \le 10^5$。我就不写了，大家可以自行尝试。

---

## 作者：yuruilin2026 (赞：6)

一道很好的基础 DP 题。\
同机房的超级神犇 [Hootime](https://www.luogu.com.cn/user/1275540) 如此说道。

那么废话不多说，直接开始：
- 思路：
  1. 对于一个完全平方数 $n$，肯定是分解出它自己一个，输出 $1$，这同时也是 DP 的边界条件。
  
  2. 对于非完全平方数 $m$，它可以分解成一个完全平方数加另一个比他小的数之和，比它小的数就可以按照这两条方法求解。

- 细节：\
  令 $dp_i$ 表示分解 $i$ 为完全平方数和的最小数量。\
  可得状态转移方程式为： $dp_i=min(dp_i,dp_{i-c_j}+1)$。\
  其中 $c_j$ 代表了第 $j$ 小的平方数。

- 代码：
  
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[1145140],n,c[1145140],r = 0;//数组开大一点，防止爆掉 
int main(){
	cin >> n;
	for(int i = 1;i <= n;i++){
		dp[i] = INT_MAX-1;//初始化是一个好习惯 
	}
	for(int i = 1;i <= sqrt(n)*2;i++){//多算几个，不然有可能会炸掉 
		c[i] = i*i;//第i小的平方数 
		dp[i*i] = 1;
	}
	for(int i = 1;i <= n;i++){
		while(i > c[r]) r++;//扩展右端点 
		for(int j = 1;j <= r;j++){//枚举平方数 
			if(i - c[j] < 0){//防止RE 
				continue;
			}
			dp[i] = min(dp[i],dp[i - c[j]]+1);//状态转移方程式 
		}
	}
	cout << dp[n];
    return 0;
}
```

---

## 作者：DemonPlayer (赞：4)

本题是典型最优解问题（属于动态规划）。动态规划分三步走。     
### STEP 1（状态表示）：
输出的答案应为 $f[n]$ ，所以 $f[W]=V$ 其中 $W$ 为数字， $V$ 为最少拆分的数字的个数。
### STEP 2（状态转移方程）：         
当选择 $i$ 的平方时，数字会减少 $i$ 的平方，数字的个数+1，但注意，要与以前的状态进行对比。不然就不是最优解。
### STEP 3（初始化）：       
因为要进行取最小的操作，要将未知的状态设为一个较大的数，如 0x3f3f3f。但注意，$f[0]=0$。       
## Code：       
```cpp
#include<bits/stdc++.h>//千能头
#define AK return
#define IOI 0
using namespace std;

int n,cnt;
long long f[100001];
long long v[100001]; //注意要开long long，极限情况时可能会超界。

int main(){
	scanf("%d",&n);
	memset(f,0x3f3f3f,sizeof(f)); //初始化为 0x3f3f3f
	f[0]=0;
	for(int i=1;i<=n;i++){
		if(i*i>n){
			break;
		}
		v[++cnt]=i*i; //构建平方数数组。
	}
	for(int i=1;i<=cnt;i++){ //枚举所有物品。
		for(int j=v[i];j<=n;j++){ //便利所有合法状态。
			f[j]=min(f[j],f[j-v[i]]+1); //装态转移方程
		}
	}
	cout<<f[n]; //输出
	AK IOI;
}
```

---

## 作者：SpriteQAQ (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P11246)
# 一、题目分析

DP 板子题(个人认为）。

# 二、解题思路

1. **定义状态**
   - 设 `dp[i]` 表示整数 $i$ 可以拆分成的完全平方数的最小数量。

2. **状态转移方程**
   - 对于每个整数 $i$ ，可以尝试用小于等于 $i$ 的完全平方数 $j^2$ 来拆分 $i$ ，则有 `dp[i] = min(dp[i], dp[i - j * j] + 1)` 。  
这是因为如果 `dp[i - j * j]` 是将 `i - j * j` 拆分成完全平方数的最小数量，那么 `dp[i - j * j] + 1` 就是将 $i$ 拆分成完全平方数的一种可能数量，取所有可能中的最小值就是 `dp[i]` 。

3. **初始状态**
   - `dp[0] = 0`，因为 0 不需要任何完全平方数就能组成。(废话)

# 三、代码实现步骤

1. 首先读取输入的正整数 $n$ 。
1. 初始化 `dp` 数组，将每个位置初始化为一个较大的值，表示当前还没有找到最小的拆分数量。
1. 使用两层循环进行动态规划求解。外层循环遍历从 $1$ 到 $n$ 的每个整数，内层循环遍历从 $1$ 到当前整数的平方根的整数 $j$，用于尝试用完全平方数 $j^2$ 去拆分当前整数 $i$ 。
1. 更新 `dp[i]` 为 `dp[i - j * j] + 1` 和当前 `dp[i]` 的较小值。
1. 最后输出 `dp[n]` ，即输入整数 $n$ 拆分成完全平方数之和的最小数量。

# 四、时间复杂度和空间复杂度分析

1. 时间复杂度：$O(n\sqrt{n})$。

2. 空间复杂度： $O(n)$。

# 五、完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int n, dp[N];
int main(){
　　cin >> n;
　　for(int i = 1; i <= n; i++){
　　　　dp[i] = i;
　　　　for(int j = 1; j <= sqrt(i); j++){
　　　　　　dp[i] = min(dp[i - j * j] + 1, dp[i]);
　　　　}
　　}
　　cout << dp[n];
　　return 0;
}

```

---

## 作者：Lyw_and_Segment_Tree (赞：1)

# P11246 小杨和整数拆分 题解

## 题意简述

小杨有一个正整数 $n$，小杨想将它拆分成若干完全平方数的和，同时小杨希望拆分的数量越少越好。

请你计算总和为 $n$ 的完全平方数的最小数量。

## 开始解题！

这是一道很经典的广搜变式题，我们令当前状态为 $\{now, dep\}$，表示走到 $now$ 需要 $dep$ 步，然后对所有 $1 \le k \le \lfloor \sqrt n \rfloor$，拓展出 $\{now + k ^ 2, dep + 1\}$ 这样的状态，并且在 $now + k ^ 2 \gt n$ 时剪枝，在第一个 $now + k ^ 2 = n$ 时记录一下答案，并输出。这样就完成了整个算法。

最后是时间复杂度，大家可能觉得这样的做法时间复杂度比较玄学，实则不然，我们由拉格朗日四平方和定理可得，一定会有 $1 \le ans \le 4$，然后对于一个状态 $\{now, dep\}$，其至多只有 $\lfloor \sqrt n \rfloor$ 个前驱，所以第四层只有 $n \sqrt n$ 个前驱，然后这个时候就是剪枝魅力时刻。在此时，大部分节点都会直接被剪掉，再加上数据比较水，所以这个时间复杂度能过，而且不玄学，最坏在 $O(n \sqrt n)$ 到 $O(n ^ 2)$ 之间，但是一定达不到 $n ^ 2$，只是因为我不会证明，可以感性理解一下。 ~~总之能过~~

code : 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
struct node {
   int s, f; 
};
queue<node> q;
int bfs(int n) {
    q.push({0,0});
    while(!q.empty()) {
        node now = q.front();
        q.pop();
        int ss = now.s;
        int no = now.f;
        for(int i = 1; i * i <= n; i++) {
            ss = now.s + i * i;
            if(ss == n) return no + 1;
            if(ss > n) break;
            q.push((node){ss, no + 1});
        }
    }
    return -1;
}
int main() {
    cin >> n;
    cout << bfs(n) << endl;
}
```

[AC record](https://www.luogu.com.cn/record/187944803)

其实从记录来看，这个代码的复杂度还是很优秀的。

做完了。

---

## 作者：Lorentz (赞：1)

# 「[GESP202409 六级] 小杨和整数拆分」题解
## 导语
本题是典型的动态规划（Dynamic Programming，DP）问题，我们可以使用其求如何将 $n$ 拆分成尽可能少的完全平方数的和。
## 思路
我们设 $dp[i]$ 表示整数 $i$ 的最小完全平方数拆分数量。

对于任意 DP 题目的 $dp$ 数组，我们都需要初始化以进行状态转移。本题的初始化为 $dp[0] = 0$，因为 $0$ 不需要任何完全平方数来拆分。我们可以将所有 $i>0$，$dp[i]=\infty$（或者一个足够大的数，如 C++ 的 `INT_MAX`），因为我们每一位都要求最小的，所以在比较时这个足够大的数一定会大于另外一个数字。

对于每个 $i$，我们尝试所有可能的完全平方数 $j^2$（其中 $j^2 \le i$），更新 $dp[i]$ 的值。状态转移方程为：
$$
dp[i]=\min\left(dp[i],dp\left[i−j^2\right]+1\right)
$$
其中 $j^2$ 遍历所有小于等于 $i$ 的完全平方数，$\min(a,b)$ 表示 $a,b$ 两数中的最小值。
## 实现
对于 C++ 与 Python，实现程序分别如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> dp(100005,INT_MAX);
int main() {
    int n;
    cin>>n;
    dp[0]=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j*j<=i;j++)
            dp[i]=min(dp[i],dp[i-j*j]+1);
    cout<<dp[n];
    return 0.0;
}
```
---
```python
n=int(input())
dp=[float('inf')]*(n+1)
dp[0]=0
for i in range(1,n+1):
    for j in range(1,int(i**0.5)+1):
        dp[i]=min(dp[i],dp[i-j*j]+1)
print(dp[n])
```
我们首先声明了 $dp$ 数组，并且将前 $n+1$ 个元素赋为「足够大的数」`INT_MAX` 与 `float('inf')`，并将 $dp[0]$ 赋为 $0$。

接下来，我们遍历求 $dp[1]\sim dp[n]$。对于 Python，由于 `range(a,b)` 所求的数组为左闭右开的 $[a,b)$ 的特点，我们 `i` 要在 $range(1,n+1)$ 中进行遍历。

然后，我们要依次从 $1$ 遍历所有 $j^2\le i$ 的正整数 $j$，对于 Python，我们遍历 $\left[1,\left\lfloor\sqrt j\right\rfloor\right)$，并按动态转移方程 $dp[i]=\min\left(dp[i],dp\left[i−j^2\right]+1\right)$ 进行动态转移，输出答案 $dp[n]$ 即可。

---

## 作者：4041nofoundGeoge (赞：0)

简简单单的动规题。

## 思路

看到标签才知道这是一道动规题目。可以把他想象成**类似** 01 背包来做。具体来说动规转移方程为：（设数组为 $dp_{i}$，表示将整数 $i$ 表示为若干个不同平方数之和的最少个数。）

$$
dp_i = min(dp_i, dp_{i-j^2} + 1)
$$

这是使用滚动数组来优化，具体请参见 [OI WIKI](https://oi-wiki.org/dp/knapsack/)。时间复杂度大概为 $O(n)$。

赶紧写代码！

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100005];
int main()
{
    int n;
    cin >> n;
    memset(dp, 0x3f, sizeof(dp)); // 方便比较大小
    dp[0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j * j <= i; ++j) {
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

---


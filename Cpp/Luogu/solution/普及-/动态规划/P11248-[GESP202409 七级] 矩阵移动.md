# [GESP202409 七级] 矩阵移动

## 题目描述

小杨有一个 $n \times m$ 的矩阵，仅包含 `01?` 三种字符。矩阵的行从上到下编号依次为 $1,2,\dots, n$，列从左到右编号依次为 $1, 2, \dots, m$。小杨开始在矩阵的左上角 $(1,1)$，小杨只能向下或者向右移动，最终到达右下角 $(n, m)$ 时停止，在移动的过程中每经过一个字符 `1` 得分会增加一分（包括起点和终点），经过其它字符则分数不变。小杨的初始分数为 $0$ 分。

小杨可以将矩阵中不超过 $x$ 个字符 `?` 变为字符  `1`。小杨在修改矩阵后，会以最优的策略从左上角移动到右下角。他想知道自己最多能获得多少分。

## 说明/提示

### 样例 1 解释

对于第二组测试用例，将 $(2,1)$ 或者 $(3,3)$ 变为 $1$ 均是最优策略。

### 数据规模与约定

| 子任务编号 | 数据点占比 | $t$ | $n,m$ | $x$ |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $30\%$ | $\leq 5$ | $\le 10$ | $=1$ |
| $2$ | $30\%$ | $\le 10$ | $\le 500$ | $\le 30$ |
| $3$ | $40\%$ | $\le 10$ | $\le 500$ | $\le 300$ |

对全部的测试数据，保证 $1 \leq t \leq 10$，$1 \leq n,m \leq 500$，$1 \leq x \leq 300$，保证所有测试用例 $n \times m$ 的总和不超过 $2.5 \times 10^5$。

## 样例 #1

### 输入

```
2
3 3 1
000
111
01?
3 3 1
000
?0?
01?
```

### 输出

```
4
2```

# 题解

## 作者：Vct14 (赞：12)

upd：更新了滚动数组优化的内容。

考虑 dp。

设 $dp_{i,j,k}$ 表示当前走到了 $(i,j)$，已经改变 $k$ 个 `?` 时的最多得分。

因为不需要恰好改变 $x$ 个 `?`，所以我们每次从 $0$ 到 $x$ 遍历 $k$ 更新 $dp_{i,j,k}$。

首先有 $dp_{i,j,k}=\max(dp_{i-1,j,k},dp_{i,j-1,k})$，即从上面一格或左边一格一步过来。然后如果这一格上的字符为 `1` 那么 $dp_{i,j,k}$ 加一。

接下来就是如何处理 `?`。按照上面的步骤，我们已经处理了 `?` 不变的情况。那么如果要变，$dp_{i,j,k}=\max(dp_{i,j,k},\max(dp_{i-1,j,k-1},dp_{i,j-1,k-1})$。

最终答案为 $\max\limits_{k=0}^x dp_{n,m,k}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define dn dp[i][j][k]
const int N=502;

int dp[N][N][302];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    int t;cin>>t;
    while(t--){
        int n,m,x;cin>>n>>m>>x;
        memset(dp,0,sizeof(dp));
        for(int i=1; i<=n; i++){
        	for(int j=1; j<=m; j++){
				char a;cin>>a;
				for(int k=0; k<=x; k++){
		            dn=max(dp[i-1][j][k],dp[i][j-1][k])+(a=='1');
		            if(a=='?' && k) dn=max(dn,max(dp[i-1][j][k-1],dp[i][j-1][k-1])+1);
				}
			}
		}
        int mx=0;
        for(int k=0; k<=x; k++) mx=max(mx,dp[n][m][k]);
        cout<<mx<<"\n";
    }
    return 0;
}
```

注意到每一层的转移只与其上一层有关，因此可以使用滚动数组进行优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define dn dp[i%2][j][k]

int dp[2][502][302];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    int t;cin>>t;
    while(t--){
        int n,m,x;cin>>n>>m>>x;
        memset(dp,0,sizeof(dp));
        for(int i=1; i<=n; i++){
        	for(int j=1; j<=m; j++){
				char a;cin>>a;
				for(int k=0; k<=x; k++){
		            dn=max(dp[(i+1)%2][j][k],dp[i%2][j-1][k]);
		            if(a=='1') dn++;
		            if(a=='?' && k) dn=max(dn,max(dp[(i+1)%2][j][k-1],dp[i%2][j-1][k-1])+1);
				}
			}
		}
        int mx=0;
        for(int k=0; k<=x; k++) mx=max(mx,dp[n%2][m][k]);
        cout<<mx<<"\n";
    }
    return 0;
}
```

---

## 作者：xuezhiyu (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P11248)

~~占领空位！~~

# 题目分析

一道很暴力的 `dp`。

因为只能往下或往右走，所以很容易想到用动态规划。但是这道题还可以改变 $k$ 怎么办呢？很简单，加一维就完了。这道题和蔼可亲的数据范围告诉我们不会 `TLE`，甚至不加滚动数组优化也不会 `MLE` ！~~感谢出题人大慈大悲~~

具体地，我们定义状态 $f_{i,j,k}$ 表示到第 $i$ 行 $j$ 列，用了不多于 $k$ 次改变机会时的最大收益。那么转移方程也就显而易见了：

$$
f_{i,j,k}=\max
\left\{ 
\begin{array}{lc}
\max(f_{i-1,j,k},f_{i,j-1,k})+[a_{i,j}=1] \\
\max(f_{i-1,j,k-1},f_{i,j-1,k-1})+1~~~~~~~,k \not= 0 ~ \wedge ~ a_{i,j}=?
\end{array}
\right.
$$

公式中 $a$ 代表输入的符号矩阵。

因为转移方程只会用到 $f_{i,j,k-1}$ 和 $f_{i,j,k}$，所以可以用 $k$ 的奇偶性分出两个数组，具体见代码。可以把空间复杂度从 $\text O(N^2K)$ 优化成 O(N^2)。

# 代码时间

### 没有滚动数组优化的

```cpp
#include <iostream>

using namespace std;

const int N = 510, M = 310;
char a[N][N];
int n, m, K, f[N][N][M];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T;
	cin >> T;
	while (T --> 0) {
		cin >> n >> m >> K;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				cin >> a[i][j];
		for (int k = 0; k <= K; k++)
			for (int i = 1; i <= n; i++)
				for (int j = 1; j <= m; j++)
					f[i][j][k] = ((k && a[i][j] == '?') ? max(max(f[i - 1][j][k], f[i][j - 1][k]), max(f[i - 1][j][k - 1], f[i][j - 1][k - 1]) + 1) : max(f[i - 1][j][k], f[i][j - 1][k]) + (a[i][j] == '1')); // 究极压行的转移方程
		cout << f[n][m][K] << endl;
	}
	return 0;
}
```

### 包含滚动数组优化

```cpp
#include <iostream>

using namespace std;

const int N = 510;
char a[N][N];
int n, m, K, f[N][N][2];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T;
	cin >> T;
	while (T --> 0) {
		cin >> n >> m >> K;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				cin >> a[i][j];
		for (int k = 0; k <= K; k++)
			for (int i = 1; i <= n; i++)
				for (int j = 1; j <= m; j++)
					f[i][j][k & 1] = ((k && a[i][j] == '?') ? max(max(f[i - 1][j][k & 1], f[i][j - 1][k & 1]), max(f[i - 1][j][(k - 1) & 1], f[i][j - 1][(k - 1) & 1]) + 1) : max(f[i - 1][j][k & 1], f[i][j - 1][k & 1]) + (a[i][j] == '1')); // 究极压行的转移方程
		cout << f[n][m][K & 1] << endl; // 就是把对 k 的访问变成了对 k & 1 的访问
	}
	return 0;
}
```

---

## 作者：chenlongli (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P11248)
### 思路
本题最关键的地方在于如何处理 `?` 的地方，那么只要是可以填 `1` 的地方我们优先填 `1`，但是还要记录目前已经将多少个 `?` 变成 `1`，所以这题便可以直接 DP 求解了。

我们设 $dp_{i,j,k}$ 代表在 $(i,j)$ 的位置已经将 $k$ 个 `?` 变成 `1`，我们分类讨论，如果这个点的值是 `0`，直接求出上方格子的值和左边格子的值的最大值，如果这个点的值是 `0`，直接求出上方格子的值和左边格子的值的最大值加 $1$，如果这个点的值是 `?`，可以求出上方格子的值和左边格子的值的最大值**但是减少一个 `?` 变成 `1` 的个数**加 $1$ 的和和直接求出上方格子的值和左边格子的值的最大值的最大值，也就是 $ dp_{i,j,k}=\max(\max(dp_{i-1,j,k},dp_{i,j-1,k}),1+\max(dp_{i-1,j,k-1},dp_{i,j-1,k-1}))$，当然要特判如果枚举的 $k$ 为 $0$ 的情况不可以将 `?` 变成 `1`。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[505][505][305];
char a[505][505];
int main()
{
    int t;
    cin>>t;
    for (int y=1;y<=t;y++)
    {
        int n,m,x;
        cin>>n>>m>>x;
        for (int j=1;j<=n;j++)
        {
            for (int k=1;k<=m;k++)
            {
                cin>>a[j][k];
            }
        }
        for (int i=1;i<=n;i++)
        {
            for (int j=1;j<=m;j++)
            {
                for (int k=0;k<=x;k++)
                {
                    if (a[i][j]=='0')
                    {
                        dp[i][j][k]=max(dp[i-1][j][k],dp[i][j-1][k]);
                    }
                    if (a[i][j]=='1')
                    {
                        dp[i][j][k]=1+max(dp[i-1][j][k],dp[i][j-1][k]);
                    }
                    if (a[i][j]=='?')
                    {
                        if (k!=0)
                        {
                            dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),1+max(dp[i-1][j][k-1],dp[i][j-1][k-1]));
                        }
                        else
                        {
                            dp[i][j][k]=max(dp[i-1][j][k],dp[i][j-1][k]);
                        }
                    }
                }
            }
        }
        int ans=0;
        for (int l=0;l<=x;l++)
        {
            //cout<<dp[n][m][l]<<endl;
            ans=max(ans,dp[n][m][l]);
        }
        cout<<ans<<endl;
    }
}
```

---

## 作者：_lxc__ (赞：3)

要解决这个问题，我们可以使用动态规划的方法。我们需要考虑将字符 `?` 变为 `1` 的最优策略，使得从左上角到右下角的路径上经过的 `1` 最多。

以下是解决这个问题的步骤：

* 定义状态：

使用一个三维数组 $dp[i][j][k]$ 表示在位置 $(i, j)$ 时，已经将 $k$ 个 `?` 变为 `1` 的情况下，可以获得的最大分数。

* 状态转移：

如果当前字符是 `1`，则 $dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k] + 1$（加上当前位置的分数）。

如果当前字符是 `0`，则 $dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k]$（分数不变）。

如果当前字符是 `?`，则有两种选择：

不变：$dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k]$

变为 `1`：$dp[i][j][k] = max(dp[i-1][j][k-1] + dp[i][j-1][k-1] + 1, dp[i][j][k])$（需要消耗一个变换机会）。

* 初始化： 

$dp[0][j][k]$ 和 $dp[i][0][k]$ 应该初始化为 $0$，因为从起点之外的位置到达是不可能的。

$dp[0][0][0]$ 也应该初始化为 $0$，因为起点没有分数。

* 结果：

最终结果在 $dp[n][m][0]$ 到 $dp[n][m][k]$ 中取最大值，因为我们可以选择使用 $0$ 到 $k$ 个变换机会。

---

## 作者：Leo2011 (赞：2)

[~~无耻的广告~~更好的阅读体验~](https://www.leo2011.eu.org/2024/11/09/ti-jie-p11248-gesp202409-qi-ji-ju-zhen-yi-dong/)

---

笑点解析：这个人所在城市考试当天刮台风了，没考，免费送了一次 12 月的考试。

---

设计这么一个东西：

$dp_{i,j}$ 表示到格子 $(i, j)$ 的最大分数。

本来还好，但现在的问题是，如果这个格子是‘？’，我哪儿知道到底可不可以变啊？万一变得太多了，那，那不就废了！万一少了，那我分不就没了？

所以我们需要到底还剩多少次机会呢？不好办，没法儿处理。

其实加一维记录就可以了。

于是我得到了这个状态：

$dp_{i, j, k}$ = 到格子 $(i, j)$ 且已经使用了 $k$ 次机会的最大值。

转移也很好推：

不是‘？’：
$$
dp_{i, j, k} = 
\begin{cases} 
\max(dp_{i, j - 1, k}, dp_{i - 1, j, k}) + 1& (i, j) = 1\\
\max(dp_{i, j - 1, k}, dp_{i - 1, j, k})& (i, j) = 0\\
\end{cases}
$$

就是从两种可能的上一步转移过来，注意横竖均可。

是‘？’：

$$
dp_{i, j, k} = 
\begin{cases} 
\max(dp_{i, j - 1, k}, dp_{i - 1, j, k}) + 1& k = 0\\
\max(dp_{i, j - 1, k - 1}, dp_{i - 1, j, k - 1}) + 1& k > 0\\
\end{cases}
$$

同上，注意 $k = 0$ 时不能使用机会。而且可以变的话当然是变了更好，所以 $k > 0$ 时可以无脑使用。

---

ACCode:
```cpp
/*Code by Leo2011*/
#include <bits/stdc++.h>

#define INF 0x3f3f3f3f
#define EPS 1e-8
#define FOR(i, l, r) for (ll(i) = (l); (i) <= (r); ++(i))
#define log printf
#define IOS                      \
	ios::sync_with_stdio(false); \
	cin.tie(nullptr);            \
	cout.tie(nullptr);

using namespace std;

typedef __int128 i128;
typedef long long ll;
typedef pair<ll, ll> PII;

const int N = 510, M = 310;
int m, n, t, x, a[N][N], dp[N][N][M], ans;  // dp[i][j][k] = (1, 1) 到(i, j)，已经使用了k次机会的最大值
string s;

template <typename T>

inline T read() {
	T sum = 0, fl = 1;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		if (ch == '-') fl = -1;
	for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';
	return sum * fl;
}

template <typename T>

inline void write(T x) {
	if (x < 0) {
		putchar('-'), write<T>(-x);
		return;
	}
	static T sta[35];
	ll top = 0;
	do { sta[top++] = x % 10, x /= 10; } while (x);
	while (top) putchar(sta[--top] + 48);
}

int main() {
    IOS;
    cin >> t;
    while (t--) {
        cin >> n >> m >> x;
        FOR(i, 1, n) {
            cin >> s;
            for (int j = 0;j < m;++j) {
                if (s[j] == '?') a[i][j + 1] = -INF;
                else a[i][j + 1] = s[j] - '0';
            }
        }
        FOR(i, 1, n) FOR(j, 1, m) FOR(k, 0, x) {
              // 要用到 k - 1, 必须正序遍历。
            switch(a[i][j]) {
                case -INF:
                    if (k > 0) dp[i][j][k] = max(dp[i][j - 1][k - 1], dp[i - 1][j][k - 1]) + 1;
                    else dp[i][j][k] = max(dp[i][j - 1][k], dp[i - 1][j][k]);
                    break;
                case 1:
                    dp[i][j][k] = max(dp[i][j - 1][k], dp[i - 1][j][k]) + 1;
                    break;
                case 0:
                    dp[i][j][k] = max(dp[i][j - 1][k], dp[i - 1][j][k]);
                    break;
            }
        }
        FOR(i, 0, x) ans = max(ans, dp[n][m][i]);  // 不超过就是不一定，要遍历一遍
        cout << ans << endl;
        memset(dp, 0, sizeof(dp));
        memset(a, 0, sizeof(a));
        ans = -INF;
        // 多组数据要清空
    }
	return 0;
}

```

[AC 记录~](https://www.luogu.com.cn/record/187354256)

理解万岁！

---

## 作者：savvsavsaasvav (赞：1)

## 题外话
作为 GESP 考生，这题我在赛时中竟然以为 $O(nmx)$ 会超时！我就没敢写，最后十五分钟才 AC 本题。

## 思路
非常简单粗暴的一道三维 dp 题。

主题思路就是使用 $dp_{i,j,k}$ 表示从 $(1,1)$ 走到 $(i,j)$ ，使用 $k$ 次操作，最多能得到多少分数。

那么当这个字符不是 ?，也就是无法修改，那我们就从上两种状态继承，再加上该字符是否为 1。

如果这个字符时 ?，那么就有两种继承方式，操作或不操作，将它们取一个最大值。

最后的输出就是 $dp_{n,m,x}$。时间复杂度 $O(nmx)$。

## 代码
详见注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=502;
int T,n,m,c,dp[N][N][302];
char s[N][N];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&n,&m,&c);//c 就是题目中的 x。 
		int cnt=0;//记录 ? 的数量。
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				cin>>s[i][j];
				cnt+=(s[i][j]=='?');
			}
		}
		c=min(c,cnt);//如果 ? 数量大于修改次数，那么不可能修改全部，所以更新修改次数。
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				for(int k=0;k<=c;++k){
					dp[i][j][k]=0;//初始化。
				}
			}
		}
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				if(s[i][j]=='?'){//可修改，分两种情况。 
					for(int k=1;k<=c;++k){//修改，k 从 1 开始，不然会 RE。 
						dp[i][j][k]=max(dp[i-1][j][k-1],dp[i][j-1][k-1])+1;
						//因为可以向右或向下，状态从左或上转移，别忘了修改后得分会 +1。 
					}
					for(int k=0;k<=c;++k){//不修改。 
						dp[i][j][k]=max(dp[i][j][k],max(dp[i-1][j][k],dp[i][j-1][k]));//同上。 
					}
				}
				else{//不可修改，唯一的状态转移。 
					for(int k=0;k<=c;++k){
						dp[i][j][k]=max(dp[i-1][j][k],dp[i][j-1][k])+(s[i][j]=='1');
						//还是从左或上转移，如果是 1，则得分 +1。 
					}
				}
			}
		}
		printf("%d\n",dp[n][m][c]);//输出就是截至到 (n,m) 用 c 次修改，能获得的最大得分。 
	}
}
```

---

## 作者：Ame_Rain_chan (赞：1)

简单线性 dp。

设 $f_{i,j,k}$ 为走到点 $(i,j)$，用了 $k$ 次转换机会时的最大得分。

则转移方程为

$$
f_{i,j,k}=
\begin{cases}
\max(f_{i-1,j,k},f_{i,j-1,k}),k \in \mathbb N\\
\max(\max(f_{i-1,j,k},f_{i,j-1,k}),\max(f_{i-1,j,k-1},f_{i,j-1,k-1})+1),k \in \mathbb{N^+} 
\end{cases}
$$

然后就可以 dp 了。

时间复杂度 $O(tnmk)$，可以通过本题。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=510;
int n,m,x,f[N][N][310];
char mp[N][N];
int main(){
    int t;scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&n,&m,&x);
        for(int i=1;i <= n;i++){
            for(int j=1;j <= m;j++){
                for(int k=1;k <= x;k++){
                    f[i][j][k]=0;
                }
                cin >> mp[i][j];
            }
        }
        for(int i=1;i <= n;i++){
            for(int j=1;j <= m;j++){
                for(int k=0;k <= x;k++){
                    f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k])+(mp[i][j] == '1');
                    if(mp[i][j] == '?' && k) f[i][j][k]=max(f[i][j][k],max(f[i-1][j][k-1],f[i][j-1][k-1])+1);
                }
            }
        }
        printf("%d\n",f[n][m][x]);
    }
    return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：0)

这是一道非常经典的动规题目。

## 题目简述

小杨有一个有一个 $n \times m$ 的矩阵，仅包含 `01?` 三种字符。矩阵的行从上到下编号依次为 $1,2,\dots, n$，列从左到右编号依次为 $1, 2, \dots, m$。小杨开始在矩阵的左上角 $(1,1)$，小杨只能向下或者向右移动，最终到达右下角 $(n, m)$ 时停止，在移动的过程中每经过一个字符 `1` 得分会增加一分（包括起点和终点），经过其它字符则分数不变。小杨
的初始分数为 $0$ 分。小杨可以将矩阵中不超过 $k$ 个字符 `?` 变为字符 `1`。小杨在修改矩阵后，会以最优的策略从左上角移动到右下角。他想知道自己最多能获得多少分。

## 思路 $1$

一看到题目我们可以想到用深度优先搜索来实现这道题。函数定义成这样：

```cpp
int dfs(int x, int y, int coin, int k)
```

代表现在在坐标为 $(x,y)$ 的位置，现在有 $coin$ 个金币，还有 $k$ 次更改 `?` 的机会。

这种算法初步估算从 $(1,1)$ 遍历到 $(n,m)$ 最坏要用至少 $8\times 10^{10}$ 次递归。明显有些复杂。

## 思路 $2$

这道题的最优解：动态规划。

使用动态规划来解决这个问题，定义 $dp_{i,j,k}$ 表示从 $(1,1)$ 到达 $(i,j)$ 且已经将 $k$ 个 `?` 转换为 `1` 时的最大得分。

状态转移：

- 如果当前格子是 `1`，则 $dp_{i,j,k} = \max(dp_{i-1,j,k}, dp_{i,j-1,k}) + 1$。
- 如果当前格子是 `0`，则 $dp_{i,j,k} = \max(dp_{i-1,j,k}, dp_{i,j-1,k})$。
- 如果当前格子是 `?`，则 $dp_{i,j,k} = \max (dp_{i-1,j,k-1} + 1, dp_{i,j-1,k-1} + 1)$。

初始化：$dp_{1,1,0}$ 如果起点为 $1$，初始化为 $1$，否则为 $0$。

结果：最终结果为 $dp_{n,m,x}$。最坏时间复杂度为 $O(n^3)≈7.5\times10^7$。

## 核心代码

```cpp
// grid是输入时的字符串
if (grid[1][1] == '1') {
    dp[1][1][0] = 1;
} else if (grid[1][1] == '?') {
    dp[1][1][1] = 1;
} else {
    dp[1][1][0] = 0;
}

// 动态规划填表
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        for (int k = 0; k <= x; ++k) {
            if (dp[i][j][k] == -1)
                continue;
            if (i < n) {
                if (grid[i + 1][j] == '1') {
                    dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k] + 1);
                } else if (grid[i + 1][j] == '0') {
                    dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);
                } else if (k < x) {
                    dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + 1);
                }
            }
            if (j < m) {
                if (grid[i][j + 1] == '1') {
                    dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k] + 1);
                } else if (grid[i][j + 1] == '0') {
                    dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);
                } else if (k < x) {
                    dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + 1);
                }
            }
        }
    }
}

// 输出结果
int ans = 0;
for (int k = 0; k <= x; ++k) {
    ans = max(ans, dp[n][m][k]);
}
cout << ans << '\n';
```

---

## 作者：andycode (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11248)
# 题目大意
给出一个 $n$ 行 $m$ 列的只包含 `0`、`1`、`?` 的矩阵，你可以选择至多 $x$ 个 `?` 改成 `1`。

设得分为经过的 `1` 的数量，求从矩阵的 $(1,1)$ 开始，每次只能向右或向下移动，走到 $(n,m)$ 的最大得分为多少？
# 思路讲解
很容易想到动态规划。

设 $dp_{i,j,k}$ 为从 $(1,1)$ 走到 $(i,j)$，修改路径上 $k$ 个 `?` 为 `1` 的最大得分，$s_{i,j}$ 为第 $i$ 行 $j$ 列的字符。

我们遍历 $i,j,k$，如果 $s_{i,j}$ 为 `?`，且 $k>0$，则 $dp_{i,j,k}=\max(\max(dp_{i-1,j,k},dp_{i,j-1,k}),1+\max(dp_{i-1,j,k-1},dp_{i,j-1,k-1}))$，即我们改或者不改 $s_{i,j}$。

否则 $dp_{i,j,k}=[s_{i,j}=1]+\max(dp_{i-1,j,k},dp_{i,j-1,k})$

最终答案为 $\max\limits_{i=0}^{i\le x}(dp_{n,m,i})$。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,m,x,dp[502][502][302];
string s[502];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&n,&m,&x);
        for(int i=1;i<=n;i++){
            cin>>s[i];
            s[i]=" "+s[i];
        }
        memset(dp,0,sizeof(dp));//不要忘了初始化
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                for(int k=0;k<=x;k++){
                    dp[i][j][k]=(s[i][j]=='1')+max(dp[i-1][j][k],dp[i][j-1][k]);//先考虑不改变 s[i][j] 的情况
                    if(k>0 && s[i][j]=='?')
                        dp[i][j][k]=max(dp[i][j][k],1+max(dp[i-1][j][k-1],dp[i][j-1][k-1]));//考虑改变 s[i][j] 的情况
                }
        int ans=0;
        for(int i=0;i<=x;i++)
            ans=max(ans,dp[n][m][i]);//求最大值
        printf("%d\n",ans);
    }
    return 0;
}
```

---


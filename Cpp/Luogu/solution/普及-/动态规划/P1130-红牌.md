# 红牌

## 题目描述


某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。

为了防止所有申请人都到效率高的工作人员去申请。这 $M \times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。

例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：

- 小组 $1$： $2, 6 ,1 ,8$；
- 小组 $2$：$3,6, 2, 6$；
- 小组 $3$：$ 4, 2 ,3 ,6$。

例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。

你的任务是求出完成申请所花最少天数。

## 说明/提示

对于 $100\%$ 的数据，$1\le N,M \le 2000$。

## 样例 #1

### 输入

```
4 3 
2 6 1 8
3 6 2 6
4 2 3 6
```

### 输出

```
12```

# 题解

## 作者：whx1003 (赞：92)

### 很明显是动规

$f[i][j]$ 表示第 $i$ 阶段第 $j$ 小组的最小天数

转移方程为

$$f[i][j]=\min(f[i-1][j],f[i-1][j-1])+a[i][j]$$

但是第 $1$ 个小组最小天数是由第 $m$ 个小组转移来的，所以需要多一个特判：

$$f[i][j]=min(f[i-1][j],j==1?f[i-1][m]:f[i-1][j-1])+a[i][j]$$

还有一个比较恶心的问题，我们读入时是按第 $i$ 小组第 $j$ 阶段存储的，但转移时变成了第 $i$ 阶段第 $j$ 小组，所以可以稍微改变一下读入方式：
```cpp
    scanf("%d", &a[j][i]);
```


代码：
```cpp
#include<cstdio>
#include<algorithm>

const int maxn = 2005;
const int INF = 0x3f3f3f3f;

int n, m;
int a[maxn][maxn], f[maxn][maxn];

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; ++i)
        for(int j = 1; j <= n; ++j)
            scanf("%d", &a[j][i]);
    
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            f[i][j] = std::min(f[i - 1][j], j == 1 ? f[i - 1][m] : f[i - 1][j - 1]) + a[i][j];
    
    int ans = INF;
    for(int i = 1; i <= m; ++i)
        ans = std::min(ans, f[n][i]);
    printf("%d", ans);
    
    return 0;
}
```

---

## 作者：引领天下 (赞：60)

纪念一下我做出的第一道DP题

此题很像数字三角形，只不过那题要求所经数值最大，这题最小。

~~ 话说我觉得并没有什么方程…… ~~

思路：从倒数第2步考虑，取两种方案中最小的一种，然后一直做到第一步，找最小值。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;
int n,m,a[2005][2005],ans=1<<30;//ans必须要定大，不然找不到最小值
int main(){
    scanf ("%d%d",&n,&m);
    for (int i=0;i<m;i++)
    for (int j=0;j<n;j++)scanf ("%d",&a[i][j]);
    for (int j=n-2;j>=0;j--)//从倒数第2步开始，向第一步推进
    //我用的是0下标
    for (int i=0;i<m;i++)
    a[i][j]=min(a[(i+1)%m][j+1],a[i][j+1])+a[i][j];//取最小值，更新为之后的步骤的最小值
    for (int i=0;i<m;i++)ans=min(ans,a[i][0]);//找答案
    printf ("%d",ans);//结束
    return 0;
}
```

---

## 作者：juruo_zjc (赞：42)

# 像我这样的蒟蒻往这儿看！

首先，这是一道不太难的题目（~~话说我还做了一个晚上呢~~）


------------
大家可以发现，其实这道题真的就像第一篇引领天下先生写的题解中说的：“此题很像数字三角形，只不过那题要求所经数值最大，这题最小。”但是，本题和数字三角形不一样，重要的就是题目中说的，“小组M可以更换到小组1”。于是，我们可以像数字三角形一样，只是用加一点儿小技巧，具体见代码。


------------
```cpp
#include<bits/stdc++.h>
#define LL long long//此题必须用longlong否则只能那60分
using namespace std;
LL n,m,gay[2005][2005],dp[2005][2000],minn=1e8;//dp[i][j]表示第i个人做完第j个步骤的最小代价
int main()
{
	cin>>n>>m;
	for(LL i=1;i<=m;i++)
		for(LL j=1;j<=n;j++)scanf("%d",&gay[i][j]);//读入，注意我没有像其他大佬的题解一样竖着读（主要还是我太弱了，不会反着处理~~）
	for(LL j=1;j<=n;j++){//循环n个步骤
		dp[0][j-1]=dp[m][j-1];//本题重点就在这里了！上一步的第零位，其实就是上一位的最后一位，因为最后一个小组是可以更换到1的
		for(LL i=1;i<=m;i++)//循环m个人，每一个步骤都有m个人可以完成，挨个儿决策
			dp[i][j]=min(dp[i-1][j-1],dp[i][j-1])+gay[i][j];//第i个人做第j步，可以由它的第j-1个步骤的第i-1个人或者第i个人转移过来
	}
	for(LL i=1;i<=m;i++)//打擂台求最小值，因为做完最后一步不一定要最后一个人完成，所以打擂台
		minn=min(minn,dp[i][n]);//求做完n个步骤，最后一步由谁来做的最小值
	cout<<minn;
	return 0;
}
```

---

## 作者：feecle6418 (赞：27)

【题目名称】红牌

【题意大概】做一件事有N步，又有M个小组，每一步花的时间不同，每步做完后，你可以从小组i转换到小组i+1（小组M直接到小组1）。求做完这件事最少总时间。

【标签】动态规划

【重点与坑点】

1. 重点：

- 本题是P1216的后继版，连转移方程都一模一样，建议先完成P1216。

- 注意小组M直接到小组1的转换。

- 设f[i][j]表示第i步在第j个小组的最少天数，状态转移方程为：$f[i][j]=min(f[i-1][j-1],f[i-1][j])+a[i][j]$。

2. 坑点：请注意输入顺序！！！（**分小组输入，分步动规**）

【代码核心部分】

```cpp
    for(int i=1; i<=M; i++) {
        for(int j=1; j<=N; j++) {
            scanf("%d",&a[j][i]);//注意输入顺序
        }
    }
    for(int i=1; i<=N; i++) {
        f[i-1][0]=f[i-1][M];//重点
        for(int j=1; j<=M; j++) {
            f[i][j]=min(f[i-1][j-1],f[i-1][j])+a[i][j];//状态转移方程
        }
    }
    long long int MMM=f[N][1];
    for(int i=2;i<=M;i++){
        MMM=min(MMM,f[N][i]);
    }
```

---

## 作者：Waddles (赞：16)

这题没有记搜题解？我来贡献一发

最近刚系统地学记搜，于是搜动规题练练记搜的手（考场上估计写不出DP的我看来只能写记搜了）

记搜万岁！！！

记搜很好想啊，就两种状态：1,走这行的下一个；2，走相邻行的写一个

就这样

code:

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class AC>void r(AC &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
int n,m,ans=1<<30,a[2005][2005],f[2005][2005];
int dfs(int x,int y){//f[i][j]表示当前第i组第j个数 
	if(f[x][y]!=-1)return f[x][y];
	if(y==n+1)return f[x][y]=0;
	int s1=0x3f3f3f3f,s2=0x3f3f3f3f;
	s1=dfs(x,y+1)+a[x][y+1];
	int xx=x+1;
	if(xx>m)xx-=m;
	s2=dfs(xx,y+1)+a[xx][y+1];
	return f[x][y]=min(s1,s2);
}
int main(){
	memset(f,-1,sizeof(f));
	r(n);r(m);
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			r(a[i][j]);
		}
	}
	for(int i=1;i<=m;i++)ans=min(ans,dfs(i,0));
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：dz_ice (赞：11)

这些题解中竟然没有用环形做法的？可以把输入的矩阵复制一份放在下面，$n*=2$，具体可以看一下我的代码，可以很轻松的解决小组$M$更换到小组1的这个问题，这种思路比较像[这道题](https://www.luogu.org/problem/P1880)
，有兴趣的可以去看看

状态转移方程就不用多说了，跟数字三角形是一样的，其他的题解里讲的也很详细

方程：$f[i][j]=min(f[i-1][j-1],f[i-1][j])+a[i][j]$

接下来上代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[4003][2003],f[4003][2003],ans=2000000000; //按照这个做法数组要开两倍大小 
int main()
{
	cin>>m>>n;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
		{
			cin>>a[i][j];
			a[i+n][j]=a[i][j]; //复制一份矩阵的操作 
		}
	for(int i=0; i<=m; i++)
		f[0][i]=1e9; //记得初始化 
	n=2*n; //矩形长度要变为两倍 
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
		{
			f[i][j]=min(f[i-1][j-1],f[i][j-1])+a[i][j]; //转移方程 
			if(j==m)
				ans=min(ans,f[i][j]); 
		}
	cout<<ans;
	return 0;
}
```


---

## 作者：BBD186587 (赞：10)

## dp简单模板 ##
1.状态设计

我的状态是二维的，f[i][j]表示以第i组结尾的情况到第j项任务最少需要的天数。

2.转移方程

以这个状态设计方程应该很简单。。。略微思考可得

```cpp
f[j][i]=min(f[j-1][i-1],f[j][i-1])+a[j][i];
```

但这道题有个小坑点是第m组可切换至第一组，于是我们需要再加一句

```cpp
f[1][i]=min(f[1][i-1],f[m][i-1])+a[1][i];
```

这两个方程应该比较好理解，就不过多说明了

3.代码实现

方程都给了，还需要代码吗？？？

不过代码里的循环我调了很久。。。所以还是上个代码吧。。。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[2010][2010],f[2010][2010],mn=0x7fffffff;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++) f[i][1]=a[i][1];//初始状态
	for(int i=2;i<=n;i++)//这里一定要先遍历天数再遍历组数
	{
		for(int j=2;j<=m;j++)
			f[j][i]=min(f[j-1][i-1],f[j][i-1])+a[j][i];
		f[1][i]=min(f[1][i-1],f[m][i-1])+a[1][i];
	}
	for(int i=1;i<=m;i++) mn=min(mn,f[i][n]);//取第n天时以各组结束的最小值
	printf("%d",mn);
	return 0;
} 
```

完结撒花~~

---

## 作者：Smallbasic (赞：9)

## 一道 dp的入门题
很像[P1216数字三角形](https://www.luogu.org/problemnew/show/P1216)，没做过的同学可以去做一下。

------------
题目翻译过来就是给你一个m行n列的矩阵a，可以从a[1][i] (0<i<n+1)开始走，从a[i][j]只能走到a[i+1][j+1] (a[m][j]可以走到a[1][j+1]),求走到a[l][n] (0<l<m+1)经过点上数字之和的的最小值。如：
```
/*
2 	6 	1 	8
3 	6 	2 	6
4 	2 	3 	6
从 a[2][1]出发，路程为
a[2][1] -> a[3][2] -> a[1][3] -> a[2][4]
数字之和最小值为
3+2+1+6=12
*/

```
设f[i][j]表示到了第i列且在第j行时取得的最小值。则一共有两种状态：

1.从a[j-1][i-1] 到达 a[j][i],表示为f[i-1][j-1]+a[j][i]

2.从a[j][i-1] 到达 a[j][i] 表示为f[i-1][j]+a[j][i]

就很容易推出状态转移方程:
# f[i][j]=min(f[i-1][j-1],f[i-1][j])+a[j][i];
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T> inline T minn(T a,T b){
	return a<b?a:b;
}//比较大小
int main(){
	int n,m;
	cin>>n>>m;
	int a[m+1][n+1];
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	int f[n+1][m+1];
   //初始化f数组
	memset(f,0,sizeof(f));
	for(int i=1;i<=m;i++){
		f[1][i]=a[i][1];
	}
	int ans=0x7fffffff; //最小值
	for(int i=2;i<=n;i++){
		f[i][1]=minn(f[i-1][m]+a[1][i],f[i-1][1]+a[1][i]);//因为从m可以跳到1，所以要加特判
		if(i==n){
			ans=minn(f[i][1],ans);
		}
		for(int j=2;j<=m;j++){
			f[i][j]=minn(f[i-1][j-1]+a[j][i],f[i-1][j]+a[j][i]);//转移方程
			if(i==n){//更新最小值
				ans=minn(ans,f[i][j]);
			}

		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Aliemo (赞：4)

~~简单的DP~~
### 看到那么多人写顺推，还没有一个人写逆推，我就来贡献一下吧~~滑稽~~

题目中说的是小组 “I更换到小组I+1,当然从小组M可以更换到小组1”逆推就变成了“I更换到小组I-1,当然从小组1可以更换到小组M”这是不用证明的，自己手推一下样例就行了~~QAQ~~ 

从倒数第2步考虑，取两种方案中最小的一种，然后一直做到第一步，找最小值

##### 又到了喜闻乐见的代码环节了，来，上代码
```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>

#define rr register

#define ll long long
#define db double

#define inf 1e9

using namespace std;

const int MAXN = 2e3 + 5;

inline int read() {
	int s = 0, m = 0;
	char ch = getchar();
	while (!isdigit(ch)) { m |= ch == '-'; ch = getchar();}
	while (isdigit(ch)) { s = s * 10 + (ch ^ 48);ch = getchar();}
	return m ? -s : s;
}

int a[MAXN][MAXN];

int n,m;

signed main(signed argc, char const *argv[]) {
	n = read();
	m = read();
	for (rr int j = 1; j <= m; j++)
		for (rr int i = 1; i <= n; i++)
			a[i][j] = read();
	for (rr int i = n - 1; i >= 1; i--){
		for (rr int j = 1; j <= m; j++) {
			if (j != m) a[i][j] += min(a[i + 1][j], a[i + 1][j + 1]);
			else {
				a[i][j] += min(a[i + 1][j], a[i + 1][1]);
			}
		}
	}
	int minn = inf;
	for (rr int i = 1; i <= m; i++) {
		minn = minn > a[1][i] ? a[1][i] : minn;
	}
	cout << minn;
	return 0;
}
```


---

## 作者：insprition (赞：4)

我说一下个人理解


经典的dp

[洛谷 P1216 数字三角形 ](https://www.luogu.org/problem/show?pid=1216)

横过来就是这道题了


具体dp就不必说了

我觉得 dp 上写转移方程

一个很重要的技巧就是

迁移到 **已经熟练** 或者 **很经典** 的dp题目上

换成熟悉的题目背景去写


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2010
#define M 1010
int ans,n,m,dp[N][M],t[N][M];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&t[j][i]);
    for(int i=1;i<n;i++){
        dp[i][1]=min(dp[i-1][1],dp[i-1][m])+t[i][1];
        for(int j=2;j<=m;j++)
            dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+t[i][j];          
    }
    ans=min(dp[n-1][1],dp[n-1][m])+t[n][1];
    for(int j=2;j<=m;j++)
        ans=min(ans,(min(dp[n-1][j],dp[n-1][j-1])+t[n][j]));        
    cout<<ans;
    return 0;
}

```

---

## 作者：Komorebi_shine (赞：3)

据我同学（DP小王子）&&众多题解说，这题就是数字三角形的变式。然后他经过深思熟虑（？），给我这么一个方程：
```cpp
f[i][j]=min(f[i-1][j-1],min(f[i-1][j],f[i-1][j+1]))+a[i][j];
```
我看了一眼，直接怼他没好好看题。然后，然后他就不肯帮我做了。。。

————————————分割线————————————

这一题首先要注意输入顺序，要把输入的矩阵“立起来”，也就是横行变竖列，竖列变横行。~~事实上，我知道要这样，但由于不当的转换还是错了不少~~

然后是方程。我虽然看到了题目的边界转换处理，但我同时也被那个同学带偏了：

（以下jiayi（，jianyi）函数为题目意义的对一个数加（剪）一，也就是n变1（,1变n），其他不变）
```
      f[i][j]=min(f[i-1][j],min(f[i-1][jianyi(j)],f[i-1][jiayi(j)])+a[i][j]);
```

后来经过无数的wa之后我意识到**只能正向换小组**，也就是说，f[i][j]只能从f[i-1][j]和f[i-1][jianyi(j]]转移。~~然后我又删错了函数导致wa，样例还调不出来~~

附AC代码（我把jianyi函数删掉了，抄题解的小心点）
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,a[2010][2010],f[2010][2010],s;
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++)
     for (j=1;j<=n;j++)
      scanf("%d",&a[j][i]),f[j][i]=1e15;
    for (i=1;i<=n;i++)
     for (j=1;j<=m;j++)
      f[i][j]=min(f[i-1][j],f[i-1][jianyi(j)])+a[i][j];
	s=f[n][1];
	for (i=2;i<=m;i++) s=min(s,f[n][i]);
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：ws_pt2 (赞：3)

f[i,j]表示到第i步，找第j个小组的最小天数，状态转移方程就是楼下的同志们说的

我来贴一个C++的代码：

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#define inf 199999997
using namespace std;
int f[2333][2333],a[2333][2333];
int n,m,ans;
int main()
{
        scanf("%d%d",&m,&n);
        for (int i=1 ;i<=n; i++)
             for (int j=1; j<=m ;j++)
                  scanf("%d",&a[i][j]);  
        for (int i=1 ;i<=n ;i++)
             for (int j=1; j<=m; j++)
                  f[i][j]=inf;         //预处理 
          for (int i=1; i<=n; i++)
               f[i][1]=a[i][1];        //预处理走第一步的情况
        for (int j=2; j<=m; j++)    
            for (int i=1; i<=n; i++)
                {
                        if (i==1) f[i][j]=a[i][j]+min(f[i][j-1],f[n][j-1]);    //状态转移中 
                        else f[i][j]=a[i][j]+min(f[i][j-1],f[i-1][j-1]);
            }
        ans=199999997;
        for (int i=1; i<=n; i++)
             if (ans>f[i][m]) ans=f[i][m];    //从f[i,m]中找最小的那个 
        cout<<ans;
        return  0;
}
```

---

## 作者：ShineEternal (赞：2)

[link](https://blog.csdn.net/kkkksc03/article/details/103963852)

## description：
矩阵型，从左到右，上下相连的数字三角形。
## solution：
大体的思路与数字三角形相似。

但是这题矩形的长宽颠倒不太方便，读入的时候可以
```
scanf:a[j][i]
```
来巧妙的转换一下。（相当于把矩形给竖起来？）

这就导致（拿样例为例）：
```cpp
2 6 1 8
3 6 2 6
4 2 3 6
```

在转换之后变成了：
```cpp
2 3 4
6 6 2
1 2 3
8 6 6
```

这样的话，原本的从左上，左转移过来，现在就是左上和上。
- 然后就是到了第一行时要特判一下，因为是最后一行可以翻过去。
- 其他基本上就是数字三角形的思路了。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[2005][2005],f[2005][2005];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[j][i]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(j==1)
			{
				f[i][j]=min(f[i-1][j],f[i-1][m])+a[i][j];
			}
			else
			f[i][j]=min(f[i-1][j],f[i-1][j-1])+a[i][j];
		}
	}
	int ans=2147483640;
	for(int i=1;i<=m;i++)
	{
		ans=min(ans,f[n][i]);
	}
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：zhaowangji (赞：2)

我觉得这题的难度恶评了啊。。。

感觉明明不止普及—的难度啊~~还是我DP太菜了~~

设f[i][j]表示到了第i组第j个步骤时能用的最短时间

答案是把f[1~m][n]中找一个最小值

初值全为0x3f3f3f3f，然后每组第1个步骤就等于该步骤所用的时间

方程：（特判i=1的情况）一种情况是从原来这队继续走，另一种是从i-1队变过来

```cpp
	if(i!=1){
		f[i][j]=min(f[i][j],f[i][j-1]+a[i][j]);
		f[i][j]=min(f[i][j],f[i-1][j-1]+a[i][j]);
	}
	if(i==1){
		f[i][j]=min(f[i][j],f[i][j-1]+a[i][j]);
		f[i][j]=min(f[i][j],f[m][j-1]+a[i][j]);
	}
```

然后注意枚举i的时候应该是m~1（因为如果顺序，推f[1][]的时候f[m][]的值还没出来）

```cpp
#include<iostream>
#include<algorithm>
#include<string.h> 
using namespace std;
int a[2007][2007];
int f[2007][2007];
int ans;
int n,m;
int main(){
	memset(f,0x3f,sizeof(f));
	memset(a,0x3f,sizeof(a));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	for(int j=1;j<=n;j++){
		cin>>a[i][j];
		if(j==1)f[i][j]=a[i][j];
	}
	for(int j=1;j<=n;j++)
	for(int i=m;i>=1;i--){
		if(i!=1){
			f[i][j]=min(f[i][j],f[i][j-1]+a[i][j]);
			f[i][j]=min(f[i][j],f[i-1][j-1]+a[i][j]);
		}
		if(i==1){
			f[i][j]=min(f[i][j],f[i][j-1]+a[i][j]);
			f[i][j]=min(f[i][j],f[m][j-1]+a[i][j]);
		}
	}
	int ans=0x3f3f3f3f;
	for(int i=1;i<=m;i++)
	ans=min(ans,f[i][n]);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：香风智乃 (赞：2)

话说，只要1个数组就能搞定了......

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int f[2003][2003],n,m;
void print()
{
    printf("\n");
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++) printf("%d ",f[i][j]);
        printf("\n");
    }
    return ;
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
        for(j=1;j<=n;j++)
            scanf("%d",&f[i][j]);
    for(i=2;i<=n;i++)
        for(j=1;j<=m;j++)
        {
            if(j==1)
                f[j][i]+=min(f[1][i-1],f[m][i-1]);
            else
                f[j][i]+=min(f[j][i-1],f[j-1][i-1]);  // 状态转移方程，读题就可得出：i表示第i组  j表示第j个步骤
        }
    int ans=1e9;
    for(i=1;i<=m;i++)
        ans=min(ans,f[i][n]);   //末尾搜一遍取最小值
    printf("%d",ans);
    //print();   //用于检查数据
    return 0;
}

```

---

## 作者：I_will (赞：1)

这道题有一种新的 dp（动规）算法！

* 一如既往的输入...
* 过程是：在别人的基础上，改成
：a[j][i]+=min(a[j][i-1],a[j-1][i-1]);
* 既省掉了第二个数组，在错的时候也容易判断错！
* 两全其美，岂不美哉？真香！！！

程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[2005][2005];
int h;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		cin>>a[i][j];
    	}
    }
    for(int i=1;i<=n;i++)
    {
    	
    	a[1][i]+=min(a[1][i-1],a[m][i-1]);//一的特判，1对的是m。
    	
    	for(int j=2;j<=m;j++)
    	{
    		
    		a[j][i]+=min(a[j][i-1],a[j-1][i-1]);
    		//其余照常即可。
		}
		
    }
    h=17677439;//随便搞个最大值。
    for(int i=1;i<=m;i++)h=min(h,a[i][n]);
    //判断h与a[i][n]的判断，完毕再输出，就行了。
	cout<<h;
	return 0;
}
```


---

## 作者：天命之路 (赞：1)

**首先，这道题最优方法应该是DP，再加上空间大约是2001^2 *2 *4B（2001^2是int二维数组，一个存本来数据，一个存DP的值）并不超。**

主要思想：顺序递推，一定按天数，一天一天往后推，**两层循环千万别写反了！！！**

具体实现：

```
#include<bits/stdc++.h>
using namespace std;
int m,n,a[2001][2001],f[2001][2001];
int main()
{
	scanf("%d %d",&m,&n);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)        //1
	cin>>a[i][j];
	for(int i=1;i<=n;i++) f[i][1]=a[i][1];    //2
	for(int j=2;j<=m;j++)
	for(int i=1;i<=n;i++)
	{
		if(i==1) f[i][j]=min(f[i][j-1],f[n][j-1])+a[i][j];      //3
		else f[i][j]=min(f[i][j-1],f[i-1][j-1])+a[i][j];
	}
	int ans=1e9;

	for(int i=1;i<=n;i++) ans=min(ans,f[i][m]);    //4
	
	cout<<ans;
	return 0;

}
```

1:输入。可以看到，题目中是先输入行，后输入列。该代码中用
m表示行，n表示列，故先输入m,后输入n.

2:DP初始化。众所周知，在第一天时，选择哪个小组的最小天数，就是哪个小组第一步的天数。n是小组数，在矩阵里是行数，在第一个下标。

3：DP核心部分。 _**两个循环一定不要写反！**_ 这是我说第二遍了。（如果写反了，遍历到第三步就会出问题。）可以看到，每个小组在每一步的最小天数就是在前一步中，该小组的最小天数，和前一小组的最小天数的最小值，再加上该小组这一步的天数（有点绕，其实可以这么理解：如果在前一步中，从该小组顺延过来的天数比从前一小组换过来的天数少，就将这部分天数顺延过来，再加上这一步的天数，反之亦然）。当然，还有一个特殊情况：如果i(小组号）为1，那他只能从n组换过来,这就是特判的原因了。

4：计算答案：我们要计算的，是f[1][m]到f[n][m]之间的最小值，这是为了比较出执行完全部m步后的最优方案，故先初始化
ans为1e9(即1000000000,10的9次方），然后遍历比较，得出答案。


最后说一句，若有哪位奆佬知道怎么更好解决环状数据，可以在评论区留言，谢谢！


---

## 作者：Jelly_Goat (赞：1)

### 逆推dp经典题目：数字三角形的折叠版
为什么这么说？  
因为我们会发现：除了每一次都特判一下是否转换行号以外，剩下的思想没什么不同。  
> 没看题目的[看这里](https://www.luogu.org/problemnew/show/P1130)  

------

先定义：  
`n,m`是步骤数目，小组数目  
`work[i][j]`表示第`i`个小组第`j`步需要的天数  
`f[i][j]`表示当前第`i`个小组第`j`步的最优天数

首先我们先看到这个题说是要**求最小天数**  
然后我们知道这个最小天数是**由原先的两个最小天数分别加上当前小组工作天数，然后二者求最小值**(因为前面的两个子状态——天数决定了后面的状态——当前最小天数)  
这中间告诉我们**当最下面的小组还想向下找小组，就返回最上面的小组1**。  
所以我们得出几个推论：  
1. 因为最后不同的小组会得到不同的值，所以我们应当求出最后一步中的最小天数值（最小值跑最后一列一遍）
2. 普通（指的是不看第三点）的dp状态转移方程就是
$$
f[i][j]=min(f[i-1][j-1]+work[i][j],f[i][j-1]+work[i][j])
$$
3. 逆着想，当`i=1`的时候，决定当前最小天数的是`i=n`和`i=1`两个子状态，所以当`i=1`的时候，转移的`i-1`就应当变成`n`。
于是得出下面的递推式：
$$
f[i][j]=min(f[i!=1?i-1:n][j-1]+work[i][j],f[i][j-1]+work[i][j])
$$
这样这个题的思路就做完了。

------

代码好说：
```cpp
#include <iostream>
#include <cstdio>
#define fin cin//测试来着
#define fout cout

using namespace std;
typedef long long int lli;
const int maxn=2000,maxm=2000;
lli f[maxm+1][maxn+1],work[maxm+1][maxn+1];
//f[i][j]表示当前第i个小组第j步的最优结果
lli n,m,ans=2147483647;

inline lli max(lli a,lli b) {
	return a>=b?a:b;
}
inline lli min(lli a,lli b) {
	return a<=b?a:b;
}

int main() {
	fin>>n>>m;
	for (register int i=1; i<=m; i++) {
		for (register int j=1; j<=n; j++) {
			fin>>work[i][j];
		}
	}
	//上面是按照表读的
	for (register int i=1; i<=m; i++) {
		f[i][1]=work[i][1];
	}
	//第一步就是原先第一列的内容
	for (register int i=2; i<=n; i++) {
		//从第二步骤开始推
		for (register int j=1; j<=m; j++) {
			//j是当前到了第几个小组
			if (j==1) {
				f[j][i]=min(f[m][i-1]+work[j][i],f[j][i-1]+work[j][i]);
			} 
        else {
				f[j][i]=min(f[j-1][i-1]+work[j][i],f[j][i-1]+work[j][i]);
			}
		}
	}
	for (register int i=1; i<=m; i++) {
		ans=min(ans,f[i][n]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：wanglichao1121 (赞：1)

一道很水的动态规划。

以步骤为阶段

此处注明：

少内存大法：由于数据一次性，我直接在输入数组里动态规划，导致内存最少！！！

```delphi

var n,m,i,j:longint;a:array[1..1000,1..2000]of longint;  
function min(a,b:longint):longint;begin if a<b then exit(a) else exit(b);end;  
function de(a:longint):longint;begin if a>1 then exit(a-1)else exit(m); end;  
begin  
  readln(n,m);  
  for i:=1 to m do  
  for j:=1 to n do  
  read(a[i,j]);  
  for i:=2 to n do  
  for j:=1 to m do  
  a[j,i]:=min(a[j,i-1],a[de(j),i-1])+a[j,i];  
  for i:=2 to m do  
  if a[i,n]>a[i-1,n] then a[i,n]:=a[i-1,n];  
  writeln(a[m,n]);  
end.

```

---

## 作者：松鼠党 (赞：1)

再交一份题解。  
思路简单，将其看作一个二维迷宫，只能向前或向前下方走，求最少得分。直接用f数组记下到达当前位置时所得到的最少得分，然后详见代码。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[2010][2010],f[2010][2010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++)
	        cin>>a[i][j];
	    f[i][1]=a[i][1];//这边带着初始化
	}
	
	for(int j=2;j<=n;j++){//动态转移
		f[1][j]=min(a[1][j]+f[1][j-1],a[1][j]+f[m][j-1]);//因为在第一行时可以由最后一行到达，所以特判
		for(int i=2;i<=m;i++)
			f[i][j]=min(a[i][j]+f[i][j-1],a[i][j]+f[i-1][j-1]);//转移方程，耿直的比较
	}
		
	for(int i=1;i<m;i++)
	    for(int j=i+1;j<=m;j++)
	        f[i][n]=min(f[i][n],f[j][n]);//清奇的做法，直接将最后一列用最小值覆盖~~（虽然貌似好像或许不用这么繁）~~
	cout<<f[1][n]<<endl;//完美结束~~一点也不完美~~
	return 0;
}
```  


---

## 作者：Hanzire76 (赞：0)

# [我的博客](zxjnvrgvp.github.io)
以上是打广告

# 思路
分析题意，一个格子能选择往正右走还是右下走，求到最后一列得到的最小值。

设`f[N][N]`为dp数组，`f[j][i]`代表走到第`j`行第`i`列时可能得到的最小值。我们可以得到状态转移方程：
$$ f[j][i]=min(f[j][i-1],f[j-1][i-1])+a[j][i] $$

代表状态从左方或左上方传递过来，应注意当`j==1`时，`f[j-1][i-1]`应该替换为`f[m][i-1]`。

# 代码
```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
using namespace std;

const int N = 2005;
int n, m, a[N][N], f[N][N], ans = 0x3f3f3f3f;

int main(int argc, char const *argv[])
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i++)
        f[i][1] = a[i][1];
    for (int i = 2; i <= m; i++)
        for (int j = 1; j <= n; j++)
        {
            if (j == 1)
                f[j][i] = min(f[j][i - 1], f[n][i - 1]) + a[j][i];
            else
                f[j][i] = min(f[j][i - 1], f[j - 1][i - 1]) + a[j][i];
        }
    for (int i = 1; i <= n; i++)
        ans = min(ans, f[i][m]);
    cout << ans;
    return 0;
}

```


---

## 作者：黯黑の夜 (赞：0)

这道题其实不是很难，只要特判一下1和n就行了

C党代码

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int a[2001][2001];//如果定义局部变量会不实行
int main()
{
	int n,m,i,j,minn=1000001,mi,k,mmi;
	long long t=0;
	scanf("%d%d",&m,&n);
	for(i=1;i<=n;i++)
	for(j=1;j<=m;j++)
	scanf("%d",&a[i][j]);
	for(i=1;i<=n;i++)//先找到mi的位置 
	{
		minn=1000001;
		for(j=1;j<=m;j++)
		if(a[i][j]<minn)
		{
			minn=a[i][j];
			mi=i;
		}
	}
	for(k=2;k<=n;k++)
	{
		minn=1000001;
		if(mi==1)//特判1 
		{
			for(j=1;j<=m;j++)
			if(a[n][j]<minn)
			{
				minn=a[n][j];
				mmi=n;
			}
			for(i=1;i<=2;i++)
			for(j=1;j<=m;j++)
			if(a[i][j]<minn)//比较 
			{
				minn=a[i][j];
				mmi=i;
			}
		}
		else if(mi==n)
		{
			for(j=1;j<=m;j++)//特判n 
			if(a[1][j]<minn)
			{
				minn=a[1][j];
				mmi=1;
			}
			for(i=n-1;i<=n;i++)
			for(j=1;j<=m;j++)
			if(a[i][j]<minn)//比较 
			{
				minn=a[i][j];
				mmi=i;
			}
		}
		else
		{
			for(i=mi-1;i<=mi+1;i++)
			for(j=1;j<=m;j++)
			if(a[i][j]<minn)//比较 
			{
				minn=a[i][j];
				mmi=i;
			}
		}
		mi=mmi;
		t+=minn;//加上当前最小值 
	}
	printf("%lld",t);
	return 0; 
}
```

注释有点少，但主要是理解过程。@^_^@~~(脸红）~~


---

## 作者：lzy755277 (赞：0)

这题主要是推出状态转移方程:

f[i][j]表示第i小组第j阶段的最小天数。

f[i][j]=前一个小组与当前小组的最小值+当前需要的天数。

f[i][j]=min(f[i][j-1]+a[i][j],f[i-1][j-1]+a[i][j])

注意:当i=1时,要特判.j从2开始。

代码:
```cpp
#include<bits/stdc++.h>//万能头文件。
using namespace std;
long long n,m,a[2001][2001],i,j,f[2001][2001]={0},mi=9999999999;
//这句话放下面会停止工作,放上面就不会了。
int main()
{
	cin>>m>>n;//输入行(小组)和列(阶段)
	for(i=1;i<=n;i++)
	for(j=1;j<=m;j++)
	cin>>a[i][j];//输入天数
	for(i=1;i<=n;i++)
	f[i][1]=a[i][1];
    //第一阶段初始化
	for(j=2;j<=m;j++)//先用j循环,因为总天数是一个一个阶段下去算出来的
	for(i=1;i<=n;i++)
	{
		f[i][j]=min(f[i][j-1]+a[i][j],f[i-1][j-1]+a[i][j]);
		if(i==1)
        //如果当前为小组1,它是f[n][j-1]+a[i][j]和f[1][j-
        //1]中的最小值
        //所以要特判
		f[i][j]=min(f[n][j-1]+a[i][j],f[1][j-1]+a[i][j]);
	}
	for(i=1;i<=n;i++)
	{
		if(f[i][m]<mi)mi=f[i][m];//求最小天数
	}
	cout<<mi;//输出
    return 0;//完美结束
}
```

---


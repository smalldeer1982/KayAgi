# [GESP202506 六级] 学习小组

## 题目描述



班主任计划将班级里的 $ n $ 名同学划分为若干个学习小组，每名同学都需要分入某一个学习小组中。观察发现，如果一个学习小组中恰好包含 $ k $ 名同学，则该学习小组的讨论积极度为 $ a_k $。

给定讨论积极度 $ a_1, a_2, \ldots, a_n $，请你计算将这 $ n $ 名同学划分为学习小组的所有可能方案中，讨论积极度之和的最大值。


## 说明/提示

对于 $40\%$ 的测试点，保证 $1\le n\le 10$。

对于所有测试点，保证 $1\le n\le 1000$，$0\le a_i\le 10^4$。

## 样例 #1

### 输入

```
4
1 5 6 3```

### 输出

```
10```

## 样例 #2

### 输入

```
8
0 2 5 6 4 3 3 4```

### 输出

```
12```

# 题解

## 作者：Gilbert1206 (赞：13)

## 题解：P13015 [GESP202506 六级] 学习小组

[题目传送门](https://www.luogu.com.cn/problem/P13015)

## 思路

这道题其实从数据范围就可以看出明显的一道 DP 题目，当然我们现在有 $n$ 名同学，如果我们选择其中的 $k$ 名同学，此时产生的价值伪 $a_k$。我们就可以发现我们把 $n$ 名同学比作背包容量，如果你要获得积极度 $a_k$，则你需要的代价就为 $k$，最后你要求把背包装满最多能获得多少价值。因为这道题虽然需要装满但是 $a_i \ge 0$，所以最大价值肯定会把所有的同学都填入进去。其实你最后能发现代码和完全背包的代码相差无几。

## code


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4500],dp[4500];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
		    dp[j]=max(dp[j],dp[j-i]+a[i]);//完全背包
		}
	}
	cout<<dp[n];//花费n的代价获得的最大价值
	return 0;
}

```

---

## 作者：Sunrise_up (赞：7)

一个非常好想的 dp。

## 状态定义

定义 $dp_i$ 为 $i$ 个人的讨论积极度的最大值。

## 初始化

很明显，$dp_0=0$。

## 转移方程

对于 $dp_i$，既然要让最大，可以先选择一个 $dp_j(j< i)$，再让剩余的人组成一个组，即：

$$dp_i=\max\{dp_j+a_{i-j}\}\ (j<i)$$

## 答案

输出 $dp_n$ 即为答案。

## 代码

时间复杂度为 $O(n^2)$。


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[1001],dp[1001];
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	scanf("%d",a+i);
    	for(int j=0;j<=i-1;j++){
    		dp[i]=max(dp[i],dp[j]+a[i-j]);
		}
	}
	printf("%d",dp[n]);
}
```


跑的飞快！

求点赞 qwq！

---

## 作者：Snoip (赞：6)

## 题目大意
$n$ 个学生分组，一个 $k$ 人小组的积极度为 $a_k$，求出积极度总和的最大值。要求每个学生都必须被分到。
## 思路分析
不难看出，这道题应该使用**背包 DP**。与传统的背包问题相比不同的是，本题的 $n$ 既代表物品数量又代表背包容量，第 $k$ 个物品的体积为 $k$，价值为 $a_k$。因为每种分法可以用无数次，所以是**完全背包**。关于完全背包的详解在文章后面。

根据完全背包，本题的状态转移方程为：
$$dp_j=\max(dp_j,dp_{j-i}+a_i)$$

其中，$i$ 遍历的物品数量，$j$ 遍历的是物品体积。因为本题的物品代价和其编号相同，所以就没有额外的代价 $w_i$。

## 参考代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[1010],dp[1010];
int main(){
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 1;i <= n;i++){
        for(int j = i;j <= n;j++){  // 正序遍历，完全背包问题
            dp[j] = max(dp[j], dp[j-i] + a[i]);
        }
    }
    cout << dp[n];
    return 0;
}
```
## 完全背包详解
### 一、问题形式化定义
给定 $n$ 种物品，每种物品有：
- 重量 $w_i > 0$
- 价值 $v_i > 0$
- **无限供应量**

背包容量为 $W$，求最大价值组合：
$$
\max \sum_{i=1}^n v_i x_i \quad \text{s.t.} \quad 
\begin{cases} 
\sum_{i=1}^n w_i x_i \leq W \\
x_i \in \mathbb{N} 
\end{cases}
$$

### 二、动态规划推导

#### 1. 朴素二维DP
定义状态：
- $dp[i][j]$：考虑前 $i$ 种物品，容量为 $j$ 时的最大价值

状态转移方程：
$$
dp[i][j] = \max_{k=0}^{\lfloor j/w_i \rfloor} \Big( dp[i-1][j-k \cdot w_i] + k \cdot v_i \Big)
$$

**时间复杂度**：$O(nW^2)$ （效率低下）

#### 2. 优化转移方程
观察发现：
$$
\begin{aligned}
dp[i][j] &= \max(dp[i-1][j], dp[i][j-w_i] + v_i) \\
&= \begin{cases} 
dp[i-1][j] & \text{不选物品}i \\
dp[i][j-w_i] + v_i & \text{至少选一个物品}i 
\end{cases}
\end{aligned}
$$

**关键改进**：将枚举 $k$ 的 $O(W)$ 操作降为 $O(1)$。

#### 3. 空间优化（滚动数组）
发现状态仅依赖于：
- 上一行同列 $dp[i-1][j]$
- 当前行左侧 $dp[i][j-w_i]$

优化为一维数组：
$$
dp[j] \leftarrow \max(dp[j], dp[j-w_i] + v_i)
$$

**必须顺序遍历**：确保 $dp[j-w_i]$ 是已更新的当前轮次状态。

### 三、数学归纳证明

#### 正确性证明
**归纳假设**：处理完前 $i$ 种物品后，$dp[j]$ 存储最优解。

**归纳步骤**：
1. 对于 $j < w_i$，保持 $dp[i][j] = dp[i-1][j]$
2. 对于 $j \geq w_i$：
   $$
   dp[i][j] = \max \begin{cases}
   dp[i-1][j] & \text{(不选)} \\
   dp[i][j-w_i] + v_i & \text{(至少选一个)}
   \end{cases}
   $$
   覆盖所有可能的选取次数。

### 四、与01背包的对比

#### 更新顺序差异
| 背包类型 | 转移方程                  | 遍历顺序 | 物理意义               |
|----------|---------------------------|----------|------------------------|
| 01背包   | $dp[j] = \max(dp[j], dp[j-w_i]+v_i)$ | 逆序     | 防止重复计入当前物品   |
| 完全背包 | 同上                      | 顺序     | 允许无限次选择当前物品 |
### 五、算法实现要点（C++片段）

```cpp
for(int i = 1;i <= n;i++){
    for(int j = w[i];j <= W;j++){  // 正序关键！
        dp[j] = max(dp[j],dp[j - w[i]] + v[i]);
    }
}
```
其中，$w_i$ 代表第 $i$ 个物品的体积，$v_i$ 表示第 $i$ 个物品的价值。

这里给出的代码是完全背包的模版代码，本题的解法将上述代码改一下即可。
## 鸣谢
- ZYB、GP（我的老师）
- CYX、LYL、XYZ、TSJ（给予我自信的朋友）
## 题外话
其实，这次六级前面选择题给出了 0-1 背包的模版，而完全背包和 0-1 背包代码实现上唯一区别只是内层 $j$ 的循环换个方向而已，所以这题完全就是送分题！而且 $1\le n\le 1000$，数据范围很小。

---

## 作者：SleepShark (赞：3)

六级考生前来报到。

## 思路及解法分析

仔细看题目，你就会发现这其实这是一道~~很水的~~完全背包模版题。

题目中说，如果一个学习小组中恰好包含 $k$ 名同学，则该学习小组的讨论积极度为 $a_k$。

我们其实可以这样考虑：我们把每个学习小组抽象成每个物品，每个学生抽象成每个单位重量。

显然包含 $k$ 个人的学习小组有 $k$ 个单位重量，价值为 $a_k$。

因为一共有 $n$ 个学习小组可供选择，所以物品总数为 $n$。

显然，背包容量，即学生总数也为 $n$。

对于以上问题，每个学习小组可以取无限次。

这样不就变成一个完全背包模版题了吗？

我们用 $a$ 数组存价值，$b$ 数组存重量，$n$ 同时存总数和容量就可以了。

我们可以直接编写一个求解标准完全背包的函数，然后在主函数写入参数直接套用即可。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, a[N], b[N]; //分别表示每件物品的价值和重量
int Solve(int n, int w, int wei[], int val[]) {
    //此函数的作用是对最基础的完全背包进行求解
    int dp[N] = {0}; //初始化为0
    for (int i = 1; i <= n; i ++) {
        for (int j = wei[i]; j <= w; j ++) {
            dp[j] = max(dp[j], dp[j - wei[i]] + val[i]); //状态转移方程，套模版，同01背包
        }
    }
    return dp[w]; 
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
        b[i] = i; //每件物品的重量是它的编号
    }
    int ans = Solve(n, n, b, a); //物品总数和背包总重量相同
    cout << ans;
    return 0;
}
```

---

## 作者：StormWhip (赞：3)

## 思路
考虑转化成背包问题：每个“小组”看成一件物品，其体积为小组人数，价值为积极度，套用完全背包模板即可。  

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+5,M=1e4+5;
int n,v[N],w[N],f[M];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>v[i],w[i]=i;
	for(int i=1;i<=n;i++)
		for(int j=w[i];j<=n;j++)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	cout<<f[n]<<"\n";
	return 0;
}
```

---

## 作者：xw_qwq (赞：3)

[题目传送门。](https://www.luogu.com.cn/problem/P13015)

#### 前言

GESP 6 级真的好水啊，场上一个小时就出来了。

~~比 5 级简单。~~

#### 题目思路

很明显的 dp 求最大值问题。

因为无负数等情况，无需初始化，仅需保持全局变量为 0 即可。

我们设 $dp_i$ 为有 $i$ 个同学时能获得的最大积极度，那么若想求出 $dp_i$，仅需从 0 开始枚举所有比 $i$ 小的 $j$，取出 $dp_j$，将其值加上 $a_{i-j}$，也就是把多出来的再分一组，将所有得出值取最大值即可。

转移方程为：$dp_i = \max(dp_i,dp_{j}+a_{i-j})$。

最后答案即为 $dp_n$。

双重循环，时间复杂度：$O(n^2)$。

#### code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1005], dp[1005];
void solve()
{
	int n;
	cin >> n; 
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < i; j++)
			dp[i] = max(dp[i], dp[j] + a[i - j]);
	cout << dp[n];
}
int main()
{
	solve();
	return 0;
}
```

---

## 作者：goIdie (赞：2)

## 思路

转化问题为：背包容量为 $n$, 每个物品的重量为小组人数，
重量为 $i$ 的物品价钱为 $a_i$。

显然为完全背包，套板子即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001],dp[1001];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        for(int v=i;v<=n;v++){
            dp[v]=max(dp[v],dp[v-i]+a[i]);
        }
    }
    cout<<dp[n];
}
```

---

## 作者：Ghosty_Neutrino (赞：2)

## 题意
班主任需要将 $n$ 名同学划分为若干学习小组，每个小组 $k$ 人对应的讨论积极度为 $a_k$。要求找出所有可能的划分方案中，讨论积极度之和的最大值。
## 分析
典型的动规背包问题分分钟秒掉，我们需要找到将 $n$ 名同学分组的最优方案。

那么如何定义状态和状态转移方程呢？

状态定义：设 $dp_i$ 表示将 $i$ 名同学分组后能获得的最大讨论积极度。

状态转移：对于 $i$ 名同学，我们可以考虑最后一个小组的人数为 $k$，则前 $i-k$ 名同学的最优解为 $dp_{i-k}$，加上当前小组的积极度 $a_k$，即：
$$
dp_i= \max(dp_i, dp_{i-k} + a_k)
$$
初始条件：$dp_0=0$（$0$ 名同学时积极度为 $0$）。

好了代码也是非常的简单，下面展示给你看。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1010],dp[1010],n;
main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		for(int k=1;k<=i;k++) dp[i]=max(dp[i],dp[i-k]+a[k-1]);//最后一个小组有 k 人，前 i-k 人已分组
	}
	printf("%d",dp[n]);
	return 0;
}
```

---

## 作者：TLE_qwq (赞：2)

### 题目简化
我们需要将一个整数 $n$ 划分为若干个正整数的和，每个正整数对应一个小组的人数。对于每一种划分方式，我们计算对应的积极度和，然后找出最大的那个。
### 解题思路
一眼看过去，DFS，容易超时，预计得分 $40$。

DFS 思路就是一个一个取，直到人数达到 $n$ 就去取讨论积极度最大值。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1001];
int n;
int sum = INT_MIN;
void dfs(int j, int num)
{
	if (j == n)
	{
		sum = max(sum, num); // 取最大值
		return;
	}
	for (int i = 1; i <= n; i++)
	{
		if ((n - j) >= i)
			dfs(j + i, num + a[i]);
	}
}
int main(void)
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	dfs(0, 0);
	cout << sum;
	return 0;
}
```
时间复杂度：$\mathcal{O}(n^n)$
### 优化
是时候上 DP 了！

仔细一看，这不就是完全背包嘛，不难看出，状态转移方程为：
$$
dp_i = \max\big(dp_i,dp_{i - j} + a_j\big)
$$

其中，$a_j$ 为考虑总人数为 $j$，可以获得的讨论积极度值。
预计得分：$100$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1001];
int n;
int dp[1001] = {0};
int main(void)
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	dp[0] = 0; // 初始化
	dp[1] = a[1];
	for (int i = 1; i <= n; i++)
	{ // 遍历人数
		for (int j = 1; j <= i; j++)
		{																					   // 遍历 a 数组，j  <= 人数，否则会越界
			dp[i] = max(dp[i], dp[i - /*因为第 i 项是从人数少 j 的那项转移而来的*/ j] + a[j]); // i 表示总人数 ,所以最后输出总人数为 n
		}
	}
	cout << dp[n];
	return 0;
}

```
时间复杂度：$\mathcal{O}(n^2)$
### 其他方案
此处还提供一个记忆化搜索的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];
int n;
int d[1001]; // 记忆数组，存储从位置 j 出发能得到的最大和
// 返回从位置 j 出发能得到的最大和
int dfs(int j) {
    // 如果已经到达终点，返回 0
    if(j == n) return 0;
    // 如果已经计算过，直接返回结果
    if(d[j] != -1) return d[j];
    int max_sum = 0;
    for(int i = 1; i <= n - j; i++) { // 小组大小 i 不能超过剩余学生数 n - j
        int c = dfs(j + i) + a[i];
        if(c > max_sum) {
            max_sum = c;
        }
    }
    // 存储讨论积极度
    d[j] = max_sum;
    return max_sum;
}

int main(void)
{
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    // 初始化记忆数组为 -1，表示未计算
    memset(d, -1, sizeof(d));
    int res = dfs(0);
    cout << res; 
    return 0;
}    
```
时间复杂度也是：$\mathcal{O}(n^2)$

---

## 作者：Na1L0n9 (赞：1)

# Solution
## 思路
设 $dp[i]$ 表示人数为 $i$ 时的答案。

对于 $i$ 个人的情况，我们把这些人分成两组，第一组有 $i-j$ 人，他们能得到的最大积极度就是 $dp[i-j]$，而剩下的 $j$ 人的积极度为 $a[j]$，我们的目的就是找到能使 $i$ 最大的 $j$。

因此，转移方程是：$dp[i]=\max(dp[i],dp[i-j]+a[j])$。
## Code

```cpp
#include <bits/stdc++.h>
#define Write ios::sync_with_stdio(0);
#define by cin.tie(0);
#define AquaDaMean1e cout.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 1e3 + 10;
const int MOD = 998244353;
int n, a[N], dp[N];
int main() {
	Write by AquaDaMean1e
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i]; 
	}
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            dp[i] = max(dp[i], dp[i - j] + a[j]);
        }
    }
    cout << dp[n];
	return 0;
}

 
```

---

## 作者：zhoujunchen (赞：1)

将班级人数看成背包容量，$a_i$ 看成价值，$i$ 看成重量，这道题就是一道完全背包板子题。

用 $dp_i$ 表示第 $i$ 名同学分组后最大积极度之和。

$$dp_i=\max(dp_i,dp_{i-j}+a_j)$$

$dp_n$ 即为答案。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],dp[1005];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			dp[i]=max(dp[i],dp[i-j]+a[j]);
	cout<<dp[n]<<"\n";
	return 0;
}
```

---

## 作者：_lxc__ (赞：1)

# 闲话

赛时十分钟做出，但这次的第二题死做一个半小时喜提爆零，还是我太菜了。

# 思路

这题是简单的动态规划题：

* 定义状态：设 $dp_i$ 为当有 $i$ 个人的情况下最大活跃度是多少。

* 答案：自然为 $dp_n$ 啦。


* 状态转移：$dp_i=\max(dp_{i-1}+a_1,dp_{i-2}+a_2,\cdots ,dp_0+a_i)$。

    * 可以将当前人数拆成以前算过的部分（即 $dp$ 数组中的值）和剩余部分（即 $a$ 数组中的值）。
 
    * 这样这一部分的时间复杂度是 $O(n^2)$ 的，需要优化。通过观察，我们可以发现 $dp_x+a_y$ 中 $x+y=i$，所以可以将式子优化：$dp_i=\max(dp_{i-1}+a_{i-(i-1)},dp_{i-2}+a_{i-(i-2)},\cdots ,dp_0+a_{i-0})$。
 
* 边界条件：$dp_1=a_1$，当有 $1$ 个人时最大活跃度当然是 $a_1$ 啦。


# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
int n,a[1010],dp[1010]; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	dp[1]=a[1];
	for(int i=2;i<=n;i++){
		for(int j=i-1;j>=0;j--){
			dp[i]=max(dp[i],dp[j]+a[i-j]);
		}
	}
	cout<<dp[n];
	return 0;
}

```

这样下来总时间复杂度是 $O(n^2)$，可以通过本题，完结撒花！

---


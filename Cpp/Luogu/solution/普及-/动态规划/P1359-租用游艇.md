# 租用游艇

## 题目描述

长江游艇俱乐部在长江上设置了 $n$ 个游艇出租站 $1,2,\cdots,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 $i$ 到游艇出租站 $j$ 之间的租金为 $r(i,j)$（$1\le i\lt j\le n$）。试设计一个算法，计算出从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 说明/提示

$n\le 200$，保证计算过程中任何时刻数值都不超过 $10^6$。

## 样例 #1

### 输入

```
3
5 15
7

```

### 输出

```
12

```

# 题解

## 作者：BIGBUG (赞：274)

这道题是一道dp题，。


------------
首先，我们要先存图。

看看样例吧：
```
3
5 15
7
```
显然，5和15是中转站1到2和3的价钱，而7是2到3的价钱。我们可以用a数组来存，$a[i][j]$表示$i$到$j$的价钱。（左边表示出发站，右边表示到达站）

|  | 中转站1 | 中转站2 | 中转站3 |
| ------ | ------ | ------ | ------ |
| 中转站1 | 0 | 5 | 15 |
| 中转站2 | 0 | 0 | 7 |
| 中转站3 | 0 | 0 | 0 |

我们可以用$dp$数组来记录这个中转站到n号中转站的最小价钱，$dp[i]$表示中转站$i$到中转站$n$的最小价钱。

|  | 中转站1 | 中转站2 | 中转站3 |
| ------ | ------ | ------ | ------ |
| 最小价钱 | 12 | 7 | 0 |

我们要用$i$把$n$上流的中转站从大到小跑一遍。我们先记录中转站2到中转站3的最小价钱，我们要用$j$跑一遍中转站2下流的所有中转站，记录$a[i][j]+dp[j]$的最小价钱,记录到$dp[i]$里面。

附上代码：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[201][201],i,j,n,dp[201];
int main(){
	cin>>n;
	for(i=1;i<n;i++){
		for(j=i+1;j<=n;j++)
			cin>>a[i][j];
		dp[i]=1e9;//初始化数组dp，使它
	}
	for(i=n-1;i>=1;i--)//跑n上流的中转站
		for(j=i+1;j<=n;j++)//跑i下流的所有中转站
			dp[i]=min(dp[i],a[i][j]+dp[j]);//记录
	cout<<dp[1];
	return 0;
}
```

PS：蒟蒻的题解，大佬勿喷！$qwq$

---

## 作者：dblark (赞：126)

这道题目，一群大佬们都想复杂了……

Floyd+SPFA+Dijkstra+Bellman-Ford+复杂的DP~~说不下去了~~

我的解法很简单，清晰的DP，什么有向图乱七八糟的

状态转移方程：`f[j]=min(f[j],f[i]+a[i,j])`也就是到j处最小的价格。

只需从1到n一遍一遍的更新即可。

代码很好写，但是要注意：f数组要初始化一个很大的数！

---

## 作者：little_gift (赞：62)

##动归，说实话我也不太明白我是怎么写的

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[201],n,i,j,x; //f[x]表示从1到x的距离
int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        for (j=i+1;j<=n;j++)
        {
            scanf("%d",&x);
            if (f[j]==0||f[j]>f[i]+x) //如果j还没有到过或者到j的距离比原来短
                f[j]=f[i]+x; //替换
        }
    printf("%d\n",f[n]); //输出到n的距离
}
```

---

## 作者：金庆涵 (赞：51)

我是一名~~蒟蒻~~，但是我不服当一枚蒟蒻。我开始我的水题之路了！

我先要水点动态规划的题，结果找到了这道“租用游艇”。

看到图论，我首先看了看数据

**n<=200!** 太棒了!找不到这么良心的出题人了！！

Floyd才是最简单的！！
并且没人写Floyd的题解。

我于是想要将AC代码奉献给连Floyd都不会写的人

[如果不知道Floyd，请点击它](https://baike.baidu.com/item/Floyd算法/291990?fr=aladdin)

但首先，我们要看66分代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[201][201];
int egde(int u,int v,int x){//创建边
	a[u][v]=x;
   	a[v][u]=x;
}
int main()
{
	int n;scanf("%d",&n);
	memset(a,0x3f,sizeof(a));//初始化
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j++){
		if(i==j)a[i][j]=0;
		else{
			int x;cin>>x;
			egde(i,j,x);
		}
	}
	for(int k=1;k<=n;k++)//floyd
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++){
		a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	}
	printf("%d",a[1][n]);
	return 0;
}
```
为何成66分呢？因为这个程序最大的漏洞是把它当成无向图处理了，应当当成有向图去做。

所以要把 a[v][u]=x;删掉。

删掉它就是令人满意的AC代码了！
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[201][201];
int egde(int u,int v,int x){
	a[u][v]=x;
}
int main()
{
	int n;scanf("%d",&n);
	memset(a,0x3f,sizeof(a));
	for(int i=1;i<=n;i++)//边的创建
	for(int j=i;j<=n;j++){
		if(i==j)a[i][j]=0;
		else{
			int x;cin>>x;
			egde(i,j,x);
		}
	}
	for(int k=1;k<=n;k++)//floyd
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++){
		a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	}
	printf("%d",a[1][n]);
	return 0;
}
```
最后在提供一份模板关于Floyd
```cpp
	for(int k=1;k<=n;k++)//连接点
	for(int i=1;i<=n;i++)//起点
	for(int j=1;j<=n;j++){//终点
		a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	}
```
再见了朋友们！祝你们在洛谷题库的海洋里翱翔吧！

---

## 作者：unbeatable_noob (赞：28)

裸的dijkstra，一次过

用了邻接矩阵存储，也没用堆优化，毕竟数据范围很小

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 9999999;
int main()
{
    int n,g[205][205];
    cin >> n;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++)
        {
            if(i == j)
                g[i][j] = 0;
            else
                g[i][j] = INF;
        }
    for (int i = 1;i <= n-1;i++)
        for(int j = i+1;j <= n;j++)
            {
                cin >> g[i][j];
            }
    //dijstkra
    int dis[205],book[205];
    memset(book,0,sizeof(book));
    for(int i = 1;i <= n;i++)
        dis[i] = g[1][i];
    dis[1] = 0;
    book[1] = 1;
    for(int i = 2;i <= n;i++)
    {
        int mind = INF,u;
        for(int j = 1;j <= n;j++)
        {
            if(!book[j] && dis[j] < mind)
            {
                mind = dis[j];
                u = j;
            } 
        }
        book[u] = 1;
        for(int j = 1;j <= n;j++)
        {
            dis[j] = min(dis[j],dis[u]+g[u][j]);
        }
    }
    cout << dis[n];
    return 0;
}
```
这道题是有向图，其实是不是有向图都无所谓，有向图把反方向初始化为-1或者初始化成取不到的最大值都可以

毕竟裸的dijkstra应该没什么需要讲的


---

## 作者：Atmizz (赞：21)

### 看到各位dalao的做法没有和我一样的，那我就发一篇吧。
**dfs+剪枝**（一道动规题目硬生生做成了深搜题**逃**）
************
题意很清楚，就是从上游开到下游，在下游换车，不可以返回上游，也就是说这个半矩阵就是一个有向图。我一开始也想最短路，但是只有**33**分，**DP**感觉不好想，于是转换思路到**DFS**，但是**裸**的**DFS**绝对会超时，只有**66**分，这时就要**剪枝**。剪枝就更好想了，当**当前**的花费大于**ans**，剩下的就不要了。

### 超时のcode：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#define LL long long
using namespace std;
int n,map[201][201],ans=9999999;//map来存图，ans是最终的答案 
void dfs(int,int);
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i < n ; ++ i)	//进行存图 
		for(int j = i + 1 ; j <= n ; ++ j )
			scanf("%d",&map[i][j]);
	dfs(1,0);	//起点是1 
	printf("%d",ans);
	return 0;
}
void dfs(int t,int step)
{
	if(t == n) {
		if(ans > step)	//看是否更新答案 
			ans = step;
		return;	//回溯 
	}
	for(int i = t + 1 ; i <= n ; ++ i)	//挨个枚举下游各个点 
		dfs(i,step + map[t][i]);
}
```
### ACのcode:
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#define LL long long
using namespace std;
int n,map[201][201],ans=9999999;//map来存图，ans是最终的答案 
void dfs(int,int);
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i < n ; ++ i)	//进行存图 
		for(int j = i + 1 ; j <= n ; ++ j )
			scanf("%d",&map[i][j]);
	dfs(1,0);	//起点是1 
	printf("%d",ans);
	return 0;
}
void dfs(int t,int step)
{
	if(step > ans)//剪枝，大于答案，那么搜下面的就没意思了 
		return;
	if(t == n) {
		if(ans > step)	//看是否更新答案 
			ans = step;
		return;	//回溯 
	}
	for(int i = t + 1 ; i <= n ; ++ i)	//挨个枚举下游各个点 
		dfs(i,step + map[t][i]);
}
```

---

## 作者：关怀他人 (赞：21)

 看见楼下的dalao们用了spfa,	floyd........
 
 其实呢简单的~~dp~~递推就能搞定
 
------------

下面上~~转移~~递推方程:

for i : 1 to n
	
        f[i] = r[1][i];
        
for i : 2 to n

	    for j : 2 to i
    
    	       f[i] = min(f[i],f[j-1]+r[j-1][i]);
               
f[i]表示从出租站1到出租站n所需的最少租金

枚举上一个出租站就能递推出来了

------------

最后上代码

```cpp
/*
Problem : luogu P1359
Algorithm : DP
Status : AC
*/
#include<bits/stdc++.h>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cstdio>
#include<iostream>
#define inf 2100000000
using namespace std;

int n;
int r[205][205],f[205];

int main(){
	cin >> n;
    for(int i = 1;i <= n-1;i++){
        for(int j = i+1;j <= n;j++)
            cin >> r[i][j];
    }
    for(int i = 1;i <= n;i++)
        f[i] = r[1][i];
    for(int i = 2;i <= n;i++){
    	for(int j = 2;j <= i;j++)
    	    f[i] = min(f[i],f[j-1]+r[j-1][i]);
	}
	cout << f[n] <<	 endl;
	return 0;
}

```

---

## 作者：big_news (赞：13)

# 思路：动归+记忆化搜索

### 一. 分析

观察一下题目，发现这明显是求一个DAG（有向无环图）上的**固定点之间的最短路**，那么一定可以用DP解

具体解法有以下两种：

1. 从终点向起点递推

2. 从起点向终点记忆化搜索

其中递推的方法已经有了，在这里不再赘述，只讲第二种解法即记忆化搜索

### 二. 实现

根据DP的本质，我们首先要定义状态：

**定义$ f_i $为以节点 $ i $ 为起点到节点 $ n $ 的最短路**

那么很明显，对于当前的状态 $ f_i $，可以由与节点 $ i $ 有边的所有节点 $ i+1,i+2,... $ 所对应的  $ f $ 值转移过来

那么状态转移方程就很明显了：

$$ f_i=min \{ f_i , dp(k)+dis_{i,k} \} $$

其中,$ dp(k) $即递归求$ f_k $。并且$ i,k $要满足：

$$ r(i,k)>0 $$

即节点 $ i,k $之间有边

对于本题的样例，搜索形如下图：

![p](https://cdn.luogu.com.cn/upload/pic/42669.png)

其中第一张图是递归入栈的示意图，第二张为递归出栈的示意图。（其中边权用蓝字标出，绿线为第一次入栈/出栈，红线为第二次入栈/出栈，出栈时返回值用r表示）

**注意：**其中$ f_1 $值被更新了两次，为inf->15（绿色）和15->12（红色）。

~~手残画的不好请见谅~~

updata:重新绘制了该图（~~虽然更乱了~~）

### 三. 代码

首先是定义部分
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;

const int CON=220;
const int INF=0x3f3f3f3f;//极大值
int n,f[CON];//f[i]以i为起点的最短路 
int _map[CON][CON];//用来存图的邻接矩阵
bool vis[CON];//标志位，用来判断节点是否被访问过(即节点有无f值)
```
然后是读入和初始化
```
int main()
{
	memset(vis,false,sizeof(vis));//标记为初始为都未访问过
	memset(_map,0,sizeof(_map));//邻接矩阵清零
	
	scanf("%d",&n);
	
	for(int i=1;i<=n;i++)//读入邻接矩阵
	  for(int j=i+1;j<=n;j++)
	  {
	  	int d;
	  	scanf("%d",&d);
	  	_map[i][j]=d;
	  }
      
	...
    
}
```
#### 下面是本题解的核心部分，即记忆化搜索
```
int dp(int cur)//记忆化搜索 
{
	int &rec=f[cur];//为f[cur]声明一个引用,以下代码中所有对rec的操作都可以看做对f[cur]的操作
	
	if(cur==n) return 0;//已经走到终点，终点到终点最短路一定是0
	
	if(vis[cur]) return rec;//已经计算过从cur开始的最短路，直接返回，即"记忆化"
	vis[cur]=true;//标志为访问过
	
	rec=INF;//把从cur开始的最短路变为极大值(即表示还没有求出)
	
	for(int i=1;i<=n;i++)
	  if(_map[cur][i])
	  	rec=min(rec,dp(i)+_map[cur][i]);//找到所有从cur可以到达的节点，并转移状态
	    
	return rec;//返回得到的解
}
```
然后就简单了，答案在$ f_1 $处
```
printf("%d",f[1]);
return 0;
```




$$ ---- \mathcal{End}---- $$



---

## 作者：Lonely_Cat (赞：7)

这题其实不需要用到图，我用的是更直观的普通DP方法。

p[i]表示到i站时的最少租金，m[j][i]表示j到i站的租金。

那么很简单的就能发现：


```cpp
i = 2 to n
    j = 1 to i
        p [ i ] = min( p [ i ] , p [ j ] + m [ j ][ i ] )
#include<bits/stdc++.h>
using namespace std;
int m[201][201],p[201],n;
int main()
{
    memset(p,127,sizeof(p));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            scanf("%d",&m[i][j]);
    p[1]=0;
    for(int i=2;i<=n;i++)
        for(int j=1;j<i;j++)
            p[i]=min(p[i],p[j]+m[j][i]);
    printf("%d",p[n]);
    return 0;
}
```

---

## 作者：蒟蒻abcd (赞：7)

说实在，这题不难，我是作为最短路做的。但是这道题目有个坑点：它是有向图，而不是无向图，所以我们存储的时候不能把相反的那一面也存下来（因为河水不能倒流呀）。因为这个问题，我WA了一次，看了题解才发现问题。  
下面贴代码：
```cpp
#include<bits/stdc++.h>
#define oo 10000003
using namespace std;
int a[201][201]={0};
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)a[i][j]=oo;
	int du;
	for(int i=1;i<n;i++)
		for(int j=i+1;j<=n;j++)
		{
			scanf("%d",&du);
			a[i][j]=du;
		}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	cout<<a[1][n]<<endl;
	return 0;
}
```


---

## 作者：LJLYROCK (赞：5)

## 动归
#### 推导：
------------
f[i] 表示到第i个租借地需要花费的最少的钱


a[i][j] 表示从第i个租借地到第j个租借地所要花的钱

很明显 f[1] = 0

很明显 f[2] = a[1][2];

到任意一个租借地B所需要花的钱就等于 【（从第一个租借地到其中某个租借地A所需最少的钱）加上（某租借地A到租借地B所需最少的钱）的和】和 a[1][B] 之间的最小值 

即 f[B] = min(f[A] + a[A][B], A[1][B]); (1 <= A < B)

就是一个双重for循环 

```c
for (int i = 3; i <= n; i++) {        //从第三个租借地开始
		for (int j = i - 1; j >= 1; j--) f[i] = min(f[i], f[j] + a[j][i]);         //寻找A使（1到A）+（A到B）最小
	}   
```

------------

### 完整代码
```c
#include<iostream>
using namespace std;

int n, a[201][201], f[201];

int main () {
	cin >> n;
	for (int i = 1; i < n; i++) {
		for (int j = i + 1; j <= n; j++) {
			cin >> a[i][j];
			if (i == 1) f[j] = a[i][j];
		} 
	}
	f[1] = 0;
	f[2] = a[1][2];
	
	for (int i = 3; i <= n; i++) {
		for (int j = i - 1; j >= 1; j--) f[i] = min(f[i], f[j] + a[j][i]);
	}
	cout << f[n];
	return 0;
} 
```




---

## 作者：a___ (赞：5)

纯dp
（各位怎么都是顺着的，我来一个倒着的）

公式：for i=n-1  to   0

                for  j=i+1 to  n

                       a[i]=min(a[j]+r[i][j],a[i]);

由n推出n-1最小值，然后n-2，…，2,1

dp代码：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int a[220],r[220][220];
int main()
{
    memset(a,0x7f,sizeof(a));//附为较大数，确保之后判断min时第一次一定能选上
    int i,j,n;
    cin>>n;
    for (i=1;i<n;i++)
    for (j=i+1;j<=n;j++)
    cin>>r[i][j];                                                               //题目描述不清，应为i:1~n;           j:i+1~n          输入
    a[n]=0;//最后一地到自己费用为0（不动），所以附0
    for (i=n-1;i>0;i--)
    {
        for (j=i+1;j<=n;j++)
        if (a[j]+r[i][j]<a[i])a[i]=a[j]+r[i][j];                         //dp
    }
    cout<<a[1]<<endl;//输出1到n（最小）费用
    return 0;
}
```

---

## 作者：k2saki (赞：4)

这道题是一道关于$ dp $的题目，刷题刷多的人可以一眼看出来

你也可以把它当成一道最短路的题目，用$ Dijkstra,SPFA $算法来解决（floyd属于dp）

下面是思路：

设$ dp[i] $为$ 1$到$i$的最优方案，$mp[i][j]$为i到j的距离，显然$0<j<i$时，$ dp[i]=min(dp[i],dp[j]+mp[j][i]) $

$dp[n]$即为我们所求的答案

$Code$:

```
#include<bits/stdc++.h>
using namespace std;
int mp[201][201]={0};
int dp[201];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n-1;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			int c;
			cin>>c;
			mp[i][j]=c;
		}
	}
	
	for(int i=1;i<=n;++i)
	{
		dp[i]=1000001;//初始化为一个大数
	}
	dp[1]=0;
	for(int i=2;i<=n;++i)
	{
		for(int j=1;j<=i;++j)
		{
			dp[i]=min(dp[i],dp[j]+mp[j][i]);//状态转移
		}
	}
	cout<<dp[n];
	return 0;
}
```


$tips:$能否解决一个dp问题的关键是如何去定义dp数组与状态转移，这两步搞懂后，就很轻松啦！

---

## 作者：_Misaka_Mikoto (赞：3)

我知道繁体字你们看着不舒服,等下我用翻译软件(word/pwoerpoint 2010)转换下

int a[233][233]={0};// 存地图

int dp[233]={0};// 缓存

dp方程dp[j]=dp[i]+a[i][j];

```cpp
#include <iostream>
using namespace std;
int n;
int a[233][233]={0};
int dp[233]={0};
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=2;i<n;i++){
        dp[i]=min(dp[i],a[1][i]);
        for(int j=i+1;j<=n;j++){
        	dp[j]=min(dp[j],dp[i]+a[i][j]);
        }
    }
    cout<<dp[n];
    return 0;
}

```
别抄,0分代码 输出0 因为初始化0,每次min()后都是0

```cpp
#include <iostream>
using namespace std;
int n;
int a[233][233]={0};
int dp[233]={0};
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=2;i<n;i++){
    	dp[i]=min(dp[i],a[1][i]);
        for(int j=i+1;j<=n;j++){
        	if(dp[j]==0)dp[j]=dp[i]+a[i][j];
            else dp[j]=min(dp[j],dp[i]+a[i][j]);
        }
    }
    cout<<dp[n];
    return 0;
}

```
别抄,30分代码 输出偏大 因为初始化a[1][i],每次min()后的最小值被clear了

```cpp
#include <iostream>
using namespace std;
int n;
int a[233][233]={0};
int dp[233]={0};
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=2;i<n;i++){
    	if(dp[i]==0)dp[i]=a[1][i];
    	else dp[i]=min(dp[i],a[1][i]);
        for(int j=i+1;j<=n;j++){
        	if(dp[j]==0)dp[j]=dp[i]+a[i][j];
            else dp[j]=min(dp[j],dp[i]+a[i][j]);
        }
    }
    cout<<dp[n];
    return 0;
}

```
AC 代码 记得判0


---

## 作者：Hexarhy (赞：3)

### 作为一道比较裸的图论题，解决方法当然不止一种，请诸君自行选择$\color{blue}\text{学习借鉴}$：

宣传[blog](https://80049.blog.luogu.org)……

> 注意：本题解程序码量较他人程序偏大，请做好心理准备。这不一定是最优解，只是为了拓宽大家的做题思路。

------------

$1)$最短路算法$+$松弛。由于数据较弱，可以使用$Floyd$、$spfa$、$dijkstra$、$Bellman-Ford$等最短路算法。**你没看错，$Floyd$也能过$QVQ$（参考他人题解）**

对于松弛操作，比较裸，类似$dp$，大家自己想吧（炒鸡简单滴）。

建图的话，邻接矩阵、普通邻接链表、链式前向星、$vector$存边等都可以，各式各样任君选择。

作者使用了~~通俗易懂~~的$spfa$+松弛+$vector$存边，参考下面程序。

~~时间复杂度玄学……~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
#include<cstring>
using namespace std;

const int INF=0x7f7f7f7f;
const int MAXN=500;
int n;
struct node
{
	int to,v;
};
vector <node> edge[MAXN];
queue <int> q;
int dis[MAXN];//此表示从1到i的最小花费
bool visit[MAXN];

void input(void)
{
	cin>>n;
	for(int i=1;i<n;i++)
	 for(int j=i+1;j<=n;j++)//注意输入顺序！QAQ
	 {
	 	int x;
	 	cin>>x;
	 	edge[i].push_back((node){j,x});//vecotr建图方便，不说
	 }
}

void spfa(void)
{
	memset(dis,INF,sizeof(dis));//松弛前的准备
	q.push(1);//起点入队
	visit[1]=true;
	dis[1]=0;
	while(!q.empty())//按照流程来spfa
	{
		const int tmp=q.front();
		for(vector<node>::iterator it=edge[tmp].begin();it!=edge[tmp].end();it++)
		 if(dis[it->to]>dis[tmp]+it->v)
		 {
		 	dis[it->to]=dis[tmp]+it->v;//松弛
		 	if(!visit[it->to])//入队标记
		 	{
		 		visit[it->to]=true;
		 		q.push(it->to);
			}
		 }
		visit[tmp]=false;//spfa是要恢复标记哟
		q.pop();
	}
}

int main()
{
	input();
	spfa();
	cout<<dis[n];//愉快的输出终点
	return 0;
}
```


------------

$2)$拓扑排序$+dp$。（是不是有点少见？）

~~不会拓扑的同学出门左转度娘等你。~~

不过这里拓扑排序有点多余？好像题目已经保证前面节点一定是后面节点的前驱？这里略微提一下拓扑思路：

由于只能往下游走，那么我们可以拓扑求前驱节点，并更新$dis$数组的答案，（有点像松弛）。

可以保证的是拓扑排序也能遍历到每一条边（已经足够了），即使不像$spfa$反复遍历。

时间复杂度$O(N+E)$（$N$为节点数、$E$为边的数量），已经算不错的。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
#include<cstring>
using namespace std;

const int INF=0x7f7f7f7f;
const int MAXN=500;
int n;
struct node
{
	int to,v;
};
vector <node> edge[MAXN];
int dis[MAXN],indeg[MAXN];//统计入度，拓扑的核心
bool visit[MAXN];

void input(void)
{
	cin>>n;
	for(int i=1;i<n;i++)
	 for(int j=i+1;j<=n;j++)
	 {
	 	int x;
	 	cin>>x;
	 	indeg[j]++;//统计入度
	 	edge[i].push_back((node){j,x});
	 }
}

void topo_sort(void)
{
	memset(dis,INF,sizeof(dis));
	queue <int> q;
	for(int i=1;i<=n;i++)
	 if(!indeg[i]) //找到入度为0的起点（其实就是点1  QAQ）
	 {
		q.push(i);
		dis[i]=0;
	 }
	while(!q.empty())//按照流程来拓扑
	{
		const int tmp=q.front();
		q.pop();
		for(vector<node>::iterator it=edge[tmp].begin();it!=edge[tmp].end();it++)
		{
			indeg[it->to]--;
			if(!indeg[it->to])
			 q.push(it->to);
			dis[it->to]=min(dis[it->to],dis[tmp]+it->v);//类似最短路松弛的dp
		}
	}
}

int main()
{
	input();
	topo_sort();
	cout<<dis[n];
	return 0;
}
```


------------

最后，对比一下上面两个程序的提交结果，没开$O2$：

![](https://cdn.luogu.com.cn/upload/pic/50932.png)

时间一样？$spfa$真玄学。

当然还有很多最短路的算法都能$AC$此题，时间复杂度各不相同，大家自行参考他人题解吧。

#### 完结撒花$QwQ$


---

## 作者：mengzhi (赞：3)

# Dijkstra + STL堆优化 +链式前向星存图

## 看了半天题解只有邻接矩阵 这可不行
### 上AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f3f3f3f3fll
#define maxn 200100
#define maxm 100100
struct edge{
	int to,next,dis;
}Edge[maxn];
//存边，to是子节点，next是上一条边的序号，dis是权值
struct node{
	long long dis;int  pos;
	bool operator <(const node &x) const{
	return x.dis<dis;
	}//不开ll有些过不去
};
int tot,first[maxm],n,m,s=1;long long dis[maxm];
bool vis[maxm];
priority_queue<node>q;
inline void add(int u,int v,long t){
	Edge[++tot].next=first[u];
	Edge[tot].to=v;
	Edge[tot].dis=t;
	first[u]=tot;//链式前向星存图，是什么详见上一篇：链式前向星
}
void dij(){//主算法
memset(dis, 0x3f, sizeof(dis));//一定要初始化！
dis[s]=0; q.push((node){0,s});
while(!q.empty())
  {  
	node tmp=q.top();q.pop();
	if(vis[tmp.pos])continue;//非常重要！
	vis[tmp.pos]=1;
	for (int i=first[tmp.pos];i;i=Edge[i].next)
	{     int  y=Edge[i].to;
		if(dis[y]>dis[tmp.pos]+Edge[i].dis)
		    {
			dis[y]=dis[tmp.pos]+Edge[i].dis;
		    if(!vis[y])
            q.push((node){dis[y],y});
		    }
	}
  } 
	   
       
       cout<<dis[n]<<" ";
        
}
int main()
{   ios::sync_with_stdio(false); 
	cin>>n;
    for(register int i=1;i<=n;i++)
	for(register int j=i+1;j<=n;j++)
	{cin>>m;//模拟表格，找出对应边和节点
	
	 add(i,j,m);
	}	
	dij();	}
```

**在Dijkstra算法中，d[i]越小应该越先出队，因此需要使用自定义比较器（或者是优先队列）这里引进几个法宝**


**1.我们可以用priority来声明一个小数先出队的优先队列。**

**2.Stl中的pair便是专门把两个类型捆绑到一起的。为了方便起见用typedef pair<int，int>pii来自定义一个pii类型，则priority_queue<pii,vector<pii>,greater<pii>>q就定义了一个二元组构成的优先队列，pair定义了它自己的排序规则——先比较第一维，相等时比较第二维，因此需要按（d[i],i)而不是(i,d[i])的方式组合，这样的方法理论上和实际上都没有问题，此语句和上面结构体node同理。**

 **再补充一点，即使是稠密图，使用优先队列的Dij算法也常常比邻接矩阵的Dij算法运算速度快，理由很简单，执行push操作的前提是d[e.to]>d[u]+e.dis,也就是上一次的值加一条边（有点像DP？），如果这个式子常常不成立，则push操作会很少**
  

---

## 作者：tobie (赞：2)

### 裸的动态规划
设map[i][j]表示从游艇出租站i到游艇出租站j之间的最少租金
那么从游艇出租站i到游艇出租站j有两种情况：

1.直接过去（输入时的map[i][j]）

2.从游艇出租站i到游艇出租站x（中转站）再从游艇出租站x到游艇出租j

那么第二种情况就变成两个子问题：
map[i][x]+map[x][j]

最终答案就是map[1][n]

这样子就可以快乐的打出代码来了 : )
```
#include<iostream>
#include<cstdio>
using namespace std;
int map[205][205],n,i,j,k;
int main()
{
	cin>>n;
	for(i=1;i<n;i++)
	for(j=i+1;j<=n;j++)
	{
		cin>>map[i][j];
	}
	for(i=1;i<=n;i++)
	for(j=i+1;j<=n;j++)
	{
		for(k=i+1;k<j;k++)//枚举每一个中转站x
		map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
	}
	cout<<map[1][n];
	return 0;
}
```


---

## 作者：mlj2004 (赞：2)

这道题发现很多用DP的大佬

我来讲一个 **Floyd** 的

首先看到数据范围(n<=200)
发现 
**O(n^3) 复杂度**
可以过

而且本题的读入类似 **邻接矩阵**
因此自然地想到简单的Floyd

直接上代码：
```
#include <iostream>
#include <cstring>
#include <string>
using namespace std;
int n,m;
int a[210][210];
int main()
{
	memset(a,127/3,sizeof(a));
	cin>>n;
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			cin>>a[i][j];
		}
	}
    //读入数据
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
			}
		}
	}
    //Floyd跑一遍
	cout<<a[1][n]<<endl;
	return 0;
}
```


---

## 作者：英俊的李子 (赞：2)

**模板流**

spfa大家都懂，下面的dalao也讲解了spfa，我就发个可以直接嵌入的模板

请自己制作，不要直接复制我的



```cpp
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
struct Chark{
    vector<int> link[10000005];
    vector<int> val[10000005];
}s;
int spfa(Chark a,int len,int st,int ed)//此处可作直接复制粘贴使用的模块
{
    queue<int> que;
    bool vis[10005];
    int d[10005];
    for(int i=1;i<=len;i++) d[i]=9999999;
    for(int i=1;i<=len;i++) vis[i]=false;
    d[st]=0;
    que.push(st);
    vis[st]=true;
    while(!que.empty())
    {
        int u=que.front();
        que.pop();
        vis[u]=false;
        for(int i=0;i<a.link[u].size();i++)
        {
            int w=a.link[u][i];
            if(d[w]>d[u]+a.val[u][i])
            {
                d[w]=d[u]+a.val[u][i];
                if(!vis[w])
                {
                    vis[w]=true;
                    que.push(w);
                }
            }
        }
    }
    return d[ed];
}
int main()
{
    int n;
    scanf("%cd",&n);
    for(int i=1;i<=n-1;i++)
     for(int j=i+1;j<=n;j++)
     {
         int c;
         scanf("%d",&c);
         s.link[i].push_back(j);
         s.val[i].push_back(c);
     }
    printf("%cd",spfa(s,n,1,n));
    return 0;
}
```

---

## 作者：li_lingyi (赞：1)

## 思路：用Dijkstra的思想dp


------------

首先要搞明白样例输入：5是从1-2的费用  12是1-3的费用 7是2-3的费用```
下面是输入代码：
for(int i=1;i<=n-1;i++){

		for(int j=i+1;j<=n;j++){
			cin>>f[i][j];
		}
}
```


------------
动态转移方程：
f1[i]=min(f1[i],f1[j]+f[j][i]);
//i到1的最小费用=min(i直接到1的费用，j先到1的费用+i再到j的费用)


------------
下面是AC代码：
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
int f[10001][10001],f1[10001];
int n,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j){
				f[i][j]=0;
			}else{
				f[i][j]=99999999;
			}
		}
	}
	for(int i=1;i<=n-1;i++){
		for(int j=i+1;j<=n;j++){
			cin>>f[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		f1[i]=f[1][i];
	}
	for(int i=1;i<=n;i++){
		for(int j=2;j<n;j++){
			f1[i]=min(f1[i],f1[j]+f[j][i]);
		}
	}
	cout<<f1[n]<<endl;
	return 0;
} 
```


---

## 作者：water_mi (赞：1)

这么多Floyd、Dijkstra和SPFA，为什么没有人写Bellman-Ford?那就我来写吧

Bellman-Ford深究：http://www.cnblogs.com/tanky\_woo/archive/2011/01/17/1937728.html

分析一下：

这个题需要求解的是从1-n的最短路径，点明了是单元最短路径，由于是租金，在作者没有特殊注明的情况下，是不存在负数（即负边权），所以这道题可以用Dijsktra$O(N^3)$的Floyd，和$O(N^2)$的Djkstra都不会超时（因为n只有200）嘛。SPFA更不用说了。但是，事实上O（NE）的Bellman-Ford也不会超时，因为E最多也就只有20100条边（显然Dijkstra比这个要[wěn]好[dìng]），其实这就是一个变了外表的模板题，还有需要注意的，这是一个有向图！

下面贴上BF的代码（其他的各种算法大佬们[楼下的]）已经写了，这里节约版面，就不写了。

```cpp
#include<cstdio>
const int maxn = 201,inf = 1000000000;
int min(int a,int b){return a < b?a:b;}
struct node{int u,v,w;}dis[40001];
//这个结构体用来存储边，u表示边的起点，v表示边的终点，w表示该边的边权 
int n,m,ans[maxn];
int main(){
    scanf("%d",&n);//读入点的数量 
    for(int i = 1;i <= n;i++) ans[i] = inf;
    ans[1] = 0;
    //初始化 
    for(int i = 1;i <= n;i++)
        for(int j = i + 1;j <= n;j++){
            dis[++m].u = i,dis[m].v = j;
            scanf("%d",&dis[m].w);
            if(dis[m].u == 1) ans[dis[m].v] = dis[m].w;
        } 
    //读入边的情况，m用来累加计算边的数量（麻烦一些） 
    for(int i = 1;i < n;i++)
        for(int j = 1;j <= m;j++)
            ans[dis[j].v] = min(ans[dis[j].v],ans[dis[j].u] + dis[j].w);
    //BF的核心操作，即不断进行n-1次松弛 
    printf("%d",ans[n]);
    return 0;
}
```

---

## 作者：lych (赞：1)

本题其实是一道最基础的floyed，注意每次一定要向前走，所以floyed可以优化一定的时间。

```delphi
var
  f:array[0..200,0..200] of longint;
  i,j,k,n:longint;
begin
  readln(n);
  fillchar(f,sizeof(f),$7f shr 1);
  for i:=1 to n do f[i,i]:=0;
  for i:=1 to n-1 do
    for j:=i+1 to n do
      read(f[i,j]);//读入
  for k:=1 to n do
    for i:=1 to k-1 do//起点一定在中转点的左侧
      for j:=1+k to n do//终点一定在中转点的右侧
        if f[i,k]+f[k,j]<f[i,j] then
          f[i,j]:=f[i,k]+f[k,j];//最基础的floyed
  writeln(f[1,n]);//1~n的路径
end.[codep/]
另外，也可以用dijkstra过，即用1为起点。
但是相对于floyed来说代码复杂度略高，在能通过的情况下，都是0ms，因此在此不提供程序。


---

## 作者：ZYBGMZL (赞：1)

看到大牛们的题解都做**最短路**，

还有一些被**有向图**坑了的大牛们。

蒟蒻做这题时没想到图，纯**dp**解法。

枚举i,j,k作起点、终点、中介点。

ps:缩进真的看不了

```cpp
#include<cstdio>
#include<cstring>
#define inf 0x7f7f7f7f
using namespace std;

const int maxn=201;
int f[maxn][maxn];
int n;

inline int minn(const int &n1,const int &n2){
    return n1<n2?n1:n2;
}

int main(){
    scanf("%d",&n);
    memset(f,inf,sizeof f);
    for(int i=1;i<=n-1;i++){
        for(int j=i+1;j<=n;j++){
            scanf("%d",&f[i][j]);
        }
    }
    //分别枚举i,j作起点和终点 
    for(int i=1;i<=n-1;i++){
        for(int j=i+1;j<=n;j++){
            //枚举k作中介点 
            for(int k=i+1;k<=j-1;k++){
                f[i][j]=minn(f[i][j],f[i][k]+f[k][j]);
            }
        }
    }
    printf("%d\n",f[1][n]);
    return 0;
}
```

---

## 作者：Carbon (赞：1)

~~暴力碾标算，n方过百万~~

为什么偏要用dp呢，emmm...

前面似乎没有c++版的Floyd，蒟蒻我便向各位dalao推出Floyd

```CPP
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>

using namespace std;

const int N=200+1;
int dist[N][N];//邻接矩阵 
int n;

int min(int a,int b)
{
	return a<b?a:b;
}

void floyd()
{
	for (int k=1; k<=n; k++)
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);//赤裸的floyd，应该不用解释吧。 
}



int main()
{
	scanf("%d",&n);
	for (int i=1; i<=n; i++)
	{
		for (int j=i+1; j<=n; j++)
		{
			int c;
			scanf("%d",&dist[i][j]);
			dist[j][i]=0x3fffffff;//因为只能从上游往下走，所以反向要设为无穷大，用0x7fffffff会爆的。。 
		}
	}
	floyd();
	printf("%d\n",dist[1][n]);
	return 0;
}
```

---

## 作者：srcrs (赞：0)

这道题就是一个求单源最短路径，难处理的是如何存储这个半矩阵r。
矩阵r
5 15
7
表示的意思是1到达2的长度是5，1到达3的长度是15，2到达3的长度是7。
存储的时候我也是按照这样的形式存储的f[1][2]=5，表示的就是1到2的长度为5。
状态转移方程为f[1][i] = min(f[1][i],f[1][j]+f[j][i])，1代表起始点，i代表终点，最终要求的结果是f[1][n]，即1到n的最短距离。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int f[205][205];
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        fill(f[i], f[i] + n, 0);
    }
    for (int i = 1; i < n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            cin >> f[i][j];
        }
    }
    for (int i = 3; i <= n; i++)
    {
        for (int j = 2; j < i; j++)
        {
            f[1][i] = min(f[1][i], f[1][j] + f[j][i]);
        }
    }
    cout << f[1][n];
    system("pause");
    return 0;
}
```



---

## 作者：weak_ddb (赞：0)

这道题一看到从$1$到$n$的最小费用，就想到了最短路。

$SPFA$会被卡，我们还是用$dijkstra$吧。

这里本蒟蒻采用了$STL$堆优化，大佬们凑合着看看吧。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define il inline
#define re register
using namespace std;
int cnt;
struct edge
{
	int to,next,w;
}e[800005];//链式前向星代替邻接表
int head[400005],dis[400005],vis[400005],n,m,s;
//具体可以查看单元最短路径模板
il LL read()
{
	re int l=1,f=0;re char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(f=='-')l=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	f=(f<<3)+(f<<1)+(ch^48),ch=getchar();
	return l*f;
}
il void put(LL x)  
{
	if(x==0)putchar('0');
    re int num = 0; re char c[15];
    while(x) c[++num] = (x%10)+48, x /= 10;
    while(num) putchar(c[num--]); 
}//快读，快输
priority_queue<int,vector<pair<int,int> >,greater<pair<int,int> > > q;
il void add(int u,int v,int w)
{
	++cnt;
	e[cnt].to=v;
	e[cnt].next=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}//链式前向星连边
il void dijkstra(int s)
{
	for(re int i=1;i<=n;i++)
	dis[i]=INT_MAX;
	dis[s]=0;//距离初始化，原点清零
	q.push(make_pair(0,s));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=true;//不停寻找最近的点并更新距离
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(!vis[v]&&dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				q.push(make_pair(dis[v],v));
			}
		}
	}
}
int main()
{
	n=read();
	//scanf("%d %d %d",&n,&m,&s);
	for(re int i=1;i<=n;i++)
		for(re int j=i+1,u;j<=n;j++)
		{
			u=read();
			add(i,j,u);
		}
	dijkstra(1);//源点为1号
	put(dis[n]);
	return 0;
}//大概也就这亚子
```


---

## 作者：wangcr (赞：0)

P1359题解

相信各位看过楼上dalao们的做法~~(SPFA,DP等等)~~后，已经对本题有了些感悟。

其实本题的做法有两种。

1、带权最短路~~(裸的)~~

由题意我们可以知晓我们需要求出从起点到起点以下的每个点的带权最短路。我们想当然的可以想到SPFA,Dijkstra,Floyd。

首先我们来谈谈SPFA和Dijkstra。学过最短路的人应该都知道。对于大数据，我们应该用SPFA或者Dijkstra，否则会超时。而这两种方法，有那么一点点小区别~~(一个用来做有稠密点的，一个做点稀疏一点的)~~。那么对于Floyd，则是针对于小数据的~~(毕竟是代码最好打的一种)~~，数据一大，就会超时。

然而我们看本题，n为正整数且n<=200。本蒟蒻一算，应该不会超时~~(后来数据证明最慢的点也只要20ms过)~~，所以便打了一份Floyd。

2、DP(动规)

由于没有后效性，所以我们可以再此题用DP来处理。

楼上dalao已经帮我们写出了状态转移方程：f[j]=min(f[j],f[i]+a[i,j])~~(帮你们copy一下，省的你们往下翻)~~

f[j]指的是当我们需要在j点上岸时所需要交的最少租金。很显然，我们可以通过不断地向后进行DP，从而得到从起点到最终点的路途中每个点上岸所需的最小租金。

那么由于本题数据较小，本蒟蒻便用Floyd~~(我才不会告诉你我懒得打SPFA和Dijkstra呢。。)~~



------------------------华丽丽的分割线------------------------

```
#include<iostream>
using namespace std;
int a[210][210];
int f[210][210];//用来存放个点的最小租金
int main()
{
    int n;
    cin >>n;
    for (int i=1;i<n;i++)
        for (int j=i+1;j<=n;j++)
            {
                cin >>a[i][j];
                f[i][j]=a[i][j];
                //建立一个初始最小租金。
            }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (f[i][j]==0) f[i][j]=9999999;
    //如果我们没有这两点最初的最小租金，那么就将其赋予一个hin大的量
    //这样可以使后面比较时不会出错..
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            for (int k=1;k<=n;k++)  if (f[i][k]+f[k][j]<f[i][j]) f[i][j]=f[i][k]+f[k][j];
    //Floyd(裸的)
    cout <<f[1][n];//最后进行输出..
    return 0;
}
```
献上本蒟蒻冗长的代码..
望dalao勿喷..

---

## 作者：ModestCoder_ (赞：0)

看到数据范围n<=200

果断用Floyd!!

看到有人初值要开大

其实不用

dist[i][j]表示从i到j的最短路径长度

我们就给他保证i<j就行了

而且根据题目

任意两个点都存在至少一条最短路径

有没有人不懂Floyd?

没事，不方------------>看程序就行了



```cpp
uses math;
var
    dist:array[0..1000,0..1000] of longint;
    n,i,j,k:longint;
begin
    readln(n);
    for i:=1 to n-1 do
        begin
            for j:=i+1 to n do
                read(dist[i][j]);
            readln;
        end;
    for k:=1 to n do   //枚举中间点，用于松弛
        for i:=1 to k-1 do  //枚举起点
            for j:=k+1 to n do  //枚举终点
                dist[i][j]:=min(dist[i][j],dist[i][k]+dist[k][j]);  //状态转移方程不用再说了吧~~~
    writeln(dist[1][n]);  //这就是Floyd的好处，能把任意两点的最短路径求出来
end.
```

---

## 作者：香风智乃 (赞：0)

楼下好多dalao都写了题解，不过Dijkstra算法出现的次数貌似最少（好像就1次啊），所以本蒟蒻来补充一下

具体可以参考刘汝佳的紫书，以下的代码就是基于书中的不完全模板（模板将数据结构封装到结构体中，然而本蒟蒻并没有这样做）。

代码中大量运用stl：vector、priority\_queue，并涉及到结构体struct。

当然你也可以用邻接矩阵写，个人认为较容易实现，不过速度较慢。

因为
d[e.to]>d[u]+e.dis

这个式子常常不成立，所以push操作少

最后引用书上的一段话：“即使是稠密图，使用priority\_queue实现的Dijkstra算法也常常比基于邻接矩阵的Dijkstra算法的运算速度快。”

```cpp
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
struct edge{
    int from,to,dis;
};
struct data{
    int d,u;
    bool operator < (const data& tmp) const
    {
        return d>tmp.d;
    }  //自定义小根堆
};
vector <edge> ed;    //存边
vector <int> g[202];   //存边的编号
int d[202];   //存当前点的最小花费
priority_queue <data> h; 
int main()
{
    memset(d,127/3,sizeof(d));
    int n,u,q,i,j,id=-1;
    scanf("%d",&n);
    for(i=1;i<n;i++)
        for(j=i+1;j<=n;j++)
        {
            scanf("%d",&q);
            ed.push_back((edge){i,j,q});
            g[i].push_back(++id);
        }  //输入
    h.push((data){0,1});  //初始花费为0，从第1个出租站开始
    d[1]=0;
    while(!h.empty())
    {
        data x=h.top(); h.pop();
        u=x.u; q=g[u].size();
        if(x.d!=d[u]) continue;   //可以省下一个标记数组： if(done[u]) continue;   done[u]=true;
        for(i=0;i<q;i++)
        {
            edge &e=ed[g[u][i]];
            if(d[e.to]>d[u]+e.dis)
            {
                d[e.to]=d[u]+e.dis;
                h.push((data){d[e.to],e.to});
            }
        }
    }
    printf("%d",d[n]);
    return 0;
}
```

---

## 作者：Bartholomew (赞：0)

/\* floyd 算法


保存了之前的路径最短的路迹，不是单单的只转一点


利用o（n^3)的循环的结果哦表示，但是数字大就不行


比如相当于3->4的路中有1转折，


如果短就记下来，就数据变成了4->1->3,


在可以试试4->3的捷径


所以k的循环从一层开始


\*/


```cpp
#include <bits/stdc++.h>万能头文件
using namespace std;
int f[10000][10000];         //开创一个数组
int main() {
    int n;
    cin>>n;            //输入数据n
    for(int i=1; i<=n-1; i++)      //floyd 算法
        for(int j=i+1; j<=n; j++)
                    cin>>f[i][j];
    for(int i=1; i<=n; i++)
        for(int j=1; j<=i; j++)
            if(i!=j)           //如果不是i->i的情况，记为∞
                f[i][j]=99999;      //让9999记为无穷大
    for(int k=1; k<=n; k++)
        for(int i=1; i<=n; i++)//保存了之前的路径最短的路迹，不是单单的只转一点
```
利用o（n^3)的循环的结果哦表示，但是数字大就不行

比如相当于3->4的路中有1转折，


```cpp
            for(int j=1; j<=n; j++)//开始循环
                if(f[i][j]>f[i][k]+f[k][j])      //即最重要的转移方程，如果小就交换，如果看不懂就私信我，有文档
                    f[i][j]=f[i][k]+f[k][j];//交换数据
cout<<f[1][n];      //输出1->n
}
```

---

## 作者：cheeseYang (赞：0)

看了下楼下的题解，觉得大佬们的Floyd算法说的可能让新手难懂，这里我详细解释一遍

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int z=210;
int n,dis[z][z];
int main(){
    cin>>n;
    for(int i=2;i<=n;i++)
        for(int j=1;j<i;j++)
            dis[i][j]=1000000;   （先初始化，这里为什么要这样初始化，因为我下面输入是输入从i到j的费用，而我的j是从i+1开始的，所以有一些情况没有值，就默认为0了，比如dis[1][2]表示从1到2所需费用，而我没有输入dis[2][1]的费用（虽说是一样的，但计算机识别不出），所以这里我要把值初始化很大，用于后面比较，因为Floyd算法是将所有情况都列出来，时间复杂度很大，如果没有初始化没有输入的值，就会出现问题）
    for(int i=1;i<=n;i++)
        for(int j=1+i;j<=n;j++)
            scanf("%d",&dis[i][j]);
    for(int l=1;l<=n;l++)（l点为桥梁）
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][l]+dis[l][j]);     （如果从i到l再从l到j所耗费的租金比直接从i到j便宜，就更新）
    cout<<dis[1][n];
    return 0;
}
```

---

## 作者：江屿 (赞：0)

```cpp
//裸的最短路，裸的floyd就可以过
#include<cstdio>
#include<iostream>
#define N 240
using namespace std;
int dis[N][N],n;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            if(i!=j)
                dis[i][j]=1e9;//先初始化 
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j)
            scanf("%d",&dis[i][j]);
    for(int k=1;k<=n;++k)//floed求最短路 
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    printf("%d",dis[1][n]);
    return 0;
}
```

---

## 作者：Rainey (赞：0)

这题给的半矩阵居然是有向的。。也就是说i到j通，j到i不通，所以dp就行了，如果像我一样写了图的，把j到i的距离初始化为无穷大也行

```cpp
#include<cstdio>
using namespace std;
int f[300][300];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n-1;++i)
        for(int j=i+1;j<=n;++j)
        {
            scanf("%d",&f[i][j]);
            f[j][i]=2100000000;
        }
    for(int k=1;k<=n;++k)
        for(int j=1;j<=n;++j)
            for(int i=1;i<=n;++i)
                if((f[i][k]+f[k][j])<f[i][j]) f[i][j]=f[i][k]+f[k][j];
    printf("%d",f[1][n]);
    return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

这是一道非常简单的图论题，大家学过弗洛伊德算法就很快AC

但是没有学过也不要紧，可以用动态规划。

- 动态规划解法O(n^2)

```cpp
设f[i]为到第i个站的最小租金，则f[1]=0,
f[i]=min{f[j]+r[j][i]}(1≤j＜i)
挺简单的一道线性dp
var n,i,j:longint;
    s:array[1..300,1..300]of longint;
begin
   readln(n);
   for i:=1 to (n-1) do 
     for j:=i+1 to n do 
       read(s[i,j]);
     for i:=2 to n do 
         for j:=i to n do
     if s[1,i]+s[i,j]<s[1,j] then s[1,j]:=s[1,i]+s[i,j];
     writeln(s[1,n]);
end.
```
- dijkstra算法O(n^2)

求单源最短路

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int r[210][210],d[210];
bool e[210];
int main(){
    int i,j,n,ans,l=100000000,a,t=0,k;
    memset(d,-1,sizeof(d));
    scanf("%d",&n);
    for (i=1;i<n;i++){
        for (j=i+1;j<=n;j++){
            scanf("%d",&r[i][j]);
        }
    }
    d[1]=0;
    for (k=1;k<=n;k++){
        l=100000000;
        for (i=1;i<=n;i++){
            if ((!e[i])&&(l>d[i]&&d[i]!=-1)){
                l=d[i];
                a=i;
            }
        }
        e[a]=1;
        for (i=a+1;i<=n;i++){
            if (d[i]==-1||d[i]>l+r[a][i]) d[i]=l+r[a][i];
        }
    }
    cout<<d[n];
    return 0;
}
```
- 弗洛伊德算法O(n^3)

```cpp
var  i,j,k,n:longint;
     f,a:array[1..200,1..200]of longint;
begin
 readln(n);
 for i:=1 to n do
  for j:=i+1 to n do begin
   read(f[i,j])
 end;
 for i:=1 to n do
  for j:=1 to n do
   if f[i,j]=0 then f[i,j]:=maxlongint div 2;
 for k:=1 to n do
  for i:=1 to n do
   for j:=1 to n do
    if (i<>j)and(j<>k)and(k<>i)and(f[i,j]>f[i,k]+f[k,j])
    then f[i,j]:=f[i,k]+f[k,j];
  writeln(f[1,n]);
end.
```

---

## 作者：doby (赞：0)

这里说一下，huangxuanao真机智……

这题竟然是有向图，怪不得SPFA只有67……

然后……还是那份代码……

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,z,op,head[50009],next[50009],dis[50009],len[50009],v[50009],l,r,team[50009],pd[50009],u,v1,e,out,fh;
char cc;
int read()//读入优化
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
void lt(int x,int y,int z)//单向联通
{
    op++,v[op]=y;
    next[op]=head[x],head[x]=op,len[op]=z;
    return;
}
void SPFA(int s)//SPFA……
{
    for(int i=1;i<=50000;i++){dis[i]=23333333;}
    memset(team,0,sizeof(team));
    memset(pd,0,sizeof(pd));
    l=0,r=1,team[1]=s,pd[s]=1,dis[s]=0;
    while(l!=r)
    {
        l=(l+1)%50000,u=team[l],pd[u]=0,e=head[u];
        while(e!=0)
        {
            v1=v[e];
            if(dis[v1]>dis[u]+len[e])
            {
                dis[v1]=dis[u]+len[e];
                if(!pd[v1])
                {
                    r=(r+1)%50000,
                    team[r]=v1,
                    pd[v1]=1;
                }
            }
            e=next[e];
        } 
    }
    return;
}
int main()
{
    n=read();
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            z=read();//建路
            lt(i,j,z);
        }
    }
    SPFA(1);//从1开始跑SPFA
    printf("%d",dis[n]);//输出
    return 0;
}
```

---

## 作者：深海鱼的眼泪 (赞：0)

dijkstra求单源最短路


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int r[210][210],d[210];
bool e[210];
int main(){
    int i,j,n,ans,l=100000000,a,t=0,k;
    memset(d,-1,sizeof(d));
    scanf("%d",&n);
    for (i=1;i<n;i++){
        for (j=i+1;j<=n;j++){
            scanf("%d",&r[i][j]);
        }
    }
    d[1]=0;
    for (k=1;k<=n;k++){
        l=100000000;
        for (i=1;i<=n;i++){
            if ((!e[i])&&(l>d[i]&&d[i]!=-1)){
                l=d[i];
                a=i;
            }
        }
        e[a]=1;
        for (i=a+1;i<=n;i++){
            if (d[i]==-1||d[i]>l+r[a][i]) d[i]=l+r[a][i];
        }
    }
    cout<<d[n];
    return 0;
}
```

---

## 作者：XUCHENGHUI (赞：0)

弗洛伊德

设一个二维数组f

f[i][j]表示i到j的距离，然后弗洛伊德一遍就过了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int i,j,k,n,m,tot;
long a[1005],b[1005],f[205][205];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
     for (int j=1;j<=n;j++) f[i][j]=32768;
    for (int i=1;i<=n-1;i++)
     for (int j=i+1;j<=n;j++)
      {
          cin>>k;
          f[i][j]=k;
      }
    for (int k=1;k<=n;k++)
     for (int i=1;i<=n;i++)
      for (int j=1;j<=n;j++)
       f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
    printf("%d",f[1][n]);
    return 0;
}
```

---

## 作者：AFOier (赞：0)

这题其实用dp或者最短路都可以做，下面的题解已经提到了dp，那我来说一说最短路吧

首先是一个33分的东东，是刚学最短路的时候写的：

```cpp
#include <iostream>
using namespace std;
int n,r[201][201];
int main()
{
    cin>>n;
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            cin>>r[i][j];
        }
    }
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
    if(r[i][j]>r[i][k]+r[k][j])
    r[i][j]=r[i][k]+r[k][j];
    cout<<r[1][n]<<endl;
}
```
然后变成了67分，和讨论里的那个错得一模一样
```cpp
#include <iostream>
using namespace std;
int n,r[201][201];
int main()
{
    cin>>n;
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            cin>>r[i][j];
            r[j][i]=r[i][j];
        }
    }
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
    if(r[i][j]>r[i][k]+r[k][j])
    r[i][j]=r[i][k]+r[k][j];
    cout<<r[1][n]<<endl;
}
```
注意到没有，有向图是33分，无向图是67分，然而正解却是有向图
。。。

好吧，现在上期待已久的AC代码：

```cpp
#include <iostream>
using namespace std;
long long n,r[201][201];
int main()
{
    cin>>n;
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            cin>>r[i][j];
```
}//巧妙的输入（其实很简单）
```cpp
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(r[i][j]==0)r[i][j]=0x7fffff;
```
}//初始化
```cpp
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)//从1开始感觉还是无向图但是呢如果从i+1开始的话就67。。。
    if(r[i][j]>r[i][k]+r[k][j])
    r[i][j]=r[i][k]+r[k][j];
    cout<<r[1][n]<<endl;
}
```

---

## 作者：Floating__Dream (赞：0)

最优子结构：i到j的最优解包含i到k和k到j最优解，其中i<k<j。

重叠子问题：要求得1到n的最优解就得将1到n每两点之间的值，而有些值会重复利用。


/\*
设f[i]表示从第一个站到第i站的最小花费

f[i]=min{f[j]+a[j][i]};

j:i-1~~2

\*/
```cpp
#include<fstream>
using namespace std;
ifstream fin("boat.in");
ofstream fout("boat.out");
int a[201][201],f[201],n;
int main()
{
    memset(f,0,sizeof(f));
    memset(a,0,sizeof(a));
    fin>>n;
    int i,j,k,minn;
    for(i=1;i<n;i++)
       for(j=i+1;j<=n;j++)
       fin>>a[i][j];
    for(i=2;i<=n;i++)
    {
       f[i]=a[1][i]; //f[i]初始化 
       for(k=i-1;k>=2;k--)
          f[i]=min(f[i],f[k]+a[k][i]);
    }
    fout<<f[n];
    return 0;
}

```

---

## 作者：PureAprilWY (赞：0)

代码很简短，经典动归

直接读入即初始化数组，状态转移方程为  s[1,j]:=min{ s[1,i]+s[i,j]，s[1,j]}；

具体看代码 吧

```cpp
program wan;
     var n,i,j:longint;
          s:array[1..300,1..300]of longint;
begin
     readln(n);
     for i:=1 to (n-1) do 
         for j:=i+1 to n do 
              read(s[i,j]);//关键看懂读入   这很重要  是s[i,j]表示i到j  的租金
     for i:=2 to n do //  主体部分  应该大家都可以看懂
         for j:=i to n do
     if s[1,i]+s[i,j]<s[1,j] then s[1,j]:=s[1,i]+s[i,j];
     writeln(s[1,n]);
     readln;
end.
```

---

## 作者：x_faraway_x (赞：0)

膜拜各位神犇的最短路orz

这题其实是一个dp（动态规划）题

设f[i]为到第i个站的最小租金，则f[1]=0,

f[i]=min{f[j]+r[j][i]}(1≤j＜i)

还是挺简单的一道线性dp

```cpp
#include <cstdio>
const int N = 233;
#define INF 23333333
int r[N][N], f[N], n;
inline int mn(int x, int y) {
    return x < y ? x : y;
}
void init() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        for(int j = i+1; j <= n; j++)
            scanf("%d", &r[i][j]); //按题目要求读入
}
void work() {
    f[1] = 0; //初始化
    for(int i = 2; i <= n; i++) {
        f[i] = INF;
        for(int j = 1; j < i; j++)
            f[i] = mn(f[i], f[j]+r[j][i]); //状态转移
    }
    printf("%d", f[n]);
}
int main() {
    init();
    work();
    return 0;
}

```

---

## 作者：Skywalker_David (赞：0)

一道Floyed算法，也就是最短路径算法，可以计算图中任意两点之间的最短路径。时间复杂度为O（N^3）。

初始化：点u，v如果有边相连，则dis[u,v]=w[u,v]。如果不相连则dis[u,v]=maxlongint div 3。

```delphi

var
    i,j,k,n:longint;
    a,f:array[1..201,1..201] of longint;
begin
    readln(n);
    for i:=1 to n do
        for j:=i+1 to n do begin
            read(a[i,j]);
            f[i,j]:=a[i,j];
        end;
    for i:=1 to n do
        for j:=1 to n do
            if a[i,j]=0 then
                f[i,j]:=maxlongint div 3;
    for k:=1 to n do
        for i:=1 to n do
            for j:=1 to n do
                if f[i,j]>f[i,k]+f[k,j] then
                    f[i,j]:=f[i,k]+f[k,j];
    write(f[1,n]);
end.

```

---

## 作者：wzf2000 (赞：0)

```delphi

var
  i,j,k,n:longint;
  a,f:array [1..200,1..200] of longint;
begin
  readln(n);
  for i:=1 to n do
    for j:=i+1 to n do
      begin
        read(a[i,j]);
        f[i,j]:=a[i,j];
      end;
  for i:=1 to n do
    for j:=1 to n do
      if a[i,j]=0 then
        f[i,j]:=maxlongint div 2;
  for i:=1 to n do
    for j:=1 to n do
      for k:=1 to n do
        if f[i,k]+f[k,j]<f[i,j] then
          f[i,j]:=f[i,k]+f[k,j];
  writeln(f[1,n]);
end.
```
弗洛伊德直秒  （重点看懂读入）


---

## 作者：youken (赞：0)

看各位大佬各种动归，弗洛伊德和dijkstra，却只有一个spfa，用vector储存的，这里我给出一个更标准的spfa，采用邻接表储存边。详细说明的见代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define maxn 205
#define inf 1<<30//超大数代表无限远 
long long n,map[maxn][maxn];
int dis[maxn],head[maxn],number;//head存每条边的头，dis为距离 
struct node{
    int e;//边的尾 
    int v;//权 
    int next;//上一条边的头（这里采用的是链表的头插法） 
}edge[20005];//邻接表 
//这里感谢大牛 @ Night_Aurora 的指点，我之前edge开小了，r了两个点 
inline void add(int b,int v,int e){  
    number++;
    edge[number].v=v;
    edge[number].e=e;
    edge[number].next=head[b]; 
    head[b]=number;
    return;
}
//----------------SPFA------------- 
void spfa(int s){
    bool light[maxn];//标记数组 
    queue<int>q;
    memset(light,0,sizeof(light));//初始化 
    for(int i=1;i<=n;i++)dis[i]=inf;//初始化 
    light[s]=1;q.push(s);dis[s]=0;
//从起点开始，起点到起点的dis为0 ，将起点打标入队 
    while(!q.empty()){
        int b=q.front();q.pop();light[b]=0;
        for(int i=head[b];i>=0;i=edge[i].next){
            int e=edge[i].e,v=edge[i].v;
//--------------松弛操作--------------- 
            if(dis[e]>dis[b]+v){
                dis[e]=dis[b]+v;
//------------松弛操作完--------------- 
                if(!light[e]){
                    light[e]=1;
                    q.push(e);//打标记，入队 
                }
            }
        }
    }
    printf("%d",dis[n]);//起点s到终点n的最短距离 
}
//---------------SPFA完---------------- 
int main(){
    memset(head,-1,sizeof(head));
    scanf("%lld",&n);
    int v;
/*这里有必要说明一下。因为题目所给为半矩阵，以样为例，即
  i 1  2  3
j 1 0  5  15
  2 5  0  7
  3 15 7  0（就是邻接矩阵） 
所以如下面代码，（自己到自己的边不读入）
i到n-1即可，j从i+1开始 ，i，j就是边的头和尾 
*/
    for(int i=1;i<=n-1;i++) 
        for(int j=i+1;j<=n;j++){
            scanf("%d",&v);
            add(i,v,j);
        }
    spfa(1);
    return 0;
}
```

---

## 作者：mike_he (赞：0)

这题可以直接使用图论的最短路算法...这里提供SPFA的解法。需要注意的是，这里的点ID是k+i+1(0<=i<g[k].size())

由于数据量很小，所以直接用vector存邻接表

[codec]



```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
#define INF 0x3f3f3f3f
vector<int> g[310];
queue<int> q;
int dist[310];
bool vis[310];
int N;
inline void init(){
    cin>>N;
    for(int i=1;i<N;i++){
        for(int j=i+1;j<=N;++j){
            int dis;cin>>dis;
            g[i].push_back(dis);
        }
    }
    memset(dist,INF,sizeof(dist));
}
inline void spfa(int s){
    vis[s]=true;
    q.push(s);
    dist[s]=0;
    while(!q.empty()){
        int k=q.front();
        q.pop();
        vis[k]=true;
        for(int i=0;i<g[k].size();++i){
            int v=k+i+1;
            if(dist[k]+g[k][i]<dist[v]){
                dist[v]=g[k][i]+dist[k];
                if(!vis[v]){
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
        vis[k]=false;
    }
}
int main(){
    init();
    spfa(1);
    cout<<dist[N];
    return 0;
}
[/codec]
```

---


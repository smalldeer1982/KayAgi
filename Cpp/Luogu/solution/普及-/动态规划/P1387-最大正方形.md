# 最大正方形

## 题目描述

在一个 $n\times m$ 的只包含 $0$ 和 $1$ 的矩阵里找出一个不包含 $0$ 的最大正方形，输出边长。

## 样例 #1

### 输入

```
4 4
0 1 1 1
1 1 1 0
0 1 1 0
1 1 0 1
```

### 输出

```
2
```

# 题解

## 作者：Ice_teapoy (赞：582)

##题解 P1387 【最大正方形】

感觉我的代码是比较短的辣QWQ

###动态规划，状转方程：

if (a[i][j]==1) f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1;

###说明：

f[i][j]表示以节点i,j为右下角，可构成的最大正方形的边长。

只有a[i][j]==1时，节点i,j才能作为正方形的右下角；

对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内向上x个节点，向左x个节点扫过的正方形中所有a值都为1；

对于一个待确定的f[i][j]，我们已知f[i-1][j]，f[i][j-1]，f[i-1][j-1]的值，如下：

f数组:

? ? ? ?

? ? 2 1

? ? 3 **?**

? ? ? ?

则说明原a数组：

1 1 1 0

1 1 1 1

1 1 1 **1**

? ? ? ?

由此得出状态转移方程：

if (a[i][j]==1) f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1;

**for example:**

a[i][j]:

0 0 0 1

1 1 1 1

0 1 1 1

1 1 1 1


f[i][j]:

0 0 0 1

1 1 1 1

0 1 2 2

1 1 2 3



```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[101][101],n,m,f[101][101],ans;
int main()
{
    scanf("%d%d",&n,&m);//读入
    for (int i=1;i<=n;++i)
        for (int j=1;j<=m;++j)
        {
            scanf("%d",&a[i][j]);
            //因为只需用到i，j上方，左方，左上方的信息，读入同步处理
            if (a[i][j]==1) f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1;
            ans=max(ans,f[i][j]);//同步更新答案
        }
    printf("%d",ans);
}
ans=3
```

---

## 作者：zjh111111 (赞：316)

### update: 前缀和加二分的解释及程序

---

### ~~水题水题水题~~

# 暴力出奇迹

## $Ps:$ 有评论区问能不能用二分做 答案是 可以 的 代码解释请看下


#### 本篇题解介绍纯暴力方法。不会炸，还挺快~~(不会$DP$直说嘛)~~

### 【题外话】
> 考场上不要盲目地追求正解！先全部写完暴力(可以和正解对拍)，再慢慢研究正解。不能在一题上耗费过多时间，其实有时候你辛辛苦苦写了个正解，某个地方写挂了，那还不如人家乱打的暴力.

------------

### 【思路】

#### 枚举每一个点作为所选正方形的左上角的点，然后枚举正方形边长，逐一判断。

### 【优化】

- #### 边长倒着枚举，$min(n,m)$作为上界(因为正方形边长最大就是$min(n,m)$)，枚举到当前的最大边长(不是最优解即使符合条件也是无济于事)。

- #### 逐一进行判断，一旦找到$0$立刻将双重循环$break$。

- #### 假如可行(即这个边长的正方形符合条件)则：

 ##### $1.$ 直接将最优解替换(由于下界为当前最大边长)。

 ##### $2.$ 将枚举长度的那一段$break$(由于是倒着枚举)。
 
Code：

```cpp
#include <bits/stdc++.h>
#define re register int
using namespace std;
bool f[202][202]={0},p;
int n,m,i,j,k,x,y,ans=0;
int main()
{
  scanf("%d%d",&n,&m);
  for (re i=0; i<n; i++)
    for (re j=0; j<m; j++)
      scanf("%d",&f[i][j]);          //读入不解释
  for (re i=0; i<n; i++)
    for (re j=0; j<m; j++)
      for (re k=min(n,m); k>ans; k--)//优化1
        {
          p=1;
          for (re x=i; x<i+k; x++)   //逐个判断
            {
              for (re y=j; y<j+k; y++)
                if (!f[x][y])        //不是1的话
                  {
                    p=0; break;      //标记，跳出循环，优化2
                  }
              if (!p) break;         //不符合没必要接着做，优化2
            }
          if (p)                     //符合条件的话
            {
              ans=k; break;          //优化3
            }
        }
  printf("%d",ans);                  //输出
  return 0;
}
```

### 【一些思考】

#### 假如n再大些，我们可以用前缀和，分为以下两种：

- #### $O(n^4)$的，设 $f[i][j] = $ 输入数据中第i行的前j个的和。那么枚举的时候只需枚举行，要是 $f[x][j+k] - f[x][j] $ (即这一行$1$的个数) $< K$ 那么就不符合条件。

- #### $O(n^3)$的，设 $f[i][j] = $输入数据中从$(1,1)$到$(i,j)$的总和。
#### 求前缀和的时候可以
$$f[i][j] = f[i-1][j] + f[i][j-1] - f[i-1][j-1] + a[i][j]$$
($a[i][j]$当前值)，如下图：
![](https://cdn.luogu.com.cn/upload/pic/32221.png)

 #### 黄色是重叠部分，紫色是当前值，两个加上后减去重叠再加上当前值即为我们要求的。
####  判断时只需要判断 ($i,j$表示正方形左上角的坐标;$k$为正方形边长)

$$f[i+k][j+k] - f[i+k][j] - f[i][j+k] + f[i][j]$$

是否 $< k^2$ 即可，小于则不满足条件。 如下：
 ![](https://cdn.luogu.com.cn/upload/pic/32218.png)
####  由于重复所以要加上去，稍微想一下就出来了。

$ $

### 【二分优化】
- 有同学提到可以二分优化，我认为这是一个非常棒的想法~~(毕竟我没想到)~~
- 为什么可以二分?

> 因为不同边长是否符合条件具有单调性

意思就是，设答案为$ans$,那么

1. **大于$ans$的肯定不符合条件**(即有0),不然那个大于$ans$又符合条件的才是真正的答案(这是个假的$ans$),

2. **小于$ans$的肯定都符合条件**,因为边长为$ans$的正方形包含了边长$<=ans$的正方形，所以边长$<ans$的正方形符合条件(即全是1)是边长为$ans$的正方形符合条件的必要不充分条件。

   即$<x$的不符合,$x$必然不符合, $<x$符合，$x$也有可能不符合($x=$边长)

   综上,得到小于$ans$的都符合。

**有了单调性后就可以二分优化啦！**

**二分边长$k$,用之前的判断方法判断,如果可行则增大$k$(没准可以更大), 否则减小$k$**

这里给出上面$O(n^3)$的优化方案，时间复杂度优化成了$O(n^2log(n))$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans = 0, x, f[205][205];
int main() {
	scanf("%d%d", &n, &m);
	for (int i=0; i<n; ++i)
		for (int j=0; j<m; ++j) {
			scanf("%d", &x);
			f[i][j]= f[i-1][j]+f[i][j-1]-f[i-1][j-1]+x;
		}
	for (int i=0; i<n; ++i)
		for (int j=0; j<m; ++j) {
			int l = 0, r = min(n,m);
			while (l<=r) {
				int mid = (l+r)>>1;
				if (i+mid>n || j+mid>m || f[i+mid][j+mid]-f[i+mid][j]-f[i][j+mid]+f[i][j] < mid*mid) r = mid-1;
					else l = mid+1;
			}
			if (f[i+r][j+r]-f[i+r][j]-f[i][j+r]+f[i][j] == r*r) ans = max(ans, r);
		}
	cout << ans;
	return 0;
}
```
实测已AC,要注意的是二分后还要再判断一下,不然就只有40分

### $O(n^2)$的话就去看楼下的dp吧。
### 我的虽然不是最优的，却是最好理解的！
#### ~~如果您满意的话右上角的赞~~

加了$\LaTeX$ $,$ 更新 $by$ $2018$ - $11$ - $17$ $ $ $20$:$00$

修了$\LaTeX$ $ $ 加了二分 $,$ 更新 $by$ $2019$ - $9$ - $11$ $ $ $6$:$47$



---

## 作者：Panthera_AFO (赞：196)

这道题可谓DP经典，只是我看楼上几个题解都不太详细，在此给一个证明吧（或者说详细讲解？）

~~希望不要说窝算法重复~~

这张图用画图画了半天，将就着看吧
![](https://s1.ax1x.com/2018/10/25/is46XT.png)

以下是我的AC代码
```
#include<cstdio>
#include<iostream>
int const maxn=111;
int f[maxn][maxn],n,m,ans;
int min(int x,int y,int z)
{
	return std::min(std::min(x,y),z);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int a,j=1;j<=m;j++)
			scanf("%d",&a),f[i][j]=a?min(f[i-1][j],f[i][j-1],f[i-1][j-1])+a:0,ans=std::max(ans,f[i][j]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：YWY_wys (赞：35)

# 暴力出奇迹

蒟蒻想不到怎么dp，于是暴力。加了些优化，跑的还挺快。好的进入正题。

### 题意：

就是让你从矩阵中找到最大的全为1的正方形，输出边长。

### 题解：

那么就按题意模拟:

先枚举正方形左上角（i，j），然后枚举边长l，判断正方形内的元素和是否为正方形面积（元素不是0就是1嘛），如果是则ans=max（l，ans）。得到一个o（nml^3）;

考虑优化：

- 求矩阵内元素和当然可以使用二维前缀和啦。
也就是：sum为前缀和数组，a为矩阵元素。预处理：sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];
按i，j顺着推一遍就行了。求（lx,ly）到（rx,ry)这一矩阵中的元素和：sum[rx][ry]-sum[rx][ly-1]-sum[lx-1][ry]+sum[lx-1][ly-1];然后就可以把o（nml^3）优化到o（nml）。然后就可以过啦

- 注意到若一个正方形中元素和不为正方形面积的话，那么再枚举边长（当然是按边长从小到大枚举啦）显然没有意义，所以可以直接break。（注意到正方形面积与边长成函数关系，即S（l）=l^2，S(l)具有严格单调性，那么我们可以二分l啦，复杂度可以达到o（nmlog (min(n,m))。）

- 边长按从小到大枚举遇到不合法情况直接break（当然是在枚举时才能用啦）。

蒟蒻当初并没有二分,所以上枚举的代码啦。

- **code**:

```
#include<cstdio>
#include<algorithm>

using namespace std;

const int maxn=105;
const int maxm=105;

int n,m,ans;
int a[maxn][maxm],sum[maxn][maxm];


int main() {
	int size;
	scanf("%d%d",&n,&m);
	size=min(n,m);
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++) {
			scanf("%d",&a[i][j]);
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		}
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++) {
			for(int l=1;l<=size;l++) {
				int rx=i+l-1;
				int ry=j+l-1;
				if(rx>n || ry>m || sum[rx][ry]-sum[rx][j-1]-sum[i-1][ry]+sum[i-1][j-1]!=l*l) break;
				if(ans<l) ans=l;
			}
		}
	printf("%d",ans);
}
```

---

## 作者：2016jzy (赞：35)

这题还是挺简单的，只需判断f[i][j]的左方、上方、左上方的最小值，再+1即可。。。

然后搞个二重循环就 # AC啦~

动态方程：f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;

```cpp
#include<iostream>
#include<cmath>                                         //头文件
using namespace std;
int n,m,a[101][101],f[101][101]={0},ans=0;
int main()
{
    cin>>n>>m;                  //输入
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];             //输入
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]==0)continue;                 //遇到零要返回，因为如果是零的话，是没法组成任何正方形的
            f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;             //动态方程
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(f[i][j]>ans)ans=f[i][j];                  //找到最大值
        }
    }
    cout<<ans<<endl;              //输出
    return 0;
}
就是需要注意代码别打错。。。
```

---

## 作者：Nemlit (赞：31)

#一道关于搜索的题

这道题可以用搜索来做，判断如果是一个·正方形就往下延伸，再让ans++，在选取最大的ans即可。我第一次提交90分，就是因为多了一句话（已经注释掉），不需要判断x+1，y+1这个点，这是多余的！

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[105][105]={0};
int n,m,ans,xx,yy,maxn;
int dfs(int x,int y){
//    if(!a[x+1][y+1])//多余
//        return 0;
    for(int i=xx;i<=x;i++)//检测正方形的左边 
        if(!a[i][y])
            return 0;
    for(int j=yy;j<=y;j++)//检测正方形的下面 
        if(!a[x][j])
            return 0;
    ans++;//让ans++并更新新的正方形 
    dfs(x+1,y+1);
    return ans;//若反回此处则返回ans 
}
int main(){
    //freopen("1387.in ","r",stdin);
    //freopen("1387.out","w",stdout);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)//离线输入 
            cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)//枚举每个点 
            if(a[i][j]){//枚举左上角的点 
                xx=i;//记录起始点的位置 
                yy=j;
                ans=0;//清空ans
                maxn=max(maxn,dfs(i,j));//求出dfs（i，j)的最大值 
            }
    cout<<maxn;
    return 0;
}
```

---

## 作者：2er0n3 (赞：13)

什么叫做暴力出奇迹;

最好理解的代码，没有之一

```cpp
#include<iostream>
#include<cstdio>
int n,m,dp[120][120],maxx=1;
using namespace std;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&dp[i][j]);
        }
    }
    for(int i=1;i<=n;i++)//枚举坐标
    {
        for(int j=1;j<=m;j++)
        {
            for(int k=1;k<=min(i,j);k++)//枚举边长
               {
                   bool ok=0;
                   for(int ii=i-k;ii<=i;ii++)//判断是否有0；
                   {
                       for(int jj=j-k;jj<=j;jj++)
                       {
                           if(dp[ii][jj]==0) ok=1;
                       }
                   }
                   if(ok==0) 
                   {
                       maxx=max(maxx,k+1);//这里不要忘记+1；
                       //printf("%d",k);
                   }
               }
         }
     }
     printf("%d",maxx);
     return 0;
}
```

---

## 作者：ljc1301 (赞：13)

我的想法和楼下差不多，只不过我是用二分答案。

先求出对于每个1≤i≤n,1≤j≤m，从(1, 1)到(i, j)中1的个数。

之后二分最后的答案可以了。

具体参见代码：

```cpp
#include <cstdio>
int sum[150][150],n,m;
int count(int x,int y,int d) //求出以(x, y)为右下角，边长为d的正方形中1的个数
{
    return sum[x][y]-sum[x-d][y]-sum[x][y-d]+sum[x-d][y-d];
}
bool ok(int k) //判断存不存在边长为k的，所有元素都为1的正方形
{
    int i,j;
    for(i=k;i<=n;i++)
        for(j=k;j<=m;j++)
            if(count(i,j,k)>=k*k)
                return true;
    return false;
}
int main()
{
    int i,j,l,r;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
        {
            scanf("%d",&sum[i][j]);
            sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; //相当于求前缀和
        }
    //二分答案
    l=0; r=(n<m)?n:m;
    while(l<r)
    {
        int mid=(l+r+1)>>1;
        if(ok(mid)) l=mid;
        else r=mid-1;
    }
    printf("%d\n",l);
    return 0;
}
```

---

## 作者：夜刀神十香ღ (赞：13)

首先肯定有边长为1的（亲测）正方形。

然后我的思路是把它的边长加1，判断是不是正方形。

~~用时: 508ms / 内存: 2109KB~~

（有点长的耗时有点大的内存啊啊啊啊）

-----------------分割线-------------------

代码部分：

```cpp
#include<cstdio>
int n,m,ans=1,a[1010][1010];
bool pd(int a1,int b,int c,int d)
{
    for(int i=a1;i<=b;i++)
        for(int j=c;j<=d;j++)
            if(a[i][j]==0) return false;//有0，不是题目所要求的正方形，返回false
    return true;//有更大的正方形，返回true
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]==1)
            {
                int k=1,h=i+1,l=j+1;
                //边长+1，判断还是不是正方形
                while(pd(i,h,j,l)) { h++; l++; k++; }//慢慢加边长，找到最大答案
                if(k>ans) ans=k;//ans存储
            }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Dzhao (赞：12)

# 题解【P1387 最大正方形】
## [博客食用更佳呦](https://www.luogu.com.cn/blog/qshjydzh/ti-xie-p1387-zui-tai-zheng-fang-xing-post)
----------------------------------------------------我是分割线----------------------------------------------------

首先，我们来看一下这道题，

>在一个n*m的只包含0和1的矩阵里找出一个不包含0的**最大正方形**，输出边长。

正方形？哦？
这时候一个~~邪恶的~~思想浮出脑子
# 暴力
>发扬暴力的优良传统

----------------------------------------------------我又是分割线----------------------------------------------------
![](https://cdn.luogu.com.cn/upload/image_hosting/phmxy13f.png)
假设，我们要求[i~n][j~m]这个矩阵的值

那么我们可以把他转换为
![](https://cdn.luogu.com.cn/upload/image_hosting/p1gtc0ss.png)
### 值就是

>（黄+蓝+绿+红）-（黄+蓝）-（黄+绿）+ 黄

那么我们用前缀和数组算就是
```cpp
p[n][m]-p[n][j-1]-p[i-1][m]+p[i-1][j-1]
```


------------
矩阵和我们会求了，下一步我们来看一下时间复杂度

我们仔细思考，发现时间复杂度只有**O(n^3)**

所以，这道题是可以轻松水过的

我们来看一下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 109
int n,m,p[N][N];
bool g[N][N];
int min(int x,int y) {return x<y?x:y;}
int max(int x,int y) {return x>y?x:y;}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&g[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+!(g[i][j]); //利用前缀和求出[1~i,1~j]这个矩形的和 
	int ans=-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=1;k<=min(n-i+1,m-j+1);k++) //枚举正方形的边的长度 
			{
				if(!(p[i+k-1][j+k-1]-p[i-1][j+k-1]-p[i+k-1][j-1]+p[i-1][j-1])) //求出[i~i+k-1,j~j+k-1]这个矩形的和 
					 ans=max(ans,k); //判断是否合法，更新答案 
			}
	printf("%d\n",ans);
	return 0;
}
```
### [跑的飞快耶](https://www.luogu.org/record/24178675)


---

## 作者：2x6_81 (赞：7)

### 思路：动态规划
分析：

我们设有2个数组：$a$与$f$

$a$：
```
1 1 1 0
1 1 0 0
1 1 0 0
1 1 1 1
```
我们能知道，每个里头是$1$的至少能形成$1\times1$的正方形

$f$：
```
1 1 1 0
1 1 0 0
1 1 0 0
1 1 1 1
```
我们会发现：有些是很明显能构成正方形的；比如左上角的：$a$数组
```
1 1
1 1
```
则$f$数组会变成：
```
1 1
1 2
```
$f$数组的意思是：以该点为正方形的右下角的点时，可以形成最大的正方形。

所以上面的操作是：发现左，左上与上面都能构成的最大正方形为1，都有1格的空位，则因为这个点是1，使得这个部分可以构成的正方形为$2\times2$的，即$(1+1)\times(1+1)$的

既然这样，我们在dp时就会用到假面这个判断语句：
```
if(a[i-1][j-1]==1&&a[i][j-1]==1&&a[i-1][j]==1) ...
```
简化：（1为真，0为假）
```
if(a[i-1][j-1]&&a[i][j-1]&&a[i-1][j]) ...
```
或者这样：（$\because$ $a$中的最大值为1，所以和的最大值为3，仅当$a_{i-1,j-1}==1 \text{ and } a_{i-1,j}==1 \text{ and } a_{i,j-1}==1$时和为3）
```
if(a[i-1][j-1]+a[i][j-1]+a[i-1][j]==3) ...
```
再举个例子：

$a$：
```
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 0
```
$f$：

①
```
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```
②
```
1 1 1 1
1 0 0 0
0 0 0 0
0 0 0 0
```
根据上面
```
1 1
1 1
```
在$f$中是：
```
1 1
1 2
```
③
```
1 1 1 1
1 2 2 2
1 2 2 2
1 2 2 0
```
等等，$f_{3,3}$不是$3$吗？：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 2 0
```
好，$f_{4,3}$，会发现周围是2个2，1个3，应该选哪一个呢？

如果选3+1，就会有问题：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 4 0
```
发现它的左边不能构成正方形，也就是说这是错误的，所以我们应该选2+1：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 3 0
```
同理，最后$f$数组应该是这样：
```
1 1 1 1
1 2 2 2
1 2 3 3
1 2 3 0
```
转移方程：
```
f[i][j]=(a[i-1][j-1]+a[i][j-1]+a[i-1][j]==3?min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j]):0)+1;
```
当然，当`a[i][j]`为0时，`f[i][j]`也为0，所以特判可以不要：
```
f[i][j]=min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j])+1;
```
最后，注意答案不是`f[n][n]`，而是$f$数组中所有数的最大值

啰嗦了这么多，应该看代码了：
```
#include <iostream>
#include <stdio.h>
#include <cstring>
using namespace std;
#pragma GCC optimize("Ofast")
//快读与快输出
int input()
{
    int re=0; char c=getchar();
    while(c<'0' or c>'9') c=getchar();
    while(c>='0' and c<='9') re=(re<<3)+(re<<1)+(c^48),c=getchar();
    return re;
}
void print(int x)
{
    if(x<10) {putchar(x^48);return;}
    print(x/10);putchar((x%10)^48);
}
const int N=105;
int map[N][N],f[N][N],n,m,ans=-1;
int min(int x,int y){return x<y?x:y;}
int max(int x,int y){return x>y?x:y;}
int main()
{
    n=input(),m=input();
    int x,y;
    for(register int i=1;i<=n;i++)
    for(register int j=1;j<=m;j++)
    map[i][j]=input();
    //分开写让大家理解
    for(register int i=1;i<=n;i++)
    for(register int j=1;j<=m;j++)
    {
    	if(map[i][j]) f[i][j]=min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j])+1;//dp
        ans=max(ans,f[i][j]);//取最大值
    }
    //其实可以写在一起省时间,为了清楚一点,多写几行
    print(ans),puts("");
    return 0;
}

```

---

## 作者：「　」 (赞：5)

##  发现大家都是用动归和搜索，我就来一发前缀和！！！
“前缀和可以是数列，也可以是矩阵。

 以一个小题为例：给定n个数a[i]以及m个询问并每次询问一段区间的和。要求：一个O(n+m)的做法。

要求效率如此之高，看来，强大的树状数组和线段树也无能为力了。

那么如此一来，前缀和上场了。

若想时间复杂度控制在O（n+m），光读一遍就需要O（n），即每一个询问要求效率为O（1），可怕~~

但前缀和可以做到，开两个数组a[n]和s[n]，前者装数据，后者装前n项和。

若想求一段区间[l,r]的和，只需用s[r]-s[l]，即可解决。”————[摘自CSDN博客 前缀和维护](https://blog.csdn.net/whxntj/article/details/54619204)

其实前缀和是一种很方便的东西，所以说本题就可以用前缀和，判定一个正方形是否全是1。

老规矩，首先上变量：
```
int s[105][105];//记录矩阵的数组
int a[105][105];//记录前缀和的数组
int n,m;//记录矩阵的大小
```
由于矩阵是二维的，所以前缀和与一维的不太一样
```cpp
for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	{
		a[i][j]=s[i][j]+a[i][j-1]+a[i-1][j]-a[i-1][j-1];
        //由于a[i-1][j-1]被加了两遍，所以加回去
	}
```
其实就是该位置到左上方点形成的矩阵中1的个数。

然后就可以三重循环遍历了：
```cpp
for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	
		if(s[i][j]!=1)
		continue;//不是1的不用看了
		for(int k=2;i-k>=0&&j-k>=0;++k)
		{
			if(a[i][j]+a[i-k][j-k]-a[i-k][j]-a[i][j-k]==k*k)//关键
            if(k>ans)
			ans=k;
		}
	}
```
关键的，其实就是如何计算正方形中1的个数了，这里要注意：因为计算一个矩阵1的个数时，可能会有些问题：

0 **1 1** 1  
1 **1 1** 0  
0 1 1 0  
1 1 0 1（矩阵）

比如计算加粗体的正方形的1的个数

0 0 0 0 0  
0 0 **1 2** 3  
0 1 **3 5** 6  
0 1 4 7 8  
0 2 6 9 11（前缀和）

大家可能会以为是1+5-2-3=1，很明显不对，其实是1 * 1的矩阵（在5所在的位置）的1的个数

但其实这样的：

0 **0** 0 **0** 0  
0 0 1 2 3  
0 **1** 3 **5** 6  
0 1 4 7 8  
0 2 6 9 11（前缀和）

是0+5-0-1=4，就正确了，就是右下角的所在行列分别减去正方形的边长，再一起减去正方形的边长（就像这样a[i][j]+a[i-k][j-k]-a[i-k][j]-a[i][j-k]）就是计算正方形1个数所需的4个点

但很明显，这样的3重循环是会超时的，所以就需要判重：
```cpp
for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	{
		if(s[i][j]!=1)
		continue;
		for(int k=ans+1/*直接遍历比当前答案大的数*/;i-k>=0&&j-k>=0;++k)
		{
			if(a[i][j]+a[i-k][j-k]-a[i-k][j]-a[i][j-k]==k*k)
			ans=k;
			else
			break;
            //如果小的正方形不行了，比他大的但有包含它的正方形肯定不行
		}
	}
```
最后将程序拼凑在一起加上必要的输入输出，就可以ac了

---

## 作者：sqrt（3B） (赞：4)

## 先凑点字数
# 首先这一看就是棋盘型DP
棋盘上的DP往往都是向四个相邻块扩展；
这个也一样；

从左上到右下，

每次靠左，左上，上三块可以形成的最大正方形中的最小的那个更新当前点

就像这个样子

![源样例](https://cdn.luogu.com.cn/upload/pic/21148.png)

***

```cpp
#include<bits/stdc++.h>
using namespace std; 
int n,m,juzhen[102][102],maxx=-1; //蒟蒻英语 
int main() 
{ 
	scanf("%d%d",&n,&m); 
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j) 
    scanf("%d",&juzhen[i][j]); 
//因为只需要调用左上左上，直接在原数组里操作（dp空间能省一点算一点） 	 	for(int i=1;i<=n;++i)
   for(int j=1;j<=m;++j) 
   { 
   	if(juzhen[i][j]==0)continue;//正方形不可能有零的直接con掉啦 
    juzhen[i][j]+=
    	min(min(juzhen[i-1][j],juzhen[i-1][j-1]),juzhen[i][j-1]);
        maxx=max(juzhen[i][j],maxx); }
    //同时记录，省循环，（dp时间能省一点算一点^-^大概是废话吧）
    printf("%d",maxx); return 0; }


```

### DP一入深似海，从此记搜是友人

---

## 作者：谁是鸽王 (赞：3)

#### [传送门](https://www.luogu.org/problemnew/show/P1387)

#### 搞不清楚为什么这一题要DP . . . . . .

思路：
- $n\le100$，考虑暴力。
- 要求一大块区间内都是1，考虑前缀和。
- 在矩阵中求一个符合条件的子矩阵，考虑$n^3$的“压行”做法。

具体实现:
- 读入时，先记录每一层的前缀和，再把上一次的前缀和加进来。
- $n^2$枚举正方形的上界和下界，顶着上界下界$O(n)$扫描记录答案。
- 若当前的上界下界的距离$\le ans$跳过

直接上代码。用了宏定义和快读，但很好理解，初学者都能一眼就懂..

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdlib>
#include<vector>
#include<set>
#include<map>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<bitset>
#include<ctime>
using namespace std;


#define TMP template < class ins >
#define endl '\n'
#define RP(t,a,b) for(register int t=(a),edd=(b);t<=edd;t++)
#define ERP(t,a) for(register int t=head[(a)];t;t=e[t].nx)
#define DRP(t,a,b) for(register int t=(a),edd=(b);t>=edd;t--)
typedef long long ll;


TMP inline ins qr(ins tag){
    char c=getchar();
    ins x=0;
    int q=0;
    while(c<48||c>57)
	q=c==45?-1:q,c=getchar();
    while(c>=48&&c<=57)
	x=x*10+c-48,c=getchar();
    return q==-1?-x:x;
}
const int maxn=105;
int data[maxn][maxn];
int sum[maxn][maxn];
int n,m;
int ans;


inline void init(){
    n=qr(1);
    m=qr(1);
    RP(t,1,n){
	RP(i,1,m)
	    sum[t][i]=(data[t][i]=qr(1))+sum[t][i-1];
	//记录当前行前缀和
	RP(i,1,m)
	    sum[t][i]+=sum[t-1][i];
	//把上一行前缀和加进来
    }
    return;
}


inline bool jde(int x1,int y1,int x2,int y2){
    int cmp=(abs(x1-x2)+1)*(abs(y1-y2)+1);
    //计算面积
    int sttd=sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
    //(x1-1,y1-1)到(1,1)的矩阵被减了两次，要补偿回来
    return cmp==sttd;
}


inline void eff(){
    RP(t1,1,n){//枚举上界
	RP(t2,t1,n){//枚举下界
	    int k=t2-t1+1;
	    //计算当前上下界对应的正方形大小
	    if(k<=ans)
		continue;
	    //最优性剪枝
	    RP(t,k,m)//扫描一遍，
		if(jde(t1,t-k+1,t2,t)){
		    ans=k;break;
		    //可以直接记录答案，因为前面已经最优性剪枝了
		}
	}
    }
    cout<<ans<<endl;
}

int main(){
#define debugged
#ifdef debug
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    init();
    eff();
    return 0;
}

```

---

## 作者：L_OnceL (赞：3)

一看就是动规(Dynamic Programming)嘛，，，

实际上，本题有多种解法，首先是朴素(~~暴力~~)解法，这个算法的复杂度为$n^5$  ,所以根本不需要去考虑它。

第二种就是使用矩阵前缀和再枚举边长求解，时间复杂度为$O(n^3)$ ,如果将枚举改成二分枚举，可以将其时间复杂度优化到$O(n^2*logn)$ , 但由于数据比较水，所以一定不会TLE，因此我刚写此题时首先就想到了这个方法。

但是首先想到的方法好像没有动规啊？接下来就是我们要写出的最优的解法，也就是多维动规，这种方法的时间复杂度是最小的，只有$O(n^2)$ 。但是这种方法相较于第二种方法来说需要一些推导。

首先我们思考一个问题：如果要形成一个正方形，需要什么条件呢？

毋庸置疑，在本题中，要形成一个正方形，0是肯定不能出现的，**只要有一个0,那么0以及它周边的一切都是不能构成一个正方形的**。

我们观察一下下面的表

|   (1，1)    |   (1，2)   |   (1，3)   |
| :---------: | :--------: | :--------: |
| **(2，1)**  | **(2，2)** | **(2，3)** |
| **(3 ，1)** | **(3，2)** | **(3，3)** |



如果我们想让构成这样的一个$3\times3$的正方形，那么一定有必要条件：除了第一排和第一列，每个点和它左，左上，上三个点都必须是1。
于是我们开始考虑本题的状态转移方程，一定是与三个条件都满足，而我们动规数组中存的就是边数，所以要使其全部满足，一定要是取最小值

由此我们得到动规方程： $$S_{i,j}=min(S_{i-1,j},S_{i-1,j-1},S_{i,j-1})+1$$ 

我们的推导初步认为是没有问题的，那么就得出我们代码：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 101;

int a[maxn][maxn];//存图
int s[maxn][maxn];//存边
int n,m,ans = -233;

int main() {
	scanf("%d%d",&n,&m);

	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			scanf("%d",&a[i][j]);

	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(a[i][j] == 1) {
				s[i][j] = min(min(s[i-1][j],s[i][j-1]),s[i-1][j-1])+1;
			}
		}
	}
	//cout<<endl;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(s[i][j]>ans) ans = s[i][j];
			//printf("%d ",s[i][j]);
		}
		//cout<<endl;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：spacetime (赞：3)

方法一：爆搜，O(n^5)（数据水，略加优化可过）

方法二：二维前缀和+爆搜，O(n^3)（可优化）

方法三：DP，O(n^2)

方法一、三的程序前面都有了，我就写个方法二的吧：

```cpp

#include<cstdio>
#include<cstring>
#define REP(I,start,end) for(int I=start;I<=end;I++)
#define PER(I,start,end) for(int I=start;I>=end;I--)
using namespace std;
int n,m,s[101][101];
int main()
{
    scanf("%d%d",&n,&m);
    memset(s,0,sizeof(s));
    REP(i,1,n)
    {
        REP(j,1,m)
        {
            int t;
            scanf("%d",&t);
            s[i][j]=s[i][j-1]+t;//一维前缀和线性维护
        }
        REP(j,1,m)
            s[i][j]+=s[i-1][j];//二维前缀和矩形维护
    }
    PER(k,n,1)//枚举最大值
    {
        int m=k*k;
        REP(i,1,n-k+1)
            REP(j,1,n-k+1)
                if(s[i+k-1][j+k-1]-s[i+k-1][j-1]-s[i-1][j+k-1]+s[i-1][j-1]==m)//条件符合退出
                {
                    printf("%d\n",k);
                    return 0;
                }
    }
    puts("0");
    return 0;
}

```

---

## 作者：Porsche (赞：3)

今天讲DP，学长说，看到一道DP题首先要想到：“哦吼，这是一道DP题”，可是不行的我看到了一道D题，却想到：“~~去你妈的~~，这分明是一道贪心题”，然后学长：“那你去贪挖，贪出来了我吃*”，最后，学长：“真香~”。

不多扯了，现在要开始讲了。

这道题是要求一个最大的正方形，我们不妨设一个前缀和数组，Map[i][j]存储的是第i行第j位左上方所有数的和（包含自己），即存储了前面1的数量，然后每一次用Map[i+sum][j+sum]-Map[i+sum][j-1]-Map[i-1][j+sum]+Map[i-1][j-1],如果这个值恰好等于该正方形边长，则这是一个正方形，每一次的值取max就可以了，如果不理解可以看下面的图↓

![图例](http://i1.bvimg.com/673208/0d44775953b1bed3.png)

要是还是不理解，看代码好了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int Map[5001][5001],Mapl[5001][5001],Maph[5001][5001];//建立三个数组，分别存储左上，正左边，正上方1的个数
int ans=1;
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&Map[i][j]);
            Mapl[i][j]=Map[i][j]+Mapl[i-1][j];
            Maph[i][j]=Maph[i][j-1]+Map[i][j];
            Map[i][j]+=Mapl[i-1][j]+Maph[i][j-1]+Map[i-1][j-1];
        }//输入并且预处理
    int sum;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            sum=0;
            while(1)
            {
                sum++;
                if(i+sum>n||j+sum>m||Map[i+sum][j+sum]-Map[i+sum][j-1]-Map[i-1][j+sum]+Map[i-1][j-1]!=(sum+1)*(sum+1))break;//判断是否是一个正方形
                ans=max(ans,sum+1);
            }//以Map[i][j]魏左上角从小到大枚举正方形
        }
    printf("%d",ans);
    return 0;
}
```
希望大家能喜欢这个贪心思想，还有不明白的可以私我~

---

## 作者：rpg123 (赞：2)

我实在是看不出来为什么是动归（应该是我太弱了吧）但是我
有一种个人认为更好的方法：

通过我的找规律，我发现一个边长2的正方形是由四个相邻边长1的小正方形组成，而一个边长3的正方形是由四个左上顶点相邻的边长为2的正方形组成。（如图）
```
1 1 1
1 1 1
1 1 1
=
1 1
1 1  （顶点为（1，1））

+
  1 1
  1 1（顶点为（1，2））

+

1 1  （顶点为（2，1））
1 1
+

  1 1（顶点为（2，2））
  1 1
```
边长为n的同理

于是，就可以多重循环，第n重循环结束后，将a数组中边长为n+1的正方形的左上角顶点改为true
```
var
  a,b,c:array[1..200,1..200]of boolean;//必须开两倍大
  n,m,i,j,x,s:longint;
  t:boolean;
begin
  readln(n,m);
  for i:=1 to n do
    for j:=1 to m do
    begin
      read(x);
      if x=1 then
        a[i,j]:=true else//给a数组赋初值
        a[i,j]:=false;
    end;
  while true do
  begin
    for i:=1 to n do
      for j:=1 to m do
        if a[i,j]and a[i+1,j] and a[i,j+1]and a[i+1,j+1] then//相邻的四个小正方形顶点=大正方形
        begin
          b[i,j]:=true;//b数组：临时数组，存储大正方形顶点
          t:=true;
        end;
    a:=b;//更新a数组
    b:=c;//c数组：归零数组，给b数组归零
    inc(s);
    if not t then//没有更大的正方形就结束
    begin
      writeln(s);
      halt;
    end;
    t:=false;
  end;
end.
```
由于我很弱，难免有误，如有错误，欢迎指教

---

## 作者：顾z (赞：2)

~~并没有发现悬线法啊 管理员夶为啥不给过啊！！！~~

**广告**  [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题目大意**

给定一个01棋盘,求其中全为1的最大正方形边长。

**分析:**

发现题解没有用悬线法的 所以介绍一下~~尝试水一篇题解~~

以下内容部分参考[@Clove_unique](https://blog.csdn.net/Clove_unique/article/details/50512624)

**悬线法**

	用途:
  	 解决给定矩阵中满足条件的最大子矩阵
	做法:
   	用一条线(横竖貌似都行)左右移动直到不满足约束条件或者到达边界
 	定义几个东西:
        left[i][j]:代表从(i,j)能到达的最左位置
        right[i][j]:代表从(i,j)能到达的最右位置
        up[i][j]:代表从(i,j)向上扩展最长长度.
	这里给出递推公式：
       left[i][j]=max(left[i][j],left[i-1][j]
       right[i][j]=min(right[i][j],right[i-1][j]
至于为什么递推公式中考虑上一层的情况？

是因为up数组的定义,up数组代表向上扩展最长长度, 所以需要考虑上一层的情况.而我们要考虑上一层的情况的话,需要考虑左右边界问题,因此递推公式中分别取max与min即可。

然后我们去利用dp方程去求解即可.

------------------代码--------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define N 108
IL void read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int left[N][N],right[N][N],up[N][N];
int res[N][N],n,m,ans;
int main()
{
	read(n),read(m);
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
		{
			read(res[i][j]);
			left[i][j]=right[i][j]=j;
			up[i][j]=1;
		}
	for(RI i=1;i<=n;i++)
		for(RI j=2;j<=m;j++)
			if(res[i][j]==1&&res[i][j-1]==1)
				left[i][j]=left[i][j-1];//预处理左边界
	for(RI i=1;i<=n;i++)
		for(RI j=m-1;j>0;j--)
			if(res[i][j]==1&&res[i][j+1]==1)
				right[i][j]=right[i][j+1];//预处理右边界
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
		{
			if(i>1&&res[i][j]==1&&res[i-1][j]==1)
			{
				left[i][j]=std::max(left[i][j],left[i-1][j]);
				right[i][j]=std::min(right[i][j],right[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
			int a=right[i][j]-left[i][j]+1;
			int b=std::min(a,up[i][j]);
			ans=std::max(ans,b);
		}
	printf("%d",ans);
}
```

悬线法题目:[P1169 棋盘制作](https://www.luogu.org/problemnew/show/P1169)   [p4147 玉蟾宫](https://www.luogu.org/problemnew/show/P4147)   [p2701 巨大的牛棚](https://www.luogu.org/problemnew/show/P2701)   [p1387 最大正方形](https://www.luogu.org/problemnew/show/P1387)

---

## 作者：Acolasian (赞：2)

既然下面的dalao大都用了动规，那我就写一下二分吧。


首先求一下前缀和，这样在二分时判是否可行时可以O(1)。


枚举左上顶点，如果左上顶点为0，直接跳过。


二分求以(i,j)为左上顶点的正方形的边长，则二分时R上界为min(n-i+1,m-j+1)，用前缀和求出此区域内的数的总和，如果等于边长的平方，则可行，调L为mid；否则调R为mid，二分结束后可行边长的最大值即L的值，每次打擂台取L和ans的最大值即可。


时间复杂度为O(n\*n\*logn)，比动规慢不了多少（滑稽）。


下面附上AC代码：


```cpp
#include<bits/stdc++.h>
#define N 105
using namespace std;
int n,m,maz[N][N],qz[N][N],ans;
inline bool check(int x,int y,int len)
{
    int xx=x+len-1,yy=y+len-1;
    if(qz[xx][yy]-qz[x-1][yy]-qz[xx][y-1]+qz[x-1][y-1]==len*len)return 1;
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            scanf("%d",&maz[i][j]);
            qz[i][j]=qz[i-1][j]+qz[i][j-1]-qz[i-1][j-1]+maz[i][j];
        }
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            if(!maz[i][j])continue;
            int d=min(n-i+1,m-j+1);
            int l=1,r=d+1,mid;
            while(l+1<r)
            {
                mid=(l+r)>>1;
                if(check(i,j,mid))l=mid;
                else r=mid;
            }
            ans=max(ans,l);
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ChoHakuNe (赞：2)

老实用dp的我...

**f[i,j]表示以(i,j)为右下角的最大正方形**

**状态转移方程为f[i,j]=min(f[i-1,j-1],f[i-1,j],f[i,j-1])，且a[i,j]不为0**

当这个(不为0的)点左边、上边、左上的点**均能**构成边长为x的正方形时，再加上这个点就可以构成边长为x+1的正方形了

```cpp
program jz;
uses math;//调用math库，就能直接用min函数了
var a:array[1..100,1..100] of integer;
    f:array[0..100,0..100] of integer;
    n,m,i,j,max:integer;
begin
 read(n,m);
 for i:=1 to n do
  for j:=1 to m do
   begin
    read(a[i,j]);
    if a[i,j]=0 then continue;//这个点是0直接不考虑
    f[i,j]:=min(min(f[i-1,j-1],f[i,j-1]),f[i-1,j])+1;//状态转移方程
    if f[i,j]>max then max:=f[i,j];//顺便找答案
   end;
 write(max);
end.
```

---

## 作者：贽殿 (赞：2)

看题解里貌似没有二分，于是打了一个二分查找的代码，还挺快的，20ms。用二分枚举正方形边长，再进行判断
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,lu,ru,mid,searchh=1;
int areas[100][100];//存图
int checked(int p,int q,int leng){
    for(int x=p;x<leng+p;x++){
		for(int y=q;y<leng+q;y++){
			if(areas[x][y]==0){
				searchh=0;
				return 0;
			}
		}
	}
}//检索正方形里是否有0

int hehe(){
	for(int i=0;i+mid<n;i++){
		for(int j=0;j+mid<m;j++){
			if(areas[i][j]==1){
				searchh=1;
				checked(i,j,mid);
				if(searchh==1)return 1;
			}
		}
	}
	return 0;	
}//无视此处函数名。。。此函数用于枚举所有边长为mid的正方形

int main(){
	cin>>n>>m;
	bool check=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>areas[i][j];
			if(check==0&&areas[i][j]==1){
				check=1;
			}
		}
	}
	if(check==0){
		cout<<"0";
		return 0;
	}//全部是0的特判，~~貌似没啥用~~


	lu=1;ru=min(n,m);
	while(lu<ru-1){
		mid=(lu+ru)/2;
		if(hehe())lu=mid;
		else ru=mid;
	}
	cout<<lu;
	return 0;
}
```

---

## 作者：HHCY (赞：1)



```cpp
//c++代码
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int n,m,s[102][102],w[102][102],f[102][102],ans;
int b[102][102];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>b[i][j];//读入
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(b[i][j])
    {
            s[i][j]=1+s[i-1][j];//s i.j表示从点i , j向上连续几个1
           w[i][j]=1+w[i][j-1];//w i.j表示从点i , j向上连续几个1
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(b[i][j])
    f[i][j]=min(min(s[i][j],w[i][j]),f[i-1][j-1]+1);//状态转移方程 ; f i , j 表示以点 i , j 为正方形的右下角得到的最大边长
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    ans=max(ans,f[i][j]);//比较每一个点
    printf("%d",ans);
    return 0;
}
```

---

## 作者：doby (赞：1)

其实很简单的……

dp很好写，暴力似乎也可以过……

状态转移方程：f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1

```cpp
#include<iostream>
using namespace std;
int a[105][105]={{0}},f[105][105]={{0}},n,m,maxb=1;
int minn(int a,int b)
{
    if(a<b){return a;}
    else{return b;}
}
int minnn(int a,int b,int c)
{
    return minn(minn(a,b),c);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cin>>a[i][j];}}
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]==0){continue;}
            f[i][j]=minnn(f[i-1][j],f[i][j-1],f[i-1][j-1])+1;
        }
    }
    for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){if(f[i][j]>maxb){maxb=f[i][j];}}}
    cout<<maxb;
}
```

---

## 作者：hfctf0210 (赞：1)

这道题数据量小，爆搜都可以过了（5重循环，我试了可以AC），但是要多加优化！！！

核心代码：（其中都是0的情况在主程序中已处理，最小都是1）

```cpp
int search()
{
int k,x,y,i,j,f;
for(k=min(n,m);k>=2;k--)//穷举长度，如果2都不行就是1了
{
for(x=1;x<=n-k+1;x++)//穷举第一行
for(y=1;y<=m-k+1;y++)//穷举第一列
{
f=1;//做标记
for(i=x;i<x+k;i++)//枚举横坐标
{
for(j=y;j<y+k;j++)//枚举纵坐标
if(!a[i][j]){f=0;break;}//如果发现格子为0就提前结束
if(!f)break;//****不是全1的提前结束穷举，否则可能会超时
}//end for i
if(f)return k;//如果矩阵里全是1就可以返回k的值，提前结束了
}//end for x、for y
}//end for k
return 1;//min(n,m)~2都不行就一定是1
}//注意：*****如果穷举k=1，x、y就会穷举n^2遍，再加上i、j的判断，可能会超时
```

---

## 作者：Mr_Li (赞：1)

这道题就是求子矩阵和，若一个01矩阵中的正方形和等于正方形大小，那么这个正方形就是不包含0的正方形，输出最大的那一个。

矩阵a的某一个子矩阵和求法：

1.求矩阵a中的第i行第1个数到第j个数的和，将其记录在矩阵b[i][j]中；

2.求矩阵b中的第j列第1个数到第i个数的和，将其记录在矩阵c[i][j]中，此时矩阵c[i][j]表示一个矩阵a中左上角是第一行第一列，右下角是第i行第j列的子矩阵和；

3.c[x1][y1]-c[x2-1][y1]-c[x1][y2-1]+c[x2-1][y2-1]即为所求（左上角是第x2行第y2列，右下角是第x1行第y1列）。


---

## 作者：w12144 (赞：1)

嗯。没看到和我思路一样的，我就说一下自己的思路，我自己觉得应该是很容易理解的。方法有点像暴力加上动态规划，dp[a][b][c]代表左上顶点坐标(a,b)边长c的正方形区域是不是正方形，若是则为1，不是为0。观察规律可以很容易发现，如果一个区域是正方形那么它的左上，右上，左下，右下，这四个区域一定也是正方形。
不知道为什么插不了图片，比如\
1 1 1\
1 1 1\
1 1 1\
那么（1，1）-（2，2）|（1，2）-（2，3）|（2，1）-（3，2）|（2，2）-（3，3）\
这四个区域一定是正方形，于是就可以得到状态转移方程:\
dp[i][j][len] = 1 if dp[i][j][k]==1 && dp[i + len - k][j][k]==1 && dp[i][j + len - k][k]==1 && dp[i + len - k][j + len - k][k]==1\
k是小正方形的边长，k取值多少无所谓，只要能够覆盖整个大的正方形就可以了，我这里取得是大正方形一半向上取整。\
```
#include <iostream>
#include<cstdio>
#include <algorithm>
using namespace std;
int n, m;
int dp[105][105][105];//dp[a][b][c]，左上(a,b)边长c,是不是正方形
int main() {
	cin >> n >> m;
	int maxn = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &dp[i][j][1]);
	int l = min(n, m);//正方形的最大边长
	for (int len = 2; len <= l; len++) {//遍历所有边长
		for (int i = 1; i + len - 1 <= n; i++) {//遍历所有左上顶点
			for (int j = 1; j + len - 1 <= m; j++) {
				int k = len + 1 >> 1;//一半边长
				if (dp[i][j][k] && dp[i + len - k][j][k] && dp[i][j + len - k][k] && dp[i + len - k][j + len - k][k])
					dp[i][j][len] = 1,maxn=max(maxn,len);
			}
		}
	}
	cout << maxn << endl;
	return 0;
}

```


---

## 作者：往事一杯酒 (赞：1)

~~这题
有点水~~

7分钟代码时间然后1次就过了emm

思路很简单
预处理当前节点左边有多少连续的1
上面有多少连续的1

dp过程：
f[i][j]=min(f[i-1][j-1]+1,min(l[i][j],u[i][j]))

解释一下
f[i][j]是(i,j)处正方形的最大边长

l[i][j]是当前节点左边有多少连续的1(left的简写~~啦啦啦~~）

同理，u[i][j]是当前节点上面有多少连续的1(up的简写~~啦啦啦~~）


给组数据看看

1 1 1

0 1 1 

1 1 1 

对于（3,3）

左上（2,2）的最大正方形边长为1，如果继承这个正方形，最多（注意是最多）只能继承它的边长+1

（不然左上那个点就无能为力了）

然后还要确定当前这个节点是否可以完全继承左上的正方形//l[i][j],u[i][j])

如果不行的话那也只能放弃左上那个正方形的一部分

（不然当前这个点就无能为力了）

因为这里的动归目测是线性的

所以可以保证其正确性

然后记得要特判左上没有正方形的情况

来来来放代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a[101][101],l[101][101],u[101][101],f[101][101],maxn=-1;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j])
			{
				l[i][j]=l[i][j-1]+1;
				u[i][j]=u[i-1][j]+1;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]) 
			{
				f[i][j]=min(f[i-1][j-1]+1,min(l[i][j],u[i][j]));
				f[i][j]=max(1,f[i][j]);
			}
			maxn=max(maxn,f[i][j]);
		}
	}
	printf("%d",maxn);
}
```


---

## 作者：咯咯咯 (赞：1)

看到楼上大佬这么多n^2算法 

我这里提供一个不一样的

~~实际上就是求极大子矩形问题~~

~~显然~~我们知道极大正方形一定在极大矩形内

在这里我先引进悬线

对于一个点它的悬线就是让他向上延伸能到达的最大高度

可以证明的是每一个极大子矩形一定包含至少一条悬线

那么我们就枚举悬线

同时我们求出对于这条悬线向左和向右的最大延伸长度

由于点最多n^2个 

悬线最多就n^2个

所以复杂度也是O（n^2）

a[i][j]表示的是这个点

L[i][j]和R[i][j]和H[i][j] 分别表示向左、右、上的最大延伸长度所到达的点

L[i][j]=max(L[i][j],L[i-1][j])

然后我们可以发现L[i][j] 和L[i-1][j]之间的递推关系
R[i][j]同理

R[i][j]=min(R[i][j].R[i-1][j])

得到了极大子矩形后我们就可以轻松求出极大正方形了

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Ford(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
int n,m;
int a[110][110],L[110][110],R[110][110],H[110][110];
int main()
{
	scanf("%d%d",&n,&m);
	For(i,1,n)
	{
		For(j,1,m) scanf("%d",&a[i][j]);
		For(j,1,m) L[i][j]=a[i][j-1]==1?L[i][j-1]:j; // 往左延伸
		Ford(j,m,1) R[i][j]=a[i][j+1]==1?R[i][j+1]:j; // 往右延伸
		For(j,1,m) H[i][j]=a[i-1][j]==1?H[i-1][j]:i; 
	}
	int ans=0;
	For(i,1,n)
	{
		For(j,1,m)
		{
			if (a[i][j]==0) continue;
			if (H[i][j]<i) L[i][j]=max(L[i-1][j],L[i][j]),R[i][j]=min(R[i-1][j],R[i][j]);
			int a=i-H[i][j]+1;
			int b=R[i][j]-L[i][j]+1;
			ans=max(ans,min(a,b));
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Khan_ (赞：1)

这道题貌似和P2733有点像...（一份代码双份喜悦），其实只要改一下就好了...

P2733的题解在博客哦[洛谷P2733【家的范围】](https://www.luogu.org/blog/SKDreamKhan/solution-p2733)

标程如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAX=105;
const int INF=0X3F3F3F3F;
int n,m;
int ans;
int map[MAX][MAX];
int f[MAX][MAX];//表示以map[i][j]为右下角的矩阵的最大值 
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    	for(int j=0;j<m;j++)
    		scanf("%d",&map[i][j]);
    /*---考虑边界情况---*/ 
    for(int i=0;i<n;i++)
    f[i][0]=map[i][0];
    for(int j=0;j<n;j++)
    f[0][j]=map[0][j];
    /*---全矩阵扫进行DP---*/
    for(int i=1;i<n;i++)
        for(int j=1;j<m;j++)
        if(map[i][j])//当前这个点不是障碍
        {
            f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
            ans=max(ans,f[i][j]);
        }
    cout<<ans;    
}
```

---

## 作者：yzher (赞：1)

关键字：**暴力！！！！！！**

本来准备正常用动归完成，然而数据弱到爆（100……）果断\_前缀和\_+\_暴力枚举矩阵\_

其实三重循环就可以解决，正方形起始坐标+边长

~~没有什么是暴力解决不了的，如果有，也只能说明你还是naive，不懂编程的精髓~~

~~万物皆暴力！！！~~

```cpp
#include<iostream>
#include<algorithm>
int n,m,ans = 0,f[150][150],a[150][150];
using namespace std;
int main()
{
    ios::sync_with_stdio(false);            //输入输出优化 
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    f[1][1] = a[1][1];                        //求前缀和 
    for (int i = 2; i <= n; i++)
        f[i][1] = f[i-1][1]+a[i][1];
    for (int i = 2; i <= m; i++)
        f[1][i] = f[1][i-1]+a[1][i];
    for (int i = 2; i <= n; i++)
          for (int j = 2; j <= m; j++) 
            f[i][j] = f[i][j-1] + f[i-1][j] + a[i][j] - f[i-1][j-1];
    /*for (int i = 1; i <= n; i++)         检查前缀和 
    {
        for (int j = 1; j <= m; j++)
            cout << f[i][j] << " ";
        cout<<endl;
    }*/
    for (int i = 1; i <= n; i++)            //暴力求极值，和ans比较 
        for (int j = 1; j <= m; j++)
            for (int x = 0; x <= min(n-i,m-j); x++)
                    if (f[i+x][j+x]+f[i-1][j-1]-f[i-1][j+x]-f[i+x][j-1]==(x+1)*(x+1))
                            ans = max(x+1,ans);
                    else break;
    cout << ans;        
}
```

---

## 作者：chinesesien (赞：1)

看起来数据是有点水的


其实判断正方形，只要判断范围内“1”的个数是否等于边长的平方即可

而且显然每个边长大于等于3的正方形内必然可以再画出更小的正方形

那么我们就暴力判断以(x,y)为左上顶点的正方形边长长度

同时传递边长最小值

(明明就是暴力好伐)

'''cpp





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,mmp[103][103],q[103][103],ans=-1;
void s(int x,int y,int l){
    int sum=0;
    if(l>min(n-x+1,m-y+1)){
        q[x][y]=l-1;
        return;
    }
    for(int i=x;i<x+l;i++){
        for(int j=y;j<y+l;j++){
            q[i][j]=max(0,max(q[i-1][j],max(q[i][j-1],q[i-1][j-1]))-1);
            sum+=mmp[i][j];
        }
    }
    if(sum==l*l){
        s(x,y,l+1);
    }
    else{
        q[x][y]=l-1;
        return;
    }
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&mmp[i][j]);
            q[i][j]=0;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            s(i,j,q[i][j]+1);
            ans=max(ans,q[i][j]);
        }
    }
    printf("%d",ans);
    return 0;
}
'''
```

---

## 作者：EricWay1024 (赞：0)

甚矣，我之不慧！

dp[i][j]：在i*j 的矩形里的最大正方形边长是多少。

状态转移：

- 如果a[i][j]=0，dp[i][j]=max(dp[i-1][j], dp[i][j-1])
- 如果a[i][j]=1，先取一下t=dp[i-1][j]。两种情况，要么是t（构不成正方形），要么是t+1（构成正方形）。

但是显然我判断是否构成正方形的复杂度偏高。


```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
bool a[200][200];
int dp[200][200];
int main(){

	int m, n;
	cin>>n>>m;
	for (int i=1; i<=n; i++){
		for (int j=1; j<=m; j++){
			cin>>a[i][j];
		}
	}
	
	for (int i=1; i<=n; i++){
		for (int j=1; j<=m; j++){
			if (a[i][j]==0){
				dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
			} else{
				
				int t=dp[i][j-1];
				bool ok = true;
				t++;
				if (i-t<0 || j-t<0 ) ok=false;
				else for (int x=0; x<t; x++){
					for (int y=0; y<t; y++){
						if (x==0 && y==0) continue;
						if (a[i-x][j-y]!=1) {
							ok=false; break;
						}
					}
				}
				if (ok) dp[i][j]=t;
				else dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
			
			}
		}
	}

	cout<<dp[n][m]<<endl;
	
}
```



---

## 作者：lamboo (赞：0)

题目分析：

本题方法非常多：

可以用搜索；可以用二分枚举边长；甚至可以不用二分直接枚举

在这里，我给大家讲一下动态规划的解法

本题采用动态规划的解法是最高效的

而且从代码长度来说，也是最短的

时间复杂度为O（n\*m），可以过1000\*1000的数据

如果其他方法这么大过不了，会超时

算法描述：

以当前这个点为右下角和它的左边、上面和左上三个方向有关

假设当前这个点的坐标为（x，y）

那么它所形成的最大长方形与（x-1，y），（x，y-1），（x-1,y-1）有关

动态规划方程式 f[i,j]:=min(f[i-1,j],f[i-1,j-1],f[i,j-1])+1;

限制条件（当前这个坐标值为1）

这个方程式在程序中会有体现

min(f[i-1,j],f[i-1,j-1],f[i,j-1])表示和它有关的最小的正方形

如果当前坐标值为1的话，那么便可以新成为一个原边长+1的正方形

1 1 1
1 1 1
1 1 1
最右下角的1关联的点已经包含了剩下的8个点

如果当前为1的话，就说明边长可以增加1

如果大家不是很好理解这个的话

我们把样例中的每个点为右下角所形成的正方形给求一遍

样例
4 4
0 1 1 1

1 1 1 0

0 1 1 0

1 1 0 1

值：
0 1 1 1

1 1 2 0

0 1 2 0

1 1 0 1

我们便可以很清楚的发现这个规律

程序解说：

```cpp
var n,m,i,j,max:longint;
    a,f:array[0..1000,0..1000] of longint;   //a数组存放矩阵，f数组存放以当前坐标点为正方形右下角的最大正方形边长
function min(x,y,z:longint):longint;  //求三个数里最小的
begin
min:=x;
if y<min then min:=y;
if z<min then min:=z;
end;
begin
readln(n,m);
for i:=1 to n do
  for j:=1 to m do read(a[i,j]);
for i:=1 to n do
  for j:=1 to m do
    begin
    if a[i,j]<>0 then f[i,j]:=min(f[i-1,j],f[i-1,j-1],f[i,j-1])+1;
    //如果当前的点为1，那么就可以用我们的方程式求出以它为右下角所形成的最大正方形的边长
    if f[i,j]>max then max:=f[i,j];
    //保存最大的边长
    end;
writeln(max);
end.
```
注：我看到楼下的大佬们大多数用的是C++，那我就发个Pascal的吧
如果题解写的不好，请多多包涵


---

## 作者：不需要黄桃 (赞：0)

经过思考的dp..

一开始想的是以每个点作为根节点

通过判此点向右向下扩展的三个点

形成由左上角扩展出来的正方形，并最终取子节点扩展出的最小正方形，再将边长加一，这样可以形成一个完整的更大的正方形

再想要逆推的话应当从右下角开始处理

于是发现需要读入后离线处理，稍微有点慢..

想到从左上角读入，恍然大悟

可以搜从右下角扩展出来的，从而从左上角开始处理，读入时在线处理。

转移方程f[i][j]=min(f[i-1][j],f[i-1][j-1],f[i][j-1])+1

以及注意初始化！

代码如下

···
```cpp
#include<cstdio>
#include<iomanip>
#include<algorithm>
using namespace std;
int n,m,maxle[105][105],ans=0;//maxle表示由该点可扩展出来的正方形的最大边长
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,a;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&a);
            if(!a)
                maxle[i][j]=0;
            else if(i==1||j==1)
                {maxle[i][j]=1;if(!ans)ans=1;}
            else
            {
                int p=101;
                p=min(maxle[i-1][j],p);
                p=min(maxle[i-1][j-1],p);
                p=min(maxle[i][j-1],p);
                maxle[i][j]=p+1;
                ans=max(ans,maxle[i][j]);
            }
        }
    printf("%d",ans);
    return 0;
}
```
···

---

## 作者：panzheng1999 (赞：0)

数据有些弱，虽然是练动规，但是还是说说更“傻又暴力的”做法吧233：

a数组记录一下前缀和，记录1的个数

枚举起点和终点，其中区间和若是和方形面积相同便合法（只需枚举边长，也就是右下的点作终点）。

看注释吧


        
            
```cpp
#include <iostream>
using namespace std;
int n,m;
int a[105][105];
int ans;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int temp;
            cin>>temp;
            a[i][j]=a[i][j-1]+a[i-1][j]-a[i-1][j-1]+temp;//建立前缀和a数组
        }
        /*for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
                cout<<a[i][j]<<" ";
            cout<<endl;
        }*/
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)//枚举起点
            for(int l=0;i+l<=n&&j+l<=m;l++)//枚举边长(l+1)
                {
                    int num=0;
                    num=a[i+l][j+l]-a[i+l][j-1]-a[i-1][j+l]+a[i-1][j-1];
                    if(num==(l+1)*(l+1))//其中全为1
                                             ans=max(ans,l+1);
                }
   cout<<ans<<endl;
}

```

---

## 作者：骑着肥猪飙 (赞：0)

完全可以n^2过

dp[i][j]表示以(i,j)为右下角的最大正方形边长

分两种情况

1.当前位置为1，则左，左上，上中选一个最小值（画图就明白了），再加1;

2.当前位置为0，则dp数组为0；

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int dp[2001][2001],a[2001][2001],n,m,ans=-1;
void solve()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
             scanf("%d",&a[i][j]),dp[i][j]=a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]) dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]))+1,ans=max(dp[i][j],ans);
    cout<<ans;
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：geek痕 (赞：0)

纠正一下@ hychychyc的题解中的小错误。

先讲题目，我参照 hychychyc的思路，写的是二维前缀和再枚举判断。

但 hychychyc的代码中有个小小的bug，数据弱才能AC。

```cpp
 for(int i=1;i<=n;i++)
         for(int j=1;j<=m;j++)
             for(int k=maxn;k+i<=n&&k+j<=m;k++)
     {
```
...
     }
看这一段，i和j都是从1开始枚举的，那么如果正方形就在边界的角上呢？

像这样的输入。

4 4
1 1 0 1

1 1 0 0

0 0 0 0

1 1 0 1

最后得到的会是错误的结果，1

原因很简单，代码枚举的时候用k+i，这样就跳过了第一行以一列开始的情况（k从1开始，i也是从1开始）

而且严格意义上，这段代码实际上每次循环是在判断（i+1,j+1)开始，边长为k的正方形是否存在。

正确的写法应该是把i，j初始化为0


因为hychychyc的题解比较靠后，所以还是上一段修正过后的完整代码，以上算是一个需要注意的细节吧。




    



```cpp
#include <iostream>
using namespace std;
int num[101][101];
int sum[101][101];
int main() {
    #ifdef LOCAL
    freopen("test.in","r",stdin);
    #endif
    int n,m;
    int zuida=0;
    cin>>n>>m;
    for(int i=1; i<=n; i++)
        for(int k=1; k<=m; k++) {
            cin>>num[i][k];
            sum[i][k]+=sum[i-1][k]+sum[i][k-1]-sum[i-1][k-1]+num[i][k];
        }
    for(int i=0; i<=n; i++)//注意这行←和↓
        for(int k=0; k<=m; k++)//这行循环的初始值问题。
            for(int res=1; i+res<=n&&k+res<=m; res++) {
                int t=sum[i+res][k+res]-sum[i][k+res]-sum[i+res][k]+sum[i][k];
                if(t==res*res)
                    zuida=max(res,zuida);
                else
                    break;
            }
    cout<<zuida;
    return 0;
}
```

---

## 作者：牟一帆mou__yifan (赞：0)

//这道题目用的是一个全新的思路。既然要我们求最大正方形的边长，那我们就设法找出所有的“正方形”，把他们的边长记录下来，输出最大的那个。

//如何找出所有的正方形呢？我开了一个二维f 数组，来记录每个数字与最左上角的数构成的对角线所在的长方形内的所有数字之和。之后框出所有“正方形”，用一个k 算出所有“正方形”右下角应有的数。如果这个数等于他所在“正方形”的边长的平方，则其就能构成一个正方形。

```cpp
var
  m,n,i,j,k,max,ans:longint;
  a,f:array[-100..1000,-100..1000] of longint;//为什么这里要是-100~1000而不是0~1000呢？往下看吧。
begin
  readln(n,m);
  for i:=1 to n do
  for j:=1 to m do read(a[i,j]);//读入
  for i:=1 to n do
  for j:=1 to m do f[i,j]:=a[i,j]+f[i,j-1]+f[i-1,j]-f[i-1,j-1];//由求面积 就可以推导出这个动态转移方程。理解理解吧。
  i:=0;j:=0;//不知我为什么要写这个
  for k:=1 to n-1 do
  for i:=2 to n do
    for j:=2 to m do begin
    if (f[i,j]=j*j) and (i=j) then max:=j;//如果恰好等于边长*边长且i=j那么就是一个正方形。
    if max>ans then ans:=max;
    if f[i,j]-f[i,j-k]-f[i-k,j]+f[i-k,j-k]=k*k then max:=k; 这个建议做一个变量表，理解了，题目就简单了。
    if max>ans then ans:=max;
  end;
  writeln(ans);//输出答案
end.
```

---

## 作者：Yoshinow2001 (赞：0)

好像和楼下的方法差不多x

嗯先用O(mn)的时间算出对所有1<=i<=n,1<=j<=m从(1,1)到(i,j)的矩阵中数字的和，~~抱歉不会打公式~~

然后直接从大到小枚举正方形的边长就好啦x（话说这题为什么有dp的标签…

~~另外我觉得如果都行的话按题目意思应该输出0？~~

```cpp
#include<cstdio>
const int maxn=205;
int w[maxn][maxn],s[maxn][maxn],n,m,size;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&w[i][j]);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)s[i][j]=s[i][j-1]+s[i-1][j]-s[i-1][j-1]+w[i][j];
    size=n>m?m:n;
    for(;size>=1;size--)
    {
        for(int i=1;i<=n-size+1;i++)
            for(int j=1;j<=m-size+1;j++)
                if(s[i+size-1][j+size-1]-s[i-1][j+size-1]-s[i+size-1][j-1]+s[i-1][j-1]==size*size)
                {
                    printf("%d",size);return 0;
                }
    }printf("%d",0);
    return 0;
}
```

---

## 作者：smzzl (赞：0)

先贴代码解释看后面

```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;

    int a[204][204];
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        cin>>a[i][j];
//读入
    int qz[204][204]={0};
    for (int i=1;i<=n;i++)
       for (int j=1;j<=m;j++)
         qz[i][j]=qz[i][j-1]+a[i][j];
//类似前缀和的预处理
    int Min=min(n,m);
    int d[204][204]={0};
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        d[i][j]=d[i-1][j]+qz[i][j];
//依然前缀和预处理
    for (int size=Min;size>=2;size--)
        for (int i=1;i<=n-size+1;i++)
          for (int j=1;j<=m-size+1;j++)
           if (d[i+size-1][j+size-1]+d[i-1][j-1]-d[i+size-1][j-1]-d[i-1][j+size-1]==size*size) {cout<<size; retnrn 0;}//精髓
    cout<<"1";
}
```
**看着题题目写着dp，但此题不知怎么的用搜索做也跑得很快**

思路就是第一重“size”循环枚举正方形大小，这里倒序的优势不言而喻

第二重循环和第三重循环枚举正方形左上角的坐标，然后判断，

那么，怎么判断呢？

我在前面做了一个前缀和之类的（我想这么叫）

然后。。。。

这样就出来了吧。。。

精髓在这一句： if (d[i+size-1][j+size-1]+d[i-1][j-1]-d[i+size-1][j-1]-d[i-1][j+size-1]==size\*size) {cout<<size; return 0;}

这样可以少掉一重遍历此正方形需要的时间，改为用类似于前缀和思想。。。。

大概就这样

我一共才跑了5ms（时间复杂度看起来蛮低的）（我太弱了不会算时间复杂度）

为了防止某些人抄题解，在代码中安放了一点点bug(这些代码的修改不影响对本题解的阅读），请不要复制代码。


---

## 作者：alpq010815 (赞：0)

处理前缀和也算dp吧

处理一个矩阵前缀和，就可以O(n)的求出矩阵的和了，而且只有和为完全平方数才是正方形，因为数据只有1吗，要是不是一的话就不容易了

这样再枚举一个起点，和一个边长就是任意一个正方形了，再优化剪枝一下，就可以0ms过了





```cpp
#include<cstdio>
#include<iostream> 
using namespace std;
int n,m;int maxn=1;
int a[101][101];int s[101][101];
int ans=0;
int main()
{
     scanf("%d%d",&n,&m);
     for(int i=1;i<=n;i++)
         for(int j=1;j<=m;j++)
         scanf("%d",&a[i][j]);
     for(int i=1;i<=n;i++)
         for(int j=1;j<=m;j++)
     {
         s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
     }
     for(int i=1;i<=n;i++)
         for(int j=1;j<=m;j++)
             for(int k=maxn;k+i<=n&&k+j<=m;k++)
     {
         int w=s[i+k][j+k]-s[i][j+k]-s[i+k][j]+s[i][j];
         if(k*k==w)
         maxn=max(maxn,k);
         else break;
     }
     printf("%d",maxn);
    return 0;
}
```

---

## 作者：MR_DENGOU (赞：0)

六年级小学生的题解，一道模拟题

输入时往左上角走，依次检查正方形

每次找出最大值。

附上代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
bool a[110][110];//开 bool 省内存 至少比 int 小 
int n,m,k=-2147483648;//选最大，赋最小
int cz(int x,int y){
    for(int i=x;i>=1;i--){
        if(y-(x-i)==0) return y;//当往左超出范围时，输出小的 y
        for(int v=x;v>=i;v--)//一定要多一循环管列，我当时就是没打所以一开始没过
        for(int j=y;j>=y-(x-i);j--){
            if(a[v][j]==0){//当不是一个完整正方形时
                return x-i;//返回边长
            }
        }
    }
    return x;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            k=max(k,cz(i,j));//找最大边长
        }
    cout<<k;
    return 0;
}
```

---

## 作者：PhantasmDragon (赞：0)

暴力加一点点日常剪枝，就能过的了。数据强度比较小(<100)

这道题亦可用dp通过,当数据强度较大时，必须使用

枚举时间复杂度O(N^5),dp时间复杂度O(N^2) 差距很大的>\_>

下面贴上丑代码QAQ

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
int a[101][101],m,n,ans=0;
int findsquare(int x,int y)//找出以(x,y)为坐上角最大的正方形
{
    int lp;
    for(lp=1;lp<=min(n,m);lp++)
    {
        for(int tx=x;tx<x+lp;tx++)
        {
            for(int ty=y;ty<y+lp;ty++)
            {
                if(a[tx][ty]!=1)//如果已经出现0，就直接退出，不必继续搜索下去。
                {
                    return lp-1;因为当前的答案已经加1，所以这里要减去。
                }
            }
        }
    }
    return lp-1;//同理
}
void solve()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    for(int i=0;i<n;i++)// 简单暴搜,一个一个找
    {
        for(int j=0;j<n;j++)
        {
            int tmp;
            tmp=findsquare(i,j);
            if(tmp>ans)//求最大的。
            {
                ans=tmp;
            }
        }
    }
    printf("%d",ans);
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：Mys_C_K (赞：0)

楼下的大神优化爆搜和前缀和讲的很好，dp也很牛，但都是二维的

蒟蒻来把它滚动一下，唯一一个问题就是要记录f[i-1,j-1]

这是比较不常见的

附上丑陋的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int f[3010];
int main()
{
    int n,m;char ch;int maxans=0,last;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int x;cin>>x;
            int t=f[j];
            if(x==0) f[j]=0;
            else{
                f[j]=min(f[j],min(f[j-1],last))+1;
                if(f[j]>maxans) maxans=f[j];
            }
            last=t;
        }
    printf("%d\n",maxans);
    return 0;
}
```

---

## 作者：mollnn (赞：0)

**提供一种很简单的思路。要验证(i,j)能表示多大的正方形的末尾，就要验证(i-1,j)(i,j-1)(i-1,j-1)这三个点中能作为正方形末尾的最小值，然后加上一即可。**

[codec]

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#define min3(x,y,z) min(x,min(y,z))
using namespace std;
int main()
{
    int a[105][105],dp[105][105],n,m,ma=0,i,j;
    cin>>n>>m;
    memset(dp,0,sizeof(dp));
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j];
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
        {
            dp[i][j]=a[i][j]*(min3(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1);
            ma=max(ma,dp[i][j]);
        }
    cout<<ma<<endl;
    return 0;
} 
[/codec]
```

---

## 作者：FHXZ (赞：0)

这个题可以应用二维数组前缀和来求解。

因为只有01这两个数，所以求前缀和会很方便的求助面积来，这样也可以很方便的找到最大边长。

注意前缀和的求法和面积的表示方法，对于二维数组的前缀和，先像一维数组那样求一遍每行的前缀和，再将每一个前缀和加上自己上面的点的前缀和。

而面积的表示：对于i,j点边长为l的正方形，前缀和表示：sum[i][j]-sum[i-l][j]-sum[i][j-l]+sum[i-l][j-l]至于为什么，大家可以自己写几组数据试试。

代码：

                
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
int n,m,ans,ans2;
int mapp[105][105];
int sum[105][105];
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    for (int j=1;j<=m;j++)
    scanf("%d",&mapp[i][j]);
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m;j++)
        sum[i][j]=sum[i][j-1]+mapp[i][j];
        for (int j=1;j<=m;j++)
        sum[i][j]+=sum[i-1][j];
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m;j++)
        {
            for (int l=1;l<=min(i,j);l++)
            {
                if(mapp[i][j]==1&&l*l==sum[i][j]-sum[i-l][j]-sum[i][j-l]+sum[i-l][j-l])
                {
                    if(ans<sum[i][j]-sum[i-l][j]-sum[i][j-l]+sum[i-l][j-l])
                    {ans2=l;
                    ans=sum[i][j]-sum[i-l][j]-sum[i][j-l]+sum[i-l][j-l];}
                }
            }
        }
    }
    printf("%d\n",ans2);
    return 0;
}
```

---

## 作者：zx2003 (赞：0)

其实就是把创新吃鱼法的除对角线外全为0改为全为1即可

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
short n,m,a[102][102],f[102][102],i,j,h[102][102],l[102][102],ans;
int main()
{
    memset(a,-1,sizeof(a));
    memset(f,0,sizeof(f));
    memset(h,0,sizeof(h));
    memset(l,0,sizeof(l));
    cin>>n>>m;
    for (i=1;i<=n;i++)
     for (j=1;j<=m;j++) 
     {
         cin>>a[i][j];
         if (a[i][j-1]==1) h[i][j]=h[i][j-1]+1;
     }
    for (i=1;i<=m;i++)
     for (j=1;j<=n;j++) 
         if (a[j-1][i]==1) l[j][i]=l[j-1][i]+1;
    ans=0;     
    for (i=1;i<=n;i++)     
     for (j=1;j<=m;j++) 
     if (a[i][j])
     {
         f[i][j]=min(min(f[i-1][j-1]+1,l[i][j]+1),h[i][j]+1);
         ans=max(ans,f[i][j]);
     }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：梦景 (赞：0)

DP

```cpp
f[I,j]=a[I,j]*(min{f[I-1,j],f[I,j-1],f[I-1,j-1]}+1); 
#include<bits/stdc++.h>
using namespace std;
int i,j,n,m,maxl;
int f[200][200],a[200][200];
int min(int a,int b,int c)
{
    if (a>b) a=b;
  if (a>c)  a=c;
  return(a);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            scanf("%d",&a[i][j]);
            if(a[i][j]==1) f[i][j]=1;
            else f[i][j]=0; 
        }
    }   
    for (i=1;i<=n;i++)
      for (j=1;j<=m;j++)
        if (a[i][j]==1) 
        {
            if (min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1>f[i][j]) f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1;  //转移方程
        }    
    maxl=0;
  int *max_ptr = max_element(&f[0][0],&f[n][m]);  //求数组中最大元素
  printf("%d",*max_ptr);
  //system("pause");                  
}
```

---

## 作者：CoolTeam (赞：0)

设f[i][j]=k ，表示以坐标(i,j)为最右下角的正方形边长为k。

k==1部分可以直接输入，所以枚举更大边长k从2到100(找不到更大边长就退出)

注意到f(i,j)==k,当且仅当 f(i,j)==k-1 且f(i-1,j)==k-1 且f(i,j-1)==k-1且f(i-1,j-1)==k-1。


---

## 作者：Skywalker_David (赞：0)

题目求得是能盖的最大房子，实际上是动规的一道经典题，最大子矩阵。 这道题，我们可以把行当作阶段，每单位土地为状态，最优函数f[i,j]指以（I,j）为正方形右下角顶点，所能盖起得最大房子单位。 好像有点乱，举个例子，如果map为 1 1 1 1 那么f为 1 1 1 2 f[1,1],f[1,2],f[2,1]都是1 因为以他们为正方形右下角顶点，只能盖起单位为1的房子，而f[2,2]能盖起单位为2的房子（房子四个顶点为（1，1），（1，2），（2，1），（2，2））。 不难推断，f[I,j]和f[I-1,j],f[I,j-1],f[I-1,j-1]有密切联系，如果f[I,j]=2,那么f[I,j-1],f[I-1,j]f[I-1,j-1]必须大于等于1。 所以方程为 f[I,j]=map[I,j]\*(min{f[I-1,j],f[I,j-1],f[I-1,j-1]}+1); 至此，题解终。 0ms没问题的 对了，还有边界 f[I,1]=map[I,1] f[1,j]=map[1,j]

pascal代码：

```cpp
var 
    a,f:array[0..101,0..101]of longint; 
    n,m,i,j,max:longint; 
function min(u,v,w:longint):longint; 
var 
    q:longint; 
begin 
    q:=100; 
    if u<q then 
        q:=u; 
    if v<q then 
        q:=v; 
    if w<q then 
        q:=w; 
        min:=q; 
end; 
begin
    readln(n,m); 
    fillchar(f,sizeof(f),0);
    max:=0;
    for i:=1 to n do 
        for j:=1 to m do read(a[i,j]); 
            for i:=1 to n do 
                for j:=1 to m do 
                    if (a[i-1,j]<>0)and(a[i-1,j-1]<>0)and(a[i,j-1]<>0) then 
                        f[i,j]:=min(f[i-1,j],f[i-1,j-1],f[i,j-1])+1 
                    else f[i,j]:=1; 
    for i:=1 to n do 
        for j:=1 to m do 
            if f[i,j]>max then max:=f[i,j]; 
    write(max); 
end.
```

---

## 作者：冰冷的心 (赞：0)

~~题目数据太水
随便打暴力就过了~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int maps[110][110];
bool check(int x,int y,int len){
	if(maps[x][y]==0)return false;
	for(int i=1;i<=len;i++){
		if(maps[x-i][y]==0||maps[x][y-i]==0)return false;
	}
	return true;
}
int main(){
	scanf("%d%d",&n,&m);
	int j,i,l,len;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			scanf("%d",&maps[i][j]);
		}
	}
	bool flag;
	int ans=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(maps[i][j]==0)continue;
			ans=max(ans,1);
			for(len=1;i+len<=n&&j+len<=m;len++){
				int dotx=i+len,doty=j+len;
				if(check(dotx,doty,len))ans=max(ans,len+1);
				else break;
			}
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```
枚举左上端点再枚举长度
即可得出右端点
再每扩大一个长度就判断一次（没有退出循环的话就是合法的）就可以过啦

---


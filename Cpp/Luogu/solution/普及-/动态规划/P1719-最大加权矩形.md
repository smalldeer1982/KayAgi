# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# 题解

## 作者：Yaser (赞：241)

该题算是P1115 最大子段和的一个升级版，其实思想差不多，都是DP，只不过该题需要先进行一个矩阵压缩，即二维变一维。

**矩阵压缩：**

假设有一个矩阵：

-5 6 4

1 -2 6

2 1 -3

如何对它进行压缩呢，其实不难，这边我做一个类比，如果我们把一行看做一个数，这里看做三个数a,b,c,那么将这三个相邻数的进行不同的组合，将这个新的组合视为一个新的数，这就是进行压缩处理，例如a,b,c可以组合为{[a],[ab],[abc],[b],[bc],[c]}，而矩阵压缩也类似。

先设置一个变量max用于保存压缩后的一维数组的最大子序列和。

第一次我们取第一行：

-5 6 4

则其最大子序列和为10，max=10。

第二次取第一二行：

-5 6 4

1 -2 6

注意现在开始是矩阵压缩的精髓，我们将每一列的数进行相加，将多行变为一行。

第一列：-5+1=-4

第二列：6+(-2)=4

第三列：4+6=10

所以压缩后的一维数组为：

-4 4 10

则其最大子序列和为14，max=14。

第三次取第一二三行：

-5 6 4

1 -2 6

2 1 -3

对每一列进行压缩：

第一列：-5+1+2=-2

第二列：6+(-2)+1=5

第三列：4+6+(-3)=7

所以压缩后的一维数组为：

-2 5 7

则其最大子序列和为12，max=14。

第四次取第二行：

1 -2 6

则其最大子序列和为6，max=14。

第五次取第二三行：

1 -2 6

2 1 -3

对每一列进行压缩：

第一列：1+2=3

第二列：-2+1=-1

第三列：6+(-3)=3

所以压缩后的一维数组为：

3 -1 3

则其最大子序列和为5，max=14。

第六次取第三行：

2 1 -3

则其最大子序列和为3，max=14。

最后求得这个矩阵最大的子矩阵和为14

也就是第一二行的三四列

6 4

-2 6

代码：
```cpp
#include <bits/stdc++.h>

#define infinitesimal  -2100000000
using namespace std;
typedef long long int lli;
/**
 *  Created with IntelliJ Clion.
 *  @author  wanyu
 *  @Date: 2018-04-24
 *  @Time: 08:43
 *  To change this template use File | Settings | File Templates.
 * 
 */

#define mset(t, x) memset(t,x,sizeof(t))
#define loop(a, b, c) for(int a=b;a<=c;a++)
#define loop2(a, b, c) for(int a=b;a>=c;a--)
#define loop3(a, b, c) for(int a=b;a<c;a++)
#define loop4(a, b, c) for(int a=b;a>c;a--)
#define maxn 150
#define maxm 20
int n, m, t;
int matrix[maxn][maxn];
int ans = infinitesimal;
int temp[maxn];
int dp[maxn];

void Arrsum() {
    mset(dp, 0);
    loop(i, 1, n) {
        dp[i] = max(dp[i], dp[i - 1] + temp[i]);
        ans = max(ans, dp[i]);
    }
}

void MatrixSum() {
    loop(i, 1, n) {
        mset(temp, 0);
        loop(j, i, n) {
            loop(k, 1, n) {
                temp[k] += matrix[j][k];
            }
            Arrsum();
        }
    }
}

int main() {
    scanf("%d", &n);
    loop(i, 1, n) {
        loop(j, 1, n) {
            scanf("%d", &matrix[i][j]);
        }
    }
    MatrixSum();
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Stella_Yan (赞：201)

题外话：

n久没有写题解了，咕值掉的不爱掉了，赶紧写一个题解加一下QωQ

---

正文：

这道题其实还是满水的。

首先呢。。。

你要算一个矩阵的内部元素和，比如说下图中的红色部分：

$\ \ \ 0\ -2\ -7\ \ \ \ \ \ \ 0$

$\ \ \ 9\ \ \ \ \ \ \color{red}2\ -6\ \ \ \ \ \ \ \color{black}2$
 
$-4\ \ \ \ \ \ \color{red}1\ -4\ \ \ \ \ \ \ \color{black}1$

$-1\ \ \ \ \ \ 8\ \ \ \ \ \ 0\ \ -2$

其实可以等同于蓝色部分：

$\color{blue}\ \ \ 0\ -2\ -7\ \ \ \ \ \ \ \color{black}0$

$\color{blue}\ \ \ 9\ \ \ \ \ \ 2\ -6\ \ \ \ \ \ \ \color{black}2$
 
$\color{blue}-4\ \ \ \ \ \ 1\ -4\ \ \ \ \ \ \ \color{black}1$

$-1\ \ \ \ \ \ 8\ \ \ \ \ \ 0\ \ -2$

减去绿色部分

$\color{green}\ \ \ 0\ -2\ -7\ \ \ \ \ \ \ \color{black}0$

$\ \ \ 9\ \ \ \ \ \ 2\ -6\ \ \ \ \ \ \ \color{black}2$

$-4\ \ \ \ \ \ 1\ -4\ \ \ \ \ \ \ \color{black}1$

$-1\ \ \ \ \ \ 8\ \ \ \ \ \ 0\ \ -2$

再减去绿色部分

$\color{green}\ \ \ 0\color{black}\ -2\ -7\ \ \ \ \ \ \ 0$

$\color{green}\ \ \ 9\color{black}\ \ \ \ \ \ 2\ -6\ \ \ \ \ \ \ 2$
 
$\color{green}-4\color{black}\ \ \ \ \ \ 1\ -4\ \ \ \ \ \ \ 1$

$-1\color{black}\ \ \ \ \ \ 8\ \ \ \ \ \ 0\ \ -2$

加上黄色部分

$\color{yellow}\ \ \ 0\color{black}\ -2\ -7\ \ \ \ \ \ \ 0$

$\ \ \ 9\ \ \ \ \ \ 2\ -6\ \ \ \ \ \ \ \color{black}2$

$-4\ \ \ \ \ \ 1\ -4\ \ \ \ \ \ \ \color{black}1$

$-1\ \ \ \ \ \ 8\ \ \ \ \ \ 0\ \ -2$

就变成了上面的红色部分。

那么假设红色部分左上角坐标为$(x1,y1)$，右下角为$(x2,y2)$，设$sum[x][y]$表示从$(1,1)$加到$(x,y)$的和，那么红色部分就是：
$$sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1]$$

(可以自己理解一下)

那么$sum[x][y]$要怎么求呢？

其实就是$x$这一行到$y$的前缀和加上$sum[x-1][y]$就Ok啦~~

可以自己理解一下（应该很好理解吧）

然后呢，再用4个变量循环判断坐标，然后求最大值即可。

代码如下：

```cpp
#include<iostream>
using namespace std;
int n;
int a[130][130];//存储题目中的矩阵
int sum[130][130];
int qz[130][130];//qz[i][j]指的是第i行到j的前缀和
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            qz[i][j]=qz[i][j-1]+a[i][j];//求前缀和
            sum[i][j]=qz[i][j]+sum[i-1][j];//计算sum
        }
    }
    int mx=-99999999;//存储答案
    for(int x1=1;x1<=n;x1++){
    	for(int y1=1;y1<=n;y1++){
    		for(int x2=1;x2<=n;x2++){
    			for(int y2=1;y2<=n;y2++){
    				if(x2<x1 || y2<y1) continue;//如果左上角比右下角还要大，就不用求了，下一个
    				mx=max(mx,sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2]);//求最大值
    			}
    		}
    	}
    }
    cout<<mx;//输出
	return 0;
}

```

---

## 作者：X_WT (赞：100)

## 引子：	

		给出一段序列，选出其中连续且非空的一段使得这段和最大。
        第一行是一个正整数N，表示了序列的长度。(N<=200000)
        
这是 **[P1115最大子段和](https://www.luogu.org/problemnew/show/P1115)**
的描述，也就是本题的一维版本。

	DP方程：dp[i]=max(dp[i-1]+tmp,tmp)	tmp表示这个数列的第i项。
    
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int maxn(int a,int b){return a>b?a:b;}
int main(){
	int ans=-999999,tmp,i,n,dp[200100]={0};//假装ans是负无穷
	scanf("%d",&n);
	for(i=1;i<=n;++i){
		scanf("%d",&tmp);
		dp[i]=maxn(dp[i-1]+tmp,tmp);
		ans=maxn(ans,dp[i]);//动态规划
	}
	printf("%d\n",ans);
	return 0;
}
```
## 那么我们如何来处理这一题呢？

我们可以考虑将矩形压缩成一维，比如处理一个2行的矩形时，将a [ i ][ j ]与a [ i - 1 ][ j ]相加，成为一个新的数组f [ n ]，再使用上述代码进行动态规划，找出局部最优解。

## 那如何来快速将矩形折叠呢？

我们可以选择**前缀和**

简单来说，就是在输入的时候，再次加上a[ i - 1 ][ j ]，这样可以用减法来快速表示压缩的矩形。

具体代码如下：
```cpp
	scanf("%d",&n);
	int i,j;
	for(i=1;i<=n;++i){
		for(j=1;j<=n;++j){
			scanf("%d",&a[i][j]);
			a[i][j]+=a[i-1][j];//根据前缀和定义处理
		}
	}
```

用样例来表示，输入的是：

		 0	-2	-7	 0
		 9	 2	-6	 2
		-4	 1	-4	 1 
		-1	 8	 0	-2

在经过前缀和处理之后，输出的是这个：

		0	-2	-7	 0
        9	 0	-13	2
        5	 1	-17	3
        4	 9	-17	1
        
可以模拟一下，a[ i ][ j ] - a[ i - k ][ j ]正好是以i为最下面一行，往上k行的压缩结果，这就很方便地表示了压缩后的矩形。

## 那又怎么循环找出各行为最下一行，不同行数的矩阵最大值呢？

我用i表示以i为最下一行，k表示向上k行，代码如下:
```cpp
	for(i=1;i<=n;++i){
		for(k=1;k<=i;++k){
			
		}
	}
```

k<=i，保证了i-k>=0。

那再次循环，运用第一个代码的简单变形，可以求出以i为最下一行，向上k行的矩形最大值，多次更新ans，愉快AC。

最后上一下总代吗：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,a[150][150],n;
int maxn(int a,int b){return a>b?a:b;}
//自定义求最大值
int main(){
	scanf("%d",&n);
	int i,j,k;
	for(i=1;i<=n;++i){
		for(j=1;j<=n;++j){
			scanf("%d",&a[i][j]);
			a[i][j]+=a[i-1][j];
		}
	}//如上，前缀和处理
	for(i=1;i<=n;++i){
		for(k=1;k<=i;++k){
			int f[150]={0},dp[150]={0};//f[j]表示压缩的矩形第j列的值
			for(j=1;j<=n;++j){			//其实可以不开数组，一个f就可以
				f[j]=a[i][j]-a[i-k][j];//求压缩的矩形第j列的值
				dp[j]=maxn(dp[j-1]+f[j],f[j]);//动态规划
				ans=maxn(ans,dp[j]);//更新答案
			}
		}
	}
	cout<<ans<<endl;//愉快AC
	return 0;
}
```



---

## 作者：LiHaoYu0512 (赞：62)

~~这道题要用二维前缀和~~！
------------
剧透的作者已经被打死

------------
一开始我尝试了暴力，结果发现需要用6重循环，于是机智的我放弃了这个想法...

------------
后来我尝试将这个程序化简成五个循环，可以使用一维前缀和进行化简，后来机智的我发现程序还是会炸掉！！！

------------
气急败坏的我发誓要于这道题抗争到底，于是我写出了四重循环，那就是使用二维前缀和啦

------------
我们先定义一个数组s，s[i][j]表示以（1,1）为左上角，（i,j）为右下角的矩阵，所有数相加之和！那如何求出s[i][j]呢？

------------
s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];

根据这个递推式我们就可以知道s[i][j]了！
------------
既然知道了这个，我们下一步就该

枚举所有左上角和右下角
---
知道了左上角和右下角，如何求出这一矩阵的所有数之和呢？

------------
设左上角的下标为(x1,y1)，右下角的下标为(x2,y2)，则我们的公式为：

s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]

根据这个公式我就可以通过s[i][j]求出每个矩阵的所有数之和
---
------------
二维前缀和的方法就写到这里，直接上程序！

```cpp
#include<iostream>
#include<climits>
#define MAXN 130
#define LL long long
using namespace std;
LL a[MAXN][MAXN];
//存储输入量的数组
LL s[MAXN][MAXN];
//二维前缀和数组
int main()
{
	ios::sync_with_stdio(0);
    //优化输入输出（仅限cin和cout）
	int N;
	cin>>N;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
		{
			cin>>a[i][j];
            //输入
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
            //O(1)递推出s[i][j]，二维前缀和
		}
	LL ans=INT_MIN;
	for(int x1=1;x1<=N;x1++)
		for(int y1=1;y1<=N;y1++)
			for(int x2=x1;x2<=N;x2++)
				for(int y2=y1;y2<=N;y2++)
					ans=max(ans,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]);
                    //用四重循环确定左上角下标及右下角下标，并用递推式求出ans，找出最大的ans
	cout<<ans;
    return 0;
}
```

---

## 作者：tommymio (赞：61)

做这道题之前我的直觉就是最大子段和的变式，AC之后一看题解，发现很多题解的DP不合理，因为最大子段和就没必要用DP,那这道题就更没必要用DP了(众所周知,DP是用空间换时间)，接下来我就具体讲一下我代码的优化(如何将最大子矩阵转化为最大子段和,**@Yaser**已经有很好的解释，在此不再赘述)。

我相信很多人应该是学过最大子段和了的，也知道DP做法的状态转移方程
${f_{i}}$=${max(a_{i},f_{i-1}+a_{i})}$，仔细观察就会发现，这个方程是可以优化的(参见《算法竞赛进阶指南》~~(The end)~~)，因为当从${f_{i}}$转移过来时，相当于加上了前面一段连续的值，或者直接从${a_{i}}$开始。这就意味着我们可以用一个$sum$进行计数，当${sum>=0}$时，${sum += a_{i}}$，否则${sum=a_{i}}$(如果$sum$ < $0$，那么$sum$ + $a_{i}$ < $a_{i}$,所以直接取$a_{i}$是最优解)。然后对每一次的$sum$取最大值，这样我们一定不会丢失状态，而且能够取到最大值。

上代码~~~~

```cpp
#include<cstdio>
int b[125][125];
int main() {
	int n,ans=-1828805;//经过计算，最小不会小过这个值 
	scanf("%d",&n);
	for(register int i=1;i<=n;++i) {
		for(register int j=1;j<=n;++j) {
			int a;
			scanf("%d",&a);
			b[i][j]=b[i-1][j]+a;
		}
	}
	for(register int i=1;i<=n;++i) {
		for(register int j=0;j<i;++j) {
			int sum=0;
			for(register int k=1;k<=n;++k) {
				int tmp=b[i][k]-b[j][k];//取前缀和 
				if(sum<0)	sum=0;
                sum+=tmp;
				if(sum>ans)	ans=sum;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```




---

## 作者：Believer (赞：28)

### 画一张图，你会惊奇的发现：


###### 从a[1][1]到a[i][j]的权值和value[i][j]为

 
### value[i][j]=a[i][j]+value[i][j-1]+value[i-1][j]-value[i-1][j-1];(容斥原理可得)

###### 并且定义一个tmp来记录从a[i][j]到a[q][w]的权值和：
### tmp=value[q][w]-value[i-1][w]-value[q][j-1]+value[i-1][j-1];
###### 再用一个简单的贪心：
### maxn=max(maxn,tmp);

好吧，上代码：



除去定义和库，核心代码为：



{
    
    cin>>n;
    
    for(int i=1;i<=n;i++)
       
       for(int j=1;j<=n;j++)cin>>a[i][j];//输入
       
    for(int i=1;i<=n;i++)
       for(int j=1;j<=n;j++)value[i][j]=a[i][j]+value[i][j-1]+value[i-1][j]-value[i-1][j-1];//已推得
    
     for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)//对于每一个点
        {
            for(int q=i;q<=n;q++)
            {
            	for(int w=j;w<=n;w++)//找遍它右下侧所有可能权值，取最优
            	{
            		int tmp=value[q][w]-value[i-1][w]-value[q][j-1]+value[i-1][j-1];//以得公式
                    maxn=max(maxn,tmp);//贪心
                }
            }
        }
    }
    cout<<maxn;//输出
    return 0;//完美结束
}

---

## 作者：zhz小蒟蒻 (赞：19)

### 先讲一下60分做法  
看到这道题，我第一眼就想到，可以暴力枚举，于是我运用了[前缀和](https://www.cnblogs.com/AndyJee/p/4474073.html)，将原本的六重循环优化了一下（不算求和部分）先贴一下代码  
```
#include <iostream>
#include <cstdio>
using namespace std;
int matrix[311][311],a[311][311];
int main()
{
	//freopen("max.in","r",stdin);
	//freopen("max.out","w",stdout);
	int i,j,k,n;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			matrix[i][j]=matrix[i][j-1]+a[i][j];
		}
	}
	int ans=0;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			for(int xx=1;i+xx-1<=n;xx++)
			{
				for(int yy=1;j+yy-1<=n;yy++)
				{
					int num=0;
					int s1=i+xx-1,s2=j+yy-1;
					for(int xun=j;xun<=s2;xun++)
						num+=matrix[xun][s1];
					ans=max(ans,num);
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

## 但是，这样子做会超时4个点，我们应该怎么办呢？  
此时，我想到了一个脑残的方法，再来一个前缀和数组，将原来的matrix数组定义为（1,1）~（x,y）这个矩阵的和，新增的数组，用来表示每一行的前缀和
### 于是，我们修改一下代码  
```
#include <iostream>
#include <cstdio>
using namespace std;
int matrix[311][311],duan[311][311],a[311][311];
int main()
{
	freopen("max.in","r",stdin);
	freopen("max.out","w",stdout);
	int i,j,k,n;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			duan[i][j]=duan[i][j-1]+a[i][j];
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			matrix[i][j]=matrix[i-1][j]+duan[i][j];
		}
	}
	int ans=0;
	for(i=1;i<=n;i++)    
	{
		for(j=1;j<=n;j++) //枚举这个矩阵的起始坐标
		{
			for(int xx=1;i+xx-1<=n;xx++)//这个矩阵的x坐标长多少
			{
				for(int yy=1;j+yy-1<=n;yy++)//这个矩阵的y坐标长多少
				{
					int num=0;
					int s1=i+xx-1,s2=j+yy-1;
					ans=max(ans,matrix[s1][s2]-(matrix[s1][j-1]-matrix[i-1][j-1])-matrix[i-1][s2]);//求出当前枚举出的这个矩阵和是多少
				}
			}
		}
	}
	printf("%d",ans);//输出答案
    while(1);//反抄袭
	return 0;
}
```
## 新人发题解，请大佬们多多谅解，勿喷（本人并没有使用最优的动态规划）

---

## 作者：liyifan24 (赞：14)


   ~~这道题挺水的，呵呵~~，讲白了就是求最大子矩阵，
方法么，学过线性动态规划的同学们应该简单的吧，基础啊！这题其实可以优化的，就用**前缀和**，具体看一下代码，
走起：
```cpp
#include <iostream>
#include<cstdio>
#include<cstring>
#define LL long long
using namespace std;
LL G[550][550];
int main()
{
    int m,n,i,j,k;
    LL a[550],dp[550],maxn,x;
    scanf("%d%d",&m,&n);
    memset(G,0,sizeof(G));
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            scanf("%lld",&x);
            G[i][j]=G[i-1][j]+x;//每行的前缀和
        }
    }
    maxn=0;
    for(i=1;i<=n;i++)
    {
        for(j=i;j<=n;j++)
        {
            dp[0]=0;
            for(k=1;k<=m;k++)
            {
                a[k]=G[j][k]-G[i-1][k];
                dp[k]=max(a[k],a[k]+dp[k-1]);
                maxn=max(maxn,dp[k]);
            }
        }
    }
    printf("%lld",maxn);
    return 0;
}
```
好了，一道水题。。。。。

---

## 作者：ysner (赞：11)

看到这道题，我瞬间想起了NOI OpenJudge 题库上的P1768最大子矩阵问题，此两题除了名字不同，确实一模一样。

关键词：贪心、二维转一维、最大字段和

total数组用于存纵向数值之和，total[i][j]代表从第0行到第i行第j-1纵列数值之和，

要求第q行到第z行纵列数值之和，用total[z][j]-total[q-1][j]即可。（前缀和优化）——此处即开始分各种情况（q、z不同）

total1用于在求出对应纵列数值之和后（一种情况），将其转化为最大子段和问题（只要一维！），

最大子段和问题公式为total1[j]=max(total1[j-1]+total1[j],total1[j]),这一行中得到的最大值那一列及其前面的数即为第q到z行最大子段。

最终将各个情况（不同行）的最大子段数比个大小即可。

```cpp
#include<cmath>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
int a[101][101],b[101],total[101][101]={},total1[101]={};
int main()
{
  int i,j,k,n,m=-1,mx=-1000,q,z;
  cin>>n;
  for(i=0;i<n;i++)
    for(j=0;j<n;j++)
      cin>>a[i][j];
  for(i=0;i<n;i++)
    total[0][i]=a[0][i];
    for(i=1;i<n;i++)
      for(j=0;j<n;j++)
    {
      total[i][j]=total[i-1][j]+a[i][j];
    }
  for(q=1;q<n;q++)
    for(z=q;z<n;z++)
    {
      for(j=0;j<n;j++)
      {
        total1[j]=total[z][j]-total[q-1][j];
      }
      for(j=1;j<n;j++)
          total1[j]=max(total1[j-1]+total1[j],total1[j]);
          for(j=0;j<n;j++)
            if(total1[j]>m) {m=total1[j];mx=j;}
   }
  cout<<m<<endl;
  return 0;
}
```

---

## 作者：塔罗兰 (赞：7)

这题主要是压缩数组，然后用求最大子段和的方法做。   
具体过程其他题解有，不废话，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[150][150],t[150],n,i,j,ma=-99999;
int zdh()//此函数求最大子段和。
{
	int k,l=-99999;
	for(k=0;k<n-1;k++)
	if(t[k]>0)
	t[k+1]+=t[k];
	for(k=0;k<n;k++)
	if(t[k]>l)
	l=t[k];
	return l;//返回最大值。
}
int main()
{
	int w,e;
	scanf("%d",&n);//输入n。
	for(i=0;i<n;i++)
	for(j=0;j<n;j++)
	scanf("%d",&a[i][j]);//输入a数组。
	for(i=0;i<n;i++)
	for(j=i;j<n;j++)
	{
		memset(t,0,sizeof(t));//清零。
		for(e=0;e<n;e++)
		for(w=i;w<=j;w++)
		t[e]+=a[w][e];//给t数组赋值（压缩纵坐标i~j的数）。
		e=zdh();//求最大子段和。
		if(e>ma)
		ma=e;//如果此值为当前最大值则保存。
	}
	printf("%d",ma);
}
```


---

## 作者：ytchx1999 (赞：4)

这道题是dp经典问题**最大子段和**的**升级版**。

不同的是，这道题是**二维**的。那么，我们是不是可以这么想呢？通过枚举行的上下边界，从而把这一区间里面的每一列缩成一个点，这样就可以把二维的问题转化为一维的问题了。

那么至此，问题就转化为了，我们如何把某一列的从第i行到第j行缩成一个点了。聪明的你一定已经想到了！！！没错，就是维护一个第k列从第1行到第x行的**前缀和**。之后，就是经典的最大子段和问题了！

接下来就是大家喜闻乐见的上代码环节。**一个小细节：题目里面并没有说是非空子矩阵，因此可以不考虑负矩阵，否则要进行特判。**


------------
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

long long a[130][130];
long long pre[130][130];

int main()
{
    int n;
    cin >> n;
    long long maxm = -1e18 - 5;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cin >> a[i][j];
            if (a[i][j] > maxm)
            {
                maxm = a[i][j];
            }
        }
    }
    if (maxm <= 0)
    {
        cout << 0 << endl;
        return 0;
    }
    for (int j = 1; j <= n; j++)
    {
        for (int i = 1; i <= n; i++)
        {
            pre[j][i] = pre[j][i - 1] + a[j][i];
        }
    }
    long long ans = -1e18 - 5;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j <= n; j++)
        {
            long long sum = 0;
            for (int k = 1; k <= n; k++)
            {
                if (sum + (pre[k][j] - pre[k][i - 1]) <= 0)
                {
                    sum = 0;
                }
                else
                {
                    sum += (pre[k][j] - pre[k][i - 1]);
                }
                ans = max(ans, sum);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：wabcy (赞：4)

###三重循环,主要使用前缀和来实现算法


```cpp
var
  a,b:array[0..105,0..105] of longint;
  i,j,x,y,k,n,s,max,max1:longint;
begin
  readln(n);
  for i:=1 to n do
    begin
      for j:=1 to n do
        begin
          read(a[i,j]);
          b[i,j]:=a[i,j]+b[i,j-1];//用b数组来储存前缀和来计算。
        end;
      {readln;}//样例有毒，不能换行，否则最后一个点会错。
    end;
  for x:=1 to n do
    for y:=x to n do 
      begin
        s:=0;
        max1:=-maxlongint;
        for k:=1 to n do 
          begin
            s:=s+b[k,y]-b[k,x-1];//加上这个方阵的值，前缀和的累加。
            if s>max1 then max1:=s;//打擂台
            if s<0 then s:=0;//用最大子段和的思路
          end;
        if max1>max then max:=max1;//继续打擂台
      end;
  write(max);
end.

```

---

## 作者：erdioce (赞：3)

[P1719 题目](https://www.luogu.org/problemnew/show/P1719)

####  思路
题意十分直接，直接要求求**最大矩形（子矩阵）的和。**

最大数据 $maxn <= 120$ 直观感觉就很小，但是思考**暴力做法：**

1.$4 for$ 枚举上下左右界；


2.维护区间内矩阵和值；

~~（我没细想过，但暴力肯定不是正解所以大郅看看就行了）~~
至少四重循环肯定会 $TLE$。

**正解思路：**

将二维矩阵压缩成一维。枚举每行，一次向下压缩矩阵

如何压缩二维矩阵？以样例为例：

**此处以 $k = 1$ 为例**  $k$ 代表从第 $k$ 行开始压缩。

$mp_i,_j$   $i,j$ 代表输入数据

$0$ $-2$ $-7$  $0$

$9$ $2$ $-6$ $2$

$-4$ $1$ $-4$  $1$ 

$-1$ $8$  $0$ $-2$

$f_i$ $i$ 代表压缩成一维的矩阵，$i$ 指从第 $i$ 行压缩的子矩阵的一维状态。

$0$ $-2$ $-7$  $0$

$9$ $0$ $-13$ $2$

$5$ $1$ $-17$ $3$ 

$4$ $9$ $-17$ $1$

以上是从第一行开始进行的矩阵压缩，在这道题中我们需要从每一行都矩阵压缩（抛弃此行以上答案贡献），然后对每个 $f_i$ 进行求最大连续子序列的操作，维护 $f_i$ 的最大值。

总体的时间复杂度是不到 $O(n^3)$ 的，对于这道题来说足够了：

1. $for$ 枚举从第几行开始对矩阵进行压缩 -> 从哪里开始 
2. $for$ 依次从以下行对矩阵进行压缩 -> 具体实现过程
3. $for$ 求压缩后数组的最大连续子序列

~~这为何是正解？请自行体会~~

#### 实现
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 200;
int ans, f[maxn];
int n, mp[maxn][maxn];
int main() {
	// freopen("_in.txt", "r", stdin);
	scanf("%d", &n);
	for (register int i = 1; i <= n; i++) {
		for (register int j = 1; j <= n; j++) {
			scanf("%d", &mp[i][j]);
		}
	}
	for (register int k = 1; k <= n; k++) {
		// memset(f, 0, sizeof f);
		for (register int i = k; i <= n; i++) {
			for (register int j = 1; j <= n; j++) f[j] += mp[i][j];
			int tmp = 0;
			int res = 0;
			for (register int j = 1; j <= n; j++) {
				if (tmp < 0) tmp = 0;
				tmp += f[j];
				res = max(tmp, res);
			}
			ans = max(ans, res);
		}
	}
	printf("%d", ans);
	return 0;
}
```
~~我加了防 $copy$ 机制~~ 注意 $f$ 数组要清空。 

好像 $luogu$ 不太推荐使用 $register$，$tiao$ 了 $tiao$ 了。

---

## 作者：星之海 (赞：3)

~~看题解，听98k啊~~

这道题目我认为用**矩阵压缩**和**前缀和**来处理是比较~~方~~(fan)~~便~~(suo)易懂的 

首先呢，明白一个道理：怎样才叫做矩阵压缩（降维）？  
矩阵压缩呢，我举一个例子你也许就懂了  
对于这道题目的样例矩阵  
0 -2 -7 0  
 9 2 -6 2  
-4 1 -4  1   
-1 8  0 -2  
那么，对于这4*4的矩阵

我们先看第一行  
0 -2 -7 0  
用dp或者前缀和知识求出该行的最大子段和  
然后和第二行合并，把两行的值相加，得  
9 0 -13 2  
然后求出该行的最大子段和  
接着，该行与第三行合并  
然后与第四行合并  
第一行与其他行合并完后，第二行继续  
以此类推

然后每次的最大子段和的最大值即为题目所求（这个结论非常容易证明，请读者自行证明）

所以，矩阵压缩时这样打
```cpp
for(i=1;i<=n;i++)//每一行
	{
		memset(b,0,sizeof(b));//b数组用来保存每次的累加值
		for(j=i;j<=n;j++)//从当前行开始一直往下累加求值
		{
			for(k=1;k<=n;k++)
			b[k]+=a[j][k];//累加当前这一行
			maxn=max(maxn,xhr(b,n));//xhr是计算最大子段和的函数，每次的最大子段和都保存在maxn最大值中
		}
	}
```

最后输出maxn即可

程序奉上：
```cpp
#include<cstring>
#include<iostream>
using namespace std;
int n,a[121][121],b[1001],maxn=-0x7fffffff;//因为矩阵里面有负数，所以要开-0x7fffffff
int xhr(int s[],int list)//前缀和知识求最大子段和
{
	int i,ans,res,minn;
	ans=res=minn=0;//一定要初始化，不要忘了
	for(i=1;i<=list;i++)
	{
		ans+=s[i];//累加当前的元素值
		res=max(res,ans-minn);//保存最大值与最小值的最大差（所求的最大子段和）
		minn=min(minn,ans);//保存最小值
	}
	return res;//输出最大值与最小值的差
}
/*
在此插入上面用前缀和知识求最大子段和的原理
对于一个序列a，令从第1个元素到第i个元素的和为s[i]，从第1个元素到第j个元素的和为s[j]，其中j>i，那么从i到j的元素和为s[j]-s[i]
如果要使该值大
那么要s[j]大，s[i]小
所以在O(n)的时间复杂度内不断更新最大值、最小值即可求出最大子段和
*/
int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	cin>>a[i][j];
	for(i=1;i<=n;i++)
	{
		memset(b,0,sizeof(b));//每次累加前要先初始化为零
		for(j=i;j<=n;j++)
		{
			for(k=1;k<=n;k++)
			b[k]+=a[j][k];//矩阵压缩
			maxn=max(maxn,xhr(b,n));//保存每次压缩的最大子段和
		}
	}
	cout<<maxn<<endl;//输出最大值即可
	return 0;
}
```

---

## 作者：xd244 (赞：2)

很水的一道题。

因为 $1\leq n\leq 100$，所以可以 $4$ 重循环枚举矩形的两个端点坐标。

同时，这道题需要用前缀和，否则就会超时。

代码：
```cpp
#include<iostream>
using namespace std;
int main(){
    int n,a[130][130]={},s[130][130]={},maxn=-1e8;cin>>n;
    for(int c=1;c<=n;c++){
        for(int _c=1;_c<=n;_c++){
            cin>>a[c][_c];
            s[c][_c]=s[c-1][_c]+s[c][_c-1]-s[c-1][_c-1]+a[c][_c];
        }
    }for(int x1=1;x1<=n;x1++){
        for(int x2=x1;x2<=n;x2++){
            for(int y1=1;y1<=n;y1++){
                for(int y2=y1;y2<=n;y2++){
                    maxn=max(maxn,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);
                }
            }
        }
    }cout<<maxn;
}
```

---

## 作者：Eason_cyx (赞：2)

首先枚举 $i,j$，计算每一行的第 $i$ 个数到第 $j$ 个数的和。然后假设整个矩阵的答案矩阵就是从第 $i$ 列到第 $j$ 列，那么这个问题就转换为了给定每一列的这些和（一个数），那就变成了求一维最大子段和。这样就可以找到答案了。而这些数的和使用前缀和处理即可。

时间复杂度 $O(n^3)$。

```cpp
#include <bits/stdc++.h>

using namespace std;
int a[505][505],s[505][505],f[505]; //s[j][i]表示第j列的第1~i个数的和
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    int n; cin >> n;
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            cin >> a[i][j];
        }
    }
    for(int j = 1;j <= n;j++) {
    	for(int i = 1;i <= n;i++) {
    		s[j][i] = s[j][i-1] + a[i][j];
    	}
    }
    int ans = -0x7fffffff;
    for(int i = 1;i < n;i++) {
		for(int j = i+1;j <= n;j++) {
			for(int k = 1;k <= n;k++) f[k] = max(f[k-1]+s[k][j]-s[k][i-1],s[k][j]-s[k][i-1]);
			ans = max(ans,*max_element(f+1,f+n+1));
		}
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：嘟嘟cqy (赞：2)

矩阵压缩算法：   
求出每一行的最大子段和  
再将各个行相加求子段和，则ans的值是最大的子段和的大小
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mapp[121][121];
int ans,c[121],dp[121];

void Getsum()
{
	for(int i=1;i<=n;i++)
    {
        dp[i]=max(dp[i-1]+c[i],c[i]);
        ans=max(ans,dp[i]);
    }
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>mapp[i][j];
	for(int l=1;l<=n;l++)
	{
		for(int r=l;r<=n;r++)
		{
			memset(c,false,sizeof(c));
			for(int i=1;i<=n;i++)
			{
				for(int j=l;j<=r;j++)
					c[i]+=mapp[i][j];
			}
			Getsum();
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：吴海啸 (赞：2)

```cpp
var a,s:array[0..200,0..200]of longint;
i,n,j,k,t,ans:longint;
begin
read(n);
for i:=1 to n do
    for j:=1 to n do
    begin
    read(a[i,j]);
    s[i,j]:=s[i-1,j]+s[i,j-1]-s[i-1,j-1]+a[i,j];//压缩子阵，预处理
    end;
ans:=-maxlongint;//初始化
for i:=1 to n do//行起点
    for j:=i to n do
    begin
    t:=0;
    for k:=1 to n do//j,k表示该子阵的右下角位置
        begin
        if t>0 then t:=t+s[j,k]-s[j,k-1]-s[i-1,k]+s[i-1,k-1]
            else t:=s[j,k]-s[j,k-1]-s[i-1,k]+s[i-1,k-1];//如果t是负数，则不需要t，直接取预处理的值
        if t>ans then ans:=t;//更新最大值
        end;
    end;
write(ans);
end.
```
**总之，这一题先压缩子阵，预处理好值，然后用动态规划来求，如果对预处理有不理解的，可以自己画一个图。**


---

## 作者：沙滩玉米 (赞：2)



```cpp
type
  su=array[0..200] of longint;
var
a:array[0..200,0..200] of longint;
b:array[0..200] of longint;
max,n,m,sum,i,j,k:longint;
function  maxsize(n:longint;c:su):longint;
var
y,x,i:longint;
begin
 x:=0;
 y:=-maxlongint;
 for i:=1 to n do
  begin
    if x>0 then x:=x+c[i] else x:=c[i];
    if x>y then y:=x;
  end;
  maxsize:=y;
end;
begin
sum:=-maxlongint;
readln(n);
for i:=1 to n do
 for j:=1 to n do
   read(a[i,j]);
for i:=1 to n do
  begin
   for k:=1 to n do  b[k]:=0;
    for j:=i to n do
      begin
        for k:=1 to n do
         b[k]:=b[k]+a[j,k];
         max:=maxsize(k,b);
        if max>sum then sum:=max;
     end;
   end;
 writeln(sum);
end.
```
思路就是压缩矩阵，用的是b数组来记录

---

## 作者：shengmingkexue (赞：2)

本题如果每次找左上和右下坐标，复杂度为O(N^4），会超时。所以采用降维的思想。

枚举上下边界，然后用一个一维数组b表示每列在上下界之间的数字之和，这样就转化为一维的问题。复杂度O(N^3)

关键代码：

```delphi

if e=f then//如果上下界相同
for g:=1 to d do b[g]:=a[f,g]//数字之和为本身
 else for g:=1 to d do
b[g]:=b[g]+a[f,g];//否则为上次的加本身
c[1]:=b[1];
for g:=2 to d do
if c[g-1]>0 then c[g]:=c[g-1]+b[g] else c[g]:=b[g];//一维递推
```

---


# 最大约数和

## 题目描述

选取和不超过 $S$ 的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。

## 说明/提示

**【样例说明】**

取数字 $4$ 和 $6$，可以得到最大值 $(1+2)+(1+2+3)=9$。

**【数据规模】**

对于 $100 \%$ 的数据，$1 \le S \le 1000$。

## 样例 #1

### 输入

```
11```

### 输出

```
9```

# 题解

## 作者：引领天下 (赞：112)

其实这题是个背包（我用暴力只得了20分）

S就是背包容量V，i就是重量，i的因子和就是价值。

这样一讲公式就出来了吧！

公式：

```cpp
i为第一个数，j为第二个数，a[k]为k的因子和
dp[i]=max(dp[i-j]+a[j],dp[i]);
```
这个公式我想大家都能很方便地推出来。

接下来我要讲一讲本题一个很重要的优化，楼下们的代码中都或多或少的有，只是他们没有解释（大佬哪有时间解释）

于是，我这个蒟蒻就来解释一下吧！

本题一个很重要的优化就是：预处理！

```cpp
void prime(){
    for (int i=1;i<=n;i++)
    for (int j=i*2;j<=n;j+=i)a[j]+=i;
}
```
看到这段预处理代码，有没有想到筛法？

没错，就是从筛法改过来的！

这个是筛法↓

```cpp
bool s[10000]={1,1};//0和1啥都不是，定1！
int a[10000],ps;//a数组存最后的质数，ps为这个数组的下标
//全局数组初值全为0
inline void $(){//不要在意函数名，这只是个筛法函数
//财迷心窍的我
    for (int j=2;j<10000;j++)//暴力！汗！
    if (!s[j]){//s[j]=0，表明j不是合数（合数为1）
    a[ps++]=j;//纪录下j这个质数，下一个
    for (int k=j*2;k<10000;k+=j)//k=j*2省一个判断，每次+j，保证是j的倍数
    s[k]=1;//既然是j的倍数，那一定是合数，标记！
    }
}
```
我将筛法改了一下，就有了这个函数。

因为是要因子和，而合数因子也算在里面，所以不用判断质数，那个bool数组自然就不要了

j=i\*2表示j初值为i的2倍，j+=i则保证j是i的倍数，就加上i这个因子

开始预处理到n，打好了一个动态表，接下来dp时就可以直接引用了

筛法的应用还有很多，所以，随机应变，打动态表可以节省很多时间哦！

代码我就不贴了，希望大家能明白预处理的重要性


---

## 作者：纸片人 (赞：41)

## 典型的01背包


Q：01背包是什么？

A：背包问题中最简单的问题。**有n件物品和一个容量为V的背包。第i件物品的体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。**

Q：01背包有什么特别之处？

A：给定**几种**物品，每种物品**有且只有一个**，并且有**价值和体积**两个属性。

Q：在求解01背包的过程中每个物品要考虑几种情况？

A：对于每个物品只需要考虑**放与不放**两种情况。

   1.不放，则不需要处理。
   
   2.放，由于不清楚之前放入的物品占据了多大的空间，需要枚举将这个物品放入背包后可能占据背包空间的所有情况。

**由此可以得出，状态转移方程是：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}**

**解释一下这个方程，f[i-1][v]指的是不放这件物品，而f[i-1][v-c[i]]+w[i]指的是将第i件放入背包之后的总价值。**


    for (int i=2;i<=n;i++) {//1的约数和为0，直接从2开始
        for (int j=i;j<=n;j++) {
            f[j]=max(f[j],f[j-i]+a[i]);
        }
    }

------------
**回到题目本身，约数和用一个简单的函数就可以求出来了。**
```c
int yueshuhe(int m){
    int ans=0;
    for (int i=1;i<m;i++){
        if (m%i==0)  ans+=i;
    }
    return ans;
}

```
注意，这里的ans一定要在函数里面初始化为0，如果定义成全局变量会叠加。嗯，会挂。不信你试试吧，我不拦你。
------------



Q：状态转移方程是啥？能吃吗？（问着问着就饿了）

A：能吃。

**END**

---

## 作者：cs18 (赞：35)

//还是一道比较水的题，基本的01背包思想，注意找出与01背包的联系（只不过多了一步寻找约数和的过程）

//另外，数据也比较水，不需要筛法，暴力求解就行

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int a[1001],dp[1001],b[1001];
int find(int x)
{
    int ans=0;//ans记录x的约数和（注意，不包括自己），还有，一定要将ans初始化为0，本蒟蒻因为没有初始化浪费了半个小时； 
    for(int i=1;i<x;i++)//不包括x本身 
        if(x%i==0)
            ans+=i;
    return ans;
```
}//简单的函数
```cpp
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    a[i]=find(i);//进行一步预处理，a[i]表示i的约数和（不包括自己，第3遍强调） 
    for(int i=1;i<=n;i++)
        for(int j=n;j>=i;j--)//01背包基本模板 
            dp[j]=max(dp[j],dp[j-i]+a[i]);//i本身当做价钱，a[i]当做价值； 
    printf("%d ",dp[n]);//输出就好了 
}
```

---

## 作者：stars_abyss (赞：15)

这道题其实还是很~~水的~~难的

基本的01背包问题

```cpp
include <bits/stdc++.h>
using namespace std;
int s,a[1005],u[1005];//定义qaq
int find(int x)//求每个数最大公约数的和
{
int ans=0;//记住，一定要把ans初始化为0，一定要把ans初始化为0，一定要把ans初始化为0，重要的事说三遍；
for(int i=1;i<x;i++)
if(x%i==0)
ans+=i;
return ans;
}
int main()
{
cin>>s;
for(int i=1;i<=s;i++)
a[i]=find(i);//把和赋值给a[i]
for(int i=1;i<=s;i++)
{

    for(int j=s;j>=i;j--)  
    {
        u[j]=max(u[j],u[j-i]+a[i]);//01背包基本模板  
    }  
}  
cout<<u[s];//输出  

return 0;//每天一个return 0，身心更健康
}


```


# 只要会01背包，就一定会这题qaq  



---

## 作者：2018小绿 (赞：8)

- 如果知道每一个数的约数和的话，那么这道题可以直接变成0-1背包

### 体积代表每个数的大小
### 价值代表每个数的约数和（除它本身）

所以，此题关键就在于求出每个数的约数和

- 我会暴力！

~~巧了，我也会~~

- 有更优的算法吗？

有的有的。

我们考虑每一个数的唯一分解形式：

$x=\Pi p_{i}^{\alpha_{i}}$

所以，每个约数都可以看做是选$\beta_{i}$个$p_{i}$个质因数乘在一起

稍微因式分解一下，得到：

- 约数和$=\Pi\sum_{j=0}^{\alpha_{i}}p_{i}^{j}$

看不懂的话珂以手推一下

## 最后一个要点：

- 别忘了从约数和里减掉这个数自己

代码：

```cpp
const int maxn(1010);
template <typename T>
T max(T a,T b){
	return a>b?a:b;
}

int pri[maxn],cntpri;
int minpri[maxn];
void sieve(int n){
	for(int i(2);i<=n;++i){
		if(!minpri[i]){
			pri[++cntpri]=i;
			minpri[i]=i;
		}
		for(int j(1);j<=cntpri&&i*pri[j]<=n&&pri[j]<=minpri[i];++j){
			pri[i*pri[j]]=pri[j];
		}
	}
}

int w[maxn];
int dp[maxn];
#include<cstdio>
int main(){
	int s;
	scanf("%d",&s);
	sieve(s);
	for(int i(1);i<=s;++i){
		w[i]=1;
		int temp(i);
		for(int j(1);j<=cntpri&&pri[j]<=temp;++j){
			int now(1),ttemp(1);
			while(temp%pri[j]==0){
				now*=pri[j];
				temp/=pri[j];
				ttemp+=now;
			}
			w[i]*=ttemp;
		}
	}
    for(int i(1);i<=s;++i){
    	w[i]-=i;
    }
	for(int i(1);i<=s;++i){
		for(int j(s);j>=i;--j){
			dp[j]=max(dp[j],dp[j-i]+w[i]);
		}
	}
	printf("%d",dp[s]);
	return 0;
}
```

---

## 作者：wancong (赞：7)

## 数论+动态规划

首先，看数据范围限制，S<=1000，所以，可以用$O(n^2)$的算法来求解。

然后，想一下递推关系。`dp[i] = max{dp[i - j] + fact[j]}`，其中`fact[j]`表示`j`的所有因子之和，`0 <= j <= i`。这样显然需要两层循环进行递推。

如果要让递推这一步达到$O(n^2)$，则必须使`fact[j]`的求解达到$O(1)$。那么，`fact`显然需要事先求出，并且在这一步预处理的过程也不能高于$O(n^2)$。

当然，这一步预处理非常简单，对于一个数k，可以扫描小于k的所有数i，看是否能整除k；如果能整除，则表明它是一个因子，要加进去。最终，得到1--S的所有整数的fact，需要两层循环，时间复杂度为$O(n^2)$。

这样，我们的问题完美解决。

参考代码：

```cpp
#include <stdio.h>
#include <stdlib.h>

using namespace std;

int dp[1001], fact[1001];

int main() {
    int s, i, j;
    scanf("%d", &s);
    for (i = 2; i <= s; i++) {
        for (j = 2; j * j <= i; j++) {
            if (i % j == 0) {
                if (i / j != j) fact[i] += j + i / j;
                else fact[i] += j;
            }
        }
        fact[i]++; // 别忘了把1算进去！！
    }
    for (i = 2; i <= s; i++) {
        dp[i] = fact[i];
        for (j = 1; j < i; j++) {
            if (dp[i] < dp[i - j] + fact[j]) dp[i] = dp[i - j] + fact[j];
        }
    }
    printf("%d", dp[s]);
    return 0;
}
```

---

## 作者：AFOier (赞：7)

这题其实很简单，几乎裸的01背包

主要思路就是先把从1~s所有数的约数和算出来（如果数字比s大还有什么意义呢）

然后物品的重量（代码中用a数组存储）就是数字，物品价值就是约数和（代码中用b数组存储）

然后就是裸的01背包咯（而且只要一维）

```cpp
#include <iostream>
using namespace std;
int s,a[1001],b[1001],f[1001]; //定义数组 
int ys(int p)
{
    int s1=0;
    for(int j=1;j<=p-1;j++)//注意它本身不算，所以要-1 
    if(p%j==0)s1+=j; //如果是这个数的约数，约数和就加上这个数 
    return s1;//返回约数和 
}
int main()
{
    cin>>s; //输入 
    for(int i=1;i<=s;i++)//计算1~s每个数的约数和 
    b[i]=ys(i),a[i]=i;//转化成01背包后，b数组储存的是价值（约数和），a数组储存的是重量（数字） 
    for(int i=1;i<=s;i++)
    {
        for(int j=a[i];j<=s;j++)
        {
            if(f[j]<=(f[j-a[i]]+b[i]))f[j]=f[j-a[i]]+b[i]; //一维01背包 
        }
    }
    cout<<f[s]; //输出 
}
```

---

## 作者：Kevin_F (赞：7)

这个题还是不容易想到背包的。。

本人先用线性筛把所有的数判断一下存进mark数组中mark[i] == 1表示：i不是素数，反之是素数。
因为只有合数有约数，而素数的约数只有1和它本身，但要注意一点**：题目中要求的是不包含本身**，所以**1的约数和为0**。

然后就是管用的01背包了

本人从 2 开始枚举的所以就不用在处理c数组时就不用特别处理1了

以下就是AC的代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 1000001;

int s,ans,num;
int f[maxn],c[maxn];
//f[i]表示i的最大约数和  c[i]表示这个数的约数和 

int mark[maxn],prime[maxn];
void pd(int n){
	if(n == 1)  prime[1] = 1;
	memset(mark,0,sizeof(mark));
	int ans = 0;
	for(int i=2;i<=n;i++){
		if(mark[i] == 0){
			prime[++ans] = i;
		}
		for(int j=1;j<=ans && i*prime[j]<=n;j++){
			mark[i*prime[j]] = 1;
			if(i % prime[j] == 0)  break;
		}
	}
}

int main(){
	scanf("%d",&s);
	pd(s);
	for(int i=1;i<=s;i++){
		if(mark[i] == 1){
			num++;
			int t = 0;
			for(int j=1;j<i;j++)
			  if(i % j == 0){
			  	t += j;
			  	c[i] = t;
			  }
		}
		else c[i] = 1;//素数的约数和全部设为 1 
	}
	for(int i=2;i<=s;i++)//因为1的约数和为0  就从2开始了 
	  for(int j=s;j>=i;j--)
	    f[j] = max(f[j],f[j-i] + c[i]);
	printf("%d",f[s]);
	return 0;
} 
```

---

## 作者：Strong_Jelly (赞：4)

## 这道题其实就是一道01背包

01背包首先得有四个已知量

```
w[i]：每个物品的重量

c[i]：每个物品的价值

n：物品的数量

m：背包容量

```

我们先来看背包容量在题目中是什么，题目中说 “**不超过S**” 那么**背包容量m就是S了**。那么每个物体的重量一定和背包容量有关系，我们在 “不超过S” 的附近找发现题目中说 “**和不超过S的若干个不同的正整数**” 那么显而易见**每个物品的重量w[i]就是那个数它本身**，从这句话中也可以得出这个**背包问题是01背包**（因为是“**若干个不同的**”）。价值又是什么呢？看题目中说的“**使得所有数的约数（不含它本身）之和最大**”那么不就是**选的数中的约数和**吗？最后就剩下物品的数量了，既然w[i] = i，且和不超过S，那么w[i]最大就S，i最大也就是S，那么**物品数量n就是S**了。

四个已知量再看一遍：

```
w[i] = i

c[i] = i的约数

n = S

m = S
```

这里**求约数和**直接暴力就好了，再**预处理**一下就剩**01背包**了

**注意：是求约数和，不是求约数的个数**

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int S, n, m, c[1000001], w[100001], f[100001];//和01背包写的一样一样的 
inline int find_y(int x)//暴力求约数和 
{
	int ans = 0;
	for(register int i = 1; i < x; ++i)
	{
		if(x % i == 0)
		{
			ans += i;//是和，不是个数 
		}
	}
	return ans;
}
int main()
{
	scanf("%d", &S);
	//预处理 
	m = S;
	n = S;
	for(register int i = 1; i <= n; ++i)
	{
		c[i] = find_y(i);
		w[i] = i;
	}
	//01背包 
	for(register int i = 1; i <= n; ++i)
	{
		for(register int j = m; j >= w[i]; --j)
		{
			f[j] = max(f[j], f[j - w[i]] + c[i]);
		}
	}
	printf("%d", f[m]);
	return 0;
}
```


---

## 作者：墨凝而止 (赞：4)

AC100题纪念：

```delphi
var
a,f:array[0..6000]of longint;
i,j,s:longint;
function f1(k:longint):longint;{求因子和}
var i,j,sum:longint;
begin
  sum:=0;
  for i:=2 to trunc(sqrt(k)) do{因子范围}
  if (k mod i=0)then
  if (k div i<>i) then{两个对应因子}
  begin
  inc(sum,i);{加上因子}
  inc(sum,k div i);{另一个因子}
  end else inc(sum,i);{如果有sqr（i）=k 之状况，就只记i}
  exit(sum+1);{包括1}
end;
begin
  read(s);
  for i:=2 to s do begin a[i]:=f1(i);end;{赋值过价值}
  for i:=2 to s do
  for j:=s downto i do{01背包处理注意downto}
  if f[j-i]+a[i]>f[j] then f[j]:=f[j-i]+a[i];{01背包状态转移方程}
  write(f[s]);
end.[/cocep]
    [color=green]此题沿用01背包（因每一个数只能选一个）之路，重要之处在于先把2至s的因子和，作为背包价值，以自身为背包费用，即可。
                                                 墨凝   执笔[/color]

---

## 作者：Elaina_7 (赞：3)

##### 这道题是01背包
虽然暴力模拟可以过，但是代码的复杂度不言而喻（任意个数的组合）

虽然题目没有明面指出背包容量，但其实s就是隐含的背包容量，1-s就是每个物品的质量，因此1或2维背包皆可。

首先用一个打表程序把可选项列出

code：（from樱花飞舞）
```cpp
#include<cstdio>
int go(int x)
{
	int sum=0;
	for(int i=1;i<x;i++)
	{
		sum+=(x%i==0?i:0);
	}
	return sum;
}
int main()
{
	freopen("D:\\233.txt","w",stdout);
	printf("a[]={0,");
	for(int i=1;i<=1005;i++)
		printf("%d,",go(i));
	puts("}");
}
```
打表结果会在D盘的233.txt保存，一定要用写字板打开不然会换行（最后还会多一个逗号，少一个分号）

接下来我们就可以用打表的结果：数组a[]来表示价值，带人01背包模板就可以了

AC_code：
```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
int a[]={0,0,1,1,3,1,6,1,7,4,8,1,16,1,10,9,15,1,21,1,22,11,14,1,36,6,16,13,28,1,42,1,31,15,20,13,55,1,22,17,50,1,54,1,40,33,26,1,76,8,43,21,46,1,66,17,64,23,32,1,108,1,34,41,63,19,78,1,58,27,74,1,123,1,40,49,64,19,90,1,106,40,44,1,140,23,46,33,92,1,144,21,76,35,50,25,156,1,73,57,117,1,114,1,106,87,56,1,172,1,106,41,136,1,126,29,94,65,62,25,240,12,64,45,100,31,186,1,127,47,122,1,204,27,70,105,134,1,150,1,196,51,74,25,259,35,76,81,118,1,222,1,148,81,134,37,236,1,82,57,218,31,201,1,130,123,86,1,312,14,154,89,136,1,186,73,196,63,92,1,366,1,154,65,176,43,198,29,148,131,170,1,316,1,100,141,203,1,270,1,265,71,104,37,300,47,106,105,226,31,366,1,166,75,110,49,384,39,112,77,284,31,234,1,280,178,116,1,332,1,202,153,218,1,312,53,184,83,194,1,504,1,157,121,190,97,258,33,232,87,218,1,476,35,130,177,255,1,270,45,328,129,134,1,456,59,214,93,208,1,450,1,286,175,140,97,396,1,142,137,440,1,294,1,220,195,218,49,531,18,250,101,226,1,390,65,274,183,152,37,568,51,154,105,316,67,396,1,364,107,266,1,528,1,160,309,244,1,330,41,442,111,254,37,523,109,166,113,302,55,534,1,256,161,170,73,656,1,211,117,416,43,438,57,316,231,176,1,492,1,394,209,404,1,366,77,274,219,182,1,810,20,184,169,420,79,378,1,376,177,314,61,524,1,274,249,344,43,582,1,460,131,194,1,636,191,196,185,298,1,618,41,463,135,200,85,696,1,202,241,561,1,414,45,310,321,314,49,672,1,346,141,316,67,522,89,466,143,302,1,924,1,214,201,386,133,438,69,328,243,362,1,808,1,334,285,334,43,450,1,640,300,314,1,620,95,226,153,568,1,759,53,346,155,230,217,744,1,232,261,548,1,690,1,466,303,236,1,806,75,394,161,428,55,486,145,532,225,242,1,1032,51,244,285,447,103,606,1,442,167,536,1,684,47,346,441,496,79,510,1,592,171,254,1,1056,107,358,225,388,1,786,81,511,287,260,109,716,59,394,177,740,1,648,1,400,467,266,49,960,24,442,249,588,55,546,113,484,183,272,145,1140,1,274,185,590,115,798,1,418,257,566,49,888,87,280,357,424,1,690,57,928,303,284,1,780,119,286,401,512,1,870,1,604,195,434,169,1075,1,343,197,680,91,594,65,526,507,296,1,1008,51,490,201,586,1,846,269,454,203,410,1,1260,1,454,281,460,193,618,1,652,351,506,61,1026,1,310,393,824,1,630,1,724,339,314,97,1112,156,316,333,478,55,1242,1,568,215,320,133,876,161,442,297,890,1,654,1,700,411,434,1,1167,71,652,373,496,1,666,137,646,305,494,1,1356,1,334,345,596,295,816,53,508,227,554,73,1344,1,340,565,605,1,690,105,940,231,470,1,1136,143,514,233,676,67,1038,1,526,555,350,145,1104,59,352,237,1036,1,978,57,820,447,356,109,972,1,586,329,638,55,1014,293,544,243,362,1,1698,111,421,245,550,205,870,1,952,364,602,61,1004,1,370,633,776,79,900,1,856,379,554,1,1176,155,376,345,764,115,1122,1,736,255,506,157,1484,1,382,393,1040,1,774,117,580,639,386,73,1276,1,958,261,586,1,942,217,694,439,392,61,1572,83,514,417,983,163,798,1,598,267,650,121,1548,75,400,501,604,1,1122,65,1153,369,404,85,1100,347,538,273,722,1,1368,1,868,275,554,169,1416,63,412,637,944,1,834,1,736,663,614,1,1356,1,682,281,946,193,846,173,844,443,422,1,2040,30,424,285,640,253,1026,217,826,287,824,61,1164,1,634,705,764,1,1158,1,988,483,434,1,1656,179,436,361,924,91,1290,81,778,401,566,373,1196,1,442,297,1352,1,1341,1,880,555,446,1,1392,135,730,561,676,67,906,185,1144,447,452,61,1921,71,610,505,806,187,918,1,688,417,1106,1,1568,95,460,573,694,139,1242,1,1240,311,464,85,1764,253,466,425,962,1,1374,209,706,315,470,361,1794,1,694,317,1076,1,954,65,916,975,638,1,1292,87,910,321,1208,1,1152,197,724,483,482,145,2088,32,634,441,730,199,1338,1,1027,471,794,1,1576,147,490,761,946,1,990,101,1414,449,494,1,1536,203,634,549,972,67,1818,1,1024,335,734,205,1356,1,502,521,1340,343,1014,77,760,627}；
//打表
int s;
long long v[100000];
int main()
{
	scanf("%d", &s);
	for(int i = 1; i <= 1000; i ++)
	for(int j = s; j >= i; j --)
		v[j] = std::max(v[j], v[j - i] + a[i]);//一维优化
	printf("%lld\n", v[s]);
	return 0;
}
```

## THE END

---

## 作者：Mys_C_K (赞：2)

楼下的所有题解都在“吐槽”这道题很水！但是他们忽略（也许是dalao不屑于解释）了题目中一个问题：

数字不允许重复！起先蒟蒻还很奇怪楼下的01背包并没有处理这个问题。

本来以为数据有误，想了想，发现题目中说“不包含它本身”，这意味着，如果选择了两个相同的数字，

设这两个相同的数字为x，那么把这两个数替换成2x更优。

证明如下：由唯一分解定理，不妨设x=(2^k)\*(a1^p1)\*(a2^p2)\*...\*(an^pn)。

其中，对于任意1<=i<j<=n，ai≠aj，且对于任意1<=i<=n，由ai!=2且ai为质数，pi为正整数。k为非负整数。

用F(x)表示x的因数（不包括x）之和。则：

根据公式，有F(x)=(1+2+4+..+2^k)(1+a1+a1^2+...+a1^p1)(1+a2+a2^2+...+a2^p2)...(1+an+an^2+...+an^pn)-x

方便起见，记u=1+2+4+...+2^k，v=(1+a1+a1^2+...+a1^p1)(1+a2+a2^2+...+a2^p2)...(1+an+an^2+...+an^pn).

则F(x)=2uv-2x。因此，2F(x)=uv-2x。

由设，2x=(2^(k+1))\*(a1^p1)\*(a2^p2)\*...\*(an^pn)。

则依定义及公式，有F(2x)=(u+2^(k+1))v-2x=uv+2^(k+1)v-2x。

则F(2x)-2F(x)=[uv+2^(k+1)v-2x]-[2uv-2x]=2^(k+1)v-uv=v[2^(k+1)-u]。

有根据等比数列求和公式，可知u=1+2+4+...+2^k=[2^(k+1)-1]/(2-1)=2^(k+1)-1。

代入上式，得F(2x)-2F(x)=v{2^(k+1)-[2^(k+1)-1]}=v>0；

综上得证：F(2x)>2F(x)；即：若选择选相同的两个数字，将他们替换成他们的和，结果更优（而且是严格更优）。

因此DP的决策中保证了不会选择相同的数字。

然后据说不贴代码会被……所以贴上代码：

还有，一开始写了一个O(n^3)的dp，加了位运算优化min/max后神奇的拯救了我200ms+：

```cpp
#include<iostream>
#include<cstdio>
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))
using namespace std;
int dp[1010];
//dp[s]=max{dp[s-k]+sol[k]}
//1<=k<=s<=S
int sol[1010];
int main()
{
    int S;scanf("%d",&S);
    for(int i=1;i<=S;i++)
        for(int j=i*2;j<=S;j+=i)
            sol[j]+=i;
    for(int s=2;s<=S;s++)
        for(int k=1;k<=s;k++)
            dp[s]=max(dp[s-k]+sol[k],dp[s]);
    printf("%d\n",dp[S]);return 0;
}
```

---

## 作者：HoshiuZ (赞：1)

### 思路
本题实质就是一个背包问题。$s$为背包的容量，物品则为$1$到$s$间的所有数，物品的体积就是数的值，而价值则为数的除了本身的因子和。定义$fsum(x)$为$x$的非本身因子和，那么本题的状态转移方程便很容易得到了。
$dp[s]=max(dp[s],dp[s-i]+fsum(i))$，其中$i∈[1,s]$。
### 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

int s,dp[1010];

int fsum(int x) {
	int sum=0;
	for(int i=1;i<x;i++) {
		if(!(x%i)) sum+=i;
	}
	return sum;
}
		
int main() {
	cin>>s;
	
	for(int i=1;i<=s;i++) {
		for(int j=s;j>=i;j--) {
			dp[j]=max(dp[j],dp[j-i]+fsum(i));
		}
	}
	
	cout<<dp[s]<<endl;
	
	return 0;
}
```


---

## 作者：peterwuyihong (赞：1)

如果一个数为s=2^p1×3^p2×5^p3×...

此数的约数和为(2^0+2^1+...+2^p1)×(3^0+3^1+...+3^p2)...

按题目要求就是(2^0+2^1+...+2^p1)×(3^0+3^1+...+3^p2)...-x

这个代码贴一下
```cpp
int QAQ(int x)
{
	int g[1001];//g[i]=j表示x有约数i^j
	int tmp=x;
	memset(g,0,sizeof g);
	int l=2;
	while(x!=1)
	if(x%l==0)x/=l,g[l]++;
	else l++;
//	for(int i=2;i<=1000;i++)
//	if(g[i]!=0)cout<<i<<':'<<g[i]<<endl;
	int ans=1;
	for(int i=2;i<=1000;i++)//核心算法
	if(g[i]!=0)
	{
		int res=0;
		for(int j=0;j<=g[i];j++)
		res+=pow(i,j);
		ans*=res;
	}
	return ans-tmp;//减掉本身
}
```
完整代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1001];
int a[1001]={0,0};
int QAQ(int x)
{
	int g[1001];
	int tmp=x;
	memset(g,0,sizeof g);
	int l=2;
	while(x!=1)
	if(x%l==0)x/=l,g[l]++;
	else l++;
//	for(int i=2;i<=1000;i++)
//	if(g[i]!=0)cout<<i<<':'<<g[i]<<endl;
	int ans=1;
	for(int i=2;i<=1000;i++)
	if(g[i]!=0)
	{
		int res=0;
		for(int j=0;j<=g[i];j++)
		res+=pow(i,j);
		ans*=res;
	}
	return ans-tmp;
}
int main()
{
	int n;
	cin>>n;
	for(int i=2;i<=1000;i++)a[i]=QAQ(i);
	for(int i=1;i<=n;i++)
	for(int j=n;j>=i;j--)
	f[j]=max(f[j-i]+a[i],f[j]);//背包
	cout<<f[n];
}

```

---

## 作者：feecle6418 (赞：1)

01背包+预处理，挺好做的，关键是想不想得到这个点子上

```cpp
#include<iostream>
using namespace std;
int f[1000001],w[1001],c[1001];
int factor(int n){
    int i,s=0;
    for(i=1;i<n;i++){
        if(n%i==0)s+=i;//约数和函数
    }
    return s;
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        w[i]=i;//重量=他本身
        c[i]=factor(i);//价值=约数和
    }
    for(int i=1;i<=n;i++){
        for(int j=n;j>=w[i];j--){
            f[j]=max(f[j],f[j-w[i]]+c[i]);//背包模版
        }
    }
    cout<<f[n];//华丽丽地结束
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

其实就是一个背包，n为质量。约数和为他的价值。真的很水

```cpp
var
  f:array[0..1000000] of longint;
  min,i,j,n,sum:longint;
function max(i,j:longint):longint;
begin
  if i>j then exit(i)
  else exit(j);
end;
function he(i:longint):longint;
var
  k,j,sum:longint;
begin
  sum:=0;
  k:=trunc(sqrt(i));
  for j:=1 to k do begin
    if i mod j=0 then begin
      sum:=sum+j+(i div j);
    end;
  end;
  if i=k*k then sum:=sum-k;
  sum:=sum-i;
  exit(sum);
end;
begin
  min:=0;
  readln(n);
  for i:=1 to n do begin
    for j:=i to n do begin
      f[j]:=max(f[j-i]+he(i),f[j]);
    end;
  end;
  for i:=1 to n do begin
    if min<f[i] then min:=f[i];
  end;
  writeln(min);
end.

```

---

## 作者：HeMeng (赞：1)

这道题没什么难度，数据最大只有1000，先将1~n之间的每个数的约数和。

然后就跟那些求最大价值的题目一样，状态转移式方程：f[j]:=f[j-i]+a[i];

```cpp
var
f,a:array[0..2000]of longint;//变量
n,i,j:longint;
begin
  readln(n);//读入
  for i:=1 to n do
  begin
    for j:=1 to n do
    if (i mod j=0)and(i<>j) then inc(a[i],j);//必须是约数且不是本身
  end;
  f[0]:=0;
  for i:=1 to n do
  for j:=n downto i do
  if f[j]<f[j-i]+a[i] then f[j]:=f[j-i]+a[i];  //判断是否比当前最优解更优，相加
  writeln(f[n]);//相加
end.
```

---

## 作者：Lidy (赞：0)

思路：
      
        拿到此题，首先要学会转化问题，由特殊到一般，正如此题，
	    此题其实就是01背包问题的演变； 
	    把s转化为背包容量，数字的权值转化为物品重量，

程序：
```cpp
#include<iostream>
using namespace std;
int f[1005][1005],a[1005],n,i,j,k,ans=0;
int main()
{  
    cin>>n;
    for(i=1;i<=n;i++)
        for(j=1;j<=i/2;j++)if(i%j==0)a[i]+=j;
        //因为题目说约数不包含本身，故枚举到i/2即可
		//a[i]相当于储存01背包里的价值 
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {  
		    f[i][j]=f[i-1][j];
            if(j>=i)f[i][j]=max(f[i-1][j-i]+a[i],f[i][j]);
            //01背包的模板（i相当于物品的重量，a[i]相当于物品的价值）
			//也可以理解为dp的状态转移方程 
        }
    cout<<f[n][n]<<endl;
    return 0; 
}

```

---

## 作者：stephen→_→ (赞：0)

### 运用线性筛的原理+背包一遍就ok了，通过分析题目可以看出，给出的n就是背包容量，因为不能大于n嘛。第i个数的约数和就是第i个数的价值，第i个数的约数和，就是第i个数的大小，标准的01背包~~，具体看代码：
---
```cpp

#include <iostream>
#include <cstdio>
//头文件
using namespace std;

int n,a[10005],f[10005],x;

int main(){

	scanf("%d",&n);
	for(int i = 1; i <= n; ++i){
		//约数和最多到n
		x = i * 2;
        //找出当前i的最小倍数，当前的i，*2后一定是i的最小倍数
---
### 看到楼下很多大佬都是暴力求当前数的约数和，那我就换一种方式，把在i的倍数的约数和（还没求出的约数和）加上i（因为i肯定是它倍数的因子），一遍一遍的找i的倍数，然后在那个位置上加上i就行了，一次更新一遍数组。~~（然而时间看上去好像也差不多...）~~具体见代码：
		while(x <= n){
			a[x] += i;
			x += i; 
		}
---
		x = 0;
	}
	for(int i = 1; i <= n; ++i)
		for(int j = n; j >= i; --j){
        //说是01背包模板，但是循环还是得注意一下的（n既是“物品”个数，也是容积大小）
			if(j - i >= 0)
			f[j] = max(f[j],f[j - i] + a[i]);
            //01背包的状态转移方程
		}
	printf("%d",f[n]);
    //输出最后一个，必定是最优解
	return 0;
}

//最后祝大家AC愉快~

---

## 作者：半仙胡小桃 (赞：0)

预处理出每个数的约数和。

把每个数的大小看出质量，约数和看为价值，s为最大的背包质量。

这样就转化为01背包了

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
int ys[1011];
int dp[1100];
void pre()
{
    for(int i=1;i<=1000;i++)
     {
         for(int j=1;j<=sqrt(i);j++)
          if(i%j==0)
          {
              ys[i]+=j;
              if(j*j!=i) ys[i]+=(i/j);
          }
          ys[i]-=i;
          //printf("%d ",ys[i]);
     }
}
int main()
{
    pre();
    int s;
    scanf("%d",&s);
    for(int i=2;i<=s;i++)
     for(int j=s;j>=i;j--)
      dp[j]=max(dp[j],dp[j-i]+ys[i]);
    printf("%d",dp[s]);
}
```

---

## 作者：doby (赞：0)

01背包系列……

先把每个数字装在容量数组，再把每个数字的约数和装在价值数组里，然后就是愉快的01背包咯……

然后01背包一维转移方程应该不用说了，自己找吧……

```cpp
#include<iostream>
using namespace std;
int f[10001],w[10001],v[10001],n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){w[i]=i;for(int j=1;j<i;j++){if(i%j==0){v[i]=v[i]+j;}}}//处理每个数的约数和
    for(int i=1;i<=n;i++)
    {
        for(int j=w[i];j<=n;j++)
        {
            if(f[j]<=f[j-w[i]]+v[i]){f[j]=f[j-w[i]]+v[i];}//01背包转移方程
        }
    }
    cout<<f[n]; //输出最大约数和
}
```

---

## 作者：Crazily (赞：0)

我们可爱的老师出的卷子中有这题。。。

所以来一发题解，纪念一下考试时第一次用了打表。。。。。

**以下正题**:

首先我们看到了

选取和不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。

所以如果用暴力的话似乎复杂度爆表。。。。

然后我们会想到Smax=Amax+Bmax

这个方程我们再熟悉不过了

没错就是背包！！！！

既然我们知道是背包就很简单了

这题首先要在知道此数在不分解情况下的最大和

然后才能放入背包

接下来是我们熟悉的背包DP

楼下DALAO们都写了解释

在此边不在废话了

最后让我们翻到题目的最后

看到了一个醒目的数据范围

S<=1000

于是，就使用了打表。。。。。

这里粘上打表的1MS的表。。。

```

```


---


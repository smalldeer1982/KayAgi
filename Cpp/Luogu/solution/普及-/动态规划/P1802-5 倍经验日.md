# 5 倍经验日

## 题目背景

现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。

## 题目描述

现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。

由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。

现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。

要求求出最大经验 $s$，输出 $5s$。

## 说明/提示

**【Hint】**

五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。

**【数据范围】**

- 对于 $10\%$ 的数据，保证 $x=0$。
- 对于 $30\%$ 的数据，保证 $0\le n\le 10$，$0\le x\le 20$。
- 对于 $60\%$ 的数据，保证 $0\le n,x\le 100$， $10<lose_i,win_i\le 100$，$0\le use_i\le 5$。
- 对于 $100\%$ 的数据，保证 $0\le n,x\le 10^3$，$0<lose_i\le win_i\le 10^6$，$0\le use_i\le 10^3$。

**【题目来源】**

fight.pet.qq.com

absi2011 授权题目

## 样例 #1

### 输入

```
6 8
21 52 1
21 70 5
21 48 2
14 38 3
14 36 1
14 36 2
```

### 输出

```
1060```

# 题解

## 作者：半仙胡小桃 (赞：196)

一个变形版的01背包。

dp[i]表示用i瓶药获得的最多经验。

**决策？**

当i>=use时，可以选择打败或者不打败

dp[i]=max(dp[i]+lose,dp[i-use]+win)。

当i<use时，无法战胜对方。

dp[i]+=lose

至于数据范围，最后输出时强制转换一下就行了。

    
    
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int dp[1100];
int win[1100],lose[1100],use[1100];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
     scanf("%d%d%d",lose+i,win+i,use+i);
    for(int i=1;i<=n;i++)
     {
         for(int j=m;j>=use[i];j--)
          dp[j]=max(dp[j]+lose[i],dp[j-use[i]]+win[i]);
         for(int j=use[i]-1;j>=0;j--)
          dp[j]+=lose[i];
     }
     printf("%lld",5ll*dp[m]);
}
```

---

## 作者：RichardH (赞：60)

几乎就是背包了，不多说

转移方程f[i][j]=max(f[i-1][j-use[i]]+win[i],f[i-1][j]+lose[i])

j<use[i]的话就是f[i-1][j]+lose[i]了

贴个代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;
long long f[1001][1001]={0};
int main(){
    int lose[1001],win[1001],use[1001];
    int n,x;
    cin>>n>>x;
    for (int i=1;i<=n;i++)
      cin>>lose[i]>>win[i]>>use[i];
    for (int i=1;i<=n;i++)
      for (int j=0;j<=x;j++)
        if (j>=use[i]) f[i][j]=max(f[i-1][j-use[i]]+win[i],f[i-1][j]+lose[i]); else f[i][j]=f[i-1][j]+lose[i];
    cout<<f[n][x]*5;
    return 0;
}
```
有一个点要用LONG LONG,虽然我也不知道为什么

嗯就这样，退役之前留点痕迹


---

## 作者：c201904 (赞：54)

/\*这道题其实就是一个变形的01背包，只不过选项不同，选输，并不用任何药（贪心）或者用药并打赢，我一开始就拆解成了2\*n个普通的01背包，前n个代表赢的，后n个代表输的，这是经典的错误解法，因为这样就有可能导致一个人被打过两次或者没有被打过，而这并不符合题意，因为每个人都要被打一次

\*/
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int maxn=1006;
long long f[maxn];//一定要用long long！不然只能得90分
long long a[maxn][2];//存赢和输的情况，a[i][0]代表输的，a[i][1]代表赢得
long long b[maxn];
int main(){
    int n,x1;
    scanf("%d%d",&n,&x1);
    long long x,y,z;
    for(int i=1;i<=n;i++){
          scanf("%lld%lld%lld",&x,&y,&z);
        a[i][0]=x,a[i][1]=y,b[i]=z;
    }
    for(int i=1;i<=n;i++){
        for(int j=x1;j>=0;j--){
            if(j>=b[i]){//如果有足够的药剂打赢别人，则看是输好还是赢好
                f[j]=max(f[j]+a[i][0],f[j-b[i]]+a[i][1]);
            }
            else f[j]+=a[i][0];//没有足够药剂就一个都不用直接认输，不然就浪费了药剂
        }
    }
cout<<5*f[x1];//记得是五倍经验！
}
```

---

## 作者：S_C_Yesterday (赞：36)

显然是一道背包问题。根据样例可以判断是01背包。

# 因此这是一道水dp。

水题的好处在于可以任性地发挥，~~例如当年的A+B Problem。~~

根据题意，选与不选都有价值。这就很奇怪。根据平时做的题目来看，不选价值为0，选择价值为正。

### 那么进入正题

我们是否可以把输掉得到的经验看作一个基础值，在这之上加上一个加成时，就变成了胜利获得的经验呢？

## 这样一来，本题就变成了纯粹的01背包。

将基础值存放在$sum$变量里，最后加上得到的最优解，乘5，得到答案。

下面是$cpp$代码。（本来想用$c$实现，但是$c$没有$long$ $long$，会炸）

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()//快读
{
	int re=0;
	char c=getchar();
	while(c>'9'||c<'0'&&c!='-')c=getchar();
	if(c=='-')
	{
		c=getchar();
		while(c<='9'&&c>='0')
		{
			re=(re<<1)+(re<<3)-'0'+c;
			c=getchar();
		}
		return -re;
	}
	while(c<='9'&&c>='0')
	{
		re=(re<<1)+(re<<3)-'0'+c;
		c=getchar();
	}
	return re;
}
long long n,v,lc,wc,w,opt[1001],sum;//其实opt[]开long long就可以了
int main()
{
	n=read();
	v=read();
	while(n--)
	{
		sum+=lc=read();//sum加上基础值
		wc=read()-lc;//加成值
		w=read();
		for(register int j=v;j>=w;--j)if(opt[j]<opt[j-w]+wc)opt[j]=opt[j-w]+wc;//经典01背包状态转移
	}
	sum+=opt[v];
	printf("%lld\n",(sum<<2)+sum);//位运算版*5
	return 0;//结束，AC
}
```

细心的同学会发现……

# 数组竟然只有$opt[]$一个？？？

没错，下面的才是重点。

在比赛过程中，我们有时为了满足空间要求，必须对数组进行**降维打击**（《三体3》乱入）。例如01背包的基本实现中，$opt[]$本身是$opt[][]$，为了避免空间冗余，才将其压缩至一维。 $P1002$过河卒 的滚动数组题解正是这个道理。

我们在做背包时，往往会用数组读入，但是我们有没有想过，ci和wi在程序中出现了几次？

## 输入一次，状态转移一次。

那么，既然我们已经把背包容量另先读入了，我们就可以一边读入c和w一边进行状态转移，不仅减少了O(n)的空间复杂度，还使编程复杂度大大降低，不失为一种有效的优化方式。

# 最后，资瓷洛谷！希望洛谷的小伙伴们能在比赛中取得佳绩！

---

## 作者：神犇梦的蒟蒻 (赞：31)

~~你谷第一篇题解，真TM激动~~

开始正篇

这题也是道对蒟蒻比较友好的动归练习题目
假设你还有i瓶药，你的某个朋友要a瓶药才能怼死。

当a<=i时

如果你不怼，那你还剩i瓶药，经验加（失败经验）

如果你怼，那你还剩i-x瓶药，经验加（获胜经验）

当x>i时 我们没有没有办法，只能失败，参照上方不怼时（当然是不会用药打必输局的）；

现在每个人输入一个lose（失败经验） win（获胜经验）yao（打死需要的药）

从0轮到x-yao（可以选择怼或不怼）
```
for(int l=0;l<=x-yao;l++)
f[l]=max(f[l]+lose,f[l+yao]+win);//f[l]表示还有多少药
```
从x-yao+1轮到x（怼不起）
```
for(int l=x-yao+1;l<=x;l++)
f[l]+=lose;//不用药，用药就是浪费。
```
最后输出发f[0]*5，药都用完能拿多少经验，记住5倍经验日！！

AC代码
```
#include<bits/stdc++.h>
using namespace std;
long long int n,m,win,lose,yao;
long long int f[1010];//一定要longlong！90分的教训
int main()
{
	cin>>n>>x;
	for(int i=1;i<=n;i++)
	{
	cin>>lose>>win>>yao;
	for(int l=0;l<=x-yao;l++)
	f[l]=max(f[l]+lose,f[l+yao]+win);	
	for(int l=x-yao+1;l<=x;l++） 
	f[l]+=lose;
    }
    cout<<f[0]*5;
}
```
别复制，理解!!(复制没用的，信我）

---

## 作者：Dr_殇 (赞：24)

##一道裸的01背包，特别简单。不过只是需要注意不用药打的人也要算在重量内

#题目分析

简单的01背包，不过实在01背包的基础上加了一个小小的变化，也就是不用药打也是要算在重量内。

所以可得动态转移方程：

f[j]=max(f[j]+lost[i],f[j-use[i]]+win[i]) (当j>=use[i]时)

f[j]=f[j]+lost[i] (当j<use[i]时）

##代码如下：


    
    
    
```cpp
    //--新阶梯工作室防伪水印--
    //--By新阶梯工作室 闪现--
    #include <ctime>
    #include <cmath>
    #include <cstdio>
    #include <string>
    #include <cstring>
    #include <cstdlib>
    #include <iostream>
    #include <algorithm>//头文件准备
    #define in freopen (".in","r",stdin)
    #define out freopen (".out","w",stdout)
    #define INF 2147483647
    #define UNINF -2147483648ll
    #define ch char
    #define bo bool
    #define ui unsigned int
    #define ll long long//闪现为了少打几个字符，弄了好多好多宏定义
    using namespace std;
    int n,v,c[1005];
    ll f[1005],w1[1005],w2[1005];//要用long long类型数组，要不然会爆
    inline void work();
    int main(){
        //in;out;
        work();
        return 0;
    }
    inline void work(){
        scanf ("%d %d",&n,&v);
        for (int i=1;i<=n;i++){
            scanf ("%lld %lld %d",&w1[i],&w2[i],&c[i]);
            w1[i]*=5;
            w2[i]*=5;//一开始就把5乘了，要不然容易忘记
        }
        for (int i=1;i<=n;i++){
            for (int j=v;j>=c[i];j--){//注意：01背包是从v到c[i]，不是从c[i]到v
                f[j]=max(f[j]+w1[i],f[j-c[i]]+w2[i]);//动态转移方程一
            }
            for (int j=c[i]-1;j>=0;j--){
                f[j]+=w1[i];//动态转移方程二
            } 
        }
        printf ("%lld\n",f[v]);//最后一定要用%lld输出
    }

```

---

## 作者：Samsam (赞：20)

这是一道变了形的01背包

首先我们因为和每个人打都一定有经验所以一定都要打一遍。

所以不难想到max=lose[1]+lose[2]......+lose[n]+某些磕了药打赢的多出的经验值

因此我们可以进行一个转换，把价值记为win[i]-lose[i]，溶剂就是要打赢磕的药，然后要使价值总和最大，然后就变成了基础的零一背包了。。。

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[100005];
long long f[1000005];
int win[100005];
int v[100005];
int lose[100005];
int main()
{
    int n,m;
    int sum=0;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d%d%d",&lose[i],&win[i],&v[i]);
        a[i]=win[i]-lose[i];
        sum=sum+lose[i];
    }
    for (int i=1;i<=n;i++){
        for (int j=m;j>=v[i];j--){
            f[j]=max(f[j],f[j-v[i]]+a[i]);
        }
    }
    printf("%lld",5*(f[m]+sum));
    return 0;
}
```

---

## 作者：Mr_QwQ (赞：11)

这题有坑。。当我N次90分后才发现这TM要用long long。。。

这题是典型的01背包。但是貌似不太好看，因为……好吧，我的意思是楼下几位巨神的转移我有点看不懂=.=

好吧，贴一个稍微好理解一点的

首先，假如你打一个boss，赢了x经验，输了y经验（自然x>y），那么你的想法是什么？或者说，怎样才能最方便？

我的想法是：打的时候先给你加y经验，如果赢了，再加（x-y）经验。

那么明显了吧？思路就是先把输掉的经验加上去，然后把赢的经验win[i]变成win[i]-lose[i]。

然后就是裸的01背包了……

最后不要忘记累加输掉的经验。

代码：

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long win[1001]={},lose[1001]={},use[1001],f[1001]={},ohno=0,n,x;
    cin>>n>>x;
    for(int i=1;i<=n;i++)
    {
        cin>>lose[i]>>win[i]>>use[i];
        ohno+=lose[i];
        win[i]-=lose[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=x;j>=use[i];j--)
          f[j]=max(f[j],f[j-use[i]]+win[i]);
    }
    cout<<(f[x]+ohno)*5;
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：8)

突然发现本题竟然没有一篇pascal题解。。。。

本蒟蒻郑(wu)重(chi)地来水一波pascal题解。

神犇别吐槽。。。

一道水DP

别看题目难懂（一看就懂），就是一个01背包

f[i]表示最多用i瓶药能得到的最多经验值

考虑状态转移方程：

1、能嗑药打败当前敌人，那就嗑药和不嗑药两种情况比较 f[i]=max(f[i]+输的经验值,f[i-嗑药数量]+赢的经验值)

2、药不够，那就加上输的经验值 f[i]=f[i]+输的经验值

最终输出f[m]即可~~~



```cpp
uses math; //偷懒使用math库~~
var
    l,w,a,f:array[0..1000] of int64;
    n,m,i,j:longint;
begin
    readln(n,m);
    for i:=1 to n do
        begin
            readln(l[i],w[i],a[i]);
        end;
    for i:=1 to n do
        begin
            for j:=m downto a[i] do //能嗑药打败别人的情况
                f[j]:=max(f[j]+l[i],f[j-a[i]]+w[i]);
            for j:=0 to a[i]-1 do //药不够的情况
                inc(f[j],l[i]);
        end;
    writeln(f[m]*5); //不要忘了乘5
end.
```

---

## 作者：k2saki (赞：6)

这道题其实就是普通的01背包

每种物品有两种状态:用药打，或直接打。

看到这里，就可以立马想到是01背包了。

### 注意：这里如果不用足药是一定打不过的！

如果您还不会01背包，请移步[此处](https://www.luogu.org/problem/P1048)

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
long long v[10001]={0},t[1001],w[1001],l[1001];
int main() {
	int m,n,i,j;
	cin>>n>>m;
	for(i=1;i<=n;++i)
	{
		cin>>l[i]>>w[i]>>t[i];
	}
	for(i=1;i<=n;++i)
	{
		for(j=m;j>=t[i];--j)
		{
			v[j]=max(v[j]+l[i],v[j-t[i]]+w[i]);
		}
		for(int j=t[i]-1;j>=0;j--)
        	v[j]+=l[i];
	}
	cout<<v[m]*5;//别忘了乘5！
	return 0;
}
```

## 注意：是5倍经验日，所以答案要乘5

---

## 作者：zirrtu (赞：6)

看到还没有记忆化的就来一发记忆化搜索的吧；

在同一问题上，记忆化搜索个人感觉比较好想，但是dp速度快是事实；但只是常熟级别

所以可以先写搜素在转化为记忆化搜索，再转dp就很容易了；

以下上代码：

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#define MAXN 1010
#define INF 9999999
using namespace std;
int n,x;
long long a[MAXN],b[MAXN],c[MAXN],dp[MAXN][MAXN];
long long dfs(int now,int less)
   {
      int i;
      if(dp[now][less])return dp[now][less];
      if(less<0)return -INF;
      if(now==n+1)return 0;
      dp[now][less]=max(dfs(now+1,less-c[now])+b[now],dfs(now+1,less)+a[now]);
      return dp[now][less];         
   }
int main()
   {
       int i,j,k;
       scanf("%d%d",&n,&x);
       for(i=1;i<=n;i++)
         scanf("%d%d%d",&a[i],&b[i],&c[i]);
       cout<<dfs(1,x)*5;
       return 0; 
   }
```

---

## 作者：nothingness (赞：3)

## 我说这题和01背包一模一样你信吗？

标准的01，不会的请进入[背包九讲](https://www.kancloud.cn/kancloud/pack/70124)

我们可以这样想：
因为不管赢了或输了都有经验，所以我们可以进行转化：假设全输，那么也会有一定的经验作为初始经验，而如果赢了，那么会额外获得 ${win[i]-lose[i]}$ 的经验;此时若输了,就没有经验；要嗑药的数量就是代价，此时就是一道完全标准的01，然后......~~套公式...~~

## Code 
```cpp
#include "bits/stdc++.h"
using namespace std;

long long n,m,t,sum,v[1001],w[1001],f[1001];

int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld%lld",&t,&v[i],&w[i]),sum+=t,v[i]-=t;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=w[i];j--)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	printf("%lld",(sum+f[m])*5);
}
```

---

## 作者：littlegagaduck (赞：2)

蒟蒻的dp一直不好，可能有的不好理解不够详细甚至会出错，~~还请大家关爱我这样的蒟蒻。~~

首先，打这个人输掉的情况，属性药是一定不用的（感觉有点贪心的思想） ，如果用了会构成浪费，影响赢掉的比赛场数。

dp的过程也并不难想，既然有两种情况可以选择，那么就要转移两次，鉴于两次转移赢掉的需要"嗑药"，而输的比赛根据上面所说的是不用"嗑药"的，
因此两者的转移的范围也是不同的，要分开写。

写这道题时我没有用滚动数组，原因是一开始没有考虑到滚动数组的合理性，总觉得既然每个人都要用，就必须确定是从上一个人转移过来，我想先说说这个
思路。

既然每个人都要用，所以写max(f[i][j],f[i-1][j-w[i]]+c2[i])（i代表第几个对手，j是用的药物的数量），关于理解这句代码可以考虑第一次来到这里比较时，因为起初
f[i][j]为0，这样写能保证第一次比较一定会存下 f[i-1][j-w[i]]+c2[i]的值，这也就意味着i这个对手一定会参与最后的解的构成（这句话可能说的不那么好理解，还请大家仔细思考，~~蒟蒻语文水平欠佳~~）。

至于滚动数组，既然失败的情况中不用消耗药，那么这种情况对于滚动数组来说是"没有消耗而加上价值"，这种情况没有比较（max函数），因此一定加到数组所表达的情况中，这便保证了每个对手一定会被至少"对战"一次。蒟蒻自己感觉滚动数组的写法还是不太好理解的，如果有像我一样的蒟蒻，建议还是要先理解透彻非滚动数组的写法。

最后一个点好像要开long long处理，大家注意下。 

滚动数组的代码因为不是很懂就没有再写，大家可以参考其他大佬的题解进一步学习。

```cpp
#include<iostream>
using namespace std;
long long c1[10000]={0},c2[10000]={0},w[10000]={0},f[1010][1010]={0};
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>c1[i]>>c2[i]>>w[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=w[i];j--)
		{
			f[i][j]=max(f[i][j],f[i-1][j-w[i]]+c2[i]);
		}
		for(int j=m;j>=0;j--)
		{
			f[i][j]=max(f[i][j],f[i-1][j]+c1[i]);
		}
	}
	cout<<f[n][m]*5;
	return 0;
} 
 
```


---

## 作者：嘟嘟cqy (赞：2)

好像我的思路和题解们的不大一样~~也许是本人脑回路清奇~~  
首先，显然无论嗑不嗑药，lose[i]所能获得的经验是一定可以获得的。而打赢之后所多获得的经验就为win[i]-lose[i].   
这样就有了预处理：
```cpp
for(int i=1;i<=n;i++)
{
	cin>>lose[i]>>win[i]>>used[i];
	win[i]-=lose[i];
	sum+=lose[i];
}
```

然后直接是裸的01背包   
DP方程：dp[j]=max(dp[j],dp[j-used[i]]+win[i]);

~~PS:long long。~~

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5001;
long long n,V,lose[maxn],win[maxn],used[maxn],sum,dp[maxn];
int main()
{
	
	cin>>n>>V;
	for(int i=1;i<=n;i++)
	{
		cin>>lose[i]>>win[i]>>used[i];
		win[i]-=lose[i];
		sum+=lose[i];
	}
	for(int i=1;i<=n;i++)
	    for(int j=V;j>=used[i];j--)
            dp[j]=max(dp[j],dp[j-used[i]]+win[i]);
    cout<<5*(dp[V]+sum)<<endl; 
	return 0;
} 
```

---

## 作者：Playnext (赞：2)

蒟蒻的第一篇题解.....

这道是经典的01背包

状态转移方程应该不难推出

用药水打赢时    F[i]=max(F[i],F[i-use]+win)

不用药水，经验当然要拿    F[i]=max(F[i],F[i]+lose)

以下为代码

'''cpp
```cpp
#include <bits/stdc++.h>    //万能头文件 
using namespace std;
#define REG register
#define FOR(X,Y,Z) for (REG int X=Y; X<Z; X++)    //宏定义 
const int MAXN=1e3+1,INF=0,MOD=1000000009;
long long F[MAXN];        //不用long long 会溢出 
int main()
{
//    freopen ("Input.txt", "r", stdin);
//    freopen ("Output.txt", "w",stdout);
    REG int n,x,win,lose,use;    scanf ("%d %d",&n,&x);
    FOR (i,0,n)     {        //边读边计算 ，可以节约一个数组
        scanf ("%d %d %d",&lose,&win,&use);
        for (REG int h=x; h>=0; h--)
            if (h >= use)        //当药水够用
                F[h]=max(F[h],max(F[h]+lose,F[h-use]+win));
                    //有些数据输的经验还远远大于之前的，再取一次max 
            else    // 当药水不够用
                F[h]=max(F[h],F[h]+lose);
    }    printf ("%lld\n",F[x]*5);    //最后别忘了乘5 
    return 0;
}
'''
```

---

## 作者：Undefined_Myth (赞：2)

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define INF 1000+5
#define MAXX 1000+5
int n,x;
int lose[INF+1],win[INF+1],use[INF+1];
long long dp[MAXX+1];//dp[v]代表瓶数不超过v瓶时最大能够获得的经验 
int main() 
{
    scanf("%d%d",&n,&x);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&lose[i],&win[i],&use[i]);
    for(int i=1;i<=n;i++)
        for(int v=x;v>=0;v--)//这是变形的01，选不来也会有消耗，而且有经验
            if(v>=use[i])//即使支付的起话也可以不选 因为要最大我们可以适当的贪心一瓶药也不用就打 
                dp[v]=max(dp[v-use[i]]+win[i],dp[v]+lose[i]);
            else
                dp[v]=dp[v]+lose[i];//药瓶不够也要拿到打不过的经验
    printf("%lld",dp[x]*5);//一定要记得最后要乘以5，呵呵5倍经验日题目的温馨提示 
        return 0; 
}//这是一道变了形的dp题，再选或者不选中间不同的是不选也有价值可以获得
```

---

## 作者：cx51y (赞：1)

本题是一道01背包问题，不同的地方在于

当背包装不下物体时，还可以获得价值（经验）

因此在原来的基础上改下就行了


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1001;
int n,m;
long long f[N][N];
struct node
{
    int lose,win,md;
}a[N];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&a[i].lose,&a[i].win,&a[i].md);
    for(int i=1;i<=n;i++)
        for(int j=m;j>=0;j--)
        {
            if(j-a[i].md>=0)f[i][j]=max(f[i-1][j-a[i].md]+a[i].win,f[i-1][j]+a[i].lose);//装得下的时候取最大值
            else f[i][j]=f[i-1][j]+a[i].lose;//装不下
        }
    printf("%lld\n",f[n][m]*5);
    return 0;
}
```

---

## 作者：wuziban (赞：1)

#我来讲讲这个题的一些问题吧#

首先，关于题意，就是DP时考略两种决策，一种是输一种是赢，本质上是01背包。

第二，此题的数据有些坑，必须用long long，尝试了二维DP，30分。换了一维DP，90分，卡在第九个测试点。我想了很久都无法解决问题。后来，我仔细看了看第九个测试点输出情况，发现，是负数，就像可能是输出有问题，我设的是long long，输出却是%d，最后我尝试使用cout流输出解决，成功AC。附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[1002]={0},l[1002],w[1002],u[1002],n,x;
int main() {
    scanf("%d %d", &n, &x);
    for(int i = 1; i <= n; i++) scanf("%d %d %d",&l[i],&w[i],&u[i]);
    for(int i = 1; i <= n; i++)
        for(int j = x; j >= 0; j--)
            if((j >= u[i])&&(dp[j]+l[i]<dp[j-u[i]]+w[i])) dp[j] = dp[j-u[i]]+w[i];
            else dp[j] = dp[j] + l[i];
    cout<<dp[x]*5<<endl;
    return 0;
}
```

---

## 作者：jws666 (赞：1)

#背包问题不多说

##在判断大小的时候改一下就行了

```cpp
 if(j>=us[i])
{
    a[i][j]=max(a[i-1][j-us[i]]+wi[i],a[i-1][j]+lo[i]);
}
else
{
    a[i][j]=a[i-1][j]+lo[i];
}
```
###判断的代码。。。


---

## 作者：深海鱼的眼泪 (赞：1)

01背包。f[j]=max(f[j]+l[i],f[j-u[i]]+w[i])

不过需要注意 j＜u[i] 时 f[j]=f[j]+l[i]

还有要用long long


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
long long l[1010],w[1010],u[1010],f[1010]; 
int main(){
    int n,x,i,j;
    cin>>n>>x;
    for (i=1;i<=n;i++){
        scanf("%d%d%d",&l[i],&w[i],&u[i]);
    }
    for (i=1;i<=n;i++){
        for (j=x;j>=0;j--){
            if (j>=u[i]&&f[j]+l[i]<f[j-u[i]]+w[i]) f[j]=f[j-u[i]]+w[i];
            else f[j]+=l[i];
        }
    }
    cout<<f[x]*5;
    return 0;
}
```

---

## 作者：操作！ (赞：1)

#### 这题基本就是裸的01背包代码

# PS：基本！！！！！

Why？

因为有好几种情况！！！

------------

接下来直接上代码——


```
#include<bits/stdc++.h>
using namespace std;
int n,x,a[2000],b[2000],w[2000],f[2000];
int main()
{
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a[i],&b[i],&w[i]);
		for(int j=x;j>=w[i];j--)
		f[j]=max(f[j]+a[i]//直接投降,f[j-w[i]]+b[i]//嗑药打赢);
		for(int j=w[i]-1;j>=0;j--)
		f[j]+=a[i]//qwq磕了药还是打不赢***这可是个重点;
	}
	printf("%lld",f[x]*5);//输出走人~~~
	return 0;
 } 
```

###### 管理大大求过~~~~~

---

## 作者：渡海 (赞：1)

一个单数组的01背包...


01背包不懂的请自行绕道...


核心思路：每一次算出win-lose作为“价值”，将ans=ans+lose，然后01背包即可。

代码如下..（引用cmath中的fmax可以代表max函数）

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int f[1010];//一个数组
int main(){
    int n,x;
    long long ans=0;//不开longlong会炸
    scanf("%d%d",&n,&x);
    for(int i=1;i<=n;i++){
        int lose,win,medcin,smon;//smon为价值
        scanf("%d%d%d",&lose,&win,&medcin);
        smon=win-lose;
        ans=ans+lose;
        for(int j=x;j>=medcin;j--){//01背包..
            f[j]=fmax(f[j],f[j-medcin]+smon);
        }
    }
    printf("%lld",5*(f[x]+ans));
    return 0;
}
//这种做法不管是在时间复杂还是空间复杂上都有很大改善的，神犇勿喷
```

---

## 作者：17and17 (赞：0)

本题最好的思路（本蒟蒻以为）应该是：转换为最基础的01背包，就是那种例题一样的。

首先这个问题没有挑战的上限人数，且输了也有经验，那当然是每个好友都要挑战一下喽。明确这一点就好说了。

每次挑战最次也就是输，我们全输了也有一个最少经验，那么以最少经验为基础，把每个好友打败他最少的嗑药数当做重量，胜利比失败多的经验当做价值，那么这就是一道妥妥的连敲都不需要敲的01背包的经典例题，甚至可以直接copy（开个玩笑，还是要自己敲的）；
```cpp
#include"stdio.h"
#include"iostream"
using namespace std;
int M,N,i,j,X,k[1001];
long int get[1001],f[100001],a,b;
long long int sum;
int main()
{
   scanf("%d%d",&N,&X);         
   for(i = 0;i < N;i++)
   {
   scanf("%ld%ld%d",&a,&b,&k[i]);
   get[i] = b - a;sum+=a;
   }
   for(i = 0;i < N;i++)
   for(j = X;j >= k[i];j--)
   f[j] = max(f[j],f[j - k[i]] + get[i]);
	printf("%lld",(sum+f[X])*5);
	return 0;
} 
```



---

## 作者：不存在之人 (赞：0)

题解在这!

转移方程：f[j]={max(f[j]+lose[i],f[j-use[i]]+win[i]),j>=use[i];
               
               {f[j]+lose[i],0<=j<use[i];

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 1010
using namespace std;
int n,m,a[MAXN],b[MAXN],c[MAXN];
long long f[MAXN];
inline int read(){
       int date=0,w=1;char c=0;
       while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
       while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
       return date*w;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){b[i]=read();a[i]=read();c[i]=read();}
	for(int i=1;i<=n;i++)
		for(int j=m;j>=0;j--)
			if(j>=c[i])f[j]=max(f[j]+b[i],f[j-c[i]]+a[i]);
			else f[j]=max(f[j],f[j]+b[i]);
	printf("%lld\n",f[m]*5);
	return 0;
}
```

---

## 作者：xukuan (赞：0)

dp之背包之01背包

##注意：有人不用药就能打过！（醉了）

有人说要开int64(pascal)或long long(Dev\_C++)，但似乎并不用


···pascal



```cpp
uses math;
var
 i,n,x,j:longint;
 lose,win,use:array[0..1010] of longint;
 f:array[0..1010,0..1010] of longint;
begin
 readln(n,x);
 for i:=1 to n do
  readln(lose[i],win[i],use[i]);
 for i:=1 to n do
  for j:=0 to x do//有不用药就能打过的人，所以从0开始循环
   begin
    f[i,j]:=f[i-1,j]+lose[i];
    if j>=use[i] then f[i,j]:=max(f[i,j],f[i-1,j-use[i]]+win[i]);//状态转移方程
   end;
 writeln(f[n,x]*5);//输出*5
end.
```
```cpp

---


# 【mc生存】卖东西

## 题目背景

服务器好好玩。

## 题目描述

lcy0x1 去服务器的系统商店买东西。

一个人的背包有 $21$ 格。

一开始他的背包里有 $m$ 件不同的物品（**不能卖**）。

他要买 $n$ 种物品，第 $i$ 件物品的名字为 $st_i$，有 $a_i$ 件，价值为 $b_i$，一格可以放 $c_i$ 个。

相同的物品可以放同一格（只要没放满）。

问：他跑一次最多能卖多少钱。

## 说明/提示

数据保证：

- $0\leq m\leq 21$；
- $0\leq n\leq 100$；
- $0\leq a_i\leq 1344$；
- $0\leq b_i\leq 10^4$；
- $0<c_i\leq 64$；
- $0<|st_i|<100$；
- $0\leq s\leq 10^6$。

**注：数据强大，搜索 $0$ 分，请使用多重背包。**

## 样例 #1

### 输入

```
20 3
63 1 64 yinshifen
1 10 1 men
1 1 64 yinshifen```

### 输出

```
64```

# 题解

## 作者：叫我DJ (赞：50)

第一篇题解，有点小激动，大佬勿喷
其实这题一点也不坑，数据也很小，所以不用DP，就小小的处理下，排下序就可以过了
话不多说，上代码
```cpp
#include<iostream>
using namespace std;
struct hgrufdhg {//见题意
	int a;
	int b;
	int c;
	string name;
} th[1001];//要联系后文，分裂物品，所以要开大点（虽然好像题目数据并没有这么坑）
int n,m,ans,i,o;
int main() {
	cin>>m>>n;
	m=21-m;//计算空的格子
	for(i=1; i<=n; i++)
		cin>>th[i].a>>th[i].b>>th[i].c>>th[i].name;//输入不说话
	for(i=1; i<n; i++) {//接下来是一节废话，题目不坑所以没关系
		/*o=1;
		while(th[i].a>th[i].c) {     //介个循环，是处理某一物品数量超过单格数量限制
			th[n+o]=th[i];      //不过数据很人性化，没有这个坑
			th[n+o].a=th[i].c;
			th[i].a-=th[i].c;
			o++;          //在末尾新建一种物体，用来放置该物品多出来的部分
		}
		n+=o;
		n--;*/           //更新n的值
		for(o=i+1; o<=n; o++) {
			if(th[i].name==th[o].name) {//合并同样的物品
				if(th[i].a+th[o].a>th[i].c) {//如果合并后的数量超过单格上限，就用一个个中的物品把另一个填满
					th[o].a+=th[i].a;
					th[o].a-=th[i].c;
					th[i].a=th[i].c;
				} else {//不会超出上限，就直接合并好了
					th[i].a+=th[o].a;
					th[o].a=0;
				}
			}
		}
	}
	for(i=1; i<=n; i++)
		th[i].b*=th[i].a;//算出每个格子可以卖多少钱
	for(i=1; i<=n; i++)//数据量少，冒泡就够了
		for(o=i+1; o<=n; o++) {
			if(th[i].b<th[o].b) {
				th[0]=th[i];
				th[i]=th[o];
				th[o]=th[0];
			}
		}
	i=1;
	while(m--) {
		ans+=th[i++].b;//挑出可以卖的最赚钱的几个格子
	}
	cout<<ans;//华丽的输出
	return 0;
}
```

---

## 作者：moongazer (赞：24)

哈！P1964第一篇题解

其实这道题就是01背包，是的，你没有听错，就是01背包，因为数据不大，没有必要用多重背包（懒癌又犯了）

其实这道题的难度在于输入，我想了半天（半分钟），终于想出一个办法——用STL的map（C语言党请自行走开），将每一个物品的名字对应个数、价值和存储空间，在把每一种物品分解成很多个，每一个占的存储空间为1,然后就是01背包了。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<map>//用STL的map的头文件
using namespace std;
int dp[30],w[150000];
map<string,int>a,b,c;//a——个数，b——价值，c——存储空间
map<string,bool>d;//一个判断是否分解过的标志，具体作用在下面
string s[105];
int main(){
    int n,m,l,i,j,k,maxi=0;
    cin>>m>>n;
    m=21-m;//先将总存储空间去掉不能用的
    for(i=1;i<=n;i++){
        cin>>l>>j>>k;//输入个数、价值、存储空间
        cin>>s[i];//输入名字
        a[s[i]]+=l;//将该名字对应的个数加上现在输入进来的个数
        b[s[i]]=j;//名字对应的价值
        c[s[i]]=k;//名字对应的存储空间
    }
    k=0;//k表示将n个物品分解后是几个物品
    for(i=1;i<=n;i++){
        if(d[s[i]]==0){//判断这个名字是否做过，因为读入的名字是有重复的，这样就不用去重
            d[s[i]]=1;//置为做过
            while(a[s[i]]>=c[s[i]]){//如果剩下的能放满一个格子，那么继续
                w[++k]=c[s[i]]*b[s[i]];//新物品——价值为一个格子最多能存储的乘上每一个的价格
                a[s[i]]-=c[s[i]];//剩余的数量减去一个格子存储的数量
            }
            if(a[s[i]]){//如果分解后还有放不满一个格子的，单独放一个
                w[++k]=a[s[i]]*b[s[i]];
            }
        }
    }
    for(i=1;i<=k;i++){//01背包，每一件物品重量为1,价值在上面已经求出
        for(j=m;j>=1;j--){
            dp[j]=max(dp[j],dp[j-1]+w[i]);
            maxi=max(maxi,dp[j]);//取最大值
        }
    }
    cout<<maxi<<endl;//输出
    return 0;
}
```

---

## 作者：Blue_wonders (赞：18)

## 这道题正解是背包，但是这道题用排序完全可以做~~一开始我也是先用背包做的~~
### （坑！注意）这个题注意一下m是用了的空间，所以要拿21减
------------
#### strcmp函数（使用cstring头文件）
- 这道题中判断两个char或string类型的字符串的时候我们可以用这个函数
- 这个函数是将两个字符串都转化为ASCII码然后作差
- 如果两个相等的时候差也会是零
- 我们可以利用这一点来判断两个字符串相等
------------

### 算法思路
- 结构体记录输入，在每一次输入时判断是否是重复的，如果是就加到上一个里面，多的要放回来
- 把每个东西的数量和单价相乘，记录价值(这就是背包的价值)
#### 如果用01背包问题解决
- 最后01背包(价值已经算好了，空间都是1，一件物品只能卖一次)
- 求出最大值
#### 如果用排序方法
- 因为每一个东西都是只能用一次的，并且每一个东西占用空间是相同的
- 所以我们直接排序，选择前m个价值最大的相加就可以了
### AC代码(附详解)——背包解法和排序解法
先来背包正解
[AC详情](https://www.luogu.org/recordnew/show/16840078)
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10000];
struct goods{ 
	int piece,price,number,value;
	char name[101];
}p [1345];
int m,n; 
int main(){
	cin>>m>>n;
	m=21-m;
	for(int i=1;i<=n;i++){
		int a,b,c;
		cin>>p[i].piece>>p[i].price>>p[i].number>>p[i].name;//结构体输入 
		for(int j=1;j<=n;j++){
			if(i!=j&&strcmp(p[i].name,p[j].name)==0){//如果这次输入的名字和已输入的名字一样(strcmp是判断两个字符串点的差的函数，如果差是0说明相等) 
				if(p[j].piece+p[i].piece<=p[j].number){//如果两个加起来可以放到一组里 
					p[j].piece+=p[i].piece;//在之前的那一组里加上去 
					n--;//总的物品数减一 
					i--;//将这一组重新输入新的值 
					break;
				}
				else {//两个加起来比一组多 
					p[i].piece=p[i].piece-(p[j].number-p[j].piece);//那么记录多出来的 
					p[j].piece=p[j].number;//原来的达到最大值 
					//因为可能有好几组名字相同的，所以这里不能用break结束循环 
				}
			}
		}
	}
	for(int i=1;i<=n;i++){//每一组都算出这一组的价值 
		p[i].value=p[i].piece*p[i].price;
	}
	for(int i=1;i<=n;i++){//01背包问题解决 
		for(int j=m;j>=1;j--){
			f[j]=max(f[j],f[j-1]+p[i].value);
		}
	}
	cout<<f[m];//输出 
	return 0;
} 
```
然后是排序解法
[AC详情](https://www.luogu.org/recordnew/show/16844546)
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10000];
struct goods{
    int piece,price,number,value;
    char name[101];
}p [1345];
int cmn(goods a,goods b){
	return a.value>b.value;//返回价值大的，就算重复加的也是一样大，所以一句就够了 
}
int m,n; 
int main(){
    cin>>m>>n;
    m=21-m;
    for(int i=1;i<=n;i++){
        int a,b,c;
        cin>>p[i].piece>>p[i].price>>p[i].number>>p[i].name;
        for(int j=1;j<=n;j++){
            if(i!=j&&strcmp(p[i].name,p[j].name)==0){
                if(p[j].piece+p[i].piece<=p[j].number){
                    p[j].piece+=p[i].piece;
                    n--;
                    i--;
                    break;
                }
                else {
                    p[i].piece=p[i].piece-(p[j].number-p[j].piece);
                    p[j].piece=p[j].number;
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        p[i].value=p[i].piece*p[i].price;
    }
	sort(p+1,p+n+1,cmn);//将价值大的排在前面 
	int s=0;//记录最大值 
	for(int i=1;i<=m;i++){
		s+=p[i].value;//前m个的价值都加上就是他的总和 
	}
	cout<<s;
    return 0;
} 
```
感谢大家能看我的题解！~

---

## 作者：hongzy (赞：12)

###多重背包

```cpp
#include <iostream>
#include <string>
using namespace std;

#define MAXN 1001    //N 
#define MAXV 101     //V 
#define capacity 21  //背包容量 

int m, n, V, cnt;
int s[MAXN], c[MAXN], v[MAXN];   //s为数量，c为价值，v为多少个为一格 
int f[MAXV];                     //占i格的最大价值f[i] 
string name[MAXN];               //物品的名称 

inline int upv(int a, int x) {   //空间向上取整：有a个，一格最多放x个，返回占多少格 
    int r = x; 
    while(true) {
        if(r >= a) return r/x;
        r += x;
    }
}

int main() {
    cin >> m >> n;
    V = capacity - m;  //还剩几格 
    cnt = 1;           //记录合并后的物品总数 
    for(int i=1; i<=n; i++) {
        cin >> s[cnt] >> c[cnt] >> v[cnt] >> name[cnt];
        /*以下是合并同种物品 */ 
        bool flag = 0;
        for(int j=1; j<=i-1; j++)
            if(name[j] == name[i]) {
                s[j] += s[i];
                flag = 1;
                break;
            }
        if(flag == 0) cnt ++;
    }
    cnt --;    
    /*多重背包模版*/ 
    for(int i=1; i<=cnt; i++) {
        for(int j=V; j>=0; j--) {
            for(int k=0; k<=s[i]; k++) {
                int w = upv(k, v[i]); //单独处理占的格子 
                if(j - w < 0) break;  //格子不够 
                f[j] = max(f[j], f[j-w] + c[i] * k);
            }
        }
    }
    cout << f[V] << endl;
    return 0;
}

```

---

## 作者：linjikai (赞：8)

dalao写的多重背包好深奥啊qwq，蒟蒻来弱弱地~~水~~发一波题解

算法：多重背包
```
#include <bits/stdc++.h>
using namespace std;
struct data{
	int w;
	int v;
	int c;
	string s;
}a[105] , b[134405];//a是原数组，b是用来处理的数组（具体看下面）
int n , m , t = 0 , x = 21 , f[22];
int main()
{
	cin >> m >> n;//输入
	x -= m;//除去不能卖的东西剩下的格子
	for(int i = 1; i <= n; i++)
		{
			cin >> a[i].w >> a[i].v >> a[i].c >> a[i].s;//输入
			for(int j = 1; j < i; j++)//如果前面有过同样的就合并
				{
					if(a[j].s == a[i].s)
						{
							a[j].w += a[i].w;//合并
							a[i].w = -1;//标记
						}
				}
		}
	for(int i = 1; i <= n; i++)
		{
			if(a[i].w != -1)//合并到前面的就不考虑
				{
					int p;
					bool bo = false;
					if (a[i].w % a[i].c > 0)//每放满一个格子，就算一个物件，占用一个空间，从而达到转01背包的作用
						{
							p = a[i].w / a[i].c + 1;
							bo = 1;//标记，最后一个没放满
						}
					else
						p = a[i].w / a[i].c;
					for(int j = 1; j <= p; j++)//计算价值									{
							if(bo == 1 && j == p)
								{
									b[++t].v = a[i].v * (a[i].w % a[i].c);//如果最后一个没放满，要特判
									b[t].w = 1;//算占用一个空间
								}
							else
								{
									b[++t].v = a[i].v * a[i].c;
									b[t].w = 1;
								}
						}
				}
		}
	for(int i = 1; i <= t; i++)
		for(int j = x; j >= b[i].w; j--)
			f[j] = max(f[j] , f[j - b[i].w] + b[i].v);//华丽的01背包模板
	cout << f[x];//输出
}
```

---

## 作者：Garrison (赞：6)

[题面传送门](https://www.luogu.org/problem/P1964)
# 前言
这一道题一道很明显的分组背包。不会分组背包的可以自行去看背包九讲或者去做一下[P1757 通天之分组背包](https://www.luogu.org/problem/P1757)，在本题解中，分组背包将不会详细阐述。
# 正文
先看一下输入，要输入四个部分：数量（number）、价值（value）、空间（space）、名字（name）。对于名字相同的我们就直接将他们的数量加起来就行了（~~反正数据超级水~~（逃））
```
	std::ios::sync_with_stdio(false);//加快cin，cout速度 
	cin>>m>>n;m=21-m;//因为背包只有21格，所以所剩空间为21-m 
	for(int i=1;i<=n;++i){
		cin>>number[num]>>value[num]>>space[num]>>name[num];//变量名已经讲得很明白了 
		for(int j=1;j<=i-1;++j){//在前面找有没有名字一样的 
			if(name[i]==name[j]){//string的好处 
				number[j]+=number[i];//数量累加 
				--num;//有重复，这组不算 
				break;
			}
		}
		++num;
		//num作用：统计有多少不同的组 
	}
	--num;//因为多算了一组，所以要减去
```
前面的工作处理完了，然后就是动态规划了！（模版不用赘述）

[背包九讲](https://blog.csdn.net/yandaoqiusheng/article/details/84782655)
```
	for(int i=1;i<=num;++i)//枚举组数 
		for(int j=m;j>=0;--j)//枚举格子0-0 
			for(int k=0;k<=number[i];++k){//枚举该组个数 
				int s=space[i];
				while(true){
					if(s>=k){
						s/=space[i];
						break;
					}
					s+=space[i];
				} //统计所需空间 
				if(j-s<0) break;//装不下，返回 
				f[j]=max(f[j],f[j-s]+value[i]*k);//递推式，很关键 
			}
```
然后输出f[m]就好了
# 后话
背包问题还是要熟知的，这道题用分组背包还是很好地，就不要用01背包刷经验了（你谷上01背包~~水~~难题这么多，足够涮了）
# Code
```
#include<bits/stdc++.h>
using namespace std;
#define N 1001
int number[N],value[N],space[N];
int f[N];
int num=1,n,m;
string name[N];
int main(){
	std::ios::sync_with_stdio(false);
	cin>>m>>n;m=21-m;
	for(int i=1;i<=n;++i){
		cin>>number[num]>>value[num]>>space[num]>>name[num];
		for(int j=1;j<=i-1;++j){
			if(name[i]==name[j]){
				number[j]+=number[i];
				--num;
				break;
			}
		}
		++num;
	}
	--num;
	for(int i=1;i<=num;++i)
		for(int j=m;j>=0;--j)
			for(int k=0;k<=number[i];++k){
				int s=space[i];
				while(true){
					if(s>=k){
						s/=space[i];
						break;
					}
					s+=space[i];
				} 
				if(j-s<0) break;
				f[j]=max(f[j],f[j-s]+value[i]*k);
			}
	cout<<f[m]<<endl;
	return 0;
}
```


---

## 作者：さくたi桜 (赞：6)

# 蒟蒻乱打的
知道这么做不对，不过侥幸混过了  
就这样吧，瑟瑟发抖


------------

```cpp
#include <iostream>
#include <string>
using namespace std;
typedef struct tMinecraft_Subject_Property{
    string sName;	//物品名称
    int StackSize;	//物品最大可堆叠数量
    int Cost;		//物品单价
    int Quantity;	//物品拥有数量
    int Real_Cost;	//物品单个格子叠满的价格
    void add(int number)
    {
        Quantity+=number;
    }				//添加同类物品的函数
    void start(string name,int number,int value,int size)
    {
        sName=name;
        Quantity=number;
        Cost=value;
        StackSize=size;
        Real_Cost=Cost*StackSize;
    }				//添加新物品的函数，或者说是新建物品
}MSP;				//一个用于存物品的结构体
MSP subject[105];
int now=0,bag,n;
void AddSubject(int num,int value,int ssize,string name)
{
    int i;
    for(i=0;i<now;i++){
        if(name==subject[i].sName){
            subject[i].add(num);	//添加已有物品
            return;
        }
    }
    subject[now].start(name,num,value,ssize);	//添加新物品种类
    now++;			//已知物品种类增加
}					//用来添加物品的函数
int Maxn()
{
    int maxn=0,maxi,maxnum,nownum,i,now_money;
    for(i=0;i<now;i++){
        now_money=subject[i].Real_Cost;		//该物品一格价值
        nownum=subject[i].StackSize;		//该物品堆叠数量
        if(subject[i].Quantity<subject[i].StackSize){
            now_money=subject[i].Cost*subject[i].Quantity;
            nownum=subject[i].Quantity;
        }			//当物品数量小于一格堆叠数量时，更新物品一格价值
        if(now_money>maxn){
            maxn=now_money;
            maxi=i;
            maxnum=nownum;
        }			//添加当前最高价值的物品
    }
    subject[maxi].Quantity-=maxnum;
    return maxn;
}					//计算当前一格最大价值量的函数
int main()
{
    cin>>bag>>n;
    bag=21-bag;
    int i,j,ai,bi,ci;
    string sti;
    for(i=0;i<n;i++){
        cin>>ai>>bi>>ci>>sti;
        AddSubject(ai,bi,ci,sti);
    }				//添加所有物品
    int money=0;
    for(i=0;i<bag;i++){
        money+=Maxn();
    }				//计算钱数
    cout<<money<<endl;	//输出
    return 0;
}
```
很菜，勿喷

---

## 作者：庸人 (赞：5)

其实这个是个很H2o的题目

大佬都是多重背包

我的方法是先处理在01背包

具体看代码



    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct thing{
    int Price,number,weight,ci;
    string name;
}z[111];
int m,n;
//卖n种物品，每种物品有ai件,价值bi,一格可以放ci个
void Set(int i,int ai,int bi,int ci,string name){
    z[i].name=name;
    z[i].ci=ci;
    z[i].number+=ai;
    z[i].Price=bi*z[i].number;//总价值 
    z[i].weight=ceil((double)z[i].number/z[i].ci);//所占的位置
    return ; 
```
}//把物品分到各自所属的位置
    

```cpp
int dp[50];
int main(){
    scanf("%d%d",&m,&n);
    int V=21-m;//所剩空间 
    int t=1;
    int ai,bi,ci;
    string name;
    scanf("%d%d%d",&ai,&bi,&ci);
    cin>>name;
    Set(0,ai,bi,ci,name);
    //敲黑板！！！ 先建一个下面的for才能进 
    for(int i=1;i<n;i++){
        scanf("%d%d%d",&ai,&bi,&ci);
        cin>>name;
        for(int j=0;j<=t;j++){
            if(z[j].name==name){
                Set(j,ai,bi,ci,name);
                break;
            }
            if(j==t){//如果找到最后一个还没有发现名字相同的就再建一个 
                t++;
                Set(j,ai,bi,ci,name);
                break;
            }
        }
    }
    //接下来01背包不解释 
    for(int i=0;i<t;i++){
        for(int j=V;j-z[i].weight>=0;j--){
            dp[j]=max(dp[j],dp[j-z[i].weight]+z[i].Price);
        }
    }  
    //输出 
    cout<<dp[V];
    return 0;
}
```

---

## 作者：Meatherm (赞：3)

其实这道题很多人都看出来是背包，那么我来给大家介绍一种很玄学的方法。

[这位大佬的题解](https://www.luogu.org/blog/user19631/solution-p1964)是用的w[i]来存的占的格子数量，而我是将每一个格子看成一件物品。然后你要问背包中的w[i]是多少？w[i]就是1了（进行分解之后）。


借鉴了[这位大佬的题解](https://www.luogu.org/blog/user19631/solution-p1964)

具体详见代码

```
# include <bits/stdc++.h>
using namespace std;
int m,n,f[104];//数组可以不开这么大
struct node
{
	int sum,wi,aw,dj;//sum是总数量，wi是占的格子，aw是一个格子能放几个，dj是单价值
	string name;//物品名称
}a[1004];
struct nd
{
	int ci;//反作弊？一个变量呢
}b[10003];
void work(int i,int v,int c,int w,string s)//i是物品序号，v是数量，c是单价值，w是每个可以放下的，s是物品名称
{
	a[i].name=s;
	a[i].sum+=v;
	a[i].aw=w;
	a[i].dj=c;//前面不解释，计算参数
	a[i].wi=ceil((double)a[i].sum/a[i].aw);//计算所占格子，记得转换类型double
}
int t;//计算有多少种类型
int main()
{
	cin>>m>>n;
	int A,B,C;
	string name;
	m=21-m;//记得这一步
	cin>>A>>B>>C>>name;
	work(1,A,B,C,name);
	t=1;//为了接下来方便判断，这里我先进了一个
	for(int i=2;i<=n;i++)
	{
		cin>>A>>B>>C>>name;
		for(int j=1;j<=t;j++)
		{
			if(a[j].name==name)
			{
				work(j,A,B,C,name);
				break;
			}//如果相同那么就累加
			if(t==j)
			{
				t++;
				work(t,A,B,C,name);
				break;
			}//否则新建一个
		}
	}
    //开始分解
	int s=0;
	for(int i=1;i<=t;i++)
	{
		for(int j=1;j<a[i].wi;j++)
		{
			b[++s].ci=a[i].dj*a[i].aw;//一个满的格子的价值就是单价*数量
		}
		if(a[i].sum-(a[i].wi-1)*a[i].aw!=0)//如果分完之后有剩余的话那么就需要建一个没放满的格子
		{
			b[++s].ci=a[i].dj*(a[i].sum-(a[i].wi-1)*a[i].aw);
		}
	}
	for(int i=1;i<=s;i++)
	{
		for(int j=m;j>=1;j--)
		{
			f[j]=max(f[j],f[j-1]+b[i].ci);
		}
	}//01背包不解释
	cout<<f[m];
	return 0;
}
```

---

## 作者：新手7889456 (赞：2)

### 尽管这道题的标签是背包，但是我仍用贪心。。。

想看背包的就在楼上了（应该没人和我一样）。

首先先找贪心方法，

1.相同的物体才能放在一的格子里；

2.相同的物体可能分开说明；

3.所以先将同一种物体存在一起；

4.尽量将格子填满（主旨）；

5.多余的另放格子；

6.排序。

不懂的看注释：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;
map<string,int> ma;//这个名字对应的物体
struct edge{//每一种物体
	int dis;//这种物体的价值
	int num;//这种物体的数量
	int xian;//这种物体每个格子的限制
}b[1001];
int n,m,ans;
int a[1001],tot,tot2;
bool cmp(int x,int y){return x>y;}//从大到小
int main()
{
	scanf("%d%d",&m,&n);
	m=21-m;//m表示还剩多少格子
	register int x,y,z;
	string shu;
	for(register int i(1);i<=n;++i){
		scanf("%d%d%d",&x,&y,&z);//读入
		cin>>shu;
		if(!ma[shu]) {
			ma[shu]=++tot2;
			b[tot2].dis=y;
			b[tot2].xian=z;
		}
		b[ma[shu]].num+=x;//叠加
	}
	for(register int i(1);i<=tot2;++i){
		while(b[i].num){
			if(b[i].num<=b[i].xian){//如果剩下的只能放一格
				a[++tot]=b[i].num*b[i].dis;//价值
				b[i].num=0;
				break;
			}
			a[++tot]=b[i].xian*b[i].dis;//价值
			b[i].num-=b[i].xian;//取走b[i].xian后还剩多少
		}
	}
	sort(a+1,a+1+tot,cmp);//排序
	for(register int i(1);i<=m;++i){//算出最大值
		ans+=a[i];
	}
	printf("%d",ans);//输出
	return 0;
}
```


---

## 作者：小小怪下士___ (赞：2)

其实这题不用背包也可以A。（一开始以为自己想错了，试了一下一遍就过了！）


## 思路讲解： 把属于一类的全部合并在一起。在算出满足条件下每个物品最多可以赚多少￥。最后排个序找出21-n个最大的累加就ok了！。

# 代码如下：

```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
map<string,int> ge,dan,da,ci;
string s[110];
int a[N];
int n,m,wei,zhi;
void gao(int x,int y,int z)
{
	if(x<=z)a[++wei]=y*x;//如果物品数量小于或等于存放量就用物品数量乘单价 
	else 
	a[++wei]=y*z;//否则就用存放量乘单价 
}
int mc(int x,int y)
{
	return x>y;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c>>s[i];
		ge[s[i]]+=a;//属于一类的累加个数 
		dan[s[i]]=b;//保存它的单价 
		da[s[i]]=c;//保存 存放量 
	}
	for(int i=1;i<=m;i++)
	{
		if(ci[s[i]])continue;//避免多次运算 
		ci[s[i]]++;
		gao(ge[s[i]],dan[s[i]],da[s[i]]);//找每个物品最大卖多少￥ 
	}
	sort(a+1,a+1+wei,mc);//排序 
	for(int i=1;i<=21-n;i++)zhi+=a[i];//找前21-n最大 
	cout<<zhi<<endl;//输出
	return 0; 
}
```

---

## 作者：tommymio (赞：1)

这题乍一看感觉很难，因为它似乎有很多状态可以作为入手点，恰恰就不知道从什么地方入手了，~~（可能是题面不太清楚吧，和noip的龙虎斗一个脾气）~~

仔细思考一下，我们就会发现，我们实际上可以把背包的容量作为一个状态的定义，对数据稍加处理，用多重背包来解决这个问题。

**相同的物品可以放同一格(只要没放满）**，所以只要当前这种物品放在了一个物品格上，就尽可能放满当前这个物品格(贪心)

如果当前这种物品都被放到格子上了，并且一格是没有放满的，我们要进行特判。

代码飞来~~~~~~

```cpp
#include<bits/stdc++.h>
struct itom{
	int a,b,c;
}it[105];
std::map<std::string,std::pair<int,int> > map;
int f[25];
int main(){
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;++i){
		std::string s;
		scanf("%d%d%d",&it[i].a,&it[i].b,&it[i].c);
		std::cin>>s;
		++map[s].first;//统计出现次数 
		if(map[s].first==1){//记录最初出现的下标 
			map[s].second=i;
		}
		else{//对最初出现的下标的数据进行处理（去重） 
			it[map[s].second].a+=it[i].a;
			it[i].a=0;
		}
	}
	for(int i=1;i<=n;++i){
		if(!it[i].a)	continue;//如果重复数据，continue 
		for(int vmax=21-m;vmax>=1;--vmax){
			for(int k=0;k<=it[i].a/it[i].c;++k){
				if(vmax-k<0)	break;
				f[vmax]=std::max(f[vmax],f[vmax-k]+k*it[i].b*it[i].c);
			}
			if(it[i].a%it[i].c!=0&&vmax-(it[i].a/it[i].c+1)>=0){//特判 
				f[vmax]=std::max(f[vmax],f[vmax-(it[i].a/it[i].c+1)]+it[i].a*it[i].b);
			}
		}
	} 
	printf("%d",f[21-m]);
	return 0;
}

```


---

## 作者：二哥啃菜包 (赞：1)

恩，这题题解都有一点睿智，让我来发一篇比较无脑的dp吧。

题意：
```
给了咱一个21-m容量的背包，再给我们每个物品的个数a，每个物品单个的价值b，以及每个格子最多可以放几个物品a。
```
那我们考虑一下，肯定把每个可以装满的格子装满是最优的。

那么对物品个数为a且a超过c的物品，我们一定可以把他分解，并且不损失最优解。

那么分解完之后，每个物品体积为1，价值为个数乘上单个价值（b）。

再做一遍01背包就水过去了。

要不要看代码啊。

![我是图片](https://cdn.luogu.com.cn/upload/pic/53271.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
const int N=910;
const int M=110;
map <string,int> h;//map判断该物品有没有出现过 
//只是我懒得写hash，欧对了，hash在C++11中是关键字欧（大佬请自动忽视） 
int f[N],a[N],b[N],c[N];
string s[N];
int main(){
	ios::sync_with_stdio(0);
	cin>>m>>n;
	m=21-m;
	for(int i=1;i<=n;++i){
		int aa=0,bb=0,cc=0;
		cin>>aa>>bb>>cc>>s[i];
		if(!h[s[i]])h[s[i]]=++cnt;
		a[h[s[i]]]+=aa;
		b[h[s[i]]]=bb;
		c[h[s[i]]]=cc;
	}
	for(int i=1;i<=cnt;++i){
		while(a[i]>c[i]){
			a[++cnt]=c[i];
			b[cnt]=b[i];
			c[cnt]=c[i];
			a[i]-=c[i];//分解多余一个能装数的物品 
		}
	}
	for(int i=1;i<=cnt;++i)for(int j=m;j>=1;--j)
		f[j]=max(f[j],f[j-1]+a[i]*b[i]);//因为体积为1，价值为个数乘单价 
	cout<<f[m]<<endl;
	return 0;
}
//哇AC了。 
```

那么余快的题解就结束了~~

---

## 作者：HyyypRtf06 (赞：0)

~~为什么题解区的代码那么难懂呢（极长的代码）~~

~~包括我之前写的（lgys的就是我写的~~

但是用了 $STL$ 之后会好很多（STL过多），变得肥肠好理解 `\QwQ/`

思路：  
对于每一种物品，做以下处理  
我们把每一种物品的数量切分一下，比如一个物品 $st_i$ 它的$a_i=138 \ \ \ \ b_i=10 \ \ \ \ c_i=64$ ，**那么我们就把 $a_i$ 切分成若干个 $c_i$ 相加再加上剩余部分**，即 $64+64+10$ ,再将每项分别乘上 $b_i$ ，将各乘积压入`vector`

处理完成之后，对`vector`进行倒序排序（或者正序排序倒输出），取前 $21-m$ 个数相加，即为答案（因为本题只需输出最多卖的钱，所以只用取数加和即可）

Code:
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<set>
#include<map>
#include<vector>
using namespace std;
struct T{//物品
	int mx;//上限
	int own;//有多少
	int cost;//价值
};
map<string,T> mp;
vector<int> v;//价值
set<string> st;//名称
int space;//空间
int n,m;
int ans;
int main(){
	cin>>m>>n;
	space=21-m;//算出剩余空间
	for(int i=0;i<n;i++){
		int a,b,c;
		string s;
		cin>>a>>b>>c>>s;
		mp[s].own+=a;//这里是+=
		mp[s].cost=b;
		mp[s].mx=c;
		st.insert(s);
	}
	for(set<string>::iterator it=st.begin();it!=st.end();it++){//iterator遍历set
		while(mp[*it].own){//只要还有
			v.push_back(min(mp[*it].own,mp[*it].mx)*mp[*it].cost);//就往里面装
			//这里注意要取min(数量,上限)
			mp[*it].own=max(0,mp[*it].own-mp[*it].mx);//减掉
		}
	}
	sort(v.begin(),v.end());//懒人排序
	int END=max(0,(int)v.size()-space);
	//这里千万不要直接把v.size()-space写到下一行的END里面去
	for(int i=v.size()-1;i>=END;i--){
		ans+=v[i];
	}
	cout<<ans<<endl;//输出
	return 0;
}
```
总结一下，`lgys`的代码的处理是每一次都循环每一种物品计算一遍一格能拿走的价值，然后拿走最贵的一份；而这篇是先把物品分装到一个个格子里，然后从贵到便宜取。

[lgys那篇的传送门](https://www.luogu.com.cn/blog/luoguyisuei/solution-p1964)

The End.

---

## 作者：灵光一闪 (赞：0)

呃……结构体有毒哦……

不用结构体：  
![](https://cdn.luogu.com.cn/upload/pic/65565.png)

用了结构体……
![](https://cdn.luogu.com.cn/upload/pic/65566.png)

woc……A了……

前排%%%结构体

这题吓唬人！千万不要相信标签！！切记！！！

~~详见说明~~

说好的多重背包呢？标签DP又是smg鸭？？我用暴力碾过去了又是什么鬼鸭？？？

吐槽完了，讲正事：

这题就是模拟，把东西分好类，然后循环``21-m``次，每次找出最优解，然后就加进``ans``

code:
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<string>
#include<vector>
#include<map>
using namespace std;
struct thing{
    string name;//名纸
    int value;//价值
    int many;//数量
    int most;//一个格子能装的最大值
};
thing arr[233];
vector<string> v;
map<string,int> mp;
map<string,bool> used;
map<string,bool> vis;
int ans;
int tep;
int n,m;
string s[233];
int main(){
    cin>>m>>n;
    int now=21-m;
    for(int i=0;i<n;i++){//输入+分类（垃圾分类，从我做起）
        int a,b,c;
        cin>>a>>b>>c>>s[i];
        if(!used[s[i]]){
            used[s[i]]=true;
            mp[s[i]]=tep++;
            v.push_back(s[i]);
        }
        arr[mp[s[i]]].many+=a;
        arr[mp[s[i]]].value=b;
        arr[mp[s[i]]].most=c;
        arr[mp[s[i]]].name=s[i];
    }
    while(now--){
        int biggest=0;
        int point=-1;
        for(int i=0;i<v.size();i++){
            if(vis[v[i]]||arr[mp[v[i]]].many<=0){//这个用光了或者用过了
                continue;
            }
            if(biggest<(arr[mp[v[i]]].value*min(arr[mp[v[i]]].most,arr[mp[v[i]]].many))){//这里看起来挺难的其实就是当前价值*最多的数量
                biggest=(arr[mp[v[i]]].value*min(arr[mp[v[i]]].most,arr[mp[v[i]]].many));
                point=i;//更新
            }
        }
        if(point==-1){//没有能用的了
            break;
        }
        else{
            ans+=biggest;//累加
            vis[v[point]]=true;//记录
            arr[mp[v[point]]].many-=min(arr[mp[v[point]]].most,arr[mp[v[point]]].many);//把用掉的剪掉
        }
    }
    cout<<ans<<endl;//输出
    return 0;
}
```
但是这个程序是不对的！在这组数据情况下会WA(居然还A了我也是无力吐槽
```
19 2
128 1 64 a
1 63 1 b
```
这个程序输出是127，但正解是128，~~难道这就是A过以后反手HACK的操作？？~~

正解嘛，自己想去！**其实并不需要加任何东西，只要把vis数组删除就行了！**

The End.

---

## 作者：严哥 (赞：0)

根据我严谨的分析,这题不用DP也行,上:
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>a;//百度一下
int m,n,s[101],c[101],ds[101],ans;
string x[101];//名字
int main()
{
	cin>>m>>n;
	int rest=21-m,wn=n;//剩余空间
	for(int i=1;i<=n;i++)
	{
		cin>>s[i]>>c[i]>>ds[i];
		if(s[i]>ds[i])s[i]=ds[i];//考虑空间不够
		cin>>x[i];//名字
		if(a[x[i]]>0)
		{
			wn--;//物品重复
			s[a[x[i]]]+=s[i];//如果重复,找到这个名字第一次出现时的那样物品的数量,累加
			if(s[a[x[i]]]>ds[i])s[a[x[i]]]=ds[i];//如果装不下,取最大能装的数量
		}
		else a[x[i]]=i;//记录位置
	}
	while(rest>0)//贪心,把剩余空间塞入价值最大的物品
	{
		int maxn=0,maxr=0;
		for(int i=1;i<=wn;i++)
		{
			if(a[x[i]]>0)//物品没用过
			{
				if(s[i]*c[i]>maxn)
				{
					maxn=s[i]*c[i];
					maxr=i;//记录位置
				}
			}
		}
		ans+=maxn;
		a[x[maxr]]=0;//物品已用过
		rest--;
	}
	cout<<ans;
	return 0;
}
```
打字太累,请读者自行理解,嘻嘻

---


# 大朋友的数字

## 题目背景

在 NOIP2013 的赛场上，常神牛华丽丽的手残了，小朋友的数字一题只得了 $10$ 分。于是，他要恶搞一下这道题。

## 题目描述

有一批大朋友（年龄 $15$ 岁以上），他们每人手上拿着一个数字，当然这个数字只有 $1$ 位，也就是 $0$ 到 $9$ 之间。每个大朋友的分数为在他之前的最长不下降子序列中所有数之和。（这个序列必须以它作为结尾！）如有多个最长不下降子序列，那么取编号字典序最小的。现在告诉你有 $n$ 个大朋友，以及他们各自的数字，请你求出他们每个人的分数。

## 说明/提示

【样例解释 $1$】

五个人分数分别为 $(1),(1+2),(1+2+5),(1+2+3),(1+2+3+4)$。

【样例解释 $2$】

五个人分数分别为 $(1),(1+7),(1+5),(1+7+9)$ （还有一个 $(1,5,9)$），$(1+5+6)$。

【数据规模】

对于 $50\%$ 的数据，$1\le n\le 500$；

对于 $80\%$ 的数据，$1\le n\le 10^3$；

对于 $100\%$ 的数据，$1\le n\le 10^4$。

## 样例 #1

### 输入

```
5
1 2 5 3 4
```

### 输出

```
1 3 8 6 10
```

## 样例 #2

### 输入

```
5
1 7 5 9 6
```

### 输出

```
1 8 6 17 12
```

# 题解

## 作者：kkksc03 (赞：91)

这题描述有些坑，不过读懂之后，我们会很容易得到一种算法。

看到这种题，一定能想到先建一个数组c，表示每个人的数字。先运用DP求出每个数字前的最长不下降子序列长度（第i个数的记为a[i]），然后再设置一个数组b，表示分数，很明显b[1]就是c[1]。然后对于每个数字i，枚举一下它前面的数字，一旦遇到一个数j，满足a[j]+1=a[i]，那么b[i]=b[j]+c[i]，然后跳出。

当然，程序最后还要确保：对于任何一个b[i]，都有b[i]<b[i+1]，违反的话b[i+1]=b[i]。


---

## 作者：樱式分解 (赞：63)

### 这道题要解决两个点。
#### 1.最长不下降子序列。
#### 2.它的和。
#### 解决第1个点需要一状态转移方程
```
if(a[j]<=a[i]&&f[i]<f[j]+1)f[i]=f[j]+1。
```
#### 注意是不下降子序列，是a[j]<=a[i],可以等于。
### 开始第二点
#### 第二个点我们可以另开一个数组V[10010],然后开始时只有最长的自己
```
for(int i=1;i<=n;i++){
cin>>a[i];
v[i]=a[i];
}
```
#### 然后就在原来的状态状态转移方程上加上v[i]=v[j]+a[i];
```
if(f[i]<=f[j])f[i]=f[j]+1,v[i]=v[j]+a[i];
```
### 代码如下
```
#include <iostream>
using namespace std;
int n,m;
int f[10010];
int a[10010];
long long v[10010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
	     cin>>a[i];
             v[i]=a[i];
        if(i>1)
	for(int j=1;j<i;j++)
	if(a[j]<=a[i])
	if(f[i]<=f[j])f[i]=f[j]+1,v[i]=v[j]+a[i];
	cout<<v[i]<<" ";
	}
    return 0;
}
```
## 用心写题解，希望给大家带来点帮助呀！


---

## 作者：DDOSvoid (赞：26)

实际上这题可以利用最长不下降子序列的最朴素算法加以改造来求得

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[10010],b[10010],c[10010];
bool vis[10010];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
        b[i]=1;
        for(int j=1;j<=i-1;j++)
            if(a[i]>=a[j])
                if(b[i]<b[j]+1){
                    b[i]=b[j]+1;
                    c[i]=c[j];//c[i]等于离它最近的一个数c[j]因为要求字典序最小 
                }
        c[i]+=a[i];//自身也是序列的一个数 
    }
    for(int i=1;i<=n;i++)cout<<c[i]<<" ";
    return 0;
}
```

---

## 作者：SGOI_Aromyase (赞：13)

贡献一下题解吧，楼下pas题解有点坑

其实我的思路和一楼神牛差不多

不过 **对于任何一个b[i]，都有b[i]<b[i+1]，违反的话b[i+1]=b[i]**。我没看懂是什么意思，不过我的代码AC了，应该也是可行的？

**这题难度远远大于普及-啊！！**

做的人少就是因为大牛看不上普及-，萌新不会做

仔细想想，这题比P1108 低价购买就**简单了一丢丢**，人家可是**省选-的难度**

真是...


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[10005]= {0},f[10005]= {0},ans[10005]= {0};//a数组存数据，b动规，ans则是当前得分
int main() {
    int n;
    scanf("%d",&n);
    for(int i=1; i<=n; i++) scanf("%d",&a[i]);
    for(int i=1; i<=n; i++) f[i]=1;//初始化
    for(int i=2; i<=n; i++) ans[i]=0x7fffffff; //初始化
    ans[1]=a[1];
    for(int i=2; i<=n; i++)
        for(int ii=1; ii<i; ii++)
            if(a[i]>=a[ii]) f[i]=max(f[i],f[ii]+1);//最长不下降，动规基础
    for(int i=2; i<=n; i++) {
        for(int ii=1; ii<i; ii++) {
            if(f[i]==f[ii]+1&&a[i]>=a[ii]) {//找到前一个状态
                ans[i]=min(ans[i],ans[ii]+a[i]);//得到得分
                break;//话说码到这里突然发现...ans数组好像不用初始化吧...
```
}//直接取值跳出不就行了，min也省了...不过我这算不算个好习惯...
        }

        if(ans[i]==0x7fffffff) ans[i]=a[i];//若推不出前一个状态，赋初值，先前少打了个f,直接爆0...

}//稍微想想，直接所有f[i]=1的数据全部处理成 ans[i]=a[i]其实更省事

for(int i=1; i<=n; i++) printf("%d ",ans[i]);//按次序输出



    return 0;

}

---

## 作者：天南地北 (赞：13)

#####  简单DP
这是一道DP中最长不下降子序列类型的题目，适合蒟蒻去刷
~~（like me）~~

##### 求最长不下降子序列
怎样求最长不下降子序列呢？

* 举个例子（题目样例）

~~~
5
1 2 5 3 4

~~~
##### 我们设$f[i]$为选取第i位时的最长不下降子序列的最多个数（这种求法十分罕见，一般不这么用），每个人数字的用$a[i]$代替
具体操作：
* 当$i=1$时，很明显知道$f[1]=a[1]=1$
* 当$i=2$时，发现$a[2]>a[1]$那么$f[2]=f[1]+1=2$
* 当$i=3$时，发现$a[3]>a[2]$又$>a[1]$那么因为要找最大，s所以为$f[3]=f[2]+1=3$
* 当$i=4$时，发现$a[4]>a[2]$又$>a[1]$那么因为要找最大，s所以为$f[4]=f[2]+1=3$
* 当$i=5$时，发现$a[5]>a[4]$又$>a[2]$还$>a[1]$那么因为要找最大，所以为$f[5]=f[4]+1=4$

那么最后再看$f[i]$中最大的值，即为整个数列最长不下降子序列的最多个数，$max$为$4$。

##### 综合一下，当$a[i]>=a[j]$时,$f[i]=max(f[i],f[j]+1)$,（$j$是第二重循环变量，从$1$到$i-1$循环）。

$Q:$为什么要找$f[i]$中最大的值？

$A:$因为我们设$f[i]$为选取第i位时的最长不下降子序列的最多个数，那么$f[n]$不一定是这个数列的最长不下降子序列最多个数,所以我们要找$f[i]$中最大的值。

##### 回归原题

很明显，求出他们每个人的分数这个问题变得十分简单，这个时候我们可以这样写DP
~~~
sum[i]=a[i];//sum为他的分数
for(int j=1;j<i;j++)
{
   	if(a[i]>=a[j]&&f[i]<f[j]+1)//满足最小字典序和最长不下降子序列时
    {
    	f[i]=f[j]+1;//计算个数
    	sum[i]=sum[j]+a[i];//计算分数
	}
}
~~~
##### 参考程序（蒟蒻版）
~~~
#include<iostream>
using namespace std;
int n;
int a[10000+10],f[10000+10],sum[10000+10];
int main()
{
    cin>>n;
	for(int i=1;i<=n;i++)
    {
    	cin>>a[i];
    	sum[i]=a[i];
    	for(int j=1;j<i;j++)
    	{
    		if(a[i]>=a[j]&&f[i]<f[j]+1)
    		{
    			f[i]=f[j]+1;
    			sum[i]=sum[j]+a[i];
			}
		}
		cout<<sum[i]<<" ";
	}
	return 0;
}

~~~
#### 参考程序（作者版）
~~~
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<deque>
#define For(i,a,b) for(i=a;i<=b;i++)
#define check if
#define read(a) cin>>a
#define write(a) cout<<a
using namespace std;
const int maxn=10000+10;
int n,i,j;
int a[maxn],f[maxn],sum[maxn];
int main()
{
    std::ios::sync_with_stdio(false);
    read(n);
	For(i,1,n)
    {
    	read(a[i]);
    	sum[i]=a[i];
    	For(j,1,i-1)
    	{
    		check(a[i]>=a[j]&&f[i]<f[j]+1)
    		{
    			f[i]=f[j]+1;
    			sum[i]=sum[j]+a[i];
			}
		}
		write(sum[i]);
		cout<<" ";
	}
	return 0;
}
~~~

---

## 作者：中国飞鱼 (赞：4)

dp经典问题：最长不下降子序列。本题只是在原来问题的基础上增加了总和的输出和字典序的判断，代码见下：

```cpp
#include<iostream>
using namespace std;
int n;
struct node{
    int num,k,sum;          sum存储总和，k存储个数，num是该人手中的数；
}dp[10001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>dp[i].num;
    }
    for(int i=1;i<=n;i++)
    {
        dp[i].k=1;dp[i].sum=dp[i].num;          初始化；
        for(int j=1;j<i;j++)
        {
            if(dp[j].num<=dp[i].num)
            {
                if(dp[j].k+1>dp[i].k)          因为j是从前往后推，所以是按字典序推过来的，只要用>判断就行；
                {
                    dp[i].sum=dp[j].sum+dp[i].num;
                    dp[i].k=dp[j].k+1;
                }
            }
        }
        cout<<dp[i].sum<<" ";
    }
    return 0;
}
```

---

## 作者：insprition (赞：4)

就是说给一串由 0~9 组成的序列


求 以 i (1~n) 结尾 的 最长不下降子序列 的 和


（最长不下降子序列不唯一时选编号字典序最小的）


 
###解

 

两步

1 求最长不下降子序列


2 求 步骤1 的和


 
1

O(n^2) 暴力不必说 (因为数字只有 0~9 十个， 即10\*n， 所以就是 O(n)啊)


O(n logn) 树状数组 log10≈3.几，即3\*n 也可以算 O(n)啊；


对于 数值x 查询 以0~x结尾的 最长不下降子序列 长度


所得长度 +1 即为所求


用 树状数组 维护


！！！！


树状数组没有 0 啊


那就每个数 查询和更新 都加一


因为这个我卡了 TLE 当时相当不解



2

再开一个数组保存序列和


在步骤1中一起维护即可


详见代码 query() 和 update()


 

###代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define low k&-k
int ret,l,n,tree[10010],s[10010];
void query(int k){ //查询 
    ret=s[k],l=tree[k]; //ret为序列和 l为长度 两个全局变量 
    for(k-=low;k;k-=low)
        if(l<tree[k])//因为要保证字典序 所以 == 时 答案不改
            l=tree[k],ret=s[k]; //长度更改时 序列和才会更改 
}
void update(int k){ //更新 
    for(;k<=10;k+=low)
        if(tree[k]<l) //因为要保证字典序 所以 == 时 不作修改 
            tree[k]=l,s[k]=ret; //长度更新时 序列和才会更新 
}
int main(){
    scanf("%d",&n);
    for(int v,i=1;i<=n;i++){
        scanf("%d",&v);
        query(v+1); //树状数组没有 0 要统一 +1  
        ret+=v; 
        l++;//长度再加上 本身 
        printf("%d ",ret);
        update(v+1);
    }
    return 0;
}/*5
```
0 2 5 3 4\*/

**[博客](http://www.cnblogs.com/1227xq/p/6906790.html)**


---

## 作者：zpf_13516358919 (赞：3)

用了O(n)的方法,姑且也算是dp吧

题目中只有10个数,所以完全不需要O(n^2)暴力...

附上代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define in(x) read(x)
#define LL long long
int gi,yi;char c;
LL Max(LL a,LL b){return a>b ? a : b;}
LL Min(LL a,LL b){return a<b ? a : b;}
LL lowbit(LL x){ return x&-x;}
const int maxn=100010;
const LL INF=(LL)1<<60;
using namespace std;
LL f[10],g[10],sum[10010],n,ai,maxx,pos,Pos;
void read(LL &x)
{
    gi=0,yi=1,c=getchar();
    while(c<'0'||c>'9'){if(c=='-')yi=-1;c=getchar();}
    while(c>='0'&&c<='9')gi=gi*10+c-'0',c=getchar();
    x=gi*yi;
}
void put(LL x)
{
    if(x>9)put(x/10);
    putchar(x%10+48);
}
int main()
{
//    freopen("in.txt","r",stdin);
//    freopen("out.txt","w",stdout);
//    f[i]//以数字i结尾的序列的最长长度 
//    g[i]//以数字i结尾的最长序列的最后一个数的位置
//    sum[i]//以第i个数结尾的序列的分数
    in(n);
    for(int i=1;i<=n;i++)
    {
        in(ai);
        maxx=-1; pos=-1; Pos=INF;
        for(int j=ai;j>=0;j--)
        maxx=Max(maxx,f[j]);
        //找最长 
        for(int j=ai;j>=0;j--)
        if(f[j]==maxx)
        {
            if(Pos>g[j]) //在最长中找最小编号 
            Pos=g[j], pos=j;
            //pos记录转移的数 
        }
        f[ai]=f[pos]+1;
        sum[i]=sum[g[pos]]+ai;//先更新答案 
        g[ai]=i;//更新位置 
        put(sum[i]),putchar(' ');
     } 
    fclose(stdin);fclose(stdout);
    return 0;
}

```

---

## 作者：lyx613 (赞：3)

看看数据范围n<=10000 n2朴素过不了，但洛谷的神评测机------rn下附n2朴素代码：```delphi
rnvar a,f,num:array[0..10000]of longint;rn    b,c,d,i,j,k:longint;rnbeginrn  read(b);rn  for i:=1 to b do read(a[i]);rn  for i:=1 to b dorn  beginrn    f[i]:=1;num[i]:=a[i];rn    for j:=1 to i-1 dorn      if (a[j]<=a[i])and(f[j]+1>f[i]) thenrn      beginrn        f[i]:=f[j]+1;rn        num[i]:=a[i]+num[j];rn      end;rn  end;rn  for i:=1 to b do write(num[i],' ');rnend.rn直接在dp的同时植入求和运算
```

---

## 作者：回头是岸 (赞：2)

我们设f[i]表示以i结尾的最长不下降子序列，g[i]表示第i号大朋友的分数，所以我们可以得到f[i]=max(f[j]+1,f[i])(1<=j<i),因为题目规定取编号最小的，所以我们不能枚举j时从i-1往前推。代码如下：

```cpp
for(int i=1;i<=n;i++){
	int mx=0;
	for(int j=1;j<i;j++)
	if(a[i]>=a[j])mx=max(mx,f[j]);
	f[i]=max(f[i],mx+1);
}
```
我们已经知道了怎样求最长不下降子序列，如何求答案，我们可以在求最长不下降子序列的过程中求，g[i]要加上g[j]的贡献，就得满足条件f[i]==f[j]+1&&a[i]>=a[j]。我们可能会加多次，所以我们在加完编号最小的贡献就要退出，全部代码如下：
```cpp
#include<bits/stdc++.h>
const int maxn=1e4+5;
using namespace std;
int n,f[maxn],a[maxn],g[maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),g[i]+=a[i];
	for(int i=1;i<=n;i++){
		int mx=0;
		for(int j=1;j<i;j++)
                    if(a[i]>=a[j])mx=max(mx,f[j]);
		for(int j=1;j<i;j++){
			if(f[j]==mx&&mx+1>f[i]&&a[i]>=a[j]){
				f[i]=mx+1;g[i]+=g[j];
				break;//防止加多次
			}
		}
	}
	for(int i=1;i<=n;i++)printf("%d ",g[i]);
	return 0;
}
```


---


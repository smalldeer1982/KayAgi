# [NOIP 1996 提高组] 砝码称重

## 题目描述

设有 $1\mathrm{g}$、$2\mathrm{g}$、$3\mathrm{g}$、$5\mathrm{g}$、$10\mathrm{g}$、$20\mathrm{g}$ 的砝码各若干枚（其总重 $ \le 1000$），可以表示成多少种重量？

## 说明/提示

**【题目来源】**

NOIP 1996 提高组第四题

## 样例 #1

### 输入

```
1 1 0 0 0 0```

### 输出

```
Total=3```

# 题解

## 作者：pantw (赞：472)

bitset基础题。


我们用一个bitset保存每个重量能否被称出即可。


实现细节详见代码。(喜欢的话给个赞呀qaq)


```cpp
#include <bitset>
#include <cstdio>
int a[10], w[10] = {1, 2, 3, 5, 10, 20};
std::bitset<1010> S;
int main() {
    for(int i = 0; i < 6; i++) scanf("%d", a + i);
    S[0] = 1;
    for(int i = 0; i < 6; i++) for(int j = 0; j < a[i]; j++) S |= S << w[i];
    printf("Total=%d\n", S.count() - 1);
    return 0;
}
```

---

## 作者：Kan_kiz (赞：456)

正经·DP题解

一道非常好的背包练手题（

sto（注：原思路来源 SLYZ_0120 的题解）orz

### 开始这道题

##### 1.~~输入六个数，存进数组中~~

##### 2.初始化 f 数组为0。 f [ i ] 表示重量为 i 的情况是否出现过（下面代码使用的是 int 数组，当然用 bool 数组会更好）。如果出现过即为真（1），未出现过即为假（0）。

##### 3.这里我们要将 f [ 0 ] 设为 1 。总重量为 0 即一个砝码也不用，我们将这种情况设为已有。

##### 4.第一重循环。
```cpp
for (int i = 1 ; i <= 6 ; i++ )
```
             我们枚举六种重量的砝码。

##### 5.第二重循环
```cpp
for (int j = 1 ; j <= a[i] ; j++ )
```
             这里的a[i]指的是第 i 种砝码的个数。即我们进行循环的次数就是第i种砝码的个数（你是不是觉得我在说废话 但是请好好理解）

##### 6.第三重循环
```cpp
for (int k = 1000 ; k >= 0 ; k-- )
```
             三重循环分开来或许不是很好理解。接下来我们来结合三个循环分析。
             
##### 7.代码核心



```cpp
for (int i=1 ; i<=6 ; i++)

    for (int j=1 ; j<=a[i] ; j++)
    
        for (int k=1000 ; k>=0 ; k--)
        {
        
             if (f[k]==1)
			 {
				 f[k+w[i]]=1;
			 }
             
        }
```
### 请按照提示看以上代码

#### 1.首先，请简要看完三重循环并尝试初步理解。

#### 2.看循环内部语句。
      
           看这两个语句时，请尝试将样例代入（建议自己设个稍微大一点点点点的样例 真的大一点点就够了 因为 1 不够特殊），从 i=1，j=1，k=1000的情况开始，尝试想想，当是这种情况时， f 数组发生了什么变化？
           接着想想，当k不停的自减，会发生什么呢？
           最后想想，当 i=1，j=1，k=0的时候会发生什么呢？那又代表了什么意思？

       思考：循环内部的语句。
                    接下来，我们指的“某种重量成立”，指的是这个重量可以被称出来。（也可以说，有这么一些砝码可以组成这个重量）
                    其实，当六种砝码的个数都是无限的时候，因为我们有一种砝码的重量为1，所以所有重量都可以 成立 。
                    但是，当六种砝码的个数是有限的时候，并不是所有的重量都能够 成立 。
                    那么，我们的 f 数组，其实就是用于标记  “这种重量是否成立”  。
                    
                    我们有这么一个状态 X ， 状态 X 的砝码重量为 w 。（即重量 w 成立）
                    那么如果我们有一个 “未使用” 的砝码 ，其重量为 p ，那么
                    重量   w+p    也是成立的。（这句话请认真理解）
                    
                    
                    带着这个思路，请看向循环  “k=1000……” 以及 循环内部的语句  。
                    这里的 k ，其实就是刚刚所提到的重量 w 。
                    f [ k ] == 1 ，就是重量 k 成立的意思 。那么我们加上 w [ i ]  （相当于刚刚的 p ），即第i种砝码的重量，那么得到的重量依然是成立的。
                    
#### 3.请看向第二个循环语句
          
            顺着我们上一条的思路。
            返回我们文章开头的地方，对于 j 这重循环的介绍。
            
            “这里的 a [ i ] 指的是第 i 种砝码的个数。即我们进行循环的次数就是第i种砝码的个数”。
            
            接着看向我们上一条中
            “ 如果我们有一个 ‘未使用’ 的砝码 ”
            
            其实在我们进行这一重循环的时候，就相当于，我们将第 i 种砝码 “摆成一排”。
            
            对，你现在可以打大开脑洞，想着你本来有10个一样重的砝码，然后你把这些砝码在你面前整齐de放成一排——————
            
            现在拿起你的第一个砝码。我们开始找已知的 “成立的重量”。 找到一个成立的重量后，我们就可以确定，这个成立的重量加上你手中的这个砝码也是一个成立的重量。那么我们将新的 “成立的重量” 标记。
            
            现在拿起你的第二个砝码。我们继续找已知的 “成立的重量”。 注意，这时成立的重量，包含了我们刚刚拿第一个砝码时标记的 “新的成立的重量”。接下来的步骤类似上面。
            
            ………………
            
            刚刚的砝码用完了，
            接着，你又拿出了跟刚才不同重量的另外10个一样重的砝码，摆成一排……
            接下来发生了什么也类似上面。
            
            
            当你把所有的砝码都用完的时候，所有被标记的 “成立的重量”，就是使用这些砝码的所有 “成立的重量” ！
            
            最后，只要一遍扫过去 ~ 统计有多少种成立的重量就可以啦 ~
            
#### 4.请思考：为什么 k 要从 1000 到 1  而不是  1 到 1000  呢？
            
            如果这个问题你一下子想不明白，那你可以先试着将下面的完整代码复制，把 for (int k=1000;k>=0;k--) 改成 for (int k=0;k<=1000;k++) ，再测一下样例，看一下结果是多少。
            
            
            
            
            如果你还没想清楚：惊不惊喜！意不意外！答案居然是1000！
            
            以样例为例子，我们可以想到，当 k=0 的时候， f[1] 就会被标记为成立。但接下来，当 k=1 的时候，f [2] 也会被标记为成立。那么是不是一遍扫过去，f [1~1000] 全部都被标记为成立了呢！
            
            在本题中，对于一个成立的重量 w ，一个砝码的重量 p ，w+p 一定大于 w。
            所以这样就会造成    一个砝码使用多次的情况  （请认真体会
            
            就是我们前一条所说的 “当六种砝码的个数都是无限的时候，因为我们有一种砝码的重量为1，所以所有重量都可以 成立 。”
            
                    
### 完整代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
const int MAXN=1001;
int a[7],w[7]={0,1,2,3,5,10,20},f[MAXN]={};//a数组存放的是每种砝码的数量，w数组是每种砝码的重量，f[i]表示 “重量 i 成立”
int main()
{
	for (int i=1;i<=6;i++)//输入
	{
		scanf("%d",&a[i]);
	}
	f[0]=1;//初始化!   f [0] 就是不使用任何砝码的情况
	for (int i=1;i<=6;i++)//枚举六种砝码
	{
		for (int j=1;j<=a[i];j++)//枚举每个砝码
		{
			for (int k=1000;k>=0;k--)//寻找 已成立的重量
			{
			    if (f[k])//若此重量成立
				{
					f[k+w[i]]=1;//那么这个重量加上这个未使用的砝码的总重量也成立
				}
			}
		}
	}
	int ans=0;
	for (int i=1;i<=1000;i++)//一遍扫，统计成立的重量。记住从1开始循环，因为不使用砝码的情况在这里不统计
	{
		if (f[i]) ans++;
	}
	printf("Total=%d",ans);//输出
	return 0;//华丽丽de结束！
 } 
```

### 给大佬们递AC！！

---

## 作者：ysy666 (赞：137)

想到一种稍微简单的方法，思想类似于装箱问题；

先打一个b[10]={0,1,2,3,5,10,20}；

再用a数组记录展开后的a1个1g，a2个2g。。

举个栗子：2 1 2 1 1 1存在a里就是1 1 2 3 3 5 10 20 ；

a数组里元素个数为a1~a6的和，记为num

从1到num扫一遍，把所有可能出现的情况在一个bool数组中标记出来；

最后从v到0跑一遍，找到的一个非零的值ans++；

跑完之后ans即为所有情况数；

附上代码


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[10010],x,num,b[10]={0,1,2,3,5,10,20},ans;
bool t[10010];
int main()
{
    for(int i=1;i<=6;i++)
    {
        cin>>x;
        for(int j=1;j<=x;j++)  a[++num]=b[i];  //在a数组里记录所有砝码重 
    }
    t[0]=1;
    for(int i=1;i<=num;i++)  //num即为a数组中元素的个数 
        for(int j=1010;j>=0;j--)  if(t[j])  t[j+a[i]]=1;  
        //这里一定从最大称重跑到0，否则新出现的情况会影响到后面的记录 
    for(int i=1;i<=1010;i++)  if(t[i])  ans++;  //如果某一位为true说明可能出现这种情况 
    printf("Total=%d",ans);
    return 0;
}
```

---

## 作者：小周猪猪 (赞：68)

很显然，这是一道01背包求方案数

有的人用多重背包，有的直接暴力过，个人认为01简单快捷而且更加好些，具体思路如下：

### 1.把题目转换成01背包，把每次进来的物品个数一个个的拆分为单个物品存放在c数组内

### 2.将c数组进行01背包求方案数的方法求解，求解方法如下：

## 设f[i][j]为体积为i的方案总和

### 那么，当第i件物品不选时，f[i][j]=f[i-1][j]
那么如果选择了呢，f[i][j]=f[i-c[i]];

### 那么两者累加，就是f[i][j]=f[i-1][j]+f[i-c[i]]
#### 为了减少空间浪费，去掉第一维，可以得到：

## f[i]=f[i]+f[i-c[i]],也就是f[i]+=f[i-c[i]]

##### 其余做法和01背包大致相同：

#### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10000000]={};
int c[10000000]={};
int main()
{
	int n=0;
	int num[10]={0,1,2,3,5,10,20};//先将砝码大小进行预处理
	for (int i=1;i<=6;i++)
	{
		int k;
		cin>>k;
		for (int j=1;j<=k;j++) 
		    c[++n]=num[i];
	}//转换01背包
	f[0]=1;
	int sum=0,ans=0;
	for (int i=1;i<=n;i++)
	    sum+=c[i];//求出01背包体积最大值
	for (int i=1;i<=n;i++)
	    for (int j=sum;j>=c[i];j--)
	        f[j]+=f[j-c[i]];//DP
	for (int i=1;i<=sum;i++)
	    if (f[i]) ans++;//累加所有可能出现的方案总和
	cout<<"Total="<<ans;
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：47)

这题由于数据范围很小，可以直接枚举。

注意:

输出结果是用这些砝码能称出的不同重量的#个数,而不是方法种数。

所以这里用a数组存，a[i]这几个砝码能否称出为i的重量。

```delphi

var a1,a2,a3,a4,a5,a6,s,b,c,d,e,f,g,i:longint;
    a:array[1..1000] of boolean;
begin
    fillchar(a,sizeof(a),false);
    write('Total=');
    read(a1,a2,a3,a4,a5,a6);
    for b:=0 to a1 do
        for c:=0 to a2 do
            for d:=0 to a3 do
                for e:=0 to a4 do
                    for f:=0 to a5 do
                        for g:=0 to a6 do
                            a[b+c*2+d*3+e*5+f*10+g*20]:=true;
    for i:=1 to 1000 do
        if a[i] then inc(s);
    write(s);
end.

```

---

## 作者：ICE_Wol (赞：44)

[题面](https://www.luogu.org/problemnew/solution/P2347)

**注 ： 部分内容参考自 李煜东《算法竞赛 进阶指南》**

## 简析 $bitset$

本质上， $bitset$ 就是一个封装了一堆奇奇怪怪操作并**支持状态压缩**的 $bool$ 数组，而且**支持基本的位运算**，那么我们该如何使用她~~（她？）~~呢？

1. 头文件 ：
```
#include<bitset>
```

	不过，使用时不要忘了命名空间，或者加上：
```
std::xxxxx();
using namespace std;
```

2. 声明 ：
	
    如何声明一个 $bitset$ ？
    
    ```
    bitset<50> s;
    ```
    以上代码声明了长度为 $50$ 的 $bitset$ 并用 $0$ 填充
    
    还有一些神奇的操作，例如：
    
    ```
    bitset<50> s1(12);
    string str = "100110";
    bitset<50> s2(str);
    ```
    
    括号中的内容会自动填充到 $bitset$ 的末位中，超出 $50$ 位的部分会被~~残忍~~舍弃
    
    （**注意：**如果是整型，那么填充时会自动转换为二进制，如果是字符串，但是其中出现了 $0/1$ 以外的字符，就会~~爆炸~~）
    
3. 一些操作 ：

	基本位运算操作符都能用在这里，以本题为例~~（你终于想起来还有个题了）~~ ：
    ```
    s |= s << w[i];
    ```
    以上代码将 $s$ 左移了 $w[i]$ 位并与原来的 $s$ 取了并集
    
    同时，她也支持像数组一样的使用 $s[i]$ 直接访问 $s$ 的第 $i$ 位
    
4. 一些好用的函数：

	```
    s.count();
    ```
    返回 $s$ 中 $1$ 的个数
    ```
    s.any();
    s.none();
    ```
    当 $s$ 全为 $0$ 时，第一个函数返回 $false$ , 第二个函数返回 $true$
    
    当 $s$ 中有任何一位是 $1$ 时，第一个函数返回 $true$,第二个函数返回 $false$
    ```
    s.set();
    s.reset();
    s.flip();
    ```
    以上三个函数分别将 $s$ 全部设为 $1$,全部设为 $0$,全部取反
    
    值得注意的是，每一个函数都可以传入一个位置参数 $i$,可以只对该位进行操作
    
## 参考代码

了解完 $bitset$ 的基本操作之后，聪明的你~~（？）~~会做这题了吗？

```
#include<bitset>
#include<iostream>
using namespace std;
bitset<1001> s;
int w[] = {1,2,3,5,10,20};
int main(){
	int n;
	s[0] = 1;
	for(int i = 0;i < 6;i++){
		cin >> n;
		for(int j = 0;j < n;j++) s |= s << w[i];
	}
	cout << "Total="<< s.count() - 1;
	return 0;
} 
```

---

## 作者：zhongtaiyang (赞：38)

首先声明一下：此题测试数据太水了，以致于六个for循环都能过，我想讲一下这道题的最完美做法。

首先，观察题目，不难发现这是一个多重背包问题（背包总容量是一定的，每一个物品有规定的最多使用次数，求最多的质量和）。对于多重背包问题，常规想法是把有数量限制的物品分成若干件同样的物品，这样就转化成了基础的01背包问题，然而，这样会耗费过高的时间和空间复杂度，据传，最高复杂度甚至可能达到n的立方，就在此时，以倍增算法为思想基础的二进制拆分储存方法也就相应地出现了（即把物品的数量x拆成2的0次方加2的1次方……再加上剩下的那个数），就此，多重背包问题在二进制拆分的数据存储支撑下完美地被我们转化为了多重背包问题，至于怎么输出答案，只要把1到总重量的每一个数都扫一遍，有几个在当前砝码重量下可以取到此砝码的值，答案就是几。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
using namespace std;
const int mass={0,1,2,3,5,10,20};//砝码质量
int max;//此为背包的最大载重
int k=0;//用来记录拆分后的数量
int num[20];//用来存放砝码的数量
int c[4000];//用来存放拆分后砝码的质量
int dp[4000];//用来存放在ig中的最大质量
int sum;//用来记录答案
int main()
{
    for(int i=1;i<=6;i++)
    {
        cin>>num[i];
        m+=num[i]*mass[i];
    }
    for(int i=1;i<=6;i++)
    {
        for(int j=1;j<=num[i];j*=2)//开始关键的二进制拆分
        {
            c[k]=j*mass[j];
            num[i]-=j;
            k++;
        }
        if(num[i])
        {
            c[k]=num[i]*mass[i];
            k++;
        }
```
}//二进制拆分完成，现在变成了一个简单的01背包问题
```cpp
    for(int i=1;i<=k;i++)
    {
        for(int j=m;j>=c[i];j--)
            dp[j]=max(dp[j],dp[j-c[i]]+c[i]);
    }
    for(int i=1;i<=m;i++)
    {
        if(dp[i]==i)    sum++;
    }
    printf("Total=%d\n",sum);
    return 0;
}
```

---

## 作者：wpy233 (赞：14)

蒟蒻学习DP中……一连$A$了十几道$DP$~~水~~题

昨晚这题后，真的有一点感慨、、、（感慨其实太深了）

- 这道题目，让你求一共有多少种称出物品的克数，还告诉你【总克数不大于$10^3$】，一看就肯定是一个打标记然后计数输出的题。

- 然后一看标签，啊，$dp$。所以立即想到的就是建立一个$dp$数组，用来存放第$i$种克数的情况是否成立。

- 接着就开始想~~那个鬼畜的方程~~。

> $dp[0]$肯定要打上标记，因为什么都不取就可以了。

> 那么，如果$dp[i]$个成立，就意味着$dp[i$+一个合法的克数$]$必定也成立。

> 所以，遍历六种砝码的只数，然后从可以形成的**最大克数**往$0$遍历，碰到$dp[i]$合法的，就将$dp[i$+一个合法的克数$]$标记成合法。

> 最后遍历**1到最大值**（注意，是1，因为题目中已经明确写了$0$不算）输出。

上代码
```
#include <bits/stdc++.h>
using namespace std;
bool dp[1005];//第i克的情况是否成立
int a[7];//六种砝码的个数
int ans;
int b[7]={0,1,2,3,5,10,20};//为方便节省时间，减少判断次数，直接预存处理
int mx;
int main()
{
	dp[0]=true;//必须标记！！！
	for(int i=1;i<=6;i++)
	{
		cin>>a[i];
		mx+=a[i]*b[i];//mx表示最大称重克数
	}
	for(int i=1;i<=6;i++)
		for(int j=1;j<=a[i];j++)//第i种砝码有a[i]个
			for(int k=mx;k>=0;k--)
				if(dp[k]==true)
					dp[k+b[i]]=true;//标记
	for(int i=1;i<=mx;i++)
		if(dp[mx])
			ans++;//计数
	cout<<"Total="<<ans<<endl;//输出
    return 0;
}
```
这份代码$92$分。当然，我是不会告诉你，漏洞在哪里的。如果你找到了漏洞，我就借机吐槽一下：

## ~~LG的数据太水了~~

漏洞：`if(dp[mx])`->`if(dp[i])`

---

## 作者：SLYZ_0120 (赞：14)

蒟蒻的第六篇题解……第一次写dp题的题解（逃）不知道过不过的了……


其实这道题的数据是比较弱的……所以楼下的dalao们利用6重循环嵌套也是强行过了，可见这道题其实是比较H2O的。

**但是主要是为了练dp所以本蒟蒻还是规规矩矩的上了背包（大概）**写的不好dalao可忽略

首先是读入开一个c数组，另外需要一个w数组存放第i种砝码的重量。

然后一种质量一种质量枚举过去，用f数组存放当前的质量f[k+w[i]]是否已经被标记可以表示出来，如果没有就标记为1，

最后从1开始统计用变量ans存放就可以了……


还是上代码吧

             
```cpp
//防伪标识
#include<bits/stdc++.h>
using namespace std;
bool f[1001]; //f数组存放第k+w[i]种重量有没有被称出来过
int c[7],w[7] = {0,1,2,3,5,10,20}; // 这里的0一定要注意！！数组的下标从0开始
int main(){
    for(int i = 1;i<=6;i++)
        scanf("%d",&c[i]);
    memset(f,0,sizeof(f));
    f[0] = 1; //初始化非常非常重要！！
    for(int i = 1;i<=6;i++)
        for(int j = 1;j<=c[i];j++) // 每一种质量的砝码进行枚举
            for(int k = 1000;k>=0;k--){ //k表示当前质量
                if(f[k]&&k+w[i]<=1000)
                    f[k+w[i]] = 1;  // 如果第k+w[i]个没有称出来过就标记上
            }
        int ans = 0;
        for(int i = 1;i<=1000;i++)//注意这里从1开始
        {
            if(f[i]) ans++;
        }
        printf("Total=%d",ans); //输出的格式要注意
        return 0;
}
```

---

## 作者：小菠萝 (赞：12)

### 这道题可以用大bitset来解决的，STL大法好

首先我们先从这道题来入手：

我们可以开心的发现这道题的转移方程很好写，我们枚举重量，然后再枚举每个物体，如果当前重量** f[i]** 可以被枚举出来，那么**f[i+w[i]]**也可以被枚举出来对吧。
好的那么一个n方dp 写完了，我们考虑一下优化

**bitset**

我们可以理解为这是一个类似于bool数组的东西，
却可以进行和二进制一样的操作，每一位只有0或1，但是，bitset却**自带1/32的超小常数**，简直就是卡常神器啊。

（关于bitset的各种基本操作请自行百度）

我们考虑一个bitset，假设6位，000101 那么表示第三个与第一个重量可以被枚举出，简而言之，我们用0代表当前重量无法被搞出，1代表可以被搞出，那么当我们有一个新的重量，（假设为2），那么(tqy是我开的bitset)   

**tqy|=(tqy<<w[i])**  

这个东西是不是就是江000101先左移2位，即表示我们当前重量加上2的重量是可以被搞到的，然后   |  ，就可以更新答案了，那么我们最后统计一下bitset变量中的1的个数就是我们可以枚举到的数的个数了
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
using namespace std;
bitset<10000> tqy;
int a[100000],w[8]={0,1,2,3,5,10,20,0};
int main(){
	rep(i,1,6) scanf("%d",&a[i]);
	tqy[0]=1; 	
	rep(i,1,6) rep(j,1,a[i]) tqy|=(tqy<<w[i]);
	cout<<"Total="<<tqy.count()-1<<endl;
	return 0;
}

```
bitset还是一种很强大的STL了，其超小常数一直被卡常专家所喜欢，而且bitset可以爆破掉不少题或是暴力分，而且代码比较短，建议入手



---

## 作者：白青sama (赞：9)

生成函数的裸题

（话说这题问什么没有组合数学的标签）

___

设质量为 $w$ 的砝码有 $n$ 个，构造生成函数：
$$f(w,n)=1+x^w+x^{2w}+x^{3w}+...+x^{nw}$$

本题 $w$ 是固定的，则有：
$$f(1)=1+x+x^2+x^3w+...+x^{a_1}$$
$$f(2)=1+x^2+x^{4}+x^{6}+...+x^{2a_2}$$
$$f(3)=1+x^3+x^{6}+x^{9}+...+x^{3a_3}$$
$$f(5)=1+x^5+x^{10}+x^{15}+...+x^{5a_4}$$
$$f(10)=1+x^{10}+x^{20}+x^{30}+...+x^{10a_5}$$
$$f(20)=1+x^{20}+x^{40}+x^{60}+...+x^{20a_6}$$

设 
$$F(x)=f(1)\times f(2)\times f(3)\times f(5)\times f(10)\times f(20)$$

对于 $F(x)$ 中的每一项 $ix_j$ ， 表示有 $i$ 种方法称量出 $j$ 的重量

本题中 $i$ 并没有用，统计 $j$ 的个数即可

---

## 作者：皮皮虾letusgo (赞：8)

暴力出奇迹，这题真没什么难度，六重循环加桶解决。

上AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <iomanip>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <stack>
#include <queue>//超长头文件(づ￣ 3￣)づ
using namespace std;
int main ()
{
    int p[1005]={0};//记录总和
    int a[7];
    for (int i=1;i<=6;i++)
    cin>>a[i];//输入
    for (int b=0;b<=a[1];b++)
    {
        for (int c=0;c<=a[2];c++)
        {
            for (int d=0;d<=a[3];d++)
            {
                for (int e=0;e<=a[4];e++)
                {
                    for (int f=0;f<=a[5];f++)
                    {
                        for (int g=0;g<=a[6];g++)
                        {
                            int s=0;
                            s=s+b+c*2+d*3+e*5+f*10+g*20;//求和
                            p[s]=1;//状态变为1
                        }
                    }
                }
            }
        }
    }
    int t=0;
    for (int i=1;i<=1004;i++)
    if (p[i]) t++;//若为1，计数加一
    cout<<"Total="<<t<<endl;    //打印
    return 0;
}
```
没了~~~~
对没错，就是这么简单。


---

## 作者：Enigmatic (赞：7)

本体是一发动态规划的多重背包

这里有一种简单的方法，就是把每个数据都拆开

然而，这样只能用于数据较小的时候（楼下竟然还有六重循环！）

所以我用了一个比较简单的方法

就是把每个砝码的数量拆分成1，2，4，8等二的幂

这样就可以表示出所有的数

之后就转化成了一道01背包

```cpp
#include <bits/stdc++.h>
using namespace std;
const int val[10]={1,2,3,5,10,20};//砝码价值
int m;//背包的最大容量 
int k=0;//记录拆分后数量
int ans=0;//记录符合条件的结果 
int num[10];//存放砝码个数 
int value[2000];//存放拆分数量后的砝码重量 
int dp[2000];//dp[i]存放在ig中最大重量 
int main()
{ 
    for(int i=0;i<6;i++)
    {
        scanf("%d",&num[i]);//读入数据 
        m+=num[i]\*val[i]; 
    }
    for(int i=0;i<6;i++)
    {
        for(int j=1;j<=num[i];j\*=2)//二进制拆分 
        {
            value[k]=j\*val[i];//价值转化 
            num[i]-=j;
            k++;
        }
        if(num[i])
        {
            value[k]=num[i]\*val[i];
            k++;    
        }    
    }
    for(int i=0;i<k;i++)
    {
        for(int j=m;j>=value[i];j--)
            dp[j]=max(dp[j],dp[j-value[i]]+value[i]);//状态转移方程    
    } 
    for(int i=1;i<=m;i++)
    {
        if(dp[i]==i) ans++;//计算最终结果    
    } 
    printf("Total=%d\n",ans);//输出数据
    return 0;
}

---

## 作者：wawcac (赞：5)

下面的题解只有dp和暴力多重大循环，我就来个正宗dfs吧（这么裸的一题深搜题就这样被暴力浪费了）

（一直只会非递归的dfs，刚学会递归的dfs，拿这题练手，结果交了三四次才ac）

```cpp
#include<stdio.h>
bool vis[10000]={0};
int w[]={1,2,3,5,10,20},num[6];
int dfs(int cen,int tot)//cen存搜索树的层数（我知道层是后鼻音），tot存搜到目前为止的砝码总重
{
    if(cen==6)//搜到第6层就到头了
    {
        if(vis[tot]) return 0;这个重量原来已经搜过了
        vis[tot]=true;return 1;//原来还没搜到过
    }
    int ans=0;
    for(int i=0;i<=num[cen];i++)//枚举这一层砝码所选数量，把可能的种树加起来
    {
        ans+=dfs(cen+1,tot+w[cen]*i);
    }
    return (ans);
}
int main()
{
    for(int i=0;i<6;i++) scanf("%d",num+i);
    printf("Total=%d",dfs(0,0)-1);//减一是排除一个都不选的情况
    return 0;
}

```

---

## 作者：土间太平 (赞：4)

【问题分析】

采用方法：深度优先搜索。问题的实质就是完成对不同的数值的组合，求能够形成多少种不同的组合。首先建一棵搜索树，如下图所示，然后对该搜索树做一次深度遍历。

#图被洛谷吃掉了

由上图可以知道每1种砝码都存在多种情况，可以取0～n个，同样当第1种砝码取0个的时候，同样第二种砝码存在多种取法，依次类推，即建立了如上图所示的搜索树。直接深搜1～6，直到depth>6，然后直接用一维数组，记录能够称重的砝码，统计该数组的值，得出能够称重的种类。

【程序代码】

```cpp
program  weight;
var f:array[0..1000]of longint;  //用于记录能够称重的不同重量
  a,w:array[1..6]of longint; 数组a存放砝码的个数，数组w存放砝码的重量
  s,i:longint;
procedure dfs(i:longint);
var j:longint;
begin
  if i>6 then begin        //完成1次6个砝码的组合，并记录能够称重的重量
    f[s]:=1;exit;
  end;
  for j:=0 to a[i] do begin     //按不同种类的砝码数量搜索能够称重的重量
    s:=s+j*w[i];
    dfs(i+1);        //  进入下一类别砝码重量的搜索
    s:=s-j*w[i];   //恢复现场，为搜索下一个重量做准备
  end;
end;
begin
  assign(input,'weight.in');reset(input);
  assign(output,'weight.out');rewrite(output);
  for i:=1 to 6 do read(a[i]);  //分别读入砝码的个数
  w[1]:=1;w[2]:=2;w[3]:=3; w[4]:=5;w[5]:=10;w[6]:=20;//定义砝码的重量
  fillchar(f,sizeof(f),0);  //初始化数组f；
  s:=0;      //初始化初值s，
  dfs(1);  //深度搜索调用过程
  s:=0;
  for i:=1 to 1000 do s:=s+f[i];
  writeln('Total=',s);
  close(output);close(input);
end.

```

---

## 作者：tudou123 (赞：4)

实际上类似于握手原理：
```cpp
#include<iostream> 
#include<bits/stdc++.h>
using namespace std;
int arr[100001];
int main(){
    int n=6;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    for(int i=0;i<6;i++){
        if(arr[i]==0){
            n--;
        }
    }
    cout<<"Total"<<"="<<((n+1)*n)/2;
}
```
：八分

还有一个四重循环：
```cpp
#include <iostream>
using namespace std;
int a[7],b[10000]={0};//b数组用于存储质量和情况，0表示没有被摆出来过，1表示被摆出来过
int main()
{
    int i,j,k,m,n,o;
    int tot=0;
    cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];
    for(i=0;i<=a[1];i++)
        for(j=0;j<=a[2];j++)
            for(k=0;k<=a[3];k++)
                for(m=0;m<=a[4];m++)
                    for(n=0;n<=a[5];n++)
                        for(o=0;o<=a[6];o++)
                            if(i+j+k+m+n+o)
                                if(!b[i*1+j*2+k*3+m*5+n*10+o*20])
                                {
                                    b[i*1+j*2+k*3+m*5+n*10+o*20]=1;
                                    tot++;//总数加一
                                }
    cout<<"Total="<<tot;//输出
    return 0;
}
```
八十分。。。


满分：
```cpp
#include<bitset>
#include<iostream>
using namespace std;
bitset<1001> s;
int w[] = {1,2,3,5,10,20};
int main(){
    int n;
    s[0] = 1;
    for(int i = 0;i < 6;i++){
        cin >> n;
        for(int j = 0;j < n;j++) s |= s << w[i];
    }
    cout << "Total="<< s.count() - 1;
    return 0;
} 
```


---

## 作者：Lyrics (赞：3)

说白了就是多重背包（裸题）

我们记录一个n数组表示所带有的数目，记录一个w数组表示所带有的重量（预处理比较方便）

题目中总重不超过1000，这就是解题的关键了说明我们可以大胆开数组，而且2维也是可以过的

当然我用的是1维数组。。。。

详细解释见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000006],n[10],w[10]={0,1,2,3,5,10,20,0,0,0},maxn,ans=0;//预处理 
int main(){
    memset(f,0,sizeof(0));
    scanf("%d%d%d%d%d%d",&n[1],&n[2],&n[3],&n[4],&n[5],&n[6]);
    maxn=n[1]*w[1]+n[2]*w[2]+n[3]*w[3]+n[4]*w[4]+n[5]*w[5]+n[6]*w[6];//找到你要多重背包的一个边界 
    f[0]=1;
    for(int i=1;i<=6;i++){//6个背包 
        for(int j=1;j<=n[i];j++){//每个背包n个东西 
            for(int k=maxn;k>=w[i];k--){//直接循环大法（从最远找回到最近）动态规划问题 
                if(f[k])continue;//这一步是为了ans的++才这样的 
                if(f[k-w[i]]){//当然，如果你的ans写在外面也是可以的，那么上面那句就可以删掉了 
                    f[k]=1;
                    ans++;
                }
            }
        }
    }
    /*for(int i=1;i<=maxn;i++)if(f[i])ans++;*/
    //就可以考虑用这一步来解决问题。 当然一边做一边处理我觉得比较好啦 
    printf("Total=%d\n",ans);
    return 0;
}
```

---

## 作者：GEM_IU_077 (赞：3)

###dfs（pascal)（虽然在搜索里查不到这题，但用深搜还是可以过的:-D）

采用方法：深度优先搜索。问题的实质就是完成对不同的数值的组合，求能够形成多少种不同的组合。首先建一棵搜索树，然后对该搜索树做一次深度遍历。由题意可以知道每**1**种砝码都存在多种情况，可以取**0～n**个，同样当第**1**种砝码取**0**个的时候，同样第二种砝码存在多种取法，依次类推，即建立了搜索树。直接深搜砝码**1～6**，直到**depth>6**，然后直接用一维数组，记录能够称重的砝码，统计该数组的值，得出能够称重的种类。

下附代码：

```pas
var
  s:array[0..1001] of longint;
  a,w:array[1..6] of longint;
  ans,i:longint;

procedure dfs(x:longint);
  var
    i,k:longint;
  begin
    if x>6
      then
        begin
          s[ans]:=666;
          exit;
        end;
    for i:=0 to a[x] do
      begin
        ans:=ans+i*w[x];
        dfs(x+1);
        ans:=ans-i*w[x];
      end;
  end;

begin
  readln(a[1],a[2],a[3],a[4],a[5],a[6]);
  w[1]:=1;
  w[2]:=2;
  w[3]:=3;
  w[4]:=5;
  w[5]:=10;
  w[6]:=20;
  ans:=0;
  dfs(1);
  ans:=0;
  for i:=1 to 1000 do
    if s[i]=666 then inc(ans);
  writeln('Total=',ans);
end.
```

---

## 作者：little_gift (赞：3)

##我发现我又不知道我是怎么做这道题的##

```cpp
#include <bits/stdc++.h> //万能头文件万岁
using namespace std;
bool b[1001];
const int e[]={0,1,2,3,5,10,20}; //6种砝码的重量
int i,j,x,k,s,y,maxx;
int main()
{
    b[0]=true; //初始化
    for (i=1;i<=6;i++)
    {
        scanf("%d",&x);
        for (j=maxx;j>=0;j--)
            if (b[j]) //如果这种重量已经有了
            {
                for (k=1;k<=x;k++)
                {
                    y=e[i]*k+j; //当用k个砝码时的重量
                    if (!b[y]) //如果没有称出过
                    {
                        b[y]=true;
                        if (maxx<y) maxx=y;
                        s++;//累加，maxx用于优化
                    }
                }
            }
    }
    printf("Total=%d\n",s); //输出最大重量
}
```

---

## 作者：Wahacer (赞：2)

比较水的数据，比较水的多重背包

相当于告诉你了药的种类，药的个数给你了，体积知道，价值知道，问优解。

个数不定，所以开始先扔个循环读进来

然后算是暴力枚举了，每种情况，如果有这个答案就不管，可以近似的理解为，所有的都放上去，一个一个取下来，去统计答案

算不上dp吧。。。。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std; 
template<class T>void read(T &x){
    x=0;int f=0;char ch=getchar();
    while(ch<'0'|ch>'9'){f|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=f?-x:x;
    return ;
}

int a[10];
int w[10]={0,1,2,3,5,10,20},ans;
int maxn;
int f[1000005];

int main()
{
    for(int i=1;i<=6;i++) {read(a[i]);maxn+=a[i]*w[i];}
    f[0]=1;
    for(int i=1;i<=6;i++)
        for(int j=1;j<=a[i];j++)
            for(int k=maxn;k>=w[i];k--)
                if(f[k]) continue;
                else if(f[k-w[i]]){
                    f[k]=1;
                    ans++;
                }
    printf("Total=%d",ans);
    return 0 ;
}
```

---

## 作者：Arendellian13 (赞：1)

显而易见的这是一道动态规划题。有人说是背包，但因为我没看出来，所以我就用了自己的方法，这里讲一下自己的思路。

首先我们注意到题目条件里的总重小于等于1000，而且各个砝码质量也是一定的。我们用$f_{i,j}$来表示只使用最小的$i$个砝码能否称出$jg$质量，能则为`true`,否则为`false`.

事情现在变得简单多了，因为我们现在已经有了如下这个双重循环的框架：
``` cpp
const int w[7] = {0, 1, 2, 3, 5, 10, 20};
bool f[7][1001];
int a[7];//存储每种砝码数量
for (int i = 1; i <= 6; i++)cin >> a[i];//读入
for(int i=1;i<=6;i++){
  for(int j=1;j<=a[i];j++){
    //一段代码
  }
}   
```
接下来所要做的就是往里面填东西。

那怎么填呢？

首先我们可以知道，对于每个$i\in\{x\in\mathbb{N}_+|x\in [1,6]\},\  j\in\{x\in\mathbb{N}_+|x\in [1,a_i]\}$，总有$f_{i,j\cdot w_i}=true$,所以我们可以得到更新后的代码：
``` cpp
const int w[7] = {0, 1, 2, 3, 5, 10, 20};
bool f[7][1001];
int a[7]
for (int i = 1; i <= 6; i++)cin >> a[i];
for(int i=1;i<=6;i++){
  for(int j=1;j<=a[i];j++){
    f[i][j*w[i]]=true;
  }
}
```
但是很显然这样会少情况，比如说题目给的样例中，$1g+2g$的情况就会少掉，那怎么办呢？我的想法是再加一重循环，每次都把$i-1$行扫一遍，遇到值是`true`的就将此时的质量与之前的$j\cdot w_i$相加得到的新质量也赋为`true`,得到如下代码：
``` cpp
const int w[7] = {0, 1, 2, 3, 5, 10, 20};
bool f[7][1001];
int a[7]
for (int i = 1; i <= 6; i++)cin >> a[i];
for(int i=1;i<=6;i++){
  for(int j=1;j<=a[i];j++){
    f[i][j*w[i]]=true;
    for (int k = 1; k <= 1000; k++){
      if (f[i - 1][k]) f[i][j * w[i] + k] = true;
    }
  }
}
```
最后输出：
```cpp
int ans=0;
for(i=1;i<=1000;i++)
  for(j=1;j<=6;j++)
    if(f[i][j])ans++;
cout<<"Total="<<ans;
```
但这样太慢了，虽然我没有想到把$n^3$优化到$n^2$的方法，但在输出和第三重循环还可以有小幅优化。

定义$maxf_i$表示用最小的$i$种砝码所能称出的最大质量，那么很显然$maxf_i=max_{i-1}+a_i\cdot w_i$,于是第三重循环里`k<=1000`可以改为`k<=maxf[i-1]`

另外对于输出，我们可以发现如果每次更新下一行时先把前一行复制下来，最后输出只要一重循环；同时我们又发现，在中间的第二重循环中，若$j$从0开始循环，就可以起到上面说的复制下来的效果，于是我们可以得到最终的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int w[7] = {0, 1, 2, 3, 5, 10, 20};
int a[7], maxf[7];
bool f[7][1001];
int ans = 0;
int main()
{
    int i, j, k;
    memset(f, false, sizeof(f));
    memset(maxf, 0, sizeof(maxf));
    for (i = 1; i <= 6; i++){
        cin >> a[i];
        maxf[i]=maxf[i-1]+a[i]*w[i];
    }
    for (i = 1; i <= 6; i++)
    {
        for (j = 0; j <= a[i]; j++)
        {
            f[i][j * w[i]] = true;
            for (k = 1; k <= maxf[i - 1]; k++)
            {
                if (f[i - 1][k])
                {
                    f[i][j * w[i] + k] = true;
                }
            }
        }
    }
    for (i = 1; i <= maxf[6]; i++)
    {
        if (f[6][i])
            ans++;
    }
    cout << "Total=" << ans;
    system("pause");
    return 0;
}
```

---

## 作者：OsvaldoAsensioLopez (赞：1)

这是个多重背包问题，既然是多重背包，那么就会有很多相同的物品，可以把每件物品当作num[i]件相同物品存放进数组，用普通的01背包处理，但这样时间复杂度太高，大数据不能AC，所以需要优化。

我们可以将每种物品个数按照二进制拆分，形如a=1+2^1+2^2+…+2^n+1，然后将这些分解出的个数乘以单件该类物品的价值，得出2^n个这样物品的总价值再放入value[k]数组中进行递推，这样既节省空间，又节省时间

、、、cpp



```cpp
#include <iostream>
using namespace std;
int main() {
    int num[10];//num[i]表示第i种砝码的个数
    int val[10]={1,2,3,5,10,20};//val[i]表示第i种砝码的单个价值 
    int m=0;//背包容量 
    int k=0;//存放砝码个数 
    int ans=0;
    int f[2001]={0};
    int value[2001];
    for(int i=0;i<6;i++) {
        cin >> num[i];
        m+=val[i]*num[i];//计算天平能存放的最大砝码质量（即背包容量） 
    } 
    //针对每种砝码进行二进制拆分 
    for(int i=0;i<6;i++) {
        for(int j=1;j<=num[i];j*=2) {//拆分的个数为2^n 
            value[k]=val[i]*j;//价值转换到第k个 
            num[i]-=j;//数量减掉j 
            k++;
        }
        if(num[i]!=0) {//如果还没分完,最后再分一次 
            value[k]=val[i]*num[i];
            k++;
        }
    }
    //01背包
    for(int i=0;i<k;i++) {
        for(int j=m;j>=1;j--) {
            if(j>=value[i]) f[j]=max(f[j],f[j-value[i]]+value[i]);
        }
    }
    for(int i=1;i<=m;i++) {
        if(f[i]==i) ans++;//天平装满了就统计方案 
    }
    cout << "Total=" << ans << endl;
    return 0;
}
、、、
```

---

## 作者：MR_DENGOU (赞：1)

此乃C语言程序！

看C语言的人看C++看不懂，于是我作为一个学C语言的人，就发了这一个题解!

```cpp
#include<stdio.h>
int c[8],k,b[8];
bool a[1002];//全程变量一开始自动全赋0
int main() {
    scanf("%d%d%d%d%d%d",&b[1],&b[2],&b[3],&b[4],&b[5],&b[6]);//输入
    for(c[1]=0; c[1]<=b[1]; c[1]++)//每一个都枚一次
        for(c[2]=0; c[2]<=b[2]; c[2]++)//我一开始定数组，就是为了少设变量
            for(c[3]=0; c[3]<=b[3]; c[3]++)//从用0个开始，一直到有几个
                for(c[4]=0; c[4]<=b[4]; c[4]++)
                    for(c[5]=0; c[5]<=b[5]; c[5]++)
                        for(c[6]=0; c[6]<=b[6]; c[6]++)
                            if(c[1]==0&&c[2]==0&&c[3]==0&&c[4]==0&&c[5]==0&&c[6]==0);//不能全部不用
                            else if(a[c[1]+c[2]*2+c[3]*3+c[4]*5+c[5]*10+c[6]*20]==0) {//如果没有摆出过c[1]+c[2]*2+c[3]*3+c[4]*5+c[5]*10+c[6]*20这一种重量
                                a[c[1]+c[2]*2+c[3]*3+c[4]*5+c[5]*10+c[6]*20]=1;//赋为摆出过
                                k++;//累加器加一个方案
                            }
    printf("Total=%d",k);//输出
    return 0;//个人习惯，可有可无
}
```
我不明白为什么那么多人动归，
这样不跟容易吗？


---

## 作者：PTC06 (赞：1)

很简单的一题。用枚举可以AC。

思路：

首先，定义一个set，名为s。

然后，直接六重循环枚举，然后将结果加进s里面，由于set会自动去重（正好符合题意），所以直接输出s.size()-1即可。（减一是因为需要减去不用任何砝码的那一个情况）

程序如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a1,a2,a3,a4,a5,a6,i1,i2,i3,i4,i5,i6;
int main()
{
    cin>>a1>>a2>>a3>>a4>>a5>>a6;           //输入
    set<int> s;        //定义一个set
    for (i1=0;i1<=a1;i1++)
    {
        for (i2=0;i2<=a2;i2++)
        {
            for (i3=0;i3<=a3;i3++)
            {
                for (i4=0;i4<=a4;i4++)
                {
                    for (i5=0;i5<=a5;i5++)
                    {
                        for (i6=0;i6<=a6;i6++)              //六重循环枚举
                        {
                            int tem=i1+i2*2+i3*3+i4*5+i5*10+i6*20;   //按照题目给出的每一个砝码的重量乘这个砝码的数量，然后相加。
                            s.insert(tem);      //将tem插入s中。
                        }
                    }
                }
            }
        }
    }
    cout<<"Total="<<s.size()-1;            //输出。
}
```

---

## 作者：1jia1 (赞：1)

看到没有c++题解，果断嗨一发（你TM吸毒啊）

数据比矿泉水还水，所以果断暴力6重搜，而且不需要剪枝（也剪不了）。

记录我是用标记（因为最多1000重量）。

```cpp
-#include <iostream>-
-using namespace std;-
-int a[7]={0},s=0,b[1001]={0};-
-int main()-
-{-
-    for(int i=1;i<=6;i++)cin>>a[i];-
-    for(int i1=0;i1<=a[1];i1++)for(int i2=0;i2<=a[2];i2++)for(int i3=0;i3<=a[3];i3++)for(int --i4=0;i4<=a[4];i4++)for(int i5=0;i5<=a[5];i5++)for(int i6=0;i6<=a[6];i6++)
-    {-
-        b[i1+i2*2+i3*3+i4*5+i5*10+i6*20]=1;---这个重量标记
-    }-
-    for(int i=1;i<=1000;i++)if(b[i]==1)s++;---如果有这个重量，就+1
-    cout<<"Total="<<s;-
-    return 0;-
-}-
```

---

## 作者：ShineEternal (赞：1)

## 题目链接：
https://www.luogu.org/problem/P2347

## 分析：
这道题应该不难看出是一道多重背包的题目。

#### 那么我们会有两种思路：

- 按照普通的计算方式，记$f[i]$为背包容量为i时能装到的最大质量。这样最后判断能否装满$(f[i]==i)$即为能否称出一种方案

- 记$f[i]$为能否称出i的质量（$0/1$），那么最后就判断有多少个1就行。

#### 那么下面就总结两种方法：

- 普通的多重背包做法：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int v[10],w[10],f[10005]; 
int main()
{
	v[1]=1;
	v[2]=2;
	v[3]=3;
	v[4]=5;
	v[5]=10;
	v[6]=20;
	int n=6,m;
	for(int i=1;i<=6;i++)
	{
		scanf("%d",&w[i]);
		m+=v[i]*w[i];
	}
	
	for(int i=1;i<=6;i++)
	{
		for(int j=m;j>=1;j--)
		{
			for(int k=0;k<=w[i];k++)
			{
				if(j-k*v[i]<0)break;
				f[j]=max(f[j],f[j-k*v[i]]+k*v[i]);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		if(f[i]==i)
		{
			ans++;
		}
	}
	printf("Total=%d\n",ans);
}
```

- 二进制优化的多重背包做法：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int v[10],w[100],f[10005],a[10]; 
int main()
{
	v[1]=1;
	v[2]=2;
	v[3]=3;
	v[4]=5;
	v[5]=10;
	v[6]=20;
	int n=6,m;
	int n1=0;
	for(int i=1;i<=6;i++)
	{
		scanf("%d",&a[i]);
		m+=a[i]*v[i];
		int t=1;
		while(a[i]>=t)
		{
			w[++n1]=v[i]*t;
			a[i]-=t;
			t*=2;
		}
		if(a[i])
		w[++n1]=v[i]*t;
	}
	for(int i=1;i<=n1;i++)
	{
		for(int j=m;j>=w[i];j--)
		{
			f[j]=max(f[j],f[j-w[i]]+w[i]);
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		if(f[i]==i)
		{
			ans++;
		}
	}
	printf("Total=%d\n",ans);
	return 0;
}
```

---

## 作者：COPPERTHIC (赞：1)

楼下大佬的题解看不懂【尴尬

不过这题数据迷之水，所有砝码的质量和不超过1000g，也就是说它并不会有很多砝码

那我们就可以暴力一下，直接水过！【希望不要带坏小朋友，楼下正经的题解还是很棒的……

下面代码（cpp


```cpp
#include <iostream>
using namespace std;
int a[7],b[10000]={0};//b数组用于存储质量和情况，0表示没有被摆出来过，1表示被摆出来过
int main()
{
    int i,j,k,m,n,o;
    int tot=0;
    cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];
    for(i=0;i<=a[1];i++)
        for(j=0;j<=a[2];j++)
            for(k=0;k<=a[3];k++)
                for(m=0;m<=a[4];m++)
                    for(n=0;n<=a[5];n++)
                        for(o=0;o<=a[6];o++)//直接暴力枚举每一种砝码的使用情况
                            if(i+j+k+m+n+o) //总不能一个砝码都不用的，只有和不为0（就是至少用了一个砝码的情况）才进入下面的讨论
                                if(!b[i*1+j*2+k*3+m*5+n*10+o*20])//如果这个和没有被摆出来过
                                {
                                    b[i*1+j*2+k*3+m*5+n*10+o*20]=1;//标记为摆出来过
                                    tot++;//总数加一
                                }
    cout<<"Total="<<tot;//输出，结束！
    return 0;
}
```
最后提一句，并不是每题都可以这样不负责任地水过的，总要先分析数据，然后大概估算一下会不会超时的
以上

---

## 作者：Konnyaku (赞：1)

用回溯暴力过了...

数据强一点就TLE了

a[]记录剩余砝码数量. b[]记录编号对应的砝码重量（如b[1]=1,b[6]=20）

用T标记可以称出来的重量

ans统计T=1（即可以）的数量输出就好了

注意输出要加Total=哦！


回溯剪枝：从上一次选择的砝码重编号向后搜（变量为now，若上次选择编号2 这次只能选择2 3 4 5 6 而不能选择 1   避免重复情况过多）


代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
int a[7],n,T[1010],b[7]={0,1,2,3,5,10,20},ans=0;
void dfs(int now,int weight)
{
    T[weight]=1;
    for(int j=now;j<=6;j++)
    {
        if(a[j]!=0)
        {
            a[j]--;
            dfs(j,weight+b[j]);
            a[j]++;
        }
    }
}
int main()
{
    memset(T,0,sizeof(T));
    for(int i=1;i<=6;i++) cin>>a[i];
    dfs(1,0);
    for(int i=1;i<=1000;i++)
    {
        if(T[i]!=0) ans++; 
    }
    cout<<"Total="<<ans; 
}
```

---

## 作者：户山香澄 (赞：1)

看到除了一个六重循环的貌似没人写P的。。。

所以本弱来一发。。。

（写六重的管理员大大：您真的不怕爆吗。。。）

···
```cpp
const w:array[0..6] of integer=(0,1,2,3,5,10,20);
var b:array[0..1001] of boolean;
    i,j,t,k,s,x,max:longint;
begin
  b[0]:=true;
  for i:=1 to 6 do
    begin
      read(t);
      for j:=max downto 0 do
        if b[j] then
          begin
            for k:=1 to t do
              begin
                x:=w[i]*k+j;
                if not b[x] then
                  begin
                    b[x]:=true;
                    if max<x then max:=x;
                    inc(s);
                  end;
              end;
          end;
    end;
```
···
  writeln('Total=',s);

···
end.
···
其实我的思路和算法和little\_gift几乎一模一样，但是本人手写pascal，请不要怀疑抄袭。


---

## 作者：critnos (赞：0)

可以用一种类似生成法的算法

枚举每个砝码的个数，然后把可能出现的重量存起来，注意要去重。这一点可以用STL容器set解决。注意最后要-1，排除总重为0的情况。

虽然乘了一个$logn$的系数，但是时间还是可以接受的。

事实上可以边读边做（虽然起不到什么优化）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int w[]={1,2,3,5,10,20},l[1005];
set<int> p;
set<int>::iterator it;
int main()
{
	p.insert(0);
	int i,j,k,s,q;
	for(i=0;i<6;i++)
	{
		cin>>q;
		for(j=1;j<=q;j++)
		{
			for(k=0,it=p.begin();it!=p.end();it++,k++)
				l[k]=*it+w[i];
			for(s=p.size(),k=0;k<s;k++)
				p.insert(l[k]);
		}
	}
	cout<<"Total="<<p.size()-1;
} 
```


---

## 作者：Capitalism_Gao (赞：0)

## 01背包
### 二进制拆分砝码数
### f[i][j]表示前i个砝码凑成j的方案数
### 对于第i个砝码
#### if(j<w[i]) f[i][j]=f[i-1][j];//砝码不能放
#### else if(j==w[i]) f[i][j]=f[i-1][j]+1;//单独放刚好  
#### else f[i][j]=f[i-1][j-w[i]]+f[i-1][j];

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=1005;
int num[7]={0,1,2,3,5,10,20},a[7];
int len,w[maxn],sum,f[maxn][maxn];

int main(){
	for(int i=1;i<=6;i++){
	    scanf("%d",&a[i]);
	    sum+=a[i]*num[i]; 
	}    
	for(int i=1;i<=6;i++){
		int now=1;
		while(1){//二进制拆分
			if(now>a[i]) break;
			w[++len]=num[i]*now;
			now*=2;
		}
	}
	f[1][w[1]]=1;
	for(int i=2;i<=len;i++){
		for(int j=1;j<=sum;j++){
			if(j<w[i]) f[i][j]=f[i-1][j];
			else if(j==w[i]) f[i][j]=f[i-1][j]+1;  
			else f[i][j]=f[i-1][j-w[i]]+f[i-1][j];
		}
	}
	int ans=0;bool able;
	for(int k=1;k<=sum;k++){
		able=0;
		for(int i=1;i<=len&&(!able);i++){
			if(f[i][k]) able=1;	
	    }
	    if(able) ++ans;
	}
	printf("Total=%d",ans);
 	
	return 0;
}
```


---

## 作者：Phrooce (赞：0)

我们用dp[m]表示质量为m时是否有砝码可以表示

由此，我们从m到a[i]枚举，若dp[m-a[i]]=1 则dp[m]=1；

初始：dp[0]=1;


一下是代码  我用了读入输出优化 如果不会可以不用

（读入优化后每个点都是0ms 不优化平均2ms)


    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1001;
int a[7]={0,1,2,3,5,10,20};
int w[7],sum=0,ans=0;
string s("Total=");
bool dp[maxn];
struct act
{
    inline void read(int &n)
    {
        int sum=0;
        bool pn=0;
        char c=getchar();
        while(c<'0'||c>'9')
        {
            if(c=='-') pn=1;
            c=getchar();
        }
        while(c<='9'&&c>='0')
        {
            sum=sum*10+c-'0';
            c=getchar();
        }
        n=pn? ~sum+1 : sum;
    }
    inline void put(int x)
    {
        int y=10,len=1;  
        while(y<=x)  {y*=10;len++;}  
        while(len--)
        {
            y/=10;
            putchar(x/y+48);
            x%=y;
        }  
    } 
}p;
void in()
{
    for(int i=1;i<=6;i++)
    {
        p.read(w[i]);
        sum+=w[i]*a[i];
    }
    memset(dp,0,sizeof(dp));
}
void work()
{
    dp[0]=1;
    for(int j=1;j<=6;j++)
    {
        for(int i=1;i<=w[j];i++)
        {
            for(int m=sum;m>=a[j];m--)
            {
                if(dp[m-a[j]]!=0) 
                {
                    dp[m]=1;
                }
            }
        }
    }
}
void out()
{
    for(int i=1;i<=sum;i++)
    {
        if(dp[i]==1) ans++;
    }
    int i=0;
    while(s[i]!='\0')
    {
        putchar(s[i]);
        i++;
    }
    p.put(ans);
}
int main()
{
    in();
    work();
    out();
    return 0;
}
```

---

## 作者：Hydroxyl (赞：0)

提供2种思路 一种是暴力循环（没毛病可以过！） 一种就是正统的dp了

先讲dp

这里的dp就直接这样吧这个背包的容量看做1000 然后直接进行一大堆就好了 反正就是完全背包 详细请参考背包九讲


const v:array[1..6] of longint=(1,2,3,5,10,20);    //定义常量数组是一个好习惯

var f,a:array[0..1000] of longint;  //f反正写dp就这样了 a是记录有多少个的

w:array[0..1000] of boolean;   //最后统计的时候用的




```cpp
    i,j,k,n,total:longint;
function max(a,b:longint):longint;  //写dp就要用的一个东西 
begin
    if a>b then exit(a) else exit(b);
end;
begin
    for i:=1 to 6 do read(a[i]);   //读入
    for i:=1 to 6 do  //按照那个循环
     for j:=1000 downto 1 do  //背包容量downto就ok 也就是当载重量为i的时候最大价值能使多少
      for k:=1 to a[i] do  //有多少个砝码都给他试一试 
       if j>=v[i]*k then   //首先不超重
       begin
         f[j]:=max(f[j-k*v[i]]+k*v[i],f[j]);   //按照dp方程推的啊，就是当前的要比接下来的方案要小的话就可以了
         w[f[j]]:=true;  //就可以了 用boolean的什么排序去重 当然用计数排序也是一样的后面改成>0就好了 这边用boolean节省空间
       end;
    for i:=1 to 1000 do
     if w[i] then inc(total);  //统计输出
    writeln('Total=',total); //记得输出格式要改一下
end.
```
然后讲暴力循环
讲道理按照这题的数据暴力循环绝对没有问题的

那么也不多说了就是每个砝码多少个循环一顿

```cpp
var f:array[1..100000]of longint;
a:array[1..6]of longint;
j,k,i,n,total,l,q,w,p,y,o:longint;
x:boolean;
begin
  for i:=1 to 6 do read(a[i]);
  for i:=0 to a[1] do
  for j:=0 to a[2] do
  for k:=0 to a[3] do
  for l:=0 to a[4] do
  for q:=0 to a[5] do
  for w:=0 to a[6] do
  begin
    p:=i+j*2+k*3+l*5+q*10+w*20;
    x:=false;
    for o:=1 to total do if p=f[O] then x:=true;
    if not x then
    begin
      inc(total);
      f[total]:=p;  
    end;
  end;
  writeln('Total=',total-1);   //记得-1 因为多统计了一次啊
end.
```

---

## 作者：深海鱼的眼泪 (赞：0)

用cz数组保存重量是否已有，wei数组保存已有的重量。枚举k从1到6，将所有已有的重量加上当前砝码的重量，若未出现过则结果数+1.


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int f[10],wei[1010];
bool cz[1010];
int main(){
    int a[10],i,n,w[7]={0,1,2,3,5,10,20},t=0,j,k;
    for (i=1;i<=6;i++){
        scanf("%d",&a[i]);
    }
    cz[0]=1;
    for (k=1;k<=6;k++){       //枚举砝码质量
        int tt=t;  //t为当前已有的种类数
        for (i=0;i<=tt;i++){
            for (j=0;j<=a[k];j++){
                if (!cz[wei[i]+j*w[k]]){
                    cz[wei[i]+j*w[k]]=1;
                    t++;
                    wei[t]=wei[i]+j*w[k];    //保存质量
                }
            }
        }
    }
    printf("Total=%d",t);
    return 0;
}
```

---

## 作者：Memorize (赞：0)

典型的背包问题

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
int a[7],sum=0,ans=0;
int w[7]={0,1,2,3,5,10,20};
bool dp[1010];
int main()
{
    memset(dp,false,sizeof(dp));dp[0]=true;
    for(int i=1;i<=6;i++) scanf("%d",&a[i]),sum+=a[i]*w[i];
    for(int k=1;k<=6;k++)
     for(int j=1;j<=a[k];j++)
      for(int i=sum;i>=w[k];i--)
        if(dp[i-w[k]]) dp[i]=true;//不能写成j*w[k]因为这样会导致物品数量超过 想一想 为什么？ 
    for(int i=1;i<=sum;i++) if(dp[i]) ans++;
    printf("Total=%d",ans);   
    return 0;
}
```

---


# 围栏木桩

## 题目描述

某农场有一个由按编号排列的 $n$ 根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数 $t$ 最大，并求出选取出 $t$ 根木桩的方案总数 $c$。


## 说明/提示

$m \leq 5$，$n \leq 20$，$h_i \leq 150$。

## 样例 #1

### 输入

```
3
9 10 1 9 8 7 6 3 4 6
3 100 70 102
6 40 37 23 89 91 12```

### 输出

```
4 1
2 2
3 3```

# 题解

## 作者：江屿 (赞：76)

这道题真心水，但就是输出卡死一堆人（原来），然后题目输出改了，于是就有人举报我的这篇题解了（生气）。


我不管我就是要再发一遍。


我是用三个数组来实现这道题的。


第一个数组a[i]表示数列的第i个数。


第二个数组b[i]表示第i个数的最长不下降子序列的长度。


第三个数组c[i]表示在这个数i之前都满足长度为b[i]的不同的子序列的个数。


统计完之后累加就好了。




//不过输出坑人。

//不是空格，而是五个单位长度的格子，所以用printf输出，是%5d，但这样是把格子空在左边，还是不行，所以就空去右边，成了%-5d，

//就ac了。

现在是直接输出%d %d\n就好了。


举报我的回来再看看，气死你气死你气死你。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 420000
using namespace std;
int n,m,a[N],b[N],c[N],ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&m);
        memset(a,0,sizeof(a));
        memset(c,0,sizeof(c));
        scanf("%d",&a[1]);
        for(int i=1;i<=m;++i){
            b[i]=1;
            c[i]=1;
        }
        for(int j=2;j<=m;++j){
            scanf("%d",&a[j]);
            for(int k=j-1;k>=1;k--)
                if(a[j]>=a[k]){
                    if(b[j]<b[k]+1){
                        b[j]=b[k]+1;
                        c[j]=c[k];
                    }
                    else
                        if(b[j]==b[k]+1)
                            c[j]++;
                }
        }
        int mmax=-1;
        for(int j=1;j<=m;++j){
            if(b[j]==mmax)
                ans+=c[j];
            else{
                if(b[j]>mmax){
                    ans=c[j];
                    mmax=b[j];
                }
            }
        }
        printf("%d %d\n",mmax,ans);
    }
    return 0;
}
```

---

## 作者：mulberror (赞：20)

### 我也来发一篇~~水~~题解
---
首先，这道题的题目大致意思就是求最长上升子序列和它的方案数。

那么我们都知道如何求最长上升子序列

$$ f_i = max(f_j +1) \ (a[i]>a[j])$$

解释一下$ f_i $表示以第$i$位为结尾的最长上升子序列的长度。

那么这个状态就通过之前最大的符合条件的状态。

边界条件：$ f_i = 1 \ (1 <=\ i\ <= n)$

---
那么我们来讲一下如何转移方案数

定义状态：$ g_i $表示为以i为结尾的最长上升子序列的方案数。

那么这就有两种决策。

* 如果在遍历到$ f[i]<f[j]+1 $时，那么就说明当前的$ f_i $并不是最优解，那么就需要通过$g[j]$来更新$g[i]$，因为以前的$f[i]$都是不优的i，而当前的状态只能通过j来得到，所以方程就是```g[i] = g[j]```
* 如果当前遍历到了$ f[i]=f[j]+1 $时，那么就说明$f[j] $这个状态也可以得到f[i]这个状态，所以就需要累加这个值。方程就是```g[i] += g[j]```

边界条件：$ g_i = 1 \ (1 <=\ i\ <= n)$

这样我们就解好了这道题。

----
以下为AC代码（最近在改码风QAQ）
```cpp
# include <bits/stdc++.h>
# define Ri register int
# define for1(i,a,b) for(Ri i(a);i<=b;++i)
# define for2(i,a,b) for(Ri i(a);i>=b;--i)

using namespace std;

inline int read ()
{
    int w = 0,x = 0;
    char ch = 0;
    while (!isdigit(ch)) { w |= ch =='-'; ch = getchar();}
    while (isdigit(ch)) { x = (x<<1) + (x<<3) + (ch ^ 48); ch = getchar(); }
    return w ? -x : x;
}

int n ;
int f[105] ,g[105] ,a[105] ;

int main()
{
    int cas = read();
    for1(_i ,1 ,cas) 
    {
        n = read();
        for1(i ,1 ,n) a[i] = read() ,f[i] = 1 ,g[i] = 1;
        for1(i ,1 ,n) for1(j ,1 ,i - 1) 
        {
            if ( a[i] < a[j] ) continue;
            int s = f[j] + 1;
            if (s > f[i] )  f[i] = s, g[i] = g[j];
            else if (s == f[i] ) g[i] += g[j];
        }
        int ans1 = 0 ,ans2 = 0;
        for1(i ,1 ,n) if (ans1 < f[i]) ans1 = f[i] ,ans2 = g[i];
        printf("%d %d\n",ans1 ,ans2 );
    }
    return 0;
}
```

---

## 作者：Atmizz (赞：17)

## DP？不存在的，我只会dfs
看到各位大佬的题解，发现竟然没有和我一样的，那我就来发一个新的做法—**DFS**。

### 思路：
看到数据范围，$m≤5,n≤20,h_i≤150$真的水，完全可以深搜。首先挨个枚举每一个位置，然后就可以向后搜索，按照最长不下降子序列的做法来记录个数，当大于当前的最大值时，就更新最大值并更新个数为**0**，然后后面枚举的最大值与当前最大值相等时就记录个数，最后就可以输出了（~~好水，逃。~~

**具体参见代码->**

[开O2AC记录](https://www.luogu.org/recordnew/show/19266439)

[不开O2AC记录](https://www.luogu.org/recordnew/show/19267317)

也就只差那么两毫秒。
### ACのcode：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int n,T,a[21],ans,tot;
void dfs(int ,int );
int main()
{
    scanf("%d",&T);	//操作的个数 
    while(T --) {
        ans = 0 ;	//最大值初始化 
        tot = 0 ;	//最大值的个数 
        scanf("%d",&n);
        for(int i = 1 ; i <= n ; ++ i)
            scanf("%d",&a[i]);
        for(int i = 1 ; i <= n ; ++ i)
            dfs(i,1);	//每一个点都进行一遍深搜 
        printf("%d %d\n",ans,tot);	//换行输出 
    }
    return 0;
}
void dfs(int t,int step)
{
    if(step > ans) {//答案更新，最大值的个数也更新为0 
        tot = 0;
        ans = step;
    }
    if(step == ans)	//与最大值相同，记录个数 
        tot++;
    for(int i = t + 1 ; i <= n ; ++ i)	//看后面的点 
        if(a[i] >= a[t])	//要符合不下降 
            dfs(i,step + 1);
}
```

---

## 作者：Priori_Incantatem (赞：10)

一道最长不降子序列的变形题

用$O(n^2)$求出最长不降子序列应该是很简单了，难点就在于怎样统计出最长不降子序列的数量

设$f[i]$为以第$i$个数结尾的最长不下降子序列的长度，$c[i]$用来储存以第$i$个数结尾，长度为$f[i]$的最长不下降子序列的个数

首先计算出每个$f[i]$，转移方程：$f[i]=max(f[i],f[j]+1)$
 
然后求出每个$c[i]$：对于比$i$小的每一个$j$ `if(f[j]+1==f[i] && a[j]<=a[i])c[i]+=c[j];`

最后，求出所有$f[i]$为最长不降子序列长度的$c[i]$总和

```cpp
#include<cstdio>
#include<cstring>
#define max(x,y) x>y?x:y
const int Maxn=30;
int a[Maxn],f[Maxn],c[Maxn];
int n,ans,cnt;
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	int m=read();
	while(m--)
	{
		n=read();
		for(int i=1;i<=n;++i)
		a[i]=read();
		c[1]=f[1]=1;
		for(int i=2;i<=n;++i)
		{
			f[i]=1;
			for(int j=1;j<i;++j)
			if(a[j]<=a[i])f[i]=max(f[i],f[j]+1);
			ans=max(ans,f[i]);
		}
		for(int i=2;i<=n;++i)
		{
			for(int j=1;j<i;++j)
			if(f[j]+1==f[i] && a[j]<=a[i])c[i]+=c[j];//注意一定要加上a[j]<=a[i]，保证序列合法
			if(c[i]==0)c[i]=1;
		}
		for(int i=1;i<=n;++i)
		{
			if(f[i]==ans)cnt+=c[i];//求和
		}
		printf("%d %d\n",ans,cnt);
		memset(c,0,sizeof(c));
		memset(f,0,sizeof(f));
		memset(a,0,sizeof(a));
		ans=n=cnt=0;
	}
	return 0;
}
```

---

## 作者：苏黎世 (赞：7)

这道题其实很简单，就是求一个最长上升子序列。

不同的是，还要求出最长的个数。

我们用一个s数组存个数，f数组存长度。

代码：
其实长整形不用开，~~只是我在调VSCode的时候用的~~
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long T, n, h[30], ans1, ans2, s[30], f[30];
int main()
{
    scanf("%lld", &T);
    while(T--)
    {
        scanf("%lld", &n);
        for(int i = 1;i <= n; ++i)
        {
            s[i] = 1;
            f[i] = 1;
        }
        ans1 = 0;
        for(int i = 1;i <= n; ++i)
        {
            scanf("%lld", &h[i]);
            
            for(int j = 1;j < i; ++j)
            {
                if(h[j] <= h[i])
                {
                    if(f[i] <= f[j])
                    {
                        f[i] = f[j] + 1;
                        s[i] = s[j];
                    }else
                    if(f[i] == f[j] + 1)
                        s[i] += s[j];
                    
                }
            }
            if(f[i] >= ans1)
            {
                ans1 = f[i];
                ans2 = s[i];
            }
        }
        printf("%lld %lld\n", ans1, ans2);
    }
    return 0;
}
```


---

## 作者：lu_run_ting (赞：6)

**经典01背包**

改动了一点点

c++题解

上代码：
```
#include <iostream>
using namespace std;
int main(){
    int m;
    int a[25],ans[25],n;
    int i,j,k;
    cin>>m;
    for(i=0;i<m;i++){
        cin>>n;
        int ways[25]={0};//方法数
        for(j=0;j<n;j++){
            cin>>a[j];
            ans[j]=1;
            ways[j]=1;//初始值为1
        }
        for(j=0;j<n;j++){
            for(k=0;k<j;k++){
                if(a[k]<=a[j]){//增序
                    if(ans[k]+1>ans[j]){//如果数量比原来大
                        ans[j]=ans[k]+1;
                        ways[j]=ways[k];
                    }
                    else 
                        if(ans[j]==ans[k]+1){
                            ways[j]+=ways[k];//a[j]方法数加上a[k]的方法数
                        }
                }
            }
        }
        int max=0,way;
        for(j=0;j<n;j++){//寻找最长方案
            if(ans[j]>max){
                max=ans[j];
                way=ways[j];
            }
            else if(ans[j]==max){
                way+=ways[j];//方法数累加
            }
        }
        cout<<max<<" "<<way<<endl;//输出
    }
    return 0;
}
```

~~坑了我好久。。。~~


---

## 作者：胡金梁 (赞：5)

## 最长上升子序列？
相信很多像我一样的蒟蒻看过题目后，都发现了这一点。但是题目中有一个很没有意思的东西：要求方案总数。肯定有 DALAO 想出来了十分厉害的代码，但是本人一介粗人，只能想出一个笨方法。在代码中体现了出来这个方法的拙劣。那就是采用类递归的思路：交给下一级来做。这个方法很简单，看看代码你也会理解的：
```cpp
if(f[i]<f[j]+1)
{
	f[i]=f[j]+1;
	sum[i]=sum[j];
}
else
{
	if(f[i]==f[j]+1)
	{
		sum[i]++;
	}
}
```
那么最长上升子序列的代码大家肯定也会写。可以套板子：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int a[10001],n,dp[10001],maxn=INT_MIN;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]; 
		dp[i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(a[j]<a[i])
				dp[i]=max(dp[i],dp[j]+1);
		}
		maxn=max(maxn,dp[i]);
	}
	cout<<maxn;
}
```
最长不下降子序列也同理，那么我们就知道最终的代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[1001],f[100001],sum[10000010];
signed main()
{
    int m;
    cin>>m;
    while(m--)
    {
        int n,maxn=0;
        cin>>n;
        memset(sum,0,sizeof(sum));
        for(int i=1;i<=n;i++)
        {
            cin>>s[i];
            f[i]=1;
            sum[i]=1;
        }
        for(int i=2;i<=n;i++)
        {
            for(int j=i-1;j>=1;j--)
            {
                if(s[i]>=s[j])
                {
                    if(f[i]<f[j]+1)
                    {
                        f[i]=f[j]+1;
                        sum[i]=sum[j];
                    }
                    else
                    {
                        if(f[i]==f[j]+1)
                        {
                            sum[i]++;
                        }
                    }
                }
            }
        }
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            if(f[i]==maxn)
            {
                ans+=sum[i];
            }
            else if(f[i]>maxn)
            {
                maxn=f[i];
                ans=sum[i];
            }
        }
        cout<<maxn<<" "<<ans<<endl;
    }
}
```
再见！

---

## 作者：Qing_s (赞：5)

## P2362 【围栏木桩】

虽然标签写的是dp，但是：
> __~~搜就完事了！~~__

分析题目：
>某农场有一个由按编号排列的n根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数t最大，并求出选取出t根木桩的方案总数c。

其实完全可以简化成：
>给你n个数，求最长上升序列，并找出有多少种方式可以达到最长上升序列。

这样就简明易懂了。看完输入输出发现没什么坑点。再来看看数据：
>$m≤5,n≤20,h{_i}≤150$

~~好家伙，这不写dfs都对不起这个数据。~~

那我们该如何实现这个dfs呢？

仔细分析，我们只需要找出最长上升序列的长度和达到的方式数。

所以我们的函数完全只需要两个值：
- 当前我们搜到了第几个数。
- 当前上升序列的长度。
```cpp
void qing_s( int noww , int sum )
//忽略我的函数名，noww是当前搜到的数，sum是当前长度。
```
那我们在函数内应该怎么实现查找上升序列呢？

很显然，因为我们最后要找出的序列顺序是源自于输入的顺序，所以我们只需要挨个遍历就可以了。

```cpp
for( int i = noww + 1 ; i <= n ; i++ )
		if( num[i] >= num[noww] )
			qing_s( i , sum + 1 ) ;
```
注意： 我们要求的序列是后面的数 __不小于__ 前面的数。所以要用 ≥ ，~~我一次就是卡在这里了。~~

那我们函数的结束条件是什么呢？

根据我们需找出的东西（最长上升序列的长度和达到方式数），我们就可以很简单的知道结束条件，分为两种情况：
1. 当当前序列长度优于已知最长序列长度，更新，并把达到方式数变为一（只发现当前一种）。
1. 当当前序列长度等于已知最长序列长度，不更新，达到方式数加一。

那我们就可以写出代码，如下：
```cpp
if( sum == ans )//如果等于。
		fs++ ;//方式数+1。
	if( sum > ans ){//不等于。
		ans = sum ;
		fs = 1 ;//更新长度，方式数变为1。
	}
```

再稍微处理一下输入输出：
```cpp
cin >> m ;
	while( m-- ){
		cin >> n ;
		for( int i = 1 ; i <= n ; i++ )
			cin >> num[i] ;
		for( int i = 1 ; i <= n ; i++ )
			qing_s( i , 1 ) ;//从第一个数开始遍历。
		cout << ans << " " << fs << endl ;//换行输出。
		ans = fs = 0 ;//注意重置ans和fs的值。
	}
```

就可以很顺利的AC了！

#### 结语：
其实很多dp的题目都可以使用记忆化搜索骗分（废话，在考场中我们不一定是要打出正解，只需要让我们的分数和到达我们所能到达的最大值。

就好比你在考场中推了一个状态转移方程但是你不能证明它的正确性，此时应该在暴力算法和你所打出的代码中正确取舍。

---

## 作者：ModestCoder_ (赞：4)

贡献一篇pascal题解~~~

这只是一道最长不下降子序列的改版

不要想复杂了

只需两个数组

一个为数列

还有一个二维的

f[i][j]表示以第i个结尾，长度为j的最长不下降子序列个数

一边读入，一边直接累加~~~

累加好后，再打个擂台，找出最长长度，并统计

因为数据范围实在太水了，剪枝什么的，就免了吧！！

注意！！！：升序是前一个<=后一个，本蒟蒻一开始手残wa掉了一个~~~




```cpp
uses math;
var
    a:array[0..10000] of longint;
    f:array[0..1000,0..1000] of longint;
    i,j,k,n,m,s,l,p:longint;
begin
    readln(p);
    for l:=1 to p do
        begin
            read(n);
            fillchar(f,sizeof(f),0);
            for i:=1 to n do
                begin
                    read(a[i]);
                    f[i][1]:=1;   //初始
                    for j:=1 to i-1 do
                        if a[i]>=a[j] then
                            for k:=1 to n do   //枚举长度
                                if f[j][k]=0 then  //若没有长度k的，也就没有长度k+1,k+2,k+3……的了
                                    break else
                                    inc(f[i][k+1],f[j][k]);  //累加
                end;
            m:=0;
            for i:=1 to n do  //找最大
                for j:=1 to n do
                    if f[i][j]<>0 then
                        m:=max(m,j);
            s:=0;
            for i:=1 to n do  //统计
                inc(s,f[i][m]);
            writeln(m,' ',s);
        end;
end.

```

---

## 作者：珅肐 (赞：3)

### 动规
设f[i]为以i结尾的最长上升序列长度

f[i]可以由之前的状态得到

所以二重循环枚举  、 f[i]=max( f[j] )+1

之后统计答案个数
#### 代码：
```cpp
#include<iostream>
#include<ctype.h>
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read(){//快读..
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return f?-x:x;
}
int a[27],f[27],cnt[27];//a储存围栏长度，cnt储存答案个数
int main(){
	int T=read();//输入次数
	while(T--){
		int n=read(),maxn=0,ans=0;
		for(int i=1;i<=n;++i)a[i]=read(),f[i]=cnt[i]=0;//读入并清空数组
		for(int i=1;i<=n;++i){
			for(int j=1;j<i;++j){
				if(a[j]<=a[i])f[i]=max(f[i],f[j]+1);//取max
				maxn=max(maxn,f[i]);//顺便求一下最大值
			}
			if(!f[i])f[i]=cnt[i]=1;
            //f[i]=0说明它是当前最大的，赋初值为1
		}
		cout<<maxn<<" ";//输出最大值
		for(int i=1;i<=n;++i){
			for(int j=1;j<i;++j){
				if(f[i]==f[j]+1 && a[i]>=a[j])
                //如果它能由上一个状态状态转移而来,即上升序列长度比上一个大1、且围栏长度比上一个大
					cnt[i]+=cnt[j];//累加个数
			}
			if(f[i]==maxn)ans+=cnt[i];//如果当前值是最大值、统计答案
		}
		cout<<ans<<"\n";//输出
	}
	
	return 0;//好习惯
}

```

---

## 作者：Acc_Robin (赞：2)

题目要求的就是最长不下降自序列和最长不下降自序列的个数.

最长不下降自序列我们$O(n^2)$求就行辣.

对于个数，我们要在转移的同时记一下.

事实上，我们会发现可以转移的元素和它们的关系构成了一张DAG（有向无环图），那么我们要求的事实上是这个DAG的最长链以及最长链个数.

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 25;
int a[N],dp[N],n,T,f[N];
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&a[i]),dp[i]=1,f[i]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<i;j++){
                if(a[j]<=a[i]){
                    if(dp[i]<dp[j]+1) dp[i]=dp[j]+1,f[i]=f[j];
                    else if(dp[i]==dp[j]+1) f[i]+=f[j];
                }
            }
        }
        int ans1=0,ans2=0;
        for(int i=1;i<=n;i++)ans1=max(ans1,dp[i]);
        for(int i=1;i<=n;i++)ans2+=(ans1==dp[i])*f[i];
        cout<<ans1<<' '<<ans2<<endl;
    }
}
```

---


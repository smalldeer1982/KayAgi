# 越越的组队

## 题目描述

班级要组织一场综合能力竞赛，班里共有 $n$ 位学生，将分成两队互相竞争。

老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出**一半**，并要求这些同学综合能力测试的成绩之和在**不超过班级总分一半**的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。

## 说明/提示

#### 样例 1 解释

班级总分为 $550$，总分的一半是 $275$，选则成绩分别为 $56,77,84,56$ 的同学可以达到总分 $273$，是不超过 $275$ 的最大值。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 100$，$0 \leq a_i \leq 100$，数据保证 $n$ 均为偶数。

## 样例 #1

### 输入

```
8
77
77
56
77
84
77
56
46```

### 输出

```
273```

# 题解

## 作者：Kalium (赞：139)

# P2663 越越的组队题解

## 前言：

这很有可能是我最后一篇博文，当然，不是最后一篇也是倒数几篇了，祝我 whk 安好吧。

## 题意：

在 n 个人中选出一半，要求选出人的分数和不超过全班分数和的一半下的最大分数。

## 思路：

这一看就很背包。

但是，看见这讨厌的一半，我们很难控制一半这玩意。

但作为一道普及-，还是很容易想出将 $dp[i][j]$ 表示为前 i 个人是否得到 j 分。

那么转移方程便显得简单，就是模板，只不过需要多来一层控制人数的循环罢了：

$dp[j][k] |= dp[j - 1][k - a[i]]$。

最后来遍历一遍分数，判断 $dp[n >> 1][i]$ 可不可行即可。

## 代码：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n;

int a[107];

int dp[107][10007];

int sum;

inline int maxa(int a, int b) {
	if (a > b)
		return a;
	return b;
}

int main() {
	scanf("%d", &n);
	
	for (int i = 1; i <= n; i ++) {
		scanf("%d", &a[i]);
		
		sum += a[i];
	}
	
	dp[0][0] = 1; 
	
	for (int i = 1; i <= n; i ++) {
		for (int j = i; j >= 1; j --) {
			for (int k = sum >> 1; k >= a[i]; k --)
				dp[j][k] |= dp[j - 1][k - a[i]];
		}
	}
	
	for (int i = sum >> 1; i >= 0; i --) {
		if (dp[n >> 1][i]) {
			printf("%d\n", i);
			return 0;
		}
	} 
}
```

## 结语：

麻烦管理员，请允许我废话几句，我怕以后就没博客发上来了。

其实学 OI 到现在，我也不明白为什么在 1 年前已经被淘汰时还要再坚持，或许只是内心的执着，亦或是内心的不甘，然而在新的一年 csp 的前一个月，我终究还是在纠结着要不要参加，学 OI 或许要抵抗许许多多的障碍，家长就是一个难过的关，可能由于家长，我没法去今年的 csp，但我还是祝愿学 OI 的那些巨佬们说：

$Wish$ $you$ $never$ $grow$ $old$.

算是勉励自己吧。

---

## 作者：yhk1001 (赞：29)

$\texttt{Upd on 2021/8/5 : 修改 \LaTeX，规范文章}$

如果你这题评测时只有50分，那你可以在这篇题解找到错因。

这题是01背包裸题。定义布尔型数组 $dp_{i,j}$ 表示前 $i$ 个人能否凑出 $j$ 分，$\text{true}$ 表示能，$\text{false}$ 表示不能。状态转移方程为 $dp_{i,j} \gets dp_{i,j} \  \text{or} \ dp_{i-1,j-score_i}$，再压成一维数组，得到 $dp_j \gets \ dp_j \ \text{or} \ dp_{j-score_i}$。可惜这样写出的代码并不能拿到满分。（错误代码附在最后，感兴趣的可以看看。）

我们再读一遍题，发现有句话被遗漏了。
 > 要求他从全班同学中选出 **一半**

在刚才的程序中，我们不能保证人数一定为总人数的一半，所以要升维记录状态。定义布尔型数组 $dp_{i,j,k}$ 表示前 $i$ 个人选 $j$ 个能否凑出 $k$ 分，得到方程 $dp_{i,j,k} \gets dp_{i-1,j,k} \ \text{or} \  dp_{i-1,j-1,k-score_i}$ ，压维得到 $dp_{j,k}\gets dp_{j-1,k-score_i}$，这就是最终的方程了。

[AC](https://www.luogu.com.cn/record/34802219)代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int a[105];//分数
bool dp[105][10005];

int main()
{
	int n;
	cin >> n;
	int sum = 0;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
		sum += a[i];//总人数
	}
	dp[0][0] = true;
	for (int i = 1;i <= n;i++)
	{
		for (int j = i;j >= 1;j--)
		{
			for (int k = sum;k >= a[i];k--)
			{
				dp[j][k] |= dp[j - 1][k - a[i]];
			}
		}
	}
	sum /= 2;
	n /= 2;
	for (int i = sum;i >= 0;i--)
	{
		if (dp[n][i])
		{
			cout << i << endl;
			break;
		}
	}
    return 0;
}
```
[WA](https://www.luogu.com.cn/record/34802012)代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int a[105];//分数
bool dp[10005];

int main()
{
	int n;
	cin >> n;
	int sum = 0;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
		sum += a[i];
	}
	dp[0] = true;
	for (int i = 1;i <= n;i++)
	{
		for (int j = sum;j >= a[i];j--)
		{
			dp[j] |= dp[j - a[i]];
		}
	}
	sum /= 2;
	for (int i = sum;i >= 0;i--)
	{
		if (dp[i])
		{
			cout << i << endl;
			break;
		}
	}
    return 0;
}
```

---

## 作者：天南星魔芋 (赞：20)

~~竟然没有大佬用模拟退火，我来水一发。~~


------------

[不会模拟退火的可以看这里 ](https://blog.csdn.net/lyxleft/article/details/82982567)，  ~~当然你也可以继续往下看。~~

我们看题：

* 从 $N$ 个数中选 $N/2$ 个数，使选出的数之和与剩下的数之和的差最小。

那么我们可以将数分成两组，每次从两部分中各选出一个数交换，对其进行退火即可。

算法详解：（会的可以直接跳过）

模拟退火的思想是模拟高温物体降温的过程，有三个状态组成：

* $best$ 最优解，输出时输出。
* $ans$ 上次解，是上次运算产生的解。
* $now$ 当前解，这次退火产生的解。

在一般思维中，只有 $now$ 比 $ans$ 更优时才更新 $ans$ ，

但模拟退火不同， $now$ 比 $ans$ 劣时有几率用 $now$ 更新 $ans$ ，

并且 温度越高

你可以理解为 

* 再退火中，高温物体内能过大时分子运动过于剧烈，使分子势能增加（即不是最小/最优），

* 在程序中有几率跳出局部最优。（如下图）

如果没有几率跳出，容易陷入局部最优。

![](https://cdn.luogu.com.cn/upload/image_hosting/q9u7b6x1.png)

但如果有几率跳出，则可能达到最优解。(蓝色是新增，橙色是跳出局部最优的步鄹)

![](https://cdn.luogu.com.cn/upload/image_hosting/vyz1gjup.png)


不过这样有一个缺陷，$ans$ 不一定是最优解，故用 $best$ 记录最优解。

代码更详细：

* 定义 $best$ ， $now$ ， $ans$ 。

```cpp
int best,bx,by;
int now,nx,ny;
int ans,ax,ay;
```

* 函数 退火


```cpp
#define db long double
int a[120];
int n;
int xx,yy;
int abss(int x){//绝对值 
	return x>0? x:-x;
}
int js(){//---------------------------------------------------------------------------//
	nx=ax-a[xx]+a[yy];//nx 表示 1~n/2 之和											 //
	ny=ay-a[yy]+a[xx];//ny 表示 n/2+1~n 之和										//
	swap(a[xx],a[yy]);//交换    												   //
	return abss(nx-ny);															  //
} 													   							 //
void SA(){     																	//
//我的学号不用在意-//     退到一个很小温度。     每次退一点。 				   //
	for(db wd=20230071;wd>0.00000000000001;wd*=0.998){						  //
    																		 //
		xx=rand()%(n/2)+1;													//
		yy=rand()%(n-n/2)+(n/2)+1;										   //
		//从 1~n/2 和 n/2+1~n 中 各选一个交换。 						  //
																		 //
		now=js();// 计算本次结果 同时交换。 ----------------------------//
		
		if(now<ans){//若 now 比 ans 更优 更新 。 
			ans=now;
			ax=nx;
			ay=ny;
			
			if(now<best){//若 now 比 best 更优 更新。   
				best=now;// best 一定不会比 ans 差 ，故如果 now 不比 ans 优 ， now 必不比 ans 优  。 
				bx=nx;
				by=ny;
			}
			
		}
		// 有几率接受。 
		else if(exp((db)(ans-now)*wd)*RAND_MAX>rand()){
		//exp(一个负数) 会产生一个 0~1 之间的数（不包括  0，1） 。
			ans=now;
			ax=nx;
			ay=ny;
		}
		//如果 以上都不接受 就换回来 （ 我们在 js() 中 不是 先换了吗？ 
		else{
			swap(a[xx],a[yy]);
		}
	}
}
```

* 将以上代码拼入主函数中：



```cpp
#include<bits/stdc++.h>
#define db long double
using namespace std;

//---------------------------//反手给他一个读入优化 
inline int read(){
	int x=0;
	char f=getchar();
	while(!isdigit(f))f=getchar();
	while(isdigit(f))x=x*10+f-'0',f=getchar();
	return x;
}
//然鹅并没有什么卵用 

int n;
int a[120];

int best,bx,by;
int now,nx,ny;
int ans,ax,ay;

int xx,yy;

int abss(int x){//绝对值 
	return x>0? x:-x;
}
int js(){//---------------------------------------------------------------------------//
	nx=ax-a[xx]+a[yy];//nx 表示 1~n/2 之和											 //
	ny=ay-a[yy]+a[xx];//ny 表示 n/2+1~n 之和										//
	swap(a[xx],a[yy]);//交换    												   //
	return abss(nx-ny);															  //
} 													   							 //
void SA(){     																	//
//我的学号不用在意-//     退到一个很小温度。     每次退一点。 				   //
	for(db wd=20230071;wd>0.00000000000001;wd*=0.998){						  //
    																		 //
		xx=rand()%(n/2)+1;													//
		yy=rand()%(n-n/2)+(n/2)+1;										   //
		//从 1~n/2 和 n/2+1~n 中 各选一个交换。 						  //
																		 //
		now=js();// 计算本次结果 同时交换。 ----------------------------//
		
		if(now<ans){//若 now 比 ans 更优 更新 。 
			ans=now;
			ax=nx;
			ay=ny;
			
			if(now<best){//若 now 比 best 更优 更新。   
				best=now;// best 一定不会比 ans 差 ，故如果 now 不比 ans 优 ， now 必不比 ans 优  。 
				bx=nx;
				by=ny;
			}
			
		}
		// 有几率接受。 
		else if(exp((db)(ans-now)*wd)*RAND_MAX>rand()){
		//exp(一个负数) 会产生一个 0~1 之间的数（不包括  0，1） 。
			ans=now;
			ax=nx;
			ay=ny;
		}
		//如果 以上都不接受 就换回来 （ 我们在 js() 中 不是 换了吗？ 
		else{
			swap(a[xx],a[yy]);
		}
	}
}
int main(){
	srand(2023);//先srand()一下 
	
	n=read();//读入 
	for(int i=1;i<=n;i++){
		a[i]=read();
		
		if(i<=n/2)bx+=a[i];//1~n/2 放 bx 中 
		else by+=a[i];//   n/2+1~n 放 by 中 
		
	}
	
	//-------------------//初始化 
	best=abss(bx-by);
	ans=best;
	now=best;
	nx=ax=bx;
	ny=ay=by;
	//--------------------// 
	
	SA();SA();SA();//连退三次 
	
	bx=bx>by? by:bx;//选出最小的，输出 
	printf("%d\n",bx);
	
	return 0; 
}
```


最后放一张经典退火图：


![](https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif)








---

## 作者：critnos (赞：17)

~~无脑做法~~

暴力地记忆化，而且直接模拟题意，然后竟然过了……

题目要求选$n \div 2$个数，那就先敲一个暴力dfs出来

```cpp
int dfs(int s,int r,int w)//竟然拿了50分……
{
	if(r*2==n) return s;
	if(w==n) return 0;
	int mx=0;
	if((s+a[w])*2<=sum) mx=dfs(s+a[w],r+1,w+1);
	if(n-w-1+r>=n/2) mx=max(mx,dfs(s,r,w+1));
	return mx;
}
```
既然暴力dfs已经敲出来了，那记忆化搜索也不难了

改装十分简单，先估算dfs中每个参数的大小，然后开相应大小的数组即可。[详细介绍看这里。](https://www.luogu.com.cn/blog/2-6-5-3-5/solution-p1833)但此题有三个参数，所以要注意空间优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105];
int j[5005][55][105];//记忆化数组，如果开j[10005][105][105]会爆空间
int n,sum;
int dfs(int s,int r,int w)//分数和，已选的人数，判断第几个人
{
	if(r*2==n) return s;
	//这里貌似少了什么……
	if(j[s][r][w]!=-1) return j[s][r][w];//明显的记忆化板子
	int mx=0;
	if((s+a[w])*2<=sum) mx=dfs(s+a[w],r+1,w+1);
	if(n-w-1+r>=n/2) mx=max(mx,dfs(s,r,w+1));//神奇优化，如果不选这个数后面的数加上已选的人数还够一半
	return j[s][r][w]=mx;
}//这个记忆化是经过优化的，比朴素的记忆化快了一倍
int main()
{
	memset(j,-1,sizeof(j));
	cin>>n;
	for(int i=0;i<n;i++) 
	{
		cin>>a[i];
		sum+=a[i];
	}
	cout<<dfs(0,0,0);
}
```


---

## 作者：ExcaIibur (赞：17)

### （背包做法挂了，容易丢失状态被hack。）

这题题意很清楚，要求选择一半的人，使其总分尽可能接近总成绩的一半。

刚开始以为是二维背包，把人数看成一维，但是并不可行，因为这同样代表的是**容量**，我们并**不能保证正好装一半人**。

接着我们发现问题的实质实际就是在限制人数的情况下进行成绩的组合，可以考虑**状态可达性**。

设数组 **d[i][j][k]** 表示前i名同学中能否选择出j名同学使成绩达到k，有状态转移方程 **d[i][j][k] = d[i-1][j][k] || d[i-1][j-1][k-a[i]]**。

由于我们只关注j和k，可以倒叙降维 **d[j][k] = d[j][k] || d[j-1][k-a[i]]**。

显然，初始状态 **d[0][0]=1**。

结果遍历一遍求出最大可达价值就行了。

代码如下：
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int n,a[105],d[51][5005],sum;
int main(){
	scanf("%d",&n);
	for(re int i=1;i<=n;++i)
		scanf("%d",a+i),sum+=a[i];
	int ave=sum/2,m=n/2;//平均成绩，总人数一半
	d[0][0]=1;
	for(re int i=1;i<=n;++i)
		for(re int j=min(i,m);j>=1;--j)//j最大为m
			for(re int k=ave;k>=a[i];--k)
			d[j][k]=d[j][k]||d[j-1][k-a[i]];
	for(re int i=ave;i;--i)
		if(d[m][i]){
			printf("%d",i);
			exit(0);
		}
}
```

---

## 作者：WanderingTrader (赞：16)

我看到这题的时候，第一个想法自然是背包。  
分析一下，由于这里的“物品”是学生，一个学生只能用一次，所以这里是01背包。大体的思路也就有了。  
所以我们需要维护两个量：所选学生成绩之和，所选学生数量。  
我们令布尔值$dp_{i,j}$表示使用$i$个学生能否取到$j$这个成绩和，易得转移方程：  
$dp_{i,j}=\begin{cases}1,dp_{i-1,j-a_k} = 1\\dp_{i,j},dp_{i-1,j-a_k} = 0\end{cases}$，此处$k$表示学生的编号，$a_k$为该学生的成绩，可在循环中枚举。  
将上面的方程转换为代码即为： 
```cpp
	int n,goal = 0;
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
	{
		scanf("%d",a+i);
		goal += a[i];
	}
	goal /= 2;	
	int x = n / 2;//确定检索范围
	for(int i = 1;i <= n;i ++)
	{
		for(int j = i;j >= 1;j --)
		{
			for(int k = goal;k >= a[i];k --)
				dp[j][k] |= dp[j - 1][k - a[i]];
		}
	}
 ```
 注意由于此题是01背包，$i$的循环要放最外面，且$j,k$的循环均要倒着排，这也是01背包最容易出错的地方 ~~(本人已经犯了这个错误好几次了)~~。  
最后找答案也很简单了，遍历$dp_{x,i}(x = [\frac{n}{2}],1\le i\le [\frac{\sum\limits_{i=1}^na_i}{2}])$，找到最大值即可  
求答案代码：  
```cpp
	for(int i = goal;i >= 0;i --)
		if(dp[x][i]) 
		{
			printf("%d\n",i);
			return 0;
		}
```
最终代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 105
int a[N];
bool dp[N][N*N] = {{1}};
int main(){
	int n,goal = 0;
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
	{
		scanf("%d",a+i);
		goal += a[i];
	}
	goal /= 2;
	int x = n / 2;
	for(int i = 1;i <= n;i ++)
	{
		for(int j = i;j >= 1;j --)
		{
			for(int k = goal;k >= a[i];k --)
				dp[j][k] |= dp[j - 1][k - a[i]];
		}
	}
	for(int i = goal;i >= 0;i --)
		if(dp[x][i]) 
		{
			printf("%d\n",i);
			return 0;
		}
	return 0;
}
```
最后我们可以检验一下时空复杂度，确保通过：  
$T(n)\approx n^2\times\sum\limits_{i=1}^{n}{a_i}$，不会超过$10^8$，当然真实的最大时间要比这小得多$($测评结果：所有数据点时间总和为$65ms$$)$。  
$S(n)\approx n^3\times 1+n\times 4$，$n$最大时约为$2MB$，比最大限度小得多，$OK$。  
于是这份代码就通过了。

---

## 作者：chlchl (赞：11)

## 题目分析：

这是一题变形01背包问题，它比普通的01背包多了一个限制：**规定了物品数量（人数的一半）**，用int有点难写（~~或者说写不出来~~），所以考虑用bool数组进行dp

## 思路：

令 $f[i][j][k]$表示前i个人中能否选出j个人，他们成绩总和为k

**状态转移方程：**$f[i][j][k] = f[i - 1][j][k] || f[i - 1][j - 1][k - a[i]];$

不过，我们应该都学过压维大法，可以把i这一维去掉.

## 压维：
状态：令 $f[j][k]$表示能否选出j个学生，他们的成绩总和为k

**状态转移方程**：$f[j][k] |= f[j - 1][k - a[i]];$

“十万个为什么”时间：能不能压成一维？\
答案是不行。如果把j省掉，那么**不能保证背包里的物品件数**；如果把k省掉，那么**就没法判断成绩总和的要求**。因此，大家就不要试图压成一维啦！

**现在，相信大家的代码已经打出来啦！以下是参考代码。**

_AC Code：_
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100 + 10;
int n, m, a[N]; //n和a[i]如题目所示，m为背包容量
bool f[N][10010];

int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i];
		m += a[i];
	}
	m /= 2, f[0][0] = 1;  //边界及条件处理
	int x = n / 2;  //人数处理
	for(int i=1;i<=n;i++)	for(int j=i;j>=1;j--)	for(int k=m;k>=a[i];k--)	f[j][k] |= f[j - 1][k - a[i]];
        //01背包记得倒着搜
	for(int i=m;i>=1;i--){
		if(f[x][i]){ //寻找最大可行的成绩和
			cout << i << endl;
			return 0;
		}
	}
	cout << f[m] << endl;
	return 0;
}
```
本蒟蒻第一次写题解，如有任何错误请及时评论指出

好了，本篇题解就到这里了，希望对您有用，记得点赞哦~
### 拜拜！

---

## 作者：cyhyyds (赞：4)

### 题意：
给定 $v$ 数组，设其总和为 $g$ 。取 $\frac{2}{n}$ 个不同的数，使和为 $s$，且 $s\le \frac{2}{g}$，$s$ 最大化。

### 思路：
因为一个数只能取一次，我们会考虑 $01$ 背包的思路。

如果直接套 $01$ 背包模板的话，不能通过题目。

为什么呢？

题目要求**正好取** $\frac{2}{n}$ 名学生。

于是我们只要在 $01$ 背包模板的基础上增加一个维度，记录人数。

也就是说，我们设布尔数组 $dp_{i,j}$ 为选 $i$ 名学生，能否取到 $j$ 分。

根据 $01$ 背包模板，易得转移方程：

$dp_{i,j}=dp_{i,j}$ $or$ $dp_{i - 1, j - v[i]}$。

### 代码：
```
#include <iostream>

using namespace std;

const int N = 105;

bool dp[N][N * 100];

int a[N], n, limit = 0;

int main() {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++) {
		scanf ("%d", &a[i]);
		
		limit += a[i];
	}
	
	limit /= 2;
    //别忘了除以二！
	
	//cout << limit << endl;
	
	dp[0][0] = true; 
    //0个人可以获得0分。
    
    //套01背包模板。

	for (int i = 1; i <= n; i ++) {
		for (int j = i; j >= 1; j --) {
			for (int k  = limit; k >= a[i]; k --) {
				dp[j][k] = dp[j][k] || dp[j - 1][k - a[i]];
			}
		}
	}
	
	for (int i = limit; i >= 0; i --) {
    	//枚举可以获得的分数。
		if (dp[n / 2][i]) {
			printf ("%d", i);
			
			return 0;
		}
	}
} 
```




---

## 作者：Mysterious_Cat (赞：3)

其实就是布尔背包模板题
  
**定义状态：**$dp_{i,j,k}$为前$i$个人中选$j$个能否凑出价值$k$  
**转移方程：**$dp_{i,j,k}=dp_{i-1,j-1,k-a_i}||dp_{i,j,k}$  
**初始化：**$dp_{0,0,0}=true,dp_{i,j,k}(i\neq0,j\neq0,k\neq0)=false$  
**边界：**$i\in[1,n],j\in[1,i],k\in[a_i,\sum_{i=1}^na_i]$ 

然后压维反向枚举就写完了  
**注意下这句话：** 要求他**从全班同学中选出一半**，并要求这些**同学综合能力测试的成绩之和在不超过班级总分一半**的前提下尽量达到最高。

### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read()
{
    int x = 0;
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
    return x;
}

int a[105];
bool dp[105][10005];

int main()
{
    int n = read(), tot = 0;
    for(int i = 1; i <= n; i++)
        a[i] = read(), tot += a[i];
    dp[0][0] = true;
    for(int i = 1; i <= n; i++)
        for(int j = i; j >= 1; j--)
            for(int k = tot; k >= a[i]; k--)
                dp[j][k] |= dp[j - 1][k - a[i]];
    for(int i = tot / 2; i >= 0; i--)
        if(dp[n / 2][i])
        {
            printf("%d", i);
            return 0;
        }
    
    return 0;
}
```


---

## 作者：BotDand (赞：2)

# Problems
班级要组织一场综合能力竞赛，班里共有 $n$ 位学生，将分成两队互相竞争。

老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出**一半**，并要求这些同学综合能力测试的成绩之和在**不超过班级总分一半**的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。
# Answer
设$f_{i,j,k}$表示从前$i$个人中选出$j$个人能否凑成$k$分。

那么转移方程就有：$f_{i-1,j,k}||f_{i-1,j-1,k}$。

将$i$压维得$f_{j,k}=f_{j,k}||f_{j-1,k-a_i}$，其中$a_{i}$就是题目中的$a_{i}$。

* 初始值：$f_{0,0}=true$。

于是可得代码：
```pascal
  for i:=1 to n do s:=s+a[i];//求和
  m:=n;s:=s div 2;n:=n div 2;//注意取一半
  f[0,0]:=true;//f数组初始值
  for i:=1 to m do//m就是最初n的替身
    for j:=i downto 1 do//从i个人中选出j个人
      for k:=s downto a[i] do//分数最多不多于一半
        f[j,k]:=f[j,k] or f[j-1,k-a[i]];//转移方程
```
最后输出最大值即可。
# Code
```pascal
var
  n,s,i,j,k,m:longint;
  a:array[0..101] of longint;
  f:array[0..101,0..10001] of boolean;//注意f数组的范围
  //因为是总分的一半，所以要定义100×100÷2，保险一点定义100×100
begin
  readln(n);//读入n
  for i:=1 to n do readln(a[i]);//读入a数组
  for i:=1 to n do s:=s+a[i];//求和
  m:=n;s:=s div 2;n:=n div 2;//注意取一半
  f[0,0]:=true;//f数组初始值
  for i:=1 to m do//m就是最初n的替身
    for j:=i downto 1 do//从i个人中选出j个人
      for k:=s downto a[i] do//分数最多不多于一半
        f[j,k]:=f[j,k] or f[j-1,k-a[i]];//转移方程
  for i:=s downto 0 do if f[n,i] then begin writeln(i);exit;end;//找最大值
end.
```

---

## 作者：zilingheimei (赞：1)

蒟蒻来写题解了

先看题目

[P2663 越越的组队](https://www.luogu.com.cn/problem/P2663)



------------

这题一个01背包就可以解决

状态转移方程：

```cpp
f[i+1][j+a[k]]=1;
```
f（i，j）用来表示当人数为 i 时，分数为 j 的情况可不可以达成。

思路如下：


1. 当人数为 i 的时候，如果分数为 j 的情况是可以达到的，且 i+1 不大于一半的学生人数时，那么人数为 i+1，分数为 j+这个学生的分数 就是也可以达到的。


```cpp
if(f[i][j]==1&&i+1<=n/2){
	f[i+1][j+a[k]]=1;
}
```

2. 从所有学生的总分的一半枚举，找到当人数为总学生人数一半的时候的分数最大值。

```cpp
for(int i=m/2;i>=0;i--){
	if(f[n/2][i]==1){
		ans=i;
		break;
	}
}
```


------------


主要代码与思路上面都有了，代码就不放了

---


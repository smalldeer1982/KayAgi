# 又上锁妖塔

## 题目描述

小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。

锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，但是每次跳跃后小 A 都将用完力气，必须爬过至少一层才能再次跳跃（你可以认为小 A 需要跳两次一层才休息）。

现在小 A 想让你帮他算出爬上塔顶的最短时间。

## 样例 #1

### 输入

```
5
3 5 1 8 4```

### 输出

```
1```

# 题解

## 作者：Clu3ter (赞：145)

[![](https://ae01.alicdn.com/kf/HTB14d0waoH1gK0jSZSy760tlpXa5.png)](https://www.luogu.org/problemnew/show/P2800)


------------

这道题是一道**DP**题。

描述状态$f[i]$表示到达第$i$层**之上**所用的最短时间。

初始状态即为塔底，根本不需要时间。
那么 _**边界条件**_ 就很明显了：
$$f[0]=0$$

接着，题目要求的是到达塔外的时间，而塔有$n$层，所以最终要求的**解**的就是
$$f[n+1]$$

然后我们自己搞一组数据：

###  INPUT：

```
6
5 2 4 5 3 2
```
### OUTPUT:
```
5
```
我们把这组数据画下来：

![](https://ae01.alicdn.com/kf/HTB1xkFuaeT2gK0jSZFv760nFXXaJ.png)
塔底$f[0]=0$，解是$f[7]$

不难看出，这组数据的走法是：
$$0\Rightarrow 1 \stackrel{2}\rightarrow 2 \Rightarrow 4 \stackrel{3}\rightarrow 5 \Rightarrow 7$$
($\rightarrow$表示爬，$\Rightarrow$表示仙术瞬移)

接下来我们来推导


------------


### 状态转移方程

根据题意，到达第$i$楼有三种方法：

>1. **徒步爬楼（花费与下层层高相等的时间 $a[i-1]$）**
>2. **仙术瞬移1层（不花费时间 $0$）**
>3. **仙术瞬移2层（不花费时间 $0$）**

也有限制条件：

>**仙术瞬移无法连续使用**

那么也就是说，**仙术瞬移之后必须爬楼**，~~爬楼是世间万物の归宿，是不可避の物，是死亡の灯塔，是宇宙の终结~~，则**爬楼到达**第$i$楼的三种方法有所变化：

>1. **从$i-1$楼徒步爬楼.**
>
>	（ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-1]+a[i-1] $ ）
>
>2. **从$i-2$楼仙术先瞬移1层到$i-1$楼，再徒步爬楼.**
>
>	（ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-2]+a[i-1] $ ）
>
>3. **从$i-3$楼仙术先瞬移2层到$i-1$楼，再徒步爬楼.**
>	
>   （ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-3]+a[i-1] $ ）
    

如下图

![](https://ae01.alicdn.com/kf/HTB1NnpyakL0gK0jSZFA763A9pXaS.png)

这样的话，就不需要考虑仙术不能连续使用的问题了，

所以，到达第$i$层所需要的最短时间$f[i]$，就是三种方法所需要总时间中的最小值，于是我们成功推导出了状态转移方程：


------------


$$ f[i]=min\{f[i-1],f[i-2],f[i-3]\}+a[i] $$


------------

下面奉上蒟蒻的辣鸡代码，还请垂阅敝码，多多赐教

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[1000005];
int f[1000005];

int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		f[i]=1e9;//注意初始化
	}
	f[n+1]=1e9;
	
	for(int i=1; i<=n+1; i++) {//循环到n+1
		f[i]=min(f[i],f[i-1]);
		f[i]=min(f[i],f[i-2]);
		f[i]=min(f[i],f[i-3]);
		f[i]+=a[i];
	}
	
	cout<<f[n+1];//输出解
	return 0;//愉快的结束
}
```

文明查题解，拒绝复制粘贴

------------

『做正确，好懂，好看的题解』

---

## 作者：Godのfather (赞：45)

### 这道题我的思路跟前面发题解的DALAO有些不一样......希望对大家有些帮助
-----

题目意思我就不讲了，相信各位DALAO都懂，下面进入正文：

这道题是一道经典的dp，难点在于怎样列状态转移方程。

首先，我们要将原问题   ~~（爬到第N层的最小时间）~~  分解成若干个子问题。

我在分解子问题的时候遇到了一点点小困难。题目限制不能连续飞跃，因此怎样定义状态是解题的关键

我们定义f[i]表示到达第i层的时候爬上去的最大值

因此我们很容易地找到它的子问题：

1.爬上第i层，$f[i]=f[i-1]+a[i]$

2.飞跃上第i层，$f[i]=min(f[i-2]+a[i],f[i-3]+a[i])$

注意边界问题：

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int f[maxn];
int a[maxn];
int n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	   cin>>a[i];
    for(int i=1;i<=n+1;i++)
    //因为题目说超过n层也算n层，所以我们需要算到n+1层 
    {
    	f[i]=f[i-1]+a[i];
    	if(i-2>=0) f[i]=min(f[i],f[i-2]+a[i]);//注意边界 
    	if(i-3>=0) f[i]=min(f[i],f[i-3]+a[i]);//注意边界*2 
    }
	cout<<f[n+1]<<endl;
	return 0;
}
```

---

## 作者：Last_Reincarnation (赞：24)

第二次发题解   ~~~~第一次惨遭管理拒绝~~~~

看啦看没和我解法一样的！！！

一道$dp$的裸题

$n$塔高，$a[i]$塔距，$f[i][j]$更新答案；

****可以考虑两种状态****

1.飞上来的时候
```c
f[j][0]=min(f[j-1][1],f[j-2][1]);

```
2.爬上来
```c
f[j][1]=min(f[j-1][0],f[j-1][1])+a[j];

```
然后最后更新一下$f[n][0]$和$f[n][1]$的值
完美$AC$

代码如下 ~~~~玛风较丑~~~~

$code$
```c
#include <iostream>
#include <cstdio>
using namespace std;

int n, f[1001000][2], a[1001000];//1是可用法术，0不可用

int main(){
	scanf("%d",&n);
	for (int i = 1;i <= n; ++i) scanf("%d",&a[i]);
	for (int j = 1;j <= n; ++j){
		f[j][0] = min(f[j-1][1], f[j-2][1]);//用了法术上来 
		f[j][1] = min(f[j-1][0], f[j-1][1])+a[j];//没用法术上来 
	}
	f[n][0] = min(f[n][0], f[n][1]);
	printf("%d",f[n][0]);
	return 0;
}

```
最后祝大家$AK$ ~~noip~~ $CSP$


---

## 作者：xukuan (赞：22)

dp自不必说，关键是怎么dp。

到达一层楼有两种方法：

1.爬（c[i-1]+a[i]）

2.飞（c[i-2]+a[i-1]和c[i-3]+a[i-2]）

状态转移方程就有了。


```pascal
uses math;

var
 i,n:longint;
 a,c:array[0..1000010] of longint;
// a表示爬到每一层楼所要的时间，c表示到每一层楼所要的最短时间
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=1 to n do
  c[i]:=min(c[i-1]+a[i]{爬上来},min(c[i-2]+a[i-1]{跨一层飞上来},c[i-3]+a[i-2]{跨两层飞上来}));//取其中最小值
 writeln(c[n]);
end.
```

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,a[1000010],c[1000010];
// a表示爬到每一层楼所要的时间，c表示到每一层楼所要的最短时间
int main()
{
    cin>>n;
    for(int i=1; i<=n; i++) cin>>a[i];
    for(int i=1; i<=n; i++)
     c[i]=min(c[i-1]+a[i]/*爬上来*/,min(c[i-2]+a[i-1]/*跨一层飞上来*/,c[i-3]+a[i-2]/*跨两层飞上来}*/));//取其中最小值
    cout<<c[n]<<endl;
    return 0;
}
```

---

## 作者：亡魂•夺命 (赞：4)

```cpp
var i,n:longint;
a:array[0..1000000]of longint;  //a[i]表示每一层的高度
f:array[0..1000000,1..2]of longint;  //f[i,1]和f[i,2]表示到i层两种方法所需的最小时间
function min(x,y:longint):longint;  
begin
  if x>y then exit(y) else exit(x);
end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);  //输入每一层的高度
  f[1,1]:=a[1];f[2,1]:=a[2];   //设定初始值，f[1,1]表示爬到第一层最小时间，f[2,1]表示爬到第二层最小时间（第一次用仙术）
  //用仙术，1,2两层的最小值一定为0，这里省略了
  for i:=3 to n do  //从第三层推起
  begin
    f[i,1]:=min(f[i-1,1],f[i-1,2])+a[i];  //爬到第i层需要的最小时间（在上一层用仙术所需的时间和不用仙术所需的时间中选个小的）
    f[i,2]:=min(f[i-1,1],f[i-2,1]);   //飞到第i层需要的最小时间（在上一层用不用仙术所需的时间和上两层不用仙术所需的时间中选个小的）
  end;
  write(min(f[n,1],f[n,2]));  //判断那个更小，输出那个
end.
```

---

## 作者：flyfree (赞：3)

我的思路很简单，到第i层有三种方法：

1、从i-1层爬上去。

2、从i-1层飞上去。

3、从i-2层飞上去。

既然有三种方法，那就建立三个数组，a[i]表示从第i-1层爬上去的最短时间，b[i]表示从i-1层飞上去的最短时间，c[i]表示从i-2层飞上去的最短时间。

f[i]存储爬上第i层所需时间。

转移方程：

a[i]=min(a[i-1],b[i-1],c[i-1])+f[i];

b[i]=a[i-1];

c[i]=a[i-2];

因为不能连续飞，所以b数组和c数组只能从a数组转移。

奉上代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[1000002],b[1000002],c[1000002],f[1000002];
int main()
{
     scanf("%d",&n);
     for(int i=1;i<=n;i++)
     scanf("%d",&f[i]);
     a[1]=f[1];//初始化
     int xx;
     for(int i=2;i<=n;i++)
     {
     	xx=min(a[i-1],b[i-1]);//由于min函数只能传入两个参数，所以借助xx完成。
     	a[i]=min(xx,c[i-1])+f[i];
     	b[i]=a[i-1];
     	c[i]=a[i-2];
     }
     xx=min(a[n],b[n]);//依旧是借助xx比较三个数
     xx=min(xx,c[n]);
     printf("%d",xx);
     return 0;
}
```
这样就可以AC了。

可我看着这程序~~非常不顺眼~~，申请数组那么一大堆0，太浪费内存~~暴殄天物~~了！

再看看程序，貌似在循环中只用到了a[i-1]、a[i-2]、a[i]、b[i-1]、b[i]、c[i-1]、c[i]啊，那只开a[3]、b[2]、c[2]然后滚动更新不就行啦！！

至于f数组嘛……只用到了f[i]，边读入边处理不就行了嘛。

emmm……第二版代码奉上

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,a[3],b[2],c[2],xx,yy;
int main()
{
     scanf("%d",&n);
     scanf("%d",&xx);
     a[1]=xx;
     for(int i=2;i<=n;i++)
     {
     	scanf("%d",&xx);
     	yy=min(a[1],b[0]);
     	a[2]=min(yy,c[0])+xx;
     	b[1]=a[1];
     	c[1]=a[0];
     	a[0]=a[1];//以下为滚动更新
     	a[1]=a[2];
     	b[0]=b[1];
     	c[0]=c[1];
     }
     xx=min(a[1],b[1]);
     xx=min(xx,c[1]);
     printf("%d",xx);
     return 0;
}
```


---

## 作者：雒仁韬 (赞：3)

这道题纯粹是在玩文字游戏......
设f[i]为爬上第i层所需的最小总时间,a[i]为爬第i层需要的时间

1.我们为了方便讨论，假设第i层一定要爬而不用“灵力”，这样有效的避免了思考何时爬何时跳的情况，到时候只要设置一个虚拟的顶层高度为0即可符合题意

2.对于每一个f[i],我们可以有以下三种选择
 
 (1)从i-3层跳过i-1层再爬第i层(用灵力跳两层)
 
 (2)从i-2层跳过i-1层再爬第i层(用灵力跳一层)
 
 (3)从i-1层爬到第i层再爬第i层(不用灵力)

3.所以状态转移方程就是
```cpp
f[i]=a[i]+min(f[i-3],f[i-2],f[i-1])
```
是不是绝对坑人？
代码如下
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n;
int a[1000005];

int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);	
	}
	for(int i=4;i<=n+1;++i)
	{
		a[i]+=min(min(a[i-1],a[i-2]),a[i-3]);
	}
	cout<<a[n+1]<<endl;
	return 0;	
}
```

---

## 作者：lxyMustGotACMGold (赞：3)

# DP啊啊啊！！！
其实很简单，就是一道dp
### 有两种转移方式
##### 1.仙术 从楼下直接飞上来。。。
##### 2.徒步 爬上来。。。
其实仙术也可分为两种
1.从-1层飞来，
2.从-2层飞来
徒步也有两种转移
从仙术后面接徒步
从徒步后面接徒步
>直接从i-1层转移就好了，没有必要再和自身比较

这是我N次WA后一神犇的提示
其实很简单但是，有个坑：输入是**倒序**的。。。。
# code:
```c++
var
    n,i:longint;
    a:array[-1..20000]of longint;
    f:array[-1..20000,0..1]of longint;
    function min(a,b:longint):longint;
    begin
        if a<b then exit(a)
        else exit(b);
    end;
begin
    read(n);
    for i:=1 to n do read(a[i]);
    fillchar(f,sizeof(f),$7F);
    f[0,0]:=0;
    f[0,1]:=0;
    for i:=1 to n do
    begin
        f[i,0]:=min(f[i-2,1],f[i-1,1]));
        //f[i,0]可以由f[i-2,1]使用仙术过来,也可以由f[i,0]跳过来，也可以从f[i-1,1]跳过来；
        f[i,1]:=min(f[i-1,0]+a[i],f[i-1,1]+a[i]);
    end;
    writeln(min(f[n,0],f[n,1]));
end.
//f[i,0]表示当爬到第i层时最后一步使用仙术
//f[i,1]表示当爬到第i层时最后一步不使用仙术
```






---

## 作者：1jia1 (赞：3)

其实很简单，不过我一开始做复杂了……后面改了一下就好了。


核心思路：第i层时判断三种情况，从i-1层爬上来，从i-1层跳上来，从i-2层跳上来，然后加一下就好了。


```cpp
-#include <iostream>-
-using namespace std;-
-int n,a[1000001],f[1000001][3];---a[i]存塔的高度，f[i][j]表示爬到i层时用的方法，j=0,1,2分别代表爬上来、跳一层、跳两层
-int main()-
-{-
-    cin>>n;-
-    for(int i=1;i<=n;i++)cin>>a[i];-
-    for(int i=1;i<=n;i++)for(int j=0;j<=2;j++)f[i][j]=1926081764;---设成很大值（+∞）
-    for(int i=1;i<=n;i++)---DP
-    {-
-        for(int j=0;j<=2;j++)f[i][0]=min(f[i][0],f[i-1][j]+a[i]);---爬上来
-        if(f[i][1]>f[i-1][0])f[i][1]=f[i-1][0];---跳一格上来
-        if(f[i][2]>f[i-2][0])f[i][2]=f[i-2][0];---跳两格上来
-    }-
-    int s=19260817;---寻找最小值
-    for(int i=0;i<=2;i++)s=min(f[n][i],s);-
-    cout<<s;-
-    return 0;-
-}-
```

---

## 作者：Garrison (赞：3)

## 前言
这道题是我见过的~~最水的dp~~最难的dp（因为我太弱了）

另外这道题浪费了我三次提交机会（一次忘记关文件）所以发个题解祭奠一下
## 正文
我们如何求状态呢？状态转移方程是什么？
如题所说([题面传送门](https://www.luogu.org/problem/P2800))
小A可以用仙术跳过一层或者两层（其实这道题可以更难一点）那么我们就可以知道当前的塔层的最小时间花费就等于
```
f[i]=min(f[i-1]+a[i],f[i-2]+a[i],f[i-3]+a[i]);
化简得：f[i]=min(f[i-1],f[i-2],f[i-3])+a[i];
//当i>=3是
```
那么当i=2时我们可以知道需要花费的时间就是
```
f[i]=min(f[i-1],f[i-2])+a[i];
```
当i为1时
```
f[i]=a[i];
```
又因为跳过塔也算，所以我们还可以多算一层（有可能最后一层好高）所以我们要将i从3循环到n+1即
```
f[1]=a[1],f[2]=min(f[1],f[0])+a[2];
	for(int i=3;i<=n+1;++i)
		f[i]=min(f[i-1],min(f[i-2],f[i-3]))+a[i];
```
最后输出f[n+1]就好了
## 总结
这道题的状态转移方程想出来了后就可以秒掉了，但是因为本蒟蒻实在太弱，所以才……

## CODE
```
#include<bits/stdc++.h>
using namespace std;
#define N 1000005
int a[N],f[N],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	f[1]=a[1],f[2]=min(f[1],f[0])+a[2];
	for(int i=3;i<=n+1;++i)
		f[i]=min(f[i-1],min(f[i-2],f[i-3]))+a[i];
	printf("%d\n",f[n+1]);
	return 0;
}
```



---

## 作者：超级范范 (赞：2)

DP
到达第i层分为三种情况：

1.    从i-2层跳上来的f[i-3]+h[i-2]

2.    从i-1层跳上来的f[i-2]+h[i-1]

3.    从i-1层爬上来的f[i-1]+h[i]

三种情况取最小值





```cpp
#include <cstdio>
const int N=1000005; 
int n,h[N],f[N];
inline int min(int a,int b){
    return a<b ? a:b;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
       scanf("%d",&h[i]);
    f[1]=f[2]=0;
    for(int i=3;i<=n;i++)
       f[i]=min(f[i-3]+h[i-2],min(f[i-2]+h[i-1],f[i-1]+h[i]));
    printf("%d",f[n]);
    return 0;
}

```

---

## 作者：a___ (赞：1)

典型dp  
三种状态：当前层爬过[0]；当前层第一次飞[1]；当前层第二次飞[2]（飞两次相当于上层飞一次后这层再飞一次）
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,dp[1000001][3],h[1000001];
int main()
{
	cin>>n;
	int i,j;
	for(i=1;i<=n;i++)cin>>h[i];//输入高度（时间）
	memset(dp,0x7f,sizeof dp);//附大值，为了取最小
	dp[1][0]=h[1];//爬第一层状态
    dp[1][1]=0;//飞第一层状态（第一层时只能飞一次，因为没有上层，所以dp[1][2]=∞）
	for(i=2;i<=n;i++)//从第二层开始
	{
		dp[i][0]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+h[i];//爬：取最小值，再加上本层时间
		dp[i][1]=dp[i-1][0];//第一次飞：即上层爬，本层不爬
		dp[i][2]=dp[i-1][1];//第二次飞：即上层飞，本层也飞（不爬）
	}
	cout<<min(dp[n][0],min(dp[n][1],dp[n][2]))<<endl;
	return 0;
}
```

---

## 作者：Goder (赞：1)

## 典型dp

同时记录更新两个状态

dp[i] :第i层是飞上去的

df[i] :第i层是走上去的

### 状态转移方程：

```
dp[i]:=min(df[i-1],df[i-2]);
df[i]:=min(dp[i-1]+a[i],df[i-1]+a[i]);
```

---

```pascal
program Tower;
var a,dp,df:array[0..10000] of longint;
      n,i:longint;
function min(x,y:longint):longint;
begin
    if x<y then exit(x)
        else exit(y);
end;
begin
    readln(n);
    for i:=1 to n do
        read(a[i]);
    df[1]:=a[1];
    for i:=2 to n do
        begin
            dp[i]:=min(df[i-1],df[i-2]);
            df[i]:=min(dp[i-1]+a[i],df[i-1]+a[i]);
        end;
    writeln(min(dp[n],df[n]));
end.
```


~~Pascal要退出舞台了（还有几年吧）好伤心~~

---

## 作者：clever_POP (赞：0)

# 二话不说上代码
```
//对20%的数据,n<=10
//对40%的数据,n<=100
//对60%的数据,n<=5000
//对100%的数据,n<=10000
//(倒…) 锁妖塔的建造很特别,塔总共有n层,
//但是高度却不相同,这造成了小A爬过每层的时间也不同.
//小A会用仙术,每用一次可以让他向上跳一层或两层,
//但是每次跳跃后小A都将用完灵力,
//必须爬过至少一层才能再次跳跃
//所以请你帮他找到一个时间最短的方案让他爬到塔顶,
//你可以最后跳到塔外即超过塔高.
#include<bits/stdc++.h>//万能头文件 
using namespace std;
const int MAXX=10000001;//定义 
int time1[MAXX];//到达第n层所用时间
int a[MAXX];//每层所用时间
int n;//塔数量 
int main() {//主函数部分 
//	cin>>n;
    scanf("%d",&n);//输入n
	for(int i=1; i<=n; i++)//循环输入 
//		cin>>a[i];
        scanf("%d",&a[i]);//输入 每层所用时
	for(int i=1; i<=n+1; i++)//一层一层找最小方案 
		// 因为题目说超过n层也算n层，所以算到n+1层
	{
		time1[i]=time1[i-1]+a[i];
		//现阶段所用时为 现层用时+之前时间
		if(i-2>=0) time1[i]=min(time1[i],time1[i-2]+a[i]);
        if(i-3>=0) time1[i]=min(time1[i],time1[i-3]+a[i]);
		//因为小A会用仙术,每用一次可以让他向上跳一层或两层,
		//tim1[i-2]+a[i-1]表示 飞1层
		//tim1[i-3]+a[i-2]表示 飞2层
		//只需 求个最小值  即为最省时方案 
	}
	printf("%d\n",time1[n+1]);//输出n+1层所用最小时间
	//若未超过第n层，memset(time1,0,sizeof(time1));
	//因为time1[n+1]=time1[n]+a[n]=time1[n]
	//所以输出time1[n+1]
	return 0;
}
```
# 注释有点多慢慢看
### 再发个简练版O(∩_∩)O~
```
#include <bits/stdc++.h>
using namespace std;
const int MAX=1000005;
int t[MAX];
int a[MAX];
int n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n+1;i++){
		t[i]=t[i-1]+a[i];
		if(i-2>=0)  t[i]=min(t[i],t[i-2]+a[i]);
		if(i-3>=0)  t[i]=min(t[i],t[i-3]+a[i]);
	}
	cout << t[n+1];
	return 0;
}
```
## O(∩_∩)O~


---

## 作者：千反田 (赞：0)

这道题的瓶颈显然是怎么判断飞跃的处理

很显然，对于每一次飞跃，之后必定伴随着爬一层

那么，我们可不可以把一次飞跃和爬一层归并成一个状态呢？

#### 事实证明，可以！



------------
我们设 $f[i]$ 为爬上第i层时所需的最小步数

考虑状态转移

很显然，$f[i]=min(f[i-1],f[i-2],f[i-3])+t[i];$

考虑边界处理

由于可以超出塔外

所以答案就是$f[n]=min(f[n],f[n-1],f[n-2]);$

## 祭上代码

```cpp
#include<bits/stdc++.h>
#define N 1000005
int f[N],t[N],n;
inline int read(){//快读
    int x=0;
    char ch=getchar();
    while(!isdigit(ch))
     ch=getchar();
    while(isdigit(ch))
     x=(x<<3)+(x<<1)+(ch^48),
      ch=getchar();
    return x;
}
inline int min(int a,int b,int c){return std::min(std::min(a,b),c);}//方便调用
int main(){
	n=read();
	for(register int i=1;i<=n;++i)
	 t[i]=read();
	f[0]=0;
	f[1]=t[1];
	f[2]=t[2];//初始化
	for(register int i=3;i<=n;++i)
	 f[i]=min(f[i-1],f[i-2],f[i-3])+t[i];//状态转移方程
	printf("%d\n",min(f[n],f[n-1],f[n-2]));
}

```


---

## 作者：东京食种 (赞：0)

其实最开始做这道题把本蒟蒻难到了，本蒟蒻一直困惑于如何判断当前楼层是否能飞，其实想明白以后发现是一个非常基础的DP。

------------

main idea：把当前楼层分两种情况讨论，(飞上来和爬上来）f[i][0]存储每层的高度，f[i][1]存储当前i楼层是爬上来的最短时间，f[i][2]存储当前i楼层是飞上来的最短时间。


所以得到状态转移方程:

**f[i][1]=min(f[i-1][1],f[i-1][2])+f[i][0]**

**f[i][2]=min(f[i-1][1],f[i-2][1])**

最后的answer就是min(f[n][1],f[n][2])




------------

AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000005][3];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>f[i][0];
	}
	f[1][1]=f[1][0];//初始化
	for(int i=1;i<=n;i++)
	{
		f[i][1]=min(f[i-1][1],f[i-1][2])+f[i][0];
		f[i][2]=min(f[i-1][1],f[i-2][1]);
	}
	cout<<min(f[n][1],f[n][2])<<endl;
	return 0;
}
```



                   


---

## 作者：zdx1031705564 (赞：0)

很迷茫为什么楼下大佬都是1维；看的我是一脸懵逼

这里了解一波2维操作

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=1000005;
int f[inf][2];//f[i][0]是已经使用过跳跃，f[i][1]是没使用过跳跃
int h[inf];//每层高度
int main()
{	int n,i;
	cin>>n;
	for(i=1;i<=n;i++)
		f[i][0]=inf;
	for(i=1;i<=n;i++)
		cin>>h[i];
	f[1][1]=h[1];//老老实实爬上第一层
	f[1][0]=0;//飞上第一层
	for(i=2;i<=n;i++)
	{	f[i][1]=min(f[i-1][1],f[i-1][0])+h[i];//f[i][1]留着跳跃，等于上次没有跳跃或者跳跃了的最小值加上老老实实爬上来的距离
		f[i][0]=min(f[i-1][1],f[i-2][1]);}//这次要跳了，看看是挑一层好，还是跳两层好
	cout<<min(f[n][1],f[n][0])<<endl;//输出最后一次跳了或者没跳的最小值
	return 0;//和谐了
}
```

---


# [COCI 2009/2010 #2] KUTEVI

## 题目背景

本题为[$\texttt{COCI 2009-2010}\ 2^\texttt{nd}\ \texttt{round}\ \text{T3 KUTEVI}$](https://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)。

分值按原题设置，满分 $70$。

## 题目描述

给定 $N$ 个角（第 $i$ 个角记作 $a_i$），作为初始角，另给定 $M$ 个角（第 $i$ 个角记作 $b_i$），作为目标角。

请求出对于每个 $b_i$，它是否能被若干个 $a_i$ 之间的加、减运算得到。

注意同一个 $a_i$ 可以用多次，也可以不用。

## 说明/提示

### 样例解释

样例 $1$ 解释：

$70^\circ-30^\circ=40^\circ$。

样例 $2$ 解释：

$15\times100^\circ=1500^\circ=60^\circ$。

### 数据范围与约定

$1\leq N,M\leq10$，$0<a_i,b_i< 360$。

## 样例 #1

### 输入

```
2 1
30 70
40```

### 输出

```
YES```

## 样例 #2

### 输入

```
1 1
100
60```

### 输出

```
YES```

## 样例 #3

### 输入

```
3 2
10 20 30
5 70```

### 输出

```
NO
YES```

# 题解

## 作者：pengzy___ (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P7774)

有 m 个数，这 m 个数能否由另外 n 个数通过加减运算获得。对于每一次加减的操作，结果不能小于 0 ，对于大于等于 360 的结果，对 360 取模。

此题可以用搜索和动态规划做，这里是完全背包的做法。注意在做的过程中要 mod 360 。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[15],b[15],f[1005];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=m;i++)cin>>b[i];
    f[0]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=1000;j++)
        {
            if(j>=a[i])
            f[j%360]|=f[(j-a[i])%360];
            f[j%360]|=f[(j+a[i])%360];
        }
    for(int i=1;i<=m;i++)
    {
        if(f[b[i]]==1)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
    return 0;
}
```

---

## 作者：asasas (赞：8)

题意：给定 $ n $ 个初始角，再给定 $ m $ 个目标角，每个初始角之间可以任意进行加，减运算，每个初始角都可以用无数次，判断是否可以通过某种方式得到目标角。

我们将题目转换一：你和另一个人都有 $ n $ 种物品，每种物品有无数个。你可以将这些物品卖出，也可以买进。判断可否通过某种交易方式，使你得到 $ m $块钱。

现在就很明确了：这题实际上是**完全背包**中的**可行性**问题。

但注意：这是角，而不是物品。而角的最大值只有 $ 360 $ ，所以在进行DP时，如果枚举得到的值 $ > 3 6 0 $ ，就要将其  $\mod 360$。

同时，内层枚举角时不能仅仅只枚举到 $ 360 $。因为 $ n \leq 10 $ ,同时每个角的度数又 $ \leq 360 $ ，理论上应该枚举到 $ 10 \times 360 $ ，即 $ 3600 $ ，但这题数据比较水，实际上开到 $ 1000 $ 左右即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define r register
bool dp[361];
int a[15];
int main(){
    int n,m;
    cin >> n >> m;
    for (register int i=1;i<=n;i++){
    	cin >> a[i];
    }
    dp[0]=1;//初始化，0肯定能得到
    for (register int i=1;i<=n;i++){
    	for (register int j=a[i];j<=1005;j++){//完全背包，j从a[i]开始顺序枚举，以免出现负数，导致RE。
    		dp[j%360]=max(dp[j%360],dp[(j-a[i])%360]);//这里可以用或来判断，也可以max，看个人的喜好
    		dp[j%360]=max(dp[j%360],dp[(j+a[i])%360]);
    	}//注意：先减后加，不然连样例都过不了
    }
    for (register int i=1;i<=m;i++){
    	int qwq;
    	cin >> qwq;
    	if (dp[qwq]==1) cout << "YES\n";
    	else cout << "NO\n";
    }
    return 0;
}

```


---

## 作者：Flokirie (赞：7)

~~为什么要dp呢。~~

只用gcd就能解决的问题

> 定理：给定整数 $x_1, x_2,...,x_n$ ，当 $a_1,a_2,...,a_n$ 取遍 $\mathbb{Z}^n$ 时， $(\sum_{i=1}^na_ix_i)\ \text{mod}\ y$ 取遍所有 $[0,y)$ 中 $gcd(x_i)$ 的倍数

因此能用 $a_i$ 表示的所有角都是 $gcd(a_i)$ 的倍数 $\text{mod}\ 360\degree$ ，换言之，能表示的角的集合为 $\{0,gcd(a_i),2gcd(a_i),...,359gcd(a_i)\}$ 。

附C#程序：
```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace P7774
{
    class Program
    {
        static int Gcd(int x, int y)
        {
            int r = x % y;
            while (y != 0)
            {
                r = x % y;
                x = y;
                y = r;
            }
            return x;
        }
        static void Main(string[] args)
        {
            int[] a, b;
            string[] input = Console.ReadLine().Split();
            int n = Convert.ToInt32(input[0]), m = Convert.ToInt32(input[1]);
            a = new int[n];
            b = new int[m];
            input = Console.ReadLine().Split();
            for (int i = 0; i < n; i++)
            {
                a[i] = Convert.ToInt32(input[i]);
            }
            input = Console.ReadLine().Split();
            for (int i = 0; i < m; i++)
            {
                b[i] = Convert.ToInt32(input[i]);
            }
            int gcd = a[0];
            for (int i = 1; i < n; i++)
            {
                gcd = Gcd(a[i], gcd);
            }
            bool[] res = new bool[360];
            for (int i = 0; i < 360; i++)
            {
                res[(gcd * i) % 360] = true;
            }
            for (int i = 0; i < m; i++)
            {
                if (res[b[i]])
                {
                    Console.WriteLine("YES");
                }
                else
                {
                    Console.WriteLine("NO");
                }
            }
        }
    }
}

```


---

## 作者：ForeverCC (赞：6)

这道题可以转成完全背包，$dp_i$ 表示角度 $i$ 能否取到。

如果 $dp_{i-a[j]}$ 或 $dp_{i+a[j]}$ 能取到，$dp_i$ 就能取到。

因为角的最大值为 $360$，所以 $dp$ 数组的下表要 $\bmod 360$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[15],b[15],dp[1005];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    	scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
    	scanf("%d",&b[i]);
    dp[0]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=1000;j++){//这里要开到很大，不然会错
            if(j>=a[i])dp[j%360]|=dp[(j-a[i])%360];
            dp[j%360]|=dp[(j+a[i])%360];
        }
    for(int i=1;i<=m;i++){
        if(dp[b[i]]==1)puts("YES");
        else puts("NO");
    }
    return 0;
}
```


---

## 作者：LiuHao2019 (赞：5)

这道题目，其实没有它的标签这么难，根本用不着 dp 、 HASH 等算法。因为它的数据范围很小，所以其实只要一个 DFS 就可以水过了。

但是有很多人止步于样例二的解释：

>$ 15 × 100 ^{\circ} = 1500 ^{\circ} = 60 ^{\circ} $

其实，这里并不是题目出了问题，而是因为我们忽略了一个很重要的信息： **这里的运算是角度运算，因此 $360^{\circ}$ 就等于 $0^{\circ}$ 。**

所以，我们只要把所有通过初始角能运算出来的角度都存起来，询问目标角时直接调用就可以了。具体看代码：

```
#include<stdio.h>
int n,m;
int a[15]; //初始角
int b;
bool x[10000]; //是否可运算出的角度
void dfs(int now){
	if(x[now]) return; //如果这个角度已经运算过了，就直接跳过：可以防止死循环和提高程序效率
	x[now] = true; //表示这个角度已经运算过了
	x[now%360] = true;//可以运算出的角度
	for(int i = 1;i <= n;i ++){ //尝试进行运算
		int tmp = now+a[i];
		if(tmp > 10000) return;
		dfs(tmp);
		tmp = now-a[i];
		if(tmp < 0) return;
		dfs(tmp);
	}
}
ovo//防作弊
int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	dfs(0);
	while(m --){ //逐个输出
		scanf("%d",&b);
		if(x[b]) printf("???\n");//防作弊
		else printf("???\n");//防作弊
	}
}
ovo//防作弊
```

---

## 作者：zymooll (赞：2)

我们学校考试题。。。

### 题目描述
一个区间为 $[0,359]$ 的数组，询问用 $n$ 个区间为 $[0,359]$ 的数相互加减，能否组合出 $m$ 个区间为 $[0,359]$ 的数。

### 实现方式
看到数据范围，大胆采用高级算法——暴力。

设一个数组 $bj$，当$ bj_{i}=1 $，则认为可以组合出，反之，则认为不能组合出。初始 $bj_{0}=1$ ，时当输入一个数 $a_{i}$，将其的 $a_{i},a_{i}\times2,a_{i}\times3$ 直到 $a_{i}\cdot n \bmod 360 = 0$，将其全部放入数组 $p$，长度为 $lenp$，随后将已知的可以组合出的数加上这些数（枚举 $i$ 从 $0$ 到 $359$，如果 $bj_{i}=1$ 则将 $bj_{(i+p[0..lenp]) \bmod 360}$ 设为 $1$（即标记为可以组合出）。

### 可行性证明
假设有 $[3,4,5]$ 可以被组合。按上列逻辑会将 $3\times1,3\times2,3\times3...$ 直到 $3\times119$（为什么是 $\times119$，看上面）与 $0$ 相乘加入 $bj$。因为只有 $0$ 目前可用（$bj_{0}=1$），所以会把 $bj_{3\times1},bj_{3\times2},bj_{3\times3}...bj_{3\times119}$ 设为 $1$。之后会 $4\times1,4\times2,4\times3...$ 直到 $4\times89$ 与上一次加入 $bj$ 数组的数相乘加入 $bj$ 数组。可以发现其就是枚举了每一个 $3\times n + 4\times n$ 加入 $bj$ 数组。之后加入 $5$ 也是如此。可以证明该逻辑会将所有可能解计算出来。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,js,ls;
int a[370];
vector<int>q;
signed main(){
	ios::sync_with_stdio(0);
	a[0]=1;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>ls;
		q.clear();
		js=ls;
		while(ls%360){
			q.push_back(js);
			js+=ls;
		}
		for(int i=0;i<360;i++){
			if(a[i]){
				for(int j:q){
					a[(i+j)%360]=1;
				}
			}
		}
	}
	for(int j=1;j<=m;j++){
		cin>>ls;
		cout<<(a[ls]?"YES":"NO")<<endl;
	}
	return 0;
} 
```

### 备注
```for(int j:q)``` 是 ```C++11``` 新加入的语法。意思就是枚举 $q$ 数组中的每个值赋值给 $j$。

### 后记
数据太水了

同机房只考虑两个数相加减的也过了。。。

而且这暴力也能拿最优解。。。

---

## 作者：Violet___Evergarden (赞：1)

先吐槽一下，我代码居然因为大括号换行被打回来。

# P7774 题解

## 思路：
由于 $n$ 和 $m$ 的范围都很小，所以第一时间想到了搜索。又因为深搜有时候会炸，所以用宽搜做。
## 实现：
建立一个队列 $q$ 和一个 bool 数组 $v$，$q$ 用来存储还没有进行扩展的状态，$v_i$ 表示 $i$ 能不能被若干个 $a_j$ 加减得到。

1. 初始化状态：将 $0$ 入队，$v_0 \gets 1$。
1. 如果队列里仍然有数字，做以下步骤：
1. 将队头取出来，这里将这个数定为 $x$，枚举 $a_i$，如果 $v_{x \pm a_i} = 0$，那么 $v_{x \pm a_i} \gets 1$，再将 $x \pm a_i$入队。
1. 将队头出队。

枚举 $b_i$，如果 $v_{b_i} = 1$，那么这个数可行，否则不行。
## 实现时需要注意的点：
- 注意判断 $x - a_i \le 0$ 时，方案不和法。
- 因为角度最多只有 $360 ^ \circ$，所以每次要将 $x \pm a_i$ 与 $360$ 取模。
##  AC CODE
```cpp
#include <iostream>
#include <queue>
using namespace std;
int n, m;
int a[11], b[11];
bool v[361];//记录每个数可不可行
queue<int> q;
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= m; i++) {
    cin >> b[i];
  }
  q.push(0);
  v[0] = true;
  while (!q.empty()) {
    int x = q.front();
    for (int i = 1; i <= n; i++) {//枚举扩展
      int xx = x + a[i];
      xx %= 360;
      if (!v[xx]) {//如果这个数以前不可行
        v[xx] = true;//现在可行了
        q.push(xx);//将其入队
      }
      xx = x - a[i];
      if (xx <= 0) continue;
      xx %= 360;
      if (!v[xx]) {//同上
        v[xx] = true;
        q.push(xx);
      }
    }
    q.pop();
  }
  for (int i = 1; i <= m; i++) {
    if (v[b[i]]) {
      cout << "YES";
    } else {
      cout << "NO";
    }
    cout << "\n";
  }
  return 0;
}
```
## 有趣的发现：
我最开始写的时候忘了扩展 $x - a_i$，最后也 AC 了，不知道是数据水还是确实可以这样偷懒，~~数学太菜了没证明出来~~。

---

## 作者：_Fatalis_ (赞：1)

写这篇题解花了我~~很多~~不少时间，希望能过 awa

---
**题意：**

有 $m$ 个数，这 $m$ 个数能否由另外 $n$ 个数通过加减运算获得。

对于每一次加减的操作，结果不能小于 $0$（角度不能小于 $0$）；
对于大于等于 $360$ 的结果，对 $360$ 取模。（大于 $360^{\circ}$ 的角会转一圈后继续转）

能则输出 YES ，不能则输出 NO 。

**思路：**

$\texttt{dp}$（背包）、搜索都可以。~~dp 太难想~~ 这里我只讲搜索。

对于每一个状态，只有加和减两种状态。所以只需要对每一个状态枚举每一个数的加或减。

记录已经过状态，枚举中遇到了要获得的数，就表明可以实现。枚举结束后还没有遇到，则不能实现。

**实现：**

对于状态 $x$ ，

拓展 $(x\pm a[i]) \bmod 360$ 且 $x\pm a[i]\ge0$ 且未被拓展过。

**上代码！**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[11],b;
bool vis[361];

bool bfs(int end)
{
	memset(vis,0,sizeof(vis));
	queue<int> q;
	q.push(0);
	vis[0]=true;
	while(!q.empty())
	{
		int t=q.front();q.pop();
		if(t==end)
		{
			return true;
		}
		for(int i=1;i<=n;i++)
		{
			int cg=(t+a[i])%360;
			if(cg>=0&&(!vis[cg]))
			{
				vis[cg]=true;
				q.push(cg);
			}  //可以不枚举减法，文后给出证明过程
			/*cg=(t-a[i])%360;  
			if(cg>=0&&(!vis[cg]))
			{
				vis[cg]=true;
				q.push(cg);
			}*/
		}
	}
	return false;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		cin>>b;
		if(bfs(b)) puts("YES");
		else puts("NO");
	}
	return 0;
}
```
完结。

---

**对于可以不枚举 $x-a$ 的证明：**

对于任意正整数 $x$，$a$，$k$，$p$，证明：

$(x+ak) \bmod 360 = x-ap$。

$x$ 指某一状态。意思就是，只用加 $k$ 次 $a$ 就可以枚举到 $x-ap$。

原式可转化为： $360t+x-ap=x+ak$，$t$ 为任意正整数。

化简，得：$360t=a(p+k)$。

所以，只需证明 $a(p+k)$ 恒为 $360$ 倍数。

若 $a$ 为 $360$ 倍数，得证；

若 $a$ 不为 $360$ 倍数，

则若使 $(p+k)$ 为 $360$ 倍数，$k=360-p$ 即可。

又有 $x-ap\ge0$，则 $p\le \frac{x}{a}<360$。

则 $k$ 在满足 $k=360-p$ 的条件下满足 $k>0$，所以无论 $p$ 取多少都能满足 $(p+k)$ 为 $360$ 倍数。得证。

综上，$(x+ak) \bmod 360 = x-ap$。

---

第一次自己写 OI 证明题，有不对或不完善的地方请指出，谢谢qaq；

被打回x4 -- 求过！

---

## 作者：Astatinear (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7774)

### 思路
**背包问题。**

我们假设 $dp_j$ 表示是否能够达到 $j$ 度这个角度,如果可以,   $dp_j=1$ ,如果不可以, $dp_j=0$。

首先,初始值: $dp_0=1$。

然后,我们来看 $dp_j$ 的状态转移。

两种情况:

一:如果我们选择了 $+a_i$ ,则状态转移为 $dp_j \gets dp_j | dp_{j - a_i}$。

二:如果选择了 $-a_i$ ,则状态转移为 $dp_j \gets dp_j | dp_{j + a_i}$。

注意事项:

一:由于这是完全背包,所以 $j$ 这一层循环要正着枚举。

二:由于所有角度均小于 $360$ 度,所以状态转移要改成 $dp_{j \bmod 360} \gets dp_{j \bmod 360} | dp_{(j-a_i) \bmod 360}$。

答案

如果 $dp_{b_i}=1$ ,输出$\text{yes}$。

如果 $dp_{b_i}=0$ ,输出$\text{no}$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[15],b[15];
int dp[1005];//dp数组
int main()
{
    //输入
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    cin>>a[i];
    for(int i=1;i<=m;++i)
    cin>>b[i];
    dp[0]=1;//初始值,dp[0]=1
    for(int i=1;i<=n;++i)
    {
        for(int j=0;j<=1000;++j)//由于是完全背包,j枚举大一点
        {
            //状态转移
            if(j>=a[i])
            dp[j%360]|=dp[(j-a[i])%360];
            dp[j%360]|=dp[(j+a[i])%360];
        }
    }
    for(int i=1;i<=m;++i)
    {
        //判断输出YES,还是NO
        if(dp[b[i]]==1)
        cout<<"YES"<<endl;
        else
        cout<<"NO"<<endl;
    }
}
```

---


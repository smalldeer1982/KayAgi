# [蓝桥杯 2020 省 AB1] 走方格

## 题目描述

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 $1$ 至第 $n$ 行，从左到右依次为第 $1$ 至第 $m$ 列，每一个点可以用行号和列号来表示。

现在有个人站在第 $1$ 行第 $1$ 列，要走到第 $n$ 行第 $m$ 列。只能向右或者向下走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

## 说明/提示

$1\le n,m\le30$。

蓝桥杯 2020 第一轮省赛 A 组 G 题（B 组 H 题）。

## 样例 #1

### 输入

```
3 4```

### 输出

```
2```

# 题解

## 作者：da_ke (赞：25)

upt 2023/7/21：增加一些内容。

upt 2024/3/17：解答一些问题，删了一些废话。

upt 2024/8/27：补充了一个模板。

## 第一阶段

我不会动态规划 dp，我只会 深度优先搜索 dfs。

我们先按二维数组的习惯构建坐标系。$(x,y)$  表示第 $x$ 行，第 $y$ 列。

需注意边界处理。

- 走到第 $n$ 行第 $m$ 列时，证明我们已经走到了终点，所以增加 $1$。

- 如果越界了，那么就不算。

- 如果走到了题目中规定不走的格子，那么也不算。

注意 if 条件判断的顺序不能错哟。（请读者仔细考虑）

边界处理完后，我们看看怎么递归。

如果我们记 $f_{x,y}$ 为点 $(x,y)$ **到终点走法总数**，依据题意可得

$$f_{x,y}=f_{x+1,y}+f_{x,y+1}$$

其中 $f_{x+1,y}$ 表示 **向下走一步后到终点走法总数**，$f_{x,y+1}$ 表示 **向右走一步后到终点走法总数**。

如上所述递归即可。

```cpp
#include <bits/extc++.h>
// extc++.h 是扩展库，这里用不到。
#define int long long

using namespace std;

int n,m;

int dfs(int x,int y){
    if(x>n||y>m) //如果越界了,那么就不算.
        return 0; 
    if(x==n&&y==m) ////走到第 n 行第 m 列时,证明我们已经走到了终点,所以增加 1 .
        return 1;
    if((x%2==0)&&(y%2==0)) //如果走到了题目中规定不走的格子,那么也不算.
        return 0; //注意if的顺序不能错哟
    int ans=dfs(x+1,y)+dfs(x,y+1); //递归求解
    return ans; //返回答案
}

signed main(){
    cin>>n>>m;
    cout<<dfs(1,1);
}
```

建议读者仔细理解上面程序。

时间复杂度： 指数级别的。

## 第二阶段 (记忆化搜索)

关键词： [**记忆化搜索**](https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp)

类似 P1048，我们也可以通过添加记忆化数组来优化算法。


```cpp
#include <bits/stdc++.h>

using namespace std;

int n,m;
int mem[100][100]; //记忆化

int dfs(int x,int y){
    if(x>n||y>m)
        return 0;
    if(x==n&&y==m)
        return 1;
    if((x%2==0)&&(y%2==0))
        return 0;
    if(mem[x][y]!=-1)
        return mem[x][y];
    int ans=dfs(x+1,y)+dfs(x,y+1);
    return mem[x][y]=ans;
}

signed main(){
    memset(mem,-1,sizeof(mem)); //记得清空为-1
    cin>>n>>m;
    cout<<dfs(1,1);
}
```

时间复杂度：$O(nm)$。（每个函数调用只访问了一次）

## 模板总结

其实我之前的那种写法不太好调试，这里给一个刘汝佳老师推荐的写法模板：

```cpp
// 这里是一个二维 DP 模板，其他可以类推。
int mem[N][N];
int dp(int i,int j)
{
  int& ans=mem[i][j]; // 传引用，不会自己百度
  if(ans!=-1) return ans; // 记忆化
  ans=min(...) // ... 填转移方程。
  return ans; // 返回，实际上也实现了记忆化。
}
memset(mem,-1,sizeof(mem));
```

## 问题&解答

Q chuiniudawang：`return mem[x][y]=ans;` 的作用是什么，为什么不直接`return ans;`。

A da_ke：`return mem[x][y]=ans;` 的作用是先 `mem[x][y]=ans`，再 `return mem[x][y]`；若直接 `return ans;` 则相当于没有「记忆化」，会超时。

Q xyx2002：时间超出了。

A da_ke：如果你提交第一份当然会超时，因为它没有**剪枝**。设想一下，第一份代码就是普通的 DFS，复杂度自然是指数级别的。

## 总结

这道题让我们学会了 **记忆化搜索** 这个法宝。用记忆化搜索会使代码比递推自然。

记忆化的关键是要大胆搜索，小心判断边界。

做完这道题请你尝试：

- [P1464 Function](https://www.luogu.com.cn/problem/P1464)（提示：不要每次都清空记忆数组）

- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)（提示：注意边界哟）

这是蒟蒻的第一篇题解，感谢支持！

---

## 作者：Ggsddu_zzy (赞：17)

[题目传送门](https://www.luogu.com.cn/problem/P8707))

#### 题目大意

现在有个人站在第 $1$ 行第 $1$ 列，要走到第 $n$ 行第 $m$ 列（只能向右或者向下走），如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

#### 解题思路

从 $f_{1,1}$ 推到 $f_{n,m}$：

- 划分阶段：以当前的方案数为阶段；

- 状态表达：设 $f_{i,j}$ 表示走到第 $i$ 行，第 $j$ 列时的方案数；

- 初始状态：$f_{i,1}=1,f_{1,j}=1$；

- 转移方程：$f_{i,j}=f_{i-1,j}+f_{i,j-1}$（在可以走入这一格的情况下）；

- 求解目标：$f_{n,m}$；



#### 代码

[AC 记录](https://www.luogu.com.cn/record/102826431)

```c++
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int n,m,f[35][35];
int main() {
	cin>>n>>m;
	for(ri i=1;i<=n;i++)f[i][1]=1;
	for(ri j=1;j<=m;j++)f[1][j]=1;
	//从起始点到第一行和第一列的方案数都为 1 
	for(ri i=2;i<=n;i++){
		for(ri j=2;j<=m;j++){
			if(i%2==0&&j%2==0)f[i][j]=0;//不能进入：将方案数赋为 0 
			else f[i][j]=f[i-1][j]+f[i][j-1];//能进入：计算从左和从上走到当前位置的方案数 
		}
	}
	cout<<f[n][m];//输出答案 
	return 0;
}
```

---

## 作者：yszkddzyh (赞：10)

这是一道典型的动态规划题目，建议先尝试 P1002。

设 $f(x,y)$ 表示到格子 $(x,y)$ 有多少走法，则易知 $f(1,1)=1$。而每一个格子（行、列号均为偶数或行、列号均为 $1$ 除外）都可以由它上面和左边的格子走来，所以可以得到状态转移方程：

$$f(x,y)=f(x-1,y)+f(x,y-1)$$

其中 $x,y$ 满足 $x,y$ 不均为偶数，并且 $x,y$ 不均为 $1$。

而对于每一对 $x,y$ 均为偶数，有 $f(x,y)=0$。

因此我们很容易得出以下代码：

```cpp
#include <iostream>
using namespace std;
int f[31][31];
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	f[1][1]=1;//边界：f(1,1)=1
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if((i&1||j&1)&&(i!=1||j!=1))//i,j不均为偶数，且i,j不均为1
				f[i][j]=f[i-1][j]+f[i][j-1];//状态转移
	printf("%d",f[n][m]);
	return 0;
}
```

---

## 作者：Iniaugoty (赞：4)

### 题意简述

在一个矩阵中，每次可以向下或向右走，不能走到行数和列数都为偶数的格子上，问从 $(1,1)$ 走到 $(n,m)$ 有多少种方案。

***

### 解法

不知道搜索能不能过，最好考虑**动态规划**。

定义 $dp_{i,j}$ 为走到第 $i$ 行第 $j$ 列时的方案总数。

下面推状态转移方程。

只能向下或右走，说明某个格子，只能从上面或者左面走过来，这个格子的方案数，就是上面和左面两个格子的方案数之和，即 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

注意到不能走向行数和列数都为偶数的格子，于是把它的方案数当作 $0$ 处理，即 $dp_{i,j}=0$。

显然，初始格子只有 $1$ 种方案。

综上，状态转移方程为 $dp_{i,j}=\begin{cases}
1 & (i=1)\land(j=1) \\
0 & (2\mid i)\vee(2\mid j)\\
dp_{i-1,j}+dp_{i,j-1} & otherwise
\end{cases}$，（这里 $dp$ 数组初始都为 $0$）。

***

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[31][31];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(i==1&&j==1)
				dp[i][j]=1;
			else if(i%2==1||j%2==1)
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
		}
	printf("%d",dp[n][m]);
	return 0;
}

```
***

~~奇怪的是，我之前已经 AC 了这题，写这篇题解前又重写了一遍，还交了三次才过。~~

---

## 作者：zymooll (赞：1)

### 题意简述

一个 $n$ 行 $m$ 列的图，除行与列皆为偶数的节点外的各个节点均连通，在只能够向下或向右的情况下，求从 $(1,1)$ 到 $(n,m)$ 的方案数。

### 思路简述

我们可以采用动态规划的方法，定义二维数组 $dp_{i,j}$ 表示从 $(1,1)$ 到 $(i,j)$ 点的方案数。

据题意只能够向下或向右走，可得每一个点 $(i,j)$ 只能够从 $(i-1,j)$ 或 $(i,j-1)$ 走过来，故方案数 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

另外，因为当行和列皆为偶数时，该节点不可用，所以 $dp_{2p,2q}=0$ $(p,q \in N*$ 且 $2p \le n,2q \le m)$。当然在实际程序中，我们枚举到行和列皆为偶数的点时，可以在置零后跳过该点。

接下来确定初始状态，显然从 $(1,1)$ 到 $(1,1)$ 有一种方案，故 $dp_{1,1}=1$。

最后输出答案，即 $(1,1)$ 到 $(n,m)$ 的方案数 $dp_{n,m}$。

### 代码

为排版美观，已将头文件及快读快写删去。

```cpp
// Author:zymooll
int n,m;
int dp[40][40];
signed main(){
	n=read(),m=read();
	dp[1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2==0&&j%2==0)continue;
			dp[i][j]+=dp[i-1][j]+dp[i][j-1];
		}
	}
	cout<<dp[n][m];
	return 0;
}

```

### 备注

参考时间复杂度 $O(nm)$

---

## 作者：WA_sir (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/P8707)

典型的 dp 题（当然你也可以 dfs）。

每个格子能走到的方案数为其上、左两个格子方案数之和。因为只有这两个格子能走到它。

此题的唯一限制是“如果行号和列数都是偶数，就不能走入这一格中”。对于这一限制，解决方法其实并不难。可以在循环时进行判断，若能走就计算方法数，不能走就设置为 $0$。

但在处理 $[1,1]$ 时，会直接赋值为前两个格子的方案数。而这两个格子都默认为 $0$，所以应该把其中一个初值设为 $1$。

参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,_[33][33];
int main()
{
	scanf("%d%d",&n,&m);
	_[0][1]=1;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(i%2||j%2)_[i][j]=_[i-1][j]+_[i][j-1];
	printf("%d",_[n][m]);
	return 0;
}
```
感谢阅读！

---


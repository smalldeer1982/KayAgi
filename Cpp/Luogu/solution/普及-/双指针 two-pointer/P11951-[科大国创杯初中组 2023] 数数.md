# [科大国创杯初中组 2023] 数数

## 题目描述

小可可和小多在拼木棍。

他们现在拿到了 $n$ 根木棍，第 $i$ 根木棍的长度是 $a_i$。他们现在想知道，有多少种在里面选三根木棍的方案，使得这三根木棍能组成一个三角形？

三根木棍能组成一个三角形，当且仅当较短的两根木棍长度和大于最长的那根木棍长度。

## 说明/提示

### 样例 1 解释

可以选择的编号的方案是：$(1,2,4)$，$(1,2,5)$, $(1,3,4)$，$(1,3,5)$，$(1,4,5)$，$(2,3,5)$, $(2,4,5)$，$(3,4,5)$。

### 数据规模与约定

对于 $20\%$ 的数据，满足 $n \leq 100$；

对于 $40\%$ 的数据，满足 $n \leq 10^3$；

对于另外 $20\%$ 的数据，满足 $a_i \leq 5 \times 10^3$；

对于 $100\%$ 的数据，满足 $3 \leq n \leq 8 \times 10^3$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
3 2 5 3 4```

### 输出

```
8```

# 题解

## 作者：2023z (赞：6)

这里提供比较暴力的二分做法

前置芝士：`lower_bound` 函数，它可以计算第一个大于等于 $ x $ 的位置。建议先学会二分的原理和手打二分模板很熟练后再用函数。

### 题意

让我们找出所有满足三根木棍能组成三角形的方案数，条件是两个短边的和大于长边。

### 思路

我们可以枚举两个短边，用二分计算出第一个大于等于 $ a_i+a_j $ 的位置，那这两条短边的方案数就是 $ pos-j-1 $ ，累加上方案，最后就是一共的方案数了。

手打二分代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[8010],ans; //不开 long long 见祖宗
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]; //输入
	sort(a+1,a+n+1); //排序
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int l=j,r=n,mid; //l 表示左端点，r 表示右端点，mid 表示中间位置
			while(l<=r){
				mid=(l+r)>>1;
				if(a[mid]>=a[i]+a[j]) r=mid-1; //如果 a[i]+a[j]<a[mid] 就缩小 r 的范围
				else l=mid+1; //mid+1 为第一个最后一个小于 a[i]+a[j] 的位置的后面一个，也就是第一个大于等于 a[i]+a[j] 的位置
			}
			ans+=l-j-1; //计算方案数，注意要减去 l 自己的位置
		}
	}
	cout<<ans; //输出
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/209409825)

运用函数就方便多了：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[8010],ans; //不开 long long 见祖宗
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]; //输入
	sort(a+1,a+n+1); //排序
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int pos=lower_bound(a+1,a+n+1,a[i]+a[j])-a; //计算第一个大于等于 a[i]+a[j] 的位置
			ans+=pos-j-1; //将方案累加
		}
	}
	cout<<ans; //输出
	return 0;
}
```
[还有一个](https://www.luogu.com.cn/record/209407645)

---

## 作者：Zskioaert1106 (赞：4)

题目传送门：[P11951 [科大国创杯初中组 2023] 数数](https://www.luogu.com.cn/problem/P11951)

### 做题过程

看到 $n \leq 8\times 10^3$，想到可以跑二重循环。

那怎么达成枚举三根木棍的效果呢？想到第三根木棍可以二分。

我们先将所有木棍排一下序，然后从 $1$ 开始枚举第一根木棍 $i$，从 $i+1$ 开始枚举第二根木棍 $j$，然后二分求得满足 $a_i+a_j>a_{ans}$ 的最大 $ans$，且 $j < ans \leqslant n$。

此时满足两根短木棍为 $i$ 和 $j$ 的方案数即为 $ans-j$，就是从 $a_{j+1}$ 到 $a_{ans}$ 都可以作为第三根木棍。

这样时间复杂度为 $O(n^2\log n)$。

### 代码实现

记得给答案开 long long！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[8003];
long long s;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+1+n);
    for(int i=1;i<n;i++){
        for(int j=i+1;j<n;j++){
            int l=j+1,r=n,mid,ans=j;
            while(l<=r){//二分答案
                mid=l+r>>1;
                if(a[i]+a[j]>a[mid]){
                    ans=mid;
                    l=mid+1;
                }
                else r=mid-1;
            }
            s+=ans-j;
        }
    }
    cout<<s;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/209321948)。

---

## 作者：Wish_kazdel (赞：3)

## 思路
首先考虑一下双指针。从作业中得到的启发，首先对于每个可能的最长边，使用双指针法来找到所有满足条件的较短两边的组合。具体来说，对于每个最长边的位置 $k$，维护两个指针 $i$ 和 $j$，分别从数组的起始位置和 $k$ 的前一个位置开始，通过移动指针来统计满足条件的组合数。

然后考虑到可以用二分优化，通过维护两个指针 $left$ 和 $right$，分别从数组的起始位置和 $k$ 的前一个位置开始，通过移动指针来统计满足条件的组合数。

这样就好了。

---

## 核心代码

```cpp
signed main() {
    int n=read();
    for (int i = 0; i < n; i++)a[i] = read();
    sort(a,a + n);
    long long ans = 0;
    for (int k = 2; k < n; k++) {
        int left = 0, right = k - 1;
        while (left < right) {
            int sum = a[left] + a[right];
            if (sum > a[k]) {
                ans += right - left;
                right--;
            } else {
                left++;
            }
        }
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：Miku_QwQ (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P11951)

洛谷终于有我们 AH 的题了！

题意很清楚，不再多说。

首先 $O(n^3)$ 的枚举应该是显然的吧。

接下来我们考虑先对 $a$ 排序，令选取的三根小棒编号为 $i$，$j$ 和 $k$，且满足 $i < j < k$。则限制条件变成了 $a_i+a_j>a_k$。

然后我们肯定是可以支持 $O(n^2\log n)$ 的复杂度的。直接枚举 $i$ 和 $j$，然后二分即可。

但是按照 $n \leq 8 \times 10^3$ 的数据，这个东西肯定是不给你过的。~~虽然考场上放过去了~~我们还是要考虑正解。

考虑只枚举 $i$，接下来限制变成了 $a_i>a_k-a_j$，容易发现这个东西一看就很双指针，直接双指针枚举即可。时间复杂度显然 $O(n^2)$。

然后附上丑陋的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[8010];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	long long ans=0;
	for(int i=1;i<=n-2;i++){
		int j=i+1;
		for(int k=i+2;k<=n;k++){
			while(a[i]+a[j]<=a[k]  &&  j<k-1){
				j++;
			}
			if(a[i]+a[j]>a[k]){
				ans+=k-j;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

闲话：这题二分不会被卡，但是不开 `long long` 考场好像会直接挂成 $40$。

---

## 作者：DLJdouliangjian (赞：1)

## P11951 [科大国创杯初中组 2023] 数数  
看到题不用想先排序。  
最好想到的思路就是三重循环，但会超时。  
于是就可以先想想怎么优化三重循环，发现最后一层循环不需要每次都来一遍，因为排过序了，因为 $i$ 是固定的，所以 $j$ 满足的 $k$，$j+1$也一定满足。  
于是第三重循环就可以拆掉。  
每次循环结束后 $cnt$ 加上 $k-j+1$ 即可。  
### CODE:
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n,a[8005],pos;
long long cnt;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        int k=i+2;
        for(int j=i+1;j<=n;j++){
            while((a[i]+a[j])>a[k]&&k<=n){
                k++;
            }
            cnt+=(k-j-1);
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：lzx111218 (赞：1)

# P11951 [科大国创杯初中组 2023] 数数
[题目传送门](https://www.luogu.com.cn/problem/P11951)
## 思路
排序 + 双指针 + 贪心。

题目要求我们在给定的 $n$ 根木棍中，使得它们可以组成三角形，即满足 三角形不等式：$a+b>c$，其中 $a ≤ b ≤ c$。

一开始我们将木棍数组**升序排序**。排序的时间复杂度是 $O(n \log n)$。

对于每个可能的最长边 $a_i$，用**双指针**来寻找符合 $a_x + a_y > a_i$ 的 $(x, y)$ 组合：
- 设 $x = 0$，$y = i - 1$。
- 如果 $a_x + a_y > a_i$，则**所有**在 $x$ 到 $y$ 之间的 $x$ 都可以与 $y$，$i$ 组成合法三角形，计数 $y - x$，然后 $y--$。
- 否则，$x++$。

总时间复杂度是 $O(n^2)$。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n;
    long long ans = 0;
    cin >> n;
    vector<long long> a(n);
    for (auto &x : a) cin >> x;
    sort(a.begin(), a.end());
    for (int i = n - 1; i >= 2; i--) {
        int x = 0, y = i - 1;
        while (x < y) {
            if (a[x] + a[y] > a[i]) { // 满足三角形不等式
                ans += (y - x);
                y--; // 让 y 更小，尝试其他可能
            } else {
                x++; // 让 x 更大，增大两边和
            }
        }
    }

    cout << ans << "\n";
    return 0;
}

---

## 作者：dsj2012 (赞：0)

# 题意
给定 $n$ 个木棍，选择其中的三个组成三角形。问有多少种不同的解法。
# 思路
我们知道，三角形中的三条边任意两条相加必须大于第三条。然后我们又发现 $n$ 是不大的。那么我们就直接枚举最小的两条。

既然我们知道了其中两条，那么在剩下的木棍中有那些满足我们的条件呢？肯定是比枚举两个数相加要小的。

那么这最后一条边难道我们也要枚举吗？当然不，如果枚举会超时的，其实这个时候我们可以二分最后一条边。

因为我们是要找比枚举的两条边要小的数的数量。那么我们就整个数组排序后直接二分这个数就可以了。

最后这次寻找的答案是在 $j$ 与 $l$ 之间的。因为大于 $l$ 就会不满足三角形的基本条件。而小于 $j$ 以前搜的结果中肯定是搜到过的。毕竟我们是选择两条小的后找最大的。最后输出答案和即可。
## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[8005];
int ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1 ; i <= n ; i ++)cin >> a[i];
	sort(a + 1 , a + 1 + n);
	for(int i = 1 ; i <= n ; i ++){
		for(int j = i + 1 ; j <= n ; j ++){
			int l = j - 1,r = n + 1;
			while(l + 1 < r){
				int mid = (l + r) / 2;
				if(a[i] + a[j] <= a[mid]){
					r = mid;
				}else{
					l = mid;
				}
			}
			ans += l - j;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：yyycj (赞：0)

## 题目简述
给定长度为 $n$ 的正整数序列 $a$，求在 $a$ 中任意选三个数可以分别作为一个三角形的三边并组成三角形的方案个数。

## 主要思路
首先可以排除 $O(n^{3})$ 的纯暴力做法。

考虑二分，给定的初数组不一定有序，所以需要先排一遍序。随后用 $n^{2}$ 的方法枚举 $i$ 和 $j$，满足 $i<j$ 并且 $i,j < n$；这样剩下一条边的范围是确定的，即 $a_{j} \sim a_{i}+a_{j}-1$，这里不需要考虑第三条边 $< a_{j}$ 的情况，否则会重复算。用 `lower_bound` 分别枚举第一个满足 $\ge a_{j}$ 和第一个满足 $\ge a_{i}+a_{j}$ 的元素的下标，答案加上两数相减即可。

## 时间复杂度
$O(n^{2} \log n)$

## 注意事项
在最极端情况下，答案会达到 $n^{3}$，即 $5.12 \times 10^{11}$，所以：十年 OI 一场空，_____________________。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
typedef long double db;
const int N = 8e3 + 10;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
// ----------------------------

// ----------------------------
int a[N];
// ----------------------------


int main() {
	int n; cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	// ----------------------------
	ll ans = 0;
	sort(a + 1, a + n + 1);
	for (int i = 1; i < n - 1; i++) {
		for (int j = i + 1; j < n; j++) {
			ans += (lower_bound(a + j + 1, a + n + 1, a[i] + a[j]) - a) - (lower_bound(a + j + 1, a + n + 1, a[j]) - a);
		}
	}
	// ----------------------------
	cout << ans;
	return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P11951)

# 思路

读完题目，最直接的办法是用三层循环暴力枚举，题目给的数据范围是 $3 \le n\le 8\times 10^3$，$O\left(n^3\right)$ 会爆。但是两层循环就不会，怎么优化？

答案是二分，所以我们先给数组 $a$ 排个序，再枚举第一根木棍，然后在有一根木棍的基础上去二分，找到剩下的两根木棍，更新答案。

要开 long long，本人卡了 $3$ 次。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=8e3+5,mod=1e9+7,MOD=998244353;
ll n,a[MAX],ans=0;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    for(ll i=0;i<n;i++)cin>>a[i];
    sort(a,a+n);// 变为有序，方便二分
    ll cnt=0;
    for(ll i=n-1;i>=2;i--){
        ll l=0,r=i-1;
        while(l<r){// 二分
            if(a[l]+a[r]>a[i]){// 若满足条件，说明 l 到 r-1 的所有组合都能与 r 和 i 构成三角形
	            cnt+=r-l;
	            r--;
	        }else l++;
	    }
	}
	cout<<cnt<<'\n';// 输出
	return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/209443485)

---

## 作者：_Jocularly_ (赞：0)

题目转化为求满足条件的三元组，我们可以排序，枚举确定最大的那一条边，然后通过双指针求出所有的合法三元组。假设当前枚举的最长边为 $a[k]$，具体为初始让 $i = 1$ 且 $j = k - 1$，那么如果满足 $a[i] + a[j] > a[k]$，那么就说明当前这一组是合法的，那么可以推出 $i$ 到 $j - 1$ 的都是合法的，因为排序了之后，这一段上的长度是单调非减的，因此只要 $i$ 合法，那么$i$ 到 $j - 1$ 的都是合法的，累加答案即可。

每次统计完当前的 $j$ 就让他向前移一位，看看前面还有没有合法的；如果没找到当前 $j$ 所配对的 $i$，那么就让 $i$ 向后移一位，让他先找到当前 $j$ 的答案。

双指针的复杂度为 $O(n)$，外层枚举 $O(n)$，总复杂度在 $O(n^2)$ 的规模。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int a[8005];
int ans;
signed main() {
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    sort(a+1,a+1+n);
    for(int k=n;k>=3;k--){
        int i = 1,j = k - 1;
        while(i < j){
            if(a[i] + a[j] > a[k]) ans += (j --) - i;
            else i ++;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

萌萌二分题。

---

这个值域跑 $O(n^3)$ 肯定是会炸的，所以这启示我们进行优化。

注意到把其中两个木棒枚举出来以后，剩下木棒的可用性是有单调性的。

那么就可以针对第三根跑二分。

时间复杂度 $O(n^2 \log n)$ 可以通过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[8005],ans;
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            int l=j,r=n;
            while(l<r){
                int mid=(l+r+1)/2;
                if(a[mid]<a[i]+a[j])l=mid;
                else r=mid-1;
            }
            ans+=l-j;
        }
    }
    cout<<ans;
    return 0;
}
```

注意 `long long`。

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11951)

提供一种 $\mathcal O(n^2)$ 的双指针做法。

我们首先将所有木棍按长度升序排列。这样，当固定最长的一根木棍时，可以快速判断其前面两根的和是否满足条件。

接着，对于每根作为最长木棍的位置 $i$，使用双指针 $l$ 和 $r$ 在其左侧寻找满足条件的木棍对。若 $a_l + a_r > a_i$，则所有在 $l$ 到 $r-1$ 之间的木棍与 $r$ 的组合均满足条件，统计这些组合数后移动指针。

时间复杂度是 $\mathcal O(n^2)$ 的，可以通过本题的数据规模。

代码实现如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=8001;
int n,a[N],ans;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=3;i<=n;i++){
        int l=1,r=i-1,cnt=0;
        while(l<r){
            if(a[l]+a[r]>a[i]){
                cnt+=r-l;
                r--;
            }
			else l++;
        }
        ans+=cnt;
    }
    cout<<ans;
}
```

---


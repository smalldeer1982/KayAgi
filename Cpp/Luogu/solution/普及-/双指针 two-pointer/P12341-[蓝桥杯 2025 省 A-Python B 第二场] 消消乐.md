# [蓝桥杯 2025 省 A/Python B 第二场] 消消乐

## 题目描述

小蓝正在玩一个叫“一维消消乐”的游戏。游戏初始时给出一个长度为 $n$ 的字符串 $S = S_0S_1\ldots S_{n-1}$，字符串只包含字符 $\text{A}$ 和 $\text{B}$。小蓝可以对这个字符串进行若干次操作，每次操作可以选择两个下标 $i, j \in [0, n-1]$，如果 $i < j$ 且 $S_i = \text{A}$ 且 $S_j = \text{B}$，小蓝就可以把它们同时消掉。小蓝想知道在经过若干次操作后，直到无法对字符串继续进行操作时，字符串最多剩下多少个字符。

## 说明/提示

### 样例说明

先消掉 $(S_1, S_6)$，再消掉 $(S_4, S_5)$，此时剩下 $\text{BBAA}$，无法继续进行操作。

### 评测用例规模与约定

- 对于 $10\%$ 的评测用例，$1 \leq n \leq 20$；
- 对于 $20\%$ 的评测用例，$1 \leq n \leq 100$；
- 对于 $50\%$ 的评测用例，$1 \leq n \leq 10000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
BABAABBA```

### 输出

```
4```

# 题解

## 作者：Clare613 (赞：2)

## 思路
这道题要我们消除到不能再消除时，字符串长度最大。很明显，我们一定要用尽量前的 A 来消除尽量后的 B，从而使字符串大，剩下来的模拟即可。
## code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	string x;
	cin>>x;
	int ans=x.size();
	int l=0,r=x.size()-1;
	while(l<r){
		while(x[l]!='A'&&l<x.size()) l++;
		while(x[r]!='B'&&r>=0) r--;
		if(l>=r) break;
		ans-=2;
		l++;
		r--;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：yulinOvO (赞：2)

### 题意：
在给定的字符串 $s$ 中，尽可能多地消去 $A$ 和 $B$ 的组合（$A$ 在前，$B$ 在后），直到无法继续操作。最终返回剩余字符的数量。
### 思路：
为了最大化消去的对数，我们应尽可能让前面的 $A$ 和后面的 $B$ 匹配，考虑使用双指针。
### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main() 
{
	cin >> s;
    int l=0,r=s.size()-1,c=0;
    while(l<r)
	{
        while(l<r&&s[l]!='A') l++;
        while(l<r&&s[r]!='B') r--;
        if (l<r) c++,l++,r--;
    }
    cout << s.size()-2*c;
}
```

---

## 作者：guoshengyu1231 (赞：2)

# 题意分析
根据题目描述，这是一个关于字符串操作的问题，需要通过消去特定字符对（$A$ 在前，$B$ 在后）来**最大化**剩余字符数量。
# 思路
注意这题是来**最大化**剩余字符数量，那我们得想如何贪心使得剩余字符数量最大，也就是消除的字符对最少。 $\\$ 

既然要我们使消除的字符对最少，那我们肯定是考虑最不利的情况，由于一定得是 $A$ 在前，$B$ 在后。那如果我们用一个 $A$ 来匹配比较靠后的 $B$，那么比较前面的 $B$ 就没有前面的 $A$ 来匹配，而比较后面的 $A$ 也失去了本应该匹配的 $B$。可能这么说有些抽象，那我就举个例子吧。 $\\$ 
示例： $\\$ 
```cpp
ABAB
```
在这个字符串中，如果要使字符全部消除的话那就是 $A$ 和 $B$ 两两一对消除。但我们要使消除的字符对最少，我们可以让第一个 $A$ 和最后一个 $B$ 消除。这样就可以使消除的字符对最少。为什么这个贪心的思路使对的？首先，对于字符串中的每一个 $A$，既然我们已经枚举到了这一个 $A$，那前面所有的 $A$ 都一定是用过了的。此时，假设后面还有多余一个的 $B$，如果我们选择最靠后的 $B$，那么之后遇到的第一个 $B$ **一定**是没的匹配的。这样我们可以使无法匹配的字符数量最大化。或者我们可以从 $B$ 的角度来想，道理也差不多。
 $\\$ 

所以贪心的依据不就出来了吗？ $\\$ 
既然都已经有思路了，那代码岂不是轻易打出来？
# 具体实现
由于我们是要枚举最靠前的 $A$ 和最靠后的 $B$。那我们不妨用一个指针 $l$ 来枚举考前的 $A$，再用另一个指针枚举靠后的 $B$。之后不断移动指针 $l$，直到 $s_l=A$。当然，$r$ 的移动也是同理。但是，无论如何，一定要满足 $l<r$，在移动完 $l$ 和 $r$ 后还得加一句特判。然后就是消除一对 $A$ 和 $B$ 了。 $\\$ 
就这样一直循环往复，直到 $l\ge r$，在循环中统计一共消除了多少对，最后减一减就行啦！
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main()
{
	cin>>s;
	int l=0,r=s.size()-1,sum=0;
	while(l<r)
	 {
	 	while(s[l]!='A'&&l<r) l++;
	 	while(s[r]!='B'&&l<r) r--;
	 	if(l>=r) break;//特判
	 	l++;r--;sum+=2;
	 }
	cout<<s.size()-sum;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12341)
## 题目分析
希望审核员大大给过。

这道题有几个要点重点：
- left 必须要小于 right
- left 必须是 A，right 必须是 B
- left 要从 $s_0$ 开始，right 要从 $s_{n-1}$ 开始

这么一列出来，就很清楚了，可以用**贪心**枚举 left 和 right，left 为 ```while (left < right && s[left] != 'A')left++```，right 为 ```while (left < right && s[right] != 'B')right--```，最后加上一个判断符不符合题目的要求即可。

还有一个重点，一次操作会消掉两个字符，所以输出是要输出 ```n-2*count```。
## 题目代码
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	int n = s.size(); //字符串长度
	int left = 0, right = n - 1;
	int count = 0;
	while (left < right) {
		while (left < right && s[left] != 'A')left++;
		while (left < right && s[right] != 'B')right--;
		if (left < right && s[left] == 'A' && s[right] == 'B') {
			count++; //增加一次操作次数
			left++; //继续循环查找
			right--;
		}
	}
	cout << n - 2 * count; //一次操作两个字符没
	return 0;
}
```
```python
s = input().strip()
n = len(s)
left, right = 0, n - 1
count = 0

while left < right:
    while left < right and s[left] != 'A':
        left += 1
    while left < right and s[right] != 'B':
        right -= 1
    if left < right and s[left] == 'A' and s[right] == 'B':
        count += 1
        left += 1
        right -= 1

print(n - 2 * count) 
```

---

## 作者：bjqxszx_liruixuan (赞：1)

## 思路
因为要一直操作下去，所以剩下的字符串为 $B \cdots BA \cdots A$ 这种类型的。让剩下的字符最少也就意味着我们要尽可能删除靠前的 $A$ 和靠后的 $B$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int ans,x;
bool flag;
int main()
{
	cin>>s;
	x=s.length();
	for(int i=0;i<s.length();i++)//从前遍历A
	{
		if(s[i]=='A')
		{
			flag=0;
			for(int j=x-1;j>i;j--)//从后遍历B
			{
				if(s[j]=='B')//如果可以消除
				{
					ans+=2;//ans为消除的数量
					flag=1;
					x=j;//x记忆遍历到哪里了，就不需要从头开始，节省时间复杂度
					break;
				}
			}
			if(flag==0)//如果不能消除了，就直接跳出
			{
				break;
			} 
		}
	}
	cout<<s.length()-ans;//输出剩余数量
 	return 0;
}


```

---


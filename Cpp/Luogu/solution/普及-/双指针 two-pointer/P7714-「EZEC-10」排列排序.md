# 「EZEC-10」排列排序

## 题目描述

给你一个长度为 $n$ 的排列 $p_1,p_2, \cdots ,p_n$。你需要把它排序。

每次可以花区间长度，即 $r-l+1$ 的代价，选择排列中的任意一段区间 $[l,r]$，并将 $[l,r]$ 从小到大排序。

现在你可以让他进行若干次这个操作，直到 $p$ 中元素的值从 $1$ 到 $n$ 按升序排序，即对于 $1$ 到 $n$ 的每一个 $i$，都有 $p_i=i$。

求问花的代价最少为多少？

## 说明/提示

【样例 $1$ 说明】

对于第一组数据，可选择区间 $[2,3]$ 进行排序。

对于第二组数据，可选择区间 $[1,3]$ 进行排序。

【数据规模与约定】

对于 $20\%$ 的数据，$n\leq 4$。

对于另 $30\%$ 的数据，$\sum n\leq5000$。

对于另 $10\%$ 的数据，$p_1=n$。

对于 $100\%$ 的数据，$1\le T,\sum n\le 10^6$。

## 样例 #1

### 输入

```
2
3
1 3 2
4
3 2 1 4```

### 输出

```
2
3```

# 题解

## 作者：YYen (赞：61)

### 思路：双指针
比赛时候看到这个题脑海闪过双指针，测试了几组例子发现都没问题，交了就AC了，说一下思路：

先约定，左指针 $ i $ 初始值为 $ 1 $ ，以及右指针 $ j $。

从左往右逐个元素进行枚举，

①、如果某个元素值与下标相同，代表该元素处于正确的位置，左指针 $ i $ 加 $ 1 $ 枚举下一个元素。

②、不同则代表该元素处于不正确的位置，此时左指针 $ i $ 指向的下标即为排序的左端点，因此生成右指针 $ j $ ，初始化为 $ i + 1 $ ，开始往后查找排序的右端点。该查找过程还需要一个 $ maxv $ 变量来维护双指针范围内的区间最大值，当右指针 $ j $ 不停向右滑动，直至指向的下标大于等于区间最大值时，右指针 $ j $ 指向的下标即为排序的右端点（这个道理应该是显然的，因为如果右指针 $ j $ 指向的下标不如区间最大值 $ maxv $ 大，代表还没找到区间最大值的对应位置，还需要进一步扩大区间长度，所以右指针 $ j $ 还需要继续右移）。此时排序区间长度为 $ j - i + 1 $ 。更新左指针 $ i $ 为右指针 $ j $ 的下一个位置，重复以上过程，直至全部元素枚举完毕。

最终时间复杂度为 $ O(n) $ 。
### 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[1000005];

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int n, ans = 0;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
        int i = 1;
        while (i <= n)
        {
            if (a[i] == i) // 相同 
                i++;
            else // 不同 
            {
                int maxv = a[i];
                int j = i + 1;
                maxv = max(maxv, a[j]);
                while (maxv > j)
                {
                    j++;
                    maxv = max(maxv, a[j]);
                }
                ans += j - i + 1;
                i = j + 1;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：14)

## Content
给定一个 $1\sim n$ 的一个排列 $p$，你每次可以选择一个区间 $[l,r]$ 并花费 $r-l+1$ 的代价将下标在这个区间内的所有数升序排序，求使得排列 $p$ 从 $1\sim n$ 按升序排序的最少代价。

**数据范围：$t$ 组数据，$1\leqslant t,\sum n\leqslant 10^6$。**
## Solution
我们直接来考虑正解。

我们不妨考虑怎样去选择区间才能做到最小代价，然后我们不难想到这样的贪心做法：如果一段区间 $[l,r]$ 里面的所有数是一个 $l\sim r$ 的一种排列并且区间长度不为 $1$（长度为 $1$ 的话不需要花费 $1$ 的代价去升序排列这个区间），那么我们就立即选择这一个区间翻转，并更新下一个需要翻转的区间的左端点。这样可以保证花费的代价是最小的。

具体如何判断一段区间 $[l,r]$ 里面的所有数是一个 $l\sim r$ 的一种排列，我们只需要边输入的时候边判断前缀区间 $[1,i]$ 中的数的最大值是否就是 $i$ 即可，详情请看代码。
## Code
```cpp
int p[1000007];

int main() {
	MT {
		int n = Rint, maxi = 0,  ans = 0, l = 1;
		F(int, i, 1, n) {
			p[i] = Rint, maxi = max(maxi, p[i]);
			if(maxi == i) ans += (i - l + 1 != 1) * (i - l + 1), l = i + 1; //这里将 (i - l + 1 != 1) 当做一个 0/1 值，可以省略掉一个 if
		}
		println(ans1);
	}
	return 0;
}
```

---

## 作者：Level_Down (赞：9)

## 题目简介：

给定一个含 $n$ 个数的数组，你每次可以将一个区间 $[l,r]$ 正序排列并且所要花的代价为 $r - l + 1$，问将这个数组正序排列所要花的代价最小是多少。

## 分析：

我们可以运用转换的思路，想要花的代价越少那么必须要得出那些不需要被排列的数有几个，然后我们可以得出这些数得具有以下特性：

> 1. 所在的位置和全数组正序排列后的位置相同。

> 2. 在原数组中在这个数之前的数不能再排列后跑到这个数后面。

根据这两个特性，我们可以想出一种方法：

遍历原数组，遇到某一个数与排列后的位置不同且未被标记（指在排列后的数组的这个位置之前没有出现过），继续从这个位置的排列后的数组中遍历，找到这个数在排列后的数组中的位置，并将沿途的数都标记一遍，表示其已经出现过。

于是找到这个数之后，我们可以知道在这个数的原位置和现在这个位置之中是绝不会有具有上述特性的数的，故将原指针拖到现在这个位置继续遍历，重复上述操作。

并且在原数组中遍历时，如果遇到某数与同位置的排列后的数组一样并且没有被标记过，那么可以认定这个数就是我们要找的数，并且将这种数的数量记录下来，最后只要输出总数 $n$ 和这种数的数量之差即可。

没看懂的看代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n,a[1000005],b[1000005],c[1000005],sum;
//a数组是原数组，b数组是排列后的数组，c数组是标记。 
signed main()
{
	cin >> T;
	while(T--)
	{
		cin >> n;
		sum = n;
		for (int i = 1; i <= n; i++)
			{
				cin >> a[i];
				b[i] = a[i];
				c[i] = 0;//别忘了初始化。 
			}
		sort(b + 1,b + 1 + n);
		for (int i = 1; i <= n; i++)
			{
				if (a[i] != b[i] && c[a[i]] == 0)//遇到某一个数与排列后的位置不同且未被标记时的操作。 
					{
						for (int j = i; j; j++)
							{
								c[b[j]] = 1;//标记。 
								if (b[j] == a[i]) break;
							}
					} else
				if (a[i] == b[i] && c[a[i]] == 0) {sum--;continue;}	//记录所需数。 
			}
		cout << sum << endl;	
	}
	return 0;
}

```

没看懂的可以在评论区问，~~也可以来喷我。~~

希望对大家有帮助。

---

## 作者：__gcd (赞：7)

小清新。

答案是区间长度的和，不妨考虑单点的答案的贡献。

* 引理 $1$：单点的贡献只有可能是 $1$。
	
    证明：单点贡献大于 $1$ 当前仅当有至少两个排序区间覆盖了它，那么排序这两个区间的并显然是更优的。

接下来我们考虑什么时候一个单点有贡献。

* 引理 $2$：一个位置 $i$ 有贡献的充分必要条件为在 $i$ 之前存在大于 $i$ 的数或在 $i$ 之后存在小于 $i$ 的数（之前和之后均包括 $i$ 本身）

 	证明：首先证明充分性。经过排序后一个数只会在排序区间之间移动，那么这个数为了移动到 $i$ 后面的位置，其区间一定包括 $i$。证毕。
    
    其次证明必要性。考虑证明逆否命题。若在 $i$ 位置不存在满足如上两个条件的数，则 $[1,i-1]$ 所包含的数的集合为 $[1,i-1]$，$[i+1,n]$ 所包含的数的集合为 $[i+1,n]$，故 $i$ 上的数一定为 $i$ 本身。所以对于任何一个跨过 $i$ 的区间 $[l,r]$，它一定可以拆分成 $[l,i-1]$ 和 $[i+1,r]$ 两个区间，容易发现排序是等效的。证毕。

对于上面的结论从前往后和从后往前扫一遍即可。时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
using namespace std;
inline int read() {
	int x = 0; bool op = false;
	char c = getchar();
	while(!isdigit(c))op |= (c == '-'), c = getchar();
	while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return op ? -x : x;
}
const int N = 1000010;
int n;
int a[N], vis[N];
int main() {
	int test = read();
	while(test--) {
		int n = read();
		for(int i = 1; i <= n; i++)vis[i] = 0;
     	// 千 万 别 用 memset
		for(int i = 1; i <= n; i++) {
			a[i] = read();
		}
		for(int i = 1, mx = 0; i <= n; i++) {
			mx = max(mx, a[i]);
			if(mx > i)vis[i] = 1;
		}
		for(int i = n, mn = n + 1; i; i--) {
			mn = min(mn, a[i]);
			if(mn < i)vis[i] = 1;
		}
		int ans = 0;
		for(int i = 1; i <= n; i++)ans += vis[i];
		printf("%d\n", ans);
	}	 
	return 0;
}	
```


---

## 作者：orz_z (赞：3)

## 题目大意
给你一个序列 $a$ , 选择排列中的任意一段区间 $[l,r]$，求将序列 $a$ 从小到大排序最少需要排序多少个数。
## 解题思路
每次输入一个数 $x$ ，将其与当前遍历的编号 $i$ 求最大和最小值。

再用一个差分数组，将区间 $[mmin,mmax]$ 整体加 $1$，说明这个区间需要排序。
## AC CODE
```cpp
#include <bits/stdc++.h>
#define max(a,b) a > b ? a : b
#define min(a,b) a > b ? b : a
#define int long long
using namespace std;

int T, n, ans;
int a[200010];

int maxn, minn;

signed main()
{
	cin >> T;
	while(T--)
	{
		cin >> n;
		maxn = 0;
		minn = INT_MAX;
		for(int i = 1;i <= n;i++) a[i] = 0;
		for(int i = 1;i <= n;++i)
		{
			int x;
			cin >> x;
			if(x == i) continue;
			minn = min(i,x);
			maxn = max(i,x);
			a[minn]++;
			a[maxn + 1]--;
		}
		ans = 0;
		for(int i = 1;i <= n;++i)
		{
			a[i] += a[i - 1];
			if(a[i]) ans++;
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：Maxmilite (赞：2)

赛时我的代码加上卡常勉勉强强把最大的数据点时间控制在 975 ms，不大清楚是不是正解，这里把思路分享一下。

我们考虑一下什么时候需要对一段区间进行排序。

对一个元素 $p_i$，如果 $p_i \neq i$，那么我们需要找到元素 $p_j=i$，然后将两个元素及之间的全部元素都调换顺序，这样才有可能将元素 $p_j = i$ 放到正确的位置 $p_i$ 上。

不妨设 $i < j$，那么对于 $p_i$ 和 $p_j = i$，我们要把 $[i, j]$ 之间的元素全部调换，需要的花费是 $j - i + 1$。

所以我们只需要扫描一遍数组 $p$，标记以下哪一些元素及之间的全部元素需要调换顺序，统计一下就是答案了。

对于多测的一个小 Trick 是，我们统计哪一些元素已经被换过顺序用的 `vis` 数组，在测试组数很多且数据规模很小的时候如果用 `memset` 函数需要耗费大量时间，所以我们在标记的时候，可以考虑对第 $i$ 组测试就用数字 $i$ 来标记。这样就省下了用 `memset` 的时间。

具体可以参看这一段代码段：

```cpp
for (register int j(i); j <= a[i]; ++j)
{
	if (vis[j] != x)
		++ans;
	vis[j] = x;
}
```

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[1000005];
int vis[1000005];
int ans = 0;

inline int read()
{
    int xx = 0;
    char ch = getchar();
    while (!isdigit(ch))
        ch = getchar();
    while (isdigit(ch))
        xx *= 10, xx += ch - 48, ch = getchar();
    return xx;
}

void solve(int x)
{
	scanf("%d", &n);
	ans = 0;
	for (register int i(1); i <= n; ++i)
	    a[i] = read();
	for (register int i(1); i <= n; ++i)
	{
		if (i >= a[i])
			continue;
		for (register int j(i); j <= a[i]; ++j)
		{
			if (vis[j] != x)
				++ans;
			vis[j] = x;
		}
	}
	printf("%d\n", ans);
	return;
}

int main()
{
	int t;
	scanf("%d", &t);
	for (int i(1); i <= t; ++i)
		solve(i);
	return 0;
}
```

---

## 作者：rfsfreffr (赞：1)

~~看到这道题的第一反应是归排~~

结果实际这道题和归排关系不大，显然答案肯定小于等于 $n$，如果我将所有元素一次性排序，所需的花费就是 $n$。

记 $p_k=k$ 的是有序元素， $p_k!=k$ 的是乱序元素

于是我们可以先找到最左边的和最右边的乱序元素，如果将中间的所有进行排序，花费就是 $r-l+1$，得到较优解。

但显然这不一定是最优解

比如我们先找到所有已经有序元素，记为 $a_1,a_2,a_3,....a_k$ ， 同时设 $a_0=0 ,a_{k+1}=n+1$	

在 $[l,r]$ 这个区间内，如果存在一个区间$[a_x,a_{x+1}]$ ,其中所有元素都大于 $a_x$ 并且小于 $a_{x+1}$ 在排序的时候就可以只排序 $[a_x+1,a_{x+1}-1] $，先比在排序 $[l,r]$ 时同时将 $[a_x,a_{x+1}]$ 都排序来说的花费更小。


# std 
```cpp
#include<bits/stdc++.h>
//#include<windows.h>
using namespace std;

int t;
int n;
int a[1000001];
int sum[1000001],k=0;
int fa=0; 
int main() {
	cin>>t;
	while(t--) {
		fa++;
		scanf("%d",&n);
		k=0;
		sum[0]=0;//初始化
		for(int i=1; i<=n; i++) scanf("%d",&a[i]);
		int ans=n,l=n,r=1;
		for(int i=1; i<=n; i++) {
			if(a[i]!=i) {//找到l和r
				if(i<l) l=i;
				if(i>r) r=i;
			} else {
				sum[++k]=i;
			}
		}
		if(l==n&&r==1) {//如果没有l和r，说明数列已经有序,输出0
			printf("0\n");
			continue;
		}
		sum[k+1]=n+1
		ans=r-l+1;
		for(int i=0; i<=k; i++) {
			int f=0;
			if(sum[i]+1>sum[i+1]-1) continue; //如果这两个有序元素连在一起就不用判断了
			for(int j=sum[i]+1; j<=sum[i+1]-1; j++) {//遍历
				if(!(sum[i]<a[j]&&a[j]<sum[i+1])) {
					f=1;
					break;
				}
			}
			if(f==0&&i!=k&&i!=0&&k!=2) ans--;//一些特判和f的判断
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
时间复杂度$O(n)$

---


# [HAOI2012] 音量调节

## 题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

## 说明/提示

$1\le n\le 50$，$1\le c_i\le beginLevel$，$1\le maxLevel\le 1000$，$0\le beginLevel\le maxLevel$。

## 样例 #1

### 输入

```
3 5 10
5 3 7
```

### 输出

```
10```

# 题解

## 作者：jackyzhu (赞：100)

到达型的01背包问题

f[i][j]:前i首歌曲能否达到音量j,f[i][j]=0不能达到,f[i][j]=1表示可以达到

音量调高表示取第i件物品，音量调低表示不取第i件物品

音量为背包容量，01背包模板题（调高调低带约束）

初始条件：f[0][beginlevel]=1,没演奏前可以到达beginlevel









```cpp
#include<bits/stdc++.h>
using namespace std;
int n,begin,maxlevel;
int ans;
int a[51];
int f[51][1001];
int main()
{
    scanf("%d%d%d",&n,&begin,&maxlevel);
    f[0][begin]=1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++)
        for(int j=maxlevel;j>=0;j--)
        {
            if(j-a[i]>=0)
                f[i][j]=f[i][j]||f[i-1][j-a[i]];
            if(j+a[i]<=maxlevel)
                f[i][j]=f[i][j]||f[i-1][j+a[i]];
        }
    for(int i=maxlevel;i>=1;i--)
        if(f[n][i]==1)
        {
            printf("%d",i);
            return 0;
        }
    printf("-1");
    return 0;
}

```

---

## 作者：Sleepy_Piggy (赞：58)

二维dp。。

如果调高不超过最大音量，调低不低于0，就把这个状态设为true（一开始全部设为false）

上代码



```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,st,maxn,a[1001],f[1001][1001];
int main(){
    scanf("%d%d%d",&n,&st,&maxn);
    memset(f,0,sizeof(f));//初始化为false
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    f[0][st]=1;//一开始的是true
    for(int i=1;i<=n;i++){
        for(int j=0;j<=maxn;j++){
            if(f[i-1][j]&&j+a[i]<=maxn) f[i][j+a[i]]=1;//调大不超过最大
            if(f[i-1][j]&&j-a[i]>=0) f[i][j-a[i]]=1;//调小不低于0
        }
    }
    for(int i=maxn;i>=0;i--){//找最后能达到的最大音量
        if(f[n][i]){
            printf("%d\n",i);//找到就输出
            return 0;//找到了就终止程序，不用再找
        }
    }
    puts("-1\n"); //找不到
}

```

---

## 作者：attack (赞：21)

这是我有史以来第一次秒掉省选题，

这应该是某种背包问题

用dp[i][j]表示对于第i次操作，音量为j是否是可行的。

楼下的做法都挺不错，但是动规的时候判断条件不需要那么繁琐

而且不需要预处理。

直接在最后倒序判断一下就好


```cpp
#include<cstdio>
#include<algorithm>
const int MAXN=2001;
inline void read(int &n)
{    char c=getchar();n=0;bool flag=0;    while(c<'0'||c>'9')    c=='-'?flag=1,c=getchar():c=getchar();
    while(c>='0'&&c<='9')    n=n*10+c-48,c=getchar();flag==1?n=-n:n=n;}
int dp[MAXN][MAXN];
int n,beginlevel,maxlevel;
int change[MAXN];
int main()
{
    read(n);read(beginlevel);read(maxlevel);
    for(int i=1;i<=n;i++)    read(change[i]);
    dp[0][beginlevel]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=maxlevel;j++)
            if(dp[i-1][j])    dp[i][j+change[i]]=1,dp[i][j-change[i]]=1;
    for(int i=maxlevel;i;i--)    if(dp[n][i])    printf("%d",i),exit(0);
    printf("-1");
    return 0;
}
```

---

## 作者：HighPerformanceRobot (赞：18)

## 音量调节

作为蒟蒻的我，一开始看到这题想的都是什么搜索，结果暴力打上去一看TLE四个点。。然后~~我作弊加了#pragma GCC optimize（3），最后MLE四个点，而且还是原来那四个TLE的点。~~啊啊啊，BFS都不能过，你们让不让人活？

好吧，暴力BFS的60分做法程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int now,state;		//当前次数标记，当前音量值
	node(int a,int b)
	{
		now=a,state=b;
	}
};
queue <node> que;		//BFS队列
int beginlev,maxlev;	//初始音量，最大音量
int c[52];
int n,ans;
void bfs(int x)
{
	int step=que.front().now;		//标记当前的步数
	while(que.front().now==step)	//避免做过了头
	{
		if(que.front().state+x<=maxlev)
			que.push(node(que.front().now+1,que.front().state+x));
		if(que.front().state-x>=0)
			que.push(node(que.front().now+1,que.front().state-x));
		que.pop();
	}
}
void all()				//统计函数
{
	while(!que.empty())
		ans=max(ans,que.front().state),que.pop();
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>beginlev>>maxlev;
	que.push(node(1,beginlev));
	for(int i=0; i<n; i++)
		cin>>c[i];
	int i=0;
	while(!que.empty()&&i<n)
		bfs(c[i]),i++;
	all();
	if(ans)		//有修改过
		cout<<ans<<endl;
	else
		cout<<-1<<endl;
	return 0;
}
```

然后就悲剧了。。

让我们再来研究一下，看看有没有可以优化的地方？

#### 重点来了！

我们可以发现，这种BFS常常会有同样的状态，也就是同样的音量，然而在该批状态中（now相等的状态），同样的state（音量）是没用的。那怎么办？

我们可以开一个bool数组，判断当前的值是不是已经进入过队列了。

~~于是这题被轻松AC了。。~~

来来来stick code：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int now,state;
	node(int a,int b)
	{
		now=a,state=b;
	}
};
queue <node> que;
int beginlev,maxlev;
int c[52];
int n,ans;
void bfs(int x)
{
	bool f[1001];
	int step=que.front().now;
	fill(f,f+maxlev+1,0);
	while(que.front().now==step)
	{
		if(que.front().state+x<=maxlev&&!f[que.front().state+x])
		{
			que.push(node(que.front().now+1,que.front().state+x));
			f[que.front().state+x]=1;
		}
		if(que.front().state-x>=0&&!f[que.front().state-x])
		{
			que.push(node(que.front().now+1,que.front().state-x));
			f[que.front().state-x]=1;
		}
		que.pop();
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>beginlev>>maxlev;
	que.push(node(1,beginlev));
	for(int i=0; i<n; i++)
		cin>>c[i];
	int i=0;
	while(!que.empty()&&i<n)
		bfs(c[i]),i++;
	while(!que.empty())
		ans=max(ans,que.front().state),que.pop();
	if(ans)
		cout<<ans<<endl;
	else
		cout<<-1<<endl;
	return 0;
}
```

嗯，差不多结束了。~~反正我不想死磕DP正解~~

这题的真正的做法是DP，具体做法我就不说了，楼下dalao都是DP。。

DP版code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,beginlev,maxlev;
int f[1001][1001];
int c[1001];
int main()
{
	cin>>n>>beginlev>>maxlev;
	for(int i=1; i<=n; i++)
		cin>>c[i];
	f[0][beginlev]=1;
	for(int i=1; i<=n; i++)
		for(int j=0; j<=maxlev; j++)
		{
			if(f[i-1][j]&&j+c[i]<=maxlev)
				f[i][j+c[i]]=1;
			if(f[i-1][j]&&j-c[i]>=0)
				f[i][j-c[i]]=1;
		}
	for(int i=maxlev; i>=0; i--)
		if(f[n][i])
		{
			cout<<i<<endl;
			return 0;
		}
	cout<<-1<<endl;;
	return 0;
}
```


---

## 作者：傅思维666 (赞：16)

## 能在省选题库中找到橙题真的是缘分。
动态规划的背包问题。

但是如果把这道题强行理解为01背包未免有些和01背包的概念不符，其实这道题是**到达性的01背包**。

我们可以不把这道题想象的那么复杂，直接按照最基础的动态规划来，设置动态转移方程和初值。

这回我们用标记数组来动归。

设状态转移方程f[i][j]为第i首歌能否达到j的音量，能为1，不能为0。

这样的话我们就可以开始动归，最后只需要枚举出最大的f[n][i]，就是需要找的答案了。

这里还需要注意，初值f[0][begin]要设置为1，因为没开始之前就可以达到begin的音量。

很好理解。
就把它算01背包吧！！

PS：这里还想给大家一个建议，begin就写begin，不要弄什么b,be,beg，假如有一道题，需要很多的、各种各样的、表示不同意义的变量，你这么写写着写着就懵圈了，不知道这个变量表示什么意义~~（记忆力爆表的当我没说）~~，所以就可以考虑一切变量都设置为英文单词，不会英文的话用全拼也行...

AC CODE:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,beginlevel,maxlevel;
int c[60];
int f[60][1010];
int main()
{
    scanf("%d%d%d",&n,&beginlevel,&maxlevel);
    for(int i=1;i<=n;i++)
        scanf("%d",&c[i]);
    f[0][beginlevel]=1;
    for(int i=1;i<=n;i++)
        for(int j=maxlevel;j>=0;j--)
        {
            if(f[i-1][j] && j+c[i]<=maxlevel)
                f[i][j+c[i]]=1;
            if(f[i-1][j] && j-c[i]>=0)
                f[i][j-c[i]]=1;
        }
    for(int i=maxlevel;i>=0;i--)
        if(f[n][i]==1)
        {
            printf("%d",i);
            return 0;
        }
    printf("-1");
    return 0;
}
```


---

## 作者：AMYHYY_ (赞：10)

~~终于记得写题解了~~


------------
这是一道典型的**01背包题**

这里定义的二维数组p代表第i首歌所能达到的音量j

背包背完之后倒序找最大能达到的音量，找到了输出之后结束就好啦


------------
真的不难，看代码~~琢磨一会儿~~就知道啦
```
#include<bits/stdc++.h>
using namespace std;
int c[10010]；
bool p[100][1050];
int main()
{
	int n,bel,mal;
	cin>>n>>bel>>mal;
	for(int i=1;i<=n;i++)
		cin>>c[i];
	p[0][bel]=1;//没有演出的时候开始音量一定是可以达到的
	for(int i=1;i<=n;i++)
	{
		for(int j=mal;j>=0;j--)
		{
			if(j-c[i]>=0)//音量最小可以到0
				p[i][j]=p[i][j]||p[i-1][j-c[i]];
			if(j+c[i]<=mal)//音量最大不超过最大音量就好了
				p[i][j]=p[i][j]||p[i-1][j+c[i]];
		}
	}
	for(int i=mal;i>=0;i--)//音量最小到0
	{
		if(p[n][i]==1)
		{//找到最大的可达到音量输出之后直接结束
			cout<<i<<endl;
			return 0;
		}
	}	
	cout<<"-1"<<endl;
	return 0;
} 
```

---

## 作者：一枚 (赞：8)

这个题呢其实是可以用bitset水过的。我们开一个1000位的bitset，第i位代表能否取到i这个值，再加上一些特判就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return f*x;
}
const int N=100010;
int n,st,mx;
bitset<1010> b;
bitset<1010> s;
int main()
{
	int tmp;
	n=read();st=read();mx=read();
	b.set(st);//初始音量位设为1
	for(int i=0;i<=mx;i++)s[i]=1;
	for(int i=1;i<=n;i++){
		tmp=read();
		b=((b>>tmp)|(b<<tmp));//左移代表加，右移代表减
		b&=s;//确保只有在0位~最大音量位是有值的
		if(b.none()){//可行范围内若无1，即取不到可行值，直接return
			puts("-1");
			return 0;
		}
	}
	while(mx>=0&&b[mx]==0)mx--;//找可行最大音量
	if(mx<0)puts("-1");
	else printf("%d\n",mx);
	return 0;
}
```

---

## 作者：寒冰大大 (赞：5)

# 一个入门的背包

但是区别于普通的背包，这个背包可以同时加（或者）减。

### 解决方案1
每个$a[i]$ 转化为两个 $a[i]于-a[i]$ 这时候就可以用原来的动态转移方程了，注意判断就好了

### 解决方案2
改写dp方程 
考虑$f[i]$的来源

$ f[i][j]= \begin{cases} f[i-1][j-a[i]] \ \ \quad \\ f[i-1][j+a[i]]\end{cases}$

只要其中一个可以，那么$f[i][j]$也可以

接下来就是一些特判了

同时不难发现$f[i]$只与$f[i-1]$有关，因此我们可以滚动数组优化空间
（每次循环前记得把要用的滚动数组清空）
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<algorithm>

using namespace std;

int f[2][2020];
int a[2020];
int n,m,b;

int main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	cin>>n>>b>>m;
	f[0][b]=1;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(i=1;i<=n;i++)
	{
		for(j=m;j>=0;j--)
		{
			if(j-a[i]>=0&&j-a[i]<=m) if(f[(i-1)&1][j-a[i]]) f[i&1][j]=1;
			if(j+a[i]>=0&&j+a[i]<=m) if(f[(i-1)&1][j+a[i]]) f[i&1][j]=1;
		}
		for(j=0;j<=m;j++) f[(i-1)&1][j]=0;
	}
	int ans=-1;
	for(i=0;i<=m;i++)
	if(f[n&1][i]) ans=i;
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：magolor (赞：5)

避免动态规划，记忆化搜索逻辑清晰代码短小简单，效果强大






    

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 100
#define MAXV 2000
int c[MAXN+5], n, S, X;
int f[MAXN+5][MAXV+5];
int Robot(int p, int v)
{
    if(p == n+1)
        return v;
    if(f[p][v]+1)
        return f[p][v];
    int ans = -1;
    if(v-c[p] >= 0)
        ans = max(ans,Robot(p+1,v-c[p]));
    if(v+c[p] <= X)
        ans = max(ans,Robot(p+1,v+c[p]));
    return (f[p][v]=ans);
}
int main()
{
    scanf("%d%d%d",&n,&S,&X);
    for(int i = 1; i <= n; i++)
        for(int v = 0; v <= X; v++)
            f[i][v] = -1;
    for(int i = 1; i <= n; i++)
        scanf("%d",c+i);
    printf("%d\n",Robot(1,S));
    return 0;
}
```

---

## 作者：蔡俊黠 (赞：4)

运用背包的思想

设f[i][j]表示第i首歌能否到达音量j

怎么判断这首歌能到达音量j呢？取决于它前面的第i-1首歌能到达的音量和这首歌能调节的音量

如果在第i-1首歌的j音量的基础上上调或下调没有超过maxlevel并且大于0，那么就可以调节

注意一开始就可以把音量调为begin值（这里我用了st来表示）

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100],st,ed;
bool f[100][1010];
int main()
{
	scanf("%d%d%d",&n,&st,&ed);
	f[0][st]=true;
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    for (int i=1;i<=n;i++)
      for (int j=ed;j>=0;j--)
      {
    	if (j-a[i]>=0) f[i][j]=f[i][j]||f[i-1][j-a[i]];
    	if (j+a[i]<=ed) f[i][j]=f[i][j]||f[i-1][j+a[i]];
	  }
	for (int i=ed;i>=0;i--) 
	{
		if (f[n][i]==true) 
		{printf("%d\n",i);return 0;} 
	}
	printf("-1\n");
	return 0;
}
```


---

## 作者：LYFer (赞：4)

01背包问题是 一个物品拿或者不拿中求最大值的问题


这道题目就是 音量增加或者减少中求最大值的问题


但是如果生搬硬套01背包的方程用在这里肯定是不合适的。


在这里，我们想对于每次调节，也就是两种可能 在上次的基础上调大，或者是调小。但是调大不能超过上限，调小不能超过下限。


让我们再分析分析样例：


3 5 10

5 3 7

第一次调节 只能从 5开始 调小的话就是0 调大的话就是10


第二次调节 先分析0 调小不可以 调大只能是3  在分析10 调小是7 调大不可以


第三次调节 先分析3 调小不可以 调大是10 再分析7 调小是0 调大是不可以


是不是隐隐约约能摸索出这个转移方程了？


对没错，方程是 用二维bool型数组来DP，f[i][j]=true表示第i首歌音量为j可行，DP方程为：


if((f[i-1][j+c[i]]==true&&j+c[i]<=maxL)||(f[i-1][j-c[i]]==true&&j-c[i]>=0)) f[i][j]=true;

关键是f[i-1][j+c[i]] 和 f[i-1][j-c[i]]这两个，要仔细推敲。


初始值f[0][初始值]=1


最后再从大到小遍历 最后一次 调节时的最大值，如果存在输出。如果不存在则输出-1.

```cpp
#include <cstdio>
const int maxn=1005;
int n,m,MAX,c[maxn];
bool dp[maxn][maxn];
int main(){
    scanf("%d%d%d",&n,&m,&MAX);
    for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    dp[0][m]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=MAX;j++){
            if( (dp[i-1][j+c[i]] && j+c[i]<=MAX) || ( dp[i-1][j-c[i]] && j-c[i]>=0)) 
            dp[i][j]=1;
        }
    for(int i=MAX;i>=0;i--){
        if(dp[n][i]) {
            printf("%d\n",i);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```

---

## 作者：悠逸 (赞：2)

这是一道很好的**模拟题**（谁让TA数据范围小~~）

开个bool二维数组yin[i][j]，记录第i首歌第j音量能否到达，来帮助下面的数组去重

开个二维数组y[i][(音量)]来记录第i首歌能到达的**所有**音量，用s一维数组辅助记录个数

中途加个判断，该轮无可到达的合法音量，-1结束

最后搜一下最后一轮的最高音量，KO~~

~~（DP，考场上基本想不出的东西）~~

上AC代码（个人习惯风格~~）

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<cmath>

using namespace std;

bool yin[55][1010];//第i首歌第j音量能否到达 
int s[55];//第i首歌能到达的音量数 
int y[55][1010];//第i首歌能到达的音量
int c,n,b,m;

int main()
{
//	freopen("changingsounds.in","r",stdin);
//	freopen("changingsounds.out","w",stdout);
	cin>>n>>b>>m;
	
	//初始化 
	yin[0][b]=true;
	s[0]=1;
	y[0][1]=b;
	
	for (int i=1;i<=n;i++)
	    {
	    	cin>>c;
	    	
	    	for (int j=1;j<=s[i-1];j++)//上首歌能到达的音量 
	    	    {
	    	    	int x=y[i-1][j];//取出数来 
	    	    	
	    	    	int xx=x+c;//上调音量 
	    	    	if (xx<=m&&yin[i][xx]==false)//本次中不存在且符合条件 
	    	    	   {
	    	    	   	yin[i][xx]=true;
	    	    	   	s[i]++;
	    	    	   	y[i][s[i]]=xx;
	    	    	   }
	    	    	
	    	    	xx=x-c;//下调音量
	    	    	if (xx>=0&&yin[i][xx]==false)//本次中不存在且符合条件 
	    	    	   {
	    	    	   	yin[i][xx]=true;
	    	    	   	s[i]++;
	    	    	   	y[i][s[i]]=xx;
	    	    	   }
	    	    	
	    	    }
	    	
	    	if (s[i]==0)//本轮没有能到达的音量 
	    	   {
	    	   	cout<<-1<<endl;
	    	   	return 0;
	    	   }
	    	
	    	
	    }
	
	int a=0;//找出最后一轮最大音量即可 
	for (int i=1;i<=s[n];i++)
	    if (a<y[n][i])
	       a=y[n][i];
	
	cout<<a<<endl;
	
	
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：Kaizyn (赞：2)

注：本题受到大佬 **U21421 pantw** 在 **P2347 砝码称重** 解法启发


------------

需要掌握的知识：

**C++ STL bitset**

**位运算 &**

**位运算 |**


------------
注释代码
```cpp
#include <iostream>
#include <cstdio>
#include <bitset>

using namespace std;

const int Maxn = 1e3 + 7;

int n, begin_level, max_level;
bitset<Maxn> b, cut;

// b中存储音量i是否能达到
// 即：当某首歌唱完时 b[i] == 1 ==> 能达到音量i 
//                    b[i] == 0 ==> 不能达到音量i

int main()
{
	scanf("%d%d%d", &n, &begin_level, &max_level);
	// 开始时的音量
	b[begin_level] = 1;
	// 设置cut为[0, max_level] = 1，其余为0的东东
	for(int i = 0; i <= max_level; ++i) cut[i] = 1;
	// tmp 为当前歌的音量改变值
	for(int i = 0, tmp; i < n; ++i)
	{
		scanf("%d", &tmp);
		// 左移是音量降低了tmp个单位,右移就是升高tmp个单位
		// 按位或| 之后, b就变成了左移和右移一共可以达到的值
		b = (b << tmp) | (b >> tmp);
		// 当值 < 0 时bitset会自动溢出
		// 而当值 > max_level时，就需要手动去掉
		b &= cut;
	}
	// 倒着找能达到的最大值
	for(int i = max_level; i; --i)
	{
		if(b[i])
		{
			printf("%d\n", i);
			return 0;
		}
	}
	// 如果在[0, max_level]中找不到，则为题目中描述的无法避免情况
	printf("-1\n");
	return 0;
}

```


------------
简洁的代码, 二十四行相当棒( •̀ ω •́ )y
```
#include <cstdio>
#include <bitset>
using namespace std;
const int Maxn = 1e3 + 7;
int n, begin_level, max_level;
bitset<Maxn> b, cut;

int main()
{
    scanf("%d%d%d", &n, &begin_level, &max_level);
    b[begin_level] = 1;
    for(int i = 0; i <= max_level; ++i) cut[i] = 1;
    for(int i = 0, tmp; i < n; ++i){
        scanf("%d", &tmp);
        b = (b << tmp | b >> tmp) & cut;
    }
    for(int i = max_level; i; --i)
        if(b[i]) {
            printf("%d\n", i);
            return 0;
        }
    printf("-1\n");
    return 0;
}
```

---

## 作者：s_a_b_e_r (赞：2)

我有特殊的桶算法

奇迹一样的桶啊。。。

truee代表在[0,max]的一共的数量，如果是0，那么说明无法满足题意输出-1

tot是每一次转所共有的状态数；

把所有的状态压进桶里。遍历一遍桶就知道所有可以到达的状态；//可以少用很多空间；

转移前清空桶；之后就AC了

注意转移时0点，不要习惯性写for(int i=1;i<=max;i++);QAQ

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
short a[53];
bool tong[3000];
short dp[2000];
int ans;
int n,maxz,be;
void GSH(){
     for(int i=0;i<=maxz+9;i++)
     tong[i]=0;
}
int main(){
    cin>>n>>be>>maxz;
    for(int i=1;i<=n;i++){cin>>a[i];}
    dp[1]=be;tong[be]=1;
    for(int i=1;i<=n;i++){
    int tot=0,truee=0;
      for(int j=0;j<=maxz;j++){
       if(tong[j]==0);
       else{
       truee+=2;
       dp[tot]=j+a[i];
       dp[tot+1]=j-a[i];
       if(dp[tot]<0)truee--;
       if(dp[tot+1]>maxz)truee--;
       tot+=2;
       }
                      }
       if(truee==0)
       {cout<<"-1";
       return 0;
       }
       GSH();
       for(int j=0;j<tot;j++){
         if(dp[j]<0)continue;
         tong[dp[j]]=1;
       }
    }
    ans=-1;
    for(int i=0;i<=maxz;i++){
     if(tong[i])ans=i;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：早右昕 (赞：2)

####好喜欢滚动数组的样子(题解 By Plue Jheng/InfoEoR)

- 1.用BOOL来标记当前阶段可以达到的状态

- 2.最后从大至小查找可行状态,输出即可

- 3.用异或交换变量太爽了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,c,S,M,r=0,u=1;
bool f[2][1001];
int main()
{
    scanf("%d%d%d",&n,&S,&M);
    f[r][S]=true;
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&c);
        fill(f[u],f[u]+M+1,false);//记得清0
        for(int j=M-c; j>=0; j--) f[u][j]=f[u][j]|f[r][j+c];
        for(int j=M; j>=c; j--) f[u][j]=f[u][j]|f[r][j-c];
        u^=r^=u^=r;
    }
    for(int i=M; i>=0; i--)
        if(f[r][i])
        {
            printf("%d",i);
            return 0;
        }
    printf("-1");
}
```

---

## 作者：1saunoya (赞：1)

>此题与01背包不太类似。 但是这题就是完完全全的01背包。

>并不是要求出最大容量或者什么。

>而是求出来一个数字是否出现过。

>不妨我们开一个数组 dp

>来体现 这个数字是否出现过。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define rep(i,j,n) for(register int i=j;i<=n;i++)
using namespace std;
typedef long long LL;
inline LL read(){ LL x=0;int f(1);char ch=getchar();
	while(!isdigit(ch)) { if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar(); return x*f;
}

int n;
int Begin,Max;
int a[1<<6];
int dp[1<<6][1<<12];
signed main(){
	memset(dp,0,sizeof(dp));//初始化
	n=read(); Begin=read(); Max=read();//读入
	dp[0][Begin]=1;
	rep(i,1,n) a[i]=read(); 
	rep(i,1,n) rep(j,0,Max)  {//dp
		if (j+a[i] <= Max) dp[i][j]=dp[i][j]||dp[i-1][j+a[i]];//判断范围 如果没有超过 max 就可以dp
		if (j-a[i] >= 0)   dp[i][j]=dp[i][j]||dp[i-1][j-a[i]];//同理
	}
	LL ans = -0x7f;
	for(register int i=1;i<=Max;i++) {
		if(dp[n][i]) ans = i;//因为大小具有单调性。 不需要 max 只需要直接 ans = i ;
	}
	if ( ans != -0x7f) cout << ans << endl ; // 如果出现 。
	else puts("-1") ; //没有出现则输出 -1 
	return 0;
}
```

---

## 作者：荣一鸣 (赞：1)

这种题目，看看就知道是背包了

我们用f[x][y]来表示选到第x个的时候，音量y可不可取，那么显然f[0][beginsound]=1;

我们就可以用01背包来做这道题，只不过有0，-1，1三种

```
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,begin,maxn;
int c[51];
int dp[51][1010];
int ans=-1;

int main(){
	cin>>n>>begin>>maxn;
	for(int i=1;i<=n;i++) cin>>c[i];
	dp[0][begin]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=maxn;j++){
			if(dp[i-1][j]){
				if(j+c[i]<=maxn){
					dp[i][j+c[i]]=1;
				}
				if(j-c[i]>=0){
					dp[i][j-c[i]]=1;
				}
			}
		}
	}
	for(int j=maxn;j>=0;j--){
		if(dp[n][j]){
			ans=j;
			break;
		}
	}
	cout<<ans;
}
```

---

## 作者：faker121 (赞：1)

经典的dp题 话说这种难度真的是省选吗。。。

用最简单的思路 裸做吧

定义bool数组bo[i][j] 表示到第i首歌的时候 音量j可不可以达到

预处理 注意不要偷懒直接写递推式 如果音量<0会出错

我只每次特判 大佬有更好的解决方案请勿喷

最后从最大开始扫 输出bo为1的

到0都没有就-1

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,bgl,maxl;
int c[60];
bool bo[60][1010];
int main()
{
    scanf("%d%d%d",&n,&bgl,&maxl);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
    }
    if (bgl+c[1]<=maxl)
    {
        bo[1][bgl+c[1]]=1;
    }
    if (bgl-c[1]>=0)
    {
        bo[1][bgl-c[1]]=1;
    }
    for (int i=2;i<=n;i++)
    {
        for (int j=0;j<=maxl;j++)
        {
            if (bo[i-1][j]==1)
            {
                if (j+c[i]<=maxl)
                {
                    bo[i][j+c[i]]=1;
                }
                if (j-c[i]>=0)
                {
                    bo[i][j-c[i]]=1;
                }
            }
        }
    }
    for (int i=maxl;i>=0;i--)
    {
        if (bo[n][i]==1)
        {
            printf("%d",i);
            return 0;
        }
    }
    printf("-1");
}
```

---

## 作者：封二少 (赞：1)

2维DP
f[i][j] = 1 表示第i首歌的音量为j是可行的

动态转移方程是f[i][j] = ((f[i - 1][j + c[i]] && j + c[i] <= Max) || (f[i - 1][j - c[i]] && j - c[i] >= 0))

由i - 1的状态加上条件来判断f[i][j]状态是否可行

如果j + c[i] > Max 就不能上升音量

如果j - c[i] < 0 就不能下降音量

最后遍历一遍f[n][i]，输出最大的i使f[n][i] = 1;

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n, begin, Max, f[1001][1001], a[1001];
inline int get()
{
    char ch;
    int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch != '-')
      res = ch - '0';
    char c;
    while ((c = getchar()) >= '0' && c <= '9')
      res = (res << 3) + (res << 1) + c - '0';
    return ch == '-' ? ~res + 1 : res;
}
void put(int x)
{
    if (x < 0)
      putchar('-'), x = ~x + 1;
    if (x > 9) put(x / 10);
      putchar(x % 10 + '0'); 
}
int main()
{
    n = get(); begin = get(); Max = get();
    for (int i = 1; i <= n; ++i) a[i] = get();
    f[0][begin] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j <= Max; ++j)
      {
          int t1 = j - a[i], t2 = j + a[i];
          if (t1 >= 0 && f[i - 1][t1] == 1) f[i][j] = 1;
          if (t2 <= Max && f[i - 1][t2] == 1) f[i][j] = 1;
      }  
    for    (int i = Max; i >= 0; --i)
      if (f[n][i] == 1)
      {
            put(i);
            return 0;
      }
    put(-1);
}

```

---

## 作者：庸人 (赞：1)

看到没有c的题解就来一发

```cpp
#include<cstdio>
bool z[55][1111]={0};//z[i][j]的意思是第i次调完声音的大小为j； 
int x[55];
int main(){
    int begin,n,max,i,j;
    scanf("%d%d%d",&n,&begin,&max);//输入不解释  
    for(i=1;i<=n;i++) scanf("%d",&x[i]);//输入不解释  
    z[0][begin]=1;//第0次调声音的声音的大小 
    for(i=1;i<=n;i++){
        for(j=0;j<1111;j++){
            if(z[i-1][j]==1){
                if((j+x[i])<=1000&&(j+x[i])<=max) z[i][j+x[i]]=1;//注意！！(j+x[i])<=max这个千万不能少  
                if((j-x[i])>=0) z[i][j-x[i]]=1; //这个是否判断max就无所谓了 
            }
        }
    }
    for(i=max;i>=0;i--){//从max开始找到0 
        if(z[n][i]==1){//找到就输出 
            printf("%d",i);
            return 0;//直接结束程序 
        } 
    }
    printf("-1");//要是前面没有return 0就是说明没有找到所以输出-1 
    return 0;
}
```

---

## 作者：ArnoD (赞：1)

100分算法动态规划，很简单

用一个二维数组一开始先把a[0]里的beginlevel所在位置打上勾，然后往下推，只要符合要求的也打上勾，最后在第n行找出最大的max，max就是答案

下面贴代码：

```delphi

var
  n,bl,ml,i,j:longint;
  b:array[1..50] of longint;
  a:array[0..50,0..1000] of boolean;//这就是那个二维数组，注意下标开到零
begin
  readln(n,bl,ml);
  a[0,bl]:=true;//beginlevel先标记
  for i:=1 to n do
    read(b[i]);
  readln;
  for i:=0 to n-1 do
    for j:=0 to ml do
      if a[i,j] then//当前音量有没有标记，有就进入if
      begin
        if j+b[i+1]<=ml then
          a[i+1,j+b[i+1]]:=true;
        if j-b[i+1]>=0 then
          a[i+1,j-b[i+1]]:=true;
      end;//添加新标记
  for i:=ml downto 1 do
    if a[n,i] then
    begin
      writeln(i);
      halt;
    end;//最后一行找max，我用了downto
  writeln(-1);//找不到就输出-1
end.

```

---


# [SDOI2007] 立体分割

## 题目描述

Ghy收了 $n$ 个小弟,如 Psf、Hf、Csr、Ll……也当然包括你啊。（原文如此……）

可是身为大哥的他从来不像小弟索要什么，反而经常给小弟分发礼物。

一天他得到了 $1$ 个长方体形状的蛋糕。但是Ghy并不喜欢吃蛋糕，所以他要把蛋糕全部分给小弟们。Ghy认为所有小弟是平等的，所以找来小弟你，让你把这个蛋糕分成 $n$个大小和形状都相等的长方体小蛋糕（即全等的小蛋糕）。

我们把蛋糕搬到一个三维坐标系里，以它的一个顶点 $O$ 为坐标原点 $(0,0,0)$。另一个与 $O$ 点相对的顶点(就是离 $O$ 点最远的点)的坐标 $(x,y,z)$。其实 $x,y,z$ 就表示了长方体的长、宽、高。

## 说明/提示

### 样例解释（2023.9.29 管理员补充）

![](https://cdn.luogu.com.cn/upload/image_hosting/o4lfzlmr.png)

### 数据范围及约定

对于 $100\%$ 的数据，$1\leq x,y,z,n\leq 1000$，$x,y,z$ 为整数。

## 样例 #1

### 输入

```
2 3 2 6```

### 输出

```
0 0 0 1 1 2
1 0 0 2 1 2
0 1 0 1 3 1
0 1 1 1 3 2
1 1 0 2 3 1
1 1 1 2 3 2```

# 题解

## 作者：Metaphysical (赞：5)

# P2459 [SDOI2007] 立体分割 题解

## 题目传送门 | Portals

[P2459 [SDOI2007] 立体分割](https://www.luogu.com.cn/problem/P2459)

---

## 题意归纳 | Title

把长宽高的分别为 $x,y,z$ 的立方体分成 $n$ 份，使每份体积相等。

## 题目分析 | Analyse

由于题目中说了：“每行 $6$ 个**实数**”。  
所以我们可以平均分长、宽或高。

## 解题思路 | Thinking

我写的是平均分高。

先用 $s$ 记录每行之间的距离，层数为 $i$，每加一层就输出那一层左上点与右下点的位置：
- 左上点：$(0, 0, i \times s)$
- 右下点：$(x, y, (i - 1) \times s)$。

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstdio>
#include <math.h>
#include <cmath>

using namespace std;

double x, y, z, n;

int main ()
{
	scanf ("%lf%lf%lf%lf", &x, &y, &z, &n);
	double s = z / n;
	for (double i = 1; i <= n; i ++) 
	{
		printf ("0 0 %.10lf ", (i - 1) * s);
		printf ("%.10lf %.10lf %.10lf\n", x, y, i * s);
	}
	return 0;
}
```

---

## 作者：rainbow_cat (赞：2)

按照高度平均切就行，具体来说，第 $i$ 块蛋糕的两个顶点位于 $(0,0,(i-1) \times \frac{z}{n})$ 和 $(x,y,i \times \frac{z}{n})$。
```cpp
#include<bits/stdc++.h>
using namespace std;
long double x,y,z,n,now;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>x>>y>>z>>n;
	for(int i=1;i<=(int)n;i++)
	{
		now+=z/n;
		cout<<fixed<<setprecision(10)<<"0 0 "<<now-z/n<<' '<<x<<' '<<y<<' '<<now<<'\n';
	}
	return 0;
}
```

---

## 作者：huangzhixia (赞：2)

## 题解
### 题意

我们有一个长方体的蛋糕，现在我们要把那个蛋糕分成 $n$ 个大小和形状都相等的长方体小蛋糕。

再把我们的蛋糕搬进一个三位坐标系里，现在我们有一个点 $O$，为坐标原点 $(0, 0, 0)$。另一个点则是离 $O$ 的最远的一个点。

现在我们要求分割成的全等长方体小蛋糕的两相对顶点的坐标。

### 思路

一道**模拟题**，要**仔细按照题目中的要求**模拟。

做这道题需要思考以下几点：

- 把我们的长方体蛋糕按照任意一个平面给切开，长方体就变成了两块。

- 继续将割出来的蛋糕按照任意一个平面切开，一直切啊切，直到我们切出了 $n$ 块蛋糕。我们的蛋糕体积要相等。

- 那我们该怎么切开一个长方体，使其分为两块呢？我们要去遍历 $x,y,z$ 轴。

- 可以从前往后去遍历 $x$ 轴，再从上至下去遍历 $y$ 轴，再从左到右去遍历 $z$ 轴。枚举所有方案的过程中，把枚举的方案的体积记下来。最后选择其中体积最接近 $1/n$ 的方案就可以啦！


### Code:

```c
#include <bits/stdc++.h>

using namespace std;

const double p1 = 1e-10;

const int p2 = 101;

int x, y, z, n;

double s;

struct Info {
    double x1, x2, y1, y2, z1, z2; 
};

Info s1[p2], s2[p2];

inline double bala(Info u){
    return (u.x2 - u.x1) * (u.y2 - u.y1) * (u.z2 - u.z1);
}

inline bool ok(double curv) {
    int cnt = 0;
    for (int i = 0; i < x; i++)
        for (int j = 0; j < y; j++)
            for (int k = 0; k < z; k++) {
                double cz = max(p1, (s1[cnt].z2 - s1[cnt].z1) * k / z - s1[cnt].z1);
                double cy = max(p1, (s1[cnt].y2 - s1[cnt].y1) * j / y - s1[cnt].y1);
                double cx = max(p1, (s1[cnt].x2 - s1[cnt].x1) * i / x - s1[cnt].x1);
                if ((curv + bala(s1[cnt])) > s + p1) 
					break;
                s2[cnt].x1 = s1[cnt].x1 + cx * (s1[cnt].x2 - s1[cnt].x1) / (double)x;
                s2[cnt].x2 = s1[cnt].x1 + (cx + 1) * (s1[cnt].x2 - s1[cnt].x1) / (double)x;
                s2[cnt].y1 = s1[cnt].y1 + cy * (s1[cnt].y2 - s1[cnt].y1) / (double)y;
                s2[cnt].y2 = s1[cnt].y1 + (cy + 1) * (s1[cnt].y2-s1[cnt].y1) / (double)y;
                s2[cnt].z1 = s1[cnt].z1 + cz * (s1[cnt].z2 - s1[cnt].z1) / (double)z;
                s2[cnt].z2 = s1[cnt].z1 + (cz + 1) * (s1[cnt].z2 - s1[cnt].z1) / (double)z;
                if (++cnt == n) 
					return true;
            }
    return false;
}

int main() {
    ios::sync_with_stdio(false); 
	cin.tie(0); 
	cout.tie(0);
    cin >> x >> y >> z >> n;
    s = x * y * z / (double)n;
    s1[0] = Info{0, (double)x, 0, (double)y, 0, (double)z};
    int c = 0; 
	double v = 0;
    while (true) {
        if (ok(v)) 
			break;
        c += 1; 
        v += bala(s1[0]); 
		double ic = v;
        for (int i = 0; i < c; i++) 
			ic += bala(s1[i + 1]) - bala(s1[i]);
        ic /= c + 1;
        for (int i = 0; i <= c; i++) {
            double l = i * ic, r = (i + 1) * ic;
            while (r - l > p1) {
                double m = (l + r) / 2;
                if (ok(v + m * (c + 1 - i))) 
					r = m;
                else 
					l = m;
            }
            v += r * (c + 1 - i);
        }
    }
    for (int i = 0; i < n; i++)
        printf("%.12lf %.12lf %.12lf %.12lf %.12lf %.12lf\n", s1[i].x1, s1[i].y1, s1[i].z1, s1[i].x2, s1[i].y2, s1[i].z2);
}
```



---

## 作者：Fuction12_ (赞：1)

## 题意
有一个正方体，将它等分为 $n$ 块，输出每一块的左下角坐标和右上角坐标。
## 思路
我们考虑这样的一个问题，有一个线段，将它分为 $n$ 段，该怎么分？

答案十分简单，直接在线段的 $n$ 等分点分割就好了。

那么我们再来考虑这样的一个问题：有一个正方形，将它分为 $n$ 段，该怎么分。

当 $n=4$ 时，有人可能想把它分成田字形，但是，如果将上题的线段搬到这里来，我们将会很容易发现另一种，并且是任意 $n$ 都通用的方案。（如图）

![](https://cdn.luogu.com.cn/upload/image_hosting/4xtl4c78.png)

我们再将正方形变为正方体，便可得到本题的解法。

![](https://cdn.luogu.com.cn/upload/image_hosting/k0goitdg.png)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double x,y,z,n;cin>>x>>y>>z>>n;
  //由于i从1开始，所以第i块的x就应该是(x/n)*(i-1)和(x/n)*i
	for(int i=1;i<=n;i++)printf("%.10lf 0 0 %.10lf %.0lf %.0lf\n",x/n*(i-1),x/n*i,y,z);
	return 0;
}
```

---

## 作者：sbh2012 (赞：1)

## 思路
既然要把一个长方体平分为 $n$ 份，那就竖着切 $n$ 个长方形，输出 $n$ 个长度为 $x / n$，宽度为 $y$，高度为 $z$ 的长方体即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double x,y,z,n;
	cin>>x>>y>>z>>n;
	for(int i=1;i<=n;i++){
		double x1=1.0*x/n*(i-1);
		double x2=1*x/n*i;
		printf("%.10lf 0 0 %.10lf %.10lf %.10lf\n", x1,x2,y,z);
	}
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：1)

考虑一种十分离谱的做法。

我们并没有必要研究复杂的切法，考虑很朴素的东西，先讲个故事。

## Story Time

我有一块蛋糕：
![](https://cdn.luogu.com.cn/upload/image_hosting/wathrc3q.png)
邻居家捣蛋鬼小孩给我切成了 $n$ 块：
![](https://cdn.luogu.com.cn/upload/image_hosting/3jx8h0oj.png)
但他有强迫症：
![](https://cdn.luogu.com.cn/upload/image_hosting/vz7n0wde.png)
他就帮我们做好了。

## 分析
熊孩子说了，横着**平均**切就行了，所以：

## Coding Time
```cpp
#include<bits/stdc++.h>
using namespace std;
int x, y, z, n;
int main(){
    cin >> x >> y >> z >> n;
    double h = 1.0 * z / n;
    int cnt = 0;//切到第几块
    for(int i = 1; i <= n; i ++){
        cout << 0 << " " << 0 << " ";
        printf("%.10lf ", h * cnt);//上次切到这了
        cout << x << " " << y << " ";
        printf("%.10lf", h * (++ cnt));
        cout << "\n";
    }
    return 0;
}
```

---

## 作者：LionBlaze (赞：0)

显然，我们可以横着把蛋糕切成 $n$ 块。比如样例中的蛋糕我们就可以这样切（拜谢 desmos）：

[![](https://s21.ax1x.com/2025/01/16/pEFya1x.png)](https://www.desmos.com/3d/kyfbtbe2aq)

所以，对于第 $i$ 块，最靠近原点的顶点坐标为 $\left(0,0,\dfrac{iz}{n}\right)$，而最远离原点的顶点坐标是 $\left(x,y,\dfrac{(i+1)z}{n}\right)$。$i$ 从 $0$ 开始。

注意到精度要求较高，我们可以使用 `long double` 并在输出时控制小数位数。

```cpp
#include <cstdio>

using namespace std;

int main()
{
    long double x, y, z;
    long long n;
    scanf("%Lf%Lf%Lf%lld", &x, &y, &z, &n);
    for(int i=0;i<n;i++)
    {
        // 其实不用这么多位，但是……
        printf("%.114Lf %.514Lf %.191Lf %.98Lf %.106Lf %.666Lf\n", (long double)0, (long double)0, i*z/n, x, y, (i+1)*z/n);
    }
    return 0;
}
```

---

## 作者：_Star_Universe_ (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P2459)
### 题意 & 思路
题目就是让我们把长、宽、高分别为 $x,y,z$ 的物体分成大小相等的 $n$ 份，观察题目后我们发现有多种切割方法，为了使需要求的值尽可能少，一些只要将一维的高平均分成 $n$ 份即可。

可以考虑用 $i$ 表示这是第几块蛋糕。显然，$(0,0,0)$ 上方（同一条竖线上）的点和 $(x,y,z)$ 下方（同一条竖线上）的点分别可表示为 $(0,0,\frac{(i-1) \times z}{n})$ 和 $(x,y,\frac{i\times z}{n})$。

[代码](https://www.luogu.com.cn/paste/3btx8eh4)不难，但是需要注意精度，保险起见尽量多定义浮点型的变量。

---

## 作者：gdz0214_and_zxb0214 (赞：0)

## 前言
此题有史以来最短代码！！！
## 题面
[P2459 [SDOI2007] 立体分割](https://www.luogu.com.cn/problem/P2459)
## 思路
此题要求平分蛋糕，那么，我们看到题目没有规定必须按整数分割，于是想到只分一维。(长，宽，高中的一个)

![](https://cdn.luogu.com.cn/upload/image_hosting/xv0ebqrz.png)

像上图，可按宽分。(分割线表示照此线分割，但图片仅能显示二维)

那么，答案就显而易见了。
## 代码
```cpp
#include<bits/stdc++.h>
int main(){
	double x,y,z,n;
	scanf("%lf%lf%lf%lf",&x,&y,&z,&n);
	for(double i=1;i<=n;i+=1.0) printf("%.10lf 0 0 %.10lf %.10lf %.10lf\n",x/n*(i-1.0),x/n*i,y,z);
}
```

---

## 作者：Ivan422 (赞：0)

简单做。

这题发现可以有小数的坐标，那就考虑切成千层蛋糕。

那么坐标就是 $(0,0,\frac{(i-1)\times z}{n})$ 到 $(x,y,\frac{i\times z}{n})$ 的蛋糕。这样，每个小朋友的蛋糕大小相同了。

注意恶心的精度。

教大家一个东西：`__float128`，精度特别高。

输出时转 `long double` 就可以了。


```cpp
//2022tysc0819
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
//#define int long long
//#define pb push_back
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=1e5+10,M=1010,P=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int x,y,z,n;
__float128 a,b;
signed main(){
	cin>>x>>y>>z>>n;
	for(int i=1;i<=n;i++){
		a=(i-1)*z;a/=n;
		b=(i)*z;b/=n;
		printf("0 0 %.30Lf %d %d %.30Lf\n",(long double)a,x,y,(long double)b);
	}
    return 0;
}
//note:

```

---


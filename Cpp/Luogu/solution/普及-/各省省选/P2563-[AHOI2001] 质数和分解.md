# [AHOI2001] 质数和分解

## 题目描述

任何大于 $1$ 的自然数 $n$ 都可以写成若干个大于等于 $2$ 且小于等于 $n$ 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，$9$ 的质数和表达式就有四种本质不同的形式：

$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$ 。

这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。

试编程求解自然数 $n$ 可以写成多少种本质不同的质数和表达式。


## 样例 #1

### 输入

```
2
200```

### 输出

```
1
9845164```

# 题解

## 作者：3493441984zz (赞：64)

# 感谢DengTJ童鞋指出了原题解的错误

## 于是我赶快把我那篇题解皮的地方改了回来。。
***
这个题目其实是完全背包求方案数的问题

首先呢为了让我的题解不被打回去,我先来一波分析

思路其实很明确，先把数据范围（200）以内的素数放入数组

打表和用函数判断都可以，可是个人不推荐打表，当然你愿意我也不阻拦你，打表也是能AC的；

以下是判断素数的函数
```cpp
bool pan(int x)
{
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) return 0;
    return 1;
}
```
很简洁有木有
好吧，大佬的比我的更好

接下来是重点，重点，重点！！！
重要的事情说三遍

很多人不知道状态转移方程f[j]+=f[j-su[i]]的意义

可以这么理解，一个数要拆成若干素数和，等同于拆成所有该数减去一个素数差的方案数之和(转自某位大佬)

### 举个例子：
### 模拟一下7质因数分解
### f[0]=1//初始化
### f[1]=0//1不能被任何质数分解
### f[2]=1//2能被2分解
### f[3]=1//被3分解
### f[4]=1//被2分解
### f[5]=2//这里就是重点了，5能被5分解，也能被2，3分解
### 而你自己举个数，模拟一遍，自然而然就知道是怎么累加方案数的了！！！（学不懂的东西，模拟是好方法）


# 一定要记得初始化f[0]=1否则会WA

话不多说，上AC代码：
```cpp
#include<iostream>
#include<cstring> 
#include<cmath>
using namespace std;
int su[201],f[201];
bool pan(int x)
{
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) return 0;
    return 1;
}
int main()
{
    int n;
    while(cin>>n)
    {
        int num=0;
        for(int i=2;i<=n;i++)
            if(pan(i))
                su[++num]=i;        
        memset(f,0,sizeof(f));
        f[0]=1;
        for(int i=1;i<=num;i++)
        {
            for(int j=su[i];j<=200;j++)
                f[j]+=f[j-su[i]];
        }
        cout<<f[n]<<endl;
    }
    return 0;
}
```

---

## 作者：RuSun (赞：30)

# 13行超短代码！！！

这是一个十分~~猥琐~~的背包题······

### Part I 为什么是背包

众所周知，背包问题就是处理取与不取的问题。然而这个题——就是处理这些素数取与不取的问题，所以这是一个背包问题。

### Part II 预处理

首先，就是素数的问题。因为只有200，大家可以直接手打出来。
笨一点的同学可以百度啦······

[百度](https://zhidao.baidu.com/question/70890182.html)

然后为了处理“，”，我就写了一个小代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a;
int main ()
	{
		freopen ("prime.txt","w",stdout);
		while (cin>>a)
			cout<<a<<',';
	}
```

然后把prime.txt里面的东西复制到我们的cpp中

### Part III 复杂的代码

根据[完全背包的模板](https://www.luogu.org/problem/P1616)
我们就可以写出以下代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a,prime[50]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199};
int main()
	{
		while(cin>>a)
			{	 
				int dp[242]={1};
				for(int i=1;i<=46;i++)
					{
						for(int j=prime[i];j<=200;j++)
							dp[j]+=dp[j-prime[i]];
					}
				cout<<dp[a]<<endl;
			}
		return 0;
	}
```

### Part IV 简化的代码

大家仔细想想，就可以发现我们的dp数组实际上是每次都可以用的，于是我们就有了简化的代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a,dp[242]={1},prime[50]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199};
int main()
	{	 
		for(int i=1;i<=46;i++)
			for(int j=prime[i];j<=200;j++)
				dp[j]+=dp[j-prime[i]];
		while (cin>>a)
			cout<<dp[a];
		return 0;
	}
```
#### （不要抄，小心有坑）

### Part V 打表代码

既然都做到这个程度了，大家可以发现，上面的代码就是一个打表生成器，那么我们就可以写一个打表的代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int ans[242]={0,1,1,1,2,2,3,3,4,5,6,7,9,10,12,14,17,1
,124,140,157,175,197,219,244,272,302,33
,987,1083,1186,1298,1420,1552,1695,1850
3936,4268,4624,5007,5419,5861,6336,6845
488,13435,14445,15527,16681,17914,19232
6,33439,35772,38257,40899,43709,46696,4
78331,83447,88874,94625,100719,107175,1
164320,174482,185225,196583,208585,2212
727,332258,351808,372427,394170,417088,
,615933,650686,687262,725757,766262,808
1114849,1175344,1238904,1305679,1375815
1876598,1975108,2078460,2186867,2300576
3108265,3266409,3432097,3605666,3787467
5072740,5323313,5585505,5859833,6146816
8166824,8559069,8969035,9397474,9845164}
int main ()
	{
		int a;
		while (cin>>a)
			cout<<ans[a]; 
	}
```

### Part VI 三者代码效率对比

|  | 代码长度 | 时间 | 空间 |
| -----------: | -----------: | -----------: | -----------: |
| 复杂的代码 | 460B | 15ms | 688KB |
| 简化的代码 | 408B | 14ms | 780KB |
| 打表的代码 | 1.28KB | 15ms | 660KB |

可以发现三者差别不大

---

## 作者：Heartlessly (赞：15)

## 算法分析

- 变了种（其实没变）的完全背包问题，简简单单的一维。先用筛法求出200以内的素数，然后直接DP背包，把每一个数的答案存进f数组。用while循环输入，每当输入一个数就输出相对应的答案。

- **状态转移方程：** $f[j] = f[j] + f[j-prime[i]]$

- P.S. prime数组存的是200以内的素数。

## 示例代码

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int prime[201], c = 1, f[201], n;
bool p[201];
int main(){
    for ( int i = 2; i <= 200; i++ ){
        if ( !p[i] ){
            prime[c++] = i;
            for ( int j = i*2; j <= 200; j += i )
            p[j] = true;
        }
    }//筛法求素数。主要原则：默认所有数为 0 (false) ，如果碰到一个数是 0 ，就把它 N 以内的所有倍数标记成 1 ，并将这个数存进 prime 数组。（#废话
    f[0] = 1;//初值憋忘了。
    for ( int i = 1; i < c; i++ )
    for ( int j = prime[i]; j <= 200; j++ )
    f[j] += f[j-prime[i]];//状态转移2333
    while ( cin >> n )//每当输入
    printf ( "%d\n", f[n] );//输出对应的答案
    return 0;//华丽落幕
}
```

---

## 作者：纸片人 (赞：13)

本题总体难度不大，接下来一步步讲解。

### **1.筛法**

看到题目中的“质数”二字，想必各位大佬都已经想到了筛法（毕竟蒟蒻我都想到了）。

判素的两种方法：**打表和函数**，推荐用后者。筛法写个函数这么方便打表干嘛？  ~~（其实是不会打表qwq)~~

不逼逼了，上代码：

    bool ps(int x){//名字奇怪勿喷，pansu
        for(int i=2;i<=sqrt(x);i++)
            if(x%i==0) return 0;
        return 1;
    }
    
这样一来，我们就可以利用这个叫ps的函数 判断素数了。

判断完了干什么呢？在主函数里开个数组，把题中需要用到的所有素数**存到一个数组里，备用**。代码如下：

    int ans=0;
    for(int i=2;i<=n;i++){
        if(ps(i)) {//如果ps()的返回值为1=>该数是素数=>存入数组
    		++ans;
    		s[ans]=i;
        } 
    }
    
筛法部分结束，开始本题的重点——


### **2.状态转移方程**

先上核心代码：

    for(int i=1;i<=ans;i++){
        for(int j=s[i];j<=200;j++)
        f[j]+=f[j-s[i]];
    }


可以看出来，本题的状态转移方程是 **f[j]+=f[j-s[i]]**

f[i]表示i可以分解成多少个本质不同的质数表达式（也就是题目要求的玩意）

那么这个看起来简单易懂的式子是怎么来的呢？~~（你猜啊QAQ）~~

**我们来自己推一遍：**

f[0]=1//初始化很重要

f[1]=0//**1不是质数，不知道的建议重修《小学数学》**

f[2]=1//质因数：2

f[3]=1//质因数：3

f[4]=1//质因数：2

f[5]=2// 5=5=2+3

f[6]=2// 6=2+2+2 =3+3
**注意：6=1+5是错误方案！1不是素数！**

f[7]=3// 7 =7 【**7自身也是质数**】=2+（7-2）【那么开始分解5】=2+5 =2+2+3 

...

由此可得，假设把j分解成s[i]+(j-s[i])的形式，那么原题可变化为**j-s[i]可以分解成多少个本质不同的质数表达式**，同理j-s[i]可以继续分解。

再重复一遍：

**不要忘记初始化！！f[0]=1！**


### **3.输入**

历尽千辛万苦，你解决了这题最难的部分。接下来你要做的就是用一个

    while (cin>>n){
        /*中间的一系列代码*/
    }
    
**END**








---

## 作者：fdszlzl (赞：9)

### 记忆化搜索

```
以7为例：
7是质数，方案数+1，7可拆分成 2+5，3+4（需要忽略4+3,5+2）

2+5：
5是质数，方案数+1，5可拆分成2+3
2+3:
3是质数，方案数+1,3不能拆分了

3+4：
4不是质数，方案数不加，4可拆分成2+2，但是2比（3+4）的3小，因此是不合法的拆分方案
```

思路：构建一张质数表作为拆分数，每次拆分时后面拆分的数不能小于之前拆分的数，保证拆分方案单调不减。

如果进行裸搜，显然超时，因为太多重复计算了，设f[i][j]为数i以j开始的拆分方案，下次直接拿取。

```
#include <bits/stdc++.h>
using namespace std;

int k,p[205],f[205][205];

int prime(int n) {
	if(n<2) return 0;
	for(int i=2; i*i<=n; i++) {
		if(n%i==0) return 0;
	}
	return 1;
}

//从数b开始拆分数x
void dfs(int x,int b) {
    if(f[x][b]) return;
    //如果数x是质数，方案+1
	if(prime(x)) f[x][b]++;
    //从b开始搜索质数表
	for(int i=b; i<=k; i++) {
    	//如果下一次要拆分的数x-p[i]比质数小，结束。
		if(p[i]>x-p[i]) return;
		//拆分，并传入下一次最小拆分值i
        dfs(x-p[i],i);
        //汇总结果
		f[x][b]+=f[x-p[i]][i];
	}
	return;
}

int main() {
	int n;
    //构建质数表，只有200，算法什么的随意了
	for(int i=2; i<=200; i++)
		if(prime(i)) p[++k]=i;
	while(cin>>n) {
		dfs(n,1);
		cout<<f[n][1]<<endl;
	}
	return 0;
}
```

---

## 作者：无敌大蒟蒻 (赞：6)

以下来自一名noip2018 ~~差一分~~ 全国一等**蒟蒻**的题解

这题要用到**DP完全背包求方案数**，但我想强调的是**质数表**O(∩_∩)O~

这个数据量已经算很小了，如果数据量大的话，这样一遍一遍求质数 ~~也许应该可能~~ 一定会 **TLE** ( ⊙ o ⊙ )！

这是可以用一个伟大的理论：**筛法求素数**

具体做法是：给出要筛数值的范围n，找出n以内的素数p1，p2，p3，......，pk。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个素数5筛，把5留下，把5的倍数剔除掉；不断重复下去......。(来自万能的百度百科)


此题状态转移方程： dp2[j]=dp2[j]+dp2[j-i]
(其他题解也有讲具体做法，我就 ~~懒的~~ 不说了)
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
long long t,m,w,dp2[100005],tm1[100001]={0},o;
int truncsqrt(int p){//筛法求素数
	int i;
	for(i=2;i<=p;i++) 
	for(int j=2;j<=p/i;j++) tm1[i*j]=1;
}
int main(){
	int p;
	truncsqrt(201);//打一个质数表，质数为0，非质数为1
	tm1[1]=1;//1不是质数
	while(cin>>p){//循环数
		memset(dp2,0,sizeof(dp2));//记得清零
	    dp2[0]=1;
			for(int i=2;i<=p;i++){
				if(tm1[i]==1) continue;
				for(int j=i;j<=p;j++){
					dp2[j]=dp2[j-i]+dp2[j];
				}
			}
	    cout<<dp2[p]<<endl;//直接输出即可
	}
	
}
```

---

## 作者：Enzymii (赞：6)

#啊 居然没有C++题解。。

这题就是一背包嘛~

状态转移方程：f[j]+=f[j-w[i]] 【调皮的我】

交了好几遍 好几遍 发现自己读入写挂了喂~

其实本题不算难的。。为了压个效率强行打200以内质数表啊。。

内个 会判素的小盆友们不要学我。。。

好吧
下面上代码

```cpp
#include<cstdio>
#include<cmath>
int f[201];
int w[47]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,
           47,53,59,61,67,71,73,79,83,89,97,101,103,
           107,109,113,127,131,137,139,149,151,157,
           163,167,173,179,181,191,193,197,199};//传说中的质数表，大家不要学我
int main()
{
    freopen("datad.in","r",stdin);
    f[0]=1;//给一个边界条件
    for(int i=1;i<=46;i++)//这就是打表的好处之一
        for(int j=w[i];j<=200;j++)//在这里循环到200然后就可以O(1)查询了o(≧v≦)o~~好棒
            if(f[j-w[i]])                       
                f[j]+=f[j-w[i]];//状态转移方程上吧
    int n;
    while(scanf("%d",&n)!=EOF)//**爆炸的来源**
        printf("%d\n",f[n]);    //O(1)查询然后输出搞定
}
```

---

## 作者：xdc呀 (赞：3)

一道完全背包问题

首先，我们先把200以内的素数求出来。
这里我们用筛法和函数求
# 求素数程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt=0;
bool qss(int x)
{
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) return 0;
    return 1;
}
int main()
{
	freopen("1.txt","w",stdout);
	cout<<"ss[50]={0,";//数组开头第一个下标是0，从0开始
	for(int i=2;i<=200;i++)
	{
		if(qss(i))
		cout<<i<<',';
	}
	cout<<"}"<<endl;
}
```
得到结果：
```
ss[50]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47
,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,
127,131,137,139,149,151,157,163,167,173,179,181,191,
193,197,199,}//这个结果需要处理一下，把199后面的逗号删掉。

```

# 最终得到答案的程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100009];
int ss[50]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199};
const int cnt=46;
int ans[209];

int main()
{
	freopen("2.txt","w",stdout);
	for(int t=1;t<=200;t++)///题目数据范围到200
	{
		memset(f,0,sizeof(f));//每次都要格式化
		f[0]=1;//0的方案是0，这就是一个方案
		for(int i=1;i<=46;i++)
		{
			for(int j=ss[i];j<=t;j++)
			{
				f[j]+=f[j-ss[i]];//状态转移方程
			}
		}
		ans[t]=f[t];//存答案
	}
	cout<<"ans[209]={";
	for(int i=0;i<=200;i++)
	{
		cout<<ans[i]<<',';
	}
	cout<<'}';
}
```
得到结果：
```cpp
ans[209]={0,0,1,1,1,2,2,3,3,4,5,6,7,9,10,12,14,17,19,23,26,30,35,40,46,52,60,67,
77,87,98,111,124,140,157,175,197,219,244,272,302,336,372,413,456,504,557,
614,677,744,819,899,987,1083,1186,1298,1420,1552,1695,1850,2018,2198,
2394,2605,2833,3079,3344,3630,3936,4268,4624,5007,5419,5861,6336,6845,
7393,7979,8608,9282,10003,10776,11603,12488,13435,14445,15527,16681,
7914,19232,20636,22134,23732,25436,27251,29186,31246,33439,35772,38257,
40899,43709,46696,49871,53243,56826,60631,64671,68957,73506,78331,83447,
88874,94625,100719,107175,114014,121255,128923,137038,145627,154709,
164320,174482,185225,196583,208585,221265,234658,248807,263745,279516,
296161,313727,332258,351808,372427,394170,417088,441250,466711,493538,
521804,551573,582925,615933,650686,687262,725757,766262,808872,853692,
900827,950393,1002502,1057278,1114849,1175344,1238904,1305679,1375815,
1449471,1526812,1608014,1693247,1782712,1876598,1975108,2078460,2186867,2300576,2419812,2544843,2675925,2813326,2957342,3108265,3266409,
3432097,3605666,3787467,3977861,4177239,4385994,4604537,4833306,
5072740,5323313,5585505,5859833,6146816,6447003,6760967,7089299,
7432618,7791567,8166824,8559069,8969035,9397474,9845164,}//答案需处理，最后一个逗号要删掉。
```


# AC程序（打表（以空间换时间））
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[209]={0,0,1,1,1,2,2,3,3,4,5,6,7,9,10,12,14,17,19,23,26,30,35,40,46,52,60,67,77,87,98,111,124,140,157,175,197,219,244,272,302,336,372,413,456,504,557,614,677,744,819,899,987,1083,1186,1298,1420,1552,1695,1850,2018,2198,2394,2605,2833,3079,3344,3630,3936,4268,4624,5007,5419,5861,6336,6845,7393,7979,8608,9282,10003,10776,11603,12488,13435,14445,15527,16681,17914,19232,20636,22134,23732,25436,27251,29186,31246,33439,35772,38257,40899,43709,46696,49871,53243,56826,60631,64671,68957,73506,78331,83447,88874,94625,100719,107175,114014,121255,128923,137038,145627,154709,164320,174482,185225,196583,208585,221265,234658,248807,263745,279516,296161,313727,332258,351808,372427,394170,417088,441250,466711,493538,521804,551573,582925,615933,650686,687262,725757,766262,808872,853692,900827,950393,1002502,1057278,1114849,1175344,1238904,1305679,1375815,1449471,1526812,1608014,1693247,1782712,1876598,1975108,2078460,2186867,2300576,2419812,2544843,2675925,2813326,2957342,3108265,3266409,3432097,3605666,3787467,3977861,4177239,4385994,4604537,4833306,5072740,5323313,5585505,5859833,6146816,6447003,6760967,7089299,7432618,7791567,8166824,8559069,8969035,9397474,9845164};
int n;
int main()
{
	while(cin>>n)//读一个处理一个
	{
		cout<<ans[n]<<endl;
	}
}
```


---

## 作者：二元长天笑 (赞：3)

第一遍看后，很明显，用DP。但是它一次要读入多个数据，很多人有可能就蒙了。其实很简单，一般用C++来说，这种东西直接用While(cin>>)就搞定了，就是要注意一下每次DP完都要给数组重置一下，要不就会爆炸。天笑在这个地方就栽了。然后就是初始化的问题了，在这里我把它放在了程序的最开头，先把质数表给**算出来**（其实质数表这种这么容易的东西用打表就不太好意思了吧，而且不用你去人工运算，也占不了多少时间）。然后后面用DP式： f [ j ] += f [ j - b [ i ] ] ;  就可以搞定了。然后再把除了运算质数的函数外的其他运算过程用个**大大的while**框起来就搞定啦！

下面是AC代码:


```cpp
#include<iostream>
#include<cstring>
using namespace std;    
bool a[510]={1,1};  
int b[510],ans=0,num,f[510];  
bool jc(int p)  
{    
    for(int i=2;i*i<=p;i++)  
        if(p%i==0)  
            return 0;    
    return 1;    
}    
void yu()  
{  
    for(int i=2;i<=500;i++)  
    {    
        if(!a[i]&&jc(i))  
        {  
            int k=i+i;    
            while(k<=500)  
            {  
                a[k]=1;  
                k+=i;    
            }  
        }    
    }    
    for(int i=1;i<=500;i++)  
        if(!a[i])  
            b[++ans]=i;  
}    
int main()  
{    
    yu();   
    while(cin>>num)
    {
        memset(f,0,sizeof(f));  
        f[0]=1;   
        for(int i=1;i<=ans&&b[i]<=num;i++)  
            for(int j=b[i];j<=num;j++)  
                if(j-b[i]>=0&&f[j-b[i]])  
                    f[j]+=f[j-b[i]];  
        cout<<f[num]<<endl;
        }
}
```

---

## 作者：wubaiting2020 (赞：2)

思路：这道题本质上就是一道完全背包，先打出质数的表，再用完全背包处理即可
首先先打出质数表
```cpp
void biao()//线性筛，作用是打出质数表
{
	for(int i=2;i<=200;i++)
	{
		if(vst[i]!=0)continue;
		ans++;zs[ans]=i;
		for(int j=2;j*i<=200;j++)vst[i*j]=1;
	}
}
```
不会的可以用朴素，~~反正也不会超时~~
```
bool pd(int n);
{
	vst[2]=1;
	for(int i=2;i<=200;i++)
	{
		bj=0;
    for(int i=2;i<n;i++)//只要有一个能整除就不是质数 
        if(n%i==0){bj=1;break;}
		if(bj==0)vst[i]=1; 
	}  
}
```
然后将质数作为物品，要求是刚好把数填满
所以就有了
```
for(int i=1;i<=ans;i++)//ans为质数个数
	for(int j=zs[i];j<201;j++)f[j]+=f[j-zs[i]];
```
所以整个代码即
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iomanip>
#include<queue>
#include<cstring>
using namespace std;
int vst[205],f[205],zs[205],ans=0;
void biao()//线性筛，作用是打出质数表
{
	for(int i=2;i<=200;i++)
	{
		if(vst[i]!=0)continue;
		ans++;zs[ans]=i;
		for(int j=2;j*i<=200;j++)vst[i*j]=1;
	}
}

int main()
{
	int n;
	biao();//打出质数表
	f[0]=1;//0空间只有一种方法
	for(int i=1;i<=ans;i++)
	for(int j=zs[i];j<201;j++)f[j]+=f[j-zs[i]];
    while(cin>>n)
	cout<<f[n]<<endl;//此时已经在f数组中存入了答案，读入n输出即可
	return 0;
}

```

---

## 作者：PigAunt (赞：2)

协议: CC BY-NC-ND-SA
## 既然(2 < n < 200)，为何不先把200的算完直接输出呢？

### 核心部分

```cpp
int prime[50]={0,2,3,5,7,11,13,17,19,23,29,31,37,
41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,
107,109,113,127,131,137,139,149,151,157,163,167,
173,179,181,191,193,197,199};
int n,d[205];
d[0]=1;
for(int i=1;i<=46;i++)
	for(int j=prime[i];j<=200;j++)
		d[j]+=d[j-prime[i]];
while(cin>>n)
	cout<<d[n]<<endl;
```

### 注意末尾换行

#### PS:200以内素数手打就可以了

---

## 作者：wxy_god (赞：1)

你们为啥都用$dp$啊，既难想，又难对  
所以打表最好了  
思路为，先用筛法对所有小于等于$200$的数进行筛法，这里$true$代表不是质数，$false$代表质数。接着，对于每一个数，进行一次$dfs$。$dfs$有俩参数，分别代表之前所有质数的和以及上一个数。如果当前和大于等于$n$，说明超出界限，如果和正好等于$n$，则计数器加一。否则进行递归。递归时，从上一个数开始枚举（保证本质不同就需要从上一个数开始枚举），每一个数首先判断是不是质数（使用筛法打出的质数表），如果是，进行递归。运行完$200$个数需要几十秒，要等一会儿。代码中注释部分为打表代码。  
```
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>

int n;
int ans[] = {-1, 0, 1, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 9, 10, 12, 14, 17, 19, 23, 26, 30, 35, 40, 46, 52, 60, 67, 77, 87, 98, 111, 124, 140, 157, 175, 197, 219, 244, 272, 302, 336, 372, 413, 456, 504, 557, 614, 677, 744, 819, 899, 987, 1083, 1186, 1298, 1420, 1552, 1695, 1850, 2018, 2198, 2394, 2605, 2833, 3079, 3344, 3630, 3936, 4268, 4624, 5007, 5419, 5861, 6336, 6845, 7393, 7979, 8608, 9282, 10003, 10776, 11603, 12488, 13435, 14445, 15527, 16681, 17914, 19232, 20636, 22134, 23732, 25436, 27251, 29186, 31246, 33439, 35772, 38257, 40899, 43709, 46696, 49871, 53243, 56826, 60631, 64671, 68957, 73506, 78331, 83447, 88874, 94625, 100719, 107175, 114014, 121255, 128923, 137038, 145627, 154709, 164320, 174482, 185225, 196583, 208585, 221265, 234658, 248807, 263745, 279516, 296161, 313727, 332258, 351808, 372427, 394170, 417088, 441250, 466711, 493538, 521804, 551573, 582925, 615933, 650686, 687262, 725757, 766262, 808872, 853692, 900827, 950393, 1002502, 1057278, 1114849, 1175344, 1238904, 1305679, 1375815, 1449471, 1526812, 1608014, 1693247, 1782712, 1876598, 1975108, 2078460, 2186867, 2300576, 2419812, 2544843, 2675925, 2813326, 2957342, 3108265, 3266409, 3432097, 3605666, 3787467, 3977861, 4177239, 4385994, 4604537, 4833306, 5072740, 5323313, 5585505, 5859833, 6146816, 6447003, 6760967, 7089299, 7432618, 7791567, 8166824, 8559069, 8969035, 9397474, 9845164};

/*
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>

const int N = 201;
int n;
int ans;
bool prime[N] = {true, true};

inline void s () {
	for(int i = 2; i <= N; i ++ ) {
		if(prime[i] == true) continue;
		for(int j = i << 1; j <= N; j += i)
		    prime[j] = true;
	}
}

inline void dfs (int sum, int last) {
	if(sum > n) return;
	if(sum == n) {
		ans ++ ;
		return;
	}
	int limit = n - sum;//这里可以优化，只不过我怕错，就没优化
	for(int i = last; i <= limit; i ++ ) {
		if(prime[i] == false) dfs(sum + i, i);
	}
}

int main () {
	
	s();
	for(int i = 1; i <= 200; i ++ ) {
		n = i;
		ans = 0;
		dfs(0, 0);
		printf("%d, ", ans);
	}
	
	return 0;
} */

int main () {
	
	while(~scanf("%d", &n)) {
		printf("%d\n", ans[n]);
	}
	
	return 0;
} 
```

---

## 作者：HPXXZYY (赞：1)

[博客食用（使用）效果更佳](https://www.luogu.org/blog/hpwwzyy2012/solution-p2563)

方法：dp（动态规划）中的完全背包

思路：首先，把1~200中的质数都储存在一个数组中（如代码中的p数组）。然后，进行完全背包

重点：很多人不理解代码中f[j]+=f[j-p[i]]的意思，现在我来解释一下：

f[i]表示i可以分解成多少个本质不同的质数表达式

~~重点来了，敲黑板~~

假设把j分解成p[i]+(j-p[i])的形式，那么原题可分解为j-p[i]可以分解成多少个本质不同的质数表达式，同理j-p[i]可以继续分解

注意：一定要把f[0]初始化为1，否则f[i]（1<i<201）将永远是0！！！~~你将收获一个Wrong Answer！！！~~

[评测记录](https://www.luogu.org/recordnew/show/15551915)

Accepted 100

用时：14ms/内存：792KB

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int p[205],f[205],n,i,j,t;
bool prime[205];
void pt(){
    memset(prime,1,sizeof(prime));
    prime[1]=false;
    for(i=2;i<201;i++)
    if (prime[i]){
        p[++t]=i;
        for(j=i*i;j<201;j+=i)
        prime[j]=false;
    }
}
int main(){
//	freopen("t1.in","r",stdin);
    pt();f[0]=1;
    for(i=1;i<=t;i++)
    for(j=p[i];j<201;j++)
    f[j]+=f[j-p[i]];
    while (~scanf("%d",&n))
    printf("%d\n",f[n]);
    return 0;
}
```

---

## 作者：izthy (赞：1)

# 暴搜出奇迹
```cpp
#include<bits/stdc++.h>
using namespace std;
int prm[666]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661};
//质数表
int pos[6666]={0,0,1,2,0,3,0,4,0,0,0,5,0,6,0,0,0,7,0,8,0,0,0,9,0,0,0,0,0,10,0,11,0,0,0,0,0,12,0,0,0,13,0,14,0,0,0,15,0,0,0,0,0,16,0,0,0,0,0,17,0,18,0,0,0,0,0,19,0,0,0,20,0,21,0,0,0,0,0,22,0,0,0,23,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,26,0,27,0,0,0,28,0,29,0,0,0,30,0,0,0,0,0,0,0,0,0,0,0,0,0,31,0,0,0,32,0,0,0,0,0,33,0,34,0,0,0,0,0,0,0,0,0,35,0,36,0,0,0,0,0,37,0,0,0,0,0,38,0,0,0,39,0,0,0,0,0,40,0,0,0,0,0,41,0,42,0,0,0,0,0,0,0,0,0,43,0,44,0,0,0,45,0,46,0,0,0,0,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49,0,0
,0,0,0,50,0,0,0,0,0,51,0,52,0,0,0,0,0,53,0,0,0,54,0,55,0,0,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,0,0,57,0,0,0,58,0,59,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,61,0,0,0,0,0,62,0,0,0,0,0,0,0,0,0,63,0,64,0,0,0,65,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,68,0,0,0,0,0,69,0,0,0,70,0,0,0,0,0,71,0,0,0,0,0,0,0,72,0,0,0,73,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,0,0,75,0,76,0,0,0,0,0,0,0,0,0,77,0,78,0,0,0,0,0,79,0,0,0,80,0,0,0,0,0,81,0,0,0,0,0,0,0,82,0,0,0,83,0,84,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,86,0,0,0,0,0,0,0,87,0,0,0,88,0,0,0,0,0,0,0,89,0,0,0,90,0,0,0,0,0,91,0,0,0,0,0,0,0,0,0
,0,0,92,0,93,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,94,0,0,0,0,0,95,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,97,0,0,0,0,0,98,0,99,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,101,0,0,0,0,0
,102,0,0,0,0,0,103,0,104,0,0,0,0,0,105,0,0,0,0,0,106,0,0,0,107,0,108,0,0,0,0,0,0
,0,0,0,0,0,109,0,0,0,0,0,0,0,0,0,110,0,111,0,0,0,112,0,0,0,0,0,113,0,0,0,0,0,114
,0,115,0,0,0,0,0};
//用来存质数位置的表
int n,a[666],ans=0;
int ff[2333]={0,1,1,1,2,2,3,3,4,5,6,7,9,10,12,14,17,19,23,26,30,35,40,46,52,60,67,77,87,98,111,124,140,157,175,197,219,244,272,302,336,372,413,456,504,557,614,677,744,819,899,987,1083,1186,1298,1420,1552,1695,1850,2018,2198,2394,2605,2833,3079,3344,3630,3936,4268,4624,5007,5419,5861,6336,6845,7393,7979,8608,9282,10003,10776,11603,12488,13435,14445,15527,16681,17914,19232,20636,22134,23732,25436,27251,29186,31246,33439,35772,38257,40899,43709,46696,49871,53243,56826,60631,64671,68957,73506,78331,83447,88874,94625,100719,107175,114014,121255,128923,137038,145627,154709,164320,174482,185225,196583,208585,221265,234658,248807,263745,279516,296161,313727,332258,351808,372427,394170,417088,441250,466711,493538,521804,551573,582925,615933,650686,687262,725757,766262,808872,853692,900827,950393,1002502,1057278,1114849,1175344,1238904,1305679,1375815,1449471,1526812,1608014,1693247,1782712,1876598,1975108,2078460,2186867,2300576,2419812,2544843,2675925,2813326,2957342,3108265,3266409,3432097,3605666,3787467,3977861,4177239,4385994,4604537,4833306,5072740,5323313,5585505,5859833,6146816,6447003,6760967,7089299,7432618,7791567,8166824,8559069,8969035,9397474,9845164};
//暴搜完后的表，直接调用就好了2333
void dfs(int x,int t){
	if(x==0)		
		ans++;
	if(x==1||x<0)	
		return;
	for(int i=pos[a[t-1]];prm[i]<=x;i++){	//从小往大搜，不然会重复
		a[t]=prm[i];
		x-=a[t];
		dfs(x,t+1);
		x+=a[t];
	}
}
int main(){
/*	freopen("质数和分解暴搜.out","w",stdout);
	a[0]=2;
	cout<<"{";
	for(int i=1;i<=200;i++){
		dfs(i,1);
		ff[i]=ans;
		cout<<","<<ff[i];		暴搜打表
		ans=0;
	}
	cout<<"}";
	return 0;*/	
	while(cin>>n){
		cout<<ff[n-1]<<endl;
	}	
	return 0;
}
```


---

## 作者：EarthGiao (赞：0)

## 【思路】
筛法 + 完全背包     
### 【题目大意】
每一个数可以被拆分成多少种质数相加的形势    

### 【题目分析】
首先这是被拆分成许多个数    
这些数都是质数     
假设是已知的    
那就可以用完全背包来拼凑某个数了    
然后要怎么知道质数呢？   
很简单的筛法     

### 【核心思路】
先预处理出200以内的质数     
然后跑完全背包     
将200以内的每个数的组合方式预处理出来    
最后输出就好了      
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int Max = 205;
int prime[Max];
bool use[Max];
int bb[Max];
int sum = 0;

signed main()
{
	for(register int i = 2;i <= 200;++ i)
	{
		if(use[i] == false)
		{
			prime[++ sum] = i;
			for(register int j = i * 2;j <= 200;j += i)
				use[j] = true;
		}
	}
	bb[0] = 1;
	for(register int i = 1;i <= sum;++ i)
		for(register int j = prime[i];j <= 200;++ j)
			bb[j] += bb[j - prime[i]];
	int n; 
	while(scanf("%lld",&n) != EOF)
	{
		cout << bb[n] << endl;
	}
	return 0;
}
```

---

## 作者：yyandy (赞：0)

## 数据。。好水
n<=200 !

于是，我就随便写了一遍，~~好水的黄题~~

先找出素数

然后预处理了一下 ~~好像没必要~~

非常水的背包，加在里面好像也不会TLE ~~我没试过~~

然后。。。输出答案就行啦

注释详见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,k,j,f[1022],a[1022];
bool t[1300];
int main(){	
n=200;
//从此开始
for (i=2;i<=n;++i)
for (j=2;j<=n/i;++j)
t[i*j]=1;
for (i=2;i<=n;++i)if (!t[i]){++k;a[k]=i;}
f[0]=1;	
//到这里，是素数，写得太烂了,别看
//把是素数的放到a数组当中
for (i=1;i<=k;++i)
for (j=a[i];j<=n;++j)
f[j]+=f[j-a[i]];//完全背包问题，求出1-200
while (cin>>n)	//不管有多少
cout<<f[n]<<endl;//输出就行
}
```
真快。。。

附送<a href="https://www.luogu.org/problemnew/solution/P1832">rt</a>



---

## 作者：Alviss_lky (赞：0)

10211314334486875731~

先上代码：
```
//严禁抄袭 
#include<bits/stdc++.h>//万能头文件 
using namespace std;
inline void read(int &x)//快读 
{
	int a=0,sign=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')sign=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		a=(a<<1)+(a<<3)+ch-48;
		ch=getchar();
	}
	x=a*sign;
}
bool prime[201];//存储是否为质数 
bool isp(int i)//判断质数 
{
	if(i==1)return 0;
	if(i==2)return 1;
	for(int j=2;j*j<=i;j++)
	{
		if(i%j==0)return 0;
	}
	return 1;
}
void find()//找质数 
{
	int cnt=0;
	for(int i=1;i<=200;i++)
	prime[i]=isp(i);
}
bool sb[300][300];//记忆化搜索（标记数组，表示这个位置是否有值） 
long long hh[300][300];//记忆化搜索存储数组 
long long dfs(int nowmax,int sx)//nowmax表示当前已经有的最大值，sx表示数还剩余多少 
{
	sb[nowmax][sx]=1;//打标记 
	if(sx==0)return hh[nowmax][sx]=1;//拆完了 
	if(nowmax>sx)return hh[nowmax][sx]=0;//拆不完，其实不加这个也可以，但是会浪费时间 
	int ans=0;
	for(int i=nowmax;i<=sx;i++)
	{
		if(prime[i])
		{
			if(sb[i][sx-i])
			ans+=hh[i][sx-i];//这个位置有值 
			else
			ans+=dfs(i,sx-i);//这个位置没有值，需要dfs 
		}
	}
	return hh[nowmax][sx]=ans;//记录数据 
}
int main()
{
	int n;//防抄题解 
	find();//先找质数 
	while(cin>>n)//不停输入 
	{
		cout<<dfs(2,n)<<endl;//dfs需要从2开始，因为质数是从2开始的 
	}
	return 0;//代码不return 0，分数return 0（逃 
}
```
这道题的代码难度真心不难……不过，爆搜会得到0分，因为只要测试一个180以上的数，就会直接炸掉（雾）。

所有注释已经在代码里面了，这道题只要有以下几步，就能用记忆化搜索AC：
+ 1.找质数，因为不找指数不可能做（逃
+ 2.dfs，注意要记忆化标记，也可以在前面return,但会浪费1步。
+ 3.输出即可，也可以先dfs一下200然后直接输出数组的值（但是我不建议这样做）
# [AC记录](https://www.luogu.org/recordnew/show/19895690)

---

## 作者：狸狸养的敏敏 (赞：0)

说实话这一题评不到黄题，既用不到高深算法也用不到很强思维（狗头保命）

我们考虑完全背包，把每个质数看成一个物品，因为空间是没有限制的，所以我们可以直接省去空间这一维，近似的变成了递推。

完全背包计数是很基础的算法，很多统计方案数的题可以用完全背包计数做，时间复杂度$O(NlogN)$

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int pri[220];//用来存储质数
bool mark[220];//用来标记是不是质数
int f[220];//用来dp
int tot;//保存质数的个数
int n;
void init() {
	mark[1]=1;
	for(int i=2; i<=200; i++)
		if(!mark[i]) {
			pri[++tot]=i;
			for(int j=i; j<=200; j+=i)
				mark[j]=1;
		}//最简单的质数筛，连线性筛都没用
}
int main() {
	init();
	f[0]=1;//为了转移用[滑稽保命]
	for(int i=1;i<=tot;i++)
	for(int j=pri[i];j<=200;j++)
	f[j]+=f[j-pri[i]];//预处理所有的答案(说白了就是打表)
	while(cin>>n)
	printf("%d\n",f[n]);//直接输出就好了
	return 0;
}
```

---

## 作者：翠竹叶飞 (赞：0)

完全背包求方案数，dp很水，我想说的是scanf的返回值。

scanf 函数是有返回值的，它的返回值可以分成三种情况

1) 正整数，表示正确输入参数的个数。例如执行 scanf("%d %d", &a, &b);

如果用户输入"3 4"，可以正确输入，返回2（正确输入了两个变量）；

如果用户输入"3,4"，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。

2) 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入",3 4"，返回0。

3) EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束。

```cpp
#include<cstdio>
#include<cstring>
int n,i,j,p[50],size;
bool judge[201];
int f[201];
int main()
{
    for (i=2; i<=200; i++)
      if (judge[i]==0)
      {
          p[++size]=i;
          int tmp=2*i;
          while (tmp<=200)
          {
              judge[tmp]=1;
              tmp+=i;
          }
      }
    while (scanf("%d",&n)==1)
    {
        memset(f,0,sizeof(f));
        f[0]=1;
        for (i=1; i<=size; i++)
        {
            if (p[i]>n) break;
            for (j=p[i]; j<=n; j++)
                f[j]+=f[j-p[i]];
        }
        printf("%d\n",f[n]);
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

没人写这题的题解，那就我来写一篇吧...

这是一道很好的记忆化+深搜题目，很容易想到。

下面放代码↓






```cpp
var b:array[0..10000]of boolean;
h:array[0..500,0..500]of longint;
i,j,k,m,n:longint;
function try(x,y:longint):longint;//try（x,y）代表数字x，所能放的最小质数为y时的解
var i:integer;
begin
if h[x,y]>0 then exit(h[x,y]) ;//标准记忆化，防止重复计算
try:=0;
  if x=0 then exit(1);   if x=y then exit(1);
  if x<y then exit(0);
  for i:=y to x do
  if b[i]=false then try:=try+try(x-i,i);
  h[x,y]:=try;//存下结果
end;
begin
  for i:=2 to 250 do
  if b[i]=false then
  for j:=2 to 300 div i do b[i*j]:=true;//筛法求质
  while not eof do//我的读入很无聊不要介意
  begin
  n:=0;
  read(n);
  if n=0 then halt;//呵呵......
  writeln(try(n,2));
  end;
end.
```

---


# [TJOI2010] 阅读理解

## 题目描述

英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。

## 说明/提示

对于 $30\%$ 的数据， $1\le M\le 10^3$ 。

对于 $100\%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。

每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。

感谢@钟梓俊添加的一组数据。

## 样例 #1

### 输入

```
3
9 you are a good boy ha ha o yeah
13 o my god you like bleach naruto one piece and so do i
11 but i do not think you will get all the points
5
you
i
o
all
naruto
```

### 输出

```
1 2 3
2 3
1 2
3
2
```

# 题解

## 作者：Ervin (赞：302)

#### 这道题看一眼就知道这是个$STL$库里的$map$
- 但是。。
- ~~神犇我~~选择了$Trie$树，$Hahahaha...$
- 可能没有$dalao$发这个题目的$Trie$树题解是因为太麻烦了、、、不过$A+B$ $Problen$都有发各种~~看不懂~~的题解的人，我发个$Trie$树也没有什么说不过去的吧、、


------------


------------
## $*******$ $dalao$ 专用分割线$******$

------------


------------
可能有的小朋友们还不知道$Trie$树是什么(~~虽然我也是刚刚才知道~~)，我还是先讲一下$Trie$树吧。。

$To$  $begin$  $with$，需要了解一下$Trie$树是干什么的，$Trie$树又叫做字典树。字典，就是用来查字的，顾名思义，$Trie$树也是用来查字或者单词的。

那什么时候会用到$Trie$树呢？

举个例子吧：
1. 就像这道题目一样，查寻这个单词在一句话中出现还是没有出现，非常简单么，$map$啊，~~短小精干~~
2. 但是，如果给出$n$个单词和$m$组询问，询问是多少个单词的前缀，那么$map$的话就完美的$TLE$了，这个时候就要使用久违的$Trie$树了！！

$Second$，先模拟一下$Trie$树的各种操作吧。


如果要插入

$CAI,CHANG,CHAO,CHEN,LAN,LI,LIU,LONG,$

$WANG,WEN,WU,YANG,YUN,ZHAO$这些字符，

所建出的$Trie$树就是这样的。

## 呈上图来：

![](https://cdn.luogu.com.cn/upload/pic/15735.png)

### 注意：$Trie$树的根节点是空的，然后在单词的末尾有个标记，这点事必不可少的。

$Then$，介绍一下$Trie$树的基本操作吧。

$A.$ $Insert$插入：
1. 首先要给所有的字母一个编号，其实并不用从$a...z$全部都编号，你会发现其实有很多字母是用不到的，所以只需要判断树中有没有这个单词的前缀，然后进行编号。
2. 编号完成后更新当前位置，接着进入下一个层。

#### 代码统一在后边统一粘上
$B.$ $Check$查询：
从$Trie$树的根开始，看有没有当前的字符，如果没有，就直接$break$掉，否则就跟新当前位置，进入下一层。

其实$Trie$树的常用操作就这两个，其实$Trie$树涉及的题目也不算很多，其实学习$Trie$树还可以为以后的$AC$自动机(~~就是用了这个算法就可以自动AC了~~)做一下铺垫。

----

----
好了，对于$Trie$树的介绍就到这里吧，下面就说这个题目了，其实这个题目就是一道裸裸的$Trie$树模板，写出上边介绍的两个操作，再加上点~~高深~~的东西就可以$AC$了。

下边直接粘代码吧：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
char s[10010];
int nex[500010][26],n,cnt=0;
bool b[500010][1010];
inline int read()
{
    int k=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9')
	{
		k=k*10+ch-'0';
		ch=getchar();
	}
    return k*f;
}
inline void insert(int x)
{
    scanf("%s",s+1);
	int l=strlen(s+1);
    int now=0;
    for(int i=1;i<=l;i++)
	{
        int p=s[i]-'a';
        if(!nex[now][p])         //如果$Trie$树中没有这个单词的前缀就进行编号
			nex[now][p]=++cnt;   //上文中说到的编号 
        now=nex[now][p];         //接着深入一层，更新现在的位置 
    }
    b[now][x]=1;                 //这个单词在第x行出现了
}
inline void check()
{
    scanf("%s",s+1);
	int l=strlen(s+1);
    int now=0,flag=1;
    for(int i=1;i<=l;i++)
	{
        int p=s[i]-'a';
        if(!nex[now][p])         //如果在Trie树中没有当前的字符，就可以直接break掉了 
		{
			flag=0;
			break;
		}
        now=nex[now][p];         //否则就更新位置 
    }
    if(flag)
		for(int i=1;i<=n;i++)    //题面上说按字典序输出 
			if(b[now][i])
				printf("%d ",i); //输出在哪些句子中出现过 
    puts("");                    //相当于printf("\n");其实这个条件很容易看不到，一定要注意啊！！ 
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
	{
        int x=read();
        for(int j=1;j<=x;j++)    //一个单词一个单词的插入Trie树里 
			insert(i);
    }
    int m=read();
    for(int i=1;i<=m;i++)
		check();
    return 0;
}
```
## 感谢大家的观看，上方点赞哦!!

---

## 作者：Misaka_Azusa (赞：115)

我先说一句：
## 我永远都喜欢~~Stella~~STL
_______

这个题，很明显就是
### ~~trie树~~ 
### ~~hash~~ 
### map+vector
_______

## 思路：

直接用map<string,vecotr<int> > 代替这题里的trie树，注意开map的时候后面两个> >之间要有一个空格。

用vector记录每个单词出现的句子位置，每遇到一个就把该单词所出现的句子的编号压入对应的vector里。

于是乎= =这就是最暴力的想法。

接下来我们利用一个桶来去重就完成了题目里的要求。（~~我会说我是因为没看见这个要求第一次提交爆零嘛qaq~~）
_______

## Code：
```
#include <map>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 100001;
int n, m, num, cnt[maxn];
string s;
map<string,vector<int> >a;
int main()
{	
	std::ios::sync_with_stdio(false);//要关闭同步，快很多
	cin>>n;
	for(int i = 1; i <= n; i++)
	{
		cin>>num;
		for(int j = 1; j <= num; j++)
		{
			cin>>s;
			a[s].push_back(i);//vector的压入操作。我每一个单词就是一个vector。
		}
	}
	cin>>m;
	for(int i = 1; i <= m; i++)
	{
		cin>>s;
		memset(cnt,0,sizeof(cnt));//cnt就是去重的桶。每用一次输出不同的查询要清零。
		for(int j = 0; j < a[s].size(); j++)//a[s].size()是vector自动返回其长度的函数。
		if(cnt[a[s][j]] == 0)
		{
			cout<<a[s][j]<<" ";//我们存的就是答案所求的所出现的句子的编号，所以直接输出不多bb。而且存的时候也是按顺序所记录的。
			cnt[a[s][j]]++;//别忘了用桶去重！
		}
		cout<<endl;
	}
	return 0;
}
```
_______
## 结尾：

我的代码应该是很短的了，同学们应该要有利用stl的意识，但不能完全依靠stl，毕竟有很多东西也是stl现在所提供不了的。

两个STL应用使代码简短了很多。然而还是那句话，天上不会掉馅饼，程序的效率还是有所下降的。然而，效率不是全部，人们宁可牺牲三倍效率用Java而不用C语言就是最好的例子（from_ Charles E Leiserson_），具体取舍要看情况。

该手打的还是要会的。~~trie树还是要会的！~~

有什么问题交流欢迎+QQ 935145183/3203600070

---

## 作者：VCarlyle (赞：57)

> 前言

#### $\rm{STL}\bold{\text{大法好！}}$

---

> 思路

现有题解里好像很多用$\rm{map}+\rm{vector}$再桶去重的……？

既然用了$\rm{STL}$，**为什么不试试$\rm{set}$呢？**

>> $\rm{Wait,\ }\rm{set}$是什么？

$\rm{set}$是$\rm{set}$库内封装的一个容器，顾名思义（？）就是一个集合（~~桶~~），满足集合的性质——一个元素只能在一个集合内最多出现一次（~~还不就是桶~~），并且已经默认从小到大排序（~~别，越说越桶了~~）。

>> 那么$\rm{set}$该怎么用？

和$\rm{STL}$中的其它容器一样，一个所有元素为整型的$\rm{set}$这样定义：

```cpp
set<int> s;
```

另外，$\rm{set}$库中还封装了以下函数：

- `s.insert()` —— 把一个元素插入$\rm{s}$；
- `s.clear()` —— 清空$\rm{s}$；
- `s.empty()` —— 返回$\rm{s}$是否为空；
- `s.size()` —— 返回$\rm{s}$中的元素个数；
- `s.count(int n)` —— 返回元素$\rm{n}$是否在$\rm{s}$中；
- 以及迭代器为基础的`s.begin()`及`end()`。

顺便提一下$\rm{set}$的遍历，和其它容器一样也需要使用一个迭代器（$\rm{iterator}$）：

```cpp
set<int>::iterator iter; //迭代器定义方法
iter=s.begin(); //将迭代器指向s的第一个元素的地址
while(iter!=s.end()) //只要迭代器没有指向s的最后一个元素的地址
{
	cout<<*iter; //因为迭代器指向的是元素的地址，所以*iter就是元素的值了
    iter++; //使迭代器指向下一个元素的地址
}
```

由于$\rm{set}$中元素是从小到大排序的，所以这段代码将会从小到大把$\rm{s}$中所有元素输出。当然，这个循环也可以用更简短的`for`循环完成——

```cpp
set<int>::iterator iter;
for(iter=s.begin();iter!=s.end();++iter)
	cout<<*iter;
```

有了$\rm{set}$这个工具，再加上$\rm{map}$（喜闻乐见？），这道题就迎刃而解了。

---

> 代码实现

首先定义一个$\rm{string}$映射到$\rm{set}$的$\rm{map}$来统计一个单词在哪几篇短文中出现过：

```cpp
map<string,set<int> > m; //两个'>'之间的空格不能少
//这里我把m用作map了，所以题面中的m后面以p代替
```

然后边输入把短文的序号存入$\rm{set}$中：

```cpp
for(int i=1;i<=n;++i)//i为短文序号
{
    int l;//单词个数
    cin>>l;
    for(int j=0;j<l;++j)
    {
        string s;//单词
        cin>>s;
        m[s].insert(i);
    }
}
```

查询也十分方便：

```cpp
while(p--) //更简短的p次循环
{
    string s;
    cin>>s;
    if(m.count(s)) //如果m中存在元素s
        for(iter=m[s].begin();iter!=m[s].end();++iter)
            cout<<*iter<<" "; //上面提到的迭代器遍历用法
    cout<<endl;
}
```

最后是完整代码：

```cpp
#include<map>
#include<set>
#include<string>
#include<iostream>
using namespace std;

map<string,set<int> > m;
set<int>::iterator iter;

int main()
{
    ios::sync_with_stdio(false); //关闭同步，让cin与cout更高效
	int n,p;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
	    int l;
	    cin>>l;
	    for(int j=0;j<l;++j)
	    {
	        string s;
	        cin>>s;
	        m[s].insert(i);
	    }
	}
	cin>>p;
	while(p--)
	{
	    string s;
	    cin>>s;
	    if(m.count(s))
	        for(iter=m[s].begin();iter!=m[s].end();++iter)
	            cout<<*iter<<" ";
	    cout<<endl;
	}
	return 0;
}
```

$\rm{Done.}$

---

> 附言

$\rm{STL}$确实给$\rm{C}$党带来了许多便利，但是该会的还是要会，不要在$\rm{STL}$中故步自封啊——

最后拿$\rm{NOIp}$的某公告煞尾吧——

[![NOIp对STL的限制？点击查看原文](https://i.loli.net/2018/10/03/5bb4d7bb1430f.png)](http://www.noi.cn/newsview.html?id=229&hash=878FD2&type=6)

$$\mathfrak{-End-}$$

---

## 作者：enceladus (赞：51)


[更佳的阅读体验](https://www.cnblogs.com/enceladus-return0/)

------------

这篇题解求过，虽然没有tire的详细讲解，但会告诉大家数据更新后用tire怎么过，@管理大大。


>这个题的数据**更新了**呢。**所以下面所有关于tire的题解都过不了了**。不过把tire讲的很详细。所以我就不多讲了。

想练习tire的我被卡的一愣愣的qaq。数组开的小了是WA#11.开成1000就是前面十个点随机MLE。

具体怎么用tire过这个题就是**把标记出现的bool数组改成bitset**，节省32倍空间~~，你，值得拥有。~~

_就是别忘了写bitset的专用头文件。定义一个bitset后当二维数组用就好啦。_

最后再丢一个博客
[qwq](https://www.cnblogs.com/zwfymqz/p/8696631.html)

这里有bitset的详细用法，想学的同学了解一下。

------------

最后是代码，除了bitset，就是普通的tire啦。

$Code$
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include <bitset>

using namespace std;

int n,m;
char s[1001];
int l;
int tot=0;
int tri[300007][26];
bitset<1001> b[500007];


inline void insert(char *s,int x){
    int rt=0;
    for(int i=0;s[i];i++){
        int v=s[i]-'a';
        if(!tri[rt][v]){
            tri[rt][v]=++tot;
        }
        rt=tri[rt][v];
    }
    b[rt][x]=1;
}

inline void query(char *s){
    int rt=0;
    for(int i=0;s[i];i++){
        int v=s[i]-'a';
        if(!tri[rt][v]){
            cout<<' '<<endl;
            return;
        }
        rt=tri[rt][v];
    }
    for(int i=1;i<=n;i++){
        if(b[rt][i]==1){
            cout<<i<<' ';
        }
    }
    cout<<endl;
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>l;
        for(int j=1;j<=l;j++){
            cin>>s;
            insert(s,i);
        }
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>s;
        query(s);
    }
    return 0;
}
```

---

## 作者：communist (赞：20)

## 前言：

这个题一直有个疑问，最多一千行，每行五千字$1000\times5000=5e6$

$5e6\times26\times4\div1024\div1024\approx496MB>125MB$

尽管清楚实际空间需求不能到达$5e6$，如何计算直接对文章建$Trie$事实上所需的最大空间呢，本人对此并不清楚，也希望有大佬能为我解决一下这个问题（至于开$5e6\times26$通过的大佬，我想我这种凡人还达不到这个境界）

那么，就请我们权且认为直接对文章建$Trie$在空间上是不被允许的，至少是不够保险的

## 正文：

于是提供一种同样是基于$Trie$的方法——**对询问建$Trie$**

$10000\times20\times26\times4\div1024\div1024\approx20MB$

占空间最多的$Trie$解决了，空间问题就不必担心了

#### 下面我们考虑对询问建$Trie$下这个问题的解决

~~（这不是$Trie$的板子题吗，有什么可考虑的）~~

### 好吧，代码实现细节及一些注意事项，见代码了

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=5e6,maxq=2e5+10;
int cnt,a[maxq][26],n,m;
vector<string>v[1010];
vector<int>ans[10010],val[maxq];
string tmp;
int idx(char c)
{
	return c-'a';
}
void insert(int x)
{
	cin>>tmp;
	int len=tmp.length(),now=0;
	for(int i=0;i<len;i++)
	{
		int c=idx(tmp[i]);
		now=a[now][c]?a[now][c]:a[now][c]=++cnt;
	}
	val[now].push_back(x);
    /*因为可能有相同的查询，这里的简单地用一个
    整形标记就不太合适了，我选择了用vector记录
    这个节点作为所有询问的标记*/
}
void check(int x,int y)
{
	int len=v[x][y].length(),now=0;
	for(int i=0;i<len;i++)
	{
		int c=idx(v[x][y][i]);
		if(!a[now][c])
			return;
            //这个单词一定没有被查询过，直接退回
		now=a[now][c];
	}
	for(int i=0;i<val[now].size();i++)
		ans[val[now][i]].push_back(x);
        //同理在所有询问中保存这个单词曾经出现的文章
}
int main()
{
	scanf("%d",&n);
	for(int i=1,num;i<=n;i++)
	{
		scanf("%d",&num);
		for(int j=1;j<=num;j++)
		{
			cin>>tmp;
			v[i].push_back(tmp);
            //采用了vector来存储原文
		}
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
		insert(i);
	for(int i=1;i<=n;i++)
		for(int j=0;j<v[i].size();j++)
			check(i,j);
	for(int i=1;i<=m;i++)
	{
		vector<int>::iterator pos=unique(ans[i].begin(),ans[i].end());
		for(vector<int>::iterator it=ans[i].begin();it!=pos;it++)
			printf("%d ",*it);
		printf("\n");
	}
    /*这里的输出，因为一篇文章里可能多次出现同一单词，
    记得去重，一开始我用的unique，再输出vector中的
    所有元素。但是unique去重时其实并没有删除这些元素
    在这里也被坑了，所以改用迭代器*/
	return 0;
}
```


---

## 作者：封禁用户 (赞：14)

居然没人发哈希的……虽然这题是Trie的板子题，但是感觉用哈希会更好一些~~其实是因为懒得写Trie树~~，为了保险起见我用了双模数的哈希表，就是每次把单词存到哈希表中，这个哈希表里记录一下在第几篇文章出现的，查找的时候直接到哈希表中找一下就行了，但是考虑到邻接表的构造，它是从外而内按照插入时间从晚到早的顺序，而我们也是从外而内的访问，而题目要求按照从早到晚输出，就拿栈存答案到时候倒过来输出就行了。

然后有2个坑点：

①题上写了“不能重复”，所以插入哈希表的时候先找一下哈希表里是否有出自当前文章的这个单词，这样就不会重复插入了。

②（这个导致我疯狂爆0……）题上写了“每篇短文只含空格和小写字母”，但是他没说查的单词也是这样……所以我们在搞哈希值的时候不能直接直接把单词当做小写字符处理，而是直接把字符值来哈希，并且进制也不能弄成26的。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define p 10000019
#define np 40000000000001
#define pii 10000000007
#define ll long long
#define int long long
using namespace std;
char str[100];
inline int sget(){
	cin>>str;return(strlen(str));
	int ptr=0;char c;while((c=getchar())||1)if(c>='a'&&c<='z')break;
	str[ptr]=c;ptr++;while((c=getchar())||1){
		if(c>='a'&&c<='z'){
			str[ptr]=c;ptr++;
		}else return(ptr);
	}
}
inline void hsh(int len,int &big,int &small,int &mid){
	ll bg=0,sm=0,md=0;
	for(register int i=0;i<len;i++){
		bg=(bg*101+str[i])%np;
		sm=(sm*101+str[i])%p;
		md=(md*101+str[i])%pii;
	}big=bg;small=sm;mid=md;
}
typedef struct _n{int data1;
	int data;int next;int index;
}node;node memchi[1000001];
int heads[10000020];
int stk[10000];
signed main(){int gn=1;
	ll n;cin>>n;
	for(register int i=1;i<=n;i++){
		int k;cin>>k;for(register int j=1;j<=k;j++){
			int len=sget();int big,small,mid;hsh(len,big,small,mid);
			for(register int l=heads[small];l;l=memchi[l].next){
				if(memchi[l].data==big&&memchi[l].index==i&&memchi[l].data1==mid)goto s;
			}
			memchi[gn].next=heads[small];memchi[gn].index=i;memchi[gn].data=big;
			memchi[gn].data1=mid;heads[small]=gn;gn++;s:;
		}
	}int m;cin>>m;
	for(register int i=1;i<=m;i++){
		int len=sget();int big,small,mid;hsh(len,big,small,mid);
		int sp=0;for(register int j=heads[small];j;j=memchi[j].next){
			if(memchi[j].data==big&&memchi[j].data1==mid){
				stk[sp]=memchi[j].index;sp++;
			}
		}
		while(sp){
			sp--;if(sp==0)printf("%d",stk[sp]);
			else printf("%d ",stk[sp]);
		}cout<<endl;
	}
	return(0);
}
```

---

## 作者：su226 (赞：10)

要记录某单词中是否出现在文章中？我的第一反应是用`map<string, bitset<1000>>`

但，如果你真就这样写……TLE90分。

那么考虑优化map的性能。

~~自然O2优化是我们最好的选择，**完**~~

* `map<string, bitset<1000>>` 超时
* `map<string, array<bool, 1000>>` 超时
* `map<string, bitset<1000>>` + O2优化 2.18s 5.69MB
* `map<string, array<bool, 1000>>` + O2优化 2.01s 25.65MB

那还能不能更快呢？

我们都知道GNU提供了比STL更STL的库——pb_ds，里面实现了**哈希表**、优先队列、字典树和平衡树这4种数据结构。

那么我们试试pb_ds？

* `gp_hash_table<string, bitset<1000>>` 2.94s 16.87MB
* `gp_hash_table<string, array<bool, 1000>>` 4.25s 98.68MB
* `cc_hash_table<string, bitset<1000>>` 2.29s 5.40MB
* `cc_hash_table<string, array<bool, 1000>>` 2.06s 25.98MB

这4种组合都能A了，那……搭配O2优化使用？

* `gp_hash_table<string, bitset<1000>>` + O2优化 1.01s 16.75MB
* `gp_hash_table<string, array<bool, 1000>>` + O2优化 2.16s 98.70MB
* `cc_hash_table<string, bitset<1000>>` + O2优化 846ms 5.50MB
* `cc_hash_table<string, array<bool, 1000>>` + O2优化 1.04s 25.83MB

附`cc_hash_table<string, bitset<1000>>`的代码:

```cpp
// luogu-judger-enable-o2
#include <bitset>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <iostream>
#include <string>
using namespace std;
int main() {
  ios::sync_with_stdio(false);
  __gnu_pbds::cc_hash_table<string, bitset<1000>> has;
  int n, m, l;
  string s;
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> l;
    for (int j = 0; j < l; j++) {
      cin >> s;
      has[s][i] = true;
    }
  }
  cin >> m;
  for (int i = 0; i < m; i++) {
    cin >> s;
    for (int j = 0; j < n; j++) {
      if (has[s][j]) {
        cout << j + 1 << ' ';
      }
    }
    cout << endl;
  }
  return 0;
}
```

附录

* STL还有一个`unordered_map`也能过（等等是不是开了O2比pb_ds还快了？~~虽然没开要慢一些~~）
  * `unordered_map<string, bitset<1000>>` 3.19s 5.50MB
  * `unordered_map<string, array<bool, 1000>>` 3.07s 25.52MB
  * `unordered_map<string, bitset<1000>>` + O2优化 816ms 5.56MB
  * `unordered_map<string, array<bool, 1000>>` + O2优化 987ms 25.50MB
* 洛谷日报说`gp_hash_table`快，但我实测时`cc_hash_table`快
* 似乎`bitset`和`array<bool>`谁快还不一定
* _真是一道试STL/pb_ds的~~水~~好题_

---

## 作者：Magallan_forever (赞：8)

# 裸的trie
首先，我们来介绍一下trie：
>又称单词查找树，前缀树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。—百度

trie长这样（根节点没有实际内容）：![](https://s2.ax1x.com/2019/08/20/mJarpF.jpg)

在查找时，直接从根节点出发顺着树往下找就OK，插入也是一样，并且都可以写成迭代的，复杂度$ O(str.length()) $

这是我最爱的数据结构，原因在于其效率非常高，而且可以做很多事情~~其实是因为我觉得这是除树状数组和并查集外最简单的树型结构~~

但trie缺点也相当明显：空间极大，很耗内存，但如果字符串长度很小其实无论时空都很优秀，把map和set吊起来打

（不过我写的是动态的所以内存不算太尴尬）

[~~趁机宣传一下我的trie模板题~~](https://www.luogu.org/problem/U83324)

好了上代码：
```cpp
template<int set_,int mod>//set_是字符集大小
struct trie{
    struct node{
        node* son[set_];
        int flag;
    };//节点，那个flag是防止查找某一字符串不在trie里的前缀时返回错误答案
    //开成int是因为可以重复
    node* root,*ctrl_c;//复制一下后面迭代插入/查找有用
    inline void init(){
        clear(ctrl_c);//清空整棵树，后面有代码
        root=new node(),ctrl_c=root;
    }//使用前请务必调用tree.init();，否则RE
    inline void insert(string line){//插入
        root=ctrl_c;//我直接拿root迭代的
        //由于后面count会返回root->flag，所以不能直接用root迭代
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){//内存不存在，调用构造函数开新内存
                root->son[line[i]%mod]=new node(),root->son[line[i]%mod]->flag=0;//把flag置为0，这个很重要
            }
            root=root->son[line[i]%mod];//往下迭代
        }
        root->flag++,root=ctrl_c;//这个当然是能重置root就重置啊
    }
    inline int count(string line){//查找
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){//内存都没有，显然没有这个字符串
                root=ctrl_c;
                return 0;
            }
            root=root->son[line[i]%mod];//仍然往下迭代
        }
        return root->flag;//有可能我们想count的只是某一个字符串的前缀
        //所以要把flag置为0
    }
    inline void del(string line){//删除
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;//内存都没有
                return;
            }
            root=root->son[line[i]%mod];
        }
        root->flag=(root->flag==0?0:root->flag-1);//如果flag是0那就不管他否则flag--
        root=ctrl_c;
    }
    void clear(node* now){//清空
        if(now==NULL) return;
        for(int i=0;i<set_;i++) if(now->son[i]!=NULL) clear(now->son[i]);//直接dfs暴力递归
        delete now;//调用析构函数&&释放内存
    }
};
```
那么这道题我们开一个trie数组然后每一个询问都count一下就OK了~~反正2秒~~

（事实上跑的贼快）

code:
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
using namespace std;
template<int set_,int mod>
struct trie{
    struct node{
        node* son[set_];
        int flag;
    };
    node* root,*ctrl_c;//复制一下后面迭代查找有用
    inline void init(){
        clear(root);
        root=new node(),ctrl_c=root;
    }
    inline void insert(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){
                root->son[line[i]%mod]=new node(),root->son[line[i]%mod]->flag=0;
            }
            root=root->son[line[i]%mod];
        }
        root->flag++,root=ctrl_c;
    }
    inline int count(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;
                return false;
            }
            root=root->son[line[i]%mod];
        }
        return root->flag;
    }
    inline void del(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;
                return;
            }
            root=root->son[line[i]%mod];
        }
        root->flag=(root->flag==0?0:root->flag-1);
    }
    void clear(node* now){
        if(now==NULL) return;
        for(int i=0;i<set_;i++) if(now->son[i]!=NULL) clear(now->son[i]);
        delete now;
    } 
};
string line;
trie<26,'a'> word[1001];
int main(){
	int n,m,l;
	bool first;
	scanf("%d",&n);
	for(int i=0;i<n;i++) word[i].init();
	for(int i=0;i<n;i++){
		scanf("%d",&l);
		while(l--){
			cin>>line;
			word[i].insert(line);
		}
	}
	scanf("%d",&m);
	while(m--){
		first=true;//输出的技巧
		cin>>line;
		for(int i=0;i<n;i++){
			if(word[i].count(line)){
				if(first){
					first=false;
				}
				else{
					printf(" ");
				}
				printf("%d",i+1);
			}
		}
		printf("\n");
	}
	return 0;
}
```
[评测记录](https://www.luogu.org/record/22996275)

---

## 作者：LevenKoko (赞：5)

看了看题解，感觉要么是很奇怪的hash，剩下的大多数是裸的stl和直接上字典树，然后我用$vector$+$hash$水过去了

时间复杂度$O(nmlogm)$都超过1e9了qwq然而显然跑不满

我们把每一个短文里的单词hash了之后丢到vecotr里面去，然后之后判断每一个vector里面是否有要查询的单词即可

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define writeln(x)  write(x),puts("")
#define writep(x)   write(x),putchar(' ')
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int M = 1e4+5;
 const ull B = 13331;
int n,m;char s[60];
vector<ull>mp[M];
inline ull Hash(char *s){
	int len=strlen(s+1),ans=0;
	for(int i=1;i<=len;i++)ans=ans*B+s[i];
	return ans;
}int main(){
	n=read();
	for(int i=1;i<=n;i++){
		m=read();
		while(m--)scanf("%s",s+1),mp[i].push_back(Hash(s));
		sort(mp[i].begin(),mp[i].end());
	}m=read();
	for(int i=1;i<=m;i++){
		scanf("%s",s+1);
		ull now=Hash(s);
		for(int i=1;i<=n;i++)
			if(*lower_bound(mp[i].begin(),mp[i].end(),now)==now)
				printf("%d ",i);
		puts("");
	}return 0;
}
```

---

## 作者：loveJY (赞：3)

~~第一篇题解qwq~~


~~翻遍题解区都没找到完全相同的呢,和STL以及Trie的做法有些不同?~~

我们先仔细观察数据范围,给出文章总共有5000000个字符,查询总共有200000个字符,单词数总共250000个

>那么根据字符大小,得到以下做法

1.根据字符集的大小我们首先可以得到一个广义后缀自动机的做法,相当于将文章插入自动机里,然后查询直接在自动机上跑

统计则也有两种做法,可以离线同时处理所有询问,也可以在线用bitset

但是,这非常不棒,~~也应该过不了~~,因为没有利用题目`简单出现`的性质qaq~~但是这样可以做文章单词中一部分出现,就是是作为一个子串出现~~

2.查询字符小,我们可以把查询单词插入AC自动机里,然后拿文章上去匹配,这样强制离线...

~~但是能过qwq~~

3.至于Trie~~其实被自动机包含?~~...题解区其他已经够详细了吧....

>根据单词数大小:

我们仅仅要求`一整个`单词在那些文章中出现

所以自然而然的想到把单词$hash$起来,得到一个值

问题就变成一个值在哪些集合中出现了

单个集合可以二分查找,但如果每个集合都去二分复杂度未免太高

所以把所有集合的元素放在一起二分,我们得到的一段值相等的区间,对应元素属于哪个集合就是答案.

复杂度就变成了$O(mlog\sum{p_i})$,$p_i$是文章i单词数

## 注意hash冲突 ##

#### 竟然会卡qaq ####

code:~~可以无视fastIO部分~~

```cpp

//From: Dawn Light
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ull unsigned long long
using std::sort;
using std::unique;
const ull p=1926081719260815;//模数太小会被卡qaq
const int MAXN=5e6+7;
const int MAXM=10000;
const int base=1926;

struct HASH {
	ull val;
	int id;
	HASH():val(0),id(0) {};
	bool operator<(const HASH&x) {
		return val==x.val?id>x.id:val<x.val;
	}
} _hash[MAXN];

namespace fastIO {
#define BUF_SIZE 100000
	static char buf[BUF_SIZE],*p1=BUF_SIZE+buf,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}

	inline int read() {
		int x=0;
		register char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x<<1)+(x<<3)+s-'0';
		return x;
	}

	inline int read(char *s) {
		int nw=1;
		s[nw]=0;
		for(; !isalpha(s[nw]); s[nw]=nc());
		for(; isalpha(s[nw]);)++nw,s[nw]=nc();
		return (nw-1);//skip \n, ,\t....
	}
#undef BUF_SIZE
}//qwqIO
using namespace fastIO;

char s[MAXM];
int T,n,m;

inline int Bs(ull k) {//Binary Search 缩写
	register int l=1,r=T,mid,ans;
	while(l<=r) {
		mid=(l+r)>>1;
		if(_hash[mid].val<=k) {
			l=mid+1;
			ans=mid;
		} else r=mid-1;
	}
	return ans;
}

int main() {
	n=read();
	for(register int i=1,num,l; i<=n; ++i) {
		num=read();
		for(register int j=1; j<=num; ++j) {
			l=read(s);
			++T;
			_hash[T].id=i;
			for(register int k=1; k<=l; ++k) {
				_hash[T].val=(_hash[T].val*base%p+s[k])%p;
			}
		}
	}//处理hash
	sort(_hash+1,_hash+T+1);
	for(int i=1; i<=T; ++i) {
		if(_hash[i].val==_hash[i-1].val&&_hash[i].id==_hash[i-1].id) {
			_hash[i-1].val=p;
		}
	}
	sort(_hash+1,_hash+T+1);
	for(; _hash[T].val==p; --T);
	//排序,去重
	m=read();
	ull tmp=0;
	for(register int i=1,l; i<=m; ++i) {
		l=read(s);
		tmp=0;
		for(register int k=1; k<=l; ++k) {
			tmp=(tmp*base%p+s[k])%p;
		}
		int g=Bs(tmp);
		register int j;
		for(j=g; _hash[j].val==tmp; --j) printf("%d ",_hash[j].id);//得到一段区间,输出答案
		puts("");
	}
	return 0;
}

```


---

## 作者：晚安晚安 (赞：3)

下午刚学了trie树，晚上写了这个题。


刚看到这个题想到的是设个二维数组存根，但果断就排除了，然后就想能不能用一维数组来存根，于是就有了这样一篇代码（解释都在代码中，看不懂的可以私信我）。

奉上有注释的ac代码：
```
#include<bits/stdc++.h>
using namespace std;

const int N = 500000;
char s[100];
int cnt;
char cha[10000+10][25];

struct Tire{
	bool word;
	int son[26];//树的儿子
}trie[N];

void intsert(int gen, char s[])
{
	int xin = gen;
	int n = strlen(s);
	for(int i = 0; i < n; i++)
	{
		int x = s[i] - 'a';
		if(trie[xin].son[x] == 0)
			trie[xin].son[x] = ++cnt;
		xin = trie[xin].son[x];
	}
	trie[xin].word = 1;
}

bool match(int gen, char cha[])
{
	int xin = gen;
	int n = strlen(cha);
	for(int i = 0; i < n; i++)
	{
		int x = cha[i] - 'a';
		if(trie[xin].son[x] == 0)return 0;
		else 
			xin = trie[xin].son[x];
	}
	if(trie[xin].word == 1)return 1;
	else return 0;
}

int main()
{	
	int n, m, wc;
	scanf("%d", &n);
	cnt = n;//cnt是标号，因为要存多个根，每篇文章有一个根，所以cnt从n开始
	for(int i = 1; i <= n; i++)//读入文章
	{
		scanf("%d", &wc);
		for(int j = 1; j <= wc; j++)
		{
			scanf("%s", s);
			intsert(i, s);//i是根的标号然后直接走trie树流程
		}
	}
	scanf("%d", &m);
	for(int i = 1; i <= m; i++)
	{	
		scanf("%s", cha[i]);//用cha数组读入要查找的单词
	}
	bool you = 0;//因为前后都不能有空格（题目要求）所以要记录一下
	for(int i = 1; i <= m; i++)//然后一个单词一个单词的找
	{	for(int j = 1; j <= n; j++)
			{
				if(match(j, cha[i]) && you == 0){cout<<j;you = 1;continue;}
				else if(match(j, cha[i]))cout<<" "<<j;
			}
		cout<<endl;
		you = 0;
	}
	return 0;
}
```

---

## 作者：Qglin_ (赞：2)

简单地读题可知，这是一道非常简单的Trie树板子题。

那我们也不考虑这么多了，直接暴力一点吧。

观察到每篇短文长度$\le5000$，$N\le1000$，$M\le10000$

那么我们直接维护1000个5000节点的Trie树，每个Trie树存储一段短文，每次查询就从头枚举一遍每一篇短文，按照题目找到答案就输出，然后换行，在这个数据强度下是可以通过此题的。

贴代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

inline int fd() {//快读
	int x = 0, f = 1; char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') f = -f; ch = getchar();}
	while(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}
	return x * f;
}

struct trie {
	struct node {
		int son[26];
		bool fin;
	} nd[5010];
	int sum;
	void insert(char *s) {
		int v, len = strlen(s), u = 0;
		for(int i = 0; i < len; ++i) {
			v = s[i]-'a';
			if(!nd[u].son[v]) nd[u].son[v] = ++sum;
			u = nd[u].son[v];
		}
		nd[u].fin = 1;
	}
	bool tfind(char *s) {
		int u = 0, v, len = strlen(s);
		for(int i = 0; i < len; ++i) {
			v = s[i]-'a';
			if(!nd[u].son[v]) return false;
			u = nd[u].son[v];
		}
		if(nd[u].fin) return true;
		return false;
	}
}T[1005];//结构体封装1005个Trie树，多开一点保险

char s[5005];//用来输入
int n, m;

int main() {
	n = fd();
	for(int i = 1; i <= n; ++i) {/*按照每行输入的格式处理，输入一个单词并将它插入对应短文编号的Trie树*/
		m = fd();
		for(int j = 1; j <= m; ++j) {
			scanf("%s",s);
			T[i].insert(s);
		}
	}
	m = fd();
	for(int i = 1; i <= m; ++i) {
		scanf("%s",s);
		for(int j = 1; j <= n; ++j) {
			if(T[j].tfind(s)) printf("%d ",j);/*查找单词，如果找到了就输出当前短文编号*/
		}
		putchar('\n');
	}
	return 0;//完美结束
}
```
~~果然暴力做法是这个世界上最美的做法~~

---

## 作者：andyli (赞：2)

~~这题难道没人用平板电视（`pb_ds`）吗~~  
思路：~~没思路~~  
就是用系统自带的`pb_ds`库，然后就没有然后了。  
代码如下：  
```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/trie_policy.hpp> // pb_ds头文件
#include <iostream>
#include <string>
using namespace __gnu_pbds; // pb_ds名称空间
using namespace std;

typedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> Trie;
Trie tr[1001];
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int siz;
        cin >> siz;
        for (int j = 0; j < siz; j++)
        {
            string tmp;
            cin >> tmp;
            tr[i].insert(tmp); // 插入到字典树中
        }
    }
    int m;
    cin >> m;
    for (int i = 0; i < m; i++)
    {
        string tmp;
        cin >> tmp;
        for (int i = 0; i < n; i++)
            if (tr[i].find(tmp) != tr[i].end()) // 如果找到，就输出
                cout << i + 1 << " ";
        cout << endl;
    }
    return 0;
}
```
很简单吧！  
最后，如果要在NOIP中使用pb_ds库，切记不能加`using namespace __gnu_pbds;`，需要在用到的时候加上`__gnu_pbds::`。

---

## 作者：attack (赞：2)

map的裸题

可以写map<string,vector>

但是我不会写，就自己定义了个结构体

对于每一个字符串的读入

不要忘记判断该序号是否已经出现过#include<cstdio>

```cpp
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<iostream>
using namespace std;
const int MAXN=1e6+10;
inline int read()
{
    char c=getchar();int flag=1,x=0;
    while(c<'0'||c>'9')    {if(c=='-')    flag=-1;c=getchar();}
    while(c>='0'&&c<='9')    x=x*10+c-48,c=getchar();return x*flag;
}
int n,m;
struct node
{
    int happen[438];
    int time;
};
map<string,node>mp;
inline void pd(string a,int pos)
{
    if(mp[a].happen[mp[a].time]==pos)    return ;//注意序号不能重复 
    mp[a].happen[++mp[a].time]=pos;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        int num=read();
        string a;
        for(int j=1;j<=num;j++)
            cin>>a,pd(a,i);
    }
    m=read();
    for(int i=1;i<=m;i++)
    {
        string a;cin>>a;
        for(int i=1;i<=mp[a].time;i++)
            printf("%d ",mp[a].happen[i]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：ChinaNB (赞：1)

~~楼下的 `dalao` 们代码怎么都那么长~~

### 思路：使用 C++ 的 `map` 代替字典树，开一个 `map<string, vector<int> >`。

**要注意：题目里要求去重，所以每次存单词的时候判断当前文章里有没有出现过这个单词，只有没有出现过得情况才加进去。**

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
struct FastReader {
    inline int Int() {int ch,nag=0,x=0;while(!isdigit(ch=getchar()))nag=ch=='-';x=ch-'0';while(isdigit(ch=getchar()))x=x*10+ch-'0';return nag?-x:x;}
    inline ll Long() {ll ch,nag=0,x=0;while(!isdigit(ch=getchar()))nag=ch=='-';x=ch-'0';while(isdigit(ch=getchar()))x=x*10+ch-'0';return nag?-x:x;}
    inline ll Mod(ll P) {ll ch,nag=0,x=0;while(!isdigit(ch=getchar()))nag=ch=='-';x=(ch-'0')%P;while(isdigit(ch=getchar()))(x=x*10+ch-'0')%=P;return nag?-x:x;}
    inline long double Double() {ll a=Int(),b=0,c=1,ch;while(isdigit(ch=getchar()))b=b*10+ch-'0',ch*=10;return a+1.*b/c;}
    inline ll DoubleInt(ll bs=-1) {ll a=Int(),b=0,c=1,ch;while(isdigit(ch=getchar()))b=b*10+ch-'0',ch*=10;return bs==-1?a*c+b:a*bs+b;}
    inline char Alpha() {char ch;while(!isalpha(ch=getchar()));return ch;}
    inline char Char() {char ch; while( isspace(ch=getchar()));return ch;}
    inline char Digit() {char ch;while(!isdigit(ch=getchar()));return ch;}
    inline int CStr(char*c) {scanf("%s",c);return strlen(c);}
    inline int Str(string&s,int len=3000) {char buf[len];int l=CStr(buf);s=buf;return l;}
    inline ll operator()() { return Long(); }
    inline int operator()(char*c) { return CStr(c); }
    inline int operator()(string&s,int len=3000) { return Str(s,len); }
} R;
struct FastWriter {
    inline FastWriter& Int(ll x) {if(x<0){putchar('-');return Int(-x);}if(x/10)Int(x/10);putchar(x%10+'0');return *this;}
    inline FastWriter& Char(char x) {putchar(x);return *this;}
    inline FastWriter& Str(const char*x) {printf("%s",x);return *this;}
    inline FastWriter& StrE(const char*x) {puts(x);return *this;}
    inline FastWriter& Eoln() {putchar('\n');return *this;}
    inline FastWriter& operator()(int x) { return Int(x); }
    inline FastWriter& operator()(char x) { return Char(x); }
    inline FastWriter& operator()(ll x) { return Int(x); }
    inline FastWriter& operator()(const char*x) { return Str(x); }
} W;

map<string, vector<int> > M;
map<string, bool> T;

int main() {
	for (int n=R(), i=1; i<=n; i++) {
        T.clear();
		int c = R(); while (c--) {
			string p; R(p);
			if (!T[p]) T[p] = 1, M[p].push_back(i);
		}
	}
	for (int m=R(); m--; ) {
		string p; R(p);
		for (int i=0; i<M[p].size(); i++) W(M[p][i]).Char(' ');
		W.Eoln();
	}
	return 0;
}

```

---

## 作者：弦巻こころ (赞：1)

#### 这道题过法很多有$Trie$树，$AC$自动机，$map$，$hash$等。

由于我最近在补字符串所以我们就讲~~AC自动机~~  ,$Trie$树写法吧。

~~这道题其实就是个Trie树板子题，还挺裸的。~~

题意：给你$n$个模式串，模式串中有许多单词，再给你$m$个文本串。问你有多少个文本串在模式串中的单词中出现。

~~我相信大家都会打Trie树所以我就不讲了吧~~

思路：对于模式串中的每个单词，我们直接以此建$Trie$树（每个单词分别建），对串尾打个标记。然后在$Trie$树上跑$dfs$，来找它对应的单词。~~跟一般Trie树没什么区别嘛。。。~~

这道题的主要两个坑点

1.卡空间（开$bitset$或者$vector$）

2.判重，对于每个模式串要判重，不然会重复输出。、

还有我想吐槽的一点是

```
（注意第一个序号的前面和最后一个序号的后面不应有空格）
```

根本就没有这件事好吧，我特判了反而$RE$了，我太菜了$orz$。

我觉得代码比我讲得更清楚。~~语文没上过年排的蒟蒻~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt[10005],trie[5000005][26],fail[5000005];
int n,m,ans,tot,L;
vector<int>num[500005];
char s[25],str[20005];
void make_trie(char s[25],int Num)
{
	int len=strlen(s),now=0;
	for(int i=0;i<len;i++)
	{
		int next=s[i]-'a';
		if(!trie[now][next])
		{
			trie[now][next]=++tot;
		}
		now=trie[now][next];
	}
	if(num[now].empty())//注意判重和数组越界问题
	{
		num[now].push_back(Num);
		return;
	}
	int l=num[now].size();
	if(num[now][l-1]!=Num)
	{
		num[now].push_back(Num);
	}
}
void dfs(int now,int x)//直接在trie树上搜，找答案。
{
	int next=str[x]-'a';
	if(x==L)//如果搜到了
	{
		ans=now;
		return ;
	}
	now=trie[now][next];
	if(now)//如果下一位仍在trie树中存在
	{
		dfs(now,x+1);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int all;
		scanf("%d",&all);
		for(int j=1;j<=all;j++)
		{
			scanf("%s",s);
			make_trie(s,i);//对于每个单词分别建trie树
		}
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		ans=0;//ans记得清0
		scanf("%s",str);
		L=strlen(str);
		dfs(0,0);//大力爆搜
		if(ans==0)
		{
			printf("\n");
			continue;
		}
		int l=num[ans].size();
		for(int k=0;k<=l-1;k++)
		{
			printf("%d ",num[ans][k]);
		}
		if(i!=m){printf("\n");}
	}
}
```




---

## 作者：Drifterming (赞：1)

发个题解吧。

没什么意思的题。

trie、AC自动机、map、set都可以。

讲一下set+hash吧。

也没什么可讲的。

只选一个base=233会WA掉全部的点，所以用两个base，一个是233，一个是311.
然后set里扔pair，一个文章一个set。

- 吸氧1400+ms，不吸4000+ms。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<set>
using namespace std;

typedef long long LL;
typedef unsigned long long ULL;

inline int read()
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar())
        f=c=='-'?-1:f;
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num*f;
}

const int N=1e3+5;
const int bas=233,sab=311;

int n,m,l;char s[23];
set<pair<ULL,ULL> > st[N];

int main()
{
    n=read();ULL hs,sh;
    for(int z=1;z<=n;++z)
    {
        l=read();
        for(int a=1;a<=l;++a)
        {
            scanf("%s",s);hs=sh=0;
            for(int i=0;s[i];++i) hs=hs*bas+s[i]-'a',sh=sh*sab+s[i];
            st[z].insert(make_pair(hs,sh));
        }
    }
    m=read();
    while(m--)
    {
        scanf("%s",s);hs=sh=0;
        for(int i=0;s[i];++i) hs=hs*bas+s[i]-'a',sh=sh*sab+s[i];
        bool flag=0;pair<ULL,ULL> t=make_pair(hs,sh);
        for(int i=1;i<=n;++i)
        {
            if(st[i].find(t)!=st[i].end())
            {
                if(!flag) cout<<i,flag=1;
                else cout<<' '<<i;
            }
        }
        puts("");
    }
    return 0;
}
```

- 当然我们也可以直接存字符串的出现位置，也就是把pair存到map里，对应一个set。

- 这样写吸氧仅有343ms，不吸也只有771ms！

```cpp

#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
using namespace std;

typedef long long LL;
typedef unsigned long long ULL;

inline int read()
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar())
        f=c=='-'?-1:f;
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num*f;
}

const int N=1e3+5;
const int bas=233,sab=311;

int n,m,l;char s[23];
map<pair<ULL,ULL>,set<int> > st;
set<int>::iterator it,iter;

int main()
{
    n=read();ULL hs,sh;
	for(int z=1;z<=n;++z)
    {
        l=read();
        for(int a=1;a<=l;++a)
        {
            scanf("%s",s);hs=sh=0;
            for(int i=0;s[i];++i) hs=hs*bas+s[i]-'a',sh=sh*bas+s[i];
            st[make_pair(hs,sh)].insert(z);
        }
    }
    m=read();
    while(m--)
    {
        scanf("%s",s);hs=sh=0;
        for(int i=0;s[i];++i) hs=hs*bas+s[i]-'a',sh=sh*bas+s[i];
        bool flag=0;
        it=st[make_pair(hs,sh)].begin(),iter=st[make_pair(hs,sh)].end();
        for(;it!=iter;++it)
        {
        	if(!flag) flag=1,cout<<*it;
        	else cout<<' '<<*it;
		}
        puts("");
    }
    return 0;
}
```

---

## 作者：ghj1222 (赞：1)

字符串哈希吼啊

把所有书本里出现的单词哈希 用set存

然后对于每个单词依次找是否存在对应哈希值即可

注意为了保证安全，要双哈希

膜一个质数是比较吼的

所以我这里膜了两个质数

下面是乱七八糟的代码QAQ

```cpp
#include <bits/stdc++.h>
using namespace std;

const int p1 = 19260817;
const int p2 = 20020303;
const int base = 233;

set<int> fuck1[1010], fuck2[1010];

int n;

int main()
{
	scanf("%d", &n);
	for (int x, i = 1; i <= n; i++)
	{
		scanf("%d", &x);
		char sb[1000];
		for (int j = 1; j <= x; j++)
		{
			scanf("%s", sb);
			int len = strlen(sb);
			long long tot1 = 0, tot2 = 0;
			for (int i = 0; i < len; i++)
			{
				tot1 = (tot1 * base + sb[i]) % p1;
				tot2 = (tot2 * base + sb[i]) % p2;
			}
			fuck1[i].insert(tot1);
			fuck2[i].insert(tot2);
		}
	}
	int m; scanf("%d", &m);
	for (int i = 1; i <= m; i++)
	{
		char sb[1000];
		scanf("%s", sb);
		int len = strlen(sb);
		long long tot1 = 0, tot2 = 0;
		for (int i = 0; i < len; i++)
		{
			tot1 = (tot1 * base + sb[i]) % p1;
			tot2 = (tot2 * base + sb[i]) % p2;
		}
		for (int j = 1; j <= n; j++)
			if (fuck1[j].count(tot1) && fuck2[j].count(tot2))
				printf("%d ", j);
		printf("\n");
	}
	return 0;
}

```

---

## 作者：flyinglandlord (赞：1)

~~这一题思路很简单~~

就是用STL的`map`和`vector`

`map`映射，`vector`表示在第几篇短文中出现

还有，注意输出是个坑：

> 对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开**（注意第一个序号的前面和最后一个序号的后面不应有空格）**。如果该单词一直没出现过，则输出一个空行。对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。

定义这么定义 ：`map<string, vector < int > >`

代码如下： (\*~~**思路很乱**~~\*)

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <string>
#include <cstring>
#include <vector>
using namespace std;

int word_num;

class Word_Find {
    public :
        #define maxn 10000
        map <string, vector <int> > list;
    public : int Readin(int num) {
        int t = 0;
        while (num--) {
            t++;
            int n;
            cin >> n;
            for(int i=1;i<=n;i++) {
                string word;
                cin >> word;
                list[word].resize(word_num);
                list[word][t] = 1;
            }
        }
    }
    public : int find(int num, int sentence) {
        for(int i=1;i<=num;i++) {
            string word;
            cin >> word;
            if(!list.count(word)) {
                cout << endl;
                continue;
            }
            int print[maxn];int tot = 0;
            memset(print, 0 ,sizeof(print));
            for(int i=1;i<=sentence;i++) {
                if(list[word][i] == 1) {
                    tot++;
                    print[tot] = i;
                }
            }
            for(int i=1;i<=tot;i++) {
                cout << print[i];
                if(i!=tot) cout << ' ';
            }
            if(i!=num)cout << endl;
        }
    }
}solver;

int main() {
    ios::sync_with_stdio(false);
    int sentence, query;
    cin >> sentence;
    word_num = sentence;
    solver.Readin(sentence);
    cin >> query;
    solver.find(query, sentence);
    return 0;
}
```

---

## 作者：jzqjzq (赞：1)

<a href="http://blog.csdn.net/jzq233jzq/article/details/77606237">我的blog</a>

一开始我感觉好像可以用set搞一搞的

然后发现迭代器我实在不太会用。。。

而且到底set怎么存我也不大有数

后来想了想，还是Trie靠谱

就是在结束标记记录一下这里有多少文章有这个单词就好了

感觉set原理也是一样的


```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <ctime>
#include <map>
#include <queue>
#include <cstdlib>
#include <string>
#include <climits>
#include <set>
#include <vector>
using namespace std;
inline int read(){
    int k=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
    return k*f;
}
char s[10010];
int nex[500010][26],n,cnt=0;
bool b[500010][110];
inline void insert(int x){
    scanf("%s",s+1);int l=strlen(s+1);
    int now=0;
    for(int i=1;i<=l;i++){
        int p=s[i]-'a';
        if(!nex[now][p])nex[now][p]=++cnt;
        now=nex[now][p];
    }
    b[now][x]=1;
}
inline void check(){
    scanf("%s",s+1);int l=strlen(s+1);
    int now=0,flag=1;
    for(int i=1;i<=l;i++){
        int p=s[i]-'a';
        if(!nex[now][p]){flag=0;break;}
        now=nex[now][p];
    }
    if(flag)for(int i=1;i<=n;i++)if(b[now][i])printf("%d ",i);
    puts("");
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++){
        int x=read();
        for(int j=1;j<=x;j++)insert(i);
    }
    int m=read();
    for(int i=1;i<=m;i++)check();
    return 0;
}
```

---

## 作者：若如初见 (赞：1)

看到题解区里的主流做法都是 map + vector 或者 trie 树，本蒟蒻来写一个不一样的做法：map + 数组模拟链表。  

我们利用 map 容器将读入的每一个字符串映射为一个数字，然后对于每一个字符串，我们只需要边读入边记录每个字符串在哪些文章中出现过。即，如果字符串的编号为 $s_1,s_2,s_3,...$ ，文章编号为 $p_1,p_2,p_3,...$ ，我们只需记录若干个二元组 $(s_i,p_{x_i})$ ，代表编号为 $s_i$ 的字符串在文章 $p_{x_i}$ 中出现过。最后对于每次询问的字符串 $s_i$ ，我们找出所有的二元组 $(s_i,p_{x_i})$ 即可。那么问题的关键在于，如何快速找出来呢？  

可以回想起我们在刚学图论的时候，都一定要知道**链式前向星**这种存图的方法。在遍历一张图的时候，我们往往需要以某个点 $u_i$ 为起点的所有边的信息——这不是和本题需要存储的信息很类似吗？  

于是，对链式前向星稍加改造，就得到了本题所需要的数组模拟链表。不过，链式前向星加边的顺序和遍历的顺序是相反的，所以在输出时需要注意。还有，同一个单词可能在一篇文章中出现多次，这点细节也要留意。

具体内容请看代码：  

```cpp
#include <iostream>
#include <string>
#include <map>
#define MAXN 50005
#define rint register int //卡常
using namespace std;
int head[MAXN],ans[MAXN];
map <string,int> mp; //用来将字符串映射为一个编号的map
string s;
int n,m,t,tot,cnt,idx;
struct Link{ //链式前向星，数组模拟链表
	int next,val;
}list[MAXN];
inline void add(int u,int v){ //板子
	list[++cnt].next=head[u];
	list[cnt].val=v;
	head[u]=cnt;
}
int main(){
	ios::sync_with_stdio(0); //加速cin和cout语句
	cin >> n;
	for(rint i=1;i<=n;++i){
		cin >> t;
		for(rint j=1;j<=t;++j){ //读入并存储每个单词的信息
			cin >> s;
			if(!mp[s]) mp[s]=++tot; //如果还没有出现过，就给单词赋予一个编号
			add(mp[s],i); //加入链表
		}
	}
	cin >> m;
	while(m--){
		cin >> s;
		idx=0;
        //遍历顺序和存储顺序相反，所以要倒序输出
		for(rint i=head[mp[s]];i;i=list[i].next)
			if(ans[idx]!=list[i].val) //去重
				ans[++idx]=list[i].val;
		for(rint i=idx;i>=1;--i)
			cout << ans[i] << " ";
		cout << "\n";
	}
	return 0;
}
```


---

## 作者：Fuko_Ibuki (赞：1)

用字典树哪来那么多奇怪的问题?一下轻松AC.
```cpp
#include<bits/stdc++.h>
namespace chtholly{
typedef long long ll;
#define re0 register int
#define rec register char
#define rel register ll
#define gc getchar
#define pc putchar
#define p32 pc(' ')
#define pl puts("")
/*By Citrus*/
inline int read(){
  int x=0,f=1;char c=gc();
  for (;!isdigit(c);c=gc()) f^=c=='-';
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return f?x:-x;
  }
template <typename mitsuha>
inline bool read(mitsuha &x){
  x=0;int f=1;char c=gc();
  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';
  if (!~c) return 0;
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return x=f?x:-x,1;
  }
template <typename mitsuha>
inline int write(mitsuha x){
  if (!x) return 0&pc(48);
  if (x<0) x=-x,pc('-');
  int bit[20],i,p=0;
  for (;x;x/=10) bit[++p]=x%10;
  for (i=p;i;--i) pc(bit[i]+48);
  return 0;
  }
inline char fuhao(){
  char c=gc();
  for (;isspace(c);c=gc());
  return c;
  }
}using namespace chtholly;//快读快写我们不管它.
using namespace std;
const int yuzu=1e4;
char c[yuzu|10];

struct trie{//这是一棵trie树.
int sz;
struct node{
  int ch[26];
  set<int> cnt;//我正在考虑怎么存放这个结点表示的单词出现在哪些文章里,想想用一个set就可以了.
  }r[yuzu<<5|13];//开了这么多结点.
void insert(char *s,int k){//插入函数,k是它所属的文章编号.
  int len=strlen(s),i,p,now=0;
  for (i=0;i<len;++i){
    p=s[i]-'a';
    if (!r[now].ch[p]) r[now].ch[p]=++sz;
    now=r[now].ch[p];
    }
  r[now].cnt.insert(k);
  }
void query(char *s){
  int len=strlen(s),i,p,now=0;
  for (i=0;i<len;++i){
    p=s[i]-'a';
    if (!r[now].ch[p]) return;//没找到这个单词,直接跳出.没想到数组越界竟然没发生一些非常奇怪的问题,我非常震惊.
    now=r[now].ch[p];
    }
  for (auto q:r[now].cnt) write(q),p32;//询问到它的时候直接找个东西遍历一下set输出里面的所有东西.
  }
}my_;

int main(){
for (int n=read(),i=1;i<=n;++i){
  for (int k=read();k--;){
    scanf("%s",c);
    my_.insert(c,i);
    }
  }
for (int m=read();m--;){
  scanf("%s",c);
  my_.query(c),pl;
  }
}//普通地插入和普通的询问,然后普通地AC.谢谢大家.
```

---

## 作者：Hatsune_Miku (赞：1)

据说本题是一个 ``普及/提高-`` 的题目？蒟蒻我表示很震惊啊。这明明是Trie树的板子题啊~~（好像Trie树全都是模板题）~~。

其实这道题目是我旁边一位dalao推荐我做的，又因为好久不写数据结构题了，然后就选择了这么一道水题来写。

其实感觉Trie树没有什么好说的，大体思路就是直接模拟一下，把字符串的每一个字符丢到一棵树上，然后查找就是遍历一遍这棵树。一般情况下字符串匹配问题在空间不是非常紧张的情况下都是可以使用Trie进行快速的匹配的。当然Trie树还有更多奇奇怪怪的用途~~（可以出各种各样奇奇怪怪的题目）~~。

主要操作大概就是一个插入和查找的操作。可以参考dalao的题解学习。要通过这道题仅仅需要在Trie的每个节点上添加一个 ``vector<int>`` 记录一下每个单词在哪些句子中出现过就行了~~（可能是指针党的福利？）~~。

附上不清真的指针版Trie树代码：
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
using namespace std;
namespace trie{
	struct node{
		node *nxt[26];
		bool isStr;
		vector<int>v;
		node(){
			memset(nxt,0,sizeof nxt);
			v.clear();
		}
	};
	inline void insert(node *root,char *str,int cnt){
		if(!root||!*str)return;
		while(*str){
			int p=*str-'a';
			if(!root->nxt[p])root->nxt[p]=new node();
			root=root->nxt[p];
			++str;
		}
		if(!root->v.size()||*(root->v.end()-1)!=cnt)root->v.push_back(cnt);
	}
	inline void find(node *root,char *str){
		if(!root||!*str)return;
		while(*str){
			int p=*str-'a';
			if(!root->nxt[p])return;
			root=root->nxt[p];
			++str;
		}
		for(vector<int>::iterator it=root->v.begin();it!=root->v.end();++it)
			printf("%d ",*it);
	}
}
using namespace trie;
char s[25];
int n,m,l;
int main(){
	node *root=new node();
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&l);
		while(l--){
			scanf("%s",s);
			insert(root,s,i);
		}
	}
	scanf("%d",&m);
	while(m--){
		scanf("%s",s);
		find(root,s);
		puts("");
	}
	return 0;
}
```
~~（不要吐槽代码风格了）~~

---

## 作者：Doubeecat (赞：0)

这题是一题很好的`Trie`与`bitset`的练手题  
显然，我们先把所有的单词插入一棵`Trie`树中，而关于题目打印在哪些文章中出现的话，第一思路：对每个节点（最坏情况）开一个`vector`，在插入时将文章号插入到对应的`vector`中。  
代码如下：
```cpp
#include <cstdio>
#include <cctype>
#include <queue>
#include <stack>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
#define MAXN 500100
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;

inline int read() {
    int a=0,f=1;char v=getchar();
    while(!isdigit(v)) {if (v == '-') {f = -1;}v = getchar();}
    while (isdigit(v)) {a = a * 10 + v - 48;v = getchar();}
    return a * f;
}

int n,m;
char s[MAXN];

int trie[MAXN][26],en[MAXN],tot = 1;
vector <int> f[MAXN];

inline void insert(char *s,int q) {
    int p = 1,len = strlen(s);
    for (int k = 0;k < len;++k) {
        int ch = s[k]-'a';
        if (trie[p][ch] == 0) {
            trie[p][ch] = ++tot;
        }
        p = trie[p][ch];
    }
    en[p] = 1;f[p].push_back(q);
}

inline void find(char* s) {
    int p = 1,len = strlen(s);
    bool flag = 1;
    for (int k = 0;k < len;++k) {
        p = trie[p][s[k]-'a'];
        if (p == 0) {
            flag = 0;
            break;
        }
    }
    if (flag) {
    	int siz = f[p].size();
    	for (int i = 0;i < siz;++i) {
    		printf("%d ",f[p][i]);
        }
    }
    puts("");
}

int main() {
    n = read();
    for (int i = 1;i <= n;++i) {
        int g = read();
        for (int j = 1;j <= g;++j) {
            cin >> s;
            insert(s,i);
        }
    }
    m = read();
    for (int i = 1;i <= m;++i) {
        cin >> s;
        find(s);
    }
    return 0;
}
```
这样有什么问题呢？  
作者第一遍就是这么写的，然而却WA了。（原因欢迎大家在评论区探讨）  
所以我们考虑其他做法：开一个`bool`数组，每查询到一个单词的结尾，就扫一遍这个单词的`bool`数组并打印出来对应的文章号。  
```cpp
#include <cstdio>
#include <cctype>
#include <queue>
#include <stack>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
#define MAXN 500100
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;

inline int read() {
    int a=0,f=1;char v=getchar();
    while(!isdigit(v)) {if (v == '-') {f = -1;}v = getchar();}
    while (isdigit(v)) {a = a * 10 + v - 48;v = getchar();}
    return a * f;
}

int n,m;
char s[MAXN];

int trie[MAXN][26],en[MAXN],tot = 1;
bool f[MAXN][1100];

inline void insert(char *s,int q) {
    int p = 1,len = strlen(s);
    for (int k = 0;k < len;++k) {
        int ch = s[k]-'a';
        if (trie[p][ch] == 0) {
            trie[p][ch] = ++tot;
        }
        p = trie[p][ch];
    }
    en[p] = 1;f[p][q] = 1;
}

inline void find(char* s) {
    int p = 1,len = strlen(s);
    bool flag = 1;
    for (int k = 0;k < len;++k) {
        p = trie[p][s[k]-'a'];
        if (p == 0) {
            flag = 0;
            break;
        }
    }
    if (flag) {
    	for (int i = 1;i <= n;++i) {
    		if (f[p][i]) {
    			printf("%d ",i);
            }
        }
    }
    puts("");
}

int main() {
    n = read();
    for (int i = 1;i <= n;++i) {
        int g = read();
        for (int j = 1;j <= g;++j) {
            cin >> s;
            insert(s,i);
        }
    }
    m = read();
    for (int i = 1;i <= m;++i) {
        cin >> s;
        find(s);
    }
    return 0;
}
```
这样你就可以AC了。   
但是，最后一题的将$n$给卡满了，所以是否有另一种做法呢？  
考虑将`bool`数组优化一下，我们发现这些状态十分简单，是不是可以压缩一下？  
很自然的想到了`bitset`  
`bitset`是什么？这里粘贴一位博主翻译的cplusplus.com上的定义：  
> bitset存储二进制数位。  
bitset就像一个bool类型的数组一样，但是有空间优化——bitset中的一个元素一般只占1 bit，相当于一个char元素所占空间的八分之一。  
bitset中的每个元素都能单独被访问，例如对于一个叫做$foo$的bitset，表达式$foo[3]$访问了它的第4个元素，就像数组一样。  
bitset有一个特性：**整数类型和布尔数组都能转化成bitset。**

所以，我们可以利用强大的`bitset`写出一份完美的AC代码：
```cpp
#include <cstdio>
#include <cctype>
#include <queue>
#include <stack>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
#include <bitset>
#define MAXN 500100
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;

inline int read() {
    int a=0,f=1;char v=getchar();
    while(!isdigit(v)) {if (v == '-') {f = -1;}v = getchar();}
    while (isdigit(v)) {a = a * 10 + v - 48;v = getchar();}
    return a * f;
}

int n,m;
char s[MAXN];

int trie[MAXN][26],en[MAXN],tot = 1;
bitset <1110> f[MAXN];

inline void insert(char *s,int q) {
    int p = 1,len = strlen(s);
    for (int k = 0;k < len;++k) {
        int ch = s[k]-'a';
        if (trie[p][ch] == 0) {
            trie[p][ch] = ++tot;
        }
        p = trie[p][ch];
    }
    en[p] = 1;f[p][q] = 1;
}

inline void find(char* s) {
    int p = 1,len = strlen(s);
    bool flag = 1;
    for (int k = 0;k < len;++k) {
        p = trie[p][s[k]-'a'];
        if (p == 0) {
            flag = 0;
            break;
        }
    }
    if (flag) {
    	for (int i = 1;i <= n;++i) {
    		if (f[p][i]) {
    			printf("%d ",i);
            }
        }
    }
    puts("");
}

int main() {
    n = read();
    for (int i = 1;i <= n;++i) {
        int g = read();
        for (int j = 1;j <= g;++j) {
            cin >> s;
            insert(s,i);
        }
    }
    m = read();
    for (int i = 1;i <= m;++i) {
        cin >> s;
        find(s);
    }
    return 0;
}
```
这种做法比`bool`优秀，~~但是我的bool比bitset快~~，所以这就是这题的两种细节上的解法讨论。
> 做题并不是为了题数，如果把一题研究透了，那么写这么一题可以大大增加我们的能力

这就是我要讨论两种方法的理由。希望大家能收获一些知识，谢谢大家

---

## 作者：元夕 (赞：0)

```cpp
/*
    Name: Trie 
    Author: Jack
    Date: 03/04/19 16:47
    Description: 
        insert： 
        以字符串为例， 当需要插入一个字符串S时，我们令一个指针P
    起初指向根节点，然后依次插入S中的每个字符c:[伪代码]
        1. if the pointer of c = NULL 
             then build a new node Q,the pointer of c = Q 
        2. else : we must know the pointer of c is Q 
             then let P=Q
     	   explain:
     	   	 我们肯定知道c的指针指向一个节点，设其为Q，在Q上再继续跑 
        3. if the search of S is over 
             back[the back of S]=true
        find：
        以字符串为例， 当需要检索一个字符串S是否在trie中存在时，
    我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c:[伪代码]
        1. if the pointer of c = NULL 
             then return false 
        2. else : we must know the pointer of c is Q 
             then let P=Q
     	   explain:
     	   	 我们肯定知道c的指针指向一个节点，设其为Q，在Q上再继续跑 
        3. if the search of S is over 
             then check back[the back of S]
               if !back[the back of S]
               	 then return false
               explain：如果s的末尾未被标记为结束，证明S只是某一条树
                    上路径的前缀，并非已经插入S。
               else then return true 
        [特]：当数组标记空间爆炸，我们可以选择用bitset来当标记，空间小大约32倍！
    example:TJ2010 阅读理解 
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e6 + 5;
int trie[maxn][26],cnt;
bitset<1001>back[maxn];
int n,m,q; 
void insert(char * str,int x){
    int len=strlen(str),p=0;
    for(int k=0;k<len;k++){
        int ch=str[k]-'a';
        if(!trie[p][ch])
            trie[p][ch]=++cnt;
        p=trie[p][ch];
    }
    back[p][x]=1;
} 
void find(){
    char str[20];
    scanf("%s",str);
    int len = strlen(str),p=0;
    for(int k=0;k<len;k++){
        p=trie[p][str[k]-'a'];
        if(!p){
            printf("\n");
            return;
        }
    }
    for(int i=1;i<=n;i++){
        if(back[p][i])
            printf("%d ",i);
    }	
    printf("\n");
}
int main(){
    char str[20];
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d",&q);
        for(int j=1;j<=q;j++){
            scanf("%s",str);
            insert(str,i);
        }
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        find();
    }
    return 0;
}
```

---


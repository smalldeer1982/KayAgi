# [GDOI2014] 世界杯

## 题目描述

3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。

众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。

作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。

现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。


## 说明/提示

对于 $30\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；

对于 $100\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$

## 样例 #1

### 输入

```
3 10 12 4
76 60 87
78 84 84 84 81 82 72 51 77 57
85 84 62 87 88 64 81 90 80 66 88 85
65 83 63 79
2
4 5 1
4 4 2```

### 输出

```
85.64
78.00
```

# 题解

## 作者：Ousmane_Dembele (赞：43)

我也不知道为什么没人打暴力，10的五次方O(10n)轻松能过，甚至不需要读入优化。

思路：守门员单算，比较简单，剩下三种类型的拿中场说。

假设你有16个中场球员，他们是：（表格纯手打）（剩下几名球员power从60到72不等）
```
 -------------- --------------  
|   name       | power        |
| -----------: | -----------: |
|    666       | 22           |
|    god       | 88           |
|    messi     | 99           |
|              |              |
 -------------- --------------
```
4套阵容，分别要求3,4,3,6个中场球员

那第一套肯定是god，messi和72的那位了。

你会发现一个规律：

排完序后，power 分别是 99,88,72,71,70,69,68,67……60,22

每次抽剩下人里的前i个就行了。

看代码：
```
#include <bits/stdc++.h>
using namespace std;
int a[100005],b[100005],c[100005],d[100005];
int k,g,f,m,q;
double tbh;
bool cmp(int a,int b){//从大至少排序
    return a>b;
}
int main(){
    cin>>k>>g>>f>>m;
    for(int i=1;i<=k;i++)
       cin>>a[i];
    for(int i=1;i<=g;i++)
       cin>>b[i];
    for(int i=1;i<=f;i++)
       cin>>c[i];
    for(int i=1;i<=m;i++) //往死里输入
       cin>>d[i];
    sort(a+1,a+k+1,cmp);
    sort(b+1,b+g+1,cmp);
    sort(c+1,c+f+1,cmp);
    sort(d+1,d+m+1,cmp);//往死里排序
    cin>>q;
    int l,z,y;
    int x=1,r=1,w=1,h=1;
    int sss;
    while(q--){
    	cin>>l>>z>>y;
    	tbh=0;
    	tbh+=a[x];//守门员
    	x++;//序号++
    	for(int i=r;i<r+l;i++)
    	   tbh+=b[i];//后卫
    	r+=l;
    	for(int i=w;i<w+z;i++)
    	   tbh+=c[i];//中场
    	w+=z;
    	for(int i=h;i<h+y;i++)
    	   tbh+=d[i];//前锋
    	h+=y;
    	printf("%.2f\n",tbh/11);//一共十一人
    }
    return 0;
}
```




---

## 作者：ezoixx118 (赞：22)

~~比较简单的一题，不知为什么那么少人做~~

###于是我用优先队列来水一篇

优先队列用法非常简单(只要记住priority怎么拼。。。)，时间也很快，很难被卡，是STL一大神器

代码:

```cpp
#include<iostream>
#include<iomanip>
#include<stack>
#include<queue>//头文件
#include<list>
#include<vector>
#include<set>
#include<string>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#define ull unsigned long long
#define ll long long
#define inf 1009
#define infm inf*inf
#define INF (int) 1e9
#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}//读入优化(写得我都看不懂)，可以不用
using namespace std;
priority_queue <int> k,d,m,f;//定义大根堆(从大到小排序，弹出来的是队列最大值)
 
int main(){
    int K,D,M,F,x;
    rd(K);rd(D);rd(M);rd(F);//读入，守门员，后卫，中锋，前锋
    for (int i=1;i<=K;i++){
        rd(x);
        k.push(x);//存入堆中
    }
    for (int i=1;i<=D;i++){
        rd(x);
        d.push(x);
    }
    for (int i=1;i<=M;i++){
        rd(x);
        m.push(x);
    }
    for (int i=1;i<=F;i++){
        rd(x);
        f.push(x);
    }
    int n,a,b,c;
    rd(n);
    for (int i=1;i<=n;i++){
        rd(a);rd(b);rd(c);
        int sum=0;
        /*对于四个堆每个都弹出最大值(注意理解题意)*/
        sum+=k.top();k.pop();//与queue不同的是弹出操作是top()，不是front()
        for (int j=1;j<=a;j++){
            sum+=d.top();d.pop();
        }
        for (int j=1;j<=b;j++){
            sum+=m.top();m.pop();
        }
        for (int j=1;j<=c;j++){
            sum+=f.top();f.pop();
        }
        printf("%.2f\n",(double)sum/11.0);//计算平均值并输出
    }
}
```

---

## 作者：Bronya18C (赞：21)

# ~~话说我国真能拿世界杯冠军吗？~~(逃)
## 来一发正经的单调队列。
---
## 本题为何要用单调队列？
### 因为本题要了的就不能要了，还有，要的时候有单调性。
---
## 队列操作：
### a.pop() 弹出
### a.push(x) 存入x
### a.front() 队首
---
## 主要做法：
### 按守门（铁定1个）——后卫——中场——前锋的顺序（话说4—2—3—1怎么办？）累加，存入了就弹出，最后除以11。
```
#include<bits/stdc++.h>

using namespace std;
long long K,D,M,F,n[1000005],N,a,b,c;
double ans;
queue<long long>k,d,m,f;
int main()
{
	cin>>K>>D>>M>>F;
	for(int i=1;i<=K;i++)
	{
		cin>>n[i];
	}
	sort(n+1,n+1+K);
	for(int i=K;i>=1;i--)
	{
		k.push(n[i]);
	}
	for(int i=1;i<=D;i++)
	{
		cin>>n[i];
	}
	sort(n+1,n+1+D);
	for(int i=D;i>=1;i--)
	{
		d.push(n[i]);
	}
	for(int i=1;i<=M;i++)
	{
		cin>>n[i];
	}
	sort(n+1,n+1+M);
	for(int i=M;i>=1;i--)
	{
		m.push(n[i]);
	}
	for(int i=1;i<=F;i++)
	{
		cin>>n[i];
	}
	sort(n+1,n+1+F);
	for(int i=F;i>=1;i--)
	{
		f.push(n[i]);
	}
	cin>>N;
	for(int i=1;i<=N;i++)
	{
		ans=0;
		cin>>a>>b>>c;
		for(int j=1;j<=a;j++)ans+=d.front(),d.pop();
		for(int j=1;j<=b;j++)ans+=m.front(),m.pop();
		for(int j=1;j<=c;j++)ans+=f.front(),f.pop();
		ans+=k.front();
		k.pop();
		printf("%.2f\n",double(ans/11));
	}
	return 0;
} 
```

---

## 作者：Chiaro (赞：9)

###      优先队列

思路很简单:

把几个球员的数据实力都放到大根堆里

然后再取出,删除

(并没有刻意缩行,只是把一些语句放在一起显得不太乱QAQ)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define sc scanf
using namespace std;
priority_queue<int ,vector<int > >K,D,M,F;
//大根堆,储存球员实力
int k,d,m,f,q,a;
int Q[100010];
int _d,_m,_f;//依次代表阵型每个位置的人的个数
int _K,_D,_M,_F;//每个阵的位置的总实力
int main(){
	//读入并放进大根堆里
	sc("%d%d%d%d",&k,&d,&m,&f);
	for(int i=1;i<=k;i++){sc("%d",&a);K.push(a);}
	for(int i=1;i<=d;i++){sc("%d",&a);D.push(a);}
	for(int i=1;i<=m;i++){sc("%d",&a);M.push(a);}
	for(int i=1;i<=f;i++){sc("%d",&a);F.push(a);}
	sc("%d",&q);
	for(int i=1;i<=q;i++){
		sc("%d%d%d",&_d,&_m,&_f);
		_K=K.top();K.pop();//取出并删除现存的实力最大的守门员
		for(int j=1;j<=_d;j++){_D+=D.top();D.pop();}
		for(int j=1;j<=_m;j++){_M+=M.top();M.pop();}
		for(int j=1;j<=_f;j++){_F+=F.top();F.pop();}
        //依次取出并删除其余位置现存的最大实力球员
		printf("%.2f\n",(double)(_F+_M+_D+_K)/11.0);
        //输出并清零
		_K=_M=_D=_F=0;
	}
	return 0;
} 
```

---

## 作者：蔡俊黠 (赞：6)

### 这题用优先队列做简直完美
#### 首先我们来了解一下优先队列是做什么的
优先队列是队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行动态的排序

每次的push和pop操作，队列都会动态的调整，以达到我们预期的方式来存储

例如：我们常用的操作就是对数据排序，优先队列默认的是数据大的优先级高

所以我们无论按照什么顺序push一堆数，最终在队列里总是top出最大的元素

这一题就要求我们每次加的都是剩下队员实力最大的，符合优先队列的特性

可以愉快地做这一题了

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int A,B,C,D,m;
priority_queue <double> q1;
priority_queue <double> q2;
priority_queue <double> q3;
priority_queue <double> q4;
int main()
{
	scanf("%d%d%d%d",&A,&B,&C,&D);
	for (int i=1;i<=A;i++) //守门 
	{
		double a;
		cin>>a;
		q1.push(a);
	} 
	for (int i=1;i<=B;i++) //后卫 
	{
		double b;
		cin>>b;
		q2.push(b);
	}
	for (int i=1;i<=C;i++)//中场 
	{
		double c;
		cin>>c;
		q3.push(c);
	} 
	for (int i=1;i<=D;i++)//前锋 
	{
		double d;
		cin>>d;
		q4.push(d);
	}
	scanf("%d",&m);
	for (int i=1;i<=m;i++)
	{
		double a,b,c,anss=0,d;
		cin>>a>>b>>c;
		d=a+b+c+1;
		anss+=q1.top(); q1.pop(); //守门 
		while (a!=0) //后卫 
		{
			anss+=q2.top();
			q2.pop();
			a--;
		}
		while (b!=0) //中场 
		{
			anss+=q3.top();
			q3.pop();
			b--;
		}
		while (c!=0) //前锋 
		{
			anss+=q4.top();
			q4.pop();
			c--;
		}
		printf("%.2f\n",anss/d); //平均实力 
	}
	return 0;
}
```




---

## 作者：ChinaGIAO (赞：5)

这个题题目挺好理解，我相信大家都能读懂。
读完这个题，我想到两种做法，一个是用快排实现，另一个是用优先队列实现，最后两个代码我都实现了。

快排做法（比优先队列快一点）：
```
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1000000],b[1000000],c[1000000],d[1000000];
double num[10000000];
int main()
{
	int s,q,z,h,n,q1[100000],q2[100000],q3[100000];
	cin>>s>>q>>z>>h;
	for(int i=1;i<=s;i++)
	cin>>a[i];
	sort(a+1,a+s+1);
	//快排(默认从小到大） 
	for(int i=1;i<=q;i++)
	cin>>b[i];
	sort(b+1,b+q+1);
	for(int i=1;i<=z;i++)
	cin>>c[i];
	sort(c+1,c+z+1);
	for(int i=1;i<=h;i++)
	cin>>d[i];
	sort(d+1,d+h+1);
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>q1[i]>>q2[i]>>q3[i];
	for(int i=1;i<=n;i++)
	{//把四种球员的最好分数加起来 
	//然后再从剩余的最好分数加 
		for(int j=s;j>=s;j--)
		{
			num[i]+=a[j];
		}s--;
		for(int p=q;p>=q-q1[i]+1;p--)
		{
			num[i]+=b[p];
		}q-=q1[i];
		for(int k=z;k>=z-q2[i]+1;k--)
		{
			num[i]+=c[k];
		}z-=q2[i];
		for(int w=h;w>=h-q3[i]+1;w--)
		{
			num[i]+=d[w];
		}h-=q3[i];
  printf("%.2lf\n",num[i]/(q1[i]+q2[i]+q3[i]+1));
  //算平均数 
	}
	return 0;
 } 
```
优先队列做法：
```
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
int q1[100000],q2[100000],q3[100000];
double num[10000000];
int main()
{
	priority_queue<int> a;
	priority_queue<int> b;
	priority_queue<int> c;
	priority_queue<int> d;
	//优先队列（默认大根堆） 
	int s,q,z,h,n,a1,b1,c1,d1;
	cin>>s>>q>>z>>h;
	for(int i=1;i<=s;i++)//把四种分数分别入队 
	{
		cin>>a1;
		a.push(a1);
	}
	for(int i=1;i<=q;i++)
	{
		cin>>b1;
		b.push(b1);
	}
	for(int i=1;i<=z;i++)
	{
		cin>>c1;
		c.push(c1);
	}
	for(int i=1;i<=h;i++)
	{
		cin>>d1;
		d.push(d1);
	}
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>q1[i]>>q2[i]>>q3[i];
	for(int i=1;i<=n;i++)
	{
		int x=q1[i],y=q2[i],o=q3[i];
		//这里不能改变人数的值，所以另设变量 
		num[i]+=a.top();
		//分别把没有分到阵型里的四种球员的最
        好分数加起来  
		a.pop();
		while(x)
		{
			x--;
			num[i]+=b.top();
			b.pop();
		}
		while(y)
		{
			y--;
			num[i]+=c.top();
			c.pop();
		}
		while(o)
		{
			o--;
			num[i]+=d.top();
			d.pop();
		}
     printf("%.2lf\n",num[i]/(q1[i]+q2[i]+q3[i]+1));
     //算平均数 
	} 
	return 0; 
}
```



---

## 作者：lytqwq (赞：4)

###### ~~这个题水的一批~~  
我也不知道为什么这么少人做。  
我是找优先队列的题时做到的  ~~（2014GDOI这么水吗？）~~

这是我学stl优先队列时找到的大佬博客

[https://blog.csdn.net/c20182030/article/details/70757660](https://blog.csdn.net/c20182030/article/details/70757660)

只需要把每种位置储存在一个优先队列中，用的时候取队首元素，然后把队首元素弹出就行了。

贴代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int> k,d,m,f;//priority_queue有点难拼。。。 
int kk,dd,mm,ff,q,s;
double ss;
int main()
{
	cin>>kk>>dd>>mm>>ff;
	for(int i=1;i<=kk;i++)
	{
		int x;
		cin>>x;
		k.push(x);
	}
	for(int i=1;i<=dd;i++)
	{
		int x;
		cin>>x;
		d.push(x);
	}
	for(int i=1;i<=mm;i++)
	{
		int x;
		cin>>x;
		m.push(x);
	}
	for(int i=1;i<=ff;i++)
	{
		int x;
		cin>>x;
		f.push(x);
	}
	/*
	前面的是加入优先队列中 
	*/
	cin>>q;
	
	for(int i=1;i<=q;i++)
	{
		int x,y,z;
		s=0;
		cin>>x>>y>>z;
		for(int i=1;i<=x;i++)
		{
			s+=d.top();
			d.pop();
		}
		for(int i=1;i<=y;i++)
		{
			s+=m.top();
			m.pop();
		}
		for(int i=1;i<=z;i++)
		{
			s+=f.top();
			f.pop();
		}
		s+=k.top();
		k.pop();
		/*
		前面的是取和 
		*/
		ss=s*1.0/11;
		/*
		算出平均数 
		*/
		printf("%.2lf\n",ss);//两位小数输出 
	}
	return 0;
}
```


---

## 作者：Sugarithm (赞：3)

贪心策略：每次对每种球员选最强的几个（守门$1$个，后卫中锋前锋各$A,B,C$个）将能力值排序，每次从最大端选。

有四种球员，用结构体实现比较省代码。

可以发现并不会爆$int$，但是要注意除法的操作数类型。

```cpp
#include <cstdio>
#include <algorithm>
#define rep(i,x,y) for(int i=x;i<=y;++i)
//love Ma Ping
using namespace std;
const int X=100010;
struct Type
{
	int A[X],L,p;
	void RAS()
	{
		rep(i,1,L){
			scanf("%d",&A[i]);
		}
		sort(A+1,A+1+L);
		p=L;
	}
	int Get(int cnt)
	{
		int ret=0;
		for(int End=p-cnt;p>End;--p){
			ret+=A[p];
		}
		return ret;
	}
}k,d,m,f;
int main()
{
	scanf("%d%d%d%d",&k.L,&d.L,&m.L,&f.L);
	k.RAS(),d.RAS(),m.RAS(),f.RAS();
	int Q;
	scanf("%d",&Q);
	rep(i,1,Q){
		int A,B,C;
		scanf("%d%d%d",&A,&B,&C);
		printf("%.2f\n",(double)(k.Get(1)+d.Get(A)+m.Get(B)+f.Get(C))/11);
	}
	return 0;
}
```

---

## 作者：FAYOU (赞：3)

//模拟题 没什么细节 适合用来写自己的第一篇题解

//思路主要是先将每个运动员的属性排序，总共四个数组。然后累计前缀和，进行计算。同时要记录一下每种职业的运动员已经使用了几个。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<memory.h>
#define maxn 100005
using namespace std;
int k,d,f,m,q;
int a[maxn],b[maxn],c[maxn],s[maxn];
int aa[maxn],bb[maxn],cc[maxn],ss[maxn];
int t1,t2,t3,t4;
bool cmp(int x,int y){return x>y;}
void init()
{
    sort(a+1,a+k+1,cmp);sort(b+1,b+d+1,cmp);
    sort(c+1,c+f+1,cmp);sort(s+1,s+m+1,cmp);
    memset(aa,0,sizeof(aa));memset(bb,0,sizeof(bb));
    memset(cc,0,sizeof(cc));memset(ss,0,sizeof(ss));
    for(int i=1;i<=max(k,max(d,max(f,m)));i++) 
       {
           aa[i]=aa[i-1]+a[i]; bb[i]=bb[i-1]+b[i];
           cc[i]=cc[i-1]+c[i]; ss[i]=ss[i-1]+s[i];
       }
    t1=t2=t3=t4=0;
    return;
}
void solve(int u,int v,int w)
{
    int sav2;
    double ret=0;
    ret+=a[++t1];
    sav2=bb[t2+u]-bb[t2]; t2+=u; ret+=sav2;
    sav2=cc[t3+v]-cc[t3]; t3+=v; ret+=sav2;
    sav2=ss[t4+w]-ss[t4]; t4+=w; ret+=sav2;
    ret/=11;
    printf("%.2f\n",ret);
    return;
}
int main()
{
    int u,v,w;
    scanf("%d %d %d %d",&k,&d,&f,&m);
    for(int i=1;i<=k;i++) scanf("%d",&a[i]);
    for(int i=1;i<=d;i++) scanf("%d",&b[i]);
    for(int i=1;i<=f;i++) scanf("%d",&c[i]);
    for(int i=1;i<=m;i++) scanf("%d",&s[i]);
    scanf("%d",&q);
    init();
    while(q--)
    {
        scanf("%d %d %d",&u,&v,&w);
        solve(u,v,w);
    }
    return 0;
}
```

---

## 作者：fzj2007 (赞：2)

# **本蒟蒻的第一篇题解233**


首先，我们先分析一下这道题，题目告诉我们：对于第i种阵型，输出一个实数，表示该阵型**平均综合水平的最大值**，并四舍五入到小数点后2位。

### 这样，我们发现直接暴力查找该类型综合水平值最大的球员就行了

例如：
初始值为【~~直接抄袭~~】

3 10 12 4

76 60 87

78 84 84 84 81 82 72 51 77 57

85 84 62 87 88 64 81 90 80 66 88 85

65 83 63 79

1

4 5 1

守门员类型 肯定选择三号（87）；

后卫类型选择二（84）、三（84）、四（84）、六号（82）；

中场类型选择八（90）、五（88）、十一（88）、四（87）、一或十二号（85）；

前锋类型选择二号（83）；

sum=942;

942/(1+4+5+1)≈85.64




下面上代码

------------
```
#include<bits/stdc++.h>
using namespace std;
int an,bn,cn,dn,n;
//结构体
struct a1{
//as代表综合水平值，at判断是否用过
	int as,at;
}a[100001];
struct b1{
	int bs,bt;
}b[100001];
struct c1{
	int cs,ct;
}c[100001];
struct d1{
	int ds,dt;
}d[100001];
bool cmpa(a1 u,a1 v){
	return u.as>v.as;
}
bool cmpb(b1 u,b1 v){
	return u.bs>v.bs;
}
bool cmpc(c1 u,c1 v){
	return u.cs>v.cs;
}
bool cmpd(d1 u,d1 v){
	return u.ds>v.ds;
}
int main(){
	scanf("%d %d %d %d",&an,&bn,&cn,&dn);//疯狂的读入
   //为了不错误，"%d"前面加空格
	for(int i=1;i<=an;i++) scanf(" %d",&a[i].as);
	for(int i=1;i<=bn;i++) scanf(" %d",&b[i].bs);
	for(int i=1;i<=cn;i++) scanf(" %d",&c[i].cs);
	for(int i=1;i<=dn;i++) scanf(" %d",&d[i].ds);
	scanf(" %d",&n);//排序 浪费时间啊
	sort(a+1,a+an+1,cmpa);
	sort(b+1,b+bn+1,cmpb);
	sort(c+1,c+cn+1,cmpc);
	sort(d+1,d+dn+1,cmpd);
	for(int i=1;i<=n;i++){
		int x1,y1,z1,x,y,z;
      //别忘了double类型啊
		double sum=0;
		scanf("%d %d %d",&x,&y,&z);
      //存储一下
		x1=x;
		y1=y;
		z1=z;
		for(int j=1;j<=an;j++){
        //先判断能不能使用 其实很浪费时间
			if(!a[j].at){
				a[j].at=1;
				sum+=a[j].as;
                //守门员只有一个，所以是break;
				break;
			}
		}
      //和上面一样
		for(int j=1;j<=bn;j++){
        //做判断，x>0代表没有选完
			if(!b[j].bt&&x>0){
				x--;
				b[j].bt=1;
				sum+=b[j].bs;
           //还要选啊，是continue啊
				continue;
			}
		}
		for(int j=1;j<=cn;j++){
			if(!c[j].ct&&y>0){
				y--;
				c[j].ct=1;
				sum+=c[j].cs;
				continue;
			}
		}
		for(int j=1;j<=dn;j++){
			if(!d[j].dt&&z>0){
				z--;
				d[j].dt=1;
				sum+=d[j].ds;
				continue;
			}
		}
       //"%.2f\n" .2f输出小数点后两位，大家都知道吧。。
       //sum/(x1+y1+z1+1)求出平均值
		printf("%.2f\n",sum/(x1+y1+z1+1));
	} 
	return 0;华丽的结束
}
```


------------
真的华丽吗？



------------


------------





~~竟然TLE了两个……~~

但是，我想说的是，数据不是太强，是太弱了！

下面 AC
```
//#include<bits/stdc++.h>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<stack>
#include<map>
#include<queue>
#include<math.h>
#include<time.h>
#include<cstdio>
#include<stdio.h>
#include<algorithm>
/*
3 10 12 4
76 60 87
78 84 84 84 81 82 72 51 77 57
85 84 62 87 88 64 81 90 80 66 88 85
65 83 63 79
2
4 5 1
4 4 2
*/
using namespace std;
int an,bn,cn,dn,n;
int a[100001],b[100001],c[100001],d[100001];
bool cmp(int u,int v){
	return u>v;
}
int ak,bk,ck,dk;
int main(){
	scanf("%d %d %d %d",&an,&bn,&cn,&dn);
    //输入不解释
	for(int i=1;i<=an;i++) scanf(" %d",&a[i]);
	for(int i=1;i<=bn;i++) scanf(" %d",&b[i]);
	for(int i=1;i<=cn;i++) scanf(" %d",&c[i]);
	for(int i=1;i<=dn;i++) scanf(" %d",&d[i]);
	scanf(" %d",&n);
    //一遍就行了
	sort(a+1,a+an+1,cmp);
	sort(b+1,b+bn+1,cmp);
	sort(c+1,c+cn+1,cmp);
	sort(d+1,d+dn+1,cmp);
	for(int i=1;i<=n;i++){
		int x1,y1,z1,x,y,z;
		double sum=0;
		scanf("%d %d %d",&x,&y,&z);
		x1=x;
		y1=y;
		z1=z;
       //ak、bk、ck、dk用来存储从哪个球员开始循环
		for(int j=ak+1;j<=an;j++){
			ak=j;
			sum+=a[j];
        //别忘了break 啊
			break;
		}
		for(int j=bk+1;j<=bn;j++){
			if(x>0){
				x--;
				bk=j;
				sum+=b[j];
               // 这是continue
				continue;
			}
		}
		for(int j=ck+1;j<=cn;j++){
			if(y>0){
				y--;
				ck=j;
				sum+=c[j];
				continue;
			}
		}
		for(int j=dk+1;j<=dn;j++){
			if(z>0){
				z--;
				dk=j;
				sum+=d[j];
				continue;
			}
		}
		printf("%.2f\n",sum/(x1+y1+z1+1));
	} 
	return 0;
}
```

[AC~~~~](https://www.luogu.org/record/22594802)

大家不要抄袭哈 这题还算 ~~简单~~ 【管理员，求过~~】


---

## 作者：Saberlve (赞：1)

# 一道可以用来当模板的优先队列题（实在是太直接了）
大体思路：(真的需要吗？？）开四个队列，读入数据，输出数据，计算，AC。
#### 简单粗暴
## 下面是代码
```
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,less<int> >k;
priority_queue<int,vector<int>,less<int> >d;
priority_queue<int,vector<int>,less<int> >m;
priority_queue<int,vector<int>,less<int> >f;//写四次有助于新手巩固啦~当然也可以4合1 
int q,a,b,c,e;
int main()
{
	int i,tmp;
	cin>>a>>b>>c>>e;
	for(i=1;i<=a;i++)cin>>tmp,f.push(tmp);
	for(i=1;i<=b;i++)cin>>tmp,m.push(tmp);
	for(i=1;i<=c;i++)cin>>tmp,d.push(tmp);
	for(i=1;i<=e;i++)cin>>tmp,k.push(tmp);//读入4个位置的球员能力 
    int n,x,y,z;
    cin>>n;
    for(i=1;i<=n;i++)
    {
    	int ans=0;
    	cin>>x>>y>>z;
    	while(z--)
    	{
    		int tmp=k.top();k.pop();
    		ans+=tmp;//出队，当前总能力值++ 
		}
		while(y--)
    	{
    		int tmp=d.top();d.pop();
    		ans+=tmp;
		}
		while(x--)
    	{
    		int tmp=m.top();m.pop();
    		ans+=tmp;
    	
		}
		ans+=f.top();f.pop();//守门员不含在队形内 
		printf("%.2lf\n",ans*1.0/11);//输出结果 
	}
	return 0;
}

```
总之这道题还是很简单的啦，大家可以练手用，CTRL C+V就不要了吧


---

## 作者：ZBAA_MKC (赞：0)

我的做法非常朴素，输入战力值后每个从大到小排序，后面在选球员时用一个 `bool` 类型的数组，来表示这名球员在前面一轮（或几轮）中有没有被选过，如果被选过就找下一个，否则把他选上。

更多说明见代码注释

```cpp
#include <bits/stdc++.h> //万能头 
using namespace std;

inline int read() //快读 
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch >'9')
	{
        if(ch == '-')
		{
         	f = -1;
		}
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
	{
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

int k[100005], d[100005], m[100005], f[100005]; //球员战力值 
bool ud[100005], um[100005], uf[100005]; //用来储存每一个球员是否被选过 

int main()
{
    int kk, dd, mm, ff; //输入 
    kk = read();
    dd = read();
    mm = read();
    ff = read();
    for (register int i = 1; i <= kk; i++)
    {
    	k[i] = read(); //守门员 
	}
	for (register int i = 1; i <= dd; i++)
	{
		d[i] = read(); //后卫 
	}
	for (register int i = 1; i <= mm; i++)
	{
		m[i] = read(); //中场 
	}
	for (register int i = 1; i <= ff; i++)
	{
		f[i] = read(); //前锋 
	}
	//从大到小排序 
	sort(k + 1, k + kk + 1, greater<int>());
	sort(d + 1, d + dd + 1, greater<int>());
	sort(m + 1, m + mm + 1, greater<int>());
	sort(f + 1, f + ff + 1, greater<int>());
	int q; //阵容个数 
	q = read();
	for (register int i = 0; i < q; i++)
	{
		double sum = k[i + 1] * 1.0; //计算战力值总和，初始化为当前最佳守门员的战力值 
		int a, b, c; //阵容布局 
		a = read();
		b = read();
		c = read();
		int cnt1 = 0; //计数，已经选了几个 
		int cnt2 = 0;
		int cnt3 = 0;
		for (register int j = 1; j <= dd; j++) //选后卫 
		{
			if (cnt1 == a) //选够数就结束 
			{
				break;
			}
			if (!ud[j]) //如果当前球员没被选过 
			{
				ud[j] = true; //把他标记为选过 
				sum += d[j] * 1.0; //累加战力值 
				cnt1++; 
			}
		}
		for (register int j = 1; j <= mm; j++) //选中场 
		{
			if (cnt2 == b) //选够数就结束 
			{
				break;
			}
			if (!um[j]) //如果当前球员没被选过 
			{
				um[j] = true; //把他标记为选过 
				sum += m[j] * 1.0; //累加战力值 
				cnt2++;
			}
		}
		for (register int j = 1; j <= ff; j++) //选后卫 
		{
			if (cnt3 == c) //选够数就结束 
			{
				break;
			}
			if (!uf[j]) //如果当前球员没被选过 
			{
				uf[j] = true; //把他标记为选过 
				sum += f[j] * 1.0; //累加战力值 
				cnt3++;
			}
		}
		sum /= 11.0; //计算平均战力值 
		printf("%.2lf\n", sum); //保留两位小数并输出（别忘换行） 
	}
	return 0;
}
```


---

## 作者：没有输入 (赞：0)

## 这道题数据才100000，为什么不搞暴力呢？？

读入，对每种球员的综合数据，进行从大到小排序
```cpp
scanf("%d%d%d%d",&K,&D,&M,&F);
for(int i=1; i<=K; i++) scanf("%d",&k[i]);
for(int i=1; i<=D; i++) scanf("%d",&d[i]);
for(int i=1; i<=M; i++) scanf("%d",&m[i]);
for(int i=1; i<=F; i++) scanf("%d",&f[i]);
sort(k+1,k+K+1,cmp);
sort(d+1,d+D+1,cmp);
sort(m+1,m+M+1,cmp);
sort(f+1,f+F+1,cmp);
```
然后在读入阵型时维护一个前缀和，使a[i]表示前i个阵型需要的后卫数量，b[i]和c{i]同理。
```cpp
scanf("%d",&q);
for(int i=1; i<=q; i++)
{
	scanf("%d%d%d",&a[i],&b[i],&c[i]);
	a[i]+=a[i-1],b[i]+=b[i-1],c[i]+=c[i-1];
}
```

由题意不难得出，第i个阵型的守门员即k[i]（排序后），后卫即第a[i-1]+1个至第a[i]个。中场和前锋同理。所以不难得出每个阵型的综合平均水平。输出即可。
```cpp
for(int i=1; i<=q; i++)
{
	ans=k[i];
	for(int j=a[i-1]+1; j<=a[i]; j++) ans+=d[j];
	for(int j=b[i-1]+1; j<=b[i]; j++) ans+=m[j];
	for(int j=c[i-1]+1; j<=c[i]; j++) ans+=f[j];
	printf("%.2lf\n",ans/11);
}
```
### 总结

对于数据范围较小的题目，要善于就题意进行模拟（暴力）。尤其要注意对题目的理解，模拟题很容易因为对题目部分的曲解而导致失分。在比赛时，即使数据范围很大，在不知道正解时，利用暴力骗取部分分数也时一种方法。但在平常练习时，应当去求正解，而不是想方设法去骗分。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int K,D,M,F,k[maxn],d[maxn],m[maxn],f[maxn],q,a[maxn],b[maxn],c[maxn];
double ans;
bool cmp(int a,int b)//使快速排序从大到小进行
{
	return a>b;
}
int main()
{
	scanf("%d%d%d%d",&K,&D,&M,&F);
	for(int i=1; i<=K; i++) scanf("%d",&k[i]);
	for(int i=1; i<=D; i++) scanf("%d",&d[i]);
	for(int i=1; i<=M; i++) scanf("%d",&m[i]);
	for(int i=1; i<=F; i++) scanf("%d",&f[i]);
	sort(k+1,k+K+1,cmp);
	sort(d+1,d+D+1,cmp);
	sort(m+1,m+M+1,cmp);
	sort(f+1,f+F+1,cmp);
	scanf("%d",&q);
	for(int i=1; i<=q; i++)
	{
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
		a[i]+=a[i-1],b[i]+=b[i-1],c[i]+=c[i-1];
	}
	for(int i=1; i<=q; i++)
	{
		ans=k[i];
		for(int j=a[i-1]+1; j<=a[i]; j++) ans+=d[j];
		for(int j=b[i-1]+1; j<=b[i]; j++) ans+=m[j];
		for(int j=c[i-1]+1; j<=c[i]; j++) ans+=f[j];
		printf("%.2lf\n",ans/11);
	}
	return 0;
}
```


---

## 作者：sunken (赞：0)

这题实际上很简单，就是每一场选出侯选队员中分数最高的那批队员，属于贪心解法。
具体实现时，开4个数组，分别存守门员、后卫、中锋、前锋的分数，并且分别排好序。
每一阵型，如4，5，1阵型，则分别选取守门员最大的1个、后卫中最大的4个、中锋中最大的5个 、前锋中最大的1个，计算总和，并将这些数从数组中去除。
继续处理下一个阵型，直至完成。
程序如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int an,bn,cn,dn,bm,cm,dm,m;
double sum,ave;
int a[100001],b[100001],c[100001],d[100001];
int main()
{
	cin>>an>>bn>>cn>>dn;
	for(int i=1;i<=an;i++)cin>>a[i];
	for(int i=1;i<=bn;i++)cin>>b[i];
	for(int i=1;i<=cn;i++)cin>>c[i];
	for(int i=1;i<=dn;i++)cin>>d[i];
	sort(a+1,a+1+an);
	sort(b+1,b+1+bn);
	sort(c+1,c+1+cn);
	sort(d+1,d+1+dn);
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>bm>>cm>>dm;
		sum=a[an];an--;
		for(int j=bn;j>=bn-bm+1;j--)
			sum+=b[j];
		bn-=bm;
		for(int j=cn;j>=cn-cm+1;j--)
			sum+=c[j];
		cn-=cm;
		for(int j=dn;j>=dn-dm+1;j--)
			sum+=d[j];
		dn-=dm;
		ave=sum/11;
		printf("%.2f",ave);cout<<endl;
	}

}

```


---

## 作者：meyi (赞：0)

提到优先队列的已有题解都是使用STL的， ~~为什么不手写堆呢？~~ 本蒟蒻正好来水一发手写堆$QwQ$

```cpp
#include<cctype>
#include<cstdio>
inline void swap(int &x,int &y){int z=x;x=y;y=z;}	//交换两个元素的位置
struct heap{	//手写堆
	int a[100001],l;	//a为数组形式的完全二叉树，l为a的元素个数。
	inline void push(int k){	
    //找到新元素的合适位置，时间复杂度O(log2(l))
		a[++l]=k;
		int s=l;
		while(s>1){
			int f=s>>1;	
            //根据完全二叉树的定义可得结点i的父结点必为i/2
			if(a[f]>=a[s])break;
			swap(a[f],a[s]);
			s=f;
		}
	}
	inline void pop(){	
    //弹出树根，并重新建堆，时间复杂度O(log2(l))
		a[1]=a[l--];
		int f=1;
		while(f<<1<=l){
			int s=f<<1;	
            //根据完全二叉树的定义可得结点i的父结点必为i*2和i*2+1
			if(s<l&&a[s]<a[s|1])s|=1;
			if(a[s]<=a[f])break;
			swap(a[f],a[s]);
			f=s;
		}
	}
}d,f,k,m;
inline int qr(){	//快读
	int in=0;char ch;
	while(!isdigit(ch=getchar()));
	do in=(in<<1)+(in<<3)+(ch^48);while(isdigit(ch=getchar()));
	return in;
}
int A,B,C,D,F,K,M,Q;
main(){
	//根据题意模拟
	scanf("%d%d%d%d",&K,&D,&M,&F);
	while(K--)k.push(qr());
	while(D--)d.push(qr());
	while(M--)m.push(qr());
	while(F--)f.push(qr());
	scanf("%d",&Q);
	while(Q--){
		A=qr(),B=qr(),C=qr();
		register int S=k.a[1],T=1+A+B+C;
		k.pop();
		while(A--)S+=d.a[1],d.pop();
		while(B--)S+=m.a[1],m.pop();
		while(C--)S+=f.a[1],f.pop();
		printf("%.2lf\n",S/double(T));
	}
}
```


---


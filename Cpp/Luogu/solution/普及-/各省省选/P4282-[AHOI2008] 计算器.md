# [AHOI2008] 计算器

## 题目描述

小可可在欢乐岛的快乐旅程还在继续，他想买一些纪念品带回去给同学们，于是来到了礼品部，在这里他发现了一个有趣的计算器.

这个计算器是一种特殊的、支持变进制整数加减运算的计算器（所谓变进制，就是每一位的进制可以不同。例如，如果最低位是 $3$ 进制，次低位是 $5$ 进制，那么这种情况的 $42$ 转化成十进制就是 $4\times 3+2=14$）。

店主看小可可对这个计算器非常感兴趣，于是他问小可可：“小朋友，如果我告诉你这个计算器最多可以支持 $N$ 位的变进制整数，且每一位的进制分别是 $x_1,x_2,\ldots,x_n$，那么你知道它能表示的最大整数 $M$ 是多少吗?”，小可可想了想说到：“它所能表示的最大的整数 $M$ 是 $(x_1\times x_2\times \cdots\times x_n)-1$。”

店主非常高兴，说道：“你真是个聪明的孩子，如果我告诉你两个长度为 $N$ 的变进制整数 $A,B$，你按照我的要求来计算 $(A＋B)\bmod(M+1)$ 或 $(A-B)\bmod(M+1)$，答案还是用相同的变进制来表示，如果你算对了，那么我就把这个计算器送给你。”

这下把小可可难住了，但是他非常想要这个计算器，聪明的你能够帮助小可可吗?

## 说明/提示

$100\%$ 的数据中，$1\le N \le 10^5$，$1 < x_1,x_2,\ldots x_N<100$。

$30\%$ 的数据中，$N \le 9$，$x_1 = x_2 =\ldots = x_N =10$。

## 样例 #1

### 输入

```
3
3 2 5
1 1 2
+
0 0 3```

### 输出

```
2 0 0

```

# 题解

## 作者：见贤思齐_Seakies (赞：25)

### [题目链接](https://www.luogu.com.cn/problem/P4282)


------------
### 题意概述

现在有两个 $n$ 位数，每一位的进制不同，第 $i$ 位为 $x_i$ 进制，要求他们两个的和或差。


------------
### 题目分析

一看这道题，大家应该就会想到高精度，首先我们把它分为两种情况，第一种情况是计算和，第二种情况为计算差。

我们通过**高精度**，模拟题意，分别计算出和与差，最后输出，输出时要注意，**最后一个数字后面没有空格**。

那么我们如何计算和与差呢？

和：首先，我们先计算出每一位的和，然后，我们进行**进位**操作。

差：与和一样，先计算出差后，如果小于零，便不断地向高位**借位**，直到得到的数大于等于零为止。

注意：我们输入的时候是从高位开始的，所以，我们进行操作的时候要**倒着**循环。

详细解释请看代码：


------------
### 代码

```cpp
#include <bits/stdc++.h> // 万能头 
using namespace std;
int n;
int x[100005], a[100005], b[100005], sum[100005]; // x 为进制，a 和 b 为两个变进制数，sum 记录和与差
/* ---------------------------------------------- */ 
void he() {
    for (int i = n; i >= 1; i--) { // 注意要倒序
        sum[i] += a[i] + b[i]; // 算和 
        a[i - 1] += sum[i] / x[i]; // 让下一位加上这一位多的数
        // 注意：我们这里是倒序的，因此，上一位应是 i - 1，下面的减法也一样
        sum[i] %= x[i]; // 当前这一位的和对进制取模
        // 进位 
    }
} // 计算加法 
void cha() {
	for (int i = n; i >= 1; i--) {
        sum[i] = a[i] - b[i]; // 算差 
        while (sum[i] < 0) { // 如果求出的差为负就不断借，直到大于零为止
        // 注意：这里一定要用循环，不能只用一个 if，因为你只借一次可能不够用
        	a[i - 1]--; // 让上一位减一
        	sum[i] += x[i]; // 当前这一位加上借的这一位，借的数就是上一位的进制
		} // 向高位借位 
    }
} // 计算减法 
	// 核心部分
/* ---------------------------------------------- */
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    char c;
    cin >> c;
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    // 输入
/* ---------------------------------------------- */
    if (c == '+') {
        he();
    } else {
        cha();
    }
/* ---------------------------------------------- */
    for (int i = 1; i < n; i++) {
        cout << sum[i] << ' ';
    } // 这里正序输出就可以了
    cout << sum[n] << endl; // 注意：这里最后一个数的后面不能有空格
    // 输出
    return 0; // return 是个好习惯
} // ~ 完美结束！~
```

***[$AC$ 记录](https://www.luogu.com.cn/record/59225952)*** ~~（别忘了开 O2）~~

于是，有的大佬就要问了，题目不是让你对 $M + 1$ 取模吗？

其实是不用的，$X$ 进制的最大值是 $M$ ，那么 $M\ mod\ (M + 1)$ 是不是还是 $M$ 呢？同样，**所有比 $M + 1$ 小的数对它取模都等于本身**。


------------

### 题目推荐
<https://www.luogu.com.cn/problem/P1601>

<https://www.luogu.com.cn/problem/P1303>

<https://www.luogu.com.cn/problem/P1255>

<https://www.luogu.com.cn/problem/P1009>

<https://www.luogu.com.cn/problem/P1480>


------------
本蒟蒻第一次写题解，希望对大家有帮助！

最后再说一句，大家不要抄袭哦！

---

## 作者：xiaoxiaoxia (赞：9)

# Part 1 思路
  这道题我们一看范围就可以知道这道题就要用高精度来做，这里的话高精度我们不重点谈论，主要来看一下三目运算符。
# Part 2 浅谈高精度
  高精度的话其实是一种工具，主要运用于数据特别大得时候，一般来说普通类型的话存的数据有限，一旦数据过大就会溢出，那该怎么办呢？我们可以用数组来存，数组的话就可以开的再大一点，一半没有问题，许多 Oier 都说高精度很烦，那我就再来拆开来细说一下。其实高精度就是模拟我们竖式计算时的进位或者退位，只是写起来麻烦而已。已加法为例子，我们把两个数相加，一旦大于十就向前进位，最后判断前导 $0$ 即可。
# Part 3 三目运算符
  三目运算符是编程中一个比较重要的语法，我们今天就来重点了解一下 。   
先了解如何使用
```
  int a=10,b=20,c=0;

//第一个条件 第一个语句 第二个语句

    c=a<b ? 1 : 2;

    cout << c << endl;
```
如果第一个条件为真，就执行第一个语句，把c赋值成1；

如果第一个条件为假，就执行第二个语句，那c就是2。

第一个条件第一个语句，第二个语句之间用问号和冒号隔开，问号和冒号输入时要用英文半角输入。
那么这个代码执行之后，因为 $10$ 小于 $20$，第一个条件为真，所以执行第一个语句。所以运行结果为：$1$。  
关于三目运算题的应用题  
输入一个数，有三目运算符判断它是奇数还是偶数。

输入格式：一个整数。

输出格式：“奇数”或“偶数”
```cpp
int i=0;

    string str;

    cin >> i;

    i%2==0?str="偶数":str="奇数";

    cout << str << endl;
```
这里如果对二取余为零的话就可以输出偶数了。  
总结   
  三目运算符的话因为我自己不太会，了解之后想给一些新手理解一下，三目运算符的话就是用来简化代码的，有时候可以使用。
# Part 4 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005], b[100005], c[100005], base[100005];//a和b是数，c是求和，base是用来存进制 
char fuhao;//变量名十分直接，不说了 
int n;
void add()//加法，不说了 
{
	int t=0;
	for(int i=n;i>=1;i--)
	{
		c[i]=a[i]+b[i]+t;
		t=c[i]/base[i];
		c[i]%=base[i];
	}
}
void jianfa()//也比较直接 
{
	int t=0;
	for(int i=n;i>=1;i--)
	{
		c[i]=a[i]-b[i]-t;
		t=0;
		if(c[i]<0)
		{
			c[i]+=base[i];
			t=1;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>base[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cin>>fuhao;
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
	}
	(fuhao=='+')?add():jianfa();//判断是加法还是减法 
	for(int i=1;i<=n;i++)
	{
		cout<<c[i]<<" ";
	}
	return 0;
}

```


---

## 作者：byft (赞：2)

一道标准高精题。

[前](https://www.luogu.com.cn/problem/P1601) [置](https://www.luogu.com.cn/problem/P2142) [芝](https://www.luogu.com.cn/problem/P1303) [士](https://www.luogu.com.cn/problem/P1480)。

我们都知道，高精的本质就是竖式计算，而在计算中会进位（满十进一）、退位（借一当十），我们就可以拓展到 $n$ 进制，即满 $n$ 进一、退一当 $n$。

所以，我们就能按高精的模板写了 $\dots$ 吗？

嗯？怎么还有个 $\bmod (M+1)$ 呢？

其实 $M$ 就已经是 $n$ 位下能表示的最大值了，再添一位就是$\ 100000\dots0$（$n$ 个 $0$），也就是当位数超过 $n$ 位时，只输出最后 $n$ 位即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int jz[100010];//存储进制
int a[100010], b[100010], c[100010];//a和b为运算数，c为答案

int main() {
	int n;
	cin >> n;
	for (int i = n; i >= 1; i--)//永远记住逆序循环！
		cin >> jz[i];
	for (int i = n; i >= 1; i--)
		cin >> a[i];
	char p;
	cin >> p;
	for (int i = n; i >= 1; i--)
		cin >> b[i];
	if (p == '+') {
		int t = 0;//t用来存储进位
		for (int i = 1; i <= n; i++) {
			c[i] = a[i] + b[i] + t;
			t = c[i] / jz[i];//因为有可能进多次，所以不用if
			c[i] %= jz[i];
		}
	}
	if (p == '-') {
		int t = 0;
		for (int i = 1; i <= n; i++) {
			c[i] = a[i] - b[i] - t;
			t = 0;//这里一定要清零！
			while (c[i] < 0) {//同理，有可能会退多次
				c[i] += jz[i];
				t++;
			}
		}
	}
	for (int i = n; i > 1; i--)
		cout << c[i] << " ";
	cout << c[1];//最后一个不能有空格，特判
	return 0;
}
```

---

## 作者：Gaogao2011 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4282)


------------

### 题意

有两个 $n$ 位数，每个数的第 $i$ 位为 $x_i$ 进制，求两个数的和或差。

### 思路

数的长度最多是 $10^5$，也只能是**高精度**了。

至于最后的对 $M$ 取模，只要明白以下几个式子。

* $1 \bmod 2 = 1$

* $114514 \bmod 1919810 = 114514$

由此可见，结果比 $M$ 小的数对 $M$ 取模，结果还等于它本身啊。~~题目真忽悠人。~~

本题主要考查高精度加和减，只是加上了简单的进制。

### 代码

AC Code:

```

#include <iostream>
using namespace std;
const int N = 1e5 + 7;
int a[N], b[N], c[N], d[N], n;
char op;
void _add() {
	int t = 0;
	for (int i = n; i >= 1; i--) {
		c[i] = a[i] + b[i] + t;
		t = c[i] / d[i];
		c[i] %= d[i];
	}
}
void _minus() {
	int t = 0;
	for (int i = n; i >= 1; i--) {
		c[i] = a[i] - b[i] - t;
		t = 0;
		if (c[i] < 0) {
			c[i] += d[i];
			t=1;
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	/*
	这个上面 27 行的代码
	ios::sync_with_stdio(false);
	解释一下。
	
	这行代码可以理解为 “是否兼容stdio”的开关，设置为 true 可以使 printf 和 cout 使用时不混乱。
	关闭之后就不可以混用了，但是可以大大提高 cin / cout 的效率。 
	*/ 
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> d[i];
	for (int i = 1; i <= n; i++) cin >> a[i];
	cin >> op;
	for (int i = 1; i <= n; i++) cin >> b[i];
	if (op == '+') _add();
	else _minus();
	for (int i = 1; i <= n; i++) cout << c[i] << " ";
	return 0;
}


```


---

## 作者：Fist_PROF (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4282)

------------

首先拿到这道题，我们看到数据范围和进位制的东西，不难想到高精度去写这道题，就是说在进位或者借位的时候要注意去弄进位制。

熟悉并且做过这道题的童鞋们肯定知道，这道题的难点就在于对 $ m $ 取模对吧，如果我们按照正常的思路，肯定是把每一位变成十进制然后取模然后再转回来，但是这样毕竟有些麻烦，于是我们来思考一下。

那么我们从 $ m $ 上来思考，~~既然这道题出出来了~~，肯定是可以找的 $ m $ 的特殊性的。

我们假设一共有 $ n $ 个数，根据题意，我们不难得到，给的操作数 $ a , b $ 一定是小于 $ m $ 的，所以最后不论是加还是减，肯定是不会大于 $ m \times 2 $ 的，这个不难理解，因此，我们只需要按照正常思路进位到第 $ n + 1 $ 位，然后，我们只输出 $ n $ 位就可做到模 $ m $ 的效果。

主要代码如下:

```cpp
int jz[maxN],a[maxN],b[maxN];
int n;
char op;
void jia(){//加法 
	int x=0;//记录进位数 
	for(int i=n;i>=1;i--){//总共n个进位值，每一个都算一次 
		int t=x;
		x=(t+a[i]+b[i])/jz[i];//进位 
		a[i]=(t+a[i]+b[i])%jz[i];//记住，一定要模 
	}//这里类似于高精度加法 
	for(int i=1;i<n;i++){//因为最后不输出空格，所以到循环到n-1 
		printf("%d ",a[i]);
	}
	printf("%d\n",a[n]);//最后不输出空格 
}
void jian(){//减法 
	for(int i=n;i>=1;i--){
		while(a[i]<b[i]){//这里有个借位的操作，记得留神while 
			a[i-1]--;//借位 
			a[i]+=jz[i];//计算减法 
		}
		a[i]-=b[i];//当不需要进位的时候，就直接减 
	}
	for(int i=1;i<n;i++){
		printf("%d ",a[i]);
	}
	printf("%d\n",a[n]);//27~30行同加法 
}

```

---

## 作者：zxh923 (赞：1)

# P4282 [AHOI2008] 计算器 题解

### 思路

这道题其实就是进行变进制运算，只是不确定进制是多少。和高精度类似，我们可以用数组进行存储。

但是，高精度计算是对十取余进行计算，这里是规定的进制。

并且我们只需要输出这一位上的数，并不需要像一般的十六进制等转换为字母（~~虽然太大的数好像没法转换成字母~~）。

### 坑点

在进行减法运算时，如果不够减，千万不要放任不管，输出负数，而要向高位借位。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[100005],y[100005],z[100005],jz[100005];//大数组要开全局变量 
int main(){
	int n;
	char c;//运算符 
	cin>>n;//数码长度 
	for(int i=1;i<=n;i++){
		cin>>jz[i];//输入每一位的进制 
	}
	for(int i=1;i<=n;i++){
		cin>>x[i];
	}
	cin>>c;
	for(int i=1;i<=n;i++){
		cin>>y[i];
	}
	//本部分为输入第一个运算数和第二个运算数 
	if(c=='+'){//判断运算符 
		for(int i=n;i>=1;i--){
			z[i]+=x[i]+y[i];
			z[i-1]+=z[i]/jz[i];
			z[i]%=jz[i];//保留余数,商加给下一位 
		}
	}
	else{
		for(int i=n;i>=1;i--){
			z[i]+=x[i]-y[i];//反之则减 
			if(z[i]<0){
				z[i]+=jz[i];
				z[i-1]--;//如果不够减,借位 
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<z[i]<<" ";//输出最终结果,记得加空格 
	}
	return 0;
}
```


---

## 作者：haokee (赞：1)

## 思路

大家在刷题时，每一看到高精度就会对这道题视而不见，仿佛很难似的（我也是）。但其实高精度就是我们小学二年级学的竖式，只是代码看起来比较长而已。

### 高精度加法

我们就按照竖式来，各位相加。例如：

```
  2  0  2  3
+ 1  9  8  0
—————————————
  3  9 10  3
```

但这时我们会发现，$2+8$ 等于的是一个大于等于十的数，而一个数位上根本不可能会有多个数。这时，我们就会“进一”。

```
  2  0  2  3
+ 1  9  8  0
—————————————
  4  0  0  3
     ^  ^
```

为了方便，我们就先全部直接向加，最后再处理进位。

---

### 高精度减法

与加法不同，减法是加法的逆运算，当然不能进位，但是我们可以“借位”。

```
  4  0  0  3
- 1  9  8  0
—————————————
  3 -9 -8  3
```

可以看到，有些位置不够减，变成了负数，那么我们就借去左边的数的一份，当成十来使用。

```
  ·  ·
  4  0  0  3
- 1  9  8  0
—————————————
  2  0  2  3
  
 // 注意百位，这里是0，已经减去了个一，再借一位应该是9
```

---

于是，唯一一篇 python 代码横空出世。~~RE 调了半天。~~

## 代码

```python
# python 的单行读入需要注意
n = int(input())
t = [0] + list(map(int, input().split())) # 这里先用int的map存下来，再转成list
a = [0] + list(map(int, input().split())) # 同理
o = str(input())
b = [0] + list(map(int, input().split()))
ans = []  # 先来一个空列表
for i in range(n + 1):  # python的下标也是从0开始
  ans.append(0) # 不断加入元素
if o == '+':  # 先来加法
  for i in range(1, n + 1):  # 直接相加
    ans[i] = a[i] + b[i]
  for i in range(n, 0, -1): # 处理进位，注意这里反向不遍历0
    ans[i - 1] += ans[i] // t[i]  # 下一位的进位
    ans[i] %= t[i]  # 这一位留下来的值
else:
  for i in range(1, n + 1):  # 各位相减
    ans[i] = a[i] - b[i]
  for i in range(n, 0, -1):  # 反向处理借位
    if ans[i] < 0:  # 如果这一位不够
      ans[i - 1] -= 1  # 向前一位借一
      ans[i] += t[i]  # 注意这里要加上当前位的值
for i in range(1, n + 1):  
  print(ans[i], end = ' ')  # 遍历输出
```

---

## 作者：szh_AK_all (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4282)

这道题的重头戏就是高精度加法和减法。至于 $M$，我们是不用计算的，因为在计算高精度时，我们可以边计算边取模。当然，高精度有两种做法：一、建造自定义变量，用重载；二、用 ```void``` 函数实现高精度计算过程。下面先讲述第一种方法。
## 高精度加法
```c
struct jia
{
    int a[100005],s;
};
jia operator+(jia p,jia p1)
{
    jia k;
    memset(k.a,0,sizeof(k.a));
    k.s=max(p.s,p1.s);
    for(int i=1;i<=k.s;i++)
    {
        k.a[i]=p.a[i]+p1.a[i];
    }
    for(int i=1;i<=k.s;i++)
    {
        k.a[i+1]+=k.a[i]/10;
        k.a[i]%=10;
    }
    k.s+=2;
    while(k.a[k.s]==0&&k.s>1)
    k.s--;
    return k;
}
```
## 高精度减法
```c
struct jia
{
    int a[100005],s;
};
jia operator-(jia p,jia p1)
{
    jia k;
    memset(k.a,0,sizeof(k.a));
    k.s=max(p.s,p1.s);
    for(int i=1;i<=k.s;i++)
    {
        k.a[i]=p.a[i]-p1.a[i];
        if(k.a[i]<0)
        {
            k.a[i]+=10;
            p.a[i+1]--;
        }
    }
    while(k.a[k.s]==0&&k.s>1)
    k.s--;
    return k;
}
```
本题解法：一、输入时要注意循环是从大到小的，因为我们通常将高精度最低位记为数组第一个元素（即数组下标为 $0$ 或 $1$）；二、模拟高精度加法和减法，用函数封装（或重载），最后输出，注意这里也要从高到低输出。
# Code
```c
#include<iostream>
using namespace std;
int a[100005],b[100005],s[100005],k[100005];
int n;
void jia()//高精度加法
{
    for(int i=1;i<=n;i++)
    {
    k[i]+=a[i]+b[i];
    k[i+1]+=k[i]/s[i];
    k[i]%=s[i];
    }
}
void jian()//高精度减法
{
    for(int i=1;i<=n;i++)
    {
        while(a[i]<b[i])
        {
            a[i]+=s[i];
            a[i+1]--;
        }
        k[i]=a[i]-b[i];
    }
}
int main()
{
    cin>>n;
    for(int i=n;i>=1;i--)
    cin>>s[i];
    for(int i=n;i>=1;i--)
    cin>>a[i];
    char t;
    cin>>t;
    for(int i=n;i>=1;i--)
    cin>>b[i];
    if(t=='+')
    jia();
    else
    jian();
    for(int i=n;i>1;i--)
    cout<<k[i]<<" ";
    cout<<k[1]<<endl;
    return 0;
}
```
最后，如果代码中有什么错误，望大家指出！





---

## 作者：weicongjun (赞：0)

# 洛谷 $P4282 [AHOI2008]$ 计算器（题解）

### 当解决这个问题时，可以按照以下详细的思路来实现算法：

#### 1. 读取输入参数：
- 首先读取计算器所支持的变进制数的长度 $N$。
- 然后读取每一位的进制数 $x_1, x_2, ..., x_n$。
- 接着读取第一个运算数 $A$。
- 再读取运算类型 $op$。
- 最后读取第二个运算数 $B$。

#### 2. 计算最大整数 $M$：
- 根据题目描述，计算器可以表示的最大整数 $M$ 等于 $(x_1 \times x_2 \times ... \times x_n) - 1$。
- 可以使用一个变量 $M$ 来保存这个最大整数。

#### 3. 进行加法或减法运算：
- 如果运算类型 $op$ 是 $+$，则将 $A$ 和 $B$ 相加得到 $sum$。
- 如果运算类型 $op$ 是 $-$，则将 $A$ 和 $B$ 相减得到 $diff$。

#### 4. 取模运算：
- 对于加法运算，将 $sum$ 对 $(M + 1)$ 取模，得到最终的运算结果。
- 对于减法运算，将 $diff$ 对 $(M + 1)$ 取模，得到最终的运算结果。

#### 5. 输出结果：
- 将最终的运算结果按照变进制的形式输出，需要注意以下几点：
- 结果需要以变进制的形式输出，即每一位的取值范围是 $0$ 到 $x_i-1$。
- 需要补齐高位的零，确保结果长度与输入进制数的长度一致。
- 不需要在最高位之前和最低位之后插入空格。

通过按照上述详细的思路来实现算法，可以保证正确地进行变进制整数的加法或减法运算，并输出正确的结果。


------------

根据上述算法的思路，可以分析出以下的时间复杂度和空间复杂度：

#### 1. 时间复杂度：
- 读取输入参数的过程需要常数级的时间复杂度，记为 $O(1)$。
- 计算最大整数 $M$ 只需要对每个进制数进行一次乘法和一次减法操作，因此时间复杂度为 $O(N)$。
- 进行加法或减法运算的时间复杂度也是 $O(N)$，因为需要对每一位进行相应的运算。
- 取模运算操作的时间复杂度为 $O(N)$，因为需要对结果进行一次取模运算。
- 输出结果的时间复杂度也是 $O(N)$，因为需要将结果转换为变进制形式并输出。

综合起来，整个算法的时间复杂度为 $O(N)$。

------------

#### 2. 空间复杂度：
- 算法只使用了固定数量的变量和常数级的辅助空间，因此空间复杂度是 $O(1)$，即常数级。

需要注意的是，这里的时间复杂度和空间复杂度分析都是基于输入进制的长度 $N$ 来计算的。如果还有其他的数据结构或操作，可能会对时间复杂度和空间复杂度产生影响。

总结起来，该算法具有线性的时间复杂度和常数级的空间复杂度。

------------

# 接下来奉上 $AC$ 代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N;
    cin >> N;
    
    vector<int> x(N);
    for (int i = 0; i < N; i++) {
        cin >> x[i];
    }
    
    vector<int> A(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    
    char op;
    cin >> op;
    
    vector<int> B(N);
    for (int i = 0; i < N; i++) {
        cin >> B[i];
    }
    
    long long M = 1;
    for (int i = 0; i < N; i++) {
        M *= x[i];
    }
    M -= 1;
    
    vector<int> result(N, 0);
    
    if (op == '+') {
        int carry = 0;
        for (int i = N - 1; i >= 0; i--) {
            int sum = A[i] + B[i] + carry;
            result[i] = sum % x[i];
            carry = sum / x[i];
        }
    } else {
        int borrow = 0;
        for (int i = N - 1; i >= 0; i--) {
            int diff = A[i] - B[i] - borrow;
            if (diff < 0) {
                diff += x[i];
                borrow = 1;
            } else {
                borrow = 0;
            }
            result[i] = diff;
        }
    }
    
    for (int i = 0; i < N; i++) {
        cout << result[i] << " ";
    }
    
    return 0;
}
```

---

## 作者：Mingci (赞：0)

# P4282 [AHOI2008] 计算器
[题目传送门](https://www.luogu.com.cn/problem/P4282)
## 题意概要
有一个支持变进制的计算器，输入的第一行的一个整数 $N$ 是要进行计算的两个数的位数，第二行是每一位的进制，接下来是要进行计算的的一个数、运算符号以及参与运算的第二个数，最后要输出的是运算的结果。

## 本题思路

真的那么简单吗？看一下数据范围，嗯……似乎不太正常，这道题需要高精度加减法，那什么是高精度呢？简单来说就是一个数用 long long 都装不下，就要用其他的方法存下它并进行运算。常见的方法是每一位存，再每一位进行运算，同时考虑进退位，存到另一个数组中。就比如一种高精度加法：

[高精度加法运算](https://www.luogu.com.cn/paste/q8ss95uv)

本题的所有数都已经分隔开来了，所以并不用用字符串，直接用 int 类型存下每一位数字，在进行高精度运算时再考虑进制转换，加减法的过程只需要用两个简单的 void 类型的函数存下就好了。紧接着就是~~大家喜闻乐见的~~代码环节了！
## 本题代码
```cpp
#include <iostream>
#include <stdio.h>
#include <cstdio>
#define  MAXN 100005
using namespace std;
int n;
int a[MAXN],b[MAXN],c[MAXN],bin[MAXN];//分别是第一第二个数，结果以及每一位的进制
char op;//运算符号
void jia(){//加法高精运算
    for(int i = n;i >= 1;i--){//从后往前
        c[i]+=a[i]+b[i];
        if(c[i] >= bin[i]){
            c[i-1]+=c[i]/bin[i];
            c[i]=c[i]%bin[i];
        }//进制转换
    }
}
void jian(){//减法高精运算
    for(int i = n;i>= 1;i--){//从后往前
        c[i]+=a[i]-b[i];
        if(c[i]<0){
            c[i]+=bin[i];
            c[i-1]-=1;
        }
    }
    //原理与加法高精运算相似
}
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i++)scanf("%d",&bin[i]);//读入每一位进制
    for(int i = 1;i <= n;i++)scanf("%d",&a[i]);//读入第一个数
    cin >> op;//不知道为什么我这用scanf样例过不了，只好改成cin
    for(int i = 1;i <= n;i++)scanf("%d",&b[i]);//读入第二个数
    op=='+'?jia():jian();//三目运算符，可以理解成op是'+'吗？如果是就进行加法，如果不是就进行减法
    for(int i = 1;i <= n-1;i++)printf("%d ",c[i]);//输出前n-1位的结果
    printf("%d",c[n]);//输出最后一位
    return 0;//圆满结束
}

```
写过的第一题高精度题解，不知道解释得清晰不清晰，但是希望对大家有帮助。



---

## 作者：liupei (赞：0)

## 解题思路 
根据题目描述，我们需要先计算出变进制数的最大值 $M$，然后根据运算符进行相应的加法或减法运算，最后将结果对 $(M+1)$ 取模。

首先，我们可以使用一个列表 x 存储输入的变进制数的进制值，然后遍历这个列表，计算 $M$ 的值。根据题目描述，$M$ 的值为 $(x_1 \times x_2 \times \cdots \times x_n) - 1$。

接下来，我们需要实现加法和减法运算。由于变进制数的每一位的进制可以不同，所以在进行进位运算时，需要根据当前位的进制值来进行计算。我们可以使用一个列表 $carry$ 存储每一位的进位值。

对于加法运算，我们从最低位开始，将对应位的两个数相加，然后将结果除以对应位的进制值取整得到进位值，同时更新当前位的结果为对应位相加的余数。最后，我们将结果对 $(M+1)$ 取模。

对于减法运算，我们需要注意如果被减数小于减数，则需要从高位向低位借位。我们从最低位开始，如果被减数小于减数，则需要向高位借位，借位的规则是将当前位的进制值加到被减数上，并将当前位的进位值设为 $-1$。然后，我们将对应位的两个数相减，如果结果小于 $0$，则需要向高位借位。最后，我们将结果对 $(M+1)$ 取模。

最后，我们将计算结果输出，每一位之间用一个空格隔开，注意高位补零，最高位之前和最低位之后不要有空格。

---

## 作者：jiangchen1234 (赞：0)

##  题目分析
看一眼数据范围便可知

> 高精度

要来了。

接下来谈谈高精度。

## 高精度
所谓高精度，就是一场大模拟。

原因很简单，高精度的原理就是把数拆分成个个位后进行加减乘除。

## 高精度加法

本题只涉及高精度加法和减法，现在来介绍一下高精度加法。

小学学过加法竖式，其实高精度加法和列数字很像，都是从个位加起，逢十进一。

也就是

> $c_{i} = a_{i} + b_{i}$

逢十进一，所以

```cpp
if(c[i] >= 10){
	c[i + 1] += c[i] / 10;
	c[i] %= 10;
}
```
### 附上高精度加法代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 505;
int a[maxn],b[maxn],c[maxn],len1,len2,len3;
char str1[maxn],str2[maxn];
int main(){
	cin >> str1;
	cin >> str2;
	len1 = strlen(str1);
	len2 = strlen(str2);
	for(int i = 0;i < len1;i++){
		a[len1 - i] = str1[i] - '0';
	}
	for(int i = 0;i < len2;i++){
		b[len2 - i] = str2[i] - '0';
	}
	len3 = max(len1,len2);
	for(int i = 1;i <= len3;i++){
		c[i] += b[i] + a[i];
		if(c[i] >= 10){
			c[i] %= 10;
			c[i + 1]++;
		}
	}
	if(c[len3 + 1] != 0){
		len3++;
	}
	for(int i = len3;i >= 1;i--){
		cout<<c[i];
	}
	return 0;
}
```
高精度减法和加法类似，可以自行推导。
## 本题思路
因为输入每个数字是分开的，可以直接输入，不用 string 来输入。

本题和高精度唯一的不同是进制不同。

故不再讲解。

## 附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100005;
int a[maxn],b[maxn],c[maxn],x[maxn],n;
char op;
void add() {
	for(int i = n; i >= 1; i--) {
		c[i] += a[i] + b[i];
		if(c[i] >= x[i]) {
			c[i - 1] += c[i] / x[i];
			c[i] %= x[i];
		}
	}
}
void jian() {
	for(int i = n; i >= 1; i--) {
		c[i] += a[i] - b[i];
		if(c[i] < 0) {
			c[i] += x[i];
			c[i - 1] -= 1;
		}
	}
}
int main() {
	cin>>n;
	for(int i = 1; i <= n; i++) {
		cin>>x[i];
	}
	for(int i = 1; i <= n; i++) {
		cin>>a[i];
	}
	cin>>op;
	for(int i = 1; i <= n; i++) {
		cin>>b[i];
	}
	if(op == '+') {
		add();
	} else {
		jian();
	}
	for(int i = 1; i <= n - 1; i++) {
		cout<<c[i]<<" ";
	}
	cout<<c[n]<<endl;
	return 0;
}
```


---

## 作者：ttq012 (赞：0)

显而易见这题是高精度加减法的板子题。

由于可以表示的数最大是 $M$，所以求的实际上就是 $A+B$ 和 $A-B$ 的值。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 101000;
int x[N], a[N], b[N], c[N];
signed main()
{
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++)  
    cin >> x[i];
  for (int i = 1; i <= n; i++)  
    cin >> a[i];
  char o;
  cin >> o;
  for (int i = 1; i <= n; i++)  
    cin >> b[i];
  if (o == '+')
  {
    for (int i = 1; i <= n; i++)
      c[i] = a[i] + b[i];
    for (int i = n; i; i--)
      c[i - 1] += c[i] / x[i], c[i] %= x[i];
    for (int i = 1; i <= n; i++)
      cout << c[i] << ' ';
    cout << '\n';
  }
  else
  {
    for (int i = 1; i <= n; i++)
      c[i] = a[i] - b[i];
    for (int i = n; i; i--)
      if (c[i] < 0)
      {
        c[i] += x[i];
        c[i - 1]--;
      }
    for (int i = 1; i <= n; i++)
      cout << c[i] << ' ';
    cout << '\n';
  }
  return 0;
}
```

---

## 作者：rain_dew (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P4282)

一道**高精度进制**模板题。

### 思路：

高精度，就是在处理大数据（例如本题目 $10^5$ 位数）时用数组模拟加减法。

在模拟过程中，按照从低位到高位进行运算（为了方便，我先按照从低位到高位）。

同时考虑本题的不同进制，要对新加上的数进行取余并进位。然后按照题目要求输出。

### 满分代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,zhuan[100005],a[100005],b[100005];
char yun;
int main()
{
	scanf("%d",&n);
	for (int i=n;i>=1;i--)
		scanf("%d",zhuan+i);
	for (int i=n;i>=1;i--)
		scanf("%d",a+i);
	scanf(" %c",&yun);//读取运算符时，scanf可以读取空格回车，因此在前面加空格过滤
	for (int i=n;i>=1;i--)
		scanf("%d",b+i);
	if (yun=='+')//+
		for (int i=1;i<=n;i++)
		{
			a[i]+=b[i];
			a[i+1]+=a[i]/zhuan[i];
			a[i]=a[i]%zhuan[i];
		}
	else//-
		for (int i=1;i<=n;i++)
		{
			while (a[i]<b[i])//a一定会大于b 借位减法
			{
				a[i+1]--;
				a[i]+=zhuan[i];
			}
			a[i]-=b[i];
		}
	for (int i=n;i>=2;i--)
		printf("%d ",a[i]);
	printf("%d",a[1]);
	return 0;
}
```

---

## 作者：jxbe6666 (赞：0)

作为一道模板题，某蒟蒻认为难度系数不大。  
### 题目描述:
- 一个整数 $N$ ,表示计算器的长度。
-  $N$ 个整数$x_1,x_2,…,x_N$，表示1~$N$位的进制。
- 两个分别是长度为 $N$ 的运算数。 
- 一个运算符，表示要实现的运算。
- 你需求出两个运算数经过运算后的值。
- $N≤10^5$，且值要对最大的变进制整数 $M+1$ 取模。

### 主要思想：
看到 $N≤10^5$，我们意识到这道题要用到高精！！！  
在计算出结果后，我们需要对一个数 $M+1$ 取模，而高精度取模是很麻烦的 (
~~其实是我不愿意写~~
) 所以我找到了一个可以巧妙避免取模的方法那就是:   
**直接输出 N 位的值。**

一个小坑点: 输入的数应该需要 reverse 一下。

------------

至于如何不取模，以下给出证明。  
已知 $M$ 为 $N$ 位可变进制数中的最大整数。  
当运算符为加时:   如果两个运算数的和大于了 $M$,那么
最后的值只会影响到 $N+1$ 位，而$1…N$ 位不会被影响，所以输出 $N$ 位就好。  
当运算符为减时:   如果两个运算数的差小于0,根据取模的性质:一个负数模一个正数答案也会是正数,所以答案也只输出  $N$ 位就好。

------------
```cpp
#include <bits/stdc++.h>
#define in scanf
#define out printf
using namespace std;
int x[100005];
int a[100005];
int b[100005];
int c[100005];
int number,mod,sum;
char op;
int main(){
	in("%d",&number);
    //原来都是正着输入的,可是因为我懒,都改成倒着输入了
	for(int rp=number;rp>=1;rp--){
		in("%d",&x[rp]);
	}
	for(int rp=number;rp>=1;rp--){
		in("%d",&a[rp]);
	}
	cin>>op; //此处是一个坑点：假如你用scanf就会多读一个空格 
	for(int rp=number;rp>=1;rp--){
		in("%d",&b[rp]);
	}
//	到此为止都是输入 
	if(op=='+'){
//		当运算符是+时，执行加法操作 
		for(int rp=1;rp<=number;rp++){
			c[rp]=(a[rp]+b[rp]+sum)%x[rp];
			sum=(a[rp]+b[rp]+sum)/x[rp];
			/*
			十进制高精：
				c[rp]=(a[rp]+b[rp]+sum)%10;
				sum=(a[rp]+b[rp]+sum)/10;
				相比之下，就是把进制改成了x[rp]进制 
			*/ 
		}
	}else{
		for(int rp=1;rp<=number;rp++){//减法操作
			if(a[rp]<b[rp]){
				a[rp]+=x[rp];
				a[rp+1]--;
			}
			a[rp]-=b[rp];
			c[rp]=a[rp];
//			同样把十进制改为了x[rp]进制 
		}
	}
	for(int rp=number;rp>=1;rp--){-
		out("%d ",c[rp]); //  输出答案c数组 
	}
	 
	return 0;
}
```


蒟蒻的第一篇题解，管理员大大求过qwq
 

---


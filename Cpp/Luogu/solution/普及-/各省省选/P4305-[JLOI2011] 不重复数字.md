# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# 题解

## 作者：Rainbow_qwq (赞：83)

[P4305 [JLOI2011]不重复数字](https://www.luogu.com.cn/problem/P4305)

---

今天早上看见 xht37 说加强了数据。然后 `map/set` 就被卡掉了。

但是 C++11 的 `unordered_map` 是哈希，能过！

`unordered_map` 的定义与用法都与 `map` 差不多，只不过是用Hash来存储的，判断是$O(1)$的。

而`map`判断是$O(\log n)$的。

代码：（不开O2也过了）
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
inline int read()
{
	char c=getchar();int x=0,f=1;
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-48;
	return x*f;
}
int T,n,x;
unordered_map<int,bool>s;//定义
void work()
{
	s.clear();//清空
	n=read();
	For(i,1,n){
		x=read();
		if(!s[x]){//没有的话，直接输出+标记掉。
			printf("%d ",x);
			s[x]=1;
		}
	}puts("");//换行
}
int main()
{
	T=read();
	while(T--)work();
	return 0;
}
```

---

## 作者：Histone (赞：52)

~~有的时间复杂度是真的玄学~~

思路很暴力，~~只需要小学二年级思维~~
___

### 大致思路:

$\color{green}\text{我们建一个结构体数组，存每个数字的值和出现的位置,}$
$\color{green}\text{先把数字按照值排序一遍（值相同的话，按照位置由前到后排序）}$
$\color{green}\text{排序后方便去除重复的数字，每个数字只需要保留位置最靠前的那个便可（简单粗暴）}$
$\color{green}\text{然后我们再按照数字的位置排一下序，顺序输出我们保留的数字即可}$

首先建一个结构体 $\color{#FB6340}\text{struct num}$

```cpp
struct num{
	int id;//每个数字的位置
	int z;//每个数字的值
};
```

然后定义一下 $\color{#FB6340}\text{比较函数}$

```cpp
bool cmz(struct num a,struct num b){
	if(a.z>b.z)
		return true;
	if(a.z==b.z)
		if(a.id<b.id)
			return true;
	return false;
}
bool cmid(struct num a,struct num b){
	if(a.id<b.id)
		return true;
	return false;
}
```

好，有了这些后，我们就可以开始操作了
___

### 具体举例:

$$\color{white}\text{武汉加油}$$

#### 1.先把一串数字读入进来，并依次赋予id值

> $\color{#52C41A}\text{1 2 18 3 3 19 2 3 6 5 4 6 17 18}$

#### 2.将数字的值排序 $\color{#FB6340}\text{(sort)(num.z)(cmz函数)}$

> $\color{#52C41A}\text{id : 6 3 14 13 9 12 10 11 4 5 8 2 7 1}$

> $\color{#52C41A}\text{z  : 19 18 18 17 6 6 5 4 3 3 3 2 2 1}$

#### 3.去掉重复的数字

> $\color{#52C41A}\text{id : 6 3 14 13 9 12 10 11 4 5 8 2 7 1}$

> $\color{#52C41A}\text{z  : 19 18 0 17 6 0 5 4 3 0 0 2 0 1}$

```cpp
//这里z的0表示该数被删去（实际程序中，我们用-2147483659来代替）
```
#### 4.将数字的位置排序 $\color{#FB6340}\text{(sort)(num.id)(cmid函数)}$

> $\color{#52C41A}\text{id : 1 2 3 4 5 6 7 8 9 10 11 12 13 14}$

> $\color{#52C41A}\text{z  : 1 2 18 3 0 19 0 0 6 5 4 0 17 0}$

#### 5.输出答案

> $\color{#52C41A}\text{1 2 18 3 19 6 5 4 17}$

___
### 注意事项:

$$\color{white}\text{武汉加油}$$

#### 数据范围问题:

该题给出的数在32位有符号整数范围内
，所以我们用-2147483659来表示该数已被去除 ~~（开long long吧）~~

#### 关于去重的问题:

```cpp
for(int i=1;i<=n;i+=pd){
	pd = 1;
	for(int j=i+1;j<=n;j++){
		if(s[i].z==s[j].z)s[j].z = -2147483659,pd++;
		else break;
	}
}
```

变量 $\color{red}\text{pd}$ 的存在可以帮我们稍稍优化一下去重的过程

~~（避免毒瘤的数据：1 1 1 1 1 1  …… 1 1 1……1 1 1 1）~~

#### 关于读入的问题:

不加快读会爆掉后四个点或者后三个点 [爆TLE](https://www.luogu.com.cn/record/29935063)

咳咳，至于具体多少，取决于提交代码时的欧气值

___

### 最后附上代码:


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct num{
	int id;
	int z;
}s[50024];
int read(){
    int w=1,q=0;
	char ch=' ';
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return w*q;
}
bool cmz(struct num a,struct num b){
	if(a.z>b.z)
		return true;
	if(a.z==b.z)
		if(a.id<b.id)
			return true;
	return false;
}
bool cmid(struct num a,struct num b){
	if(a.id<b.id)
		return true;
	return false;
}
signed main(void){
	int t,n,pd;
	t = read();
	while(t--){
		scanf("%lld",&n);
		for(int i=1;i<=n;i++){
			s[i].id = i;
			s[i].z = read();
		}
		sort(s+1,s+n+1,cmz);
		for(int i=1;i<=n;i+=pd){
			pd = 1;
			for(int j=i+1;j<=n;j++){
				if(s[i].z==s[j].z)s[j].z = -2147483659,pd++;
				else break;
			}
		}
		sort(s+1,s+n+1,cmid);
		for(int i=1;i<=n;i++){
			if(s[i].z!=-2147483659)printf("%lld ",s[i].z);
		}
		printf("\n");
	}
	return 0;
}
```

~~(再次请求加强数据)(滑稽~~

这只是为了大家考场上可以多一个选择，~~说不定暴力踩标算呢~~

最好还是要掌握这题的HASH写法呀，(⑉• •⑉)‥♡

蒟蒻的第一篇绿题题解，如有错误，请指出，我一定会改正的，（●＾o＾●）

- 不吸氧测试信息 [点我](https://www.luogu.com.cn/record/29935122)

- 吸氧测试信息 [点我](https://www.luogu.com.cn/record/29938067)

$\color{pink}\text{最后一次编辑时间 : 2020.02.01 11:08}$

(显示后排版有些问题，现已修改，麻烦审核大大啦)

---

## 作者：skydogli (赞：25)

模拟赛的时候要用到哈希，于是yy了一发。

我们平时使用的哈希大概有两种：

- 比较一次开销很大

例如求字符串判重、判断两个区间排序后是否完全相同等，如果我们要保证正确，显然就要用$O(n)$的复杂度判断，这在很多时候是吃不消的，于是就使用哈希，对于不同的值或不同的位置赋一个随机值，每次比较字符串或区间的总权值，如果权值相等就判定相等。

显然，这样有错判的危险，所以我们很多人使用多个模数来尽量避免冲突。

- 比较一次开销不大，但是空间开不下

本题就是这种情况，我们显然可以取一个模数$P$,对于输入的数$a$,存入$a \pmod P$的集合中，每次判断时，把这个集合里的数全部取出来一一判断即可，而这个集合我们可以直接选择```vector```或邻接表，这样在平均意义下的复杂度就是$O(\frac{n^2}{P}+n)$了，显然能正确地判重。

那么，是不是P越大越好呢？我开始也是这么认为的，但是发现内存调用的开销反而占了相当大的比例。所以我们的P不许要开太大，尤其是用```vector```实现时，它的空间调用奇慢无比，但是访问连续的元素时又非常快，所以我们的P要开小一点，我实验出的最好的$P$在$10^4$左右，而邻接表的优劣势和和```vector```正好相反，所以可以大一点，但也仅仅是$3\times 10^4$左右，我们平时使用大可将P设为$\frac{n}{2}$左右的取值。

不过细心的朋友可能发现，当输入数据都是$kP+b$时，事情变得有点微妙，好像可以卡飞。如果对着模数卡……

这也比较好办，我们可以设置一个约为$[2P,10P]$的模数，将a先对这个数取模，这样的模数就比较随机了，再将它对$P$取模。（注意这个大模数不能太大，不然在大模数以内就被卡爆了）

要是两个模数都恰好被针对……建议您转行博彩行业哦！


code(```vector```):
```cpp#include<bits/stdc++.h>
using namespace std;
#define MN 200005
#define LL long long
inline LL read(){
	   LL a=0,fh=1;char c=getchar();
	   while(c>'9'||c<'0'){if(c=='-')fh=-1;c=getchar();}
	   while('0'<=c&&c<='9'){
		   a=a*10ll+c-48ll;
		   c=getchar();
	   }
	   return a*fh;
}
const int MD=(1<<17)-1,Mod=20007;
struct Hash{
	vector<LL>num[Mod],loc;
	bool vis[Mod];
	bool insert(LL a){
		int v=(a&MD)%Mod;
		for(int i=0;i<num[v].size();++i)
			if(num[v][i]==a)return 0;
		num[v].push_back(a);
		if(!vis[v])vis[v]=1,loc.push_back(v);
		return 1;
	}
	void clear(){
		for(int i=0;i<loc.size();++i){
			num[loc[i]].clear();
			vis[loc[i]]=0;
		}
		loc.clear();
	}
}Map[2];
int main(){
	int T=read();
	while(T--){
        Map[0].clear();
		Map[1].clear();
		int q=read();
		while(q--){
			LL a=read(),op=0;
            if(a<0)a=-a,op=1;
			if(Map[op].insert(a)) {if(op)putchar('-');printf("%lld ",a);}
		}
		puts("");
	}
	return 0;
}
```
code(邻接表）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline LL read(){
	   LL a=0,fh=1;char c=getchar();
	   while(c>'9'||c<'0'){if(c=='-')fh=-1;c=getchar();}
	   while('0'<=c&&c<='9'){
		   a=a*10ll+c-48ll;
		   c=getchar();
	   }
	   return a*fh;
}
const int MD=(1<<18)-1,Mod=30007,Maxn=50005;
struct Hash{
	int head[Mod],nex[Maxn];
	LL val[Maxn];
	int cnt;
	vector<int>loc;
	bool vis[Mod];
	void ADD(int x,LL y){
		cnt++;
		nex[cnt]=head[x];
		val[cnt]=y;
		head[x]=cnt;
	}
	bool insert(LL a){
		int v=(a&MD)%Mod;
		for(int i=head[v];i;i=nex[i])
			if(val[i]==a)return 0;
		ADD(v,a);
		if(!vis[v])loc.push_back(v),vis[v]=1;
		return 1;
	}
	void clear(){
		cnt=0;
		for(int i=0;i<loc.size();++i)vis[loc[i]]=0,head[loc[i]]=0;
		loc.clear();
	}
}Map[2];
int main(){
	int T=read();
	while(T--){
        Map[0].clear();
		Map[1].clear();
		int q=read();
		while(q--){
			LL a=read(),op=0;
            if(a<0)a=-a,op=1;
			if(Map[op].insert(a)) {if(op)putchar('-');printf("%lld ",a);}
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：万弘 (赞：18)

一眼看去显然是用桶的思路来做.只不过数的范围是32位整数,没法直接开桶.显然的思路是离线然后离散化再开桶.  
我不喜欢离线做法,就随手写了FHQ_Treap打算水过去
![](https://cdn.luogu.com.cn/upload/image_hosting/wtpgitxw.png)
擦,是我FHQ常数太大了嘛...再看下数据范围,喔,好像$O(nlogn)$是$5\times 10^7$这个好像是跑不太过.

好吧,那我认真点...  
就是hash维护开散列.hash值直接就用对size取模的结果,相同的用链表串在一起然后查就好了.期望下分布均匀,单次操作时间复杂度$O(1)$,总时间复杂度$O(n)$

注:此题有负数,cpp的取模无法把负数转成正数,要`(x%size+size)%size`这样写  
然后最长点402msAC..真就自带大常数呗.
```cpp
/**********/省略快读
#define MAXN 200011//即size,开散列大小,同时也是模数
struct hash_table
{
    ll last[MAXN],nxt[MAXN],cnt;//链表
    ll val[MAXN];
    void build()//清空
    {
        cnt=0;
        memset(last,0, sizeof(last));
    }
    ll hash(ll x)//hash值
    {
        return (x%MAXN+MAXN)%MAXN;
    }
    bool insert(ll x)//插入x,如果已经有x返回0,否则返回1
    {
        ll f=hash(x),cur=last[f];
        while (cur&&val[cur]!=x)
        {
            cur=nxt[cur];
        }
        if (cur)return 0;
        ++cnt;
        val[cnt]=x,nxt[cnt]=last[f],last[f]=cnt;
        return 1;
    }
}t;
int main()
{
    ll task=read();
    while (task--)
    {
        t.build();
        ll n=read();
        for (int i = 1; i <= n ; ++i)
        {
            ll x=read();
            if (t.insert(x))printf("%lld ",x);
        }
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Arghariza (赞：15)

更好的阅读效果请来我的[博客]()

看来大部分人都是用```unordered_map```水过去的...

咳咳，这题正解其实是哈希，由于善良的xht加强的数据，所以普通哈希是过不了的！

所以我们似乎除了```unordered_map```只能用拉链哈希了QwQ（还有什么方法我实在是想不到了）

- 首先是定义一个模数：

```#define mod 100007```

- 还有定义longlong（其实不用加longlong的QwQ）：

```#define ll long long```

- 接着是我们的哈希向量：

```vector<int> Hash[100007];```

- 然后就是普普通通的定义变量：

```
int maxx, t, n, num;//t表示组数，n表示个数，num表示答案，maxx表示最大值
```

- 加上快读（没啥好说吧）：

```
inline int read() {
    int w = 1, q = 0;
    char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
}
```

- 重新定义一下max函数：

```
ll max(ll x, ll y) {
    return (x > y) ? x : y;
}
```

- 接着是check函数：

```
bool check(int val) {//传进val参数
    ll pos = (val % mod + mod) % mod;//初始化pos
    maxx = max(maxx, pos);//更新最大值
    for (int k = 0; k < Hash[pos].size(); k++) {//遍历向量
        if (Hash[pos][k] == val) {//如果有某一个值等于参数
            return true;//返回成功
        }
    }
    Hash[pos].push_back(val);//如果找不到那就push_back一下
    return false;//返回失败
}
```

- 接着就是mian函数里面的部分了：

```
t = read();//输入t
while (t--) {//t--表示输入组数
    n = read();//输入n
    for (int i = 0; i <= maxx; i++) Hash[i].clear();//初始化Hask向量
    maxx = 0;//初始化最大值
    for (int i = 1; i <= n; i++) {//枚举
        num = read();//输入num
        if(!check(num)) cout << num << " ";//如果找不到num则输出
    }
    cout << "\n";//换行
}
```

- 所以整个代码就出来了：

```
#include <iostream>
#include <vector>
#include <cstdio>
#define mod 100007
using namespace std;

vector<int> Hash[100007];
int maxx, t, n, num;

inline int read() {
    int w = 1, q = 0;
    char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
}

int max(int x, int y) {
    return (x > y) ? x : y;
}

bool check(int val) {
    int pos = (val % mod + mod) % mod;
    maxx = max(maxx, pos);
    for (int k = 0; k < Hash[pos].size(); k++) {
        if (Hash[pos][k] == val) {
            return true;
        }
    }
    Hash[pos].push_back(val);
    return false;
}

int main() {
    t = read();
    while (t--) {
        n = read();
        for (int i = 0; i <= maxx; i++) Hash[i].clear();
        maxx = 0;
        for (int i = 1; i <= n; i++) {
            num = read();
            if(!check(num)) cout << num << " ";
        }
        cout << "\n";
    }
    return 0;
}
```

---

## 作者：Ckger (赞：14)

这道题就是一个典型的Hash。

这题其实难死了。
1.开一个Hash数组。

2.t组数据，处理每组数据的时候先清空Hash数组。

3.对于每组数据，依次读入n个数，每次对一个数进行处理：

**如果存在于Hash中，则不用管，不存在的话就将其添加进Hash数组，然后将其输出即可。**

end。

就是这么简单，但是对于这个方法，需要注意Hash数组的初始化！

初始化时不可简单地初始化为-1（因为-1也有可能进入数组），因此应该初始化为一个INF（我随便赋的值）。

就是这么个鬼，下面附上代码，代码有注释。

# code:


```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define hmod 4698571    //对于Hash数组的mod值
inline ll read();

ll Hash[hmod+123456];   //Hash需开大一点

inline bool find(ll x)
{
	ll wh=abs(x%hmod);   //对于负数只需处理一个定值即可，表示位置
	while (Hash[wh]!=1808504320951916825)//如果当前位置有数
	{
		if (Hash[wh]==x) //查看是否为此数
			return true; //返回true
		else
			++wh;      //否则查找下一个位置
	}
	Hash[wh]=x;       //没找到则放入Hash中
	return false;      //返回false
}

ll t,n;

int main()
{
	t=read();
	while (t--)
	{
		memset(Hash,25,sizeof(Hash));//每次将Hash赋初始值，此时Hash中的值正是1808504320951916825（随便乱赋的值）
		n=read();
		for (register int i=1;i<=n;++i)
		{
			ll k=read(); //每次读入k
			if (!find(k))//如果k没进入数组
				cout<<k<<" ";//输出（"放入"已经在函数中执行了）
		}
		cout<<endl;     //回行
	}
	return 0;
}

inline ll read()		//快读（不解释了）
{
	ll x=0,f=0;
	char c=getchar();
	while (!isdigit(c))
		f|=c=='-',c=getchar();
	while (isdigit(c))
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x;
}
```

灰名小蒟蒻我希望大家看了题解之后能够理解清楚，谢谢。

---

## 作者：Aehnuwx (赞：13)

今天凌晨看到了这道题目，发现原来的哈希表做法被 xht 巨佬 hack 啦，只得了 60 分，RE 了 4 个点！

很疑惑，于是又写了一遍，发现还是和原来一样的结果。对着代码看了良久，发现给出的数可以为负数，然后就会出现负数下标...

于是就写了一个负数取模（然而我菜得很，写炸了 2 次）。这才 AC 此题。


------------
这道题实际上是哈希表的模板题。每读入一个数，就判断在哈希表中是否重复了。如果出现了重复，就直接退出，继续读入下一个数。否则，就将这个数插入哈希表中，并输出该数即可。

需要注意的一点是，哈希函数如果直接写成 $\operatorname{H}(x)=x\bmod  P$ 的话会出现上文中说的负数下标，所以正确的写法是 $\operatorname{H}(x)=(x\bmod P+P)\bmod P$。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int P=50021;
#define int long long
struct node {int v,nxt;}rec[10+P];
int hd[10+P],n;
namespace HASH {
int tot;
int H(int x) {return (x%P+P)%P;}
bool add(int x, int v) {
	for (int i=hd[x];i;i=rec[i].nxt) if (rec[i].v==v) return false;
	rec[++tot].v=v;
	rec[tot].nxt=hd[x];
	hd[x]=tot;
	return true;
}
}
using HASH::tot;
using HASH::H;
using HASH::add;
void rd(int&),wt(int);
#undef int
int main() {
#define int long long
	int T;rd(T);
	while(T--) {
		tot=0;memset(rec,0,sizeof rec);memset(hd,0,sizeof hd);rd(n);
		while (n--) {
			int x;rd(x);
			if (add(H(x),x)) wt(x),putchar(' ');
		}
		puts("");
	}
	return 0;
}
void rd(int& x) {
	x=0;int f=1;char ch=getchar();
	while (!isdigit(ch)) (ch=='-')&&(f=-1),ch=getchar();
	while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;
}
void wt(int x) {
	(x<0)&&(x=-x,putchar('-'));
	if (x>9) wt(x/10);putchar(x%10^48);
}
```


---

## 作者：高天 (赞：13)

先看看定义

[去重](https://blog.csdn.net/qq_41139830/article/details/80631988)

思路：
这题的目标就是去重

先把整个序列按值排序一遍，在按值去重，再按原来的顺序排回去，就这么简单

注意使用sort

时可能会打乱前后顺序，所以也要在排序时加入另外加入与位置有关的条件

复杂度O(nlogn)

代码：

```cpp
#include<cstdio>
#include<algorithm>
#define re register
using namespace std;
template <typename T>
inline void read(T &x) {
	x=0;
	char s=(char)getchar();
	bool flag=false;
	while(s<'0'||s>'9') {
		if(s=='-')
			flag=true;
		s=(char)getchar();
	}
	while(s>='0'&&s<='9') {
		x=(x<<1)+(x<<3)+(s^'0');
		s=(char)getchar();
	}
	if(flag)
		x=~x+1;
	return;
}
const int N=5e4+5;
int n;
struct node {
	int val,id;
	inline bool operator <(const node &rhs)const {
		return val<rhs.val||val==rhs.val&&id<rhs.id;
	}
	inline bool operator ==(const node &rhs)const {
		return val==rhs.val;
	}
} a[N];
inline bool cmp(const node &x,const node &y) {
	return x.id<y.id;
}
int main() {
	int T;
	read(T);
	while(T--) {
		read(n);
		for(re int i=1; i<=n; ++i) {
			read(a[i].val);
			a[i].id=i;
		}
		sort(a+1,a+1+n);
		n=unique(a+1,a+1+n)-1-a;
//      printf("%d\n",n);
		sort(a+1,a+1+n,cmp);
		for(re int i=1; i<=n; ++i)
			printf("%d ",a[i].val);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：FjswYuzu (赞：10)

不得不说 xht37 的效率十分之高，当初也是用 `map` 水过去的。现在来写一下正解。

用一种类似于离散化的思想，将一个数的位置和值保存在一个结构体内。按：

- 如果值不同，值小的在前面；

- 否则，位置在前的在前面。

排序，得到这样一个序列。

记录排序后序列的第一个数（因为它一定是会输出的），保存自 `rear` 数组，并储存位置是否有数。依次便利，遇到不同的数就再次保存进去。注意下标是什么。然后再遍历一边数组，如果这里有数，输出，否则下一个。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct number{
	int val,whe;
	bool operator < (number compare) const {
		if(val-compare.val)	return val<compare.val;
		else	return whe<compare.whe;
	}
}a[50005];//保存序列
int rear[50005];//去重后序列的样子
bool isFull[50005];//是否有数
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		int n;
		scanf("%d",&n);
		memset(isFull,false,sizeof isFull);
		for(int i=1;i<=n;++i)	scanf("%d",&a[i].val),a[i].whe=i;
		sort(a+1,a+1+n);
		rear[a[1].whe]=a[1].val,isFull[a[1].whe]=true;
		for(int i=2;i<=n;++i)	if(a[i].val-a[i-1].val)	rear[a[i].whe]=a[i].val,isFull[a[i].whe]=true;
		for(int i=1;i<=n;++i)	if(isFull[i])	printf("%d ",rear[i]);
		puts("");
	}
	return 0;
}
```

---

## 作者：HansLimon (赞：10)

虽说是个题解，但不是什么正儿八经的题解。

## 准备
考虑**平板电视**$pbds$，毕竟数据加强了。

pbds的hash_table用法和map几乎是一样的，值得提一点的是：
	
> gp_hash_table 也就是探测法，难删除元素、元素过多容易崩、空间预先准备、速度快

> cc_hash_table 就是拉链法，易删除元素、平均查找长度短、空间动态申请、速度慢

其实如果不是很特殊的情况(比如水题(比如水本题www))的话，没啥区别，用法都一样，选一个自己喜欢的就好qwq

## 思路
考虑本题，建一个从long long到boolean的gp_hash_table(因为题意不删除元素)。

然后对于每组的每个数值，用hash_table来看对应的映射是否为true。为true，那么直接跳过；为false，那么标记其映射为true，然后直接输出。这样做不会影响输入的顺序，而且节省了空间。

还有一点，对于每组数据，首先把hash_table清空，和map用法一样，$clear()$就好。

## 代码
为了不占用太多位置，我就把快读给省去了qwq。担心从来都打正解的神犇们不知道挂什么头，所以把头挂上。(~~打正解的神犇怎么会看这篇文章~~)

注释在代码中

```cpp
#include <ext/pb_ds/assoc_container.hpp>//pbds容器
#include <ext/pb_ds/hash_policy.hpp>//这个才是hash_table本体
using namespace __gnu_pbds;

int T, n;//数据总数、每组数字个数
long long now;//当前输入的数值
gp_hash_table<long long, bool> corder;//直接从数值映射到布尔值，避免find操作炸掉

int main(){
	quick_read(T);
	while (T --){
		corder.clear();//针对每一组而言，corder要清空
		quick_read(n);
		while (n --){
			quick_read(now);
			if (corder[now])continue;//存在这个值就直接跳过
			printf("%lld ", now);//反之立即输出，这样不用准备数组
			corder[now] = true;//标记已存在
		}
		putchar(10);//换行
	}
	return 0;
}
```

---

## 作者：loveJY (赞：5)

`题目描述`

给定$n$个数，要求把其中重复的去掉，只保留第一次出现的数。


离散(或去重)练习题,这里分析一下几种方法

> 1.STL法

众所周知,STL有一个容器叫map,他最大的功能就是可以把数组下标扩展到任意类型,而且支持和数组一样便捷的访问方法.

但是实现方式是平衡树,访问和加入都是logn的,平衡树的log大的惊人,过不了这题加强数据

`unordered_map`本质好像是hash表,内部元素无序,访问是O1,不知道能否通过,毕竟hash是可以冲突的,冲突越多应该越慢

> 2.标准排序去重

~~好像也是STL~~

因为logn有大有小,所以我们选择一个小的logn->sort!,sort的log肯定是要比平衡树的小

具体实现时我们要保持原下标的有序性,所以再新开一个数组记录读入值,将新数组sort一下,我们再用STL中的unique将排好序数组去重,最后拿出原数组在新数组上lower_bound找到对应下标就是离散后的值了

有了离散后的值就可以用vis数组来直接判重了!~~这个O1是严格的qwq~~

代码采用第二种方法

复杂度$\Theta ( \text{Tn} \log _ {2} \text{n} ) $

Code:

```cpp

//From: Dawn light
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>

using std::lower_bound;
using std::vector;
using std::unique;
using std::sort;

const int MAXN=5e4+7;
int arr[MAXN];
vector<int> v;
int vis[MAXN],n,T;

namespace fastIO {
#define BUF_SIZE 100000
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		int f=1;
		register char s=nc();
		for(; !isdigit(s); s=nc())if(s=='-')f=-1;
		for(; isdigit(s); s=nc())x=(x<<1)+(x<<3)+s-'0';
		return x*f;
	}
}
using namespace fastIO;

inline int getid(int x) {
	return lower_bound(v.begin(),v.end(),x)-v.begin()+1;
}

inline void init() {
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());
	register int tmp;
	for(register int i=1; i<=n; i++) {
		tmp=arr[i];
		arr[i]=getid(arr[i]);
		if(!vis[arr[i]])printf("%d ",tmp),vis[arr[i]]=1;
	}
	return ;
}

int main() {
	T=read();
	for(register int l=1; l<=T; l++) {
		v.clear();
		n=read();
		for(register int i=1; i<=n; i++) {
			arr[i]=read();
			v.push_back(arr[i]);
		}
		init();
		printf("\n");
		memset(vis,0,sizeof(vis));
	}
	return 0;
}

```

---


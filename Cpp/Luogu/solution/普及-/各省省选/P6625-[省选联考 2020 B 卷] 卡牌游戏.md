# [省选联考 2020 B 卷] 卡牌游戏

## 题目描述

轩轩某天想到了一个卡牌游戏，游戏规则如下：

1. 初始时轩轩的手中有自左向右排成一排的 $n$ 张卡牌，每张卡牌上有一个整数分值。
2. 接下来，轩轩每次可以选取卡牌序列最左边的连续若干张卡牌（至少 $2$ 张），将它们替换为一张新卡牌。新卡牌将插入到序列的最左端，它的分值为本次操作中被替换掉的卡牌的分值之和。
3. 初始时轩轩总分为 $0$，每执行一次卡牌替换操作，新卡牌的分值将加到总分中。当序列长度为 $1$ 时游戏结束，轩轩也可以在任意时刻结束游戏。

现在给出序列中各个卡牌的分值，请你来帮助轩轩计算他能够获得的最高总分是多少？

## 说明/提示

**样例解释 1**

最优策略为，首先选择最左侧的两张卡牌，总分增加 $2 + (-1) = 1$。此时轩轩选择的两张卡牌被替换为一张分值为 $1$ 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $1$ 和 $2$。

接下来选择当前序列中所有卡牌，总分增加 $1 + 2 = 3$，总分为 $4$。此时轩轩选择的两张卡牌被替换为一张分值为 $3$ 的卡牌，且被放入序列最左侧，此时序列中只有一张分值为 $3$ 的卡牌，游戏结束。

**样例解释 2**


最优策略为，首先选择最左侧的四张卡牌，总分增加  $(-4) + 3 + 0 + 7 = 6$。此时轩轩选择的四张卡牌被替换为一张分值为 $6$ 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $6, -3, -5, -3$。

再选择最左侧的两张卡牌，总分增加 $6 + (-3) = 3$，总分为 $9$。此时轩轩选择的两张卡牌被替换为一张分值为 $3$ 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $3, -5, -3$。

此时无论如何操作均无法使总分继续增大，轩轩选择结束游戏。

**数据范围与约定**

测试点 $1 \sim6 $ 满足：$1\le n\le 16, |a_i| \le 100$。

测试点 $7 \sim 12$ 满足：$1\le n\le 10^3, |a_i| \le 100$。

测试点 $13 \sim 20$ 满足：$1\le n\le 10^5, |a_i| \le 10^5$。

## 样例 #1

### 输入

```
3
2 -1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
7
-4 3 0 7 -3 -5 -3```

### 输出

```
9```

# 题解

## 作者：Cripple_Abyss (赞：150)

[题目传送门](https://www.luogu.com.cn/problem/P6625)

~~这可是省选题呀！！！早知道我也去报名了（但是我报不了QwQ）~~

## 题目本质：

- 取若干个前缀和，使他们的和最大

## 题目做法：

- 暴力枚举：如果前缀和大于$0$，则累加

### 注：第一个数的前缀和（也就是它本身）不加

时间复杂度：$O(n)$

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans,x,s,n;//注意开long long
int main() {
	cin>>n;
	for (ll i=1; i<=n; i++) {
		cin>>x;
		s+=x;
		if (s>0&&i!=1) 
			ans+=s;
	}
	cout<<ans;
	return 0;
}
```

都看到这里了，点个赞呗QwQ

---

## 作者：cxh315 (赞：16)

[题目传送门](https://www.luogu.com.cn/problem/P6625)

首先，面对形如要求计算$\sum_{j=1}^{i}a_j$的问题，我们要想到前缀和。

什么是前缀和呢？其实就是预先处理出$\sum_{j=1}^{i}a_j$存入数组S,使得$S_i$等于$\sum_{j=1}^{i}a_j$。不难发现，$\sum_{a}^{b}a_j=S_b-S_a$。

但是，这样计算前缀和，每计算一个$S_i$的时间复杂度为$O(n)$，总体预处理时间复杂度为$O(n^2)$，~~甚至比暴力还慢~~，如何更快的计算呢？

首先，看一个公式：$\sum_{i=1}^{b}a_i=\sum_{i=1}^{b-1}a_i+a_b$。根据前缀和的定义，我们可以得出：$S_i=S_{i-1}+a_i$，由此，我们可以得出前缀和的简便计算方式

```cpp
for(int i=1;i<=n;i++){
	scanf("%d",&a[i]);
	s[i]=s[i-1]+a[i];
}
```


利用这一特性，我们可以解出[这道题](https://www.luogu.com.cn/problem/P1115)。

然后，我们掌握了这一知识后，就可以开始做这道~~良心出题人的馈赠~~了

每次替换对答案的贡献等于最前面一张卡牌上的数值加替换的一段中其他卡牌的数值，而第一张卡牌上的数值等于之前被替换掉的卡牌数值之和，我们可以发现，这个值就等于原数组中本轮要替换的末尾元素下标的前缀和

而我们想让这个值尽量大，不难看出，每一次的选择无后效性，故这个值只要为正数就可以选择

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],s[100005],n;
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];
	}
	for(int i=2;i<=n;i++){
		ans+=max(0,s[i]);

	}
	cout<<ans<<endl;
} 
```


---

## 作者：CSP_Sept (赞：11)

枚举每个 $p=\sum\limits_{i=1}^ka_i(2\le k\le n)$，若 $p_k>0$，则把 $ans$ 加上 $p_k$。
___
**证明：** 令共进行 $m$ 步，第 $k(1\le k\le m)$ 次去前面 $b_k$ 个数。

显然第 $k$ 次相当于取**原数列**的前 $\sum\limits_{i=1}^kb_i$ 个数。

于是第 $k$ 次的得分：$p_k=\sum\limits_{i=1}^{\sum^{k}_{i=1}b_i}a_i$。

$\because$ 要使 $\text{Score}$ 尽可能大，$\therefore$ 要使 $p_k(2\le k\le m)$ 尽可能大，即：使取到的 $p_k(2\le k\le m)>0$。

证毕
___
注意开 `LL`。

代码：

```cpp
#include <cstdio>

#define int long long
int ans,tmp,sum;
signed main(){
    int n;
    scanf("%lld",&n);
    for(int i=0;i<n;i++){
        scanf("%lld",&tmp);
        sum+=tmp;
        if(sum>0&&i!=0) ans+=sum;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：hanzhongtlx (赞：6)

省选的橙题也是挺有意思的.jpg   


------------

首先，题解中的做法我并没有想到。 
  
但着不代表这题不可做，，，   

我们考虑什么时候收手合并，当然是负数了！   
如果负数后面有个很大的数呢？  
如果费力把后面的数纳入现在的卡，那么就会少一次合并机会，得不偿失，所以只要是非负数就合并为一个卡，同时更新 $sum$。  

记录一下合并完的卡片，作为第一张，第二张用一个动态的指针来记录一下，记得判断是否已经到了最后一张卡片，如果是的话并且总和比 $0$ 大，就加上，还有就是要注意 `long long`。   

### $Code$:
```cpp
#include"iostream"
#include"cstdio"
#include"cmath"
#include"cstring"
using namespace std;

#define read(x) scanf("%d",&x)
#define MAXN 100005 
#define ll long long

int n,a[MAXN];
ll sum=0,fir=0;
ll now=0;
int lst=2;

int main()
{
	read(n);for(int i=1;i<=n;i++) read(a[i]);
	fir=a[1];
	while(lst<=n)
	{
		now=fir+(ll)a[lst];
		if(lst==n&&now>=0) sum+=now;
		lst++;
		int k=lst;
		for(int i=k;i<=n;i++)
		{
			if(now>=0){sum+=now,fir=now;break;}
			now+=a[i],lst++;
			if(i==n&&now>=0) sum+=now;
		}
	}
	printf("%lld\n",sum);
	return 0;
}
```

---

## 作者：Miraik (赞：4)

前缀和简单题。

前缀和就是求$f_{i}=\sum_{j=1}^ia_j$。

显然有$f_{i}=f_{i-1}+a_{i}$。

即可$O(n)$求出$f_{1},f_{2},f_{3},...,f_{n}$。

回到这道题。

题面写：

轩轩每次可以选取卡牌序列最左边的**连续**若干张卡牌（至少$2$张），将它们替换为一张新卡牌。新卡牌将插入到序列的最左端，它的分值为本次操作中被替换掉的卡牌的分值之和。

这个问题就能转化为：

**在$f_{2},f_{3},f_{4},...,f_{n}$中选若干个数，使它们的和最大。**

显然就是求$f_{2},f_{3},f_{4},...,f_{n}$中所有正数的和。

注意：本题答案可达$10^5 * 10^5$，记得开 ```long long``` 。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
ll n,h,ans;
int main(){
	n=read(),h=read();//h为前缀和，f[1]不计入内 
	while(--n)//n-1次，从f[2]开始 
	    h+=read(),ans+=h>0?h:0;//在线求和即可，当当前前缀大于0是就加，否则不变
	printf("%lld\n",ans);
	return 0;
}

```

u1s1，这题比格雷码简单吧（小声


---

## 作者：Scintilla (赞：3)

B 卷人口普查题，场外选手写个题解。

记 $sum_i = \sum\limits_{j = 1}^ia_j$。

若当前替换到第 $i$ 个数，则此次替换的得分为 $sum_i$。

所以设每次替换到 $p_1, p_2, \dots, p_m(p_i \ne 1)$，那么我们要最大化

$$\sum\limits_{i = 1}^msum_{p_i}$$

于是把除去 $sum_1$ 的所有前缀和中大于 $0$ 的加起来即可。
```cpp
int n;
ll sum, ans;

int main() {
    n = read();
    Rep(i, 1, n) {
        sum += read();
        if (i != 1) ans += max(sum, 0ll);
    }
    printf("%lld", ans);
    return 0;
}
```


---

## 作者：听取MLE声一片 (赞：2)

这道题是贪心

1.合并替换操作其实是可以不进行的，只需要把前面几项累加起来就可以算出分值。所以说我们用一个变量存储从1到n个数字之前的和，每一次加上当前的和就行了

2.这个序列不总是整数，如果都是正数，就可以从头两两合并知道末尾，但是是有负数的，我们就可以跳过某些合并，判断依据是与0比较

注意：比较时需要两个long long 比较，所以0要用0ll

我们还可以边读入边计算，减小了码量

上代码：

```
#include<bits/stdc++.h>
using namespace std;
long long s,ans;
int n,x;
int main()
{
	cin>>n>>x,s=x;
	for(int i=2;i<=n;i++)
		cin>>x,s+=x,ans+=max(s,0ll);
	cout<<ans;
	return 0;
}
```

谢谢大家！

---

## 作者：Cult_style (赞：2)

贪心思路：尽量不取负数或每次只去一个负数

如$3$,$-2$,$-2$,$9$,$-1$

- 因为至少要取两个，那么第一组选的应该是$a_1$和$a_2$，获得的值是$3$+（$-2$）=$1$,$ans$=1

- 第二步，数组已经变成$1$,$-2$,$9$,$-1$ 目的是之取一个负数，那么应该取$1$,$-2$,$9$ 获得的值为$1$+（$-2$）+$9$=$8$，$8$+$1$等于$9$，$ans$=$9$

- 接着数组为$8$,$-1$,只能取，获得的值为$8$+($-1$)=$7$,$9$+$7$=$16$,$ans$=16，输出即可

顺便说一句，不开longlong只有65分

```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n;
LL a[100005];
LL dp[100005];
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	LL len=0,flag=0,i=2;
        //一开始最少取两个,那么从2开始
	dp[1]=a[1];
	while(i<=n){
		len++;
     		//长度加一
		if(len==1&&a[i]<0) flag=1;
        	//如果第一个去的就是负数,那就要标记，不然长度就立刻为0
		dp[i]=a[i]+dp[i-1];
		if(a[i]<0&&flag==0){
			len=0;
		}
		flag=0;
      		//清零
		i++;
	}
	LL ans=0;
	for(int i=2;i<=n;i++){
		if(dp[i]>0) ans+=dp[i];
	}
	printf("%lld",ans);
	
	return 0;
}
```


---

## 作者：PersistentLife (赞：2)

我们设 $S_i=S_{i-1}+a_i$，其实就是前缀和。

题目要我们求：

$\sum\limits_{i=2}^{n} \max(S_i,0)$。

为什么呢？

假设我们要选取 $x$ 张牌。

如果 $S_x$ 是负数，那么我们就不选取，因为选取了是扣分，加入的新卡牌也是负分。

如果 $S_x$ 是正数，那么就把它们取了，因为这些分“不要白不要”，而且取了也会产生一个正分值的卡牌，对后面的有利。

那么我们取了 $x$ 张牌，对答案的贡献是多少呢？答案是 $S_x$，因为取了不会影响后面的答案，所以我们不要更新前缀和，所以求出 $\sum\limits_{i=2}^{n} \max(S_i,0)$ 就行了，因为至少取 $2$ 张，所以 $i$ 从 $2$ 开始。

记得开 `long long` ！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans,s[123456],a[123456];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	for(int i=2;i<=n;i++) if(s[i]>0) ans+=s[i];
	cout<<ans;
	return 0;
}
```


---

## 作者：pengyule (赞：1)

~~没参加省选，做一道最简单的题吧~~

我们先考虑，如果整个序列全是正数，策略是什么。答案是：从左到右（题目这么要求）两两合并，而不是一股脑全部加起来。为啥？你看，我们如果每次只取两个数，那么第一个数被加了 $n$ 次，第二个数被加了 $n-1$ 次，…，第 $n$ 个数被加了 $n-(n-1)=1$ 次，又因为这个加的次数是随每次取的数的个数的递增而递增的，所以相比之一股脑全取（每个数被加了一次），显然是更优的，且是最优的策略。

对于这道题而言，我们沿用这种“单次少取”的策略，然而我们又不想让我们本次得到的这个加和成为负数从而使结果变小，所以我们的策略就是，每次从当前的数列中从左到右取尽量少（但是要大于等于 2）的数，使得加和为正。

代码实现如下（含注释）。
```
#include <iostream>
using namespace std;
typedef long long ll;
ll a[100010];  //须用长整型
int main()
{
    int n;
    //读入
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    //ans为答案，sum为这一次的加和
    ll ans=0,sum=a[1];
    for(int i=1,j=1;i<n;i=j-1){
        sum+=a[i+1];  //我们只需要在上一次的结果上操作即可
        //你可能会问，为什么上面的sum+=a[i+1]不直接放到循环里面呢
        //其实，我们的循环不一定会执行，而上面这个必须要执行（因为至少要取两个数）
        for(j=i+2;j<=n && sum<=0;j++) sum+=a[j]; //一旦sum>0就跳出
        if(sum<=0) break; //后面怎么加也不能为正了，断定他没救了
        ans+=sum;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：zmxqs (赞：1)

> 前言：看了今年省选 B 卷，我似乎找到了信心

~~€	€￡ 出题组确定没吃错药？这题是不是走错了？~~

设$f_{i}$为区间$1,i$的结果

$f_{1,i}=\max(f_{1,i-1} \times 2 + a_i,f_{1,i})$

然后可以得到$f_{1,i-1}$要尽可能的大，所以$f_{1,i-1}\ge0$

然后用前缀和优化，如果区间$[1,i)\geq0$则$ans+=\sum_{k=1}^ik$

Updated 2020.6.24

Code:
```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize("O1,O2,O3,Ofast,no-stack-protector,unroll-loops,fast-math")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
using namespace std;

template<typename T> inline T read() {
	T s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
	return s*w;
}

const int MAXN = 1e5 + 10 ;
int n , a[MAXN] , sum[MAXN] ;
int ans = 0 ;
int main(){
	scanf("%d",&n) ;
	for(int i=1;i<=n;i++) {
		scanf("%d",a + i);
		sum[i] = sum[i-1] + a[i];
	}
	for(int i=2;i<=n;++i) {
		ans += sum[i] > 0 ? sum[i] : 0 ;
	}
	printf("%d\n",ans) ;
	return 0 ;
} 


```

---

## 作者：爱晚亭哦 (赞：0)

~~没想到省选题这么EZ？？？~~

~~好像也就这题比较EZ/kk~~

**题目反复强调最左端，所以很好想到前缀和**

**对于前缀和正的数计入答案，否则不计直到结束**

因为答案只和前缀和有关，所以前缀和正的肯定要计入答案

此外注意开$long long$

```
#include<cstdio>
int n,x;
long long ans;
int a[100001];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		a[i]=a[i-1]+x;
	}	
	for(int i=2;i<=n;i++)
		if(a[i]>0)
			ans+=a[i];
	printf("%lld",ans);
} 
```


---

## 作者：bovine__kebi (赞：0)

代码跟大家的都差不多，但思路不同，我来讲一下这个贪心的证明：  

首先，我们看到每次都会取一个前缀，就很自然的会想到用前缀和，然后我们再来看如何贪心。  

其实这个取前缀然后更新数组循环的过程，可以看做是每次都去一段前缀和，有的取，有的不取,当前缀和为正数的时候取。

比如样例：

$2\; -1\; 2$  

如果按照题意的过程就是：  

$1\quad2\quad$   贡献为 $1$

$3\quad$ 贡献为 $3$

所以答案就是 $1+3=4$

----
按我所说的过程就是  
取出所有的前缀和(从第二个开始)

$1\quad 3$  

都为正数，所以都可以取。

再比如样例2：  
所有前缀就是：  

$-1\quad -1\quad 6\quad 3\quad -2\quad -5$

取 $6$ 和 $3$ ，刚好也满足条件。

于是我们就可以开始code了，代码如下(不开longlong见祖宗)：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
typedef long long ll;
int a[maxn];//原数组
ll ans=0,S[maxn];//答案与前缀和
int main()
{
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),S[i]=S[i-1]+a[i];//读入+前缀和
    for(int i=2;i<=n;i++)ans+=max(S[i],0ll);//贪心的过程，取或者不取
    printf("%lld\n",ans);//输出
}
```



---


# [常州市赛 2020] 重点单词

## 题目背景

搬运自 <http://czoj.com.cn/p/448>。数据为民间数据。

## 题目描述

回家后，小 $\text{X}$ 望着自己打瞌睡时写的英语笔记陷入了迷茫。由于太困了，他会时不时地把一个字母多写几次：比如可能把 $\texttt{she}$ 写成 $\texttt{shhe}$，也可能写成 $\texttt{ssshee}$。  
但他依稀记得这堂课只讲了一个重点单词。为了找到这个单词，他想先把每个单词中连续重复的字母压缩起来：把 $\texttt{coool}$ 压缩为 $\texttt{col}$，把 $\texttt{aabbaa}$ 压缩为 $\texttt{aba}$。接下来找到压缩后出现次数最多的单词，这样就能找到重点单词了。  
由于工作量太大，小 $\text{X}$ 希望你帮助他找到重点单词。他向你保证压缩后的单词出现次数最多的一定唯一。

## 说明/提示

### 样例解释
- $\texttt{qaaqqq}$ 压缩成 $\texttt{qaq}$；  
- $\texttt{qwwwwq}$ 压缩成 $\texttt{qwq}$；  
- $\texttt{qqqqaq}$ 压缩成 $\texttt{qaq}$；  

$\texttt{qaq}$ 出现了两次，$\texttt{qwq}$ 出现了一次，所以 $\texttt{qaq}$ 出现次数最多。  
### 数据范围
本题共有 $10$ 个测试点。  
对于全部数据：$1\le n\le 10^4$，$1\le $ 单词长度 $\le50$。 
|测试点编号|$n$|单词长度|
|:-:|:-:|:-:|
|$1$|$=1$|$=1$|
|$2\sim3$|$\le 10^4$|$=1$|
|$4\sim6$|$=1$|$\le 50$|
|$7\sim8$|$\le 10$|$\le 50$|
|$9\sim10$|$\le 10^4$|$\le 50$|  


## 样例 #1

### 输入

```
3
qaaqqq
qwwwwq
qqqqaq```

### 输出

```
qaq```

# 题解

## 作者：sfb1363II (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B4200)

## Solution

这题我的思路是，首先我们先对每个单词做如下操作：如果 $s_i=s_{i-1}$，那么就删除 $s_i$。然后用 map 存储操作完后的单词，然后输出次数最多的单词。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+10;
int n,maxn;
string res,s[N];
map<string,int> mp;
string get(string s){
    string res="";
    for(int i=0;i<s.size();i++)
        if(!i||s[i]!=s[i-1]) res+=s[i];
    return res;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        s[i]=get(s[i]);
        mp[s[i]]++;
    }
    maxn=-1e9;
    for(auto i:mp)
        if(i.second>maxn){
            res=i.first;
            maxn=i.second;
        }
    cout<<res<<"\n";
    return 0;
}
```

---

## 作者：Temp113 (赞：3)

## Solution

若 $s_{i-1} = s_i$（存在 $s_{i-1}$），计入压缩单词中，一开始压缩单词只有第一个字母。

再用 map 对所有压缩单词统计次数，并求出答案。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
int n, l;
string s, ss[N], ans = "                ";
map<string, int> mp;
int main(){
	ios::sync_with_stdio(false);
	cin.tie();
	cin >> n;
	for(int i = 1; i <= n; i++){
		ss[i] = "";
		cin >> s;
		l = s.length();
		ss[i] += s[0];
		for(int j = 1; j < l; j++) if(s[j - 1] != s[j]) ss[i] += s[j];
		mp[ss[i]]++;
	}
	for(int i = 1; i <= n; i++) if(mp[ss[i]] > mp[ans]) ans = ss[i];
	cout << ans;
	return 0;
}
```

---

## 作者：Sliarae (赞：1)

我们将这道题的解题过程分为两部分：第一部分是如何压缩一个单词，第二部分是找到压缩后出现次数最多的单词。

首先考虑压缩单词。假设原来的字符串是 $s$，压缩后是 $t$，我们执行以下流程：

- 从前往后考虑 $s$ 的每个字母，如果它和 $t$ 的结尾不同（或者 $t$ 为空），就将其加入到 $t$ 的末尾。

发现此时 $s$ 中每段相同的字符到 $t$ 中都变成了一个。比如 $s = \texttt{qaaqqq}$，在将 $s$ 的第三个字母 $\texttt{a}$ 放入 $t$ 时，$t = \texttt{qa}$，此时这个 $\texttt{a}$ 和 $t$ 的结尾相同，不会被加入到 $t$ 的末尾。后面的三个 $q$ 同理。于是最后可以得到 $t = \texttt{qaq}$。

再考虑找出现次数最多的单词。它类似于找众数的过程，并且保证众数唯一。

我们用 `map<string, int>` 维护一个单词的出现次数。最后遍历整个 `map`，将出现次数最多的那个输出。

```cpp
#include <iostream>
#include <map>

using namespace std;

int n;
map<string, int> mp;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		string s, t;
		cin >> s;
		for (auto c : s) 
			if (t.empty() || c != t.back()) t.push_back(c);
		++mp[t];
	}
	int mx = 0; 
	string ans;
	for (auto i : mp) {
		if (i.second > mx)
			mx = i.second, ans = i.first;
	}
	cout << ans << '\n';
	return 0; 
}
```

---

## 作者：sea_bird (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4200)。

复习字符串哈希做到这题，那就用字符串哈希来解吧。

## 前置知识

> 我们定义一个把字符串映射到整数的函数 $f$，这个 $f$ 称为是 Hash 函数。这个函数 $f$ 可以方便地帮我们判断两个字符串是否相等。

# 题目分析

根据题意，大概能将做法分成两步：

1. 压缩字符串。
2. 查重。

## 压缩字符串

并不难，枚举字符串的每一位，遇到相同的只留下一位，没有重复的字符也留下，重新存入到数组中，第 $i$ 个记为 $str_i$。

## 查重

先用字符串哈希将字符串映射到整数的数组中，第 $i$ 个记为 $a_i$，排序后相同的字符串一定相邻（因为其哈希值一样），那么比对相邻字符串，一样的话计数器加一，不一样的话更新计数器，注意过程中别忘了存下出现最多次数的字符串，及其出现次数，最后输出即可。

## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4+5;
string str[N];
ll b=1e9+7;
ll mod=1e9+9;
struct wor{//结构体
	int ad;//下标
	ll z;//哈希值
}a[N];
ll maxn=-1;
bool cmp(wor x,wor y){
	return x.z<y.z;
}
string check(string str){//压缩
	string a="";
	for(int i=1;i<=str.size();i++){
		if(str[i-1]!=str[i-2]){//遇到相同的字符
			a+=str[i-1];//留下一个
		}
	}
	return a;
}
ll hashh(string str){//哈希
	ll a;
	for(int i=1;i<=str.size();i++){
		a=(a*b+(ll)str[i-1])%mod;
	}
	return a;
}
int main(){
	ll n;ll cnt=1;
	string ans;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>str[i];
		str[i]=check(str[i]);//压缩
		a[i].z=hashh(str[i]);//字符串哈希
		a[i].ad=i;//存下标 
	}
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++){//循环查重
		if(a[i].z!=a[i-1].z){//当前位的与上一位不相同
			cnt=1;//更新计数器
		}
		if(a[i].z==a[i-1].z){//相同的话
			cnt++;
		}
		if(cnt>maxn){//更新最大值
			maxn=cnt;
			ans=str[a[i].ad];//更新出现次数最多的字符串
		}
	}
	cout<<ans<<'\n';//输出
	return 0;
}
```

我写的第一篇 B 开头的题目题解，如有问题欢迎指出。

---

## 作者：TheTrash (赞：1)

### 思路

输入 $n$ 个字符串，对字符串进行压缩。用 ```map``` 存储压缩后的字符串的出现次数，压缩完一次就把压缩完的字符串的出现次数与当前出现次数的最大值进行比较，如果比当前最大值大就更新最大值并保存压缩后的字符串。

### 代码

```cpp
#include<iostream>
#include<map>
using namespace std;
int n,maxn;
string s,t,r;
map<string,int>mp;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		t="";
		for(int j=0;j<s.size();j++) if(s[j]!=s[j+1]) t+=s[j];
		mp[t]++;
		if(mp[t]>maxn) maxn=mp[t],r=t;
	}
	cout<<r;
}
```

---

## 作者：2789617221guo (赞：0)

## 做法
- 字符串+映射。
## 思路
我们每次读入一个字符串 $str$，然后根据题目对 $str$ 进行去重（我这里对函数名定义为 `string qc(string s)`）。

在 `qc` 中，我们可以对于每一段相同的字符，记录它的区间开头。循环字符串 $s$ 的每一个字符，若这个字符与开头的字符不同，则在新字符串 $ns$ 的末尾 `push_back` 开头的字符，然后再将开头设置为当前位置 $i$。最后返回 $ns$ 即可。

在 `main` 函数中的循环中，每次去重完毕后，在记录的映射 $mp$（`map<string,int> mp`） 中 `mp[str]` 加一。

最后使用 `map` 的内置迭代器 `map<string,int>::iterator` 进行对每一个存储结果进行遍历，通过“打擂台法”记录出现次数最多的字符串，最后输出即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define ll   long long

using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;

int n;
string str;
map<string, int> mp;

string qc(string s) {
    int st = 0;
    string ns;
    for (int i = 0, sz = s.size(); i < sz; i++) {
        if (!(i == 0 || s[i] == s[st])) {
            ns.push_back(s[st]);
            st = i;
        }
    }
    ns.push_back(s[st]);
    return ns;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> str;
        str = qc(str);
        mp[str]++;
    }
    int mxn = -1;
    string mxs;
    for (map<string, int>::iterator it = mp.begin(); it != mp.end(); it++) {
        if (it->second > mxn) {
            mxn = it->second;
            mxs = it->first;
        }
    }
    cout << mxs << endl;
    return 0;
}
```
## AC 记录
[AC，用时 34ms，内存 680.00KB。](https://www.luogu.com.cn/record/207884776)

---

## 作者：jiangchengzhe (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4224)。

### Part 1 理清题意
* * *
把每个单词中连续重复的字母压缩起来，再找到压缩后出现次数最多的单词并输出。

### Part 2 思考题目做法
* * * 
由于本蒟蒻不会字符串哈希，所以我只能使用 map 来写这道题。  
将字符串压缩后存进 map 里面，然后使用迭代器遍历 map 找出出现次数最多的单词即可。

### Part 3 完整代码
* * *

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    string s,sum="";
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s;
        sum="";
        for(int j=0;j<s.size()-1;j++){
            if(s[j]!=s[j+1]) sum+=s[j];
        }
        sum+=s[s.size()-1];//记得加上最后一个字符
        mp[sum]++;
    }
    map<string,int>::iterator it;//迭代器不要打错
    int zd=INT_MIN;
    string ans;
    for(it=mp.begin();it!=mp.end();it++){
        if((it->second)>zd){
            zd=(it->second);
            ans=(it->first);
        }
    }
    cout<<ans;
    return 0;
}
```

### Part 4 完结撒花
[AC记录](https://www.luogu.com.cn/record/206578850)。

---

## 作者：Dollartree (赞：0)

### 解题思路

1. 首先我们要知道如何按照题意压缩字符串，可以设一个 $i$，单词为字符串 $s$，在满足 $s_{i} = s_{i+1}$ 的情况下，使 $i \gets i+1$，直到 $s_{i} \ne s_{i+1}$，并将 $s_{i}$ 加入新的压缩后的字符串，同时使 $i \gets i+1$，再从在满足 $s_{i} = s_{i+1}$ 的情况下开始，直到 $i$ 到达了 $s$ 的结尾。

2. 接着将压缩后的字符串计数，并用打擂台的方式计算出压缩后出现次数最多的单词。

### 注意事项

1. 可以用 map 来存储压缩后单词的出现次数。

2. 输出的是压缩后出现次数最多的单词，不是最多的出现次数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>mmap;//存储出现次数 
int main()
{
	int n,mmax=0;
	string s,news,ans;
	cin>>n;
	while(n--)
	{
		cin>>s;
		news="";//多次用要清空 
		for(int i=0;i<s.length();)
		{
			while(s[i]==s[i+1])
			{
				++i;
			}
			news=news+s[i];
			++i;//要再让i<-i+1是因为要到下一个不同的字符 
		}
		mmap[news]++;
		if(mmap[news]>mmax)//打擂台 
		{
			mmax=mmap[news];
			ans=news;
		}
	}
	cout<<ans;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4200 [常州市程序设计小能手 2020] 重点单词](https://www.luogu.com.cn/problem/B4200)
## 思路：
本题需输入 $n$ 个字符串，把字符串压缩，即把重复的~~扔掉~~删除。用 `map` 容器存储压缩后每种字符串的出现次数，每压缩好一次就把目前压缩完的字符串的出现次数与当前出现次数的最大值进行比较，求最大值，记录目前压缩完的字符串，最后输出即可。
## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Max;string s,ans;
map<string,int>m;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		string ss="";
		for(int j=0;j<s.size();j++)
            if(s[j]!=s[j+1])ss+=s[j];
		m[ss]++;
		if(m[ss]>Max)Max=m[ss],ans=ss;
	}
	cout<<ans;
}
``````

---

## 作者：AnOIer (赞：0)

### Solution

考虑压缩单词的解法，设 $last$ 为单词的首个字母，将这个字母加入压缩后的单词中，如果后面的字母等于 $last$ 就跳过，否则将这个字母加入压缩后的单词中，更新 $last$ 为这个字母，如此循环最后得到的字符串即为压缩后的单词。

然后将压缩后的字符串存到桶里，更新 $maxn$ 为字符串出现的次数，最后枚举一遍输入的单词，如果它压缩后的单词出现的次数等于 $maxn$ 就输出。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string solve(string word) {
	string res="";
	char last=word[0];
	res+=last;
	for(int i=1;i<word.size();i++) {
		if(last==word[i]) {
			continue;
		}else {
			last=word[i];
			res+=last;
		}
	}
	return res;
}
map<string,int> w;
string word[10010];
int maxn=0;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>word[i];
		w[solve(word[i])]++;
		maxn=max(maxn,w[solve(word[i])]); 
	}
	for(int i=1;i<=n;i++) {
		if(w[solve(word[i])]==maxn) {
			cout<<solve(word[i]);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：LG086 (赞：0)

给出 $n$ 个字符串，需要用某种方式压缩字符串，并求出压缩完成之后出现次数最多的字符串。

我们需要一个 `map<string,int>mp` 来记录压缩后的字符串。每次对输入的字符串 ${s_1}_i$ 进行压缩操作，变为 ${s_2}_i$，同时加入 $mp$ 中。操作完毕后，遍历 $mp$ 求出现次数最多的字符串，输出即可。

代码略。

---

## 作者：Jasoncwx (赞：0)

[题目传送门](/problem/B4200)
## 题目思路
一道基础字符串题。

先把每个单词进行压缩，再看看压缩之后哪个单词数量最多即可。

在压缩字符串时，我们只需要判断若本位与前一位相同，说明无法压缩，所以保留。否则不保留。
## 代码
```cpp
//By Jasoncwx
#include<bits/stdc++.h>
#define R register
#define us unsigned
#define ll long long
inline ll read(){R ll s=0,w=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}return s*w;}
using namespace std;
const int N=1e6+5;
map<string,int>mp;
string f(string s){//压缩
	string ans="";
	for(int i=0;i<s.size();i++){
		if(s[i]!=s[i-1])ans+=s[i];
	}
	return ans;
}
int main(){
	int n=read(),mx=0;
	string s[10005];
	for(int i=1;i<=n;i++){
		cin>>s[i];
		mp[f(s[i])]++;//计算字符串出现次数
		mx=max(mx,mp[f(s[i])]);//记录出现次数最大值
	}
	for(int i=1;i<=n;i++){
		if(mp[f(s[i])]==mx)return cout<<f(s[i]),0;
	}
	return 0;
}
```

---


# 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。


**友情提醒：如果真的想好好练习哈希的话，请自觉。**


## 说明/提示

### 数据范围

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$M_{\max}\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$M_{\max}\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$M_{\max}\leq 1500$。

### 样例说明

样例中第一个字符串 $\tt{abc}$ 和第三个字符串 $\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\{\tt{aaaa},\tt{abc},\tt{abcc},\tt{12345}\}$，故共计 $4$ 个不同的字符串。

### 拓展阅读

以下的一些试题从不同层面体现出了字符串哈希算法的正确性分析。

- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)
- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)
- [P12199 （目前无解）Hash Killer III](https://www.luogu.com.cn/problem/P12199)
- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)
- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)
- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)

## 样例 #1

### 输入

```
5
abc
aaaa
abc
abcc
12345```

### 输出

```
4```

# 题解

## 作者：皎月半洒花 (赞：1782)

** _这篇博客我打算皮一下qwq，适合初学者阅读（因为讲的是在太细了）_ **
# 一、首先理解字符串操作的意义：
  ## ~~没意义~~

$emmmmmm$其实字符串操作的意义是很浅显的，比如百度的推荐搜索啊，比如查找比对一篇题解里有多少个相同或者不同的脏字然后$kkksc03$再根据其数量、恶劣程度决定用多大的刀将博主$kill$掉。。。所以字符串操作很重要啊喂$qwq$。
   
  再来考虑时间：如果百度对于一个人的一次“常搜”推荐需要$10s$，那么对于全国网友来说，同时上网的人群基数很高，那么如果服务器性能不好的话，怕不是要三星$note7$ $qwq$？？？
  
  所以啊，打造高效的字符串算法是很有必要滴！
  
# 二、言归正传，浅析字符串哈希
   哈希其实是所有字符串操作中，笔者认为最简单的操作了（except输入输出qwq）。哈希的过程，其实可以看作**对一个串的单向加密过程**，并且需要保证所加的密**不能高概率重复**（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样qwq），通过这种方式来替代一些很费时间的操作。
   
   比如，最常见的，当然就是通过哈希数组来判断几个串是否相同（洛谷P3370）。此处的操作呢，很简单，就是对于每个串，**我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串   _尽量_  不同。**
   
   此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如ab和ba，并不是同一个串，但是如是做却会让其认为是qwq）。这种情况就叫做**$hash$冲突**，并且在如此的单向加密哈希中，$hash$冲突的情况在所难免（bzoj就有这种让你给出一组样例，使得一段哈希代码冲突的题，读者可以尝试尝试）。
   
   而我们此处介绍的，即是最常见的一种哈希：**进制哈希**。进制哈希的核心便是**给出一个固定进制$base$，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个$base$进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同**
   
   奉上$P3370ac$代码（单哈希）：
   
   ```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
typedef unsigned long long ull;
ull base=131;
ull a[10010];
char s[10010];
int n,ans=1;
int prime=233317; 
ull mod=212370440130137957ll;
ull hashe(char s[])
{
	int len=strlen(s);
	ull ans=0;
	for (int i=0;i<len;i++)
    ans=(ans*base+(ull)s[i])%mod+prime;
    return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		a[i]=hashe(s);
	}
	sort(a+1,a+n+1);
	for(int i=1;i<n;i++)
	{
		if(a[i]!=a[i+1])
		ans++;
	}
	printf("%d",ans);
} 
   
```
   
   当然，再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性
   
  ## 1、无错哈希
   
   其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突（比如somebody’s birthday qwq）。
   
   先贴代码：
```cpp
for(int i=1;i<=m;i++)//m个串
{
cin>>str;//下一行的check为bool型 
while(check[hash(str)])hash[i]+=19260817;
hash[i]+= hash(str) ;
}
```
正如下图（亲手做的~~英文高逼格~~）：

![](http://images.cnblogs.com/cnblogs_com/pks-t/1233651/o_bwb.png)

但是，这种方法类似桶查找，但是桶查找的弊端2就会很恶心——数据过大，$check$数组无能为力来支持上亿个空间（弊端1是由于数据具有跳跃性，浪费最后的统计次数，但在此不是特别明显，就当我皮了一下qwq）

## 2、多重哈希

这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。

![](http://images.cnblogs.com/cnblogs_com/pks-t/1233651/o_owo.png)

下面皮一个哈希自动机qwq（不用百度了，名字自己起的）

```cpp
//哈希自动机,需要二维hash数组 
for伪代码排序，用来使哈希值单调（更好判断相/不同的数量） 
for(int i=1;i<=m;i++){
	check=1； 
	for(int j=1;j<=qwq;j++)//皮一下
		if(hash[j][i]==hash[j][i+1]){check=0;break;} 
	if(check)ans++;//此为判断相同个数 
} 

```

# 三、字典树浅析

##   1、简要介绍

首先要知道，字典树是一种假想数据结构（数据结构不都是
假想的吗qwq），那么问题来了——为什么是要用字典树呢？为什么不用类似字典链表之类的东西呢？很简单，所有树形结构
都有一个基本特点，就是

**元素与元素间的关系为继承的一对多关系**。

拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；**而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行**

比如下图就是一棵$Trie$，这里用颜色区分单词路径上的点
![](http://images.cnblogs.com/cnblogs_com/pks-t/1233651/o_qwq.png)

 ## 2、字典树基础与如何建树（插入操作）
 
首先，关于字典树，我们一般不是用点来存储字符的，而是用边——为什么呢？之后再说（十分皮地卖个关子qwq）。
 
重新首先，一般来说，字典树是不会使用根节点的，原因很浅显，**因为根节点的个数决定究竟有几棵字典树**，而通常字典树是只有一棵的，否则产生森林会很麻烦（qwq你皮你就splay，并且如果有森林的话应该叫做“字典森林”啊喂）。

但是我们要知道，并不是一个题中所有的串都有公共前缀（肯定不会的吧qwq），**可如果根节点唯一，就代表他们一定有公共前缀，并且公共前缀的长度必定大于等于1**。

其次，**字典树中每个节点的子节点数量都肯定会小于某个数。**

如果字典树里都是小写字母，那么“某个数”就是26；如果大小写都有，“某个数”就应该是52（证明过程：显然）；

并且**每个节点的所有的边都不同**，这条性质可以便于我们判断在某一棵字典树到底有没有某条链：**只要前缀不符合，就不需要再判断，因为必然没有（同一深度、同一父亲，边与边必定互异）**

在这里，我选择用结构体来存树，具体解释见注释：
 
```cpp
//建树（其实就是存点啦）
struct nodes{
	int son[26];
//此处只考虑小写字母字典树
    bool mark;
// 此为标记，作用下面说 
}trie[10001]; 
int root=0,num=0;
//根节点永久为0 qwq 
bool insert_check(char *str)
{
	int position=root;//初始化位置,跟深度没有直接关系 
	for(int i=0;str[i];i++)
	{
		int symbol=(int)str[i]-'a';
/*此处实际是因为我们的trie都是存int的,如果贸然存char会
很别扭qwq，并且此处由于都是小写字母，所以 -‘a’ ,如果
存了别的类型的字符，需要特判，保证字符容易确定 */	
	    if(!trie[position].son[symbol]) //还没有被编号
	    trie[position].son[symbol]=++num;//编一个号
		
		position=trie[position].son[symbol] ;
		//更新迭代位置，直到字符链的最末端 
	} 
	int temp=trie[position].mark;
	trie[position].mark =1;
//将这条链的最末端置为1，如果还有重复的串，那么一定会出现
//最末端相同 ;反之，最末端节点的mark相同也可以推出链相同，
//借此来判断串是否相同 
	return temp!=0;
/*最后说一下为什么要编号：我们根据程序可以看出，字符串是
按秩插入树，所以一条链上的编号肯定满足单调，便于我们查找
和比对*/ 
} 
```

于是便可以通过这种方式比对字符串，期望时间复杂度O（n）大多用于比对。

  ##  3、关于字典树的查找
   
   查找前缀比较好写，只需要一边判断是否符合要求，一边判断是否继续迭代即可。
   
   ```cpp
int root=0;
bool find(char* str)
{
	int pos=root;
	for(int i=0;str[i];i++)
	{
		int x=str[i]-'a';
		if(trie[pos].son[x]==0)return false;
		//如果在建完树之后这个点还没有被编号，
		//那么就肯定不存在这条链。（互异性） 
		pos=trie[pos].son[x] ;//继续迭代 
	}
	return true; 
}

```
其实查询单词和查询前缀差别不大，只是我们**每次都需要维护一个$check[i]$（$bool$）**，存在单词链的**末尾**。

每当一个新字符已经被标记时（即所**查询单词的这个字母及其前缀都在树的某条链上**），我们**使这个字符$check$异于它祖先们的$check$**，最后判断**该条匹配链结尾字符的$check$是否异于链上其他字符的$check$**即可判断是否有这个单词（如果没有的话，末尾的$check$肯定与链上其他的相同啊qwq）

至于前缀出现次数，很简单，只要将每一个前缀的出现次数存到它相连的子节点，最后输出前缀最后一个字符所带的次数即可（可以用数组维护，也可以直接写在结构体里）
   
 好啦，就是这样，希望对大家有所帮助
##  日拱一卒，功不唐捐！

---

## 作者：Starlight237 (赞：7)

## $ELF\ Hash$
我们先看一个最简单的错位叠加哈希：
```cpp
inline uint hs(char *s){
	reg uint sm=0;
	reg char *p=s;
	while(*p)sm=(sm<<4)+*p++;
	return (sm&0x7fffffff);
}
```
但是这个哈希函数显然可能会溢出，从而增加冲突的可能性。

为了防止溢出，可以利用一个辅助变量x，每次更新哈希值的时候执行以下操作：
```cpp
(x=sm&0xf0000000)&&(sm^=(x>>24),sm&=~x);
//为了压行+卡常数进行了改写，实际上等同如下代码：
x=sm;
if(x&0xf0000000)sm^=(x>>24),sm&=~x;
```
它的意义是：取x的可能溢出的最高一位，若不为零则有溢出风险，这时最简单的方式就是直接暴力地把溢出的内容转移到低位，这样既可保证每一位都对hash值有影响。

可以证明，这样的哈希方式正确率是极高的。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
typedef unsigned int uint;
uint hsh[10001],ans=1,n;
static char str[10001];
inline uint hs(char *s){
	reg uint sm=0,x=0;
	reg char *p=s;
	while(*p)
		sm=(sm<<4)+*p,
		(x=sm&0xf0000000)&&(sm^=(x>>24),sm&=~x),
		++p;
	return (sm&0x7fffffff);
}
int main(){
	freopen("1.in","r",stdin);
	scanf("%d",&n);
	for(reg int i=1;i<=n;++i)
		scanf("%s",str),hsh[i]=hs(str);
	sort(hsh+1,hsh+n+1);
	for(reg int i=1;i<n;++i)
		ans+=hsh[i]!=hsh[i+1];
	printf("%d",ans);
	return 0;
}

```

---

## 作者：warzone (赞：5)

这道题是希望我们把字符串存入HASH表中,相互冲突的再排序去重

然而,~~哈希是不可能的这辈子都不可能的~~

那么这道题怎么AC呢?字典树吗?巨大的空间开销必定时空两爆炸

于是介绍此题对于二者的替代算法——基数排序

-----------------------

什么是基数排序
------------

首先,我们这里有一串数列

![](https://cdn.luogu.com.cn/upload/image_hosting/i4aj7ic6.png)

我们按从左往右的顺序遍历串,

按第一位依次放入相应的桶(实现为队列)中

![](https://cdn.luogu.com.cn/upload/image_hosting/sio7ir2u.png)

然后依序遍历桶,将桶中的数据按插入的顺序取出来恢复到表中

(其实就是从队列中弹出)

(循环队列可用内存拷贝函数memcpy实现整体恢复)

![](https://cdn.luogu.com.cn/upload/image_hosting/1oyjlhuf.png)

这时,所有的数都按第一位排序了

再把第二位按相同的方式处理

![](https://cdn.luogu.com.cn/upload/image_hosting/4sazqs1s.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0s1qt7jx.png)

这时,我们发现数列**在满足第二位从小到大的前提下,也满足前面的顺序**

**(包括按第一位从小到大和初始顺序)**

这便是基数排序的思想:按关键字多次放桶。它是桶排序的改进

如此反复进行,直到遍历到最高数的最后一位,排序就完成了

![](https://cdn.luogu.com.cn/upload/image_hosting/tshxxdhf.png)

----------------------


基数排序的时空复杂度
------------

我们设待比对的共有n个值,每个值有q个关键字,范围为1~m

1. **时间复杂度**

   每个值入桶q次,出桶q次,共入桶n * q次,出桶n * q次

   且每次出桶都要遍历每个桶,每个桶遍历了q次

   因此时间复杂度为O((n+m)q)
   
   m较小时(100以内),是可以忽略不计的,时间复杂度也就近似于O(nq)
   
   ㅤㅤㅤㅤ
   
2. **空间复杂度**

   对于每个桶,要用一个队列来存储
    
   如果使用STL的队列的话,需要O(n)的辅助空间(不算空队列的指针)
   
   但STL效率较低,如果使用循环队列,需要O(n * m)的辅助空间

	ㅤㅤㅤㅤ

3. **对于整型和字符串的时空复杂度**

   对于整型,若最大值为max
  
   - 如果按十进制入桶,q=log10(max),m=10,
   
     开循环队列共需要十倍的空间存储
     
     时间复杂度近似于O(log10(n))
     
     ㅤㅤㅤㅤ
     
   - 如果按二进制入桶,q=log2(max),m=2
   
     开循环队列只需要两倍空间存储,
     
     时间复杂度近似于O(log2(n)),可与快速排序,归并排序和堆排序媲美
   
   ㅤㅤㅤㅤ
   
   对于字符串,关键字即字符,是从后往前扫的
   
   入桶和出桶的是它们的下标(或头指针),与长度无关,因此用循环队列仍只需O(n * m)的辅助空间
   
   字符串长度约为n * q,于是时间复杂度为O(字符串总长),与字典树和哈希相同

------------------------

基数排序的优势
------------

- 相对于桶排,因数据范围导致的额外空间和时间大幅减少
  (尤其是空间)
  
ㅤㅤㅤㅤ 
- 相对于其它排序算法,可达到O(log2(n))级别,且适用于字符串

ㅤㅤㅤㅤ
- 相对于字典树,基数排序的时间复杂度相同,空间上的常数更小  
  (这也是为什么基数排序可以AC这道题)
 
-------------

最后,让我们回到这道题

这道题如果不用哈希,就可以对所有字符串进行基数排序

这样筛选时只需要相邻的字符串两两比对,然后输出即可

基数排序时间复杂度O(字符串总长),两两比对的时间复杂度O(字符串总长),最后的时间复杂度仍为O(字符串总长)

常数一般是逊于哈希的,但很明显没有哈希冲突的担忧

AC代码(1.51s,15.81MB)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int size=10000;
struct queue{//循环队列 
	short list[10001];
	short head,tail; 
	void clear(){//队列清空 
		head=tail=0;
	}
	void push(short in){//队列插入 
		list[tail]=in;
		tail++;
		if(tail==size) tail=0;
	}
	int set(short *p){//用memcpy实现整体恢复 
		if(head==tail) return 0;
		if(head<tail){
			memcpy(p,list+head,sizeof(short)*(tail-head));
			return tail-head;
		}
		memcpy(p,list+head,sizeof(short)*(size-head));
		memcpy(p,list,sizeof(short)*tail);
		return size-head+tail;
	}
};
queue q[64];
int ans=1;
short n,id[10000];
char s[10000][1510];
bool compare(short id1,short id2){//单字符串比对 
	for(int i=0;i<1500;i++)
		if(s[id1][i]!=s[id2][i]) return 1;
	return 0;
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){//输入字符串,将下标放入表 
		scanf("%s",s[i]);
		id[i]=i;
	}
	for(int cmp=1500;cmp>=0;cmp--){//基数排序 
		for(int i=0;i<n;i++){//根据关键字放入相应队列 
			if('0'<=s[id[i]][cmp]&&s[id[i]][cmp]<='9') 
				q[s[id[i]][cmp]-'0'].push(id[i]);
			else if('a'<=s[id[i]][cmp]&&s[id[i]][cmp]<='z')
				q[s[id[i]][cmp]-'a'+10].push(id[i]);
			else if('A'<=s[id[i]][cmp]&&s[id[i]][cmp]<='Z')
				q[s[id[i]][cmp]-'a'+36].push(id[i]);
			else q[63].push(id[i]);
		}
		for(int i=0,copy=0;i<64;i++){//从队列中恢复 
			copy+=q[i].set(id+copy);
			q[i].clear();
		}
	}
	for(int i=1;i<n;i++)//两两比对 
		ans+=compare(id[i-1],id[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：hcx2012 (赞：4)

## 题意

~就是字面意思。~ 

给定 $N$ 个字符串，求不同字符串的个数。

## 哈希

哈希的本质上是把一个任意长度的序列通过哈希函数映射成尽可能不重复（又称冲突）的一个值。它也可以视为一种不可逆的压缩算法。

只要满足上述概念的算法都可叫做哈希，所以哈希有很多种，这里介绍的是**进制哈希**，也是相对来说较为简单的哈希：

通过选取一个 $base$ 进制的哈希值，使得字符串转换为哈希值。这里如果 $base$ 足够大，就不会引起冲突，所以这个哈希值是**唯一**的。于是我们可以通过 $O(1)$ 的比较操作确定它们是否相等。

但是这样做在字符串过大的情况下就很容易溢出，所以还要把哈希值对一个大模数 $mod$ 取模，即把哈希值映射到一个 $0\sim mod-1$ 的范围中。这能解决溢出的问题但有可能造成哈希冲突。（卡模数应运而生）

### 冲突概率估算

首先设 Hash 的取值空间（所有可能出现的字符串的数量）为 $d$，计算次数（要计算的字符串数量）为 $n$。则 Hash 冲突的概率为：（证明见[字符串哈希 - OI wiki](https://oi-wiki.org/string/hash/#hash-%E5%86%B2%E7%AA%81)）

$$
p(n,d) = \frac{d!}{d^n\left(d-n\right)!}  \approx 1 - \exp(-\frac{n(n-1)}{2d} )
$$

本题 $d=mod=10^{10}+1$，$n$ 取 $1500$，代入公式估算得

$$
p(n,d) \approx 1 -  \exp(-\frac{1500 \times 1499}{2 \times (10^{10}+1)}) \approx 0.000112425
$$

所以只要不是出题人有意卡模数，哈希的正确性也是可观的。当然如果担心出题人卡模数，也可以用两个模数来进行双值哈希，可以大大降低冲突概率。

## 细节

这里字符串内包含数字、大小写字母，不好处理。所以可以直接把字符串中的字符当做整数处理。

## 代码

```cpp
#include <bits/stdc++.h>
#define BASE 133
#define MOD 1000000001
using namespace std;
int a[11000];
int main(){
    int n;
    cin>>n;
    string s;
    for(int i=0;i<n;i++){
        cin>>s;
        int x=0;
        for(int j=0;j<s.size();j++){
            x=(x*BASE+s[j])%MOD;
        }
        a[i]=x;
    }
    sort(a,a+n);
    int ans=1; // 第0项
    for(int i=1;i<n;i++){
        if(a[i]!=a[i-1])ans++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：DX3906_ourstar (赞：4)

[同步发表于博客园。](https://www.cnblogs.com/D3906-ourstar/articles/18814480)

~~主播曾被这题卡了一下午，所以讲解一种最适合人类宝宝理解的哈希。~~

## 引入

考虑以下问题。

> DX 给了你一个字符串 `aadead`，请你用自己的方式，将其表示为十进制数。

聪明的你很快想到，将原串拆分成六个字母，得到`a`，`a`，`d`，`e`，`a`，`d`。

然后考虑将每个字母分别转成十进制数。你选择最直观的方式——采用字母表中每个字母的编号，于是你得到了 $1,1,4,5,1,4$ 这六个数字。

接下来，你把六个数字写到一起，得到了 $114514$，解决了问题。

从哈希的角度来看，你所做的操作，实际上就是求出了字符串 `aadead` 的 **哈希值**。

这中间有一些细节，我们接下来展开探讨。

## 基本概念

### 哈希值

通俗来讲，就是将一个字符串映射成整数后，得到的值。我们将其记为 $\text{hashh}$。

一般地，我们认为”两字符串相等”与“两字符串哈希值相等”互为充要条件。这就提供了一个机会，使得我们可以在预处理后以 $O(1)$ 的复杂度判断两串是否相等。

这一结论的主要应用在于代替传统的字符串比较方式，即一位一位地判断。容易发现，后者的复杂度是线性的。

### 基数

我们回到你得到的六个数字：$1,1,4,5,1,4$。

你是如何从它们得到 $114514$ 的呢？很简单，将已得到的值（初始为 $0$）乘以 $10$，再加上下一个数。

用文字可能不太直观，我们写成代码来看。

```
inline int calc(){
	int sum=0;
	int a[]={1,1,4,5,1,4};
	for(int i=0;i<6;++i)sum=sum*10+a[i];
	return sum;
}
```

相信你能够完全理解这一步骤了。但是，我们思考一个问题：为什么统计下一个数的贡献时，我们会将已有结果乘以 $10$，而不是别的数呢？

答案是显然的——我们要得到的是十进制数。

这就引出了哈希中的一个重要概念——**基数**。通俗来讲，它决定了你得到的哈希值的进制。我们记它为 $\text{base}$。

认识到这一点，我们就可以给 $\text{base}$ 随意取值，以计算任意进制下字符串的哈希值。

容易发现，我们已经有了一个通用的公式。具体地，我们记 $s$ 为任意字符串，$n$ 为 $s$ 的长度。于是有：

$$
\text{hashh}=\sum\limits^n_{i=1}s_i\cdot\text{base}^{n-i}
$$

其中 $\forall s_i$ 在转为整数后参与运算。有了上面的解释，这个式子很好理解了。把它写成代码，就类似于这样：

```
inline int get(string s,int base){//给定以 1 为起始位置的长度为 n 的字符串，返回它在 base 进制下的哈希值。 
	int hashh=0;
	for(int i=1;i<=n;++i)hashh=hashh*base+(int)s[i]; 
	return hashh;
}
```

### 模数

注意到上面的代码有一个缺陷：我们得到的哈希值可能很大，可能炸 `int`，甚至达到任何一种数据类型都无法存储的地步。因此，我们需要指定一个 **模数**，随时将得到的哈希值对它取模。我们记模数为 $\text{p}$，那么我们计算哈希值的公式就变成了：

$$
\text{hashh}=(\sum\limits^n_{i=1}s_i\cdot\text{base}^{n-i})\bmod \text{p}
$$

容易发现，必然有 $\text{hashh} \in[0,\text{p})$，也就是说，上面的式子只能生成 $\text{p}$ 种不同的哈希值。这时候，可能出现 **哈希冲突**，也就是两个不同字符串的哈希值相同。~~这就是哈希身上玄学色彩的来源。~~

举个例子，现在 $A$ 串的哈希值原本为 $201$，$B$ 串的哈希值原本为 $101$。对 $100$ 取模后，两串的哈希值都变成了 $1$，这就是哈希冲突。

为避免哈希冲突，我们显然希望 $\text{p}$ 有以下特征：

* **大**，这样区间更大，能生成的不同哈希值更多；

* **$\text{p} \in \mathbb{P}$**，这样 $\text{p}$ 的因子最少，取模后结果相等的可能性最小。

所以，我们一般选取 $998244353,19491001,1145141$ 这样的数作为模数。

但是，我们可以偷个懒——用 `ull` 存储哈希值，不进行取模。这种写法被称为 **自然溢出**。

一来，`ull` 的存储范围很大，一定程度上可以提高正确率；另一方面，它溢出后直接从 $0$ 重新开始，相当于我们将 $\text{p}$ 设成了 `ull` 的上界
。

~~题外话：敢在 CF 上写自然溢出的都是勇士。~~

容易发现，自然溢出的优点在于简单好写，但缺点在于容易被卡。~~其实不影响它能够通过此题。~~

另外，还有一种写法——**双模数**，可以看我的 [这篇题解](https://www.luogu.com.cn/article/sw3iybk7) 进行了解。它正与自然溢出相反——难写，但正确率高。

## 代码实现

现在你已经对字符串哈希有了基本的了解，于是我们回到本题。

思路是显然的——计算每个串的哈希值，最后观察不同的哈希值的个数。

我们把重点放在后半部分。容易发现，对于一个有序的数列，相等的数必然相邻。于是我们考虑将哈希值存在一个单调递增（减）的数组中，再从前往后扫一遍；若当前位与前一位不同，则计入答案；否则，直接忽略。

于是代码就显然了。

```
#include<iostream>
#include<string>
#include<algorithm>
#define ull unsigned long long
#define p 212370440130137957ll//模数
#define base 191//基数
using namespace std;

const int N=1e7+5;

int n,ans=1;
ull a[N];//存储哈希值

namespace OIfast{
	
	inline int read(){//快读快写
		int n=0,f=1;
		char c=getchar();
		while(c<'0'||c>'9'){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9')n=(n*10+c-'0')%p,c=getchar();
		return n*f;
	}
	
	inline void print(int n){
		if(n<0)putchar('-'),n=-n;
		if(n>=10)print(n/10);
		putchar(n%10+'0');
		return ;
	}
	
	inline void write(int n,char c){
		print(n),putchar(c);
		return ;
	}
	
}using namespace OIfast;

inline ull hashh(string s){//计算给定字符串的哈希值。
	int l=s.size();
	ull x=0;
	for(int i=0;i<l;++i){
		x=(x*base+(ull)s[i])%p;
	}
	return x;
}

signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		string s;
		cin>>s;
		a[i]=hashh(s);
	}
	sort(a+1,a+n+1);//排序，递增递减都可。
	for(int i=2;i<=n;++i)if(a[i]!=a[i-1])++ans;//如上。
	write(ans,'\n');
	return 0;
}
```

这个代码实现是主播不太喜欢的，因为它需要使用 `cin` 来读入字符串。主播不喜欢 `cin`，主播要用 `getchar()`。~~`scanf()` 是什么，能吃吗。~~

注意到我们使用代码（不是公式）计算哈希值时，每一轮计算都只与某一个字符有关，而与字符串长度无关。我们完全可以在输入的同时处理出哈希值，但却在 `hashh()` 函数中获取了字符串的长度用以遍历字符串。

所以，使用 `getchar()` 一个一个地读入字符并计入贡献，直到读取到非法字符（此时当前字符串输入完毕）。

我们再加上自然溢出，就得到了这份代码：

```
#include<iostream>
#include<string>
#include<algorithm>
#define ull unsigned long long
#define base 191
using namespace std;

const int N=1e7+5;

namespace OIfast{
	
	inline ull read(){
		ull n=0;
		char c=getchar();
		while(c<'0'||c>'9')c=getchar();
		while(c>='0'&&c<='9'){
			n=(n<<3)+(n<<1)+(c^48);
			c=getchar();
		}
		return n;
	}
	
	inline void print(ull n){
		if(n>=10)print(n/10);
		putchar(n%10^48);
		return ;
	}
	
	inline void write(ull n,char c){
		print(n),putchar(c);
		return ;
	}
	
}using namespace OIfast;

int n,ans=1;
ull a[N];

signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		ull hashh=0;
		char c=getchar();
		while(!isdigit(c)&&!isalpha(c))c=getchar();//跳过乱七八糟的东西。
		while(isdigit(c)||isalpha(c)){//计算当前字符串的哈希值。循环结束就标志着当前字符串输入结束。
			hashh=hashh*base+(ull)c;
			c=getchar();
		}
		a[i]=hashh;
	}
	sort(a+1,a+n+1);
	for(int i=2;i<=n;++i)if(a[i]!=a[i-1])++ans;
	write(ans,'\n');
	return 0;
}
```

---

## 作者：LastKismet (赞：4)

这里提供 XorShift 哈希方式。

我们考虑哈希字符串的形态，不难想到，前 $i$ 位形成的前缀的哈希值可以由前 $i-1$ 位形成的前缀的哈希值和第 $i$ 位字符转移得来，这也是大多数字符串哈希的哈希思路。

我们会考虑对 $hsh_{i-1}$ 进行一次映射，然后再更新上这一位的字符串。以常规的“把字符串看作高进制数来说”，我们会把 $hsh_{i-1}$ 乘上一个高进制，这就是一种映射。

但多项式映射的冲突率是很高的。所以这里提供一种冲突率极低的方式，也就是 XorShift。

事实上，这是一个伪随机数生成算法。我们可以利用其周期长的特性进行映射。

关于那三次位移的常量，实测换成别的也够用，但是用这个经典的常量~~好背好写~~可以获得更大的周期，也就是更小的冲突率。

```cpp
const ull mask=mt19937_64(time(0))();
ull shift(ull x){
    x^=mask;
    x^=x<<13;
    x^=x>>17;
    x^=x<<5;
    x^=mask;
    return x;
}
```

其实那两次对随机常量 $mask$ 的异或可有可无，但为了防止被人对着 Hack，所以可以加上。事实上我不是很确定这道题的数据范围能不能卡掉。但这并没有很大的常数影响，所以为了保险就加上吧。

然后是关键部分代码：

```cpp
const ull mask=mt19937_64(time(0))();
ull shift(ull x){
    x^=mask;
    x^=x<<13;
    x^=x>>17;
    x^=x<<5;
    x^=mask;
    return x;
}

set<ull> hshs;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    int n;cin>>n;
    string s;
    rep(i,1,n){
        cin>>s;
        ull hsh=0;
        for(auto c:s)hsh=shift(hsh)+c;
        hshs.insert(hsh);
    }
    cout<<hshs.size();
	return 0;
}
```

代码中对当前位的更新使用了直接加的方式，事实上直接异或也没有问题，以及别的杂七杂八的更新方法多半都没有问题，是自由的。

---

## 作者：我的妹妹syf (赞：3)

普通的trie当然做不了啦，毕竟输入这么大。

正确的姿势应该是压缩字典树吧，因为N的规模比较小，所以压缩字典树的结点数量也会相对较小。

实际上不需要查找——我是在递归建树时存一下有没有对树进行修改，有修改过就把答案+1(s)，没有的话就意味着找到了完全相同的路径，也就是说这个串已经出现过了。

当然，速度还是要比hash慢不少的。

不知为何读入写错了= =wa了好几次。

附代码





```cpp
#include<iostream>
#include<cstring>
using namespace std;
struct Node{
    int st,ed,cnt;
    Node *ch[64];
    char sus[64];
};
int ans=0;
char sus[20000000],c[20000],re;
Node *t=new(Node),*tnode;
int n,cmq,len,size,tmp;
void clear(Node *p){
    p->st=p->ed=size;
    p->cnt=0;
}
int same(Node *p,int st){
    int i;
    for(i=0;p->st+i < p->ed&&st+i<len&&c[st+i]==sus[ p->st +i];i++);
    return i;
}
void diliver(Node * &p,int len){
    Node *t=new(Node);
    t->st=p->st;
    t->ed=t->st+len;
    t->cnt=1;
    t->sus[0]=sus[t->ed];
    t->ch[0]=p;
    p->st=t->ed;
    p=t;
}
int find(Node *p,char ch){
    for(int i=0;i< p->cnt;i++)
        if(p->sus[i]==ch)
            return i;
    return -1;
}
void insert(Node *&p,int st,int flag){
    int ll;
    ll=same(p,st);
    if(ll==p->ed - p->st){
        st=st+ll;
    }
    else{
        diliver(p,ll);
        flag=1;
        st=st+ll;
    }
    if(st==len){
        if(flag) ans++;
        return;
    }
    else{
        tmp=find(p,c[st]);
        if(tmp!=-1) insert(p->ch[tmp],st,flag);
        else{
            tnode=new(Node);
            p->ch[p->cnt]=tnode;
            p->sus[p->cnt]=c[st];
            p->cnt++;
            clear(tnode);
            for(int i=st;i<len;i++)
                sus[tnode->ed++]=c[i];
            size=tnode->ed;
            flag=1;
            if(flag) ans++;
            return;
        }
    }
}
int main(){
    clear(t);
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>c;
        len=strlen(c);
        insert(t,0,0);
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：sea_bird (赞：2)

[题目の传送门](https://www.luogu.com.cn/problem/P3370)。

# 算法介绍

> 我们定义一个把字符串映射到整数的函数 $f$，这个 $f$ 称为是 Hash 函数。这个函数 $f$ 可以方便地帮我们判断两个字符串是否相等。
>
> Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。
>
> —— [Oi-wiki](https://oi-wiki.org/string/hash/)。

也就是说 Hash 函数中应满足**每一个字符串对应**一个 Hash 的函数值，如果两个不同字符串的哈希值相同则称为**哈希冲突**，当然，当 Hash 的函数值不一样时，其所对应的字符串也不一致。

```cpp
int Hash(string str){
 	int ans=0;
 	for(int i=0;i<str.size();i++){
 		ans=(ans*b+(int)str[i])%mod;
	}
 	return ans;
}
```

## 哈希冲突

在遇到 Hash 函数值相同但原字符串不一样的情况，便是发生了哈希冲突（上文链接有关于哈希冲突的详细概率证明）。

解决哈希冲突的方法当然有，比如**多值哈希**就是一个（一般用双值哈希），使用多个 Hash 函数，对于两个字符串，假如有一个函数中的函数值不同，那么这两个字符串就一定不相同，若每个函数中其所对应的 Hash 值都相同，则认为两个字符串相同，这样就基本能解决 Hash 冲突问题。

# 代码实现

先对字符串进行处理，将其映射到数组中，第 $i$ 个字符串存为 $a_i$，将哈希值存入数组后，将数组排序，遍历数组，如果 $a_i$ 与 $a_{i-1}$ 不同，计数器加一，最后输出由计数器统计的不同哈希值的数量（也就是不同字符串的数量）。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string str[100005];
ll a[100005];
ll mod=1e9+9;
ll b=99991;
ll hashn(string str){
 	ll ans=0;
 	for(int i=0;i<str.size();i++){
 		ans=(ans*b+(ll)str[i])%mod;
	}
 	return ans;
}
int main(){
 	ll n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>str[i];
		a[i]=hashn(str[i]);
	}
	sort(a,a+n+1);
	ll cnt=0;
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]){
			cnt++;
		}
	}
	cout<<cnt<<endl;
    return 0;
}
```

## 说句闲话

其实用 STL 里的 set 容器即可，利用其**不允许元素重复**性质去重，最后输出容器中的数量，但毕竟是字符串哈希的模板题目，建议还是用字符串哈希来做吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
set<string> a;
int main()
{
    string p;
    int n,i;
    cin>>n;
    for(i=1;i<=n;i++){
    	cin>>p;
    	a.insert(p);
	}
	cout<<a.size();
}
```

欢迎补充。

---

## 作者：Coffee_zzz (赞：1)

我们定义一个把字符串映射到整数的函数 $f$，称其为 Hash 函数。

我们希望该函数能帮助我们快速判断两个字符串是否相等。根据此目标，我们希望该函数满足：

- 当 Hash 函数值不同时，两个字符串不同；
- 当 Hash 函数值相同时，两个字符串相同。

但在绝大多数情况下，当 Hash 函数值相同时，我们不能保证两个字符串相同，只能使两个字符串**大概率**相同。我们将 Hash 函数值相同但原字符串不同的现象称为 Hash 冲突或 Hash 碰撞。

通常情况下，我们采用的是下面的定义方法：

$$
f(s)=\left(\sum_{i=1}^n s_i \times b^{n-i} \right) \bmod M
$$

其中，$b$ 通常是一个不小于 $|\Sigma|$ 的整数，我们称其为底数；$M$ 是一个大整数，我们称其为模数。可以将其类比为一个 $b$ 进制数理解，对 $M$ 取模是为了避免返回值太大导致无法比较。

接下来，我们考虑出现 Hash 冲突的概率。

我们设模数为 $M$，需要计算的字符串的数量为 $n$，则出现 Hash 冲突的概率为：

$$
P(n,M)=1-\prod_{i=0}^{n-1} \dfrac {M-i}{M}=1-\dfrac{M!}{M^n(M-n)!} \approx 1-\exp\left(-\dfrac {n(n-1)}{2M}\right)
$$

具体证明可以参考 [OI Wiki](https://oi-wiki.org/string/hash/#hash-%E7%9A%84%E9%94%99%E8%AF%AF%E7%8E%87%E5%88%86%E6%9E%90)。

通常情况下，当 $n$ 是 $\mathcal O(\sqrt M)$ 量级的时候，出现 Hash 冲突的概率就很大了。

我们可以使用 `unsigned long long` 来定义 Hash 函数的结果，相当于把模数 $M$ 设置为 $2^{64}$。这种方法被称作自然溢出，在随机数据下出现 Hash 碰撞的概率很低，但容易被刻意构造的数据卡住。

我们还可以使用多模 Hash，即定义多个模数 $M$ 不同的 Hash 函数。判断时，只要有其中一个 Hash 函数值不同就认为两个字符串不同，当且仅当所有 Hash 函数值相同时才认为两个字符串相同。通常情况下，双模 Hash 就够用了。

以上知识对于解决本题已经够用了，接下来我们来看一些常用的拓展知识。

我们考虑怎么优化该算法的时间复杂度。

当题目需要多次查询子串的 Hash 函数值时，我们可以做到 $\mathcal O(n)$ 预处理，$\mathcal O(1)$ 回答单次询问。

具体而言，对于字符串 $s$，我们定义 $v_i$ 表示 $f(pre_i)$，即 $s$ 的长度为 $i$ 的前缀的 Hash 函数值。根据定义，我们有：

$$
\begin{aligned}
v_i&=\left(\sum_{j=1}^i s_j \times b^{i-j} \right) \bmod M\\
&=\left(s_i+\sum_{j=1}^{i-1} s_j \times b^{i-j}\right)\bmod M\\
&=\left(s_i+\left(\sum_{j=1}^{i-1} s_j \times b^{i-1-j}\right)\times b\right)\bmod M\\
&=\left(s_i+v_{i-1} \times b\right)\bmod M\\
\end{aligned}
$$

其中我们认为 $v_0=0$。

对于 $s[l,r]$，我们考虑用类似前缀和的方式计算它的 Hash 函数值：

$$
\begin{aligned}
f(s[l,r])&=\left(\sum_{i=l}^{r} s_i \times b^{r-i}\right) \bmod M \\
&=\left(\sum_{i=1}^r s_i \times b^{r-i}- \sum_{i=1}^{l-1} s_i \times b^{r-i}\right) \bmod M\\
&=\left(\sum_{i=1}^r s_i \times b^{r-i}- \left(\sum_{i=1}^{l-1} s_i \times b^{l-1-i}\right) \times b^{r-l+1}\right) \bmod M\\
&=\left(v_r-v_{l-1} \times b^{r-l+1}\right) \bmod M
\end{aligned}
$$

$\mathcal O(n)$ 预处理出 $v$ 数组后即可 $\mathcal O(1)$ 回答。

字符串 Hash 题单链接：<https://www.luogu.com.cn/training/682394>  
字符串 Hash 题单题解链接：<https://www.luogu.com.cn/article/gze8zzs2>

---


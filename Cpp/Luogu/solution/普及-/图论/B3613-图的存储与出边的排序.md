# 图的存储与出边的排序

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点编号从 $1$ 至 $n$。对于 $u = 1, 2, 3, \dots n$，依次完成如下要求：  
对于 $u$ 的所有出边（即从 $u$ 出发的边），按照**从小到大**的顺序输出出边所指向的节点编号。

**依次完成**的含义是，先按顺序输出 $u = 1$ 的出边所指向的点的编号，再按顺序输出 $u = 2$ 的出边所指向的点的编号……最后按顺序输出 $u = n$ 的出边所指向的点的编号。

## 说明/提示

### 数据规模与约定：

对于全部的测试点，保证 $1 \leq T, n, m \leq 5 \times 10^5$，但同时各测试点的 $n$ 与 $m$ 之和均不超过 $5 \times 10^5$，即 $\sum n, \sum m \leq 5 \times 10^5$。且 $1 \leq u, v \leq n$，每组数据内不存在重边。

### 提示

请注意大量读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
2
3 4
1 3
1 2
3 2
3 1
3 9
1 3
2 3
3 3
1 2
2 2
3 2
1 1
2 1
3 1```

### 输出

```
2 3

1 2
1 2 3
1 2 3
1 2 3```

# 题解

## 作者：Firstly (赞：18)

看到其他题解用的都是 vector，这里提供一种不一样的思路：用 STL 中的 set 来存图。

## **解题思路：**


------------

我们考虑使用 ```set<int>s[maxn]``` 以邻接表的格式存储图。每读取一条边，就用 ```s[x].insert(y);``` 存进去。在输出的时候，我们就可以直接输出 $s_i$ 中存储的所有终点了。

set 相比 vector 有一个优势：在插入的时候，它就能够自动去重和排序。也就是说，在插入完毕之后，我们无需像 vector 一样用 sort 扫一遍了。

## 关于 set 的基本操作：


------------
### 1.插入
```insert(x) ``` 用于将 x 插入到 set 中，并自动递增排序和去重。时间复杂度为 $O(\log_2 n)$，其中 n 为 set 中的元素个数。

### 2.获取元素个数。
```size()``` 用来获得 set 中的元素个数，时间复杂度为 $O(1)$。

### 3.清空元素
```clear()``` 用来清空 set 中的所有元素，时间复杂度为 $O(n)$。

### 4.删除指定元素
```erase()``` 可以删除单个元素，也可以删除一个区间内的所有元素。删除单个元素时可以使用 ```erase(it)```，其中 it 为要删除的元素的迭代器，时间复杂度为 $O(1)$。也可以使用 ```erase(x)```，其中 x 为要删除元素的值，时间复杂度为 $O(\log_2 n)$。例如以下一段代码（若 s 为已定义好的 set 集合）：
```cpp
s.insert(1);
s.insert(10);
s.insert(100);
s.erase(10);
for(set<int>::iterator it=s.begin();it!=s.end();it++)cout<<*it<<' ';
```
其输出结果为 ```1 100```。

### 5.找到对应元素
```find(x)``` 返回的是 set 中对应值为 x 的迭代器，时间复杂度为 $O(\log_2 n)$。例如以下一段代码：
```cpp
s.insert(1);
s.insert(2);
s.insert(3);
printf("%d",*(s.find(2)));
```
其输出结果为：```2```

在了解了 set 的基本用法之后，我们来看一看本题的代码：
## **Code:**


------------
```cpp
#include<cstdio>
#include<set>//set专属头文件
using namespace std;
const int maxn=5e5+5;
int t,n,m,x,y;
set<int>s[maxn];
inline int read(){//快读
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-48,ch=getchar();
    return s*w;
}
inline void write(int x){//快写
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
int main(){
    t=read();
    while(t--){
        n=read();m=read();
        for(int i=1;i<=n;i++)s[i].clear();//在一组数据的开始部分进行初始化，将集合清空。
        for(int i=1;i<=m;i++){
        	x=read();y=read();
        	s[x].insert(y);//使用邻接表的方式存储图。
		}
		for(int i=1;i<=n;i++){
			for(auto it=s[i].begin();it!=s[i].end();it++)
				write(*it),putchar(' ');//遍历输出
			putchar('\n');//注意：即使一行中没有输出也要换行
		}
    }return 0;
}
```

---

## 作者：Zboh_Zbp (赞：16)

## 题意简述

- 给定 $T$ 组数据和有向图 $G$。
- 给出有向图 $G$ 中从 $u$ 指向 $v$ 的边。
- 按序输出 $u={1,2,3\ldots n}$ 为出边时指向的点的编号。

## 题目分析

参看样例，我们发现可以把每个节点的出边存到一个数组里，即为 `w[u][i]` 表示 $u$ 出发的边指向第 $i$ 个节点。

但是，我们会发现数组开不下，因为一共有 $5\times 10^5$ 个点，普通的二维数组要开成 $n^2=2.5\times 10^{11}$，显然会 MLE。

但是，我们借用前面的思路，使用可变长数组 vector 来实现：定义 `vector <unsigned long long int> w[500010]`。`w[u]` 则表示 $u$ 出边指向的节点。那么在读入一条边 $\langle u,v \rangle$ 后，直接 `w[u].push_back(v)` 即可。

注意到一共有 $n$ 条边，因此总的空间复杂度是 $O(n)$ 的，显然可以 AC。

最后，还需要有序输出，要进行排序。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,m,u,v;
vector <unsigned long long int> w[500010];
int main(){
	scanf("%d",&T);
	for(int i=1;i<=T;i++){
		scanf("%d%d",&n,&m);
		for(int j=1;j<=n;j++){ // 清除上一次的数据。
			w[j].clear();
		}
		for(int j=1;j<=m;j++){
			scanf("%d%d",&u,&v);
			w[u].push_back(v);
		}
		for(int j=1;j<=n;j++){
			sort(w[j].begin(),w[j].end());
			for(auto v : w[j]){
				printf("%d ",v);
			}
			//这里运用了 C++14 语言的特性，意思是将 w[j] 拆分为一个一个的数字 v，依次输出，直到全部输出为止。
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：luckydrawbox (赞：8)

[$\text{Link}$](https://www.luogu.com.cn/problem/B3613)

## 前置知识

[图的存储](https://oi-wiki.org/graph/save/)、[排序](https://www.luogu.com.cn/problem/P1177)。

## 题意

>给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点编号从 $1$ 至 $n$。对于 $u = 1, 2, 3, \dots n$，依次完成如下要求：
对于 $u$ 的所有出边（即从 $u$ 出发的边），按照**从小到大**的顺序输出出边所指向的节点编号。
>
>**依次完成**的含义是，先按顺序输出 $u = 1$ 的出边所指向的点的编号，再按顺序输出 $u = 2$ 的出边所指向的点的编号……最后按顺序输出 $u = n$ 的出边所指向的点的编号。

## 分析

这里给出两种做法：邻接表和链式前向星。

### 邻接表

- 清空邻接表。

```cpp
for(int i=1;i<=n;i++)
	e[i].clear();
```

- 存边。

```cpp
for(int i=1,x,y;i<=m;i++){
    x=read();y=read();
    e[x].push_back(y);
}
```

- 对每个点的出边排序，并输出。

```cpp
for(int i=1;i<=n;i++){
    sort(e[i].begin(),e[i].end());
    for(int j=0;j<e[i].size();j++)
        printf("%d ",e[i][j]);
    puts("");
}
```

### 链式前向星

- 清空 $head$ 数组，因为 $\sum m\le 5\times10^5$，所以 ``tot=0;`` 可加可不加。注意不能写成 ``memset(head,0,sizeof(head));``，否则时间复杂度就变成 $O(TN)\le(5\times10^5)^2=2.5\times10^{11}$ 级别的了。

```cpp
for(int i=1;i<=n;i++)
	head[i]=0;
```

- 存边

```cpp
void add(int x,int y){
	ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;
}

for(int i=1,x,y;i<=m;i++){
    x=read();y=read();
    add(x,y);
}
```

- 把每个点的出边放入 $\text{vector}$ 类型的 $e$ 或一个数组 中，注意前面要清空，然后排序并输出（~~那还不如直接用邻接表~~。

```cpp
for(int i=1;i<=n;i++){
    e.clear();
    for(int j=head[i];j;j=nxt[j])
        e.push_back(ver[j]);
    sort(e.begin(),e.end());
    for(int j=0;j<e.size();j++)
        printf("%d ",e[j]);
    puts("");
}
```

------------

以上两种做法的复杂度都是 $O(n\log n)$。

## 代码

### 邻接表

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N=5e5+10;
int t,n,m;
vector<int>e[N];
int main(){
	t=read();
	while(t--){
		n=read();m=read();
		for(int i=1;i<=n;i++)
			e[i].clear();
		for(int i=1,x,y;i<=m;i++){
			x=read();y=read();
			e[x].push_back(y);
		}
		for(int i=1;i<=n;i++){
			sort(e[i].begin(),e[i].end());
			for(int j=0;j<e[i].size();j++)
				printf("%d ",e[i][j]);
			puts("");
		}
	}
	return 0;
}
```

### 链式前向星

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N=5e5+10;
int t,n,m;
int head[N],nxt[N<<1],ver[N<<1],tot;
void add(int x,int y){
	ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;
}
vector<int>e;
int main(){
	t=read();
	while(t--){
		n=read();m=read();
		for(int i=1;i<=n;i++)
			head[i]=0;
		for(int i=1,x,y;i<=m;i++){
			x=read();y=read();
			add(x,y);
		}
		for(int i=1;i<=n;i++){
			e.clear();
			for(int j=head[i];j;j=nxt[j])
				e.push_back(ver[j]);
			sort(e.begin(),e.end());
			for(int j=0;j<e.size();j++)
				printf("%d ",e[j]);
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：tZEROちゃん (赞：5)

考虑用 `std::vector<int> to[N]` 存储边，也就是说 `to[u] = v` 表示有一条边从 $u$ 到 $v$。

我们将输入的点进行排序，然后按照上述规定 `push_back` 到 `to[u]` 里面，最后遍历每一个 `to[u]`，输出即可。

```cpp
const int N = 1e6 + 10;
vector <int> to[N];
pair<int, int> a[N];

void solve() {
  int n, m;
  iocin >> n >> m;
  rep (i, 1, m) {
    cin >> a[i].first >> a[i].second;
  }
  sort(a + 1, a + m + 1);
  rep (i, 1, m) {
    to[a[i].first].push_back(a[i].second);
  }
  rep (i, 1, n) {
    for (auto i : to[i]) {
      printf("%d ", i);
    }
    puts("");
    to[i].clear();
  }
}

int main(){
  multiCase() solve();
  return 0;
}


---


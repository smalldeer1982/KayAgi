# 图的遍历（简单版）

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

## 说明/提示

- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^3$。

## 样例 #1

### 输入

```
4 3
1 2
2 4
4 3```

### 输出

```
4 4 3 4```

# 题解

## 作者：Base_ring_tree (赞：24)

~~蒟蒻第一次发题解，望审核通过~~

## [题目](https://www.luogu.com.cn/problem/B3862)

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求从点 $v$ 出发，能到达的编号最大的点。


这是一道图的遍历考察的是如何使用 DFS 遍历图（~~废话~~）。

## 思路

我们可以来这样思考，我们按节点编号大小从大到小依此遍历每一个数所能到达的节点，这一个操作可以用 DFS。

再来详细的说如何 DFS。

我们可以**反向建边**，这样如果一个点 $x$ 能被另一个点 $y$ 访问到，那么 $x$ 也一定能访问 $y$。

DFS 的过程就是：如果我遍历到一个点 $x$ 就来看这个点是否被比我编号更大的点访问过。

简单点说就是看 $x$ 是否被标记过。我们是按节点编号大小从大到小依此遍历，如果 $x$ 被标记过就是说明 $x$ 被比我编号更大的点访问过。

如果没有那么就表明我是 $x$ 可以访问到的编号最大的点（这样就可以知道 $x$ 多能到达最大的节点的编号了）。

然后再依次 DFS 自己的子节点就好惹！

# 代码！
~~注释较少，别打我...~~
```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define TRACE 1
#define tcout TRACE && cout

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

#define int long long

#ifdef int
const int INF = 0x3f3f3f3f3f3f3f3f; 
#else
const int INF = 0x3f3f3f3f;
#endif

const int P = 998244353; 
const int N = 1e5 + 10, M = 1e5 + 10; 

int n, m;
vector<int> g[N];

bool vis[N];

int a[N];

void dfs(int u, int i)
{
	if(vis[u])
	{
		//如果这个点被别的点到达过, 则不能再走了
		return;
	}
	vis[u] = 1;
	a[u] = i;
	for(auto v: g[u])
	{
		if(vis[v] == 0)
		{
			dfs(v, i);
		}
	}
}

signed main()
{
	cin >> n >> m;
	for(int i=1; i<=m; i++)
	{
		int u, v;
		cin >> u >> v;
		g[v].push_back(u);
	}
	for(int i=n; i>=1; i--)
	{
		dfs(i, i);	//从i点出发, 能到哪个点, 就表示哪个点能到i
	}
	for(int i=1; i<=n; i++)
	{
		cout << a[i] << " ";
	}
	return 0;
}
```

---

## 作者：xu222ux (赞：11)

这是一道普通的 dfs 题目。

# 思路

dfs 每个起始点，扫一遍所有的点，然后看扫到的点编号最大的输出就可以了。

**特别注意： 要初始化，要初始化，要初始化！**

# 100pts code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
vector<int>mp[1005];
bool flag[1005];
void dfs(int now){
	for(int i=0;i<mp[now].size();i++){//子节点
		if(!flag[mp[now][i]]){
			flag[mp[now][i]]=true;//标为已走过
			dfs(mp[now][i]);//下一层
		}
	}
}
int main(){
	cin>>n>>t;//点数and边数
	for(int i=1;i<=t;i++){
		int u,v;
		cin>>u>>v;
		mp[u].push_back(v);//注意是有向图
	}
	for(int i=1;i<=n;i++){//dfs每个起始点
		flag[i]=true;
		dfs(i);	
		int ans=-1;
		for(int j=1;j<=n;j++){
			if(flag[j])ans=j;
		}
		cout<<ans<<' ';
		memset(flag,0,sizeof(flag));//多测不清空，爆零两行泪
	}
	return 0;
}

```


---

## 作者：Code_Select_You (赞：8)

## 思路
这道题的 $1 \leq N \leq 10^3$，直接枚举就能过。用数组记下每个点出去的边，再 DFS 搜索一遍，更新最大值。最后输出即可。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> e[1010];
int ans[1010],n,m;
bool f[1010];
void dfs(int p,int q){//dfs遍历能到达的点，p是当前点，q是起点 
	f[p]=false;
	ans[q]=max(ans[q],p);
	for(auto i:e[p])
		if(f[i])
			dfs(i,q);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){//建图 
		int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y); 
	}
	for(int i=1;i<=n;++i){//枚举 
		memset(f,true,sizeof(f));
		dfs(i,i);
	}
	for(int i=1;i<=n;++i) printf("%d ",ans[i]);//输出 
	return 0;
}
```


---

## 作者：XinFengIneverleft (赞：5)

### ~~蒟蒻第一次写题解，求通过(~~  
------------
求从一个点出发能到达的编号最大的点，由于数据范围不是很大，所以使用 DFS 进行遍历。（本蒟蒻用 DFS 交[本题数据强化版](https://www.luogu.com.cn/problem/P3916)就只有 $90$ 分了（逃）  
因为 $n$ 个点都要求一遍，所以要进行 $n$ 次 DFS 遍历。  
代码如下，详见注释。  
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;

vector<int> g[100005];//vector存图
int maxn[100005];//存储能到达的编号最大的点
bool f[100005];//判断点是否已经遍历过

void add(int x, int y)//无边权的加边操作
{
	g[x].push_back(y);
}

void dfs(int n, int u)//平平无奇DFS，n表示起点，u表示当前遍历到的点
{
	if (g[u].empty())//如果这个点没有指向其他点的边（即无出度）就回退
		return;
	for (int i = 0; i < g[u].size(); i++)
	{
		if (f[g[u][i]] == false)
		{
			f[g[u][i]] = true;//标记为已遍历
			maxn[n] = max(g[u][i], maxn[n]);//更新答案
			dfs(n, g[u][i]);//搜索下一层
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//卡常小技巧（虽然此题并不需要）
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)//初始化！！！
		maxn[i] = i;
	for (int i = 1; i <= m; i++)//建图
	{
		int x, y;
		cin >> x >> y;
		add(x, y);
	}

	for (int i = 1; i <= n; i++)//搜索n次
	{
		dfs(i, i);
		cout << maxn[i] << " ";
		memset(f, false, sizeof(f));//退回初始状态，避免影响下一次搜索
	}
	return 0;
}
```

---

## 作者：scc36 (赞：3)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B3862)    
### 思路   
本题范围较小，$n$ 最多只有一千，使用宽搜进行搜索，找到最大节点即可。    
#### 注意：勿用深搜。因为深搜时要调用栈，太多栈要溢出。   
### 代码  
```cpp
#include <bits/stdc++.h>      //万能头
using namespace std;
int n,m,i,x,y,j,f[10001],ma,b[10001],t,w,fx;
vector<int>e[1001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);    //输入输出的加速
	cin>>n>>m;
	for(i=1;i<=m;i++){
		cin>>x>>y;
		e[x].push_back(y);     //单向图的储存
	}
	for(i=1;i<=n;i++){
		ma=0;             //求最大要赋值！！！
		for(j=1;j<=n;j++) f[j]=0;
		t=w=1;          //宽搜开始
		b[1]=i;f[i]=1;
		while(t<=w){
			fx=b[t];ma=max(ma,fx);
			for(j=0;j<e[fx].size();j++)
				if(f[e[fx][j]]==0){  //有没有做过
					w++;
					b[w]=e[fx][j];
					f[e[fx][j]]=1;  //做过赋1
				}
			t++;
		}
		cout<<ma<<" ";         //输出最大值
	}
}
```
新鲜出炉的题目，新鲜出炉的题解。   
求过~~

---

## 作者：Crasole (赞：2)

## 思路

直接爆搜肯定不行(虽然我没试过)。

考虑反向建边，这样子当我们从点 $u$，出发时，从点 $n$ 开始一直到点 $1$，对每个点做起点做深搜，对于所有 $u$ 能到达的点 $v$，令 $f_i$ 代表 $A(i)$：

- 如果 $f_i \ne 0$，则代表之前已经有更大的点到达了点 $i$，不继续搜索。

- 如果 $f_i = 0$，则说明点 $i$ 没有到达过，从点 $i$ 开始继续深搜。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,idx,h[N],to[N],nx[N],f[N];
void add_edge(int u,int v){
	to[++idx]=v;
	nx[idx]=h[u];
	h[u]=idx;
}
void dfs(int u,int v){//以点u作为起点，当前搜到点v
	f[v]=u;//因为点v之前还没到过，那么点u就是A(v)
	for(int i=h[v];i;i=nx[i])
		if(f[to[i]]==0) dfs(u,to[i]);//如果点i没有到达过，从点i开始继续深搜。
			
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(v,u);//反向建边
	}
	for(int i=n;i>=1;i--)
		if(f[i]==0)//判断是否到达过
			dfs(i,i);	
	for(int i=1;i<=n;i++)
	 	printf("%d ",f[i]);
	return 0;
}
```

---

## 作者：yzm0325 (赞：2)

~~哇 P3916 竟然出了弱化版所以我来水题解了~~

## 思路

首先显而易见的思路就是对搜索每个点能去到的所有点，然后取最大值，时间复杂度 $O(n^2)$。虽然也能通过，但是复杂度还不是最优秀的。

既然是考虑每个点能到达的最大值，那我们不如**逆向思维**，计算**每个点是哪些点能到达的最大值**。

首先在建图时**反向建边**（以下默认是反向建边后的图），然后开一个数组 $a$ 记录每个节点能到达的最大值，然后从大到小遍历每个节点，如果这个节点没有被标记，说明这个节点在图中是所有能从它出发到达的点中编号最大的那一个（否则前面的遍历应该已经标记了这个节点），那么进行 dfs 标记。

dfs 中先标记原来的节点的最大值是它的节点编号，然后遍历它所有能去到的节点，继续进行 dfs。

最后直接输出 $a$ 数组即可。

## 代码（19ms 第二优解）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[1010];
vector <int> p[1010];
void dfs(int x, int v) {
    a[x] = v;
    for (int i = 0; i < p[x].size(); i++)
        if (!a[p[x][i]]) dfs(p[x][i], v);
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        p[v].push_back(u);
    }
    for (int i = n; i > 0; i--)
        if (!a[i]) dfs(i, i);
    for (int i = 1; i <= n; i++) cout << a[i] << ' ';
    return 0;
}
```

---


# [蓝桥杯青少年组省赛 2022] 路线

## 题目描述

有一个旅游景区，景区中有 $N$ 个景点，景点以数字 $1$ 到 $N$ 编号，其中编号为 $N$ 的景点为游客服务中心所在地。景区中有 $M$ 条连接路线，每条路线连接两个景点。

已知：
1. 一个景点可以被多条路线连接；
2. 景点之间的连接路线都可以双向行走；

当给出 $N$ 个景点和 $M$ 条连接路线，及 $M$ 条路线的连接关系，请你计算出从编号 $1$ 到编号 $N-1$ 的每一个景点，到达游客服务中心至少需要经过几条路线。如果某个景点不能到达游客服务中心则输出 $-1$。

例如：
- 当 $N=5$，$M=4$ 时
- 4 条路线的连接关系为：$1\leftrightarrow2$、$1\leftrightarrow3$、$2\leftrightarrow4$、$2\leftrightarrow5$
- 则：
  - 景点 $1$ 到达景点 $5$（游客服务中心）至少经过 $2$ 条路线（路线 $2$，路线 $4$）
  - 景点 $2$ 到达景点 $5$ 至少经过 $1$ 条路线（路线 $4$）
  - 景点 $3$ 到达景点 $5$ 至少经过 $3$ 条路线（路线 $1$，路线 $2$，路线 $4$）
  - 景点 $4$ 到达景点 $5$ 至少经过 $2$ 条路线（路线 $3$，路线 $4$）

## 样例 #1

### 输入

```
5 4
1 2
1 3
2 4
2 5```

### 输出

```
2 1 3 2```

# 题解

## 作者：lmz105 (赞：5)

### 思路
这题可以直接把除 $N$ 以外的每个点当作起点，然后求起点到 $N$ 的距离，但是这样太慢了，我们可以看到这是一个无向图，而且终点都是 $N$，所以可以直接把 $N$ 当作起点，求它到每个点的距离，这样就可以快速得到答案。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			bo ^= (ch == '-');
			ch = getchar();
		}
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo) {
			in = -in;
		}
	}
	template<typename T> inline void w(T out) {
		static char op[20];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar(' ');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
using namespace FX;
#undef getchar
#undef putchar
#endif
using namespace std;
const ll N = 106;
ll n, m, dis[N];
vector<ll>e[N];

int main() {
	r(n, m);
	while (m--) {
		ll x, y;
		r(x, y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	memset(dis, -1, sizeof dis);
	queue<ll>q;
	dis[n] = 0;
	q.push(n);
	while (q.size()) {
		ll a = q.front();
		q.pop();
		for (auto v : e[a]) {
			if (dis[v] == -1) {
				dis[v] = dis[a] + 1;
				q.push(v);
			}
		}
	}
	for (ll i = 1; i < n; i++) {
		w(dis[i]);
	}
	return 0;
}
```
### 时间复杂度

$O(n)$

---

## 作者：hyc0604 (赞：2)

很简单的一题最短路。

算法：Dijkstra+堆优化+链式前项星。

题目简述：从 $i=1$ 到 $i=N-1$ 对每个 $i$ 求到编号为 $n$ 的最短路。
 
题目分析：因为景点之间的连接路线都可以双向行走，所以是个**无向图**
，把边权设为 $1$ 就可以直接套最短路模板了。

模板推荐：[P4779](https://www.luogu.com.cn/problem/P4779)。

---


代码实现如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
using pii = pair<int, int>;
const int N = 105;
int n, m, s;
int head[N];

struct Edge {
	int to, w, next;
} edge[N * 2];
int cnt;
//链式前项星
void add_edge(int u, int v, int w) {
	edge[cnt].to = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt++;
}
int dis[N], vis[N];

void dij(int u) {
	fill(dis, dis + N, INT_MAX);
	fill(vis, vis + N, 0);//多测记得清空
	priority_queue<pii, vector<pii>, greater<pii> >q;
	q.push({0, u});
	dis[u] = 0;
	while (!q.empty()) {
		int u = q.top().second;
		q.pop();
		if (vis[u])
			continue;
		vis[u] = 1;
		for (int i = head[u]; ~i; i = edge[i].next) {
			int v = edge[i].to;
			int w = edge[i].w;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
> 				q.push({dis[v], v});
			}
		}
	}
	if (dis[s] != INT_MAX)//如果数值没有变化则输出-1
		cout << dis[s] << " ";
	else
		cout << -1 << " ";
}

signed main() {
	cin >> n >> m;
	s = n;
	fill(head, head + N, -1);
	for (int i = 1, u, v; i <= m; i++) {
		cin >> u >> v;
		add_edge(u, v, 1);
		add_edge(v, u, 1);//无向图
	}
	for (int i = 1; i < n; i++) {
		dij(i);
	}

	return 0;
}

```

因为数据范围 $n,m \le 100$，所以不用过多优化~~绝对不是我不想写~~。

~~ps : 第一次写题解求通过。~~

---

## 作者：TJB_LHY (赞：2)

# 思路

一道~~有点奇怪的~~广搜题，题意主要是：有一个**无向图**，每条路径长为一，在指定图上一点，要你求以该点为起点的单源最短路。由于每条路径长为一，所以每个点只需要拓展一次，普通广搜就可以以 $O(n)$ 的速度得到答案。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
struct node{
    int l,id;
}t;//广搜结构体，前者为路径长度，后者为编号
int n,m,u,v,w,dist[105];//dist为答案
bool vis[105];//标记
vector<int>G[105];//存图
queue<node>Q;//广搜队列
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    while(m--){
        cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }//输入
    memset(dist,0x3f,sizeof dist);//赋最大值
    Q.push({0,n});
    vis[n]=1;
    while(Q.size()){
        u=Q.front().id;
        w=Q.front().l;
        dist[u]=w;
        Q.pop();//弹出对头
        for(int i=0;i<G[u].size();i++){
            v=G[u][i];
            if(vis[v])continue;
            Q.push({dist[u]+1,v});//广搜
            vis[v]=1;//标记
        }
    }
    for(int i=1;i<n;i++){
        if(dist[i]!=0x3f3f3f3f)cout<<dist[i]<<' ';//可以到达
        else cout<<-1<<' ';//无法到达
    }
	return 0;
}
```

---

## 作者：HongzheLi (赞：1)

## 题目
双向边，求最短路。

## 思路
计算出从编号 $1$ 到编号 $N−1$ 的每一个景点去 $N$ 就可以转换成从 $N$ 去 $1$ 到编号 $N−1$ 的每一个景点。就变成了单源最短路，这里本蒟蒻就用 Dijkstra 来写了。

## 代码

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll N=110;
ll n,m,dis[N],u;
vector<ll>G[N];
bool vis[N];
struct node{
	ll u,dis;
	bool operator < (const node &a) const{return dis>a.dis;}
};
priority_queue<node>p;
void Dij(){
	for(ll i=1;i<=n;i++)dis[i]=inf;
	dis[n]=0;
	p.push({n,0});
    while(!p.empty()){
		u=p.top().u;
		p.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(ll v:G[u]){
			if(dis[u]+1<dis[v]){
				dis[v]=dis[u]+1;
				p.push({v,dis[v]});
			}
		}
	}
	for(ll i=1;i<=n;i++)if(dis[i]==inf)dis[i]=-1;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=1,u,v;i<=m;i++){
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	Dij();
	for(ll i=1;i<n;i++)cout<<dis[i]<<" ";
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 思路

这就是简简单单的图吗。

题目让我求出各个点到第 $N$ 号点的最短距离。

题目已经说好了，这是一个双向图。

所以从 $x$ 到 $y$ 和从 $y$ 到 $x$ 的距离相同，那么这就是单源最短路了。

不会的可以看 [模板](https://www.luogu.com.cn/problem/P4779)。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>f[110];
int a[110],n,m,x,y;
bool b[110];
queue<int>q;
int main(){
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>x>>y;
		f[x].push_back(y); 
		f[y].push_back(x); 
	}
	memset(a,0xff,sizeof(a));
	a[n]=0,q.push(n),b[n]=1;
	while(q.size()){
		int x;
		x=q.front(),q.pop();
		for(int i=0;i<f[x].size();i++)
		if(b[f[x][i]]==0){
			q.push(f[x][i]);
			b[f[x][i]]=1;
			a[f[x][i]]=a[x]+1;
		}
	}
	for(int i=1;i<n;i++)
	cout<<a[i]<<" ";
}
```

---

## 作者：lianchanghua (赞：0)

#### 题目大意

有 $N$ 个点，$M$ 条双向边。

求出各个点到第 $N$ 号点的最短距离。

#### 算法思路

既然题目中说了，是双向边。

那么从 $x$ 到 $y$ 和从 $y$ 到 $x$ 的距离必然相同，那么我们就可以单源最短路了。

至于单源最短路，不会的可以去看[模板](https://www.luogu.com.cn/problem/P3371)。

#### AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
using namespace std;
const int N=105;
int n,m;
int dis[N];
bool vis[N];
vector<PII>g[N];
void spfa(){
	memset(dis,0x3f,sizeof(dis));
	queue<int>q;
	q.push(n);
	vis[n]=1;
	dis[n]=0;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(auto ts:g[u]){
			int v=ts.first;
			int w=ts.second;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	}
	for(int i=1;i<n;i++){
		if(dis[i]>1e9)cout<<-1<<" ";
		else cout<<dis[i]<<" ";
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int s,e;
		cin>>s>>e;
		g[s].push_back({e,1});
		g[e].push_back({s,1});
	}
	spfa();
	return 0;
}
```

---

## 作者：dear_deer_land (赞：0)

## 题意

给定一个有 $n$ 个点 $m$ 条边的图，求出图中的每一个点到节点 $n$ 的最短路径。

## 思路

求最短路最简单的方法就是使用 bfs，实现方法为存图后开一个数组 $ans$，$ans_i$ 表示节点 $i$ 到节点 $n$ 经过的最少边数，当 $ans_i$ 为 $0$ 时则表示节点 $i$ 无法走到节点 $n$。  
具体实现是在 bfs 过程中取 $tmp$ 为队列的队首，如果遍历到一个之前未遍历过的节点 $j$，那么 $ans_j = ans_{tmp} + 1$。剩下的部分就是一些普通 bfs 和 vector 存图，具体实现和解释及注意事项见代码。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[110];
bool vis[110];//判断有没有遍历到过 
vector<int> mp[110];//使用vector存图 
void bfs(){
	queue<int> q;
	q.push(n);
	int tmp;//记录当前点 
	while(!q.empty()){
		tmp=q.front();
		vis[tmp]=1;
		q.pop(); 
		for(int i=0;i<mp[tmp].size();i++){
			if(!vis[mp[tmp][i]]){
				q.push(mp[tmp][i]);
				vis[mp[tmp][i]]=1;
				ans[mp[tmp][i]]=ans[tmp]+1; //更新答案 
			}
		}
	} 
} 
int main(){
	cin>>n>>m;
	for(int i=1,x,y;i<=m;i++){
		cin>>x>>y;
		mp[x].push_back(y);
		mp[y].push_back(x);//建双向边（建两次） 
	}
	bfs();
	for(int i=1;i<n;i++){
		if(ans[i]==0){
			cout<<-1<<" ";//无解 
			continue; 
		}
		cout<<ans[i]<<" ";
	}
	return 0;
}
```

---

## 作者：xf20280111 (赞：0)

## 分析
题目要求我们求最短路，而且每条边边权都是 1，考虑 BFS 来求解。

接下来就是 BFS 模板了，建立一个队列存储节点，不断取出节点直到队列为空。

每个点遍历一次，所以时间复杂度 $\mathcal{O}(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100 + 10;
int n,m,ans[N];
vector<int> son[N];
queue<int> q;
int vis[N];
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= m;i++){
		int u,v;cin >> u >> v;
		son[u].push_back(v);
		son[v].push_back(u);
	}
	for (int i = 1;i <= n;i++) ans[i] = -1;
	q.push(n);
	ans[n] = 0;
	vis[n] = 1;
	while(q.size()){
		int x = q.front();q.pop();//取出节点
		for (auto i : son[x]){//遍历与这个节点连接的点
			if (vis[i] == 0){
				q.push(i);
				vis[i] = 1;//标记走过了
				ans[i] = ans[x] + 1;//计算
			}
		}
	}
	for (int i = 1;i < n;i++){
		cout << ans[i] << " ";
	}
	return 0;
}
```

---

## 作者：lty2023 (赞：0)

由于道路是双向的，所以求每个点到点 $n$ 的距离就是求点 $n$ 到那个点的距离。

考虑使用广度优先搜索，从节点 $n$ 开始搜索，这样一路搜下去，就能求出所有能到达的节点的距离了，把答案数组初始化为 $-1$，这样不能到达就能直接输出了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> a[110];
int ans[110];
bool b[110];
queue<int> q;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x,y;
		cin>>x>>y;
		a[x].push_back(y); 
		a[y].push_back(x); 
	}
	for(int i=1;i<=n;i++){
		ans[i]=-1;
	}
	ans[n]=0;
	q.push(n);
	b[n]=1;
	while(q.size()){
		int x;
		x=q.front();
		q.pop();
		for(int i=0;i<a[x].size();i++){
			if(b[a[x][i]]==0){
				q.push(a[x][i]);
				b[a[x][i]]=1;
				ans[a[x][i]]=ans[x]+1;
			}
		}
	}
	for(int i=1;i<n;i++){
		cout<<ans[i]<<" ";
	}
}
```

---


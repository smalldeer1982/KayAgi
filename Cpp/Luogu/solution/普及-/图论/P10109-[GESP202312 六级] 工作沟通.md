# [GESP202312 六级] 工作沟通

## 题目描述

某公司有 $N$ 名员工，编号从 $0$ 至 $N-1$。其中，除了 $0$ 号员工是老板，其余每名员工都有一个直接领导。我们假设编号为 $i$ 的员工的直接领导是 $f_i$。

该公司有严格的管理制度，每位员工只能受到本人或直接领导或间接领导的管理。具体来说，规定员工 $x$ 可以管理员工 $y$，当且仅当 $x=y$，或 $x=f_y$，或 $x$ 可以管理 $f_y$。特别地，$0$ 号员工老板只能自我管理，无法由其他任何员工管理。

现在，有一些同事要开展合作，他们希望找到一位同事来主持这场合作，这位同事必须能够管理参与合作的所有同事。如果有多名满足这一条件的员工，他们希望找到编号最大的员工。你能帮帮他们吗？

## 说明/提示

**样例解释 1**

对于第一场合作，员工$3,4$ 有共同领导 $2$ ，可以主持合作。

对于第二场合作，员工 $2$ 本人即可以管理所有参与者。

对于第三场合作，只有 $0$ 号老板才能管理所有员工。

**数据范围**

对于 $50\%$ 的测试点，保证 $N \leq 50$。

对于所有测试点，保证 $3 \leq N \leq 300$，$Q \leq 100$。



------------
2024/1/28 添加一组 hack 数据。

## 样例 #1

### 输入

```
5
0 0 2 2
3
2 3 4
3 2 3 4
2 1 4```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
7
0 1 0 2 1 2
5
2 4 6
2 4 5
3 4 5 6
4 2 4 5 6
2 3 4```

### 输出

```
2
1
1
1
0```

# 题解

## 作者：WsW_ (赞：53)

难度约为橙到黄。

本题解是目前题解区最精简的题解。

---
### 思路
对于每次合作：  
假设合作的员工中有 $x$，那么 $x$ 所有的领导都有可能成为主持者，给这些人的标记加一。  
如果某个人的标记数等于 $m$，说明他是所有合作者的领导，那么他就可以当主持者。  
在所有主持者中找到编号最大的即可。  

可以使用 dfs 来遍历某个人所有的领导。

记得每次处理合作前要清空标记。

时间复杂度为 $O(QN^2)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,m,ans;
int f[300];
int cnt[300];
void dfs(int x){
	++cnt[x];
	if(f[x]!=x)dfs(f[x]);//如果直接领导不是自己，就向上遍历
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++)cin>>f[i];
	cin>>q;
	while(q--){
		memset(cnt,0,sizeof(cnt));
		ans=0;
		cin>>m;
		for(int i=1;i<=m;i++){
			int x;  cin>>x;
			dfs(x);
		}
		for(int i=1;i<n;i++)if(cnt[i]==m)ans=i;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Peiyuan (赞：5)

LCA 问题，但是这道题直接暴力就能过，一开始还想着打搜索和位运算优化呢……

## 思路

简单的暴力思路。每次输入完了以后，从后往前遍历，查找符合要求的，这样的话最先找到符合要求的就是最大的。寻找祖先的部分用递归查找就行了，具体见代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,f[302],a[302];
bool find(int x,int y){ //找x，当前为y
	if(!y&&x) return 0;
	if(f[y]==x) return 1;
	return find(x,f[y]);
}
bool chk(int x){ //判断如果以x为管理员满不满足要求
	for(int i=1;i<=m;i++){
		if(!find(x,a[i])&&a[i]!=x) return 0;
	}
	return 1;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++) scanf("%d",&f[i]);
	scanf("%d",&q);
	while(q--){
		scanf("%d",&m);
		for(int i=1;i<=m;i++) scanf("%d",&a[i]);
		for(int i=n-1;i>=0;i--){ //从后往前遍历
			if(!i) puts("0"); //只能是老板了，特判一下会更快
			else if(chk(i)){
				printf("%d\n",i);
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Loser_Syx (赞：5)

因为题目中给出的是树形结构，所以管辖某个点 $i$ 的点集一定是在以 $0$ 为根到 $i$ 的一条链上的点的集，故可以根据 $f_i$ 倒推出所有管辖 $i$ 的点（即 $i$ 的祖先）。  
然后对于每个询问，通过 $\mathtt{AND}$ 运算得到他们的的公共祖先集，然后找到最大的即可。懒了，用的 `bitset`。  
复杂度是 $O(n^2+\frac{qnm}{\omega})$。

```cpp
int f[1010];
signed main() {
	int n = read();
	for (int i=1;i<n;++i) f[i]=read();
	bitset<301> mp[n];
	for (int i=0;i<n;++i) {
		int x=i;
		mp[i][i]=1;
		do {
			x=f[x];
			mp[i][x]=1;
		} while (x != 0);
	}
	int q = read();
	while (q--) {
		int m = read(), x = read();
		auto ans=mp[x];
		for (int i=2;i<=m;++i) {
			ans&=mp[read()];
		}
		for (int i=n-1;~i;--i) {
			if (ans[i]) {
				write(i, '\n');
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：__O_w_O__ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10109)  

每次询问输出多个点的编号最大的公共祖先，本质上就是 LCA 问题。  

这里提供一种思路：把每个点的祖先全部求出来，然后用数组标记，如果这个点被标记了 $m$ 次，那就说明这个点是所有员工的公共祖先。  

最后输出最大值即可。  

因为这道题的数据比较小，所以这样做的时间复杂度是完全可行的。  

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
int fa[N], vis[N];

void change(int x) {
    vis[x]++;//自己能管理自己，即自己是自己的祖先
    while(x != 0) {
        x = fa[x];//一直向上找祖先
        vis[x]++;//记录这个点作为祖先的个数
    }
}
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        scanf("%d", &fa[i]);
    }
    int q;
    scanf("%d", &q);
    while(q--) {
        int m;
        scanf("%d", &m);
        //注意vis数组要清空
        memset(vis, 0, sizeof(vis));
        for (int i = 1; i <= m; i++) {
            int x;
            scanf("%d", &x);
            change(x);//每输入一个数，进行标记
        }
        int ans = 0;
        //因为是从小到大枚举的，所以不用取max
        for (int i = 1; i < n; i++) {
            if (vis[i] == m) ans = i;
        }
        printf("%d\n", ans);
    }
    return 0;
}

```

---

## 作者：Fp0cY1tZ6Nn4Rd_ (赞：4)

### 思路
这题是树形结构，而且要求编号最大，是树上最近公共祖先。虽然暴力能过，但是这里来说一下倍增优化的树上最近公共祖先。

> 最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。 ——OI Wiki

我们首先想到的肯定就是暴力往上爬，直到它们相遇。但是这个算法在数据量很大的时候就会超时。因此我们有了倍增优化的 LCA。

倍增是什么呢？顾名思义，就是每次翻倍跳。但是在这里，我们不是从小到大跳，而是从大到小跳。

那么这个算法怎么实现呢？我们先保存每个节点的深度和祖先节点。其中 `fath[x][i]` 表示节点 $x$ 的第 $2^i$ 个祖先，可以用 dfs 预处理出来，`from[x]` 表示节点 $x$ 的父节点，`depth[x]` 表示节点 $x$ 的深度。

现在我们就我们可以开始求 LCA 了。第一步，我们要将 $u,v$ 两点跳转到同一深度。计算出 $u,v$ 的深度之差 $y$，对 $y$ 进行二进制的拆分，也就是将 $y$ 次跳转优化为 $y$ 的二进制中所含的 $1$ 的个数次跳转。如果两点相遇则问题解决。第二步，我们从可能的最大步数开始一直进行尝试，不断减半，如果跳到的地方相同就不跳，否则就跳，再一步一步往上调整，直到找到最近公共祖先。

这题求的是多个节点的最近公共祖先，只需要让每个节点与其他节点的最近公共祖先求最近公共祖先再找最大编号即可。

### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
using namespace std;
const int N=5e5+5;
int fath[N][20],from[N],depth[N],n,m,c,k,x,y,q,u,v,t,ans,root=0;
vector<int> G[N];
void getDepth_dfs(int root){
	for(unsigned i=0;i<G[root].size();i++){
		int next=G[root][i];
		depth[next]=depth[root]+1;
		getDepth_dfs(next);
	}
}
void getParents(){
	for(int up=1;(1<<up)<=n;up++)
		for(int i=1;i<=n;i++)
			fath[i][up]=fath[fath[i][up-1]][up-1];
}
int LCA(int u,int v){
	if(depth[u]<depth[v])
		swap(u,v);
	int i=-1;
	while((1<<(i+1))<=depth[u])
		i++;
    for(int j=i;j>=0;j--)
        if(depth[u]-(1<<j)>=depth[v])
            u=fath[u][j];
    if(u==v) return u;
    for(int j=i;j>=0;j--) {
        if(fath[u][j]!=fath[v][j]) {
            u=fath[u][j];
            v=fath[v][j];
        }
    }
    return fath[u][0];
}
int main(){
	ios::sync_with_stdio(false);
	memset(fath,-1,sizeof(fath));
	memset(from,-1,sizeof(from));
	memset(depth,-1,sizeof(depth));
	cin>>n;
	for(int i=1;i<=n-1;i++){
		cin>>x;
		G[x].push_back(i);
		fath[i][0]=x;
		from[i]=x;
	}
	depth[root]=1;
	getDepth_dfs(root);
	getParents();
	cin>>m;
	while(m--){
		cin>>c>>k;
		t=k;c--;
		while(c--){
			cin>>k;
			t=LCA(t,k);
		}
		ans=t;
		while(t!=0){
			t=fath[t][0];
			ans=max(ans,t);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Igallta (赞：3)

这道题我看大家好像都提到了 LCA 这个东西？笑死我了我是蒟蒻，只会写两个节点的 LCA。

就在我以为没救了的时候，我一看 $3 \leqslant N \leqslant 300$，哇！貌似 $N^2\log N$ 都能过！于是我就开启了我的暴力：

这道题我的思路就是把每个员工的领导全部列出来，然后放进集合，最后做交集。

这道题由于是树形结构，所以我使用了 `map` 存储每一个人的上司。

有人就要问了：交集怎么写啊，网上搜的竟然写了 $80+$ 行！

其实交集有一个函数叫做 `set_intersection`，这个东西可以把两个序列的交集存放在另一个序列里面。需要注意的是：交集的两个序列**必须是从小到大排序的**，所以我们也要对我们用到的参与交集的序列进行从小到大的排序。

由于要求我们输出最大的，我们是从小到大排序的，直接输出 `ans.back()` 就行了。

这样，听起来是不是很简单？我们一起梳理一下步骤：

对于每一次询问：

先清空 $ans$。

然后将第一个员工的所有领导放进答案集合 $ans$ 中，这是一个特例。为了方便接下来对它进行交集操作。然后对 $ans$ 做从小到大的排序。因为后面交集是保证从小到大的，所以不必在遍历员工的时候对 $ans$ 进行排序。

接下来对其他员工进行遍历：

对于第 $i$ 个员工：都将领导存放至 $tmp$ 中。然后对 $tmp$ 做从小到大的排序。最后让 $tmp$ 对 $ans$ 做并集，存放在 $c$ 中。然后让 $ans=c$。

最后一定记得清空 $tmp$ 和 $c$。

循环结束后输出 `ans.back()` 即可。

```cpp
/****************************************
作者:
版权:
日期:
*****************************************/
#include<bits/stdc++.h>
#define LL k<<1
#define RR k<<1|1
#define int long long
using namespace std;
const int N=301;
int n,T;
map<int,int>mp;
vector<int>ans,tmp,c; 
void dfs1(int x){
	if(x==0)return;//如果是老板，那么跳出循环
	ans.push_back(x);
	dfs1(mp[x]);
}
void dfs2(int x){
	if(x==0)return;
	tmp.push_back(x);
	dfs2(mp[x]);
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n-1;i++){
		int t;
		cin>>t;
		mp[i]=t;//记录上司
	}
	cin>>T;
	while(T--){
		int q,t;
		cin>>q>>t;
		ans={0};//先传老板
		dfs1(t);//获得所有领导
		--q;			
		sort(ans.begin(),ans.end());//排序
		while(q--){
			cin>>t;
			tmp={0};//一样的，先传老板
			dfs2(t);//获得所有领导

			sort(tmp.begin(),tmp.end());
			set_intersection(ans.begin(),ans.end(),tmp.begin(),tmp.end(),back_inserter(c));//并集
			ans=c;//赋值
			c.clear();//多测不清空，爆零两行泪！
		}
		cout<<ans.back()<<'\n';//输出最后一位
	}
	return 0;
}
```

---

## 作者：CleverRaccoon (赞：3)

## 题目描述

某公司有 $N$ 名员工，编号为 $0$ 到 $N-1$，形成树形结构，其中 $0$ 号为老板。每个员工的直接领导为 $f_i$。每个员工可以被自己管理或被自己的所有直接领导和间接领导管理。

有一些人开展合作，想找一个可以管所有参与合作的人且编号最大的主持。

## 思路

一个很简单的思路。

数据范围小，按题意进行模拟即可。

可以用一个 `vector` 来记录每个人的直接下属。然后通过深度优先搜索找到每个人的所有直接下属和间接下属，并用 `unordered_map` 存下来（不使用 `map` 是因为避免 $\log$ 的出现），代码如下：

```cpp
unordered_map<int,int> v[310];
void dfs(int c,int x){
    for(int i=0;i<t[x].size();i++){
        v[c][t[x][i]]=1;
        dfs(c,t[x][i]);
    }
}
```

主函数中的调用：

```cpp
for(int i=0;i<n;i++){
    v[i][i]=1;
    dfs(i,i);
}
```

求出这个后，对于每次询问，直接从 $N-1$ 到 $0$ 枚举每个人（倒着枚举是因为要求出编号尽可能大的），利用预处理出来的每个人的下属有谁，判断其下属是否涵盖了所有当前询问中的要开展合作的人，如果第 $i$ 个人涵盖了，就直接输出 $i$ 即可。

## 代码

完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[310],a[310];
vector<int> t[310];
unordered_map<int,int> v[310];
void dfs(int c,int x){
    for(int i=0;i<t[x].size();i++){
        v[c][t[x][i]]=1;
        dfs(c,t[x][i]);
    }
}
int main(){
    cin>>n;
    f[0]=-1;
    for(int i=1;i<n;i++){
        cin>>f[i];
        t[f[i]].push_back(i);
    }
    for(int i=0;i<n;i++){
        v[i][i]=1;
        dfs(i,i);
    }
    int q;
    cin>>q;
    while(q--){
        int m;
        cin>>m;
        for(int i=0;i<m;i++)cin>>a[i];
        int res=-1;
        for(int i=n-1;i>=0;i--){
            bool flg=true;
            for(int j=0;j<m;j++){
                if(!v[i].count(a[j])){
                    flg=false;
                    break;
                }
            }
            if(flg){
                res=i;
                break;
            }
        }
        cout<<res<<"\n";
    }
    return 0;
}
```

这次考了九十二分，纪念一下。


---

## 作者：CuteGirlGC (赞：3)

## Solution
首先看题，树形结构，需要找到一个可以同时统领所有人的领导。

可以将领导看作祖先，答案就是每一个工作中所有人的公共祖先。还要求编号最大，所以就是最近公共祖先的最大编号祖先，预处理即可。

然后直接套用模板就行了。

## Code
```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kMaxN = 5e5 + 1, kMaxL = 21;

int n, m, rt;
struct V {
  int f[kMaxL], d, maxn;
  vector<int> g;
} v[kMaxN];

void Walk(int x, int f, int maxn) {
  v[x].f[0] = f, v[x].d = v[f].d + 1, v[x].maxn = max(maxn, x);
  for (int i : v[x].g) {
    if (i != f) {
      Walk(i, x, max(maxn, x));
    }
  }
}

void CalcF() {
  for (int j = 0; j < kMaxL - 1; j++) {
    for (int i = 1; i <= n; i++) {
      v[i].f[j + 1] = v[v[i].f[j]].f[j];
    }
  }
}

int LCA(int x, int y) {
  if (v[x].d > v[y].d) {
    swap(x, y);
  }
  for (int i = 0; i < kMaxL; i++) {
    if (((v[y].d - v[x].d) >> i) & 1) {
      y = v[y].f[i];
    }
  }
  for (int i = kMaxL - 1; i >= 0; i--) {
    if (v[x].f[i] != v[y].f[i]) {
      x = v[x].f[i], y = v[y].f[i];
    }
  }
  return x == y ? x : v[x].f[0];
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i < n; i++) {
    int u;
    cin >> u;
    v[u].g.push_back(i);
  }
  Walk(0, 0, 0);
  CalcF();
  int q, c, s;
  for (cin >> q; q; q--) {
    cin >> c >> s;
    c--;
    int L = s;
    for (; c; c--) {
      cin >> s;
      L = LCA(L, s);
    }
    cout << v[L].maxn << '\n';
  }
  return 0;
}
```

---

## 作者：zsh_haha (赞：2)

### 题目大意

已知某公司有 $N$ 个人，其中 $0$ 号员工是老板，也是管理级别最高的人，只有自己可以管理自己，现给出 $1\sim N-1$ 号员工的管理者。又给出若干个人，问这几个人的公共管理者中编号最大的人的编号是多少。

### 思路讲解

这题是一道经典的 LCA（最近公共祖先），不过因为数据范围小，所以可以用暴力的方法做，不需要什么技巧。

>Q1：我们如何求出一些人的最近公共管理者呢？
>
>A1：设有 $k$ 个人，其中第 $i$ 个人的编号为 $a_i$。
>
>我们可以设 $x$ 为 $a_1$ 和 $a_2$ 的最近公共管理者，再把 $x$ 改为 $x$ 和 $a_3$ 的最近公共管理者，再把 $x$ 改为 $x$ 和 $a_4$ 的最近公共管理者，以此类推，这样我们就得到了 $a_0,a_1,a_2,\dots,a_k$ 的最近公共管理者。

>Q2：我们如何求出某两个人的最近公共管理者呢？
>
>A2：我们设这两个人的编号分别为 $x,y$，设公司中编号为 $i$ 的员工的直接/间接管理者数为 $d_i$。
>
>首先，如果 $d_x\ne d_y$，我们可以让直接/间接管理者数更大的那个人往更高层次跳，直到 $d_{x}=d_y$。
>
>然后，我们同时让这时的 $x,y$ 同时往更高层次跳，直到 $x=y$，这时候的 $x$ 或 $y$ 就是原来 $x,y$ 的最近公共管理者。
>
>如果不明白原理的的同学可以自己画图理解一下，这很简单，相信聪明的你很容易就理解了。

这时候还需要考虑一个问题，就是题目中的：

>如果有多名满足这一条件的员工，他们希望找到编号最大的员工。

我们知道，如果一个员工 $x$ 是某些员工的最近公共管理者，那么员工 $x$ 的直接/间接管理者员工 $y$ 也使这些员工的公共管理者。所以我们得到某些员工的最近公共管理者 $x$ 时，我们可以遍历每一个 $x$ 的直接/间接管理者员工，看看谁的编号最大。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[301],d[301];
int find(int n){
    if(f[n]==n){
        return 1;
    }
    return find(f[n])+1;
}
int lca(int x,int y){//找某两个人的最近公共管理者
    while(d[x]<d[y]){//使dx=dy
        y=f[y];
    }
    while(d[x]>d[y]){//使dx=dy
        x=f[x];
    }
    while(x!=y){//使x=d
        x=f[x];
        y=f[y];
    }
    return x;
}
int main(){
    int n,m,k,x,y;
    cin>>n;
    f[0]=0;//老板的管理者就是自己
    for(int i=1;i<n;i++){
        cin>>f[i];
    }
    for(int i=0;i<n;i++){
        d[i]=find(i);//求某个员工的直接/间接管理者人数
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>k>>x;
        y=x;
        for(int i=2;i<=k;i++){
            cin>>x;
            y=lca(x,y);//找这些员工的最近公共管理者 y
        }
        int ans=y;
        while(f[y]!=y){
            y=f[y];
            ans=max(y,ans);//比较每个可以管理 y 的员工的编号，取最大值
        }
        cout<<ans<<endl;//输出结果
    }
    return 0;
}
```

---

## 作者：zzx114514 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P10109)

# 题目大意
求一棵树上给定节点的最近公共祖先。

# 解题思路
看到最近公共祖先，肯定用 `LCA`，但注意到 $3\le N\le 300$，于是~~不会写~~懒得写 `LCA`，写了个 `dfs`，原理是先预处理，给以每个节点为根节点的子树打上记号，到时候直接看这个节点下被打上记号的节点是否包含所有给定节点即可，若包含则记录答案，否则该节点不合格。  

### 注意事项：
1. 自己也是自己的祖先，需要给自己打上标记。
2. 题目要求编号最大的节点，答案要取最大值。

# 完整代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,f[305],q,m,a[305],ans,sum; 
vector<int> t[305];
bool vis[305][305],flag;
void dfs(int id,int x)//给被领导者打标记 
{
	for (int i=0;i<t[x].size();i++) vis[id][t[x][i]]=true;
	for (int i=0;i<t[x].size();i++) dfs(id,t[x][i]);
}
int main()
{
	cin>>n;
	for (int i=1;i<n;i++)//建树 
	{
		cin>>f[i];
		t[f[i]].push_back(i);
	}
	for (int i=0;i<n;i++) dfs(i,i);//打标记 
	for (int i=0;i<n;i++) vis[i][i]=true;//注意自己也是自己的祖先，即自己领导自己 
	
	cin>>q;
	while(q--)
	{
		ans=0;//记得赋初始值 
		cin>>m;
		for (int i=1;i<=m;i++) cin>>a[i];
		for (int i=0;i<n;i++)//判断被打上标记的员工是否包含所有需要合作的员工 
		{
			flag=true;
			for (int j=1;j<=m;j++)
				if (!vis[i][a[j]]) flag=false;
			if (flag) ans=max(ans,i);//注意题目要求编号最大的 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：linjinkun (赞：1)

最简单的解法（搜索）

把上下级的关系想象成一个图，每问一次，就从 $n$ 号员工到 $1$ 号员工（老板）每个都试一遍，然后 $\operatorname{dfs}$ 求这个员工能管理的所有员工，最后判断。

代码：
```cpp
//员工编号从1~n的代码
#include<bits/stdc++.h>
using namespace std;
int a[305];
vector<int>e[305];
int vis[305];
void dfs(int x)//标准的搜索
{
    for(int i = 0;i<e[x].size();i++)
    {
        if(vis[e[x][i]] == 0)
        {
            vis[e[x][i]] = 1;
            dfs(e[x][i]);
        }
    }
}
int main()
{
    int n,q;
    scanf("%d",&n);
    for(int i = 2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        e[x+1].push_back(i);//转换成图，因为是从1~n，所以x+1
    }
    scanf("%d",&q);
    for(int i = 1;i<=q;i++)
    {
        int m;
        scanf("%d",&m);
        for(int j = 1;j<=m;j++)
        {
            scanf("%d",&a[j]);
            a[j]++;//因为是从1~n，所以a[j]++;
        }
        for(int j = n;j>=1;j--)
        {
            if(j == 1)//这份代码1号员工是老板
            {
                printf("0\n");
                break;
            }
            memset(vis,0,sizeof(vis));//清空标记
            vis[j] = 1;//可以管理自己
            dfs(j);
            bool flag = 1;
            for(int k = 1;k<=m;k++)
            {
                if(vis[a[k]] == 0)//如果j号员工无法管理a[k]号员工，break
                {
                    flag = 0;
                    break;
                }
            }
            if(flag == 1)
            {
                printf("%d\n",j-1);//由于与题目的编号相差1，所以-1
                break;
            }
        }
    }
    return 0;
}
```


---

## 作者：int32 (赞：0)

题目给出的公司结构是一颗以 $0$ 为根节点的树，因此对于每个合作询问的答案即为参与这次合作的员工的**编号最大的公共祖先**。

考虑先求出这些结点的最近公共祖先，再从它向父亲暴力跳到根，找其中最大编号的结点即为答案。

由于本题数据范围很小，求 LCA 可以使用暴力，复杂度 $O(nmq)$。

```cpp
//
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
const int S=25;
int n, m, T;
int dep[N];
int fa[N][S];
int lg[N];
int head[N], cntedge;
struct node{int v, nxt;}e[N<<1];
void edge(int U, int V){
    e[++cntedge]=(node){V,head[U]};
    head[U]=cntedge;
}
void dfs(int u, int f){
    dep[u]=dep[f]+1;
    for(int i=1;i<=lg[dep[u]];i++)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=head[u];i;i=e[i].nxt){
        int to=e[i].v;
        if(to!=f) dfs(to,u);
    }
}
int lca(int x, int y){
    if(dep[x]<dep[y]) swap(x,y);
    // while(dep[x]>dep[y])
    //     x=fa[x][lg[dep[x]-dep[y]]-1];
    // if(x==y) return x;
    // for(int i=lg[dep[x]]-1;i>=0;i--)
    //     if(fa[x][i]!=fa[y][i]){
    //         x=fa[x][i];
    //         y=fa[y][i];
    //     }
    // return fa[x][0];
    while(x!=y){
        if(dep[x]>=dep[y]) x=fa[x][0];
        else y=fa[y][0];
    }
    return x;
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        lg[i]=lg[i-1]+(1<<lg[i-1]==i);
    for(int i=1;i<n;i++){
        cin>>fa[i][0];
        edge(fa[i][0],i);
        edge(i,fa[i][0]);
    }
    dfs(0,0);
    cin>>T;
    while(T--){
        int ans=0;
        cin>>m;
        int _;
        cin>>_;
        int l=_;
        for(int i=2;i<=m;i++){
            cin>>_;
            l=lca(l,_);
        }
        ans=l;
        while(l){
            ans=max(ans,fa[l][0]);
            l=fa[l][0];
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---


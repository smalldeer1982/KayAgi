# [蓝桥杯 2025 省 Python B] 书架还原

## 题目描述

在一个偏远的图书馆里，有个书架上放着 $n$ 本书，每本书上都标有一个从 $1$ 到 $n$ 的唯一编号。

按照规矩，这些书应该按编号从小到大依次排列：$1$ 号书位于最左端，$2$ 号书紧随其后，以此类推，直到 $n$ 号书在最右端。这样的顺序不仅看起来整齐，也方便读者快速找到想借的书。

可昨天店里人来人往，借书还书忙得不可开交，书架上的顺序出现了错乱。现在，书架上的书变成了 $a = (a_1, a_2, \ldots, a_n)$，其中 $a_i$ 表示第 $i$ 个位置上的书编号。

管理员决定动手整理书架，但时间有限，他希望用最少的操作把书的顺序恢复到正确的排列。每次操作，他可以挑选书架上任意两本书，交换它们的位置。例如，如果当前排列是 $(3, 1, 2)$，他可以交换第 $1$ 本和第 $2$ 本，得到 $(1, 3, 2)$，再交换第 $2$ 本和第 $3$ 本，得到 $(1, 2, 3)$。

你的任务是帮助管理员计算，最少需要进行多少次操作，才能让书架上的书的编号排列变为 $(1, 2, \ldots, n)$。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 10^3$，$1 \leq a_i \leq n$，$a_1, a_2, \dots, a_n$ 各不相同；
- 对于所有评测用例，$1 \leq n \leq 10^6$，$1 \leq a_i \leq n$，$a_1, a_2, \dots, a_n$ 各不相同。


## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
2```

# 题解

## 作者：Dicer_L (赞：5)

## solution

### 题意

有 $1$ 到 $n$ 一共 $n$ 个数字，现在顺序是乱的。要求对这 $n$ 个数字进行排序，通过交换每次交换两个任意位置的数字，求最小交换次数。

### 注意点

> 他可以挑选书架上任意两本书，交换它们的位置。

任意很重要。

> $1 \leq n \leq 10^6$

这代表如果我们使用 $\mathcal{O(n^2)}$ 的算法将会时间超限。我们需要更优的算法。

### 思路

与冒泡排序相似，每次找到当前未排好序的最小值，与自己值的位置上的值互换位置。

如果找最小值位置的操作每次都遍历数组一遍，时间明显挡不住。因此进行预处理，不仅记录每个位置的值，还记录每个值的位置。

这样的话，每次进行交换操作的时候，两种记录方式的值都要改变。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1000005;
int n,w[N],ag[N],ans;
signed main(){
    ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i];
		ag[w[i]]=i;
	}
	for(int i=1;i<=n;i++){
		if(w[i]!=i){
			ag[w[i]]=ag[i];
			swap(w[i],w[ag[i]]);
			ag[i]=i;
			ans++;
		}
	}
	cout<<ans;
}
```

```python
n = int(input())
w = list(map(int, input().split()))
w = [0] + w 
ag = [0] * (n + 2)  # 初始化ag数组
for i in range(1, n + 1):
    ag[w[i]] = i  # 记录每个数值的位置
ans = 0
for i in range(1, n + 1):
    if w[i] != i:
        x = w[i]
        pos = ag[i]
        ag[x] = pos  # 更新原数值的位置信息
        w[i], w[pos] = w[pos], w[i]  # 交换元素
        ans += 1
        ag[i] = i  # 当前数值i的位置已正确
print(ans)
```

---

## 作者：wenqinghua1001 (赞：4)

## 思路

我一看到这道题，认为是再求逆序对的个数，打了一个代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000010;
int ans=0;
int a[N],b[N],n;
void work(int l,int mid,int r){
	int k=0,i=l,j=mid+1;
    while(i<=mid&&j<=r){
        if(a[i]<=a[j])
			b[++k]=a[i++];
        else{
            b[++k]=a[j++];
            ans+=mid-i+1;
        }
    }
    while(i<=mid)
		b[++k]=a[i++];
    while(j<=r)
		b[++k]=a[j++];
    for(int i=l;i<=r;i++)
		a[i]=b[i-l+1];
}
void msort(int l,int r){
    if(l>=r) return ;
    int mid=(l+r)/2;
    msort(l,mid);
    msort(mid+1,r);
    work(l,mid,r);
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)
		cin>>a[i];
    msort(1,n);
    cout<<ans;
    return 0;
}
```

~~[逝世的测试信息](https://www.luogu.com.cn/record/215719470)~~。

我的天哪！我仔细理了一下题目，发现不是在求逆序对。

这道题要求书架上的书恢复到正确排列所需的最少操作次数，那么肯定要最优解，数据范围是 $1 \le N \le 10^6$，$O(N^2)$ 肯定超时。

首先，第 $i$ 个位置的数不是 $i$，一定要交换。换句话说，不该在相应位置的数肯定要交换，还要最优。那就要把两个都不符合条件的两个数交换位置，都变成正确的。

对重要结论的证明：我们发现这道题中不该在相应位置的位置，刚好形成了一个环，而且恰好每个环使用了 $s−1$ 次边，交换了 $s-1$ 次。时间复杂度是 $O(N)$。

## 代码

### C++ 代码

[AC 记录](https://www.luogu.com.cn/record/215721666)

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[10000001];
int b[10000001];
signed main(){
    int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]; 
	for(int i=1;i<=n;i++)
		b[a[i]]=i;
	int ans=0;
	for(int i=1;i<=n;i++){
		if(a[i]!=i){
			// 不符合条件。
			b[a[i]]=b[i];
			swap(a[i],a[b[i]]);
			// 把不符合条件的两个数位置交换。
			// 保证最优。 
			ans++;
		}
	}
	cout<<ans;
    return 0;
}
```

### Python 代码

[AC 记录](https://www.luogu.com.cn/record/216088226)

```python
n=int(input())
nums=list(map(int,input().split()))
ans=0
for i in range(n):
    while nums[i]!=i+1 :
    	# 不符合条件。
        j=nums[i]-1
        tmp=nums[j]
        nums[j]=nums[i]
        nums[i]=tmp
        # 把不符合条件的两个数位置交换。
	    # 保证最优。 
        ans+=1
print(ans)
```

---

## 作者：SafariMo (赞：3)

考虑如下操作方式：

- 每次找到 $i$ 所在的位置 $p$，若 $a_p \ne a_i$，则交换 $a_i , a_p$。

下证明其正确性。

首先我们将 $p_i \leftarrow i$ 连边，$p_i$ 表示 $i$ 的位置。

现在由于 $p_i , i$ 互不相同，则每个点入度和出度均为 $1$，构成了若干个环，每个环对答案的贡献为 $l - 1$，$l$ 为点数，因为一个环要走 $l - 1$ 个点才能到正确的点，这样已经做完了。

但是为什么开头的算法也是正确的？

发现和在环上走没有区别，因为恰好每个环使用了 $l - 1$ 次边。

最后，可以简单的进行 $\mathcal O(n)$ [实现](https://www.luogu.com.cn/record/213587257)。

---

## 作者：ZYX0716 (赞：2)

[这题](https://www.luogu.com.cn/problem/P12176)主要的思想是**贪心**，与图论关系不大。

## 题目大意:

给你一个由 $1$ 到 $n$ 组成的序列，保证这 $n$ 个数各不相同。请你求出将其从小到大排序的最少交换次数。

## 算法分析:

先看数据范围， $n$ 的最大值是 $10^6$，暴力不可取。

考虑将无序数列中，每本书的下标记录下来，再 $O(N)$ 扫一遍，找到放错的那些书。若第 $i$ 本书放错位了，则将其应该在的位置上的书与其交换。

思路明确后，代码很简短。

## AC Code:


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],b[1000005],ans;
int main(){
	scanf("%d",&n);//书架上有n本书。
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);//第i个位置上的书的编号。
		b[a[i]]=i;//记录其下标。
	}for(int i=1;i<=n;i++){
		if(b[i]!=i){//如果第i本书放错了，则需要调换一次。
			b[a[i]]=b[i];
			swap(a[b[i]],a[i]);
			ans++;
		}
	}
	printf("%d",ans);//输出最小交换次数。
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

## 主要意思:

这道题目描述了一个书架上原本应该按编号从小到大排列的书籍（编号从 $1$ 到 $n$），但由于借还书的繁忙，书籍的顺序被打乱了。现在需要将这些书重新整理回正确的顺序（即 $1,2,\cdots,n$），每次操作可以交换任意两本书的位置。我们的任务是计算出最少需要多少次交换操作才能完成整理。

## 思路:

这道题的核心是通过环分解来计算最少交换次数。我们将当前排列分解为若干个环，每个环内的元素需要通过交换操作才能归位。最少交换次数等于所有环的（环大小 $-1$）之和。


## [AC](https://www.luogu.com.cn/record/214316453) 代码:

```
#include <bits/stdc++.h>
using namespace std;
int a[1000005],bbj[1000005];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (!bbj[i]) {
            int ct = i;
            int bj = 0;
            while (!bbj[ct]) {
                bbj[ct] = 1;
                ct = a[ct];
                bj++;
            }
            if (bj > 1) {
                sum += (bj - 1);
            }
        }
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：Dream_poetry (赞：2)

### 思路：

设 $p_i$ 表示 $i$ 在 $a$ 中所在的位置。

直接模拟，从 $1$ 到 $n$ 按顺序判断，若摆好则跳过，否则交换 $a_i,a_{p_i}$，并将 $p_{a_i}$ 修改为 $p_i$。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000005];
int ans;
int p[1000005];

signed main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		p[a[i]]=i;
	}
	for (int i=1;i<=n;i++){
		if (a[i]!=i){
			p[a[i]]=p[i];
			swap(a[i],a[p[i]]);
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zlqwq (赞：1)

小模拟。

显然，元素的位置可以构成环。


设环有 $n$ 个点，交换它显然需要 $n-1$ 次代价。

所以开一个数组 $vis$ 来存储是否经过，找到一个环加上其贡献即可。

最终答案显然为所有环贡献和。



```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; ++i) {
		cin >> a[i];
	}
	
	vector<bool> visited(n, false);
	int ans = 0;
	
	for (int i = 0; i < n; ++i) {
		if (!visited[i] && a[i] != i + 1) {
			int cycle_size = 0;
			int current = i;
			do {
				visited[current] = true;
				++cycle_size;
				current = a[current] - 1;
			} while (current != i);
			ans += cycle_size - 1;
		}
	}
	
	cout << ans << endl;
	
	return 0;
}
```

---

## 作者：wangjunyee (赞：1)

### 题意简述
有一串乱序的编号，每个数字最终都要回到自己正确的位置。

### 思路
先说一下正确的操作：从第一个位置开始检查，如果当前数字**不在正确位置**，就找到它应该去的位置，把这两个位置的数字**交换**。

为什么这是正确的？一旦某个数字归位，算法不会再动它。所有交换只针对未归位的数字，确保**每一步都有效**。

下面进行严谨一点的证明：

将每个数字都转化为一个点，给每个点都添加一个有向边，指向它正确的位置，则这个图一定是由多个环组成的。

如数字 $3$ 现在在位置 $1$，数字 $1$ 在位置 $2$，数字 $2$ 在位置 $3$，这三个数字就形成了一个环：$3→1→2→3$。每个数字都在“指向”它正确的位置，但彼此卡住了。可以自己举一些例子，理解一下。

那么问题就变成了算法如何通过最少的交换操作解开环。我们发现每个环的最小交换次数为 $l-1$，$l$ 为环的点数。

考虑使用数学归纳法证明：

- 环长为 1：元素已在正确位置，交换次数为 $0$。
- 环长为 2：交换两个元素即可还原，次数为 $1$。
- 假设环长为 $k$ 时，最少交换次数为 $k-1$。

所以对于一个环长为 $k+1$ 的环，在环中任选两个元素交换，交换后环能被分解为两个更小的环，其长度分别为 $m$ 和 $n$，且有 $m+n=k+1$。

由归纳假设，两个小环的交换次数分别为 $m-1$ 和 $n-1$，加上当前交换的 $1$ 次，总次数为 $(m-1)+(n-1)+1=k$，即 $(k+1)-1$，与归纳假设一致。

所以得证：单个环的最小交换次数为环长减一。算法每次交换都严格对应环的拆解，没有多余操作，从而算法正确。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e6+5;

int n,a[N],cnt;
int v[N];//记录每个值的当前位置

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		v[a[i]]=i;
	}
	
	for(int i=1;i<=n;i++)
		if (a[i]!=i){
			v[a[i]]=v[i];
			int t=a[i];
			a[i]=a[v[i]];
			a[v[i]]=t;
			cnt++;
		}
	
	printf("%d\n",cnt);
	
	return 0;
}
```

---

## 作者：dashabi35 (赞：0)

一共有 $n$ 个数，每输入一个数就可以记录一下输入的数 $i$ 的位置。

随后，可以进行模拟排序：

如果一个数在它应该在的位置上，那么就别动它（都排好序了再排就是吃饱了撑了）。

否则，就让它和它本应该在的地方上的数交换。

显然，按照这样排序一定可以完成排序，接下来考虑是否为最优解。

显然，想要为最优解，那就要减少排序的次数，而一次最多只能能影响到两个数，若能一次能完成两个未完成排序的数的排序，那一定为最优解。

而用这种思路若一个数它原本位置所在的数变到它所在的这个位置可以变得有序，那显然是符合最优解的。

但显然，如果去主动创造这种结构会更快，但用上述如果可以的话，迟早是可以的。

所以综上，用这种方法是最优解。

那么代码就很好搞了。

**AC CODE:**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000005],p[1000005];
int ans;

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		p[a[i]]=i;
	}
	for(int i=1;i<=n;++i)
	{
		
		if(a[i]!=i) 
		{
			p[a[i]]=p[i];
			++ans;
			swap(a[i],a[p[i]]);
		}
	}
	printf("%d",ans);
}
```

---

## 作者：Noob_Oler (赞：0)

## 题目大意：

管理员要整理书架，且时间有限，希望用最少的操作次数将书恢复到正确顺序。每次操作允许挑选书架上任意两本书交换位置。

要求帮助管理员计算最少需要进行多少次这样的交换操作，能使书架上书的编号排列变为 $1,2,\dots,n$。

## 解法：

可以每次找到当前未排好序的最小值，与自己的值的位置上的值互换位置。

即，交换 $a_i$ 与 $a_{{id}_i}$。

还要把 $id_{a_i}$ 的值改为 $id_i$。

$id$ 数组要预处理，记录每个值的位置。


## Code
```
#include <bits/stdc++.h>
using namespace std;
int a[1000005],id[1000005],cnt = 0;
int main()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        id[a[i]] = i;//预处理
    }
    for(int i = 1; i <= n; i++)
    {
        if(id[i] != i)
        {
            cnt++;
            id[a[i]] = id[i];
			swap(a[i],a[id[i]]);
			id[i] = i;
        }
    }
    cout << cnt;//cnt是次数
    return 0;
}
```
请不要抄袭本题解代码

---


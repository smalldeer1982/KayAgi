# 【深基18.例3】查找文献

## 题目描述

小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(1\le n\le10^5)$ 篇文章（编号为 $1$ 到 $n$）以及 $m(1\le m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 $X\to Y$ 表示文章 $X$ 有参考文献 $Y$。不保证编号为 $1$ 的文章没有被其他文章引用。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇（因此你可能需要先排序）。

## 样例 #1

### 输入

```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8```

### 输出

```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8 ```

# 题解

## 作者：yangrunze (赞：761)

想必大家应该非常精通两种搜索算法——也就是**深度优先搜索dfs**和**广度优先搜索bfs**了，这时好奇的宝宝们也许会问啦：深度和广度到底还有什么意思呢？其实它们还有另外一层含义——**图的遍历**。

相信在座的各位应该知道图是个啥玩意，应该也知道“遍历”是啥：所谓“**遍历**”，就是**把图上的每个顶点都找一遍**呗！但是要找可不能瞎找，要不会把自己找晕，咱这里就有两种“防晕”的好方法！正所谓“**举例是理解的试金石**”，咱就拿样例来说！

![戳我看样例](https://cdn.luogu.com.cn/upload/image_hosting/mrqi5io9.png)

### 方法A

咱们可以一步一步向前去走：

从1出发，先去最小的2

然后从2出发，沿路到5

再从5出发......咦？没路了？好吧那就回去到2吧

出发点又到了2，这时候5已经到过啦，那就去6

6又没路了，好办！回到2，由于2通往的5和6都来过了，所以再回去到1，这时候1的路中2已经走过了，没走过的最前一个是3，那就在走到3

........

就这样一步一步走过去，可以得到顺序：
```
1 2 5 6 3 7 8 4
```

这种方法就是一步一步去尝试，先从一条路走到黑，走完了就回去找另一条，总结成7个字就是“**不撞南墙不回头**”，有没有发现跟我们的“**深度优先搜索**”迷之相似？？？所以，我们叫它“**图的深度优先遍历**”

### 方法B

~~想用这种方法，你需要掌握一项技能——分身术~~

还是从1出发，咱先把能走的都走一遍，依次到达2，3.4

1的走完了，咱就从下一个没往下走的地点开始，也就是从2出发，到达5，6

2的也走完了，目前最靠前的还没往下走过的点是3，好的，从3到达7，8

然后下一个没往下“扩展”的地点是4，哇，这时候7，8都已经走过了呢，那就走完啦

所以我们可以得到顺序：
```
1 2 3 4 5 6 7 8
```
总之就是把每个没有向下走过的地方都走一遍，如果你看懂了，你可以发现这个方法和“**广度优先搜索**”算法很像，我们就叫它“**图的广度优先遍历**”



------------
两种遍历方法都讲完了，接下来咱们考虑的就只有细节问题了，首先，这个题数据范围那么大，**用邻接矩阵存肯定是会爆的**，那咱们就用一种新的方法。

首先，我们**用一个结构体vector（为了节省空间，咱用vector来存）存储每个边的起点和终点**，然后**用一个二维vector（也就是一个vector数组）存储边的信息**。

这个存储方法可能有点难理解，不过其实也没那么难：**我们用$e$[$a$][$b$]=$c$，来表示顶点$a$的第$b$条边是$c$号边**。咱举个栗子，还是拿样例说吧：

```
8 9
1 2 //0号边（由于vector的下标是从0开始的，咱就“入乡随俗”，从0开始）
1 3 //1号边
1 4 //2号边
2 5 //3号边
2 6 //4号边
3 7 //5号边
4 7 //6号边
4 8 //7号边
7 8 //8号边
```
最后二维vector中的存储会如下所示：
```
0 1 2 //1号顶点连着0、1、2号边
3 4	//2号顶点连着3、4号边
5	//3号顶点连着5号边
6 7 //4号顶点连着6、7号边
	//5号顶点没有边
	//6号顶点没有边
8	//7号顶点连着8号边
	//8号顶点没有边

```
看是不是对上号了？这个方法比较好懂，又节省空间，是个好方法。*（此方法由大佬vectorwyx发明）*

最后，别忘了题目要求：“**如果有很多篇文章可以参阅，请先看编号较小的那篇**”

那就**排序**呗！咱们按照题目要求，**按照终点从小到大排列，如果终点相同按起点从小到大排列** 注意我们说的第几号边是指排序后的序号


```cpp
//准备工作：
struct edge{
	int u,v; //记录边的结构体，u起点，v终点
};
vector <int> e[100001];  //存具体信息的二维vector
vector <edge> s;  //存边的结构体vector数组
bool cmp(edge x,edge y){  //排序规则
	if(x.v==y.v)  //v相同按u排序
	return x.u<y.u;
	else return x.v<y.v;  //否则按v从大到小排序
}

```

```cpp
//main函数里的内容	
	int n,m;  
	cin>>n>>m; //n个顶点，m条边，没啥好说的
	for(int i=0;i<m;i++){ //m条边
		int uu,vv;  
		cin>>uu>>vv;  
		s.push_back((edge){uu,vv}); //初始化存边的s数组  
	}
	sort(s.begin(),s.end(),cmp);
        //优雅地排个序（别忘了vector的操作：start返回第一个（指针）,end返回最后一个（指针））
	for(int i=0;i<m;i++)
		e[s[i].u].push_back(i); 
	//初始化e数组，在e[s[i].u]（也就是i号边的起点s[i].u连接的边的数组）中存入i号边
```
接下来就是遍历的过程，由于你们对两种搜素的过程那么熟悉，一定可以看懂下面的~~没有注释的~~代码！
（骗你们的，像我这么心地善良，怎么可能不给你们加注释）

```cpp
bool vis1[100001]={0},vis2[100001]={0};
//vis数组用来判断有没有遍历过这个顶点，vis1用于深搜，vis2用于广搜（我才不会告诉你我懒得memset呢）
```
```cpp
void dfs(int x){  //dfs——深度优先遍历，x表示当前遍历到x号顶点
	vis1[x]=1;  //这个顶点已经走过啦！
	cout<<x<<" "; //输出~
	for(int i=0;i<e[x].size();i++){ //一条一条边去搜索
		int point=s[e[x][i]].v;  //找出当前这条边（也就是e[x][i]）的终点
		if(!vis1[point]){   //如果这个点没走过
			dfs(point); //那就接着往下搜吧！
		}
	}
}
```

```cpp
void bfs(int x){   //bfs——广度优先遍历（x依然是第几号顶点，不过既然不递归其实传这个参数也没啥用）
	queue <int> q;  //没有队列那还叫广搜吗
	q.push(x);  //先把第一个顶点推进去，输出，标记访问过
	cout<<x<<" ";  
	vis2[x]=1; 
	while(!q.empty()){   //广搜板子，上！
		int fro=q.front();  //把队首取出来
		for(int i=0;i<e[fro].size();i++){   //每条边去试
			int point=s[e[fro][i]].v;  //取终点（和dfs差不多）
			if(!vis2[point]){  //没访问过，推进去，输出，标记
				q.push(point); 
				cout<<point<<" ";
				vis2[point]=1;
			}
		}
		q.pop();  //队首搜完啦！把它弄出去
	}
}
```

这篇题解就到这里啦！Finally:AC code:

```cpp
#include<iostream>  //头文件头文件头文件
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;  
struct edge{       //存边结构体
	int u,v;
}; 
vector <int> e[100001];  //两个vector刚才已经详细讲过了
vector <edge> s;
bool vis1[100001]={0},vis2[100001]={0}; //标记数组
bool cmp(edge x,edge y){  //排序规则
	if(x.v==y.v)
	return x.u<y.u;
	else return x.v<y.v;
}
void dfs(int x){  //深度优先遍历
	vis1[x]=1;
	cout<<x<<" ";
	for(int i=0;i<e[x].size();i++){
		int point=s[e[x][i]].v;
		if(!vis1[point]){
			dfs(point);
		}
	}
}
void bfs(int x){  //广度优先遍历
	queue <int> q;
	q.push(x);
	cout<<x<<" ";
	vis2[x]=1;
	while(!q.empty()){
		int fro=q.front();
		for(int i=0;i<e[fro].size();i++){
			int point=s[e[fro][i]].v;
			if(!vis2[point]){
				q.push(point); 
				cout<<point<<" ";
				vis2[point]=1;
			}
		}
		q.pop();
	}
}
int main(){
	int n,m;  //输入，存边
	cin>>n>>m; 
	for(int i=0;i<m;i++){
		int uu,vv;
		cin>>uu>>vv;
		s.push_back((edge){uu,vv});   
	}
	sort(s.begin(),s.end(),cmp);  //排序
	for(int i=0;i<m;i++)   
		e[s[i].u].push_back(i); 
	dfs(1);   //从1号顶点开始深搜
	cout<<endl;
	bfs(1);   //广搜亦同理
}
```

### The  End~~~


---

## 作者：UnyieldingTrilobite (赞：106)

上手鉴定大膜你······

题目说了半天，其实就是给你一张有向图，要你把它深度遍历一遍再广度遍历一遍。

一些细节：
```plain
考虑到要排序，用set代替邻接表的vector.
为了更简洁的写法采用C++11.
```
然后进入主要问题：深度优先遍历和广度优先遍历怎么实现？

统一起见，假设我们有一张清单，记录现在可以遍历的点。

深度优先：

既然是深度优先，那么遍历完一个点x后肯定立刻遍历它的邻居节点（因为这些点现在肯定比清单里其它点都深）。

->把x的邻居加入清单后立刻取出。

->后进先出。

**用栈实现！**

如果想要代码变得短一些（以常数为代价，不过可以无视），可以把人工开的栈改成系统函数调用栈。（好处：代码短，**省空间！！！**）

类似这样：
```cpp
	if(vis[x])return;vis[x]=1;//bool数组vis记录是否被访问过
	printf("%d ",x);//输出正在访问的点
	for(int v:e[x])dfs(v);//递归访问邻居
```
广度优先：

思考略微复杂，就直接给结论了：

一个队列，每次取队首遍历邻居加入队尾。（可以归纳证明一定符合“广度优先”的定义）

队列么······就没有dfs的福利了。

上代码：
```cpp
queue<int>q;
q.push(1);//清单里第一个点
while(!q.empty()){//还有没访问的？
	int x=q.front();q.pop();//清单首元素
	if(vis[x])continue;vis[x]=1;
	printf("%d ",x);//遍历到
	for(int v:e[x])q.push(v);//加入清单
}
```
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
set<int>e[100009];
bool vis[100009];
void init(){
	for(scanf("%d%d",&n,&m);m;--m){
		int u=0,v=0;
		scanf("%d%d",&u,&v);
		e[u].insert(v);
	}
}
void dfs(int x=1){
	if(vis[x])return;vis[x]=1;
	printf("%d ",x);
	for(int v:e[x])dfs(v);
}
void bfs(){
	queue<int>q;
	q.push(1);
	while(!q.empty()){
		int x=q.front();q.pop();
		if(vis[x])continue;vis[x]=1;
		printf("%d ",x);
		for(int v:e[x])q.push(v);
	}
}
int main(){
	init();
	dfs();
	putchar('\n');
	memset(vis,0,sizeof(vis));
	bfs();
	putchar('\n');
	return 0;
}
```
Over.

---

## 作者：zhangyuhan (赞：91)

一道图的遍历的基础入门题。

题目大意可以概括一下：有一张有向图，求其进行深度优先搜索($DFS$)和广度优先搜索($BFS$)的两个字典序最小的遍历序列。

首先我们得明白什么叫$DFS$和$BFS$。

$DFS$，用通俗的话来说，就是你从图的一个结点出发，选择了下一个你需要遍历的结点，然后你再以你所选择的点作为新的起点，继续向下选择，直到你选择的结点没有了下一个结点，或者它所有的子节点都被访问过。

**那么此时怎么办呢？**

那你就要按照你选择的路径，依次跳回，直到你跳回的节点有了字节点，再进行遍历，以此类推。

$BFS$，用通俗的话来说，就是你从图中的一个节点出发，其有几个子节点，你会先将这所有的子节点遍历，再挑其中的一个子节点，遍历它的所有子节点，再换到另外一个结点遍历其所有的子节点。这样一层层遍历，以此类推。

**那么该用什么算法实现呢？**

对于$DFS$，由于它需要往回跳，所以就需要用递归算法；

对于$BFS$，由于它需要一层层遍历，所以需要用一个数据结构来存储每一层的节点，而根据我所描述的，选用队列($queue$)是最为合适的。

对了，这道题节点数$\leq10^5$，使用邻接矩阵会$MLE$，那么就只能考虑采用邻接表。

又由于本题需要求字典序最小的序列，那么就要将邻接表存储的结点按从小到大进行排序。

总体就是这样的，记得两次遍历中间要清空你遍历时所需要的标记数组。

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 100010;

std::vector<int> G[MAXN];
int n, m;
bool visited[MAXN];
queue<int> q;

void dfs(int x, int cur) {//x指当前所在的节点，cur指已遍历过的节点个数
	visited[x] = true;//标记以避免重复访问
	cout << x << " ";//输出
	if (cur == n) return ;
	for (int i=0; i<G[x].size(); i++)
		if (!visited[G[x][i]]) dfs(G[x][i], cur+1);//记得要判断是否遍历过
}

void bfs(int x) {
	memset(visited, false, sizeof(visited));//记得一定要清空
	visited[x] = true;
	q.push(x);
	while (!q.empty()) {
		int v = q.front();
		q.pop();//记得要弹出，否则会一直在第一层遍历
		cout << v << " ";//输出
		for (int i=0; i<G[v].size(); i++) 
			if (!visited[G[v][i]]) {
				visited[G[v][i]] = true;
				q.push(G[v][i]);//记得要入队
			}
	}
}

int main() {
	cin >> n >> m;
	for (int i=1; i<=m; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);//标准邻接表建有向图
	}
	for (int i=1; i<=n; i++) sort(G[i].begin(), G[i].end());//标准vector排序
	dfs(1, 0);
	cout << endl;
	bfs(1);
	cout << endl;
	return 0;//完结撒花！
}
```

---

## 作者：Varuxn (赞：62)

[题目传送门](https://www.luogu.com.cn/problem/P5318)

根据本蒟蒻~~细致~~粗略的分析

这明显是一道~~水题~~模（du）板（liu）题

可我竟然没有一遍AC;

为更好地食用本题解需要了解以下内容

1.dfs（~~大法师~~深搜）

2.bfs（~~冰法师~~广搜）/[dij最短路](https://www.luogu.com.cn/blog/Varuxn/dij-shi-xian-zui-duan-lu)

3.[STL vector的使用](https://www.luogu.com.cn/blog/Varuxn/vector-ji-cao)

4.[STL 队列的使用](https://www.luogu.com.cn/blog/Varuxn/dui-lie-hu-tai-xiao-gen-dui-ji-cao)

其次就是一些优化（本人在此处卡了while(1)n++次）

下面附上代码


```
#include<bits/stdc++.h>//万能文件头 
using namespace std;
inline int read()//二进制优化的快读 
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int n,m;
bool b[100005];//定义b数组防止重复输出 
vector<int > a[100005];//STL大法好 
void dfs(int x,int r)//x表示所在点，r表示剩余未遍历的点 
{
	b[x]=true;//记录某点已经输出过 
	if(!r)//如果每个点都遍历过终止递归 
	{
		cout<<x<<' ';
		return ;
	}
	cout<<x<<' ';//输出 
	for(int i=0;i<a[x].size();i++)
	if(!b[a[x][i]]) dfs(a[x][i],r-1);//查找从x可以到的点，并遍历 
}
void bfs()
{
	queue<int> q;//还是STL 
	q.push(1);b[1]=true;//把1点放入队列中，并标记1点已经遍历过 
	while(!q.empty())
	{
		int s=q.front(); q.pop();//拿出队列首的那个点 
		cout<<s<<' ';//输出 
		for(int i=0;i<a[s].size();i++) if(b[a[s][i]]==false) q.push(a[s][i]),b[a[s][i]]=true;//把点s所能到达的点遍历，为防止TLE和重复输出，记录已遍历过的点 
	}
}
int main()
{
	n=read();//读入 
	m=read();
	for(int i=1;i<=m;i++) 
	{
		int x,y;
		x=read();//读入
		y=read();
		a[x].push_back(y);//建图 表示x可以到y 
	}
	for(int i=1;i<=n;i++)//把每条路所通向的点从小到大排列（题目中有要求） 
	sort(a[i].begin(),a[i].end());//快排  
	dfs(1,n);//进行深搜 从1点开始，进行n次 
	cout<<endl;//换行 
	for(int i=1;i<=n;i++) b[i]=false;//初始化 
	bfs();//进行广搜 
	return 0;
}
```

望管理大大给过

---


# 合并序列

## 题目描述

有 $N$ 个单词和字符串 $T$，按字典序输出以字符串 $T$ 为前缀的所有单词。

## 说明/提示

【数据规模】

对于 $60\%$ 的数据，满足 $1 \le N \le 1000$；

对于 $100\%$ 的数据，满足 $1 \le N \le 100000$ 且所有字符均为小写字母。

## 样例 #1

### 输入

```
6
na
no
ki
ki
ka
ku
k```

### 输出

```
ka
ki
ki
ku```

# 题解

## 作者：郑yz (赞：88)

## 简单的字符串操作
## 主要用到的函数为find函数，find函数用来对原始数据中某个字符串进行定位，以确定其位置。

## 判断是否是以字符串T为前缀的单词只需要find返回的数为0即可

## 代码演示



------------


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n;
string k,a[1000005]; 

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	   cin>>a[i];
	cin>>k;
	sort(a+1,a+n+1);//将所有的单词都按字典序排序
	for(int i=1;i<=n;i++) 
	   if(a[i].find(k)==0)cout<<a[i]<<endl;
       //判断是否是以字符串T为前缀的单词，如果是输出
	return 0;
}

```


---

## 作者：Magallan_forever (赞：31)

# 这题是一个裸的trie
首先，我们来介绍一下trie：
>又称单词查找树，前缀树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。—百度

trie长这样（根节点没有实际内容）：![](https://s2.ax1x.com/2019/08/20/mJarpF.jpg)

在查找时，直接从根节点出发顺着树往下找就OK，插入也是一样，并且都可以写成迭代的，复杂度$ O(str.length()) $

这是我最爱的数据结构，原因在于其效率非常高，而且可以做很多事情~~其实是因为我觉得这是除树状数组和并查集外最简单的树型结构~~

但trie缺点也相当明显：空间极大，很耗内存，但如果字符串长度很小其实无论时空都很优秀，把map和set吊起来打

（不过我写的是动态的所以内存不算太尴尬）

上代码：
```cpp
template<int set_,int mod>//set_是字符集大小
struct trie{
    struct node{
        node* son[set_];
        int flag;
    };//节点，那个flag是防止查找某一字符串不在trie里的前缀时返回错误答案
    //开成int是因为可以重复
    node* root,*ctrl_c;//复制一下后面迭代插入/查找有用
    inline void init(){
        clear(ctrl_c);//清空整棵树，后面有代码
        root=new node(),ctrl_c=root;
    }//使用前请务必调用tree.init();，否则RE
    inline void insert(string line){//插入
        root=ctrl_c;//我直接拿root迭代的
        //由于后面count会返回root->flag，所以不能直接用root迭代
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){//内存不存在，调用构造函数开新内存
                root->son[line[i]%mod]=new node(),root->son[line[i]%mod]->flag=0;//把flag置为0，这个很重要
            }
            root=root->son[line[i]%mod];//往下迭代
        }
        root->flag++,root=ctrl_c;//这个当然是能重置root就重置啊
    }
    inline int count(string line){//查找
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){//内存都没有，显然没有这个字符串
                root=ctrl_c;
                return 0;
            }
            root=root->son[line[i]%mod];//仍然往下迭代
        }
        return root->flag;//有可能我们想count的只是某一个字符串的前缀
        //所以要把flag置为0
    }
    inline void del(string line){//删除
        root=ctrl_c;
        for(int i=0;i<line.length();i++){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;//内存都没有
                return;
            }
            root=root->son[line[i]%mod];
        }
        root->flag=(root->flag==0?0:root->flag-1);//如果flag是0那就不管他否则flag--
        root=ctrl_c;
    }
    void clear(node* now){//清空
        if(now==NULL) return;
        for(int i=0;i<set_;i++) if(now->son[i]!=NULL) clear(now->son[i]);//直接dfs暴力递归
        delete now;//调用析构函数&&释放内存
    }
};
```
那么为什么这道题会考虑trie呢？

由于trie基于前缀的方法存字符串，所以前缀为T的字符串一定包含T，所以我们可以考虑从T的末尾开始dfs输出所有字符串即可

使用dfs是因为深度优先，可以处理```abfsd<ba```的情况

关于dfs:
```cpp
inline node* count_(string line){
    root=ctrl_c;
    for(int i=0;i<line.length();++i){
        if(root->son[line[i]%mod]==NULL){
            root=ctrl_c;
            return NULL;
        }
        root=root->son[line[i]%mod];
    }
    return root;
}
void dfs(node* now){
	if(now==NULL) return;
    int temp=now->flag;
	while(temp--) cout<<now->s<<endl;
	for(int i=0;i<set_;++i) dfs(now->son[i]);
}
```
复杂度$ n\ length(n) $

AC代码:
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
using namespace std;
template<int set_,int mod>
struct trie{
    struct node{
        node* son[set_];
        int flag;
        string s;
    };
    node* root,*ctrl_c;//复制一下后面迭代查找有用
    inline void init(){
        clear(ctrl_c);
        root=new node(),ctrl_c=root;
    }
    inline void insert(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();++i){
            if(root->son[line[i]%mod]==NULL){
                root->son[line[i]%mod]=new node(),root->son[line[i]%mod]->flag=0,root->son[line[i]%mod]->s.clear();
            }
            root=root->son[line[i]%mod];
        }
        root->flag++,root->s=line,root=ctrl_c;
    }
    inline int count(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();++i){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;
                return 0;
            }
            root=root->son[line[i]%mod];
        }
        return root->flag;
    }
    inline void del(string line){
        root=ctrl_c;
        for(int i=0;i<line.length();++i){
            if(root->son[line[i]%mod]==NULL){
                root=ctrl_c;
                return;
            }
            root=root->son[line[i]%mod];
        }
        root->flag=(root->flag==0?0:root->flag-1);
        root=ctrl_c;
    }
    void clear(node* now){
        if(now==NULL) return;
        for(int i=0;i<set_;++i) if(now->son[i]!=NULL) clear(now->son[i]);
        delete now;
    }
    inline node* count_(string line){
      root=ctrl_c;
      for(int i=0;i<line.length();++i){
          if(root->son[line[i]%mod]==NULL){
              root=ctrl_c;
              return NULL;
          }
          root=root->son[line[i]%mod];
      }
      return root;
  }
  void dfs(node* now){
      if(now==NULL) return;
      int temp=now->flag;
      while(temp--) cout<<now->s<<endl;
      for(int i=0;i<set_;++i) dfs(now->son[i]);
  }
};
trie<26,'a'> tree;
string s;
int main(){
	tree.init();
	int n;
	scanf("%d",&n);
	while(n--){
		cin>>s,tree.insert(s);
	}
	cin>>s;
	tree.dfs(tree.count_(s));
	return 0;
}
```
[评测记录](https://www.luogu.org/record/23478603)

p.s 其实这题还可以用kmp算法（其实就是优化一下find）

---

## 作者：PrincessYR✨～ (赞：29)

这是一道二叉堆的问题，很多人用冒泡或sort来代替二叉堆，我很想说：没有这个必要
因为二叉堆会自动进行排序，只需要将元素压入二叉堆（小根堆），再对顶部的元素进行操作

首先介绍一下二叉堆之小根堆的定义

```
#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
priority_queue<int, vector<int>, greater<int> > q;//小根堆 
int a;
int main()
```

如果你很懒，也可以：
```
#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
priority_queue<int> q;//大根堆 
int a;
int main(){
	for(int i=1;i<=5;i++){
		cin>>a;
		q.push(-a);//只有负数才会按照数从小到大排（在这里忽略负号
	}
	for(int i=1;i<=5;i++){
		cout<<-q.top()<<" ";
		q.pop();
	}
	return 0;
}
```
下面废话不多说，上代码
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<string>
#include<cstring>
using namespace std;
priority_queue<string, vector<string>, greater<string> > q;
int main()
{
	int a,b,c=0;
	string d,e,f;
	cin>>a;
	for(int i=1;i<=a;i++)
	{
		cin>>d;
		q.push(d);//见元素压如二叉堆 
	}
	cin>>e;
	for(int i=1;i<=a;i++)
	{
	    f=q.top();//防止数据紊乱 
		for(int i=0;i<e.size();i++)
		{
			if(f[i]==e[i])//判断是否含有字符串T 
			{
				c++;//
		    }
		}
		if(c==e.size())//如果含有，直接输出 
		{
			cout<<q.top()<<endl;
		}
		c=0;//c归零 
		q.pop();//删除已经判断完的堆顶的元素 
	}
	return 0;//完美结束（撒花）
}
```
//by:鱡舞//date:2019.8.15


---

## 作者：WatT_T (赞：13)

## 分享一个char二维数组的方法
## 以及用sort的毒瘤操作~~（如果是我太弱了可以忽略这一句）~~
## 虽然代码比不上前面大佬的简洁，但是自认为简单易懂，有利于理解sort用法；
## 另外，第一次写，有什么不好的请见谅
首先纯%膜你应该都会吧~~（如果不会我表示抱歉）~~ 

 再看一下代码
```
using namespace std;
char c[100050][105];
char d[10000];
ll n,dl,cl,f=0;//ll 就是宏定义(即#define)成long long(看不习惯请原谅)
/*bool cmp(ll a,ll b){
	return strcmp(c[a],c[b])<0;    第一次先别管这东西，后面再说QAQ
}*/
int main(){
    ll arr[100005];
	scanf("%d",&n);//输入单词个数
	for(int i=0;i<n;i++)arr[i]=i;//这一句是让long long数组的下标跟着char数组下标变化(不理解可以先跳过，这个下面的sort用到的)；
	for(int i=0;i<n;i++){
		scanf("%s",c[i]);//输入单词
	}
	sort(arr,arr+n,cmp);//这个排序是让所有字符串按字典序排列，因为不是普通的升序排列，所以要定义自己的cmp(看不懂先跳过);
	scanf("%s",d);//输入字符串T；
    dl=strlen(d);//求出T的长度；这是char的用法( string应为：dl.length() )
    //别急，还没完呢；
}
```
现在说一下那个sort，这是百度找到的，链接[使用STL sort对字符串按字典序排序 - amojury - 博客园](https://www.cnblogs.com/amojury/p/9001195.html)听完不懂得可以看一下,大佬说的不错；
### 下面做一下搬运工## 
先说一下为啥不用string，因为某些情况下string会超时，个人推荐用char；

然后说说那个sort~~(某些大佬可以跳过)~~

因为我们排序的实际是数组arr的下标，所以比较快，但是我们要更改是数组c；
```
bool cmp(ll a,ll b){
	return strcmp(c[a],c[b])<0; 
    /*
    strcmp(),这个函数是用来比较字符串大小的；
    若a==b,返回0；
    若a<b,返回负数；
    若a>b,返回正数；
    我们是要升序排列，所以条件是<0；
    */
    //如果看不懂bool cmp这个东西，应该自行百度一下sort的用法；
}
```
再看一下后面的判断部分;
```
for(int i=0;i<n;i++){
		cl=strlen(c[arr[i]]);//切记，我们排序的是arr数组下标，变换的也是他，所以要求当前的应该用strlen(c[arr[i]]),而不是strlen(c[i]);
        //因为考虑的是前缀，所以只需循环到T完就好了
		for(int k=0;k<dl;k++){
			if(c[arr[i]][k]!=d[k]){//一位一位的判断，如果有一位不同f=1，退出，这里的f起辅助作用，可以理解为flag；
				f=1;
				break;
			}
		}
		if(f==0)printf("%s\n",c[arr[i]]);//如果没有f==0，说明符合条件，则输出，记住还是输出c[arr[i]]，理由同上
		f=0;一个单词一个flag，所以最后还要变为0;
	}
```
最后希望通过审核吧QWQ，感谢管理大大

---

## 作者：Strong_Jelly (赞：6)

# 我来发一篇string的题解

**思路：先给字符串排个序（sort直接字典序排序了）。枚举字符串1 ~ n，看字符串是否满足条件（前缀为那个字符串），是就输出，不是就不管。**

**判断是否满足条件：只需看前缀的字符串和那个字符串的前（前缀字符串的长度）个字符组成的字符串是否相等就行了**

字符串福利1：**可以直接拼接字符串**

举个例子：aaaaa和bbbbbb拼接起来就是aaaaabbbbbb

code：

```cpp
s1 = s1 + s2;// '+' 号就是拼接符号（在字符串中）
```

字符串福利2：**可以直接sort按字典序排序**（字典序就是按英文字典的单词顺序）

code：

```cpp
sort(s + 1, s + n + 1);
```

字符串福利3：**可以直接判等**（及判断两个字符串是否**完全相等**）（通常在if语句中）

举个例子：aaaaa和aaaaa完全相等，aaaaa和bbbbb不完全相等

code：

```cpp
if(s1 == s2)
{
	printf("YES");
}
else
{
	printf("NO");
}
```

看代码吧：

```cpp
//代码里的register和inline不用管，是用于优化的(是给萌新说的) 
#include <bits/stdc++.h>
using namespace std;
int n;
string s[100001], m;
inline bool check(string s)
{
	string x; 
	for(register int i = 0; i < m.length(); ++i)//s的前m.length()个字符 
	{
		x += s[i];//拼接 
	}
	if(x == m)//直接判等 
	{
		return true;
	}
	else
	{
		return false;
	}
}
int main()
{
	scanf("%d", &n);
	for(register int i = 1; i <= n; ++i)
	{
		cin >> s[i];
	}
	cin >> m;
	sort(s + 1, s + n + 1);//快排 
	for(register int i = 1; i <= n; ++i)
	{
		if(check(s[i]))
		{
			cout << s[i] << endl;
		}
	}
	return 0;
}
```


---

## 作者：Chemist (赞：5)

# P1628【合并序列】题解 
### 这道题就是将一些字符串按照字典序排序，当然可以用string+sort一遍过，也可以用堆排序，就是将堆中的元素存成字符串，然后用<cstring>中的strcmp函数比较字符串大小，维护一个元素为字符串的小根堆。
```cpp
#include<bits/stdc++.h>
using namespace std;
char tree[100002][101],s[101],cp[101];
int n,len;
void sp(char a[],char b[])//自己写交换函数
{
	char temp[101];
	strcpy(temp,a);
	strcpy(a,b);
	strcpy(b,temp);
}
bool compare(string a,string b)
//判断最后的字符串是否为前面字符串的前缀
{
	for(int i=0;i<len;i++)
	 if(a[i]!=b[i])return false;
	return true;
}
struct node{
	int size;
	void push(char a[])
	{
		strcpy(tree[++size],a);
		int pos=size;
		while(pos/2&&strcmp(tree[pos],tree[pos/2])<0)//小根堆 
		 {
		 sp(tree[pos],tree[pos/2]);
		 pos/=2;
		 }
	}
	void pop()
	{
		int pos=1;
		strcpy(tree[1],tree[size--]);
		while(pos*2<=size){
			int i=pos*2;
			if(i+1<=size&&strcmp(tree[i],tree[i+1])>0)i++;
			if(strcmp(tree[pos],tree[i])>0)
			 {
			 sp(tree[pos],tree[i]);
			 pos=i;
		     }
		    else break;
		}
	}
}heap;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	 {
	 cin>>s;
     heap.push(s);
	 }
 	cin>>cp;
	len=strlen(cp);
	for(int i=1;i<=n;i++)
	 {
	 if(compare(tree[1],cp))
	  cout<<tree[1]<<endl;
	 heap.pop();
     }
	return 0;
} 
```

---

## 作者：蹲在丛中笑 (赞：5)

参考楼下大佬的字典树题解,我我来贡献一个数组版的字典树.

由于数据非常水,理论上根本不够的1e6个树节点也A掉了这道题

具体操作就是把输入的字符串都插到字典树里,在题目要求的节点处dfs一遍所有子树,

dfs子树前把该子树根节点的内容push进栈,

dfs完了再pop出站

遇到末尾标记时就把栈内的字符串输出一遍

下面是代码

```cpp
#include<stdio.h>
#include<string.h>
#define N 1000000
int n;
int ch[N][26],cnt[N],size;
char s[105],len;
void insert() {
    int t=0;
    for(int i=0;i<len;i++) {
        int &son=ch[t][s[i]-'a'];
        if(son==-1) son=++size;
        t=son;
    }
    cnt[t]++;
}
void dfs(int t) {
    while(cnt[t]--) {
        for(int i=0;i<len;i++) putchar(s[i]);
        puts("");
    }
    for(int i=0;i<26;i++) {
        if(~ch[t][i]) {
            s[len++]=i+'a';
            dfs(ch[t][i]);
            len--;
        }
    }
}
void predfs() {
    int t=0;
    for(int i=0;i<len;i++) {
        t=ch[t][s[i]-'a'];
        if(t==-1) return;
    }
    dfs(t);
}
int main() {
    memset(ch,-1,sizeof ch);
    scanf("%d",&n);
    while(~n--) {
        scanf("%s",s);
        len=strlen(s);
        ~n ? insert() : predfs();
    }
}
```
最后我要说的的是:

要有信仰

数据其实并没有题目所给的那么大


---

## 作者：zhaowangji (赞：4)

~~前面几篇题解写的太烦了~~

其实就是一个提取子串的函数——substr
[详细了解](https://www.cnblogs.com/yongpan/p/7919527.html)

substr(a,b)

a是字串的起始位，b是字串的长度

希望大家记住

用字符串数组读入，首先要排序，因为题目要求按字典序输出答案，然后枚举每个字符串，提取字串，与T比对，相同则输出（字符串或数组可以直接互相比较）

```cpp
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;
int n;
string s[100007];
string t;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>s[i];
	cin>>t;
	sort(s+1,s+n+1);//要求字典序升序
	for(int i=1;i<=n;i++)
	{
		string x=s[i].substr(0,t.size());//提取子串
		if(x==t)cout<<s[i]<<endl; //相同，输出
	}
    return 0;    
}
```


---

## 作者：DOs__lx (赞：3)

# 暴力~~不挺简单的~~
这道题蒟蒻~~不会什么二叉堆~~，暴力一波，大佬勿喷~~~
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
using namespace std;
int n;
const int M=100002;
int len[M];//存长度
string a[M];//存输入的字符串
string end[M];//存前缀为t的字符串
string t;//前缀
bool cmp(string a,string b){
	int lena=a.length();
	int lenb=b.length();
	for(int i=1;i<max(lena,lenb);++i){
		if((int)a[i]==(int)b[i]) continue;
		return (int)a[i]<(int)b[i];
		break;//题目要求，升序
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		cin>>a[i];
		len[i]=a[i].length();
	}//输入不解释
	cin>>t;
	int sum;
	int l=1;//便于存入end数组的变量
	int r=0;//总共有几个字符串前缀为t
	for(int i=1;i<=n;++i){
		sum=0;
		string c=a[i];
		for(int j=0;j<len[i];++j){
			if(c[j]==t[j]) sum++;
			else break;
		}
		if(sum==t.length()){
			end[l]=c;
			++l;
			++r;
		}
	}//暴力匹配
	sort(end+1,end+r+1,cmp);//排序
	for(int i=1;i<=r;++i) cout<<end[i]<<endl;
	return 0;//华丽地结束
} 
```
蒟蒻第一次发题解，求过


---

## 作者：半笙、凡尘 (赞：2)

# P1628 【合并序列】
### 蒟蒻的题解，很好理解，但不一定是最优解，也不一定是最简便的做法


------------


~~简单地~~描述一下题面：就是找哪几个单词是以字符串$t$开头的，全部按**字典序**输出

说到字典序，关键来了——**排序**，首先当然选择$sort$啦

~~具体~~的话就看注释吧~

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{//结构体
	string s;//有的单词
	bool f=0;//标记这个单词的开头是否有字符串t
}a[100010];
bool fg=0;
int main(){
	int n,t;
	string l,p[100010];
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		cin>>a[i].s;//输入n个字母
	}
	cin>>l;//输入要查询的字符串
	for(int i=0;i<n;i++){//枚举每一个单词
		fg=0;//不要忘记每一遍标记初始化
		for(int j=0;j<l.size();j++){//枚举字符串t中的每个字母
			if(a[i].s[j]!=l[j]){//当单词中的一个字母与字符串t中字母不同时，只要发现有一个字母不同，那就不是我们要查询的单词
				fg=1;
				continue;//发现不是就退出
			}
		}
		if(fg==1){//当fg==1，说明这不是我们要查询的单词
			a[i].f=0;
		}else{//当fg==0，说明这是我们要查询的单词
			a[i].f=1;
		}
	}
	for(int i=0;i<n;i++){
		if(a[i].f==1){//将我们确定要查询的单词放在一个数组里，进行排序（不另外加数组其实也可以，但这么写容易理解）
			p[i]=a[i].s;
		}
	}
	sort(p,p+n);//最激动人心的sort排序，将确定的单词按字典序排好
	for(int i=1;i<=n;i++){
		if(p[i]>="a" && p[i]<="z"){//因为题目中提到所有单词的字母都为小写字母（如果没了if(p[i]>="a" && p[i]<="z")可能会有很多换行，所以我们只选择小写字母输出）
			cout<<p[i]<<endl;
		}
	}
	return 0;
}
```


---

## 作者：SIXIANG32 (赞：1)

# 本蒟蒻的第二篇题解
看到各大佬不是用trie就是用队列等等贼牛的强大的东东，置顶的大佬还用find函数，此蒟蒻看得瑟瑟发抖，今日我发一个咱们蒟蒻家族能看懂的题解。  

——————————————————————  

第一节：读入  
cin，又没空格。如果要用getline的话注意要多加一个，吸收换行符（否则你会WA的耀眼）。

——————————————————————  

第二节：排序  
sort。这里解释一下字符串的大小比较默认就是字典序。字典序的意思就是从第一个比较ASCLL码值，如果一样比较次高位，以此类推。    

——————————————————————  

第三节：查找    
查找应该是这题的重点吧。说一下string也可以当char数组使用，而string数组可当成char型的二维数组。这样就可以一一枚举前缀的第i个字符和字符串的第i个字符，看看是否一样。如果全一样，就输出。

—————————————————————— 

~~相信泥萌都不喜欢看上面的一通分析，~~，代码走起。
```cpp
#include<bits/stdc++.h>
#include<string>
#include<algorithm>
using namespace std;
int main()
{
	int n;
	bool f;
	cin>>n;
	string str[100001],t;
	for(int p=1;p<=n;p++)cin>>str[p];
	cin>>t;
	sort(str+1,str+n+1);//字典序排序
	for(int p=1;p<=n;p++)
	{
		f=1;//标记一不一样的标志
		for(int i=0;i<=t.size()-1;i++)
		{
			char ch1=str[p][i];
			char ch2=t[i];
			if(ch1!=ch2){f=0;break;}//如果不一样，果断退出，标记为0（不一样） 
		}
		if(f==1)cout<<str[p]<<endl;//一样的操作
	 } 
	 return 0;
}
```
虽然这个题解用的时间比较长，但还是AC了。  
（管理员大大求通过qwq）

---

## 作者：Jelly_Goat (赞：1)

### 看到这个题，小金羊第一秒的反应就是：  
## 优先队列可解！  
看到楼上某同学一个个比较，  
### find()函数是时候现身了！  
```cpp
string//类型库
      //find具体用法可以自行百度
      //这里仅说这里的用法（逃）
原型：
public size_type basic_string::find(const basic_string&str,size_type __pos = 0)const noexcept;
/*
返回一个定位器:pos(unsigned int pos)
       或返回npos(unsigned int npos=-1)
现行G++版本适用-1代替npos。
英语解释：
pos=position位置
npos=no position没有位置，即没有这个子字符串
*/
```

------------

还有一点，我们可以建立一个临时队列来存一下输入的字符串。  
最后，我看到dalao使用了一个计数器来输出，并且输出都会多一个回车，  
### 这里提供一个简单的方法来避免这个多回车的办法。  
~~juruo不才，惭愧惭愧~~

------------

#### Code:
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
priority_queue<string,vector<string>,greater<string> >qwq;
/*
一开始小金羊没有打里面多余的（不看题），
结果就是不看题的后果：一片WA然！（还交了3次）
*/
queue<string>qwq2;
//临时的队列，用来存放输入的字符串
int main()
{
//小金羊没有用输入优化，建议大家加上iostream的取消缓存优化
	int n;
	string input,t;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>input;
		qwq2.push(input);
        //存入qwq2里
	}
	cin>>t;//子字符串
	while (!qwq2.empty())
	{
		input=qwq2.front();
		qwq2.pop();
		if (input.find(t,0)==0)
		{//当子字符串位于父字符串的最前端时
			qwq.push(input);
         //压入优先队列
		}
	}
	while (!qwq.empty())
	{//当优先队列不空的时候，尽情输出就是
		input=qwq.top();
		qwq.pop();
        //先取出一个元素
		if (!qwq.empty())
		{//如果里面还有元素，就输出换行(endl)
			cout<<input<<endl;
		}
		else
		{//空了,就只输出字符串，避免最后的换行
			cout<<input;
		}
        //这样就简单的避免了上述最后一个问题
	}
	return 0;
}
```
# ~~虽然，卡换行的出题人可以去世了~~  
### 关于string在优先队列（或sort）里的排序，  
### 是按照string重载的‘<’号，  
### 自带字典序和长度比较，所以优先队列（或sort）可解！
这篇题解应该是写题解的OIER们最标准的了？  
~~简单易懂，juruo求过，敲代码题解很累！~~

---

## 作者：lych (赞：1)

本题可以先判断再排序也可以先排序再判断，但是为了方便起见，使用后一种方法（代码简单一点）

1.首先读入n个字符串，并进行排序（直接比较即可，不需要用特殊的比较方法）；

2.逐一比较每一个字符串，符合即输出

代码如下：

```cpp
var
  a:array[0..100000] of ansistring;
  i,n,j:longint;
  k,t:ansistring;//注意一定要用ansistring，否则会导致错误，我就被坑了
procedure qsort(r,l:longint);
var i,j:longint;
    t,mid:ansistring;
begin
  i:=r;
  j:=l;
  mid:=a[random(j-i+1)+i];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
      begin
        t:=a[i];
        a[i]:=a[j];
        a[j]:=t;
        inc(i);
        dec(j);
      end;
  until i>j;
  if r<j then qsort(r,j);
  if i<l then qsort(i,l);
end;//快排，不多解释
begin
  randomize;//随机化快排
  readln(n);
  for i:=1 to n do readln(a[i]);
  qsort(1,n);//对n个字符串排序，方便后面的操作
  readln(k);
  for i:=1 to n do
    if pos(k,a[i])=1 then writeln(a[i]);//如果k是它的前缀，即pos(k,s)=1，就直接输出，因为a[i]本身是有序的，所以后面的一定会在前面的判断好之后输出，保证了输出一定是按字典顺序的
end.
```

---

## 作者：傅思维666 (赞：0)

## 题解：

这道题有多种方法：

字典树（Trie树）、排序、二叉堆...

正解应该是字典树（来自教练和大佬的指点）~~可惜我不会~~。

所以我们考虑一种朴素方法：

处理输入的单词和前缀关键词的匹配，如果匹配上了就加入要排序的一个数组中，没匹配上就不用管，因为C++的sort函数是支持字符串排序的（当然要用C++STL中的string容器），所以就可以保证正确性。

而且时间也可以过。

那么，我们还可以用堆进行数据结构处理。实现原理和上面那个大同小异。因为小根堆（这里用优先队列实现）也可以维护一个字符串的字典序。

比较一下这两种做法：

排序的时间复杂度比较高，但是码量少，容易想。二叉堆的常数大，如果不开O2的话奇慢无比容易被卡，但大多数时候要更优秀一些。~~而且可以用于装b~~。

代码：

```c++
#include<cstdio>
#include<string>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
const int maxn=1e5+1;
int n;
string s[maxn],k;
priority_queue<string,vector<string>,greater<string> >q;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        q.push(s[i]);
    }
    cin>>k;
    for(int i=1;i<=n;i++)
    {
        int cnt=0;
        string a=q.top();
        q.pop();
        for(int j=0;j<k.size();j++)
            if(a[j]==k[j])
                cnt++;
        if(cnt==k.size())
            cout<<a<<endl;
    }
    return 0;
}
```



---

## 作者：la_un_ty (赞：0)

# 一道模拟题。

这一道题可以这样做：

首先，题目中有说到按升序排列，所以我们可以把它丢进一个小根堆，最后一个一个处理。

关于$string$，它有一个函数：$substr (size_t pos = 0, size_t len)$，意思是从$pos$开始，截取一个长度为$len$的子串，返回一个$string$，这样用来截取前缀就方便的多。

具体做法详见注释。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<string,vector<string>,greater<string> > q;//定义一个内容为string的小根堆。
int n;
string tmp,fr/*用于存储前缀*/;
int main(){
	scanf("%d",&n);
	while(n--){
		cin>>tmp;
		q.push(tmp);//把它扔进去
	}
	cin>>fr;
	int len=fr.length();
	while(!q.empty()){//一个一个检验
		string a=q.top();
		q.pop();
		if(a.substr(0,len)/*从头开始，截取一个长度为fr长度的前缀并判断*/==fr) cout<<a<<endl;//比较成功就输出
	}
	return 0;
}
```

这也是处理字符串的一个好方法。

---

## 作者：altar (赞：0)

这题 很 简单，纯模拟

大体思想为 ：
每次 把用到的字符串 和 标准 t 比较 

用 计数器 ans 来 表示 他们的相似度

最后ans 如果 等于 t的长度 

即：这个字符串前缀符合 t 

再设置一个 输出数组put

把每次的 判断好的 字符串 放进去，注意下标的初始坐标

最后把 put 用 sort 排序一下

sort 是个好东西，它可以为我们进行字典序排序

尤其注意 下标 与 字符串 长度 的关系

下标可以从 1 开始，但是 字符串第一个字符 确是从 0 开始

    
    
    #include <cstdio>
    #include <iostream>
    #include <algorithm>
    #define SM 402600

    int n , len , y = 1 ;
    std :: string t , a[SM] , put[SM] ;

    int main () {
        scanf ( "%d" , &n ) ;
        for ( int i = 1 ; i <= n ; i ++ )
            std :: cin >> a[i] ;
        std :: cin >> t ;
        len = t.length() ;
        for ( int i = 1 ; i <= n ; i ++ ) {
            int ans = 0 ;
            for ( int j = 0 ; j <= len - 1 ; j ++ ) {
            	// 尤其注意 j 初始 为 0
                // 要 循环到 len的前一位
                if ( a[i][j] == t[j] )
                    ans ++ ;
                if ( ans == len ) {
                    put[y] = a[i] ;
                    y ++ ;
                }
            }
        }
        std :: sort ( put + 1 , put + y + 1 ) ;
        for ( int i = 2 ; i <= y ; i ++ )
            std :: cout << put[i] << std :: endl ;
        return 0 ;  
    } 
    
PS : 不要吐槽个人代码风格

小结 ： 

  	std :: 
是个 好东西

不用 

	using namespace std ;
的话

需要 在 变量前 加上 这个 东西

#  ***重要的事情说三遍 ： 注意 1 与 0***
#  ***它 会害死你 的***
#  ***第一次 提交 下标 搞错 0 与 1 ， 爆零 ***

---

## 作者：听取TLE声一片 (赞：0)

我不知道为什么标签里写“二叉堆”。

这道题非常简单，排一下序、判断前缀就行了，也没有陷阱。

不要被**字典序**所迷惑，只用一个sort排序就可以了。~~不会sort排序的蒟蒻就不要学习了~~

~~本人只用了5分钟敲出代码~~

废话不说，贴上代码。
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>//一大堆头文件
using namespace std;
string a[100001],b;//所有的字符串、前缀
int l,n;//长度、个数
int main()
{
    cin>>n;//输入个数
    for(int i=0;i<n;i++)
        cin>>a[i];
    cin>>b;//输入前缀
    sort(a,a+n);//排序字符串 
    l=b.length();
    for(int i=0;i<n;i++)
        if(a[i].substr(0,l)==b)//判断是否符合要求
            cout<<a[i]<<endl;//输出
    return 0;
}
```
望通过

不要抄代码

---

## 作者：小周猪猪 (赞：0)

各种大佬的字典树，优先队列之类的看的我一阵发凉

事实上，AC这道题只需要模拟+排序即可

具体做法如下：

1. 用map存储t，map相当于哈希（没学过也没关系），相当于以字符串为下表存储某个数值，定义方式如下：map<下标类型，储存数据类型>；事实上，开map数组只用了1个空间，但却给了我们极大的方便

2. sort：为了使字典序从大到小，因此需要排序。

3. 每次只要判断vis[a[i].substr(0,t.length())]是否为真，即是否满足题目所说的要求即可；substr指的是取字符串的函数（s.substr(x,y)表示在字符串s中以第x个位置为起始点去y个字符），而a[i].substr(0,t.length())则是去取a[i]的前长度为t.length()的字符串，vis为上述map，即如果取的字符串和t相同则输出。


------------
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    map<string,int>vis;
    string t,a[10100]={};
    cin>>n;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    cin>>t;
	vis[t]=1;
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++)
		if (vis[a[i].substr(0,t.length())])
			cout<<a[i]<<endl;
	return 0;
} 
```


---

## 作者：Salmon_lee (赞：0)

[multiset]系统自带字典树，只需将每一个字符串insert入这个容器即可自动按字典顺序排列。

	multiset<string> str;
	while(n--)
	{
		cin>>temp;
		str.insert(temp);
	}
    
[判断前缀]
只需要知道前缀的长度len = temp.size()，然后string(p->begin(),p->begin()+len)==temp即可。

	size_t len = temp.length();
	
	for(auto p = str.begin(); p != str.end(); ++p)
	{
		if(string(p->begin(),p->begin()+len) == temp)
			cout<<*p<<endl;
	}

---

## 作者：Hamster_Air (赞：0)

###这是一题比较水的字符串模拟，这里用到的是string，不过也可以用char，但可能比较麻烦，因为char不能sort

###代码奉上：



```cpp
#include<bits/stdc++.h> //万能头文件
#define f(i,j,n) for(i=j;i<=n;i++) //for循环简写，个人习惯问题
using namespace std; 
string s[100005],t;
int main()
{
    ios::sync_with_stdio(false); //cin，cout输入输出优化，写c的注意了，写了这句话scanf，printf，getchar，gets等是用不了的
    int n,l,i,j; //基本定义
    bool ok; //bool变量用于表示是否为前缀
    cin>>n; //输入n
    f(i,1,n)
        cin>>s[i]; //输入n个字符串
    sort(s+1,s+1+n); //首先排序，string的优势就体现在这里
    cin>>t; //输入字符串t
    l=t.size(); //测长
    f(i,1,n) //重点循环语句
    {
        ok=1; //每次更新ok的值为1
        f(j,0,l-1)
            if(s[i][j]!=t[j]) //只要两者不相等，就把ok变成假
            {
                ok=0;
                break;
            }
        if(ok) //如果整个循环都没有不同点，就说明t是此字符串的前缀，此时输出
            cout<<s[i]<<endl;
    }
    return 0; //华丽丽地结束
}

```

---

## 作者：ShawnZhou (赞：0)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

看了看题解，怎么大家写的都这么麻烦。。。。我用STL随手瞎搞了一下一遍就过了。。

这是一个偷懒而不用小根堆的做法。。

我们离线处理这些单词。读入之后先扫一遍，如果扫到的单词前缀与给定的相同就压到优先队列里面，然后依次弹出，每次弹出使计数器cnt++。

然后要怎么办？从cnt到0倒着枚举，输出就好了。。。

没有想象中那么难。。。。真的

参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <string>
#define maxn 100005
using namespace std;
int n;
string words[maxn];
string outwords[maxn];
priority_queue<string> q;
string st;
int cnt;

int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        cin >> words[i];
    cin >> st;
    for (int i=1;i<=n;i++){
        if (words[i].substr(0,st.length()) == st)
            q.push(words[i]);
    }
    while (!q.empty()){
        outwords[++cnt] = q.top();
        q.pop();
    }
    for (int i = cnt;i>=0;i--)
        cout << outwords[i] << endl;
    return 0;
}
```

---

## 作者：justin_cao (赞：0)





```cpp
//首先，我是个渣渣，我没用那个函数
//我是自己写了个判断函数
//还有，我认为可以优化，就是在找到第一个匹配的以后就用一个while语句往后找
//知道找到一个不匹配的就直接跳出
//这样时间复杂度会更低
//代码如下
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int n,len;
string s[100001];
string sx;
bool check(string x)//判断函数
{
    for(int i=0;i<len;i++)
    {
        if(x[i]!=sx[i])  return false;
    }
    return true;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)  cin>>s[i];
    sort(s+1,s+n+1);
    cin>>sx;
    len=sx.size();
    for(int i=1;i<=n;i++)
    {
        if(check(s[i])==1)
        {
            cout<<s[i]<<endl;
            int j=i+1,sum=1;
            while(check(s[j])==1&&j<=n)//这就是优化的核心
            {
                cout<<s[j]<<endl;
                sum++;
                j++;
            }
            break;
        }
    }
    return 0;
}
```

---

## 作者：water_mi (赞：0)

前言：虽然我承认这题根本不用用堆去做。

但是，这对于一个刚学习堆的oier来说，值得一做

当然，这里并不对排序或者trie树表示歧视

分析：

1.这一题的第一个重点在于，如何以字典序输出。

2.以字典序输出，这恰好符合小根堆的定义：

根始终最小（即字典序最前）

3.于是，问题就变为了一道简单的小根堆

4.但问题是，字符数组的堆，如何实现？

5.这里我们要用到一个STL：string类，完美实现该题

6.但还有一个重点，string类如何匹配前缀:利用find函数

如果我们要在一个字符串s里面寻找有没有前缀t

那么只需要这么写:

```cpp
if(!s.find(t,0)); 
```
有同学会问了，为什么这么写?

我们首先先看一下find函数的原型

```cpp
size_type find(const char *str, size_type index);
//返回str在字符串中第一次出现的位置（从index开始查找）
``` 
对于上面那个if语句的解释：

在字符串s中搜索字符串t,返回t第一次出现的位置

那么那个'!'是什么意思呢？很容易理解，

因为我们要搜寻的是前缀，所以第一次出现的位置就只能是0

```cpp
#include<string>
#include<iostream>
using namespace std;
string heap[100010],str[100010],t;
int n,heap_size;
void Swap(string &a,string &b){string tmp = a;a = b;b = tmp;}
void put(string value){
    heap[++heap_size] = value;
    int now = heap_size,next;
    while(now > 1){
        next = now >> 1;
        if(heap[next] <= heap[now]) return;
        Swap(heap[next],heap[now]);
        now = next;
    }
}
string get(){
    string value = heap[1];
    heap[1] = heap[heap_size--];
    int now = 1,next;
    while(now << 1 <= heap_size){
        next = now << 1;
        if(next < heap_size && heap[next + 1] < heap[next]) next++;
        if(heap[now] <= heap[next]) break;
        Swap(heap[next],heap[now]);
        now = next;
    }
    return value;
}
int main(){
    std::ios::sync_with_stdio(false);
    //关闭cin,cout与scanf,printf的同步，加速数据读入 
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> str[i];
    cin >> t;
    for(int i = 1;i <= n;i++)
        if(!str[i].find(t,0))
            put(str[i]);
    while(heap_size) cout << get() << endl;
    return 0;
} 
```

---

## 作者：shijunfeng00 (赞：0)

用C++的string类+sort排序,这道题还是挺简单的

```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
string a[100005],b;
int main()
{
    int n,len;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1);     //按照字典顺序排序,默认从小到大
        cin>>b;
    len=b.size();                 //获得b的长度
    for(int i=1;i<=n;i++)
        if(a[i].substr(0,len)==b) //比较是否匹配,若匹配,则输出
            cout<<a[i]<<endl;  
}
```

---

## 作者：Michael_Li (赞：0)

首先回答楼下的问题，不管是noip，还是省选（只知道zj，不敢乱讲），sort都是可以用的，只要开algorithm这个系统库。

被楼下字母数大佬吓的瑟瑟发抖。

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std; 
int n;
string sen[100000+10];
char word[100+10];
int main(){
    cin>>n;//cin读入字符串很好，读到空格或空行为止
    for (int i=1;i<=n;i++) cin>>sen[i];
    cin>>word;
    sort(sen+1,sen+n+1);//我是先排序，这样就不用重新压入一个数组了，可以直接输出，如果是要从大到小，可以改成sort(sen+1,sen+n+1,cmp) cmp为自定义的一个bool函数，bool cmp(int x,int y){return x>y},就可以实现了。
    int len=strlen(word);//求字符数组长度
    for (int i=1;i<=n;i++){
        bool p=true;//判断是否为前缀
        for (int j=0;j<len;j++)    if (sen[i][j]!=word[j]){//特别注意c++的字符串和字符数组是从0开始的
            p=false;
            break;    
        } 
        if (p==true) cout<<sen[i]<<endl;//如果是前缀直接输出，因为前面以按字典序排好
    }
}
```

---

## 作者：Hiki (赞：0)

  
    
    
      
    
    
   
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;  //该题其实只需用一个sort就可以排序了，它会自动帮你按字典顺序排好序。而且速度还很快啊，192ms，哈哈哈哈哈，就是不知道考试的时候可不可以用sort。
int main()
{
    bool t;
    int n,i,l,j,m=0;
    string s[100001],kk,a[100001];
  cin>>n;
    for(i=1;i<=n;i++)         //输入
      cin>>s[i];
    cin>>kk;
l=kk.length();   //长度
    for(i=1;i<=n;i++)
    {
      t=true;
      for(j=1;j<=l;j++)
        if(s[i][j-1]!=kk[j-1]) t=false;  //筛除词头不符合的单词
      if(t) a[++m]=s[i];    //把符合的单词计入一个新的字符串组
    }
    sort(a+1,a+m+1);  //排序啦
    for(i=1;i<=m;i++)
      cout<<a[i]<<endl; //输出
    return 0;
    //总结一下，其实这个做法很取巧，只是给大家看看的
}
```

---

## 作者：zhengrunzhe (赞：0)

奇奇怪怪的做法

闲得无聊用优先队列（小根堆）做字典序

逐个逐位与t比较也能过

看见有人用trie树顿时就懵逼了.

注解见代码

```cpp
#include<queue>
#include<string>
#include<vector>
#include<iostream>
#define N 100001  //数据范围 
#define S string  //方便定义 
using namespace std;
int n,i,j;
S t,s[N];
priority_queue<S,vector<S>,greater<S> >q;  //建立小根堆 即优先队列 
bool f;
int main()
{
    cin>>n;
    for (i=1;i<=n;i++)cin>>s[i];
    cin>>t;
    for (i=1;i<=n;i++)
    {
        f=0;  //清空标记 
        for (j=0;j<t.length();j++)if (s[i][j]!=t[j]){f=1;break;}  //逐位匹配 如果失配了 就标记上 并退出循环 
        if (!f)q.push(s[i]); //如果没被标记 即为匹配成功 将该字符串推进坑中 
    }
    while (q.size())cout<<q.top()<<endl,q.pop(); //将优先队列中的每一个字符串输出 
    return 0;  //华丽地结束 
}
```

---

## 作者：vegetabird (赞：0)

这道题其实是一道很裸的Frie树。Frie树又称字典树，功能就是储存很多单词。。。（<--废话）（你可以百度一下）

先放代码：

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;
inline void getstring(char *str){
    char ch=0,sz=0;
    while(!isalpha(ch)){
        ch=getchar();
    }
    while(isalpha(ch)){
        str[sz++]=ch;
        ch=getchar();
    }
    str[sz]=0;
}
char ans[110];int len=0;                                ans记录输出的答案,len记录ans的长度
class FrieTree{
```
public:
FrieTree(){                                构建根节点的函数

```cpp
            memset(subTree,0,sizeof(subTree));
            ch=0;                                根节点不储存值
            end=0;
        }
        FrieTree(int alpha){                            构建叶子节点的函数
            memset(subTree,0,sizeof(subTree));
            ch=alpha+'a';                            叶子节点储存一个字母
            end=0;
        }
        ~FrieTree(){                                析构函数（不写用时更少2333）
            ch=0;
            end=0;
            for(int i=0;i<26;i++){
                if(subTree[i]){
                    delete subTree[i];
                }
            }
        }
        inline void insert(char *str){                    向树里插入一个单词
            if(*str==0){                            如果单词为空
                end++;                            标记：在该节点有一个单词结束
                return;
            }
            char str2[110];
            strcpy(str2,str+1);                        单词剩余部分
            if(!subTree[*str-'a']){
                subTree[*str-'a']=new FrieTree(*str-'a');
            }
            subTree[*str-'a']->insert(str2);                将单词剩余部分插入子树
        }
        inline bool check_and_output(char *str){            检查以str为前缀的字符串是否存在并输出
            if(*str==0){
                output();                            输出
                return true;
            }
            if(ch){                                如果不是根节点
                ans[len++]=ch;                    输出字符串中加入ch
            }
            char str2[110];
            strcpy(str2,str+1);                        字符串str剩余部分
            if(!subTree[*str-'a']){                        str不是任何一个单词的前缀
                return false;
            }
            return subTree[*str-'a']->check_and_output(str2);        继续检索～
        }
        inline void output(){
            ans[len++]=ch;                            将ch加入输出字符串
            if(end){                                    如果有单词在此节点结束
                for(int i=1;i<=end;i++){                    有多少个就输出多少个
                    puts(ans);
                }
            }
            for(int i=0;i<26;i++){
                if(subTree[i]){                            继续输出更长的单词
                    subTree[i]->output();
                }
            }
            ans[--len]=0;
        }
```
private:
FrieTree \*subTree[26];                                    26棵子树，表示26个字母

char ch;                                                当前节点表示的字母

int end;                                                有多少单词在当前节点结束

```cpp
};
FrieTree ft;
int N;
char word[110],T[110];
int main(){
    scanf("%d",&N);
    for(int i=1;i<=N;i++){
        getstring(word);
        ft.insert(word);
    }
    getstring(T);
    ft.check_and_output(T);
}
```

---

## 作者：hanghang0702 (赞：0)


**[color=green]这题你还叫“堆”？[/color][b]

##[b]此题思路：**

[color=green]**[center]先排序，再查找前缀，找到一个输出一个（排过序了，所以还是有序的。或者先查找前缀，放到新数组里，排序，输出。相比之下，第一种方法好一点。[/center]**[/color]

```delphi

var a:array[1..100000] of ansistring;
    search:ansistring;  //search为前缀
    n,i:longint;
procedure qsort(l,r:longint);//快排，不多解释
var i,j:longint;t,m:ansistring;
begin
 i:=l;j:=r;m:=a[(l+r) div 2];
 repeat
  while a[i]<m do inc(i);
  while m<a[j] do dec(j);
  if i<=j then
  begin
   t:=a[i];a[i]:=a[j];a[j]:=t;
   inc(i);dec(j);
  end;
 until i>j;
 if l<j then qsort(l,j);
 if i<r then qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do readln(a[i]);//输入
 readln(search);
 qsort(1,n); //排序
 for i:=1 to n do
  {if copy(a[i],1,length(search))=search then}//这样也可以
  if pos(search,a[i])=1 then                            //如果有前缀，那么它的起始位是第1位
   writeln(a[i]);                                                //有就输出
end.
[color=red]下面提供**Pascal**标程：[/color]

```

---

## 作者：CoolTeam (赞：0)

把前缀匹配的筛出来，在快排一次即可。下面提供**C代码**

```cpp
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char ans[100010][102],chr[102],ans2[100010][102];
int cmp(const void *a,const void *b)
{
    return strcmp((char*)a,(char*)b);
}
int main(void)
{
    int n,i,len=0;
    scanf("%d\n",&n);
    for(i=0;i<n;i++)    
        gets(ans[i]);
    gets(chr);
    for(i=0;i<n;i++)
    {    
        int ptr=strstr(ans[i],chr)- ans[i]; //前缀相同时ptr为0（即从&ans[i][0]开始匹配到）
        if( ptr == 0 ) strncpy(ans2[len++],ans[i],sizeof(ans[i])); 
    }
    qsort(ans2,len,sizeof(ans2[0]),cmp);
    for(i=0;i<len;i++)
        puts(ans2[i]);
    return 0;
}
```

---

## 作者：发源于 (赞：0)

[color=red]这题你好意思叫堆？[/color]

读入，求前缀，快排，end，居然不会超

非常朴素的算法

[删除]你疯了的话可以用二叉排序树[/删除]

```delphi

var
  a:array[1..200000] of ansistring;
  sort:array[1..200000] of ansistring;//以b为前缀的数组
  b:ansistring;
  n,i,j:longint;
procedure qsort(l,r:longint);{快排略去}
var
begin
end;
begin
  readln(n);
  for i:=1 to n do
    readln(a[i]);
  readln(b);
  j:=1;
  for i:=1 to n do
    if copy(a[i],1,length(b))=b then {a[i]以b为前缀厩将a[i]放入sort中}
      begin
        sort[j]:=a[i];
        inc(j);
      end;
  dec(j);
  qsort(1,j);
  for i:=1 to j do
    writeln(sort[i]);
end.

```

---


# [语言月赛202304] 写大作业

## 题目描述

扶苏为了写计算理论大作业已经 $36$ 小时没有合眼了。

为了能快点睡觉，扶苏找到了 $n$ 份文献，第 $i$ 份文献是一个字符串 $s_i$，她打算把这些文献组合起来。

具体来说，一共有两种操作：

- `1 x y`：把文献 $s_x$ 整体拼接到 $s_y$ 的后面，然后删除 $s_x$。
- `2 x y`：查询 $s_x$ 和 $s_y$ 是否**相似**。

我们保证在 `1 x y` 操作出现后，字符串 $s_x$ **不会**出现在接下来的任何操作中。这就是说，操作 $1$ 至多有 $n-1$ 次。

**相似**的定义是：对两个字符串 $s_x$ 和 $s_y$，如果存在一种重新排列 $s_x$ 的方法，使得重排后的 $s_x$ 和 $s_y$ 相等，则称 $s_x$ 和 $s_y$ **相似**。

例如，假设 $s_1 = \texttt{ab}, s_2 = \texttt{cd}, s_3 = \texttt{abcd}$，则执行 `1 1 2` 后，$s_1$ 被删除，$s_2 = \texttt{cdab}, s_3 = \texttt{abcd}$；继续执行 `2 2 3` 后，因为可以把 $s_2$ 重排为 $\texttt{abcd}$，所以 $s_2$ 和 $s_3$ 相似。

注意，操作 $2$ 不会对字符串做出实际修改。

## 说明/提示

### 数据规模与约定

- 对 $30\%$ 的数据，保证 $n = 2$，$q = 1$。
- 对 $60\%$ 的数据，保证 $n \leq 6$，$q \leq 6$，$|s_i| \leq 6$。
- 对 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$1 \leq q \leq 10^6$，$1 \leq o \leq 2$，$1 \leq x, y \leq n$，且输入字符串的总长度不超过 $10^6$，输入字符串仅含小写英文字母，且不是空串。

## 样例 #1

### 输入

```
4 4
ab
cd
abcd
abcc
1 1 2
2 2 3
2 3 4
2 2 4```

### 输出

```
Yes
No
No```

# 题解

## 作者：一扶苏一 (赞：16)

# [语言月赛202304H] 写大作业 题解

## Source & Knowledge

2023 年 4 月语言月赛，由洛谷网校入门计划/基础计划提供。

本题考察字符串处理和算法技巧。

## 文字题解

### 题目大意

给出 $n$ 个字符串 $s_1, s_2, \dots s_n$，有 $q$ 次操作，要么把 $s_x$ 和 $s_y$ 拼接合并，要么比较 $s_x$ 和 $s_y$ 是否能经过重排后变成相同的字符串。

### 解析

首先思考如何判定两个字符串经过重排后可以相同，容易发现等价的条件是每个字符在字符串内出现的次数相等。例如，对 $s_1 = \texttt{abbc}$，$s_2 = \texttt{bacb}$，因为字符 $\texttt{a}$ 在两串中都出现了一次，$\texttt b$ 在两串中都出现了两次，$\texttt c$ 在两串中都出现了三次，所以两串重排后可以相等。于是问题转化成维护每个字符串中字符的出现次数。

#### 60 分做法

可以依照题意模拟，每次对于操作 $1$，使用 `string` 类的 `+=` 运算符将两个字符串拼接：

```cpp
if (o == 1) s[y] += s[x];
```

对于操作 $2$，可以开一个大小为 $26$ 的数组 $b$，$b_i$ 表示第 $i$ 个字母的出现次数。扫描一遍 $s_x$，把 $s_x$ 出现的字母在 $b$ 数组里增加 $1$，再扫描一遍 $s_y$，把 $s_y$ 出现的字母在数组里减小 $1$。最后看一遍 $b$ 数组是否全 $0$，如果是则说明两串相似，否则不相似。

注意每次操作之前都必须要清空 $b$ 数组。

```cpp
if (o == 2) {
  for (int i = 0; i < 26; ++i) b[i] = 0;
  for (int i = 0; i < s[x].length(); ++i)
    ++b[s[x][i] - 'a'];
  for (int i = 0; i < s[y].length(); ++i)
    --b[s[y][i] - 'a'];
  if (count(b, b + 26, 0) == 26) { // 这个函数的意思是找 b[0] 到 b[25] 中 0 的数量，需要 algorithm 头文件
    cout << "Yes\n";
  } else {
    cout << "No\n";
  }
}
```

#### 100 分做法

可以发现实际地拼接两个字符串是不必要的。我们最终检查的只是两串的字符出现数量。于是我们考虑直接维护字符出现数量。

具体地，设 $b_{i, j}$ 表示第 $j$ 个字符在字符串 $s_i$ 中出现的次数。

这样合并两串的时候，只需要合并两串对应的 $b$ 数组即可。检查两串是否相似是，同样只需要检查两串的 $b$ 数组。

```cpp
cin >> o >> x >> y;
if (o == 1) {
  for (int j = 0; j < 26; ++j) b[y][j] += b[x][j];
} else {
  bool ans = true;
  for (int j = 0; j < 26; ++j) if (b[x][j] != b[y][j]) ans = false;
  cout << (ans ? "Yes\n" : "No\n");
}
```

## 视频题解


**完整代码请在视频题解中查看**。

![](bilibili:BV1jo4y1L7fz?page=8)


---


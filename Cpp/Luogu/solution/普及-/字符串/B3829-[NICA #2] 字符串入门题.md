# [NICA #2] 字符串入门题

## 题目背景

小波说这是字符串入门题极好的，所以这是极好的。

## 题目描述

给定一个仅包含大小写字母和数字的字符串 $s$，问能否将 $s$ 拆分成至少 $k$ 个子串 $s_1,s_2,\dots,s_t(t\ge k)$ 满足 $\forall 1<i\le t$ 有 $s_i$ 是 $s_1s_2\dots s_{i-1}$（这里表示的是拼接）的子串。

一个字符串 $s$ 是另一个字符串 $t$ 的子串当且仅当可以通过删除 $t$ 的一个可以为空的前缀以及一个可以为空的后缀后得到 $s$。

## 说明/提示

#### 样例 1 解释

`1145|14`是一种合法的拆分方案，因为拆分出了 $2$ 个字符串且 $2\ge k$，并且`14`是`1145`的一个子串。

#### 样例 2 解释

`a1A|a1|1Aa`是一种合法的拆分方案，因为拆分出了 $3$ 个字符串且 $3\ge k$，并且`a1`是`a1A`的一个子串，且`1Aa`是`a1Aa1`的一个子串。

#### 样例 3 解释

尝试所有拆分方案后发现无论如何拆分都无法满足条件。

#### 数据范围

对于所有数据，满足 $2\le k\le n\le 10^6$，$s$ 仅由大小写字母和数字构成。

## 样例 #1

### 输入

```
6 2
114514```

### 输出

```
2
1145
14```

## 样例 #2

### 输入

```
8 2
a1Aa11Aa```

### 输出

```
3
a1A
a1
1Aa```

## 样例 #3

### 输入

```
11 2
stoImakforz```

### 输出

```
-1```

# 题解

## 作者：wmrqwq (赞：9)

# 原题链接

[B3829 [NICA #2] 字符串入门题](https://www.luogu.com.cn/problem/B3829)

# 题目简述

现在有一个字符串 $s$，你需要将字符串 $s$ 拆分成至少 $k$ 段子串，并需要满足每一个子串都为拆分后字符串的第一个子串的子串，并依次输出拆分成的字段数量和这些子串，若无法满足条件，则输出 $-1$。

# 解题思路

首先，因为拆分后所有的子串都需要为拆分后字符串的第一个子串的子串，所以我们就需要让拆分后的第一个字符串尽量的长，因为这样就能让第一个字符串的字符变多，进而可以让后面的子串成为第一个字符串的子串的可能性更大。

然后我们就得出了结论：**需要尽可能的增加拆分后第一个字符串的长度。**

接着我们再来推一下这个结论的逆定理，因为我们要尽可能增加第一个字符串的长度，所以我们就要使得后面的字符串的长度尽量的短，因为要最短，所以后面的字符串的长度就需要为 $1$，因为这样我们就能尽可能增加第一个字符串的长度了，**因此，我们只需要从后面依次拆分每个字符即可。**

而题目中要求我们至少要拆分 $k$ 个子串，因为我们要让第一个字符串最长，**所以只需要拆分为正好 $k$ 个子串即可。**

推出了结论，我们就可以用程序解决问题了。

我们只需要开一个桶，存储每一个字符的数量，不过需要注意，不用存储后 $k-1$ 个字符，因为这些字符我们是必然需要拆分的，因此只需要判断后 $k-1$ 个字符有没有在前面出现过即可，若没有，则直接输出 $-1$。否则我们直接依次输出这 $k$ 个子串即可。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define QwQ return 0;
long long pd[1010],n,m;
string s;
int main(){

	cin>>n>>m>>s;
	for(int i=0;i<n-m+1;i++) 
		pd[s[i]]=1;//先把前 n-k+1 个字符装桶里存储
	for(int i=n-m+1;i<n;i++)
		if(!pd[s[i]])//如果前面没有后面 k-1 个字符，则直接输出 -1
		{
			cout<<-1;
			QwQ;
		}
	cout<<m<<endl;	//否则直接依次输出这 k 个子串即可。
	for(int i=0;i<n-m+1;i++) 
		cout<<s[i];
	cout<<endl;
	for(int i=n-m+1;i<n;i++) 
		cout<<s[i]<<endl;
	QwQ;
}
```

---

## 作者：Clarinet (赞：5)

# 简要题意
给出一字符串，请问能否将其分成至少 $k$ 个子串，并且要求后面的子串是前面分出子串的子串。若不能，则输出负一。
# 分析
对于想我一样字符串学的很差的蒟蒻，读懂题目都是很难的。但是这道题给到了 Special Judge 就可以一定程度上说明每个样例不止一种情况。那让我们想一种最极端且好想的情况，既然要分成 $k$ 个子串，那么我们就让第一个子串最长，后面的每一个长度都为 $1$。毕竟子串必须是连续的，如果长度更大的话满足的可能性必然更小。这样一来，我们只需要记录前 $n-k+1$ 个字符中出现的各个字符，再判断后面的字符有没有新的，就能解决这道题啦。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t[10000];
string a;
int main(){
	cin>>n>>k>>a;
	for(int i=0;i<=n-k;i++)t[a[i]]=1;
	for(int i=n-k+1;i<n;i++){
		if(!t[a[i]]){
			cout<<-1;
			return 0;//后面出现前面未出现的字符 
		}
	}
	cout<<k<<endl;
	for(int i=0;i<=n-k;i++)cout<<a[i];
	cout<<endl;
	for(int i=n-k+1;i<n;i++)cout<<a[i]<<endl;
	return 0;
}
```
感谢阅读！

---

## 作者：midsummer_zyl (赞：2)


[题目传送门](https://www.luogu.com.cn/problem/B3829)


### 简要概括：
 
将字符串$s$ 拆分成 $t$ 个字符串。

如果不存在拆分方案，输出 ``-1``。

### 思路：

以前面部分的 ``n−k+1`` 个字符为主串，剩下的字符为子串，

然后用一个布尔类型的数组记录字符是否出现过即可。

## [AC代码如下：](https://www.luogu.com.cn/record/124967028)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
long long n, k;
bool s2[N];
int main() {
	memset(s2, 0, sizeof(s2));
	cin >> n >> k;
	string s;
	cin >> s;
	long long sum = n - k;
	for (int i = 0; i <= sum; i++)
		s2[(int)s[i]] = 1;
        //标记为1
	for (int i = sum + 1; i < n; i++) {
		if(s2[(int)s[i]] == 0) {
			printf("-1");
			return 0;
		}
      	//判断无解的情况
	}
	cout << k << endl;
	for (int i = 0; i <= sum; i++)
		cout << s[i];
	cout << endl;
	for (int i = sum + 1; i < n; i++)
		cout << s[i] << endl;
	return 0;
}
```


---

## 作者：zheng_zx (赞：1)

# B3829 [NICA #2] 字符串入门题

[题目传送门](https://www.luogu.com.cn/problem/B3829)


## 题意


给定一个字符串 $s$，问能否把它划分成至少 $k$ 个非空子串，且使每个子串都是其在原序列前的主串的子串。

## 分析

既然要把主串 $s$ 分成 $k$ 个子串，那么我们干脆直接让第一个子串最长，后面的每个子串长度都为 $1$。这样一来，我们只需先输出前 $n-k+1$ 个字符，再遍历一遍后面的字符，如果没有出现过，那么直接输出 $-1$ 即可通过此题。

### AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, k, pos[10005], num = 0;
string s;

int main(){
	cin >> n >> k >> s;
	num = n - k + 1;
	for(int i = 0; i < num; ++i)
		pos[s[i]] = 1;//把出现过的字符标记为 1 
	for(int i = num; i < n; ++i)
		if(!pos[s[i]])//判断无解时的所有情况
		{ 
			cout << -1 << endl;//未出现则输出 -1 
			return 0;//结束运行 
		}
	cout << k << endl;
	for(int i = 0; i <= n - k; ++i)
		cout << s[i];//输出主串 
	cout << endl; 
	for(int i = num; i < n; ++i)
		cout << s[i] << endl;//输出子串 
	return 0;//结束运行 
}
```

~~本蒟蒻第二次写题解，管理大大求过~~

---

## 作者：封禁用户 (赞：1)

## 题目大意
给出一字符串，请问能否将其分成至少 $k$ 个子串，并且要求后面的子串是前面分出子串的子串。若不能，则输出 $-1$ 。

------------

## 大致思路

以前面部分的 $n - k + 1$ 个字符为主串，剩下的字符为子串，

然后用一个布尔类型的数组记录字符是否出现过即可。

## 直接上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
long long n, k;
bool s2[N];
int main()
{
    memset(s2, 0, sizeof(s2));
    cin >> n >> k;
    string s;
    cin >> s;
    long long sum = n - k;
    for (int i = 0; i <= sum; i++)
    {
		s2[(int)s[i]] = 1;
	} 
    //标记为1
    for (int i = sum + 1; i < n; i++)
	{
        if (s2[(int)s[i]] == 0)
		{
            printf("-1");
            return 0;
        }
        //判断无解的情况
    }
    //输出 
    cout << k << endl;
    for (int i = 0; i <= sum; i++)
    {
		cout << s[i];
	} 
    cout << endl;
    for (int i = sum + 1; i < n; i++)
    {
		cout << s[i] << endl;
	} 
    return 0;
}
```

审核大大让过一下吧，这是我的第一个题解qwq。

---

## 作者：LiJinLin_AFO (赞：1)

# B3829 题解

说实话，当我第一眼看到这题时，我的心态已经开始爆炸了。然而，那个显眼的 Speacial Judge 让我的嘴角微微上扬。

既然这样，我们就可以推断出一个“万能”的公式。

至少需要 $k$ 个子串，那么就输出 $k$ 个子串，这是正常人类的思维。

不过，如何分配并输出这些子串，是一个问题。对于这类题目，我们需要用到贪心策略。

设字符串长度为 $len$，我们可以先输出前 $len-k+1$ 个字符，然后在遍历一遍后面的字符，如果没有在之前的 $len-k+1$ 个字符中出现，那么肯定没有合法的方案，输出 $-1$。

如果满足上面的条件，就输出以下 $3$ 个部分：

1. 一个整数，即 $k$。

2. 一行，即前 $len-k+1$ 个字符。

3. $k-1$ 行，即接下来的 $k-1$ 个字符。

```cpp
#include<iostream>
#include<stdio.h>
#include<string>
#include<map>
using namespace std;
string a;
map<char,bool> m;
int main(){
    int n,k;
    cin>>n>>k>>a;
    int l=a.size();
    for(int i=0;i<=l-k;i++) m[a[i]]=true;//将前 len-k+1 个字符的存在情况放入 map
    for(int i=l-k+1;i<l;i++){
        if(!m[a[i]]){
            printf("-1");
            return 0;
        }//判断这个是否在前 len-k+1 个字符中出现，没有输出-1
    }
    printf("%d\n",k);
    for(int i=0;i<=l-k;i++) putchar(a[i]);
    puts("");
    for(int i=l-k+1;i<l;i++) printf("%c\n",a[i]);
  //输出答案
    return 0;
}
```


---

## 作者：aCssen (赞：1)

### Solution
首先，每一个字符的第一次出现都应在 $s_1$ 中。

否则，如果 $s_i$ 中有一个在 $s_1 \sim s_{i-1}$ 中没有出现过的字符，则 $s_i$  显然不可能是前 $i-1$ 个字符串拼接而成的子串。

因此，我们找到在 $s$ 中出现的所有字符中**第一次出现的位置最靠后**的字符第一次出现的位置 $p$，则前 $p$ 个字符构成第一个分割出来的串。

又因为我们分割的数目应该尽量多，以满足 $t \ge k$ 的限制，所以我们应将 $p$ 后每个字符划分为一个串，因为每个字符都在第一个串中出现过，所以这个方案一定合法。

如果这样划分的字符串数量都 $<k$，则无解。
### Code
用了一些奇奇怪怪的写法。
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
const int maxn=1e6+5;
int a[maxn],pos[200],len;
bool vis[200];
int main(){
    int n,k;
    scanf("%d%d\n",&n,&k);
    for(int i=1;i<=n;i++){
        char c=getchar();
        if(c>='0'&&c<='9') a[i]=c-'0'+1;
        if(c>='A'&&c<='Z') a[i]=c-'A'+11;
        if(c>='a'&&c<='z') a[i]=c-'a'+37;
    }
    for(int i=n;i>=1;i--){
        pos[a[i]]=i;
        vis[a[i]]=1;
    }
    for(int i=1;i<=100;i++)
        if(vis[i]) len=max(len,pos[i]);
    if(n-len+1<k) printf("-1");
    else
    {
        printf("%d\n",n-len+1);
        for(int i=1;i<=len;i++){
            if(a[i]>=1&&a[i]<=10) printf("%c",a[i]-1+'0');
            if(a[i]>=11&&a[i]<=36) printf("%c",a[i]-11+'A');
            if(a[i]>=37) printf("%c",a[i]-37+'a');
        }
        printf("\n");
        for(int i=len+1;i<=n;i++){
            if(a[i]>=1&&a[i]<=10) printf("%c",a[i]-1+'0');
            if(a[i]>=11&&a[i]<=36) printf("%c",a[i]-11+'A');
            if(a[i]>=37) printf("%c",a[i]-37+'a');
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：Chenyichen0420 (赞：1)

## 简要题意

问你是否有方法将一个字符串 $s$ 切分成至少 $k$ 份，使得每一份都是其在原序列前的字符串的子串（第一串除外）。

## 思路分析

其实很容易想到一个思路，只分成 $k$ 份，其中的后 $k-1$ 份是结尾起的 $k-1$ 个字符。

首先关于只分成 $k$ 份应该都没有疑问吧？毕竟份数越少成功的可能性越大。

其次就是为什么一定是从结尾开始的 $k-1$ 个字符了。

这时我们观察一下对于这么一个例子 `abcddab`。假设让你分成三份。

我们发现让 `ab` 作为其第一串，让 `d` 作为其第二串一定是可以的。但是对于一个长度非一的长串，若这个长串满足，则其中的每一个字符单独成串一定满足。反之每一个字符都满足，其拼成的串却不一定满足（例如 `da` 之类的）！因此，让结尾的字符作为串一定比将一个长串作为串更优！

至此，此题完结。附上代码（镜像赛赛时）：

```cpp
#include<iostream>
#include<string>
using namespace std;
int n, k; string t, t_;
inline bool check(int ncl) {
	if (ncl == k) return 1;
	char cec = t[t.size() - 1];
	t.erase(t.end() - 1);
	if (t.find(cec) == -1) return 0;
	return check(ncl + 1);
}
inline void out(int nou) {
	if (nou == 0) cout << t_ << endl;
	else {
		char c = t_[t_.size() - 1];
		t_.erase(t_.end() - 1);
		out(nou - 1); cout << c << endl;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin >> n >> k >> t_; t = t_;
	if (check(1)) {
		cout << k << endl;
		out(k - 1);
	}
	else cout << "-1\n";
	return 0;
}
```

---

## 作者：lrqlrq250 (赞：0)

## 题意简述
问一个长度为 $n$ 的字符串能否被划分成至少 $k$ 个非空串，满足每个非空串都是它在原序列中前面所有字符拼接起来形成字符串的子串。

## 解题思路
注意到一个结论：对于每一个在原字符串中出现过的字符，它第一次出现必须要在被分出来的第一个串中，否则它之前的字符串中一定没有这个字符，自然也不会是它之前的字符串的子串。

因此我们先记录每一种出现过的字符第一次出现的位置，设这其中最靠后的位置为 $p$，我们将 $s_1s_2s_3 \dots s_p$ 作为第一个串，这时 $\forall p < i \leq n$，$s_i$ 都一定在第一个串中出现过了，便可以直接令每一个字符为一个串，这样就有了 $n - p + 1$ 个串，判断其是否不小于 $k$ 即可。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[1000005];
unordered_map<char, int> pos;


int main(){
	int n, k;
	scanf("%d%d", &n, &k);
	scanf("%s", s + 1);
	for (int i=1; i<=n; i++){
		if (!pos[s[i]]) pos[s[i]] = i;
	}
	int maxn = -1;
	for (unordered_map<char, int>::iterator it=pos.begin(); it != pos.end(); it++) maxn = max(maxn, (*it).second);
	if (maxn > n - k + 1) printf("-1\n");
	else{
		printf("%d\n", n - maxn + 1);
		for (int i=1; i<=maxn; i++) printf("%c", s[i]); printf("\n");
		for (int i=maxn+1; i<=n; i++) printf("%c\n", s[i]);
	}
	return 0;
}
```


---

## 作者：xibaohe (赞：0)

# 题目大意
给你一个字符串，问你能否把字符串切割成至少 $k$ 个子串，使后面的子串为前面子串的子串。

# 样例解读
![](https://cdn.luogu.com.cn/upload/image_hosting/rob646mu.png)


# 题目思路
考虑到这道题有 Special Judge，我们可以考虑极端情况。以前 $n-k+1$ 个字符为主串，剩下的每一个字符为子串，然后用一个 $vis$ 数组记录字符是否出现过即可。

# 优化方案
我的思路整体上与 xinyu123 较为相像，但我的代码在此基础上进行了两项优化。

- 本道题不需要用 map 记录字符是否出现，只需要以字母强制转成的数字为下标开普通数组即可。

- 输出时可以使用 `s.substr(1,n-k+1)` 而不需要循环枚举。

# 满分代码
加上了代码注释，但压行比较严重，不喜勿喷。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string s;
bool vis[205];
int main(){
    cin>>n>>k>>s;
    s=" "+s;//加一个空格方便调用
    for(int i=1;i<=n-k+1;i++) vis[int(s[i])]=1;//优化一
    for(int i=n-k+2;i<=n;i++){//判断无解情况
        if(vis[int(s[i])]==0){cout<<-1<<endl;return 0;}
    }
    cout<<k<<endl;
    cout<<s.substr(1,n-k+1)<<endl;//优化二
    for(int i=n-k+2;i<=n;i++) cout<<s[i]<<endl;
    return 0;
}
```


---


# [语言月赛 202311] 基因

## 题目描述

有一个长度为 $n$ 的字符串 $S$。其只包含有大写字母。

小 A 将 $S$ 进行翻转后，得到另一个字符串 $S'$。两个字符串 $S$ 与 $S'$ 对应配对。例如说，对于 $S=\tt{ATCGT}$，则有 $S'=\tt{TGCTA}$，$S$ 与 $S'$ 进行配对。

对于两个字符串 $S,S'$ 的第 $i$（$1 \leq i \leq n$）个字母，配对规则如下：

- 定义 $\tt A$ 与 $\tt T$，$\tt C$ 与 $\tt G$ 为可以配对的字母。
- 如果 $S_i$ 与 $S_i'$ 为可以配对的字母，那么该字符串的稳定性增加 $i$。
- 如果 $S_i$ 或者 $S_i'$ 中任意一方出现非 $\tt A,\tt T,\tt C,\tt G$ 的字母，则整个字符串的稳定性将直接为 $0$。

现在给定 $T$ 个字符串 $S$，对每一个字符串，询问若用其翻转再进行配对，其稳定性将如何。

## 说明/提示

**【样例解释】**

- 对于第一个字符串，$S=\tt{\red{A}TCG\blue{T}}$，$S'=\tt{\red{T}GCT\blue{A}}$。标红色的一组与蓝色的一组为可以配对的字母。它们分别是 $S$ 的第 $1$ 个字母和第 $5$ 个字母，因此稳定性是 $1+5=6$。
- 对于第二个字符串，$S=\tt{\red{A}\blue{C}\red{A}\blue{T}\red{G}\blue{T}}$，$S'=\tt{\red{T}\blue{G}\red{T}\blue{A}\red{C}\blue{A}}$，每个对应位置上的字母都可以配对，因此稳定性是 $1+2+3+\dots+6=21$
- 对于第三条字符串，出现了非 $\tt A,\tt T,\tt C,\tt G$ 的字母 $\tt U$，因此稳定性为 $0$。

**【数据范围】**

对于所有数据，保证：$1\leq T\leq 5$，$1\leq n\leq 10^5$，$S$ 中出现的所有字母保证为大写英语字母。

## 样例 #1

### 输入

```
3
5
ATCGT
6
ACATGT
5
ATCGU```

### 输出

```
6
21
0```

# 题解

## 作者：chen_zhe (赞：2)

# Source & Knowledge

2023 年 11 月语言月赛，由洛谷网校入门计划/基础计划提供。

考察字符串的运用。

# 文字题解

本题考察字符串的运用。首先，我们应该如何读取一个字符串呢？这里有多种方式：

对于字符串（string）类型的变量 s，以下都是可能的读入方式：

```
cin >> s;//读入一个字符串，读到空格或者换行截断
getline(cin,s);//读入一整行字符
```

对于字符数组类型的字符串 ch[]，以下都是可能的读入方式：

```
cin >> ch;//从 ch[0] 开始填充字符数组，每个字符占一位
scanf("%s",ch);//同上
cin >> (ch+1);//从 ch[1] 开始填充字符数组，在 C++20 以后被弃用。
fgets(ch,MAX_SIZE,stdin);//读入一行的字符填充入字符数组中，其中 MAX_SIZE 可以理解为一次性最多允许读入的字符量
```

而不推荐使用以下方式读入字符或者字符串：

```
char ch=getchar();//容易被各种平台下的换行符坑害
gets(s);//被弃用
```

假设我们现在使用了任何一种字符串的读入方式读入下了这个字符串，接下来我们应当如何处理翻转呢？

方法 1：使用 `std::reverse()` 函数。对于使用了字符串（string）而言，直接使用 `reverse(s.begin(),s.end())`，就可以翻转一条字符串 $s$ 了（需要头文件：algorithm）。

方法 2：使用一个循环。具体而言，假设我们下标从 $0$ 到 $n$ 去存储一个字符串 $s$，那么其翻转后的字符串 $s1$ 可以用这种方式获得：

```cpp
for (int i=0;i<n;i++)
	s1[i]=s[n-i-1];
```

接着我们只需根据题意，找出字符串中不为 $\tt A,\tt T,\tt C,\tt G$ 的那些字符，再让字符进行配对就可以了。

问题真的就这么结束了吗？并没有那么容易。这个题目最大的坑点在于稳定度最大能够是多少？很显然，我们可以构造出一个像 $\tt{AAATTT}$ 的字符串，其每一位都能配对得上，贡献一次稳定度。也就是说，稳定度的最大值是：

$$1+2+3+\dots+n=\dfrac{n(n+1)}{2}$$

代入 $n=100000$ 的上限，可知其大约是 $5\times 10^9$ 的范围，恰好超过了 int 类型所能容纳的最大值（约 $2.1\times 10^9$），因此需要使用 long long 类型的变量存储该值。

详细的代码请参考视频题解。

![](bilibili:BV1jz4y1A7Mz?page=7)

---


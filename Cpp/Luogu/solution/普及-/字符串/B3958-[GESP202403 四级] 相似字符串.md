# [GESP202403 四级] 相似字符串

## 题目描述


对于两个字符串 $A$ 和 $B$，如果 $A$ 可以通过删除一个字符，**或**插入一个字符，**或**修改一个字符变成 $B$，那么我们说 $A$ 和 $B$ 是相似的。

比如 $\texttt{apple}$ 可以通过插入一个字符变成 $\texttt{applee}$，可以通过删除一个字符变成 $\texttt{appe}$，也可以通过修改一个字符变成 $\texttt{bpple}$。因此 $\texttt{apple}$ 和 $\texttt{applee}$、$\texttt{appe}$、$\texttt{bpple}$ 都是相似的。但 $\texttt{applee}$ 并不能 通过任意一个操作变成 $\texttt{bpple}$，因此它们并不相似。

特别地，两个完全相同的字符串也是相似的。

给定 $T$ 组 $A,B$，请你分别判断它们是否相似。

## 说明/提示

对全部的测试数据，保证 $1 \leq T \leq 100$，$A$ 和 $B$ 的长度不超过 $50$，仅含小写字母。

## 样例 #1

### 输入

```
5
apple applee
apple appe
apple bpple
applee bpple
apple apple```

### 输出

```
similar
similar
similar
not similar
similar```

# 题解

## 作者：yedalong (赞：252)

[点这里观看更佳](https://www.luogu.com.cn/article/col0ou2r)   
[题目传送门](https://www.luogu.com.cn/problem/B3958)


------------

个人觉得此题还行，~~我不会告诉你我提交了三次。~~
# 思路
把删除字符和增加字符两种操作合并成一种，本人没有做任何字符串操作。我分成了以下三种情况：  
1.两个字符串长度相等，改变字符串方式只有改变字符串中的字符一种方式，所以只需在两个字符串中寻找不相同字符个数，如果不相同字符数小于等于 $1$,就可以，否则不行。  
2.两个字符串长度相差等于 $1$，先将长度长度字符串放在第一个，方便操作。只需在两个字符串中遍历，整个标记，在第一个不相同的字符改标记，标记代表第二个字符串中已经有插入过数，以后坐标都改成 $i+1$。当标记为 $1$ 时，在后面还能找到不同的字符，也是没救的。  
3.两个字符串长度相差大于 $1$，这是没救的。
# AC code:
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int main(){
    int n;cin>>n;//输入
    while(n--){
        string a,b;cin>>a>>b;//输入
        if(a.size()<b.size()) swap(a,b);//统一字符串 a 最长，方便操作
        if(a.size()-b.size()>1){//如果长度相差大于 1，无论怎么做都无法一样
            cout<<"not similar"<<endl;
            continue;
        }
        if(a.size()-b.size()==1){//如果相差 1 就统一让字符串 b 增加一个字母
            int ans=0,f=0;//ans 代表 b[i] 当前是否有和 a[i] 不相等
            for(int i = 0;i<b.size();i++){
                if(a[i+ans]!=b[i])ans=1;//如果不相等 ans 就为 1
                if(ans&&a[i+ans]!=b[i]){//如果 ans 已经为 1 了还不相等就没救了
                    cout<<"not similar"<<endl;
                    f=1;
                    break;//要退循环，不然你会看见好多个 not similar
                }
            } 
            if(f==0) cout<<"similar"<<endl;
        }
        if(a.size()==b.size()){//如果长度相等，直接判断 a 和 b 有多少个不相等
            int sum=0;
            for(int i = 0;i<a.size();i++){
                if(a[i]!=b[i]) sum++;//统计有多少个不相等
            }
            if(sum<=1) cout<<"similar"<<endl;//不相等数量小于等于 1 是就可以
            else cout<<"not similar"<<endl;
        }
    }
  return 0;//完结撒花
}
`````
~~码字辛苦，管理员给过。。。~~  
~~都看完了，点个赞再走吧 qwq~~

---

## 作者：xyx404 (赞：31)

## 思路：
因为只有通过删除一个字符，或插入一个字符，或修改一个字符变成另一个字符串才是相似的，所以我们可以分成五种情况。

第一种情况，如果第一个字符串和第二个字符串是相同的，那么这两个字符串是相似的，代码如下。
```cpp
if(a==b){// 特判如果 a 与 b 相同的情况 
	cout<<"similar\n";continue;
}
```


第二种情况，如果第一个字符串的长度等于第二个字符串的长度且两个字符串不相同，如果它们是相似的，那么只能是修改一个字符出来的，两个字符串之间至少有第一个字符串的长度减一个字符是相同的，且位置相同，代码如下。
```cpp
if(a.size()==b.size()){// a 的长度与 b 的长度相同
	for(int i=0;i<a.size();i++){
		if(a[i]==b[i])cnt++;// 都用 i 因为要在同一个位置 
	}
	if(cnt+1==a.size()||cnt==a.size()){// 至少有 a.size()-1 个字符相同且在同一个位置 
		cout<<"similar\n";
	}
	else cout<<"not similar\n";
}
```


第三种情况第一个字符串的长度比第二个字符串的长度小一，如果它们是相似的，那么只能是通过插入一个字符出来的，这下不用是同一个位置了，但是顺序要一样，所以我们可以定义一个变量 $cc$ 用来储存现在历遍到了第一个字符串的第几个字符，第二个字符串用循环历遍，代码如下。
```cpp
else if(a.size()+1==b.size()){//a 的长度加一等于 b 的长度 
	for(int i=0;i<b.size();i++){
		if(a[cc]==b[i])cnt++,cc++;
	}
	if(cnt==a.size()){// 因为是插入的所以相同的要有 a 的长度个，也就是去掉那个插入的字符后要完全相同 
		cout<<"similar\n";
	}
	else cout<<"not similar\n";
}
```


第四种情况第一个字符串的长度比第二个字符串的长度大一，如果它们是相似的，那么只能是通过删除一个字符出来的，因为它们是相似的所以可以看做第一个字符串是第二个字符串通过插入操作得到的，只需要交换两个字符串然后和第三种情况一样写就可以了，代码如下。
```cpp
else if(a.size()-1==b.size()){// a 的长度减一等于 b 的长度 
	swap(a,b);// 交换 a 和 b
	for(int i=0;i<b.size();i++){
		if(a[cc]==b[i])cnt++,cc++;
	}
	if(cnt==a.size()){
		cout<<"similar\n";
	}
	else cout<<"not similar\n";
}
```


第五种情况，以上情况都不是也就是说肯定不是通过删除一个字符，或插入一个字符，或修改一个字符出现的，所以可以直接输出，代码如下。
```cpp
else{
	cout<<"not similar\n";
}
```


## 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		string a,b;
		cin>>a>>b;
		int cnt=0,cc=0;
		if(a==b){// 1
			cout<<"similar\n";continue;
		}
		if(a.size()==b.size()){// 2
			for(int i=0;i<a.size();i++){
				if(a[i]==b[i])cnt++;
			}
			if(cnt+1==a.size()||cnt==a.size()){
				cout<<"similar\n";
			}
			else cout<<"not similar\n";
		}
		else if(a.size()+1==b.size()){// 3
			for(int i=0;i<b.size();i++){
				if(a[cc]==b[i])cnt++,cc++;
			}
			if(cnt==a.size()){
				cout<<"similar\n";
			}
			else cout<<"not similar\n";
		}
		else if(a.size()-1==b.size()){
			swap(a,b);
			for(int i=0;i<b.size();i++){
				if(a[cc]==b[i])cnt++,cc++;
			}
			if(cnt==a.size()){
				cout<<"similar\n";
			}
			else cout<<"not similar\n";
		}
		else{
			cout<<"not similar\n";
		}
	} 
	return 0;
}

```

---

## 作者：spfa_ (赞：12)

[B3958 [GESP202403 四级] 相似字符串](https://www.luogu.com.cn/problem/B3958)

此题可看作为 [P2758](https://www.luogu.com.cn/problem/P2758) 的弱化版。

若题目中的操作都能进行无限次操作，那么一定是能够将 $A$ 变成 $B$ 的，那么我们只需求出变为 $B$ 的最小次数，并判断是否小于等于 $1$ 即可。

那么我们设状态 $f_{i,j}$ 表示 $A$ 中前 $i$ 个字符变成 $B$ 中前 $j$ 个字符的最小操作。那么有

$$
f_{i,j}=
\begin{cases}
i & j=0 \\
j & i=0 \\
f_{i-1,j-1} & A_{i}=B_{j} \\
\min(\min(f_{i-1,j},f_{i,j-1}),f_{i-1,j-1})+1 & A_i\ne B_i
\end{cases}
$$

最后判断即可啦~

代码：

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

bool solve() {
	string a, b; cin >> a >> b;
	int n = a.size(), m = b.size();
	vector <vi> f(n+1, vi(m+1));
	for (int i = 0; i <= n; ++i) f[i][0] = i;
	for (int i = 0; i <= m; ++i) f[0][i] = i;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			if (a[i-1] == b[j-1]) f[i][j] = f[i-1][j-1];
			else f[i][j] = min(f[i][j-1], min(f[i-1][j], f[i-1][j-1]))+1;
	return f[n][m] <= 1;
}

int main() {
	for (int t = rd(); t--; ) puts(solve() ? "similar" : "not similar");
	return 0;
}
```

---

## 作者：cmpt_xiaoxiao (赞：10)

# 题解：B3958 \[GESP202403 四级] 相似字符串

### [题目传送门](https://www.luogu.com.cn/problem/B3958)

## 分析

~~暴力出奇迹~~，主要分五种情况：

- 两个字符串直接相等
- $a$ 的长度和 $b$ 的长度相差超过 2，直接不可能。因为插入、删除只会使字符长度变化 $1$ 位
- $a$ 的长度小于 $b$ 的长度，插入
- $a$ 的长度大于 $b$ 的长度，删除
- $a$ 的长度等于 $b$ 的长度，修改

确定情况后直接枚举即可

## AC code

~~为了防止直接复制 $\sout {tj}$，加了一些防伪标记 ($\sout3$ 个够了吧 QWQ)~~

```cpp

#include<iostream>
#include<string>
#include<cmath> 
using namespace std;
int n;//数量 
string a,b;//两个字符串 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a>>b;
		if(a==b){//情况1 
			cout<<"similar"<<endl;
			continue;
		}
		if(abs(int(a.length())-int(b.length()))>=2) cout<<"not similar"<<endl;//情况2 
		else{
			bool f=0;
			if(a.length()>b.length()){//情况4
				for(int j=0;j<a.length();j++){
					string t=a;
					t.erase(j,1);//删除 
					if(t==b){
						cout<<"similare"<<endl;
						f=1;
						break;
					}
				}
			}else if(a.length()<b.length()){//情况3
				for(int j=0;j<a.length();j++){
					for(int k=97;k<=122;k++){//枚举所有情况 
						string t=a;
						t.insert(j,1,char(k));//插入 
						if(t==b){
							cout<<"similar";
							f=1;
							break;
						}
					}
					if(f) break;//二次跳出 
				}
			}else{//情况5 
				for(int j=0;j<a.length();j++){
					for(int k=97;k<=122;k++){//枚举所有情况 
						string t=a;
						t[j]=char(k);//修改 
						if(t==b){
							cout<<"similar"<<endl;
							f=1;
							break;
						}
					}
					if(f) break;//二次跳出 
				}
			}
			if(!f) cout<<"not similr"<<endl;//最后不行 
		}
	}
	return 0;
} 

```

如果您觉得对您有帮助~~关注~~点个赞吧

求过 QWQ

---

## 作者：Alex866 (赞：6)

## 题意分析
[题目](https://www.luogu.com.cn/problem/B3958)让我们判断给定的两个字符串是否相似，两个字符串相似有以下几种情况：
1. 一个字符串添加一个字符为另一个字符串。  
2. 一个字符串删除一个字符为另一个字符串。  
3. 一个字符串修改一个字符为另一个字符串。  
4. 一个字符串与另一个字符串相等。  


经过分析得到：
* 定义 4 可以直接确定。  
* 定义 1 定义 2 和可以用 for 循环来确定添加或减少的字符。  
* 定义 3 同样用 for 循环确定修改的字符，不过相对定义 1 和定义 2 循环体有所改变
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
string a,b;
bool isSimilar(string s1,string s2){
	if(s1==s2){
		return 1;     //两个字符串一样（情况 4）
	} 
	if(s1.length()==s2.length()){
		int diffCount=0;
		for(int i=0;i<s1.length();i++){
			if(s1[i]!=s2[i]){
				diffCount++;
				if(diffCount>1){
					return 0;
				}
			}
		}
		return 1;       //两个字符串长度相等，只是修改了一个字符（情况 3）
	}
	if(s1.length()<s2.length()){       //将情况 1 和情况 2 归结为一种情况
		swap(s1,s2);
	}
	for(int i=0;i<s1.length();i++){
		string temp=s1.substr(0,i)+s1.substr(i+1);      //跳过第 i 个字符
		if(temp==s2){
			return 1;
		}
	}
	return 0;
}
int main(){
	scanf("%d",&t);
	for(int i=0;i<t;i++){
		cin>>a>>b;
		if(isSimilar(a,b)){
			printf("similar\n");
		}else{
			printf("not similar\n");
		}
	}
	return 0;
}
```
~~求管理员通过~~

---

## 作者：__qkj__ (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/B3958)
## 解题思路
按题意模拟即可。

设 $A$ 长度为 $l$，$B$ 长度为 $ll$，那么：

- 当 $|l-ll|\ge2$，无解；
- 当 $l=ll$，统计不同个数 $s$，若 $s>2$，无解；
- 否则，若 $l<ll$，交换 $A,B$，接着统计不同个数 $s$，当 $a_i+s\ne b_i$，$s\gets s+1$；再如果 $a_i+s\ne b_i$ 且 $s>0$，无解。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	BREAK:
	while(t--)
	{
		string a,b;
		cin>>a>>b;
		int l=a.size(),ll=b.size();
		if(abs(l-ll)>=2)cout<<"not similar\n";
		else if(l==ll)
		{
			int s=0;
			for(int i=0;i<l;i++)
				if(a[i]!=b[i])s++;
			if(s<=1)cout<<"similar\n";
			else cout<<"not similar\n";
		}
		else
		{
			if(l<ll)swap(a,b),swap(l,ll);
			int s=0;
			for(int i=0;i<ll;i++)
			{
				if(a[i+s]!=b[i])s++;
				if(a[i+s]!=b[i]&&s)
				{
					cout<<"not similar\n";
					goto BREAK;
				}
			}
			cout<<"similar\n";
		}
	}
	return 0;
}
```

---

## 作者：CodeXTreme (赞：3)

# 一、思路
如题目描述，一共分为四种情况：
- 两个字符串完全相同：直接返回 `true`
- 修改了一个字符：遍历计数是否只修改了 $1$ 个字符
- 删除了一个字符：双指针法计数是否只删除了 $1$ 个字符
- 插入了一个字符：双指针法计数是否只插入了 $1$ 个字符
# 二、程序
不要直接抄程序！你的思路是最宝贵的，建议看一看我的思路之后先自己想一想怎么写！
```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

int T;
string A, B;

bool isSimilar(string A, string B)
{
    // 两者完全相同
    if (A == B) return true;
    
    // 初始化
    int m = A.length();
    int n = B.length();
    int cnt = 0; // 记录变化字符数量
    int l = 0, r = 0; // 记录插入、删除的位置
    
    
    // 长度差大于1
    if (abs(m-n) > 1) return false;
    
    // 两者长度相等，判断是否只修改了一个字符
    else if (m - n == 0)
    {
        for (int i = 0; i < m; i++)
        {
            if (A[i] != B[i]) cnt++;
            if (cnt > 1) return false;
        }
    }
    
    // 两者长度相差1
    else
    {
        // B比A多一个字符，判断是否插入一个字符
        if (m - n == -1)
        {
            int i = 0, j = 0;
            while (i < m)
            {
                if (A[i] != B[j])
                {
                    // 记录插入的位置
                    l = i;
                    r = j;
                    // 直接比较后面的字符是否相等
                    while (i < m && j < n)
                    {
                        if (A[i] != B[j+1]) return false;
                        i++;
                        j++;
                    }
                    
                    // 如果后面的字符都相等，则必须是A的剩余字符都相等
                    if (i < m) return false;
                    break;
                }
                else
                {
                    i++;
                    j++;
                }
            }
        }
        
        // A比B多一个字符，判断是否删除一个字符
        else
        {
            int i = 0, j = 0;
            while (i < m)
            {
                if (A[i] != B[j])
                {
                    // 记录删除的位置
                    l = j;
                    r = i;
                    // 直接比较后面的字符是否相等
                    while (i < m && j < n)
                    {
                        if (A[i+1] != B[j]) return false;
                        i++;
                        j++;
                    }
                    
                    // 如果后面的字符都相等，则必须是B的剩余字符都相等
                    if (j < n) return false;
                    break;
                }
                else
                {
                    i++;
                    j++;
                }
            }
        }
    }
    
    return true;
}

int main()
{
    cin >> T;
    while (T--)
    {
        cin >> A >> B;
        cout << (isSimilar(A, B) ? "similar\n" : "not similar\n");
    }
    return 0;
}
```

---

## 作者：TPJX (赞：2)

在解决这个问题时，我们主要依靠[编辑距离](https://www.luogu.com.cn/problem/P2758)的一个简化版本来判断字符串 $A$ 和 $B$ 是否相似。这里的“相似”定义两个字符串之间的编辑距离为 $1$ 或 $0$。

编辑距离定义了将一个字符串转换为另一个字符串所需的最小编辑操作数。

对于这个问题，我们关心的操作包括：

- **插入一个字符**：例如，将 $\texttt{apple}$ 转换为 $\texttt{applee}$。
- **删除一个字符**：例如，将 $\texttt{applee}$ 转换为 $\texttt{apple}$。
- **替换一个字符**：例如，将 $\texttt{apple}$ 转换为 $\texttt{bpple}$。

如果可以确定如果两个字符串完全相同，它们绝对是相似的。如果不完全相同，我们需要进行以下检查：

- 长度相同：比较两个字符串，只能有一个位置的字符不同。
- **长度差 1：对于较长的字符串，可以在不改变其它字符的情况下删除一个字符，使之与较短的字符串相同，或者在较短的字符串中插入一个字符使之与较长的字符串相同。**

## C++ 代码实现：

```cpp
#include <iostream>
#include <string>
using namespace std;

bool isSimilar(string a, string b) {
    int na = a.size(), nb = b.size();
    if (na == nb) {
        int cnt = 0;
        for (int i = 0; i < na; ++i)
            if (a[i] != b[i]) cnt++;
        return cnt <= 1;
    } 
    else if (abs(na - nb) == 1) {
        string s = na > nb ? a : b;
        string t = na > nb ? b : a;
        int ns = s.size(), nt = t.size();
        for (int i = 0, j = 0; i < ns && j < nt; ++i, ++j) {
            if (s[i] != t[j]) {
                return s.substr(i + 1) == t.substr(j) || s.substr(i) == t.substr(j + 1);
            }
        }
        return true;
    } 
    else {
        return false;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        string a, b;
        cin >> a >> b;
        cout << (isSimilar(a, b) ? "similar" : "not similar") << endl;
    }
    return 0;
}
```

## Python 代码实现：

```python
def is_similar(a, b):
    na, nb = len(a), len(b)
    if na == nb:
        return sum(1 for x, y in zip(a, b) if x != y) <= 1
    elif abs(na - nb) == 1:
        s, t = (a, b) if na > nb else (b, a)
        ns, nt = len(s), len(t)
        i, j = 0, 0
        while i < ns and j < nt:
            if s[i] != t[j]:
                return s[i+1:] == t[j:] or s[i:] == t[j+1:]
            i += 1
            j += 1
        return True
    return False

T = int(input())
for _ in range(T):
    a, b = input().split()
    print("similar" if is_similar(a, b) else "not similar")
```

上面代码都在判断两个字符串是否相似时使用了简化的编辑距离检查，确保对所有情况进行了覆盖。

---


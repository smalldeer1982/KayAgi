# [海淀区小学组 2023] 纸牌游戏

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

有一种纸牌游戏，游戏的规则如下：初始时玩家分数都是 $ 0 $，游戏一共进行 $ n $ 个回合，每个回合中玩家要么得分要么扣分。游戏结束时如果只有一名得分最高的玩家，那么他就是获胜者；如果有两名或两名以上的玩家最高分数相同，则其中先获得最高分的玩家为游戏的获胜者。数据保证在比赛结束时至少有一个玩家的分数为正。

## 说明/提示

### 数据范围

对于 $70\%$ 的数据，$1\leq n\leq 1000$；

对于 $100\%$ 的数据，$1\leq n\leq 10^5$。

## 样例 #1

### 输入

```
3
bob 3
alice 5
mike 2```

### 输出

```
alice```

## 样例 #2

### 输入

```
3
david 3
david 2
mike 5```

### 输出

```
david```

# 题解

## 作者：Bill_luogu (赞：4)

# [[2023 海淀区小学组] 纸牌游戏](https://www.luogu.com.cn/problem/B4195) 题解  
## 题目思路:
定义一个```map```，用它来存每个人的分数。然后每输入一个数据就比较一下是不是大于最大值，如果大于，则更新最大值和答案。  
代码:
```cpp
#include<iostream>
#include<map>
using namespace std;
int n,x;
long long maxx;
string s,ans;
map<string,int> m;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s>>x;
		m[s]+=x;//分数累加
		if(m[s]>maxx)maxx=m[s],ans=s;//更新答案和最大值
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：Chengqijun2012 (赞：2)

这道题需要用到 STL（C++标准库）中的 ```map```（映射），不会的先来看看[这里](https://blog.csdn.net/shuzfan/article/details/53115922)。

我们先声明一个 ```map<string, int> a``` 来存储每个人的分数，然后设 $name_{i}$ 表示第 $i$ 个人的名字，在让 $a_{name_{i}}$ 加上ta们的分数，最后边算边求最大值即可。

AC Code：
```cpp
#include <iostream>
#include <map>
using namespace std;
int n, s, ans = -100000;
string name, ansname;
map<string, int> a;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	while(n--){
		cin >> name >> s;
		a[name] += s;      //加上分数。如果是负数，就是自然会变成减法，不用分开算
		if(a[name] > ans) ans = a[name], ansname = name;      //这里必须是>，因为题目中要求的是第一个最高分的人，如果用>=就可能被后面的人覆盖掉
	}
	cout << ansname << "\n";
	return 0;
}
```

---

## 作者：lizhixun (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/B4195)

### $\texttt{Description}$

给定 $n$ 轮游戏，每一轮游戏会有一名小朋友加分。现在要求出最先获得最大分数的小朋友的名字。

### $\texttt{Solution}$

用 `std::map` 存储每一个小朋友的分数，并维护当前的最大值，如果当前输入的小朋友的总分大于了之前的最大值就更新最大值和答案即可。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

map<string, int> mp;
int maxx = INT_MIN;
string ans;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n;
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		string s;
		int num;
		
		cin >> s >> num;
		mp[s] += num;
		
		if (mp[s] > maxx) {
			maxx = mp[s];
			ans = s;
		}
	}
	
	cout << ans << endl;
	return 0;
}
```

完结，这题貌似跟 CSP-J2024 的 T1 差不多，都是用 map 解决。

---

## 作者：Sliarae (赞：2)

首先模拟题目中的过程，对每个人进行加分/扣分。对于每个人维护它的得分和最后一次操作的时间。

最后统计答案的时候，假设我们要比较两个人谁能赢。当然先比分数，如果分数不同，那么分数高的人赢。否则最后一次操作较早的人赢。

实现上可以用 `map`，做到用一个字符串来快速索引。

```cpp
#include <iostream>
#include <map>

using namespace std;
using Pii = pair<int, int>;

map<string, Pii> mp;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	int n;
	cin >> n;
	for (int i = 1, x; i <= n; ++i) {
		string s;
		cin >> s >> x;
		Pii v = mp[s];
		v.first += x, v.second = i;
		mp[s] = v;
	}
	string name;
	Pii val = {-1, 0};
	for (auto s : mp) {
		if (s.second.first > val.first || s.second.first == val.first && s.second.second < val.second)
			name = s.first, val = s.second;
	}
	cout << name << '\n';
	return 0; 
}
```

---

## 作者：_lxc__ (赞：1)

很显然的 `map`。`map` 有两个不同类型的参数相互映射，正好可以解决此题。

在每次的输入中，用打擂台法寻找最大值，若发现当前分数大于以前的最大值，则更新最大值为当前分数，并将答案更新为当前玩家的名字。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> mp;  //string 和 int 类型映射的 map
string a,ans;
int n,b,maxx=-1;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a>>b;
        mp[a]+=b;
		if(mp[a]>maxx){  //发现更大值
            maxx=mp[a];   //更新
            ans=a;
        } 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：TheTrash (赞：1)

### 思路

由于一个玩家在游戏里分数可能不断变化，所以不能直接找最大值，用 ```map``` 一边存储一个人的分数一边求最大值就行了。

### 代码

```cpp
#include<iostream>
#include<map>
using namespace std;
map<string,int>mp;
string s,t;
int n,k,ma;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s>>k,mp[s]+=k;
		if(mp[s]>ma) ma=mp[s],t=s;//比较求最大值
	}
	cout<<t;
}
```

---

## 作者：ikunTLE (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4195)

### 思路

用一个 `map` 类型结构 $M$，$M_S$ 代表名字为 $S$ 的人的分数。每次输入的 $S$ 和 $X$，执行加分操作 $M_S\gets M_S+X$，并判断更新后的 $M_S$ 是否大于原先的最大值。若大于，更新答案字符串和最大值。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<string,int>mp;//等同于 map
int main(){
	int n;cin>>n;
	string fs;int fnum;
	cin>>fs>>fnum;
	mp[fs]=fnum;
	string ans=fs;
	int maxx=fnum;
	while(--n){
		string s;int num;
		cin>>s>>num;
		mp[s]+=num;
		if(mp[s]>maxx)
			ans=s,maxx=mp[s];
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：LINYUHENG2 (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/B4195)

## 题意
给定 $n$ 轮游戏，每一轮游戏会有一名玩家加分。现在要求出最先获得最大分数的玩家的名字。
## 思路
可以用一个 `map` 数组存储各个玩家的得分，并维护最大值，如果一名玩家的分数**大于**最大值，更新最大值。  
要注意的是，要**大于**最大值才能更新最大值，而不是**大于等于**。因为获胜者应该是最先获得最高分的人。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
map<string,int> mp;
int maxn=-1005,n;
string ans;

int main(){
    cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		int num;
		cin>>s>>num;
		mp[s]+=num;
		if(mp[s]>maxn){
			maxn=mp[s];
			ans=s;
		}
	}
	cout<<ans;
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/206290326)

---

## 作者：yyycj (赞：0)

## 题目简述
每个人有自己的名字和分数，分数会在游戏过程中加或减，最后输出分数最高者的名字，有多个最高则输出先获得这个分数的人的名字。

## 主要思路
由于人的分数在游戏过程中会减少，所以不能在输入过程中就计算最高分数，这样在最高分数减分后，不会改变目前的最高分数。

可以创建一个结构体 `node`：
- `name` 变量表示这个人的名字。
- `score` 表示游戏结束时这个人的分数。
- `id` 表示这个人最后一次改变分数是第几条信息。

输入时先用 `unordered_map` 存下来这些信息，然后遍历 `unordered_map`，依次将这些人的信息存入 `node` 数组，最后数组按照题意结构体排序，输出排序后第 $1$ 个人的名字。

## AC Code
```cpp
#include<map>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

namespace IO {
	#ifdef ONLINE_JUDGE
	#define getchar getchar_unlocked
	#endif
	#define pc putchar
	#define gc getchar
	template<typename T> void read(T &x) { int f = 1; x = 0; char ch = gc(); while (!isdigit(ch)) { if (ch == '-')f = -1; ch = gc(); }while (isdigit(ch)) { x = (x << 1) + (x << 3) + (ch ^ 48); ch = gc(); }x *= f; }
	template<typename T, typename ...Args> void read(T &x, Args &...args) { read(x); read(args...); }
	template<typename T> void print(T x) { if (x < 0) { pc('-'); x = -x; }if (x > 9) { print(x / 10); }pc(char(x % 10 + 48)); }
	template<typename T, typename ...Args> void print(T &x, Args &...args) { print(x); pc(' '); print(args...); }
	inline void readstr(string& x) { x.clear(); char ch = gc(); while (isspace(ch)) ch = gc(); while (!isspace(ch) && ch != EOF) { x.push_back(ch); ch = gc(); } }
	inline void printstr(char* x) { for (int i = 0; i < (int)strlen(x); i++) pc(x[i]); }
	inline void printstr(string& x) { for (auto i = x.begin(); i != x.end(); i++) pc(*i); }
};
using namespace IO;

#define OUT 0
#define MAMBA return
typedef long long ll;
typedef long double db;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int man();int main(){MAMBA man();}
inline int _abs(int a) { if (a < 0) return -a; return a; }
inline int _pow(int a, int b) { int x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }
// ----------------------------
struct node {
	string name;
	int score, id;
};
// ----------------------------
node members[N];
unordered_map<string, node> mp;
// ----------------------------
bool cmp(node a, node b) {
	if (a.score != b.score) return a.score > b.score;
	return a.id < b.id;
}

int man() {
	int n; read(n);
	// ----------------------------
	int score;
	string name;
	for (int i = 1; i <= n; i++) {
		readstr(name); read(score);
		mp[name].id = i;
		mp[name].score += score;
	}
	int cnt = 0;
	for (auto i : mp) members[++cnt] = {i.first, i.second.score, i.second.id};
	sort(members + 1, members + cnt + 1, cmp);
	// ----------------------------
	printstr(members[1].name);
	MAMBA OUT;
}
/*
				 .-~~~~~~~~~-._       _.-~~~~~~~~~-.
			 __.'              ~.   .~              `.__
		   .'//   A    C    之   \./  之    真    理  \`.
		 .'//                     |                     \`.
	   .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \`.
	 .'//.-"                 `-.  |  .-'                 "-.\`.
   .'//______.============-..   \ | /   ..-============.______\`.
 .'______________________________\|/______________________________`.
*/
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4195 [2023 海淀区小学组] 纸牌游戏](https://www.luogu.com.cn/problem/B4195)
## 思路：
在本题中由于一个玩家在游戏里分数可能会不断变化，所以不能直接寻找最大值，需要用一个 `map` 容器一边存储一个人的分数一边求最大值就行了。

那么 `map` 容器要如何定义呢？众所周知，`map` 容器是有两个参数的，分别对应两种变量，其实就相当于一个数组，不过是下标可以为各种类型罢了。在本题中，这个容器的下标应该是玩家的名字，存的值是玩家的得分，再边求最大值，这题就可以解决啦！

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>m;
string s,ss;int n,k,Max;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s>>k;
        m[s]+=k;
		if(m[s]>Max)Max=m[s],ss=s;
	}
	cout<<ss;
}
``````

---


# [DTCPC 2024] 小方和小立方

## 题目背景

小方不想变成小立方。

## 题目描述

给你一个由小写字母组成的字符串，求有多少个区间 $[l,r]$，满足这个区间所表示的串是回文的，且每个字符的出现次数不超过 $2$。

## 样例 #1

### 输入

```
ababa```

### 输出

```
8```

# 题解

## 作者：littlesnake (赞：39)

### 前言

看别人枚举字串状态，我表示无语，赛时还以为是一道很难的题呢，写了马拉车，调了好久才调出来。我保证我的做法绝对新颖，时间复杂度和空间复杂度都是 $O(N)$。

### 思路

看到题目，不难想到马拉车。但是又多了一个条件：

> 每个字符的出现次数不超过 $2$。

但这样也很简单，在向外延伸时多判断一个条件即可。

### 算法详解

#### 算法由来

在求解最长回文子串的问题时，一般的思路是以当前字符为中心，向其左右两边扩展寻找回文，但是这种解法的时间复杂度是 $O(N^2)$，那么能不能将时间复杂度再降低一点？做到线性？马拉车算法就完美地解决了这个问题。

说人话就是把时间复杂度降低为 $O(N)$。

#### 预处理

回文字符串以其长度来分，可以分为奇回文（其长度为奇数）、偶回文（其长度为偶数），一般情况下需要分两种情况来寻找回文，马拉车算法为了简化这一步，对原始字符串进行了处理，在每一个字符的左右两边都加上特殊字符（肯定不存在于原字符串中的字符），让字符串变成一个奇回文。例如：

- 原字符串：`abba`，长度为 $4$。
- 预处理后：`XaXbXbXaX`，长度为 $9$。

- 原字符串：`aba`，长度为 $3$。
- 预处理后：`XaXbXaX`，长度为 $7$。

注：`X` 为特殊字符，以后使用美元符号。

#### 做法

在预处理后，先看是否超出边界 $R$，如果超出，就直接暴力向外扩展；如果没有，就先借鉴 $i$ 对于 $M$ 的中心点 $k$ 所可以扩展的最长半径，然后再暴力向外扩展。（这里还要向外扩展的原因是，可能 $k$ 在边上，无法向左或向右扩展。）

如果扩展最长半径已经超出边界，就更新边界的值。

最后打擂即可。

注意最后输出的是 $ans-1$，原因是里面加了特殊符号，导致原来长度变为原先的 $2$ 倍再加 $1$，而打擂求的是半径，因此直接减 $1$ 即可。

#### 模板

下面给出求最长回文串长度的例题和代码。

题目：[P3805 【模板】manacher](https://www.luogu.com.cn/problem/P3805)。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 11000002;
// n 代表一开始字符串的长度
// m 代表添加特殊符号后的字符串的长度
// p[i] 代表往一边能够扩展的字符数即为从 i 开始的最大回文半径 
int n, m, p[N * 2 + 2];
// s[] 代表一开始的字符串
// t[] 代表添加特殊符号后的字符串 
char s[N + 2], t[N * 2 + 3];
// 马拉车 
inline void manacher() {
	n = strlen(s + 1);
	m = 0;
	// 添加特殊符号 
	t[++m] = '$';	
	for(int i = 1; i <= n; i++) {
		t[++m] = s[i]; t[++m] = '$';
	}
	int M = 0, R = 0;
	for(int i = 1; i <= m; i++) {
		// k 是 i 对于 M 的对称点 
		int k = M * 2 - i;
		if(i > R) p[i] = 1;
		else p[i] = min(p[k], R - i + 1);
		// 暴力向外扩展 
		while(i - p[i] > 0 && i + p[i] <= m && t[i - p[i]] == t[i + p[i]])
			++p[i];
		if(i + p[i] - 1 > R) M = i, R = i + p[i] - 1;
	}
}
int main() {
	// 从 1 开始读入 
	scanf("%s", s + 1);
	manacher();
	int ans = 0;
	for(int i = 1; i <= m; i++) ans = max(ans, p[i]);
	printf("%d", ans - 1);
	return 0;
}
```

AC 记录：[link](https://www.luogu.com.cn/record/147235139)

### 小结

### 小结

马拉车算法将求解最长回文子串的时间复杂度降低到了 $O(N)$，虽然也牺牲了部分空间，其空间复杂度为 $O(N)$，但是其算法的巧妙之处还是值得学习和借鉴的。

这道题我感觉还可以枚举形态做，但是用马拉车进行求解复杂度是惊人的 $O(N)$。

个人认为这种算法应该叫条件马拉车，在朴素马拉车的基础上增加了一个条件。


### 本题代码

先放 AC 记录啦~

AC 记录：[link](https://www.luogu.com.cn/record/147250072)

```cpp
#include <bits/stdc++.h>
#define N 50010
using namespace std;
// n 代表一开始字符串的长度
// m 代表添加特殊符号后的字符串的长度
// p[i] 代表往一边能够扩展的字符数即为从 i 开始的最大回文半径 
// cnt[] 代表每个字母出现的次数
int n, m, p[N * 2 + 2], cnt[30];
// s[] 代表一开始的字符串
// t[] 代表添加特殊符号后的字符串 
char s[N + 2], t[N * 2 + 3];
// 马拉车 
inline void manacher() {
	n = strlen(s + 1);
	m = 0;
	// 添加特殊符号 
	t[++m] = '$';
	for(int i = 1; i <= n; i++) {
		t[++m] = s[i];
		t[++m] = '$';
	}
	int M = 0, R = 0;
	for(int i = 1; i <= m; i++) {
		// 每次需要清空数组
		memset(cnt, 0, sizeof(cnt));
		// k 是 i 对于 M 的对称点 
		int k = M * 2 - i;
		if(i > R) {
			p[i] = 1;
			// 本身记一次数
			if(t[i] != '$') {
				cnt[ t[i] - 'a' ] = 1;
			}
		}
		else {
			p[i] = min(p[k], R - i + 1);
			// 将之前的数据搬运过来
			for(int j = i - p[i] + 1; j <= i + p[i] - 1; j++) {
				if(t[j] != '$') cnt[ t[j] - 'a' ]++;
			}
		}
		// 暴力向外扩展，记得多加了一个条件
		while(i - p[i] > 0 && i + p[i] <= m && (t[i - p[i]] == t[i + p[i]])) {
			if(t[i - p[i]] == '$') {
				++p[i];
			}else {
				// 注意要先判断，再让 p[i] 自增，否则 p[i] 的值会改变
				cnt[ t[i - p[i]] - 'a' ] += 2;
				if(cnt[ t[i - p[i]] - 'a' ] <= 2){
					++p[i];	
				}else break; // 否则就不可以继续延伸了，跳出循环	
			}	 
		}	
		// 更新边界
		if(i + p[i] - 1 > R) M = i, R = i + p[i] - 1;
	}
}
int main() {
	// 从 1 开始读入 
	scanf("%s", s + 1);
	manacher();
	int ans = 0;
	for(int i = 1; i <= m; i++) {
		ans += p[i] / 2;
		// 直接除以二下取整得到半径
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Fujxxx (赞：6)

显然大回文串中间一定包含小回文串。

遍历每个点并以中间一个点或中间相同的两个点为中心出发向两边扩展。

扩展时判断回文以及用数组记录字母是否出现即可。

需要特别注意的是这个数组每次扩展前都要清空。

下面给出参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200;
string s;
int ans;
bool vis[MAXN];
signed main(){
	std::ios::sync_with_stdio(0);
	cin>>s;
	for(register int i=0;i<s.size();i++){
		ans++;
		memset(vis,0,sizeof(vis));
		vis[(int)s[i]]=1;
		for(register int j=1;;j++){
			if(i-j<0||i+j>=s.size()) break;
			if(s[i-j]==s[i+j]&&!vis[(int)s[i-j]]) ans++,vis[(int)s[i-j]]=1;
			else break;
		}
	}
	for(register int i=0;i<s.size()-1;i++){
		if(s[i]!=s[i+1]) continue;
		int l=i,r=i+1;
		ans++;
		memset(vis,0,sizeof(vis));
		vis[(int)s[i]]=1;
		for(register int j=1;;j++){
			if(l-j<0||r+j>=s.size()) break;
			if(s[l-j]==s[r+j]&&!vis[(int)s[l-j]]) ans++,vis[(int)s[l-j]]=1;
			else break;
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```


---

## 作者：ran_qwq (赞：4)

分两类。

1. $2\nmid r-l+1$。枚举回文串中间那个位置 $mid$，一步一步往两边扩展，同时记录每个字符出现次数 $cnt_i$。设当前最左边位置是 $j$，最右边是 $k$。如果 $s_j\ne s_k$ 或者 $cnt_{s_j}>2$，再或者 $cnt_{s_k}>2$ 则 break。

1. $2\mid r-l+1$。枚举中间偏右那个位置 $mid$，和 $2\nmid r-l+1$ 时同样，一步一步往两边扩展，同时记录每个字符出现次数。

因为每个字符最多出现两次，所以回文串长度小于等于 $2|S|=52$。时间复杂度 $O(n|S|)$。

```cpp
string s;
void QwQ() {
	cin>>s;int n=s.size(),cnt=0;
	for(int i=0;i<n;i++) {
		vector<int>v(26);v[s[i]-'a']++,cnt++;
		for(int j=i-1,k=i+1;~j&&k<n;j--,k++) {
			if(s[j]!=s[k]) break;
			v[s[j]-'a']++,v[s[k]-'a']++;
			if(v[s[j]-'a']<=2&&v[s[k]-'a']<=2) cnt++;
			else break;
		}
	}
	for(int i=1;i<n;i++) {
		if(s[i-1]!=s[i]) continue;
		vector<int>v(26);
		v[s[i-1]-'a']++,v[s[i]-'a']++,cnt++;
		for(int j=i-2,k=i+1;~j&&k<n;j--,k++) {
			if(s[j]!=s[k]) break;
			v[s[j]-'a']++,v[s[k]-'a']++;
			if(v[s[j]-'a']<=2&&v[s[k]-'a']<=2) cnt++;
			else break;	
		}
	}
	wr(cnt,"");
}
```

---

## 作者：Register_int (赞：4)

若每个字母都不能出现超过两次，那么这个回文串的长度必定不会超过 $2|\Sigma|=52$。直接枚举回文中心与回文串长度判断即可。时间复杂度 $O(n|\Sigma|)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 5e4 + 10;

int n, cnt[26], ans; char s[MAXN];

int main() {
	scanf("%s", s + 1), n = strlen(s + 1);
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < 26; j++) cnt[j] = 0;
		cnt[s[i] - 'a'] = 1, ans++;
		for (int j = i, k = i; j > 1 && k < n; ) {
			if (++cnt[s[--j] - 'a'] > 2 || ++cnt[s[++k] - 'a'] > 2) break;
			if (s[j] != s[k]) break; ans++;
		}
		for (int j = 0; j < 26; j++) cnt[j] = 0;
		for (int j = i + 1, k = i; j > 1 && k < n; ) {
			if (++cnt[s[--j] - 'a'] > 2 || ++cnt[s[++k] - 'a'] > 2) break;
			if (s[j] != s[k]) break; ans++;
		}
	}
	printf("%d", ans);
}
```

---

## 作者：icypenguin (赞：2)

### 闲话

比赛的时候被队友带飞，rk77，这个题是我完成的两个题中的第一个题。


### 思路分析

因为每个字符的出现次数不超过 $2$，很明显，符合这个条件的串的长度最大为可选字符的数量的 $2$ 倍。因为可选所有小写字母，所以 符合这个条件的串的长度最大为 $26 \times 2 = 52$。

接着枚举所有 $r - l \leq 52$ 并且 $1 \leq l \leq r \leq n$ 的 $l$、$r$，并一一判断这两个条件即可，时间复杂度是 $O(l^2n)$ 的，$l$ 表示符合第一个条件的最大串长度，即 $52$。可以通过本题。

### 代码实现


```cpp
#include <iostream>
#define ll long long
using namespace std;
string s;
ll n, t[35], cnt = 0;
char c[1000005];
int main(){
    cin >> s;
    n = s.size();
    for (ll i = 1; i <= n; i++){
        c[i] = s[i - 1];
    }
    for (ll i = 1; i <= n; i++){
        for (ll j = i; j <= min(i + 51, n); j++){
            for (ll k = 0; k <= 25; k++){
                t[k] = 0;
            }
            for (ll k = i; k <= j; k++){
                t[c[k] - 'a']++;
            }
            bool flg = true;
            for (ll k = 0; k <= 25; k++){
                if (t[k] > 2){
                    flg = false;
                    break;
                }
            }
            if (!flg){
                continue;
            }
            string s1 = "", s2 = "";
            for (ll k = i; k <= j; k++){
                s1 += c[k];
            }
            for (ll k = j; k >= i; k--){
                s2 += c[k];
            }
            if (s1 == s2){
                cnt++;
            }
        }
    }
    cout << cnt << endl;
    return 0;
}
```


---

## 作者：xu_zhihao (赞：2)

### 题目理解：

- 这道题其实就是枚举每一个字串，顺便统计是否有出现次数大于 $2$ 的字母，判断这个字串是否是回文串，因为跑不满 $O(\frac{n^2}{2})$，复杂度只能算的上是 $O(n)$ 级别的，字符串的长度只能算的上是一个常数，因为字串长度最多为 $52$，所以不会超时的。

### AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int flag[30];
bool cmp(string s,int len)
{
	int p=len/2;
	for(int i=0;i<p;i++)
	{
		if(s[i]!=s[len-i-1]) return false;
	}
	return true;
}
int main()
{
	string s;
	cin>>s;
	int len=s.size();
	int sum=len;
	for(int l=0;l<len;l++)
	{
		string k;
		k+=s[l];
		flag[s[l]-'a']++;
		for(int r=l+1;r<len;r++)
		{
			k+=s[r];
			flag[s[r]-'a']++;
			if(flag[s[r]-'a']>2)
			{
				break;
			}
			if(cmp(k,r-l+1))
			{
				sum++;
			}
		}
		memset(flag,0,sizeof(flag));
	}
	cout<<sum;
}
```


---

## 作者：luogu10086 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P10170)

### PART 1

整体思路：

要求回文串里每个字母最多出现 $2$ 次，那么每个字母都出现过的情况下，因为 $26 \times 2 = 52$，所以字串长度最多只有 $52$ 个字符。

所以枚举子串时最多枚举到长度为 $52$ 的字符串，直接乱判断乱找就得了，简单粗暴。

--------

### PART 2

代码实现：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
string s,a;
int cnt,mp[30]={0};
int nmin(int a,int b){
    return (a<b?a:b);
}
bool check(string s){
    memset(mp,0,sizeof mp);
    for(int i = 0;i < s.size()/2;i ++){
        if(s[i]!=s[s.size()-1-i])return false;
        mp[s[i]-'a']+=2;
        if(mp[s[i]-'a']>2)return false;
    }
    if(s.size()%2==1)//长度为奇数时注意正中央的字母
    if(mp[s[s.size()/2]-'a']>1)return false;
    return true;
}
signed main(){
    cin>>s;
    cnt+=s.size();//单个字母也回文
    int len=nmin(52,cnt);//最长也就那么长
    for(int i = 2;i <= len;i ++){
        for(int j = 0;j <= s.size()-i;j ++){
            a="";//拿来记录纸糊串
            for(int k = j;k < j+i;k ++)a+=s[k];
            if(check(a))cnt++;//直接乱判就完蛋
        }
    }
    cout<<cnt;
}
```

---

## 作者：AAA404 (赞：1)

水题，看到回文串想到 `PAM`，发现字符集很小直接暴力建 `PAM` 然后统计。

大概说一下怎么统计每个字母的出现次数：

对于 `PAM` 上每一个节点，它代表了一个回文串，那么直接暴力遍历统计是 $O(n^2)$ 的，一点都不优雅，我们考虑怎么从已有状态转移。

这是十分容易的，因为对于一个状态，对比其在 `PAM` 中的前继状态，仅仅是在前后两端多了两个相同字符，并且字符集很小，所以暴力继承前继状态的数据，再加上两个就行了。

由于 `PAM` 上没有重复状态，所以统计出现次数，这是十分简单的。

复杂度：$O(n \sigma)$，其中 $\sigma = 26$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
const int N=5e4+5;
long long ans=0;
namespace PAM{
	int lst,cur_n,nT=1;
	int go[N][26],len[N],fail[N],cnt[N],t[N][26];
	void init()
	{
		len[1]=-1;
		fail[0]=fail[1]=1;
		// for(int i=0;i<26;i++)t[1][i]=-1;
		return;
	}
	int find(int x)
	{
		while(s[cur_n]!=s[cur_n-len[x]-1])x=fail[x];
		return x;
	}
	void extend(int ch)
	{
		++cur_n,ch-='a';
		int cur=find(lst);
		if(!go[cur][ch])
		{
			int x=++nT;
			fail[x]=go[find(fail[cur])][ch];
			len[go[cur][ch]=x]=len[cur]+2;
			for(int i=0;i<26;i++)
			t[x][i]=t[cur][i];
			if(len[x]>1)
			t[x][ch]+=2;
			else t[x][ch]++;
		}
		lst=go[cur][ch];
		cnt[lst]++;
		return;
	}
	void calc()
	{
		for(int i=nT;i>=2;i--)
		{
			cnt[fail[i]]+=cnt[i];
			bool f=1;
			for(int j=0;j<26;j++)
			{
				if(t[i][j]>2){f=0;break;}
			}
			if(f)ans+=cnt[i];
		}
		return;
	}
}
int main()
{
	clock_t c1=clock();
#ifdef LOCAL
 	freopen("1.in","r",stdin);
 	freopen("1.out","w",stdout);
#endif
    ios::sync_with_stdio(0);
 	cin.tie(0);cout.tie(0);
	cin>>s;
	PAM::init();
	s='%'+s;
	for(int i=1;i<=s.length()-1;i++)
	PAM::extend(s[i]);
	PAM::calc();
	cout<<ans;
#ifdef LOCAL
	cerr<<"Time used:"<<clock()-c1<<"ms";
#endif
 	return 0;
}
```


---

## 作者：Night_sea_64 (赞：0)

赛时我就直接写 hash……这篇题解就是写来自嘲一下的（

正常做法就是枚举中心点，然后两边各 $26$ 个字符扫一下即可。显然长度不超过 $52$ 啊。

而我……

记录正着的 hash 、反着的 hash 和对于每个字符的前缀和。枚举中心点二分查找。。。

```cpp
#include<iostream>
using namespace std;
string s;
int n,sum[50010][130];
unsigned long long h1[50010],h2[50010],p[50010];
unsigned long long hs(unsigned long long h[],int l,int r){
    return h[r]-h[l-1]*p[r-l+1];
}
long long ans;
int main()
{
    cin>>s;
    n=s.size();
    s=' '+s;
    p[0]=1;
    for(int i=1;i<=n;i++)
    {
        h1[i]=h1[i-1]*127+s[i],p[i]=p[i-1]*127;
        for(int j='a';j<='z';j++)
            sum[i][j]=sum[i-1][j]+(s[i]==j);
    }
    for(int i=1;i<=n;i++)h2[i]=h2[i-1]*127+s[n-i+1];
    for(int i=1;i<=n;i++)
    {
        int l=1,r=min(i,n-i+1),k;
        while(l<=r)
        {
            int mid=(l+r)/2;
            bool flag=1;
            for(int j='a';j<='z';j++)
                if(sum[i+mid-1][j]-sum[i-mid][j]>2)flag=0;
            if(hs(h1,i-mid+1,i+mid-1)==hs(h2,n-(i+mid-1)+1,n-(i-mid+1)+1)&&flag)
                l=mid+1,k=mid;
            else r=mid-1;
        }
        ans+=k;
        l=min(1,n-i),r=min(i,n-i),k=0;
        while(l<=r)
        {
            int mid=(l+r)/2;
            bool flag=1;
            for(int j='a';j<='z';j++)
                if(sum[i+mid][j]-sum[i-mid][j]>2)flag=0;
            if(hs(h1,i-mid+1,i+mid)==hs(h2,n-(i+mid)+1,n-(i-mid+1)+1)&&flag)
                l=mid+1,k=mid;
            else r=mid-1;
        }
        ans+=k;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

只能场切黄了。

注意到字符集的大小仅仅为 $|S| = 26$。对于以 $i$ 为中心的，满足条件的回文串，最多从中心像左右扩展 $26$ 步。

故枚举中心 $p$，向左右暴力扩展并判断即可。复杂度 $O(n |S|)$

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define int long long
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )
#define dep(i, a, b) for (int i = (a); i >= (b); i -- )

using namespace std;

const int N = 1e5 + 10;
char s[N]; int bin[30];
int ans = 0, n;
int check(int mid, int ans = 0) {
	memset(bin, 0, sizeof bin); bin[s[mid] ^ 96] ++ ; ans ++ ;
	for (int i = mid - 1, j = mid + 1; i > 0 and j <= n; i -- , j ++ ) {
		if (s[i] != s[j]) break; bin[s[i] ^ 96] ++ , bin[s[j] ^ 96] ++ ;
		if (bin[s[i] ^ 96] > 2 or bin[s[j] ^ 96] > 2) break; ans ++ ;
	} return ans;
}
int check2(int mid, int ans = 0) {
	memset(bin, 0, sizeof bin);
	for (int i = mid, j = mid + 1; i > 0 and j <= n; i -- , j ++ ) {
		if (s[i] != s[j]) break; bin[s[i] ^ 96] ++ , bin[s[j] ^ 96] ++ ;
		if (bin[s[i] ^ 96] > 2 or bin[s[j] ^ 96] > 2) break; ans ++ ;
	} return ans;
}
signed main() {
	scanf("%s", s + 1); n = strlen(s + 1);
	rep(i, 1, n) ans += check(i);
	rep(i, 1, n - 1) ans += check2(i);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P10170)

# 题意简述
给定一个字符串 $S$。求出其有多少回文子串，满足其内部每种字符出现次数不超过 $2$ 次。

# 思路分析
如果一个字符串 $S'$ 满足题目中的要求，那么他的长度一定不超过 $52$。因为题目中明确规定“每个字符的出现次数不超过 $2$”。如果子串长度超过 $52$。必然有一个字符出现 $3$ 次以上。

想明白这些题目就很好做了，我们枚举回文半径（即回文串长度的一半向上取整）和左端点 $l$。判断其是否是一个回文串，累加答案即可。

回文半径不超过 $26$。枚举左端点时间复杂度 $O(n)$。判断回文串的循环次数不超过 $52$。可以通过 $5\times 10^4$ 的数据。

由于回文串可以分为奇回文串和偶回文串，我们要进行分类讨论，记左端点为 $l$，回文半径为 $R$。那么奇回文串为 $S_{l,l+2\times R-2}$（例如 $\texttt{ababa}$），偶回文串为 $S_{l,l+2\times R-1}$（例如 $\texttt{abba}$）。

# Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=5e4+10;
char s[N];
int n,cnt[30],ans;
int pd(int l,int r){//判断回文串
    memset(cnt,0,sizeof(cnt));
    for(int i=l,j=r;i<=j;i++,j--)
        if(s[i]!=s[j]||cnt[s[i]-'a'])return 0;
        else cnt[s[i]-'a']++;
    return 1;
}
int main(){
    scanf("%s",s+1);
    n=strlen(s+1);
    for(int i=1;i<=26;i++){
        for(int l=1;l<=n;l++){
            if(l+2*i-2<=n&&pd(l,l+2*i-2))ans++;
            if(l+2*i-1<=n&&pd(l,l+2*i-1))ans++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
还是很简单的。

---

## 作者：Programming_Konjac (赞：0)

赛时就写出来这一个题，写写题解吧。
# 思路
一道很好的模拟题。

枚举 $l$，然后找出符合条件的 $r$ 的数量，存到累加器里面，最后输出就可以了。

为了不用 reverse 函数，所以用两个字符串进行查找回文串的操作，$b$ 和 $c$，$b$ 正序存储，$c$ 倒序存储。然后枚举所有 $r$，然后 $b+s_r,c=s_r+c$ 就可以实现 $b$ 和 $c$ 是相反了，如果当前的 $r$ 满足了 $b=c$，那么累加器 $+1$，**并不结束枚举**。

因为题目中说：每个字符的出现次数不超过 $2$，所以还需要一个桶数组，用来存储数量，如果当前这个字符数量大于 $2$，那么直接跳出枚举 $r$ 的循环。
# 思路
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	string s;
	cin>>s;
	ll ans=0;
	for(int i=0; i<s.size(); i++){
		int tong[26]={0};
		string b,c;
		for(int j=i; j<s.size(); j++){
			if(tong[s[j]-'a']==2) break;
			tong[s[j]-'a']++;
			b+=s[j];
			c=s[j]+c;
			if(b==c) ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xz001 (赞：0)

由于字符串仅有小写字母组成，小写字母有 $26$ 个，由鸽巢原理得，一个子串长度大于 $52$ 便至少有一个字符出现次数大于 $2$，所以直接枚举每个长度小于 $52$ 的子串，判定即可。

代码如下：

```cpp
/*
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3, "Ofast", "inline")
*/
#include<bits/stdc++.h>

using namespace std;

#define re			register
#define int			long long
#define fi			first
#define se			second
#define swap(a, b) 	a ^= b, b ^= a, a ^= b
#define pb 			push_back
#define all(x)		x.begin(), x.end()
#define max(a, b)	(a > b ? a : b)
#define min(a, b)	(a < b ? a : b)
#define il			inline
#define abs(x)		((x ^ (x >> 63)) - (x >> 63))

typedef pair<int, int> PII;

const int N = 1e6 + 10;
const int M = 1e6 + 10;
const int INF = 1e18, P = 998244353;
const double eps = 1e-6;

il int  read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { if (c == '-') f = false; c = getchar(); } while (c >= 48 && c <= 57) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(int x) { if (x < 0) putchar('-'), x = -x; if (x > 9) write(x / 10); putchar(x % 10 + 48); }
il void wel(int x) { write(x), putchar('\n'); }
il void wsp(int x) { write(x), putchar(' '); }

int n, ans;

char s[N]; 

signed main() {
    scanf("%s", s + 1);
	n = strlen(s + 1);
	for (int i = 1; i <= 52; ++ i) {
		for (int j = 1; j <= n - i + 1; ++ j) {
		    int t[26];
		    memset(t, 0, sizeof(t));
		    int l = j, r = j + i - 1;
		    while (s[l] == s[r] && l < r) ++ l, -- r;
		    if (l < r) continue;
		    l = j, r = j + i - 1;
		    for (int k = l; k <= r; ++ k) ++ t[s[k] - 'a'];
		    bool f = false;
		    for (int k = 0; k < 26; ++ k)
		        if (t[k] > 2) f = true;
		        
		    ans += !f;
		}
	} 
	printf("%lld\n", ans);
    return 0;
}


```

---


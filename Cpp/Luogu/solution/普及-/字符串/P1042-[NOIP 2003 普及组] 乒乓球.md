# [NOIP 2003 普及组] 乒乓球

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。


## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

## 样例 #1

### 输入

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出

```
11:0
11:0
1:1

21:0
2:1
```

# 题解

## 作者：DengDuck (赞：24)

本题是一道基本语法题。

在本篇题解中，我们将使用 `string` 类进行读入，并利用较新的遍历语法来完成编程。

首先读入字符串，我们一个一个读入字符，并添加到字符串的末尾，一直到读到 `E` 字符为止。

```cpp
while(cin>>C)
{
  if(C=='E')break;
  S+=C;
}
```
其中 `while(cin>>C)` 这一语法利用了 `cin` 的特性，当 `cin` 没能读入到信息的时候，会返回 $0$，那么循环就会终止。

在本地调试的时候，你可以输入 `Ctrl+Z` 来使得循环终止。

读入之后，我们可以利用遍历语法寻找所有的字符，并统计分数，我们可以把结算的条件记作：
- $\max(A,B)>Lim$，$\max$ 表示的是两者中较大的一个数字的数值，其中 $Lim$ 表示的是规则是多少分制。
- $|A-B|\geq 2$，其中 $|x|$ 是求 $x$ 的绝对值，相当于 C++ 中的 `abs(x)`，意思可以理解为，去除数字的正负号。

一局游戏能结算，当且仅当两个条件都成立。

那我们可以得到以下代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
char C;
string S;
int n,A,B;
int main()
{
	while(cin>>C)
	{
		if(C=='E')break;
		S+=C;
	}
	for(char i:S)
	{
		if(i=='W')A++;
		if(i=='L')B++;
		if(max(A,B)>=11&&abs(A-B)>=2)
		{
			cout<<A<<":"<<B<<endl;
			A=0,B=0;
		}
	}
	printf("%d:%d\n",A,B);
	A=B=0;
	puts("");
	for(char i:S)
	{
		if(i=='W')A++;
		if(i=='L')B++;
		if(max(A,B)>=21&&abs(A-B)>=2)
		{
			cout<<A<<":"<<B<<endl;
			A=0,B=0;
		}
	}
	printf("%d:%d\n",A,B);
	return 0;
}
```

我们发现两次统计做的事情是类似的，关键在于参数 $Lim$ 的不同，如果你会函数语法，我们也可以写一个函数 `Work`，并且含有参数 `Lim`，这样代码就更加简短啦！

```cpp
#include<bits/stdc++.h>
using namespace std;
char C;
string S;
int n,A,B;
void Work(int Lim)
{
	for(char i:S)
	{
		if(i=='W')A++;
		if(i=='L')B++;
		if(max(A,B)>=Lim&&abs(A-B)>=2)
		{
			cout<<A<<":"<<B<<endl;
			A=0,B=0;
		}
	}
	printf("%d:%d\n\n",A,B);
	A=B=0;	
}
int main()
{
	while(cin>>C)
	{
		if(C=='E')break;
		S+=C;
	}
	Work(11),Work(21);
	return 0;
}
```

我们通常用时间复杂度来判断代码的运行效率，那么这份代码的时间复杂度是 $\mathcal O(n)$。

---

## 作者：qhr2023 (赞：15)

## solution

一道模拟题。

首先我们对于不确定数量的输入通常采用 ```while(cin>>c)``` 的形式，当没有输入时，```cin>>c``` 就返回 $0$。

用两个整数 $a$ 和 $b$ 记录两个人当前这局各得了多少分，再考虑一局的结束条件，在 $k$ 分制下，有人达到 $k$ 分且两人分差不小于 $2$。

可以用 $\max(a, b)$ 表示两个数中较大的数，来判断是否有人达到 $k$ 分。对于分差，可以用 ```abs(a-b)```，表示求 $a-b$ 的绝对值。

剩下的按题意模拟即可。注意要忽略输入结尾的字符，两个分制之间要有空行。

[通过记录](https://hydro.ac/record/67b7ddf9ade670af7ebd302a)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
char c;
void solve (int k) {
    int a=0, b=0;
    for (char i:s) {
		i=='W'?a++:b++;
		if (max(a, b)>=k&&abs(a-b)>=2)
			cout << a << ':' << b << '\n',
			a=b=0;
	}
	cout << a << ':' << b << "\n\n";
}
int main () {
	while (cin >> c&&c!='E') s+=c; 
    solve(11); solve(21);
	return 0;
}
```

---

## 作者：__assassin_ (赞：10)

# 题目大意：

给你一个由 $\texttt W$、$\texttt L$ 和 $\texttt E$ 组成的字符串（$\texttt E$ 表示结束），问你在 $11$ 分制和 $21$ 分制下双方的比分。

# 思路：

我们先来模拟 $11$ 分制下的比分，我们用 $w$ 来表示华华的分数，用 $l$ 来表示对手的分数。从字符串的头开始遍历，如果当前的字符为 $\texttt W$，那么 $w \gets w+1$；如果当前的字符为 $\texttt L$，那么 $l \gets l+1$。当 $w$ 和 $l$ 中有一个大于或等于 $11$，且 $\lvert w-l\rvert \ge 2$ 时，输出比赛当前得分，并且 $w \gets 0$，$l \gets 0$。字符串遍历完后，再输出一次当前比赛得分，然后 $w \gets 0$，$l \gets 0$，准备模拟 $21$ 分制下的比分。

然后再来模拟 $21$ 分制下的比分，我们继续用 $w$ 来表示华华的分数，用 $l$ 来表示对手的分数。从字符串的头开始遍历，如果当前的字符为 $\texttt W$，那么 $w \gets w+1$；如果当前的字符为 $\texttt L$，那么 $l \gets l+1$。当 $w$ 和 $l$ 中有一个大于或等于 $21$，且 $\lvert w-l \rvert \ge 2$ 时，输出比赛当前得分，并且 $w \gets 0$，$l \gets 0$。字符串遍历完后，再输出一次当前比赛得分。

# AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[250000];
int w,l,i; 
int main(){
	for(i=1; ;i++){
		cin>>a[i];
		if(a[i]=='E'){
			i--;//得分次数 
			break;
		}
	}
	for(int x=1;x<=i;x++){//遍历 
		if(a[x]=='W') w++;
		if(a[x]=='L') l++;//加分 
		if((w>=11||l>=11)&&abs(w-l)>=2){//判断比赛是否结束 
			cout<<w<<":"<<l<<"\n";//输出比赛得分 
			w=0,l=0;//清0 
		}
	}
	cout<<w<<":"<<l<<"\n\n";//输出当前得分 
	w=0,l=0;//清0 
	for(int x=1;x<=i;x++){//遍历 
		if(a[x]=='W') w++;
		if(a[x]=='L') l++;//加分 
		if((w>=21||l>=21)&&abs(w-l)>=2){//判断比赛是否结束 
			cout<<w<<":"<<l<<"\n";//输出比赛得分 
			w=0,l=0;//清0 
		}
	}
	cout<<w<<":"<<l<<"\n";//输出当前得分 
	return 0;
}
```

---

## 作者：jinfanhao (赞：9)

这题适合给刚学习字符串的巨佬练手。\
每回读字符，用一个字符数组存下来。\
再用两个变量计数，如果两个变量之间有一个超过了分制的要求并且绝对差超过二便输出分数并且清零。\
两个分制之间的换行要记得输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6;
char ch,str[N];
int pos,sum,ans;
int main(){
	ch=getchar();
	while(ch!='E'){
		if(ch=='W' || ch=='L')str[++pos]=ch;
		ch=getchar();
	}
	for(int i=1; i<=pos; ++i){
		if(str[i]=='W')++sum;
		if(str[i]=='L')++ans;
		if((sum>=11 || ans>=11) && abs(sum-ans)>=2){
			printf("%d:%d\n",sum,ans);
			sum=ans=0;
		}
	}
	printf("%d:%d\n",sum,ans);
	puts("");
	sum=ans=0;
	for(int i=1; i<=pos; ++i){
		if(str[i]=='W')++sum;
		if(str[i]=='L')++ans;
		if((sum>=21 || ans>=21) && abs(sum-ans)>=2){
			printf("%d:%d\n",sum,ans);
			sum=ans=0;
		}
	}
	printf("%d:%d\n",sum,ans);
	return 0;
}
```

---

## 作者：lucky_Mrzhao (赞：6)

## 思路

这是一道经典的模拟题，我们将这一道题划分成 个部分进行思考。

### 输入

以下是输入中需要思考的几个问题：

1. 题目中提及输入共有若干行，但是这若干行却应该合并成同一行
2. 当我们读取到字母 `E` 时，应当立即停止输入。

思考应当如何解决输入中的问题？其实很简单。首先，对于多行输入，我们将其转化成输入若干个字母，然后将其存入同一个数组中，这样我们就可以实现上面的第 $1$ 个问题，同时这也方便了我们处理第 $2$ 个问题，因为我们读入的是字符，所以再增加一个判断，即可解决第 $2$ 个问题。

### 输入代码

```cpp
while(cin >> c[++tot]){
    if(c[tot]=='E'){
        tot--;
        break;
    }
}
```

### 模拟

在完成输入之后，我们要将输入的内容进行模拟，但是我们稍微偷个懒，将模拟的内容打包成一个函数，这样，无论我们需要的是多少分制，都不用再重新打一遍代码，大大减少了代码的行数。在函数中，我们传入参数 `k` ，即现在是 `k` 分制。那么我们将输入中处理的数组 `c` 。当且仅当 $l \ge k $ 或 $m \ge k$ 且 $|l-r| \ge 2$ 。

### 模拟代码

```cpp
void num(int k){
	int w,l;
	w = l = 0;
	for(int i = 1;i <= tot;i++){
		if(c[i]=='W') w++;
		else l++;
		if((w>=k||l>=k)&&(abs(w-l))>=2){
			cout << w << ':' << l << endl;
			w = l = 0;
		}
	}
	cout << w << ':' << l << endl;
}
```

## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[200005];
int tot = 0;
void num(int k){
	int w,l;
	w = l = 0;
	for(int i = 1;i <= tot;i++){
		if(c[i]=='W') w++;
		else l++;
		if((w>=k||l>=k)&&(abs(w-l))>=2){
			cout << w << ':' << l << endl;
			w = l = 0;
		}
	}
	cout << w << ':' << l << endl;
}
int main()
{
	while(cin >> c[++tot]){
		if(c[tot]=='E'){
			tot--;
			break;
		}
	}
	num(11);
	cout << endl;
	num(21);
	return 0;
}
```

---

## 作者：mairuisheng (赞：6)

[P1042 [NOIP 2003 普及组] 乒乓球](https://www.luogu.com.cn/problem/P1042)

主要算法：模拟

分析：首先读入比赛信息，分别对它进行 $11$ 分制和 $21$ 分制。

先讲 $11$ 分制的处理：当读到 `W`，计数器一累加；当读到 `L`，计数器二累加。任意时刻如果有至少一个计数器大于等于 $11$ 且两个计数器之差的绝对值小于等于 $2$，就输出比赛结果。

$21$ 分制与 $11$ 分制同理。

关于输入：用 `scanf` 读取字符直到读到 `E` 为止，把这些字符存到字符数组里。

注意：输出比赛结果之后，两个计数器一定要清零。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[62526];
long long i=0,j,h=0,d=0;
int main()
{
	while(1)
	{
		scanf("%c",&a[i]);
		if(a[i]=='E')break;
		i++;
	}
	for(j=0;j<i;j++)
	{
		if(a[j]=='W')h++;
		else if(a[j]=='L')d++;
		if((h>=11&&h-d>=2)||(d>=11&&d-h>=2))
		{
			printf("%lld:%lld\n",h,d);
			h=0;
			d=0;
		}
	}
	printf("%lld:%lld\n",h,d);
	printf("\n");
	h=0;
	d=0;
	for(j=0;j<i;j++)
	{
		if(a[j]=='W')h++;
		else if(a[j]=='L')d++;
		if((h>=21&&h-d>=2)||(d>=21&&d-h>=2))
		{
			printf("%lld:%lld\n",h,d);
			h=0;
			d=0;
		}
	}
	printf("%lld:%lld\n",h,d);
	return 0;
}
```

---

## 作者：derderhaoyue (赞：5)

这道题属于一道模拟题。
我将通过使用 `scanf` 这一格式输入函数配合 `char` 类型数组进行解题

作为解题的第一步，本蒟蒻决定先读入数据。

```cpp
while(scanf("%c ",&c[cnt])!=EOF){// 使用scanf进行读入
        cnt++;// 计数器++
    }
```

在以上的代码中，本蒟蒻借助了 `scanf` 函数的两个小特性来完成读入：

1. `scanf` 这一函数在读取失败，或者达到文件末尾，或者遇到输入结束的条件，会返回 EOF，可以通过检测 `scanf` 是否返回了 EOF 来判断是否读到了文件结尾。
2. 在 `scanf` 的格式字符串（即代码中的 `"%c "`）中添加空格可以屏蔽掉诸如制表符，空格，换行的影响，保证读入的是有效信息。
值得一提：在本地测试时可以手动终止代码的读入，在 windows 环境下需要按下 Ctrl+Z 组合键，而在 UNIX/Linux/Mac OS 环境中，需要按下 Ctrl+D。

完成读取之后，本蒟蒻就开始处理数据了，本蒟蒻遍历了一遍这个数组并模拟计分过程，比赛结束的条件为当且仅当满足以下两点条件：
1. 两人分数之差大于等于 2。
2. 两人分数的较大者高于赛制的分数规定。
最后，本蒟蒻将处理的部分打包成函数，通过传参的方式区分 11 分赛制与 21 分赛制。

>Talk is cheap,show your code

```cpp
#include<bits/stdc++.h>// 使用万能头文件,里面有很多好用的东西呦
using namespace std;// 使用std命名空间,这样可以省略部分代码要写"std::"的烦恼
char c[70500];// 存储字符的char
int cnt=1;// 计数器,初始化为1是为了让数组下标从1开始使用,留一个0号下标防止越界
int w,l;// 华华和对手的得分
void res(int fo){// result结果 format赛制
    for(int i=1;i<=cnt;i++){
        if(c[i]=='W') w++;// 华华赢了,加分
        if(c[i]=='L') l++;// 对手赢了,对手加分
        if(c[i]=='E'){// 读到了E,终止比赛
            printf("%d:%d\n\n",w,l);// 输出比分
            w=l=0;// 重置比分
            return;
        }
        if(max(w,l)>=fo&&abs(w-l)>=2){//一般情况下必须同时满足分差大于等于2且有一方分数大于等于结束分数
            printf("%d:%d\n",w,l);
            w=l=0;
        }
    }
    printf("%d:%d\n\n",w,l);
    w=l=0;
}
int main(){
    while(scanf("%c ",&c[cnt])!=EOF){// 使用scanf进行读入
        cnt++;// 计数器++
    }
    res(11);// 这是11分制的情况
    res(21);// 21分制的情况
}
```

感谢各位神犇观看本蒟蒻的题解，本蒟蒻的题解如有不妥，请各位神犇不吝赐教。

---

## 作者：maziming (赞：4)

## 题意：
题目给了我们一个字符串，以 $E$ 结尾，如果是 $W$ 华华加一分，如果是 $L$ 花花对手加一分，让我们输出每场的得分。
## 思路：
每次输入一个字符，判断是华华加分还是华华的对手加分，然后再判断有没有人达到 $11$ 分，如果有人达到并且两人相差 $2$ 分及以上，便输出结果。

然后换行，再来一次，每次输入一个字符，判断是华华加分还是华华的对手加分，然后再判断有没有人达到 $21$ 分，如果有人达到并且两人相差 $2$ 分及以上，便输出结果。

#### 提示：如果字符输出完后还有分数，还要输出一次。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long w,l,n;
char a[100005];
int main()
{
	cin>>a[++n];
	while(a[n]!='E')
	{
		if(a[n]=='W')w++;
		else l++;
		if(w>=11&&w-2>=l||l>=11&&l-2>=w){cout<<w<<":"<<l<<endl;w=0,l=0;}
		cin>>a[++n];
	}
	cout<<w<<":"<<l<<endl<<endl;
	w=0,l=0;
	for(int i=1;i<n;i++)
	{
		if(a[i]=='W')w++;
		else l++;
		if(w>=21&&w-2>=l||l>=21&&l-2>=w){cout<<w<<":"<<l<<endl;w=0,l=0;}
	}
	cout<<w<<":"<<l;
	return 0;
}
```

---

## 作者：wurang (赞：2)

本题为模拟题，按照题意模拟即可。
利用循环语句，在输入为 E 时跳出，完成读入。
使用两个变量 $w,l$ 表示双方目前分数。
当有一方超过 $11$ 或 $21$ 分时且双方分数差大于等于 $2$ 时，比赛结束。

```cpp
#include <bits/stdc++.h> 
using namespace std;

int a[6250005], n = 0;
char tmp;
int w, l;

int main() {
    while (true) {//读入
        cin >> tmp;
        if (tmp == 'E') break;
        n++;
        if (tmp == 'W') a[n] = 1;//华华得分
        else if (tmp == 'L') a[n] = 0;//对手得分
    }
    
    w = l = 0;//初始化为0
    for (int i = 1; i <= n; i++) 
	{
        w += a[i];
        l += 1 - a[i];
        if ((max(w, l) >= 11) && abs(w - l) >= 2) //若满足条件
		{
            cout << w << ":" << l << endl;//结束本局
            w = l = 0;//初始化为0
        }
    }
    cout << w << ":" << l << endl;//最终剩余的比分
    cout << endl;

    //再以21分制算一遍
    w = l = 0;
    for (int i = 1; i <= n; i++) 
	{
        w += a[i];
        l += 1 - a[i];
        if ((max(w, l) >= 21) && abs(w - l) >= 2) 
		{
            cout << w << ":" << l << endl;
            w = l = 0;
        }
    }
    cout << w << ":" << l << endl;
    
    return 0;
}
```

---

## 作者：lixianyuan (赞：1)

# 题意
[题目](https://www.luogu.com.cn/problem/P1042)\
已知每个球的胜负情况，然后分别计算在 11 分制和 21 分制下双方的比赛结果。
# 思路
首先要注意一个细节，就是无论最后剩下多少分都要再多输出一遍。\
输入很好解决，只需要一直读下去，读到 E 就跳出循环。然后遍历一遍字符串并记录双方胜负情况，一旦一方满足胜利条件就输出并将记录清零。\
但是如何判断胜负情况呢？读题可以发现，如果一方分数大于等于 $x$（设比赛为 $x$ 分制），且双方分差大于等于二则获胜，最后要记住要额外输出一次比分。
# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define LL long long
#define uLL unsigned long long
#define iny int
#define itn int
#define icn cin
#define Endl "\n"
#define endl "\n"
#define For(i,a,n) for(auto i=(a);i<=(n);i++)
#define FOR(i,n,a) for(auto i=(n);i>=(a);i--)
using namespace std;
const int N=25*2510; 
char a[N];
int len,l,w;
void work(int x){//设比赛为 x 分制 
	For(i,1,len){
		if(a[i]=='W')w++;
		else if(a[i]=='L')l++;
			//记录得分情况 
		if((w>=x||l>=x)&&abs(w-l)>=2){
			cout<<w<<':'<<l<<"\n";
			w=l=0;
		}
			//如果对局结束，输出并清空 
	}
	cout<<w<<':'<<l<<"\n\n";
	w=l=0;
		//要记得额外输出一次并清零！ 
}
int main(){
	do{
		a[++len]=getchar();
	}while(a[len]!='E');
		//输入 
	work(11);
	work(21);
	return 0; 
}
```

---

## 作者：easy42 (赞：1)

本题是一道基本语法题。

在这里，将使用 `string` 类型来进行读入，并使用函数来简化代码。

### `string` 类型的使用方法

像这样，可以读取一个字符串 $s$。

```cpp
string s;
cin>>s;
```

像这样，可以遍历一个字符串 $s$。

```cpp
for(int i=0;i<s.size();i++) cout<<s[i];
```

### 本题的输入

有多个字符串读入，可以这样做：

```cpp
while(cin>>c) s+=c;
```

### 本题的要求

要求处理 $11$ 和 $21$ 分制，可以直接使用函数。

```cpp
void work(int t){
	for(int i=0;i<s.size();i++){
		if(s[i]=='W')a++;
		if(s[i]=='L')b++;
		if(s[i]=='E')break;
		if(max(a,b)>=t&&abs(a-b)>=2){
			cout<<a<<":"<<b<<endl;
			a=0,b=0;
		}
	}
	cout<<a<<":"<<b<<endl<<endl;
	a=b=0;	
}
```

### 本题代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
char c;
int n,a,b;
void work(int t){
	for(int i=0;i<s.size();i++){
		if(s[i]=='W')a++;
		if(s[i]=='L')b++;
		if(s[i]=='E')break;
		if(max(a,b)>=t&&abs(a-b)>=2){
			cout<<a<<":"<<b<<endl;
			a=0,b=0;
		}
	}
	cout<<a<<":"<<b<<endl<<endl;
	a=b=0;	
}
int main(){
	while(cin>>c) s+=c;
	work(11),work(21);
	return 0;
}
```

---


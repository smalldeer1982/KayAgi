# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# 题解

## 作者：CYJian (赞：5)

主要思路就是：记录->判断->输出/判错

由于简单，就直接上代码，看注释即可。

```cpp
#include<cstdio>
#include<cstring>
#include<map>
#define ERROR {printf("Failed\n");return 0;}
using namespace std;
map<char,char>mp,mq;//mp来记录翻译后文字，mq记录加密后文字 
int main(){
        int la,lb,lc,book=26;//la、lb、lc记录a,b,c的长度，book计算用了多少种字母 
        char a[10005],b[10005],c[10005];//分别储存加密后、加密前和要求翻译字符串 
        scanf("%s%s%s",&a,&b,&c);
        la=strlen(a); lb=strlen(b); lc=strlen(c);//计算长度 
        if(la!=lb||la<26) ERROR    //长度不等或长度不够就判错 
        for(int i=0;i<la;i++)
                if(mp[a[i]]==0&&mq[b[i]]==0)
                        mp[a[i]]=b[i] , mq[b[i]]=a[i] , book--;//符合标准就记录下来 
                else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i])//不合标准 
                            ERROR//判错 
        if(book>0) ERROR//没有26个字母就判错 
        for(int i=0;i<lc;i++) printf("%c",mp[c[i]]);//输出 
        printf("\n");//换行 
        return 0;
}
```

---

## 作者：陈嘉逸2012 (赞：2)

不知道为什么大家的做法都那么复杂，只有[一篇题解](/article/vjhqsomd)和我思路差不多。
## 思路
这就是个模拟题。我们设读入的三行字符串分别为 $a,b,c$。

一看到题目，就知道可以用 `map` 解题。先设一个 `map<char,char>mp;`，用于整理“密码本”；再设一个 `map<char,bool>vis;`，用于记录哪个字符已经在“密码本”里了。

首先遍历 $a$：如果 $vis_{b_i}=1 \land b_i \ne mp_{a_i}$，直接输出 `Failed` 并结束程序；否则，$mp_{a_i} \gets b_i,vis_{b_i} \gets 1$。

然后遍历 $\tt A \sim Z$，如果 $vis_i=0$，输出 `Failed` 并结束程序。

最后根据“密码本”翻译 $c$ 中的内容并输出。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b,c;
map<char,char>mp;map<char,bool>vis;
int main(){
	cin>>a>>b>>c;
	for(int i=0;i<a.size();i++){
		if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;}
		mp[a[i]]=b[i],vis[b[i]]=1;
	}
	for(char i='A';i<='Z';i++){
		if(!vis[i]){cout<<"Failed\n";return 0;}
	}
	for(int i=0;i<c.size();i++) cout<<mp[c[i]];
}
```

---

## 作者：qhr2023 (赞：2)

## solution

小模拟。

我们开一个映射，记 $mp_i$ 表示字母 $i$ 作为密文时对应的原信息，遍历时若发现 $mp_i$ 对应两个不同的原信息则不合法，遍历后若发现有字母没出现则不合法。最后按题意输出。

[通过记录](https://hydro.ac/record/67ac251080df283de8c3202d)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[105], b[105], c[105], mp[205], vis[205];
int main(){
	cin >> a >> b >> c;
	int la=strlen(a), lc=strlen(c);
	for (int i=0; i<la; mp[a[i]]=b[i], vis[b[i]]=1, i++) 
		if (vis[b[i]]&&b[i]!=mp[a[i]]) {
			puts("Failed");
			return 0;
		}
	for (int i='A'; i<='Z'; i++)
		if (!vis[i]) {
			puts("Failed");
			return 0;
		} 
	for (int i=0; i<lc; i++)
		cout << mp[c[i]];
	return 0;
}
```

---

## 作者：lianghuahua (赞：1)

具体思路，用 map 处理已知密文到明文匹配。每做一次破译，成功则记录到 map，遇到破译矛盾直接 Failed 结束（状态 3）。匹配处理完成后，破译匹配数量达到 26 则成功（状态 1），否则 Failed 结束（状态 2）。最后对目标密文进行破译输出。

一个难点是破译矛盾（状态 3）的判断，有大佬用双向 map 非常好用，我这里用 map 直接判断密文到明文是否有映射不一致，用一个 set 记录已经被映射的明文，从而来判断明文是否被其他密文已经映射过。

这题开始还入了个小坑。状态 2 判读，读题时误以为是针对要破解的信息找不到原信息，后来发现是必须要通过原文和密文破解全部 26 个字母。

AC 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
map<char, char> mp; //密文到明文匹配
set<char> st; //被匹配过的明文 
int main(){
	string s1, s2, s3, t;
	cin >> s1 >> s2 >> s3;
	for(int i = 0; i < s1.size(); i++){
		//密文是否被匹配过 
		if(mp.count(s1[i])) {
			//匹配过，但匹配矛盾，状态3错误 
			if(mp[s1[i]] != s2[i]) {
				cout << "Failed";
				return 0;
			}
		}else{
			//明文被其他密文匹配过，状态3错误 			
			if(st.count(s2[i])) {
				cout << "Failed";
				return 0;
			}			
			//匹配成功，建立密文到明文匹配，并记录已经匹配过的明文 
			mp[s1[i]] = s2[i];
			st.insert(s2[i]);
		}
	}	
	//如果没有匹配到26对，状态2错误 
	if(mp.size() < 26){
		cout << "Failed";
		return 0;
	}
	//根据密文匹配输出
	for(int i = 0; i < s3.size(); i++){
		cout << mp[s3[i]];
	}
	return 0;
} 

```

---

## 作者：piske (赞：0)

# [NOIP 2009 提高组] 潜伏者
### [题目传送门](https://www.luogu.com.cn/problem/P1071)
## 思路：
完成输入后找到每个字母对应的原文，做成密码本。  
再进行三个判断：
1.  判断原文和密文长度是否相等。
2.  判断密码本中是否有字母缺失
3.  判断密码本中是否有一个密文对应多个原文或一个原文对应多个密文


如果以上三种情况都没有发生，就可以按照密码本翻译要翻译的密文，否则输出`Failed`。
## Coding：
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[110];   //小 C 掌握的一条加密信息
char b[110];   //第一行的加密信息所对应的原信息
char c[110];   //为 R 国司令部要求小 C 翻译的加密信息
int di[29];    //密码本,记录每个密文对应的原文 
int vis[27];
bool f=true;
int main( ){
	for(int i=0;i<28;i++)
		di[i]=-1;
	cin>>a>>b>>c;
	int lena=strlen(a),lenb=strlen(b),lenc=strlen(c); //记录每个字符串的长度 
	if(lena!=lenb){ //判断原文和密文长度是否相等。 
		f=false;
	}
	else{ 
		for(int i=0;i<lena;i++){
			if(di[a[i]-'A']!=b[i]-'A'&&di[a[i]-'A']!=-1)
				f=false;
			di[a[i]-'A']=b[i]-'A';
			vis[b[i]-'A']=1;  //断密码本中是否有字母缺失
		}
	}
	int sum=0;
	for(int i=0;i<26;i++)
		if(di[i]==-1||vis[i]==0) //判判断密码本中是否有一个密文对应多个原文或一个原文对应多个密文 
			f=false;
	if(f==false){
		cout<<"Failed";
	}
	else{
		for(int i=0;i<lenc;i++)
			cout<<char(di[c[i]-'A']+'A');
	}
	return 0;
}
```

---

## 作者：xukuan (赞：0)

先判断是否合法

不合法直接跳出

合法就进行翻译





```cpp
var
 s1,s2,s3:string;
 i,t,len3:longint;
procedure no;//不行时的输出
 begin
  writeln('Failed');
  halt;
end;
procedure check(s1,s2:string);//判断是否合法
 var
  c:char;
  i,j,len:longint;
  c1,c2:array['A'..'Z'] of boolean;
 begin
  fillchar(c1,sizeof(c1),true);
  fillchar(c2,sizeof(c2),true);//子程序中必须重新赋值
  len:=length(s1);
  for i:=1 to len do
   if (s1[i] in['A'..'Z']) and (s2[i] in['A'..'Z']) then
    begin
     c1[s1[i]]:=false;
     c2[s2[i]]:=false;
    end;
  for c:='A' to 'Z' do
   if c1[c] or c2[c] then no;//是否全部出现
  for i:=1 to len-1 do
   for j:=i+1 to len do
    if (s1[i]=s1[j]) and (s2[i]<>s2[j]) or (s2[i]=s2[j]) and (s1[i]<>s1[j]) then
     no;//是否有冲突
end;
begin
 readln(s1);
 readln(s2);
 check(s1,s2);
 readln(s3); len3:=length(s3);
 for i:=1 to len3 do
  if s3[i] in['A'..'Z'] then//不加样例第三组输出NOIP2
   begin
    t:=pos(s3[i],s1);
    write(s2[t]);//别加换行
   end;
 writeln;
end.

```

---


# [ROIR 2024] 登机 (Day 1)

## 题目背景

翻译自 [ROIR 2024 D1T1](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day1.pdf)。

飞机上一共有 $n$ 排座位，每排有六个位置，其中第三和第四个位置之间有过道。一些乘客在线上已经提前订好位置，其他乘客则在机场的登记台购买机票。在线上购买机票时，乘客可以选择任何座位，且不能更改。例如，当 $n = 6$ 时，在线上已经订好的座位可能如下（用叉号标记已占用的座位）：

![](https://cdn.luogu.com.cn/upload/image_hosting/bei2tmfa.png)

有 $m$ 名乘客在登记台购买机票。根据航空公司的规定，在工作人员帮他们选好位置后，最终的座位安排相对于过道应该是对称的。即，如果某一排的第一个座位有乘客，那么同一排的第六个座位也必须有乘客。同样，第二和第五、第三和第四个座位也必须相应对称。同时，在线上购买的乘客的座位不能改变。在上图的初始座位中，可以添加七名乘客以满足对称性，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vkk729ne.png)

## 题目描述

给定在线购买的乘客选定的座位，你需要安排 $m$ 名乘客，使得最终的座位安排相对于过道是对称的。如果不可能做到，输出 `Impossible`。

## 说明/提示

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $15$ | $m=0$ |
| $2$ | $16$ | 刚开始飞机上所有座位都是空的 |
| $3$ | $17$ | $m=1$ |
| $4$ | $18$ | 刚开始飞机上只有一个座位 |
| $5$ | $34$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 1000$，$0 \leq m \leq 6000$。

Subtask 5 的最后两个测试点是原数据中没有的 hack。

## 样例 #1

### 输入

```
1 0
X.XX.X```

### 输出

```
X.XX.X```

## 样例 #2

### 输入

```
2 1
X.XX.X
..X...```

### 输出

```
X.XX.X
..XX..```

## 样例 #3

### 输入

```
3 2
X.XX.X
......
X..X.X```

### 输出

```
Impossible```

## 样例 #4

### 输入

```
1 103
.X.XXX```

### 输出

```
Impossible```

## 样例 #5

### 输入

```
6 7
X.....
......
....X.
X.....
......
..XX..```

### 输出

```
X....X
X....X
.X..X.
X....X
..XX..
..XX..```

# 题解

## 作者：cff_0102 (赞：5)

首先根据输入找出所有必须被安排的座位，并计算它的数量（设为 $cnt$）。如果这个数大于 $m$ 则肯定不行，输出 `Impossible`。

否则，先把 $cnt$ 个乘客安排好，剩下 $m'=m-cnt$ 个乘客。因为座位必须是对称的，所以左边有一个座位，右边就必须也有一个，即如果有安排的方案，$m'$ 必须是偶数。如果是奇数就无解。

接下来就直接模拟，从飞机第一排开始往后分别给乘客排好座位即可，记得判断最后会不会有飞机座位不够的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[1145][7];
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			char c;cin>>c;
			if(c=='X')a[i][j]=1;
		}
	}
	int cnt=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			if(a[i][j]&&!a[i][7-j])cnt++,a[i][7-j]=1;
		}
	}
	if(cnt>m)cout<<"Impossible",exit(0);
	m-=cnt;
	if(m%2)cout<<"Impossible",exit(0);
	for(int i=1;i<=n&&m;i++){
		for(int j=1;j<=6&&m;j++){
			if(a[i][j]==0)m-=2,a[i][j]=a[i][7-j]=1;
		}
	}
	if(m)cout<<"Impossible",exit(0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			cout<<((a[i][j])?('X'):('.'));
		}cout<<endl;
	}
	return 0;
}
```

注：代码中 `m-=cnt;` 前后两行的判断删去也能 AC，这是因为在后面的模拟中，如果 $m'$ 不符合要求，则代码中的变量 `m` 一定不会被减到 $0$。

---

## 作者：Zskioaert1106 (赞：5)

题目传送门：[P11120 [ROIR 2024 Day 1] 登机](https://www.luogu.com.cn/problem/P11120)

### 题目大意

给你一个 $n\times 6$ 的布尔矩阵，要求将 $m$ 个为 $0$ 的元素变为 $1$ 使得其关于纵轴对称。

### 题目分析

首先在最开始判断一种无解的情况：空位小于 $m$。我们可以设置一个初始值为 $6n$，之后每读入到一个 `X` 就让其减 $1$。如果输入完它小于 $m$，就输出 `Impossible` 并结束。

之后要让矩阵对称，首先就要将关于纵轴不对称的元素都变成 $1$，即判断：如果 $a_{i,j}\neq a_{i,6-j-1}$（$j<3$ 且从 $0$ 开始）则让其中为 $0$ 的那个变为 $1$。

因为只有两者不同才会操作，所以肯定只会改变一个，那就让 $m$ 减去 $1$。

这样走过一遍后，如果 $m<0$，那也就说给定的 $m$ 还不够把原先的矩阵填上，则无解。而如果 $m\bmod 2 = 1$，也无解。

因为我们此时已经让矩阵对称了，接下来无非就是把剩下的两个两个填入矩阵，此时出一个落单的必定不行。

之后再循环一遍（其实可以放在刚才的循环中，但是这样比较清晰，且 $n$ 也很小），如果 $a_{i,j} = a_{i,6-j-1} = 0$，那就把剩下的 $m$ 减 $2$，并将这一对对称点更改为 $1$。在这个循环中药时刻判断，如果 $m$ 为 $0$ 了，就立刻结束循环并输出。

如果完整的走了一遍后，$m$ 还是比 $0$ 大，则无解（但是这段在最初已经判断过了）。

### 编写代码

```cpp
#include<iostream>
using namespace std;
int n,m,s;
bool a[1000][6];
int main(){
```

读入时的判断：

```cpp
	cin>>n>>m;
	s=n*6;
	for(int i=0;i<n;i++){
		for(int j=0;j<6;j++){
			char o;
			cin>>o;
			if(o=='X'){
				a[i][j]=1;
				s--;
			}
		}
	}
	if(s<m){
		cout<<"Impossible";
		return 0;
	}
```

第一遍填充对称：

```cpp
	for(int i=0;i<n;i++){
		for(int j=0;j<3;j++){
			if(a[i][j]^a[i][6-j-1]){
				a[i][j]=1,a[i][6-j-1]=1;
				m--;
			}
		}
	}
```

两种无解的情况：

```cpp
	if((m<0)||(m&1)){
		cout<<"Impossible";
		return 0;
	}
```

将剩余的 $m$ 填进去，并随时结束：

```cpp
	for(int i=0;i<n&&m>0;i++){
		for(int j=0;j<3&&m>0;j++){
			if(a[i][j])continue;
			if(m>0){
				a[i][j]=1,a[i][6-j-1]=1;
				m-=2;
			}
			else{
				break;
			}
		}
	}
```

输出：

```cpp
	for(int i=0;i<n;i++){
		for(int j=0;j<6;j++){
			cout<<((a[i][j])?'X':'.');
		}
		cout<<'\n';
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/178717153)，这样的时间复杂度约是 $\mathcal O(18n)$。

---

## 作者：LG086 (赞：1)

简单说下思路：  
先计算最多还可以坐几个人，同时计算至少还要几个人才可以保证座位对称。分别记作 $cntMax$ 和 $cntMin$。  
如果 $cntMax < m$ 或 $cntMin > m$ 那么无解。如果 $m-cntMin$ 为奇数同样无解。因为剩余的座位必须足够坐，同时还要求座位对称。在坐下了 $cntMin$ 个人之后，剩下的 $m-cntMin$ 个人也要对称地坐下，所以剩余人数必须为偶数。  
判断完无解后，在满足对称的前提下直接随便坐就行了。排好座位后直接输出即可。



---

### 代码

```cpp
#include<bits/stdc++.h>
#define END return 0
using ll = long long;
using namespace std;
ll n,m;
char mp[1145][10];
ll cntMax,cntMin;
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=6;j++){
            cin>>mp[i][j];
            if(mp[i][j]=='.')
                cntMax++;
            if(j>3)
                if(mp[i][j]!=mp[i][7-j])
                    cntMin++,mp[i][j]=mp[i][7-j]='X';
        }
    if(m>cntMax||m<cntMin)
        return cout<<"Impossible",0;
    m-=cntMin;
    if(m%2!=0)
        return cout<<"Impossible",0;
    for(int i=1;i<=n&&m>0;i++)
        for(int j=1;j<=3&&m>0;j++)
            if(mp[i][j]=='.')
                mp[i][j]=mp[i][7-j]='X',m-=2;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=6;j++)
            cout<<mp[i][j]<<(j==6?"\n":"");
}
```

---

## 作者：suyi1111 (赞：0)

首先算出客舱还能坐下多少人以及最少坐下多少人才能对称。

首先，如果人数比还能坐下多少人还要多的话，无解。

第二，如果人数比最少坐下多少人才能对称的人数还要少的话，无解。

最后，如果人数和最少坐下多少人才能对称的人数不同奇偶，无解。因为这样坐人数永远是奇数。

否则就先补成对称的，然后在空白位置补人。

代码：
```cpp
#include<bits/stdc++.h>
#define fr(x,y,z,t) for(int x=(y);x<=(z);x+=t)
#define rf(x,y,z,t) for(int x=(y);x>=(z);x+=t)
using namespace std;
int n,m;
char c[1002][7];
int sum=0,avg=0;//还能坐下多少人，至少要坐下多少人才能对称 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c[i];
		for(int j=0;j<=5;j++)
		if(c[i][j]!='X')sum++;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=5;j++){
			if(c[i][j]=='X'&&c[i][5-j]=='.')avg++;
		}
	}
	if(m>sum||m<avg||(m&1)!=(avg&1)/*第三条是因为 &1==%2*/){
		cout<<"Impossible";
		return 0; 
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=5;j++){
			if(c[i][j]=='X'&&c[i][5-j]=='.')c[i][5-j]='X',m--;//开始补成对称 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=5;j++){
			if(c[i][j]=='.'&&c[i][5-j]=='.'&&m!=0)c[i][j]=c[i][5-j]='X',m-=2;//补人 
		}
	}
	for(int i=1;i<=n;i++){
		cout<<c[i]<<'\n';
	} 
}
```

---

## 作者：wht_1218 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11120)

----

我们可以把这一题分成几个部分。

首先，给定的座位情况**不一定对称**。为了解决这一问题，我们可以调整即将买票的乘客的位置，使得座位情况对称。

例如样例 $2$，我们为了让最终的座位情况对称，要让乘客 $1$ 选在 $(2,4)$ 的位置上。

如果乘客不足以将当前座位情况调整对称，就是无解。


接着，考虑剩下的乘客。由于此时座位情况**已经对称**，所以考虑乘客**两两入座**。因此，如果前面操作完毕后剩余乘客人数是**奇数**，则是无解。

例如样例 $5$，我们让座位情况对称后还有 $4$ 个乘客未入座，随便找到两对空位即可。

如果**座位已满还有乘客未入座**，则是无解。

~~怎么写的跟 AI 一样~~

实现细节其实不少。


```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1007][10],b[1007][10];
bool vis[1007][10];
int main(){
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=6;++j){
			if(j<4)cin>>a[i][j];
			else cin>>b[i][j-3];
		} 
	}for(int i=1;i<=n;++i){
		for(int j=1;j<=3;++j){
			if(a[i][j]!=b[i][3-j+1])m--,a[i][j]=b[i][3-j+1]='X';
		} 
	}if(m<0||m%2)return cout<<"Impossible",0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=3;++j){
			if(m>0&&a[i][j]=='.'&&b[i][3-j+1]=='.'){
				a[i][j]=b[i][3-j+1]='X';m-=2;
			}
		}
	}if(m!=0)return cout<<"Impossible",0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=6;++j){
			if(j<4)cout<<a[i][j];
			else cout<<b[i][j-3];
		}cout<<"\n";
	}
	return 0;
} 
```

几个**自己造的** hack 数据在[这里](https://www.luogu.com.cn/paste/94t2xm2c)

---

## 作者：xueshengyi (赞：0)

就是一道模拟，不是很难。

可以发现相互对称的作为的列数和为 $7$。

若一个作为已经被网上预订但它的对称作为仍然为空，就将乘客放置在它的对称点上，直到 $m = 0$ 时，直接判断即可。

这里注意，当 $m = 0$ 时，需直接判断。

若增加完后仍有剩余乘客，两个两个放置即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<=(y);i++)
#define foR(i,x,y,...) for(int i=(x),##__VA_ARGS__;i>=(y);i--)
#define Rep(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<(y);i++)
#define endl '\n'
#define debug(...)
#define debug1(a,i,...) cout<<i<<" "<<a[i]<<endl;
typedef long long ll;
#define fi first
#define se second
#define PII pair<int,int>
#define me(s,x) memset(s,x,sizeof s)
#define pb emplace_back

template<typename T=int>T read(){T x;cin>>x;return x;}
const int mod=998244353;
struct mint{
	int x;mint(int x=0):x(x<0?x+mod:x<mod?x:x-mod){}
	mint(ll y){y%=mod,x=y<0?y+mod:y;}
	mint& operator += (const mint &y){x=x+y.x<mod?x+y.x:x+y.x-mod;return *this;}
	mint& operator -= (const mint &y){x=x<y.x?x-y.x+mod:x-y.x;return *this;}
	mint& operator *= (const mint &y){x=1ll*x*y.x%mod;return *this;}
	friend mint operator + (mint x,const mint &y){return x+y;}
	friend mint operator - (mint x,const mint &y){return x-y;}
	friend mint operator * (mint x,const mint &y){return x*y;}
};mint Pow(mint x,ll y=mod-2){mint z(1);for(;y;y>>=1,x*=x)if(y&1)z*=x;return z;}
const int N=1010;
bool vis[N][10];
void MAIN(){
	int n,m;
	cin>>n>>m;
	int cnt=0;
	For(i,1,n){
		For(j,1,6){
			char c;
			cin>>c;
			vis[i][j]=c=='.'?0:1;
			if(vis[i][j]) cnt++;
		}
	}
	if(n*6<m+cnt){
		puts("Impossible");
		exit(0);
	}
	if(m==0) goto togo;
	For(i,1,n){
		For(j,1,3){
			if(vis[i][j]){
				if(!vis[i][7-j]){
					vis[i][7-j]=1;
					m--; 
				}
				if(m==0) goto togo;
			}
		}
	}
	For(i,1,n){
		For(j,4,6){
			if(vis[i][j]){
				if(!vis[i][7-j]){
					vis[i][7-j]=1;
					m--; 
				}
				if(m==0) goto togo;
			}
		}
	}
	if(m&1) puts("Impossible"),exit(0);
	For(i,1,n){
		For(j,1,3){
			if(!vis[i][j]){
				vis[i][j]=vis[i][7-j]=1;
				m-=2;
				if(m==0) goto togo;
			}
		}
	}
	togo:
	For(i,1,n){
		For(j,1,3){
			if(vis[i][j]!=vis[i][7-j]){
				puts("Impossible"),exit(0);
			}
		} 
	} 
	for(int i=1;i<=n;i++,puts(""))For(j,1,6){
		cout<<(vis[i][j]?"X":".");
	}
}int main(){
	int t=1;while(t--){
		MAIN();
	}
	return 0;
}
```

---

## 作者：hyl_____ (赞：0)

## Part 0 前言
这种题一看就是签到题，也是特水，建议评红或橙。
## Part 1 思路
思路就是先将已有位置先填对称，然后将剩余还未添加的乘客以对称方式填入。

首先可以特判掉需要的位置大于空位的情况，直接输出 `Impossible`。

然后用数组记录 `.` 和 `X` 的位置，先遍历所有 `X` 的位置，然后看他的对称位置是否为空，若为空，则填入 `X`，然后 `m--`。最后若 $m < 0$，则说明现有的人不能满足对称（太少了），若 $m \bmod 2 = 0$，则说明还未添加的乘客不能以对称方式填入，这两种都应输出 `Impossible`。

最后遍历所有 `.` 的位置，以对称方式填入即可。

## Part 2 AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1010][10];
struct seat{
	int x;
	int y;
}Map[10100],Mpa[10100];//记录位置
int main()
{
	int n,m,sum1=0,sum2=0,num1=1,num2=1;//记录数量
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			cin>>a[i][j];
			if(a[i][j]=='X'){
				sum1++;
				Map[num1].x=i;
				Map[num1].y=j;
				num1+=1;
			} 
			else{
				sum2++;
				Mpa[num2].x=i;
				Mpa[num2].y=j;
				num2+=1;
			}
		}
	} 
	if(n*6-sum1<m){
		cout<<"Impossible";
		return 0;
	}//特判
	for(int i=1;i<=sum1;i++){
		if(a[Map[i].x][7-Map[i].y]!='X') m--,a[Map[i].x][7-Map[i].y]='X';//若对称位上没有，则填入
	}
	if(m<0||m%2==1){
		cout<<"Impossible";
		return 0;
	}//判定
	for(int i=1;i<=sum2;i++){
		if(m==0) break;
		if(a[Mpa[i].x][7-Mpa[i].y]!='X') m-=2,a[Mpa[i].x][7-Mpa[i].y]='X',a[Mpa[i].x][Mpa[i].y]='X';;//若对称位上没有，则填入
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			cout<<a[i][j];
		}
		cout<<endl;
	} 
	return 0;
}
/*完结撒花(*^▽^*)*/
```

---


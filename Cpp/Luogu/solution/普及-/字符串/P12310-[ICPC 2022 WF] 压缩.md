# [ICPC 2022 WF] 压缩

## 题目描述

无限压缩计划联盟（*Infinite Compression Plan Consortium*, ICPC）开发出了一种全新的，伟大的数据压缩策略，称作「不要重复自己」（*Don't Repeat Yourself*, DRY）。DRY 适用于字符串，如果字符串中包含连续两个相同的子串，它就会删除其中一个。例如，在字符串 `alfalfa seeds` 中，它可以移除子串 `seeds` 中两个 `e` 中的一个，和子串 `alfalfa` 中两个 `lfa` 中的一个，结果为 `alfa seds`。DRY 也可以利用之前的删除操作——例如，在字符串 `seventeenth baggage` 中，首先会移除 `seventeenth` 中重复的 `e` 和 `baggage` 中重复的 `g`，得到 `sevententh bagage`，然后删除 `sevententh` 中重复的 `ent` 和 `bagage` 中重复的 `ag`，得到 `seventh bage`。

如果有多种删除连续重复子串的方法，DRY 会选择可以得到最短的最终子串的删除方法。例如，对于字符串 `ABBCDCABCDCD`，DRY 有两种选择——要么删除靠近开头的两个重复的 `B` 中的一个，或者删除结尾处重复的 `CD`。如果删除了 `B`，则 DRY 就可以删除重复的 `ABCDC`，获得 `ABCDCD`，然后就可以删除结尾的 `CD`，最终得到 `ABCD`。然而，如果 DRY 首先移除了结尾的 `CD`，首先会得到 `ABBCDCABCD`，这样只能删除连续的 `B`，得到 `ABCDCABCD`——这个字符串不能移除更多字符了。因此，对于 DRY 来说正确的选择是先压缩两个 `B`，然后得到 `ABCD`。

ICPC 观察到 DRY 在二进制串上能得到最佳结果——也就是只包含 0 和 1 的字符串。因此，因此，你的任务就是在二进制字符串上实现最佳的 DRY 算法。对于任意二进制串，你都应该输出一个通过反复使用 DRY 算法可以得到的最短字符串。

## 样例 #1

### 输入

```
1111
```

### 输出

```
1
```

## 样例 #2

### 输入

```
101
```

### 输出

```
101
```

## 样例 #3

### 输入

```
10110
```

### 输出

```
10
```

# 题解

## 作者：htl2025 (赞：2)

~~又是一道难（shui）题。~~
## 分析

1. 检查当前末尾是否存在**两个相邻相等的子串**。
2. 如果存在，就删去其中一个。
3. 不断重复这个过程，直到无法再压缩。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s, res;
    cin >> s;
    for (char c : s)
    {
        res += c;
        int len = res.size();//长度
        for (int l = 1; l * 2 <= len; ++l)
        {
            if (res.substr(len - 2 * l, l) == res.substr(len - l, l))
            {
                res.erase(len - l, l);//去除相等的子串中一个
                break;
            }
        }
    }
    cout << res << '\n';//输出
    return 0;
}
```

---

## 作者：JIN_LONG (赞：1)

## 思路：

- 首先要将两个字符串合并，不过在合并的过程中，字符串 $s_1$ 需要去除重复的字符。
- 然后再讲合并完成的字符串从末尾开始删除，每一次删除两个字符，直到字符串长度小于 $4$ 为止。

## 代码：

```
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int main(){
	cin>>s1;
	for(int i=0;i<s1.size();i++){
        if(s1[i]!=s1[i+1]){
            s2+=s1[i];
        } 
    }
	while(s2.size()>=4){
     	s2.pop_back();
      s2.pop_back();   
    }
	cout<<s2;
    return 0;
}
```

---

## 作者：Potato24 (赞：1)

## 声明
该题解为原创，结论参考了 [zqx168](https://www.luogu.com.cn/user/1279390) 的[题解](https://www.luogu.com.cn/article/htf1yjfm)。
## 思路
```cpp
#include<bits/stdc++.h>
using namespace std;
```
一定要记得把数组开在主函数外面。

注意字符串的范围是 $10^5$。
```cpp
int c[100010];
int main()
{
}
```
输入（这里 $i$ 指的是目前字符串的长度，后面也会用到）。
```cpp
int i=1;
while(cin>>c[i])
  i++;
i--;
```
然后设一个循环，`if_have` 用于判断是否有连续重复的字符串。
```cpp
bool if_have=true;
while(if_have)
{
  if_have=false;//这里要重置
```
> `11010` 不管是先删 `1` 还是先删 `10` 结果都是 `10`。而且当 `101101` 的时候会优先删 `1`，`010010` 也如此。所以每次要么删 $2$ 个，要么删 $1$ 个。

所以我们只需要设两个循环。
第一个循环从 $2$ 开始枚举，对于每一个 $c[j]$ 判断是否与 $c[j-1]$ 相同。
如果相同，把 $c[j]$ 删掉，后面的补上。
也就是 `for(int k=j;k<=i-1;k++)c[k]=c[k+1];`。
最后， `if_have` $=$ `true`，长度 $i\gets i-1$。
```cpp
for(int j=2;j<=i;j++)
  if(c[j]==c[j-1])
  {
    for(int k=j;k<=i-1;k++)
      c[k]=c[k+1];
    if_have=true;
    i--;
  }
```
第二个循环从 $4$ 开始枚举，对于每一个 $c[j]$ 判断是否与 $c[j-2]$ 相同，对于每一个 $c[j-1]$ 判断是否与 $c[j-4]$ 相同。
如果相同，把 $c[j]$ 和 $c[j-1]$ 删掉，后面的补上。
也就是 `for(int k=j-1;k<=i-2;k++)c[k]=c[k+2];`。
最后， `if_have` $\gets$ `true`，长度 $i\gets i-2$。
```cpp
for(int j=4;j<=i;j++)
  if(c[j]==c[j-2]&&c[j-1]==c[j-3])
  {
    for(int k=j-1;k<=i-2;k++)
      c[k]=c[k+2];
    i-=2;
    if_have=true;
  }
```
最后输出结果。
```cpp
for(int j=1;j<=i;j++)
  cout<<c[j];
```
漂亮的结尾。
```cpp
  return 0;
}
```
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char c[100010];
int main()
{
    int i=1;
    while(cin>>c[i])
        i++;
    i--;
    bool if_have=true;
    while(if_have)
        {
            if_have=false;
            for(int j=2;j<=i;j++)
                if(c[j]==c[j-1])
                {
                    for(int k=j;k<=i-1;k++)
                        c[k]=c[k+1];
                    if_have=true;
                    i--;
                }
            for(int j=4;j<=i;j++)
                if(c[j]==c[j-2]&&c[j-1]==c[j-3])
                {
                    for(int k=j-1;k<=i-2;k++)
                        c[k]=c[k+2];
                    i-=2;
                    if_have=true;
                }
        }
    for(int j=1;j<=i;j++)
        cout<<c[j];
    return 0;
}
```

---

## 作者：Evan2000 (赞：1)

## 题意
给你一个只包含 0 和 1 的字符串，如果字符串中包含连续两个相同的子串，删除其中一个，直到无法再删除为止，最后输出进行一系列删除后的字符串。
## 思路
我的主要思路就是暴力枚举，找到相同的两个连续子串就删除其中的一个，根据一定的分析就能发现，只需要寻找长度为 1 或 2 的子串即可。

首先写一个大循环，在里面遍历字符串，如果找到两个连续且相同的长度为 1 的子串，就删掉一个，退出遍历，然后再遍历一次字符串，这次如果找到两个连续且相同的长度为 2 的子串，就删掉一个，退出遍历。在开始时设一个变量用来记录这两次遍历是否删除过子串，如果一个子串都没有删除过，说明已经无法删除更多的子串，直接退出大循环并输出最终的字符串即可。
## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main()
{
	cin>>s;
	int len=s.size();//算出字符串的长度
	while(1)
	{
		int flag=0;
		for(int i=0;i<len-1;i++)
		{
			if(s[i]==s[i+1])//先判一下有没有两个长度1的子串相同且是连续的
			{
				s.erase(i,1);
				len--;
				flag=1;
				break;//退出，等到下一次大循环再判断
			}
		}
		for(int i=0;i<len-3;i++)
		{
			if(s[i]==s[i+2] && s[i+1]==s[i+3])//再判一下有没有两个长度为2的子串相同且是连续的
			{
				s.erase(i,2);
				len-=2;
				flag=1;
				break;//退出，等到下一次大循环再判断
			}
		}
		if(flag==0)//如果已经无法再删除子串，就退出大循环
		{
			break;
		}
	}
	cout<<s;//输出最终的字符串
	return 0;
}
```
## 关于 erase 函数
这是一个专门用于删除容器中的元素的成员函数，可以用于 ```string``` 和 ```vector``` 等容器，因为这题用的是 ```string```，所以我就只讲一下此函数在 ```string``` 中的用法。

```s.erase(x,y)``` 表示从字符串 ```s``` 中的位置 $x$ 开始，删除 $y$ 个字符，比如 ```s.erase(1,5)``` 表示的就是从字符串 ```s``` 中的第 $1$ 位开始，删除 $5$ 个字符。

希望管理能给过！

---

## 作者：yongqian123 (赞：1)

## 题目分析
先压缩单个字符 $\texttt0$ $\texttt1$，变成了相邻字符不同的数，即 $\texttt{\dots1010}$ 或 $\texttt{\dots0101}$。

即可压缩 $\texttt{10}$ 或 $\texttt{01}$，那么由于在 $\texttt{10}$ 和 $\texttt{01}$ 之外的仅有一个字符甚至没有字符，所以最多只可能压缩到 $3$ 个字符，即 $\texttt{101}$ 和 $\texttt{010}$，无法再压缩。

则若第一次压缩超过 $3$ 个字符的，必须从后往前两个两个地压缩，直到不超过 $3$ 个字符。

两个两个地压缩，则压缩前与压缩后的字符数奇偶性相同，即从串首输出到第 `2 + (s.size() & 1)` 个字符。

## 核心代码
```cpp
char a = ' ', b;
string s = "";
while (cin >> b){
	if (a != b) s += b;
	a = b;
}for (int i = 0; i < 2 + (s.size() & 1) && i < s.size(); i++) cout << s[i];

```

---

## 作者：lcycl (赞：0)

## 题目大意
给定一个只有 $0$ 和 $1$ 的字符串，将其中**连续且相同**的字串删除其中一个。  
# 思路
第一眼是暴力，通过枚举每次删除的长度，将最优的方法记录，最后输出。但是显然会 TLE。

我们可以发现，只要字符串的长度达到了 $4$，那么就必定有 相同且连续的字串。如： $1010$ 中的 $10$，$1001$ 中的  $0$ 。所以我们的操作可以简化成两个：压缩 $11$ 和 $00$ 或压缩 $1010$ 和 $0101$。而后者可以再次简化成删除末尾两个字符。  

压缩解决了，那什么时候停止压缩呢？我们发现，当字符串的长度达到 $3$ 的时候，就不能再压缩了，如 $101$ 和 $010$。所以当字符串的长度**大于等于 $4$** 的时候就继续压缩。

# 代码   
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin>>s;
    int i;
    for(i=0;i<s.size();i++){
        while(s[i]==s[i+1]) s.erase(i,1);//压缩 11 或 00。用 while 是为了预防像 1001 这种情况
    }
    while(s.size()>=4) s.erase(s.size()-1,2);//不断删除末尾两个字符直到字符串长度小于4
    cout<<s;
    return 0;
}
```

---

## 作者：Noob_Oler (赞：0)

## 大致题意

ICPC 开发了名为 DRY 的数据压缩策略，该策略适用于字符串，当字符串包含同一子字符串的两个连续实例时，可删除其中一个实例，且可利用之前移除后的结果继续进行删除操作。DRY 操作要以产生最短最终字符串为目标。现在 ICPC 发现 DRY 在二进制字符串（仅由 $0$ 和 $1$ 组成）上效果最佳，要求实现适用于二进制字符串的最佳 DRY 算法，即对于任意给定的二进制字符串，输出通过重复应用 DRY 操作后能得到的最短字符串。

再简化一下的题意就是：

读入一个 $01$ 字符串，把其中连续相同的字串删除，只删一个。

## 思路
我们可以使用贪心。

先遍历一遍字符串，又可以压缩的就先压缩。

如果长度还 $\ge 4$ 就再压缩。

举个例子，`1010`可以删掉一个`10`,`1001`可以删掉一个`0`。

直到长度 $\le 4$ 才可以不压缩。

## Code
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s,ss;
	cin >> s;
	for(int i = 0; i < s.size(); i++) if(s[i] != s[i + 1]) ss += s[i];
	while(ss.size() >= 4) 
    {
        ss.pop_back();
        ss.pop_back();
    }
	cout << ss;
	return 0;
}
```

---

## 作者：Yumi_Anaxa_ (赞：0)

貌似是道贪心。
## 思路
贪心策略可以在每一步选择能最大程度上缩短字符串的操作，所以要优先处理最大的重复子串。因为删掉更大的区块后续就能压缩更多次，得到更短的结果。\
复杂度 $O(n^3)$，$n$ 是字符串长度。\
提交后：~~听取 TLE 声一片。~~\
**具体思路**：
1. **删掉连续的并重复的字符**：
首先删掉连续的并重复的字符，确保最终得到的字符串中不存在相邻的相同字符，这样能压缩更多次来得到更短的结果。
2. **删掉连续重复子串**：
循环检查并删掉长度为 $2$ 的连续并且重复的子串。这样可以**正确处理**掉通过删掉连续并且重复项就能压缩更长子串的情况。
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
string init(string s){
    string res;
    for (char c : s)if (res.empty() || res.back() != c)res.push_back(c);
    return res;
}
string solve(string s){
    bool flag;
    do{//发现while好像不行
        flag = 0;//初始化
        int n = s.size();
        for (int i = 0; i + 3 < n; ++i)
            if (s[i] == s[i+2] && s[i+1] == s[i+3]){
                s = s.substr(0, i+2) + s.substr(i+4);
                flag = 1;
                break;
            }
    }while(flag);
    return s;
}
int main(){
    string s;
    cin >> s;
    s = init(s);
    s = solve(s);
    cout << s;
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目不传送门](https://www.luogu.com.cn/problem/solution/P12310)
## 题目分析
这道题的数据范围很小，字符串长度只有 $10^5$，所以可以大胆的**暴力**，题目中说过，如果有多种删除方法，优先选择**短的**子字符串。

仅需用到 ```erese``` 和 ```substr``` 即可。至于 ```erase``` 和 ```substr``` 的用法，```substr``` 是用来截取字符串的，而 ```erase``` 是用来删除字符串的。~~这里就不细说了~~
## 题目代码
~~~cpp
#include <bits/stdc++.h>
using namespace std;
string s, c;
int main(){
    cin >> s;
    for (int i=0;i<=s.size();i++){
        c += s[i];
        int len = c.size();//长度
        for (int l = 1; l * 2 <= len; ++l)
        {
            if (c.substr(len - 2 * l, l) == c.substr(len - l, l))
            {
                c.erase(len - l, l);
                break;
            }
        }
    }
    cout << c ;
    return 0;
}
~~~

---


# 重生有惊喜

## 题目背景


---

在本题中，对于一个字符串 $x$，用 $|x|$ 表示 $x$ 的长度，$x_i$ 表示 $x$ 的第 $i$ 个字符（$1 \leq i \leq |x|$，即字符串下标从 $1$ 起）。称 $x$ 是一个回文串当且仅当对全部的 $1 \leq i \leq |x|$ 都有 $x_i = x_{|x| - i + 1}$。


## 题目描述


给定一个字符串 $s$，你可以做如下操作**任意多**（可以为 $0$）次：

- 选择两个下标 $i,j$ 满足 $1 \leq i , j \leq |s|$。
- 交换 $s_i$ 和 $s_j$，即交换字符串 $s$ 的第 $i$ 个和第 $j$ 个字符。

你要求出：是否存在一种方法，使得在若干次操作后，得到的字符串是一个**回文串**。


## 说明/提示

- 对 $40\%$ 的数据，$T = 1$。
- 对 $70\%$ 的数据，$|s| \leq 9$。
- 对 $100\%$ 的数据，$1 \leq T \leq 10$，$1 \leq |s| \leq 10^4$，$s$ 中仅含小写英文字母。

## 样例 #1

### 输入

```
3
aba
abab
abcd```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：wawatime1 (赞：7)

### 题目分析
本题要求判断给定字符串是否可以通过任意次交换操作变成一个回文串。
关键在于理解回文串的性质：对于一个回文串，每个字符出现的次数必须满足以下条件：
- 如果字符串长度为偶数，每个字符出现的次数必须是偶数。
- 如果字符串长度为奇数，恰好有一个字符出现奇数次，其余字符出现偶数次。
### 解题思路
我们可以通过统计每个字符的出现次数，并检查奇数次出现的字符数量来解决这个问题：
- 统计每个字符的出现次数。
- 计算出现奇数次的字符数量。
- 如果奇数次字符的数量不超过 1，则可以通过交换操作形成回文串，否则不能。
### 代码
```cpp
#include <bits/stdc++.h>
#define nailong 114514
using namespace std;
int t;int a[26];
bool f(string s) {
	memset (a, 0, sizeof(a));
	for (char d : s) a[d - 'a']++;
	int c = 0;
	for (int i = 0; i < 26; i++) if (a[i] % 2) c++;
	return c <= 1;
}
int main() {
	cin>>t;
	cin.ignore();
	while (t--) {
		string s;
		cin >> s;
		cout << (f(s) ? "Yes" : "No")<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

因为这个字符串是可以通过交换变成任何样子的，所以我们可以统计每个字符出现的次数，然后再判断这些字符是否构成回文就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t[30];//t数组来存出现次数
string s;
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> s;
		for(int j=0;j<s.size();j++) t[s[j]-96]++;//次数+1
		int cnt=0;
		for(int j=1;j<=26;j++){
			if(t[j]%2==1) cnt++;//有偶数个就能放在对称的位置，统计出现次数为奇数的个数
            t[j]=0;//算完一次记得归零！
		}
		if(cnt<=1) cout << "Yes" << endl;//有1个奇数时可以放中间，所以<=1
		else cout << "No" << endl;
	}
	return 0;
}
```

---

## 作者：chenzefan (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P12592)
## 前言
赛时 AC 了，交一发题解。
## 思路
字符串题。

因为回文字符串除中间字符外（当长度是奇数时），其他字符都成对出现。

所以，用一个 map，记录字符串 $S$ 中各个字符的数量，如果最后数量是奇数，则记录一次，反之则不用。

当奇数的数量为超过 $1$ 时，则无法变成回文字符串。

操作可以再循环内同时解决。

**注意：多测不清空，爆零两行泪。**

时间复杂度：$O(t \times len)$，其中，$t$ 是测试次数，$len$ 是字符串长度。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	map <char,int> mp;
    int t;
    cin>>t;
    while(t--){
    	mp.clear(); //清空
    	string s;
    	cin>>s;int cnt=0;
    	for(int i=0;i<s.size();i++){
    		mp[s[i]]++;//累计
    		if(mp[s[i]]%2==1) cnt++;
    		else cnt--;
		}
		if(cnt<=1) printf("Yes\n");//考虑到字符串长度是奇数的情况
		else printf("No\n");
	}
    return 0;
}
```

---

## 作者：cjy0329 (赞：3)

## 重生有惊喜题解

### 前言

本蒟蒻花了一小时才切出来。

### 题意

一个字符串，交换一些字符，判断能否使其变成**回文串**。

### 分析

因为交换次数不限，所以相当于把字符串的顺序改变（打乱）。

回文串分为**奇回文**和**偶回文**。

我们定义**奇回文**，除了中间一项，其他都能左右两两配对，如：

$\color{red}\texttt{a}\color{blue}\texttt{c}\color{green}\texttt{d}\color{blue}\texttt{c}\color{red}\texttt{a}$

我们定义**偶回文**，每个字符都能左右两两配对，如：

$\color{red}\texttt{a}\color{blue}\texttt{c}\color{green}\texttt{d}\color{green}\texttt{d}\color{blue}\texttt{c}\color{red}\texttt{a}$

对于奇回文，有一种字符数量为奇数，其他字符的数量都为偶数；

对于偶回文，所有字符数量都为偶数。

### 代码

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
string s;
int num[999];                  //统计字符数量
int doing() {
	memset(num, 0, sizeof num);//多组数据，初始化
	cin >> s;
	for (int i = 0; i < s.size(); i++) {
		int now = s[i];        //当前字符
		num[now]++;            //该字符数量+1
	}
	int ans = 0;
	for (int i = 'a'; i <= 'z'; i++) {
		if (num[i] & 1)
			ans++;             //统计无法配对字符的数量
	}
	if (s.size()&1){		   //长度为奇数，奇回文
		if(ans==1)puts("Yes");
		else puts("No");
	}else{                     //长度为偶数，偶回文
		if(ans==0)puts("Yes");
		else puts("No");
	}
	return 0;
}
int main() {
	int t;
	cin >> t;
	while (t--)doing();        //多组数据
	return 0;
}
```

---

## 作者：prh_rpjiajia (赞：2)

### 思路
首先关注到，本题并没有要求求出最小步数，仅求出是否可以将原本的字符串变成回文串。

先给出结论：一个回文字符串中，出现次数为奇数的字母不超过 $1$ 个。（稍后会有证明）

根据这个性质，我们可以利用桶，统计每个字母出现的次数，然后遍历一遍判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[205];
int main(){
    int T;cin>>T;
    while(T--){
        memset(f,0,sizeof f);
        string s;cin>>s;
        for (int i=0;i<s.length();++i){
            f[s[i]]++;
        }
        int j=0,o=0;
        for (int i='a';i<='z';++i){
            if (f[i]%2==0)o++;
            else j++;
        }
        if (j>=2)cout<<"No"<<'\n';
        else cout<<"Yes"<<'\n';
    }
}
```
### 证明
命题：一个回文字符串中，出现次数为奇数的字母不超过 $1$ 个。

定义：
- 回文字符串是满足 $\forall i, s_i = s_{n+1-i} $ 的字符串 $s = s_1 s_2 \dots s_n$。
- 定义 $\operatorname{cnt}(c)$ 表示字符 $c$ 在 $s$ 中的出现次数。

首先，任意回文字符串有对称配对性，对于任意非中心字符 $s_i$（即 $i \neq \frac{n+1}{2}$），存在唯一匹配字符 $s_j = s_{n+1-i}$。

容易发现：
   - 非中心字符总是**成对出现**，每对贡献 $+2$ 次计数。
   - 所有非中心字符的 $\operatorname{cnt}(c)$ 均为偶数。

   - 若长度 $n$ 为奇数，中心字符 $s_{\frac{n+1}{2}}$ 无配对。
   - 其 $\operatorname{cnt}(c)$ 为**奇数**（因单独出现 $1$ 次）。

或者这样证：

咱们分类讨论
- **情况1（偶数长度）**：
  无中心字符 $\to$ 所有字符均成对出现 $\to$ 所有 $\operatorname{cnt}(c)$ 为偶数  
  ⇒ 奇数次数字符数量 $= 0$。

- **情况2（奇数长度）**：
  仅中心字符可能具有奇数次计数，其余字符均成对出现 $\to$ 奇数次数字符数量 $\le 1$。



因此，一个回文字符串中，出现次数为奇数的字母不超过 $1$ 个。  

证毕。

---

## 作者：yanrs111019 (赞：2)

# 题解：P12592 重生有惊喜  
## 分析题目本质  
注意到，操作次数任意，每次交换随便两个字符。  
这意味着我们可以用已有的字符串的字符，随意排列，组成新的字符串。  
那么问题就转化成了当前有的字符，是否能组成一个回文串。  
## 分析回文串性质  
### 偶回文串  
当回文串长度为偶数时，那么每个字符出现的次数必定为偶数。  
### 奇回文串  
当回文串长度为奇数时，那么每个字符出现的次数，有且仅有一个是奇数，剩下的全部是偶数。  
### 总结  
那么，将两者结合，也就是对于所有字符，最多有一个字符出现次数是奇数，剩下均为偶数。  
## AC code  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL cnt[30];
int main(){
	LL T;
	string str;
	scanf("%lld",&T);
	while(T--){
		memset(cnt,0,sizeof cnt);
		cin>>str;
		bool flag=0;
		LL n=str.size();
		str=' '+str;
		for(LL i=1;i<=n;i++){
			cnt[str[i]-'a']++;
		}
		bool ok=1;
		for(LL i=0;i<=25;i++){
			if(cnt[i]%2==1){
				if(!flag)flag=1;
				else{
					ok=0;
					printf("No\n");
					break;
				}
			}
		}
		if(ok)printf("Yes\n");
	}
	return 0;
}
```
**多测记得清空。**

---

## 作者：__Jared__ (赞：1)

## 思路

观察可以发现，当每个字母出现次数为偶数，或者当且仅有一个字母出现过奇数次，则可以判断其可以在通过数次交换后成为回文字符串；

同理，由异或性质，同为零异为一则可以借助此省去取模的操作。

通过一个桶即可实现对每个字母出现的次数的纪录。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
bool mp[25];
string s;
signed main()
{
	scanf("%d",&T);
	while(T--)
	{
		m=0;
		for(short i=0;i<=24;i++) mp[i]=0;
		cin>>s;
		for(int i=0;i<s.size();i++) mp[s[i]-'a']^=1;
		for(short i=0;i<=24&&m<2;i++) m+=mp[i];
		if(m<2) printf("Yes\n");
		else printf("No\n");
	}
}
```

---

## 作者：封禁用户 (赞：1)

# P12592 重生有惊喜 题解

## 题意

给定一个字符串，你可以任意次交换任意两个字符，问能否通过这些操作让字符串变成**回文串**。

## 思路

因为可以任意次交换字符，这就意味着我们可以重新排列字符顺序。

要判断是否能构成回文串，只需要判断字符出现的频次是否满足回文的结构要求。

### 回文的字符判断方法

* 若字符串长度是**偶数**：所有字符必须出现**偶数次**。
* 若字符串长度是**奇数**：**最多只有一个字符**可以出现**奇数次**，其余字符必须出现偶数次。

## 代码

我们只需统计每个字符出现的次数，判断有多少个字符出现了奇数次即可。
```python
from collections import Counter

T = int(input())
for _ in range(T):
    s = input()
    a = Counter(s)
    b = sum(1 for c in a.values() if c % 2 == 1)
    if b <= 1:
        print("Yes")
    else:
        print("No")

```

---

## 作者：ADKT_YL (赞：1)

# 题解：P12592 重生有惊喜
## 思路
由于可以交换任意两个字符，且交换次数不限，我们会发现这个字符串可以变成其任意排列。所以只要分析什么样的字符组合可以排列成回文串即可。  
**那什么样的字符组合可以排列成回文串呢？**  
假如这个回文串 $x$ 的长度 $|x|$ 是奇数，那么根据 $x_i=x_{|x|-i+1}$ 可知**除去字符串最中间的字符以外任意一种字符在字符串中都出现了偶数次，而最中间的字符则出现了奇数次。**  
假设这个回文串 $x$ 的长度 $|x|$ 是偶数，那么根据 $x_i=x_{|x|-i+1}$ 可知**每一种字符在字符串中都出现了偶数次。**  
所以在代码中就可以先判断字符串 $x$ 的长度 $|x|$ 是奇数还是偶数，再根据结果判断 $x$ 是否满足条件，最后输出结果即可。  
需要注意的是，由于本题单个测试点内有多组测试数据，请注意清空原记录。
## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s; 
int m[256];
int main(){
	cin>>t;
	while(t--){
		int c=0;
		cin>>s;
		memset(m,0,sizeof m);
		for(int i=0;i<s.size();i++) m[s[i]]++;
		if(s.size()%2==0){
			for(int i=0;i<256;i++){
				if(m[i]%2==1) c++;
			}
			if(c==0) cout<<"Yes\n";
			else cout<<"No\n";
		}else{
			for(int i=0;i<256;i++){
				if(m[i]%2==1) c++;
			}
			if(c==1) cout<<"Yes\n";
			else cout<<"No\n";
		}
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

容易发现通过交换操作我们可以将字符串任意重排。题目即求输入的字符串重排后能否得到回文串。

对于一个回文串，由于它顺着读和倒着读都是一样的，所以除长度为奇数时最中间的元素外其余元素应该都会成对出现。

因此要么所有字母出现的次数都必须为偶数，要么只有一种字母出现的次数为奇数。时间复杂度 $O(Tn)$。


```cpp
#include<bits/stdc++.h>
using namespace std;

int a[30];

int main(){
    int t;cin>>t;
    while(t--){
        string s;cin>>s;int n=s.size();
        for(int i=0; i<n; i++) a[s[i]-'a']++;
        int ev=0;
        for(int i=0; i<26; i++){
            if(a[i]%2) ev++;
            a[i]=0;
        } 
        if(ev<=1) cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
```

---

## 作者：0Io_oI0 (赞：1)

基础题。

题目其实就是给我们 $n$ 个字符串，问我们这 $n$ 个字符串能否通过改变每个字符的位置是的这个字符串变成一个回文串。

我们分两种情况讨论：

1. 若这个字符串的长度是一个偶数，则在这个字符串里出现的字符都需要出现偶数次，才能满足条件。
2. 若这个字符串的长度是一个奇数，则在这个字符串中的字符有且仅有一个出现奇数次，其余都出现偶数次。

这样这道题目就简单了，使用 `map` 记录每个字符串中字符的出现个数，然后分两种情况判断就好了。

代码：

```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
#define int long long
#define double long double
#define R register
I AK IOI;
int n;
string s[15];
map<char,int>mp[15];
i_will ak IMO{
	//freopen("","r",stdin);
	//freopen("","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		for(int j=0;j<s[i].size();j++)mp[i][s[i][j]]++;
	}
	for(int i=1;i<=n;i++){
		int ss=s[i].size();
		if(ss%2==0){
			bool flag=0;
			for(auto it:mp[i]){
				if((it.second)%2==1){
					flag=1;
					break;
				}
			}
			if(flag)puts("No");
			else puts("Yes");
		}
		else{
			bool flag=0;
			int cnt=0;
			for(auto it:mp[i]){
				if(cnt>1){
					flag=1;
					break;
				}
				if((it.second)%2==1)cnt++;
			}
			if(flag)puts("No");
			else puts("Yes");
		}
	}
	i_ak ioi;
}
```

亲测可过，请勿抄袭！

---

## 作者：swate114514 (赞：1)

## 题意
判断给定的字符串 $s$ 是否可以通过任意次数的字符交换操作变成回文串。回文串的定义是正读和反读都相同的字符串，例如 `level` 或 `noon`。

## 思路
我们知道，一个字符串可以排列成回文串的条件分为两种情况：
1. 如果字符串长度为偶数，所有字符的出现次数必须都是偶数。

2. 如果字符串长度为奇数，恰好有一个字符的出现次数是奇数，其余都是偶数。


由于可以任意交换字符的位置，因此字符的排列顺序不重要，只需要统计每个字符的出现次数即可。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

bool cmp(const string &s) {
	vector<int> cnt(26, 0);
	for (char c : s) {
		cnt[c - 'a']++;
	}
	int cnt2 = 0;
	for (int num : cnt) {
		if (num % 2 != 0) {
			cnt2++;
		}
	}
	return cnt2 <= 1;
}

int main() {
	int T;
	cin >> T;
	while (T--) {
		string s;
		cin >> s;
		if (cmp(s)) {
			cout << "Yes\n";
		} else {
			cout << "No\n";
		}
	}
	
	return 0;
}
```

---

## 作者：daitangchen2008 (赞：0)

## 思路 
原字符串能被重排为一个回文串，当且仅当原串中只有零个或一个小写字母的数量是奇数。   
依据这个思路记录每个小写字母出现个数后判断奇数个数即可。  

注意多测清空，时间复杂度 $O(n)$。  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005];
signed main()
{
	int T;
	cin>>T;
	while(T--)
	{
		string st;
		cin>>st;
		int n=st.size();
		st=' '+st;
		for(int i=1;i<=n;i++)
			a[(int)(st[i]-'a')]++;
		int flag=0;	
		for(int i=0;i<=25;i++)
			if(a[i]%2==1)
			flag++;		
		if(flag>1)
			cout<<"No\n";
		else
			cout<<"Yes\n";
		for(int i=0;i<=255;i++)
			a[i]=0;
	}
	return 0;
 }
```

---

## 作者：一扶苏一 (赞：0)

注意到一个回文串的字母除了对称轴都是成对出现的。因此一个串可以被重排成回文的充要条件是至多存在一个字母出现了奇数次。

当所有字母都是偶数次出现时，回文串的对称轴在中间两个字母之间，仅有一个出现奇数次的字母时，对称轴是该字母。

统计所有字母出现次数，检查其中奇数的个数即可。

```cpp
#include <bits/stdc++.h>

int main() {
  int T;
  std::cin >> T;
  for (auto _ : std::views::iota(0, T)) {
    std::string s;
    std::cin >> s;
    auto a = std::accumulate(s.begin(), s.end(), std::map<char, int>(), [](auto &&ret, char c) {
      ++ret[c];
      return std::move(ret);
    });
    std::cout << std::format("{}\n", (std::count_if(a.begin(), a.end(), [](auto &&it) {
      return it.second & 1;
    }) >= 2) ? "No" : "Yes");
  }
}
```

---


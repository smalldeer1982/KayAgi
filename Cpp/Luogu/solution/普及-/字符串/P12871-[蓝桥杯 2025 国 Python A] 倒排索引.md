# [蓝桥杯 2025 国 Python A] 倒排索引

## 题目描述

在信息检索系统中，倒排索引是一种常用的数据结构，用于快速查找包含特定词语的文档集合。为了增强搜索的灵活性，我们引入了 N-Gram 分词算法，参数 $[\min, \max]$，表示分别按照长度 $\min$、$\min+1$、$\cdots$、$\max$ 对单词进行滑动窗口截取。例如对于 $[3, 5]$ 的 N-Gram，会将单词 $\tt{lanqb}$ 分割为 $[\tt{lan, anq, nqb, lanq, anqb, lanqb}]$ 的索引序列，如果文档长度小于 $\min$，那么索引序列只包含文档本身。

给定 $n$ 个文档，对于第 $i$ 个文档 $d_i$，利用上述的 N-Gram 算法为其生成一组索引序列 $L_i$。对于查询词 $q$，也对其应用 N-Gram 为其生成一个索引序列 $P$，如果序列 $P$ 中的某个单词出现在序列 $L_i$ 中，那么就认为查询词和文档 $d_i$ 匹配成功。

请统计查询词 $q$ 能与多少个文档匹配成功。

## 说明/提示

**【样例说明】**

文档分词结果如下：

- $\tt{angel}$：$[\tt{ang, nge, gel, ange, ngel}]$
- $\tt{ac}$：$[\tt{ac}]$
- $\tt{angle}$：$[\tt{ang, ngl, gle, angl, ngle}]$

查询词分词结果如下：

- $\tt{lang}$：$[\tt{lan, ang, lang}]$

$\tt{angel}$ 和 $\tt{angle}$ 的分词中都包含 $\tt{ang}$，所以答案为 $2$。

**【评测用例规模与约定】**

设 $|s|$ 表示字符串 $s$ 的长度。

对于 50% 的评测用例，$1 \leq n \leq 100$；

对于所有评测用例，$1 \leq n \leq 10^3$，$1 \leq \min \leq \max \leq 20$，$1 \leq |d_i|, |q| \leq 20$，$d_i$ 和 $q$ 都只包含小写英文字母。

## 样例 #1

### 输入

```
3 3 4
angel
ac
angle
lang```

### 输出

```
2```

# 题解

## 作者：Ghosty_Neutrino (赞：2)

## 题意
在信息检索系统中，需要根据 N-Gram 分词算法实现文档与查询词的匹配：
* 给定参数 $[\min, \max]$，对文档和查询词生成所有长度为 $\min$ 到 $\max$ 的滑动窗口子串。
* 若查询词的任意 N-Gram 出现在某文档的 N-Gram 集合中，则该文档匹配成功。
* 统计匹配成功的文档数量。
## 分析
N-Gram 是指将字符串按连续字符窗口截取的子串，窗口长度为 $N$。本题中 $N$ 的范围是 $[\min, \max]$，即需要生成所有长度从 $min$ 到 $max$ 的连续子串。

生成规则分两种情况。

情况一（字符串长度小于 $\min$）：
* 若字符串长度 $len< \min$，则无法生成长度为 $min$ 的子串，此时 N-Gram 仅包含字符串本身。

情况二（字符串长度大于等于 $\min$）：
* 对每个长度 $1$，从左到右滑动窗口截取子串，步长为 $1$。

对每个文档生成所有合法 N-Gram，存入 $\texttt{unordered\_set}$ 集合（去重且支持快速查询）。

对查询词生成所有合法 N-Gram，形成序列 $P$。

遍历每个文档的 N-Gram 集合，判断 $P$ 中是否存在至少一个 N-Gram 在集合中。若存在，则文档匹配成功。
## 代码
以下是 c++ 版的。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,minl,maxl;
vector<string> gngrams(const string& s,int minl,int maxl){
    vector<string> ngrams;
    int len=s.size();
    if(len<minl){
        ngrams.push_back(s);
        return ngrams;
    }
    for(int l=minl;l<=maxl&&l<=len;l++){
        for(int i=0;i<=len-l;i++) ngrams.push_back(s.substr(i,l));
    }
    return ngrams;
}
int main(){
    cin>>n>>minl>>maxl;
    vector<unordered_set<string>> dngrams(n);
    for(int i=0;i<n;i++){
        string d;
        cin>>d;
        vector<string>ngrams=gngrams(d,minl,maxl);
        for(const string& ng:ngrams) dngrams[i].insert(ng);
    }
    string q;
    cin>>q;
    vector<string> qngrams=gngrams(q,minl,maxl);
    int cnt=0;
    for(int i=0;i<n;i++){
        for(const string& qng:qngrams){
            if(dngrams[i].count(qng)){
                cnt++;
                break; 
            }
        }
    }
    cout<<cnt;
    return 0;
}
```

## 代码 Python 版（AI 辅助生成）
作者其实把 Python 忘了。

```python
def generate_ngrams(s, min_length, max_length):
    """生成字符串的 n-gram 列表"""
    ngrams = []
    length = len(s)
    
    # 当字符串长度小于最小 n-gram 长度时，直接返回原字符串
    if length < min_length:
        ngrams.append(s)
        return ngrams
    
    # 生成指定长度范围内的所有 n-gram
    for l in range(min_length, max_length + 1):
        if l > length:
            continue
        for i in range(length - l + 1):
            ngrams.append(s[i:i+l])
    
    return ngrams

def main():
    # 读取输入
    n, min_length, max_length = map(int, input().split())
    
    # 存储每个文档的 n-gram 集合
    document_ngrams = [set() for _ in range(n)]
    
    # 处理每个文档并生成 n-gram
    for i in range(n):
        document = input()
        ngrams = generate_ngrams(document, min_length, max_length)
        document_ngrams[i].update(ngrams)
    
    # 处理查询字符串
    query = input()
    query_ngrams = generate_ngrams(query, min_length, max_length)
    
    # 计算匹配的文档数量
    count = 0
    for i in range(n):
        # 只要查询的 n-gram 中有一个存在于文档的 n-gram 集合中，即计数
        for ng in query_ngrams:
            if ng in document_ngrams[i]:
                count += 1
                break  # 找到一个匹配就可以停止检查该文档
    
    # 输出结果
    print(count)

if __name__ == "__main__":
    main()
```

---

## 作者：SuyctidohanQ (赞：2)

### 思路分析

挺好的一道题，就是代码有点难写。还是我太菜了？

思路比较简单。

对每个文档进行**分词处理**，这里可以使用 `vector` 实现，对于每个输入进来的字符串，用一个函数将字符串按照指定的规则**生成分词列表**。

函数代码如下：

```cpp
vector<str> ng(str s, LL mn, LL mx) {
	vector<str> t;
	LL l = s.length();
	if(l < mn) {
		t.push_back(s);
		return t;
	}
	for(int n = mn; n <= mx && n <= l; n++) 
		rep(i, 0, l - n) t.push_back(s.substr(i, n));
	return t;
}
```

**只要关键词的某个分词在某个文档的分词的 `vector` 中出现**，就算该文档匹配，答案 $+1$。

### 代码实现

这里提供 C++ 和 Python 的代码实现。

```cpp
#include<bits/stdc++.h>
#define please return 
#define AC 0
#define str string
#define rep(i, a, b) for(long long i = a; i <= b; i++)
#define repr(i, a, b) for(long long i = b; i >= a; i--)

using namespace std;

typedef long long LL;

vector<str> ng(str s, LL mn, LL mx) {
	vector<str> t;
	LL l = s.length();
	if(l < mn) {
		t.push_back(s);
		return t;
	}
	for(int n = mn; n <= mx && n <= l; n++) 
		rep(i, 0, l - n) t.push_back(s.substr(i, n));
	return t;
}

signed main() {
	int n, mn, mx; cin >> n >> mn >> mx;
	vector<set<str> > ds(n);
	rep(i, 0, n - 1) {
		str d; cin >> d;
		vector<str> ts = ng(d, mn, mx);
		for(string t : ts) ds[i].insert(t);
	}
	str q; cin >> q;
	vector<str> qs = ng(q, mn, mx);
	int cnt = 0;
	rep(i, 0, n - 1) {
		for(str t : qs) {
			if(ds[i].count(t)) {
				cnt++;
				break;
			}
		}
	}
	cout << cnt << '\n';
	please AC; 
}
```

```python
def ng(s, mn, mx):
	t = []
	l = len(s)
	if l < mn:
		t.append(s)
		return t
	for n in range(mn, min(mx, l) + 1):
		for i in range(l - n + 1):
			t.append(s[i:i+n])
	return t

n, mn, mx = map(int, input().split())
ds = [set() for _ in range(n)]
for i in range(n):
	d = input().strip()
	ts = ng(d, mn, mx)
	for t in ts:
		ds[i].add(t)

q = input().strip()
qs = ng(q, mn, mx)
cnt = 0
for i in range(n):
	for t in qs:
		if t in ds[i]:
			cnt += 1
			break

print(cnt)    
```

---

## 作者：__KevinMZ__ (赞：1)

# [题解：P12871 \[蓝桥杯 2025 国 Python A\] 倒排索引](https://www.luogu.com.cn/problem/P12871)

今天教练布置这题作为 Hash 练习，全机房 15 人就我 AC。/yiw

## 思路

两步走：

1. 预处理：对每个索引序列 Hash 值排序、存好 $q$ 的索引序列 Hash 值。
2. 二分：枚举 $1\sim n$，再枚举 $q$ 的索引序列 Hash 值，二分求出是否有匹配。

## 给出我的好用的 Hash

```cpp
template<int B>
class str_hash{
	using ull=unsigned long long;
	const ull mod=((ull)1<<61)-1;
	const ull base=B;
	ull power[5000005]={1};
	ull add(ull a,ull b){
		return (a+b)%mod;
	}
	ull mul(ull a,ull b){
		return (__uint128_t)a*b%mod;
	}
	void doit(){
		for(int i=1;i<5000005;i++){
			power[i]=mul(power[i-1],base);
		}
	}
public:
	str_hash(){doit();}
	ull Hsh(string s,ull l,ull r){//[l,r)开区间
		ull ans=0;
		for(int i=l;i<r;i++){
			ans=add(ans,mul(s[i],power[r-i-1]));
		}
		return ans;
	}
	ull Hsh(string s){
		return Hsh(s,0,s.size());
	}
};
```

## 给出完整代码

```cpp
#include<bits/stdc++.h>
#define ONLINE_JUDGE
#define int unsigned long long
using namespace std;
vector<int>vec[1005];
vector<int>query;
template<int B>
class str_hash{
	using ull=unsigned long long;
	const ull mod=((ull)1<<61)-1;
	const ull base=B;
	ull power[5000005]={1};
	ull add(ull a,ull b){
		return (a+b)%mod;
	}
	ull mul(ull a,ull b){
		return (__uint128_t)a*b%mod;
	}
	void doit(){
		for(int i=1;i<5000005;i++){
			power[i]=mul(power[i-1],base);
		}
	}
public:
	str_hash(){doit();}
	ull Hsh(string s,ull l,ull r){//[l,r)开区间
		ull ans=0;
		for(int i=l;i<r;i++){
			ans=add(ans,mul(s[i],power[r-i-1]));
		}
		return ans;
	}
	ull Hsh(string s){
		return Hsh(s,0,s.size());
	}
};
str_hash<13331>hsh;
signed main(){
#ifndef ONLINE_JUDGE
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    int n,Min,Max;
    cin>>n>>Min>>Max;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        if(s.size()<Min)vec[i].push_back(hsh.Hsh(s));//Hash
        for(int len=Min;len<=Max;len++){
            for(int pos=0;pos+len<=s.size();pos++){
                vec[i].push_back(hsh.Hsh(s,pos,pos+len));//Hash
            }
        }
        sort(vec[i].begin(),vec[i].end());
    }
    string q;
    cin>>q;
    if(q.size()<Min)query.push_back(hsh.Hsh(q));//Hash
    for(int len=Min;len<=Max;len++){
        for(int pos=0;pos+len<=q.size();pos++){
            query.push_back(hsh.Hsh(q,pos,pos+len));//Hash
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        bool flag=false;
        for(auto j:query){
            auto k=lower_bound(vec[i].begin(),vec[i].end(),j);//二分
            if(k!=vec[i].end()&&*k==j){
                flag=true;
                break;
            }
        }
        ans+=flag;
    }
    cout<<ans;
    return 0;
}
```

最终时间复杂度：$O(((\max-\min)\sum_{i=1}^n|d_i|)\log((\max-\min)\sum_{i=1}^n|d_i|)+((\max-\min)|q|)\log((\max-\min)|q|))$ 预处理，\
$O(((\max-\min)|q|\log((\max-\min)\sum_{i=1}^n|d_i|))$ 二分。

---

## 作者：Vct14 (赞：1)

纯暴力做法。通过枚举长度和第一个字母的位置来求出每个文档的所有索引词以及查询词的所有索引词，然后一一逐个字母进行比对，判断是否相同。

注意如果文档长度小于 $\min$，该文档仅有一个索引词，即它本身。

```cpp
#include<bits/stdc++.h>
using namespace std;

string a[1002],s;

int main(){
	int n,MIN,MAX;cin>>n>>MIN>>MAX;
	for(int i=1; i<=n; i++) cin>>a[i];
	cin>>s;int sl=s.size(),ans=0;
	for(int c=1; c<=n; c++){
		int len=a[c].size();
        if((len<MIN && sl>=MIN) || (len>=MIN && sl<MIN)) continue;
		if(len<MIN){
            if(len!=sl) continue;
			bool ok=0;
			for(int i=0; i+len-1<sl; i++){
				bool ok1=1;
				for(int j=1; j<=len; j++) if(a[c][i+j-1]!=s[j-1]){ok1=0;break;}
				if(ok1){
					ok=1;
					break;
				} 
			}
			if(ok) ans++;
			continue;
		}
		bool ok=0;
		for(int l=MIN; l<=min(len,MAX); l++){
			for(int i=0; i+l-1<sl; i++){
				for(int j=0; j+l-1<len; j++){
					bool ok1=1;
					for(int k=1; k<=l; k++) if(a[c][j+k-1]!=s[i+k-1]){ok1=0;break;}
					if(ok1){
						ok=1;
						break;
					} 
				}
				if(ok) break;
			}
			if(ok) break;
		}//大概是 O(n\min(\max |d_i|,MAX)^3|q|)
		if(ok) ans++;
	}
	cout<<ans;
	return 0;
}
```

因为 $\min,\max$ 和所有单词长度都不超过 $20$，而且 $n\le10^3$，所以运算量一定不超过 $1000\times 20^4=1.6\times10^8$（而且显然不会达到这个数），在 3s 的时限下能过。

---



应要求补上 python 代码。

```python
a = ["" for _ in range(1002)]
s = ""

n, MIN, MAX = map(int, input().split())
for i in range(1, n + 1):
    a[i] = input().strip()
s = input().strip()
sl = len(s)
ans = 0

for c in range(1, n + 1):
    length = len(a[c])
    if (length < MIN and sl >= MIN) or (length >= MIN and sl < MIN):
        continue
    if length < MIN:
        if length != sl:
            continue
        ok = False
        for i in range(sl - length + 1):
            ok1 = True
            for j in range(length):
                if a[c][j] != s[i + j]:
                    ok1 = False
                    break
            if ok1:
                ok = True
                break
        if ok:
            ans += 1
        continue
    ok = False
    for l in range(MIN, min(length, MAX) + 1):
        for i in range(sl - l + 1):
            for j in range(length - l + 1):
                ok1 = True
                for k in range(l):
                    if a[c][j + k] != s[i + k]:
                        ok1 = False
                        break
                if ok1:
                    ok = True
                    break
            if ok:
                break
        if ok:
            break
    if ok:
        ans += 1

print(ans)
```

---

## 作者：Belia (赞：1)

这题挺有意思，就是有点费手。

### 题意：

你有一堆文档和一个查询词，现在要用 N-Gram 分词的方式（滑动窗口截取子串）来匹配文档和查询词。

于是我们就不难想到……

### 思路：

我们可以使用 vector（动态数组）和 unordered_set（哈希表）来对文档和单词进行粉刺和储存，时间复杂度为 $\mathcal{O}(L^2\times n)$，由于 $L$ 最大为 $20$，所以可以轻松通过此题。下面请看实现……

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//#define ll long long你值得拥有
using namespace std;
ll n,mn,mx,qlen,ans;
string q;
unordered_set <string> qset;// 使用哈希集合存储分词结果
int main()
{
    cin>>n>>mn>>mx;
    vector <string> docs(n);
    for(auto& doc:docs)
	cin>>doc;
    cin>>q,qlen=q.size();
    if(qlen<mn)// 如果查询词长度小于 mn，整个词作为唯一索引
	qset.insert(q);
    else
    {
        for(ll len=mn;len<=min(mx,qlen);len++)
        for(ll i=0;i<=qlen-len;i++)
        qset.insert(q.substr(i,len));// 截取子串加入集合
    }
    for(auto& doc:docs)
    {
        ll dlen=doc.size(),mat=0;
        if(dlen<mn)
		{
			if(qset.count(doc))
			mat=1;
		}
        else
        {
            for(ll len=mn;len<=min(mx,dlen);len++)
            {
                for(ll i=0;i<=dlen-len;i++)
                {
                    string sub=doc.substr(i,len);
                    if(qset.count(sub))
                    {
                        mat=1;
                        break;
                    }
                }
                if(mat)
				break;
            }
        }
        if(mat)
		ans++;
    }
    cout<<ans<<"\n";
    return 0;
}
```
$\mathcal{Just}$ $\mathcal{so}$ $\mathcal{so}$！

---

## 作者：_WCW_ (赞：1)

## 题目分析
给定 $n$ 个字符串，将其按照题目中的截取方法截取出子串序列，之后和字符串 $q$ 的子串序列进行比较，如果有一个子串相同，则答案加一。
## 解题思路
这道题很明显是字符串模拟题，按照题目要求，枚举每个从 $\text {min}$ 到 $\text {max}$ 的长度。之后枚举每一个子串的截取开头，用 ```substr``` 进行截取并存入数组中，之后再和字符串 $q$ 的子串序列进行对比即可。
### 子串序列匹配
我们可以用一个 ```set``` 容器存储第 $i$ 个字符串和字符串 $q$ 的生成的所有子串序列，由于 ```set``` 自动去重的性质，如果长度比两个字符串的子串序列的长度总和小，说明有重复的子串，答案加一。
## 代码
### C++ [AC](https://www.luogu.com.cn/record/221137294) 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Min,Max;//这三个变量均为题中意思
long long ans;//存储最终结果
string d[1010],q;//存储字符串
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);//读入优化
    cin>>n>>Min>>Max;//输入
    for(int i=1;i<=n;i++) cin>>d[i];
    cin>>q;
    set<string> P;//用set存储q的子串序列，防止重复子串
    for(int len=Min;len<=Max;len++)//枚举所有长度
    {
        if(q.size()<Min)//如果长度比min小
        {
            P.insert(q);//存入整个字符串
            break;//退出
        }
        for(int j=1,left=0;j<=(int)q.size()-len+1;j++,left++) if(q.size()>=len) P.insert(q.substr(left,len));
        //j为截取长度为len下的循环次数，left为截取开始点，如果字符串长度大于等于len就截取，转int防止出现负数
    }
    for(int i=1;i<=n;i++)//枚举每个输入的字符串
    {
        set<string> a;//存储总子串序列
        set<string> L;//当前字符串的子串序列
        if(d[i].size()<Min)//如果长度不够
        {
            L.insert(d[i]);//插入整个字符串
            goto FLAG;//跳过截取子串的循环
        }
        for(int len=Min;len<=Max;len++)//枚举所有长度
        {
            for(int j=1,left=0;j<=(int)d[i].size()-len+1;j++,left++) if(d[i].size()>=len) L.insert(d[i].substr(left,len));
        }
        FLAG://FLAG标记，跳转到此处
        for(auto s:L) a.insert(s);//使用范围for循环将两个序列的字符串存入到a中
        for(auto s:P) a.insert(s);
        if(a.size()<L.size()+P.size()) ans++;//如果有相同字符串，存入a中会被去重，长度就会变小，所以答案加一
    }
    cout<<ans;//输出

    return 0;
}
```
### Python [AC](https://www.luogu.com.cn/record/221137124) 代码

```python
import sys
n,Min,Max=map(int,sys.stdin.readline().split())
d=[sys.stdin.readline().strip() for _ in range(n)]
q=sys.stdin.readline().strip()
P=set()
if len(q)<Min:
    P.add(q)
else:
    for length in range(Min,Max+1):
        if len(q)<Min: 
            P.add(q)
            break
        j=1
        left=0
        while j<=len(q)-length+1:
            if len(q)>=length:
                P.add(q[left:left+length])
            j+=1
            left+=1
ans=0
for i in range(n):
    a=set()
    L=set()
    if len(d[i])<Min:
        L.add(d[i])
    else:
        for length in range(Min,Max+1):
            j=1
            left=0
            while j<=len(d[i])-length+1:
                if len(d[i])>=length:
                    L.add(d[i][left:left+length])
                j+=1
                left+=1
    for s in L:
        a.add(s)
    for s in P:
        a.add(s)
    if len(a)<len(L)+len(P):
        ans+=1
print(ans)
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
这道题就是让你统计有多少个文档能和查询词匹配上。匹配的规则是：把每个文档和查询词都按给定的长度范围切成多个小片段，只要查询词的任意一个片段出现在某个文档的片段集合里，就算这个文档匹配成功。最后数一数有多少个文档匹配就行了。实现步骤如下：
1. 把每个文档切成规定长度的所有可能子串存起来。
2. 把查询词也切成同样规则的子串。
3. 检查查询词的每个子串是否出现在各个文档的子串集合里。
4. 只要有一个子串匹配上，这个文档就算数。
5. 最后统计总共有多少个文档被匹配到。
### C++ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,M,c;
string d[1005],q;
unordered_set<string>s[1005],t;
int main(){
    cin>>n>>m>>M;
    for(int i=1;i<=n;i++)cin>>d[i];
    cin>>q;
    for(int i=1;i<=n;i++){
        int l=d[i].size();
        if(l<m){s[i].insert(d[i]);continue;}
        for(int j=m;j<=M;j++)
            for(int k=0;k+j<=l;k++)
                s[i].insert(d[i].substr(k,j));
    }
    int l=q.size();
    if(l<m)t.insert(q);
    else for(int i=m;i<=M;i++)
        for(int j=0;j+i<=l;j++)
            t.insert(q.substr(j,i));
    for(int i=1;i<=n;i++)
        for(auto x:t)
            if(s[i].count(x)){c++;break;}
    cout<<c;
    return 0;
}
```
### Python 代码：

```python
import sys
from typing import List, Set

n, m, M = 0, 0, 0
c = 0
d = [""] * 1005
q = ""
s = [set() for _ in range(1005)]  # type: List[Set[str]]
t = set()  # type: Set[str]

def main():
    global n, m, M, c, d, q, s, t
    n, m, M = map(int, sys.stdin.readline().split())
    for i in range(1, n+1):
        d[i] = sys.stdin.readline().strip()
    q = sys.stdin.readline().strip()
    
    for i in range(1, n+1):
        l = len(d[i])
        if l < m:
            s[i].add(d[i])
            continue
        for j in range(m, M+1):
            for k in range(0, l - j + 1):
                s[i].add(d[i][k:k+j])
    
    l = len(q)
    if l < m:
        t.add(q)
    else:
        for i in range(m, M+1):
            for j in range(0, l - i + 1):
                t.add(q[j:j+i])
    
    for i in range(1, n+1):
        for x in t:
            if x in s[i]:
                c += 1
                break
    
    print(c)

if __name__ == "__main__":
    main()
```
**将 C++ 代码转化为 Python 代码的工作由 deepseek 完成。**

---

## 作者：the_Short_Path (赞：0)

## 形式化题意
给定若干个字符串，按照 N-Gram 分词算法维护出其分词集合，然后在给定一个字符串，求这若干个字符串中分词集合和这个字符串的分词集合有交集的数量。
## 思路
首先，想要实现 N-Gram 分词算法，那么就需要以下代码：

```cpp
if (d[x].size() < mn) { // 注意特殊情况
    L[x].insert(d[x]);
    return ;
}
for (int i = mn; i <= mx; i++) {
    for (int l = 0; l + i - 1 < d[x].size(); l++) L[x].insert(d[x].substr(l, i));
}
```
这里的 $L_i$ 是分词的集合，$d_i$ 是字符串（即“文档”）。

给每个字符串都维护一遍，再查找交集即可。
# 正解
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, mn, mx, cnt; // 注意 min 和 max 是关键字，不能做变量名
string d[1005], q;
set <string> L[1005];
void solve(int x) {
    if (d[x].size() < mn) { // 特判
        L[x].insert(d[x]);
        return ;
    }
    for (int i = mn; i <= mx; i++) {
        for (int l = 0; l + i - 1 < d[x].size(); l++) L[x].insert(d[x].substr(l, i));
    }
}
int main() {
    cin >> n >> mn >> mx;
    for (int i = 1; i <= n; i++) {
        cin >> d[i];
        solve(i);
    }
    cin >> q;
    if (q.size() < mn) { // 特判
        L[n + 1].insert(q);
    } else {
        for (int i = mn; i <= mx; i++) {
            for (int l = 0; l + i - 1 < q.size(); l++) L[n + 1].insert(q.substr(l, i)); // 这类可以把 q 视为第 n+1 个字符串
        }    
    }
    for (int x = 1; x <= n; x++) {
        for (auto t : L[n + 1]) { // 判断是否有交集
            if (L[x].count(t)) {
                cnt++;
                break; // 记得退出循环
            }
        }
    }
    cout << cnt << endl;
    return 0;
}
```

---


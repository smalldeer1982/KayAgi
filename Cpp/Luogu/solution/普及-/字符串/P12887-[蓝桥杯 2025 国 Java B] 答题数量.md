# [蓝桥杯 2025 国 Java B] 答题数量

## 题目描述

小蓝从一间空荡的房间中醒来，眼前放着一张木桌，桌上摆放着两份密封的答案纸，一份属于他，另一份属于他的朋友。每张纸上都写着一个长度为 $N$ 的字符串，仅包含字符 $\tt T$ 和 $\tt F$ ——这是他们昨晚参加一场判断题考试后的答题记录。

考试共有 $N$ 道题目，每题的答案只有两种可能：
- $\tt T$ 表示 $\text{True}$（正确）
- $\tt F$ 表示 $\text{False}$（错误）

两人在相互隔离、无法交流的情况下各自完成了作答，并提交了自己的答案。

今早，小蓝收到了一条神秘信息：
> “你的朋友恰好答对了 $M$ 道题。”

标准答案尚未公布，小蓝无法直接判断自己答对了多少题。然而，基于已知信息，小蓝希望评估出，在所有可能的标准答案中，他自己最多能答对多少题。现在，请你计算小蓝至多能答对的题目数量。

## 说明/提示

**【评测用例规模与约定】**

对于 $100\%$ 的评测用例，$2 \leq M \leq N \leq 10^5$。


## 样例 #1

### 输入

```
4 2
TTFF
FTTF```

### 输出

```
4```

# 题解

## 作者：MingDynasty (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P12887)

思维题。

## 题目思路;

我们知道，小蓝和朋友答案相同时肯定是正确的，所以剩下不相同的数值就是 $N$ 减去相同的数值。而在正确的数量中，还有一部分未被判定正确与否，所以这里可以用到容斥原理的思想。未判定的量中，只有不同的字符数减去 $M$ 的差才是小蓝还可以判对的数量。所以我们按照这个思路模拟即可。

## Code：

C++：

```cpp
#include<iostream>
#include<cmath>
#define ll long long
using namespace std;
int maxn=-1e9,sum,a;
int main(){
	ll n,m;
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m;
	string w,q;
	cin>>w>>q;
	for(int i=0;i<w.size();i++){
		if(q[i]==w[i]) a++;
	}
	int b=n-a,same=min(a*1ll,m),ans=2*same+b-m;
	cout<<ans;
	return 0;
}
```

Java：

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long m = scanner.nextLong();
        scanner.nextLine(); // consume the remaining newline
        
        String w = scanner.nextLine();
        String q = scanner.nextLine();
        
        int a = 0;
        for (int i = 0; i < w.length(); i++) {
            if (q.charAt(i) == w.charAt(i)) {
                a++;
            }
        }
        
        long b = n - a;
        long same = Math.min(a, m);
        long ans = 2 * same + b - m;
        
        System.out.println(ans);
    }
}
```

祝各位通过本题！

---

## 作者：_seven_7k_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12887)
## 思路
这道题可以算是贪心题。我们考虑一下状况：小蓝和朋友答案不一样以及小蓝和朋友答案不样。当小蓝和朋友答案不一样时，如果朋友对了，那么小蓝错了，反之小蓝对了；当小蓝和朋友答案一样时，如果朋友对了，那么小蓝也对了，反之小蓝错了。所以，我们要尽可能让小蓝和朋友答案一样的题目对。定义一个数 $k$ 为小蓝答对题目数，定义一个 $s$ 为两人答案相同的题目数，那么 $k$ 为 $n-|m-s|$。
## 代码
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        String a = scanner.next();
        String b = scanner.next();
        int s = 0;

        for (int i = 0; i < n; i++) {
            if (a.charAt(i) == b.charAt(i)) {
                s++;
            }
        }
        
        System.out.println(n - Math.abs(m - s));
        scanner.close();
    }
}


```

---

## 作者：zhoujunchen (赞：1)

我们先假设相同答案都是对的，用一个变量 $cnt$，记录 $s_i=t_i$ 的数量，因为这样既可以增加小蓝的正确数量，也可以增加朋友的数量。

如果 $cnt \ge m$，只需要选择 $m$ 个相同位置，其余位置让小蓝答对即可，答案为不同位置与 $m$ 的和。

如果 $cnt < m$，说明必须借给朋友一些答对的机会，不然就无法满足题意，借一次机会就少一道答对题目，答案为总题数减去借给朋友的机会。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
string a,b;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>a>>b;
	for(int i=0;i<n;i++)if(a[i]==b[i])cnt++;
	if(cnt>=m)cout<<n-cnt+m;
	else cout<<n+cnt-m;
	return 0;
}
```


```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        String a = scanner.next();
        String b = scanner.next();
        int cnt = 0;
        for (int i = 0; i < n; i++) 
            if (a.charAt(i) == b.charAt(i)) 
                cnt++;
        if (cnt >= m) 
            System.out.println(n - cnt + m);
        else 
            System.out.println(n + cnt - m);
    }
}
```

---

## 作者：M1__ (赞：0)

# 题解：P12887 [蓝桥杯 2025 国 Java B] 答题数量

[Link](https://www.luogu.com.cn/problem/P12887)

本题重点即为如何求出小蓝和他的好朋友都答对的题的取值范围。

设只有小蓝答对的题为 $T_b$，只有朋友答对的题数量为 $T_f$，他们都答对的题数目为 $S_{T}$，他们答案相同的题目数为 $S$。题目总数为 $N$。

我们要求出 ${S_{T}}_{max}$。因为朋友答对的所有题数量为 $M$，当 $S>M$ 时，显然 ${S_{T}}_{max}=M$。反之，${S_{T}}_{max}=S$。因此 $S_{T}$ 的区间为 $[0,\min(S,M)]$，即 ${S_{T}}_{max}=\min(S,M)$。

接下来我们来看不同位置，因为此时两人答案不同，所以只有一人对一人错。此时因为两人答案相同的题目数为 $S$，所以他们答案不相同的题目数为 $N-S$，只有小蓝答对的题数为 $T_b=N-S-T_f$。

综上，答案为： 
$$
\begin{align*}
T_b+{S_{T}}_{max} &= {S_{T}}_{max} + N-S- T_f\\
  &= {S_{T}}_{max} + N-S- (M-{S_{T}}_{max})\\
  &= 2 \cdot {S_{T}}_{max} + N-S- M\\
  &= 2 \cdot \min(S,M)+N-S- M
\end{align*}
$$

```cpp
//C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,cnt;
string s,t;
int main(){
    cin>>n>>m;
    cin>>s>>t;
    for(int i=0;i<n;i++){
        if(s[i]==t[i]) cnt++;
    }
    ll ans=2*min(cnt,m)+n-cnt-m;
    cout<<ans;
    return 0;
}
```

```java
//java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner=new Scanner(System.in);
        long n=scanner.nextLong();
        long m=scanner.nextLong();
        scanner.nextLine(); 
        String s=scanner.nextLine();
        String t=scanner.nextLine();
        long cnt=0;
        for (int i=0;i<n;i++){
            if(s.charAt(i)==t.charAt(i)) cnt++;
        }
        long ans=2*Math.min(cnt,m)+n-cnt-m;
        System.out.println(ans);
    }
}
```

---


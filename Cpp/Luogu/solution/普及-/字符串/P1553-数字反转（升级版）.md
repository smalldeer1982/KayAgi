# 数字反转（升级版）

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。


## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 说明/提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

## 样例 #1

### 输入

```
5087462```

### 输出

```
2647805```

## 样例 #2

### 输入

```
600.084```

### 输出

```
6.48```

## 样例 #3

### 输入

```
700/27```

### 输出

```
7/72```

## 样例 #4

### 输入

```
8670%```

### 输出

```
768%```

# 题解

## 作者：SebMa (赞：737)

错了好几次才AC；QAQ

**细节太多，要周密考虑！**

我的大概思路如下；

分成两块，先输出前一个数，判断有无符号，无return0，有再输出第二个数；

代码较简单，30行，供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    char p=0;//放符号 
    int cnt=0; 
    cin>>s;
    for(int i=0;i<s.size();i++)
    {
        if(s[i]>='0'&&s[i]<='9') cnt++;//记录第一个数长度
        else    //遇到符号，记录，跳出 
        {
            p=s[i];
            break;
        } 
    }
    int x=cnt;//记下第一个数末后一个的位置，也就是符号的位置，如果是分数或小数就要用 
    cnt--;
    while(s[cnt]=='0'&&cnt>0) cnt--;//去除多余前导0； 
    for(int i=cnt;i>=0;i--)//输出第一个数 
       cout<<s[i];
    if(p==0) return 0;//无符号return 0 
    else
      if(p=='%') {cout<<p;return 0;} 
      else cout<<p;//其他继续 
    int m=s.size()-1;
    while(s[x+1]=='0'&&x<m-1) x++;//去除末尾0 
    while(s[m]=='0'&&m>x+1) m--; //去除多余前导0
    for(int i=m;i>x;i--)//输出第二个数 
        cout<<s[i];
    return 0; 
}
###第一次写题解，求过。
```

---

## 作者：Anguei (赞：293)

如果你对 STL 了解得比较透彻，那么这篇题解一定是最简单的（虽然有点长，但思路很清晰）。如果你不是很懂 STL，借此机会了解、学习一下也无妨。
主要思路是，读如字符串后，判断字符串中是属于哪一种类型的数字。一共有四种情况：**正整数、正实数、正分数、正百分数。**
+ 如果是正整数，先反转，再去掉前导零，输出。
+ 如果是百分数，先按正整数方案做，最后输出一个百分号。
+ 如果是分数或者实数，以分数线 / 小数点为分界，将字符串分为左右两部分，分别进行反转。

----------
综上，我们有以下几个问题需要解决：
1. 如何反转？用 STL 中的 `std::reverse()`。
2. 如何去掉前导零？先遍历一遍字符串，看看有多少前导零，然后 `std::string::erase()` 即可。
3. 如何提取出子字符串？`std::string::substr()`。

对于以上三个函数不是很懂？没关系，文末会有具体解释。
还有两点需要注意，分别是：
1. 但要注意，如果数字本身就是零，按照上面的做法会得到空串。所以需要特判。
2. 还要注意，小数点之后的部分还需要去掉“后导零”。

----------

代码如下：
```cpp
//【P1553】数字反转（升级版） - 洛谷 - 100
#include <string>
#include <iostream>
#include <algorithm>

// 自己写的反转函数，返回反转并去掉前导零之后的字符串
std::string reverse(std::string s) {
	int zeroCount = 0;
	std::reverse(s.begin(), s.end()); // 反转
    // 范围 for 循环，用于统计前导零个数
	for (auto i : s)
		if (i == 48) ++zeroCount;
		else break;
	s.erase(s.begin(), s.begin() + zeroCount);
	return (s != "" ? s : "0"); // 特判
}

// 用于去掉后导零
std::string deleteTail(std::string s) { 
	int zeroCount = 0;
	for (int i = s.size() - 1; i >= 0; --i)
		if (s[i] == 48) ++zeroCount;
		else break;
	s.erase(s.end() - zeroCount, s.end());
	return (s != "" ? s : "0");
}

int main() {
	std::string s;
	std::cin >> s;
	if (s.back() == '%') {
		std::cout << reverse(s.substr(0, s.size() - 1)) << "%" << std::endl;
		return 0;
	}
	for (auto i : s) {
		std::string left, right;
        // 其实还有一种不需要遍历字符串的做法，直接 find() 即可，但是当时没想到
		if (i == '/') {
			left = s.substr(0, s.find("/"));
			right = s.substr(s.find("/") + 1);
			std::cout << reverse(left) << "/" << reverse(right) << std::endl;
			return 0;
		}
		if (i == '.') {
			left = s.substr(0, s.find("."));
			right = s.substr(s.find(".") + 1);
			std::cout << reverse(left) << "." << deleteTail(reverse(right)) << std::endl;
			return 0;
		}
	}
    // 最后剩下的一种情况是正整数
	std::cout << reverse(s) << std::endl;
	return 0;
}
```
----------
分别解释一下用到的 STL 算法。
1. `std::reverse()`，顾名思义，用于反转序列。需要提供首尾迭代器作为参数。
2. `std::string::erase()`，传入两个迭代器 l,r，清除[l,r)范围内的字符。
3. `std::string::substr()`，用于提取子字符串，用法与前者类似。
4. `std::string::find()`，用来查找字串在母串中第一次出现的位置。

如果还是不太懂，不要着急，初学 STL 总要花费些时间的。与快排等算法结合学习，会起到事半功倍的效果。另外，[cppreference.com](zh.cppreference.com) 这个网站非常有用。如果有不理解的，可以随时去查。

---

## 作者：lhh619899573 (赞：88)

很少见别人用java做题，我先发下

我觉得题目可以分两部分：

1.处理对应的哪种数据类型（小数、分数、百分数、整数）

2.封装一个函数：处理字符反倒。（处理前面多余的0、处理后面多余的0）

由于不能一次AC，才发现里面有坑，要注意 00/5 要输出 0/5。

最重要还是要看java怎么处理字符串鸭。


```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        String s[] = new String[2] ;
        if(str.indexOf('.')!=-1) { // 识别小数
        	s = str.split("\\.");
        	turn(s[0]);
        	System.out.print(".");
        	turn(s[1]);
        }else if(str.indexOf('/')!=-1) { // 识别分数
        	s = str.split("/");
        	turn(s[0]);
        	System.out.print("/");
        	turn(s[1]);
        }else if(str.indexOf('%')!=-1) { // 识别百分数
        	s = str.split("%");
        	turn(s[0]);
        	System.out.print("%");
        }else { // 识别整数
        	turn(str);
        }
    }
    // 字符反倒
    public static void turn(String str) {
    	boolean flag1 = false; // 标志前面多余的0
    	boolean flag2 = false; // 标志后面多余的0
    	String s = "";
    	// 去除前面多余的0
    	for(int i=0;i<=str.length()-1;i++) { 
    		if(!flag1 && str.charAt(i)=='0') {
    			continue;
    		}
    		flag1 = true;
    		s += str.charAt(i); // 表示已去除前面0的字符串
        }
    	// 去除后面多余的0
    	for(int i=s.length()-1;i>=0;i--) {
    		if(!flag2 && s.charAt(i)=='0') {
    			continue;
    		}
    		flag2 = true;
			System.out.printf("%s",s.charAt(i));
        }
    	if(str == "" || s == "") {
    		System.out.print("0");
    		return ;
    	}
    }
}
```

第一次发博客，有点紧张。

冲鸭！！！

---

## 作者：风不停Wind╮ۣۖ (赞：74)


别着急这应该是最通俗易懂的代码，慢慢看~~（逃~~
------------

~~把符号前面和后面分成两部分进行判断原理和数字反转一样~~
------------
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std; 
string c;
int z[123456],h[123456],fz[123465],fh[123456];
//z数组来存符号前的一串数，h数组来存符号后的一串数
//fz来判断z数组开头是不是0，fh来判断h数组开头是不是0
int mid,flagz,flagh;//mid存符号位
//flagz来表示z数组里是不是都是0
//flagh来表示h数组里是不是都是0
int main()
{
	cin>>c;
	int len=c.size();
	if(len==1)//长度为1的话不需要反转直接输出
	{
		cout<<c;
		return 0;
	} 
	for(int i=0;i<len;i++)
	{
		if(c[i]<'0'||c[i]>'9')//用mid来存第几位是符号位
		mid=i;
	}
	if(mid!=0)
    //如果mid为0说明他并没有被赋值，这个数都是有数字组成
	{
	for(int i=0;i<mid;i++)//z数组来存符号位之前的
	z[i]=c[i]-'0';
	for(int k=0;k<mid;k++)//判断z数组里存的是不是都是0
	if(z[k]!=0)//如果都是0那就只输出1个0
	flagz=1;
	if(flagz!=0)//如果不都是0
	{
		for(int j=mid-1;j>=0;j--)//去0操作，模拟过程
	    {
	        if(z[j]!=0)
	        break;
	        else fz[j]=1;//fz数组等于1表示开头的0都为1最后不输出
	    }
	    for(int j=mid-1;j>=0;j--)
	    {
	        if(fz[j]==0)//判断如果不是开头的0
	        printf("%d",z[j]);
	    }	
	}
	else printf("0");
	cout<<c[mid];//因为其他的都转化为数字了，符号单独输出
	if(mid==len-1)
    //判断符号后面还有没有数字，如果没有就不用判断，直接结束
	return 0;
    //以下代码与z数组同理
	for(int i=mid+1;i<len;i++)
	h[i]=c[i]-'0';
	for(int q=mid+1;q<len;q++)
	if(h[q]!=0)
	flagh=1;
	if(flagh!=0)
	{
		for(int s=len-1;s>=mid+1;s--)
    	{
	        if(h[s]!=0)
	        break;
	        else fh[s]=1;
    	}
    	for(int s=mid+1;s<len;s++)//这个用来删除小数后面的0，比如6.480-->6.48
    	{
    		if(h[s]!=0)
			break;
			else mid++;	
		}
		for(int s=len-1;s>=mid+1;s--)
    	{
        if(fh[s]==0)
        printf("%d",h[s]);
    	}
	}
	else printf("0");
	}
	else//这个对应上面没有符号的话，直接倒过来输出
	{
	for(int i=0;i<len;i++)
	z[len-i-1]=c[i]-'0';
	for(int j=0;j<len;j++)
    {
        if(z[j]!=0)
        break;
        else fz[j]=1;
    }
    for(int j=0;j<len;j++)
    {
        if(fz[j]==0)
        printf("%d",z[j]);
    }
	}
    return 0;//结束主程序
}
```
------------

---

## 作者：AlexZy (赞：72)

**Python题解**

share一下解题思路

- 输入数字，判断是什么类型的数字

- 如果是特殊类型，就将符号割掉，重新输入，再组合结果

- 如果是整数，就判断是不是小数位的部分，如果不是，就直接转换

- 转换后就排零

代码如下

```python
#输入变量
num_str = list(input())
#定义一个递归函数
def convert_num(num, decimal=True):
    #定义针对分数、百分数、小数的部分的处理
    #将整数跟特殊符号切分出来进行递归
    tem_num = tem_num0 = []
    sym_location = 0
    if num[-1] == '%' :
        return ''.join(convert_num(num[:-1])+'%')
    if '/' in num:
        sym_location = num.index('/')
        tem_num = convert_num(num[:sym_location])
        tem_num0 = convert_num(num[sym_location+1:])
        return ''.join(tem_num+'/'+tem_num0)
    if '.' in num:
        sym_location = num.index('.')
        tem_num = convert_num(num[:sym_location])
        tem_num0 = convert_num(num[sym_location+1:],decimal=False)
        return ''.join(tem_num+'.'+tem_num0)
    #定义针对整数的部分的处理
    boo = True
    num.reverse()
    #如果是正常转换，就从列表头开始排零
    if decimal:
        while boo :
            if num[0] =='0' :
                if len(num) == 1 :
                    boo = False
                else:
                    num.remove('0')
            else:
                boo = False
    #如果是小数部分转换，就从列表尾开始排零
    else:
        while boo :
            if num[-1] =='0' :
                if len(num) == 1 :
                    boo = False
                else:
                    num.pop()
            else:
                boo = False
    return ''.join(num)
print(convert_num(num_str))
```

求赞呀！！！

---

## 作者：HYMing (赞：57)

	#include<stdio.h>
	#include<string.h>
	int main()
	{
	int chang,d,i,e=0,j;
	char size[600];
	gets(size);
	chang=d=strlen(size);
	for(i=0;i<chang;i++)
		if(size[i]=='/'||size[i]=='.'||size[i]=='%')
			d=i;//这个相信大家都懂，这只是看他的方位 
	for(i=d-1;i>=0;i--){
		if(e==0&&size[i]=='0') continue;
		e+=1; 
		printf("%c",size[i]);
	}//这个就是简单的把符号前的反转 
		if(e==0&&i==-1) {printf("0");}
		e=0;
		printf("%c",size[d]);//	如果前面没有数字就输出0 
	if(d!=chang-1||d!=chang){
    //因为这个题目就'/'有点坑，分母前面不能有0 
		if(size[d]=='/'){
			for(i=chang-1;i>d;i--){
				if(e==0&&size[i]=='0') continue;
				break; 
			}
			for(j=i;j>d;j--)
			printf("%c",size[j]);
		return 0;
		}else{
		for(i=d+1;i<chang;i++){
			if(e==0&&size[i]=='0'){size[i]=' ';continue;}
			e+=1;
			}
		for(i=d+1;i<=chang;i++){
			if(size[i]=='0') continue;
			if(i==chang&&size[chang-1]==' ') size[chang-1]='0';
		}
        
	//剩下的就是整理然后输出，只不过我这里有点取巧，把'0'换成了' 
		for(i=chang-1;i>d;i--)
			printf("%c",size[i]);
		return 0;}
	}
	}
    //不管怎么说我感觉我还是有点取巧的成分在里面，不过只要能抓到老鼠不就行了吗？嘻嘻

---

## 作者：情到深处人孤独 (赞：41)

题解：

嗯，这题是有些麻烦。分成几个子程序就行，而且还能互相调用。

主程序：

    ```cpp

int main()
{
    cin>>s;
    b=find(s);
    if (b==0)
       integer(s);
    if (b==1)
       decimals(s);
    if (b==2)
       fraction(s);
    if (b==3)
       percentage(s);
    return 0;
}
    
```
子程序1：

    ```cpp

int find(string S)
{
    for (int i=0;i<=S.size()-1;i++)
        {
         if (S[i]=='.')
            {a=i;return 1;}    {是小数返回1}
         if (S[i]=='/')
            {a=i;return 2;}    {是分数返回2}
         if (S[i]=='%')
            {a=i;return 3;}    {是百分数返回3}
        }
    return 0;    {是整数返回0}
}
    
```
子程序2：

    ```cpp

void integer(string S)    {整数程序，正常人看得懂的}
{
     for (int i=S.size()-1;i>=1;i--)
         if (S[i]=='0')
            S=S.erase(i,1);
         else
            break;
     for (int i=S.size()-1;i>=0;i--)
         cout<<S[i];
}
    
```
子程序3：

    ```cpp

void decimals(string S)    {小数程序，是四种可能中最难的}
{
     n=S.substr(0,a);    {小数点前整数部分}
     m=S.substr(a+1,S.size()-(a+1));    {小数点后小数部分}
     //cout<<n<<endl<<m<<endl;
     integer(n);    {整数部分用整数处理}
     cout<<".";
     int i=0;
     while (m!="")
           {
            if (m[i]=='0')
               m=m.erase(0,1);
            else 
               break;
           }
     if (m=="")
        m="0";
     for (i=m.size()-1;i>=0;i--)
         cout<<m[i];
}
    
```
子程序4：

    ```cpp

void fraction(string S)    {分数程序}
{
     n=S.substr(0,a);    {同小数，分数线前分子}
     m=S.substr(a+1,S.size()-(a+1));    {分数线后分母}
     //cout<<n<<endl<<m<<endl;
     integer(n);    {分子调用整数程序}
     cout<<"/";
     integer(m);    {分母调用整数程序}
}
    
```
子程序5：

    ```cpp

void percentage(string S)    {百分数程序}
{
     S=S.erase(S.size()-1,1);    {调用整数程序前先去百分号}
     integer(S);    {数字调用整数程序}
     cout<<"%";
}
    
```
五个程序分着做，比较简单。


---

## 作者：_扶笙_ (赞：34)

P党的人真心少啊，我来发一篇

有了数字反转（1），做（2）非常容易

详细见代码：

```cpp
var s,s1,s2:ansistring;
i:longint;
begin
readln(s);
if (pos('/',s)=0)and(pos('.',s)=0)and(pos('%',s)=0)then//是数字，其他三个都找不到
begin
while (s[length(s)]='0')and(length(s)>1) do delete(s,length(s),1);
for i:=length(s) downto 1 do write(s[i]);
end;//和1一样的方法
if pos('.',s)>0 then
  begin
  s1:=copy(s,1,pos('.',s)-1);//小数点之前
  s2:=copy(s,pos('.',s)+1,length(s));//小数点之后
  while (s1[length(s1)]='0')and(length(s1)>1) do delete(s1,length(s1),1);//和1一样的方法
  for i:=length(s1) downto 1 do write(s1[i]);//倒序输出
  write('.');//输出小数点
  while (s2[1]='0')and(length(s2)>1) do delete(s2,1,1);//这里和1不太一样，要从第一位开始删除‘0‘，读懂题目就行了
  for i:=length(s2) downto 1 do write(s2[i]);//倒序输出
  end;
if pos('/',s)>0 then  //如果有‘/’号
  begin
  s1:=copy(s,1,pos('/',s)-1);//前一部分
  s2:=copy(s,pos('/',s)+1,length(s));//后一部分
  while (s1[length(s1)]='0')and(length(s1)>1) do delete(s1,length(s1),1);
  for i:=length(s1) downto 1 do write(s1[i]);//和1一样
  write('/');//输出/
  while (s2[length(s2)]='0')and(length(s2)>1) do delete(s2,length(s2),1);
  for i:=length(s2) downto 1 do write(s2[i]);//和1一样
  end;
if pos('%',s)>0 then  //如果有百分号
  begin
  delete(s,length(s),1);//百分号分为两部分，前一部分直接反转，百分号先不管，后来直接输出即可
  while (s[length(s)]='0')and(length(s)>1) do delete(s,length(s),1);
  for i:=length(s) downto 1 do write(s[i]);//和1一样
  write('%');//输出百分号
  end;
end.
```
此代码为新手
神犇路过~~~


---

## 作者：方子正 (赞：32)

```python
def _rev(s):
    if s=='0': return '0'
    return str(int(s[::-1]))

def rev(s):
    if '.' in s:
        a, b = s.split('.')
        return _rev(a) + '.' + _rev(_rev(_rev(b)))
    if '/' in s:
        a, b = s.split('/')
        return _rev(a) + '/' + _rev(b)
    if '%' in s:
        return _rev(s[:-1]) + '%'
    return _rev(s)

print(rev(input()))

```

---

## 作者：ingu (赞：25)

此题在新手村应该是绝对的大坑了。题面比较好懂，但细节实在很多。

解决问题不涉及函数和其他前面没用过的知识，代码比较简练只有40行。

算法思路1：一、反转  二、打印

0.存储。首先想到用数组来保存数据，这个应该没有问题吧。

1.反转。接着挨个字符进行判断找到非数字的位置，这样从开始位置到结尾位置就可以反转了。小数和分数看成是前后两个数，小数从小数点后第一个非0字开始反转。

2.打印。都是整数规则，除了最前面的0不打印其他都打印。如果有只有1个0，要打印0。

参考代码如下：

```cpp
#include <iostream>
using namespace std;
int main()
{
    char s[30]={},t;
    cin>>s;
    int i=0,j,flag=0;
    for (j=0; s[j]!='\0'; j++) {
        t=s[j+1];
        if (t=='.'||t=='/'||t=='%'||t=='\0') {
            while (flag &&s[i]=='0') i++;
            unsigned long long n=s[j]-'0';
            for(int a=i,b=j;a<b;a++,b--){
                char c=s[a];s[a]=s[b];s[b]=c;
            }
            i=++j+1;
            if (t=='.') {
                flag=1;
            }
        }
    }
    for(flag=1,j=0; s[j]!='\0'; j++){
        t=s[j+1];
        if(flag && s[j]=='0'){
            continue;
        }
        if(flag && (s[j]=='.'||s[j]=='/'||s[j]=='%')){
            cout<<'0';
        }
        flag=0;
        cout<<s[j];
        if (s[j]=='.'||s[j]=='/') {
            flag=1;
        }
    }
    if(flag){
        cout<<'0';
    }
    return 0;
}
```

算法思路2：把字符转换成数字，然后再打印。不过这里有个坑，因为转换成数字会涉及到溢出的问题，而本地刚好溢出。所以可以针对超长整数直接反转。参考代码如下：


```cpp
#include <iostream>
using namespace std;
int main()
{
    char s[30]={},t;
    cin>>s;
    int i=0,j,flag=0;
    for (j=0; s[j]!='\0'; j++) {
        if (j-i==19) {
            t=1;
            for (int k=j; k>=i; k--) {
                if (t && s[k]=='0') {
                    continue;
                }else {
                    t=0;cout<<s[k];
                }
            }
            break;
        }
        t=s[j+1];
        if (t=='.'||t=='/'||t=='%'||t=='\0') {
            while (flag &&s[i]=='0') {
                i++;
            }
            unsigned long long n=s[j]-'0';
            for (int k=j-1;k>=i;k--) {
                n*=10;
                n+=s[k]-'0';
            }
            cout<<n;
            if (t!='\0') {
                cout<<t;
            }
            i=++j++;
            if (t=='.') {
                flag=1;
            }
        }
    }
    return 0;
}
```

---

## 作者：我是蒟弱 (赞：12)

## 这道题思路会了就可以了。

**整数：**反着输出（交换）

**小数：**以小数点为分界线，前面当整数，后面当整数。

**分数：**以分数线（/）为分界线，前面当整数，后面当整数。

**百分数：**百分号前当整数，然后输出百分号。

### 话不多说，***上代码！***
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int main(){
	string a;
	cin>>a;//没有空格，直接用cin就行了 
	int xiaoshudian,fenshuxian,baifenhao,bfor;//xiaoshudian：小数点，fenshuxian：分数线，baifenhao：百分号，bfor：以后用的 
	bool z=false,x=false,f=false,b=false;//声明几个来判断是哪一个类型。z：整数；x：小数；f：分数；b：百分数 
	for(int i=0;i<a.length();i++){//遍历字符串 
		if(a[i]=='.'){//如果有小数点证明是小数 
			x=true;//小数类型判断变为true 
			xiaoshudian=i;//把小数点的位置存起来 
			break;//跳出循环就行了（没必要再循环下去） 
		}
		if(a[i]=='/'){//遇到了分数线（也就是除号）证明是分数 
			f=true;//分数类型判断变为true 
			fenshuxian=i;//储存分数线的位置 
			break;//跳出循环 
		}
		if(a[i]=='%'){//遇到了百分号证明是百分数 
			b=true;//百分数类型判断为true 
			baifenhao=i;//储存百分号位置（其实就是个人以后打起来顺一点，因为百分号必定在最后一个） 
			break;//跳出循环 
		}
	}
	if(x==false&&f==false&&b==false){//不是小数、分数、百分数 
		z=true;//那就是整数 
	}
	bool zero=true;//这个变量是判断及去除前面的0的 
	if(z==true){//是整数 
		for(int i=a.length()-1;i>=0;i--){//反着遍历 
			if(zero==true&&a[i]=='0'&&i==0){//如果这是最后一个数了切还一直没有输出 
				cout<<'0';//输出0 
				break;//结束（和return 0是一样的作用） 
			}
			if(zero==true&&a[i]=='0'){//如果这个是0且一个没输出 
				continue;//继续循环，寻找不是零的 
			}
			if(zero==true&&a[i]!='0'){//zero变量还是true（一个没输出）且现在不是0了 
				cout<<a[i];//输出 
				zero=false;//zero变量改变 
				continue;//避免重复输出 
			}
			cout<<a[i];//这是zero变量false的情况，可直接输出 
		}//整数处理完毕 
	}else if(x==true){//是小数 
		for(int i=xiaoshudian-1;i>=0;i--){//把小数点前面按整数处理（这个和整数的代码相同） 
			if(zero==true&&a[i]=='0'&&i==0){
				cout<<'0';
				break;
			}
			if(zero==true&&a[i]=='0'){
				continue;
			}
			if(zero==true&&a[i]!='0'){
				cout<<a[i];
				zero=false;
				continue;
			}
			cout<<a[i];
		} 
		cout<<'.';//输出小数点 
		zero=true;//再把zero变量给到true，因为有可能zero变量在上一次循环中变成了false 
		bfor=xiaoshudian;//bfor变量是小数点这个位置 
		if(a[xiaoshudian+1]=='0'){//因为if下面语句是for循环，写的i>bfor，如果是整数就不变bfor值 
			for(int i=xiaoshudian+1;i<=a.length()-1;i++){
				if(a[i]!=0){
					bfor=i;
					break;
				}
			}
		}
		for(int i=a.length()-1;i>bfor;i--){//把后面再当整数处理一次（还是那个代码） 
			if(zero==true&&a[i]=='0'&&i==bfor+1){
				cout<<'0';
				break;
			}
			if(zero==true&&a[i]=='0'){
				continue;
			}
			if(zero==true&&a[i]!='0'){
				cout<<a[i];
				zero=false;
				continue;
			}
			cout<<a[i];
		}
	}else if(f==true){//是分数 
		for(int i=fenshuxian-1;i>=0;i--){//分数线前当整数处理 
			if(zero==true&&a[i]=='0'&&i==0){//这个for循环也是和整数一样的代码 
				cout<<'0';
				break;
			}
			if(zero==true&&a[i]=='0'){
				continue;
			}
			if(zero==true&&a[i]!='0'){
				cout<<a[i];
				zero=false;
				continue;
			}
			cout<<a[i];
		} 
		cout<<'/';//输出分数线 
		bfor=fenshuxian;//和小数点似的处理bfor 
		if(a[fenshuxian+1]=='0'){//处理bfor变量 
			for(int i=fenshuxian+1;i<=a.length()-1;i++){
				if(a[i]!=0){
					bfor=i;
					break;
				}
			}
		}
		zero=true;//同理，由于上一个for循环，还得把zero赋值到true 
		for(int i=a.length()-1;i>bfor;i--){//再次当整数处理（没错，是那一个代码） 
			if(zero==true&&a[i]=='0'&&i==bfor+1){
				cout<<'0';
				break;
			}
			if(zero==true&&a[i]=='0'){
				continue;
			}
			if(zero==true&&a[i]!=0){
				cout<<a[i];
				zero=false;
				continue;
			}
			cout<<a[i];
		}
	}else{//是百分数 
		for(int i=baifenhao-1;i>=0;i--){//百分号前当整数处理（对，the same代码） 
			if(zero==true&&a[i]=='0'&&i==0){
				cout<<'0';
				break;
			}
			if(zero==true&&a[i]=='0'){
				continue;
			}
			if(zero==true&&a[i]!='0'){
				cout<<a[i];
				zero=false;
				continue;
			}
			cout<<a[i];
		}
		cout<<'%';//最后别忘了输出百分号 
	}
	return 0;//风风火火的结束代码 
}
```
## 愿大家AC！

---

## 作者：rentenglong (赞：10)

其实这个题主要在于题意理解。

如果过了简单的数字翻转，但是这个没过，应该参见以下条目：

- 关于整数

后面的0不要

遇到“0”或“000000000000”只输出0

- 关于小数

小数点前的整数：后面的0不要

小数点后的整数：前面的0不要

遇到“0”或“000000000000”只输出0

小数点的正确输出

- 关于分数

分数前的整数：后面的0不要

分数后的整数：后面的0不要

遇到“0”或“000000000000”只输出0

分数的正确输出

- 关于百分数

百分数前的整数：后面的0不要

遇到“0”或“000000000000”只输出0

百分号的正确输出

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char a[200];//存储读入数据
int len=0;//读入数据长度
void reversef(int fro,int to)//本函数用于计算整数翻转或小数点前的整数翻转（全拼：reverse front）
```
{//函数是模块化函数，直接从a圈定范围a[fro...to]进行反转。
```cpp
    bool is_ok=false;//用来判断是否去完“0”
    for(int i=to;i>=fro;i--)
    {
        if(is_ok==false)
        {
            if(a[i]!='0')//扫描到非0整数，表明去0成功
            {
                is_ok=true;
                cout<<a[i];
            } 
        }
        else cout<<a[i];//如果已经完成去0，则直接输出被反转字符
        if(is_ok==false&&i==fro) cout<<"0";//整个字符串没有非0整数，即“0”或“0000000”情况，直接输出0
    }
}
void reverseb(int fro,int to)//用于小数点后面的整数反转，即去前翻转。（全拼：reverse behind）
{
    bool is_ok=false;
    for(int i=fro;i<=to;i++)//这是为了去掉前面的0
    {
        if(a[i]!='0')
        {
            fro=i;
            is_ok=true;
            break;
        }
    }
    if(is_ok==false)//如果前面没扫描到0，就说明是“0”或“0000000”情况，直接输出0
    {
        cout<<"0";
        return;
    }
    else
    {
        for(int i=to;i>=fro;i--) cout<<a[i];//正常情况直接进行翻转
    }
}
int main()//主程序
{
    cin>>a;
    len=strlen(a);//读入数据
    for(int i=0;i<len;i++)//开始分辨数据的情况
    {
        if(a[i]=='.')//小数点情况
        {
            reversef(0,i-1);
            cout<<a[i];
            reverseb(i+1,len-1);
            return 0;
        }
        if(a[i]=='/')//分数情况，注意前后都用了reversef
        {
            reversef(0,i-1);
            cout<<a[i];
            reversef(i+1,len-1);
            return 0;
        }
        if(a[i]=='%')//白分数情况
        {
            reversef(0,i-1);
            cout<<"%";
            return 0;
        }
    }
    reversef(0,len-1);//以上情况都没遇到，则数据是整数，直接翻转整数就行了。
    return 0;
}
```

---

## 作者：lqhsr (赞：8)

## 总体来说这题坑多，整体思路如下：

第三篇题解啦，开心~~~

先scanf输入，再找各个符号并调用函数交换符号前和符号后的部分（%只要交换前面的部分即可）如果没有符号就整体交换，我始终没有把他当数字看待而是用处理字符的方式处理，所以输出有点麻烦......

## 坑点：

1.有的数据符号前全是零记得输出一个0

2.如10000这种倒过来应该是1，前面的0不要输出

3.输出......呃......麻烦啊主要是0的输出与省略，看下面程序里的详解吧

4.嗯......好像就这么多了（自造坑点的除外）

## 代码如下：
（看累了可以翻到最下面，讲个小故事）：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[30],st[4]={'.','/','%'};
int zhao,n;
int str(char ch)
{
    for(int i=0;i<n;i++)
        if(s[i]==ch)//如果找到了这种符号（ch）就返回下标
            return i;
    return 0;//没找到返回0
}
void change(int le,int ri)
{
    int cha=ri-le,ji=(cha+1)/2;//cha用来控制交换的位置，ji用来控制交换次数，cha+1是总元素个数，如6个元素除2交换3次，7个也是3次，中间的元素不用交换
    if(cha==1){//只有两个元素时（1-0=1，所以n个元素cha为n-1）
        swap(s[le],s[ri]);//函数交换即可(不这样做跑下面的会错)
        return;
    }
    bool bo=cha%2;//记录cha的奇偶性
    for(int i=0;i<ji;i++){//千万记得用ji，而不是(cha+1)/2，cha的值在循环中会改变
        swap(s[i+le],s[i+cha+le]);//这里特别说明一下：如测试点1：6980358432985(不用数了，13位)要交换6次6de下标为0，5的下标为12，i+le=0，i+cha+le=12，
        if(cha<=3)cha=1;//交换到最后2个（共偶数个元素）时cha=3时如698035已经交换了9和3即只要交换8和0即可，此时应cha=1
        else cha-=2;//还要交换次数>1次如交换6和5以及9和3
        if(bo==0&&cha==1)//cha为偶数即共有奇数个元素且cha=1（即只剩下中间的元素没动过了）
            return;//果断返回
    }
}
bool pan(int p,int q)
{
    bool booo=0;
    for(int l=p;l<=q;l++)
        if(s[l]!='0')booo=1;//有除0以外的元素标记下
    if(booo)
    return 1;//有除0之外的元素就可以输出0
    return 0;//没有除0之外的元素就不输出
}
int main(){
    scanf("%s",&s);//输入
    n=strlen(s);//判断长度
    for(int l=0;l<2;l++){//找‘。’或‘/’
        zhao=str(st[l]);
        if(zhao){//找到了
            change(0,zhao-1);//交换前半部分
            change(zhao+1,n-1);//交换后半部分
            goto sb;//跳过找其他符号的部分
        }
        zhao=0;
    }
    zhao=0>=str(st[2])?n:str(st[2]);//找‘%’或什么符号也没有即全为数字
    if(zhao||zhao==0){
        change(0,zhao-1);//此时只需交换之前的部分即可
        goto sb;
    }
    sb:
    bool bo=0;
    for(int i=0;i<n;i++){
        if(s[i]!='0'){//如果输出的不是0，那就直接输出
            bo=1;//表示已经输出了非零的字符
            cout<<s[i];//输出
        }
        else //将要输出0
            if(bo==1){//如果前面有东西，就从该点找到符号处或从符号初找到末尾因为数据中有100000这种数据（测试点18、19）
                if(i<zhao)
                    if(pan(i+1,zhao-1)==1)//这种数据在符号前，注意是减1
                        cout<<"0";
                if(i>zhao)
                    if(pan(i+1,n-1)==1)//在符号后，同样减1
                        cout<<"0";
            }
        if('0'>s[i]||s[i]>'9'){//到符号处从新开始
            bo=0;
            if(s[i]=='%')return 0;//如果是%则退出
        }
        if(('0'>s[i+1]||s[i+1]>'9'))//如果前面全是0（数据有这么坑）就只输出一个0
            if(bo==0)cout<<"0";
    }
}
```

来来来故事开始:

全洛谷最爱玩的游戏是slay one，但这个名字就告诉我们因该节制：

正着读：死了一个

反着都：累死一个

这说明什么？

————你的KD比越高你就越累

所以适度装逼有益健康，适当放过他人快乐自己~~（别一群人上来狂轰滥炸）~~


请审阅大佬通过，这篇题解我是非常认真地写的，谢谢大佬啦

---

## 作者：黑曜守护Violet (赞：7)

本来这题我是想用STL中的vector装逼一波的，但最后翻车了，调了半小时没调出来

~~（装逼是有代价的）~~

身为蒟蒻，我无法写出楼下那位dalao那样精炼的题解，但是我的思路一定非常好理

解，我用的是队列的思想；

比如：一个小数：

  230.0098；
  
先读入；然后我们找到小数点的位置，标记为mid；接下来，有四个指针（这是假的指

针，只是记录数组下标，不是真的指针，所以，请不要看到指针就跳过这篇题解~~）

以上面的小数为例：
 
head1 指向 2；

tail1 指向 0（小数点前面那个）；

head2 指向 0（小数点后第一个）；

tail2 指向 8；

mid 指向 小数点；

在反转后，对于一个小数来说，整数部分的前面不能是0，小数部分的后面不能是0，

所以也就是说：在反转前：整数部分的后面不能是0，小数部分的前面不能是0；

如何去掉0呢？ 很简单，不输出就行了；

比如：我们想去掉小数点后的那两个0，可以这么做：


```
while(a[head2]==0&&head2<tail2)
  
  head2++;
  
 ```
 
 输出的时候从tail2循环到head2，就可以倒序输出了；
 
 为什么要有一个head2<tail2的判断呢？ 是为了防止0被减完，比如：有一个测试点
 
 是 000.0000；如果没有那句判断；输出就只剩一个小数点；而如果有，那么就能输
 
 出0.0；
 
 好了，至于除号，百分号和整数；除号和小数差不多，百分号，整数都更简单，看下
 
 代码就能理解了；
 
 上代码
 
``` 
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int mid,head1,head2,tail1,tail2,head,tail,len,flag1,flag2;
char a[101];
int main()
  {
  	cin.getline(a,100);
  	len=strlen(a);
  	for(int i=0;i<len;i++)
  	  {
  	  	if(a[i]=='.'||a[i]=='/')
  	  	  {
  	  	  	flag1=1;
  	  	  	mid=i;
  	  	  	head1=0;
  	  	  	tail1=mid-1;
  	  	  	head2=mid+1;
  	  	  	tail2=len-1;
		  }
	  }
	if(flag1==0)
	  {
	  	head=0;
	  	tail=len-1;
	  	while(a[tail]=='0'&&head<tail)
	  	  tail--;
	  	if(a[tail]=='%')
	  	  {
	  	  	tail--;
	  	  	flag2=1;
	  	  	while(a[tail]=='0'&&head<tail)
	  	  	  tail--;
		  }
	  	for(int i=tail;i>=head;i--)
	  	  cout<<a[i];
	  	if(flag2==1)
	  	  cout<<"%";
	  	return 0;
	  }
	else
	  {
	  	if(a[mid]=='.')
	  	  {
	  	  	while(a[tail1]=='0'&&head1<tail1)
	  	  	  tail1--;
	  	  	while(a[head2]=='0'&&head2<tail2)
	  	  	  head2++;
	  	  	for(int i=tail1;i>=head1;i--)
	  	  	  cout<<a[i];
	  	  	cout<<a[mid];
	  	  	for(int i=tail2;i>=head2;i--)
	  	  	  cout<<a[i];
	  	  	return 0;
		  }
		if(a[mid]=='/')
		  {
		  	while(a[tail1]=='0'&&head1<tail1)
		  	  tail1--;
		  	while(a[tail2]=='0'&&head2<tail2)
		  	  tail2--;
		  	for(int i=tail1;i>=head1;i--)
	  	  	  cout<<a[i];
	  	  	cout<<a[mid];
	  	  	for(int i=tail2;i>=head2;i--)
	  	  	  cout<<a[i];
	  	  	return 0;
		  }
	  }
	return 0;
  }
  ```
  
好了，讲完了
  
打字辛苦，求审核过~

---

## 作者：s_h_y (赞：6)

我看了一下貌似我代码最短。

先写一个反转操作，去除收尾0再反转，若为空则返回'0'。

然后分类讨论，若含'.'或'/'则拆开扔到过程里，若最后是'%'则先去掉反转后添加即可。

基本不需要废话。



```cpp
var
 x:longint;
 s:string;
function ct(s:string):string;
var
 i,l,r:longint;
begin
 ct:='';
 l:=1;         while s[l]='0' do inc(l);
 r:=ord(s[0]); while s[r]='0' do dec(r);
 for i:=r downto l do ct:=ct+s[i];
 if ct='' then exit('0')
end;
procedure pr(s:string);
begin
 write(s);
```
halt

```cpp
end;
begin
 read(s);
 x:=pos('.',s); if x>0 then pr(ct(copy(s,1,x-1))+'.'+ct(copy(s,x+1,20)));
 x:=pos('/',s); if x>0 then pr(ct(copy(s,1,x-1))+'/'+ct(copy(s,x+1,20)));
   if s[ord(s[0])]='%' then pr(ct(copy(s,1,ord(s[0])-1))+'%');
                            pr(ct(s))
end.
```

---

## 作者：野菜汤 (赞：6)

题解：

我真是非常佩服此题的作者，把原本的一题水题变得更水了。而且这个作者也可谓是勤勤恳恳，这题竟然有二十个测试点，发过题目的朋友都知道，出一道题最麻烦的就是写测试点了，所以在此表达对作者的真心敬佩。


**然后再说一下算法分析：其实我们只要拿出原本数字反转的题解，然后对于小数点，分号，百分号分别进行处理。而比较需要注意的就是数据为小数时的小数部分，需要单独提出来处理，因为对于一个整数，例如100，它是成立的，可是对于一个小数0.100就需要变成0.1，所以这一部分需单独处理。**

        
说了那么多，那么程序该如何实现呢？其实我们只要用字符串来读入，然后用pos找出符号，对于符号前与符号后的数进行处理。这里有几点需要注意：

**1.整数和百分数只需要做前部分的处理，不要把后一部分的处理也写出来了。**

2.在所给出的数据中，很有可能会有0的情况出现，对于这种情况，要十分注意，我栽在上面好多次了。

**3.这里讲一下0的情况的细节。首先除了小数的小数部分之外的数，绝对不可能以0开头，所以如果数据的第一个字符就是0，那么直接打0,。而小数的小数部分呢，它的开头可以是0，但结尾就绝对不可能是0，那么如果该数据的最后一个字符是0，也直接打0。**

  
**以下是个人的AC源程序，仅供参考。**

```delphi
var i,j,k,m,n,q,p:longint;
    s:string;
procedure fz1(s:string);{这里是对于普通的整数进行处理的过程}
begin
  if s[1]='0' then begin write('0');exit;end;{对于答案是0的情况的处理}
  j:=length(s);
  while s[j]='0' do dec(j);{去0}
  for i:=j downto 1 do{倒向输出即为答案}
    begin
      write(s[i]);
    end;
end;
procedure fz2(s:string);{对于小数的小数部分的特殊处理}
var i:longint;
begin
  j:=length(s);
  if s[j]='0' then begin write('0');exit;end;
  while s[j]='0' do dec(j);{去掉开头的0}
  k:=1;
  while s[k]='0' do inc(k);{去掉末尾的0}
  for i:=j downto k do
    begin
      write(s[i]);
    end;
end;
begin
  read(s);
  n:=length(s);
  m:=pos('.',s);
  if m>0 then begin{如果该数据是小数，那么处理}
    fz1(copy(s,1,m-1));{对该小数的整数部分处理}
    write('.');{在数据中间打出小数点}
    fz2(copy(s,m+1,n));{对于该小数的小数部分的处理}
    exit;{处理完后就退出}
  end;
  p:=pos('/',s);{以下处理大致与上同}
  if p>0 then begin
    fz1(copy(s,1,p-1));
    write('/');
    fz1(copy(s,p+1,n));
    exit;
  end;
  q:=pos('%',s);
  if q>0 then begin
    fz1(copy(s,1,q-1));{对于百分号的数据只需要处理一个数据}
    write('%');
    exit;
  end;
  fz1(s);{如果数据既不是小数、分数也不是百分数那么就直接进行整数的处理}
end.
```

---

## 作者：亮剑精神 (赞：5)

错了好多次，一AC高兴得键盘都要拍烂了；

百分号在最后，可删除不管，后来补上；

然后判断是分数，是小数，或是整数；

去零；

倒着输出；

添百分号；
```c
#include <iostream> 
#include <cstdio>
using namespace std;
#include <cstring>
#include <ctype.h>
#include <cmath>
#include <time.h>
#include <stdlib.h>
#include <algorithm>
#include <bits/stdc++.h> 
int main(){
    char a[50];
    int s=-1,d=-1,bai=0;
    scanf("%s",a);
    if(a[strlen(a)-1]=='%'){    //如果是百分数 
    	a[strlen(a)-1]=0;       //删除百分号 
    	bai++;                  //记录 
	}
    for(int i=0,j=strlen(a);i<j&&bai==0;++i){    //访问 
    	if(a[i]=='.'){                           //如果是小数 
		    d=i;                                 //记录 
		    break;
	    }
	    if(a[i]=='/'){                           //如果是分数 
		    s=i;                                 //记录 
		    break;
	    }
	}
	if(s==-1&&d==-1)    for(int i =strlen(a)-1;a[i]=='0'&&i!=0;--i)     a[i]=0;    //整数去零 
	if(d!=-1){                                                                     //小数去零 
		int m = d-1;
		for(;a[m]=='0'&&m!=0;--m)     a[m]=97;                                     //去掉小数点前的零（别在意97。98，99都行） 
		m = d+1;
		for(int i =strlen(a)-1;a[m]=='0'&&m!=i;++m)     a[m]=97;                   //去掉小数点后零 
	}
	if(s!=-1){
		int m = s-1;                                                               //类似 
		for(;a[m]=='0'&&m!=0;--m)     a[m]=97;
		for(int m =strlen(a)-1;a[m]=='0'&&m!=s+1;--m)     a[m]=97;
	}
	if(d!=-1){
		for(int i = d-1;i!=-1;--i){         //反转输出 ，是零跳过 
			if(a[i]==97)    continue;
		    cout<<a[i];
		}
		cout<<'.';
		for(int i = strlen(a)-1;i!=d;--i){
			if(a[i]==97)    continue;
		    cout<<a[i];
	    }
	}
	else if(s!=-1){
		for(int i = s-1;i!=-1;--i){
			if(a[i]==97)    continue;
		    cout<<a[i];
		}
		cout<<'/';
		for(int i = strlen(a)-1;i!=s;--i){
			if(a[i]==97)    continue;
		    cout<<a[i];
	    }
	}
	else    for(int i = strlen(a)-1;i!=-1;--i)    cout<<a[i];
	if(bai==1)    cout<<'%';    //添百分号 
    return 0;
}
```

---

## 作者：iCaesar (赞：5)

//解法有点特殊，并不完全使用字符串，而是把字符串转为数字之后使用数学方法进行接下来的操作，除了整数，因为整数最高数据有20位，即使使用long long也存不下，只好用字符串操作（其实我觉得数学方法会简单点），嘛，觉得我写的够详细了，代码如下



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<ctime>
#include<string>
#include<cstdlib>
using namespace std;
void turn(long long &s);//声明一个函数来进行使用数学方法反转；
int main()
{
  char a[200],b[200];
  int i,j=0,k; long long s;
  gets(a);//读入数据
 for(i=0;i<strlen(a);i++)
 if(a[i]<48||a[i]>57) break;else j++;//这句代码可以判断非数字的字符（即小数点啊百分号之类的）在哪个位置，如果没找到符号说明是读入的是整数，如果符号在最后一位说明是百分数，如果符号在数组中间说明是小数或分数
 if(j==strlen(a))//判断出是整数的话
 {
     i=strlen(a)-1;
     while(a[i]=='0') i--;//从后往前找到第一个不为0的数
     if(i==-1) { cout<<0<<endl; return 0;}//如果全部都是0，就输出0，结束程序
     for(;i>=0;i--) cout<<a[i];//否则就从第一个不为0的位置开始倒着输出剩下的数
     cout<<endl;
 }
 else if(j==strlen(a)-1)//判断出是百分数
 {
         sscanf(a,"%lld",&s);//使用sscanf函数把数组a转换为整型数s
   turn(s);//执行函数，函数体在main函数后方记得看哟
   cout<<s<<'%'<<endl;//别忘了百分号
 }
 else if(j<strlen(a)-1)//判断出是小数或分数
 {
     sscanf(a,"%lld",&s);//使用sscanf函数把数组a转换为整型数s，但是因为sscanf读入到非数字符号时就自动结束读入（可以自己去尝试一下加深理解），所以这时候s里存的其实是小数点（或百分号）前面的数字
     turn(s);
cout<<s<<a[j];//输出反转后的前面部分，别忘了输出符号
     for(i=j+1,k=0;i<strlen(a);i++,k++) b[k]=a[i];//把从数组a符号后一位开始的所有数存到数组b里
     sscanf(b,"%lld",&s);//同理，这时s里存的是a数组里符号后面的数字
     turn(s);cout<<s<<endl;//执行函数，输出
 }
 return 0;
}
void turn(long long &s)//这个函数用来反转很方便，就是纯数学方法，思路是把整型数s的最后一位取出来，存到i里然后删掉s的最后一位，再取出来存到i里，同时i里上一次存的数乘以10，如果不懂的话建议随便找个数模拟一下
{
    long long i=0;
         while(s!=0)
     {
         i=i*10+s%10;
         s=s/10;
     }
     s=i;
}

```

---

## 作者：张鑫杰 (赞：4)

一个oop语言怎么能够没有oop的题解呢？
我的思路都在一个叫var的class里。
利用STL的reverse函数、substr函数、erase函数可以完成任务。
坑点也是有的，比如1.001变成1.1这些要分开讨论的点。
```cpp
#include<iostream>
#include<algorithm>
#include<sstream>
#include<istream>
#include<ostream>
using namespace std;
class var {//定义一个类
	friend ostream& operator<<(ostream& os, const var &a);//友元
private:
	string numLeft;
	string numRight;
	enum typeName {
		longint, decimal, fraction, percentage
	};//表示该var到底是小数,整数,分数,还是百分数
	typeName type;
public:
	var(string input) {//构造一个var类
		type = longint;//默认为整数,为什么是longint?Pascal留下的习惯
		numLeft = input;
		for (int i = 0; i != input.size(); i++) {
			if (input[i] == '%') {
				type = percentage;
				numLeft = input.substr(0,i);
				break;
			}
			if (input[i] == '.') {
				type = decimal;
				numLeft = input.substr(0, i);
				numRight = input.substr(i + 1);
				break;
			}
			if (input[i] == '/') {
				type = fraction;
				numLeft = input.substr(0, i);
				numRight = input.substr(i + 1);
				break;
			}
		}
	}
	var() = default;
	var turnAround() {//翻转
		bool flag = true;//是否为第一次
		if (type == longint || type == percentage) {//百分数和整数处理相似
			reverse(numLeft.begin(),numLeft.end());//翻转
			for (unsigned int i = 0; i < numLeft.size(); i++) {
				if (flag && numLeft[i] != '0') {
					flag = false;
					if (i != 0) {
						numLeft.erase(0, i);//删除范围[0,i)
					}
				}
				if (flag && i != 0 && i == numLeft.size() - 1) {
					numLeft.erase(0, i);//如果全是0
				}
			}
		}
		else {//分数和小数处理相似
			reverse(numLeft.begin(), numLeft.end());//翻转
			reverse(numRight.begin(), numRight.end());
			for (unsigned int i = 0; i < numLeft.size(); i++) {
				if (flag && numLeft[i] != '0') {
					flag = false;
					if (i != 0) {
						numLeft.erase(0, i);//删除范围[0,i)
					}
				}
				if (flag && i != 0 && i == numLeft.size() - 1) {
					numLeft.erase(0, i);//如果全是0
				}
			}
			flag = true;
			for (unsigned int i = 0; i < numRight.size(); i++) {
				if (flag && numRight[i] != '0') {
					flag = false;
					if (i != 0) {
						numRight.erase(0, i);//删除范围[0,i)
					}
				}
				if (flag && i!=0 && i == numRight.size() - 1) {
					numRight.erase(0, i);//如果全是0
				}
			}
		}
		if (type == var::decimal) {//小数特别去掉末尾的零
			for (int i = static_cast<int>(numRight.size())-1; i >= 0 ; i--) {
				if (numRight[i] != '0' || i == 0) {
					break;
				}
				if (numRight[i] == '0') {
					numRight.erase(i);
				}
			}
		}
		return *this;
	}
	
};
istream& operator>>(istream& is, var &a) {//重载
	string tmp;
	is >> tmp;
	a = var(tmp);
	return is;
}
ostream& operator<<(ostream& os,const var &a) {
	string out;
	if (a.type == var::percentage) {
		out = a.numLeft;
		out += "%";
	}
	else if(a.type == var::fraction){
		out = a.numLeft;
		out += '/';
		out += a.numRight;
	}
	else if (a.type == var::decimal) {
		out = a.numLeft;
		out += '.';
		out += a.numRight;
	}
	else {
		out = a.numLeft;
	}
	os << out;
	return os;
}
int main() {
	var i;
	cin >> i;
	i.turnAround();
	cout << i;
	return 0;
}
```
利用var类就可以完成

---

## 作者：luokd (赞：4)

蒟蒻的JAVA题解如下：


思路比较简单，**从最基本的整数反转这个函数出发**：


**判断读入字符串**中是含有小数点、斜杠还是百分号（./%），从而**分支**。这里我们用split()来进行分子分母、整数部分小数部分以及百分数的数值的提取。


1-分数：分和分母分别反转，输出时两者之间加一个"/"


2-百分数：百分数直接反转，输出时末尾加一个"%"


3-小数：前段视作整数直接反转,小数部分若仅有一位且为零则保留，否则当作整数进行反转。


**注意：这里的整数反转时的参数有可能超过long，所以我们判断若接近long的最大值，则使用字符串处理来实现反转**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str = in.next();
        String resStr = "";
        if (str.indexOf('/') != -1) {
            String[] strArray = str.split("/");
            String numerator = strArray[0];
            String denominator = strArray[1];
            resStr = reverseInt(numerator) + "/" + reverseInt(denominator);
        } else if (str.indexOf('%') != -1) {
            String numerator = str.split("%")[0];
            resStr = reverseInt(numerator) + "%";
        } else if (str.indexOf('.') != -1) {
            String[] strArray = str.split("\\.");
            String inte = strArray[0];
            String decm = strArray[1];
            decm = "" + reverseInt(decm);
            if (decm.length() == 1 && decm.charAt(0) == '0') {
                // do nothing
            } else {
                while (decm.charAt(decm.length() - 1) == '0') {
                    decm = decm.substring(0, decm.length() - 1);
                }
            }
            resStr = reverseInt(inte) + "." + decm;
        } else {
            resStr = "" + reverseInt(str);
        }

        System.out.println(resStr);
    }

    private static String reverseInt(String originalNumber) {
        String result = "";
        if (originalNumber.length() < 19) {
            long sum = 0;
            for (int i = originalNumber.length() - 1; i >= 0; i--) {
                sum += Math.pow(10, i) * Integer.parseInt("" + originalNumber.charAt(i));
            }
            result = "" + sum;
        } else {
            int count=0;
            for (int i = originalNumber.length()-1; i >= 0; i--) {
                if(originalNumber.charAt(i)=='0') {
                    count++;
                }else {
                    break;
                }
            }
            
            for (int i = originalNumber.length()-count-1; i >= 0; i--) {
                result=result+originalNumber.charAt(i);
            }
        }

        return result;
    }
}
```

---

## 作者：Mono_pigsicklie (赞：4)

### Emma，关于这道题，我。。不想说啥子，也就做了它一个下午左右吧（原由：本人太菜）


------------

## 补充一个知识点goto语句：

这个东西特别的好用,可以直接无条件调到冒号后面的语句，进行操作。

举个例子：
```cpp
#include"bits/stdc++.h"
using namespace std;

int main() {
	ios::sync_with_stdio(false);//流输入输出，让cin堪比scanf
	int a,b,c,d;
	cin>>a>>b;
	if(a==b) c=a;
	else if(a>b) c=b;
	else goto e;
	if(c==4) {
e:
		for(int i=1; i; i++) {
			d+=i;
		}
	}
	cout<<c<<d;
	return 0;
}
```

------------


#### 总结一下自己犯得**错误：

>1.（针对数据点2）如测试数据0.0000    没有判断多个0

>2.（针对数据点4）如测试数据0000/2414   当是分数的时候，没有判断前半部分的多个0

>3.（针对数据点5）如测试数据1234567890.0987654321   ' . ' 后半部分翻转后0移到末尾，不应该输出（但我却输出了Q）

>4.（针对数据点6）如测试数据0/10000   输出的正确结果应为0/1，但我的却是0/00001。

>5.（针对数据点20）如测试数据132000.000   输出应该为231.0。我的是231000.0。忘记删去0。


------------

	针对以上**错误，我调了很长时间……嘤。

### 具体的注意事项在code中有注释（稍微有点长Q）：

```cpp
#include"bits/stdc++.h"
using namespace std;

#define N 300

char s[N];

int a[N];//没任何卵用

int cnt=0;//+1

int flag=0;

int main() {
	cin>>s;
	int len=strlen(s);//字符串长度
//特判0
	if((s[0]=='0' && len==1) /*整数*/) {
		cout<<0<<"\n";
		return 0;
	}//一个0
	/*	if((s[0]=='0' && s[1]=='0') ) {//整数
	        for(int i=0; i<=len-1; i++)
	            if(s[i]=='0') cnt++;
	        if(cnt==(len-1))
	            cout<<0;
	        return 0;
	    }//多个0
	*/
	cnt=0;
	if((s[0]=='0' && s[1]=='%')/*百分数*/) {
		cout<<0<<"%\n";
		return 0;
	}//针对 0%
	if(s[0]=='0' && s[1]=='0' && len>1) {
		for(int i=0; i<=len-1; i++) {
			if(s[i]=='/' || s[i]=='.') {
				flag=2;
			}
		}
	}//针对类似数据 0000000/2414
	for(int i=0; i<=len-1; i++) {//判断属于哪种类型
		if(s[i]=='.'||s[i]=='/')
			flag=2;//小数，分数
	}
	for(int i=0; i<=len-1; i++) {
		if(s[i]=='%')
			flag=3;//百分数
	}
	if(flag==0) flag=4;//整数
//	cout<<flag<<'\n';//手动调试
	if(flag==4) {//整数
		cnt=0;//归零
		memset(a,0,sizeof(a));//清空
		if(s[len-1]=='0') {//如果翻转后开头是0
			for(int j=len-2; j>=0; j--) {//从开头接着往前判断直到找到第一个不是0的位置
				if(s[j]!='0') {
					for(int i=j; i>=0; i--)
						cout<<s[i]-'0';
					return 0;//直接输出，结束
				}
			}
		}
		if(s[len-1]!='0') { //如果翻转后开头不是0
			for(int i=len-1; i>=0; i--) cout<<s[i]-'0';
			return 0;
		}
	}
	if(flag==3) {//百分数
		cnt=0;
		memset(a,0,sizeof(a));//
		if(s[len-2]=='0') {//因为是百分数，所以最后一个肯定是符号%，直接从倒数第二个开始,len-1是倒数第一个
			for(int i=len-3; i>=0; i--) {
				if(s[i]!='0') {//跟整数的处理差不多
					for(int j=i; j>=0; j--)
						cout<<s[j]-'0';
					cout<<s[len-1];
					return 0;
				}
			}
		} else {
			for(int i=len-2; i>=0; i--)//
				cout<<s[i]-'0';
			cout<<s[len-1];
			return 0;
		}
	}
	int b;
	int d=-100;//记录位置
	if(flag==2) {//小数、分数
		for(int i=0; i<=len-1; i++) {//从头开始找'.'和'/'
			if(s[i]=='.'||s[i]=='/') {//以它为界限，分成前后两部分
				b=i;
				break;//找到就直接退出循环
			}
		}
		if(s[b-1]=='0' && (b-1==0)) {//如果只有一个0
			cout<<0;
			goto a;//goto 语句
		} else if(s[b-1]=='0') {//多个0
			for(int y=b-1; y>=0; y--) {
				if(s[y]!='0') {
					d=y;//记录位置
					break;
				}
			}
			if(d==(-100)) goto b;//goto语句，针对此类数据134500000.0000
			for(int y=d; y>=0; y--) cout<<s[y];//输出前半部分
			goto a;
		}
b:
		if(s[b-1]=='0') {
			for(int j=b-2; j>=0; j--) {//如果存在多个0
				if(s[j]=='0')
					cnt++;
			}
			if(cnt==(b-1)) {
				cout<<0;
				goto a;
			}
		}//再一次针对这种数据 000000000/2414，一个貌似针对不了
		if(s[b-1]=='0') {//注意翻转后开头是否为0
			for(int j=b-2; j>=0; j--) {//找第一个不是0的位置
				if(s[j]!=0)
					for(int k=j; k>=0; k--)
						cout<<s[k];
				break;
			}
		} else if(s[b-1]!='0') {//如果开头不是0
			for(int j=b-1; j>=0; j--)
				cout<<s[j];
		}
a:
		cout<<s[b];//输出符号
//找符号界限后面的
		/*
		以符号'.'和'/'为界限分成前后两个部分，（因为它们都位于数字中间，所以可以将它们归为一类）
		*/
		cnt=0;//归零
		if(s[len-1]=='0' && (len-1==b+1) ) {//如果只有一个0
			cout<<0;
			return 0;
		} else if(s[len-1]=='0') {//如果存在多个0
			for(int j=len-2; j>=b+1; j--) {
				if(s[j]=='0') cnt++;
			}
			if(cnt==(len-2-b)) {
				cout<<0;
				return 0;
			}
		}//针对这种数据 0.000000
		cnt=0;
		int w;//记录位置
		if(s[b+1]=='0') {
			for(int u=b+2; u<=len-1; u++) {
				if(s[u]!='0') {
					w=u;
					break;
				}
			}
			for(int u=b+1; u<w; u++) {
				s[u]='\0';//转换为空字符
			}
		}//针对这种数据1234567890.0987654321
		if(s[len-1]=='0') {//注意翻转后开头是否为0
			for(int j=len-2; j>=b+1; j--) {
				if(s[j]!='0') {
					/*for(int k=j; k>=b+1; k--)
					if(s[k]=='0' && s[k+1]=='0' && s[k+2]=='0' && s[k+3]=='0' && s[k+4]=='0') {
					    cout<<" ";
					    return 0;
					}
					if(s[k]=='0') {
					    for(int l=k; l>=b+1; l--)
					        if(s[k]=='0') cnt++;
					    if(cnt==(k-b)) {
					        s[k]=' ';
					    }
					}*/
					for(int l=j; l>=b+1; l--)
						cout<<s[l];
					return 0;
				}
			}
		} else if(s[len-1]!='0') { //若开头不是0
			for(int x=len-1; x>=b+1; x--)
				cout<<s[x];
			return 0;
		}
	}
}
//DARLING in the FRANXX
```

---

## 作者：中2少年雷耶斯 (赞：3)

#第一印象：很简单啊~

然后到了75分的时候才发现这题的真实难度

**辗转二十余次，终于做对，好坑好坑好坑好坑的题啊！！！**

##至少有二十次是在小数部分卡着了##

不多说，放题解（一定要小心小数部分的坑！！这里重点提出了！）


/\*C++版 数字反转（强化版）题解  作者：magooli\*/

/\*我能不能吐槽一句，既然写了“本题没有负数”为什么有那么多人判断负数……\*/

```cpp
#include<iostream> 
#include<cstring>
#include<cstdio>
using namespace std;
char a[233];  //储存需要转换的数
char q[233],w[233];  //分开储存整数小数和分子分母
bool xiao=0,zheng=0,bai=0,fen=0,zero=0;
//xiao为是否为小数，zheng为是否为整数，bai为是否为百分数
//fen为是否为分数，zero判断整数部分前置0和小数后置0 
int xiaoo,fenn; //分别储存小数点的位置和分数杠的位置 
int zz=0;
#define back zero=zz=0;
#define next continue 
#define out goto end 
int main(void) 
{
    cin>>a;
    for(int i=0;i<=strlen(a)-1;i++) //从前到后查找一遍查看数类型 
    if(a[i]=='.'){xiao=1;xiaoo=i;} 
    else if(a[i]=='%')bai++;
    else if(a[i]=='/'){fen=1;fenn=i;}
    if(xiao==0&&fen==0&&bai==0)zheng=1;//不是小数不是分数不是百分数就是整数~ 
    if(zheng==1)//整数（难度：入门） 
    { 
        if(a[0]=='0'){cout<<"0";out;}//此数为0的情况 
        for(int i=strlen(a)-1;i>=0;i--)//输出 
        { 
            if(zero==0&&a[i]=='0')next;//忽略前置0 
            else{zero=1;cout<<a[i];}
        }
    }
    else if(bai==1)//百分数（难度：还是入门）
    {
        if(a[0]=='0'){cout<<"0%";out;}
        for(int i=strlen(a)-2;i>=0;i--)
        {
            if(zero==0&&a[i]=='0')next;
            else{zero=1;cout<<a[i];}
        }
        cout<<"%";//再输出%即可
    }
    else if(fen==1)//分数（难度：一般）
```
{//分成两个整数处理即可
for(int i=0;i<=fenn-1;i++){zz++;q[zz]=a[i];}back; //分子分母分开运算

for(int i=fenn+1;i<=strlen(a)-1;i++){zz++;w[zz]=a[i];}

```cpp
        if(q[1]=='0') //分子为0的情况
        {
            cout<<"0/";//直接输出分子
            for(int i=strlen(a)-1;i>=fenn+1;i--)
            {
                if(zero==0&&a[i]=='0')next;
                else{zero=1;cout<<a[i];}
            }
            out;
        }
        for(int i=fenn-1;i>=0;i--) //输出分子
        {
            if(zero==0&&a[i]=='0')next; //这里基本跟整数相同（就是整数的好吧！）
            else{zero=1;cout<<a[i];}
        }
        back;cout<<"/";
        for(int i=strlen(a)-1;i>=fenn+1;i--) //输出分母
        {
            if(zero==0&&a[i]=='0')next;
            else{zero=1;cout<<a[i];}
        }
    }
    else if(xiao==1) //本人认为最难的部分（不能对着整数抄了）
    {
        for(int i=0;i<=xiaoo-1;i++){zz++;q[zz]=a[i];}back; //整数小数分开（怎么感觉很熟悉）
        for(int i=xiaoo+1;i<=strlen(a)-1;i++){zz++;w[zz]=a[i];}
        if(q[1]=='0')cout<<"0";
        else 
        for(int i=xiaoo;i>=1;i--)//输出整数部分！注意不要输出xiaoo+1个数，xiaoo不计入数字中
        {
            if(zero==0&&q[i]=='0')next;
            else{zero=1;cout<<q[i];}
        }
        cout<<".";  //不要忘记输出小数点
        back; //清零
        for(int i=1;i<=(strlen(a)-1-xiaoo);i++) //小数部分为0
        {
            if(w[i]!='0')break;
            if(i==(strlen(a)-1-xiaoo)){cout<<"0";out;}
        }
        for(int i=1;i<=1;i++)//删掉小数部分前置0，这样翻转后就没有后置0了
        {if(w[i]=='0'&&zero==0)w[i]='$'; //用一个符号代替，最后不输出这个符号就可以了
        else zero=1;}
        for(int i=(strlen(a)-1-xiaoo);i>=1;i--)if(w[i]!='$')cout<<w[i];
        if(1){}//上面i的数值为(strlen(a)-1)-(xiaoo+1)+1得来，前面两个大家都懂，+1是因为xiaoo
        if(1){}//不计入范围内，又因为是从xiaoo后开始推，所以总数要+1.
        while(1){}//反抄袭
    }
    end:{};;;;;;;;;;;;;;;;;;;;;;;;//结束工具
}
链接：https://www.luogu.org/record/show?rid=1193589
```

---

## 作者：Deny_小田 (赞：3)

我的代码#也很长

但是[color=blue]比较好懂[/color]


代码如下:



```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
int main(){
    int n,flag = 0,b = -1,p = 1;
    string a;
    cin >> a;
    n = a.size();
    for(int i = 0; i < n; i++){
        if(a.at(i) == '.'){
            flag = 1;
            b = i;
            break;
        }
        else if(a.at(i) == '/'){
            flag = 2;
            b = i;
            break;
        }
        else if(a.at(i) == '%'){
            flag = 3;
            b = i;
            break;
        }
    }
    switch(flag){
        case 0:{
            int p = 1;
            for(int i = n-1; i >= 0; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    printf("%c",a.at(i));
                }
            }
            if(p == 1) printf("0");
            break;
        }case 1:{
            for(int i = b-1; i >= 0; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    printf("%c",a.at(i));
                }
            }
            if(p == 1) printf("0");
            printf(".");
            p = 1;
            for(int i = n-1; i >= b+1; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    if(a.at(i) == '0'&&i == b+1) continue;
                    printf("%c",a.at(i));
                }
            }
            if(p == 1) printf("0");
            break;
        }case 2:{
            for(int i = b-1; i >= 0; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    printf("%c",a.at(i));
                }
            }
            if(p == 1) printf("0");
            p = 1;
            printf("/");
            for(int i = n-1; i >= b+1; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    printf("%c",a.at(i));
                }
            }
```
/\*题目保证分母不为零\*/
    
```cpp
            break;
        }case 3:{
            for(int i = b-1; i >= 0; i--){
                if(a.at(i) == '0'&&p == 1) continue;
                else{
                    p = 0;
                    printf("%c",a.at(i));
                }
            }
            if(p == 1) printf("0");
            printf("%%");
            break;
        }
    }
    return 0;
}
```

---

## 作者：plazum (赞：3)

写一个用于反转的函数就方便多了嘛……

楼上说出测试点很难的，这题恰恰相反，这题要出测试点很容易，人工来搞就行了……

```cpp

#include<iostream>
#include<string>
using namespace std;
string s,t;
int pos,l;
void rev(string &s,int a,int b)//Use this to reverse a string (from s[a] to s[b])
{
    l=b-a+1;
    t="";
    while(s[b]=='0')b--;
    while(b-a+1)t+=s[b--];
    if(t.empty())t="0";
    s.replace(a,l,t);
}
int main()
{
    cin>>s;
    if((pos=s.find('.'))!=string::npos){//小数
        rev(s,0,pos-1);
        rev(s,s.find('.')+1,s.size()-1);
        while(s[s.size()-1]=='0'&&s.find('.')+2<s.size())s.resize(s.size()-1);
    }else if((pos=s.find('/'))!=string::npos){//分数
        rev(s,0,pos-1);
        rev(s,s.find('/')+1,s.size()-1);
    }else rev(s,0,(pos=s.find('%'))-string::npos?pos-1:s.size()-1);//整数和百分数
    cout<<s;
    
    return 0;
}

```

---

## 作者：BelieveGod (赞：2)

虽然代码看起来有点长 但是实际上还是比较容易理解的  我这代码的核心思想 在小数部分的代码 其实还可以用自定义函数优化 但是我有点懒 

****这个题我的思路比较简单 就是考虑特殊符号前后的倒转和去零 ********

重点是 好多特殊值 比如说  0000.0000 12/1200 我也是不断在错误中修改 

重点是小数的代码 其他的都是复制粘贴 稍微修改的 



```c

#include<stdio.h>
#include<string.h>

int main ()
{
	char a[30];
	int n,i,sum=0,c;
	gets(a);
	c=1;
	for(n=0;a[n]!='\0';)//标记这个字符串的长度  
	{
		n++;
	}
	///////////////////////////////////////////////////////
	for(i=0;a[i]!='\0';i++)
	{
		if(a[i]=='.')//小数 找出小数点的下标 
		{
			for(sum=i-1;sum>=0;sum--)
				if(a[sum]!='0')
					break;
					if(sum==-1)//如果小数点前面都是0  比如 00000.0  只剩一个0 的情况 
			  printf("0");
			for(int x=i-1;x>=0;x--)//小数之前 
			{	
				if(a[x]!='0'||c==0)//两个条件 同时限制  第一个条件是0都去掉 但是中间的0也去掉了  所以要用c来限制 
				{
					printf("%c",a[x]);
					c=0;
				}
			}
			printf("%c",a[i]);//小数点的输出  
			
			for(c=i+1;a[c]!='\0';c++)//把前面的0给计数 
				if(a[c]!='0')
					break;
			for(int  x=n-1;x>=c;x--)//
			{
				printf("%c",a[x]);
			}
			if(c==n)//如果 c==n说明小数点的后面都是0  前面没有输出这里补上 
			  printf("0");
		}
	}
	/////////////////////////////////////////
		for(i=0;a[i]!='\0';i++)//分数 
	{
		if(a[i]=='/')//小数 找出小数点的下标 
		{
			for(sum=i-1;a[sum]!='\0';sum--)
				if(a[sum]!='0')
					break;
					if(sum==-1)//如果小数点前面都是0  比如 00000.0  只剩一个0 的情况 
			  printf("0");
			   
			for(int x=i-1;x>=0;x--)//分子  	
				if(a[x]!='0'||c==0)
				{
					printf("%c",a[x]);
					c=0;
				}
			printf("%c",a[i]);
			
			for(c=n-1;a[c]!='\0';c--)//去掉分母前面的0   比如 12/0012 去掉0 
				if(a[c]!='0')
					break;
			for(int  x=c;x>i;x--)//分母 
				printf("%c",a[x]);
		}
	}
	//////////////////////////////////////////////////
		for(i=0;a[i]!='\0';i++)//百分数 
	{
		if(a[i]=='%')
		{
			for(sum=i-1;a[sum]!='\0';sum--)
				if(a[sum]!='0')
					break;
					if(sum==-1)
			  printf("0");
			for(int x=i-1;x>=0;x--)
			{	
				if(a[x]!='0'||c==0)
				{
					printf("%c",a[x]);
					c=0;
				}
			}
			printf("%c",a[i]);
		}
	}
	/////////////////////////////////////////

		for(i=0;a[i]!='\0';i++)//整数 
	{	
		for(int x=0;a[x]!='\0';x++)
		{
			if(a[i]=='.'||a[i]=='/'||a[i]=='%')
			    sum=1;
		}//////////判断为整数 
		 
	}
	
	   if(sum!=1) 
	   {
	   		for(c=n-1;a[c]!='\0';c--)//标记 0 
				if(a[c]!='0')
					break;
					
					for(sum=i-1;a[sum]!='\0';sum--)
				if(a[sum]!='0')
					break;
					
					if(sum==-1)//都是0就只输出一个0  比如000000    
			  printf("0");
	   	   for(i=c;i>=0;i--)
	   	     printf("%c",a[i]);
	   }
	    //printf("sum=%d",sum) ;
	return 0 ;
}

```

---

## 作者：Hey_System (赞：2)

###这题神坑= =

看到其他题解有很多用字符串转数字的，开始觉得很奇怪为什么不直接反转字符

后来我知道了

......
到底是什么输入会鬼畜到有这种数据！

>输入：0000000000
>输出：0
......
直接反转字符串的话，会把字符头和尾的所有零去掉，对于这个输入

最后的输出就是

> 
所以需要判断是否全部为零（这个在下面的题解里也有提到过，我这个就算是对string库函数的应用(?)）



``


    
    
    
        
        
            
            
            
        
            
            
            
        
            
            
            
        
            
            
        
    
        
        
        
            
        
            
        
            
        
```cpp
    #include <iostream>
    #include <string>
    using namespace std;
    string turning(string);//反转字符函数
    int main()
    {
        string number;
        cin>>number;
        if(number.find('.')!=string::npos)//如果在这个字符中找到了“.”，也就是小数
        {
            string a,b;
            a=turning(number.substr(0,number.find('.')));//反转整数部分（也就是从开头到“.”的部分）
            b=turning(number.substr(number.find('.')+1));//反转小数部分（也就是从“.”的下一个到结尾的部分）
            cout<<a<<'.'<<b;
            exit(0);
        }
        else if(number.find('/')!=string::npos)//如果找到“/”，也就是分数
        {
            string a,b;
            a=turning(number.substr(0,number.find('/')));//反转分子
            b=turning(number.substr(number.find('/')+1));//反转分母
            cout<<a<<'/'<<b;
            exit(0);
        }
        else if(number.find('%')!=string::npos)//百分数
        {
            string a;
            a=turning(number.substr(0,number.size()-1));//反转数字部分
            cout<<a<<'%';
            exit(0);
        }
        else//整数
        {
            string a;
            a=turning(number);//直接反转
            cout<<a;
        }
        return 0;
    }
    string turning(string number)
    {
        string turned;
        bool allzero=true;//判零
        for(int i=0;i<number.size();i++)//查看是否全是0
            if(number[i]!='0')
                allzero=false;
        if(allzero)//如果是，直接返回0
            return "0";
    //不是就反转
        for(int i=0;i<number.size();i++)//去掉前面的零（用于小数部分反转）
        {
            if(number[i]!='0')break;
            number[i]='\0';
        }
        for(int i=number.size()-1;i>=0;i--)//去掉后面的零
        {
            if(number[i]!='0')break;
            number[i]='\0';
        }
        for(int i=number.size()-1;i>=0;i--)//反储存
        {
            if(number[i]=='\0')continue;
            turned+=number[i];
        }
        return turned;
}
```

---

## 作者：北海_Beihai (赞：2)

这题很简单，没有楼上说的那么复杂。

我的思路就是，首先用getline()读入字符串并创建一个字符串流，然后把所有的字符都放在一个栈里，遇到符号就全部适当处理并输出（此时已经反转），再入栈，当读完时再处理输出。

##**敬请管理员认可！！**

具体代码如下：

```cpp
#include<iostream>
#include<stack>
#include<string>
#include<sstream>
using namespace std;
int main(){
    stack<char> s;
    char c,op=' ';
    string ss;
    getline(cin,ss);
    stringstream in(ss);
    bool f=true;
    while(in>>c){
        if(c>='0'&&c<='9') {
            if(op!='.') s.push(c);
            else {
                if(!(c=='0'&&f)) s.push(c);
                if(c!='0') f=false;
            }
        }
        else{
            op=c;
            while(!s.empty()&&s.top()=='0') s.pop();
            if(s.empty()) cout<<0;
            while(!s.empty()) {
                cout<<s.top();
                s.pop();
            }
            cout<<op;
        }
    }
    while(!s.empty()&&s.top()=='0') s.pop();
    if(op!='%') if(s.empty()) cout<<0;
    while(!s.empty()) {
        cout<<s.top();
        s.pop();
    }
    return 0;
}
```

---

## 作者：varvar (赞：2)



```cpp
//数字反转及数字反转（升级版）之通用版
//代码超短版 
#include <cstdio>
#include <cstring>
using namespace std;
bool f;
char s[100];
int l,st[2],la[2];
void work(int a)
{
    if (s[st[a]]=='-')
    {
        printf("%c",'-');
        st[a]++;
    }
    if (f==true) while (s[la[a]]=='0') la[a]--;
    if (f==false) while (s[st[a]]=='0') st[a]++;//如果符号是'.'就从头开始删0 
    if (st[a]>la[a]) printf("%c",'0');//如果这段区间之间都是0，就直接输出0 
    for (int i=la[a];i>=st[a];i--) printf("%c",s[i]);
}
int main()
{
    f=true;
    gets(s);
    l=strlen(s);
    la[0]=-1;
    for (int i=0;i<=l-1;i++)
    {
        if ((s[i]=='/') || (s[i]=='.') || (s[i]=='%'))
        {
            work(0);//对符号前的区间进行处理 
            printf("%c",s[i]);//输出符号 
            if (s[i]=='%') return 0;// 如果符号是'%'就直接退出 
            if (s[i]=='.') f=false;
            st[1]=i+1;
            la[1]=l-1;//对后一段区间的头和尾进行赋值 
            work(1);//对符号后的区间进行处理 
            return 0;
        }
        la[0]++;
    }
    work(0);//如果是整数，就对整段区间进行处理 
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：2)

这题……模拟，四个过程，四种情况……

```delphi

var ss:string;
    i:longint;
procedure zhengshu(var s:string);
var i:longint;
begin
    if s='0' then begin write(0);exit; end;
    for i:=length(s) downto 1 do
    if s[i]='0' then delete(s,i,1) else break;
    for i:=length(s) downto 1 do
    write(s[i]);
    if s='' then write(0);
end;
procedure xiaoshu(var s:string);
var i,x:longint;
    ss:string;
begin
   x:=pos('.',s)-1;
   ss:=s;
   s:=copy(s,1,x);
   zhengshu(s);
   //write('.');
   x:=pos('.',ss)+1;
   i:=x;
   while 1=1 do                                       begin
       if length(ss)<i then break;
       if ss[i]='0' then delete(ss,i,1) else break;        end;
       if ss[length(ss)]='.' then begin write('.0');exit; end;
   write('.');
   for i:=length(ss) downto x do
   write(ss[i]);
end;
procedure fenshu(var s:string);
var s1,s2:string;
begin
    s1:=copy(s,1,pos('/',s)-1);
    s2:=copy(s,pos('/',s)+1,length(s)-pos('/',s));
    zhengshu(s1);
    write('/');
    zhengshu(s2);
end;
procedure baifenshu(var s:string);
var s1:string;
begin
    s1:=copy(s,1,length(s)-1);
    zhengshu(s1);
    write('%')
end;
begin
    readln(ss);
    if pos('.',ss)>0 then xiaoshu(ss) else//小数
    if pos('/',ss)>0 then fenshu(ss) else//分数
    if pos('%',ss)>0 then baifenshu(ss) else//百分数
                         zhengshu(ss);//整数
end.


```

---

## 作者：北北北北 (赞：2)

```c
#include <stdio.h>
#include <string.h>

void integer(char number[]){ //整数 
	int i;
	int start = 0; //整数中首数字的实际下标 
	int length = strlen(number); //整数的长度 
	
	for(i = 0; i < length/2; i++){ //因为是从0开始,所以循环终止条件就是i=length/2,而不是i>length/2 
		char temp = number[i];
		number[i] = number[length-i-1];
		number[length-i-1] = temp;
	}
	while(number[start] == '0' && start < length-1){ //去前缀0,且保证当整数全是0时,只保留一个0 
		start++;
	}
	for(i = start; i < length; i++){
		printf("%c", number[i]);
	}
}

void decimal(char number[]){ //小数
	int length = strlen(number); //整数部分+小数部分的长度 
	int start = 0,t_length = 0; //整数部分中首数字的实际下标,整数部分的长度 
	int i,j;
	
	for(i = 0; i < length; i++){ //计算整数部分的长度 
		if(number[i] == '.'){
			break;
		}
		t_length++;
	}
	for(i = 0; i < t_length/2; i++){ 
		char temp = number[i];
		number[i] = number[t_length-i-1];
		number[t_length-i-1] = temp;
	}
	while(number[start] == '0' && start < t_length-1){
		start++;
	}
	for(i = start; i < t_length; i++){
		printf("%c", number[i]);
	}
	for(i = 0; i < length; i++){
		if(number[i] == '.'){
			for(j = 0; j < (length-t_length-1)/2; j++){ //小数部分的长度=(整数部分的长度+小数部分的长度+小数点的长度)-整数部分的长度-小数点的长度 
				char temp = number[i+j+1];
				number[i+j+1] = number[length-j-1];
				number[length-j-1] = temp;
			}
			i = length;
		}
	}
	while(number[length-1] == '0' && length > t_length){ //去末尾0,且保证当小数部分全是0时,只保留一个0 
		length--;
	}
	if(number[length-1] == '.'){
		length++;
	}
	for(i = t_length; i < length; i++){
		printf("%c", number[i]);
	}
}

void fraction(char number[]){ //分数 
	int length = strlen(number); //分母的长度+分子的长度 
	int start = 0,t_length = 0; //分子中首数字的实际下标,分子的长度 
	int i,j;
	
	for(i = 0; i < length; i++){ //计算分子的长度 
		if(number[i] == '/'){
			break;
		}
		t_length++;
	}
	for(i = 0; i < t_length/2; i++){ 
		char temp = number[i];
		number[i] = number[t_length-i-1];
		number[t_length-i-1] = temp;
	}
	while(number[start] == '0' && start < t_length-1){
		start++;
	}
	for(i = start; i < t_length; i++){
		printf("%c", number[i]);
	}
	for(i = 0; i < length; i++){
		if(number[i] == '/'){
			for(j = 0; j < (length-t_length-1)/2; j++){ //分母的长度=(分母的长度+分子的长度+除号的长度)-分子的长度-除号的长度 
				char temp = number[i+j+1];
				number[i+j+1] = number[length-j-1];
				number[length-j-1] = temp;
			}
			i = length;
		}
	}
	while(number[t_length] == '0' || number[t_length+1] == '0'){ //去前缀0,PS:因为分母不为0,所以不再考虑当分母全为0时,要保留一个0的要求 
		t_length++;
	}
	if(number[t_length] != '/'){
		printf("/");
	}
	for(i = t_length; number[i] != '\0'; i++){
		printf("%c", number[i]);
	}
}

void percentage(char number[]){ //百分数 
	int i;
	int start = 0; //百分数中首数字的实际下标 
	int length = strlen(number); //百分数的长度
	
	for(i = 0; i < (length-1)/2; i++){
		char temp = number[i];
		number[i] = number[length-i-2];
		number[length-i-2] = temp;
	}
	while(number[start] == '0' && start < length-2){
		start++;
	}
	for(i = start; i < length; i++){
		printf("%c", number[i]);
	}
}

int main(){
	char number[25]; //要处理的数 
	int flag = 0; //0为整数,1为小数,2为分数,3为百分数 
	int i;
	
	scanf("%s", number);
	for(i = 0; number[i] != '\0'; i++){ //判断当前要处理的是什么类型的数 
		switch(number[i]){
			case '.': flag = 1; break;
			case '/': flag = 2; break;
			case '%': flag = 3; break;
		    default: break;
		}
	}
	switch(flag){
		case 0: integer(number); break;
		case 1: decimal(number); break;
		case 2: fraction(number); break;
		case 3: percentage(number); break;
		default: break;
	}
	
	return 0;
} 
```


---

## 作者：邓晓蓝 (赞：2)

//虽然我的代码不是最短，但目测我的代码是比较好懂的。其实就是纯模拟，分四种情况。首先我编写了两个自定义函数，分别用啦反转和去前导0.


```cpp
var  st,a:string;
function quling(st:string):string;   //这是去前导0
begin
  while (st[1]='0') and (length(st)>1) do delete(st,1,1);
  quling:=st;
end;
function fanzhuan(st:string):string;  //这是反转
var ii:longint;
begin
fanzhuan:='';
  for ii:=length(st) downto 1 do fanzhuan:=fanzhuan+st[ii];
end;
begin
  readln(st); 
  if pos('.',st)>0 then   //首先是小数情况
    begin
      a:=copy(st,1,pos('.',st)-1);  //先处理整数部分
      a:=fanzhuan(a);
      a:=quling(a);
      write(a,'.');
      a:=copy(st,pos('.',st)+1,255);   //小数部分需要特殊处理
      a:=fanzhuan(a);
      while (a[length(a)]='0') and (length(a)>1) do delete(a,length(a),1);  //不是去前导0，而是后导0.
      write(a);
    end else
  if pos('/',st)>0 then   //分数情况
    begin
      a:=copy(st,1,pos('/',st)-1);
      a:=fanzhuan(a);
      a:=quling(a);
      write(a,'/');
      a:=copy(st,pos('/',st)+1,255);
      a:=fanzhuan(a);
      a:=quling(a);
      write(a);
    end else
  if pos('%',st)>0 then  //百分数其实就是把百分号去掉按整数处理
    begin
      a:=st;
      delete(a,length(a),1);
      a:=fanzhuan(a);
      a:=quling(a);
      writeln(a,'%');
    end else
  begin  //整数部分
    st:=fanzhuan(st);
    st:=quling(st);
    writeln(st);
  end;
end.

```

---

## 作者：♂♂♂♂♂ (赞：2)

```cpp
var st:String;
function opposite(st:string):string;//整数用
var i:longint;
begin
  opposite:='';
  for i:=length(st) downto 1 do opposite:=opposite+st[i];
  while (length(opposite)>1) and (opposite[1]='0')
   do delete(opposite,1,1);//去前导0
end;
function opposite1(st:string):string;//小数用
var i:longint;
begin
  opposite1:='';
  for i:=length(st) downto 1 do opposite1:=opposite1+st[i];
  while (length(opposite1)>1) and (opposite1[1]='0')
   do delete(opposite1,1,1);//去前导0
  while (length(opposite1)>1) and (opposite1[length(opposite1)]='0')
   do delete(opposite1,length(opposite1),1);//化简
end;
begin
  readln(st);
  if pos('.',st)>0 then st:=opposite(copy(st,1,pos('.',st)-1))+'.'+opposite1(copy(st,pos('.',st)+1,255))
   else if pos('%',st)>0 then st:=opposite(copy(st,1,pos('%',st)-1))+'%'
    else if pos('/',st)>0 then st:=opposite(copy(st,1,pos('/',st)-1))+'/'+opposite(copy(st,pos('/',st)+1,255))
     else st:=opposite(copy(st,1,255));
  writeln(st);
end.
```

---

## 作者：百里亦守约_test (赞：2)

可以不用字符串做前导零，可以用字符串转数字，然后再用数字转字符串，就可以把前面的零去掉，然后再用val再次把反转后的前面的零去掉就可以输出了，这样子又不用写那么多又可以去除前导零。我加了//话就可以防止有三个点错。因为那三个点数据太大了。

```cpp
var st,st1,st2,xst:ansistring;  //
    o,xx,s:qword;   //
    i:longint;
begin
  readln(st);
  o:=1;
  for i:=1 to length(st) do
  begin
    if(st[i]='.') then o:=2;   //判断是哪一种情况。
    if(st[i]='/') then o:=3;
    if(st[i]='%') then o:=4;
  end;
  if(o=1) then
  begin
    for i:=length(st) downto 1 do
      xst:=xst+st[i];
    val(xst,xx);
    write(xx);
  end;
  if(o=2) then
  begin
    s:=pos('.',st);
    st1:=copy(st,1,s-1);
    val(st1,xx);
    str(xx,st1);      //去前导零，下面也是一样。
    st2:=copy(st,s+1,length(st));
    val(st2,xx);
    str(xx,st2);
    for i:=length(st1) downto 1 do
      xst:=xst+st1[i];   //反转，下面也是一样。
    val(xst,xx);      
    write(xx,'.');
    xst:='';
    for i:=length(st2) downto 1 do
      xst:=xst+st2[i];
    val(xst,xx);
    write(xx);
  end;
  if(o=3) then
  begin
    s:=pos('/',st);
    st1:=copy(st,1,s-1);
    val(st1,xx);
    str(xx,st1);
    st2:=copy(st,s+1,length(st));
    val(st2,xx);
    str(xx,st2);
    for i:=length(st1) downto 1 do
      xst:=xst+st1[i];
    val(xst,xx);
    write(xx,'/');
    xst:='';
    for i:=length(st2) downto 1 do
      xst:=xst+st2[i];
    val(xst,xx);
    write(xx);
  end;
  if(o=4) then
  begin
    s:=pos('%',st);
    st1:=copy(st,1,s-1);
    val(st1,xx);
    str(xx,st1);
    for i:=length(st1) downto 1 do
      xst:=xst+st1[i];
    val(xst,xx);
    write(xx,'%');
  end;
end.
```

---

## 作者：Evyde (赞：1)

多多运用C++ 11的新特性：

  `stoi`、`stoll`
  
  运用这两个函数，基本不需要我们考虑去零的问题。
  
  具体看比较复杂的代码：
  
```C++
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>

using namespace std;

char kindOfNum(string s) {
	/*return value:
		' ': integer
		'.': decimal
		'/': fraction
		'%': percentage 
	*/
	char returnValue= ' ';
	if(s.find('.')!= string::npos) returnValue= '.';
	else if(s.find('/')!= string::npos) returnValue= '/';
	else if(s.find('%')!= string::npos) returnValue= '%';
	return returnValue;
}

int clearLastZero(int target) {
	if(target/ 10* 10== target) target/= 10;
	return target;
}

int main() {
	string rst, str;
	char kind;
	string::size_type sz;
	getline(cin, str);
	kind= kindOfNum(str);
	
	if(kind== '%') {
		stoll(str, &sz);
		rst= str.substr(0, sz);
		reverse(rst.begin(), rst.end());
		cout<< stoll(rst)<< kind;
		return 0;
	}
	else if(kind== ' ') {
		reverse(str.begin(), str.end());
		cout<< stoll(str, &sz);
	}else {
		int last;
		reverse(str.begin(), str.end());
		last= clearLastZero(stoll(str, &sz));
		rst= str.substr(sz+ 1);
		cout<< stoll(rst)<< kind<< last;
	}
		
	return 0;
}
```
蒟蒻第一次写题解，望各位大佬多多包涵。

---

## 作者：Forgetter (赞：1)

萌新初学java，第一次写题解，发现几乎没人发java的，就发一下自己写的。
### 思路：
1. 判断输入的“字符串”属于哪一类数，然后分别调用相应的方法；
1. 有符号的字符串(. % /)利用split分割成两个字符串
1. 写一个反转字符串的方法，用字符数组交换下标。

### 注意：
1. 里面去掉多余的"0"的操作，我的方法是转换成大整形(题目好像说20位数，int就不行了)，再转成String。即"0123"->"123"。

------------

### 代码如下：
```java
import java.math.BigInteger;
import java.util.Scanner;

public class FanZhuan {
	
	public static void xiao(String a) {		//小数
		String[] b = a.split("\\.");
		System.out.print(Zhuan(b[0]));
		System.out.print(".");
		System.out.println(Zhuan(b[1]));
	}
	
	public static void fen(String a) {		//分数
		String[] b = a.split("\\/");
		System.out.print(Zhuan(b[0]));
		System.out.print("/");
		System.out.println(Zhuan(b[1]));
	}
	
	public static void baifen(String a) {	//百分数
		String[] b = a.split("\\%");
		System.out.print(Zhuan(b[0]));
		System.out.print("%");
	}
	
	public static void zheng(String a) {	//整数
		
		System.out.println(Zhuan(a));
	}
	
	public static String Zhuan(String a) {	//字符串反转
		BigInteger bi = new BigInteger(a);		//用来去掉转换前小数前面多余的0,即12.05的05——>5
		a = String.valueOf(bi);
		char[] cha1 = a.toCharArray();
		char[] cha2 = new char[cha1.length];
		for(int i=0;i<cha1.length;i++) {
			cha2[i] = cha1[cha1.length-i-1];
		}
		String b = String.valueOf(cha2);
		BigInteger bii = new BigInteger(b);		//这里用来去掉转换后多余的0，和上面一样，最好用大整形
		b = String.valueOf(bii);
		return b;
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner (System.in);
		while(sc.hasNext()) {
			String str = sc.nextLine();
			if(str.contains(".")) {					//小数
				xiao(str);
			}else if(str.contains("/")) {			//分数
				fen(str);
			}else if(str.contains("%")) {			//百分数
				baifen(str);
			}else {									//整数
				zheng(str);
			}
		}sc.close();
	}

}

```

---

## 作者：hilsinleri (赞：1)


这题的话只要将一个字符串成功分成两端，问题就解决了一半。至于反转，和真题的做法一样，但是要用字符串，用int会超范围。而且说了无负数，就不需要考虑了。

但小数的反转就有意思了。用库函数find\_first\_of("123456789")，如果没找到，就说明小数部分纯0，直接输0即可。否则就用刚刚这个库函数找到的位置开始反转。



```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<sstream>
#include<algorithm>

using namespace std;

void revprint(string x)
{
    reverse(x.begin(),x.end());
    bool sp=false;
    for(register int i=0;i<x.size();++i)
    {
        if(!sp&&x[i]=='0')
        {
            ;
        }
        else
        {
            sp=true;
            putchar(x[i]);
        }
    }
    if(!sp)
        putchar('0');
    return;
}
void revprintp(string x)
{
    int t=x.find_first_of("123456789");
    if(t==string::npos)
    {
        putchar('0');
        return;
    }
    x=x.substr(t,x.size()-t);
    reverse(x.begin(),x.end());
    bool sp=false;
    for(register int i=0;i<x.size();++i)
    {
        if(!sp&&x[i]=='0')
        {
            ;
        }
        else
        {
            sp=true;
            putchar(x[i]);
        }
    }
    if(!sp)
        putchar('0');
    return;
}

int main()
{
    string a;
    getline(cin,a);
    int sa=a.size();
    for(register int i=0;i<sa;++i)
    {
        if(a[i]=='.')
        {
            revprint(a.substr(0,i));
            putchar('.');
            revprintp(a.substr(i+1,sa-i));
            return 0;
        }
        if(a[i]=='/')
        {
            revprint(a.substr(0,i));
            putchar('/');
            revprint(a.substr(i+1,sa-i));
            return 0;
        }
        if(a[i]=='%')
        {
            revprint(a.substr(0,i));
            putchar('%');
            return 0;
        }
    }
    revprint(a);
    return 0;
}
```

---

## 作者：我家羊肉汤 (赞：1)

这题就是个坑题

说几点吧

首先很多人会too short，为什么呢？因为没有输出。

那么为什么没有输出呢？因为0！因为0！因为0！

如果只有0或者00000000000000000000000时

按照传统翻转就会，就会。。。

消失了；

所以呢，代码里就要加一个特判2333

事实上，数据真的坑得要死！！！

贴上我的代码：






```cpp
program change;
var sss:string; i:Longint;
function z(s:string):string;
var ans:string; i,len:longint;
begin
  if s='0' then exit('0');
  len:=length(s); ans:='';
  while s[len]='0' do dec(len);
  for i:=len downto 1 do ans:=ans+s[i];
  if ans='' then ans:='0';
  exit(ans);
end;
procedure dian(s:string);
var i,len,k:longint;
    ans,s1,s2:string;
begin
  len:=length(s); ans:='';
  s1:=copy(s,1,pos('.',s)-1);
  s2:=copy(s,pos('.',s)+1,len-pos('.',s));
  ans:=z(s1)+'.';
  len:=length(s2);k:=1;
  while s2[k]='0' do inc(k);
  for i:=len downto k do ans:=ans+s2[i];
  if ans[length(ans)]='.' then ans:=ans+'0';
  writeln(ans);
  halt;
end;
procedure fen(s:string);
var ans:string; po:longint;
begin
  po:=pos('/',s);
  ans:=(z(copy(s,1,po-1))+'/'+z(copy(s,po+1,length(s)-po)));
  writeln(ans);
  halt;
end;
procedure bai(s:string);
var ans:string; 
begin
  ans:=z(copy(s,1,length(s)-1))+'%';
  writeln(ans);
  halt;
end;
begin
  readln(sss);
  if pos('.',sss)<>0 then dian(sss);
  if pos('/',sss)<>0 then fen(sss);
  if pos('%',sss)<>0 then bai(sss);
  writeln(z(sss));
  while true do begin s:='' end; {防抄袭}
end.
```

---

## 作者：CallMeTewi (赞：1)

我的代码[h]很长[/h]

但是我觉得十分好懂的#滑稽

代码里有详细注释= =


```cpp

#include <iostream>
#include <string>
using namespace std;

string in,out,part1,part2;  //分别是输入的字符串，输出的字符串，和两个临时字符串;
unsigned int targ=0;  //用来存储符号的位置;
char flg='0';  //存储符号

string cut(string x,int f,int e)   //将一个字符串x从f开始到e的字符串复制出来的函数;
{
    string cache;
    for(int i=f;i<=e;i++)
    {
        cache+=x[i];
    }
    return cache;
}


string exc(string in)   //反转一个字符串;
{
    string out;int flag=0;   //flag用来表示数尾的0有没有被删除干净;
    while (in[0]=='0')
        in=cut(in,1,in.size()-1);   //删除字符串头的0(小数点后可能会出现;
    for (int i=in.size()-1;i>=0;i--)
    {
        if (in[i]=='0'&&flag==0)continue;   //删除尾0;
        if (in[i]!='0'||flag==1)
        {
         flag=1;   //标记第一个不是0的数，数中间的0将不会被删除;
         out+=in[i];   //反转剩下的字符串;
        }
    }
    if(out=="")out="0";   //防止返回空字符串;
    return out;
}

int main()
{
    getline(cin,in);
    for(unsigned int i=0;i<in.size();i++)   //来检查输入的字符串里有没有符号;
    {
        switch (in[i])
        {
         case '.' :case '/' :case '%' :
            flg=in[i];targ=i;   //用flg存储这个符号;
            break;
         default:;
        }
    }
    switch (flg)   //反转的过程;
    {
     case '.':case '/':   //小数和分数的反转策略;
         part1=cut(in,0,targ-1);   //小数点/分数线前的部分;
         part2=cut(in,targ+1,in.size()-1);  //小数点/分数线后的部分;
         out+=exc(part1)+flg+exc(part2);  //合并;
         cout<<out<<endl;   //输出;
         break;
     case '%':   //百分数的策略
         part1=cut(in,0,targ-1);  //百分号前边的部分;
         out+=exc(part1)+"%";   //加上百分号;
         cout<<out<<endl;   //输出;
         break;
     case '0':   //整数的情况;
         cout<<exc(in)<<endl;   //输出;
         break;
     default:;
    }
    return 0;
}

/*其实百分号和小数分数的策略可以合并起来，我当时没想起来*/

```
<hr>

---

## 作者：三实小范世祎 (赞：1)

```cpp
var i,j,k,m,n,q,p:longint;  
    s:string;  
procedure fz1(s:string);{这里是对于普通的整数进行处理的过程}  
begin  
  if s[1]='0' then begin write('0');exit;end;{对于答案是0的情况的处理}  
  j:=length(s);  
  while s[j]='0' do dec(j);{去0}  
  for i:=j downto 1 do{倒向输出即为答案}  
    begin  
      write(s[i]);  
    end;  
end;  
procedure fz2(s:string);{对于小数的小数部分的特殊处理}  
var i:longint;  
begin  
  j:=length(s);  
  if s[j]='0' then begin write('0');exit;end;  
  while s[j]='0' do dec(j);{去掉开头的0}  
  k:=1;  
  while s[k]='0' do inc(k);{去掉末尾的0}  
  for i:=j downto k do  
    begin  
      write(s[i]);  
    end;  
end;  
begin  
  read(s);  
  n:=length(s);  
  m:=pos('.',s);  
  if m>0 then begin{如果该数据是小数，那么处理}  
    fz1(copy(s,1,m-1));{对该小数的整数部分处理}  
    write('.');{在数据中间打出小数点}  
    fz2(copy(s,m+1,n));{对于该小数的小数部分的处理}  
    exit;{处理完后就退出}  
  end;  
  p:=pos('/',s);{以下处理大致与上同}  
  if p>0 then begin  
    fz1(copy(s,1,p-1));  
    write('/');  
    fz1(copy(s,p+1,n));  
    exit;  
  end;  
  q:=pos('%',s);  
  if q>0 then begin  
    fz1(copy(s,1,q-1));{对于百分号的数据只需要处理一个数据}  
    write('%');  
    exit;  
  end;  
  fz1(s);{如果数据既不是小数、分数也不是百分数那么就直接进行整数的处理}  
end.
```

---

## 作者：slush (赞：1)

魁拔必胜 更新时间2014-11-26 22:18 题解有问题，如果数据为012356.123540测试后会是怎么样的结果呢？


```cpp
 procedure fz1(s:string);
    begin
     { if s[1]='0' then begin write('0');exit;end;}
      j:=length(s);
      while s[j]='0' do dec(j);
      k:=1;
      while s[k]='0' do inc(k);
      for i:=j downto k do  write(s[i]);
      if j<k then write('0'); //此处增加判断
    end;
    procedure fz2(s:string);
    var i:longint;
    begin
      j:=length(s);
      {if s[j]='0' then begin write('0');exit;end;}
      while s[j]='0' do dec(j);
      k:=1;
      while s[k]='0' do inc(k);
      for i:=j downto k do write(s[i]);
      if j<k then write('0');  //此处增加判断
end;
```

---

## 作者：灬Amiya灬 (赞：0)

这道题还是很有意思的
说说我这个小弱弱的思路
先处理字符串，看是那种类型
小数点，还是\ 还是% 还是整数
接着用zt 标记
处理%和整数差不多
只不过处理%的话，要先把前面字符串截取，然后用处理整数的方法去处理
小数点和\是一样的。把他们截取两段字符串后各自处理就可以了
我写了两个函数一个getW()用来删掉前面的零
getS()用来删掉后面的零
至于为什么不一次写完，因为判断逻辑好麻烦，怕写错，这样写虽然看上去复杂一些，但其实逻辑更清晰一点，也没那么容易出错

```java
package p1553;

import java.util.Scanner;

public class Main {
	static int zt=0;
	static String c = new String();
	static String d = new String();
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		String a = new String();
		String b = new String();
		a = in.next();
		for(int i=0;i<a.length();i++) {
			if(a.charAt(i)=='%') {
				a = a.substring(0,a.length()-1);
				zt=1;
				break;
			}
			if(a.charAt(i)=='.') {
				c = a.substring(0, i);
				d = a.substring(i+1,a.length());
				zt=2;
				break;
			}
			if(a.charAt(i)=='/') {
				c = a.substring(0, i);
				d = a.substring(i+1,a.length());
				zt=3;
				break;
			}
		}
		if(zt==1) {
			a = getS(a);
			a = getW(a);
			for(int i=a.length()-1;i>=0;i--){
				b += a.charAt(i);
			}
			b+='%';
		}
		else if(zt==2) {
			c = getS(c);
			c = getW(c);
			for(int i=c.length()-1;i>=0;i--){
				b += c.charAt(i);
			}
			b+='.';
			d = getS(d);
			d = getW(d);
			for(int i=d.length()-1;i>=0;i--){
				b += d.charAt(i);
			}
		}
		else if(zt==3) {
			c = getS(c);
			c = getW(c);
			for(int i=c.length()-1;i>=0;i--){
				b += c.charAt(i);
			}
			b+='/';
			d = getS(d);
			d = getW(d);
			for(int i=d.length()-1;i>=0;i--){
				b += d.charAt(i);
			}
		}
		else {
			a=getW(a);
			a=getS(a);
			for(int i=a.length()-1;i>=0;i--){
				b += a.charAt(i);
			}
		}
		System.out.println(b);
	}
    private static String getW(String a) {
    	int q=0;
		for(int i=0;i<a.length();i++){
			if(a.charAt(i)=='0'&&i<a.length()-1){
				continue;
			}
			q=i;
			break;
		}
		return a.substring(q,a.length());
    }
	private static String getS(String a) {
		// TODO 自动生成的方法存根
		int q=0;
		for(int i=a.length()-1;i>=0;i--){
			if(a.charAt(i)=='0'&&i>0){
				continue;
			}
			q=i;
			break;
		}
		return a.substring(0,q+1);
	}

}

```

---

## 作者：BillPan (赞：0)

#小小蒻萌新第一次发题解，望大佬指出不足

**这题的关键我觉得还是在小数的小数部分的输出，因为小数部分0可以输出在非0数前面，如125.0054，而且最后一位不能有0，所以只需要输出到最后一个不为0的数字为止**

因为实力不够，，，我用了分类模拟的方法，代码显得比较长
·
```cpp
#include<bits/stdc++.h> 
using namespace std;

int main()
{
	int i,sum=0,x=0;                 //整数i用来标记小数点和除号的位置 
	string num;                      //sum用来统计不为0的字符数
	cin>>num;                        //输入数字
	for(int c=0;c<num.length();c++)
	{
		if(num[c]=='%')              //判断为百分数侯把x标记为1
			x=1;
		if(num[c]=='/')              //x标记为2则为分数 
		{
			x=2;
			i=c;
		}
		if(num[c]=='.')              //x标记为3为小数 
		{
			x=3;
			i=c;
		}
	}
	switch(x)
	{
		case 0:                               //x为0时是整数
			for(int c=num.length()-1;c>=0;c--)  //倒序输出 
				if(num[c]!='0'||sum!=0)  //判断第一个不为0的数字再输出
				{
					cout<<num[c];
					sum++;
				}
			if(sum==0)                       //所有数字均为0时
				cout<<"0";
			break; 
		case 1:                              //百分数的情况
			for(int c=num.length()-2;c>=0;c--)  //倒序输出 
				if(num[c]!='0'||sum!=0)  //判断第一个不为0的数字再输出
				{
					cout<<num[c];
					sum++;
				}
			if(sum==0)                       //所有数字均为0时
				cout<<"0";
			cout<<num[num.length()-1];       //输出百分号 
			break; 
		case 2:                              //为分数的情况
			for(int c=i-1;c>=0;c--)          //分子倒序输出 
				if(num[c]!='0'||sum!=0)  //判断第一个不为0的数字再输出
				{
					cout<<num[c];
					sum++;
				}
			if(sum==0)                       //分子全为0的情况
				cout<<"0";
			sum=0;
			cout<<num[i];                      //输出分号 
			for(int c=num.length()-1;c>i;c--)  //分母倒序输出 
				if(num[c]!='0'||sum!=0)
				{
					cout<<num[c];
					sum++;
				}
			break; 
		case 3:                                //小数的情况
			for(int c=i-1;c>=0;c--)            //倒序输出 
				if(num[c]!='0'||sum!=0)  //判断第一个不为0的数字再输出
				{
					cout<<num[c];
					sum++;
				}
			if(sum==0)
				cout<<"0";
			sum=0;
			cout<<num[i];  //小数点 
			for(int c=num.length()-1;c>i;c--)  //小数部分 
				if(num[c]!='0')
					sum++;              //统计小数点后不为0的数的个数 
			if(sum==0)                  //小数部分全为0的情况
				cout<<"0";
			else
				for(int c=num.length()-1;c>i;c--)   
				{
					if(sum==0)     //当不为0的数字全部输出后直接退出，
						break;     //因为之后的0不需要输出
					cout<<num[c];
					if(num[c]!='0')      //每输出一个不为0的数字sum减1
						sum--;
				}
			break; 
	}
	
	return 0; 
}
```


---

## 作者：tenjyun0401 (赞：0)

```cpp
#include<bits/stdc++.h> // 用于打开c++的所有库函数 
using namespace std;

char c[10005],len,t; //c为读入的数组，len为数组长度（后面有所变化），t用来存储字符串中可能出现的标点 
int pos = 0,bot = 0; //pos用来记录标点所在的位置，bot用来记录输出的尾端 

char type() //用来判断字符串中符号的类型 
{
	if (c[len-1] == '\%')
	 {
	 	len--; //百分数的情况和纯数字类似，所以len减一，作常数处理 
	 	return '\%';
	 }
	for (int i=0;i<len;i++)
	 {
	 	if (c[i] == '/')
	 	 {
	 	 	pos = i;
	 	 	return '/';
		 }
	 	if (c[i] == '.')
	 	 {
	 	 	pos = i;
	 	 	return '.';
		 }
	 }
	return '\0'; //如果没有任何符号，返回0 
}

void nao_print() //“直接输出”，正向判断是否有0 
{
	while (c[len-1] == '0' && len > 0) len--; //正向表达，如果首端有0的话len减一表示删去 
	if (len-bot == 0) //len-bot的值为0意味着这部分数值为零，直接输出0即可 
	 {
	 	printf("0");
	 	return;
	 }
	for (int i=len-1;i>=bot;i--) 
	 printf("%c",c[i]);
}

void anti_print() //“反向输出”，逆向判断是否有0 
{
	while (c[bot] == '0' && bot < len) bot++; //逆向表达，如果尾端有0的话bot加一表示删去 
	if (len-bot == 0) //同上，处理输入0的情况 
	 {
	 	printf("0");
	 	return;
	 }
	for (int i=len-1;i>=bot;i--)
	 printf("%c",c[i]);
}

void do_it() //主要运行部分 
{
	if (t == '\0' || t == '\%') //纯数字和百分数为一情况 
	 {
	 	nao_print();
	 	putchar(t); 
	 }
	int tot = len;
	len = pos;
	if (t == '/')
	 {
	 	nao_print();
	 	putchar(t);
	 	len = tot;
	 	bot = pos+1;
	 	nao_print();
	 }
	if (t == '.')
	 {
	 	nao_print();
	 	putchar(t);
	 	len = tot;
	 	bot = pos+1;
	 	anti_print();
	 }
}

int main ()
{
	scanf("%s",c);
	len = strlen(c);
	t = type();
	do_it();
	return 0;
}
```

---

## 作者：lchhhh (赞：0)

# include <stdio.h>

# include <stdlib.h>

# include <string.h>

# define Max 22

# define End putchar('\n'); break;return 0

char\* mystrrev(char\* s) //要注意这里其实是需要说明这个函数的，否则有些编译器无法编译 

{  
/\* h指向s的头部 \*/

  
    char\* h = s;      

    char\* t = s;  

    char ch;  

/\* t指向s的尾部 \*/

  
    while(\*t++){};  

    t--;    /\* 与t++抵消 \*/  

    t--;    /\* 回跳过结束符'\0' \*/  

/\* 当h和t未重合时，交换它们所指向的字符 \*/

  
```cpp
    while(h < t)  
    {  
        ch = *h;  
        *h++ = *t;    /* h向尾部移动 */  
        *t-- = ch;    /* t向头部移动 */  
    }  
    return(s);  
}  
char* itoa(int num,char*str,int radix)
```
{/\*索引表\*/
char index[]="0123456789ABCDEF";

unsigned unum;/\*中间变量\*/

int i=0,j,k;

/\*确定unum的值\*/

```cpp
if(radix==10&&num<0)/*十进制负数*/
{
unum=(unsigned)-num;
str[i++]='-';
}
else unum=(unsigned)num;/*其他情况*/
```
/\*转换\*/
```cpp
do{
str[i++]=index[unum%(unsigned)radix];
unum/=radix;
}while(unum);
str[i]='\0';
```
/\*逆序\*/
```cpp
if(str[0]=='-')k=1;/*十进制负数*/
else k=0;
char temp;
for(j=k;j<=(i-1)/2;j++)
{
temp=str[j];
str[j]=str[i-1+k-j];
str[i-1+k-j]=temp;
}
return str;
}
void Rev(char *k)
{
    int c,f=0;
    c=strlen(k);
    for(;*(k+c-1)=='0';c--)
        *(k+c-1)='\0';
    if(!c)
        *k='0';
    k=mystrrev(k);
    printf("%s",k);
}
int main()
{
    int x=0,t=1;
    unsigned long z1,z2;
    char num[Max],n0[Max],n1[Max],n2[Max];
    gets(num);
    do
        switch(num[x])
        {
            case'.': sscanf(num,"%ld.%ld",&z1,&z2);     t=2;
                     itoa(z1,n1,10); itoa(z2,n2,10); break;
            case'/': sscanf(num,"%ld/%ld",&z1,&z2);  t=3;
                     itoa(z1,n1,10); itoa(z2,n2,10); break;
            case'%': strcpy(n0,num);                 t=4;
                     n0[strlen(num)-1]='\0';
        }
    while(++x<strlen(num) && t==1);
    switch(t)
    {
        case 1: Rev(num);                        End;
        case 2: Rev(n1); putchar('.');
                printf("%s",mystrrev(n2));        End;
        case 3: Rev(n1); putchar('/'); Rev(n2); End;
        case 4: Rev(n0); putchar('%');            End;
        default:printf("结果未知。");            End;
    }
}

```

---

## 作者：Renatus (赞：0)

一次秒过,不喜勿喷

-定义了一个函数output,用于处理反转情况

-主要想法先把1,4归为一类，2,3归为另一类处理

-而小数有点特殊,小数点后**数字前后均可有零**,故又对output稍加补充

-同时又判断了是否在一个output区间内全为零,此时直接输出一个零即可

-总体来说，就是各种细节考虑+测试

```cpp
   cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<stack>
#include<string>
using namespace std;
stack<char> ans;
string line;

void output(int l,int r){
    int i=r;
    while((line[i]=='0')&&(i>=l)) i--;
    int j=l;
    while((line[j]=='0')&&(j<=r))j++;
    if(i==l-1) {
        printf("0");
        return;
    }
    for(;i>=j;i--) printf("%c",line[i]);
    return;
}

int main(){
    char ch;
    int type=1,pos=0;
    cin>>line;
    if(line[line.length()-1]=='%') type=4;
    else {
        for(int i=0;i<line.length();i++){
            if(line[i]=='.') {
                type=2;
                pos=i;
                break;    
            }
            else if(line[i]=='/'){
                type=3;
                pos=i;
                break;
            }
        }
    }
    switch(type){
        case 1:{
            output(0,line.length()-1);
            break;
        }
        case 2:{
            output(0,pos-1);
            printf(".");
            output(pos+1,line.length()-1);
            break;
        }
        case 3:{
            output(0,pos-1);
            printf("/");
            output(pos+1,line.length()-1);
            break;
        }    
        case 4:{
            output(0,line.length()-2);
            printf("%c",line[line.length()-1]);
            break;
        }    
    }
    return 0;
}
```

---


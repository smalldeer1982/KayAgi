# 计算分数

## 题目描述

Csh 被老妈关在家里做分数计算题，但显然他不愿意做这么多复杂的计算。况且在家门口还有 Xxq 在等着他去一起看电影。为了尽快地能去陪 Xxq 看电影，他把剩下的计算题交给了你，你能帮他解决问题吗？


## 说明/提示

### 数据范围及约定

对于所有测试点，输入计算式长度在 $100$ 以内，分子、分母在 $1000$ 以内。同时保证，直接从前往后直接计算分数的和或者差，然后立刻化简，这么做的中间结果不会超过 int 的范围。

注意输入的分数不一定是最简分数。


------------
2024/2/13 添加 2 组 hack 数据。

## 样例 #1

### 输入

```
2/1+1/3-1/4```

### 输出

```
25/12```

# 题解

## 作者：ggylz49 (赞：203)

## 题外话
在进入正题之前，先介绍一下 c++ 一些好用的东西（STL 是 c++ 的宝库！）。
- `__gcd(int a,int b)`：计算 $\gcd(a,b)$，也就是 $a,b$ 的最大公约数。
- 如果定义一个结构体（这里就不在详解结构体了），那么结构体变量（不是成员变量）都可以作为函数的输入值或返回值。例如定义一个结构体 `lt`：
```cpp
struct lt
{
	int a,b;
};
```
那么如下的函数可行：
```cpp
lt find(lt x)
{
	x.a=x.a+x.b;
	return x;
}
```
这两个东西会在本题中用到。
## 详解
首先定义一个结构体，表示分数。
```cpp
struct fs
{
    long long fm,fz;//开long long最保险了！
};//结构体定义后要加分号
```
然后就是一些杂七杂八的函数了。
1. `fs yf(fs a)` 对分数 $a$ 进行约分。返回一个分数。
```cpp
fs yf(fs a)
{
    long long m=__gcd(a.fm,a.fz);//求出最大公约数
    a.fm/=m;
    a.fz/=m;//分别除掉
    return a;//返回约分后的分数
}
```
2. `jia(fs a,fs b)` 计算分数 $a+b$，返回值也是分数。
```cpp
fs jia(fs x,fs y)
{
    long long z=x.fm*y.fm;//直接将分母统一（虽然不是最小公倍数）
    x.fz*=y.fm;
    y.fz*=x.fm;//互相乘得到在分母为z的情况下的分子
    x.fm=z;
    y.fm=z;//统一分母
    fs answer;//答案
    answer.fz=x.fz+y.fz;//分子相加
    answer.fm=x.fm;//分母就按原来的咯
    return yf(answer);//记得约分
}
```
例如 $\frac{\ 2 \ }{\ 4 \ }+\frac{\ 3 \ }{\ 4 \ }$，程序理解成 $\frac{\ 8 \ }{\  16 \ }+\frac{\ 12 \ }{\ 16 \ }$，约分后得到 $\frac{\ 5 \ }{\ 4 \ }$。

3. `jian(fs a,fs b)` 计算分数 $a-b$，返回值也是分数。
```cpp
fs jian(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz-y.fz;
    answer.fm=x.fm;
    return yf(answer);//就不解释了，可按照加法自行理解
}
```
4. 主函数。
```cpp
int main()
{
    fs a,b;
    char ysf;
    scanf("%lld/%lld",&a.fz,&a.fm);//输入第一个分数，后面就按 [运算符 分数] 格式读入
    cin>>ysf;//输入运算符
    while (scanf("%lld/%lld",&b.fz,&b.fm)!=EOF)//保证读入不为空
    {
        if (ysf==EOF)break;//如果输入的运算符本身为空，跳出
        else if (ysf=='+'){a=jia(a,b);}//把a赋值成a+b结果，之后输入b再运算
        else if (ysf=='-'){a=jian(a,b);}//a-b，同上
        cin>>ysf;//最后输入下一个运算符
    }
    if (a.fm<0&&a.fz>0)//如果分母乘着乘着就变成了负数
    {
        a.fm=abs(a.fm);
        a.fz-=a.fz*2;//分子变负，分母变正
    }
    if (a.fm==1)cout<<a.fz;//特判分母为1，直接输出分子
    else cout<<a.fz<<'/'<<a.fm;//不然照常输出
    return 0;
}
```
不过只能得 $\text{Unaccped} \ 100$ 分。因为第一次输入没有约分，所以如果只有 $1$ 个分数，就会输出原来的分数，就不是约分过的了。所以输入时就先约分一次，如下所示。
## code
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
struct fs
{
    long long fm,fz;
};
fs yf(fs a)
{
    long long m=__gcd(a.fm,a.fz);
    a.fm/=m;
    a.fz/=m;
    return a;
}
fs jia(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz+y.fz;
    answer.fm=x.fm;
    return yf(answer);
}
fs jian(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz-y.fz;
    answer.fm=x.fm;
    return yf(answer);//约分是个好习惯
}
int main()
{
    fs a,b;
    char ysf;
    scanf("%lld/%lld",&a.fz,&a.fm);
    a=yf(a);
    cin>>ysf;
    while (scanf("%lld/%lld",&b.fz,&b.fm)!=EOF)
    {
        if (ysf==EOF)break;
        else if (ysf=='+'){a=jia(a,b);}
        else if (ysf=='-'){a=jian(a,b);}
        cin>>ysf;
    }
    if (a.fm<0&&a.fz>0)
    {
        a.fm=abs(a.fm);
        a.fz-=a.fz*2;
    }
    if (a.fm==1)cout<<a.fz;
    else cout<<a.fz<<'/'<<a.fm;
    return 0;
}
```
## 约法三章
1. 这个是最长的题解，不要毁谤，谢谢。
2. 题解写了一天半，你若喜欢请点赞。若你抄袭不点赞，被举报有你好看。
3. 有问题欢迎指正。如果有 hack 数据，我会尽快改正！

---

## 作者：int_stl (赞：33)

今天看见一大堆题解被撤了，顺便来写一篇题解~~增加咕值~~。  

这其实是小学数学，已知：  
$$ \frac{a}{b} + \frac{c}{d} = \frac{a \times \text{lcm}(b,d) \div b + c \times \text{lcm}(b,d) \div d}{\text{lcm}(b,d)} $$

根据这个公式，我们可以用 C++ 模拟这个过程：
```cpp
int now = lcm(fm, b); //fm,b的最小公倍数
a = a * (now / b); //通分
b = now; 
fz = fz * (now / fm);
fm = now;
fz += a; //累加
```
通分后，我们还要把分子和分母同除以 $\gcd(fz,fm)$（也就是约分），避免超出长整型的数据范围。

算好后，再约分一下，看看分母是否为 $1$，如果是，那么直接输出分子；否则，如果分子为 $0$，输出 $0$ 即可；

如果上面条件都不成立，就判断分子分母的正负性。如果分子分母有一个是负，那么把符号移到最前面；否则，直接输出分子和分母。
```cpp
#include <iostream>
#include <string>
using namespace std;
#define int long long
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int lcm(int a, int b) { return a / gcd(a, b) * b; }
int sgn(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
}
signed main() {
	int fz = 0, fm = 0; 
	int a, b; char ch;
	cin >> a >> ch >> b, fz = a, fm = b;
	while (cin >> a >> ch >> b) {
		int nowb = lcm(fm, b);
		a = a * (nowb / b);
		b = nowb;
		fz = fz * (nowb / fm);
		fm = nowb;
		fz += a;
		int t = gcd(fz, fm);
		fz /= t, fm /= t;
	}
	int t = gcd(fz, fm);
	fz /= t, fm /= t;
	if (fz % fm == 0) { //或if (fm == 1)
		cout << fz / fm;
	}
	else {
		if (fz == 0) {
			cout << 0;
		}
		else {
			if (sgn(fz) == -sgn(fm)) {
				cout << "-" << abs(fz) << "/" << abs(fm);
			}
			else {
				cout << fz << "/" << fm;
			}
		}
	}
}
```

感谢 Bingxiu 提供的 hack 数据：

输入 \#1：

```
1/625+624/625+1/343+342/343+1/121+120/121+1/169+168/169+1/289+288/289+1/529+528/529+1/512+1/729
```

输出 \#1：

```
2240729/373248
```

输入 \#2：

```
2/4
```

输出 \#2：

```cpp
1/2
```

本程序已经过测试，保证能通过这些数据。


---

## 作者：lgydkkyd (赞：8)

~~这也是本蒟蒻洛谷开专栏后第一次写题解~~。这题对于学历的要求是比较低的，只要上过小学就足以应付分数的运算，我选择的方法是将这个式子分成多个分数输入，就因为输入我卡了整整六次。


------------
只需要每次输入都加入结果的分数中去，唯一要注意的是每一次加入结果后都要约分使分子与分母互质，以防溢出导致结果错误，然后就是要判断答案的合法性，防止出现分子分母都是负数等等情况，输出答案即可。

------------
# Code
```cpp
#include<bits/stdc++.h>//万能头最好力 
using namespace std;
int z,m,zans,mans=1;
char op;//没啥用 '/'
int main(){
    while(cin>>z>>op>>m){//把式子拆解为多个分数 
        zans=z*mans+m*zans,mans=m*mans;//计入结果 
        int gcd=__gcd(zans,mans);//最大限度的约分就是除以最大公约数 
		zans/=gcd,mans/=gcd;//约分
    }
	if(zans<0&&mans<0)zans=abs(zans),mans=abs(mans);//注意不能直接abs,只有都为负数时才需要转为正数 
    else if(zans>0&&mans<0)mans=abs(mans),printf("-");//分子为正数，分母为负数 
	else if(zans<0&&mans>0)zans=abs(zans),printf("-");//分子为负数，分母为正数
	if(zans==0)cout<<0;//分子为0则该分数=0
	else if(mans==1)printf("%d",zans);//分母为1即化简直接输出分子 
	else cout<<zans<<"/"<<mans;//正常输出
    return 0;//华丽结束~~~ 
}
```

---

## 作者：zhang_Jimmy (赞：6)

这道题是一道模拟题，但细节还是很多的。

首先我们要处理一下读入：可以直接 `while(cin >> f1 >> a >> f2 >> b)`，其中 f1 是加/减号，f2 是分数线，a 是分子，b 是分母。注意第一个分数要单独读入。

然后我们就要处理一下计算的过程。由~~小学五年级数学知识~~可知：分母不同的两个分数相加，要先通分。形式化的，即：

$\dfrac{a}{b} + \dfrac{c}{d} = \dfrac{a\times  \operatorname{lcm}(b,d)\div b}{\operatorname{lcm}(b,d)} + \dfrac{c\times  \operatorname{lcm}(b,d)\div d}{\operatorname{lcm}(b,d)}$

我们可以写一个函数模拟这个过程。

然后我们就要按照同分母分数的计算方法来计算了。

计算完后要约分，不然可能会爆 `int`。即：

$\dfrac{a}{b} = \dfrac{a \div \gcd(a, b)}{b\div \gcd(a, b)}$

最后计算完之后还要再约分一次，不然在只有一个分数的情况下可能会出错。

输出也要特殊处理一下（以下记答案的分母和分子分别为 $ansfm$ 和 $ansfz$）：

- 如果最终答案的分母小于 $0$，那么我们就要输出 `-ansfz/-ansfm`。
- 如果最终答案的分母等于 $1$，那么直接输出 `ansfz`。
- 否则，输出 `ansfz/ansfm`。

在这里解释一下为什么对于负数的情况只要判断一种和不用判断分子为 $0$ 的情况：

- 如果 $ansfz < 0, ansfm > 0$，根据第二种和第三种情况输出即可。
- 如果 $ansfz < 0, ansfm < 0$，根据四则运算法则（两数相除，同号得正，异号得负），直接根据第一种情况输出是可以的。
- 如果 $ansfz = 0$，因为 $\gcd(a, 0) = a$，所以在约分完成后 $ansfz = 0, ansfm = 1$，会直接进入到第二种情况。

代码如下：（**本代码可以通过目前讨论区的所有 hack 数据**）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int fm, fz, ansfm, ansfz;
char a, b; 

int lcm(int a, int b){
	return a / __gcd(a, b) * b;
}

void tongfen(){
	int t = lcm(ansfm, fm);
	int anssum = t / ansfm;
	int sum = t / fm;
	ansfz *= anssum;
	ansfm *= anssum;
	fz *= sum;
	fm *= sum;
}

void yuefen(){
	int t = __gcd(ansfz, ansfm);
	ansfz /= t;
	ansfm /= t;
}

signed main(){
	cin >> ansfz >> b >> ansfm;
//	cout << ansfz << b << ansfm;
	while(cin >> a >> fz >> b >> fm){
//		cout << a << fz << b << fm;
//		cout << 1 << endl;
		tongfen();
		if(a == '+') ansfz += fz;
		else ansfz -= fz;
		yuefen();
	}
	yuefen();
	if(ansfm < 0) cout << -ansfz << "/" << -ansfm;
	else if(ansfm != 1) cout << ansfz << "/" << ansfm;
	else cout << ansfz;
	return 0;
}

```


---

## 作者：LG086 (赞：6)

### 分析

分数加减法，注意到题目中的关键语句：“同时保证，直接从前往后直接计算分数的和或者差，然后立刻化简，这么做的中间结果不会超过 int 的范围”。

所以暴力通分加减完就约分。

------------
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char ch1,ch2;//分别代表加减号和除号
int x,y;//输入的分子分母
int ans_a,ans_b = 1,gcd;//答案的分子分母以及最大公约数
signed main(){
    cin>>x>>ch2>>y;//先输入第一个分数
    ans_a=x,ans_b=y;//分子分母
    while(cin>>ch1>>x>>ch2>>y){//输入
        if(ch1=='-')x=-x;//判负数
        ans_a=x*ans_b+y*ans_a,ans_b*=y;//通分
        gcd=__gcd(ans_a,ans_b),ans_a/=gcd,ans_b/=gcd;//约分
    }
    gcd=__gcd(ans_a,ans_b),ans_a/=gcd,ans_b/=gcd;
    if(ans_b<0)ans_a=-ans_a,ans_b=-ans_b;//分母为负
    ((ans_b==1)?(cout<<ans_a):(cout<<ans_a<<"/"<<ans_b));
}
```

---

## 作者：封禁用户 (赞：5)

这题细节还挺多的。

本题可以直接依次读入并将读入的分数相加（减去一个分数可转化为加上该分数的相反数）。

由于 int 可以带符号读入，所以无需注意符号，直接全部相加即可。

我们通分可得：$\dfrac ab+\dfrac cd=\dfrac{ad+bc}{bd}$。

注意要边计算边约分，否则可能溢出。

最后要处理一下符号。

输出时注意：如果分子为 $0$，直接输出 $0$；如果分母为 $1$，则不用输出分母。

代码是目前题解区里最短的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d=1;//注意要给 d 赋值
int main(){
    while(~scanf("%d/%d",&a,&b)){//读入
        c=a*d+b*c,d=b*d;//相加，a/b+c/d=(a*d+b*c)/(b*d)
        int g=__gcd(c,d);c/=g,d/=g;//约分
    }if(c<0&&d<0)c=-c,d=-d;//分子分母均为负
    else if(c<0&&d>0)c=-c,putchar('-');//只有分子为负
	else if(c>0&&d<0)d=-d,putchar('-');//只有分母为负
	if(!c)puts("0");//分子为 0
	else if(d==1)cout<<c;//分母为 1
	else cout<<c<<'/'<<d;//无特殊情况
    return 0;
}
```

---

## 作者：LionBlaze (赞：4)

这题没那么难，但是有一堆细节。

# 公式

小学五年级下学期数学第一讲：**异分母分数加减法要先通分**。

所以：

$$ \begin{aligned}\frac{a}{b} \pm \frac{c}{d} &= \frac{ad}{bd} \pm \frac{bc}{bd} \\
&= \frac{ad \pm bc}{bd} \end{aligned}$$

# 细节

- 输入的时候不要用 `scanf("%c%d/%d");`。
- 最大公因数计算需要加绝对值，不然会被卡：`-1/2+1/3`。
- 第一个数也要约分：`2/4`。
- 答案如果是整数不用输出 `/1`：`1/2+1/2`。
- 要实时约分，不然会[爆](https://www.luogu.com.cn/discuss/774452)。

# 代码

```cpp
#include <cstdio>
#include <cmath>

using namespace std;

long long gcd(long long x, long long y)
{
    if(y == 0) return abs(x);
    return gcd(y, x%y);
}

int main()
{
    long long a, b, c, d; //a/b c/d
    scanf("%lld/%lld", &c, &d);
    //约分：
    long long gdd = gcd(c, d);
    c/=gdd;
    d/=gdd;
    while(scanf("%lld/%lld", &a, &b) != EOF) //技巧：和P2788类似
    {
        if(op == '-') a = -a;
        // 计算：
        c = c*b + a*d;
        d = b*d;
        //约分：
        gdd = gcd(c, d);
        c/=gdd;
        d/=gdd;
    }
    printf("%lld", c);
    if(d != 1) printf("/%lld", d); //如果是整数
    puts("");
    return 0;
}
```

---

## 作者：ecxjs (赞：3)

首先我们回顾小学数学：

$\frac{a}{b}±\frac{c}{d}=\frac{ad±bc}{bd}$

我们用用一个变量来表示分母的最小公倍数，分母分子变输入边计算。

这里给出 $\text{lcm}$ 函数的算法：

$\text{gcd}$ 函数 c++ 自带 `__gcd`，$\text{lcm}$ 的求法就是 $\frac{a×b}{\text{gcd}(a,b)}$。

注意最大公约数计算要加绝对值，如果计算结果为整数不需要输出结尾的 `/1`。

代码不难实现，这里不提供。

---

## 作者：banglee (赞：3)

# [P1572] 计算分数 题解
[题目传送门](https://www.luogu.com.cn/problem/solution/P1572)

# 前置知识
要求一个数的最大公约数，可以用辗转相除法，代码如下：
```
int a,b,r;
cin>>a>>b;
r=a%b;
while(r!=0)
{
	a=b;
	b=r;
	r=a%b;
}
```
当然，也可以用递归函数来实现，这里就不放代码了。

补充一点，C++自带一个求最大公约数的函数，函数形式是 ```__gcd(x,y)```。

那怎么求最小公倍数呢？

众所周知：
$$\operatorname{lcm}(x,y) = \frac{x \times y}{\gcd(x,y)}$$

根据这个公式，我们便可以求出最小公倍数。
# 正文
首先开始输入，将所有的分数保存起来。

计算式中只包含数字、```+```、```-```、```/```。其中 ```/``` 为分数线，分数线左边为分子，右边为分母。输入数据保证不会出现繁分数。如果输入计算式的第一项为正，不会有前缀 ```+``` 号；若为负，会有前缀 ```-``` 号。

正如题目所说，我们在做题的时候要注意好这几点。

然后对将所有的分数通分，通分的时候要立即化简，负号要在分子上面。

综上所述，代码不难实现，这里就不贴代码了。

---

## 作者：Acoipp (赞：3)

现有的题解都被 Hack 了，来补发一篇。

首先考虑如何输入分数并且进行处理，我们可以将输入的表达式按照字符串的格式进行处理。

首先从头开始读字符，每读到一个分数就记录一下。

一个分数一定是以下面的格式出现：

- 分子要么带 `+` 号，要么带 `-` 号，或者直接以数字开头。

- 分母要么带 `+` 号，要么带 `-` 号，或者直接以数字开头。

- 分子分母之间有一个 `/` 号也要进行读入。

于是用字符串的基本操作处理即可。

然后对于读入的分数进行通分，通分的时候要注意：

- `__gcd(a,b)` 一定要传入正整数，否则可能返回负数。

- 每个分数读入进来就立刻化简，并且保证负号在分子上面。

- 通分使用 `lcm` 即可，使用之后也必须立即化简，负号也要在分子上面。

- 最后如果分母是 $1$ 输出分子即可。

综上所述，代码不难实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s;
ll i,j,k,ans1,ans2,zf1,res1,zf2,res2,lcm,gcd;
int main(){
	cin>>s;
	for(i=0;i<s.size();){
		zf1 = 1,zf2 = 1,res1 = 0,res2 = 0;
		for(j=i;j<s.size();j++){
			if(s[j]=='+') zf1=1;
			if(s[j]=='-') zf1=-1;
			if('0'<=s[j]&&s[j]<='9') res1=res1*10+s[j]-'0';
			if(s[j]=='/') break;
		}
		j++;
		if(s[j]=='+') zf2=1,j++;
		if(s[j]=='-') zf2=-1,j++;
		for(;j<s.size();j++){
			if('0'<=s[j]&&s[j]<='9') res2=res2*10+s[j]-'0';
			if(s[j]=='-'||s[j]=='+') break;
		}
		res1 = res1*zf1,res2 = res2*zf2;
		if(res2<0) res2=-res2,res1=-res1;
		gcd = __gcd(abs(res1),abs(res2)),res1 /= gcd,res2 /= gcd;
		if(!ans2){
			ans1=res1,ans2=res2;
			i=j;
			continue;
		}
		lcm = res2*ans2/__gcd(abs(res2),abs(ans2));
		res1 *= (lcm/res2),ans1 *= (lcm/ans2);
		ans2 = lcm,ans1 += res1;
		if(ans2<0) ans1=-ans1,ans2=-ans2;
		gcd = __gcd(abs(ans1),abs(ans2)),ans1 /= gcd,ans2 /= gcd;
		i=j;
	}
	if(ans2!=1) cout<<ans1<<"/"<<ans2<<endl;
	else cout<<ans1<<endl;
	return 0;
}
```

---

## 作者：luogu10086 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P1572)



### PART 1

整体思路：

判断是否是数字字符。  
用上 `cnt` 分辨分子和分母再用上 `flag` 判断正负数。



一边算一边通分约分，~~以免爆了~~。  
若两个分数分母不同则通分，若同分母则直接分子相加。

加减运算核心代码：

```cpp
for(int i = 0;i < top-1;i ++){
    int a1,b1;
    if(a[i].y==a[i+1].y){
        a1=a[i].x+a[i+1].x;
        b1=a[i].y;
    }else{
        b1=a[i].y*a[i+1].y;
        a1=a[i].x*a[i+1].y+a[i+1].x*a[i].y;
    }
    int gcd=__gcd(a1,b1);
    a1/=gcd,b1/=gcd;
    a[i+1].x=a1,a[i+1].y=b1;
}
ans_a=a[top-1].x,ans_b=a[top-1].y;
```



------------

### PART 2

代码实现：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
string s;
struct data{
    int x,y;//分子分母
}a[10000];
int top=0,ans_a=0,ans_b=1;
signed main(){
    cin>>s;
    int cnt=0;
    for(int i = 0;i < s.size();i ++){
        if(s[i]=='/')cnt++;
        int flag = 1;//初始化为正数
        if(s[i]=='+')
        flag=1,i++;//正数
        if(s[i]=='-')
        flag=-1,i++;//负数
        if(s[i]>='0'&&s[i]<='9'){
            if(cnt%2==1){//分母
                while(s[i]>='0'&&s[i]<='9')
                    a[top].y=a[top].y*10+s[i]-'0',i++;
                a[top].y*=flag;
                top++,cnt=0;
            }else{//分子
                while(s[i]>='0'&&s[i]<='9')
                    a[top].x=a[top].x*10+s[i]-'0',i++;
                a[top].x*=flag;
            }
            i--;
        }
    }
    for(int i = 0;i < top-1;i ++){//依次计算
        int a1,b1;
        if(a[i].y==a[i+1].y){//同分母
            a1=a[i].x+a[i+1].x;
            b1=a[i].y;
        }else{//异分母
            b1=a[i].y*a[i+1].y;
            a1=a[i].x*a[i+1].y+a[i+1].x*a[i].y;
        }
        int gcd=__gcd(a1,b1);
        a1/=gcd,b1/=gcd;//约分
        a[i+1].x=a1,a[i+1].y=b1;
    }
    ans_a=a[top-1].x,ans_b=a[top-1].y;
    if(ans_a==0){//分子为零
        cout<<0;
        return 0;
    }
    if(ans_b<0)//分母为负
    ans_a=-ans_a,ans_b=-ans_b;
    int gcd=__gcd(abs(ans_b),abs(ans_a));
    if(ans_b/gcd==1){//分母为一
        cout<<ans_a/gcd;
        return 0;
    }
    cout<<ans_a/gcd<<"/"<<ans_b/gcd;
}
```

---


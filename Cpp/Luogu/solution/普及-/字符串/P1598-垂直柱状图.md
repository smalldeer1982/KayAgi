# 垂直柱状图

## 题目描述

写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 $100$ 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。


## 说明/提示

每行输出后面不允许出现多余的空格。


## 样例 #1

### 输入

```
THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.
THIS IS AN EXAMPLE TO TEST FOR YOUR
HISTOGRAM PROGRAM.
HELLO!
```

### 输出

```
                            *
                            *
        *                   *
        *                   *     *   *
        *                   *     *   *
*       *     *             *     *   *
*       *     * *     * *   *     * * *
*       *   * * *     * *   * *   * * * *
*     * * * * * *     * * * * *   * * * *     * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
```

# 题解

## 作者：lili_flyingcutter (赞：358)

#模拟加字符串搞定

##上代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int ff[26];//定义计数数组
int main()
{
    int i,j,n,maxn=0;char a[81];
    for(i=0;i<4;i++)
    {
        gets(a);//gets读入
        n=strlen(a);
        for(j=0;j<n;j++)if(a[j]>='A'&&a[j]<='Z')ff[a[j]-'A']++;//统计字符出现次数
    }
    for(i=0;i<26;i++)maxn=max(maxn,ff[i]);//最多次数（最高柱状图）
    for(i=maxn;i>0;i--){
    for(j=0;j<26;j++)
    if(ff[j]>=i)printf("* ");else printf("  ");//模拟，是可以输出的就输出*，否则跳过
    printf("\n");}//换行
    for(i=0;i<26;i++)printf("%c ",i+'A');//输出a~z
}
```

---

## 作者：飞翔 (赞：316)

[h1 ]题解

我们可以用类似桶排序的方法，先记录每个字符出现的次数，再暴力双重循环，把\*放在数组里输出。

为了大家方便“抄”我的代码不括起来。

```cpp
var
  i,j,k:integer;
  a:array['A'..'Z']of integer;
  s:string;
  c:char;
begin
  for i:=1 to 4 do
  begin
    readln(s);
    for j:=1 to length(s) do
      if s[j] in ['A'..'Z'] then inc(a[s[j]]);
  end;
  for c:='A' to 'Z' do
    if a[c]>k then k:=a[c];
  for i:=k downto 1 do
  begin
    for c:='A' to 'Z' do
      if a[c]>=i then write('* ') else write('  ');
    writeln;
  end;
  for c:='A' to 'Z' do write(c,' ');
end.
抄我的代码的童鞋，给个赞吧！
```

---

## 作者：GPNU_moko (赞：190)

本蒟蒻分享个最low的方法吧。。看你们的题解都感觉很不适合新手，我感觉我这个代码估计是最弱智的写法了吧。。。


------------
```c
#include <stdio.h>
#include <string.h>

int main(){
    char tmp;//暂时用来读取字符
    int word[26]={0};//存储每个字母出现的次数
    while(scanf("%c",&tmp)!=EOF){
        switch(tmp){
            case 'A':word[0]++;break;
            case 'B':word[1]++;break;
            case 'C':word[2]++;break;
            case 'D':word[3]++;break;
            case 'E':word[4]++;break;
            case 'F':word[5]++;break;
            case 'G':word[6]++;break;
            case 'H':word[7]++;break;
            case 'I':word[8]++;break;
            case 'J':word[9]++;break;
            case 'K':word[10]++;break;
            case 'L':word[11]++;break;
            case 'M':word[12]++;break;
            case 'N':word[13]++;break;
            case 'O':word[14]++;break;
            case 'P':word[15]++;break;
            case 'Q':word[16]++;break;
            case 'R':word[17]++;break;
            case 'S':word[18]++;break;
            case 'T':word[19]++;break;
            case 'U':word[20]++;break;
            case 'V':word[21]++;break;
            case 'W':word[22]++;break;
            case 'X':word[23]++;break;
            case 'Y':word[24]++;break;
            case 'Z':word[25]++;break;
        }
    }
    for(int i = 0;i<=405;i++){
        int flag = 0,max=0,end=0;//flag标识是否还有星号要输出，0是默认没有了
        for(int j = 0;j<26;j++){//查找当前出现次数最多的字母
            if(word[j]>=max){
                max=word[j];//把出现的次数给max
                end=j;
                if(max!=0){flag=1;}//如果max！=0则说明仍有星号待输出
            }
        }
        if(flag==0){//结束时输出
            printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
            break;//退出循环
        }
        for(int j = 0;j<=end;j++){
            if(word[j]==max){//输出此时和最大次数相同的字母星号
                printf("%s%c",j==0?"":" ",'*');
                word[j]--;
            }
            else{printf("%s%s",j==0?"":" "," ");}
        }
        printf("\n");
    }
    return 0;
}
```


---

## 作者：WilliamPen (赞：64)

本蒟蒻才不会说那些很奇怪很奇怪的东西呢。。

其实这道题很简单，就是注意细节就可以了，一路扫过去，把所有单词出现的次数记录下来，然后模拟一个输出。

输出其实最麻烦。

主要思路，求最大的，然后从底下或者最上面扫，当a-z中有字母个数达到现在已所指的数目，就输出，否则就输出空格。

还有件很重要的是，别输出多余的空格了，注意理解。

以下代码，严禁抄袭

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char arc[80];int list[26];
int main(){
    int i,j,k,l,maxn=0,m,n,z,f;
    for(i=1;i<=4;++i)
    {
        gets(arc);
        l=strlen(arc);
        for(j=0;j<l;++j)
        {            
            if(arc[j]>='A'&&arc[j]<='Z')
            list[arc[j]-'A']++;            
        }
    }
    for(k=0;k<26;++k){
        if(list[k]>maxn) 
        maxn=list[k];
    }
    for (;maxn;maxn--)
    {
        for(f='Z';f>='A';f--){
            if(f!=' ') break;}
        for (k='A';k<='Z';k++){
        if(maxn<=list[k-65]) cout<<"* ";
        else cout<<"  ";
        }
        cout<<endl;
    }
    for (k='A';k<='Z';k++) cout<<char(k)<<' ';//输出
    for    (;maxn;maxn--){
        k='A';
        while(k>='Z'){
            if(k>=f) getchar();
            ++k;
        }
    }
    return 0;
}

```

---

## 作者：lhh619899573 (赞：61)

没什么人用java做，那我就发下代码哈！

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
    	Scanner in = new Scanner(System.in);
        int s[] = new int[26]; // 记录26个字母的个数
        String str ; // 存储当前一行的字符串
        char a; // 存储当前字符串的单个字符
        // 一共有4行数据
        for(int i=0;i<=3;i++) {
        	str = in.nextLine();
        	for(int j = 0;j<str.length();j++) {
        		a = str.charAt(j);
//        		System.out.print(a);
        		if(a>='A' && a <= 'Z') {
        			s[a-'A']++; // 记录A-Z的字符的个数
        		}
        	}
//        	System.out.println(str.length());
        }
        // 因为要处理结果字符串的高度，要找到出现字符中的最大值
        int max=0;
        for(int i=0;i<=25;i++) {
        	if(s[i]>max) {
        		max = s[i];
        	}
//        	System.out.printf("%d ",s[i]);
        }
//        System.out.println();
        // 处理输出的字符
        for(int i=max;i>=1;i--) { // 一共有max行（除了字母）
        	for(int j =0; j<=25;j++) { // 一共有26个字母
        		if(s[j]==i) {  // 如果找到当前字符等于i,记录个数减1
        			s[j]--;
        			System.out.print("* ");
        		}else
        			System.out.print("  ");
        	}
        	System.out.println(); // 记得换行
        }
        System.out.print("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
    }
}
```

冲鸭！

---

## 作者：zhouxuanbo (赞：49)

 **思路**
 
这是一道很简单的水题，只是把统计出来的数字用一个数组保存下来后，空的地方用空格替代，最后输出即可。

**代码**
```cpp
#include<iostream>
using namespace std;
string s1,s2,s3,s4;
int maxx,a[30];
char b[110][30];//最后输出的数组。
int main(){
    getline(cin,s1);
    getline(cin,s2);
    getline(cin,s3);
    getline(cin,s4);
    //读入数据
    for(int i=0;i<=s1.size();i++){
        if(s1[i]>='A'&&s1[i]<='Z'){
            a[s1[i]-'A'+1]++;
        }
    }
    for(int i=0;i<=s2.size();i++){
        if(s2[i]>='A'&&s2[i]<='Z'){
            a[s2[i]-'A'+1]++;
        }
    }
    for(int i=0;i<=s3.size();i++){
        if(s3[i]>='A'&&s3[i]<='Z'){
            a[s3[i]-'A'+1]++;
        }
    }
    for(int i=0;i<=s4.size();i++){
        if(s4[i]>='A'&&s4[i]<='Z'){
            a[s4[i]-'A'+1]++;
        }
    }
    //统计字母
    for(int i=1;i<=26;i++){
        maxx=max(maxx,a[i]);
    }
    //求最高的高度
    for(int i=1;i<=26;i++){
        for(int j=maxx;j>=maxx-a[i]+1;j--){
            b[j][i]='*';
        }
        for(int j=maxx-a[i];j>=1;j--) b[j][i]=' ';
        b[maxx+1][i]=i+'A'-1;
    }//形成最后输出的数组
    for(int i=1;i<=maxx+1;i++){
        for(int j=1;j<=51;j++){
            if(j%2==0){
                cout<<' ';
                continue;
            }
            cout<<b[i][j/2+1];
        }
        cout<<endl;
    }//输出
    return 0;
}
```

---

## 作者：传说饭 (赞：33)

刚学map,看到这题终于可以用map了，就给个map解法。不懂红黑树原理能用用红黑树也是很激动的！！！
```
#include <iostream>
#include <map>
using namespace std;

map<char, int> m;
char c;

int main()
{	
	while (cin >> c)
		if (c >= 'A' && c <= 'Z')
			m[c]++;
	int Max = -1;
	for (auto i : m)
		if (i.second > Max)
			Max = i.second;//取直方图高度
	for (int i = 0; i < Max; i++)
	{
		for (int j = 0; j < 26; j++)
			if (i >= Max - m[j + 'A'])//确保底在下面
				cout << "* ";
			else
				cout << "  ";
		cout << endl;
	}
	for (auto i : m)
		cout << i.first << " ";
	return 0;
}

```

---

## 作者：pqy000 (赞：31)

### 题目P1598的题解

通过本题目能够熟悉string字符串的相关操作，包括字符串的STL函数，字符串的遍历以及字符串输入三部分来说明

#### STL中字符串操作
- ```std::string::reverse()``` 用于翻转模版，需要提供首尾迭代器作为参数，使用实例:```reverse(s.begin(),s.end())```
- ```std::string::erase()``` 用于删除区间的字符片段，传入两个迭代器l与r，用于删除区间$[l,r)$的范围内的字符。使用实例：```s.erase(s.end()-5, s.end())```
- ```std::string::susbstr()``` 用于提取字符串，使用的区间范围同样是$[l,r)$的，使用例子:```s.substr(s.find('\')+1)``` 提示：其中一个参数表示，从此处到字符串结尾。
- ```std::string:find()```用于查找子字符串在母串中的第一个出现的位置，并返回一个int型的位置，使用例子：```s.find(subs, beta+1)```，表示从位置beta继续向后寻找子串，并返回找到的第一个子串的位置，另外若无法找到时，采用```string::npos```作为查找失败的结果，若判断使用$>=0$无法成功判断，举例:

```
	- 错误方法
    if(s.find('\') >= 0) {
    	//若查找成功
        ...
    }
    //该方法在判断失败时也会进入
    
    - 正确方法
    if(s.find('\') != string::npos) {
    	//若查找成功
        ...
    }
    //该方法能够成功判断

```

#### 字符串的遍历
同时在使用stl时，通过```for(auto i:s)```，可直接遍历字符串中的各个字符，比如：
```
for(auto i:s):
	if(i == '\'):
        ....
```
此处可对字符串中每个字符依次进行操作。

#### 字符串的输入

```
  string s;
  char c[1000];
  
  getline(cin, s);     //无警告安全
  gets(s);             //可能会有警告
  (int)s.size()        //表示字符串大小
  
  scanf("%s", c);      //字符型数组输入
  (int)strlen(c);      //获得字符型输入长度
  
  stringstream ss(s);
  s >> iA >> B;        //按照空格来分割每行的输入
                       //需要#include<sstream>
                       
   while(getline(cin, line)) {	
		if(line.size() == 0) { break; }
		stringstream ss(line);
		ss >> inputA >> inputB;
		dict.insert(map<string, string> :: value_type(inputB, inputA));
	}
  
  //当空行时结束输入
```

#### 题目代码

```
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;

string s;
string reverse_head(string s) {
    int zeroCount = 0;
    reverse(s.begin(), s.end());
    
    for(auto i:s) {
        if(i == '0') { zeroCount++; }
        else break;
    }
    s.erase(s.begin(), s.begin() + zeroCount);
    return (s == "") ? "0" : s;
}

string reverse_tail(string s) {
    int zeroCount = 0;
    reverse(s.begin(), s.end());
    int cnt = (int)s.size();
    for(int i = cnt-1; i >= 0; i--) {
        if(s[i] == '0') zeroCount++;
        else break;
    }
    s.erase(s.end() - zeroCount, s.end());
    return (s == "") ? "0" : s;
}

int main() {
    getline(cin, s);
    int cnt = (int)s.size();
    string temp1, temp2;
    if(s[cnt - 1] == '%') {
        temp1 = s.substr(0, cnt - 1);
        cout << reverse_head(temp1) << "%" << endl;
        return 0;
    } else if(s.find('/') != string::npos) {
        int pos1 = (int)s.find('/');
        temp1 = s.substr(0, pos1);
        temp2 = s.substr(pos1 + 1);
        temp1 = reverse_head(temp1);
        temp2 = reverse_tail(temp2);
        cout << temp1 << "/" << temp2 << endl;
        return 0;
    } else if(s.find('.') != string::npos) {
        int pos2 = (int)s.find('.');
        temp1 = s.substr(0, pos2);
        temp2 = s.substr(pos2 + 1);
        temp1 = reverse_head(temp1);
        temp2 = reverse_tail(temp2);
        cout << temp1 << "." << temp2 << endl;
        return 0;
    }
    cout << reverse_head(s) << endl;
    
    return 0;
}

```

---

## 作者：Corrine (赞：17)

本弱驹代码，大神们见笑了！

本题用字符串做就行了

再加上个桶排

最后输出

```cpp
#include<cstdio>
#include<cstring>//头文件，不用解释了
char a[50][73];//因为是多个字符串，用一个二维数组更方便
int f[100];//桶排的“桶”
int ans=0;//ans存最多出现的字符，以便输出
int main()//主程序
{
    for(int i=1;i<=4;i++)//输入，有4行
    {
        gets(a[i]+1);//输入字符串
 int n=strlen(a[i]+1);//读出字符串的长度
        for(int j=1;j<=n;j++)
        {
            f[a[i][j]-'A']++;//桶排的累加
        }
    }
    for(int i='A';i<='Z';i++)
    {
        if(f[i-'A']>ans) ans=f[i-'A'];//求出桶中的最大值
    }
    for(int i=ans;i>=1;i--)//从最上面开始
    {
        for(int j='A';j<='Z';j++)
        {
            if(f[j-'A']>=i) printf("*");//逐一判断，够不够i个，够，就输出‘*’
            else printf(" ");//不够，就跳过
            printf(" ");//空格，隔开‘*’号
        }
        printf("\n");换行
    }
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");最后把对应的字符输出
    return 0;//程序结束
}
```

---

## 作者：gracelv (赞：16)

/\*
【注意】本题的两种打印法

第1种：26个字母对应的2列全打印， 打印“\* ”（1星1空）或“  ”（2空）；

第2种：找到每行最后1个星，使该星号后的空格都不打印

均试过了，提交都为80分，最后一个测试点，都不能通过


真正坑点：把存储4行输入字符的数组，开设大一点，以上的两种打印法都可以通过（与Z后面有无空格也无关系）

\*/


    
        
    
    
    
        
```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    char a[4][100];//最后一个测试点异常，数组开大点就过了 
    int i, j, t, letter[26]={0}, max, len;
    memset(a, 0, sizeof(char)*300);
    for(i=0; i<4; i++)//读取4行字符 
        gets(a[i]);
    //统计各大写字母出现的次数到letter数组中 
    for(i=0; i<4; i++)
    {
        len = strlen(a[i]);
        for(j=0; j<len; j++)
            if(a[i][j]>='A' &&a[i][j]<='Z')
            {
                t=a[i][j]-'A'; 
                letter[t]++;
            }    
    }
    //字母中最高的出现次数（即找出柱状图的峰顶） 
    max = 0;
    for(i=0; i<26; i++)
        if(max<letter[i]) max=letter[i];
    //打印柱状图，根据max确定整个图的最高行数 
    for(j=max; j>=1; j--)
    {
        for(i=0; i<26; i++)
        {
            if(letter[i]>=j) 
                printf("* ");//1个星+1个空格 
            else
                printf("  ");//2个空格 
        }
        printf("\n");
    }
    for(i=0; i<26; i++)//打印底部的26个字母
        printf("%c ", 'A'+i);
    return 0;
}

```

---

## 作者：ILibra (赞：6)

[h1]本题要点：

1.字母出现几次就打印几个星

2.\*与\*之间、字母与字母之间有空格，最后一个\*与Z后无空格

3.一共输入了4行字符串而不是一行[/h1]

[codec]


    
    
```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string a,b,c,d;
    int e[27];
    //记录字母出现次数，初始为0
    for(int i=0;i<26;i++){
        e[i]=0;
    }
    getline(cin, a, '\n');
    getline(cin, b, '\n');
    getline(cin, c, '\n');
    getline(cin, d, '\n');
    for(long i=0;i<a.length();i++){
        for(int j=0;j<=26;j++){
            if(a[i]-65==j){
                e[j]++;
            }
        }
    }
    for(long i=0;i<b.length();i++){
        for(int j=0;j<=26;j++){
            if(b[i]-65==j){
                e[j]++;
            }
        }
    }
    for(long i=0;i<c.length();i++){
        for(int j=0;j<=26;j++){
            if(c[i]-65==j){
                e[j]++;
            }
        }
    }
    for(long i=0;i<d.length();i++){
        for(int j=0;j<=26;j++){
            if(d[i]-65==j){
                e[j]++;
            }
        }
    }
    //次数记录完毕
    int max=0;
    //找到出现次数最多的字母，以其出现次数为基础
    for(int i=0;i<26;i++){
        if(max<e[i]){
            max=e[i];
        }
    }
    //大于等于当前次数输出*，否则输出空格
    for(int i=max;i>0;i--){
        for(int j=0;j<25;j++){
            if(e[j]>=i){
                cout<<"*"<<" ";
            }else{
                cout<<" "<<" ";
            }
        }
        //末尾不能有空格，所以单独抽出来
        if(e[25]>=i){
            cout<<"*";
        }
        else{
            cout<<" ";
        }
        cout<<endl;
    }
    cout<<"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z";
    return 0;
}
[/codec]
```

---

## 作者：Komorebi_shine (赞：6)

大神们都是那么做，一维数组我想不出来，此方法略显暴力：

存一个二维布尔数组b，c用于b的指针，来判断b数组到哪儿了。如果频率加一，b数组第x列就多一个标记。输出时再扫描，逢标记输出。（别忘了输出字母和空格！）

```cpp
var
 s:string;
 b:array[1..50,1..26]of boolean;
 c:array[1..26]of integer;
 i,j,a:integer;
begin
 for i:=1 to 4 do
  begin
   readln(s);
   for j:=1 to length(s) do
    if (s[j]>='A')and(s[j]<='Z') then inc(c[ord(s[j])-64]);
  end;
 a:=0;
 for i:=1 to 26 do
  begin
   for j:=1 to c[i] do b[j,i]:=true;
   if c[i]>a then a:=c[i];
  end;
 for i:=a downto 1 do
  begin
   for j:=1 to 26 do
    if b[i,j] then  write('* ') else write('  ');
   writeln;
  end;
 for i:=1 to 26 do
  write(chr(i+64),' ');
end.
```

---

## 作者：MedalPluS (赞：5)

这题灰常的简单，不要被题目的表面所迷糊

实际上就是统计然后放到数组暴力输出，代码30行不到



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cstdlib>
using namespace std;
char c;
int t[26],i,j,maxx;
int main(){
    while(~scanf("%c",&c))
        if(c>='A' && c<='Z')
          t[c-'A']++;
    for(i=0;i<=25;i++)
      if(t[i]>maxx)
        maxx=t[i];
    for(i=maxx;i>=1;i--){
        for(j=0;j<=25;j++)
          if(t[j]==i)cout<<"* ",t[j]--;
          else cout<<"  ";
        cout<<endl;
    }
    for(i=0;i<26;i++)
      cout<<(char)(i+'A')<<" ";
    return 0;
}

```

---

## 作者：ROOToj (赞：3)

本来用getchar一个个读结果超时于是用了getline，，附AC代码：


```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<string>
using namespace std;
int main() {
    int hm[100];
    memset(hm, 0, sizeof(hm));
    char c;
    for(int i = 0; i < 4; i++) {
        /*while((c = getchar()) != '\n')
            if(isalpha(c)) hm[c]++;*/
        string s;
        s.clear();
        getline(cin, s);
        for(int j = 0; j < s.length(); j++) if(isalpha(s[j])) hm[s[j]]++;
    }
    int max = 0;
    for(int i = 'A'; i <= 'Z'; i++)
        if(hm[i] > max) max = hm[i];
    for(int i = max; i >= 1; i--) {
        for(int j = 'A'; j < 'Z'; j++)
            if(hm[j] < i) printf("  ");
            else printf("* ");
        if(hm['Z'] < i) putchar(' ');
        else putchar('*');
        putchar('\n');
    }
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n");
    return 0;
}

```

---

## 作者：AndyToPro (赞：3)

因为最近在看numpy模块，就用了
相当于c++的数组
也算是一种解题方法
附上代码：
```python
import numpy as np
def addalpha(s):        # 记录每个字母出现次数
    for i in s:
        if i.isupper():
            up[ord(i)-65] += 1

a,b,c,d = input(),input(),input(),input()
bar = np.zeros((26,400),dtype=np.int)       # 用二维数组保存图形，初始化为0，0表示空格，1表示星号
up = [0 for i in range(26)]     # 记录每个字母出现次数的列表
addalpha(a)
addalpha(b)
addalpha(c)
addalpha(d)
# print(up)
maxcol = max(up)        # 记录最长一列
for i in range(26):     # 记录星号位置
    for j in range(up[i]):
        bar[i][j] = 1
# print(bar)
for j in range(maxcol-1,-1,-1):     # 打印图形
    for i in range(26):
        if bar[i][j] == 0:
            print(" ",end=" ")      # 切记每列有空格
        else:
            print("*",end=" ")
    print()
for i in range(26):
    print(chr(i+65),end=" ")
```
代码粗糙，敬请谅解

---

## 作者：Farewe1ll (赞：3)

### 这道题其实hin简单 
#### ~~但是卡了本蒟蒻30min qwq~~
思路就是类似桶排序或hash

~~别跟我讲map或unordered_map~~

但最后的输出特别恶心

需要加特判的地方 莫名想到一种三目运算符~~玄学~~解法

废话不多说 上代码。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
//define re register
#define FOR(i,a,b) for(re int i=a;i<=b;++i)
#define REP(i,a,b) for(re int i=a;i>=b;--i)//几种玄学卡常或宏定义
const int MAXN=26+10;
int a[MAXN];//hash数组
int main() {
	string str;
	int ma=0;
	FOR(i,1,4){
		str="";//别忘了清空（好像不清空也没事
		getline(cin,str);
		FOR(j,0,(int)str.size()-1)
			if(isalpha(str[j]))ma=max(++a[str[j]-'A'],ma);//玄学的预处理 isalpha函数用于判断是不是字母 题意表明如果是字母，就是大写字母 所以可直接处理
	}
	REP(i,ma,1)
		FOR(j,0,25)
			printf("%c%c",a[j]>=i?'*':' ',j==25?'\n':' ');//玄学处理 用三目运算符处理输出
	FOR(i,0,25)
		printf("%c%c",i+'A',i==25?'\n':' ');
	return 0;
}
```

看完代码 但还不懂？请继续往下看～～

~~看懂的去码代码吧~~

>printf("%c%c",a[j]>=i?'*':' ',j==25?'\n':' ');

该语句输出两个字符 第一个 由题意得 是‘*’或‘ ’ 在a[j]>=i时表达时返回‘*’ 其他返回‘ ’

而最后行末空格可用j==25判断（最后一个字母编号）判断，同理

P.S:为了方便处理 我从0开始处理

~~其实我一般从1开始~~

---

## 作者：Plague瘟疫先生 (赞：3)

#纯暴力——无脑暴力！！！

###第一次发题解233

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
char a1[10010];
long long b[100],c[100];
int main()
{
    long long max=0,l,m;
    for(int i=1;i<=4;i++)
    {
        gets(a1);l=strlen(a1),m=l;
        for(long long i=0;i<=l;++i)
        {
            if(a1[i]==' ')    
            m--;
        }//存储每个字母出现的个数
        for(long long i=0;i<l;++i)
        b[a1[i]-'A']++;
    }
    for(long long i=0;i<=26;++i)
        {
            max=b[i]>max?b[i]:max;
        }//判断出现数字最大的一位，即表格“*”的最高值
        for(long long j=max;j>=1;--j)//max为最高值，限制表格最高为max位
        {
            for(long long x=0;x<=26;++x)
            {
                if(b[x]>=j) 
                    {
                        cout<<"*";
                        if(x!=26) cout<<" ";    
                    }
                else 
                    {
                        cout<<" ";
                        if(x!=26) cout<<" ";
                    }
            }
        cout<<endl;
        }//打印列表
    cout<<"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z";//最后一行
    return 0;
}
```

---

## 作者：Lyrics (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
char s1[1000],s2[1000],s3[1000],s4[1000];
int a[300],maxn=-1;
int main(){
    gets(s1);    gets(s2);    gets(s3);    gets(s4);//读入字符串
    for(int i=0;i<strlen(s1);i++)    a[s1[i]-'A'+1]++;//对于每个出现过的字符进行累计
    for(int i=0;i<strlen(s2);i++)    a[s2[i]-'A'+1]++;//对于每个出现过的字符进行累计
    for(int i=0;i<strlen(s3);i++)    a[s3[i]-'A'+1]++;//对于每个出现过的字符进行累计
    for(int i=0;i<strlen(s4);i++)    a[s4[i]-'A'+1]++;//对于每个出现过的字符进行累计
    for(int i=1;i<=26;i++)maxn=max(maxn,a[i]);//找到最大的那个出现次数
    while(maxn>0){//进行操作
        for(int i=1;i<26;i++){//肯定是先做最高层才是最好的，然后一层一层往下砍掉
            if(a[i]<maxn){
                printf("  ");
                continue;
```
}//肯定是先做最高层才是最好的，然后一层一层往下砍掉
```cpp
            else {
                a[i]--;
                printf("* ");
            }
        }
        if(a[26]==maxn){//肯定是先做最高层才是最好的，然后一层一层往下砍掉
            printf("*");
            a[26]--;
        }
        printf("\n");
        maxn--;//砍掉高度继续往下搜
    }
    for(char i='A';i<'Z';i++)//输出过程
        cout<<i<<" ";
    cout<<"Z"<<endl;
    return 0;
}
```

---

## 作者：火星大王 (赞：3)

童鞋们注意啊这题数组一定要开大


char in[800];

long long count[30];

long longstart=0;

就是这3行，开数组，我一开始写

char in[80];

int count[30];

int start=0;

结果RE


除了这个还是挺简单的

            
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
char in[800];
long long count[30];
#define maxn(x,y) ((x)>(y))?(x):(y)
long long start=0;
int main()
{
    freopen("1598.in","r",stdin);
    for(int i=0;i<4;i++)
    {
        gets(in);
        for(int j=0;in[j]!=0;j++)
        {
            if(in[j]!=' ')
                count[in[j]-'A'+1]++;
        }
    }
    for(int i=1;i<=26;i++)
    {
//        printf("%d ",count[i]);
        start=maxn(start,count[i]);
    }
//    cout<<endl<<start<<endl;
    for(int i=start;i>0;i--)
    {
        for(int j=1;j<=26;j++)
        {
            if(count[j]>=i)
                printf("*");
            else
                printf(" ");
            if(j!=26)
                printf(" ");
        }
        printf("\n");
    }
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
}
```

---

## 作者：_Archangel (赞：2)

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    string a[4];//4行数据
    int count[26];//每个字母设置一个数组的元素作为计数器
    int max=0;//用来找到字母出现次数的变量
    for(int i=0;i<4;i++)
        getline(cin,a[i]);//逐行输入数据
    for(int i=0;i<26;i++)
        count[i]=0;//初始化计数数组
    for(int i=0;i<4;i++)//i=行数
    {
        for(int j=0;j<a[i].length();j++)//j=第i行的第j个字符
        {
            for(int k=65;k<=90;k++)//ASCII中A=65，B=66，......，Z=90
            {
                if(a[i][j]==k)//判断a中第i行第j个字符是否与目前循环到的字母K相等
                {
                    count[k-65]++;//如果相等，对应的计数器+1
                }    
            }    
        }
    }
    for(int i=0;i<26;i++)
    {
        if(count[i]>max)
        max = count[i];//寻找出现次数最多的字母
    }
    for(int i=0;i<max;i++)//第i行
    {
        for(int j=0;j<26;j++)//第j列
        {
            if(j<25)//非行尾情况
            {
            if(count[j]>=(max-i))
```
/\*因为柱状图是从最后一行往上的，而输出是从上往下，所以要判断这个位置有没有\*，而不是直接输出。\*/
cout << "\* ";//注意无论柱状图这里是\*还是空格，输出末尾都要再加一个空格

            
            
```cpp
            else
            cout << "  ";
            }
            if(j==25)//行尾情况，与非行尾情况大致相同，只是输出后换行
            {
                if(count[j]>=(max-i))
                cout << "*" << endl;//输出后换行
                else
                cout << " " << endl;//输出后换行
            }
        }
    }
    for(char i='A';i<'Z';i++)
    cout << i << " ";//输出A-Y，后面都有一个空格
    cout << "Z";//输出Z，后面没有空格
    return 0;
}

```

---

## 作者：bjrjk (赞：2)

定义数组，数组清零；然后一个一个的读字符取ascii码，不在大写字母范围内直接略去。写了个max函数计算最多有多少行，然后再循环字母列，不够数的打空格，够数的打＊号，除了最后一个其他都要空格，每一行换行，最后打一列字母。完了！

```cpp

#include <iostream>  
#include <stdio.h>  
using namespace std;  
int max(int* array,int num);  
int main(){  
    int array[26],tempchar;  
    memset(array, 0, sizeof(int)*26);  
    while((tempchar=getchar())!=EOF){  
        if(tempchar<65&&tempchar>90)continue;  
        array[tempchar-65]+=1;  
    }  
    for(int i=max(array,26);i>=1;i--){  
        for(int j=0;j<=25;j++){  
            if(array[j]<i)printf(" ");  
            else printf("*");  
            if (j!=25)printf(" ");  
        }  
        printf("\n");  
    }  
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");  
    return 0;  
}  
int max(int* array,int num){  
    int max=0;  
    for(int i=0;i<=(num-1);i++){  
        if(array[i]>max)max=array[i];  
    }  
    return max;  
}  

```

---

## 作者：QQ860287390 (赞：2)

```cpp

#include <iostream>
using namespace std;

int cnt[26];
char gap[] = "                                                    ";

// 本方法用于打印一定数量的空格
void printgap(int size) {
    cout << (gap + 52 - size);
}

void makegraph() {
    // 计算柱形图的高度
    int height = 0;
    for(int i = 0; i < 26; i++) {
        if(cnt[i] > height)
            height = cnt[i];
    }
    // 从高到低打印柱形图
    for(int h = height; h > 0; h--) {
        int gapsize = 0;
        for(int i = 0; i < 26; i++) {
            if(cnt[i] >= h) {    // 该字母的柱形到达了当前高度，打印 * 号
                // 空格仅在需要时打印
                printgap(gapsize);
                cout << '*';
                // gapsize 用于计算下一次打印的空格数
                // 每个 * 后面自动预留一个空格
                gapsize = 1;
            } else {
                // 若该字母的柱形没有到达当前高度则不打印 * 号
                gapsize += 2;
            }
        }
        cout << endl;
    }
    cout << "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z";
}

int main() {
    // 统计各字母出现次数
    char buf;
    while(cin >> buf) {
        buf |= ('a' - 'A');
        if(buf >= 'a' && buf <= 'z') {
            cnt[buf - 'a']++;
        }
    }
    // 制图
    makegraph();
    return 0;
}

```

---

## 作者：九指客 (赞：2)

这道题有点坑，需要一个一个判断，希望对大家有帮助。

```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    int i,j,la,b[27]={0},max,s,c[27];
    char a[1001];
    for(i=0;i<=3;i++)
    {
        gets(a);
        la=strlen(a);
        for(j=0;j<la;j++)
        {
            if(a[j]>='A'&&a[j]<='Z');
            b[a[j]-'A'+1]++;
        }
    }
    max=0;
    for(i=1;i<=26;i++)
    {
        if(b[i]>max)
        {
            max=b[i];
        }
    }
    for(i=1;i<=26;i++)
    {
        c[i]=max-b[i];
    }
    for(j=1;j<=max;j++)
    {    
        for(i=1;i<=26;i++)
        {
            if(c[i]!=0)
            {
                c[i]--;
                printf("  ");
            }
            else if(c[i]==0)
            {
                printf("* ");
            }
        }
        printf("\n");
    }
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
    return 0;
}
```

---

## 作者：ABlueCat (赞：2)

本蒟蒻第一次发题解……请多多包涵。

## 基本思想

1.把所有从A-Z的大写字母存储在一个数组里面，用数组下标1->A，2->B的方式存储数据，即**num[s[i] - 'A' + 1]++;**；

2.查找数组中出现字母的最大值，因为最大出现次数 = 柱状图行数；

3.打印时该字母出现次数一定要减少1次；

4.至于max - i + 1的意思，请自己思考。

最后是代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
int num[27];
char s1[1001], s2[1001], s3[1001], s4[1001];

int main()
{
    cin.getline(s1, 1001);
    cin.getline(s2, 1001);
    cin.getline(s3, 1001);
    cin.getline(s4, 1001);
    int i = 0;
    for (i = 0; i<strlen(s1); i++) {
        if (s1[i] >= 'A' && s1[i] <= 'Z')
            num[s1[i]-'A'+1]++;
    }
    for (i = 0; i<strlen(s2); i++) {
        if (s2[i] >= 'A' && s2[i] <= 'Z')
            num[s2[i]-'A'+1]++;
    }
    for (i = 0; i<strlen(s3); i++) {
        if (s3[i] >= 'A' && s3[i] <= 'Z')
            num[s3[i]-'A'+1]++;
    }
    for (i = 0; i<strlen(s4); i++) {
        if (s4[i] >= 'A' && s4[i] <= 'Z')
            num[s4[i]-'A'+1]++;
    }
    //==============以上是得到字母，存储到数组里面=====================
    int max = num[1];
    for (i = 2; i<27; i++)
        if (num[i] > max)
            max = num[i];
    for (i = 1; i<=max; i++) {
        for (int j = 1; j<27; j++) {
            if (num[j] == max - i + 1) {
                cout<<"*";
                num[j]--;
            }
            else cout<<" ";
            cout<<" ";
        }
        cout<<endl;
    }
    cout<<"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"<<endl;//打印最后一排
    return 0;
}
```

---

## 作者：Excim (赞：2)

这个题主要是模拟和字符串（废话）

我的核心思路就是1.找所有字母中出现次数最大的值（用来防止打印空行）

2.找最后一次应该打印‘\*’的位置（防止打印多余空格）

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int len1,len2,len3,len4;
int i,j,e,t1[27],t2[401];//e是所有字母出现的最大次数，t1是用来统计每个字母出现的次数，t2是用来记录 最后出现 每个次数 的字母（即每行最后一次打印‘*’的位置） 
char a[100],b[100],c[100],d[100];
int main()
{
    gets(a);
    gets(b);
    gets(c);
    gets(d);//gets还是很好用的 
    len1=strlen(a);
    len2=strlen(b);
    len3=strlen(c);
    len4=strlen(d);
    for(i=0;i<len1;i++)
    {
        t1[a[i]-'A'+1]++;
```
}//统计每个字母出现的次数
```cpp
    for(i=0;i<len2;i++)
    {
        t1[b[i]-'A'+1]++;
    }
    for(i=0;i<len3;i++)
    {
        t1[c[i]-'A'+1]++;
    }
    for(i=0;i<len4;i++)
    {
        t1[d[i]-'A'+1]++;
    }
    for(i=1;i<=26;i++)
    {
        if(t1[i]>e) e=t1[i];
```
}//找最大值
for(i=e;i>=1;i--)//从最大值到1分别查找它最后一次出现的位置

```cpp
    {
        for(j=26;j>=1;j--)//从后往前找，这很重要 
        {
            if(t1[j]>=i)
            {
                t2[i]=j;
                break;//找到后跳出 
             }
        }
    }
    for(i=e;i>=1;i--)//还是从后往前，否则输出是倒着的 
    {
        for(j=1;j<=t2[i];j++)//只需要循环到最后打印的位置就好了 
        {
            if(t1[j]>=i) printf("* ");//每个字母出现次数大于当前打印的行数就打印 
            else printf("  ");//否则打印两个空格（这里不需要考虑最后打印两个空格的问题，因为不打印的一定不是最后一个） 
        }
        printf("\n");
    }
    printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
    return 0;
}
```

---

## 作者：TangPointer_1 (赞：2)

## JAVA方式实现柱状图
首先通过一个StringBuffer来组装字符串
然后通过分支条件判断来获得每个字母出现的个数，用数组将其装下.
然后找出最高的那个数（也就是最大的那个值）来开始打印
最后打印出A~Z
```java


import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        StringBuilder str = new StringBuilder(in.nextLine());
        for(int i=0;i<3;i++)
            str.append(in.nextLine());
        int[] numOfLetter = new int[26];
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)>='A'&&str.charAt(i)<='Z')
                numOfLetter[str.charAt(i)-'A']++;
        }
        int max = MAX(numOfLetter);
        for(int i=max;i>0;i--){
            for(int j=0;j<26;j++){
                if(numOfLetter[j]-i>=0)
                    System.out.print("*");
                else
                    System.out.print(" ");
                System.out.print(" ");
            }
            System.out.println();
        }
        //***********************打印A~Z
        for(int i=0;i<numOfLetter.length;i++)
            System.out.print((char)('A'+i)+" ");
    }
    public static int MAX(int[] e){
        int max = e[0];
        for(int i=1;i<e.length;i++){
            if(e[i]>max)
                max = e[i];
        }
        return max;
    }
}

```


---

## 作者：zxkgz (赞：1)

#### 主要思想就是先找到每一个字符出现的次数，然后用一个二维数组star存储输出结果。出现最多的字符个数是max，那么除开A B C...这一行，上面的输出就有max行，从max行开始到第一行，设置每一列的'*',例如设置'A'是就是设置star[max-1:0][1],每设置一个'*',ch[1]--,直到ch[1]==0，说明'A'这一列的'*'设置完了，该列上面其余的就设置为' ',剩下的列都按照这个方法设置，最后输出star[0：max-1][1-26]就是结果


```cpp
#include <iostream> 
#include <cstring>

using namespace std;


int main(int argc, char const *argv[])
{
    int ch[27];//统计字母出现次数
    char star[400][27];//用来存储输出的结果'*'
    char str[4][100];//存储的4行文本
    memset(ch, 0, sizeof(ch));//初始化为0
    memset(str, 0, sizeof(str));//初始化为'\0'
    memset(star, 0, sizeof(star)); //初始化为'\0'
    for(size_t i = 0; i < 4; i++)   
    {
        cin.getline(str[i], 100);
    }
    for(size_t i = 0; i < 4; i++)   //遍历4行文本， 遇到空格跳过，遇到'\0'说明当前行的文本结束，扫描下一行
    {
        for(size_t j = 0; j < 100; j++)
        {
            if (str[i][j] == '\0') 
            {
                break;
            }
            else
            {
                if (str[i][j] != ' ') //不是空格，字符-64表示下标，如'A' - 64 = 1,ch[1]++;
                {
                    ch[str[i][j] - 64]++; //当前扫描到的字符对弈的ch数组+1， 例如‘A’，ch[1]++表示找到一个'A'
                }  
                // cout << ch[str[i][j] - 64] << " ";
            }
        }
    }
    int max = 0;	//存储出现最多字符的个数， 因为最多有max行输出‘*’
    for(int i = 1; i <= 26; i++)    //找到出现次数最多那个数
    {
        max = max > ch[i] ? max : ch[i];
    }
    
    for(int i = 1; i <= 26; i++)    //给star数组设置'*',由于最多次数为max，输出的*有max行。从第一列max行开始，倒着设置，以列为单位从下往上设置，即star[1][0],star[1][1]....,每设置一个ch[i]--,直到ch[i] == 0,该列的*设置完了，该列其余的设置为' '
    {                     

        for(int j = max-1; j >= 0; j--)
        {
            
            if (ch[i] != 0) 
            {
                star[j][i] = '*';
                ch[i]--;
            }
            else
            {
                star[j][i] = ' ';
            }
            
            
        }
        
    }
    
    
    for(int i = 0; i < max; i++)    //输出垂直柱状图结果
    {
        
        for(int j = 1; j <= 26; j++)
        {
            
            if (j == 26) //该行结束不打空格
            {
                cout << star[i][j];
                continue;
            }
            
            cout << star[i][j] << ' ';
        }
        cout << endl;
    }
    char a = 'A';
    for(size_t i = 0; i < 26; i++)
    {

        if (i == 25) //该行结束不打空格
        {
            cout << a++;
            continue;
        }
        
        cout << a++ << ' ';
    }
    
    getchar(); // 提交代码删除此行
    return 0;
}

```

---

## 作者：ArnoD (赞：1)

这道题本来很简单的，就是这该死的空格（其实也没麻烦多少）

```cpp
var
  x:char;
  max,i,j:longint;
  a:array['A'..'Z'] of longint;
begin
  repeat
    read(x);
    if x in ['A'..'Z'] then
    begin
      inc(a[x]);
      if a[x]>max then
        max:=a[x];
    end;
  until eof;//读入并统计字母出现次数
  for i:=1 to max do//外循环做出现次数最多的字母的出现次数遍
  begin
    for j:=1 to 25 do//因为这坑爹的数据要求行末不能有空格
      if a[chr(j+64)]=max-i+1 then//判断第j个大写字母出现的次数是否可以在第i行输出
      begin
        write('* ');
        dec(a[chr(j+64)]);//该大写字母出现次数减一
      end else
        write('  ');//补空格
    if a[chr(j+65)]=max-i+1 then//由于该死的空格，所以。。。。
    begin
      write('*');
      dec(a[chr(j+65)]);
    end else
      write(' ');
    writeln;
  end;
  for x:='A' to 'Y' do//还是该死的空格
    write(x,' ');
  writeln('Z');
end.
```

---

## 作者：初学者1 (赞：1)

简单的模拟，标程如下，不解释（你懂得）：

```cpp
var i,j,max:longint;
    str1:ansistring;
    ch1,ch:char;
begin
  for i:=1 to 4 do begin
  readln(str1);
      for j:=1 to length(str1) do
      if str1[j] in ['A'..'Z'] then a[str1[j]]:=a[str1[j]]+1;
  end;
  for ch:='A' to 'Z' do
  if a[ch]>max then max:=a[ch];
  for i:=max downto 1 do begin
  ch1:='A';
      for ch:='A' to 'Z' do
      if a[ch]>=i then begin
      write('*':(ord(ch)-ord(ch1)+1)*2-1);ch1:=j;
      end;
  end;
  writeln;
  end;
  for ch:='A' to 'Z' do write(ch:2);
end.
```

---

## 作者：JasonLi3000 (赞：0)

    #include <iostream>
    #include <cctype>
    #include <map>
    #include <algorithm>

    #pragma warning(disable:4996)	
    // 用VS2017时，告诉编译器忽视scanf(), printf()等函数的安全性问题

    using namespace std;

    const int MAX_SIZE = 100;

    map<char, int> alpha_cnt;

    int main() {
        char str[MAX_SIZE + 1];
        for (int i = 0; i < 4; ++i) {
            gets_s(str, MAX_SIZE + 1);	
            // gets_s()是C11标准开始使用，用来替代gets()的函数
            // 但是洛谷的库里没有gets_s()，反而有gets()

            for (auto p = str; *p != '\0'; ++p) {
                if (isalpha(*p)) {
                    ++alpha_cnt[*p];	// 这里不明白的同学可以查询map对operator[]的重载
                }
            }
        }

        // 求字母出现的最大次数
        int max_cnt = 0;
        for (const auto &t : alpha_cnt) {
            max_cnt = max(max_cnt, t.second);
        }

        // 打印柱状图
        for (int i = max_cnt; i > 0; --i) {
            for (char c = 'A'; c <= 'Z'; ++c) {
                if (alpha_cnt[c] >= i) {
                    printf("* ");
                }
                else {
                    printf("  ");
                }
            }
            putchar('\n');
        }

        for (char c = 'A'; c < 'Z'; ++c) {
            printf("%c ", c);
        }
        printf("Z");

        return 0;
    }

---

## 作者：时崎狂三 (赞：0)

//本题应该是比较基础的模拟，但有一个坑点就是要先初始化一遍，直接模拟可过。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
char b[75],t[27][375];int c,t1[27],max;
int main()
{for(int a=0;a<=26;a++)
for(int i=0;i<=374;i++)
t[a][i]=' ';//初始化记录数组；
 for(int a=1;a<=4;a++)
 {gets(b);
 c=strlen(b)
 for(int i=0;i<c;i++)
 if(b[i]>='A'&&b[i]<='Z')t1[b[i]-'A'+1]+=1;};//读取字符串并判断是否为大写字母，并累计；
 for(int i=1;i<=26;i++) {for(int j=1;j<=t1[i];j++)t[i][j]='*';if(t1[i]>max)max=t1[i];}//判断这个柱状图应该输出多高；
 for(int i=1;i<=26;i++) t[i][0]=i+'A'-1;//对底层字母初始化；
 for(int i=max;i>=0;i--){for(int j=1;j<=26;j++) printf("%c ",t[j][i]);printf("\n");}//进行输出；
return 0;
}
```

---

## 作者：邓晓蓝 (赞：0)

```cpp
//这题不是很难，看pascal简单代码
var i,j,max:longint;
    st:string;
    k:char;
    gs:array['A'..'Z'] of longint;
begin
  for i:=1 to 4 do  //输入并统计字母个数
    begin
      readln(st);
      for j:=1 to length(st) do
        if st[j] in ['A'..'Z'] then
        inc(gs[st[j]]);
    end;
  for k:='A' to 'Z' do  //找最大值
    if gs[k]>0 then
      if gs[k]>max then max:=gs[k];
  for i:=max downto 1 do   //输出
    begin
    for k:='A' to 'Z' do
      if gs[k]>=i then write('* ') else write('  ');
    writeln;
    end;
  for k:='A' to 'Z' do
    write(k,' ');
end.
```

---

## 作者：skyair (赞：0)

为什么用pascal的又这么少？求高手教怎么控制空格。还好检验的时候不考虑空格

```delphi

Program p1598;//这是第1598题
var //对整个程序定义变量
 s:string;//s的给出的句子，下一个会覆盖掉上一个，保留下来并没有什么卵用
 i,k:char;//这两个都是计数器，定义成字符是为了后面比较好描述
 le,z:integer;//le是一次的句子长度，z的所有的句子加起来的长度
 t:array['A'..'Z'] of integer;//每个字母出现的次数
 tm,j,q:integer;//tm（max）出现次数最多的字母的次数，j依然是计数器，q没用，一时写多了
 
Function time(li:char):integer;//计算每个字母在每句话中次数的函数，写成函数只是为了简洁
 var i:integer;//重新定义的i依然是计数器，但是数据类型变了，注意
 begin
 time:=0;//将次数置零
 for i := 1 to le do//逐个对比字符
  if s[i]=li then//如果俩一样
  time:=time+1;//说明字幕出现了一次，统计次数
 end;
 
begin
 for j:= 1 to 4 do//一共有4个句子
  begin
  readln(s);//读入句子
  le:=length(s);//看看句子有多长
  z:=z+le;//总长度，不会被下一次覆盖
  for i := 'A' to 'Z' do
   t[i]:=time(i)+t[i];//计算每个字母出现的总次数
  end;
 for i:= 'A' to 'Z' do
  if tm<t[i] then tm:=t[i];//找出出现次数最多的字幕出现的次数
 for i:= 'A' to 'Z' do
  t[i]:=tm-t[i];//我们要先打印空格，后打印星号，所以把字母出现的次数转化成空格出现的次数
 for j:= 1 to tm do//打印出现次数最多的字母出现次数那么多行
  begin
  for i:='A' to 'Z' do
   begin
   q:=0;
   if t[i]>0 then//如果还有剩下的空格没有打印
    begin write('  '); t[i]:=t[i]-1; end else//就打印空格
    write('* ');//不然就打星花
   end;
  writeln;
  end;
 writeln('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z');//坐标轴的底
 end.

```

---

## 作者：BenNOI (赞：0)

其实就用一个数组装字母出现的次数就可以了，注意每行后面不要输出空格，用一个locat变量控制最后一个，用一个f变量控制空格输出

程序如下：

```cpp
var
  a:array [1..26] of longint;
  f:boolean;
  s1,s2,s3,s4:string;
  i,j,max,min,locat:longint;
begin
  max:=0;
  min:=10000;
  for i:=1 to 26 do a[i]:=0;
  readln (s1);
  readln (s2);
  readln (s3);
  readln (s4);
  for i:=1 to length(s1) do
    if s1[i] in ['A'..'Z'] then a[ord(s1[i])-64]:=a[ord(s1[i])-64]+1;
  for i:=1 to length(s2) do
    if s2[i] in ['A'..'Z'] then a[ord(s2[i])-64]:=a[ord(s2[i])-64]+1;
  for i:=1 to length(s3) do
    if s3[i] in ['A'..'Z'] then a[ord(s3[i])-64]:=a[ord(s3[i])-64]+1;
  for i:=1 to length(s4) do
    if s4[i] in ['A'..'Z'] then a[ord(s4[i])-64]:=a[ord(s4[i])-64]+1;
  for i:=1 to 26 do begin
    if a[i]>max then max:=a[i];
    if a[i]<min then min:=a[i];
  end;
  if min=0 then min:=1;
  for i:=max downto min do begin
    for j:=26 downto 1 do
      if a[j]>=i then begin locat:=j;break;end;
    f:=true;
    for j:=1 to 26 do
      if (a[j]>=i)and(j<=locat) then
        if not f then write (' *') else begin f:=false;write ('*');end
        else if j<=locat then write ('  ');
    writeln;
  end;
  f:=true;
  for i:=1 to 26 do begin
    if not f then write (' ') else f:=false;
    write (chr(i+64));
  end;
end.
```

---


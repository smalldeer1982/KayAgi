# 方程求解

## 题目描述

给一个方程，形如 $X+Y=Z$ 或 $X-Y=Z$。给出了其中两个未知数，请求出第三个数。未知数用 `?` 表示，等式中也许会出现一些多余的空格。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数，保证 $0\le X,Y,Z\lt10^9$，输入的字符串一定为题目给定的形式且长度不超过 $10^6$。

## 样例 #1

### 输入

```
1+2=?
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 +? =  2
```

### 输出

```
-1```

## 样例 #3

### 输入

```
3-?=2
```

### 输出

```
1```

# 题解

## 作者：minecraft_herobrine (赞：25)

## 首先，先看一下这道题可能需要什么算法

![](https://cdn.luogu.com.cn/upload/pic/60837.png)

## 咦？这怎么和猪国*一样啊

![](https://cdn.luogu.com.cn/upload/pic/60835.png)

## ~~哈哈哈哈哈~~

![](https://cdn.luogu.com.cn/upload/pic/60836.png)

## ~~好了不闹了~~

这道题需要进行字符串模拟，但是这道题的表达式里会有空格和回车，就像``x +y = z``这样，这就需要过滤空格了。不过``scanf("%c",&ch)``是可以读入空格和回车的

所以我们在读入是可以使用

```cpp
while(scanf("%c",&s[i++])!=EOF);
len=i-1;

```

进行读入。

----

# 下面就开始模拟了（敲黑板）

因为在读入时没有过滤空格（scanf都读进去了），所以模拟时需要过滤空格。显然需要判断如果是空格就continue。

而题目中表达式的表示方法是``x+(或者-)y=z``，所以在整个表达式中出现非数字字符只能是+（-）和=，空格已经被过滤。所以这把整个表达式分成了三部分，每个部分都是一个整数，我们可以用x，y，z来表示。

----

模拟过程我们需要两个状态变量，一个是3个状态，表示当前在表达式的哪个部分，另一个有两个状态，表示表达式是加法还是减法。所以模拟时需要分类讨论符号，具体的模拟过程在代码中解释

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2147483647;//这里可以看出哪个数是未给出的数
char s[100];
int main()
{
	int len,i=1,x=0,y=0,z=0,op=0;
	bool op_add=true;
    //这里op表示当前处于表达式的哪个部分,op_add表示当前表达式是加法还是减法,x,y,z都要给初值,否则后面会出错
	while(scanf("%c",&s[i++])!=EOF);//读入,暂时不忽略空格
	len=i-1;//长度,在读入时多了一个,需要-1
	for(i=1;i<=len;i++)
	{
		if(s[i]==' ') continue;//这里过滤空格
		else if(s[i]>='0' && s[i]<='9')//处理数字
		{
			if(op==0) x=x*10+(s[i]-'0');//看这是在哪个部分
			else if(op==1) y=y*10+(s[i]-'0');//不同的部分表示不同的数
			else if(op==2) z=z*10+(s[i]-'0');//如果这里没给初值的话,那这就是乱码,会WA
		}
		else if(s[i]=='+') op=1;//如果遇到'+',说明已经到了第二部分(+或-和=号之间)
		else if(s[i]=='-') op=1,op_add=false;//如果是-,那就把op_add=false,后面需要判断
		else if(s[i]=='=') op=2;//到=了,说明到第三部分了
		else if(s[i]=='?')//遇到了未知数
		{
			if(op==0) x=INF;//记录下来
			else if(op==1) y=INF;//INF相当于标记
			else if(op==2) z=INF;
		}
	}
	if(op_add)//处理完毕,如果表达式是加法
	{
		if(x==INF) printf("%d",z-y);//加数=和-另一个加数
		else if(y==INF) printf("%d",z-x);
		else if(z==INF) printf("%d",x+y);//和=...
	}
	else//如果是减法
	{
		if(x==INF) printf("%d",z+y);//同理了呗~~
		else if(y==INF) printf("%d",x-z);
		else if(z==INF) printf("%d",x-y);
	}
//	printf("\n%d %d %d",x,y,z);//这是调试的语句
	return 0;//结束
}
```

最后求管理大大过QAQ

---

## 作者：whiteqwq (赞：7)

本人觉得可能是最短而完整易解的代码了，31行（没有压行）QWQ

首先，在输入的时候借鉴了一下楼下的写法，使用while来输入，因为这样可以十分方便地省略空格，免去不必要的困扰。

然后就很简单了，搜索中间的"?"在第几个位置上，同时将另外两个数搜索出来，然后就枚举6种情况：

* 中间有"+"号，且空位在第一个位置上，答案是第三个数-第二个数

* 中间有"+"号，且空位在第二个位置上，答案是第三个数-第一个数

* 中间有"+"号，且空位在第三个位置上，答案是第一个数+第二个数

* 中间有"-"号，且空位在第一个位置上，答案是第三个数+第二个数

* 中间有"-"号，且空位在第二个位置上，答案是第一个数-第二个数

* 中间有"-"号，且空位在第三个位置上，答案是第一个数-第三个数

owo，下面是蒟蒻的代码：

```
#include<bits/stdc++.h>//万能头
using namespace std;
int i,x,a[10],b[10];//循环量，一个普通的变量qwq，一个记录数字的数组，一个记录"?"号的数组
string t,s;
int main(){
    while(cin>>t)//循环输入，运用cin的特点去除空格
        s+=t;//连接
    for(i=0;i<s.size();i++){//搜索"?"与另外两个数
        if(s[i]=='?')//搜索到"?"号
            b[++x]=1;//标记
        if(s[i]<'0'||s[i]>'9')//不属于数字
            continue;
        for(x++;s[i]>='0'&&s[i]<='9';i++)//读取数字，并存储数字
            a[x]=a[x]*10+s[i]-48;
    }
    if(s.find('+')<s.size())//有"+"号
        x=1;//标记
    else x=0;
    if(x&&b[1])//第一种情况
        printf("%d\n",a[3]-a[2]);
    else if(x&&b[2])//第二种情况
        printf("%d\n",a[3]-a[1]);
    else if(x&&b[3])//第三种情况
        printf("%d\n",a[1]+a[2]);
    else if(!x&&b[1])//第四种情况
        printf("%d\n",a[2]+a[3]);
    else if(!x&&b[2])//第五种情况
        printf("%d\n",a[1]-a[3]);
    else printf("%d\n",a[1]-a[2]);//第六种情况
    return 0;
}
```

---

## 作者：王钰翔 (赞：6)

## 看到了一篇类似题解 ~~(但是我的比较简单易懂)~~
------------
#### 根据中缀运算的特性 :
#### num(+/-)num=num
#### 所以直接取出数字的位置再运算就可以了
##### 良心的点在于数据范(0<=X,Y,Z<1,000,000,000)没有负数,不用考虑负号
###### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100000];
int a,b,c;
int a1,b1;
int main() {
	gets(s); // 要读入空格
	for(int i=0; i<strlen(s); i++) { // 找出位置
		if(s[i]=='+'||s[i]=='-') {
			b=i;
		}
		if(s[i]=='=') {
			c=i;
		}
		if(s[i]=='?') {
			a=i;
		}
	}
	if(a<b) { // ?(+/-)num=num时
		for(int i=b; i<c; i++) {
			if(s[i]>='0'&&s[i]<='9') {
				a1=a1*10+s[i]-'0';
			}
		}
		for(int i=c; i<strlen(s); i++) {
			if(s[i]>='0'&&s[i]<='9') {
				b1=b1*10+s[i]-'0';
			}
		}
		if(s[b]=='+') { // 就地处置,下同
			cout<<b1-a1<<endl;
		} else {
			cout<<a1+b1<<endl;
		}
	} else if(a>b&&a<c) { // num(+/-)?=num时
		for(int i=0; i<b; i++) {
			if(s[i]>='0'&&s[i]<='9') {
				a1=a1*10+s[i]-'0';
			}
		}
		for(int i=c; i<strlen(s); i++) {
			if(s[i]>='0'&&s[i]<='9') {
				b1=b1*10+s[i]-'0';
			}
		}
		if(s[b]=='+') {
			cout<<b1-a1<<endl;
		} else {
			cout<<a1-b1<<endl;
		}
	} else { // num(+/-)num=?时
		for(int i=0; i<b; i++) {
			if(s[i]>='0'&&s[i]<='9') {
				a1=a1*10+s[i]-'0';
			}
		}
		for(int i=b; i<c; i++) {
			if(s[i]>='0'&&s[i]<='9') {
				b1=b1*10+s[i]-'0';
			}
		}
		if(s[b]=='+') {
			cout<<a1+b1<<endl;
		} else {
			cout<<a1-b1<<endl;
		}
	}

}

```


---

## 作者：第一大砍刀 (赞：5)

**非常暴力**
**非常易懂**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
string s;
int a[5],b,r,w,f,i,j;
int main()
{
    getline(cin,s);
    int l=s.size()-1;
    for(i=0;i<=l+1;i++)//循环查找数字
    {
        if(s[i]>='0'&&s[i]<='9')
        {
            a[++b]=s[i]-'0';
           for(j=i+1;j<=l;j++)
           {
            if(s[j]>='0'&&s[j]<='9')
            {
                a[b]=a[b]*10+s[j]-'0';
            }
            if(s[j]=='+'||s[j]=='-'||s[j]=='=')//如果遇到=，+或-就退出进行下一次查找
            {
                break;
            }
           }
           i=j;//防止重复查找
        }

    }
    for(int p=0;p<=l+1;p++)//标记各符号位置
    {
        if(s[p]=='=')
            r=p;
        if(s[p]=='+'||s[p]=='-')
            w=p;
        if(s[p]=='?')
            f=p;
    }
     if(f>r)//如果问号在等号后面
     {
        if(s[w]=='+')
         {
            cout<<a[1]+a[2]<<"\n";
            return 0;
          } 
        if(s[w]=='-')
        {
            cout<<a[1]-a[2]<<"\n";
            return 0;
        }
     }
     if(f<r)//如果问号在等号前
     {
            if(s[w]=='+')如果是加号
            {
                cout<<a[2]-a[1]<<"\n";
                return 0;
             }
        if(f>w&&s[w]=='-')如果是减号并且问号在减号后
        {
            cout<<a[1]-a[2]<<"\n";
            return 0;
             }
        else//问号在减号前
        {
            cout<<a[1]+a[2]<<"\n";
            return 0;
        }   

     }
    return 0;
} 
```

---

## 作者：UnyieldingTrilobite (赞：3)

上手鉴定大膜你。

首先，这题看着不是那么好写，所以把它拆开成几个部分分别写函数。

读入->滤空格->求解->输出。

重点在求解，其它的直接上代码了（含注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
class problem{
	private:
		string h;
	public:
		problem readline(){
			getline(cin,h);
			return *this;
		}//输入
		problem flitter(char c){
			string w;
			for(int i=0;i<h.length();++i)if(h[i]!=c)w.push_back(h[i]);
			h=w;
			return *this;
		}//过滤
		int getans(){/*求解*/}
}P1689; 
int main(){
	printf("%d\n",P1689.readline().flitter(' ').getans());//输出
	return 0;
}
```
~~啊面向对象主函数看着真舒服。~~

接着考虑怎么写getans函数。

首先显而易见的几个基本变量：flg表示加法还是减法，a1,a2表示其他两个操作数。

然后从头开始找每一个字符。

如果遇到加减法就设置flg.

如果先遇到等号（还没有遇到问号），那么问号肯定在另一头，并且已经遇到过了加减号。

这时的代码很好写：
```cpp
sscanf(h.c_str(),flg==1?"%d+%d=?":"%d-%d=?",&a1,&a2);
return flg==1?a1+a2:a1-a2;
//flg=1:加法;2:减法;初始为0
```
第二种稍微麻烦一点，先遇到问号。

继续分类：

第一种：遇到过加减号:

和上面完全同理，代码也像：
```cpp
sscanf(h.c_str(),flg==1?"%d+?=%d":"%d-?=%d",&a1,&a2);
return flg==1?a2-a1:a1-a2;
```
总之就是知道加减法就好写。

**第二种，符号未知。**

怎么办？

~~凉拌~~。

也还好，无非就是多读入一个符号。

```cpp
sscanf(h.c_str(),"?%c%d=%d",&f,&a1,&a2);
if(f=='+')return a2-a1;
else return a1+a2;
```
综上······就没了。

分开讲很轻松吧？

尽量尝试自己写一遍，细节不少，~~合起来就烦了~~。

最后总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
class problem{
	private:
		string h;
	public:
		problem readline(){
			getline(cin,h);
			return *this;
		}
		problem flitter(char c){
			string w;
			for(int i=0;i<h.length();++i)if(h[i]!=c)w.push_back(h[i]);
			h=w;
			return *this;
		}
		int getans(){
		    int flg=0;
			int a1,a2;
			for(int i=0;i<h.size();++i){
				if(h[i]=='+')flg=1;
				if(h[i]=='-')flg=2;
				if(h[i]=='='){
					sscanf(h.c_str(),flg==1?"%d+%d=?":"%d-%d=?",&a1,&a2);
					return flg==1?a1+a2:a1-a2;
				}
				if(h[i]=='?'){
				    char f;
				    if(flg){
				    	sscanf(h.c_str(),flg==1?"%d+?=%d":"%d-?=%d",&a1,&a2);
				    	return flg==1?a2-a1:a1-a2;
					}
					else{
						sscanf(h.c_str(),"?%c%d=%d",&f,&a1,&a2);
						if(f=='+')return a2-a1;
				    	else return a1+a2;
					}
				}
			}
		}
}P1689; 
int main(){
	printf("%d\n",P1689.readline().flitter(' ').getans());
	return 0;
}
```
看不懂的欢迎私信。

Over.

---

## 作者：Jack_cjj (赞：3)


    

    
    
        
       








```cpp
//作为一个P党，我来发一个Pas题解。
//我的思路是：先删去无用空格
//“？”有3种状态
//（1）A+B=？
//（2）？+A=B
//（3）A+？=B
//第二种情况时，如果是加法，？=B-A；如果是减法，？=A+B
//第三种情况时，如果是加法，？=B-A；如果是减法，？=A-B
var  
    a:string;//有一些符号，所以用字符串方便
    x1,k,j,i,x2,sum,ok,jj:longint;//X，Y，Z都小于1000000000，所以用longint
begin
    readln(a);
    for i:=length(a)  downto 1  do if a[i]=' ' then delete(a,i,1);
    //因为题目中说明了有一些无效空格，所以要先删除。我WA了3次！如果你得了50分，你应该没删空格。
    k:=pos('?',a);  //求出“？”的位置
    jj:=pos('=',a);  //求出“=”的位置
    if k>jj then begin //如果“？”在“=”后面，说明只要计算前两数字的和或差即可
        if pos('+',a)<>0 then begin k:=pos('+',a)-1; ok:=1; end;//减一是因为“+” 或 “-”不算一个数位。
        if pos('-',a)<>0 then begin k:=pos('-',a)-1; ok:=2; end;
        j:=0;
        x1:=0;
        x2:=0;//清零
        for i:=1  to k do //求出第一个数
            begin
                val(a[i],j);
                x1:=x1*10+j;//把字符串转化成数字
            end;
        for i:=k+1  to length(a)-2 do //“=？”占了两位，所以只用算到倒数第3位
            begin
               val(a[i],j);
                x2:=x2*10+j;
            end;
            case ok of
            1:sum:=x1+x2;
            2:sum:=x1-x2;
            end;
            writeln(sum);
            end;
    k:=pos('?',a);
    jj:=pos('=',a);//重新计算一次，不要把上一次的结果带进下一种情况
   if k=1 then begin//问号在最前面的情况
        if pos('+',a)<>0 then begin k:=pos('+',a)+1; ok:=1; end;//为什么这次是“+1”呢？是因为现在只用求问号后面的数，“？”占了一位，所以要“+1”
        if pos('-',a)<>0 then begin k:=pos('-',a)+1; ok:=2; end;
         j:=0;
        x1:=0;
        x2:=0;
        for i:=k  to jj-1 do//求出问号后的第一个数
            begin
                val(a[i],j);
                x1:=x1*10+j;
            end;
        j:=0;
          for i:=jj+1  to length(a) do
            begin
                val(a[i],j);
                x2:=x2*10+j;
            end;
            case ok of
            1:sum:=x2-x1;
            2:sum:=x1+x2;
            end;
            writeln(sum);
            end;
            k:=pos('?',a);
    jj:=pos('=',a);
      if (k<jj) and (k<>1) then begin //如果前两种都不符合，说明“？”在中间。
        if pos('+',a)<>0 then begin k:=pos('+',a)-1; ok:=1; end;
        if pos('-',a)<>0 then begin k:=pos('-',a)-1; ok:=2; end;
        j:=0;
        x1:=0;
        x2:=0;
        for i:=1  to k do
            begin
              val(a[i],j);
              x1:=x1*10+j;
            end;
        j:=0;
        for i:=jj+1  to length(a) do
            begin
              val(a[i],j);
              x2:=x2*10+j;
            end;
            case ok of
            1:sum:=x2-x1;
            2:sum:=x1-x2;
            end;
            writeln(sum);
            end;
            readln;
            readln;
end.//结束
```

---

## 作者：白面葫芦娃 (赞：2)

因为X,Y,Z都为正，所以不用考虑负数情况。说是将X,Y放在等式左侧，Z放在等式右侧，其实并没有，只是相当于X,Y放在等式左侧，Z放在等式右侧。

1.将原输入去掉空格

2.将原式中的X,Y提取(不包括前面的符号，后面进行处理)

3.将X,Y,Z分别处理，将X,Y加上前面的符号放在等式左边，将Z加上前面符号放在等式右边

```cpp
#include <iostream>
#include <string>
using namespace std;
string a,b,c;
long long x,y,z;
int main(){
	getline(cin,a);		//有空格的输入 
	for(int i=0;i<a.size();i++)
		if(a[i]!=' ') b+=a[i];     //单独处理，去掉空格 
	int mark=0,flag=0;
	for(int i=0;i<b.size();i++)
		if(b[i]>='0' && b[i]<='9'){		//不管X,Y前面符号如何，先取X,Y，后面再进一步处理 
			if(!mark) {x=x*10+b[i]-'0'; if(!flag){c+='x';flag=1;}}  //放一个x知道x原来的位置 
			else {y=y*10+b[i]-'0'; if(!flag){c+='y';flag=1;}}	//同上 
			if(b[i+1]<'0' || b[i+1]>'9') {mark=1; flag=0;}
		}
		else c+=b[i];
	//cout<<c<<endl; 这时候c里面就是没有空格，没有数字的原来的字符串 
	int f_d=0;	//遇到等号为1 
	flag=0; //把z放在等式右边，flag表示z前面的符号，负为1 
	for(int i=0;i<c.size();i++){
		if(c[i]=='=') f_d=1;
		if(c[i]=='?'){	//把z放在右边，判断它前面的符号 
			if(!f_d && (i==0 || c[i-1]=='+')) flag=1;
			if(f_d && c[i-1]=='-') flag=1;
		}
		if(c[i]=='x'){ //把x放在左边，判断符号 
			if(!f_d && c[i-1]=='-') x=-x;
			if(f_d && c[i-1]!='-') x=-x;
		}
		if(c[i]=='y'){ //把y放在左边，判断符号 
			if(!f_d && c[i-1]=='-') y=-y;
			if(f_d && c[i-1]!='-') y=-y;
		}
	}
	z=x+y;  //因为前面把X,Y都放在了左边，以及X,Y前面的符号进行判定，所以直接相加就行 
	if(flag) z=-z;
	cout<<z<<endl;
	return 0;
} 
```
我可能表达没有那么清楚，在草纸上写两个方程就很容易理解了。


---

## 作者：寒武纪 (赞：2)

被卡了一晚上，看了题解都没纯C啊,直接放弃题解，所以来水一发。

原理：提取数字

```c
//输入 mid标记+/- equal 标记=
	char str[24],tempStr;
	int index=0,mid,equal,state=1;
	while(scanf("%c",&tempStr)){
		if(tempStr==' '){
			continue;
		}
		if(tempStr=='\n')
			break;
		if(tempStr=='-'||tempStr=='+'){
			mid=index;
			if(tempStr=='-')
				state=0;
		}
		if(tempStr=='=')
			equal=index;
		//输入可能会有非数字字符，加了个判断
        if((tempStr>='0'&&tempStr<='9')||tempStr=='+'||tempStr=='-'||tempStr=='='||tempStr=='?')
		str[index++]=tempStr;
	}
	str[index]='\0';
```

判断mid-1是否为?,是则提取X

```c
long temp;
if(str[mid-1]!='?'){
		temp=1;
		for(int i=0;i<mid-1;i++)
			temp*=10;
		for(int i=0;i<mid;i++){
			X+=temp*(str[i]-'0');
			temp/=10;
		}
	}
```
同理再提取Y，Z

完整代码：
```c
#include<stdio.h>

int main(){
	long long X=0,Y=0,Z=0,temp;
	char str[24],tempStr;
	int index=0,mid,equal,state=1;
	while(scanf("%c",&tempStr)){
		if(tempStr==' '){
			continue;
		}
		if(tempStr=='\n')
			break;
		if(tempStr=='-'||tempStr=='+'){
			mid=index;
			if(tempStr=='-')
				state=0;
		}
		if(tempStr=='=')
			equal=index;
		if((tempStr>='0'&&tempStr<='9')||tempStr=='+'||tempStr=='-'||tempStr=='='||tempStr=='?')
		str[index++]=tempStr;
	}
	str[index]='\0';
	if(str[mid-1]!='?'){
		temp=1;
		for(int i=0;i<mid-1;i++)
			temp*=10;
		for(int i=0;i<mid;i++){
			X+=temp*(str[i]-'0');
			temp/=10;
		}
	}
	if(str[mid+1]!='?'){
		temp=1;
		for(int i=mid+1;i<equal-1;i++)
			temp*=10;
		for(int i=mid+1;i<equal;i++){
			Y+=temp*(str[i]-'0');
			temp/=10;
		}
	}
	if(str[equal+1]!='?'){
		temp=1;
		for(int i=equal+1;i<index-1;i++)
			temp*=10;
		for(int i=equal+1;i<index;i++){
			Z+=temp*(str[i]-'0');
			temp/=10;
		}
	}
	if(str[mid-1]=='?')
		printf("%lld\n",state?Z-Y:Z+Y);
	if(str[mid+1]=='?')
		printf("%lld\n",state?Z-X:X-Z);
	if(str[equal+1]=='?')
		printf("%lld\n",state?X+Y:X-Y);
	return 0;
}

```




---

## 作者：InformationEntropy (赞：1)

### 大致思路：

~~暴力~~模拟：

- 遍历到 + 说明该方程为加法方程，即$X+Y=Z$，遍历到 - 说明该方程为减法方程，即$X-Y=Z$，用$type$变量记录方程种类。

- ？ 的位置有三种：等号左边第一个数，等号左边第二个数，等号右边的数。用$flag1$,$flag2$记录运算符和等号的位置，如果遍历到 ？ ，根据$flag1$，$flag2$得出它在等式中的位置，用$pos$存储结果。

处理完这些后，根据$pos$还原两个已知数的值，然后根据$pos$和$type$将两个已知数做加减运算操作，算出结果。

### 代码(~~通俗易懂~~)：

```cpp
#include<iostream>
#include<string>
using namespace std;
string a;
int x=0,y=0;//存储两个已知数
bool num(int i){
    return a[i]>='0'&&a[i]<='9';//判断是否为数字
}
void huanyuan(int start,int end,int type){
    for(int i=start;i<end;i++){
        if(num(i)){
            if(type==0) x=x*10+a[i]-48;
            else y=y*10+a[i]-48;
        }
    }
    //得到两个已知数（针对中间可能有空格）
    
}
int main(){
    getline(cin,a);
    int flag1=0,flag2=0;//记录等号和运算符的位置，如果未出现则值为0
    int lena=a.length();
    int type;//记录种类 + 1 - 0
    int pos;//记录位置(从前到后为012)
    for(int i=0;i<lena;i++){
        if(a[i]=='='){
            flag1=i;
        }else if(a[i]=='+'){
            type=1;
            flag2=i;
        }else if(a[i]=='-'){
            type=0;
            flag2=i;//上文已说，不解释
        }else if(a[i]=='?'){
            if(!flag2) pos=0;//运算符未出现，说明？表示第一个数
            if(flag2&&(!flag1)) pos=1;//运算符出现，等号未出现，说明？表示第二个数
            if(flag1) pos=2;等号已出现，说明？表示第三个数
        }
    }
    if(pos==0){
        huanyuan(flag2,flag1,0);
        huanyuan(flag1,lena,1);//已知数为后两个数
    }else if(pos==1){
        huanyuan(0,flag2,0);
        huanyuan(flag1,lena,1);//已知数为第一个和第三个数
    }else{
        huanyuan(0,flag2,0);
        huanyuan(flag2,flag1,1);//已知数为前两个数
    }
    switch(type){
        case 1:
            if(pos==1||pos==0) cout<<y-x;//x+?=y||?+x=y，?=y-x
            else cout<<x+y;//x+y=?
            break;
        case 0:
            if(pos==1||pos==2) cout<<x-y;//x-?=y||x-y=? ?=x-y
            if(pos==0) cout<<x+y; ?-x=y ?=x+y
            break;
    }
    return 0;
}
```
本题实质就是模拟，耐心把情况想全就行了

---

## 作者：andyli (赞：1)

这一题基本思路就是模拟，如果想出来了几乎没什么难度。字符串用`C++`自带的`string类`就可以，非常方便。注意题目说可能有多余的空格，因此在输入后还要再转换到一个新的字符串里面。

代码中我多次用到了一个函数`stoi`，从`C++11`才支持，因此在竞赛中不可以使用。我在这里自己写了一个`stoi2`，供大家参考。

```cpp
int stoi2(string str) // 支持负数
{
    int f = 1;
    if (str[0] == '-')
        f = -1, str = str.substr(1);
    int x = 0;
    for (size_t i = 0; i < str.length(); i++)
        x = (x << 1) + (x << 3) + (str[i] ^ 48);
    return x * f;
}
```
~~其实就是快读~~  


------------
主程序代码：
```cpp
#include <iostream>
#include <string>
using namespace std;

int stoi2(string str) // 支持负数
{
    int f = 1;
    if (str[0] == '-')
        f = -1, str = str.substr(1);
    int x = 0;
    for (size_t i = 0; i < str.length(); i++)
        x = (x << 1) + (x << 3) + (str[i] ^ 48);
    return x * f;
}

int main()
{
    string str;
    getline(cin, str);
    string newstr;
    for (const auto& c : str)
        if (c != ' ')
            newstr.push_back(c);
    size_t posq = newstr.find('?'), posp = newstr.find('+'), posj = newstr.find('-'), pose = newstr.find('=');
    int ans;
    if (posq > pose)
        if (posp != string::npos)
            ans = stoi(newstr.substr(0, posp)) + stoi(string(newstr.begin() + posp + 1, newstr.begin() + pose));
        else
            ans = stoi(newstr.substr(0, posj)) - stoi(string(newstr.begin() + posj + 1, newstr.begin() + pose));
    else if (posp != string::npos)
        if (posp > posq)
            ans = stoi(newstr.substr(pose + 1)) - stoi(string(newstr.begin() + posp + 1, newstr.begin() + pose));
        else
            ans = stoi(newstr.substr(pose + 1)) - stoi(newstr.substr(0, posp));
    else
        if (posj > posq)
            ans = stoi(string(newstr.begin() + posj + 1, newstr.begin() + pose)) + stoi(newstr.substr(pose + 1));
        else
            ans = stoi(newstr.substr(0, posj)) - stoi(newstr.substr(pose + 1));
    cout << ans << endl;
    return 0;
}
```
看起来可能有点乱，但是如果你仔细分析这些句子的意思，就能明白其中的意思。（~~怎么跟语文一样QAQ~~）

---

## 作者：Scarlet_Lightning (赞：1)

## 此题乍一看非常简单，实则非常非常毒瘤。

比如他会在算式当中加空格：
```cpp
1   +      45    =    ?
```
两个字符连在一块儿：
```cpp
1   +    45 =?
```
甚至——
```cpp
1     3+5   5= ?
```
结果等于68……

所以为了处理这些特别恶心的空格，需要进行各种骚操作：

- 利用cin读到空格即停的特性，过滤掉那些骚气的空格

骚操作：S+=s（把字符串s接在S的后面）

- 为了了解运算为-方程的解法，我们可以定位运算符和未知数的位置，再判断未知数在运算符前面还是后面

代码：
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
string str,S;
bool flag=1;//判断此时读入的数字是a还是b
long long a;
long long b;
long long i;
int type;//算式的类型：1:?+...||...+? 2:?-...||...-? 3:...+...=?||...-...=?
int unkownPos=-1;//未知数的位置
char ssd;//运算符
int o;//运算符的位置
long long Makenum(int begin){//在str里从begin开始读取数字
    i=begin;
    long long ret=0;
    while(str[i]>='0'&&str[i]<='9'&&i<str.length()){
        ret=ret*10+str[i]-'0';
        i++;
    }
    return ret;
}
int main()
{
	while(cin>>S)str+=S;//骚操作
	for(i=0;i<=str.length()-1;++i)
	{
		if(str[i]>='0'&&str[i]<='9'){
			if(flag==1){
				a=Makenum(i);//对a、b进行赋值
				flag=0;
			}
			else b=Makenum(i);
		}
		if(str[i]=='+'){
			type=1;//类型定为1
			o=i;
			ssd='+';
		}
		if(str[i]=='-'){
			type=2;//类型定为2
			o=i;
			ssd='-';
		}
		if(str[i]=='='){
			for(int j=i;j<str.length();++j){
				if(str[j]=='?')type=3;//寻找等号后面是否存在未知数，如果有，类型定为3
			}
		}
		if(str[i]=='?')unkownPos=i;//定位未知数
	}
	int ans;
	if(type==1)ans=b-a;//如果类型为1，直接进行运算
	else{
		if(type==2){//类型为2有点麻烦。。。
			if(unkownPos>o){//如果未知数在运算符后面
				ans=a-b;
			}
			else if(unkownPos<o&&unkownPos!=-1){//如果未知数在运算符前面
				ans=a+b;
			}
		}
		if(type==3){//类型为3时直接做计算
			if(ssd=='+')ans=a+b;
			if(ssd=='-')ans=a-b;
		}
	}
	cout<<ans<<endl;
}
```

## RT

---

## 作者：Slience_K (赞：1)

很入门的题目，考察对于字符串的处理，细心就好。。。

贴一份C++的代码

```cpp

/*

  author: Slience_K
  Belong: C++
  Pro: LGOJ P 1689 
  
*/
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
char s[ 10005 ] , sym , ch;
int data[ 3 ] , k , pos , tot , n;
int main(){
    freopen( "P1689.in" , "r" , stdin );
    while( scanf( "%c" , &ch ) != EOF ){
        if ( ch == ' ' ) continue;
        if ( ch == '\n' ) break;
        s[ n++ ] = ch;
    }
    tot = 1;
    for( int i = 0 ; i < n ; i++ ){
        if ( s[ i ] == '?' ){
            pos = tot;
            continue;
        } 
        if (( s[ i ] == ' ' )||( s[ i ] == '=' )) continue;
        if (( s[ i ] == '+' )||( s[ i ] == '-' )){
            sym = s[ i ];
            continue;
        }
        if (( s[ i ] <= '9' )&&( s[ i ] >= '0' )){
            k = 0;
            while((( s[ i ] <= '9' )&&( s[ i ] >= '0' ))||( s[ i ] == ' ' )){
                if ( s[ i ] == ' ' ) i++;
                else{
                    k = k * 10 + s[ i ] - '0';
                    i++;
                }
                if ( i == n ) break;
            }
                
            i--;
            data[ tot++ ] = k;
        }
    }
    if ( sym == '+' )
        if ( pos == 3 ) printf( "%d" , data[ 1 ] + data[ 2 ] );
        else printf( "%d" , data[ 2 ] - data[ 1 ] );
    else if ( pos == 1 ) printf( "%d" , data[ 1 ] + data[ 2 ] );
    else printf( "%d" , data[ 1 ] - data[ 2 ] );
    return 0;
}

```

---

## 作者：jacky567 (赞：1)

我的思路比较奇特，首先，把输入的数组中多余的空格去掉，再把a、b、c已知的两个数求出来,最后运算。

接下来重点说一下把a、b、c已知的两个数求出来的过程：遍历整个字符串，最开始的数一定是a，如果第一个字符是？，那么a就是不知道的数，跳过，否则，就把这个数存到a里；当遇到加号或减号的时候就存储下来，如果是加号就存1，否则，存-1；接着遇到的一定是b，b的操作和a的操作一样；接着，是等号，不需要操作；最后，c的操作和a的操作也一样。

再说明一点，把字母转化成数字会用到[sscanf](http://www.cplusplus.com/reference/cstdio/sscanf/?kw=sscanf)，如果不明白就点一下，会跳转到cpp官网的帮助，翻译一下就可以了。

完整代码如下：
```cpp
//程序内设漏洞，请勿抄袭。
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s[1000],s1[1000];
int pd(char c)
{
  if('0'<=c&&c<='9') return 0;
  if(c=='+'||c=='-'||c=='='||c=='?') return 1;
  return 0;
}
int main()
{
	int a=0,b=0,c=0,fh,k=0,q;
	gets(s1);
	for(int i=0;i<strlen(s1);i++){
		if(pd(s1[i])) s[k]=s1[i],k++;/ 
	}
	for(int i=0;i<strlen(s);i++){
		if(i==0){
			if(s[i]!='?') sscanf(s+i,"%d",&a); 
			else q=1;
		}
		if(s[i]=='+') fh=1;
		if(s[i]=='-') fh=-1;
		if(s[i-1]=='+'||s[i-1]=='-'){
			if(s[i]!='?') sscanf(s+i,"%d",&b),b*=fh;
			else q=2;
		}
		if(s[i-1]=='='){
			if(s[i]!='?') sscanf(s+i,"%d",&c);
			else q=3;
		}
	}
	if(q==1) cout<<c-b;
	if(q==2) cout<<(c-a)*fh;
	if(q==3) cout<<a+b;
}
```

---

## 作者：HPXXZYY (赞：0)

[原题链接](https://www.luogu.org/problemnew/show/P1689)

基本思路：因为本题一共只有6种情况，所以我们可以一个情况一个情况枚举，然后对每种情况求解

**[评测记录：](https://www.luogu.org/recordnew/show/17095135)**

**耗时/内存：26ms，804KB**

**语言/长度：C++，1.6KB**

**状态/分数：Accepted，100分**

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,l1,l2;
string s,s1,s2;
int main(){
    getline(cin,s);
    for(int i=0;i<s.size();)
    if (s[i]==' ') s.erase(i,1);
    else i++;
    if (s.find('+')!=-1){
        l1=s.find('+');
        l2=s.find('=');
        if (s[0]=='?'){//方程形如?+a=b
            s1=s.substr(l1+1,l2-l1-1);
            s2=s.substr(l2+1,s.size()-l2-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<b-a;
        }
        else if (s[l1+1]=='?'){//方程形如a+?=b
            s1=s.substr(0,l1);
            s2=s.substr(l2+1,s.size()-l2-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<b-a;
        }
        else{//方程形如a+b=?
            s1=s.substr(0,l1);
            s2=s.substr(l1+1,l2-l1-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<a+b;
        }
    }
    else{
        l1=s.find('-');
        l2=s.find('=');
        if (s[0]=='?'){//方程形如?-a=b
            s1=s.substr(l1+1,l2-l1-1);
            s2=s.substr(l2+1,s.size()-l2-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<b+a;
        }
        else if (s[l1+1]=='?'){//方程形如a-?=b
            s1=s.substr(0,l1);
            s2=s.substr(l2+1,s.size()-l2-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<a-b;
        }
        else{//方程形如a-b=?
            s1=s.substr(0,l1);
            s2=s.substr(l1+1,l2-l1-1);
            a=atoi(s1.c_str());//a
            b=atoi(s2.c_str());//b
            cout<<a-b;
        }
    }
    return 0;
}
```
扩展：s.substr(a,b)是求字符串s**从a起的b个字符**，即s[a..a+b-1]

s.c_str()是返回一个内容与s相同的c型字符串（返回**临时指针**）

---

## 作者：Swanwan_OWO (赞：0)

使用
### scanf("%s");
来进行空格过滤

使用C风格字符串存储过滤后的正常字符串

完成后扫描取出3个数，是问号的进行特殊赋值，是加减号的进行操作记录

接下来的~~就好做了~~

上码
```cpp
#include<cstdio>
#include<cstring>

char in[50];
int num[5]={};

int main()
{
	int pos,p=0,s=1;
	while(scanf("%s",in+p)!=EOF)//这个EOF是文件终止符
	{
		p=strlen(in);
	}
	for(int i=0;i<p;i++)
	{
		if((in[i]>='0')&&(in[i]<='9'))
		{
			num[s]*=10;
			num[s]+=in[i]-'0';
		}
		if(in[i]=='+')
		{
			pos=1;
			s++;
		}
		if(in[i]=='-')
		{
			pos=2;
			s++;
		}
		if(in[i]=='=')
		{
			s++;
		}
		if(in[i]=='?')
		{
			num[s]=-1;
		}
	}
	if(pos==1)
	{
		if(num[1]==-1)
		{
			printf("%d",num[3]-num[2]);
		}
		else if(num[2]==-1)
		{
			printf("%d",num[3]-num[1]);
		}
		else
		{
			printf("%d",num[1]+num[2]);
		}
	}
	else
	{
		if(num[1]==-1)
		{
			printf("%d",num[3]+num[2]);
		}
		else if(num[2]==-1)
		{
			printf("%d",num[1]-num[3]);
		}
		else
		{
			printf("%d",num[1]-num[2]);
		}
	}
	return 0;
}
```

---

## 作者：Drinkkk (赞：0)

/\*
P1689 题解

字符串的使用+状态判断

\*/
```cpp
#include <cstdio>//头文件
#include <cstring>//头文件
char st[101];//st数组是一个字符类型的数组（可以用来存储字符串），接下来我们将用它来存储这个方程
int main()//主函数
{
    int a=-1,b=-1,flag=-1,js=-2,wz=-2;//定义变量，a表示这个方程当中的第一个已知数，而b则是表示这个方程当中的第二个已知数，flag表示的是当前已经读完了多少个已知数，当flag=-1时表示没有读入任何一个或者已经读入到了一个，而在flag=0的时候则表示当前读入到了第二个已知数，请想一想，为什么在flag=0的时候可以表示两种状态，js表示的是这个算式当中使用了加法运算（即js=-1时）还是减法运算（即flag=0时），wz表示的是这个位置数在什么位置，如果wz=-1，那么就表明这个未知数在最左边，否则，当wz=0时，就表明这个未知数在中间，如果这个未知数在最右边的话，那么就可以根据js、a和b求出答案（因为有了这两个已知数就可以解这个方程了）
    gets(st+1);//读入这个字符串（因为读入的方程可能会有空格），所以不能够用scanf，要用gets
    int len=strlen(st+1);//len是用来存这个字符串的长度的
    for(int i=1;i<=len;i++)//从1到len进行循环，即遍历这个字符串
    {
        if(st[i]==' ')//如果这一位是空格（因为空格时多余的，所以要直接地进入到下一位）
        {
            continue;//直接进行下一次的循环
        }
        if(st[i]>='0' && st[i]<='9')//如果这一位是数字
        {
            if(flag==-1)//如果这是这个方程中的第一个未知数
            {
                a=0;//先把这个数给清零
                while(1)//一直循环（即死循环）
                {
                    if(st[i]==' ')//如果这是一个多余的空格（因为在数字中间有可能有空格，所以要在这里也要加一个判断，例如：12 345这样）
                    {
                        i++;//那么就直接将i加1
                    }
                    else if(st[i]>='0' && st[i]<='9')//否则，如果这一位上是数字
                    {
                        a=a*10+st[i]-'0';//加上去（例如a=12，这一位上是'3'，那么12乘以10之后就是120，再加上数字3，即'3'-'0'，就可以的到123了）
                        i++;//继续去下一位
                    }
                    else//如果这一位上既不是空格又不是数字，那么就表示这个数字读入完了
                    {
                        break;//跳出这个循环
                    }
                }
                flag=0;//改变flag的值，表示第一个给出的数（即已知数）已经读入完了
            }
            else if(flag==0)//如果第一个数读入完了
            {
                b=0;//那么就去读入第尔个数，然后给b初始化为0
                while(1)//一直循环
                {
                    if(st[i]==' ')//去除掉多余的空格
                    {
                        i++;//继续去下一位
                    }
                    else if(st[i]>='0' && st[i]<='9')//如果这一位上是数字
                    {
                        b=b*10+st[i]-'0';//加上去
                        i++;//继续去这个字符串的下一位找
                    }
                    else//如果读入完了
                    {
                        break;//跳出这个循环
                    }
                }
            }
        }
        if(st[i]=='+')//如果这个方程中用到了加法运算
        {
            js=-1;//那么就改js的值为-1
        }
        else if(st[i]=='-')//否则如果这个方程中用到了减法运算
        {
            js=0;//否则就将js的值改为0
        }
        if(st[i]=='?')//如果这一位上是要求的未知数
        {
            if(a==-1 && b==-1)//如果这个未知数在左边
            {
                wz=-1;//那么就将wz的值改为-1
            }
            else if(a!=-1 && b==-1)//否则如果这个未知数在中间
            {
                wz=0;//那么就将wz的值改为0
            }
            else if(a!=-1 && b!=-1)//否则如果这个未知数在右边
            {
                if(js==-1)//如果在这个方程中用到了加法运算
                {
                    printf("%d",a+b);//输出答案
                }
                else if(js==0)//否则如果在这个方程中用到了减法运算
                {
                    printf("%d",b-a);//输出答案
                }
                return 0;//结束程序（因为已经把答案输出了）
            }
        }
    }
    if(wz==-1)//如果这个未知数在左边
    {
        if(js==-1)//如果在这个方程中用到了加法运算
        {
            printf("%d",b-a);//输出答案
        }
        else if(js==0)//否则如果在这个方程中用到了减法运算
        {
            printf("%d",a+b);//输出答案
        }
    }
    else if(wz==0)//否则如果这个未知数在中间
    {
        if(js==-1)//如果在这个方程中用到了加法运算
        {
            printf("%d",b-a);//输出答案
        }
        else if(js==0)//否则如果在这个方程中用到了减法运算
        {
            printf("%d",a-b);//输出答案
        }
    }
    return 0;//结束程序
}
```

---

## 作者：Sweetlemon (赞：0)

这是一道字符串/模拟题，需要注意的有几点:

1.读入时要忽略一切空格。

2.若全部把'-'号当做负号给数，要注意数的符号。如果'?'前有负号，要带上。(如果不带上，过不了第3个点。)

下面是代码(C,5ms,8261kb)。

```cpp
#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>
long getnum(int);
char get(void);
int ques=0;
char leave=' ';
bool quessymbol=0;
int main(void){
    long a,b,c;
    a=getnum(1);
    b=getnum(2);
    c=getnum(3);
    switch (ques){
        case 1:printf("%ld",quessymbol?b-c:c-b);break;
        case 2:printf("%ld",quessymbol?a-c:c-a);break;
        case 3:printf("%ld",quessymbol?-a-b:a+b);break;
    }
    return 0;
}
long getnum(int i){
    char t;
    bool symbol=0;
    long temp=0;
    if (leave!=' ')
        t=leave;
    else
        t=get();
    if (t=='=' || t=='+')
        t=get();
    if (t=='-'){
        symbol=1;
        t=get();
    }
    if (t=='?'){
        ques=i;
        quessymbol=symbol;
        leave=' ';
        return 0;
    }
    while (isdigit(t)){
        temp=temp*10+(t-'0');
        t=get();
    }
    leave=t;
    if (symbol)
        temp=-temp;
    return temp;
}
char get(void){
    char t='\0';
    if (scanf("%c",&t))
        while (t==' ')
            scanf("%c",&t);
    return t;
}
```

---

## 作者：Samsam (赞：0)

简单的模拟

判断一下即可

```cpp
var
  ch,top:char;
  sum:array[1..3] of int64;
  ans:longint;
begin
  ans:=1;
  while not eoln do begin
    read(ch);
    if (ch<>' ') and (ch<>'-') and (ch<>'+') and (ch<>'?') and (ch<>'=') then begin
      sum[ans]:=sum[ans]*10+ord(ch)-48;
    end;
    if (ch='+') then begin
      top:=ch;
      inc(ans);
    end;
    if (ch='=') then begin
      inc(ans);
    end;
    if (ch='?') then begin
      sum[ans]:=1000000001;
    end;
    if (ch='-') then begin
      top:=ch;
      inc(ans);
    end;
  end;
  if sum[1]=1000000001 then begin
    if top='-' then begin
      writeln(sum[3]+sum[2]);
    end;
    if top='+' then begin
      writeln(sum[3]-sum[2]);
    end;
  end;
  if sum[2]=1000000001 then begin
    if top='-' then begin
      writeln(sum[1]-sum[3]);
    end;
    if top='+' then begin
      writeln(sum[3]-sum[1]);
    end;
  end;
  if sum[3]=1000000001 then begin
    if top='-' then begin
      writeln(sum[1]-sum[2]);
    end;
    if top='+' then begin
      writeln(sum[1]+sum[2]);
    end;
  end;
end.

```

---

## 作者：Ape_epA (赞：0)

咳咳，此题是一道非常考验细心程度与基本功的题目。根本不用多说，直接模拟。

上代码：

```cpp
var a:array[1..2] of longint;
    s,t:string; i,k:longint;
begin
  readln(s);
  for i:=length(s) downto 1 do
    if s[i]=' ' then
      delete(s,i,1);       //本人被坑！第二个数据若不进行处理则很难进行下面的模拟。
  s:=s+' ';
  for i:=1 to length(s)+1 do
    if s[i] in ['0'..'9'] then
      t:=t+s[i]
    else if t<>'' then
      begin
      inc(k);
      val(t,a[k]);
      t:='';
      end;      //将两个数字取出来
  k:=pos('?',s);    //找到问号
  if pos('+',s)>0 then
    begin
    if (k=1)or(s[k-1]='+') then
      writeln(a[2]-a[1])
    else writeln(a[1]+a[2]);
    end
  else if pos('-',s)>0 then
    begin
    if s[k-1]='-' then
      writeln(a[1]-a[2])
    else if k=1 then
      writeln(a[1]+a[2])
    else writeln(a[1]-a[2]);
    end;    //进行分别输出，此处过于简单，自己理解。
end.

```

---

## 作者：Catch_22 (赞：0)

```cpp
{
  n:=Length(st);
 {Judge ' '} //没这一步貌似是40
 xx:=Pos(' ',st);
  While xx<>0 do
    {
      For yy:=xx+1 to n do
        st[yy-1]:=st[yy];
      st[n]:='*';
      n--;
      xx:=Pos(' ',st);
    }
//上述可用Delete(st,xx,1)过程代替，写的时候2了，忘了这个语句。
  T:=Pos('+',st);
  Tt:=Pos('=',st);
  {X+Y=Z}//分离X,Y,Z;xx,yy,zz判断是不是'？'
//Val(st,a,b)将st字符串转换成数字a，如果st中有非法字符，将非法字符位置赋值给b
  if (t<>0)
   {
      Val(Copy(st,1,t-1),X,xx);
      Val(Copy(st,t+1,Tt-t-1),Y,yy);
      Val(Copy(st,Tt+1,n-Tt),Z,zz);
      if xx=1 Then Writeln(Z-Y);
      if yy=1 Then Writeln(Z-X);
      if zz=1 Then Writeln(X+Y);
   }
  Else
      {X-Y=Z}//同理，隐去
}
```

---

## 作者：Genius (赞：0)

这是一题比较黑的模拟题，重点在字符串的模拟，挺考验基本功。



```delphi

program solve;
var
s,t,x,y:string;
c:char;
l,u,i,a,b:longint;
begin
readln(s);
while  pos(' ',s)<>0 do delete(s,pos(' ',s),1);
if pos('+',s)<>0 then c:='+' else c:='-';
l:=pos(c,s);
i:=pos('=',s);
u:= pos('?',s);
if u<l then begin

 x:=copy(s,l+1,i-3);
 val(x,a);
 y:=copy(s,i+1,length(s));
 val(y,b);
 if c='+' then writeln(b-a) else writeln(b+a);
 end;

if (u>l)and(u<i) then begin
  x:=copy(s,1,l-1);
  val(x,a);
  y:=copy(s,i+1,length(s));
  val(y,b);
  if c='+' then writeln(b-a) else writeln(a-b);
  end;

 if (u>i) then begin
  x :=copy(s,1,l-1);
  val(x,a);
  y:=copy(s,l+1,u-l-2);
  val(y,b);
  if c='+' then writeln(b+a) else writeln(a-b);
  end;
end.


```

---


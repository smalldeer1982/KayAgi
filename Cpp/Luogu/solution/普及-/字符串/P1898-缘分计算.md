# 缘分计算

## 题目背景

缘分是一个外国人难以理解的中文名词。大致说来，缘分是一种冥冥中将两人（通常是情人）结合的力量。仅管这是种迷信，很多人——特别是女生——喜欢去计算它。

不幸的是，644 也是这样。有天，她问 DL：“甜心，可以算一下我们的缘分吗？”唉，DL 真的很讨厌这问题，但他无法拒绝。还好，DL 是个程序设计师，所以他只要找到一个看来不错的算法并写成一个缘分计算器就可以了。在网络上搜寻了几个小时后，他决定采用以下的缘分算法：

## 题目描述

第一步：取出姓名的缩写（abbreviation）并接在一起。例如，如果这对恋人叫 JiangYunFan 和 TangYuRou，他们的缩写就是 JYFTYR。第二步：将每个字母用数字字符串取代。用 $\mathrm{ST}$ 来取代 $\tt A$，$\mathrm{ST}+1$ 来取代 $\tt B$，$\mathrm{ST}+2$ 来取代 $\tt C$，……，$\mathrm{ST}+25$ 来取代 $Z$，其中 $\mathrm{ST}$ 为一个已知的正整数。例如，如果 $\mathrm{ST}=81$，$\tt A$ 就被 $81$ 取代，$\tt B$ 就被 $82$ 取代，……，$\tt Z$ 则被 $106$ 取代。上面的例子 JYFTYR 则被 $901058610010598$ 取代。

第三步：重复以下操作：将相邻的两位数相加，并写下和的个位数。不难发现这个操作每进行一次，这个数字字符串就会少一位数。当这个数字变成 $100$ 或不超过两位数（第一位是 $0$ 也算两位数）时，这个程序便停止。所得的数字就是两人的缘分。用上面的例子来说，处理的过程如下：

- $901058610010598$；
- $91153471011547$；
- $0268718112691$；
- ……
- $374$；
- $01$。

所以如果 $\mathrm{ST}=81$，JiangYunFan 和 TangYuRou 的缘分便只有 $1$。

惨了！DL 很了解 644。他知道即使这个程序计算出的缘分高达 $99$ 她仍然会不高兴。更何况 644 还对其余很多对恋人间的缘分感兴趣，要是他一个个计算会太繁琐。如果告诉你一对恋人的姓名和一个 $\mathrm{ST}$ 值，你能编一个程序算出他们的缘分吗？

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$4 ≤ L ≤ 10$，$1 ≤ \mathrm{ST} ≤ 10000$。

### 注意

如果你和你的恋人的缘分不是 $100$，不要伤心。这没有什么大不了的。

## 样例 #1

### 输入

```
DLLSS
478```

### 输出

```
100
```

# 题解

## 作者：hmh13951417981 (赞：44)

## 一道调了好久的水题 
### 其实主要是被标题吸引的 ~~虽然好像我还不太需要这种计算~~
本题主要要处理正序存储，本蒟蒻是用数组模拟的
```c
	num=s[i]-'A'+st;//算出数
	w=10000,flag=0;//由于最大就10000，所以除数最大为10000
	while(w){
		if(num>=w) flag=1;//如果发现现在这个位置比除数大，就要开始录入了
		if(flag) a[++sum]=num/w;//分离数位
		num=num%w;
		w/=10;//向下一个数位进军
	}
```
## 然后就是纯模拟，后一位加到前一位


------------

```c
#include<bits/stdc++.h>
using namespace std;
string s;
int a[101],st,i,num,sum,w;
bool flag;
int main()
{	cin>>s>>st;//输入
	for(i=0;i<s.size();i++)
	{num=s[i]-'A'+st;//算出数
	w=10000,flag=0;
	while(w){
		if(num>=w) flag=1;
		if(flag) a[++sum]=num/w;
		num=num%w;
		w/=10; 
	}	}//正序存储
	while(sum>2){
		if(sum==3&&a[1]==1&&a[2]==0&&a[3]==0){
			cout<<100; return 0;
		}//特判（如果是100 直接输出）
		for(i=1;i<sum;i++)
		a[i]=(a[i]+a[i+1])%10;//和取个位
		sum--;		      //位数减一
	}
	if(sum==1) cout<<a[1];//特判，如果只有一位就只输出一位
	else cout<<a[1]*10+a[2];//否则输出正常的数（这里这样写可以去前导0）
  	return 0;
}
```
## 最后百无聊赖的我测了几组和基友的数据
#### 输入：HMHYY 520 输出：75 	
#### 输入：HMHZYX 520 输出：97
#### 输入：HMHLSH 520 输出:77
## 可以通过这道题测一测“缘分”，但是
Don't be sad if the result of you and your sweetie is not 100. That's no big deal.


---

## 作者：帝千秋丶梦尘 (赞：15)

在给你GF/BF看这道题时切记自己先算一遍（找一个好的ST）

# ~~你们好，蒟蒻又来了~~

[小哥哥小姐姐们先看题吖](https://www.luogu.com.cn/problem/P1898)

这题。。。emmmm。。。很水啊

为啥成功率不到一半（努力忘记自己交了10次）

缘分是个很玄的东西，~~所以这题很玄~~（毕竟字符串）

此题应注意：因为全是大写，所以字符要减65（其实随便都行，自己觉得舒服就好），然后其实就是在一位位放入数组时要注意不要手残就好。

so，up代码：

```
#include<bits/stdc++.h>//好习惯（大雾
#define ri register//习惯性定义一下
using namespace std;
const int maxn=100001;
int temp,st,l,a[maxn],len,num,mod,ans;
string s;
inline void f(int k)
{
	num=5,mod=10000;
	while(k/mod<=0)
	{
		num--;
		mod/=10;
	}
}
inline void jia(int x)
{
	int m=l+num;
	while(x)
	{
		a[m]=x%10;
		m--;l++;
		x/=10;
	}//放入数组
}
int main(void)
{
	cin>>s;
	scanf("%d",&st);
	len=s.length();//string类型的长度
	for(ri int i(0);i<len;++i)
	{ 
		temp=st+s[i]-65;
		f(temp);//找位数
		jia(temp);//将每一位放入数组
	}
	while(l>=3)
	{
		if(l==3&&a[1]==1&&a[2]==0&&a[3]==0)
		{
			puts("100");
			return 0;
		}//这种特殊情况要特判
		for(ri int i(1);i<=l;++i)
		{
			a[i]=(a[i]+a[i+1])%10;
		}
		l--;
	}
	ans=a[1]*10+a[2];
	printf("%d",ans);//输出不解释了就
	return 0;//好习惯一直保持吖
}
```
# 各位看官慢走( ^_^ )/~~拜拜。

欸，还没结束呢QwQ

你们一定能发现这程序不好测试，数字还自己选。

# 那么

```
#include<bits/stdc++.h>
#define ri register
#include<windows.h>
using namespace std;
const int maxn=100001;
int temp,st,l,a[maxn],len,num,mod,ans;
string s;
void f(int k)
{
	num=5,mod=10000;
	while(k/mod<=0)
	{
		num--;
		mod/=10;
	}
}
void jia(int x)
{
	int m=l+num;
	while(x>0)
	{
		a[m]=x%10;
		m--;l++;
		x/=10;
	}
}
int main(void)
{
	cout<<"Please enter the name:";
	srand(time(NULL));
	cin>>s;
	len=s.length();
	int st=((rand()+rand())*rand()/rand())%114514;
	for(ri int i(0);i<len;++i)
	{ 
		temp=s[i]-65+st;
		f(temp);
		jia(temp);
	}
	while(l>=3)
	{
		if(l==3&&a[1]==1&&a[2]==0&&a[3]==0)
		{
			puts("100");
			return 0;
		}
		for(ri int i(1);i<=l;++i)
		{
			a[i]=(a[i]+a[i+1])%10;
		}
		l--;
	}
	int x=0;
	while(x<100)
	{
		x+=(rand()%20+10);
		if(x>100) x=100;
		cout<<"Calculating..."<<x<<"%"<<endl;
		Sleep(500);
	}
	ans=a[1]*10+a[2];
	cout<<"Calculated!"<<endl;
	cout<<"Fate Index:"<<ans;
	return 0;
}
```
### 大伙们用这个去测你们的缘分吧。
But,don't be sad if the result of you and your sweetie is not 100. That's no big deal.

祝每一对情侣999999999999999.

( ^_^ )/~~拜拜一定要给过啊

---

## 作者：Lolierl (赞：12)

感觉楼下代码都好长的啊，一道普及-其实完全没必要。

最重要的一点是数位分离，楼下某dalao用的是4个if，但我用了倒序存储，就可以用%10的方法了。题目不难，模拟一下即可。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

int main()
{
    string s;
    cin>>s;
    int st;
    cin>>st;
    int len=s.size();
    int a[len+1];
    
    for(int i=0;i<len;i++)
        a[i+1]=s[i]-65+st;//大写字母A的ASCLL码是65，注意看清是0代表A还是1代表A。
    
    int k[100001],p=0;
    for(int i=len;i>=1;i--)
        while(a[i]>0)
        {
            p++;
            k[p]=a[i]%10;
            a[i]/=10;
        }//倒序数位分离，因为倒序存储就可以不用写if了，注意一定要分离后才能进行下一步。

    for(int i=p-1;i>=3;i--)//每一次剩下i位。
        for(int j=1;j<=i;j++)
            k[j]=(k[j]+k[j+1])%10;//这题的feature，每一次都可以这样建立一一对应关系
    
    if(k[1]==0&&k[2]==0&&k[3]==1){cout<<100;return 0;}//这题只有100一个三位数，所以最后剩下三位，特判即可
    if((k[2]+k[3])%10!=0)cout<<(k[2]+k[3])%10;//注意首位为0的情况，不输出0
    cout<<(k[1]+k[2])%10;
    return 0;
} 
```
ps:AC以后测了一下我和异性朋友的缘分，嘿嘿···


---

## 作者：deamoon_2 (赞：6)

### 我竟然被一道很水的题卡了很长时间，~~我是不会告诉你我是卡在了输入上面。~~
字符串模拟，大致思路如下（建议配合代码观看）：

#### 1. 字符串处理

先输入一个字符串，然后一个一个处理，得出来的数倒序放到新数组a[]里。

处理方式：x=s[i]-'A'+st;（依据是ASCII码）

倒序方式自己模拟。

#### 2.  数组二层循环处理

第一层是处理次数，第二层是进行数组处理，把数组里的前n-1个数都算成这个数与下一个数之和的个位，如此循环，每循环一次n--。

计算方式：a[j]=(a[j]+a[j+1])%10;

#### 3. 特判，循环终止条件

循环条件设成n>2,重点就是这个特判，有三种情况：

情况一：三位数，结果是100，判断在循环内，判断成功就输出直接结束。判断方式：if(r==3&&a[1]==1&&a[2]==0&&a[3]==0)

情况二：两位数，结束判断后直接输出。输出方式：cout<<a[1] *10+a[2]<<endl;（注：这样就可以去掉0）

情况三：一位数，可能性小，但是千万不能忘！在循环结束后和输出两位数之前判断。判断方式：if(n==1)

亮代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cstdlib>
#include<cmath>
using namespace std;
int a[100001],b[10];
int main()
{
	int x=0,t,y,r=0;
	string s;
	cin>>s;
	cin>>t;
	for(int i=0;i<s.length();i++)
	{
		x=s[i]-'A'+t;
		y=0;
		while(x>0)
		{
			b[++y]=x%10;
			x/=10;
		}
		for(int j=y;j>0;j--)
		a[++r]=b[j];
	}
	/*for(int i=1;i<=r;i++)
	cout<<a[i];*/
	while(r>2)
	{
		for(int j=1;j<r;j++)
		{
			a[j]=(a[j]+a[j+1])%10;
			//cout<<a[j];
		}
		//cout<<endl; 
		r--;
		if(r==3&&a[1]==1&&a[2]==0&&a[3]==0)
		{
			cout<<100<<endl;
			return 0;
		}
	}
	if(r==1)
	cout<<a[1];
	else
	cout<<a[1]*10+a[2]<<endl;
	return 0;
}
```



祝各位2019 NOIP RP++

---

## 作者：__Chtholly (赞：4)

## 一道水题
其实这道题真不难(假的

但是想要想全很难

**思路:①将读入的串的某位值+ST ②将这个经过转换的值一位一位装入一个=字符串数组,后面进行模拟 ③进行简单递推(或者说是模拟**

### ①处理:
```cpp
for(register int i=1;i<=n;++i)//转换成数字 
	b[i]=ch[i]-'A'+ST;
```
### ②处理
```cpp
void kkkAKIOI()//将数字处理成字符串 
{
	for(register int i=n;i>=1;--i)
	{
		while(b[i])
		{
			maked[++len]=b[i]%10+'0';
			b[i]/=10;
		}
	}
	return ;
}
```
### ③处理
```
void work()
{
	while(len-2&&(maked[1]!='0'||maked[2]!='0'||maked[3]!='1'))//"len-2"为判断是不是二位数,001特判有没有100的情况 
	{
		for(int i=1;i<=len-1;++i)
			maked[i]=(maked[i]-'0'+maked[i+1]-'0')%10+'0';
		len--;//长度-1 
//		for(register int i=1;i<=len;++i)
//			printf("%c",maked[i]);
//			printf("\n");
	}
	int cl_zero=len;//处理前导0 
	while(maked[cl_zero]=='0')cl_zero--;
	for(register int i=cl_zero;i>=1;--i)
		printf("%c",maked[i]);
}
```

我们提交,发现:
![](https://i.loli.net/2020/10/31/hNirEgDCUIJxnft.png)
#### 啊？为什么这样子啊！！！
我们得冷静分析一下

最终我们盯住这一行:
```cpp
int cl_zero=len;//处理前导0 
	while(maked[cl_zero]=='0')cl_zero--;
	for(register int i=cl_zero;i>=1;--i)
		printf("%c",maked[i]);
```
然后我们想:会不会出现**全是0**的情况呢？

创个数据:
![](https://i.loli.net/2020/10/31/hz4NDvr26BWlLqZ.png)

#### 果然！
![](https://i.loli.net/2020/10/31/p7D8XhN6bALn4Gc.png)

为啥啥都没有呢？

我们可以看出:若出现全是0的情况,就会被当作前导0**全部删除**！

##### 最终,~~作为蒟蒻的我~~,只能写一个putcha来检查是否有输出,如果有,就是已经输出答案了；若无，则最终输出0

### ③改完后的代码

```cpp
void work()
{
	while(len-2&&(maked[1]!='0'||maked[2]!='0'||maked[3]!='1'))//"len-2"为判断是不是二位数,001特判有没有100的情况 
	{
		for(int i=1;i<=len-1;++i)
			maked[i]=(maked[i]-'0'+maked[i+1]-'0')%10+'0';
		len--;//长度-1 
//		for(register int i=1;i<=len;++i)
//			printf("%c",maked[i]);
//			printf("\n");
	}
	int cl_zero=len;//处理前导0 
	int putcha=0;//有没有全为0的情况 
	while(maked[cl_zero]=='0')cl_zero--;
//	printf("%d\n",cl_zero);
	for(register int i=cl_zero;i>=1;--i)
		printf("%c",maked[i]),putcha++;//输出 //若有全为0的情况,putcha必为1
	if(putcha==0)
		printf("0"); 
}
```

最终：[完美ac！](https://www.luogu.com.cn/record/40867952)

~~PS:接下来才是正片~~

## 献上我的代码
```cpp
#include<cstdio>
#include<cstring>
#include<string>
int n;
char ch[15];
int b[15];
int ST;
char maked[105],len;
void kkkAKIOI()//将数字处理成字符串 
{
	for(register int i=n;i>=1;--i)
	{
		while(b[i])
		{
			maked[++len]=b[i]%10+'0';
			b[i]/=10;
		}
	}
	return ;
}
void work()
{
	while(len-2&&(maked[1]!='0'||maked[2]!='0'||maked[3]!='1'))//"len-2"为判断是不是二位数,001特判有没有100的情况 
	{
		for(int i=1;i<=len-1;++i)
			maked[i]=(maked[i]-'0'+maked[i+1]-'0')%10+'0';
		len--;//长度-1 
//		for(register int i=1;i<=len;++i)
//			printf("%c",maked[i]);
//			printf("\n");
	}
	int cl_zero=len;//处理前导0 
	int putcha=0;//有没有全为0的情况 
	while(maked[cl_zero]=='0')cl_zero--;
//	printf("%d\n",cl_zero);
	for(register int i=cl_zero;i>=1;--i)
		printf("%c",maked[i]),putcha++;//输出 //若有全为0的情况,putcha必为1
	if(putcha==0)
		printf("0"); 
}
int main()
{
	scanf("%s\n",(ch+1));
	n=strlen(ch+1);
	scanf("%d",&ST);
	for(register int i=1;i<=n;++i)//转换成数字 
		b[i]=ch[i]-'A'+ST;
	kkkAKIOI();//再转换成字符串 
//	for(register int i=len;i>=1;--i)
//		printf("%c",maked[i]);
	work();//最后模拟 
	return 0;
}
```
# 最终:祝大家NOIP2020 rp++！


---

## 作者：我是小何子啊 (赞：2)

# **~~这道题提交了3次才过，淦！~~**

**思路如下（仅供参考，杜绝抄袭）：**
	
    
 **首先要把他们的st值都算下来，把它们一个一个数位的存进我们的f数组里，然后这里有个贼重要的东西——栈！因为我是用st%10得到的数字，此时存进去数字是反的！所以先用栈存一遍，再才把它们一个个弹出栈，存进f数组。最后按照常规方法：f[i]=(f[i]+f[i+1])%10，因为是从1~n依次计算，所以不用考虑其他情况**
 
**偶的代码：**

```cpp
#include<iostream>
#include<cstring>
#include<stack>//stack函数栈
using namespace std;
string s;
int st,f[1001],n,t;
int main(){
	cin>>s>>st;//输入
	for(int i=0;i<s.length();++i){
		t=int(s[i]-'A')+st;//计算st值
		stack<int>a;
		while(t>0){
			a.push(t%10);//把他的个，十，百...位存进栈里
			t/=10;
		}
		while(!a.empty()){//如果栈没空就继续
			f[++n]=a.top();//一个个又存进f数组里，n记录数字的个数，方便后面计算
			a.pop();//每存一个就弹出一个
		}
	}
	while(n>2){//当数字个数不少于2就继续运算
		if(n==3&&f[1]==1&&f[2]==0&&f[3]==0){
			cout<<"100";//题目给出的特判
			return 0;
		}
		for(int i=1;i<n;++i){
			f[i]=(f[i]+f[i+1])%10;//题目给出的计算方法
		}
		--n;//记得每计算一次就会少一个数字
	}
	cout<<f[1]*10+f[2];//输出剩下的两位数
	return 0;
}
```


---

## 作者：PTC06 (赞：2)

```cpp
var c,i,n,f,t,t1:longint;  //呵呵，这里定义变量
    s,st,s1,l,st1:string;
procedure search(s:string);     //自定义一个过程来把姓名缩写转化为数字，方便些
begin
  for i:=1 to length(s) do        //把题目中说的姓名缩写搜索一遍
    begin
      c:=ord(s[i]);                     //把字符串的这一位ord后的值赋给c
      c:=c-65;                          //全都是小写字母，而小写字母ord后的值减65就等于它在字母表的位置减一
      c:=c+n;                          //再加上题目中所说的那个值
      str(c,st1);                        //把最后的结果转化为字符串
      s1:=s1+st1;                    //把姓名缩写所代表的数字加起来
    end;
end;
procedure sort;                //接下来就到了下一步，把它不停地将这一位和后一位加起来
begin
  st:='';                             //刚开始清空
  for i:=1 to length(s1)-1 do
    begin
      val(s1[i],t);                //把这一位转化为数字
      val(s1[i+1],t1);          //下一位也是
      f:=t+t1;                   //加起来
      str(f,l);                      //转化为字符串
      st:=st+l[length(l)];     //加上它的个位，所以必须是l[length(l)]
   end;
  s1:=st;      //把加完后的赋给没加之前的
end;
begin
  readln(s);       //读入两个人的姓名缩写
  readln(n);      //输入题目所描述的值
  search(s);        //把姓名缩写变成数字
  repeat
    sort;             //不停的重复将这一位和下一位加起来
  until (length(s1)=2) or (s1='100');    //直到长度为2或等于100
  if s1[1]='0' then delete(s1,1,1);    //删了前导0
  writeln(s1);    //最后输出
end.
```

---

## 作者：keyingkai (赞：2)

这就是单纯的模拟.

```delphi

var ch,ch1,t:string;
  st,i:longint;
begin
  readln(ch);
  readln(st);
  for i:=1 to length(ch) do
  begin
    str(ord(ch[i])-65+st,t);//依题意加上st的值
    ch1:=ch1+t;
  end;
  ch:=ch1;
  ch1:='''';
  while length(ch)>3 do   //先处理到四位，100特判
  begin
    for i:=1 to length(ch)-1 do
    begin
      str((ord(ch[i])+ord(ch[i+1])-48-48)mod 10,t);
     ch1:=ch1+t;
    end;
    ch:=ch1;
    ch1:='''';
  end;
  if ch=''100'' then begin writeln(100);halt;end;
   for i:=1 to length(ch)-1 do
    begin
      str((ord(ch[i])+ord(ch[i+1])-48-48)mod 10,t);//把3位处理成2位
     ch1:=ch1+t;
    end;
  if ch1[1]=''0'' then writeln(ch1[2]) else writeln(ch1);//删去前导0
end.

```

---

## 作者：_Luminous (赞：1)

#### ` 解题思路 & 方法


------------
题意其实很好理解，代码也好打，解题重点是数字存储，这里借鉴了一位dalao的方法——**倒序存储** 。
```cpp
for(int i=0;i<len;i++)
	a[i]=s[i]-'A'+st;//把字符转化成数字
for(int i=len-1;i>=0;i--)//倒序存储
  	while(a[i]>0)
  		ans[++cnt]=a[i]%10,a[i]/=10;
```
将相邻位相加：
```cpp
for(int i=cnt-1;i>=3;i--)//i>=3是因为要把这个值变为变成 100（三位）或不超过两位数
        for(int j=1;j<=i;j++)
            ans[j]=(ans[j]+ans[j+1])%10;
```


#### · Code
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int st,len,cnt,a[1000005],ans[100005];//因为题目中没有给出s数组的长度，所以我们尽量定义大一些
string s;
int main(){
	ios::sync_with_stdio(false);//加速黑科技（）
    cin>>s>>st;
    len=s.size();
    for(int i=0;i<len;i++)//将字符转化成数字
        a[i]=s[i]-'A'+st;
    for(int i=len-1;i>=0;i--)//存储
    	while(a[i]>0)
            ans[++cnt]=a[i]%10,a[i]/=10;
    for(int i=cnt-1;i>=3;i--)//相邻位相加
        for(int j=1;j<=i;j++)
            ans[j]=(ans[j]+ans[j+1])%10;
    if(ans[3]==1 && !ans[2] && !ans[1]){//特判最后的值为100
		cout<<100<<endl;
		return 0;
	}
    if((ans[2]+ans[3])%10)//判断最后是否是两位数
		cout<<(ans[2]+ans[3])%10;
    cout<<(ans[1]+ans[2])%10<<endl;
    return 0;
}
```


---

## 作者：Eason_AC (赞：1)

## Content
根据一个长度为 $l$，只含大写字母的字符串算出它的“缘分值”。

步骤如下：

1. 给定一个数 $st$。
2. 将字符串里面的所有字母改成数字（如 A 改成 $st$，B 改成 $st+1$，……，Z 改成 $st+25$），并拼接成一个数字。
3. 将这个数字中相邻数位的两个数相加并依次写下它的个位数，重新拼接出新的数字。
4. 对这个新的数字重复操作 $3$，直到这个数字 $\leqslant 100$ 为止，此时这个数字即为需要操作的字符串的“缘分值”。

**数据范围：$4\leqslant l\leqslant 10,1\leqslant ST\leqslant 10000$。**
## Solution
这道题目是一道很简单的模拟，如果对题意不懂的建议先去题面中的解释看看，再来看题解。

就只需要将所有的字符根据 $st$ 转化为数字，然后一个一个拼接，最后再模拟一下整合的过程就好了。完全就是按照题目中所说的模拟一遍就好了。
## Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <iostream>
using namespace std;

string s;
int t, sum[17], digits[1000007], cnt;

int main() {
	cin >> s >> t;
	int n = s.size(), sumtot = 0;
	for(int i = 0; i < n; ++i) {
		sum[i] = t + (s[i] - 'A'); 
		int tmp[17] = {0};
		while(sum[i]) {
			tmp[++tmp[0]] = sum[i] % 10;
			sum[i] /= 10;
		}
		for(int i = tmp[0]; i >= 1; --i)
			digits[++cnt] = tmp[i];
	}
	while(cnt >= 3) {
		if(cnt == 3) {
			for(int i = 1; i <= 3; ++i)
				sumtot = sumtot * 10 + digits[i];
			if(sumtot == 100)	break;
		}
		for(int i = 1; i < cnt; ++i) {
			digits[i] = (digits[i] + digits[i + 1]) % 10;
//			printf("%d", digits[i]);
		}
//		puts("");
		cnt--;
	}
	if(sumtot == 100)	printf("%d", sumtot);
	else {
		sumtot = 0;
		for(int i = 1; i <= cnt; ++i)
			sumtot = sumtot * 10 + digits[i];
		printf("%d", sumtot);
	}
	return 0;
}
```

---

## 作者：Blue_wonders (赞：1)

# 我的第好几篇题解，绝对详细（看不懂你打我）~~atoi，itoa不能用~~

#### 先给大家排几个坑
- atoi，itoa俩函数不能用（这个是字符串和整数互相转化的函数，题解最下方有解释）~~我就是用了这个编译错误了一次~~
- 然后是前缀的0要去掉，不去掉是wa
#### 坑不多，然后是方法
- 首先将输入的字符串全部转化为数字，
- 然后一次次将两个数求和
- 最后判断是否为两位数或者是100
- 输出
#### 详解在代码中
```cpp
#include<bits/stdc++.h>
//万能头文件，不知道为啥突然喜欢上了这个
using namespace std;
char h[11];
char s[6000];
int st,m=0;
int build(char a){
	int x=a+st-65;//x表示这个字母所表示的数字
	char y[6]={0,0,0,0,0,0};
	int o=1,u=x;
	while(u%10!=u){//用while求出x的位数，用o表示
		u=u/10;
		o++;
	}
	for(int i=o-1;i>=0;i--){//将整数x转化为字符串y
		y[i]=(x%10+48);
		x=x/10;
	}
	for(int i=0;i<o;i++){//将y并入总的字符串s中，s记录所有数字表示内容
		s[m]=y[i];
		m++;//m表示s的个数，随着每个y的并入而增加
	}
}
int marge(char a,char b){//合并函数
	int p;
	p=(a-48)+(b-48);//p为a+b的大小（整数）
	if(p%10==p)return (char)p+48;//如果p为1位数，就返回p的值（字符串）
	else return (char)((p%10)+48);//如果p为两位数，返回后一位的值（字符串）
}
int main(){//先看主函数
	cin>>h>>st;//按题目要求输入
	int l=strlen(h);//l表示输入原字符串长度
	for(int i=0;i<l;i++){
		build(h[i]);//将每个数都做处理
	}
//处理完后得到一个完整的字符串s
	while(m>=3){//只要不是一位数和两位数就开始累加
		if(s[0]=='1'&&s[1]=='0'&&s[2]=='0'&&m==3){//特判是否为100
			cout<<s;
			return 0;
		}
		for(int i=1;i<m;i++)s[i-1]=marge(s[i-1],s[i]);//每相邻两个数相加，取最后一位放在前一个数的位置上
		s[m-1]=0;//最后一位没有数，所以变成0
		m--;数的位数减少1；
	}
	if(s[0]=='0')cout<<s[1];//如果第一位是0，那么就只输出第二位
	else cout<<s;//如果第一位不是零，那么都输出
	return 0;//结束程序
}
```
谢谢大家能看我的题解！


------------
ps：这是atoi和itoa的部分，可以看看
```cpp
//用到库是这个
#include<cstdlib>
```
itoa是整数化字符串的函数
```cpp
int build(char a){
    int x=a+st-65;
    char y[6];
    itoa(x,y,10);
//整数转字符串的函数，x是整数，y是转化完的字符串，10代表的是进制
    int z=strlen(y);
    for(int i=0;i<z;i++){
        s[m]=y[i];
        m++;
    }
}
```
atoi是字符串化整数的函数
```cpp
    cout<<atoi(s);//这是最后输出
    //字符串化整数后前面的0自动舍去
    //不用判断了
```


---

## 作者：Enterpr1se (赞：0)

# ~~这可能是全谷实用价值最高的一道题~~
好了，这题本身很基础，基本没有难度，全部模拟，数据规模也不大。（简单到蒟蒻楼主基本没有调试就AC了。）  
本来计划用循环做，但是后来发现这东西**代码极长**，**难以调试**，于是毅然转向了另一种做法：  
## 递 归
做法非常基础，比搜索什么的简单多了：  
```cpp
//lg-1889
#include<iostream>
#include<string>
using namespace std;
short st,l;
string name,num,ans;
string strint(short a){//将int转化为string 
	string ret;
	char dig;
	while(a!=0){
		dig=(a%10)+48;
		ret=dig+ret;
		a/=10;
	}
	return ret;
}
string sht(string a){//shorten的缩写，但是看着有点奇怪（大雾 
	if(a.length()==2 || a=="100") return a;//若得出两位或100则直接返回 
	short len=a.length();
	string ret;
	for(int i=0;i<len-1;++i){
		ret+=((a[i]+a[i+1]-96)%10)+48;//第i位数字形式+第(i+1)位数字形式的和模10，转换为字符 
	}
	return sht(ret);//递归 
}
int main(){
	ios::sync_with_stdio(false);//输入加速の黑科技 
	cin>>name>>st;
	l=name.length();
	for(int i=0;i<l;++i) num+=strint(st+name[i]-65);
	ans=sht(num);
	if(ans[0]=='0') cout<<ans[1];//判断是否有前置0 
	else cout<<ans;
	return 0;
}
```
好了，快输入你和那个TA的名字，来测测你们的缘分吧！  
~~幸福都是你们的（猛男哭泣~~  
~~另：如果测出你和你兄弟有什么奇♂妙的缘分，本人概不负责~~

---

## 作者：xiangyanhao (赞：0)

由于程序中需要用到一些操作，这里先声明几个函数：
```cpp
string tostr(int n){ //将整数转换为字符串，例如12->"12"
	string s = "";
	while(n != 0){
		s += n%10+'0';
		n /= 10;
	}
	string r = "";
	for(int i = s.size()-1;i >= 0;i--){
		r += s[i];
	}
	return r;
}
char csum(char a,char b){ //计算两个数字字符的和，例如'3','2'->'5'
	int na = a-'0';
	int nb = b-'0';
	return (na+nb)%10+'0';
}
```

下面写主程序：


```cpp
string str;
int st;
cin >> str >> st;
string num = ""; //表示算出的数字串
for(int i = 0;i < str.size();i++){
	char ch = str[i];
	num += tostr(ch-'A'+st); //求出数字串，以便之后操作
}
```
接下来开始对数字串进行处理：
```cpp
while(num.size()>2&&(!(num.size()==3&&num[0]=='1'&&num[1]=='0'&&num[2]=='0'))){
	string temp = "";
	for(int i = 0;i < num.size()-1;/*注意需要减1，否则num[i+1]会越界访问*/i++){
		temp += csum(num[i],num[i+1]);
	}
	num = temp;
}
```
然后，输出 $num$，此时 $num$ 即为答案。
```cpp
bool print = false; //避免输出前导0
for(int i = 0;i < num.size();i++){
	if(num[i]!='0') print = true;
	if(print) cout << num[i];
}
if(!print) cout << 0;
```


---

## 作者：AveMarina (赞：0)

## string解

### 首先考虑下怎么把数字转换成字符串
因为题目给出的字符串只包含大写字符，所以我们可以用 __当前字符减去'A'得到这个字符在26个大写字母中的位置__。然后对于每一位进行了如上运算的数字来说，__它不一定是一个0~9的数字__，因此我们无法直接将其转换成字符。那么我们可以把这个数字的 __每一位分离出来__，单独转换为字符再加起来合并成一个字符串。

但是对于上面所说的字符串，还存在一个问题。比如我们把数字123分离后，按顺序来说我们得到的字符串应该是 __321__，因此，我们还要 __进行一次旋转操作__，将运算出来的字符串转换为 __正确顺序的字符串__。

### 其次考虑下解是否合法
在我们把数字转换为字符串后，还要对其相邻的数字进行相加。__出现解的情况有：当前字符串为"100"，或者当前字符串长度小于等于2__。针对上面的条件而言，我们可以将原来的字符串 __进行若干次相加操作，直到满足了这两个条件之一__

## 正题
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
void rev(string& str) {
	int l = 0, r = str.size() - 1;
	while (l < r) swap(str[l++], str[r--]); // 利用双指针算法旋转字符串 
}

int main() {
	int st;
	string str, res, temp;
	cin >> str >> st;
	int t, sLen = str.size();
	for (int i = 0; i < sLen; i++) {// 数位分离转成字符串，为了方便这里还得来次翻转 
		t = st + str[i] - 'A', temp = "";
		while (t) temp += (char)(t % 10 + '0'), t /= 10;
		rev(temp), res += temp;// 翻转我们得出来的数字
	}
	int rLen;
	while (true) { // 循环处理，直到出现了合法解
		temp = "";
		rLen = res.size();
		if (rLen <= 3) {
			if (res == "100") break;
			else if (rLen <= 2) break;
		}
		for(int i = 0; i < rLen - 1; i++) temp += (char)((res[i] - '0' + res[i + 1] - '0') % 10 + '0'); // 按题目要求取出相邻两个数的个位再把它转成字符 
		res = temp; // 更新解 
	}
	if (res[0] == '0') cout << res[1]; // 特判下首字符是不是0 
	else cout << res;
	return 0;
}
```

---

## 作者：血色黄昏 (赞：0)

23333 纯模拟啊

~~谷对python好像不太友好~~

废话少说 上代码

```python
s = input()
ST = int(input())#输入
l = ""
for i in s:
    l += (str(ord(i) + ST - ord('A')))#string不能改里面的字符，所以要用另一个string处理
while len(l) > 2 and l != "100":#如果是两位数或者100了就输出
    s = ""
    for i in range(1, len(l)):
        s += (str((int(l[i]) + int(l[i - 1])) % 10))#加到前一位，%10
    l = s#重新赋值
print(int(l))#输出
```

# ~~抄代码棕名~~

---

## 作者：STILL_ALONE (赞：0)

由于我越来越蒟了，所以我来水普及-的题了。  
~~希望我一个月之内交紫题题解~~  
一道很水的字符串模拟吧  
```cpp
#include <string>
#include <iostream>
using namespace std;
string str;
int t[15],num[100005];
int n,len,k,ans;
int main() 
{
	cin >> str;//读入
	cin >> n;
	len = str.length();
	for( int i = 0; i < len; ++i)
	{
		t[i] = str[i] - 'A' + n;//定义每个字母的数值
	}
	k = 0;
	for( int i = len - 1; i >= 0; --i)
	{
	    while(t[i] > 0)
	    {
	    	num[k] = t[i] % 10;
	    	t[i] /= 10;
	    	++k;//进位
		}
	}
	/*
	cout << k << endl;
	for( int i = 0; i < k; ++i)
	{
		cout << num[i];
	}
	cout << endl;
	*/
	for( int i = k - 1; i >= 0; --i)
	{
		for( int j = 0; j < i; ++j)
		{
			num[j] = (num[j] + num[j+1]) % 10;//注意这里数位要倒着判，这样就不会管什么前导零
	    }
	    if(i == 3)
	    {
	    	ans = num[2]*100+num[1]*10+num[0];
	    	if(ans == 100) break;
		}
		else if(i == 2)
		{
			ans = num[1]*10+num[0];
			break;
		}//特判三位数与两位数
	}
	cout << ans << endl;//完美输出
	return 0;
}


---

## 作者：_•́へ•́╬_ (赞：0)

## 按题意~~摸妳~~（模拟）即可
```cpp
#include<bits/stdc++.h>//懒人专用头文件
int ans[100000],l,st;char*name;
void add(int num)
{
	if(!num)return;
	add(num/10);//用中间递归实现
	ans[l++]=num%10;//加上这个数字
}
main()
{
	name=new char(11);//申请新空间
	scanf("%s%d",name,&st);//输入
	for(register int i=0;i<strlen(name);++i)add(name[i]-'A'+st);//字符串改成数字串
	if(l==1)printf("%d",ans[0]);//特判，如果输入的只有一个字母，且st为一位数
	for(;l>3;--l)for(register int i=0;i<l-1;++i)ans[i]=(ans[i]+ans[i+1])%10;//相邻各位加起来
	if(l==3)
	{
		if(ans[0]*100+ans[1]*10+ans[2]==100){puts("100");return 0;puts("congratulations");}
		for(register int i=0;i<l-1;++i)ans[i]=(ans[i]+ans[i+1])%10;//相邻各位再加一遍
	}
	printf("%d",ans[0]*10+ans[1]);//输出
}/**/
```

---


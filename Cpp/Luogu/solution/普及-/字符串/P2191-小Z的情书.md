# 小Z的情书

## 题目背景

众所周知，小 Z 是高富帅的典范和代表，所以他很很多很多的妹纸。小 Z 要写情书给他的妹纸了，作为一个谨慎的人，他当然不会直白的写在纸上（否则被那群损友发现岂不糟了？）。

## 题目描述

虽然小 Z 谨小慎微，但是还是被狡猾的小 D 给发现了其中的玄机。作为一个大方的人，小 D 自然要把这个秘密拿出来给大家共享啦~小 Z 开始有两张 $N \times N$ 大小的纸一张是透明的、一张是有字的。然后小 Z 把透明的纸上有些格子涂黑了。接着把这两张纸一起给他的妹纸，妹纸事先和小 Z 约定好了，按照如下方法阅读：首先先把透明的纸盖在另一张纸上，然后把露出来的字母从上到下从左到右写下来，然后转个 $90$ 度，再读一遍……这样子一共读四遍……详见样例。

小 D 不知从哪把情书弄来了，请大家一起来欣赏，顺便请大家把内容打出来看看。


## 说明/提示

$1 \leq N \leq 1000$。

## 样例 #1

### 输入

```
4
##O#
#O#O
####
###O
ARAO
PCEM
LEEN
TURC```

### 输出

```
ACMCENTRALEUROPE```

# 题解

## 作者：Diaоsi (赞：20)

# ~~带模拟题~~
好吧言归正传,由样例可知是顺时针旋转

观察下面两个卡片

    ###O# #####
    ##### #####
    ##### #####
    ##### ####0
    ##### #####
设原坐标为(x,y)

不难发现旋转90度后坐标可以表示为(y,len-x)

len为卡片的边长+1

于是我们可以用一个函数去处理旋转的过程
### 旋转函数：

```cpp
void turn(){
	for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            TEMP[i][j]=0;//初始化
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])TEMP[j][len-i]=1;//临时存放
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			P[i][j]=TEMP[i][j];//转移
}
```
在这个函数中，我使用了一个bool数组P去储存卡片的状态(0为'#',1为'O')

同时使用一个临时矩阵(TEMP)去记录旋转后的卡片，目的是防止重复操作

最后再将结果存入原始的矩阵P中
### 遍历操作：
```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])ans[cnt++]=s[i][j];
```

在主函数中每旋转一次就将文字卡片遍历一次

s[N][N]为文本卡片

对于结果，我们可以使用一个字符数组ans[N]和计数器cnt来存储

cnt初始化为0

### 完整代码奉上：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10010,M=1000010;
bool P[N][N],TEMP[N][N];
char s[N][N],ans[M];
int n,cnt,len;
void turn(){
	for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            TEMP[i][j]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])TEMP[j][len-i]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			P[i][j]=TEMP[i][j];
}
int main(){
	cin>>n;len=n+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char a;
			cin>>a;
			if(a=='O')P[i][j]=1;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>s[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])ans[cnt++]=s[i][j];
	turn();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])ans[cnt++]=s[i][j];
	turn();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])ans[cnt++]=s[i][j];
	turn();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(P[i][j])ans[cnt++]=s[i][j];
	for(int i=0;i<=cnt;i++)cout<<ans[i];
	return 0;
}
```
### 如有错误请在评论区指出

---

## 作者：CSP_Sept (赞：11)

# [题目链接](https://www.luogu.org/problem/P2191)

这是我通过的第一道黄题，对于一个刚学OI仅三个月的人（注：我）竟然能通过，难度还是较低的。

先仔细观察：

$1.N\leqslant1000$

$2.$边长为$len$的字符方阵转化后，$(i,j)\rightarrow(j,len-i-1)$

那么就先定义一个交换函数$swaps()$。

代码：

```cpp
char swaps(char zy[1000][1000],int n){
	char yb[1000][1000];
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			yb[j][n-i-1]=zy[i][j];
		}
	}
	for(int h=0;h<n;h++){
		for(int s=0;s<n;s++){
			zy[h][s]=yb[h][s];
		}
	}
}
```

然后读入$N$和两个字符阵。

```cpp
char zy[1000][1000],yb[1000][1000],zf[1000][1000];
int main(){
	int len,si;
	cin>>len;
	for(int o=0;o<len;o++){
		for(int p=0;p<len;p++){
			cin>>zy[o][p];
		}
	}
	for(int u=0;u<len;u++){
		for(int v=0;v<len;v++){
			cin>>zf[u][v];
		}
	}
```

接着循环四次，将$O$覆盖着的字符打印出来。

```cpp
if(zy[a][b]=='O') cout<<zf[a][b];
```

每次循环结束之前使用$swpas$函数。

```cpp
swaps(zy,len);
```

最后$return$ $0$。

完整代码奉上：

```cpp
#include <bits/stdc++.h>
using namespace std;
char swaps(char zy[1000][1000],int n){
	char yb[1000][1000];
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			yb[j][n-i-1]=zy[i][j];
		}
	}
	for(int h=0;h<n;h++){
		for(int s=0;s<n;s++){
			zy[h][s]=yb[h][s];
		}
	}
}
char zy[1000][1000],yb[1000][1000],zf[1000][1000];
int main(){
	int len,si;
	cin>>len;
	for(int o=0;o<len;o++){
		for(int p=0;p<len;p++){
			cin>>zy[o][p];
		}
	}
	for(int u=0;u<len;u++){
		for(int v=0;v<len;v++){
			cin>>zf[u][v];
		}
	}
	for(si=1;si<=4;si++){
		for(int a=0;a<len;a++){
		    for(int b=0;b<len;b++){
			    if(zy[a][b]=='O') cout<<zf[a][b];
		    }
	    }
	    swaps(zy,len);
	}
	return 0;
}
```


---

## 作者：我的父亲 (赞：6)

本蒟蒻第一次写题解，请别喷。

当我看到这题时，马上想到了模拟（bao li）。

我的思路是用两个数组用模拟（bao li）来实现旋转（顺时针）。

我简单地用模拟（bao li）画了个图:

    旋转前    旋转后

    ##O#     ####
    #O#O     ##O#
    ####     ###O
    ###O     O#O#
原来如此

       旋转前的1,1是旋转后的1,n。
       旋转前的1,2是旋转后的2,n。
       旋转前的2,1是旋转后的1,n-1。
       旋转前的3,1是旋转后的1,n-2。
       ......
因此我们可以知道旋转前的i,j就是旋转后的j,n-(i-1)。

然后就AC啦；
下面贴代码；
```
#include<bits/stdc++.h>
using namespace std;
int n,i,j,h;
char a[1001][1001],b[1001][1001],c[1001][1001];
bool l=0;
int main()
{
	cin>>n;
	for(i=1;i<=n;i++)
	   for(j=1;j<=n;j++)
	      cin>>a[i][j];//输入不多说
	for(i=1;i<=n;i++)
	   for(j=1;j<=n;j++)
	      cin>>b[i][j];
	for(int k=1;k<=4;k++)//旋转4次
	{
		for(i=1;i<=n;i++)
	     for(j=1;j<=n;j++)
	       if(a[i][j]=='O'&&l==0)//这应该都可以理解
	         cout<<b[i][j];
	       else 
		       if(c[i][j]=='O'&&l==1)
	            cout<<b[i][j];
	    if(!l)//开始旋转
	      for(i=1;i<=n;i++)
	        for(j=1;j<=n;j++)
	          c[j][n-(i-1)]=a[i][j],l=1;//公式套用
	    else
	      for(i=1;i<=n;i++)
	        for(j=1;j<=n;j++)
	          a[j][n-(i-1)]=c[i][j],l=0;
	}
	return 0;
}
```
楼下dalao学不来。orz。

---

## 作者：loi_hjh (赞：6)

# 题目中说是旋转90度，通过样例，我们可以得知，是顺时针旋转 

附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
char a[1001][1001],b[1001][1001],c[1001][1001];//a是读入的#和O，b是密钥，c是旋转后的 
int n;//情书大小 
inline void gg(int x){
	if(x%2==0){//双数就用c来存a，单数a存c，节约空间 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				c[j][n-i+1]=a[i][j];//将其逆时针旋转，最开始转反了，如果写成c[i][j]=a[j][n-i+1]是逆时针转 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(c[i][j]=='O') printf("%c",b[i][j]);//是O就输出这里的b（最开始不知为啥经常不输出） 
		return;//不想写else（等价） 
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[j][n-i+1]=c[i][j];//反过来存上一次变化后的 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]=='O') printf("%c",b[i][j]);//是O就输出这里的b				
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];//读入不解释 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>b[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]=='O') printf("%c",b[i][j]);//先输出第一遍没旋转的，如果是O，就输出这个位置的b 
	for(int i=2;i<=4;i++)
		gg(i);//函数看着舒服 
	return ~~(0-0);
}


```

---

## 作者：5ab_juruo (赞：5)

# 方法和各位dalao的都差不多，~~（为什么都要现场转呢？）~~

我们可以存储一个三维数组，记录下在4种方向上洞洞的规律。那么规律又是什么呢？

>请看：

>对于一个洞而言，4种方向上的卡片会长这样：

>%%O% %%%%

>%%%% %%%%

>%%%% %%%%

>%%%% %O%%

>------

>%%%% %%%%

>%%%% O%%%

>%%%O %%%%

>%%%% %%%%

假设刚开始的坐标是$(x,y)$

那么，一次顺时针后（假设长度为$len$）应该是$(y,len-x)$

我们发现，$y$坐标变成$len-x$，而$x$坐标变成上一个状态的$y$坐标。

同理，我们可以把剩下两个状态的$x,y$坐标都推出来：

顺时针$180\degree:$ $(len-x,len-y)$

顺时针$270\degree:$ $(len-y,x)$

这样，就只要把bool三维数组镂空，就可以完成输出啦$QwQ$

[代码奉上](https://www.luogu.org/recordnew/show/16284041)

---

## 作者：碳碳双键！ (赞：4)

可以画一张图看一下qwq
注意 转的是透明纸 情书的方向不会变

贴代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN=1005;
int n;
char ch[MAXN][MAXN],s[MAXN][MAXN];

int main(){
	cin>>n;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			cin>>ch[i][j];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			cin>>s[i][j];
			
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (ch[i][j]=='O') cout<<s[i][j];
			
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (ch[n-j+1][i]=='O') cout<<s[i][j];
			
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (ch[n-i+1][n-j+1]=='O') cout<<s[i][j];
			
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (ch[j][n-i+1]=='O') cout<<s[i][j];
	cout<<endl;
}
```

---

## 作者：Nemlit (赞：4)

#模拟题

模拟题的代码一般都很长，所以检查起来就很麻烦。这道题我写代码只用了5分钟，可调式却用了30分钟。本题的思路是离线搜索，从四个方向依次搜索，搜到及输出。第二个方向和第四个方向的代码比较麻烦，想的话可能想很久很久都不明白。我的第二个方向错误代码是这样的：

```cpp
for(int i=n;i>0;i--)
    for(int j=1;j<=n;j++)
        if(b[i][j])
            cout<<arr[i][n-j+1];
```
想了很久才想明白搜索的思路。你只要想清楚每个方向的起始值和输出值，其实这道题就很简单了。然后贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[1005][1005]={0};//存透明的板子
int n;
char temp,arr[1005][1005];//存‘情书’
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)//输入透明的板子，由于b数组初值已经负为0，所以就不用管‘#’的情况了
        for(int j=1;j<=n;j++){
            cin>>temp;
            if(temp=='O')
                b[i][j]=1;
        }
    for(int i=1;i<=n;i++)//输入‘情书’
        for(int j=1;j<=n;j++)
            cin>>arr[i][j];
    for(int i=1;i<=n;i++)//正面读，这一块十分简单，不多做讲解
        for(int j=1;j<=n;j++)
            if(b[i][j])
                cout<<arr[i][j];
    for(int i=1;i<=n;i++)//第一次旋转读，观察后可发现样例顺序如下：（4,1）（3,1）（2,1）（1,1）（4,2）……所以i代表纵坐标，从1~n，j则代表横坐标，从n~1
        for(int j=n;j>0;j--)
            if(b[j][i])
                cout<<arr[i][n-j+1];//因为输出值都是用正常数据输出，所以纵坐标应该是n-j+1
    for(int i=n;i>0;i--)//同第一次
        for(int j=n;j>0;j--)
            if(b[i][j])
                cout<<arr[n-i+1][n-j+1];
    for(int i=n;i>0;i--)//同第二次
        for(int j=1;j<=n;j++)
            if(b[j][i])
                cout<<arr[n-i+1][j];
    return 0;
} //2191
```

---

## 作者：Konnyaku_ljc (赞：2)

## ~~说实话，此题很水~~    
乍一看，我还以为是个搜索+字符串+模拟，结果……~~异常简单~~  
好吧，我是用数学老师教的“瞪眼法”做出来的……
# 划重点： ~~显然的~~ 经过精密的计算，是顺时针旋转  
附样例的四次旋转  
![2191](https://cdn.luogu.com.cn/upload/pic/52279.png)  
接下来就非常简单了（吐槽一下，dalao都直接旋转，~~我没想到~~为了美观，我多用了三个数组）  
附代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n;//n*n的方阵
char a[1005][1005],b[1005][1005],c[1005][1005],d[1005][1005],e[1005][1005];
//a为遮挡板，b为情书，c/d/e为旋转后的遮挡板
int main()
{
	cin>>n;//输入
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		cin>>a[i][j];//上半部分输入完成
    		c[j][n-i+1]=a[i][j];
    		d[n-i+1][n-j+1]=a[i][j];
    		e[n-j+1][i]=a[i][j];
            //带入两到三个数带一下，便可瞪出怎样旋转
		}
	}
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		cin>>b[i][j];//下半部输入
		}
	}
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		if(a[i][j]=='O')
    		{
    			cout<<b[i][j];
                //没旋转时，第一次判断；不解释，上面图很清楚
			}
		}
	}
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		if(c[i][j]=='O')
    		{
    			cout<<b[i][j];
                //第一次旋转，第二次判断；不解释，上面图很清楚
			}
		}
	}
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		if(d[i][j]=='O')
    		{
    			cout<<b[i][j];
                //第二次旋转，第三次判断；不解释，上面图很清楚
			}
		}
	}
	for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		if(e[i][j]=='O')
    		{
    			cout<<b[i][j];
                //第三次旋转，第四次判断；不解释，上面图很清楚
			}
		}
	}
	return 0;//完美结束！！！
}
```
蒟蒻写了其实多行…………
所以蒟蒻常常很生气  
以此来展示自己的[恶趣味]( https://www.luogu.org/paste/43pr24x4)
### ~~敬请谅解，但毕竟是本蒟蒻的100AC的标志，请允许我皮一下~~

---

## 作者：The_Stalker (赞：2)

蒟蒻的第一篇题解。

只能说是一道水题。

~~一开始以为是红题，做完后What?黄的?~~

本题重点在于旋转的处理。

蒟蒻一枚不会旋转数组,只能模拟旋转直接输出

注意，旋转是顺时针转90°，扫描从左上往右下。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char p1[1001][1001];//定义字符数组存储透明纸
char p2[1001][1001];//定义字符数组存储情书
int n;
int main()
{
	cin>>n;
	for(int i=0;i<=n-1;i++)
	cin>>p1[i];//输入用cin轻松完成,gets()会把输入的n也读进去
	for(int i=0;i<=n-1;i++)
	cin>>p2[i];//输入
    //重点!!!旋转与输出
	for(int i=0;i<=n-1;i++)
		for(int j=0;j<=n-1;j++)
        //第一次直接扫描,遇到O输出即可
		if(p1[i][j]=='O')cout<<p2[i][j];
	for(int j=0;j<=n-1;j++)
		for(int i=n-1;i>=0;i--)
        //第二次,顺时针旋转90°,所以从左下往右上扫描
        //由于从上到下从左到右,所以先列后行(i,j扫描顺序互换)
		if(p1[i][j]=='O')cout<<p2[j][n-1-i];
        //输出时要注意,因为旋转,原来的(i,j)变为(j,n-1-i)可由分析样例得到这一规律(原因过会儿讲)
	for(int i=n-1;i>=0;i--)
		for(int j=n-1;j>=0;j--)
        //第三次,再转90°,所以右下往左上扫描
		if(p1[i][j]=='O')cout<<p2[n-1-i][n-1-j];
        //同理,输出时(i,j)变为(n-1-i)(n-1-j)
	for(int j=n-1;j>=0;j--)
		for(int i=0;i<=n-1;i++)
        //第四次,在转90°,从右上往左下扫描
        //同第二次,先列后行
		if(p1[i][j]=='O')cout<<p2[n-1-j][i];
        //同理,输出时(i,j)变为(n-1-j,i)
    return 0;//代码很短
}
```
下面讲一下为什么旋转后(i,j)分别变为(j,n-1-i)(n-1-i,n-1-j)和(n-1-j,i)。

如图,当n=4时,样例为

·##O#

·#O#O

·####

·###O

一次旋转后变为：

·####

·##O#

·###O

·O#O#

可以看到原来位于(0,2)的'O'旋转后在(2,3)=(2,3-0),因为这个‘O’距离整个矩阵的两边界的距离不变,所以横坐标为原来纵坐标,纵坐标为右边界-原来的横坐标

同理,旋转两次后为:

·O###

·####

·O#O#

·#O##

与原图中心对称,原来(0,2)变为(3,1)=(3-0,3-2)∵与边界距离不变,原来左上边界变为右下边界∴横纵坐标同时变为边界值-距离

同理,旋转三次后变为:

·#O#O

·O###

·#O##

·####

和第一次类似,可以直接当做逆时针旋转90°。这次只需要将原来的第一次的反过来做一遍,纵坐标为原来横坐标,横坐标为左边界-原来纵坐标。

这样就可以AC了。希望能有帮助。

~~要不是忘了换扫描方向我一遍就AC了~~

---

## 作者：夜卿羽 (赞：1)

## 首先，恕我吐槽下题目，说是旋转90度，却没说好是顺时针还是逆时针，其实就是~~逆时针~~（瞎说什么？）顺时针的。
本蒟蒻第一次写题解，求管理员通过中。
这道题目关键就在旋转啦，累加字符什么的不会的话，你也不会去看这道题的啦。

下面先献上本蒟蒻的代码：

```cpp
#include<iostream>
using namespace std;
int n;
string ans;
char c[1001][1001],ch;
bool t[1001][1001],T[1001][1001];
void sum()
{
    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++)
            if (t[i][j]) ans+=c[i][j]; //累加，得到情书的内容
}
void xz() 
{
        for (int i = 0; i <n / 2; i++)
	    {
		    int num = n - 2*i; //这一轮一边有几个数据
	    	int move_count = num-1;//这一轮一边有几个数据
	    	for (int j = i; j <i + move_count; j++)
	    	{
		    	int offset = j - i;	 
                int temp = t[i][j];  //记录上方
                t[i][j] = t[i + num - 1 - offset][i];	//上=左
                t[i + num - 1 - offset][i] = t[i+num-1][i+num-1-offset];	//左=下
                t[i + num - 1][i + num - 1 - offset] = t[i + offset][i + num - 1];	//下=右
                t[i + offset][i + num - 1]=temp;//右=上
		    }
	    }
}
int main()
{
    cin>>n;
    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++)
        {
            cin>>ch;	//简单的读入（透明纸张）
            if (ch=='O') t[i][j]=true;	//布尔变量，标记是否可读。
        }
    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++)
            cin>>c[i][j];	//读入情书
    sum();	//第一遍，不用旋转，直接累加
    for (int i=1;i<=3;i++)
    {
        xz();	//旋转，拼音了解一下
        sum();	//依旧是累加
    }
    cout<<ans;	//输出
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：1)

这道题很水……

然后我输入是用的字符串，字符输入太麻烦了……

主要是考二维数组的旋转（旋转的是透明纸……）

```delphi

var a,c,bb{c存旋转前的位置}:array[1..1002] of ansistring;
    n,i,j:longint;
    ch:char;
procedure try;
begin
    for i:=1 to n do
        for j:=1 to n do
      if bb[i][j]='O' then write(a[i][j]);
end;
procedure xuanzhuan;
begin
    c:=bb;
    for i:=1 to n do
         for j:=1 to n do
        bb[i][j]:=c[n-j+1][i];
end;
begin
    read(n);
    readln;
        for i:=1 to n do
        readln(bb[i]);
    for i:=1 to n do
        readln(a[i]);
    try;
    xuanzhuan;
    try;
    xuanzhuan;
    try;
    xuanzhuan;
    try;
end.

 ![](https://cdn.luogu.com.cn/upload/pic/1422.png) 

```

---

## 作者：方方小逗逼 (赞：1)

无脑模拟。。。注意方向

第一次，自左上往右下

第二次，自左下往右上

第三次，自右下往左上

第四次，自右上往左下

个人感觉，要两重指针，程序如下：

```cpp
var
  a,b:array [1..1000] of ansistring;
  n,i,j,i1,j1:longint;
begin
  readln(n);
  for i:=1 to n do readln(a[i]);
  for i:=1 to n do readln(b[i]);
  i:=1;
  j:=1;
  i1:=1;
  j1:=1;
  while i<=n do
  begin
    if a[i,j]='O' then
      write(b[i1,j1]);
    inc(j);
    if j>n then
    begin
      inc(i);
      j:=1;
    end;
    inc(j1);
    if j1>n then
    begin
      inc(i1);
      j1:=1;
    end;
  end;
  i:=n;
  j:=1;
  i1:=1;
  j1:=1;
  while j<=n do
  begin
    if a[i,j]='O' then
      write(b[i1,j1]);
    dec(i);
    if i<1 then
    begin
      inc(j);
      i:=n;
    end;
    inc(j1);
    if j1>n then
    begin
      inc(i1);
      j1:=1;
    end;
  end;
  i:=n;
  j:=n;
  i1:=1;
  j1:=1;
  while i>=1 do
  begin
    if a[i,j]='O' then
      write(b[i1,j1]);
    dec(j);
    if j<1 then
    begin
      dec(i);
      j:=n;
    end;
    inc(j1);
    if j1>n then
    begin
      inc(i1);
      j1:=1;
    end;
  end;
  i:=1;
  j:=n;
  i1:=1;
  j1:=1;
  while j>=1 do
  begin
    if a[i,j]='O' then
      write(b[i1,j1]);
    inc(i);
    if i>n then
    begin
      dec(j);
      i:=1;
    end;
    inc(j1);
    if j1>n then
    begin
      inc(i1);
      j1:=1;
    end;
  end;
end.

```

---

## 作者：partychicken (赞：0)

## 换一种旋转方式
把每个能看见的点记录下来，然后每次旋转更改点的坐标，并重新排序

具体内容看代码吧

```
#include<bits/stdc++.h>

using namespace std;

struct node
{
	int x,y;
}s[1000010];

int cnt,n;
char mp[1010][1010];

bool cmp(node a,node b)
{
	if(a.x==b.x) return a.y<b.y;
	else return a.x<b.x;
}

void addnode(int x,int y)
{
	s[++cnt].x=x;
	s[cnt].y=y;
}

void rotate()
{
	for(int i=1;i<=cnt;i++)//旋转的坐标更改
	{
		int x=s[i].x;
		int y=s[i].y;
		s[i].y=n-x+1;
		s[i].x=y;
	}
	sort(s+1,s+cnt+1,cmp);
    //排序，一开始把cnt写成了n，20分，吓得我写了个对拍
    //做水题翻车系列
}

void print()
{
	for(int i=1;i<=cnt;i++)
	{
		cout<<mp[s[i].x][s[i].y];
	}
	rotate();
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		string temp;
		cin>>temp;
		for(int j=0;j<n;j++)
		{
			if(temp[j]=='O')
			{
				addnode(i,j+1);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>mp[i][j];
		}
	}
	print();
	print();
	print();
	print();
}
```

---

## 作者：Deny_小田 (赞：0)

小田又来发题解了~


本题是一道字符串题，字符串首先要解决的是读入，我刚开始写了一个代码，结果对了，但是我没有看到读入全为空，于是信心满满的提交，爆蛋。。

当连续爆了9次（呃。。）蛋后，我的老师，@xiao233给我提供了一组数据，我失败了，这才意识到好像有点错误。。

**读入推荐用gets，并且刚开始读入n时要加一个回车：**

scanf("%d\n",&n);

超级重要的一点是：redbag兄的旋转方程只适用于不是gets的其他方法，就是字符串下标从1~n的，我们知道gets的下标是从0~n-1的，所以。。方程得换成P[i][j] = S[n-j-1][i];这个啦。


后来就没什么啦，最后就AC了。

按照国际惯例，附代码：





    
```cpp
#include <cstdio>
#define Size 1005 
char A[Size][Size],S[Size][Size],P[Size][Size];
int n;
void Print(){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(P[i][j] == 'O') printf("%c",A[i][j]);
        }
    }
}
void Zhu(){
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) S[i][j] = P[i][j]; 
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++) P[i][j] = S[n-j-1][i];
    }
}
int main(){
    freopen("__Pictures.in","r",stdin); 
    scanf("%d\n",&n);
    for(int i = 0; i < n; i++) gets(P[i]);
    for(int i = 0; i < n; i++) gets(A[i]);
    Print(); Zhu(); Print();Zhu(); Print(); Zhu(); Print();        //也可以用循环来写 
    return 0;
}
```

---

## 作者：wanglishuang (赞：0)

这题主要是数组的旋转比较困难，完成了它应该就不会错;

这里直接发旋转的函数。

[codec ]

```cpp
char a[1001][1001];
int zhuanhuan(char a[1001][1001])
{
char c[1001][1001];//先定义一个二维数组c； 
int x=1,y=1;//y，x分别是之后转换时c的横竖下标； 
for(int j=1;j<=n;j++)//j是竖下标
for(int i=n;i>=1;i--)//i是横下标，因为是顺时针90度旋转，所以要从左下角开始将a的值存入c； 
{
c[x][y]=a[i][j];//存值 
if(y==n)//如果c的横下标等于正方形的边长； 
{
x++;//竖下标加1； 
y=1;//横下标清空 
}
else y++;//否则横下标+1； 
}
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
a[i][j]=c[i][j];//将c的值赋给a； 
}
```
[/codec ]
新人发帖，望采纳！！！


---

## 作者：Ufowoqqqo (赞：0)

此题考察的是对数组的旋转，只要这个关键的操作没问题就能轻松[color=viridis]Accepted[/color]。

```delphi

var
 n,i,j,k:integer;
 ch:char;
 a{旋转后的透明纸},t{旋转前的透明纸}:array [1..1000,1..1000] of boolean;
 b:array [1..1000,1..1000] of char;//有字纸

procedure print;//输出
var
 i,j:integer;
begin
 for i:=1 to n do
  for j:=1 to n do
   if a[i,j] {是否露出来} then write(b[i,j])
end;

begin
 readln(n);
 for i:=1 to n do
 begin
  for j:=1 to n do
  begin
   read(ch);
   if ch='#' then a[i,j]:=false else a[i,j]:=true
  end;
  readln
 end;
 for i:=1 to n do
 begin
  for j:=1 to n do
   read(b[i,j]);
  readln
 end;
 print;
 for i:=1 to 3 do
 begin
  //------旋转90度------
  t:=a;
  for j:=1 to n do
   for k:=1 to n do
    a[j,k]:=t[n-k+1,j];
  //--------------------
  print
 end
end.

```

---


# 计算器弹琴

## 题目描述

总所周知，计算器可以拿来干很多它本不应该干的事情，比如写作文。（参看洛谷P2549）

小A发现了一个计算器的另一个隐藏功能——弹琴。


http://www.bilibili.com/video/av2205500/

如果按上一个键，比如说1，就会发出中音“Do”。

这边给出按键音高表

```cpp
+ 低音Fa
< 低音So
* 低音La
/ 低音Xi
1 中音Do
2 中音Re
3 中音Mi
4 中音Fa
5 中音So
6 中音La
7 高音Xi
8 高音Do
9 高音Re
= 高音Mi
% 高音Fa
C 高音So
M 高音La
```
现在小A搞到了一份乐谱——我们称为计算器谱，一种变形的简谱。

时值（也就是按的时间长度）是这么记录的，例如：

1 是四分音符，占1拍。

1- 是二分音符，占2拍。

1--- 是全音符，占四拍。

对于小于四分音符的音符，我们用嵌套括号表示，例如

(1(34(56))2)

1和2在一层括号中，是八分音符，占0.5拍。

3和4在两层括号中，是16分音符，占0.25拍。

5和6在三层括号中，是32分音符，占1/8拍。当然实际上比较少见。

括号中不会出现‘-’这个符号。

不会出现四层或以上的括号。

在一个音符后面添加一个附点即“.”表示这个音符延长1/2倍。

例如
1-.是3拍，1.是1.5拍，(3.(45.))3是3/4拍，4是1/4拍，5是3/8拍。

附点不会连续添加两个或以上，也不会出现超过四拍的音符。

不考虑其他的乐理符号。

另外整个乐谱会给一个速度，整数，意思是一分钟多少拍。


为了美观，乐谱可以随便换行、添加空格。这个忽略即可。

现在小A想知道，按完这个谱子，需要多少时间（单位：秒）


## 说明/提示

样例1说明：（一共32拍，每分钟60拍，所以是32秒。对了，这是欢乐颂的开头部分）

样例2说明：（一共80拍，别问我怎么数的，一分钟120拍的话，是40秒。至于这是什么曲子？根据相关的法律政策，该部分未予显示。）



http://bd.kuwo.cn/yinyue/4641527

对于40%的数据，没有附点没有括号

对于100%的数据，括号层数不会超过3层，不超过100行，每行不超过100个字符。

对于其中的一个数据，是《千本樱》。


## 样例 #1

### 输入

```
2 60
3345 5432 1123 322-
3345 5432 1123 211-```

### 输出

```
32
```

## 样例 #2

### 输入

```
5 120
3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- 
3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- 
2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-
=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- 
=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- ```

### 输出

```
40
```

# 题解

## 作者：tauyoung (赞：13)

主要是特殊字符处理，其他的一律default按音符算


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,T,st=0,Length;
double itime=0;                                         //乐谱长度
string s;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>T;
    for(;cin>>s;st=0)                                   //读不到就结束了
    {
        Length=s.length();
        for(int i=0;i<Length;i++)
        {
            switch(s[i])                                //分析字符
            {
                case ' ':
                case '\r':
                case '\n':break;                        //空字符
                case '(':st++;break;                    //音符值减半
                case ')':st--;break;                    //音符值翻倍
                case '.':itime+=pow(0.5,st+1);break;    //半个音符
                default:itime+=pow(0.5,st);             //普通音符
            }
        }
    }
    cout<<(int)itime*60/T<<endl;                        //注意取整
    return 0;
}
```

---

## 作者：见贤思齐_Seakies (赞：7)

### [题目链接](https://www.luogu.com.cn/problem/P2614)


------------
### 题意概述

输入一段乐谱，共 $n$ 行，速度为**每分钟 $t$ 拍**，有不同的音符，用不同的符号表示，要求出弹玩这段乐谱要用多少**秒**，答案保留整数部分。

------------
### 题目分析

首先，这是一道明显的**模拟**，只要认真仔细一般就能做对。

普及一下音乐知识：

1. `-` **延时线**，**延长一拍**。
2. `_` **减时线**，题目中用 `()` 表示，一条减时线 $0.5$ 拍，两条 $0.25$ 拍，同理可以推出 **$n$ 条减时线为 $ \frac 1 {2^{n}} $ 拍**。
3. `.` **附点**，延长**前一个音的的一半**，注意是**前一个音**的一半。 

好了，其实题目中有很多迷惑你的东西，比如说音符高低，此题要计算的是节拍数，**与音符高低无关**。

我们分情况解决，记录下减时线和延时线的数量，遇到延时线就延长，遇到减时线就减短，遇到附点，就延长上一个的一半。

注意：有一种特殊情况 `1-.` ，这种情况为 3 拍，要特殊判断。

详细解释请看代码：

------------
### 代码

```cpp
#include <bits/stdc++.h> // 万能头
using namespace std;
int n, t; // n 为字符串个数，t 为速度（表示一分钟多少拍）。
double cnt[10100]; // 表示到当前字符为止所需要的时间。
int num; // 记录左括号的个数。
int sum; // 记录延时线的个数。
string s; // string 类型可以直接加减。
int main() {
    scanf("%d %d\n", &n, &t); // 注意要加一个换行符，不然它会认为你输的换行也是一个字符串。 
    for (int i = 1; i <= n; i++) {
        string ss; // 当前字符串。
    	getline(cin, ss); // getline 输入一行。
        s += ss; // 这样可以累加字符串。
    } 
    // 输入，并将所有字符串累加起来。
/* ------------------------------------- */
    for (int i = 0; i < s.size(); i++) { // size 获取字符串长度，也可用 length。
        switch (s[i]) { // 判断当前字符为那种字符。
            case '-': sum++, cnt[i] = cnt[i - 1] + 1; break; // 如果是延时线，那么就加一拍，千万不要忘了 break，我就差点忘了。
            // 注意：附点有特殊情况，比如说：1-. 为 2 拍加 1 拍等于 3 拍。  
			case '.': {
                if (s[i - 1] == '-') {
                    cnt[i] = (sum + 1) * 0.5 + cnt[i - 1]; // sum + 1 就是上一音符的时长。
                    // 相当于把到上一个音符为止的节拍数加上上一拍的一半，if 后面的那一句也一样。 
                    sum = 0; // 将 sum 清零。
                    break;
                }
                cnt[i] = 1 / pow(2, num) * 0.5 + cnt[i - 1];
                // num 为减时线的个数。
                /*
                    如果 num = 1，那么它就是 1/2 拍，也就是 1/(2^1)。
                    如果 num = 2，它就是 1/4 拍，也就是 1/(2^2)。
                    其他同理。
                */
                break;
            } // 如果是附点，就加上上一音符的一半。
            case '(': sum = 0, num++, cnt[i] = cnt[i - 1]; break; // 如果是减时线，就记录一下是几条减时线。
            case ')': sum = 0, num--, cnt[i] = cnt[i - 1]; break; // 如果是右括号，就减回去。 
            case ' ': cnt[i] = cnt[i - 1]; break;
            case '\n': cnt[i] = cnt[i - 1]; break;
            case '\r': cnt[i] = cnt[i - 1]; break; // 如果是空格或回车就直接赋为上一个值。 
            default: sum = 0, cnt[i] = 1 / pow(2, num) + cnt[i - 1]; break;
            // 不用管是哪个音，这和节拍没有关系，所以都算成其他情况。 
        } 
    }
    // 核心部分
/* --------------------------------------- */
    printf("%d\n", (int)(cnt[s.size() - 1] * 60 / t)); // 由于我们的 t 是一分钟的拍子数，所以最后要乘以 60，不要忘了取整。
    // 输出
    return 0; // return 是个好习惯！
} // ~完美结束~
```

***[$AC$ 记录](https://www.luogu.com.cn/record/59585278)*** ~~（别忘了开 O2）~~

------------

### 题目推荐
<https://www.luogu.com.cn/problem/P2108>

------------
本蒟蒻第二次写题解，希望对大家有帮助！

最后再说一句，大家不要抄袭哦！

---

## 作者：CW666 (赞：5)

~~自己试了一下计算机弹琴，差点不笑死~~

我觉得吧整道题最烦的就是输入了真的烦；于是查了一下有这种方法
```cpp
	getline(cin,a);
	for(int i=0; i<n; ++i) {
		string s;
		getline(cin,s);
		a+=s;//这样可以将字符串并在一起
	}
```
然后接下来就好处理了：

①：遇到 ‘-’号就直接++；因为‘-’号不可能出现在括号内，所以不用考虑几分之几

②：遇到 ‘（’号就将kuohao++，计算这是第几层括号

③：遇到 ‘）’号就将kuohao--，

**Attention Please：**

④：遇到

![](https://cdn.luogu.com.cn/upload/image_hosting/b0pqaroj.png)

~~洛谷的图片上传好方便~~

这些情况就需要动用之前算的kuohao了：
```cpp
jiepai+=double(1/pow(2,kuohao));
```
算出几分之几拍

⑤：遇到 ‘.’号则只需将
	
   ```cpp
jiepai+=double(1/pow(2,kuohao));
```
除以二就好了

即
```
jiepai+=double(0.5/pow(2,kuohao));
```

 

------------
解说到此

This Is Code：
```
#include<bits/stdc++.h>
using namespace std;
string a;
double jiepai;
int kuohao,n,t;
int main() {
	cin>>n>>t;
	jiepai=0;
	getline(cin,a);
	for(int i=0; i<n; ++i) {
		string s;
		getline(cin,s);
		a+=s;
	}
	for(int i=0; i<a.length(); ++i) {
		if(a[i]=='-')
			jiepai++;
		if(a[i]>='0'&&a[i]<='9'||a[i]=='+'||a[i]=='<'||a[i]=='*'||a[i]=='/'||a[i]=='='||a[i]=='%'||a[i]=='C'||a[i]=='M')
			jiepai+=double(1/pow(2,kuohao));
		if(a[i]=='(')
			kuohao++;
		if(a[i]==')')
			kuohao--;
		if(a[i]=='.')
			jiepai+=double(0.5/pow(2,kuohao));
	}
	cout<<(int)jiepai*60/t;
	return 0;
}

```
~~言简意赅~~

---

## 作者：No_Rest (赞：3)

## 题目描述

- 给出一段乐谱和音乐的速度，其中乐谱随意添加空格、换行。
- 乐谱中 +，<，*，/ ，1，2，3，4，5，6，7，8，9，=，%，$\texttt{C}$，$\texttt{M}$ 都是音高。
- $\texttt{-}$ 是延长音，一个 $\texttt{-}$ 就延长一个四分音符。
- $\texttt{.}$ 也是延长音，不过一个 $\texttt{.}$ 就延长至原来的 $\frac{3}{2}$。
- 如果被 $n$ 层的括号包裹，就变成原来的 $\frac{1}{2^n}$。

## 题目分析

输入我们可以使用 `getline`。然后将他们拼接成一段字符串，并遍历这个字符串：

1. 如果是延长音 $\texttt{-}$，那么节拍数加上 $1$。
1. 如果是括号，我们可以用一个变量 $cnt$ 来存括号的个数。是左括号 $cnt$ 就加 $1$，是右括号 $cnt$ 就减 $1$。
1. 如果是音高，那么节拍加上 $\frac{1}{2^{cnt}}$。
1. 如果是延长音 $\texttt{.}$，那么节拍数加上 $\frac{1}{2^{cnt+1}}$。

最后输出节拍数就好了。

## 代码

注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;//把乐谱合成一个字符串
double ans;//节拍数
int n, t, cnt;
int main(){
	cin >> n >> t;//输入开始
	getline(cin, a);
	for(int i = 0; i < n; ++i){
		string s;
		getline(cin, s);
		a += s;//接在后面
	}//输入结束
	for(int i = 0; i < a.length(); ++i){//遍历
		if(a[i] == '-'){//如果是延长音-
			ans++;//节拍加1
		} else if(a[i] == '('){//左括号
			cnt++;//括号数加1
		} else if(a[i] == ')'){//右括号
			cnt--;//括号数减1
		} else if(a[i] >= '0' && a[i] <= '9' || a[i] == '+' || a[i] == '<' || a[i] == '*' || a[i] == '/' || a[i] == '=' || a[i] == '%' || a[i] == 'C' || a[i] == 'M'){//是音高
			ans += (1.0 / pow(2, cnt));
		} else if(a[i] == '.'){//是延长音.
			ans += (1.0 / pow(2, cnt + 1));
		}
	}
	cout << (int)ans * 60 / t;//输出
	return 0;//好习惯
}
```

无注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
double ans;
int n, t, cnt;
int main(){
	cin >> n >> t;
	getline(cin, a);
	for(int i = 0; i < n; ++i){
		string s;
		getline(cin, s);
		a += s;
	}
	for(int i = 0; i < a.length(); ++i){
		if(a[i] == '-'){
			ans++;
		} else if(a[i] == '('){
			cnt++;
		} else if(a[i] == ')'){
			cnt--;
		} else if(a[i] >= '0' && a[i] <= '9' || a[i] == '+' || a[i] == '<' || a[i] == '*' || a[i] == '/' || a[i] == '=' || a[i] == '%' || a[i] == 'C' || a[i] == 'M'){
			ans += (1.0 / pow(2, cnt));
		} else if(a[i] == '.'){
			ans += (1.0 / pow(2, cnt + 1));
		}
	}
	cout << (int)ans * 60 / t;
	return 0;
}
```

---

## 作者：Correct_ (赞：3)

# 1.分析
## 1.1特殊情况
实际上特殊的形态有四种，

分别是1拍，0.5拍，0.25拍，0.125拍。

也就是要专门为它们设立专用代码:
```cpp
double mb(int x,int y)
{
    if(y==0) return 1.0;
    if(y==1) return 0.5;
    if(y==2) return 0.25;
    if(y==3) return 0.125;
}
```
- 为什么用double？
- 就是因为下面除了1拍的都应该用浮点型，为了整齐性，我们在此把1拍也设置。

##  1.2特殊情况的分析

**浮点音符:**

原节拍的一半再加原节拍。

**带括号的节拍:** 

先遇到一个'('就++，

后遇到一个')'就-- 。

**既带减号也带浮点的节拍:**

有几个减号加上几个，然后与浮点音符作相同处理。
```cpp
if((c[i][j]!='.')&&(c[i][j]!='(')&&(c[i][j]!=')')) ans+=mb(2,p);
if(c[i][j]=='(') p++;
if(c[i][j]==')') p--;
if(c[i][j]=='.')
{
	if(c[i][j-1]=='-') ans+=1.0;
   else ans+=mb(2,p)*0.5;            
}  
```
# 2.完整代码
```cpp
#include<bits/stdc++.h> 
#define LL long long
#define MOD 1000000007
using namespace std;

int n,i,j,len,m,p;
double t,ans;
char c[105][105];

double mb(int x,int y)
{
    if(y==0) return 1.0;
    if(y==1) return 0.5;
    if(y==2) return 0.25;
    if(y==3) return 0.125;
}

int main()
{   
    scanf("%d%lf",&n,&t);

    while(cin>>c[i])
    {   

        len=strlen(c[i]);

        for(j=0;j<len;j++)
        {
            if((c[i][j]!='.')&&(c[i][j]!='(')&&(c[i][j]!=')')) ans+=mb(2,p);
            if(c[i][j]=='(') p++;\\这里是计算括号层数
            if(c[i][j]==')') p--;
            if(c[i][j]=='.')
            {
                if(c[i][j-1]=='-') ans+=1.0;
                else ans+=mb(2,p)*0.5;\\附点音符的处理         
            }       
        }

        i++;            
    }

    m=(ans*60.0)/t;
    printf("%d",m);
    return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：2)

## 基本思路

题目中虽然给出了一大个按键高音表，但实际上没有用处，实际就看是括号里面的还是带杠带点的，所以只是判断麻烦一点。然后要面临的一个问题就是如何去判断是在第几层括号里，这里我用了一个 flag 变量来判断，他的左右括号一定是可以完美配对的，所以只要见了第一个左括号，那他在遇见右括号之前一定是最多占二分之一拍的（有其他的括号依次除以 2 就好了），所以只要遇见左括号就直接把 flag 除以二就好了，在每次计算此音符占了多少拍就用 1 乘上 flag 就好了，遇见右括号就乘 2，就完美解决括号问题了。其次是点的问题，前面音符的二分之一拍，他前面必定是一个音符而不可能是括号，所以直接用 1 乘上 flag 再除以 2 来表示就好了。


## code


```cpp
#include<bits/stdc++.h>
using namespace std;
string c[101],s;//s用于输出后面的换行符，c存放输入的谱子 
int len[101],n,m,ans;//len存放每一行的长度，ans存放答案 
double sum;//sum存放总拍数 
int main()
{
	cin>>n>>m;
	getline(cin,s);//先把换行符输出掉 
	for(int i=1;i<=n;i++)//依次输入每一行的谱子 
	{
		getline(cin,c[i]);//输入一整行 
		len[i]=c[i].size();//计算长度存起来 
	}
	double flag=1;//用来判断是不是在括号里 
	for(int i=1;i<=n;i++)//一行一行遍历 
	{
		for(int j=0;j<len[i];j++)//从零开始，遍历每一个字符 
		{
			if(c[i][j]>='0'&&c[i][j]<='9')sum+=1*flag;//列举每一种情况 
			if(c[i][j]=='+')sum+=1*flag;//一定要*flag，flag是标记在哪一层括号的 
			if(c[i][j]=='-')sum+=1*flag;
			if(c[i][j]=='*')sum+=1*flag;
			if(c[i][j]=='/')sum+=1*flag;
			if(c[i][j]=='=')sum+=1*flag;
			if(c[i][j]=='%')sum+=1*flag;
			if(c[i][j]=='C')sum+=1*flag;
			if(c[i][j]=='M')sum+=1*flag;
			if(c[i][j]=='<')sum+=1*flag;
			if(c[i][j]=='.')sum+=1*flag/2;//前面音符的一半 
			if(c[i][j]=='(')flag/=2;//左右括号必定是匹配的，左括号是*1/2的标志 
			if(c[i][j]==')')flag*=2;//右括号给他乘回去 
		}
	}
	ans=sum/m*60;//sum/m是用了几分钟，*60换算成秒 
	cout<<ans<<endl;//输出答案 
	return 0;//好习惯 
 } 
```


---

## 作者：VIOLET__FOREVER (赞：2)

题目[传送门](https://www.luogu.com.cn/problem/P2614)
## 思路提供
这只是一道简单的模拟
我们只需要对于 `.` ， `-` ， `(` ，`)` 进行特判即可，但是还是要注意对每个数的定义类型防止出现错误。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h,len,ans,k;
double t,m;
string ch[105];//用string比char方便一点（本人是这么觉得的）
double o(int x){//因为有返回值是浮点型所以要加上double
    if(x==0) return 1.0;
    if(x==1) return 0.5;
    if(x==2) return 0.25;
    if(x==3) return 0.125;
}
int main(){
	cin>>n>>t;
	while(cin>>ch[h]){//用while进行输入
        int len=ch[h].size();
		for(int i=0;i<len;i++){
			if(ch[h][i]!='.' && ch[h][i]!='(' && ch[h][i]!=')') m+=o(k);
            if(ch[h][i]=='(') k++;
            if(ch[h][i]==')') k--;
            if(ch[h][i]=='.'){
                if(ch[h][i-1]=='-') m+=1.0;
                else m+=o(k)*0.5;         
            }       
		}//以上就是各种特判，是主要代码
		h++;
	}
	ans=(m*60.0)/t;
	cout<<ans;
	return 0;
}
```


---


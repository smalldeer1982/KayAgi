# 硬币翻转

## 题目描述

有很多个硬币摆在一行，有正面朝上的，也有背面朝上的。正面朝上的用 $1$ 表示，背面朝上的用 $0$ 表示。

现在要求从这行的第一个硬币开始，将**从第一个硬币开始的前若干个硬币**同时翻面，求如果要将所有硬币翻到正面朝上，最少要进行这样的操作多少次？


## 说明/提示

### 样例解释

- 第 $1$ 次翻转：把第一个硬币翻到反面，字符串为 $00$；
- 第 $2$ 次翻转：把第一、二个硬币一起翻到正面，字符串为 $11$，翻转完成，输出 $2$。

### 数据范围

记 $n$ 表示硬币的总个数，

- 对于 $20\%$ 的数据，$1\le n\leq10$；
- 对于 $50\%$ 的数据，$1\le n\leq10^4$；
- 对于 $100\%$ 的数据，$1\le n\leq10^6$。


## 样例 #1

### 输入

```
10```

### 输出

```
2```

# 题解

## 作者：转站的open鸡 (赞：112)

一道水题

对于读入的长度为m的字符串，只需要从第二个开始判断，如果和前面的一样（s[i]==s[i-1]）就删去，如：

0111000111

变成：

0101
如果最后一个是1  答案就是删取后的字符串长度；

如果最后一个是0  答案就加1 （相当于把全是背面朝上的变成全是正面朝上的）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
            int i,m,k;
       string s;
       cin>>s;
       m=s.size();k=m-1;
       for(i=1;i<m;++i)
         if(s[i]==s[i-1])k--;         //删除语句
          if(s[m-1]=='0')k++;
       cout<<k;
       return 0;
}
```

---

## 作者：anyway (赞：49)

**题目到底在说啥？**

发题解是因为一开始没看懂题目，所以给像我一样的蒟蒻解释一下，顺便说一下我的做法。

读入表示硬币状态的字符串，要把硬币都翻到1。翻转有一定的规则，如果你要翻第i枚硬币，必须把1~i枚都翻转。问怎么翻才能用最少的次数得到全部为1的硬币序列。


既然是翻1~i的话，连续的0可以一次变为1，就可以当成一个0处理。但是如果0前有1，就要再操作一次把翻成0的1翻回去。当我们找到一个0，如果它前面也是0，我们可以不管它，和前面的0一起处理。如果它前面是1，就要翻2次纠正。要做到次数最少，我们就要使调整好的状态不受影响，所以应该从后向前搜索，而翻转后面的操作实际不影响前面的值，因为前面的硬币会翻2次回到原状态。最后要再判断一下第一枚硬币，如果是0再翻1次。



```cpp
#include<cstdio>
#include<cstring>
int main()
{
    char c[202];
    int i,l,s=0;
    scanf("%s",c);
    l=strlen(c);
    for (i=l;i;i--)
        if (c[i]=='0'&&c[i-1]=='1') s+=2;
    if (c[0]=='0') s++;
    printf("%d",s);
    return 0;
}
```

---

## 作者：Stella_Yan (赞：32)

如题所说,如果看得懂真的比较简单。

其实只要从左往右扫,如果这个硬币与下个硬币状态不同,就说明要翻一次。最后还得判断最后一个是不是0,如果是0还要再翻一次,因为题目说要全部正面朝上,就是全部为1,最后一位为0就说明翻完后全是0,还要再翻一次。

具体说明看代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	string s;//要翻转的硬币串。
	cin>>s;
	int sum=0;//计数。
	int len=s.length();//用一个变量存储,防止重复计算长度。
	for(int i=0;i<len-1;i++)
	{
		if(s[i]!=s[i+1])//如果当前硬币与下一个硬币状态不同,说明要翻一次。
			sum++;
	}
	if(s[len-1]=='0')//最后一位是0,还要再翻一次。
		sum++;
	cout<<sum;//输出。
}

```

---

## 作者：SS003 (赞：21)

看到题目,第一反应就是模拟

但再仔细想想,其实还有更简便的解法

由于硬币翻转的规则是:
```
要求从这行的第一个硬币开始,将前若干个硬币一起翻面
```
那么我们来举两个例子,模拟一下翻转过程:
```
(1)1010010:
1010010
0010010
1110010
0000010
1111110
0000000
1111111

(2)10011:
10011
00011
11111

```
由此找到规律:

当这一个硬币与下一个硬币不同时,这一个硬币连同它之前的硬币一起翻转

翻转至与下一个硬币相同的一面

直到将所有硬币翻转到同一面

但这里还有一个点要注意:

题目要求所有硬币正面朝上,也就是所有面都是'1'的情况,才算完成

我们就再把全部硬币翻转一次

------------

那么这道题就好解决了

- 分析如下:

1. 输入硬币状态,用字符串存储
2. 从第一个字符开始,两两比较
3. 如果不一样就翻转(翻转次数+1)
4. 全部翻转(比较)后,如果最后一个硬币朝下,翻转次数还要+1(具体看前面的解释)
5. 输出翻转次数,结束运行

这道题的简短代码:

------------

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
  char c[10005];
  int i,l,ans=0;
int main(){
  scanf("%s",c);l=strlen(c);//输入硬币状态,保存长度
  for(i=0;i<=l-2;i++){//从第1个开始循环,到l-1个时停止循环(由于字符串的下标从零开始,所以是(i=0;i<=l-2;i++))
    if(c[i]!=c[i+1]){ans++;}//比较第i个和第i+1个是否一样,若不一样,ans++
  }
  if(c[l-1]=='0'){ans++;}//翻转后硬币如果都反面朝上,就再翻转一次,ans++
  printf("%d",s);
return 0;
}
```
希望这篇题解能帮助到你.

---

## 作者：空の軌跡 (赞：8)

# 结论：仅改变你的操作顺序不会影响最终结果。（显而易见）

所以，为了使得我们的操作不会影响前面的操作，我们需要倒着进行操作。

首先记录一个已经进行的操作次数，凭借这个就可以判断当前的硬币的朝向，然后判断是否翻转。这样我们就可以保证这枚硬币以后的硬币都朝向上。

# 代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    string s;int n=0;
    cin>>s;
    for(int i=s.size()-1;i>=0;i--)//倒着枚举
    {
        if(n%2==0)//判断当前是朝向那一面
        {
            if(s[i]=='0')++n;
        }
        else
        {
            if(s[i]=='1')++n;
        }
    }
    cout<<n;
}
```


---

## 作者：青珹 (赞：5)

这道题是一道简单的模拟~~（其实洛谷标签上说这道题是搜索？？？）~~，我们只需要每一次从前往后找相同的硬币，直到找到不同的硬币**n**，然后将找到的前**n-1**个相同的硬币翻过来，每翻一次让计数器**tot+1**，直到所有硬币都是正面后输出**tot**即可。

****AC****代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
int l/*字符串长度*/,tot/*翻转次数*/;
char c[10001]; 
int main()
{
	cin>>c;                     //输入硬币正反
	l=strlen(c);                //l为硬币个数
	for(int i=l;i>=1;i--) //
	c[i]=c[i-1];          //将硬币标号从0——n-1变为1——n（个人习惯啦）
	while(1)
	{
		for(int i=1;i<=l;i++)   //先从头到尾找一遍
		{
			if(c[i]=='0')       //只要遇到0说明还得再翻
			  break;            //跳出for执行下面的
			else
			if(i==l)//若一直找到最后都是1，那么恭喜啦，硬币都已翻到正面！！
			{
				cout<<tot;      //输出总数
				return 0;       //程序结束！！
			}
		}
		char a=c[1];            //记录当前第一个硬币的正反
		for(int i=1;i<=l;i++)
		{
			if(a=='0')          //若第一个硬币是反的
			{
				if(c[i]==a)     //那只要遇到反的
				  c[i]='1';     //都翻成正的
				else            //若遇到了正的
				  break;        //就翻完了一遍，跳出即可
			}
			else                //若第一个硬币是反的
			if(a=='1')
			{
				if(c[i]==a)     //那只要遇到正的
				  c[i]='0';     //都翻成反的
				else            //若遇到了反的
				  break;        //就翻完了一遍，跳出即可
			}
		}
		tot++;                  //翻硬币的总数加一
	}
    return 0;
}
```


---

## 作者：行者_Walker (赞：5)

其实还有一种思路

扫描一遍，如果发现字符串从1变到0的话那就把1前面的（包括1）硬币翻转一遍，

然后又从第一个字符开始扫描，重复~~这种暴力~~操作

直到没有从1变为0的这种情况（那就一定只有从0变为1的这种情况）

想象一下，这字符串一定只有这种可能-------有前导0（如000011）

最后判断一下第一位是否为0，是0就只用再翻一遍，不是0就已经全部翻完了

~~**数据太水了....**~~

刚开始以为这种暴力模拟会T，结果[20ms 800K就过了](https://www.luogu.org/recordnew/show/15720596)

以下是暴力代码o(=•ェ•=)m

```cpp
# include <iostream>
# include <cstdio>
# include <algorithm>
# include <cmath>
# include <cstring>
# include <queue>
using namespace std;
string s;
void qufan(int x)//取反
{
	for(int i=0;i<=x;i++)
	{
		if(s[i]=='0'） s[i]='1';
		else
		s[i]='0';
	}
}
void doit()
{
	cout<<s<<endl;
}
int main()
{
	long long ans=0;
	cin>>s;
	int pre=-1;//初始化为-1
	int l=s.length();
	for(int i=0;i<l;i++)
	{
		if(s[i]=='0'&&pre==1)
		{
			pre=-1;qufan(i-1);//翻转的是1及1以前的
			i=-1;ans++;//i=-1是因为continue回去后循环里面还会i++
//          doit()把屏蔽去了可以看过程
			continue;//直接跳过
		}
		pre=s[i]-'0';//记录前一个数的值
	}
	if(s[0]=='0')
	ans++;
	printf("%d\n",ans);
	return 0;
}
```

望管理大大仔细斟酌（蒸煮），通过审核；

欢迎同学们到本蒟蒻+萌新的[博客](https://www.luogu.org/blog/mess/)

---

## 作者：cmwqf (赞：5)

很好奇为什么只有我这么想的：

若翻的次数sum是偶数，则相当于没翻，此时判断此数是否是0，若是，则sum++;

若翻的次数sum是奇数，则相当于翻了一次，此时判断此数是否是1，若是，则sum++;

代码如下：

~~有问题欢迎指正~~
```
#include<cstdio>
#include<cstring>
using namespace std;
const int maxN=100000;
char s[maxN+1];
int sum=0;
int main()
{
    scanf("%s",s);
    for(int i=strlen(s)-1;i>=0;i--)
            if(sum%2==0&&s[i]=='0') sum++;
            else if(sum%2&&s[i]=='1') sum++;
    printf("%d",sum);
    return 0;
} 
```

---

## 作者：WLR__jr (赞：4)

#### 这是本蒟蒻的第二篇题解（~~不要D我呀~~

emmmm······怎么说呢，这是一道很难（shui）的题~~

我还交了三次（我还是太菜了）

代码~~十八禁~~（太暴力了，毫无技巧可言）

除了判断，还是判断，一个一个翻就好了

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
char s[110];
int main()
{
	gets(s);
	int len=strlen(s),ans=0;
	for(int i=len;i>=1;--i)
	{
		if(s[i]=='0'&&s[i-1]=='1')ans+=2;//判断前一位，如果为1默认再翻一次
	}
	if(s[0]=='0')ans+=1;//特判最后一位~~~
	printf("%d",ans);
	return 0;//完结撒花。。。
}
```

---

## 作者：lixiao189 (赞：3)

# Luogu p2708题解

## 思路：
由于我们这个题目的长度不知道，所以我们不能一次性输入所有的硬币的状态，也许会爆数组(Ps:我没试过我不是知道)。所以我们为了保险采取用`getchar()`一个一个读入硬币的状态的方法。然后我们可以发现假如当前输入的硬币的状态和之前所有硬币的状态不一样的时候我们要把当前硬币之前的所有硬币的状态修改掉。如果不修改那么之后不管怎样改变状态都不能让所有硬币的状态都一样了。我们要去把之前所有的硬币都修改得和当前的硬币一样。最后我们这样做硬币肯定都是一样的了。然后判断所有硬币是否都朝上，如果都不朝上那么就还要再翻动一次硬币。最后我们不可能去真的修改前缀要不然很可能会超时，并且这样做的话前面的所有硬币都是一样的。所以我们用一个`bool`变量`flag`来存储当前硬币之前的所有硬币是否朝上，如果是`true`就是朝上否则朝下。

## 代码：
```cpp
#include <cstdio>

int get_ans()
{
    int ans = 0;
    char ch = getchar();
    bool flag = (ch == '1');
    while (ch >= '0' && ch <= '9')
    {
        if ((ch == '1') != flag) {
            ++ans;
            flag = (ch == '1');
        }
        ch = getchar();
    }
    if (!flag) ++ans;
    return ans;
}

int main(int argc, char const *argv[]) 
{ 
    int ans = get_ans(); 
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：James_Brady (赞：2)

**我自闭了······**

入门题都要用DP来做 ~~（果然还是太菜了）~~

先说一下DP思路

用dp[i]表示将1~i全部置为1时的最少次数

对于s[i]，如果他为0，那么找到它前面第一个1的位置（因为和前面的0一起翻转，节约次数），将这个位置全置为1，然后翻转，再将整个翻转

如果为一，则不动，为dp[i-1]

所以dp[i]=dp[j]+2;（注意特判全是0的情况）每个j我们可以预处理出来

code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,dp[10010],f[10010],t;//f如上文所述的j
char s[10010];
int main()
{
	scanf("%s",s);
	n=strlen(s);
	for(int i=n;i>=1;i--)
	s[i]=s[i-1];//为了操作方便将整个字符串向后移一位
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='1')
		{
			f[i]=i;//貌似没用
			t=i;//记录1出现的位置
		}
		if(s[i]=='0')
		f[i]=t;
	}
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='1')
		dp[i]=dp[i-1];
		else
		{
			dp[i]=dp[f[i]]+2;
			if(!f[i])
			dp[i]--;//全是0就不用翻转1~f[i]了
		}
	}
	printf("%d",dp[n]);
}
```


---

## 作者：二元长天笑 (赞：2)

天笑在使劲研究之后发现，其实对于每一个字符串，要把它变成全1串，往往都是如下步骤：


原：1 0 1 0 1 0

0 1 0 1 0 1

1 0 1 0 1 1

0 1 0 1 1 1

1 0 1 1 1 1

0 1 1 1 1 1

1 1 1 1 1 1


然后最后天笑意识到，如果要把全部都变为1，其实只用从字符串“右边”往“左边”找，找到一个0就让它左边所有的值取反，因为题目中说道只能从第一个硬币开始反转，所以这样反转得到的一定是最优解（这可能需要好好仔细的想一想，但其实很快就能想通）。所以天笑就用了这种方法来模拟，虽然时间复杂度比较高，但毕竟也只有255位，也是可以水一发的，下面是AC代码：


```cpp
#include<iostream>
#include<cstring>
using namespace std;
string s;
int ans;
void change(int x)
{
    for(int i=x;i>=0;i--)    //往左找，取反
        if(s[i]=='0')
            s[i]='1';
        else
            s[i]='0';
}
int main()
{
    cin>>s;
    int len=s.length();
    for(int i=len-1;i>=0;i--)     //从最右边开始找到0就反转
        if(s[i]=='0')
        {
            ans++;    //次数加1
            change(i);
        }
    cout<<ans<<endl;
}
```

---

## 作者：Lithium_Chestnut (赞：1)

又是一道找规律题。

普通模拟有点麻烦，所以就选择了更简单的找规律方法。

模拟从左到右看，如果每一位与它的前一位不相等的话，步数就会$+1$，因为看的是**前一位**，**所以循环从$1$开始**，**并且循环到字符串长度的前一位**，循环结束后，判断倒数第$2$位，如果是$0$，就代表还剩最后一次没有反转，那计数器再次$+1$。

最后用样例解释一下规律：

```10```

因为$1$和$0$并不相等，所以计数器$+1$；并且反转后倒数第二位是$0$，所以计数器再次$+1$；共$2$次，所以答案为$2$。

最后，贴下代码，代码里有注释，可以借助注释阅读。切莫抄袭，小心棕名哦！

$Code:$

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
string s;//字符串
int cnt,a;//计数器和字符串长度
int main()
{
    cin>>s;//输入
    a=s.length();//赋值
    for(int i=1;i<=a-1;i++)
    {
        if(s[i]!=s[i-1]) cnt++;//判断相不相等，如果相等，计数器++
    }
    if(s[a-1]=='0') cnt++;//如果倒数第二位是0，计数器++
    cout<<cnt;//输出计数器
    return 0;//程序结束，返回0
}
```
完结撒花！

---

## 作者：yubing_lml (赞：1)

NO.15 灵光乍现乱涂乱画突然发现一种新奇的做法！
试着写了一下居然AC啦~那就是——

每次翻转从开始到最后一个0的这段字符串！

1010->0101->1011>0111>1111

代码没什么技术含量不解释了直接上~

```cpp
#include<iostream>
#include<string>
using namespace std;

void change(string &str,int pos)
{
	for (int i = 0; i <= pos; i++)
		str[i] = '1' - (str[i] - '0');
}

int main()
{
	int ans = 0;
	string str;
	cin >> str;
	while (str.find('0') != string::npos)
	{
		ans++; 
		int i = str.find_last_of('0');
		change(str, i);
	}
	cout << ans;
	return 0;
}
```


---

## 作者：sshwy (赞：1)

### 水题往往能激发新的思维

### 难题往往是水题的叠加

对于这道题，虽然简单，看过楼上Dalao的题解，大都蕴含一个重要的思想：

# 离散化

譬如11100011101011111这个字符串，可将其连续的1或者连续的0分别看作单个的1或0，变成1010101。
而我们之所以可以这样做，是因为我们不关心1和0的具体个数，我们只关心他们交替出现的次数。
这就是离散化的基本思想：**只取为我之用**，不需要的信息就忽略，来达到**简化代码，简化思维**的目的。

------

离散化之后，针对01交替的字符串，进行简单的0和1的出现次数统计再判断即可完成。
#### Case1 1010...（头为1）

针对Case1，末尾为1为0我们不用考虑，这时一定满足**1出现的次数>=0出现的次数**。因此翻转**（0出现次数）*2**次。

#### Case2 0101...（头为0）

同理，不考虑末尾，一定满足**0出现的次数>=1出现的次数**，翻转**（0出现次数）*2-1**次

------

### 代码

```cpp
#include<iostream>

using namespace std;

char c,pre='*',first;
int count[2];

int main()
{
	while(cin>>c)
	{
		if(pre=='*')first=c;
		if(c!=pre)count[c-48]++,pre=c;
	}
	if(first=='1')cout<<count[0]*2;
	else cout<<count[0]*2-1;
	return 0;
}

```

---

## 作者：Deny_小田 (赞：1)

我来贴一个doby的证明吧


例如：

10101
变换过程：

10101 --> 01101

01101 --> 11101

11101 --> 00011

00011 --> 11111


完毕。


大家不禁要问，为什么这样就能成功呢？


我们不妨再举一个简单的例子：

101
变换过程：

101 011 111

我们发现，每次其中一个‘0’会往前提一位（当然前面有可能都反过来了），以此类推，最终必能得到全‘1’的字符串。

这个“往前提”是抽象的概念，因为前面的位置也有可能反过来。


再举一个例子：

1001
变换过程：

1001 0101（注意，第一个0往前提了一位），1101，0011（注意，第二个0往前提了一位），1111


由此可证出，对于一个只包含0、1的数字串S，经过若干次翻转，最终必能得到一个 全1的数字串。

得证。


代码？

。。。doby已经给出了，我贴了也没什么意义。


---

## 作者：wushuang0828 (赞：0)

### 一篇Pascal题解（我没用深搜）
首先给大家讲一下我的思路

输入一串字符后:

      1.我先找到字符串中第一个与前面字符不同的字符，并把这个字符的位置记为i
      2.把1~i-1全部反转，使1~i全部相同，即完成一次反转
      3.重复以上两条操作，直到找不到一个字符与前面的字符不同，即整串字符全为0或全为1
假设输入10010

      首先找到位置为2的字符，把1~1位置的字符反转，即为00010
      接下来找到位置为4的字符，把1~3位置的字符反转，即为11110
      最后找到位置为5的字符，把1~4位置的字符反转，即为00000（整串字符全部为0，退出循环）
代码如下：
```pascal
var
 i,j,sum,ans:longint;
 s:ansistring;
begin
 readln(s);
 for i:=1 to length(s) do
  if s[i]='0' then inc(sum);//数出初始字符中有多少个0
 while (sum<>0) and (sum<>length(s)) do//判断当前字符串是否全为0或全为1
  begin
   inc(ans);//接下来要反转一次
   for i:=2 to length(s) do
    if s[i]<>s[i-1] then break;//找到第一个与前面字符不同的字符
   for j:=1 to i-1 do//反转
    if s[j]='0' then begin s[j]:='1'; dec(sum); end
                else begin s[j]:='0'; inc(sum); end;
   
  end;
 if sum<>0 then inc(ans);//如果全为0，要把所有字符再反转一次
 writeln(ans);
end.
```


---

## 作者：peiyangsong (赞：0)

# P2708  硬币翻转 #
## 题目描述 ##


从前有很多个硬币摆在一行，有正面朝上的，也有背面朝上的。正面朝上的用1表示，背面朝上的用0表示。现在要求从这行的第一个硬币开始，将n个硬币（1<=n<=硬币个数）一起翻面，问如果要将所有硬币翻到正面朝上，最少要进行这样的操作多少次？

## 输入输出格式 ##
### 输入格式 ###
一个字符串（当然不限长度，在字符串范围之内），有0和1组成

### 输出格式 ###
要翻转的最少次数

### 输入输出样例 ###
输入样例#1： 

10

输出样例#1： 

2



> 样例1说明：
> 
> 第1次翻转：把第一个硬币翻到反面，字符串为00
> 
> 第2次翻转：把第一、二个硬币一起翻到正面，字符串为11，翻转完成，输出2


## 程序 ##

    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=11000;
    
    int n=0/*翻转次数*/;
    
    char s[N]/*存储字符串*/;
    
    int main(){
    	
    	//读入 
    	int z=0;
    	while(1){//构造死循环 
    		
    		//读入数据 
    		scanf("%c",&s[z]);
    		
    		//退出程序条件 
    		if(s[z]=='\0')  break;
    		
    		//z每循环自增一，可记录数组长度 
    		++z;
    		
    	}
    	
    	//循环 
    	for(int i=0;i<=z-2;i++){
    		
    		//若前后两数不等，则... 
    		if(s[i]!=s[i+1]){
    			
    			//计数器自增一 
    			++n;
    			
    			//翻转硬币 
    			for(int k=0;k<=i;k++){
    			
    				if(s[k]=='0'){
    				
    					s[k]='1'; 
    				
    				}else{
    					
    					s[k]='0';
    					
    				} 
    				
    			} 
    			
    		}
    		
    }
    	
    	//若全部为0，则再全部反转一次，翻为全是1 
    	if(s[z-1]=='0')  ++n;
    	
    	//输出 
    	printf("%d",n); 
    	
    	return 0;
    	
    } 



## 算法 ##

1. 字符串
2. 模拟
3. 数学


## 注意 ##



- 字符串需用**字符数组**存储
- 字符数组**从零开始**，调用strlen函数时需注意


2019/6/25 23:37:34 

---

## 作者：blackfrog (赞：0)

## 大家好~欢迎来到我的题解
安利博客先：[blog](https://www.luogu.org/blog/blackfrog/)

我们先来想一下，怎么样才是比较优的策略，知道用什么策略，实际上就能解出这道题。

不妨我们来看个例子吧：`11001`

我们第一次应该如何反转呢？  
我们肯定会想让前面地`11`与后面的`00`统一。这样来看，一共有几个相间的硬币，就需要翻转几次。所以，具体实现方法就是将它现在的状态存一个bool变量,如果当前状态与原来储存的不一样，那就`cnt++`。最后输出就行了。望通过。
```
#include<iostream>
using namespace std;
bool j = 1;
string a;
long long cnt = 0;
int main(){
    cin>>a;
    for(long long i = a.size()-1;i>=0;i--){
        if((a[i]-'0')!=j){cnt++;j = (a[i]-'0');}
    }
    cout<<cnt;
    return 0;
}
```


---

## 作者：5ab_juruo (赞：0)

思路基本与楼上dalao相同：

比较相邻的字符，不同就++；

# 那么，为什么是这样呢？

__原因：__

首先：我们可以想一想，翻的顺序是无关的。也就是说，我们可以先翻前4个，再翻前3个，也可以先翻前3个，再翻前4个。原因很简单，因为正反只与次数有关，和顺序无关。

接着，我们的目标是111111......11111，

## 也就是说，相邻两个字符必须相同！

那么，当且只当翻转从1到这两个字符的中间才可以改变这两种字符的相对状况，也就是相不相同。

其次，在这种情况以外都不会影响相对情况。

然后，只要翻偶数次，效果是一样的。__或者说，一串要么翻，要么不翻__

所以，我们就可以推出这个结论：

---

首先，我们想要全都是1，而且顺序无关，且一串要么翻，要么不翻，所以我们可以把翻的过程想象成一个bool数组。因为只有在两个字符中间翻才可以改变状况，而我们想要让它们相同。所以，假如相同，那么就不翻。

而且，只要把前$n$个字符和第$n+1$个字符设成相同的，那么我们就可以把它们看成一个字符，这个字符的值=$a[n+1]$。

所以，我们可以在字符串的末尾再加一个‘1’，这样就不用特判，也保证了整个字符串的最终每一个字符的值都是‘1’。

代码奉上：
```cpp
#include <iostream>
using namespace std；

int main()
{
	string a;
	int ans = 0;
	cin >> a;
	a += '1'; // 增加一个‘1’，原因已经在上面讲过了。
	for (int i = 1; i < a.length(); i++)
		if (a[i] != a[i - 1])
			ans++;
	
	cout << ans << endl;
	return 0;
}
```

>欢迎来到[Blog](https://abs2333.blog.luogu.org/#)

---

## 作者：kamiyoru (赞：0)

其实还有一个简单的思路，从最后一个字符开始，如果是1则判断前一个字符，如果是0则翻转从第一个到这个字符所有的数，直到第一个字符结束判断。因为只有0，1两个数，所以可以用bool数组实现存储。一开始我数组设置的大小是10000000，没想到100也可以.....

···cpp

```cpp
#include <cstdio>
using namespace std;
bool a[100];
int main(){
    char ch;int i,pi=0,count=0;
    while(scanf("%c",&ch)==1&&(ch=='0'||ch=='1')){
        if(ch=='0')a[pi++]=false;
        else a[pi++]=true;
    }
    pi--;
    while(pi!=-1){
        if(a[pi]==true)pi--;
        else{
            count++;
            for(i=0;i<=pi;i++)a[i]=!a[i];
        }
    }
    printf("%d",count);
    return 0;
}
```
```cpp

---

## 作者：Lin1043 (赞：0)

我的思路跟楼下的都不一样啊……

就是我们首先从最后一位开始考虑，如果最后一位是0那就一定要翻，因为接下来的操作是不会再影响到这个点的

然后我们记录一个标记记录是否翻转，因为只有0和1的状态就可以用xor来转移

然后对接下来的每一位都当做最后一位来处理即可

（对每一位的01判断只要当前字符xor标记就可以了）


```cpp
#include <iostream>

using namespace std;

string S;

int ans;
int temp;

int main(){
    cin>>S;
    for(int i=S.length()-1;i>=0;i--)
        if((S[i]-'0')^temp!=1)temp^=1,ans++;
    printf("%d\n",ans);
    return 0;
}



```

---

## 作者：yang2016 (赞：0)

c++简短代码   水题

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
string s;
int ans;
int main()
{
    cin>>s;                   //字符串输入
    for(int i=1;i<s.size();i++)
    {
        if(s[i]!=s[i-1]) ans++;          //碰到不一样的就反转一下
    }
    if(s[s.size()-1]=='0') cout<<ans+1;             // 最后要特判一下  如果最后的是 0 还要多翻一次
    else cout<<ans;                                 //不是0的话直接输出就好
}
话说这么短的代码 注释加不上吧  落谷管理orz
```

---

## 作者：xw001 (赞：0)

本题关键是找规律

下面是非常简单的规律：

如果有一段夹在1中间的0就要多翻两次，说明只要找有多少段夹在1中的0就行了，而还有特殊情况就是没被1夹住的0，

没被夹住的0，也直接翻一次就行了。

```cpp
#include <stdio.h>
#include <string.h>
int main(){
    char a[10000],sum=0;
    scanf("%s",a);
    int i=0,j;
    for(;i<strlen(a);i++){
        if(a[i]=='0'){   
            if(a[i-1]=='1')sum++;//判断0前面是否是1
            for(;i<strlen(a);i++)//判断是否有被1夹住
                if(a[i]=='1'){//判断0后面是否是1
                    i--;    //因为外循环回把i加1，这样会少判断一个，所以先减一
                    break;
                }
            sum++;//这个非常重要，不管是什么情况都包括了 
        }
        else{//如果是1的情况，就像往后找0
            for(;i<strlen(a);i++)
                if(a[i]=='0'){
                    i--;
                    break;
                }
        }
    }
    printf("%d",sum);
    return 0;
}
```

---

## 作者：杨奕辉 (赞：0)

这道题其实只要知道规律就很简单，就是如果被夹住的0就要加两次，如果没被夹住就加一次，没发几次题解，不知道怎么弄，就介绍个大概吧

```cpp
var 
  s:string;
  i,t,l:longint;
begin
  readln(s);  //一定要readln，read会把回车读入
  l:=length(s);
  for i:=2 to l do
    if (s[i]='0')and(s[i-1]<>'0') then t:=t+2;   //搜索被夹住的0
  if s[1]='0' then t:=t+1;   //如果第一位是0，那就没被夹住，加一
  write(t);
end.
```

---

## 作者：高泽棵 (赞：0)

没有pascal的程序，我发一个。至于思路，下面的童鞋讲的已经很清楚了

```cpp
var s:string;j,i,t:longint;
begin
  readln(s);
  for i:=2 to length(s) do
    if s[i]='0' then
      if s[i-1]<>'0' then //如果有被1夹住的0，加2
        inc(t,2);
  if s[1]='0' then inc(t);//如果0没有被夹住，加1
  writeln(t);
end.
```

---


# [COCI 2017/2018 #2] ​​ZigZag

## 题目描述

Zig和Zag正在玩文字游戏。Zig说了一个字母，而Zag说了一个以该字母开头的单词。但是这个词需要出现在给出的单词列表中，并且被是相同首字母中使用的次数最少的单词。如果单词的选择不明确(即相同首字母中使用的次数最少的单词不止一个)，那么Zag会选择字典序较小的字母。输入保证对于每个Zig的字母，都有可以选择的单词。

假设有一个由K个不同的单词组成的列表和一个Zig给出的N个字母组成的列表。编写一个程序，根据输入，输出Zag在游戏过程中说出的N个单词。

## 样例 #1

### 输入

```
4 5
zagreb
split
zadar
sisak
z
s
s
z
z
```

### 输出

```
zadar
sisak
split
zagreb
zadar
```

## 样例 #2

### 输入

```
5 3
london
rim
pariz
moskva
sarajevo
p
r
p
```

### 输出

```
pariz
rim
pariz
```

## 样例 #3

### 输入

```
1 3
zagreb
z
z
z
```

### 输出

```
zagreb
zagreb
zagreb```

# 题解

## 作者：greenheadstrange (赞：25)

本蒟蒻开始时被题目的zig，zag吓住了

其实这道题并不是splay，只是简单的推理哦！

###### 分析：

既然题目中已经说了：先考虑使用的次数最少的单词

当我们将开头字母相同的字符串合并到一个数组，再按字典序排完序后，每个字符串都是排着队去取。

例如：split和sisak

排完序后是sisak，split

1. 第一次，次数一样，取字典序小的sisak

2. 第二次，split的次数为0，取split

3. 第三次，次数又一样，取字典序小的sisak

……

###### 小提示

sort可以直接将字符串按字典序进行排序的qwq

下面是本蒟蒻的丑代码：（喜欢请点个赞哦）

```cpp
#include<bits/stdc++.h>
using namespace std;
string s[30][10005],S;
char ch;
int n,m,num[30],p[30];//p[i]为以i开头的字符串的个数，ans[i]是一个小指针 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>S;
		int bj=S[0]-'a'+1;
		s[bj][++num[bj]]=S;//将首字母相同的合并到一个数组中 
	}
	for(int i=1;i<=26;i++)sort(s[i]+1,s[i]+num[i]+1);//使数组中的字符有序 
	while(m--){
		ch=getchar();
		while(ch<'a'||ch>'z')ch=getchar();//快速读入，节省时间 
		int bj=ch-'a'+1;
		p[bj]++;
		if(p[bj]>num[bj])p[bj]=1;//访问完了，该回到第一个了 
		cout<<s[bj][p[bj]]<<'\n';
	}
	return 0;
}

```


---

## 作者：引领天下 (赞：12)

没有C++题解？我来一发

这题目实际上可以用C++vector轻松解决

具体代码里说吧

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#include <vector>
using namespace std;
int n,k,q[30];//q为以a开头的单词中应该选的序号
vector <string> a[30];//建立一个以首字母序号为索引的vector
char c;
int main(){
    scanf("%d%d",&k,&n);
    while(k--){
        string s;
        cin>>s;
        a[s[0]-'a'].push_back(s);//vector的基本用法
    }
    for (int i=0;i<26;i++)sort(a[i].begin(),a[i].end());//C++对string的排序默认按字典序
    while (n--){
    	cin>>c;
    	cout<<a[c-'a'][q[c-'a']]<<endl;
    	q[c-'a']=(q[c-'a']+1)%a[c-'a'].size();//+1指向下一个，同时取模
        //经观察可发现：
        //单词：zadar zoo
        //次数：0     0
        //第一次选zadar：
        //      zadar zoo
        //      1     0
        //则第二次选zoo：
        //      zadar zoo
        //      1     1
        //第三次又选zadar：
        //      zadar zoo
        //      2     1
        //…
        //则可以发现：无论有多少次，在同一字母开头的单词中下标一直单调递增
        //所以直接+1就可以啦。
    }
}
```

注：本题只有一个Pascal的解法，我不知我的C++vector解法哪里重复了，麻烦管理员拒绝时给个明确的理由，谢谢

---

## 作者：Ptilopsis_w (赞：6)

题目很简单，就是给定一个首字母，输出这个首字母对应的出现次数最少、字典序最小的字符串

分析题目我们可以得到，对于每一个字符串，**只要它被输出一次，它的优先级就会降到最低而排在最后面**  

所以我们可以用一个二维队列，用二维队列的下标对应字符串的首字母，先按字典序将所有字符串插入到队列中，每次询问直接输出队头的字符串，然后将队头的字符串扔到队尾,不停循环,就可以达到目的，因为我们循环都是按顺序的，所以不管怎么操作都是字典序

~~(其实vector的写法空间更小时间更快，但是我是个懒狗，就直接用队列模拟了)~~

下面是代码详解
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, k;
string str[100005];
queue<string> q[128];
//c++中ASCII码是从0~127,所以定一个128大小的二维队列就ok

int main()
{
	scanf("%d%d", &k, &n);
	for(int i = 1; i <= k; i++)
		cin >> str[i];
	sort(str+1, str+k+1);//string类型可以直接用'<'、'>'进行操作,直接sort是没有问题的
	for(int i = 1; i <= k; i++)
		q[str[i][0]].push(str[i]);//把每个字符串按下标入队
	for(int i = 1; i <= n; i++)
	{
		char ch[3];
		scanf("%s", ch);
		//你谷的getchar()有毒,我用getchar()读字符RE一片,换成读入字符串就AC了...
        
		cout<<q[ch[0]].front()<<endl;//输出给定字符对应的字符串
		
		q[ch[0]].push( q[ch[0]].front() );//让这个字符串再次从队尾入队
		q[ch[0]].pop();//这个字符串出队
	}
    return 0;//愉快的AC了!
}
```

---

## 作者：Harry_hcx (赞：6)

没有人？来一发！     
2s？64MB？不存在的！    
我548ms，25MB，不知道有没有大佬更少的……      
首先，快排肯定是不能少的，直接用字符串比较      
接下来就，有点小骚的方法

num和a数组定义如下     
```pascal
num,a:array['a'..'z'] of longint;
```
a数组保存排序后,a【ch】表示在排好序的单词里面，首字母为ch的单词的第一次出现的位置，num【ch】表示首字母为ch的下一个要输出的单词的下标
接下来，看代码
```pascal
var
  s:array[1..100000] of string;
  a,num:array['a'..'z'] of longint;
  k,n,i,j:longint;
  ch:char;
  procedure qs(l,r:longint);//亲爱的快排
  var
    i,j:longint;
    x,tmp:string;
  begin
    i:=l;
    j:=r;
    x:=s[(i+j) div 2];
    repeat
      while s[i]<x do
        inc(i);
      while s[j]>x do
        dec(j);
      if i<=j then begin
        tmp:=s[i];
        s[i]:=s[j];
        s[j]:=tmp;
        inc(i);
        dec(j);
      end;
    until i>j;
    if l<j then qs(l,j);
    if i<r then qs(i,r);
  end;
begin
  readln(k,n);
  for i:=1 to k do
    readln(s[i]);
  qs(1,k);
  for i:=k downto 1 do
    a[s[i][1]]:=i;//如上所说的方法处理
  num:=a;//直接传给num，
  for i:=1 to n do begin
    readln(ch);
    writeln(s[a[ch]]);//输出
    inc(a[ch]);//指向下一个要输出的单词
    if (s[a[ch]][1]<>ch) or (a[ch]>k) then//如果该首字母的单词都输出了一遍，或者输出完了，则回到第一个该首字母的单词
      a[ch]:=num[ch];
  end;
  readln;
end.
```

---

## 作者：荷叶下 (赞：5)

# 题意
1. 给出几个字符串
2. 根据首字母，输出该首字母对应的字典序最小，出现次数最少的字符串

# 实现
1. 先用sort排序字符串(sort直接就按照字典序排序)
2. 计算每个首字母对应的字符串,放入队列中
```cpp
for(int i = 1; i <= k; i++)
	q[str[i][0]].push(str[i]);
``` 
3. 输出,每个字符串出现一次后扔到队尾即可 
```cpp
for(int i = 1; i <= n; i++)
{
	char ch ; cin >> ch ;
	cout << q[ch].front() << endl; 
    q[ch].push(q[ch.front()]);
    q.pop();
}
```
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k;
string str[100010];
queue<string> q[2021];
int main()
{
	cin >> k >> n ;
	for(int i = 1; i <= k; i++)
		cin >> str[i];
    sort(str + 1, str + k + 1);
    for(int i = 1; i <= k; i++)
        q[str[i][0] - '0'].push(str[i]);
    for(int i = 1; i <= n; i++)
    {
        char ch ; cin >> ch ;
        cout << q[ch - '0'].front() << endl; 
        q[ch - '0'].push(q[ch - '0'].front());
        q[ch - '0'].pop();
    }
    return 0;
}
```


---

## 作者：北冥之子 (赞：4)

这道题就应该是道~~绿~~黄题！

看大家都是用vector做的，我就尝试了一下不用vector 
 ~~其实是我不会vector~~  当然用vector要好得多
 
先上代码，注释在里面详细讲哈QwQ
```cpp
#include<bits/stdc++.h>//我只在 luogu 用万能头！
using namespace std;
string zag1[100010];//存单词列表；
string c;
int zag2[27],zag3[27],zag4[27];
//2存每一个字母开头的数量；
//3随输入更新；
//4存每一个字母开头第一个字符串的位置 - 1 ；
int k,n;
int cmp(string a,string b)
{
	return a<b;
}//cmp 函数，放在 sort 里面排序
int main()
{
	scanf("%d%d",&k,&n);
	for(int i=1;i<=k;i++)
	{
		cin>>zag1[i];//输入单词列表；
		zag2[zag1[i][0]-'a'+1]++;//更新每一个字母开头的数量；
	} 
	sort(zag1+1,zag1+1+k,cmp);//按照字典序给字符串排序；
	zag4[1]=0;
	for(int i=2;i<=26;i++)	zag4[i]=zag4[i-1]+zag2[i-1];//更新zag4；
	/*for(int i=1;i<=26;i++)
	{
		cout<<zag2[i]<<" ";
	}*///检验排序有没有问题用的！
	for(int i=1;i<=n;i++)
	{
		cin>>c;
		int o=c[0]-'a'+1;
		zag3[o]++;
		if(zag3[o]>zag2[o])	zag3[o]=1;
		int u=zag4[o]+zag3[o];
		cout<<zag1[u]<<endl;
	}//后面还有注释！
	return 0;
}
```
前面有一段写得比较难懂，最后一个循环中，先输入字母，然后开始更新 zag3 ，就是看看这个字母是第几次输入，并且保证 zag3 不大于 zag2 。因为 zag4 是各个字母中第一个字符串的位置 - 1 ，所以只要加上 zag3 就是对应字符串的位置了！
这样这道题就很简单了！加油！(⌒▽⌒)

---

## 作者：Jekyll_Y (赞：2)

### ~~挺水的（一开始打暴力打T了）~~
###  看dalao们都用了队列，vector，觉得很慌
## 题意：
给出一个单词序列，每次询问输入一个字母，在单词序列中找出以该字母开头的并且被是**相同首字母中使用的次数最少**的单词。

如果相同首字母中使用的次数最少的单词不止一个**选择字典序较小的字母**。
## 解题思路：
显然每询问一次，再排序一次是不可以的（~~亲身经历~~）。

但是我们发现每用一个以该字母开头的单词，当下次再出现这个字母时，就使用下一个以该字母开头的单词。

所以我们只需要统计单词列表中每个字母出现的次数，然后记录以每个字母开头的第一个单词的位置，再存询问的每个字母的次数，不断询问不断取模输出就可以了，也不用一些数据结构。
## Code：
```c
#include<cstdio>
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int n,k;
string d[100010]; 
int w[27],p[27],now[27];
//p数组存单词列表每个字母出现的次数 
//w数组存以每个字母开头的第一个单词的位置
//now数组存询问的每个字母的次数 
int main()
{
	cin>>k>>n;
	for(int i=1;i<=k;i++)
	{
		cin>>d[i];
		p[d[i][0]-'a'+1]++;
		w[d[i][0]-'a'+1]++;
	}
	for(int i=1;i<=26;i++)w[i]=w[i]+w[i-1];
	//用前缀和存每个字母开头的第一个单词的位置
	sort(d+1,d+k+1);//按字典序从小到大排序；
	for(int i=1;i<=n;i++)
	{
		char q;
		cin>>q;
		cout<<d[w[q-'a']+now[q-'a'+1]+1]<<endl;
		//输出 
		now[q-'a'+1]++;
		//存询问的每个字母的次数
		now[q-'a'+1]%=p[q-'a'+1];//取模 
	}
	return 0;
}
```
### 完结撒花


---

## 作者：苏黎世 (赞：2)

这道题，个人觉得算是一个模拟吧。

#### 题意提取：
有k个字符串，有n个关于首字母的询问。

我们令ji为询问的首字母的次数。

输出该首字母的第ji个询问的字符串。

#### 思路：

首先，不要试图每次出入都从1开始查，这样暴力是会TLE的。

### 那么，我们就需要根据首字母进行一个分组。

该组的第一个串就是第ji个询问要输出的字符串。

### 那么，这个组就是：队列。

如果可以理解上面的话，那么代码实现应该是不太难的。

具体的话看注释吧：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>//string类型的头文件
#include<algorithm>//别忘了sort
#include<queue>//队列要用头文件
using namespace std;
const int maxk = 1e5 + 5;
string a[maxk];
char c;
int n, k;
queue<string> q[30];//下标就是首字母
bool cmp(string x, string y)
{
	return x < y;
}

int main()
{
    int now;
    scanf("%d%d", &k, &n);
    for(int i = 1;i <= k; ++i)
    	cin >> a[i];
    
    sort(a + 1, a+ k + 1, cmp);//string的sort自动根据字典序排序
    for(int i = 1;i <= k; ++i)
      q[a[i][0] - 'a'].push(a[i]);//注意，这里是关键
    
    for(int i = 1;i <= n; ++i)
    {
    	cin >> c;
    	now = c - 'a';
    	string res = q[now].front();  q[now].pop() ;
    	cout << res << endl;
    	q[now].push(res);//输出的东西不能扔掉，放队尾

    }
    return 0;
}
```
支持一下我这个萌新吧~

---

## 作者：cyrxdzj (赞：1)

### 一、思路

本题有一个地方需要注意：输出相同首字母中使用的次数**最少**的单词。

实际上这一点是有规律的，输出此首字母的第一个单词后，下次就输出下一个。于是，最后转了一圈，又回来了。

本题必须使用 `vector` 动态分配空间，否则会爆 `MLE`。

[![2q2zmF.png](https://z3.ax1x.com/2021/06/15/2q2zmF.png)](https://imgtu.com/i/2q2zmF)

### 二、完整代码

```cpp
#include<cstdio>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;
vector<string>input[26];//输入数据。
int should_choose_id[26];//应该选择哪一个字符串。
int cnt[26];//计数器。
int k,n;
int main()
{
	scanf("%d%d",&k,&n);
	for(int i=1;i<=k;i++)
	{
		char temp[22];
		scanf("%s",&temp);//输入。
		input[temp[0]-'a'].push_back(string(temp));
		cnt[temp[0]-'a']++;//计数器自增。
	}
	for(int i=0;i<26;i++)
	{
		sort(input[i].begin(),input[i].end());//排序。
	}
	for(int i=1;i<=n;i++)
	{
		char temp[2];
		scanf("%s",&temp);
		printf("%s\n",input[temp[0]-'a'][should_choose_id[temp[0]-'a']].c_str());
		should_choose_id[temp[0]-'a']=(should_choose_id[temp[0]-'a']+1)%cnt[temp[0]-'a'];//应该选择下一个字符串。
	}
	return 0;//完结撒花！
}

```

### 三、后记

记录：<https://www.luogu.com.cn/record/51821857>。

By [dengzijun](https://www.luogu.com.cn/user/387836)

---

## 作者：yezl (赞：1)

### 题目概述：

给你 $ k $ 个单词 $ s_1,s_2,s_3…s_k $ ，然后给你 $ n $ 个字母 $ c_1,c_2,c_3…c_n $ ，要你输出 $ n $ 个满足以下条件的单词：

 1. 是给定的 $ k $ 个单词中的一个。
 2. 以 $ c_i $ 为开头。
 3. 使用（输出）的次数最少。
 4. 字典序最小。

（按照优先级从上到下）

### 思路分析：

对于这道题，一开始我的分析是暴力枚举，每一次输出完后重新拍以下序，其中的核心部分如下：（注意，这个会超时，66pts，后四点TLE）

```c
bool cmp(node x,node y)//排序函数
{
	if(x.o!=y.o)//如果使用次数不相等
		return x.o<y.o;//按使用次数从小到大
	int l=x.s.size(),r=y.s.size()
	for(int k=0;k<l && k<r;k++);//否则使用次数相等
		if(x.s[k]!=y.s[k])//如果字母不相等
			return x.s[k]<y.s[k];//那么比字典序
	return l<r;//上面都相等，那么最后比长度
}
--------------------分割线---------------------
for(int i=1;i<=k;i++)//暴力枚举
{
	sort(a+1,a+n+1,cmp);//记住先排序
	for(int j=1;j<=n;j++)
	{
		if(c[i]==a[j].s[0])//如果首字母一样
		{
			printf("%s\n",&a[j].s[0]);//输出
			a[j].o++;//使用次数+1
			break;//退出这个循环
		}
	}
}
```

怎么办呢？这个时间复杂度真的过高了，所以我就想：是不是这个两层循环的问题呢？（PS：其实不是， $ sort $ 中还有两层循环呢）于是我把它改成了这样：

```c
bool cmp(node x,node y)//排序函数
{
	//q和p存与要求的首字母的相似度（其实肯定要0呀）
	int q=abs(x.u-(c[i]-'a'+1)),p=abs(y.u-(c[i]-'a'+1));
	if(q!=p)//如果首字母与要求的相似度不一样
		return q<p;//那么就把要的放前面
	if(x.o!=y.o)//如果使用次数不相等
		return x.o<y.o;//按使用次数从小到大
	int l=x.s.size(),r=y.s.size();
	for(int k=0;k<l && k<r;k++)//否则使用次数相等
		if(x.s[k]!=y.s[k])//如果字母不相等
			return x.s[k]<y.s[k];//那么比字典序
	return l<r;//上面都相等，那么最后比长度
}
--------------------分割线---------------------
for(i=1;i<=k;i++)
{
	sort(a+1,a+n+1,cmp);//直接排序然后输出
	printf("%s\n",&a[1].s[0]);
	a[1].o++;//使用次数+1
}

```

你认为代码改成这样就不超时了吗？ $ \mathcal{No\;No\;No} $   
事实上它又超时了，而且用时还更大了。（~~想想就知道呀~~）

~~于是我终于要开始讲正确的解法了......~~

### 正解思路：

这时候我们就要讲一个非常神奇的东西啦，它就是 $ \color{red}\text{不定长数组} $ ，那这东西怎么用呢？首先来讲定义方式，比如说我们要定义一个数组 $ a $ ：  
 $ \texttt{vector<int>\;\;a} $  
你可能会问了：这是数组？没错呀，它就是一个数组，你要二维的话就是这样：  
 $ \texttt{vector<int>\;\;a[数字]} $ 

具体的用法等下讲，回归正题，先讲思路，讲读入的 $ s $ 都按照首字母存到一个二维不定长数组里，然后对这个不定长数组排一下序，一边读入一边输出，每次输出完让使用次数+1就行了。
  
### 具体代码如下：

```c
#include<iostream>
#include<cstdio>
#include<vector>//要用不定长数组要加这个头文件o
#include<cstring>
#include<algorithm>
using namespace std;
const int N=30;
int n,k,u[N];
vector<string> a[N];//定义一个二维的 string 类型的不定长数组
char c;
string s;
int main()
{
	scanf("%d %d",&k,&n);//读入k，n
	for(int i=1;i<=k;i++)//读入s，并把s开头字母对应的数字存进a
		cin>>s,a[s[0]-'a'].push_back(s);//存的方法是push_back(要存的元素)，它会为你开一个空间往后存
	for(int i=0;i<26;i++)
		sort(a[i].begin(),a[i].end());//直接排序（这个默认就是按字典序o）
	for(int i=1;i<=n;i++)
	{
		scanf("%s",&c);
		printf("%s\n",&a[c-'a'][u[c-'a']][0]);//输出
		u[c-'a']=(u[c-'a']+1)%a[c-'a'].size();//u[c-'a']+1，且不能超过a[c-'a']的长度吖，所以取一下余
	}
	return 0;
}
```

注：那个 $ \texttt{printf} $ 里的 $ string $ 类型输出法看不懂的可以直接换成 $ \texttt{cout<<a[c-'a'][u[c-'a']]} $ o。   
希望可以帮到大家。


---

## 作者：AzzyZhe (赞：0)

## 题解 P4432 ZigZag
$\rightarrow$ [题目传送门](https://www.luogu.com.cn/problem/P4432)

确实最后每个字母开头的单词按轮流输出就行。不过暴力也可以。

由于 STL 的 `string` 比较时直接按照字典序，`pair` 先后比较两个关键字（使用次数和单词），直接用 `string`+`pair`+`priority_queue` 即可（正解可以用 `string`+`pair`+`sort`+`queue`）。不过由于默认 `priority_queue` 是大根堆，我们还需要使用 `greater`。

详见代码：
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
using namespace std;
typedef pair<int,string> pr;
priority_queue<pr,vector<pr>,greater<pr> >q[26];
int n,m;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=0;i<n;i++)
	{
		pr p;
		p.first=0;
		cin>>p.second;
		q[p.second[0]-'a'].push(p);
	}
	for(int i=0;i<m;i++)
	{
		char c;
		cin>>c;
		c-='a';
		pr p=q[c].top();
		q[c].pop();
		cout<<p.second<<'\n';
		++p.first;
		q[c].push(p);
	}
	return 0;
}
```
emmmm 借此机会给大家讲一个 `priority_queue` 自定义比较的方法。

大家都知道使用自定义的函数作为 `priority_queue` 的第三个参数会导致 CE，实际上这个参数要求的是一个函数类，也就是重载了 `operator()` 的类，因此只要定义一个类并像定义普通函数一样重载其括号运算符即可。

如下：
```cpp
struct pr{
	int c;
	string s;
};
struct cmp{
	bool operator()(pr a,pr b)
	{
		if(a.c==b.c)
			return a.s>b.s;
		return a.c>b.c;
	}
};
priority_queue<pr,vector<pr>,cmp>q[26];
```

---

## 作者：yxy666 (赞：0)

这道题竟然一遍过了，自认为思路还比较清晰，就水一波题解。

题意：我们先输入 $n$ 个单词，然后输入 $Q$ 次询问，也就是一个字母，每次输出首字母是这个的单词。如果有重复的就看我当前输出了几次，然后将输出次数最少的单词，就输出字典序最小的输出。如果有多个输出次数最少的单词，就输出字典序最小的一个单词。

思路：首字母所有不同的的情况也只有 $26$ 种，那我们可以按照首字母将每个单词分组，然后将每个组里的单词排序一趟，然后一个一个挨个输出呀。如果已经输出到最后一个单词了，就改成第一个啊。但是为什么可以这样子呢？

```
第一轮询问：
0 0 0 
第二轮询问：
1 0 0
第三轮询问：
1 1 0
第四轮询问：
1 1 1
第五轮询问：
2 1 1
```
那我们就会很自然的明白了啊。

$code$ :
```cpp
#include<bits/stdc++.h>
using namespace std;
int N,M,num[26],cnt[26];
struct ZS{
	char s[22];
	bool operator <(const ZS B)const{return strcmp(s,B.s)<0;}
} Q[26][100005],s;
int main(){
	scanf("%d%d",&M,&N);
	for (int i=1;i<=M;i++){
		scanf("%s",s.s);
		int x=s.s[0]-'a';//看一下这个单词是哪一组的
		strcpy(Q[x][num[x]++].s,s.s);//
	}
	for (int i=0;i<26;i++) sort(Q[i],Q[i]+num[i]);//挨个排序
	for (int i=1;i<=N;i++){
		scanf("%s",s.s);
		int x=s.s[0]-'a';
		printf("%s\n",Q[x][cnt[x]++%num[x]].s);//挨个输出，然后最后一个了，mod一下又回到最前面了
	}
	return 0;
}
```


---

## 作者：zhouyanyu321 (赞：0)

# **Map大法好**
## 好……
### 这里用place来存每个首字母第一次出现的位置

### 用total来存储每个首字母出现的总次数

### 用sum来记录现在枚举到的是首字母内第几个单词

#### 看代码里面的注释吧

~~**~~感觉我是唯一一个用map的另类~~**~~

```cpp
#include<iostream>
#include<algorithm>
//用了sort  
#include<cstring>
//用了STL的字符串  
#include<map>
//嗝嗝  

using namespace std;

map<char,int> place;//每个首字母第一次出现的位置 
map<char,int> total;//每个首字母出现的总次数 
map<char,int> sum;//记录现在枚举到的是首字母内第几个单词 

string str[1000005];//开大点……  
int k,n;

int main()
{
	cin>>k>>n;//输入  
	for(int i=1;i<=k;i++)//输入 
		cin>>str[i];
	sort(str+1,str+k+1);
	//将字符串数组按字典序排列(sort()自带功能)  
	for(int i=1;i<=k;i++)
	//枚举每一个单词 
	{
		if(place[str[i][0]]==0) place[str[i][0]]=i;
		//如果该单词的首字母是第一次出现 
		//记录改首字母第一次出现的位置  
		else total[str[i][0]]++;
		//如果不是第一次出现 
		//增加含有该首字母的单词总数 
	}
	for(int i=1;i<=n;i++)
	//开始询问  
	{
		char c; cin>>c;
		//输入询问的首字母  
		if(sum[c]>total[c]) sum[c]=0;
		//如果该字母出现的次数已经达到了总数 
		//重置sum,从头开始记录 
		cout<<str[place[c]+sum[c]]<<endl;
		//将现在枚举到的单词输出  
		sum[c]++;
		//记录  
	}
	return 0;//嗝嗝 
}

```


---

## 作者：zqiceberg (赞：0)

###这是一道很经典的题目
###数据结构改变命运！！！

```cpp
//改用vector
//相同字符开头的字符串不在用sort进行排序
//而是对下标进行操作（需要理解题面取值的含义） 
#include <iostream>
#include <algorithm>
#include <fstream>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 1e5 + 10;

vector<string> q[30]; //开放链，26个英文字母 
int pos[30];
 
int k, n;

bool cmp(string a, string b)
{
	return a < b;
}

int main()
{
//	freopen("zigzag1.in", "r", stdin);
	cin >> k >> n;
	
	string str;
	for (int i = 0; i < k; i++)           
	{
		cin >> str;
		q[str[0] - 'a'].push_back(str);  //读入对应开头字母的vector里面 
	}
	
	for (int i = 0; i < 26; i++)
		sort(q[i].begin(), q[i].end(), cmp);  //每一个vector进行一次排序，形成字典序 
	
	while (n--)
	{
		char ask;
		cin >> ask;
		
		//例如查询字母a 
		//字母a这串vector的字符串使用顺序就是从前往后遍历
		//到尾部的时候，再回到头部，形成了一个环
		//再看一下体面的意思，相同首字母中使用的次数最少的单词，使用次数相同使用字典序小的
		//其实就是，字典序下，环形遍历 
		int pos_ask = ask - 'a';
		cout << q[pos_ask][pos[pos_ask]] << endl;     
		pos[pos_ask] = (pos[pos_ask] + 1) % q[pos_ask].size();
	}

	return 0;
}
```

几番尝试，从sort(),到组内排序的时候，用二分查找开头结尾进行局部sort
怎么做都是会有三组数据TLE
唯独改成vector，就ok了

![](https://cdn.luogu.com.cn/upload/image_hosting/f92c7slv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

---


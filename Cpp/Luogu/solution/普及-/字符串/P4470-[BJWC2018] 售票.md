# [BJWC2018] 售票

## 题目描述

C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。

在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/17861.png)

在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。

告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。

## 说明/提示

**【样例解释】**

输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。

## 样例 #1

### 输入

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA```

### 输出

```
****B*D*
*G******
********
********```

# 题解

## 作者：引领天下 (赞：25)

抢到全网最优解之后发题解

其实此题有一个很好用的命令：strncmp，可以直接比较两个字符串的前n位

接下来就很方便了

代码：

```cpp
#include <cstdio>
#include <cstring>
short n,l;
char a[51][101],s[101],k[]={"********\n********\n********\n********"};//省的换行
int main(void){
    scanf ("%d\n",&n);
    for (short i=0;i<n;i++)scanf ("%s\n",&a[i]);
    scanf ("%s",s),l=strlen(s);
    for (short i=0;i<n;i++)if (!strncmp(a[i],s,l)){//比较
        char c=a[i][l];
        if('A'<=c&&c<='E')k[c-'A'+3]=c;
        if('F'<=c&&c<='M')k[c-'A'+4]=c;
        if('N'<=c&&c<='U')k[c-'A'+5]=c;
        if('V'<=c&&c<='Z')k[c-'A'+6]=c;//设置为可见
    }
    puts(k);//直接输出
}
```

---

## 作者：Blue_wonders (赞：13)

## 模拟题意，逐个判断（简单易懂）
#### 这道题认真模拟就好，注意最后输出的换行顺序就好
#### 本题思路
- 先输入n个，目的地名称，再输入已经输进去的字母
- 然后对于每一个输入进去的字母都进行判断是否和目的地一致（只要有一个不一样就做标记，在最后搜索时跳过）
- 对于每一个目的地，只要没被做过标记那么他的没输入的下一个字母就在输出的表数组上记录
- 最后输出一个表
#### AC代码（附详解）
[AC详情](https://www.luogu.org/recordnew/show/16714054)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[51],l;
char b[51][101];
char s[101];
char m[33];
int main(){
    cin>>n; 
    for(int i=1;i<=n;i++){
        cin>>b[i];//输入每个字符串 
        a[i]=1;//后面判断是否符合条件 
    }
    cin>>s;//输入已经输入的字符串 
    l=strlen(s);//数一下输入了几个数据 
    for(int i=0;i<l;i++){//对于每一个字母判断 
        for(int j=1;j<=n;j++){
            if(a[j]==1&&b[j][i]!=s[i])a[j]=0;//如果不相符那么a变成0，a为0以后就不搜索了 
        }
    }
    for(int i=1;i<=32;i++){//m[32]代表要输出的4*8的表格 
        m[i]='*';//先都赋值为* 
    }
    for(int i=1;i<=n;i++){//对每一个输入都进行判断 
        if(a[i]==1)m[b[i][l]-61]=b[i][l];//如果所有字符都符合那么应该a为1，
		//如果a为1那么他和数据一直相符，将下一位的字母存进m函数里 
    }
    for(int i=1;i<=32;i++){//输出表格 
        cout<<m[i];
        if(i%8==0)cout<<endl;//只要是8的倍数就换行 
    }
    return 0;
}
```
感谢大家能看我的题解!~

---

## 作者：ShaeKnight (赞：6)

## 解题思路

#### 用字符串来寻找已输入候选站的下一个，

#### 并用 ${bool}$ 数组 ${f}$ 来判断，若该站存在，则值为 1，反之则为 0；

#### 最后在输出时进行判断，若为零就输出  _${*}$_ ,反之则输出站台

下面上代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>   //头文件
using namespace std;
#define ll long long
#define fr(c,a,b) for(int c=a;c<=b;c++)
#define rf(c,a,b) for(int c=a;c>=b;c--) //懒的人是这样打for循环的
const int Max=0x3f3f3f3f;
const int Min=-1;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}    //并没有什么用的快读
inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)write(x/10);
    putchar(x%10+'0');
}    //更没有什么用的快写
string s[60],t;
bool f[40];
int main()
{
	int n,js=3;
	n=read();
	fr(i,1,n)cin>>s[i];
	cin>>t;    //读入
	fr(i,1,n)
		if(!s[i].find(t))f[s[i][t.size()]-65]=1;  
		//核心代码，用find函数来判断t是否在s[i]的首位
		//若存在，则定位到下一个位置，变为1
	printf("***");   //先输出最前面的三个
	fr(i,0,28)
	{
		if(f[i]==1)putchar(char(i+65));
		else putchar('*');
		js++;
		if(js%8==0)puts("");
	}  //输出
	returm 0;    //防抄袭
}
```
#### 珍爱生命 远离抄袭
~~由于太菜了，用不来什么高大上的函数，只会用{find}~~

---

## 作者：孤_独 (赞：4)

看没有人用 string 模板库，特地发一篇题解！！！

作为一名蒟蒻，不知道多少函数，只知道 string 中有 substr 函数，可以截取一段 。

用法：
```
	string str;
	str.substr(i,j);	//从str串中第i个开始，截j个字符。		
```
核心代码：用flag记录哪个字母可以出现


```
	cin>>s;			//读入乘客输入的字符串
	int len=s.length();		//求其长度
	for(int i=1;i<=n;++i)	//一个一个比较
	{
		if(s==str[i].substr(0,len))		//如果开头相同
		{
			flag[str[i][len]-'A'+4]=1;	//用flag记录
		}
	}

```
附上代码
```
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <stdlib.h>
#include <algorithm>
#include <string>
using namespace std;
int n;
string str[55];
string s;
bool flag[40];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)		//读入
	{
		cin>>str[i];
	}
	cin>>s;
	int len=s.length();
	for(int i=1;i<=n;++i)
	{
		if(s==str[i].substr(0,len))
		{
			flag[str[i][len]-'A'+4]=1;
		}
	}
	for(int i=1;i<=32;++i)		//输出（4行，每行8个）
	{
		if(flag[i]==0)		//不可行输出“*”
		{
			cout<<'*';
		}
		else				//可行输出字母
		{
			cout<<char(i-4+'A');	//用ascll码逆推
		}
		if(i%8==0)			//到8个换行
			cout<<endl;
	}
	return 0;
}


```


---

## 作者：Tomone (赞：4)

简单的模拟，注意，千万别开ios的那个同步，全WA
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<cstring>
using namespace std;

const int maxn(55);
string tmp[maxn];
string a[4]={ 
	"***ABCDE",
	"FGHIJKLM",
	"NOPQRSTU",
	"VWXYZ***",
};
bool vis[4][9]={0}; //标记 
string temp;
inline void work(char);
inline void print(void);

int main(){
	//ios::sync_with_stdio(false); 别开这个 
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;++i){
		cin>>tmp[i];
		transform(tmp[i].begin(),tmp[i].end(),tmp[i].begin(),::toupper); //转换成大写 
	}
	cin>>temp;
	transform(temp.begin(),temp.end(),temp.begin(),::toupper);//转换成大写 
	int len=temp.length();
	for(int i=0;i<n;++i){
		string t=tmp[i].substr(0,len); //截取字符串 
		if(t!=temp) continue; //如果不相等的话就不进行判断 
		else {
			char c=tmp[i][len];
			work(c);
		}
	}
	print();
	return 0;
}
inline void work(char c){
	for(int i=0;i<4;++i){
		for(int j=0;j<8;++j){
			if(a[i][j]==c){
				vis[i][j]=1; //标记 
				break;
			}
		}
	}
}
inline void print(void){
	for(int i=0;i<4;++i){
		for(int j=0;j<8;++j){
			if(vis[i][j]==true) cout<<a[i][j]; //如果被标记就输出 
			else cout<<"*"; //否则输出* 
		}
		cout<<endl; //换行 
	}
}

```
小博客：aptx.xin,cokemine.com
Welcome

---

## 作者：5ab_juruo (赞：3)

为什么没人用字典树呢？？？

那我就来发一波~~Yeah

----
# Warning！
字典树纯为暴力方法，不要在意代码细节。

字典树，是一种多叉树，每一根枝都代表一个字母，每一种自上而下的路径都代表一个单词。

比如说以B为根，延伸出A，再延伸出G，从B到A到G，连起来，就变成单词BAG。

本题的方法也相同，通过读入字符串构建字典树，再根据用户已输入的字符走一遍。假如中间已经断掉，那就直接全部星号输出。否则到了最后的节点，查看有多少不为NULL即可。

本方法需要一些基本指针知识，如果不知道自行翻阅《C++ Primer Plus》。
## 1、基本数据结构
```cpp

struct dic_tree_node
{
	dic_tree_node * children[26];//指向子节点的指针
	
	void init ()
	{
		for (int i = 0; i < 26; i++)
			children[i] = NULL; //一定要加！！！自动分配时可能不是NULL
	}
};

struct dic_tree
{
	dic_tree_node * root;//根
	
	void init ()
	{
		root = new dic_tree_node;
	}
} Tree;
```
## 2、构建字典树
```cpp

void insert_to_dic_tree (char * word)
{
	const int len = strlen (word);
	int ind = 0;
	dic_tree_node * Node = Tree.root;
	
	while (ind < len)
	{
		if (Node->children[word[ind] - 'A'] == NULL)
		{
			Node->children[word[ind] - 'A'] = new dic_tree_node;
			Node->children[word[ind] - 'A']->init (); //不加会RE
		}
		Node = Node->children[word[ind] - 'A'];
		ind++;
	}
	return;
}

int str_count;
cin >> str_count;
char str[101];

for (int i = 0; i < str_count; i++)
{
	cin >> str;
	insert_to_dic_tree (str);
}
```
## 3、走一遍字典树
```
char board[4][9] = {
	"********",
	"********",
	"********",
	"********"
};

void printboard ()
{
	for (int i = 0; i < 4; i++)
		cout << board[i] << endl;
}

cin >> str;
dic_tree_node *Node = Tree.root;
int ind = 0, len = strlen (str);
while (ind < len)
{
	if (Node == NULL) //假如中间断了
	{
		printboard ();
		return 0;
	}
	
	Node = Node->children[str[ind] - 'A'];
	ind++;
}
```
## 4、插入可以按的按钮并输出
```cpp
void put_into_board (char ch)
{
	int index = ch - 'A' + 3;
	int row = index / 8, col = index % 8;
	
	board[row][col] = ch;
}

for (int i = 0; i < 26; i++)
	if (Node->children[i] != NULL)
		put_into_board (i + 'A');
printboard ();
```
# 完整代码附上：
```cpp
/*    Problem 4470 --
 *    Selling Tickets
 *                 -- By 2018/12/18
 */

#include <iostream>
#include <cstring>
using namespace std;

struct dic_tree_node
{
	dic_tree_node * children[26];
	
	void init ()
	{
		for (int i = 0; i < 26; i++)
			children[i] = NULL;
	}
};

struct dic_tree
{
	dic_tree_node * root;
	
	void init ()
	{
		root = new dic_tree_node;
	}
} Tree;

char board[4][9] = {
	"********",
	"********",
	"********",
	"********"
};

void insert_to_dic_tree (char * word)
{
	const int len = strlen (word);
	int ind = 0;
	dic_tree_node * Node = Tree.root;
	
	while (ind < len)
	{
		if (Node->children[word[ind] - 'A'] == NULL)
		{
			Node->children[word[ind] - 'A'] = new dic_tree_node;
			Node->children[word[ind] - 'A']->init ();
		}
		Node = Node->children[word[ind] - 'A'];
		ind++;
	}
	return;
}

void put_into_board (char ch)
{
	int index = ch - 'A' + 3;
	int row = index / 8, col = index % 8;
	
	board[row][col] = ch;
}

void printboard ()
{
	for (int i = 0; i < 4; i++)
		cout << board[i] << endl;
}

int main()
{
	Tree.init();
	
	int str_count;
	cin >> str_count;
	char str[101];
	
	for (int i = 0; i < str_count; i++)
	{
		cin >> str;
		insert_to_dic_tree (str);
	}
	
	cin >> str;
	dic_tree_node *Node = Tree.root;
	int ind = 0, len = strlen (str);
	while (ind < len)
	{
		if (Node == NULL)
		{
			printboard ();
			return 0;
		}
		
		Node = Node->children[str[ind] - 'A'];
		ind++;
	}
	
	for (int i = 0; i < 26; i++)
		if (Node->children[i] != NULL)
			put_into_board (i + 'A');
	printboard ();
	return 0;
}
```
----
机房某大佬：你可能不知道，有一种东西，叫做构造函数。

---

## 作者：Ousmane_Dembele (赞：3)

作为一个初一蒟蒻，表示BJWC2018的16道题目中就这道比较简单，考试那天还晚到没做出来，正式考试那天想得20分但不知为何只得了5分

这题可以用简单的模拟通过

思路：先建一个ans数组，全是*
```
char ans[5][9]={
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'}
};
```
一步一步模拟，成功就把后一位输入
```
#include<bits/stdc++.h>
using namespace std;
int n;
string a[111],b;//a数组是所有的数，b数组是查找的数
char ans[5][9]={
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'},
    {'*','*','*','*','*','*','*','*'}
};
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    cin>>b;//按照题意输入
    int lenb=b.size()-1;//长度是东西-1
    for(int i=1;i<=n;i++){
        bool flag=false;//判断是否可行的flag
        int lena=a[i].size()-1;
        if(lena<=lenb)continue;//lena<lenb的话不可能包含，lena=lenb的话没有后一位
        for(int j=0;j<=lenb;j++)if(b[j]!=a[i][j]){flag=true;break;}//不一样
        if(flag==true)continue;//退出
        char d=a[i][lenb+1];//最后一位
        int e=d-'A';//数字
        e+=3;//前三个是*，所以加3
        int f=e%8;//在第几列
        int g=(e-f)/8;//在第几排
        ans[g][f]=a[i][lenb+1];//把ans数组修改
    }
    for(int i=0;i<4;i++){
       for(int j=0;j<8;j++)
          cout<<ans[i][j];//输出
        cout<<endl;
    }
    return 0;
}
```
虽然我这不是最快的代码，不是代码最少的代码，但是比较容易让人理解

---

## 作者：Laser_Crystal (赞：1)

**这题的主要思想还是 ~~暴力~~ 模拟，加上一点字符串技巧~**

有个字符串函数叫做strncmp（我翻了好久的书才翻到，然而写题解前一看，已经有人这么做了QAQ），有三个参数，分别是两个字符数组和一个比较长度,用法是strncmp（char a[],char b[],int l）它是用来比较字符串a和b前l个字符是否相同；

类似于这个：
```cpp
if(a>b) return 1;
else if(a==b) return 0;
else if(a<b) return -1;
```
Pascal是这个：
```pascal
if a>b exit(1)
else if a=b exit(0)
else if a<b exit(-1);
```
所以，我们只要判断返回值是不是0就行了。

哦，对了，这里还有一个找规律的方法：

对于大写字母c，有

x坐标=（c-65）%8+3；（ord（c）mod 8+3）

y坐标=（c-65）/8；（ord（c） div 8）

这个对于往键盘上填数有帮助。

代码如下
```cpp
#include<bits/stdc++.h> 
using namespace std;
int main()
{
	char x[60][200],p[200];
	int n;
	char ans[4][8];
	memset(ans,'*',sizeof(ans));
	cin>>n;
	for(int i=0;i<n;i++) cin>>x[i];
	cin>>p;
	int l=strlen(p);
	for(int i=0;i<n;i++)
	{
		if(strncmp(p,x[i],l)==0)
		{
			int k=x[i][l]-65;
			int a=k%8+3;
			int b=k/8;
			ans[b][a]=x[i][l];
		}
	}
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<8;j++)
		cout<<ans[i][j];
		cout<<endl; 
	}
	return 0; 
}
```
代码不长，思路简单，886~

---

## 作者：andyli (赞：1)

这是一道字符串的模拟题。我们可以利用`C++`的`string`来简化我们的代码。其实存储屏幕上的字母只需要用一维数组，然后在输出的时候处理一下。

把所有的都输入完以后，检查哪个目的地字符串的前缀是当前打进去的字符，然后把这个目的地前缀的后一个字符填充到屏幕里面。思路非常简单。

代码如下：
```cpp
#include <algorithm>
#include <iostream>
#include <string>
using namespace std;
const int maxn = 55;

string A[maxn];
int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> A[i];
	string read;
	cin >> read;
	string screen(32, '*');
	size_t readlen = read.length();
	for (int i = 0; i < n; i++)
		if (A[i].substr(0, readlen) == read && A[i].length() > readlen) // 注意这个目的地的长度必须大于读入的前缀
			screen[A[i][readlen] - 'A' + 3] = A[i][readlen];
	for (size_t i = 0; i < screen.length(); i++)
	{
    	cout.put(screen[i]);
    	if ((i + 1) % 8 == 0 && i)
			cout << endl;
    }
    while (1); // 防抄袭
	return 1; // 防抄袭
}
```

---

## 作者：yzyxbw (赞：1)

这，这不是一个string就可以解决的问题吗？为什么看大佬们的题解都这么难？这么复杂？

不多说，直接上代码      **解释在代码里面**

```cpp
#include <bits/stdc++.h>
#define S1 struct
#define S2 string
using namespace std;
int n;
bool f[35];//判断是否满足输出条件
char biao[35]={"****ABCDEFGHIJKLMNOPQRSTUVWXYZ***"};//“操作界面”
S2 a[10001],b;//S2就是string上面用了宏定义。a[]存站点，b存现在输入了什么
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>b;//以上是输入
	for(int i=1;i<=n;i++){
	int len=a[i].size(),ll=b.size();//len是a[i]的长度，ll是b的长度
	int x=a[i].find(b);//这句下面有详解
	if(x==0) f[a[i][ll]-'A'+4]=1;//如果在第一位找到了这个单词，那么它的下一位就可以输出
	}
	int p=0;
	for(int i=1;i<=32;i++){
		if(f[i]) cout<<biao[i];
		else cout<<"*";//输出
		p++;
		if(p==8){
			cout<<endl;
			p-=8;
		}//换行
	}
	return 0;//完美结束
}
```

**这道题重点在此**

```cpp
int x=a[i].find(b);
```

此句意为在a[i]这串单词中从0开始寻找b这个单词，如果找到了，就将这个单词在这串单词中的首位附给x。

是不是觉得有点难以理解，看看下面这个样例就知道了

 _样例_ 
 
 ```cpp
#include <bits/stdc++.h>
#define S1 struct
#define S2 string
using namespace std;
int n,ans;
S2 a,b;
int main(){
	cin>>a>>b;
	int x=a.find(b);
	if(x!=-1)
	cout<<x;
	else cout<<"111111"<<endl;
	return 0;
}

```
_输入样例1_

**ZAZAZAZSSSS**

**ZAAAA**

_输出样例1_  **111111**

_输入样例2_

**ASDSADDDD**

**DDDD**

_输出样例2_

**5**

PS:是从0开始计数并查找的

看完样例是不是就简单易懂了呢？

所以说~~学好c++，妈妈再也不用担心我不能AK OI了~~string真的很好用

**看我这么努力，管理员你就让我过了吧**

---

## 作者：Drinkkk (赞：1)

【题目描述】

C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有$n$处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。

在自动售票机屏幕上，有一个$4$行$8$列的键盘，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/17861.png)

在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符'``*``' 取代。

告诉你$n$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。

【输入输出格式】

- 输入格式

第一行为一个整数$n$（$1 \leq n \leq 50$）。接下来$n$行，每行一个由大写英文字母组成的长度不超过$100$的字符串，表示一处目的地。最后一行，一个长度不超过$100$的字符串，表示按顺序输入的若干字符。

- 输出格式

输出一共有$4$行，每行一个长度为$8$的字符串，表示键盘状态。

【输入输出样例】

- 输入样例

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA
```

- 输出样例

```
****B*D*
*G******
********
********
```

【样例解释】

输入``ZA``以后，下一个字符可能是``G``（终点站有可能是``ZAGREB``），或``D``（终点站有可能是``ZADAR``)，或``B``（终点站有可能是``ZABOK``)。

【题解】

我会暴力！

考虑直接暴力枚举，暴力统计。复杂度为$O(n)$+大常数，不过还是能够过的。~~这可能是我有史以来最短的一篇题解了吧~~。

下面上AC代码~

```cpp
#include <cstdio>
#include <cstring>
char st[101][101];
char t[101];
int c[101];
int n=0;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",st[i]+1);
	}
	scanf("%s",t+1);
	int pt=strlen(t+1);
	for(int i=1;i<=n;i++)
	{
		int len=strlen(st[i]+1);
		if(pt<=len-1)
		{
			bool flag=true;
			for(int j=1;j<=pt;j++)
			{
				if(t[j]!=st[i][j])
				{
					flag=false;
					break;
				}
			}
			if(flag==true)
			{
				c[st[i][pt+1]]=1;
			}
		}
	}
	printf("***");
	for(int i='A';i<='E';i++)
	{
		if(c[i]==1)
		{
			printf("%c",i);
		}
		else
		{
			printf("*");
		}
	}
	printf("\n");
	for(int i='F';i<='M';i++)
	{
		if(c[i]==1)
		{
			printf("%c",i);
		}
		else
		{
			printf("*");
		}
	}
	printf("\n");
	for(int i='N';i<='U';i++)
	{
		if(c[i]==1)
		{
			printf("%c",i);
		}
		else
		{
			printf("*");
		}
	}
	printf("\n");
	for(int i='V';i<='Z';i++)
	{
		if(c[i]==1)
		{
			printf("%c",i);
		}
		else
		{
			printf("*");
		}
	}
	printf("***");
	return 0;
}
```

---

## 作者：Steinway (赞：1)

看到这道题这么高的AC率，蒟蒻瑟瑟发抖  
看了看题解，感觉都不是很中规中矩的模拟..  
(可能是我太鶸了看着有点吃力  
我相信我的代码不需要加注释就能看懂了（狂奶）  
希望那些写字符串模拟有点吃力的小伙伴能学到点东西ing~~  
  
    
写题过程：先打表出键盘，然后输入  
然后我们检测是否当前字符串满足前缀相同  
如果相同 那么我们就将前缀的下一位做上标记  
然后最后汇总的时候 如果当前数没有做标记  
就砍掉ヽ(･ω･´ﾒ) 拿去献祭scp106（变成*）  
如果做了标记就用我们之前打表中的内容即可  
Over  

```cpp
//#define fre yes

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn = 55;
string c[maxn];
string s;

bool Vis[maxn];

char h[4][8]
{
    { '*','*','*','A','B','C','D','E' },
    { 'F','G','H','I','J','K','L','M' },
    { 'N','O','P','Q','R','S','T','U' },
    { 'V','W','X','Y','Z','*','*','*' }
};

int n,flag;

template<typename T>inline void read(T&x)
{
    x = 0;char c;int lenp = 1;
    do { c = getchar();if(c == '-') lenp = -1; } while(!isdigit(c));
    do { x = x * 10 + c - '0';c = getchar(); } while(isdigit(c));
    x *= lenp;
}

int main()
{
    read(n);
    for (int i=1;i<=n;i++)
    {
        cin >> c[i];
    } cin >> s;
    
    for (int i=1;i<=n;i++)
    {
        for (int j=0;j<s.size();j++)
        {
            if(c[i][j] != s[j]) flag = 1;
        } if(flag == 1) { flag = 0; }
        else if(flag == 0) { Vis[c[i][s.size()] - 'A'] = 1; }
    }

    for (int i=0;i<4;i++)
    {
        for (int j=0;j<8;j++)
        {
            if(Vis[h[i][j] - 'A'] == 0)
            {
                printf("*");
            } else printf("%c",h[i][j]);
        } puts("");
    } return 0;
}
```  
(啊 这优美的码风 自恋++）

---

## 作者：灵光一闪 (赞：0)

~~唯一一次没编译就一波A，好感动……~~  
# 这题其实就是把所以可能的字母标记一下，然后就是愉（恶）快（心）的输出了

代码：
```
//#include<bits/stdc++.h>

#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<vector>
#include<string>
#include<cmath>
#include<map>

using namespace std;
string s[66];
string str;
bool q[26]={false};
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>s[i];
    cin>>str;
    for(int i=0;i<n;i++)//判断不解释
        if(s[i].find(str)==0)
            q[s[i][str.size()]-'A']=true;
    cout<<"***";
    for(int i=0;i<5;i++)//我用的方法比较笨，但易懂（真的易懂吗）
    {
        if(q[i])
            cout<<(char)(i+'A');
        else
            cout<<"*";
    }
    puts("");//换行
    for(int i=5;i<13;i++)
    {
        if(q[i])
            cout<<(char)(i+'A');
        else
            cout<<"*";
    }
    puts("");
    for(int i=13;i<21;i++)
    {
        if(q[i])
            cout<<(char)(i+'A');
        else
            cout<<"*";
    }
    puts("");
    for(int i=21;i<26;i++)
    {
        if(q[i])
            cout<<(char)(i+'A');
        else
            cout<<"*";
    }
    cout<<"***";
    return 0;
}
```

---

## 作者：JosephDai (赞：0)

这是一篇~~非常好懂的~~题解；
题目很简单，通过这道题，给大家介绍两个黑科技（~~其实只是做题技巧~~）	

	1、看到很多人写模拟，其实有个函数叫find，在cstring库里面，可以判断一个字符串是否在另一个字符串里出现。
    具体用法：if(!a.find(b)){cout<<"出现了”}	
    就是这么简单，一个函数，不用模拟，不用调边界，可以直接判断b是否在a中出现
    
    2、看到大家用的for循环十分复杂，蒟蒻我用了另一个技巧——类型转换
    具体用法：int('A')-> 'A'的整形表示		char(1)-> 1所对应的字符类型
    
    空说无用，上代码，具体理解一下




```cpp
#include <iostream>
#include <cstring>
using namespace std;
int n;
string a[1001]; 
string b;
int f[1000001];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>b;
	int l=b.size();
	for(int i=1;i<=n;i++){
		if(!a[i].find(b)){//技巧1
			char x=a[i][l];
			f[int(x)]=1;
		}
	}
	int cnt=3;
	cout<<"***";//凑数
	for(int i=int('A');i<=int('Z');i++){//技巧2
		if(cnt==8){
			cout<<endl;
			cnt=0;
		}
		cnt++;
		if(f[i]){
			cout<<char(i);
		}
		else{
			cout<<"*";
		}
	}
	cout<<"***";//凑数
	return 0;
}
```
就这样，ac！

---


# 「DTOI-2」星之灵

## 题目背景

### 小提醒

- 注意 $\texttt{CapsLock}$ 的大小写。

## 题目描述

### 简要题意

重复输入 $n$ 个字符串，其中：

- 当输入的字符串为 $\texttt{CapsLock}$ 时，在此之后的字符串大小写互换，直到下一个 $\texttt{CapsLock}$ 出现；
- 给定 $q$ 组询问，每次询问第 $x$ 个不为 $\texttt{CapsLock}$ 的字符串。

### 原题面

星之灵可以对你说 $n$ 句话，你需要对其做记录。

每句话可能是一个不等于 $\texttt{CapsLock}$ 的字符串，也可以是一个命令 $\texttt{CapsLock}$，其作用是控制星之灵说出的所有字母的大小写，当说出一次 $\texttt{CapsLock}$ 时，之后说出的所有小写字母均需变为大写，大写字母均需变为小写，第二次说出 $\texttt{CapsLock}$ 时又变为正常，以此类推。特别地，对于星之灵说出的 $\texttt{CapsLock}$ 命令，你无须记录。

星之灵将会不断重复说出这 $n$ 句话，且不改变顺序，而且他有 $q$ 次询问，每次询问都请你告诉星之灵，你记录的第 $x$ 句话是什么。

## 说明/提示

### 样例 #1 解释

前四次记录的语句分别为：$a,b,A,B$。

### 数据范围

| $\textbf{Subtask}$ | $n,q \le$ | $x\le $ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $100$ | $A$ | $30$ |
| $2$ | $10^4$ | $10^5$ | / | $30$ |
| $3$ | $10^5$ | $10^{18}$ | / | $40$ |

对于所有数据，$1 \leq n,q \leq 10^5,1 \leq x \leq 10^{18}$

性质 $A$：输入字符串中不存在 $\texttt{CapsLock}$。

### 数据保证

- 所有语句中至少包含一个不为 $\texttt{CapsLock}$ 的字符串；
- 所有输入的字符串长度不大于 $10$；
- 所有输入的字符串不为空且仅包含大小写字母。

## 样例 #1

### 输入

```
5
CapsLock CapsLock a CapsLock B
4
1
2
3
4```

### 输出

```
a
b
A
B```

## 样例 #2

### 输入

```
7
h W CapsLock I CapsLock j CapsLock
8
7
9
13
45
20
28
50
101```

### 输出

```
I
h
H
H
j
j
W
H```

## 样例 #3

### 输入

```
10
Oh P CapsLock CapsLock CapsLock Cv Ts CapsLock XU AR 
10
84
63
414
149
25
61
50
4043
9111
47```

### 输出

```
AR
cV
AR
XU
Oh
Oh
P
XU
cV
XU```

# 题解

## 作者：刘辰雨 (赞：4)

# The Solution of P8573

### 题意：
给出 $ n $ 个字符串，包含一定的 "CapsLock" 来决定**直到下一个 "CapsLock" 的字符串的大小写**。

假定输入不断循环，询问 $ q $  次不同次输入的字符串。

### 关键：
仔细阅读样例，不难发现，当 "CapsLock" 为奇数个时，不同的“回合”里，字符串大小写变化不一。针对此问题，可以将输入读入两边，这样保证 "CapsLock" 的数量为偶数个，从而达到创造规律的效果。

### Code:
详见代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
int n,q;
bool flag = false;
long long x;
string s_now,s_all;
vector<string> a;
string change_back(string s,bool flag)
{
	if(flag == false)
		return s;
	else
	{
		for(int i = 0 ; i< s.length() ; i++)
		{
			if('a'<= s[i] && s[i] <= 'z')
				s[i] = s[i]-'a'+'A';
			else
				s[i] = s[i]-'A'+'a';
		}
		return s;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i<= n ; i++)
	{
		cin>>s_now;
		if(s_now == "CapsLock")
			flag = !flag;
		else
		{
			a.push_back(change_back(s_now,flag));
		}
	}
	long long u = a.size();
	if(flag == true)
	{
		for(long long i = 0 ; i< u ; i++)
		{
			a.push_back(change_back(a[i],true));
		}
	}
	long long tot = a.size();
	scanf("%d",&q);
	while(q--)
	{
		scanf("%lld",&x);
		if(x <= tot)
			cout<<a[x-1]<<'\n';
		else
		{
			x %= tot;
			if(x == 0)
				x = tot;
			cout<<a[x-1]<<'\n';
		}
	}
	return 0;
}
```

### 修改日志：

#### 2022年10月10日 
第一次审核未通过。修改：删除末尾无意义内容，增加变量字母Latex 
并提交第二次。

---

## 作者：Kreedy_Ke (赞：3)

### 因为麻烦，所以本文中所有 $\texttt{CapsLock}$ 均改为 $S$。

---

拿到这题的第一反应是打表，但一看数据范围最多只能拿 60 分，所以换种思路，来找规律。

先考虑**样例 #1**的数据：$S$ $S$ $\texttt{a}$ $S$ $\texttt{B}$

过滤掉其中的 $S$，并将得到的所有星之灵说的话连起来，我们就可以得到：

$\texttt{a}$ $\texttt{b}$ $\texttt{A}$ $\texttt{B}$ $\texttt{a}$ $\texttt{b}$ $\texttt{A}$ $\texttt{B}$ $\texttt{a}$ $\texttt{b}$ $\texttt{A}$ $\texttt{B}$ $\dots$

可以发现，这些话在不断循环，循环节为 4。

再考虑一下**样例 #2**的数据：

$\texttt{YOhAwuwWhu}$ $\texttt{EhuqjPYhNY}$ $S$ $S$ $S$ $\texttt{CvHKboCfNH}$ $\texttt{QwjGTsTFnY}$ $S$ $\texttt{YxhXpGFXTU}$ $\texttt{AceSmixHlR}$

同样进行上述操作，可以得到如下序列：

$\texttt{YOhAwuwWhu}$ $\texttt{EhuqjPYhNY}$ $\texttt{cVhkBOcFnh}$ $\texttt{qWJgtStfNy}$ $\texttt{YxhXpGFXTU}$ $\texttt{AceSmixHlR}$ $\texttt{YOhAwuwWhu}$ $\texttt{EhuqjPYhNY}$ $\texttt{cVhkBOcFnh}$ $\texttt{qWJgtStfNy}$ $\texttt{YxhXpGFXTU}$ $\texttt{AceSmixHlR}$ $\dots$

同样我们也可以发现这些话在循环，循环节为 6。

这时就可以总结规律了：**设星之灵说的 $n$ 句话中非 $S$ 的个数为 $a$，则其所说的话将以 $a$ 或 $2a$ 为循环节循环。** 由于以 $a$ 为循环节也可以看成是以 $2a$ 为循环节，因此只需考虑以 $2a$ 作为循环节的情况。

而要求说出的第 $x$ 句话，则只需要先将这 $2a$ 句话先预处理出来，然后直接输出其中的第 $x\bmod 2a$ 句话即可。

以下为代码：

```
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+9;
const string S="CapsLock";
string orig[N],s[N];
int n,q,cnt=1;
string Change ( string x ) //改变整句话的大小写
{
    int len=x.size();
    for ( int i=0 ; i<len ; i++ )
        if ( x[i]>='a' && x[i]<='z' )
            x[i]=toupper(x[i]);
        else x[i]=tolower(x[i]);
    return x;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n; bool wy=0;
    for ( int i=1 ; i<=n ; i++,cnt++ )
    {
        cin>>orig[i]; //原输入的所有字符串
        if ( orig[i]==S ) wy=!wy,cnt--; //改变大小写
        else if ( !wy ) s[cnt]=orig[i];
        else s[cnt]=Change(orig[i]);
    }
    for ( int i=1 ; i<=n ; i++,cnt++ ) //重复处理一次
        if ( orig[i]==S ) wy=!wy,cnt--;
        else if ( !wy ) s[cnt]=orig[i];
        else s[cnt]=Change(orig[i]);
    cin>>q; cnt--;
    while ( q-- )
    {
        long long t; cin>>t; t=t%cnt;
        if ( t ) cout<<s[t]<<"\n";
        else cout<<s[cnt]<<"\n";
    }
    return 0;
}
```

---

## 作者：zt17 (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P8573)

祝贺 DTOI Round2 顺利召开！

$\texttt{update：}$

- 2023.4.26 : 感谢 [@StandardManager](https://www.luogu.com.cn/user/912750) 提出的建议：`(c[0] == 'C' && ... && c[7] == 'k') 由于是 stl の string 所以可以直接判断 if (c == "CapsLock") ` ，所以改变了一下代码。

### 题意简介

其实题目已经讲得很清楚了~~好吧再讲一次~~

给你 $n$ 个字符串，其中有正常的字符串（不包含 $\texttt{CapsLock}$），这种需要存起来。也有 $\texttt{CapsLock}$。你需要把所有字符串存储起来。当出现一个 $\texttt{CapsLock}$ 时，输入的字符串中的字母需转换大小写(大写 $\rightleftharpoons$ 小写），直到下一次出现 $\texttt{CapsLock}$。最开始读入的字符串是正常的。然后会进行 $q$ 次询问，你需要输出第 $x$ 个输入的字符串（不包括  $\texttt{CapsLock}$）。

### 思路分析

可以创建一个 ```string``` 数组和一个全局变量 $m$，然后对输入的字符串进行判断（长度、字符一一比较），如果输入的字符串是 $\texttt{CapsLock}$，那么如果 $m$ 非零，则把 $m$ 设为 ```'a' - 'A'```的值。否则设为 $0$。如果输入的是正常的字符串的话，每个字符判断一次，大写字母的值加上 $m$，小写字母的值减去 $m$。最后按照给定的输出就可以了。

### 正解代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int m;
int main()
{
    string a[10086];
    int n;
    cin >> n;
    for(int i=1;i<=n;i++)
    {
        string c;
        cin >> c;
        if(c == "CapsLock")
            if(!m)
                m = 'a' - 'A';
            else
                m = 0;
        else
            for(int j=0;j<=c.size();j++)
            {
                if(c[j] <= 'A' && c[j] >= 'a')
                    c[j] += m;
                else 
                    c[j] -= m;
                a[i] = c;
            }
    }
    int q;
    cin >> q;
    for(int i=1;i<=q;i++)
    {
        long long int qwq;
        cin >> qwq;
        qwq = qwq % n;
        cout << a[qwq] << endl;
    }
    return 0;
}
```


---

## 作者：ImposterAnYu (赞：2)

# 解析
这道题的 $x$ 很大，所以很明显不能暴力，所以我们需要从中找点规律。

观察题面可以发现，第 $i$ 个不为 `CapsLock` 的单词输出时是否大小写反转只与在这个单词之前 `CapsLock` 的个数的奇偶性有关。所以，我们只需要知道每 $n$ 个单词中 `CapsLock` 个数的奇偶性和 $n$ 个单词内前 $(i - 1) \bmod m + 1$ 个单词中 `CapsLock` 个数的奇偶性（$m$ 为 $n$ 个单词内不为 `CapsLock` 的单词的个数），就可以推出第 $i$ 个单词输出时是否大小写反转了。

至于具体流程的话……我放代码里了，你们慢慢看吧（光速逃）~
# AC code
```c++
#include<bits/stdc++.h>
#define N 100005
#define int1 long long
using namespace std;
int1 n,m,q,i,j,x,l[N],y,e;
char a[N][15],fa[N][15],ch[15],mo[15] = {'\0','C','a','p','s','L','o','c','k'};
bool w,s[N];
int1 read(){//很烂的快读。
    int1 x = 0,f = 1;
    char ch = getchar();
    while(!isdigit(ch)){
        if(ch == '-'){
            f = -1;
        }
        ch = getchar();
    }
    while(isdigit(ch)){
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(int1 x){//更烂的快写。
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9){
        print(x / 10);
    }
    putchar(x % 10 + 48);
    return ;
}
int main(){
	n = read();
	for(i = 1; i <= n; i++){
		scanf("%s",ch + 1);
        l[0] = strlen(ch + 1);
        for(j = 1; j <= 8; j++){
            if(ch[j] != mo[j]){
                break;
            }
        }
        if(l[0] == 8 && j > 8){//如果这个单词是 CapsLock，
            w ^= 1,e++;//奇偶性反转（w 是 n 个单词里 CapsLock 个数的奇偶性，e 是 n 个单词里 CapsLock 的个数）。
        }else{
            s[++m] = w,l[m] = l[0];//m 是 n 个单词内不为 CapsLock 的单词个数。
            for(j = 1; j <= l[0]; j++){
                a[m][j] = ch[j],fa[m][j] = (ch[j] >= 'A' && ch[j] <= 'Z' ? ch[j] + 'a' - 'A' : ch[j] + 'A' - 'a');//fa[i] 是 a[i] 大小写反转后的字符串。
            }
        }
	}
	q = read();
    while(q--){
        x = read(),y = (x - 1) % m + 1;//y 表示第 x 个不为 CapsLock 的单词是 m 个单词里的第几个。
        if(!e){//如果没有任何 CapsLock，
            for(i = 1; i <= l[y]; i++){//直接输出原串。
                putchar(a[y][i]);
            }
            putchar('\n');
        }else{
            x = (x - 1) / m;//x 变为在 m 个单词里循环的次数。
            if((x * w + s[y]) & 1){//如果第 x 个单词之前有奇数个 CapsLock，
                for(i = 1; i <= l[y]; i++){//输出大小写反转之后的字符串。
                    putchar(fa[y][i]);
                }
                putchar('\n');
            }else{//否则，
                for(i = 1; i <= l[y]; i++){//直接输出原串。
                    putchar(a[y][i]);
                }
                putchar('\n');
            }
        }
    }
	return 0;
}
```
时间复杂度 $O(n + s + q)$（$s$ 是 $n$ 个字符串的总长度），只跑了 $31ms$，还是蛮快的。

---

## 作者：cyhtxdy (赞：2)

算是无脑暴力吧。

首先看题目，感觉 “重复在键盘上输入 $n$ 个字符串” 这个操作是有周期性的。

那可以先线性处理字符串，询问的时候直接对周期长度取模即可。

但现在我又不知道什么时候出现周期，怎么找呢？

~~虽然很显然长度为 $2n$，但是我就是不用脑子做。~~

看到 $n\le 10^5$，那么就可以在不爆空间和不超时的前提下多模拟这个过程并存储下来，保证会有周期。那我就重复做 $20$ 次这个操作，每次查询 $O(1)$ 输出即可。

得到代码：
```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int inf = 0x3f3f3f3f;
const int N = 2e6 + 7;

string s[N], x[N];
int n, q, p = 0, tot = 0;

string change (string x) {
	//将一个字符串大写字母转小写，小写字母转大写 
	string ans = "";
	for (int i = 0; i < x.size (); i ++) {
		if (x[i] >= 'a' && x[i] <= 'z') {
			ans += x[i] - 'a' + 'A';
		}
		else if (x[i] >= 'A' && x[i] <= 'Z') {
			ans += x[i] - 'A' + 'a';
		}
	}
	return ans;
}

int main () {
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> x[i];
		if (x[i] == "CapsLock") {
			p ++;
		}
		else {
			if (p & 1) {//奇数次是有影响的 
				s[++ tot] = change (x[i]);
			}
			else {//偶数次就抵消了 
				s[++ tot] = x[i];
			}
		}
	}//首先做第一次模拟 
	for (int k = 2; k <= 20; k ++) {//再重复做19次 
		for (int i = 1; i <= n; i ++) {
			if (x[i] == "CapsLock") {
				p ++;
			}
			else {
				if (p & 1) {
					s[++ tot] = change (x[i]);
				}
				else {
					s[++ tot] = x[i];
				}
			}
		}
	}
	cin >> q;
	while (q --) {
		long long x;
		cin >> x;
		if (! (x % tot)) {
			cout << s[tot] << endl;
		}
		else {
			cout << s[x % tot] << endl;
		}
		//周期长度为tot，直接取模输出即可 
	}

	return 0;
}

```


---

## 作者：sylqwq (赞：2)

简单模拟。

我们设除了 $\text{CapsLock}$ 以外的字符串为“好的字符串”。

我们发现 $x$ 非常大，直接做是不行的，所以要维护一些周期信息。首先要维护一个周期内有多少个 $\text{CapsLock}$ 和多少个好的字符串，这样根据 $x$ 求出整周期个数后能快速得到整周期部分有多少 $\text{CapsLock}$。为了处理除去整周期外的部分，我们还要维护一个 $p$ 数组，$p_i$ 表示一个周期中第 $i$ 个好的字符串之前，有多少个 $\text{CapsLock}$。

这样对于一个 $x$，我们就能快速得到当前 $\text{CapsLock}$ 个数了，根据奇偶性决定是否大小写翻转。然后再求出第 $x$ 个字符串是一段周期中的第几个，找到对应字符串输出就好了。

代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=100010;
string s,a[N];
int n,m,tot,p[N];
void calc(char c){
	if(c>='A'&&c<='Z')
		cout<<char(c+'a'-'A');
	else
		cout<<char(c-'a'+'A');
}
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
signed main(){
	n=read();
	int cnt=0;
	for(int i=1;i<=n;i++){
		cin>>s;
		if(s=="CapsLock")
			cnt++;
		else{
			a[++tot]=s;
			p[tot]=cnt;
		}
	}
	m=read();
	for(int i=1;i<=m;i++){
		int x;
		x=read();
		int xx;//第 x 个字符串是一个周期中的第几个好的字符串
		int rev;//CapsLock 个数
		if(x%(n-cnt)==0){
			xx=n-cnt;
			rev=(x/(n-cnt)-1)*cnt+p[xx];
		}
		else{
			xx=x-(x/(n-cnt)*(n-cnt));
			rev=cnt*(x/(n-cnt))+p[xx];
		}
		if(rev%2==0)
			cout<<a[xx]<<'\n';
		else{
			for(int j=0;j<(a[xx].length());j++)
				calc(a[xx][j]);
			cout<<'\n';
		}
	}
}
```

---

## 作者：what_can_I_do (赞：2)

[传送门](https://www.luogu.com.cn/problem/P8573)

这道题我们可以先把需转换大小写的给转换了，接着我们可以发现 $x\le 10^{18}$，很明显直接循环会 TLE，所以我们就得用到小学的知识——周期问题求解。

我们先判断这一个字符串中有多少个 `CapsLock`，如果是奇数，我们就需要在字符串后面多加一个原本的字符串，但是加上去的字符串要把里面所有单词的字母都转换大小写，其中单词的数量也要乘 $2$，最后用 $x$ 对单词数量取模，再输出对应的单词就行了。

注：这道题我是用二维的 char 数组存储单词的。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,n,q,s=0,l=1;
char a[200000][100],cmp[9]="CapsLock",cs[100];
int main()
{
	scanf("%lld",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%s",&cs);
		if(strcmp(cs,cmp)==0) s++;
		else
		{
			if(s%2) for(register int j=0;j<strlen(cs);j++) if(cs[j]>='a'&&cs[j]<='z') cs[j]=cs[j]-'a'+'A';else if(cs[j]>='A'&&cs[j]<='Z') cs[j]=cs[j]-'A'+'a';
			strcpy(a[l],cs),l++;
		}
	}
	l--;
	if(s%2)
	{
		for(register int i=1;i<=l;i++)
		{
			strcpy(a[i+l],a[i]);
			for(register int j=0;j<strlen(a[i+l]);j++) if(a[i+l][j]>='a'&&a[i+l][j]<='z') a[i+l][j]=a[i+l][j]-'a'+'A';else if(a[i+l][j]>='A'&&a[i+l][j]<='Z') a[i+l][j]=a[i+l][j]-'A'+'a';
		}
		l*=2;
	}
	scanf("%lld",&q);
	for(register int i=1;i<=q;i++)
	{
		scanf("%lld",&x);
		if(x%l==0) printf("%s\n",a[l]);else printf("%s\n",a[x%l]);
	}
	return 0;
}
```

---

## 作者：wdgm4 (赞：1)

~~发题解的人好少啊，那我也来水一波~~


------------
注：我们暂时把每个不等于 $\texttt{CapsLock}$ 的字符串叫为字符串。

因为 $x \le 10^{18}$ ，所以首先排除巨暴力。看题意，一个命令 $\texttt{CapsLock}$ 可以让之后的字符串变换大小写，直到遇到下一个 $\texttt{CapsLock}$ 。假设 ~~猩~~ 之灵说的每 $n$ 句话为一段，那么有两种情况：

- 在还未开始这一段时，前面的命令 $\texttt{CapsLock}$ 数为偶数或这一段本来就是第一段（即是正常大小写）。

- 在还未开始这一段时，前面的命令数为奇数（即是非正常大小写）。

那么操作的周期就为 $2$。

最后询问的话，只需要让 $x$ 取余记录数的长度就行了


## code

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define yee 1919810

using namespace std;
int n,q,len;
string cap="CapsLock";
bool c;
string a[200010],s[100010];
string gg(string s){//替换大小写 
	for(int i=0;i<s.length();i++){
		s[i]^=' ';//注：' '==32
	}
	return s;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		if(s[i]==cap){
			c=!c;
		}else{
			if(c) a[++len]=gg(s[i]);
			else a[++len]=s[i];
		}
	}
	for(int i=1;i<=n;i++){
		if(s[i]==cap){
			c=!c;
		}else{
			if(c) a[++len]=gg(s[i]);
			else a[++len]=s[i];
		}
	}
	cin>>q;
	for(int i=1;i<=q;i++){
		long long nem;
		cin>>nem;
		if(nem%len==0){
			cout<<a[len]<<endl;
		}else{
			cout<<a[nem%len]<<endl;
		}
	}
	return 0;
}

```


---

## 作者：Wind_Smiled (赞：1)

## 题意

重复在键盘上输入 $n$ 个字符串，若字符串为 $\texttt{CapsLock}$ 则之后所有字符串大写转小写，小写转大写，第二次出现 $\texttt{CapsLock}$ 时变为正常。最开始输入的字母大小写为正常，有 $q$ 次询问，每次问第 $x$ 个打入的字符串是什么（不计算 $\texttt{CapsLock}$）。

第一行一个整数 $n$。

接下来一行 $n$ 个字符串，用空格隔开，表示星之灵说的话。

第三行一个整数 $q$，表示星之灵的询问次数。

接下来 $q$ 行，每行一个正整数 $x$。

对于所有数据，$1 \leq n,q \leq 10^5,1 \leq x \leq 10^{18}$

数据保证星之灵说的话中至少存在一个非 $\texttt{CapsLock}$ 的字符串，任意字符串的长度 $\le 10$，且星之灵的话中只有字符串和 $\texttt{CapsLock}$。

所有字符串不为空且仅包含大小写字母。

## 分析
记录每一次非 $\texttt{CapsLock}$ 的字符串并存入一个数组，进行扫描，所以要将另一个数组存入前面所含有的 $\texttt{CapsLock}$ 的个数。

显然，查询的个数可能远远大于字符串总个数，所以计算每次扫描的轮数和剩余的个数，进行计算。

如果是整轮数，就把总 $\texttt{CapsLock}$ 的数量进行判断，如果为奇数，就转化大小写输出，否则直接输出即可。

因为 $x \leq 10^{18}$，所以要开 `long long`。


------------

代码如下：
```cpp
#include<bits/stdc++.h> 
#define int long long//x<=10的18次方，会爆int 
using namespace std;
const int MAXN=100005;
string s,a[MAXN];
int n,m,tot,p[MAXN],cnt;
void change(char c){//转化字符串 
	if(c>='A'&&c<='Z'){//如果是大写字母 
		cout<<char(c+'a'-'A');
	}
	else{//如果是小写字母 
		cout<<char(c-'a'+'A');
	}
}
int read(){//数据规模比较大，用快读加一下速 
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			w=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
signed main(){//#define int long long 以后一定要用 signed main 
	n=read();
	for(int i=1;i<=n;i++){
		cin>>s;
		if(s=="CapsLock"){//如果是 CapsLock，计数器+1 
			cnt++;
		}
		else{
			a[++tot]=s;//对于每次非 CapsLock 的读入，存入数组 a 
			p[tot]=cnt;//每一个非 CapsLock的字符，对应存入前面有的 CapsLock 的个数 
		}
	}
	m=read();
	for(int i=1;i<=m;i++){
		int x;
		x=read();
		int c;
		int CAPSLOCK;
		if(x%(n-cnt)==0){
			c=n-cnt;
			CAPSLOCK=(x/(n-cnt)-1)*cnt+p[c];
		}
		else{
			c=x-(x/(n-cnt)*(n-cnt));
			CAPSLOCK=cnt*(x/(n-cnt))+p[c];
		}
		if(CAPSLOCK%2==0){
			cout<<a[c]<<'\n';//不需要转化的输出 
		}
		else{
			for(int j=0;j<(a[c].length());j++){
				change(a[c][j]);//转化输出 
			}
			cout<<'\n';
		}
	}
}
```

---


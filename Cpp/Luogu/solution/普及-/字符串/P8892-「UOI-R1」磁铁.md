# 「UOI-R1」磁铁

## 题目描述

有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。

你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：

1. 将前若干个字符删除，例如删除 $\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\texttt{87}$。
2. 将后若干个字符移至前面去，例如将 $\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\texttt{98791}$。

问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。

为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。

## 说明/提示

**【样例解释 #1】** 

$$
\texttt{12341234}\\ \to \texttt{1234}\\ = \texttt{1234}
$$

**【样例解释 #2】** 

$$
\texttt{6012739810910020338452}\\
\to \texttt{2601273981091002033845}\\
\to \texttt{601273981091002033845}\\
\to \texttt{384560127398109100203}\\
\to \texttt{4560127398109100203}\\
\to \texttt{0345601273981091002}\\
\to \texttt{345601273981091002}\\
\to \texttt{091002345601273981}\\
\to \texttt{2345601273981}\\
\to \texttt{3981234560127}\\
\to \texttt{81234560127}\\
\to \texttt{01278123456}\\
\to \texttt{78123456}\\
\to \texttt{12345678} \\
=\texttt{12345678}
$$

**【数据范围】**

以下记 $ \left| a \right|$ 表示每组数据磁铁 $a$ 的长度，$\left| b \right|$ 表示每组数据磁铁 $b$ 的长度。

对于 $20\%$ 的数据，保证 $\left| a \right| = 1$。

对于另外 $20\%$ 的数据，保证 $\left| b \right| = 1$。

对于 $100\%$，保证 $1 \leq \left| a \right|, \left| b \right| \leq 1000$，$1 \leq t \leq 10$。

保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。



## 样例 #1

### 输入

```
1
12341234
1234```

### 输出

```
Y```

## 样例 #2

### 输入

```
1
6012739810910020338452
12345678```

### 输出

```
Y```

## 样例 #3

### 输入

```
1
123456789
465```

### 输出

```
N```

## 样例 #4

### 输入

```
见文件附件的 magnets4.in```

### 输出

```
见文件附件的 magnets4.ans```

# 题解

## 作者：cosf (赞：8)

[P8892 磁铁](https://www.luogu.com.cn/problem/P8892)
---

先别想着做题！先别想着做题！先别想着做题！重要的事情说三遍！
---

我们先看看那两个操作都是有什么用的

举个栗子：有个字符串叫做：`crazyouthcosf`，那么我们可以把它想象成这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/3gym5xyi.png)

那么，第二个操作可能很多人都会想象成这个样子：


![](https://cdn.luogu.com.cn/upload/image_hosting/3gym5xyi.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/v1yzpff0.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/v3j2xji2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/201x4yqt.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/mopery1n.png)

对吧。但是，这样处理很难理解。我们可以换一个思路：

![](https://cdn.luogu.com.cn/upload/image_hosting/9pedcc86.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/yxa2ycio.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/btmwfdj5.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3lmbln97.png)

这不就是一个环吗！也就是说，在这个环里面，磁铁的相对位置是不会变的。那么对于第一个操作，其实就是删除环中的任意连续的一段！那么其实就可以理解了。

我们可以先把题目中的 $a$ 看作一个环，然后再在里面匹配一下，看看 $b$ 是不是他的子序列，并且长度小于或等于 $a$，如果是，$a$ 就可以变成 $b$，否则就不行。比如说，`ytcoaz` 是 `crazyouthcosf` 环中的一个子序列，而 `crthou` 不是。

毕竟 $O(n^2)$ 是可以过的，所以朴素的算法是可以的 ~~（其实是高级算法我不会）~~。

```cpp
#include <iostream>
using namespace std;

int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        string a, b;
        cin >> a >> b;
        int alen = a.length();
        int blen = b.length();
        a = a + a;
        b = " " + b;
        int ys = 0;
        for (int i = 0; i < alen; i++)
        {
            string c = a.substr(i, alen); // 枚举环中的每一条边，这样确保了枚出来的子串长度一定小于或等于 a 的长度。
            int cur = 0;
            for (int j = 0; j < alen; j++)
            {
                if (c[j] == b[cur + 1])
                {
                    cur++;
                }
                if (cur == blen)
                {
                    ys = 1;
                    break;
                }
            }
            if (ys)
            {
                break;
            }
        }
        if (ys)
        {
            cout << 'Y' << endl;
        }
        else
        {
            cout << 'N' << endl;
        }
    }
}

```


---

## 作者：Shanganze (赞：4)

本人在这里只介绍一种 $O(n^2)$ 做法，如有大佬会 $O(n)$ 请指教。

先看第一种操作，每次删除字符串前几个字符，在搭配上可以将字符串前几个字符移动到末尾。上述操作就可以将其转换成原字符串的任意一个子序列。

举个例子,字符串 $114514$ 经上述操作后 变成 $115$ 。我们先将前两个字符放到最后变为 $451411$，删除第一个字符变为 $51411$，再将第一个字符移到末尾，删除前两个字符得 $115$。

而又由于可以将前几个字符移到末尾，我们可以在原字符串后面接一个相同的字符串，来处理用由哪个字符开头来枚举的问题。

具体操作见代码

### 代码：
```c
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		string a,b;int p=0;
		cin>>a>>b;a+=a;
		int n=a.size(),m=b.size();
		for(int q=0;q<n/2;q++){
			int l=0;
			for(int w=q;w<q+n/2;w++){
				if(b[l]==a[w]){
					l++;
				}
			}
			if(l==m){
				p=1;
				break;
			}
		}
		if(p==1)cout<<"Y\n";
		else cout<<"N\n";
	}
	return 0;
} 
```


---

## 作者：yeshubo_qwq (赞：2)

## Solution

操作 $2$ 使得磁铁 $a$ 本质为环，结合操作 $1$，可以删除任意位置的字符。

破环为链，以每个位置为起点进行判定，使用双指针可以做到 $O(n^2)$（$n$ 为磁铁长度）。

## Code

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
int T,n,m,i,l,r,sum;
string s,t;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T;
	while (T--){
		cin>>s>>t;
		n=s.size(),s=" "+s+s;
		m=t.size(),t=" "+t;
		if (n<m){
			cout<<"N\n";
			continue;
		}
		for (i=1;i<=n;i++){
			l=i,r=1,sum=0;
			while (l<=i+n-1 && r<=m)
				if (s[l]==t[r]) l++,r++,sum++;
					else l++;
			if (sum==m) break;
		}
		cout<<(i>n?"N\n":"Y\n");
	}
	return 0;
}

```


---

## 作者：ダ月 (赞：1)

### 题目分析：

对于操作 $2$，我们可以理解成将字符串 $a,b$ 理解成一个环。所以这道题变成了一道环上的问题，我们可以选择**断环为链**。

对与操作 $1$，删除字符我们可以理解成将环上相邻两个字符中间所有的字符删去。那么这道题变成了环上的**子序列匹配**。

由于 $1 \leq \left| a \right|, \left| b \right| \leq 1000$，可以直接暴力匹配。

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=2010;
char a[N],b[N];
int t;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%s",a+1);
		scanf("%s",b+1);
		bool flag=false;
		int LA=strlen(a+1),LB=strlen(b+1);
		for(int i=LA+1;i<=LA<<1;i++) a[i]=a[i-LA];LA;
		for(int i=1;i<=LA;i++){
			int pos=1;
			for(int j=i;j<=i+LA-1;j++)
				if(b[pos]==a[j]){
					pos++;
					if(pos==LB+1) break;
				}
			if(pos==LB+1){
				puts("Y");
				flag=true;
				break;
			}
		}
		if(!flag) puts("N");
	}
	return 0;
}
```

### 细节：
断环为链，需要两倍空间。


---

## 作者：BugGod (赞：0)

首先来看操作 $2$ ，可以发现这个操作将磁铁 $a$ 变成了一个环（因为利用操作 $2$ 可以做到首尾相连的效果）。因此我们考虑倍增。

再来看操作 $1$ ，这时就明了多了。事实上就是删除环上任意连续的一段。

最终问题就变成了：求字符串 $b$ 是否为环 $a$ 的子序列。

子序列：从序列中挑出任意个且任意一些元素，并从左往右排列的序列。

这个问题，可以利用双指针来求解。若 $b_i$ 可以匹配，则检查 $b_{i+1}$ 是否可以匹配 $\cdots\cdots$ 以此类推。

代码就不挂了，杜绝 $\texttt{Ctrl+C}$ 。

---

## 作者：MH_SLC (赞：0)

## 题目分析
思路：将第一串字符串看成一个环，环中数字的顺序不能改变，查找环中是否含有第 $2$ 个字符串。这里将第一串字符串等于第一串字符串加第一串字符串，从$i$  到 $i+n(0 \leq i<n)$ 就是成环后第一串字符串的所有可能。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll MAXN = 1010, mod = 998244353;

inline int read() {
	int x = 0;
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x;
}
int T = read();
signed main() {
	string a, b;	//母串和字串
	while (T--) {
		cin >> a >> b;
		int n = a.size(), m = b.size();
		bool flag = false;
		if (m > n) {
			cout << "N" << endl;
			continue;
		}
		a += a;
		for (int i = 0; i < n; ++i) {
			int ans1 = i, ans2 = 0;
			while (ans1 < n + i && ans2 < m) {
				if (a[ans1] == b[ans2])ans1++, ans2++;
				else ans1++;
			}
			if (ans2 == m) {
				flag = true;
				break;
			}
		}
		if (flag) cout << "Y" << endl;
		else cout << "N" << endl;
	}
	return 0;
}
```


---

## 作者：_Remake_ (赞：0)

## 题目分析
如果你学习过最小表示法，可以发现，操作二就是构造 $a$ 的循环同构串，同时可以发现，操作一就是在这些同构串里删除一段连续的元素，由于操作次数不限，所以可以得出以下解法：构造 $b$ 的所有循环同构串，检查每个串是否是 $a$ 的子序列，如果存在一个 $b$ 的同构串使其为 $a$ 的子序列则有解，否则无解。
时间复杂度：$\mathcal{O}(t|b|^2)$
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
int read()
{
    int n=0,k=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        {
            k=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        n=n*10+ch-'0';
        ch=getchar();
    }
    return n*k;
}
int n,m,t;
char S[1145];
char C[1919];
char SC[1201][1201];
namespace qwq
{
    void main()
    {
        t=read();
        while(t--)
        {
            memset(SC,0,sizeof SC);
            memset(S,0,sizeof S);
            memset(C,0,sizeof C);
            std::cin>>(S+1);
            std::cin>>(C+1);
            int lA=strlen(S+1);
            int lB=strlen(C+1);
            for(int r=1;r<=lB;r++)
            {
                for(int f=r;f<=lB;f++)
                {
                    SC[r][f]=C[f-r+1];
                }
                for(int f=1;f<=r-1;f++)
                {
                    SC[r][f]=C[lB-r+f+1];
                }
            }
            bool flag=0;
            for(int r=1;r<=lB;r++)
            {
                int now=1;
                for(int f=1;f<=lA;f++)
                {
                    if(S[f]==SC[r][now])
                    {
                        now++;
                    }
                }
                if(now==lB+1)
                {
                    flag=1;
                    break;
                }
            }
            if(!flag)
            {
                puts("N");
            }
            else
            {
                puts("Y");
            }
        }
        return;
    }
}
signed main()
{ 
    //std::cout<<system("diff qwq.out queries3.ans");
    //freopen("qwq.in","r",stdin);
    //freopen("qwq.out","w",stdout);
    qwq::main();
    return 0;
}
/*
*/


```


---

## 作者：so_find_skind (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8892)

## 题目分析

其实不难分析的。

首先，第一种操作可以删除前 $x$ 个字符，而第二种操作可以将后 $x$ 个字符转移到前面去，互相结合可以发现，实际上后面的字符也是可以连续剔除的。

其次，将后 $x$ 个字符转移给前方，其实就是一种“全体后退”的现象而已，也就是说，在某种情况下，如果磁铁 $a$ 在执行 $n$ 次此操作之后可以得到磁铁 $b$ 的话，也是可以的。

总结：对于此题，只有在磁铁 $a$ 执行第二种操作时可以转换为磁铁 $b$ 或包含磁铁 $b$ 的时候是能够输出 `Y` 的，其余一并输出 `N`。

由于~~作者很懒~~此题比较简单，就不在这里放代码了。

完结撒花！

---


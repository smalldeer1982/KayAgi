# [CSP-J2022 山东] 植树节

## 题目背景

受疫情影响，山东省取消了 CSP-J 2022 认证活动，并于次年三月重新命题，在省内补办比赛。

## 题目描述

植树节快要到了，学校要组织志愿者去给树苗浇水。

有一排树苗，编号依次是 $0,1,2,\dots$。

现有 $n$ 个志愿者去给树苗浇水，第 $i$ 个志愿者选定了一个区间 $\left[a_{i},b_{i}\right]$ ，表示第 $i$ 个志愿者将 $\left[a_{i},b_{i}\right]$ 这一区间内的每一棵树都浇一次水。

如某个志愿者选择的浇水区间为 $\left[4,9\right]$ ，表示他将给编号为 $4,5,6,7,8,9$ 的树各浇水一次。

当所有的志愿者完成各自所选区间的浇水后，可能有些树苗被不同的志愿者浇水多次，也可能有的树苗一次也没被浇过水。

请你求出浇水最多的树苗被浇了多少次。

## 说明/提示

### 数据范围
* 对于所有的数据： $n \le 10^{5}$；$0\le a_{i}\le b_{i}\le 10^{6}$。  

|测试点编号|$a_{i}\le$|$b_{i}\le$|$n\le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1,2,3$|$10^{3}$|$10^{3}$|$10^{3}$|无|
|$4,5,6,7$|$10^{6}$|$10^{6}$|$10^{5}$|无|
|$8$|$10^{6}$|$10^{6}$|$10^{5}$|$a_{i}=b_{i}$|
|$9$|$10^{6}$|$10^{6}$|$10^{5}$|$a_{i}=1,b_{i}=10^{3}$|
|$10$|$10^{6}$|$10^{6}$|$10^{5}$|无|

## 样例 #1

### 输入

```
4
0 2
2 4
1 4
6 7```

### 输出

```
3```

## 样例 #2

### 输入

```
4
1000000 1000000
1000000 1000000
0 1000000
1 1000000```

### 输出

```
4```

# 题解

## 作者：2011hym (赞：14)

## 题目分析

一道比较水的差分题目。

本题的核心问题是有一排编号从 $0$ 开始的树苗，$n$ 个志愿者会分别给一个区间内的树苗浇水，需要找出浇水次数最多的树苗的浇水次数。

## 思路分析

本题可以使用差分的思想来解决。差分是一种对区间进行修改的高效方法，通过记录区间端点的变化，最后再通过前缀和还原出每个位置的实际值。

先进行读入，再将每次差分的数据求出。

- 通过前缀和的方式还原每个位置的实际浇水次数。`c += diff[i]` 表示当前位置的浇水次数等于前一个位置的浇水次数加上当前位置的变化量。
- 在计算过程中，不断更新 `sum` 的值，确保 `sum` 始终记录着浇水最多的树苗的浇水次数。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int diff[1000010], n, a, b, sum, c;
signed main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a >> b;
        diff[a]++;
        if (b + 1 <= 1000010) diff[b + 1]--;//先进行差分
    }
    for (int i = 0; i <= 1000000; i++) {
        c += diff[i];
        if (c > sum) sum = c;//再进行前缀和
    }
    cout << sum;
    return 0;
}
```

一道橙题就这么被秒了。

**upd：2025.7.17** 感谢三位好心人指出错误

---

## 作者：Vct14 (赞：6)

差分基础练习题。

题意：有一个初始全部为 $0$ 的序列 $a$，$n$ 次操作，每次操作给定 $l,r$，将区间 $[l,r]$ 内的元素加一。求操作完后序列最大值。

我们定义一个数组 $c$，使得 $c_i=a_i-a_{i-1}$。有 $a_i=\sum\limits_{j=1}^i c_i$。如果 $a_i$ 加上了 $1$，那么 $c_i$ 会增加 $1$，$c_{i+1}$ 会减少 $1$。则如果一个区间都加 $1$ 的话，中间的减 $1$ 和加 $1$ 都被抵消，只剩下 $c_l$ 加一和 $c_{r+1}$ 减一。

然后求出原数组的各项找最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+2;
int cf[N];

int main(){
	int M=1e6;
	int n;cin>>n;
	while(n--){
		int l,r;cin>>l>>r;
		cf[l]++;cf[r+1]--;
	}
	int x=0,mx=-1;
	for(int i=0; i<=M; i++){
		x+=cf[i];
		mx=max(mx,x);
	}
	cout<<mx;
	return 0;
}
```

---

## 作者：封禁用户 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P11853)

## 题意

给你一串数，每次把区间 $[a_i,b_i]$ 内的数都加 $1$，求最后最大的数的值。

## 思路

差分板子题，每次把 $d_a$ 加 $1$（求前缀和后就相当于把位置 $a$ 以及后面的数都加了 $1$），再把 $d_{b+1}$ 减 $1$（求前缀和后就相当于把位置 $b+1$ 以及后面的数都减了 $1$），就做到了把 $[a,b]$ 这个区间都加上 $1$。最后把 $d$ 数组做个前缀和统计最大值即可。

```cpp
#include <iostream>
using namespace std;

const int N = 1e6 + 5;
int d[N];

int main() {
  ios::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  
  int n;
  cin >> n;
  int mx = 0;
  for (int i = 1; i <= n; i++) {
    int l, r;
    cin >> l >> r;
    mx = max(mx, r);
    d[l]++, d[r + 1]--;
  } int ans = 0;
  for (int i = 0; i <= mx; i++) {
    d[i] += d[i - 1];
    ans = max(ans, d[i]);
  } cout << ans;
  return 0;
}
```

---

## 作者：Wide_Master (赞：4)

## 前言

致敬传奇入门组有紫。

## 正言

首先，要求浇水次数最多的树，每隔志愿者会给第 $a_i \sim b_i$ 棵树之间贡献一次浇水次数。

那么很容易发现，这就是一个区间加，并且没有修改操作，那么这就是一个板子的差分。

但是，我们要注意，$a_i,b_i$ 可以为 $0$ 啊。而差分数组转回正常数组是要用到前缀和，这里会越界。

那我们怎么办呢？

这里给出一种解决方法，那就是将操作的左右端点加 $1$，让操作从 $1$ 开始，这样就不会越界了，同时，要注意最后求答案的时候要到 $10^6+1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
int n,a[N],b[N],maxv;
void insert(int l,int r,int c){
    b[l]+=c;
    b[r+1]-=c;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        int l,r;
        cin>>l>>r;
        insert(l+1,r+1,1);
    }
    for(int i=1;i<=1000001;i++){
        b[i]+=b[i-1];
        maxv=max(maxv,b[i]);
    }
    cout<<maxv<<endl;
    return 0;
}
``````

---

## 作者：tomAmy (赞：3)

本题难点在于区间修改，考虑差分解决。

令 $d_i$ 表示 $a_i - a_{i - 1}$。

区间修改时，$a_x \sim a_y$ 都增加一，则使得 $d_x$ 增加一，$d_{y + 1}$ 减少一。（可以自己模拟一下）

操作后，仍有 $d_i = a_i - a_{i - 1}$，则可以通过 $a_{i - 1} + d_i$ 求出 $a_i$。

代码：

```cpp
#include <iostream>
using namespace std;

int d[1000005];

int main()
{
	int n;
	cin >> n;
	// 差分板子
	for (int i = 1; i <= n; i++)
	{
		int a, b;
		cin >> a >> b;
		d[a]++, d[b + 1]--;
	}
	int ans = 0;
	for (int i = 0; i <= 1e6; i++)
	{
		d[i] += d[i - 1];
		ans = max(ans, d[i]);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：2)

# P11853 [CSP-J2022 山东] 植树节
简单差分。我们每次将树苗看成一大段区间，每次将区间头加一，区间尾后一个数减一，然后做一个前缀和，得到原数组，取最值即可。
## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int n, l, r;
int s[N];

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> l >> r;
        s[l]++, s[r + 1]--;
    }

    int res = 0;
    
    for (int i = 0; i <= 1e6; i++) {
        if (i != 0) s[i] += s[i - 1];
        res = max(res, s[i]);
    }

    cout << res << '\n';
    
    return 0;
}
```

---

## 作者：guer_loser_lcz (赞：1)

# 题解
## 思路
对于神犇，应该使用：珂朵莉树，线段树等。

对于像我一样的蒟蒻，应该使用：差分。

前置芝士：前缀和。

差分的操作非常简单，对区间 $l$ 至 $r$ 中的所有元素加一，用差分可以表示为 $a_l + 1 , a_{r+1} - 1$。最后要对差分数组进行前缀和操作，最大的则是答案。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000100],b[1000100],n,x,y,ans,mx;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		x++,y++;
		a[x]++,a[y+1]--;//差分
		mx=max(mx,y);//最远浇水位置
	}
	b[0]=a[0];//零也会被浇
	for(int i=1;i<=mx;i++){
		b[i]+=b[i-1]+a[i];
		ans=max(ans,b[i]);//求答案
	}
	cout<<ans;
	return 0;
}
```

---


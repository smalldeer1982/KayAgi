# 语文成绩

## 题目背景

语文考试结束了，成绩还是一如既往地有问题。


## 题目描述

语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？


## 说明/提示

对于 $40\%$ 的数据，有 $n \le 10^3$。

对于 $60\%$ 的数据，有 $n \le 10^4$。

对于 $80\%$ 的数据，有 $n \le 10^5$。

对于 $100\%$ 的数据，有 $n \le 5\times 10^6$，$p \le n$，学生初始成绩 $ \le 100$，$z \le 100$。

## 样例 #1

### 输入

```
3 2
1 1 1
1 2 1
2 3 1```

### 输出

```
2
```

# 题解

## 作者：GoldenFishX (赞：202)

蒟蒻题解，有什么问题请大佬指出

### 思路
这题明显就是差分

根据差分数组的定义：``` d[i]=a[i]-a[i-1]```，可以发现，在```d[x]```上加上```z```,会让后面的学生全部加上z。↓

![](https://cdn.luogu.com.cn/upload/image_hosting/2prm1f96.png)

但这是把后面全部都加了，还要减掉一节，所以↓

![](https://cdn.luogu.com.cn/upload/image_hosting/vpzmrk8l.png)

把两个综合起来就是↓

![](https://cdn.luogu.com.cn/upload/image_hosting/45xhj19v.png)

所以每一次变化只要把```d[x]+z,d[y+1]-z```就好了。

因为``` d[i]=a[i]-a[i-1]```

所以``` a[i-1]+d[i]=a[i]```

最后再根据``` a[i-1]+d[i]=a[i]```输出每一个同学的分数

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int d[5000001];//d[i]表示a[i]-a[i-1] 
int a[5000001];
int main()
{
	int n,p,x,y,z,i,min=1e9;
	cin>>n>>p;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	
    for(i=1;i<=n;i++)
	{
		d[i]=a[i]-a[i-1];
	}
	for(i=0;i<p;i++)
	{
		cin>>x>>y>>z;
		d[x]+=z;
		d[y+1]-=z;
	}
	
	for(i=1;i<=n;i++)
	{
		a[i]=a[i-1]+d[i];
		if(min>a[i])
		{
			min=a[i];
		}
	}
	cout<<min;
	return 0;
} 
```


---

## 作者：StudyingFather (赞：34)

区间修改？乍一看似乎要用线段树才能解决。不过读完题目，就会发现只需要在最后求出最小值，并不需要线段树这样的在线算法。

于是自然而然想到差分了（本蒟蒻也不会写线段树那么复杂的代码），这样只需要 $O(n)$ 的时间复杂度就可以解决这道题了。

PS：其实今天早上春令营上课就讲了差分，所以这道题算是学以致用了吧。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[5000005],diff[5000005],n,p,mina;
int main()
{
 scanf("%d%d",&n,&p);
 for(int i=1;i<=n;i++)
 {
  scanf("%d",&a[i]);
  diff[i]=a[i]-a[i-1];
 }
 for(int i=1;i<=p;i++)
 {
  int x,y,z;
  scanf("%d%d%d",&x,&y,&z);
  diff[x]+=z;
  diff[y+1]-=z;
 }
 mina=diff[1];
 for(int i=1;i<=n;i++)
 {
  a[i]=a[i-1]+diff[i];
  mina=min(a[i],mina);
 }
 printf("%d",mina);
 return 0;
}
```

---

## 作者：学委 (赞：30)

这道题的输入规模非常大，老师肯定累垮了。

可以普及一下 fread。我之前没学，觉得它一定很复杂，其实它非常单纯。

## 普通快读

有这样的方法，用它读入整数比 scanf 快，帮你省下时间。

读入一个字符，如果是不是数字就继续读入。

读到一个数字？开始处理：

```cpp
while(isdigit(ch))//判断是不是数字字符，此函数在头文件<cctype>中
	result = result * 10 + (ch - '0'), ch = getchar();
```

比如读入数字 408，分成几个字符读入：

  * 发现读入 4，记录 4(变量 result)，读下一个字符。

  * 发现读入 0，先把之前的记录乘以 10，然后加上 0。现在记录了 40，读下一个字符。

  * 发现读入 8，先把之前的记录乘以 10，然后加上 8。现在记录了 408，读下一个字符。

  * 发现读到空格、换行符（标准的数字间隔符）或者 EOF（读不到东西），就可以返回结果：408。
  
*小提示：数字字符要转变为数字，即减去字符 '0'（ASCII码是 48）。*
  
  
```cpp
int getint()//名字仿照了getchar()
{
    int res = 0;
    char ch = getchar();
    while(!isdigit(ch))
        ch = getchar();
    while(isdigit(ch))
        res = res * 10 + (ch - '0'), ch = getchar();
    return res;
}
```

## 用 fread 优化

*只是优化了上面的 getchar()，因为 getchar() 有点慢。*

* fread 的用处是**快速地读入一大堆字符进来，便于你利用这些字符**。你肯定知道这个：

  ```cpp
  scanf("%s", a+1);//为了首个字符的下标是1（便于理解），所以读进a+1
  //scanf遇到空格、换行符就结束了
  ```

  那么你能理解：

  ```cpp
  fread(tmp+1, 1, 1000000, stdin);
  ```

  迅速读入 1000000 个字符到 tmp 数组。**如果没有 1000000 个也不会出错。**其中第二个参数是 1：因为 fread 是一块块地读入数据的，这里每块大小定为 1 字节。

* 一次 fread() 以后，你的 getchar() 可以换成：

  ```cpp
  char getch(){
      return tmp[++cnt];
  }
  ```

**只要在原来的快读里面把 getchar() 替换成 getch()，就快了许多了！**

fread 讲完了。

## 细节

* 为了保证 fread 能读入多于 1000000 个字符，**同时 tmp 数组占用的空间也不能太大**，我们可以这样修改 getch() ：

  ```cpp
  char tmp[1000010];
  int cnt = 0, Max = 0;//两个初值都是0，使第一次getch()一定会调用fread()
  char getch()
  {
      ++cnt;
      if(cnt > Max)
      {
          cnt = 1;
          Max = fread(tmp+1, 1, 1000000, stdin);
      }
      return tmp[cnt];
  }
  ```
  
  fread() 会返回成功读入的个数，用 Max 记录本次读入了几个（这里限制一次最多 1000000 个），如果 cnt 大于 Max 了，就自动再次 fread() 1000000 个字符。
    
更多细节，如 getint() 判断负数、fread() 指针写法以及快速输出 fwrite()，感兴趣可看看[快读有多难？](https://cicos.blog.luogu.org/grammar-readAndWrite)
    
## 原题

先不看题目。

有一个概念叫做前缀和。现在有一个数组 t，里面都是 0。然后，我们用 sum[i] 表示 t 数组前 i 位的和。

* 如果 t[4] 加上 2，sum 数组要发生什么变化?

	**sum[4] ~ sum[n] 每一位都要加 2。sum[1] ~ sum[3] 不变。** 

* 如果在 t[9] 减去 2，sum 数组发生什么变化?
	
	**sum[9] ~ sum[n] 每一位都要减 2。**
  
* 依次进行上面两步操作以后，sum 数组要发生什么变化?

	**只有 sum[4] ~ sum[8] 增加 2，其余不变。**
    
如果 t[l] 增加 x，t[r+1] 减去 x，那么 sum[l] ~ sum[r] 都增加 x。
___

大量的区间加，最后询问所有数中的最小值。

我们可以开一个 t 数组，若修改学生 x ~ y 都加 z，就只在 t 数组上进行两个操作：t[x] 加上 z，t[y+1] 减去 z。你可以脑补出**此时有一个 sum 数组，是 t 的前缀和，sum[i] 能正确表示第 i 个学生被修改了多少。**但是不要每次修改 sum 数组，而是修改以 t 数组代替。

最后从左到右求一次 t 的前缀和，还原出 sum 数组，加到第 i  位时的 sum 就能表示出这个学生被修改的量。别忘了加上初始成绩，取最小。 

t 叫做 sum 的差分数组。t 的前缀和就是 sum。

```cpp
#include <cstdio>
#include <cctype>
char tmp[1000010];
int cnt = 0, Max = 0;
char getch()
{
    ++cnt;
    if(cnt > Max)
    {
        cnt = 1;
        Max = fread(tmp+1, 1, 1000000, stdin);
    }
    return tmp[cnt];
}
int getint()
{
    int res = 0;
    char ch = getch();
    while(!isdigit(ch))
        ch = getch();
    while(isdigit(ch))
        res = res * 10 + (ch - '0'), ch = getch();
    return res;
}

int n, p;
int a[5000010], b[5000010];
int main()
{
    n = getint(), p = getint();
    for(int i = 1; i <= n; i++)
        a[i] = getint();
    for(int i = 1; i <= p; i++)
    {
        int x = getint(), y = getint(), z = getint();
        b[x] += z;
        b[y+1] -= z;
    }
    
    int sum = 0, ans = 1000000000;
    for(int i = 1; i <= n; i++)
    {
        sum += b[i];
        if(a[i] + sum < ans)
            ans = a[i] + sum;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：_WMD (赞：22)

这道题其实并不用线段树，用差分序列可以更快的解决，也不需要担心爆空间。下面上代码。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q,d[5000005]={0},a,minn,x,y,z;
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",&d[i]);
	for(int i=n;i>1;i--)d[i]-=d[i-1];
	while(q--)
	{
		scanf("%d%d%d",&x,&y,&z);
		d[x]+=z;d[y+1]-=z;
	}
	minn=d[1];
	for(int i=2;i<=n;i++)
	{
		d[i]+=d[i-1];if(d[i]<minn)minn=d[i];
	}
	cout<<minn;
	return 0;
}
```  

---

## 作者：AmamiyaYuuko (赞：19)

题解里没有分块？这怎么能行。

一道**分块**的裸题。

由于数据比较大，吸了氧。

最慢的数据点 471ms。使用 [OI Wiki](https://oi-wiki.org/misc/io/) 上的 `fread` 和 `fwrite` 优化后可以到 454ms。

为什么要用分块呢？因为我喜欢。

如果你还不会分块，那我就将大概思路讲一下。

分块，顾名思义，将整个序列分成若干个块。我们要先预处理每个点在哪一个块内。对于不在整块中的点，进行暴力修改。对于在整块中的点，直接对块进行修改。最后每个元素的值即为在原序列上这个元素进行暴力修改最后得到的值加上它所在整块修改的值。一般来说，块的长度都为 $\sqrt n$，$n$ 为序列长度。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cctype>

#define reg register

template <class T>
inline void read(T &x)
{
    x = 0;
    int f = 0;
    char ch = getchar();
    while (!isdigit(ch))    { f |= ch == '-'; ch = getchar(); }
    while (isdigit(ch))     { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    x = f ? -x : x;
    return;
}

int a[5000010], add[2510], pos[5000010];
int n, p, len, ans = 0x3f3f3f3f;

void update(int l, int r, int c)
{
    for (reg int i = l; i <= std::min(pos[l] * len, r); ++i)
        a[i] += c;
    if (pos[l] != pos[r])
        for (reg int i = (pos[r] - 1) * len + 1; i <= r; ++i)
            a[i] += c;
    for (reg int i = pos[l] + 1; i <= pos[r] - 1; ++i)
        add[i] += c;
}

int main()
{
    read(n), read(p);
    for (reg int i = 1; i <= n; ++i)
        read(a[i]);
    len = sqrt(n);
    for (reg int i = 1; i <= n; ++i)
        pos[i] = (i - 1) / len + 1;
    for (reg int i = 1; i <= p; ++i)
    {
        int x, y, z;
        read(x), read(y), read(z);
        update(x, y, z);
    }
    for (reg int i = 1; i <= n; ++i)
        ans = std::min(ans, a[i] + add[pos[i]]);
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：pengym (赞：14)

##.
这道题一开始看到区间累和的第一反应就是用**线段树**，但是仔细读题之后会惊讶的发现，它什么操作都没有，仅仅只有区间累和。。我们需要的也只是那个**lazy操作**罢了。当时就有放弃的欲望，但看到题解里没人打线段树，于是我就走上这条~~不归路~~。当自信的打完后，惊奇的发现会MLE。于是，我便想了各种操作，最终被我用一个~~特愚蠢的骚操作~~水过去了。

##.
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<map>
#include<queue>
#define N 5000010
#define Mid ((l+r)>>1)
#define lson rt<<1,l,Mid
#define rson rt<<1|1,Mid+1,r
using namespace std;
inline void read(int &x)
{
    x=0;
    int p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;
}
int n,p;
int a[N];
int lazy[N<<2];
int minn=0x7f7f7f7f;
void pushdown(int rt,int len)
{
    if(lazy[rt]!=0)
    {
        lazy[rt<<1]+=lazy[rt];
        lazy[rt<<1|1]+=lazy[rt];
        lazy[rt]=0;
    }
}
void build(int rt,int l,int r)
{
    if(l==r)
    {
        int x;read(x);
        a[l]=x;//秀操作的神奇方法，一般是a[rt]，但考虑到本题和a没任何关系，于是根本不需要开4倍空间
        return;
    }
    else
    {
        build(lson);
        build(rson);
    }
}
void update(int rt,int l,int r,int L,int R,int val)
{
    if(L<=l&&r<=R)
    {
        lazy[rt]+=val;
        return;
    }
    else
    {
        pushdown(rt,r-l+1);
        if(L<=Mid)update(lson,L,R,val);
        if(R>Mid)update(rson,L,R,val);
    }
}
void query(int rt,int l,int r)
{
    if(l==r)
    {
        a[l]+=lazy[rt];
        minn=min(minn,a[l]);
        return ;
    }
    else
    {
        pushdown(rt,r-l+1);
        query(lson);
        query(rson);
    }
}
int main()
{
    read(n);read(p);
    build(1,1,n);
    for(int i=1;i<=p;i++)
    {
        int x,y,z;
        read(x);read(y);read(z);
        update(1,1,n,x,y,z);
    }
    query(1,1,n);
    printf("%d\n",minn);
    return 0;
}
```

---

## 作者：TPR123456 (赞：6)

~~前情提要 这篇题解是面对从未接触过差分的人写的 嫌啰嗦的直接看楼上或者楼下哈~~

调差分调了一个半小时码力极弱的OIer来水一发题解......

[来自OI-Wiki的差分介绍](https://oi-wiki.org/basic/prefix-sum/#_8)

差分基本思想：令b[i]=a[i]-a[i-1]

b[i]的含义为a[i]与a[i-1]的差值

这个东西易于在O(1)内维护区间内所有的数加减乘除一个值

实例：将a数组中[l,r]区间内的数字全部加k

设b数组存储差分信息，则易得 将b[l]加上k，然后再将b[r+1]减去k即为想要的结果

Q&A

Q1:为什么是b[l]?

A1:a[l]加k，则a[l]与a[l-1]的差增加k

Q2:那为什么是b[r+1]?

A2:a[r]加k，则a[r]与a[r+1]的差减小k。注意！此时操作的应该是b[r+1]而不是b[r]。

Q3:为什么b[l+1,r]不用更改？

A3:一起增加k，他们之间的差值不变

~~我是不会告诉你们我调Q2调了半个小时~~

并且比线段树简单 ~~线段树是这么用的吧我还没学我唔知啊~~

最后输出只要从头到尾做一遍前缀和就可以了

最后是你们最喜欢的代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#define N 5000005
using namespace std;
int a[N],b[N];
inline int minx(int a,int b){return a<b?a:b;}
inline int read() //读入优化
{
	int x=0,k=1;char c=getchar();
	while (c<'0'||c>'9'){if (c=='-') k=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*k;
}
int main()
{
	int n,m,test=0,minn=0x7f7f7f7f;
	n=read();m=read();
	for (int i=1;i<=n;i++) a[i]=read(),b[i]=a[i]-a[i-1];
	for (int i=1,x,y,z;i<=m;i++)
	{//此处为差分操作
		x=read();y=read();z=read();
		b[x]+=z;b[y+1]-=z;
	}
	for (int i=1;i<=n;i++) minn=minx(minn,test+b[i]),test+=b[i];
  //前缀和找最小值
	cout<<minn;
	return 0;
}
```


---

## 作者：xiaohuang (赞：5)

[更好的阅读体验](https://xiaohuang888.github.io/2019/12/11/%E3%80%8CLuogu%202367%E3%80%8D%E8%AF%AD%E6%96%87%E6%88%90%E7%BB%A9/)

### Solution

这题介绍一种$O(n)$的算法。

可以用差分数组来做，在修改的时候，第一个数加$x$，第$n+1$个数减$x$，类似于一个懒标记，查询的时候累加一下，再加上本身就是这个数的最终值。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

const int INF = 0x3f3f3f3f, MAXN = 5000005;
int n, q, l, r, val, a[MAXN], diff[MAXN];
int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= q; i++) {
        scanf("%d%d%d", &l, &r, &val);
        diff[l] += val; diff[r + 1] -= val;//差分数组
    }
    int Min = INF, tmp = 0;
    for (int i = 1; i <= n; i++) {
        tmp += diff[i];//查询这一个位置的修改值
        if (a[i] + tmp < Min) Min = a[i] + tmp;
    }
    printf("%d\n", Min);
    return 0;
}
```

---

## 作者：流逝丶 (赞：5)

这题，第一眼：区间加，区间最小值。这不是线段树裸题吗？

看数据范围 $n\le5000000$.开了个tr维护最小值，laz维护加

然后一算空间大概是$152$MB，完了,$MLE$。

换方法吧，但是我就想写线段树，就是写线段树才能使我快乐，我就改变策略

本来直接输出$tr[1]$，我现在删掉$laz$，让$tr$维护加，访问的时候就访问每个叶子

结点，并且一路下放，原来的值用一个n大小的数组维护，叶子结点的值就是

$tr[k]+a[l]$ 这不就解决空间问题了么,然后只写个$change$，$down$和$ask$不就完了

代码，最慢的也才$424ms$

```cpp
#include<iostream>
#include<cstdio>
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
using namespace std;
const int maxn=5000005;
int n,m,a[maxn];
int tr[maxn<<2];
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
inline void down(int k){
	tr[ls]+=tr[k];tr[rs]+=tr[k];
}
void change(int k,int l,int r,int x,int y,int val){
	if(l==x&&y==r){
		tr[k]+=val;
		return ;
	}
	if(y<=mid)change(lson,x,y,val);
	else if(x>mid)change(rson,x,y,val);
	else change(lson,x,mid,val),change(rson,mid+1,y,val);
}
int ask(int k,int l,int r){
	if(l==r){
		return a[l]+tr[k]; 
	}
	if(tr[k])down(k);
	return min(ask(lson),ask(rson));
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	int x,y,z;
	while(m--){
		x=read();y=read();z=read();
		change(1,1,n,x,y,z);
	}
	printf("%d",ask(1,1,n));
	return 0;
}
```


---

## 作者：TsReaper (赞：5)

典型的差分题。

记i号学生得分为a[i]，令b[i] = a[i] - a[i-1]，那么b[1]+b[2]+...+b[i] = a[i]。

老师给i号学生到j号学生全部加上x分，就相当于b[i] += x, b[j+1] -= x

最后求所有学生的最低分，那么只要一边对b[i]求和，一边求求和过程中的最小值即可。


另外本题数据比较大，时间比较紧，要写快速读入才能过。


---

## 作者：PTC06 (赞：3)

经典的树状数组。

树状数组一般是用于查询两位之间所有元素的和，但是这时只能修改一个点。改一改可以进行范围修改，但只能查询一个点。

这道题符合第二种情况。

这题可以简化为将区间[x,y]里的每个点加z，最后找出整个数组中值最小的一个点。

不会用树状数组的可以参考P3368 【模板】树状数组 2，和这题很像。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,x,y,ans,tree[5000000],m,pre,a,k;
int lowbit(int x)
{
    return x&-x;
}
void add(int x,int addnum)
{
    while (x<=n)       //修改
    {
        tree[x]+=addnum;
        x+=lowbit(x);
    }
}
int query(int x)
{
    int sum=0;           //查询
    while (x)
    {
        sum+=tree[x];
        x-=lowbit(x);
    }
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a);
        add(i,a-pre);
        pre=a;
    }
    for (i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&k);
        add(x,k);
        add(y+1,-k);
    }
    ans=query(1);            
    for (i=2;i<=n;i++)
    {
        if (query(i)<ans) ans=query(i);
    }
    printf("%d",ans);
}
```

---

## 作者：囧人232 (赞：3)

这道题可以用线段树/差分/树状数组搞一下；

又因为题目中只要求找出被修改后的最小值，所以我用的是差分（线段树太长不想写）；

差分百度上找不到太多资料

大概思想

就是设一个数组记录下a【i】相对于a【i-1】的变化；

最后查询a【i】的时候就是把s【0】+。。。+s【i】；

这样时间复杂度和空间复杂度都会比线段树优；//noip的借教室也可以用差分搞，常数大的线段树会被卡

（而且还比线段树好写）

其实你根本不需要记录a【i】数组，因为差分要用的只是a【i】和a【i-1】的差值

我加拉一个小小的优化，详细见代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
```
}//快读
```cpp
int n,m,k;
int g[5000000+10];//g数组就是记录a【i】值对于前一位的变化值（默认a【0】，g【1】=a【1]】）
int main()
{
     n=read();k=read();
     g[0]=0;m=0;
     for(int i=1;i<=n;i++){
      g[i]-=m;//在这个地方m是a【i-1】的值
      m=read();
      g[i]+=m;//在这个地方m是a【i】的值
```
}//这样我们就省去了a【i】数组
for(int i=1;i<=k;i++){/\*修改，x-》y加上z（z可为负数）因为我们是通过前缀和来求a【i】的值，所以可以将g【x】+z，g【y+1】-z（x，y区间内的变化量是不变的，变得只是两个端点），最后前缀和求出的就是修改后的值；\*/

```cpp
     int x,y,z;，
     x=read();
     y=read();
     z=read();
     g[x]+=z;
     g[y+1]-=z;
     }
     int sum=1000086,ans=0;
     for(int i=1;i<=n;i++)
     { 
        ans+=g[i];//枚举修改后的每一个a【i】；
        sum=min(ans,sum);
     }
     printf("%d",sum);
     return 0;
}
```
这道题可以搞搞线段树，如果你想练一下差分，可以学习一下noip2012的借教室，内道题多种解法（常数大的线段数会被卡）=v=
最后最后这是本蒟蒻的第四篇题解，希望对泥萌有帮助qwq


---

## 作者：NP003 (赞：1)

这道题，就是楼下的方法，貌似叫前缀数组。

```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<queue>
#include<stack>
#include<set>
#include<vector>
#include<map>
using namespace std;
#define fr(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)
#define fd(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)
#define ln putchar('\n')
#define mem(x,y) memset(x,y,sizeof(x));
#define gc getchar()
#define u unsigned
#define inf 0x3f3f3f3f
#define ct continue
#define rt return
#define llf double
#define lld long long
#define frei(s) freopen(s,"r",stdin);
#define freo(s) freopen(s,"w",stdout);
#define _FILE_ ""
void OPENFILE(){
.    if(strlen(_FILE_)==0)rt;
.    char FILENAME[50];
.    sprintf(FILENAME,"%s.in",_FILE_);
.    frei(FILENAME);
.    sprintf(FILENAME,"%s.out",_FILE_);
.    freo(FILENAME);
}//无视
lld n,m,x,y,z,f[5000010],ans,d,k[5000010];
int main(){
.    OPENFILE();
.    scanf("%lld%lld",&n,&m);
.    fr(i,1,n)
.        scanf("%lld",&k[i]);
.    while(m--){
.        scanf("%lld%lld%lld",&x,&y,&z);
.        f[x]+=z;
.        f[y+1]-=z;//就是程序的精华
.    }
.    ans=inf;//设初值
.    fr(i,1,n){
.        d+=f[i];//看目前增加（减少的）数值
.        ans=min(ans,d+k[i]);
.    }
.    printf("%lld\n",ans);
.    rt 0;
}
```

---


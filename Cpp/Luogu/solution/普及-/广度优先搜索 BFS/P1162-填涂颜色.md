# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# 题解

## 作者：LMB_001 (赞：1263)

楼下dalao们的都看不懂，只好自己写了一个搜索的啦，用染色法，其实可以先练习拯救总部那道

c++：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[32][32],b[32][32];
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//第一个表示不动，是充数的，后面的四个分别是上下左右四个方向
int n,i,j;
void dfs(int p,int q){
    int i;
    if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;//如果搜过头或者已经被搜过了或者本来就是墙的就往回
    a[p][q]=1;//染色
    for (i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);//向四个方向搜索
}
int main(){
    cin>>n;
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++){
            cin>>b[i][j];//其实不拿两个数组也可以，不过我喜欢啦
            if (b[i][j]==0) a[i][j]=0;
            else a[i][j]=2;
        }
    dfs(0,0);//搜索 从0，0开始搜
    for (i=1;i<=n;i++){
        for (j=1;j<=n;j++)
        if (a[i][j]==0) cout<<2<<' ';//如果染过色以后i，j那个地方还是0，说明没有搜到，就是周围有墙，当然就是被围住了，然后输出2
        else cout<<b[i][j]<<' ';//因为被染色了，本来没有被围住的水和墙都染成了1，所以就输出b[i][j]
        cout<<'\n';//换行
    }
}
```

---

## 作者：冰冻赤道 (赞：277)

看到dalao们的题解，蒟蒻深感无力。所以，自己写了一个BFS，供大家借鉴；


首先，分析题目，这是要将闭合的“1”里面的“0”改写成“2”，然后输出。由此，我们猛然发觉，只要‘0’的联通块中，没有在边界的

就是闭合的‘0’；（发现这个，就等于做对了一半；）

因为，从正面推，找闭合中的‘0’不好找。所以，蒟蒻想到，运用BFS或者DFS直接搜索边界中‘0’，所在的联通块，然后标记。

最后输出时，去除‘1’点和标记了的点，剩下的输出为‘2’，就是正解啦！！！


**下面是代码解释：**

    


    
        
        
    
    
    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int M = 31;            //最大边界是30，我习惯从1，开始存图； 
int map[M][M];                //用于存图； 
bool vis[M][M];                //用于记录是否是边界联通块，或者是‘1’； 
int n,m,a,b,c;                
queue <int > q;                
void bfs(int x, int y)            //蒟蒻今天用的是BFS； 
{
    vis[x][y] = 1 ;            //把初始点标记，初始点一定为边界，不懂得看主函数； 
    q.push(x);                //队列存点； 
    q.push(y);
    while(!q.empty())            //BFS开始 
    {
        int w = q.front();
        q.pop();
        int e = q.front();
        q.pop();
        if(map[w+1][e] == 0 && w != n && !vis[w+1][e] )    vis[w+1][e] = 1,q.push(w+1),q.push(e);        //其实可以用结构体存四个方向，但蒟蒻不想动脑子； 
        if(map[w-1][e] == 0 && w != 1 && !vis[w-1][e] )    vis[w-1][e] = 1,q.push(w-1),q.push(e);
        if(map[w][e+1] == 0 && e != n && !vis[w][e+1] )    vis[w][e+1] = 1,q.push(w),q.push(e+1);
        if(map[w][e-1] == 0 && e != 1 && !vis[w][e-1] )    vis[w][e-1] = 1,q.push(w),q.push(e-1);
    }
}
int main()
{
    cin>>n;
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= n ; j++)
        {
            cin>>map[i][j];                            //输入点，并把为‘1’的点标记； 
            if(map[i][j] == 1)    vis[i][j] = 1;    
        }
    }
                                //下面两个for是枚举边界，我用的方法比较笨，望dalao海涵； 
    for(int i = 1 ; i <= n ; i = i + n - 1 )        
    {                                                //
        for(int j = 1 ; j <= n ; j++)
        {
            if(vis[i][j])    continue;
            bfs(i,j);
        }
    }
    for(int i = 1 ; i <= n ; i = i + n - 1 )        //
    {
        for(int j = 1 ; j <= n ; j++)
        {
            if(vis[j][i])    continue;
            bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界； 
        }
    }
    for(int i = 1 ; i <= n ; i++)                //
    {
        for(int j = 1 ; j <= n ; j++ )
        {
            if(!vis[i][j])    cout<<"2"<<" ";        //如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； 
            else     cout<<map[i][j]<<" ";;
        }
        cout<<endl;
    } 
    return 0;
}

```

---

## 作者：zhy137036 (赞：180)

~~我膨胀了，已经敢给有70篇题解的题写题解~~

这篇题解会研究两种搜索与两种数据结构的关系，以及函数调用的方式等问题。
# 前言
[这个帖子](https://www.luogu.org/discuss/show/61579)里说“可以在题解里阐述比其他题解更优的理由，让管理认可你的题解。”所以我说一下。

本解法已经有题解说了，但是我简单的翻了一下，没有深入研究两种搜索与数据结构的关系以及函数调用与栈的关系的题解。我知道，审核题解的管理员（如cz）能力很强，可能会认为我讲的很简单，大家都会。可是这道题本身就是给新手做的，我希望新手看完本篇题解能对搜索有更深入的理解，所以我发在了这道题。
# 分析题目
这道题不难，正常输入，在外面围一圈0，再从周围搜索就行了，画成图大概是这个样子：

![](https://cdn.luogu.com.cn/upload/pic/72820.png)

给出代码。

```cpp
#include<iostream>
using namespace std;
int n,a[35][35];//全局变量自动初始化为0
int main()
{
	ios::snyc_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	search(0,0);//从边界开始搜索
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<2-a[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```
# 从BFS说起
我们都知道，bfs是用队列实现的，而dfs是用递归实现的，这看着就不舒服了：凭什么一个是用数据结构，一个是用递归？dfs就不能用数据结构实现吗？
偶然的，我在百度百科（[这篇](https://baike.baidu.com/item/goto语句/7603004?fr=aladdin)）上发现了这么一句话: **任何程序都可以用顺序、分支和重复(循环)结构表示出来。** 那么，不用递归也一定能实现dfs。那需要用数据结构吗？需要的话用哪个呢？想一想，和队列对应的数据结构是什么？很容易想到，是**栈**。接下来，我们就要想办法用栈实现dfs。
## 补充知识：BFS
这部分是给不会bfs的萌新看的，会bfs的可以跳过。

bfs的基本思路是：
1. 把根节点放进队列里
2. 取出一个节点，进行处理
3. 将此节点的子节点放入队列（没有子节点就不放）
4. 判断队列是否为空。如果非空，返回第2步；如果为空，结束。

代码：
```cpp
#include<queue>
#include<utility>
queue<pair<int,int> >que;
void search(int x, int y)
{
	int dx[5] = { 0,-1,0,1,0 }, dy[5] = { 0,0,1,0,-1 };
	que.push(pair<int, int>(x, y));
	while (!que.empty())
	{
		pair<int, int>t = que.front();
		que.pop();
		a[t.first][t.second] = 2;
		for (int i = 1; i <= 4; i++)
		{
			if (t.first + dx[i] >= 0 && t.first + dx[i] <= n+1)
			if (t.second + dy[i] >= 0 && t.second + dy[i] <= n+1)
			if (a[t.first + dx[i]][t.second + dy[i]] == 0)
			que.push(pair<int, int>(t.first + dx[i], t.second + dy[i]));
		}
	}
}
```
## 进入正题：栈实现DFS
有了bfs的基础，我们也很容易发现，用同样的方法，只是把队列换成栈，就能实现dfs。理解不了的可以看下图

![](https://cdn.luogu.com.cn/upload/pic/73037.png)

这是在搜索$3\times3$的方格。可以看到，用栈实现的dfs和用递归实现的dfs搜索顺序完全一样。

总结一下：
1. 把根节点放进栈里
2. 取出一个节点，进行处理
3. 将此节点的子节点放入栈（没有子节点就不放）
4. 判断栈是否为空。如果非空，返回第2步；如果为空，结束。

代码：
```cpp
#include<stack>
#include<utility>
stack<pair<int,int> >sta;
void search(int x, int y)
{
	int dx[5] = { 0,-1,0,1,0 }, dy[5] = { 0,0,1,0,-1 };
	sta.push(pair<int, int>(x, y));
	while (!sta.empty())
	{
		pair<int, int>t = sta.top();
		sta.pop();
		a[t.first][t.second] = 2;
		for (int i = 1; i <= 4; i++)
		{
			if (t.first + dx[i] >= 0 && t.first + dx[i] <= n+1)
			if (t.second + dy[i] >= 0 && t.second + dy[i] <= n+1)
			if (a[t.first + dx[i]][t.second + dy[i]] == 0)
			sta.push(pair<int, int>(t.first + dx[i], t.second + dy[i]));
		}
	}
}
```
可以看出，这和上面bfs的代码几乎完全一样。
# 函数调用与栈
如果我说，dfs只能用栈实现，你会怎么想？你可能会说，递归也能实现dfs。实际上，函数调用本身就是靠一个叫**调用栈**的栈实现的。首先，在栈里放入main函数，执行它，当main函数调用其他函数时，就会把该函数的信息压入栈中，开始执行新的函数。当一个函数执行完之后，该函数就会被弹出，继续执行调用它的函数。栈中的每一个函数都叫**栈帧**，不仅保存着函数的地址，还保存着函数里所有局部变量。调用栈很小，所以我们才说大的数组要保存成全局变量，否则会**爆栈**，意思就是说栈里存不下。递归层数过多也会导致爆栈。

不过，调用栈和我们写的栈有一点不同：我们写的栈是弹出后将它的子节点压入栈中，而调用栈则是压入一个子节点就继续搜索，该子节点弹出后再把它的下一个子节点压入，直到该节点所有子节点都被搜索过了之后，才会把这个节点弹出。这样写起来要麻烦一些，不过对于函数调用，这是最简单的方法。

---

## 作者：LevenKoko (赞：180)

//为什么都是BFS，难道DFS不够简洁吗。。。（可能是因为我不会BFS吧）

//言归正传，这种题第一眼应该就可以看出求联通快，于是。。。

//从边界为起点，把所有0搞成1，然后……好像除了输出就没然后了

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100][100],b[100][100]={0};
int n,x,y;

void dfs(int x,int y)
{
    if(x>n||x<1||y>n||y<1||a[x][y]!=0)//判断是否越界 
        return;
    a[x][y]=1;
    dfs(x+1,y);
    dfs(x-1,y);
    dfs(x,y+1);
    dfs(x,y-1);//四个方向 
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
            if(a[i][j]==1) b[i][j]=-1;//b用来存原来的位置 
        }
    int flag=0;
    for(int i=1;i<=n;i++)
    {
    if(a[i][1]!=1) dfs(i,1);
    if(a[i][n]!=1) dfs(i,n);//搜第i行的第一列和第n列 
    }
    for(int i=1;i<=n;i++)
    {
    if(a[1][i]!=1) dfs(1,i);
    if(a[n][i]!=1) dfs(n,i);//搜第i列的第一行和第n行 
    } 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(b[i][j]==-1) printf("1 ");
            else
            if(a[i][j]==0) printf("2 ");
            else printf("0 ");
        }
        printf("\n");
    }//输出，如果这个看不懂的话建议刷P1000(大牛分站的！); 
    return 0;
}
//代码如下： 

```

---

## 作者：Rec° (赞：151)

看了下前几页的题解没找到太像的 所以还是勇敢的传一下试试  
~~不想莫名不被通过~~
# 思路：
### 因为只有零和一 且 零分为两种 所以我们不妨先把它手动分成三个数（~~问题就是要做这件事~~） 圈里的并不算好找 看dalao们的题解可能初学dfs的~~蒟蒻~~我也不是很理解 于是就~~百度到~~想到我们只需要把圈外零的用dfs先变成其他的数 最后全盘扫一遍 把没被改变的零（即圈内零）变成需要的数（2） 同时要是检测到圈外数（刚刚dfs更改的）把它变回0就OK啦！！！
# 代码：


------------

```cpp
#include <cstdio>
using namespace std;
int n;
int a[32][32];
void dfs(int x, int y){
	if(x >= 0 && x <= n + 1 && y >= 0 && y <= n + 1){
		if(a[x][y] == 1 || a[x][y] == 3) return ;
		else{a[x][y] = 3;
			dfs(x + 1, y); dfs(x - 1, y);
			dfs(x, y + 1); dfs(x, y - 1);}
	}
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	for(int j = 1; j <= n; ++ j)
	scanf("%d", &a[i][j]);
	dfs(0, 0);
	for(int i = 1; i <= n; ++ i)
	for(int j = 1; j <= n; ++ j)
	if(a[i][j] == 3) a[i][j] = 0;
	else if(a[i][j] == 0) a[i][j] = 2;
	for(int i = 1; i <= n; ++ i, printf("\n"))
	for(int j = 1; j <= n; printf("%d ", a[i][j]), ++ j) ;
	return 0;
}

```
### 注意：dfs在先搜索的时候应该搜索到矩阵的外面一圈（0， n + 1） 否则的话就会出现错误（边缘处被涂色）
#### 输入：  
6    
0 0 1 1 1 0  
1 1 1 0 1 0  
1 0 0 0 0 1    
1 1 0 1 1 1   
0 1 0 1 0 0  
0 1 1 1 0 0  
### 正确输出：  
0 0 1 1 1 0  
1 1 1 2 1 0  
1 2 2 2 2 1  
1 1 2 1 1 1  
0 1 2 1 0 0  
0 1 1 1 0 0  
### 错误输出： ~~自己改边界跑一下试试~~  
求审核给过一次 嘤嘤嘤~







---

## 作者：歌者siner (赞：114)

    哈哈哈本人第一次发布题解,希望管理员大大审核的时候手下留情!
   
   这一题为什么是**BFS**呢,**因为DFS的效率其实没有BFS那么高**
   
   
   为什么:
   
   看完代码之后你就知道了
   
   ### 思路:
   1.我们假设所有的'0'其实都被包围,但事实上并不是
   
   2.犯了错误就要纠正,具体有哪一些本来并不是被包围的'0'被我们误认成了被包围的?
   
   3.我们发现,那些在矩阵边缘的其实都不应该被包围!(这个就自己证明吧)
   
   
   ##### 程序实现:
   
   1.先认为所有的'0'都应该被修改,并且真的把它修改成了'2';
   
   2.边角上的'2'其实本来不应该被修改的,那我们把他们改回去  ,改成'0'
   
   3.然后来寻找与这些零相邻的'2',它们其实也是被改错了的
   ```
#include<iostream>
#include<ctime>
#include<cstdio>
using namespace std;
int num[40][40],c;
int k;
int main()
{
	int i,j,k,l;
	cin>>c;
	for(i=1;i<=c;i++)for(j=1;j<=c;j++)
	{
		scanf("%d",&num[i][j]);
		if(num[i][j]==0)num[i][j]=2;
	}
	for(i=1;i<=39;i++)
	{num[0][i]=9;num[i][0]=9;}//这一行先不要管,先看懂整个程序
	//输入+预处理结束 
	for(i=1;i<=c;i++)
	{
		if(num[1][i]==2){num[1][i]=0;}
		if(num[i][1]==2)num[i][1]=0;
		if(num[c][i]==2)num[c][i]=0;
		if(num[i][c]==2)num[i][c]=0;//针对所有边角料来一遍 
	}
	for(k=1;k<=100;k++)//广度优先搜索 阈值=100 (事实上不需要那么多)
	for(i=1;i<=c;i++)
	for(j=1;j<=c;j++)
	{
		if(num[i][j]!=1)
		if(num[i][j-1]==0||num[i-1][j]==0||num[i+1][j]==0||num[i][j+1]==0)
		num[i][j]=0; 
	}
	for(i=1;i<=c;i++)
	{
		
		for(j=1;j<=c;j++)
		printf("%d ",num[i][j]);
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：苏钦云 (赞：77)

第一次发题解，求给过（眼泪汪汪）。

首先讲一下思路：根据题意，当找到第一个1时，其右下必然是圈内的0，那么只要从这个0开始广搜寻找联通块就可以了。（因为圈只有一个，那么当找到第一个1之后便要打断循环，很重要！）

话不多说，上代码！

```cpp
#include<iostream>
using namespace std;
int n；
int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};//定义方向数组（暂且这么叫吧。）
int map[31][31];//用于存放矩阵
void cz(int p,int q){//bfs函数
	int h[1000][2];//定义队列
	int t,w,x,y,i;//t、w分别表示头、尾指针，x、y即横纵坐标
	map[p+1][q+1]=2;t=0;w=1;//将找到的1的右下角的0改为2
	h[1][1]=p+1;h[1][2]=q+1;//将0入队
	do{//四向广搜
		t++;
		for(i=0;i<=3;i++){
			x=h[t][1]+dx[i];y=h[t][2]+dy[i];//这里举个例子:当i=0时，横坐标加上dx【0】即1，纵坐标加上dy【0】即0，就表示向下搜索
			if(map[x][y]==0){//判断是否可以入队
				w++;
				h[w][1]=x;h[w][2]=y;
				map[x][y]=2;//“上色”
			}
		}
	}while(t<w);//队空则停止搜索
}
int main(){
	int i,j;
	bool f=0;
	cin>>n;
	for(i=0;i<n;i++){//输入矩阵
		for(j=0;j<n;j++){
			cin>>map[i][j];
		}
	}
	for(i=0;i<n;i++){//搜索第一个1
		for(j=0;j<n;j++){
			if(map[i][j]==1){
				cz(i,j);
				f=1;
				break;//找到后立即打断循环，因为只有一个圈
			}
		}
		if(f)break;
	}
	for(i=0;i<n;i++){//输出“上色”后的矩阵
		for(j=0;j<n;j++){
			cout<<map[i][j]<<" ";
		}
		cout<<endl;
	}
}
```
完成！

这里主要跟大家分享一下方向数组，刚学的，很方便不是吗？

如有不足还请dalao指正（抱拳）

（求过求过求过求过求过）

---

## 作者：封禁用户 (赞：36)

# 大爆搜

对于这种数据大小的题来说



首先预处理：

①将所有的0替换为2


②将处于边界处的2替换为0


然后进行


# 大爆搜


①先搜索所有的2，看其周围（4个方向）是否存在0，如果存在，就将其设为0（因为不在圈内）


②由①，我们已经扫除次外层所有的非1值了，此时可以在进行n边上述操作，直到圈外都是0，圈内都是2，圈上是1。


③但是该怎样实现呢？


很简单：


## 复制粘贴即可


（当然正解应该是递归）

因为这种数据规模下，绝对可以AC

```cpp
C++
#include <cstdio>
using namespace std;

const int L = 48;
int map[L][L] = {};
int n;
int X[4] = {1,-1,0,0};
int Y[4] = {0,0,1,-1};

void search(int sx,int sy){
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 0){
                map[i][j] = 2;
            }
        }
    }
}

void bfs(int sx,int sy){
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2){
                if(i == 0 || j == 0){
                    map[i][j] = 0;
                   }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(map[i][j] == 2 && (i > 0 && j > 0)){
                if(!map[i - 1][j] || !map[i + 1][j] || !map[i][j + 1] || !map[i][j - 1]){
                    map[i][j] = 0;
                }
            }
        }
    }
    
}

int main(){
    scanf("%d",&n);
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            scanf("%d",&map[i][j]);
        }
    }
    
    search(1,1);
    bfs(1,1);
    
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            printf("%d ",map[i][j]);
        }
        printf("\n");
    }
    
    return 0;
}
```

---

## 作者：封禁用户 (赞：26)

# 很有意思的一道bfs题。
本来大家看到题想的应该都是“如何将包围圈内的染成2”，但其实更方便的做法是“  __将0都染成2，再将暴露在闭合圈外的2染回0__ ”。
## 关键问题在于如何bfs
如果按照常规从（1,1）开搜的话，会被“与边框重合的闭合圈”卡住。因为程序无法正常搜索，或只能搜索一部分，如下情况
```
0 0 1 0 0
0 1 1 1 0
1 1 0 1 1
1 1 0 1 1
0 1 1 1 0
```
如果按正常方式搜索的话，会只有左上角的三个0，左上角及左下右下的2均没有变回0。

所以说要像这样，将矩阵外留一圈，方便搜索。
```
x x x x x x x x
x 0 0 0 0 0 0 x
x 0 0 1 1 1 1 x
x 0 1 1 0 0 1 x
x 1 1 0 0 0 1 x
x 1 0 0 0 0 1 x
x 1 1 1 1 1 1 x
x x x x x x x x
```
(x为留出的外圈边框，上边框在二维数组中纵坐标为0，下边框纵坐标为n+1,左边框在二维数组中横坐标为0，右边框横坐标为n+1)

在运行中，我们把边框和所有0都赋值为2，像这样
```
2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2
2 2 2 1 1 1 1 2
2 2 1 1 2 2 1 2
2 1 1 2 2 2 1 2
2 1 2 2 2 2 1 2
2 1 1 1 1 1 1 2
2 2 2 2 2 2 2 2
```
再从（0,0）开始搜索，将圈外0赋值为2即可完成答案！！（别把用于搜索的外圈一块输入了）
附上AC代码：
```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,xn[4]= {0,1,0,-1},yn[4]= {1,0,-1,0};
int a[32][32];
queue<pair<int,int> >q;//pair队列存坐标
int main() {
	/*
	先把所有的0染成2
	再把闭合环之外的2染回0
	bfs*/
	cin>>n;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			cin>>a[i][j];
		}
	}
	for(int i=0; i<=n+1/*从0赋值到n+1，将外圈和其他0赋值为2*/; i++) {
		for(int j=0; j<=n+1; j++) {
			if(a[i][j]==0)a[i][j]=2;
		}
	}
	q.push(make_pair(0,0));
	while(!q.empty()) {
		int x=q.front().first,y=q.front().second;
		q.pop();
		a[x][y]=0;//赋值为0，改写
		for(int i=0; i<4; i++) {
			if(a[x+xn[i]][y+yn[i]]==2) {//搜索还是2的相邻格子
				q.push(make_pair(x+xn[i],y+yn[i]));
			}
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {/*从1输出到n，别把辅助外圈一块输出了*/
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}
}
```
新人刚刚红名了（难道不是洛谷最弱红名吗？），第一次发题解，大佬们不喜请轻喷。可能有漏洞，大佬发现请指正。

---

## 作者：AFreeMan (赞：19)

//一道水题，从边缘DFS，把圈外的0都记录下，最后没记录的就是圈内的0，不过一开始没想到。。。



    
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,map[35][35],vis[35][35];
//大小n*n，图，是否访问过 
void dfs(int i,int j)//求联通块 
{
    if(map[i][j] || vis[i][j] || i<1 ||i>n || j<1 || j>n)return;
    vis[i][j]=1;
    dfs(i-1,j);dfs(i+1,j);dfs(i,j+1);dfs(i,j-1);
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)scanf("%d",&map[i][j]);
//贪心，从边缘DFS一定能把所有外面的0都访问过 
    for(int i=1;i<=n;i++){dfs(1,i);dfs(n,i);}
    for(int i=2;i<n;i++){dfs(i,1);dfs(i,n);}
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)if(map[i][j])printf("%d ",1); else printf("%d ",vis[i][j]?0:2);
        cout<<"\n";
    }
    return 0;
}
```

---

## 作者：ctq1999 (赞：10)

[传送门](https://www.luogu.org/problem/P1162)

此题是要找一个包围的圈，里面填色。

反过来想只要把外面的没被包围的找到就行

- #### 但是外面的被切割成了好几块（如测试点#2），怎么办

```
6
0 0 1 1 1 0
1 1 1 0 1 0
1 0 0 0 0 1
1 1 0 1 1 1
0 1 0 1 0 0
0 1 1 1 0 0

```


**最笨的办法：**

```cpp
for (int i = 1; i <= n; i++) {
	if (a[n][i] != 1) dfs(n, i);
	if (a[1][i] != 1) dfs(1, i);
}
for (int i = 1; i <= n; i++) {
	if (a[i][1] != 1) dfs(i, 1);
	if (a[i][n] != 1) dfs(i, n);
}
```

**比较聪明的办法：**

因为矩阵是从$(1, 1)$开始的，所以不妨把矩阵周围的格子也打开

就像水流一样，从$(1, 1)$开始放的话可能遇到格子为$1$的就停了

但如果从$(0, 0)$开始放，原矩阵外的格子不会有$1$，那么水就会流过去，从而所有没被包围的格子会有水流到

- #### $dfs$（俗称大法师）一定要用$4$个$if$来搜索吗

定义方向数组：

```cpp
int dx[] = {0, 0, -1, 1};
int dy[] = {1, -1, 0, 0};
```

那么三行就搞定了：

```cpp
for (int i = 0; i < 4; i++) {
		dfs(x + dx[i], y + dy[i]);
}
```

- #### 死循环怎么办

要知道，搜到下个格子后，可能会从下个格子搜回来，造成了死循环

定义$visit$数组，没搜到时为$0$，搜到一个后便把它标记为$1$（已搜）

> 希望可以帮助到萌新
> 
> $OI$之路十分漫长，此题只是一个微小的开始，但也是一个伟大的开始







---

## 作者：溜肾污主xyt (赞：8)

# 标准搜索题

题目描述： 由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字1构成，围圈时只走上下左右4个方向。现要求把闭合圈内的所有空间都填写成2.例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：

0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 0 0 1

1 1 0 0 0 1

1 0 0 0 0 1

1 1 1 1 1 1

0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 2 2 1

1 1 2 2 2 1

1 2 2 2 2 1

1 1 1 1 1 1

输入格式

每组测试数据第一行一个整数n(1≤n≤30)

接下来n行，由0和1组成的n×n的方阵。

方阵内只有一个闭合圈，圈内至少有一个0。

首先看数据：n<=30 数据很小，**搜索不会TLE**，不用优化。

再看描述：方阵内只有一个闭合圈，圈内至少有一个0。

也就是说，**除1与1包围的0以外，其他0都在外围**

不用多说，**搜索染色法**，可以轻松拓展在一起的0。但这时，问题就来了：怎么搜外围？ 众所周知，外围是有1的（如题目描述样例）


------------

case1 ：枚举外围：开循环枚举

蒟蒻专用写法 代码如下，枚举外围每个点，不难理解。

for(int i=1;i<=n;i++)if(f[i][1]==0)bfs(i,1);//第一列
for(int i=1;i<=n;i++)if(f[i][n]==0)bfs(i,n);//第n列
for(int i=1;i<=n;i++)if(f[1][i]==0)bfs(1,i);//第一行
for(int i=1;i<=n;i++)if(f[n][i]==0)bfs(n,i);//第n行
#### 虽然可以，但是 有没有觉得太麻烦了点？


------------

case2:围上一圈0

先拿样例来说：如果在外围围上一圈0，会怎样？

0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0

0 0 0 1 1 1 1 0

0 0 1 1 0 0 1 0

0 1 1 0 0 0 1 0

0 1 0 0 0 0 1 0

0 1 1 1 1 1 1 0

0 0 0 0 0 0 0 0

如果这样做，那么可以发现……由外圈开始，一定能搜到所有0！ 于是，我们只需要短短的一行来搜索。

# bfs(0,0);


------------

### 上代码~

广搜代码

```cpp
#include<bits/stdc++.h>//万能头，懒人专用 
using namespace std;
int f[32][32];
int dx[4]= {0,1,0,-1},dy[4]= {1,0,-1,0};//存储方向
int n;
queue<int>q;//使用stl队列
void bfs(int x,int y) {//广搜
    int x1,x2,y1,y2;//这里别学我开y1变量，有时候会被判断为一个函数y1，然后gg 
    q.push(x);//存储x(下同) 
    q.push(y);//存储y(下同) 
    f[x][y]=2;//染色(下同) 
    while(!q.empty()) {//队列不为空 
        x1=q.front();
        q.pop();
        y1=q.front();
        q.pop();//获得队头数据 
        for(int i=0; i<4; i++) {//向四个方向搜索
            x2=x1+dx[i];
            y2=y1+dy[i];//用变量，下文判断更方便 
            if(x2>=0&&x2<=n+1&&y2>=0&&y2<=n+1&&f[x2][y2]==0) { 
                q.push(x2);
                q.push(y2);
                f[x2][y2]=2;
            }//满足条件，入队
        }
    }
    return;
}
int main() {
    cin>>n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++) {
            cin>>f[i][j];
        }
    bfs(0,0);//从(0,0)开始，一定能搜到外圈省去多余枚举外圈代码
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            cout<<(f[i][j]==0?2:(f[i][j]==1?1:0))<<' ';//装B专用写法，意为如果为0输出2，否则如果为1输出1，否则输出0
        cout<<endl;//别忘记输出回车 
    }
    return 0;//好习惯 
}
```

深搜代码

```cpp
void dfs(int x,int y) {
    f[x][y]=2;//染色
    for (int i=0; i<4; i++)
        if(x>=0&&x<=n+1&&y>=0&&y<=n+1&&f[x][y]==0)
            dfs(x+dx[i],y+dy[i]);
}
```

至于打哪种搜索，可以选择自己不熟练的进行练习（就像我不熟悉广搜，就打了个广搜代码）

---

## 作者：_H1kar1 (赞：8)

ps：本题题解已经70多篇了...但是翻了翻竟然没有随机化的写法，于是斗胆提交一篇hhh

重要：_这个写法有小概率会错，但是胜在又快又简单，没有思维难度，而且很有意思XD，如果是考场上还可以用来骗分_

 基本思路如下:
 
*   随机生成一个点，判断这个点是否在环内，如果在，就从这个点开始floodfill（无脑泼水填充），如果不在，就重找一个点

 那么如何判断一个点在环内呢？这里的思路很简单:
 
 
*  如果向四个方向走都能碰到1,就在环内，反之不在

 这个做法当然不是保证正确的做法，而且有可能被卡（比如说有个只有一个小口的假环）但是看下数据范围，$n \leq30$，也就是说如果不是很刻意的卡，我们仍可以期望随机点生成在环内，正确率应该不错，事实证明，直接A了...



 [记录](https://www.luogu.org/record/24090249)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1000;
const int dx[]={0,0,-1,0,1},
          dy[]={0,1,0,-1,0};
//方向数组，不写大小代表视初始值情况而定
int a[MAXN][MAXN];
int n;

bool chk(int x,int y){
    if(a[x][y]==1)return false;
    //这里要注意，如果本来就是1就别找了，直接返回
    bool v1=false,v2=false,v3=false,v4=false;
    for(int i=1;i<=n && x+i<=n;i++)
        if(a[x+i][y]==1 )
            v1=true;
    for(int i=1;i<=n && y+i<=n;i++)
        if(a[x][y+i]==1 )
            v2=true;
    for(int i=1;i<=n && x-i>=0;i++)
        if(a[x-i][y]==1 )
            v3=true;
    for(int i=1;i<=n && y-i>=0;i++)
        if(a[x][y-i]==1 )
            v4=true;
    return v1 && v2 && v3 && v4;
}

bool vis[MAXN][MAXN]={0};
void fld_fill(int x,int y){
    if(a[x][y]==1 || vis[x][y])return ;
    //如果碰到边界或者泼过的点就返回
    vis[x][y]=true;
    a[x][y]=2;
    for(int i=1;i<=4;++i)
        fld_fill(x+dx[i],y+dy[i]);
}

int main(){
    srand(rand());//随机种子
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            scanf("%d",&a[i][j]);

    while(true){
        int x=rand()%n+1,y=rand()%n+1;
        //我们的点的坐标应该是1-n之间的
        bool flag=chk(x,y);
        if(flag){//如果在环内就泼水，否则再找一个点
            fld_fill(x,y);
            for(int i=1;i<=n;++i){
                for(int j=1;j<=n;++j)
                    printf("%d ",a[i][j]);
                printf("\n");
            }
            return 0;
        }
    }
}


```

---

## 作者：湫泷 (赞：7)

看了这么多题解，居然发现没有人用我这种方法

------------

蒟蒻：一拿到这到题我就对样例观察了一番，发现了这个圈的特点便是1 0 1。

二狗（一脸疑惑）：啥是1 0 1？

蒟蒻：就拿n为5的来说吧。

蒟蒻：形如1 0 0 0 1 ，1 0 0 1 1 ，1 0 1 1 1 ，0 1 0 0 1 ，0 1 0 1 1 ，0 1 1 0 1 ，0 0 1 0 1 ......
   
二狗（打断蒟蒻的话）：停停停，别举例子了，我已经懂了。

二狗（想了想）：为什么说是1 0 1呢？

蒟蒻：因为对于每一行输入来说，只要是第一个出现有1 0 1种格式的，中间的 0 一定属于圈内的 0 ，注意，是第一个，然后我们只要对这个0进行搜索就好啦。

蒟蒻：我给你举几个栗子，

	n=6

	0 0 0 0 0 0

	0 0 1 1 1 1

	0 1 1 0 0 1
	
	1 1 0 0 0 1

	1 0 0 0 0 1
	
	1 1 1 1 1 1

蒟蒻：你看上面这个样例，第三行的0 1 1 0 0 1，就是出现的第一个1 0 1，夹在中间的两个0，就是圈内的0。再给你举个例子。

	n=6

	0 1 1 1 1 0
	
	1 1 0 0 1 1
	
	1 0 0 0 0 1
	
	1 0 0 0 0 1
	
	1 1 0 0 1 1
	
	0 1 1 1 1 0 

蒟蒻：你看第二行的1 1 0 0 1 1 ，也是出现的第一个1 0  1，夹在中间的两个0也是圈内的0，这下你应该懂了吧。

二狗（皱了皱眉头）：你这不对啊！

蒟蒻（ÒωÓױ）：哪不对啦？？

二狗（拿出草稿纸画了画）：你看你看。

	n=9
	
	0 1 1 1 0 1 1 1 0
	
	0 1 0 1 0 1 0 1 0
	
	1 1 0 1 1 1 0 1 1
	
	1 0 0 0 0 0 0 0 1
	
	1 1 1 1 0 0 0 1 1
	
	0 0 0 1 1 0 1 1 0
	
	0 0 0 0 1 0 1 0 0
	
	0 0 0 0 1 0 1 0 0
	
	0 0 0 0 1 1 1 0 0
	
二狗（把草稿纸递给蒟蒻）：你看这栗子，既然这样话，第一行的0 1 1 1 0 1 1 1 0就是出现的第一个1 0 1。那你不是错了吗？

蒟蒻（拍了一下脑袋）：对哦，看样子不能找第一个1 0 1了。

二狗：找第二个不就好了吗？

蒟蒻（恍然大悟）：Aha！不愧是二狗！

（正当他们准备提交代码时）

蒟蒻（忽然感觉不太对）：咦？那如果只有一个1 0 1的话，上哪去找第二个呢？

二狗（慌了）：那咋办？？

蒟蒻（沉思....）:既然这样的话，我们把第一个1 0 1也记录下来，第二个也记录下来。如果有多个1 0 1的话，就用第二个1 0 1，如果只有一个1 0 1的话，就用第一个。

二狗：搜嘎斯内。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x;
	int y;
}st,by;
const int dx[5]={0,1,-1,0,0},dy[5]={0,0,0,1,-1};
int n,a[40][40],sum;
bool flag;
queue<node> q;
void dfs(node now){
	for(int i=1;i<=4;i++){
		node nxt;
		nxt.x=now.x+dx[i];
		nxt.y=now.y+dy[i];
		if(nxt.x>=1&&nxt.y<=n&&nxt.y>=1&&nxt.y<=n&&a[nxt.x][nxt.y]==0){
			a[nxt.x][nxt.y]=2;
			dfs(nxt);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		bool flag1=0,flag2=0,flag3=0;
		int x=0,y=0;
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
			if(a[i][j]==1&&flag1==0){
				flag1=1;
			}
			if(a[i][j]==0&&flag1==1&&flag2==0){
				flag2=1;
				x=i,y=j;
			}
			if(a[i][j]==1&&flag1==1&&flag2==1&&flag3==0){
				flag3=1;
			}
		}
		if(flag1==1&&flag2==1&&flag3==1){
			sum++;
			if(sum==1){
				by.x=x;
				by.y=y;
			}
		}
		if(sum==2){
			st.x=x;
			st.y=y;
		}
	}
	if(sum==1){
		st.x=by.x;
		st.y=by.y;
	}
	a[st.x][st.y]=2;
	if(n%2==0){
		q.push(st);
		while(!q.empty()){
			node now=q.front();
			q.pop();
			for(int i=1;i<=4;i++){
				node nxt;
				nxt.x=now.x+dx[i];
				nxt.y=now.y+dy[i];
				if(nxt.x>=1&&nxt.y<=n&&nxt.y>=1&&nxt.y<=n&&a[nxt.x][nxt.y]==0){
					a[nxt.x][nxt.y]=2;
					q.push(nxt);
				}
			}
		}
	}
	else{
		dfs(st);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}

```

---

## 作者：クリオネ (赞：7)

//思路：从外环的规则来看，第一个搜索到的‘1’的右下角一定是0

    
```cpp
//于是可以从这个0开始bfs
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
    int n,map[31][31],x,y,bfs[3000][2],head=1,len=2;
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        scanf("%d",&map[i][j]);
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        if (map[i][j]==1)
        {
            bfs[1][0]=i+1;
            bfs[1][1]=j+1;
            map[i+1][j+1]=2;
            break; 
        }
        if (bfs[1][0]!=0) break;  //这一个break一定不能忘，否则会出现十分令人崩溃的情况
    }
    while (head!=len) //四向bfs
    {
        if (map[bfs[head][0]+1][bfs[head][1]]==0)
        {
            bfs[len][0]=bfs[head][0]+1;
            bfs[len][1]=bfs[head][1];
            map[bfs[len][0]][bfs[len][1]]=2;
            len++;
        }
        if (map[bfs[head][0]-1][bfs[head][1]]==0)
        {
            bfs[len][0]=bfs[head][0]-1;
            bfs[len][1]=bfs[head][1];
            map[bfs[len][0]][bfs[len][1]]=2;
            len++;
        }
        if (map[bfs[head][0]][bfs[head][1]-1]==0)
        {
            bfs[len][0]=bfs[head][0];
            bfs[len][1]=bfs[head][1]-1;
            map[bfs[len][0]][bfs[len][1]]=2;
            len++;
        }
        if (map[bfs[head][0]][bfs[head][1]+1]==0)
        {
            bfs[len][0]=bfs[head][0];
            bfs[len][1]=bfs[head][1]+1;
            map[bfs[len][0]][bfs[len][1]]=2;
            len++;
        }
        head++;
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)    printf("%d ",map[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：oistr (赞：6)

看了看楼下的代码都开了2个数组，其实不需要啊qwq

**其实，只要一个map数组即可，可以同时担负“记录选过没选过”和“染色的地图”两个作用。**

基本思路：全图可以分成3部分：

1. 圈外

2. 圈内

3. 圈本身

那么思路就很明确了：**把图当做3个连通块用BFS去搜即可**。搜到的第二个全0联通块即是我们要染色的部分。

但是，应注意到下面这种情况：

```
6
0 0 1 1 1 0
0 1 1 0 1 0
0 1 0 0 1 1
0 1 0 0 0 1
0 1 1 1 1 1
0 0 0 0 0 0
```
图中“圈外”这一部分其实是两个连通块！

**对于这种情况，我们只需要把图扩大一下，在外面增加一圈0，就能保证圈外这一部分始终都是1个联通块了。**

算法流程：

1.读入数组，从(1,1)开始存到map数组中。

2.以（0,0）为起点搜第一个连通块。将这个连通块内的点全部涂成3。

3.找到下一个0点，这个点必然在圈内。所以以这个点为起点在搜一会，这回将搜到的所有点涂成2。

4.输出。记得将所有3转换为0即可。

我们将搜到的点全部涂成不是0的值（true），这样没有搜到的点全部是0（false），**这样要想知道(i,j)有没有搜过只需要看map[i][j]的逻辑真假即可。所以不用开另一个数组专门记录。**

附AC代码：

```cpp
#include <iostream>
#include <queue>
using namespace std;
//结构体：点
struct Point
{
	int x;
	int y;
};
//图的大小n和map数组
int n,map[33][33];
//常量数组记录移动方向，这里是四向
int mx[4]={0,0,1,-1};
int my[4]={1,-1,0,0};
  //广搜必备之队列
queue<Point> q;
  //out函数判断是否越界
bool out(int x,int y)
{
  //因为第一轮搜索从（0,0）开始，所以越界判断也应该是x<0而不是x<1。第二轮搜索不会越界，所以这样设置没有问题。
	return x<0||y<0||x>(n+1)||y>(n+1);
}
  //bfs，sxsy是起点，color是本轮搜索要将搜到的点涂成的颜色
void bfs(int sx,int sy,int color)
{
  //入队，采用强制类型转换，这样写更简洁
	q.push((Point){sx,sy});
	map[sx][sy]=color;//别忘了起点
	while(!q.empty())
	{
		Point np=q.front();
		q.pop();//np：当前状态
		for(int i=0;i<4;i++)
		{
			int x=np.x+mx[i];
			int y=np.y+my[i];//扩展新的点
                             //越界，被使用的均应该continue
			if(out(x,y))
			{
				continue;
			}
			if(map[x][y])
			{
				continue;
			}
                             //填涂颜色，入队
			map[x][y]=color;
			q.push((Point){x,y});
		}
	}
}
                             //输出函数
void output()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(map[i][j]==3)//如果是3则输出0
			{
				cout<<0<<" ";
				continue;
			}
			cout<<map[i][j]<<" ";
		}
		cout<<endl;
	}
}
int main()
{
                   //读入，从（1,1）开始存储
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>map[i][j];
		}
	}
	bfs(0,0,3);//先搜一轮
	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<=n;j++)
		{
			if(!map[i][j])
			{
				bfs(i,j,2);//寻找下一个没搜到的点（圈内），开始第二轮搜索
			}
		}
	}
	output();//输出
	return 0;//qwq
}
```

---

## 作者：critnos (赞：6)

![](https://cdn.luogu.com.cn/upload/pic/69505.png)

因为不会BFS，所以什么01迷宫之类的我都是用DFS的

显然，涂色并不难，难的是如何找到图形内部的点

本蒟蒻一开始是这样想的：枚举每个点，然后分别枚举上下左右四个方向，如果都碰到了1，那么这个点就在图形里面

30分钟过去了，我正在艰难地打着第41行代码，突然，一个不祥的想法在我脑中闪过......

这个方法不行啊！！！

比如这个：

![](https://cdn.luogu.com.cn/upload/pic/69514.png)

那个红点所在的区域是有问题的，它的上下左右都有边框，却不是内部的点

那怎么办呢？

枚举？

把每个点都枚举一遍，若碰到数组边缘就停（即x或y等于n或小于0），但是很有可能会超时（时间复杂度O(n^4)）

又经过了一天的思考，我想出了如下方案：

图形把平面分为两部分，那么先随机找一个为0的点（我为了方便用的是最后一个0点），然后用两个DFS（DFS1用来染色判断，DFS2用来涂色输出），从这个点开始染色（要开两个数组），如果碰到边缘，不要停止，继续染色，染色完毕后如果碰到过边缘那么说明被染色过的都是在图形外的点（如果没有碰到过边缘那就直接输出），在找一次没被染色过的0点，再染色另一个数组就可以了

然而......

![](https://cdn.luogu.com.cn/upload/pic/69516.png)

下载数据后，发现......

不一定把平面分为**两**部分啊！！！

福利数据：

6

0 0 **1 1 1** 0

**1 1 1** 0 **1** 0

**1** 0 0 0 0 **1**

**1 1** 0 **1 1 1**

0 **1** 0 **1** 0 0

0 **1 1 1** 0 0

又经过了若干天的思考，我想出了如下AC方案：

图形把平面分为若干部分，那么先找一个0点，然后从这个点开始染色，如果碰到边缘，不要停止，继续染色，染色完毕后如果碰到过边缘那么说明被染色过的都是在图形外的点，一直找到不碰到边缘了，说明那个点在图形内部，再染色另一个数组就可以了

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[35][35],n,b[35][35],f;
int fx[4]={-1,0,0,1},fy[4]={0,-1,1,0};
int TP(int x)
{
	if(x<0||x==n) return 1;
	return 0;
}
inline void dfs1(int x,int y)
{
	if(b[x][y]) return;
	if(TP(x)||TP(y)) 
	{
		f=1;
		return;
	}
	b[x][y]=2;
	for(int i=0;i<4;i++)
		dfs1(x+fx[i],y+fy[i]);
}
inline void dfs2(int x,int y)
{
	if(a[x][y]) return;
	a[x][y]=2;	
	for(int i=0;i<4;i++)
		dfs2(x+fx[i],y+fy[i]);
} 
int main()
{
	int i,j,x,y,flag;
	cin>>n;
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]==0)
			{
				x=i;
				y=j;
			}
			b[i][j]=a[i][j];
		}	
	for(;;)
	{
		f=0;
		flag=0;
		dfs1(x,y);
		if(f==0) break;
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++)
				if(!b[i][j])
				{
					x=i;
					y=j;
					flag=1;
					break;
				}
			if(flag) break;
		}		
	}	
	dfs2(x,y);
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
			cout<<a[i][j]<<' ';
		cout<<endl;
	}
} 
```


![](https://cdn.luogu.com.cn/upload/pic/69511.png)

快乐地AC

---

## 作者：HearTheWindSing (赞：6)

开始本菜鸟感觉此题挺难得，因为不知道怎么确定哪块是‘1’围起来的

其实这道题不难

关键是把
## 思路
理清

仔细一想其实把***不是***‘1’里面的区域标记出来不就好了

---

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
3是被标记的，也就是不填涂的，最后输出0
1是组成圈的东西，最后输出1
0(指开始时的)是一会有些会变成3有些会原封不动的
0(指输出时的)是最后剩下的0，也就是要填涂的，最后输出2
(2到哪去了？)
*/
int paper[32][32];
int main ()
{
	int n;
	for (int i=0;i<32;i++){
		for (int ii=0;ii<32;ii++){ //先全部初始化为3
			paper[i][ii]=3;
		}
	}
	cin >> n;
	for (int i=1;i<=n;i++){
		for (int ii=1;ii<=n;ii++){ //输入
			cin >> paper[i][ii];
		}
	}
	int a;
	do{
		a=0; //a是用来计数的
		for (int i=1;i<=n;i++){
			for (int ii=1;ii<=n;ii++){
				if (paper[i][ii]==0 && (paper[i+1][ii]==3 || paper[i-1][ii]==3 || paper[i][ii+1]==3 || paper[i][ii-1]==3)){
					paper[i][ii]=3; //3是被标记的，也就是说这里不填涂
					a++;
				}
			}
		}
	}while (a!=0); //如果do{}while循环下来a还是0的话，说明已经没有可标记的了
	for (int i=1;i<=n;i++){
		for (int ii=1;ii<=n;ii++){
			(paper[i][ii]==3) ? (cout << 0 << ' ') : ((paper[i][ii]==1) ? (cout << 1 << ' ') : (cout << 2 << ' ')); //这是两个连在一起用的三目运算符，如果不知道就自己上百度搜
		}
		cout << endl;
	}
	return 0;
} //本菜鸟实际上并没有学过BFS，以上均为个人钻研结果，所以大牛勿喷

```
---
end

---

## 作者：Soledad_S (赞：6)

# 能得分的算法……
简单粗暴。由题目知道，要染色的连通块都是由一包围起来的，所以凡是能搜边界的连通块都是不需要染色的。
 
上来就搜索（1，1），如果搜到了边界，标记搜到的点，输出的时候，若没有标记，就染色。

如果没搜到边界，还是标记搜到的点，输出的时候直接输出标记。

（本蒟蒻也只能想到这些）……

```cpp

#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
int n,a[1005][1005],vst[1005][1005],bj=0;;
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
struct node {int x,y;};
void BFS(int x,int y)//常规操作 
{  queue<node>q;
   node t={x,y};
   q.push(t); 
   vst[x][y]=1;
   while(!q.empty())
   {  int nx=q.front().x,ny=q.front().y;
      for(int i=0;i<4;i++)
      {  int tx=nx+dx[i],ty=ny+dy[i];
         if(tx<1||tx>n||ty<1||ty>n){bj=1;continue;}//如果是边界，标记 
         if(!vst[tx][ty])
         {  node t={tx,ty};
            q.push(t);
            vst[tx][ty]=1; //标记搜到的点 
        }
      
      }q.pop();
   }
}
int main()
{  cin>>n;
   for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
     {  scanf("%d",&a[i][j]);if(a[i][j])vst[i][j]=1;//原图上为1就标记1 
     }
     
   BFS(1,1);
   if(bj)//如果搜到边界，那么未标记的点染色 
   {  for(int i=1;i<=n;i++)
      {  for(int j=1;j<=n;j++)if(!vst[i][j])printf("2 "); 
      else printf("%d ",a[i][j]);
         printf("\n");
      }
   }
   else//反之，标记了的且原图不为1的点染色 
   {  for(int i=1;i<=n;i++)
      {  for(int j=1;j<=n;j++)
      if(vst[i][j]&&!a[i][j])
      printf("2 ");
      else printf("%d ",a[i][j]);
         printf("\n");
      }
   }
   return 0;
 } 
```
想的太快了，让我们停下来喘口气。

看看这组样例
```cpp
6
0 1 1 1 1 0
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
0 1 1 1 1 0
```
本代码的输出

```
6
0 1 1 1 1 2
1 2 2 2 2 1
1 2 2 2 2 1
1 2 2 2 2 1
1 2 2 2 2 1
2 1 1 1 1 2
```
如果能搜到边界的点不止1个，情况会很尴尬。还有，（1，1）这个点是永远都搜得到边界的，代码根本不会执行第二种输出。

错误百出……
~~但只要数据够水，40分也是小菜一碟。~~
 # 于是就有了正解
我们将vst数组增加一个用途，记录为第几次搜到的点（这不好影响搜索本身），用一个sign去更新它。
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
int n,a[1005][1005],vst[1005][1005],sign=1;//因为原图上为1就标记1，所以第一次搜索时标记为2 
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
struct node {int x,y;};
int BFS(int x,int y)//还是常规操作 
{  queue<node>q;
   node t={x,y};
   q.push(t); 
   sign++;
   vst[x][y]=sign;
   int bj=1;//初始为1 
   while(!q.empty())
   {  int nx=q.front().x,ny=q.front().y;
      for(int i=0;i<4;i++)
      {  int tx=nx+dx[i],ty=ny+dy[i];
         if(tx<1||tx>n||ty<1||ty>n){bj=0;continue;}//如果搜到边界，bj为假。 
         if(!vst[tx][ty])
         {  node t={tx,ty};
            q.push(t);
            vst[tx][ty]=sign; //标记第几次搜 
      }
      
   }q.pop();
}
   return bj;
}
int main()
{  cin>>n;
   for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
     {  scanf("%d",&a[i][j]);
        if(a[i][j])vst[i][j]=1;//原图上为1就标记1 
     }
     
   for(int i=2;i<=n;i++)
     for(int j=2;j<=n;j++)//每一个点都搜索，因为在边缘的点必定搜到标记，所以从2开始。 
       if(!vst[i][j])//如果这个点不是1. 
         if(BFS(i,j))//返回真表示搜到染色块，sign会保存的是染色连通块的标记。 
         {  for(int i=1;i<=n;i++)
            {  for(int j=1;j<=n;j++)
                 if(vst[i][j]==sign)printf("2 ");//如果点的标记等于sign，染色。 
                 else printf("%d ",a[i][j]);
                printf("\n");
            }
         }
   return 0;
 } 
```

（蒟蒻的题解如有错误，还望各位dalao指正。）

---

## 作者：yyy2015c01 (赞：5)

by:yyy2015c01

blog:http://iyyy.sinaapp.com/

想象洪水从四面八方涌过来。

```cpp

#include<iostream>  
#include<queue>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<cstring>  
#include<string>  
#include<cstdlib>  
using namespace std;  
int map[31][31]={0},x[10001]={0},y[10001]={0},f[31][31]={0},dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
int main()
{
    int n,l,r,xx,yy;
    scanf("%d",&n);//读入
    for (int i=1;i<=n;i++)
    {
        for (int j=1,tmp;j<=n;j++)
        {
            map[i][j]=2;//初始全部0置为2
            scanf("%d",&tmp);
            if (tmp) 
            {
                f[i][j]=map[i][j]=1;//f是标志数组，0代表未找过，1代表找过
            }
        }
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            if (((i!=1&&j!=1)&&(i!=n&&j!=n))||map[i][j]!=2 ||f[i][j]==1) continue;
//精华：当这个点在边界上、map中为2、且未走过或被1填充时bfs，队列中得到的点都不可能为2
            l=0;
            r=1;
            x[1]=i;
            y[1]=j;
            while(l<r)
            {
                l++;
                for (int k=0;k<4;k++)//四个方向搜索
                {
                    xx=x[l]+dx[k];
                    yy=y[l]+dy[k];
                    if (xx<1||yy<1||xx>n||yy>n||f[xx][yy]==1)//顺序不能乱，不然越界
                    {
                        continue;
                    }
                    f[xx][yy]=1;//置为已走过
                    r++;
                    x[r]=xx;//入队
                    y[r]=yy;
                }
            }
            for (int ii=1;ii<=r;ii++)
            {
                map[x[ii]][y[ii]]=0;//置为0
                f[x[ii]][y[ii]]=1;
            }
        }
    }
    for(int i=1;i<=n;i++)  
    {  
        for(int j=1;j<=n;j++)//输出
        {
            printf("%d ",map[i][j]); 
        } 
        puts("");  
    }  
    return 0;
}

```

---

## 作者：CoolTeam (赞：3)

我一开始代码跟@墨凝而止 的差不多，也AC了，后来发现并不是正确的题解，只是数据太弱。比如输入

5
1 1 1 0 1

1 0 1 0 1

1 1 1 0 1

1 0 0 0 1

1 1 1 1 1

=========

1 1 1 0 1

1 2 1 0 1

1 1 1 0 1

1 2 2 2 1

1 1 1 1 1

如果用这样的程序只能得到这样的错误结果，不信可以试试，其实有不少人(感觉起码有10%)都骗过去了。实际答案只有坐标(2,2)被置为2。

我这里也给一份C代码的“能AC的错解”：

```cpp
#include<stdio.h>
int main(void)
{
    int a[31][31],temp;
    int n,i,j,k;
    scanf("%d\n",&n);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            a[i][j]=2;
            if(scanf("%d",&temp)&&temp==1) a[i][j]=temp;
        }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(a[i][j]==1) break;
            a[i][j]=0;
        }
        for(j=1;j<=n;j++)
        {
            if(a[j][i]==1) break;
            a[j][i]=0;
        }
        for(j=n;j>=1;j--)
        {
            if(a[i][j]==1 ) break;
            a[i][j]=0;
        }
        for(j=n;j>=1;j--)
        {
            if(a[j][i]==1 ) break;
            a[j][i]=0;
        }        
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            printf("%d ",a[i][j]);    
        printf("\n");
    }
    return 0;
}
```
但是，我的目的毕竟不是为了骗一骗然后AC就得了，而是通过题目来学习和巩固算法。

于是不久前才学了BFS的我试着用上去了。

思路是这样的（BFS用队列实现）

①n\*n个坐标全部设置为2，然后输入1的坐标，用book记录坐标为1的地方不可到达。

②枚举每一个坐标，如果是2，则以此为坐标BFS。

③把从该起点为坐标能BFS到达的地方全部坐标入队。

④只要其中一条路是通往边界，那么队列全部坐标都要被设置为0.

下面是C代码：

```cpp
#include<stdio.h>
struct node{
    int x;//横坐标，等同j 
    int y;//纵坐标，等同i 
};
int main(void)
{
    struct node Que[910];
    int a[31][31],book[31][31]={{0}},next[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
    int n,i,j,k,l,head,tail,tx,ty,flag,temp;
    scanf("%d\n",&n);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            a[i][j]=2;//先初始化为2，之后从2开始BFS，能走到边界则置0 
            if(scanf("%d",&temp)&&temp==1) {book[i][j]=1; a[i][j]=temp;}//标记1的位置 
        }
    for(i=1;i<=n;i++)//注意：i,y为深度(纵坐标)，j,x为广度(横坐标) 
        for(j=1;j<=n;j++)
        {
            if(a[i][j]!=2 || book[i][j]==1) continue; //找到2并以此坐标为BFS起点 
            tail=head=1; 
            Que[tail].x=j;
            Que[tail].y=i;//队列初始化 
            tail++;//tail记录队尾的下一个位置 
            flag=0;//flag记录有无找到边界 
            while(tail>head)//开始BFS 
            {
                for(k=0;k<4;k++)//枚举4个方向
                {
                    tx=Que[head].x+next[k][0];
                    ty=Que[head].y+next[k][1];
                    if(tx<1 || tx>n || ty<1 || ty>n)
                    {
                        flag=1;//找到边界 
                        break;
                    }
                    if(book[ty][tx]!=0) continue;
                    book[ty][tx]=1;
                    Que[tail].x=tx;
                    Que[tail].y=ty; 
                    tail++;//入队
                }
                head++;//以下一个点继续扩展路线 
            }
            if(flag) 
            {
                for(l=1;l<tail;l++)//遍历以i,j为起点BFS得到的队列。
                    a[Que[l].y][Que[l].x]=0; 
            }
        }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            printf("%d ",a[i][j]);    
        printf("\n");
    }
    return 0;
}
```
我一开始代码跟@墨凝而止 的差不多，也AC了，后来发现并不是正确的题解，只是数据太弱。比如输入

5
1 1 1 0 1

1 0 1 0 1

1 1 1 0 1

1 0 0 0 1

1 1 1 1 1

=========

1 1 1 0 1

1 2 1 0 1

1 1 1 0 1

1 2 2 2 1

1 1 1 1 1

如果用这样的程序只能得到这样的错误结果，不信可以试试，其实有不少人(感觉起码有10%)都骗过去了。实际答案只有坐标(2,2)被置为2。

我这里也给一份C代码的“能AC的错解”：

```cpp
#include<stdio.h>
int main(void)
{
    int a[31][31],temp;
    int n,i,j,k;
    scanf("%d\n",&n);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            a[i][j]=2;
            if(scanf("%d",&temp)&&temp==1) a[i][j]=temp;
        }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(a[i][j]==1) break;
            a[i][j]=0;
        }
        for(j=1;j<=n;j++)
        {
            if(a[j][i]==1) break;
            a[j][i]=0;
        }
        for(j=n;j>=1;j--)
        {
            if(a[i][j]==1 ) break;
            a[i][j]=0;
        }
        for(j=n;j>=1;j--)
        {
            if(a[j][i]==1 ) break;
            a[j][i]=0;
        }        
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            printf("%d ",a[i][j]);    
        printf("\n");
    }
    return 0;
}
```
但是，我的目的毕竟不是为了骗一骗然后AC就得了，而是通过题目来学习和巩固算法。

于是不久前才学了BFS的我试着用上去了。

思路是这样的（BFS用队列实现）

①n\*n个坐标全部设置为2，然后输入1的坐标，用book记录坐标为1的地方不可到达。

②枚举每一个坐标，如果是2，则以此为坐标BFS。

③把从该起点为坐标能BFS到达的地方全部坐标入队。

④只要其中一条路是通往边界，那么队列全部坐标都要被设置为0.

下面是C代码：

```cpp
#include<stdio.h>
struct node{
    int x;//横坐标，等同j 
    int y;//纵坐标，等同i 
};
int main(void)
{
    struct node Que[910];
    int a[31][31],book[31][31]={{0}},next[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
    int n,i,j,k,l,head,tail,tx,ty,flag,temp;
    scanf("%d\n",&n);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            a[i][j]=2;//先初始化为2，之后从2开始BFS，能走到边界则置0 
            if(scanf("%d",&temp)&&temp==1) {book[i][j]=1; a[i][j]=temp;}//标记1的位置 
        }
    for(i=1;i<=n;i++)//注意：i,y为深度(纵坐标)，j,x为广度(横坐标) 
        for(j=1;j<=n;j++)
        {
            if(a[i][j]!=2 || book[i][j]==1) continue; //找到2并以此坐标为BFS起点 
            tail=head=1; 
            Que[tail].x=j;
            Que[tail].y=i;//队列初始化 
            tail++;//tail记录队尾的下一个位置 
            flag=0;//flag记录有无找到边界 
            while(tail>head)//开始BFS 
            {
                for(k=0;k<4;k++)//枚举4个方向
                {
                    tx=Que[head].x+next[k][0];
                    ty=Que[head].y+next[k][1];
                    if(tx<1 || tx>n || ty<1 || ty>n)
                    {
                        flag=1;//找到边界 
                        break;
                    }
                    if(book[ty][tx]!=0) continue;
                    book[ty][tx]=1;
                    Que[tail].x=tx;
                    Que[tail].y=ty; 
                    tail++;//入队
                }
                head++;//以下一个点继续扩展路线 
            }
            if(flag) 
            {
                for(l=1;l<tail;l++)//遍历以i,j为起点BFS得到的队列。
                    a[Que[l].y][Que[l].x]=0; 
            }
        }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            printf("%d ",a[i][j]);    
        printf("\n");
    }
    return 0;
}
```
另外表示虽然知道有floodfill算法，但找不到合适资料的来学习(因为百度到的资料基本都是图像处理方向的)，希望楼上有人能来补一下课←\_←，谢谢。


---

## 作者：信赖滴星辰 (赞：3)

别看代码长，其实就只是括号多而已。

这个代码是写给~~像我这样~~不会搜索的人看的

~~搜索都不会，发什么题解~~

这个代码还可以有很多的优化，但是本蒟蒻~~又笨又~~懒，就留给大佬们改进了

先说一下与众不同的思路：

## ~~假的~~分治法

举个栗子——

1 1 1

**1** 0 **1**

1 1 1

先找到最左边的那个粗体的1

再往右找，找到最右边的粗体的1

然后把两个1之间的所有的0都变成2就好了

大体思路就是这样，一行一行找，把每行两个1之间的0变成2

于是本蒟蒻兴致满满地提交了，80分，因为还有个问题


![0和1](http://a3.qpic.cn/psb?/V11wzxgJ16ZAMk/ViTNIohxi0w2dL.II.VT3keUoVKiWlMX2PpQc0LSK.M!/m/dC4BAAAAAAAAnull&bo=SQFDAQAAAAADByg!&rf=photolist&t=5)

圈出来的那些诡异的2，按照逻辑，确实是位于两个1之间的，可以涂成2，然而事实上是错的

怎么解决呢，本蒟蒻想到一个很笨的办法，就是横着做一遍，再竖着做一遍，如果两遍都是2，就输出2，否则就输出1

其实也可以做个指针什么的，但是反正只要复制粘贴数组改一下就好了，本蒟蒻就没多去想了

上代码

```cpp
#include <iostream>
using namespace std;

int n;
int map[31][31];        //横着一遍,dalao们千万别学我，将数组名定义成"map"
int check[31][31];      //竖着一遍

void hanshu(int x,int y) //横着的
{
	int flag=0;
	for(int i=y;i<=n;i++)
	{
		if(flag==1)      
		{
			break;
		}
		if(map[x][i]==1 && map[x][i+1]==0)
		{
			flag=1;    //找到了第二个1，接下来要将中间的0变成2
			for(int j=i+2;j<=n;j++)
			{
				if(map[x][j]==1 && map[x][j-1]==0)
				{
					for(int k=i+1;k<=j-1;k++)
					{
						if(map[x][k]!=1)  //如果不是1，那么就是0了，就变成2
						{	
							map[x][k]=2;
						}
					}
				}
			}	
		}
	}
}



void Hanshu(int x,int y)   //跟上面的一模一样
{
	int flag1=0;
	for(int i=x;i<=n;i++)
	{
		if(flag1==1)
		{
			break;
		}
		if(check[i][y]==1 && check[i+1][y]==0)
		{
			flag1=1;
			for(int j=i+2;j<=n;j++)
			{
				if(check[j][y]==1 && check[j-1][y]==0)
				{
					for(int k=i+1;k<=j-1;k++)
					{
						if(check[k][y]!=1)
						{	
							check[k][y]=2;
						}
					}
				}
			}	
		}
	}
}



int main()
{	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>map[i][j];         //横着一遍
			check[i][j]=map[i][j];  //竖着一遍
		}
	}
	
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(map[i][j]==1)
			{
				hanshu(i,j);
				Hanshu(i,j);  //两个函数名有点诡异
			}
		}
	}

	cout<<endl;   //这是方便调试的，要提交得删掉这行

	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(map[i][j]==2)  //如果横着的是2
			{
				if(check[i][j]==2)   //并且竖着的也是2
				{
					map[i][j]=2;
				}
				else
				{
					map[i][j]=0;    //那么就是2了
				}
			}
			
		}
	}

	for(int i=1;i<=n;i++)  //输出
	{
		for(int j=1;j<=n;j++)
		{
			if(j!=n)
			{
				cout<<map[i][j]<<" ";
			}
			else
			{
				cout<<map[i][j]<<endl;
			}
		}
	}

return 0;	//良好习惯
} 

```

写了这么多，望批准啊

有大佬有问题，可以私信我哦，或者直接评论，我会定期看的


---

## 作者：FCBM71 (赞：3)

刚刚看了大佬们的题解，发现几乎全是C党。于是我决定为广大P党提供一种思路。

 
从思路上来说，这题其实挺简单的。对于任何一个在圈圈内部的点，他的正上方，正下方，正左边，正右边都至少有一个1.只有这样他才能被判定是在圈内部。example（举了一个长方形的例子，正方形也同理。）

**11111**000

**1**000**1**0**B**0

**1**0**A**0**1111**

**1**000000**1**

**11111111**

对于在框内的A来说他的正上，正下，正左，正右都有一个1.所以就可以判断他在方框内部；而对于B，他的上方和右边都没有1，就说明他不在框中。


由于这道题数据比较弱（只有30\*30），\*所以在不用任何算法的情况下纯粹的暴力模拟所有点在时间上也绰绰有余。

算法上对每个点**（特别地，一定要判断这个点本身是不是1.如果他本身就是1，则跳过以下所有步骤）**用四个repeat。分别用于枚举他的四个方向有没有1.如果四个方向都有1，这个点赋值为2.\*


废话不多说，上代码：

 






```cpp
    var
      a:array[0..31,0..31]of longint;  //数组一定要开到0..31，原因见下
      n,i,j,k:longint;
     begin
      read(n);
      for i:=0 to n+1 do begin
       a[0,i]:=-1;a[i,0]:=-1;
       a[n+1,i]:=-1;a[i,n+1]:=-1;   //对整幅图的边界做标记，一会儿repeat到边界时自动停止
      end;
      for i:=1 to n do
       for j:=1 to n do
        read(a[i,j]);  //读入
      for i:=1 to n do
       for j:=1 to n do begin
        k:=0;
        if a[i,j]=0 then begin //如果该点不是闭合圈上的一点才开始循环
        repeat
         k:=k+1;
        until(a[i-k,j]>0)or(a[i-k,j]=-1); //搜索该点上方有没有1
        if a[i-k,j]>0 then begin
         k:=0;
         repeat
          k:=k+1;
         until(a[i+k,j]>0)or(a[i+k,j]=-1);  //搜索该点下方有没有1
         if a[i+k,j]>0 then begin
          k:=0;
          repeat
           k:=k+1;
          until(a[i,j+k]>0)or(a[i,j+k]=-1);  //搜索该点右方有没有1
          if a[i,j+k]>0 then begin
           k:=0;
           repeat
            k:=k+1;
           until(a[i,j-k]>0)or(a[i,j-k]=-1); //搜索该点左方有没有1
           if a[i,j-k]>0 then a[i,j]:=2;  //如果这个点四个方向都有1，则把这个点赋值为2
          end;end;
         end;
        end;
       end;
      for i:=1 to n do begin
       for j:=1 to n do
        write(a[i,j],' ');
       writeln; //输出
      end;
     end.

```

---

## 作者：Khassar (赞：3)

/\*关于这题我要介绍一种奇葩的解法

看到很多大神都是广搜或者是从外往里的深搜，我表示我都不会；

所以我只好用这种很笨的方法：

从前往后依次搜索，遇到1记一下，再往后搜到0时打上标记；

不过这样还需要很多情况的判断，具体判断看注释

\*/



        
            
        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,c[50][50];//n是方阵大小，c数组是输入的方阵
int a[50][50],flag;//a是方阵的标记数组，flag是状态标记
int main()
{
    scanf("%d",&n);
for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            scanf("%d",&c[i][j]);//输入数据
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i-2][j]!=2&&c[i-2][j]!=1)//判断上方有没有在闭合圈内
                if(a[i-1][j]==2)
                    a[i-1][j]=0;    //不在就把标记去掉
        }
        if(flag==2)//当上一行无1做结尾时：
        {
            for(int k=n;k>0;--k)//倒着找上一行直到找到一个1，并把标记去掉
            {
                if(c[i-1][k]==1)
                    break;
                if(a[i-1][k]==2)
                    a[i-1][k]=0;    
            }
        }
        flag=0;//每行从头开始时把标记重置成0
        for(int j=1;j<=n;++j)
        {
            if(c[i][j]==1&&flag!=2)
                flag=1;//找到1时把标记记为1
            if(c[i][j]==0&&(flag==1||flag==2))
            {
                a[i][j]=2;//在标记不为0的情况下把扫到的0记上标记
                flag=2;
            }
            if(flag==2&&c[i][j]==1)
                flag=1;
        }
    }
    for(int i=n;i>=1;--i)//倒着搜一遍标记
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i+1][j]!=2&&c[i+1][j]!=1)//判断下方在不在闭合圈内
                if(a[i][j]==2)
                    a[i][j]=0;//不在去掉标记
        }
    }
    if(flag==2)//正着搜索打标记时没有判断最后一行这里在判断下
        {
            for(int k=1;k<=n;++k)
                if(a[n][k]==2)
                    a[n][k]=0;    
        }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)//输出
        {
            if(a[i][j]==2)//如果有标记就输出2
                printf("2 ");
            else
                printf("%d ",c[i][j]);//没有标记就输出原数
        }
    printf("\n");//换行
    }
    return 0;
}
//可能标记标记有点乱
//为什么自动左对齐啊，我好懒不想美化
```

---

## 作者：iLeGend (赞：3)

本题一个新思路。

我第一次想水过这道题，用n^2遍历结果好久没写程序一下写跪了。

于是希望偷懒简化复杂度，于是这个方法就诞生了，只用一次遍历。

==================分割线=================================

读入时将所有0赋成2，然后从边界（0,0）开始遍历，把和边界连在

在一起的全部赋成0，输出OK！


第一次题解，++RP。


---

## 作者：USSENTERPRISE (赞：2)

# 这是史上最毒瘤的A题方式 #

****$ Upd \text{ } 2019/09/30 $**** : 吸收了机房一位学姐的意见，将思路分析放到了代码前，去掉了代码中一些不必要的注释和语句。

****$ Upd \text{ } 2019/10/17 $**** : 又用bfs打了一遍，将代码贴到这里

-----------

**** 不要抄袭！不要抄袭！不要抄袭！ ****

~~而且也不是最优解~~

$ \color{Brown} \text{棕名} $ 后果自负！！！


------------

对于本题，我当时的思路不是BFS，而却想到了暴力的方法。。。

首先，你需要先存下来这个矩阵~~废话~~ 紧接着，你需要从左往右扫一遍，每行直到碰见1再停，并把所有遍历过的单元标记为3（其实只要除0、1、2之外的数值均可）。

然后，你需要按相同的方式从右至左、从上至下、从下至上均扫一遍。

最后，把所有0替换成2就可以了。

> 这里需要说明一下，当你将所有剩下的0替换成2时，你所替换的一定是圈内的位置。对此你可以想象成为这个圈做了一个由3组成的模子，模子之内就是所要操作的空间

### 代码如下： ###

```cpp
// AC 12ms
#include <bits/stdc++.h>
#define rg register
#define MAX 35
using namespace std;

int matrix[MAX][MAX];
bool inCircle;

inline int read(){
	rg int s=0,f=0;
	rg char c=getchar();
	
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) s=(s<<3)+(s<<1)+(c^48),c=getchar();
	
	return f?-s:s;
	
}

signed main(void){
	int n=read();
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			matrix[i][j]=read();
		}
	}
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			if(!matrix[i][j]){
				matrix[i][j]=3;
			}else{
				break;
			}
		}
	}
	
	for(rg int i=0;i<n;i++){
		for(rg int j=n-1;j>-1;j--){
			if(!matrix[i][j]){
				matrix[i][j]=3;
			}else{
				break;
			}
		}
	}
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			if(!matrix[j][i]){
				matrix[j][i]=3;
			}else{
				break;
			}
		}
	}
	for(rg int i=0;i<n;i++){
		for(rg int j=n-1;j>-1;j--){
			if(!matrix[j][i]){
				matrix[j][i]=3;
			}else{
				break;
			}
		}
	}
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			if(!matrix[i][j]){
				matrix[i][j]=2;
			}
		}
	}
	
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			if(matrix[i][j]==3) matrix[i][j]=0;
		}
	}
	
	for(rg int i=0;i<n;i++){
		for(rg int j=0;j<n;j++){
			cout<<matrix[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```
~~如此毒瘤的解题方式也许只有暑假作为萌新的我才能写出来~~

## BFS 解法

对于本题数据，可能会有圈顶到边上。对于这种数据，我们可以在判断范围时在外圈加一圈0，就可以顺利通过。

具体实现方式请看代码。

```cpp
//AC 14ms,居然比大暴力慢
#include <bits/stdc++.h>

#define ll long long 
#define rg register
#define digit(n) ((n)>='0'&&(n)<='9')

using namespace std;

inline int read(){
	rg int s=0,f=0;
	rg char ch=getchar();
	
	while(not digit(ch)) f|=(ch=='-'),ch=getchar();
	while(digit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	
	return f?-s:s;
}
struct Node{
	int x,y;
};
const int N=35;
queue<Node> q;
const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};
int n;
int vis[N][N];
Node start={1,1};

inline void bfs(){
	q.push(start);
	Node now;
	while(!q.empty()){
		now=q.front();
		q.pop();
//		rg int xx=now.x,yy=now.y;
		Node nxt;
		for(rg int i=0;i<4;i++){
//			int nx=xx+dx[i],ny=yy+dy[i];
			nxt.x=now.x+dx[i];
			nxt.y=now.y+dy[i];
			if(!vis[nxt.x][nxt.y]&&nxt.x>=0&&nxt.x<=n+1&&nxt.y>=0&&nxt.y<=n+1){
//这里存vis是从（1,1）到（n,n) 所以搜索时从（1,1）搜，到(n+1,n+1)停，对于结果并不会有任何影响
				q.push(nxt);
				vis[nxt.x][nxt.y]=3;
			}
		}
	}
}

int main(){
	
	n=read();
	for(rg int i=1;i<=n;i++)
		for(rg int j=1;j<=n;j++)
			vis[i][j]=read();
			
	bfs();
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=n;j++){
			if(!vis[i][j]) vis[i][j]=2;
			else if(vis[i][j]==3) vis[i][j]=0;
		}
	}
	
	for(rg int i=1;i<=n;i++,putchar('\n'))
		for(rg int j=1;j<=n;j++,putchar(' '))
			printf("%d",vis[i][j]);
	
			
	
	return 0;
}
```

# ~~这一定是某谷上最毒瘤的切BFS的方式(其实也并不是通法~~ #

最后惯例 [我的博客](https://www.luogu.org/blog/USSENTERPRISE-juruo/)

---

## 作者：Mubuky (赞：2)

# _**P1162 填涂颜色 题解**_ 

![](https://api.gushi.ci/all.svg)

##### 做完好题写题解是一个好习惯,并且我并没有在题解中找到像我一样优秀（复杂）的思路。

### **感受:**

我做完题（AC）后看了看题解，“我在想什么啊！！！”，原来这道试炼场水题只需要1个dfs/bfs即可，而聪明（呵呵）的我竟然想到了使用3个dfs并且dfs套dfs的做法。

### **思路:**

**第一步，读图**（依题面），我们读入01图。

**第二步**，如同[P1451 求细胞数量](https://www.luogu.org/problem/P1451)一样，我们循环找到01图中为0的点，并进行**dfs1接dfs2**。

**dfs1:** 作用是搜索与外界相连的点（即闭合圈外的点），搜索原理，无脑暴搜。从当前点开始搜索，如果搜索到外面（图的边界以外的点），就停止搜索。搜索时我们假设当前搜索的点就是闭合圈内的点，并把它的赋值从1变成2。因为闭合圈内的点与外界不连通，所以我们在暴力搜索闭合圈内的点时并不会搜索到图边界以外的点，dfs可以正常递归推出。而若dfs搜索到了图边界以外的点，说明这一整片连通的区域都是“0”，即都是闭合圈外的点，我们需要给他们再做一个标记“-1”，表示他们已经被dfs1搜索过并且是闭合圈外的点，于是这就成为了dfs2的任务。

**dfs2:** 我们需要dfs2这个dfs1搜索到的在边界上的点，把与他连通的所有“2”和“0”都赋值成“-1”，因为这个点在闭合圈外，所以dfs2会被“1”所阻挡，不会影响到闭合圈内的“2”。

单纯讲解有些生涩（尤其是遇到想我这样..的算法），我们不妨使用样例解释下。

**（另：事实上dfs1和dfs2在某一时间段内是同时进行的，只是开始时刻上dfs1较dfs2更早一些。）**

```cpp
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

看上面的01图，我们在dfs1之后圈内应该都会变成“2”。但由于dfs1和dfs2同时进行的原因，我们只能展示dfs1和dfs2都停止时的结果,如下（注意区分“1”和“-1”）:

```cpp
-1 -1 -1 -1 -1 -1
-1 -1  1  1  1  1
-1  1  1  2  2  1
 1  1  2  2  2  1
 1  2  2  2  2  1
 1  1  1  1  1  1
```
dfs1和dfs2代码：

```cpp
void dfs2(int x,int y)
{
	f[x][y]=-1;//赋值成“-1”
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&f[nx][ny]==2){
			dfs2(nx,ny);
		}
	}
	return;
}
int dfs1(int x,int y)
{
	f[x][y]=2;//赋值成“2”
	int rettt=0;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx<1||nx>n||ny<1||ny>n){
			dfs2(x,y);
			rettt=-1;
      		break;//快速退出
		}else if(f[nx][ny]==0){
			int ret=dfs1(nx,ny);
			if(ret==-1){
				return -1;
			}
		}
	}
	return rettt;//单一出口
}
```


**第三步，输出**，其实已经结束了，我们发现这个图已经达成了题中所求，只需要：

```cpp
printf("%d ",f[i][j]==-1?0:f[i][j]);
```

**咦？你不是说有3个dfs吗？？**

是的，**dfs3**是用来防止被卡特殊数据（dfs1退出不及时造成的多余的“2”）而构造的暴力函数，其作用就是再次处理一遍圈外的点，循环找“-1”的位置，dfs3这个“-1”的位置，把所有搜索到得“-1”和“2”全部制成“0”，**保证输出的正确性**。

dfs3结果如下：

```cpp
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

dfs3代码：

```cpp
void dfs3(int x,int y)
{
	f[x][y]=0;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&(f[nx][ny]==-1||f[nx][ny]==2)){
			dfs3(nx,ny);
		}
	}
	return;
}
```


接着只需要：

```
printf("%d ",f[i][j]);
```

即可完成题目。

完整代码：

```cpp
#include<cstdio>
int f[31][31];
int dx[5]={0,0,1,0,-1};
int dy[5]={0,-1,0,1,0};
int n;
//状态：1表示墙，0表示未进行过任何搜索的点，2表示已搜索并做暂时标记点，-1表示闭合圈以外的点 
void dfs3(int x,int y)
{
	f[x][y]=0;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&(f[nx][ny]==-1||f[nx][ny]==2)){
			dfs3(nx,ny);
		}
	}
	return;
}
void dfs2(int x,int y)
{
	f[x][y]=-1;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&f[nx][ny]==2){
			dfs2(nx,ny);
		}
	}
	return;
}
int dfs1(int x,int y)
{
	f[x][y]=2;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx<1||nx>n||ny<1||ny>n){
			dfs2(x,y);
			return -1;
		}else if(f[nx][ny]==0){
			int ret=dfs1(nx,ny);
			if(ret==-1){
				return -1;
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&f[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]==0){
				dfs1(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]==-1){
				dfs3(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",f[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

**优化方案：**

虽然我知道这个算法太水基本上是暴力，但是暴力也是可以优化的。

dfs3的用途过小，只是为了避免特殊情况，但却又搜了一遍图，我们可以使用2个dfs，让dfs1在搜索到边界后只把该边界上的点制成“-1”，而并不启用dfs2,。等待dfs1全部走完后再直接启用dfs3，即可双dfs解决问题。

代码：

```cpp
#include<cstdio>
int f[31][31];
int dx[5]={0,0,1,0,-1};
int dy[5]={0,-1,0,1,0};
int n;
void dfs3(int x,int y)
{
	f[x][y]=0;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&(f[nx][ny]==-1||f[nx][ny]==2)){
			dfs3(nx,ny);
		}
	}
	return;
}
void dfs1(int x,int y)
{
	f[x][y]=2;
	for(int i=1;i<=4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx<1||nx>n||ny<1||ny>n){
			f[x][y]=-1;
		}else if(f[nx][ny]==0){
			dfs1(nx,ny);
		}
	}
	return;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&f[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]==0){
				dfs1(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]==-1){
				dfs3(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",f[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

## 给大家看个震惊的东西：
![优化非优化解法对比](https://cdn.luogu.com.cn/upload/pic/71113.png)

**注意所有时空数据都是luogu在没有开O2,没有快读快写，没有常数优化，的情况下实测得出。**

非优化3个dfs用了15ms，且占用空间较大，而优化后2个dfs仅用时10ms,空间占用较小。

**而其他题解的解法多为12-14ms，都没有达到我的10ms的水平！！**

### 所以说，这其实是该题在时间复杂度上的最优解法。

（另：对数据有疑问的同学情搜索我的该题提交记录。）

##  _**By Mubuky**_ 

---

## 作者：ICE_Wol (赞：2)

本题是一道典型的搜索题

dfs和bfs其实都行，然后个人觉得dfs稍微方便一点

思路上其实是要搜索图中的连通块

显然地 我们可以发现：

-  题中给定的被1包围的块都**没有与边界接触**

那么我们就可以通过搜索处于图边界上（x = 1，x = n，y = 1，y = n的点）再对这些点做上标记

最后扫一遍图把标记过的改成0，没标记的改成2，其他照常输出即可

个人觉得楼下在搜边界和转方向两点上处理不太好

关于方向处理有个小技巧

- 分别声明两个数组dx[],dy[]来表示各个方向上行和列的位移，使用时for(int i = 0;i <= 3;i++){x += dx[i];...}即可

其他细节参见代码注释

```
#include<cstdio>
const int maxn = 35;
int field[maxn][maxn];
int n;
struct node{
    int x = 0;int y = 0;
    node(int x = 0,int y = 0):x(x),y(y){} //构造函数,可以使用node(a,b)来创建一个node型变量并带有初值
};
int dx[] = {0,1,0,-1};//刚刚提到的方向数组
int dy[] = {-1,0,1,0};
void dfs(int x,int y){
    if(x > n || x < 1 || y > n || y < 1)return;//出界
    if(field[x][y] > 0)return;//被访问过或者是墙壁
    field[x][y] = 3;//标记
    for(int i = 0;i <= 3;i++)
        dfs(x + dx[i],y + dy[i]);//递归继续搜索
}
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++)
            scanf("%d",&field[i][j]);
    for(int i = 1;i <= n;i++){//搜边界,虽然这样写四个角会重复搜几次但无伤大雅而且十分方便,可读性也很强
        dfs(1,i);
        dfs(n,i);
        dfs(i,1);
        dfs(i,n);
    }
    for(int i = 1;i <= n;i++){//最后的处理
        for(int j = 1;j <= n;j++){
            if(field[i][j] == 3)
                field[i][j] = 0;
            else if(!field[i][j])
                field[i][j] = 2;
            if(j != n)printf("%d ",field[i][j]);
            else printf("%d\n",field[i][j]);//打印解,注意最后一列数字后没有空格
        }
    }
    return 0;
}

```

---

## 作者：wmxwmx (赞：2)

看了几页题解，貌似都在用**搜索**做这道题。

那么在这里就谈下一个思路新奇的做法:

## 并查集

这个方法的**好处**就在于：**容易写**（重点）+不论是一个还是**几个**闭合区间都可以搞定。


1. 大概就是把outside当成一个node.

2. 然后读入的时候**往左上相同node**（假如在边界上就算上outside-node）union集合.

3. 最后输出检查一下这个**0有没有和outside在一个集合**并改2就好了。

4. 还有就是**1的node不用参与union**。


放个自己写的Pascal代码。(洛谷显示pascal总是有问题不知道为啥,姑且用C的高亮吧,聊胜于无)


```c
const maxn=30;
    maxn2=900;
var n,i,j,cnt:longint;
    mtx:array[1..maxn,1..maxn]of longint;
    fa:array[0..maxn2]of longint;

function find(x:longint):longint;
begin
    if fa[x]=x then exit(x);
    fa[x]:=find(fa[x]);
    exit(fa[x]);
end;

procedure union(x,y:longint);
begin
    fa[find(x)]:=find(y);
end;

begin
    readln(n);
    cnt:=0;
    for i:=1 to n do
    for j:=1 to n do
    begin
        inc(cnt);
        read(mtx[i,j]);
        if mtx[i,j]=1 then continue;
        fa[cnt]:=cnt;
        if (i=1)or(j=1)or(i=n)or(j=n) then
        union(cnt,0);
        if (i>1)and(mtx[i,j]=mtx[i-1,j]) then
        union(cnt,cnt-n);
        if (j>1)and(mtx[i,j]=mtx[i,j-1]) then
        union(cnt,cnt-1);
    end;
    cnt:=0;
    for i:=1 to n do
    begin
        for j:=1 to n do
        begin
            inc(cnt);
            if (mtx[i,j]=0)and(find(cnt)<>find(0)) then
            mtx[i,j]:=2;
            write(mtx[i,j],' ');
        end;
        writeln;
    end;
end.
```

---

## 作者：leozhudd (赞：2)

一种另类的解法（至少题解里没有dalao和我一样）

**正面硬杠**，

读入MAP后寻找出第一个在“围墙”里的0，从这个0开始bfs即可！


            
            
        



        
        
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
int n;
int map[32][32];
void bfs(int x,int y);
struct node{
    int x;
    int y;
};
int main()
{
    cin>>n;
    int i,j;
    int flag=0,fllag=0;
    int startx,starty;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            cin>>map[i][j];
    for(i=2;i<=n;i++)               //开始寻找第一个围墙里的0
    {    
        for(j=1;j<n;j++)
            if(map[i][j]==1 && map[i][j+1]==0) {flag=j;    
        for(j=flag;j<n;j++) 
            if(map[i][j]==0 && map[i][j+1]==1) fllag=j;
        }
        if(fllag!=0) 
        {startx=i;starty=fllag;break;}
    }
    //查找完毕（startx,starty），开始BFS！
    map[startx][starty]=2;
    bfs(startx,starty);
    for(i=1;i<=n;i++)
    {    for(j=1;j<=n;j++)
            cout<<map[i][j]<<" ";
        cout<<endl;
    }
//    printf("\n%d %d",startx,starty);
    return 0;
}
void bfs(int x,int y)
{
    queue<node>Q;
    node vs;
    vs.x=x;vs.y=y;
    Q.push(vs);
    int nnext[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    int tx,ty,flag;
    while(!Q.empty())
    {
        for(int k=0;k<4;k++)
        {
            tx=Q.front().x+nnext[k][0];
            ty=Q.front().y+nnext[k][1];
            if(tx<1||ty<1||tx>n||ty>n||map[tx][ty]==1||map[tx][ty]==2) continue;
            vs.x=tx;vs.y=ty;Q.push(vs);
            map[tx][ty]=2;
        }
        Q.pop();
    }
}
```

---

## 作者：ShawnZhou (赞：2)

挺简单的一道BFS题。

这道题要求我们把用1围成的圈里面的0改成2，可是这不好办，因为我们很难判定一个0到底是不是在圈里，那怎么办呢？

涂反色就可以啦！

我们可以考虑给圈外面的0涂色，在最后输出时判定它是不是涂过色，如果是就把颜色“擦掉”，如果不是那就“再涂上”。

这样做为什么正确呢？因为全局数组的初值默认是0，正好和未涂色的格子是一样的值，而搜索时判断一个0是不是在圈外就很好办了。

在搜索时判断，如果走到某个值是1的格子那就说明撞墙了，同时用vis数组记录走过的点避免重复搜索，这样搜索完毕就可以把所有圈外的0都涂成2，最后输出时进行“反色”操作就可以了。

下面是我的代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<utility>
#include<queue>
#include<vector>
#include<map>
#include<stack>
#define uint unsigned int
#define ll long long
#define ull unsigned lls
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define INF 2147483647
#define LINF 9999999999
#define maxn 33
#define maxm 23333333
#define ms(l) memset(l,0,sizeof(l))
#define chk cout << "ok" << endl;
using namespace std;
struct node{
    int x;
    int y;
};//使用队列时把每个节点的x y看作一个整体，这样稍微方便一点
const int dx[]={0,1,-1,0};
const int dy[]={1,0,0,-1};//dx dy用来进行状态转移
int n;
int a[maxn][maxn];//地图
bool vis[maxn][maxn];//判断某个格子是否走过
bool check(int x,int y){
    if (x>=0 &&x<=n+1 &&y>=0 &&y<=n+1)
        return true;
    return false;
}
/*
这里我要说一下这个check函数，它用来判断我们的行走是否合法（即判断越界），但这里要注意的是我们的右边界和下边界不是n而是n+1
如果你把边界设成了n，那么搜索时就不会把右边和下边空档里的0涂成2，即程序认为这里“越界”了，这样显然不符合题意，会WA三个点。
*/
void bfs(int x,int y){
    queue<node> q;
    node s;
    s.x = x;
    s.y = y;
    q.push(s);
    a[s.x][s.y]= 2;
    vis[s.x][s.y] = true;
    while (!q.empty()){
        node u = q.front();
        q.pop();
        for (int i=0;i<4;i++){
            node w;
            w.x = u.x + dx[i];
            w.y = u.y + dy[i];
            if (check(w.x,w.y)){
                if (a[w.x][w.y]==0 && !(vis[w.x][w.y])){
                    //chk
                    vis[w.x][w.y] = true;
                    a[w.x][w.y] = 2;
                    q.push(w);
                }

            }

        }
    }

}
/*
平淡无奇的BFS主过程。
*/
int main(){
    cin >> n;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            cin >> a[i][j];
    bfs(0,0);//理论上讲从圈外任何一个0点开始搜都是可以的，毕竟都能涂完整个外面的0
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            switch(a[i][j]){
                case 0:
                    cout << "2 ";
                    break;
                case 1:
                    cout << "1 ";
                    break;
                case 2:
                    cout << "0 ";
                    break;

            }
        }
        cout << endl;
    }
    return 0;
}
```
用洛谷这么长时间，还是第一次在这写题解，写的不好，嘿嘿，各位见谅。


---

## 作者：Toxic_Obsidian (赞：2)

我看了看大牛们的题解。。。感觉想得有点多，其实完全只用一个全局变量，四个局部变量就可以了

以下是c++代码，为了省空间，直接std::cin了

```cpp
#include <iostream>
short puzzle[32][32];
void dfs(short a,short b){
    if(a>=0&&b>=0&&a<=32&&b<=32){
        if(puzzle[a][b]==0) puzzle[a][b]=-1;
        if(puzzle[a+1][b]==0) dfs(a+1,b);
        if(puzzle[a][b+1]==0) dfs(a,b+1);
        if(a==0||b==0){}
        else{
            if(puzzle[a-1][b]==0) dfs(a-1,b);
            if(puzzle[a][b-1]==0) dfs(a,b-1);
        }
    }
}
int main(){
    short n;
    std::cin>>n;
    for(short i=1;i<=n;i++)
    {
        for(short j=1;j<=n;j++)
        {
            std::cin>>puzzle[i][j];
        }
    }
    dfs(0,0);
    for(short i=1;i<=n;i++)
    {
        for(short j=1;j<=n;j++)
        {
            if(puzzle[i][j]==-1) {puzzle[i][j]=0;}
            else if(puzzle[i][j]==0) puzzle[i][j]=2;
            std::cout<<puzzle[i][j]<<" ";
        }
        std::cout<<std::endl;
    }
    return 0;
}
```

---

## 作者：chenyy (赞：2)

BFS
```cpp

#include <cstdio>
#include <queue>
using namespace std;
struct Pos{int x,y;};
Pos NewPos(int x,int y){
    Pos temp;
    temp.x = x;
    temp.y = y;
    return temp;
}
int map[32][32] = {0};
bool vis[32][32] = {0};
int n;
void fill(Pos p){//从p点向外广搜
    const int nx[] = {-1,0,1,0};
    const int ny[] = {0,-1,0,1};
    if (vis[p.x][p.y]) return;//如果被搜索过，那么不必搜索
    bool visited[32][32] = {0};
    //visited记录本次搜索中访问过的所有点，并填写到vis中，减少再次搜索的次数，节约时间
    visited[p.x][p.y] = true;
    queue <Pos> s;//定义一个队列为s，其元素的类型为自定义的Pos
    s.push(p);//把当前的这个点先放入队列中
    while(!s.empty()){//当队列空的时候，也就不必再搜了
        Pos now = s.front();//把这个点作为一个临时变量
        s.pop();//让这个点出队列，因为这个点已经在扫描了
        for (int i=0;i<4;i++){
            int x = now.x + nx[i];
            int y = now.y + ny[i];
            if (x == 0 || y == 0 || x == n+1 || y== n+1) return;//扫到边界，也就意味着这个点可以到达边界，因此这块区域不必填充
            if (x >0 && x <= n && y > 0 && y <= n){//数组没有越界
                if (!visited[x][y] && map[x][y] != 1){//没有被扫描过而且这个点不是围栏
                    visited[x][y] = true;//标记这个点已经在队列中，这样避免某个点扫描两次的问题
                    s.push(NewPos(x,y));//把这个点进队
                }
            }
        }
    }
    for (int i=0;i<=n;i++)
        for (int j=0;j<=n;j++){
            if (visited[i][j]){
                vis[i][j] = true;//把本次扫描时经过的点在vis中标记，防止重复扫描耗时
                map[i][j] = 2;//填充2
            }
        }
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            scanf("%d",&map[i][j]);
    //输入数据结束 
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (map[i][j] == 0)fill(NewPos(i,j));
    //搜索结束 
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++) printf("%d ",map[i][j]);
        printf("\n");
    }//输出 
    return 0;
}

```

---

## 作者：zzjzxh (赞：2)

楼楼上把所有初始化为2启发了我。。。

读入地图时，先判断，如果是1就读入1，如果是0就读入2.这样便达到了除一之外都设为2的效果。

bfs不解释，但在搜索的方式上做了些手脚。

如果搜索到边界就设为0，那么为什么我们不从边界开始往里面搜呢？

那么四条边，就搜这四条边上的点。如果该点是1或者0就不搜，2就搜

思想就是如此，下面附上代码（衷心希望各位不要复制粘贴！别自己骗自己！）

```delphi

const
  dx:array[1..4] of longint=(0,0,1,-1);
  dy:array[1..4] of longint=(1,-1,0,0);
var
  i,j,n:longint;
  map:array[-1..32,-1..32] of longint;
  procedure init;
  var
    i,j,x:longint;
  begin
    read(n);
    for i:=1 to n do
      for j:=1 to n do
      begin
        read(x);
        if x=1 then map[i,j]:=1 else map[i,j]:=2;
      end;
  end;

  procedure bfs(xx,yy:longint);
  var
    head,tail,x,y,i,j:longint;
    a:array[0..901,1..2] of longint;
  begin
    a[1,1]:=xx;
    a[1,2]:=yy;
    head:=0;
    tail:=1;
    while head<tail do
    begin
      inc(head);
      for i:=1 to 4 do
      begin
        x:=a[head,1]+dx[i];
        y:=a[head,2]+dy[i];
        if (map[x,y]=2) and (x<=n) and (x>0) and (y<=n) and (y>0) then
        begin
          inc(tail);
          a[tail,1]:=x;
          a[tail,2]:=y;
          map[x,y]:=0;
        end;
      end;
    end;
  end;
begin
  init;
  for j:=1 to n do
  begin
    if map[j,1]=2 then bfs(j,1);
    if map[j,n]=2 then bfs(j,n);
    if map[1,j]=2 then bfs(1,j);
    if map[n,j]=2 then bfs(n,j);
  end;
  for i:=1 to n do
  begin
    for j:=1 to n do
      write(map[i,j],' ');
    writeln;
  end;
end.

```

---

## 作者：plazum (赞：2)

楼上的先把0都置为2启发了我……

首先，把所有0置为2，然后遍历四条边界上的点，每当发现2就从这点开始广搜，把到达的都置为0。

话说2-1=1，2-0=2呢……这真是极好的，连判断都省了……

```cpp

#include<iostream>
using namespace std;
const int dx[]={0,1,0,-1};
const int dy[]={1,0,-1,0};
int n,i,j,a[30][30],xy[28*28][2];
void bfs(int x,int y)
{
    int head=0,tail=1,tx,ty;
    a[x][y]=0;
    **xy=x;xy[0][1]=y;
    while(head<tail){
        for(int i=0;i<4;i++){
            if((tx=xy[head][0]+dx[i])>=0&&tx<n&&(ty=xy[head][1]+dy[i])>=0&&ty<n&&a[tx][ty]==2)
                a[tx][ty]=0,xy[tail][0]=tx,xy[tail][1]=ty,tail++;
        }
        head++;
    }
}
int main()
{
    cin>>n;
    for(;i<n;i++)for(j=0;j<n;j++)cin>>a[i][j],a[i][j]=2-a[i][j];
    for(i=0;i<n-1;i++){
        if(a[0][i]==2)bfs(0,i);
        if(a[i][n-1]==2)bfs(i,n-1);
        if(a[n-1][n-1-i]==2)bfs(n-1,n-1-i);
        if(a[n-1-i][0]==2)bfs(n-1-i,0);
    }
    for(i=0;i<n;i++){for(j=0;j<n;j++)cout<<a[i][j]<<' ';putchar('\n');}
    
    return 0;
}

```

---

## 作者：xayata_ (赞：2)

思路简单 ：从最外围all点开始广搜，遇到1就不加入队列，最后将所有未搜到的点打印为2即可







    
        
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
const int N=31;
const int xd[]={0,1,0,-1};
const int yd[]={-1,0,1,0};
struct node{
    int x,y;
}now,nxt,pus;
int a[N][N];
queue<node>q;
int n;
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
inline void bfs(int x,int y)
{
    now.x=x;
    now.y=y;
    q.push(now);
    while(!q.empty())
    {
        nxt=q.front();
        q.pop();
        a[nxt.x][nxt.y]=3;
        for(int i=0;i<4;i++)
        {
            int xx=nxt.x+xd[i];
            int yy=nxt.y+yd[i];
            if(!a[xx][yy]&&xx>=0&&xx<=n&&y>=0&&y<=n)
            {
                pus.x=xx;
                pus.y=yy;
                a[xx][yy]=3;
                q.push(pus);
            }
        }
    }    
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a[i][j]=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(!a[i][j]&&(i==1||i==n||j==1||j==n))
                bfs(i,j);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==3)
                printf("0 ");
            else 
                if(a[i][j]==1)
                    printf("1 ");
                else 
                    printf("2 ");
        }
        printf("\n");        
    }    
    return 0;
}
```
/\*
6
0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 0 0 1

1 1 0 0 0 1

1 0 0 0 0 1

1 1 1 1 1 1

5
0 0 0 0 0

0 0 0 0 0

1 1 1 1 1

1 0 0 0 1

1 0 0 0 1

10
0 0 0 0 0 0 0 0 0 0

0 0 1 1 1 0 0 0 1 1

0 1 1 0 1 1 0 1 1 1

1 1 0 0 0 1 1 1 0 1

1 0 0 0 0 0 1 1 0 1

1 0 0 0 0 0 1 1 1 1

1 0 0 0 0 1 1 0 0 0

1 1 0 0 0 1 1 0 0 0

0 1 1 0 1 1 0 0 0 0

0 0 1 0 1 0 0 0 0 0

\*/

---

## 作者：睡在墙上的猫 (赞：2)

###先把所有的都变成2（除了原来是1的）

###然后从周围开始搜索

###一遇到1就返回

###最后剩下的就是答案

```cpp
#include<iostream>
using namespace std;
int a[100][100],n; 
void dfs(int x,int y)
{
    if (a[x][y]==2) a[x][y]=0;//如果是二就变成0
    else return;//否则退出
    if (x-1>=1&&x-1<=n&&a[x-1][y]==2)//如果不越界就往下搜索四个方向
    {
        dfs(x-1,y);
    }
    if (x+1>=1&&x+1<=n&&a[x+1][y]==2)
    {
        dfs(x+1,y);
    }
    if (y-1>=1&&y-1<=n&&a[x][y-1]==2)
    {
        dfs(x,y-1);
    }
        if (y+1>=1&&y+1<=n&&a[x][y+1]==2)
    {
        dfs(x,y+1);
    }
    return;
}
int main()
{
    int i,j;
    cin>>n;
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=n;j++) 
        {
            cin>>a[i][j];
            if (a[i][j]==0) a[i][j]=2;//全变成0
        }
    } 
//因为封闭的区域可能有很多，所以要用循环
    for(i=1;i<=n;i++)//四个边
    {
        dfs(n,i);
        dfs(i,n);
        dfs(1,i);
        dfs(i,1);
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=n;j++)
        {
            cout<<a[i][j]<<" ";
        } 
        cout<<endl;
    }
    return 0;
}

```

---

## 作者：王鹏PRO (赞：1)

1. 数据的数量N<=30,那么怎么解题都是可以通过的
2. 想要尝试一下使用并查集进行解题，提供一种不同的思路
3. 并查集最好用的一个功能是考察连通性，由此我们可以这样破题

**总体思路：中间的格子（值为0）只要不与边缘格子（值为0）连通，就可以输出为2**

- 使用data[x][y][z]进行数据存储，x y是二维坐标，z[0]存储原始值(0或1)， z[1]保存父节点的索引值(x*n+y), z[2]存储中间值(-1,0,1)

- 定义：边缘格子，坐标x=0或x=n-1或y=0或y=n-1（个人习惯 0 ~ n-1，也可以使用1 ~ n）
- 我们的目标是找出被1（z[0]）包围的0（z[0]），那么首先要排除那些值是0的边缘格子，把他们的值设为-1（z[2]）
- 将值为0的格子进行Union操作，将相互连通的0（z[0]）的父节点（z[1]）设置成这些格子z[2]值最小的那个格子的z[1]
- 遍历格子，当格子的z[0]==0 && 其父格子的z[2]!=-1时输出2，否则输出原始z[0]


- 最后是代码
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import static java.lang.Math.min;
public class Main {
    private static int n;
    private static final int[][][] data = new int[30][30][3];
    private static final int[][] offset = new int[][]{{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
    public static void main(String[] args) throws Exception {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        in.nextToken();
        n = (int) in.nval;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                in.nextToken();
                data[i][j][0] = (int) (in.nval);
                data[i][j][1] = i * n + j;
                data[i][j][2] = (int) (in.nval);
                if (data[i][j][0] == 0) {
                    for (int k = 2; k < 4; k++) {
                        int nextX = i + offset[k][0];
                        int nextY = j + offset[k][1];
                        if (nextX < 0 || nextX >= n) data[i][j][2] = -1;
                        else if (nextY < 0 || nextY >= n) data[i][j][2] = -1;
                    }
                    for (int k = 0; k < 2; k++) {
                        int nextX = i + offset[k][0];
                        int nextY = j + offset[k][1];
                        if (nextX < 0 || nextX >= n) data[i][j][2] = -1;
                        else if (nextY < 0 || nextY >= n) data[i][j][2] = -1;
                        else {
                            if (data[nextX][nextY][0] == 0) union(i, j, nextX, nextY);
                        }
                    }
                }
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (data[i][j][0] == 0) {
                    int p = find(i, j);
                    int x = p / n;
                    int y = p % n;
                    if (data[x][y][2] == -1) System.out.print(data[i][j][0] + " ");
                    else System.out.print("2 ");
                } else {
                    System.out.print(data[i][j][0] + " ");
                }
            }
            System.out.println();
        }
    }

    private static int find(int x, int y) {
        int index = x * n + y;
        if (index == data[x][y][1]) return index;
        return data[x][y][1] = find(data[x][y][1] / n, data[x][y][1] % n);
    }

    private static void union(int x1, int y1, int x2, int y2) {
        int p1 = find(x1, y1);
        int p2 = find(x2, y2);
        if (p1 == p2) return;
        int p1x = p1 / n;
        int p1y = p1 % n;
        int p2x = p2 / n;
        int p2y = p2 % n;
        int min1 = min(data[x1][y1][2], data[x2][y2][2]);
        int min2 = min(data[p1x][p1y][2], data[p2x][p2y][2]);
        int min = min(min1, min2);
        if (p1 > p2) {
            data[p1x][p1y][1] = p2;
        } else {
            data[p2x][p2y][1] = p1;
        }
        data[p1x][p1y][2] = min;
        data[p2x][p2y][2] = min;

    }
}

```


---

## 作者：WTing (赞：1)

### 题意解读

其实就是地图染色题，它的思路就是想把闭合区域内的图染成另外一种颜色，其他的都不变，如果能确定闭合区域，然后以任何一个点为起点，进行深度遍历或者广度遍历，此题都可以做！

而且效率上可以说都是差不多的，因为只需要遍历，不需要搜索！

但是我们会发现确定一个闭合区域并不简单，所以我们做了一个逆向处理！

![](https://cdn.luogu.com.cn/upload/pic/72061.png)

原始示意图


然后我们把所有的0点都处理成2点

![](https://cdn.luogu.com.cn/upload/pic/72062.png)

处理后示意图

值得注意的是，其实我针对这个图，把原来N×N的图变成了(N+2)×(N+2)的图，为什么这么做呢，因为你这样做了之后，N×N外圈非闭合的2点，会因为(N+2)×(N+2)外圈的2点肯定成为一个连通图，这个时候，我们就爽歪歪的开始了深度遍历或者广度遍历！

### 示例程序

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[35][35],vis[35][35];
struct node{
	int x;
	int y;
};
queue<node> que;
int cx[4]={0,1,0,-1},
    cy[4]={1,0,-1,0};
int main(){	
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
				cin>>a[i][j];
	for(int i=0;i<=n+1;i++)
		for(int j=0;j<=n+1;j++)
			if(a[i][j]==0)
				a[i][j]=2;//0点处理成2点，并扩大区域
	node p1,p2;
	p1.x=0,p1.y=0;//处理队列头
	a[0][0]=0;vis[0][0]=1;//处理起点
	que.push(p1);
	while(!que.empty()){
		p2=que.front();
		que.pop();
		for(int i=0;i<=3;i++){
			int tx,ty;
			tx=p2.x+cx[i];
			ty=p2.y+cy[i];
			if(a[tx][ty]==1||tx>n+1||ty>n+1||tx<0||ty<0)
				continue;
			if(a[tx][ty]==2&&vis[tx][ty]==0){
				vis[tx][ty]=1;
				a[tx][ty]=0;
				p1.x=tx;p1.y=ty;
				que.push(p1);
			}
		}		
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			cout<<a[i][j]<<" ";
		cout<<endl;
		}
	return 0;
}
```

---

## 作者：20160161simon (赞：1)

# BFS水题

这道题第一眼感觉很麻烦，判断是在圈内还是在圈外有点恶心，想了下发现只要在最外围加一圈就行了，这样从（0,0）开始总是能遍历完圈外的所有点


------------

具体就拿范例来说

0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 0 0 1

1 1 0 0 0 1

1 0 0 0 0 1

1 1 1 1 1 1

这样一张图很难去遍历圈内的点，想了下要加个是否与边界触碰的判断，懒得写这个判断的人注意了，只要把图变成下面这样就行了

0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0

0 0 0 1 1 1 1 0

0 0 1 1 0 0 1 0

0 1 1 0 0 0 1 0

0 1 0 0 0 0 1 0

0 1 1 1 1 1 1 0

0 0 0 0 0 0 0 0

这样我们就很好遍历外围的点了，只要把外围的点找出来，剩下除1以外的点就一定是圈内的点了，代码如下

```cpp
#include <bits/stdc++.h>
#define N 110
#define MAX 1000010
using namespace std;
typedef long long ll;
typedef unsigned long long ull; 
ll read()
{
	char c=getchar();bool flag=0;ll x=0;
	while(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return flag?-x:x;
}//读入优化，可以直接用scanf输入 
ll x[MAX],y[MAX],a[N][N],b[N][N];//因为x,y是两个队列所以数组要开大 
int main()
{
	//读入 
	ll n=read();
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=n;j++) b[i][j]=a[i][j]=read();
	}
	x[0]=0,y[0]=0;//起点在(0,0) 
	ll tail=1;
	//bfs，平时少点STL，对算法理解更深 
	for(ll head=0;head<tail;head++)
	{
		ll ax[4]={0,1,0,-1};//x的四个方向 
		ll ay[4]={1,0,-1,0};//y的四个方向 
		for(ll i=0;i<4;i++) 
		{
			ll dx=ax[i]+x[head],dy=ay[i]+y[head];
			if(dx>=0&&dx<=n+1&&dy>=0&&dy<=n+1&&b[dx][dy]==0)//判断是否在圈外 
			{
				b[dx][dy]=1;//有的话把这个设为1，表示走过，即vis数组 
				x[tail]=dx;
				y[tail]=dy;
				tail++;//把新坐标加在队尾 
			}
		}
	}
	//输出 
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=n;j++) 
		{
			if(b[i][j]==1) printf("%lld ",a[i][j]);//如果b[i][j]==1说明不是原本的1就是圈外的0 
			else printf("2 ");//否则则在圈内 
		}
		printf("\n");
	}
}

```
码风不是很好看，大家凑合着看看吧。。。

---

## 作者：yizixuan_Kitty (赞：1)

	#include<iostream>
	#include<cstdio>
	using namespace std;
	int map[31][31];
	bool flag[5],vis[31][31]; //flag用来储存0的四周是否都有1 
                          //vis用于广搜，判断这个点是否更改过 
	int q[1001][2],h=1,t;     //队列 
	int fx[5][2]={{0,0},{1,0},{-1,0},{0,1},{0,-1}};//枚举方向 
	int main()
	{
    	//输入 
    	int n;
    	cin>>n;
    	for(int i=1;i<=n;i++)
      		for(int j=1;j<=n;j++)
        		cin>>map[i][j];
    //枚举每个点，判断它的四周是否都有1 
    	for(int i=1;i<=n;i++)
    	{
        	for(int j=1;j<=n;j++)
        	{
          	if(!map[i][j])  //如果这个点不是1，那么枚举四周，算是个剪枝 
            for(int k=1;k<=n;k++)
            {
                if(i+k<=n&&map[i+k][j]==1)
                  flag[1]=1;
                if(j+k<=n&&map[i][j+k]==1)
                  flag[2]=1;
                if(i-k>=1&&map[i-k][j]==1)
                  flag[3]=1;
                if(j-k>=1&&map[i][j-k]==1)
                  flag[4]=1;  
            }
            if(flag[1]&&flag[2]&&flag[3]&&flag[4]) //如果四周都有1，那么标记，退出循环 
            {
                q[++t][0]=i, q[t][1]=j;
                break;
            }
            for(int k=1;k<=4;k++) //如果不是，清空flag 
              flag[k]=0;
        }
        if(q[t][0])
          break;
    }
    map[q[t][0]][q[t][1]]=2; //把第一个被找到的点变成2 
    while(h<=t) //广搜 
    {
        for(int i=1;i<=4;i++) //枚举四个方向 
        {
            int x=q[h][0]+fx[i][0];
            int y=q[h][1]+fx[i][1];
            if(x<=n&&x>=1&&y<=n&&y>=1&&map[x][y]!=1&&!vis[x][y]) //如果没有越界，且不是1，且没有被访问过 
            {
                map[x][y]=2;//把它变成2         
                q[++t][0]=x;//入队 
                q[t][1]=y;
                vis[x][y]=1;//标记这个点被访问过 
            }
        }
        ++h; //取出队首 
    }
    //输出 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
          cout<<map[i][j]<<" ";
        cout<<endl;
    }  
    
    return 0;
}

---

## 作者：Dilute (赞：1)

#令人窒息的DFS操作（很容易想到但不知为何没人写的算法）

##这道题我看踢界的各位大佬们都是在想如何判定是否是闭合圈，但是我想应该判定**不是**闭合圈应该更加方便一些

##那么具体就是这么想的：

## - 如果一个圈子四周遇到了边界，那么它一定不是个闭合全

## - 如果一个圈子四周没有边界，那么它一定是个闭合圈

## - 然后我们对每一个点进行DFS的染色操作

## - 那么我们只需要找到一个圈子它四周没有边界，那么就行了

###（边界指的是x、y越界的情况）

## - 时间复杂度$O(n^2)$？也许是的

##具体代码实现如下：

```cpp
#include<bits/stdc++.h> // 万能头文件 

using namespace std;

bool used[40][40]; // 判断这个点有没有被搜索到过 
int m[40][40], n;  // m表示地图，n的作用RT 
bool flg; // 判断有没有搜到边界 
int opt[10][3] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; // 这个是拿来方便上下左右的 

void dfs(int x, int y){ // dfs函数 
    if(x > n || x < 1 || y > n || y < 1){ // 如果遇到了越界的情况 
        flg = true;
        return ;
    }
    if(used[x][y]) return ; // 如果这个点已经被搜过了，return掉 
    used[x][y] = true; // 将当前搜索到的点设为已经搜索过 
    for(int i = 0; i < 4; i++){ // 向四个方向拓展 
        dfs(x+opt[i][0], y+opt[i][1]); 
    }
    m[x][y] = 2; // 将地图上的当前点设为2（如果不合法后面会重新改成0）, 
}

int main(){
    memset(used, 0, sizeof(used));
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            scanf("%d", &m[i][j]);
            if(m[i][j] == 1) used[i][j] = true;
        }
    } // 读入就不多讲了 
    for(int i = 1; i <= n; i++){ // 扫一遍所有的点 
        for(int j = 1; j <= n; j++){
            if(used[i][j]) continue; // 保证扫到的都是没扫过的点 
            flg = false; // 初始化 
            dfs(i, j); // 染色 
            if(flg){ // 如果周围碰到了边 
                for(int u = 1; u <= n; u++){
                    for(int v = 1; v <= n; v++){
                        if(m[u][v] == 2) m[u][v] = 0;
                    }
                } // 将所有的2改为0 
                continue; // 进入下一个循环 
            }
            // 那么下面是只有在没有碰到边缘（即扫出答案）的情况下 
            for(int u = 1; u <= n; u++){ // 输出 
                for(int v = 1; v < n; v++){
                    printf("%d ", m[u][v]);
                }
                printf("%d\n", m[u][n]);
            }
            return 0; // 直接退出程序（都有答案了扫它干嘛？） 
        }
    }
}
```

---

## 作者：Demons (赞：1)

这个题其实是在找用1围成的联通块并且改成2

## 怎么做呢？

发现了一个结论，内圈有0的时候，1的排列是有“棱角”的

```cpp
0 0 1 1 1 0
0 1 1 0 1 1
0 1 0 0 0 1
```
这是一部分图，第二行的第四个位是一个三面被1包围的0，如果1第一次出现并且连续出现了两次，这个地方就可以确认是棱，如

**0 1 1**

**0 ? ?**

如果这是图最上面的一部分，很容易想到第一个？一定是1（要满足1闭合），第二个？一定是0（出现这样的结构说明里面肯定存在被包围的0），可能不像上面画的只有一个0被包围，也可能有多个..

```cpp
0 0 1 1 1 1
0 1 1 0 0 1
0 1 0 0 0 1
```
总之结论是成立的，可以通过一个1的棱直接进入联通块，然后就可以以这个点为起始点进行bfs修改

bfs到的点值就被修改了，因此不需要标记是否访问过..

代码是这样的

```cpp
#include "cstdlib"
#include "iostream"
#include "cstdio"
#include "cstring"
#include <string>
#include <queue>//队列
using namespace std;
class Point//结构体，用来在队列中储存要bfs的点
{
public:
    int x, y;
    Point(int i, int j) :x(i), y(j){}
    Point(){}//无参构造方法
};
int puz[32][32];//图
queue<Point>q;//bfs的队列
const int l[4] = { 1, -1, 0, 0 };//这两个数组是用来四个方向找连通的
const int r[4] = { 0, 0, 1, -1 };
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)for (int j = 1; j <= n; j++)
    {
        scanf("%d", &puz[i][j]);//读入图
    }
    for (int i = 1; i <= n; i++)for (int j = 1; j <= n; j++)
    {
        if (puz[i][j - 1] && puz[i][j])//省略了==1，这一步就是从上到下找两个连在一起的1，也就是棱
        {
            q.push(Point(i + 1, j));//找到一个就放入队列，然后结束寻找（如果不结束貌似会导致有可能跳出联通块？）
            break;
        }
        if (!q.empty())break;//也是为了跳出寻找设计的，有一个元素就跳出寻找
    }
    register Point p;
    register int a, b;//寄存器玄学加速（虽然数据很小...下来五个点都是0ms）
    while (!q.empty())     //bfs
    {
        p = q.front(); q.pop();
        a = p.x; b = p.y;
        puz[a][b] = 2;
        for (int i = 0; i<4; i++)//四个方向找连通的0
        {
            if (puz[a + l[i]][b + r[i]] == 0)
            {
                q.push(Point(a + l[i], b + r[i]));//有0就加入bfs队列
                puz[a + l[i]][b + r[i]] = 2;//有可能会修改多次(bfs到这个点时还会被改为2)，但是能避免重复加入队列
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cout << puz[i][j] << " ";//输出
        }
        cout << endl;
    }
    return 0;
}
```

---

## 作者：misayap (赞：1)

//一道很直观的搜索题，要与图像紧密联系，可以想象成一块以0组成的空地上有一道环形的以1组成的围墙，要将墙内的空地变为2，首先

//要将墙内空地与墙外空地区分开来，这个可以用bool实现，那么写搜索时以防围墙将开始搜索的顶角隔开，要从四个顶角分别向内推进，

//最后将bool为0且值为0的点赋值为2即可，注意按矩阵输出。附上橙名蒟蒻代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
bool flag[1005][1005]={{0},{0}};
int n;
int a[1005][1005];
int fx[4]={0,1,-1,0};
int fy[4]={1,0,0,-1};
void dfs(int x,int y);
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        dfs(i,1);//从四个角搜索保证将1组成的围墙 
        dfs(1,i);//以外地区的bool变为1 
        dfs(i,n);
        dfs(n,i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==0&&flag[i][j]!=1)//即1组成围墙内的0，墙外的0flag=1
                a[i][j]=2; //变为2 
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
void dfs(int x,int y)
{
    if(a[x][y]==1||flag[x][y]==1)//碰到1组成的围墙返回 
        return;
    else if(x>=1&&x<=n&&y>=1&&y<=n)//判断是否在输入的图内 
    {
        flag[x][y]=1;//标记 
        for(int i=0;i<4;i++)
        {
            dfs(x+fx[i],y+fy[i]);
        }
    }
}
```

---

## 作者：觞羰涙 (赞：1)

#来一个dfs解法

本解法为dfs但无回溯，时间和bfs就差不多了，比bfs好理解也更好写

其实和细胞这道题有异曲同工之妙 注：水王大法好！！！

####
```cpp
//moon beautiful!!!
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<stack>
#include<queue>
#include<iomanip>
bool l=false;//标记是否为外围0 
int n,a[31][31],v[31][31],k1[4]={0,1,0,-1},k2[4]={1,0,-1,0},t=0;
using namespace std;
void sexy(int x,int y)//对每坨连在一起的0做标记 
{
    v[x][y]=t;//标记到达 
    if(x-1<1||x+1>n||y-1<1||y+1>n) //如果一坨0有一个在边界说明此片0不被1包围，此思路可能不好想 
    l=true;//记录 
    for(int i=0;i<4;i++)
    {
        int nx=x+k1[i];
        int ny=y+k2[i];//向四方扩展 
        if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!a[nx][ny]&&!v[nx][ny])//正常dfs，做标记 
        sexy(nx,ny);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    cin>>a[i][j];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
      {
        if(!a[i][j]&&!v[i][j])
        {
            t++;//b不同坨的0是不同的标记，以便输出被围住的那片0 
            l=false;//初始化 
            sexy(i,j);//找到未标记过的0就进去标记 
            if(!l)//l是false说明此坨0被1包围 
            {
                for(int i=1;i<=n;i++)
             {
                for(int j=1;j<=n;j++)
               {
                  if(a[i][j]==0&&v[i][j]==t)//输出这坨 
                  cout<<2;
                  else cout<<a[i][j];
                  cout<<" ";
               }  
                 cout<<endl;
             }
            }
        }
      }
    }
    return 0;
}
```

---

## 作者：ingu (赞：1)

思路：将数据保存在[1,n][1,n]的数组中，然后利用数组边界默认的0，相当于套了一圈0，变成[0,n+1][0,n+1]的数组。

从[0][0]开始搜索（深度和宽度都可以），将搜索到的格子涂成颜色2（想一下为什么是2？）。

最后在输出的时候有个小技巧：输出的是2-a[i][j]，这样原来的2变成0，0变成2，而墙1还是1. 代码较为整洁。参考代码如下：

···cpp


```cpp
#include<iostream>
#include<queue>
using namespace std;
int main(){
    int n,t,a[50][50]={},di[4][2]={0,1,1,0,0,-1,-1,0};
    cin>>n;
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) {
            cin>>a[i][j];
        }
    }
    queue<int>qx,qy;
    qx.push(0);qy.push(0);
    while (!qx.empty()) {
        int x=qx.front();
        int y=qy.front();
        for (int k=0; k<4; k++) {
            int dx=di[k][0];
            int dy=di[k][1];
            if (x+dx>=0 && x+dx<=n+1 && y+dy>=0 && y+dy<=n+1 && !a[x+dx][y+dy]) {
                a[x+dx][y+dy]=2;
                qx.push(x+dx);qy.push(y+dy);
            }    
        }
        qx.pop();qy.pop();
    }
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) {
            cout<<2-a[i][j]<<' ';
        }
        cout<<endl;
    }
    return 0;
}
```
```cpp

---

## 作者：RyanFox (赞：1)

这题可以用深搜做，首先最外层一圈是必定要找的，都作为起点（以防特殊情况嘛），向内搜索，将0都标记一遍，遇到墙就不标记（一定不能过墙啊）。这就是将墙外的0都标记，将其与墙内的0分隔开来。最后整体循环，为0且未被标记则改为输出2。


```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,a[31][31],flag[31][31];
void search(int x,int y){
    if(x+1<=n && flag[x+1][y]==0 && a[x+1][y]==0){
        flag[x+1][y]=1;
        search(x+1,y);
    }
    if(x-1>=1 && flag[x-1][y]==0 && a[x-1][y]==0){
        flag[x-1][y]=1;
        search(x-1,y);
    }
    if(y+1<=n && flag[x][y+1]==0 && a[x][y+1]==0){
        flag[x][y+1]=1;
        search(x,y+1);
    }
    if(y-1>=1 && flag[x][y-1]==0 && a[x][y-1]==0){
        flag[x][y-1]=1;
        search(x,y-1);
    }
    return;
}
void confine(){
    for(int y=1;y<=n;y++){
        if(flag[1][y]==0 && a[1][y]==0){
            flag[1][y]=1;
            search(1,y);
        }
    }
    for(int x=1;x<=n;x++){
        if(flag[x][1]==0 && a[x][1]==0){
            flag[x][1]=1;
            search(x,1);
        }
    }
    for(int y=1;y<=n;y++){
        if(flag[n][y]==0 && a[n][y]==0){
            flag[n][y]=1;
            search(n,y);
        }
    }
    for(int x=1;x<=n;x++){
        if(flag[x][n]==0 && a[x][n]==0){
            flag[x][n]=1;
            search(x,n);
        }
    }
    return;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    confine();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(a[i][j]==0 && flag[i][j]==0)
                cout<<2<<" ";
            else
                cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：ljc20020730 (赞：1)

思路：在矩阵的外围加一圈0（系统自带的，定义时要注意-1，+1）；

然后在宽搜把走过的路径0变成3 ；

最后进行判断 把剩下的0赋值成2 然后打印

注意：不要打成（n+1）\*（n+1）矩阵！

看到下面各种各样奇怪的解法还有冗长的代码，有些蒟蒻还是有点不理解，

这里我把我的代码放上，供大家参考。

```cpp
type rec=record
x,y:longint;
end;//记录类型记录上个点的x坐标，y坐标
const
dx:array[1..4] of longint=(-1,0,1,0);
dy:array[1..4] of longint=(0,1,0,-1);
//坐标增量
var a:array[1..10000]of rec;//好像是叫“队列”的一个东西
    map:array[0..1000,0..1000]of integer;
    i,j,n:longint;
procedure bfs;
var xx,yy,head,tail,i:longint;
begin
  head:=1; tail:=1;
  while head<=tail do begin
   for i:=1 to 4 do begin
    xx:=a[head].x+dx[i];
    yy:=a[head].y+dy[i];
    if (xx<0)or(xx>n+1)or(yy<0)or(yy>n+1)or(map[xx,yy]=1)or(map[xx,yy]=3) then continue;
//上面是判重
    inc(tail);
    a[tail].x:=xx;
    a[tail].y:=yy;
    map[xx,yy]:=3;//赋值3
   end;
    inc(head);
  end;
end;
begin
 readln(n);
 for i:=1 to n do
  for j:=1 to n do
   read(map[i,j]);
 a[1].x:=1;
 a[1].y:=1;
//从（1,1）开始bfs
 bfs;
 for i:=1 to n do begin
  for j:=1 to n do begin
   if map[i,j]=3 then map[i,j]:=0
   else if map[i,j]=0 then map[i,j]:=2;
   write(map[i,j],' ');
  end;
  writeln;
  end;
end.

```

---

## 作者：satan (赞：1)

/\*
这道题选择开始搜索的地点是关键，建议从外往里搜。但如果图是这样的：

000000
111011
100001
100001
100001
111111
或是这样的：

000000
000000
000000
000000
000011
000011
就不是很好处理。

所以我把图扩大了一点，把例子1变成了这样：

00000000

00000000

01110110

01000010

01000010

01000010

01111110

00000000

这样就好处理多了，把搜过的0变成3（只要不是1,2就好） ，相当于记下搜过的点，输出时变回2就好。但千万不要输出扩大后的图。

\*/

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
using namespace std;
int map[39][39],x[12222],y[12222],head=0,tail=1,n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>map[i][j];
        }
    }
    x[1]=y[1]=32;
    while(tail!=head)
    {
        head++;
        if(map[x[head]+1][y[head]]==0&&x[head]+1<33) tail++,x[tail]=x[head]+1,y[tail]=y[head],map[x[head]+1][y[head]]=3;
        if(map[x[head]-1][y[head]]==0&&x[head]-1>=0) tail++,x[tail]=x[head]-1,y[tail]=y[head],map[x[head]-1][y[head]]=3;
        if(map[x[head]][y[head]+1]==0&&y[head]+1<33) tail++,x[tail]=x[head],y[tail]=y[head]+1,map[x[head]][y[head]+1]=3;
        if(map[x[head]][y[head]-1]==0&&y[head]-1>=0) tail++,x[tail]=x[head],y[tail]=y[head]-1,map[x[head]][y[head]-1]=3;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(map[i][j]==3) cout<<0;
            if(map[i][j]==0) cout<<2;
            if(map[i][j]==1) cout<<1;
            cout<<" ";
        }
        cout<<endl;
    }
}
```

---

## 作者：Bling萌星丶 (赞：1)

我的思路是在矩阵的外围加一圈0；然后在宽搜把外围的所有0变成3 在进行判断 把剩下的0赋值成2 然后打印

刚刚学宽搜  不喜勿喷

```cpp
var p1,p2,last,s,ax,ay:integer;
    openx:array[0..10000,1..2] of integer;
    x1,x2,y1,y2,i,p,q,n,j,u,ji:integer;
    dx:array[1..4] of longint=(-1,0,1,0);
    dy:array[1..4] of longint=(0,1,0,-1);//4个方向
    a:array[0..100,0..100] of longint;
function check(x,y:integer):boolean;
var j:integer;
begin
   check:=true;
   if (x<1) or (x>n+2) or (y<1) or (y>n+2) then check:=false;//判断有没有超界
   if (a[x,y]=1)or(a[x,y]=3) then check:=false;
   exit;
end;
begin
  readln(n); fillchar(a,sizeof(a),0);
  for i:=2 to n+1 do
  for j:=2 to n+1 do begin read(a[i,j]);end;
  p1:=1;p2:=1;
  openx[1,1]:=1;openx[1,2]:=1;
  while p1<=p2 do
    begin
      for u:=1 to 4 do
       begin
        ax:=openx[p1,1]+dx[u];
        ay:=openx[p1,2]+dy[u];
        if check(openx[p1,1]+dx[u],openx[p1,2]+dy[u]) then
          begin
           inc(p2);
           openx[p2,1]:=ax;
           openx[p2,2]:=ay;
           a[openx[p2,1],openx[p2,2]]:=3;//走过的点赋值成3
          end;
       end;
       inc(p1);
    end;
    ji:=0;
  for q:=2 to n+1 do
  for p:=2 to n+1 do
  begin
   if a[q,p]=3 then a[q,p]:=0 else
   if a[q,p]=0 then a[q,p]:=2;
   write(a[q,p],' ');
   inc(ji);
   if ji=n then  begin writeln;ji:=0;end;
  end;
end.
```

---

## 作者：wcl95716 (赞：1)


相信刚刚看这个题的人都很懵逼，之后看了下题解 ， 也没看懂别人的代码，主要就是一句话，  不用找圈内的2，只需要找圈外的0就好了

然后 这个题就变得和水池数目差不多了 = =  一个搜索的方法


  
  
  
  
  
  
  

```cpp
#include<iostream>  
#include<cmath>  
#include <cstring>  
using namespace std;  
char d[50][50];     
char p[50][50];  
int dp[50][50];    //主要作用就是标记   ，加快下速度， 要保持好习惯
int n;  
void dfs(int x,int y)    //和经典简单搜索的水池数目一样的搜索方法
{  
    if(dp[x][y]==0) return ;   
    dp[x][y]=0;    
    p[x][y]='0';    //标记连在一起的0
    if(x+1>0&&y>0&&x+1<=n&&y<=n&&d[x+1][y]=='0') dfs(x+1,y);  
    if(x>0&&y-1>0&&x<=n&&y-1<=n&&d[x][y-1]=='0') dfs(x,y-1);  
    if(x-1>0&&y>0&&x-1<=n&&y<=n&&d[x-1][y]=='0') dfs(x-1,y);  
    if(x>0&&y-1>0&&x<=n&&y-1<=n&&d[x][y-1]=='0') dfs(x,y-1);  
}  
int main()  
{  
    while(cin>>n)  
    {  
        memset(dp,1,sizeof(dp));  
        memset(d,'0',sizeof(d));  
        for(int i=1;i<=n;i++)  
        {  
            for(int j=1;j<=n;j++)  
            {  
                cin>>d[i][j];  
            }  
        }  
        memset(p,'2',sizeof(p));     //主要就是这一步智商比较高
        for(int i=1;i<=n;i++)  
        {  
            for(int j=1;j<=n;j++)  
            {  
                if(d[i][j]=='1') p[i][j]='1';  
            }  
        }  
        for(int i=0;i<=n+1;i++) dfs(0,i);            //四个循环  查四个临界的0， 然后搜圈外的0  
        for(int i=0;i<=n+1;i++) dfs(i,0);  
        for(int i=0;i<=n+1;i++) dfs(n+1,i);  
        for(int i=0;i<=n+1;i++) dfs(i,n+1);  
        for(int i=1;i<=n;i++)  
        {  
            for(int j=1;j<=n;j++)  
            {  
                cout<<p[i][j]<<' ';  
            }  
            cout<<endl;  
        }  
    }  
}  

```

---

## 作者：CRyan (赞：1)

这个BFS简直是个脑筋急转弯，算法上水的要死，结果思路上真是拐墙角。

因为只有一个闭合圈，所以不管如何，除去闭合圈内的0，**剩下的所有的0一定与边界连接**

所以，**BFS的起点，只需要枚举边界就可以，把非闭合圈的0都涂成2，剩下的0一定都是符合要求的点，所以再0/2反向输出就可以了**，说白了就是种逆转思维...论《逆转裁判》玩多了

看起来复杂度很高，但实际上最卡数据的情况无非就是1010101为边界的这种，也无非O(2n^2)，完全足够。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct a0001{
    int x,y;
}list[1000];
int map[32][32],n,l,r;//l,r为队列的指针

void reload(){
    cin>>n;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++) 
            cin>>map[i][j];
}

void bfs(){
    a0001 temp;
    l=1;r=0;
    while(r<l){
            r++;
            temp=list[r];
            if (map[temp.x][temp.y]!=0) continue;//已经填过，无论01
            if (temp.x<=0||temp.x>n||temp.y<=0||temp.y>n) continue;//边界
            map[temp.x][temp.y]=2;
            if (map[temp.x][temp.y-1]==0) {l++;list[l].x=temp.x;list[l].y=temp.y-1;}
            if (map[temp.x][temp.y+1]==0) {l++;list[l].x=temp.x;list[l].y=temp.y+1;}
            if (map[temp.x-1][temp.y]==0) {l++;list[l].x=temp.x-1;list[l].y=temp.y;}
            if (map[temp.x+1][temp.y]==0) {l++;list[l].x=temp.x+1;list[l].y=temp.y;}
        }
}

void work(){
    bool check;
    a0001 temp;
    for (int i=1;i<=n;i++){//只是因为我懒，直接一个for4个if拉倒，if中的是确定边界处为0的点，作为起点
        if (map[i][1]==0){         
            list[1].x=i;
            list[1].y=1;
            bfs();
        }
        if (map[i][n]==0){         
            list[1].x=i;
            list[1].y=n;
            bfs();
        }
        if (map[1][i]==0){         
            list[1].x=1;
            list[1].y=i;
            bfs();
        }
        if (map[n][i]==0){         
            list[1].x=n;
            list[1].y=i;
            bfs();
        }
    }
        
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            switch (map[i][j]){//反向输出
                case 0:{
                    cout<<"2 ";
                    break;
                }
                case 2:{
                    cout<<"0 ";
                    break;
                }
                default:{
                    cout<<"1 ";
                }
            }
        }
        cout<<endl;
    }
}

int main(){
    reload();
    work();
    return 0;
}
```

---

## 作者：magolor (赞：1)

突然发现做法和别人不太一样！！！！

枚举ij搜索，BFS遇到边界返回false，如果图中不是1而且BFS没有遇到边界，那么说明这个点就是内部点，break掉然后DFS或者BFS染色








    
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define pii pair<int,int>
int n,g[40][40];
int mx[4] = {-1, 0, 1, 0};
int my[4] = { 0, 1, 0,-1};
bool BFS(int r, int k)
{
    bool book[40][40];
    memset(book,false,sizeof(book));
    pii q[1000];
    book[r][k] = true;
    q[0] = pii(r,k);
    for(int head = 0, tail = 1; head < tail; head++)
    {
        int x = q[head].first, y = q[head].second;
        for(int i = 0, tx, ty; i < 4; i++)
        {
            tx = x+mx[i], ty = y+my[i];
            if(tx < 1 || tx > n || ty < 1 || ty > n)
                return false;
            if(g[tx][ty] || book[tx][ty])
                continue;
            book[tx][ty] = true;
            q[tail++] = pii(tx,ty);
        }
    }
    return true;
}
void DFS(int x, int y)
{
    for(int i = 0, tx, ty; i < 4; i++)
    {
        tx = x+mx[i], ty = y+my[i];
        if(g[tx][ty])
            continue;
        g[tx][ty] = 2;
        DFS(tx,ty);
    }
    return;
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            cin >> g[i][j]; 
    int sx = 0, sy = 0;
    for(int i = 1; !sx && !sy && i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(!g[i][j] && BFS(i,j))
            {
                sx = i, sy = j;
                break;
            }
    g[sx][sy] = 2;
    DFS(sx,sy);
    for(int i = 1; i <= n; i++, cout << endl)
        for(int j = 1; j <= n; j++)
            cout << g[i][j] << ' '; 
    return 0;
}
```

---

## 作者：hz1624917200 (赞：1)

按楼上大神的方法，在开始的时候把0全看成2，再一个个消掉。

其实还可以省掉visited数组，方法如下：

在搜索拓展的时候遇到2就拓展，把拓展得到的点立刻转成0并加入队列

所以，所有值是0的点，不是已经拓展过的，就是在队列中将要拓展的。

这不是和另开一个visited数组一样的效果吗，还天然避开1，做的时候就不用管了

另外还要注意初始化拓展四条边的时候，四个角还是不要重复的好。

下附蒟蒻代码：

[codep]




```cpp
program p1162;
type
  point=record
    x,y:longint;
  end;
const
  dir:array[1..4,1..2] of longint=((0,1),(0,-1),(1,0),(-1,0));
var
  n,i,j,h,t,x,y,newx,newy:longint;
  map:array[1..35,1..35] of longint;
  q:array[1..2000] of point;
procedure checkedge(x,y:longint);
begin
  if map[x,y]=2 then
    begin
      map[x,y]:=0;
      inc(t);
      q[t].x:=x; q[t].y:=y;
    end;
end;
begin
  readln(n);
  for i:=1 to n do
    begin
      for j:=1 to n do
        begin
          read(map[i,j]);
          if map[i,j]=0 then
            map[i,j]:=2;
        end;
      readln;
    end;
  h:=0; t:=0;
  for i:=1 to n-1 do
    begin
      checkedge(i,1); //left
      checkedge(i+1,n); //right
      checkedge(1,i+1); //up
      checkedge(n,i); //down
    end;
  while h<t do
    begin
      inc(h);
      x:=q[h].x; y:=q[h].y;
      for i:=1 to 4 do
        begin
          newx:=x+dir[i,1];
          newy:=y+dir[i,2];
          if (newx>=1) and (newx<=n) and
            (newy>=1) and (newy<=n) and (map[newx,newy]=2) then
              begin
                map[newx,newy]:=0;
                inc(t);
                q[t].x:=newx; q[t].y:=newy;
              end;
        end;
    end;
  for i:=1 to n do
    begin
      for j:=1 to n do
        write(map[i,j],' ');
      writeln;
    end;
end.
[/codep]
```

---

## 作者：2015wanghongyu (赞：1)

不建议用我的代码，思想就是开始搜0，如果能搜到边（map[x][y]中x=0或x=n-1或y=0或y=n-1）那么肯定不封闭，变成1就好，最后把所有不封闭的0都变成一

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
struct node {
    int x,y;
};node q[900];
int map[30][30],map2[30][30],ansx,ansy;
int n,p=0,k=0;
int stepx[4]={0,1,0,-1},
    stepy[4]={1,0,-1,0};
bool final=false;
void change(int w,int e)
{
    int head,tail;
    memset(q,0,sizeof(q));
    queue <int> h;
    head=0;tail=1;
    q[0].x=w;q[0].y=e;
    h.push(head);
    map2[w][e]=2;
    while(!h.empty())
    {
        head=h.front();
        for(int i=0;i<4;++i)
        {
            int x1=stepx[i]+q[head].x;
            int y1=stepy[i]+q[head].y;
            if(map2[x1][y1]==0)
            {
                q[tail].x=x1;
                q[tail].y=y1;
                map2[x1][y1]=2;
                h.push(tail);
                tail++;
            }
        }
        h.pop();
    }
}
void check(int c,int d)
{
    int s1=c,s2=d;
    while(map[c][d]==0&&c>=0)
    {
        map[c][d]==1;
        d--;
        if(d=-1) c--;
    }
    while(map[s1+1][s2+1]==0&&s1<n)
    {
        map[s1+1][s2+1]==1;
        s2++;
        if(s2==n) s1++;
    }
}
void search(int a,int b)
{
    ansx=a;ansy=b;
    int head,tail;
    memset(q,0,sizeof(q));
    queue <int> f;
    head=0;tail=1;
    q[0].x=a;q[0].y=b;
    f.push(head);
    bool turn=true;
    while (!f.empty())
    {
        head=f.front();
        for(int i=0;i<4;++i)
        {
            int x1=stepx[i]+q[head].x;
            int y1=stepy[i]+q[head].y;
            if(x1>=0&&x1<n&&y1>=0&&y1<n&&map[x1][y1]==0)
            {
                q[tail].x=x1;
                q[tail].y=y1;
                if(x1==0||x1==n||y1==0||y1==n)
                {
                    check(x1,y1);
                    turn=false;
                    break;
                }
                f.push(tail);
                tail++;
            }
        }
        if(turn==false) break;
        f.pop();
    }
    if(turn==true)
    {
        final=true;
        change(ansx,ansy);
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(j<n-1) cout<<map2[i][j]<<' ';
                else cout<<map2[i][j];
            }
            cout<<endl;
        }
        return;
    }
}
int main()
{
    char ch;
    cin>>n;
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j){
            cin>>ch;
            if(ch==' ') continue;
            else
            {
                switch(ch)
                {
                    case '1':map[p][k]=1;map2[p][k]=1;k++;break;
                    case '0':map[p][k]=0;map2[p][k]=0;k++;break;
                }
                if(k==n){k=0;p++;}
            }
        }
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
        {
            if(map[i][j]==0) search(i,j);
            if(final==true) return 0;
        }
}
```

---

## 作者：Rapiz (赞：1)

```cpp

//luogu P1162 填涂颜色
#include<iostream>
using namespace std;
const int MAXN=30+1;
int c[MAXN][MAXN],n,now,cnt=1;
bool check(int x,int y){//检查是否越界 
    return x>=1&&x<=n&&y>=1&&y<=n;
}
bool dfs(int x,int y,int cur){
    //if 到达边界 return false
    //else return true 
    bool ok=1;
    c[x][y]=cur;
    for(int dx=-1;dx<=1;dx++) for(int dy=-1;dy<=1;dy++) if(dx*dy==0&&dx!=dy) {
        if(check(x+dx,y+dy)) {if(c[x+dx][y+dy]==0) ok=dfs(x+dx,y+dy,cur)&&ok;}
        //!! 由于短路，dfs(x+dx,y+dy,cur)&&ok 不能调换 
        //!! 为了else正确配对，需要加上花括号 
        else ok=0;
    }
    return ok;
}
int main(){
    freopen("P1162.in","r",stdin);//调试代码 
    cin>>n;
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>c[i][j];
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(c[i][j]==0) if(dfs(i,j,++cnt)) now=c[i][j];
    for(int i=1;i<=n;i++,cout<<endl) for(int j=1;j<=n;j++) {
        if(c[i][j]==now) cout<<"2 ";
        else if(c[i][j]==1) cout<<"1 ";
        else cout<<"0 ";
    }
}

```

---

## 作者：天狗的手帖 (赞：1)

提供一种较为朴素的做法


按照题意模拟染色过程，DFS搜索，如果搜到边界就声明染色失败，这样就可以确保所有被1围住的0都完成染色


```cpp

#include<cstdio>
#include<cstring>

using namespace std;

bool flag;
int data[100][100];
int visit[100][100];
int n;

void solve(int x,int y)
{
    if (data[x][y]==1) return;
    if (visit[x][y]==1) return;
    if ( (x==0 or x==n+1) or (y==0 or y==n+1) ) 
    {
        flag=false;
        return;
        //color failed
    }
    
    visit[x][y]=1;
    solve(x+1,y);
    solve(x-1,y);
    solve(x,y+1);
    solve(x,y-1);
    
    if (flag) data[x][y]=2;//color
    
    return;
}

int main()
{
    memset(data,0,sizeof(data));        
    memset(visit,0,sizeof(visit));
    
    scanf("%d",&n);
    
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            scanf("%d",&data[i][j]);
    
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if ( (!visit[i][j]) && (data[i][j]!=1) )
            {
                flag=true;
                solve(i,j);
            }
            
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
            printf("%d ",data[i][j]);
        printf("\n");
    }
    
    return 0;
}

```

---

## 作者：AmuroRay (赞：1)

读入时将所有0变2，然后从边界开始，把和边界连在一起

或和与边界间接的全部变成0。

      
          
```cpp
# include<stdio.h>  
# include<stdlib.h>  
int a[100][100],n;  
void lily(int i,int j)  //找与边界相连的0
{  
    if(a[i][j]==2)  
    a[i][j]=0;  
    else  
    return;  
    if(i-1>=1&&a[i-1][j]==2)  //四个方向搜索
    lily(i-1,j);  
    if(i+1<=n&&a[i+1][j]==2)  
    lily(i+1,j);  
    if(j-1>=1&&a[i][j-1]==2)  
    lily(i,j-1);  
    if(j+1<=n&&a[i][j+1]==2)  
    lily(i,j+1);  
    return;  
}  
int main(){  
    int i,j;  
    scanf("%d",&n);  
    for(i=1;i<=n;i++)  
        for(j=1;j<=n;j++)  
        {  
            scanf("%d",&a[i][j]);  //读入把2变0
            if(a[i][j]==0)  
            {  
                a[i][j]=2;  
            }  
        }  
        for(i=1;i<=n;i++)  //从边界出发是因为如果边界到都为1那图中的零都要变二
        {  
        lily(i,1);  
             lily(i,n);  
    }  
        for(i=1;i<=n;i++)  //见上
        {  
            lily(1,i);  
            lily(n,i);  
        }  
    for(i=1;i<=n;i++)  //输出
    {  
        for(j=1;j<=n;j++)  
        {  
            printf("%d ",a[i][j]);  
        }  
        printf("\n");  
    }  
}  
```
题解不对的地方请说明，谢谢！
前面大侠给的数据已过。


---

## 作者：kczno1 (赞：1)

DFS
找0，搜索判断是否处在闭合圈，

并对和该点处在同一区域的0做标记，

对于这些被标记了的点：

在搜索中:

防止再次访问

在搜索结束后:

如果处在闭合圈，便于输出时改为2；如果不是，可以防止下一次找这些点。


找到解后直接输出，halt


注意:

如果知道了不在闭合圈也不要退出搜索

(防止下次再次找同一区域内，同样不处在闭合圈的点)

输出时的空格

(反正我第一次提交时就错在这)


```cpp
const
 cx:array[1..4]of -1..1=(0,0,-1,1);
 cy:array[1..4]of -1..1=(-1,1,0,0);

var
 a:array[1..30,1..30]of 0..2;
 b:array[1..30,1..30]of longint;
 n,i,j,k:longint;
 ok:boolean;

function can(x:longint):boolean;
begin
 if (x>0)and(x<=n) then exit(true);
 exit(false);
end;

procedure try(x,y:longint);
var
 i:longint;
begin
 if a[x,y]=1 then exit;
 b[x,y]:=k;
 for i:=1 to 4 do
 if can(x+cx[i]) and can(y+cy[i]) then
 begin
  if b[x+cx[i],y+cy[i]]=0 then
   try(x+cx[i],y+cy[i]);
 end
 else
  ok:=false;
end;

procedure toend;
var i,j:longint;
begin
 for i:=1 to n do
 begin
  for j:=1 to n do
  if b[i,j]<k then write(a[i,j],' ')
  else write(2,' ');
  writeln;
 end;
 halt;
end;

begin
 readln(n);
 for i:=1 to n do
  for j:=1 to n do
   read(a[i,j]);
 for i:=2 to n-1 do
  for j:=2 to n-1 do
  if (a[i,j]=0) and (b[i,j]=0) then
  begin
   inc(k); ok:=true;
   try(i,j);
   if ok then toend;
  end;
end.

```

---

## 作者：zyxyzm_77 (赞：1)

首先感谢楼上的题解帮助我首次自行顺利地写出了BFS（这里是只看得懂pascal的蒟蒻一只QwQ）。。。

然后写题解只是为了指出楼上题解的一个小bug……在BFS的时候似乎应该先把开始BFS的那个点置为0。不然像这样的数据就会被卡。。。

7
1 1 1 1 0 0 0

1 0 0 1 0 0 0

1 1 0 1 1 1 1

0 1 0 0 0 0 1

1 1 0 0 1 1 1

1 0 0 0 1 0 0

1 1 1 1 1 0 0

=============

正确输出

1 1 1 1 0 0 0

1 2 2 1 0 0 0

1 1 2 1 1 1 1

0 1 2 2 2 2 1

1 1 2 2 1 1 1

1 2 2 2 1 0 0

1 1 1 1 1 0 0

顺便[吐槽一下测试数据的弱（大雾）以及]提出一点疑问：题目中的“方阵内只有一个闭合圈”是否是指只有一个圈并且除了这个圈以外没有多余的1？

（代码长得太像了是不是就不要贴了……）

（贴一下好像也没什么关系……？）

再次感谢前面各位写题解and赠送测试数据的同学们！

```delphi

program luop1162;
type GKing=record
     x,y:longint;
     end;
const dfx:array[1..4] of longint=(0,0,-1,1);
      dfy:array[1..4] of longint=(-1,1,0,0);
var i,j,n:longint;
    a:array[0..32,0..32] of longint;

procedure bfs(j,k:longint);
var c:array[0..901] of GKing;
    head,tail,xi,yi:longint;
  begin
    a[j,k]:=0;
    head:=0;
    tail:=1;
    c[1].x:=j;
    c[1].y:=k;
    while head<tail do
      begin
        inc(head);
        for i:=1 to 4 do
          begin
            xi:=c[head].x+dfx[i];
            yi:=c[head].y+dfy[i];
            if a[xi,yi]=2 then
              begin
                inc(tail);
                c[tail].x:=xi;
                c[tail].y:=yi;
                a[xi,yi]:=0;
              end;
          end;
      end;
  end;

begin
  read(n);
  for i:=1 to n do
    begin
      readln;
      for j:=1 to n do
        begin
          read(a[i,j]);
          if a[i,j]=0 then a[i,j]:=2;
        end;
    end;
 for i:=1 to n do
    begin
      a[0,i]:=3;
      a[n+1,i]:=3;
      a[i,0]:=3;
      a[i,n+1]:=3;
    end;
  for i:=1 to n do
    begin
      if a[1,i]=2 then bfs(1,i);
      if a[n,i]=2 then bfs(n,i);
      if a[i,1]=2 then bfs(i,1);
      if a[i,n]=2 then bfs(i,n);
    end;
  for i:=1 to n do
    begin
      for j:=1 to n do write(a[i,j],' ');
      writeln;
    end;
end.

```

---

## 作者：jxpxcsh (赞：1)

没想到已经有大神发了题解了，自以为想到了很不错的一个算法。。。刚学完暴搜，新手做个题目练习一下

不过我还是独家发布一下标程，并且还加入了一些无关紧要不足挂齿聊胜于无的优化。


```delphi

program project1;
var a:array[1..30,1..30]of 0..2;
  n,i,j:longint;
begin
  readln(n);
  for i:=1 to n do
    for j:=1 to n do
      begin
        read(a[i,j]);
        if a[i,j]=0 then a[i,j]:=2;
      end;
  readln;
  for i:=1 to n do
    begin
      for j:=1 to n do//左边开始从竖着的边界枚举
          if a[i,j]=1 then break
                        else a[i,j]:=0;
      for j:=1 to n do//上面开始从横着的边界枚举
          if a[j,i]=1 then break
                        else a[j,i]:=0;
      for j:=n downto 1 do//右边开始从竖着的边界枚举
          if(a[i,j]=1)or(a[i,j]=0)then break else a[i,j]:=0;
      for j:=n downto 1 do//下面开始从横着的边界枚举
          if(a[j,i]=1)or(a[j,i]=0)then break else a[j,i]:=0;
      //如果碰到零说明这一行（列）已经被还原成零了
    end;
  for i:=1 to n do
    begin
     for j:=1 to n do
       write(a[i,j],' ');
     writeln;
    end;
  readln;
end.


```

---

## 作者：虚无教主 (赞：1)

### 为什么有这么多人给出如此复杂的代码？
#### 因为
# 不会打表的人进不了省一！！！

###### 核心代码
```
int k[]= {2,1,0};

```
### 完整代码
```
#include <bits/stdc++.h>

int o[35][35];
int n;
int k[]= {2,1,0};

void bfs(int x,int y) {
    if(o[x][y]>=1||o[x][y]<=-1) return;
    else {o[x][y]=2;bfs(x+1,y);bfs(x-1,y);bfs(x,y+1);bfs(x,y-1);}}//为防止边界出现孤单的0

int main() {
    scanf("%d",&n);
    memset(o,-1,sizeof(o));
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            scanf("%d",&o[i][j]);
    for(int i=1; i<=n; i++)
        bfs(i,1),bfs(1,i),bfs(n,i),bfs(i,n);
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            printf("%d ",k[o[i][j]]);printf("\n");}//打表的精华
    return 0;}
```

这不是很简单吗？？？？

### 为什么你们的代码那么长？






---

## 作者：衡屿睿 (赞：1)

这道题用纯暴力求解，沾数据的光，恐怕也不比BFS费事。

对于方阵中为零的元素，判断其上下左右是否都有“墙”，若成立将其变为二，不成立则保留原样。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int a[31][31];
int main()
{
    int n;
    int ans1,ans2,ans3,ans4;//此四数据用以判断其左右上下是否都有“墙”。
    cin>>n;
    for(int i=1;i<=n;++i)
     for(int j=1;j<=n;++j)
          cin>>a[i][j];
    for(int i=1;i<=n;++i)
     for(int j=1;j<=n;++j)
     {
         ans1=0,ans2=0,ans3=0,ans4=0;
         if(a[i][j]==0)
         {
             for(int z=1;z<=j-1;++z)if(a[i][z]==1)ans1=1;
             for(int x=j+1;x<=n;++x)if(a[i][x]==1)ans2=1;
             for(int c=1;c<=i-1;++c)if(a[c][j]==1)ans3=1;
             for(int v=i+1;v<=n;++v)if(a[v][j]==1)ans4=1;
         }
         if(ans1+ans2+ans3+ans4==4)a[i][j]=2;//若成立将其变为二。
     }
     for(int i=1;i<=n;++i)
     {
        for(int j=1;j<=n;++j)
          cout<<a[i][j]<<" ";
        cout<<endl;
     }
    return 0;
}
```

---

## 作者：焚魂 (赞：0)

其实我当初做这道题的时候是想练习一下bfs的，但是看到这道题时，发现是求联通块的，还是觉得dfs好一点。当初我是先做了[P1506 拯救oibh总部](https://www.luogu.org/problem/P1506)，然后一脸懵逼，看了题解区大佬的想法之后才明白的，思路就是搜索。
举个例子，就说样例吧：
```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
搜索外边一圈的，把暴露在外面的0全部都变成1，然后被包裹着的（搜索不到的）就是要变成2的啦。
搜索之后的结果：
```
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
然后把里面的变成2输出就好啦，当然，外面的输出时不能变成1，于是就要一个bool数组b来代替判断。
具体代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
int map[10010][10010];
int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
bool b[10010][10010];
void dfs(int x,int y);
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	cin>>map[i][j];
	for(int i=1;i<=n;i++)
	{
		if(map[1][i]==0)dfs(1,i);
		if(map[i][1]==0)dfs(i,1);
		if(map[n][i]==0)dfs(n,i);
		if(map[i][n]==0)dfs(i,n);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
	    {
		    if(map[i][j]==0&&b[i][j]==0)
		    map[i][j]=2;
		    cout<<map[i][j]<<" ";
	    }
	    cout<<endl;
	}
	return 0;
}
void dfs(int x,int y)
{
	b[x][y]=1;
	for(int i=0;i<=3;i++)
	{
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(xx>0&&xx<=n&&yy>0&&yy<=n&&map[xx][yy]==0&&b[xx][yy]==0)
		{
			dfs(xx,yy);
		}
	}
}
```


---

## 作者：wind_cross (赞：0)

	 这题应该学了搜索的都会写，普通的染色法而已，但我这里写了个比较复杂的，主要是dfs的思想，对每个点进行一次查找，如果会出界就判断为不可行，最后找到第一个不会搜索出界的点，进行染色。
代码见下：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
int a[35][35];
bool used[35][35];
bool flag=1;//判断变量
int sx[4]{1,0,-1,0};
int sy[4]{0,1,0,-1};//方向数组
int n,b1,b2;
void dfs(int x,int y){
	if(x<1||y<1||x>n||y>n){//边界判断
		flag=0;
		return;
	}
	if(a[x][y]==1)return;//是1直接返回
	else used[x][y]=1;//反之标记一下已来过
	for(int i=0;i<4;i++){
		int xx=sx[i]+x,yy=sy[i]+y;
        dfs(xx,yy);//四个方向找一遍
	}
}
void rs(int x,int y){//染色函数
	if(a[x][y]==1||a[x][y]==2)return;//无论是1或2都不可继续搜索
	else a[x][y]=2;//是0直接标为2
	for(int i=0;i<4;i++){
		int xx=sx[i]+x,yy=sy[i]+y;
		rs(xx,yy);//依然四个方向找
	}
}
int main()
{
	n=read(n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)a[i][j]=read(a[i][j]);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			flag=1;//初始为1，若搜索时越界，会赋值为0
			if(!a[i][j])dfs(i,j);//如果当前数为0，开始搜索
			else flag=0;
			if(flag){
				b1=i,b2=j;//找到第一个搜索后发现不会越界的点，进行标记
				break;
			}
		}
		if(flag)break;
	}
	rs(b1,b2);//从标记的点开始染色
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",a[i][j]);
		}
		puts("");
	}//输出
	return 0;
}
```
这份代码看上去比较复杂，但实际上时间复杂度不高，本题只用了15ms,可放心食用。

---

## 作者：爱晚亭哦 (赞：0)

**将方阵周围赋值为-1，然后前后搜索两遍四周有-1的0，剩下的的0就都变成2.**

因为1≤n≤30，所以这种O(11n²+n)时间复杂度的程序还是可以接受的.

各位大佬的程序都比我快好多啊，**wtcl** qwq.

Code：
```
#include<cstdio>
int a[31][31],b[31][31];//一个数组用来搜索，一个用来输出，比较方便 
int x[5]={0,1,-1,0,0},y[5]={0,0,0,1,-1};//方向 
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
			b[i][j]=a[i][j];
		}
	for(int i=1;i<=n;i++)
		a[0][i]=a[i][n+1]=a[i][0]=a[n+1][i]=-1;//周围都赋值为-1 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]==0)
				for(int k=1;k<=4;k++)
					if(a[i+x[k]][j+y[k]]==-1)
					{
						a[i][j]=-1;
						break;
					}
	for(int i=n;i>=1;i--)
		for(int j=n;j>=1;j--)
			if(a[i][j]==0)
				for(int k=1;k<=4;k++)
					if(a[i+x[k]][j+y[k]]==-1)
					{
						a[i][j]=-1;
						break;
					}//顺着逆着都要搜一遍 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]==0)
				b[i][j]=2;//0改成2 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			printf("%d ",b[i][j]);
		printf("\n");
	}
	return 0;//好习惯	
}
//这么弱的代码还要抄吗qwq 
```
如果上述题解有误欢迎指出 （~~估计很多吧~~）

管理看我这么弱，题解比较易懂，~~就过了吧qwq~~

---

## 作者：RayI_ovo (赞：0)

这是bfs的基础题

需要注意的是要先找圈内的一个点，再从这个点开始用先广搜索方式填充。

找一个封闭多边形内点点的方法比较多，这里采用是按照行来循环，在每行找到第一个边界点，并判断它右侧点点，如果右侧点是内点（数值为0）那么就是它了，如果不是就去下一行寻找。 

填充就没有什么好说的，建立一个队列保存第一个找到的内点并做上入队的标记，而后循环判断队列不空的情况下从队列前面取一个节点，填充后，再找他四周没有入过队的点加入到队尾即可。

代码如下：



```
#include <iostream>
#include <cstring>

using namespace std;
const int MaxSize = 32;
int N=0;
int board[MaxSize][MaxSize]; //
int vis[MaxSize][MaxSize];   // 辅助标记，1表示在队列里面 0不在
struct POS {
    int x, y;
} queue[MaxSize*MaxSize]; // 队列最长N*N
int qs=0, qe=0;   //qs队列开始， qe队列结束 qs=es表示队列空

void readDate() {
    cin >> N;
    for ( int i=0; i<N; i++ ) {
        for ( int j=0; j<N; j++ ) {
            int t;
            cin >> t;
            vis[i][j]   = t;  // 入队列的标记。边界默认都在队列里面
            board[i][j] = t;
        };
    };
}
void printResult() {
    for ( int i=0; i<N; i++ ) {
        for ( int j=0; j<N; j++ ) {
            cout << board[i][j] << " ";
        }; cout << endl;
    }
}
// 寻找圈内的一点，找到后返回1，并把点放到队列里面
// 找圈内点点办法: 从左到右，遇到第一个边界点而且它右边不是边界点的点，必然是内点
//              这个点一定是内点当中最左侧的点
int findInner() {
    for (int x=1; x<N-1; x++ ) {
        for (int  y=0; y<N-1; y++) {
            if ( board[x][y]== 0 ) continue;
            if ( y<N-1 && board[x][y+1]==0 ) {
                queue[qe].x = x;
                queue[qe].y = y+1;
                qe ++;
                vis[x][y+1] = 1;
                return 1; // 有右侧点切不是边界点
            } else
                break; // 找下一行
        };
    }
    return 0;
};

void bfs() {
    while ( qe != qs ) {
        int i = queue[qs].x;
        int j = queue[qs].y;
        qs ++;
        board[i][j]=2;
        
        // 检查该点周边，遇到没有填充的入队列
        // 可以确保的是，每个没有填充的点只会进入队列一次
        if ( j<N-1 && board[i][j+1]==0 && 0 == vis[i][j+1]) {
            queue[qe].x = i;
            queue[qe].y = j+1;
            qe ++;
            vis[i][j+1] = 1;
        };
        if ( j>0 && board[i][j-1]==0 && 0==vis[i][j-1]) {
            queue[qe].x =i;
            queue[qe].y =j-1;
            qe ++;
            vis[i][j-1] = 1;
        };
        if ( i>0 && board[i-1][j]==0 && 0==vis[i-1][j]) {
            queue[qe].x = i-1;
            queue[qe].y = j;
            qe ++;
            vis[i-1][j] = 1;
        };
        if ( i<N-1 && board[i+1][j] ==0 && 0==vis[i+1][j]) {
            queue[qe].x = i+1;
            queue[qe].y = j;
            qe++;
            vis[i+1][j] = 1;
        };
    }
    // 队列为空，表示全部处理完了
    // 可以输出结果了
    printResult();
}
int main() {
    memset(board, 0, MaxSize*MaxSize*sizeof(int));
    readDate();
    if ( findInner()) bfs();
    return 0;
};
```

ps 在mac系统用xcode来调试，遇到cin数据半道儿不读数据的情况，坑人的编译器！ 改scanf也不行。 同样代码换个windows系统dev环境什么都不用动就通过了。  白浪费了半天时间。

---

## 作者：Kevin234 (赞：0)

此题要求把由"1"围成的圈内的"0"都改为"2",而圈外的"0"不需要改动,所以如何区分开圈内"0"和圈外"0"就成了关键.注意到圈内"0"有一个显著特征,就是:上下左右至少含有一个"1".据此得到如下题解:
```java
import java.util.Scanner;

public class P1162 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(in.hasNext()) {
			int n = in.nextInt();
			char [][]a = new char[n][n];
			for(int i = 0;i<n;i++) {
				for(int j = 0;j<n;j++)
					a[i][j] = in.next().charAt(0);
			}
			for(int i = 0;i<n;i++) {
				for(int j = 0;j<n-1;j++) {
					if(a[i][j]=='0' && IsMiddle(a,i,j)) a[i][j]='2';
					System.out.print(a[i][j]+" ");
				}
				System.out.println(a[i][n-1]);
			}
		}
		in.close();
	}
	public static boolean IsMiddle(char [][]a,int i,int j) {
		int L=0,R=0,U=0,D=0;
		for(int k = 0;k<j;k++)
			if(a[i][k]=='1') { L=1;break; }
		for(int k = a[i].length-1;k>j;k--)
			if(a[i][k]=='1') {R=1;break;}
		for(int k = 0;k<i;k++)
			if(a[k][j]=='1') {U=1;break;}
		for(int k = a[i].length-1;k>i;k--)
			if(a[k][j]=='1') {D=1;break;}
		if(L==1&&R==1&&U==1&&D==1) return true;
		return false;
	}
}

```

---

## 作者：Freddie (赞：0)

~~15ms，应该很快了，最优解测出来也是15ms~~
楼上大佬都用的DFS，BFS，我就只会用栈代替


------------

## 思路
- #### 其实思维很简单，因为直接改变任意形状闭合圈中的0，我们不知道从哪里开始BFS或者DFS。所以我们只能改变任意形状闭合圈外的0。

- #### 任意形状闭合圈外的0可能是断裂的（不连通），~~@YZZdalao：那怎么办呢？~~

- #### 我们在图外再加一圈，就可以把不连通的0，连接起来，就可以DFS，BFS了~
- #### 所以我们把闭合圈外的0替换为其他数字（非1），最后输出$\color{red} \text{把这些数变为0，把0变为2}$就行了。
_#define turn(x) (x?(x==2?0:1):2)_ 
## 程序实现:
- 1.先认为所有的'0'都应该被修改,并且真的把它修改成了'2';

- 2.边角上的'2'其实本来不应该被修改的,那我们把他们改回去 ,改成'0'

- 3.然后来寻找与这些零相邻的'2',它们其实也是被改错了的

```
                 0 0 0 0 0 0 0 0      2 2 2 2 2 2 2 2
0 0 0 0 0 0      0 0 0 0 0 0 0 0      2 2 2 2 2 2 2 2     
0 0 1 1 1 1      0 0 0 1 1 1 1 0      2 2 2 1 1 1 1 2
0 1 1 0 0 1----\ 0 0 1 1 0 0 1 0----\ 2 2 1 1 0 0 1 2
1 1 0 0 0 1----/ 0 1 1 0 0 0 1 0----/ 2 2 1 1 0 0 1 2
1 0 0 0 0 1      0 1 0 0 0 0 1 0      2 1 0 0 0 0 1 2
1 1 1 1 1 1      0 1 1 1 1 1 1 0      2 1 1 1 1 1 1 2
                 0 0 0 0 0 0 0 0      2 2 2 2 2 2 2 2

      0 0 0 0 0 0
      0 0 1 1 1 1
----\ 0 1 1 2 2 1
----/ 1 1 2 2 2 1
      1 2 2 2 2 1
      1 1 1 1 1 1
```  


------------

## ruogou的代码：
```cpp
#include <bits/stdc++.h>
#define turn(x) (x?(x==2?0:1):2)
using namespace std;                             //把2变成0,0变成2
int n,o[32][32];//全局变量 所以值全部为0
int xi[5]={0,1,-1,0,0},yi[5]={0,0,0,-1,1};
void find()  {                                              //把外层的0改为2 因为x,y属于[0,n+1]所以可以把圈外搜索完 
    stack<int> x,y;x.push(0);y.push(0);
    while(!x.empty()){                                      //用栈 DFS  
    	int i=x.top(),j=y.top();x.pop(),y.pop();o[i][j]=2;
		for(int k=1;k<=4;k++)                               //从四个方向找 
			if((i+xi[k]<=n+1&&i+xi[k]>=0)&&(j+yi[k]>=0&&j+yi[k]<=n+1)&&o[i+xi[k]][j+yi[k]]==0) //没有越界和不找到圈内			                                                
				x.push(i+xi[k]),y.push(j+yi[k]);}}      //放入栈 也就是继续搜索find(i+xi[k],j+yi[k]) 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)                                   //输入图 
    	for(int j=1;j<=n;j++)scanf("%d",&o[i][j]);	
    find();                                              //边缘的边开始找都可以 
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=n;j++)printf("%d ",turn(o[i][j])); //把2变成0,0变成2输出 
    	printf("\n");}
    return 0;}//完美结束 
```
### ~~为什么你们代码那么长？？~~


------------

↓是来自同机房dalao的 思维感觉不错~~懒的理解~~ 排版也不错
```
#include<cstdio>
using namespace std;
int n,m[31][31];
bool find(int x,int y)
{
    bool f1=false,f2=false,f3=false,f4=false;
    for(int i=x-1;i>=1;--i) 
		if(m[i][y])
		 	{f1=true;break;}
    for(int i=y-1;i>=1;--i) 
		if(m[x][i]) 
			{f2=true;break;}
    for(int i=y+1;i<=n;++i) 
		if(m[x][i]) 
			{f3=true;break;}
    for(int i=x+1;i<=n;++i) 
		if(m[i][y]) 
			{f4=true;break;}
    return (f1 && f2 && f3 && f4);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) 
	for(int j=1;j<=n;++j) scanf("%d",&m[i][j]);
    for(int i=2;i<n;++i) 
		for(int j=2;j<n;++j) 
			if(!m[i][j] && find(i,j)) 
				m[i][j]=2;
    for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j)
			printf("%d ",m[i][j]);
		printf("\n");
	}
    return 0;
}
```
### 求过呢~


------------


---

## 作者：xmc611 (赞：0)

这题看了dalao们的题解，开始尝试只从（1,1）开始搜索，但是还是有3个点wa了QAQ，最后尝试从每个边界点都搜索一遍，最后终于过了= =.附上代码.


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int f[33][33];
int x,y,i,j,n;
bool flag[33][33];
int dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
void work(int i,int j){
    if(f[i][j]==1||flag[i][j]==1||i==n+1||i==-1||j==-1||j==n+1)return;//判断是否走到了边界或者已经走过了或者撞墙了
    int a;
    flag[i][j]=1;
    for(a=1;a<=4;a++)work(i+dx[a],j+dy[a]);//4个方向上进行查找
    return;
}
int main(){
    memset(flag,0,sizeof flag);
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            scanf("%d",&f[i][j]);
            if(f[i][j])flag[i][j]=1;//给墙提前标记
        }
    }
    for(i=1;i<=n;i++){//因为在圈内的0周围肯定会有1，如此可以推导出位于边缘的0绝对不在圈内，可以作为搜索起始点
        work(i,1);//从每个边界点都搜索一遍，怎么输？！
        work(1,i);
        work(n,i);
        work(i,n);
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            if(flag[i][j])//判断是否走过该点，走过了就输出原数，没走过就说明在墙内，输出“2 ”(别忘了空格)
            printf("%d ",f[i][j]);
            else
                printf("2 ");
        }
    printf("\n");
    }    
    return 0;
}
```

---

## 作者：q2368126021 (赞：0)

#算法下面的大佬都已讲过，我也是先判断外圈的0，对外圈的0进行染色，有0的则变为2，后面逐个逐个输出，但稍稍偏暴力，本以为会tle

            
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000][1000];
int dx[5]={1,0,-1,0},
    dy[5]={0,1,0,-1};
int bfs(int x,int y)**广搜过程不用讲了吧。。。。**
{
    int head=0,tail=1;
    int h[1000][3];
    h[1][1]=x,h[1][2]=y;
    int xi,yi;
    int i;
    if(!a[x][y])
    a[x][y]=2;
    while(head<tail)
    {
      head++;
      for(i=0;i<=3;i++)    
        {
          xi=h[head][1]+dx[i];yi=h[head][2]+dy[i];    
            if(xi>0&&xi<=n&&yi>0&&yi<=n&&!a[xi][yi])
              {
                tail++;    
                h[tail][1]=xi;
                h[tail][2]=yi;         
                a[xi][yi]=2;
              }
        }    
    }
}
int main()
{
    cin>>n;
    int i,j;
    for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
        cin>>a[i][j];**读入，这就不用说了吧**
```
**剩余代码先从外圈判断，如果有0则进行广搜染色**
```cpp
    for(i=1;i<=n;i++)
    if(!a[1][i])**判断第一行**
      bfs(1,i);
    for(i=1;i<=n;i++)
    if(!a[i][1])**判断第一列**
      bfs(i,1);
    for(i=n;i>=1;i--)
     if(!a[n][i])**判断最后一行**
      bfs(n,i);
    for(i=n;i>=1;i--)
     if(!a[i][n])**判断最后一列**
      bfs(i,n);
    for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)**反色输出**
        {
         if(a[i][j]==2)    
          cout<<0<<" ";
         if(a[i][j]==1)    
          cout<<1<<" ";     
         if(a[i][j]==0)
          cout<<2<<" ";    
         if(j==n)
          cout<<endl;
        }
}
```

---

## 作者：HeHere (赞：0)

**强行DFS,提供2种方法**

##方法1

本题数据较弱，涂色的边框只有一层，于是可以发现这样的规律：

0上面如果是1，那么这个0很可能是涂色区域。

从左上往右下扫描，第一个遇见的这样的0就是涂色区域的一部分：

```cpp
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(map[i][j]==1 && map[i+1][j]==0){
                paint(i+1,j);
                printAns();
                return 0;
            }
        }
    }
```

##方法2

如果可以有多个区域，或者地图像这样：

 ![](https://cdn.luogu.com.cn/upload/pic/5091.png) 

被标记的那个0就会影响判断。于是反过来，**先全部涂色为2，然后取消靠近边缘的0**。

```cpp
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            int tmp;
            cin >> tmp;
            if(tmp==0) map[i][j]=2;
            else map[i][j]=1; 
        }
    }
    
    for(int i=1;i<=n;i++){
        unpaint(1,i);
        unpaint(n,i);
        unpaint(i,1);
        unpaint(i,n);
    }
    printAns();
```
代码更简单，unpaint是典型的DFS递归函数：

```cpp
void unpaint(int x, int y){
    if(map[x][y]!=2) return;
    map[x][y]=0;
    for(int i=0;i<DELTA_COUNT;i++){
        int nx=x+dx[i];
        int ny=y+dy[i];
        unpaint(nx,ny);
    }
}
```

完整代码如下（第二版的）：

```cpp
//www.luogu.org   P1162
#include <iostream>
#include <cstring>
using namespace std;
const int maxN=30+5;
int n;
int map[maxN][maxN];

const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};
const int DELTA_COUNT=4;

void unpaint(int x, int y){
    if(map[x][y]!=2) return;
    map[x][y]=0;
    for(int i=0;i<DELTA_COUNT;i++){
        int nx=x+dx[i];
        int ny=y+dy[i];
        unpaint(nx,ny);
    }
}

void printAns(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cout<<map[i][j]<<" ";
        }
        cout<<endl;
    }
}

int main(){
    
    cin >> n;
    memset(map,-1,sizeof(map));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            int tmp;
            cin >> tmp;
            if(tmp==0) map[i][j]=2;
            else map[i][j]=1; 
        }
    }
    
    for(int i=1;i<=n;i++){
        unpaint(1,i);
        unpaint(n,i);
        unpaint(i,1);
        unpaint(i,n);
    }
    printAns();
    
    return 0;
}
```

---


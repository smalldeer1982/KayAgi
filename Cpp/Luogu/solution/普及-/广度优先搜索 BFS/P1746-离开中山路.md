# 离开中山路

## 题目背景

《爱与愁的故事第三弹·shopping》最终章。


## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？


## 说明/提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。

## 样例 #1

### 输入

```
3
001
101
100
1 1 3 3```

### 输出

```
4```

# 题解

## 作者：Cult_style (赞：103)

### 这道题是一道水题，可以直接用BFS的方法做
### BFS的时间复杂度是n*n，可以直接过掉
## 可能有些人还不知道怎么用BFS
###  _那就来看下面的解释_ 
#### 首先，先要用到一个叫队列的东西
#### 它可以从尾巴进去，头上出来
#### 把一个数丢到队列的末尾，可以用到函数push（）
#### 把队列里的东西拿出来的，可以用到函数front（）
#### 把队列里的东西扔了，可以用到函数pop（）
#### 测量队列长度，可以用到函数size（）


------------

### 讲完队列后，你可能会想，队列和BFS有什么关系
#### 那么，就再讲一讲队列的作用


------------

#### 关于BFS，我们可以用结构体来表示一个横坐标，一个纵坐标
#### 我们先把起点的横、竖坐标放进队列q里
#### 当然，我们还要把步数存进vis二维数组里
### 然后如果队列q里还有数，就执行以下操作
#### 1.把队列里的第一个数取出来
#### 2.判断移动上下左右四个方向可不可以走
#### 3.如果可以走，就把它的横坐标合纵坐标存进队列q里
#### 4.把步数定为前一步加一
## 最后，把参数设为起点就行了
```
#include<bits/stdc++.h>
using namespace std;
int n;
int vis[1005][1005];
int h[4]={0,0,1,-1},s[4]={1,-1,0,0};
//h、s数组代表可以走的上下左右四个方向
char a[1005][1005];
//a数组表示地图
struct node{
	int x,y;
};
//结构体
queue<node>q;
//如上，队列q
bool check(int x,int y){	
	if(a[x][y]=='1')
	    return false;
    	//如果是障碍物，就返回false
	if(vis[x][y]>0)
	    return false;
   	//如果以前走过了，就返回false
	if(x>n||x<1)
	    return false;
	if(y>n||y<1)
	    return false;
        //如果超出地图边界，就返回false
	return true;
    	//如果它通过了重重考验，就给它过吧
}
void bfs(int x,int y){
	vis[x][y]=1;
    	//标记起点
	q.push((node){x,y});
    	//把起点和终点放进队列q里 
	while(q.size()!=0){
    	    //如果队列里还有数，就继续
	    int xx=q.front().x;
	    int yy=q.front().y;
            //把队列里的数取出来
	    q.pop();
            //用过了就把它扔了
	    for(int i=0;i<4;i++){
            //代表四个方向
		int xxx=xx+h[i];
		int yyy=yy+s[i];
                //向某一个方向前进
		if(check(xxx,yyy)){
		    vis[xxx][yyy]=vis[xx][yy]+1;
            	    //记录步数
		    q.push((node){xxx,yyy});
            	    //把通过的答案扔进队列里
	        }
	    }
        }
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
	    for(int j=1;j<=n;j++){
		cin>>a[i][j];
	    }
	}
    	//地图
	int x1,x2,y1,y2;
    	//x1表示起点的横坐标，x2表示起点的纵坐标
	scanf("%d%d%d%d",&x1,&x2,&y1,&y2);
	bfs(x1,x2);
	printf("%d",vis[y1][y2]-1);
	//输出答案减一，它把起点也算了一步
	return 0;
} 
```
#### 在这里插一句，为什么vis数组要等于一呢？
#### 等于0不就不用减一了吗
## 不不不，如果它初始值是0,
## 也会在check里面被算为false


------------
### ~~求过求赞~~


---

## 作者：_yjh (赞：55)

# 我的做法用的是 广搜+STL队列


------------
###### 废话：~~最近新学了**广搜**，看到大家都用 **A star，手打队列**，本蒟蒻表示看不懂，自愧不如。我还是献上一份**广搜+STL**队列的题解吧。~~
------------

## 我先给大家介绍一下**STL队列的用法_帮你[百度一下](http://buhuibaidu.me/?s=queue队列用法)**。

_**什么是队列？**_

```
队列是一种特殊的线性表，
特殊之处在于：它只允许在表的前端进行删除操作，只允许在表的后端进行插入操作；
队列是一种操作受限制的线性表；
进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。
队列的数据元素又称为队列元素。
在队列中插入一个队列元素称为入队，
从队列中删除一个队列元素称为出队。
因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
/*摘自 https://jingyan.baidu.com/article/b2c186c80ff8b7c46ff6ff50.html */
```

使用 **queue(队列)** 的步骤
- 引入头文件 **<queue>**
  ```cpp
#include<queue>
``` 
- 定义一个 **任何类型的队列** (如int)
  ```cpp 
queue <类型名> 变量名;
``` 
- 使用 **库中的函数** 对其进行操作
  ```cpp
//基本操作
/*定义一个队列变量q*/
#1 q.push(变量); 将变量插入队尾
#2 q.pop(); 弹出队首的元素
#3 q.front(); 访问队首元素
#4 q.back(); 访问队尾元素
#5 q.empty(); 判断队列是否为空,是则返回true
#6 q.size(); 返回队中元素的个数
```
  ------------
 明白 **队列的性质** ，便可以 **开始阅读本题解了** 
  
 这其实是一个 **普通的迷宫问题的变形** 。
  
 首先，普通的迷宫问题，只需要判断是否能走到终点。
  
 于是，便可以用以下思路解题：
  1. 定义一个结构体变量 Pos，存储坐标
  2. 定义一个 Pos类型的队列q
  3. 从起点开始搜索，将起点加入队列
  4. 将所有可走的路放入队列中，再弹出并向四周延伸。
  5. 找到终点返回 Yes，否则返回 No

  这就有了以下代码：
  ```cpp
#include<iostream>
#include<queue>
using namespace std;
struct Pos
{
	int x,y;
};
int n,m,x,y,zx,zy;
bool vis[101][101];
char mp[101][101];
const int dx[]={1,-1,0,0};
const int dy[]={0,0,-1,1};
queue <Pos> q;
int bfs(int sx,int sy)
{
	q.push((Pos){sx,sy});
	vis[sx][sy]=true;
	while(!q.empty())
	{
		x=q.front().x; y=q.front().y;
		q.pop();
		if(mp[x][y]=='T') return true;
		for(int i=0;i<4;i++)
		{
			zx=x+dx[i]; zy=y+dy[i];
			if(zx<=0||zx>m||zy<=0||zy>n) continue;
			if(mp[zx][zy]=='#'||vis[zx][zy]==true) continue;
			vis[zx][zy]=true;
			q.push((Pos){zx,zy});
		}
	}
	return false;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	        cin>>mp[i][j];
	if(bfs(1,1)==true) cout<<"Yes";
	else cout<<"No";
	return 0;
}
```
  
但是，本题要我们找的是 **最短路径**。

~~把所有死路堵上？~~ 显然是不可行的
  
那就...对了!可以加一个 **计步用的数组**!
  
**最先到达并返回** 的肯定是 **最短路径**！
  
证明的话...
  
由于广搜是 **几条路径同时进行的**，在这些路径中，肯定有一个会 **率先到达**，  **返回步数** 并 **结束该函数**。
  
还不明白看下图
  
 ![](http://www.bbvdd.com/d/201908221929166o6.png)
  
 在 **同时走两条路径时**，第二条没走完，第一条就已经 **走完并返回了**。
  
 _**所以能找到最短路径**_ 
  
------------
# Code
```cpp
#include<iostream>
#include<queue>
using namespace std;
struct Pos
{
	int x,y;
};
queue <Pos> q;
int n,x,y,tx,ty,dis[1001][1001],s_a,s_b,t_a,t_b;
const int dx[]={1,-1,0,0};
const int dy[]={0,0,1,-1};
char mp[1001][1001];
bool vis[1001][1001];
int bfs(int sx,int sy)
{
	q.push((Pos){sx,sy});
	vis[sx][sy]=true;
	while(!q.empty())
	{
		x=q.front().x;
		y=q.front().y;
		q.pop();
		if(x==t_a&&y==t_b) return dis[x][y];
		for(int i=0;i<4;i++)
		{
			tx=x+dx[i];
			ty=y+dy[i];
			if(tx<=0||tx>n||ty<=0||ty>n) continue;
			if(mp[tx][ty]=='1'||vis[tx][ty]==true) continue;
			dis[tx][ty]=dis[x][y]+1;
			vis[tx][ty]=true;
			q.push((Pos){tx,ty});
		}
	}
	return -1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)
	        cin>>mp[i][j];
	cin>>s_a>>s_b>>t_a>>t_b;
	cout<<bfs(s_a,s_b);
	return 0;
	
}
```


------------
## [**总用时 668ms，空间865b**](https://www.luogu.org/record/23168050)

---

## 作者：Ciyang (赞：36)

### 此题好像还没有启发式搜索A Star算法题解,我就水一发.
### 以下废话: 
#### 两三天我为了学A Star算法,随便找了这道BFS伪模板水题来练习,当时对A Star了解的不够深刻,因为自己的问题,只能拿40分.  
#### 经过三天的更深层研究后,终于找到了问题所在,修改代码后AC.
### 以下是A Star简介:
#### A Star算法通常用来寻路,是启发式搜索的一种,它与DFS,BFS搜索方式略不相同.如果你熟悉BFS就很好理解,因为BFS可以算是A Star算法中极端的一种.所以我打算将BFS与A Star进行比较说明.
#### 在BFS算法中,每一个格子向外扩展的优先级就是自己的步数,因为步数少的先进入搜索队列.在A Star算法中,每一个格子向外扩展的优先级需要计算,通过估步函数后,每个格子就带上了权值,代表它的优先级.
#### 再来看BFS,通常扩展后的格子放在普通的队列中,队列是先进先出的,所以先搜到的格子先进行扩展.而A Star算法一般使用优先队列(二叉堆),所以后进去的格子,有可能因为优先级高排在在队列前端,很快就开始扩展此格子,来搜索下一步.
#### 说到估步函数,一般叫[评价函数](https://baike.baidu.com/item/%E8%AF%84%E4%BB%B7%E5%87%BD%E6%95%B0),就是计算某个格子优先级的函数.在这个题中,要计算平面最短路径,所以f(优先级)=step(到达此格子的最小步数)+h(与终点的[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB))
### 先放上部分代码,再继续讲解:
```cpp
bool closelist[1002][1002], openlist[1002][1002];
//关闭列表和开放列表
struct node {
	int  x, y, step, f, h;
	void init(int _x, int _y, int _step) {
		x= _x;
		y= _y;
		step= _step;
		h= abs(x - wx) + abs(y - wy);
        //曼哈顿距离
		f= step + h;
        //f为已走步数+到达目标需要距离
	}
	void update(int _step) {
		step= _step;
		f= step + h;
	}
	int abs(int _a) {
		return _a > 0 ? _a : -_a;
	}
} newn[1002][1002];
struct nodecmp {
	bool operator()(node *&a, node *&b) const {
		if(a->f == b->f) return a->h > b->h;
		return a->f > b->f;
        //小根堆,f越低在小根堆里越靠前,f一样就选离目标近的
	}
};
int  lx, ly, lstep, newx, newy;
void Astar() {
	priority_queue<node *, vector<node *>, nodecmp> q;
    //优先队列存放的是指针,存放指针后默认是指针的从小到大排序
    //因此不能重载<运算符,要把比较函数写到一个类里
	newn[bx][by].init(bx, by, 0);
	q.push(&newn[bx][by]);
	while(!q.empty()) {
		lx= q.top()->x;
		ly= q.top()->y;
		lstep= q.top()->step;
		q.pop();
		closelist[lx][ly]= true;
        //将此点放到关闭列表,进行扩展
		for(int i= 0; i < 4; i++) {
			newx= lx + moves[i][0], newy= ly + moves[i][1];
			if(tmap[newx][newy] == '1' || closelist[newx][newy]) continue;
			if(newx == wx && newy == wy) {
            //到达目标结束搜索
				ans= lstep + 1;
				return;
			}
			if(openlist[newx][newy]) {
            //如果扩展后的点已经存在于开放列表
				if(lstep < newn[newx][newy].step) {
                //比较步数,更新扩展后的点
					newn[newx][newy].update(lstep + 1);
				}
			}
			else {
            //如果扩展后的点不存在于开放列表
				newn[newx][newy].init(newx, newy, lstep + 1);
				q.push(&newn[newx][newy]);
				openlist[newx][newy]= true;
                //将扩展后的点放入优先队列和开放列表中
			}
		}
	}
	return;
}

```
#### 我的代码还是可以优化的,有些地方为了写着容易而耗费了运行时间空间.
#### A Star在实现时有两个bool二维数组,一个优先队列(可以手写会更快).
#### 这两个bool二维数组分别是开放列表(OpenList)和关闭列表(CloseList),分别代表某个方格是否已经在队列中,某个方格是否已经向外扩展过
#### 我在代码中用优先队列存指针,不存指针而是存元素也可以,时间空间差不了太多,貌似是不用指针好,不用指针的话还可以省略更新节点的操作,只不断向优先队列push就够了(我感觉指针省空间,但结果相反)
#### 对于这个题,别的就没什么了,学会BFS搜索后,这种较为普通的A Star寻路只不过多了优先级.而对于更高深的启发式搜索题,才是A Star算法的真面目(~~好奇怪~~).
#### 若想更好了解学习A Star,可以试试 [【模板】k短路（[SDOI2010]魔法猪学院）](https://www.luogu.org/problemnew/show/P2483),就是有一个点卡A Star会MLE.
### 下面附上完整代码:
```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
#include <math.h>
#include <stdlib.h>
#include <limits.h>
using namespace std;
int  n, bx, by, wx, wy, moves[4][2]= {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}, ans;
bool closelist[1002][1002], openlist[1002][1002];
char tmap[1002][1002];
struct node {
    int  x, y, step, f, h;
    void init(int _x, int _y, int _step) {
        x= _x;
        y= _y;
        step= _step;
        h= abs(x - wx) + abs(y - wy);
        f= step + h;
    }
    void update(int _step) {
        step= _step;
        f= step + h;
    }
    int abs(int _a) {
        return _a > 0 ? _a : -_a;
    }
} newn[1002][1002];
struct nodecmp {
    bool operator()(node *&a, node *&b) const {
        if(a->f == b->f) return a->h > b->h;
        return a->f > b->f;
    }
};
int  lx, ly, lstep, newx, newy;
void Astar() {
    priority_queue<node *, vector<node *>, nodecmp> q;
    newn[bx][by].init(bx, by, 0);
    q.push(&newn[bx][by]);
    while(!q.empty()) {
        lx= q.top()->x;
        ly= q.top()->y;
        lstep= q.top()->step;
        q.pop();
        closelist[lx][ly]= true;
        for(int i= 0; i < 4; i++) {
            newx= lx + moves[i][0], newy= ly + moves[i][1];
            if(tmap[newx][newy] == '1' || closelist[newx][newy]) continue;
            if(newx == wx && newy == wy) {
                ans= lstep + 1;
                return;
            }
            if(openlist[newx][newy]) {
                if(lstep < newn[newx][newy].step) {
                    newn[newx][newy].update(lstep + 1);
                }
            }
            else {
                newn[newx][newy].init(newx, newy, lstep + 1);
                q.push(&newn[newx][newy]);
                openlist[newx][newy]= true;
            }
        }
    }
    return;
}
int main() {
    cin >> n;
    for(int i= 0; i <= n + 1; i++) {
        for(int j= 0; j <= n + 1; j++) {
            if(i == 0 || j == 0 || i == n + 1 || j == n + 1)
                tmap[i][j]= '1';
            else
                cin >> tmap[i][j];
        }
    }
    cin >> bx >> by >> wx >> wy;
    Astar();
    cout << ans << endl;
    return 0;
}

```

---

## 作者：Nick丶12138 (赞：13)

/\*
楼下大神们代码都看不懂（我太蒻了）

所以就自己打一遍

思路如下：

记录开始点和结束点的位置

开始点设为1，不能走回来

结束点不能设为1，不然走不到

搜索一遍就没了

\*/


```cpp
#include<cstdio>
#include<cstring>
int fx[4]={1,0,-1,0};
int fy[4]={0,1,0,-1};
char ma[1001][1001];//注意注意！！一点要用char，输入图的时候没有空格，int输入不了 
struct node{int x,y,c;}q[1100000];//(x,y)坐标，c是步数 
int n; 
void bfss(int stx,int sty,int enx,int eny)
//(stx,sty)起点位置，(enx,eny)终点位置 
{
    int tou=1,wei=2;//接下来几句就是一般的搜索了 
    q[tou].x=stx;q[tou].y=sty;//第一步在起点开始 
    q[tou].c=0;//走到起点需要0步 
    while(tou!=wei)
    {
        for(int i=0;i<4;i++)//四个方向可以走 
        {
            int xx=q[tou].x+fx[i];//xx等于当前步q[tou].x，fx[i]是偏移量 
            int yy=q[tou].y+fy[i];//yy同理 
            if(xx==enx&&yy==eny){printf("%d",q[tou].c+1);return;}//如果走到重点，输出当前步数加1（因为走到终点也算一步），然后结束 
            if(xx<1||xx>n||yy<1||yy>n||ma[xx][yy]=='1') continue;//如果出界或者不能走，跳过 
            ma[xx][yy]='1';//走过了封路 
            q[wei].x=xx;//走下一步 
            q[wei].y=yy;//走下一步 
            q[wei].c=q[tou].c+1;//步数加一 
            wei++;//前进 
        }
        tou++;//前进 
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",ma[i]+1);//只能这样输入，用%c会有BUG，会没有输出 
    }
    int sx,sy,ex,ey;scanf("%d %d %d %d",&sx,&sy,&ex,&ey);//输入起点终点坐标 
    ma[sx][sy]=1;//起点为1 
    bfss(sx,sy,ex,ey);//搜索 
    return 0;
}
```

---

## 作者：3493441984zz (赞：9)

**国庆节到了，准备充实一下自己**

~~于是就水了一波题解~~

这道题目相信学过宽搜的都能一眼看出这几乎是模板题！

思路大概是：利用队列**先进先出**的特性来保证答案要求步数最少

1.先把起点入队列（前提是输入之类的处理完之后，头指针=0，尾指针=1，**一定要记得封点！！**）

2.枚举队列头指针所在的上下左右四个点，判断是否能走，能的话入队列，把步数+1，**封点**，入队列

3.**头指针+1**

4.重复2,3步

如果还是不太懂的话可以参考一下代码。

~~~cpp
#include<iostream>
using namespace std;
const int dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};//x,y增量表示 
char g[2001][2001];//数字之间没有空格，所以用字符读入 
struct shu
{
	int ii,jj,bu;
}dui[4000002];//队列 
int n,i1,j1,i2,j2;//i1,j1为起点坐标，i2,j2为中点坐标 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>g[i][j];
		}	
	cin>>i1>>j1>>i2>>j2;//读入不解释 
	int head=0,tail=0;
	dui[tail].ii=i1;
	dui[tail++].jj=j1;
	g[i1][j1]='1';//封点 
	while(head<tail)
	{
		for(int i=0;i<4;i++)
		{
			int nx=dui[head].ii+dx[i],ny=dui[head].jj+dy[i];//枚举上下左右 
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&g[nx][ny]!='1')//这里要注意的是 nx>=1&&nx<=n&&ny>=1&&ny<=n不能与g[nx][ny]!='1' 调换，可能会越界 
			{
				if(nx==i2&&ny==j2)
				{
					cout<<dui[head].bu+1;
					return 0;
				}
				g[nx][ny]='1';
				dui[tail].ii=nx;
				dui[tail].jj=ny;
				dui[tail++].bu=dui[head].bu+1;
			}
		}
		head++;//头指针+1
	}
	cout<<"0";
	return 0;
} 
~~~
这篇题解希望初学宽搜的能够看懂，了解其中过程

有不会的请留言，我会回复的

如果本题解存在错误的话，欢迎指出

---

## 作者：HiroshiRealm (赞：9)

 蒟蒻最近学了宽搜（太蒟了），找了一堆水题刷刷，一下发现这题，然后爆零n次（n==1（滑稽））
 
 好了，言归正传，这题我们可以用BFS，BFS适用于最短步数（比如这题），应为蒟蒻不会写STL的queue，就手写了一个
 
 我们可以开一个结构体，储存每次的情况（坐标和步数）
 
 还有一个小技巧，我看楼下dalao全都用字符读入，本蒟蒻不会（滑稽），就直接读入数字（骄傲）
 
 ### 提示：队列一定要开大一点，我是深思熟虑（30 second）后发现的
 
 上代码
 ```
#include <iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
struct node{
    int x;
    int y;
    int step;
}Queue[10000000];
int  head,rear,a,b,c,mp[2000][2000],d,e,ans;
int main() {
    scanf("%d",&a);
    for(int x=1;x<=a;x++){
        for(int y=1;y<=a;y++){
            scanf("%1d",&mp[x][y]);//读入一位数
            mp[x][y]=1-mp[x][y];//我改了一下读入，这样可以省去下面的去重
        }
    }
    scanf("%d%d%d%d",&b,&c,&d,&e);
    head=1;rear=1;
    Queue[1].x=b;
    Queue[1].y=c;
    mp[b][c]=0;
    while(head<=rear){//大量重复，dalao请原谅
        int i,j;
        i=Queue[head].x;
        j=Queue[head].y;//小技巧：这样每一次只要改和j，不用Queue队列了
        if(Queue[rear].x==d&&Queue[rear].y==e){
            ans=Queue[rear].step;break;
        }
        i++;
        if(mp[i][j]==1){
            Queue[++rear].x=i;
            Queue[rear].y=j;
            Queue[rear].step=Queue[head].step+1;
            mp[i][j]=0;
        }
        if(Queue[rear].x==d&&Queue[rear].y==e){
            ans=Queue[rear].step;break;
        }        i-=2;
        if(mp[i][j]==1){
            Queue[++rear].x=i;
            Queue[rear].y=j;
            Queue[rear].step=Queue[head].step+1;
            mp[i][j]=0;
        }
        if(Queue[rear].x==d&&Queue[rear].y==e){
            ans=Queue[rear].step;break;
        }        i++;j++;
        if(mp[i][j]==1){
            Queue[++rear].x=i;
            Queue[rear].y=j;
            Queue[rear].step=Queue[head].step+1;
            mp[i][j]=0;
        }
        if(Queue[rear].x==d&&Queue[rear].y==e){
            ans=Queue[rear].step;break;
        }
        j-=2;
        if(mp[i][j]==1){
            Queue[++rear].x=i;
            Queue[rear].y=j;
            Queue[rear].step=Queue[head].step+1;
            mp[i][j]=0;
        }
        if(Queue[rear].x==d&&Queue[rear].y==e){
            ans=Queue[rear].step;break;
        }
        head++;
    }
    printf("%d",ans);
        return 0;
}

```

---

## 作者：zjy111 (赞：7)

这道题是很典型的搜索题

看各位神犇都在用什么启发式之类的高级东西，感觉有点杀鸡用牛刀了（不过P1001的题解更是如此）用宽搜就可以啦~~~

所谓宽搜，就是每一次搜索时把与之相邻的几个点全部搜索一遍，然后记录这些点和起点之间的距离，再从这些点开始向周围展开搜索，因为方向四面八方，故得名为BFS（宽度优先搜索）。这个算法可以找到边数最短的路径。也就是说当所有边权相同时（这题都是1），可以找到最短路。可以通过先进先出的队列来实现。更多关于宽搜的知识可以[点击这里](https://oi-wiki.org/graph/bfs/)

献上码风奇特的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[1005][1005];  //记录地图
bool gone[1005][1005]={0};  //记录某个点是否被访问
int ans[1005][1005]={0};  //记录答案
int drct[4][2]={{1,0},{0,1},{-1,0},{0,-1}};  //方向数组，只能朝4个方向走（上下左右）
struct p{
	int x=0,y=0; //结构体定义，表示每个点坐标
}p1,p2,pp;  //起点，终点，遍历点
int main(){
	int n,i,j;
	scanf("%d\n",&n);
	queue<p>q;  //建队
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++)
		    cin>>mp[i][j];
	}
	cin>>p1.x>>p1.y>>p2.x>>p2.y; //输入起终点
	pp.x=p1.x;pp.y=p1.y; //从起点开始
	q.push(pp);  //加入队列
	gone[pp.x][pp.y]=1;  //标记为已访问
	while(!q.empty()){  //重复直到队列为空
		p p3=q.front();  //取遍历点
		q.pop();  //删点
		p tmp;  //中间点
		for(i=0;i<4;i++){   //向4个方向遍历
			tmp.x=p3.x+drct[i][0];
			tmp.y=p3.y+drct[i][1];
			if(tmp.x>0&&tmp.x<=n&&tmp.y>0&&tmp.y<=n&&!gone[tmp.x][tmp.y]&&mp[tmp.x][tmp.y]=='0'){ //x，y没有越界；该点没有被访问而且是条路才遍历
				ans[tmp.x][tmp.y]=max(ans[tmp.x][tmp.y],ans[p3.x][p3.y]+1);//到该点的距离是到上一个点的距离+1
				gone[tmp.x][tmp.y]=1;  //标记为已访问
				if(tmp.x==p2.x&&tmp.y==p2.y){   //到达终点
					printf("%d",ans[p2.x][p2.y]);  //输出并结束
					return 0;
				}
				q.push(tmp); //将这个点加入队列，准备进一步搜索
			}
		}
	}
}
```


---

## 作者：梁丘封冽 (赞：7)

大家好我是KM_YoaMoa

一个刚学OI的蒟蒻QwQ

这是我写的第一篇题解

之前看到的BFS题解觉得不是很好QwQ搜索时用了一堆if语句,这样调试起来比较困难,代码也长QwQ于是写了一篇自我感觉还行的

```cpp
#include<bits/stdc++.h>

using namespace std;

queue<int> qx;
queue<int> qy;
queue<int> qs;//定义x,y,和step的队列 
char Map[1001][1001];//储存地图 
bool usd[1001][1001];//储存标记 
int n;//地图大小 
int sx, sy, ex, ey;//起点和终点 
int movex[] = {0, 0, 1, 0, -1};
int movey[] = {0, 1, 0, -1, 0};//这样写方便修改代码也短 

int bfs() {
	qx.push(sx);
	qy.push(sy);
	qs.push(0); 
	while(! qx.empty()) {
		int vs = qs.front();
		int vy = qy.front();
		int vx = qx.front();
		qs.pop();
		qx.pop();
		qy.pop();
		
		//cout << vx << " " << vy << endl;
		
		if(vx == ex && vy == ey) return vs;//到达终点时直接返回 
		
		for(register unsigned int i = 1; i <= 4; ++i) {
			int mx = vx + movex[i];
			int my = vy + movey[i];
			if(usd[my][mx] || Map[my][mx] == '1' || mx < 1 || my < 1 || mx > n || my > n) {
				continue;
			}
			usd[my][mx] = true;
			qx.push(mx);
			qy.push(my);
			qs.push(vs + 1);
		}//这样就不用写一堆if了 
	}
}

int main(void) {
	cin >> n;
	for(register unsigned int i = 1; i <= n; ++i) {
		for(register unsigned int j = 1; j <= n; ++j) {
			cin >> Map[i][j];//字符输入可以不用空格 
		}
	}
	cin >> sy >> sx >> ey >> ex;
	cout << bfs();//输出答案
	while(1) cout << endl;
	return 0;
}
```

大佬肯定有很多优化的方法(反正我是看不懂了)这篇题解供新手参考


---

## 作者：YellowBean_Elsa (赞：4)

# 浅谈A*

1.A*是一种常用来寻找路径的启发式搜索，在普通搜索中加入了估值函数。

2.A*用于优先队列BFS，每次从队列中取出估值函数最大或最小的元素，当然也要优先考虑实际因素（比如本题中是各点步数）。

（其实本题用A** 会使最差情况的时间复杂度多一个log）

3.估值函数的设计很大程度上影响了程序的效率，学习A*要重点练习估值函数的设计。

**4.理解估值函数的意义**: 估值函数是对一个元素达到目标状态还需“步数”的估计。此估计应小于等于其实际值，否则会WA。

### 回到这道题

**估值函数**：每个点到终点的曼哈顿距离与当前步数之和（这种估值函数在方格问题中很常用）

剩下就是人人都会的BFS了：


```cpp
//A*(第一次写，勿喷谢谢)
#include<iostream>
#include<cmath>	
#include<queue>	
#include<stdio.h>
#include <math.h>
#include <stdlib.h>						
using namespace std;							
int n,x1,x2,yy1,yy2;
int map[1005][1005],guess_dist[1005][1005];//map：是否能走。
// guess_dist：各点到终点曼哈顿距离 
int dx[5]={0,-1,0,1,0};
int dy[5]={0,0,1,0,-1};
bool vis[1005][1005];//别学了A*把普通的剪枝给忘了（QAQ那不是myself吗） 
struct point{
	int x,y,dist;
	int estimate;//估值 
	//为了优先队列，我们重载运算符！ 
	bool operator < (const point &A)const{
		if(dist!=A.dist)return dist>A.dist;//这行不能少
		//本题没有这行会快很多，但会WA一个点
		//就算有估值，我们也应该先考虑步数少的点。A*的正确性还是要保证的 
		return estimate>A.estimate;
	} 
};
priority_queue<point> q;
inline void get(point &A){
	A.estimate=guess_dist[A.x][A.y]+A.dist;
}//计算估值 
point s,t[5];
char c;
inline void init_queue(){
	s.x=x1,s.y=yy1,s.dist=0;
	vis[s.x][s.y]=1;
	get(s);q.push(s);
}//把起点推入队列 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++){
    		scanf("%1d",&map[i][j]);//读入一位数的骚操作 
    		map[i][j]^=1;//根据题意，map中的0，1与输入的相反
						 //用xor 1 把0变1，1变0 
		}	
	scanf("%d%d%d%d",&x1,&yy1,&x2,&yy2);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			guess_dist[i][j]=abs(i-x2)+abs(j-yy2);//求曼哈顿距离 
	init_queue();
	while(q.size()){
		t[1]=t[2]=t[3]=t[4]=q.top();
		q.pop();
		for(int i=1;i<=4;i++){
			t[i].x+=dx[i];t[i].y+=dy[i];
			t[i].dist++;
			if(t[i].x==x2 && t[i].y==yy2){
				printf("%d\n",t[i].dist);
				return 0;//到达目的地，本次运行结束 
			}
			get(t[i]);
			if(map[t[i].x][t[i].y] && !vis[t[i].x][t[i].y]){
				q.push(t[i]);
				vis[t[i].x][t[i].y]=1;//不要忘了剪枝！ 
			}
		}
	}
    return 0;														
}

```
A* 还可以用在迭代加深DFS里面，成为“IDA*”。

蒟蒻我不会，大家可以去问这位巨佬：

[咱杭州文澜中学rockyyh](https://www.luogu.org/space/show?uid=36361)


---

## 作者：Mignon (赞：4)

这题其实很容易想到BFS的做法，可是本蒟蒻发现我根本看不懂各位大神们的做法，点点点点点点。所以我就放上了我的代码。

首先要定义一个STL中的队列（STL真是个好东西）以及两个数组（分别用来存储地图和标记），把起点的横纵坐标放入队列中，然后利用队列头的横纵坐标扩展出上下左右的路线。找到目的地就可以终止循环了。(＾－＾)V

Finnish，ヾ(◍°∇°◍)ﾉﾞ。

```cpp
#include<bits/stdc++.h>
using namespace std ;
queue<int> q ; // STL中的队列
void check( int c , int d , int s ,int t ) ;
int n , x , y , a , b ;
int flag[2100][2100] , 	l[2100][2100] ;

int main()
{
	memset( flag , -1 , sizeof(flag) ) ;
	cin >> n ;
	for( int i = 1 ; i <= n ; i ++ )
	{
		string tmp ;
		cin >> tmp ;
		for( int j = 1 ; j <= n ; j ++ )
		{
			l[i][j] = tmp[j-1] - '0' ;
		}
	}
	cin >> x >> y >> a >> b ;
	q.push(x) ;
	q.push(y) ;
    // 把起点的横纵坐标放入队列
	flag[x][y] = 0 ;
	while( true )
	{
		if( q.empty() ) break ;
		int s = q.front() ;
		q.pop() ;
		int t = q.front() ;
		q.pop() ;
		if( s == a && t == b ) // 到达目的地
		{
			cout << flag[s][t] ;
			return 0 ;
		}
		check(1,0,s,t) ; 
		check(0,1,s,t) ;
		check(-1,0,s,t) ; 
		check(0,-1,s,t) ; 
        // 检查上下左右的点
	}
	return 0 ;
} 

void check( int c , int d , int s , int t ) // 检查路线是否合格
{
	if( l[s+c][t+d] == 1 ) return ;
	if( flag[s+c][t+d] == -1 )
	{
		if( ( s + c > 0 && s + c <= 1200 ) && ( t + d > 0 && t + d <= 1200 ) ) 
		{
			q.push(s+c) ;
			q.push(t+d) ;
			flag[s+c][t+d] = flag[s][t] + 1 ;
		}
	}
	return ;
}
```

---

## 作者：liujian (赞：4)

这一题...~~完全是裸的广搜啊~~

稍微有一点坑的是读入的数字之间没有空格（~~虽然这很常见~~），用字符串读入就没问题了。

下面贴本蒟蒻的代码（仅供参考）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
struct node
{
    int x,y,dep;//x储存横坐标，y储存纵坐标，dep储存步数
}list[1000010];//如果用万能库不能用list做变量名
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};//增量
int b[1010][1010];//判断是否能走
bool vis[1010][1010];//判断是否走过
char a[1010];
int main()
{
	while (1);//防抄袭
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    { 
        scanf("%s",a+1);//a+1使字符数组由下标1开始（这只是本蒟蒻的习惯）
        for(int j=1;j<=n;j++) 
        { 
            if (a[j]=='0') b[i][j]=1;
        } 
    } 
    int x1,x2,y1,y2;
    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
    int head=0,tail=1;
    list[1].x=x1;list[1].y=y1;list[1].dep=0;vis[x1][y1]=1;//起点入队列
    while (head!=tail)
    {
        head++;//头指针+1
        for (int i=0;i<4;i++)枚举增量
        {
            int xx=list[head].x+dx[i],yy=list[head].y+dy[i];
            if (xx<=n&&xx>=1&&yy<=n&&yy>=1&&!vis[xx][yy]&&b[xx][yy])//判断是否越界
            {
                tail++;//尾指针+1
                list[tail].x=xx;list[tail].y=yy;//当前点入队
                vis[xx][yy]=1;//当前点设为已走过
                list[tail].dep=list[head].dep+1;//步数+1
                if (xx==x2&&yy==y2)//若以到达终点，则输出此时的步数，第一次搜到终点时的步数一定最小
                {
                    printf("%d",list[tail].dep);
                    return 0;
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：Create_Random (赞：3)

看到题解区里都是广搜。

本蒟蒻就补一发SPFA~

思路:

只要相邻两个数都是$0$.

就把这两个数之间建边。

本蒟蒻标点方式:

![](https://cdn.luogu.com.cn/upload/image_hosting/bvei5rtk.png?x-oss-process=image/resize,m_lfit,h_400,w_400)

如果枚举到的点是$0$.

就向四周是$0$的点连边。

而且不用连双向边！（废话）

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int l1,r1;
int l2,r2;
char a[1010][1010];
struct node
{
    int to;
    int w;
};
vector<node>g[1000010];
queue<int>q;
bool inq[1000010];
int dis[1000010];
void spfa(int s)
{
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push(s);
    inq[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        inq[u]=0;
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i].to,w=g[u][i].w;
            if(dis[v]>dis[u]+w)
            {
                dis[v]=dis[u]+w;
                if(!inq[v])
                {
                    q.push(v);
                    inq[v]=1;
                }
            }
        }
    }
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='0')
			{
				a[i][j]='2';//防止向边界外连边。
			}
		}
	}
	scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			node tmp;
			tmp.w=1;
			if(a[i][j]=='2')
			{
				if(a[i-1][j]=='2')
				{
					tmp.to=(i-1)*n+j-n;
					g[(i-1)*n+j].push_back(tmp);//向上连边。
				}
				if(a[i+1][j]=='2')
				{
					tmp.to=(i-1)*n+j+n;
					g[(i-1)*n+j].push_back(tmp);//向下连边。
				}
				if(a[i][j-1]=='2')
				{
					tmp.to=(i-1)*n+j-1;
					g[(i-1)*n+j].push_back(tmp);//向左连边。
				}
				if(a[i][j+1]=='2')
				{
					tmp.to=(i-1)*n+j+1;
					g[(i-1)*n+j].push_back(tmp);//向右连边。
				}
			}
		}
	}
	spfa((l1-1)*n+r1);//计算从起始点的最短路
	printf("%d",dis[(l2-1)*n+r2]);//输出到终点的最短路
	return 0;
}
```


---

## 作者：cxy004 (赞：3)

呐，好水のBFS

为了用STL的队列把每个点的x坐标和y坐标都减1

```cpp
#include<cstdio>
#include<queue>
using namespace std;

const int t[4][2]={{-1,0},{0,-1},{0,1},{1,0}};
int n,x1,x2,y1,y2,f[1001][1001],e[1001][1001];
queue<int>q;

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) {scanf("%1d",&e[i][j]);f[i][j]=-1;}
    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);f[x1-1][y1-1]=0;
    for(q.push(x1*n-n+y1-1);q.size();q.pop())
    {
      int x=q.front()/n,y=q.front()%n;
      for(int i=0;i<=3;++i)
      {
        int fx=x+t[i][0],fy=y+t[i][1];
        if((fx>=0)&&(fy>=0)&&(fx<n)&&(fy<n)&&(!e[fx][fy])&&(f[fx][fy]==-1)) {f[fx][fy]=f[x][y]+1;q.push(fx*n+fy);}
      }
    }
    printf("%d",f[x2-1][y2-1]);
    return 0;
}
```

---

## 作者：二元长天笑 (赞：3)

这道题是可以用搜索做的，在这里推荐广搜，然后天笑看到这里C++的题解比较少，所以就过来补一补，这里我用了手工队列，理解起来会容易一点。

这里要注意的是输入时没有空格，要用字符串，还有在搜索时要注意边界值。

```cpp
#include<iostream>
#include<string>
using namespace std;
int p1[4]={1,0,0,-1},p2[4]={0,1,-1,0},n,m,x,y,sx[10001],sy[10001],sa[10001],head,tail=1,ex,ey;
//p1,p2是搜索时向上下左右四个方向的坐标控制数组 ，sx是x坐标的队列，sy是y坐标的队列，sa是步数队列 
bool l[1001][1001]={0};//记录当前点能否走或是否走过 
string s;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        for(int j=0;j<n;j++)//提取地图元素，因为没空格，要用字符串 
            if(s[j]=='1')
                l[i][j+1]=1;//标记无法走
    }
    cin>>x>>y>>ex>>ey;
    sx[1]=x;//把初始坐标入队 
    sy[1]=y;
    do
    {
        head++;
        for(int i=0;i<4;i++)//尝试4个方向 
        {
            if(!l[sx[head]+p1[i]][sy[head]+p2[i]]&&sx[head]+p1[i]>=1&&sx[head]+p1[i]<=n&&sy[head]+p2[i]>=1&&sy[head]+p2[i]<=n)//检查是否走过或是否越界 
            {
                l[sx[head]+p1[i]][sy[head]+p2[i]]=1;//走过记录 
                tail++;
                sa[tail]+=sa[head]+1;//步数累计加1 
                sx[tail]=sx[head]+p1[i];//成立坐标入队 
                sy[tail]=sy[head]+p2[i];
                if(sx[tail]==ex&&sy[tail]==ey)//如果到达终点就输出 
                {
                    cout<<sa[tail]<<endl;
                    return 0;//直接结束，节省时间 
                }
            }
        }
    }while(head<tail);
}
```

---

## 作者：LikeJ (赞：2)

## ***离开中山路***
**题目描述**
爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在x1,y1处，车站在x2,y2处。现在给出一个n×n（n<=1000）的地图，0表示马路，1表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（a[i][j]距离为1）。你能帮他解决吗？
**输入格式**
第1行：一个数 n
第2行~第n+1行：整个地图描述（0表示马路，1表示店铺，注意两个数之间没有空格）
第n+2行：四个数 x1,y1,x2,y2
**输出格式**
只有1行：最短到达目的地距离
**输入输出样例**
**输入**
3
001
101
100
1 1 3 3
**输出**
4
**分析**
这道题我们可以用深搜（BFS）来做
十分简单，就是个队列，可以参考[
电子老鼠闯迷宫（BFS）](https://blog.csdn.net/weixin_45524309/article/details/103428660)
来做
**AC代码**
```cpp
#include<iostream>
int n,x1,y1,x2,y2,head,tail,a[1005][1005],st[1000005][3];
int dx[9]={0,1,-1,0,0};
int dy[9]={0,0,0,1,-1};
char ch;
void bfs()
{
	while(head<tail)//套广搜模板
	{
		head++;
		for(int i=1;i<=4;i++)//四个方向
		 {
		 	int x=st[head][0]+dx[i],y=st[head][1]+dy[i];
		 	if(x>=1&&x<=n&&y>=1&&y<=n)//边界
		 	 if(a[x][y]==0)//是否判断过
		 	  {
		 	  	tail++;
		 	  	a[x][y]=1;//标记
		 	  	st[tail][2]=st[head][2]+1;//最短路径
			    st[tail][0]=x;st[tail][1]=y;//更新坐标
			    if(x==x2&&y==y2)return;//如果到目标点就退出
			  }
		 }
	}
}
using namespace std;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++)
	  {cin>>ch;a[i][j]=ch-48;}//输入
	cin>>x1>>y1>>x2>>y2;
	st[1][0]=x1;st[1][1]=y1;//坐标
	a[x1][y1]=1;//标记
	tail=1;//初值
	bfs();
	cout<<st[tail][2];
}
```
## ***谢谢***

---

## 作者：RenaMoe (赞：2)

**BFS+queue**不用说了

但是：

STL的queue太慢。。。

手写queue太丑。。。

于是手工封装queue

实测：
![](https://s2.ax1x.com/2019/07/27/eKhUsK.png)

上代码（inline等是常数优化，另外[关于namespace的技巧](https://banana.blog.luogu.org/tong-guo-namespace-fang-zhi-ming-ming-chong-tu)）

```cpp
#include <cstdio>
#include <cstring>

using namespace std;

namespace BANANA {

#define N 1005

struct Node {
	int x, y;
};

struct queue {// 手工封装queue 
	Node a[N*N];
	int head, tail;
	queue() {// queue初始化 
		head = 0, tail = -1;
	}
	inline void push(int x, int y) {
		a[++tail] = (Node){x, y};
	}
	inline void pop() {
		head++;
	}
	inline bool empty() {
		return tail < head;
	}
	inline Node front() {
		return a[head];
	}
};

int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};// 偏移量，懒得分类讨论 
int n, sx, sy, ex, ey;// sx,sy起点，ex,ey终点 
char map[N][N];// 输入地图 
int ans[N][N];// ans[i][j]记录到i,j的步数 
queue q;

inline void bfs() {
	memset(ans, -1, sizeof ans);// 先全设为-1表示都未访问过 
	ans[sx][sy] = 0;
	q.push(sx, sy);
	while (!q.empty()) {
		Node u = q.front();
		q.pop();
		for (int i = 0; i < 4; i++) {// 利用dx[],dy[]减少码量 
			int x = u.x + dx[i], y = u.y + dy[i];
			if (x > 0 && x <= n && y > 0 && y <= n && map[x][y] == '0' && ans[x][y] == -1) 
				ans[x][y] = ans[u.x][u.y] + 1, q.push(x, y);// 当ans[i][j]!=-1时，相当于标记为已访问过 
			if (x == ex && y == ey)//找到车站就直接返回 
				return;
		}
	}
}

inline void main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%s", map[i]+1);
	scanf("%d%d%d%d", &sx, &sy, &ex, &ey);
	bfs();
	printf("%d\n", ans[ex][ey]);
}
}

int main() {
	BANANA::main();
	return 0;
}
```

---

## 作者：Snoaple (赞：2)

本题为蒟蒻刚学宽搜的练习题（~~那你还敢写题解~~）

因为求的是最小路径，所以果断选择BFS（~~笨法师~~）

最后把步数用另一个数组储存，每次进队都 

inc(t);a[t]:=a[h]+1;

每次t加一就判断到了终点没

到了就输出a[t]

附上AC代码

```pascal
const
  dx:array[1..4] of integer=(0,0,-1,1);
  dy:array[1..4] of integer=(-1,1,0,0);
var
  n,i,j,x,y,x1,y1:longint;
  a:array[0..1000,0..1000] of char;
  d:array[0..1000,0..1000] of longint;
  procedure try(x,y:longint);
    var
      h,t,l:longint;
      xl,yl:array[0..1000000] of longint;
    begin
      h:=0;t:=1;
      xl[1]:=x;
      yl[1]:=y;
      a[x,y]:='1';
      repeat
       inc(h);
       for l:=1 to 4 do
        begin
         x:=xl[h]+dx[l];
         y:=yl[h]+dy[l];
         if (x>0) and (x<=n) and (y>0) and (y<=n)
           and (a[x,y]='0') then
          begin
           inc(t);
           xl[t]:=x;
           yl[t]:=y;
           a[x,y]:='1';
           d[x,y]:=d[x-dx[l],y-dy[l]]+1;
           if (x=x1) and (y=y1) then begin writeln(d[x,y]); halt; end;
          end;
        end;
      until h=t;
    end;
begin
  readln(n);
  for i:=1 to n do
   begin
    for j:=1 to n do
     read(a[i,j]);
    readln;
   end;
  readln(x,y,x1,y1);
  try(x,y);
end.
```

---

## 作者：墨凝而止 (赞：2)

```delphi
const f1:array[1..4]of shortint=(-1,0,1,0);｛x坐标增量｝
      f2:array[1..4]of shortint=(0,1,0,-1);｛y坐标增量｝
var
a:array[0..1000,0..1000]of longint;｛标记｝
b:array[1..1000000,1..2]of longint;｛队列｝
min,i,j,k,n,x1,x2,y1,y2:longint;
s:ansistring;
procedure gs;｛广搜｝
var i,j,k,l,p,q:longint;
begin
  p:=1;q:=2;｛头尾指针初始化｝
  b[p,1]:=x1;b[p,2]:=y1;｛记录｝
  repeat
  for i:=1 to 4 do
  begin
  if (b[q-1,1]=x2)and(b[q-1,2]=y2) then
  begin write(a[x2,y2]-1);｛因为起点已经值为1，所以需要将储存的步数-1｝
halt;end;
    k:=b[p,1]+f1[i];l:=b[p,2]+f2[i];
    if (k>0)and(k<=n)and(l>0)and(l<=n)and(a[k,l]=0)｛不越界，且未走过｝ then
    begin
      b[q,1]:=k;｛记录｝
      b[q,2]:=l;
      a[k,l]:=a[b[p,1],b[p,2]]+1;｛走一步｝
      inc(q);
    end;
  end;
  inc(p);
  until p=q;｛拓展完毕｝
end;
begin
 readln(n);
 for i:=1 to n do
 begin
  readln(s);
  for j:=1 to n do val(s[j],a[i,j]);
 end;
 read(x1,y1,x2,y2);
 a[x1,y1]:=1;
 gs;
end.
```
[color=green]此题适宜使用广度优先搜索。b为队列，a为标记数组。是为解。[/color]


---

## 作者：Archers_wylr (赞：1)

```c
/************************************************************
广度优先搜索算法的基本思想：
1、对于初始状态入队，设置初始状态为已访问
2、如果队列不为空时，出队队头元素，否则跳到第5步
3、检查出队的元素是否为最终解，如果是则跳到第5步。
4、对于出队的元素，检查所有相邻状态，如果有效并且未访问，则将
   所有有效的相邻状态进行入队，并且设置这些状态为已访问，然后
   跳到第2步重复执行
5、检查最后出队的元素是否为最终解，如果是输出结果，否则说明无解

广度优先搜索是借助于队列这种数据结构进行搜索的，队列的特点是先
进先出（FIFO），通过包含queue这个队列模板头文件，就可以利用c++
的队列模板定义自己的队列了，队列的操作非常简单，主要有以下几个：
q.push() 入队操作
q.front() 取队头元素
q.pop() 队头元素出队
q.size() 获取队列的元素个数
q.empty() 判断队列是否为空，为空返回true，不为空返回false

广度优先搜索算法的关键是要搞清楚求解过程中每一步的相邻状态有哪些，
每个状态需要记录什么信息，在搜索过程中如何标记这些状态为已访问。
*/
#include <bits/stdc++.h>//万能头文件
using namespace std;
int mapp[1005][1005];//定义我们的地图
int vis[1005][1005];//记录我们有没有走过这个地方
struct Node{
	int x,y;//结构体维护数组
	int step;//分别记录横纵坐标，以及当前的步数
}m[2500005];
int qx,qy,tx,ty;//qx,qy起点,tx,ty终点
int n,front,rear;//n为地图大小，front,rear,分别为队列的头指针和尾指针
Node s;//用一个我们定义的类型作为while循环中取出的队头
int ans;//保存最终答案
int main()
{	
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%1d",&mapp[i][j]);//不能用cin,因为输入是没有空格的
	cin>>qx>>qy>>tx>>ty;//读入起点终点
	mapp[qx][qy]=1;//先将起点特殊处理，防止走回到起点
	m[rear].x=qx;//这就是上面所说的将初始状态入队
	m[rear].y=qy;//分别入队x,y,step
	m[rear].step=0;
	rear++;
	while(front!=rear){//只要我们的队列不为空
		s=m[front];//取出队头元素
		front++;
		if(s.x==tx&&s.y==ty){//如果我们走到了的话，直接保存当前的步数，也就是题目中的距离，并退出循环
			ans=s.step;
			break;
		}
		if(s.x+1<=n&&mapp[s.x+1][s.y]==0&&vis[s.x+1][s.y]==0){
        //考虑四个方向，如果不出界，是道路，没走过，三个条件满足，我们就走，下同
			m[rear].x=s.x+1;//将该状态入队
			m[rear].y=s.y;
			m[rear].step=s.step+1;
			rear++;
			vis[s.x+1][s.y]=1;
		}
		if(s.x-1>=1&&mapp[s.x-1][s.y]==0&&vis[s.x-1][s.y]==0){
			m[rear].x=s.x-1;
			m[rear].y=s.y;
			m[rear].step=s.step+1;
			rear++;
			vis[s.x-1][s.y]=1;
		}
		if(s.y+1<=n&&mapp[s.x][s.y+1]==0&&vis[s.x][s.y+1]==0){
			m[rear].x=s.x;
			m[rear].y=s.y+1;
			m[rear].step=s.step+1;
			rear++;
			vis[s.x][s.y+1]=1;
		}
		if(s.y-1>=1&&mapp[s.x][s.y-1]==0&&vis[s.x][s.y-1]==0){
			m[rear].x=s.x;
			m[rear].y=s.y-1;
			m[rear].step=s.step+1;
			rear++;
			vis[s.x][s.y-1]=1;
		}
	}
	cout<<ans;//输出最终结果
	return 0;
}
*/
------------
这是标准的BFS作法，希望能够帮到大家
------------



---

## 作者：_maze (赞：1)

本蒟蒻最近学了BFS,把这题当成水题刷刷

这道题一看到最短距离就应该想到BFS,但你坚持要用DFS我也不反对[（一位dalao的提交记录）](https://www.luogu.org/recordnew/show/3109492 )……

1、这种题直接用cpp自带的queue就可以了，用数组模拟还要考虑范围

2、用字符读入再转数字时可以-48也可以-'0'~~dalao可以无视~~

上代码

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,m,sta,stb,a[1004][1004],fx[4]={1,-1,0,0},fy[4]={0,0,-1,1},lx,ly,lol[1004][1004];//这里离散化就可以了，不然要if好久
string pop[1005];
struct node{//定义一个结构体，内部装着每一个点的信息
	int x;
	int y;
	int he;//距离之和
}cur;//创建一个结构体用于存储现在的位置的信息
void bfs(int x,int y){
	queue <node>q;//创造队列
	int u=0;
	cur.x=sta;//初始化
	cur.y=stb;//初始化
	cur.he=0;//初始化
	q.push(cur);//将cur（起点）放至队列中
	lol[sta][stb]=1;//起点需额外赋值 
	while(q.empty()==false){
		cur=q.front();//提取
		q.pop();//弹出
		if(cur.x==lx&&cur.y==ly){//如果到达目的地 
			cout<<cur.he;//输出 
			return ;
		}
		for(int r=0;r<4;r++){//向八个方向探索
			int xx=cur.x+fx[r];
			int yy=cur.y+fy[r];
			if(xx>0&&yy>0&&xx<=n&&yy<=n&&lol[xx][yy]==0&&a[xx][yy]==0){//判断是否越界及是否符合条件
				node next;//下一步要走的地方
				next.x=xx;//赋值
				next.y=yy;//赋值
				next.he=cur.he+1;//赋值
				lol[xx][yy]=1;
				q.push(next);//next进队列
			}
		}		
	}
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>pop[i];
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			a[i+1][j+1]=pop[i][j]-'0';//将字符转化为数字 
		}
	}
	cin>>sta>>stb>>lx>>ly;
	bfs(sta,stb);//bfs
	return 0;//完美结束?
}

```


---

## 作者：ahhsst (赞：1)

queue 是个好东西······
蒟蒻的无奈
这是一个~~dfs~~bfs·····
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int step,x,y;
}d,dd;
queue <node> q;
int a[1010][1010],qx,qy,zx,zy,n;
int dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};
int main(){
	char c;//数据之间无空格
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			cin>>c;
			if(c=='1')
				a[i][j]=0;//个人比较喜欢取反，可以无视这块
			else
				a[i][j]=1;
		}
	cin>>qx>>qy>>zx>>zy;
	a[qx][qy]=0;
	if(qx==zx&&qy==zy){
		cout<<0<<endl;
		return 0;
	}
	d.x=qx;d.y=qy;d.step=0;
	q.push(d);
	while(!q.empty()){
		d=q.front();
		dd.step=d.step+1;//步数++
		for(int i=1;i<=4;i++)
			if(a[d.x+dx[i]][d.y+dy[i]]){
				a[d.x+dx[i]][d.y+dy[i]]=0;
				dd.x=d.x+dx[i];//生成新的坐标
				dd.y=d.y+dy[i];
				if(dd.x==zx&&dd.y==zy){//入队时判断
					cout<<dd.step<<endl;
					return 0;//出去
				}
				q.push(dd);//入队
			}
		q.pop();//出队
	}

	return 0;
}

```

---

## 作者：李若谷 (赞：0)

## 双向BFS

看了看题解，很多大佬都用A*，但是我又不想用普通BFS ~~(装逼)~~ 于是用了双向BFS

什么是双向BFS?
普通BFS就是从起点开始扩展，一直到终点然后结束。双向BFS是起点和终点一起扩展，如果相遇就代表找到了答案，并且答案为起点扩展的次数+终点扩展的次数。

据说，时间复杂度会从 2^k 降到 2^(k/2)次方

如果一道广搜题，知道目标（终点）的话，就可以试试用双向bfs，速度提高不少。一些很经典的BFS题如八数码，子串变换等都可以用双向bfs。

代码后还有一些解释

AC代码 265ms:

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
const int N = 1500;
char a[N][N];
int n;
int sx,sy,ex,ey;
queue <pair<int,int> > start;
queue <pair<int,int> > final;
int steps[N][N];
int stepe[N][N];
const int dx[4] = {-1,1,0,0};
const int dy[4] = {0,0,-1,1};
int bfs()
{
	start.push(make_pair(sx,sy));
	final.push(make_pair(ex,ey));
	steps[sx][sy] = 0;
	stepe[ex][ey] = 0;
	if(sx==ex&&sy==ey)
	{
		return 0;
	}
	while(!start.empty()||!final.empty())
	{
		int lens = start.size();
		int lene = final.size();
		// 正向
		for(register int i=0;i<lens;i++)
		{
			int curx = start.front().first, cury = start.front().second;
			start.pop();
			for(register int j=0;j<4;j++)
			{
				int xx = curx+dx[j];
				int yy = cury+dy[j];
				if(a[xx][yy] == '0' &&xx<=n&&yy<=n&&xx>=1&&yy>=1&&steps[xx][yy]==-1)
				{
					if(stepe[xx][yy]!=-1)
					{
						return steps[curx][cury] + 1 + stepe[xx][yy];  //steps[curx][cury] + 1其实就是 steps[xx][yy]
					}
					steps[xx][yy] = steps[curx][cury] + 1;
					start.push(make_pair(xx,yy));
				}
			}
		}
		//反向
		for(register int i= 0;i<lene;i++)
		{
			int curx = final.front().first, cury = final.front().second;
			final.pop();
			for(register int j=0;j<4;j++)
			{
				int xx = curx + dx[j];
				int yy = cury + dy[j];
				if(a[xx][yy] == '0'&&xx<=n&&yy<=n&&xx>=1&&yy>=1&&stepe[xx][yy] == -1)
				{
					if(steps[xx][yy]!=-1)
					{
						return steps[xx][yy] + stepe[curx][cury] + 1;
					}
					stepe[xx][yy] = stepe[curx][cury] + 1;
					final.push(make_pair(xx,yy));
				}
			}
		}

	}
}
int main()
{
	memset(steps,-1,sizeof(steps));
	memset(stepe,-1,sizeof(stepe));
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
			scanf("%s",a[i]+1);
	}
	scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
	printf("%d\n",bfs());
	return 0;
}
```

这个双向bfs的判重与记录步数都用了与单向bfs不同的方法。
两个数组，一个steps表示起点的步数，stepe表示终点的步数。初始化为-1 (表示没走过)

如果正在扩展起点，并且steps != -1，那么肯定就重了。

如果扩展起点，发现stepe !=-1，代表终点扩展到过那个点，直接返回两个距离之和就行了。



---

## 作者：linyuanAmalgam (赞：0)

### 引入
为了纪念即将逝去的~~美好的~~暑假，我决定~~没事找事~~写一写我的第一篇题解~~本蒟蒻看不懂下面的QAQ~~
### 审题
建议少看标签，自己理清思路。

看题目。类似走迷宫，DFS和BFS都可以，BFS更快更好写 ~~因为不会记忆化和A*~~
### 思路
用STL的queue（队列）先进先出的特点进行搜索（多学学STL，有时真的很好用）
### 好了，下面放代码，如果有细节错误请指出哟~

```cpp
#include <iostream>
#include <queue>
using namespace std;
struct node
{
    int x,y,step;
}pos,head;
bool map[1010][1010],vis[1010][1010]; //map存储地图，vis判断有没有访问过
int dx[]={0,1,0,-1},
    dy[]={1,0,-1,0}; //增量数组（很整齐有没有！）
int n,x1,y1,x2,y2;
queue<node> Q;
inline void read() //代码函数化，清晰明了
{
    cin >> n;
    char ch;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
            cin >> ch;
            //一定要注意是字符啊，不要像某人第一次输入数字，WA了十个点
            if (ch!='\n') map[i][j]=ch-'0';
            else j--;
        }
    cin >> x1 >> y1 >> x2 >> y2;
}
void bfs()
{
    head.x=x1,head.y=y1,head.step=0; //先处理出发点
    Q.push(head);
    while (!Q.empty()) //标准queue模板
    {
        head=Q.front(); //取队头
        Q.pop();
        if (head.x==x2 && head.y==y2) //已到达，结束
            return;
        for (int i=0;i<4;i++) //四个方向
        {
            int nx=head.x+dx[i],ny=head.y+dy[i]; //新的x，y
            if (nx>=1 && nx<=n && ny>=1 && ny<=n && !vis[nx][ny] && !map[nx][ny])
                //顺序！一定要先判断nx，ny，不然你等着RE吧
            {
                vis[nx][ny]=true; //记录已访问
                pos.x=nx,pos.y=ny,pos.step=head.step+1; //构造新点
                Q.push(pos); //新点入队
            }
        }
    }
}
int main()
{
    read();
    bfs();
    cout << head.step << endl; //队头步数即是结果
    return 0; //华丽收尾
}
```

---

## 作者：doyo (赞：0)

非递归版广搜

想到当年学搜索的时候，教练一直反复解释“深搜就是在维护一个栈”。

“广搜就是在维护一个队列”（MMP他自己会说就是不打，不示范），害的我的搜索一直挂，学DP的时候怎么也理解不了记忆化搜索

直到后来学会了STL这种东西，才捡起了搜索

为那些初学OI的萌新们写一篇题解，希望能对搜索的实现有所帮助
```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=1002;//这里死了一次，1001RE成了20分，1002AC
//所以说开数组不能太小气啊 
int dis[maxn][maxn];
bool vis[maxn][maxn];
int n,nx,ny,x,y;
struct node
{
	int x;
	int y;
};
queue<node> q;//结构体，用STL里的队列保存状态 ，即坐标 
void bfs()//非递归版的广搜 
{
	dis[x][y]=0;q.push((node){x,y});//结构体下STL里push操作，注意看 
	while(!q.empty())
	{
		node temp=q.front();q.pop();
		x=temp.x;y=temp.y;
		if(x<=0||x>n||y<=0||y>n) continue;//如果不写会越界导致RE 
		//下面4个if完全可以用一个dx,dy数组以及一个for循环代替（但是Ctrl+c,Ctrl+v的感觉还是挺好的） 
		if(!vis[x+1][y])
		{
			dis[x+1][y]=dis[x][y]+1;
			vis[x+1][y]=true;
			q.push((node){x+1,y});
		}
		if(!vis[x-1][y])
		{
			dis[x-1][y]=dis[x][y]+1;
			vis[x-1][y]=true;
			q.push((node){x-1,y});
		}
		if(!vis[x][y+1])
		{
			dis[x][y+1]=dis[x][y]+1;
			vis[x][y+1]=true;
			q.push((node){x,y+1});
		}
		if(!vis[x][y-1])
		{
			dis[x][y-1]=dis[x][y]+1;
			vis[x][y-1]=true;
			q.push((node){x,y-1});
		}
	}
}
int main()
{
	char ch;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("\n");//用标准输入输出要注意在这里把换行符吃掉 
		for(int j=1;j<=n;j++)
		{
			scanf("%c",&ch);
			if(ch=='0') vis[i][j]=false;
			else vis[i][j]=true;
		}
	}
	scanf("%d%d%d%d",&x,&y,&nx,&ny);
	bfs();
	printf("%d\n",dis[nx][ny]);
	return 0;
}
```


---

## 作者：Warriors_Cat (赞：0)

## 本蒟蒻的第n篇题解

最近一直在刷深搜广搜题，刚好碰到了一个bfs练手题，于是就~~毫无精力~~兴致勃勃的A了这道题。

一开始是TLE，后面调了一次就AC了，

bfs肯定离不开一个STL，Ta就是

### queue（队列）！

queue对于各位C++选手来说应该不陌生了吧，在这里就不在叙述了。

## 代码准备：

```
#include<bits/stdc++.h>
using namespace std;
int n, a[1010][1010], vis[1010][1010], sx, sy, hx, hy, ans;
//一大堆乱七八糟的变量qwq 
string s;//因为读入是没有空格，所以要字符串 
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
//此两个均为方向 
struct node{
	int x, y, cnt;
};//坐标和次数 
queue<node>q;//STL真好用，不用手打队列了 
inline bool check(int x, int y){//判断是否已经经过或不在方阵内 
	return x >= 1 && x <= n && y >= 1 && y <= n && !a[x][y] && !vis[x][y];
	//一句搞定（天知道我为什么要写这个qwq） 
}//加一个inline会快一些，但不能用到递归里去 
inline int bfs(){//开始打bfs啦 
	node data;
	data.x = sx; data.y = sy; data.cnt = 0;
	q.push(data);//将初始值怼进去 
	while(!q.empty()){//当队列非空时 
		node rhs = q.front(); q.pop();//取队头值并弹出，rhs = right hand side 
		if(vis[rhs.x][rhs.y]) continue;//若已遍历过则跳过 
		vis[rhs.x][rhs.y] = rhs.cnt;//将步数存到vis里面 
		if(rhs.x == hx && rhs.y == hy) return vis[rhs.x][rhs.y];//若已在终点则返回 
		for(int i = 0; i < 4; ++i){//开始枚举 
			int nx = rhs.x + dx[i], ny = rhs.y + dy[i];//走一步 
			if(!check(nx, ny)) continue;//若矛盾则跳过 
			node lhs;//lhs = left hand side
			lhs.x = nx; lhs.y = ny; lhs.cnt = rhs.cnt + 1;
			q.push(lhs);//怼进队列去 
		}
	}
	return 0;//无聊专用 
}
int main(){
	ios::sync_with_stdio(false);//输入输出加速 
	cin >> n;
	for(int i = 1; i <= n; ++i){
		cin >> s;
		for(int j = 0; j < n; ++j){
			a[i][j + 1] = s[j] - '0';
		}
	}//存储店铺或马路 
	cin >> sx >> sy >> hx >> hy; 
	ans = bfs();
	cout << ans;
	system("pause");//日常防伪代码 
	return 0;
} 
```
啊！就这么A了一道广搜水题！

各位深搜广搜的beginner们可以以这道题练一下手。

## 求过！

### 重要的事情说“一”遍！

谢谢各位读者的阅读以及管理员的审阅。

---

## 作者：royzhu (赞：0)


这道题并不难 （dalao都这么觉得）

蒟蒻的我都可以一遍AC

思路：

跑一遍宽（广）搜

```cpp
#include<cstdio>
int sx,sy,ex,ey,n;//sx,sy是起点坐标，ex，ey是终点坐标（出题者真良心，起点，终点都给了） 
char a[1100][1100];//表（输入没有空格得用char读） 
struct lol{int x,y,t;} d[1100000];//记录每次要跑的点 
int dx[4]={0,1,0,-1};//x的偏移量 
int dy[4]={1,0,-1,0};//y的偏移量 （两偏移量组成，上，下，左，右） 
void dfs()
{
    int tou=1,wei=2;//tou记录当前点，wei记录当前点走的点 
    d[tou].x=sx;d[tou].y=sy;d[tou].t=0;//把初始点记录下来，把初始步刷0 
    while(tou!=wei) 
    {
        for(int i=0;i<4;i++)//四个方向 
        {
            int x=d[tou].x+dx[i];// 当前点x加偏移量 
            int y=d[tou].y+dy[i];// 当前点y加偏移量
            if(x==ex&&y==ey){printf("%d",d[tou].t+1);return;}//到终点输出 
            if(x>=1&&x<=n&&y>=1&&y<=n&&a[x][y]=='0')//如果当前点走的点没超n记录当前点走的点
            {
                a[x][y]='1';//封点 
                d[wei].x=x;d[wei].y=y;d[wei].t=d[tou].t+1;wei++;
            }
        }tou++;
    }
}
int main()
{
    scanf("%d",&n); //输入
    for(int i=1;i<=n;i++)
    {
        scanf("%s",a[i]+1);//不能用%c，%c会读回车 
    }
    scanf("%d %d %d %d",&sx,&sy,&ex,&ey);//输入起点，终点 
    a[sx][sy]=1;//封起始点 
    dfs();
}
```

---

## 作者：codesonic (赞：0)

其他题解都用搜索做qwq，我来一发SPFA

注释见代码

spfa做法也是裸的

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cstdio>
using namespace std;
char a[1010][1010];
int dis[1010][1010];
bool inq[1010][1010];
struct node{
    int x,y;
};
queue<node> q;
inline void spfa(int r,int c){
    memset(dis,127,sizeof(dis));dis[r][c]=0;//令所有距离为inf
    q.push((node){r,c});inq[r][c]=1;
    while(!q.empty()){
        int x=q.front().x,y=q.front().y;q.pop();inq[x][y]=0;
        int x1=x,y1=y+1,x2=x,y2=y-1,x3=x+1,y3=y,x4=x-1,y4=y;
        int temp1=dis[x1][y1],temp2=dis[x2][y2],temp3=dis[x3][y3],temp4=dis[x4][y4];//记录方便下面比较，当然如果用方向数组就不用这么麻烦
        if(a[x1][y1]=='0')dis[x1][y1]=min(dis[x][y]+1,dis[x1][y1]);
        if(a[x2][y2]=='0')dis[x2][y2]=min(dis[x][y]+1,dis[x2][y2]);
        if(a[x3][y3]=='0')dis[x3][y3]=min(dis[x][y]+1,dis[x3][y3]);
        if(a[x4][y4]=='0')dis[x4][y4]=min(dis[x][y]+1,dis[x4][y4]);
        if(temp1>dis[x1][y1])
            if(!inq[x1][y1])q.push((node){x1,y1}),inq[x1][y1]=1;
        if(temp2>dis[x2][y2)
            if(!inq[x2][y2])q.push((node){x2,y2}),inq[x2][y2]=1;
        if(temp3>dis[x3][y3])
            if(!inq[x3][y3])q.push((node){x3,y3}),inq[x3][y3]=1;
        if(temp4>dis[x4][y4])
            if(!inq[x4][y4])q.push((node){x4,y4}),inq[x4][y4]=1;//这几步也可以写成方向数组循环
    }
}
int main()
{
    int qx,qy;
    int ax,ay;
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf(" %c ",&a[i][j]);//字符读入需要加空格
    scanf("%d%d%d%d",&qx,&qy,&ax,&ay);
    spfa(qx,qy);
    printf("%d",dis[ax][ay]);
    return 0;
}
```

---

## 作者：zhengzha (赞：0)

一看到这道题目，让你求做少步数，一定是广搜，但是1000×1000的迷宫图，单向广搜可能会TLE，所以就用双向广搜。


上代码：




```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
struct node{int x,y,d,f;};//x，y是位置，d是步数，f表示是起点还是重点生成的 
node q[1000010];//队列 
int fx[4]={1,-1,0,0};
int fy[4]={0,0,1,-1};//偏移量 
char s[1010][1010];//地图 
int n;
int x1,y1,x2,y2;
void bfs()
{
    int st=1,ed=3;
    q[st].x=x1,q[st].y=y1;q[st].d=0;q[st].f=2;//记录起点的位置放入队列 
    q[2].x=x2,q[2].y=y2;q[2].d=0;q[2].f=3;//记录终点的位置放入队列 
    while (st!=ed)
    {
        for (int i=0;i<4;i++)
        {
            int xx=q[st].x+fx[i],yy=q[st].y+fy[i];
            if (xx<0 || xx>=n || yy<0 || yy>=n || s[xx][yy]=='1') continue;//如果跑出地图或这个地方是店铺就跳过 
            //printf("%d %d\n",xx,yy);
            if (s[xx][yy]!='0')//如果是路但是走过 
            {
                if (s[xx][yy]-'0'==q[st].f) continue;//如果都是起点或都是终点生成的，跳过 
                else//否则就输出步数 
                {
                    //printf("%d %d\n",s[xx][yy]-'0',q[st].f);
                    int d;
                    for (int i=1;i<=ed;i++)//去队列中找之前到过这个点的数据 
                    {
                        if (q[i].x==xx && q[i].y==yy)//找到记录 
                        {
                            d=q[i].d; 
                            break;
                        }
                    }
                    //printf("%d\n",d);
                    printf("%d\n",q[st].d+d+1);//因为初始设置的都是0，有一步没有算，所以要加1 
                    return;
                }
            }
            q[ed].x=xx;
            q[ed].y=yy;
            q[ed].d=q[st].d+1;
            q[ed].f=q[st].f;//记录新点的数据 
            s[xx][yy]=q[ed].f+'0'; //修改地图 
            ed++;
        }
        st++;
    }
}
int main()
{
    scanf("%d",&n);
    for (int i=0;i<n;i++)
        scanf("%s",s[i]);
    scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    x1-=1,y1-=1,x2-=1,y2-=1;//因为我个人从0开始读的，所以就要减 
    s[x1][y1]='2',s[x2][y2]='3';//记录迷宫，同时记录是哪边的节点生成的，'2'表示起点 ,'3'表示重点 
    bfs();
}
```

---

## 作者：王小宇 (赞：0)

### 一道显而易见的广度优先搜索

当时提交了好几次都wa，后来才发现是数组开小了。

再就是那个y3本来是y1，因为编译器的原因，y1冲突了，只好用y3代替了，看代码的时候自己转换过来就好了。

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
bool map[1001][1001];
int head=0,tail=1;
int arrayx[10001],arrayy[10001],arrayl[1000001];
int n,x1,x2,y3,y2;
int xz[4]={-1,0,1,0},yz[4]={0,-1,0,1};//定义两个数组来转换方向
//true代表不可以走    false代表可以走 
bool check(int x,int y)
{
    if (map[x][y]==false&&x>=1&&x<=n&&y>=1&&y<=n) return true;
    return false;
}//先判断当前点是否在范围之内且是否能走
void bfs()
{
    int xx,yy,i;
    arrayx[1]=x1;
    arrayy[1]=y3;
    arrayl[1]=0;//将起点作为第一个元素，把它的横纵坐标放进去，并且初始步数是0
    map[x1][y3]=true;//把起点标记，已经不能再走了
    while(head<tail)
    {
        head++;//头指针加1
        for (i=0;i<4;i++)
        {
            xx=arrayx[head]+xz[i];
            yy=arrayy[head]+yz[i];//将当前坐标向四个方向扩展
            if (check(xx,yy)==true)//先判断这个新扩展的点是否合法
            {
                map[xx][yy]=true;//如果当前点合法，把这个点标记，不能再走
                tail++;//尾指针加1
                arrayx[tail]=xx;
                arrayy[tail]=yy;//把这个新扩展的点的坐标放进去
                arrayl[tail]=arrayl[head]+1;//步数加1
                if (arrayx[tail]==x2&&arrayy[tail]==y2)
                {
                    printf("%d",arrayl[tail]);
                }//如果已经到了终点，那么就输出步数
            }
        }
    }
}
int main()
{
    int i,j;
    memset(map,0,sizeof(map));//初始化
    string str;
    scanf("%d",&n);
    for (i=1;i<=n;i++)
    {
        cin>>str;
        for (j=0;j<n;j++)
        {
            if (str[j]=='0') map[i][j+1]=false;
            if (str[j]=='1') map[i][j+1]=true;
        }
    }//读入地图
    scanf("%d%d%d%d",&x1,&y3,&x2,&y2);
    bfs();//开始bfs
    return 0;
}
```
### 一道适合提高熟练度的bfs


---

## 作者：Ape_epA (赞：0)

一道宽搜，非常经典的走迷宫问题。个人比较喜欢宽搜，深搜可能会超。

const f:array[1..4,1..2] of longint=((-1,0),(1,0),(0,-1),(0,1));

```cpp
var d:array[0..1001,0..1001] of longint;
    a:array[0..1001,0..1001] of char;
    b,c:array[0..1000001] of longint;
    n,i,j,x,y,x1,y1,t,w:longint;
begin
  readln(n);
  fillchar(a,sizeof(a),'1');
  for i:=1 to n do
    begin
    for j:=1 to n do
      read(a[i,j]);
    readln;
    end;
  readln(x,y,x1,y1);
  t:=1;
  w:=1;
  b[1]:=x;
  c[1]:=y;
  while t<=w do
    begin
    for i:=1 to 4 do
      begin
      x:=b[t]+f[i,1];
      y:=c[t]+f[i,2];
      if a[x,y]='0' then
        begin
        inc(w);
        b[w]:=x;
        c[w]:=y;
        a[x,y]:='1';
        d[x,y]:=d[b[t],c[t]]+1;
        if (x=x1)and(y=y1) then
          begin
          writeln(d[x,y]);
          halt;
          end;
        end;
      end;
    inc(t);
    end;
end.
```

---


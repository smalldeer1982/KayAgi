# [蓝桥杯 2018 省 AB] 全球变暖

## 题目描述

你有一张某海域 $N \times N$ 像素的照片，`.` 表示海洋、 `#` 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 $2$ 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 


## 说明/提示

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

## 样例 #1

### 输入

```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  ```

### 输出

```
1```

# 题解

## 作者：kkxacj (赞：37)

upd:改进码风，更改错别字。

[题目传送门](https://www.luogu.com.cn/problem/P8662)

#### 引言：

这个蒟蒻竟然交了几次才过，写个题解纪念一下。

#### 题意

给出一张某海域 $N \times N$ 像素的照片，求有多少岛屿会被完全淹没。

#### 思路

用 `DFS` 求出最开始有几个小岛，再求被海水淹没后还剩几个小岛，相减即可得到答案。

#### 注意：被海水淹没后的陆地应用另一个字符表示，而不是把它变为海洋，这个点可以遍历，但不能被当作起点，不然就只有 $36$ 分。

例如：

```
9
.........
.#######.
.#######.
.#######.
..#.#....
.#######.
.#######.
.#######.
.........
```
如果你把被淹没的陆地改为海洋的话，后面求就会认为这是两个小岛，答案就会为 $-1$，但答案其实是 $0$。


code
```c
#include<bits/stdc++.h>
using namespace std;
int n,ans,ans1;
int fx[6]={-1,0,1,0};
int fy[6]={0,1,0,-1};//方向数组
char d[1010][1010],f[1010][1010]; 
void dfs(int x,int y) //求淹没后有几个大陆 
{
	d[x][y] = '.';
	for(int i = 0;i < 4;i++) 
	{
		int xt = x + fx[i],yt = y + fy[i];
		if(d[xt][yt] != '.' && xt > 0 && xt <= n && yt > 0 && yt <= n) dfs(xt,yt);
	}
	return;
}
void df(int x,int y)//求淹没前有几个大陆 
{
	f[x][y] = '.';
	for(int i = 0;i < 4;i++) 
	{
		int xt = x + fx[i],yt = y + fy[i];
		if(f[xt][yt] == '#' && xt > 0 && xt <= n && yt > 0 && yt <= n) df(xt,yt);
	}
	return;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			cin >> d[i][j],f[i][j] = d[i][j];
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++) 
			if(d[i][j] == '#' && (d[i-1][j] == '.' || d[i+1][j] == '.' || d[i][j-1] == '.' || d[i][j+1] == '.')) 
				d[i][j] = '-'; 
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			if(f[i][j] == '#')
			{
				ans1++;
				df(i,j);
			}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			if(d[i][j] == '#')
			{
				ans++;
				dfs(i,j);
			}
	printf("%d",ans1 - ans);
	return 0;
}
```

---

## 作者：Tolerate (赞：20)

遍历图一遍即可

如果有一块陆地上下左右都是陆地  那么这块陆地就不会被淹没

另外有一个细节  就是当遍历到其中一个点时  标记这个点要用其他符号  避免与图中两点重复。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,sum,ans,t,dx[]={0,1,0,-1},dy[]={1,0,-1,0};
char mp[1010][1010];
void dfs(int x,int y)
{
	if(!t)//一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋),就会被淹没。
	{
		cnt=0;
		for(int i=0;i<4;i++)
			if(mp[x+dx[i]][y+dy[i]]!='.') 	cnt++;
		if(cnt==4)//岛屿上的一个点四周无海洋
			ans++,t=1;//这个岛屿不会被淹没
	}
	mp[x][y]='*';//标记
	for(int i=0;i<4;i++)
	{
		int xx=x+dx[i],yy=y+dy[i];
		if(xx<0||xx>=n||yy<0||yy>=n||mp[xx][yy]!='#') continue;
		dfs(xx,yy);
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			cin>>mp[i][j];
	for(int i=1;i<n-1;i++)
		for(int j=1;j<n-1;j++)
			if(mp[i][j]=='#')
			{
				sum++;
				t=0;
				dfs(i,j);
			}
	cout<<sum-ans;//岛屿总数量-没被淹没的岛屿
}
```


---

## 作者：small_john (赞：12)

## 分析

简单的暴力题。

思路很简单，如果一块陆地上下左右都是陆地，就算与他相邻的陆地都被淹没，那这块地也不会被淹，这个小岛就没有被完全淹没。所以我们只需要遍历一遍，看每个岛的陆地是否沿海即可。

直接 DFS，实现方法详见代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1005;
char a[N][N];
int n,ans,xx[] = {1,-1,0,0},yy[] = {0,0,1,-1};
bool v = 1,vis[N][N];//v来记录返回值，vis数组打标记 
bool ok(int x,int y)//单纯是为了方便，判断是否是陆地 
{
	return a[x][y]!='.';
}
bool dfs(int x,int y)
{
	vis[x][y] = 1;//遍历过了，标记为1 
	if(ok(x-1,y)&&ok(x+1,y)&&ok(x,y-1)&&ok(x,y+1))//上下左右都是陆地，不沿海，那么这个岛不会被完全淹没 
		v = 0;
	for(int i = 0;i<4;i++)//扩张 
	{
		int X = x+xx[i],Y = y+yy[i]; 
		if(ok(X,Y)&&vis[X][Y]==0)//没遍历过并且是陆地，那么此区域属于这片岛屿 
			dfs(X,Y);
	}
	a[x][y] = '.'; 
	return v;
}
signed main()
{
	cin>>n;
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=n;j++)
			cin>>a[i][j];
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=n;j++)
			if(ok(i,j))//如果是陆地，那么就遍历这个岛 
				v = 1,ans+=dfs(i,j);
	cout<<ans;
	return 0;
}
```

---

## 作者：hycqwq (赞：8)

~~很有生活气息的题~~。

## 思路

首先想到，我们可以在开始时先统计一下总共有多少个岛，然后再统计水面上升之后有多少个岛，然后一减！

但是我们发现，这样只有 $36\text{pts}$。

于是我们找到了一个错误的数据：

```text
10
..........
.##.......
.###......
..##...##.
.###..###.
..#...###.
.###...#..
..#...###.
.......#..
..........
```

我们的方法居然会得出 $-3$！

我们来看看，这个地图在水面上升之后会变成什么样：

```text
..........
..........
..#.......
..........
..#....#..
.......#..
..#.......
.......#..
..........
..........
```

$2$ 个岛分裂成了 $5$ 个岛！难怪输出会错！

再回去看题面：

> 请你计算：依照科学家的预测，照片中有多少岛屿会被**完全**淹没。

所以说，如果一个大岛分裂成了若干个小岛，那么这些小岛其实是算在同一个岛力的，因为分裂出它们的那个大岛没有被完全淹没（有露出水面的小岛）。

于是我们还需要在开始时给每个岛一个编号，最后统计水面上的残部有多少个不同的编号，而不是最后岛的个数。

## 代码

STL 大法好！

```cpp
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
#define elif else if

int n, s1 = 0, s2 = 0;//s1是开始时岛屿个数，s2是水面上涨后的
char c1[1005][1005], c2[1005][1005];//c1是开始时的形势，c2是水面上涨后的
int id[1005][1005] = {0};//id表示一个坐标本来属于哪个岛
//因为是否淹没某个坐标的判定需要原来的形势，所以水面上涨后需要另开一个数组
bool f[1005][1005] = {{false}};//记录到没到过某个坐标，初始都没到过
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};//四个方向，上下左右

//floodfill算法，走遍这个岛的每块陆地
//坐标：(x, y)，记录到c数组中（这样写其实是懒），这是第iid号岛（iid, island ID）
void srh(int x, int y, char c[1005][1005], int iid)
{
    f[x][y] = true;//标记到过了
    id[x][y] = iid;//标记是iid号岛
    for (int i = 0; i < 4; i++)
        if (1 <= x + dx[i] && x + dx[i] <= n && 
            1 <= y + dy[i] && y + dy[i] <= n && //如果没有越界
            c[x + dx[i]][y + dy[i]] == '#' && //并且还是陆地
            !f[x + dx[i]][y + dy[i]])//最后还没到过
            srh(x + dx[i], y + dy[i], c, iid);//那就搜过去
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> c1[i][j], c2[i][j] = c1[i][j];//复制一份
    //统计开始前有多少个岛
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)//枚举每个坐标
            if (c1[i][j] == '#' && !f[i][j])//如果是陆地并且没有统计到过
                srh(i, j, c1, ++s1);//统计一下
    //水面开始上涨了
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)//枚举每个坐标
            if (c1[i][j] == '#')//如果这一个地方是陆地，才继续
                for (int k = 0; k < 4; k++)//枚举上下左右
                    if (c1[i + dx[k]][j + dy[k]] == '.')//如果碰到了海
                    {
                        c2[i][j] = '.';//被淹没力
                        break;//再见
                    }
    //统计结束后还有多少个岛有残部
    map<int, int> mp;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (c2[i][j] == '#' && mp[id[i][j]] == 0)//发现一块残部并且之前没有发现其所属大岛的其他残部
                mp[id[i][j]] = 1;//标记这个岛有残部，注意是=1而不是++
    for (auto i : mp)//C++11及以上遍历STL容器的方法
        s2 += i.second;//统计有多少个岛有残部
    //最后，答案就是开始时的岛屿个数减去水面上涨后还剩的
    cout << s1 - s2 << endl;
    return 0;
}
```

---

## 作者：wuhan1234 (赞：5)

## 1. 编程思路。

对给定海域中的每个陆地像素，从它出发用 BFS 搜索包括这个陆地像素的连通块，置连通块中的每个路地像素 $(i,j)$ 的 $vis_{i,j}=1$，同时对连通块中的每个陆地像素的上下左右四个像素进行判断，若其上下左右这四个像素也是陆地像素 #，则其不会被淹没，对表示一个连通块中不会淹没的陆地进行计数，即 $left$ 加 $1$。若一个连通块的 $left$ 值为 $0$，表示这个连通块中的陆地像素都会被淹没，这个岛屿也就全被淹没了。

用 BFS 找出每个连通块，所有连通块中 $left$ 值为 $0$ 的连通块个数就是被淹没的岛屿数。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
#define N 1005
char a[N][N];
int n,vis[N][N],dir[4][2]={{-1,0},{0,-1},{0,1},{1,0}};
struct Point
{
	int x,y;
};
struct Point q[1000000];
int bfs(int x,int y)
{
	struct Point p;
    p.x=x;  p.y=y;
    int front=0,rear=0;
	q[rear++]=p;
	int left=0;    // 表示一个连通块中留下的没有被淹没的陆地像素
	while (front<rear)
	{
		p=q[front++];
		int i,cnt=0;
		for (i=0;i<4;i++)
		{
			int dx=p.x+dir[i][0];
			int dy=p.y+dir[i][1];
			if (dx<0 || dx>=n || dy<0 || dy>=n)
				continue;
			if (a[dx][dy]=='#')   
			{
				cnt++;
				if (!vis[dx][dy])
				{
					vis[dx][dy]=1;
					q[rear].x=dx;
					q[rear].y=dy;
					rear++;
				}
			}
		}
		if (cnt==4)    // 如果一个陆地像素的上下左右四个方向也是陆地像素
			left++;    // 这个陆地像素肯定不会被淹没，留下了
	}
	return left;
}
int main()
{
	int i,j,ans=0;
	scanf("%d",&n);
	for (i=0;i<n;i++)
	{
        scanf("%s",a[i]);
	}
	memset(vis,0,sizeof(vis));
	for (i=0;i<n;i++)
	{
		for (j=0;j<n;j++)
		{
			if (a[i][j]=='#'&& !vis[i][j])  // 从这个没有访问过的陆地像素出发寻找其连通块
			{
				vis[i][j]=1;
				if (!bfs(i,j))    // 包含(i,j)陆地像素的连通块中的陆地像素全部被淹没，left=0
					ans++;        // 被淹没的岛屿个数加 1
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Play_with (赞：3)

### 
## 题意分析:
先用所属岛屿的编号标记所有陆地，再标记所有会被淹没的岛屿，统一淹没。最后统计剩余岛屿，相减即可得出被淹没数

------------
## 一些坑：
1. 如果一个岛被淹没变成两块陆地，它们仍然只算一个岛
2. 如果不先标记会被淹没的陆地，可能导致淹没本不该淹没的陆地

[题目传送门](https://www.luogu.com.cn/problem/P8662)
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1234][1234],f[1234567][2],c[1234],h=1,c1,c2,fl;
int cx[5]={0,1,0,-1,0},cy[5]={0,0,1,0,-1};//用于上下左右移动 
char s[1234][1234];
void ranse(int x1,int y1,int s1){//x1,y1代表原坐标,s1代表岛屿编号 
	for(int i=1;i<=4;i++){//for循环遍历上下左右移动 
		int x=x1+cx[i],y=y1+cy[i];//用x,y代表新坐标 
		if(x>0&&x<=n&&y>0&&y<=n&&s[x][y]=='#'&&a[x][y]==0){//将移动控制在地图范围内，且为陆地，且并未被岛屿编号标记 
			a[x][y]=c1;
			ranse(x,y,c1);
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>s[i][j];//读入s[i][j]
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='#'){//如果是岛 ,则将岛上的全部陆地标记为岛的编号，用a[][]储存, c1作为编号 
				if(a[i][j]==0){
					c1++;//岛屿数++
					a[i][j]=c1;//全部标记 
					ranse(i,j,c1);
				}
				//一个岛会被淹没的判定:上下左右至少有一格海洋 
				for(int l=1;l<=4;l++){
					int x=i+cx[l],y=j+cy[l];
					if(x>0&&x<=n&&y>0&&y<=n&&s[x][y]=='.'){
						f[h][0]=i;//标记为会被淹没,之后统一淹，避免重复淹没其他陆地 
						f[h++][1]=j;//用f[][0]存i,f[][1]存j,h作为被淹判定的计数变量 
                      	break;//被标记就无须再找了
					}
				}
			}
	for(int i=1;i<h;i++)
		s[f[i][0]][f[i][1]]='.';//开始淹没 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='#')//如果还有陆地则利用岛屿标号的桶去记录还有多少个岛幸存
				for(int l=1;l<=c1;l++)
					c[a[i][j]]=1;
	for(int i=1;i<=c1;i++)
		if(c[i]==1) c2++;//将幸存岛屿统计 
	cout<<c1-c2;//最后有原来的岛屿数减去幸存的岛屿数,得到淹没的岛屿数 
	return 0;
}
```

---

## 作者：Furina_Hate_Comma (赞：2)

一道深度优先搜索题。

搜索每个岛屿在淹没后的情况，判断连通块，注意一块岛屿淹没后有可能变成两块，不要直接判断连通块。

算法流程：

1. 找到一个陆地。
1. 广搜遍历连通块。
1. 修改岛屿。
1. 再次广搜判断是否增加或减少。

如下：

```
.........
.##...##.
.#######.
.##...##.
.........
```
代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[1007][1007], b[1007][1007], ca = 0, cnta = 0, ans = 0, via[1007][1007], v[100007];
char ch;
int dx[] = {0, 1, -1, 0, 0};
int dy[] = {0, 0, 0, 1, -1};
inline void dfsa(int x, int y) {
    if (via[x][y] == 0)
        ca++, via[x][y] = ++cnta;

    fr(4) {
        int tx = x + dx[i], ty = y + dy[i];

        if (a[tx][ty] == 1 && 1 < tx && tx < n && 1 < ty && ty < n && !via[tx][ty]) {
            via[tx][ty] = via[x][y];
            dfsa(tx, ty);
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin >> n;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            cin >> ch;

            if (ch == '#')
                a[i][j] = 1;
        }

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (a[i][j] && via[i][j] == 0)
                dfsa(i, j);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (a[i][j] == 1)
                if (a[i - 1][j] == 1 && a[i + 1][j] == 1 && a[i][j - 1] == 1 && a[i][j + 1] == 1)
                    b[i][j] = 1;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (b[i][j] == 1 && via[i][j])
                v[via[i][j]] = 1;

    for (int i = 1; i <= cnta; i++) {
        ans += (v[i] == 1);
    }

    cout << ca - ans << endl;
    return 0;
}
```

---


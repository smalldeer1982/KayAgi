# 【模板】拓扑排序 / 家谱树

## 题目描述

有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。给出每个人的后代的信息。输出一个序列，使得每个人的后辈都比那个人后列出。

## 样例 #1

### 输入

```
5
0
4 5 1 0
1 0
5 3 0
3 0```

### 输出

```
2 4 5 3 1```

# 题解

## 作者：MujicaSaki (赞：80)

拓扑排序的模板题。

拓扑排序是一个有向无环图的所有顶点的线性序列。

该序列需要满足每个顶点出现且**只出现一次**和如果有一条 $A$ 到 $B$ 的路径，在序列中 $A$ 出现在 $B$ 的前面。

这道题目显然全部满足以上条件。如果不懂可以看下面样例的有向无环图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ynd20iy.png?x-oss-process=image/resize,m_lfit,h_200,w_400)

拓扑排序的步骤：

- 计算每个点的入度。

- 入度为 $0$ 就加入队列。

- 当队列不为空则循环：

	- 取出队首元素并输出。
    
   - 遍历队首元素的连边，对应节点的入度 $-1$。
   
   - 当对应的节点入度为 $0$ 就加入队列。
   
我们看样例的图，其中 $1$ 到 $5$ 的入度分别为 $2$，$0$，$2$，$1$ 和 $2$。我们就把 $2$ 号节点加入队列。队首现在不为空，所以我们取出 $2$ 号节点，并且输出出来。这时候因为他没有祖先所以一定是现在辈分最大的所以输出出来。删除所有对应节点的入度之后我们会发现 $4$ 号节点入度为 $0$。所以加入队列。然后取出队首 $4$ 号节点并且输出。很明显他的祖先 $2$ 号节点已经没了，所以 $4$ 号节点已经没有辈分比他还大的了。按照上面的步骤我们就可以完成此道题目了。

---

## 作者：览遍千秋 (赞：72)

对于第 $i$ 个人的后代 $a_{i,j}$，我们可以使用图上的有向边来描述这样的后代关系。

建立有向边 $i \rightarrow a_{i,j}$，表示 $a_{i,j}$ 是 $i$ 的后代。

这样，所有 $N$ 个人的后代关系构成了一个 DAG（有向无环图）。

如果存在边 $u \rightarrow v$，那么 $u$ 必须在 $v$ 之前输出，自然可以想到拓扑排序 toposort。

输出这张图的一个拓扑序即可。

```cpp
queue <int> Q;
void toposort() {
	for(int i = 1; i <= n; i++) {
		if(deg[i] == 0) {
			printf("%d ", i);
			Q.push(i);
		}
	}
	while(Q.size()) {
		int x = Q.front(); Q.pop();
		for(int i = Head[x]; i; i = Next[i]) {
			deg[to[i]]--;
			if(deg[to[i]] == 0) {
				printf("%d ", to[i]);
				Q.push(to[i]);
			}
		}
	}
}
```

---

## 作者：awdec (赞：28)

记录每个点第一次回溯的 dfn，原图拓扑排序就是按 dfn 降序排序的序列。按照标记时间，放入栈中输出即可。不用排序。

时间复杂度：$O(n)$。

不用判入度。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=a;i<=b;i++)
#define FOR(i,a,b) for(i=a;i>=b;i--)
using namespace std;
const int N = 5e5 + 10;
int n;
vector<int> p[N];
void add(int u, int v) {
	p[u].push_back(v);
}
bool vis[N];
stack<int> ans;
void dfs(int x) {
	for (auto u : p[x]) {
		if (vis[u]) continue;
		dfs(u);
	}
	vis[x] = 1;
	ans.push(x);
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int i;
	cin >> n;
	For(i, 1, n) {
		int x;
		while (cin >> x && x) {
			add(i, x);
		}
	}
	For(i, 1, n) {
		if (!vis[i])
			dfs(i);
	}
	while (ans.size()) {
		cout << ans.top() << ' ';
		ans.pop();
	}
}
```

---


# [中山市赛 2024/科大国创杯小学组 2023] 倍数子串/子串

## 题目背景

本题题面为 2024 年中山市赛版本，在题面主人公上与 2023 年安徽省科大国创杯小学组略有区别。

## 题目描述

Jimmy 对数字有着异于常人的热爱。有一天，他随便写出来一个数字——$04320$，然后开始对着这个数字写写画画。他发现，从这个数字中随便选出连续的一段（Jimmy 把这个称为连续子串），有可能是 $4$ 的倍数，例如 $4$，$04$，$32$，$432$ 等；也有可能是 $5$ 的倍数，例如 $20$，$320$ 等。

Jimmy 的老师恰好路过此处，他向正沉迷于自己发现的 Jimmy 提了一个有趣的问题——给定一个指定的数字串，请问有多少连续子串是 $4$ 或者 $5$ 的倍数呢？

老师还特别提醒他：

* 连续子串的开头可以是 $0$；
* 两个连续子串只要是从数字串中的不同位置选出来的，它们就算是不同的；
* 如果一个连续子串同时是 $4$ 和 $5$ 的倍数，应当只被计算一次哦！

## 说明/提示

### 样例解释 1

所有满足题意的连续子串分别为：$0$，$04$，$0432$，$04320$，$4$，$432$，$4320$，$32$，$320$，$20$，$0$。

其中有两个相同的 $0$，这是因为它们是从数字串中的不同位置选出来的（一个在开头处，一个在结尾处）。

### 数据范围

- 对于 $10\%$ 的数据，保证 $n = 1$。
- 对于 $60\%$ 的数据，保证 $1 \leq n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
04320```

### 输出

```
11```

## 样例 #2

### 输入

```
2000```

### 输出

```
9```

# 题解

## 作者：guoshengyu1231 (赞：3)

## 思路：
这道题如果暴力枚举子串，那么时间复杂度 $O(n^2)$，肯定超时。
 

---

 
正解应该是用数学的方法，首先，我们要知道，一个数如果是  $5$  的倍数，那么它的末位一定是  $5$  的倍数。一个数如果是  $4$  的倍数，那么它的末两位一定是  $4$  的倍数。
 

---

证明：一个正整数一定可以写成 $x\times100+y$ 的形式，其中  $x$  为任意自然数， $y$  为小于  $100$  的自然数。那么 $x\times100$ 一定是  $4$  的倍数，所以是否能被  $4$  整除取决于  $y$  是否能被  $4$  整除，而  $y$  其实就是数的末两位（另一个证明也差不多)。

---


到这思路已经非常清晰了，枚举  $i$  为子串末尾，判断末尾是否是  $4$  或  $5$  的倍数，如果末尾是  $4$  或  $5$  的倍数，那么以此为末尾的子串都符合要求。
 

---


## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
long long sum=0;//记的开long long 
int main()
{
	cin>>a;
	int n=a.size();
	for(int i=0;i<n;i++)
	 {
		//注意：由于i是从0开始的，所以计数时要加1 
	 	if((a[i]-'0')%5==0) sum+=i+1;//判断5的倍数 
	 	else if(i>0&&((a[i-1]-'0')*10+a[i]-'0')%4==0)//判断末两位是4的倍数 
	 	 {
	 	 	if((a[i]-'0')%4==0) sum++;//判断第i个数是4的倍数 
	 	 	sum+=i;
	 	 }
	 	else if((a[i]-'0')%4==0) sum++;//判断第i个数是4的倍数 
	 }
	cout<<sum;
	return 0;
}
```

---

## 作者：Autumn_Dream (赞：2)

声明：本地人，参加过这场比赛，因为细节才 $10$ 分，大悲。

**思路：**

因为判断 $5$ 的倍数决策于个位，而判断 $4$ 的倍数决策于个位和十位，所以在处理重复时，判断 $5$ 的倍数计数器只加 $1$，否则加 $i$ 即可。（$i$ 为数字从左到右所在的位置）

```cpp
#include <bits/stdc++.h>
using namespace std;
int main () {
	char a[50200005];
	unsigned long long sum = 0;
	cin >> a;
	for (int i = 0; i < strlen (a); i++) {
		if (a[i] == '0' || a[i] == '5') sum += i + 1;
		if (a[i] == '4' || a[i] == '8') sum++;
	} 
	for (int i = 0; i < strlen (a) - 1; i++) {
		if (((a[i] - '0') * 10 + a[i + 1] - '0') % 4 == 0 && a[i + 1] != '0') {
			sum += i + 1;
		}
	} 
	cout << sum; 
	return 0;
}
```

---

## 作者：Sliarae (赞：1)

为方便设 $a_i(0 \le a_i \le 9)$ 表示数字串从左到右第 $i$ 为的数字是多少。代码中可以用 `a[i] = s[i] - '0'` 来表示。

由小学奥数可知，一个数是否是 $4$ 或 $5$ 的倍数只与它的最低两位有关。

证明：设一个 $k$ 位十进制数的表示为 $\overline{d_{k - 1}d_{k - 2}\ldots d_1 d_0}$，它的实际值是 $\sum\limits_{i = 0}^{k - 1}10^i d_i$，注意 $i \ge 2$ 时 $10^i$ 同时是 $4$ 和 $5$ 的倍数，所以它在模 $\gcd(4, 5) = 20$ 意义下（或者可以简单理解为，只关心一个数是否是 $4$ 或 $5$ 的倍数时）就是 $10d_{1} + d_0$，容易发现它就是这个数的最低两位。

将答案分成两部分计算：

- 子串的长度恰好为 $1$。这时数字串由单个数字组成，只需要判断这个数字是否是 $4$ 或 $5$ 的倍数即可。

- 子串的长度至少为 $2$。由前面的结论，我们只需要枚举子串的最后两位是 $i$ 和 $i + 1$，并判断这两位是否合法（是 $4$ 或 $5$ 的倍数）。如果合法，此时子串的开头可以是 $[1, i]$ 中的任意整数，这时将答案加上 $i$。

形式化地，答案可以表示成

$$

\sum\limits_{i = 1}^{n} [4 \mid a_i \vee 5 \mid a_i] + \sum\limits_{i = 1}^{n - 1} i[4  \mid \overline{a_i a_{i + 1}} \vee 5 \mid \overline{a_i a_{i + 1}}]

$$

时间复杂度 $O(n)$。

```cpp
#include <iostream>
#include <cstring>

using namespace std;
using LL = long long;

const int kN = 1e6 + 5;

int n;
int a[kN];
char s[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> s, n = strlen(s);
	copy(s, s + n, s + 1);
	for (int i = 1; i <= n; ++i) a[i] = s[i] - '0';
	LL ans = 0;  
	for (int i = 1; i <= n; ++i) ans += !(a[i] % 4) || !(a[i] % 5);
	for (int i = 1; i < n; ++i) {
		int x = a[i] * 10 + a[i + 1];
		if (!(x % 4) || !(x % 5))
			ans += i;
	}
	cout << ans << '\n';
	return 0; 
}
```

---

## 作者：yedalong (赞：1)

注意：$0$ 也是 $4$ 或 $5$ 的倍数。
## Solution
设输入的字符串为 $s$。   

考虑枚举每一个位置 $i$，加和以 $i$ 为个位的符合要求的连续子串的个数。  

对于一个位置 $i$，如果 $s_i$ 为 $0$ 或 $5$，那么以 $s_i$ 为个位的连续子串一定是 $5$ 的倍数，因为我们小学就知道一个数是否是 $5$ 的倍数只跟个位有关系。  

对于为 $4$ 的倍数的情况，有三种情况。  
第一种情况是 $s_i$ 为 $4$ 的倍数，那么答案只需加上这个数以前的前导 $0$ 个数加 $1$ 即可。可以想想为什么。  
第二种情况。对于 $s_i+10s_{i-1}$ 为 $4$ 的倍数时，那么以 $s_i$ 为个位、$s_{i-1}$ 为十位的所有连续子串也都是 $4$ 的倍数。因为 $100\bmod 4=0$，且个位和十位为 $0$ 的数一定能通过多个 $100$ 加和表示出来，因此这种数为 $4$ 的倍数，又因为 $s_i+10s_{i-1}$ 已经是 $4$ 的倍数了，所以以 $s_i$ 为个位、$s_{i-1}$ 为十位的所有连续子串也都是 $4$ 的倍数。  
第三种情况需要特判，及以上两种情况同时满足，可以将其归到 $s_i=0\lor s_i=5$ 这一类。  

最后时间复杂度 $O(n)$。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
string s;
int n,ans,w[1000005];
signed main(){
	cin>>s;
	n=s.size();
	s=' '+s;
	for(int i = 1;i<=n;i++){
		if(s[i-1]=='0') w[i]=w[i-1];
		else w[i]=i;
	}
	for(int i = n;i>=1;i--){
		if(s[i]=='0'||s[i]=='5'||((s[i]-'0')%4==0&&(s[i]-'0'+(s[i-1]-'0')*10)%4==0)) ans+=i;
		else{
			int tmp=0;
			if((s[i]-'0'+(s[i-1]-'0')*10)%4==0) tmp=max(tmp,i-1);
			if((s[i]-'0')%4==0) tmp=max(tmp,i-w[i]+1);
			ans+=tmp;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4185 [中山市赛 2024] 倍数子串](https://www.luogu.com.cn/problem/B4185)
## 思路：
本题为循环结构和分支结构的结合体。

这是一道数学题。

设这个数是 $n$。若 $n$ 能整除五，则 $n$ 的个位为五或者零。若 $n$ 能整除四，则 $n$ 的后两位是四的倍数。

~~都分析到这儿了，还不简单？~~ 我们只要遍历一遍字符串，简单判断一下即可。
## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans;string s;
int main(){
	cin>>s;
	for(int i=s.size()-1;i>=0;i--)
		if(s[i]=='5'||s[i]=='0')ans=ans+i+1;
        else if(((s[i]-'0')+(s[i-1]-'0')*10)%4==0){
			ans=ans+i+1;
			if(s[i]=='2'||s[i]=='6')ans--;
		}
        else if(s[i]=='4'||s[i]=='8')ans++;
	cout<<ans;
}
``````

---

## 作者：CARLJOSEPHLEE (赞：0)

# 题解：B4185 [中山市赛 2024] 倍数子串

## 本题思路

发现 $n$ 的范围是 $1e6$，所以尝试寻找 $O(n)$ 的解法。下面分别分析被 $4$ 整除和被 $5$ 整除。

- 被 $5$ 整除的数，充要条件是个位数为 $0$ 或 $5$，因为 $10$ 被 $5$ 整除，所以只需考虑个位数。

- 被 $4$ 整除的数，首先肯定要是偶数，对于末尾是 $0, 4, 8$ 的，前面那个数必须要是偶数；对于末尾是 $2, 6$ 的，前面那个数必须要是奇数。另一种做法是直接检查最后两位是否能被 $4$ 整除。因为 $100$ 被 $4$ 整除，所以只需考虑最后两位。

## AC 代码如下
```python
from sys import stdin
input = lambda: stdin.readline().rstrip() #这是python的快读


a = input()
n = len(a)
cnt = 0

for i in range(n):
    temp =  int(a[i]) #末尾数
    if temp in [0,5]:
        cnt += i+1
    elif temp in [2,6]:
        try:
            if int(a[i-1])%2 == 1:
                cnt += i
        except:
            pass
    elif temp in [4,8]:
        cnt += 1
        try:
            if int(a[i-1])%2 == 0:
                cnt += i
        except:
            pass
print(cnt)

---

## 作者：DashZhanghanxu (赞：0)

# 解析
奥数题。

一个数字是五的倍数的话，这个数末尾一定是零或五，如果是四的倍数的话，末尾两位一定是四的倍数，我们可以枚举每一个数作为末尾，如果该数的这一位和上一位组成的十位数为四的倍数，那么以这两个数为末尾的数字就是四的倍数（但该位不一定是四的倍数，要判断），如果末尾是五或零，就是五的倍数，并且以这个数为末尾的数字就是五的倍数，（提醒：如果数字为四或八，那么这个数也是四的倍数，但以其为末尾的数不一定是四的倍数，且以该数的这一位和上一位组成的十位数不一定为四的倍数，要特判。~~我就被这种情况卡了很久~~）将这些数字为末尾的数字总数之和加起来即为答案。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
signed main(){
	int ans=0;
	string s;
	cin>>s;
	int len=s.size()-1;
	for(int i=len;i>=0;i--){
		if(s[i]=='5'||s[i]=='0') {
			ans=ans+i+1; 
		}else if(((s[i]-'0')+(s[i-1]-'0')*10)%4==0){
			ans=ans+i+1;
			if(s[i]=='2'||s[i]=='6'){
				ans--;
			} 
		}else if(s[i]=='4'||s[i]=='8')ans++;
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：canwen (赞：0)

~~橙想了 $20$ 分钟才想出~~。

## Solution
显然，一个数字 $x$ 末尾是 $0$ 或 $5$，那么满足 $x \bmod 5 = 0$，这是小学课上教的所以不做证明。

然后想想 $4$ 的倍数有什么特征，当数字 $x \ge 100$ 时，假如末两位所组成的数字可以被 $4$ 整除，那么数字 $x$ 就能被数字 $4$ 整除。

为什么？~~其实也是小学教过的，只是笔者写的时候脑子抽了下没想到~~。

$10^{2},10^{3},10^{4},\dots$ 这些数字可以被写作 $4 \times 25,4 \times 250,4 \times 2500,\dots$。显然 $4$ 的倍数相加还是 $4$ 的倍数。

故可以线性统计出这部分的答案，特判 $x < 100$ 的情况即可。

复杂度 $O(n)$，可以通过此题。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}
constexpr int N = 1e6 + 5;
int s[N],n,ans;
signed main(){
	string x;
	cin >> x;
	n = x.size();
	_rep(i,1,n){
		s[i] = x[i-1]-'0';
	}
	if(s[1] % 4 == 0 || s[1] % 5 == 0) ans++;
	_rep(i,2,n){
		if(s[i] % 4 == 0 || s[i] % 5 == 0){
			// 特判一位数的 
			++ans;
		}
		int maxn = 0;
		if(s[i] == 0 || s[i] == 5){
			maxn = i-1;
		}
		if((s[i] + s[i-1]*10) % 4 == 0){
			maxn = max(maxn,i-1);
			// 注意只能被统计一次 
		}
		ans += maxn;
	}
	out(ans), pc;
	return 0;
}
```

---

## 作者：taiyuu (赞：0)

$5$ 的倍数满足个位是 $0,5$ ，$4$ 的倍数满足后两位能够被 $4$ 整除。

从前向后扫描字符串，以第 $i$ 位字符为结尾，如果其为

① $0$ 或 $5$ ，则有 $i$ 种方案满足要求。

② $4$ 或 $8$ , 有 $1$ 种方案满足要求，即其自己单独作为一个数字。

③ 其与前面一位字符共同构成 $4$ 的倍数，则有 $i-1$ 种方案满足要求。


```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long ans;
int num;
int main(){
	cin>>s;
	if(s[0]=='5'||s[0]=='0'||s[0]=='4'||s[0]=='8')	++ans;
	for(int i=1;i<s.size();++i){
		if(s[i]=='5'||s[i]=='0')	ans+=i+1;
		else{
			num=(s[i-1]-'0')*10+s[i]-'0';
			if(num%4==0){
				ans+=i;
			}
			if(s[i]=='4'||s[i]=='8')	++ans;	
		}
	}
	cout<<ans;
	return 0;
}

```

---


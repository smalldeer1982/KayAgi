# 集合求和

## 题目描述

给定一个集合 $s$（集合元素数量 $\le 30$），求出此集合所有子集元素之和。


## 说明/提示

**【样例解释】**

子集为：$\varnothing, \{ 2 \}, \{ 3 \}, \{ 2, 3 \}$，和为 $2 + 3 + 2 + 3 = 10$。

----

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le \lvert s \rvert \le 30$，$1 \le s_i \le 1000$，$s$ 所有子集元素之和 $\le {10}^{18}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
10
```

# 题解

## 作者：feecle6418 (赞：340)

我把这题的公式推导过程详细的说一下。

先选出指定的一个元素，加入子集；

首先，当子集里只有一个元素时，在其他剩余的元素中不能选出任何元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^0$ 次被选中。

当子集里有 2 个元素时，在其他剩余的元素中选出 1 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^1$ 次被选中。

当子集里有 3 个元素时，在其他剩余的元素中选出 2 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^2$ 次被选中。

当子集里有 $i\ (i\leq n)$ 个元素时，在其他剩余的元素中选出 $i-1$ 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^{i-1}$ 次被选中。

所以共有 $\sum_{i=1}^{n} {C_{n-1}^{i-1}}$ 次被选中，即 $2^{n-1}$ 次被选中。

也可以这样考虑：如果要选中 $x$，剩下的元素都可选可不选，所以总共有 $2^{n-1}$ 种方法。

代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[31],i=0,j;
long long s=0;
int main(){
    //cout<<s;
    while(cin>>a[i++]);//合写cin>>a[i];i++;
    for(j=0;j<i;j++){
        s+=a[j];
    }
    s*=pow(2,i-2);//注意，i-2!
    cout<<s;
    return 0;
}
```

---

## 作者：BL_Turtle (赞：3)

## 题目理解
题目要求我们计算一个集合所有子集的元素之和。例如，给定集合 ${2,3}$，它的子集有：空集 $∅,\{2\},\{3\},\{2,3\}$。这些子集的元素之和就是 $2 + 3 + 2 + 3 = 10$。
## 做题思路
直接计算所有子集的元素之和看起来需要枚举所有子集是比较慢的，为了提高效率，我们应该寻找一下存在的数学规律：
* 每个元素在所有子集中出现的次数是相同的；
* 对于有 $n$ 个元素的集合，每个元素会出现在 $2 ^ {n-1}$ 个子集中；
* 因此总和 $=$ 所有元素的和 $\times 2 ^ {n - 1}$。
## 正确代码:
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int main() {
	int n,a[30],cnt = 0;//a 用来存储元素, cnt 用来记录元素个数 
	long long sum = 0;  //sum 用来存储所有元素的和 
	while (cin >> n) {  //输入数据 
		a[cnt] = n;//输入一个元素后, 存储当前的元素 
		sum += n;  //把元素的值累加到 sum 里面 
		cnt++;
	}
	long long ans = sum * (1LL << (cnt - 1));//这里就是最后的答案了
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Yjb111111 (赞：3)

# 题目大意
给你一个集合求它的所有子集的所有元素之和。
# 推导过程
若设集合 $S$ 共有 $n$ 个元素，$m$ 个子集。

则 $m,n$ 关系如下

$$
m = \sum_{i = 0}^{n} \binom{n}{i}=2^n
$$

取 $S$ 中的一个元素 $x$。

对于每个子集它要么包含 $x$，要么不包含 $x$。

所以 $S$ 中的每个元素对答案的贡献都为自身数值乘 $2^{n-1}$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int x;
    long long s=0;//集合元素的和，必须开long long
    int ss=0;//集合元素的数量
    while(cin>>x){
        s+=x;//累加
        ss++;
    }
    cout<<(s<<(ss-1));//相当于cout<<(s*pow(2,ss-1));
    return 0;
}
```

---

## 作者：pengyirui (赞：2)

## 思路
### 暴力
我们观察这道题目，可以轻易地发现暴力完全不可行，所以我们要智取。
### 正解
注：对于以下的全部讲解，$n$ 表示集合中元素数量。       
对于每一个数字，我们可以计算其对于最后的和的贡献。   
首先，对于这个集合，有 $2^n$ 个子集。     
#### 证明
对于每一个数字都有选和不选两种情况，所以总共有：$$\displaystyle\prod^{n}_{i=1}{2}=2^n$$ 个子集。
******
而对于每个数字 $x$，都会对序列有 $2^{n-1}\cdot x$ 的贡献。
#### 证明
对于每一个数字，有选和不选两种可能，并且两种的情况数量相等，故不选的情况有 $2^{n-1}$ 种，贡献为 $2^{n-1}\times 0=0$；选的情况有 $2^{n-1}$ 种，贡献为 $2^{n-1}\cdot x$，相加之和为 $2^{n-1}\cdot x$。
*****
所以我们得出了结论，答案为 $$\displaystyle\sum^{n}_{i=1}{a_{i}\cdot 2^{n-1}}$$。
### 特别注意
1. 输入没有给 $n$，故你应该这样输入：```while(cin>>n)```；
2. 十年 OI 一场空，不开 long long 见祖宗；
3. 如果你使用 pow 函数：pow 函数结果为 double，请务必转化为 long long。
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,t;
signed main()
{
    int n;
    while(cin>>n)x+=n,t++;
    cout<<x*(long long)pow(2,t-1);
    return 0;
}
```
希望我的题解能够对您有所帮助，感谢您的阅读。

---

## 作者：kaikatandy (赞：2)

# 思考过程
令这个集合为 $s$。
- 考虑贡献。
- 我们在集合中选定一个元素，那么它总共出现的次数就是这个集合其它元素所构成的集合的子集个数，是 $2^{|s|-1}$，$|s|$ 代表集合 $s$ 的大小。
# 代码
```cpp
//Face the fear, make the future.
#include <bits/stdc++.h>
#define ll long long
using namespace std;

set<ll> s;

int main(){
	ll a;
	while(cin >> a) s.insert(a);
	ll n = s.size(), ans = 0;
	for(ll x: s) ans += (1 << (n - 1)) * x;
	cout << ans;
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：1)

# P2415 集合求和 题解

[题目传送门](https://www.luogu.com.cn/problem/P2415)

## 题目分析

看到题目，我们如果使用深度优先搜索（DFS）枚举出每个子集，会导致时间超时。我们需要另外思考方法。

### 推导结论

由深度优先搜索的思想可以知道，对于每一个数，它的选择有两种：**选或不选**。

那么对于含有 $N$ 个元素的集合，它**所有子集的个数**就是 $2^N$。

我们再单看一个数，它在所有子集中出现（被选择）的总次数就是**总子集数的一半**，即 $2^{N-1}$。

记集合 $s$ 中的元素总和为 $sum$，集合 $s$ 的元素个数为 $N$，则最终的答案就为 $sum \times 2^{N-1}$。

代码如下：  

```cpp
#include <iostream>
using namespace std;
int sz, num;
long long sum;

int main(){
	while(cin >> num) sum += num, sz++; // sz 记录集合中元素个数
	cout << sum * (1 << (sz - 1)); // 1 << N 就是 2 的 N 次方。
	return 0;
}
```


## 总结

本题考察数学，适合初学者练习。

感谢您的阅读！

---

## 作者：lijingshu_304775 (赞：0)

## 分析

题意：给定一个包含不超过 $30$ 个元素的集合，求所有子集的元素之和。例如，集合 $\{2,3\}$ 的所有子集为 $\varnothing, \{ 2 \}, \{ 3 \}, \{ 2, 3 \}$，其元素和为 $2+3+2+3=10$。

通过观察可以发现，每个元素在所有子集中出现的次数是相同的。

对于一个大小为 $n$ 的集合，每个元素出现的次数为 $2^{n-1}$。例如，集合 $\{2,3\}$ 中，元素 $2$ 和 $3$ 各出现 $2$ 次 $2^{2-1}=2$。

所以所有子集的元素之和为 $\left( \sum_{i=1}^{n} a_i \right) \times 2^{n-1}$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[30];
signed main() {
	int cnt = 0, sum = 0;
	while (cin >> a[cnt]) {
		sum += a[cnt];
		cnt++;
	}
	int mul = 1;
	for (int i = 1; i < cnt; i++) mul *= 2;
	cout << sum * mul;
	return 0;
}
```

---


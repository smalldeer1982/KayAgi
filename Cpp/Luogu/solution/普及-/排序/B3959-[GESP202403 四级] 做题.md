# [GESP202403 四级] 做题

## 题目描述

小杨同学为了提高自己的实力制定了做题计划，在第 $k$ 天时，他必须要完成 $k$ 道题，否则他就会偷懒。

小杨同学现在找到了一个题库，一共有 $n$ 套题单，每一套题单中有一定数量的题目。但是他十分挑剔，每套题单他只会使用一次，每一天也只能使用一套题单里的题目，之后那套题单就会弃之不用。对于每套题单，他不必完成题单内所有的题。

那么问题来了，小杨同学最多做题几天才偷懒呢？

## 说明/提示

### 数据规模与约定
对全部的测试数据，保证 $1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
4
3 1 4 1
```

### 输出

```
3```

# 题解

## 作者：yu1128_AKIOI (赞：28)

# 思路

贪心，先排序，再按题目所述，第 $k$ 天需完成 $k$ 道题。如果我们发现途中有偷懒的行为，就拒之不加；否则，我们让这一天内就做一道题。

**注意：最终结果 $sum$ 要初始化为 1，且在输出时要 -1。**

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum=1,n,a[1000010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i]<sum)continue;
		else sum++;
	}
	cout<<sum-1<<endl;
}
```

---

## 作者：dugeng0120 (赞：7)

## B3959 题解

这道题主要涉及的知识点是循环结构、排序和贪心,下面来看一下主要步骤:

1.  输入题目所给的整数 $n$ 和所有题单的题目个数。

实现代码:

```cpp
cin>>n;
for(int i=1;i<=n;i++) cin>>a[i];
```

2.  因为是贪心,所以我们要给数组从小到大排序，以便于后面的贪心。

实现代码:

```cpp
sort(a+1,a+n+1);
```

3.  二重循环寻找是否有题单可以满足小杨不会偷懒。为了不浪费题单,这里选择最小的满足题单题目小于等于当天需要完成的题目数的题单即可。

实现代码:

```cpp
for(int i=1;i<=n;i++){
	for(int j=temp;j<=n;j++){
		if(i<=a[j]){
			sum++;
			a[j]=0;
			temp=j;
			break;
			}
		}
	}
```

4.  输出答案。

实现代码:

```cpp
cout<<sum;
```

附上最终代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000005];
int n,sum,temp;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		for(int j=temp;j<=n;j++){
			if(i<=a[j]){
				sum++;
				a[j]=0;
				temp=j;
				break;
			}
		}
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：damnM3bro (赞：6)

## 思路
排序预处理后，对于每 $k$ 天，只需找到一个最小的 $a_i$ ，并选择此题单即可。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+19;
int a[N];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	sort(a+1,a+1+n);
	int ans=0;
	int now=1;
	for(int i=1;i<=n;++i){
		if(a[i]>=now){
			++now;
			++ans;
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：_UniqueGirl_ (赞：4)

## B3959题解

#### 1. 题目大意

小杨在第 $k$ 天要做相应数量的题目，不然他就会偷懒。但是他题单只做一遍，并且一天只做一个题单内的题目。求他什么时候会开始偷懒。

#### 2. 思路解析

1. 这题要用到贪心，所以首先要进行排序。

2. 用双重循环来判断，为了做的天数更多，也就是不浪费题单内的题目。我们选择最小的满足题单题目小于等于当天需要完成的题目数的题单，也就保证了浪费的题目尽可能地少。

#### 3. 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,ans,x;
long long a[1000005];

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//ios::sync_with_stdio(false);
   //输入
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
   //排序
	sort(a+1,a+n+1);
   //贪心
	for(int i=1;i<=n;i++)
		for(int j=x;j<=n;j++)
			if(i<=a[j]){
				ans++,a[j]=0,x=j;
				break;
			}
   //输出
	cout<<ans;
	return 0;//完结撒花
}

```

---

## 作者：jiangyunuo (赞：2)

### 主要意思：
[题目传送门](https://www.luogu.com.cn/problem/B3959)  
小杨要做题，一共有 $n$ 个题单，第 $i$ 个题单有 $a_i$ 题，一个题单只能用一次，小杨第 $k$ 天要做 $k$ 道题，如果满足不了，小杨就会偷懒，问我们这些题单小杨最多可以用多少天？
### 主要思路：
本题我们要先排序，以便接下来计算，接着，由于每天做的题目数量要等于天数，（当然，我们每天做的题单肯定是题目数量越少越好，不然题目数量多的题单没了，题目数量少的又不符合，在这时候，前面的排序就起作用了。）因此我们需要手动对比天数，模拟答案即可得出结果了。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x=1,n;  //定义题单数量（n）以及天数（x）。
int main(){
	cin>>n;   //输入题单数量。
        int a[n+1];  //定义每个题单题目数量（数组   a）。
	for(int i=1;i<=n;i++){  //循环 n 次，输入每个题单题目数量
		scanf("%d",&a[i]);   //输入每个题单题目数量。
	}
	sort(a+1,a+n+1);   //从小到大每个题单题目数量排序。
	for(int i=1;i<=n;i++){  //循环 n 次求出天数
      
		if(a[i]<x)continue;   //如果第 i 个题单的题目数小于天数，就是不符合条件，那么就要进入下个循环。
		else x++;  //反之，天数增加。
	}
	cout<<x-1<<endl;  //输出答案，因为 x 初值是 1，因此 x 实际上表示第 x 天小杨可以偷懒，所以要减 1。
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/155509678)

---

## 作者：xd244 (赞：1)

### 题解

题目描述：

在第 $d$ 天的时候，需要做 $\ge d$ 道题目，否则就会偷懒，求出他最多能多少天不偷懒。

其实这道题就是 [P2695 骑士的工作](https://www.luogu.com.cn/problem/P2695) 的弱化版。先对原数组 $a$ 排序，用两个变量存储天数 $d$ 和现在是第几个元素（排序后，这里用 $l$ 表示），比较 $a_l$ 与 $d$ 的大小，如果 $a_l\ge d$，那么 $ans+1,d+1,l+1$，否则就 $l+1$。最后输出 $ans$。

代码（一遍过）:
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n,a[1000010]={},l=1,d=1,ans=0;cin>>n;
	for(int c=1;c<=n;c++)cin>>a[c];
	sort(a+1,a+n+1);
	while(l<=n){
		if(a[l]>=d)ans++,l++,d++;
		else l++;
	}cout<<ans<<"\n";
}
```
祝大家 GESP ~~RE++~~ RP++

---

## 作者：WMWD (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3959)


------------
### B3959 [GESP202403 四级] 做题
提供非正确思路和正解思路两种思路。
#### 非正确思路：
相信很多人拿到题后会进行一个排序，然后进行一次遍历。如果第 $k$ 个数小于 $k$，天数减一。~~我就是这么做的。~~

这样的做法只会得到 $25$ 分，为什么呢，不妨看一组数据：
```
输入：
4
1 2 1 2
输出：
2

```
你会发现，这种办法只会输出 $1$！

然后你可能会这么做。如果第 $k$个 数小于 $k$，那么往后找到一个大于或等于的数。但是会超时。



------------

#### 正解思路：
这道题你不妨这么想，不管第 $k$ 个数是否小于 $k$，都往去寻找数，找寻的范围是从大于或等于 $k-1$ 的地方到 $n$。请你想想为什这么做。当找到了大于或等于 $k$ 的数。标记位置，方便下一次寻找。天数加一。退出循环。



------------
#### 代码方面：
- 数组大小一定要比 $10 ^ 6$ 大！
- 排序请用 `sort` 。更省时间。


------------
#### CODE ：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000009
int n,a[1000009];
int ans,s;//ans 记录天数，s 记录上一次的位置
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//优化
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];//输如
	sort(a+1,a+1+n);//排序，注意细节
	for(int k=1;k<=n;k++){
		for(int j=s;j<=n;j++){
			if(k<=a[j]){
				ans++;
				a[k]=i;
				s=k;
				break;
			}
		}
	}
	cout<<ans;
	return 0;//完美结束
}


```
可以参考官方代码 ：[https://gesp.ccf.org.cn/101/attach/1602047134662688.pdf](https://gesp.ccf.org.cn/101/attach/1602047134662688.pdf)

对于为什么寻找范围是从大于或等于 $k-1$ 的地方开始的解释。因为经过排序后的数组 $a$ 是升序的，也就是说在大于或等于 $k-1$ 的地方的前面不可能存在大于 $k$ 的数。这可以节约时间。

---

## 作者：lqsy002 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/B3959)。

## 解题思路

因为天数是递增的，所以每天要完成的题也是递增的，为了使不偷懒的天数最多，在满足条件的情况下，题单越小越优。

于是想到优先队列，将题单的大小加入小根堆，每次将堆顶元素与天数比较，直到找到合适的题单或剩余题单均不满足。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
int n,ans;
bool flag;
priority_queue<int,vector<int>,greater<int> >q;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1,a;i<=n;++i){
        cin>>a;
        q.push(a);
    }
    for(int i=1;i<=n&&!q.empty();++i){
        flag=false;
        while(!q.empty()&&!flag){
            if(q.top()>=i)
                flag=true;
            q.pop();
        }
        ans+=flag;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：TPJX (赞：0)

[题目链接](https://www.luogu.com.cn/problem/B3959)

这是一道贪心入门题。

## 贪心的策略
我们可以观察到，题单的题目数量越少，越容易在较早的时间完成。因此，我们应该优先选择题目数量较少的题单，以便在较早的时间完成。同时，如果小杨能够在第 $k$ 天完成题单中的题目，那么他在之后的天数都可以利用剩余的题单来继续做题。

基于这个思路，我们首先将题单按照题目数量**从小到大**排序，然后从小到大依次检查题单。对于每个题单，如果题目数量**大于等于**当前天数，那么就可以在当前天数完成**当前**题单的题目，并且完成后的天数加一。否则，就继续遍历下一个题单，直到找到题目数量大于等于当前天数的题单，找到后再将天数加一。**（这就意味着找到了当天可以做的不会偷懒的题单）** 这样，我们就可以找到最多连续做题的天数。最后输出天数即可。

## 代码实现
### C++
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1000010];
int main() {
    int n;
    scanf("%d",&n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
	}
    sort(a, a + n); // 将题单按题目数量从小到大排序
    int days = 0; // 最多偷懒的天数（也可以叫ans） 
    for (int i = 0; i < n; ++i) {
        // 判断当前题单中的题目数量是否大于等于当前天数
        // 若是，则可以在当天完成
        if (a[i] >= days + 1) {
            ++days; // 完成题目后增加一天
        }
    }
    printf("%d",days);
    return 0;
}
```

### Python
```python
n = int(input())
a = list(map(int, input().split()))
a.sort()  # 将题单按题目数量从小到大排序
days = 0  # 最多偷懒的天数
for i in range(n):
    # 判断当前题单中的题目数量是否大于等于当前天数
    # 若是，则可以在当天完成
    if a[i] >= days + 1:
        days += 1  # 完成题目后增加一天

print(days)

```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/B3959)
# 分析
对于第 $k$ 天，如果能找到一个题目数大于 $k$ 且之前没有用做过题的题单，那么就将答案加 $1$，否则就输出结果，结束程序。

为了方便找题目数大于 $k$ 个的题单，所以在最开始可以进行升序排序，之前已经排除过的就不需要再判断了。

好啦，可以开始愉快的写代码啦！
# code
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,arr[1000000],ans,loction;
int main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>arr[i];
	sort(arr,arr+n);//升序排序
	for(ans=1;loction<n;++ans,++loction) {
		while(arr[loction]<ans&&loction<n-1) ++loction;//找到题目数大于1且之前没有做过题目的题单
		if(arr[loction]<ans&&loction+1==n) break;//退出循环
	}
	cout<<--ans;//输出结果，一定要将ans减1
	return 0;
}
```

---

## 作者：LG086 (赞：0)

### 分析

输入一个整数为 $n$，接下来输入 $n$ 个整数 $a_1, a_2, \dots a_n$。

定义变量 $k$ 和 $ans$，分别记录要完成的题数和天数。  
对输入的数进行排列，直接暴力判断，如果满足要求的，$k$ 和 $ans$ 都增加，不满足条件的，一直寻找直到满足条件或者是循环结束。  
最后输出答案即可。

------------
### 代码

```cpp
#include<bits/stdc++.h>
#define LG086 signed
int n,ans,i,k=1,a[1000100];
LG086 main(){
    std::cin>>n;
    for(i=1;i<=n;i++)
    std::cin>>a[i];
    std::sort(a+1,a+1+n);i=1;
    while(i<=n)
    {if(a[i]>=k)++ans,k++;i++;}
    std::cout<<ans;
}
```

---

## 作者：lpx666666 (赞：0)

## 题面
给出长度为 $n$ 的序列代表小杨同学所有的提单，每天做题的数量要比前一天多 $1$ 道，求这些题单最多能做几天。
## 思路
这道题基本上是一眼出贪心，因为每天的做题数是累加的，所以肯定从最小的题单开始，直到没有题单数量足够为止。

我第一想到的是桶排，但 $a_i$ 数据过大直接否定。

那就只能快排，然后模拟数组出结果了。
## 代码
又到了你们最喜欢的环节了。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,arr[1000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>arr[i];
	}
	sort(arr+1,arr+n+1);//从小到大排序 
	int k=1;//初始为第一天 
	for(int i=1;i<=n;i++){
		if(arr[i]>=k){//判断此题单是否不小于此天题目数 
			k++;//增加天数 
		}
	}
	cout<<k-1;//最后一天不满足条件 
	return 0;//华丽收尾 
}

```

---

## 作者：lucasincyber (赞：0)

## 思路
首先，对于每一天 $x$，需要找到一个题单 $k$，使 $a_k ≥ x$。

我们先把题库 $a$ 从小到大排序，接着可以直接贪心，只要有题单满足 $a_k ≥ x$，就将题单用上，同时天数加 $1$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

int n;
int a[N]; 

int main()
{
 	scanf("%d", &n);
 	for (int i = 1; i <= n; i++)
 		scanf("%d", &a[i]);
	sort(a + 1, a + n + 1); // 从小到大排序
	int ans = 1; // 因为第 1 天是开始，所以初始化为 1
	for (int i = 1; i <= n; i++)
		if (a[i] >= ans) // 满足条件，天数加 1
   		    ans++;
	printf("%d\n", ans - 1); //最后一天是满足不了的
	return 0;
}
```

---

## 作者：zyn0309 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3959)
# 思路
因为天数 $k$ 递增，为了让之后可以使用的题单更多，应该选择 $a_i$ 最接近天数 $k$ 的题单 $i$。

只需要对数组 $a$ 从小到大进行排序，找到大于等于 $k$ 的 $a_i$ 后将 $k$ 加 $1$ 即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,a[N],k=1;
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)
	  cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i)
	  if(a[i]>=k)
	    ++k;
	cout<<k-1;//最后一天没有满足所以要减一
}

---


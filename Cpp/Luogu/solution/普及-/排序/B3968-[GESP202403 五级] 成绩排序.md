# [GESP202403 五级] 成绩排序

## 题目描述

有 $n$ 名同学，每名同学有语文、数学、英语三科成绩，你需要按照如下规则对所有同学的成绩从高到低排序：

1. 比较总分，高者靠前；
2. 如果总分相同，则比较语文和数学两科的总分，高者靠前；
3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前；
4. 如果仍相同，则二人并列。

你需要输出每位同学的排名，如遇 $x$ 人并列，则他们排名相同，并留空后面的 $x - 1$ 个名次。例如，有 $3$ 名同学并列第 $1$，则后一名同学自动成为第 $4$ 名。

## 说明/提示

- 对 $30\%$ 的数据，$N \leq 100$，且所有同学总分各不相同。
- 对全部的测试数据，保证 $2 \leq N \leq 10^4$，$0 \leq c_i, m_i, e_i \leq 150$。

## 样例 #1

### 输入

```
6
140 140 150
140 149 140
148 141 140
141 148 140
145 145 139
0 0 0```

### 输出

```
1
3
4
4
2
6```

# 题解

## 作者：Ravener (赞：40)

首先看到这道题，知道这是一个排序夹杂了结构体的题。  
然而看到排序规则时彻底懵了：

>1. 比较总分，高者靠前；
>2. 如果总分相同，则比较语文和数学两科的总分，高者靠前；
>3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前；
>4. 如果仍相同，则二人并列。


于是在经过了 114514 次思考后，有了下面的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct student
{
	int chn=0;//语文
  	int mah=0;//数学
      	int eng=0;//英语
  	int sum=0;//总分
  	int num=0;//序号
	int pm=0;//排名
};
bool cmp1(student a,student b)
{
	if(a.sum!=b.sum)//对应规则 1
		return a.sum>b.sum;
	else if((a.mah+a.chn)!=(b.mah+b.chn))//对应规则 2
		return (a.mah+a.chn)>(b.mah+b.chn);
	else if(max(a.mah,a.chn)!=max(b.mah,b.chn))//对应规则 3
		return max(a.mah,a.chn)>max(b.mah,b.chn);
	else//对应……？（挖个坑，后文再填）
		return a.num<b.num;
}
main()
{
	student stu[200005];
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>stu[i].chn>>stu[i].mah>>stu[i].eng;
		stu[i].sum=stu[i].chn+stu[i].mah+stu[i].eng;
		stu[i].num=i;
	}
	sort(stu+1,stu+1+n,cmp1);
 	for(int i=1;i<=n;i++)
		stu[i].pm=i;
	for(int i=1;i<=n;i++)
		cout<<stu[i].pm<<"\n";
	return 0;
}
```

然而结局嘛……  
不用说的，全 WA 了。

------------

为何？  
看了一下输出格式：

>**注意：请不要按排名输出同学的序号，而是按同学的顺序输出他们各自的排名。**

原来如此。  
又想了 1919810 次后，就有了下面的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct student
{
	int chn=0,mah=0,eng=0,sum=0,num=0;
	int pm=0;
};
bool cmp1(student a,student b)
{
	if(a.sum!=b.sum)
		return a.sum>b.sum;
	else if((a.mah+a.chn)!=(b.mah+b.chn))
		return (a.mah+a.chn)>(b.mah+b.chn);
	else if(max(a.mah,a.chn)!=max(b.mah,b.chn))
		return max(a.mah,a.chn)>max(b.mah,b.chn);
	else
		return a.num<b.num;
}
bool cmp2(student a,student b)
{
	return a.num<b.num;
}
main()
{
	student stu[200005];
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>stu[i].chn>>stu[i].mah>>stu[i].eng;
		stu[i].sum=stu[i].chn+stu[i].mah+stu[i].eng;
		stu[i].num=i;
	}
	sort(stu+1,stu+1+n,cmp1);
  	for(int i=1;i<=n;i++)
		stu[i].pm=i;
	sort(stu+1,stu+1+n,cmp2);
	for(int i=1;i<=n;i++)
		cout<<stu[i].pm<<"\n";
	return 0;
}
```

这里多了的 ``bool cmp2(student a,student b)`` 和 ``sort(stu+1,stu+1+n,cmp2)`` 就是用来实现这一功能的。

然而……  
还是全 WA 了。

------------

又是为何？  
仔细再读一遍题目：
>你需要输出每位同学的排名，**如遇 $x$ 人并列，则他们排名相同，并留空后面的 $(x-1)$ 个名次。**

那么，具体怎么实现？  
这是我想了 956382 次后想出来的做法：  

首先，在结构体里多定义一个 ``bool`` 型变量，并赋值为 ``false``：

```cpp
struct student
{
	int chn=0,mah=0,eng=0,sum=0,num=0;
	int pm=0;
	bool iscp=0;
};
```

然后再把排序规则的最后一个 ``else`` 改一改：

```cpp
else//填前面的坑，做标记，对应规则 4
{
	if(a.num<b.num)
		b.iscp=1;
	else
		a.iscp=1;
	return a.num<b.num;
}
```

接着在两个 ``sort`` 语句间的 ``for`` 循环改一改：

```cpp
for(int i=1;i<=n;i++)//查重
{
	if(stu[i].pm) continue;//关键，做到留空名次
	else
	{
		stu[i].pm=i;
		int cur=1;
		while(stu[i+cur].iscp)//关键，做到排名相同
		{
			stu[i+cur].pm=stu[i].pm;
			cur++;
		}
	}
}
```

这样便大功告成了！  

------------

最后，把这些整合一下，AC 代码就有了！  
代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct student
{
	int chn=0,mah=0,eng=0,sum=0,num=0;
	int pm=0;
	bool iscp=0;
};
bool cmp1(student a,student b)
{
	if(a.sum!=b.sum)
		return a.sum>b.sum;
	else if((a.mah+a.chn)!=(b.mah+b.chn))
		return (a.mah+a.chn)>(b.mah+b.chn);
	else if(max(a.mah,a.chn)!=max(b.mah,b.chn))
		return max(a.mah,a.chn)>max(b.mah,b.chn);
	else
	{
		if(a.num<b.num)
			b.iscp=1;
		else
			a.iscp=1;
		return a.num<b.num;
	}
}
bool cmp2(student a,student b)
{
	return a.num<b.num;
}
main()
{
	student stu[200005];
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>stu[i].chn>>stu[i].mah>>stu[i].eng;
		stu[i].sum=stu[i].chn+stu[i].mah+stu[i].eng;
		stu[i].num=i;
	}
	sort(stu+1,stu+1+n,cmp1);
	for(int i=1;i<=n;i++)
	{
		if(stu[i].pm) continue;
		else
		{
			stu[i].pm=i;
			int cur=1;
			while(stu[i+cur].iscp)
			{
				stu[i+cur].pm=stu[i].pm;
				cur++;
			}
		}
	}
	sort(stu+1,stu+1+n,cmp2);
	for(int i=1;i<=n;i++)
		cout<<stu[i].pm<<"\n";
	return 0;
}
```

（题解仅供参考，如有谬误或纰漏欢迎 at 我并指正）

---

## 作者：xyx404 (赞：15)

## 思路：
使用结构体快排，自己写判断函数，按照题目给出的进行判断，判断后历遍一次结构体数组，把学生的排名赋值，然后按照输入的顺序再排序一次最后输出就可以了。

如何赋值排名，如果和上一个人的排名是相同的就赋值为上一个人的排名，如果不是直接赋值为 $i$。

## 代码：
```cpp
// 以下代码与思路完全相同 
// 本代码已经提交测试并且已经 AC 
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long long sum/* 总和 */,chinese/* 语文 */,math/* 数学 */,english/*english 可以不定义在结构体里 */;
	long long pm/* 排名 */,bh/* 编号 */;
}stud[10002]; 
bool cmp(node x,node y){// 排序排名降序 
	if(x.sum!=y.sum)return x.sum>y.sum;// 判断总分
	else{// 如果总分相同 
		if(x.chinese+x.math!=y.chinese+y.math)return x.chinese+x.math>y.chinese+y.math;// 比较语文和数学两科的总分
		else{
			if(max(x.chinese,x.math)!=max(y.chinese,y.math))return max(x.chinese,x.math)>max(y.chinese,y.math);//比较语文和数学两科的最高分
			else{
				// 并列 
				return 0;// 可以 return 1 也可以 return 0 
			}
		}
	}
}
bool cmp1(node x,node y){// 按编号复原升序 
	return x.bh<y.bh;// 按编号复原 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>stud[i].chinese>>stud[i].math>>stud[i].english,stud[i].sum=stud[i].chinese+stud[i].math+stud[i].english/* 输入并计算总和 */,stud[i].bh=i/* 赋值编号 */; 
	sort(stud+1,stud+1+n,cmp);// 排序排名
	int cnt=1;// 上一个人的排名 
	for(int i=1;i<=n;i++){
		if(stud[i].sum==stud[i-1].sum// 判断总分 
		&&stud[i].chinese+stud[i].math==stud[i-1].chinese+stud[i-1].math// 判断语文和数学两科的总分
		&&max(stud[i].chinese,stud[i].math)==max(stud[i-1].chinese,stud[i-1].math)){// 比较语文和数学两科的最高分
			stud[i].pm=cnt;// 如果都相同那么说明并列 
		}
		else{
			cnt=i;// 将名次赋值为 i 
			stud[i].pm=cnt;// 赋值排名 
		}
		//cout<<stud[i].bh<<" "<<stud[i].sum<<" "<<stud[i].chinese+stud[i].math<<" "<<stud[i].chinese<<" "<<stud[i].math<<"\n";
	}
	sort(stud+1,stud+1+n,cmp1);// 还原编号 
	for(int i=1;i<=n;i++)cout<<stud[i].pm<<"\n";// 输出排名 
	return 0;
}


```

---

## 作者：Francium_ (赞：9)

# 思路
排序加模拟，至于排序的比较题目已经说的很清楚了，就主要是并列的处理，可以排两次序，第一次排完后两两比较，如果题目中的三项要求都相等，则前面的序号赋值后面的序号，否则就把 $i$ 赋值给序号，后面再用初始位置排一次序再输出，其他细节看代码吧。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	int e, c, m, sum, pai, num;//e英语，c语文，m数学，sum存储三科成绩和，pai存储第几名，num存储原来的下标
} a[10004];

bool cmp(node x, node y) {//根据题意模拟
	if (x.sum != y.sum)
		return x.sum > y.sum;
	if (x.c + x.m != y.c + y.m)
		return x.c + x.m > y.c + y.m;
	if (max(x.c, x.m) != max(y.c, y.m))
		return max(x.c, x.m) > max(y.c, y.m);
	return false;
}

bool cmp1(node x, node y) {//用下标排序
	return x.num < y.num;
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].c >> a[i].m >> a[i].e;
		a[i].num = i;//存储原下标
		a[i].sum = a[i].c + a[i].m + a[i].e;//计算和
	}
	sort(a + 1, a + n + 1, cmp);//第一遍排序
	for (int i = 1; i <= n; i++) {
		if (a[i].sum == a[i - 1].sum && a[i].c + a[i ].m == a[i - 1].m + a[i - 1].c
		        && max(a[i].c, a[i ].m) == max(a[i - 1].m, a[i - 1].c))//如果相等
			a[i].pai = a[i - 1].pai;//并列
		else
			a[i].pai = i;//这里因为两个下标不会冲突，所以并列的会顺延
	}
	sort(a + 1, a + n + 1, cmp1);//第二遍排序
	for (int i = 1; i <= n; i++)
		cout << a[i].pai << endl;//输出
	return 0;//完结撒花！：）
}
```

---

## 作者：zxy1919810 (赞：8)

## B3968 [GESP202403 五级] 成绩排序 题解
[题意](https://www.luogu.com.cn/problem/B3968)在这里。

思路：使用**结构体数组**，**自定义比较规则**排序。
```cpp
struct node{
	int m,c,e,number1/*编号*/,number2/*排名*/;
}a[10009];
```

按题目说的：

比较总分，高者靠前； 

如果总分相同，则比较语文和数学两科的总分，高者靠前； 

如果仍相同，则比较语文和数学两科的最高分，高者靠前； 

如果仍相同，则二人并列。 

我们可以写出比较函数。
```cpp
bool cmp(const node&a,const node&b){
	if(a.m+a.e+a.c!=b.m+b.e+b.c) return a.c+a.e+a.m>b.e+b.c+b.m;
	if(a.c+a.m!=b.c+b.m) return a.c+a.m>b.c+b.m;
	return max(a.c,a.m)>max(b.c,b.m);
}
```
因为排序时没有考虑并列，所以需要处理并列的情况。
```cpp
for(int i=1;i<=n;i++){
	a[i].number2=i;
	if(a[i].m+a[i].e+a[i].c==a[i-1].m+a[i-1].e+a[i-1].c&&a[i].c+a[i].m==a[i-1].c+a[i-1].m&&max(a[i].c,a[i].m)==max(a[i-1].c,a[i-1].m))
		a[i].number2=a[i-1].number2;
}
```
最后贴上完整代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int m,c,e,number1/*编号*/,number2/*排名*/;
}a[10009];
int n,ans[10009];
bool cmp(const node&a,const node&b){
	if(a.m+a.e+a.c!=b.m+b.e+b.c) return a.c+a.e+a.m>b.e+b.c+b.m;
	if(a.c+a.m!=b.c+b.m) return a.c+a.m>b.c+b.m;
	return max(a.c,a.m)>max(b.c,b.m);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].c>>a[i].m>>a[i].e,a[i].number1=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		a[i].number2=i;
		if(a[i].m+a[i].e+a[i].c==a[i-1].m+a[i-1].e+a[i-1].c&&a[i].c+a[i].m==a[i-1].c+a[i-1].m&&max(a[i].c,a[i].m)==max(a[i-1].c,a[i-1].m))
			a[i].number2=a[i-1].number2;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[j].number1==i)
				cout<<a[j].number2<<endl;
	return 0;
}
```

---

## 作者：穼柗° (赞：4)

可以把学生封装成类，接着先按成绩排序，确定好他们的排名，然后再按输入序号排序，最后输出
### Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
class xxs {
    public:
        short c,m,e,sum,idx,pm; // 分别为语文成绩、数学成绩、英语成绩、总分、输入序号、排名
        xxs() {c=m=e=idx=pm=0;}
        inline bool operator <(const xxs &b) const {return this->idx<b.idx;} // 以便第二次排序
        inline bool operator >(const xxs &b) const {return this->idx>b.idx;} // 同上
} arr[10000];
inline bool compare_1(xxs a,xxs b) {
    if(a.sum!=b.sum) return a.sum>b.sum; // 若总分不同，按总分降序排序
    else if(a.e!=b.e) return a.e<b.e; // 若语数总分不同，按语数总分降序排序（总分相同，所以语数总分=总分-英语成绩）
    else if(max(a.c,a.m)!=max(b.c,b.m)) return max(a.c,a.m)>max(b.c,b.m); // 若语数最高分不同，按语数最高分降序排序
    else return a.idx<b.idx; // 保持排序的稳定性，好习惯
}
signed short n;
signed main(void) {
    scanf("%hd",&n); // 输入
    register short i;
    for(i=0;i<n;i++)
        scanf("%hd%hd%hd",&arr[i].c,&arr[i].m,&arr[i].e),
        arr[i].idx=i,arr[i].sum=arr[i].c+arr[i].m+arr[i].e;
    sort(arr,arr+n,compare_1); // 按成绩降序排序
    for(i=0;i<n;i++)
        if(!i) arr[i].pm=1; // 防止下面的判断取到负下标
        else if(arr[i].sum==arr[i-1].sum&&
                arr[i].e==arr[i-1].e&&
                max(arr[i].c,arr[i].m)==max(arr[i-1].c,arr[i-1].m))
            arr[i].pm=arr[i-1].pm; // 总分相同&&语数总分相同&&语数最高分相同 说明两人并列
        else arr[i].pm=i+1; // 此人的排名为i+1  注意：i从0开始
    sort(arr,arr+n); // 将学生按输入顺序排序
    for(i=0;i<n;i++)
        printf("%hd\n",arr[i].pm); // 输出
    return 0;
}
```

---

## 作者：__youzimo2014__ (赞：2)

## 题目简述

给你所有学生的成绩单，请你输出他们所有人的排名。
比较方法：

1. 比较总分，高者靠前；
2. 如果总分相同，则比较语文和数学两科的总分，高者靠前；
3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前；
4. 如果仍相同，则二人并列。

如遇 $x$ 人并列，则他们排名相同，并留空后面的 
$x−1$
个名次。

## 思路

放眼望去，本题目就是一道比较简单的模拟题。

可以用结构体记录学生的成绩。

但这里有个小问题：排序之后，顺序就乱了，题目要求按照输入顺序输出，怎么办呢？

可以在结构体里放上一个子属性，叫做 $id$，用它记录输入时本学生的编号。  
这样做有个额外的好处：由于 $id$ 不会重复，所以它可以让排序更稳定。

最后用个数组记录答案（因为顺序是乱的，不好输出）

```cpp
#include <bits/stdc++.h>
using namespace std;
struct stu {
    int c, m, e, id;
    stu() { // 默认构造函数
        c = m = e = 0;
    }
    stu(int c_, int m_, int e_, int id_) { // 构造函数，可快速录入成绩单
        c = c_;
        m = m_;
        e = e_;
        id = id_;
    }
} st[10005]; // 可爱的学生们（的成绩）
bool cmp(stu a, stu b) {
    if (a.c + a.m + a.e != b.c + b.m + b.e) return (a.c + a.m + a.e >  b.c + b.m + b.e); // 比较总分
    if (a.c + a.m != b.c + b.m) return (a.c + a.m > b.c + b.m); // 比较语文 + 数学
    if (max(a.c, a.m) != max(b.c, b.m)) return (max(a.c, a.m) > max(b.c, b.m)); // 比较max(语文, 数学)
    return a.id < b.id; // 注意保持排序的稳定性哦
}
int ans[10005];
int main(int argc, const char * argv[]) {
    // insert code here...
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> st[i].c >> st[i].m >> st[i].e;
        st[i].id = i;
    }
    sort(st+1, st+n+1, cmp);
    stu lastScore = stu(-1, -1, -1, 0); // 上一名成绩与其他学生不一样的学生（的成绩）
    int lastRanking = 0; // 上一名学生（的名次）
    for (int i = 1; i <= n; i++) {
        if ((lastScore.c + lastScore.m + lastScore.e == st[i].c + st[i].m + st[i].e) && // 看总分是否一样
            (lastScore.c + lastScore.m == st[i].c + st[i].m) && // 看语文和数学两科的总分是否一样
            (max(lastScore.c, lastScore.m) == max(st[i].c, st[i].m)) // 看语文和数学的最高分是否一样
            ) { // 恭喜两位学生并列第 lastRanking 名
            ans[st[i].id] = lastRanking;
            lastScore = st[i];
        } else { // 恭喜这位学生获得第 i 名
            ans[st[i].id] = i;
            lastRanking = i;
            lastScore = st[i];
        }
    }
    for (int i = 1; i <= n; i++) {
        cout << ans[i] << endl;
    }
    return 0;
}

```

---

## 作者：dlzlj_2010 (赞：2)

题目看着挺吓人，但其实排两遍序就好了。  
我们**先按照题目的规则**排一遍序，再遍历数组**处理一下并列的排名**，最后再**按照输入顺序**排回去输出就好了。
## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
struct node{//存储同学信息
	int c,m,e;//成绩
	int sum;//总分
	int id,rk;//输入顺序，排名
}a[N];
int n;
bool cmp1(node a,node b){//第一遍排序
	if(a.sum!=b.sum)return a.sum>b.sum;//总分不同直接看总分
	if(a.c+a.m!=b.c+b.m)return a.c+a.m>b.c+b.m;//比较语数两科总分
	if(max(a.c,a.m)!=max(b.c,b.m))return max(a.c,a.m)>max(b.c,b.m);//比较语数最高分
}
bool cmp2(node a,node b){//第二遍排序
	return a.id<b.id;
}
bool check(int i){//判断第i个学生以前一个是否并列
	node a=::a[i],b=::a[i-1];
	if(a.sum!=b.sum||a.c+a.m!=b.c+b.m||max(a.c,a.m)!=max(b.c,b.m))return 0;
	return 1;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int a,b,c;
		cin>>a>>b>>c;
		::a[i]={a,b,c,a+b+c,i};
	}
	sort(a+1,a+1+n,cmp1);
	int bl=0;//并列的名次
	for(int i=1;i<=n;i++){
		if(check(i)){//并列
			a[i].rk=bl;//排名为并列的名次
		}
		else{//否则
			bl=i;//更新并列名次
			a[i].rk=i;//排名即为i
		}
	}
	sort(a+1,a+1+n,cmp2);
	for(int i=1;i<=n;i++){
		cout<<a[i].rk<<'\n';
	}
	return 0;
}
```

---

## 作者：ny_Dacong (赞：2)

这道题可以用结构体存储每位学生的成绩。

不过结构体需要写自定义排序函数，且本题需要判断并列的情况。

自定义排序函数按照题目要求写即可。

并列的判断可以在排序结束后让每个学生与他前面的学生比较，如果并列，则该学生名次等于前一个学生的名次。否则顺次排列。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int pos[10005];
struct students{
    int Chinese,math,English,id,ranking,cmmax,sum;
}stu[10005];
bool cmp(students a,students b){
    if(a.sum == b.sum){
        if(a.sum-a.English == b.sum-b.English){
            return a.cmmax > b.cmmax;
        }else{
            return a.sum-a.English > b.sum-b.English;
        }
    }else{
        return a.sum > b.sum;
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        int ch,ma,en;
        scanf("%d%d%d",&ch,&ma,&en);
        stu[i] = {ch,ma,en,i,0,max(ch,ma),ch+ma+en};
    }
    sort(stu+1,stu+1+n,cmp);
    for(int i = 1; i <= n; i++){
        stu[i].ranking = i;
        if(stu[i].cmmax == stu[i-1].cmmax && stu[i].sum == stu[i-1].sum && stu[i].sum-stu[i].English == stu[i-1].sum-stu[i-1].English){
            stu[i].ranking = stu[i-1].ranking;
        }
        pos[stu[i].id] = i;
    }
    for(int i = 1; i <= n; i++){
        printf("%d\n",stu[pos[i]].ranking);
    }
    return 0;
}
```

---

## 作者：InfiniteRobin (赞：1)

## B3968 [GESP202403 五级] 成绩排序  
[题目传送门](https://www.luogu.com.cn/problem/B3968)  
### 题目大意

------------
给你几位学生的成绩，根据给定的规则进行排序，最后**按同学的顺序输出他们各自的排名**。

------------
### 思路

------------
看到每个同学都有不同的三科成绩，果断使用结构体存储数据并进行排序。  
  
但考虑到输出顺序中并列排名的要求，可以对排序好的结构体数组进行处理。
```cpp
for(int j=1;j<=n;j++){
   	//判断是否符合题目中说的并列要求 
   	if(a[j].c+a[j].e+a[j].m==a[j-1].c+a[j-1].e+a[j-1].m && a[j].c+a[j].m==a[j-1].c+a[j-1].m &&  max(a[j].c,a[j].m)==max(a[j-1].c,a[j-1].m)){
   		//如果并列，此人的排名就等于前一个人的排名 
		a[j].rank=a[j-1].rank;
	}
	else{
		//否则正常排名 
		a[j].rank=j;
	}
}
```


------------
接下来，考虑到学生的序号是混乱的，可以采取暴力的方式，用双重循环找到每一位学生排序后的位置，然后输出其对应的排名。  
  
时间复杂度为 $\mathcal{O(n^2)}$。


------------
### AC CODE

------------
```cpp
#include<bits/stdc++.h>
using namespace std;

struct student{
  int dex,c,m,e,rank;  
}a[100005];

//排序 
bool cmp(student p,student q){
    if(p.c+p.e+p.m==q.c+q.e+q.m){
    	if(p.c+p.m==q.c+q.m){
			return max(p.c,p.m)>max(q.c,q.m);
		}
		else{
			return p.c+p.m>q.c+q.m;
		}
	}
	else{
		return p.c+p.e+p.m>q.c+q.e+q.m;
	}
}



int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].c>>a[i].m>>a[i].e;
        a[i].dex=i;
    }
    sort(a+1,a+n+1,cmp);

for(int j=1;j<=n;j++){
   	//判断是否符合题目中说的并列要求 
   	if(a[j].c+a[j].e+a[j].m==a[j-1].c+a[j-1].e+a[j-1].m && a[j].c+a[j].m==a[j-1].c+a[j-1].m &&  max(a[j].c,a[j].m)==max(a[j-1].c,a[j-1].m)){
   		//如果并列，此人的排名就等于前一个人的排名 
		a[j].rank=a[j-1].rank;
	}
	else{
		//否则正常排名 
		a[j].rank=j;
	}
}
	//爆搜 
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=n;j++){
    		//找到就输出 
    		if(a[j].dex==i){
    			cout<<a[j].rank<<endl;
			}
		}
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/157190943)

------------
###  THE END

---

## 作者：fried_chicken (赞：1)

# 题意

给你几个规则，让你排序，然后进行输出。

# 分析

我们可以用结构体或者类 $score$ 来存。接下来重载运算符即可。

第一个规则，比较总分。

```cpp
(x.a+x.b+x.c)<(this->a+this->b+this->c))
```

第二个规则：总分相同比前两科。
```cpp
((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)<(this->a+this->b))
```


第三个规则：前两个规则都相同比前两科最大值。
```cpp
(x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)==(this->a+this->b)&&max(x.a,x.b)<max(this->a,this->b)
```


连起来就是这样（我个人写重载运算符的码风不好，见谅）
```cpp
bool operator < (const score x)const{
	return ((x.a+x.b+x.c)<(this->a+this->b+this->c))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)<(this->a+this->b))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)==(this->a+this->b)&&max(x.a,x.b)<max(this->a,this->b));
}
```

从这里开始，先排一遍序，为规则四做准备。

第四个规则：前三个规则都一样的时候那排名相同。

前三个规则都比较好做，那么第四个规则怎么办呢？

我们可以用二分。假如存下来的结构体数组名称为 $a$ ,那我们就需要找 $a$ 中大于等于 $a[i]$ 的数。如果找到大于等于 $a[i]$ 的数，就说明符合规则四，输出就行了（主要是奔着这个等于去找的，因为大于在排序里已经排过了）。

但是我们不能在 $a$ 中找符合条件的 $a[i]$ 。那我们可以再搞个 $b$ ，把 $b$ 赋值为 $a$ ，在 $a$ 中找 $b[i]$ 。

接下来找到后输出就行了。

# 代码：
```cpp
//step1：存结构体+重载
#include<bits/stdc++.h>
using namespace std;
const int N=114514;
struct score{
	int a,b,c;
	bool operator < (const score x)const{
		return ((x.a+x.b+x.c)<(this->a+this->b+this->c))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)<(this->a+this->b))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)==(this->a+this->b)&&max(x.a,x.b)<max(this->a,this->b));
	}
}a[N],b[N];
//如果你用的是类，那么这样写：
/*
class score{
	public:
		int a,b,c;
		bool operator < (const score x)const{
			return ((x.a+x.b+x.c)<(this->a+this->b+this->c))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)<(this->a+this->b))||((x.a+x.b+x.c)==(this->a+this->b+this->c)&&(x.a+x.b)==(this->a+this->b)&&max(x.a,x.b)<max(this->a,this->b));
		}
}a[N],b[N];
*/
//step2:读入
signed main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].a>>a[i].b>>a[i].c;
		b[i]=a[i];//把b赋值给a
	}
	//step3:排序
	sort(a+1,a+n+1);
//	step4:二分+输出
	for(int i=1;i<=n;i++){
		cout<<lower_bound(a+1,a+n+1,b[i])-a<<endl;//b中找a
	}
	return 0;
}
```

---

## 作者：hard_learn (赞：1)

# 简要题意
题目要求按照规定的排序规则对同学的成绩进行排名，并输出每位同学的排名。
# 思路
- 读取输入，存储每位同学的成绩。
- 计算每位同学的总分、语文数学总分、语文数学最高分。
- 根据排序规则，对同学进行排序。
- 赋予按顺序的排名
- 输出每位同学的排名。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
struct st{
	int c,m,e,z; 
	int id;
	int maxx,zx;
}a[10005];
int f[10005];
bool cmp(st a,st b){
	if(a.z!=b.z){
		return a.z>b.z;
	}
	else if(a.zx!=b.zx){
		return a.zx>b.zx;
	}
	else{
		return a.maxx>b.maxx;
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		a[i].id=i;
		cin>>a[i].c>>a[i].m>>a[i].e;
		a[i].z=a[i].c+a[i].m+a[i].e; 
		a[i].maxx=max(a[i].c,a[i].m);
		a[i].zx=a[i].c+a[i].m;
	}
	sort(a+1,a+n+1,cmp);
	int cnt=1,ans=cnt;
	f[a[1].id]=1;
	for(int i=2;i<=n;i++){
		cnt++;
		if(a[i].maxx==a[i-1].maxx&&a[i].z==a[i-1].z&&a[i].zx==a[i-1].zx){
			f[a[i].id]=ans;
		}
		else{
			f[a[i].id]=cnt;
			ans=cnt;
		}
	}
	for(int i=1;i<=n;i++){
		cout<<f[i]<<endl;
	}
	return 0;
} 
```

---

## 作者：iyka (赞：1)

本篇题解主要是介绍一下本题思路和 `sort` 函数的用法。

## 本题思路：
题面描述非常清晰，我们只需按照题目给出的关键字从大到小排序，最后单独维护一下输出顺序和同编号的情况就行了。

## 排序：
那怎么进行特定关键字排序呢？这里我们用到 `sort` 来排序。
### 对于数组:
对于数组的排序是 `sort` 函数的基本用法，它一般形如：
```cpp
sort(first,end,compare)
``````
其中 `first` 是数组的开始指针位置，`end` 是结束指针位置，`compare` 是排序须遵循的关键词，比如我们想把数组 $a$ (下标从 $1$ 开始，到 $n$ 结束）从小到大排序，就可以用以下代码：
```cpp
sort(a+1,a+n+1);
``````
有细心的同学可能发现了，上面的代码是没有 `compare` 部分的，因为 `sort` 默认从小到大排序，如要进行从大到小排序就要加上关键字 `greater<type>()` 中间的 `type`就是要排序的数组的类型，完整的从大到小排序代码如下（此处默认 $a$ 数组是 `int` 类型）：
```cpp
sort(a+1,a+n+1,greater<int>());
``````

### 对于结构体
对于结构体排序大致上和对于数组是一样的，就是要注意 `compare` 部分，我们通常要自己写一个关键字函数，就是我们常说的 `compare` 函数。  
`compare` 函数是一个布尔类型的函数，返回的是关键字的判断结果，如果把关键字 `greater<type>()` 用 `compare` 函数实现就是以下样子：
```cpp
bool compare(int a,int b)
{
	return a>b;
}

sort(a+1,a+n,compare);
`````
不难看出 `compare` 函数中传递的参数的类型就是排序目标的类型。  
那如果我要对一个拥有两个参数 $l$ 和 $r$ 的结构体 $b$ 进行以下关键字从小到大排序：
- 若 $l$ 相同则比较 $r$，反之就比较 $l$。

那 `compare` 函数就长以下的样子：
```cpp
bool compare(node x,node y)
{
	if(x.l==y.l)
		return x.r<y.r;
	return x.l<y.l;
}
`````
然后，本题的知识点就讲完了。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+10;
int n;
struct node
{
	int c,m,e,tot,idx,_idx;
}a[N],k;
bool compare(node x,node y) //题目关键字 
{
	if(x.tot==y.tot)
	{
		if(x.tot-x.e==y.tot-y.e)
			return max(x.c,x.m)>max(y.c,y.m);
		return x.tot-x.e>y.tot-y.e;
	}
	return x.tot>y.tot;
}
bool _compare(node x,node y) //排序维护初始编号 
{
	return x.idx<y.idx;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i].c>>a[i].m>>a[i].e, a[i].tot=a[i].c+a[i].m+a[i].e, a[i].idx=i;
	sort(a+1,a+n+1,compare);
	a[1]._idx=1, k=a[1];
	for(int i=2;i<=n;++i)
	{
		if(k.tot==a[i].tot && k.tot-k.e==a[i].tot-a[i].e && max(k.c,k.m)==max(a[i].c,a[i].m))
			a[i]._idx=k._idx;
		else
			a[i]._idx=i, k=a[i];
	}
	sort(a+1,a+n+1,_compare);
	for(int i=1;i<=n;++i)
		cout<<a[i]._idx<<"\n";
	return 0;
} 
```

---

## 作者：yekc2010 (赞：1)

## 思路。
首先说一下我认为的题型：排序+模拟+结构体。看到这种要多个数据排序的最好用结构体，这样更简单易懂。
#### 排序的题意。
1. 比较总分，高者靠前。

2. 如果总分相同，则比较语文和数学两科的总分，高者靠前。

3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前。

4. 如果仍相同，则二人并列（难点）。

排序简单过一下。快排，如果当前比较的数不互相等于就判断。
```cpp
bool cmp(node x,node y){
	if(x.sum1!=y.sum1) return x.sum1>y.sum1;
    if(x.sum2!=y.sum2) return x.sum2>y.sum2;
    if(x.sum3!=y.sum3) return x.sum3>y.sum3;
}
```
然后就是想，如何按同学的顺序输出他们各自的排名并成绩相同的做到并列呢？

我们可以用一个 $k$ 来储存现在到了多少名了；一个数组来储存顺序，再来判断成绩相。成绩与上一个人相同的话 $k$ 就不变，不同就更新 $k$ 。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;//命名空间
typedef long long ll;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
int n,x[10010];//x[]储存输出顺序
struct node{
	int num,C,M,E,sum1,sum2,sum3;
	//num序号，C语文，M数学，E英语
	//sum1语数英，sum2语数,sum3语数最高分
}a[10010];
bool cmp(node x,node y){//快排，解释过了
	if(x.sum1!=y.sum1) return x.sum1>y.sum1;
    if(x.sum2!=y.sum2) return x.sum2>y.sum2;
    if(x.sum3!=y.sum3) return x.sum3>y.sum3;
}
int main(){
    IOS;//加速
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].C>>a[i].M>>a[i].E;//输入语数英
		a[i].num=i;//序号
		a[i].sum1=a[i].C+a[i].M+a[i].E;
		//语数英
		a[i].sum2=a[i].C+a[i].M;
		//语数
		a[i].sum3=max(a[i].C,a[i].M);
		//语数最高分
	}
	sort(a+1,a+1+n,cmp);//排序
	int k=1;
	for(int i=1;i<=n;i++){
		if(a[i].sum1==a[i-1].sum1&&a[i].sum2==
		a[i-1].sum2&&a[i].sum3==a[i-1].sum3){
		//判断是否与上一个相等
			x[a[i].num]=k;
		}
		else{
			x[a[i].num]=i;
			k=i;//更新 k
		}
	}
	for(int i=1;i<=n;i++){//输出
		cout<<x[i]<<'\n';
	}
	return 0;
}
```

---

## 作者：xzz_0611 (赞：1)

[题目传送门](/problem/B3968)
# 讲解
由于一个学生包含语文、数学、英语三科的成绩，所以我们可以先定义一个结构体，在里面存储语文分数、数学分数、英语分数、总分、语文与数学的总分、语文与数学的最高分、排名和原始位置，结构体代码如下：
```cpp
struct score{
	int c,m,e/*语数英的成绩*/,total/*总分*/,cm/*语文与数学的总分*/,max_cm/*语文与数学的最高分*/,num/*初始位置*/,ranking/*排名*/;
}sco[10000];
```
随后，我们就要进行输入及初始化，这个肯定不用讲，大家都会。代码如下：
```cpp
for(int i=0;i<n;++i) {
	cin>>sco[i].c>>sco[i].m>>sco[i].e;//输入
	sco[i].total=sco[i].c+sco[i].m+sco[i].e;//总分
	sco[i].cm=sco[i].c+sco[i].m;//语文数学总分
	sco[i].max_cm=max(sco[i].c,sco[i].m);//语文数学最高分
	sco[i].num=i;//初始位置
}
```
然后，我们就用 `sort` 函数对其按照题目中给定的方式进行排序。而由于是结构体排序，要写一个规则，如下：
```cpp
bool cmp1(score a,score b) {
	if(a.total!=b.total) return a.total>b.total;//比较总分
	else if(a.cm!=b.cm) return a.cm>b.cm;//比较语文和数学的总分
	else if(a.max_cm!=b.max_cm) return a.max_cm>b.max_cm;//比较语文和数学的最高分
	return true;//都一样则并列
}
```
在排了序之后我们就可以开始记录排名了。为什么要记录排名呢？因为输出时需要按初始顺序依次输出每个学生的排名，这也就意味着又要将其按初始位置再排序一遍，如果不记录排名的话，等到输出时你还是不知道这个学生的排名。需要注意的是，总分、语文数学成绩和以及语文数学最高分全部一样的学生排名是一样的，所以每次还要判断当前学生的总分、语文数学成绩和以及语文数学最高分是否与上一个学生总分、语文数学成绩和以及语文数学最高分相同，如果相同，该学生的排名就要改成上一个学生的排名。代码如下：
```cpp
for(int i=0;i<n;++i) {
 	sco[i].ranking=i+1;//记录排名
	if(i!=0) if(sco[i].total==sco[i-1].total&&sco[i].cm==sco[i-1].cm&&sco[i].max_cm==sco[i-1].max_cm) sco[i].ranking=sco[i-1].ranking;//如果相同就更改排名
}
```
最后，由于输出要按初始顺序输出，所以还要按初始顺序再进行一遍排序。同样由于是结构体，所以要自己写规则，如下：
```cpp
bool cmp2(score a,score b) {
	return a.num<b.num;//从小到大
}
```
最后只要输出就行啦！代码如下：
```cpp
for(int i=0;i<n;++i) cout<<sco[i].ranking<<"\n";
```
# code
~~为了方便你们抄代码我就不加注释了。~~
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct score{
	int c,m,e,total,cm,max_cm,num,ranking;
}sco[10000];
bool cmp1(score a,score b) {
	if(a.total!=b.total) return a.total>b.total;
	else if(a.cm!=b.cm) return a.cm>b.cm;
	else if(a.max_cm!=b.max_cm) return a.max_cm>b.max_cm;
	return true;
}
bool cmp2(score a,score b) {
	return a.num<b.num;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	for(int i=0;i<n;++i) {
	cin>>sco[i].c>>sco[i].m>>sco[i].e;
	sco[i].total=sco[i].c+sco[i].m+sco[i].e;
	sco[i].cm=sco[i].c+sco[i].m;
	sco[i].max_cm=max(sco[i].c,sco[i].m);
	sco[i].num=i;
}
	sort(sco,sco+n,cmp1);
	for(int i=0;i<n;++i) {
		sco[i].ranking=i+1;
		if(i!=0) if(sco[i].c==sco[i-1].c&&sco[i].m==sco[i-1].m&&sco[i].e==sco[i-1].e) sco[i].ranking=sco[i-1].ranking;
	}
	sort(sco,sco+n,cmp2);
	for(int i=0;i<n;++i) cout<<sco[i].ranking<<"\n";
	return 0;
}
```

---

## 作者：DFs_YYDS (赞：1)

结构体排序 $+$ 模拟，建议评橙。
# 题目大意
给你 $n$ 个学生的成绩，让你按输入循序输出每个学生的排名。
# 具体思路
读入的时候记录总分和顺序，再按照题目中给的方法进行结构体排序，（即总分不相等，把总分高的往前排；如果总分相等，数学和语文两科总分高的往前排；如果数学和语文两科总分也相等，数学和语文两科最高分高的靠前；如果数学和语文两科最高分也一样，就算并列），然后处理排名，如果排好后的第 $i$ 个人和第 $i-1$ 个人并列，那么第 $i$ 个人的排名和第 $i-1$ 个人一样；如果不并列，那么第 $i$ 个人的排名就是  $i$。
# 完整代码
废话不多说，上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
	int a/*语文成绩*/,b/*数学成绩*/,c/*英语成绩*/,s/*总分*/,id/*读入顺序*/,ans/*最终答案，即排名*/;
}a[10005];//数组开到1e4+5。 
bool cmp(student x,student y){//一号比较函数 。 
	if(x.s!=y.s)return x.s>y.s;//总分不一样按总分排。 
	if(x.a+x.b!=y.a+y.b)return x.a+x.b>y.a+y.b;//总分一样并且语文数学两科总分不一样，按语文数学两科总分排。 
	return max(x.a,x.b)>max(y.a,y.b);//总分以及语文数学两科的总分都一样，按语文数学两科最高分排，一样也没关系，之后会处理。 
}
bool cmp2(student x,student y){//二号比较函数。 
	return x.id<y.id;//按读入顺序从小到大排。 
}
int main(){//主函数。 
	int n;//n个学生。 
	cin>>n;//读入n。 
	for(int i=1;i<=n;i++){
		cin>>a[i].a>>a[i].b>>a[i].c;//读入三科成绩。 
		a[i].s=a[i].a+a[i].b+a[i].c;//记录总分。 
		a[i].id=i;//记录读入顺序。 
	}
	sort(a+1,a+n+1,cmp);//第一次排序。 
	for(int i=1;i<=n;i++){
		if(a[i].s==a[i-1].s && a[i].a+a[i].b==a[i-1].a+a[i-1].b && max(a[i].a,a[i].b)==max(a[i-1].a,a[i-1].b))//如果所有条件相同，即和前一个人并列。 
		    a[i].ans=a[i-1].ans;//两人排名也相同。 
		else//和前一个人不并列。 
		    a[i].ans=i;//排名就是i。 
	}
	sort(a+1,a+n+1,cmp2);//第二次排序。 
	for(int i=1;i<=n;i++)cout<<a[i].ans<<endl;//输出排名并换行。 
    return 0;
}
```

---

## 作者：2023gdgz01 (赞：1)

模板的结构体排序，自定义比较大小根据题意即可。按题意从大到小排序后，遍历每个同学的成绩统计排名，可以用 $ans$ 数组记录答案，用一个 $now$ 变量记录当前排名，如果第 $i(i>1)$ 名同学与第 $i-1$ 名同学并列，则 $ans_i\gets now$，否则 $now\gets i，ans_i\gets now$。代码如下：

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

struct node { //记录成绩
	int c, m, e, sum, id;
	inline bool operator< (const node &nod) const {
		if (sum != nod.sum)
			return sum > nod.sum;
		if (c + m != nod.c + nod.m)
			return c + m > nod.c + nod.m;
		if (max(c, m) != max(nod.c, nod.m))
			return max(c, m) > max(nod.c, nod.m);
		return false;
	}
	inline bool operator== (const node &nod) const {
		return sum == nod.sum && c + m == nod.c + nod.m && max(c, m) == max(nod.c, nod.m);
	}
};

int n;
int now; //当前排名
int ans[10005]; //答案
node data[10005];

int main() {
	scanf("%d", &n);
	for (register int i = 1; i <= n; ++i) {
		scanf("%d%d%d", &data[i].c, &data[i].m, &data[i].e);
		data[i].sum = data[i].c + data[i].m + data[i].e;
		data[i].id = i;
	}
	sort(data + 1, data + n + 1);
	data[0] = {0, 0, 0, -1, 0}; //防止第一名为 0 分而导致判定为和“第零名”并列
	for (register int i = 1; i <= n; ++i) {
		if (data[i] == data[i - 1])
			ans[data[i].id] = now;
		else {
			now = i; //想想为什么不是 ++now;
			ans[data[i].id] = now;
		}
	}
	for (register int i = 1; i <= n; ++i)
		printf("%d\n", ans[i]);
	return 0;
}
```

时间复杂度为 $O(n\log_2n)$。[AC 链接](https://www.luogu.com.cn/record/156842334)

---

## 作者：queenbee (赞：1)

# B3968 成绩排序 题解
## 思路
[题目传送门](https://www.luogu.com.cn/problem/B3968)，用结构体存储每个同学语、数、英三科的成绩，再写一个 cmp 函数按照先比较总分，再比较语、数总分，再比较语、数最高分的顺序对成绩进行排序，将他们的排名按照编号储存到数组中，最后输出各自的排名即可。

其中储存排名的部分，因为可能有并列的同学，所以要先判断总分，语、数总分，语、数最高分与上一名同学是否相同，如果相同，则两人并列，排名为变量 $t$。若不同，则排名为当前遍历的人数 $i$，并将 $t$ 更新为 $i$。
```
for(int i=1;i<=n;i++){	//按编号储存排名 
	if(f[i].sum==f[i-1].sum&&f[i].a+f[i].b==f[i-1].a+f[i-1].b&&max(f[i].a,f[i].b)==max(f[i-1].a,f[i-1].b)){	//判断是否并列 
		v[f[i].num]=t;
	}
	else{
	v[f[i].num]=i;
			t=i;
	}
}
```

## 程序
```cpp
#include<bits/stdc++.h>	//我爱万能头 
using namespace std;
const int N=1e4+10;
struct Node{
	int sum,num;
	int a,b,c;
}f[N];
int n;
int t=1;
int v[N];
bool cmp(Node a,Node b){	//按规则排序 
	if(a.sum==b.sum){	//判断成绩是否相同 
		if(a.a+a.b==b.a+b.b){	//判断语、数总分是否相同 
			return max(a.a,a.b)>max(b.a,b.b);	//判断语、数最大值是否相同
		}
		return a.a+a.b>b.a+b.b;
	}
	return a.sum>b.sum;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		f[i].num=i;	//编号 
		cin>>f[i].a>>f[i].b>>f[i].c;
		f[i].sum=f[i].a+f[i].b+f[i].c;	//总分 
	}
	sort(f+1,f+n+1,cmp);	//排序 
	for(int i=1;i<=n;i++){	//按编号储存排名 
		if(f[i].sum==f[i-1].sum&&f[i].a+f[i].b==f[i-1].a+f[i-1].b&&max(f[i].a,f[i].b)==max(f[i-1].a,f[i-1].b)){	//判断是否并列 
			v[f[i].num]=t;
		}
		else{
			v[f[i].num]=i;
			t=i;
		}
	}
	for(int i=1;i<=n;i++){	//按编号输出排名 
		cout<<v[i]<<endl; 
	}
	return 0;	//完结撒花 
} 
```

---

## 作者：GXZJQ (赞：0)

# B3968 [GESP202403 五级] 成绩排序 题解

[题目链接](https://www.luogu.com.cn/problem/B3968)

## 题目大意

给定 $n$ 个学生的成绩，将这 $n$ 个学生的成绩按照题目要求排序后按输入顺序输出他们的排名。

## 题目分析

这是一道非常典型的自定义排序的题目，最关键的点就在于输出排名的时候要按照输入顺序输出，且存在日常生活中的“**并列占位**”情况。

对于这道题来说，我们需要一个结构体储存所有学生的信息：

```cpp
struct student {
	int id, c, m, e, total, highest, sum;
	/*id为输入顺序,c,m,e含义如题所述,total记录总分,
	highest记录语文和数学的最高分,sum记录语文和数学的总分*/
} a[maxn];
```
下面一个问题，如何排序呢？
库函数能够支持我们自定义排序方法，可以胜任这道题目：

```cpp
bool cmp(student a, student b) {//排序代码
	if (a.total > b.total) return 1;//比较总分
	else if (a.total < b.total) return 0;
	else {
		if (a.sum > b.sum) return 1;//比较语文数学分数和
		else if (a.sum < b.sum) return 0;
		else {
			if (a.highest > b.highest) return 1;//比较语文数学最高分
			else if (a.highest < b.highest) return 0;
			else return a.id < b.id;
		}
	}
}
```
然后就是这道题最关键的部分：如何正确地输出呢？我们不妨用一个 $ans$ 数组记录输出的内容。因为这时所有学生的成绩已经是从高往低排序好的，所以我们可以定义一个变量 $last$ 记录上一个学生的信息，如果这个学生部分信息和上一个学生部分信息相同，说明他们是并列的：

```cpp
bool check(int num1, int num2) {//判断是否并列
	if (a[num1].total == a[num2].total &&
	    a[num1].sum == a[num2].sum &&
	    a[num1].highest == a[num2].highest) return 1;
	else return 0;
}
```
这时候我们就要考虑处理并列的问题了。我们可以定义一个 $k$，代表要**额外**空出几个位置。每出现一个并列的学生，就将 $k$ 累加 $1$。需要注意的是，每次用完 $k$ 之后，都要把 $k$ 清零，否则会出错。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e4 + 10;
struct student {
	int id, c, m, e, total, highest, sum;
	/*id为输入顺序,c,m,e含义如题所述,total记录总分,
	highest记录语文和数学的最高分,sum记录语文和数学的总分*/
} a[maxn];
int n, p = 1;
//p记录用到了第几个位置
int k;
int ans[maxn], last;
bool cmp(student a, student b) {//排序代码
	if (a.total > b.total) return 1;//比较总分
	else if (a.total < b.total) return 0;
	else {
		if (a.sum > b.sum) return 1;//比较语文数学分数和
		else if (a.sum < b.sum) return 0;
		else {
			if (a.highest > b.highest) return 1;//比较语文数学最高分
			else if (a.highest < b.highest) return 0;
			else return a.id < b.id;
		}
	}
}
bool check(int num1, int num2) {//判断是否并列
	if (a[num1].total == a[num2].total &&
	    a[num1].sum == a[num2].sum &&
	    a[num1].highest == a[num2].highest) return 1;
	else return 0;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].c >> a[i].m >> a[i].e;
		a[i].id = i;
		a[i].total = a[i].c + a[i].m + a[i].e;
		a[i].highest = max(a[i].c, a[i].m);
		a[i].sum = a[i].c + a[i].m;
	}
	sort(a + 1, a + n + 1, cmp);
	ans[a[1].id] = 1;
	last = 1;
	for (int i = 2; i <= n; i++) {
		if (check(last, i)) {//有并列的学生
			ans[a[i].id] = p;//记录排名
			k++;//是并列的学生,累加k
			last = i;
			continue;
		}
		p += k + 1;//并列结束,新的占位
		k = 0;//记得清空
		ans[a[i].id] = p;//记录排名
		last = i;//更新缓存信息
	}
	for (int i = 1; i <= n; i++ ) {
		cout << ans[i] << endl;
	}
	return 0;
}
```

---

## 作者：yu1128_AKIOI (赞：0)

# 思路

排序的板子题，cmp 函数按题意模拟即可，具体如下：

```cpp
bool cmp(node x,node y){
  //s为三科分数的总和，s1为语文和数学两科的总分，mx为语文和数学两科的最高分。
    if(x.s==y.s){
        if(x.s1==y.s1) return x.mx>y.mx;
        else return x.s1>y.s1;
    }
    else return x.s>y.s;
}
```
关键是输出部分。

我们可以拟定一个排名数组 b，当多人排名相同时，那么这个人的排名 -1，类似的，如果这时还有人排名相同时，那么这个人的排名再 -1，对于判断函数方面，与 cmp 函数类似，具体如下：

```cpp
bool f(node x,node y){
    if(x.s==y.s){
        if(x.s1==y.s1){
            if(x.mx==y.mx) return 1;
            return 0;
        }
        return 0;
    }
    return 0;
}
```
# 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int a,b,c,s,s1,mx,id;
}t[100010];
int n,tot,b[10010];
bool cmp(node x,node y){
    if(x.s==y.s){
        if(x.s1==y.s1) return x.mx>y.mx;
        else return x.s1>y.s1;
    }
    else return x.s>y.s;
}
bool f(node x,node y){
    if(x.s==y.s){
        if(x.s1==y.s1){
            if(x.mx==y.mx) return 1;
            return 0;
        }
        return 0;
    }
    return 0;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>t[i].a>>t[i].b>>t[i].c;
        t[i].s=t[i].a+t[i].b+t[i].c;
        t[i].s1=t[i].a+t[i].b;
        t[i].mx=max(t[i].a,t[i].b);
        t[i].id=i;
    }
    sort(t+1,t+n+1,cmp);
    for(int i=1;i<=n;i++){
        int x=i;
        while(f(t[x],t[x-1])) x--;
        b[++tot]=x;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(t[j].id==i){
                cout<<b[j]<<endl;
                break;
            }
        }
    }
}
```

---


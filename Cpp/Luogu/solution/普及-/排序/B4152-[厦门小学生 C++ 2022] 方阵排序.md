# [厦门小学生 C++ 2022] 方阵排序

## 题目背景

本试题为 2022 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

班主任高老师是一位特别关注班级学习氛围建设的老师，每次考完试，高老师都想知道目前班级的每个座位上同学的名次情况，以便于重调座位，把不同水平的同学的座位分布均匀。已知高老师班级的座位分布是一个 $N\times N$ 的方阵，即 $N$ 排 $N$ 列，每个学生的成绩为 $0\sim 100$ 之间的正整数，现在高老师请会编程的你帮忙打印出名次方阵，即输出新的 $N\times N$ 方阵，每个位置把成绩替换成对应的名次，特别注意同分都取相同名次，请参考以下输入输出样例。

## 说明/提示

### 样例解释

$3$ 行 $3$ 列，共 $9$ 个学生，其中两个 $90$ 分，名次均为 $3$，所以没有名次 $4$，直接到名次 $5$。

### 数据范围

- 对于 $60\%$ 的数据，$N\leq 10$。
- 对于 $100\%$ 的数据，$N\leq 100$。


## 样例 #1

### 输入

```
3
5 50 65
70 80 90
90 95 100```

### 输出

```
9 8 7
6 5 3
3 2 1```

# 题解

## 作者：liwanxian (赞：3)

## 简要题意

输入 $N\times N$ 成绩方阵，将成绩替换为其**对应名次**，输出对应名次方阵。

---


## 思路

1.  创建一个结构体`stu`来储存该学生的成绩、所在行、所在列，方便**排序之后**来存储该学生的排名。
2.  将读入的学生按成绩由大到小**降序**排序，以便输出排名。
3.  在排序后，**从前往后**遍历`sl`动态数组，并将其排名`rk`存入`ans`数组中。特别的，如果有多个同学的成绩相同，其排名也应该相同。
4.  最后输出答案即可。

更多细节注释请看代码捏。

---


## 实现代码

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int ans[105][105];
struct stu{
	int r,c,scr;//行、列 、成绩 
};
bool cmp(stu a,stu b){
	return a.scr>b.scr;//对成绩进行降序排序
}
int main(){
	int n;
	cin>>n;
	vector<stu>sl;
	for(int i=0;i<n;i++){//读取成绩方阵 
		for(int j=0;j<n;j++){
			stu tmp;
			cin>>tmp.scr;
			tmp.r=i,tmp.c=j;
			sl.push_back(tmp);//将记录的行、列、成绩存入sl 
		}
	}
	sort(sl.begin(),sl.end(),cmp);
	int rk=1;//排名，记得是从1开始 
	for(int i=0;i<sl.size();i++)
	{
		if(i>0&&sl[i].scr<sl[i-1].scr)//如果当前成绩和前一个成绩不同，更新名次 
			rk=i+1;
		ans[sl[i].r][sl[i].c]=rk;//将名次存储到对应的位置
	} 
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++)
			cout<<ans[i][j]<<" ";
		cout<<endl;
	}
    return 0;//撒花 
}
	
```
附上[AC记录](https://www.luogu.com.cn/record/203540194)。

感谢观看。

---

## 作者：yedalong (赞：1)

哇，厦门市比赛的题居然跑到洛谷了，太感人了。。。

## Solution

很简单的一道题。考虑用两个数组存，其中一个数组排序，另一个数组不排序。对于不排序的数组，我们遍历其中的每一个数，然后对于每个数到排序后的数组内找到排名，输出即可。\
时间复杂度 $O(n^4)$，可以通过此题。

## AC code

最后附上小学写的代码，由于时代久远，不喜勿喷。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
    int a;cin>>a;int lll=a*a;int arr[lll];int arr1[lll];
    for(int i = 0;i<lll;i++){
        cin>>arr[i];
        arr1[i]=arr[i];
    }
    sort(arr1,arr1+lll,greater<int>());
    for(int i = 0;i<lll;i++){
        for(int j = 0;j<lll;j++){
            if(arr[i]==arr1[j]){
                cout<<j+1<<' ';
                break;
            }
        }
        if((i+1)%a==0) cout<<endl;
    }
}
```

---

## 作者：qianyuzhe (赞：1)

## 分析

考虑将原数组复制后按照成绩降序排序，即可预处理出所有同学的排名。此时，对于每个同学，只需找出第一个小于等于其成绩的数的排名即可。直接求第一个小于等于某数的数的排名不方便，我们可以对其相反数升序排序后用 `lower_bound` 二分查找出第一个大于等于某数的数的排名。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,i,j,a[10005],b[10005];
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n;
	for(i=0;i<n*n;i++){
		cin>>a[i];
		b[i]=-a[i];//取相反数 
	}
	sort(b,b+n*n);
	for(i=0;i<n;i++){
		for(j=0;j<n;j++)cout<<lower_bound(b,b+n*n,-a[i*n+j])-b+1<<' ';//二分查找 
		cout<<'\n';
	}
}
```

---

## 作者：liuli688 (赞：1)

### 思路
由于要求输出名次，所以考虑排序。先将输入数组按递减排序，那么此时位于第一名的数排名就是 $1$。为了能按输入顺序输出，需要用到 `std::pair`，第一维为成绩，第二维为坐标（是第几个被输入的）。计算完名次后按坐标将答案存储到另一个数组内输出即可。

由于名次可能并列，因此在排完序后扫描时判断如果一个人的成绩和上一个人成绩一样，则排名等于上一个人的排名，否则是自己的下标。

注意输出仍然是方阵，要适时输出换行符。
### 代码
```cpp
#include <cstdio>
#include <utility>
#include <algorithm>
#include <functional>
using pii = std::pair<int, int>;

constexpr int N = 101;
pii a[N * N];
int n, nn, ans[N * N];

signed main()
{
    scanf("%d", &n); nn = n * n;
    for (int i = 1; i <= nn; ++i)
    {
        scanf("%d", &a[i].first);
        a[i].second = i;
    }
    std::sort(a + 1, a + nn + 1, std::greater<pii>());
    for (int i = 1; i <= nn; ++i)
        if (a[i].first != a[i - 1].first)
            ans[a[i].second] = i;
        else
            ans[a[i].second] = ans[a[i - 1].second];
    for (int i = 1; i <= nn; ++i)
    {
        printf("%d ", ans[i]);
        if (i % n == 0)
            putchar('\n');
    }
    return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4152)

## 题目大意：

有 $n^2$ 个学生坐在 $n \times n$ 的位置上，给出各个位置学生的成绩，输出这个位置上学生的排名，排名可以并列。

## 思路：

注意到 $n \le 100$ 非常小，考虑暴力模拟排序的过程，即先处理每个出现分数的名次，再根据学生分数输出相应的名次即可。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int m[100005];
int da[105][105];
int cx[105][105];
int n; 
bool cmp(int q,int p){
	return q>p;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>m[(i-1)*n+j];//输入，预处理所有出现分数的名次 
			cx[i][j]=m[(i-1)*n+j];
		}
	} 
	sort(m+1,m+n*n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n*n;k++){
				if(m[k]==cx[i][j]){
					da[i][j]=k;//查找学生分数对应的名次 
					break;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<da[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}

```

由于代码中 $k$ 是从小到大枚举的，所以一定输出这个分数可得的最好排名，就不用再特意处理并列情况了。

虽然是 $3$ 层循环共 $n^4$ 但有 ```break;``` 的优化，所以实际上远没有 $10^8$，可以通过此题。

---


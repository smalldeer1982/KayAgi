# [厦门小学生 C++ 2024] 战线巡逻

## 题目背景

本试题为 2024 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

在一条战线中，有 $n$ 个需要巡逻的点，为了完成巡逻任务，指挥部计划指派 $k$ 个哨兵，每个哨兵可以自由选择起始位置 $i$，不消耗体力。但哨兵每移动一个单位距离（从 $i$ 到 $i+1$ 或 $i-1$），则消耗 $1$ 点体力。

指挥部的目标是将 $k$ 个哨兵合理部署到战线上，使得：
- 所有需要巡逻的点都由至少一名哨兵巡逻过。
- 哨兵总体力消耗的最小。

请你设计一个合理的方案，计算最小的体力消耗，并输出结果。

## 说明/提示

### 样例解释 1

- 哨兵 1 初始点位即为 $-10$，接下来无需移动，消耗为 $0$。
- 哨兵 2 初始点位为 $-1$，接下来需向右移动 $2$ 个位置到点位 $1$，消耗为 $2$。
- 哨兵 3 初始点位即为 $14$，接下来无需移动，消耗为 $0$。

综上，总消耗为 $0+2+0 = 2$。

### 样例解释 2

- 哨兵 1 初始点位即为 $-100$，接下来无需移动，消耗为 0。
- 哨兵 2 初始点位为 $-11$，接下来无需移动，消耗为 0。
- 哨兵 3 初始点位即为 $-3$，接下来需向右移动 $3$ 个位置至点位 $0$，消耗为 $3$；接下来需向右移动 $1$ 个位置至点位 $2$，消耗为 $1$；接下来需向右移动 $1$ 个位置至点位 $2$，消耗为 $1$；接下来需向右移动 $7$ 个位置至点位 $9$，消耗为 $7$；共计消耗 $3+1+1+7 = 12$。
- 哨兵 4 初始点位即为 $17$，接下来需向右移动 $3$ 个位置，消耗为 $3$。

综上，总消耗为 $0+0+12+3 = 15$。

### 样例解释 3

根据题意，哨兵巡逻可以做到不消耗体力。

### 数据范围

对于所有测试数据有：$-10^5 \leq a_i \leq 10^5$，$1 \leq k \leq 10^5$，$1 \leq n \leq 10^5$。

| 测试点 | 特殊性质 A | $k$ | $n$ |
|:--------:|:------------:|:---:|:---:|
| $1, 2$   | 否         | $k=1$ | $\leq 10^5$ |
| $3, 4$   | 是         | $\leq 10^5$ | $\leq 10^5$ |
| $5, 6, 7$| 否         | $\leq 10^3$ | $\leq 10^2$ |
| $8, 9, 10$ | 否         | $\leq 10^5$ | $\leq 10^5$ |

特殊性质 A：保证 $k \geq n$ 恒成立。

## 样例 #1

### 输入

```
3 4
-10 -1 1 14```

### 输出

```
2```

## 样例 #2

### 输入

```
4 9
-11 -3 0 9 -100 2 17 20 1```

### 输出

```
15```

## 样例 #3

### 输入

```
5 3
-1000 100 200```

### 输出

```
0```

# 题解

## 作者：AW_BCH (赞：11)

## 题解：B4179 [厦门小学生 C++ 2024] 战线巡逻

[题目传送门](https://www.luogu.com.cn/problem/B4179)

[更好的阅读体验](https://www.luogu.com.cn/article/exuux9od)

### 题目分析

一道很明显的贪心题。分析一下题意，很容易想到，对于每个需要被巡逻的点，都有两种被士兵巡逻到的情况：

1. 一开始就被士兵直接部署。这种情况下，所需要的体力总和**不变**。

2. 一开始没有被士兵部署，由**离目前最近的被部署的点**上的士兵巡逻。这种情况下，所需要的体力总和要**加上这两点之间的距离**。

分析到这里，就有了一个问题：**我们怎么找到离目前的这个点最近的点呢？**

答案很明显，可以把所有的点排序，然后依次求出两点之间距离。

~~实在想不到的看一下题目标签就想到了。~~

### 代码实现

- 我们用 ```num``` 变量来表示会有几个点没有被士兵直接部署。

- 我们用 ```cha``` 数组来表示**排序后**相邻两个点的距离。

- 我们用 ```ans``` 变量来表示答案。

还有一些细节在注释里。

**代码：**

```cpp
//洛谷 B4179 [厦门小学生 C++ 2024] 战线巡逻
#include<bits/stdc++.h>
using namespace std;
//#define int long long//
#define endl '\n'
#define emdl '\n'
typedef long long ll;
const int MAXN=1e5+5;
int k,n;
int num,ans;
int a[MAXN];
int cha[MAXN];//a[i] 和 a[i-1] 的差 
//注意：cha[1] 始终为 0
//所以排序时要直接从 cha[2] 开始排 
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>k>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	num=n-k;
	//如果 num<=0 那么直接将士兵部署到点上
	if(num<=0){
		//此时答案为 0 
		cout<<0<<endl;
		return 0;
	}
	sort(a+1,a+1+n);
	for(int i=2;i<=n;i++){
		cha[i]=a[i]-a[i-1]; 
	}
	//直接从 cha[2] 开始排 
	sort(cha+2,cha+n+1);
	for(int i=2;i<=num+1;i++){
		ans+=cha[i];
	}
	cout<<ans<<emdl;
	return 0;
}
```

---

## 作者：Temp113 (赞：4)

## Solution

$1 \le n \le 10^5$，考虑贪心。

考虑指派 $1$ 个哨兵的情况。

此时选两端点最优，最优为 $r - l$。

证明：设两端点分别为 $l,r$，选的点为 $p$，此时最小体力消耗为 $\min(p - l, r - p) + r - l$（先移动到左端点或右端点）。当 $p - l = 0$ 或 $r - p = 0$ 时（$p = l$ 或 $p = r$），取最小值 $r - l$。

进一步，考虑指派 $2$ 个哨兵的情况。

此时 $2$ 个哨兵分成 $2$ 个区域巡逻，比 $1$ 个哨兵（最优）的情况少消耗：两区域中间段消耗的体力。

证明：设中间段的两端点分别为 $v,w$，由 $1$ 个哨兵的情况知，两区域的最小体力消耗分别为：$v - l$ 与 $r - w$，$v - l + r - w = r - l + v - w$，少消耗 $w - v$。

再进一步，考虑指派 $k$ 个哨兵的情况。

此时，类比 $2$ 个哨兵的情况，每多一个哨兵，就少消耗：分开的两区域中间段消耗的体力。

求指派 $k$ 个哨兵所消耗的最小体力，就可转换为：最小体力一开始为 $r - l$，执行 $k - 1$ 次，每次选择相邻两点距离的最大值（未选择）。

所以可将相邻两点距离从大到小排序，并正序选择。

时间复杂度：$O(n \log n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int k, n, a[N], b[N], ans;
int main(){
	ios::sync_with_stdio(false);
	cin.tie();
	cin >> k >> n;
	k--;
	for(int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	ans = a[n] - a[1];
	for(int i = 1; i < n; i++) b[i] = a[i + 1] - a[i];
	sort(b + 1, b + (n - 1) + 1, greater<int>());
	for(int i = 1; i <= k; i++) ans -= b[i];
	cout << ans;
	return 0;
}
```

---

## 作者：canwen (赞：4)

想明白一件事这道题就简单了，~~笔者一开始想错了~~。

每个哨兵只会沿着一个方向走，假设有 $3$ 个位置 $a,b,c$ 满足 $a< b < c$ 需要被哨兵经过，哨兵放在位置 $b$，按照从 $b$ 到 $c$，再从 $c$ 到 $a$ 的方式走一定劣于把哨兵直接放在位置 $c$，然后从 $c$ 直接走到 $a$ 的方法，当然放在位置 $a$ 的方式也可以。

那么只需要先排序，求出 $n-1$ 个相邻位置之间的距离，从中选择最小的 $n-k$ 个元素求和即可。

瓶颈在于排序。

---

## 作者：lty2023 (赞：3)

## 思路
### 贪心
为了让体力消耗最小，就是让哨兵走的路程少。   

如果 $k<n$，肯定要有哨兵从起始位置走到相邻的位置，而要走的段数自然就是 $n-k$。选的要走那些段，肯定是路程最小的 $n-k$ 个。
### 实现
题目没说给的数组 $a$ 是有序的，所以要先对 $a$ 进行排序，接着把 $a$ 数组的相邻两项相减，得到路程数组 $b$。   
将 $b$ 排序后取前 $n-k$ 项相加，得到最终答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010];
int b[100010];
int main(){
	int k,n;
	cin>>k>>n;
	if(k>n){
		cout<<0;
		return 0;
	}
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);
	for(int i=0;i+1<n;i++){
		b[i]=a[i+1]-a[i];
	}
	sort(b,b+n-1);
	int sum=0;
	for(int i=0;i<n-k;i++){
		sum+=b[i];
	}
	cout<<sum;
}
```

---

## 作者：LINYUHENG2 (赞：2)

### 思路
若 $k \ge n$，输出 $0$ 即可。

为了使移动体力消耗最小，应当选择距离没有士兵的点最近的一个有士兵的点，让这个点的士兵移动到没有士兵的点上。

那么答案其实就是将距离从小到大排序后，前 $n-k$ 个距离之和。
### 代码

```cpp
#include <bits/stdc++.h>
#define MAXN 100005
using namespace std;
int a[MAXN],b[MAXN];

int main(){
    int k,n;
    scanf("%d%d",&k,&n);
    if(k>=n){
        printf("0");
        return 0;
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    for(int i=1;i<n;i++){
        b[i]=a[i+1]-a[i];
    }
    sort(b+1,b+n);
    int sum=0;
    for(int i=1;i<=n-k;i++){
        sum+=b[i];
    }
    printf("%d",sum);
    return 0;
}
```

---

## 作者：xiao_young (赞：2)

这道题目的标签是贪心，所以我也用贪心的思路讲解。

这道题目消耗的体力就是各个需要巡逻的点之间的距离，而每多一个哨兵就可以减少其中一段需要消耗的体力，列举三个样例就会发现，一共可以减少 $(k-1)$ 个距离。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxN=1e5+100;
int a[maxN],s[maxN];
int main(){
	int k,n,ans=0;
	cin>>k>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	} 
	sort(a+1,a+n+1);//记得排序 。 
	for(int i=1;i<n;i++){
		s[i]=a[i+1]-a[i];//计算每个距离 。 
	}
	sort(s+1,s+n,greater<int>());//给每个距离做降序排序 。 
	for(int i=k;i<n;i++){
		ans+=s[i];//减少 (k-1) 个最大的距离，从 k 开始遍历相加。 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Aventurine_ (赞：2)

## 题目算法
贪心思想，可以使用差分数组及排序。
## 具体思路
首先如果 $k \ge n$ 那么就不需要任何哨兵移动，输出 $0$ 即可。

对 $a$ 数组进行排序，用查分数组 $c$ 维护相邻点的距离，再将 $c$ 数组排序，初始有 $k$ 个人在站点上， $n-k$ 即为没有人的站点数，移动时肯定要走到相邻距离最近的站点，所以 $c$ 数组前 $n-k$ 个值的和即为答案。

## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,n;
int a[100009];
int c[100009];
signed main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>k>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序
	if(k>=n)
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<n;i++)
	{
		c[i]=a[i+1]-a[i];
	}
	sort(c+1,c+n);
	int s=n-k;
	int ans=0;
	for(int i=1;i<=s;i++)ans+=c[i];
	cout<<ans;
	return 0;
}

---

## 作者：zsjaaaxy (赞：2)

# 题意
数轴上 $n$ 个点,在数轴上标记 $k$ 个点,让标记移动次数最小使得对于每个点都曾有标记。

# 思路
可以有 $k$ 次标记的机会，那我们肯定要标在点上，并让每个标记“管”几个点，单纯的向右或向左移动并不走回头路，这样是最划算的。那有些“世外桃源”的点我们就可以使用标记直接标记它。

具体实现看代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100001],b[100001],ans=0;
int main()
{
    cin>>k>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    //排序方便后序处理。
    b[1]=INT_MAX;
    for(int i=2;i<=n;i++)
    {
        b[i]=a[i]-a[i-1];
        //计算点之间的距离。
    }
    sort(b+1,b+1+n);
    //按距离排序，走点之间距离较短的。
    for(int i=1;i<=n-k;i++)
    {
        ans+=b[i];
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：AnOIer (赞：2)

### 思路

先考虑一下特殊性质 A，易得当 $k\geq n$ 时，输出 $0$ 即可。

其他数据考虑贪心，可以发现当 $k<n$ 时一定有巡逻点没有士兵，那么有的士兵就必须要移动到没有士兵的点。为了使移动体力消耗最小，应当选择距离没有士兵的点最近的一个有士兵的点，让这个点的士兵移动到没有士兵的点上。

答案其实就是将距离从小到大排序后，前 $n-k$ 个距离之和。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100100];
int dis[100100];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int k,n;
	cin>>k>>n;
	if(k>=n) {
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<n;i++) dis[i]=a[i+1]-a[i];//计算距离
	sort(dis+1,dis+n);//给距离排序
	int ans=0;
	for(int i=1;i<=n-k;i++) {
		ans+=dis[i];//计算前n-k个距离之和
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：yedalong (赞：1)

## Solution
首先我们能想到一个性质：最优方案中每个哨兵的出生点一定是在某个巡逻点上，正确性是显然的。  

注意：由于题目没有保证 $a$ 数组有序，因此需要自己排序。  

我们发现，原本 $n$ 个巡逻点一共有 $n-1$ 个间隔，当我们插上 $k$ 个士兵后，需要哨兵跑的间隔只剩 $n-k$ 个了。考虑贪心，使得那 $n-k$ 个间隔的总路程尽可能小。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k,n,a[100005],ans,tmp[100005];
int main(){
	cin>>k>>n;
	for(int i = 1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i = 1;i<n;i++) tmp[i]=a[i+1]-a[i];
	sort(tmp+1,tmp+n,greater<int>());
	for(int i = k;i<n;i++) ans+=tmp[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：Dollartree (赞：1)

### 解题思路

为了让哨兵总体力消耗的最小，我们应该让哨兵尽量不动，让一些哨兵站在需要巡逻的点，让其他哨兵先站在需要巡逻的点，再消耗体力去巡逻。同时我们要让总路程最短，于是我们可以求出所有相邻需要巡逻的点的差值，让差值最少的 $n - k$ 段路程加入体力消耗。

### 注意事项

1. 需要巡逻的点有可能不按顺序，需要排序。

2. 相邻需要巡逻的点的差值只有 $n - 1$ 个。

3. 必须消耗体力从一个需要巡逻的点走到另一个需要巡逻的点的路程段数只有 $\max ( 0 , n - k)$ 个。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],b[100010];
int main()
{
	int k,n;
	cin>>k>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//让需要巡逻的点按顺序 
	for(int i=1;i<n;++i)//计算差值 
	{
		b[i]=a[i+1]-a[i];
	}
	sort(b+1,b+n);
	int sum=0;
	for(int i=1;i<=n-k;++i)
	{
		sum+=b[i];
	}
	cout<<sum;
 } 
```

---

## 作者：DashZhanghanxu (赞：1)

# 解析
简单题。

可以用贪心。

我们可以将巡逻线看作一个一维的线，而巡逻点看作点，将问题简化为求士兵起始点与目标点两个点之间的距离。

因为要士兵移动距离最小，因此每个士兵都应该在巡逻点开始移动，所以答案就是 $n-k$ 个两点间距离之和的最小值。

我们可以先输入数据，并且进行升序排序，然后求出每个点之间的距离。再将距离进行升序排序，优先取小的距离，（注意：距离数组中的第一个点前面没有点，距离为零，不能取。）最后输出这 $n-k$ 个距离之和。
# CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int cf[1000001];
int n,k,a[100001];
int main(){
	cin>>k>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		cf[i]=a[i]-a[i-1];
	} 
	cf[1]=0;
	sort(cf+1,cf+1+n);
	long long ans=0;
	for(int i=2;i<=n-k+1;i++)ans+=cf[i];
	cout<<ans;
	return 0;
} 
```

---

## 作者：FZY_CZY (赞：1)

老师模拟赛上看到的，差点没看出来写法。
# 思路
思路很简单，我们分三步。

 1. 士兵经过的每一段距离都应该是不与其它点（或边）重合的，所以我们完全可以将所有点的坐标进行排序，这样才能保证我们的答案具有第一步的正确性。
 2. 然后我们需要的最小值，那么我们就需要考虑怎么取有最小值，很明显就是算出相邻点的距离（做一遍差分），然后排序、求和即可。

这道题就解决了，我们讲问题划分为两个部分，首先是使其有规律，点的坐标单调递增，然后是算距离，求和。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
typedef long long LL;
int k,n;
int a[N];
int f[N];
LL ans;
int main(){
	cin>>k>>n;
	if (k>=n)
	{
		cout<<0;
		return 0;
	}
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for (int i=1;i<n;i++) f[i]=a[i+1]-a[i];
	sort(f+1,f+n);
	for (int i=1;i<=n-k;i++) ans+=f[i];
	cout<<ans;
	return 0;
}
``````

---

## 作者：qianyuzhe (赞：0)

## 题意简述

有 $k$ 个哨兵和 $n$ 个必须巡逻的坐标 $a_i$，将一个哨兵移动一个单位长度需要花费 $1$ 点体力，初始时可以任意部署哨兵的位置，要使所有必须巡逻的点都由至少一名哨兵巡逻过，求哨兵总体力消耗的最小值。

## 题目分析

显然当 $k\ge n$ 时，只需将 $n$ 个哨兵部署到 $n$ 个位置上即可，故答案为 $0$。

当 $k<n$ 时，先将 $a_i$ 升序排序，则初始时必须将 $k$ 个哨兵部署到其中 $k$ 个位置上，否则，设有哨兵设置在位置 $b$，且 $b$ 与任意 $a_i$ 不相等，若 $b$ 先向左移动至 $a_x$，显然不如直接将 $b$ 部署到 $a_x$，向右移动的情况同理。

将 $k$ 个哨兵部署到其中 $k$ 个位置上后，每当一个哨兵从 $a_x$ 位置移动到 $a_y$ 位置，其消耗的体力为 $|a_x-a_y|$，为使总体力消耗最小，就要使移动的总距离最小，故我们可以将所有相邻坐标的距离升序排序，取前 $n-k$ 个相加即可。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,c,i,a[100005];
priority_queue<int,vector<int>,greater<int> >q;//小顶堆 
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>k>>n;
	for(i=0;i<n;i++)cin>>a[i];
	sort(a,a+n);//按坐标排序 
	for(i=1;i<n;i++)q.push(a[i]-a[i-1]);//按相邻坐标的距离排序 
	for(n-=k;n>0;n--){//取距离的前(n-k)项相加
		c+=q.top();
		q.pop();
	}
	cout<<c;
}
```

---


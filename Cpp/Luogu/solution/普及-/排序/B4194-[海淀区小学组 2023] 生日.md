# [海淀区小学组 2023] 生日

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

本题数据范围较官方赛事有所修改，保证 $n\leq 5\times 10^{\color{red}6}$，避免不必要的过大的输入输出量。尽管如此，本题最大的单测试点输入输出仍然可达 100MB 左右，请优化你的输入输出速度。

## 题目描述

陶陶过生日，有 $ n $ 个小伙伴站成环形为他庆祝，并将他们标号为 $ 1 \ldots n $，他们对应的身高为 $ a_1 \ldots a_n $。求如何排序，能让任意相邻的两个小伙伴之间身高差的绝对值最大值最小。

## 说明/提示

对于 $100\%$ 的数据，$2\leq n\leq 5\times 10^6$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5
2 1 1 3 2```

### 输出

```
1 2 3 2 1```

## 样例 #2

### 输入

```
3
30 10 20```

### 输出

```
10 20 30```

# 题解

## 作者：封禁用户 (赞：6)

## 思路

我们可以先不考虑环。

这样想一定是将数组 $a$ 从小到大排序，求最大相邻身高差。

可惜这样 $a_1$ 和 $a_n$ 的差到达最大。

我们可以让 $a$ 数组排列为 $a_1$，$a_3$，$a_5$，$\ldots$，$a_{2\times\lfloor n\div 2 \rfloor+1}$，$a_{2\times\lfloor n\div 2 \rfloor}$，$\ldots$，$a_4$，$a_2$，这样代价最小。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i+=2)
	cout<<a[i]<<' ';
	for(int i=(n/2)*2;i;i-=2) 
	cout<<a[i]<<' ';
}
```

简单！

---

## 作者：_xzhdsnh1364 (赞：2)

# 题外话

一个星期第二篇题解。

# 题意

$n$ 个同学围成一个环，要使相邻两人身高差距最大值最小，求排序后身高的序列。

# 解法

看完题目，很多童鞋可能会认为，直接从小到大排序就好了呀，可是这是一个环，所以我们要从小到大按身高将每个同学均匀分布在两侧。还有一种情况，就是同学数量为奇数，那也简单，将最终序列最后一个同学设为身高排序序列在最中间的那个同学就好了。

还有此题数据输入量最高可到达 $5 \times 10 ^ 6$，所以记得关闭流同步或加上快读。

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e6 + 5;
int n , a[N] , ans[N] , now = 1 , l , r;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    r = n;
    for(int i = 1;i <= n;i++)cin >> a[i];
    sort(a + 1 , a + n + 1);
    for(int i = 1;i <= n;i += 2){
        ans[++l] = a[i];
        ans[r--] = a[i + 1];
    }
    if(n % 2 == 1)ans[l] = a[n];
    for(int i = 1;i <= n;i++)cout << ans[i] << ' ';
    return 0;
}
```

---

## 作者：Wendy_Hello_qwq (赞：2)

[题目传送门。](https://www.luogu.com.cn/problem/B4194)

## 题意

题目给出了一个长度为 $n$ 的数组，要求我们构造一个数组的排序，这个排序要使这个数组每个数之间的差的绝对值最大值最小（包括第 $1$ 个和第 $n$ 个，即一个环）。

## 分析

这道题从哪里入手呢？首先观察样例。

```cpp
输入：
5
2 1 1 3 2
输出：
1 2 3 2 1
```
那么通过观察发现，想要得到我们想要的结果，构造数组时要尽可能让大的数在中间，越小的数尽量往两边散开，使两边平衡。

比如，这个答案数组中间的数 $3$，是原数组中最大的那个数，而 $3$ 左边和右边都是对称的，这样使得它们的每个数之间的差的绝对值最大值最小（包括第 $1$ 个和第 $n$ 个，即一个环）。

分析完毕，来讲讲如何实现：

- 我们先对数组进行从小到大的排序。

- 用双指针，一个记录头，一个记录尾。

- 将原数组的数交替存进答案数组的头和尾中。

- 最后记得特判一下 $n$ 为奇数的情况，那么答案数组中间的那个数就是原数组最大的那个数。

这个思路能够直接在 $5 \times 10^6$ 下通过，可以不需要优化输入输出速度。不过在赛场上容易卡常，建议使用 `scanf();printf();` 或 `ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);` 优化输出。

## Code

```cpp
// B4194.[海淀区小学组 2023] 生日
#include <cstdio>
#include <algorithm>
#define N 5000005
using namespace std;
int n, h, t, a[N], ans[N];
int main() {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++) scanf ("%d", &a[i]);
	// 对数组进行排序 
	sort (a + 1, a + 1 + n);
	t = n;
	for (int i = 1; i <= n; i += 2) {
		// 开始一头一尾重置新数组 
		ans[++h] = a[i];
		ans[t--] = a[i + 1];
	}
	// 特判奇数个数的情况：新数组最中间的数是原数组最后一个数 
	if (n % 2 == 1) ans[h] = a[n];
	for (int i = 1; i <= n; i++) printf ("%d ", ans[i]);
	return 0;
}
```

完结撒花。

[AC 记录。](https://www.luogu.com.cn/record/206635922)

---

## 作者：Like_Amao (赞：2)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/B4194)

**思路**

考虑先对数组进行排序，不过，这样数组第一个元素和最后一个元素的差就会非常大，因此，我们可以把数组分为两个部分，一个是下标是偶数的部分，另一个是下标是奇数的部分，然后将下标是奇数的部分翻转，放到下标是偶数的部分，就可以了。

**代码**


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[5000001];
class solution
{
	public:
		void work()
		{
			int n;
			cin>>n;
			for(int i=1;i<=n;i++)
			{
				cin>>a[i];
			}
			sort(a+1,a+n+1);
			for(int i=1;i<=n;i++)
			{
				if(i%2==0)
				{
					cout<<a[i]<<" ";
				}
			}
			for(int i=n;i>=1;i--)
			{
				if(i%2!=0)
				{
					cout<<a[i]<<" ";
				}
			}
		}
};
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	solution sol;
	sol.work();
	return 0;
}
```

---

## 作者：mcturtle (赞：2)

## 思路
首先进行排序。

我们考虑一种做法：排列 $a_0,a_1,\dots,a_{n-1}$。但是我们需要的是一个环形序列， $a_{n-1}-a_0$ 的差很明显最大，这不是最优的。

那么我们将其分成两份，一份是下标为奇数的数列 $A$，一份是下标为偶数的数列 $B$。

将数列 $B$ 翻转，并拼接在数列 $A$ 后面，我们就得到了一个最优数列。

对于一个任意的下标 $i(0\le i\le n-3)$，最大差为 $a_{i+2}-a_i$，明显比 $a_{n-1}-a_0$ 的差小多了。
## 代码
**注意：本题为 `SPJ`，本代码在测试样例 $2$ 时与样例输出不同。**
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[5000005];
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    sort(a, a + n);
    for (int i = 0; i < n; i++)
        if (i % 2 == 1)
            cout << a[i] << " ";
    for (int i = n - 1; i >= 0; i--)
        if (i % 2 == 0)
            cout << a[i] << " ";
    return 0;
}
```

---

## 作者：int_inf (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4194) ＆ [AC 记录](https://www.luogu.com.cn/record/206596408)
# Solution
本题由于需要构成一个环形，且要求两人身高差最小，不难想到使用**贪心**来解题。首先先对这个数列从小到大进行排序，将这个数列的后半部分倒序处理，最后输出第奇数个和第偶数个即可。

注意循环条件！！！（~~本人惨痛经历~~）
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000005]; //空间要开够 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); //加速 
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
	{
		if(i%2) cout<<a[i]<<" ";
	}
	for(int i=n;i>=1;i--) //注意循环条件 
	{
		if(!(i%2)) cout<<a[i]<<" ";
	}
	cout<<endl;
	return 0; //下次再见 
}
```
事已至此，不如留下赞和关注，后会有期。

---

## 作者：Sliarae (赞：1)

首先将 $a_{1 \sim n}$ 从小到大排序。容易想到构造 $a_1, a_2, \ldots, a_n$，但由于是环形序列，这样做 $a_1$ 和 $a_n$ 会连起来，很不优。

考虑构造 $a_1, a_3, a_5, \ldots, a_{2\lfloor  \frac{n - 1}{2} \rfloor + 1}, a_{2\lfloor \frac{n}{2} \rfloor}, \ldots, a_4, a_2$。比如 $n = 4$ 时构造 $a_1, a_3, a_4, a_2$，$n = 5$ 时构造 $a_1, a_3, a_5, a_4, a_2$。

这样构造的代价为 $\max\limits_{i = 1}^{n - 2} a_{i + 2} - a_i$。我们证明这是答案的下界：

- 对于任意的 $i(1 \le i \le n - 2)$，我们证明答案一定不小于 $a_{i + 2} - a_i$。

- 在环上找到 $i$ 所在的位置，分别向左右两边找第一个不小于 $a_{i + 1}$ 的数，其中至少一个不小于 $a_{i + 2}$，并且它旁边一定有一个数 $\le a_i$，这两个元素之差至少为 $a_{i + 2} - a_i$。证毕。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int kN = 5e6 + 5; 

int n;
int a[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i += 2)
		cout << a[i] << ' ';
	for (int i = (n >> 1) << 1; i; i -= 2) 
		cout << a[i] << ' ';
	cout << '\n';
	return 0; 
}
```

---

## 作者：Aventurine_ (赞：0)

# 算法使用
排序及贪心。
# 基本思路
考虑将 $a_1$ 到 $a_n$ 排序，但这样 $a_n$ 与 $a_1$ 相邻，显然不是最优解。      
可以将数组分为两部分，奇数下标与偶数下标分离，偶数下标的元素顺序输出，奇数下标逆序输出。这样相邻元素之差为 $a_{i+2}-a_i$，为最优解。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[5000009];
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)if(i%2==0)cout<<a[i]<<" ";
	for(int i=n;i>=1;i--)if(i%2==1)cout<<a[i]<<" ";
	return 0; 
}
```
[AC记录](https://www.luogu.com.cn/record/206787166)

---

## 作者：ridewind2013 (赞：0)

## 分析

给 $n$ 个人排身高，排成环形，要使任意相邻的两个人之间身高差的绝对值最大值最小。

## 思路

我们先尝试一种排法 $a_{1},a_{2},a_{3},a_{4},\dots,a_{n-1},a_{n}$，这样最大值会达到惊人的 $a_{n} - a_{1}$，明显不是最优排法。

运用贪心的策略，把大的放中间，小的放两边，所以就是 $a_{1},a_{3},a_{5},\dots,a_{n},\dots,a_{6},a_{4},a_{2}$。
所以我们先给数组排序，然后先从小到大输出下标为奇数的数，再从大到小输出下标为偶数的数，这样最大值就可以优化到 $$\begin{aligned} \max_{i = 3}^{n} a_{i} - a_{i-2} \end{aligned}$$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(i%2!=0)cout<<a[i]<<" ";
	}
	for(int i=n;i>=1;i--){
		if(i%2==0)cout<<a[i]<<" ";
	}
	return 0;
}
```

---

## 作者：xf20280111 (赞：0)

感觉不是很需要输入输出的优化？
## 思路
**惊人的注意力！这个序列是环形的。**

所以直接排序后输出 $a_{1}$ 和 $a_{n}$ 的差值会非常大，很容易构造出一组数据来卡掉他。

所以我们不一定要构造出非常小的差值。

这里思路就很显然了。

同样先进行排序，把下标奇数的元素放在一起，然后再把偶数的元素序列反转后再拼接到后面。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch;
const int N = 5000000 + 10;
int a[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;cin >> n;
    for (int i = 1;i <= n;i++){
        cin  >> a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1;i <= n;i++){
        if (i % 2 == 1) cout << a[i] << " ";
    }
    for (int i = n;i >= 1;i--){//反转
        if (i % 2 == 0) cout << a[i] << " ";
    }
    return 0;
}
```

---

## 作者：LINYUHENG2 (赞：0)

## 题意
给 $n$ 个人排身高，排成环形，要使任意相邻的两个人之间身高差的绝对值最大值最小。
## 思路
先将数组 $a$ 排序。

先尝试 $a_1,a_2,a_3,a_4,\dots,a_{n-1},a_n$ 这种排法，结果我们发现，最大值会是 $a_n-a_1$，显然是不行的。

那么，运用贪心的策略，把大的放中间，小的放两边。于是，成了 $a_1,a_3,a_5,\dots,a_n,\dots,a_6,a_4,a_2$。

我们只需要先从小到大输出下标为奇数的数，再从大到小输出下标为偶数的数，最大值为 $\max_{i=3}^n a_i-a_{i-2}$。
## 代码
```cpp
#include <bits/stdc++.h>
#define N 5000005
using namespace std;
int n,a[N];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        if(i%2==1) printf("%d ",a[i]);
    }
    for(int i=n;i>=1;i--){
        if(i%2==0) printf("%d ",a[i]);
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/207287474)

---


# [蓝桥杯青少年组国赛 2023] 主要成分

## 题目背景

金星是离地球最近的行星，人类发射的“金星快车”探测器的主要任务是对金星大气层进行精确的探测，分析其化学成分。

## 题目描述

从金星探测器传回来一组测量数据，这是一个长度为 $N$（$1 \leq N \leq 1\,000\,000$）的整数数列，数列中的每个整数代表某一种化学成分（相同的整数代表相同的化学成分）。 

**主要成分**：指在包含的所有化学成分中比例超过一半（$N \div 2$ 的结果向下取整）的成分。  

现在要判断其是否有主要成分；如果有，其主要成分是哪一种？  

**例如**：  
- 当 $N=7$，整数数列为 $1$ $2$ $3$ $2$ $2$ $1$ $2$，其中成分 $2$ 有 $4$ 个，超过了 $7$ 的一半（$7$ 的一半向下取整为 $3$），所以主要成分是 $2$。  
- 当 $N=6$，整数数列为 $1$ $102$ $31$ $31$ $1$ $102$，其中的每一种成分都只有 $2$ 个，未超过 $6$ 的一半（$6$ 的一半为 $3$），所以没有主要成分。  

## 样例 #1

### 输入

```
7
1 2 3 2 2 1 2```

### 输出

```
2```

# 题解

## 作者：yedalong (赞：3)

## Solution
提供一种较劣的解法。  
可以先用桶统计每个数出现的次数，统计完后再跑一遍看一下是否有一个数出现的次数大于 $\lfloor N\div 2\rfloor$。  
重要的一个性质：这些数中最多只有一个数出现次数大于一半。因此，只要找到第一个满足要求的就可以结束程序了。  
至于没找到，在循环外输出 `No` 即可。  
这里我是用 `unordered_map`，需要注意的是，用 `map` 可能会超时。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
unordered_map<int,int> t;
int n,a[1000005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i = 1;i<=n;i++) cin>>a[i],t[a[i]]++;
	for(int i = 1;i<=n;i++){
		if(t[a[i]]>n/2){
			cout<<a[i];
			return 0;
		}
	}
	cout<<"No";
	return 0;
} 
```

---

## 作者：hezhiran (赞：1)

## 题意

有 $N$ 个数，求其中出现次数超过一半（ $\frac{N}{2}$ 的结果向下取整）的那个数。

## 思路

用一个 ```map``` 来存储每一个数的出现次数，再循环遍历每一个出现次数超过一半的。

可是这样交上去会超时，于是我们可以把判断的代码放到输入的循环中，如果满足条件直接输出并 ```return```。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000010];
map<int,int> mp;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	int ans=-1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		mp[a[i]]++;
		if(mp[a[i]]>n/2){
			ans=a[i];
			cout<<ans;
			return 0;
		}
	}
	cout<<"No\n"; 
	return 0;
}
```

---

## 作者：LINYUHENG2 (赞：1)

由于该题数据范围较大，所以，开桶排序会炸。

因此我们使用 `map` 来存储每个成分的量，而且还可以边输入边判断，只要哪种成分的数量大于 $\left \lfloor \frac{n}{2}  \right \rfloor $，就马上输出，并结束程序。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
map<int,int>mp;
int n,a;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a);
        mp[a]++;
        if(mp[a]>n/2){
            printf("%d",a);
            return 0;
        }
    }
    printf("No");
    return 0;
}
```

---

## 作者：Starry_Sky_135 (赞：1)

#   思路

这道题范围过大，桶数组就变得不可行了。但是我们可以用 map 来替代桶数组，边输入 $x$ 边判断 $mp_x$ 是否大于 $\frac{2}{n}$。

时间复杂度有点高，卡一卡能过。

#   [AC](https://www.luogu.com.cn/record/211598155) 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>mp;
int n;
int main()
{
	cin>>n;
	for(int i=1,x;i<=n;i++)
	{
	    scanf("%d",&x);
	    mp[x]++;
	    if(mp[x]>n/2)
	    {
	        cout<<x<<endl;
	        return 0;
	    }
	}
	cout<<"No"<<endl;
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

字典存储，遍历字典找众数（或者发现数量达到众数时直接停止）。
```python
a=int(input());from collections import*;b=Counter(map(int,input().split()))
for i in b:
    if b[i]>a//2:print(i);exit()
print('No')
```

---

## 作者：Wide_Master (赞：0)

## 前言

居然这么简单的题目无人交题解，那我就来交一发吧。

## 正言

首先，要所含的化学成分超过一半，那我们是不是能开一个桶来储存，但是，因为输入最大达到了 $2 \times 10^9$，我们不能开一个数组来储存，所以我们用 map 来储存。

如果你这样子交上去的话，你只有 $80$ 分，为什么呢？因为 map 时间复杂度太高了。

所以我们重新想，想要求出一个数在序列里出现的次数，还要时间复杂度够快，这里有一种思路，我们排序，求一个数连续出现了多少次，然后统计一下最大出现次数就好了。

## 代码

### 80分

```cpp
//By Wide_Master
#include<bits/stdc++.h>
#define int long long
using namespace std;
map<int,int>s;
int n,h,a[1000005],maxv=-1,maxl=-1;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	h=n/2; 
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[a[i]]++;
	}
	for(int i=1;i<=n;i++){
		if(s[a[i]]>=h){
			if(s[a[i]]>maxl){
				maxl=s[a[i]];
				maxv=a[i];
			}
		}
	}
	if(maxv!=-1)cout<<maxv<<endl;
	else puts("No");
	return 0;
}
``````

### 100分

```cpp
//By Wide_Master
#include<bits/stdc++.h>
#define int long long
using namespace std;
map<int,int>s;
int n,h,a[1000005],maxv=-1,maxl=-1;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	h=n/2;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(int i=2,len=1;i<=n;i++){
		if(a[i]==a[i-1]){
			len++;
		}else{
			if(len>=h&&len>maxl){
				maxl=len;
				maxv=a[i-1];
			}
			len=1;//一定要注意不连续后len要变回1啊！
		}
	}
	if(maxv!=-1)cout<<maxv<<endl;
	else puts("No");
	
	return 0;
}
``````

---

## 作者：xf20280111 (赞：0)

考察了 `map` 的基本语法。
## 思路
我们用一个 `map` 记录每个数出现的次数。

不同于数组实现的桶，`map` 可以遍历，错过那些没有出现的数。

最后遍历 `map` 遍历即可。
## 代码
由于 `map` 插入是 $\log$ 级别，所以我们用快读快写来卡过去（可能是因为常数时间也比较大）。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1000000 + 10;
int a[N];
char ch;
inline void read(int &x)
{
    while((ch=getchar())<48||ch>57);
    x=ch^48;
    while((ch=getchar())<58&&ch>47)
        x=(x<<1)+(x<<3)+(ch^48);
}
inline void write(const int &x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}

map<int,int> vis;
int main()
{
    int n;read(n);
    for (int i = 1;i <= n;i++){
        read(a[i]);
        vis[a[i]]++;
    }   
    for (auto it = vis.begin();it != vis.end();it++) if (it -> second > floor(n / 2)) {cout << it -> first;return 0;}
    cout << "No";
    return 0;
}
```

---


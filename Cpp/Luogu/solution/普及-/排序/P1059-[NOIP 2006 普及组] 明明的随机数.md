# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# 题解

## 作者：qr小盆友 (赞：128)

# 分析一下

这题因为既要排序又要去重，而且数据范围不大，所以可以用改进一下的桶排序。

## 那桶排序是什么呢？？？

我们换个思路想，如果要对一串数字排序，是不是可以**这样做：**

如果排序的数字在10以内，那我们先拿出十个小桶：

![1.jpg](https://i.loli.net/2019/10/06/uHKioqjmgr5Ll3z.jpg)

第一个读入的是3，那么在3上插一根小棒；

![2.jpg](https://i.loli.net/2019/10/06/5RsKFuhXGar9TkP.jpg)

接下来是5；

![3.jpg](https://i.loli.net/2019/10/06/CstgVeSZpax3Grd.jpg)

这是又来了一个3。我们不管这么多，继续；

![4.jpg](https://i.loli.net/2019/10/06/ZQgiyG4n61S8I3A.jpg)

## 以此类推。

打印的时候一个一个小桶看：

```
1号：0根小棒，不打印。

2号：0根小棒，不打印。

3号：2根小棒，打印“3 3 ”。

4号：0根小棒，不打印。

5号：1根小棒，打印“5”。

6号：0根小棒，不打印。

7号：0根小棒，不打印。

8号：0根小棒，不打印。

9号：0根小棒，不打印。

10号：0根小棒，不打印。
```

## 那么我们排序完毕了。
（真正的桶排序还要更复杂一些）

------------------

想必大家都发现了，桶排序很浪费空间！！！

不过像该题，数据不大，可以使用桶排序。

有了桶排序，我们还要**改进一下：**在标记前（就是插入小棒前）增加一个判定，如果该数是第一次出现的话，就把累加器+1。这样就满足了题目要求。**机智如我！**

那么大家就可以着手写程序了。

----------------------

# 完整AC代码：

```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;
int main(){
    bool book[1001]={0};//表示num[0]~[100]的数组，为了方便，num[0]是不用的
                    	//因为只用表示是否出现过，需要去重，用bool就行了
                    	//单词book也有标记的意思
                    	//记得初始化
    int n;	//表示随机数的个数
    int final=0;
    cin>>n;
    int a[n];   //储存随机数
    for(int i=0;i<n;i++){
    	cin>>a[i];
    	if(book[a[i]]==0){  //如果这个数在之前还没出现过
    		final++;
	}
    	book[a[i]]=1;//核心代码
    }
    cout<<final<<endl;
    for(int i=1;i<=1000;i++){  //打印标记过的数字
        if(book[i]==1){
            cout<<i<<" ";
        }
    }
    return 0;
}
```
![批注 2019-10-06 104417.jpg](https://i.loli.net/2019/10/06/UCweaFJWu4AzZdO.jpg)

--------------------

# 感谢阅读！
### BY qr小盆友

---

## 作者：Erina (赞：40)

emm,STL是万能的,有一个函数叫做unique,可以提出所有连续的数并缩减到一个.

举个例子:
```cpp
#include<iostream>
#include<algorithm>//unique in <algorithm>
using namespace std;
int main(){
	int ints[]={1,1,1,1,2,2,2,3,5,5,10};
    unique(ints,ints+11);
    for(int i=0;i<5;i++)cout<<ints[i]<<' ';
}
```
最后输出:1 2 3 5 10

在离散化中,同样可以用这个来偷懒
附上代码:
```cpp
#include<iostream>
#include<algorithm>//sort和unique都在这个库里
#include<vector>//vector真方便
using namespace std;
vector<int>mem;
int main(){
	int n,k;
    cin>>n;
    for(int i=0;i<n;i++){
    	cin>>k;//读入
        mem.push_back(k);
    }
    vector<int>::iterator it;//记录调整后的位置
    sort(mem.begin(),mem.end());
    it=unique(mem.begin(),mem.end());//unique返回最后的指针
    mem.resize(distance(mem.begin(),it));//更改mem的大小,否则输出容易错
    cout<<mem.size<<endl;
    for(int i=0;i<mem.size();i++){
    	cout<<mem[i]<<' ';//输出
	}
}
```

---

## 作者：2023z (赞：23)

### 思路

这道题可以先排序再去重，因为我们发现，排序后同样的数字会被排在一起，如图：

假设原来为

#### $ 20,40,32,67,40 $ 

排完序后就变成了

#### $ 20,32,40,40,67 $ 

这时候重复的 $ 40 $ 就挨在一起了，于是去重就好办了。直接判断 `if(a[i]==a[i-1])` 的话，就输出。但是这道题要先输出去重后的数量，于是就要分两次循环来解决，第一次统计去重后的数量，第二次输出去重后的序列。注意错误代码：

```cpp
for(int i=1;i<=n;i++){
	if(a[i]==a[i-1]){ //判断是否有重复的，因为重复的会被排在一起，所以只要判断和i-1数是否相等
		cnt--; //cnt表示有几个不同的数
		a[i]=0;
	}
}
cout<<cnt<<endl;
for(int i=1;i<=n;i++){
	if(a[i]!=a[i-1])
		cout<<a[i]<<' ';
}
```

看这个数据

 $ 8 $

 $ 20\enspace40\enspace321\enspace67\enspace40\enspace40\enspace89\enspace15 $

三个四十会被排列在一起，如果把第二个四十赋值为 $ 0 $，第三个四十就不会被排除，答案就错了。

正确代码应为：


```cpp
for(int i=1;i<=n;i++){
		if(a[i]==a[i-1]) //判断是否有重复的，因为重复的会被排在一起，所以只要判断和i-1数是否相等
			cnt--;
	}
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]) //如果没重复就输出
			cout<<a[i]<<' ';
	}
```

然后就可以愉快的[AC](https://www.luogu.com.cn/record/198419190)啦

**code：**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110],cnt; //cnt表示有几个不同的数
int main(){
	cin>>n;
	cnt=n; //首先要赋值为n
	for(int i=1;i<=n;i++) cin>>a[i]; //输入
	sort(a+1,a+n+1); //排序
	for(int i=1;i<=n;i++){
		if(a[i]==a[i-1]) //判断是否有重复的，因为重复的会被排在一起，所以只要判断和i-1数是否相等
			cnt--;
	}
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]) //如果没重复就输出
			cout<<a[i]<<' ';
	}
	return 0;
} //华丽结束，点赞评论再走吧QWQ
```

---

## 作者：mcturtle (赞：7)

## 前置知识
`set`，又称集，是 `STL` 库中的一个容器。当它插入了一个元素后，它会自动将元素排序，并去重。
## 思路
`set` 模板可以秒掉这道题。

先输入 $n$，再输入 $n$ 个数，输入过程中直接加入到 `set` 中查重排序，再分别输出集的大小和各个数即可。
对了，`set` 不能按照下标输出，得用迭代器。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
set<int>s;
int main()
{
	int n;
	cin>>n;
	while(n--){
	    int x;
	    cin>>x;
	    s.insert(x);
	}
	cout<<s.size()<<endl;
	for(auto it=s.begin();it!=s.end();it++){
	    cout<<*it<<" ";
	}
	return 0;
 }
```
复杂度 $\mathcal{O(n)}$。

---

## 作者：Stars_Traveller (赞：5)

## 题解：P1059 [NOIP2006 普及组] 明明的随机数
### 分析
值域不大，可以使用桶排。

对于每个 $a_i$，用数组记录他的值出现的次数。然后再枚举从 $1 \sim 1000$，直接输出出现过的数即可。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, a[105], tong[1005], sum;
signed main()
{
   
    cin>>n;
    for(int i=1;i<=n;i++){cin>>a[i];tong[a[i]]++;}
	for(int i=1;i<=1000;i++)if(tong[i])sum++;
	cout<<sum<<"\n";
	for(int i=1;i<=1000;i++)if(tong[i])cout<<i<<" ";
}
```

---

## 作者：bym666 (赞：5)

# P1059 明明的随机数   
这道题题目中明确地说明了我们需要做的事情，就是排序和去重。那么这道题就要分为两个部分来做。
## 排序
排序我用的是sort，如果你不想偷懒也可以手写排序。另外讲一下sort的用法（虽然我觉得大家应该都会，就当作帮助c++菜鸟好了）：sort（要排序的第一位，要排序的最后一位的下一位，排序方法；不加时默认为从小到大）。比如要把数组a[10]从小到大排序，就是sort（a+0,a+10）。
## 去重
去重我是每发现一个重复的就标记，输出时跳过（列表表示一下）
| 序号 |1  | 2 | 3 | 4 | 5 | 6 |7  | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|数字  | 15 | 20 |20  |32  | 40 |40  |67  |89  |300 |400  |
|  标记（初始为0）|0  |1  | 0 | 0 |1  | 0 | 0 | 0 |  0| 0 |
| 输出 | 15 |20  | 32 | 40 | 67 | 89 |300 |400  |  |  |
代码如下：
```
#include <bits/stdc++.h>//万能头文件 
using namespace std;
int n,a[101],i,ans;
bool f[101];
int main()
{
	cin>>n;//输入个数 
	ans=n;//最终答案的个数一开始与输入的个数相同 
	for(i=0;i<n;i++) cin>>a[i];//输入数字 
	sort(a+0,a+n);//排序 
	for(i=1;i<=n;i++) //去重 
	{
		if(a[i]==a[i-1])//如果相同 
		{
			ans--;//最终答案的个数减一 
		    f[i-1]=1;//标记为一 
		}
	}
	cout<<ans<<endl;//输出最终答案的个数 
	for(i=0;i<n;i++)//输出数字 
	{
		if(f[i]==0) cout<<a[i]<<" ";
	} 
} 
```


---

## 作者：Stone_Xz (赞：3)

# [传送门：P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

# 分析：

1. 我们开一个标记数组记录 $vis_i$ 记录 $i$ 这个数字在数列中有没有出现过，如果之前没出现过，现在第一次出现了，我们就让不同的数字数 $sum + 1$。

2. 依次枚举 $1 \sim 1000$ 的所有数字，看它在数列中有没有出现过。如果出现过就输出，这样同一个数字就只会输出一次。并且因为我们是依次枚举的，输出的数列一定是从大到小排好序的。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, sum;

bool vis[1005];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        if (vis[x])  //如果这个数已经出现过了，那么跳过
            continue;
        vis[x] = true;  //如果没有出现，把数据放在桶里，并让总数居++
        sum ++;
    }
    cout << sum << "\n";
    for (int i = 1; i <= 1000; i++) // 枚举 1-1000每一个数字，检查是否出现过 
        if (vis[i])
            cout << i << " ";
    return 0;
}
```

---

## 作者：kunkun127 (赞：3)

## 思路

这题就是桶排序的入门题。

- 桶排序

  我们先介绍桶排序是什么。

  我们对一串数字进行排序，在比较大小的过程中，我们会发现很多重复的数字。

  那么不妨把每个数字看作一个桶，每次输入的 $x$ 就使第 $x$ 个桶里面的数量加一，最后按照自然数的自然规律进行遍历，即可排序。

  **注意，桶排序空间较大，慎重使用！**

- 本题思路

  题目中说我们要“去重”与“排序”。那我们根据上面所述，进行模拟，把出现过的数**只加一次**进 $ans$ 数组，同时记录有多少个出现过的不重复的数即可。

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

int box[1005], ans[105];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int q;
		cin >> q;
		box[q]++;
	}
	int cur = 0, cnt = 0;
	for (int i = 1; i <= 1000; i++)
	{
		if (box[i] != 0)
		{
			cnt++;
			ans[++cur] = i;
		}
	}
	cout << cnt << endl;
	for (int i = 1; i <= cur; i++) cout << ans[i] << " ";
	return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：2)

## $\mathbf{Knowledge}$

1. 排序

## $\mathbf{Solution}$

看到题面，我们会想到要去重。去重的话，可以用桶排序和 `unique` 函数解决，现在，我们来隆重介绍一下 `unique` 函数。

`unique` 函数在 `algorithm` 头文件中。它用于去除容器或数组中相邻的重复元素。不过，它不会真正删除元素，而是将重复的元素移动到容器的末尾，并返回去重后的尾地址，具体见下面的代码：

```cpp
#include<cstdio>
#include<algorithm>//unique 和 sort函数需要 
using namespace std;
int arr[7]={1,1,4,5,1,4};//我们要去重的数组 
int main(){
	sort(arr,arr+6);//用 unique 函数前要排序 
    int n=unique(arr,arr+6)-arr-1;//unique 函数，参数填写近似于 sort，n 是这个数组经过去重后的最后元素的下标。其中，-arr-1 能将指针地址变为元素下标。 
    for(int i=0;i<=n;i++){
    	printf("%d ",arr[i]);//输出 1 4 5 
	}
	return 0;
}
```

知道了 `unique` 函数的用法，题目做法也就一目了然了。

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[101],c;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
    	scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);//排序 
    c=unique(a+1,a+n+1)-a-1;//去重 
    printf("%d\n",c);
    for(int i=1;i<=c;i++){
    	printf("%d ",a[i]);
	}
	return 0;
}
```

---

## 作者：Sweet_2013 (赞：2)

# 我的解题思路
- 创建一个桶 $t$。
- 读入 $n$ 和 $a_i$，把它放到桶所给定的位置。
- 如果桶的这一位不是 $0$，那么表示不相同的随机数个数的变量 $sum+1$，并且输出桶的这一位。
# 上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[101], t[1001], sum;
int main(){
	cin>> n;
	for(int i=1;i<=n;i++){
		cin>> a[i];
		t[a[i]]=a[i];
	} 
	for(int i=1;i<=1000;i++) if(t[i]!=0) sum++;
	cout<<sum<<endl;
	for(int i=1;i<=1000;i++) if(t[i]!=0) cout<<t[i]<<" ";
	return 0;
}
```

---

## 作者：BetterGlow (赞：2)

# P1059 题解

## 解决

题面很长，我们提取关键信息：

- 有 $N$ 个随机整数。

求的是：

- $N$ 个数“去重” 并“排序” 后的结果。

排序相信大家都会，我们可以用 `sort()` 完成。那么去重怎么完成呢？接下来我们介绍一下 `unique()`：

首先注意，`unique()` 只能对**相邻**的元素进行操作，所以使用前需要排序。同时 `unique()` 并没有删除元素，而是将重复的元素排在了后边。

`unique(x,y)` 中，第一个参数写起始位置，第二个参数写结束位置。

`unique()` 返回去重后最后一个有效元素的下一个位置。

相信大家对 `unique()` 有所了解了！我们来看个例子：

```cpp
cin>>n;
for(int i=0;i<n;i++) cin>>m[i];
sort(m,m+n); //排序
fini=unique(m,m+n)-m;
//unique(m,m+n) 返回的是 m 的前 n 项去重后，最后一个元素的下一个位置，但注意返回的是一个地址 (int*)，我们需要减 m 才能获得我们需要的 (int)。
cout<<fini<<endl;
for(int i=0;i<fini;i++) cout<<m[i]<<" ";
```

## 代码

```cpp
#include<bits/stdc++.h>
#define maxn 105
using namespace std;
int n,m[maxn],fini;
int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>m[i];
    sort(m,m+n);
    fini=unique(m,m+n)-m;
    cout<<fini<<endl;
    for(int i=0;i<fini;i++) cout<<m[i]<<" ";
    return 0;
}
```

---

## 作者：zhoujunchen (赞：2)

做题思路
--

这题又让我们排序，又让我们去重，考虑到数字大小不超过一千，我们可以开个桶数组 $cnt$，$cnt_i$ 表示数字 $i$ 在序列中出现的个数，然后遍历桶，如果发现 $cnt_i>0$，记录答案。

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,count[1005]={0},tf[1005]={0},tmp,sum=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>tmp;
        if(tf[tmp]==0){
            count[tmp]++;
            tf[tmp]=1;
        }    
    }
    for(int i=0;i<1005;i++)if(tf[i]>0)sum++;
    printf("%d\n",sum);
    for(int i=0;i<1005;i++)if(count[i]>0)printf("%d ",i);
    return 0;
}
```

---

## 作者：GZXUEXUE (赞：2)

这里分享两种方法。

### 思路一

我们可以利用 STL 中自带的 set 容器自动排序、去重的特性解决本题，关于 set 容器可参见[OI-Wiki](https://oi-wiki.org/lang/csl/associative-container/#set)，这里不再赘述。

时间复杂度为 $O(N)$，相对后文时间更快且适用于较大的对于「随机整数」的数据范围。

### 实现一

```cpp
# include <iostream>
# include <set>
using namespace std;
int main(){
	int n; cin >> n;
	set<int> s;
	for (int i = 1;i <= n;i++){
		int tmp; cin >> tmp;
		s.insert(tmp);
	}cout << s.size() << endl;
	for (auto i : s) cout << i << " ";
	return 0;
}
```

### 思路二

观察到随机整数范围在 $1$ 到 $1000$ 之间，考虑使用一个 $\text{cnt}$ 数组记录每个数字的出现与否，同时记录**没有重复的**数字的出现次数，可以据此达到 「去重」的目的。在输出时，我们遍历每一个数字，如果出现过就输出，可以据此达到「排序」的目的。

时间复杂度为 $O(M)$，其中 $M = 1000$，略慢于上一思路（因为 $N \le 100$）。


### 实现二

```cpp
# include <iostream>
# include <set>
using namespace std;
int cnt[1001];
int main(){
	int n,num = 0; cin >> n;
	for (int i = 1;i <= n;i++){
		int tmp; cin >> tmp;
		num += !(cnt[tmp]);
		cnt[tmp]++;
	}cout << num << endl;
	for (int i = 1;i <= 1000;i++){
		if (cnt[i]) cout << i << " ";
	}return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：2)

## 题解：P1059 [NOIP2006 普及组] 明明的随机数
### 分析
这里我们使用桶排序。

对于每个 $a_i$，用数组记录他的值出现的次数。然后再枚举值域，对于 $1 \sim 1000$ 中出现过的数，直接输出即可。这样既保证了按从小到大输出，又完成了去重。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n, a[105], cnt[1005]={0}, sum=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>a[i];
    	cnt[a[i]]++;
	}
	for(int i=1;i<=1000;i++)
	{
		if(cnt[i]!=0)
		{
			sum++;
		}
	}
	cout<<sum<<endl;
	for(int i=1;i<=1000;i++)
	{
		if(cnt[i]!=0)
		{
			cout<<i<<" ";
		}
	}
	return 0;
}
```

---

## 作者：jscaj0921 (赞：1)

# P1059题解

很明显，这是一道排序题。

## 思路

由于考虑了去重，所以用其他排序会烦一点。  
于是就可以用桶排序来解决。
定义一个 bool 数组，读一个数就将其转为 true 。  
桶排序虽然简单，但这里提供另一种思路。  
先进行快排，输出时进行判断去重，如果一个元素和上一个相等，那就要去掉，反之，不相等就不去。
```cpp
if (a[i] != a[i - 1])
{
    cout << a[i] << " ";
}
```
因为排序后的数组是单调的，所以这样就可以去全了。
### CODE
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[101];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        if (a[i] != a[i - 1])
        {
            ans++;
        }
    }
    cout << ans << endl;
    for (int i = 1; i <= n; i++)
    {
        if (a[i] != a[i - 1])
        {
            cout << a[i] << " ";
        }
    }
    return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道模拟题。

发现值域很小，考虑桶排。对于求不相同数个数，将当前元素加入桶时，若当前元素出现次数为零，不相同数的个数加一。

[通过记录](https://hydro.ac/record/6787af95cd244a3f57f22f08)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int b[1005], sum, n;
int main(){
	cin >> n;
	for(int x; n--; )
		cin >> x,
		sum+=(!b[x]),
		b[x]++;
	cout << sum << '\n';
	for(int i=0; i<1001; i++)
		if(b[i]) 
            cout << i << " ";
	return 0;
}
```

---

## 作者：wangshengchen (赞：1)

# 思路
我们需要完成“去重”与“排序”的工作。我们可以这样想，如果输入了一个数，我们就把这个数当作数组 $b$ 的下标，让 $b$ 的位置 $+ 1$，最后输出这个下标的元素不是 $0$ 的下标。~~听起来有些绕口......~~

## Code

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<cmath>
#include<vector>
#include<set>
#include<map>
#define Over exit(0);return 1
#define FAST_Used ios::sync_with_stdio(0),cin.tie(0)
#define FAST_2 ios_base::sync_with_stdio(0)
#define FAST_3 cout.tie(0)
#define FAST_Ultimate ios::sync_with_stdio(0),ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)

using namespace std;

int n,len=1,x;
bool b[1005];//布尔类型占用的空间小（2）

int main(){
	FAST_Ultimate;//加快cin,cout速度
	
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x;
		b[x]++;//标记
	}
	for(int i=0;i<1001;i++) if(b[i]) len++;//计算长度
    /************************输出*****************************/
	cout<<len-1<<"\n";
	for(int i=0;i<1001;i++) if(b[i]) cout<<i<<" ";
	
	Over;
}
```

---

## 作者：陈嘉逸2012 (赞：1)

~太水了吧！~
## 思路
新建一个桶 $c$，每次输入一个随机数 $t$，将 $c_t$ 自增一（其实也可以用 `bool` 数组打标记），并统计到统计个数的变量 $s$ 里，最后遍历 $c_i$，输出即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,c[1005];
int main(){
	cin>>n;
	for(int i=1,t;i<=n;i++) cin>>t,s+=(c[t]?0:1),c[t]++;//输入；三目运算，如果 c[t]=0，就自增；统计个数（等同于 "c[t]=1"）
	cout<<s<<'\n';//输出个数
	for(int i=1;i<=1000;i++){
		if(c[i]) cout<<i<<' ';//若不为 0，输出
	}
}
```

---

## 作者：yuxinrui0618 (赞：1)

# 题解：P1059 [NOIP2006 普及组] 明明的随机数
## 1. 题目大意
- 给你一列数，进行排序和去重工作；

## 2. 思路
- 排序这里就不说了，最简单的就直接快排（当然，因为数据小，其他排序都行）；
- 接下来，求不相同的随机数的个数。我的方法很与众不同：在有序的条件下，前一个数与后一个数不相等，则该数是不重复的，计数器加一；
- 最后输出，就是只要该数不重复就输出，否则不输出。

## 3. 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
long long s[100001];
int main(){
    int a;
    cin>>a;
    for(int i=1;i<=a;i++)
        cin>>s[i];
    sort(s+1,s+a+1);
    int d=0;
    for(int i=1;i<=a;i++)
        if(s[i]!=s[i+1])
            d++;
    cout<<d<<endl;
    for(int i=1;i<=a;i++)
        if(s[i]!=s[i+1])
            cout<<s[i]<<" ";
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：Kawaii_qiuw (赞：1)

### 思路

这道题目主要就是让你把相同的元素删掉，只留下一个，并排序输出。

拿样例来看：

$20$ 重复了，只算一个，$40$ 重复了，也只算一个，因此只有 $n - 2$ 个（去除重复后）。

我们可以来思考怎么才能变得更简单一些呢？

1. 把重复的元素算一个再进行排序

2. 把它进行排序，再判断重复的元素

如果说使用第一种方法的也是可以做出来的，就是有点麻烦。

第二种先排序，相同的元素自然会挨在一起，就像这样：

如一个数组 $1,4,2,3,5,1,5$。

排序完之后固然是：$1,1,2,3,4,5,5$。

因此我们只需要判断当前元素 $a_i$ 是否和 $a_i + 1$ 相同，如果相同则跳过（因为第二个之后就不一定是相同了），这样就实现了去除相同元素。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, ans = 0, k = 0;
    cin >> n;
    int a[n], b[n];
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a, a+n);
    for (int i = 0; i < n - 1; i++) {
    	if (a[i] == a[i + 1]) {
			ans++;
			continue;
		}
    	b[k] = a[i];
    	k++;
	}
	b[k] = a[n - 1];
	cout << k + 1 << endl;
	for (int i = 0; i <= k; i++) cout << b[i] << " ";
    return 0;
}
```

---

## 作者：jiqihang (赞：1)

我分部分说明。
### 排序
直接用 sort 排序即可。

不会 sort 的自己搜索。

### 去重
去重很简单。

可以定义一个 bool 数组，若原数组两个值重复，则将此时的 $i+1$（$i$ 为循环变量）的值改变。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000];
bool b[10000];
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];//输入 
	sort(a,a+n);//排序 
	int gs=n;
	for(int i=0;i<n;i++) if(a[i]==a[i+1]) b[i+1]=1,gs--;//去重 
	cout<<gs<<endl;
	for(int i=0;i<n;i++) if(b[i]==0) cout<<a[i]<<" ";//输出 
	return 0;
 }
```

---

## 作者：Eason_lyx (赞：1)

博客效果**更佳**->[洛谷博客](https://www.luogu.com.cn/article/t6iku0nc)。

### 题目大意
输入 $N$ 个 1 至 1000 的整数。其中有 $N \le 100$。你需要将它们去重、排序。并输出**去重后**的整数个数，以及**从小到大**排序后的结果。
### 题目分析
这是一道很裸的桶排序题。如果你不知道什么是桶排序，请看 [这里](https://oi-wiki.org/basic/bucket-sort/),有十分详细的说明，这里不多说。
### 代码

#### 注释版：

```cpp
#include<bits/stdc++.h>
using namespace std;
int box[1005];//这是桶数组
int n,s=0,x;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		box[x]++;//桶计数
	}//输入
	for(int i=1;i<=1000;++i){
		if(box[i])s++;//计算总数
	}
	printf("%d\n",s);
	for(int i=1;i<=1000;++i){ 
		if(box[i])printf("%d ",i);
	}//输出
	return 0;
}

```


#### 无注释版：
```cpp
#include<bits/stdc++.h>
using namespace std;
int box[1005];
int n,s=0,x;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		box[x]++;
	}
	for(int i=1;i<=1000;++i){
		if(box[i])s++;
	}
	printf("%d\n",s);
	for(int i=1;i<=1000;++i){ 
		if(box[i])printf("%d ",i);
	}
	return 0;
}


```
[评测记录](https://www.luogu.com.cn/record/198399163)。

---

## 作者：GSQ0829 (赞：1)

### 思路：
桶排序的思想，就是把随机数存入对应数字的桶中。

但是，要注意优化，不然数据量一大起来，桶就会超时。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, x, a[1001], maxn, minn, m = 0;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		if (a[x] == 0) m++, a[x] = 1;
		minn = min(minn, x);
		maxn = max(maxn, x);
	}
	cout << m << endl;
	for (int i = minn; i <= maxn; i++) if (a[i]) cout << i << ' ';
	return 0;
}
```

---

## 作者：Kaidora (赞：1)

本【题解】准确说是【语言解】，完全用内核的数组方法做题。

本题解意义仅在于示范 Ruby 基本操作。

gets 固定读入一行，返回一个字符串；

split() 表示将字符串按给出的参数为分隔符，分割为字符串数组，默认参数为空格；

map(&:to_i) 表示对数组的每个元素进行操作，而 to_i 操作就是将字符串转化为整数。

整一行意义就是读入一个整数数组，赋值给 arr。

不加感叹号 ! 的方法表示返回一个新数组，因此

s = arr.uniq

可以得到去重的数组 s ，而 arr 保持不变；

arr.uniq!

则会改变 arr 。sort 方法同理。

去重与排序的先后顺序可能会影响运行效率，但最终效果相同。


```python
N = gets.to_i   #这个N没什么用
arr = gets.split.map(&:to_i)    #读入数组
arr.uniq!   #去重
arr.sort!   #排序
puts arr.size   #输出数组大小
puts arr.join(' ')  #以' '为分隔输出数组所有元素
```


---

## 作者：banana365 (赞：0)

也是非常的简单好吧。

首先将输入的数组用 `sort` 函数排个序，然后枚举每一位是否和前一位相同。如果相同就忽略，如果不同就加入答案中，记得统计总数。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, tot, a[1005];

vector<int> ans;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n);
	a[0] = -114514;
	for (int i = 1; i <= n; i++) {
		if (a[i] != a[i - 1]) {
			tot ++;
			ans.push_back(a[i]);
		}
	}
	cout << tot << "\n";
	for (auto haha : ans)
		cout << haha << " ";
	return 0;
}
```

---

## 作者：Eason0324 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1059)

## 思路
用一个数组来存储，排序后去重即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
    cin>>a;
    b=a;
  	int f[a];
    for(int i=0;i<a;i++)
        cin>>f[i];
    sort(f,f+a);
    for(int i=1;i<a;i++)
        if(f[i]==f[i-1])
            b--;
    cout<<b<<endl;
    for(int i=0;i<a;i++)
        if(f[i]!=f[i-1])
            cout<<f[i]<<" ";
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：0)

## 思路

大概题意：将一个序列去重并排序，输出调整之后的序列长度和序列。

而 STL 里面就有一个和这个有关的容器，就是 `set`。

我们把每个数用 `insert` 都放到 `set` 容器里。

随后输出长度和调整好的序列即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
set<int> st;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		st.insert(t); 
	} 
	cout<<st.size()<<endl;
	for(auto it:st){
		cout<<it<<' ';
	}
	return 0;
}
```

---

## 作者：sieve (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1059)

### 思路

首先，我们先进行排序，那么如果有一样的，则一定存在 $a_i = a_{i - 1}$ 的情况，有多少个这样的情况就有几组一样的，所以，最后的元素个数是 $a_i \ne a_{i - 1}$ 的个数。

最后，如果 $a_i \ne a_{i - 1}$，那么说明不是重复的，输出 $a_i$，否则就是重复的，不输出。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum,n,a[1100];
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i) {
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i) {
		if(a[i]!=a[i-1]) {
			sum++;
		}
	}
	cout<<sum<<"\n";
	for(int i=1;i<=n;++i) {
		if(a[i]!=a[i-1]) {
			cout<<a[i]<<' ';
		}
	}
	return 0;
}
```

---


# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# 题解

## 作者：「已注销」 (赞：293)

作为蒟蒻，表示不会结构体，用了下标数组

```cpp
#include<bits/stdc++.h>万能头文件
using namespace std;
int i,n,m,f,k[5001],s[5001],sub[5001];f是分数线，sub是下标
bool cmp(int a,int b){sort规则
    if(s[a]==s[b])return k[a]<k[b];成绩相等比编号
    return s[a]>s[b];否则比成绩
}
int main(){
    cin>>n>>m;
    for(i=1;i<=n;i++)cin>>k[sub[i]=i]>>s[i];输入编号和成绩，同时初始化下标
    sort(sub+1,sub+n+1,cmp);对下标排序
    f=s[sub[int(m*1.5)]];算分数线
    for(i=1;s[sub[i]]>=f;i++);算录取人数
    cout<<f<<" "<<i-1<<endl;
    for(i=1;s[sub[i]]>=f;i++)cout<<k[sub[i]]<<" "<<s[sub[i]]<<endl;输出
}
```

---

## 作者：zhengrunzhe (赞：30)

提供一个Splay /滑稽

分数左大右小

把分数相同的当作一个点 把报名号塞进该点的set中自动排序

把排名m*1.5的数旋转至根，得到录取分数

此时把根与右子树的连接断掉

从根中序遍历(即遍历根和其左子树

```cpp
#include<set>
#include<cstdio>
using namespace std;
class Balanced_Binary_Tree
{
	private:
		struct tree
		{
			int value,size;
			tree *fa,*son[2];
			set<int>id;
			inline tree(int key,int num)
			{
				size=1;
				value=key;id.insert(num);
				fa=son[0]=son[1]=NULL;
			}
			inline void pushup()
			{
				size=id.size();
				if (son[0])size+=son[0]->size;
				if (son[1])size+=son[1]->size;
			}
			inline int lsize() //方便获取左子树大小
			{
				return son[0]?son[0]->size:0;
			}
		};
		inline bool relation(tree *p)
		{
			if (p->fa)return p->fa->son[1]==p;
		}
		inline void connect(tree *p,tree *fa,bool which)
		{
			if (p)p->fa=fa;
			if (fa)fa->son[which]=p;
		}
		inline void rotate(tree *&p)
		{
			tree *fa=p->fa;
			bool lr=relation(p);
			connect(p,fa->fa,relation(fa));
			connect(p->son[lr^1],fa,lr);
			connect(fa,p,lr^1);
			fa->pushup();p->pushup();
		}
	public:
		tree  *root;
		inline void splay(tree *p)
		{
			for (tree *fa;fa=p->fa;rotate(p))
				if (fa->fa)
					rotate(relation(p)==relation(fa)?fa:p);
			root=p;
		}
		inline void insert(int key,int num)
		{
			if (root==NULL){root=new tree(key,num);return;}
			tree *now=root;
			while (1)
			{
				if (now->value==key)
				{
					now->id.insert(num);
					now->pushup();
					if (now->fa)now->fa->pushup();
					splay(now);
					return;
				}
				tree *fa=now;
				bool dir=key<now->value;
				now=now->son[dir];
				if (now==NULL)
				{
					now=new tree(key,num);
					connect(now,fa,dir);
					fa->pushup();
					splay(now);
					return;
				}
			}
		}
		inline tree *find_rank(int ranking)
		{
			tree *now=root;
			while (1)
				if (ranking<=now->lsize())now=now->son[0];
				else
				{
					ranking-=now->lsize()+now->id.size();
					if (ranking<=0)return now;
					now=now->son[1];
				}
		}
		inline void write(tree *p) //中序遍历
		{
			if (p->son[0])write(p->son[0]);
			for (set<int>::iterator i=p->id.begin();i!=p->id.end();i++)
				printf("%d %d\n",*i,p->value);
			if (p->son[1])write(p->son[1]);
		}
}Splay;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	while (n--)
	{
		int k,s;
		scanf("%d%d",&k,&s);
		Splay.insert(s,k);
	}
	m*=1.5;
	Splay.splay(Splay.find_rank(m));
	printf("%d %d\n",Splay.root->value,Splay.root->lsize()+Splay.root->id.size()); //有并列 要输出的是并列中的最后一名的排名
	Splay.root->son[1]=NULL; //断掉150%m之后的
	Splay.write(Splay.root); //输出150%m之前的
	return 0;
}
```

---

## 作者：2023z (赞：17)

### 题意

让我们输出分数线及按从大到小的顺序输出录取的所有人的考号和分数。

### 思路

我们用一个结构体来存储每个人的考号和分数，按从大到小的顺序对分数进行排序，在分数相同的情况下，考号小的就排在前面，因为题目说成绩相同，则按报名号由小到大的顺序输出，然后算出分数线，从最后一个人开始，找出第一个大于等于分数线的就停止，记录下当前下标 $ i $ ，就有 $ i $ 个人被录取，然后输出录取的所有人的考号和分数。

#### code：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct Scoreline{
	int k,s;
}a[5010]; //k 代表考号，s 代表分数
int n,m,j; //j 来记录第一个大于等于分数线的下标
bool cmp(Scoreline a,Scoreline b){
	if(a.s!=b.s) return a.s>b.s;
	return a.k<b.k;
} //排序函数
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i].k>>a[i].s; //输入
	sort(a+1,a+n+1,cmp); //排序
	int x=a[int(m*1.5)].s; //注意向下取整，int 会自动向下取整
	cout<<x<<' '; //输出分数线
	for(int i=n;i>=1;i--){
		if(a[i].s>=x){
			j=i;
			break; //注意 break，不然会出错
		}
	}
	cout<<j<<endl; //输出被录取的人数
	for(int i=1;i<=j;i++) cout<<a[i].k<<' '<<a[i].s<<endl; //依次输出被录取的人的考号及分数
	return 0;
} //点赞评论再走吧，管理员求过QWQ

```
[AC记录](https://www.luogu.com.cn/record/199096026)

#### 完结撒花！！！

---

## 作者：ryf2011 (赞：6)

# 题目思路
我们根据题意模拟。

用一个结构体，存储每个人的编号以及成绩。输入完成后，对结构体排序时，先比较两者成绩，成绩高的在前，如果成绩相等，则编号小的在前。

最后计算同分。定义一个计数变量，如果出现一个同分，变量就加 $1$。最后按照格式输出即可。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,lq,cnt; //lq:录取人数；cnt:与录取分数线同分的人还有几个 
struct node{
	int k,s;
} p[5005]; //结构体，存储每个人的编号和成绩 
bool cmp(node a,node b){ //cmp 比较函数 
	if(a.s==b.s){ //如果两人成绩相等，编号小的在前 
		return a.k<b.k;
	} 
	else{
		return a.s>b.s;
	}
}
int main(){
	//输入 
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d %d",&p[i].k,&p[i].s);
	}
	sort(p+1,p+n+1,cmp); //用 cmp 函数排序 
	lq=m*15/10; //用 m*15/10 表示 m*150% 
	for(int i=lq+1;i<=n;i++){
		if(p[i].s==p[lq].s){ //如果出现同分，cnt+1 
			cnt++;
		}
	}
	//输出 
	printf("%d %d\n",p[lq].s,lq+cnt);
	for(int i=1;i<=lq+cnt;i++){
		printf("%d %d\n",p[i].k,p[i].s);
	}
	return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：WsW_ (赞：2)

### 思路
按照题意模拟。  
首先算出计划进入面试的志愿者人数 $t=\lfloor m\times 1.5 \rfloor$。  
接着把所有志愿者按成绩排序。注意，需要把成绩和报名号绑定到一起后排序，这个过程可以使用结构体或者 STL 中的 `pair` 容器。排序后，就可以求得分数线为 $s_t$。  
统计有多少个人的成绩达到了 $s_t$ 并按排序后顺序输出即可。  

时间复杂度为 $O(n\log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum;
struct node{
	int h,f;
};
node p[5005];
bool cmp(node x,node y){
	if(x.f!=y.f)return x.f>y.f;
	return x.h<y.h;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d%d",&p[i].h,&p[i].f);
	sort(p+1,p+n+1,cmp);
	m*=1.5;
	for(int i=1;i<=n&&p[i].f>=p[m].f;i++)sum++;
	printf("%d %d\n",p[m].f,sum);
	for(int i=1;i<=sum;i++)printf("%d %d\n",p[i].h,p[i].f);
	return 0;
}
```

---

## 作者：yanghaoyu123 (赞：1)

# [P1068 [NOIP2009 普及组] 分数线划定](https://www.luogu.com.cn/problem/P1068)

### 思路

可以求出有几个人可以通过，之后进行排序，只要人数大于等于通过人数，就将分数线划定，之后继续比较看看有没有人的分数线跟划定的分数线相等，如果相等就也算通过。

### Code


```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][2];
    for (int i=0;i<n;i++){
        for (int j=0;j<2;j++){
            cin>>arr[i][j];
        }
    }
    m=floor(m*1.5);
    for (int i=0;i<n;i++){
        for (int j=i+1;j<n;j++){
            if (arr[i][1]>arr[j][1]){
                int s=arr[i][1];
                arr[i][1]=arr[j][1];
                arr[j][1]=s;
                int s1=arr[i][0];
                arr[i][0]=arr[j][0];
                arr[j][0]=s1;
            }
            else if (arr[i][1]==arr[j][1]){
                if (arr[i][0]<arr[j][0]){
                   int s=arr[i][1];
                    arr[i][1]=arr[j][1];
                    arr[j][1]=s;
                    int s1=arr[i][0];
                    arr[i][0]=arr[j][0];
                    arr[j][0]=s1;
                }
                else{
                    continue;
                }
            }
            else{
                continue;
            }
        }
    }
    int c=0;
    int f=0;
    for (int i=n-1;i>=0;i--){
        c+=1;
        if (c==m){
            f=arr[i][1];
            for (int j=i-1;j>=0;j--){
                if(arr[j][1]==arr[i][1]){
                    m+=1;
                }
            }
        }
    }
    cout<<f<<" "<<m<<endl;
    for (int i=n-1;i>=0;i--){
        if (arr[i][1]>=f){
            cout<<arr[i][0]<<" "<<arr[i][1]<<endl;
        }
    }
    return 0;
}

```

---

## 作者：Loyal_Soldier (赞：1)

### 思路

我们首先要对每个选手的成绩从大到小排序，然后算出分数线，分数线就是第 $\lfloor {m\times 150\%}\rfloor$（将 $m\times 150\%$ 向下取整）名的成绩。算出分数线后，我们遍历一遍 $1\sim n$，判断当前选手的成绩是否达到分数线，如果达到了，进入面试的选手数量就加一，遍历完我们就输出分数线和进入面试的选手数量，然后我们再遍历一遍，如果当前选手的成绩达到了分数线，则输出当前选手的报名号与成绩。

注意，排序时如果两个人的成绩相同，报名号小的在前。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct node{
    int id;//id表示报名号
    int cj;//cj表示成绩
}a[114514];//定义储存每个选手信息的结构体
bool cmp(node a,node b){
    if(a.cj==b.cj)
        return a.id<b.id;
    return a.cj>b.cj;
}//排序函数
int fsx,sum;//fsx表示分数线，sum表示进入面试的选手数量
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i].id>>a[i].cj;
    sort(a+1,a+n+1,cmp);//排序
    int x=m*1.5;
    fsx=a[x].cj;//计算分数线
    for(int i=1;i<=n;i++)
        if(fsx<=a[i].cj)//如果当前选手的成绩达到了分数线
            sum++;//进入面试的选手数量加一
    cout<<fsx<<' '<<sum<<endl;//输出分数线和进入面试的选手数量
    for(int i=1;i<=n;i++)
        if(fsx<=a[i].cj)//如果当前选手的成绩达到了分数线
            cout<<a[i].id<<' '<<a[i].cj<<endl;//输出当前选手的报名号和成绩
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：1)

## 思路

可以用结构体来做。

- 如果相比的两个数的成绩不同，就按成绩来从大到小排序。否则就按报名号来从小到大排序。

- 分数线是第 $1.5m$ 名选手的成绩，然后再去成绩中去统计大于等于分数线的人数。

- 最后再按照进入面试的选手，分别输出报名号和成绩。

### 排序关键代码：

```cpp
bool cmp(stu a,stu b){
	if(a.s!=b.s){
		return a.s>b.s;
	}else{
		return a.k<b.k;
	}
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct stu{
	int k,s;
}a[5005];
bool cmp(stu a,stu b){
	if(a.s!=b.s){
		return a.s>b.s;
	}else{
		return a.k<b.k;
	}
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].k>>a[i].s;
	}
	sort(a+1,a+1+n,cmp);
	int t=m*1.5;
	int cnt=a[t].s;
	int sum=0;
	for(int i=1;i<=n;i++){
		if(a[i].s>=cnt){
			sum++;
		}
	}
	cout<<cnt<<' '<<sum<<endl;
	for(int i=1;i<=sum;i++){
		cout<<a[i].k<<' '<<a[i].s<<endl;
	}
	return 0;
}
```

---

## 作者：wangshengchen (赞：1)

### 题意分析

找出分数线和进入面试的选手的实际人数，并输出进入面试的选手的信息。

## 思路

- 如果分数一样按报名号从小到大排序，不一样按分数从大到小排序。
- 算出分数线用 $s$ 存储。
- 遍历数组，记录进入面试的选手的实际人数。
- 输出答案。

#### Code

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=5005;
struct stu{
	int num,score;
}player[maxn],pass[maxn];
int n,m,k=0,s=0,passi=0;
bool cmp(stu a,stu b){//如果分数一样按报名号从小到大排序，不一样按分数从大到小排序
	return a.score==b.score?a.num<b.num:a.score>b.score; 
}
int main(){
	cin>>n>>m;
	k=m*3/2;//k=m*150%
	for(int i=1;i<=n;i++) cin>>player[i].num>>player[i].score;//输入
	sort(player+1,player+n+1,cmp);//排序
	s=player[k].score;//s记录分数线
	for(int i=1;i<=n;i++) if(player[i].score>=s) passi++;//如果过了，人数+1
	cout<<s<<" "<<passi<<endl;//输出分数线和进入面试的选手的实际人数
	for(int i=1;i<=n;i++) if(player[i].score>=s) cout<<player[i].num<<" "<<player[i].score<<endl;
	return 0;
}
```

---

## 作者：kunkun127 (赞：1)

## 思路

这题也是考察结构体排序和基本语法的题目。

首先，我们编写一个结构体，内容包含编号 $k$ 和分数 $s$。


```cpp
struct Man
{
	int id, s;
};
Man a[5005];
```

然后进行排序时，我们还要编写一个比较函数。如题面所说：按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。


```cpp
bool cmp(Man x, Man y)
{
	if (x.s != y.s) return x.s > y.s;//不相等就直接按分数排序
	return x.id < y.id;//相等就按编号排序
}
```

最终，我们先输出分数线和录取人数（也就是最后一个人的编号），被录取的每个人的编号和分数。具体实现可根据代码理解。

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

struct Man
{
	int id, s;
};
Man a[5005];

bool cmp(Man x, Man y)
{
	if (x.s != y.s) return x.s > y.s;
	return x.id < y.id;
}

int main() 
{
	int n, m;
	cin >> n >> m;
	m = floor(m * 1.5);
	for (int i = 1; i <= n; i++) cin >> a[i].id >> a[i].s;
	sort(a + 1, a + n + 1, cmp);
	int endid, line;
	for (int i = 1; i <= n; i++)
	{
		if (a[i].s != a[i + 1].s && i >= m) 
		{
			line = a[i].s;
			endid = i;
			break;
		}
	}
	cout << line << ' ' << endid << endl;
	for (int i = 1; i <= endid; i++) cout << a[i].id << ' ' << a[i].s << endl;
	return 0;
}
```

---

## 作者：superLouis (赞：1)

## 题解：P1068 [NOIP2009 普及组] 分数线划定

就是纯模拟加排序啦。

----------
### 1. 解题思路
首先，每个人又两个信息，报名号和分数，由此我们想到用结构体。后面还要找前几名，所以排序也是必不可少的，我比较喜欢用重载小于号排序。

找到人数 $p$ 后（$m \times 1.5$ 下取整），先记录下分数线，随后在下标 $p+1$ 到 $n$ 的人中找到与分数线相同的分数就记录下来，并且 $p+1$。最后输出 $1$ 到 $p$ 的人即可。

----------
### 2. 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 5010;
int n, m;
struct node {
	int id, points;
	bool operator < (const node &r) const {
	    if (points == r.points) return id < r.id;
	    return points > r.points;
	}
} a[maxn]; 
inline int read() {
    register int x = 0, f = 1;
    register char c = getchar();
    if (c == '-') f = -1;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    n = read(); m = read();
    for (int i = 1; i <= n; i++) 
		a[i].id = read(), a[i].points = read();
    sort(a + 1, a + n + 1);
	int p = 1.5 * m, line = a[p].points, cnt = p;
	for (int i = p + 1; i <= n; i++) if (a[i].points == line) cnt++;
	cout << line << " " << cnt << "\n";
	for (int i = 1; i <= cnt; i++) cout << a[i].id << " " << a[i].points << "\n";
    return 0;
}
```

---

## 作者：langni (赞：0)

在这道题中，我们要把分数和编号绑在一起排序，所以要用到结构体。排好序后，再根据题目要求找到所需分数线即可。\
代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct st
{
    int k, s;
} a[5001];
bool cmp(st aa, st bb) //排序函数
{
    if (aa.s != bb.s)
        return aa.s > bb.s; //如果分数不相等，就把分数高的排在前面
    else
        return aa.k < bb.k; //否则把编号小的排在前面
}
int main()
{
    int m, n;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i].k >> a[i].s;
    }
    sort(a + 1, a + 1 + n, cmp); //排序
    int i;
    m *= 1.5; //计算判定的人的位置
    st x = a[m]; //记录下来
    cout << x.s << ' ';
    for (i = 1; a[i].s >= x.s; i++); //寻找分数大于或等于x的人的数量(也可以用二分)
    cout << i - 1 << endl; //由于多加了一次，所以要输出i-1
    for (i = 1; a[i].s >= x.s; i++) //循环输出进入面试的人
    {
        cout << a[i].k << ' ' << a[i].s << endl;
    }
    return 0;
}

```

---

## 作者：DeImage (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1068)

-----------
## 解题思路
这道题的思路很简单，只需要模拟 + 排序即可。

首先我们要求的是面试分数线以及进入面试的人数。由题意可知，面试分数线就是第 $\lfloor m \times 150\% \rfloor$ 名选手的分数。因此，我们可以先定义一个包含报名号和成绩的结构体数组对所有数据按分数从大到小排一下序，遍历所有数据找到第一个低于面试分数线的选手，在此之前的人数即最终进入面试的人数。  
该部分代码：
```cpp
struct Score {
    int k, s;  // s 为成绩，k 为报名号
} a[5001];
bool cmp1(const Score& A, const Score& B) {
    return A.s > B.s;  // 按成绩从大到小排序
}
``````
以及
````cpp
sort(a + 1, a + n + 1, cmp1);
int l = a[(int)(m * 1.5)].s, i;  // 面试分数线
for (i = 1; i <= n; i++)  // 进入面试人数判断
    if (a[i].s < l)
        break;
i--;
``````

第二，我们还要输出这些进入面试的选手的信息。我们可以对这些选手的成绩从大到小排序，如果成绩相同则按学号从小到大进行排序，最后再输出就可以了。  
该部分代码：
```cpp
bool cmp2(const Score& A, const Score& B) {
    if (A.s == B.s)  // 如果成绩相等
        return A.k < B.k;  // 按报名号从小到大排序
    return A.s > B.s;  // 按成绩从大到小排序
}
``````
以及
```cpp
sort(a + 1, a + i + 1, cmp2);  // 排序
for (int j = 1; j <= i; j++)
    printf("%d %d\n", a[j].k, a[j].s);
``````
-----------
### 因此，你们最爱的完整代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, m;
struct Score {
    int k, s;  // s 为成绩，k 为报名号
} a[5001];
bool cmp1(const Score& A, const Score& B) {
    return A.s > B.s;  // 按成绩从大到小排序
}
bool cmp2(const Score& A, const Score& B) {
    if (A.s == B.s)  // 如果成绩相等
        return A.k < B.k;  // 按报名号从小到大排序
    return A.s > B.s;  // 按成绩从大到小排序
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &a[i].k, &a[i].s);
    sort(a + 1, a + n + 1, cmp1);
    int l = a[(int)(m * 1.5)].s, i;  // 面试分数线
    for (i = 1; i <= n; i++)  // 进入面试人数判断
        if (a[i].s < l)
            break;
    i--;  // 记得减一
    printf("%d %d\n", l, i);
    sort(a + 1, a + i + 1, cmp2);  // 排序
    for (int j = 1; j <= i; j++)
        printf("%d %d\n", a[j].k, a[j].s);
    return 0;
}
``````

---

## 作者：Jerry_zpl (赞：0)

本题算法：排序，模拟。  
难度建议：红。  
本题比较简单，思路如下：
- 我们可以先把所有人的分数从大到小排序，确定所有人的录取分数线。
- 然后我们把分数线输出，再枚举所有人的分数，找出录取人数并输出。
- 输出录取的人，编号为 $1$ 到 $cnt$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int num;
	int s1;
};
bool cmp(node a,node b)
{
	if(a.s1!=b.s1) return a.s1>b.s1;    
	else return a.num<b.num; 
}
int main()
{
	int n,m;
	cin>>n>>m;
	node s[5005];
	int i,p,t,dian;
	for(int i=1;i<=n;i++)  cin>>s[i].num>>s[i].s1; 
	sort(s+1,s+1+n,cmp);
	p=m*150/100;
	t=s[p].s1; 
	for(int i=1;i<=n;i++)
	{
		if(s[i].s1<t)
		{
			dian=i-1;
			break;
		}
	}
	cout<<t<<" "<<dian<<endl;
	for(int i=1;i<=dian;i++)
	{
		cout<<s[i].num<<" "<<s[i].s1<<endl;
	}
} 
```

---

## 作者：ylzpl (赞：0)

首先我们可以将每个人的分数从高到低排序，然后就可以确定分数线为 $a_{m \times 1.5}$。知道分数线后，我们就可以枚举每个人的分数，用计数器统计一共有多少个人可以录取，输出人数。然后再把能录取的人的编号输出即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
	int fenshu, id;
}a[5005];

bool cmp(node x, node y){
	if(x.fenshu != y.fenshu)
		return x.fenshu > y.fenshu;
	return x.id < y.id;
}
int n, m, cnt;
int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		cin >> a[i].id >> a[i].fenshu;
	sort(a+1, a+n+1, cmp);
	int num = m * 1.5;
	int fsx = a[num].fenshu;
	for(int i = 1; i <= n; i++)
		if(a[i].fenshu >= fsx)
			cnt++;
	cout << fsx << " " << cnt << endl;
	for(int i = 1; i <= n; i++)
		if(a[i].fenshu >= fsx)
			cout << a[i].id << " " << a[i].fenshu << endl;
	return 0;
}
```

---

## 作者：Eason_lyx (赞：0)

我来写一波结构体数组的题解。
### 题目分析
由于一个选手有多余一个信息要处理，故使用结构体，并对其排序。先排序，以分数倒序为第一关键字，编号正序为第二关键字。然后依照题面划定分数线。接着从高到低依次录取，并计算人数。最后输出。

还不懂？看代码注释！

### 代码
#### 注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
struct M{
    int k,s;//编号 分数
}a[5005];//结构体数组，表示每位选手
bool cmp(M a,M b){//比较函数，以分数倒序为第一关键字，编号正序为第二关键字
    if(a.s!=b.s)return a.s>b.s;
    return a.k<b.k;
}
int n,m,sc,cnt;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i].k>>a[i].s;
    }
    sort(a+1,a+n+1,cmp);//排序
    sc=a[(int)(1.5*m)].s;//划定分数线
    while(a[cnt+1].s>=sc)cnt++;//由高到低录取
    printf("%d %d\n",sc,cnt);//输出分数线与人数
    for(int i=1;i<=cnt;i++){//输出
        printf("%d %d\n",a[i].k,a[i].s);
    }
    return 0;
}
```

#### 无注释版
```cpp
#include<bits/stdc++.h>
using namespace std;
struct M{
    int k,s;
}a[5005];
bool cmp(M a,M b){
    if(a.s!=b.s)return a.s>b.s;
    return a.k<b.k;
}
int n,m,sc,cnt;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i].k>>a[i].s;
    }
    sort(a+1,a+n+1,cmp);
    sc=a[(int)(1.5*m)].s;
    while(a[cnt+1].s>=sc)cnt++;
    printf("%d %d\n",sc,cnt);
    for(int i=1;i<=cnt;i++){
        printf("%d %d\n",a[i].k,a[i].s);
    }
    return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/199081124)。

---

## 作者：sjh0626 (赞：0)

## 思路分析
一道模拟题，我们要用一个结构体去存储报名号和成绩，然后自定义排序去排一遍，再根据题意模拟计算分数线，然后再循环判断有多少人大于分数线就行了。

对于结构体的模板：
```cpp
struct XXX{
   int a,b; 
}
```
## 代码解析
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt=0,nm;
struct xxx{
	int k,d;
}s[10010];
bool cmp(xxx a,xxx b){
	if(a.d!=b.d)return a.d>b.d;
	return a.k<b.k;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s[i].k>>s[i].d;
	}
	sort(s+1,s+n+1,cmp);
	nm=m*1.5;
	for(int i=1;i<=n;i++){
		if(s[i].d<s[nm].d){cnt=i;break;}
	}
	cout<<s[nm].d<<" "<<cnt-1<<endl;
	for(int i=1;i<=n;i++){
		if(s[i].d>=s[nm].d)cout<<s[i].k<<" "<<s[i].d<<endl;
	}
}
```

---


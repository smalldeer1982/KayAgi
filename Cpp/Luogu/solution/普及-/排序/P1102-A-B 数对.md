# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# 题解

## 作者：OsvaldoAsensioLopez (赞：787)

这一题将A-B=C转换成A-C=B，首先将A数组每个元素出现的次数统计起来，用map映射，最后将A数组每次减一个C，再将A数组扫一遍，将所有映射的次数和加起来就是答案

    
    
    
```cpp
    #include <iostream>
    #include <map>
    using namespace std;
    typedef long long LL;
    LL a[200001];
    map<LL,LL> m;//建立一个数字到出现次数的映射 map<num,times>
    //A-B=C --> A-C=B
    int main() {
        int n;
        LL c;
        LL ans=0;
        cin >> n >> c;
        for(int i=1;i<=n;i++) {
            cin >> a[i];
            m[a[i]]++;
            a[i]-=c;    
        } 
        for(int i=1;i<=n;i++) ans+=m[a[i]];
        cout << ans << endl;
        return 0;
}
```

---

## 作者：樱花飞舞 (赞：536)

这道题有一个用二分的神奇做法。
### Q1:什么是lower_bound/upper_bound?
这两个函数是STL中用于二分查找的两个函数，用法：
假定我们有一个有序的数组$a$，并将数$x$作为二分查找的目标，那么：
```cpp
lower_bound(a,a+n,x)-a      //下标从0开始
lower_bound(a+1,a+n+1,x)-a  //下标从1开始

```
它们就能取得最小的$a$数组的下标$i$，满足$a_i \geqslant x$。


```cpp
upper_bound(a,a+n,x)-a      //下标从0开始
upper_bound(a+1,a+n+1,x)-a  //下标从1开始

```
它们就能取得最小的$a$数组的下标$i$，满足$a_i > x$。


------------
那他如何来解这道题呢？

我们发现，如果这个数组是有序的，那么对于每一个$A$的值，在它的后方就只有一个数值$B$满足$A,B$的差值为$C$。

这时我们只需要使用两个函数求出数组中对于每个$A$,$A+C$的这两个位置，它们的差即为数组中数值为$A+C$的元素个数。将这个数加到ans中。
```cpp
for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
```

同时这样也有效避免了重复，因为只向后方查找。

输入的数据是无序的，我们只需要运算之前一遍`sort`即可。

总复杂度是$O(NlogN)$的。（两个函数的复杂度为$logN$）

最后贴上AC代码（没开O2）
```
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```





---

## 作者：jins3599 (赞：458)

明明是一道双指针的好题...怎么题解里面全是暴力$map$

我们考虑题目要求求出所有`A-B=C`的数对，我们可以先将原数组排序，然后就会发现每个数$A$，对应的数$B$一定是一段连续的区间。

然后我们再考虑如何去找到这个区间。

我们显然是要找到这个连续区间的左端点和右端点。

考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是**单调不降**的，因此我们可以用$\text{two-pointers}$，也就是双指针来维护这个东西。

具体的实现就是，我们维护两个右端点$r1$ , $r2$，每次$r1$右移到`a[r1] - a[l] <= c`的最后位置的下一位，$r2$右移到满足`a[r2] - a[l] < c`最后一位.

也就是说，
此时如果`a[r2] - a[l] == c && a[r1 - 1] - a[l] == c`，中间的那一段一定都是满足条件的，我们让`ans += r1 - r2`即可。

代码很简洁。

$Code:$

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Ajwallet (赞：140)

这题用$HASH$~~**的题解好像只有一个放了代码的**~~
# 思路
## $O(n^2)$思路
楼下的题解讲的很清楚，就是将$A-B=C$变成$A=B+C$，朴素的算法是一个二重循环，当然我们知道这肯定会超时的。

## $O(nlogn)$思路

利用二分，一遍循环枚举找$B$，中间二分找$C$，时间复杂度$O(nlogn)$，可以通过本题

也可以利用$stl$中自带的红黑树$map$达到$AC$的效果

## $O(n)$思路
优化一点的算法呢则是用桶去保存每个数，这样我们就只需要枚举$B$，然后判断一下$C$存不存在就行了，这样的时间复杂度是$O(n)$，当然此算法空间复杂度很高会$MLE$

# 正题
好吧，前面讲了这么多都是为了告诉你各算法的优缺点，自然在目前来看，$HASH$解法是最优秀的（除了打表），那么具体怎样实现呢？

# 实现
前面讲$O(n)$算法的时候，讲过用桶去做，这样的代价是用空间换时间，需要的空间代价是极高的，而$HASH$就是避免了这一点。

其实我们可以发现，桶数组中是有很多桶是没有用到的，也就是浪费了空间，比如有4个数

2 4 7 10001

用桶你就必须得开一个10001的数组，而用$HASH$只需要开一个长度为4的数组，它们的位置分别为

2%4=2 4%4=0 7%4=3 10001%4=1

在$HASH$表中表示为

 $0\ 1\ \ \ \ \ \ \ \ \ 2\ 3\ $
 
 $4\ 10001\ 2\ 7$

明白了吗？其实就是%一个数而已，若%的过程中，这个位置已经有数了，那么就放在它的后面就行了，以此类推。

需要注意的是统计数量，本人的处理方法使用结构体保存数量（即出现相同解的时候）

最后放一个$HASH$例题给你们可以去做一下，那道题本人也写了题解，[洛谷P4305 不重复数字](https://www.luogu.org/problemnew/show/P4305)
# 代码
```cpp
#include<cstdio>
#define p 1000003//这个数越大就越好，最好是质数，这样冲突会减少，但至少要大于200000才行，这里1000003可以轻松AC
#define hash(a) a%p//hash函数
using namespace std;long long n,m,a[p],ans;
struct node
{
	long long x;int y;//x为这个位置对应的数，y为这个数出现了几次
}h[p];
long long abs(long long x){return x<0?-x:x;}//绝对值
int find(long long x)//找到x的位置
{
	int y=hash(abs(x));//因为x可能是负数，所以要abs
	while(h[y].x&&h[y].x!=x) y=hash(++y);
	return y;
}
void push(long long x){int y=find(x);h[y].y++;h[y].x=x;}//先找到此数在hash表中的位置，并将这个位置对应的数量+1，并且将数放进去
int check(long long x){return h[find(x)].y;}//输出这个数在hash表中出现的次数
int main()
{
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++) scanf("%lld",&a[i]),push(a[i]);//输入并放入
	for(long long i=1;i<=n;i++) ans+=check(a[i]-m);//统计
	printf("%lld",ans);//输出
}
```
$updata:$对于$map$的时间复杂度给各位造成了困扰，因为$map$内部是由一棵红黑树构造的，所以应该是$logn$

---

## 作者：Cambridge (赞：106)


小学生又来发题解了！

这道题初看，大家可能认为是暴力枚举。其实不然，请看一眼数据：对于100%的数据，200000N≤200000。，那么大呀，用什么暴力？看了楼下的大佬用了数组计数，真心很简洁。那本蒟蒻就来讲讲二分查找吧。首先，我们讲一下一个样例（不是题目的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/vg7uimkf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)			
我们再转换一下思路：

	A-B=C也等于B+C=A也等于C+B=A		
    
这时候好像二分查找这个算法已经显现出来了，那我们再想思路，就想到两种方法：

![](https://cdn.luogu.com.cn/upload/image_hosting/ur43uuax.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

找到了结论，代码就很容易打了。我们用两个函数分别查找查找小于等于a[i]-C的数和查找小于a[i]+C的数，再用一个变量累加它们的和，最后输出即可。

    #include<iostream>
    #include<cstring>
    #include<cstdio>
    #include<cmath>
    #include<string>
    #include<cstdlib>
    #include<algorithm>//文件头不解释
    using namespace std;
    long long n,x,h;
    int a[1000000];//定义
    int find1(int x)//找小于等于a[i]-C的数的函数
    {
    int l=0,r=n+1,mid;				
        while(l+1<r)			
        {			
            mid=(l+r)/2;		
            if(a[mid]<=x)l=mid;		
            else r=mid;		
        }			
        return l;			
    }
    int find2(int x)//找小于a[i]-C的数的函数
    {
    int l=0,r=n+1,mid;				
        while(l+1<r)			
        {			
            mid=(l+r)/2;		
            if(a[mid]<x)l=mid;		
            else r=mid;		
        }			
        return l;			
    }
    int main()
    {
    cin>>n>>x;
    for(int i=1; i<=n; i++)
    {
        cin>>a[i];//读入
    }
    sort(a+1,a+1+n);//用二分数组要有序
    for(int i=1; i<=n; i++)
    {
        h+=find1(a[i]+x)-find2(a[i]+x);//每次累加差
    }
    cout<<h;//输出
    return 0;//结束程序（要养成后习惯）
    }

好了，本蒟蒻就讲到这里，希望对读者有所帮助。如果上方图片模糊，私聊我 ~~逃~~


---

## 作者：Drifterming (赞：74)

楼下的都是用的二分查找，我用二分查找做了一次。   但我的A-B数对的代码也能AC，没有ＴＬＥ，挺黑科技的。


/\*map求解。将没一个数字映射到map中，答案每次加上num[i]+c位置的数的个数，num[i]+c即为式子的另一个加数\*/




```cpp
#include<iostream>
#include<cstdio> 
#include<cmath>
#include<map>
#include<algorithm>
using namespace std;
int n,c;
long long ans;
map<int,int> a;
int num[200005];
int main()
{
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&num[i]);
        a[num[i]]++;    //当前数的个数++ 
    }
    for(int i=1;i<=n;i++)
    {
        ans+=a[num[i]+c];    //答案+=相差为c的数的个数，即a[num[i]+c]位置的数的个数 
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：onepeople666 (赞：58)


**map 映照容器可以解决这一题**

首先，我们来了解一下 map 是个什么东西：

- map 映照容器在头文件<map>中定义，它的元素数据是由一个键值和一个映照数据组成的，键值和映照数据具有一一对应的关系，键值可以是数，也可以是字符。
 例如：


------------

       键值    映照数据
      (name)   (score)
       Alice      98  
       Mary       96
       156        66

------------
在没有指定比较函数时，元素是从小到大插入的。比较函数只对键值进行比较，元素的各项数据可以通过键值检索出来。
  

------------
对于这一道题，我们可以把 A-B=C 改成 B+C=A，再通过 map 进行映照，就可以得出答案。
  
  **code:**
  ```cpp
#include <bits/stdc++.h>//万能头文件,不用调用头文件<map> 
using namespace std;
int main()
{
  long long n,c,co=0; //要开long long,否则会 WA 一个数据点 
  cin>>n>>c;
  int a[n+1];
  map<int,int> b;//键值和映照数据都是 int 类型 
  for(int i=1; i<=n; i++)
  {
    cin>>a[i];
    b[a[i]]++;
  }
  for(int i=1; i<=n; i++)
    co+=b[a[i]+c];//反向思维,枚举 B+C
  cout<<co<<endl;
  return 0;
}

```


---

## 作者：ysj1173886760 (赞：47)

看到数据规模后就应该想到是nlogn的算法或者n的，O(n)复杂度的算法可能不太好想，毕竟题中没有给规定数的大小，只是longint，这样如果是桶的思想可能就会爆掉，那么对于A-B=C这个式子来说，两个变量都在等号同侧，这样只能n方枚举，肯定T，那么我们考虑移项，则有A-C=B，这样两边分别都含变量，我们每次枚举A，这样问题就转换为寻找数组中元素为A-C的个数，白皮书上很明确的提到过这一技巧。二分即可。

这里再复述一遍lower_bound和upper_bound的作用，都是stl中的函数，内部实现是二分。

我们粘出他们的内部实现分析（只粘了部分）
```cpp
lower_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
```
可以看到参数就是四个，代表数组开头的迭代器（理解为指针），代表数组结尾的迭代器，一个常量_val，还有就是类似sort的compare函数。一般我们不使用第四个参数。
这里我再次粘出algobase中对这两个函数的解释:
```cpp
  *  @brief Finds the first position in which @p __val could be inserted
  *         without changing the ordering.
  *  @brief Finds the last position in which @p __val could be inserted
  *         without changing the ordering.
   ```
  分别是lowerbound和upperbound的brief。
  最终return的是
  ```cpp
   *  @return An iterator pointing to the first element <em>not less
   *  than</em> @p __val, or end() if every element is less
   *  than @p __val.or end() if no elements are greater than @p __val.
   
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
  ```
  所以通俗一点（看结论了哈）
  ```cpp
  lower_bound(a,a+n,val)
  lowerbound函数返回的是有序数组a中满足a[i]>=val的最小指针。
  
  upper_bound(a,a+n,val)
  upperbound函数返回的是有序数组a中满足a[i]>val的最小指针。
  
  那么在查询数组a中元素值为val的个数就是
  upper_bound(a,a+n,val)-lower_bound(a,a+n,val)
  大于这个元素的最小指针减去等于这个元素的最小指针就是这个元素的个数（一定要有序）
  ```
  说了这么多
  
  最后的代码
  ```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long a[200010],n,c,ans;//这里注意ans要存long long，其他的存不存无所谓。否则第三个点会错。
int main()
{
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);	//读入
	sort(a+1,a+1+n);//注意要对这个数组进行排序，因为我们不知道他是否有序
	for(int i=1;i<=n;i++)
	{
		int k=a[i]-c;		//像上面说的，找到数组中A-C的个数。
		ans+=upper_bound(a+1,a+1+n,k)-lower_bound(a+1,a+1+n,k);//刚才提到的技巧
		if(a[i]-c==a[i])k--;//这里注意是数对，如果c等于零的话，二分时就会把自己也算进去，但是实际上是不可以的，所以要减去1.
	}
	printf("%lld",ans);
	return 0;
}
  ```
  
  看在我这么用心的写题解的份上，给我过了吧qaq

---

## 作者：lemondinosaur (赞：36)

### **~~copy一下~~**
### **题目是这样的：给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对）**
特别是后面这句话特别重要，它告诉我们重复是算的、
A-B=C 那么 A-C=B 所以就把A的个数累加，然后把A减去C就可以了，B的值的和就是答案。
当然内存才是最重要的。所以就找到了一个map
这样就简单的表达出来了
```
#include <cstdio>
#include <map>
using namespace std;
map <int,int> boo;
int c,n,a[200001];
long long s;
int main(){
    scanf("%d%d",&n,&c);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        boo[a[i]]++; a[i]-=c;
    }
    for (int i=1;i<=n;i++) s+=boo[a[i]];
    printf("%lld",s);
}
```



---

## 作者：Edmundino (赞：23)

这是一道很坑的题目

有两个新增的数据导致许多人做不出来

一开始我是用数组的下标来做的，也就是下面一些大佬的做法

但是怎么做总会有两个测试点re

于是我开始使用队列

在使用前，我们要用sort来给那堆数排序

然后让一个个数进入队列

这个时候第一个参数就是记录看到底有多少个重复一样的用p表示

p表示的不是当前跟自己重复的是多少个，比如题目给的序列是1 1 2 3，那么看到2的时候p记录的是前面 1 有2个重复

这个时候判断2-1=1，那么答案就加2


如果是1 1 1 2 3，那么循环到第四个数字2的时候，答案就加3

如果是1 1 1 2 2 3，循环到第四个答案加3，循环到第五个数字，发现它和前面一样，也加3

然后，我们需要一个新的队列，如果当前数字和前一个一样，那么我们就每一个1都加入队列

知道遇到跟前一个不一样的，比如 1 1 1 2 3，这个时候遇到2，队列里面有三个数字 1 1 1

那么只要这个队列不为空，就从队列头看起，如果 2 - 队列头 = 1那就 p++

比如 1 1 1 4 5 5 6

循环到4，发现队列头小于3

那么把队列头一个一个弹出

弹出的时候p没有加加，然后队列就弹完了

之前那个如果是1的p加加之后还是要继续弹出队头

然后 2也得进队

也就是说我们的总体思想是，每一个元素都进队

但是如果你和前面的元素一样，就不需要执行什么判断了

如果你和前面的元素不一样，这个时候就要执行判断，看看排在你前面的队头有多少个跟你相差1

前面比你小的刚好1的判断完就全部弹出去了

或者如果前面全部没有刚好是1，那就弹到你之前没有数字

相当于队尾进一个数字，就看看要不要把前面的人推出去

这种思想去找答案

最后送上AC代码

```cpp
//P1102
#include<iostream>
#include<algorithm>
using namespace std;
long long int n,c,s=0,zs[2000010],a[2000010],front=0,reat;
int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	
	sort(a+1,a+n+1); 
	zs[0] = a[1];
    reat=1;
   	long long p=0;
	for(int i=2;i<=n;i++)
	{
		  if(a[i]==a[i-1])
		  {
		  	s += p;
		  	zs[reat]=a[i];
		  	reat++;
		  }  
		  else
		  {
		  	while(front<reat && zs[front]<a[i]-c)
		  	{
		  		front++;
			}
			p = 0;
			while(front<reat && zs[front]==a[i]-c)	
			{
				p++;
				front++;
			 } 
			zs[reat]=a[i];
			reat++;
			s += p;
		  }
	}
	cout<<s;
	return 0;
}
```


---

## 作者：FlierKing (赞：14)

这题完全可以用map过

mp[i]表示i出现的次数，所以答案就是所有mp[v[i]]\*mp[v[i]-c]之和，加一次后记得将mp[v[i]]清0就可以避免重复计算

不得不吐槽一下这道题的数据，如果数据是

200000 1

100000个1 100000个2

那么答案是会爆int的，所以这道题的ans要开long long

然而……出题人并没有这种数据


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#define ll long long
using namespace std;
    int n,c;
    int v[200010];
    map <int,int> mp;
    ll ans;
int main()
{
    scanf("%d%d",&n,&c);
    for (int i=1;i<=n;i++)
    { 
        scanf("%d",&v[i]);
        mp[v[i]]++;
    } 
    sort(v+1,v+n+1);
    for (int i=n;i>=1;i--)
        if (mp[v[i]]&&mp[v[i]-c]) 
        {
            ans+=mp[v[i]]*mp[v[i]-c];
            mp[v[i]]=0;
        }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：百里亦守约_test (赞：14)

这一题佷简单，但是事先说明一点，用a-b数对的升级版提交会变成零分，所以我们必须用一个新方法来做这一道题，我是用数组计数的：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int big,n,c,s;
int a[1000000],b[1000000];    //数组要大。
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        b[a[i]]++;     //数组计数，判断数出现了几个次数。
        if(a[i]>big) big=a[i];
    }
    for(int i=1;i<=big;i++)
    {
        if((b[i]>0)&&(b[i+c]>0)) s=s+b[i]*b[i+c];     //判断是否可以组成a-b数对，如果可以的话就是两个数的次数的乘积。
    }
    cout<<s;    //输出。
    return 0;
}
```

---

## 作者：封禁用户 (赞：11)

#一看到题目描述，我心想：水题

#可一看到数据量好大，毫不犹豫使用了二分查找

#相信大家已经知道题目的意思

#看看别人的题解，用不着这么麻烦

#下面，我的程序：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,k,a[100005],shu,s1,s2,gs,to;
int main()
{
   scanf("%d%d",&n,&k);
   for(int i=1;i<=n;i++)scanf("%d",&a[i]);
  //上面我就不说了，反正大家也明白
 //下面才是重点
   for(int i=1;i<=n;i++)
   {
     int low=i+1,high=n;
        shu=a[i]+k;
         while(low<=high)
         {
             int mid=(low+high)/2;
             if(a[mid]<shu)low=mid+1;else high=mid-1;
         }
     //上面的二分查找用来找比被减数小的
         s1=low;
         low=i+1,high=n;
         while(low<=high)
         {
             int mid=(low+high)/2;
             if(a[mid]<=shu)low=mid+1;else high=mid-1;
         }
     //上面的二分查找用来找比被减数小、等于的
         s2=low;
         gs=gs+(s2-s1);//再用被减数小、等于的减去被减数小的，就等于被减数等于的，也就是方案数
   }
   cout<<gs;
   return 0;  
}
```

---

## 作者：sky_fackr (赞：10)

~~这么弱的题目本弱偷偷上传个题解试下博客应该不会被学校那群巨佬发现吧~~

首先根据小学奥数，将公式**A-B=C**转换为**A-C=B**，这样接下来会好找

题目说明**不同位置的数字一样的数对算不同的数对**，因此假设成立的一对数 _A,B_ ，则每个A都可以和每个B进行一次配对，可知公式： _**ans=num[A] x num[B]** _ 

代入**A-C=B**，得到：

```cpp
ans+=num[A]*num[A-C]
```

由于数字特别大，这里用map进行映射，同时用一个队列number记录每个出现的数字

当a-c的数字本身不存在的时候，数组为0，不会对ans有任何影响，即可做到排除

**记住，一定要开longlong，别问我怎么知道的**~~我是不会说某个点答案数字有11位的~~


------------

给出正片

```cpp
#include<bits/stdc++.h>
#include<queue>
using namespace std;
map<long long,long long> num;
queue<int> number;
int n,i,j,c;
long long ans;
int main()
{
//	freopen("testdata.in","r",stdin);
	cin>>n>>c;
	for (i=1;i<=n;i++)
	{
		cin>>j;
		if (num[j]==0) number.push(j);
		num[j]++;
	}
	while (!number.empty())
	{
		j=number.front();
		number.pop();

		if (j>=c) ans+=num[j]*num[j-c];
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：EarthGiao (赞：9)

## 【思路】
两种思路，用桶或者用双指针     
### 【桶】    
输入数据，用一个桶存一下     
然后从1枚举到最大值     
如果一个数出现过     
并且他减去c的数也出现过    
那么数对的数量就是     
这两个数的桶里面存的值乘起来    
最后加起来就好了     
### 【完整代码】
```cpp
#include<cstdio>
#include<iostream> 
#include<map>

using namespace std;

int a[200005];//桶存储每个出现过的数的次数 
map<int,int> tong;

int main()
{
	int n,c;
	scanf("%d%d",&n,&c);
	for(int i = 1;i <= n;++ i)
	{
		scanf("%d",&a[i]);
		tong[a[i]] ++;//计数 
	}
	long long js = 0;
	for(int i = 1;i <= n;++ i)
 	{//这里倒着想不去找两个数而是找一个然后再找另一个 
 		js += tong[a[i] + c];
	}
	printf("%lld\n",js);
	return 0;
 } 
```

### 【双指针】

双指针      
现将输入的那串数字排一下序     
然从以一个开始枚举    
头指针先不动    
尾指针累加知道尾指针所在的位置上面的数    
减去头指针所在的数的差大于等于c    
然后判断是否等于c    
如果等于c计数器累加    
   
不过这道题目会出现重复的数    
如果单纯的按照上面的方法是没法处理重复的数
所以可以在    
当你找到一组差恒等于c的数的时候    
判断一下大的后面还有没有也可以减去小的恒等于c的      
也就是等于大的的     
为什么不处理小的而是处理大的呢？     
因为我的思路是枚举小的所以小的都会扫一遍    
但是大的确实会跳过去的     
所以应该处理大的      

不过如果你处理出来有多少个和他相等的    
那就用一个桶记录一下     
到时候再一次用到的话直接O(1)查询就好     
不然会超时     

依次枚举下去      
因为头指针和尾指针都是只将那串数字扫一遍      
所以复杂度是线性的      

### 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
const int Max = 200005;
int a[Max];
int t[Max]; 
int main()
{
	int n,c;
	cin >> n >> c;
	long long js = 0;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i];
	sort(a + 1,a + 1 + n);
	for(register int l = 1,r = 1;l <= n;++ l)
	{
		while(a[r] - a[l] < c && r <= n)
			r ++;
		if(r > n)
			break;
		if(a[r] - a[l] == c)
		{
			int jj;
			if(t[r] != 0)
			{
				jj = t[r];
			}
			else
			{
				jj = 1;
				int rr = r + 1;
				while(a[rr] - a[l] == c)
					jj ++,rr ++;
				t[r] = jj;
			}
			js += jj;
		}
	}
	cout << js << endl;
	return 0;
}
```
## 【PS】
其实还有更简单的方法的        
思路说一哈：     
枚举大数A，用双指针法找到最靠前与A差≤ C的，和最靠后与A差≥ C的。如果这两个位置不是在同一个数上面，那么他们中间就是还有符合要求的数，所以这中间的数的个数（包括两个位置上面的）都累加起来。     
但是貌似实现起来很复杂，只想出来了思路没有去实现瞎搞了一下搞了上面的思路然后A掉了QWQ

---

## 作者：chy2003 (赞：8)

~~不明白为什么摆着STL不用……~~

此题对式子移项，得到$B=A-C$。我们只要枚举$B$，然后找满足条件的$C$的个数就好了。
先从小到大排序，统计的时候upper_bound-lower_bound即可。
记得Ans要开 long long

AC代码：
```C++
#include <bits/stdc++.h>
using namespace std;

int N, C, A[ 200010 ];

int main() {
	scanf( "%d%d", &N, &C );
	for( int i = 1; i <= N; ++i ) scanf( "%d", &A[ i ] );
	sort( A + 1, A + N + 1 );
	long long ans = 0;
	for( int i = 1; i <= N; ++i ) 
		ans += upper_bound( A + 1, A + N + 1, A[ i ] - C ) - 
			lower_bound( A + 1, A + N + 1, A[ i ] - C );
	printf( "%lld\n", ans );
	return 0;
}
```

---

## 作者：xuan__xuan (赞：6)

这题是用二分法解决的

分析题目我们知道，不能开数组去记录数的个数，不然会爆，但是呢会发现，不这么做的话，不好二分。

继续分析我们知道，开数组浪费了大量的空间，那为什么我们不能将这些空间舍去呢？当然用STL的map是完全可以的，我们还可以采用别的方法。

我么可以用一个结构体，记录数的种类，并同时记录种类个数，每个种类的个数，每个种类的数值；

假设一共有M种，故时间复杂度是O（MlogM），最坏情况也是当M = N的时候。

下面是代码：


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100005;
typedef long long LL;
int N,Num = 1;
LL data[MAXN],C,Ans = 0;
struct node{
    LL Tot;
    LL Val;
}Type[MAXN];
void Work(int x)
{
    int i = 1,j = x-1;
    while(i <= j)
    {
        int mid = (i+j) / 2;
        if(Type[x].Val - Type[mid].Val == C)
        {
            Ans += Type[x].Tot * Type[mid].Tot;
            break;
        }
        else if(Type[x].Val - Type[mid].Val > C)
            i = mid + 1 ;
        else
            j = mid - 1;
    }
}
int main(){
    scanf("%d%lld",&N,&C);
    Type[1].Tot = 1;
    for(int i = 1; i <= N; i++)
    {
        scanf("%lld",&data[i]);
        if(i > 1)
        {
            if(data[i] == data[i-1])
                Type[Num].Tot++;
            else
            {
                Type[++Num].Tot++;
                Type[Num].Val = data[i];
            }
        }
        else
            Type[Num].Val = data[i];
```
}//记录种数及其个数,并保存数值；
```cpp
    for(int i = 1; i <= Num; i++)
    {
        Work(i);
    } 
    cout << Ans << endl;
    return 0;
}
```

---

## 作者：高泽棵 (赞：6)

这道题用stl库里的map解决很快，只要把A-B=C转换成A-C=B，然后找这N个数里有几个B就解决了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read(int&n)//读入优化，不用理会
{
    n=0;int k=1;char ch=getchar();
    while(!('0'<=ch&&ch<='9')&&ch!='-')ch=getchar();
    if(ch=='-')k=-1,ch=getchar();
    while('0'<=ch&&ch<='9')n=n*10+ch-48,ch=getchar();
    return n=n*k;
}
map<int,int> mp;
int n,c,a[200010],i;ll s;//s不开LL会爆
int main(){
    read(n),read(c);
    for(i=n;i;i--)read(a[i]),mp[a[i]]++;//读入并记录a[i]的个数
    for(i=n;i;i--)s+=mp[a[i]-c];//加上B
    printf("%lld\n",s);
    return 0;
}
```

---

## 作者：用户已注销 (赞：5)

最好想的就是O(NlogN)的二分方法，此外还可以用迭代来做。

首先时间复杂度是O(N)，可以装逼（本题47ms，目测最快）

代码比较简单，思想也很简单

首先是把数据整理一下，因为数据排序好了所以这一步很简单

之后设置两个指针，分别指向左右，然后进行迭代

具体细节见代码内部

用了一些恶心的小技巧，缩到了24行（没有乱缩进！）

```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
#define re register
int num[100001],hmy[100001],top=1,n,c;//数字，出现次数，数字种数
long long ans=0;//最后答案数
int main()
{
    for(re int i=1;i<=100000;i++) hmy[i]=1;//比较弱，不知道memset能不能赋初值为1
    scanf("%d%d%d",&n,&c,&num[1]);//注意num[1]也在这里输入，这样是为了代码简短
    for(re int i=2;i<=n;i++)
    {
        scanf("%d",&num[top+1]);//暂时存在后一位 
        if(num[top+1]==num[top]) hmy[top]++;//如果和上一位一样，数量++ 
        else top++;//如果不一样，移位（此时数量已经是1） 
    }
    int lef=top-1,rig=top+1;//开始迭代，rig开始的时候会自行-1 
    for(;--rig;)//可以试验一下，循环次数实际上是rig-1，也就是top 
    {
        while(num[rig]-num[lef]<c and lef>0) lef--;//如果当前左值太大，往前移 
        if(num[rig]-num[lef]==c) ans+=hmy[rig]*hmy[lef];//如果恰好，计入答案 
    }
    return !printf("%lld\n",ans);
}/*时间复杂度O(N)*/
```

---

## 作者：pgz123 (赞：5)


    
        
```cpp
//这是一种c++的方法
#include<cstdlib>
#include<stdio.h>
#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstring>
#include<algorithm>
#include<math.h>
using namespace std; 
long long n,m,i,a[1000000],k,j,ma,key,k1,k2;
void s()//二分查找第一个大于等于某个数的下标
{
    int low = 0;  
    int high = n;  
    int mid = 0;  
    while (low <= high) {  
        mid = low + ((high - low) >> 1);  
        if (key <= a[mid]) {  
            high = mid - 1;  
        } else {  
            low = mid + 1;  
        }  
    }  
    k1=low;
}
void b()// 二分查找第一个大于某个数的下标
{
    int low = 0;  
    int high = n;  
    int mid = 0;  
    while (low <= high) {  
        mid = low + ((high - low) >> 1);  
        if (key < a[mid]) {  
            high = mid - 1;  
        } else {  
            low = mid + 1;  
        }  
    }  
    k2=low;  
}
int main() 
{
    cin>>n>>m;//输入整数的个数和差值
    for(i=1;i<=n;i++) scanf("%d",&a[i]);//输入N 个从小到大排好序的整数
    for(i=1;i<=n-1;i++)
    {
        key=a[i]+m;//key是二分查找的目标
        s();//二分查找第一个大于等于某个数的下标
        b();//二分查找第一个大于某个数的下标
        k+=k2-k1;//后面的下标减前面的下标，求出目标的个数再乘1（这里省略了）求出方案数，并累加
    }
    cout<<k;//输出
}
```

---

## 作者：十年若如一梦 (赞：5)

//这题就是经典的二分答案（变异二分查找）题目，我们只需我们要找的数的最左端和最右端的数，让他们相减，再加一，就是总个数了。

```cpp
var n,i,c,l,r,mid,z,l1,r1,zh:longint;
     a:array [0..100100] of longint;
begin
  readln(n,c);
  for i:=1 to n do read(a[i]);
  a[0]:=a[1]-1;a[n+1]:=a[n]+1;{第一个不同：为了不死循环，所以我们要在数组两端赋上两个不可能的值}[color=green]
  for i:=1 to n-1 do
    begin
      z:=c+a[i];
      l:=0;
      r:=n+1;{第二个不同：赋初值如果你按照普通二分查找写的话，你会错得很惨的~~~}[color=red]
      while l+1<r do
        begin
          mid:=(l+r) div 2;
          if a[mid]<z then l:=mid else r:=mid;{第三个不同：不能l:=mid+1和r:=mid-1原因很简单，自己想}[color=green]//这里是找最左边的
        end;
      l1:=0;
      r1:=n+1;
      while l1+1<r1 do
        begin
          mid:=(l1+r1) div 2;
          if a[mid]<=z then l1:=mid else r1:=mid;//这里是找最右边的
        end;
      zh:=zh+(l1-l);//这里我耍了一个小聪明，因为二分查找找完后，l是比r小1的，我没有用老方法l1-r+1而是用了l1-l（这句话是送给不熟练二分答案的蒟蒻们听的，为的是不误导，神犇直接忽视）
    end;
  writeln(zh);
end.
//其实这题可以用普通二分查找来做的，但是较二分答案，就显得比较麻烦了，所以我们做题当然要择优啦~~
//该程序时间复杂度为O（2·n·log2n），空间复杂度为O（n）。（该程序仅供参考）
```

---

## 作者：woshiren (赞：5)

数组计数法，仅仅适用于这种较弱的数据。

而且题目说明有问题……数据根本没有到longint的极限，所以大家不要被迷惑了。

```cpp

#include<iostream>
using namespace std;
int n,c,a[200005],b[10000000],sum;
int main()
{
    cin>>n>>c;//输入 
    for (int i=1;i<=n;i++)
    {
        cin>>a[i];
        b[a[i]]++;//数组计数，统计a数组里面数的出现个数 
    }
    for (int i=1;i<=n;i++)
    {
        if (a[i]<c) continue;//如果当前的数比差要小，就跳过。 
        sum+=b[a[i]-c];
        //计算结果，根据减数=被减数-差，同时题目说明不同的位置一样的数是两个不同的，所以加上次数。 
    }
    cout<<sum;//输出结果。 
    return 0;
}

```

---

## 作者：马必辰 (赞：5)

轻松A掉后，出于好奇看了一下题解，大部分都是二分的思想，时间复杂度O（nlogn），这里分享一种O（n）的方法。


类似于队列的思想，前面的指针指向的数>=（后面的指针指向的数-C），随着后面的指针增加，前面的指针也是增加的。对于等于的情况，统计一下数量就可以了。如果后面的指针指向的数连续相同，直接加上前者结果即可。


下面是代码，看不懂可以私信我。

```cpp
    #include<cstdio>
    long long a,b,c,d,e,f,g,i,m,n,x[200000]={0}; 
    int main()
    {
    scanf("%lld%lld",&a,&b);
    for(i=1;i<=a;i++)
    {
        scanf("%lld",&x[i]);
    }
    c=1;
    d=0;
    e=0;
    for(i=1;i<=a;i++)
    {
        while(x[c]<x[i]-b)
        {
            c++;
            d=0;
        }
        while(x[c+1]==x[i]-b)
        {
            d++;
            c++;
        }
        if(x[c]==x[i]-b) e=e+d+1;
    }
    printf("%lld\n",e); 
}
```

---

## 作者：kuansoudafahao (赞：5)

传播STL邪教：

这题我们除了二分做法，还可以用数组计数来做。Sum[i]表示数i出现过的次数，那么sum[i-c]就是可以和数i组成差为c的数的个数。如果只是这样，那远远不够，因为数据范围里明确规定，i的范围是[0…1,000,000,000]。开这么大的数组一定会爆。但是c++的STL里有一个功能强大的map(映射)。Map<类型1，类型2>代表的是这个map的下标为类型1，存的是类型2。通过这个map，我们可以轻松地做出这题。

附上AC代码：

```cpp
#include <cstdio>
#include <iostream>
#include <map>
using namespace std;//使用STL函数，这一行是必须的
map <int,int> a;
int tmp[100005];
int n,c,ans;
int main()
{
    freopen("2357.in","r",stdin);
    freopen("2357.out","w",stdout);
    scanf("%d%d",&n,&c);
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&tmp[i]);
        a[tmp[i]]++;
    }
    for(int i=1; i<=n; i++)
        ans+=a[tmp[i]+c];
    printf("%lld",ans);        
    return 0;    
}
```

---

## 作者：KesdiaelKen (赞：4)

这一题如果用O(N^2)暴力枚举，会炸。

将输入的数据进行排序，然后用两个指针指向a[0]，a[1]，然后用类似归并的思想，将指针位置向后推移。若找到a[m]-a[n]=c，则找到所有等于a[m]，等于a[n]的数（包括a[m]，a[n]）的个数，然后利用乘法原理，将它们相乘。将这些乘积累加，即得到答案。需要注意的是，当c等于0时，需要加一个特判，避免重复。另外，记得用long long。

代码如下：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
bool cmp(const long long& a,const long long& b)
{
    return a>b;
}
long long shu[300000]={0};
int main()
{
    int n,c;
    scanf("%d%d",&n,&c);
    for(int i=0;i<n;i++)scanf("%lld",&shu[i]);
    sort(shu,shu+n,cmp);//STL排序
    int t=0,w=1;
    int tj,wj;
    int st,sw;
    long long sum=0;
    while(w<n)
    {
        if(shu[t]-shu[w]>c)t++;
        if(shu[t]-shu[w]<c)w++;//靠近c
        if(shu[t]-shu[w]==c)
        {
            tj=wj=0;
            st=t,sw=w;
            for(int i=t;shu[i]==shu[st];i++)
            {
                tj++;
                t++;
            }
            if(c==0)wj=1;//若等于，则w不计数（这时a[t]-a[w]<=0，但不需要担心，在之后的操作中会将w恢复到t后面）
            else
            for(int i=w;shu[i]==shu[sw];i++)
            {
                wj++;
                w++;
            }
            sum+=(long long)tj*(long long)wj;
        }
    }
    printf("%lld",sum);
    return 0;
}
```

---

## 作者：hncsyjc (赞：4)

第一种方法：二分

先给所有的数排个序，然后从头扫到尾，跳过并记录重复的，设当前重复的元素为g1个，然后再二分查找有多少个元素的值=当前元素+c设有g2个，那么当前答案a[i]=g1\*g2，最后Sum(a[1..n])便是答案

时间复杂度O(nlogn)

空间复杂度O(n)

第二种方法：Hash

直接Hash

时间复杂度O(n)

空间复杂度O(n)


---

## 作者：小小小朋友 (赞：3)

这道题是一道方法非常多的题……

首先，暴力$O(n^2)$肯定过不了……

于是，我们的视线转向**枚举B，找有几个C+A**，然后我们就想到cnt数组，看了一眼数据范围，是小于long long的……果断想写哈希，但是突然想到可以用map映射啊……（STL大法好）

于是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
map<ll,ll> m;//映射
ll c,n,t,ans=0,k[200005];
int main(){
	cin>>n>>c;
	for(int i=0;i<n;i++){
		cin>>k[i];
		m[k[i]]++;
	}
	for(int i=0;i<n;i++){
		ans+=m[c+k[i]];//加上c+k[i]的个数
		if(c==0) ans--;
	}
	cout<<ans;
	return 0;
}
```

但是呢，map是一个自带排序的STL，所以时间慢了很多，怎么解决呢？~~散列~~我在OiWiki和C++ Reference查到了这样一个神奇的STL：**unordered_map**（同样还有unordered_set）唯一的问题是——**只支持C++11或以上**……但是万能的洛谷都支持到C++17啦！

而且代码几乎没改：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
unordered_map<ll,ll> m;//不排序的映射!
ll c,n,t,ans=0,k[200005];
int main(){
	cin>>n>>c;
	for(int i=0;i<n;i++){
		cin>>k[i];
		m[k[i]]++;
	}
	for(int i=0;i<n;i++){
		ans+=m[c+k[i]];//加上c+k[i]的个数
		if(c==0) ans--;
	}
	cout<<ans;
	return 0;
}
```
时间只用了300ms左右！（辣么多打表提交0ms是什么鬼啊！）

---

## 作者：Fuko_Ibuki (赞：3)

可以知道对于数列中的每一个元素来讲，它加上c之后的值是确定的。那么排序之后我们可以二分查找第一个a[i]+c和最后一个a[i]+c的位置。这里要用到两个函数lower\_bound和upper\_bound.做过导弹拦截的朋友应该不陌生，就是查找按升序排列的数组中比val大的第一个数字。我在codevs上A掉了题目之后把代码搬了过来，里面那个sort还在,不要在意。关于两个函数的用法可以自行去百度，很好理解。

```cpp
#include<bits/stdc++.h>
#define boss 200000
using namespace std;
int n,c,a[boss+10];
int main()
{
int i;
scanf("%d%d",&n,&c);
for (i=1;i<=n;i++) scanf("%d",&a[i]);
sort(a+1,a+n+1);
long long s=0;
for (i=1;i<=n;i++) 
  {
  int pos1=lower_bound(a+i,a+n+1,a[i]+c)-a;//查找数组中第一个大于等于a[i]+c的数字的位置
  int pos2=upper_bound(a+i,a+n+1,a[i]+c)-a;//查找数组中第一个大于a[i]+c的数字的位置
  s+=pos2-pos1;//自己把数组列出来之后就可以知道pos2-pos1就是a[i]+c在数组中的个数。
  }
printf("%lld",s);
}
```

---

## 作者：hfctf0210 (赞：3)

这道题，我看楼下都说用模拟或者数组保存等等，在这里，我向大家介绍一中独特的方法：

**薛山大定理+杨颙大定理（或者杨颙小定律）+查三道数列**：

具体解释：

**薛山大定理**：对于任意不超过2^36的数字，都可以用树状数据结构来保存**（仔细想想为什么？）而本题就是longint，2^31-1，正好

**杨颙小定律**：杨颙——一位伟大的人，出生于九州大陆，……（不具体介绍了），于2014年6月7日最新提出了小定律：任意不超过3^20-13的数，都可以表示在一个圆上，做x点共园（x<=3^20-13）

**查三道数列**：这个讲不好，上网搜搜，这个多得是，简单叙述：对于任何一个\_有序数列\_，都可以将第n(n>=3)个数表示为a[n]=pa[n-1]+qa[n-2](p,q∈R)，而本题中的数列，\_排一个序\_即可

```cpp
#include<iostream>
using namespace std;
int n,a[51][51][51][51],map[40][40];
void read()
{
    cin>>n;
    int x=1,y=1,z;
    while(x||y)
    {
        cin>>x>>y>>z;
        map[x][y]=z;
    }
}
int max(int a,int b,int c,int d)
{
    int ans=a;
    if(b>ans)ans=b;//薛山定律来保存
    if(c>ans)ans=c;
    if(d>ans)ans=d;
    return ans;
}
int main()
{
    read();
    int x1,y1,x2,y2;
    for(x1=1;x1<=n;x1++)
    for(y1=1;y1<=n;y1++)
    for(x2=1;x2<=n;x2++)
    for(y2=1;y2<=n;y2++)
    if(x1==x2&&y1==y2)
    a[x1][y1][x2][y2]=map[x1][y1]+max(a[x1-1][y1][x2-1][y2],a[x1-1][y1][x2][y2-1],a[x1][y1-1][x2-1][y2],a[x1][y1-1][x2][y2-1]);
    else a[x1][y1][x2][y2]=map[x1][y1]+map[x2][y2]+max(a[x1-1][y1][x2-1][y2],a[x1-1][y1][x2][y2-1],a[x1][y1-1][x2-1][y2],a[x1][y1-1][x2][y2-1]);
    cout<<a[n][n][n][n]; 
    int n,a[10001][4],x,y,max1=0,i;  
    cin>>n;  
    for(i=1;i<=n;i++)  
    cin>>a[i][0]>>a[i][1]>>a[i][2]>>a[i][3];  //查三道数列
    cin>>x>>y;  
    for(i=n;i>=1;i--)  
    if(x>=a[i][0]&&x<=a[i][0]+a[i][2]&&y>=a[i][1]&&y<=a[i][1]+a[i][3]) //现在来一发杨颙大法
    {
        cout<<i<<endl;
        return 0;
    }
    cout<<-1<<endl; 
}
```

---

## 作者：Real_Create (赞：2)

首先我们看到题目，觉得可以用桶来做

然后看到数据范围，开始沉思

二重循环成功[TLE](https://www.luogu.com.cn/record/22714081)

然鹅这题可以用队列做

------------

不想看的直接跳过下面的

~~那是很久很久以前~~

那是一个班内比赛，我在里面发现了这一题，而我已经在洛谷双重循环TLE过了，于是，我便意识到，~~下面的我也不会了~~也许要骗分了

......

终于，~~我发现下面的确实不会~~我把题全~~骗~~做完了，然后突然灵光一现，使用了一种诡异的方法

------------

首先，我们要思考，这个数他要在几种情况里用呢？

1、被减数

2、减数

那么我们可以用队列做

在作为被减数时被丢进队列

在作为减数时丢出队列

所以，我们要先排序

思路讲完了，那么上代码了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define qaq int main()
#define qwq return 0;
qaq
{
	int n,c,s=0,x=0,t;
	cin>>n>>c;
	long long a[n];//这个是排序用的（数组都没有你拿什么排序）
	queue<int> q;//队列来了
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	sort(a,a+n);
	for(int i=0;i<n;i++)
	{
		q.push(a[i]);//先丢进去
		if(a[i]!=x)//数字变了！
		{
			x=a[i];
			t=0;
			if(x-c>=q.front())//一个个地把太小的数丢出去
			{
				while(x-c>=q.front())
				{
					if(q.front()==x-c)
					{
						t++;//累加一下（数被丢出不复返）
					}
					q.pop();
				}
			}
		}
		s+=t;（累加一下有几个可以被当前数作减数
	}
	cout<<s;//输出
	qwq//没了
}
```

防抄袭已使用（不是RE，真的）

---

## 作者：Mubuky (赞：2)

**题目简意:**

> 给你一个长度为 $n$ 的数列 $a$，对于数列中的每个数 $a_i$ 询问 $a_i$ + $c$ 是否属于数列 $a$

**解法一:**

使用 $STL\ map$ 快速建立数和这个数出现的次数的映射。

对于每个属于数列 $a$ 的 $a_i$ + $c$ ,令 $ans$ += $map[a_i]$ ( $map[a_i]$ 即为按照上述方法建立的关于 $a_i$ 的映射)。

时间复杂度$O(nlogn)$，但 $STL\ map$ 基于平衡树实现，常数较大。

**解法二:**

使用二分查找，查找第一次等于 $a_i$ + $c$ 的位置和第一次大于 $a_i$ + $c$ 的位置,两位置的差就是所求 $ans$ 需要增加的个数。

当然，二分查找的前提是保证数列升序排列（或降序排列），需要提前对数列 $a$ 排序以满足此条件。

对于下面这组样例：
```cpp
5 1
1 1 2 2 3
```
注:以下部分默认下标从 $1$ 启用。

当遍历至 $a_1$$(1)$ 时, $a_i$ + $c$ = $2$ ,按照解法二的思想，二分查找到数列 $a$ 第一个等于 $2$ 的位置 $[3]$ ,和第一个大于 $2$ 的位置 $[5]$，两位置作差得到的 $2$ 就是 $ans$ 需要增加的数量。

时间复杂度$O(nlogn)$。

**下面给出解法二的 $STL$ 实现。**

```cpp
#include<cstdio>
#include<algorithm>
#define MAXN 200001
using namespace std;
int a[MAXN];
int main()
{
	int n,c;
	scanf("%d %d",&n,&c);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	long long ans=0;
	for(int i=1;i<=n;i++){
		int p=lower_bound(a+i,a+1+n,c+a[i])-a;
		int q=upper_bound(a+i,a+1+n,c+a[i])-a;
		ans+=q-p;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：2)

### 害怕$map$被卡？

### 哈希不会写？

欢迎使用pbds~

## [学习指南](https://www.luogu.org/blog/Chanis/gnu-pbds)
```cpp
#include <cstdio>
#include <iostream>
#include <stack>
#include <utility>
#include <algorithm>
#include <set>
#include <cstring>
#include <string>
#include <cmath>
#include<ext/pb_ds/assoc_container.hpp> //核心
#include<ext/pb_ds/hash_policy.hpp>     //核心
#define rep(i,a,b) for(int i=(a);i<=(b);++i) 
#define dec(i,a,b) for(int i=(a);i>=(b);--i)
#define gc() getchar()
#define endll putchar('\n')
using namespace std;
using namespace __gnu_pbds;             //核心
typedef long long ll;
typedef pair<int,int> P;
inline ll read(){
	char ch=gc();
	ll x=0,f=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=gc();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=gc();
	}
	return x*f;
}
inline void print(ll k){
	if(k<0) k=-k,putchar('-');
	if(k>9) print(k/10);
	putchar(k%10+48);
}
inline void println(ll k){
	print(k);
	endll;
}
const int maxn=200411;
ll a[maxn];
int n;
gp_hash_table<int,int> mapp;     //其实和map用法是差不多的
ll ans,c;
int main(){
	n=read();
	c=read();
	rep(i,1,n) {a[i]=read();mapp[a[i]]++;}
	rep(i,1,n){
		ans+=mapp[a[i]+c];
	}
	println(ans);
	return 0;
}
```


---

## 作者：yang2016 (赞：2)

c++代码 用STL里的map来记录

```cpp
#include<iostream>  
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map>
using namespace std;
int n,c;
int v[200010];
map<int,int>mp;
long long ans;
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i];
        mp[v[i]]++;
    }
    sort(v+1,v+1+n);
    for(int i=n;i>=1;i--)
    if(mp[v[i]]&&mp[v[i]-c])
    {
        ans+=mp[v[i]]*mp[v[i]-c];   //相乘即可得到数对的数量
        mp[v[i]]=0;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：JJYZLXJ (赞：2)

枚举A然后二分找B

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct p
{
    int v;//数值
Int sum;//出现次数
}pp[200001];
int comp(const p a,const p b)//比较函数
{
    return a.v<b.v;
}
int main()
{
    long long tot=0;
    int n,c,count=0;
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&pp[i].v);
        pp[i].sum=1;//初始化个数
    }
    sort(pp+1,pp+n+1,comp);
    for(int i=2;i<=n;i++)
    if(pp[i].v==pp[i-1].v)
    {
        pp[i].sum=pp[i-1].sum+1;
        pp[i-1].v=-2147483647;
        count++;//除去重复的数并记下
    }
    sort(pp+1,pp+n+1,comp);
    for(int i=count+1;i<=n;i++)//sort完后从count+1到n开始枚举
    {
        int a=count+1,b=n,k=(a+b)/2,x=pp[i].v-c;
        if(x<pp[a].v||x>pp[b].v)continue;
        else if(pp[a].v==x){tot+=pp[a].sum*pp[i].sum;continue;}
        else if(pp[b].v==x){tot+=pp[b].sum*pp[i].sum;continue;}
        else
        {
            while(b-a>1)
            {
                k=(a+b)/2;
                if(pp[a].v<=x&&pp[k].v>=x)b=k;
                else a=k;
            }
            if(pp[a].v==x)
            tot+=pp[a].sum*pp[i].sum;
            else if(pp[b].v==x)
            tot+=pp[b].sum*pp[i].sum;
        } 
    }
    printf("%lld",tot);
    return 0;
}
```

---

## 作者：May_Forever (赞：2)

楼下的解法我并不是很懂。。。。为什么还要sort啊QwQ

也是用map，存每个数出现的次数，然后直接扫一遍，看每个数与C相加后的值有没有出现过，出现过就加上，没出现就不管（当然，如果不判断直接加也没事，但这样到最后可能这个map占据的空间会越来越大。。）


```cpp
#include<map>
#include<cstdio>
#include<iostream>
using namespace std;
int n,c,a[300000];
map <int,int> mp;
int main(){
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
        ++mp[a[i]];
    }
    int ans=0;
    for(int i=1;i<=n;++i)if(mp.find(a[i]+c)!=mp.end()){ans+=mp[a[i]+c];}
    cout<<ans<<endl;
}
```

---

## 作者：fallenangel (赞：2)

# 我来传播一波pb_ds邪教

#### 众所周知，pbds是个好东西

#### 它可以帮我们非常快乐的实现堆、平衡树等一堆非常神奇的数据结构

#### 当然也包括hash

#### pb_ds和hash分两种：gp_hash_table 和 cc_hash_table

#### 于是我用gp_hash_table,cc_hash_table,map都试了一遍，发现时间差距还是蛮大的

### gp_hash_table:133ms

### cc_hash_table:204ms

### map:382ms(~~瑟瑟发抖~~)

### 因此，这证明了：

# pb_ds是个好东西

#### 下面是我三个程序的代码（~~我已经尽力了~~）

```
#include<cstdio>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>

typedef long long LL;

__gnu_pbds::gp_hash_table<LL, LL> Hash;
LL n, c, ans, a[200010]; 

inline LL read() {
	LL x = 0, f = 1; char c;
	for (c = getchar(); !isdigit(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
	return x * f;
}

int main() {
	n = read(); c = read();
	for (register int i = 1; i <= n; ++i) {
		++Hash[a[i] = read()];
		a[i] -= c;
	}
	for (register int i = 1; i <= n; ++i)
		ans += Hash[a[i]];
	printf("%lld\n", ans);
	return 0;
}

```

```
#include<cstdio>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>

typedef long long LL;

__gnu_pbds::cc_hash_table<LL, LL> Hash;
LL n, c, ans, a[200010]; 

inline LL read() {
	LL x = 0, f = 1; char c;
	for (c = getchar(); !isdigit(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
	return x * f;
}

int main() {
	n = read(); c = read();
	for (register int i = 1; i <= n; ++i) {
		++Hash[a[i] = read()];
		a[i] -= c;
	}
	for (register int i = 1; i <= n; ++i)
		ans += Hash[a[i]];
	printf("%lld\n", ans);
	return 0;
}

```

```
#include<cstdio>
#include<cctype>
#include<map>
using namespace std;

typedef long long LL;

LL n, c, ans, a[200010]; 
map<LL, LL> Hash;

inline LL read() {
	LL x = 0, f = 1; char c;
	for (c = getchar(); !isdigit(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
	return x * f;
}

int main() {
	n = read(); c = read();
	for (register int i = 1; i <= n; ++i) {
		++Hash[a[i] = read()];
		a[i] -= c;
	}
	for (register int i = 1; i <= n; ++i)
		ans += Hash[a[i]];
	printf("%lld\n", ans);
	return 0;
}

```

我才不会告诉你其实hash_map只跑了76ms
```
#include<cstdio>
#include<cctype>
#define SIZE 500010
using namespace std;

typedef long long LL;

LL n, c, ans, a[SIZE];

inline LL read() {
	LL x = 0, f = 1; char c;
	for (c = getchar(); !isdigit(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
	return x * f;
}

struct Hash_Map {
	struct node {int next,v,w;} edge[SIZE];
	int cnt, head[SIZE];
	int &operator [] (int v) {
		for (int i = head[v%SIZE]; i; i = edge[i].next)
			if (edge[i].v == v) return edge[i].w;
		edge[++cnt] = (node) {head[v%SIZE],v,0};
		head[v%SIZE] = cnt;
		return edge[cnt].w;
	}
} Hash;

int main() {
	n = read(); c = read();
	for (register int i = 1; i <= n; ++i) {
		++Hash[a[i] = read()];
		a[i] -= c;
	}
	for (register int i = 1; i <= n; ++i)
		ans += Hash[a[i]];
	printf("%lld\n", ans);
} 
```


---

## 作者：Xiao_Ling (赞：2)

本题枚举的话绝对会炸

因为该题有相同的数，本着统计的思想再加上二分的方法优化，就能搞定它~~

#注意，因为数据比较大，所以要开long long 来储存

#这里我用b数组存数，c数组统计对应位置的b中的个数0.0(有点绕)

```cpp
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n,p;
    long long ans=0;
    int o=0;
    long long a[200010]={0},b[200010]={0},c[200010]={0};
    int main()
    {
        scanf("%d%d",&n,&p);
        for(int i=1;i<=n;i++)//先存进来
        {
            cin>>a[i];
        }
        sort(a+1,a+n+1);//然后进行排序，方便统计
        for(int k=1;k<=n;k++)//这里是统计时间(0.0)
        {
            if(b[o]==a[k])
            {
                c[o]++;
            }
            else
            {
                b[++o]=a[k];
                c[o]++;
            }
        }
        for(int i=1;i<=o;i++)
        {
            long long x=b[i]+p;
            int l=1,r=o,mid=(l+r)>>1;
            while(l<=r)//二分大法好
            {
                mid=(l+r)>>1;
                if(x==b[mid])
                {
                    ans+=(c[mid]*c[i]);//注意，要乘起来
                    break;
                }
                else if(x<b[mid])
                    {
                        r=mid-1;
                        continue;
                    }
                    else
                    {
                        l=mid+1;
                        continue;
                    }
            }
        }
        cout<<ans;
        return 0;
    }

```

---

## 作者：Fuko_Ibuki (赞：2)

改成long long就可以过了.我在增强版里发的题解是二分的,这里我突然想起了一个经典解法:尺取法.

加了几个优化,48ms,还是非常快的.

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define boss 200000
using namespace std;
typedef long long ll;
int a[boss+10],n,k;ll s;

inline int read()//这个可以说是最简单的读入优化写法了(只限自然数)
{
int x=0;char c=getchar();
for (;!isdigit(c);c=getchar());
for (;isdigit(c);c=getchar()) x=x*10+c-'0';
return x;
}

void write(ll x)//输出优化当然也只限自然数.由于输入输出很少会有负数,我通常不判负数.
{
if (x>9) write(x/10);
putchar(x%10+'0');
}

int main()
{
int i,l=1,r1=1,r2=1;//r1左端点,r2右端点
memset(a,63,sizeof a);//必须要把a数组赋值成inf,不然取左右区间的时候会炸到N
for (n=read(),k=read(),i=1;i<=n;i++) a[i]=read();
for (sort(a+1,a+n+1);l<=n;l++)//逐步取一个位置,寻找a[i]+k的左端点和右端点.
  {
  for (;a[l]+k>a[r1];r1++);//左端点,和二分法当中的解释相同
  for (;a[l]+k>=a[r2];r2++);//右端点也是同理.
  s+=r2-r1;
  }
write(s);
}
```

---

## 作者：Mashiro_ylb (赞：2)

#一个小模拟

这个题可以用O(n ^ 2)的方法进行暴力枚举统计a[i] 与 a[i] + c相等情况的出现次数

但显然是不行的

所以笔者对其进行了优化

容易推知若对a[i]进行排序，则a[i] 与 a[i] + c相等情况出现之前与出现之后都不会再有相同的相等情况出现

所以那一部分没必要再进行枚举，详情请看代码

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

long long ans = 0, ans1, ans2;
long long z1 = 1;
long long z2 = 1;
long long n, c;
long long a[200007];

template<class T>void read(T &x)   //读入优化（这种写法比世上所熟知的那个读入优化稍微快一些吧）
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
void write(long long x)   //输出优化（其实这个题可以不加这两个优化，但是笔者有任何代码都带着这两个优化的习惯）
{
    if(x < 0){putchar('-'); x = -x;}
    if(x > 9)write(x / 10);
    putchar(x % 10 + '0');
}

int main()
{
    read(n);read(c);
    int jishu = 0;
    for(int i = 1; i <= n; i++)
    {
        read(a[i]);
    }
    sort(a + 1, a + n + 1);
    while(z1 <= n && z2 <= n)   //类似于归并排序
      {
          while(a[z1] < a[z2] + c)  z1++;  //z1, z2是两个指针分别指向数组a[i]与a[i] + c                                           
        while(a[z1] > a[z2] + c)  z2++;  //由于前边已经排好序，所以用类似归并的方法比较当前位置的值来决定z1和z2两指针的后移
        if(a[z1] == a[z2] + c)  //如果z1,z2指向的值相同，则进行统计
          {
              ans1 = 0; ans2 = 0; 
              long long rong = a[z1];  //rong用于临时存值
              while(a[z1] == rong)  //相同数字处理
                {
                      ans1++;
                      z1++;
              }
            while(a[z2] + c == rong)
              {
                  ans2++;
                  z2++;
              }
            ans += (ans1 * ans2);  //根据乘法原理求得每次得出的满足题意数对的个数，然后进行累加得出最终答案
          }
      }
    write(ans);
    return 0;
}
```

---

## 作者：michenghao (赞：2)

只要进行一个计数排序即可，把所有数做过来，发现这个数+c也是有的，加起来。其实数据有点弱，大一点，数到maxlongint，f数组就存不下了，具体程序如下：

```cpp
var
  n,m,x,i,max,sum:longint;
  f:array[-1000001..1000001] of longint;
begin
  readln(n,m);
  for i:=1 to n do
  begin
    read(x);
    f[x]:=f[x]+1;   //计数排序
    if x>max then max:=x;
  end;
  for i:=0 to max do       //把所有数扫描一遍
  if (f[i]>0) and (f[i-m]>0) then
    sum:=sum+f[i-m]*f[i];    //累加
  writeln(sum);
end.
```

---

## 作者：cxh125011501 (赞：2)

本着简练的精神，c++选手其实直接开个map就好了

```cpp

#include<iostream>
#include<iterator>
#include<map>
using namespace std;
map<int,int> jihe;
int main(){
    int n,c,mmm,sum=0;
    cin>>n>>c;
    for(int i=0;i!=n;++i){
        cin>>mmm;
        jihe[mmm]++;
    }
    map<int,int>::iterator it,itb;
    for(it=jihe.begin();it!=jihe.end();++it){
        itb=jihe.find((it->first)-c);
        if(itb==jihe.end()) continue;
        sum+=it->second * itb->second;
    }
    cout<<sum;
}

```

---

## 作者：Mashiro_ylb (赞：1)

#一个模拟(归并排序思想)

这个题可以用O(n ^ 2)的方法进行暴力枚举统计a[i] 与 a[j] + c相等情况的出现次数，但果断地超时了，所以笔者对其进行了优化。

容易推知若对这n个整数进行排序，则a[i] 与 a[j] + c相等情况出现之前与出现之后都不会再有相同的相等情况出现（在此之前a[i] > a[j] + c,  之后a[i] < a[j] + c）；所以那一部分没必要再进行枚举，详情请看代码；

这个方法的复杂度较低，所以这道题的数据加不加强这个算法都是可以过的。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

long long ans = 0, ans1, ans2;
long long z1 = 1;
long long z2 = 1;
long long n, c;
long long a[200007];

template<class T>void read(T &x)   //读入优化
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
void write(long long x)   //输出优化
{
    if(x < 0){putchar('-'); x = -x;}
    if(x > 9)write(x / 10);
    putchar(x % 10 + '0');
}

int main()
{
    read(n);read(c);
    int jishu = 0;
    for(int i = 1; i <= n; i++)
    {
        read(a[i]);
    }
    sort(a + 1, a + n + 1);
    while(z1 <= n && z2 <= n)   //类似于归并排序
      {
          while(a[z1] < a[z2] + c)  z1++;  //z1, z2是两个指针分别指向数组a[i]与a[i] + c                                           
        while(a[z1] > a[z2] + c)  z2++;  //由于前边已经排好序，所以用类似归并的方法比较当前位置的值来决定z1和z2两指针的后移
        if(a[z1] == a[z2] + c)  //如果z1,z2指向的值相同，则进行统计
          {
              ans1 = 0; ans2 = 0; 
              long long rong = a[z1];  //rong用于临时存值
              while(a[z1] == rong)  //相同数字处理
                {
                      ans1++;
                      z1++;
              }
            while(a[z2] + c == rong)
              {
                  ans2++;
                  z2++;
              }
            ans += (ans1 * ans2);  //根据乘法原理求得每次得出的满足题意数对的个数，然后进行累加得出最终答案
          }
      }
    write(ans);
    return 0;
}
```

---

## 作者：hyoi_ctime (赞：1)

用一个map数组p[max]存一下每一个数出现的次数；

如果p[x[i]+c]大于0；也就是比x[i]大c的数出现过，所以ans就加上p[x[i]+c]；

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
using namespace std;
long long n,c,ans;
map<long,long>p;
long long x[200001];
inline void read()
{
    scanf("%lld%lld",&n,&c);
    for(int i=1;i<=n;i++)
    {
         scanf("%lld",&x[i]);
         p[x[i]]++;
    }
    for(int i=1;i<=n;i++)
        {
            if(p[x[i]+c]>0)
            ans+=p[x[i]+c];
        }
        printf("%lld",ans);
}
int main()
{
    read();
    return 0;
}
```

---

## 作者：Megumi_Cold (赞：1)

展示一个神奇的代码

主要还是二分,但是惊讶地发现二分最后一个点居然超时

于是想到一种神奇的思路

先查出某个需要查询的数共出现了多少次

然后再查出加上指定数后有多少个(用上二分)

最后相乘记录结果


```cpp
#include<cstdio>
#define M 100001
using namespace std;
int n,c,a[M],sum,poi,mul;
int search_part(int left,int right,int value)
{
    if(left>=right)
    return right;
    int mid;
    mid=(left+right)>>1;
    if(a[mid]>=value)
    return search_part(left,mid,value);
    if(a[mid]<value)
    return search_part(mid+1,right,value);
}
int main()
{
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    mul=1;
    for(int i=1;i<=n;i++)
    {
        if(a[i]==a[i+1])
        {
            mul++;
            continue;
        }
        int num;
        num=0;
        poi=search_part(1,n,a[i]+c);
        if(a[poi]!=a[i]+c)
        {
            mul=1;
            continue;
        }
        poi++;
        num++;
        while(a[poi]==a[poi-1])
        {
            num++;
            poi++;
        }
        sum+=num*mul;
        mul=1;
    }
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：attack (赞：1)

数据更新之后题解里面的的大部分都A不了了，都会W掉第3个点

原因很简单，没有开long long

思路：因为是long long ，所以简单的数组hash肯定是过不了了。

我们可以考虑用map

虽然时间复杂度是nlogn但也勉强可以水过去

我们可以吧A-B==C的式子转换一下，转换成A-C=B

这样用map就方便多了，

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#define lli long long int 
using namespace std;
const lli MAXN=200001;
lli n,c;
map<lli,int>mp;
lli a[MAXN];
lli read(lli & n)
{
    char c='.';lli x=0,flag=0;
    while(c<'0'||c>'9')
    {
        c=getchar();
        if(c=='-')flag=1;
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+(c-48);
        c=getchar();
    }
    if(flag==1)n=-x;
    else n=x;
}
int main()
{
    read(n);read(c);
    for(lli i=1;i<=n;i++)
    {
        read(a[i]);
        mp[a[i]]++;
    }    
    lli ans=0;
    for(lli i=1;i<=n;i++)
        if(mp[a[i]-c]!=0)
            ans=ans+mp[a[i]-c];
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：fl_334 (赞：1)

没错，这题用哈希；

本人不才，不像各位大神会用stl





```cpp
#include <iostream>
#define LL long long            //要开龙龙哦
using namespace std;
const int bigPrimeNum = 277777;           //选的哈希数，是个大素数
LL arr1[300000],arr2[300000],Hash[bigPrimeNum + 10];
int Max = 300000;
int sum[bigPrimeNum + 10];
void Insert(LL num){       //插入，套模板
    int tmp = num % bigPrimeNum;             //取模
    while (Hash[tmp] != Max && Hash[tmp] != num){
        tmp++;
        if(tmp > bigPrimeNum)
            tmp = 0;
    }
    Hash[tmp] = num;
    sum[tmp]++;
}
int Find(LL num){               //找，有没有发现和插入差不多
    int tmp = num % bigPrimeNum;
    while (Hash[tmp] != Max && Hash[tmp] != num){
        tmp++;
        if(tmp > bigPrimeNum)
            tmp = 0;
    }
    return sum[tmp];          //注意此处，如果有，就返回TRUE，没有就返回0
}
int main() {
    int n;
    LL c;
    for (int k = 0; k < bigPrimeNum + 10; ++k) {
        Hash[k] = Max;
    }
    cin >> n >> c;
    for (int i = 0; i < n; ++i) {
        cin >> arr1[i];
        arr2[i] = arr1[i] + c;
        Insert(arr2[i]);        //插入。。。
    }
    int ans = 0;
    for (int j = 0; j < n; ++j) {
        ans += Find(arr1[j]);            //计算，如果没有就+0。
    }
    cout << ans << endl; 
    return 0;
}
```

---

## 作者：飞翔 (赞：1)

首先快排，如果用STL里的快排实测能排到百万级，但是手写就不行了，只能20W。

然后手撸单调队列。具体思路请看程序。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long a[2000010],f[2000010];//f[i]表示满足a[i]-a[x]=c的情况的总数
const int INF=1000000000;
bool cmp(int a,int b) { return a>b; }
int main()
{
    int n,c,i,j=2;
    scanf("%d%d",&n,&c);
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1,cmp);
    a[0]=-1; a[n+1]=-INF/3;
    memset(f,0,sizeof(f));
    for (i=1;i<n;i++) {
        if (a[i]==a[i-1]) { f[i]=f[i-1];continue; }//这就不用解释了吧
        while (a[i]-a[j]<c) j++;//这里已经排好序了，所以j只要增加，不会减少，可以自己画图验证
        if (j>n) break;
        while (a[i]-a[j]==c) { f[i]++;j++; }//累加答案
    }
    int ans=0;//数据貌似有些弱，int也过了，不过最好用long long
    for (i=1;i<=n;i++) ans+=f[i];
    printf("%d",ans);
}
```

---

## 作者：lych (赞：1)

本题有两种方法，以下进行分析：


方法一：用类似计数排序的思路，代码简短又很好理解，是本题的最佳首选。但是算法存在局限性，面对强数据的时候就无能为力了。思路就是把一个数的个数计入数组，然后直接统计即可。

```delphi
var
  a,b:array[0..10000000] of longint;
  i,n,m:longint;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      read(a[i]);
      inc(b[a[i]]);//计数
    end;
  for i:=1 to n do
    inc(ans,b[a[i]+m]);//累加比a[i]大m的数的个数
end.
```

方法二：排序+二分，先排序，用一个数组记录元素即该元素的位置，然后二分查找比该元素大m的元素的个数，根据乘法原理得出可以得到的数对的个数，最后累加

```delphi
var
  ans,j,k,i,n,m:longint;
  a,c,d:array[0..200001] of longint;
procedure qsort(r,l:longint);
var
  i,j,mid,t:longint;
begin
  i:=r; j:=l;
  mid:=a[random(j-i+1)+i];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
      begin
        t:=a[i]; a[i]:=a[j]; a[j]:=t;
        inc(i); dec(j);
      end;
  until i>j;
  if i<l then qsort(i,l);
  if r<j then qsort(r,j);
end;
function erfen(r,l:longint):longint;
var
  m:longint;
begin
  if r>l then exit(0);//无解，返回值为0
  m:=(r+l) shr 1;//取中值
  if c[m]=k then exit(m) else//找到解，退出
  if c[m]<k then exit(erfen(m+1,l)) else exit(erfen(r,m-1));//范围更换，递归查找
end;
begin
  randomize;//随机化快排
  readln(n,m);
  for i:=1 to n do read(a[i]);
  readln;
  qsort(1,n);
  i:=1; j:=1;
  while i<=n do
    begin
      inc(k);
      c[k]:=a[i];//重复的元素
      while (a[j]=a[j+1]) do inc(j);
      inc(j);//下一个不重复的元素的位置
      d[k]:=j-i;//元素个数
      i:=j;
    end;
  n:=k;
  for i:=1 to n do
    begin
      k:=c[i]+m;
      if k<c[1] then continue;
      if k>c[n] then continue;//找不到，跳过
      inc(ans,d[i]*d[erfen(1,n)]);
    end;
  writeln(ans);
end.
```

---

## 作者：insprition (赞：1)

此题由楼下所述map而得灵感；

建立一个map映射   (number+c)  --> (number+c) of times；

往后边输入边累加就好；

```cpp
#include<iostream>
#include<map>
using namespace std;
map<int,int>mp;
long long s=0,a,n,c,i;//s为结果
int main(){
    cin>>n>>c;
    cin>>a;
    mp[a+c]=1;//记录出现次数
    for(i=2;i<=n;i++){
        cin>>a;
        mp[a+c]++;
        if(mp.count(a)){//如果存在映射，s累加
            s+=mp[a];
        }
    }
    cout<<s;//THE END
    return 0;
}
```
但map不如二分快，后几个数据点有明显体现...


---

## 作者：zzqDeco (赞：0)

~~我个傻x~~

交一个尺取法（尺取入门题）

现将相同的合并起来统计个数，然后，用尺取法统计满足的数对（先要排序）

```cpp
ans+=l.cnt*r.cnt;
```

考虑到c==0的情况（但是好像没有），单独求组合

下面是代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

struct p
{
  long long num,cnt;
}point[200010];//压缩之后的点，统计个数

int n,c;

long long ans;

long long a[200010];

int l=1,r=2,m;

bool cmp(long long a,long long b)//一定要先排序
{
  return a<b;
}

int main()
{
  scanf("%d%d",&n,&c);
  for(int i=1;i<=n;i++)
  {
    scanf("%lld",&a[i]);
  }
  sort(a+1,a+n+1,cmp);
  for(int i=1;i<=n;i++)
  {
    if(i==1||(i!=1&&a[i]!=a[i-1]))
    {
      point[++m].num=a[i];
      point[m].cnt=1;
    }
    if(i!=1&&a[i]==a[i-1])
    {
      point[m].cnt++;
    }
  }//常见的套路，在UVA11235也用到过
  if(c==0)
  {
    for(int i=1;i<=m;i++)
    {
      ans+=point[i].cnt*(point[i].cnt-1)/2;
    }
    printf("%lld\n",ans);
    return 0;
  }//c==0特殊处理
  while(l<=m&&r<=m)
  {
    if(point[r].num-point[l].num==c) ans+=point[l].cnt*point[r].cnt;
    if(point[r].num-point[l].num<=c) r++;
    if(point[r].num-point[l].num>c) l++;
  }//标准尺取法
  printf("%lld\n",ans);
}

```

---

## 作者：马峰 (赞：0)

## 我可能是个傻子，闲来无事做这么水的题还被卡了半天

看题解都用的map吧2333.然而这道题完全不需要用map啊。直接暴力加点优化就可以过。

思想，sort一遍。nlogn。然后就直接比较就好了啊。记录一下不可能的值，第二重搜索的时候直接跳过。

上代码。

```
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

long long n,c,a[200010],ans;

inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}//不用也能过吧qwq


int main(){
    //freopen("testdata.in","r",stdin);
    n=read();c=read();
    for(int i=1;i<=n;i++) a[i]=read();
    sort(a+1,a+n+1);
    long long j=1,pos=1,sum=0;
    for(int i=1;i<=n;i++){
        if(a[i]==a[i-1]){
            ans+=sum;continue;
        }
        sum=0;
       // bool flag=1;
        for(j=pos;j<=n;j++){
            if(a[j]-a[i]==c) {
                sum++;
                ans++;
                //if(flag)pos=j,flag=0;
            }
            if(a[j]-a[i]>c) {
                pos=j-1;break;
            }
        }
    }
    cout<<ans;
    return 0;
}
```
哦对了记得开long long，不然会被卡。
这个东西好像比map快400ms？

---


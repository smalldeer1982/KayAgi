# 生日

## 题目描述

cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。


## 说明/提示

数据保证，$1<n<100$，$1\leq |s|<20$。保证年月日实际存在，且年份 $\in [1960,2020]$。

## 样例 #1

### 输入

```
3
Yangchu 1992 4 23
Qiujingya 1993 10 13
Luowen 1991 8 1
```

### 输出

```
Luowen
Yangchu
Qiujingya
```

# 题解

## 作者：_jimmywang_ (赞：206)

### 我又来了！

首先，题目标签是：

字符串 &排序 &模拟 &选择排序

然而我们不用玄学的选择排序，我们来引进一种更加简（xuan）单（xue）的排序方法：

## 快速排序！！！！

首先推荐一个网站：[算法可视化]( https://visualgo.net/zh)

看到这里的人去该网站看快排的图示，肯定要比我讲的好的多…………

快排呢，用的是分治法。先找一个基准数，把比他小的放他左边，比他大的放他右边，再递归左边和右边。

好吧，我承认我讲不清楚，看图吧…………

6个数：5,7,6,4,3,8.

```
                               --- 
       ---                    |   |
      |   |  ---              |   |
 ---  |   | |   |             |   |
| 5 | |   | |   |  ---        | 8 |  
|   | | 7 | |   | |   |  ---  |   |
| 基| |   | | 6 | |   | |   | |   |
| 准| |   | |   | | 4 | | 3 | |   |
|   | |   | |   | |   | |   | |   |
 ---   ---   ---   ---   ---   --- 
```


把3和4移到5左边，剩下的在5右边。

```
                               --- 
                   ---        |   |
                  |   |  ---  |   |
             ---  |   | |   | |   |
 ---        | 5 | |   | |   | | 8 |  
|   |  ---  |基 | | 7 | |   | |   |
|   | |   | |准 | |   | |   | |   |
| 4 | | 3 | |   | |   | | 6 | |   |
|   | |   | |   | |   | |   | |   |
 ---   ---   ---   ---   ---   --- 
 
```

这样就确定了5的位置。

递归左边，3和4交换。

```
                               --- 
                   ---        |   |
                  |   |  ---  |   |
             ---  |   | |   | |   |
       ---  | 5 | |   | |   | | 8 |  
 ---  |   | |基 | | 7 | |   | |   |
|   | |   | |准 | |   | |   | |   |
| 3 | | 4 | |   | |   | | 6 | |   |
|   | |   | |   | |   | |   | |   |
 ---   ---   ---   ---   ---   --- 
 
```
这样，3,4,5的位置就确定了。

再递归右边

```
                               --- 
                         ---  |   |
                   ---  |   | |   |
             ---  |   | |   | |   |
       ---  | 5 | |   | |   | | 8 |  
 ---  |   | |基 | | 6 | | 7 | |   |
|   | |   | |准 | |   | |   | |   |
| 3 | | 4 | |   | |   | |   | |   |
|   | |   | |   | |   | |   | |   |
 ---   ---   ---   ---   ---   --- 
 
```
 排好了QWQ
 
 
 
##  回到本题：

```
#include<bits/stdc++.h>
using namespace std;
struct node//结构体排序
{
	string s;//名字
	int n,y,r,num;//年，月，日，输入的编号。
}a[110];
int n;
bool cmp(node a,node b)
{
	if(a.n<b.n)return 1;//先比年
	if(a.n>b.n)return 0;
	if(a.n==b.n)
	{
		if(a.y<b.y)return 1;//再比月
		if(a.y>b.y)return 0;
		if(a.y==b.y)
		{
			if(a.r<b.r)return 1;//再比日
			if(a.r>b.r)return 0;
			if(a.r==b.r)
			{
				if(a.num>b.num)return 1;//最后比编号
				else return 0;
			}
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].s>>a[i].n>>a[i].y>>a[i].r,a[i].num=i;//输入
	sort(a+1,a+n+1,cmp);//快排
	for(int i=1;i<=n;i++)cout<<a[i].s<<endl;//输出。
	return 0;
}
```



### 希望对不会的小朋友有帮助，谢谢观看！


---

## 作者：子墨丶 (赞：173)



~~蒟蒻一点小建议~~

看着题解里的大佬们用的各种神仙做法，我一个连结构体都一团浆糊的蒟蒻真的深感无力。。。

不过幸运的是我~~在买车票时~~由身份证得到了一个启发

所以在这里推荐一个稍微简单一点的做法吧

我就不贴完整代码了

首先呢我们要搞清楚一个重要规律

y=year，m=month，d=day，下同（~~小学都学过就不解释啦~~~）

常识告诉我们，表示年份的数字越小，生日越大（例如1990和1995）；年份相同时，表示月份的数字越小生日越大（例如1990.7和1990.3）；月份相同时，表示日期的数字越小生日越大（例如1990.7.31和1990.7.3）。【~~废话~~】

# 所以我们为什么不可以把年+月+日摞成一个数字（生日数）呢？

我用测试数据举个例子，yangchu是1992.4.23，
qiujingya是1993.10.13,luowen是1991.8.1，
我们把他写成**yangchu,19920423;qiujingya，19931013，luowen，19910801**的形式，其实就是省略中间的分割点重头到尾连在一起，就和身份证上显示生日的数一样

根据**数字越小，生日越大**的原理，我们可以用自带从小到大排序功能的sort函数对所有生日数进行排序，然后根据生日数的大小进行名字的输出不就行了吗？

以下是代码核心！

~~此处播放心太软~~

```
for (int 1=1;i<=n;i++)    //循环输入开始
{
   cin>>y[i]>>m[i]>>d[i];	//输入年份，月份和日期
  int s[i]=y[i]*10000+m[i]*100+d[i]*1; //计算生日数
  }
   sort（s+1,s+n+1）;          //对生日数进行排序 
```

连结构体都不用，是不是很简单呢？



---

## 作者：JJJJones_Zhu (赞：160)

#### 这题的单调性很明显，明显可以用快排做嘛！但是在用快排的时候要在cmp函数里~~添油加醋~~
#### 直接看代码吧！注释应该很清楚了！
### 另：sort是不稳定排序 可以改成稳定排序 stable_sort 用法和sort一样

```cpp
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
#include<cmath>
#include<cstdio>
using namespace std;
int n;
struct node{
	string name;//姓名
	int year,mon,day;//年月日
	int level;//记输出顺序
}nn[105];

bool cmp(node a,node b){
	if(a.year != b.year)
	return a.year < b.year;//如果出生年份不相等便直接按照年份进行排序
	else{
	if(a.mon != b.mon) return a.mon < b.mon;//年份相等月份不相等
	else if(a.day == b.day && a.mon == b.mon) return a.level > b.level;//同年同月同日生 便把后输入的排在前面
	else if(a.day != b.day && a.mon == b.mon) return a.day < b.day;//同年同月不同日
	}
}

int main(){
	cin>>n;
	for(int i = 1; i <= n; ++i)
	{
		cin>>nn[i].name>>nn[i].year>>nn[i].mon>>nn[i].day;
		nn[i].level = i;//记录输入顺序
	}
	stable_sort(nn + 1,nn + n + 1,cmp);//注意边界
	for(int i = 1; i <= n; ++i) cout<<nn[i].name<<endl;
	return 0;
}

```

---

## 作者：Histone (赞：62)

~~蒟蒻第一次发题解~~
望大佬们海涵

看到这题的瞬间，我想到了一个鬼点子。

（翻了翻看到有类似题解，不过稍稍还是有点出入）

倘若把每个人的出生日期看做他的死亡日期。
把出生日期设为公元第一年一月一日的话……

那就计算他从公元 1.1.1 — xxxx.x.xx 一共有多少天就好了，~~然后排序输出~~

~~（每个人都是千年老妖，有点恐怖）~~

从公元到死亡的日子 = 年×365+月×30+日;

排序什么的随便啦（~~本蒟蒻冒泡~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct sr{
	string name;
	int n,y,r;
}xs[120];//结构体，nian年，yue月，ri日。一目了然的变量名，哈哈
int main(void){
	int k,i,j,temp1,temp2;
	cin>>k;
	for(i = 0;i<k;i++)cin>>xs[i].name>>xs[i].n>>xs[i].y>>xs[i].r;//输入每个人的信息
	for(i = 0;i<k;i++){
		for(j = 0;j<k;j++){
			temp1 = xs[i].n*365+xs[i].y*30+xs[i].r;
			temp2 = xs[j].n*365+xs[j].y*30+xs[j].r;
			if(temp1<=temp2)swap(xs[i],xs[j]);		
		}//蒟蒻的冒泡排序
	}
	for(i = 0;i<k;i++)cout<<xs[i].name<<endl;//输出就好了
	return 0;
}
```




---

## 作者：dinghongyu (赞：55)

## 看楼上楼下都是用结构体的大佬，可是本蒟蒻不会。
## 思路：排序，排序，还是排序……
### 献上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int year[105],month[105],day[105];
string name[105];
int main()
{
	int n;
	cin>>n;
	for (int i=0;i<n;i++)
	   cin>>name[i]>>year[i]>>month[i]>>day[i];
	for (int i=0;i<n;i++)
	{
		for (int j=i+1;j<n;j++)
		{
		    if (year[i]>year[j]||year[i]==year[j]&&month[i]>month[j]||year[i]==year[j]&&month[i]==month[j]&&day[i]>=day[j])
		    {
		    	swap(name[i],name[j]);
		    	swap(year[i],year[j]);
		    	swap(month[i],month[j]);
		    	swap(day[i],day[j]);
			}
		}
	}
	for (int i=0;i<n;i++)
	   cout<<name[i]<<endl;
	return 0;
}
```

---

## 作者：Obito (赞：42)

这题用结构体很简单，相信我，~~我写的绝对最简单~~
### 好吧我不会说我是看不懂dalao们的题解！！
进入正题；边写边解释。
```cpp
#include<bits/stdc++.h>//传说中的万能头
using namespace std;
int i,j,k,n,m;
struct sb{//结构体定义，不要想歪了。我想的是英文的sb.
	string name;//名字，用string吧，我习惯了；
	int y,m,d,bian;//年，月，日，编号。
}a[1001]; 
int cmp(sb x,sb y){//开始结构体排序，看不懂的小伙伴怎么办，答案：慢慢看；
	return x.y<y.y||x.y==y.y&&x.m<y.m||x.y==y.y&&x.m==y.m&&x.d<y.d||x.y==y.y&&x.m==y.m&&x.d==y.d&&x.bian>y.bian;
    //先按年排，再按月，日，编号。
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);noip时的头文件
	cin>>n;//输入人数
	for(i=1;i<=n;i++){
		cin>>a[i].name>>a[i].y>>a[i].m>>a[i].d;//输入
		a[i].bian=i;//记下输入顺序
	}
	sort(a+1,a+1+n,cmp);//开始快排
	for(i=1;i<=n;i++)//输出
	cout<<a[i].name<<endl;
	return 0;//完美结束
}
/*
3
Yangchu 1992 4 23
Qiujingya 1991 8 1
Luowen 1991 8 1
这是我自己想的数据，可以试一下。
*/

```
## 谢谢dalao们赏脸观看，不好的地方请指正，没过的朋友们加油，一定会过的，最后祝luogu越来越好！！

---

## 作者：Dog_Two (赞：33)

这一题其实并不需要在结构体里面加一个编号。

除了我们熟知的sort，STL还提供了一个稳定的stable\_sort，它能保证排序结果的稳定性。

当然，无论是sort还是stable\_sort，它们都需要排序元素支持 < 的运算符。

所以我们可以在结构体里面重构 < 运算符——


```cpp
#include<bits/stdc++.h>
using namespace std;
struct birth{
    string name;
    int year,mon,day;
    bool operator <(birth tmp)const{
        if(year!=tmp.year) return year<tmp.year;
        if(mon!=tmp.mon) return mon<tmp.mon;
        if(day!=tmp.day) return day<tmp.day;
    }
    //重载运算符 
};
birth per[105];
int n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        char c=getchar();
        //过滤行末换行 
        string N;
        int y,m,d;
        cin>>N>>y>>m>>d;
        per[i]=(birth){N,y,m,d};
    }
    stable_sort(per+1,per+n+1);
    //STL自带的稳定排序 
    for(int i=1;i<=n;i++) cout<<per[i].name<<endl;
    return 0;
}

```

---

## 作者：M_seа (赞：23)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct node{
    char s[24];
    int n,y,r;
}a[120],b[1];//b数值用来交换
int main()
{
    int i,j,n,m,k;
    scanf("%d",&n);
    for (i=0;i<n;i++) scanf("%s %d %d %d",a[i].s,&a[i].n,&a[i].y,&a[i].r);
    for (i=0;i<n-1;i++)
         for (j=i+1;j<n;j++)
         {
             if ((a[i].n>a[j].n) || (a[i].n==a[j].n && a[i].y>a[j].y) || (a[i].n==a[j].n && a[i].y==a[j].y && a[i].r>=a[j].r))    //岁数大就交换到前面去，注意是a[i].r>=a[j].r而不是a[i].r>a[j].r，因为题目上说年龄相等，后输入的先输出
            {
                b[0]=a[i];
                a[i]=a[j];
                a[j]=b[0];//交换
            }
        }
    for (i=0;i<n;i++) printf("%s\n",a[i].s);
    return 0;
}
```

---

## 作者：tllwtg (赞：14)

##这题居然是普及，我也是醉了

##用结构体很快就能做出来

##具体看注释

#上代码：


```cpp
#include<iostream>
#include<algorithm>//sort函数的头文件
struct student{
    char name[30];//注意！！这里不能用string，因为string是一个类，不是数据类型。
    int nf;//年
    int yf;//月
    int h;//日
    int bh;//编号
};
bool cmp(struct student b,struct student c){//自定义一个cmp函数用来和sort排序
    if(b.nf<c.nf){
        return 1;
    }
    else if(b.nf>c.nf){
        return 0;
    }
    else{
        if(b.yf<c.yf){
            return 1;
        }
        else if(b.yf>c.yf){
            return 0;
        }
        else{
            if(b.h<c.h){
                return 1;
            }
            else if(b.h>c.h){
                return 0;
            }
            else{
                if(b.bh>c.bh){
                    return 1;
                }
                else{
                    return 0;
                }
            }
        }
    }
}
using namespace std;
int main(){
    int n;//同题目
    cin>>n;//输入不解释
    struct student stu[n];//开一个struct student类型的数组
    for(int i=0;i<n;i+=1){
        cin>>stu[i].name;//输入不解释
        cin>>stu[i].nf;
        cin>>stu[i].yf;
        cin>>stu[i].h;
        stu[i].bh=i+1;//给编号赋值
    }
    sort(stu,stu+n,cmp);//用sort排序
    for(int i=0;i<n;i+=1){
        cout<<stu[i].name<<endl;//输出不解释
    }
    return 0;//华丽结束
}
```

---

## 作者：linlin (赞：10)

既然题解选择排序都有了那我介绍一种不同的pasca字符串输入方法


众所周知，空格数字都是字符，所以这一题的重点是字符串输入。。。

程序片段

```cpp
begin
readln(p);
for i:=1 to p do
begin
read(z);s:='';//每次读入之前初始化
while z<>' ' do//一直读到空格结束
begin
s:=s+z;
read(z);
end;
a[i]:=s;
readln(n[i],y[i],r[i]);
end;
```
其思路就是吧每次读入的字符不用字符串输入而是不断输入不同字符
这样就能判断到空格结束读入

再读年月日就可以了！！


完整程序（选择排序）








```cpp
var a:array[1..101] of string;
    n,y,r:array[1..101] of longint;
    i,j,t,max,p:longint;
    z:char;
    s,g:string;
begin
readln(p);
for i:=1 to p do
begin
read(z);s:='';
while z<>' ' do
begin
s:=s+z;
read(z);
end;
a[i]:=s;
readln(n[i],y[i],r[i]);
end;
//------------------
for i:=1 to p-1 do
for j:=i+1 to p do
if n[j]<n[i] then begin
t:=n[i];n[i]:=n[j];n[j]:=t;
g:=a[i];a[i]:=a[j];a[j]:=g;
t:=y[i];y[i]:=y[j];y[j]:=t;
t:=r[i];r[i]:=r[j];r[j]:=t;
end
else if (n[j]=n[i])and(y[j]<y[i]) then begin
t:=n[i];n[i]:=n[j];n[j]:=t;
g:=a[i];a[i]:=a[j];a[j]:=g;
t:=y[i];y[i]:=y[j];y[j]:=t;
t:=r[i];r[i]:=r[j];r[j]:=t;
end
else if (n[j]=n[i])and(y[j]=y[i])and(r[j]<r[i]) then begin
t:=n[i];n[i]:=n[j];n[j]:=t;
g:=a[i];a[i]:=a[j];a[j]:=g;
t:=y[i];y[i]:=y[j];y[j]:=t;
t:=r[i];r[i]:=r[j];r[j]:=t;
end
else if (n[j]=n[i])and(y[j]=y[i])and(r[j]=r[i])and((i>j)or(j>i)) then begin
t:=n[i];n[i]:=n[j];n[j]:=t;
g:=a[i];a[i]:=a[j];a[j]:=g;
t:=y[i];y[i]:=y[j];y[j]:=t;
t:=r[i];r[i]:=r[j];r[j]:=t;
end;
//-----------------------
//其实这几个程序段可以放在一起的。。懒得改了
for i:=1 to p do
writeln(a[i]);
end.

```

---

## 作者：Heartlessly (赞：7)

# c的不多啊，来发c的简单代码

## 算法解析

- 本题主要考察sring和struct的运用，先用结构体存下每一个人的姓名，出生年，月，日与每个人输入的编号。写个bool型的cmp函数来做排序的条件，优先度为：年 -> 月 -> 日 -> 编号，注意年月日都相同时编号从大到小输出，最后一遍快排过。

## 示例代码

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
struct note{
    string s;//名字
    int y, m, d, num;//年、月、日和编号
}f[100];
bool cmp ( note a, note b ){//排序函数
    if ( a.y == b.y ){
        if ( a.m == b.m ){
            if ( a.d == b.d ) return a.num > b.num//最后编号
            else return a.d < b.d;;//再次日
        }
        else return a.m < b.m;//其次月
    }
    else return a.y < b.y;//优先年
}
int n;
int main(){
    scanf ( "%d", &n );//总人数
    for ( int i = 1; i <= n; i++ )
    cin >> f[i].s >> f[i].y >> f[i].m >> f[i].d, f[i].num = i;//输入，每个人编号为i
    sort ( f+1, f+n+1, cmp );//sort大法perfect
    for ( int i = 1; i <= n; i++ )
    cout << f[i].s << endl;//输出名字
    return 0;//结束
}
```

---

## 作者：sycqwq (赞：3)

__思路__:这题可以直接sort做，使用结构体，自己写个cmp，进行排序。

__主要代码__:

```cpp
bool cmp(node s1,node s2)//写一个cmp，来排序
{
	if(s1.n!=s2.n)//先判断年，如果年份不同，就直接返回s1.n<s2.n
		return s1.n<s2.n;
	
	 if(s1.y!=s2.y)//继续比较月
		return s1.y<s2.y;
	 if(s1.r!=s2.r)//比较日
		return s1.r<s2.r;
	return s1.h>s2.h;//到最后，比较输入顺序
}
```

__完整代码__:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{//结构体
	string name;
	int n,y,r,h;
}a[105];
bool cmp(node s1,node s2)
{
	if(s1.n!=s2.n)
		return s1.n<s2.n;
	
	    if(s1.y!=s2.y)
			return s1.y<s2.y;
	    if(s1.r!=s2.r)
			return s1.r<s2.r;
		 return s1.h>s2.h;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].name>>a[i].n>>a[i].y>>a[i].r;//输入
		a[i].h=i; 
	}
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++)//输出
	{
		cout<<a[i].name<<endl;
	}
    return 0;
}
```

---

## 作者：大魔鬼灿灿 (赞：3)

# 排序，字符串
## 这道题非常非常显然是字符串+排序，没有什么技巧，个人觉得用结构体比较好做


### 主要思路

```

1.用结构体把每个同学的信息存起来

2.按照年月日从小到大,日期相同按序号从大到小排起来

3.输出排完序的同学的名字就行了

```

### 我的代码

```
1.结构体中的s是每个同学的名字
  年月日是每个同学生日的年月日
  shu是每个同学的输入序号

2.排序时先按年的小--大排
  如果年相同，再按月的小--大排
  如果月也相同时，再按日的小--大排
  如果日相同也时，再按序号的大--小排

3.按排好的顺序输出就可以了

```
## 上代码

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
struct node
{
    string s;
    int year,month,day,shu;
}q[101];
bool cmp1(const node &a,const node &b)
{
    if(a.year<b.year) return 1;
    if(a.year==b.year)
    {
        if(a.month<b.month) return 1;
        if(a.month==b.month)
        {
            if(a.day<b.day) return 1;
            if(a.day==b.day)
            {
                if(a.shu<b.shu) return 0;
                else return 1;
            }
            else  return 0;
        }
        else return 0;
    }
    else return 0;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>q[i].s;
        scanf("%d%d%d",&q[i].year,&q[i].month,&q[i].day);
        q[i].shu=i;
    }
    sort(q+1,q+n+1,cmp1);
    for(int i=1;i<=n;i++)
      cout<<q[i].s<<endl;
    return 0;
}
```

---

## 作者：Xie_BR (赞：2)

# sort 走遍天下  
对于这道题来说，我认为最重要的是审题 ！！！！！  
尤其是那句  
```cpp
(如果有两个同学生日相同,输入靠后的同学先输出)
```  

然后，明白了这个神奇的规则就知道后面应该怎么做了！！！  
于是，建一个结构体， 因为年月份包括出现的次序都是一一绑定的，所以不能乱了顺序。  
然后，我们将这个结构体sort一遍，终点在于cmp上：  
```cpp
int cmp(node a,node b)
{
	if((a.year==b.year) && (a.mon==b.mon) && (a.day==b.day))
	{
		return a.id > b.id;
	}
	if((a.year==b.year) && (a.mon==b.mon))
	{
		return a.day < b.day;
	}
	if(a.year==b.year)
	{
		return a.mon < b.mon;
	}
	return a.year < b.year;
}
```

只要知道了cmp的写法，其他的都好办了！！！

于是：  
# AC 代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define int long long
#define MK 110
using namespace std;
int n;

struct node
{
	char a[MK];
	int year,mon,day;
	int id;
}e[MK];

int cmp(node a,node b)
{
	if((a.year==b.year) && (a.mon==b.mon) && (a.day==b.day))
	{
		return a.id > b.id;
	}
	if((a.year==b.year) && (a.mon==b.mon))
	{
		return a.day < b.day;
	}
	if(a.year==b.year)
	{
		return a.mon < b.mon;
	}
	return a.year < b.year;
}

signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s%lld%lld%lld",&e[i].a,&e[i].year,&e[i].mon,&e[i].day);
		e[i].id = i;
	}
	sort(e+1,e+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		printf("%s\n",e[i].a);
	}
	return 0;
}
```

# ：）

---

## 作者：御·Dragon (赞：2)

## 这题可以快排一下，输出就可以了。我们看看最普通的AC代码：

```
#include<bits/stdc++.h>
using namespace std;
struct Node{
    string name;
    int year,month,day,number;
}a[101];

```

__上面的struct，name记录名字，用string；year记录年份，month记录月，day记录天，number记录顺序__

```

bool cmp(Node a,Node b)//cmp快排函数 
{
	/*
	这个方法有点蠢，很简单明了，大家这个应该看得懂 
	*/ 
    if(a.year ==b.year )//判断年份是否一样 
    {
        if(a.month ==b.month )//月份是否一样 
        {
            if(a.day ==b.day )//日期是否一样 
            {
                return a.number>b.number ;//全一样就返回在前面的 
            }
            else
            {
                return a.day <b.day ;//不然，返回天数少的 
            }
        }
        else
        {
            return a.month <b.month ;//返回月数少的 
        }
    }
    else
    {
        return a.year <b.year ; //返回年数少的 
    }
}

```

__是吧，这上面的cmp快排方法很蠢，所以我想了一中更美妙，好看，简单的方法__

```
bool cmp(opp x,opp y){
	return x.year < y.year //判断年份
	|| (x.year == y.year && x.month < y.month)//年份相同判月份 
	|| (x.year == y.year && x.month == y.month && x.day < y.day)//月份相同看天数 
	|| (x.year == y.year && x.month == y.month && x.day == y.day && x.number > y.number);//否则返回靠前的
}
```
__这样舒服多了，是吧！主程序：__

```

int main()
{
    int n,i,j,m;
    Node t;
    cin>>n;//输入 
    for(i=1;i<=n;i++)//枚举 
    {
        cin>>a[i].name >>a[i].year >>a[i].month >>a[i].day ;//输入月份 
        a[i].number =i;//输定顺序 
    }
    sort(a+1,a+1 + n,cmp);//快排 
    for(i=1;i<=n;i++)
    {
        cout<<a[i].name<<endl;//输出 
    }
    return 0;
}
```

__但是有没有比逐个比较的更简单的呢？有，当然有，看下面！__

```
struct Node{
	string name;
	int number;
    int shunxu;
}a[101];
```

__只剩下number，讲年份、月份、天数统一化天数__

```
for(int i = 1;i <= n; i++){
	cin>>f[i].name>>x[i]>>y[i]>>z[i];
    minx = (minx,x[i]);
    miny = (miny,y[i]);
    minz = (minz,z[i]);
    f[i].shunxu = i;
}
for(int i = 1;i <= n; i++){
	f[i].number = (x[i] - minx) * 365 + (y[i] - miny) * 31 + (z[i] - minz);
}
```

__大家可以看到，我将共有的部分去掉了，这样保证不会爆空间自然cmp函数只要比较number就行了，一样的话，判断shunxu。好了，谢谢大家！__

---

## 作者：bestcow (赞：2)

这题大家运用结构体做很方便哦

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct hh{
    string xm;
    int nf;
    int yf;
    int rq;
    int xh;
};
struct hh d[101];
int n;
int comp(const hh & a,const hh & b)
{
    if(a.nf>b.nf)
    {
        return 0;
    }
    if(a.nf<b.nf)
    {
        return 1;
    }
    else
    {
        if(a.yf>b.yf)
     {
        return 0;
     }
       if(a.yf<b.yf)
     {
        return 1;
     }
     else
     {
         if(a.rq>b.rq)
     {
        return 0;
     }
       if(a.rq<b.rq)
     {
        return 1;
     }
     else
     {
```
return a.xh>b.xh
```cpp
     }
     }
    }
}
int main()
{
    cin>>n;
    for(int x=1;x<=n;x++)
    {
        cin>>d[x].xm>>d[x].nf>>d[x].yf>>d[x].rq;//读入数据
        d[x].xh=x;//记住顺序，万一有生日相等的情况，要看看序号大小
    }
    sort(d+1,d+n+1,comp);//快排，从小到大
    for(int x=1;x<=n;x++)
    {
        cout<<d[x].xm<<endl;//排好后一个个输出吧
    }
}
```

---

## 作者：化学小哥 (赞：2)

一道简单易懂的排序题，可以来一点小技巧，以一个关键字排序，小的靠前；



```cpp
#include<iostream>    
#include<algorithm>    
using namespace std;    
struct ti    
{    
    string name;  
    long long sum;   
}a[10001];    
int compare(const ti & a,const ti & b)    
{      
    if (a.sum<b.sum) return 1;  
    return 0;    
}    
int main()    
{    
    int n,x,y,z;    
    cin>>n;    
    for(int i=1;i<=n;i++)    
    {cin>>a[i].name>>x>>y>>z;
     a[i].sum=x*10000000+y*100000+z*1000+100-i; //本题精髓，将四个关键字熔成一个。
    }  
    sort(a+1,a+n+1,compare);    
    for (int i=1;i<=n;i++)    
     cout<<a[i].name<<endl;  
}
```

---

## 作者：灵光一闪 (赞：2)

表示不会玩``sort``，特发一个结构体+手动if的代码
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<string>
using namespace std;
struct people{//每个人
    string name;//名字
    int year;//年份
    int month;//月份
    int day;//日期
};
people arr[2333];//定义
bool used[2333];//是否被用过
bool checker(int num,int sum){//强大的判断程序，看似复杂，实则简单
    if(arr[num].year<arr[sum].year){
        return false;
    }
    else if(arr[num].year>arr[sum].year){
        return true;
    }
    else{
        if(arr[num].month<arr[sum].month){
            return false;
        }
        else if(arr[num].month>arr[sum].month){
            return true;
        }
        else{
            if(arr[num].day<arr[sum].day){
                return false;
            }
            else{//这里因为后输入的先输出，所以这里直接true
                return true;
            }
        }
    }
}
int main(){
    int point;//当前位置
    int n,tep=0;
    cin>>n;
    for(int i=0;i<n;i++){//输入
        cin>>arr[i].name;
        cin>>arr[i].year;
        cin>>arr[i].month;
        cin>>arr[i].day;
    }
    for(int i=0;i<n;i++){
        while(used[tep]){//一直到没有用过的位置
            tep++;
        }
        string now=arr[tep].name;//初始值
        point=tep;//当前位置
        for(int j=tep+1;j<n;j++){
            if(used[j]){//被用过
                continue;
            }
            if(checker(point,j)){//判断
                point=j;
                now=arr[j].name;
            }
        }
        cout<<now<<endl;
        used[point]=true;
    }
    return 0;
}
```
然后吐槽下题目：这里的名字可能相同但是题目中讲都没讲，差评！最后附上map版（不兹磁重名，所以无法AC

但是这个map版相对于上面来说思维和代码都比较简单，所以放出来（话说我一开始提问的时候有人喷我说``map是为了装*，我真是不能理解……``
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<string>
#include<map>
using namespace std;
map<string,int> mp;//STL万岁！！！
struct people{
    string name;
    int year;
    int month;
    int day;
};
people arr[2333];
bool used[2333];
bool checker(int num,int sum){
    if(arr[num].year<arr[sum].year){
        return false;
    }
    else if(arr[num].year>arr[sum].year){
        return true;
    }
    else{
        if(arr[num].month<arr[sum].month){
            return false;
        }
        else if(arr[num].month>arr[sum].month){
            return true;
        }
        else{
            if(arr[num].day<arr[sum].day){
                return false;
            }
            else{
                return true;
            }
        }
    }
}
int main(){
    int n,tep=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>arr[i].name;
        cin>>arr[i].year;
        cin>>arr[i].month;
        cin>>arr[i].day;
        mp[arr[i].name]=i;
    }
    for(int i=0;i<n;i++){
        while(used[tep]){
            tep++;
        }
        string now=arr[tep].name;
        for(int j=tep+1;j<n;j++){
            if(used[j]){
                continue;
            }
            if(checker(mp[now],j)){
                now=arr[j].name;
            }
        }
        cout<<now<<endl;
        used[mp[now]]=true;//有map就好多了
    }
    return 0;
}
```

The End.

---

## 作者：feecle6418 (赞：2)

这道题的比较函数好像楼下写的都比较的繁琐，其实不必。

比如：

```cpp
if(a>b)return 1;
else return 0;
```
可以写成：

```cpp
return a>b;
```
为什么呢？因为a>b这个表达式的值是一个bool型数，所以函数可以直接返回这个表达式的值。

根据以上，可以写出以下的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
class student {
    public:
        string name;
        int year,month,day;
        int rank;
};
/*简洁比较函数*/
bool cmp(student a,student b) {
    if(a.year!=b.year)return a.year<b.year;
    if(a.month!=b.month)return a.month<b.month;
    if(a.day!=b.day)return a.day<b.day;
    return a.rank>b.rank;
}
student a[105];
int main() {
    int n;
    cin>>n;
    for(int i=0; i<n; i++) {
        cin>>a[i].name>>a[i].year>>a[i].month>>a[i].day;
        a[i].rank=i;
    }
    sort(a,a+n,cmp);
    for(int i=0; i<n; i++) {
        cout<<a[i].name<<endl;
    }
    return 0;
}
```

---

## 作者：Erina (赞：2)

基本思路：使用结构体，方便STL的交换。

注意：必须使用stable\_sort而不是sort

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct p{
    string name;
    int year,month,day;
}ygy[100];
bool operator < (const p &a,const p &b){//代替了正常的comp函数
    return a.year<b.year||(a.year==b.year&&a.month<b.month)||(a.year==b.year&&a.month==b.month&&a.day<=b.day);//要求先输出后来的，所以要添加‘=’号
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>ygy[i].name>>ygy[i].year>>ygy[i].month>>ygy[i].day;
    }
    stable_sort(ygy,ygy+n);
    for(int i=0;i<n;i++){
        cout<<ygy[i].name<<endl;
    }
}
```

---

## 作者：Sinwind (赞：1)

# 1.分析

1. 因为每个同学的姓名与生日是一个整体，需要统一处理，所以用结构体。

2. $sort$函数的使用：[C++ STL之排序(sort)](https://www.luogu.org/blog/Singularwind/sort-algorithm#)。

# 2.思路

$compare$函数：

- 先比较年份。若年份不等，输出小的$($即年份早的$)$。

- 若年份相等，比较月份。若月份不等，输出小的$($即月份早的$)$。

- 若年份、月份相等，比较日子。若日子不等，输出小的$($即日子早的$)$。

- 若年份、月份、日子相等，输出编号大的$($即靠后的同学先输出$)$。

# 3.代码

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

//生日结构体
typedef struct
{
	int year;           //年
	int month;          //月
	int day;            //日
}Birthday;
//学生信息结构体
typedef struct
{
	int id;             //编号
	string name;        //姓名
	Birthday date;      //生日
}Student;
int num;                //学生人数
Student student[105];   //学生信息

//作为sort的第三个参数
bool compare(Student x, Student y)
{
	if(x.date.year != y.date.year)
	{
		return x.date.year < y.date.year;
	}
	else if(x.date.month != y.date.month)
	{
		return x.date.month < y.date.month;
	}
	else if(x.date.day != y.date.day)
	{
		return x.date.day < y.date.day;
	}
	else
	{
		return x.id > y.id;
	}
}

int main(void)
{
	cin >> num;
	for(int i = 0; i < num; i++)
	{
		student[i].id = i + 1;
		cin >> student[i].name
			>> student[i].date.year
			>> student[i].date.month
			>> student[i].date.day;
	}
	
	sort(student, student + num , compare);
	
	for(int i = 0; i < num; i++)
	{
		cout << student[i].name << endl;
	}
	
	return 0;
}
```


---

## 作者：CrashBen (赞：1)

这题很简单只需一个结构体和排序，话不多说，看代码。事实上cmp只是在sort里加佐料的

------------
**注：sort要用<algorithm>库**
  ```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <set>
#include <map>
#include <cmath>
#include <stdlib.h>
using namespace std;
struct no{
    string mz;//姓名 
    int nf,yf,r,xh;//年份，月份，日，序号 
}a[1001];//不用太大 
int cmp(no a,no b) 
{
    if(a.nf==b.nf)//如果年份相等比月份 
    {
        if(a.yf==b.yf)//如果月份相等比日 
        {
            if(a.r==b.r)//如果日相等比先后顺序 
            {
                return a.xh>b.xh;
            }
            return a.r<b.r;
        }
        return a.yf<b.yf;
    }
    return a.nf<b.nf;
}
int main()
{
    int n;
    cin>>n;//读入n 
    for(int i=1; i<=n; i++) 
    {
        cin>>a[i].mz>>a[i].nf>>a[i].yf>>a[i].r;
        a[i].xh=i;//计录序号 
    }
    sort(a+1,a+1+n,cmp);//排序 
    for(int i=1; i<=n; i++)//输出 
    {
        cout<<a[i].mz<<endl;
    }
    return 0;//完美结束，棒。 
} 
```
新手一定要养成打 return 


---

## 作者：Warriors_Cat (赞：1)

本蒟蒻想问一下大家，

## 为什么不用优先队列呢？？

看了一下其他dalao的题解，都是直接sort过的。

但本蒟蒻想出了一个特别巧的办法：开优先队列！

优先队列说的是这么一个事情：

每次将队列中的量按代码定义的从大到小排列，

意义上越小的在越后面。

也就是说，优先队列自带了排序，不用手打sort了。

所以，只需要将<符号重载即可。

优先队列的定义如下：

priority_queue</*加一个类型*/> q;

优先队列有以下几个基本操作：

q.push():表示将一个东西存到队列尾部

q.pop():将队列最上面的东西弹出

q.top():取队列最上面的东西的值

本蒟蒻的

## 代码如下：
```
#include<bits/stdc++.h>//习惯用万能头文件，不用老是打一些乱七八糟的头文件
using namespace std;
struct node{//定义结构体 
	int idx;//存储下标，如有生日相同时使用 
	string nm;//存储名字 
	int yr, mh, dy;//year, month, day, 年月日 
	bool operator<(const node&rhs)const{//开始怼重载代码 , rhs = right hand side
		if(yr == rhs.yr && mh == rhs.mh && dy == rhs.dy) return idx < rhs.idx;//若年月日都相同，则下标小的在后面 
		if(yr == rhs.yr && mh == rhs.mh) return dy > rhs.dy;//若年月相同，则日大的在后面 
		if(yr == rhs.yr) return mh > rhs.mh;//若年相同，则月大的在后面 
		return yr > rhs.yr;//若年月日都不相同，则年大的在后面 
	}
}a[110];//定义一个node类型的数组 
int n;//定义人数 
priority_queue<node> q;//开一个优先队列 
int main(){
	scanf("%d", &n);//输入不多讲，不用cin是因为比较慢
	for(int i = 1; i <= n; ++i){
		cin >>a[i].nm;//string只能用cin, cout 
		a[i].idx = i;//存储下标 
		scanf("%d %d %d", &a[i].yr, &a[i].mh, &a[i].dy);//输入年月日 
		q.push(a[i]); //将a[i]存到优先队列里面 
	}
	for(int i = 1; i <= n; ++i){
		node x = q.top();//取队列最上面的值 
		q.pop();//将最上面的值移除 
		cout << x.nm << endl;//输出名字 
	}
	system("pause")//日常防伪代码 
	return 0;//再见！ 
}
```
STL最巨！！STL最强！！

这就是优先队列的做法，跟sort时间差不多。

但看上去是不是更加~~高端，大气，上档次~~高大上了呢？

所以，大家不要忘记还有优先队列这个东东。
## 求通过！！求通过！！求通过！！
### 重要的事情说3遍！
谢谢各位读者的阅读。

---

## 作者：肥婆纳妾 (赞：1)

## MAP 无脑做题法
```cpp

#include<bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, w = 0; char ch = 0;
    while (!isdigit(ch))w |= ch == '-', ch = getchar();
    while (isdigit(ch))x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
    return w ? -x : x;
}
int main() {
    map<long long, vector<string > >data;
    int t1, t2, t3;
    string temStr;
    int n;
    n = read();
    for (int i = 1; i <= n; ++i) {
        cin >> temStr >> t1 >> t2 >> t3;
        data[t3 + t2 * 100 + 10000 * t1].push_back(temStr);
    }
    for (auto itor = data.begin(); itor != data.end(); ++itor)
        for (int i = itor->second.size() - 1; i >= 0; --i)
            cout << itor->second[i] << endl;
    return 0;
}
```

---

## 作者：半仙胡小桃 (赞：1)

这种类型的题目很明显是使用sort+结构题排序的

按照题目的要求把年月日设为第一第二第三关键字即可

要注意全部相同时后输入的先输出

对于名字的处理，还是string最吼辣

```cpp
#include <cstdio>
#include <string>
#include <algorithm>
#include <iostream>
using namespace std;
struct node{
    int n,y,r,id;
    string name;
}a[9999];
bool comp(const node&a,const node&b)
{
    if(a.n>b.n) return 0;
    if(a.n<b.n) return 1;
    if(a.y>b.y) return 0;
    if(a.y<b.y) return 1;
    if(a.r>b.r) return 0;
    if(a.r<b.r) return 1;
    return a.id>b.id;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
     cin>>a[i].name>>a[i].n>>a[i].y>>a[i].r,a[i].id=i;
    sort(a+1,a+n+1,comp); 
    for(int i=1;i<=n;i++)
     cout<<a[i].name<<endl;
    return 0;
}
```

---

## 作者：铁盒 (赞：1)

此题非常简单，是一道纯水的排序，但是要注意一开始读入的是字符串，接下来附上代码：

```cpp
program ye;
  type
    x=record//在这里我用了一个记录类型
      x1:string[20];
      x2:longint;
      x3:longint;
      x4:longint;
    end;
  var
    a:array[1..100]of x;
    s:x;
    n,i,j:longint;
    t:string;
begin
  readln(n);
  for i:=1 to n do
    begin
      readln(t);//通过字符串读入
      a[i].x1:=copy(t,1,pos(' ',t)-1);//依次附给a数组
      delete(t,1,pos(' ',t));
      val(copy(t,1,pos(' ',t)-1),a[i].x2);
      delete(t,1,pos(' ',t));
      val(copy(t,1,pos(' ',t)-1),a[i].x3);
      delete(t,1,pos(' ',t));
      val(copy(t,1,length(t)),a[i].x4);
    end;
  for i:=1 to n do
    for j:=1 to n-i do//由于先输入的在前，所以我用了个冒排
      if (a[j].x2<a[j+1].x2)or
         ((a[j].x2=a[j+1].x2)and(a[j].x3<a[j+1].x3))or
         ((a[j].x2=a[j+1].x2)and(a[j].x3=a[j+1].x3)and(a[j].x4<a[j+1].x4))then
        begin//交换，不过用了记录就是好，一次性全部交换完
          s:=a[j];
          a[j]:=a[j+1];
          a[j+1]:=s;
        end;
   for i:=n downto 1 do
     writeln(a[i].x1);//输出
end.
```

---

## 作者：Hanzire76 (赞：1)

# [Hanzire 的博客](https://zxjnvrgvp.github.io/)

以上是打广告↑↑↑

# 思路
我的思路很简单，直接把年月日处理成一个数字，之间排序就OK。

怎么处理呢？

年，月，日，按顺序拼接，如果是0几月，0几日，就在那一位补0。这样从高位看下来，就符合从小往大排序的标准了。具体就是年×10000，后面多出4个0用来补位，月×100，再三者加起来。

但要注意还是要记录读入的顺序，假如生日相同就用读入顺序判断吧。

# 代码
```cpp
#include "iostream"
#include "algorithm"
#include "cstdio"
using namespace std;

int n;

struct node
{
    char s[30];
    int birthday, order;
} a[105];

inline bool cmp(node x, node y)
{
    if (x.birthday == y.birthday)
        return x.order > y.order;

    return x.birthday < y.birthday;
}

int main(int argc, char const *argv[])
{
    scanf("%d", &n);
    int x, y, z;
    for (int i = 1; i <= n; i++)
    {
        scanf("%s%d%d%d", a[i].s, &x, &y, &z);
        a[i].birthday = x * 10000 + y * 100 + z;
        a[i].order = i;
    }
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= n; i++)
        cout << a[i].s << endl;
    return 0;
}

```


---

## 作者：Liu_zj (赞：1)

~~好久没写题解了来水篇~~
分析题目可以得出结构体排序
使用sort排序结构体的两种简单方法
```
struct student
{
...
}balabala[MAXN];
```
定义排序规则

第一种
```
bool cmp(const student &x,const student &y)
```
第二种
```
bool cmp(student x,student y)
```

之后sort(balabala+1,balabala+n+1,cmp);

题目要求“如果有两个同学生日相同,输入靠后的同学先输出”
在排序时动一下手脚×
```
bool cmp(student x,const node &y)
{
	if(x.num==y.num)//日期相等
	return x.innum>y.innum;//按输入顺序排序
	return x.num<y.num;//否则按日期排序
}
```
也可以直接用三目运算符
```
bool cmp(student x,const node &y) return x.num==y.num?x.innum>y.innum:x.num<y.num;
```

num用来计算日期

可以将年月日存到一个八位数中


直接比较
```
cin>>sts[i].name>>y>>m>>d;//年月日
sts[i].num=y*10000+m*100+d;
```
下方代码


.
```
#include<bits/stdc++.h>
using namespace std;
struct student{
	string name;
	int num;
	int innum;
}sts[1001];
bool cmp(student x,student y){
	return x.num==y.num?x.innum>y.innum:x.num<y.num;
}
int main()
{
	ios::sync_with_stdio(false);//加速
	int n,y,m,d;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>sts[i].name>>y>>m>>d;
		sts[i].num=y*10000+m*100+d;
		sts[i].innum=i;
	}
	sort(sts+1,sts+n+1,cmp);//排序
	for(int i=1;i<=n;i++)
		cout<<sts[i].name<<endl;
}
```

---

## 作者：_Misaka_Mikoto (赞：1)

看到这道题首先想到时间戳。多年搞javascript与网路安全等方面，这道题可以用类时间戳。

时间戳定义：到1970年1月1日零点，之间相差的秒数（10位），其中13位就是多了毫秒

类时间戳，就是这道题，我们自己定义的时间戳，即到1970年1月1日，中间相差的天数。

//曾经写了一个小程序计算放假时间(Fonggaa for cpp),和同学一起写的，写了第五个版本了，同样是计算天数，精确到秒，理论上也可以用时间戳，算上一点类似通的经验吧。

其次就是排序要用选择，因为冒泡多半都会TLE。

附上ac代码。soma函数是计算天数的函数。使用葡萄牙语或其他语言同英语，可以避免变量名，函数名重复。至于我连拼音都不会，所以没有用拼音。

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
int soma(int year,int month){
	int soma1;
	if(month==1) soma1=0;
	else if(month==2) soma1=31;
	else if(month==3) soma1=59;
	else if(month==4) soma1=90;
	else if(month==5) soma1=120;
	else if(month==6) soma1=151;
	else if(month==7) soma1=181;
	else if(month==8) soma1=212;
	else if(month==9) soma1=243;
	else if(month==10) soma1=273;
	else if(month==11) soma1=304;
	else if(month==12) soma1=335;
	if(year%4==0 && year%100!=0 || year%400==0) return soma1+1; else return soma1;
}
int main(){
	int n,ano[105],mes[105],dia[105],tmpint;
	long long day[105],temp;
	string nome[105],tmpstr;
	cin>>n;
	for(int i=0;i<n;i++){
	    cin>>nome[i]>>ano[i]>>mes[i]>>dia[i];
	    day[i]=(ano[i]-1960)*365+soma(ano[i],mes[i])+dia[i];
	}
	for(int i=0;i<n-1;i++){
	    int k=i;
	    for(int j=i;j<n;j++){
	        if(day[j]>day[k]) k=j;
	    }
	    temp=day[i];
	    day[i]=day[k];
	    day[k]=temp;
	    tmpint=ano[i];
	    ano[i]=ano[k];
	    ano[k]=tmpint;
        tmpint=mes[i];
	    mes[i]=mes[k];
	    mes[k]=tmpint;
	    tmpint=dia[i];
	    dia[i]=dia[k];
	    dia[k]=tmpint;
	    tmpstr=nome[i];
	    nome[i]=nome[k];
	    nome[k]=tmpstr; 
	}
	for(int i=n-1;i>=0;i--){
	    cout<<nome[i]<<endl;
	}
	return 0;
}
```

---

## 作者：遥望天空 (赞：1)

看了大佬的题解表示看不懂......


------------

```c
#include<iostream>
using namespace std;
struct qwe{
	char a1[10000];
	int a2,a3,a4;
}a[10000];//定义结构体，便于排序
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
	cin>>a[i].a1>>a[i].a2>>a[i].a3>>a[i].a4;
    //不能直接输入a[i],蒟蒻勿喷
    a[i].a2=a[i].a2*10000+a[i].a3*100+a[i].a4;
	}
	for(int i=1;i<n;i++)
	   for(int j=i+1;j<=n;j++)
	   if(a[i].a2>=a[j].a2)
       //'='不能少，因为是生日相同先输入的后输出
	   swap(a[i],a[j]);//排序
	for(int i=1;i<=n;i++)
	cout<<a[i].a1<<endl;//输出名字
	return 0;//程序易懂，请各位大佬指出不足
 } 
```
------------



---

## 作者：VenusM1nT (赞：1)

一道不难想的~~（水）~~题

作为一个 STL 走火入魔的人，不用 sort 肯定是不行的

那么问题就是 cmp 比较函数怎么写

思路很简单啦

具体见代码


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node
{
    string name;
    int year,month,day,num;//结构体存下数据 
}a[105];
int n;
bool cmp(node x,node y)//核心代码 其实可以写得很简洁，不懂为什么那么多dalao要写一长串……
{
    if(x.year!=y.year) return x.year<y.year;
    //如果年份不同，直接比较即可 
    else if(x.month!=y.month) return x.month<y.month;
    //如果年份相同月份不同，比较月份即可 
    else if(x.day!=y.day) return x.day<y.day;
    //如果年月相同日不同，比较日即可 
    else return x.num>y.num;
    //如果年月日都相同比较序号 
}
int main()
{
    cin >> n;
    for(int i=1;i<=n;i++)
    {
        cin >> a[i].name >> a[i].year >> a[i].month >> a[i].day;
        a[i].num=i;//读入数据，记录序号 
    }
    sort(a+1,a+n+1,cmp);//草率的排序 
    for(int i=1;i<=n;i++) cout << a[i].name << endl;//输出即可~ 
    return 0;
}
```

---

## 作者：微雨燕双飞 (赞：1)

来一发题解。。真不懂这题怎么有那么多人不看题就瞎写，83分的一大堆一大堆的，况且题目又不长。。。

好了，本题的标签解法是选择排序，然而就像楼下许多大佬一样，本人也不要脸地写了结构体+快排的标配（selectsort又慢代码又长，真心不如c++自带的sort性价比高）。

不多说了，上100分代码：

```cpp
#include<iostream>
#include<string> 
#include<algorithm>
using namespace std;
int n;
struct op
{
  string name;
  int year,month,day,order; //加一个order，用来判断输入先后
};
op p[105];
bool cmp(const op&a,const op&b) //快排标配comp，不会看书
{
  if(a.year<b.year) return 1; //年相同比月，月相同比日，日相同比输入先后即可，简洁明了
  if(a.year>b.year) return 0;
  if(a.month<b.month) return 1;
  if(a.month>b.month) return 0;
  if(a.day<b.day) return 1;
  if(a.day>b.day) return 0;
  if(a.order<b.order) return 0;
    else return 1;
}
int main()
{
  cin>>n;
  for(int i=1; i<=n; i++) 
  {
    cin>>p[i].name>>p[i].year>>p[i].month>>p[i].day; //结构体读入
    p[i].order=i; //记录编号
  }
  sort(p+1,p+n+1,cmp); //快排，bongbong，搞定
  for(int i=1; i<=n; i++) cout<<p[i].name<<endl; //输出
  return 0;
} //全篇结束
```

---

## 作者：ww3113306 (赞：1)

一个教了三次才过，前两次为了图方便，直接将年份\*100+月份\*10+日作为每一个人的值，然后排序，于是wa了4个点，然后改成年份月份日不同优先度就过了，所以在此要提醒广大同胞，，把重要的\*xxx是有风险的，这里我估计是某几个数据中月份可能超过100

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    string name;
    int num,a,b,c;
};
int n;abc student[105];
bool cmp(abc x,abc y)
{
    if(x.a!=y.a) return  x.a<y.a;//要年龄最大的先输出，不是数字最大的
    if(x.b!=y.b) return  x.b<y.b;
    if(x.c!=y.c) return  x.c<y.c;    
    if(x.num!=y.num) return x.num>y.num;//这个点注意，后输入，先输出
}
int main()
{
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        cin>>student[i].name;
        scanf("%d%d%d",&student[i].a,&student[i].b,&student[i].c);
        student[i].num=i;
    }
    sort(student+1,student+n+1,cmp);
    for(i=1;i<=n;i++) cout<<student[i].name<<endl;
    return 0;
}
```

---

## 作者：yyy2015c01 (赞：1)

使用结构体存OI组学生的信息。

STL 威武~

```cpp

#include<iostream>
#include<algorithm>
#include<cstdlib>
using namespace std;
struct oi{
       string name;
       int y;
       int m;
       int d;
       int num;
}a[1001];
int comp(const oi &a,const oi &b)//比较函数
{
    if (a.y>b.y) return 0;
    if (a.y<b.y) return 1;
    if (a.m>b.m) return 0;
    if (a.m<b.m) return 1;
    if (a.d>b.d) return 0;
    if (a.d<b.d) return 1;
    if (a.num>b.num) return 1;
    return 0;
}
int main()
{
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>a[i].name>>a[i].y>>a[i].m>>a[i].d;
        a[i].num=i;
    }
    sort(a+1,a+n+1,comp);//C党表示轻松极了
    for (int i=1;i<=n;i++)
    {
        cout<<a[i].name<<endl;
    }
    //system("pause");
}


```

---

## 作者：野菜汤 (赞：1)

题解：

我就直说了，这题真的是超级简单，只要将他们的生日日期比较一下大小既可以解决问题了。但是这一题是为了字符串初学者准备的，此题的关键所在就是它的读入与分解方式，这种方式在以后也是会经常用到，所以这里并不提供完整的题解，而是提供读入数据的分解方式，以供参考。

```delphi
for i:=1 to n do  begin
    readln(s);{先读入成字符串}
    m:=pos(' ',s);{需找第一个空格}
    b[i]:=copy(s,1,m-1);{记录空格前的数据}
    delete(s,1,m);{将空格一并删掉}
    m:=pos(' ',s);{与上同}
    val(copy(s,1,m-1),a[i,1]);{因为是数字，所以转化}
    delete(s,1,m);{再删}
    m:=pos(' ',s);
    val(copy(s,1,m-1),a[i,2]);
    delete(s,1,m);
    val(copy(s,1,length(s)),a[i,3]);{因为删到最后只剩一个数据所以直接记录}
    end;
```
若是能好好运用以上方法，那么对将来也是有着莫大的帮助。


---

## 作者：走开啊你 (赞：0)

## 【解题思路】
此题范围较小！可以采用蒟蒻都会的选择排序！

只要进行字符串处理，取出姓名和年月日就可进行排序！

 _上pascal代码！！！_ 

```pascal
var n,i,t,j,k:longint;
s,t1:string;
a:array[0..100] of string;
b,c,d,f:array[0..100] of longint;
begin
readln(n);
for i:=1 to n do
  begin
  readln(s);
  s:=s+' ';//方便取出最后一位
  k:=pos(' ',s);a[i]:=copy(s,1,k-1);//姓名delete(s,1,k);
  k:=pos(' ',s);val(copy(s,1,k-1),b[i]);//年delete(s,1,k);
  k:=pos(' ',s);val(copy(s,1,k-1),c[i]);//月delete(s,1,k);
  k:=pos(' ',s);val(copy(s,1,k-1),d[i]);//日delete(s,1,k);
  f[i]:=i;
  end;
for i:=1 to n-1 do
  for j:=i+1 to n do//选择排序
    if (b[i]>b[j]) or (b[i]=b[j]) and (c[i]>c[j]) or (b[i]=b[j]) and
    (c[i]=c[j]) and (d[i]>d[j]) or (b[i]=b[j]) and
    (c[i]=c[j]) and (d[i]=d[j]) and (f[i]<f[j]) then
      begin
      t:=b[i];b[i]:=b[j];b[j]:=t;
      t:=c[i];c[i]:=c[j];c[j]:=t;
      t:=d[i];d[i]:=d[j];d[j]:=t;
      t1:=a[i];a[i]:=a[j];a[j]:=t1;
      t:=f[i];f[i]:=f[j];f[j]:=t;//始终不变的交换
      end;
for i:=1 to n do writeln(a[i]);//输出姓名
end.
```
（解析中的一些提示是给萌新看的，大神勿喷，这是不尊重他人的行为！！！） 完结撒花~(≧▽≦)/~啦啦啦



---

## 作者：tryrtj (赞：0)

刚刚看到这题时，又深刻感到了不学结构体的恐怖。。

我tryrt就是死，死外边，从这里跳下去，也不会用一个结构体！

年份只要大，不用管月日，月再大，不用考虑日。于是就产生了好多人用过的，题解中也有大佬试过，但是问题就是这样容易WA,TLE
```
nian*10000+yue*100+ri;
```

然后就开心了，因为数据范围比较小，冒泡能过。但是，当我码字开心时，看到这句话

### 如果有两个同学生日相同,输入靠后的同学先输出

头疼中。。。如果判断是这样的话

```
for(int i=0;i<n-1;i++){
	if(a[i]<=a[i+1]){
		fanzhuan(i);
	}
}
```

很容易发现其实这样是死循环，因为两个相等的值会永远永远永永远远调换位置，后来我就又想到了用数组存已变换位置的元素，不过，如果这样

a 1 2 3

b 1 2 3

c 1 2 3

那么输出就是bac，因为b,a已经被标记，如果再加判断那就太麻烦了；

于是，新的思路，如果我正着输出最后输入的，意思就是反着输出最靠前的，问题迎刃而解，因为不需要考虑相同数值！不需要考虑相同数值！！不需要考虑相同数值！！！

判断条件如下

```
for(int i=n-2;i>=0;i--){
        if(shi[i]<shi[i+1]){
            fanzhuan(i);
        }
    }
```

然后输出就是这样的

```
for(int i=n-1;i>=0;i--){
        cout<<ming[i]<<endl;
    }
```

就可以看成最普通的排序问题，然后就是最好的完整代码：

```
#include<iostream>
using namespace std;
string ming[105];//存名字
unsigned long long shi[105];//存生日
int n;
void asd(){
    bool g=false;//节省递归调用次数
    for(int i=n-2;i>=0;i--){//倒着判断
        if(shi[i]<shi[i+1]){//交换，值小的反而排后面
            int t=shi[i];
            shi[i]=shi[i+1];
            shi[i+1]=t;
            string s;
            s=ming[i];
            ming[i]=ming[i+1];
            ming[i+1]=s;
            g=true;
        }
    }
    if(g==true)asd();//递归冒泡
    return;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>ming[i];
        int nian,yue,ri;
        cin>>nian>>yue>>ri;
        shi[i]=nian*10000+yue*100+ri;//求生日，注意，系数大一点，不然容易WA
    }
    asd();
    for(int i=n-1;i>=0;i--){
        cout<<ming[i]<<endl;//反着输出
    }
    return 0;//结束
}
```

希望能给大家带来写帮助^_^

---

## 作者：Drinkkk (赞：0)

/\*
题解 P1104

\*/
```cpp
#include <cstdio>//头文件
#include <cstring>
struct nod{ char name[101];int sy,sm,sd,sx; } f[101];//结构体
void px(int l,int r)//快排函数
{
    int x=l,y=r,m1=f[(l+r)/2].sy,m2=f[(l+r)/2].sm,m3=f[(l+r)/2].sd,m4=f[(l+r)/2].sx;//分别存储当前的中间的年、月、日以及读入的顺序
    while(x<=y)//如果左边的边界小于等于右边的边界就执行
    {
        while((f[x].sy<m1) || (f[x].sy==m1 && f[x].sm<m2) || (f[x].sy==m1 && f[x].sm==m2 && f[x].sd<m3) || (f[x].sy==m1 && f[x].sm==m2 && f[x].sd==m3 && f[x].sx>m4))//判断是否满足条件
        {
            x++;//向右
        }
        while((f[y].sy>m1) || (f[y].sy==m1 && f[y].sm>m2) || (f[y].sy==m1 && f[y].sm==m2 && f[y].sd>m3) || (f[y].sy==m1 && f[y].sm==m2 && f[y].sd==m3 && f[y].sx<m4))//判断是否满足条件
        {
            y--;//向左
        }
        if(x<=y)//如果左边的边界小于等于右边的边界就互相交换
        {
            nod t=f[x];
            f[x]=f[y];
            f[y]=t;
            x++;
            y--;
        }
    }
    if(l<y)//递归
    {
        px(l,y);
    }
    if(x<r)//递归
    {
        px(x,r);
    }
}
int main()
{
    int n=0;
    scanf("%d",&n);//读入数据
    for(int i=1;i<=n;i++)
    {
        scanf("%s %d %d %d",f[i].name,&f[i].sy,&f[i].sm,&f[i].sd);
        f[i].sx=i;
    }
    px(1,n);//快排
    for(int i=1;i<=n;i++)//输出名字
    {
        printf("%s\n",f[i].name);
    }
    return 0;
}
```

---

## 作者：mike_he (赞：0)

多关键字排序，全部判断之后如果都相等，再返回id大小的比较结果。要注意是后输！入！的！先！输！出！(坑了两个点WA)

这里对结构体进行[]重载，方便数据输入和比较

[codec]




```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
struct P{
    string name;
    int birth[4];
    int id;
    int& operator [](const int&x){
        return birth[x];
    }
}list[10001];
bool cmp(P a,P b){
    if(a[0]!=b[0]) return a[0]<b[0];
    if(a[1]!=b[1]) return a[1]<b[1];
    if(a[2]!=b[2]) return a[2]<b[2];
    return a.id>b.id;
}
int main(){
    int N;
    cin>>N;
    for(int i=0;i<N;++i){
        cin>>list[i].name>>list[i][0]>>list[i][1]>>list[i][2];
        list[i].id=i;
    }
    sort(list,list+N,cmp);
    for(int i=0;i<N;++i){
        cout<<list[i].name<<"\n";
    }
    return 0;
}
[/codec]
```

---

## 作者：May_Forever (赞：0)

啊啊啊感觉用冒泡的自己好弱→\_→

一点一点判断，for(i=1;i<n;++i)for(j=i+1;j<=n;++j)这时，需要改变的情况共有以下三种：

1.y[i]>y[j]

2.y[i]=y[j]且m[i]>m[j]

3.y[i]=y[j]且m[i]=m[j]且d[i]>=d[j](用">="是因为原题说如果两人一样大,后输入的排在前面)

当然，代码实现时我是直接if嵌套的。。。。

总之，是道水题，而且数据好弱n才100。。。。


下面是我的代码：





```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
string s[200];
int n,y[200],m[200],d[200];
void swap(int &a,int &b){
    int t=a;a=b;b=t;
}
void exchange(int i,int j){
    string t=s[i];s[i]=s[j];s[j]=t;
    swap(y[i],y[j]);
    swap(m[i],m[j]);
    swap(d[i],d[j]);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)cin>>s[i]>>y[i]>>m[i]>>d[i];
    for(int i=1;i<n;++i)
        for(int j=i+1;j<=n;++j)
            if(y[i]>y[j])exchange(i,j);else
                if(y[i]==y[j])if(m[i]>m[j])exchange(i,j);else
                    if(m[i]==m[j])if(d[i]>=d[j])exchange(i,j);
    for(int i=1;i<=n;++i)cout<<s[i]<<endl;
}
```

---

## 作者：ArnoD (赞：0)

多关键字排序，不难但是很烦

```delphi

var
  n,i,j,t:longint;
  s,st:string;
  year,month,day,id
  :array[1..100] of longint;
  name:array[1..100] of string;
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(s);
    name[i]:=copy(s,1,pos(' ',s)-1);
    delete(s,1,pos(' ',s));
    val(copy(s,1,pos(' ',s)-1),year[i]);
    delete(s,1,pos(' ',s));
    val(copy(s,1,pos(' ',s)-1),month[i]);
    delete(s,1,pos(' ',s));
    val(s,day[i]);//字符串操作。。。
    id[i]:=i;
  end;
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if (year[j]>year[i])or(year[j]=year[i])and(month[j]>month[i])or(year[j]=year[i])and(month[j]=month[i])and(day[j]>day[i])or(year[j]=year[i])and(month[j]=month[i])and(day[j]=day[i])and(id[j]<id[i]) then//按生日排序
      begin
        t:=year[i];
        year[i]:=year[j];
        year[j]:=t;
        t:=month[i];
        month[i]:=month[j];
        month[j]:=t;
        t:=day[i];
        day[i]:=day[j];
        day[j]:=t;
        t:=id[i];
        id[i]:=id[j];
        id[j]:=t;
        st:=name[i];
        name[i]:=name[j];
        name[j]:=st;
      end;
  for i:=1 to n do
    writeln(name[n-i+1]);//一开始题目看错了，懒得改，就这样了吧
end.

```

---

## 作者：pengpeng (赞：0)

我不会用comp函数......看看题解没有手写排序过程，我就写了一个....希望你能看懂

```cpp

#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct node
{string n;int y,m,d,num;}a[1000];
string s;
int i,j,k,n,m;
int main()
{    cin>>n;
    for(i=1;i<=n;i++)
     {cin>>a[i].n>>a[i].y>>a[i].m>>a[i].d;a[i].num=i;}
    //sort(a+1,a+n+1,comp);
    for(i=1;i<n;i++)
     for(j=i+1;j<=n;j++)
      if((a[i].y>a[j].y)||
          (a[i].y==a[j].y&&a[i].m>a[j].m)||
        (a[i].y==a[j].y&&a[i].m==a[j].m&&a[i].d>a[j].d)||
        (a[i].y==a[j].y&&a[i].m==a[j].m&&a[i].d==a[j].d&&a[i].num<a[j].num))
          {k=a[i].y;a[i].y=a[j].y;a[j].y=k;
             k=a[i].m;a[i].m=a[j].m;a[j].m=k;
             k=a[i].d;a[i].d=a[j].d;a[j].d=k;
             s=a[i].n;a[i].n=a[j].n;a[j].n=s;}
      
    for(i=1;i<=n;i++)cout<<a[i].n<<endl;
    return 0;}
 
```

---


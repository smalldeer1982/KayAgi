# 车厢重组

## 题目描述

在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。


## 样例 #1

### 输入

```
4
4 3 2 1 ```

### 输出

```
6```

# 题解

## 作者：小学生 (赞：1059)

- 我看了其他题解都是做了排序，可是题目只是问需要多少次移动，没问排序结果啊！！！

- 所以我没有做排序，只是迭代去计算每个数字前有几个数字比它大，这意味着它必须要移动几次。

- 没有做冒泡排序，双层循环写法也和冒泡无关。没人发布这种思路的题解，望管理员通过。

```cpp
#include <iostream>
using namespace std;
int n, sum;
int main()
{
    cin >> n;
    int a[n];
    for (int i = 0; i < n; ++i)
        cin >> a[i];
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < i; ++j)
            if (a[j] > a[i])
                ++sum;
    cout << sum;
    return 0;
}

```

---

## 作者：star_magic_young (赞：105)

这道题由于数据较小，可用冒泡排序做出来

这里介绍一种数据较大时的解法

##归并排序

其思想就是把一段数分成两段，把分好的接着分，，，分到不能分，

然后把分的两段合并，

**由于两段是有序的**，所以我们可以只要用两个指针指向两段开头，然后比较指针指向的数字，

如果要从大到小排序，就比较两个变量，大的放在新开数组里，同时指针往后指。如果指完了，就把没指完的那一段

全部放在数组后面，最后把排好的数组赋值给原数组即可。


对于这道题，因为要求逆序对，在排序时只要加一句就行：


如果数列右端的放入新数组，计数器加上左边剩余数字个数


假设有数组 1 5 3 6 4 2从大到小排序，分治后会得到 1 3 5   2 4 6 两段


首先，比较 1 2，1放入新数组，由于1在左边，所以没有逆序对


然后，比较 3 2，2放入新数组，但由于2在右边，所以产生了逆序对，数量为 左边剩余数字个数（**因为数字排列好了，这个数和最小的数都是逆序对，那和后面的大数也会构成逆序对**）


，，，


最后得到有序的数组


代码如下


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,a[200010],rr[200010];
unsigned long long ans;
void jj(int l,int r)   //归并过程 l,r为当前处理的数字段的左右边界
{
    if(l==r) return;  //如果只有一个数就不要排序
    int x=(l+r)/2;   //去中间的下标
    jj(l,x);
    jj(x+1,r);   //分成左右两段排序
    int t1=l,t2=x+1,xx=0;  //t1 左数组下标 t2 右数组下标 xx 新数组下标
    while(t1<=x&&t2<=r)  //排序，直到某个指针到达边界
       {
        if(a[t1]<=a[t2]) //如果左端小于等于右段
           {
            xx++;
            rr[xx]=a[t1];  //插入新数组，下标移动，没有产生逆序对
            t1++;
        }
        else  //否则
        {
            xx++;
            rr[xx]=a[t2];
            t2++;   //插入新数组，下标移动
            ans+=x-t1+1;  //产生了逆序对，计数器加上左边剩余数字个数
        }
    }
    while(t1<=x) //如果左边有数字没排进去，就放进去
    {
        xx++;
        rr[xx]=a[t1];
        t1++;
    }
    while(t2<=r) //右边同理
    {
        xx++;
        rr[xx]=a[t2];
        t2++;
    }
    for(int i=1;i<=xx;i++) a[l+i-1]=rr[i]; //把原数组覆盖为新数组
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    jj(1,n); //左右边界1，数组数字个数
    cout<<ans; //输出逆序对个数
    return 0;
}
```

此题为P1980的数据缩小版


---

## 作者：Tyler2 (赞：68)

本蒟蒻第二次写题解，求管理员通过！

------------


这个相当于一个冒泡排序，就以样例为例：

输入了四个数，如表：

4  3  2  1

先将1号车厢归位

1  4  3  2

共交换了3次，前面有3个比1大的数；再将2归位：

1  2  4  3

共交换了2次，前面有2个比2大的数；再将3归位：

1  2  3  4

共交换了1次，前面有1个比3大的数；再将4归位：

此时4已归位，前面有0个比4大的数.

这和冒泡排序原理一样。

C/C++代码如下：

```cpp
#include<stdio.h>
int main()
{
	int n;
	scanf("%d",&n);
	int a[n+1],ans;
	ans=0;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			if(a[i]<a[j])
				ans++;
	printf("%d",ans);
}
```


---

## 作者：Surpersolo (赞：28)

```cpp
#include <bits/stdc++.h>//废话不多说，万能头文件直接上 
using namespace std;
int n,i,j,a[10090],ans;//ans是旋转的最少次数，n是车厢总数 
int main(){
	cin>>n; //输入车厢总数 
	for(i=1;i<=n;i++)//循环输入车厢顺序 
		cin>>a[i];

	for(i=1;i<=n-1;i++) //因为1<=i<n所以要循环这么多次   枚举(这些范围内的数) 
		for(j=i;j<=n;j++)//因为i<=j<=n所以。。。。同上  枚举（这些范围内的数）跟上面的不一样 
			if (a[i]>a[j]) { //如果在a[i]范围的数大于a[j]范围的数 
				swap(a[i],a[j]); //就交换这两个数 
				ans++; //次数加一 
			}

	cout<<ans; //输出最少次数 
	return 0; //华丽的结束并AC 
}
```


---

## 作者：KesdiaelKen (赞：27)

简单的来讲，这一题实际上就是让我们模拟冒牌排序的过程，并计算交换了多少次。这种方法的正确性，可用贪心证明它的正确性。下面就是程序，模拟冒泡排序：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    int gs;
    int hc[10000];
    int bs=0;
    cin>>gs;
    for(int i=0;i<gs;i++)cin>>hc[i];//读入数据
    for(int i=gs-2;i>=0;i--)//第一次循环，每次交换时左项最大下表为gs-2，此时右项下标为gs-1，为数组最后一项，不可再。第二次循环时，gs-1位已确定则只用循环到gs-3即可，以此类推，边界为0
    {
        for(int j=0;j<=i;j++)//j=左下标，j+1=右下标
        {
            if(hc[j]>hc[j+1])//如果需要交换
            {
                hc[j]+=hc[j+1];
                hc[j+1]=hc[j]-hc[j+1];
                hc[j]-=hc[j+1];
//此为一种交换方法数据方法（当然也可以直接调用swap）。设a，b为原hc[j],hc[j+1]值，则三步种hc[j],hc[j+1]的值分别为：
//第一步：a+b,b
//第二步：a+b,a
//第三步：b,a，大家如果还不理解可以自己试一下
                bs++;//计一次交换
            }
        }
    }
    printf("%d",bs);
    return 0;
}
```

---

## 作者：oneman233 (赞：15)

**虽然用树状数组求逆序对这种方法发布在这道题这里显得有点大材小用，但我主要是想聊聊树状数组求逆序对的原理以及一个衍生的小问题。**

------------

首先来看看逆序对的定义

**如果存在正整数 i, j 使得 1 ≤ i < j ≤ n 而且 A[i] > A[j]，则 <A[i], A[j]> 这个有序对称为 A 的一个逆序对，也称作逆序数。**

逆序对的一个应用是：数列中所有元素的逆序数之和等于**交换相邻两数把数列变为有序的最小步数**

是不是感觉与题意有些相似了？

------------

接下来说说树状数组

树状数组是一个高效的求前缀和的数据结构，支持单点修改，关于它的更多信息请参看luogu树状数组模板：

[P3368 【模板】树状数组 2](https://www.luogu.org/problemnew/show/P3368)

[P3374 【模板】树状数组 1](https://www.luogu.org/problemnew/show/P3374)

既然可以求前缀和，我们不妨思考，如果我们把数据从大到小，按顺序在它的位置上加一，然后每插入一次就求一下该位置的前缀和，不就可以计算出这个数前面有多少个数字比他大了吗？

一个简单的实例：

测试样例中：4 3 2 1

我们按照刚才所说的步骤，首先按顺序由大到小在对应数字的位置上加一：

1、插入4，结果为1 0 0 0，ans=0

2、插入3，结果为1 1 0 0，ans=0+1=1

3、插入2，结果为1 1 1 0，ans=1+2=3

4、插入1，结果为1 1 1 1，ans=3+3=6

得出结果。

------------

细心的同学们也许注意到了一个问题，**数组有序**是一个并不严格的定义，也就是说数组有**从小到大**和**从大到小**两个定义。而上题中我们所求的是**从小到大**的有序。

那么如果要求**从大到小**该如何是好？

答案很简单，改变逆序对的定义，找到一个数前面比它小的数有多少个即可，也就是说，在最后改变插入顺序为由小到大即可。

此外还有一点需要特别注意，在对数组进行排序是我们一定要使用**稳定的**排序算法，例如STL当中的stable_sort()，**否则不稳定的排序算法可能会改变相同元素的相对位置，导致计算逆序数的时候出现错误！**

上代码，关键点的注释已经写在其中：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,ans=0;
int a[10005],b[10005],c[10005];

int lowbit(int x){return x&-x;}

void add(int x,int v)
{
    while(x<=n){
        a[x]+=v;
        x+=lowbit(x);
    }
}

int sum(int x)
{
    int ans=0;
    while(x>=1){
        ans+=a[x];
        x-=lowbit(x);
    }
    return ans;
}

bool cmp(const int &a,const int &b)
{
    return a>b;
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>b[i],c[b[i]]=i;
    ///稳定排序是为了防止有相同元素的情况，这可能导致答案出错
    stable_sort(b+1,b+1+n,cmp);
    ///可在此处改变插入顺序
    for(int i=1;i<=n;++i){
        add(c[b[i]],1);
        ans+=sum(c[b[i]]-1);
    }
    cout<<ans;
    return 0;
}

```

------------

一些碎碎念：

关于逆序对的更高效求法可以参看luogu[P1908 逆序对](https://www.luogu.org/problemnew/show/P1908)

最后我想聊的是**为什么逆序数之和就是我们的答案呢**？

一个序列要有序，我们必须把最大的数放在序列末尾，然后就可以不再考虑它了，即数列元素个数从n变成了n-1，那么对一个给定的数字，要交换多少次才能把它放到合适的位置上呢？

应该是等到它**右边比它大的数字**全部有序之后这个数字才会被操作，此时它需要的交换次数就是它右边数字之和减去右边比他大的数字个数。


---

## 作者：LCuter (赞：15)

**楼下这么多大佬已经说明冒泡排序，本蒟蒻就不再复述**

这边提供一个改进后的算法————

```cpp
void qs(int& x,int& y){
    x=x-y;
    y=x+y;
    x=y-x;
    ans++;
}
while(flag>0){
    k=flag-1;
    flag=0;
    for(i=1;i<=k;i++){
        if(a[i]>a[i+1]){
            qs(a[i],a[i+1]);
            flag=i;
        }
    }
}
```

这样极大限度保证当后面的数据已经排好，不必做过多排序。


---

## 作者：「QQ红包」 (赞：11)

关于为什么不要交换只要求这个数后面有多少个数比它小。

因为冒泡排序是从后往前排的，所以后面的数一定是排序排好了的。

然后把这个数插入到应该插入的位置需要交换的次数也就是后面的数中比它大的数的个数。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
using namespace std;
int a[10001000]={0};
int main()
{
    int n,sum=0;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]); 
    } 
    for (int i=1;i<=n-1;i++)//这个是选择排序也可以说是改良版的冒泡不过这不是原版冒泡，
    //for(int i=1;i<=n;i++)  
    //for(int j=1;j<n-i+1;j++)才是原版的冒泡  
        for (int j=i;j<=n;j++)
        {
            if (a[i]>a[j]) sum++;//其实就是统计在此之后有多少个数比这个数小 
        } 
    cout<<sum; 
}


```

---

## 作者：Shallowy (赞：8)

看见大家齐刷刷的冒泡排序，我果断码了一段树状数组。

本题其实是一个求逆序对的问题，有几个逆序对，就需要操作几次。

这里c[i]表示的是数字i出现的次数，比i小的数就有(c[1]+c[2]+...+c[i-1])个，这就关系到一个区间的和，可以用树状数组解决。

- 由于此题数据范围较小（也就10000），不需要离散化了。

附上pascal代码：

```cpp
var
  n,i,ans:longint;  //ans存答案
  a,c:array[0..10000] of longint;  //a数组即原数
function lowbit(x:longint):longint;  //低位
  begin
    exit(x and (-x));
  end;
procedure modify(k:longint);  //插入(修改)操作
  begin
    while k<=n do
      begin
        inc(c[k]);  //次数+1
        inc(k,lowbit(k));  //往根节点上溯
      end;
  end;
function sum(k:longint):longint;  //求和操作
  begin
    sum:=0;
    while k>0 do
      begin
        inc(sum,c[k]);  //累加
        dec(k,lowbit(k));
      end;
  end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  for i:=n downto 1 do  //倒推，求比a[i]小的数（保证之前已经插入的数的序号一定是大于i的）
    begin
      inc(ans,sum(a[i]-1));  //累加 比a[i]小的数(即1~a[i]-1)的次数
      modify(a[i]);  //加入a[i]（a[i]出现的次数+1，此处变量省略1）
    end;
  write(ans);
end.
```

---

## 作者：三岁、 (赞：7)

车厢重组

阅读题目后，提取出了关键字

 1. 相邻的车厢两两交换
 
 1. 排序
 
### 思路一

我们首先想到的就是冒泡排序法，故使用冒泡排序的方法进行排序
然后记录排序的次数就行了

代码如下
------------


```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 0;

    cin >> n;
    int a[n];

    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    int cnt = 0;
    for (int j = 0; j < n-1; ++j) {
        for (int i = 0; i < n-j-1; ++i) {
            if (a[i] > a[i+1]) {
                swap(a[i], a[i+1]);
                cnt++;
            }
        }
    }

    cout << cnt << endl;
    return 0;
}
```


------------


### 思路二

 题目中其实并没有要求我们进行排序，只是要求我们记录一下需要移动的次数就好了


代码如下
------------

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 0;

    cin >> n;
    int a[n];

    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    int cnt = 0;
    for (int j = 0; j < n-1; ++j) {
        for (int i = 0; i < n-j-1; ++i) {
            if (a[i] > a[i+1]) {
                cnt++;
            }
        }
    }

    cout << cnt << endl;
    return 0;
}
```



---

## 作者：Kuchinashi (赞：4)

其实这题只要用一个冒泡排序即可！

```cpp
#include<bits/stdc++.h> //涵盖了所有C++头文件的头文件
using namespace std;
int a[10001], n; //数组开大一点，以防万一
int main()
{
    int ans=0; //定义一个用于储存操作步数的变量
    cin >> n; //输入有几个车厢
    for(int i=1;i<=n;i++)
        cin >> a[i]; //用for循环读入车厢号码
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i;j<=n;j++) //冒泡排序~
            if(a[i] > a[j]) //如果前一个比后一个大
            {
                int tmp=a[i];
                a[i]=a[j];
                a[j]=tmp; //交换位置
                ans++; //操作次数加1
            }
    }
    cout << ans; //最后输出操作次数即可！
    return 0;
}
```

---

## 作者：Li_Dicker (赞：2)

# 这道题可以用goto！！！
```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<ctime>
#include<queue>
#include<stack>
using namespace std;
int n,ans;
int a[11111];
int check()
{
	for (int i=1;i<n;i++)
		if (a[i]>a[i+1])
			return 0;
	return 1;
}//检查是否合法
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]);//读入数据
	loop:
	for (int i=1;i<n;i++)
		if (a[i]>a[i+1])
			swap(a[i],a[i+1]),ans++;//搜索一次逆序对，如果是逆序对就调换顺序且记录答案
	if (check()==0)//如果不合法
		goto loop;//继续搜索
	printf("%d\n",ans);//输出答案
	return 0;
}
```

那么我们先来介绍一下goto语句

goto语句是一种强制性跳转语句，起着在程序运行时将程序强制跳转到循环节，经常与if语句、while等循环和分支语句并列出现

goto语句支持向下跳转和向上跳转，我们需要在循环节（也就是要跳转到的地方）打一个循环标记，但是这个标记不能与C++的关键字重复。代码如下

向下跳转：
```cpp
goto loop;
//需要执行的程序
loop:


```

向上跳转
```cpp
loop:
//需要执行的程序
goto loop;
```

那么goto语句实际用处有哪些呢？

**1.代替for和while循环，实现它们不能完成的功能**

代替while循环的例子就是本题，当然本题其实不如说是代替的do-while循环

那么如何完成它们无法完成的任务呢？

就像如下代码一样
```
loop1:

//do something

loop2:

//do something

if (/*someting*/)
	goto loop1;
else if (/*something*/)
	goto loop2;
else if (/*also someting*/)
	goto loop3;
//dosomething
loop3:
//dosomething
if (/*something*/)
	goto loop1;
else 
	goto loop3;
    
```
上面的伪代码

我们当然可以只用while和if写出来~~（可惜本萌新没有这个实力）~~

这就是goto的第一个实际用途：代替复杂的分支加循环语句

**2.实现一次性退出多层循环**（妈妈再也不用担心我分不清break和continue啦）

那么我们来对比一下用break和用goto的区别吧

```
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			for (int k=1;k<=n;k++)
			{
				for (int l=1;l<=n;l++)
				{
					//dosomething

					if (/*something*/)
					{
						flag=1;
						break;
					}
				}
				if (flag==1)
					break;
			}
			if (flag==1)
				break;
		}
		if (flag==1)
			break;
	}
    
```
那么goto需要几行呢
```cpp
for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			for (int k=1;k<=n;k++)
				for (int l=1;l<=n;l++)
				{
					//dosomething

					if (/*something*/)
						goto loop;
				}
	loop:
```
是不是很简单？

甚至，它还做得到那些break和continue做不到的事情，但是我就不一一列举了

**特别注意！！！goto不能实现函数间的跳转，这样会不通过编译！！！**

在最后还是提醒大家：在比赛的时候，能不用goto的尽量不要用goto

毕竟我们不知道ccf是否允许（有没有良心）让我们用goto

祝大家AK CSP2019

---

## 作者：feecle6418 (赞：2)

特别简单的题，其实就是冒泡排序（有点改变）。

统计一个转换次数就行啦。

```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
//#include<rmath>（我的专属头文件）
long long n,i,j,t,s=0,a[10000];//开大一点，必须在main的外面，不然RE
using namespace std;
int main(){
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    for(i=1;i<=n-1;i++){
        for(j=1;j<=n-i;j++){
            if(a[j]>a[j+1]){
                swap(a[j],a[j+1]);//冒泡排序
                s++;
            }
        }
    }
    cout<<s;
    return 0;
}
```

---

## 作者：九指客 (赞：2)

```cpp
//一个选择排序就过了，非常简单。
#include<stdio.h>
int main()
{
    int i,j,n,k=0,m;
    int a[10001];
    scanf("%d",&n);//输入
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//输入
    }
    for(i=1;i<n;i++)//排序
    {
        for(j=i+1;j<=n;j++)
        {
            if(a[i]>a[j])
            {
                m=a[i];
                a[i]=a[j];
                a[j]=m;
                k++;//标记
            }
        }
    }
    printf("%d",k);//输出
    return 0;
}
```

---

## 作者：courage (赞：2)

这题有两种解法

#解法1 暴力

直接模拟，实际上也就是冒泡排序，每次交换时ans++，时间复杂度[color=red]**O(n^2)**[/color]，洛谷神机不解释，10000的规模都能[color=red]**0ms**[/color]飘过（这不科学啊！！！）


#解法2 分治

实际上每次交换就是使序列的逆序对数-1，到最后逆序对数=0，所以ans=逆序对数。（不知道逆序对的自行百度）

实际上，把归并排序（不会归并排序的自行百度）的代码稍加改编即可求出逆序对数，时间复杂度[color=red]**O(nlogn)**[/color]，[color=red]**0ms**[/color]飘过。（暴力都能0ms了正解当然0ms。。）

建议先自己根据归并排序的代码改写，实在写不对再看下面的代码


另外多说一句，poj2299和本题差不多，只不过数据规模稍微大了一点（每个输入数据有多组，每组500000），交一下这题就能发现解法2的优越性了。（这么大的规模暴力再能过的话我就无语了）


```cpp

#include<cstdio>
int a[10010],b[10010],c[10010],n,ans=0;
void merge(int x,int y){
    if (x==y) return;
    int m=(x+y)>>1;
    merge(x,m);
    merge(m+1,y);
    for (int s=x;s<=m;s++) b[s-x+1]=a[s];
    for (int s=m+1;s<=y;s++) c[s-m]=a[s];
    int i=1,j=1;
    int p=m-x+1;
    int q=y-m;
    int k=x-1;
    while (i<=p && j<=q){
        if (b[i]<=c[j]){
            k++;
            a[k]=b[i];
            i++;
        }else{
            k++;
            a[k]=c[j];
            j++;
            ans+=p-i+1;
        }
    }
    if (i>p)
        for (int s=j;s<=q;s++){
            k++;
            a[k]=c[s];
        }
    if (j>q)
        for (int s=i;s<=p;s++){
            k++;
            a[k]=b[s];
        }
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    merge(1,n);
    printf("%d",ans);
}

```

---

## 作者：Sinwind (赞：2)

------------
# 思路

1. 分析：
- 桥能也只能交换两节相邻的车厢，故选择交换排序中的冒泡排序。

2. BubbleSort函数（冒泡排序）：
- 双重循环，外层循环控制趟数，执行n - 1趟，内层循环控制每趟的次数，每趟执行n - i - 1次；
- 若a[j] > a[j + 1]，交换，count++，记录交换的次数；
- 返回交换的次数。

3. 主函数：
- 读取车厢的总数N，动态分配N块int型内存空间给carriages（carriages = (int*)malloc(sizeof(int) * N)），读取车厢的顺序，存入carriages数组；
- 调用BubbleSort函数（BubbleSort(carriages, N)），返回值赋给times，并输出times，释放动态分配的内存（free(carriages)）。

------------
# 代码

```c
#include <stdio.h>
#include <stdlib.h>

//冒泡排序，将有n个元素的数组a从小到大排序，返回交换的次数
int BubbleSort(int a[], int n)
{
	int count = 0;

	for (int i = 0; i < n - 1; i++)
	{
		for (int j = 0; j < n - i - 1; j++)
		{
			if (a[j] > a[j + 1])
			{
				int temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				count++;
			}
		}
	}

	return count;
}

int main(void)
{
	int N;			//车厢的总数
	int* carriages;		//车厢的顺序
	int times;		//旋转的次数

	scanf("%d", &N);

	carriages = (int*)malloc(sizeof(int) * N);

	for (int i = 0; i < N; i++)
	{
		scanf("%d", &carriages[i]);
	}

	times = BubbleSort(carriages, N);

	printf("%d\n", times);

	free(carriages);

	return 0;
}
```


---

## 作者：linus_li (赞：2)

这道题其实不用真正的冒泡排序啦......因为它不需要排序后的结果，所以只要统计逆序对的个数就可以了......
	
	#include<cstdio>
	int a[20000];
	int main()
	{
		int n, ans = 0;
		scanf("%d", &n);
		for(int i = 1; i <= n; i++)
		{
			scanf("%d", &a[i]);
		}
		for(int i = 1; i <= n; i++)
		{
			for(int j = i+1; j <= n; j++)
			{
				if(a[i] > a[j])ans++;
			} 
		}
		printf("%d", ans);
	}
    
这样做下来最快的点是2ms，最慢的是4ms，（~~之前看见有一个大佬秀自己的6ms~~）

---

## 作者：dqa2022 (赞：2)

题目说白了就是：若只能交换相邻两元素位置，求至少要交换多少次才能使整个序列有序.

可以得出，需要交换的元素a[i]和a[j]（这里规定i<j）满足 a[i]>a[j]，(a[i],a[j])就是一个逆序对；需要交换的次数就是序列中逆序对的个数.

怎么求逆序对个数呢？

冒泡排序交换的即是逆序对的元素，我们可以用它排序，排序过程中累计逆序对个数，时间复杂度为O(n^2)，数据比较小，可以全过.

冒泡排序代码：

```cpp
#include<cstdio>
const int MAXN=10002;
int array[MAXN],n,ans;
inline void swap(int &x,int &y)//交换元素可以使用位运算符“^” 
{
    x^=y;
    y=x^y;
    x^=y;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%d",&array[i]);
    for (int i=2;i<=n;i++)//选择排序 
        for (int j=1;j<i;j++)
            if (array[i]<array[j])//判断是否为逆序对 
                swap(array[i],array[j]),ans++;//交换并累加 
    printf("%d\n",ans);
    return 0;
}
```
这道题我们还可以用树状数组、归并排序等来做，下面来说说树状数组.
树状数组能够用O(log n)的复杂度更新数组某个元素及查询某数组某前缀的和；我们边读入边把元素存进树状数组中，并计算逆序对个数（即有多少个比我先进来但比我大的），时间复杂度为O(n log n)，比上面的方法更加高效.

树状数组代码：

```cpp
#include<cstdio>
const int MAXN=10002;
int array[MAXN],n,num,ans;
inline int lowbit(int x)//lowbit技术 
{return x&-x;}
inline void add(int x)//更新数组某个元素 
{
    for (;x<=n;x+=lowbit(x))
        array[x]++;
}
inline int calc(int x)//查询数组前x个数的和 
{
    int res=0;
    for (;x;x-=lowbit(x))
        res+=array[x];
    return res;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&num);
        add(num);//数组第num个元素为1 
        ans+=i-calc(num);//calc查询有多少个不大于当前元素的元素（包括它自己） 
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：2016级8班taiqi (赞：2)

此题数据较小，可用冒泡解决。

用一个变量ans记录交换次数，进行一次交换ans++;

下面附上代码：

```cpp
#include<iostream>
using namespace std;
int n,a[10001],ans(0);
int main(){
    int t;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];//输入
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            if(a[j]<a[i]){//如果后面比前面小，
                t=a[i];
                a[i]=a[j];
                a[j]=t;//交换
                ans++;//ans记录交换次数
            }
        }
    }
    cout<<ans;输出次数；
    return 0;//完美结束
} 
希望对大家有帮助~
```

---

## 作者：ZHDX (赞：1)

看到很多题解, 觉得双N循环次数太多了. 而且都在子循环里进行完全交换, 觉得没必要.

分享一个方案, 减少循环次数, 也尽量减少让赋值数组的次数.


```cpp

#include <iostream>
using namespace std;

int N;
int numbers[10000];


int main()
{
	cin >> N;
	for (int i = 0; i < N; i++)
		cin >> numbers[i];

	int c = 0;

	// i 是由 0 到 N-2项 , 分别与 1 到 N-1项 进行大小比较
	for (int i = 0; i < N - 1; i++)
	{
		//如果再发现 i+1 项 , 比较小, 则需要对这一项进行处理
		if (numbers[i + 1] < numbers[i])
		{
			//注意, 现在我们要移动的是 i+1 项, 只需要取1次就够了. 
			int t = numbers[i + 1];

			//开始反向循环 , 先记录一下当前位置
			int k = i;
			do
			{
				c++;//一共需要的交换次数+1

				//把当前项往右边移动, 
				numbers[k + 1] = numbers[k];

				//***本来按题目, 应该是交换的 , 但可以优化性能到后面设置一次
				//numbers[k] = t;
				
				//往左移动一位, 然后如果需要, 则继续交换
				k--;
			} while (k >= 0 && numbers[k] > t);

			//***因为k--了, 所以k+1才是之前的位置. 
			numbers[k+1] = t;
		}
	}

	cout << c;

	return 0;
}


```


---

## 作者：_Los (赞：1)

其实我也不知道我写了什么，就按照我一开始的思路来写吧。
```cpp
#include <iostream>
using namespace std;
int n,f[10005],sum=0;/*
n：记录车厢数
f[]：车型顺序
sum：记录移动总次数
*/ 
void tot(int a,int b){
	//tot函数来交换f[]数组中的两个变量的值
	//模拟车厢换位 
	int t;
	t=f[a];
	f[a]=f[b];
	f[b]=t;
}
void turn(int p,int k){
	//turn函数用来将f[]数组中p这个位置的车厢移到k处 
	//相当于将其冒泡到k处
	//k：当前排好序的车厢最后面的那个车厢，即下一个车厢所在位置 
	for(int i=p;i>k;i--){//从p开始往前走，一个一个交换直到k处 
		tot(i,i-1);//交换 
		sum++;//记录 
	}
}
int main(){	
	cin>>n;
	for(int i=0;i<n;i++)cin>>f[i];
	for(int i=0;i<n;i++){
		int minnum=0x7fffffff,num;/*
		minnum：记录i~n（待排序车厢）中最小的车厢
		num：那个最小车厢的序号
		*/ 
		for(int j=i;j<n;j++)
			if(f[j]<minnum){
				minnum=f[j];
				num=j;
			}
		//找最小车厢 
		turn(num,i);//把最小车厢冒泡到已排序过的车厢的最后，即i处 
	}
	cout<<sum<<endl;
	return 0;
}
```
说的可能还是有点模糊，没关系，看张表：
```cpp
n=4
sum=0
第0次（一开始）: 4 3 2 1
第0次到第1次时，找到了最小数1，其位置为4
然后，将1冒泡到最前面（这时的i值为1）
第1次: 4 3 1 2
       4 1 3 2
       1 4 3 2
sum=0+3=3
第1次到第2次时，在2~4中找到了最小数2，其位置为4
然后，将2冒泡到第2个位置（这时的i值为2，第1个位置已经排好了，为1）
第2次: 1 4 2 3
       1 2 4 3
sum=3+2=5
第2次到第3次时，在3~4中找到了最小数3，其位置为4
然后，将3冒泡到第3个位置（这时的i值为3，第1~2个位置已经排好了，为1、2）
第3次:1 2 3 4
sum=5+1=6
得：最少用的次数为6
```
~~其实这就是一个冒泡排序~~


---

## 作者：yanxxx (赞：1)

其实就是一个冒泡排序统计一共交换了多少次，另外，推荐喜欢用cin，cout的同学们使用ios::sync\_with\_stdio(false);来关掉stdio同步，会使代码的速度快很多。但关掉后就不能使用scanf和printf了。

```cpp
include<bits/stdc++.h>
using namespace std; 
int main(void)
 { ios::sync_with_stdio(false); 
int n; cin>>n; int a[1010]; 
for(int i=1;i<=n;i++) cin>>a[i];
 int ans=0;//用ans变量来储存答案
 for(int i=1;i<=n-1;i++)//这是冒泡排序 
for(int j=i+1;j<=n;j++)
 if(a[i]>a[j])
 {int t=a[i];a[i]=a[j];a[j]=t;ans++;}
 cout<<ans; return 0; }
```

---

## 作者：zhych (赞：1)

```cpp
var
   n,i,j,t:integer; k:longint;
   a:array[1..11000]of integer;
begin
    readln(n);//读入车厢总数。
    for i:=1 to n do
     read(a[i]);//读入车厢的排列顺序
    k:=0;//次数为零
    for i:=1 to n-1 do
       for j:=i+1 to n do
          if a[i]>a[j] then
               begin
                  inc(k);
               end;//冒泡循环
    writeln(k);//输出
    //由于题目比较水，所以冒泡就可以满分，不会超时、
end.

```

---

## 作者：M_seа (赞：1)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
int main()
{
    int n,i,j,ans=0,k;
    scanf("%d",&n);
    int a[n];
    for (i=0;i<n;i++)
    scanf("%d",&a[i]);
    for (i=0;i<n-1;i++)
        for (j=i+1;j<n;j++)//排序
        if (a[i]>a[j])
        {
            k=a[i];
            a[i]=a[j];
            a[j]=k;
            ans++;//每排一次加一次
        }
    printf("%d\n",ans);//一共排了多少次
    return 0;
}
```

---

## 作者：ol1125032224 (赞：1)

```delphi

(program huochediaohuan;
 var n,i,j,k,sum:longint;
 a:array[1..10000] of longint;

begin
 read(n);
  for i:=1 to n do
   read(a[i]);
    for i:=2 to n do
     for j:=n downto i do
      if a[j]<a[j-1] then begin
       k:=a[j];
        a[j]:=a[j-1];
         a[j-1]:=k;
          inc(sum);
           end;
            writeln(sum);
 end.)

```
一开始看错样例，死活过不了。。。。。数据小，冒泡这种o（n^2)也可以过


---

## 作者：hfctf0210 (赞：1)

其实就是冒泡排序，数据量1000，很容易过的，不解释。

核心代码：

```cpp
for(i=0;i<n;i++)//数组从0开始
for(j=0;j<n-i-1;j++)
if(a[j]>a[j+1])
{
swap(a[j],a[j+1]);
num++;
```
}//输出num即可
}

---

## 作者：oreimo_eromanga (赞：1)

```cpp

//这道题实际上就是简单的冒泡排序，交换的次数就是答案。
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<string>
#include<cstdio>
#include<cmath>
using namespace std;
int n1[10001];
int main()
{
    int n,p,total=0;  //用total来计算调换的次数。
    cin>>n;
    for(int i=1;i<=n;i++)
       cin>>n1[i];
    for(int i=1;i<n;i++)
    {
       for(int j=1;j<=n-i;j++)
       {
          if(n1[j]>n1[j+1])
          {
            p=n1[j];n1[j]=n1[j+1];n1[j+1]=p;total++;  //程序的核心思想。蒟蒻就好好学习，天天向上吧！
          }
       }
    }
    cout<<total<<endl;
    return 0;
}

```

---

## 作者：taophee (赞：1)

想法:

这道题看到题目就觉得比较水，再一对题目理解就发现这其实就是一个冒泡排序，只要将数对用冒泡排序的过程枚举一遍就可以了，每交换一次就将计数器+1，最后输出计数器即可.

程序:

```delphi

var
n,i,j,s:longint;
a:array[1..10000] of longint;

procedure swap;
var
t:longint;
begin
  t:=a[j];a[j]:=a[j-1];a[j-1]:=t;
end;

begin
  read(n);
  for i:=1 to n do
    read(a[i]);
  for i:=1 to n do
    for j:=n downto i+1 do
      if a[j]<a[j-1] then begin swap;inc(s);end;
  writeln(s);
end.

```

---

## 作者：Skyjoy (赞：1)

# 显而易见，这道题要按照题意操作排序，只能冒泡了。

给不懂的童鞋简单解释一下：

有些童鞋可能审题不够清晰，会想到快排、归并、桶、堆排等神奇的排序算法。然鹅我们思考一下各种排序算法的实现思想，发现一件神奇的事情：

# 好像只有冒泡能够使排序时相邻两个交换了

看了看大部分的题解，直接模拟了整个过程并计数。但是，毕竟冒泡中，该浮上去的早晚都要浮上去，不用模拟，直接计数即可。

# 接下来就是最激动人心的代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt=0,a[10010];
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<i;j++){
			if(a[j]>a[i]){
				cnt++;
			}
		}
	}
	cout<<cnt;
	return 0;
}
```

祝童鞋们$CSP2019rp++$！！！

---

## 作者：autoint (赞：0)

# 前言
### 看了大家的做法，什么冒泡排序，插入排序，树状数组，线段树,都好厉害呐，我都没想出来
### 但我发现竟然还没有人用主席树，于是我跟大家交流一下 主席树 做法
# 显然我们有
## $Ans=\sum_{i=1}^n\sum_{j=1}^{i-1}a_j\geq{}a_i$
# 于是这样用主席树做
### 考虑每个$i$对$Ans$的贡献，发现只需要统计出大于$a_i$的数的个数，注意这些数应该是已经出现了的
### 用主席树维护答案，查询$0\to{}i-1$的历史版本，做法已经很明确了
# 最后分析时间复杂度
### 对每个$i$我们要先查询$[a_i+1,n]$数的个数，需要$O(\log_2n)$时间，然后插入这个数也需要$O(\log_2n)$时间
### 因此总时间复杂度为$O(n\log_2n)$
# 放代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int maxn=1e4+7;
struct PreSegTree
{
	int sum;
	int L,R;
}PST[maxn*16];
int root[maxn],cnt;

void insert(int&now,int l,int r,int x)
{
	PST[++cnt]=PST[now];
	now=cnt;
	++PST[now].sum;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid)
		insert(PST[now].L,l,mid,x);
	else if(x>=mid+1)
		insert(PST[now].R,mid+1,r,x);
}

int query(int i,int j,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr)
		return PST[j].sum-PST[i].sum;
	int mid=(l+r)>>1;
	int ans=0;
	if(ql<=mid)
		ans+=query(PST[i].L,PST[j].L,l,mid,ql,qr);
	if(qr>=mid+1)
		ans+=query(PST[i].R,PST[j].R,mid+1,r,ql,qr);
	return ans;
}

int main()
{
	memset(PST,0,sizeof(PST));
	memset(root,0,sizeof(root));
	cnt=0;
	int n;
	cin>>n;
	int a,ans=0;
	for(int i=1;i<=n;++i)
	{
		cin>>a;
		if(a<n) // 注意a==n时统计要特判掉
			ans+=query(root[0],root[i-1],1,n,a+1,n);
		root[i]=root[i-1];
		insert(root[i],1,n,a);
	}
	cout<<ans<<endl;
}
```

---

## 作者：南城忆潇湘 (赞：0)

看到下面dalao都用树状数组/归并排序做。。

在此献上一颗线段树

位运算优化+map qaq

基本上都是log级别的

时间复杂度O(nlogn)

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;
map<int, int> change;
int n, a[100005], b[100005], jsq;
long long ans, t[400005];
void add(int node, int f, int k, int l, int r){
    if(l == r){//找到了就返回
        t[node] += f;
        return ;
    }
    int mid = ( l + r ) >> 1;//不然就继续往下面找
    if(k <= mid)
        add( node << 1, f, k, l, mid);
    else
        add( node << 1 | 1, f, k, mid + 1, r); 
    t[node] = t[node << 1] + t[node << 1 | 1];
}
long long Sum(int node, int L, int R, int l, int r){//线段树求和,
    if( l > R || r < L )
        return 0;
    if( l >= L && r <= R )
        return t[node];
    int mid = (l + r) >> 1;
    return (long long) Sum( node << 1, L, R, l, mid) + 
                    Sum( node << 1 | 1, L, R, mid+1, r);
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
        b[i] = a[i];//备份一份,后面有用qaq
    }
    sort(b + 1, b + 1 + n );
    
    for(int i = 1; i <= n ; i++){
        if(!change[b[i]]){
            change[b[i]] = (++jsq);
        }
    }
    for(int i = 1; i <= n; i++){
        ans += Sum( 1 ,change[a[i]] + 1, jsq, 1, jsq);//统计
        add( 1, 1, change[a[i]], 1, jsq);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：康娜卡姆依 (赞：0)

冒泡的经典题

```cpp
//pascal
var k,i,j,n,temp:longint;
    a:array[1..1000] of longint;
begin
  read(n);
  for i:=1 to n do
  read(a[i]);
  for i:=1 to n-1 do
  for j:=1 to n-i do
  begin
    if a[j]>a[j+1] then begin temp:=a[j]; a[j]:=a[j+1]; a[j+1]:=temp; inc(k); end;
  end;
  write(k);
end.
```
冒泡的基本思想：
依次比较相邻的两个数，把大的放前面，小的放后面。即首先比较第1个数和第2个数，大数放前,小数放后。然后比较第2个数和第3个数......直到比较最后两个数。第一趟结束，最小的一定沉到最后。重复上过程,仍从第1个数开始,到最后第2个数，然后......


由于在排序过程中总是大数往前，小数往后，相当气泡上升，所以叫冒泡排序。

------------------------------------------------------------------------------------------------------------------------------------------

不过其实是可以优化的：有些时候已经排好序了。但是计算机此时并不知道已经排好序。所以，还需进行一次比较，如果没有发生任何数据交换，则知道已经排好序，可以不干了。因此第三趟比较还需进行，第四趟、第五趟比较则不必要。优化后的时间复杂度大大降低。

我们可以设置一个布尔变量bo来记录是否有进行交换。值为false表示本趟中进行了交换，true 则没有。

于是——

C++“冒泡2.0”代码如下：

```cpp
int i=1;
while (!bo)
{
    bo=true;
    for (int j=1;j<=n-i;j++)
    if (a[j]<a[j+1]) 
    {
        temp=a[j];    
        a[j]=a[j+1];
        a[j+1]=temp;  
        bo=false; 
     }
　i++;
}
```

---

## 作者：封禁用户 (赞：0)

```cpp
var n,i,j,t,cs:longint;k:array[1..10000] of longint;
begin
  readln(n);
  for i:=1 to n do read(k[i]);
  //输入部分:输入n个数 
  for i:=1 to n-1 do
   for j:=i+1 to n do
    if k[i]>k[j] then begin t:=k[i];k[i]:=k[j];k[j]:=t;inc(cs);end;
  //排序，然后排序，再记录调换次数就行了 
  writeln(cs);
end.
```

---

## 作者：雄鹰展翅 (赞：0)

冒泡排序（归并排序也行），时间复杂度为O(n^2),第一道循环i从1~n-1,第二道循环j从1~n-i.

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10001],num;//题目中的n,数组,计数器
void read()
{
    int i,j;//循环变量
    cin>>n;
    for(i=1;i<=n;i++)
    cin>>a[i];
    for(i=1;i<=n-1;i++)
    for(j=1;j<=n-i;j++)
    if(a[j]>a[j+1]){
        swap(a[j],a[j+1]);//swap直接交换
        num++;
    }
    cout<<num<<endl;
}
int main()
{
    read();
    return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

这个题就是考了个求逆序对。

所以原题实际意义为求N个数据排序成从小到大有几个逆序对(调换几次)

O（n^2）的算法最好想到，直接一个冒泡/插入  AC

```cpp
var n,i,j,ans,t:longint;
    a:array[1..10000]of longint;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=1 to n-1 do
  for j:=i+1 to n do
   if a[i]>a[j] then inc(ans);
 writeln(ans);
end.
```
AC效率：（Greatest）
10ms /  8.25MB

代码：0.2KB Pas 车厢重组

有没有O（n log n）的算法呢？

要用分治思想，即归并排序求逆序对。。

```cpp
var n,i,ans:longint;
a,b:array[0..10000] of longint;
procedure merge(left,mid,right:longint);
var le,mi,k,i:longint;
begin
le:=left;mi:=mid+1;k:=left;
while (le<=mid) and (mi<=right) do
begin
if a[le]<=a[mi] then
begin
b[k]:=a[le];
inc(le);
inc(k);
end else
begin
b[k]:=a[mi];
inc(mi);
inc(k);
ans:=ans+mid-le+1;//删去就是纯归并排序，加上就是求逆序对
end;
end;
while le<=mid do begin b[k]:=a[le];inc(le);inc(k); end;
while mi<=right do begin b[k]:=a[mi];inc(mi);inc(k); end;
for i:=left to right do a[i]:=b[i];
end;
procedure msort(left,right:longint);
var mid:longint;
begin
if left=right then exit;
mid:=(left+right) div 2;
msort(left,mid);
msort(mid+1,right);
merge(left,mid,right);
end;
begin
readln(n);
for i:=1 to n do read(a[i]);
msort(1,n);
writeln(ans);
end.
```
AC效率：（fastest）
6ms /  8.29MB

代码：0.97KB Pas


---

## 作者：ckyao1881 (赞：0)

```cpp
var
  i,j,n,x:longint;
  a:array[0..10000] of longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  for i:=1 to n-1 do//用一个冒泡排序
    for j:=n downto i+1 do
     if a[j-1]>a[j] then//从小到大排
      begin
      a[0]:=a[j-1];//交换
      a[j-1]:=a[j];
      a[j]:=a[0];
      x:=x+1;//交换次数加一
     end;
  writeln(x);
end.
```

---

## 作者：封禁用户 (赞：0)

归并排序求逆序对，n log(n)的算法（然而n^2暴力也能过）



```cpp
var n,i,ans:longint;
a,b:array[0..10000] of longint;
procedure merge(left,mid,right:longint);
var le,mi,k,i:longint;
begin
  le:=left;mi:=mid+1;k:=left;
  while (le<=mid) and (mi<=right) do
  begin
    if a[le]<=a[mi] then
    begin
      b[k]:=a[le];
      inc(le);
      inc(k);
    end else
    begin
        b[k]:=a[mi];
        inc(mi);
        inc(k);
        ans:=ans+mid-le+1; 
    end;
  end;
  while le<=mid do begin b[k]:=a[le];inc(le);inc(k); end;
  while mi<=right do begin b[k]:=a[mi];inc(mi);inc(k); end;
  for i:=left to right do a[i]:=b[i];
end;
procedure msort(left,right:longint);
var mid:longint;
begin
  if left=right then exit;
  mid:=(left+right) div 2;
  msort(left,mid);
  msort(mid+1,right);
  merge(left,mid,right);
end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  msort(1,n);
  writeln(ans);
end.
```

---

## 作者：magolor (赞：0)

树状数组求逆序对




    
    
    


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 40000
int n,a[MAXN+5],num[MAXN+5],ans = 0;
inline int lowbit(int k)
{
    return (k&(-k));
}
bool cmp(int a1, int a2)
{
    return a[a1] < a[a2];
}
struct Index_Tree
{
    int c[MAXN+5];
    void Init()
    {
        memset(c,0,sizeof(c));
        return;
    }
    void Add(int i, int j)
    {
        for(; i <= n; i+=lowbit(i))
            c[i] += j;
        return;
    }    
    int Sum(int i)
    {
        int ans = 0;
        for(; i; i-=lowbit(i))
            ans += c[i];
        return ans;
    }
};
Index_Tree T;
int main()
{
    T.Init();
    scanf("%d",&n);
    for(int i = 0; i < n; i++)
        scanf("%d",a+i),num[i] = i;
    stable_sort(num,num+n,cmp);
    for(int i = 0; i < n; i++)
        a[num[i]] = i;
    for(int i = 0; i < n; i++)
        ans += T.Sum(n-a[i]), T.Add(n-a[i],1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：HZZX_CJX (赞：0)

讲真，不太清楚为什么冒泡排序是对的，但事实就是这样，而且不超时！加了个小优化。

```cpp
var a:array[1..10000]of longint;
    n,i,j,t,ans:longint;  f:boolean;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  for i:=1 to n-1 do begin
    f:=true;
    for j:=i+1 to n do
      if a[i]>a[j] then begin
        t:=a[i];a[i]:=a[j];a[j]:=t; inc(ans);
        if f then f:=false;
      end;
    if f then break;（判断这一轮有没有交换，没有交换就已经排序完成）
  end;
  writeln(ans);
end.
```

---

## 作者：ergeda (赞：0)


```cpp
//冒泡排序也就过了~~
#include<iostream>
using namespace std;
int a[10010];
int main(){
    int m,n,ans=0;//ans用来记录次数，m是车厢数
    cin>>m;//输入
    for(int i=1;i<=m;i++)
        cin>>a[i];
        for(int i=1;i<=m-1;i++)  
            for(int j=1;j<=m-i;j++)
                if(a[j]>a[j+1]){//从第一个数开始，一个个向下比较
                    ans++;//记录
                    n=a[j];//n相当于一个中间人，交换位置
                    a[j]=a[j+1];
                    a[j+1]=n;//排序
                }
                cout<<ans<<endl;//输出
    return 0;
}
```

---

## 作者：十年若如一梦 (赞：0)

//一道模拟题，虽然用排序不是正解，但毕竟有一句话叫做"黑猫白猫，能抓老鼠的都是好猫“，能对就是正解。

```cpp
var n,cs,by,i,j:longint;
    bh:array[1..10000] of longint;
begin
  readln(n);
  for i:=1 to n do 
    read(bh[i]);
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if bh[i]>bh[j] then {如果编号[i]大于编号[j]就进行交换}
        begin
          by:=bh[j];
          bh[j]:=bh[i];
          bh[i]:=by;{进行交换}
          inc(cs);{别忘了还要记录交换了多少次}
        end;
 writeln(cs);
end.

```

---

## 作者：封禁用户 (赞：0)

{很简单的一道题，用冒泡，前面比后面大inc（k）}

```cpp
var
   n,i,j,t:longint; k:longint;
   a:array[1..10000]of integer;
begin
    readln(n);
    for i:=1 to n do
     read(a[i]);{读入车厢顺序}
    k:=0;{次数必须是0，是1就错了。}
    for i:=1 to n-1 do
       for j:=i+1 to n do
          if a[i]>a[j] then
               inc(k);{冒泡，累加。可以不替换。}
               writeln(k);{输出}
end.

```

---

## 作者：ZYR_ (赞：0)


```cpp
program cxcz(input,output);
var
a:array[1..10000]of integer;
i,j,sum,n,t:longint;
begin
readln(n);
sum:=0;
for i:=1 to n do
read(a[i]);
for i:=1 to n do
  for j:=i to n do
  if a[i]>a[j] then begin
  t:=a[i];
  a[i]:=a[j];
  a[j]:=t;
  inc(sum);
  end;
  writeln(sum);
end.
这就是一个冒泡的过程，记录次数就行了
```

---


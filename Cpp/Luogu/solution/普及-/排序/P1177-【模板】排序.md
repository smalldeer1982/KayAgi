# 【模板】排序

## 题目描述

将读入的 $N$ 个数从小到大排序后输出。

## 说明/提示

对于 $20\%$ 的数据，有 $1 \leq N \leq 10^3$；

对于 $100\%$ 的数据，有 $1 \leq N \leq 10^5$，$1 \le a_i \le 10^9$。


## 样例 #1

### 输入

```
5
4 2 4 5 1```

### 输出

```
1 2 4 4 5```

# 题解

## 作者：__Allen_123__ (赞：227)

本题解/笔记专门讲述快速排序及其应用，比较适合新手学习和阅读，如果想了解其他做法请移步。

2023.12.15：修改了一些笔误和可能引起误解的内容。

2024.8.16：优化了一些表述，使描述更加严谨。

2024.11.26：修改了一些 typo 和小错误。

---

快速排序是 OI 中常用的算法。这篇题解/笔记将会详细地讲解快速排序的原理、实现过程，也会拓展 STL `sort` 函数的使用和快排复杂度及其证明。

### 快速排序的原理

本部分讲述的是常用的三路快速排序。如果想了解快速排序的更多变种实现方式可以在 [OI Wiki](https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6) 中了解。

我们设待排序的序列为一个长度为 $n$ 的序列 $a$。快速排序的具体原理如下：

首先，在 $a$ 中随机选择一个数 $x$，之后我们进行如下操作：

1.  如果 $n=0$ 或 $n=1$，此时根本无需排序，直接退出；
2.  定义三个新的序列 $b, c, d$；
3.  遍历整个序列 $a$，将比 $x$ 小的放在 $b$ 内，比 $x$ 大的放在 $d$ 内，和 $x$ 相等的放在 $c$ 内；
4.  将 $b, d$ 按如上过程继续排序。序列 $c$ 中的数由于都相等所以不必排序。

说起来可能有点抽象，给大家举个例子：

我们定义一个未排序序列 $a=\{3, 2, 4, 1\}$。

我们从序列中选择第一个数 $a_1=3$，根据上面的过程可知，$b=\{2, 1\}, c=\{3\}, d=\{4\}$。

此时因为 $c, d$ 长度已经为 $1$，所以不必再排序；而同理，在序列 $b$ 中，我们可以将两个数分为两个序列（相当于把它们交换位置），最终就可以完成排序。排序结果为 $a=\{1, 2, 3, 4\}$。

---

### 快速排序如何用 C++ 实现？

我们以 [P1177 【模板】排序](https://www.luogu.com.cn/problem/P1177)为例来讲解这一算法的实现过程。

#### 普通自定义函数

首先，我们看完如上所示的实现方法与过程后，可以发现：实际上每一次的排序之后都会通过调用本身来继续排序，这明显就是递归的精髓。

确实，**递归是快速排序的主要思想**，通过递归，我们将一个完整的序列经过不断的分解来变成很多个小序列，直到只有一个或没有数为止。**这种排序就是在不断的递归和分解当中来慢慢实现与完成排序**。

这里，我们提供了这个函数的参考代码：

```cpp
// 注：四个数组的下标均从 0 开始。
// 请在主函数内设置随机种子，例如 srand(time(0))，否则可能会超时。
int randint(int l, int r){ // 生成在 [l, r] 之间的随机数
	return rand() % (r - l + 1) + l;
}
void qsort(int l, int r){ // l 为左端点，r 为右端点
	if(l >= r){ // 如果长度为 0 或 1 就返回
		return;
	}
	int num = randint(l, r), ind1 = 0, ind2 = 0, ind3 = 0; // 随机选择一个数，并定义三个作为下标的变量来记录长度、存放数据
	for(int i = l;i <= r;i++){ // 将 a 中的数分别分到 b, c, d（如上所述）
		if(a[i] < a[num]){
			b[ind1++] = a[i];
		}
		else if(a[i] == a[num]){
			c[ind2++] = a[i];
		}
		else{
			d[ind3++] = a[i];
		}
	}
	for(int i = 0;i < ind1;i++){ // 将 b, c, d 中的数重新放回 a
		a[i + l] = b[i];
	}
	for(int i = 0;i < ind2;i++){
		a[i + ind1 + l] = c[i];
	}
	for(int i = 0;i < ind3;i++){
		a[i + ind1 + ind2 + l] = d[i];
	}
	qsort(l, l + ind1 - 1); // 继续递归，排序原来的 b 和 d
	qsort(l + ind1 + ind2, r);
}
```


#### 拓展：STL sort 函数的使用

（自定义比较方式时，除了下文所述的比较函数仍然有其他方法，感兴趣的读者可以自行了解，此处不再赘述。）

除了如上的快排模板外，我们还可以使用 C++ algorithm 头文件中的 sort 函数来直接完成排序。其使用方法如下：

我们设我们排序的数组为 $a$，排序区间为 $[l, r)$（即所有满足 $l\le x<r$ 的整数 $x$），且从小到大排序。则调用方法为：`sort(a + l, a + r)`。

注意，如果要使用这个函数，你应该在头文件中加上 `#include <algorithm>` 或者 `#include <bits/stdc++.h>`（万能头文件）。

如果我们不想从小到大排序，而是想从大到小排序，或者以其他方式进行排序，那么我们就应该写一个**比较函数**（一般命名为 `cmp`）来改变排序方法。

例如我们想要把一个类型为 `int` 的数组从大到小排序，我们应该这么定义这个比较函数：

```cpp
bool cmp(int a, int b){
	return a > b;
}
```

我们只需要定义两个与数组类型相同的变量作为参数，再返回两个数字的比较就可以了。

如果是从小到大排序，就用小于号连接两数；如果是从大到小排序，就用大于号连接两数。注意比较函数中的大于号、小于号不应改为大于等于号、小于等于号，否则会出现栈溢出等问题，导致意外的结果（例如运行时错误）。

写完这个函数，我们只需要在调用 `sort` 函数时在第三个参数写上函数名（例如 `sort(a + l, a + r, cmp);`）就可以了。

同样，结构体也可以用它排序。

例如我们定义一个结构体：

```cpp
struct node{
	int x, y;
}c[1005];
```

此时，我们想这样对 $c$ 的第 $1$ 到 $1000$ 项按如下所示的方式排序：$x$ 更大的在前，如果 $x$ 相同则 $y$ 更大的在前，那么我们可以这样写比较函数：

```cpp
bool cmp(node a, node b){
	if(a.x != b.x){ // 如果两个 x 不等则以 x 的大小排序
		return a.x > b.x;
	}
	return a.y > b.y; // 否则以 y 的大小排序
}
sort(c + 1, c + 1001, cmp);
```

在排序时，你可以通过以上所述的比较函数、重载运算符或者其他方式进行自定义比较，但是在比较方式不明确的情况下就无法排序。故在排序时需要确认比较方式明确。

---

### 快速排序的复杂度

#### 时间复杂度$^{[1]}$

快速排序最好情况下的时间复杂度为 $O(n\log n)$，一般情况下的复杂度为 $O(n \log n)$，最坏时间复杂度为 $O(n^2)$。如下是其证明：

根据快速排序的实现过程和如上代码可以发现，每一次将原序列分为 $3$ 个序列的过程的时间复杂度是 $O(n)$。

对于最优情况，当每一次随机选择的都是序列的中位数时，我们要排序的序列将被分成两个长度相差不多的两个序列。此时时间复杂度的递推式满足 $T(n)=2T(\frac{n}{2})+O(n)=O(n\log n)$，所以其最好情况为 $O(n\log n)$；

对于最坏情况，当每一次选择的都是数列的最值（一个典型的例子就是数列已经有序），此时除了与选定的数相等的数以外，剩下的数仍然需要排序（一个序列为空，另一个包含了除与选定的数相等的数以外的所有数），此时的复杂度递推式为 $T(n)=T(n-1)+n=O(n^2)$，所以快速排序的最坏时间复杂度为 $O(n^2)$。由于我们每次会随机选择，所以一般情况下带随机化的快速排序复杂度不会达到 $O(n^2)$。**在日常训练和比赛中，我们一般都认为快排的时间复杂度为 $O(n\log n)$**。

篇幅所限，这里无法提供一般情况下快排复杂度的证明，感兴趣的读者可以参考《算法导论》第 $7$ 章第 $4$ 节或查看 [OI Wiki 中的相关内容](https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)。

#### 空间复杂度

由于快速排序只需要一个序列来储存序列中的数（也可以再多加几个作为辅助），所以其空间复杂度为 $O(n)$。如果进行了一些优化可以降低额外的空间复杂度，但不影响总体的空间复杂度。

---

### 尾声

排序虽是最基本的普及组算法，但在信息学竞赛中往往有着无比重要的辅助作用，也是在思考题目时的重要思维支柱。愿看到这篇题解/笔记的后来者能够以排序等基础算法为根基，以此解决众多题目，在信息学竞赛中取得理想的成绩，~~而不是像我一样~~。

祝大家 OI 旅途好运。

---

### 引用

$[1]$：部分引用 OI Wiki 中有关[快速排序-时间复杂度](https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)的内容。

---

## 作者：Flanksy (赞：184)

## 简单排序 & 分块优化

**有动图，[建议在博客内阅读](https://www.luogu.com.cn/blog/Flanksy/solution-p1177)**

------------

### 前言

意义不大的[感叹](https://www.luogu.com.cn/paste/d4scwu0q)。

**这篇文章主要介绍选择排序和应用分块优化时间复杂度的方法，分块优化对插入排序、冒泡排序等同样适用。** 结尾顺带写了插入排序和冒泡排序。

文章中 $n$ 表示待排序元素数量，和题目中意义相同。

------------

### 选择排序

一种比较暴力的排序方法，将序列分为**有序区**和**无序区**，开始时有序区没有元素，每次找到无序区中最小的元素放入有序区，当无序区没有元素时排序结束。

每次找到的无序区最小的元素都将成为有序区最大的元素，由于是从小到大排序，把元素放在有序区右边即可，图示：

![selection sort](https://img.ryanli.top/i/4/65bc66a021ff9.gif)

橙色区域为有序区，蓝色区域为无序区，红色元素为无序区当前的最小元素。

选择排序的过程如下：

- 遍历无序区，标记最小元素的位置。
- 交换无序区第一个元素和最小元素。
- 标记无序区的第一个元素为有序的。
- 如果无序区为空，排序结束。

有序区和无序区仅用来帮助理解，代码实现中不需要标记。

简单来说就是**在第 $i$ 轮找到第 $i$ 大的元素放到有序区第 $i$ 个位置**。

每次遍历无序区都会向有序区添加一个元素，一共遍历 $n$ 次，每次遍历到的元素数量虽然递减，但仍然和 $n$ 同阶。

时间复杂度 $O(n^2)$，适用于 $n\leq 20000$ 的情况。

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
int n,a[100001];
void selection_sort(int l,int r){//对区间[l,r]排序
	int length=r-l+1;//区间长度即为遍历无序区的次数,每轮无序区即[l+i-1,r]
	for(int i=1;i<=length;i++){
		int aim=l+i-1;//最小元素的初始位置可以在无序区任取,这里选择无序区第一个元素
		for(int j=l+i-1;j<=r;j++) if(a[j]<a[aim]) aim=j;
		swap(a[l+i-1],a[aim]);//交换无序区第一个元素和最小元素
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	selection_sort(1,n);
	for(int i=1;i<=n;i++) cout<<a[i]<<' ';
	return 0;
}
```

------------

### 分块优化

本题中 $n\leq 100000$，选择排序等时间复杂度为 $O(n^2)$ 的排序算法一般无法通过，这时可以考虑分块以优化时间复杂度。

分块即**将序列分成几个部分，分别处理然后合并来得到最终答案**。

分块的技巧极多，笔者不能全部解释明白，这里默认块长为 $\sqrt n$（向下取整），详细解释写在后文的补充中，感兴趣的读者可以自行查看后面的内容。

由于块长已经设定为 $\sqrt n$，序列将会被分成约 $n\div \sqrt n=\sqrt n$ 块（$n$ 不一定为完全平方数），对这 $\sqrt n$ 个块分别进行选择排序。对一个块排序的时间复杂度为 $O(\sqrt n^2)$，一共 $\sqrt n$ 个块。

时间复杂度 $O(\sqrt n^2 \times \sqrt n)=O(n\sqrt n)$。

现在序列是**局部有序**的，接下来该合并答案了，但是不知道如何合并。如果再对整体进行选择排序，时间复杂度还是 $O(n^2)$，不可接受。感觉需要**利用一些性质**，先将序列的特殊性质罗列出来：

- 局部有序。

只有一个选项，答案不言而喻：**整个序列中最小的元素一定是某个块的第一个元素。** 每次遍历所有块的首个元素，其中最小的元素即为当前序列最小的元素。

每次遍历 $\sqrt n$ 个块，一共遍历 $n$ 次，时间复杂度 $O(n\sqrt n)$。

分块优化后的选择排序过程如下：

- 预处理：
	- 将序列分成长度至多 $\sqrt n$ 的 $\sqrt n$ 块，注意最后一块可能并没有 $\sqrt n$ 个元素。
	- 记录每个块的块首、块尾位置，对每个块进行选择排序。
- 合并块：
	- 遍历所有块，找到当前序列最小的元素，记录其所属块的编号。
   - 将当前最小的元素加入最终有序序列，这个元素所属块的块首前移。

如果某个块的块首超出了块尾，说明这个块是空的，跳过它即可。

总体时间复杂度 $O(n\sqrt n)$，适用于 $n\leq 500000$ 的情况。

```cpp
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
int n,block_len,block_num,head[1001],tail[1001],a[100001],ans[100001];
void selection_sort(int l,int r){
	int length=r-l+1;
	for(int i=1;i<=length;i++){
		int aim=l+i-1;
		for(int j=l+i-1;j<=r;j++) if(a[j]<a[aim]) aim=j;
		swap(a[l+i-1],a[aim]);
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	block_len=sqrt(n);//计算块长 
	block_num=(n-1)/block_len+1;//除法上取整计算块数,也可以换用下面一行统计块数 
//	for(int i=0;i<=n-1;i+=block_len) block_num++;

	for(int i=1;i<=block_num-1;i++){//最后一块可能不完整,单独处理 
		head[i]=block_len*(i-1)+1;//块i包含的范围是[head[i],tail[i]] 
		tail[i]=head[i]+block_len-1;
	}
	head[block_num]=block_len*(block_num-1)+1;
	tail[block_num]=n;
    for(int i=1;i<=block_num;i++) selection_sort(head[i],tail[i]);

	for(int i=1;i<=n;i++){
		int aim=0;//aim:块首元素最小的块编号 
		for(int j=1;j<=block_num;j++)
			if(head[j]<=tail[j]){aim=j;break;}//找一个非空块的块首 
		
		for(int j=aim+1;j<=block_num;j++){
			if(head[j]>tail[j]) continue;
			if(a[head[j]]<a[head[aim]]) aim=j;
		}
		ans[i]=a[head[aim]];//计入答案 
		head[aim]++;//块首前移 
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
	return 0;
}
```

------------

### 关于块长

块长可以设为常数，一般情况下块长只要和 $\sqrt n$ 同阶就没有问题，$n$ 需要取上界 $10^5$。笔者的实现中选择 $\sqrt n$ 作块长，这里（并不严谨地）解释原因。

设块长为 $x$，块数量就为 $y=n/x$。

预处理时间复杂度 $O(x^2y)=O(x^2 \times n / x)=O(nx)$，合并块时间复杂度 $O(ny)=O(n\times n / x)=O(n^2/x)$。

利用基本不等式可知当 $x=\sqrt n$ 时 $nx$ 和 $n^2/x$ 中的最大值最小且 $nx+n^2/x$ 取最小值。

[完整代码](https://www.luogu.com.cn/paste/byf6838z)：本题数据范围下块长固定在 $1000$ 左右时效率最高。

经过测试优秀的实现可以在 1s 内完成 $10^6$ 个元素的排序。

------------

### 插入排序

将序列分成有序区和无序区，每次随便从无序区找一个元素（一般取第一个元素）插入到有序区，插入时操作有序区来保持其有序性质，图示：

![insection sort](https://img.ryanli.top/i/4/65bc66a00db4e.gif)

常数较小，一般比选择排序和冒泡排序都快。

插入排序的过程如下：

- 在无序区选中一个元素。
- 有序区向右扩展，所有比该元素大的元素右移，创造一个空位。
- 将选中的元素放入空位。
- 如果无序区为空，排序结束。

进行 $n$ 次插入，有序区每轮最坏移动次数与 $n$ 同阶，时间复杂度 $O(n^2)$。

代码仅给出函数部分。

```cpp
void insection_sort(int l,int r){//对区间[l,r]排序 
	int length=r-l+1;
	for(int i=1;i<=length;i++){
		int pos=l+i-2,now=a[l+i-1];//无序区第一个元素会被覆盖 
		while(pos>=l&&a[pos]>now) a[pos+1]=a[pos],pos--;
		a[pos+1]=now;//注意pos+1才是空位 
	}
}
```

------------

### 冒泡排序

在冒泡排序中，一般无序区在有序区左边，即一般先找出较大值。

遍历无序区，如果某个元素比其右边的元素大就交换，图示：

![bubble sort](https://img.ryanli.top/i/4/65bc669feb9d1.gif)

每轮会将无序区的最大元素换到最右边。如同泡泡从水中上浮，体积最大的会先浮出水面。

冒泡排序的过程如下：

- 遍历无序区，如果某个元素比其右边的元素大就交换它们。
- 标记无序区最右端的元素为有序。
- 如果无序区为空，排序结束。

进行 $n$ 轮，每轮遍历的元素数量与 $n$ 同阶，时间复杂度 $O(n^2)$。

代码仅给出函数部分。

```cpp
void bubble_sort(int l,int r){
	int length=r-l+1;
	for(int i=1;i<=length;i++)//注意a[r]不应与其右边元素比较
		for(int j=l;j<=r-i;j++) if(a[j]>a[j+1]) swap(a[j],a[j+1]);
}
```

------------

### 后记

这个算法是我独立想出来的，以前不会分块但是一直挺好奇，有一天突发奇想“排序能不能分块”，仔细想想感觉对每个块暴力时间复杂度挺对，又想了想发现可以像归并一样合并，时间复杂度也很对。于是就有了这篇文章里的内容，笔者第一次写分块就是这个排序算法。后来发现数据结构题的分块实现和排序还是挺不一样的。

上边的分块优化代码里选择排序换成文中其他两个也能通过。

朴素的选择排序、插入排序、冒泡排序都交了一遍，选择排序过了三个测试点，另外两个过了一个测试点。分块 + 插入排序最快，毕竟插入排序最好时间复杂度是 $O(n)$ 嘛。不过冒泡排序也能做到最好时间复杂度 $O(n)$。

希望我的学弟学妹们会比我更强。

---

## 作者：梦应归于何处 (赞：59)

这题的数据范围一看是 $ N \leq 10^5 $  所以，这题肯定不能用 $ O ( n^2 ) $ 的排序方法。

下面，我给大家介绍一种复杂度为 $ O ( n \log n ) $ 排序方法，**归并排序**。

### 归并排序

归并排序用的是分治思想，分为三大步：

1.分解：将 $ n $ 个元素分成两个含有 $ n \div 2 $ 个元素的子序列。

2.解决：用合并排序法对两个子序列递归来排序。

3.合并：合并两个已排序的子序列来得到最终的排序结果。

我给大家介绍的是递归法：

动图演示：

![](https://pic.rmb.bdstatic.com/bjh/down/095deac03e3678e35646bca306d641fc.gif)

下面是代码，代码中有解释：

~~~cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll a[600000], b[600000], ans;
void mergee(ll l, ll r) {
	if (l >= r) {  //不能再分了，直接返回。
		return ;
	}
	ll mid = (l + r) / 2;//取一个中间值
	ll i = l, j = mid + 1, tot = l;  // i是第一个序列的开头，j是第二个序列的开头，tot是整个的大序列。
	while (i <= mid && j <= r) {  //合并
		if (a[i] <= a[j]) {  //谁小就把谁放到前面。
			b[tot++] = a[i]; 
			i++;
		} else {
			b[tot++] = a[j];
			j++;
		}
	}
	while (i <= mid) {  //可能还没有放完，就把剩下的放进来。
		b[tot++] = a[i];
		i++;
	}
	while (j <= r) {  // 同上
		b[tot++] = a[j];
		j++;
	}
	for (int i = l; i <= r; i++) {  // 给最终的答案数组赋值。
		a[i] = b[i];
	}
	return;
}
void mergesort(ll l, ll r) {
	if (l < r) {
		int mid = (l + r) / 2;
		mergesort(l, mid);  //  先给左子序列排序。
		mergesort(mid + 1, r); //再给右子序列排序。
		mergee(l, r);  // 最后把两个子序列合并。
	}
}
int main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ll n;
	cin>>n;
	for (int i = 1; i <= n; i++) {
		cin>>a[i];
	}
	mergesort(1, n);
	for (int i=1;i<=n;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}


~~~

---

## 作者：AKPC (赞：46)

### 排序算法
排序算法是对一个数列根据某种规律进行重排列的操作，一般都是从小（大）到大（小）。
### 经典入门排序算法：冒泡排序
虽然不是正解但是可以介绍，这个主要是带萌新了解排序的实现，这也是排序算法中最通俗易懂的一个了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100001];
void pop_sort(){
	for (int i=1;i<=n;i++)
		for (int j=1;j<n;j++)
			if (a[j]>a[j+1]) swap(a[j],a[j+1]);//change a[j] and a[j+1].
}
signed main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	pop_sort();
	for (int i=1;i<=n;i++) cout<<a[i]<<' ';
	return 0;
}
```

思路：

每次将未确定部分的相邻两个值对比，设为 $a_i,a_{i+1}$。如果 $a_i>a_{i+1}$ 则对这两个值进行交换，可以使用 ```swap``` 来快速对两个值进行交换。

那么，这样一轮交换下去，第一个数就可以确定是最小的了。以此类推，直到所有值都被确定，就得出最终排好序的数列了。

时间复杂度 $\text O(n^2)$。
### 分析本题
本题 $1\leq n \leq 10^5$，那么 $\text O(n^2)$ 是过不去的，至少要 $\text O(n\log n)$。
### 正解来力，快速排序
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100001],b[100001],c[100001],d[100001];
void quick_sort(int l,int r){
	if (l>=r) return;
	int mid=rand()%(r-l+1)+l;//This value is random.
	int tb=0,tc=0,td=0;//b is smaller than a[mid],c is bigger than it,d is the same of it.
	for (int i=l;i<=r;i++){
		if (a[i]<a[mid]) b[++tb]=a[i];
		else if (a[i]>a[mid]) c[++tc]=a[i];
		else d[++td]=a[i];
	}
	for (int i=1;i<=tb;i++) a[l+i-1]=b[i];
	for (int i=1;i<=td;i++) a[l+i-1+tb]=d[i];
	for (int i=1;i<=tc;i++) a[l+i-1+tb+td]=c[i];
	quick_sort(l,l+tb-1);
	quick_sort(l+tb+td,r);
}
signed main(){
	srand((int)time(0));
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	quick_sort(1,n);
	for (int i=1;i<=n;i++) cout<<a[i]<<' ';
	return 0;
}
```

思路：

找到一个“基准”，将小的往前面放，将大的往后面放。由于数据的不确定性，这个“基准”最好是一个随机数。这样分成三块：比基准小的，等于基准的，大于基准的。将第一者和第三者再递归进行快排。

平均复杂度 $\text O(n \log n)$，但是并不太稳定。

上述是手写快排，更稳定更简单的 ```STL``` 大法给我们提供了 ```sort``` 排序！其用法为 ```sort(<要排序的数组>+<排序区间左端>,<要排序的数组>+<排序区间右端>,<排序规则>)```。其中排序规则默认为从小到大。

复杂度 $\text O(n \log n)$，稳定。所以考场最好写一个 ```sort``` 实现排序。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100001];
signed main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++) cout<<a[i]<<' '; 
	return 0;
}
```

拓展 ```STL sort``` 的排序规则（命名为 ```cmp```）：

只是一个普通数列的排序直接写就行。如下是从大到小的排序规则的示例：

```cpp
bool cmp(int o,int p){
	return o>p;//biggest is first
}
```

当然你可以玩更多的花样，比如数列所有值模上 $3$ 的值从大到小的排列，如果模上 $3$ 的值相等，原值大的在前面：

```cpp
bool cmp(int o,int p){
	if (o%3>p%3) return 1;
	else if (o%3==p%3&&o>p) return 1;
	else return 0;
}
```

结构体排序：

结构体的复杂那么一点点，但也很简单。如果不知道结构体可以自行百度。如下的判定规则：结构体的两个值为 $a,b$，按照 $a$ 从大到小排序，如果 $a$ 出现相等，按照 $b$ 从大到小排序。

```cpp
struct node{
	int a,b;//create a struct "node"
};
bool cmp(node o,node p){
	if (o.a!=p.a) return o.a>p.a;
	return o.b>p.b;
}
```

结构体重载运算符排序：

重载即为重写 ```sort``` 的规则，主要在结构体内运用 ```operator<```，而不是 ```cmp```。

```cpp
struct node{
	int a,b;//create a struct "node"
	bool operator<(const node x){
		if (a!=x.a) return this->a>x.a;
		return this->b<x.b;
	}
};
```


在 ```sort``` 中调用的时候直接写 ```cmp``` 就行，不用加括号。不过如果你使用了结构体重载运算符，则不需要调用。

---

## 作者：HappyCode (赞：45)

### 简易版桶排序

OI-Wiki：<https://oi-wiki.org/basic/bucket-sort/>

PS：本文的简易版桶排为 OI-Wiki 上的桶排去掉分块部分。

建立一个新数组 $b$，$b_i$ 代表待排序数组 $a$ 中值为 $i$ 的数量。

统计完后遍历 $b$，按顺序输出 $b_i$ 个 $i$。

计数排序复杂度为 $O(n+w)$，空间复杂度为 $O(w)$，$w$ 为待排序数据值域。

因为本题 $w \le 10^9$，因此使用计数排序 $b$ 数组需要开到 $10^9$，会爆空间，因此只能开到 $10^8$ 获得 60pts。

```cpp
// https://www.luogu.com.cn/record/109481901
#include<iostream>
using namespace std;
int n,b[100000005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        b[x]++;
    }
    for(int i=1;i<=100000000;i++){
        for(int j=1;j<=b[i];j++){
            cout<<i<<' ';
        }
    }
    return 0;
}
```

### 冒泡排序

OI-Wiki：<https://oi-wiki.org/basic/bubble-sort/>

循环枚举每个元素，如果当前元素大于下个元素（若升序则反之）就交换当前元素与下个元素。当一轮枚举中没有交换时即排序结束。

时间复杂度为 $O(n^2)$，因为时间复杂度过高只能获得 60pts。

```cpp
// https://www.luogu.com.cn/record/109484406
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[100005];
void swap(int &a,int &b){
    int t=a;
    a=b;
    b=t;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    bool flag=true;
    while(flag){
        flag=false;
        for(int i=1;i<n;i++){
            if(a[i]>a[i+1]){
                flag=true;
                swap(a[i],a[i+1]);
            }
        }
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

### 插入排序

OI-Wiki：<https://oi-wiki.org/basic/insertion-sort/>

将未排序序列中的一个元素放到已排序序列中的正确位置。

时间复杂度为 $O(n^2)$，但因为常数小可以通过本题。

```cpp
// https://www.luogu.com.cn/record/109490353
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[100005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        int x=a[i];
        int j=i-1;
        while(j>=0 and a[j]>x){
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=x;
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

### 选择排序

OI-Wiki：<https://oi-wiki.org/basic/selection-sort/>

找出序列中的第 $i$ 小（若升序则大于）值，将其放在第 $i$ 个位置。

时间复杂度为 $O(n^2)$，但因为常数小可以通过本题。

```cpp
// https://www.luogu.com.cn/record/109489083
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[100005];
void swap(int &a,int &b){
    int t=a;
    a=b;
    b=t;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        int x=i;
        for(int j=i+1;j<=n;j++){
            if(a[j]<a[x]){
                x=j;
            }
        }
        swap(a[i],a[x]);
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

### 快速排序

OI-Wiki：<https://oi-wiki.org/basic/quick-sort/>

先把序列分成两个部分，保证前一个子序列中的数都小于（若升序则大于）后一个子序列中的数。一般选择序列中点 $m$ 作为分界。

维护两个指针 $i$ 和 $j$，如果 $a_i$ 小于（若升序则大于）分界点 $a_m$ 则将 $i$ 向前一位，如果 $a_j$ 大于（若升序则小于）分界点 $a_m$ 则将 $j$ 向后一位。如果不满足则将第一个有问题的 $a_i$ 与第一个有问题的 $a_j$ 交换。

最后对两个子序列分别进行快速排序即可。

时间复杂度为 $O(n\log n)$，但最坏情况（数组已经有序，本题 #5）下会退化至 $O(n^2)$，但仍可通过本题。

```cpp
// https://www.luogu.com.cn/record/76625312
#include<iostream>
using namespace std;
int n,a[100005];
void swap(int &a,int &b){
    int t=a;
    a=b;
    b=t;
}
void sort(int a[],int l,int r){
    int i=l,j=r,flag=a[(l+r)/2];
    do{
        while(a[i]<flag){
            i++;
        }
        while(a[j]>flag){
            j--;
        }
        if(i<=j){
            swap(a[i],a[j]);
            i++;
            j--;
        }
    }while(i<=j);
    if(l<j){
        sort(a,l,j);
    }
    if(i<r){
        sort(a,i,r);
    }
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a,0,n-1);
    for(int i=0;i<n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

### STL

OI-Wiki：<https://oi-wiki.org/basic/stl-sort/#stdsort>

使用 `sort(a,a+n)` 可以将 $a_0$ 到 $a_{n-1}$ 升序排序，同理排序 $a_1$ 到 $a_n$ 的方法为 `sort(a+1,a+n+1)`。

如需降序排序或自定义排序，可编写 `cmp` 函数。函数的参数为两个待排序元素，返回值为 `bool` 型，为第一个元素是否在第二个元素前面。将 `cmp` 函数作为参数传入 `sort` 函数（如 `sort(a+1,a+n+1,cmp)`）即可实现降序或自定义函数。

时间复杂度为 $O(n\log n)$，可以通过本题。

```cpp
// https://www.luogu.com.cn/record/109483053
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[100005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

---

## 作者：ran_qwq (赞：38)

## 堆排序

### 0x00 选择排序

#### 0x01 思想

堆排序是选择排序的优化，所以这里先讲一下选择排序。

选择排序有两个数组：一个**排好序的**，一个**没排好序的**。一开始排好序的数组是空数组，所有数都在没排好序的数组中。

每一轮会从**没排好序的**数组中 $O(n)$ 扫一遍选一个最小的，把它从没排好序的数组中删掉，放到排好序的数组中。这样进行 $n$ 次，就排好序了，时间复杂度 $O(n^2)$。

#### 0x02 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f;
int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
void Write(int x){if(x<0){putchar('-'),Write(-x);return;}if(x<10){putchar(x+'0');return;}Write(x/10),putchar(x%10+'0');}
void write(int x,char *s){Write(x),printf("%s",s);}
int n,len,a[N],b[N],vis[N];
void solve()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++)
	{
		int mn=INF,id=0;
		for(int j=1;j<=n;j++)
			if(!vis[j]&&a[j]<mn) id=j,mn=a[j];
		vis[id]=1,b[++len]=mn;
	}
	for(int i=1;i<=n;i++) write(b[i]," ");
}
signed main()
{
	int T=1;
	while(T--) solve();
}
```

### 0x20 堆排序

此算法无法过掉这道题，考虑对它进行优化。每次找最小值的过程时间复杂度较大，尝试把它优化到低于 $O(n)$。可以用到一种数据结构：堆。

#### 0x21 堆的概念

堆是一棵**完全二叉树**，且满足父节点都比子节点大或小。如果父节点都比子节点大，这是一个大根堆（根节点最大）；如果父节点都比子节点小，这是一个小根堆（根节点最小）。本题要从小到大排序，所以要用小根堆。

堆可以支持 $O(\log n)$ 的插入和删除。

#### 0x22 插入

一开始插入在底部。因为小根堆要满足父节点比子节点小，所以如果新加入的数比父亲节点小，就要往上挪。这样直到到达顶部或无法往上挪就停止。

```cpp
int n,len,heap[N];
void push(int x)
{
	if(x==1||heap[x>>1]<=heap[x]) return;
	swap(heap[x>>1],heap[x]),push(x>>1);
}
```

#### 0x23 删除

每次删除要删除根节点，先把根节点清除。接着如果左子节点大就让它往上挪，否则让右子节点往上挪。直到左子节点和右子节点都无法往上挪为止。

```cpp
void pop(int x)
{
	int y=x;
	if((x<<1)<=len&&heap[x<<1]<heap[x]) y=x<<1;
	if((x<<1|1)<=len&&heap[x<<1|1]<heap[y]) y=x<<1|1;
	if(y!=x) swap(heap[x],heap[y]),pop(y);
}
```

#### 0x24 全部代码

先把所有数加入到堆中，再删除 $n$ 次，得到的就是排好序的序列。

因为堆是一棵完全二叉树，深度是 $\log n$ 层级的，所以整个排序时间复杂度为 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,INF=0x3f3f3f3f;
int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
void Write(int x){if(x<0){putchar('-'),Write(-x);return;}if(x<10){putchar(x+'0');return;}Write(x/10),putchar(x%10+'0');}
void write(int x,char *s){Write(x),printf("%s",s);}
int n,len,heap[N];
void push(int x)
{
	if(x==1||heap[x>>1]<=heap[x]) return;
	swap(heap[x>>1],heap[x]),push(x>>1);
}
void pop(int x)
{
	int y=x;
	if((x<<1)<=len&&heap[x<<1]<heap[x]) y=x<<1;
	if((x<<1|1)<=len&&heap[x<<1|1]<heap[y]) y=x<<1|1;
	if(y!=x) swap(heap[x],heap[y]),pop(y);
}
void solve()
{
	n=read();
	while(len<n) heap[++len]=read(),push(len);
	while(len) write(heap[1]," "),heap[1]=heap[len--],pop(1);
}
signed main()
{
	int T=1;
	while(T--) solve();
}
```

#### 0x25 STL 的 priority_queue

C++ 的 STL 有优先队列，底层用堆实现，在 queue 头文件中。

新建一个大根堆是这样：

```cpp
priority_queue<int>q;
```

如果要新建小根堆就这样：

```cpp
priority_queue<int,vector<int>,greater<int> >q;
```

插入操作是这样：

```cpp
q.push(x);
```

删除根节点是这样：

```cpp
q.pop();
```

访问根节点是这样：

```cpp
q.top();
```

用 STL 优先队列代码会更短，也可以过掉这道题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f;
int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
void Write(int x){if(x<0){putchar('-'),Write(-x);return;}if(x<10){putchar(x+'0');return;}Write(x/10),putchar(x%10+'0');}
void write(int x,char *s){Write(x),printf("%s",s);}
int n,a[N];
priority_queue<int,vector<int>,greater<int> >q;
void solve()
{
	n=read();
	while(n--) q.push(read());
	while(q.size()) write(q.top()," "),q.pop();
}
signed main()
{
	int T=1;
	while(T--) solve();
}
```

---

## 作者：Furina_Hate_Comma (赞：33)

**排序**模板题。

我写了插入排序，冒泡排序，选择排序，归并排序，快速排序，桶排序。

具体算法看注释。

下面主要讲一讲插入排序。

大家都玩过扑克牌吧，每次我们拿到一张牌，将它插入一个合适的位置，这就是插入排序。

更标准的描述是将一个无序区间的第一个数字从后面逐个找到第一个比它大的数并插入。

下面讲解一下具体方法。

以这个序列为例：

$$11,45,14,91,19,98,10$$

首先将 $11$ 插入，得到:

$$11|45,14,91,19,98,10$$

左边是有序区间，右边是无序区间。

接下来得到

$$11,45|14,91,19,98,10$$

然后

$$11,14,45|91,19,98,10$$

接下来继续操作直至有序。

时间复杂度：

每次插入会花费接近 $O(n)$ 的时间，而一共有 $n$ 次插入，所以是 $O(n^2)$，而在最优情况下为 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010],bucket[2000010],temp[2000010];
void Selection_sort(int n)//选择排序
{
//每次选择最小的放到最未排序部分最前面
	int i,j;
	for(i=0;i<n;i++)//枚举放的位置
	{
		for(j=i+1;j<n;j++)//枚举后面
		{
			if(a[j]<a[i])
			{
				swap(a[i],a[j]);//交换，放置到当前最前面
			}
		}
	}
}
void bubble_sort(int n)//冒泡排序
{
//每次比较相邻两个，如果不符合就交换，那么每一轮排序后最后面会多一个最大的
	int i,j;
	for(i=0;i<n;i++)//枚举第几轮
	{
		for(j=0;j<n-i;j++)//枚当前未排序区间
		{
			if(a[j+1]<a[j])
			{
				swap(a[j],a[j+1]);//冒泡操作
			}
		}
	}
}
void bucket_sort(int n)//桶排序
{
//将元素放入桶中，最后遍历桶
	int i,big=0,k=0;
	memset(bucket,0,99999);
	for(i=0;i<n;i++)
	{
		bucket[a[i]]++;//放入桶中
		if(a[i]>big)
		{
			big=a[i];//记录最大值，枚举桶时会用到
		}
	}
	for(i=0;i<big+1;i++)//枚举桶
	{
		if(bucket[i]>=0)
		{
			for(int j=0;j<bucket[i];j++)
			{
				a[k++]=i;//输出桶到序列中
			}
		}
	}
}
void insertion_Sort(int n)//插入排序
{
//每次将当前数向前枚举并插入合适的位置
	int i,j,temp;
	for(i=0;i<n;i++)//插入第i个数
	{
		temp=a[i];
		for(j=i-1;j>=0&&temp<a[j];j--)//插入过程
		{
			a[j+1]=a[j];//整体后移
		}
		a[j+1]=temp;
	}
}
void merge_Sort(int l,int r)//归并排序
{
//每次将区间二分，直到单独的数，由于一个数有序，返回合并区间。
	if(l>=r)return ;//单独的数
		int mid=(l+r)/2,i,j,c=0;
		merge_Sort(l,mid);//排序左区间
		merge_Sort(mid+1,r);//排序右区间
		i=l;
		j=mid+1;
		while(i<=mid&&j<=r)//在temp中进行合并操作
		{
			if(a[i]<a[j])temp[++c]=a[i++];
			else temp[++c]=a[j++];
		}
		while(i<=mid)temp[++c]=a[i++];
		while(j<=r)temp[++c]=a[j++];
		for(i=1;i<=c;i++)//复制到原数组
		{
			a[l++]=temp[i];
		} 
}
void quick_sort(int l, int r)//快速排序
{
//每次选一个数，以它为界划分左右区间并像归并一样返回
    if (l< r)//边界
    {     
        int i = l, j = r, x = a[l];
        while (i < j)//以x为界划分
        {
            while(i < j && a[j]>= x)
                j--; 
            if(i < j)
                a[i++] =a[j];
            while(i < j && a[i]< x)
                i++; 
            if(i < j)
                a[j--] = a[i];
        }
        a[i] = x;
        quick_sort( l, i - 1); //递归左区间
        quick_sort( i + 1, r);//递归右区间
    }
}
	

int main () {
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",a+i);
    merge_Sort(1,n);//我个人喜欢归并，因为快排有可能退化O(n^2)
    for(int i=1;i<=n;++i)
        printf("%d ",a[i]);
    return 0;
}
```


---

## 作者：ice_fish01 (赞：18)

## $\text{P1177}$ 【模板】排序

### 前言

- 本题解是按照 @[**览遍千秋**](https://www.luogu.com.cn/user/28910)的[**要求**](https://www.luogu.com.cn/discuss/603741)编写。
- 在这里，你可以领悟到 STL 的妙处，~~并深深的爱上它~~。

### $20$ 分做法：选择排序

选择排序是一种**简单直观**的排序算法。它的工作原理是每次找出第 $i$ 小的元素（也就是 $a_{i\cdots n}$ 中最小的元素），然后将这个元素与数组第 $i$ 个位置上的元素交换。

选择排序具有**不稳定**的特点，最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 $O(n^2)$。

由于这种做法复杂度太高，且用起来太差劲，直接贴上代码，仅供参考：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T> //这里没什么用的快读
inline void read(T &x) {
    x = 0;
    int f = 1;
    char c = getchar();

    while (!isdigit(c)) {
        if (c == '-')
            f = -1;

        c = getchar();
    }

    while (isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    x *= f;
}
template<typename T, typename ... Args>
inline void read(T &x, Args &... y) {
    read(x);
    read(y...);
}
int n, a[100010];
signed main() {
    read(n);

    for (int i = 1; i <= n; i++)
        read(a[i]);

    for (int i = 1; i < n; i++) {
        int ith = i;

        for (int j = i + 1; j <= n; j++) {
            if (a[j] < a[ith])
                ith = j;
        }

        swap(a[i], a[ith]);
    }

    for (int i = 1; i <= n; i++)
        cout << a[i] << ' ';

    return 0;
}
```

### $60$ 分做法：冒泡排序、桶排序

**冒泡排序**

冒泡排序是一种简单的排序算法。由于在算法的执行过程中，**较小的元素像是气泡般慢慢「浮」到数列的顶端**，故叫做冒泡排序。

它的工作原理是每次**检查相邻两个元素**，如果前面的元素与后面的元素**满足给定的排序条件，就将相邻两个元素交换**。当没有相邻的元素需要交换时，排序就完成了。可以证明，冒泡排序最多需要扫描 $n-1$ 遍数组就能完成排序。

冒泡排序是一种**稳定**的排序算法,平均时间复杂度为 $O(n^2)$。代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x) {
    x = 0;
    int f = 1;
    char c = getchar();

    while (!isdigit(c)) {
        if (c == '-')
            f = -1;

        c = getchar();
    }

    while (isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    x *= f;
}
template<typename T, typename ... Args>
inline void read(T &x, Args &... y) {
    read(x);
    read(y...);
}
int n, a[100010];
signed main() {
    read(n);

    for (int i = 1; i <= n; i++)
        read(a[i]);

    bool flag = true;

    while (flag) { // 还未满足有序
        flag = false;

        for (int i = 1; i < n; i++) {
            if (a[i] > a[i + 1]) {
                flag = true; // 交换后需要继续排序过程
                swap(a[i], a[i + 1]); // 交换两个元素
            }
        }
    }

    for (int i = 1; i <= n; i++)
        cout << a[i] << ' ';

    return 0;
}

```

**计数排序**

**友情提示：本部分我采用了 STL 中的 `map` 实现，请不懂 `map` 的同学到下面去看正解。**

[$\text{P1271}$ 【深基 $9$.例 $1$】选举学生会](https://www.luogu.com.cn/problem/P1271) 一题中已经对其方法做了介绍，这里略过。放上代码：（MLE $2$ 个测试点）

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x) {
    x = 0;
    int f = 1;
    char c = getchar();

    while (!isdigit(c)) {
        if (c == '-')
            f = -1;

        c = getchar();
    }

    while (isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    x *= f;
}
template<typename T, typename ... Args>
inline void read(T &x, Args &... y) {
    read(x);
    read(y...);
}
map <int, int> t;
int n, a, maxi = -1;
signed main() {
    read(n);

    for (int i = 1; i <= n; i++) {
        read(a);
        t[a]++;
        maxi = max(maxi, a); // 取数列最大值，这样遍历 map 时可以减少时间
    }

    for (int i = 1; i <= maxi; i++) {
        for (int j = 1; j <= t[i]; j++)
            cout << i << ' ';
    }

    return 0;
}
```
### 正解：`sort` 排序

- `sort` 排序是 `algorithm` 头文件中自带的一个函数。
- 它可以对数组中任意一段**按照你的方式**进行排序。
- 用法：`sort(a+1,a+n+1)` 或 `sort(a+1,a+n+1,cmp)`。其中 $a$ 是数组名，它可以将 $a$ 数组中 $a_1\sim a_n$ 的这一部分排序。
- 其中 `cmp` 是比较函数，返回值应是 `true` 或 `false`。它可以接受两个元素 $a,b$，返回 `true` 代表 $a$ 应该排在 $b$ 之前，反之也成立。
- C++11 标准以及后续标准要求它的**最坏**时间复杂度达到 $O(n\log n)$。

代码如下：

```cpp
//P1177 【模板】快速排序
#include <bits/stdc++.h>
using namespace std;
int a[100010];
int main() {
    int n;
    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> a[i];

    sort(a + 1, a + n + 1);

    for (int i = 1; i <= n; i++)
        cout << a[i] << ' ';

    return 0;
}
```

### 引用

- OI-Wiki 排序 中的部分内容。

---

## 作者：Xiphi (赞：15)

**前排提示：这篇题解主要讲解基于二叉排序树的排序。**

## 基本概念
二叉排序树是具有一下几种性质的**二叉树**：
- 任何节点的左或右儿子不空，则左或右子树上所有节点均小于他的根节点的值。
- 这棵树的所有子树也均为二叉排序树。
- 一般情况下没有 $key$ 值相等的节点。

二叉排序树的最大特点就是有序性。对于任意一个节点，它的左子树上所有节点的值都小于它的值，其右子树上所有节点的值都大于它的值。因此，对于一个二叉排序树，它的中序遍历结果是一个递增的有序序列。

最朴素的二叉排序树的插入删除操作复杂度均为树高。每次操作期望 $O(\log_2n)$，最坏 $O(n)$（原数列有序，树退化成一条链）。其支持动态查询，改进版的二叉排序树可使树高恒为 $\log_2n$，如   $\operatorname{Treap}$ 等。

## 二叉排序树的插入

由于二叉排序树的有序性，所以插入操作可以使用二分查找的思想来实现。具体来说，对于一个节点，如果要插入一个值 $v$，我们可以比较 $v$ 和该节点的值，如果 $v$ 小于该节点的值，则在左子树中插入；如果 $v$ 大于该节点的值，则在右子树中插入。

如果你还是不太会写，我们具体来分一下步骤：

1. 若 $t$ 为空树，则将 $v$ 作为根节点插入，否则执行步骤 $2$。
2. 若 $v$ 等于根节点节点的值，返回即可，否则执行步骤 $3$。
3. 若 $v$ 小于根节点节点的值，则将 $v$ 插入到该节点的左子树，否则执行步骤 $4$。
4. 把 $v$ 插入到右子树。

代码实现：
```cpp
const int N=500005;
int n,cnl,rt=0,a[N],t[N],chi[N][3];
int b[N];
void insert(int &x,int v){//插入一个值为 v 的节点
	if(x==0){//为空节点，则插入
    	++cnl;//节点个数+1
      	x=cnl;//更新节点标号
        t[x]=v;
       	return ;//返回
    }
    if(v<t[x]) insert(chi[x][1],v);//去左子树
	else insert(chi[x][2],v);
}
```

## 二叉排序树的查找

同上，可以使用二分查找的思想来实现查找操作。具体来说，对于一个节点，如果要查找它的值v，我们可以比较 $v$ 和该节点的值，如果 $v$ 小于该节点的值，则在左子树中查找；如果 $v$ 大于该节点的值，则在右子树中查找。

如果你还是不太会写，我们具体来分一下步骤：

1. 若 $t$ 为空树，直接返回查找失败，否则执行步骤 $2$。
2. 若 $v$ 等于根节点的值，查找成功，返回即可，否则执行步骤 $3$。
3. 若 $v$ 小于根节点的值，则 $v$ 搜索该节点的左子树，否则执行步骤 $4$。
4. $v$ 搜索右子树。

这里就不给出代码实现了，因为本题不会用到。

## 二叉排序树的中序遍历

当所有节点插入完毕，我们就可以对其进行中序遍历，然后输出即可。这里采用递归的方法实现：
```cpp
void zdfs(int u){
	if(!u) return ;
    zdfs(chi[u][1]);
    cout<<t[u]<<' ';
    zdfs(chi[u][2]);
}
```

注意，在排序前要把数组随机打乱，使得复杂度不会退化。

## 代码实现
如果你已经按照我说的打了一遍，就会发现最后两个点 TLE 了，是因为相同的元素也会拉长链，这时，我们引入一个数组记录每个点的元素个数即可（把相同元素放入同一节点，输出时输出 $tcnt_i$ 次）。

最终代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,cnl,rt=0,a[N],t[N],chi[N][3];
int tcnt[N];
mt19937 Rnd(N);
int b[N];
void insert(int &x,int v){//插入一个值为 v 的节点
	if(x==0){//为空节点，则插入
    	++cnl;//节点个数+1
      	x=cnl;//更新节点标号
        t[x]=v;
        tcnt[x]=1;
       	return ;//返回
    }
    if(v<t[x]) insert(chi[x][1],v);//去左子树
	else if(v>t[x]) insert(chi[x][2],v);
	else if(v==t[x]) tcnt[x]++;
}
void zdfs(int u){
	if(!u) return ;
    zdfs(chi[u][1]);
    for(int i=1;i<=tcnt[u];++i) cout<<t[u]<<' ';
    zdfs(chi[u][2]);
}
int main(){
//	freopen("P1177_4.in","r",stdin);
    cin>>n;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        swap(a[i],a[(Rnd()%n)+1]);
    for(int i=1;i<=n;++i) insert(rt,a[i]);
	zdfs(rt);
    return 0;
}
```

## 补充内容

### 其他应用

二叉排序树还有许多应用，如删除操作等等。二叉排序树的复杂度容易退化，但一些方法可以使其平衡，树高保持在 $\log_2 n$，那么其各种操作的复杂度为 $O(\log_2n)$，十分优秀。其平衡方法可以自行查找资料。

### 快速排序

至于 stl 中的其他排序，如快速排序，这里也给出用法。

其“固定搭配”基本为：
```cpp
sort(a+1,a+n+1);//数组名称为 a，下标从 1 到 n，从小到大排序
sort(a,a+n) //数组名称为 a，下标从 0 到 n-1，从小到大排序
sort(a+1,a+n+1,cmp) //数组名称为 a，下标从 1 到 n，排序规则为cmp
```

---

## 作者：lichenzhen (赞：15)

## 题目简述
对 $N$ 个数进行从小到大排序。

## 题目解法
排序的方法有很多种，有冒泡排序、插入排序、堆排序、计数排序（桶排序）、快速排序等

这道题由原来的快速排序变成了排序，所以我就来讲一下桶排序和堆排序还有用 `sort` 进行排序。

### 解法 1
桶排序的原理很简单，就是定义一个数组为桶，然后每个桶代表一个数字，每输入一个数就将这个数对应的桶加上 $1$（比如说 $3$，它所对应的桶下标就是 $3$），最后扫描桶，因为题目要求是从小到大排序，所以就直接正序扫描即可，只要桶里有值就输出。

这种排序的速度比较快，但是缺点是数值如果要想通过本题，需要定义一个 $10^9$ 大的桶，这样会 MLE。将数组开到最大 $10^8$，可以得 $60$ 分。

桶排序可以用来处理 $N$ 比较大，但是每个数的范围比较小的数据。

#### 参考代码（60 分）
```cpp
#include<iostream>
using namespace std;
int book[100000001];
int n,a;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a,book[a]++;
	for(int i=0;i<=1e8;i++) for(int j=1;j<=book[i];j++) cout<<i<<" ";
}
```

### 解法 2
堆排序可以用 STL 库数据结构来实现。这里我要介绍的是用优先队列实现。

优先队列是队列的一种，分为两种：大顶堆和小顶堆。

大顶堆的特性是每次最前面的那个数总是最大的，小顶堆就是每次最前面的数是最小的。

很显然，这道题应该用小顶堆解决，优先队列的定义方法是： `priority_queue<int,vector<int>, greater<int> > a;`，其中 `int` 是数据的类型，`a` 是队列的名称，要注意两个 `>` 之间要有空格，不然就会被认为是右移符号。

优先队列的使用方法和队列是一样的，常用的主要是 `a.push(xxx)`（放入队列某个数据）、`a.top()`（队列中最顶部的数据）、`a.pop()`（弹出最顶端的数据）。

这道题用堆排序是可以 AC 的。

具体实现看代码。
#### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,a;
	priority_queue<int,vector<int>, greater<int> > ss;//定义优先队列
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		ss.push(a);//将输入a的放入队列
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ss.top()<<" ";//输出队列中最上边的数据（也就是小顶堆中最小的）
		ss.pop();//将最上边的数据删掉（也可以说弹出）
	}
 } 
```

### 解法 3
上边的两种方法都比较复杂，而且时间空间复杂度高。

但是 C++ 中有黑科技 `sort` 函数，这是一个能够实现快速排序的函数，使用方法简单。

它的结构是 `sort(a+1,a+n+1,cmp)`，第一个数据中 $a$ 是数组的名称，后面的 $+1$ 是从下标 $1$ 开始排序，第二个数据是结束排序的范围，与第一个数据同理。第三个数据可以不用管，这是一个自定义函数，改变 `sort` 的逻辑时用得到。

注意：`sort` 函数默认就是从小到大排序的。

#### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[100001],n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
}
```



---

## 作者：yummy (赞：14)

**本文主要进行 STL 优化插入排序的讲解。如果想学习 $O(n\log n)$ 等其他排序方法，请前往其他题解。**

---

插入排序的基本流程如下：

假设我们有一个已经从小到大排好序的数组 $a$，我们现在要往 $a$ 里面插入一个 $x$，并且仍然保持数组有序，怎么办呢？

为了让数组保持有序，我们需要以下面的方式插入：

- 寻找最前面的位置 $i$，使得 $x\le a_i$。此时因为 $i$ 是最前面的位置，我们必然有 $a_{i-1}\le x$（若存在）。
- 将 $x$ 插入在 $a_i$ 前面。

第一个步骤我们可以使用 STL 中的 `lower_bound` 函数实现。`lower_bound(first,last,value)` 可以求出在 `first` 到 `last`（不包含 `last`）范围内第一个**不小于** `value` 的位置。注意这里 `first,last` 都是迭代器或指针类型，返回的也是迭代器或指针。

本题中我们不妨使用 `vector` 对排好序的数组 $a$ 进行存储。因为我们要查找整个 `vector`（从头到尾），所以要查找数字 $x$，可以使用 `lower_bound(a.begin(),a.end(),x)`。

在一个 `vector` 中，我们可以很方便地使用 `insert` 函数（或从 C++11 起可用 `emplace` 函数）进行插入，时间复杂度为插入位置到 `vector` 末尾的距离。`emplace(pos,x);` 可以在 `pos` 位置**之前**插入 `x`。

注意，虽然 `lower_bound` 函数使用二分查找，每次查找为 $O(\log n)$ 的时间复杂度，但是 `emplace` 或 `insert` 的时间复杂度最坏 $O(n)$，因此整个程序时间复杂度还是 $O(n^2)$。所幸 `emplace` 或 `insert` 常数非常小，仍然可以通过这道题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> a;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=0;i<n;i++){
		int x;
		cin>>x;
		auto it = lower_bound(a.begin(),a.end(),x);
		a.emplace(it,x);
	}
	for(int i=0;i<n;i++)
		cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：kkxacj (赞：13)

#### 基数排序

##### 思路

我们在比较两个数的大小时，是找到第一位不同的数的位置后比较大小。

考虑将每个数按个位，十位，百位...进行比较，确保在比较第 $i$ 位时所有数已经按前 $i-1$ 位排好序，也就是说我们要知道 $n$ 个数只看前 $i-1$ 位数排序后的位置。

若第 $a_j$ 的第 $i$ 位比 $a_z$ 的第 $i$ 位小，那么在只看前 $i$ 位数的情况下一定是 $a_j < a_z$，**注意此时的小于符号是我们定义的**。

若第 $a_j$ 的第 $i$ 位等于 $a_z$ 的第 $i$ 位，那么保持原来的位置关系就行了。

这里引用 OI wiki 的图供读者理解：


![by OI wiki](https://oi-wiki.org/basic/images/radix-sort-1.png)


##### 实现

记 $sum_j$ 表示第 $i$ 位上的值 $\le j$ 的数有几个，$o=10$，只考虑第 $1$ 位获取排名方式如下：
```cpp

	for(int i = 1;i <= n;i++) sum[a[i]%o]++;//值为a[i]%o的个数有几个 
	for(int i = 1;i <= 9;i++) sum[i] += sum[i-1];//前缀 
	for(int i = n;i >= 1;i--) id[sum[a[i]%o]--] = i,a[i]/=o;//计算排名
```

假设一个数第一位为 $i$，那么他的排名至少是小于 $i$ 的个数，相同的话就累加一下，那么 $sum_i$ 的初值就是值为 $i$ 的排名最靠后的位置，由于这里是算的第一位的，我们直接默认顺序为输入顺序，于是直接从后往前依次给排名，给完后 $sum_{a[i] \mod o}-1$ 是因为最后一个排名算完了，前一个的位置就是当前的位置 $-1$。

若不是第一位，只需要改一部分即可，实现是差不多的。


```cpp

 	  for(int i = 0;i <= 9;i++) sum[i] = 0;
		for(int i = 1;i <= n;i++) id1[i] = id[i];//新的位置
		for(int i = 1;i <= n;i++) sum[a[i]%o]++;
		for(int i = 1;i <= 9;i++) sum[i] += sum[i-1];
		for(int i = n;i >= 1;i--) id[sum[a[id1[i]]%o]--] = id1[i],a[id1[i]]/=o;
```

可以发现唯一的区别就是 $i$ 变为了 $id1_i$，这是因为数的顺序改变了，我们初始是默认第 $i$ 个数的排名是 $i$。

可以发现时间复杂度是 $O\left ( n \log_{10}{V}  \right ) $ ，空间复杂度 $O\left ( n  \right ) $。

然后就没有了。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
const int N = 2e5+10;
int n,a[N],b[N],sum[20],id[N],id1[N],o=10,cnt=1;
signed main()
{
	read(n);
	for(int i = 1;i <= n;i++) read(a[i]),b[i]=a[i];
	for(int i = 1;i <= n;i++) sum[a[i]%o]++;//值为a[i]%o的个数有几个 
	for(int i = 1;i <= 9;i++) sum[i] += sum[i-1];//前缀 
	for(int i = n;i >= 1;i--) id[sum[a[i]%o]--] = i,a[i]/=o;
	while(cnt < 9) //最多执行最大数的位数次，也就是9次，前面已经执行了一次 
	{
		for(int i = 0;i <= 9;i++) sum[i] = 0;
		for(int i = 1;i <= n;i++) id1[i] = id[i];
		for(int i = 1;i <= n;i++) sum[a[i]%o]++;
		for(int i = 1;i <= 9;i++) sum[i] += sum[i-1];
		for(int i = n;i >= 1;i--) id[sum[a[id1[i]]%o]--] = id1[i],a[id1[i]]/=o;
		cnt++;
	}
	for(int i = 1;i <= n;i++) print(b[id[i]]),pc(' ');
	flush();
	return 0;
}
```

---

## 作者：huangruiheng0217 (赞：8)

#### 题意

将一个数组从小到大排序后输出。

#### 归并排序

归并排序用的是分治的思想。

什么是分治？就是把一个问题拆分成若干个小问题，逐个解决，然后再合并。

投射在数组排序上，就是先把一个数组拆成若干个小部分，然后给每个小部分依次排序后再合并。

说得具体一点：先将一个数组平均分成长度相同的两段，然后把每一段再平均分，分到只剩下一个数。

然后，考虑一下如何合并两个数？当然是小的在前大的在后。

现在你手上有两个长度为 $2$ 且各自分别有序的数组了，如何合并？

举个例子。

| 轮次 | 数组 1 | 数组 2 | 合并结果 |
| :----------: | :----------: | :----------: | :----------:|
| $0$ | $\text{[}$ $1$ $,$ $5$ $\text{]}$ | $\text{[}$ $2$ $,$ $3$ $\text{]}$ | 无 |
| $1$ | $\text{[}$ $\color{Red}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $2$ $,$ $3$ $\text{]}$ | $\text{[}1\text{]}$ |
| $2$ | $\text{[}$ $\color{Grey}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $\color{Red}{2}$ $,$ $3$ $\text{]}$ | $\text{[}1,2\text{]}$ |
| $3$ | $\text{[}$ $\color{Grey}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $\color{Grey}{2}$ $,$ $\color{Red}3$ $\text{]}$ | $\text{[}1,2,3\text{]}$ |
| $4$ | $\text{[}$ $\color{Grey}{1}$ $,$ $\color{Red}5$ $\text{]}$ | $\text{[}$ $\color{Grey}{2}$ $,$ $\color{Grey}3$ $\text{]}$ | $\text{[}1,2,3,5\text{]}$ |

长度更大的情况也是类似的，可以自己试着推一下。

~~大量实验表明~~合并时每次向结果数组里新添加的元素，一定是两个原数组首元素中较小的那一个。

>证明：假设当前最小的元素不是两个原数组的首元素中的任何一个。那么，无论它在哪一个数组里，都比该数组的首元素小，与“原数组各自有序”矛盾。

代码就非常好写了。(读入在 $a$ 数组)

```cpp
void merge(int l,int r)//处理区间[l,r]
{
    //以下是“分”的部分
    if(l==r)return;//只有一个数，不能再分了，直接返回
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid+1,r);//分成两个区间
    
    //以下是“治”的部分（执行到这一步的两个原数组都是有序的了）
    int i=l,j=mid+1;
    int cur=l-1;
    while(i<=mid&&j<=r)//每次取原数组的剩下元素中的首个进行比较
    {
        if(a[i]<=a[j])
            b[++cur]=a[i++];//结果统计在b数组
        else
        {
            b[++cur]=a[j++];
        }
    }
    while(i<=mid)//处理剩下的元素
        b[++cur]=a[i++];
    while(j<=r)
        b[++cur]=a[j++];
    for(int i=l;i<=r;i++)//把排序后的结果存回a数组
        a[i]=b[i];
}
```

顺便提一句，归并排序还可以处理逆序对问题。不是本题重点，可以移步[【模板】逆序对](https://www.luogu.com.cn/problem/P1908)。

---

## 作者：Crab_Tang (赞：7)

# **这里介绍希尔排序**

###### 前置芝士：[插入排序](https://oi-wiki.org/basic/insertion-sort/)~~没看见别怪我~~
---
希尔排序是插入排序的一种优化算法。以他的发明者~~贝壳~~希尔（Shell）命名。


## 希尔排序的过程：

>1. 把原序列划分为几个每个元素间距相等的子序列。（每组元素间的距离称作梯度）
>2. 对每个子序列进行插入排序（梯度为原序列长度时不做，因为每组只有一个元素，做了也没有意义）
>3. 缩小梯度，重复上述步骤直到梯度为1
## 希尔排序的思想：

插入排序在有序时最快。通过前面间距较小的插入排序，序列一步步变得有序。

### 经典选取梯度方式及其时间复杂度

梯度 $T=\{2^k-1|k=1,2,...,{\left \lfloor{ \log_2 n}\right \rfloor}\}$。在程序实现时一般先设最大值，再逐渐缩小。这种选取梯度的方法时间复杂度为 $O(n^{3/2})$。

具体证明请看[OI-WIKI](https://oi-wiki.org/basic/shell-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)。

**例：**

>1. 序列：$7,6,5,4,3,2,1,0$。
>2. 序列长度：$8$。
>3. 最初梯度：$8$。
>3. 梯度每次缩小方式：$tidu\gets \left \lfloor \frac{tidu}{2}\right \rfloor  $。
>4. 排序方式：升序

第一轮取梯度为 $8$，不做。

第二轮取梯度为 $4(\left \lfloor \frac{8}{2}\right \rfloor)$，进行插入排序：

$7,3$ 为一组，$6,2$ 为一组，$5,1$ 为一组，$4,0$ 为一组。（**此处数字指元素而不是指下标**）

插入排序后序列：$3,2,1,0,7,6,5,4$。

第三轮取梯度为 $2(\left \lfloor \frac{4}{2}\right \rfloor)$，进行插入排序：

$3,1,7,5$ 为一组，$2,0,6,4$ 为一组。

插入排序后序列：$1,0,3,2,5,4,7,6$。

第三轮取梯度为 $1(\left \lfloor \frac{2}{2}\right \rfloor)$，进行插入排序：

$1,0,3,2,5,4,7,6$ 为一组。

插入后序列：$0,1,2,3,4,5,6,7$。

排序完毕。



## 空间复杂度：

空间复杂度为 $O(1)$。

## 代码

### 主函数部分
~~太简单了不给了。~~

### 子排序部分

这部分的代码其实跟插入排序差不多。

只不过下标为 $i$ 的下一个元素是 $i+梯度$ 罢了。 

~~自己改改插入排序就好了不给了代码~~

### 缩小梯度部分

```cpp
void shellsort(){//左闭右开
	int _tidu=(1<<int(log2(n)));//最开始的梯度是比n小最大的2的k次方
	while(_tidu>=1){//此处注意，梯度为1时也要做一遍子排序
        sub_shellsort(_tidu);//执行子插入排序
		_tidu=_tidu/2;//梯度每次缩小为二分之一是一种比较经典的选梯度方式
	}
	return ;
}
```

[参考代码](https://www.luogu.com.cn/paste/xuele4tr)

---

## 作者：tZEROちゃん (赞：5)

update：归并排序的时间复杂度写成 $O(\log n)$ 了，已修改。

首先我们介绍一种复杂度较劣的做法，即冒泡排序。

冒泡排序的流程是这样的，首先，依次比较相邻的两个元素，记作 $a_i, a_{i+1}$，若 $a_i>a_{i+1}$，那么就交换两个元素，这样从 $1$ 到 $n-1$ 遍历一遍之后，最后一个数就是数组的最大值。第二次循环，我们就能找到次大值，以此类推，在 $n-1$ 次循环后就完成了排序。

比如，对数组 $[3, 1, 4, 5, 2]$，变化过程如下：
- $3>1$，交换 $3, 1$，变成 $[1, 3, 4, 5, 2]$。
- $3<4$，不交换。
- $4<5$，不交换。
- $5>2$，交换 $5, 2$，变成 $[1, 3, 4, 2, 5]$，此时最大数 $5$ 来到最后。
- $1<3$，不交换。
- $3<4$，不交换。
- $4>2$，交换 $4, 2$，变成 $[1, 3, 2, 4, 5]$，此时次大数来 $4$ 来到了倒数第二个。
- $1<3$，不交换。
- $3>2$，交换 $2, 3$，变成 $[1, 2, 3, 4, 5]$，此时倒数第三大数 $3$ 来到倒数第三个。
- $1<2$，不交换，算法结束。

这个算法在对有序数组排序时，若数组为有序数组，时间复杂度显然是 $O(n)$，但在最坏的情况下，时间复杂度会达到 $O(n^2)$，无法通过本题。

**C++ 代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int a[N];

int main() {
  int n;
  cin >> n;
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
  }
  for (int i = 0; i < n - 1; ++i) {
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j + 1]) swap(a[j], a[j + 1]);
    }
  }
  for (int i = 0; i < n; ++i) {
    cout << a[i] << ' ';
  }
}
```

在此基础上，在每轮循环时判断数组是否有序，若有序就可以结束排序，可以在某些数据中跑的更快。

考虑归并排序。

所谓归并排序，它用一种分治的思想，将一个大的数组先拆分成几个小的数组，然后把它们合并起来。我们以数组 $[11, 45, 14, 19, 81, 1]$ 为例，来讲解归并排序的过程。

### 拆分

首先，我们用递归把这个数组拆成两个数组，具体来说，我们设 $l, r$ 为两个端点下标，取 $mid = \lfloor\dfrac{l + r}{2} \rfloor$，然后分为从 $1$ 到 $mid$，从 $mid + 1$ 到 $r$ 两个数组，对这两个数组再次进行拆分，直到不再有 $l < r$。

对例子来说，是这样的：

- $[11, 45, 14, 19, 81, 1]$
- $[11, 45, 14],[19, 81, 1]$
- $[11, 45],[14],[19, 81],[1]$
- $[11],[45],[14],[19],[81],[1]$

拆分完成。

### 合并

用 $i, j$ 两个指针，分别表示要合并的两个小数组的下一个要取的数，因为小数组一定是排好序的，合并的时候只需要把两个小数组的未被取的最小的元素拿出来比大小，然后把比较小的那个放到正确的位置。如果其中有一个数组取完了，直接把另外一个数组没放完的扔到结果数组里。

可以发现如果直接扔回原数组，那你原来的操作序列就会被打乱，所以用一个临时数组存一下。

还是以上文的例子，我们省略前两步，直接来说明 $[11, 14, 45]$ 和 $[1, 19, 81]$ 的合并过程（数组下标从 $0$ 开始）：

- $i = 0, j = 3$，$11>1$，数组：$[1]$，$j$ 加 $1$。
- $i = 0, j = 4$，$11<19$，数组：$[1, 11]$，$i$ 加 $1$。
- $i = 1, j = 4$，$14<19$，数组：$[1, 11, 14]$，$i$ 加 $1$。
- $i = 2, j = 4$，$45>19$，数组：$[1, 11, 14, 19]$，$j$ 加 $1$。
- $i = 2, j = 5$，$45<81$，数组：$[1, 11, 14, 19, 45]$，$i$ 加 $1$。
- 此时 $i = mid = 3$，说明前面数组放完了，直接把 $81$ 扔进结果数组，变成 $[1, 11, 14, 19, 45, 81]$，算法结束。

时间复杂度为 $O(n \log n)$，空间复杂度为 $O(n)$。可以通过本题。

**C++ 代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int a[N], c[N];
int n;

void MergeSort(int l, int r) {
  if (l >= r) return ;
  int m = (l + r) / 2;
  MergeSort(l, m);
  MergeSort(m + 1, r);
  for (int k = l; k <= r; ++k) {
    c[k - l] = a[k];
  }
  int i = 0, j = m - l + 1;
  for (int k = l; k <= r; ++k) {
    if (i == m - l + 1) a[k] = c[j], ++j;
    else if (j == r - l + 1) a[k] = c[i], ++i;
    else if (c[i] < c[j]) a[k] = c[i], ++i;
    else a[k] = c[j], ++j;
  }
}

int main() {
  cin >> n;
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
  }
  MergeSort(0, n - 1);
  for (int i = 0; i < n; ++i) {
    cout << a[i] << ' ';
  }
}
```


此外，C++ 的 STL 中提供了方便的 `stable_sort` 归并排序，格式如下：

```cpp
void stable_sort ( RandomAccessIterator first, RandomAccessIterator last, Compare comp );
```

它可以按照指定的排序规则（comp），对 $[first, last)$ 区域内的元素进行排序。comp 可以省略，默认升序排序。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
  int n;
  cin >> n;
  vector<int> a(n);
  for (int i = 0; i < n; ++i) cin >> a[i];
  stable_sort(a.begin(), a.end());
  for (auto i : a) cout << i << ' ';
}
```

---


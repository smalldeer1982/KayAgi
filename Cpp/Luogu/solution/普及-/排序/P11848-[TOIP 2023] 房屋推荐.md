# [TOIP 2023] 房屋推荐

## 题目描述

房屋中介小潮负责高谈市的租房业务。小潮手中有编号为 $1, 2, \cdots, n$ 的 $n$ 间待租房屋，房屋 $i$ 的位置用二维坐标 $(a_i, b_i)$ 表示，且该房屋的月租金为 $r_i$ 元。

高谈市有 $m$ 座地铁站，地铁站编号为 $1, 2, \cdots, m$，地铁站 $j$ 的位置用二维坐标 $(c_j, d_j)$ 表示。定义房屋 $i$ 与地铁站 $j$ 的距离为 $\sqrt{(a_i - c_j)^2 + (b_i - d_j)^2}$ 单位。

小潮发现租客的偏好如下：
1. 房屋与最近地铁站的距离越短越好。
2. 若两间房屋离各自最近地铁站的距离相同，则月租金较低的房屋更优。
3. 若两间房屋离各自最近地铁站的距离相同且月租金相同，则编号较小的房屋更优。

请帮助小潮开发一个房屋推荐系统，对房屋进行排序，使得越受租客偏好的房屋排名越靠前。

下图为一个 $n=3$ 且 $m=3$ 的示例：
- 方点 $H_1, H_2, H_3$ 分别代表房屋 $1, 2, 3$
- 圆点 $S_1, S_2, S_3$ 分别代表地铁站 $1, 2, 3$
- 房屋坐标与租金：
  - 房屋 1：$(2, 0)$，租金 $11000$ 元
  - 房屋 2：$(5, 0)$，租金 $12000$ 元  
  - 房屋 3：$(3, 3)$，租金 $10000$ 元
- 地铁站坐标：
  - 地铁站 1：$(1, 3)$
  - 地铁站 2：$(3, 0)$
  - 地铁站 3：$(5, 3)$

![](https://cdn.luogu.com.cn/upload/image_hosting/5j17sbyi.png)

计算得出：
- 房屋 $1$ 最近地铁站为 $2$ 号站（距离 $1$ 单位）
- 房屋 $2$ 最近地铁站为 $2$ 号站（距离 $2$ 单位）
- 房屋 $3$ 最近地铁站为 $1$ 号站和 $3$ 号站（距离 $2$ 单位）

第 $2$ 间房屋和第 $3$ 间房屋与地铁站的距离均为 $2$ 单位，但由于第 $3$ 间房屋的月租金更便宜，因此排在第 $2$ 间房屋前面。最终租客偏好的房屋顺序为：$1, 3, 2$。

## 说明/提示

### 测试数据限制

- $1 \le n \le 10^5$
- $1 \le m \le 10^3$
- $-10^9 \le a_i, b_i, c_i, d_i \le 10^9$
- $0 \le r_i \le 10^9$
- 所有坐标为整数且互不重叠
- 保证房屋与地铁站不在同一坐标

### 评分规则

| 子任务 | 分数 | 条件          |
| :----: | :--: | ------------- |
| 1      | 20   | $n \le 2$     |
| 2      | 30   | $n \le 100$   |
| 3      | 50   | 无额外限制    |

## 样例 #1

### 输入

```
3 3
2 0 11000
5 0 12000
3 3 10000
1 3
3 0
5 3```

### 输出

```
1
3
2```

## 样例 #2

### 输入

```
4 2
2 -2 10000
-2 1 12000
1 -3 12000
4 5 19000
1 5
4 1```

### 输出

```
4
1
2
3```

# 题解

## 作者：ryf2011 (赞：4)

# 题目思路
我们用一个结构体记录每个房屋的坐标、月租、离地铁站最短距离和编号。

全部输入完成后，对于每个房屋，我们都遍历一遍地铁坐标数组，取最小值。由于本题 $n \le 10^5,m \le 10^3$，所以 $\mathcal O(nm)$ 的时间复杂度不会超时。

接下来按照题目要求排序，最后输出编号即可。

注意一点，计算距离是涉及转换小数，本题要求开 $\texttt{long double}$ 存储。

# 代码
注：本代码仅供参考。具体见 [提交记录](https://www.luogu.com.cn/record/206211703)。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long
#define double long double //一定要开 long double！
using namespace std;
const int max_n=1e5+5;
const int max_m=1e3+5;
int n,m,c[max_m],d[max_m];
struct node{ //结构体
    int id; //编号
    int ha,hb; //坐标
    int r; //月租
    double sl; //距离（小数！）
} houses[max_n];
bool cmp(node a,node b){ //比较函数
    if(a.sl==b.sl){ //如果距离相同，比较月租
        if(a.r==b.r){ //月租相同，比较编号
            return a.id<b.id;
        }
        else{
            return a.r<b.r;
        }
    }
    else{
        return a.sl<b.sl;
    }
}
signed main(){
    //输入
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld %lld %lld",&houses[i].ha,&houses[i].hb,&houses[i].r);
        houses[i].id=i;
    }
    for(int i=1;i<=m;i++){
        scanf("%lld %lld",&c[i],&d[i]);
    }
    //计算、排序
    for(int i=1;i<=n;i++){
        houses[i].sl=sqrt((double)((houses[i].ha-c[1])*(houses[i].ha-c[1])+(houses[i].hb-d[1])*(houses[i].hb-d[1]))); //等同于把 houses[i].sl 初始化为无穷大
        for(int j=2;j<=m;j++){ //houses[i].sl 取最小值
            houses[i].sl=min(houses[i].sl,sqrt((double)((houses[i].ha-c[j])*(houses[i].ha-c[j])+(houses[i].hb-d[j])*(houses[i].hb-d[j])))); //记得转为小数！
        }
    }
    sort(houses+1,houses+n+1,cmp); //按照 cmp 排序
    for(int i=1;i<=n;i++){ //输出编号
        printf("%lld\n",houses[i].id);
    }
    return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：songge888 (赞：3)

### 题意

给定平面上的 $n$ 个房子和 $m$ 个地铁站，每个房子有坐标 $(x, y)$ 和租金 $r$，编号 $i$，每个地铁站有坐标 $(x, y)$。对于每个房子，计算它到最近地铁站的距离，并按照以下规则对房子排序：

1. 距离小的优先。
2. 距离相等的租金 $r$ 低的优先。
3. 租金 $r$ 相等的编号 $i$ 低的优先。

求排序后每个房子的编号。

### 思路

看见 $n \le 10^5$，$m \le 10^3$，对于每个房子 $i$，枚举每个地铁站 $j$，时间复杂度也完全可以接受。

注意 $r_i \le 10^9$，最小值的初值一定要设的足够大。

枚举复杂度：$O(nm)$。

排序复杂度：$O(n \log n)$。

总时间复杂度：$O(nm+n \log n)$。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
#define bug cout<<"___songge888___"<<'\n';
using namespace std;

int n,m;

struct lxl{
    int x,y;
}b[100005];
struct lyl{
    int x,y;
    int r;
    int id;
    int val;
}a[100005];
bool operator<(lyl x,lyl y){
    if(x.val!=y.val){
        return x.val<y.val;
    }
    else if(x.r!=y.r){
        return x.r<y.r;
    }
    else{
        return x.id<y.id;
    }
}

signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int x,y,r;
        cin>>x>>y>>r;
        a[i].x=x;
        a[i].y=y;
        a[i].r=r;
        a[i].id=i;
    }
    for(int j=1;j<=m;j++){
        int x,y;
        cin>>x>>y;
        b[j].x=x;
        b[j].y=y;
    }
    for(int i=1;i<=n;i++){
        int ret=LLONG_MAX;
        for(int j=1;j<=m;j++){
            int dx=a[i].x-b[j].x;
            int dy=a[i].y-b[j].y;
            int now=dx*dx+dy*dy;
            ret=min(ret,now);
        }
        a[i].val=ret;
    }
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        cout<<a[i].id<<'\n';
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11848)

简单题，先计算每个房子到所有站点的最小距离的平方，然后依次根据最小距离的平方、房子的半径和房子的编号对房子进行排序，最后输出排序后的房子编号。

有个 $\Theta(nm)$ 的循环和 $\Theta(n\log n)$ 的排序，总复杂度是可以接受的。

```cpp
#include <iostream>
#include <algorithm>
#define int long long
#define F first
#define S second
using namespace std;

const int N = 1e5 + 5;
const int Inf = 0x7f7f7f7f7f7f7f7f;

pair<int, int> st[N];

struct Node {
  int a, b, r, id, mn;
  bool operator < (const Node& x) const {
    if (mn != x.mn) return mn < x.mn;
    if (r != x.r) return r < x.r;
    return id < x.id;
  }
} p[N];

signed main() {
  ios::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> p[i].a >> p[i].b >> p[i].r;
    p[i].id = i;
    p[i].mn = Inf;
  }
  for (int i = 1; i <= m; i++)
    cin >> st[i].F >> st[i].S;
  for (int i = 1; i <= n; i++) {
    int md = Inf;
    for (int j = 1; j <= m; j++) {
      int dx = 1LL * p[i].a - st[j].F;
      int dy = 1LL * p[i].b - st[j].S;
      int dist = dx * dx + dy * dy;
      md = min(md, dist);
    } p[i].mn = md;
  } sort(p + 1, p + 1 + n);
  for (int i = 1; i <= n; i++)
    cout << p[i].id << "\n";
  return 0;
}
```

---

## 作者：末然Ender (赞：2)

# 题解：P11848 [TOIP 2023] 房屋推荐

## 思路

题意我就不简述了，看两遍能看懂。

作为一个 `普及-` 的题目，这个题一看就是暴力，通过结构体存储每一个房子的位置，然后每插入一个地铁站更新每个房子里最近地铁站的距离然后根据要求排序输出。复杂度 $O(n \cdot m + n \cdot \log n)$ 可以过。

然后一不注意你就会挂成 $0$ 分。

为了这事我调了很久，有两点：
- 开根号会丢失精度，我们不开根求距离的平方不影响比大小；
- 每一组 subtask 都造了至少一组极限数据，所以距离的初始值 $inf$ 不得小于 $8 \cdot 10^{18}$。这个大小开 `long long` 勉强可以存下。

然后就可以过了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
const ll N=1e5+4,inf=8000000000000000005ll;
struct house{
	ll x,y,r;
	ll d,id;
}a[N]; 
ll n,m;
inline ll func(ll x,ll y,ll a,ll b)/*求距离的平方*/{
	return (ll)((x-a)*(x-a)+(y-b)*(y-b));
}
inline bool cmp(house a,house b){
	if(a.d==b.d){
		if(a.r==b.r)return a.id<b.id;
		return a.r<b.r;
	}
	return a.d<b.d;
}
int main(){
	read(n,m);
	for(int i=1;i<=n;i++)read(a[i].x,a[i].y,a[i].r),a[i].d=inf,a[i].id=i;
	for(int i=1;i<=m;i++){
		ll x,y;
		read(x,y);
		for(int j=1;j<=n;j++){
			a[j].d=min(a[j].d,func(a[j].x,a[j].y,x,y));
		}
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		write(a[i].id);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：anyiming (赞：2)

# P11848 [TOIP 2023] 房屋推荐 题解

[题目传送门](https://www.luogu.com.cn/problem/P11848)

## 解题思路

对于每个房屋，计算其与所有地铁站的欧几里得距离的平方，找到最小值。然后按照以下规则排序：

1. 优先按距离平方从小到大排序。
2. 若距离平方相同，按租金从小到大排序。
3. 若租金也相同，按房屋编号从小到大排序。

## 代码实现


```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <unordered_set>
using namespace std;

long long nextNum(long long num, int d) {
    string s = to_string(num);
    while (s.size() < d) s = "0" + s; // 补零
    sort(s.begin(), s.end());
    long long min = stoll(s);
    reverse(s.begin(), s.end());
    return stoll(s) - min; // 最大数 - 最小数
}

int main() {
    int n, d; cin >> n >> d;
    while (n--) {
        long long x; cin >> x;
        unordered_set<long long> vis;
        while (!vis.count(x)) {
            vis.insert(x);
            x = nextNum(x, d);
        }
        cout << x << endl;
    }
    return 0;
}
```

---

## 作者：long_long_inf (赞：2)

# 思路

这是一道排序题，看上去不难，但实际上比较坑。

先定义结构体，然后按题意排序。

求家到地铁站的距离时千万**不要**直接开根，这题卡得很死，会有精度损失而导致不通过此题。所以，我们干脆不开根。如果一个大于零的数的平方比另一个大于零的数的平方大，那么它本身也肯定更大。

# 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct ho
{
    int a, b;
    int id;
    int r;
    long long dis;
} c[100005];
struct su
{
    int c, d;
} d[1005];
bool cmp(ho x, ho y)
{
    if (x.dis != y.dis) return x.dis < y.dis;
    if (x.r != y.r) return x.r < y.r;
    return x.id < y.id;
}
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> c[i].a >> c[i].b >> c[i].r;
        c[i].id = i;
    }
    for (int i = 1; i <= m; i++) cin >> d[i].c >> d[i].d;
    for (int i = 1; i <= n; i++)
    {
        long long minn = 8e18;
        for (int j = 1; j <= m; j++)
        {
            minn = min(minn, 1ll * (c[i].a - d[j].c) * (c[i].a - d[j].c) + 1ll * (c[i].b - d[j].d) * (c[i].b - d[j].d));
        }
        c[i].dis = minn;
    }
    sort(c + 1, c + n + 1, cmp);
    for (int i = 1; i <= n; i++) cout << c[i].id << endl;
    return 0;
}
```

# [AC](https://www.luogu.com.cn/record/206575178)

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11848)

# Problem

定义房屋有 $a,b,r$ 三个值，地铁站有 $c,d$ 两个值。

按如下规则排序：

1. $\sqrt{(a-c)^2+(b-d)^2}$ 越小越好；
2. 相同时，$r$ 越小越好；
3. 否则编号越小越好。

输出按排名顺序的房屋编号。

# Solution

定义 $a$ 是一个结构体数组，有变量 $a,b,r,id,sub$（$id$ 是编号，$sub$ 是最小的 $\sqrt{(a-c)^2+(b-d)^2}$）和 $s$ 是一个结构体数组，有变量 $c,d$。

输入 $n,m,a$，把所有 $a_{sub}=10^{10}+1,a_{id}=i$。

然后输入 $s$，输入 $s_c,s_d$，遍历 $a$，令每个 $a_{sub}=\min\{a_{sub},\sqrt{(a_a-s_c)^2+(a_b-s_d)^2}\}$。

然后排序按规则即可。

最后输出。

不过，众所周知，使用 `double` 和 $nm$ 次计算，会造成 $nm$ 次精度损失，大约有 $10^8$ 次。需要用 `long double`。

# Code

复杂度：$O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+1;
struct node1{
	long double a,b;
	long double sub;
	long long id,r;
}a[maxn];
struct node2{
	long double c,d;
}s[maxn];
int n,m;
bool cmp(node1 x,node1 y){
	if(x.sub==y.sub){
		if(x.r==y.r){
			return x.id<y.id;
		}else{
			return x.r<y.r;
		}
	}else{
		return x.sub<y.sub;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].a>>a[i].b>>a[i].r;
		a[i].id=i;
		a[i].sub=1e10+1;
	}
	for(int i=1;i<=m;i++){
		cin>>s[i].c>>s[i].d;
		for(int j=1;j<=n;j++){
			a[j].sub=min(a[j].sub,sqrt(abs(a[j].a-s[i].c)*abs(a[j].a-s[i].c)+abs(a[j].b-s[i].d)*abs(a[j].b-s[i].d)));
		}
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		cout<<a[i].id<<endl;
	}
	return 0;
}
/*
4 2
2 -2 10000
-2 1 12000
1 -3 12000
4 5 19000
1 5
4 1
*/
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11848)
# 解析
## 题意
给出一系列数据，分别是房屋的数据和地铁站的数据。房屋数据又分为坐标、价格以及房价，地铁站数据即地铁站坐标。

需要用以下的方式对房屋进行排序：

- 房屋与最近地铁站的距离短的排前面。
- 若两间房屋离各自最近地铁站的距离相同，则月租金较低的排前面。
- 若两间房屋离各自最近地铁站的距离相同且月租金相同，则编号较小的排前面。

计算房屋与地铁站的距离公式为 $\sqrt{(a_i-c_j)^2+(b_i-d_j)^2}$，其中 $a$ 和 $b$ 表示房屋横坐标和纵坐标，$c$ 和 $d$ 表示地铁站的横坐标和纵坐标。
## 考察知识
本题考查结构体和排序。
## 思路
用结构体分别存储房屋编号、坐标、离地铁站的距离和租金以及地铁站的坐标，输入，然后算出房屋距离最近地铁站的距离并存储，再依据上面题目大意中的排序方式编写排序的函数进行排序，最后按顺序输出即可。
> 温馨提示：本题数据很坑，数组开大亿点，依次枚举算房屋距离最近地铁站的距离时的初始最小距离也开大亿点。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+86; 
int n,m;
struct housenode
{
    long double distance;//定义离地铁站的距离 
    long long x,y,r,no;//定义坐标，租金和编号 
}house[N];//定义结构体：房子信息 

struct metronode
{
    long long x,y;//定义地铁站的坐标 
}metro[N];//定义结构体 

bool cmp(housenode a,housenode b)//比较函数 
{
    if(a.distance<b.distance)//房屋与最近地铁站的距离越短越好
	{
		return 1;
	}
    if(a.distance==b.distance&&a.r<b.r)//若两间房屋离各自最近地铁站的距离相同，则月租金较低的房屋更优
	{
		return 1;
	}
    if(a.distance==b.distance&&a.r==b.r&&a.no<b.no)//若两间房屋离各自最近地铁站的距离相同且月租金相同，则编号较小的房屋更优
    {
    	return 1;
	}
	return 0;//否则调换位置 
}

int main()
{
    cin>>n>>m;//输入 
    for(int i=1;i<=n;i++)
	{
        cin>>house[i].x>>house[i].y>>house[i].r;//输入 
        house[i].no=i;//存编号 
    }
    for(int i=1;i<=m;i++)
	{
        cin>>metro[i].x>>metro[i].y;//输入 
    }
    for(int i=1;i<=n;i++)//枚举每套房 
	{
        long double lsmin=1e20;//定义很大的数，让最小值达不到即可(开大亿点！) 
        for(int j=1;j<=m;j++)//枚举每个地铁站 
		{
            long double lsdistance=sqrt((long double)((house[i].x-metro[j].x)*(house[i].x-metro[j].x)+(house[i].y-metro[j].y)*(house[i].y-metro[j].y)));//按题意算这套房离这个地铁站的最小值,记得开更高精度的数据类型 
            lsmin=min(lsdistance,lsmin);//更新距离地铁站的最小值 
        }
        house[i].distance=lsmin;//存储 
    }
    sort(house+1,house+n+1,cmp);//比较 
    for(int i=1;i<=n;i++)
	{
        cout<<house[i].no<<endl;//一个一个输出 
    }
}
```

---

## 作者：Starry_Sky_135 (赞：1)

# 思路

结构体排序，但是略微复杂。

**如何求房屋离最近地铁站距离：**  
对于 $n$ 个房屋，每个房屋枚举一遍 $m$ 个地铁站，根据公式求出最小的距离即可。注意距离不用开方，会因为精度问题过不去。

**如何进行排序：**

* 比较房屋离最近地铁站距离，距离小的靠前。

* 如果距离相等，比较租金，租金小的靠前。

* 如果距离和租金都相等，比较编号，编号小的靠前。

**不开 long long 见祖宗。**


# [AC](https://www.luogu.com.cn/record/207058457) 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+8;
int n,m;
struct house
{
    int a,b,r,dis;
    int id;
}h[N];
int c[N],d[N];
bool cmp(house x,house y)
{
    if(x.dis!=y.dis) return x.dis<y.dis;
    if(x.r!=y.r) return x.r<y.r;
    return x.id<y.id;
}
signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>h[i].a>>h[i].b>>h[i].r;
        h[i].id=i;
        h[i].dis=1e19;//注意开大一点，1e18过不去
    }
    for(int i=1;i<=m;i++)
        cin>>c[i]>>d[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            h[i].dis=min(h[i].dis,(h[i].a-c[j])*(h[i].a-c[j])+(h[i].b-d[j])*(h[i].b-d[j]));//求最小距离
        }
    }
    sort(h+1,h+n+1,cmp);
    for(int i=1;i<=n;i++)
        cout<<h[i].id<<endl;
    return 0;
}
```

---

## 作者：yihang2011 (赞：1)

## [P11848 [TOIP 2023] 房屋推荐](https://www.luogu.com.cn/problem/P11848)

很好的结构体排序练习题，可惜坑有点多。

---

#### 坑点如下：

 - 计算房屋与地铁站的距离时，**不要**使用 `double`，可以考虑 `long double`，或者把计算距离函数改成 $(x_{1} - x_{2})^{2} + (y_{1} - y_{2})^{2}$，不开方，使用整形；

 - 如果计算距离时没有开方，那么请在距离计算过程中也改成 `long long`，因为 $(x_{1} - x_{2})^{2} + (y_{1} - y_{2})^{2}$ 的最大值为 $(10^{5} - 10^{3})^{2} + (10^{5} - 10^{3})^{2} = 1.9602 \times 10^{10}$，使用 `int` 溢出，所以要使用 `long long`；

 - 如果计算距离时没有开方，那么请将每一栋房子与地铁站的初始距离设为 $9 \times 10^{18}$，即 `9e18`，而不是 `1e9`；

 - 结构体排序时注意关键字顺序。

~~说句闲话，解决这道题的最好方法是：`#define int long long`，祝你们好运。~~

---

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

long long dist(long long x1, long long y1, long long x2, long long y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

struct house {
    int x, y;
    long long dis;
    int cost, id;
} h[100010];

struct subway_station {
    int x, y;
} s[1010];

int n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> h[i].x >> h[i].y >> h[i].cost;
        h[i].id = i;
    }
    for (int i = 1; i <= m; i++) {
        cin >> s[i].x >> s[i].y;
    }
    for (int i = 1; i <= n; i++) {
        long long d = 9e18;
        for (int j = 1; j <= m; j++) {
            d = min(d, dist(h[i].x, h[i].y, s[j].x, s[j].y));
        }
        h[i].dis = d;
    }
    sort(h + 1, h + n + 1, [](house x, house y) {
        if (x.dis != y.dis) {
            return x.dis < y.dis;
        }
        if (x.cost != y.cost) {
            return x.cost < y.cost;
        }
        return x.id < y.id;
    }) ;
    for (int i = 1; i <= n; i++) {
        cout << h[i].id << endl;
    }
    return 0;
}
```

---

为什么我要写这篇题解？~~因为上面这几个坑我都踩过。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/1b3dww5m.png)

---

## 作者：ziyaojia (赞：1)

## 题解：P11848 \[TOIP 2023] 房屋推荐

这道题主要考查的是我们的结构体的运用与排序，其实不太难，只要处理出各个房子与地铁站的距离的最小值，接着按题意排序就好了。

坑点：

1. 距离里的计算可以爆 int，所以要开 long long。
2. double 精度过低，需要开 long double。

## [AC](https://www.luogu.com.cn/record/206530191) 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node1{
    long double mindis;
    long long x,y,r,i;
    //分别建立坐标，租金和离地铁口最近的距离
}house[100001];
struct node2{
    long long x,y;//建立地铁站的坐标
}metro[1001];
bool cmp(node1 a,node1 b){//排序函数
    if(a.mindis!=b.mindis) return a.mindis<b.mindis;
    if(a.r!=b.r) return a.r<b.r;
    return a.i<b.i;
}
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>house[i].x>>house[i].y>>house[i].r;
        house[i].i=i;
    }
    for(int i=1;i<=m;i++){
        cin>>metro[i].x>>metro[i].y;
    }
    for(int i=1;i<=n;i++){
        long double minn=1e18;
        for(int j=1;j<=m;j++){
            long double dis=sqrt((long double)((house[i].x-metro[j].x)*(house[i].x-metro[j].x)+(house[i].y-metro[j].y)*(house[i].y-metro[j].y)));//计算距离
            minn=min(dis,minn);
        }
        house[i].mindis=minn;//记录离地铁站最近的距离
    }
    sort(house+1,house+n+1,cmp);
    for(int i=1;i<=n;i++){
        cout<<house[i].i<<endl;
    }
    return 0;
}
```

---

## 作者：longyitongxue (赞：1)

# 主要思路
这道题，主要思路很简单，首先，先读入，把距离算出来，然后按照到地铁站的距离、租金、编号排序就行。
# ※坑点※
只因我也在这里栽过坑……

1. 我们看题目，需要计算 $\sqrt{\left(a_i-c_j\right)^2+\left(b_i-d_j\right)^2}$，这里我们得用 C++ 里的 `sqrt` 函数对吧。可是你知道的， `double` 类型也是有误差的，我们必须用误差更小的 `long double` 来做题。
2. 就刚才的那个公式 $\sqrt{\left(a_i-c_j\right)^2+\left(b_i-d_j\right)^2}$，其中，$a_i$ 和 $b_i$ 的范围是 $10^5$，$c_i$ 和 $d_i$ 的范围是 $10^3$，我们要把根号算出来，必须先算出根式里面的。根式里面的值最大是 $2\left(10^5-10^3\right)^2$，也就是 $1.9602\times10^{10}$，这个范围 `int` 肯定炸吧，所以得开 `long long`。

# [AC](https://www.luogu.com.cn/record/206491608) 代码

```cpp
#include<iostream>
#include<stdio.h>
#include<math.h>
#include<algorithm>
using namespace std;
struct node{
	long long int a,b,r;
	int id;
	long double juli;
}h[100005];
struct sbw{
	long long int c,d;
}s[1005];
bool cmp(node x,node y){
	if(x.juli!=y.juli)return x.juli<y.juli;
	if(x.r!=y.r)return x.r<y.r;
	return x.id<y.id;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld",&h[i].a,&h[i].b,&h[i].r);
		h[i].id=i;
	}
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&s[i].c,&s[i].d);
	}
	for(int i=1;i<=n;i++){
		long double minn=1e18;
		for(int j=1;j<=m;j++){
			long double kkk=sqrt((long double)((h[i].a-s[j].c)*(h[i].a-s[j].c)+(h[i].b-s[j].d)*(h[i].b-s[j].d)));
			minn=min(minn,kkk);
		}
		h[i].juli=minn;
	}
	sort(h+1,h+n+1,cmp);
	for(int i=1;i<=n;i++){
		printf("%d\n",h[i].id);
	}
	return 0;
}
```

---

## 作者：little_stickman (赞：1)

# P11848题解
题目不难，但把我坑了。
# 主要题意
有 $n$ 间房屋以及 $m$ 个地铁站，给出每栋房屋的位置，租金，以及地铁站的位置，带入算式计算最优的单位后分别通过单位、租金、编号的先后顺序排序，然后按顺序输出即可。

# 解题思路
这题一眼就是暴力模拟，每次模拟每栋房屋离每座地铁站的单位，然后再求出最小值，按照单位、租金、编号的先后顺序排序，然后按顺序输出。

但是我们交了暴力代码后爆零了……

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int c[100010], d[100010];
int n, m;
struct node
{
	int a, b, r, num;
	double minn;
}x[100010];
bool cmp(node l1, node l2)
{
	if(l1.minn != l2.minn)
		return l1.minn < l2.minn;
	else if(l1.minn == l2.minn)
		return l1.r < l2.r;
	else
		return l1.num < l2.num;
	return l1.minn < l2.minn;
}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i ++)
		cin >> x[i].a >> x[i].b >> x[i].r, x[i].num = i;
	for(int i = 1;i <= m;i ++)
		cin >> c[i] >> d[i];
	for(int i = 1;i <= n;i ++)
		x[i].minn = INT_MAX;
	for(int i = 1;i <= n;i ++)
		for(int j = 1;j <= m;j ++)
		{
			double tp = sqrt((x[i].a - c[j]) * (x[i].a - c[j]) + (x[i].b - d[j]) * (x[i].b - d[j]));
			x[i].minn = min(x[i].minn, tp);
		}
	
	sort(x + 1, x + 1 + n, cmp);
	for(int i = 1;i <= n;i ++)
		cout << x[i].num << endl;
	cout << endl;
    return 0;
}
```
我们看一下这个代码，思路都对了，但是结果不对。

在思考了一会后，我们发现：计算单位的算式中存在开方运算，但是开方运算会有**精度误差**！

于是，我们可以直接比较除去开方运算的算式，因为这样也可以得出**正确的排列顺序**！
# 上代码！ 
```cpp
#include <bits/stdc++.h>
using namespace std;
int c[100010], d[100010];
int n, m;
struct node
{
	long long a, b, r, num;
	long long minn;
}x[100010];
bool cmp(node l1, node l2)
{
	if(l1.minn != l2.minn)
		return l1.minn < l2.minn;
	else if(l1.minn == l2.minn)
		return l1.r < l2.r;
	else
		return l1.num < l2.num;
}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i ++)
		cin >> x[i].a >> x[i].b >> x[i].r, x[i].num = i;
	for(int i = 1;i <= m;i ++)
		cin >> c[i] >> d[i];
	for(int i = 1;i <= n;i ++)
		x[i].minn = LONG_LONG_MAX;
	for(int i = 1;i <= n;i ++)
		for(int j = 1;j <= m;j ++)
		{
			long long tp = (x[i].a - c[j]) * (x[i].a - c[j]) + (x[i].b - d[j]) * (x[i].b - d[j]);
			x[i].minn = min(x[i].minn, tp);
		}
	sort(x + 1, x + 1 + n, cmp);
	for(int i = 1;i <= n;i ++)
		cout << x[i].num << endl;
    return 0;
}

```

---

## 作者：Luogu_916767 (赞：0)

### 题目大意

有 $n$ 座房屋，$m$ 个地铁站，每座房屋和地铁站有一个位置，每座房屋有一个定价。顾客会优先选择离最近的地铁站最近的房屋，若相同则选择较便宜的，若还相同则选择编号较小的。

现在将数据给你，求将顾客选择房屋的优先值从大到小排列后，每座房屋的编号。

### 思路分析

对于每座房屋，枚举离它最近的地铁站并算出距离，记录最小值（这里有一个技巧，用勾股定理求距离时不用开方，因为对答案不影响，还可以防止精度丢失），然后再排序，输出就行。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int n,m;
struct node{
    int id;
    int x,y,m;
    int s;
}a[100005];
struct edge{
    int x,y;
}b[1005];

int work(int x1,int y1,int x2,int y2){
    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}

bool cmd(node a,node b){
    if(a.s != b.s){
        return a.s < b.s;
    }else if(a.m != b.m){
        return a.m < b.m;
    }else{
        return a.id < b.id;
    }
}

signed main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i ++ ){
        a[i].id = i;
        cin>>a[i].x>>a[i].y>>a[i].m;
    }
    for(int i = 1; i <= m; i ++ ){
        cin>>b[i].x>>b[i].y;
    }
    for(int i = 1; i <= n; i ++ ){
        a[i].s = work(a[i].x,a[i].y,b[1].x,b[1].y);
        for(int j = 2; j <= m; j ++ ){
            a[i].s = min(a[i].s,work(a[i].x,a[i].y,b[j].x,b[j].y));
        }
        // cout<<a[i].s<<"\n";
    }
    sort(a+1,a+n+1,cmd);
    for(int i = 1; i <= n; i ++ ){
        cout<<a[i].id<<"\n";
    }
}
```

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11848)

### 前置知识
两点坐标距离公式：$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

### 重点思路
题目大意十分简单，在此便不赘述。

我们考虑将每一间房屋都计算出离其最近的地铁站的距离，然后排序即可。时间复杂度 $\mathcal O(nm)$，可以通过本题。

注意事项：
+ 由于点的坐标比较大，平方的时候注意开 `long long`。
+ 计算距离的时候不需要开方，以防精度丢失。
### AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1,M=1e3+1,inf=LLONG_MAX;
int n,m,a[N],b[N],c[M],d[M],t;
struct house{
	int dis,r,id;//k[i].dis 表示第 i 间房屋与地铁站的最短距离 
}k[N];
bool cmp(house u,house v){//根据题目要求排序 
	if(u.dis!=v.dis) return u.dis<v.dis;
	if(u.r!=v.r) return u.r<v.r;
	return u.id<v.id;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		k[i].id=i;
		k[i].dis=inf;
	}
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i]>>k[i].r;
	for(int i=1;i<=m;i++) cin>>c[i]>>d[i];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) k[i].dis=min(k[i].dis,(a[i]-c[j])*(a[i]-c[j])+(b[i]-d[j])*(b[i]-d[j]));//计算房屋与地铁站的最短距离
	sort(k+1,k+n+1,cmp);
	for(int i=1;i<=n;i++) cout<<k[i].id<<endl;
}
```

---

## 作者：fish_love_cat (赞：0)

[小潮](https://space.bilibili.com/5970160)……？

---

发现这个范围 $O(nm)$ 似乎是可以草过去的，于是直接模拟，对于每一个地铁站都更新一遍距离。

最后排序就可以了。

为了避免精度问题可以不开根号，使用 `long long` 存储根号前的数字。

注意此时初始化需赋极大值 `0x7f7f7f7f7f7f7f7f`。

然后没了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct fish{
    int x,y,jl,id,mon;
}a[100005];
int flc(int i,int x,int y){
    return(a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y);
}
bool cmp(fish x,fish y){
    if(x.jl!=y.jl)
    return x.jl<y.jl;
    if(x.mon!=y.mon)
    return x.mon<y.mon;
    return x.id<y.id;
}
signed main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i].x>>a[i].y>>a[i].mon,a[i].id=i,a[i].jl=0x7f7f7f7f7f7f7f7f;
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        for(int j=1;j<=n;j++)
            a[j].jl=min(a[j].jl,flc(j,x,y));
    }
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)
        cout<<a[i].id<<endl;
    return 0;
}
```

---

## 作者：AnOIer (赞：0)

比较坑的一道题。

思路很简单，在 $O(nm)$ 的时间复杂度预处理出所有房子离其最近的地铁站，然后自定义排序函数：如果距离相等比价格，价格相等比编号。

坑点：

- 距离要找最小值，初始值要设的比较大，要大于 $8 \times 10^{18}$。

- 距离不能具体计算出来，否则会 WA 一些点。因为比较时仅与距离大小有关，所以题目中计算距离的根号可以舍去。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct house{
	int x,y,r,id;
}a[100010];
struct subway{
	int x,y;
}b[1010];
int dis[100010];
bool cmp(house a,house b) {
	if(dis[a.id]==dis[b.id]) {
		if(a.r==b.r) return a.id<b.id;
		return a.r<b.r;
	}
	return dis[a.id]<dis[b.id];
}
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		dis[i]=LLONG_MAX;
		cin>>a[i].x>>a[i].y>>a[i].r;	
		a[i].id=i;
	}
	for(int i=1;i<=m;i++) {
		cin>>b[i].x>>b[i].y;
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			dis[i]=min(dis[i],((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y)));
		}
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++) {
		cout<<a[i].id<<"\n";
	}
	return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：0)

**begin**

[P11848 [TOIP 2023] 房屋推荐](https://www.luogu.com.cn/problem/P11848)

# 思路

题意已经清楚的不能再清楚了，这里就不多赘述了。

很明显的一道结构体排序吧。

我们先 $O(nm)$ 暴力求出所有房子与最近地铁站的距离。

然后重载一下运算符对结构体排序（cmp 也行）。

最后按顺序输出编号即可。

### Tips

- 求距离的时候要用 `long double` 和 `sqrtl` 不然会爆 0（只能说 subtask 太可爱了），因为这个玩意我调了好久。。。

- 注意一下数据类型的问题。

# Code


```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc() getchar()
#define pc(a) putchar(a)
#define sqrt(a) __builtin_sqrtl(a) // 小小的硬件优化
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) a/__gcd(a,b)*b
#define y1 fuck_cmath
using namespace std;
const ll N=1e5+10,M=1e3+10;
struct node
{
    ll id,x,y,r;
    ldb dis=LLONG_MAX;
    bool operator<(const node &T)const // 重载运算符 下面这一大坨就是题目中的条件
    {
        if (dis==T.dis)
        {
            if (r==T.r)
                return id<T.id;
            return r<T.r;
        }
        return dis<T.dis;
    }
}h[N],s[M]; // house subway
ll n,m;
ldb d;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for (ll i=1;i<=n;i++) cin>>h[i].x>>h[i].y>>h[i].r,h[i].id=i;
    for (ll i=1;i<=m;i++) cin>>s[i].x>>s[i].y;
    // 无脑输入
    for (ll i=1;i<=n;i++)
    {
        for (ll j=1;j<=m;j++)
        {
            d=sqrt((h[i].x-s[j].x)*(h[i].x-s[j].x)+(h[i].y-s[j].y)*(h[i].y-s[j].y)); // 求距离
            h[i].dis=min(h[i].dis,d); // 若更优则更新
        }
    }
    sort(h+1,h+n+1); // 按题目要求排序
    for (ll i=1;i<=n;i++) cout<<h[i].id<<"\n"; // 输出id
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 思路
用结构体存储编号，坐标，月租和距离，再遍历一遍地铁坐标并且取最小值，接下来按照题目要求排序。  
一定要写 long double 并且转换成小数！！！  
### 代码  

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double //一定要开 long double！
using namespace std;
const int max_n=1e5+5;
const int max_m=1e3+5;
int n,m,c[max_m],d[max_m];
struct node{ //结构体
    int id; //编号
    int ha,hb; //坐标
    int r; //月租
    double sl; //距离（小数！）
} houses[max_n];
bool cmp(node a,node b){ //比较函数
    if(a.sl==b.sl) //如果距离相同，比较月租
        if(a.r==b.r) //月租相同，比较编号
            return a.id<b.id;
        else
            return a.r<b.r;
    else
        return a.sl<b.sl;
}
signed main(){
    //输入
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld %lld %lld",&houses[i].ha,&houses[i].hb,&houses[i].r);
        houses[i].id=i;
    }
    for(int i=1;i<=m;i++)
        scanf("%lld %lld",&c[i],&d[i]);
    //计算、排序
    for(int i=1;i<=n;i++){
        houses[i].sl=sqrt((double)((houses[i].ha-c[1])*(houses[i].ha-c[1])+(houses[i].hb-d[1])*(houses[i].hb-d[1]))); //等同于把 houses[i].sl 初始化为无穷大
        for(int j=2;j<=m;j++) //houses[i].sl 取最小值
            houses[i].sl=min(houses[i].sl,sqrt((double)((houses[i].ha-c[j])*(houses[i].ha-c[j])+(houses[i].hb-d[j])*(houses[i].hb-d[j])))); //记得转为小数！
    }
    sort(houses+1,houses+n+1,cmp); //按照 cmp 排序
    for(int i=1;i<=n;i++) //输出编号
        printf("%lld\n",houses[i].id);
    return 0;
}
```

---


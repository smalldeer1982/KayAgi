# [NHSPC 2023] G. 博物館

## 题目描述

在 H 国有一座博物馆，陈列了 $n$ 件作品在一条直线的走廊上。从门口开始，由左至右，放置于第 $i$ 个位置的作品价值为 $c_i$。

今日有重要的贵宾要莅临博物馆，但是因为行程紧凑，贵宾只能观赏最接近门口，也就是最左边的 $k$ 件作品。为了提升博物馆的形象，博物馆馆长打算把一些珍贵的作品移至前方。亦即把价值最高的前 $k$ 件作品移至最左边的 $k$ 个位置。

因为博物馆中的作品都非常珍贵，每一次搬动，都只能交换相邻的两件作品，并且为了最小化损坏作品的风险，馆长要求要用最少次数的搬动来完成。

给定当前每件作品的价值，请输出最少的搬动次数以完成馆长的要求。

## 说明/提示

### 测试数据限制

* $1 \le k \le n \le 10^5$。
* $1 \le c_i \le 10^9$。
* 输入的数皆为整数。

### 评分说明

本题共有三组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $3$ | $n \le 500$ 且 $c_1, c_2, \ldots, c_n$ 两两相异 |
| 2 | $19$ | $c_1, c_2, \ldots, c_n$ 两两相异 |
| 3 | $78$ | 无额外限制 |

## 样例 #1

### 输入

```
5 3
1 2 3 4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6 2
2 3 2 3 2 3```

### 输出

```
3```

# 题解

## 作者：Arthur2024 (赞：4)

# 题目意思
[题目传送门](https://www.luogu.com.cn/problem/P11908)

题目让我们在 $n$ 个作品中，把价值最昂贵的 $k$ 个作品移至最前面的几个位置，并且要求每次只能将相邻的两个作品交换，问最少要交换几次。
# 思路
假如我们先将价值最昂贵的 $k$ 个作品找出来，把它们一个个往前搬，但是这样不一定是最优的。

我们可以想到一个作品在往前搬时，有可能会把另一个也要往前搬的作品交换，此时另一个作品的位置会随着前面的哪个作品的交换往后退，这导致后面再搬这个作品时，会比原来多搬一次。

为了避免这种情况，我们会优先搬最靠前的要搬的作品，这样在搬的过程就不会影响后面的作品，并且第一个搬的作品最后会到第一个位置，第二个搬的作品最后会到第二个位置，以此类推。

注意不能找出最昂贵的 $k$ 个作品中最便宜的作品进行比较，因为如果出现相同价格的作品时，找出的作品数量可能超过了 $k$ 个。

我这里用一个数表示两个数，即将第一个数乘一个比第二个数可能的范围还要大的数再加上第二个数，这样做是为了后面排序做准备，这样就能做到第一个数小的在前，大的在后，相同的第二个数小的在前，大的在后，记得开 longlong。

我这里把 $c_i$ 作为第一个数，$n-i$ 作为第二个数，而不是 $i$，因为排序时我们希望把在相同价值的所有作品中，原本位置更靠前的作品在 $a$ 数组中更靠后，再从 $a$ 数组中提取最后的 $k$ 个元素，即优先提取价值最高的，价值相等的作品中，先提取原本位置最靠前的。

提取的时候注意要先取模，再用 $n$ 减取模后的数，因为之前存储时也是用 $n$ 去减 $i$，后面 $-k+n-i$ 是因为每个要搬的作品最后的位置不同，第一个要搬的作品最后在第一个的位置，第 $k$ 个要搬的作品最后在第 $k$ 个的位置。

最后记得开 longlong。
# [AC](https://www.luogu.com.cn/record/210671204)代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int c[100010];
signed main(){
	int n,k,ans=0;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		c[i]=c[i]*1000000+n-i;//用c数组存储的一个数存储两个数，方便排序
	}
	sort(c+1,c+n+1);//排序
	for(int i=n;i>n-k;i--){
		ans+=n-c[i]%1000000-k+n-i;//提取每个作品需搬的次数
	}
	cout<<ans;
	return 0;
}
```
**谢谢观看！**

---

## 作者：Circle_Table (赞：1)

**题目大意**

需要将 $n$ 个元素中前 $k$ 大的挪到前 $k$ 个位置，求最小的总代价。

**解题思路**

想到了用结构体来解此题，储存每一个元素的大小与编号。然后按照元素从大到小进行排序，得到一个新的顺序，此时前 $k$ 个就是需要放在前 $k$ 位的。  
在此之后，为防止无效挪动（比如向后挪动），可以再将前 $k$ 个元素再按编号从小到大排序，这样既可以保证前 $k$ 个元素是所有元素中前 $k$ 大的，也可以保证挪动次数最小。

由此，我们只需要对输入的 $c_i$ 进行两次排序即可。

**代码**


```cpp
#include <bits/stdc++.h>
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
int n,k,ans;
struct node{
	int id,v;//id存储编号,v存储价值
}c[114514];
bool cmp1(node a,node b){
	if(a.v==b.v)return a.id<b.id;//价值相等时，确保编号小的在前
	return a.v>=b.v;//保证排序后价值是从高到低
}
bool cmp2(node a,node b){
	return a.id<b.id;//保证排序后编号是从低到高
}
int main(){
	ios;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>c[i].v;
		c[i].id=i;
	}
	sort(c+1,c+1+n,cmp1);//按所有作品价值，从高到低排序
	sort(c+1,c+1+k,cmp2);//按前k个作品的编号，从低到高排序
	for(int i=1;i<=k;i++){
		ans+=c[i].id-i;//将第id个作品挪到第i个的代价
	}
	cout<<ans;
	return 0;
}
```
完结撒花~

---

## 作者：longyitongxue (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11908)
# 解题思路
这道题，想一想，其实很简单的。首先，暴力枚举肯定是炸的，因为范围在 $10^5$ 级别。我们可以建立一个结构体（你用二元组也可以），然后，记录作品价值和其位置。先对整体的价值进行从大到小的排序，如果价值一样，就对位置进行从小到大的排序。然后，`for` 循环，$i$ 从 $1\to k$，看看作品 $i$ 的位置 $a_{i}.id$ 距离位置 $i$ 有多远，用 $ans$ 把这个距离累加，最后 $ans$ 里的值就是答案。详见代码。
# [AC](https://www.luogu.com.cn/record/209298554) 代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
    int c,id;
}a[100005];
bool cmp(node x,node y){
    if(x.c!=y.c)return x.c>y.c;
    return x.id<y.id;
}
int main(){
    int n,k;
    long long ans=0;//保险起见，开个 𝚕𝚘𝚗𝚐 𝚕𝚘𝚗𝚐。 
    cin>>n>>k;//𝑛 个作品，𝑘 个要欣赏的最珍贵的作品数量
    for(int i=1;i<=n;i++){
        cin>>a[i].c;//读入其价值
        a[i].id=i;//记录器位置
    }
    sort(a+1,a+n+1,cmp);//按照思路排序
    for(int i=1;i<=k;i++){
        ans+=(long long)(a[i].id-i);//依思路累加距离
    }
    cout<<ans;//答案就在 𝑎𝑛𝑠 里
    return 0;
}
```

---

## 作者：DemonPlayer (赞：1)

## 思路：   
使用贪心。     
1. 将 $a$ 排序，取出前 $k$ 幅画，但需要记录原来的位置。
2. 计算并统计将价值第 $i$ 大的画的位置移动到 $i$ 的搬运次数。
3. 最后输出结果。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;

struct arr{
	int val;
	int idx;
};

arr a[maxn];
int n,k,cnt;

bool cmp(arr x,arr y){
	if(x.val!=y.val){
		return x.val>y.val;
	}
	return x.idx<y.idx;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].val);
		a[i].idx=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=k;i++){
		cnt+=a[i].idx-i;
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：__VN (赞：1)

# P11908 [NHSPC 2023] G. 博物館
[题目传送门 ](https://www.luogu.com.cn/problem/P11908)


---


## 思路
1. 从大到小排序每件作品的价值，价值一样则位置较近的在前面。
2. 累加价值最高的前 $k$ 件作品所需移动的次数。
## 注意
作品排列顺序不做要求，故第 $i$ 靠近门口的作品移动到第 $i$ 个位置即可。

---

## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;						//n,k含义同题目 
int sum=0;						//最小移动次数 
struct type{					
	int i,c;					//第i靠近门口的作品的价值c及原位置i 
}t[100001];
bool cmp(type x,type y){		//排序函数 
	if(x.c==y.c){				//如果价值相同,位置较近的在前面 
		return x.i<y.i;
	}else{
		return x.c>y.c;			//价值高的在前面 
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>t[i].c;
		t[i].i=i;				//第i件作品距离第i远 
	}
	sort(t+1,t+n+1,cmp); 
	for(int i=1;i<=k;i++){
		sum+=t[i].i-i; 			//累加 
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

## 题目描述：

放置于第 $i$ 个位置的作品价值为 $c_i$。

把价值最高的前 $k$ 件作品移至最左边的 $k$ 个位置。

每次移动仅能交换两个作品的位置。

输出最少的搬动次数。

## 思路：

设价值为前 $k$ 个的作品为好的，其余为坏的。

及原题变成给你一个 $01$ 串，要最少交换多少次使得左边有 $k$ 个为 $1$（因为有可能价值并列，所以这么说）。

注意到，每次只能交换最近的两个，所以可以直接从左到右，让好的点依次往左交换，直到碰见另一个好的点。

其实一样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/prfe4rtx.png)

## 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,x,jl,ans=999999999;
struct xx{ll k,c,z;};xx o[100011];
ll cmp1(xx a,xx b){return a.k==b.k?a.c<b.c:a.k>b.k;}
ll cmp2(xx a,xx b){return a.c<b.c;}
int main(){
	ios::sync_with_stdio(0);
    std::cin.tie();
	std::cout.tie();
	cin>>n>>m;
	for(ll i=1;i<=n;i++) cin>>o[i].k;
	for(ll i=1;i<=n;i++) o[i].c=i;
	std::sort(o+1,o+n+1,cmp1);std::sort(o+1,o+m+1,cmp2);
	for(ll i=1;i<=m;i++) jl=jl+o[i].c-i;
	cout<<jl;
    return 0;
}
```

---

## 作者：liaoxingrui (赞：1)

## Content

有 $n$ 件物品，每件物品都有一个价格 $a_i$，将价格前 $k$ 件的物品放在前 $k$ 个位置里。

## Solution

需要注意一下，放在前 $k$ 个位置里，不一定要按照价格摆放。

显然可以想到按照价格从高到低排序，因为是最小的操作次数，我们又将前面 $k$ 个按位置从小到大排序，再依次计算答案即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,k,ans;
struct node{
	int id,val;
}a[N];
bool cmp1(node x,node y){
	return x.val==y.val?x.id<y.id:x.val>y.val;
}
bool cmp2(node x,node y){
	return x.id<y.id;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].val;
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp1);
	sort(a+1,a+k+1,cmp2);
	for(int i=1;i<=k;i++)
		ans+=a[i].id-i;
	cout<<ans; 
	return 0;
}
```

---

## 作者：Francium_ (赞：1)

## 题目大意  
有 $n$ 个价值为 $c_i$ 的物品，现需要将价值前 $k$ 大的物品放到左起的 $k$ 个位置，每次只能交换相邻两个物品，求最小交换次数。  
## 思路
贪心。   
为什么呢？题目中说，要将前 $k$ 大的物品放到左起的 $k$ 个位置，不难想到按价值 $c_i$ 排序，但是，可能有多个一样价值的物品，并且必须舍弃一些，那么在题目要求下的“最小交换次数”，最优的解法肯定是以 $c_i$ 为第一关键字，$i$ 为第二关键字排序，最后排序后的前 $k$ 个加距离计算。但是！题目中并没有说左起的 $k$ 个位置必须按价值升序或降序，因此，上面所说的解法可能得到的并不是最优解，我们还需要在前 $k$ 个物品中按出现位置 $i$ 再排一次序，这样再来累加距离，得到的一定是最优解。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
pair<int, int> a[100005];//定义，second是出现位置i 

bool cmp(pair<int, int> x, pair<int, int> y) {//第一次排序，以ci为第一关键字，i为第二关键字排序
	if (x.first == y.first)
		return x.second < y.second;
	return x.first > y.first;
}

bool cmp1(pair<int, int> x, pair<int, int> y) {//第二次排序，按i排序
	return x.second < y.second;
}

signed main() {
	int n, k, ans = 0;
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		cin >> a[i].first, a[i].second = i;
	sort(a + 1, a + n + 1, cmp);//排两次
	sort(a + 1, a + k + 1, cmp1);
	for (int i = 1; i <= k; i++)
		ans += a[i].second - i;//计算总距离，即交换次数
	cout << ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/208654164)

---

## 作者：Luogu_916767 (赞：1)

[In Luogu](https://www.luogu.com.cn/problem/P11908)

### 题目大意

一共 $n$ 个数，将最大的 $k$ 个移到最前面，每次可以将相邻两位交换，问最少需要交换多少次。

### 思路分析

首先，我们将最大的 $k$ 个数的位置找出来，若有相等的就优先找位置靠前的。

然后，将这 $k$ 个数按照原来的顺序排到前 $k$ 位，容易证明，原序排列是最优解，否则会因为改变顺序而浪费交换次数。

记录数的原位置，不妨令最大的 $k$ 个数的原位置分别为 $w_1$ 到 $w_k$。则最小交换次数为 $w_i-1+w_2-2+\cdots +w_k-k$。化简一下，就是原位置之和减去 $1+2+\cdots+k$。

### Code

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,k;
struct node{
    int da,id;
}a[100001];

bool cmd(node a,node b){
    return (a.da!=b.da) ? (a.da > b.da) : (a.id < b.id);
}

int main(){
    cin>>n>>k;
    for(int i = 1; i <= n; i ++ ){
        cin>>a[i].da;
        a[i].id = i;
    }
    sort(a+1,a+n+1,cmd);
    int ans = 0;
    for(int i = 1; i <= k; i ++ ){
        ans += a[i].id;
        ans -= i;
    }
    cout<<ans;
}
```

---

## 作者：lvweisi (赞：0)

## 一道普普通通的排序题

这一道题比较有趣，我是用了两次排序就过了，只需要对于每一个 $c_i$ 进行排序，并存储前 $k$ 个最大价值的位置再次进行排序即可。
### 代码如下:
```
#include<bits/stdc++.h>
using namespace std;
struct C{
	int a;//存储每一个c的价值
	int wz;//存储每一个c的位置
}c[100005];
int n,k;
bool cmp(const C &t1,const C &t2){
	if(t1.a==t2.a)return t1.wz<t2.wz;
	return t1.a>t2.a;
}
int p[100005];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>c[i].a;
		c[i].wz=i;
	}
	sort(c+1,c+1+n,cmp);//对价钱排序
	for(int i=1;i<=k;i++){
		p[i]=c[i].wz;
	}
	sort(p+1,p+1+k);//对前k个价值的位置排序
	int ans=0;
	for(int i=1;i<=k;i++){
		ans+=p[i]-i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LG086 (赞：0)

给出 $n$ 个数，要将前 $k$ 大的数移至前 $k$ 个位置上，每次移动操作仅能交换两个相邻的数，问至少需要操作几次。

记原数列为 $a$，定义一个变量 $k_2$ 并赋值为 $k$。  
我们使用 `map<int,int>` 记录前 $k$ 大的数字，在这之后，从 $a_1$ 开始遍历数列 $a$。若此时的 $a_i$ 是被记录的数字，则说明 $a_i$ 是前 $k$ 大的数，将答案加上 $i-k+k_2-1$，同时 $k_2 \leftarrow k_2 - 1$。若 $k_2 = 0$，则说明已经完成了选择，直接跳出循环，输出答案即可。

代码略。

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11908)

## 思路：

考虑以排序为基础的贪心，因为首要目标是作品价值尽可能大，所以先按作品价值从大到小排序，次要任务是挪动次数尽可能小，所以作品价值相同时按位置从小到大排序，最后计算挪动距离和即可。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int bh;
	int s;
}m[100005];
bool cmp(node q,node p){
	if(q.s==p.s) return q.bh<p.bh;//价值相同按位置从小到大排 
	return q.s>p.s;//价值从大到小排 
}
int ls[100005]; 
int x,y;
int main(){
	cin>>x>>y;
	for(int i=1;i<=x;i++){
		cin>>m[i].s;
		m[i].bh=i;
	}
	sort(m+1,m+1+x,cmp);//排序 
	for(int i=1;i<=y;i++){
		ls[i]=m[i].bh;
	}
	sort(ls+1,ls+1+y);
	int da=0;
	for(int i=0;i<y;i++){
		da+=(ls[i+1]-1-i);//计算挪动次数 
	}
	cout<<da;
	return 0; 
}

```
[通过记录](https://www.luogu.com.cn/record/208936242)

---

## 作者：Doraeman (赞：0)

## 题意
我们要在 $n$ 件作品中按照一定的顺序选出 $k$ 件，将它们移动到前 $k$ 个位置。
## 提示
~~根据题目算法标签~~，这道题需要用排序完成。
## 排序
1. 如果两个作品 $c_i$，$c_j$ 都是“珍贵作品”，并且满足 $c_i>c_j$，那么 $c_i$ 一定要排序到 $c_j$ 之前。
2. 如果两个作品 $c_i$，$c_j$ 都是“珍贵作品”，满足 $c_i=c_j$，我们就可以考虑这两件作品，谁的交换次数更少。

对于第 $1$ 种情况，直接进行大小比较即可。  
对于第 $2$ 种情况，就以题目给出的第 $2$ 个样例为例。

即，$n=6,k=2$，作品价值依次为 $2,3,2,3,2,3$。  
此时，两件作品的价值都应该为 $3$，但是作品中有 $3$ 个价值为 $3$ 的作品。  
显然，选择 $c_2$ 和 $c_4$ 这两件作品进行交换才能使交换次数最少，即为交换 $3$ 次。

在刚才的分析过程中，可以得出这样的规律：如果两个作品 $c_i$，$c_j$ 都是“珍贵作品”，满足 $c_i=c_j$，那么位置更靠前的作品一定交换次数最少。  
再根据理论分析，所有符合条件的作品都可以被放在前面，那么距离前 $k$ 个作品这个区域更近的作品，交换次数一定更小。

提示：可以使用 $id$ 数组或者结构体中的变量来保存 $c_i$ 这个作品排序之前的位置（因为排序后其位置会发生改变）。
## 总结
1. 如果两个作品 $c_i$，$c_j$ 都是“珍贵作品”，并且满足 $c_i>c_j$，那么 $c_i$ 一定要排序到 $c_j$ 之前。
2. 如果两个作品 $c_i$，$c_j$ 都是“珍贵作品”，满足 $c_i=c_j$，那么 $i<j$ 时，$c_i$ 排在 $c_j$ 前面，$i>j$ 时，$c_i$ 排在 $c_j$ 后面。

直接按照这个排序方法对 $c$ 排序即可。
## 计算答案
对于排序后的第 $i$ 个位置上的作品，它要从原来的位置 $id_i$ 挪到第 $i$ 个位置，$id_i-i$ 就是需要交换的次数。  
例如：第 $5$ 个位置上的作品挪到第 $1$ 个位置需要交换 $5-1=4$ 次。

从排序后的第 $1$ 件作品到第 $k$ 件作品，每次直接在答案 $ans$ 上累加 $id_i-i$。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;

int n, k, ans;
struct Item{
	int c, id;
}a[N];
// 结构体记录作品价值和初始位置  

bool cmp(Item x, Item y){
	if(x.c == y.c)
		return x.id < y.id;
	return x.c > y.c;
}
	
int main(){
	// 1.读入 
	cin >> n >> k;
	for(int i=1; i<=n; i++){
		cin >> a[i].c;
		a[i].id = i;
	}
	
	// 2.排序 
	sort(a + 1, a + n + 1, cmp);
	
	// 3.计算答案 
	for(int i=1; i<=k; i++)
		ans += a[i].id - i;
		
	cout << ans;
	
	return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

显然可以把摆什么先处理出来扔进桶里。

然后我们从前往后去搜，显然越前面的往前挪次数越少。

然后我们就可以对于每个目标物体算出移到目标位置的代价，那么做完了。

时间复杂度 $O(n \log n)$，瓶颈在于排序。

代码还是贴一下吧。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],b[100005];
map<int,int>mapp;
bool cmp(int x,int y){
    return x>y;
}
int ans;
signed main(){
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i],b[i]=a[i];
    sort(b+1,b+1+n,cmp);
    for(int i=1;i<=k;i++)
        mapp[b[i]]++;
    for(int i=1,j=1;i<=n&&j<=k;i++)
        if(mapp[a[i]]){
            ans+=i-j;
            mapp[a[i]]--;
            j++;
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P11908)

简化一下题目，意思是将价值最高的前 $k$ 件作品移动到最左边的 $k$ 个位置，且每次只能交换相邻的两件作品，计算最少的交换次数。

# 思路

范围是 $10^5$，两层循环会炸。

所以我们可以先找出价值最高的前 $k$ 件作品（为了方便记录每个作品的价值和初始位置，我们用一个结构体 Item 来存储）。

然后将所有作品按照价值**从大到小**排序，如果价值相同，则按照初始位置从小到大排序（处理重复价值的情况）。排序后取前 $k$ 个作品，并记录它们的初始位置。

将记录的前 $k$ 个作品的初始位置存储在一个数组中，并对其进行排序。排序后的位置就是这些作品最终要移动到的目标位置顺序。

对于每个作品，计算它移动到目标位置所需的最少交换次数。可以通过计算该作品初始位置和目标位置之间的距离来得到。具体地说，对于第 $i$ 个要移动的作品，其目标位置是 $i$，初始位置是 $tar_i$，那么它需要移动的步数就是 $tar_i - i$。将所有作品的移动步数相加，就得到答案了。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5,mod=1e9+7,MOD=998244353;
struct Item{
    int value,idx;
};
bool cmp(Item a,Item b){// 先按价值从大到小排序，价值相同时按初始位置从小到大排序
    if(a.value!=b.value)return a.value>b.value;
    return a.idx<b.idx;
}
int n,k,ans=0;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);// 关流
    cin>>n>>k;
    vector<Item>e(n);
    for(int i=0;i<n;i++){// 读入
        cin>>e[i].value;
        e[i].idx=i;// 记录位置
    }
    sort(e.begin(),e.end(),cmp);
    // 取前 k个元素
    vector<int>tar;
    for(int i=0;i<k;i++)tar.push_back(e[i].idx);
    sort(tar.begin(),tar.end());// 对目标位置进行排序
    for(int i=0;i<k;i++)ans+=tar[i]-i;// 计算每个元素移动到目标位置所需的步数
    cout<<ans<<'\n';// 输出答案 
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/208619098)

时间复杂度应该是 $n\log n$，~~勿喷~~。

---

## 作者：iranai (赞：0)

# 思路
看完题目，可以简化题意：

给定 $n$ 个数，求出将前 $k$ 大的数移到前 $k$ 位的最小操作数。

我们利用 pair 数组存储每个数的大小与位置，将其按照大小从大到小排序（大小一样则把位置靠前的排在前边），定义一个 $ans$ 来存储最小操作数。实际上答案就是前 $k$ 个数位置之和再从 $1$ 减到 $k$ ，因为移动是将后面位置的数移到前面，假设全部移到 $0$ 位置处，则得来的结果再依次减去实际上要移到的位置，就是最后的结果了。减法的实际效果等于将 $1$ 到 $k$ 的数字全部减一遍，可以在加上前 $k$ 个数位置之和的时候顺便操作了。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
typedef long long LL;
int n,k;
PII a[100000+10];
bool cmp(PII x,PII y){
	if(x.first==y.first) return x.second<y.second;
	return x.first>y.first;
}
LL ans;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		a[i]=(PII){x,i};
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=k;i++){
		ans+=a[i].second;
		ans-=i;
	}
	printf("%lld",ans);
	return 0;
	
}

```

---


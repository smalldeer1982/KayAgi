# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# 题解

## 作者：无乐鸦 (赞：496)

#简单数学证明


###首先我们要排的是所有的元素，但是为什么是从小到大呢？？？


排队总是象征要排序，每个元素在此序列下都要满足条件，也就是从中拿出两个相邻元素同样满足条件：


于是设：


ai 和 bi且ai<bi


那么针对这两个元素：就有两种排列情况：




1.ai排在bi前面那么有总时间：t1=ai+ai+bi.

2.bi排在ai前面那么有总时间：t2=bi+bi+ai.

##于是由ai<bi得出 t1<t2—》变一下式子—》ai+ai+bi<bi+bi+ai;


再化简不等式得出ai<bi


于是得出结论：当ai在bi前面时，时间为最小值。


于是反推回总体，两两相较，那么越小的应该越排在前面，以至于总时间越小


本题真的水，AC代码太多了，提交记录中还有同意了代码公开计划的牛犇在，我觉得没必要贴出代码正如百科中的第一条：题解可以选择贴代码或者不贴。

故：麻烦您在审一次了，这是一次用数学分析的思维分享。我希望能够让大家知道，不是为了单纯炫耀。也许在以后大家的解题思路方向多了一点，能更好的拓展思维。


---

## 作者：f112358 (赞：263)

有一个巧妙的存数据方式来输出排序之后编号的顺序

（针对快排懒得用结构体的同学）

因为n<=1000

所以给每个ti都\*1001，在加上当前序号

可以保证排序的时候序号不干扰排序

又可以方便输出序号（只需mod1001输出序号，／1001 输出时间）

具体代码如下








```cpp
//
//  main.cpp
//  Water containing
//
//  Created by Leonardo Cullen on 2017/5/6.
//  Copyright © 2017年 Leonardo Cullen. All rights reserved.
//
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
double sum;
long int n;
long long int t[1001];
double ans;
int main(int argc, const char * argv[])
{
    cin>>n;
    int x;
    for(int i=1;i<=n;i++)
    {
        cin>>x;
        t[i]=x*1001+i;
    }
    sort(t+1,t+1+n);
    for(int j=1;j<=n;j++)
    {
        cout<<t[j]%1001<<" ";
        sum+=t[j]/1001*(n-j);
    }
    cout<<endl;
    ans=sum/n;
    printf("%0.2lf",ans);
    return 0;
}

```

---

## 作者：BlueArc (赞：110)

```cpp
#include"iostream"
#include"cstdio"
#include"algorithm"//为了用sort快排
using namespace std;
struct a  
{
 int b,num;//定义结构体a      
};
bool cmp(a x,a y)//定义“小于”运算符
{
 return x.b<y.b;    
}
int main()
{
 struct a a[1010];//定义结构体数组
 int n,i,j;
 double time=0;
 cin>>n;    
 for(i=1;i<=n;i++)   
  {
   cin>>a[i].b;
   a[i].num=i;//序号存起来              
  } 
 sort(a+1,a+n+1,cmp);//排序
  for(i=1;i<=n;i++)
  {
   cout<<a[i].num<<" "; //先把简单的做了，输入由小到大的编号
  }
  cout<<endl;//要换行
  for(j=n-1;j>=1;j--) //等待人数的计数器，由n-1开始
  {
   i=n-j;//这是个规律，当前最少时间的人序号和要等待的人数之和=n
   time+=a[i].b*j; //累加                  
  }
 printf("%.2lf",time/n);//算平均，保留两位小数
  return 0; 
}
```

---

## 作者：封禁用户 (赞：96)

非结构体……

思路：先排序，再用求和公式

AC代码如下（简单易懂，针对新手）

```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    //freopen("t1.in","r",stdin);
    //freopen("t1.out","w",stdout);
    //cout<<fixed<<setprecision()<<;
    int i,n,a[1005],b[1005],f;//定义数组，一个赋值，一个记录序号 
    double s=0;//结果要是浮点数形式 
    cin>>n;//输入 
    for(i=0;i<n;i++){ 
        cin>>a[i];//输入
        b[i]=i+1;//如果i为0，要加一 
    }
    for(i=0;i<n;i++){
        for(int j=n-1;j>0;j--){
            if(a[j]<a[j-1]){
                swap(a[j],a[j-1]);//冒泡大法！！！ 
                swap(b[j],b[j-1]);//注意，这里要同时变换 
            }
        }
    }
    for(i=0;i<n;i++){
        cout<<b[i]<<' ';//数出序号 
    }
    for(i=0;i<n;i++){//这里有个公式，s=a1*n+a2*(n-1)+a3*(n-2)+a4*(n-3)……一直到 an 
        a[i]*=(n-i-1);
        s+=a[i];
    }
    cout<<endl;//换行 
    s/=n;
    cout<<fixed<<setprecision(2)<<s;//保留两位输出 
    return 0;//庄严地结束程序 
}
```

---

## 作者：Anguei (赞：81)

大致翻看了一下题解，大多是用的 struct 结构体来存储等待时间和序号两个变量。

但是因为只有两个值需要并列存储，所以我们可以使用 **std::pair** 来实现（在头文件 algotithm 当中）。

我们可以通过下面的方法定义一个名为 a 的、具有两个 int 类型值的 pair :

```cpp
std::pair<int, int> a;
```
我们可以通过下面两行代码分别访问 pair a 的两个值：

```cpp
a.first = 1;        //第一个元素
a.second = 2;       //第二个元素
```
有关 std::pair 的详细情况（如定义等），可参考[std::pair - cppreference.com](http://en.cppreference.com/w/cpp/utility/pair)

另外，我使用了定义动态数组的办法（**使用 new 运算符**）来避免内存浪费（否则在 n <= 1000 的时候，需要 4 \* 2 \* 1000 = 8000 字节来保存每个人的时间和序号信息）。有关 new 运算符的详细信息，可参考[operator new, operator new[] - cppreference.com](http://en.cppreference.com/w/cpp/memory/new/operator\_new)

## 下面说做法。

题目要求说要平均等待时间最短，也就是总等待时间最短。所以令接水需求最小的人排在前面，最大的排在后面。也就是说，对于每一个 pair ，根据它们的时间进行升序排序，可以使用 STL 的 sort() 函数。**由于 std::pair 当中已经定义了 < 运算符，所以不需要自己手写比较函数就可以实现默认的升序排序（先按 first 成员排序）。**这比使用 struct 方便一些。

这道题有一个地方需要注意。当一共有 n 人排队接水时，第 i 个人接水，后面一共有 n - i 人等待。所以第 i 人的等待时间需要乘以 n - i 再计入总时间。不要每个人的时间只算一次。

下面附上代码。

```cpp
//【P1223】排队接水 - 洛谷 - 100
#include <cstdio>
#include <iostream> 
#include <algorithm>// for std::sort() ans std::pair 

int main()
{
    int n;
    double sum = 0.0f;// 总等待时间。必须是 double 类型，除非最后做除法的时候进行 int 到 double 的强制转换。 
    std::cin >> n;
    // 下一行定义了一个 pair 动态数组， 每个 pair 具有两个 int 类型成员。 
    std::pair<int, int>\* a = new std::pair<int, int>[n];// first 成员表示每个人的等待时间 ， second 成员表示序号。 
    for (int i = 0; i < n; ++i)
    {
        std::cin >> a[i].first;
        a[i].second = i + 1;
    }
    
    std::sort(a, a + n);// 依据 first 成员（接水时间）进行默认的升序排序 。
    for (int i = 0; i < n; ++i)
    {
        sum += a[i].first \* (n - i - 1);// 第 i 人的接水时间乘以 (n - 1) - i ，然后加到 sum 里面。 
                                        // 因为我是从 0 开始循环的，所以乘的时候要减一。 
        std::cout << a[i].second << ' ';
    }
    
    printf("\n%.2f", sum / n);// 按照指定格式输出。 
    
    delete[] a;// 最后别忘了释放内存，虽然这不必要，但这是个好习惯 。 
    return 0; 
}
'''

---

## 作者：冷、雨夜 (赞：41)

### 这题其实看样例也能看出来排队顺序就是从小->大排


### 序，但是也许有很多人找不出这题的公式，费尽一番心


### 思想出来了一个简单程序（~~蒟蒻专用~~），如果人数


### 为n个，每个人的排队时间就是a[i]×(n-i),所以总时


### 间sum就是每个人时间总和；排队顺序就用一个数组存


### 一下，后在时间进行排序的同时进行交换。



# 然后就AC了！！！



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	int n,t,k;
	double sum,s=0;   //sum总时间一定要用double型 
	int a[1001],b[1001];      //a数组为每个人的等待时间，b数组用来存每个人所在位置 
	cin>>n;
	for(int i=1;i<=n;i++)    //这个循环用来输入和存位置 
	{
		cin>>a[i];
		b[i]=i;
	}
	for(int i=1;i<=n;i++)    //这个循环用来排序时间和交换位置 
	{
		for(int j=i;j<=n;j++)
		{
			if(a[i]>a[j])
			{
				swap(a[i],a[j]);
				swap(b[i],b[j]);
			}
		}
	}
	for(int i=1;i<=n;i++)   //这个循环用来计算总时间 
	{
		s+=a[i]*(n-i);
	}
	sum=s/n;  //平均时间 
	for(int i=1;i<=n;i++)
	{
		cout<<b[i]<<" ";
	}
	cout<<endl;
	printf("%.2f\n",sum);  // 保留小数后两位输出 
	return 0;
}
```



---

## 作者：Peter_Z (赞：35)

楼下dalao的解法稍微复杂了点，不用waitingtime这个数组也能解决。

思路很清晰：由于若把时间长的放在后面接水，那么就较少人等，所以排序+贪心即可。

对于每一个人，在场剩余每个人都要经历一次他的打水时间。

故遍历整个数组求其他人在这个人打水时花费的总时间累加到ans上，

最后ans除以n。

蒟蒻的代码：

```cpp
#include<stdio.h>
#include<algorithm>
using std::sort;
struct water {
    int num,time;    //保存打水序号，打水时间 
```
/\*
注：由于打水时间均为整数，且除法运算中没有涉及到time这个

变量，所以time设为int类型即可，不需要用double或float。

\*/
```cpp
} p[1002];
double ans;
inline bool comp(water a,water b) {        //双关键字排序 
    if(a.time!=b.time)
        return a.time<b.time;
    return a.num<b.num;
}
int main() {
    int n;
    scanf("%d",&n);
    for(int i=1; i<=n; i++) {        //输入时间并重置序号 
        scanf("%d",&p[i].time);
        p[i].num=i;
    }
    sort(p+1,p+n+1,comp);
    for(int i=1; i<=n; i++)        //排完序的数组即为顺序，输出即可 
        printf("%d ",p[i].num);
    printf("\n");
    for(int i=1; i<=n; i++)
        ans+=i*p[n-i].time;        //核心公式 
    ans/=n;
    printf("%.2f",ans);
    return 0;
}
```

---

## 作者：SbasdianJulian (赞：23)

~~事实上，我看不出来这和贪心有什么关系~~

**要让平均排队时间最小，就要让打水快的人往前排**

**证：**

设有n个人打水，每个人的打水时间分别为 $x_1,x_2,x_2,...,x_n$

则打水时间总和为$x_1*(n-1)+x_2*(n-2)+...+x_{n-1}*1+x_n*0 $

要让打水总时间最小，就要让$x_1<x_2<...<x_n $

所以我们可得
#### 1.排序，对输入进行排序，使其变成$x_1<x_2<...<x_n $这个序列
#### 2.累加时间，如果用$x_1*(n-1)+...+x_{n-1}*1+x_n*0 $会比较麻烦，我们换一个方式,令$x_0=0$ 我们求$x_0+(x_0+x_1)+...+(x_0+x_2+...+x_{n-1})$
#### 3.把加完的时间除以n，再把$x_1,x_2,...,x_n $和时间输出

## AC!~~（假的）~~

**还要解决两位小数的保留问题！**

>提供两种方法 

>1.cout<<fixed<<setprecision(2)<<(头文件#include<iomanip>);  
>2.printf("%.2f",a)（这东西的头文件就不讲了）
 
**AC代码**
  ```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;
#define N 1010

int n,a[N]={0,},b[N];
double t1,t2;

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        b[i]=a[i];
    } 
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        t1+=a[i-1];
        t2+=t1;
        for(int j=1;j<=n;j++)
        {
            if(a[i]==b[j])
            {
                cout<<j<<" ";
                b[j]=0; 
            }
        }
    }
    t2/=n;
    cout<<endl<<fixed<<setprecision(2)<<t2;
    return 0;
}
```


---

## 作者：花千树 (赞：16)

一开始没看见可以用sort，用数组做的，后来才发现可以……

结果定义了一个结构体AC（本人爱好），第一遍平均值看错了，改了一下，第二遍AC。

本题其实不难，主要是结构体快排，其他没什么好说的。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct AC{//（本人爱好QAQ）
    int a;
    int b;
};
AC f[1005];
bool cmp(const AC&i,const AC&j){//重要cmp（其实本题挺好写）
    if(i.b<j.b)return 1;
    else return 0;
}
int main(){//主程序开始
    int n;
    cin>>n;//读入
    for(int i=1;i<=n;i++){
        cin>>f[i].b;//读入
        f[i].a=i;//存入序号
    }
    sort(f+1,f+1+n,cmp);//直接快排
    for(int i=1;i<=n;i++){
        printf("%d ",f[i].a);//输出序号
}
printf("\n");//换行
double ans;
for(int i=1;i<=n;i++){
   ans+=f[i].b*(n-i);//计算总值，套用多次实践所得的公式QAQ
}
printf("%.2f\n",ans/n);//直接输出平均值
return 0;
}
```

---

## 作者：渔歌唱晚 (赞：15)

????又是一道没有java题解的题目，~~赶紧水一发~~，

总等待时间：t1+(t1+t2)+(t1+t2+t3)+……+(t1+t2+t3+……+tn)

所以要把接水时间较少的放在前面

用java的构造类(可以看做是c的结构体)来储存接水时间和序号

菜????我就不用什么什么快排了，构造类也用不了sort难受，
老老实实写个冒泡好了

------------

```java
/*
 * P1223 排队接水
 * 	有n个人在一个水龙头前排队接水，假如每个人接水的时间为Ti，请编程找出这n个人排队的一种顺序，使得n个人的平均等待时间最小。
 *	 输出文件有两行，第一行为一种排队顺序，即1到n的一种排列；第二行为这种排列方案下的平均等待时间(输出结果精确到小数点后两位)。
 *	把接水时间长的放后面
 */
import java.util.Scanner;
class Main {
	public static void main(String[] args) {
		Scanner in=new Scanner(System.in);
		int n;
		people[] a;
		double sum;
		while(in.hasNext()){
			n=in.nextInt();
			a=new people[n];
			sum=0;
			for(int i=0;i<n;i++) {
				a[i]=new people();
				a[i].time=in.nextInt();
				a[i].No=i+1;				
			}
			sort(a);
			for(int i=0;i<n;i++) {
				sum=(n-i-1)*a[i].time+sum;
				if(i!=n-1)
					System.out.print(a[i].No+" ");
			}
			System.out.println(a[n-1].No);
			System.out.printf("%.2f",sum/n);
			System.out.println();
		}
		in.close();
	}

	private static void sort(people[] a) {
		int t;
		for(int i=0;i<a.length;i++) {
			for(int j=a.length-1;j>i;j--) {
				if(a[j].time<a[j-1].time) {
					t=a[j].time;
					a[j].time=a[j-1].time;
					a[j-1].time=t;
					t=a[j].No;
					a[j].No=a[j-1].No;
					a[j-1].No=t;
				}
			}
		}
		
	}

}

class people{
	int time;				//接水时间
	int No;					//序号
}

```

------------


---

## 作者：AmuroRay (赞：7)

c语言简单版（菜鸟版），希望能给你启示

```cpp
# include<stdio.h>
# include<stdlib.h>
int w[100000001],o[100000001];
void qsort(int l,int r)//定义快排
{
    int i,j,k,t;
    i=l;
    j=r;
    t=w[(l+r)/2];
    do{
        while(w[i]>t) i++;
        while(w[j]<t) j--;
        if(i<=j)
        {
            k=w[i]; w[i]=w[j];    w[j]=k; 
            k=o[i]; o[i]=o[j];    o[j]=k; 
        i++;j--;
        }
    }while(i<=j);
    if(l<j)qsort(l,j);
    if(i<r)qsort(i,r);
}
int main()
{
    int n,i,s=0;
    double j=0.0;//用Int的话只能拿80分
    scanf("%d",&n);
    for(i=1;i<=n;i++)//读入
    {
        scanf("%d",&w[i]);
        o[i]=i;
    }
    qsort(1,n);//调用快排
    for(i=n;i>=1;i--)
    {
        printf("%d ",o[i]);//顺序输出
        j=j+s;//s中是每个人的等待时间
        s=s+w[i];//这句一定要写在后面
    }
    printf("\n");
    printf("%.2f",j*1.0/n);//输出
}
```

---

## 作者：天命之路 (赞：6)

首先，这道题目的核心要素就是等待时间，答案也要求每个人的等待时间最小，故而，我们先把等待时间表示出来。

令数组a存放每个人的节水时间，我们从1到n，一步步看······

首先，第一个人节水，那么第二到n个人都要等a[1]秒，故总等待时间为a[1]* (n-1)。

同样，第二个人接水，在他后面的第3到n个人都要等a[2]秒，总时间加上a[2]* （n-2）。

······

由此，可得表达式为：a[1]* (n-1)+a[2]* (n-2)······a[n-1]* 1
（第n个人节水不产生等待时间）

既然如此，这道题目就是用贪心做的，把接水时间从小到大排序即可。

既然说到排序······还是用时间复杂度稳定，编码复杂度较低的**归并排序**
~~（冒泡排序）~~



--------------------------------一条知识的分割线------------------------------------------

贵宾排序的时间复杂度是O(n* logn)，且相对稳定，时间跟快排差不多，那它是怎么实现的呢？话不多说，先上函数：

```cpp
int n,a[10000001],m[10000001];  //m是个临时数组。
void msort(int l,int r)    //l是左边界,r是右边界
{
	if(l==r) return;
	int mid=(l+r)>>1;  //这里的“>>1”是除以2的意思
	msort(l,mid);msort(mid+1,r);   //这就是分了
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)    //比较
	{
		if(a[i]<=a[j]) m[k++]=a[i++];
		else m[k++]=a[j++];
	}
	while(i<=mid) m[k++]=a[i++];   //顺承
	while(j<=r) m[k++]=a[j++];
	for(int i=l;i<=r;i++) a[i]=m[i];   //拷贝
}
```
归并归并，先分再并。归并排序的思想就是，把待排序序列分成多个有序的序列，而后一一合并。

分靠什么？靠二分思想，将带分序列由中间分成两个序列，把这两个序列再递归地分，直至剩下一个数为止，即左边界等于右边界。

接下来，是并。用i遍历左边的待合并序列，j遍历右边的待合并序列，k为临时数组的指针，这一次合并的结果即存在m数组里。
开始合并，如果位置i的数更小，那它合并后的位置就应该比位置j的数更靠前，故这时就把位置i的数存在m数组里，反之亦然。

当然的，大部分情况下，只有1个变量遍历完了整个序列，而我们不得不结束过程，此时，因为剩下的数也要进来，所以后面的两个while循环负责将剩下的数顺承进来（不用担心大小，他们就是因为太大了才没有被放进来）。**显然，两个while循环只会执行一个**。最后还要将合并后的有序结果拷贝到原数组。


-------

讲完了排序，接下来上AC代码：


```cpp

#include<bits/stdc++.h>
using namespace std;
struct peo{
int times;
int No;}
a[1010],m[1010];
bool cmp(peo a,peo b)
{
    return a.times<b.times;
}
void msort(int l,int r)      //归并排序
{
	if(l==r) return;
	int mid=(l+r)>>1;
	msort(l,mid);msort(mid+1,r);   
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)   
	{
		if(cmp(a[i],a[j])) m[k++]=a[i++];
		else m[k++]=a[j++];
	}
	while(i<=mid) m[k++]=a[i++];   
	while(j<=r) m[k++]=a[j++];
	for(int i=l;i<=r;i++) a[i]=m[i];   
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].times;     //初始化
        a[i].No=i;}
    msort(1,n)；
    long long sum=0;double average; 
    for(int i=1;i<=n;i++)
    {
        sum+=a[i].times*(n-i);
    }
    average=sum*1.0/n;
    
    for(int i=1;i<=n;i++)
    {
        cout<<a[i].No<<' '；
    }
    cout<endl;
    printf("%.2lf",average);
    return 0;
    
    
}
```
嗯~最好不要抄，符号被我换成了中文。
建议大家理解完后自己写。因为这道题比较**水**（请允许我使用如此恶劣的词汇），所以我还拓展了一下其他的内容，如果掌握了归并排序，你就可以用贪心了（有些规律要在排序后才会有）！最后祝大家道道题AC！

---

## 作者：逍遥__天赐 (赞：6)

这道题是比其它oj上都简单一些的……

主要思路：在输入以后，首先把它们排序，但是需要自己写，因为我用了两个数组

然后用一个变量存放等待时间

注意：第i个人的等待时间为前i-1的人的接水时间总和

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000],b[1000];//a数组存放时间，b数组存放次序
int main()
{
    int n,sum=0;
    double ans=0;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i],b[i]=i+1;
    for(int i=0;i<n-1;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            if(a[i]>a[j])
            {
                swap(a[i],a[j]);
                swap(b[i],b[j]);
            }
        }
    }
    for(int i=0;i<n;i++) cout<<b[i]<<' ';
    for(int i=0;i<n-1;i++) sum+=a[i],ans+=sum;
    ans/=n;
    printf("\n%.2f\n",ans);
    return 0;
}
```

---

## 作者：越羽 (赞：5)

这道题比较简单吧，仔细想一下就能想出来，只要按从小到大的顺序排一下，确保前面的人所需要打水的时间比正在与他作比较的人小，就可以贪心贪出来了。

思路：
1. 结构体输入，从小到大排序，顺便确定好序号。
    
1. 输出序号。

1. 做一个加阶，算出总时间从而计算平均时间，输出平均时间（注意第一个人是不需要等待的，我居然还在这迟疑了几分钟，捂脸）。


总结一下这道题给我的感觉：
## 1. 结构体用的一时爽，一直用就一直爽。

## 2. sort用的一时爽，一直用就一直爽。
以下是代码：
```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,jia=0;
double sum=0;
struct student{
    int b;
    int t;
}a[200005]; 
int cmp(student x,student y){
    return x.t<y.t;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].t;//结构体输入打水所需时间
        a[i].b=i;//顺便做好序号
    }
    sort(a+1,a+n+1,cmp);//排序
    for(int i=1;i<=n;i++)
    cout<<a[i].b<<" ";
    cout<<endl;
    for(int i=2;i<=n;i++){
        jia+=a[i-1].t;
        sum+=jia;//计算平均时间
    }
    sum=sum/n;
    printf("%.2lf",sum);
    return 0;
}
```




---

## 作者：sshwy (赞：4)

#注意变量要存得下！

这种贪心很明显，

**用时少的先上，减少等待时间**

所以用结构体保存每个人的编号，时间，

然后sort排序即可。

**但是一定要注意，存放总时间的变量要足够大**

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct peo
{
    int bh=0,ti=0;
}t[1000];
bool cmp(peo a,peo b)
{
    if(a.ti!=b.ti)return a.ti<b.ti;
    return 0;
}
int main()
{
    int n,x=0;
    long long sum=0;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>t[i].ti;
        t[i].bh=i+1;
    }
    sort(t,t+n,cmp);
    for(int i=0;i<n;i++)cout<<t[i].bh<<' ';
    for(int i=0;i<n;i++)sum=sum+(n-i-1)*t[i].ti;
    printf("\n%.2f",(sum*1.0/n));
    return 0;
}
```
第一次发题解，多多关照


---

## 作者：童年如作业 (赞：3)

做这题呢，最重要的是基本思想并找到规律：前面的人接水所用的时间越少，那么总时间越少，平均时间也就越少(+﹏+)~狂晕。当然，要注意题目中的如果效果一样，按编号先后顺序输出，因此我用二维数组，不说了，马上进入程序o(≧v≦)o~~好棒！！！

```cpp
#include <iostream>//不解释，头文件；
#include <iomanip>//欲想保留小数，这句不能少；
#include <algorithm>//快排；
using namespace std;
struct r
{
    int time,NO;//1个记录时间，1个记录编号，好快排；
}a[100000];
bool cmp(r a,r b)
{
    if(a.time==b.time)
    return a.NO<b.NO;//如果时间一样，按编号排序；
    else
    return a.time<b.time;
}
int main()
{
    int n;
    double b=0;//双精度，单精度float不行;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].time;//输入时间；
        a[i].NO=i;//记录编号；
    }
    sort(a+1,a+1+n,cmp);//快排；
    for(int i=1;i<=n;i++)
    {
        cout<<a[i].NO<<" ";//输出编号；
        b+=a[i].time*(n-i);//累加总时间；
    }
    cout<<endl;//换行；
    cout<<fixed<<setprecision(2)<<b/n;//保留两位小数，输出平均时间。
    return 0;
}
float数据会爆，坑了我好久~~o(>_<)o ~~，不过总算过了。新手上路，多多关照哈   ↖(^ω^)↗↖(^ω^)↗↖(^ω^)↗！！！
再见~~~
```

---

## 作者：Right (赞：3)

发现居然没有C++的快排手写版题解，赶紧来补上：

其实快排很好写，虽然C++有sort函数，但是快排也是必备之物

>>快排代码
```cpp
void qsort(int l,int r)
{
    int i=l,j=r,m=a[(l+r)>>1],t;
    while(i<=j)
    {
        while (a[i]<m) ++i;
        while (a[j]>m) --j;
        if (i<=j)
        {
            t=a[i]; a[i]=a[j]; a[j]=t;
            t=b[i]; b[i]=b[j]; b[j]=t;
            ++i; --j;
        }
    }
    if (i<r) qsort(i,r);
    if (j>l) qsort(l,j);
}
```
再来看看此题，一题纯朴的贪心，只要打水时间少的人先即可
代码为排序+统计

>>上完整代码：
#include <stdio.h> 除了基本读入输出函数外，啥都不用

int n,a[1001],b[1001]; >>其中a为打水时间，b为每个人的编号

long long s=0; 一定要用int64 或者  long long ，不然会炸！

```cpp
void qsort(int l,int r) >>经典快排
{
    int i=l,j=r,m=a[(l+r)>>1],t; >>1即div 2
    while(i<=j)
    {
        while (a[i]<m) ++i;
        while (a[j]>m) --j;
        if (i<=j)
        {
            t=a[i]; a[i]=a[j]; a[j]=t; 、、交换 ==swap（）
            t=b[i]; b[i]=b[j]; b[j]=t;
            ++i; --j;
        }
    }
    if (i<r) qsort(i,r);
    if (j>l) qsort(l,j);
}
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=n; ++i) {scanf("%d",a+i);b[i]=i;} >>读入+初始化
    qsort(1,n);
    for (int i=1; i<=n; ++i){printf("%d ",b[i]); s+=a[i]*(n-i); } >>输出+统计
    printf("\n%.2f",s*1.0/n);
}
```

---

## 作者：CRyan (赞：3)

这个题是个很好的练习STL的题，除了sort这种基本的东西，优先队列在这个题也能使用，本代码作为一个模板提交。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int n,x,t;
long long sum;
double ans;

struct list{
    int n,x;
};//同时记录原队列顺序和值

struct cmp{
    bool operator() (list x,list y){
        return x.n>y.n;
    }    //重载比较运算符
};

priority_queue<list, vector<list>, cmp > a; //优先队列，三个参量，注意运算符重载要用结构体

int main(){
    cin>>n;
    t=n;
    list temp;
    for (int i=1;i<=n;i++){
        cin>>x;
        temp.x=i;
        temp.n=x;
        a.push(temp);//读入
    }
    while (!a.empty()){
        n--;
        sum+=a.top().n*n;//计算
        cout<<a.top().x<<" ";//输出顺序
        a.pop();
    }
    ans=double(sum)/t;
    cout<<endl;
    printf("%.2f",ans);//输出答案
    return 0;
}
```

---

## 作者：强力人 (赞：3)

#其实找到规律后就很简单了

首先读入，用结构体保存标号和时间；

接着排序，用sort和cmp根据时间由小到大排序；

然后循环，平均时间怎么算呢？

比如有三个人，时间分别为2,3,4,那么平均时间就是ans=（2\*（3-1）+3\*（3-2）+4\*（3-3））/3；**ans要用double类型**

接着输出两位小数；

最后AC。

AC代码如下


    
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node
{
    int n,t; 
} ;
struct node t[1010];
bool cmp(node x,node y)
{
    return x.t<y.t;
}
int main()
{
    int n,sum=0,i;
    double ans;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&t[i].t);
        t[i].n=i+1;
    }
    sort(t,t+n,cmp);
    int j=n-1;
    for(i=0;i<n;i++)
    {
        ans=ans+j*t[i].t;
        printf("%d ",t[i].n);
        j--;
    }
    printf("\n");
    printf("%.2f",ans/n);
    return 0;
}
```

---

## 作者：Steven111 (赞：2)

### 题目描述

有n个人在一个水龙头前排队接水，假如每个人接水的时间为Ti，请编程找出这n个人排队的一种顺序，使得n个人的平均等待时间最小。
## 题解
#### 一道非常经典的排序题
在这个程序中，我用了一个交换函数（实际上可以直接用swap，只不过为了装*）：
```
void AC(int& x, int& y)
{
	int temp = 0;
	temp = x;
	x = y;
	y = temp;
}
```
这样我的冒泡排序就会变得不一样一些：
```
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<n;j++)
		{
			if(t[j]>t[j+1])
			{
				AC(t[j],t[j+1]);
				AC(m[j],m[j+1]);
			}
		}
	}
```
直接放冒泡AC代码：
```
#include<bits/stdc++.h>
using namespace std;
void AC(int& x, int& y)//交换函数
{
	int temp = 0;
	temp = x;
	x = y;
	y = temp;
}
int main()
{
	int n;
	cin>>n;
	int t[n],m[n]={0};
	double sum=0.0;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i];m[i]=i;//输入节水时间和记录序号
	}
	for(int i=1;i<=n;i++)//冒泡开始
	{
		for(int j=1;j<n;j++)
		{
			if(t[j]>t[j+1])
			{
				AC(t[j],t[j+1]);//交换
				AC(m[j],m[j+1]);
			}
		}
	}
	for(int i=1;i<=n;i++)//输出并计算综合
	{
		cout<<m[i]<<' ';
		sum+=t[i]*(n-i);//最后一个人的接水时间无需加上
	}
	cout<<endl;
	printf("%.2lf",sum/n);//输出记得保留小数点两位哦：-）
	return 0;
}
```


---

## 作者：Sinwind (赞：2)

# 1.分析

1. 结构体：因为排队顺序与接水时间是一个整体，所以用结构体。

2. 贪心：贪心是一种策略，每一步都是局部最优解，综合起来就是或者接近整体最优解。

- 设共有$n$个人$w$为接水时间，$w[i]$表示第$i$个人的接水时间，$a$为等待时间，$a[i]$为第$i$个人的等待时间。$(i\in [0,n-1],i\in N_+)$

  - $a[0]=0$

  - $a[1]=a[0]+w[0]$

  - $a[2]=a[1]+w[1]$
  
  - $a[3]=a[2]+w[2]$

  - $\dots$

  - $a[i]=a[i-1]+w[i-1]$

- 为了使总等待时间最小，要令每一个位置的等待时间最小。

	- $a[0]$已经最小，为$0$。

	- $a[0]$已经最小，为了使得$a[1]$最小，要使得$w[0]$最小。
    
    - $a[1]$已经最小，为了使得$a[2]$最小，要使得$w[1]$最小。
    
    - $\dots$
    
    - $a[i-1]$已经最小，为使得$a[i]$最小，要使得$w[i-1]$最小。

- 即要使得每一个位置的接水时间最小，所以**按照接水时间从小到大排序**。

3. 平均等待时间$(avg)$计算：第$i$个人的等待时间等于前面所有人$(0\sim i-1)$的接水时间之和。将每个人的等待时间累加，计算出总和除以人数，得到平均值。

# 2.代码

```cpp
#include <iostream>
#include <algorithm>
#include <iomanip>

using namespace std;

//排队接水的人的结构体
typedef struct
{
	int id;             //排队顺序
	int t;              //接水时间
}Water;
Water people[1005];     //排队的人
int num;                //排队人数
double avg;          	//时间的平均数

//作为sort的第三个参数
bool compare(Water x, Water y)
{
	if(x.t != y.t)
	{
		return x.t < y.t;
	}
	else
	{
		return x.id < y.id;
	}
}

int main(void)
{
	cin >> num;
	for(int i = 0; i < num; i++)
	{
		people[i].id = i + 1;
		cin >> people[i].t;
	}
	
	sort(people, people + num, compare);
	
	for(int i = 0; i < num; i++)
	{
		cout << people[i].id << " ";
	}
	cout << endl;
	
	for(int i = 0; i < num; i++)
	{
		for(int j = 0; j < i; j++)
		{
			avg += people[j].t;
		}
	}
	
	avg /= num;
	
	cout << fixed << setprecision(2) << avg;

	return 0;
}
```


---

## 作者：Nibelungen (赞：2)

# 有几个重要的地方在代码注释中标出，还是可以学到些东西，也当给我自己做笔记

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,cq[100000],f[100000];
double t=0;             //t一定是double，如果是int会全部得0，而如果是float也会爆几个点
bool cmp(int i,int j){return cq[i]<cq[j];}       //一定要用<而不是<=，不然第一个会过不到，原理自己想
int main(){
    scanf("%d",&n);
    for(int a=1;a<=n;a++){
    scanf("%d",&cq[a]);
    f[a]=a;
    }
    sort(f+1,f+1+n,cmp);            //加入cmp函数实行间接排序（学自《算法竞赛入门经典》）
    for(int a=1;a<=n;a++)
    printf("%d ",f[a]);
    printf("\n");
    for(int a=1;a<=n;a++){
        int i=f[a];
        t+=(cq[i]*(n-a));            ///
    }
    printf("%.2f",t/n);                 //注意%.2f的用法
}
```

---

## 作者：WilliamPen (赞：1)

然而这道题目很容易的。显然序号要和时间一起排，所以要用结构体，速度出结果。求最小平均等待时间，不就是让快的先接水不就好了吗，生活经验可得，所以用了一遍快排。然而注意的是，不要用float，必须要用double。不信你可以试试，会在求平均值的地方炸掉。

以下鄙人代码

    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct r{
    int xh;//序号 
    int sj;//时间 
}a[1010];
bool cmp(struct r x,struct r y){
    if(x.sj<y.sj) return 1;
    else return 0;
}
int main(){
    int n;float t;
    cin>>n;
    for(int i=1;i<=n;++i){
        a[i].xh=i;
        cin>>a[i].sj;
    }
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;++i){
        t+=a[i].sj*(n-i);
        cout<<a[i].xh<<" ";
    }
    cout<<endl;
    printf("%.2f",t/n);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

学过一点数学的人都知道（比如本菜鸟...）：

要使每个人的等待时间都尽量少，就要让那些快的人排在前面

这样的话后面那些乌龟才不会大幅度地拖累前面的人嘛

但是由于受到种种装逼因素的影响，蒟蒻们请注意：

1.数据范围装逼，写了1e6，但实际上是十万，所以不能用冒泡来排序

2.数据范围再次装逼，写了“不保证ti不重复”，所以桶排也不行

3.c++也很装逼，用部分和，样例输出就是会少0.9

结论是：要用结构体+快排+一些处理

具体见程序：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
//先让结构体大神现身吧 
struct k 
{
    int t;//每个人接水的时间 
    int l;//每个人的序号 
}t[100005];//定义了一个结构体数组，t 
bool cmp(k x,k y)
//结构体数组排序时注意要附上本函数，不然...没有不然 
{
    return x.t<y.t;//返回小的那个时间 
}
double m;//必须用double，不然会出现误差 
int s,n;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++) 
    {
       scanf("%d",&t[i].t);//输入时间 
       t[i].l=i;//记录每个人的编号 
    }
    sort(t+1,t+1+n,cmp);//将时间从小到大排序 
    for (int i=1;i<=n;i++)
    {
        printf("%d ",t[i].l);//输出每个人的编号 
        m+=s;s+=t[i].t;//由于部分和坑爹，只能装个逼了 
    }
    printf("\n%.2lf",m/n);//输出 
    return 0;
}
```

---

## 作者：FREEH (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct aa
{
    int s;
    int b;
};
aa a[10000];
bool cmp(aa s1,aa s2)
{
    if (s1.s>s2.s) return false;
    return true;
}//sort的cmp
int main()
{
    int n;
    double z;
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>a[i].s;
        a[i].b=i;
    }
    sort(a+1,a+1+n,cmp);//按装水速度从小到大排序
    for (int i=1;i<=n;i++)
    {
        cout<<a[i].b<<" ";//输出编号
        z=z+a[i].s*(n-i);//算出这位仁兄后面的人一共要等待多久并累加
    }
    printf("\n%.2f\n",z/n);//输出平均等待时间
    return 0;
}
```

---

## 作者：panzheng1999 (赞：1)

感觉样例已经暴露了解法。。。

就是让时间短的先接水，时间长的后接水，这样接水时间长的人不会耽误太多的人（嘛，大概就是这个道理）

细节码里说喽

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct stu
{
    int t;
    int num;
}a[1010];//个人接水时间及其编号
bool  cmp(stu x,stu y)
{
    return x.t<y.t;
```
}//所需时间少的先接水
```cpp
double b[1010];//每个人等待的时间
int n;
double ans;//答案
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i].t;
        a[i].num=i+1;//编号从1开始
    }
    sort(a,a+n,cmp);//排～
    for(int i=0;i<n;i++)
    {
        cout<<a[i].num<<" ";//输出编号
        for(int j=i;j<n;j++)
        {
            b[j]+=a[i].t;//每个人在第i个人接水时候所等待的时间
        }
        b[i]-=a[i].t;//本人接水是不等待，所以再减掉
    }
    for(int i=0;i<n;i++)
    {
        ans+=b[i];//所有人等待总时间
    }
    ans/=n;//平均值
    cout<<endl;
    printf("%.2f",ans);//保留后2位
    cout<<endl;
    return 0;
}

```

---

## 作者：Mr张 (赞：1)

var a,b:array [1..1000] of longint;{a数组是时间，b数组是序号}

```cpp
    n,i,j,k,x:longint;
    s,y:double;
begin
    read(n,a[1]);{先读入n和a[1]（后面是边读边排序，插排的改编）}
    b[1]:=1;
    for i:=2 to n do begin
        read(x);
        j:=i-1;
        while x<a[j] do begin
            a[j+1]:=a[j];
            b[j+1]:=b[j];
            dec(j);
        end;
        a[j+1]:=x;
        b[j+1]:=i;    
    end;{边读边排序，实际上就是插入排序的改编}
    for i:=1 to n do begin 
        write(b[i],' ');
        y:=y+a[i];{统计时间（地球人都懂）}
        s:=s+y-a[i];{自己排队的时间不算}
    end;
    writeln;
    write(s/n:0:2);{输出，保留两位小数}
end.
```

---

## 作者：萌新天行健 (赞：1)

加了个读入优化

```cpp

#include<cstdio>
#include<algorithm>
template <class TL> inline bool read(TL& x){
    char ch;bool f=false;
    x=0;
    while((ch=getchar())&&(ch<'0'||ch>'9')&&ch!='-');
    if(ch=='-') f=true;else x=ch-'0';
    while((ch=getchar())&&(ch>='0'&&ch<='9')) x=(x\*10)+(ch-'0');
    if(f) x=-x;
    return !(!x);}
struct R{
    int t,n;
    bool operator < (const R&rhs)const{
    return t<rhs.t;}
}C[1500];
int main(){
    int n;
    double s=0.0,p=0.0;
    read(n);
    for(int i=0;i<n;i++){read(C[i].t);C[i].n=i+1;}
    std::sort(C,C+n);
    for(int i=0;i<n;i++){
        printf("%d ",C[i].n);
        p+=C[i].t;
        s+=p;}
    printf("\n%.2lf",(s-p)/n);
    return 0;
}
[/codev]


---

## 作者：ztz11 (赞：1)

#坑就坑在必须用double，无语，简单贪心。

##只要用结构体+sort快排函数+cmp参数，一遍就a；

###但千万注意精度，int，float都会使你永远a不了也错的不明所以

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct r{
    int a,b;
}a[10005];
bool cmp(r x,r y)//因为是结构体，所以手写一下排序函数
{
    return x.b<y.b;
}
int b,c,d,e,g,h;
double f;//注意，此处必须用double，否则只有54分
```
#主程序，简单排序，中间记录就OK
```cpp
int main()
{
    cin>>b;
    for(c=1;c<=b;c++)
    {
        cin>>a[c].b;
        a[c].a=c;
    }
    sort(a+1,a+b+1,cmp);
    for(d=1;d<=b;d++)
    {
        cout<<a[d].a<<" ";
    }
    cout<<endl;
    for(e=b-1;e>=1;e--)//二元循环，算一下总等待时间
    {
        for(g=1;g<=e;g++)
        {
            f=a[g].b+f;
        }
    }
    f=f/b;
    printf("%.2lf",f);
}
```

---

## 作者：wabcy (赞：1)

很奇怪居然没有PASCAL快排，~~赶紧水一发~~,

思路都大家都讲得很清楚了,快的先上，以下是我的代码：




```cpp
var
a,b:array[0..10000] of longint;//a数组存时间，b数组存序号
i,j,n:longint;
s:double;
procedure qsort(l,r:longint);//快排交换不解释
var
  i,j,t,mid:longint;
begin
  i:=l;j:=r;mid:=a[(l+r) div 2];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then begin
       t:=a[i];a[i]:=a[j];a[j]:=t;
       t:=b[i];b[i]:=b[j];b[j]:=t;//序号也换了
       inc(i);dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  readln(n);
  for i:=1 to n do begin 
    read(a[i]);b[i]:=i;//输入，存序号
    end;
  qsort(1,n);//排序
  for i:=1 to n do write(b[i],' ');//输出序号先
  writeln;//换行
  j:=0;
  for i:=n-1 downto 0 do 
    begin
      j:=j+1; 
      s:=s+a[j]*i; //统计时间
    end;
  write((s/n):0:2); //输出走人
end.
```

---

## 作者：zzozz (赞：1)

分析：


嗯。。。。题目意思就是让一些人去接水，有的人水瓶大，接满花的时间多，有的人花的时间少 ，现在问怎么排队，才能使平均接水等待时间最少。。。那么我们知道总共的等待时间是第一个人的时间一直加到第n个人，那么就可以先让时间少的去打，这样就可以知道花的时间最少。。。。


那么题目中最多有1000个人，并且其中的ti不重复，那么我们就可以用一个1e6的桶来装数据（用于输出顺序），然后再求出平均时间；


 

代码：


代码





```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int n,f[1000010],data[1010];
double tot,cnt;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int a;
        cin>>a;
        data[i]=a;
        f[a]=i;
    }
    for(int i=0;i<=1000000;i++)
        if(f[i]) cout<<f[i]<<" ";
    cout<<endl;
    sort(data+1,data+1+n);
    for(int i=1;i<=n;i++){
        cnt+=data[i-1];
        cnt/=n;
        tot+=cnt;
        cnt*=n;
    }
    printf("%.2lf\n",tot);
}
博客：[http://www.cnblogs.com/zzozz/p/6214341.html](http://www.cnblogs.com/zzozz/p/6214341.html)
```

---

## 作者：谁懂谁伤心 (赞：1)

这题分两部分，1是顺序，2是平均。首先我们将读入的数字存入两个一样的数组，将一个数组排序，在用排序后的数一个一个与未排序的数对比，找到一样的就打印序号。求平均数时，我们只需要将排序后的数组从第一个起，每个数乘以总人数减他的位置即可，保留小数用printf完成。

    ```cpp
#include<algorithm>    
    #include<iostream>  
    using namespace std;  
    int main()  
    {  
    int a; cin >>a; int b=a,s[a-1],d[a-1]; for (int q=0;q<a;q++) {scanf("%d",&s[q]); d[q]=s[q];}      
    sort (d,d+a);  
    for (int q=0;q<a-1;q++)  
    for (int w=0;w<a;w++)  
    if (s[w]==d[q]){cout <<w+1<<" "; s[w]=-1; break;}  
    for (int w=0;w<a;w++)  
    if (s[w]==d[a-1]){cout <<w+1<<endl; s[w]=-1;break;}  
    float z=0.0;  
    for (int w=0;w<b;w++)  
    {z+=d[w]*(a-1); a--;}  
    printf("%0.2f",z/b);  
    return 0;  
    }  
```

---

## 作者：fzh001 (赞：0)

这是本蒟蒻第一次发题解，如有不足，请指出。

------------

这题乍一看挺难，其实搞懂了也是道水题。

此题分为两个步骤：
1.从小到大排序，输出更改后的位置；

2.按顺序累加；
代码如下：


```cpp
------------
#include<bits/stdc++.h>

using namespace std;

int a[100001],s[100001];

int main()

{

	int i,j,n;
	double ans=0,sum=0;
	cin>>n;
	memset(a,0,sizeof(a));//数组清零
	memset(s,0,sizeof(s));
	for(i=1;i<=n;i++)//输入数据
	{
		cin>>a[i];
		s[i]=i;//储存a[i]的位置
	}
	for(i=1;i<=n;i++)//将i的位置和a[i]排序
	{
		for(j=i+1;j<=n;j++)
	     {
	     	if(a[i]>a[j])
	     	{
	     		swap(s[i],s[j]);
			 	swap(a[i],a[j]);
			}
		 }
		 cout<<s[i]<<" ";//输出排好的位置
	}
	cout<<endl;
	for(i=1;i<=n-1;i++)//计算总值
	{
		a[i]=a[i]*(n-i);//(n-i)表示a[i]被算了几次：想想为什么？
			sum+=a[i];
	}
    
   ans=sum/n;//得出均值
   
	printf("%.2f",ans);//输出
	return 0; //~~习惯它~~

}
```


---

## 作者：Scandium (赞：0)

## 又是水题一道！！ 

### 思路：

#### 用一个结构体将当前这个人的编号和用时存起来，然后一个sort快排所用时间（小的在先）后输出对应编号，再把每个人的等待时间（前面所有人的用时和，不包括自己）加起来，除以人数，保留小数点后两位就好了.....

话不多说，贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct a{			//定义一个结构体 
	int bh;		//编号 
	long long sj;	//时间 
}t[1005];
int cmp(const a i,const a j)     //cmp让结构体也可以快排 
{
	return i.sj<j.sj;
}
int main()
{
	int n;
	double ans=0.00;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i].sj;			//读入，将编号存入结构体 
		t[i].bh=i;
	}
	sort(t+1,t+1+n,cmp);		//快排 
	for(int i=1;i<=n;i++)
		cout<<t[i].bh<<' ';
	cout<<endl;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<i;j++)		//由于第一个人不用等，i从2开始，j代表前面打水的人的编号 
			ans+=t[j].sj;
	}
	cout<<fixed<<setprecision(2)<<ans/n;		//输出，保留2位小数 
	return 0;		//华丽的收尾 
}


```

---

## 作者：huayucaiji (赞：0)

用个快排搞定。具体见程序注释。

```cpp

//copyright@huayucaiji 2019.1.12 

#include<bits/stdc++.h>
using namespace std;
int a[32678],b[32678],n;//开数组，a表示时间，b表示序号 
double ave=0;
void qsort(int l,int r)//qsort 快排，用二分法（编程书上都有，不讲了） 
{
	int i=l,j=r,mid=a[(l+r)/2];
	while(i<=j)
	{
		while(a[i]<mid)
		{
			i++;
		}
		while(a[j]>mid)
		{
			j--;
		}
		if(i<=j)
		{
			swap(a[i],a[j]);
			swap(b[i],b[j]);//交换一下数据 
			i++;j--;
		}
	}
	if(l<j)
	{
		qsort(l,j);//递归 
	}
	if(i<r)
	{
		qsort(i,r);//同上 
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)//输入 
	{
		cin>>a[i];
		b[i]=i+1;
	}
	n--;
	qsort(0,n);//排序 
	for(int i=0;i<=n;i++)
	{
		cout<<b[i]<<" ";
		ave+=(a[i]*(n-i));//算总时间 
	}
	ave/=(n+1);//求平均值 
	cout<<endl;
	cout<<fixed<<setprecision(2)<<ave;//输出fixed，setprecision函数在<cstdio>下 
	return 0;//鬼畜 
}
```

---

## 作者：凌云 (赞：0)

来一个不排序的

##最讨厌长代码了！！！  太不可爱了！！！

一定要简约啊。。。

###### pair,hash,简直是浪费内存。正如某楼所说：楼下的FIFO队列、优先队列等，拜托大佬，这是一道“普及-”，不是“提高-”。

数据小，二次循环轻松过

话休絮烦，代码如下



```cpp
##### #include<bits/stdc++.h>
##### #define for(a,c,e) for(int a=c;a<=e;a++)//压行（注意技巧，保证可读）
##### using namespace std;
int main(){//主程序（c++）如下
    double m3;int n,t[1002],m1,m2;//如题目所言,有n,T(i).另有m1,m2,m3一会用
    cin>>n;for(i,1,n)cin>>t[i];//输入
    for(i,1,n){m1=0,m2=9999999;//初始化
        for(j,1,n)if(t[j]<m2)m1=j,m2=t[j];//比较以找出最小，标记，避免sort
        printf("%d ",m1);//输出
        t[m1]=2147483657;//移出队列
        m3+=m2*(n-i);//计算总时间
    }
    printf("\n%.2f",m3/n*1.0);//新手必学习操作！！！
    return 0;
}
```

---

## 作者：vinvor (赞：0)

楼下的FIFO队列、优先队列等，拜托大佬，这是一道“普及-”，不是“提高-”。

waitingtime数组，用来存储每个人的等待时间，答案只需要求和再除以人数即可。

特别判断：第1个人的等待时间为0。

由贪心的思路易得，**每次选择接水时间最小的人来接水，后面排队的人增加的等待时间会最小，即符合了最优解原则**。

person结构体，存储编号和接水时间。当然这里可以将等待时间并入person类型的p数组里，更简单。

sort排序需要自定义比较器，因为排序规则是按照多关键字的，这样**比较的是两个结构体，而不是两个数**。

**注意最后一行的平均等待时间需要定义为double型，如果定义为int型，会截断后面的小数，不精确。**

而本题要求精确到小数点后2位，double默认为小数点后6位，即使截断也不会有误差。

```cpp
#include<bits/stdc++.h>
using namespace std;
double waitingtime[1050]={};
struct person{
    int num;
    double time;
}p[1005];
bool cmp(person a,person b){
    if(a.time==b.time){
        if(a.num>b.num){
            return 0;
        }
        else return 1;
    }
    if(a.time>b.time){
        return 0;
    }
    else return 1;
}
int main(){
    int n;
    cin>>n;
    double ans=0;
    for(int i=1;i<=n;++i){
        p[i].num=i;
        cin>>p[i].time;
    }
    sort(p+1,p+1+n,cmp);
    for(int i=2;i<=n;++i){
        waitingtime[i]=waitingtime[i]+waitingtime[i-1]+p[i-1].time;
    }
    for(int i=1;i<=n;++i){
        printf("%d ",p[i].num);
    }
    for(int i=2;i<=n;++i){
        ans+=waitingtime[i];
    }
    cout<<endl;
    ans/=n;
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：woshiren (赞：0)

本题不难，连脑筋都不用动，不过要注意细节。

```cpp

#include<iostream>
#include<cstdio> //这只是一个习惯，当然你也可以用这个库的printf来控制小数点 
#include<algorithm>
#include<iomanip> //为了下面输出控制小数点后面的位数，所以要调用这个库 
using namespace std;
struct data
{
    int time,num;
}a[1001]; //结构体捆绑排序。 
int n;
double sum;//如果是整数，计算总和的时候会少一些东西，所以要用double 
bool comp(data a,data b)
{
    return a.time<b.time;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++) 
    {
        cin>>a[i].time;
        a[i].num=i;//写入序号。 
    }
    sort(a+1,a+1+n,comp);//从小到大排序。 
    for (int i=1;i<=n;i++) 
    {
        cout<<a[i].num<<" ";//输出排序后的序号，即输出题目中的第一项结果——排列。 
        sum+=a[i].time*(n-i);//求出所有人等待时间的总和。 
    }
    cout<<endl;
    cout<<fixed<<setprecision(2)<<sum/double(n);//输出平均。 
     
    return 0;
}

```
本题主要在于排序和计算平均值，Pascal党可能有点麻烦，但是注意一点应该是很简单的。

#不准抄袭！


---

## 作者：Megumi_Cold (赞：0)

运用结构体排序，加上较为简洁的程序，ac！！！

```cpp

#include<iostream>
using namespace std;
struct l//结构体 
{
    int a,b;
}c[10000];
int co(const l & g,const l & h)//排序 
{
    return g.a<h.a;
}
int main()//主程序 
{
    int n;
    double d=0,e=0;
    cin>>n;//输入 
    for(int i=0;i<n;i++)
    {cin>>c[i].a;c[i].b=i+1;}//输入+记号 
    sort(c,c+n,co);//sort一下，你就知道 
    for(int i=0;i<n;i++)
    cout<<c[i].b<<" ";//输出号数 
    cout<<endl;//换行 
    for(int i=0;i<n;i++)
    e=e+c[i].a*(n-i-1);//等待时间 
    e=e/n;//平均 
    printf("%0.2f",e);//输出 
    return 0;//结束 
}

```

---

## 作者：Dillct (赞：0)

简单的贪心,把时间少的放在前面,最后的平均等待时间最短.

用sort结构体排序,然后计算出平均时间,输出就AC了




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>  //sort的需要的函数库
using namespace std;
struct ss{
    int num; //序号
    int time;  //时间
}a[1001];
int n;
double ans=0;
bool cmp(const ss &a,const ss &b) //sort比较函数
{
    return a.time<b.time;
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a[i].time);
        a[i].num=i+1;
    }
    sort(a,a+n,cmp);
    for(int i=0;i<n-1;i++)
    {
        ans+=a[i].time*(n-i-1); //计算总等待时间
        printf("%d ",a[i].num);
    }
    printf("%d",a[n-1].num);
    printf("\n%.2lf",ans/n);
    return 0;
}
```

---

## 作者：杨奕辉 (赞：0)

解题思路：它要求的是平均时间，每个人占的平均时间=他要的时间\*他前面的人数+1；

解题过程：先读入一个数组，内存所有人的时间；再用一个数组，值为它的标号；将a数组从小到大排序，使时间最小，交换是要两个数组一起交换；算出总时间，将每个人时间输出，再换行输出平均时间

```cpp
var
  a,b:array[0..5000]of longint;
  n,i,j,t:longint;
begin
  read(n);
  for i:=1 to n do  //读入
    read(a[i]);
  for i:=1 to n do  
    b[i]:=i;
  for i:=1 to n-1 do  //排序
    for j:=i+1 to n do
      begin
        if a[i]>a[j] then
                       begin
                         t:=a[i];
                         a[i]:=a[j];
                         a[j]:=t;
                         t:=b[i];
                         b[i]:=b[j];
                         b[j]:=t;
                       end;
      end;
  for i:=1 to  n do  //每个人的时间就是他的时间乘他前面的人数加一
    s:=s+a[i]*(n-i);
  for i:=1 to n do  //输出每个人倒时间
    write(b[i],' ');
  writeln;   //输出中要换行
  write(s/n:0:2);  //输出平均时间
end.

```

---

## 作者：Linshaos (赞：0)

#刚刚达到中牛不久（然而还是菜），做了几道贪心（因为动态规划还不熟），想来发发题解（放假时间充裕），算法很渣，欢迎建设性建议。

##切入正题，此题为非常简单和典型的贪心，个人认为主要有2个注意的重点：①对于Ti（每个人的接水时间）的处理；②平均接水时间。附上总时间的计算公式：

首先，理清楚思路：共有n人，每人轮流打水，可知当n[i]在打水时，就有n-i个人在等待，而这n-i个人等待总时间就是                      t[i]\*(n-i).用测试数据为例：排序后得到  3    2    7    8    1    4    9    6    10    5

1    12  33  55  56  99  99 234  812 1000

时间为  n[1]1   1   1   1   1   1   1   1   1

n[2]12 12 12 12 12 12 12 12

n[3]33 33 33 33 33 33 33

n[4]55 55 55 55 55 55

n[5]56 56 56 56 56

n[6]99 99 99 99

n[7]99 99 99

n[8]234 234

n[9]812

n[10] 0

###附上代码（没用algorithm，老师说最好自己编，我是好学生(\*^\_^\*)）

```cpp
#include<iostream>
#include<iomanip> //对应原题精确到小数点后两位的流输出的头文件
using namespace std;
void kp(int,int);  //对于Ti的处理我选择是快排
long long t[100001]={0},number[100001]={0};  //稍微初始化两个数组，其中t是每个人的接水时间，number是每个人的序号
double k=0.0; //考虑到数据可能比较大，用float应该也可以
int main() //主程序
{
    int n;  
      cin>>n;  //读入共有多少人
    for (int i=1;i<=n;i++)
    {
        cin>>t[i];
        number[i]=i;}  //读入每个人的时间，并记录序号
        kp(1,n);  //快排跑一趟
        for (int i=1;i<=n;i++)cout<<number[i]<<" "; //排好先输出
 cout<<endl;  //注意换行
    for (int i=1;i<=n;i++)
    {
        t[i]=t[i]*(n-i);
        k=k+t[i];}
     cout<<setprecision(2)<<fixed<<k/n;  //标准输出
     return 0;
}
void kp(int l,int r)
{
    int i=l,j=r,x=t[(l+r)/2],y=number[(l+r)/2];  //把两个数组从中间切开
    while (i<=j) //i>j的话，你想怎么排？
    {
        while (t[i]<x ||(t[i]==x && number[i]<y))i++;
        while (t[j]>x || (t[j]==x && number[j]>y))j--; //其他不解释（序号小的在前面）
         if (i<=j)
         {
                swap(t[i],t[j]);
                swap(number[i],number[j]);
                i++;
                j--;}
    if (j>l) kp(l,j);
    if (i<r) kp(i,r);}  //递归重造
}
```

---

## 作者：TBB_Nozomi (赞：0)

这个题的本质上是找到一个队列使得加权累加的总时间和最小。

首先的第一步是要排序。由于数据量较小，除了随机排序以外一般规定时间都能过。在这里我使用C自有的qsort和结构体配合使用。

然后接下来是研究最短等待时间和。由于排队接水是一个接着一个的，也就是只允许最多一个人同时打水，所以某一个人打水的时候其身后的人的等待时间总和就是人数\*单人时间

显然每一个人接水的时间和需要等待的人数是不变的（对应关系会发生改变），于是我们生成两个序列：list1“这个时候需要等待接水的人数”{0,1,2,...,n-1}和时间序列{t1,t2,...,tn}（由小到大），求对应乘积和的最小值。由**排序不等式**可知，当序列均为正数时倒序和最小.

因此时间总和为**s=0\*tn+1\*t2+...+(n-1)\*t1**,也就是为什么要先对时间排序的原因。

下面附上原码(千万不要用int来存储时间总和QAQ)

```cpp
#include <stdio.h>
#include <stdlib.h>
struct num{
    int n;
    int k;
}list[1001];
int camp(const void *a,const void *b)    {
    return ((struct num*)a)->k-((struct num*)b)->k;
}
int main()
{
    int i,n;
    double s=0.0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)    {
        scanf("%d",&list[i].k);
        list[i].n=i;
    }
    qsort(&list[1],n,sizeof(struct num),camp);
    for(i=1;i<=n;i++)    printf("%d ",list[i].n);
    for(i=1;i<=n;i++)    s+=(n-i)*list[i].k;
    printf("\n%.2f",(double)s/(double)n);
    return 0;
}
```

---

## 作者：XiChZ (赞：0)

简单易懂的一份题解~

program water;

首先我们需要定义变量

```cpp
var
n,i,j,p:longint; //n为总个数，i,j为循环变量
t,a:array[1..10000]of longint; //两个数组，t作为时间，a作为次序
sum:real; //用于存储时间总和
```
然后，主程序开始了~
```cpp
begin
readln(n); //先读入个数
for i:=1 to n do //通过循环读入时间变量
begin 
read(t[i]); //由于时间在一行输入所以用“read"
a[i]:=i; //初始化次序
end;
```
下面这一步最关键，根据数学知识，我们知道，打水的时候花费时间越少的人越先打，那么所有人的等待时间之和就会最小，所以我们需要排序。（以下是pascal的最基础排序，从小到大）
```cpp
for i:=1 to n-1 do
for j:=i+1 to n do
if t[i]>t[j] then 
begin 
p:=t[i]; //p只是作为一个排序时交换的临时变量
t[i]:=t[j];
t[j]:=p;
p:=a[i]; //每次交换时间，同时交换次序
a[i]:=a[j];
a[j]:=p;
end;
```
循环输出排好的次序（在第一行）
```cpp
for i:= 1 to n do 
write(a[i],' ');
writeln; //输出好第一行之后一定要换行！！
p:=0; //废旧变量再次利用
for i:=n-1 downto 0 do //计算总等待时间
begin
p:=p+1; 
sum:=sum+t[p]*i; 
end;
write((sum/n):0:2); //输出第二行：总等待时间除以总人数就是平均等待时间，保留2位小数（题目要求）
end.
贪心算法的基本实现，大功告成！
```

---


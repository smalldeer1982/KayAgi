# 【深基9.例1】选举学生会

## 题目描述

学校正在选举学生会成员，有 $n$（$n\le 999$）名候选人，每名候选人编号分别从 $1$ 到 $n$，现在收集到了 $m$（$m \le 2000000$）张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。

## 样例 #1

### 输入

```
5 10
2 5 2 2 5 2 2 2 1 2```

### 输出

```
1 2 2 2 2 2 2 2 5 5```

# 题解

## 作者：DreamFox (赞：204)

本题思路：

简单的快排，直接$sort$即可

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000000],n,m;
int main()
{
	cin>>n>>m;
	for(int i=0;i<m;i++)cin>>a[i];
	sort(a,a+m); //sort排序
	for(int i=0;i<m;i++)cout<<a[i]<<" ";
	return 0;
}
```
我们发现这还不够快，怎么办？

用桶排！

用$1000$的数组记录票出现的次数，最后根据票出现的次数输出即可

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,n,m,b[1000];
int main()
{
	cin>>n>>m;
	for(int i=0;i<m;i++)cin>>a,++b[a]; //记录票出现的次数
	for(int i=0;i<1000;i++)while(b[i]--)cout<<i<<" "; //根据票出现的次数输出
	return 0;
}
```


---

## 作者：Ares゜ (赞：34)

##### ~~这是~~~~一道由黄~~~~色降为橙色的深基题目~~
#### 主要就是排序
 个人觉的得它作为一道橙题还是比较合适的
### 下面我说说直接用sort做的办法
```
#include<bits/stdc++.h>
//来个万能头
using namespace std;
int main()
{
    int a[2000001],n,m;//注意数组范围，不要开小了
    scanf("%d%d",&n,&m);//来个输入
    for(int i=1;i<=m;i++)
    scanf("%d",&a[i]);
    sort(a+1,a+m+1);//排序
    for(int i=1;i<=m;i++)
    printf("%d ",a[i]);//输出
    return 0;
}
```
这应该是比较简单的做法了，输入，排序，然后直接输出
另外我再给大家介绍一下我最初的做法
这应该是比较基础的方法
```
#include<cstdio>
using namespace std;
int main()
{
    int a[2000001],n,b,m,c;//定义一下,开数组
    scanf("%d%d",&n,&m);//输入
    for(int i=1;i<=m;i++)
    scanf("%d",&a[i]);//输入数组
    for(int i=1;i<=m;i++){
        for(int j=i;j>0;j--){//倒着往回找
            if(a[j]>=a[i]){//看看有没有比现在的数大的
                b=a[j];
                a[j]=a[i];
                a[i]=b;//换位置
            }
        for(int k=i;k<=m;k++){//再往后找
        if(a[k]<a[i])//找找有没有比现在的数小的
        {
        	c=a[k];
        	a[k]=a[i];
        	a[i]=c;//换位置    
        }
        }
    }
    }
    for(int i=1;i<=m;i++)
    printf("%d ",a[i]);//输出
    return 0;
}
```
这个代码理论上应该是没错的，但是由于题目的数据范围比较大，会超时(我WA了6次就是因为TLE),数据范围较小的情况下可以参考一下
### 本蒟蒻的第五篇题解，如有不足之处请大佬帮忙指正

---

## 作者：dfadfsafsdaf (赞：24)

 **这只是一个~~橙(hong)题~~~~**

这个题主要是要我们完成一个数值排序

现在我们介绍一下[STL库](https://baike.so.com/doc/10037528-10530805.html)

STl库是一个c++自带的模板程序库，在头文件#include<algorithm>中，我们今天要用到的就是STL库中的[sort](https://blog.csdn.net/zzzmmmkkk/article/details/4266888/)函数

sort是STL库中的一个排序函数，非常方便，它的格式是：

sort(排序区间头，排序区间尾，排序规则）;
  
不废话，上代码

------------

  
```cpp
#include<cstdio>//基本输入输出头文件
#include<algorithm>//STL库头文件
using namespace std;
int main()
{
    int a[2000001],n,m;//
    scanf("%d%d",&n,&m);//输入n,m
    for(int i=1; i<=m; i++)
    {	
    	scanf("%d",&a[i]);//输入候选人选票
    }
    sort(a+1,a+m+1);//排序，不加排序规则默认从小到大排
    for(int i=1; i<=m; i++)
	{
  		printf("%d ",a[i]);//输出排序后的结果
  	}
  	return 0;//完美撒花~~
}

```
*------------------------------------------------------------------------------------------------------------*
  
希(qiu)望大(tong)家喜(guo)欢~~


---

## 作者：sycqwq (赞：15)

题目理解：

嗯，这题就是把m个数从小到大排序输出来，每个数<=n；

一题多解，此题既可以直接用sort，又可以用桶排。

sort代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2000005];
int main(){
	cin>>n;
	int m;
	cin>>m;
	for(int i=1;i<=m;i++)
		cin>>a[i];
	sort(a+1,a+m+1);//排序
	for(int i=1;i<=m;i++)
		cout<<a[i]<<' ';
	return 0;
}

```

桶排代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[2000005],t[1000];//t为桶
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i];
		++t[a[i]];//a[i]的出现次数+1
	}
	for(int i=1;i<=n;i++)//最大得数是n
	{
		for(int j=1;j<=t[i];j++)//这里循环输出，因为不要去充，所以要循环出现的次数次，输出i，如果没出现过，t【i】为0，直接跳过循环
			cout<<i<<' ';
	}
	return 0;
}

```

最让我惊讶的是堆排竟然被卡了233

---

## 作者：vеctorwyx (赞：11)

## ~~黄题！~~

既然出题人把他定义为黄题肯定要考什么有 **点** 难度的东西

题目中给了个n的意思应该是桶排，再看m，得出结论应该是考桶排。

~~但出题人好像把数据范围弄得太小了，我就这么用sort水过去了。。。~~

那么我就发个桶排的代码吧（~~虽然我比赛时写的是sort~~）：

```
#include<iostream>
using namespace std;
int n，m;
int a[999];
int d;
int main()
{
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		cin>>d;
       		a[d]++;
	}
	for(int i=1;i<=n;i++)
	{
    		while(a[i]--)
            	cout<<i<<" ";
       	}
        return 0;
}
```


---

## 作者：封禁用户 (赞：8)

标准的排序模板题

$2020/2/10:$链接打不开了，修改了一下。


再次安利我的博文[常用排序算法总结](https://www.luogu.com.cn/blog/CM0/chang-yong-pai-xu-suan-fa-zong-jie)。

[原题链接](https://www.luogu.com.cn/problem/P1271)

话说这题我是在洛谷入门赛里翻到的，错过比赛好可惜$QwQ$（题外话

进入正题：

好像就是排序。。

不过，冒泡和选排不用想了，肯定$TLE$，但是$sort$还是值得一试的![](https://cdn.luogu.com.cn/upload/image_hosting/3eu5qbzt.png)

呵呵，提交之后，代码炸了。。

就像这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1001]={0};
int main() {
	cin>>m>>n;
	for(int i=1; i<=n; ++i)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1; i<=n; ++i)cout<<a[i]<<" ";
	return 0;
}
```

分析：

$m≤2000000$好像铁定会炸欸。

那就只有手写快排和桶排了


我？当然选桶排

桶排$code$

```cpp
#include<bits/stdc++.h>
using namespace std;
long long b[1001],n,m,k;
int main() {
	cin>>m>>n;
	for(long long i=1; i<=n; ++i) {
		cin>>k;
		b[k]++;
	}
	for(long long i=1; i<=m; i++) {
		while(b[i]>0) {
			cout<<i<<" ";
			b[i]--;
		}
	}
	return 0;
}
```


应该没难度吧（虽然卡了我一会

---

## 作者：Misaka_Mikoto0502 (赞：7)

看了一下样例数据，其实就是排序
STL方案
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
	int m,n; cin >> m >> n;
	int* x = new int[n];
	for (int i = 0; i < n; i++)
		cin >> x[i];
	sort(x, x + n);
	for (int i = 0; i < n; i++)
		cout << x[i]<<" ";
}
```
冒泡方案：
```cpp
#include <iostream>
using namespace std;
int main ()
{
  int m;cin>>m;
	int n; cin >> n;
	int* in = new int[n];
	for (int i = 0; i < n; i++)
		cin >> in[i];
	for (int j = 0; j < n - 1; j++)
	{
		for (int i = 0; i < n - 1; i++)
		{
			if (in[i] > in[i + 1])
			{
				int tmp = in[i];
				in[i] = in[i + 1];
				in[i + 1] = tmp;
			}
		}
	}
	for (int i = 0; i < n; i++)
	{
		cout << in[i] << " ";
	}
	cout << endl;
}
```


---

## 作者：TRZ_2007 (赞：7)

## Solution

这道题目本质上是排序……  
数据上说$m \le 2 \times 10^6$，所以我们可以基本排除$\Theta(n^2)$以上的算法，那么只有$sort,qsort,msort$以及其他我没说的排序了。

- 1 $sort$（谁都会，不讲）

```
#include <bits/stdc++.h>
using namespace std;

const int N = 2000010;

int a[N],n;
int m;

int main() {
	scanf("%d %d",&m,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) {
		printf("%d ",a[i]);
	}
}
```

- 2： $qsort$  
主要是找到基准数并让其他数和它进行比较，以它为中心，左右分别是比他大和比他小的数。继续递归。

- 3：$msort$  
对这个数列进行分解，直到数据长度为一。接下来进行合并即可

---


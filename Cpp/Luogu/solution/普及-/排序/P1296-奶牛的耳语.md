# 奶牛的耳语

## 题目描述

在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有 $n$ 头奶牛，其中第 $i$ 头牛在直线上所处的位置可以用一个整数坐标 $p_i(0\le p_i \le 10^8)$ 来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过 $d(0 \le d \le 10^4)$ 的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离 $d$ ，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。

## 说明/提示

数据规模

对于 $40\%$ 的数据，$1 \leq n \leq 10^3$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
5 10
10 12 16 37 40
```

### 输出

```
4```

# 题解

## 作者：dingcx (赞：292)

~~这道题怎么可能是红题？~~

我认为此题为红题的原因是可以用**STL**。
## 思路
尽管样例是按顺序给的，但事实上位置未必是按顺序的，为了方便计算，首先要**排序**。

排完序后，对于每一头牛，只需要找到后面的所有和它的距离小于$d$的，累计一下就好了。

不过，数据范围很大，一个一个找一定超时，需要优化，用到**二分**。

这样只需要把二分结果前面的所有牛加起来就行了。
## 代码
STL是个好东西。我用到了这里的两个函数：$sort$和$upper$_$bound$。

### sort
这个函数相信大家都很熟悉，就是给数组排个序。

用法：$sort(a.begin(),a.end())$。这样可以给数组从小到大排个序。放在这道题里就是：
```cpp
sort(a+1,a+n+1);//数组从1开始
```
当然这个函数不仅仅可以从小到大，可以从大到小或结构体排序，这些东西大佬们一定知道，这里就不赘述了。
### upper_bound
没错，这才是这个代码的核心部分。它的作用是二分查找一个数在数组中出现的位置。

用法：$upper$_$bound(a.begin(),a.end(),num)$。这样可以在数组中找到第一个大于$num$的数的地址，如果不存在就返回$end$。而由于是地址，就需要在最后减去$a$。

放在这道题里就是：
```cpp
int k=upper_bound(a+i+1,a+n+1,a[i]+d)-a;//返回地址，要减去a的地址
```
有一个和此函数差不多的函数，叫做$lowerbound$，只是把上面的“大于”改成“大于等于”。但这道题用的是$upperbound$。

在这里需要注意目前遍历的牛（即$i$）和二分结果（即$k$）都不算在内，所以这里结果要加$k-i-1$。
## 代码
~~相信没有多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——

代码长度$17$行（~~还没上面的分析长~~），时间$48ms$（~~挺快~~）。
```cpp
#include<cstdio>
#include<algorithm>//sort和bound都需要此库
using namespace std;
const int MAXN=1e6+10;//n的最大值
int a[MAXN];
int main(){
	int n,d,ans=0;
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=n;i++){//遍历每只奶牛
		int k=upper_bound(a+i+1,a+n+1,a[i]+d)-a;//二分
		ans+=(k-i-1);//记录
	}
	printf("%d",ans);
	return 0;//华丽结束
}
```
在百忙之中写一篇题解也比较辛苦，别忘了点个赞！

---

## 作者：scp233 (赞：105)

其实按这题的数据范围，难度决不止入门~~（我刚开始交了个暴力t了两个点）~~

然而由于数据的仁慈，许多时间复杂度十分接近暴力的程序通过了这题，使得这题的难度标签被拉了下来。事实上在某些阶段数据（如d很大【声音传得超~远】，奶牛之间离得很近，这时排序后的【数据有序】这一红利将大为减小，还要搭上排序的O(nlogn)时间）


--------------------正片开始--------------------

前面说过在某些极端数据下排序+暴力会使【数据有序】这一红利大大减小，那该怎么解决呢？

看到一串有序的数列，你会想到什么？

###   二分

~~（单调队列）~~

  
想到这个一切就都好办了：首先排完序，然后从第一个点开始向后做，利用二分找出声音最多能到第几个点，然后加到累加变量里就行了。    这样最坏时间复杂度是O（nlogn【快排】+nlogn【二分】）~~没有最好情况~~，并不会超时

  

放出程序：

    
    
      
    
```cpp
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<string>
    #include<cstring>
    #include<cmath>//大部分没有用的头文件
    #define rep(a,b,c) for(int a=b;a<=c;a++)//宏定义，就是为了下面方便，大家读的时候可以脑补成for语句，有兴趣可以去搜索一下
    #define drp(a,b,c) for(int a=b;a>=c;a--)
    #define HY 1000005
    #define lo long long
    using namespace std;
    int n,m,x,y,s,a[HY],l,r,mid;
    int main(){
      cin>>n>>m;
      rep(i,1,n) scanf("%d",&a[i]);
      sort(a+1,a+n+1);//排序只需一句话 @pascal 
       rep(i,1,n-1){ //从每个点（除最后一个点）开始都做一遍
        l=i+1; r=n; //二分标配l和r，表示目前可能的范围在l与r之间
         while(l<r){
         mid=(l+r+1)/2; //取区间的中间
          if(a[mid]-a[i]<=m) l=mid; //若条件满足，说明mid及左边都可以与第i头牛说话，就把l赋成mid
          else r=mid-1; //若条件不满足，说明mid及右边都不能与第i头牛说话，把r赋成mid-1
         } //做完后l必与r相等
        s+=l-i; //i能与i+1到l的牛说话，则都累加上去
        if(a[l]-a[i]>m) s--; //如果i连第i+1头牛都不能听到，那么说明之前多加了一对，减掉
       }
    cout<<s;    //输出之
    return 0;
    }
蒟蒻求赞_(:з」∠)_
```

---

## 作者：「已注销」 (赞：56)

这题数据太水，让很多$O(n^2)$暴力卡过了，本来难度不止入门

$O(nlogn)$不一定要二分呀

读入完排序，$it$存能与第$i$头牛交流的坐标最大的牛的编号

当$i$变大时，$it$一定不会变小

所以统计答案$O(n)$

加上快排$O(nlogn)$
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,d,a[100001],it=2,ans;
int main(){
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<n;++i){
		while(it<=n&&a[it]-a[i]<=d)++it;
		--it;
		ans+=it-i;
	}
	printf("%d",ans);
}
```

---

## 作者：AdzearDisjudge (赞：33)

本题核心思路：

1、读入后要排序以达到剪枝的目的

2、模拟，遇到不能再交流就转入下一头牛，否则计数器加一

3、输出计数器即可

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001],n,f,i,j,k;
int main()
{
    cin>>n>>f;
    for(i=1;i<=n;++i)
    cin>>a[i];
    k=0;
    sort(a+1,a+(n+1));
    for(i=1;i<n;++i)
    for(j=i+1;j<=n;++j)
    {
        if(a[j]-a[i]>f)
        break;
        ++k;
    }
    cout<<k;
    return 0;
}
```
PS：%%%神犇thx!!!


---

## 作者：ExcaIibur (赞：11)

```cpp

# ------------保证最优------------

必须用快排！不排序的话，即使时间过了内存也会爆！在筛选阶段也可以利用
二分法和题意的逻辑进行优化！但此题二分的效果不明显。

------------

#include<bits/stdc++.h>//万能头文件
#include<algorithm>//算法库
using namespace std; 
int main()
{
	int n,d,i;//n为牛总数，d为传播范围
	cin>>n>>d;
	int p[n];//定义大小为n的数组p，记录各牛位置
	for(i=0;i<n;i++)
	cin>>p[i];
	sort(p,p+n);//c++快排函数
	int s=0,c,len=p[n-1]-d,mid=1,l,h;
   	//s为答案，c为当前牛可听到的最右边(避免重复计算，所以用变量了)
    len为需要遍历的最右边（因为在最后的d范围内的牛肯定能互相交流）
    mid、l、h均为二分参数
	for(i=0;p[i]<len;i++)//从左向右遍历，求出每头牛向右可相互交流
    的组数
	{
		c=p[i]+d;//当前c
		l=mid,h=n-1;//二分法求出在c右边的第一头牛（不能交流的
    第一头牛）位置mid。此处有一小技巧：因为牛是非降序排列，当p[i]右移时
    上一次的mid肯定是当前mid的下限，所以每次计算的l都能用上次mid
		mid=(l+h)/2;
		while(l<h)//二分找牛
		{
			if(p[mid]<=c)l=mid+1;
			else h=mid;
			if(p[mid]>c&&p[mid-1]<=c)break;
			mid=(l+h)/2;
		}//也可用for(int j=mid;p[j]<=c;j++);mid=j;暴力找牛
		s+=mid-i-1;
        //两头牛位置相减再减1即为该次循环可交流组数
	}s+=(n-i)*(n-i-1)/2;//加上最后d范围（排列组合）
	cout<<s;
	return 0;
}

------------
顶一下

**

---

## 作者：洛绫璃 (赞：3)

复杂度（nlongn+n），先排序a[n]，标记i=1,j=2，开始循环找到第一个与i相距大于m距离的奶牛，则与i组成一对的个数为 j-i-1 ，然后++i，（重点！！）j不用变，因为当前a[j]距离上个a[i]刚好第一次距离大于m，则新的i-（j-1）之间奶牛的距离必定小于m，直到j==n+1，内循环截止，直接ans+=(n+1-i-1)+(n+1-i-1-i)+(n+1-i-2-1)+...+(n+1-n-1),即ans+=（n-i+1）*n-(n-i+1)*(n+i)/2;跳出循环即可，看似n^2,实则是j在i的基础上逼近n然后跳出循环，复杂度为（n）;
```
#include<bits/stdc++.h>
  using namespace std;
int n, a[1000001], m, d[1000001], ans;
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	for (int i = 1, j = 2; i <= n; ++i) {
		for (; a[j] - a[i] <= m&&j<=n; ++j);
		if (j == n + 1) ans += (n - i + 1)*n - (n - i + 1)*(n + i) / 2, i = n + 1;
		else ans += j-i-1;
	}
	printf("%d", ans);
}
```


---

## 作者：ZHDX (赞：3)

看了其他题解. 觉得有必要把这个问题说清楚, 简单化. 

思路清晰的情况下, 这题根本没难度. 

其他题解里, 凡是出现 结果++; 都是没好好理解题意.


原理如下, 如果限定距离 d=100 , 举例, 并排序后: 

11 23 37 255 266 277 366 1024 1035 1046 

设置一个 i 循环作为主循环 , 然后设置一个开始位置 s=0 

这样当 i=[4] 到达  255 的时候, 前面3项距离都超过100 , 

这时候通过 s++ 寻找左边d<=100的数, s自然就到达[4]

然后 i 到达 266,277 的时候,  只需要和s=[4]比较一次便可. 

**在i和s之间的所有数字都满足距离小于d的条件. **

所以 t += i - s;

i去到366的时候呢?  s位置255不满足了, 这时候s++ 到达266, 又满足条件了. 

总的说来,  i单独最多循环n次,  s单独循环n次, 并非嵌套循环, 所以循环次数仅仅为2n 

相对于前面的排序的复杂度, 在超大数据下, 这个2n是几乎可以忽略的. 



```cpp

#include <algorithm>
#include <iostream>
using namespace std;

int nums[1000001];

bool compi(int& v1, int& v2)
{
	return v1 < v2;
}

int main()
{

	int n, d;
	scanf("%d%d", &n, &d);

	for (int i = 0; i < n; i++)
	{
		scanf("%d", &nums[i]);
	}

	//题目数据未排序, 需要排一下
	sort(nums, nums + n, compi);

	int s = 0;//表示左边最后在范围内的另外一只牛的位置

	int t = 0;//结果

	//循环右边的牛
	for (int i = 0; i < n; i++)
	{
		int curr = nums[i];

		//检查左边的另外一只牛在不在范围
		//如果不在, 则继续寻找
		//最差的情况是 因为 s==i 而结束循环, 一个都找不到.
		for (; s < i; s++)
		{
			//如果找到一只牛是在范围内, 则其他牛全都在范围内
			if (curr - nums[s] <= d)
			{
				//范围内, 除了自己, 所有符合结果的牛的个数
				t += i - s;

				//找到了, 就让s停留在当前位置
				break;
			}
		}
	}

	cout << t;

	return 0;
}
```



---

## 作者：SGOI_Aromyase (赞：2)

这题其实剪枝也可能会卡TLE

然而良心的出题人没有卡2333

我感觉如果卡了TLE这题，毕竟d很大时最坏情况是O(N2)

楼下给了一种思路，我也给一种

排序肯定是没问题的，关键是排序以后怎么找

线性数组查找数据，我们可以使用二分法

然后时间复杂度就成功的变成了O(NlogN）~

然后再扫一遍


---

## 作者：autoencoder (赞：1)

这道题主要思路在于始终维持一个大小为d的滑动窗口，统计窗口中的奶牛对数。

代码复杂度：O(nlogn)+O(n)=O(nlogn)

```cpp
#include <iostream>
#include <algorithm>
#include <fstream>
using namespace std;

int p[1000001];

int main() {
	int n, d, count = 0;
	cin >> n >> d;
	for (int i = 0; i < n; i++) {
		cin >> p[i];
	}
	sort(p, p+n);
    /*
    这里我们手动添加一个奶牛，把这个奶牛所在的
    位置设置为任何一个奶牛都不可能到达的位置。
    这样的好处在于在后面循环的时候不需要单独考
    虑当i>=n时j<i-1的特殊情况。为什么会有特殊
    情况呢？
    
    思路就是i不断向右寻找窗口的右边界，j表示窗
    口左边界。一旦发现i所指向的奶牛和j所指向的
    奶牛距离超过了d就表示窗口已经大于d了（我们
    始终希望窗口的大小是小于等于d的），这时候
    i-1就是最后一个可以跟j聊天的奶牛，这时候
    在窗口中的奶牛对数为(i-1-j)。
    */
	p[n] = p[n-1] + d + 1;
	int i = 0, j = 0;
	while (i <= n) {
		if (p[i] - p[j] > d) {
			count += i - j - 1;
			j++;
		} else {
			i++;
		}
	}
	
	cout << count << endl;
}
```
    
有特殊情况的代码：
```cpp
    int i = 0, j = 0;
	while (i < n) {
		if (p[i] - p[j] > d) {
			count += i - j - 1;
			j++;
		} else {
			i++;
		}
	}
    // 特殊情况处理，也可使用求和公式
	while (j < i) {
		count += i - j - 1;
		j++;
	}
```
特殊情况发生在如果i不断递增超过了n-1，也就是循环结束但事实上j依然距离i有一段距离，也就是说当循环结束时，由j和i表示的窗口中的所有的奶牛依然可以互相联络，这时候我们就需要特殊处理。通过这个例子我们就可以看出手动增加一个奶牛的好处了。
```

---

## 作者：_Andy_Lin_ (赞：0)

与诸位大佬不一样，我用了倍增来解决此题。

------------
第一步：快排（好像大家都一样）

------------
第二步：对每头牛进行这样一个操作：
用变量k记录第i头牛最远能跟后面第几头牛谈话，起初k=i。然后再用一个变量p表示可以往前扩展几头牛，起初p=1。如果可以与第k+p头牛谈话，就将k加上p，将p乘上2。否则，将p除以2。直到p=0停止操作。此时，第k头牛就是最远的谈话对象。将ans加上k-i。

------------
最后愉快的输出ans就好啦！

------------
代码如下
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,d,a[1000001],ans;
int main(){
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);//C党的优越感
	for(int i=1;i<=n;i++){//倍增算法实现
		int k=i,p=1;
		while(p){
			if(k+p<=n&&a[k+p]-a[i]<=d){
				k+=p;
				p*=2;
			}
			else p/=2;
		}
		ans+=k-i;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：灬Amiya灬 (赞：0)

一开始java用暴力过不了，不知道是不是没有剪枝呢
没有确认，然后因为比较少写二分，想锻炼下，便写一下吧
写二分的话，边界问题要注意好
快排好后，从左到右遍历点，
find函数处理遍历的点，向左二分搜索，得出离自己最远的在d范围里面的点。
然后用算出之间包括自己有多少个点就可以得出有多少对了。


```java
package p1296;

import java.util.Arrays;
import java.util.Scanner;

public class Main {
	static int n,d;
	static int count=0;
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		Scanner in = new Scanner(System.in);
		n = in.nextInt();
		d = in.nextInt();
		int a[] = new int[n];
		for(int i=0;i<n;i++) {
			a[i] =  in.nextInt();
		}
		Arrays.sort(a);
		for(int i=0;i<n;i++) {
			count+=i-find(0,i,i,a);
		}
		System.out.println(count);
	}
	private static int find(int left,int right,int i,int a[]) {
		// TODO 自动生成的方法存根
		int mid = (right+left)/2;
		if(left==right) {
			if(a[i]-a[left]<=d) {
				return left;
			}
			else return left+1;
		}
		if(a[i]-a[mid]<=d) {
			 return find(left,mid,i,a);
		}
		else return find(mid+1,right,i,a);
		
	}

}

```

---

## 作者：kdlkswb (赞：0)

[题目传送门](https://www.luogu.org/problemnew/show/P1296)

简述题意：给定一个序列和一个数$d$，求无序数对$<i,j>$的个数，满足$|a_i-a_j|<=d$。

思路：先将给定的序列排序，然后放入一个队列中，维护与队首距离$<=d$的数是哪些。当我们要加入一个数的时候，先将当前队列中与新加入的数距离过远的数出队，同时更新答案，然后将新的数加入队尾。因为我们已经将序列排好序了，所以需要出队的数都在队首，直接判断即可。

考虑数据出队时如何更新答案。我们队列里记录的是比队首大的、符合要求的数（一开始从小到大排序的话），因此答案只需要加上当前队列里的元素数量即可（队首要去掉）。那么比队首小的符合要求的数会漏掉吗？其实并不会，因为$<i,j>$和$<j,i>$是相同的，所以这部分已经在之前计算过了。

这样做的复杂度为$O(nlogn+n)$，过此题无压力

最后，别被样例坑了，输入的数据是无序的，要记得排序（我就是这样在一道红题WA了两次的QAQ，真的是天下最弱了）

贴代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100010;
int n,m,a[N],q[N],fp=1,rp;
long long ans;
int main()
{
	scanf("%d%d",&n,&m);ans=0;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1);//千万别忘了排序！！！ 
	for(int i=1;i<=n;i++)
	{
		while(fp<=rp&&q[fp]+m<a[i])ans=ans+rp-fp,fp++;//将不合要求的队首出队，同时更新答案 
		q[++rp]=a[i];//将当前数入队 
	}
	int t=rp-fp+1;ans=ans+(long long)t*(t-1)/2;//最后队列里会剩下一些数，别忘了处理 
	printf("%lld\n",ans);return 0;
}
```

---

## 作者：嚯呀嚯呀 (赞：0)

其实这题有O(n)的做法的，用不到之前dalao说的二分啊之类的......

首先先把位置排序(我一开始以为是默认有序的，结果WA)

然后先处理第1头奶牛向右最多能让第几头奶牛听到，记录指针p，和答案ans

然后枚举每一头奶牛，因为排过序了，所以第1头奶牛能传出去的后面的奶牛肯定也能传到，只要在p的基础上继续向后扩展就可以了

注意一个特殊情况，如果一个奶牛不能向右传出去到任何一个奶牛(就是它后面的奶牛都离它巨远)，这时候p要指向下一头奶牛，不然会出现p<枚举的i的情况，出现错误

Code(Pascal 福利！！)：
```
var
  ans:int64;
  d,i,j,m,n,k,p:longint;
  a:array[0..1000005]of longint;
procedure qs(l,r:longint);
var
  i,j,mid,a1:longint;
begin
  i:=l; j:=r;
  mid:=a[(l+r) div 2];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if not(i>j) then
      begin
        a1:=a[i]; a[i]:=a[j]; a[j]:=a1;
        inc(i); dec(j);
      end;
  until i>j;
  if i<r then qs(i,r);
  if l<j then qs(l,j); 
end;
begin
  readln(n,d);
  for i:=1 to n do
    read(a[i]);
  qs(1,n);//好羡慕你们C++啊
  for i:=2 to n do
    begin
      if a[i]-a[1]<=d then
        inc(ans)
      else
        begin
          p:=i-1; break;
        end;
    end;
  for i:=2 to n do
    begin
      //ans:=ans+p-i;
      while (p+1<=n)and(a[p+1]-a[i]<=d) do
        inc(p);
      ans:=ans+p-i;
      if p=i then p:=i+1;
    end;
  writeln(ans);
end.


```

---

## 作者：moongazer (赞：0)

其实直接模拟就能过，然而我还是蒟蒻地写了二分。

每次枚举每一个数，然后二分查找第一个比a[i]+d大的数，具体看代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
using namespace std;
int a[1000005];
int main(){
    int n,m,i,ans=0,L,M,R;//这里把题目中的d改成了m
    cin>>n>>m;
    for(i=1;i<=n;i++){
        cin>>a[i];
    }//输入
    sort(a+1,a+n+1);//先要排序
    for(i=1;i<n;i++){
        L=i;
        R=n;//二分初始化
        while(L<=R){
            M=(L+R)/2;
            if(a[M]>a[i]+m){
                R=M-1;
            }else{
                L=M+1;
            }
        }//二分第一个比a[i]+d还大的数的序号
        ans+=(L-i-1);//将ans加上二分出的数与当前数中隔了几个数
    }
    cout<<ans<<endl;//输出
    return 0;
}
```

---

## 作者：McGrady (赞：0)

题解全是最坏情况为O(nlogn+n^2)的算法，很容易被卡掉啊

我给一个O(nlogn+n)的算法

先排序，但后来扫描的时候j不需要每次从i+1开始，比如1可以传到2,3,4,5，那么2一定能传到3,4,5，就不用再判断了，只要把j向后移就行了

所以就有了一个O(n)的扫描算法（好像看上去有点类似尺取）

代码(pascal党表示没有stl的sort，还要手写快排)：

```cpp
program rrr(input,output);
var
  a:array[0..1000000]of longint;
  i,j,n,d,ans:longint;
procedure sort(q,h:longint);
var
  i,j,x,t:longint;
begin
   i:=q;j:=h;x:=a[(i+j)>>1];
   repeat
     while a[i]<x do inc(i);
     while x<a[j] do dec(j);
     if i<=j then
        begin
           t:=a[i];a[i]:=a[j];a[j]:=t;
           inc(i);dec(j);
        end;
   until i>j;
   if j>q then sort(q,j);
   if i<h then sort(i,h);
end;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n,d);
   for i:=1 to n do read(a[i]);
   sort(1,n);
   ans:=0;
   j:=1;
   for i:=1 to n-1 do
      begin
         while (a[j+1]-a[i]<=d) and (j<n) do inc(j);
         ans:=ans+j-i;
      end;
   write(ans);
   //close(input);close(output);
end.
```

---

## 作者：felixwu (赞：0)

看到这种题，就要想到队列（毕竟海港都是用队列）。
简单的来说，就是用尺举法。
OK，代码（好看版）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int q[1000001];
int a[1000001],n,k,r=1,l=1,ans,d;
void push(int x)
{
	r++;
	q[r]=x;
}
void pop()
{
	l++;
}			//两个基本操作，不说了
int main()
{
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	q[r]=a[1]; 
	for(int i=2;i<=n;i++){
		push(a[i]);//入队
		k++;
		while (abs(q[l]-q[r])>d){//没有响应，出队
			pop();
			k--;
		}
		ans+=k;//累计结果
	}
	printf("%d",ans);
    return 0;
}
```
再来一个压行板：
```cpp
#include<bits/stdc++.h>
using namespace std;
int q[1000001],a[1000001],n,k,r=1,l=1,ans,d;
int main()
{
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);q[1]=a[1]; 
	for(int i=2;i<=n;i++){
		q[++r]=x;k++;
		while (abs(q[l]-q[r])>d)l++,k--;
		ans+=k;}
	printf("%d",ans);
    return 0;
}
```

---


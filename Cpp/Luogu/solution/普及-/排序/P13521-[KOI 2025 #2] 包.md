# [KOI 2025 #2] 包

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

商户是在 KOI 市经营商店的一位市民。商户的店里有 $N$ 件商品，其中第 $i$ 件商品的重量为 $A_i$。商户收到了情报，得知小偷“金基范”正觊觎自己的店铺，于是他准备采取措施，将损失降到最低。

小偷金基范计划从店里偷走 $K$ 件商品。但如果商品太重，不仅难以偷窃，被警察抓住的可能性也会变高。因此，小偷金基范会**最小化**他所偷商品的总重量。不过，如果店里的商品总数不足 $K$ 件，小偷金基范会偷走店里所有的商品。

在小偷金基范到达店铺之前，商户会把店里的一些商品装进一个包里带走。之后，小偷金基范会对商户没有带走的那些商品，以上述方式实施盗窃。商户希望通过合理地往包里装商品，来**最大化**小偷金基范最终偷走的商品总重量。

商户的包能承受的重量是有限的。当给定一个最大承重 $C$ 时，请对所有的 $x = 1, 2, \ldots, C$ 回答以下问题：

*   在商户能放入包中的商品总重量不超过 $x$ 的条件下，小偷金基范偷走的商品总重量的最大值是多少？

## 说明/提示

### 限制条件

*   所有给定的数都是整数。
*   $1 \le K \le N \le 5\,000$
*   $1 \le C \le 1\,000\,000$
*   对于所有 $i$ ($1 \le i \le N$)，满足 $1 \le A_i \le 1\,000\,000$

### 子任务

1.  (13 分) $N \le 10, A_i \le 10\,000, C \le 10\,000$
2.  (17 分) $N \le 80, A_i \le 10\,000, C \le 10\,000$
3.  (23 分) $A_i \le 10\,000, C \le 10\,000$
4.  (16 分) $K = 1$
5.  (31 分) 无额外限制条件。

## 样例 #1

### 输入

```
5 1 6
1 2 3 4 5```

### 输出

```
2
2
3
3
3
4```

## 样例 #2

### 输入

```
5 2 5
2 3 5 7 11```

### 输出

```
5
8
8
8
12```

## 样例 #3

### 输入

```
3 2 3
1 1 7```

### 输出

```
8
8
8```

# 题解

## 作者：chen_zhe (赞：5)

### 子问题 1

通过回溯法，枚举所有放入背包的物品的组合。对于每种情况 $S$：
*   计算放入背包的物品的重量总和 ($A_S$)
*   计算小偷拿走剩余物品时的重量总和 ($B_S$)

可以将所有 $2^N$ 种情况的结果都存储在一个数组中。对于每个 $x$，问题的答案就是在满足 $A_S \le x$ 的所有 $S$ 中，$B_S$ 的最大值。时间复杂度为 $O(2^N \cdot C)$。

### 子问题 2

首先，将输入的所有物品按重量升序排序。在这种情况下，小偷会偷走我没有选择的物品中，最先出现的最多 $K$ 个物品。

我们使用动态规划。定义 `dp[i][j][w]` = (在前 $i$ 个物品中决定是否放入背包，小偷已经拿了 $j$ 个物品，且目前背包内物品总重量不超过 $w$ 时，小偷能偷走物品的最大重量)。那么：
*   将第 $i+1$ 个物品放入背包的情况：状态转移到 `dp[i+1][j][w + A_{i+1}]`。
*   不将第 $i+1$ 个物品放入背包的情况：如果小偷偷走的物品少于 $K$ 个，则状态转移到 `dp[i+1][j+1][w]`，并且小偷额外偷走了重量为 $A_{i+1}$ 的物品。否则，状态转移到 `dp[i+1][j][w]`，小偷没有额外偷走物品。

对于每个 $x$，计算当 $i = N, 0 \le j \le K, w = x$ 时，`dp[i][j][w]` 的最大值即可。时间复杂度为 $O(N \cdot K \cdot C)$。

### 子问题 3

物品已经按重量排序，且小偷会从最轻的物品开始偷。因此，对于某个下标 $0 \le i \le N$，小偷会偷走所有下标不大于 $i$ 且未放入背包的物品，而不会偷走下标大于 $i$ 的物品。当我们固定这个下标 $i$ 时，为了最大化小偷偷走的物品重量总和：

*   在 $1, 2, \dots, i$ 号物品中，必须精确地将 $i - K$ 个物品放入背包。
*   放入背包的物品总重量必须不大于 $x$，且应尽可能小。

如果能满足上述条件，将总重量为 $w \le x$ 的物品放入背包，那么小偷就能偷走总重量为 $\sum_{j=1}^{i} A_j - w$ 的物品。

“精确地放入 $i-K$ 个物品”这一条件，可以放宽为“放入至少 $i-K$ 个物品”。虽然也需要考虑小偷拿走下标大于 $i$ 的物品的情况，但这种情况只会得到一个不大于实际小偷能偷走重量的值，因此不会产生问题。

现在使用动态规划。定义 `dp[i][w]` = (在前 $i$ 个物品中决定是否放入背包，且目前放入背包的物品总重量不超过 $w$ 时，背包中物品的最大数量)。对于每个 $x$，计算当 $0 \le i \le N, w = x$ 时 `dp[i][w]` 的最大值即可。时间复杂度为 $O(N \log N + NC)$。

### 子问题 4

小偷只偷一件物品。为了让小偷偷走第 $1 \le i \le N$ 号物品，必须满足 $\sum_{1 \le j \le i-1} A_j \le x$。我们对 $x=1,2,\dots,C$ 都求出满足此条件的最大 $i$ 即可。随着 $x$ 的增加，最大的 $i$ 也会增加，因此可以通过维护当前的最大 $i$ 和 $\sum_{1 \le j \le i-1}$（使用双指针）来解决问题，时间复杂度为 $O(N \log N + C)$。

### 子问题 5

整个问题可以使用贪心算法来解决。可以观察到以下两点：

*   没有必要拿超过 $N-K$ 个物品：如果多拿了一个物品，可以从背包中取出，让小偷拿走。
*   没有必要不拿第 $i$ 个物品而拿第 $i+1$ 个物品：如果用第 $i$ 个物品替换背包中的第 $i+1$ 个物品，背包的总重量不变或减少，而小偷拿走的物品总重量不变或增加。（即第 $i+1$ 个物品的位置由第 $i$ 个物品替代）

根据这两个条件，我们知道应该拿的物品是重量最轻的 $i$（$0 \le i \le N-K$）个。当我们拿走这些物品时，小偷会拿走第 $i+1, i+2, \dots, i+K$ 号物品。也就是说，对于每个 $x$，我们求出满足 $\sum_{1 \le j \le i} A_j \le x$ 的最小 $i$，然后输出第 $i+1, i+2, \dots, i+K$ 号物品的重量总和。前半部分与子问题 4 相同，后半部分使用前缀和即可。整个问题可以在 $O(N \log N + C)$ 内解决。

```cpp
#include <bits/stdc++.h>
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
#define cr(v, n) (v).clear(), (v).resize(n);
using namespace std;
using lint = long long;
using pi = array<lint, 2>;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n, k, c;
	cin >> n >> k >> c;
	vector<lint> a(n);
	for (int i = 0; i < n; i++)
		cin >> a[i];
	sort(all(a));
	a.insert(a.begin(), 0);
	for (int i = 1; i <= n; i++)
		a[i] += a[i - 1];
	int j = 0;
	for (int x = 1; x <= c; x++) {
		while (j < n - k && a[j + 1] <= x)
			j++;
		cout << a[j + k] - a[j] << "\n";
	}
}
```

---

## 作者：_Null_Ptr (赞：3)

贪心加前缀和，首先将商品按重量从小到大排序，因为商户应优先考虑带走较轻的商品，以迫使小偷选择更重的商品。
由于要快速计算任意区间内商品的总重量，所以计算要计算前缀和。然后模拟小偷能取商品的数量既可以。

具体实现详见代码。

```python
import sys
input = sys.stdin.read().split()
idx = 0
N = int(input[idx]); idx += 1
K = int(input[idx]); idx += 1
C = int(input[idx]); idx += 1
A = list(map(int, input[idx:idx+N]))
A.sort()
sump = [0] * (N + 1)
for i in range(N):
    sump[i+1] = sump[i] + A[i]
tot = sump[N]
val = [0]*(N + 1)
for t in range(N + 1):
    ys = N - t
    if ys <= K:
        val[t] = tot - sump[t]
    else:
        val[t] = sump[t + K] - sump[t]

max_val = [0] * (N + 1)
max_val[0] = val[0]
for t in range(1, N + 1):
    max_val[t] = max(max_val[t-1], val[t])
summ = sump+[float('inf')]
out = []
for i in range(N + 1):
    L = summ[i]
    R = summ[i + 1]
    x_st = max(L, 1)
    x_end = min(R - 1, C)
    if x_st > x_end:
        continue
    out.append(f"{max_val[i]}\n"*(x_end - x_st + 1))
print(''.join(out), end='')
```

---

## 作者：ryf2011 (赞：2)

# 0.更新日志
- 2025.8.3：修正了一处笔误，并修改、润色内容。

# 1.题目思路
由于小偷会取 $K$ 个数且和最小，我们容易想到排序。先将原数列排序，此时前 $K$ 个数即为最小和。

但是，商户每次还会取出若干个（可能为零）物品装入包中。什么时候答案最大呢？

我们考虑维护一个指针 $l$，指向当前商户决定是否带走的物品（在 $l$ 之前的物品一定会选，否则将留下小的数，不优），由于背包的容量是有限的，我们考虑把物品尽量装入背包，由于我们已经对数列排序，那么后面的数一定比前面的数大，所以答案更优。

但是，这个方法无法通过样例#3！为什么呢？考虑样例#3中，$x = 2$ 时，显然只装入第 $1$ 个物品比装入前 $2$ 个物品更优，而按照我们的思路却选择了后者。

此时，我们发现，商户不一定要把包装满。

由于 $K$ 的值不变，我们可以提前计算出数列中每 $K$ 个数（即 $1 \sim K,2 \sim K+1,\cdots,N-K+1 \sim N$）的和，计算答案时，在保证装入背包的物品重量不超过当前容量上限的情况下（利用前缀和数组 $sum$ 解决，即 $\texttt{sum[l]}$），找到所有满足条件的选法中的最大值并输出。

:::warning[本题数据范围]{open}
> 十年OI一场空，（下一句你懂得）。

本题的前缀和数组，以及答案变量都需要开 $\texttt{long long}$！
:::

# 2.代码
注：代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int max_n=5005;
int n,k,c,a[max_n],l;
long long sum[max_n],ksum[max_n],ans; //开 long long！
int main(){
    scanf("%d %d %d",&n,&k,&c);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1); //排序
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+a[i]; //计算前缀和
    }
    for(int i=k;i<=n;i++){
        ksum[i]=sum[i]-sum[i-k]; //K个数的和
    }
    for(int i=1;i<=c;i++){
        while(sum[l]<=i&&l<=n-k){ //保证满足条件时，计算最大值（注意一开始也有可能选 0 个）
            ans=max(ans,ksum[l+k]);
            l++; //指针
        }
        printf("%lld\n",ans); //输出
    }
    return 0;
}
```

# 3.后记
更多内容，请移步至：

1. [$\color{red}\texttt{Luogu ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")；
2. [$\color{orange}\texttt{cnblogs（博客园） cnblogs2011ryf}$](https://www.cnblogs.com/cnblogs2011ryf)。

---

## 作者：jsisonx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13521)

# 题目分析

首先考虑以什么规则装商品。先对所有商品按重量从小到大排序。设第 $i$ 个商品重量为 $h_i$。如果商品足够多，我们应该从重量最小的开始装，直到装不下为止。证明：由于商品足够多，小偷又总选择总重量最小的偷，因此小偷会偷掉剩余商品中重量前 $K$ 小的。现在假设从重量最小的开始装，装到第 $t$ 个后就装不下第 $t+1$ 个了。此时商户拿走了前 $t$ 个。接着，商户从他装走的 $t$ 个商品中拿出了一个放了回去，换成了一个更重的（假设还装的下），设把一个重量为 $h_x$ 的商品换成了重量为 $h_y$ 的商品（$h_x<h_y$）。则小偷偷走的商品重量减去了 $h_y$，加上了 $h_x$，显然小于原重量。这就证明了这种装法的最优性。若商品数量不够多，就不能装到装不下为止了，此时应适当的装，让小偷拿走最后 $k$ 个即可。对于 $t$ 的计算，可以使用二分使用前缀和数组 $S$ 存储前 $i$ 个商品的重量和，二分找到最靠右满足 $S_i\le c_0$ 的位置（其中 $c_0$ 表示当前包可装的最大重量），该位置就是 $t$。

### 无法通过的代码

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int n,k,c;
int h[N];
long long sum[N]={0};
int main(){
    cin>>n>>k>>c;
    for(int i=1;i<=n;i++){
        cin>>h[i];
    }
    sort(h+1,h+1+n);
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+h[i];
    }
    for(int i=1;i<=c;i++){
        int t=upper_bound(sum+1,sum+1+n,i)-sum;
        if(t+k-1<=n){
            cout<<sum[t+k-1]-sum[t-1]<<endl;
        }
        else{
            cout<<sum[n]-sum[n-k]<<endl;
        }
    }
    return 0;
}
```
如果提交上面这段代码，会获得[69分](https://www.luogu.com.cn/record/228192265)的分数，原因是超时。所以我们需要优化常数。常见的优化常数有很多种方式，这里讲一个十分有效的方法：快读和快写（了解快读快写的读者可跳过这一段）。

快读快写的基本思路是将数字的读入与输出转化为字符的读入与输出。其中的原理是读入数字时输入流需要将读入的数字字符序列转换为二进制数值，输出数字时需将二进制数值转换为数字字符序列。这些步骤都十分耗时，而输入输出字符可以省去二进制转换这一步，因此速度更快。同时，在快读中加入位运算也可以加速运算。详细内容见代码。

### 快读模板（读入正整数）

```cpp
inline long long read(){
    long long x=0;
    char ch=getchar();
    while(ch>='0'&&ch<='9'){//判断是否为数字，如果是空格或是换行符意味着一个数字输完了。
        x=(x<<1)+(x<<3)+(ch^48);//x<<1表示x*2,x<<3 表示x*8，相加即为x*10。ch^48即为ch-'0'，这样写等价于常见的x*10+ch-'0'，位运算可以使速度更快。
        ch=getchar();
    }
    return x;
}
```
### 快写模板（输出正整数）

```
inline void write(long long x){
    if(x>9){
        write(x/10);//递归，将x的每一位以字符的形式放入系统栈返回时依次输出。
    }
    putchar(x%10+'0');
    return;
}
```
使用快读快写优化，可以顺利通过此题。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int n,k,c;
long long h[N];
long long sum[N]={0};
inline long long read(){
    long long x=0;
    char ch=getchar();
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
inline void write(long long x){
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int main(){
    n=read();k=read();c=read();
    for(int i=1;i<=n;i++){
        h[i]=read();
    }
    sort(h+1,h+1+n);
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+h[i];
    }
    for(int i=1;i<=c;i++){
        int t=upper_bound(sum+1,sum+1+n,i)-sum;
        if(t+k-1<=n){
            write(sum[t+k-1]-sum[t-1]);
            printf("\n");
        }
        else{
            write(sum[n]-sum[n-k]);
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：tujiaqi12 (赞：1)

## 前置知识
[前缀和](https://blog.csdn.net/qq_61840254/article/details/145642327)，
[sort排序](https://blog.csdn.net/qq_34410710/article/details/147930005)。
## 思路

$tot$ 为商户最多能带走的物品数。

商户最希望小偷把最重的 $k$ 样东西偷走。所以若 $tot + k > n$，直接返回最重的 $k$ 样东西的总重。

否则商户先把最轻的 $tot$ 件带走，直接返回剩下的最轻的 $k$ 样东西的总重。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n,k,c;
ll a[10005];//重量
ll f[10005];//前缀和 
int main(){
	scanf("%lld%lld%lld",&n,&k,&c);
	for(ll i = 1;i <= n;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1);//从小到大排序
	for(ll i = 1;i <= n*2;i++){
		f[i] = f[i-1] + a[i];//求前缀和 
	} 
	ll tot = 0;//商户能拿几件物品
	ll y = 0;//剩余空间
	for(ll i = 1;i <= c;i++){
		y++;
		if(tot < n && y >= a[tot+1]){
			tot++;
			y -= a[tot];
		}
		ll ans;
		if(tot + k <= n){
			ans = f[tot + k] - f[tot];//a_tot+1 一直加到 a_tot+k的和
		}
		else{
			ans = f[n] - f[n - k];//a_n-k+1 一直加到 a_n的和
		}
		printf("%lld\n",ans);
	} 
	return 0;
}
```

---

## 作者：jiangyuan2011 (赞：0)

## 题目分析
在小偷到来之前，选择一些商品装进包里带走（总重量不超过 $x$），目标是让小偷偷走的商品总重量最大化，对于 $x$ 需要分别求出在小偷偷走的商品总重量的最大值。
## 解题思路
1. 小偷的行为模式：小偷总是从剩下的商品中选择最轻的 $K$ 件（或全部），因此商户的策略是带走最轻的商品，以保护较重的商品不被偷走。
2. 商户的最优策略：商户应优先带走最轻的商品，这样剩下的商品中较重的商品会被保留，从而让小偷偷走的总重量最大化。
## 代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, K, C;
    cin >> N >> K >> C;
    vector<int> A(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }

    sort(A.begin(), A.end());

    vector<long long> S(N + 1, 0);
    for (int i = 1; i <= N; ++i) {
        S[i] = S[i - 1] + A[i - 1];
    }

    vector<long long> max_theft(N + 1, 0);
    for (int t = 0; t <= N; ++t) {
        if (t + K <= N) {
            max_theft[t] = S[t + K] - S[t];
        } else {
            max_theft[t] = S[N] - S[t];
        }
    }

    vector<long long> prefix_max_theft(N + 1, 0);
    prefix_max_theft[0] = max_theft[0];
    for (int t = 1; t <= N; ++t) {
        prefix_max_theft[t] = max(prefix_max_theft[t - 1], max_theft[t]);
    }

    vector<long long> answer(C + 1, 0);
    for (int x = 1; x <= C; ++x) {
        int best_t = upper_bound(S.begin(), S.end(), x) - S.begin() - 1;
        if (best_t >= 0) {
            answer[x] = prefix_max_theft[best_t];
        } else {
            answer[x] = 0;
        }
    }

    for (int x = 1; x <= C; ++x) {
        cout << answer[x] << '\n';
    }

    return 0;
}
```
## 总结
本题通过排序、前缀和和预处理技术，高效地解决了商户与小偷之间的博弈问题。关键在于理解商户的最优策略是带走最轻的商品，从而最大化小偷偷走的总重量。预处理和二分查找的结合使得查询能够在合理的时间内完成。

---

## 作者：Clouds_dream (赞：0)

### 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P13521)

### 题目分析
我们希望小偷偷走的物品重量最大，那么商户拿走的物品质量一定要最小，这样可以迫使小偷去偷重量大的物品。  
我们将数组由小到大排序，带走前 $m$ 件物品，那么剩下的物品中前 $k$ 小的就是原序列中第 $m+1$ 到第 $m+k$ 大的商品。  
我们遍历每个物品，找到每个可能的 $m$ $(0 \le m \le n-k)$，计算带走前 $m$ 个商品的总重量，和剩下的前 $k$ 个商品的总重量。最后用前后缀优化即可。

### 代码实现
```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int N = 1e6+10, M = 1e8 + 10;

int n,k,c;
int a[N];
int s1[N],s2[N];
int ans[N];

signed main()
{
	fst
	cin>>n>>k>>c;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);
	for(int i=1;i<=n;i++){
		s1[i]=s1[i-1]+a[i-1];//前缀
	}
	for(int i=0;i<=n;i++){
		if(min(k,n-i)==0)s2[i]=0;
		else s2[i]=s1[i+min(k,n-i)]-s1[i];//后缀
	}
	for(int i=0;i<=n;i++){
		if(s1[i]>c)continue;
		if(s2[i]>ans[s1[i]])ans[s1[i]]=s2[i];//最大化前缀
	}
	for(int i=1;i<=c;i++){
		ans[i]=max(ans[i],ans[i-1]);
		cout<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

小偷会最小化偷的商品总重，说明小偷会偷走前 $K$ 小的所有商品，而商户不能让小偷得逞，所以商户会将重量小的商品拿走，拿到剩下 $K$ 个为止，因为如果再拿只会让小偷偷走的重量更小。先将数组排序，再新建一个下标 $p$，小偷当前能偷的最小重量的商品为 $A_p$，注意 $p$ 不能超过 $n-k+1$，也就是店里必须剩下至少 $K$ 个商品。维护一个前缀和就能 $O(1)$ 求出小偷能偷的最小重量了。

要在排序后求前缀和，不要像我一样贪方便在输入时就求，导致看半天看不出来错误。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[5005],fr[5005];
signed main()
{
	int n,k,c,p=1;
	cin>>n>>k>>c;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) fr[i]=fr[i-1]+a[i];
	for(int i=1;i<=c;i++)
	{
		while(fr[p]<=i&&p+k<=n) p++;
		cout<<fr[p+k-1]-fr[p-1]<<"\n";
	}
	return 0;
}
```

---


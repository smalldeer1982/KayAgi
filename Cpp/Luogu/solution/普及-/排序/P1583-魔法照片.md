# 魔法照片

## 题目描述

一共有 $n$ 个人（以 $1\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\bmod 10 +1$，显然类别序号的取值为 $1 \sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 20000$，$1\leq k\leq n$，保证所有数据均在 `int` 范围之内。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# 题解

## 作者：CreeperK (赞：219)

这道题真的很绕……我交了四五次才最终AC。

###题目实际上指的是先给定你1~n号对应的权值，从大到小排序后根据当前次序再编第二次号，分类别加上对应的e[i]，再次从大到小进行排序后输出前k大权值分别的初始编号。

##注意！第二次编号与最终的编号输出无关，仅用于分类。

###举个例子：

输入：（测试点#1）

14 3
9 2 5 4 0 0 0 0 0 0

1 1 3 4 9 2 8 2 8 8 8 7 1 9

编号为：1 2 3 4 5 6 7 8 9 10 11 12 13 14


第一次排序后：（序号小优先）

9 9 8 8 8 8 7 4 3 2 2 1 1 1

编号为：5 14 7 9 10 11 12 4 3 6   8 1 2 13

类别为：1 2   3 4 5   6   7   8 9 10 1 2 3 4

加上e[i]后：18 11 13 12 8 8 7 4 3 2 11 3 6 5


第二次排序后：（序号小优先）

18 13 12 11 11 8 8 7 6 5 4 3 3 2

编号为：5 7 9 8 14 10 11 12 2 13 4 1 3

输出：5 7 9

###这就是这道题大概的思路：输入——排号——排序——分类加e[i]——排序——输出

如果对上面的推导过程有什么疑问，可以自己动手尝试。

##最后附上代码，希望能帮到大家(｀・ω・´)：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int e[12],n,k;
struct person{
    int w;//权值 
    int num;//编号 
    int d;//类别 
}p[20010];//储存每个人的信息 
int w_comp(const person &a,const person &b){
    if(a.w!=b.w)return a.w>b.w;//从大到小排序 
    return a.num<b.num;//序号小优先 
}//结构体排序 
int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<10;i++)scanf("%d",&e[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].num=i+1;
    }//读入+编号 
    sort(p,p+n,w_comp);//第一次排序 
    for(int i=0;i<n;i++){
        p[i].d=i%10;//分类 
        p[i].w+=e[p[i].d];//加上e[i] 
    }
    sort(p,p+n,w_comp);//第二次排序 
    for(int i=0;i<k;i++)printf("%d ",p[i].num);
}
```

---

## 作者：Aehnuwx (赞：34)

看了各位红名的题解，微（苦）微（思）思（冥）索（想）后AC啦！

~~感觉其他大佬的代码有点长，我只有二十多行（也许是因为人家注释很多吧，本萌新自愧不如）~~

咳咳，话不多讲，立刻进入代码……

、、、cpp

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxN 20005
struct Node{
    int id,w;
}p[maxN]; //结构体，在排序时方便些
int n,k,E[11];
bool cmp(Node,Node); //排序的函数（其实可以用重载运算符，但我太懒）
int main(){
    scanf("%d%d",&n,&k); //输入
    for(int i=1;i<=10;i++) scanf("%d",&E[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].id=i+1;//由于我i是从0开始的，所以要加个1    
    } 
    sort(p,p+n,cmp); //sort函数，需带algorithm头文件（虽然我带的是万能头文件）。这是第一次排序
    for(int i=0;i<n;i++)
        p[i].w+=E[i%10+1];
    sort(p,p+n,cmp); //然后这就是第二次排序
    for(int i=0;i<k;i++) printf("%d ",p[i].id); //输出
    return 0;    
}
bool cmp(Node a,Node b){
    if(a.w==b.w) return a.id<b.id;
    return a.w>b.w;
}
```

---

## 作者：zhaowangji (赞：20)

题目不是很难，但错了好多次
# ~~都怪样例太狡猾~~

思路很简单，直接按照题意来就行了，但很容易被骗

代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,e[17],k;
struct node{
	int sum;
	int num;
}a[20007];
//方便用快排
bool cmp(node x,node y)
{
	if(x.sum!=y.sum) return x.sum>y.sum;
	else return x.num<y.num;
    	//规则：权值不一样按权值先大再小
        //否则按编号先小再大
        //再被坑了一次
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=10;i++)
	cin>>e[i];
	for(int i=1;i<=n;i++)
	cin>>a[i].sum,a[i].num=i;
	//记得额外权值数组要输入，被坑了一次
	sort(a+1,a+n+1,cmp);
	
	for(int i=1;i<=n;i++)
	a[i].sum+=e[(i-1)%10+1];
	//记得是按照编号来算出处在哪一个类别里
    	//又被坑了一次
	sort(a+1,a+n+1,cmp);
	
	for(int i=1;i<=k;i++)
	cout<<a[i].num<<' ';
    	//记得是输出编号
	return 0;
}
```


---

## 作者：BrainiX (赞：11)

本真·蒟蒻第二次借了豹子胆来写题解。

其实主要原因就是自己太菜了，写了半天一交结果WA了，绝望的看题解，却更绝望的发现各位神犇都是用的c++并且各种sort和struct溜得飞起，但是我才刚学c啊用不来怎么办，于是又想了半天才想出了这个lowB解法。所以本篇题解是留给那些和我一样不会结构体、不会快排的c宝宝的，大佬们自动无视就好。

也可能只有我还不会结构体了吧emmmm

```
#include <stdio.h>
#define MAX 20010

int e[11], w[MAX], d[MAX], t[MAX];
//e,w,d皆为题意中的E,W,D, t是一个零时数组，用来保证第一次排序时不改变w数组

int main(int argc, char const *argv[])
{
    int n, k;
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= 10; i++)
        scanf("%d", &e[i]);
    for(int i = 0; i < n; i++){
        scanf("%d", &w[i]);
        t[i] = w[i];//t里面存的其实就是w的数据
    }
    for(int i = 0; i < n; i++){
    	int max = i;
    	for(int j = 0; j < n; j++)
    		if(t[j] > t[max])
    			max = j;//选择排序的思想，但是为了保证w的数据不变，于是用t代替
    	d[max] = i;//max用来记录最大数的下标
    	t[max] = 0;//懒得写顺序交换，所以我就直接置零了，反正也都是正数
    }
    for(int i = 0; i < n; i++)
        w[i] += e[d[i]%10 + 1];
    for(int i = 0; i < k; i++){
        int max = 0;
        for(int j = 0; j < n; j++)
            if(w[j] > w[max])
                max = j;//还是一样的选择排序思想
        w[max] = 0;
        printf("%d ", max+1);
    }
    return 0;
}

```

---

## 作者：lyc_AFO (赞：9)

第一次发题解  求过QAQ




------------


阿西吧，这题真的有点~~复杂~~

题目读了好几遍，总算看懂了

可能是本蒟蒻太垃圾了

不过运气较好 第一次re 第二次就AC了

我的思路是：先按照权值排序，再求出对应的类别，而后加上额外值成为总分，再按照总分的大小排序，最后输出第k大的序号……

这道题有个比较黑的地方：编号和序号不一样！！！！！

编号：输进来时是第几位就是几

序号：按照初始权值排序得到的

我的方法稍微长了点，但应该比较~~易懂~~……

上代码：

```
#include <bits/stdc++.h>
using namespace std;
struct zp {
	int cs;//初始权值
	int bh;//初始编号
	int xh;//以大小排序后的编号
	int lb;//操作后的类别
	int zf;//总分
} s[20005];
int t[15];//用于存储额外权值的数组
int cmp(zp a,zp b) {//第一次排序
	if(a.cs!=b.cs) {
		return a.cs>b.cs; //初始权值不相等，从小到大拍
	} else {
		return a.bh<b.bh;//如果相等，编号小优先
	}
}
int cmq(zp a,zp b) {//第二次排序（滑稽的名字）
	if(a.zf!=b.zf){
		return a.zf>b.zf;//总分大优先
	}else{
		return a.bh>b.bh;//总分相等，编号优先 
	}
	
}
```


以上是主函数之前的七七八八

主要就是很垃圾的结构体以及排序函数

然后就是主函数

```
int main() {
	int n,k;
	cin>>n>>k; 
	for(int i=1; i<=10; i++) {   //输入额外权值  共十种 
		cin>>t[i];
	}
	for(int i=1; i<=n; i++) {    //输入初始权值  顺带确定编号 
		cin>>s[i].cs;
		s[i].bh=i;
	}
	sort(s+1,s+1+n,cmp);//第一次排序 排的是初始权值的大小 
	for(int i=1; i<=n; i++) {  
		s[i].xh=i; //注意：序号和编号不同 编号是初始编号 而序号是排序后的 
		s[i].lb=(s[i].xh-1)%10+1;//照抄题目中确定类别的操作 
	}
	for(int j=1; j<=n; j++) {
		for(int i=1; i<=10; i++) {//双重for循环  第二层用来判定类别并加上相应的额外分数 形成总分 
			if(s[j].lb==i) s[j].zf=s[j].cs+t[i];
		}
	}
	sort(s+1,s+1+n,cmq);//第二次排序 将总分从大到小排序 
	for(int i=1; i<=k; i++) {
		cout<<s[i].bh<<" ";//输出前k个人的编号，注意，是编号！！！ 
	}
	return 0;
}

```


完整的代码：


```
#include <bits/stdc++.h>
using namespace std;
struct zp {
	int cs,xh,lb,bh,zf;
} s[20005];
int t[15];
int cmp(zp a,zp b) {
	if(a.cs!=b.cs) {
		return a.cs>b.cs;
	} else {
		return a.bh<b.bh;
	}
}
int cmq(zp a,zp b) {
	if(a.zf!=b.zf){
		return a.zf>b.zf;
	}else{
		return a.bh<b.bh;
	}
	}
int main() {
	int n,o;
	cin>>n>>o;
	for(int i=1; i<=10; i++) {
		cin>>t[i];
	}
	for(int i=1; i<=n; i++) {
		cin>>s[i].cs;
		s[i].bh=i;
	}
	sort(s+1,s+1+n,cmp);
	for(int i=1; i<=n; i++) {
		s[i].xh=i;
		s[i].lb=(s[i].xh-1)%10+1;
	}
	for(int j=1; j<=n; j++) {
		for(int i=1; i<=10; i++) {
			if(s[j].lb==i) s[j].zf=s[j].cs+t[i];
		}
	}
	sort(s+1,s+1+n,cmq);
	for(int i=1; i<=o; i++) {
		cout<<s[i].bh<<" ";
	}
	return 0;
}


```


好吧总算return 0了

第一次写题解 好方……

一定要过啊！！！









---

## 作者：P500 (赞：7)

这道题只是让你排两次序

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[30000],f[3000],e[1000];//a[]为权值，f[]为序号
bool cmp(int x,int y){
    return a[x]==a[y]?x<y:a[x]>a[y]; //本题排序规律
}
int main(){
    int i,j,k,n;
    cin>>n>>k;
    for(i=1;i<=10;i++) cin>>e[i];       //输入
    for(i=1;i<=n;i++)  cin>>a[i],f[i]=i;//输入+初始化
    sort(f+1,f+n+1,cmp);                  //排序
    for(i=1;i<=n;i++)a[f[i]]+=e[(i-1)%10+1]; //这是题目要求
    sort(f+1,f+n+1,cmp);                 //再排序
    for(i=1;i<=k;i++) cout<<f[i]<<" ";//输出
}
```

---

## 作者：wucstdio (赞：6)

其实这道题和blash数集很相似的，就是把两个队列换成了十个……（好艰难……）

具体思路如下：

1、输入后编好号，用sort排序。（使用了读入优化，不用也许也能过）

2、for循环依次枚举，加入十个队列中，并将权值加上e。（再排一遍有点浪费时间，于是加入队列，这样每个队列都是有序的）

3、for循环从1到k，每一层循环从十个队列的队首中挑出一个权值最大的加入a数组。（可以证明每一次选的元素都是余下的元素中最大的，因为队列是有序的）

4、输出。

其实思路很简单，但程序实现需要注意n个细节……上代码！

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct people
{
    int m;//初始编号
    int w;//权值
}a[20005],queue[15][20005];
int e[15],front[15],rear[15],n,k;
inline int read()//读入优化
{
    char c=getchar();
    bool flag=1;
    int t=0;
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')
    {
        flag=0;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        t=t*10+c-'0';
        c=getchar();
    }
    return flag?t:-t;
}
bool cmp(people a,people b)
{
    return a.w>b.w||(a.w==b.w&&a.m<b.m);//如果权值不同，权值较大的在前；若相同，编号小的在前。
}
int main()
{
    n=read();
    k=read();
    for(int i=1;i<=10;i++)
      e[i]=read();
    for(int i=1;i<=n;i++)
    {
        a[i].w=read();
        a[i].m=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        int c=(i-1)%10+1;类别号码
        queue[c][rear[c]]=a[i];
        queue[c][rear[c]++].w+=e[c];
    }
    for(int i=1;i<=k;i++)//因为选k个人，所以只要循环到k就可以了
    {
        int maxw=0,maxq,maxm;//记录最大权值、编号和队列序号
        for(int j=1;j<=10;j++)
            if(maxw<queue[j][front[j]].w||(maxw==queue[j][front[j]].w&&maxm>queue[j][front[j]].m))//如果权值不同，权值较大的在前；若相同，编号小的在前。
            {
                maxw=queue[j][front[j]].w;
                maxm=queue[j][front[j]].m;
                maxq=j;
            }
        a[i]=queue[maxq][front[maxq]++];加入a数组
    }
    bool flag=0;//万一输入是0 0呢？（被坑不止一次）
    for(int i=1;i<=k;i++)
    {
        printf("%d ",a[i].m);
        flag=1;
    }
    printf("\n");
    return 0;
}
```

---

## 作者：肥婆纳妾 (赞：5)

### 乱用 STL 瞎 ** 做
#### 解题步骤：
##### 先对权值 排序(绑定编号)，然后分类 加上E[i]，再次排序（同样绑定编号）
##### 最后找到前 k 个进行打印 即可

#### 题目描述
一共有n（n≤20000）个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。

#### 输入输出格式
#### 输入格式：
第一行输入用空格隔开的两个整数，分别是n和k。

第二行给出了10个正整数，分别是E[1]到E[10]。

第三行给出了n个正整数，第i个数表示编号为i的人的权值W[i]。

#### 输出格式：
只需输出一行用空格隔开的k个整数，分别表示最终的W[i]从高到低的人的编号。

#### 输入输出样例
#### 输入样例#1： 
##### 10 10
##### 1 2 3 4 5 6 7 8 9 10
##### 2 4 6 8 10 12 14 16 18 20
#### 输出样例#1： 
##### 10 9 8 7 6 5 4 3 2 1

### CODE:↓↓
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    map<int,vector<int>>data;
    int n,k,E[10],w,count=0;
    cin>>n>>k;
    for(int i=0;i<10;cin>>E[i++]);
      for(int i=0;i<n;++i){		//权 排
        cin>>w;
        data[w].push_back(i+1);
    }
    map<int,vector<int>>newData;
    for(auto ritor=data.rbegin();ritor!=data.rend();++ritor){
        for(int i=0;i<ritor->second.size();++i)
        	newData[ritor->first+E[(count++)%10]].push_back(ritor->second[i]);
    }
    for(auto ritor=newData.rbegin();ritor!=newData.rend();++ritor){
        sort(ritor->second.begin(),ritor->second.end());
        for(int i=0;i<ritor->second.size();++i){
            cout<<ritor->second[i]<<" ";
            if(0==--k)
                return 0;
        }
    }
    return 0;
}
```

---

## 作者：0x460c34 (赞：3)


------------
~~我看到了好多用sort的人，但是我想用手撸的qsort来实现，方便理解实现的原理，下面我们来看看。~~
#
本题采用多关键字快排，**解法不重复** **求通过**
##
首先，题目的意思就是 排序 加值后 排序
关键是排序，这需要我们写一个多关键字排序
###
我先写了一个冒泡排序的写法
~~//或者写成选择排序也行，这样写只是用来理解题意的，不能够AC~~


------------

```cpp
#include<iostream>
using namespace std;
int a[20001][3],n,k,e[11];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=10;++i)
		cin>>e[i];
	for(int i=1;i<=n;++i)
	{
		a[i][0]=i;
		cin>>a[i][1];
	}
	for(int i=1;i<n;++i)
		for(int j=1;j<=n-i;++j)
		{
			if(a[j][1]<a[j+1][1])
				{
					swap(a[j][0],a[j+1][0]);
					swap(a[j][1],a[j+1][1]);
				}
			else
				if(a[j][1]==a[j+1][1])
				{
					if(a[j][0]>a[j+1][0])
						{
							swap(a[j][0],a[j+1][0]);
							swap(a[j][1],a[j+1][1]);
						}
				}
		}
	for(int i=1;i<=n;++i)
		a[i][1]+=e[(i-1)%10+1];
	for(int i=1;i<n;++i)
		for(int j=1;j<=n-i;++j)
		{
			if(a[j][1]<a[j+1][1])
				{
					swap(a[j][0],a[j+1][0]);
					swap(a[j][1],a[j+1][1]);
				}
			else
				if(a[j][1]==a[j+1][1])
				{
					if(a[j][0]>a[j+1][0])
						{
							swap(a[j][0],a[j+1][0]);
							swap(a[j][1],a[j+1][1]);
						}
				}
		}
	for(int i=1;i<=k;++i)
		cout<<a[i][0]<<' ';
	return 0;
}
void swap(int &a,int &b)
{
	int t=a;
	a=b;
	b=t;
	return ;
}
```


------------

#
结果就是超时了嘛，时间复杂度为 O(N^2) // **TLE了** **难受**
##
我们就考虑到了用快排，时间复杂度为 O(logn) 关键是快排中间的 while里面怎么写
对于关键点左边，我们只需要找比他w[i]大的，当w[i]相等时找序号更小的
所以有 **//我用二维数组来储存数据 [0]储存序号 [1]储存 w[i] 的值**
###
while(a[i][1]>mid||(a[i][1]==mid&&a[i][0]<mid_n))
		i++;//这个式子理解，就可以搞定了
对于关键点右边同理
####


------------

```cpp
#include<iostream>
using namespace std;
int a[20001][2],n,k,e[11];
void qsort(int ,int ,int [][2]);
void swap(int &,int &);
int main()
{
	cin>>n>>k;
	for(int i=1;i<=10;++i)
		cin>>e[i];
	for(int i=1;i<=n;++i)
	{
		a[i][0]=i;
		cin>>a[i][1];
	}
	qsort(1,n,a);  
	for(int i=1;i<=n;++i)
		a[i][1]+=e[(i-1)%10+1];
	qsort(1,n,a);
	for(int i=1;i<=k;++i)
		cout<<a[i][0]<<' ';
	return 0;
}
void qsort(int l,int r,int a[][2])
{
	int i=l,j=r,mid,mid_n;
	mid=a[(l+r)/2][1];
	mid_n=a[(l+r)/2][0];
	while(i<=j)
	{
		while(a[i][1]>mid||(a[i][1]==mid&&a[i][0]<mid_n))
		i++;
		while(a[j][1]<mid||(a[j][1]==mid&&a[j][0]>mid_n))
		j--;
		if(i<=j)
		{
			swap(a[i][1],a[j][1]);
			swap(a[i][0],a[j][0]);
			i++;
			j--;
		} 
	} 
	if(l<j) qsort(l,j,a);
	if(i<r) qsort(i,r,a);
}
void swap(int &a,int &b)
{
	int t=a;
	a=b;
	b=t;
	return ;
}
```


------------


---

## 作者：微香玉烛暗 (赞：3)

这道题很毒瘤，普及-的题目我居然做了——
##### 一个半小时！?

思路很简单，用结构体进行一波操作。。。

上代码：

（有解释）

```cpp
#include<cstdio>
#include<string>
#include<algorithm>
using namespace std;

int n,k,e[15];//变量……
struct st{
    int num,sum;
}a[20005];//先定义结构体

int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar())
    x = x * 10 + ch - '0';
    return x * f;
}//快读，应该不用结束了吧。。

bool cmp(st x,st y)//compare排序函数
{
    if (x.sum!=y.sum) return x.sum>y.sum;//这很重要！
    //判断是用sum排序还是用num下标排序
    else return x.num<y.num;
}

int main()
{
    n=read();
    k=read();//我最爱快读了！
    for (int i=1;i<=10/*只有10个数*/;i++)
    	e[i]=read();//数组读入
    for (int i=1;i<=n;i++)
    {
        a[i].sum=read();//读入的是sum
        a[i].num=i;//下标是num
    }
    sort(a+1,a+n+1,cmp);//一排
    for (int i=1;i<=n;i++)
    	a[i].sum+=e[(i-1)%10+1];//这一步是核心代码，请确保看明白！
    sort(a+1,a+n+1,cmp);//操作完后二排
    for (int i=1;i<=k;i++)
    	printf("%d ",a[i].num);//输出
    return 0;
    //并不怎么华丽地结束了。
}
```
供大家参考，题解求过！

谢谢支持！


---

## 作者：「QQ红包」 (赞：3)

pascal求解……

代码中用 b[i] 数组记录了第i个数字是多少

用 c[i] 数组记录了按照规则排序后第i大的数在b[]中的下标

然后快排

```delphi

var a,b,c:array[1..100000] of longint;
    n,i,k:longint;
procedure qsort(l,r:longint);//注意快排不仅仅是从小到大排a数组，还要考虑相等的情况……审清题的应该不会错……
var
 i,j,p,mid1,mid2:longint;
begin
 i:=l; j:=r;
 mid1:=a[(l+r) div 2];
 mid2:=c[(l+r) div 2];
 repeat
  while (a[i]>mid1) or ((a[i]=mid1) and (c[i]<mid2)) do inc(i);
  while (a[j]<mid1) or ((a[j]=mid1) and (c[j]>mid2)) do dec(j);
  if i<=j then
  begin
   p:=a[i];
   a[i]:=a[j];
   a[j]:=p;
   p:=c[i];
   c[i]:=c[j];
   c[j]:=p;
   inc(i); dec(j);
  end;
 until i>j;
 if l<j then qsort(l,j);
 if i<r then qsort(i,r);
end;

begin
    read(n,k);
    for i:=1 to 10 do
        read(b[i]);
    for i:=1 to n do 
       begin c[i]:=i; read(a[i]);
 end;    qsort(1,n);
     for i:=1 to n do a[i]:=a[i]+b[(i-1) mod 10+1];  qsort(1,n); 
    for i:=1 to k do
    write(c[i],' ');
end.
 
        

```

---

## 作者：杨柏涵 (赞：2)

这个题目的关键在于sort的比较函数，需要使得在权值相等的情况下，序号小的排在前面。对于N=20000的规模，STL的sort函数效率够用了，不需要另外优化排序算法。

下面是AC代码：

```cpp
// By Yangbohan 2019
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
struct t{
    int num;
    int w;
};
bool op(t a,t b){
    if(a.w!=b.w) return a.w>b.w;
    else return a.num<b.num;
}
vector<t> a;
int main(){
    int n,k;
    int e[11];
    cin>>n>>k;
    for(int i=1;i<=10;i++) cin>>e[i];
    t f;
    a.push_back(f);
    for(int i=1;i<=n;i++){
        t f;
        f.num=i;
        a.push_back(f);
        cin>>a[i].w;
    }
    sort(a.begin()+1,a.end(),op);
    for(int i=1;i<=n;i++){
        a[i].w+=e[(i-1)%10+1];
    }
    sort(a.begin()+1,a.end(),op);
    for(int i=1;i<=k;i++){
        cout<<a[i].num<<" ";
    }
    return 0;
}
```

---

## 作者：加减乘除 (赞：2)

	//看各位大佬们的题解，大部分是用C++中的sort函数实现的，身为菜鸟的我然而并不明白

	//改进版的堆排序。实际上改变排序条件就可以了  
	//------->详情请参考《算法导论》的相关章节  
	//经测试，算法性能不错，0ms无压力
	#include<stdio.h>
	int n,k;  
	int len,heap;//数组长度与堆的大小 
	int w[20001],d[20001],e[11];
	void chushihua(){  //初始化数组
    	int i;
    	for(i=1;i<=len;i++)d[i]=i;  
	}   
	void weihu(int i){//维护堆的性质
    //注意，比较顺序的方法有改变：先比较分数，再比较序号。分数由大到小，而序号由小到大，则构建的是“最小堆”。(相关概念请参照算法书籍)
    	int l,r,min,t;
    	l=i*2;r=l+1;
    	if(l>heap)return;
   	if(l<=heap){
        if(w[l]<w[i])min=l;
        else if(w[l]==w[i] && d[l]>d[i])min=l;
        else min=i;
    }
    if(r<=heap){
        if(w[r]<w[min])min=r;
        if(w[r]==w[min] && d[r]>d[min])min=r;
    }
    if(i!=min){
        t=w[min];w[min]=w[i];w[i]=t;
        t=d[min];d[min]=d[i];d[i]=t;
        weihu(min);
            }
    }
	void build(){       //构建堆
	int r;r=len/2;
	int i;
    for(i=r;i>=1;i--)weihu(i);
	}
	void heapsort(){//排序算法主
    build();
	int i,h;
	for(i=len;i>=2;i--){
    h=w[1];w[1]=w[i];w[i]=h;
    h=d[1];d[1]=d[i];d[i]=h;//交换序号与分数
    heap--;
    weihu(1);
		}
	}
	int main(){
	scanf("%d%d",&n,&k);
	heap=len=n;
	chushihua();
	int i,j;
	for(i=1;i<=10;i++)scanf("%d",&e[i]);
	for(i=1;i<=len;i++)scanf("%d",&w[i]);
	heapsort();
	//测试第一次
	/*
	printf("第一次排序后的序号：\n");
	for(i=1;i<=len;i++)printf("%d ",d[i]);
	printf("\n第一次排序后的值：\n");
	for(i=1;i<=len;i++)printf("%d ",w[i]);
	printf("\n");
	*/
	//第一次结束
	for(i=1;i<=len;i++){
    	j=(i-1)%10+1;
    	w[i]=w[i]+e[j];
	}
	heap=len=n;
	heapsort();
	//第二次测试
	/*
	printf("第二次排序后的序号：\n");
	for(i=1;i<=len;i++)printf("%d ",d[i]);
	printf("\n第二次排序后的值：\n");
	for(i=1;i<=len;i++)printf("%d ",w[i]);
	printf("\n");
	*/
	//第二次结束
	for(i=1;i<=k;i++)printf("%d ",d[i]);
	printf("\n");
	return 0;
	}
	//作为初学者，建议弄懂算法原理后再使用相关算法函数。


---

## 作者：0year (赞：1)

这道题相当的坑~~蒟蒻的感慨~~

一开始是按初始权值W[i]进行排序的，然而要考虑编号。我一开始写了两个compare，一个只根据全值大小不考虑编号，然后样例过了，提交之后发现只有一个AC...

代码还是挺简单的

------------

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,k,ans,E[10];
struct people{
    int W,D;
}; people p[20020];//结构体
bool cmp0(people x,people y){
    if(x.W!=y.W)return x.W>y.W;
    else return x.D<y.D;
}//排序用的compare
/*bool cmp(people x,people y){
    return x.W>y.W;
}这个没有用..*/
int main(){
    cin>>n>>k;
    for(int i=0;i<10;i++)cin>>E[i];
    for(int i=0;i<n;i++){cin>>p[i].W;p[i].D=i+1;}//这里的D是编号不是题目里的D.
    sort(p,p+n,cmp0);
    for(int i=0;i<n;i++){p[i].W+=E[i%10];}//类别编号直接合在一起写了
    sort(p,p+n,cmp0);
    for(int i=0;i<k;i++)
    cout<<p[i].D<<' ';
    return 0;
}
```


---

## 作者：wick (赞：1)

本蒟蒻的第2篇题解~~望众大佬笑纳~~






题目描述
一共有n（n≤20000）个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。






这道题大概的思路：输入赋初始权值W[i]——加号——排序*1——分类加额外得到E[i]的权值——排序*2——输出。



首先上一道10分代码：



```
#include<bits/stdc++.h>
using namespace std;
int n,m,b,l[15];
struct per{
	int num;
	int sc;
}a[50005];
bool cmp1(per a,per b){
	return a.sc>b.sc;
}
bool cmp2(per a,per b){
	if(a.sc>b.sc) return true;
	if(a.sc==b.sc&&a.num<b.num) return true;
	return false;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int j=1;j<=10;j++){
		scanf("%d",&b);
		l[j]=b;
	} 
	for(int j=1;j<=n;j++){
		scanf("%d",&a[j].sc);
		a[j].num=j;
	} 
	sort(a+1,a+n+1,cmp1);
	for(int j=1;j<=n;j++)a[j].sc+=l[(j-1)%10+1];
	sort(a+1,a+n+1,cmp2);
	for(int j=1;j<=m;j++) printf("%d ",a[j].num);
	return 0;
}


``

以上是运用了   结构体   排序.

不懂的同学可以理解为一个n维的数组，但你可以将其中的每一部分命名并调用。

10分代码有两个排序，显然与题中“在排序中，如果两人的W[i]相同，编号小的优先。”不符。

要将“cmp1”修改。

以下为100分代码
：


``
#include<bits/stdc++.h>
using namespace std;
int n,m,b,l[15];
struct per{//结构体
	int num;
	int sc;
}a[50005];
bool cmp(per a,per b){
	if(a.sc>b.sc) return true;
	if(a.sc==b.sc&&a.num<b.num) return true;
	return false;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int j=1;j<=10;j++){
		scanf("%d",&b);//输入赋初始权值W[i]
		l[j]=b;//加号
	} 
	for(int j=1;j<=n;j++){
		scanf("%d",&a[j].sc);
		a[j].num=j;
	} 
	sort(a+1,a+n+1,cmp);//排序*1
	for(int j=1;j<=n;j++)a[j].sc+=l[(j-1)%10+1];//分类加额外得到E[i]的权值
	sort(a+1,a+n+1,cmp);//排序*2
	for(int j=1;j<=m;j++) printf("%d ",a[j].num);//输出
	return 0;
}

```
希望能帮到大家(｀・ω・´)。










---

## 作者：limuloo (赞：1)

题目非常绕~WA了好多发才AC

首先先解释一下题目所说的“如果两人的W[i]相同，编号小的优先”中的编号是“输入”的时候按顺序给的编号，这里我们叫它为【初始编号】

加额外权值是按【第一次排序之后的序号】（而不是【初始编号】）来分类的

加上额外权值之后再进行一次排序（排序原则还是权值大在前，权值相同【初始编号】小在前）

输出排序后前K个人对应的【初始编号】

下面给出代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct node{   
	int number;
	int pow;
}; 
node a[20005];
int plus[11];
int n,k;
bool cmp(node a,node b){   //排序的比较函数 
	if(a.pow==b.pow) return a.number<b.number;  //权值相同   序号小的在前面 
	return a.pow>b.pow;     //权值不同  权值大在前 
}
int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=10;i++)  scanf("%d",plus+i);   //plus记录额外加权 
	for(int i=1;i<=n;i++){
		a[i].number=i;       
		scanf("%d",&a[i].pow);
	}
	sort(a+1,a+1+n,cmp); //第一次排序（注意此时没有加上额外权值） 
	for(int i=1;i<=n;i++)
		a[i].pow+=plus[(i-1)%10+1];   //加上额外权值 
	sort(a+1,a+1+n,cmp);      //第二次排序得到结果 
	for(int i=1;i<=k;i++) printf("%d ",a[i].number);
	return 0;
}
```

---

## 作者：90182si (赞：1)

这题超级坑啊，一开始过了10%，就是要注意其中两点（下方已标注）
我这里主要讲排序，用的是朴素快速排序，取中间值为基准，分别从两边找比他小的值和比他大的值，找到就进行交换。对编号排序需要当权值相等时才触发。
```cpp
#include <iostream>
using namespace std;
struct node{
	int number,n;
}W[20006],temp;
void Quicksort(node a[],int low,int high){
	int i=low,j=high,k=a[(i+j)/2].n,kk=a[(i+j)/2].number;
	while(i<=j){
		//朴素快速排序+判定条件
		while(i<high&&(a[i].n>k||(a[i].n==k&&a[i].number<kk)))i++;
		while(j>low&&(a[j].n<k||(a[j].n==k&&a[j].number>kk)))j--;
		if(i<=j)temp=a[i],a[i++]=a[j],a[j++]=temp;
	}
	if(i<high)Quicksort(a,i,high);
	if(low<j)Quicksort(a,low,j);
}
int main(){
    int i,n,m,E[11];
    cin>>n>>m;
    for(i=0;i<10;i++)cin>>E[i];//最主要的是这里1
    for(i=0;i<n;i++)cin>>W[i].n,W[i].number=i+1;
    Quicksort(W,0,n);
    for(i=0;i<n;i++)W[i].n+=E[i%10];//最主要的是这里2
    Quicksort(W,0,n);  
    for(i=0;i<m;i++)cout<<W[i].number<<" ";
    return 0;
}
```

---

## 作者：xukuan (赞：1)

模拟，排序，

注意数入e[i]时是：








```cpp
#for i:=1 to 10（不是n） do read(e[i]);  pas
#for(int i=1; i<=10（不是n）; i++)cin>>e[i];  cpp
{$IFDEF NORMAL}
  {$I-,OBJECTCHECKS-,Q-,R-,S-}
{$ENDIF NORMAL}
{$IFDEF DEBUG}
  {$I+,OBJECTCHECKS+,Q+,R+,S-}
{$ENDIF DEBUG}
{$IFDEF RELEASE}
  {$I-,OBJECTCHECKS-,Q-,R-,S-}
{$ENDIF RELEASE}//O^2优化即此
type
 magic=record
  d,w:longint;
end;
var
 i,n,k:longint;
 a:array[0..20010] of magic;
 b:array[0..20010] of longint;
procedure qsort(var a:array of magic; l,r:longint);//快速排序
 var
  i,j,x,y:longint;
  tmp:magic;
 begin
  i:=l; j:=r;
  x:=a[(i+j) div 2].w;
  y:=a[(i+j) div 2].d;
  repeat
   while (a[i].w>x) or (a[i].w=x) and (a[i].d<y) do inc(i);
   while (a[j].w<x) or (a[j].w=x) and (a[j].d>y) do dec(j);
   if i<=j then
    begin
     if i<>j then
      begin
       tmp:=a[i];
       a[i]:=a[j];
       a[j]:=tmp;
      end;
     inc(i);
     dec(j);
    end;
  until i>j;
  if l<j then qsort(a,l,j);
  if i<r then qsort(a,i,r);
end;
begin
 readln(n,k);
 for i:=1 to 10 do read(b[i]);
 for i:=1 to n do
  begin
   read(a[i].w);
   a[i].d:=i;
  end;
 qsort(a,1,n);//调用
 for i:=1 to n do inc(a[i].w,b[(i-1) mod 10+1]);//加余数权值
 qsort(a,1,n);//调用
 for i:=1 to k do write(a[i].d,' ');//输出
end.

```

---

## 作者：karma (赞：1)

//看了一下，似乎没有C的题解，因为高(wu)兴(liao)写个题解，神犇勿喷

```cpp
//思路：模拟加快排
#include<stdio.h>
#include<stdlib.h>
#define maxn 20000+10
typedef struct {
    int N;//初始序号(最终输出的序号)
    int W;//(初始权值)
}fuck; 
fuck data[maxn];//别在意名字(滑稽)
int n;//总人数
int k;//给的人数
int E[11];//额外权值
int cmp(const fuck*a,const fuck *b){
    if(a->W!=b->W)return b->W - a->W;
    else return a->N - b->N;
```
}//将初始(或之后权值)从大到小排序，若相等，将序号从小到大排序
```cpp
int main(){
    scanf("%d %d",&n,&k);//输入不解释
    for(int i=1;i<=n;i++)data[i].N=i;//赋予每人编号(即最终输出的编号)
    for(int i=1;i<11;i++)scanf("%d",&E[i]);//输入额外权值
    for(int i=1;i<=n;i++)scanf("%d",&data[i].W);//输入初始权值
    qsort(&data[1],n,sizeof(data[0]),cmp);//排序
//    for(int i=1;i<=n;i++)printf("%d %d\n",data[i].N,data[i].W);//检查排序结果
    for(int i=1;i<=n;i++)
        data[i].W+=E[(i-1)%10+1];//赋予每人额外权值
    qsort(&data[1],n,sizeof(data[0]),cmp);//排序
//    for(int i=1;i<=n;i++)printf("%d %d\n",data[i].N,data[i].W);//检查排序
    for(int i=1;i<=k;i++)printf("%d ",data[i].N);//输出编号
    return 0;
}
//谢谢阅读
```

---

## 作者：a710128 (赞：1)

c++题解

代码中用 sz[a] 数组记录了第a个数字是多少

用 id[b] 数组记录了按照规则排序后第b大的数在sz[]中的下标

利用cmp函数对id数组排序

```delphi

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int MaxN = 20000 + 10;
int n, k, E[11], sz[MaxN], id[MaxN];
bool cmp(int a,int b){return sz[a] > sz[b] || (sz[a] == sz[b] && a < b);}//按照题面规则排序 
int main()
{
    scanf("%d%d",&n,&k);
    for(int i = 1;i <= 10; ++i) scanf("%d",&E[i]);
    for(int i = 1;i <= n; ++i) scanf("%d",&sz[id[i] = i]);  //读入的同时对 id[] 数组复赋值
                                                            //初始 id[x] = x 
    sort(id + 1, id + n + 1, cmp);                            //利用 cmp 函数对数组id[]进行排序 
    for(int i = 1;i <= 10; ++i)                                //枚举 mod 10后的余数 
        for(int j = i; j <= n; j += 10)                        //修改所有 mod 10后余数相同的id 
            sz[id[j]] += E[i]; 
    sort(id + 1, id + n + 1, cmp);                            //再次排序 
    for(int i = 1;i <= k; ++i) printf("%d ",id[i]);            //输出 
    return 0;
}

```

---

## 作者：Sinwind (赞：0)

# 1.分析

1. 因为人的编号与总权重是统一的，需要同时使用，所以用结构体。

2. $sort$函数：

- 请参考[C++ STL之排序(sort)](https://www.luogu.org/blog/Singularwind/sort-algorithm#)。

- 本题中，需要对两种不同的情况进行排列，$compare$函数分为两种情况。

	- 当总权重相等时$(x.total\_weight==y.total\_weight)$，按编号升序排列$(return\space x.id<y.id)$。
    
    - 当总权重不等时$(x.total\_weight!=y.total\_weight)$，按总权重降序排列$(return\space x.total\_weight>y.total\_weight)$。

# 2.代码

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int total;          //总的人数
int num;            //选择人数
int other_num;      //与最后一名同分的格外人数
int else_weight[15];//格外权重
//要照片的人的结构体
struct People
{
	int id;         	//人的编号
	int total_weight; 	//总的权重
}people[20005];

//作为sort的第三个参数：
//若总权重相等，则按编号升序排列；
//若总权重不等，则按总权重降序排列。
bool compare(struct People x, struct People y)
{
	if(x.total_weight == y.total_weight)
	{
		return x.id < y.id;
	}
	else
	{
		return x.total_weight > y.total_weight;
	}
}

int main(void)
{
	//读入
	cin >> total >> num;
	for(int i = 1; i <= 10; i++)
	{
		cin >> else_weight[i];
	}
	for(int i = 0; i < total; i++)
	{
		people[i].id = i + 1;
		cin >> people[i].total_weight;
	}
	
	//第一次排序，得出序号D
	sort(people, people + total, compare);

	//加上格外权重
	for(int i = 0; i < total; i++)
	{
		people[i].total_weight += else_weight[i % 10 + 1];
	}
	
	//第二次排序，得出最终权重
	sort(people, people + total, compare);
	
	//输出结果
	for(int i = 0; i < num; i++)
	{
		cout << people[i].id << " ";
	}
	
	return 0;
}
```


---

## 作者：MRZMRZ (赞：0)

此题的题目描述非常清真，一般来说题目说什么，你就照着做即可。所以不存在思维难度和代码难度。但越是这样的题越要小心谨慎。以下是这道题的一些坑点：

1. 在排序中，如果两人的W[i]相同，编号小的优先。

2.  _序号_ 与 _编号_ 是完全不同的概念，详情见题目描述。

3. 注意排完序后，加的是 $E[($D[i]$-1)%10+1]$。$D[i]$表示 _序号_ 。我第一次交的时候不小心加了$($D[i]$-1)%10+1$，不得不说样例很坑。

4. 不要忘了$k$

希望对大家有帮助。

附上AC代码：
```cpp
//ZJ_MRZ's Code
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
#define N 20010
using namespace std;
struct mrz {
    int num,val;
} W[N];
long long E[11],n,k;
bool cmp(mrz k1,mrz k2) {//见注意点1
    if(k1.val!=k2.val) 
        return k1.val>k2.val;
    else
        return k1.num<k2.num;
}
int main() {
    scanf("%d%d",&n,&k);
    for(int i=1;i<=10;i++)
        scanf("%d",&E[i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&W[i].val),W[i].num=i;
    sort(W+1,W+n+1,cmp);
    for(int i=1;i<=n;i++)
        W[i].val+=E[(i-1)%10+1];//见注意点2、3
    sort(W+1,W+n+1,cmp);
    for(int i=1;i<=k;i++) printf("%d ",W[i].num);
    return 0;
}
```

---

## 作者：李曦来 (赞：0)

**这道题真的很绕……好久才AC**

但是思路很简单。

#### 题目意思：给你1~n所有对应的值并排序，再分别加上e[ 排序后的序号 %10]，最后再次排序并输出前k人的序号。



------------
源码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct p{
	int n,i;
}w[20000];
int e[10];
bool f(p x,p y){
	return(x.n!=y.n?x.n>y.n:x.i<y.i);
}
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=0;i<10;i++){
		cin>>e[i];
	}for(int i=0;i<n;i++){
		cin>>w[i].n;
		w[i].i=i+1;
	}
	sort(w,w+n,f);
	for(int i=0;i<n;i++){
		w[i].n+=e[i%10];
	}
	sort(w,w+n,f);
	for(int i=0;i<k;i++){
		cout<<w[i].i<<(i<k-1?' ':'\n');
	}
	return 0;
}
```

---

## 作者：ricky_lin (赞：0)

# 此篇用到结构体、排序（sort）
## 其实有点象模拟
## 主要还是要先理思路：
### 1.先得输入（决不能缺）
### 2.标号
### 3.排序
### 4.直接加E[i]（看程序就知道了）
### 5.排序
### 6.输出
#### 下面是代码：
```cpp
#include<cstdio>
#include<algorithm>//sort必备
using namespace std;
int n,k,e[11];
struct hehe{
	int w,n;
}a[20001];//4-7排为结构体定义
bool temp(hehe d,hehe b)
{
	if(d.w!=b.w)
	return d.w>b.w;
	else return d.n<b.n;
}//8-13排是sort中要用到的
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=10;i++)
		scanf("%d",&e[i]);//16-18排输入前两排（第一步）
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i].w);
		a[i].n=i;
	}//19-23排输入第三排+标号（第一步+第二步）
	sort(a+1,a+1+n,temp);//排序（第三步)
	for(int i=1;i<=n;i++)
	{
		a[i].w+=e[(i-1)%10+1];
	}//这层for中的i为题目中说的d则可知他的权值应加(i-1)%10+1
	sort(a+1,a+1+n,temp);//再排序（第5步）
	for(int i=1;i<=k;i++)
		printf("%d ",a[i].n);//最后的输出（第六步）
	return 0;//大家一定要养成打"return 0;"的习惯
} 
```

---

## 作者：小豆子范德萨 (赞：0)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 20000+10;
int E[11];
struct Node{
	int id1,id2;		//id1为初始的编号，id2为分类的编号 
	int num;
}a[maxn];

bool cmp(Node& a,Node& b){
	if(a.num == b.num) return a.id1 < b.id1;
	else return a.num > b.num;
}
int main(void)
{
	int n,k;
	cin>>n>>k;
	for(int i = 1;i <= 10;i++){
		cin>>E[i];
	}
	//输入初始权值W[i] 
	for(int i = 0;i < n;i++){
		cin>>a[i].num;
		a[i].id1 = i + 1;	//初始序号 
	}
	sort(a,a+n,cmp); 
	//给排序的后的权值分类
	for(int i = 0;i < n;i++){
		a[i].id2 = i % 10 + 1;		//
		int t = a[i].id2;
		a[i].num = a[i].num + E[t];
	}
	
	//最后再对分数进行排序
	sort(a,a+n,cmp);
	for(int i = 0;i < k;i++){
		cout<<a[i].id1<<" ";
	}
	return 0;
}
```

---

## 作者：藤原とうふ店 (赞：0)

唉！~

像我这样的蒟蒻也只能用巨多代码行数来AC了...


------------

我的思想是看着题目一步一步来，

输入n,k（用题目给的变量名不容易搞混，可以使代码更清晰）。

把所有需要的变量都定义在一个自定义的函数里，更方便查看和使用。

还有一个需要注意的是编号、序号与类别序号之间的区别（在这死了好多次）。编号是一开始输入的先后顺序，而序号则是权值从大到小排序之后的先后顺序，类别序号是序号mod10之后+1的值【(D[i]-1) mod 10 +1】，最后输出的是编号。

好了，第一次发题解，希望大佬勿喷..


------------


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>//这是sort的库文件
#define Maxn 20009
using namespace std;
struct a{
    int w,c,d,z;//w:初始权值
                //c:类别编号
                //d:序号
                //z:编号
}p[Maxn];
//自己定义一个函数。
bool cmd(a f,a g){
    if(f.w==g.w)
        return f.z<g.z;//权值相等时编号小的在前
    else
        return f.w>g.w;//初始权值从大到小排序
}
int e[11];
int main()
{
    int n,k;//n:要照片的人数
            //k:给的人数
    cin>>n>>k;
    for(int i=1;i<=10;i++){
        cin>>e[i];
    }
    for(int i=0;i<n;i++){
        cin>>p[i].w;
        p[i].z=i+1;
    }
    sort(p,p+n,cmd);
    for(int i=0;i<n;i++){
        p[i].d=i+1;
    }
    for(int i=0;i<n;i++){
        p[i].c=(p[i].d-1)%10+1;
        p[i].w+=e[p[i].c];
    }
    sort(p,p+n,cmd);
    for(int i=0;i<k;i++){
        cout<<p[i].z<<' ';
    }
    return 0;
}
```

---

## 作者：HFColin (赞：0)

无聊刷水题

其实就是模拟

你可以用多队列优化，但是没有必要

如果你做过瑞士轮（P1309）你就会发现：

“按照这个序号对10取模的值将这些人分为10类，第i类的人将会额外得到E[i]的权值” 则每一类的相对顺序是一样的！

我们可以用归并乱搞了！

（其实并不用归并，用十个队列和一个堆也可以做到）

先放简单模拟的代码

```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    long long a[50000],e[10];
    int main()
    {
        int n,k,i;
        scanf("%d %d",&n,&k);
        for (i=0;i<10;i++)
            scanf("%d",&e[i]),e[i]*=50001;
        for (i=0;i<n;i++)
            scanf("%d",&a[i]),a[i]=a[i]*50001+50000-i;
        sort(a,a+n);
        for (i=n-1;i>=0;i--)
            a[i]+=e[(n-i-1)%10];
        sort(a,a+n);
        for (i=n-1;i>=n-k;i--)
            printf("%d ",50001-a[i]%50001);
        return 0;
    }
```
（用了编码避免开结构体，由于vijos数据范围较大，有所不同，这个代码在vijos与luogu皆可AC）
再放乱搞代码

```cpp
    #include<cstdio>
    #include<queue>
    #include<algorithm>
    using namespace std;
    long long a[50000],e[10],l;
    int main()
    {
        int n,k,i;
        scanf("%d %d",&n,&k);
        for (i=0;i<10;i++)
            scanf("%d",&e[i]),e[i]*=50001;
        for (i=0;i<n;i++)
            scanf("%d",&a[i]),a[i]=a[i]*50001+50000-i;
        sort(a,a+n);
        queue <long long> q[10];
        priority_queue <long long> que;
        for (i=n-1;i>=0;i--)
            q[(n-i-1)%10].push(a[i]*10+(n-i-1)%10);
        for (i=0;i<10;i++)
            if (!q[i].empty())
            {
                que.push(q[i].front()+e[i]*10);
                q[i].pop();
            }
        while (k--)
        {
            l=que.top();
            que.pop();
            printf("%d ",50001-(l/10)%50001);
            if (!q[l%10].empty())
            {
                que.push(q[l%10].front()+e[l%10]*10);
                q[l%10].pop();
            }
        }
        return 0;
    }
```
这个代码在vijos与luogu也是可以AC的
真有趣


---

## 作者：lolilukia (赞：0)

这道题用了两次排序，第一次根据权值排序，然后根据序号再计算排序

根据特点，第一次排序必须要全部都排，就选择了快速排序

第二次排序只用排部分数据，选择快速排序

贴上源码：

```cpp
#include<iostream>
#include<stdio.h>
#include<cstdlib>
using namespace std;
int size, k;
int e[11];
class person{    //用类来存储每一个人的相关信息
  public:
    int n;
    int e;
    int w;
    person(int number, int weight){
        n = number;
        w = weight;
    }
};
void partition(person** l, int s, int t);
void partition(person** l, int s, int t){ //对对象数组进行快速排序
    if(s>=t) return;
    person* v = l[s];
    int i = s, j = t;
    while(i<j){  //需要注意的是这里就需要注意权重相同时要根据编号排序
        while(i<j && ( l[j]->w<v->w || (l[j]->w==v->w && l[j]->n>v->n))) j--;
        l[i] = l[j];
        while(i<j && ( l[i]->w>v->w || (l[i]->w==v->w && l[i]->n<v->n))) i++;
        l[j] = l[i];
    }
    l[i] = v;
    partition(l, s, i-1);
    partition(l, i+1, t);
}
int main(){
    cin >> size >> k;
    person* l[20000];
    for(int i=1;i<=10;i++) cin >> e[i];
    for(int i=0;i<size;i++){
        int w;
        cin >> w;
        l[i] = new person(i+1, w);
    }
    partition(l, 0, size-1);
    for(int i=0;i<size;i++){
        l[i]->e = e[(i+1-1)%10+1];
        l[i]->w += l[i]->e;    //排序后计算e值和最终的权值
    }
    int t;
    for(int i=0;i<size;i++){  //对部分数据进行选择排序
        t = i;
        for(int j=i+1;j<size;j++){
            if(l[j]->w>=l[t]->w){
                if(l[j]->w==l[t]->w){
                    if(l[j]->n<l[t]->n)
                        t = j;
                }
                else t = j;
            }
        }
        swap(l[i], l[t]);
        if(i+1==k) break;   //选够一定数量就跳出
    }
    for(int i=0;i<k;i++){
        cout<<l[i]->n<<" ";
    }
    return 0;
}
```

---

## 作者：HenryHuang (赞：0)

这道题又是结构体+二级排序，先按权值排，再按**编号**（注意，是**编**号）排，但是这道题确实有点绕（你可以请教你的语文老师，然后···），但是开心的是，我还是一次AC啦！高兴之余，发个题解，请看代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>//头文件 
using namespace std;
struct cc
{
    int c;//类别序号 
    int d;//序号 
    int w;//权值 
    int num;//编号 
}p[20001];
bool cmp(cc x,cc y)//二级排序 
{
    if(x.w>y.w)//如果权值可以比较 
    return 1;
    if(x.w==y.w&&x.num<y.num)//如果权值相等，比较编号 
    return 1;
    return 0;
}
int main()
{
    int n,k,e[11];//总人数，给照片人数，每类人可额外获得的权值 
    cin>>n>>k;
    for(int i=1;i<=10;i++)
        cin>>e[i];
    for(int i=1;i<=n;i++)
    {
        p[i].num=i;//记录编号 
        cin>>p[i].w;    //输入 
    }
    sort(p+1,p+n+1,cmp);//排序 
    for(int i=1;i<=n;i++)
    {
        p[i].d=i;//记录序号 
        p[i].c=(p[i].d-1)%10+1;//记录类别序号 
        p[i].w+=e[p[i].c];//加上额外权值 
    }//是不是好麻烦？！ 
    sort(p+1,p+n+1,cmp);//排序 
    for(int i=1;i<=k;i++)
    cout<<p[i].num<<' ';//输出 
    cout<<endl;
}
```

---

## 作者：Qiu233 (赞：0)

看了看各位大佬的题解，略感复杂，放一下自己的答案吧





```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct node
{
    unsigned id, weight;
};
int E[11];
node W[20000];
unsigned int w = 0;
```
/\*
根据排序的规则，如果权值相等，那么id小的优先

否则权值大的优先

\*/


```cpp
bool cmp(node a,node b)
{
    if (a.weight == b.weight)return a.id < b.id;
    return a.weight > b.weight;
}
int main()
{
    //freopen("in.in", "r", stdin);
    //freopen("out.out", "w", stdout);
    unsigned int n, k;
    cin >> n >> k;
    for (size_t i = 1; i <= 10; i++)
        cin>>E[i];
    for (size_t i = 1; i <= n; i++) 
    {
        W[w].id = i;
        cin >> W[w++].weight;
    }
    //按照权值排序
    sort(W, W + w, cmp);
    for (size_t i = 0; i < w; i++)
        W[i].weight += E[(i % 10) + 1];//加上计算得出额外的权值
    //按照权值再次排序
    sort(W, W + w, cmp);
    for (size_t i = 0; i < k; i++)
        cout << W[i].id << " ";
    return 0;
}
```

---

## 作者：clouds (赞：0)

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int E[11];
typedef struct Photo
{
    int bh;//编号
    int w;//权值
    bool operator <(Photo a)const//重定义“<”
    {
        if(w!=a.w) return w>a.w;
        return bh<a.bh;
    }
};
vector<Photo> vec;
int n,k;
Photo temp;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=10;i++) cin>>E[i];//读入10个额外权值
    for(int i=0;i<n;i++)//读入权值并给每个权值编号
    {
        cin>>temp.w;
        temp.bh=i+1;
        vec.push_back(temp);
    }
    sort(vec.begin(),vec.end());//排序
    for(int i=0;i<n;i++) vec[i].w=vec[i].w+E[i%10+1];//给权值加上额外权值
    sort(vec.begin(),vec.end());//排序
    for(int i=0;i<k;i++) cout<<vec[i].bh<<" ";//输出
    return 0;
}
```

---

## 作者：panzheng1999 (赞：0)

新人写题解：

写好结构体和cmp大概就可以了233

注意一下题目里的“编号”和"序号“（可能只有我眼神不太好吧）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
struct stu
{
    int W;//权值
    int D;//类别
    int B;//编号
}a[20005];
bool cmp(stu a,stu b)
{
    if(a.W!=b.W)  return a.W>b.W;
    else if(a.W==b.W) return a.B<b.B;
}
int E[11];//额外权值
int n,k;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=10;i++)
      cin>>E[i];
    for(int j=0;j<n;j++)
     {
         cin>>a[j].W;
         a[j].B=j+1;
     }
    sort(a,a+n,cmp);
    for(int i=0;i<n;i++) a[i].D=(i+1-1)%10+1;//归类
    for(int i=0;i<n;i++) a[i].W+=E[a[i].D];//加上额外权值
    sort(a,a+n,cmp);
    for(int i=0;i<k;i++) cout<<a[i].B<<" ";
    cout<<endl;
    return 0;
}

```

---

## 作者：debiluz (赞：0)

我的思路和大家一样，用的是c++中的STL。有一点要提醒大家，就是题目中有多处提到了编号的问题，每个人的编号是一开始输入的1-n,我把当成了排序后的1-n,调了好长时间。还有一点就是取余的时候要看你的数组是从0开始还是从一开始。下面贴上我的代码（把程序分成一个个函数看起来回更清晰哦！）：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 20001;
struct Re
{
    int w;
    int l;
}re[N]; //使用数组更加方便
int n,k,i,j;
int e[11];
bool cmp(Re a, Re b) //自己定义一个函数，用于sort的比较
{
    return (a.w > b.w) || (a.w == b.w && a.l < b.l);
}
void init() //输入数据
{
    cin >> n >> k;
    for (i = 1; i <= 10; i++)
        cin >> e[i];
    for (i = 1; i <= n; i++)
    {
        cin >> re[i].w;
        re[i].l = i;
    }
}
void op()
{
    sort(re+1,re+n+1,cmp); //先对权值进行排序
    for (i = 1; i <= n; i++)
    {
        int tep = (i - 1) % 10 + 1;
        re[i].w += e[tep];
    }
    sort(re+1,re+n+1,cmp);
}
void output() //输出
{
    for (i = 1; i <= k; i++)
        cout << re[i].l << " ";
    cout << endl;
}
int main()
{
    init();
    op();
    output();
    return 0;
}
```

---


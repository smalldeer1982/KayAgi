# [USACO19FEB] Sleepy Cow Herding B

## 题目描述

Farmer John 的三头获奖奶牛 Bessie、Elsie 和 Mildred，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。

农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这 $3$ 头奶牛现在正位于不同的整数位置，Farmer John 想要移动她们，使得她们占据三个相邻的位置（例如，位置 $6$、$7$、$8$）。

不幸的是，奶牛们现在很困，Farmer John 要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。

请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。 

## 说明/提示

### 样例解释 1

最小移动次数为 $1$——如果 Farmer John 将位置 $4$ 的奶牛移动到位置 $8$，那么奶牛们就处在连续的位置 $7$、$8$、$9$。最大移动次数为 $2$。例如，位置 $9$ 的奶牛可以被移动到位置 $6$，然后位置 $7$ 的奶牛可以被移动到位置 $5$。

## 样例 #1

### 输入

```
4 7 9```

### 输出

```
1
2```

# 题解

## 作者：canwen (赞：1)

## 题意
简单来说就是，给定三个数 $a,b,c$，每次只能操作最大数和最小数移动到其余两个数之间，目标是让 $b-a=1$ 和 $c-b=1$，分别求最大和最小的移动次数。
## 分析
我们可以先用数组的操作对其进行排序。

先考虑最小的答案如何求。
我们可以发现：

- 当 $c-a=2$ 时，答案直接为 $0$。
 
- 当 $b-a=2$ 或者 $c-b=2$ 时，答案为 $1$，毕竟可以让另外一个数直接插入到这两个数之中直接完成。
  
- 其他情况最好答案为 $2$。我们可以举一个例子看看，例如 $100,200,300$，我们只需要先让其中的一个端点和另外一个端点相减得到差 $2$，例如先变成 $100,102,200$，这个时候再让新的端点移动到其余两个数之中就行了，例如最后变成 $100,101,102$。

这个时候考虑最大答案就容易了。

我们只需要先确认两个可以插入的区间中哪个最大，每次都从最大数这个端点减 $1$ 形成中间那个数。这样就能确保操作次数最多，而答案就是 $\max(b-a,c-b)-1$ 次。

如果难以理解那可以看看下面这组例子。

假设这三个数为 $5,9,12$。

1. 确定差最大的区间差是 $9-5=4$，进行 $4-1$ 步操作。
2. 第一步变成 $5,8,9$。
3. 第二步变成 $5,7,8$。
4. 第三步变成 $5,6,7$。不能进行更多步了。

讲解得如此细致就不放代码了，可以根据上面的结论自己编写代码的，不压行 $20$ 行左右就行了。

---

## 作者：cff_0102 (赞：1)

假设 $a<b<c$。

注意到每一次操作都会使得这组数据的极差缩短 $b-a$ 或 $c-b$。

最后要让极差变为 $2$。

首先当极差本来就是 $2$，最大值和最小值都直接输出 $0$。

当极差不是 $2$，则 $b-a$ 或 $c-b$ 必然大于等于 $2$。

首先考虑操作次数最小的情况：
- 当其中有一个是 $2$，要让操作次数最小，可以直接一步到位，将不在刚刚计算出 $2$ 的算式中的那个数（如果 $c-b=2$ 就是 $a$，如果 $b-a=2$ 就是 $c$）移到刚刚计算出 $2$ 的两个数之间的位置即可。输出 $1$。
- 否则要让操作次数最小，只需要分别缩短 $b-a$ 和 $c-b'$ 即可，其中 $b'=a+2$，这需要两次操作。输出 $2$。

然后考虑操作次数最大的情况：
- 第一次操作，极差必然减去 $b-a$ 或 $c-b$ 中的一个（这里进行一次操作，极差变为 $c-a-\min(b-a,c-b)$）；接下来每次操作，极差都至少会减少 $1$ 直到减到 $2$（这里进行 $c-a-\min(b-a,c-b)-2$ 次操作）。因此最后的操作次数不会大于 $c-a+1-\min(b-a,c-b)-2=c-a-\min(b-a,c-b)-1=\max(b-a,c-b)-1$。
- 而不难构造出一种方法使得操作次数为 $\max(b-a,c-b)-1$，所以操作次数的最大值就是 $\max(b-a,c-b)-1$。

AC 代码（Python 真的太方便了！！！11）：

```python
a,b,c=sorted(list(map(int,input().split())))
# 最小值
print(0 if c - a == 2 else (1 if c - b == 2 or b - a == 2 else 2))
# 最大值
print(max(b - a , c - b) - 1)
```

注：当极差是 $2$ 时最大值为 $1-1=0$，所以不需要进行特判。

---

## 作者：Quartz_Blocks (赞：1)

# P1693 [USACO19FEB] Sleepy Cow Herding B 题解

此题不是很难，纯模拟即可。

我采用的方法就是分开来计算。

由于只有 $3$ 头牛，这变得十分简单。

思路已经放在代码里了，接着奉上代码：

```
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
void f1(int a,int b,int c,long long cnt){
	//最小次数
	if(a > b) swap(a,b);
	if(b > c) swap(b,c);
	if(a > b) swap(a,b);
	if(b > c) swap(b,c);
    //模拟一趟交换
    //要么 0 要么 1 要么 2
	if(c-b == 1 && b-a == 1){
		cout << cnt;
		return;
	}
	if(c - b == 2 || b-a == 2){
		cout << 1;
		return;
	}else{
		cout << 2;
	}
}
void f2(int a,int b,int c,long long cnt){
	if(a > b) swap(a,b);
	if(b > c) swap(b,c);
	if(a > b) swap(a,b);
	if(b > c) swap(b,c);
    //模拟一趟交换
    //距离 - 1
	cout << max(c-b,b-a)-1;
}
int main(){
	int a,b,c;
	cin >> a >> b >>c;
	f1(a,b,c,0);//min
	cout << '\n';
	f2(a,b,c,0);//max
	return 0;
}
```

---

## 作者：RockyQ012 (赞：1)

## 题目大意
一数轴上有三点，每次把最大或最小的一点牛移到另外两点的中间，求最大和最小的移动次数。
## 思路
### 首先
排序。
### 最大值
把端点移到中间点的一侧，然后继续选取移动后的端点重复上述操作直到三点相邻，由于有两个端点，所以有两种方法，大的那一个就是最大值。
### 最小值
第一种是三个点已相邻，直接输出两个 $0$ 后结束程序。
第二种是有两个点相隔 $2$，将第三点插入这两点之间即可，此时的最小值为 $1$。
第三种是先通过一次移动，使其变为可能性 $2$，然后按可能性 $2$ 操作即可，此时的最小值为 $2$。
## 代码：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a[3];
    cin >> a[0] >> a[1] >> a[2];
    sort(a , a + 3);
    int x = a[1] - a[0] , y = a[2] - a[1];
    if(x == 1 && y == 1) 
    {
        cout << 0 << endl;
        cout << 0 << endl;
        return 0;
    }
    if (a[2] - a[1] == 2 || a[1] - a[0] == 2)
    {
        cout << 1 << endl;
    }
    else
    {
        cout << 2 << endl;
    }
    cout << max(x , y) - 1;
    return 0;
}
```

---

## 作者：Citlali_qwq (赞：1)

## 题意

给定 $3$ 个坐标 $a, b, c$，问只要要操作多少次，使得 $a, b, c$ 可以重排为一个等差序列。

## 思路

不妨令 $a > b > c$。

最小值分 $3$ 种情况来讨论：

+ 若 $a - b = b - c$，已经构成等差序列，输出 $0$。
+ 若 $a - b, b - c$ 中其中有一个为 $2$，则只需要将另一个数移动 $1$ 步到中间即可。
+ 否则，至少需要 $2$ 步才可以使他们连续。

令 $t=\max(a-b,b-c)$，则最大值应该是 $t-1$。

## 代码

```cpp
/*****************************************
备注：
******************************************/
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cmath>
#include <cassert>
#include <climits>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define int ll
const int MAXN = 2e6 + 10;
const int MR = 10 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1e9 + 7;
const int _ = 0;
const bool debug = false;
#define check(x)cout << #x << "   ===   " << x << endl;
signed main()
{
	// int start = clock();
	int ta, tb, tc, a, b, c;
	cin >> ta >> tb >> tc;
	a = max({ta, tb, tc}), c = min({ta, tb, tc}), b = ta + tb + tc - a - c;
	if(a - b == b - c)puts("0");
	else if(a - b == 2 || b - c == 3)puts("1");
	else puts("2");
	cout << max(a - b, b - c) - 1;
	// printf("%.3lf", clock() - start);
    return ~~(0^_^0);
}
```

---

## 作者：klxxwyx123 (赞：0)

## 解析
### 排序：
* 由于三只牛的顺序不固定，所以要用 sort 进行排序。

### 最小次数：
* 当三只奶牛两两之间距离都为 $1$ 时，则不需要移动，最小次数为 $0$。  
* 当三只奶牛中有两头及以上的奶牛距离小于或等于 $2$，那最少只需 $1$ 次移动。  
* 否则就至少要 $2$ 次移动。

### 最大次数：
* 应为相邻两头奶牛距离最大值 $-1$。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[4];
int main(){
	for(int i=1;i<=3;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+3);
	if(a[1]+1==a[2]&&a[2]+1==a[3]) cout<<"0\n0";
	else if(a[1]+2==a[2]||a[2]+2==a[3]){
		cout<<"1\n"<<max(a[3]-a[2]-1,a[2]-a[1]-1);
	}else{
		cout<<"2\n"<<max(a[3]-a[2]-1,a[2]-a[1]-1);
	}
	return 0;
}
```

---

## 作者：liyp (赞：0)

# 题解
## 题目思路

这道题目可以分为三种情况：

### 最小值

1. 三只奶牛挨在一起，不需要移动。

2. 三只奶牛中相邻的任意两只奶牛间距为 1 ，且这两只奶牛中间的位置是空的，第三只奶牛可以直接移过来，最小次数为 1 。

3. 其他情况，最小只需要移动两次。 证明：将一只在端点上的奶牛移至中间那只奶牛间距为 1 的地方，形成情况 2 。

### 最大值

对于第一种情况，由于不需要移动，最大值也是 0 。

对于第 2 、3 种情况，最大值为相邻的两只奶牛间距最大值减掉 1 。  
**操作**如下：
把端点移到中间点的一侧，然后继续选取移动后的端点重复上述操作直到三点相邻，由于有两个端点，所以有两种方法，大的那一个就是最大值。

## 局部代码（供参考）
### 情况 1
```cpp
if (cows[0] + cows[2] == cows[1] * 2)
{
	cout << 0 << endl<<0;
	return 0;
}
```
### 情况 2 的最小值

```cpp
if (cows[2] - cows[1] == 2 || cows[1] - cows[0] == 2)
	cout << 1 << endl;
```
### 情况 3 的最小值
```cpp
else
	cout << 2 << endl;
```
### 情况 2 与 3 的最大值
```cpp
cout << max(cows[1]-cows[0], cows[2]-cows[1]) - 1;
```
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int cows[3];
int main()
{
	
	cin >> cows[0] >> cows[1] >> cows[2];
	sort(cows, cows + 3);
	if (cows[0] + cows[2] == cows[1] * 2)
	{
		cout << 0 << endl<<0;
		return 0;
	}
	if (cows[2] - cows[1] == 2 || cows[1] - cows[0] == 2)
		cout << 1 << endl;
	else
		cout << 2 << endl;
	cout << max(cows[1]-cows[0], cows[2]-cows[1]) - 1;
	return 0;
}
```

---

## 作者：pjx0106 (赞：0)

这一道题可以理解成是 [[USACO19FEB] Sleepy Cow Herding S](https://www.luogu.com.cn/problem/P5541) 的弱化版

# 解题思路
首先分类讨论，因为有一些刚开始就是排好的，不需要判断。

然后考虑最大值和最小值

## 最大值
最大值是最好搞的，最大值就尽量把每个空位都踩一遍，模拟一下会发现，第一跳的空隙一定没办法踩到，因此考虑两边第一跳谁跳的短，就从哪边开始。

## 最小值
1.考虑连续的 $3$ 个位置，假设枚举的这个区间外的牛，都可以跳进来，则答案为 $3 - cnt_lr$ 

显然可以转化成为：找到一个长度为 $3$ 的连续区间，使得牛尽可能多，双指针处理即可

2.会有不满足条件 $1$ 的情况，也就是在区间外的牛没办法跳进来，这种情况只有 $3-1$ 头牛连续才会出现

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int a[100005];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    for(int i=0;i<3;i++)cin>>a[i];//输入
    sort(a,a+3);//排序，好进行双指针操作
    int cnt=0,now=1;
    for(int i=1;i<3;i++){
        if(a[i]==a[i-1]+1)now++;
        else now=1;
        cnt=max(now,cnt);//计算有多少连续数字
    }
    if(cnt==3){//如果有3个，证明已经有序
		cout<<0<<endl<<0;
		return 0;
	}
    int ans=INT_MAX;
    int l=0,r=0;
    while(l<3){//双指针，这里不详细讲解
        while(r<3&&a[r]<=a[l]+3-1)r++;
        ans=min(ans,3-(r-l));
        l++;
    }
    if(cnt==3-1){
        ans=2;
        if(a[0]==a[1]-2||a[3-1]==a[3-2]+2)ans=1;//判断是否满足条件1
    }
    cout<<ans<<endl;
    ans=a[3-1]-a[0]-1;//判断最大值
    ans-=3-2;
    ans-=min(a[1]-a[0],a[3-1]-a[3-2])-1;
    cout<<ans<<endl; 
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：0)

## 思路
1. 排序：

- 首先，我们需要确保奶牛的位置是有序的，即 $a \le b \le c$ 。这样可以简化后续的计算。
- 我们可以使用 sort 来对包含奶牛位置的数组或  vector 进行排序。如果只有三个元素，也可以使用if语句和 swap 函数进行排序，但 sort 通常更加高效和通用。
2. 计算最小移动次数：

- 一旦奶牛的位置有序，我们就可以根据它们之间的相对位置来计算最小移动次数。
- 如果奶牛已经相邻（即 $a + 1 == b$ 且 $b + 1 == c$ ），则不需要移动，最小移动次数为 $0$ 。
- 如果只有一对奶牛之间的距离为 $2$ （即 $a + 2 == b$ 或 $b + 2 == c$ )，则只需要移动一次奶牛。
- 否则，我们至少需要移动两次奶牛，以便将它们聚集到相邻位置。
3. 计算最大间隔：
- 最大间隔是指相邻奶牛之间的最大距离减一（因为我们要计算的是间隔，而不是距离）。
- 在排序后的位置中，最大间隔要么是 $b - a - 1$ ，要么是 $c - b - 1$ ，取决于哪对奶牛之间的距离更大。
- 注意，这里的“最大间隔”并不是指将奶牛移动到某个位置所需的最大移动次数，而是指奶牛之间可能的最大间隔。在理论上，如果数轴是无限的，那么最大移动次数可以是无限的，因为我们可以将一头奶牛移动到任意远的位置。
4. 输出结果：
- 最后，我们将计算得到的最小移动次数和最大间隔输出到标准输出。
### 总结
这个问题主要考察了对排序和条件判断的理解。通过排序奶牛的位置，我们可以简化后续的计算。使用 sort 等算法函数可以提高代码的效率和可读性。最后，我们根据排序后的位置计算最小移动次数和最大间隔，并将结果输出。
### CODE：
```cpp
#include <bits/stdc++.h> 
using namespace std;  
int main(){  
    int a,b,c;  
    cin>>a>>b>>c;  
    vector<int> v = {a,b,c};  
    sort(v.begin(), v.end());  
    a = v[0];  
    b = v[1];  
    c = v[2];  
    int minS = 0;  
    if(!(a+1==b&&b+1==c)){ 
        if(a+2==b||b+2==c){  
            minS = 1; 
        }else{  
            minS = 2; 
        }  
    }  
    cout<<minS<<endl;  
    int maxS = max(b-a-1,c-b-1);
    cout<<maxS<<endl;  
    return 0;  
}
```

---

## 作者：LookatSea (赞：0)

思路：首先输入三个数 $x,y,z$ 并排好序。

如果三个数相邻，也就是最大的数减中间数与中间数减最小数的差都为一的情况最小和最大的数都是 $0$。

如果两个数之间有一个空位，直接插入另一个数即可，最小值为一。最大值取最大的数减中间数与中间数减最小数再减一的最大值即可。

如果两数相邻把他们分开让中间有一个空位再转化为第二种即可。

如果两个数之间的空大于二，那么让他们移动成空为一转换为第二种。

代码就不贴了。

---

## 作者：Genshin_ZFYX (赞：0)

对于最少的步数，有四种情况，按优先级从大到小依次是：

第一种，三个点已经连在一起了，答案显然为 $0$.

第二种，有两个点相隔 $1$，将另一个点插入两点之间就行，答案为 $1$。

第三种，有两个点相邻，把它们分开再把另一点插入到中间，答案为 $2$。

第四种，三个点中任意两点距离均 $>2$，需要将两个点通过移动使它们相隔 $1$，再将另一点插入到中间，答案为 $2$。

对于最多的步数，我们将边上的点移到中间那个点的内侧，直到三点相邻，有两种走法，答案就是更多的那个步数。

AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	int a,b,c;cin>>a>>b>>c;
	if(a>b)swap(a,b);if(b>c)swap(b,c);if(a>b)swap(a,b);
	if(a+1==b&&b+1==c)cout<<0;
	else if(a+2==b||b+2==c)cout<<1;
	else cout<<2;
	cout<<'\n'<<max(b-a-1,c-b-1);
	return 0;
}

```

---

## 作者：JOKER_chu (赞：0)

## 题意

形式化的来说，数轴上有 $3$ 个点，你每次都能移动一个再三点中最小或最大点到另一个位置，但是这个点必须成为中间那个点，求让他们靠在一起的最小与最大次数。

## 思路

分类讨论：

对于最小的步数，有三种情况：

第一种：他们三个已经靠在一起了，所以答案为 $0$。

第二种：他们三个中有两个已经靠在一起了，或者他们三个的距离都大于 $2$，对于这两种情况，我们每次都移动其中一个点到其他两个点的中间，所以答案为 $2$。

第三种：我们发现答案始终无法大于 $2$，使用 `else` 输出 $1$ 即可。

对于最大的步数，只有一种情况：我们每次都将一个端点移到中间那个旁边，然后又将变为端点的那个移到中间点的旁边，一直向另一个点靠近，这里用 `a[1] a[2] a[3]` 表示三个点。答案即为：

`max(abs(a[1] - a[2]) - 1, abs(a[2] - a[3]) - 1)`

## 完整代码

```cpp
#include <iostream>

#include <cmath>

#include <algorithm>

#define endl '\n'

using namespace std;

const int hutao = + 5;

int a[hutao];

int main(){
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> a[1] >> a[2] >> a[3];
  sort(a + 1, a + 3 + 1);
  if(a[1] + 1 == a[2] && a[2] + 1 == a[3]){
    cout << 0 << endl;
  }else if(abs(a[1] - a[2]) == 1 || abs(a[2] - a[3]) == 1 || (a[2] - a[1] > 2 && a[3] - a[2] > 2)){
    cout << 2 << endl;
  }else{
    cout << 1 << endl;
  }
  cout << max(abs(a[1] - a[2]) - 1, abs(a[2] - a[3]) - 1);
  return 0;
}
```

---

## 作者：Silent1019 (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/P1693)
## 题目大意
$3$ 头奶牛通过将端点位置的 $1$ 头奶牛移到另 $2$ 头牛中间的位置，求将 $3$ 头奶牛移到相邻位置的最小和最大次数。
## 思路
### 最小值
最小值有三种情况：
1. $3$ 头奶牛位置原本就是相邻的，显然最小次数为 $0$。
2. 其中 $2$ 头不都是端点的奶牛的位置差为 $2$，此时只需要将另 $1$ 头奶牛移到这 $2$ 头奶牛中间即可,最小次数为 $1$。
3. 剩余情况可以通过 $1$ 次移动，使 $3$ 头奶牛的位置情况转变为情况 $2$，因此最小次数为 $2$。
### 最大值
最大值的思路容易想很多。由于每次只能将端点奶牛移动到剩下 $2$ 头奶牛中间，那么很容易想到将奶牛一个一个位置的靠近，可以使次数达到最大值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int main()
{
	scanf("%d%d%d",&a,&b,&c);
	if(a>c) swap(a,c);
	if(b>c) swap(b,c);
	if(a>b) swap(a,b);
	//将3头奶牛的位置按从小到大一次存在a，b，c中
	 
	if(b-a==1&&c-b==1) printf("0\n");
	else if(b-a==2||c-b==2) printf("1\n");
	else printf("2\n");
	//判断最小值的3种情况
	 
	printf("%d\n",max(b-a,c-b)-1);
	//求最大值 
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# 前言
USACO的题目营养价值真高。

# 题目分析
这道题代码难度较低，思维难度较低，仔细分析，仔细读题肯定没问题。

## 最少

### 特殊情况
三只奶牛在一起，或者是三只奶牛中有两只只空一格且另外一个不在中间之类的，这时需要注意次数。

1. 在一起，不用移动，是 $0$ 次。

2. 第二种是 $1$ 次，直接把另外一头牛移动到他俩之间就行了。

### 正常情况

直接将一只牛为中心，另外两只移动到它的左右两边即可。

## 最多

这是这道题真正的重要之处，但是其实并没有那么难。

只需要假设两个最近的牛的距离为 $x$ 和 $y$。然后让牛一格一格地挪就行了。但是仔细读题后，你会发现，并不能这样挪动，所以最多的次数只能是 $x$ 和 $y$ 中最大的一个，因为最小的时候还没有挪动完成。

# 重点！！！
根据上面的分析，很多人会以为最多就是下面这样。
```cpp
ansmin = max(x, y);
cout << ansmin << endl;
```
但是这可是大错特错，实际上 $x$ 和 $y$ 中最小值的次数挪动完成后，剩下只有一次，所以要减少一次，答案自然是这样的。
```cpp
ansmin = max(x, y) - 1;
cout << ansmin << endl;
```

至此，本题基本思路结束，开始写代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a, b, c;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> a >> b >> c;
    if(a > b)
    {
    	swap(a, b);
	}
    if(b > c)
    {
    	swap(b, c);
	}
    if(a > c)
    {
    	swap(a, c);
	}
	//先排序，这里次数不多，直接手动排序。
	int x = b - a, y = c - b;
    if(x == 1 && y == 1) 
    {
        cout << 0 << endl;
        cout << 0 << endl;
        return 0;
    }
    //特殊情况，直接结束。
    if (c - b == 2 || b - c == 2)
    {
        cout << 1 << endl;
  	//特殊情况，只有一次。
    }
    else
    {
        cout << 2 << endl;
  	//正常情况，有两次。
    }
    cout << max(x, y) - 1 << endl;
    //正常结尾，max - 1 为答案！
    return 0;
}
```


---

## 作者：xiaozhu_zty (赞：0)

# P1693 Solution
数学推论题，草稿纸上画画图就能解出来（

## 题意简述
三只牛，每次只能把两边的其中一只牛移到另外两只牛的中间，求最大、最小移动次数。

## 分析
最简单的情况，三只牛本来就在一起。这种情况下，最大和最小移动的次数都是 $ 0 $ 次。

之后我们考虑分析不在一起的情况。首先分析最小移动次数。有两大类情况。

- 开始时有两只牛距离为 $ 2 $ 。此时我们只需要直接将另一只牛移动到这两头牛之间来即可。故最小移动次数为 $1$ 。
- 一般情况，此时只需要将任意端点上的一头牛移到距离中间牛 $ 1 $ 格的地方，然后变成了第一种情况，只需要再移动一次，故最小移动次数为 $ 2 $

综上，最小值的情况就处理完了。然后我们来分析最大次数。

对于一般情况，我们假设两端点牛到中间牛的距离分别为 $ l $ 和 $ r $ 。不难发现，操作最多的方法是找到 $ maxn = \max(l,r)$ 以及 $minn = \min(l,r) $ ，然后先将距离中间牛 $minn$ 位置的牛移动到中间牛的旁边格，然后反复移动两头牛直到其中一只牛贴近距离在中间牛距离 $maxn $ 的牛的位置。此时移动次数正好为 $ maxn -1 $ 。

到这里，最大最小值就都分析完了。

## 代码实现
``` cpp
#include <bits/stdc++.h>
using namespace std;
int ca,cb,cc;
int main(){
    cin>>ca>>cb>>cc;
    if (ca>cb) swap(ca,cb);
    if (cb>cc) swap(cb,cc);
    if (ca>cc) swap(ca,cc);
    if (cb-ca==1&&cc-cb==1) {
        cout<<0<<endl;
        cout<<0<<endl;
        return 0;
    }
    if (cc-cb==2||cb-cc==2){
        cout<<1<<endl;
    }
    else {
        cout<<2<<endl;
    }
    cout<<max(cc-cb,cb-ca)-1<<endl;
    return 0;
}

```

---


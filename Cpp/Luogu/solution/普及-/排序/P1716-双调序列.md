# 双调序列

## 题目描述

电脑组的童鞋们经常玩一些智力 PK 小游戏，某月某日，发源于小朋友又发明了一种新的序列：双调序列，所谓的双调呢主要是满足如下条件描述：

假定有 $n$（$n \le 1000$）个整数（都在 `long int` 范围内，即 $-2147483648 \sim 2147483647$），双调序列的第一个数是 $n$ 个整数中的最大数，第二个数是 $n$ 个整数中的最小数，第三个数是 $n$ 个数中的第二大数，第四个数是 $n$ 个数中的第二小数……取过的数不能再取，依次类推，直到结束。

聪明的你听完描述就抿嘴笑了吧？那就请你用程序正确的帮他找出这 $n$ 个数的双调序列。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 1000$。


## 样例 #1

### 输入

```
5
10
-1
3
3
-9
```

### 输出

```
10
-9
3
-1
3
```

# 题解

## 作者：B_Qu1e7 (赞：30)

```cpp
//楼下dalao的程序带我们重新认识了题解的意义（我没有嘲讽的意思） 
//坐看整楼水题解，各种反排 双判 deque 选排 （我真的没有嘲讽的意思） 
//真的那么难？
//见代码 
#include<bits/stdc++.h>
using namespace std;
int n,a[1001];
int main()
{
    cin>>n;//输入 
    for(int i=1;i<=n;i++)cin>>a[i];//和输入 
    sort(a+1,a+n+1);//和排序 
    for(int i=1;i<=n/2;i++)
    {
        cout<<a[n-i+1]<<endl<<a[i]<<endl;//和输出 
    }
    if(n%2)cout<<a[n/2+1]<<endl;//和判定 
}
//跟【模板】快速排序一样简单，只不过反了一半而已…… 
```

---

## 作者：decoqwq (赞：17)

思路：既然要找排名为1，倒数第1的数，那么很容易会想到用平衡树。这里介绍一种平衡树，名字叫finger—tree。它既可以当可并堆，又可以当平衡树，又像一颗线段树。与线段树相同的部分就是他的节点存的是两个叶子节点中较大的一个，这就是为什么可以用来当堆。调整平衡可以用旋转也可以拍扁重构。我这里写的是旋转。它的复杂度证明应该类似于SBT，因为它这种平衡能始终保持在log(n)+4 的这种级别。但是由于它在非叶子情况下有左右两个子节点，所以省去了大量的分类讨论，因此非常好写。

实现方法（题目）：先将所有数插入平衡树中，然后每次查找其中的最大值和最小值，再将其删除即可。

PS：因为懒得删所以把求rank的代码也放在上面啦，大家可以看看qwq

code：
```
//
//  main.cpp
//  qwq
//
//  Created by deco on 2018/6/13.
//  Copyright © 2018年 deco. All rights reserved.
//

#include <stdio.h>
#include <iostream>
#include <algorithm>
#define MAXN 300006
using namespace std;
struct Node
{
    int val,size;
    Node *ls,*rs;
    void pushup()
    {
        if(ls==NULL)
        {
            return ;
        }
        size=ls->size+rs->size;
        val=rs->val;
    }//向上传最大值和大小
    Node(int v,int s,Node *l,Node *r):val(v),size(s),ls(l),rs(r){}
    Node(){}
}pool[MAXN];
int cnt=0;
Node *root=NULL;
Node *NewNode(int val,int size,Node *ls,Node *rs)
{
    pool[cnt]=Node(val,size,ls,rs);
    return &pool[cnt++];
}
int find(int k,Node *rt)
{
    if(rt->size==1)
    {
        return rt->val;
    }
    if(k<=rt->ls->size)
    {
        return find(k,rt->ls);
    }
    else
    {
        return find(k-rt->ls->size,rt->rs);
    }
}
int Rank(int x,Node *rt)
{
    if(rt->size==1)
    {
        return 1;
    }
    else
    {
        if(x<=rt->ls->val)
        {
            return Rank(x,rt->ls);
        }
        else
        {
            return Rank(x,rt->rs)+rt->ls->size;
        }
    }
}
inline void maintain(Node *rt)
{
    if(rt->ls->size>rt->rs->size*4)
    {
        rt->rs=NewNode(rt->rs->val,rt->ls->rs->size+rt->rs->size,rt->ls->rs,rt->rs);
        Node *tmp=rt->ls;
        rt->ls=rt->ls->ls;
        *tmp=*rt->rs;
        rt->rs=tmp;//垃圾回收，下面同理
        cnt--;
    }
    else if(rt->ls->size*4<rt->rs->size)
    {
        rt->ls=NewNode(rt->rs->ls->val,rt->rs->ls->size+rt->ls->size,rt->ls,rt->rs->ls);
        Node *tmp=rt->rs;
        rt->rs=rt->rs->rs;
        *tmp=*rt->ls;
        rt->ls=tmp;
        cnt--;
    }
}
void ins(int val,Node *&rt)
{
    if(rt==NULL)
    {
        rt=NewNode(val,1,NULL,NULL);
        return ;
    }
    if(rt->size==1)
    {
        rt->ls=NewNode(min(val,rt->val),1,NULL,NULL);
        rt->rs=NewNode(max(val,rt->val),1,NULL,NULL);
    }
    else
    {
        if(val>rt->ls->val)
        {
            ins(val,rt->rs);
        }
        else
        {
            ins(val,rt->ls);
        }
    }
    rt->pushup();
    maintain(rt);//旋转
}
void del(Node *rt,Node *fa,int val)
{
    if(rt->size==1)
    {
        *fa=fa->ls->val==val?*fa->rs:*fa->ls;
    }
    else
    {
        if(val<=rt->ls->val)
        {
            del(rt->ls,rt,val);
        }
        else
        {
            del(rt->rs,rt,val);
        }
    }
    rt->pushup();
}
int main()
{
    int n;
    scanf("%d",&n);
    root=NewNode(2147483647,1,NULL,NULL);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        ins(x,root);//插入
    }
    for(int i=1;i<=n;i++)
    {
        if(i%2==0)
        {
            printf("%d\n",find(1,root));//查找
            del(root,NULL,find(1,root));//删除
        }
        else
        {
            printf("%d\n",find(n-i+1,root));//查找
            del(root,NULL,find(n-i+1,root));//删除
        }
    }
    /*for(int i=1;i<=n;i++)
    {
        int opt,x;
        scanf("%d%d",&opt,&x);
        if(opt==1)
        {
            ins(x,root);
        }
        if(opt==2)
        {
            del(root,NULL,x);
        }
        if(opt==3)
        {
            printf("%d\n",Rank(x,root));
        }
        if(opt==4)
        {
            printf("%d\n",find(x,root));
        }
        if(opt==5)
        {
            printf("%d\n",find(Rank(x,root)-1,root));
        }
        if(opt==6)
        {
            printf("%d\n",find(Rank(x+1,root),root));
        }
    }*/
}
```

2020/1/15:upd:略微修改了代码(

---

## 作者：RedreamMer (赞：10)

#### ~~这道题很简单啊，不知道其他大佬为什么要这么烦的代码~~
#### 我是使用判断奇数和偶数的方法，从1开始，若是奇数，就输出目前没输出过的最大数，若是偶数则输出目前没输出过的最小数
### 详见代码
```
#include<bits/stdc++.h>
using namespace std;
int x[1001];
int main()
{
	int a;
	cin>>a;
	for(int i=1;i<=a;i++)
	cin>>x[i];
	sort(x+1,x+a+1);
	for(int i=1,j=a+1,k=0;i<=a;i++)
	{
		if(i%2==1)
		cout<<x[--j]<<endl;
		else
		cout<<x[++k]<<endl;
	}
    return 0;
}
```
#### 十分简单吧

---

## 作者：judgejudge (赞：9)

# 纯排序或优先队列

这道题思路很清晰：输出第一大，第一小，第二大，第二小......

那么就有两种方案：

1. 纯排序
1. 优先队列
------------
## 方案一：纯排序

我们先对所有的数来一下**从大到小排序**。定义两个变量，分别在**头尾**，输出所在位置上的数后**互相靠近**，直到越过彼此为止。

```cpp
#include <iostream>
#include <algorithm>
#define N 1001//范围大点
using namespace std;
typedef long long ll;
ll a[N];
ll n;
inline bool cmp(ll a,ll b){
	return a>b;//从大到小排序，从小到大亦可
}
int main(){
	register int i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+n+1,cmp);//排序，赞一下STL
	ll pl=1,pr=n;//定义变量，初始在头尾
	while(pl<=pr){//直到越过彼此为止
		if(pl<=pr)cout<<a[pl]<<endl,pl++;//向右移动
		if(pl<=pr)cout<<a[pr]<<endl,pr--;//向左移动
	}
	return 0;
}
```


------------
## 方案二：优先队列
分别定义两个优先队列：**一个弹出队列中最小值，另一个弹出队列中最大值**。

即：
```cpp
typedef long long ll;
priority_queue<ll,vector<ll>,greater<ll> > q1;//弹出最小值
priority_queue<ll,vector<ll>,less<ll> > q2;//弹出最大值
```
然后分别把数放进两个队列中。

先弹出最大值队列，再弹出最小值队列，直到弹出n个为止。

代码:
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
priority_queue<ll,vector<ll>,greater<ll> > q1;//最小值队列
priority_queue<ll,vector<ll>,less<ll> > q2;//最大值队列
ll n;
main(){
	register int i;
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
		ll k;
		scanf("%lld",&k);
		q1.push(k);
		q2.push(k);//放入队列
	}
	while(n){//输出n个
		if(n)cout<<q2.top()<<endl,q2.pop(),n--;//弹出最大值
		if(n)cout<<q1.top()<<endl,q1.pop(),n--; //弹出最小值
	}
	return 0;
}
```
c++自带就是好。


---

## 作者：Peter_Z (赞：5)

一个排序然后从数组两边往中间输出就行了~~，应该是入门难度……~~

写了几种不同的排序（也就两种）

1.快排（STL大法好，O(nlogn)，不稳定）

直接sort(a+1,a+1+n)就可以了。

2.冒泡（O(n^2)，稳定排序）

模板（假设a数组需要从小到大排序）

```cpp
for(int i=1; i<n; i++) {
    for(int j=i+1; j<=n; j++) {
        if(a[i]>a[j]) {
            swap(a[i],a[j]);
        }
    }
}
```
还有就是注意n为奇数时要**输出中间的数**！

就是这些，并上蒟蒻的c++快排和pascal冒泡排序（闲着没事写写pas）代码：

1.c++快排

```cpp
#include<stdio.h>
#include<algorithm>
using std::sort;
const int Size=1001;
int a[Size];
int main() {
    int n,f;
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
        scanf("%d",&a[i]);
    sort(a+1,a+1+n);
    f=n>>1;
    for(int i=1; i<=f; i++)
        printf("%d\n%d\n",a[n-i+1],a[i]);
    if(n&1)    printf("%d",a[f+1]);
    return 0;
}
```
-------------------------------------------------------------------------------------------------------------------------------------

2.pascal冒泡

```pas
var
 a: array[1..1000] of longint;
 n,f,t : longint;
 i,j : integer;
begin
 read(n);
 for i:=1 to n do
 begin
  readln(a[i]);
 end;
 for i:=1 to n do
 begin
  for j:=i+1 to n do
  begin
   if a[i]>a[j] then
    begin
     t:=a[j];
     a[j]:=a[i];
     a[i]:=t;
    end;
  end;
 end;
 f:=n div 2;
 for i:=1 to f do
 begin
  writeln(a[n-i+1]);
  writeln(a[i]);
 end;
 if odd(n) then
 begin
  writeln(a[f+1]);
 end;
end.
```

---

## 作者：装逼是种缺德 (赞：5)

双调序列？
------------//华丽分割啪啪啪~~~

好高深的名字

我想许多人被这个名字吓跑了吧？

闲话少叙，先看代码
```cpp

#include<iostream>//基本都得用的高频率头文件

#include<algorithm>//调用sort

using namespace std;//不写很恐怖的啊啊啊~··~

int main()//进入主函数！

{

      int a[10000];//数字最好开大点不然会WA

      int n;//数据个数

      cin>>n;//输入不讲

      for(int i=1;i<=n;i++)//循环输入

      {

           cin>>a[i];//输入不讲

      }

      sort(a+1,a+n+1);//排序调用sort（stl大法好，感触颇深~~）

      int g=n+1;//由于下面要输出g-1所以g=n+1这样第一次输出a[n]

      int h=0;//同上类比输入从a[1]开始所以h=0第一次输出a[1]

      for(int i=1;i<=n;i++)//循环输出

      {

           if(i%2==1)//由题意推得奇数输出大的 

           {

                 cout<<a[g-1]<<endl;

                 g-=1;//更新输出下一大的数

           }

           else if(i%2==0) //偶数输出小的

          {
 
                 cout<<a[h+1]<<endl;

                 h+=1;//更新输出下一小的数

          }

     }

    return 0;//好习惯

}
```

让我们来好好讲讲思路，

首先，我们要理解这道题，

这道题的主要题干是：输入n个数，然后第一次输出最大，第二次输出最小，第三次输出第二大，第四次输出第二小。

那我们来找下规律：

1 最大       

2 最小

3 第二大

4 第二小

5 第三小

6 第三大

：
：

那么规律显而易见，奇数输大的，偶数输小的。

那么，这道题就出来了；

感谢各位不厌其烦的观看；

谢谢，希望大佬勿喷。

管理大大求过~~~(码字不易

---

## 作者：pbdean (赞：4)

嘿，下面的dalao们，有没有听说过“排序三慢”啊？

当然，我承认，我是个小学生，还不会那么多（如快排，望指教）但这道题怼起来还是绰绰有余的。

排序三慢是：冒泡，插入，**选择**

这道题，就是为选择排序量身定制的吧！

选择排序：在一堆数据中找到最大（小）的，置顶，再从剩下的找到最大（小）的……

这就是正反两次选择啊！

我能说的都说了，上代码（码风不好，请见谅）
```cpp
#include<iostream>
using namespace std;
int main(){
	int n=0;
	long int a[1000]={0};
	cin>>n;
	for(int i=0; i<n; i++) cin>>a[i];
	for(int i=0; i<n-1; i++) {
		int min_index = i;
		for(int j=i; j<n; j++) if(a[j] > a[min_index]) min_index = j;//找出第 i 小的数所在的位置
		swap(a[i],a[min_index]);//将第 i 小的数，放在第 i 个位置；如果刚好，就不用交换
		i++;
		for(int j=i; j<n; j++) if(a[j] < a[min_index]) min_index = j;//找出第 i 小的数所在的位置
		swap(a[i],a[min_index]);//将第 i 小的数，放在第 i 个位置；如果刚好，就不用交换
}
for(int i=0; i<n; i++) cout<<a[i]<<endl;
}

```
~~（不知感觉如何，反正我觉得挺好）

（为第一个解决的洛谷题目&&第一份题解干杯！）

---

## 作者：LGG_ (赞：3)

# 简单，易理解，结构体
###### ~~看见没人用结构体做，所以~~
这道题的关键在于数据的排序，数据排序然后前后一起输出即可

#### ！注意：

```c
if(r==l)
if(r>l)return 0;
```
##### 注意这两个if，超过就结束语句，相等就输出那个值然后结束语句

然后就是那个结构体了![](https://cdn.luogu.com.cn/upload/pic/1436.png)

```c
struct uu{
	int n;
}a[1001];
```
###### ~~都懂吧~~

#### ~~然后就是sort加cmp函数就ojbk了~~
代码：
```c
#include<iostream>
#include<algorithm>
using namespace std;
struct uu{
	int n;
}a[1001];
int k,r,l;
bool cmp(uu x,uu y){
	return x.n>y.n;
}
int main()
{
	cin>>k;l=k+1;
	for(int i=1;i<=k;i++)cin>>a[i].n;
	sort(a+1,a+1+k,cmp);
	for(int i=1;i<=k;i++){
		r=i;l--;
		if(r==l){
			cout<<a[r].n;
			return 0;
		}
		if(r>l)return 0;
		else {
			cout<<a[r].n<<endl<<a[l].n<<endl;
		}
	}
}
```
就这样..

---

## 作者：transmigration (赞：3)

# 看到这题一瞬间就想到了优先队列。。。本来以为挺简单，然后发现有点麻烦，不过还好。
## 主要思路
#### 从大到小和从小到大两个队列，每次分别输出两个队列的首元素，然后输出就记一下次数，次数等于n就结束。
# 代码
```cpp
//#include<bits/stdc++.h>
//using namespace std;
//priority_queue<long int, vector<long int>,less<long int> > p;
//priority_queue<long int, vector<long int>,greater<long int> > q;
//long int n,x,a,b,flag;
//int main()
//{
	//cin>>n;
	//for (int i=0;i<n;i++)
	//{
		//cin>>x;
		//p.push(x);
		//q.push(x);
	//} 
	//while (1)
	//{
		//a=p.top();
		//b=q.top();
		//cout<<a<<endl;
		//cout<<b<<endl;
		//flag+=2;
		//if (flag==n)
		  //break;
		//p.pop();
		//q.pop();
	//}
	//return 0;
//}
```
## 然后你会发现......竟然是错的！！
## 思考良久，突然发现，，，自己就是个~~傻子~~天才
#### 不能两个都输出了再判断，如果n是奇数，那么输出时就会有错误，所以我选择了输出一个加一次，判断一次，果然A了！毕竟还是道~~水题~~


------------
# 正解 附~~AC~~代码 ~~亲测~~
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<long int, vector<long int>,less<long int> > p;//从大到小的优先队列
priority_queue<long int, vector<long int>,greater<long int> > q;//从小到大的优先队列
long int n,x,a,b,flag;
int main()
{
	cin>>n;
	for (int i=0;i<n;i++)
	{
		cin>>x;
		p.push(x);
		q.push(x);
	} 
	while (1)
	{
		a=p.top();//首元素取出
		b=q.top();//同上
		cout<<a<<endl;//输出
		flag++;//累计次数
		if (flag==n)//判断是否达到次数
		  break;//跳出
		cout<<b<<endl;
		flag++;
		if (flag==n)//同上
		  break;
		p.pop();//删掉队首元素，那么下一次输出的就是下一个最大（小）的
		q.pop();//同上
	}
	return 0;
}
```
# 有大（xián）佬（rén）觉得不好的，请~~用力喷~~

---

## 作者：louyichen (赞：2)

这道题是用模板函数来进行排序的，
以下代码仅供参考：
```cpp
#include<iostream>
using namespace std;
template<typename T>
void bubble_sort(T arr[], int len)
{
    int i, j;  T temp;
    for (i = 0; i < len - 1; i++)
        for (j = 0; j < len - 1 - i; j++)
        if (arr[j] < arr[j + 1])
        {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
}
int main()
{
	int a[1000];
	int n;
	cin>>n;
	for(int i=0; i<n; i++)
	{
		cin>>a[i];
	}
	bubble_sort(a,n);
	for(int i=0;i<n;i++)
	{
		if((i+1)%2==1)cout<<a[(i+1)/2]<<endl;
		if((i+1)%2==0)cout<<a[n-(i+1)/2]<<endl;
	}
	return 0;
}
```

---

## 作者：秋雨 (赞：1)

本人~~蒟蒻~~发了七次题解一次都没过，希望这次好点

这题真的很简单的，还有人用平衡树！！排序，从中间往两边输出就完了

例如样例：  10 -1 3 3 -9

排序后：    -9 -1 3 3 10

输出顺序为：5  1  4 2  3

贴代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a[1001];
	cin>>n;//输入
	for(int i=1;i<=n;i++) cin>>a[i];//输入
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=n/2;i++){
		cout<<a[n-i+1]<<'\n'<<a[i]<<'\n';//从中间往两边输出
		if(n-i+1-i==2){//特判
			cout<<a[n/2+1];
			break;
		}
	}
}
```
七次了，求过！

---

## 作者：banana_233 (赞：1)

既然都用的排序那本蒟蒻用一下优先队列好了

priority_queue<int,vector<int>,greater<int> >优先队列 按照由小到大顺序（升序）
  
priority_queue<int,vector<int>,less<int> >优先队列 按照由大到小顺序（降序）

注：两个>之间记得加空格

开两个优先队列分别是升序和降序的，然后再把数值放入两个队列中（两个队列都要记入所有数值）

然后用按位异或运算符判断奇数偶数，奇数则调动降序的优先队列，偶数则调动升序的优先队列，然后再开一个数组a记入队首数值，调动之后记得弹出队首的数

最后输出数组a就好了~
下面上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,a[1010],b,t=0;
	scanf("%d",&n);
	priority_queue<int,vector<int>,greater<int> >q;
	priority_queue<int,vector<int>,less<int> >p;
	for(int i=1;i<=n;i++) 
	{
		scanf("%d",&b);
		q.push(b);
		p.push(b);
	}
	for(int i=1;i<=n;i++)
	{
		t=t^1;
		if(!t)
		{
			a[i]=q.top();
			q.pop();
		}
		if(t)
		{
			a[i]=p.top();
			p.pop();
		}
	}
	for(int i=1;i<=n;i++)
	printf("%d\n",a[i]);
    return 0;
}

```

---

## 作者：Enzymii (赞：1)

STL依赖症+压行狂热患者前来水题解。。

此题做法显然，先排一边序，然后两端交替输出即可。。

作为STL依赖症晚期，一想到头尾交替输出便想到deque..

然后就想到了以下代码

```cpp
#include <queue>
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
    deque<int> v; int n,m=1;cin>>n; for(int i=1,t;i<=n;i++) cin>>t,v.push_back(t); sort(v.begin(),v.end());
    while(!v.empty()) (m^=1)?(cout<<v.front()<<'\n',v.pop_front()):(cout<<v.back()<<'\n',v.pop_back());
        //不要问我怎么压的行……唯一要讲的就是begin和end指针都是迭代器，可以作为sort的参数……
}
```
讲完了\_ (:з」∠) \_


---

## 作者：Q1284673918 (赞：0)

看看数据范围没超long long就是好事这就很麻婆了。

既然它都叫双调序列了，~~不开两个数组岂不是对不起出题人了~~。

为了~~水~~题解我也是不择手段了，就瞎扯些以后可能会用到的东西吧，快读在此段程序中有，这可是比scanf读入还要快的多的东西，有必要的还是记一记。接下来就是函数cmp，这个东西可以有很多种运用方法在sort中，可以使sort排结构体，或其他奇奇怪怪的东西，需具体情况具体分析。

废话不多说，代码时间
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}//快读以防超时 
bool cmp(int a,int b;){
	return a>b;
}//cmp快排由大到小 
long long a[1010],b[1010];//long long只有空间不会爆，首开long long，long long的玄学你会知道的 
int main()
{
	int n;
	read(n);//输入
	for(int i=1;i<=n;i++)
	read(a[i]),b[i]=a[i];//存入，两个数组
	sort(a+1,a+n+1);//快排大法好
	sort(b+1,b+n+1,cmp);
	if(n%2==0){//判断是奇数还是偶数
		for(int i=1;i<=n/2;i++)
		cout<<b[i]<<endl<<a[i]<<endl;
        //为偶数，两个数组，各输出一半的数字，b[]数组倒起输出，a[]数组正起输出，一大一小刚刚好
	}
	else {//如果是奇数，中间那个数字会输不出来
		for(int i=1;i<=n/2;i++)
		cout<<b[i]<<endl<<a[i]<<endl;
		cout<<a[n/2+1];//加上就行了
	}
	return 0;//re0不要忘
}
```	
最后再祝各位~~早日秃头~~我秃了但我也强了！！！！

---

## 作者：QianianXY (赞：0)

这题无疑是一道~~水~~入门题。关于思路，dalao们已经讲的很清楚，蒟蒻在此不再重复。

那么，这篇题解的作用则是引伸，介绍一下**位运算**的简单用法。（dalao请绕道）

如果不用位运算，本题代码大约是这样的：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++) 
        scanf("%d", &a[i]);
    sort(a, a + n);
    for (int i = 0; i < n / 2; i++)
        printf("%d\n%d\n", a[n - i - 1], a[i]);
    if (n % 2) printf("%d\n", a[n / 2]);
    return 0;
}
```

但是，在一些更难，对时间复杂度要求更高的题目里，取模和除所用时间更多，位运算则会快上很多倍。上述代码有两个地方可以优化。

### 1、n/2 -> n>>1:

">>"表示n的二进制形式向右移动k位。n>>1等同于整数除以2。n>>2等同于整数除以4。
    
### 2、n%2 -> n&1:

n&1可以比较n的最后一位的奇偶，忽略前面的数位。如果n&1=0，则n为偶数；n&1=1，则n为奇数。

优化后的代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++) 
        scanf("%d", &a[i]);
    sort(a, a + n);
    for (int i = 0; i < n >> 1; i++)
        printf("%d\n%d\n", a[n - i - 1], a[i]);
    if (n & 1) printf("%d\n", a[n >> 1]);
    return 0;
}
```

---

## 作者：mcyqwq (赞：0)

### ~~一道水题~~
### 此题主要有两个难点：
### 1：排序 2：输出

首先先说说排序的问题，我用的是堆排序（手打堆，没用STL），堆的原理不会的同学们可以去看一下[P3378](https://www.luogu.org/problemnew/show/P3378)和[那道题的题解](https://www.luogu.org/problemnew/solution/P3378)

堆排序就是每次取出堆顶元素加入到答案数组中。在这里我用的是小根堆，即堆顶元素是整个堆中最小的，所以只要先将原数组插入堆中，维护好小根堆然后每次取出堆顶元素加入到答案数组，然后将堆顶元素删除，直到堆为空就行了.此时排序好的数组是从小到大的（如果使用的是大根堆，即堆顶元素是整个堆中最大的，那么排序好的数组就是从大到小的）。


然后是输出的问题，我是这样做的（可能还有其他更好的做法）：先设置两个变量i和j，初始化为i=n,j=1。然后每次输出两个数，每次输出后将i加1，将j减1，直到i<j。如果出现i=j的情况，则那次输出只输出一个数(这样就能避免在n为奇数时多输出了中间的数）,由于题目要求第一个数是最大的，所以先输出i，再输出j。

### P.S.:堆的插入和删除操作可以看看上面我说的的那个题解
```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int n,x,heap[1001],siz,ans[1001];

inline void swap(int &x,int &y)//手打交换函数
{
    int t=x;
    x=y; y=t;
    return;
}

inline void push(int x)//在小根堆中插入一个数
{
    heap[++siz]=x;
    int now=siz;
    while(now>1)
    {
        int nxt=now>>1;
        if(heap[nxt]>heap[now]) swap(heap[nxt],heap[now]);
        else break;
        now=nxt;
    }
    return;
}

inline void pop()//删除堆顶元素
{
    swap(heap[1],heap[siz]);
    siz--;
    int now=1;
    while((now<<1)<=siz)
    {
        int nxt=now<<1;
        if(nxt+1<=siz&&heap[nxt+1]<heap[nxt]) nxt++;
        if(heap[nxt]<heap[now]) swap(heap[now],heap[nxt]);
        else break;
        now=nxt;
    }
    return;
}

int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)//输入
    {
        scanf("%d",&x);
        push(x);//插入到堆中
    }
    for(register int i=1;i<=n;i++)//循环n次，即循环至堆为空时
    {
        ans[i]=heap[1];//把堆顶元素加入答案数组
        pop();//删除堆顶元素
    }
    int i=n,j=1;//初始化输出控制变量
    while(i>=j)//输出
    {
    	if(i==j)//如果i=j，只输出一个数。此时输出ans[i]或者ans[j]都是一样的
    	{
    		printf("%d\n",ans[i]);
    		break;//跳出循环，不执行下面的输出操作
    	}
    	printf("%d\n",ans[i--]);
    	printf("%d\n",ans[j++]);//每次输出后i加1，j减1
    }
    return 0;//养成好习惯
}
```
### 说在最后：堆排序是最快的排序之一，P1177中我用堆排序的速度和STL的sort差不多快(堆排136ms，sort115ms），有兴趣的同学们可以学习一下堆及其应用
### 谢谢大家QAQ

---

## 作者：ComeOver· (赞：0)

这道题目主要考的是如何排序和怎样输出


1.排序

加上一个
```cpp
#include <algorithm>
```
在主函数中调用sort即可

sort（数组名称，数组名称+排序长度）

sort默认从小到大排序，如果要从大到小排序可以加入第三个参数，表示规则

2.输出

用两个参数i，j，用for循环（当然也可以用while，但这里本蒟蒻用for）两头一起输出即可

```cpp
#include <iostream>
#include <algorithm>//要用sort（）是要加的
using namespace std;

int main(){
	int n;//个数
	int a[1005];
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);//把数组排序
	for(int i=0,j=n-1;i<j+1;i++,j--){//i表示从小到大，j则相反
		if(i==j) cout<<a[i];//因为当i==j的时候，说明只剩一个数了，输出就可以了，然后会跳出循环
		else cout<<a[j]<<endl<<a[i]<<endl;//普通情况一次输出剩下中的最大，最小
	}
	return 0;
}
```

---

## 作者：1jia1 (赞：0)

真TM水啊。

核心思路：把序列排序一遍，然后后一个前一个地输出就好了。注意n为奇数和偶数的区别。

```cpp
-#include <iostream>-
-#include <cstdio>-
-#include <algorithm>-
-using namespace std;-
-int n,a[1001]={0};-
-int main()-
-{-
-    cin>>n;-
-    for(int i=1;i<=n;i++)cin>>a[i];-
-    sort(a+1,a+n+1);---快排就好了
-    if(n%2==0)---如果是n偶数
-        for(int i=1;i<=n/2;i++)---直接后输出一个前输出一个就好了
-        {-
-            cout<<a[n-i+1]<<endl<<a[i]<<endl;-
-        }-
-    else---否则
-        for(int i=1;i<=n/2+1;i++)---后输出一个前输出一个还要中间的一个
-        {-
-            cout<<a[n-i+1];-
-            if(i!=n/2+1)cout<<endl<<a[i]<<endl;---防止重复
-        }-
-    return 0;-
-}-
```

---

## 作者：Cyamuleaf (赞：0)

[ color=red]

本题思路：

①排序

②找输出的规律

[/color]

代码如下，仅供参考：

```cpp

#include<iostream>
#include<math.h>
using namespace std;
int main()
{
    int a[1010],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i]; 
    for(int j=1;j<=n;j++)
    for(int k=1;k<=n-j;k++) 
    if(a[k]<a[k+1])
    swap(a[k],a[k+1]);//排序，这里是冒泡 
    for(int i=1;i<=n;i++)
    {
        if(i%2==1)
        cout<<a[i/2+1]<<endl;//如果i为奇数，则输出大的 
        else cout<<a[n-i/2+1]<<endl;//如果i为偶数，输出小的 
    }
    return 0;
}


```

---

## 作者：Ufowoqqqo (赞：0)

排序一遍，模拟。用**[color=red]O(n^2)[/color]**的选择排序就可以了。

```delphi

var
 n,i,j,t:longint;
 a:array [1..1000] of longint;
begin
 readln(n);
 for i:=1 to n do readln(a[i]);
 for i:=1 to n-1 do
  for j:=i+1 to n do
   if a[i]<a[j] then
    begin
     t:=a[i];a[i]:=a[j];a[j]:=t;
    end;
  for i:=1 to n div 2 do
  begin
   writeln(a[i]);
   writeln(a[n-i+1]);
  end;
  if odd(n) then writeln(a[n div 2+1]);
end.

```

---

## 作者：courage (赞：0)

本题实际上还是比较简单的，只是需要排序两次并且按照一定的顺序输出即可，不过要注意细节哦。时间复杂度[color=red]**O(nlogn)**[/color]，数据规模很小，果断0msAC


实在想不出来的可以参考下面的代码：

```cpp

#include<cstdio>
#include<algorithm>
int n,a[1010],i,j;
bool cmp(int x,int y){
    return (x>y);
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    std::sort(a+1,a+n+1);
    std::sort(a+n/2+1,a+n+1,cmp);
    i=1;
    j=n/2+1;
    while (i<=(n>>1) || j<=n){
        if (j<=n) printf("%d\n",a[j]);
        j++;
        if (i<=(n>>1)) printf("%d\n",a[i]);
        i++;
    }
}

```

---


# 宇宙总统

## 题目描述

地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。


## 说明/提示

票数可能会很大，可能会到 $100$ 位数字。

$1 \leq n \leq 20$。

## 样例 #1

### 输入

```
5
98765
12365
87954
1022356
985678
```

### 输出

```
4
1022356```

# 题解

## 作者：callG (赞：413)

upd - 19 - 02 - 28，现在在洛谷可以编译通过了

---

其实对于只要比较大小的题，写高精度没必要

直接用 string 记录一个 max 每次比较很简单啊

---
原理：string的比较 保存数字的字符串=高精度版比较大小

和字典序什么的有关系

---
代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main() {
    int n, id; // id 记录当上总统的人的号数
    string max = ""; // 赋初值，这个 max 不可以作为全局变量（会重名）
    // 如果一定要把 string max 放到全局变量去，应去掉 using namespce std;
    string in;
    cin >> n;
	for (int i = 1; i <= n; i++) {
        cin >> in;
        int inSize = in.size();
        int maxSize = max.size();
        if (inSize > maxSize || (inSize >= maxSize && in > max)) {
            max = in;
            id = i;
        }
    }
    cout << id << endl << max << endl;
    return 0;
}
```

---

## 作者：right_cat (赞：219)

逛了一圈发现似乎没人用结构体做。

其实这道题用结构体做非常简单，我们可以定义三个结构体变量，一个装票数，一个装号数，还有一个装票数的位数。

重点是排序，**首先我们比较位数，位数多的排前面，如果位数相同就按字典序排列**。

一系列操作完成后，输入排在首位的答案即可。

代码实现：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct node
{
    string x; //装票数
    int num;  //装号数
    int lenx; //装票数的位数
}s[25];
bool cmp(node a,node b)
{
    if(a.lenx>b.lenx) return 1; //前一个比后一个位数多，不交换
    if(a.lenx==b.lenx&&a.x>b.x) return 1; //位数相同，但前一个按字典序排列比后一个大，也不交换。
    return 0; //剩下情况均要交换。
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i].x;
        s[i].num=i; //存号数
        s[i].lenx=s[i].x.size(); //存票数的位数
    }
    sort(s+1,s+n+1,cmp); //排序
    cout<<s[1].num<<endl;  //输出首位答案即可，注意先输出号数
    cout<<s[1].x<<endl; //再输出票数
    return 0;
}

```

---

## 作者：zhangyiming (赞：70)

**本初一蒟蒻的第一篇题解，好激动啊！！！**

------------

看了那么多大佬的题解，发现大多数都用**sort**。那我就来~~投机取巧、不要脸地~~发一篇不一样的题解。

------------

原理：利用**strcmp**函数比较。
-----------------------
代码如下：
```
include<iostream>
include<cstring>
using namespace std; 
int main(){ 
int n,num;
char a[201],max[201]="";  
cin>>n;
for(int i=1;i<=n;i++){                 
    cin>>a;
    if(strcmp(max,a)<0){//当max < a时，返回负数。  
        strcpy(max,a);  
        num=i; 
    }
} 
cout<<num<<endl;  
puts(max);  
return 0;     
}
```
然而！
  
0分！！！

why?!

原来，strcmp函数是先比较第1个字符的值！
--------------
于是乎，加上了**strlen**判定。

AC满分代码如下：
```
include<iostream>
include<cstring>  
using namespace std; int main(){
int n,num;  
char a[201],max[201]="";
cin>>n;
for(int i=1;i<=n;i++){                      
    cin>>a;  
    if((strlen(max)<strlen(a))||(strlen(a)==strlen(max)&&strcmp(max,a)<0)){//若a的长度==max的长度，再用strcmp比较  
        strcpy(max,a);  
        num=i;  
    }  
}
cout<<num<<endl;  
puts(max);//输出
return 0; // 程序再见！
}
```
  
附上[我的AC记录](https://www.luogu.org/record/21104745)
  
~~管理员大大求过~~

---

## 作者：CaptW (赞：66)

### ~~最近迷上了字符串，毕竟才做了字符串的整理（水题）~~
### 如果过了就是我的第一篇题解aaa
| 问题 | 数字太大 | 怎样比较 | 输出序号 |
| :----------: | :----------: | :----------: | :----------: |
| 措施 | 用字符串存 |  使用字符串的关系运算（稍作加工） | 使用结构体记录序号 |

### 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;

struct person{//每个人对应的有票数与序号两个元素 
	string piao;//票数超出long long使用字符串储存 
	int no;//序号存在使用二元结构体形成对应关系，方便输出 
}a[25],maxn;//a数组存每个人的相关信息，maxn用来存储答案 

bool cmp(string a,string b){//自己写一个比较函数，对字符串关系运算的弊端进行处理加工(这里弊端指的是位置越靠前优先级越高；如果对象长短不同，且较短对象的每个字符都与较长对象的字符相同，就说较短的对象小于较长的对象。) 
	if(a.length()>b.length()) return true;//（避免出现123>122222等类似的情况）正常情况下数字位数多的票数肯定较大 
	if(a.length()==b.length()&&a>b) return true;//若位数相同则按照正常字典序比较 
	return false;//以上条件分支都不成立就返回0 
}

int main(){
	int n;//人数 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].piao;
		a[i].no=i;//序号 
	}
	for(int i=1;i<=n;i++){
		if(cmp(a[i].piao,maxn.piao)) {//调用函数，正常操作 
			maxn.piao=a[i].piao;
			maxn.no=a[i].no;
		}
	}
	cout<<maxn.no<<endl<<maxn.piao;//输出，完美收场 
	return 0;
}
```

感谢阅读至此，orz

---

## 作者：TheUltimateLaw (赞：43)

这个题其实是很有价值的，

因为它能给不少像我一样的蒟蒻提供一个新的技能。

P.S我第一遍A题的时候，写的是根大部分题解类似的排法，直到一位神犇为我打开了新世界的大门...........

好吧，对于C++的同志们来说，

这题...

可以用sort......

代码如下





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define inf 2147483647
#define RE register
const int maxn=10010;
using namespace std;
inline int read (){
    int misaka=0,mikoto=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')
            mikoto=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        misaka=misaka*10+(int)(c-'0');
        c=getchar();
    }
    return misaka*mikoto;
}
struct node{
    string s;
    int id;
} a[maxn];
inline bool cmp(node x,node y){
    if(x.s.size()==y.s.size())
        return x.s>y.s;
    else return x.s.size()>y.s.size();
}
int main(){
int n;
    n=read();
    for(int i=1;i<=n;++i)
        cin>>a[i].s,a[i].id=i;
    sort(a+1,a+1+n,cmp);
    cout<<a[1].id<<endl<<a[1].s; 
    return 0;
}

```

---

## 作者：arfa (赞：21)

# 基数排序

本来我像比较字符串大小的(只需要先比较length和s[i]-s[j]就可以了),但是我还是没有那么做......


基数排序时间复杂度O(nq),也就是O(2000),很快。



## 如何排序？

先开一个10个位置的槽,下标为:0-9。每一次,我们把a[i]的第l位数字给a[i]分配位置:如1923,第一次的位置是(个位)place[3,o],第二次(十位)place[2,o],第三次place[9,o],第四次place[1,o]。当每一个数都分配完槽,将其[顺序]取出,覆盖a[i],在进行下一位的放槽。最后顺序出槽时,就是顺序的了。

![基数排序](http://pic.92to.com/2c/201609/29/201609060930471087.jpg)

所以我们要排q次(q为最大值的位数,如:max=123094,q=6),每一次放槽是n,取出覆盖是n。所以时间复杂度度2nq,也就是O(nq)。此排序只是内存耗的有点多(可以用内存来减少取位数的时间)。


[其实槽可以看作是栈啦...]


//---------------------------------以上是对基数排序的讲解,以下如何配用此题-----------------------------

## 进槽

上述的进槽是一个整数,但是这里却是一个字符串。所以我们分为3个进槽方式:


'0':直接给0槽。


个位数:给m槽,但是值为'0'


多位数:正常进槽。

## 巧用方法!

本题可以将a[i]变为s[i]string。排序时如上述一样,将每一位进槽出槽,最后将是最优解。(my基数排序得出来的是o[i],意思是原数组中的位置,而不是一个排好的数组!所以输出时也可以巧用!)



# 代码:

```pascal
var
        i,j,n,m,k,l:longint;
        place:array[0..9,1..20] of string;
        num,light:array[1..20] of string;
        op:array[0..9,1..20] of longint;
        na:array[0..9] of longint;
        o:array[1..20] of longint;
begin
        readln(n);
        for i:=1 to n do
        begin
                readln(num[i]);//票数
                light[i]:=num[i];//最后输出的票数
                k:=length(num[i]);
                o[i]:=i;//在数组中的位置
                if k>l then
                        l:=k;//q,也就是最大值的位数
        end;

        for i:=1 to l do//开始排序
        begin
                for j:=1 to n do//近槽
                begin
                        if num[j]='0' then//第一种情况'0'
                        begin
                                inc(na[0]);//给'0'槽
                                place[0,na[0]]:=num[j];
                                op[0,na[0]]:=o[j];
                        end
                        else
                        begin
                                k:=length(num[j]);
                                if k=1 then//个位数
                                begin
                                        val(num[j,1],m);
                                        inc(na[m]);//槽多了一个数
                                        place[m,na[m]]:='0';//进槽,值和下表都放进去
                                        op[m,na[m]]:=o[j];
                                end
                                else
                                begin
                                        val(num[j,k],m);//同上
                                        delete(num[j],k,1);
                                        inc(na[m]);
                                        place[m,na[m]]:=num[j];
                                        op[m,na[m]]:=o[j];
                                end;
                        end;
                end;

                m:=0;

                for j:=0 to 9 do//出槽
                begin
                        for k:=1 to na[j] do
                        begin
                                inc(m);//分配给原本的数组
                                num[m]:=place[j,k];
                                o[m]:=op[j,k];
                                {elete(place[j,k],1,length(place[j,k]));
                                op[j,k]:=0;}//清空槽,次句可以省略,因为进槽时会覆盖...
                        end;
                        na[j]:=0;//槽以清空
                end;
        end;

        writeln(o[n]);//最后一个
        writeln(light[o[n]]);//最大票数
end.

```

---

## 作者：Drifting (赞：20)

~~高精的题我们会选择用Python（滑稽.jpg）~~
# 一份正经的Python题解
```python
n = int(input())
vote = {}
for i in range(1, n + 1):
    vote[str(i)] = int(input())
ans = sorted(vote, key=lambda x: vote[x])[-1]
print(ans)
print(vote[ans])
```
当然啦，C++选手使用STL过这道题还是很简单的。

（只不过Python代码更简短 ~~但效率低~~）

---

## 作者：Xecades (赞：18)

**这个题，乍一看，我还以为是用高精...**
~~相信很多人都会和我想的一样~~

只不过我想问一句：
## 用高精？
实际上，这道题只要好好想一想，就很容易想到$string$的比较。

**Q:字符串的长度不一样，怎么比较啊！**
**A:**长度不一样，就弄得一样呗，直接在不足长度的字符串前加空格就是了

我的解法可能很麻烦，但好理解
- 先用$num$变量来统计竞选人数
```c
cin>>num;
```
- 为了保存方便，我们用一个结构体来统计
```c
struct node{
	string p;  //票数
	int w;     //排号
}n[30];
```
- 用$len$来统计最大长度，用$max()$选择最大长度，输入和最大长度可以放在一起弄
```c
for(int i=1;i<=num;i++)
{
	cin>>n[i].p;
	n[i].w=i;
	len=max(len,(int)(n[i].p).length());
}
```
- 在每一个票数前加上空格，用一个简简单单的$while$就好了
```c
while((int)(n[i].p).length()<=len)//转换成int类型,不然编译器报错不好看^+_+^
	n[i].p=' '+n[i].p;
```
- 我们用$maxs$来记录最大的票数，用$maxi$记录最大票数的排号，依次判断更新如下
```c
if(n[i].p>maxs)
{
	maxs=n[i].p;
	maxi=n[i].w;
}
```
- 判断完后就要输出，只不过问题就来了：最大票数前面的空格怎么办？于是我们可以一位一位地输出：
```c
for(int i=1;i<=len;i++)
	if(maxs[i]!=' ')//不是空格就输出
		cout<<maxs[i];
```

### 好了，完整的代码如下
```c
#include<iostream>
#include<string>
using namespace std;
struct node{
	string p;
	int w;
}n[30];
string maxs;
int num,len=0,maxi=0;
int main()
{
	cin>>num;
	for(int i=1;i<=num;i++)
	{
		cin>>n[i].p;
		n[i].w=i;
		len=max(len,(int)(n[i].p).length());
	}
	for(int i=1;i<=num;i++)
	{
		while((int)(n[i].p).length()<=len)
			n[i].p=' '+n[i].p;
		if(n[i].p>maxs)
		{
			maxs=n[i].p;
			maxi=n[i].w;
		}
	}
	cout<<maxi<<endl;
	for(int i=1;i<=len;i++)
		if(maxs[i]!=' ')
			cout<<maxs[i];
	return 0;
}
```


---

## 作者：学思悟行 (赞：12)

**我的第一个的题解（想想有点激动）**


------------
- 这道题目可以用字符串轻松解决（~~~~然而我做了2天)  
言归正传，上代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
main()
{
	//freopen("testdata.in","r",stdin);
	char a[21][101];
	int c[21]={0};
	int i,n,j;
	cin>>n;
	for(i=0;i<=n;i++)
	{
		gets(a[i]);
	}//读入
	int max=strlen(a[1]);
	/*整个比较共采用两次筛查，第一次用字符长度，将不合数位的数全数排除
	以解决不同数位的比较，第二次则是从低位到高位依次比较，最终得出结果*/
	for(i=2;i<=n;i++)
	{
		if(strlen(a[i])>max)
		{
			max=strlen(a[i]);
		}
	}//max表示最大数位，以便我们后面以数位的筛查
	for(i=1;i<=n;i++)
	{
		if(strlen(a[i])==max)
		{
			c[i]=1;
		}
	}//c数组用于标记，排除不同数位的票数
	//接下来是比较部分
	for(i=1;i<=n;i++)
	{
		if(c[i]==1)
		{
			for(j=1;j<=n;j++)//第二个for是为了找到比较数
			{
				if(c[j]==1)
				{
					for(int s=0;s<=max;s++)
					{
						if(a[i][s]==a[j][s])
						continue;//如果该位数上数字相同则跳过
						if(a[i][s]>a[j][s])
						{
							c[j]=0;//将该数取消标记
						}
						if(a[i][s]<a[j][s])
						{
						    //其实这里可以直接改为else
							c[i]=0;
							break;
						}
					}
				}
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		if(c[i]==1)
		cout<<i<<endl<<a[i];//最后还在标记的数即为最大票数了AWA
	}
	//fclose(stdin);
}
```

---

## 作者：LPA20020220 (赞：9)

这里我压了一个namespace, 基本上可以做模板了（感谢网上高人 ** 代号4101** 的指导  [戳这里](http://my.csdn.net/DaiHaoC83E15) ），还支持sort。

不过仍须完善，例如当前版本不支持负数，需要特判等等。

代码如下

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
namespace BigInteger
{
#define maxn 10005
using std::sprintf;
using std::string;
using std::max;
using std::istream;
using std::ostream;

struct Big_integer{  
    int d[maxn], len;  
  
    void clean() 
	{ 
	while(len > 1 && !d[len-1]) 
	len--;
	}  
  
    Big_integer()          { memset(d, 0, sizeof(d)); len = 1; }  
    Big_integer(int num)   { *this = num; }   
    Big_integer(char* num) { *this = num; }  
    Big_integer operator = (const char* num){  
        memset(d, 0, sizeof(d)); len = strlen(num);  
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';  
        clean();  
        return *this;  
    }  
    
    Big_integer operator = (int num){  
        char s[10005]; sprintf(s, "%d", num);  
        *this = s;  
        return *this;  
    }  
  
    Big_integer operator + (const Big_integer& b){  
        Big_integer c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] += b.d[i];  
            if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;  
        }  
        while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;  
        c.len = max(len, b.len);  
        if (c.d[i] && c.len <= i) c.len = i+1;  
        return c;  
    }  
    
    Big_integer operator - (const Big_integer& b){  
        Big_integer c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] -= b.d[i];  
            if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;  
        }  
        while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;  
        c.clean();  
        return c;  
    }  
    
    Big_integer operator * (const Big_integer& b)const{  
        int i, j; Big_integer c; c.len = len + b.len;   
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++)   
            c.d[i+j] += d[i] * b.d[j];  
        for(i = 0; i < c.len-1; i++)  
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;  
        c.clean();  
        return c;  
    }  
    
    Big_integer operator / (const Big_integer& b){  
        int i, j;  
        Big_integer c = *this, a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            c.d[i] = j;  
            a = a - b*j;  
        }  
        c.clean();  
        return c;  
    }  
    
    Big_integer operator % (const Big_integer& b){  
        int i, j;  
        Big_integer a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            a = a - b*j;  
        }  
        return a;  
    }  
    
    Big_integer operator += (const Big_integer& b){  
        *this = *this + b;  
        return *this;  
    }  
  
    bool operator <(const Big_integer& b) const{  
        if(len != b.len) return len < b.len;  
        for(int i = len-1; i >= 0; i--)  
            if(d[i] != b.d[i]) return d[i] < b.d[i];  
        return false;  
    }  
    bool operator >(const Big_integer& b) const{return b < *this;}  
    bool operator<=(const Big_integer& b) const{return !(b < *this);}  
    bool operator>=(const Big_integer& b) const{return !(*this < b);}  
    bool operator!=(const Big_integer& b) const{return b < *this || *this < b;}  
    bool operator==(const Big_integer& b) const{return !(b < *this) && !(b > *this);}  
  
    string str() const{  
        char s[maxn]={};  
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';  
        return s;  
    }  
};  
  
istream& operator >> (istream& in, Big_integer& x)  
{  
    string s;  
    in >> s;  
    x = s.c_str();  
    return in;  
}  
  
ostream& operator << (ostream& out, const Big_integer& x)  
{  
    out << x.str();  
    return out;  
}  
}
using namespace BigInteger;
using namespace std;
struct use
{
	Big_integer a;
	int num;
	bool operator < (const use &x)const
	{
		return a < x.a;
	}
};
use data[21];
int main()
{
	int cnt;
	scanf("%d", & cnt);
	for (int i = 1; i <= cnt; ++i)
		cin >> data[i - 1].a, data[i - 1].num = i;
	sort(data, data + cnt);
	printf("%d\n", data[cnt - 1].num), cout << data[cnt - 1].a;
	return 0;
}
```

---

## 作者：影のない霜跡 (赞：7)

这道题目，刚开始看的时候以为是高精度 **（100位！！！）** ，后来一想：
~~那么麻烦干什么，~~ 用字符串不好吗？然后......我就用**字符串+结构体**做出来了

然后......我拿了80分？？？


## **代码：**
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
struct da{int num;string xp;}a[20];//结构体
int n;
int bj(string x,string y)//比较字符串（字典序）
{
    if(x.size()>y.size())return 1;
    if(x.size()<y.size())return -1;
    for(int i=0;i<x.size();i++)
    {
        if(x[i]<y[i])return -1;
        if(x[i]>y[i])return 1;
    }
    return 0;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].xp;//输入选票
		a[i].num=i;//标记号码
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(bj(a[j].xp,a[i].xp)==-1)swap(a[j],a[i]);//排序
	printf("%d\n",a[1].num);//输出号码
	cout<<a[1].xp;//输出选票
	return 0;
}
```

WA后的下一秒，我就意识到：a[20]下标为0~19......~~（OMG）~~ 低级错误

然后......我就~~理所当然地~~AC了

## 满分代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
struct da{int num;string xp;}a[25];//就改了这玩意儿
int n;
int bj(string x,string y)
{
    if(x.size()>y.size())return 1;
    if(x.size()<y.size())return -1;
    for(int i=0;i<x.size();i++)
    {
        if(x[i]<y[i])return -1;
        if(x[i]>y[i])return 1;
    }
    return 0;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].xp;
		a[i].num=i;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(bj(a[j].xp,a[i].xp)==-1)swap(a[j],a[i]);
	printf("%d\n",a[1].num);
	cout<<a[1].xp;
	return 0;
}
```

# 这次惨痛的教训告诉我们：以后要认真看题（尤其是数据范围）......

---

## 作者：zhoulan119 (赞：7)

# 都没有人肯用STL模板吗？
## 都没有人肯用STL模板吗？
### 都没有人肯用STL模板吗？
### 都没有人肯用STL模板吗？
#### 都没有人肯用STL模板吗？
##### 都没有人肯用STL模板吗？
###### 都没有人肯用STL模板吗？

感叹完毕，解释一下用STL模板完成这道题的乐趣

**STL的String库支持直接用大于号、等于号、小于号比较！**

也就是说，仅仅考虑此道题，用STL可以愉快的解决。没错你没有看错，不用**高精度**！下面是19行的C++代码

^__^ 笑一个

---

```cpp

#include <iostream>
#include <string>

using namespace std;

string space;
int n;

int main(){
	cin >> n;
	string max = "0";
	int num = 1;
	for(int i=1;i<=n;i++){
		cin >> space;
		if(space.size()>max.size()||space > max&&space.size()>=max.size()){//比较大小和长度（优先考虑长度，否则比较的是前半段）
			max = space;
			num=i;
		}
	}	
	cout << num << endl << max;
	return 0;
}

```

AC证明：[戳我](https://www.luogu.org/record/21910338)


---

## 作者：gdjcwsk (赞：5)

~~本蒟蒻第三次发题解，~~此次题解仅供参考，有什么问题请大家批评指正！！！

本题主要思路：永远不要忘记这道题需要高精！！~~用sort的人就GG了~~

怎么摆脱高精的困境呢？首先我们得运用字符串~~（这是老规矩）~~，然后定义一个函数来比较两个字符串的大小（把他们当成整数比较），这一步非常关键。后面就简单了。

如果还不懂的话，请看我的代码注释。

废话不多说，先请出代码君：
```cpp
#include <bits/stdc++.h>
using namespace std;
string a[10005],maxn,z;
string bj(string x,string y)//比较大小的函数
{
    if(x.length()>y.length())//先比较位数
    {
        return x;
  
  }
    else if(x.length()<y.length())
    {
        return y;
    }
    int l=x.length();
    for(int i=0;i<l;i++)//如果位数一样，那就从高往低位比
    {
        if(x[i]>y[i])
        {
            return x;
        }
        else if(x[i]<y[i])
        {
            return y;
        }
    }
    return z;
}
int main()
{
    int n,nu=0;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    maxn=a[0];//因为sort不能用于字符串上，所以我改用打擂台法
    for(int i=1;i<n;i++)
    {
        if(bj(maxn,a[i])==z||bj(maxn,a[i])==maxn)
        {
            continue;
        }
        maxn=a[i];
        nu=i;
    }
    cout<<nu+1<<endl<<maxn;
    return 0;
}
```
这就是本蒟蒻的P1781题解，如果有什么问题，请尽快和我沟通或者在评论区留言。

谢谢各位！

---

## 作者：小周猪猪 (赞：5)

这道题考察的地方就是字符串的比大小

因为最终要求得的答案就是一些数据的最大值

而根据题意，某些数据的最大值会超过整数最大数据类型的范围

所以要用字符串来存储

而字符串比大小的方法就是

1.如果两者的字符串长度不同，则长度长的数值较大

2.如果两者的字符串长度相同，则直接用字符串的Ascii码比大小即可（不过你得了解两个字符串如何用ASCII码直接比大小）

然后用变量max直接存储最大值，用变量t直接存储最大值的标号，最后输出即可

------------------------------------------------------------------------------------------------------------------------------------------------

pascal的代码：

```cpp
var n,i,t:longint;
    max,k:string;
begin
  readln(n);//输入存储数据的组数
  for i:=1 to n do
  begin
    readln(k);//输入第i各数据k
    if length(k)>length(max) then
      begin
        max:=k;
        t:=i;
      end;//比较在不同长度下字符串的大小
    if length(k)=length(max) then
      if k>max then 
        begin
          max:=k;
          t:=i;
        end;//比较相同的长度下字符串的大小
  end;
  writeln(t);//输出编号t
  writeln(max);//输出最大值max
end.
```
-----------------------------------------------------------------------------------------------------------------------------------------------
c++的代码

```cpp
  #include<bits/stdc++.h>//传说中的万能头文件 
using namespace std;
int main()
{
    int n,t;
    string max="",k;//定义的变量max要赋初始值 
    cin>>n;//输入要求的组数 
    for (int i=1;i<=n;i++)
    {
        cin>>k;//输入第i个数据k 
        if (k.size()>max.size()) 
        {
            max=k;
            t=i;
```
}//比较长度相同的字符串的大小
```cpp
        if (k.size()==max.size())
          if (k>max)
          {
              max=k;
              t=i;
```
}//比较长度不同的字符串的大小
```cpp
    }
    cout<<t<<endl<<max;//最后输出编号t和最大值max 
    return 0;//程序结束 
}
```
------------------------------------------------------------------------------------------------------------------------------------------------
ok，代码仅供参考，不要抄袭，希望我的题解会对你有帮助，谢谢！



---

## 作者：W_px (赞：4)

#题解......

##思路分析 此题其实并不难，方法有很多种（看看楼下就知道了）。本水解就介绍一种**比较**省空间的方法：用string类型计算票数，默认最大票数为‘0’，再根据string类型的大小比较特性（位数一样直接比，位数不一比位数）进行比较,边读入，便比较，不断刷新最高票数。

###【代码已上线】


```cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int n,Max_=-1;//Max_:最大票数获得者编号
    string a,max_="0";//max_存储最大票数，初始值为0
    cin>>n;读入候选人个数n
    for(int k=1;k<=n;k++)
    {
        cin>>a;//读入票数
        if(a.length()>max_.length()){max_=a;Max_=k;}//先比较位数
        if((a.length()==max_.length())&&(a>max_)){max_=a;Max_=k;}//如果位数一样，则直接比较大小
    }
    cout<<Max_<<endl<<max_;//输出...要换行哦^_^
}
```

---

## 作者：Sinwind (赞：3)

# 1.分析

0. 高精度：

- 什么是高精度？顾名思义，精度非常高$(PS:$这不废话$)$。

- 有时，有的数的位数太多，远远超过$long\space long$的范围$(9E18)$，此时通常用$char$型数组或$string$对数进行模拟，每一位存储一位数字，整个$char$型数组或$string$就可以存储一个很大的数，称为高精度数。

- 此时，高精度数的算法要单独设计$($主要是模拟$)$，称为高精度算法。

1. $high\_accuracy$函数：高精度比较函数，若$x$号的得票大于$y$号，返回$true$；否则，返回$false$。

	此时$tickets[x]$的长度$x\_len$与$tickets[y]$的长度$y\_len$关系只有三种情况：

- $x\_len>y\_len,tickets[x]>tickets[y],return\space true$。

- $x\_len<y\_len,tickets[x]<tickets[y],return\space false$。

- $x\_len=y\_len$：遍历$tickets[x]$与$tickets[y](i\in [0,x\_len-1))$，有三种情况：

	- $tickets[x][i]>tickets[y][i],return\space true$。
    
    - $tickets[x][i]<tickets[y][i],return\space false$。
    
    - $tickets[x][i]=tickets[y][i]$，不做处理。

# 2.代码

```cpp
#include <iostream>
#include <string>

using namespace std;

int n;                  //参选人数
string tickets[25];     //候选人票数

//若x号得票大于y号，返回true；否则，返回false
bool high_accuracy(int x, int y)
{
	int x_len = tickets[x].length();
	int y_len = tickets[y].length();
	
	if(x_len > y_len)
	{
		return true;
	}
	else if (x_len < y_len)
	{
		return false;
	}
	else
	{
		for(int i = 0; i < x_len; i++)
		{
			if(tickets[x][i] > tickets[y][i])
			{
				return true;
			}
			else if(tickets[x][i] < tickets[y][i])
			{
				return false;
			}
		}
	}
	
	return false;
}

//比较，返回票数最多的候选人的下标
int comparison(void)
{
	int index = 0;
	
	for(int i = 1; i < n; i++)
	{
		if(high_accuracy(i, index))
		{
			index = i;
		}
	}
	
	return index;
}

int main(void)
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> tickets[i];
	}
	
	cout << comparison() + 1 << endl << tickets[comparison()];
	
	return 0;
}
```


---

## 作者：Forgetter (赞：3)

# Java
## 思路：
题目说了长度可能会到100，想也不想直接用String

然后遍历一次（冒一个泡）

比较的规则：
1. 比较票数的长度
2. 比较ASCII码的大小（其实就是用compareTo()）

挺简单的一题，直接看代码：

代码
------------
```java
import java.io.BufferedInputStream;
import java.util.Comparator;
import java.util.Scanner;

public class P1781 {
	public static void main(String[] args){ 
		int n,no ;	//n竞选的人数  no记录最多选票的总统号码 
		String[] str ;//存储输入数据
		String max;	//最大的选票
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		president pre = new president();
			n=sc.nextInt();  
			str = new String[n+1];	//多一个空间不算浪费吧-_-||
			for(int i=1;i<=n;i++)
				str[i] = sc.next();
			sc.close();
			
			//初始化
			no=1;	max = str[1];	
			//遍历一遍  冒一个泡 
			for(int i=2;i<=n;i++)
				if(pre.compare(max, str[i])>=0);
				else {	//新的值比之前的大
					no = i;
					max = str[i];
				}
			
			System.out.println(no);
			System.out.println(max);
	}
	
	//重写比较规则 优先级：1.比较长度  2.比较ASCII
	static class president implements Comparator<String>{
		@Override
		public int compare(String max, String xin) {	//最大值   新传进来的值
			//先比长度
			int len1 = max.length();
			int len2 = xin.length();
			if(len1!=len2)	
				return len1-len2;
			//(如果长度相等)再 从头比较 ASCII 码的大小
			else{
				return max.compareTo(xin);
			}
		}
	}

}

```

---

## 作者：Dillct (赞：3)

这道题我用的是选择排序的思想，因为只让求最大数，所以直接找出最大数即可。




    
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stdio.h>
#include<bits/stdc++.h>
using namespace std;
string num[21];
int n;
int nen(int i,int j)
{
    if(num[i].size()<num[j].size()) return 1;
    if(num[i].size()>num[j].size()) return 0;
    for(int h=0;h<num[i].size();h++)
    {
        if(num[i][h]>num[j][h]) return 0;
        if(num[i][h]<num[j][h]) return 1;
    } 
}
int main()
{
    cin>>n;  //输入
    for(int i=0;i<=n;i++)
    getline(cin,num[i]);
    int max=0;   //记录最大数的下标，也是总统候选人的编号
    for(int i=1;i<=n;i++)
    {
        if(nen(max,i)) max=i;  //如果下一个数比当前最大数大，那么下一个数成为当前最大数，nen为比较函数，
    }
    cout<<max<<endl;  //输出
    cout<<num[max];
    return 0;
}
```

---

## 作者：wogua (赞：3)

很简单的一题......






```cpp
program qsortstring;
var n:integer; s:array[0..20]of string; i,maxlen:integer;
begin
readln(n);
maxlen:=0;
for i:=1 to n do begin readln(s[i]);  if length(s[i])>maxlen then begin maxlen:=length(s[i]);s[0]:=s[i];end; end;                    //更新最多位数和暂时最大票数
for i:=1 to n do begin if (length(s[i])=maxlen)and(s[i]>s[0]) then s[0]:=s[i]; end;{更新最大票数}
for i:=1 to n do if (length(s[i])=maxlen)and(s[i]=s[0]) then begin writeln(i); break; {输出序号，放心，输入数据保证没有相同票数}end;
writeln(s[i])//输出票数最多总统
end.

```

---

## 作者：k2saki (赞：3)

####  P1781：宇宙总统

### 题意：n个数字，输出最大的数字和编号。

### 思路：我刚开始看到这个题的时候，认为这个题就是一个结构体排序的题，于是打了上去，后来才发现“票数可能会很大，可能会到100位数字。”这个条件，于是把结构体中的数字改成了字符串。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct zt{
	string a;
	int b;
}a[22];
int cmp(zt a,zt b){
	return a.a>b.a;
	
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i].a;
		a[i].b=i;
	}
	sort(a+1,a+n+1,cmp);
	cout<<a[1].b<<endl<<a[1].a;
} 
```

### 60分？因为字符串排序规则与数字不同，所以，如果要从大到小排序，必须先判断长度，再判断大小。这是此题的一个大坑点。

# 附AC代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct zt{
	string a;
	int b;
}a[22];
int cmp(zt a,zt b){
	if(a.a.size()==b.a.size())//先判断位数
	{
		return a.a>b.a;
	}
	else
	{
		return a.a.size()>b.a.size();
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i].a;
		a[i].b=i;//序号
	}
	sort(a+1,a+n+1,cmp);
	cout<<a[1].b<<endl<<a[1].a;
} 
```



---

## 作者：wuliang1 (赞：3)

//数很大只能用字符串处理，只要判断他的长度是不是大于他或者两者相等时strcmp（a,b)>0，也就是c++string里的a>b

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<string>
using namespace std;
string a,b="0";
int maxi=0;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a;
        if(a.length()>b.length()||(a.length()==b.length()&&a>b))//关键这一句判断
           {
               b=a;
               maxi=i;
           }
    }
    cout<<maxi<<endl;
    cout<<b<<endl;
}

```

---

## 作者：optimize_2 (赞：2)

## 思路清奇的做法

安利zhy123456神犇的blog:[高精度模板](https://www.luogu.org/blog/zhy123456/gao-jing-lei-mu-ban-wei-wan-post)

有了这个,就可以很容易的切掉高精题啦:-)

以下是模板:
```
namespace Bigint
{
    class bigint
    {
    private:
        int value[10005];
        short leng;
        bool fuhao;
        bigint plus(bigint a);
        friend bigint minus(bigint a, bigint b);
        bigint cheng(int a);
    public:
        bigint(int n);
        bigint();
        int length() { return leng; }
        friend std::ostream& operator << (std::ostream& output, bigint c);
        friend std::istream& operator >> (std::istream&, bigint&);
        friend bigint operator+(bigint a, bigint b);
        friend bigint operator+(bigint a, int b);
        friend bigint operator+(int a, bigint b);
        friend bigint operator-(bigint a, bigint b);
        friend bigint operator-(bigint a, int b);
        friend bigint operator-(int a, bigint b);
        friend bool operator>(bigint a, bigint b);
        friend bool operator>(bigint a, int b);
        friend bool operator>(int a, bigint b);
        friend bool operator<(bigint a, bigint b);
        friend bool operator<(bigint a, int b);
        friend bool operator<(int a, bigint b);
        friend bool operator==(bigint a, bigint b);
        friend bool operator==(bigint a, int b);
        friend bool operator==(int a, bigint b);
        friend bool operator>=(bigint a, bigint b);
        friend bool operator>=(bigint a, int b);
        friend bool operator>=(int a, bigint b);
        friend bool operator<=(bigint a, bigint b);
        friend bool operator<=(bigint a, int b);
        friend bool operator<=(int a, bigint b);
        friend bool operator!=(bigint a, bigint b);
        friend bool operator!=(bigint a, int b);
        friend bool operator!=(int a, bigint b);
        friend bigint operator<<(bigint a,int b);
        friend bigint operator>>(bigint a, int b);
        friend bigint operator*(bigint a, bigint b);
        friend bigint operator*(bigint a, int b);
        friend bigint operator*(int a, bigint b);
        friend bigint operator/(bigint a, bigint b);
        friend bigint operator/(bigint a, int b);
        friend bigint operator/(int a, bigint b);
        friend bigint operator%(bigint a, bigint b);
        friend bigint operator%(bigint a, int b);
        friend bigint operator%(int a, bigint b);
        friend bigint operator+=(bigint &a, bigint b);
        friend bigint operator+=(bigint &a, int b);
        friend int operator+=(int &a, bigint b);
        friend bigint operator-=(bigint &a, bigint b);
        friend bigint operator-=(bigint &a, int b);
        friend int operator-=(int &a, bigint b);
        friend bigint operator<<=(bigint&a, int b);
        friend bigint operator>>=(bigint&a, int b);
        friend bigint operator*=(bigint &a, bigint b);
        friend bigint operator*=(bigint &a, int b);
        friend bigint operator*=(int &a, bigint b);
        friend bigint operator/=(bigint &a, bigint b);
        friend bigint operator/=(bigint &a, int b);
        friend bigint operator/=(int &a, bigint b);
        friend bigint operator%=(bigint &a, bigint b);
        friend bigint operator%=(bigint &a, int b);
        friend bigint operator%=(int &a, bigint b);
        bigint operator++();
        bigint operator++(int);
        bigint operator--();
        bigint operator--(int);
        bool operator!();//气势磅礴的运算符重载
        operator int();
        //  operator long long();
        //  operator short();
    };
    bigint::bigint(int n)
    {
        for (int i = 0; i < 10005; i++)value[i] = 0;
        if (n >= 0)fuhao = true;
        else fuhao = false;
        n = n >= 0 ? n : -n;
        for (leng = 1; n; leng++, n /= 10)value[leng] = n % 10;
        leng--;
    }
    bigint::bigint()
    {
        for (int i = 0; i < 10005; i++)
            value[i] = 0;
        leng = 0;
        fuhao = true;
    }
    //输出
    std::ostream& operator << (std::ostream& output, bigint c)
    {
        if (c.leng == 0)
        {
            std::cout << 0;
            return output;
        }
        if (c.fuhao == false)output << '-';
        for (int i = c.leng; i > 0; i--)output << c.value[i];
        return output;
    }
    //输入
    std::istream& operator >> (std::istream& input, bigint& c)
    {
        std::string s;
        input >> s;
        int i = s.length(), j = 0;
        c.leng = s.length();
        if (s[j] == '-')
        {
            j++;
            c.fuhao = false;
            c.leng--;
            i--;
        }
        else c.fuhao = true;
        for (; i > 0; i--, j++)c.value[i] = s[j] - '0';
        return input;
    }
    //大于
    bool operator>(bigint a, bigint b)
    {
        if (a.fuhao != b.fuhao)return a.fuhao;
        if (a.leng != b.leng)return (a.leng < b.leng) xor (a.fuhao);
        for (int i = a.leng; i > 0; i--)
            if (a.value[i] != b.value[i])
                return (a.value[i] < b.value[i]) xor a.fuhao;
        return false;
    }
   /*
    高精大于低精
    （不要说多余，加个构造函数就行了，
    这个程序既有低精转高精的构造函数，
    又有高精转低精的类型转换函数，
    编译器会报错有歧义，不知道是转换成高精比高精还是低精比低精，
    但是有了类型完全匹配的函数，
    编译器才不会想着转换类型，才会直接调用这个函数。）
    */
    bool operator>(bigint a, int b)
    {
        return a > bigint(b);
    }
    bool operator>(int a, bigint b)
    {
        return bigint(a) > b;
    }
    //小于
    bool operator<(bigint a, bigint b)
    {
        if (a.fuhao != b.fuhao)return b.fuhao;
        if (a.leng != b.leng)return (a.leng > b.leng) xor (a.fuhao);
        for (int i = a.leng; i > 0; i--)
            if (a.value[i] != b.value[i])
                return (a.value[i] > b.value[i]) xor a.fuhao;
        return false;
    }
    bool operator<(bigint a, int b)
    {
        return a < bigint(b);
    }
    bool operator<(int a, bigint b)
    {
        return bigint(a) < b;
    }
    //高精加高精（符号一样）
    //或高精减高精（符号不一样）
    bigint bigint::plus(bigint a)
    {
        bigint b;
        int max;
        if (leng > a.leng)max = leng;
        else max = a.leng;
        for (int i = 1; i <= max; i++)
        {
            b.value[i] += value[i] + a.value[i];
            b.value[i + 1] = b.value[i] / 10;
            b.value[i] %= 10;
        }
        if (b.value[max + 1] == 0)b.leng = max;
        else b.leng = max + 1;
        b.fuhao = fuhao;
        return b;
    }
    //高精加高精（符号不一样）
    //或高精减高精（符号一样）
    bigint minus(bigint a, bigint b)
    {
        bigint c;
        c.fuhao = a.fuhao;
        a.fuhao = 1;
        b.fuhao = 1;
        if (a < b)
        {
            bigint d = a;
            a = b;
            b = d;
            c.fuhao ^= 1;
        }
        for (int i = 1; i <= a.leng; i++)
        {
            c.value[i] += a.value[i] - b.value[i];
            if (c.value[i] < 0)
            {
                c.value[i + 1]--;
                c.value[i] += 10;
            }
        }
        for (int i = a.leng; i > 0; i--)
        {
            if (c.value[i] != 0)
            {
                c.leng = i;
                return c;
            }
        }
        c.leng = 0;
        c.fuhao = true;
        return c;
    }
    //加
    bigint operator+(bigint a, bigint b)
    {
        bigint c;
        if (!a.fuhao^b.fuhao)
        {
            c.fuhao = a.fuhao;
            c = a.plus(b);
        }
        else
        {
            b.fuhao ^= 1;
            c = minus(a, b);
        }
        return c;
    }
    bigint operator+(bigint a, int b)
    {
        return a + bigint(b);
    }
    bigint operator+(int a, bigint b)
    {
        return bigint(a) + b;
    }
    //减
    bigint operator-(bigint a, bigint b)
    {
        bigint c(0);
        if (!a.fuhao^b.fuhao)
        {
            c.fuhao = a.fuhao;
            c = minus(a, b);
        }
        else
        {
            b.fuhao ^= 1;
            c = a.plus(b);
        }
        return c;
    }
    bigint operator-(bigint a, int b)
    {
        return a - bigint(b);
    }
    bigint operator-(int a, bigint b)
    {
        return bigint(a) - b;
    }
    //等于
    bool operator==(bigint a, bigint b)
    {
        if (a.fuhao != b.fuhao)return false;
        if (a.leng != b.leng)return false;
        for (int i = 1; i <= a.leng; i++)if (a.value[i] != b.value[i])return false;
        return true;
    }
    bool operator==(bigint a, int b)
    {
        return a == bigint(b);
    }
    bool operator==(int a, bigint b)
    {
        return bigint(a) == b;
    }
    //大于等于
    bool operator>=(bigint a, bigint b)
    {
        return !(a < b);
    }
    bool operator>=(bigint a, int b)
    {
        return !(a < bigint(b));
    }
    bool operator>=(int a, bigint b)
    {
        return !(bigint(a) < b);
    }
    //小于等于
    bool operator<=(bigint a, bigint b)
    {
        return !(a > b);
    }
    bool operator<=(bigint a, int b)
    {
        return !(a > bigint(b));
    }
    bool operator<=(int a, bigint b)
    {
        return !(bigint(a) > b);
    }
    //自增（前置）
    bigint bigint::operator++()
    {
        *this = *this + 1;
        return *this;
    }
    //自增（后置）
    bigint bigint::operator++(int)
    {
        bigint a = *this;
        *this = *this + 1;
        return a;
    }
    //自减（前置）
    bigint bigint::operator--()
    {
        *this = *this - 1;
        return *this;
    }
    //自减（后置）
    bigint bigint::operator--(int)
    {
        bigint a = *this;
        *this = *this - 1;
        return a;
    }
    //高精转换成低精
    //（在不溢出的情况下
    //位数尽可能多）
    bigint::operator int()
    {
        int a = 0;
        for (int i = 9; i > 0; i--)
        {
            a *= 10;
            a += value[i];
        }
        int b = 0;
        for (int i = 10; i > 0; i--)
        {
            b *= 10;
            b += value[i];
        }
        int c;
        if (b < 0)c = a;
        else c = b;
        if (fuhao)return c;
        else return -c;
    }
    bool operator!=(bigint a, bigint b)
    {
        return !(a == b);
    }
    bool operator!=(bigint a, int b)
    {
        return !(a == bigint(b));
    }
    bool operator!=(int a, bigint b)
    {
        return !(bigint(a) == b);
    }
    //高精乘一位数（正数）
    bigint bigint::cheng(int a)
    {
        bigint b;
        for (int i = 1; i <= leng; i++)b.value[i] = value[i] * a;
        for (int i = 1; i <= leng; i++)if (b.value[i] > 9)
        {
            b.value[i + 1] += b.value[i] / 10;
            b.value[i] %= 10;
        }
        b.fuhao = true;
        for (int i = leng + 1; i > 0; i--)
        {
            if (b.value[i])
            {
                b.leng = i;
                return b;
            }
        }
        b.leng = 0;
        return b;
    }
    bigint operator<<(bigint a, int b)
    {
        for (int i = a.leng + b; i > b; i--)a.value[i] = a.value[i - b];
        for (int i = b; i > 0; i--)a.value[i] = 0;
        a.leng += b;
        return a;
    }
    bigint operator>>(bigint a, int b)
    {
        for (int i = 1; i <= a.leng - b; i++)a.value[i] = a.value[i + b];
        for (int i = a.leng - b + 1; i <= a.leng; i++)a.value[i] = 0;
        a.leng -= b;
        if (a.leng < 0)a.leng = 0;
        return a;
    }
    //高精乘
    bigint operator*(bigint a, bigint b)
    {
        if (a == 0 || b == 0)return bigint(0);
        bigint c;
        for (int i = 1; i <= b.leng; i++)
        {
            bigint d = a.cheng(b.value[i])<<(i-1);
            c += d;
        }
        c.fuhao = !(a.fuhao^b.fuhao);
        for(int i=a.leng+b.leng;i>0;i--)
            if (c.value[i] != 0)
            {
                c.leng = i;
                break;
            }
        return c;
    }
    bigint operator*(bigint a, int b)
    {
        return bigint(b)*a;
    }
    bigint operator*(int a, bigint b)
    {
        return bigint(a)*b;
    }
    bigint operator/(bigint a, bigint b);
    bigint operator/(bigint a, int b);
    bigint operator/(int a, bigint b);
    bigint operator%(bigint a, bigint b);
    bigint operator%(bigint a, int b);
    bigint operator%(int a, bigint b);
    bigint operator+=(bigint &a, bigint b)
    {
        a = a + b;
        return a;
    }
    bigint operator+=(bigint &a, int b)
    {
        a = a + bigint(b);
        return a;
    }
    int operator+=(int &a, bigint b)
    {
        a = int(bigint(a) + b);
        return a;
    }
    bigint operator-=(bigint &a, bigint b)
    {
        a = a + b;
        return a;
    }
    bigint operator-=(bigint &a, int b)
    {
        a = a + bigint(b);
        return a;
    }
    int operator-=(int &a, bigint b)
    {
        a = int(bigint(a) + b);
        return a;
    }
    bigint operator<<=(bigint&a, int b)
    {
        a = a << b;
        return a;
    }
    bigint operator>>=(bigint&a, int b)
    {
        a = a >> b;
        return a;
    }
    bigint operator*=(bigint &a, bigint b)
    {
        a = a * b;
        return a;
    }
    bigint operator*=(bigint &a, int b)
    {
        a = a * b;
        return a;
    }
    bigint operator*=(int &a, bigint b)
    {
        a = int(a*b);
        return a;
    }
    bigint operator/=(bigint &a, bigint b);
    bigint operator/=(bigint &a, int b);
    bigint operator/=(int &a, bigint b);
    bigint operator%=(bigint &a, bigint b);
    bigint operator%=(bigint &a, int b);
    bigint operator%=(int &a, bigint b);
    bool bigint::operator!()
    {
        return *this == bigint(0);
    }
}
```
可以看见,里面自带了```friend bool operator>(bigint a, bigint b);```.

这道题需要输出最多选票者的编号,所以需要定义两个$ans$,$ans_1$代表当前选票最多的人的编号,$ans_2$代表当前选票最多的人获得的选票.

然后主程序是这样的:
```
using namespace std;
using namespace Bigint;

int n,ans1;
bigint tmp,ans2;

int main()
{
	//freopen(".in","r",stdin),freopen(".out","w",stdout);
	//ios_base::sync_with_stdio(0),cin.tie(NULL);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>tmp;
		if(tmp>ans2)
		{
			ans2=tmp;
			ans1=i;
		}
	}
	cout<<ans1;
	puts("");
	cout<<ans2;
	return 0;
}
```
就这么AC了

~~模板真好用~~

---

## 作者：Apojacsleam (赞：2)

    一道高精度排序的模板题。

    本来我是自定义一个结构体，然后用operator定义一下小于号，最后排序的。
    
    然而。我写出来了以后才发现，用string是那么的简单。
    
    下面的代码是我写的自定义结构体高精排序代码（不是题解！）。
    
    大家可以当做板子食用，如有错误请联系我：
    
```cpp
/*
	Coded by Apojacsleam
*/
#include<cstdio>
#include<cstring>
#include<cctype>
#include<cmath>
#include<algorithm>
#include<iostream>
#define MaxSize 10 
using namespace std;
struct BigInteger{
	char num[(const int)MaxSize];
	int len;
	inline void Swap_BigInteger(char &BigIntegera,char &BigIntegerb)
	{
		swap(BigIntegera,BigIntegerb);
	}
	inline void Clean_BigInteger(bool Clean_num)
	{
		len=-1;
		if(Clean_num) memset(num,0,sizeof(num)); 
	}
	void Input()
	{
		Clean_BigInteger(false);
		char ch=0;
		for(;!isdigit(ch);ch=getchar());
		for(;isdigit(ch);ch=getchar()) num[++len]=ch-'0';
		for(register int i=0;i<=(len>>1);i++)  Swap_BigInteger(num[i],num[len-i]);
		return;
	}
	void Output(char ch)
	{
		for(register int i=len;i>=0;i--)  putchar(num[i]+'0');
		putchar(ch);
	}
	bool operator == (const BigInteger &A)
	{
		if(A.len!=len) return false;
		else
		{
			for(register int i=A.len;i>=0;i--)
			  if(A.num[i]!=num[i]) return false;
			return true;
		}
	}
	bool operator <= (const BigInteger &A)
	{
		if(len>A.len) return false;
		else if(len<A.len) return true;
		else
		{
			for(register int i=A.len;i>=0;i--)
			  if(num[i]>A.num[i]) return false;
			  else if(num[i]<A.num[i]) return true;
			return true;
		}
	}
	bool operator != (const BigInteger &A)
	{
		return !(*this==A);
	}
};
bool cmp(BigInteger a,BigInteger b)
{
	return a<=b;
}
BigInteger a[100001];
int main()
{
	int n;
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	  a[i].Input();
	sort(a+1,a+n+1,cmp);
	for(register int i=1;i<=n;i++) a[i].Output(' '); 
	return 0;
}
```
    
    用string怎么做呢？这就用到了幼儿园的比较知识：
    
    首先，如果两个数字的长度不同，那么长度长的肯定比长度短的大。
    
    如果两个数长度相等，只需要比较字典序就行了。
    
    代码如下：
```cpp
/*
	Coded by Apojacsleam
*/
#include<bits/stdc++.h>
using namespace std;
struct node{
	string s;
	int len,t;
}a[21];
bool cmp(node A,node B)
{
	if(A.len==B.len) return A.s<B.s;
	return A.len<B.len;
}
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].s;a[i].t=i;
		a[i].len=a[i].s.size();
	}
	sort(a+1,a+n+1,cmp);
	cout<<a[n].t<<endl<<a[n].s;
	return 0;
}

```

---

## 作者：WXS_ (赞：2)

```python
a=[]
b=[]
n = int(input())
for i in range(0,n):
    s = int(input())
    a.append(s)
    b.append(s)

a.sort()

ans = a[-1]
for i in range(0,n):
    if(b[i]==ans):
        print(i+1)
        break

print(ans)

```

---

## 作者：Makasukaka (赞：2)

本题看到100位的数据就用字符串了，看到N<=20就不打算用排序了，只是记录最大值，保证maxn与max中存储的一直为最大。最初我只是用了strcpy函数比较，但是发现位数不同的数比较就会有问题。所以又加了一个strlen。保证只是位数相同的才比较，不同的直接pass。本人蒟蒻，代码繁杂，大牛们多指教。

```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    char s[21][102],max[102];
    int len1,len2,n,maxn;
    scanf("%d",&n);
    scanf("%s",s[1]);
    maxn=1;
    len1=strlen(s[1]);
    strcpy(max,s[1]);
    for(int i=2;i<=n;i++)
    {
        scanf("%s",s[i]);
        len2=strlen(s[i]);
        if(len1==len2)
        {
        if(strcmp(s[i-1],s[i])>0)
            continue;
        if(strcmp(s[i-1],s[i])<0&&i<n)
        {
            len1=strlen(s[i]);
            maxn=i;
            strcpy(max,s[i]);
        }
        }
        else
        if(len1>len2)continue;
        else
        {
            len1=strlen(s[i]);
            maxn=i;
            strcpy(max,s[i]);
        }
    }
    printf("%d\n%s",maxn,max);
    return 0;
}
```

---

## 作者：chuxiaoyang (赞：2)

为什么大家都在排序？

这道题不是只要输出最大不就好了？

```cpp
#include<iostream>
using namespace std;
bool compares(string a,string b)
{ int lea=a.length();
  int leb=b.length();
  int i;
  if(lea>leb)return true;
  if(lea<leb)return false;
  for(i=0;i<=lea-1;i++)
  {
      if(a[i]>b[i])return true;
      if(a[i]<b[i])return false;
  }
}
int main(void)
{
    string max,tem;
    int mi,i,j,tens,n;
    cin>>n;
    max="0";
    mi=0;
    for(i=1;i<=n;i++)
    {
     cin>>tem;
     if(compares(tem,max)){
     max=tem;
     mi=i;
     }
    }
   cout<<mi<<endl;
   cout<<max; 
}
```

---

## 作者：我好菜啊呜呜 (赞：2)

java选手无所畏惧


```java
import java.math.BigInteger;
import java.util.Scanner;


public class Main {

	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int n=input.nextInt();
		BigInteger num[]=new BigInteger[n];
		for(int i=0;i<n;i++)
			num[i]=input.nextBigInteger();
		int max_num=0;
		BigInteger max=num[0];
		for(int i=1;i<n;i++){
			if(num[i].compareTo(num[max_num])>0){
				max=num[i];
				max_num=i;
			}
				
		}
		
		System.out.println(max_num+1);
		System.out.println(max);
		
		
	}
}

```

---

## 作者：浮尘ii (赞：2)

这是一道很典型的高精度比较排序问题，需要用到字符串。所以我用了C++的STL中的string类型。并且运用了STL中的sort函数排序，其中重难点就是重载比较函数，要将字符串模拟数字进行比较。先比较位数，如果位数相等，就用一般的字符串比较，就可以了。

```cpp

#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>

using namespace std;

const int N = 25;

struct node{
    int ID;            //编号 
    string Number;    //票数，因为很大，所以用字符串类型 
}P[N];//定义结构体，记录票数及编号 

inline bool Compare(const struct node &i, const struct node &j){//排序函数 
    if(i.Number.size() != j.Number.size())
        return i.Number.size() > j.Number.size() ;//先按数字位数进行比较 
    else 
        return i.Number > j.Number;//如果位数相等，从高位起向低位比较 
}//模拟数字比较 

int main(){
    int n;
    
    cin >> n;
    for(size_t i = 1; i <= n; i++){
        cin >> P[i].Number;
        P[i].ID = i;
    }//输入票数并记录编号 
    
    sort(P + 1, P + n + 1, Compare);//进行排序 
    
    cout << P[1].ID << endl << P[1].Number << endl;//输出票数第一的编号和票数 
    
    return 0;
}


```

---

## 作者：路边的水沟 (赞：2)

很简单的题目。核心想法就是字符串比较。

①首先比较字符串长度，长度长者大。

②若长度相同，则直接比较字符串。

附上核心代码:

```delphi

if (length(t)>length(ans)) or ((length(t)=length(ans)) and (t>ans)) then
    begin
    h:=i;  //h为答案号数。ans为答案。t为当前读入的字符串。
    ans:=t;
    end;

```

---

## 作者：KyrieIrving (赞：1)

我的基本思路很简单，就是用string类型打擂台比大小。这里涉及到多位数比大小的方
法，先比位数，位数相同比最高位数字大小，再依次往低位比，直到比出大小。需要住
意的事就是要记得更新数据，~~我就因为这事卡了半天~~，话不多说，贴代码

```cpp
#include<iostream>
#include<cstring>//头文件
using namespace std;
int main()
{
	int n,max,now,num;//ans是最终答案，max是最高票数的位数，now是当前票数的位数，num是最终答案的号码
	string s,ans;
	cin>>n;
	cin>>s;
	max=s.size();
	ans=s;
	num=1;
	for(int i=2;i<=n;i++)
	{
		cin>>s;
		now=s.size();//重新赋值
		if(max<now)
		{
			max=s.size();
			ans=s;
			num=i;//更新数据
		}//位数比较
		if(max==now)
		{
			for(int j=1;j<=max;j++)
			{
				if(s[j]>ans[j])
				{
					ans=s;
					num=i;//更新数据
					break;
				}
				if(s[j]<ans[j])
					break;//不要漏下
         }
		}//数字比较
	}
	cout<<num<<endl<<ans;
	return 0;
}
```

---

## 作者：王江睿 (赞：1)

### **这种题怎么看都像没难度，但实际挺难。**
1. .....看了一下题，不就找个最大值看序号吗，开始！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
   int a;
   cin>>a;
   int b[a];
   for(int i=0;i<a-1;i++)
   {
   	   cin>>b[i]*100+i+1;
   }
   sort(b,b+a);
   cout<<b[a-1]%100<<endl<<b[a-1]/100<<endl;
   return 0;
}
```
然后吗...全Unaccepted..

2. 100位！字符串吧
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
   int a;
   cin>>a;
   string s;
   string s1;
   cin>>s;
   int g=0;
   int f;
   int y;
   for(int i=0;i<a-1;i++)
   {
   	   cin>>deq1;
   	   int f=s.size();
   	   int y=s1.size();
       ......
   }
   cout<<g+1<<endl<<deq<<endl;
   return 0;
}
```
咋比较呢？

查书：strcmp，可以！

结果，编译错误。。。

3.正解代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
   int a;
   cin>>a;
   string deq;
   string deq1;
   cin>>deq;
   int g=0;
   int f;
   int y;
   for(int i=0;i<a-1;i++)
   {
   	   cin>>deq1;
   	   int f=deq.size();
   	   int y=deq1.size();
       if(y>f||(y>=f&&deq1>deq))
       {
          deq=deq1;
          g=i+1;
      }
   }
   cout<<g+1<<endl<<deq<<endl;
   return 0;
}
```
才发现字符串也可以比较，但比不了位数。


1、字符串比较：

strcmp （ no ）报错

自己比较
string1>=<string2  **?**

77比29838838383大  

这是为何呢？？

2.原理

字符串比较计算机是默认对齐高位所以

77

比

2983883838383

大

所以需要这样

string 1.size > string 2.size || ( string 1.size  = string 2.size  && string 1 > string 2) 









---

## 作者：gy5461 (赞：1)

```java
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.LinkedHashSet;
import java.util.Iterator;
import java.io.*;
import java.applet.*;
import  java.util.Collections.*;
public class Main {
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),m,index=1;
        BigInteger a,ans;
        ans=sc.nextBigInteger();
        for(int i=2;i<=n;i++){
            a=sc.nextBigInteger();
            if(a.compareTo(ans)>0){
                ans=a;
                index=i;
            }
        }
        System.out.println(index);
        System.out.println(ans);
    }
}

```

---

## 作者：zhaosizhe (赞：1)

Python3 代码：

```python3
def main():
    '主函数'
    # 读入 n
    n = int(input())
    # 设置初始票数
    ans = [-1, -1]
    # 读入接下来的 n 行
    for i in range(n):
        # 读入票数
        x = int(input())
        # 若比当前最大值大
        if x > ans[1]:
            # 更新编号和最大值
            ans[0] = i + 1
            ans[1] = x
    # 输出编号
    print(ans[0])
    # 输出票数
    print(ans[1])


if __name__ == '__main__':
    main()

```

---

## 作者：醉语梦 (赞：1)

###这道题主要就是字符串+排序 （当然我还用了结构体~）

这里分享一种手写排序的代码~

练习手写的可以看看~

#具体见代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<iostream>
#include<cstring>
using namespace std;
int n;
struct peo{//结构体 
    char ti[105];//票数 
    int le,nu;//票数的位数 号数 
}p[25];
void asort(int l,int r){//手写排序 
    if(l>=r) return;
    swap(p[l],p[rand()%(r-l+1)+l]);
    int i=l+1,lt=l,rt=r+1;
    while(i<rt){//位数大的在前 
        if(p[i].le==p[l].le) i++;
        else if(p[i].le>p[l].le) swap(p[i],p[lt+1]),lt++,i++;
        else swap(p[i],p[rt-1]),rt--;
    }
    swap(p[l],p[lt]);
    asort(l,lt-1);
    asort(rt,r);
}
int m(int x,int y){//比较票数大小 
    for(int j=1;j<=p[1].le;j++){
        if(p[x].ti[j]>p[y].ti[j]) return 1;
        if(p[x].ti[j]<p[y].ti[j]) return 0;
    }
    return 1;
}
int main(){
    scanf("%d ",&n);
    for(int i=1;i<=n;i++){
        gets(p[i].ti+1);
        p[i].le=strlen(p[i].ti+1);
        p[i].nu=i;
    }
    asort(1,n);
    int ma=1;//最大的号数 
    for(int i=2;p[i].le==p[1].le;i++)
        if(m(i,ma)) ma=i;//确定最终最大值 
    printf("%d\n",p[ma].nu);
    puts(p[ma].ti+1);
    return 0;
}
```

---

## 作者：Hydra_ (赞：1)

这道题目不需要高精度。

我觉得我的代码比较清晰，容易让入门新手弄懂。

核心思想就是用字符串读入超过 long long 范围的整数

排序的时候不能用sort函数，因为字符串的比较是一位位比较过去的，和整数的比较不一样，所以我们需要自己定义一个字符串的比较标准，就是这边的bool函数。

然后因为n的范围很小，以便读代码，我采用了选择排序。会冒泡的可以自己尝试一下哦。

注意：在交换的时候，记住要把序号和字符串同时交换；sort函数给结构体数组排序的时候不需要考虑两个同时交换。

上面上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct ss
{
    string s;//用字符串读入过大的整数
    int xh;//序号
};//结构体
bool hy(ss a,ss b)//用来判断两个字符串对应的数字大小
//也就是上文说到的我们自定义的字符串比较标准
{
    int l1=a.s.size();
    int l2=b.s.size();
    if(l1>l2) return true;
    if(l1<l2) return false;//先判断位数
    for(int i=1;i<=l1;i++)
    {
        if(a.s[i]>b.s[i])
        return true;
        if(a.s[i]<b.s[i])
        return false;
```
}//如果位数相等，就一位位判断过去
return true;//这里可以是true也可以是false，因为已经相等了

```cpp
}
int main()
{
    int n=0;
    ss a[23];//自定义一个数组
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].s;
        a[i].xh=i;
```
}//记录序号、读入字符串
for(int i=1;i<=n-1;i++)//这里数据少，选择排序就ok

```cpp
    for(int j=i+1;j<=n;j++)
    {
        if(!hy(a[i],a[j]))//如果要交换用swap函数交换
        {
            swap(a[i].s,a[j].s);
            swap(a[i].xh,a[j].xh);//记住都要交换
        }
    }
    cout<<a[1].xh<<endl<<a[1].s;/按照题目要求输出
    return 0;
}
```

---

## 作者：Tony_Chu_ (赞：1)

#不一定要用排序...

高精的思想其他题解已经说的很详细了(想偷懒吗喂)，string自带的大于号可以准确比较形如"41155"和“12345”（位数相同的数字字符串）的大小，所以我们只要先比较位数（位数大的票数肯定多）、再利用自带的大于号便能比较出票数大小(可以按这个思路重载大于号)

由于我们只需要**一位**总统，所以只需要筛出最大值就好了

so，此题不需要排序

附渣代码

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <array>
#include <map>
using namespace std;
int n;
string a0 = "0"; //a0是当前已发现的最大值，“0”保证初始值足够小
map<string,int> b;//本人比较懒所以懒得用结构体，就用map凑合一下
array<string,20> a; //这种用法是为了科普一下STL里array这一数据类型
//“几乎”等价于string a[20]; 区别在于array还提供迭代器什么的
int main()
{
    cin>>n;
    for(int i = 0;i<=n-1;i++)
    {
        cin>>a[i];
        b[a[i]] = i+1;
    }

    for(int i = 0;i<=n-1;i++) //在所有的候选人里挨个筛
    {
        if(a[i].size() > a0.size())  //比较位数
        {
            a0 = a[i];
        }
        else if(a[i].size() == a0.size()) //位数相同
        {
            a0 = a[i]>a0?a[i]:a0; //运用string自带的大于号
        }
    }
    cout<<b[a0]<<endl<<a0;
    return 0;
}
```

---

## 作者：鹭天 (赞：1)

很简单的一道比较字符串大小的题目，不知道为什么有很多人想到了高精度，我也想不通。。

```cpp
var
  s,s1,max:string;
  i,j,n,k,x,y:longint;
begin
  readln(n);
  readln(s);//不管怎么样，先输入一个。
  max:=s;//我先认为第一个最大，到后面比较了再说。
  for i:=2 to n do begin//因为已经输入了，所以是2 to n。
    readln(s);
    if (length(s)>length(max))or((length(s)=length(max))and(s>max)) then begin//比较字符串大小，如果长度都比max要大，那就更不用说了;如果长度相同，那就直接比较字符串的大小；如果长度也不相等，s也不必max大，那就是max比s大，不必记录。
      max:=s;//目前的最大值
      x:=i;//目前最大值的下标。
    end;
  end;
  writeln(x);
  writeln(max);
end.

```

---

## 作者：tuolei717 (赞：1)

# C++11题解,只要了解string类的大小于号的重载,代码很简洁,希望能帮到你们

```cpp11
#include <iostream>
#include <string>

int main()
{
    using namespace std;
    string piao[20]{};
    int n{};
    cin >> n >> piao[0];
    string *maxc{&piao[0]};  //记录最大数字串;
    int maxn{};  //记录最大编号;

    for(int i{1}; i < n; ++i)
    {
        cin >> piao[i];

        if(piao[i].size() == maxc->size() && piao[i] > *maxc)  //长度相等,则按字典比较大小;
        {
            maxc = &piao[i];  //指向数字大的类地址;
            maxn = i; //记录位置;
        }
        else if(piao[i].size() > maxc->size())  //长度不相等,长度大的串大;
        {
            maxc = &piao[i];
            maxn = i;
        }
    }

    cout << maxn + 1 << '\n' << *maxc << endl;  //因为从0开始,所以编号得加1;
}
```

---

## 作者：hxr_225 (赞：1)




```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
struct lon{       //由于C++的里面只要定义小于符号的结构体都可以sort，那么自己写个结构体就可以排序了
    string k;        
//储存选票用string，不一定要开数组，string有小于号，但是比较是直接扫描string比较的，所以下面的程序里面有位数比较
    int j;         //序号，与选票数始终为同对
};
bool operator < (const lon a, const lon b){
    if (a.k.size() != b.k.size()) return a.k.size() < b.k.size();        //位数比较，以及这儿可以直接用一行代码完成
    if (a.k < b.k) return true;
    else return false;
}
int main(){
    int n;
    lon m[25];
    cin >> n;
    for (int i = 0; i < n; i++){
        cin >> m[i].k;
        m[i].j = i + 1;
    }
    sort (m, m + n);        //C++的sort
    cout << m[n - 1].j << endl << m[n - 1].k;
    return 0;
}
```

---

## 作者：店长 (赞：1)

```cpp
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
using namespace std;
#define maxn 21
struct 
{
  string score;
  int num;
}pre[maxn];
int n;
int main()
{
  cin>>n;
  int i,j;
  for(i=1;i<=n;i++)
  {
    cin>>pre[i].score;
    pre[i].num=i;
  }
  int maxx=1;
  for(i=2;i<=n;i++)
  {
    if((pre[i].score).length()>(pre[maxx].score).length())
      maxx=i;
    if((pre[i].score.length()==pre[maxx].score.length())&&pre[i].score>pre[maxx].score)
        maxx=i;
  }
  cout<<pre[maxx].num<<endl;
  cout<<pre[maxx].score;
  system("pause");
  return 0;  
}
//还是我的看着比较清爽 比较长度与字典序就好了
```

---

## 作者：Zoewilly (赞：1)

看到好多用排序，还有高精，需要这么麻烦吗？本题要求输出最大值即可。根据数据范围可知需使用字符串储存数据，并记录字符串的最大长度，在所有满足最大长度的字符串中输出最大即可，方法：字符串比较。

本题需注意：当最大票数相同时需选择后面的人。

    
```cpp
var
    n,i,maxl                :longint;
    l                        :array[0..50] of longint;
    a                        :Array[0..50] of string;
    ans                        :string;
    ansn                    :longint;
begin
    readln(n);
    for i:=1 to n do
    begin
        readln(a[i]);
        l[i]:=length(a[i]);
        if l[i]>maxl then maxl:=l[i];
    end;
    ans:='';
    for i:=n downto 1 do if (a[i]>ans) and (l[i]=maxl) then 
    begin
        ans:=a[i];
        ansn:=i;
    end;
    writeln(ansn);
    write(ans);
end.
```

---

## 作者：smzzl (赞：1)

大水题啊根本不用排序，就是找出最大的票数，

就是字符串读入，然后先比较长短，长的大，一样长就比较大小，字符串一样长是可以直接比较的

其次就是有一点害得我80分，就是如果后一个等于前一个要把总统给他

```pascal
program fads;
var st:array[0..100] of string;
    i,j,k,l,n,m,o,p,x,t:longint;
    max:string;
begin
readln(n);
for i:=1 to n do readln(st[i]);
max:=st[i];
for i:=2 to n do
  begin
  p:=0;
  if length(max)<=length(st[i]) then p:=1
      else
        if length(max)=length(st[i]) then
          if max**<=**st[i] then p:=1;
  if p=1 then begin x:=i; max:=st[i]; end;
  end;
writeln(x);
writeln(max);
end.
```

---

## 作者：，。？！ (赞：1)

其实……把票数当成字符串输入然后字符串排序就好了，排序依据主要是字符串长度，长度大的成绩大，长度一样的话就直接字符串大于小于就好了。



```cpp
[codec ]#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct nodde{
  friend bool operator < (nodde n1, nodde n2){  return n1.j.length() < n2.j.length() ? true : n1.j.length()==n2.j.length()? n1.j<n2.j:false; }
  int hao;
  string j;
};
nodde z[1000000];
int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        z[i].hao=i;cin>>z[i].j;
    }
    sort(z+1,z+n+1);
    cout<<z[n].hao<<endl<<z[n].j;
    return 0;
}
[/codec ]
```

---

## 作者：七十七 (赞：1)

//利用STL中的map， 如果没有学过可百度搜索张同学one的博客




```cpp
//http://www.cnblogs.com/zhangone/p/5111232.html
#include <iostream>
#include <map>
#include <string>
using namespace std;
map <int, string> Map;//定义， 用字符串可以避免高精
map <int, string>::iterator it;//迭代器
int main()
{
    int i, n, a, ii = 0;
    string s, ss = "0";
    cin >> n;
    for(i = 1; i <= n; ++i)
    {
        cin >> s;
        Map[i] = s;//数组方式插入数据
    }
    for(it = Map.begin(); it != Map.end(); ++it)
    {
        ii++;
        s = it -> second;//取出Map中的字符串
        if(s.length() > ss.length() || (s.length() == ss.length()) && (s.compare(ss) > 0))//找出最多选票
        {
            a = ii;//选票数最多的那个人
            ss = s;//最多选票数
        }
    } 
    cout << a << endl << ss;//输出
    return 0;
} 

```

---

## 作者：spacetime (赞：1)

//虽然知道用字符串很方便，但由于还要重载运算符，所以本人运用“lazy思想”（233）把早已准备好的高精模板复了下来~~

```cpp
//具体排序方法可以用set模拟堆排
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#define REP(I,start,end) for(int I=start;I<=end;I++)
#define PER(I,start,end) for(int I=start;I>=end;I--)
#define digiter 1000000ll
using namespace std;
char st[10001];
struct bigNumber
{
    int len;
    long long num[100];
    inline bool operator >(const bigNumber& T)const
    {
        if(len<T.len)
            return false;
        if(len>T.len)
            return true;
        PER(ii,len,1)
        {
            if(num[ii]<T.num[ii])
                return false;
            if(num[ii]>T.num[ii])
                return true;
        }
        return false;
    }
};
inline void scan(bigNumber& T)
{
    memset(T.num,0,sizeof(T.num));
    scanf("%s",st);
    T.len=1;
    long long hehe=1ll;
    PER(ii,strlen(st)-1,0)
    {
        T.num[T.len]+=(st[ii]-'0')*hehe;
        hehe*=10;
        if(hehe==digiter)
        {
            T.len++;
            hehe=1ll;
        }
    }
}
inline void print(const bigNumber T)
{
    if(T.len==0)
    {
        putchar('0');
        return;
    }
    printf("%lld",T.num[T.len]);
    PER(ii,T.len-1,1)
    {
        long long tmp=digiter/10;
        while(tmp)
        {
            printf("%lld",T.num[ii]/tmp%10);
            tmp/=10;
        }
    }
}
struct node
{
    int num;
    bigNumber vote;
    inline bool operator >(const node T)const
    {
        return vote>T.vote;
    }
}t;
set<node, greater<node> > tree;
int n;
int main()
{
    scanf("%d",&n);
    REP(i,1,n)
    {
        t.num=i;
        scan(t.vote);
        tree.insert(t);
    }
    printf("%d\n",(*tree.begin()).num);
    print((*tree.begin()).vote);
    return 0;
}
```

---

## 作者：ArnoD (赞：1)

因为数字很大，不得不用字符串，下面应该是字符串最简单的一种了吧

```cpp
var
  n,i,maxid:longint;
  t,max:string;
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(t);
    if (length(t)>length(max))or(length(t)=length(max))and(t>max) then//如果当前读入数字的长度就打败max的话，那肯定当前数大，否则一位一位比较
    begin
      max:=t;
      maxid:=i;
    end;//替换
  end;
  writeln(maxid);
  writeln(max);
end.
```

---

## 作者：Timor (赞：1)

注意到题目后面说明的同学很容易就想到这应该是一道高精度的排序题。千万不要试图使用long long 什么的试图卡过去，不要抱有这样的侥幸心理否则noip上有可能会吃亏。

先粘代码：

```cpp

#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <cmath>
#include <cstring>          //别忘了库
#include <algorithm>
using namespace std;
char  num[1000000], maxx[1000000];  //数组开大点不花钱….但也大到过空间。
int i,n,p,l1,l2;
int main()
{ 
  cin>> n;
  for(i=1; i<=n; i++){
                     cin>>num;
                     l1 = strlen(num);     //长度返回函数，返回num的长度。
                     l2 = strlen(maxx);
                     if (l1>l2) {            //位数大的一定大     
                                 strcpy(maxx,num);
                                 p=i;
                                }
                     if (l1==l2&&strcmp(num,maxx)>0) // 位数相等时使用比较函数。
                                {
                                 strcpy(maxx,num); //复制函数，不解释。
                                 p=i;//记录最大的数是第几个
                                }
                   }
  cout<<p<<endl<<maxx;
  return 0;
}
 
```                                  
主要还是考察对字符函数的运用情况。我看到有的题解使用了字符串（c++语言的），还写了重载比较函数和sort排序，感觉有点小麻烦，写个简单点的望采纳。


---

## 作者：武松不打虎sz (赞：1)

emmm...翻了翻题解里的代码，好像没几个直接用string比较的。所以就想发一个。
（这是本蒟蒻第一次发题解，希望能对各位有所帮助。）

代码如下 ：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int num1,num2,n;
int main(){
	cin>>n;
	cin>>a;	//这是票最多的人（暂定）的票数，先暂定是第一人。
	num1=1;	//这是编号。
	for(int i=1;i<n;i++){
		cin>>b; //输入后面的人的票数
		num2=i+1;//此人的编号
		if(b.size()>a.size()||b>a&&a.size()==b.size()){
        //判断1.如果此人的得票数的位数比最多（暂定）的大
        //2.票数位数一样，比较就直接比较。
        //string 的比较是从首位开始按字典序比较的。如果位数不同就会有问题。
        //比如10000和9999，因为9>1，所以会说9999大。所以要有长度相同的条件。
			a=b;		//找到票数更多的，更新票最多的人（暂定）的票数、编号。
			num1=num2;  
		}
	}
	cout<<num1<<endl<<a;
	return 0;
}
```
emmm 刚刚发现楼下的那位的思路和我的差不多呢。互为参照吧

---

## 作者：unbeatable_noob (赞：1)

都知道数据大的要用字符串我就不多说了。。

本来是拿来熟悉一下运算符重载的写法，结果栽在了string模板库的比较方法上。。。

先比较位数再比较大小！

我知道可以一边读一边比较。。但是毕竟水题就水一水呗233

给出结构体带运算符重载的写法（不知道有没有人写过反正我没翻）

另外为什么直接用string自带比较还能ac两个点啊！数据太水了吧

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
struct man{
    int num;
    string ticket;
    
    bool operator < (const man &x)const
    {
        if(ticket.size() != x.ticket.size())
            return ticket.size() < x.ticket.size();
        return ticket < x.ticket;
    }
}people[300];
int main()
{
    int n;
    cin >> n;
    for(int i = 0;i < n;i++)
    {
        people[i].num = i;
        cin >> people[i].ticket;
    }
    sort(people,people+n);
    cout << people[n-1].num+1 << endl << people[n-1].ticket;
    return 0;
}
```

---

## 作者：骑着肥猪飙 (赞：1)

一个冒泡搞定，水题还是不要用stl好，自己打………………；

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct xx
{
    int p;
    string s;
}a[254];
void solve()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].s;//储存……
        a[i].p=i;
    }
    for(int i=1;i<=n-1;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            int u,f=a[j].s.length(),t=a[j+1].s.length();//记录长度，冒泡排序……
            if(f < t){
                 swap(a[j].s,a[j+1].s);
                 swap(a[j].p,a[j+1].p);//注意要交换编号
            }
            else if(f==t)
            {
                for(int v=f-1;v>=0;v--)//若长度相等从高位到低位比较两数大小
                {
                    if(a[j].s[v] < a[j+1].s[v])
                    {
                        swap(a[j].s,a[j+1].s);
                        swap(a[j].p,a[j+1].p);
                    }
                }
            }
        }
    }
    cout<<a[1].p<<endl;
    cout<<a[1].s;
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：呵呵侠 (赞：0)

此题我觉得根本不需要什么算法，函数

首先这题不是入门难度的原因是这题爆long long

高精度？不需要！

string搞定一切

位数更多的数一定更大

要判断位数，用size

如果位数相等，从首位开始判断，看哪一个数大

其他内容看代码里的注释

（听说抄袭会CE）
```
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    int a,max=1,MAX=1;//max是位数（众所周知，位数越多数越大），MAX是序号（数组下标加一）
    cin>>a;
    itn j[a];
    string k[a];
    for(int i=0;i<a;i++)
    {
        cin>>k[i];
        j[i]=k[i].size();//我最开始用char的strlen，结果效果不理想
        if(j[i]>max)//如果该数位数大于最大位数
        {
            max=j[i];//将最大位数设置为该数位数
            MAX=i+1;//序号的更改
        }
        if(j[i]==max)//位数相等
        {
            for(int p=0;p<=j[i]-1;p++)//从第一位开始判断
            {
                if(k[MAX-1][p]>k[i][p])//如果该数这一位小于最大数的这一位
                {
                    break;//退出循环
                }
                else if(k[MAX-1][p]<k[i][p])//如果该数这一位大于最大数的这一位
                {
                    MAX=i+1;//更改序号
                    break;//退出循环
                }
                else//相等
                {
                    continue;//continue循环催眠
                }
            }
        }
    }
    cout<<MAX<<endl<<k[MAX-1];//OK，输出
}
```
记住：

# 抄袭会CE！！！

---

## 作者：Leery (赞：0)

就 可能没有人写高精吧，第一份题解

**主要还是高精模板**

```c
#include<iostream>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
int n,m,k,flag;
struct bigInteger{//高精度整数的struct
	int digit[100];//每四位数字存在一个digit[]中
	int size;//有多少个四位
	void init(){//初始化，将digit数组清空
		for(int i=0;i<100;i++){
			digit[i]=0;
		}
		size=0;
	}
	void set(char str[]){//将很长的字符串分段存入digit
    //如123456789，则digit[0]=6789，digit[1]=2345，digit[2]=1；
		init();
		int L=strlen(str);
		for(int i=L-1,j=0,t=0,c=1;i>=0;i--){
			//倒序遍历 j计1-4, t计当前的数，c计权重 
			t+=(str[i]-'0')*c;
			j++;
			c*=10;
			if(j==4||i==0){
				digit[size++]=t;
				j=0;
				t=0;
				c=1;
			}
		}
	}
	void output(){//输出
		for(int i=size-1;i>=0;i--){
			if(i!=size-1)
			    printf("%04d",digit[i]);//若中间4位不足4位，要在前面添0补足
            else
                printf("%d",digit[i]);//最高位不需补0
		}
		printf("\n");
	}
	bool operator < (const bigInteger &A) const{//重载
		if(size!=A.size)return size<A.size;//先比长度
		for(int i=size-1;i>=0;i--){
			if(digit[i]!=A.digit[i]){//再比大小
				return digit[i]<A.digit[i];
			}
		}
		return false;
	}
}a,b; 

int main(){
	scanf("%d",&n);
	b.init();
	char str[103];
	for(k=1;k<=n;k++){
		scanf("%s",str);
		a.set(str);//读入的字符串，存入高精整数中
		if(b<a){//比大小，存大的
			flag=k;
			b.set(str);
		}
	}
	printf("%d\n",flag);
	b.output();
    return 0;
}
```


---

## 作者：天梦 (赞：0)

###### 其实还是比较基础的一道题，第一次发题解，如有不妥之处，敬请提出。
- 废话不多说，我们来看代码：


------------
```
#include<iostream>
#include<cstring>
using namespace std;
int n;
struct qqwer{
	char b[101];
	int z;
};
qqwer a[21];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].b;
		a[i].z=i;
	}
	for(int j=2;j<=n;j++)
	{
		if((strcmp(a[1].b,a[j].b)<0||strlen(a[j].b)>strlen(a[1].b))&&strlen(a[j].b)>=strlen(a[1].b)) swap(a[1],a[j]);
	}
	cout<<a[1].z<<endl<<a[1].b;
	return 0;
}
```


------------
在开头，我定义了一个结构体：
```
struct qqwer{
	char b[101];
	int z
};
```
其中z代表号数，b字符数组为票数；
主函数中


- 1. 赋值。代码如下：
```
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].b;
		a[i].z=i;
	}
```
- 2.排序：选择排序。程序如下：
```
	for(int j=2;j<=n;j++)
	{
		if((strcmp(a[1].b,a[j].b)<0||strlen(a[j].b)>strlen(a[1].b))&&strlen(a[j].b)>=strlen(a[1].b)) swap(a[1],a[j]);
	}
```
- 解释：

1. 在此并没有循环嵌套，因为我们要求的值是票数最大值，在经过选择排序后   a[1].b自然就是最大值。

2.在if语句中strcmp函数可以比较两个字符串的大小。例：strcmp(a,b),a,b都为字符串，若a>b，则返回大于0的数，若a=b，返回0，若a<b,则返回小于0的数，
但strcmp必须满足两个字符串长度相等（此处不是很确定，但用括号实现右对齐行不通），也就是说，例：a串=9898，b串=11111，strcmp(a,b)=1;
于是又有了两个strlen,strlen(a)表示a字符串的长度。因此，在这个题上，两个字符串a[1].b和a[j].b,只要满足后者长度大于等于前者和后者长度大于前者或strcmp规律符合任意一条，就可以进行交换。
注&&strlen(a[j].b)>=strlen(a[1].b)不能省略（大家若不懂可以删掉并调试一下）。
###### 至少能AC。

 


---

## 作者：zhangyiming (赞：0)

**本初一蒟蒻的第一篇题解，好激动啊！！！**

------------

看了那么多大佬的题解，发现大多数都用**sort**。那我就来~~投机取巧、不要脸地~~发一篇不一样的题解。

------------

原理：利用**strcmp**函数比较。
-----------------------
代码如下：
```
include<iostream>
include<cstring>
using namespace std; 
int main(){ 
int n,num;
char a[201],max[201]="";  
cin>>n;
for(int i=1;i<=n;i++){                 
    cin>>a;
    if(strcmp(max,a)<0){//当max < a时，返回负数。  
        strcpy(max,a);  
        num=i; 
    }
} 
cout<<num<<endl;  
puts(max);  
return 0;     
}
```
然而！
  
0分！！！

why?!

原来，strcmp函数是先比较第1个字符的值！
--------------
于是乎，加上了**strlen**判定。

AC满分代码如下：
```
include<iostream>
include<cstring>  
using namespace std; int main(){
int n,num;  
char a[201],max[201]="";
cin>>n;
for(int i=1;i<=n;i++){                      
    cin>>a;  
    if((strlen(max)<strlen(a))||(strlen(a)==strlen(max)&&strcmp(max,a)<0)){//若a的长度==max的长度，再用strcmp比较  
        strcpy(max,a);  
        num=i;  
    }  
}
cout<<num<<endl;  
puts(max);//输出
return 0; // 程序再见！
}
```
  
附上[我的AC记录](https://www.luogu.org/record/21104745)
  
~~管理员大大求过~~

---

## 作者：Shiwellyoung (赞：0)

通过观察可以发现这道题需要保存通过的候选人的票数与编号。然后继续思考可以发现首先可以比较候选人票数的长度，这样可以大大的提高比较的效率。然后可以利用字符串设定一个函数比较长度。接着把最长的长度拿出来，开始从高到低比较它们每一位上的数字。最后在主函数中调用即可。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int cam(string a,string b)
{
	if(a.length() >b.length()) return true;
	if(a.length() <b.length()) return 0;
	int l=a.length();
	for(int i=0;i<l;i++)
	{
		if(a[i]>b[i]) return true;
		if(a[i]<b[i]) return 0;
	}
	return 0;
}	
string m,maxn;
int main()
{
	int n,j;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>m;
		if(cam(m,maxn))
		{
		  maxn=m; j=i;
		}
	}
	cout<<j<<endl<<maxn;
}

```


---

## 作者：Jasonare (赞：0)

简单来说，这道题就是比大小嘛，唯一的难点在于大数。。
考虑一下，如果没有大数，是不是一个FOR循环就搞定了。。
其实这道题也一样，也可以一个FOR循环就搞定了，只不过我看到有犇犇已经说了，那么我就舍近求远，就Sort了一下。
所谓比大小，就是先比谁的位数大嘛，如果位数相同，就依次从高位比到低位就行了，最后输出最大那个就行了。。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	string s;
	int len;
	int num;
}N[25];

int cmp(node a, node b)
{
	if(a.len == b.len)//长度一样就直接字符串比较 
		return a.s > b.s;
	else	return a.len > b.len;//不一样比谁长^.^ 
}
int main()
{
	int n, i;
	cin >> n;
	for(i = 1; i <= n; i++)
	{
		cin >> N[i].s;
		N[i].len = N[i].s.length();//记录一下长度 
		N[i].num = i;
	}
	sort(N+1, N+n+1, cmp);
	cout << N[1].num << endl;
	cout << N[1].s;
}
```

---

## 作者：加减乘除 (赞：0)

//还以为是普通的比大小，结果long long int都存不下(###千万不要这样做)

//用字符数组，而且对应的ANSII码与0-9的大小顺序是一样的

//一开始就想到比大小的方法，不知为何题解里的各位大佬们有人用排序

```cpp
//两数比大小，记录那个大的
//上代码
#include<iostream> 
using namespace std; 
char a[102],lar[102];//用字符数组记录 
int len=0,len1=0,k=0;//两个数组的长度，以及最大的数字的顺序 
void c(int h)
{ 
if(len>len1)
{
for(int i=0;a[i]!='\0';i++)
lar[i]=a[i];k=h;return;
```
}//比较两者长度，把长的记录下来

```cpp
if(len<len1){return;}//小于就不再记录 
if(len==len1)
{ 
for(int i=0;i<len;i++)
{
if(a[i]==lar[i])continue; //相等的话比下一位
if(a[i]>lar[i])
{
for(int j=0;j<len;j++)lar[j]=a[j];//复制操作
k=h;//记得记录是第几个选举人
return;
} if(a[i]<lar[i])return;
} 
} 
} 
int main()
{ 
int n,i,j; 
cin>>n; 
cin.get();//记得把回车符吃掉，要不然会少输一次 
for(i=1;i<=n;i++)
{ 
cin>>a; 
len=0; 
//每次输入新的数据时应将长度归零，而数组lar不用
while(a[len]!='\0')len++;
//不会用计算长度的函数，so自己写了个
while(lar[len1]!='\0')len1++;//如上所述
c(i);
} 
cout<<k<<endl<<lar<<endl;//输出格式
return 0; 
}
```

---

## 作者：ErkkiErkko (赞：0)

刚才那个题解排版有些问题，重发一下ToT

这道题由于票数巨大，可以用字符串保存。

在这里为了使排序以及接下来的步骤更为方便而使用了结构体。

sort中的排序函数cmp的编写是此题的重难点，

在比较中先比较数位，如果数位相同再用strcmp函数比较还是很严谨的。

萌新一枚，dalao勿喷@~@

代码如下------

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n;//竞选人数 
struct Elect{
    char tk[105];//tk：票数，这里用字符串存入 
    int len,num;//len：票数的数字位数；num：竞选人编号 
}a[25];//这里用一下结构体 
bool cmp(Elect x,Elect y)//比较函数是重点 
{
    if(x.len>y.len)
        return 1;
    if(x.len<y.len)
        return 0;//先比数位多少 
    if(strcmp(x.tk,y.tk)>0)
        return 1;//如果数为相同的话还要比较数字大小 
    return 0;
 } 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].tk;//这里用cin是为了防吃回车 
        a[i].len=strlen(a[i].tk);
        a[i].num=i;//这里运用循环将每个候选人（结构体）的三个数据读入 
    }
    sort(a+1,a+n+1,cmp);//进行排序，sort函数需调用algorithm库 
    cout<<a[1].num<<endl;
    puts(a[1].tk);//进行输出 
    return 0;
}
```

---

## 作者：codesonic (赞：0)

用了string类，可能会比较慢，但代码清晰

虽然此题被放在了排序里面，但不一定必须排序

我的思想是先读入一个数，以这个数为基准数，接着继续读，读到比基准数大的就以它为基准数

同时记录基准数的编号

```cpp
#include<cstdio>    
#include<cstring>
#include<iostream>
using namespace std;    
int main()    
{
    string a,b;
    int n;
    int x=1;
    cin>>n;
    cin>>a;
    for(int i=2;i<=n;i++)
    {
        cin>>b;
        if(a.length()<b.length())//b的位数大，则b大
        {
            a=b;//基准数更新
            x=i;//记录编号
            /*cout<<"1error!"<<endl;调试用，可删除*/
        }
        else if(a<b&&a.length()==b.length())//string内有定义大于运算符，其定义为两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。但是用在这里一定要先保证长度相等（同strcmp函数）
        {
            a=b;//基准数更新
            x=i;//记录编号
            /*cout<<"2error!"<<endl;*/
        }
    }
     cout<<x<<endl<<a;
}
```

---

## 作者：过期薯条 (赞：0)

数可能到100位，我用的字符串存的，因为还要输出编号，所以我选择了一个string到int的map

```cpp
#include<iostream>
#include<map>    //用来关联票数和序号
#include<algorithm>  //我用的sort，虽然还要写函数判断字符串大小
using namespace std;

bool pd(string a,string b){    //用于判断位数相同的字符串的大小
    int i=0;
    while(a[i] == b[i])    i++;
    if(i < a.length())    return (a[i] > b[i]);
    return 0;
}

bool rule(string a,string b){
    if(a.length() == b.length())    return pd(a,b);   
    else    return (a.length() > b.length());   //若位数不相同，那么就不再比较，长的肯定大
    
}

int main(){
    int n;
    cin>>n;
    string p[21];
    map<string,int>bh;
    for(int i=1;i<=n;i++){
        cin>>p[i];
        bh[p[i]]=i;    //把票数和序号关联起来
    }
    sort(p+1,p+n+1,rule);    //不要在意
    cout<<bh[p[1]]<<endl<<p[1]<<endl;
}
```

---

## 作者：siunaus (赞：0)

//这道题虽然出在排序里，但是只要找出最“大”的字符串就可以了

//可以利用STL中的优先队列，在输入时就将元素按照从大到小的顺序排列好

```cpp
//只要从队列首取出元素就可以了
#include<iostream>
#include<queue>             //包含头文件queue
#include<string>
using namespace std;
struct node
{
    int index;                                                         //定义结构体，index储存编号，x储存数字
    string x;
    bool operator<(const node& a)const             //重载运算符
    {
        if (x.length() == a.x.length())                     //长度相等，直接比较
        {
            return x < a.x;
        }
        else
        {
            return x.length() < a.x.length();          //否则比较长度即可
        }
    }
};
int main()
{
    priority_queue<node> pq;
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        node x;
        x.index = i;
        cin >> x.x;
        if (x.x == "\n")                       //处理输入n时产生的"\n"
            cin >> x.x;
        pq.push(x);
    }
        cout << pq.top().index << endl << pq.top().x;                //输出队列首元素的编号与票数
    return 0;
}
```

---

## 作者：百里亦守约_test (赞：0)

这一题是有点难的，但是只要想一想就非常简单，我先说说这里的一个坑点：在字符串的比较中，9>100，因为9比100的1大，还有要输出一开始的号数，所以我们就要用一个字符串数组记住以前的次序。排序是这里的精髓，我们只能先从长度去看，如果长度相同那么就可以用st的第i个和st的第j个进行比较了。但是长度不同的话小的肯定就是小。所以用这两个条件就可以比较字符串了，最后就是找原本位置，然后输出就可以了。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,w;
string st[100000],xst[100000];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
      cin>>st[i];
      xst[i]=st[i];      //记住
    }
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(((st[i].size())<(st[j].size()))||(((st[i].size())==(st[j].size()))&&(st[i]<st[j])))
            {
                swap(st[i],st[j]);       //排序。
            }
        }
    }
    for(int i=1;i<=n;i++)
      if(xst[i]==st[1]) 
      {      //找
          w=i;
          break;
      }
    cout<<w<<endl;
    cout<<st[1];      //输出
    return 0;
}
```

---


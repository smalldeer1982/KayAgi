# 凌乱的yyy / 线段覆盖

## 题目背景

**Python 用户可以尝试使用 pypy3 提交试题。**

快 noip 了，yyy 很紧张！


## 题目描述

现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。

## 说明/提示

- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $50\%$ 的数据，$n \le 10^3$；
- 对于 $70\%$ 的数据，$n \le 10^{5}$；
- 对于 $100\%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} < b_{i} \le 10^6$。

## 样例 #1

### 输入

```
3
0 2
2 4
1 3
```

### 输出

```
2
```

# 题解

## 作者：kkksc03 (赞：1762)

在一个数轴上有n条线段，现要选取其中k条线段使得这k条线段两两没有重合部分，问最大的k为多少。

最左边的线段放什么最好？

显然放右端点最靠左的线段最好，从左向右放，右端点越小妨碍越少

其他线段放置按右端点排序，贪心放置线段，即能放就放

。

---

## 作者：chengni (赞：357)

个人的想法比较直白，只需要先将每一场比赛以结束时间排一次序，得到一个顺序的结构体数组，存储最前面一节课的下课时间，然后以结束时间为准，在这相同结束时间比赛中下，如果有比赛的开始时间小于等于记录的结束时间，直接参加比赛，然后计数，最后输出总次数就可以了。

下面ac代码

       
    
    
    
    
```cpp
       #include<bits/stdc++.h>//（万能库）
    struct px{//（定义一个结构体数组，分别储存开始时间和结束时间）
    int a;//（开始时间）
    int b;//（结束时间）
    }x[2000000];
    bool cmp(px x,px y){//（不管开始时间，直接按照结束时间排序）
    return x.b<y.b;
    }
    using namespace std;
    int main(){
    int n,sum=1,mi;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    cin>>x[i].a>>x[i].b;//（读入数据）
    sort(x+1,x+n+1,cmp);//（排序）
    mi=x[1].b;//（无脑记录第一个值）
    int j=1;
    while(j<=n)//（未优化的超长循环）
    {
        j++;
        if(x[j].a>=mi) {//（找到符合要求的比赛，记录，参加）
        sum++;//（计数）
        mi=x[j].b;}
    }
    cout<<sum;//（输出）
    return 0;//（功德圆满）
    }
存在不足之处，还请指教。
```

---

## 作者：MakerOne (赞：101)

# 题意分析：
------------
## 题目的大意是给出比赛的开始和结束的时间，求解最多能参加多少场比赛。因为所有的比赛时间点在同一个时间轴上，所以结束时间越早的比赛就是必须参加的，那么我们可以通过结束时间点进行从大到小的排序。由于一个时间点只能参加一个比赛，那么就需要剔除时间上有交叉的比赛（剔除比赛时间较长的一个）。可以使用一个pos记录上一次参加比赛的结束时间，下一场比赛是否参加，只需要将pos与要参加的比赛的开始时间进行比较。只有小于等于的情况才参加。
------------
# 代码实现：
------------
```
#include<stdio.h>
#include<algorithm>
using namespace std;
struct Match//使用结构体将比赛的开始时间和结束时间保存下来 
{
	int start;//开始时间 
	int end;//结束时间 
}M[1000005];
bool compare(Match a, Match b)//以结束时间从小到大排序 
{
	return a.end < b.end;
}
int main()
{
	int n,i,j;
	scanf("%d",&n);
	for(i=0;i<n;i++)scanf("%d %d",&M[i].start,&M[i].end);
	sort(M,M+n,compare);
	int pos = 0; //记录上一场比赛的结束时间 
	int ans=0;//记录能够参加几次比赛 
	for(i=0;i<n;i++)
	{
		if(pos<=M[i].start)//遍历所有比赛的时间 
		{
			pos = M[i].end;
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：飞翔 (赞：101)

[h1]题解：[h1]

先按照结束时间排序，再使用贪心的策略，一遍一遍的搜。

代码：

```delphi
var
  n:longint;
  a,b:array[1..1000001]of longint;
procedure init;
var
  i:longint;
begin
  readln(n);
  for i:=1 to n do
    readln(a[i],b[i]);
end;
procedure qsort(l,r:longint);
var
  i,j,m,t:longint;
begin
  i:=l;
  j:=r;
  m:=b[(l+r)div 2];
  repeat
    while b[i]<m do inc(i);
    while b[j]>m do dec(j);
    if i<=j then
    begin
      t:=a[i]; a[i]:=a[j]; a[j]:=t;
      t:=b[i]; b[i]:=b[j]; b[j]:=t;
      inc(i);dec(j);
    end;
  until i>j;
  if i<r then qsort(i,r);
  if l<j then qsort(l,j);
end;
procedure fct;
var
  i,x,sum:longint;
begin
  x:=-1;
  sum:=0;
  for i:=1 to n do
    if a[i]>=x then
    begin
      x:=b[i];
      inc(sum);
    end;
  write(sum);
end;
begin
  init;
  qsort(1,n);
  fct;
end.```delphi

为了让大家抄程序时费点时间，我框起来了……

[b]给个赞吧![b]


---

## 作者：Running_Coder (赞：67)

看到好多大佬用贪心。。。表示萌新老老实实用的DP

进入正题：

定义f[i]表示在前[i]场比赛中最多可以参加几场比赛，

由此得出方程：f[i]=max(f[i-1],f[temp]+1);

f[temp]指从f[i-1]向前找到的第一个允许参加第i场比赛的f[]

由于每次循环时都向前找一次temp会浪费太多时间，又因为f[]是单调递增的，

故可以令temp在循环时逐步递增，这样时间复杂度就降到了O(n).

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<string>
#include<ctime>
#include<cstdlib>
#include<algorithm>
using namespace std; 
struct qj{
    int l,r;
};
bool cmp(qj a,qj b){
    if(a.r!=b.r)return a.r<b.r;
    return a.l<b.l;
}
qj game[1000005];
int f[1000005];
int i,n,temp;
int main(){
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d%d",&game[i].l,&game[i].r);  
    sort(game+1,game+1+n,cmp);
    f[0]=0;
    temp=0;
    for(i=1;i<=n;i++){
        while(game[temp+1].r<=game[i].l)temp++;
        f[i]=max(f[i-1],f[temp]+1);
    }
    printf("%d\n",f[n]);
    return 0;
}
```

---

## 作者：孤独的观测者 (赞：27)

#  TreeSet简直是算法神器

### 思路比较简单

### -1.  结束早的放前面

### -2. 同样时间结束的就看开始时间

### -3. 然后直接遍历这个集合加过去就行了

###### 代码如下

------------

```cpp
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.sql.Time;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

public class Main
{

    public static void main(String[] args) throws NumberFormatException, IOException
    {
        int last=-1;
        int sum=0;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int N=Integer.parseInt(bufferedReader.readLine());
        TreeSet<p> treeSet=new TreeSet<>(new comparaab());
        for (int i = 0; i < N; i++)
        {
            String[] strings=bufferedReader.readLine().split(" ");
            treeSet.add(new p(Integer.parseInt(strings[0]),Integer.parseInt(strings[1])));
        }
        for (Iterator iterator = treeSet.iterator(); iterator.hasNext();)
        {
            p p = (p) iterator.next();
            if(p.begintime<last)
            {
                continue;
            }
            last=p.endtime;
            sum++;
        }
        System.out.println(sum);
    }

}
class p
{
    int begintime;
    int endtime;
    
    public p(int order, int time)
    {
        super();
        this.begintime = order;
        this.endtime = time;
    }
    
}

class comparaab implements Comparator<p>
{

    @Override
    public int compare(p o1, p o2)
    {
        if(o1.endtime==o2.endtime)
        {
            return o1.begintime-o2.begintime;
        }
        return o1.endtime-o2.endtime;
    }
}
```

---

## 作者：Haishu (赞：22)

其实这一题并不需要判断前一个和后一个的。直接判断当前一个就行。

先按后端点排序；

很显然，只要当前的头时间>现在的时间（已经参加了几场比赛的yyy最后一次参加比赛的时间）

说明这个比赛可以参加，且当前比赛结束时间最靠前，非选他莫属。


//我也不知道这有没有漏洞哈>\_<

下面是我的代码




```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,su=0,last=-1;
struct node
{
    int a,b;
}a[1000005];
bool cmp(node a,node b)
{
    return a.b<b.b;
}
int main()
{
    cin>>n;for (int i=0;i<n;i++) scanf("%d%d",&a[i].a,&a[i].b);sort(a,a+n,cmp);
    for (int i=0;i<n;i++)
    {
        if (a[i].a<last) continue;
        su++;last=a[i].b;
    }
    cout<<su<<endl;
    return 0;
}

```

---

## 作者：Bartholomew (赞：11)

##带贪心的DP!

我么首先知道 区间的范围只有 -999~999 但是线段却很多,这意味着有好多的线段可能左右端点会有重复的!

(不知道是不是和你们说的是一题)但是其实这是一道带贪心的动规 我们试想 如果有好多条线段的右端点是一样的

那么比如有n条,为了避免不会重复,所以我们要去掉n-1 条线段!,

那么我们根据自己的贪心策略,会选择左端点小的,为什么,**因为它可以让别的空间空出来,但是价值都是1**,所以十分有效果!

所以我们的dp方程就是

```cpp
    dp[i]=max(dp[i-1],dp[a[i]]+1);
```
a[i] 表示 对于 i 结尾的左端点最多可以拓展到哪里! 或者是左端点 --延伸右端点!

```cpp
#pragma GCC optimize(3)
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cstring>
#define N 2005
#define INF 0x3f
using namespace std;
int n,x,y,l,a[N],dp[N];
int main()
{
    scanf("%d",&n);
    memset(a,-INF,sizeof a);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
        if(x>y) x^=y,y^=x,x^=y;
        x+=1000,y+=1000;l=max(l,y);
        if(x>a[y]) a[y]=x;
    }
    for(int i=1;i<=l;i++)
    {
        if(a[i]>=0)
        {
            dp[i]=max(dp[i-1],dp[a[i]]+1);
        }
        else
            dp[i]=dp[i-1];
    }
    printf("%d\n",dp[l]);
    return 0;
}
```

---

## 作者：karma (赞：11)

```cpp
//此题为典型的贪心题
//思路;以线段右端点(即终点)为依据贪心，先排序，之后
//情况:如果下一线段的起点>now,可留下的线段总数++；如果下一线段的起点<=now,则更新now为下一线段的终点，
//小于等于时再分情况
//如果下一线段全部被包含在前一线段中，将now更新为下一线段终点(now越小越好(因为贪心)),如果下一线段与之前部分重叠，则舍弃此线段
//不更新now
#include<stdio.h>
#include<stdlib.h>
int N;//线段个数
typedef struct {
    int x;int y;
}data;//定义结构体
int cmp(data* a,data* b){
    if(a->x != b->x )return a->x - b->x;
    else return a->y - b->y;
```
}//从小到大排序，若线段起点相等，则按照终点从小到大排序
```cpp
int ans=0;//答案
data line[10010];
int main(){
    scanf("%d",&N);
    for(int i=1;i<=N;i++)scanf("%d %d",&line[i].x,&line[i].y);
    for(int i=1;i<=N;i++)
        if(line[i].x>line[i].y){int temp=line[i].y;line[i].y=line[i].x;line[i].x=temp;}//此题起点与终点可能反着，需要交换
    qsort(&line[1],N,sizeof(line[0]),cmp);//排序
//    for(int i=1;i<=N;i++)printf("%d %d\n",line[i].x,line[i].y);    //检查排序
    int now=-9999;//贪心依据
    for(int i=1;i<=N;i++){
        if(line[i].x>=now){now=line[i].y;ans++;}
            else if(line[i].x<now&&line[i].y<=now)now=line[i].y;
            else if(line[i].x<now&&line[i].y>now);
    }    
    printf("%d",ans);
    return 0;    
}
//感谢阅读
```

---

## 作者：Mayday (赞：8)

这道题首先要对结束时间进行排序，首先令标准=-1，从i=0开始，如果i的开始时间在标准时间之后，那么ans++，把i的结束时间作为新的标准时间，如此循环即可。

```cpp

(#include<iostream>    
#include<cstdio>    
#include<algorithm>    
using namespace std;    
struct node{    
    int a,b;    
}a[1000000];    
int cmp(node x,node y)    
{    
    return x.b <y.b;    
}    
int main()    
{    
    //pair<int,int> a[1000000];    
    int n;    
    cin>>n;    
    for(int i=0;i<n;++i)    
    scanf("%d%d",&a[i].a,&a[i].b);    
    sort(a,a+n,cmp);    
    int tt=-1,ans=0,i=0;    
    for(int i=0;i<n;++i)  
    {  
        if((a[i].a>=tt))  
        {  
            ans++;  
            tt=a[i].b;  
        }  
    }  
    cout<<ans;    
    return 0;    
}    )

```

---

## 作者：zhaowangji (赞：8)

话说个人觉得前面的几篇并不是很好，其实没有那么难，代码也没有那么长

很久以前就看到了，但貌似一直认为自己的算法是错误的，结果交上去发现是正解

首先按照时间排序（贪心）：结束时间早（尽可能不影响后面的比赛）的在前，若结束时间相同，则开始时间晚（尽可能不影响前面的比赛）的在前。（如果两者的判断顺序反了，就把最后一场比赛放到前面来了）

由于n<=1000000，所以sort一下即可

把目前的结束时间初值赋为1，最后循环一遍判断：当前比赛的开始时间是否比目前的结束时间晚，若是ans++，更新目前的结束时间，若否，不参加比赛，判断下一场。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	int sta;//开始时间
	int end;//结束时间
}com[1000007];
bool cmp(node x,node y){
	if(x.end!=y.end)return x.end<y.end;//按结束时间早的在前
	else return x.sta>y.sta;按开始时间晚的在前
}
int ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>com[i].sta>>com[i].end;//读入
	sort(com+1,com+n+1,cmp);//排序
	int end=-1;//初值记得是-1（其实0应该也可以）
	for(int i=1;i<=n;i++){
		if(com[i].sta>=end)ans++,end=com[i].end;
        	//开始时间比目前的结束时间晚，ans++，更新目前的结束时间
	}
	cout<<ans<<endl;//输出ans
	return 0;
}
```


---

## 作者：asasas5d (赞：5)

网上基本都是按右端点排序贪心的啊。  
介绍自己的一种按左端点排序贪心的方法吧，写起来还简短一些。  

思路就是比较当前区间和下一区间，如果下一区间与当前区间没有相交，则由于我们是按左端点排序的，后面的都不会相交，直接选择当前区间；否则这两个区间显然必须抛弃一个，由于我们是按左端点排序的，后面的区间左端点都是大于它们的，因此这两个的左端点已经没有意义了，为了留出更多的空间，留下右端点靠左的那一个即可。

  

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
vector<pair<int,int> > vct;
int main(){
    int n; scanf("%d", &n);
    for(int i=1; i<=n; i++){
        int a, b; scanf("%d %d", &a, &b) ;
        vct.push_back(make_pair(a, b)) ;
    } sort(vct.begin(), vct.end()) ;
    int cnts = 0 ;
    for(int i=0; i<(int)vct.size(); i++){
        if(i<n-1 && vct[i+1].first < vct[i].second) vct[i+1].second = min(vct[i+1].second, vct[i].second) ;
        else cnts ++ ;
    }
    printf("%d", cnts) ;
    return 0;
}
```




---

## 作者：S_C_Yesterday (赞：4)

### 哇，好久没有没做过这么经典的题了！
线段覆盖问题是非常经典的贪心问题。
## 为什么可以贪心呢？
首先拟定一种贪心策略。我们优先挑选$bi$值更小的一场比赛，这样一来，我们给后续比赛留下的时间就更多了。在剩下的比赛里，我们再按照这样的策略，选择可行的方案即可。
# 下面我们来检验这种策略的正确性
**1.**
```
对于区间[a,b) [c,d) [e,f)，有a<b<c<d<e<f，即：
a  b c  d e  f
[  )
     [  )
          [  )
显然能够被全部选择。
```
**2.**
```
对于区间[a,b) [c,d) [e,f)，有a<c<b<e<d<f，即：
a c    b e     d    f
[      )
  [            )
         [          )
显然[a,b)比[c,d)更优。
```
**3.**
```
对于区间[a,b) [c,d) [e,f)，有a<c<b<d<e<f，即：
a  c b de   f
[    )
   [   )
        [   )
显然[c,d)和[a,b)等价。
```
### $so$，这题满足了最优子结构性质，我们只需将各区间按$bi$从小到大排序，依次选择可行方案，得出的结果就是最优解。
下面就是$AC$代码$(P1803.cpp)$
###### （本来想用$c$代码实现，然而似乎出现了一些奇奇怪怪的问题）
```cpp
#include<stdio.h>//stdio.h万岁！
int min(int a,int b)
{
	return a<b?a:b;
}
int read()//快读
{
    int re=0;
    char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')
    {
        c=getchar();
        while(c>='0'&&c<='9')
        {
            re=(re<<1)+(re<<3)+(c^48);
            c=getchar();
        }
        return -re;
    }
    else
    {
        while(c>='0'&&c<='9')
        {
            re=(re<<1)+(re<<3)+(c^48);
            c=getchar();
        }
        return re;
    }
}
struct data
{
    int a,b;
}d[1000001];
int n,lst,cnt;
int pile[2000001];//除了sort()只会堆排so..
void push(int x)//将元素x加入堆
{
    pile[++pile[0]]=x;
    int i=pile[0];
    while(d[pile[i]].b<d[pile[i>>1]].b&&i>1)
    {
        pile[i]^=(pile[i>>1]^=(pile[i]^=pile[i>>1]));
        i>>=1;
    }
}
void pop()//去掉堆顶元素
{
    pile[1]=pile[pile[0]--];
    int i=1,j=2;
    while(d[pile[i]].b>min(d[pile[j]].b,d[pile[j+1]].b)&&j<=pile[0])
    {
    	if(d[pile[j]].b>d[pile[j+1]].b)
    	{
    		pile[i]^=pile[j+1]^=pile[i]^=pile[j+1];
    		i=j+1;
		}
		else
		{
			pile[i]^=pile[j]^=pile[i]^=pile[j];
			i=j;
		}
        j=i<<1;
    }
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        d[i].a=read();
        d[i].b=read();
        push(i);
    }
    while(pile[0])
    {
        if(d[pile[1]].a>=lst)
        {
            ++cnt;
            lst=d[pile[1]].b;
        }//只有可行才选择，否则直接pop()
        pop();
    }
    printf("%d\n",cnt);
    return 0;
}
```
![](http://m.qpic.cn/psb?/V12BlaGM3XjZOn/BLz0IWBcBbiKBxwctQD3mPu3x7rUMVY6FUqRpBvgyPs!/b/dL4AAAAAAAAA&bo=KgHgAAAAAAACd5g!&rf=viewer_4)

希望代码能给非$C++$的同学一些启发。

# 最后，祝大家NOIP500+，也祝洛谷越办越好！

---

## 作者：空銀子 (赞：4)

某正在培训的珂学家想研究珂学，但研究珂学之路遭到了阻挡，于是，蒟蒻就来写篇题解宣传珂学。

咳咳，话不多说，进入正题。
本题是经典的贪心算法中的选择不相交区间的问题，在《算竞入门》中也介绍过，无论如何，选择结束点最靠前的区间总是最好的，于是我们排序，之后挨个选，能选就选（贪一波）。

下面有请珂学代码：
```cpp
#include <bits/stdc++.h>//信竞万能头
using namespace std;
vector<pair<int , int> >lines;//个人习惯开vector,换个方式存储也行
int n;
int lc=-1,ans=0;//ans是选择的区间个数,lc指最后选择的区间的结束点
bool cmp(const pair<int , int>& x,const pair<int , int>& y)//比较函数
{
    if(x.second==y.second)
        return (x.first<y.first);
    else
        return (x.second<y.second);
}
int main(void)
{
    cin >> n;
    int a,b;
    for(int i=0;i<n;i++)
        cin >> a >> b,lines.push_back(make_pair(a,b));//读入
    sort(lines.begin(),lines.end(),cmp);//用sort排序
    for(int i=0;i<lines.size();i++)//检索每一个区间
    {
        if(lc<=lines[i].first)/*判断与上一个区间是不是相交(第一个区间那
        是肯定要选的，所以前面把lc定义成了-1)*/
        {
            lc=lines[i].second;//更新区间结束点
            ans++;//区间数加1
        }
    }
    cout << ans;//输出答案
    return 0;
}
```

---

## 作者：Shepherd不秃头 (赞：3)

刚开始把逻辑搞错了,wa声一片......
后来梳理了一下逻辑,发现这道题考查的应该是贪心,
贪心的地方在于每次都选择结束时间最早的那场比赛,最后的参赛次数应该是最高的(详情请见其他dalao的题解),~~所以代码实现就十分简单了~~,利用sort快排把结束顺序从小到大排列,然后根据上场比赛的结束时间和本场比赛的开始时间一一检查能否参加就可以了


------------
代码如下:
```cpp#include <bits/stdc++.h>
using namespace std;
typedef struct test{
	int st;
	int ed;
}test;
int cmp(test t1,test t2){
	if(t1.ed == t2.ed ) return t1.st < t2.st;
	return t1.ed < t2.ed;
}
int n,sum,med;//med用来记录上一场比赛的结束时间 
test t[1000000];
int main(int argc, char** argv) {
	cin >> n;
	for(int i=0;i<n;i++){
		cin >> t[i].st >> t[i].ed;
	}
	//将数组按结束时间从小到大的顺序排序 
	sort(t,t+n,cmp);
	//结束时间最早的那场比赛一定是可以参加的
	med = t[0].ed;
	//因为已经参加了第一场的比赛,所以初始sum应为1 
	sum = 1;
	//这里要注意,因为已经参加一场比赛了,所以i要从1开始 
	for(int i=1;i<n;i++){
		//如果这场比赛的开始时间大于等于上场比赛的结束时间,则可以参加 
		if(t[i].st>=med){
			sum ++; 
			med = t[i].ed;
		}
	} 
	cout << sum;
	return 0;
}

```


---

## 作者：Leap_Frog (赞：3)

# [P1803 凌乱的yyy / 线段覆盖（题解）](https://www.luogu.org/problemnew/show/P1803)

首先应以右节点排序，从左向右扫一遍，如果一个区间能有，则取来。

## ~~贪心大法好用！！！~~

证明：

**~~显然~~**

如果你选了右端点比p1大的点p2，而且是根据顺序来的。

那么，p1与p2都是此时能选的点。

**那么，p1是不会比p2差的！！！**

证毕。

更多细节见代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct qu
{
    ll left,right;
    qu() {left=0;right=0;}
    qu(ll a,ll b):left(a),right(b) {}
};
bool cmp(qu a,qu b)
{
    if(a.right!=b.right) return a.right<b.right;
    return a.right-a.left<b.right-b.left;
}
ll n,ans=0,leftest=0;
qu a[1000005];
int main()
{
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++) scanf("%lld%lld",&a[i].left,&a[i].right);
    sort(a+1,a+n+1,cmp);
//	for(ll i=1;i<=n;i++) printf("%lld %lld\n",a[i].left,a[i].right);
    for(ll i=1;i<=n;i++)
    {
        if(leftest<=a[i].left)
        {
            ans++;
            leftest=a[i].right;
        }
//		printf("i=%lld,leftest=%lld,ans=%lld\n",i,leftest,ans);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：MY_Lee (赞：3)

因为~~某些原因~~而不能通过的我，今天满怀激(beng)动(kui)地来写这篇题解！

首先看标签——这是一道
## 贪心，排序题
嗯好，知道了大方向，我们可以上路了。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
我的基本思想:先sort(万能啊),然后每次取可以参加并且总是“早早收尾”的noip比赛，直到无法取。
### 贪心总是和排序有那么一点联系。
### ——xxx神犇
话不多说，代码走起来：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct TV{
    long long be,en;
    bool operator<(TV const &x)const{//这便是多条件排序的另一种写法——重载运算符。由于排序的时候两数都是不变，所以要用const进行维护。
        return en<x.en|| 
               en==x.en&&be>x.be;
    }//首先比较结尾的大小，结尾的时间直接导致了参赛的数量；如果相同就比较开始的时间，开始的时间越晚越好，因为越晚前面就有越多的时间参赛。
};
TV a[1000005];
int tv,ans=1,now;//注意ans=1，表示总有一个比赛是一定可以参加的，这一点也体现在代码第23行。
int main(){
	scanf("%d",&tv);//输入
    if(tv==0){
    	return 0;
    }//em......这个不用管他
    for(int i=0;i<tv;i++){
        scanf("%d%d",&a[i].be,&a[i].en);//输入每场noip模拟赛的开始和结尾时间
    }
    sort(a,a+tv);//sort,大法好！请看代码第7行
    now=a[0].en;//由于筛选后第一个比赛最优，就参加此noip模拟赛，时间轴前进至这场比赛的末尾
    for(int i=1;i<tv;i++){
        if(now<=a[i].be){//如果现在的时间还赶得上这场比赛，那就参加此次noip模拟赛
            ans++;//参加次数＋1
            now=a[i].en;//时间轴前进至这场比赛的末尾
        }
    }
    printf("%d\n",ans);//输出答案
    return 0;
}
```
呼，舒了一口气，总算把复(jian)杂(dan)的代码看完了，相信你能在这篇题解的帮助下成功A掉他。

加下来是~~友情~~部分：

1. 话说noip不是改成CSP认证了吗？
2. 如果你干掉了这道题，你再看题目，发现了它——
#### 线段覆盖
如果你对此东东感兴趣，你可以再做做acm的“今年暑假不AC”这题，跟本题差不多。

[友情链接(不是恶作剧)](http://acm.hdu.edu.cn/showproblem.php?pid=2037)

---

## 作者：就是小马啊 (赞：2)

很容易可以看出来是用贪心。
关于贪心的线段覆盖问题，一般都是采用线段尾端排序（具体为什么论证的方法，俺也不太清楚，算是看yxc大佬讲解的课总结的经验吧，可能有更好的方法，我做题不多不太清楚），没看题的时候还以为是寻找增管路径，看了题发现不需要，直接遍历就行了。
这个题好像没卡数据，暴力一次就AC了。
在做这种线段覆盖的题可以使用stl里面的pair，可能比结构体简单一点？好像也差不多。
下面是AC代码。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, ans = 1;
const int N = 1000010;
typedef pair<int,int> PII;
PII noip[N];
int main(int argc, const char * argv[]) {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> noip[i].second >> noip[i].first;
    }
    sort(noip, noip+n);
    int j = 0;
    int f = noip[0].first;
    while (j < n) {
        j++;
        if (noip[j].second >= f) {
            ans++;
            f = noip[j].first;
        }
    }
    cout << ans << endl;
    return 0;
}
```
遍历过程：按照线段末端从小到大排序，找到第一个，将第一个线段末端赋值给f，比较下一个线段的头是否>=这个末端，如果成立，更新ans和f，一直循环到遍历完所有的线段结束，输出。
希望给过！！！

---

## 作者：killerlist (赞：2)

···cpp

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn=10000+5;
const int inf=1<<30;//无限大
struct xianduan{//线段表示
    int s,t;
};
xianduan xd[maxn];
int n,ans,p;
bool cmp(xianduan a,xianduan b){//排序规则
    if(a.t==b.t){
        return a.s<b.s;
    }else{
        return a.t<b.t;
    }
}
int main(){
    cin>>n;
    int x,y;
    for(int i=1;i<=n;i++){
        cin>>x>>y;
        if(x>y){//判断开端结尾
            xd[i].s=y;xd[i].t=x;
        }else{
            xd[i].s=x;xd[i].t=y;
        }
    }
    sort(xd+1,xd+n+1,cmp);//排序
    p=-inf;//无限小
    for(int i=1;i<=n;i++){
        if(p<=xd[i].s){//选择最早结束
            ans++;
            p=xd[i].t;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
···
#题解：线段覆盖

1. 线段开端与结尾需要判断谁是谁

2. 需要排序（方便后期处理）

3. 总是选最早结束的线段而不是开端或时间或覆盖最少

4. 注意坐标可是负数，有两种解决方案，一：p赋值无限小。二：将坐标轴平移，使可能最小坐标也是正数

以下是测试坐标处理的代码

···cpp

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn=10000+5;
struct xianduan{
    int s,t;
};
xianduan xd[maxn];
int n,ans,p;
bool cmp(xianduan a,xianduan b){
    if(a.t==b.t){
        return a.s<b.s;
    }else{
        return a.t<b.t;
    }
}
int main(){
    cin>>n;
    int x,y;
    for(int i=1;i<=n;i++){
        cin>>x>>y;
        if(x>y){
            xd[i].s=y;xd[i].t=x;
        }else{
            xd[i].s=x;xd[i].t=y;
        }
    }
    sort(xd+1,xd+n+1,cmp);
    cout<<endl;
    for(int i=1;i<=n;i++){
        cout<<xd[i].s<<" "<<xd[i].t<<endl;
    }
    return 0;
}
```
···
壮哉我大MIT！！！


---

## 作者：Misaka_Mikoto (赞：2)

利用结束时间从小到大排序，在相同时按开始时间从大到小排序。

p.s.要利用结构体快排。

```cpp

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<iostream>
using namespace std;
int ans=0;
struct Node{
    int l,r;
}a[1000005];
int cmp(const void *a,const void *b){
    Node *x=(Node *)a;
    Node *y=(Node *)b;
    if(x->r!=y->r)return x->r-y->r;
    return y->l-x->l;
}
int main(){
    int i,n,t=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)scanf("%d%d",&a[i].l,&a[i].r);
    qsort(a+1,n,sizeof(a[0]),cmp);
    for(i=1;i<=n;i++)if(a[i].l>=t&&a[i].r>=t){ans++;t=a[i].r;}
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：clearman (赞：2)

**算法模型：给n个开区间，选择尽量多的开区间，使两两不相交。**

首先按照结束时间排序，依次考虑各个比赛，如果没有和正在进行的比赛冲突，就选；反之不选。

代码：

```cpp

#include<iostream>
using namespace std;
int n,be[1000001],ov[1000001],ans=0;
void kp(int l,int r)
{
    int i=l,j=r,x,t;
    x=ov[(i+j)/2];  
    while(i<=j)
    {
       while(ov[i]<x)i++; 
       while(x<ov[j])j--; 
       if(i<=j) {t=ov[i];ov[i]=ov[j];ov[j]=t;t=be[i];be[i]=be[j];be[j]=t;i++;j--;}
    }  
    if(l<j)kp(l,j); 
    if(i<r)kp(i,r); 
} 

int main()
{
    cin >> n;
    for(int i=1;i<=n;++i)cin >> be[i] >> ov[i];
    kp(1,n);
    int y=-1;
    for(int i=1;i<=n;++i)
      if(be[i]>=y){++ans;y=ov[i];}
    cout << ans;
    system("pause");
    return 0;
}
```

---

## 作者：Acheing (赞：2)

二分啦啦啦

强行nlogn的二分，而且不会T！

就是用类似于线段覆盖的方法，即可A此题。记得一开始要从右端点排序

丢代码跑

`
/\*纪念LinuxA掉的第一题\*/

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct data{int x,y;}a[1000001];
int i,j,k,n,m,x,y,t,f[1000001];
bool bmp(const data&a,const data&b){return a.y<b.y;}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++){scanf("%d%d",&a[i].x,&a[i].y);if (a[i].x>a[i].y){t=a[i].x;a[i].x=a[i].y;a[i].y=t;};}
    sort(a+1,a+1+n,bmp);
    for (i=1;i<=n;i++){
        int l=1,r=i-1,ans=0;
        while (l<=r){
            int mid=(l+r)>>1;
            //printf("%d %d %d %d\n",l,r,a[mid].y,a[i].x);
            if (a[mid].y>a[i].x) r=mid-1;else ans=mid,l=mid+1;
        }
        f[i]=max(f[i-1],f[ans]+1);
    }
    printf("%d\n",f[n]);
    return 0;
}
`
```

---

## 作者：hsfzLZH1 (赞：2)

看了看其他dalao的方法，发现虽然我使用的也是DP方法，但是还是和dalao们的思路有些不同。

最长上升子序列的长度（LIS）相信大家都十分熟悉，我这里使用的就是类似的方法（序列型DP）。

具体实现过程如下：

首先将读入的数据进行排序，需要注意的是数据中线段的两个端点可能是逆序的（即左端点的坐标大于右端点，或者说长度<0），在输入的时候需要特殊处理（交换位置）。

然后就是DP的主要过程了，设f[i]表示从排序后的第1条线段到第i条线段中可以选取（不重合）的最多线段数，初始边界条件为f数组中的所有元素都是1，则状态转移方程为：

## f[i]=max{f[i],(若第i个线段与第j个线段不重合)f[j]+1}   j=0...i-1

附代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=10005;
int n,f[maxn],maxx=0;
struct node{int x,y;}a[maxn];
bool cmp(node a,node b)
{
    if(a.x!=b.x)return a.x<b.x;
    return a.y<b.y;
}
int main()
{
    for(int i=0;i<maxn;i++)f[i]=1;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d%d",&a[i].x,&a[i].y);
        if(a[i].x>a[i].y)swap(a[i].x,a[i].y);
    }
    sort(a,a+n,cmp);
    for(int i=1;i<n;i++)for(int j=0;j<i;j++)
    if(a[i].x>=a[j].y)f[i]=max(f[i],f[j]+1);
    for(int i=0;i<n;i++)maxx=max(maxx,f[i]);
    printf("%d\n",maxx);
    return 0;
}
```

---

## 作者：Clouder (赞：1)


贪心想法各位$dalao$都讲得很清楚了，在下就提供一种桶排的做法吧。

因为给出数据范围

$0≤ai＜bi≤1000000$

可以想到使用桶排的方式优化。即从快排的$O(nlogn)$的复杂度降低到了$O(n)$的复杂度。

# 需要考虑的问题
快排是依照右端点直接排序后遍历所有线段，因此并不需要考虑右端点相同时的放置顺序（因为遍历一遍总会遇到），但桶排则需要考虑右端点相同的线段要如何放置。

显然右端点相同时，左端点更大的线段更有潜力，因此以左端点为第二关键字进行桶排即可。

```cpp
#include <cstdio>
using namespace std;
struct node
{
    int l, r;
} all[1000001];//保存数据的结构体数组
int s[1000001];//排序数组，保存以右端点位置为下标的线段的编号，即   s[all[i].r] = i
int n, last, ans, maxr;//last为上次选择的线段的右端点
//读入优化部分
inline char nc()
{
    static char buf[1000000],*p1 = buf,*p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
void read(int &r)
{
    static char c; r=0;
    for(c=nc();c>'9'||c<'0';c=nc());
    for(;c>='0'&&c<='9';r=(r<<1)+(r<<3)+(c^48),c=nc());
}
//
int main()
{
    read(n);
    for (int i = 1; i <= n; ++i)
    {
        read(all[i].l);
        read(all[i].r);
        maxr = maxr < all[i].r ? all[i].r : maxr;//更新最大右端点，即以后枚举的上界
        if (!s[all[i].r] || all[s[all[i].r]].l < all[i].l)//如果桶的当前位置没有线段，直接放入就好了
            s[all[i].r] = i;//否则以左端点为第二关键字进行排序，左端点大的优先级高
    }
    for (int i = 1; i <= maxr; ++i)//枚举桶位置，依次更新答案
        if (s[i] && all[s[i]].l >= last && ++ans)
            last = all[s[i]].r;
    printf("%d", ans);
    return 0;
}
```


---

## 作者：Walker_wang (赞：1)

# 本题思路：结构体+vector

**安利博客-->[博客食用更佳](https://www.luogu.org/blog/will1123/#)**

**题目描述

现在各大oj上有n个比赛，每个比赛的开始、结束的时间点是知道的。

yyy认为，参加越多的比赛，noip就能考的越好（假的）

所以，他想知道他最多能参加几个比赛。
由于yyy是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加2个及以上的比赛。

输入格式

第一行是一个整数n ，接下来n行每行是2个整数ai,bi(ai<bi)，表示比赛开始、结束的时间。

输出格式

一个整数最多参加的比赛数目。
**

```
#include <bits/stdc++.h>//万能头
using namespace std;
struct activ//结构体
{
	int begin;
	int end;
};
int cmp(activ a,activ b)//cmp
{
	return a.end<b.end;
}
int main()
{
	int n;
	cin>>n;//输入
	vector<activ> vec;//vector
	for(int i=1;i<=n;i++)
	{
		activ a;//结构体a
		cin>>a.begin>>a.end;//输入
		vec.push_back(a);//放到后面去
	}
	sort(vec.begin(),vec.end(),cmp);//排序
	int count=vec.size(),k=0;//count赋值vec的长度
	for(int i=1;i<vec.size();i++)
	{
		if(vec[i].begin<vec[k].end)//注意没有=
		{
			count--;
		}
		else
		{
			k=i;
		}
	}
	cout<<count;
}
```


---

## 作者：悠悠lyz (赞：1)

蒟蒻的第一篇题解，用了贪心+队列（看着好像没有人写）。

贪心真是最~~简单~~难的算法啊（允 悲）。

具体的思路是：搞一个单调队列（依据右端点从小到大排序），然后贪心。
贪心策略是，只要放得下，就往里面放。因为之前已经把右端点排过序了，所以这个时候如果把右端点从小到大搜的话，就可以显然->此时最优<-。

代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
struct kkk{
	int lp,rp,len;//起点，终点，长度（其实没用）
	bool operator <(const kkk &chs) const{//kkk代表了什么？
		return chs.rp<rp;//这里是让优先队列按kkk中的rp排序
	}
}map[1000086];
int res=1,n,now;
priority_queue <kkk> pq;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
   {
		scanf("%d%d",&map[i].lp,&map[i].rp);
		map[i].len=map[i].rp-map[i].lp;
		pq.push(map[i]);//加进来自动排序
	}
	kkk temk=pq.top();//先把首条线段处理了
	now=temk.rp;//记上一个的末尾值（头尾可重）
	pq.pop();
	while(!pq.empty())//再来处理剩下的
	{
		temk=pq.top();
		if(temk.lp>=now)//符合不重合的条件
		{
			now=temk.rp;
			res++;
		}
		pq.pop();//用完就丢
	}
	cout<<res<<endl;
   cout<<"抄代码记得把这里删了"<<endl;
	return 0;
}

```


---

## 作者：_蒟蒻__ (赞：1)

题目大意：在一个数轴上有n条线段，现要选取其中k条线段使得这k条线段两两没有重合部分，问最大的k为多少。（摘自站长kkk的题解）

虽说出现在训练营的贪心列表内，但本蒟蒻证明不了贪心（菜），只好乖乖写DP

设dp[i]表示时间（就是数轴上的点）为 $i$ 时最大选取数量。考虑到正向枚举时间存在有后效性的问题，就倒着枚举。先将所有线段按照左端点 $l$ 排序，当 $i$ 恰好等于 $l$ 时就考虑是否选取，否则继承 $i +1$时的状态。

排序 O(nlogn)

核心部分 O(m) ~ O(n+m) （m表示 $i$ 的枚举初始值）

生命苦短，直接上代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1000010;
int n,dp[N];

struct segment
{
	int l,r;
	bool operator < (const seg &a)const 
	{
		return l<a.l;
	}
	
}a[N];

int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].l>>a[i].r;
	sort(a+1,a+n+1);
	int j=n;
	for(int i=a[n].l;i>=0;i--)
	{
		while(i==a[j].l && j) // 因左端点重复，所以用while而不是if 
		{
			dp[i]=max(dp[i],dp[a[j].r]+1);
			j--;
		}
		dp[i]=max(dp[i],dp[i+1]); // 继承上一状态 
	}
	return cout<<dp[0],0;
}
```


---

## 作者：风火 (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define oo 1000024
int n,cnt;
int dp[oo*2];
struct cx{
	int bg,ed;
}a[oo],b[oo];
bool cmp(cx a,cx b)
{
	return a.bg<b.bg||(a.bg==b.bg&&a.ed<b.ed);
}
/*本蒟蒻来发一波dp（没有想到贪心）*/
//%%%%%龘鬎
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d %d",&a[i].bg,&a[i].ed);
	sort(a+1,a+n+1,cmp);//按照开始的时间点排序
	a[0].bg=-1;
	for(int i=1;i<=n;i++)
		if(a[i].bg!=a[i-1].bg) b[++cnt]=a[i];
    //可以保证开始时间一定要找最先结束的
	for(int i=1;i<=cnt;i++)
	{
		for(int j=i-1;j>=max(1,i-1224);j--)
        //向前找随机个，答案必然很接近
		{
			if(b[j].ed<=b[i].bg)
				dp[i]=max(dp[i],dp[j]+1);
		}
	}
	printf("%d\n",dp[cnt]+1);//最后加1
	return 0;
}
```

---

## 作者：我要上天 (赞：1)

对于这题，思路别的题解讲得都已经很明确了。

那为什么要我这个题解呢？

因为，我这里要讲的是优化，极大的优化。

题中给的数据范围中可以看出，线段非常多，但是区间很小，这便是优化的空间！

DP方程：dp[ i ]=max(dp[ i-1 ],dp[ a[ i ] ]+1),a[ i ]!=0;

               dp[ i ]=dp[ i-1 ],a[ i ]==0;

dp状态表示，dp[ i ]表示便利到区间位置 i 时保留的最大线段数；

a[ i ]表示以i为后端点的线段的前端点（优化就在这里，不需要遍历所有以i为后端点的线段，只需要遍历最短的线段即可，极大优化）

方程无非是对便利到的线段取与不取来抉择的，取，线段前端点位置加1，不取，直接前一个状态照搬。

下面是代码

```cpp
#include"bits/stdc++.h"
using namespace std;
int len[9999];
int dp[9999];
int a[9999];
int main()
{
    int n;
    cin>>n;
    int x,y,s,z,l=0;
    for(int i=1;i<=9998;i++)len[i]=1e9;
    for(int i=1;i<=n;i++)
    {
        cin>>x>>y;
        z=min(x,y);
        y=max(x,y)+1000;
        x=z+1000;//保证x小y大
        s=y-x;
        if(s<len[y])//这个就是优化所在
        {
            len[y]=s;
            a[y]=x;
        }
        l=max(l,y);
    }
    for(int i=1;i<=l;i++)
    {
        if(a[i])
        {
            dp[i]=max(dp[i-1],dp[a[i]]+1);
        }
        else dp[i]=dp[i-1];
    }
    cout<<dp[l];
}
```

---

## 作者：AutumnKite (赞：1)

如楼下各位网友所说，采用贪心算法（如有漏洞请指出）：

1. 输入数据是杂乱的，先进行排序，n＜10000，所以用快速排序。

2. 尽量使当前留下的线段的尾坐标最小。

3. 对于一条线段，有三种情况

上AC代码：

```cpp
var
  n,i,x,t,s:longint;
  a:array[0..10000,1..2]of longint;
procedure qsort(l,r:longint);
var
  i,j:longint;
  mid:array[1..2]of longint;
begin
  i:=l; j:=r; mid:=a[(l+r) shr 1];
  repeat
    while (a[i,1]<mid[1]) or ((a[i,1]=mid[1]) and (a[i,2]<mid[2])) do inc(i);
    while (a[j,1]>mid[1]) or ((a[j,1]=mid[1]) and (a[j,2]>mid[2])) do dec(j);
    if i<=j then 
      begin
        a[0]:=a[i]; a[i]:=a[j]; a[j]:=a[0];
        inc(i); dec(j);
      end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  readln(n);
  for i:=1 to n do 
    begin
      readln(a[i,1],a[i,2]);
      if a[i,1]>a[i,2] then 
        begin
          t:=a[i,1]; a[i,1]:=a[i,2]; a[i,2]:=t;
        end;
    end;
  qsort(1,n);
  x:=a[1,2]; s:=0;
  for i:=2 to n do 
    if a[i,2]<x then //整条包含（尾坐标比当前尾坐标小）
      begin
        x:=a[i,2]; s:=s+1;
      end
    else
      if a[i,1]<x then //部分包含（头坐标比当前尾坐标小，尾坐标比当前尾坐标大或等于）
        s:=s+1
      else //不包含
        x:=a[i,2];
  write(n-s);
end.
```
程序中贪心部分的三种情况分别是：
1. 整条线段都包含在前面留下的线段中，那么可以删去i-1线段或i线段，那么前面说了，尽量使留下线段的尾坐标小，所以删掉尾坐标大的那条——i-1线段，留下部分尾坐标变为i线段的尾坐标。

2. 部分包含在前面留下的线段中，那么“尽量使留下线段的尾坐标小”，还是删去“尾坐标大的那条”——i线段。

3. 不包含在前面留下的线段中，那么留下，留下部分尾坐标变为i线段的尾坐标。

代码不太简洁，神犇勿喷！


---

## 作者：天狗的手帖 (赞：1)

来讲一种不需要排序的DP算法


p[i]表示第i个时间点存在的比赛是从p[i]开始的，假如有两组比赛的时间是相同的，那我们显然希望得到p[i]较大的那组，就用较大的那个起始时间来替换p[i]


如此预处理之后，用f[i]表示到第i个时间点位置最多能参加几场比赛假如对于i存在一个p[i]，那就对f[i]取f[i-1]（不参加比赛）和f[p[i]]（参加比赛）之中的最大值


问题最终的答案就是f[1~maxint of endingtime]的最大值


```cpp

#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

int n,a,b,maxin,ans;
int p[1000005],f[1000005];

int main()

{
    scanf("%d",&n);
    memset(p,-1,sizeof(p));
    
    for (int i=0;i<n;i++) 
    {
        scanf("%d%d",&a,&b);
        
        p[b]=max(p[b],a);
        maxin=max(maxin,b);
    }
    
    memset(f,0,sizeof(f));
    
    for (int i=1;i<=maxin;i++)
    {
        if (p[i]!=-1) f[i]=max(f[p[i]]+1,f[i-1]);
            else f[i]=f[i-1];
        ans=max(ans,f[i]);
    }
    
    printf("%d",ans);
}

```


---

## 作者：median_dxz (赞：1)

这题有简单的贪心所有的特征：主要部分短小精悍有逻辑。。

楼上说的很好，首先题目原型是一个线段从n个区间取最多的不相交区间。。

然后思路首先排序结束时间。。

设一个b=-1；

接着找到最先结束的一个比赛时间设为b，

然后找到第一个比b多的比赛开始时间，

再把找到的这个比赛的结束时间当做下一次比较的b，同时计数器+1。。

没了？

没了。

```delphi

var n,i,c,b:longint;
a:array[1..100000,1..3]of longint;
procedure qsort(l:longint;r:longint);
var i,j,tp,mid1,mid2:longint;
begin
  i:=l;j:=r;
  mid1:=a[(l+r) div 2][3];
  mid2:=a[(l+r) div 2][2];
  repeat
    while(a[i][3]<mid1)or((a[i][3]=mid1)and(a[i][2]<mid2))do inc(i);//注意处理分数相等的序号大小处理
    while(a[j][3]>mid1)or((a[j][3]=mid1)and(a[j][2]>mid2))do dec(j);
    if(i<=j)then begin
      tp:=a[j][1]; a[j][1]:=a[i][1]; a[i][1]:=tp;
      tp:=a[j][2]; a[j][2]:=a[i][2]; a[i][2]:=tp;
      tp:=a[j][3]; a[j][3]:=a[i][3]; a[i][3]:=tp;
      inc(i);
      dec(j);
    end;
  until(i>j);
  if l<j then
    qsort(l,j);
  if i<r then
    qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do begin
 read(a[i][1],a[i][3]);
 a[i][2]:=i;
 end;
 qsort(1,n);

 {writeln('======================================');
 for i:=1 to n do
 writeln(a[i][1],' ',a[i][3]);
 writeln('======================================');
 调试用代码，实则没用}
 b:=-1;
 for i:=1 to n do begin
   if(a[i][1]>=b)then begin
     b:=a[i][3];
     inc(c);
   end;
 end;
 writeln(c);
 readln;readln;
end. 

```

---

## 作者：易极feng (赞：1)

十分经典的任务调动问题

贪心解决

>先按结束时间升序排序
>选择第一个任务
>再依次判断开始时间是否与上一个已选任务冲突
>如果没有则选择此任务
>最后输出选择的任务数量
**双手捧上代码**

[codep]








```cpp
program manage;
type match=record
  a,b:longint;
  end;
var n,i,t,ans:longint;
m:array[1..1000000]of match;
procedure sort(l,r:longint);
var i,j,mid:longint;
t:match;
begin
  mid:=m[(l+r)div 2].b;
  i:=l;j:=r;
  while i<=j do
  begin
    while m[i].b<mid do inc(i);
    while m[j].b>mid do dec(j);
    if not(i>j) then
    begin
      t:=m[i];
      m[i]:=m[j];
      m[j]:=t;
      inc(i);
      dec(j);
    end;
  end;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
begin
  readln(n);
  for i:=1 to n do
    readln(m[i].a,m[i].b);
  sort(1,n);
  t:=m[1].b;
  ans:=1;
  for i:=1 to n do
  begin
    if m[i].a<t then continue
    else
    begin
      inc(ans);
      t:=m[i].b;
    end;
  end;
  writeln(ans);
end.
[/codep]
```

---

## 作者：桀骜的野心家 (赞：1)

这题我的做法是贪心。这题只要按结束时间为第一关键字，开始时间为第二关键字进行从小到大排序。排序后第一个比赛是可以参加的，之后每个比赛只要判断开始时间是不是在参加过比赛的结束时间之后就行了，是的就参加。

```cpp
#include<cstdio>  
#include<iostream>  
#include<algorithm>  
using namespace std;  
struct node{int x;  
int y;  
}p[1000001];  
bool cmp(const node a,const node b)  
{  
    if ((a.y<b.y) || ((a.y==b.y) && (a.x<b.x))) return true;  
    else return false;  
}  
int main()  
{int n,i,j,k,l;  
   scanf("%d",&n);  
   for (i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);  
   sort(p+1,p+n+1,cmp);  
k=0;  
l=0;  
for (i=1;i<=n;i++)  
if (k<=p[i].x)  
   {  
    k=p[i].y;  
    l++;  
   }  
printf("%d",l);  
}
```

---

## 作者：imaginebreaker (赞：1)

就是一点点判断过去，先以**结束时间**为关键字进行排序，然后设置指针k=0，每当寻找到比k大的结束时间（且开始时间比k晚）然后k=b[i],inc(次数);


```delphi
program luogu1094;
var n,m,i,j,k,num:longint;
    a,b:array[1..1000005] of longint;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=b[(l+r) div 2];
         repeat
           while b[i]<x do
            inc(i);
           while x<b[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;

 begin
  readln(n);
  for i:=1 to n do readln(a[i],b[i]);
  k:=-32767;
  sort(1,n);
  for i:=1 to n do if (b[i]>k) and (a[i]>=k) then begin k:=b[i]; inc(num); end;
   writeln(num);
   end.
```

---

## 作者：北凌scoffs (赞：0)

```c
#include<bits/stdc++.h>
using namespace std;
int n;
struct myq {
	int t1,t2;
} a[1005*1005];//定义一个结构体 
inline  bool cmp(myq x,myq y) {
	return x.t2<y.t2;
	//最开始打的是return x.t1<y.t1
	//后来在发现，其实排序之取决与结束时间
	//想要参加越多的比赛
	//理想数据情况(已经人为排好序)的话就是1~2，2~3,3~4,4~5......
	//那么觉定能否参加得是a[i-1].t2能否与a[i].t1对接上
	//很抽象，所以我举个栗子 
	//假设按照x.t1<y.t1排序，如果如见这样的数据呢？见下面
	//2~4,4~5，1~99999(有点夸张，不过不管怎样，只要有一个不满足就假设不成立)
	//那么排出来就是, 1~99999，2~4,4~5
	//这还怎么玩，后面两个比赛都在第一个比赛期间,只能参加一个 
	//而如果是x.t2<y.t2排序就是
	// 2~4,4~5,1~99999很明显参加2个，比第一种多
	//举个栗子就很清楚了把
	//其实很多时候，贪心排序都要在两个数据中选择，这个时候脑袋疼的话
	//就假设其中一种情况，然后举出特殊栗子，再用这个栗子用第二张数据排序看一下
	//最后比较一下，就可以了，非常没有科学依据的方法，但是一般都是正确的
	//方法很辣鸡，但是很实用 
}
int sum=1;
int j=1;
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
		scanf("%d%d",&a[i].t1,&a[i].t2);//输入嘛 
	sort(a+1,a+1+n,cmp);//排序 
	int flag=a[1].t2;//flag用于比较a[i].t1是不是>=a[i-1].t2; 
	while(j<=n) {
		j++;//开始 
		if(a[j].t1>=flag) {//满足条件就刷新，并且计算个数sun++； 
			sum++;
			flag=a[j].t2;
		}
	}
	printf("%d",sum);//输出 
	return 0;
}
```


---

## 作者：EnderXie (赞：0)

本蒟蒻做完这道题后觉得开大数组不好玩...然后就写了优先队列。

于是思路和codesonic大佬差不多，但实现方法不太相同。代码：

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define ll long long
#define _for(i,a,b) for(ll i=a;i<b;i++)
using namespace std;
typedef pair<ll,ll> pii;
ll n,a,b,ind=0,ans=0;
struct cpm{//自定义的排序结构体
	bool operator()(pii a,pii b){
		return a.second>b.second;//由于是堆排序，故升序应用>
	}
};
priority_queue<pii,vector<pii>, cpm> pq;
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	_for(i,0,n){
		cin>>a>>b;
		pq.push(make_pair(a,b));//无脑推入
	}
	while(!pq.empty()){
		if(ind<=pq.top().first) ind=pq.top().second,ans++;
		while(pq.top().first<ind && !pq.empty()) pq.pop();//无脑弹出
	}
	cout<<ans;
	return 0;
}
```

就这么简单...

---

## 作者：Npse_D (赞：0)

看了一圈题解orz

大多数都是贪心大佬，也有看到用dp的大佬，但是使用了sort()函数，时间复杂度依旧是O(nlogn)，我提供一个针对该题的O(n)做法。（还是比较广为人知的，但为什么没人发~~）

假设v到u有一条线段，那么就可以


f[u]=max(f[u],f[v]+1)，

这是显然的，因为可以选上这条边。

时间复杂度O(max{bi}+m)是O(n)级别的

可惜当ai，bi较大的时候，我们只好nlogn地离散化才可以用O(n)方法。

那样还是直接贪心咯~~~

```
#include<bits/stdc++.h>
using namespace std;
int n,f[1000005],x,y,maxt;
vector<int>m[1000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		if(x<y)swap(x,y);
		m[x].push_back(y);
		maxt=max(maxt,x);
	}
	for(int i=1;i<=maxt;i++){
		f[i]=f[i-1];
		for(int j=0;j<m[i].size();j++){
			f[i]=max(f[i],f[m[i][j]]+1);
		}
	}
	cout<<f[maxt]<<endl;
} 
```

---

## 作者：Cxs3 (赞：0)

题目链接：https://www.luogu.org/problemnew/show/P1803  

---


## 题目分析  
题目大意：给定$n$条线段，选择尽量多的线段，使得两两不相交（端点可重合）。  

由“最多能参加几个比赛”可知这是一道（简单的）贪心qwq.  

思路：先按照$b1<=b2<=...<=bn$的顺序排序，依次枚举每条线段（比赛），如果没有和已选的线段重合，就选；否则就不选。  

证明其正确性：  
$1.$对于两条线段，尾端越靠前的越优。  
如下图：  
![404啦](https://cdn.luogu.com.cn/upload/pic/46043.png)  
选择$i$明显比选择$j$更优，因为：若选$i$，则下面的$k$也可以选；若选$j$，$k$就不能选。  
这就证明了上面的命题。  

$2.$设最新选择的是线段$i$，那么对于线段$j(j>i)$：若$i,j$不重合，则多选$j$更优；若$i,j$重合，则只选择尾端点靠前的那条（即$i$，因为已排过序）更优（原因：上面$1.$处的命题）。  

时间复杂度$O(nlogn)$.  
(因为我排序用的是$sort$）.  

---

## 代码实现  
照例略去头文件、宏定义、uns.  
```cpp  
struct node
{
	int begin,end;
}a[N];//记录每条线段的结构体
int n,ans,m=-1;//m记录最新选择的线段的尾端点，初始化为-1
bool cmp(node x,node y){return x.end<y.end;}//按尾端点从小到大排序
int main()
{
	int i;
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i].begin>>a[i].end;
	sort(a+1,a+n+1,cmp);
	for(i=1;i<=n;i++) if(a[i].begin>=m){m=a[i].end; ans++;}
         //如果这条线段与最新选择的线段不重合，更新答案
	cout<<ans<<endl;
	return 0;
}
``` 
 
 
不到二十行的代码美滋滋qwq.

---

## 作者：shzr (赞：0)

这道题有两个点要注意一下：
  
1.两条线段仅端点重合不算相交 （然而相交的定义是两条线段存在公共点... ...）

2.a端点可能比b端点更靠右，所以输入的时候这种情况要换过来！（惯性思维...）




```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>

using namespace std;

struct szr
{
	int b,e;	
};

int n;
szr L[10004]={0};

bool cmp(szr a,szr b)
{
	if(a.e!=b.e) return a.e<b.e;
	return a.b>=b.b; 
}

int main()
{
	int t;
	scanf("%d",&n);
	int S=n;
	for (int i=1;i<=n;i++)
	{
	  scanf("%d%d",&L[i].b,&L[i].e);
      if(L[i].b>L[i].e)
      {
      	t=L[i].b;
      	L[i].b=L[i].e;
      	L[i].e=t;
	  }
	}
	sort(L+1,L+1+n,cmp);
	int en=L[1].e;
	for (int i=2;i<=n;i++)
	{
		if(L[i].b<en) S--;
		else en=L[i].e;
	}
	cout<<S;
	
	return 0;	
}
```

---

## 作者：hehelego (赞：0)

# talk is cheep, show me the code
贪心的正确性比较显然~~其实是我不会证明~~。
我们把线段按照右端点来排序。
从第二条线段开始选取，若与最后一条（被选择的）线段相交，则舍弃，否则，这条线段可以选择，更新最后一条选取的线段。
emmm，大概就是这样了。。


#### 会踩到的坑
1. 这个线段相交要求公共长度大于0，emmmm，就是端点重合不算相交
2. 数据输入的时候可能会故意调换左右端点（输入的左端点大于右端点），直接输入进来排序会挂。



```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct Interval{
    int a,b;
    Interval(){a=b=0;}
    Interval(int x,int y){a=x,b=y;}
    bool operator<(const Interval& rhs) const {
        return this->b<rhs.b;
    }
}seg[10000+10];
int n;
int main(){
    cin>>n;
    int a,b;
    for(int i=0;i<n;i++){
        cin>>a>>b;
        if(a>b)swap(a,b);
        seg[i].a=a;seg[i].b=b;
    }
    sort(seg,seg+n);
      
    int cnt=0;
    int last=0;
    for(int i=1;i<n;i++){
        if(seg[i].a<seg[last].b)cnt++;
        else last=i;
    }
    cout<<n-cnt<<endl;
    
    return 0;
}
```

---

## 作者：Enigmatic (赞：0)

我用的是贪心

每次选取结束时间最早的一个

看它的开始时间是否与前一个重叠

这里用到了c++自带的pair

在头文件<vector>里

它是按照前面一个数的大小排序

所以把结束时间读成first

开始时间读成second

还有熟悉的scanfuck

```cpp
#include <iostream>
#include <algorithm>
#include <vector> 
using namespace std;
int n,ans,maxn;
pair<int,int> t[1000010];
inline void scanfuck(int &x)
{
    x=0;
    bool f=0;
    char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-')
    {
        f=1;
        ch=getchar();
    }
    while(ch<='9'&&ch>='0')
    {
        x=x\*10+ch-48;
        ch=getchar(); 
    }
    if(f) x=-x;
}
int main()
{
    scanfuck(n);
    for(register int i=1;i<=n;i++)
    {
        scanfuck(t[i].second);
        scanfuck(t[i].first);
    }
    sort(t+1,t+n+1);
    for(register int i=1;i<=n;i++)
    {
        if(t[i].second>=maxn)
        {
            ans++;
            maxn=t[i].first;
        }
    }
    printf("%d\n",ans);
    return 0;
}

---

## 作者：chenkaixing (赞：0)

多余文字请大家自动省略[本体贪心，楼楼竟然用了30多分钟，你们谁都想不通我为什么屡屡10分（没看清题，我以为是像图一样的，n个点，然后读入m个关系，然后.....嗯，就这样）

咳咳，不废话了，]

这题就贪心最容易想和做，我稍微看了一下，我和楼下某位差不多，（10分的时候还对比了到底我哪里出了漏洞）就是直接求剩下多少条，最重要的思想就是让留下来的线段尽量短，这样可以得到最多的不相交的线段，于是先快排，按头坐标从小到大排（当然从大往小排也没问题），然后我用的是一个tail来记录尾坐标，这样线段从前往后找，可以依靠尾坐标判断这条线段是否可以留下【1、如果整条包含在上条记录的线段内，那么要这条（即减小尾坐标，缩短线段）；2、如果整条都在外面，那么可以留下它，即答案加一；3、除开这些，就只剩下一部分在上条线段内的了，不管它】

下面是我的code：


```cpp
program xianduan;
var
      a:array[1..10000,1..2]of longint;
      i,j,n,ans,temp,tail:longint;
procedure sort(l,r: longint);//根据头坐标快排，不多言
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2,1];
         repeat
           while a[i,1]<x do inc(i);
           while x<a[j,1] do dec(j);
           if not(i>j) then
             begin
                y:=a[i,1];
                a[i,1]:=a[j,1];
                a[j,1]:=y;
                y:=a[i,2];
                a[i,2]:=a[j,2];
                a[j,2]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
      //assign(input,'xianduan.in'); reset(input);
      readln(n);
      for i:=1 to n do
      begin
            readln(a[i,1],a[i,2]);
            if a[i,1]>a[i,2] then//被坑过一次，所以知道这个要写
            begin
                  temp:=a[i,1];
                  a[i,1]:=a[i,2];
                  a[i,2]:=temp;
            end;
      end;
      ans:=1;//假设第一条线段被留下来了
      sort(1,n);
      tail:=a[1,2];//记录第一条线段的尾坐标，也相当于初始化
      for i:=2 to n do
      begin
            if tail>a[i,2] then tail:=a[i,2]//这是我上面提到的第一种情况
            else if a[i,1]>=tail then//这是第二种
            begin
                  inc(ans);
                  tail:=a[i,2];//记得把战线推后，兄弟姐妹们
            end;
      end;
      write(ans);//输出0~0
      //close(input);
end.

```

---

## 作者：X_o_r (赞：0)

线段覆盖：题解

看到楼上写贪心的想法很不错，但是相对而言，我更喜欢写DP

很多人可能要问，DP怎么能写这道题呢？

首先我们可以定义F[i]表示由-999..i这个区间内最大的留存线段最大数量

（注意C++需要对于每个数+1000，以应对没有负数的下标情况，具体处理见代码）

我们可以将线段右短点到左端点建边，然后就可以得出F[i]=max(F[i],F[所有连结的左端点]+1)

这一定就是最优解

下面贴下代码

``` cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,L,R,tot,f[2005],lnk[2005],nxt[100005],son[100005];
inline int read(){
    char ch=getchar(); int res=0,flg=1;
    while (ch>'9'||ch<'0') {if (ch=='-') flg=-flg; ch=getchar();}
    while (ch>='0'&&ch<='9') res=res\*10+ch-48,ch=getchar();
    return res\*flg;
}
inline void add(int x,int y){
    if (x<y) swap(x,y);
    son[++tot]=y,nxt[tot]=lnk[x],lnk[x]=tot;
}
int main(){
    n=read();
    for (int i=n;i;i--) L=read(),R=read(),add(L+1000,R+1000);
    for (int i=1;i<2004;f[i+1]=f[i],i++)
    for (int j=lnk[i];j;j=nxt[j]) f[i]=max(f[son[j]]+1,f[i]);
    printf("%d\n",f[2004]);
    return 0;
}

---

## 作者：fl_334 (赞：0)

本人不才，代码笨重，望见谅。

总思路，贪心，按照始端点排序，之后贪

```cpp
type
        node=record
        b,e:longint;
        end;
var
        n,i,j,k,sum:longint;
        a:array[0..1010]of node;
procedure qsort(x,y:longint);
var
        i,j:longint;
        t,m:node;
begin
        i:=x;   j:=y;   m:=a[(x+y) div 2];
        repeat
                while (a[i].b<m.b)do       inc(i);
                while (a[j].b>m.b) do       dec(j);            //快排。。。有什么好说的么
                if i<=j then
                begin
                        t:=a[i];
                        a[i]:=a[j];
                        a[j]:=t;
                        inc(i);
                        dec(j);
                end;
        until i>j;
        if x<j then qsort(x,j);
        if i<y then qsort(i,y);
end;
begin
        readln(n);
        for i:=1 to n do
        begin
                readln(a[i].b,a[i].e);
                if (a[i].b>a[i].e) then              //注意，这里坑死人
                begin
                        k:= a[i].e;
                        a[i].e:=a[i].b;
                        a[i].b:=k;
                end;
        end;
        qsort(1,n);
        sum:=1;
        k:=a[1].e;                                  //我们可以把1先扔进去
        for i:=2 to n do
        begin
                if (a[i].e<k) then k:=a[i].e            //在内部，保留+缩短
                else if (a[i].b>=k) then       //在外部
                begin
                        k:=a[i].e;            //更新k值
                        inc(sum);        //累加sum
                end;
        end;
        write(sum);
end.

```

---


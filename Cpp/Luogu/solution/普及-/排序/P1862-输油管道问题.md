# 输油管道问题

## 题目背景

听说最近石油危机。

所以想到了这题。


## 题目描述

某石油公司计划建造一条由东向西的主要输油管道。

该管道要穿过一个有 $n$ 口油井的油田。从每口油井都要有一条输油管道沿最短路径（或南或北）与主管道相连。

如果给定 $n$ 口油井的位置，及它们的 $x$ 坐标（东西向）和 $y$ 坐标（南北向），应如何确定主管道的最优位置，即使各油井到主管道之间的输油管道长度总和最小的位置？证明可规定时间内确定主管道的最优位置。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 10000$，$-10^4 \le x,y \le 10^4$。

## 样例 #1

### 输入

```
5
1 2
2 2
1 3
3 -2
3 3```

### 输出

```
6```

# 题解

## 作者：LMB_001 (赞：54)

其实这道题就是简单的中位数，经典的输油管道问题，然后x轴只是一个摆设，c++代码，不喜勿喷哦

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n,i,a[100000],ans=0,l;
    cin>>n;
    for (i=1;i<=n;i++) {
        int x;
        cin>>x>>a[i];//如题，x轴只是一个摆设
    }
    sort(a+1,a+n+1);//排个序
    l=n/2;
    for (i=1;i<=l;i++){
        ans+=a[n-i+1]-a[i];
```
}//中位数
    cout<<ans;//输出答案

}

---

## 作者：Jy_Amoy (赞：19)

这道题其实可以用**模拟退火**做，就差不多是模板了

~~反正我刚写的时候是没想到其他写法~~

### 然后这里就稍微讲一下模拟退火的需要用到的东西(~~概念博客找找就有~~):

 模拟退火主要有关于这几个东西：

初始温度 $T$、末温 $T_0$、降温变量 **Δ**

其中有个主要以一定概率换解的公式，也是这个算法的核心：

设新解与最优解的差为**ΔE**,当前温度为$T$,设随机数$k$

则概率为$e^\frac{ΔE}{kT}$在c++里我们可以写作(~~反正我是这样写的~~)
```
exp(-ΔE/T)*RAND_MAX>rand();//这里ΔE前面加不加符号自己根据题目慢慢试(之前某个博客看到的,然而我写的题都加了负号都可以A掉，也没有过多尝试)
```
------------
然后还是推荐点讲模拟退火的:[洛谷之前的日报](https://m-sea.blog.luogu.org/qian-tan-SA)、[百度百科](https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/8664695?fr=aladdin)、[网上不错的博客](https://www.xianjichina.com/news/details_73392.html)

然后如果你们看了我顶上给的三个链接就会知道这是个玄学算法(如果没看的话最好还是看下qwq)

所以不保证我的代码一交上去就能A qwq

然后放代码
```cpp
#include<bits/stdc++.h>
#define maxn 10005
using namespace std;
const double delta=0.993;//降温系数
int ans,ansx;//全局最优解以及其最优管子在的坐标
int n,xx[maxn];
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline void out(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) out(x/10);
    putchar(x%10+'0');
}
inline int check(int x)//求出当前解
{
    int sum=0;
    for(int i=1;i<=n;++i)
        sum+=abs(x-xx[i]);
    return sum;
}
inline void SA()//模拟退火
{
    double T=2003;//初温
    int x=ansx;//定义当前最优管坐标
    while(T>1e-15)//1e-15是末温(懒得再设个变量了)
    {
        int X=x+((rand()*2-RAND_MAX)%100000/1000)*T;
        //rand()-RAND_MAX的范围是0~RAND_MAX-1
        //而rand()*2-RAND_MAX的范围则是-RAND_MAX~RAND_MAX-1
        //由于我们的坐标有负的，所以使用rand()*2-RAND_MAX
        //再缩小随机加与随机减的范围
        double now=check(X),DE=now-ans;//now为当前解(可能不是最优)
        if(DE<0)//就是ΔE
        {
            ansx=X,x=X;
            ans=now;//此解优于全局最优解，替换(记得替换当前最优坐标)	
        }	
        else if(exp(-DE/T)*RAND_MAX>rand()) x=X;
        T*=delta;
    }
}
inline double Time()
{
    return (double)clock()/CLOCKS_PER_SEC;//此公式返回程序运行时间,可以记一下，对于卡时间很有用
}
int main()
{
    srand(114514810);srand(rand());//随机种子
    n=read();
    for(int i=1,y;i<=n;++i) y=read(),xx[i]=read(),ans+=abs(xx[i]);//全局解先预处理(可能会更快?)
    while(Time()<0.75) SA();//在允许时间内跑多次SA
    out(ans);
    return 0;
}

```

最后推荐几道不错的模拟退火的题吧[[P1337]平衡点](https://www.luogu.org/problemnew/show/P1337)、[[P3936]coloring](https://www.luogu.org/problemnew/show/P3936)、[[P2530]均分数据](https://www.luogu.org/problemnew/show/P2503)

最后放下我自己写的博客qwq有我对于模拟退火的一些浅要理解吧[博客](https://www.luogu.org/blog/Asukaaa/guan-yu-mu-ni-tui-huo)

---

## 作者：封禁用户 (赞：10)

这个题大佬们说暴力不行，结果我强行暴力居然……AC了。

很简单，从油井的y值最小值暴力枚举到最大值，然后求管道之和，再与已求得的最大值相比较。但是我为了节省时间，用了一个办法：很显然主管道在最北边时管道之和特别大，在最南边时管道之和也特别大，在中间一个位置是管道之和刚好达到最小值，也就是说，**管道之和与主管道的位置成一个类似“抛物线”的关系**，我们就是要求出这个“抛物线”的最低点。所以，**当我们发现管道之和开始大于已经求出的最小值后，就说明我们已经枚举过最佳位置，直接结束枚举**。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int ys[10001];
int xs[10001];
int main(){
    int maxy,miny;
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int x,y;
        cin>>x>>y;
        if(y>maxy)maxy=y;
        if(y<miny)miny=y;   //找出油井y坐标的最大值和最小值
        ys[i]=y;
        xs[i]=x;
    }
    int minsum=0x7fffffff;
    for(int guandao=miny;guandao<=maxy;guandao++){   //从油井能达到的最上面位置枚举到最下面
        int sum=0;
        for(int i=0;i<n;i++){      //求管道长度
            sum+=abs(ys[i]-guandao);
        }
        if(sum<minsum){
            minsum=sum;
        }
        else{
            break;     //当我们发现管道之和开始大于已经求出的最小值后，就说明我们已经枚举过最佳位置，直接结束枚举
        }
    }
    cout<<minsum<<endl;
    return(0);
}
```

---

## 作者：x_faraway_x (赞：9)

楼下说枚举会爆，我看不然=\_=

下面给出暴力枚举程序供大家参考


```cpp
#include <cstdio>
#include <cstdlib>
#define INF 233333333 //最大值，不要在意那些细节
const int N = 10005;
int a[N];
int main() {
    int n, ans = INF;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%*d%d", &a[i]); //横坐标貌似这题没什么用，直接读入后舍弃=_=
    for(int i = -10000; i <= 10000; i++) { //横坐标从-10000枚举到10000，暴力嘛
        int tot = 0;
        for(int j = 1; j <= n; j++)
            tot += abs(i-a[j]); //累加距离不解释
        if(ans > tot) ans = tot; //更新最小值
    }    
    printf("%d\n", ans); //所以说这题还是蛮水的=_=
    return 0;
}

```

---

## 作者：oistr (赞：7)

$\color{white} \text{洛谷后台编号：152300}$

## 正宗的求中位数
暴力可以AC，但是这里想介绍一下这题非常简单的解法。

设东西向主管道的 $y$ 坐标是 $m$ ，则输油管道总长 $S=|y_1-m|+|y_2-m|+...+|y_n-m|$ 。

得到这个式子后，蒟蒻我就看了好久，然后突然醒悟：$m$ 应该是 $y_1,y_2,...,y_n$ 的中位数啊！

然后手算了好几组小数据都是对的，然后就斗胆提交，然后就 $AC$ 了。。。

比较新奇的是：这题是一道有干扰数据的题。题中的 $x$ 坐标根本无用 。

这里上代码：
```
#include <iostream>
#include <cmath>
#include <algorithm>//头文件，不多说
using namespace std;
int y[10005];
int main()
{
	int n,tmp;
	cin>>n;//input
	for(int i=1;i<=n;i++)
	{
		cin>>tmp>>y[i];//其实x坐标没有用，直接忽略，记得scanf好像有一个标记能让输入的数不存储在任何变量中，但是萌新忘了怎么写。。。就用cin了
	}
	sort(y+1,y+n+1);//排序（万能STL）
	int mid;//就是上面的m
	if(n%2==1)
	{
		mid=y[(n+1)/2];
	}
	else
	{
		mid=(y[n/2]+y[n/2+1])/2;
	}
    //以上是标准的求中位数，注意n为偶数的情况是中间两数之算术平均
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		sum+=abs(y[i]-mid);//按上面的式子加和
	}
	cout<<sum<<endl;//输出
	return 0;
}
```

---

## 作者：深海鱼的眼泪 (赞：5)

如果只有一口井，那么显然是越近越好。如果有两口井，那么显然是有以下三种情况： 1.两口井都在主管道北边，那么这个时候的两个连接管道的长度和肯定大于两口井的Y坐标之差。2.两口井都在主管道南边，和情况1是一样的 3.两口井，一个在主管道南边，一个在主管道北边，那么两个连接管道的长度和就等于两口井的Y坐标之差。显然情况三是所要的最短管道的设计情况。就是当主管道在两口井之间的任意位置时，连接管道长度之和都等于两口井的Y坐标之差，是最短的长度。

那么将这个结论推广，当有n口井的时候， 1.n是偶数 只要这n口井分布在主管道的两边，一边n/2个，那么就是距离之和最小的。2.n是奇数，只要将这n个井中，Y坐标最中间的（也就是Y是中值的那个）井不算，其余的偶数个井分布在主管道的两侧，这个时候移动主管道，那么这n个连接管道长度之和就决定于那个没有算的井了，因为其余的井的距离之和是固定了的，这个时候只要主管道最接近那个点就好了。

也就是说，输油管道的位置就是最中间的那口井（或中间的区间）。我的方法是将各口井的y坐标排序（x坐标不用管），再取 n div 2+1 的位置，即最中间的位置。



```cpp
var n,i,a,t,l:longint;
y:array[1..10000]of longint;
procedure qsort(l,r:longint);
var t,mid,i,j:longint;
begin
     i:=l;j:=r;
     mid:=y[(l+r) div 2];
     repeat
     while y[i]<mid do inc(i);
     while y[j]>mid do dec(j);
     if i<=j then
     begin
         t:=y[i];y[i]:=y[j];y[j]:=t;
         inc(i);dec(j);
     end;
     until i>j;
     if l<j then qsort(l,j);
     if i<r then qsort(i,r);
end;
begin
     readln(n);
     for i:=1 to n do readln(a,y[i]);
     qsort(1,n);
     t:=y[n div 2+1];
     for i:=1 to n do l:=l+abs(t-y[i]);
     writeln(l);
     readln;
end.

```

---

## 作者：ylsoi (赞：4)

这题可以用暴力枚举，并且不会超时。用数学绝对值的思想来看，油管的纵坐标必定是某一个油井的纵坐标，那么按照这样枚举就不会超时。可以先用循环来枚举每一个坐标的y值，再在里面嵌套一个循环来累加。最后求min值。

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
void qsort(int a[],int l,int r)//快排，不用说。 
{
    int i=l,j=r,mid=a[(l+r)/2],b;
    while(i<=j)
    {
        while(a[i]<mid)i++;
        while(a[j]>mid)j--;
        if(i<=j)
        {
            b=a[i];
            a[i]=a[j];
            a[j]=b;
            i++;
            j--;
        }
    }
    if(l<j)qsort(a,l,j);
    if(r>i)qsort(a,i,r);
} 
int main()
{
    int a[10005]={0},b,i,j,n,sum=0,min=210000000;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    scanf("%d%d",&b,&a[i]);//这个x坐标的值没有必要存。。。 
    qsort(a,1,n);
    for(i=1;i<=n;i++)//首先先存一个值假设为min，否则min不好设。。。 
    {
        for(j=1;j<=n;j++)
        {
            if(a[i]>=a[j])
            sum=sum+(a[i]-a[j]);
            else
            sum=sum-(a[i]-a[j]);
        }
        min=sum;
        sum=0;
    }
    for(i=1;i<=n;i++)//好戏开始了。。 
    {
        for(j=1;j<=n;j++)
        {
            if(a[i]>=a[j])
            sum=sum+(a[i]-a[j]); //暴力。。。。 
            else
            sum=sum-(a[i]-a[j]);
        }
        if(sum<=min)
        min=sum;
        sum=0;
    }
    printf("%d",min);//输出。。。 
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：3)

管道是横着铺的（那一段描述一般不太清楚）……这道题枚举的话肯定会爆……

至于为何是中位数，自己去证……也挺容易证的……

最后加的时候记得[color=red]取绝对值[/color]。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
int n,i,a[10010],mid=0,sum=0;
using namespace std;
int main()
{
    int sum=0;
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        scanf("%d %d",&a[i],&a[i]);//读入两次覆盖掉横坐标 
    sort(a+1,a+n+1);//从小到大将纵坐标排序。
    if (n%2==0)//如果n是偶数 （利用小学知识求中位数）
        mid=(a[n/2]+a[n/2+1])/2; //中间两个数的平均值
        else mid=(a[n/2+1]); //奇数情况中位数就是最中间那个数
    for (i=1;i<=n;i++)
        sum+=abs(mid-a[i]);//加上每个输油管道的长度。a[i]有可能>mid所以要取绝对值
    cout<<sum;
    return 0;
}

```

---

## 作者：王钰翔 (赞：3)

# 中位数
## 概念：一排序列中最中间的一个数字(奇数直接取，偶数取中间两个的平均值)。
### 此题序列如果为偶数也无需取平均！！！
#### 思路：取中点，求每个油井的距离。
Code：
------------

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,y,ans=0;
int a[10005];
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) { // x轴没用
		cin>>x>>a[i];
	}
	sort(a+1,a+n+1);
	y=a[n/2+1];  // 取中位数操作
	for(int i=1; i<=n; i++) {
		ans+=abs(a[i]-y); // 求每一点到主管道距离 
	}
	cout<<ans; 
}
```


---

## 作者：zhangzhaoke (赞：3)

刚学完奥数中位数，正好能用
```cpp
#include<iostream>
#include<algorithm>//sort头文件
using namespace std;
int main(){
    int n,a[100000],b[100000],answer=0;//定义
    cin>>n;
    for (int i=1;i<=n;i++)cin>>a[i]>>b[i];//输入两个数组
    sort(b+1,b+n+1);//sort排序
    for(int i=1;i<=n/2;i++)ans+=b[n-i+1]-b[i];//中位数算法,很关键,n/2是中位数
 	cout<<ans<<endl;//输出
	return 0;//好习惯
}
```
大佬都在用模拟退火，蒟蒻不才，用下中位数，欢迎私信讨论哦

---

## 作者：chenfeiyang (赞：1)

此题用初中绝对值方法解。

```cpp
var a:array[1..10000] of longint;
    i,j,p,t,n,x,s:longint;
begin
  readln(n);
  for i:=1 to n do
    readln(x,a[i]);
  for i:=1 to n do
    begin
      P:=i;
      for j:=i+1 to n do
        if a[j]<a[p] then p:=j;
      if i<>p then
       begin
         t:=a[i];a[i]:=a[p];a[p]:=t;
       end;
    end;
  x:=a[(n+1) div 2];
  for i:=1 to n do s:=s+abs(x-a[i]);
  writeln(s);
end.

```

---

## 作者：guobaipeng0 (赞：0)


```cpp
//pascal做法
var n,i,j,x,y,max,min,minc,s,t:longint;
  a:array[-10000..10000] of longint;
begin
  readln(n);    //输入井的个数
  max:=-maxlongint;
  min:=maxlongint;
  for i:=1 to n do
  begin
    readln(x,y);    //输入坐标
    inc(a[y]);    //因为油管是南北向的，所以要注重南北向的坐标，用桶排序
    if y>max then max:=y;   //找到最大值
    if y<min then min:=y;   //找到最小值
  end;
  for i:=max-1 downto min do  //先假设油管在最大值处
  begin
    s:=s+a[i]*abs(i-max);     
   //然后统计它的长度（油井的坐标-油管的坐标）*油井的个数=长度
    t:=t+a[i];       //进行统计下面有多少个油井，方便统计，详细请看下面
  end;
  minc:=s;    //假设为最小的长度
  j:=a[max];  //进行统计上面有多少个油井，方便统计，详细请看下面
  for i:=max-1 downto min do   //进行一次枚举（也可能是动态规划）
  begin
    t:=t-a[i];   //减去这个地方的油井个数，就能继续算出下面有多少个油井
    s:=s+j-a[i]-t;   
```
｛进行统计长度，加上上面的油井数（因为每次都如此，所以只是上一次的）再减后面的油井数和本身｝
```cpp
    if s<minc then minc:=s;   //算出最少的长度
    j:=j+a[i];    //计算上面有多少个油井
  end;
  writeln(minc);   //输出最少的长度
end.
```

---


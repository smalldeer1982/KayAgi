# 士兵站队

## 题目描述

在一个划分成网格的操场上，$n$ 个士兵散乱地站在网格点上，由整数坐标 $(x,y)$ 表示。

士兵们可以沿网格边上、下左右移动一步，但在同时刻任一网格点上只能有 1 名士兵。

按照军官的命令，他们要整齐地列成一个水平队列，即排成队列，即排成 $(x,y),(x+1,y),\ldots,(x+n-1,y)$。请求出如何选择 $x$ 和 $y$ 的值才能使士兵们以最少的总移动步数排成一列。

## 说明/提示

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10000$，$-10000 \leq x,y \leq 10000$。

## 样例 #1

### 输入

```
5
1 2
2 2
1 3
3 -2
3 3```

### 输出

```
8```

# 题解

## 作者：xiejinhao (赞：246)

# P1889 士兵站队 题解
### 好多Dalao写的我没看明白，那么我就自己写一篇吧
附送题目链接：[P1889士兵站队](https://www.luogu.org/problemnew/show/P1889)

那么我就不多解释题目了；

对于输入士兵的坐标：


**纵坐标处理**
------------

我们先看纵坐标（其实是纵坐标比较~~简单~~）

- 我们假设士兵要移动到的目标纵坐标为m；

**那么我们可以推导出一大堆的东西**：
士兵在垂直于x轴方向上的移动距离为：

		|y1-m|+|y2-m|+|y3-m|+……+|yn-1-m|+|yn-m|

那么m取什么值最小呢？显而易见，就是y1~yn序列的中位数，实现代码如下：
```cpp
	int rey;
   	sort(y+1,y+n+1);
	if(!n%2) rey=(y[n/2]+y[n/2+1])/2;
	//!n%2意为 n%2 =0(在if语句里写2个'=')，即 n%2 为假
	else rey=y[n/2+1];
		
```

**横坐标处理**
------------

**现在到了x麻烦了，因为有可能两位士兵的横坐标是相同的！而纵坐标的相同对于计算并没有影响！**

**~~~到这里实在不懂的要自己画下图了~~~**

那接着怎么办？

- ~~依旧假设~~~ ，我们假设第一位士兵站的位置是k，因为x从x1开始，那么我们假设成起始位置为k+1吧(不懂接着看完你就懂了）

那么：第二位士兵的位置是 k+2，接着是k+3,k+4,……,k+n;

所以，士兵横向(即平行于y轴方向)移动的距离为：

		|x1-(k+1)|+|x2-(k+2)|+|x3-(k+3)|+……+|x(n-1)-(k+n-1)|+|xn-(k+n)|

那么k取何值会使上式最小？我们不妨变形一下：

		|(x1-1)-k)|+|(x2-2)-k)|+|(x3-3)-k)|+……+|(x(n-1)-(n-1))-k)|+|(xn-n)-k)|
     //x(n-1)中 n-1 是x的下标
        
emmmm……于是又是**中位数**了！

**结论：我们只需要取 k=xi-i的中位数就好了！**

代码很容易实现，同纵坐标的的处理，先排序，但这次我们要将xi-i之后再次排序，再取中位数；

代码实现如下：
```cpp
	int rex;
	sort(x+1,x+n+1);
	for(int i=1;i<=n;i++) x[i]-=i;
	sort(x+1,x+n+1);
  	//处理完还要再排序；
	if(!n%2) rex=(x[n/2]+x[n/2+1])/2;
   	//同上；
	else rex=x[n/2+1];
```

到此，核心的部分就结束了
------------

然后程序就over了；

完整代码实现：
```cpp
//认真看 杜绝抄袭 
#include<cstdio>
#include<algorithm>
//使用 sort 排序函数 调用算法库; 
#include<cmath>
//使用 abs 绝对值函数 调用数学库;
using namespace std;
int n,x[10005],y[10005],ans=0,rex,rey;
//输入士兵数n，x数组储存士兵横坐标，y数组储存士兵纵坐标;
//ans统计步数和，rex记平行于x轴(即横方向)的中位数，rey记行于y轴(即纵方向)的中位数; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",x+i,y+i);
	//输入完毕 
	sort(x+1,x+n+1); sort(y+1,y+n+1);
	//无论如何都要先排序,sort调用'algorithm'(算法)库; 
	for(int i=1;i<=n;i++) x[i]-=i;
	sort(x+1,x+n+1);
	//处理完横坐标还要再排序一次; 
	if(!n%2)
	//人数n为偶数; 
	//相当于'if(n%2==0)'; 
	{
		rex=(x[n/2]+x[n/2+1])/2;
		rey=(y[n/2]+y[n/2+1])/2;
		//数学知识不解释了，自己多算; 
	}
	else//否则为奇数 
	{
		rex=x[n/2+1];
		rey=y[n/2+1];
	}
	for(int i=1;i<=n;i++) ans+=abs(x[i]-rex)+abs(y[i]-rey);
	//abs为绝对值函数，调用'cmath'(数学)库; 
	printf("%d",ans);
	//输出完毕,程序结束; 
	return 0;//这个千万不能漏！ 
} 
```

看都看完了，~~点个赞~~如何？
------------

---

## 作者：yydfj (赞：16)

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

在一个平面上，把 $n$ 个点排列在一条与 $x$ 轴平行的直线的整点上，且相邻两点的距离为 $1$ 。

求一种排列方案，使得这 $n$ 个点到目标位置的曼哈顿距离和最小。

## 解法综述

__由于是求曼哈顿距离，所以可以将 $x$ , $y$ 分开考虑。__

- $y$ ：要将所有的 $y_i$ 集中到某个 $y_0$ 上。

  可以通过微量法证明 $y_0$ 一定在某个已知 $y_i$ 上。再通过微量法证明 $y_0$ 一定是 $y_i$ 的中位数。

- $x$ ：要将 $x_1$ 集中到某个 $x_0$ 。其他 $x_i$ 依次相间 $1$ 排下去。

  先将 $x$ 排序，可以证明 $x$ 的顺序一定就是最终的序列的顺序（因为交叉位置的话解更差）。

  因为定了序，所以有 $x_i=x_0+i-1$ ，则可以将问题转化为 $x_i=x_i-(i-1)=x_i-i+1=x_0$ 。

  $x$ 就是与 $y$ 同样的问题了，求 $x_i-i+1$ 的中位数 $x_0$ 就可以了。
  
__综上述可知，这道题其实是一道贪心题。__

## 代码描述
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
using namespace std;
int n,x[10001],y[10001],ans;
void xsort(int l,int r)//用于将x轴上的士兵进行排序
{
	int i=l,j=r,m=x[(l+r)/2];
	while(i<=j)
	{
		while(x[i]<m) i++;
		while(x[j]>m) j--;
		if(i<=j)
		{
			swap(x[i],x[j]);
			i++;j--;
		}
	}
	if(l<j) xsort(l,j);
	if(i<r) xsort(i,r);
}
void ysort(int l,int r)//用于将y轴上的士兵进行排序
{
	int i=l,j=r,m=y[(l+r)/2];
	while(i<=j)
	{
		while(y[i]<m) i++;
		while(y[j]>m) j--;
		if(i<=j)
		{
			swap(y[i],y[j]);
			i++;j--;
		}
	}
	if(l<j) ysort(l,j);
	if(i<r) ysort(i,r);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);//输入当前士兵的坐标
	xsort(1,n);
	ysort(1,n);//将士兵的坐标进行排序
	for(int i=1;i<=n;i++) ans+=abs(y[i]-y[(n+1)/2]);//累加排序后士兵y坐标离y0的距离
	for(int i=1;i<=n;i++) x[i]=x[i]-i+1;
	xsort(1,n);//处理完士兵x坐标后需要再次排序
	for(int i=1;i<=n;i++) ans+=abs(x[i]-x[(n+1)/2]);//累加排序后士兵x坐标离x0的距离
	printf("%d",ans);//输出答案（为曼哈顿距离和最小）
	return 0;
}
```
**这是本蒟蒻第一次写的题解，如有错误点请好心指出！**

该题解审核通过后有人指出错误，已被修改 $1$ 次。

---

## 作者：oreimo_eromanga (赞：12)

```cpp

#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<string>
#include<cstdio>
#include<cmath>
using namespace std;
int x[1000001],y[1000001];
int main()
{
    int n,zb1,zb2,total=0;
    cin>>n;
    for(int i=1;i<=n;i++)
       cin>>x[i]>>y[i];    //输入。
    sort(x+1,x+(n+1));
    sort(y+1,y+(n+1));     //排序。
    for(int i=1;i<=n;i++)
       x[i]-=i;            //由于士兵要站一排，所以要减不同的。
    sort(x+1,x+(n+1));     //剪完还要再排。
    if(n%2==0)             //接下来就与输油管道一样区中位数。
    {
      zb1=(x[n/2]+x[n/2+1])/2;
      zb2=(y[n/2]+y[n/2+1])/2;
    }
    else
    {
      zb1=x[n/2+1];
      zb2=y[n/2+1];
    }
    for(int i=1;i<=n;i++)
    {
       total+=abs(zb1-x[i])+abs(zb2-y[i]);

    }
    cout<<total<<endl;     //打印。
    return 0;
}

```

---

## 作者：2017gangbazi (赞：9)








```cpp
//简单说一下思路哈
//先按照x大小顺序将数组排序（我用的是结构体，冒泡排序比较简单一些）
// 既然是个二维的空间，不妨先找到符合题意的 与x轴平行的线
//讨论从-6500到6500（测试数据逼出来的）哪一个点使各点到这条线距离之和最短（即输油管道问题）
//同理，讨论出各点在这条线上从哪一点开始向后排列可以使移动步数最少
//输出两次最少步数的和
//附ac代码
#include <bits/stdc++.h>
using namespace std;
struct xy{
    int x;
    int y;
}s[10001];//结构体数组，存储输入的数据
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    scanf("%d%d",&s[i].x,&s[i].y);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            if(s[j].x>s[j+1].x)
            {
                int k=s[j].x;
                s[j].x=s[j+1].x;
                s[j+1].x=k;
                k=s[j].y;
                s[j].y=s[j+1].y;
                s[j+1].y=k;
            }
        }
```
}//按x大小将数组排序
    
    
    
    
    
```cpp
    int yy[n+1]; 
    for(int i=1;i<=n;i++)
    yy[i]=s[i].y;
    sort(yy+1,yy+n+1);//讨论平行于x的直线
    //for(int i=1;i<=n;i++)
    //cout<<s[i].x<<" "<<s[i].y<<endl;
    int h1=0,h2=0;
    for(int j=-6501;j<=6500;j++)
    {
        for(int i=1;i<=n;i++)
        h1+=abs(s[i].y-j);
        if(h1<h2||j==-6500)
        h2=h1;
        h1=0;
    }
    int kk=h2;
    h1=0; h2=0;
    int xx[n+1]; 
    for(int i=1;i<=n;i++)
    xx[i]=s[i].x;
    sort(xx+1,xx+n+1);//同理
    for(int j=-6501;j<=6500;j++)
    {    int jj=0;
        for(int i=1;i<=n;i++)
        {
            h1+=abs(s[i].x-j-jj);
            jj++;
            }
        if(h1<h2||j==-6500)
        h2=h1;
        h1=0;
    }
    kk+=h2;
    cout<<kk;
//望审核通过，第一次交题解，为大家服务同时也让自己涨了知识，谢谢啦！    
}
```

---

## 作者：苯酚加氧 (赞：7)

  
  
```cpp
#include<iostream>  
#include<algorithm>  
#include<cstring>  
#include<cstdio>  
#include<cstdlib>  
#include<cmath>  
using namespace std;  
int main()  
{  
    long long n,m=0,l=0,x,y;  
    int a[10000],b[10000];  
    cin>>n;//输入
    for(int i=0;i<n;i++)  
        cin>>b[i]>>a[i];  
    sort(a+0,a+n);      //排序 
    sort(b+0,b+n);  
    for(int i=0;i<n;i++)//同时刻任一网格点上只能有一名士兵  
      b[i]-=i;  
    sort(b+0,b+n);  
    for(int i=0;i<n;i++)  
    {  
        m+=abs(a[n/2]-a[i]);//类似油田中位数运用  
        l+=abs(b[n/2]-b[i]);  
    }  
    cout<<m+l<<endl;//输出  
    return 0;  
}
```

---

## 作者：yezl (赞：6)

首先概括一下题意，大概就是给你 $ n $ 个士兵的 $ x,y $ 坐标，要你用最小的步数让他们排成整齐的横队（y坐标相同）。  

**相关题目推荐：**
 1. [P1862 输油管道问题](https://www.luogu.com.cn/problem/P1862)（简单点）
 2. [P1632 点的移动](https://www.luogu.com.cn/problem/P1632)（更难点）

我们就设他们都要移动到 $ y $ 坐标为 $ y_{ans} $的位置，他们每个人的 $ y $ 坐标为 $ y_1,y_2…,y_n $ 那我们就可以得出关于总移动距离 $ m $ 的方程：
 $$ m=|y_1-y_{ans}|+|y_2-y_{ans}|+|y_3-y_{ans}|…+|y_n-y_{ans}| $$
那 $ y_{ans} $ 的值取什么的时候 $ m $ 最小呢？  

稍有数学基础的同学应该都知道就是取中位数嘛，还是比较好解决的，（不知道中位数是什么的同学[点这里](https://baike.baidu.com/item/%E4%B8%AD%E4%BD%8D%E6%95%B0/3087401?fr=aladdin)）。

### 解决了纵坐标的问题，现在来看横坐标

这时候你可能就有问号了，为什么要考虑这个呢？因为有可能两个士兵的横坐标 $ x $ 是相同的，这会发生这种情况：上面的士兵移动到 $ y_{ans} $  时就会和另一个士兵~~重合~~撞到一起了呀，但是题目要求
> 同时刻任一网格点上只能有1名士兵。

~~（其实想想就知道呀）~~，所以我们要保证每个士兵的 $ x $ 坐标不能相同。

于是这时我们就设 $ s=x_1-n\;,\;t=x_1+n\; \text{（注：此时 x 数组已按从小到大的顺序排序过）}$   

为什么要 $ s=x_1-n $ 呢？因为考虑最坏的情况所有士兵的横坐标相同，那么只能 $ x_1 $ 往前排 $ n $ 位了，这里顺便说一下sort（快速排序）函数的用法： $ \text{sort(数组起始地址,终止地址,函数)} $ 这个函数部分就是让你可以让它从大到小之类的，不填也可以（用结构体一定要填），然后就是如下代码：

```c
for(int i=s;i<=t;i++)//i是第一个士兵的位置
{
	int sum=0;
	for(int j=1;j<=n;j++)
	{
		int k=x[j];
		sum+=abs(k-(i+j-1));//第j个士兵的位置：i+j-1
	} 
	if(ansx==0 || sum<ansx)
	{
		ansx=sum;
	}
}
```

这样就可以完美得解决问题啦，然后输出 $ ansx+ansy $ 就好了。  
~~（你可能会问ansy在哪）~~

### 好吧，给出完整代码：

```c
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=100010;//定义常变量
int x[N],y[N],ansx=0,ansy=0,n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d %d",&x[i],&y[i]);
	sort(x+1,x+n+1);//从小到大排序 x 
	sort(y+1,y+n+1);//从小到大排序 y 
	int mid=y[(n+1)/2];//处理y 
	for(int i=1;i<=n;i++)
		ansy+=abs(y[i]-mid);//abs就是绝对值o	
	int s=x[1]-n,t=x[1]+n;//开始处理x
	for(int i=s;i<=t;i++)//i是第一个士兵的位置
	{
		int sum=0;
		for(int j=1;j<=n;j++)
		{
			int k=x[j];
			sum+=abs(k-(i+j-1));//第j个士兵的位置：i+j-1
		} 
		if(ansx==0 || sum<ansx)
		{
			ansx=sum;
		}
	}
	printf("%d",ansx+ansy);
	return 0;
}
```

希望可以帮到大家。


---

## 作者：lzj666_luogu (赞：4)

## 思路

将本题中的士兵横纵坐标分开考虑。

为什么可以呢？

考虑士兵不能同时占据同一位置，那就让其中一个先走，另一个后走即可。其中由于最开始不会有两个或更多的士兵同时占据同一位置，所以结论显然正确。然后所有人统一先动 x 或先动 y 就可以将 x 和 y 分开考虑了。

因为他们最后都是要 $y$ 坐标相同的，所以我们设士兵要移动到的目标纵坐标为 $y_0$。

所以，士兵在垂直于 x 轴方向上的移动距离为：

$$
\sum_{i = 1}^{n}{|y_i-y_0|}
$$

那么 $y_0$ 取什么值最小呢？就是 $y$ 序列的中位数。

接下来我们设最终序列的第一位士兵 $x$ 为 $x_0$，则最终花费为：

$$
\sum_{i=1}^n |x_i-(k+i)|
$$

变形为：

$$
\sum_{i=1}^n |(x_i-i)-k|
$$

就又是中位数了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10000+10],y[10000+10],n,ans;
int main(){
	ios_base::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
	sort(&x[1],&x[n+1]); sort(&y[1],&y[n+1]);
	for(int i=1;i<=n;i++) x[i]-=i; sort(&x[1],&x[n+1]);
	for(int i=1;i<=n/2;i++) ans+=x[n-i+1]-x[i]+y[n-i+1]-y[i];
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：fengyuhaoz (赞：4)

哦！！！第三篇题解！！！！

首先，还是我的开场白，嗯，好的，说完了。

直入主题

我的解法好像与楼下的有许多相似之处

其实我们重点看纵坐轴就行了

好的，废话不多说，解释在代码中，上你们最喜欢的代码君

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[1000001];
int y[1000001];
int n,zb1,zb2,c=0;
int main(){ 
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>x[i];//输入纵坐标
	   	cin>>y[i]; //输入横坐标
	}
    for(int i=1;i<n;i++)
	{
    	for(int j=1;j<=n-i;j++){
    		if(x[j]>x[j+1])
    		swap(x[j],x[j+1]);} }//排序（纵坐标）  
    for(int i=1;i<n;i++)
	{
    	for(int j=1;j<=n-i;j++){
    		if(y[j]>y[j+1])
    		swap(y[j],y[j+1]);} } //排序（横坐标）    
    for(int i=1;i<=n;i++)
       x[i]=x[i]-i;     //因为士兵要站一排，所以相减且不同      
    for(int i=1;i<n;i++)
	{
    	for(int j=1;j<=n-i;j++){
    		if(x[j]>x[j+1])
    		swap(x[j],x[j+1]);} }  //减完之后，必须要继续排（因为顺序被打乱了）
    if(n%2==0){        
	zb1=(x[n/2]+x[n/2+1])/2;zb2=(y[n/2]+y[n/2+1])/2;}//后面的就是取中位数了，详见P1862
    else{zb1=x[n/2+1];zb2=y[n/2+1];}
    for(int i=1;i<=n;i++)
       c=c+abs(zb1-x[i])+abs(zb2-y[i]);
    cout<<c;    //输出
    return 0;//结束
}
```
最后，希望管理大大通过！

还有，切勿抄袭！ 

有不对的地方，请大家斧正！

制作不易，请谅解！

---

## 作者：2c_s (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10461)

## 思路

题目要求找最近位置，根据数学原理，最佳位置应该是这些数横纵坐标的中位数所组成的位置。

我们排两次序，第一次找目标位置的横坐标，第二次找目标位置的纵坐标。由于这样会有一定误差，所以我们把计算出的纵坐标取 $\pm 5$ 作为中点进行计算。之后进行循环，设目标点为 $(ex,ey)$，那么这个点 $(x_i,y_i)$ 到目标点的距离就是 $|x_i-ex|+|y_i-ey|$，总距离为：

$$\sum_{i=1}^n |x_i-ex|+|y_i-ey|$$

最后输出这些中点计算值的最小值即可。

- 记得开 `long long`。注意 $n$ 的奇偶性。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4+10;
ll n,ex,ey,ans=1e18;//记得赋极大值。
struct node{ll x,y;}a[N];
bool cmp(node a,node b){
	if(a.y!=b.y)return a.y<b.y;
	else return a.x<b.x;
}
bool cmp2(node a,node b){
	if(a.x!=b.x)return a.x<b.x;
	else return a.y<b.y;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i].x>>a[i].y;
  
	sort(a+1,a+1+n,cmp);//按横坐标排序。
	if(n&1)ey=a[n+1>>1].y;
	else ey=a[n+1>>1].y+a[n>>1].y>>1;
  
	sort(a+1,a+1+n,cmp2);//按纵坐标排序。
	if(n&1)ex=a[n+1>>1].x;
	else ex=a[n+1>>1].x+a[n>>1].x>>1;
  
	for(int k=-5;k<=5;++k){
		ll p=ex-n/2+k,res=0;
		for(int i=1;i<=n;++i)res+=abs(a[i].y-ey)+abs(a[i].x-p++);
		ans=min(ans,res);
	}
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/159388448)

---

## 作者：qmq菜死了 (赞：2)

这题的题意简单来说就是把一些点排成一行，求最少移动次数，所以应该用贪心思想，通过排序来解决。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
	int n,a[10005],b[10005],s=0,y,s2=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
	}
	sort(a+1,a+n+1);//分别将横坐标和纵坐标进行排序
	sort(b+1,b+n+1);
	y=b[(n+1)/2];//要讨论行所以应该反过来求列
	for(int i=1;i<=n;i++)
	{
		s=s+abs(b[i]-y);//求出必须需要移动的步数
	}
	for(int i=a[1]-n;i<=a[1]+n;i++)
	{
		int m=0;//需要累加每次循环初值都赋值为0
		for(int j=1;j<=n;j++)
		{
			int k=a[j];
			m=m+abs(k-(i+j-1));//累加需要移动距离
		}
		if(m<s2||s2==0)//贪心求最少移动次数
		{
			s2=m;
		}
	}
	s=s+s2;//累加即为所求
	cout<<s;
	return 0;
    	//应该没有和我一样代码的吧 qwq
}
```


---

## 作者：wanyaxin (赞：2)

####  这道题本蒟蒻想了好久才做出来,希望题解可以审核通过
#### 思路如下：
- 首先，要找到最优的一列（使移动步数最少的一列），其实就是要找一条平行于x轴的直线，设此直线为x=k，那么，每个点到这条距离为|yi-k|，不难发现，当k是所有点纵坐标的中位数时，距离之和最小。
- 找到了这条直线之后，又该把每个点移到哪个位置才能使结果最优呢？可以设最左边的点（第一个点）移动后的位置为b,因为所有点必须排在一条线段上，那么第二个点的移动后的位置即为b+1，第三个移动后的位置为b+2......以此类推，第n个点移动后的位置为b+n-1。那么横向移动的步数之和为|x1-b|+|x2-b-1|+|x3-b-2|+......+|xn-b-n+1|，所以，要使步数之和最小，只需要再找一次中位数即可。
##### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10001];
int y[10001];
int main()
{
	int n,i,ans=0,fx,fy;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	sort(y+1,y+n+1);
	sort(x+1,x+n+1);
	if(n%2==0)
	{
		fy=(y[n/2]+y[n/2+1])/2;
	}
	else
	{
		fy=y[n/2+1];
	}
	for(i=1;i<=n;i++)
	{
		ans+=abs(fy-y[i]);
	}
	for(i=1;i<=n;i++)
	{
		x[i]-=i;
	}
	sort(x+1,x+n+1);
	if(n%2==0)
	{
		fx=(x[n/2]+x[n/2+1])/2;
	}
	else
	{
		fx=x[n/2+1];
	}
	for(i=1;i<=n;i++)
	{
		ans+=abs(x[i]-fx);
	}
	cout<<ans;
}
```

---

## 作者：chenxi (赞：1)

X轴方向上的考虑?首先需要对所有士兵的X轴坐标值进行排序?

然后，按从左至右的顺序依次移动到每个士兵所对应的“最终位置”（最优），

所移动的步数总和就是X轴方向上需要移动的步数?例，

最左的士兵移动到“最终位置”的最左那位，

第二个士兵移动到“最终位置”的第二位?则总的步数为：

士兵一移动步数+士兵二移动步数+?……?+士兵n移动步数?如何确定X轴

方向上的最佳的“最终位置”？?共n个士兵?他们相应的X轴坐标为

：X0，X1，X2?……?……?Xn-1?设，士兵需要移动到的“最终位置”的X轴

坐标值为：k，k+1，k+2?……?……?k+（n-1）?则所求最优步数S=|X0-k|+|
X1-?（k+1）?|+|X2-（k+2）|+?……?+|Xn-1-（k+（n-1））|?经过变形S=|
X0-k|+|（X1-1）-k|+|（X2-2）-k|+?……?……?+|（Xn-1-（n-1））-k
|?注意到公式的形式与Y轴方向上的考虑一样，同样是n个已知数分别减

去一个待定数后取绝对值，然后求和?因此还是采用取中位数的办法求得

k值，最后算出最优解。//并非原话

```delphi

var 
  x,y:sj;
  i,mid,step,n,a,min:longint;
procedure px(l,r:longint;var a:sj);
var
  i,j,k,t:longint;
begin
  i:=l;
  j:=r;
  k:=(l+r) div 2;
  t:=a[k];
  a[k]:=a[l];
  while i<j do
  begin
    while (i<j) and(a[j]>t) do
      dec(j);
    if i<j then
    begin
      a[i]:=a[j];
      inc(i);
    end;
    while (i<j) and(a[i]<t) do
      inc(i);
    if i<j then
    begin
      a[j]:=a[i];
      dec(j);
    end;
  end;
  a[i]:=t;
  if i-1>l then
    px(l,i-1,a);
  if i+1<r then
    px(i+1,r,a);
end;
begin
    readln(n);
    for i:=1 to n do
     read(x[i],y[i]);
    px(1,n,y);
    mid:=y[n div 2+1];
    step:=0;
    for i:=1 to n do
     step:=step+abs(y[i]-mid);
    px(1,n,x);
    for i:=1 to n do
      x[i]:=x[i]-i+1;
    px(1,n,x);
    mid:=x[n div 2+1];
    for i:=1 to n do
     step:=step+abs(x[i]-mid);
    writeln(step);
end.

```

---

## 作者：不到前10不改名 (赞：0)

//思路：贪心思想，先让x坐标没有重合，再计算出中数即题目所求的x,y，之后对于x轴的移动和y轴的移动为|xi-x|，|yi-y|
```
//本题解已经使用防伪标识以及修改
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int n,srx[10001],sry[10001],i,j,lhy,x,y,t;
int main()
{
	 scanf("%d",&n);
	 for(i=1;i<=n;i++)
	 scanf("%d%d",&srx[i],&sry[i]);
	 sort(srx,1,n);
	 sort(sry,1,n);//第一遍排序
	 for(i=1;i<=n;i++)
     srx[i]-=i;//之前一直认为是直接在后面减去，结果...
     sort(srx,1,n);//剪完之后就会保证x值不会有重合（如果原先相同由于减去的数不同也会不同）
     if(n%2==0)//求中位数有奇偶之分             
     {x=(srx[n/2]+srx[n/2+1])/2;
     y=(sry[n/2]+sry[n/2+1])/2;}
     else
     {x=srx[n/2+1];
     y=sry[n/2+1];}
     for(i=1;i<=n;i++)
     lhy+=abs(srx[i]-x)+abs(sry[i]-y);//绝对值
	 printf("%d",lhy);
	 return 0;
	 }
```

---


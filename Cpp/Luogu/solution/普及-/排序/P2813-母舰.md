# 母舰

## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）


## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。


## 说明/提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。

## 样例 #1

### 输入

```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000```

### 输出

```
2000```

# 题解

## 作者：sjl40 (赞：51)

/\*
这道题目有几个关键点要知道:

一、每个攻击系统只能打一个防御系统，打完了就没了。

二、我方的攻击系统的攻击力或者是敌方的防御系统的防御力可能为0。

三、要用尽量小的打他的防御系统，因为大的要放后面打母舰。

下面进入程序部分。

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int tf[10000000],wf[10000000];
int m,n,s,i,t;
int main()
{
 cin>>m>>n;//输入敌方的防御系统数量和我方的攻击系统数量
 for(i=1;i<=m;i++)scanf("%d",&tf[i]);//输入敌方的防御系统的防御力
 for(i=1;i<=n;i++)scanf("%d",&wf[i]);//输入我方的攻击系统的攻击力
 sort(tf+1,tf+1+m);//进行排序。（注意：这里要从小到大，否则就不能用尽量小的来打敌方的防御系统，留大的来打母舰。）
 sort(wf+1,wf+1+n);//进行排序。（注意：这里要从小到大，否则就不能用尽量小的来打敌方的防御系统，留大的来打母舰。）
 t=1;//定义敌方现有的,最小的防御系统的防御力
 for(i=1;i<=n;i++)
 {
  if(tf[t]==0)t++;//要特别注意这里！！！否则其实没有防御系统，程序也自动把他当成有0的防御力的防御系统。
  if(tf[t]<wf[i]&&tf[t]!=0){wf[i]=0;t++;}//再判断一下当前的攻击系统能打破敌方现有的,最小的防御系统。如果能就清0做标记，并且换下一个防御系统进行攻打。
 }
 if(t<=m){cout<<0;return 0;}//如果打不完防御系统就一点伤害都没有。
 for(i=1;i<=n;i++)s+=wf[i];//否则就是有伤害，把剩下的攻击系统的攻击力加起来，这些就是可以打到母舰的攻击系统。
 cout<<s;//输出最多能打多少伤害
}
```

---

## 作者：EarthGiao (赞：15)

总体思路：
输入护盾和攻击力，然后快速排序sort走起来，

排完序之后从第一个开始找，如果攻击力大于护盾，护盾继续下一个，

这个攻击力记录为0，如果小雨的话，那就攻击力继续下一个，护盾不动，

其中最为特别的地方也就是占了很大一部分数据点的，那就是护盾是0这种情况了，当护盾是零的时候，护盾继续下一个找，但是攻击力就不要动了。

然后让我来分布解析代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <set>
#include <iomanip>

using namespace std;

int hudun[100001],gongji[100001];
```
这是可食用的头文件，数组用来干啥，拼音打好了qwq

接下来

```cpp
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i) {
		scanf("%d",&hudun[i]);//护盾防御力 
	}
	for(int j=1; j<=m; ++j) {
		scanf("%d",&gongji[j]);//攻击力 
	}
```
输入防御系统和攻击力的数量

分别是n和m

然后for循环存入数组中去

然后

很简单的sort快速排序，虽然这个很容易爆炸，但是用在这个题中还是可以AC的

```cpp
	sort(hudun+1,hudun+n+1);//快速排序 
	sort(gongji+1,gongji+m+1);//快速排序 
```
注意上面必须要+1哦，因为我上面输入的时候是从1开始到n或者到m的而不是从0开始的，如果是从0开始，那这个+1就是真的没用了哦

下面高潮来了！！！！！！！！！！！！

最核心的代码部分！！！！！！！！

```cpp
		int ans=0,js=1,jss=1;//计数器 
		while(jss!=n + 1) {//结束条件，也就是防护盾全部攻破的时候 
		if(js == m + 1 && jss != n + 1) {
			printf("0\n");
			return 0;
		}
		if(hudun[jss]==0) {//护盾是零的时候 
			jss++;
			continue;
		} else if(hudun[jss]<gongji[js]) {//可以打破护盾的时候 
			gongji[js]=0;
			jss++;
			js++;
			continue;
		} else {
			js++;
			continue;
		}
     }
```
ans是最后的答案先不用管它，这块用不到的，js是计数攻击力是第几个的计数器，那么jss显而易见就是防御系统的计数器啦

都从第一个开始找，如果护盾小于攻击力，护盾的计数器就累加，攻击力就变为零，因为可以看做和护盾抵消了

如果大于或者等于的话，那就继续找，也就是攻击力的计数器js累加，因为sort排好序了所以越往后面找伤害越大的

前面特判护盾是0的时候，只需要护盾的计数器jss累加就好了

结束条件当攻击力用完了但是护盾还有剩余的话，就结束输出0就好了

```cpp
	for(int i=1; i<=m; ++i) {
		//printf("%d\n",gongji[i]);
		ans+=gongji[i];//挨个加起来 
	}
	printf("%d\n",ans);//输出 
	return 0;
```
最后从第一个开始累加，消耗掉的都变成了0，所以直接加就好了，加出来的数就是能够造成的伤害

完整代码双手奉上qwq

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <set>
#include <iomanip>

using namespace std;

int hudun[100001],gongji[100001];

int main() {
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i) {
		scanf("%d",&hudun[i]);//护盾防御力 
	}
	for(int j=1; j<=m; ++j) {
		scanf("%d",&gongji[j]);//攻击力 
	}
	sort(hudun+1,hudun+n+1);//快速排序 
	sort(gongji+1,gongji+m+1);//快速排序 
	int ans=0,js=1,jss=1;//计数器 
	while(jss!=n + 1) {//结束条件，也就是防护盾全部攻破的时候 
		if(js == m + 1 && jss != n + 1) {
			printf("0\n");
			return 0;
		}
		if(hudun[jss]==0) {//护盾是零的时候 
			jss++;
			continue;
		} else if(hudun[jss]<gongji[js]) {//可以打破护盾的时候 
			gongji[js]=0;
			jss++;
			js++;
			continue;
		} else {
			js++;
			continue;
		}
	}
	for(int i=1; i<=m; ++i) {
		//printf("%d\n",gongji[i]);
		ans+=gongji[i];//挨个加起来 
	}
	printf("%d\n",ans);//输出 
	return 0;
}
```


---

## 作者：Saliеri (赞：11)

### [P2813 母舰](https://www.luogu.org/problem/P2813)

------

首先观察数据范围

非常明显的$\Theta(nlog_2n)$的复杂度

------

这道题主要需要思考的是

如何保证攻击系统能打出**最多的伤害**

贪心策略显而易见：

**选择攻击力最小的 能够击毁防御系统的系统攻击**

怎么保证最小？

$\Theta(n^2)$解法无法承受

所以 ———— **排序**

排序后用一个指针维护最小满足条件的攻击系统即可

~~真的没必要$lowerbound $~~

----

$Tips : $

**不要忘了加上前面无法满足任何需求的攻击系统的伤害作为答案**

[这人](https://www.luogu.org/space/show?uid=199266)就是这么做的，~~然后他交了八九遍~~

___

### Code
我知道你们就想看这个

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 1e5+5;
int n,m,ans = 0;
int attack[maxn],defense[maxn];
int main(){
	scanf("%d %d",&m,&n);
	if(n <= m){printf("0");return 0;}
	for(int i=1;i<=m;++i)scanf("%d",&defense[i]);
	for(int i=1;i<=n;++i)scanf("%d",&attack[i]);
	sort(attack+1,attack+n+1),sort(defense+1,defense+m+1);
	int pa = 1;
	for(int i=1;i<=m;++i){
		while(attack[pa] <= defense[i] and pa <= n)ans += attack[pa++];
		++pa;
		if(i != m && pa == n+1){printf("0");return 0;}
	}
	while(pa <= n)ans += attack[pa++];
	printf("%d",ans);
	return 0;
}
```
谢谢观赏




---

## 作者：Rbu_nas (赞：8)

题意描述：一艘舰M个防御系统，夕立有N发炮弹，打击完防御系统后可以对舰造成伤害，问你最大的伤害值。

贪心，没啥好说的，每次发射伤害离防御值最接近的导弹，注意下“炮弹伤害**大于防御系统**可以摧毁防御系统”就好了。

思路：首先对防御值与伤害值都进行排序，依次枚举防御值$Tex_i$，如果没有找到可以破坏其的导弹$Poi_i$，直接输出$0$。

寻找导弹这里采用的是$STL$炒鸡好用的`upper_bound`。

---

代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

typedef long long LL;                                      //为了防tot与ans炸随手long long. 
const int N=100000+5;
LL Tex[N], Poi[N], tot_tex, tot_poi, ans;                  //Tex-防御值 Poi-导弹伤害值. 

int main(int argc, char const *argv[])
{
    int m, n; scanf("%d %d", &m, &n);
    if(n < m) return printf("0")&0;                        //小优化,如果导弹数量比防御系统数量还少肯定咕咕. 
    for(register int i=1; i<=m; ++i) scanf("%lld", &Tex[i]), tot_tex+=Tex[i];
    for(register int i=1; i<=n; ++i) scanf("%lld", &Poi[i]), tot_poi+=Poi[i];
    if(tot_poi <= tot_tex) return printf("0")&0;           //如果导弹总伤害值都不够打的也凉凉. 
    sort(Tex+1, Tex+m+1); sort(Poi+1, Poi+n+1);            //排序,从小到大枚举防御值. 
    for(register int i=1; i<=m; ++i)
    {
        int Place=upper_bound(Poi+1, Poi+n+1, Tex[i])-Poi; //找出第一个大于防御值的导弹的位置. 
        if(Poi[Place] < Tex[i]) return printf("0")&0;
        Poi[Place]=0;  
    }
                                                           
    for(register int i=1; i<=n; ++i) ans+=Poi[i];          //累加还没有发射的导弹伤害值.
    printf("%lld", ans);
    return 0;
}

```

---

最后求过+赞$\mathfrak{qwq}$

大家珂以做做[P2695 骑士的工作](https://www.luogu.org/problemnew/show/P2695)来练练手，思路完全一样

---

## 作者：YWY_wys (赞：6)

**写在前面**

**抄袭可耻 抄袭可耻 抄袭可耻**

#贪心

- 我们需要考虑每个防御系统被哪个攻击系统攻击，以得到最优解

- 那么对于每个防御系统而言，大于他防御力的攻击力最弱且没有攻击目标的的那个系统肯定是最优的

- 然后将攻击系统和防御系统排序即可获得一个O（n）的复杂度

- 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=100005;
int n,m;
int a[maxn],b[maxn];
int calc(){
    int i=1,j=1;
    int res=0;
    while(i<=m&&j<=n){
        if(a[i]>b[j]) j++;//如果能打破，则打破 否则这个攻击系统只可能打到母舰上 
        else res+=a[i];
        i++;
    }
    if(j<=n) return 0;//如果没打完防御系统，那么伤害为0； 
    while(i<=m) res+=a[i++];//剩余防御系统全部打在母舰上； 
    return res;
}
int main(){
    int ans;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&b[i]);
    for(int i=1;i<=m;i++) scanf("%d",&a[i]);
    sort(a+1,a+m+1);
    sort(b+1,b+n+1);
    ans=calc();
    printf("%d",ans);
}
```


---

## 作者：MuYC (赞：5)

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
int a[100000],b[100000],book[100000];
using namespace std;
int main(){
	int i,j,k,l,o,p=0,n,next=1,m=0,cnt=0,gong=0;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	cin>>a[i];//读入防御舰艇
	for(i=1;i<=m;i++)
	cin>>b[i];//读入攻击舰艇
	sort(b+1,b+1+m);//排序，尽量用最小的攻击去攻击最大的母舰
	sort(a+1,a+1+n);//
	for(i=1;i<=n;i++){
		for(j=next;j<=m;j++){/*这里我定义了一个next,上次没定义就超			时了定义这个可以从上次搜索的后一个来继续查找，想想为什么吧*/
			if(b[j]>a[i]&&book[j]!=1){/*找到可以打沉此母舰的最小的			攻击母舰*/
				book[j]=1;
				a[i]=0;
				p++;
				cnt++;
				break;
			}
		}
		next=j;
		}
	for(i=1;i<=m;i++)
	if(book[i]!=1)
	gong+=b[i];//如果这个攻击母舰还没攻击过 
	if(p==n&&m>n)//如果可以达到目的便输出伤害值
	cout<<gong;
	else cout<<0;//否则就以题目意思输出0
	return 0;
}
```

---

## 作者：spsp23 (赞：4)

# 看了一眼题解，竟然没有优先队列。

------------
~~偷乐~~

### 用c++自带的priority_queue

------------
便捷又欢乐。

priority_queue自带功能

------------
示例

q.pop() 删除堆顶元素；

q.top() 查询堆顶元素（最大值）；

q.push() 把元素插入堆;

比起其他，priority_queue功能不多，但也足够啦。

------------
至于思路，其他大佬解释得很清楚了。

## 尽量用小的攻击系统去打防御系统。

###### 上代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,pp,qq,x;//
long long num=0;//存答案 
priority_queue<int> p,q;
int main(){
  scanf("%d%d",&m,&n);
  for(int i=1;i<=m;i++){
  	scanf("%d",&x);
	if(x>0) p.push(-x);//不知道是不是还有负权。 
  }
  for(int i=1;i<=n;i++){
  	scanf("%d",&x);
	if(x>0) q.push(-x);//默认大根堆，取反加入。 
  }
  while(!q.empty() || !p.empty()){//两个堆都不空。
  	if(q.empty() && !p.empty()){//攻击系统用完了，防御系统还有。
  		cout<<"0";return 0;//提前结束。 
  	}
  	if(p.empty()) break;//防御系统全部打掉。
  	int qq=-q.top();q.pop();//取反取出。 
  	int pp=-p.top();p.pop();
  	if(qq>pp) continue;//这个攻击系统和防御系统一起吹了。
	                   //一开始以为=也可以取555 
  	num+=qq,p.push(-pp);//防御系统没用到，再加入。 
  }
  while(!q.empty()){承接上文，防御系统全部打掉，放心地开火（累加）
  	num+=-q.top();q.pop();
  }
  cout<<num;
}
```


---

## 作者：SGOI_Aromyase (赞：4)

讲道理，这题十分微妙，一开始看题以为是只用打最小的母舰，然后瞄准一个使劲输出的水题，后来发现不是这么搞的...


楼上的题解**可读性不高，而且繁琐**

首先打出最大伤害，当然是**攻击母舰稍微比防御母舰攻击稍微高一些**

于是我们就把攻击母舰数值和防御母舰数值排序，找到稍微大的赋值为0就可以了

```cpp
o(n)算法就出来了
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100005]={0},b[100006]={0};
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&a[i]); sort(a,a+n);//读入，排序，攻击母舰
    for(int i=0;i<m;i++) scanf("%d",&b[i]); sort(b,b+m);//读入，排序，防御母舰
    int now=0; //有M个防御母舰，依次找最大，从0开始
    for(int i=0;i<m;i++){
        if(b[i]>a[now]) {
            b[i]=0;now++;//找到稍微大的攻击母舰，然后赋值为0~
        }
        if(now==n) break; //找完了~
    }
    int tot=0;
    if(now!=n){  //如果有一个根本打不破的防御母舰，GG
        printf("0");
        return 0;
    }
    for(int i=0;i<m;i++) tot+=b[i];//循环，把剩下攻击母舰数值相加
    printf("%d",tot);
    return 0;
}
```

---

## 作者：lydon (赞：4)

# include "cstdio"

# include "iostream"

# include "algorithm"

```cpp
using namespace std;
int de[100005],wo[100005];
int main()
{
    int n,m;
    int x=0,ans=0;
    scanf("%d %d",&m ,&n);
    for(int i=1;i<=m;i++)
    scanf("%d",&de[i]);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&wo[i]);
        ans+=wo[i];//假设每一个攻击系统都打到了敌方母舰身上
    }
    if(n<=m)//如果攻击系统没有防御系统多或和防御系统一样多，那么就每有攻击系统打到母舰身上
    {
        cout<<0<<endl;
        return 0;
    }
    sort(de+1,de+m+1);
    sort(wo+1,wo+n+1);
    for(int i=1;i<=n;i++)
    {
        if(x==m||wo[i]<=de[x+1])//所有的防御系统都没了或当前攻击系统不能击溃当前防御系统，那么就假设它们都打到了母舰身上
        continue;
        x++;
        ans-=wo[i];//表示当前的攻击系统用来攻击防御系统
    }
    if(x<m)//防御系统没有全消失
    cout<<0<<endl;
    else
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：清辉暮翊晨 (赞：2)

第一篇题解qwq

其实还有一篇没过审（划掉）

这个题大概意思就是用攻击系统依次换防御系统，算换完之后剩余攻击系统攻击力之和的最大值。

就讲一下定义的o吧。

o做的是防御系统的下标，要对母舰本体造成伤害防御系统必须全废，所以所有攻击系统必须消耗数量等同于防御系统数量的一部分去换防御系统，而我们要求的是剩余攻击系统的攻击力总和最大值，也就是说换防御系统的攻击系统攻击力尽可能小，所以要对防御系统和攻击系统从小到大排序；排序之后第一个找到的当前要消除的防御系统对应攻击系统的攻击力是最小，即最优的，这就是题目标签上的贪心。


还有m大于等于n时的特判，因为攻击系统和防御系统是一换一，攻击系统不比防御系统多时就绝对无法对母舰造成伤害，所以直接输出0。

附代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum;
int o=1;//记录防御系统下标 
int a[1000005],b[1000005];
int main()
{
	cin>>m>>n;//防御数，攻击数 
	if(m>=n)
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=m;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	sort(a+1,a+1+m);
	sort(b+1,b+1+n);//输入+排序
	for(int i=1;i<=n;i++)//循环攻击系统攻击力
	{
		if(o==m+1)break;//防御系统全部打完的时候跳出
		if(b[i]>a[o])//攻击大于防御 
		{
			b[i]=0;//该攻击系统失效
			o++;//换下一个防御系统
		}
	}
	for(int i=1;i<=n;i++)sum+=b[i];
	cout<<sum;
	return 0;
}
# ```




---

## 作者：SUNCHAOYI (赞：1)

**这道题不难，一看就是一道排序题**

**两组数据输入后从小到大排序，然后判断能否攻击来毁掉敌方防御系统。  但需要特别注意：有可能防御系统为0**

**继续，全部过一遍后，看看防御系统是否还有**

**有：输出0；无：输出攻击系统剩余的和(所以之前打过的得标0)**

------------

**代码：**
```
#include <iostream>
#include <algorithm> 
using namespace std;
const int MAX = 100001;
int a[MAX],b[MAX];
int main()
{
	int n,m,cnt = 1,ans = 0;
	cin>>n>>m;
	for(int i = 1;i <= n;i++)cin>>a[i];
	for(int i = 1;i <= m;i++)cin>>b[i]; 
	sort(a + 1,a + n + 1);sort(b + 1,b + m + 1);
	for(int i = 1;i <= m;i++)
	{
		if(a[cnt] == 0) cnt++;//没有防御力的 
		else if(a[cnt] < b[i])//打得过 
		{
			cnt++;b[i] = 0;//已经打垮，标记为已用过 
		}	
	}
	if(cnt <= n) cout<<"0"<<endl;//还没打完 
	else
	{
		for(int i = 1;i <= m;i++) ans += b[i];
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：likztime (赞：1)

```cpp
#include<cmath>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<set>
#include<stack>
#include<deque>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXN=100000+5;
int a[MAXN],b[MAXN];//a每一个防御系统的防御力，b每一个攻击力
int main() {
    int m,n;//m敌防御数量，n我方攻击数量
    int x=1,ans=0;// 因为下标从1开始的，x初始化为1
    //ans为真实的伤害 
    scanf("%d%d",&m,&n);
    if(n<=m) {//执行操作前先判断防御系统与攻击系统的数量 
        printf("0\n");
        return 0;
    }
    for(int i=1; i<=m; ++i) {
        scanf("%d",&a[i]);
    }
    for(int i=1; i<=n; ++i) {
        scanf("%d",&b[i]);
        ans+=b[i];//假设没有防御系统，意思是全部打在母舰上 
    }
    sort(a+1,a+m+1);//从小到大的打，因为是最大伤害
    sort(b+1,b+n+1);
    for(int i=1; i<=n&&x<=m; ++i) {// 摧毁的数量肯定是小于等于总防御数量 
        if(b[i]<=a[x])//没摧毁成功就直接跳过 ，x不会上升 
            continue;
        //能摧毁这次的防御系统，转到下一次的防御系统 
        x++;//增加摧毁防御系统的个数
        ans-=b[i];//减去这个打破了防御的攻击系统的攻击力
    }
    if(x<=m)printf("0\n");//如果攻击系统全没了但是防御系统还有 
    else printf("%d\n",ans);
    return 0;
}
```

---

## 作者：鹭天 (赞：1)

######这题得用排序

建议从小到大，因为大的伤害高，可以留到后面。

那么样例的意思就是：

我先排序数组a和b，如下：

a：1000  1000  1200  2000  2100

b：1000  1200  2000

先让数组a去和b比较，因为他说只能大于，不能小于，所以两个1000没用，他是这样打：

a的1200去打1000；a的2000去打1200；a的2100去打2000；

那么a就还剩两个1000，顾为2000；

```cpp
type arr=array[1..100000] of longint;
var
  n,m,i,j,s,k:longint;
  a,b:arr;
  f:boolean;
procedure qsort(l,r:longint);//快排程序段
var i,j,t,mid:longint;
begin
  i:=l;j:=r;mid:=a[(l+r) shr 1];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then begin
      t:=a[i];a[i]:=a[j];a[j]:=t;inc(i);dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;//我就不讲了
procedure qsort1(l,r:longint);//其实本来可以用一个快排就能解决，但我怕有些人不懂。qsort排序a数组，qsort1排序b数组。
var i,j,t,mid:longint;
begin
  i:=l;j:=r;mid:=b[(l+r) shr 1];
  repeat
    while b[i]<mid do inc(i);
    while b[j]>mid do dec(j);
    if i<=j then begin
      t:=b[i];b[i]:=b[j];b[j]:=t;inc(i);dec(j);
    end;
  until i>j;
  if l<j then qsort1(l,j);
  if i<r then qsort1(i,r);
end;
begin
  readln(m,n);f:=true;//用来判断能不能打破防御，我已开始认为可以。
  for i:=1 to m do readln(b[i]);
  for i:=1 to n do readln(a[i]);
  qsort(1,n);
  qsort1(1,m);//排序
  j:=1;//a数组的下标
  for i:=1 to m do begin//b数组循环
    while (a[j]<=b[i])and(j<=n) do inc(j);//找最小能够打掉b防御的攻击（有可能一个都打不掉，所以要加条件（j<=n））
    if j<=n then begin a[j]:=0;b[i]:=0;end;//如果j<=n 那么就可以打掉，那么数组都清空。
  end;
  for i:=1 to m do if b[i]>0 then f:=false;//判断，如果b数组有一个大于0的，那么说明该防御系统还在，那么就不可能打到主体。
  if f then begin//如果打掉了那就累加
    for i:=1 to n do 
      s:=s+a[i];//这里不用担心，也不用单独开辟一个数组来判断，如果a[i]是0，那就等于没加。
    write(s);
  end
    else write(0);//不然没输出0
end.
######程序只供参考，不可抄袭！！
```

---

## 作者：159号程序员 (赞：0)

这是一道水题，用的是贪心的算法。

首先，我们可以用我方攻击力最小的去打敌方防御力最小的。

然后，如果打得过，记录已击败，把该防御系统的防御值设为0。

重复前两步，如果未打完，输出0，不可能打完。

如果打完了，输出攻击系统的和，因为打完的已写为0。

实现方法：

1. 输入，不需多说：

```cpp

	int n, m, jihuishu = 1, ans = 0;
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
	    cin >> a[i];
	}
	for(int i = 1; i <= m; i++)
	{
	    cin >> b[i];
	}

```

2. 排序，让最小的打最小的，最大的打最大的：

```cpp
	sort(a + 1,a + n + 1);
	sort(b + 1,b + m + 1);
```

3. 开始记录：

```cpp
	for(int i = 1; i <= m; i++)
	{
		if(a[jihuishu] == 0) //特判，如果本身为0，无需攻击，直接增加击毁数。
		{
		    jihuishu++;
		}
		else if(a[jihuishu] < b[i])//打得过，直接打。
		{
			jihuishu++;
			b[i] = 0;
		}	
	}

```

4. 输出

```cpp
	if(jihuishu <= n)//如果没打完，直接输出0。
	{
	    cout << "0" << endl;
	}
	else
	{
		for(int i = 1; i <= m; i++) //否则累加攻击还剩余的值，去打母舰。
		{
		    ans += b[i];
		}
		cout << ans << endl;
	}
```

完整 _AC Code_ ：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10001], b[10001]; //a 代表我舰伤害值，b 代表敌舰防御值。
int main()
{
	int n, m, jihuishu = 1, ans = 0;//jihuishu 代表击毁的数量(拼音)
	cin >> n >> m; // 输入
	for(int i = 1; i <= n; i++)
	{
	    cin >> a[i];
	}
	for(int i = 1; i <= m; i++)
	{
	    cin >> b[i];
	}
	sort(a + 1,a + n + 1); //排序
	sort(b + 1,b + m + 1);
	for(int i = 1; i <= m; i++) //循环判断每一次攻击
	{
		if(a[jihuishu] == 0) //特判，如果此处没有防御系统，直接增加击毁数。
		{
		    jihuishu++;
		}
		else if(a[jihuishu] < b[i]) // 直接攻击，记录击毁数。
		{
			jihuishu++;
			b[i] = 0;
		}	
	}
	if(jihuishu <= n) // 没打过，输出0。
	{
	    cout << "0" << endl;
	}
	else
	{
		for(int i = 1; i <= m; i++) //否则输出攻击系统剩余的值(也是对母舰的伤害值)。
		{
		    ans += b[i];
		}
		cout << ans << endl;
	}
	return 0;
}
```

解释一下原理，以这组输入为例：

**2000 2000 1200 1500 0000**

**2100 2000 1200 1000 1000**

上方为敌舰防御系统，下方为我舰攻击系统。

最优方案：

第一轮：2000 VS 2100 成功击毁

第二轮：2000 VS 2000 成功击毁

第三轮：1500 VS 1000 未成功击毁，还剩500点防御值

第四轮：1000 VS 500  成功击毁，并且剩余的500点伤害转移向母舰。

所以，最优方案输出为500。

---

## 作者：xckxck (赞：0)

python3解法
先排序，over计算是否有防御塔无法消灭，fang保存防御塔，gong保存攻击，z保存循环中搜到的位置，没有的话影响速度，会有一个超时
先判断n小于m，如果防御机器多余攻击就输出0
然后，循环保存输入数据，再排序，然后开始根据防御机器循环计算，双重循环，每次找到后就从列表删除元素，并把找到的位置保存，下次直接从这个位置继续，可以提高速度，如果发现有一个无法打败，退出循环，输出0。等防御机器全消灭后，计算gong列表剩下的元素，求和。
```python
m,n=map(int,input().split())
fang=[0 for i in range(m)]
gong=[0 for i in range(n)]
over=False
z=0
if n<=m:
    print(0)
else:
    for i in range(m):
        fang[i]=int(input())
    for i in range(n):
        gong[i]=int(input())
    fang.sort()
    gong.sort()
    for i in range(m):
        over=False
        for j in range(z,len(gong)):
            if gong[j]>fang[i]:
                gong.pop(j)
                z=j
                over=True
                break
        if over==False:
            break
    if over==False:
        print(0)
    else:
        su=0
        for i in gong:
            su=su+i
        print(su)
```


---

## 作者：charles547 (赞：0)

Pascal，贪心，水题一道

排序一下就行了

```cpp
type
  arr=array[0..200000] of longint;
var
  a,b:arr;
  t:array[1..200000] of boolean;
  i,j,s,k,m,n:longint;
procedure qsort(l,r:longint;var c:arr);
var
  i,j,m,t:longint;
begin
  i:=l;
  j:=r;
  m:=c[(l+r) div 2];
  repeat
    while m>c[i] do
      inc(i);
    while m<c[j] do
      dec(j);
    if i<=j then
    begin
      t:=c[i];
      c[i]:=c[j];
      c[j]:=t;
      inc(i);
      dec(j);
    end;
  until i>j;
  if i<r then qsort(i,r,c);
  if j>l then qsort(l,j,c);
end;
begin
   readln(n,m);
   for i:=1 to n do
     readln(b[i]);
   for i:=1 to m do
   begin
     readln(a[i]);
     t[i]:=true;
   end;
   if n>=m then
   begin
     writeln(0);
     halt;
   end;
   qsort(1,n,b);
   qsort(1,m,a);
   i:=1;j:=1;
   while (i<=n) and (j<=m) do
   begin
     if b[i]>=a[j] then
     begin
       t[j]:=true;
       inc(j);
     end else
     begin
       inc(i);
       t[j]:=false;
       inc(j);
     end;
   end;
   if i<=n then
   begin
     writeln(0);
     halt;
   end;
   for i:=1 to m do
     if t[i] then
       s:=s+a[i];
   writeln(s);
end.
```

---

## 作者：Johnson_sky (赞：0)

本题可以使用贪心，也可以使用其他方法。

数据比较弱，若数据加强，可以使用读入优化~

代码如下：


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int m,n,f=0,tot=0;
int am[100001],an[1000001];
```
/\*
```cpp
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&& ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();} 
    return x;
}
```
\*/
    
    
    
    
    
```cpp
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&am[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&an[i]); 
    }
    sort(am+1,am+m+1);
    sort(an+1,an+n+1);
    for(int i=1;i<=m;i++)
    {
        for(int j=f+1;j<=n;j++)
        {
            f=j;
            if(an[j]>am[i])
            {
                an[j]=0;
                break;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        tot=tot+an[i];
    }
    if(m>=n)
    {
        cout<<"0";
    }
    else
    {
        cout<<tot;
    }
    return 0;
}
```

---


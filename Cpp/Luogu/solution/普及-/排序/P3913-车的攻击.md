# 车的攻击

## 题目描述

$N \times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。

车可以攻击所有同一行或者同一列的地方。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10^3; 1 \le K \le 10^3$；

• 对于60% 的数据，$1 \le N \le 10^6; 1 \le K \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^9; 1 \le K \le 10^6; 1 \le R_i , C_i \le N$。


## 样例 #1

### 输入

```
3 2
1 2
2 2```

### 输出

```
7```

# 题解

## 作者：Kater_kcl (赞：69)

**本题数据已增强，但是做法不变，仅将读入和输出换成stdio的即可**  

题解好少啊，赶紧水一波。

题目要咱求能被攻击到的格子，但是如果硬处理的话超时是妥妥的，所以咱得想个数学办法，不能只靠模拟来打暴力。

首先考虑能不能直接将x轴与y轴有车的点先全部记录下来，然后将有车的行的数量和有车的列的数量记录下来，然后*n再相加，但是这样显然不可行，因为这样会导致在行列交汇处的点呗重新算2次。

既然被重新计算了，那我们把他们都删掉不就可以了吗？

不难看出，交叉点的个数就是有车的行数*有车的列数，那么就不难导出公式：  
$ans=sizex*n+sizey*n-sizey*sizex$  
然后就是统计一共有几行几列有车了，这里就要用到我大stl中的一员大将：unique,也就是去重，通俗来讲，这个玩应的用法一般是

unique(数组名,数组名+大小)  
(没错和sort几乎一模一样）

然后值得注意的有两点：  
第一点：在$unique$之前必须保证去重数组有序，也就是得$sort$一下。  
第二点：$unique$并不会生成一个新的数组，而是将原数组多余的部分“移”到了数组之后，同时$unique$本身还会返回一个指针，指向去重之后的最后一位。

利用c++可以指针相加减的特点，我们可以通过  unique-数组指针  来知道去重之后数组的“大小”（这里听不懂没关系，往下看代码，背住用法就好）

下面放ac代码
```cpp
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <queue>
#define ll long long
const int maxn=1e6+5;
using namespace std;
ll n,k;
ll x[maxn],y[maxn];
int main(){
 //       freopen("test.in","r",stdin);
        //cin>>n>>k;
        scanf("%lld%lld",&n,&k);
        for(ll i=0;i<k;i++){
                //cin>>x[i]>>y[i];
            scanf("%lld%lld",&x[i],&y[i]);
        }
        sort(x,x+k);
        sort(y,y+k);
        ll sizex=unique(x,x+k)-x;
        ll sizey=unique(y,y+k)-y;
        //cout<<n*n-(n-sizex)*(n-sizey);
        printf("%lld",n*n-(n-sizex)*(n-sizey));
        return 0;
}
```
很简短对不对，嘻嘻。

---

## 作者：lzy755277 (赞：64)

看大佬们的代码都挺长，发一个短代码。

首先想一下：

比如输入车的坐标1，2和3，4，

第1,3行的格子就被攻击了，第2,4列的格子也被攻击了，把被攻击的

行和列都挪在左上角，不被攻击的格子变为(n-2)*(n-2)。

同理，只要统计输入的行不重复的个数h与列不重复的个数l，答案便

为n的平方（星号打不出来）-(n-h)*(n-l)

上臃肿代码，~~连cin都懒得改成快读了~~，不过还是不会TLE
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,k,x[1000002]={0},y[1000002]={0},i,h=0,l=0;
int main()
{
    cin>>n>>k;
    for(i=1;i<=k;i++)
    cin>>x[i]>>y[i];
    sort(x+1,x+k+1);
    sort(y+1,y+k+1);
    for(i=1;i<=k;i++)
    {
        if(x[i]!=x[i+1])h++;//去重
        if(y[i]!=y[i+1])l++;//同上
    }
    cout<<n*n-(n-h)*(n-l);
}
```

---

## 作者：Scherzo (赞：36)

# P3913 车的攻击 题解

这是蒟蒻做的第100道橙题，准备发个题解庆祝一下，求管理大大通过，我一定会尽我所能讲的详细的！

废话不多说正式开始

看到这题当然最先想到DFS啦~

DFS大致思路如下

## Solution 1 30pts

当然，从我开始写代码的时候，我就意识到了DFS绝对会RE（因为我的一个好习惯，详见代码）

也希望大家都能有这个习惯，不要写完代码，蓦然回首，RE就在灯火阑珊处

不过，为了能写出一篇好的题解，~~干了兄弟们~~

~~应该没人不会DFS了吧，就不讲了~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N=1010;//那个好习惯

int n,k;
int map[N][N];
int attack[N][N];
int nx[15]={0,0,1,0,-1};
int ny[15]={0,-1,0,1,0};

void dfs(int x,int y,int dir)
{
	int xx=x+nx[dir];
	int yy=y+ny[dir];
	attack[x][y]=1;
	if (xx>=1&&xx<=n&&yy>=1&&yy<=n&&map[xx][yy]==0)
	{
		dfs(xx,yy,dir);
	}
}

int main()
{
	scanf("%d%d,",&n,&k);
	for (int i=1;i<=k;i++)
	{
		int r,c;
		scanf("%d%d",&r,&c);
		map[r][c]=1;
		attack[r][c]=1;
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			if (map[i][j]==1)
			{
				for (int k=1;k<=4;k++)
				{
					dfs(i,j,k);
				}
			}
		}
	}
	int cnt=0;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			if (attack[i][j]==1)
			{
				cnt++;
			}
		}
	}
	printf("%d",cnt);
	return 0;
}

```

结果如何？

30分，AC#1#2#3，其余RE

很明显，题目中说$n\le10^9$,在将数据存储到$map$数组的过程中一定会RE，所以考虑另一种解法。

~~说句闲话：暴搜不RE，数据太垃圾~~

------------

## solution 2 100pts

**注意：**

- 由于Excel表格中的一格的行列差距太大，所以在此解法中，图片行列不一，请不要介意，以作者在旁表标的数和注释为准。

- 为了~~偷懒~~方便理解，这种解法中所有的“可被攻击到”都被作者改成了“可覆盖”，请读者留意

### Part 1

首先，我们考虑任意两枚棋子都不在同一行，同一列的情况下。

你有一个棋盘

因为无聊，你在上面添加了一个小小的车。

![](https://cdn.luogu.com.cn/upload/image_hosting/pexubk09.png)

如图，灰色的是棋盘，深蓝是可覆盖的行，浅蓝是可覆盖的列。

注：多余的两条蓝色框是为了加强读者理解为什么覆盖的范围总是$2n-1$，如不理解可以跳过。

**此时，不管这枚小小的车怎么移动，他所能攻击到的范围都是$2n-1$(好好思考一下这句话)。~~之前好像剧透了~~**

为了使我们的思路保持有规律，我们把它放到第一行第一列

![](https://cdn.luogu.com.cn/upload/image_hosting/pb4bsvq7.png)

由于你现在仍然很无聊，所以你想要再加入一枚车。

**同样地，不管这两枚棋子放在什么位置(但要满足不在同一行，同一列)，他们总会有重合，并且重合部分面积总是为2(自行理解，建议自己画几张图试试)。**

你发现，它可以放在任何不在第一行，也不再第一列的任何位置(因为第一行/列已经被第一个车占用)。

为了保持规律，我们把它放在第二行第二列。

![](https://cdn.luogu.com.cn/upload/image_hosting/stix3huv.png)

现在你发现了什么？

~~这两个车穿的是情侣装！~~

当棋盘上有$2$枚不同行不同列的车时，可覆盖的区域为$n^2-(n-2)^2$。

**同样地，当棋盘上有$x$枚不同行不同列的车时，未覆盖的区域为$n^2-(n-x)^2$。**

### Part 2

接下来，我们就要考虑有重复行/列。的问题了。

一个格子能放下两枚车吗？当然不行。

所以，**任意两枚棋子只有可能行相同或列相同，绝不可能行列都相同。**

由于行和列在本题中本质上是没有区别的，所以我们现在以列举栗子。

![](https://cdn.luogu.com.cn/upload/image_hosting/a3ae0iqr.png)

如图，**由于第三个车与第二个车在同一列，所以那重复的一列只计算了一次**

我们发现，重复的行/列坐标是不计算的。

所以，我们可以在$r$数组和$c$数组中去掉重复的，只保留独一无二的，然后计算有多少个独一无二的，我们假设：

**$x$行，$y$列是独一无二的时候，则可覆盖的面积为：$n^2-(n-x)×(n-y)$**

搞了半天，这就是个去重的题啊~

只要输入之后算一下$r$里有几个重的，$c$里有几个重的，都去掉，最后计数器统计一下然后套公式输出就得了呗~

注意：cnt在这里的最大值是整个棋盘都可覆盖，为$10^{18}$，所以**不开longlong见祖宗**

### Part 3

**Code:**

这篇代码说是去重并不准确，应该说是“计不重”，直接sort排序后记录有数组中多少个不同的元素

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int K=1000010;

long long r[K],c[K];

int main()
{
	long long n,k;
	scanf("%lld%lld",&n,&k);
	for (int i=1;i<=k;i++)
	{
		scanf("%lld%lld",&r[i],&c[i]);
	}
	//排序是为了后面计重 
	sort(r+1,r+k+1);
	sort(c+1,c+k+1);
	long long cntr=0,cntc=0;
	for (int i=1;i<=k;i++)
	{
		if (r[i]!=r[i+1]) 
		{
			cntr++;//r里面有多少个独一无二的 
		}
		if (c[i]!=c[i+1])
		{
			cntc++;//同上 
		}
	}
	printf("%lld",n*n-(n-cntr)*(n-cntc));
	return 0;
}

```

	毕竟我是蒟蒻，如果有问题请dalao一定指出！

---

## 作者：vectorwyx (赞：15)

## 移行列，得矩形；求面积，算剩余




首先，肯定不可能模拟棋盘，因为数据范围太大了；

那么，就在行列上做文章。

题目要求我们求出被攻击的格子数，那我们先算出**不被攻击的格子数**，最后把棋盘的格子数减去它不就行了？


------------
如何算出不被攻击的格子数呢？

我们把每个棋子所在的行和列平移一下，会得到一个矩形。

**矩形所占的面积就是不被攻击的格子数**。

那我们只需要求出长和宽，其实就是求不被攻击的行数和列数。

------------

每个棋子都会攻击所在的行和列，$K$个棋子所攻击的行数和列数其实就等于$K-a$和$K-b$。

其中$a$为被重复攻击的行数，$b$为被重复攻击的列数。

**那我们的问题就变成了求a和b，也就是去重**


------------

一维数组的去重很简单，各种五花八门的方法都可以用，不再赘述。这道题我们用$sort$实现


------------

### 代码如下：
```
#include<cstdio>
#include<iostream> 
#include<algorithm>//调用algorithm库，以使用STL自带的sort函数
using namespace std;
const int maxn=1000001;//定义数组的规模
int cnt1[maxn],cnt2[maxn];//存储行、列
int main(){
	long long n,k,sum1=1,sum2=1,ans;
//sum1和sum2为被攻击的行数与列数，注意要初始化为1
	cin>>n>>k;
	for(int i=1;i<=k;++i){
		scanf("%lld%lld",&cnt1[i],&cnt2[i]);
//scanf能够加快读入速度
	}
	sort(cnt1+1,cnt1+1+k);//快速排序
	sort(cnt2+1,cnt2+1+k);
	for(int i=2;i<=k;++i){
		if(cnt1[i]!=cnt1[i-1]) sum1++;
		if(cnt2[i]!=cnt2[i-1]) sum2++;
	}
	ans=(n-sum1)*(n-sum2);//计算未被攻击的格子数
	cout<<n*n-ans;//输出被攻击的格子数
	return 0;
} 
```


---

## 作者：itandsoon (赞：4)

虽然题目描述很简单，但是依然让我没有想到更好的数学方法。在提交了三次之后我依旧被卡了两个TLE。

 接下来我要介绍一种时间**复杂度较高的暴力做法**，枚举每一个车的占位情况，通过记录占位来计算答案。这篇题解的目的是想展示**undered_map**的特性。
 
 undered_map的用法上和map映射没有本质的区别，但是如同它的名字一样，它的**内部储存数据是无序的，通过哈希表进行数据存储和查找**。这样的内部结构是undered_map的查找速度明显快于map,在查找数据比较大的时候，使用undered_map在性能上会快很多。
 
 具体的做法就是记录每次读入坐标时有多少行列已经被占据了，然后用undered_map记录具体某一行是否被占据。
 
 以下结合代码解释：
 
 ```c
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<tr1/unordered_map>//在C++11前的版本里代码头文件要加tr1
using  namespace std;
inline int read() {//快速读入，防止TLE
    char ch = getchar(); int x = 0, f = 1;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') f = -1;
        ch = getchar();
    } 
    while('0' <= ch && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    } return x * f;
}
long long ans=0;
tr1::unordered_map<int,int>line;//定义方式和map几乎一样，用来记录该行列是否被占据
tr1::unordered_map<int,int>row;
int l=0,r=0;//记录行列被占据的数量
int main()
{
    int n=read(),k=read();
    for(int i=0;i<k;i++)
    {
        int x=read(),y=read();
        int a=line[x],b=row[y];//提前记录，以免多次调用undered_map增加耗时
        if(a&&b)continue;
        if(!a)//计算除车的位置外可占据的同列格数
        {
            int q=n-r;
            if(!b)q--;
            ans=ans+q;
        }
        if(!b)//计算除车的位置外可占据的同列格数
        {
            int p=n-l;
            if(!a)p--;
            ans=ans+p;
        }
        if(!a&&!b)ans++;//判断车的位置是否被占据
        if(!a){l++;line[x]=1;}
        if(!b){r++;row[y]=1;}//更新车的位置带来的占位改变
    }
    cout<<ans;
}
```

不过话说回来，即使使用undered_map，对于这个题的数据量而言也必须借助快读和O2吸氧才能通过最后两个点，所以这篇题解略显鸡肋，权当记录了。

---

## 作者：皮卡丘最萌 (赞：4)

这题好像还没有Pascal题解，蒟蒻赶紧来水一发。

先看样例：

3 2

1 2

2 2

第一个坐标1,2表示第一行被全部覆盖，第二列被全部覆盖。

第二个坐标2,2表示第二行被全部覆盖，第二列被全部覆盖。

我们发现只要把相同行或相同列的数全部看成只有一个，这个问题就变简单了。

假设有一个大力士，把所有的行和列都移到了左上角

看图：![404](https://cdn.luogu.com.cn/upload/pic/70442.png)

我们设不一样的行有x个，不一样的列有y个，棋盘边长为n。

这样被攻击到的格子个数就是n×n-(n-x)×(n-y)，在样例里表示就是3×3-(3-2)×(3-1)=7

这样我们就只需要先对行和列分别进行快排，再统计不一样的行和不一样的列，即可得出答案。

上代码：

```pascal
var n,i,k,x,y:longint; 
a,b:array[0..1000001] of longint;  //貌似不用int64也能过
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;                        //对行快排
procedure sort1(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=b[(l+r) div 2];
         repeat
           while b[i]<x do
            inc(i);
           while x<b[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort1(l,j);
         if i<r then
           sort1(i,r);
      end;                    //对列快排

begin
readln(n,k);
for i:=1 to k do readln(a[i],b[i]);      //读入
sort(1,k); sort1(1,k);            //分别快排
for i:=1 to k do
  if a[i]<>a[i-1] then inc(x);          //统计不一样的行的个数
for i:=1 to k do
  if b[i]<>b[i-1] then inc(y);          //统计不一样的列的个数
writeln(n*n-(n-x)*(n-y));              //运用公式求解
end.
```


---

## 作者：zjp_shadow (赞：4)

- 这个题让我不禁想起了小学数学书上的一个问题。花园上有很多条林荫道，求剩下的草地的面积。

- 这个放车就十分类似了，我们只要将每辆车扩充为两条小道，一条横的，一条竖的。

- 因为有些格子会重复计算，所以我们需要去掉重复的小道。

- 具体如图:![pic](http://images.cnblogs.com/cnblogs\_com/zjp-shadow/1056673/o\_P3913.bmp)（图有点丑……）

- 图中第二列重复了，所以我们只算一条。行中算两行，所以剩下的面积（蓝色区域）面积就是$(3-2)*(3-1)=2$，所以被车攻击的面积就是$3*3-2=7$。

- 所以我们计算的公式就是$n*n-(n-r)*(n-c)$（可以展开消元，但没必要）

- 对于去重，我们不能用$set$或者$map$（太慢了），可以用$sort$后，再判。（一开始只用了$unique$以为会自动排序，WA几次TAT）


代码：

```cpp
#include <bits/stdc++.h>
#define For(i, l, r) for(ll i = (l), _end_ = (ll)(r); i <= _end_; ++i)
#define Fordown(i, r, l) for(ll i = (r), _end_ = (ll)(l); i >= _end_; --i)
#define Set(a, v) memset(a, v, sizeof(a))
using namespace std;
typedef long long ll;

bool chkmin(ll &a, ll b) {return b < a ? a = b, 1 : 0;}
bool chkmax(ll &a, ll b) {return b > a ? a = b, 1 : 0;}

inline ll read() {
    ll x = 0, fh = 1; char ch = getchar();
    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;
    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');
    return x * fh;
}

ll n, ans;
ll k;
const int N = 1e6 + 1e3;
ll r[N], c[N];
void input() {
    n = read(); k = read();
    For (i, 1, k) {
        r[i] = read(); c[i] = read();
    }
}

void solve() {
    sort (r + 1, r + 1 + k);
    sort (c + 1, c + 1 + k);
    ll n1 = unique(r + 1, r + 1 + k) - r - 1,
       n2 = unique(c + 1, c + 1 + k) - c - 1;
    ans = n * n - (n - (ll)(n1) ) * (n - (ll)(n2) );
}

void output() {
    printf ("%lld\n", ans);
}

int main () {
    input();
    solve();
    output();
    return 0;
}
```

---

## 作者：一座城·守一人 (赞：3)

大家好，很高兴又可以为一道~~很有思维难度的~~题写题解。

**对于看过我题解的人来说，你们应该知道我的风格：**

# $\Huge\mathcal{STL}$ 走天下

## 首先我们对这道题目进行分析：

#### 看到这道题的题目描述，很多人(包括我)第一反应：大水题。有时间的就继续往下看，没时间的加进了任务计划。

#### 再一看数据范围
#### 果断的从任务计划中删除(或者关掉了这个网页)。

其实这一切没你想象的那么难。

如果你要求出来有多少个点会被至少一辆车攻击，你只要数一下有多少排会被车攻击，乘上每一排有多少个点。再数一下有多少列会被车攻击，乘上每一列有多少个点。然后再减去重复计算的点，就是答案了。

说起来容易做起来难，有很多人选择了暴力枚举，看这一行有没有车，有的话横行$++$，但实际上，如果你是$c++$选手，你可以毫不犹豫的调用`unique`函数。

unique函数具体用法见我的另一~~片~~篇题解[P1317 低洼地](https://www.luogu.org/blog/youknowxiaohongis666/solution-p1317)
(不过话说回来，好像篇和片在这里都可以诶)。

上代码了(杜绝抄袭)：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long k,n,sl;
int r[1000010],c[1000010];
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=0;i<k;i++){
		cin>>r[i]>>c[i];//输入每辆车所在的每一行，每一列
	}
	sort(r,r+k);//排序，unique前必做的
	sort(c,c+k);
	long long rc=unique(r,r+k)-r;//一定要开long long 不然白丢60分
	long long cc=unique(c,c+k)-c;
	sl=rc*n+cc*n-rc*cc;//小学……连奥术都算不上的常识
	cout<<sl;
	return 0;
}
```
## [听说洛谷里,STL和$O_2$更配哦](https://www.luogu.org/recordnew/show/11891614)$\mathcal{\Huge{?^?_??}}$

---

## 作者：stansxt (赞：3)

# 前言

- 蒟蒻第一次交这题果断 $TLE$，当场懵了：橙题卡常？！复杂度明明 $O(n \log_2{n} )$的。~~说明窝还是太菜了QwQ~~。然后就不信邪的把$lower\_bound$换换成手写二分，果然就过了。~~事实证明STL一点都不好使~~ 然后进来扫一圈题解，顿时欲哭无泪：大佬的做法我怎么永远想不到啊/dk。于是乎，就发一篇题解记录一下蒟蒻古怪的想法吧。可能跑得比较慢，但不开$O_2$也是能过的，最慢的点大概950$ms$。

# 大体思路
- 首先我们考虑$N\leqslant10^6$的情况。我们考虑每加入一个车后对答案产生的贡献：

	- 一个车会影响到一行、一列，那我们先考虑行：
    - 若这一行已经被占用过了，那么此车不会再在水平方向做出贡献，跳过。这里就随便开个数组记录下即可。后面代码里的 $qa$ []、$qb$ [] 即是。
    - 一行本来会有$N$个格子，对于之前的每一个已经被计算过的列，都会与该行有一个交点。因此还需要记录一下当前有几个 ***不同的列被计算过***，我用的是$nowl$、$nowr$。然后该车在水平方向上的贡献即为$N$\-$nowr$。
    - 竖直方向同理即可。
    - 最后注意一下，该点本身并未被覆盖时$ans$还需要$\ +\ +$。
- 然而本题最终数据是$N\leqslant10^9$，显然数组开不到$10^9$的，那怎么办呢？
- 注意看到题中的$K\leqslant10^6$，那么很容易想到，需要想办法把数组开到$K$的大小。
- 考虑把一个车挪动的结果。假设仅挪动这一个车，有了上面的结论，很容易发现只要保证它所在行的是否被攻击的情况不变（就是说如果它本来的位置所在行已经有车，那么它的目标位置所在行也得有车。反之原先行上没有，目标位置所在行也不能有），它对答案的贡献就不变。列同理。
- 有了这个结论，我们便可以开始挪车了。这个时候很容易想到离散化，只需要找到每个行的排名，把这个行里所有的车移动到它的排名那一行去，这样答案不变。
- 离散化之后所有的行都在$1$~$10^6$中，这样就可以开数组了，相当于$N\leqslant10^6$的情况。
- 一定注意不要轻易用$lower\_bound$，当然用了开$O_2$也是能过的，但是个人建议手写一个二分查找，反正又不麻烦。我代码里的二分写的很丑，但是保证正确。大家也可以用自己熟悉的写法。注意最好要返回该值第一次出现的位置。
- 还有就是，程序跑得再慢，$ans$还是要开$long\ long$的，这个别忘了。

# 代码


```
//P3913 车的攻击        
//submit 3             
//By sxt on 2020.4.6         
#include<bits/stdc++.h>             

#define rg register int                 
#define il inline             
#define in read()                       
#define _num(x) (x >= '0' && x <= '9')   
#define ql(x) memset(x, 0, sizeof(x))   
#define mid ((l + r) >> 1)   
#define el else if     

using namespace std;   

typedef long long ll;   

const int N = 1e6+3;   

il int read(){      
	int x=0,f=1;          
	char ch=getchar();    
	while(!_num(ch)){     
		if(ch=='-')     
			f=-1;      
		ch=getchar();     
	}                
	while(_num(ch)){     
		x=x*10+ch-'0';     
		ch=getchar();     
	}           
	return x*f;               
}                         

char f[20];               
int cnt;                   

il void pint(ll x){              
	if(x == 0){ putchar('0'), putchar('\n'); return ;}            
    cnt = 0;          
    while(x > 0){                   
        f[cnt++] = x % 10 + '0';         
        x /= 10;     
    }     
    while(cnt > 0) putchar(f[--cnt]);   
    putchar('\n');   
    return ;   
}   

int n, m, x, y, a[N], b[N], nowl, nowr, pa[N], pb[N], qa[N], qb[N], k;   
ll ans;     

il int check(int se[], int xx){   
	rg l = 1, r = m;    
	while(l < r - 1){     
		if(xx < se[mid]) r = mid - 1;  
		el(xx > se[mid]) l = mid + 1;  
		else r = mid;    
	}    
	if(se[l] == xx) return l;    
	return r;    
}     

signed main()    
{      
	//freopen("1.txt", "r", stdin);    
	n = in, k = m = in;     
	while(k--){     
		pa[m - k] = a[m - k] = in, pb[m - k] = b[m - k] = in;    
	}     
    	//离散化    
	sort(pa + 1, pa + m + 1);     
	sort(pb + 1, pb + m + 1);     
	for(rg i = 1; i <= m; ++ i){    
		a[i] = check(pa, a[i]);   
		b[i] = check(pb, b[i]);   
	}                   
    	//离散完成             
        //下面依次加入每一个车        
	for(rg i = 1; i <= m; ++ i){        
		x = a[i], y = b[i];      
		nowl += 1 - qa[x];        
		nowr += 1 - qb[y];      
        	//这里注意一下顺序，本行的上下最好不要颠倒，颠倒的话最底下那个if需要做些调整。不懂可以手完一下。         
		if(!qa[x]){     
			ans += n - nowr;     
		}          
		if(!qb[y]){        
			ans += n - nowl;    
		}     
		if(!qb[y] && !qa[x]) ++ ans;   
		qb[y] = 1, qa[x] = 1;    
	}          
	pint(ans);    
	return 0;    
}        
```

---
- 最后附个[评测记录](https://www.luogu.com.cn/record/32539382)叭，不开$O_2$稍显勉强QwQ

---
$THE\ ·\ END.$

---

## 作者：wangxuye (赞：3)

~~来一发简单的数学题解~~

由于车的攻击范围为横、竖的直线，所以横的直线相互之间不会交叉（同理竖的也一样），所以我们可以先求出有多少条横着的直线，记为cnt,再求出有多少条竖着的直线，记为count,结果sum=cnt*n+count(n-cnt)


来看个例子（样例，0为空格，1为车）：
 
0  1  0 

0  1  0 

0  0  0

前两行均为车的攻击范围，cnt=2，第二列为车的攻击范围，count=1，此时

	sum=cnt*n+count(n-cnt)=2*3+1(3-2)=7

这个式子为什么是正确的呢，接下来来证明一下：

先不考虑竖的直线，如果有cnt条横着的直线，就一定会有cnt*n个格子被攻击，

再考虑竖着的直线，如果有count条竖着的直线，也会有count*n个格子被攻击
但是
---

每条横着的直线一定与每条竖着的直线有且仅有一个交叉点，所以要减掉cnt*count个格子

	所以sum=cnt*n+count*n-cnt*count=cnt*n+count(n-cnt)
    
最后记得要开

# long long,long long,long long


上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int size=1e6;

int line[size+10],row[size+10];

int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++) scanf("%d%d",&line[i],&row[i]);
	sort(line+1,line+k+1);                        //排序
	sort(row+1,row+k+1);                          //排序
	ll sum=0;
	ll cnt=0;
	for(int i=1;i<=k;i++) if(line[i]!=line[i-1]) cnt++; //去重
	sum+=cnt*n;
	ll count=0;
	for(int i=1;i<=k;i++) if(row[i]!=row[i-1]) count++; //去重
	sum+=count*(n-cnt);
	printf("%lld\n",sum);                       //记得%lld
	return 0;
}
```

---

## 作者：TESJackeyLove (赞：2)

- 题目简单易懂，车可以攻击一行和一列，一行有N个格子，一列也有N个格子，那么我们第一步需要求出一共有多少行多少列就可以了。每个车有一个横坐标和一个纵坐标，所以我们统计一下有多少个不同的横坐标和不同的纵坐标。横纵坐标都是一样的统计方式，所以这里可以写成函数的形式方便我们去调用。（有大佬用了unique，蒟蒻一开始并不知道还有这种操作。）统计函数的实现如下，思路就是先排序，定义一个变量sum进行统计，遍历，看arr[i]和arr[i-1]是不是一样的，如果不是一样的就sum++，否则continue。代码如下：  
```cpp
  ll countn(int arr[],int m){//把long long宏定义为ll了 
      //统计arr数组里面不重复元素的个数
      //下标从0~m 
      ll sum=1;//因为一会相乘可能会溢出，开成long long 
      fore(i,1,m){//for循环宏定义成fore，比较懒 
          if(arr[i]==arr[i-1]){
              continue;
          }
          else{
              sum++;
          }
      }
      return sum;
  }
```
- 这个函数有了以后，思路就很明确了，定义两个数组R和C，分别用来存横纵坐标，然后分别sort一下，调用countn函数统计数组不同元素的个数，用另外两个变量Rn和Cn存起来。（Tips：一年OI一场空，不开long long见祖宗。为什么要开long long，有人可能会int一个a和b，然后把a乘b的结果再存到一个long long变量里面去，这样写一样会溢出，我理解的是int与int相乘结果依然是int类型的，已经溢出变成错误数字了，再存到long long里面依然是那个错误的数字，所以Rn和Cn要开long long），存完之后，有Rn行和Cn列会被攻击到，那么结果就是(Rn+Cn)$\times$ N个格子会被攻击到，是没错，但是会有重复计算的格子。看下面这幅图，红线部分就是被攻击到格子，红线的交点就是被攻击一次以上的格子，也就是被我们重复计算的格子，那么我们只需要减去重复计算的格子就可以了，怎么算呢？Rn条竖线和Cn条横线多少个交点？一条横线会把所有竖线都交了，产生Rn个交点。Cn条呢？当然是Rn$\times$Cn个了。所以我们把这部分减去就好啦~  
![](https://cdn.luogu.com.cn/upload/image_hosting/ytxuzkqc.png)  
- 那么最后的答案就是(Rn+Cn)$\times$ n - Rn$\times$Cn了。以下是丑陋的代码：  
```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<algorithm>
  #include<cstring>
  #include<cstdlib>
  #include<queue>
  #include<stack>
  #define fore(i,a,b) for(int i=a;i<=b;i++)
  #define foru(i,a,b) for(int i=a;i<b;i++)
  #define ford(i,a,b) for(int i=a;i>=b;i--)
  #define IGNB std::ios::sync_with_stdio(false);
  #define ll long long
  #define INF 0x3fffffff
  using namespace std;
  int r[1000005],c[1000005];
  ll rn,cn,n;
  int k;
  ll countn(int arr[],int m){//把long long宏定义为ll了 
      //统计arr数组里面不重复元素的个数
      //下标从0~m 
      ll sum=1;//因为一会相乘可能会溢出，开成long long 
      fore(i,1,m){//for循环宏定义成fore，比较懒 
          if(arr[i]==arr[i-1]){
              continue;
          }
          else{
              sum++;
          }
      }
      return sum;
  }
  int main(){
      IGNB;
      cin>>n>>k;
      foru(i,0,k){
          cin>>r[i]>>c[i];
      }
      sort(r,r+k);
      sort(c,c+k);
      rn=countn(r,k-1);
      cn=countn(c,k-1);
      ll ans=(rn+cn)*n-rn*cn;
      cout<<ans;
      return 0;
  }

```


---

## 作者：Na2PtCl6 (赞：1)

## 结论
这题的解法基于以下结论：

**放下一个车后，它会覆盖一行一列。**

**如果车所在列没被占领，就把结果加上没被占领的行的数量**

**如果车所在行没被占领，就把结果加上没被占领的列的数量**

依照以上结论，我们就能得出放下一个车，结果会怎么变化。

## 注意事项

- 结果至少开long long
- 需要一些常数优化（比如手写快读，手写平衡树）

## 代码

这道题如果用这个方法，想不开O2就过，要手写平衡树或哈希表，我用map意思一下就好了。

```cpp
#include<map>
#include<cstdio>
using namespace std;
typedef unsigned long long ull;
int N,K,R,C;
ull res;
map < int , bool > h,l;

inline int read(){
	char c=getchar();int ret=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		ret=(ret<<1)+(ret<<3)+(c^48);
	return ret;
}

inline void print(ull x){
    if(x < 0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}

int main(){
	N=read(),K=read();
	ull hleft=N,lleft=N;//没被占用的行，列 
	while(K--){
		R=read(),C=read();
		if(!h[R]){
			res+=lleft;//见结论 
			if(hleft>0)
				--hleft;//没被占用的行又少了一个 
			h[R]=1;//标记用过的 
		}
		if(!l[C]){//和上面同理 
			res+=hleft;
			if(lleft>0)
				--lleft;
			l[C]=1;
		}
	}
	print(res);
	return 0;
} 

```
如何~~卡常~~优化？
因为我们一直在判断一行或是一列有没有在之前重复出现，而排序能使一样的数排在一起，所以用排序来解决。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef unsigned long long ull;
int N,K,R[1000004],C[1000004];
ull res;

inline int read(){
	char c=getchar();int ret=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		ret=(ret<<1)+(ret<<3)+(c^48);
	return ret;
}

inline void print(ull x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}

int main(){
	N=read(),K=read();
	ull hleft=N,lleft=N;
	for(int i=0;i<K;i++)
		R[i]=read(),C[i]=read();
	sort(R,R+K);
	sort(C,C+K);
	for(int i=0;i<K;i++){
		if(R[i]!=R[i-1]){
			res+=lleft; 
			if(hleft>0)
				--hleft; 
		}
		if(C[i]!=C[i-1]){
			res+=hleft;
			if(lleft>0)
				--lleft;
		}
	}
	print(res);
	return 0;
} 
```
这样不用开O2也能过啦！



---


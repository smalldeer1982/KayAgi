# 攀爬者

## 题目背景

HKE 考完 GDOI 之后跟他的神犇小伙伴们一起去爬山。


## 题目描述

他在地形图上标记了 $N$ 个点，每个点 $P_i$ 都有一个坐标 $(x_i,y_i,z_i)$。所有点对中，高度值 $z$ 不会相等。HKE 准备从最低的点爬到最高的点，他的攀爬满足以下条件：

 (1) 经过他标记的每一个点；

 (2) 从第二个点开始，他经过的每一个点高度 $z$ 都比上一个点高；

 (3) HKE 会飞，他从一个点 $P_i$ 爬到 $P_j$ 的距离为两个点的欧几里得距离。即，$\sqrt{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}$

现在，HKE 希望你能求出他攀爬的总距离。


## 说明/提示

对于100%的数据，$1\leq N\leq 50000$，答案的范围在 double 范围内。


## 样例 #1

### 输入

```
5
2 2 2
1 1 1
4 4 4
3 3 3
5 5 5
```

### 输出

```
6.928```

# 题解

## 作者：我终于改名惹 (赞：70)

	=w=冷门题，人群当中冒出一个游六：我来！
	23333没错又是我
    这题其实就是普通的排序+数学计算题，结构体快排操作一下就好。
    仔细审题，必须从低到高爬，那么我们最简单的方法就是计算每两个
   **高度相邻**
 	
    坐标之间的直线距离，然后把算出来的所有距离相加即可。
    那么首先我们需要用sort排序一下，具体使用方法请见
   [百度！](www.baidu.com)
   	
    接着就可以for计算了。
    
	```cpp
	#include<bits/stdc++.h>
	using namespace std;
	const int N = 100000;
	int read(){
      char ch = getchar();
      int x = 0, f = 1;
      while(ch < '0' || ch > '9'){
          if(ch == '-') f = -1;
          ch = getchar();
      }
      while('0' <= ch && ch <= '9'){
          x = x * 10 + ch - '0';
          ch = getchar();
      }
      return x * f;
  	}
	struct shan{
   	int x,y,z;
   	bool operator<(const shan &other)const{
		return z<other.z;//我偷到了啊啊啊！！！
		}
	}s[N];
	int main(){
    	int n = read();
    	double ans = 0;
    	for(int i = 0; i < n; ++i)
        	s[i].x = read(), s[i].y = read(), s[i].z = read();
    	sort( s, s + n);
    	for(int i = 1, j = 0; i < n; ++j, ++i)
        	ans += sqrt(pow(s[i].x - s[j].x,2) + pow(s[i].y - s[j].y,2) + pow(s[i].z-s[j].z,2));
    	printf("%0.3lf",ans);
    	return 0;
	} 
```

    
    反正就很好聊，坐等大牛牛牛的优化。

---

## 作者：zhanghzqwq (赞：36)

### ~~这是黄题？~~

这题就是结构体排序，让每个点高度从小到大排序。看大佬们都用的cmp，我就介绍一下重载运算符。

重载运算符相对于比较函数来说虽然难写，但不过速度确实快了很多，在比较函数排序中，每一次比较都要拷两个结构体过去，这样的速度是非常慢的。但如果是重载运算符，那么比较规则就本身就在结构体里面了，排序的时间会很快。

这是重载小于运算符的模板：
```
bool operator<(const Node &other)const{
		return a<other.a;//a是要比较的元素
}
```
这样排序时间就会非常快了。

最后，保留三位小数的代码是：
```
printf("%.3lf\n",ans);
```
AC代码：
```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
struct Node{
	double x,y,z;
	bool operator<(const Node &other)const{//重载小于运算符
		return z<other.z;
	}
} a[50050];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%lf%lf%lf",&a[i].x,&a[i].y,&a[i].z);
	}
	sort(a,a+n);//每个点高度从小到大排序
	double ans=0;
	double cx=a[0].x,cy=a[0].y,cz=a[0].z;
	for(int i=1;i<n;i++){
		ans+=sqrt(abs(cx-a[i].x)*abs(cx-a[i].x)+abs(cy-a[i].y)*abs(cy-a[i].y)+abs(cz-a[i].z)*abs(cz-a[i].z));//两点的欧几里得距离
		cx=a[i].x;
		cy=a[i].y;
		cz=a[i].z;
	}
	printf("%.3lf\n",ans);//输出保留三位小数
	return 0;//华丽的结束
} 
```


---

## 作者：Viccc (赞：15)

 思路很简单，给所有点排个序，然后一个循环计算一下就过去了。

其中的欧几里得距离公式设计了平方和开方，用的函数分别是pow（）和sqrt（），~~来刷黄题的同学应该都知道这个吧~~。

### 科普一下最后的保留小数！！！（貌似题解还没有人这么写）
大家都知道C语言的I/O有保留小数功能，其实cout也是有的。
在C++中这么写：
```cpp
cout<<setiosflags(ios::fixed)<<setprecision(3)<<a;
```
假定a是我们要输出的数字，这句话的意思就是“保留3位小数”，如果要保留两位小数，把setprecision(3)的3改成2即可，以此类推。

如果删去setiosflags(ios::fixed)，那么句意就变成了“保留有效数字x位”，x还是是setprecision(3)括号里的数。要注意的是这个功能不在iostream里面，需要头文件
```cpp
#include <iomanip>
```




不说了，上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;

struct point
{
	int x,y,z;
}a[50010];

bool cmp(point a,point b)
{
	return a.z<=b.z;
}
int main()
{
	unsigned int n;
	cin>>n;
	double s=0;
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].y>>a[i].z;
	sort(a+1,a+n+1,cmp);
	for(int j=1;j<=n-1;j++)
		s+=sqrt(pow(a[j].x-a[j+1].x,2)+pow(a[j].y-a[j+1].y,2)+pow(a[j].z-a[j+1].z,2));
	cout<<setiosflags(ios::fixed)<<setprecision(3)<<s;
	return 0
```
;
} 

---

## 作者：philosopherchang (赞：9)

题意说的很清楚了，只能往高处走，所以sort把z排序一遍就行了，值得注意一下的是（对于我这个代码来说），加到第n-1个山峰时就不能往上再加了，因为n+1个山峰的高度是0.

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
using namespace std;
struct node{
	int x,y,z;
}mountain[50001];
double ans;
int n;
int cmp(node x,node y)
{
	return x.z<y.z;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>mountain[i].x>>mountain[i].y>>mountain[i].z;
	}
	sort(mountain+1,mountain+n+1,cmp);
	for(int i=1;i<=n-1;i++)
	{
		ans+=sqrt(((mountain[i].x-mountain[i+1].x)*(mountain[i].x-mountain[i+1].x))+((mountain[i].y-mountain[i+1].y)*(mountain[i].y-mountain[i+1].y))+((mountain[i].z-mountain[i+1].z)*(mountain[i].z-mountain[i+1].z)));
	}
	printf("%.3f",ans);
}
```

---

## 作者：_zby_ (赞：7)

```cpp
   代码，最重要的是简洁易懂，而不是花里胡哨      
   
```
~~（略讲一下结构体应该算不上花里胡哨）~~

思路：1、用****结构体****存储所有点的方位，

2、sort按z从小到大排一遍序
    
3、ans统计距离

~~啥，你没学过结构体~~ 

[点击这里](https://www.runoob.com/cprogramming/c-structures.html)

#### 就像这样

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
inline void read(int& x)
{
    x=0;int k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=k;
}//快读
struct point{
	int x,y,z; //坐标
}a[100001];
int main(){
	int n;
        register int i;
        register double ans=0.0;//register加快速度
	read(n);
	for(i=1;i<=n;i++)
	read(a[i].x),read(a[i].y),read(a[i].z);//读入
	sort(a+1,a+n+1);
	for(int i=2;i<=n;i++)
	ans+=sqrt((a[i].x-a[i-1].x)*(a[i].x-a[i-1].x)+
	(a[i].y-a[i-1].y)*(a[i].y-a[i-1].y)+
	(a[i].z-a[i-1].z)*(a[i].z-a[i-1].z));//公式
	printf("%.3lf",ans);
	return 0;
}
```
#### ~~然后你就CE了~~ （Why？）
注意，struct定义的是 ****你自己的point类型 ，sort没有内置的排序规则。****

~~（其实严格的说是有的，只是在point类型中没有可用的'<'运算符）~~

这种处理方法一般有两种

### 1、写一个排序规则****函数****（常用）
就像这样
```cpp
bool cmp(point a,point b){
	return a.z<b.z;//按z从小到大排序（返回1为不交换，0为交换）
}
sort(a+1,a+n+1,cmp);
```

### 2、在结构体内重载'<'运算符
就像这样
```cpp
struct point{
	int x,y,z;
	bool operator  < (const student &other)const{
		return z<other.z;
	}
}a[100001];//sort不变
```
~~AC代码请自行从以上提取~~




---

## 作者：ViXpop (赞：5)

蒟蒻又来发题解了呢qwq

这题难度是黄题，但是绝对是相当水的一道黄题（~~虽然黄题都差不多水~~）

### 正解：结构体+排序+欧几里得距离

别看正解要的东西很多，其实还是很好想的

我们来简单分析一下题目

#### 看完题目的要求，可以发现第二个和第三个要求是解题的核心（当然各位dalao一眼就可以看出来）

第二个要求提示了我们需要排序

但是每一个点的坐标是绑定在一起的，单独排序定会打乱其顺序，这是我们就需要结构体排序

```
struct node {
    int x,y,z;
}q[N];
bool cmp(node a,node b){
    return a.z<b.z;
}
```
排序完后就相当简单了，直接欧几里得距离往上套就行

#### 下面是代码（带有部分注释）

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=5e4+5;
struct node {
    int x,y,z;
}q[N];//结构体
double suan(int x1,int x2,int y1,int y2,int z1,int z2){
    return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2));
}//欧几里得距离公式
bool cmp(node a,node b){
    return a.z<b.z;
}
int n;
double ans;
int main(){
    n=read();
    for(register int i=1;i<=n;i++)
    	q[i].x=read(),q[i].y=read(),q[i].z=read();
    sort(q+1,q+n+1,cmp);//结构体排序
    for(register int i=2;i<=n;i++)
    	ans+=suan(q[i-1].x,q[i].x,q[i-1].y,q[i].y,q[i-1].z,q[i].z);
    printf("%.3lf\n",ans);//保留三位小数
    return 0;
} 
```

---

## 作者：lotus_grow (赞：4)



------------

### 题意

给出 $n$ 个三维的点坐标 $(x_i,y_i,z_i)$ ，其中 $z_i$ 是高度且互不相同。

要求人从低往高走，求人走完 $n$ 个点一共经过的距离（欧几里得距离）

------------

### 思路

将点按 $z_i$ 从小到大排序，统计答案即可

------------

### 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>

using namespace std;

int n;
double ans;
struct pt
{
    int x,y,z;
    bool operator <(const pt &a) const
    {
        return z<a.z;
    }
    double operator -(const pt &a) const
    {
        return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y)+(z-a.z)*(z-a.z));
    }
}a[50001];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    sort(a+1,a+n+1);
    for(int i=2;i<=n;i++) ans+=a[i]-a[i-1];
    printf("%.3lf",ans);
    return 0;
}
```

---

## 作者：Feliks (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
pair<int,pair<int ,int> > a[50010];
double ans;
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d%d%d",&a[i].second.first,&a[i].second.second,&a[i].first);//用a[i].first保存高度，这样在下面排序时就是按照从低到高排序
	}
	sort(a,a+n);
	for(int i=1;i<n;i++){
		ans+=hypot(hypot(a[i].second.first-a[i-1].second.first,a[i].second.second-a[i-1].second.second),a[i].first-a[i-1].first);
	}//hypot（x,y）即对x，y进行勾股定理
	printf("%.3f",ans);//.3f是输出三位小数的意思
}
```


---

## 作者：LittleSnowy (赞：2)

这道题就是一道排序题

看大家都用的是结构体排序，那我就发个归并吧

排完序就直接算吧
```
#include<iostream>
#include<stdio.h>
#include<math.h>
using namespace std;
int n;
double a[50001],b[50001],c[50001],x[50001],y[50001],z[50001];
double ans=0;
void sort(int l,int r)//归并排序
{
    if(l==r)return;
    int mid=(l+r)/2;
    sort(l,mid);sort(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r)
    {
        if(x[i]<=x[j])
        a[k]=x[i],b[k]=y[i],c[k]=z[i],k++,i++;
        else
        a[k]=x[j],b[k]=y[j],c[k]=z[j],k++,j++;
    }
    while(i<=mid)
    a[k]=x[i],b[k]=y[i],c[k]=z[i],k++,i++;
    while(j<=r)
    a[k]=x[j],b[k]=y[j],c[k]=z[j],k++,j++;
    for(int i=l;i<=r;i++)x[i]=a[i],y[i]=b[i],z[i]=c[i];
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>y[i]>>z[i]>>x[i];
	sort(1,n);
	for(int i=2;i<=n;i++)ans+=sqrt((a[i]-a[i-1])*(a[i]-a[i-1])+(b[i]-b[i-1])*(b[i]-b[i-1])+(c[i]-c[i-1])*(c[i]-c[i-1]));
	printf("%.3lf",ans);
}
```

注意不能只排$z_i$(代码中的$x_i$)


---

## 作者：yu__xuan (赞：2)

**水题个人感觉是入门难度**

### 题目
[P5143 攀爬者](https://www.luogu.org/problem/P5143)

### 解析

*  经过他标记的每一个点

* 从第二个点开始，他经过的每一个点高度zz都比上一个点高；

根据所有点对中，高度值`z`不会相等可以得知，必然是按照高度值由小到大这样攀爬，否则不能满足条件一。很明显

题目中没有说开始点在哪里~~可能我眼瞎~~，按照一开始在高度最低的点开始可以A。

### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cmath>

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

#define MAXN 50001

int n;
double ans;
struct point {
	int x,y,z;
}p[MAXN];//每个点的信息

bool cmp(point a,point b) {
	return a.z<b.z;
}//比较函数也可以写重载运算符。

void calc(int a) {
	ans+=sqrt((p[a].x-p[a-1].x)*(p[a].x-p[a-1].x)+(p[a].y-p[a-1].y)*(p[a].y-p[a-1].y)+(p[a].z-p[a-1].z)*(p[a].z-p[a-1].z));
}//计算距离

int main() {
	read(n);
	for(int i=1;i<=n;++i) {
		read(p[i].x),read(p[i].y);
		read(p[i].z);
	}
	std::sort(p+1,p+n+1,cmp);
	for(int i=2;i<=n;++i) calc(i);
	std::cout<<std::fixed<<std::setprecision(3)<<ans<<'\n';
	return 0;
}
```

---


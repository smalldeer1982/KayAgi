# [SBCOI2020] 小镇

## 题目背景

在人们不知道的地方，有一个小镇。  
一个，连名字都说不上来的小镇。  
季节再度进入冬季，  
那个属于雪的季节。  
在那雪下，埋葬着的，  
是只属于这个小镇的梦，与传说。  
......   
“又到了冬天啊！”  
“是啊！周围都变成白茫茫的一片了呢...”  
“唉，要是这样的日子能够永远持续下去该有多好啊。”  
“啊，永远...”  
“不过，世间又有什么是永远呢。如同雪的消融，洁白地融入大地，还来不及让人品味，如此无奈，又如此纯净......”   

在雪中，一幢幢房屋间的灯光散发出温暖的光芒。  
![](https://cdn.luogu.com.cn/upload/image_hosting/j728ebas.png)  
“以后我们还能在一起看雪吗？”  
“当然，一直可以......”

## 题目描述

小镇可以看作是一个 $n \times n$ 的网格，其中有 $k$ 个格子是房屋。    
小镇里面还有灯。每两个相邻的格子之间有一盏灯。

如果两幢房屋**相邻**，那么这两幢房屋之间的灯就会点亮。  
请问这座小镇一共有多少盏灯被点亮。

注意，本题中相邻指有公共边。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/tbjkl3ul.png)  
如图，阴影格子为房屋，被描红的边为灯。

#### 数据范围

对于 $30\%$ 的数据，$1 \leq n,k \leq 100$。  
对于 $80\%$ 的数据，$1 \leq n,k \leq 5000$。  
对于 $100\%$ 的数据，$1 \le n,k \le 10^5$。  

## 样例 #1

### 输入

```
6 12
1 1
2 1
2 2
1 4
3 3
4 3
4 4
3 4
3 6
4 6
5 6
6 6```

### 输出

```
9```

# 题解

## 作者：Utilokasteinn (赞：18)

其实这道题主要代码2行就好了，连if都不用。

定义一个二维map数组，如果不会map的请看这边：
```cpp
先写一个map，map是关键字
map<数组下标类型,数组存储类型>数组名;

举一个例子:
map<long long,long long>a;
就是一个数组a，下标类型是long long，存储类型是long long
有的时候数组不够大就可以这样写，就是速度会比普通数组慢一些 

这道题可以开一个map数组，数组下标是char类型的，存储的数据是int型的
就像这样：
map<char,int>a; 

二维数组的话只要在map里面再写一个map就好了，比如这样：
map<int,map<int,int> >;
```
如果这里有房子就为1，没有则为0。所以，可以直接把上下左右的数加起来，如果有房子为1就加1，没有为0就相当于加0，也就是什么也没有加。代码很简洁，有压一点行。代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x,y,ans;
map<int,map<int,int> >a;
int main()
{
	for(cin>>n>>k;k--&&cin>>x>>y&&(a[x][y]=1);)//把输入循环赋值全部压这行里了 
		ans+=a[x-1][y]+a[x+1][y]+a[x][y+1]+a[x][y-1];//上下左右全部加起来 
	cout<<ans;//输出答案 
	return 0;
}
```
谢谢观赏


---

## 作者：犇犇犇犇 (赞：13)

这里是官方题解qaq  
其实出这道题本质考察的是对于行列分别排序统计  
但是比赛的时候貌似都是用 map 过的  

### 对于 $30\%$ 的数据，$1 \leq n,k \leq 100$。  
没啥注意的，算法同 $80\%$ 的数据，直接根据题意暴力模拟即可。

### 对于 $80\%$ 的数据，$1 \leq n,k \leq 5000$。  
我们可以暴力枚举任意两个被涂色的格子，看他们是否相邻。  
对于两个相邻的格子，可以注意到他们行相同，列差为一 或者 列相同，行差为一。所以我们可以通过 $abs(x_1-x_2)+abs(y_1-y_2)==1$的方法来判断是否相邻。  
时间复杂度 $O(k^2)$。  
代码：  
```
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f; 
}
int n,k,x[MAXN],y[MAXN],ans=0;
int main()
{
	n=read();k=read();
	for(int i=1;i<=k;i++)
	{
		x[i]=read();
		y[i]=read(); //读入
	}
	for(int i=1;i<=k;i++)
		for(int j=i+1;j<=k;j++) //暴力枚举任意两个格子
		{
			if(abs(x[i]-x[j])+abs(y[i]-y[j])==1) //判断相邻
				ans++;
		}
	cout<<ans<<endl;
	return 0;
} 
```

### 对于 $100\%$ 的数据，$1 \leq n,k \leq 10^5$。 

我们把两个相邻格子的公共边成为夹边。  
观察样例，可以发现对于每条夹边，都平行于x轴或者平行于y轴。所以我们可以自然想到对于平行于x轴和y轴的夹边分开计算。  
接下去步骤就比较明了了，对于平行于x轴的边，我们把格子的x轴作为第一关键字排序，再根据y轴排序。  
这样，就保证了相邻的两个格子如果x轴相同，那他们的y轴单调递增。  
这时候我们比较y轴是否差一，便能统计出所有平行于x轴的夹边了。平行于y轴的边同理，具体见代码。  
时间复杂度 $O(k log k)$

代码：  
```
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
struct node
{
	int x,y;
}a[MAXN];
bool cmp1(node a,node b)
{
	if(a.x!=b.x) return a.x<b.x;
	else return a.y<b.y; 
} 
bool cmp2(node a,node b)
{
	if(a.y!=b.y) return a.y<b.y;
	else return a.x<b.x;
} //排序函数
int n,k,ans;
int main()
{
	n=read();k=read();
	for(int i=1;i<=k;i++)
	{
		int x,y;
		x=read();y=read();
		a[i].x=x;a[i].y=y;		
	}
	sort(a+1,a+k+1,cmp1); //统计平行于x轴的边
	for(int i=1;i<k;i++)
	{
		if(a[i].x==a[i+1].x && a[i].y==a[i+1].y-1) //若x轴相同并且y轴差为1
			ans++;
	}
	sort(a+1,a+k+1,cmp2); //统计平行于y轴的边
	for(int i=1;i<k;i++)
	{
		if(a[i].y==a[i+1].y && a[i].x==a[i+1].x-1) //同上
			ans++;
	}
	cout<<ans<<endl;
	return 0; //qwq
} 
```

---

## 作者：houpingze (赞：12)

这题有一个特别简单的方法——一边输入边判断。

~~（我考试的时候怎么没想出来）~~

先写个map数组：

```cpp
map<int,map<int,int> >a;
```

再for循环输入：
```
for(int i=1;i<=m;i++){
	cin>>x>>y;
	a[x][y]++;
}
```
如果上面有房子，cnt++

下面有房子，cnt++

以此类推

## AC CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long cnt=0;
map<int,map<int,int> >a;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]++;
		if(a[x-1][y]) cnt++;
		if(a[x][y-1]) cnt++;
		if(a[x+1][y]) cnt++;
		if(a[x][y+1]) cnt++;
        //上下左右有房子，cnt++
	}
	cout<<cnt;
	return 0;
}

```





---

## 作者：infinities (赞：3)

一道一眼题，但是也是比赛时唯一有心情写的题。

提供一种不需要写 cmp 来排序的更水方法。

但是一开始脑残的我没有发现 $n \le 10^5$ 于是脑残到开了一个 $n^2$ 的二维数组。

实际上我们完全可以在这个的基础上直接改进，具体操作只需要把数组换成 C++ STL 中的 map，注意开二维，然后每次读入房子只需要看看上下左右是否有房子，有的话计数器加一，否则不变，然后输出即可。

由于 map 是单次 $O(\log k )$ 的，所以总复杂度是 $ O(k \log k)$，但是由于 STL 自带略大常数，而且每次要进行5次操作，所以常数巨大，但是出题人没有毒瘤到卡常，所以可以使用。

水的一匹的code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rint register int
const int maxn = 2e5;
using std::ios;
using std::cin;
using std::cout;
using std::max;
using std::min;
using std::sort;
using std::unique;
using std::lower_bound;
using std::map;
using std::swap;
using std::abs;
using std::acos;

int n, k, xx, yy, ans;
map <int, map<int, int> > ma;
//注意int和ma之间的两个">"要分开，避免被识别为右移。

signed main(){
	cin >> n >> k;
	
	for(int i = 1; i <= k; i++){
		cin >> xx >> yy;
		ma[xx][yy] = 1;
		if(ma[xx - 1][yy] > 0)ans++;
		if(ma[xx + 1][yy] > 0)ans++;
		if(ma[xx][yy + 1] > 0)ans++;
		if(ma[xx][yy - 1] > 0)ans++;
        //计数即可，注意这里要写大于0，不能写"ma[xx][yy - 1]"，否则会出现一些奇奇怪怪的错误
	}
	cout << ans;
	return 0;
}
```

---

## 作者：sipu6174 (赞：3)

## STL做法

用一个pair储存二维坐标，再用map映射一个bool值。

对每一个坐标，判断上下左右四格有没有值为1的，如果有ans++。

因为同一盏灯会被两边各算一次，最后将ans/2即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int opx[]={0,0,-1,1,0},opy[]={0,1,0,0,-1};
pair<int,int> pos[N],tmp;
map<pair<int,int>,bool>mp;
int ans;
int main(){
   cin>>n>>m;
   for(int i=1;i<=m;i++){
      cin>>pos[i].first>>pos[i].second;
      mp[pos[i]]=1;
   }
   for(int i=1;i<=m;i++)
      for(int j=1;j<=4;j++){
         tmp.first=pos[i].first+opx[j];
         tmp.second=pos[i].second+opy[j];
         ans+=mp[tmp];
      }
   cout<<ans/2;
   return 0;
}
```


---

## 作者：Terrible (赞：2)

## 思路

先想象小镇是空的，按照顺序依次插入房屋，并判断是否与其他房屋毗邻。

#### 为什么不能按随机顺序插入？

因为本题数据 $n\leqslant 10^5$，如果随机插入，一般需要用 bool 数组记录房屋位置，大约需要 $9537$ MB 内存。用 `std::map` 亦可，但常数上大于本题解代码。

#### 按什么顺序插入？

先按行排列再按列排列，这样的房屋插入的顺序就是有序的。我们只记录每一列行数最大的房屋，就可以解决问题。

#### 时间复杂度：
主要是快排，$O(k \log k)$。

枚举插入，$O(k)$。

常数很小。

![样例数据排列图示](https://cdn.luogu.com.cn/upload/image_hosting/8nfmmemn.png)

![样例数据算法图示](https://s3.bmp.ovh/imgs/2023/03/20/30af0813c5453f0d.gif)

## 代码：

```cpp
#include<cstdio>
#include<algorithm>
inline int read()//正整数快读 
{
	int a=0;char c;
	while((c=getchar())<'0');
	while(c>='0')a=a*10+(c^48),c=getchar();
	return a;
}
struct Pair//手写pair 
{
	int a,b;//a表示行，b表示列 
	bool operator<(const Pair&q)//C++的struct可以运算符重载。 
	{
		return a==q.a?b<q.b:a<q.a;//先按行来，行相等，则按列比较大小。 
	}
}x[100005];//房屋位置。 
int l[100005];//记录每列房屋行数的最大值。 
int main()
{
	int n=read(),k=read(),a,b,i,sum(0);
	for(i=0;i<=n;i++)l[i]=-1;//防止枚举的时候把边界情况也枚举上。 
	for(i=0;i<k;i++)a=read(),b=read(),x[i]={a,b};//C++11特性。 
	std::sort(x,x+k);//快排，O(klogk)，主要的复杂度在这里。 
	for(i=0;i<k;i++)//枚举，O(k)，依次将房屋插入小镇。 
	{
		if(l[x[i].b-1]==x[i].a)sum++;//判断是否与左端房屋毗邻。 
		if(l[x[i].b]==x[i].a-1)sum++;//判断是否与上端房屋毗邻。 
		l[x[i].b]=x[i].a;//更新最大值。 
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：Franka (赞：1)

### **题外话**
考试的时候傻掉了，忘记用$map$了。。

显而易见，这道题用$map$最简单（不用$map$，反正我考试的时候就。。）

### **思路**
读入**k个数**，建一个图记录他们出现的位置，然后四面八方的加起来，最后输出的数要**除以2**。

别的不讲（太水了），讲一下为什么要除以$2$。

以题目样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/tbjkl3ul.png)

程序运行时，如果不除以2，每个就会多算一份。

以$(2,2)$为例，将他四个方向的数加起来，和为$1$，但是这个$1$再算$(2,1)$的时候已经算过了，所以最后的结果要除以$2$。

### **代码（应该很好理解）**
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,map<int,int> > a;
//注意，这里不能直接写map<int,map<int,int>> a;，程序会把>>这两个字符连起来，会造成编译错误！！
int main()
{
	int x[100001],y[100001],n,k,s;
	cin>>n>>k;
	for(int i=1;i<=k;i++)//k个
	{
		cin>>x[i]>>y[i];//这里的x和y记录一下
		a[x[i]][y[i]]=1;//标记这个位置
	}
	s=0;//s要清零！！
	for(int i=1;i<=k;i++) s+=a[x[i]-1][y[i]]+a[x[i]+1][y[i]]+a[x[i]][y[i]-1]+a[x[i]][y[i]+1];//四个方向加起来
	cout<<s/2;//输出s除以2
	return 0;
}
```


---

## 作者：zjrdmd (赞：0)

一眼水题~

用一个vis数组表示这个点是否有房子，但是由于这个数组是二维的，所以我们考虑优化到一维，显然，我们可以给每个点赋一个值，那么考虑怎么赋值他不会重复，还是很显然，假设有点x,y。那么我们可以把vis[x*n+y]标记成true。

容易证明，这样任意两个点应该都不会有重复的值，于是这样可以在O(klogk)的时间解决。

当然可以用哈希做到O(k),但是没有必要。

下面是代码啦。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <stdlib.h>
#include <stack>
#include <queue>
#define ri register int
#define N 100005

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}

struct node{
	int x,y;
};


int ans=0;
int xx[5]={1,-1,0,0};
int yy[5]={0,0,1,-1};
std::map<long long,bool>vis;


int main(){
    int n=read(),m=read();
    for(ri i=1;i<=m;i++){
    	int x=read(),y=read();
    	for(ri j=0;j<4;j++){
    		int ii=x+xx[j];
    		int jj=y+yy[j];
    		if(vis[ii*n+jj])ans++; 
		}
		vis[x*n+y]=true;
	}
	printf("%d",ans); 
	return 0;
}

```


---


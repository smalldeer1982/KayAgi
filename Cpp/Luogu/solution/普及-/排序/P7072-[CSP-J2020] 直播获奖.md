# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# 题解

## 作者：AzusagawaKaede (赞：358)

# P7072 直播获奖 题解

$update:$
优化了代码的风格



蒟蒻的第一篇题解 求过

此题动态维护第K大数，显然对顶堆

****

先来看几种错误解法：

## 1. 每读入一个就sort排序一次（$50pts$）

这种解法最好想，相应的分也就最少

代码如下
```c++
scanf("%d%d", &n, &w);
for (int p = 1; p <= n; p++)
{
	now=max(1,p*w/100);
	scanf("%d", &a[p]);
	sort(a+1, a+p+1, greater<int>());
	printf("%d ", a[now]); 
}
return 0;
```




结果如下

![](https://cdn.luogu.com.cn/upload/image_hosting/ubknm6ij.png)

## 2. 整体做一次插入排序，边读边做插入排序边输出（$85pts$）

复杂度$O(n^2)$,神奇地过了n=10^4的数据

代码如下

```c++
scanf("%d%d", &n, &w);
a[0]=0x7fffffff;
for (int p = 1; p <= n; p++)
{
	now=max(1,p*w/100);
	scanf("%d", &num);
	for (int i = p; i >= 0; i--)
	{
		if (num < a[i])
		{
			a[i+1]=num;
			break;
		}
		else
		{
			a[i+1]=a[i];
		}
	} 
	printf("%d ", a[now]); 
}
```

结果如下

![](https://cdn.luogu.com.cn/upload/image_hosting/cv5ce27q.png)

****
接下来，我们来了解对顶堆

## 1.什么是对顶堆？
通俗的说，对顶堆是一种简单好用的**动态维护单调区间第k大数或第k小数的数据结构** ~~（好像也不怎么通俗啊）~~,
由一个大顶堆和一个小顶堆构成

 先看图（由于题意降序排列，小顶堆在上， 大顶堆在下。反之亦然 ）：

![](https://cdn.luogu.com.cn/upload/image_hosting/wgonylvh.png)



**不言而喻，一目了然**

*********

## 2. 基本操作

1. 插入元素
```c++
void push(int num)
{
	if (num >= ma_hp.top())
   		mi_hp.push(num);
	else ma_hp.push(num);
	qwq();//调整小顶堆元素个数
}
```

2. 在两个堆之间交换元素:



大->小（下->上）:
```c++
mi_hp.push(ma_hp.top());
ma_hp.pop();
```


小->大（上->下）:
```c++
ma_hp.push(mi_hp.top());
mi_hp.pop();
```

3. 查询
```c++
mi_hp.top();
```


注意：插入元素时应注意整个序列的单调性，判断应插入上面还是下面
于是题目就变成一个动态维护序列第p\*w%大数的题目啦~
****

## 3. 代码

递上一份蒟蒻写的蒟蒻代码

$code:$

```c++
#include <bits/stdc++.h>

using namespace std;

priority_queue<int> ma_hp;//大顶堆 
priority_queue<int, vector<int>, greater<int> > mi_hp;//小顶堆 

int n, w, now, num;

void qwq()//调整获奖人数（小顶堆元素个数）
{
	if (mi_hp.size()<now)
	{
		mi_hp.push(ma_hp.top());
		ma_hp.pop();
	} 
	if (mi_hp.size() > now)
	{
		ma_hp.push(mi_hp.top());
		mi_hp.pop();
	}
	
} 

void push(int num)
{
	if (num >= ma_hp.top()) mi_hp.push(num);
		else ma_hp.push(num);
	qwq();
}

int main()
{
	scanf("%d%d", &n, &w);
	ma_hp.push(0);//避免边界判断 
	for (int p = 1; p <= n; p++)
	{
		now=max(1,p*w/100);;//实时获奖人数 
		scanf("%d", &num);
		push(num);
		printf("%d ", mi_hp.top()); 
	}
	return 0;
}
```

*result：*
![](https://cdn.luogu.com.cn/upload/image_hosting/9fivymje.png)

PS：由于数据范围较小，官方正解应该是桶排序。但是对顶堆可以应对数据更大的题目，并且代码也非常短，是一种非常好用的数据结构呢。

对顶堆练手题目：[P3871](https://www.luogu.com.cn/problem/P3871)

### 点个赞再走吧
### 谢谢



---

## 作者：Eason_AC (赞：30)

## Update
- $\texttt{2020.11.13}$ 修改了一个小细节。
- $\texttt{2020.11.16}$ 修改了一个错误。

## Content
有一场 $n$ 个人的比赛，计划获奖人数为总人数的 $w\%$。第 $i$ 个人的成绩为 $a_i$。请求出在第 $i\in[1,n]$ 个人出成绩时的实时分数线。

**数据范围：$n\leqslant 10^5,0\leqslant a_i\leqslant 600,1\leqslant w\leqslant 99$。**
## Solution
考场没想出来，果然还是我太菜。

考虑开个大小为 $600$ 的桶，然后在读入第 $i$ 个人的成绩的时候边将其分数放到相应的桶中，在按照分数 $k$ 从大到小直接遍历一遍，统计分数大于等于 $k$ 的人的个数，直到这个数 $\geqslant \max(1,\left\lfloor i\times w\%\right\rfloor)$ 为止，此时的 $k$ 就是答案，输出就好。
## Code
```cpp
int n, w, x, a[607];

int main() {
	scanf("%d%d", &n, &w);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &x);
		a[x]++;
		int pl = max(1, i * w / 100), num = 0;
		for(int j = 600; j >= 0; --j) {
			num += a[j];
			if(num >= pl) {printf("%d ", j); break;}
		}
	}
	return 0;
}

```

---

## 作者：GZXUEXUE (赞：5)

### 思路

注意到由于选手的分数不超过 $600$，且并列的人都可以获奖，考虑使用一个数组去记录该得分段的人数。

每次加入一个人之后，我们只需要找到一条分数线，判断当前累计获奖人数是否达到了 $\max(1, \lfloor p \times w \%\rfloor)$ 即可。同时，由于计算分数线不用考虑后面的人，所以可以直接一边输入一遍计算。

该算法的时间复杂度为 $O(nm)$，其中 $m = 600$。

### 实现

```cpp
# include <iostream>
# include <cmath>
using namespace std;
int a[601]; // a[i]表示该分数段的人数
int main(){
    int n,w,tmp; scanf("%d %d",&n,&w);
    for (int i = 0;i < n;i++){
        cin >> tmp;
        a[tmp]++; // 记录这个人的分数
        // j表示当前分数线，sum表示当前累计获奖人数，sc表示当前计划获奖人数
        int j = 600,sum = 0,sc = max((i + 1) * w / 100,1);
        for (;j >= 0 && sum < sc;j--) sum += a[j];
        cout << ++j << " ";
    }return 0;
}
```

---

## 作者：niuniudundun (赞：4)

[原题。](https://www.luogu.com.cn/problem/P7072)

# 解法

考虑桶排序思想。

定义选手成绩为 $a_i$，和一个桶 $t$。

每输入一个 $a_i$，将 $a_i$ 添加入桶，即 $t_{a_i}\gets t_{a_i}+1$。

既然分数高的获奖，则从 $a_i$ 上限 $600$ 遍历到下限 $0$，计数器计算当前人数，即 $\displaystyle \sum_{i'=i}^{600} t_{i'}$（$i$ 为循环变量），随后判断人数是否大于等于 $\left \lfloor i\times w\% \right \rfloor $，大于等于则当前的 $i$ 就是获奖分数线，输出即可。

# 代码

复杂度：$O(An)$，其中 $A$ 是 $a$ 值域，即 $600$。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=1e5+1;
int a[maxn],tong[maxn];
int n,w;
int ans=0;
int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		tong[a[i]]++;
		int sum=0;
		for(int j=600;j>=0;j--){
			sum+=tong[j];
			if(sum>=max(1,i*w/100)){
				ans=j;
				cout<<j<<" ";
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：3)

按照题意模拟即可。因为分数值域 $V=600$ 不大，所以我们可以开桶存储每个分数的人数。对于每一个选手，计算出当前的获奖人数并从高到低枚举分数，当当前获奖人数大于或等于 $k$ 时输出当前分数即可。时间复杂度 $O(nV)$ 可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[602];

int main(){
    int n,w;cin>>n>>w;
    for(int i=1; i<=n; i++){
        int x;cin>>x;a[x]++;
        int k=max(1,int(i*w/100.0)),ans=0;
        for(int j=600; j>=0; j--){
            if(ans+a[j]<k) ans+=a[j];
            else{
                cout<<j<<" ";
                break;
            }
        }
    }
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

观察题目我们会发现，本题需要维护一个有序数组，需要完成的功能有插入和查询排名为 $k$ 的数。

所以我们可以直接掏出大杀器 Treap，其可以在 $O(\log n)$ 时间内完成插入以及查询。

综上时间复杂度为 $O(n\log n)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e5 + 10, INF = 1e3;

int n, p;
struct Node
{
    int l, r;
    int key, val;
    int cnt, size;
}tr[N];
int root, idx;

void pushup(int u)
{
    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + tr[u].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build()
{
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
    pushup(1);
    if (tr[1].val < tr[2].val)
        zag(root);
}

void insert(int &p, int key)
{
    if (!p)
        p = get_node(key);
    else if (tr[p].key == key)
        tr[p].cnt ++;
    else if (tr[p].key > key)
    {
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val)
            zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val)
            zag(p);
    }
    
    pushup(p);
}

int query_key(int p, int rank)
{
    if (!p)
        return INF;
    if (tr[tr[p].l].size >= rank)
        return query_key(tr[p].l, rank);
    if (tr[tr[p].l].size + tr[p].cnt >= rank)
        return tr[p].key;
    return query_key(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    build();
    
    cin >> n >> p;
    for (int i = 1; i <= n; ++ i )
    {
        int x;
        cin >> x;
        int k = min(i, i - int(p * 0.01 * i) + 1);
        insert(root, x);
        cout << query_key(root, k + 1) << ' ';
    }
    
    return 0;
}
```

---

## 作者：Eason_cyx (赞：3)

注意到值域不大，考虑用一个桶记录当前每个分数有多少人，这样在每一次查询中，只需要从大到小枚举所有的分数，判断一下前缀和是否已经 $\ge \max(1, \lfloor p \times w \%\rfloor)$，如果大于等于了就直接输出当前枚举的分数即可。

值域显然是 $V=\max a_i = 600$（$a_i$ 为每个选手的分数），所以时间复杂度 $O(nV)$。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int box[605];
int main(){
	int n,w;
	cin >> n >> w;
	for(int i = 1;i <= n;i++)
	{
		int x;
		cin >> x;
		box[x]++;
		int cnt = max(1,int(i * w / 100.0));
		for(int j = 600;j >= 0;j--)
		{
			cnt -= box[j];
			if(cnt <= 0)
			{
				cout << j << ' ';
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：bowen404 (赞：3)

用 python 刷 P7072 的时候遇到了困难。

由于 python 的性能比 c++ 差了 5-10 倍，导致这道用 c++ 随便过的桶排序的题差最后的三个点 TLE，所以不得不另寻他法降低开销。

仔细观察数据，可以发现人数每次增加一位，所以分数线每次最多移动一次：左移到非零位，不变，右移到非零位。

所以可以根据这个思路，设置左右两个标志位，分别表示当前分数线左侧非零位和右侧非零位。

## 核心思路：
- 如过人数过多，左界及当前点右移
- 如过人数不足，右界及当前点左移

## 优化：
- 在必要时才移动当前位置，节省了大多数 rank 不变的时候的开销
- 总人数随循环直接计算，节省了反复求和这个 $O(n)$ 的过程

## 核心难点：
- 准确的找到左右标志位
- 左右标志位到达两侧边界的时候进行特判

## 以下为 AC 代码
- 大概优化到了线形级
- 没用 python 自带的特性，纯手写，通用性比较强，之后可以换 c++ 尝试一下。

```python
n, w = map(int, input().split())
ls = list(map(int, input().split()))
a = [0] * 610

total = 0
lt = 0  # 保存上一次sum所在位置的左侧第一个非零元素
cur = ls[0]   # 保存上一次sum所在位置
rt = 600  # 保存上一次sum所在位置的右侧第一个非零元素


def find_right(idx):
    for k in range(idx+1, 600):
        if a[k] != 0:
            return k
    return idx


def find_left(idx):
    for k in range(idx-1, -1, -1):
        if a[k] != 0:
            return k
    return idx


for i in range(n):
    score = ls[i]
    a[score] += 1
    # 如果新来的数在右侧空隙, 或新数拓宽了右边界, 就更新右侧. 左侧同理
    if cur < score < rt or score > rt and cur == rt:
        rt = score
    if lt < score < cur or score < lt and cur == lt:    # 更新左侧
        lt = score

    rank = max(1, (i + 1) * w // 100)

    if score >= cur:  # 如果分数比当前值高, 显然人数要+1
        total += 1

    if total - a[cur] >= rank:  # 人数过多?
        total -= a[cur]  # 减去当前桶
        lt, cur = cur, rt  # 左界及当前点右移
        rt = find_right(rt)  # 找right右边下一个非零人的分数

    elif total < rank:    # 人数不足
        total += a[lt]  # 加上左侧桶
        cur, rt = lt, cur  # 右界及当前点左移
        lt = find_left(lt)  # 找left左边下一个非零人的分数

    print(cur, end=' ')
```

---

## 作者：infinities (赞：3)

作为一名非J组的选手，赛后听人说了说题面，但是并没有听到值域，于是想当然地认为值域是 $[1,1000000000]$，口胡了一个和值域范围没有关系的 $O(n \log n)$ 的做法。

大致思路就是维护两个堆，一个大根堆维护目前在分数线下的人，一个一个小根堆维护分数线内的，每次新加进来一个人，我们先看看加入这个人后，名额有没有比之前多1，如果有的话，直接将新进来的这个人压入分数线下的大根堆，然后弹出大根堆中最大的一个人加入小根堆中。

如果没有多一个名额，那么也先压入大根堆，比较一下大根堆最大的那个数和小根堆最小的那个数，如果后者小于前者就调换一下位置即可。

易证，这么做可以保证大根堆中的最大值严格不大于小根堆中的最小值，且小根堆中的数的个数恰好是名额个数，这样就满足了题目要求。

要求输出及格线上的分数，那么直接输出小根堆的最小值即可。

code：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rint regester int
const int maxn = 1e6 + 10;
const int INF = 1e9;
using namespace std;
int read(){int x = 0,f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){if(ch == '-')f = -1; ch = getchar();}while(ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();} return x * f;}
int n, w, pre, a[maxn];
priority_queue<int>qmin, qmax;
signed main(){
	cin >> n >> w;
	for(int i = 1; i <= n; i++)a[i] = read();
	for(int i = 1; i <= n; i++){
		int now = max(1, i * w / 100); qmax.push(a[i]);//处理一下当前的名额
		if(now > pre){qmin.push(-qmax.top()); qmax.pop();}//如果名额多了
		else{int to = qmax.top(); qmax.pop(); int to1 = -qmin.top(); qmin.pop(); if(to > to1)swap(to, to1); qmin.push(-to1); qmax.push(to);}//如果名额没有多
		cout << -qmin.top() << " "; pre = now;//输出，而且下次就要比对这次的名额了
	}
}
```

---

## 作者：Zskioaert1106 (赞：2)

题目传送门：[P7072 [CSP-J2020] 直播获奖](https://www.luogu.com.cn/problem/P7072)

总感觉这题比 T1 还简单。

### 做题过程

良心之把计算方法都给你了。计划获奖人数为 $\max(1,\lfloor p\times w\%\rfloor)$。

我们开桶记录每个分数的人数，从高往低遍历直到总数大于等于计划获奖人数，输出此时桶的下标。

### 代码编写

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,a[654];
int main(){
    cin>>n>>w;
    for(int i=1;i<=n;i++){
        int l;
        cin>>l;
        a[l]++;
        int lv=max(1,i*w/100);
        int s=0,j=600;
        while(s<lv){
            s+=a[j];
            j--;
        }//如果人数多于计划则从此往后的人都无法获奖
        cout<<j+1<<' ';
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/171282430)。

---

## 作者：Jerry_zpl (赞：1)

# P7072 [CSP-J2020] 直播获奖

#### 题意：

1\. 给两个整数 $n,w$ 分别代表选手总数与获奖率。\
2\. 再给 $n$ 个数，分别代表 $n$ 个选手的 NOIP 的成绩。\
3\. 求出获奖的人的成绩。

#### 分析思路

- 1\. 当前已评出了 $x$ 个选手的成绩，则当前计划获奖人数为 $\max (1,x \times w \div 100)$
- 2\. 计划获奖人数可能比获奖人数多
- 3\. 每读入一个选手的成绩，要使用 `sort` (快排）把分数从高到低排序。

```cpp
#include<bits/stdc++.h>//万能头文件。
using namespace std;//命名空间，不想讲。
long long k[1000005];//定义一个k数组，是全局变量，代表n个选手的分数。
bool cmp(int q,int h) {return q>h;}//使用cmp函数，帮助下面的sort快排从高到低排序。
int main() //主函数
{
	int n,w;//定义两个变量n和w，分别代表表选手总数和获奖率
	cin>>n>>w;//输入n和w
	for(int i=1;i<=n;i++)//开一个for循环，从1遍历到n。
	{
		int x=max(1,i*w/100);//定义变量x，代表当前计划获奖人数。
		cin>>k[i];//在开一个for循环，从1遍历到n的同时进行输入；
		sort(k+1,k+i+1,cmp);//紧接着是排序，把当前i个选手的分数从高到低排序。
  //不过sort只能从小到大排序，所以要用cmp函数来从大到小排序。
		cout<<k[x]<<" "; //输出当前最新获奖人的分数。
	}
	return 0;//返回0，华丽结束。
}
```

发现只有 $65$ 分，因为快速排序的时间复杂度太高了，所以我们需要换一个思路：

- 首先定义桶数组，统计选手的分数。
- 使用题目中的公式求获奖人数。
- 从大到小枚举分数线，若果获得分数 $j$ 的人数比获奖人数多，就证明 $j$ 是分数线。

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//命名空间
long long a[9000000],t[1000];//定义两个全局变量，分别是a数组和t数组。a数组是每个选手的分数，t数组用来记录每个分数出现的次数。
int main()//主函数
{
	int n,w;//定义两个变量n和w，分别代表选手总数和获奖率
	cin>>n>>w;//输入n和w
	for(int i=1;i<=n;i++)//开一个for循环，从1遍历到n，遍历每个选手的分数。
	{
		cin>>a[i];//输入每个选手的分数。
		t[a[i]]++;//每读入一个选手的分数，分数对应的桶就+1。
		int k=max(1.0,1.0*i*w/100);//定义变量k,计算当前计划获奖人数
		for(int j=600;j>=0;j--)//开一个内层for循环，遍历选手的分数。
		{
			k=k-t[j];//
			if(k<=0)//k<=0就证明当前的j是获奖的人的分数线。因为有分数相同的人，所以是<=0。
			{
				cout<<j<<" ";//输出j
				break;//跳出循环
			}
		}
	}
	return 0;//返回0，华丽结束。
}
```

---

## 作者：Ak_hjc_using (赞：1)

题解：[P7072 [CSP-J2020] 直播获奖](https://www.luogu.com.cn/problem/P7072)

#### 思路
如果我们直接采用暴力的思路，那么一定会超时。

那么直接考虑正解。

我们可以使用**桶排序**的做法来做出本题。

用 $vis_{i}$ 来表示成绩为 $i$ 的学生数量，因为这里的 $a_{i}$ （也即学生的成绩）的最大值是 $600$，所以我们直接枚举到 $600$ 即可。

然后我们直接从 $600$ 到 $1$ 遍历（遍历的是最终输出的分数线），所以我们就可以用一个计数器变量统计已经有多少个人了，如果到了目标的人数 $\max(1, i \times w\%)$，那么直接输出当时遍历的答案即可。
#### 思路
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N = 1e7 + 1;
LL vis[N], a[N], n, w;
int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> w;
    for (LL i = 1; i <= n; i++) {
        cin >> a[i];
        vis[a[i]]++;
        LL cnt = 0;
        LL num = max(1ll, i * w / 100);
        for (LL j = 600; j >= 0; j--) {
            cnt += vis[j];
            if (cnt >= num) {
                cout << j << ' ';
                break;
            }
        }
    }
    return 0;
}

```

---

## 作者：SUNCHAOYI (赞：1)

$\texttt{T2}$

简单模拟，仔细读题注意一些细节就行 (比如循环范围，数据类型等)。

因为最大的点 $n = 10^5$，如果每次输入后都进行一次快排，最后可能超时。

考虑用一个数组 `num[i]` 记录不小于分数 $i$ 的人数。输入一个人的分数 $x$ 后，将会对数组 `num[0-x]` 分别产生 $1$ 的贡献，然后计算出当前获奖人数。   

由题知**每个选手的成绩均为不超过 $600$ 的非负整数**，所以就可以从大到小枚举 `num[i]`，直到找到第一个 `num[i]` 满足不小于当前获奖人数后，输出并退出循环。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n,w,x,num[605];//num[i] means the number of people that the scores are equal or more than i 
int main ()
{
	freopen ("live.in","r",stdin);
	freopen ("live.out","w",stdout);
	scanf ("%d%d",&n,&w);
	for (int i = 1;i <= n;++i)
	{
		scanf ("%d",&x);
		for (int j = 0;j <= x;++j) ++num[j];
		int now = max ((double) 1,floor ((double) i * w / 100.0));
		for (int j = 600;j >= 0;--j)
		{
			if (num[j] >= now) 
			{
				printf ("%d ",j);
				break; 
			}
		}
	}
	puts ("");
	return 0;
}
```

---

## 作者：novax (赞：1)

### 题意

有 $N$ 个人，每人有一个分数，要你实时求出进入前 $w\%$ 所需要的分数线。

### 思路

考虑题目中所说的“前 $w\%$ 的分数线”，当进入前 $w\%$ 的分数有并列分数的人时，会增加获奖人数而不是更改分数线，所以并列的分数不需要考虑，所以只需要考虑第 $\lfloor p \times w \% \rfloor$ 名的分数就可以了。

此时题目就变成了：求一个动态增加的数列中的第 $k$ 大。其中 $k$ 为当前的 $\lfloor p \times w \% \rfloor$。

### 解法

#### 暴力

容易想到每读入一个数就对整个数列进行排序，然后输出第 $\lfloor p \times w \% \rfloor$ 大的数。时间复杂度是 $O(n^2\log n)$，只有50pts。

#### 桶排序

仔细读题会发现：题目中给定的分数一定小于等于600！所以我们可以开一个大小为600的桶数组 $T_i$ ，表示当前分数为 $i$ 的人数。每一次都从600分开始从大往小遍历整个数组，在循环中维护一个变量 $cnt$，表示大于等于当前分数的人数，在每个分数值都加上当前分数值的人数，当这个人数大于等于 $\lfloor p \times w \% \rfloor$ 时，当前的分数值就是要求的答案了。时间复杂度是 $O(600n)$，应该可以过 $10^5$ 的数据，100pts。

#### 对顶堆

我们也可以维护两个堆，一个大根堆，一个小根堆，其中小根堆中维护最大的 $\lfloor p \times w \% \rfloor$ 个数，大根堆维护剩下的 $p - \lfloor p \times w \% \rfloor$ 个数。此时要求的数就是小根堆的堆顶。若小根堆元素数量大于需要的，就将小根堆的堆顶弹出，插入大根堆；反之亦然。当有新的数插入时，只需要维护对顶堆的状态，就能求出要求的分数了。时间复杂度是 $O(n\log n)$，100pts。

---


# [COCI 2009/2010 #3] SORT

## 题目描述

Mirko 是一个伟大的密码破解者。他知道世界上任何密码都可以通过频率分析来破解。

但他完全弄错了什么是频率分析。

他截获了一个敌人的信息。这个信息由 $N$ 个小于等于 $C$ 的数字组成。 

Mirko 相信频率分析包括对这个序列进行排序，使频率较高的数字出现在频率较低的数字之前。

给定任何两个数字 $x$ 和 $y$，如果 $x$ 在原始序列中出现的次数大于 $y$ 出现的次数，则 $x$ 出现在 $y$ 之前。如果出现的次数相等，则输入中谁的值出现的早，谁就应该在排序后的序列中出现靠前。

请帮助 Mirko 制作一个「频率排序器」。


## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le N \le 10^3$，$1 \le C \le 10^9$，$1\le a_i \le C$。

#### 说明
翻译自 [COCI 2009-2010 #3 T3 SORT](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 70，每个测试点 7 分，共 10 个测试点。

## 样例 #1

### 输入

```
5 2
2 1 2 1 2
```

### 输出

```
2 2 2 1 1
```

## 样例 #2

### 输入

```
9 3
1 3 3 3 2 2 2 1 1
```

### 输出

```
1 1 1 3 3 3 2 2 2
```

## 样例 #3

### 输入

```
9 77
11 33 11 77 54 11 25 25 33
```

### 输出

```
11 11 11 33 33 25 25 77 54```

# 题解

## 作者：櫻尘ིོི༹ (赞：7)



 **Part1 排序条件**
 
条件实际上很容易得出：

就是 x , y 两个数都会~~多次~~出现。

1.假如 x 出现得多，最后就先输出 x（**出现了多少次输出多少次**）；反之，都懂的。

2.假如 x , y 出现的次数一样，就看谁出现的早，出现的早的那一位，先输出。

大概就是这样：
```

bool cmp(work x,work y){
	if(x.ans!=y.ans)return x.ans>y.ans;// ans记录的是分别出现的次数 
	else return x.ft<y.ft;// ft记录的是这个数出现出现在第几位 
}

```

 **Part2 储存**
 
实际上这道题，想~~骗分~~的话，可以直接用桶（哈希）来储存某个数出现的次数。

毕竟数据范围……（对于100%的数据，1 $\leqslant N \leqslant 10^3
  1 \leqslant C \leqslant 10^9 1 \leqslant  a_i  \leqslant C$)( _望而生畏_） 
 
 所以直接定义一个**大大**的结构体呢：
 
 ```
struct work{
	int num;//储存这个数是好多
	int ans;//这个数出现了多少次
	int ft;//这个数是第几个出现的
}w[10005];
```

**Part3 实现**

_Code_：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,cnt; 
int a[10005],b[10005];// a是这个数是多少，b是这个数是第几个出现的 
struct work{
	int num,ans,ft;// num记录这个数出现了多少次 
}w[10005];
bool cmp(work x,work y){
	if(x.ans!=y.ans)return x.ans>y.ans;// ans记录的是分别出现的次数 
	else return x.ft<y.ft;// ft记录的是这个数出现出现在第几位 
}
int main(){
	cin>>n>>c;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		bool blog=0;// 标记 
		for(int j=1;j<i;j++){// 从前面出现了的数里面找相同的 
			if(a[i]==a[j]){
				blog=1;
				w[b[j]].ans++;// 这个数出现的次数++ 
				break;
			}
		}
		if(blog==0){// 标记为假，说明没有出现过这个数
			// 把它储存进去 
			w[++cnt].num=a[i];
			w[cnt].ans=1;
			w[cnt].ft=cnt;// 看它出现的是第几个 
			b[i]=cnt;// 在外面记录一次 
		}
	}
	sort(w+1,w+cnt+1,cmp);// 排序 

	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=w[i].ans;j++){
			cout<<w[i].num<<" ";
		}
	}
	return 0;
}
```



---

## 作者：欢黎明陌 (赞：4)

我的第四篇题解

[原题传送门](https://www.luogu.com.cn/problem/P7259)（有这个东西是真的方便）

这道题在排序题和普及-的题目中算是比较难的，因为它必须要用 $STL$ 的 $map$。



------------


题目给出，输入一个 $N$ （下文用小写的 $n$ 表示），是输入数据的个数；然后输入一个小于 $1e9$ 的数字 $C$ ,它的唯一现实作用是告诉我们这道题不能用桶排；下一行是 $n$ 个待排序的数。

排序规则：

给定任何两个数字 $x$ 和 $y$，如果 x 在原始序列中出现的次数大于 $y$ 出现的次数，则 $x$ 出现在 $y$ 之前。如果出现的次数相等，则输入中谁的值出现的早，谁就应该在排序后的序列中出现靠前。

翻译过来就是：

先按出现频率排，频率一样的看早晚。

这样，我们就可以得到 $sort$ 的灵魂—— “ $cmp$ ”了；

为了方便理解，于是把预处理和主函数之间的都搬过来先：

```cpp
int n , c , num , sum;//用全局变量，省去了初始化 
map<int,int>mapp;
struct inf{//inf表示informance信息，替换成什么都行； 
	int ap_w;
	int ap_t;//分别是 weight 和 time 的缩写 
}a[1001000];//开大一点不吃亏 
bool cmp(inf x , inf y){//先按出现频率排，频率一样的看早晚。
	if( x.ap_t != y.ap_t ) return x.ap_t > y.ap_t;
	else return mapp[x.ap_w] < mapp[y.ap_w];
}
```

### 这道题对于初学$STLmap$的同学并不友善，如果您此前对$map$并不了解，请读懂上面的东西再往下看！！！

 [对于map没有一点了解的看这里](https://blog.csdn.net/sevenjoin/article/details/81943864?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161301550616780299036672%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161301550616780299036672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-81943864.pc_search_result_cache&utm_term=map)



------------


如果弄明白了，那就太好了，离 $AC$ 就很近了,继续往下看吧~~~

之后，我们要不断地利用 $map$ 的特性，我们可以得到曾经是否输入过这个数，以及其输入频率。千万不要忘记统计有多少个数（我定义了一个叫 $sum$ 的变量，初始值一定要是 $0$ 啊），不然输出的时候将会很困难~

哦，对了，个人习惯问题，我加了个快读，不喜欢的同学可以自动把它看做 $cin$ 或 $scanf$ ，很喜欢的同学可以在写个快写，顺便给此题解点个赞~~

下面是标程：

```cpp
#include <map>
#include <iostream>
#include <cstdio>
#include <algorithm>//已经把没有用的头文件都去掉了 
using namespace std;//省去了写无数个“std:” 

int n , c , num , sum;//用全局变量，省去了初始化 
map<int,int>mapp;
struct inf{//inf表示informance信息，替换成什么都行； 
	int ap_w;
	int ap_t;//分别是 weight 和 time 的缩写 
}a[1001000];//开大一点不吃亏 
bool cmp(inf x , inf y){
	if( x.ap_t != y.ap_t ) return x.ap_t > y.ap_t;
	else return mapp[x.ap_w] < mapp[y.ap_w];
}

inline int read()//快读
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main()
{
	n = read() , c = read();
	for(int i = 0;i < n;i ++){
		num = read();
		if(mapp.count(num))	a[mapp[num]].ap_t ++;
		else{
			mapp[num] = ++sum;
			a[sum] = {num,1};
		}
		//利用 map 的特性进行处理，不多解释 
	}
	stable_sort( a + 1 , a + sum + 1 , cmp );//稳定排序哦 
	for(int i = 1;i <= sum;i ++)
		for(int j = 1;j <= a[i].ap_t;j ++)
			cout << a[i].ap_w << " ";	//输出，千万不要忘记空格哦 
	return 0;
}
```


------------


祝大家新年快乐。

祝大家 $RP++$。

管理大大辛苦了。


---

## 作者：luckydrawbox (赞：3)

## 题意

给定一个原始序列，按题目要求排序：

$1.$ 按在序列中出现的次数从大到小排序。

$2.$ 若次数相同，则按在原始序列出现的位置从小到大排序。

$3.$ 相同的元素排序后一定连在一起。（观察样例可得）

所以，**题目怎么说我们就怎么做**。

## 分析

因为涉及排序的变量有很多个，所以我们可以把他们统一放在一个 ``struct`` 结构体里面，根据题意，每个元素涉及的变量有：

$1.$ 元素本身的值 $v$。

$2.$ 元素在序列中出现的次数 $cnt$。

$3.$ 元素在序列中第一次出现的位置 $first$。

在输入的过程中，我们只需在已有的结构体里寻找这个元素是否已经存入过，若找到，则将元素在序列中出现的次数 $+1$，否则新建一个结构体，此时这个元素只出现了一次，所以将 $cnt$ 赋值为 $1$，而 $first$ 就是当前循环中的 $i$。

```cpp
for(int i=1;i<=n;i++)
{
	cin>>x;
	flag=1;//flag存储是否在已有结构体中找到相应元素 
	for(int j=1;j<=m;j++)//在当前m个结构体当中寻找 
	{
		if(a[j].v==x)//找到 
		{
			a[j].cnt++;//这个元素又出现了一次 
			flag=0;//找到了则将flag标记为0 
			break;
		}
	}
	if(flag)//没找到 
	{
		//新建一个
		a[++m].first=i;//第一次是在i处出现 
		a[m].cnt=1;//只出现了一次 
		a[m].v=x;//元素本身的值 
	}
}
```

接下来是排序，~~标题已经告诉我们~~用 ``sort``，不过需要自己写一个比较函数，只要跟着题意的步骤写就行了。

```cpp
bool cmp(asdf x,asdf y)//asdf是结构体名称
{
	return (x.cnt>y.cnt||(x.cnt==y.cnt&&x.first<y.first));
  //按次数较大或次数一样且位置靠前排序
}
```

排好序后就要输出，输出时从小到大循环一遍结构体，对于每个结构体，只需输出 $cnt$ 个 $v$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,c,x,m;//m为结构体个数，初始为0 
struct asdf
{
	int v;//元素本身的值
	int cnt;//元素在序列中出现的次数
	int first;//元素在序列中第一次出现的位置
}a[N];
bool flag;
bool cmp(asdf x,asdf y)
{
	return (x.cnt>y.cnt||(x.cnt==y.cnt&&x.first<y.first));
	//按次数较大或次数一样且位置靠前排序
}
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
    	cin>>x;
    	flag=1;//flag存储是否在已有结构体中找到相应元素 
    	for(int j=1;j<=m;j++)//在当前m个结构体当中寻找 
    	{
    		if(a[j].v==x)//找到 
			{
				a[j].cnt++;//这个元素又出现了一次 
				flag=0;//找到了则将flag标记为0 
				break;
			}
		}
		if(flag)//没找到 
		{
			//新建一个
			a[++m].first=i;//第一次是在i处出现 
			a[m].cnt=1;//只出现了一次 
			a[m].v=x;//元素本身的值 
		}
	}
	sort(a+1,a+m+1,cmp);//将m个结构体排序 
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=a[i].cnt;j++)//第二层循环cnt次 
		{
			cout<<a[i].v<<" ";
		}
	}
	return 0;
}
```

PS:个人感觉 $C$ 没有任何用处~~删了算了~~。

---

## 作者：我和鱼过不去 (赞：3)

### 思路
+ 用 ```map``` 存下数字第一次出现的位置，再用结构体存下数字的值与出现次数。  
+ 排序，输出。  

这里简单介绍一下 ```map``` 。  
```map``` 本质上就像一个数组，  
只不过你可以自己定义键和值 ~~（其实就是下标与它所对应的元素）~~ 类型。
```cpp
map<string,int> mp;  
```
这样你就有了一个可以用 string 类型映射到 int 类型的 ```map``` 数组 $mp$ 。
```cpp
mp["hello"] = 532;
```
这意味着在 $mp$ 数组里，
$\mathtt{"hello"}$ 对应着 $\mathtt{532}$
。
```cpp
mp.count("hello");
mp.count("world");
```
判断该元素之前是否存在映射。
返回值分别为 $\mathtt{1}$ 和 $\mathtt{0}$。  
  
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a;
int sum;      //一共出现了多少个不同的数字,同时可以辅助存储数字首次出现的位置
map<int,int> fir;  //存储数字第一次出现的位置 
struct num
{
    int val;
    int cnt;       //存储数字出现的次数 
} f[1005];
bool cmp(num a,num b)       //排序函数 
{
    if(a.cnt!=b.cnt) return a.cnt>b.cnt;
    else return fir[a.val]<fir[b.val];
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
    	cin>>a;
    	if(fir.count(a))   //如果此前已经出现过 
    	{
            f[fir[a]].cnt++;    //次数++ 
        }
        else
        {
            fir[a] = ++sum;    //出现的位置 
            f[sum] = {a,1};
        }
    }
    sort(f+1,f+1+sum,cmp);
    for(int i=1;i<=sum;i++)
    {
        while(f[i].cnt--) cout<<f[i].val<<" ";  //重复输出相同的数字 
    }
    cout<<endl;
    return 0;
}

---

## 作者：_JF_ (赞：2)

##  [COCI2009-2010#3] SORT 

[题目传送门](https://www.luogu.com.cn/problem/P7259)

我们考虑记录一个数出现了多少次，但是由于值域太大，于是我们换一个方法，表示下标为 $i$ 对应的这个数出现的次数为多少次，从当前这个数开始往后找，和它相等的话就加一，用 $s_i$ 来表示。

如果一个数出现了多次，我们开一个值域大小的布尔型数组 $vis$ 对这个数打标记。显然，按照第一段的统计方法，对于一个数来说，我从他第一次出现去统计所得的值，就是这个数在区间里面的数量就是正确的。如果后面有数和他相同，我们就不用统计了，不然会记录到其他的出现次数中去，会出错。

然后我们用 $maxx$ 表示出现次数最多的次数，从后往前枚举出现次数，同时我们从前往后扫一遍 $s$ 数组，如果当前的 $s_i$ 等于这个出现次数，就输出对应的 $a$ 数组中的值。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e9+10;
const int INF=1e6+10;
bool vis[N];
int a[INF],s[INF];
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
    int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int maxx=-INT_MAX;
	for(int i=1;i<=n;i++)
	{
		if(vis[a[i]]==true)
			continue;
		vis[a[i]]=true;
		s[i]=1;
		for(int j=i+1;j<=n;j++)
			if(a[j]==a[i])
				s[i]++;
		maxx=max(maxx,s[i]);	
	} 
	for(int i=maxx;i>=1;i--)
	{
		for(int j=1;j<=n;j++)
			if(s[j]==i)
			{
				for(int k=1;k<=i;k++)
					cout<<a[j]<<" ";
			}
	}
	return 0;
}

```


---

## 作者：追梦之鲸 (赞：2)

本蒟蒻的第$009$篇题解。

[经典回顾P7259](https://www.luogu.com.cn/problem/P7259)

# 前置芝士：

>## 1. map

其实map就是一个高级的数组，~~只不过听起来高大上而已~~

1. **定义**

``map<int,int> z``

这样就定义了一个下标类型为``int``，存储类型为``int``的数组$z$

然后我就可以这样

```c
z[1]=1

z[-1]=324

z[0]=z[-1]+z[1]

printf("%d",z[-1])
```

当然我们也可以这样写

``map<string,char> z``

这样就定义了一个下标类型为``string``，存储类型为``char``的数组$z$

然后我就可以这样

```c
z["I"]='a'

z["AK"]='b'

printf("%d",z["AK"])
```

当然``queue``、``double``、``map``、``struct``都行，这里我就不一一列举了

2. **一些基本操作**

```c
z.size()//求z数组里有多少数

z.clear()//清空z数组

z.empty()//询问z数组是否为空，是返回true

```

3. **``map``的优点和缺点：**

map的最大优势是：

1. 节省空间

2. 下表可为负数、字符串、小数

最大的缺点是：

1. 时间复杂度差（大约是$log_n$）

[**blog**](https://blog.csdn.net/sevenjoin/article/details/81943864)

>## 2. struct

这个……基础东西，不会就看下面的blog吧

[**blog**](https://www.cnblogs.com/zhengfa-af/p/8144786.html)


# 思路：

用``map``和``struct``存储第一个次出现的位置和出现的次数

然后排序输出


### code：
```c
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<map>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define ull unsigned long long
#define ll long long
#define rint register int
#define MAX 2147483647
//为了CSP,加油！
using namespace std;
struct qaq
{
	int x,y;//x存储次数，y存储第一个次出现的位置
};
map<int ,qaq > k;
bool cnp(int a,int b)
{
    if(k[a].x!=k[b].x)
        return k[a].x>k[b].x;
    return k[a].y<k[b].y;
}
//自己想一想为什么要这么写
int n,z[1010],C;

int main()
{
	scanf("%d%d",&n,&C);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&z[i]);
		k[z[i]].x++;
		if(k[z[i]].y==0)k[z[i]].y=i;
	}
	sort(z+1,z+1+n,cnp);
	for(int i=1;i<=n;i++)
	{
		printf("%d ",z[i]);
	}
	return 0;
}
```

最后管理大大求过&&[**来玩啊**](https://www.luogu.com.cn/user/361726)

---

## 作者：Wu_while (赞：1)

**[题目传送门](https://www.luogu.com.cn/problem/P7259)**

看到题目第一感觉是**桶排**，然而看到
$1≤C≤10^9$

嗯······~~就很NICE~~

$1≤N≤10^3$

然后就想到了**map**(不知道的可以看[这里](https://www.baidu.com/s?wd=c%2B%2Bmap&rsv_spt=1&rsv_iqid=0xe8f838570000087a&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=ib&rsv_sug3=5&rsv_sug1=5&rsv_sug7=100))

尝试使用$map$进行排序
~~然而无果~~

### 思考
对于这道题来说，$map$能做而普通数组不能做的就是存下数字的次数和出现位置。

而如果将其中一个存到$map$里，另一个存到普通数组里，然后将两者挂钩，就能通过对数组的排序来实现整体的排序。

# 上代码
#### （具体做法见注释）
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<algorithm>
using namespace std;
int n,c,tot;//tot存储目前不相同的数字的个数
int t;
struct st
{
	int num;//数字
   	//使用数字值来进行挂钩
	int sum=0;//出现次数
}
m[1010];
map<int,int> a;//map存储每个数字第一次出现的位置
bool cmp(st t,st u)//排序函数
//建议先看代码主体
{//注意如果map名用a的话形参就不能习惯性的用a了
	if(t.sum!=u.sum)
		return t.sum>u.sum;//先排出现次数
	return a[t.num]<a[u.num];//排出现位置
}
int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++)
	{
		cin>>t;
		if(a[t])//如果出现过这个数字
			m[a[t]].sum++;//出现次数加一
		else
		{
			a[t]=++tot;//总数量加一，存下位置
			m[tot].num=t;//存下数字
			m[tot].sum++;//加上次数
		}
	}
	sort(m+1,m+tot+1,cmp);//排序
	for(int i=1;i<=tot;i++)//输出
	{
		for(int j=1;j<=m[i].sum;j++)
			cout<<m[i].num<<' ';
	}
	return 0;
 } 
```

[AC 70分](https://www.luogu.com.cn/record/45633366)

---

## 作者：feicheng (赞：1)

# 离散化

这道题的数据范围启发我们，可以向离散化的方向思考。

尽管离散化在这题里显得有些小题大做，但是在线段树时是非常重要的一个工具。

在讲解本题代码之前，先介绍两个STL函数（熟知unique，lower_bound的大佬可以跳过此段）


------------


#### lower_bound

lower_bound的作用是在有序数组中查找第一个大于等于某元素的下标，查找不到返回尾指针。

用法是lower_bound(首指针,尾指针,要查找的值)。但是注意，这里返回的是迭代器，于是你还需要减去指针名（通俗理解就是减去数组的名字）

#### unique

unique的作用是给**有序数组**去重，返回不重复元素的个数（同样是迭代器，实际返回的是最后一个不重复元素的迭代器）

用法是 unique(首指针,尾指针)。大概了解了这两个函数的作用。就可以来看题了


------------
题意简述：给你一个数列，请你按照出现频率排序（如果频率一样就按照先出现的顺序排序）。输出数列

俗话说，看题先看数据范围：$1\le N\le10^3,1\le C\le10^9$。

我的做法是统计每一个数字出现的次数，然后比较（非常暴力）

但是 $C$ 的范围如此之大，我岂不是要开一个 $10^9$ 的数组？不不不，我们看看人畜无害的 
$N$ 的范围，顿时就想到了离散化。

所谓离散化，就是不关注数的大小，只关注数与数之间的大小关系。比如一个数列 1 4 200000 3 6，离散化之后就变成了1 3 5 2 4。

从这里就能看出为什么离散化好用了，我们想表示某些数的大小关系，只需要开一个跟数的个数等大的数组就可以了。多么方便！

那么，如何实现离散化呢？

这就要用到刚才说的**unique**和**lower_bound**了。

我们直接来看代码。因为我们不能改变原数，所以我们要建立一个新数组复制原数，保留信息。

解释都在代码里写了，这里就不多废话了。
```cpp
#include <bits/stdc++.h>
#define ri register int
typedef long long ll;
using namespace std;
const int N = 1e3 + 10;
struct node{
	int val,tim,num;
	friend bool operator < (node a,node b){
		return (a.tim==b.tim) ? a.num<b.num : a.tim>b.tim;
	}//重载运算符，先比较频率，再比较出现位置 
}a[N];//这个结构体存储了一开始的值val，每个值出现的频率tim，以及这个值第一次出现的位置num 
int t[N],q[N],f[N],r[N];//t数组保存原来的值，q数组保存离散化后的值 
//f代表频率，r代表出现顺序 
int n,c,cnt;//cnt记录出现顺序 
int main(int argc,const char *argv[]){
    ios::sync_with_stdio(false);
	cin>>n>>c;
	for(ri i=1;i<=n;++i) cin>>q[i],a[i].val=t[i]=q[i];
	sort(t+1,t+1+n);
	int m=unique(t+1,t+1+n)-t;//m就是不重复元素的个数，所有不重复的元素都在前m个里有序存放 
	for(ri i=1;i<=n;++i){
		q[i]=lower_bound(t+1,t+1+m,q[i])-t,f[q[i]]++;//离散化，用排名来压缩数的范围 
		r[q[i]]=(r[q[i]]==0)? ++cnt : r[q[i]];
	} 
	for(ri i=1;i<=n;++i) a[i].tim=f[q[i]],a[i].num=r[q[i]];
	sort(a+1,a+1+n);
	for(ri i=1;i<=n;++i) cout<<a[i].val<<" ";
	return 0;
}
```


---

## 作者：CGDGAD (赞：1)

P7259首A，发个题解纪念一下。

### 题目大意

给你个数列，要你按数的出现次数排列。出现次数最多的排在前面。

当两个数出现次数一样多时，这两个数中第一次出现得最早的，排在前面。

### 做法

开两个 `map`，一个记录数出现的次数，一个记录数第一次出现时的下标。

然后边输入边处理 `map`，输入完了以后 `sort` 一下然后输出即可。

`map` 就是功能类似字典的一个数据结构，这个不知道的话可以使用搜索引擎搜索。

### 代码

```cpp
#include <cstdio>
#include <map>
#include <algorithm>
int n, c, a[1001];
std::map<int, int> m; // 记录出现次数
std::map<int, int> m2; // 记录第一次出现的下标
bool compare(int a, int b) {
	if (m[a] == m[b]) { // 如果出现次数相同
		return m2[a] < m2[b]; // 按第一次出现的下标排序
	}
	return m[a] > m[b]; // 按出现次数排序
}

// 先看主程序
int main() {
	scanf("%d%d", &n, &c); // 注意c在这个程序里虽然没有用到，但还是得输入一下
	for (int i = 1; i <= n; i += 1) {
		scanf("%d", &a[i]);
		if (m.find(a[i]) == m.end()) { // 这个数第一次出现
			m2[a[i]] = i; // 记录下标
			m[a[i]] = 1;
		} else {
			m[a[i]] += 1; // 出现次数加一
		}
	}
	std::sort(a + 1, a + n + 1, compare); // 排序
	for (int i = 1; i <= n; i += 1) {
		printf("%d ", a[i]); // 输出
	}
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

思路为桶，记录每个数出现的次数以及它第一次出现的位置即可，然后排序输出即可。
## AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,a[1005];
map<int,int> sum,fir;//sum 记录次数，fir 记录第一次出现的位置
bool cmp(int a,int b){
	if(sum[a]==sum[b])
		return fir[a]<fir[b];
	return sum[a]>sum[b];
}//排序方式
signed main(){
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		++sum[a[i]];
		if(!fir[a[i]])
			fir[a[i]]=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)
		printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：TgyaSunie (赞：0)

### 题意简述

- 按照数字出现的**频数从大到小**，对数字进行排序，若有相同则**第一次出现的位置**靠前的排在前面。
- 输出时每个数字输出的次数与其频数相同。

~~好像并没有简化。~~

### 思路

一开始想桶排，但是根据 $C$ 的范围，开十亿的数组显然不可行。否定了桶排，这是 $C$ 唯一的作用，接下来的解题过程只能说跟 $C$ 毫无关系。

要存的东西好像有点多啊。频数、数字和第一次出现的位置都要存。而且之后还要**排序**，分成好几个数组来存储不便于排序。而给**结构体**排序就方便多了。所以用**结构体**存储这些信息。

- $cnt$ 表示频数
- $num$ 表示数字
- $st$ 表示第一次出现的位置

已经想好怎么储存信息了。那么，开始读入数据。

将原序列中的数依次读入。如果读入的数已经出现过，那么就将其对应 $cnt$ 加 $1$；如果没有出现过，就新开一个结构体，记录 $st$（当前位置）、$num$（读入的数）和 $cnt$（没有出现过，所以这是第一次出现，即 $cnt = 1$）。

数据都读入完毕了。接下来给储存的信息排序。

排序当然用sort ~~，你看题目都告诉我们了~~。但是我们要对结构体排序，结构体有多个变量，所以我们得告诉机器，要用什么标准进行排序。

回顾题意。得出对两个结构体的判断顺序前后的方法。

- 如果出现的频数 $cnt$ 相同，那么第一次出现的位置 $st$ 靠前的排在前面。
- **否则**，出现频数 $cnt$ 大的排在前面。

根据上文写下代码：
```cpp
bool cmp(node x, node y){
	if(x.cnt == y.cnt)
		return x.st < y.st;
	return x.cnt > y.cnt;
}
```

最后就是输出。按照排序后的顺序输出，每个数字输出的次数与频数相同。

### 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, c, a, fl, tot;
struct node{
	int num, cnt, st;
}t[1010];
bool cmp(node x, node y){
	if(x.cnt == y.cnt)
		return x.st < y.st;
	return x.cnt > y.cnt;
}//比较函数
int main()
{
	scanf("%d%d", &n, &c);
	for(int i = 1; i <= n; i ++)
	{
		scanf("%d", &a);
		fl = 0;//fl用来记录读入的数是否出现过
		for(int j = 1; j <= tot; j ++)
		{
			if(a == t[j].num)//读入的数已经出现过
			{
				t[j].cnt += 1;
				fl = 1;
				break;
			}
		}
		if(fl == 0)//读入的数没有出现过
		{
			t[++ tot].num = a;//tot用来记录目前结构体的数量
			t[tot].cnt = 1;
			t[tot].st = i;
		}
	}
	sort(t + 1, t + tot + 1, cmp);
	for(int i = 1; i <= tot; i ++)
		for(int j = 1; j <= t[i].cnt; j ++)
			printf("%d ", t[i].num);
	return 0;
}

---

## 作者：Iron_Heart (赞：0)

## 思路

结构体排序 + `map`。

用结构体存该数字的第一次出现位置，用 `map` 统计每个数字的出现次数。

之后按出现次数排序；如果出现次数相同，则按第一次出现位置排序。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

map<int, int> mp;
int n, c, a[1050];
struct number {
    int idx, val, num;
} nums[1050];

bool cmp(number a, number b) {
    if (a.num == b.num) {
        return a.idx < b.idx;
    }
    return a.num > b.num;
}

int main() {
    scanf("%d%d", &n, &c);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
        ++mp[a[i]];
    }
    for (int i = 0; i < n; ++i) {
        nums[i] = {0, a[i], mp[a[i]]};
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (a[j] == nums[i].val) {
                nums[i].idx = j;
                break;
            }
        }
    }
    sort(nums, nums + n, cmp);
    for (int i = 0; i < n; ++i) {
        printf("%d ", a[nums[i].idx]);
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：0)

## Content
请编写一个“频率排序器”。输入一个
长度为 $n$ 的数列 $A=\{a_1,a_2,\dots,a_n\}$，要求：

- 按照每个数的出现次数降序排列。
- 如果两个数出现次数相同，则谁在数列中出现的位置靠前，排列之后那个书的位置也是靠前的。

**数据范围：$n\in[1,10^3],1\leqslant a_i\leqslant c\leqslant10^9$。**
## Solution
我们开个 $\texttt{map}$ 数组 $vis$ 用来记录某个数是在数列中第几个出现的（如果某个数 $x$ 没出现则 $vis_x=0$），然后再开个结构体存储：

- 这个数的值。
- 这个数最先出现的位置。
- 这个数出现的次数。

边输入就边记录以上信息。但有个例外，如果这个数第一次出现，则在结构体中新开一个元素，记录当前位置为最先出现的位置，出现次数为 $1$，数的值为当前读入的数的值。

以上信息记录完以后我们就开始排序了，首先按照数的出现次数为第一关键字降序排列，如果次数相同，再按照最先出现的位置为第二关键字排序。排序完之后就可以输出了。
## Code
```cpp
struct node {
	int fi, ti, num;
	bool operator < (const node& tmp) const {
		if(ti != tmp.ti) return ti > tmp.ti;
		return fi < tmp.fi;
	}
}a[1007];
map<int, int> vis;
int n, c, cnt, x[1007];

int main() {
	n = Rint, c = Rint;
	F(i, 1, n) {
		x[i] = Rint;
		if(!vis[x[i]]) {
			a[++cnt] = (node){i, 1, x[i]};
			vis[x[i]] = cnt;
		} else a[vis[x[i]]].ti++;
	}
	sort(a + 1, a + cnt + 1);
	F(i, 1, cnt) F(j, 1, a[i].ti) printf("%d ", a[i].num);
	return 0;
}
```

---

## 作者：rickyxrc (赞：0)

这道题比较水，~~但是搞得我跟个傻子一样调了好久~~

题意(个人翻译，非官方)：
- 对于每个数$0$到$C$,都有一个出现次数$n_i$

现在需要你:

- 对数列进行排序
- 第一关键字:$n_i$
- 第二关键字:出现的位置$index$,越靠前越优先

如何存储？很显然是用结构体

```cpp
struct AK{
	int data;
	int n;
	int index;
}dt[1001];
```

接下来，我们要干什么？读入，把题目格式转化成上文格式,为达成这一点，我们需要一个```map<int,int>```进行处理

```cpp
map<int,int>mp=map<int,int>();
int n,tp,c;
cin>>n>>c; 
for(int i=1;i<=n;i++){
	cin>>tp;
	if(!mp[tp])
		tt++,
		mp[tp]=tt,
		dt[tt].data=tp,
		dt[tt].n++,
		dt[tt].index=i;
	else
		dt[mp[tp]].n++;	
}
```

接下来，我们对数列排序。
我们需要什么？
“第一关键字:$n_i$，第二关键字:出现的位置$index$,越靠前越优先”(上文已提及)

这里我们使用```STL```的```sort```,对数列进行排序，排序我们需要一个函数：

```cpp
inline bool cp1(AK i,AK j){
	if(i.n!=j.n)
		return i.n>j.n;
	return i.index>j.index;
}
```
双关键字排序，第一次打。 ~~两个大小于符号让我像个傻子似的调了半天~~

在主函数内：

```cpp
sort(dt+1,dt+n+1,cp1);
```

然后是最后的输出：

```cpp
for(int i=1;i<=tt;i++)
		for(int j=1;j<=dt[i].n;j++)
			cout<<dt[i].data<<" ";
```

然后我们就可以愉快的结束代码了。

```cpp
return 0;
```
AC代码，可以复制(复制完了我就不管你了)

chen_zhe & kkksc03 :你说什么?

```
#include<bits/stdc++.h>
using namespace std;
struct AK{
	int data;
	int n;
	int index;
}dt[1001];
int tt;
map<int,int>mp=map<int,int>();
inline bool cp1(AK i,AK j){
	if(i.n!=j.n)
		return i.n>j.n;
	return i.index>j.index;
}
int main(){
	int n,tp,c;
	cin>>n>>c; 
	for(int i=1;i<=n;i++){
		cin>>tp;
		if(!mp[tp])
			tt++,
			mp[tp]=tt,
			dt[tt].data=tp,
			dt[tt].n++,
			dt[tt].index=i;
		else
			dt[mp[tp]].n++;	
	}
	sort(dt+1,dt+n+1,cp1);
	for(int i=1;i<=tt;i++)
		for(int j=1;j<=dt[i].n;j++)
			cout<<dt[i].data<<" ";
	return 0;
}
```


---

## 作者：Argon_Cube (赞：0)

* **【题目链接】**

[Link:P7259](https://www.luogu.com.cn/problem/P7259)

* **【解题思路】**

本题大意：

_给你一个数列，要求把这个数列按出现次数从高到低排序，如果出现次数一样按输入次序排序。_

出现次数告诉我们使用```unordered_map```。

排序告诉我们用```map```。

现在，一个问题出现了：

一个数有三个属性（数值、出现次数、第一次出现的下标），但map只能存两个数。

很简单，把出现次数和第一次出现的下标用```pair```结合起来。

这样，声明似乎应该是这样：

```cpp
map<int,pair<int,int>> nums;
```

但是实际上```map```是按键值排序的，而此处要按出现次数和第一次出现的下标排序，所以声明应该是这样：

```cpp
map<pair<int,int>,int> nums;
```

但是，在实现中，```map```没法按值查找，也就不能增加某个值的出现次数。

那么，就只能按第一种声明方法读入，然后处理成第二种了。

* **【实现细节】**

由于输入时的```map```无需排序，所以可以改成```unordered_map```。

由于```pair```的比较是先比```first```，如果相等再比```second```，所以应该把出现次数放在第一，把出现下标放在第二。

另外，```map```是从小到大排序，而出现次数是从大到小排，可以把出现次数变成负数。

为什么不用```greater<pair<int,int>>```呢？因为，出现下标是从小到大排的，不能用```greater```。

* **【实现代码】**

```cpp
#include <unordered_map>
#include <iostream>
#include <map>

using namespace std;

int main(int argc,char *argv[],char *envp[])
{
	unordered_map<int,pair<int,int>> srtnum;//存储输入
	int cntnum,tmp;
	cin>>cntnum>>tmp;
	for(int i=0;i<cntnum;i++)
	{
		cin>>tmp;
		if(srtnum.find(tmp)!=srtnum.end())
			srtnum[tmp].first++;//把这个数的出现频率递增
		else
			srtnum[tmp].first++,srtnum[tmp].second=i;//如果这个数第一次出现，把这个数的第一次出现下标设置好
	}
	map<pair<int,int>,int> nums;//存储结果
	for(const auto& val:srtnum)
		nums[make_pair(-/*注意这个负号！*/val.second.first,val.second.second)]=val.first;
	for(const auto& val:nums)
	{
		tmp=-/*这个负号把出现频率恢复成正数*/val.first.first;
		while(tmp--)
			cout<<val.second<<' ';
	}
 	return 0;
}

```

---


# [传智杯 #3 决赛] 商店

## 题目背景

disangan333 想给 disangan233 买一个礼物，于是他和你一起逛商店。

## 题目描述

有 $n$ 名同学去逛商店，店里有 $m$ 个物品，第 $i$ 人有 $w_i$ 块钱，第 $i$ 个物品价格 $c_i$ 元。

每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

对于所有数据，$n,m \leq 10^5$，$w_i,c_i\leq 10^9$。

## 样例 #1

### 输入

```
15 20
4 3 9 10 7 7 5 3 6 1 8 6 6 1 5 
12 4 1 9 8 5 8 6 4 5 18 8 14 9 9 7 20 11 8 19 ```

### 输出

```
10```

# 题解

## 作者：Double_Light (赞：8)

一道简单的橙题

思路很简单，贪心+排序。

我们令 $m$ 件商品和 $n$ 名同学依次按价格和财力进行排序，让同学们依次来选购商品，如果买的走，就买走它，再接着卖下一件商品；如果钱不够，则让下一个人来选购。

用两个变量分别指向轮到第几个人买和该卖第几样东西，再输出有几个人买到了东西即可。

不多说了，代码里有注释：

```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,m,a[100005],b[100005],cnt,zz1=1,zz2=1;//zz1,zz2分别指向轮到第几个人买东西和该卖第几样东西
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	sort(a+1,a+n+1);//对人们的钱数排序 
	sort(b+1,b+m+1);//对商品的价格排序 
	while(zz1<=n&&zz2<=m){//还有人没开始买且商品还没卖完
		if(a[zz1]>=b[zz2]){//买的起 
			cnt++;//多了一个买得起商品的人
			zz1++;//下一个人来买 
			zz2++;//卖下一件商品 
		}
		else zz1++;//买不起就下一个人来买 
	}
	cout<<cnt; 
	return 0;
}
```

  $$\mathbb{---END---} $$

---

## 作者：WA_sir (赞：5)

## [题目链接](https://www.luogu.com.cn/problem/P8837)

一道非常明显的贪心题。

由于输入数据非常多，我们不好直接得出最优解。但由于题目性质，**一件物品可以分给多个人时，分给钱最少的那个人一定是最优解。**

为什么呢？这里我举个例子：

假设一个物品价值为 $5$ 元，有三个人来买这个物品。其中 $a$ 有 $3$ 元， $b$ 有 $10$ 元， $c$ 有 $200$ 元。$a$ 的钱不够，首先排除。而在 $b$ 和 $c$ 之中，$b$ 的钱较少。为了让更多人买到物品，只有让 $b$ 购买这个物品，才是最优解。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],w=1,ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=m;i++)scanf("%d",b+i);
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	for(int p=1;p<=n;p++)
	{
		if(w>m)break;
		if(a[p]<b[w])continue;
		w++;
		ans++;
	}
	printf("%d",ans);
	return 0;
}
```
感谢阅读！(\*^▽^\*)

---

## 作者：Adolfo_North (赞：4)

#### 贪心+排序。

思路：在输入后，将 $w_i,c_i$ 都排序一遍，之后扫一遍 $w_i$ 数组，看看该人的钱够不够。

- 若够了，就可以保证不存在既比该人钱数少，又可以购买该商品的人，计数器加加即可。

- 若不够，直接舍弃该人。

###### 代码如下
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100001],b[100001];
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){ if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
//因为数据有10^5所以用了快读 
int main(){
	int n=read(),m=read(),cnt=0;
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=m;i++){
		b[i]=read();
	}
	sort(a+1,a+1+n);//快排函数
	sort(b+1,b+1+m);
	int j=1;
	for(int i=1;i<=n&&j<=m;i++){
		if(a[i]>=b[j]){
			j++;
			cnt++;
		}
	}
	/*
	注意 ：
	&&j<=m这个判断条件与 
	if(j>m) break;等价 
	*/
	cout<<cnt<<endl;
	return 0;
} 
```


---

## 作者：李卓衡001 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8837)

思路：
-

一道简单的贪心题。

先将人的钱数和物品的价钱从小到大排一遍序，再从头开始，能买的就买，不能买的就下一个，再用一个计数的变量在能买的时候统计一下，最后输出就可以了。

满分代码：
-
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+10;
int n,m,cnt=0,top=0,a[maxn],b[maxn];//a[i]表示第i个人带的钱数，b[i]表示第i件物品的价钱。
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d",&b[i]);
	sort(a+1,a+n+1); sort(b+1,b+m+1);
	for(int i=1;i<=n;i++){
		if(a[i]>=b[top+1]){
			cnt++; top++;//可以买，cnt（表示能买的人）++，top（表示第top件物品）++。
		}
	}
	cout<<cnt<<endl;
	return 0;
}
```


---

## 作者：lilong (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8837)

#### 分析

既然要使得购买到商品的人最多，很容易想到要用贪心的策略。对于拥有的钱越少的人，就应当给 ta 匹配越便宜的商品。可以证明这种方案能使人数最大化。

接下来看具体的方法。首先将 $w_i$ 和 $c_i$ 从小到大排序（$w_i$ 和 $c_i$ 的含义如题目中所述），接着，将 $w_1$ 与 $c_1$ 比较，看是否能买下，如果能买则买，不能买则将 $c_1$ 推给下一个人。以此类推，直到最后一个人比较结束。

这样做的思想是将便宜的给钱少的人，如果买不起则给后面的人，就是“少钱买低价，多钱买高价”，可以保证最多的人买到东西。

#### Code

具体代码实现如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,w[1000001],c[1000001],ans,k;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		w[i]=read();
	for(int i=1;i<=m;i++)
		c[i]=read();
	sort(w+1,w+n+1);
	sort(c+1,c+m+1);
	k=1;//k 代表当前最便宜的商品的位置（排序后）
	for(int i=1;i<=n;i++)
		if(w[i]>=c[k])
			ans++,k++;
	cout<<ans;
	return 0;
}
```


---

## 作者：HarryKane (赞：0)

## 思路分析
本题是入门贪心题。

我们只需要把数组 $a$ 和数组 $b$ 从小到大排序，然后枚举 $b$ 数组，用尽可能小的数组 $a$ 中的数去买东西。

## Ac Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5;
int a[N+5], b[N+5];

int main (){
    int n, m; cin >> n >> m;
    for (int i=1; i<=n; i++) scanf ("%d", &a[i]);
    for (int i=1; i<=m; i++) scanf ("%d", &b[i]);
    sort (a+1, a+n+1); sort (b+1, b+m+1); //从小到大排序。
    int j=1, ans=0; 
    for (int i=1; i<=n && j<=m; i++){
        if (a[i]>=b[j]){ //找到第一个合适的。
            ans++; j++;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：fengziyi (赞：0)

### 主要思想
萌新贪心入手题。  
> 每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。  

显然要挑便宜的买。  
先对 $w_i$ 和 $c_i$ 排序，考虑一样商品第 $i$ 人买不了，那就留给第 $i+1$ 人买。  
写出以下代码片段：

```cpp
now = 1; ans = 0;
for (reg int i = 1; i <= n; i++)
{
    if (w[i] >= c[now])
    {
        ans++;
        now++;
    }
}
return ans;
```

观察到变量 `ans` 更新和 `now` 是同步的，所以可以优化~~多达~~ `4Byte` 内存。
具体代码如下。
### 贴个代码
```cpp
#include <iostream>

#include <algorithm>

#define longint long long
#define reg register
#define qwq puts("fzy qwq ~");
#define endl '\n'
#define space ' '

using namespace std;

int n, m, now;
int w[114514];
int c[114514];

int main()
{
    scanf("%d%d", &n, &m);
    for (reg int i = 1; i <= n; i++)
        scanf("%d", &w[i]);
    for (reg int i = 1; i <= m; i++)
        scanf("%d", &c[i]);
    
    sort(w + 1, w + n + 1);
    sort(c + 1, c + m + 1);

    // w, c数组已经排好
    now = 1;
    for (reg int i = 1; i <= n; i++)
    {
        if (w[i] >= c[now])
            now++;
    }
    cout << now - 1 << endl;
    return 0;
}
```
珍惜生命，不要抄题解。

---

## 作者：AKPC (赞：0)

### 思路
贪心题，简单。  

首先将 $w,c$ 数组分别从小到大排序，从最小的开始，能卖的最少的先买，如果能买就买掉，反之就让下一个人去买，以此类推。

这样可以让买到的东西最多，利益最大化。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,w[1000001],c[1000001],ans,tip=1;
signed main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++) cin>>w[i];
    for (int i=1;i<=m;i++) cin>>c[i];
    sort(w+1,w+n+1),sort(c+1,c+m+1);
    for(int i=1;i<=n;i++) if(w[i]>=c[tip]) ans++,tip++;
    //tip表示当前未买下的商品中最便宜的那一个在排序后的位置。也就是一个指针。
    cout<<ans;
    return 0;
}
```

---

## 作者：lwx20211103 (赞：0)

## 分析
这题是贪心法，贪法是这样的。

首先把每个人拥有的钱和商品的价值从小到大排序，保证两者单调递增，因为每个人只能买一件且买完就行，所以我们得对它们两两比较。

当然，不能排序后直接一对一比较，样例过不去，所以，我们模拟可以两个指针。$i$ 和 $j$ 初始值为 $1$。先从第 $1$ 个购物者和商品进行对比，如果满足条件，即 $c[i] \leq w[i]$，指针 $i$ 和 $j$ 都自增 $1$，轮到下一个购买者，同时商品已经买完，轮到下一个更贵的。如果不满足，指针 $i$ 自增 $1$，就是轮到下一行购买力更大的消费者。

## 代码

不难实现。
```cpp
#include<bits/stdc++.h>
using namespace std;

int w[114514], c[114514];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n, m, ans = 0;
	cin >> n >> m;
	int i = 0, j = 0;
	for (i = 0; i < n; i++)
	{
		cin >> w[i];
	}
	for (i = 0; i < m; i++)
	{
		cin >> c[i];
	}
	sort(w, w + n);
	sort(c, c + m);
	for (i = 0, j = 0; i < n; i++)
	{
		if (i[w] >= j[c])
		{
			ans++;
			j++;
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：icaijy (赞：0)

~~看到没有题解，当个好人。~~

# 思路
这题题意写的已经很清晰了，就不简述了。这题的做法是**贪心**。要让更多的人买到东西，那么就让**钱少的人买便宜的，钱多的买贵的**。因为假如让钱多的买便宜的，那么钱少的人就买不了了，结果就会变小。

# 具体做法+代码
先把人的钱和物品的钱**从小到大排序**。然后从一个**线性查找**，从钱最少的人开始依次买他能买到最便宜的商品，然后下一个人。具体怎么实现看代码就行了。

时间复杂度为 $O(n\log n)$，能过这个范围。
```cpp
#include <bits/stdc++.h>
using namespace std;

int ren[100005];
int dongxi[100005];

int main(){
	int n,m,ans=0;
	cin >> n >> m;
	for (int i=0;i<n;i++) scanf("%d",&ren[i]);
	for (int i=0;i<m;i++) scanf("%d",&dongxi[i]);
   // 读入没啥说的
	sort(ren,ren+n);
	sort(dongxi,dongxi+m);//用stl对它们排序。
	int i=0; // i 是当前的人
	for (int j=0;j<m;j++){//线性查找商品，商品没了就结束。
		if (i==n) break;//人到头了结束
		if (ren[i]>=dongxi[j]) ans++,i++;
		else i++,j--;//如果当前人找不到了就下一个人。
      //因为下一轮j会加一，但这里还是保留当前商品，就减回去。
	}
	cout << ans; // 输出
}
```

结束。


---

## 作者：VitrelosTia (赞：0)

题链：[P8837 [传智杯 #3 决赛] 商店](https://www.luogu.com.cn/problem/P8837)

### 题意
$n$ 个人都有一定的钱，每个人只能买一件商品，求在 $m$ 件商品中最多能买多少件。

### 思路
考虑贪心策略，显然我们要让当前钱最少的人去尽可能买最便宜的物品。

实现这个目的需要将人按钱从少到多排序，物品从便宜到贵排序。排序后看人，假如这个人能够买到最便宜的商品，就买下，并且拿走最便宜的，否则看下一件商品。

容易想到用队列模拟商品，假如被买下就出队，而当前最便宜的商品就是队头。

### code
```
#include<bits/stdc++.h>
using namespace std;
queue<int> q;
const int N=100000;
int n,m,cnt;
int a[N+5],b[N+5];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=m;i++) cin>>b[i];
    sort(a+1,a+n+1);//将人按钱从少到多排序
    sort(b+1,b+n+1);//将物品从便宜到贵排序
    for(int i=1;i<=m;i++) q.push(b[i]);//将商品价格入队
    for(int i=1;i<=n;i++){
        if(a[i]>=q.front()){//如果能买下最便宜的
            cnt++;//计数器加一
            q.pop();//出队
        }
    }
    cout<<cnt<<endl;
}
```


---

## 作者：pxb0801 (赞：0)

## 1.分析：

这道题其实是一道经典的贪心题，我们来一起分析一下。

首先，既然是一一配对，我们当然希望钱最多的人买最贵的物品，当然前提是他能买得起，这样钱少一些的人就可以买到便宜的了。

所以很明显，我们用 $a[]$ 表示每个人有的钱，用 $b[]$ 表示每个物品的价格。将两个数组进行从大到小排序，再定义变量 $i$ 和 $j$ 分别遍历 $a$ 数组和 $b$ 数组。对于每一个 $a_i$，只要 $j≤m \land a_i≥b_j$，$ans$ 就加 $1$。如果 $j$ 等于 $m$ 就直接退出。时间复杂度 $O(n)$。

-------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],ans;
bool cmp(int x,int y){
	return x>y;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=m;i++){
		scanf("%d",&b[i]);
	}
	sort(a+1,a+n+1,cmp);//从大到小排序
	sort(b+1,b+m+1,cmp);
	for(int i=1,j=1;i<=n&&j<=m;i++){//两个条件
		while(j<=m&&a[i]<b[j]){//时刻判断j是否小于等于m
			j++;
		}
		if(j<=m){
			ans++;//符合要求ans++
			j++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：RP_INT_MAX (赞：0)

## 前言

[题目传送门](https://www.luogu.com.cn/problem/P8837)

~~沙发题解，水一波咕值~~ 在阅读本篇题解之前，请确保你已经熟悉以下算法、数据结构：

- 贪心算法
- 排序算法及 `sort` 函数
- 堆及优先队列 `priority_queue` 的使用

## 解题思路

这是一道较好的贪心题。我们来分析贪心策略。

> 每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

考虑将客户和商品一一匹配。题目中要求最大化买到商品的客户人数，所以不难得出，我们应该每次取**最小的** $w$ 和**最大的** $c$ 进行匹配。因为，如果我们不是按这种策略贪心的话，若最小的 $w$ 都能和最大的 $c$ 匹配，我们将得不到最优解。

先将 `w` 数组升序排序，定义游标 $i=1\sim n$ 来对每一个 $w_i$ 进行检查，接着采用大根堆（代码中使用优先队列），将 `c` 数组存入堆中，每次取堆顶（即 `c` 数组当前的最大值，记为 $top$），检查是否满足 $w_i \ge top$，若是，则答案加一，同时将 $top$ 自堆中去除。否则，直接跳过，进行下一轮循环。

## 参考代码

代码中加了注释，读到这里不懂的可以再看看。但是，不要直接复制。

```cpp
//以上省略头文件以及快读部分 
const int N=100010;
int n,m,ans;
int a[N],b[N];
priority_queue<int,vector<int>,greater<int>> q;
/*
	n,m 如题意所述 
	a,b 数组分别表示题目中的 w,c 
	q 即为上文所述的堆 
*/
int main () {
	in(n),in(m);
	for(int i=1;i<=n;++i)
		in(a[i]);
	for(int i=1;i<=m;++i)
		in(b[i]),q.push(b[i]); //将 b 数组入堆 
	sort(a+1,a+1+n); //a 数组升序排序，sort 函数默认升序 
	for(int i=1;i<=n;++i) //如上文所述，进行检查 
		if(a[i]>=q.top()) { //若可以配对 
			++ans; //更新答案 
			q.pop(); //弹出 b 数组中当前的最大值 
		}
	printf("%d\n",ans);
	return 0;
}
```

---


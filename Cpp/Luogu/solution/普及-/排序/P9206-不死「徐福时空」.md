# 不死「徐福时空」

## 题目背景

徐福是秦朝齐地方士。

奉秦皇之命，徐福率三千童男童女踏上了寻找传说中的「蓬莱之药」的征途。但最后再也没有回来。

徐福最终去了哪里？有没有找到蓬莱之药？这些问题已经无关紧要了。

## 题目描述

时间的流逝可以抽象成对数字序列进行排序所花费的时间。不同排序策略花费的时间是不同的。这里介绍一种人类探索排序过程中具有里程碑意义的一种排序算法：希尔排序。

希尔排序可以被视为一种对插入排序的优化。为了研究希尔排序的运行效率，我们希望你实现一个简单的希尔排序的过程。在这之前，我们会规范插入排序的具体流程以及评价一个插入排序的过程的「代价」。

### 插入排序

对于一个长度为 $n$ 的数组 $a=[a_1,a_2,\cdots,a_n]$，插入排序的思想是，从前到后枚举每一个元素，将其插入到正确的位置上去：

![](https://cdn.luogu.com.cn/upload/image_hosting/bzr46ykp.png)

如图所示是一个典型的插入排序的过程。在第 $i$ 轮中我们把下标为 $i$ 的元素插入到了**排好序的部分中第一个比 $\bm{a_i}$ 大的元素之前**。假设 $a_i$ 最终被插入到了 $b_i$ 位置，那么我们称这一轮的代价为 $|a_i-b_i|+1$，整个插入排序的过程的代价就是每一轮的代价之和。

### 希尔排序

为了减小插入排序的代价，我们引入了希尔排序。希尔排序将整个排序过程分成了若干轮，每一轮会按照一定的间隔把元素分组，对每一组内的元素分别进行排序。在最后一轮，希尔排序会对整个数组进行一次最终的插入排序。

具体的分组方式是，选定一个整数 $d$，划分为如下组别：

- 下标为 $1,1+d,1+2d,\cdots$ 的元素；
- 下标为 $2,2+d,2+2d,\cdots$ 的元素；
- 下标为 $3,3+d,3+2d,\cdots$ 的元素；
- ……
- 下标为 $d,2d,3d,\cdots$ 的元素。

下面是**一轮**希尔排序的过程。我们选定 $d=3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ladynhmo.png)

希尔排序每一轮分别选取 $d$，并且在最后一轮取 $d=1$，每一轮都进行这样的排序，最终得到一个有序的数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/msa25yb1.png)

虽然看上去进行了很多轮插入排序，但是最终每一轮插入排序的代价之和可能会远小于对整个数组进行单次插入排序的代价（上述例子中体现得并不明显，可以参考样例 $2,3$ 给出的例子）。

事实上，希尔排序是人类发现的第一个最坏复杂度低于 $\Theta (n^2)$ 的排序算法。例如，当取 $d=2^k-1,\ k=\lfloor\log_2 n\rfloor,\lfloor\log_2 n\rfloor-1,\lfloor\log_2 n\rfloor-2,\cdots,1$ 时，整个过程的最坏时间复杂度为 $\mathcal \Theta(n^{3/2})$。

## 说明/提示

### 数据范围及约定

对于全部数据，保证 $1\le n\le 10^5$，$1\le m\le 100$，$\mathrm{cost}\le 5\times 10^7$，$1\le a_i\le 10^9$，$1\le d_i\le n$，$d_m=1$。

## 样例 #1

### 输入

```
10 1
3 2 6 4 1 1 3 8 7 3
1
```

### 输出

```
27
1 1 2 3 3 3 4 6 7 8 
```

## 样例 #2

### 输入

```
15 1
15 14 13 12 10 11 9 8 7 4 5 6 3 2 1
1
```

### 输出

```
116
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

## 样例 #3

### 输入

```
15 3
15 14 13 12 10 11 9 8 7 4 5 6 3 2 1      
9 3 1```

### 输出

```
68
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

# 题解

## 作者：Night_sea_64 (赞：5)

此题是个简单模拟题。通过 $\text{cost}\le 5\times 10^7$ 可以看出不需要优化。

首先插入排序的代码是这样的（来自 [P7910](https://www.luogu.com.cn/problem/P7910)）：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这里是跟前面一个值作比较然后交换，类比到希尔排序之后，就是跟当前元素前面的第 $d$ 个值作比较然后交换。整个代码就是这样的了：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[100010];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int cnt=0;
    for(int i=1;i<=m;i++)
    {
        int d;
        scanf("%d",&d);
        for(int i=1;i<=n;i++)
        {
            cnt++;
            int now=i;
            while(now>d)
            {
                if(a[now]<a[now-d])
                {
                    swap(a[now],a[now-d]);
                    now-=d,cnt++;
                }
                else break;
            }
        }
    }
    printf("%d\n",cnt);
    for(int i=1;i<=n;i++)
        printf("%d ",a[i]);
    return 0;
}
```

---

## 作者：fkcufk (赞：3)


[题目传送门](https://www.luogu.com.cn/problem/P9206)

解析：

一道模拟题。

我们用希尔排序模拟一下即可。

如果 $i$ 大于 $a_i$，那么交换。否则退出循环。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005]={};
int n,m;
int ans=0;
int mian(){
#if 0
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		int k;
		cin>>k;
		for(int j=1;j<=n;j++){
			ans++;
			int t=j;
			while(t>k){
				if(a[t]<a[t-k]){
					swap(a[t],a[t-k]);
					t-=k;
					ans++;
				}
				else break;
			}
		}
	}
	cout<<ans<<"\n";
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	return 0;
}
```


---

## 作者：FSHYLHX (赞：1)

# 题目大意
将一个数组进行希尔排序后，求交换的价值和最终的序列。
# 思路分析
不难发现，这道题的数据并不算大，且可以保证希尔排序的时间复杂度，则直接选择进行大模拟。
# 补充希尔排序
将数组每几个分成一组，将每一组中序号相同的数进行插入排序。
# 代码实现
```c
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,ans,sum;
int a[100005];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++) scanf("%d",&a[i]);
    while(m--){
        scanf("%d",&k);
        for(int i=1; i<=n; i++){
            ans++;
            sum = i;
            while(sum > k){
                if(a[sum] < a[sum-k]){
                    swap(a[sum], a[sum-k]);
                    ans++;
                    sum -= k;
                }
                else break;
            }
        }
    }
    printf("%d\n", ans);
    for(int i=1; i<=n; i++) printf("%d ", a[i]);
    return 0;
} 
```


---

## 作者：_Emperorpenguin_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/solution/P9206)

## 思路

一道简单的模拟题，甚至不需要优化。

所以，根据题意，直接进行希尔排序即可。

#### 插入排序：
将当前的数和前面（已完成排序）的每一个数比较，如果比前面的某数大，那么就与其交换。

#### 希尔排序
将当前数字和往前面数的每 $d$ 个数字进行比较，如果比前面的某数大，那么就与其交换。

由于 $d$ 当且仅当在最后一次排序是为 $1$，所以它的时间复杂度比普通的插入排序更优。


## Code

```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(2)
using namespace std;

int n,m;
int a[100005];
int d,y;
int cost;

signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++)//元素个数 
		cin>>a[i];
	while(m--){//排序次数 
		cin>>d;
		for(int i=1;i<=n;i++){//模拟排序 
			cost++;
			y=i;
			while(y>d)
				if(a[y]<a[y-d]){
					swap(a[y],a[y-d]);
					y-=d;
					cost++;
				}else 
					break;
		}
	}
	cout<<cost<<endl;
	for(int i=1;i<=n;i++) 
		cout<<a[i]<<" ";
	return 0;
}
/*

*/
```



---

## 作者：Peiyuan (赞：1)

[P9206 原题](https://www.luogu.com.cn/problem/P9206)

### 思路

这道题我们按照题意模拟即可。

我们会重复这样的操作：设当前下标为 $t$；如果 $a_t<a_{t-d}$，则交换 $a_t$ 和 $a_{t-d}$，否则退出循环。

### 代码

```cpp
#include<iostream>
using namespace std;

int a[100005],n,m,d,ans,t;
int main(){
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    for(int i=1; i<=m; i++){
        cin>>d;
        for(int j=1; j<=n; j++){
            ans++,t=j; //用临时变量t存储j的值，因为我们不能直接用j来模拟过程。 
            while(t>d && a[t]<a[t-d]){ //第一个：因为有减法，所以要额外判断一下，以免出现负数。
                swap(a[t],a[t-d]);
                t-=d,ans++;
            }
        }
    }
    cout<<ans<<endl;
    for(int i=1; i<=n; i++) cout<<a[i]<<" ";
    return 0;
}
```


---

## 作者：nynkqh_yzp (赞：1)

首先，$cost \leq 5 \times 10^7$，所以直接按照题目要求，类比希尔排序模拟及可。
代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100001],b[100001],ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		for(int j=1;j<=n;j++){
			ans++;
			int s=a[j];
			for(int k=1;k*x<=j;k++)
				if(a[j-k*x]>s)
					a[j-k*x+x]=a[j-k*x],a[j-k*x]=s,ans++;
				else
					break;
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
		printf("%d ",a[i]);
	return 0; 
}

```


---

## 作者：zhuweiqi (赞：1)

### 前置知识：插入排序

插入排序是一种 $O(n^2)$ 级别的稳定的排序算法，具体操作步骤是：排序时，一个数一个数的进行判断，我们需要找到比当前数大的最靠后的位置，并从那个位置开始后面所有的数都往后移动一个位置，这样腾出来一个位置后再把当前这个数插入进去，具体代码实现如下：

```cpp
void msort(int n){
	for(int i=2;i<=n;i++){
		int t=a[i],j=i-1;
		while(j>=1 && a[j]>t){
			a[j+1]=a[j];
			j--;
		}
		a[j+1]=t;
	}
}
```

### 核心部分：希尔排序

题目中会进行 $m$ 次排序，每次排序给定参数 $d$，我们需要把原数组分为 $d$ 组，每组内的数的下标 $\bmod$ $d$ 的值相同，我们需要分别对这 $d$ 组进行插入排序，那么我们只需要解决如何分组的问题就可以了，显然，这 $d$ 个组不能存在不同的数组里面，这样太浪费空间了，我们每次只排序一组内的数，一共排 $d$ 次，每次选取一个 $i$ 的值，让下标为 $i$，$i+d$，$i+2d$，$\cdots$ 的所有元素统统放进另外一个数组进行插入排序，排好序再按顺序放进原数组下标为 $i$，$i+d$，$i+2d$，$\cdots$ 的位置。其中对于每次插入排序价值的计算，我们只需要加两步就可以了，由于第 $1$ 个数进行插入排序的价值为 $1$，所以每次进行插入排序的时候 $ans$ 都需要 $+1$，从第 $2$ 个数开始的插入排序的价值就是 $\left|j+1-i\right|+1$，因为我插进去的位置 $j+1$。

### 完整 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n;
}
int a[100002],d[102],b[100002];
int ans=0;
void msort(int n){
	ans++;
	for(int i=2;i<=n;i++){
		int t=b[i],j=i-1;
		while(j>=1 && b[j]>t){
			b[j+1]=b[j];
			j--;
		}
		b[j+1]=t;
		ans+=abs(j+1-i)+1;
	}
}
int main(){
	int n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++){
		d[i]=read();
		for(int j=1;j<=d[i];j++){
			int cnt=0;
			for(int k=j;k<=n;k+=d[i]) b[++cnt]=a[k];
			msort(cnt);
			for(int k=j;k<=n;k+=d[i]) a[k]=b[(k-1)/d[i]+1];
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：darkness_max (赞：0)

# 洛谷P9206
## 原文：[link]( https://www.luogu.com.cn/problem/P9206)
###  题目所用思想：插入排序，不会的看这里：[here](https://oi-wiki.org/basic/insertion-sort/)
其实这个题就是个纯模拟，插入排序怎么做题目给的很清楚。

良心好评。


做法：插入排序，模拟，对于每一个 $i$，若 $i$ $>$ $a_i$ 便交换，否则退出。


具体内容上边题解亦有说法，不再赘述，只是要注意范围，数组别开小了。$cost<50000000$。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],cost=0,d[105],pos; 
int read()//快读模板，可以去。
{
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=m;i++)
		d[i]=read();//输入。
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++,cost++)
		{
                 pos=j;
	          while(pos>d[i]){
			if(a[pos]<a[pos-d[i]])//如果位置在后的反而小。
			{
                        swap(a[pos],a[pos-d[i]]);//交换
                        cost++;//增加代价
                        pos=pos-d[i];//换到大的一方的位置。
                        continue;
                	}
                break;
			}
		}
	}
	cout<<cost<<endl;
	for(int i=1;i<=n;i++)
		cout<<a[i]<<' ';//输出。
	puts("");//可省略,输出换行。
	return 0;
}
```

---

## 作者：EntimE (赞：0)

## 前置芝士：插入排序
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。打过扑克牌的应该都会明白。

### 基本思想
 
插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描。找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 前置另一个芝士：希尔排序
希尔排序的实质就是分组插入排，该方法又称递减增量排序算法。希尔排序是非稳定的排序算法。

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

### 基本思想
先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

## 题目分析
在了解上面2个芝士后，我们就可以正式开始做题了。看数据可得 $cost \le 5 \times 10^7$，所以用希尔排序模拟就行了。

如果 $i>a_i$ 就交换，不然就退出循环。

代码就不贴了qwq



---

## 作者：dengqingrui123 (赞：0)

# SETP 0 插入排序
代码如下：
```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

# SETP 1 题目分析
本题~~比较水~~是一道模拟题（感觉说了跟没说一样）

注意本题  $\mathrm{cost}\le 5\times 10^7$  所以嘛...连优化都不用！！！

所以本题只要取前面一个值比较然后交换，类比到题目中的希尔排序之后，其实是跟元素前面的第 $d$ 个值作比较然后交换，最后输出即可。

# SETP 2 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a[100005], ans, d, Set;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++)	scanf("%d",&a[i]);
	for(int i = 1; i <= m; i++)
	{
		scanf("%d",&d);
		for(int i = 1; i <= n; i++)
		{
			ans++;
			Set = i;
			while(Set > d)
			{
				if(a[Set] >= a[Set - d]) break;//摆好后退出循环
				else//如果比较小，那么交换
				{
					swap(a[Set], a[Set-d]);
					Set = Set - d;
					ans++;
				}
			}
		}
	}
	printf("%d\n",ans);
	for(int i = 1; i <= n; i++)	printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

定义变量 $ans$ 表示希尔排序过程的代价，初始值为 $0$。

直接模拟希尔排序的过程，在每个数插入的过程中，每进行一次比较 $ans$ 加 $1$。如果插入到了子序列的第 $1$ 个位置，$ans$ 再加 $1$。

排序过程模拟结束，$ans$ 的值就是插入排序的代价。

2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    int a[100005];
    int n,m;
    scanf("%d%d",&n,&m);
    int i,j,k;
    for (i=0; i<n;i++)
        scanf("%d",&a[i]);
    int ans=0;
    while (m--)
    {
        int d;
        scanf("%d",&d);
        for (k=0;k<d;k++)       // 分成 d 组进行插入排序
        {
            ans++;              // 序列的第1个位置的数无需插入，但代价为 1  
            for (i=k+d;i<n;i+=d)
            {
                int t=a[i];
                for (j=i-d;j>=0;j-=d)
                {
                    ans++;
                    if (a[j]>t) a[j+d]=a[j];
                    else break;
                }
                if (j<0) ans++;  // 移动到了序列的第1个位置
                a[j+d]=t;
            }
        }
    }
    printf("%d\n",ans);
    for (i=0;i<n;i++)
        printf("%d ",a[i]);
    printf("\n");
    return 0;
}

```


---


# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# 题解

## 作者：阮行止 (赞：21)

简化题意：给定一个整数集合，寻找子集使异或和最大。

本题 $n\leq 21$，可以暴力枚举子集。$k\leq 60$，可以采用 unsigned long long 来存储二进制位（不必开 bool 数组）。

细节：

- 读入每个人的能力时，应该用 `p[i] |= (1ULL << (k - x))` 来标记 $i$ 人士拥有 $x$ 能力。需要注意这个 ULL，如果不加，编译器将其视为 int 型的 1，程序会 WA。


枚举子集有多种方式。我们下面的代码采用了递归枚举，但也可以使用二进制技巧枚举子集。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
ull p[30];
int n, k;

void input() {
    cin >> n >> k;

    for(int i=0; i<n; i++) {
        int c, x;
        cin >> c;

        while(c--) {
            cin >> x;
            p[i] |= (1ULL << (k - x));   // 人士 i 拥有 x 能力，修改对应 bit
        }
    }
}

int choice[30];
ull ans;

void dfs(int pos) {
    if(pos == n) {
        ull res = 0;
        for(int i=0; i<n; i++)
            if(choice[i])
                res ^= p[i];
        
        ans = max(res, ans);
        return;
    }

    choice[pos] = 0;
    dfs(pos + 1);
    choice[pos] = 1;
    dfs(pos + 1);
}

void work() {
    dfs(0);
    cout << ans << endl;
}

int main() {
    input();
    work();

    return 0;
}
```

上述代码的复杂度为 $\mathcal{O}(2^n \cdot k)$，其中 $2^n$ 为枚举子集的复杂度。

需要指出，本题可以采用线性基 + 贪心来做。线性基能以 $\mathcal{O}(nk)$ 的复杂度完成任务，在此仅给出 Python 代码，有兴趣的同学可以去学习。

```python
import numpy as np
from functools import reduce

n, k = map(int, input().split())
s = np.zeros([k, k], dtype=int)

for x in range(n):
    r = list(map(int, input().split()))[1:]
    p = np.array([1 if i+1 in r else 0 for i in range(k)])
    
    for pos in range(k):
        if p[pos] == 1:
            if s[pos, pos] == 1:
                p ^= s[pos]
            else:
                s[pos] = p
                break

res = np.zeros([k], dtype=int)
for pos in range(k):
    if res[pos] == 0 and s[pos, pos] == 1:  # 贪心
        res ^= s[pos]

print(reduce(lambda x,y: x*2+y, res))    # 二进制转整数输出
```







---

## 作者：Usada_Pekora (赞：15)

~~目前本题最优解？~~

题意：给定 $n$ 个员工，以及员工的能力总数 $k$ ， 每个员工 $i$ 有 $c_i$ 种能力，第 $j$ 种能力 $x_j$ 可以提供 $2^{k-x_j}$ 的分值。从 $n$ 个员工中选出 $m$ 个员工时，如果这 $m$ 个员工有偶数个人拥有某个能力，那么这个能力就不能提供分值，反之，如果是奇数个人拥有该能力，那么该能力就能提供分值，求任选几个员工后最大的分值。

解法：对于每种能力，需要记录当前能力选了几次吗？其实是不需要的，用抑或运算可以很快地记录选了某个员工后当前的分值，因为对于任意一种能力，只有提供或不提供分值两种情况，选下一个员工后，该员工拥有的能力中，原来提供分值的会不提供，不提供的会提供分值，这时用抑或就可以快速统计了，因为一个数抑或上另一个数以后，结果里另一个数二进制中为 $1$ 的位置都会改变，而不是的则不变。

举个例子： $k = 4$ ，当前的分值为 $(7)_{10}$ ，也就是 $(0111)_2$ ，有一个员工拥有 $1, 3$ 两种能力，这个员工不选则不变，选了以后就是 $(0111)_2 \oplus (1010)_2 = (1101)_2 = (13)_{10}$ 。

而对于每个员工，只有选或不选两种状态，所以我们用 DFS 搜一遍，复杂度是 $O(2^n)$ ，非常的快。

另外，利用状压 DP 的方法也可以做这道题，不过我太弱了，一开始只想出一种 $O(3^n)$ 的转移就打了暴力了。

代码： 

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull n, k, a[22], ans;//用unsigned long long记录最大 2^k 的数据， （其实long long也可以）
inline void dfs(ull dep, ull now) {
	if(dep > n) {//取了n个人以后
		ans = max(ans, now);
		return;
	}
	dfs(dep + 1, now ^ a[dep]);//选这个人，抑或上他的分值
	dfs(dep + 1, now);//不选
}
int main() {
	cin >> n >> k;
	for(ull i = 1, c; i <= n; i++) {
		cin >> c;
		for(ull j = 1, x; j <= c; j++) {
			cin >> x;
			a[i] |= (1ull << (k - x)); //记录二进制分值，等价于a[i] += (1ull << (k - x))或a[i] += (1ull * pow(2, k - x))
		}
	}
	dfs(0, 0);
	cout << ans;
	return 0;
}
```


当然，暴搜是很好打，那么遇上 $n$ 更大的数据自然就无能为力了，所以我们引入线性基这种方法。（我居然第二天才想起来）。

如果存在两个集合 $S,B$ ，且 $S$ 的任意子集的抑或和都能通过 $B$ 的子集以抑或和的形式表示时，则称 $\left | B\right|$ 最小的一个 $B$ 是 $S$ 的线性基。

线性基的性质：线性基中任意两个元素的二进制最高位不同；线性基的子集抑或和唯一；线性基中任意元素的抑或和不为 $0$ 。

为了满足上面的三个性质，在线性基插入元素 $x$ 时，从高位向低位扫，如果 $x$ 二进制下该位为 $1$，且不存在最高位为该位的线性基元素，将其插入线性基。如果该位为 $1$，但已经存在元素的最高位为该位，将 $x$ 抑或上该元素，继续向后扫。

线性基求抑或最值问题时，只需要进行贪心就可以，求最大值从高位向低位扫，如果抑或上线性基中对应元素以后更大，则进行抑或。求最小值时，只用取线性基中最小的元素就可以了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 25, K = 65;
ull n, k, base[K], a[N];
inline void insert(ull x) {
	for(ull i = k - 1; ~i; i--) {
		if(x & (1ull << i)) {
			if(!base[i]) {
				base[i] = x;
				break;
			}
			else x ^= base[i];
		} 
	}
}
inline ull query() {
	ull res = 0;
	for(ull i = k - 1; ~i; i--) if((res ^ base[i]) > res) res ^= base[i];
	return res;
}
int main() {
	cin >> n >> k;
	for(ull i = 1, x, c; i <= n; i++) {
		cin >> c;
		while(c--) cin >> x, a[i] |= (1ull << (k - x));
	}
	for(int i = 1; i <= n; i++) insert(a[i]);
	cout << query();
	return 0;
}
```


---

## 作者：ImposterAnYu (赞：9)

~~状压大水题，可惜太冷门了。~~

# 解析

这道题，一看数据范围，我就想到了状态压缩。

## 1. 状态压缩是什么？

状态压缩，顾名思义，就是将状态像压缩包一样缩到一起。

比如，这道题如果要拿每个人是选还是不选（选则为 $1$，不选则为 $0$）作为状态表示的话，最多会需要 $21$ 个参数来表示状态！虽然不是很多，但是写起来还是会比较麻烦的。
```c++
long long dp[2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2];
```
（不压缩的数组长这样，是不是很长很烦？）

但是，我们可以发现：这个数组的每个下标取值都只会是 $0$ 或 $1$，而`int`的范围远远大于 $0$ 和 $1$。如果按上面这样来表示，会造成很多的空间浪费！

那怎么办呢？

当我们将每一维看作一个 $2$ 进制数中的一位时，我们就可以用一个 $2$ 进制数表示整个数组 $21$ 维的状态。

举个例子：

当我们把 $dp_{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0}$ 的下标压缩后，得到了 $10110_{(2)}$。$10110_{(2)} = 14_{(10)}$，所以 $dp_{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0}$ 就可以直接用 $dp_{14}$ 来表示。

所以，我们可以把空间挤一下，将数组压成一维！
```c++
long long dp[1<<22];//为什么是左移22位呢？因为左移21位会RE……
```
## 2. 这题怎么算成功率？
题目说了，当有偶数个人拥有同一类能力时，团队会失去这项能力。就像当多个数异或有偶数个 $1$ 时，异或的结果为 $0$。

所以，我们可以首先预处理出如果只选这个人的成功率，然后枚举所有可能的状态，判断这种状态里选了哪些人，最后将这些人的成功率全部异或，再找出最大的答案输出即可。

不理解也没关系，看代码就好了。

# AC code
```c++
#include<bits/stdc++.h>
#define owo (1<<22)+5
#define int1 unsigned long long
using namespace std;
int1 n,k,n2,i,j,l,a[26],dp[owo],s,t,ans;//不开long long见祖宗。
int1 read(){//日常快读。
	int1 x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
void print(int1 x){//日常快写。
  	if(x < 0){
    	putchar('-');
    	x = -x;
  	}
  	if(x > 9){
    	print(x / 10);
  	}
  	putchar(x % 10 + 48);
  	return ;
}
int main(){
	n = read(),k = read(),n2 = 1ull << (n + 1ull);
	for(i = 1ull; i <= n; i++){
		s = read();
		for(j = 1ull; j <= s; j++){
			t = read();
			a[i] += (1ull << (k - t));//预处理成功率。
		}
	}
	for(i = 2ull; i < n2; i++){//枚举所有可能的情况。
		l = i;
		for(j = n; j >= 1ull; j--){//计算这种组合的成功率。
			if(l >= (1ull << j)){
				l -= 1ull << j;
				dp[i] ^= a[j];
			}
		}
		ans = max(ans,dp[i]);//找最大的答案。
	}
	print(ans);
    return 0;
}
```

---

## 作者：5k_sync_closer (赞：7)

我来发个位运算枚举子集。
# 题意
给一个 $n$ 个数的集合，找出一个子集使其异或和最大，求出这个异或和。
# 思路
$n$ 很小，考虑直接 $2^n$ 枚举。

定义 $p_i$ 为一个人能力的权重和，首先要算出 $p_i$。

只需要把第 $i$ 个人所有能力的权重按位或起来就可以了。

需要注意的是，如果要用 `1 << k - x` 的方式来算 $2^{k - x}$，那么必须写成 `1ull << k - x`，

因为 `1 << k - x` 里的 1 是 `int` 型的，把 `int` 型的数左移 $60$ 位是未定义行为。

这样这个集合就求出来了，接下来我们要枚举子集。


------------

我们用一个二进制数来表示每个数选不选，

具体地，`s & (1 << i) == 1` 代表选择第 $i$ 个数。

现在需要枚举所有的 $s$，也就是所有不多于 $n$ 位的二进制数。

可以发现，需要枚举 $[0,2^n)$ 之内的数。

对于每个 $s$，求出它所代表的的子集的异或和，取最大值即可。
# 代码
```cpp
#include <cstdio>
unsigned long long p[50], s, u, ans, sum;int n, k;
int main()
{
    scanf("%d%d", &n, &k);u = 1 << n;
    for(int i = 0, t, x;i < n;++i)
    {
        scanf("%d", &t);
        while(t--) scanf("%d", &x), p[i] |= 1ull << k - x; //注意是 1ull
    }
    for(;s < u;++s) //枚举 s
    {
        sum = 0;
        for(int i = 0;i < n;++i)
            if(s & (1 << i)) sum ^= p[i]; //算出 s 代表的子集的异或和
        if(sum > ans) ans = sum; //更新最大值
    }
    printf("%lld", ans);
    return 0;
}
```


---


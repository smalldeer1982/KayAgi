# [中山市赛 2023] 互质

## 题目描述

给定一个整数 $n$ 与 $n \times n$ 的矩阵 $a$，在 $a$ 中放置若干个不重叠的 $3 \times 3$ 子矩阵，使它们覆盖的元素和最大，求它们覆盖的元素和。

若没有放置任何子矩阵，则答案为 $0$。

## 说明/提示

### 样例解释 1

$5 \times 5$ 矩阵中仅能放置一个 $3 \times 3$ 的子矩阵，令其左上角为 $(3, 3)$，此时其覆盖的元素为 $-9, 4, 5, 3, 4, 5, 3, 2, 1$，和为 $18$。

### 样例解释 2

一种解的各子矩阵左上角为 $(1, 5),(1, 8),(3, 1),(5, 8),(6, 1),(7, 5),(8, 8)$。

### 数据范围

对于 $20\%$ 的数据，$n \le 5$。

对于另外 $20\%$ 的数据，$a$ 中仅包含正整数。

对于 $100\%$ 的数据，$n \le 10$，对于任意 $1 \le i, j \le n$ 满足 $|a_{i,j}| \le 100$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
5 4 3 2 1
1 2 -9 4 5
1 2 3 4 5
5 4 3 2 1```

### 输出

```
18```

## 样例 #2

### 输入

```
10
98 78 -97 -36 94 44 42 69 50 7
54 -54 -36 -56 98 69 59 36 52 80
90 36 65 -23 -33 65 12 79 -38 0
81 -19 65 73 32 -57 -79 -66 89 6
92 63 1 61 -96 -41 25 -44 -53 25
55 83 78 -41 -34 16 62 87 79 62
-63 91 -30 -33 91 39 92 92 29 92
74 39 44 25 29 50 -63 65 77 75
-26 -78 -92 55 -45 45 74 53 62 58
3 92 -4 -76 -60 -24 90 72 53 95```

### 输出

```
2921```

# 题解

## 作者：hanxiaofensheng (赞：4)

题意：给一个的整数矩阵，我们需要在里面放若干个不重叠的 $3×3$ 子矩阵，使得这些子矩阵覆盖的元素之和最大；如果没有可以放置的子矩阵，则返回 $0$。
# 思路
- 枚举所有可能的 $3\times 3$ 子矩阵：遍历矩阵中每个可能作为 $3\times 3$ 子矩阵左上角的位置，计算每个子矩阵的元素和。
- dfs：使用 dfs 尝试所有可能的子矩阵组合，确保选择的子矩阵互不重叠，并记录最大的和值。其中有两种选择：选或不选。如果选择当前子矩阵，需要确保它与已选的子矩阵都不重叠。在 dfs 中，如果发现当前路径的和不可能超过已记录的最大值，可以提前终止该分支的搜索。
# 注意点
- 子矩阵生成：对于这个矩阵，可以生成的 $3\times 3$ 子矩阵数量为 $(n-2)\times (n-2)$ 个。每个子矩阵由其左上角坐标 $i,j$ 唯一确定。
- 重叠判断条件：它们在 $x$ 轴和 $y$ 轴上的投影都有重叠。
- 优先选择和较大的子矩阵，这样更容易快速找到较大的和值。
# 复杂度分析
时间复杂度：$O(2^k)$（差一点超时/ll）。  
空间复杂度：$O(k)$。

[代码](https://www.luogu.com.cn/paste/ies5ncj2)

---

## 作者：Yivan11 (赞：2)

## 前言
### [题目传送门](https://www.luogu.com.cn/problem/B4335)

给你一个 $n×n$ 的矩阵,要在里面放若干个不重叠的 $3×3$ 的子矩阵，让这些子矩阵覆盖的元素和最大。如果放不下任何子矩阵，答案就是 $0$。

## 思路
因为 $n$ 最大只有 $10$，可以直接暴力枚举所有可能的 $3×3$ 子矩阵的位置，然后找出不重叠的子矩阵组合，使它们的和最大。可以用递归或者位运算来枚举所有可能的组合方式。

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, as = 0;
vector<vector<int>> m;
vector<vector<bool>> u;

//计算以(i,j)为左上角的3x3子矩阵的和
int cs(int i, int j) {
    int sum = 0;
    for (int x = 0; x < 3; x++)
        for (int y = 0; y < 3; y++)
            sum += m[i+x][j+y];
    return sum;
}

//检查以(i,j)为左上角的3x3子矩阵是否可用
bool ck(int i, int j) {
    for (int x = 0; x < 3; x++)
        for (int y = 0; y < 3; y++)
            if (u[i+x][j+y]) return false;
    return true;
}

//标记或取消标记3x3子矩阵
void m1(int i, int j, bool f) {
    for (int x = 0; x < 3; x++)
        for (int y = 0; y < 3; y++)
            u[i+x][j+y] = f;
}

//递归枚举所有可能的子矩阵组合
void d(int i, int j, int c) {
    if (j > n-3) { j = 0; i++; }      //换行
    if (i > n-3) {      //遍历完所有可能位置 
        as = max(as, c);
        return;
    }

//不选当前位置的子矩阵
    d(i, j+1, c);

//如果可以选当前位置的子矩阵
    if (ck(i, j)) {
        int sum = cs(i, j);
        m1(i, j, true);
        d(i, j+1, c + sum);
        m1(i, j, false);
    }
}

int main() {
    cin >> n;
    m.resize(n, vector<int>(n));
    u.resize(n, vector<bool>(n, false));
    
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> m[i][j];
    
    if (n >= 3){
        d(0, 0, 0);
    } 
    cout << as << endl;
    return 0;
}
```

---

## 作者：Gongyujie123 (赞：2)

## [B4335 [中山市赛 2023] 互质](https://www.luogu.com.cn/problem/B4335) 题解

### 1. 思路分析
我们可以用 DFS 枚举每个左上角为 $(x,y)(1 \le x,y \le n - 2)$ 的 $3 \times 3$ 子矩阵。

根据左上角的坐标 $(x,y)$，我们先判断这个子矩阵是否越界或与其他子矩阵重叠，如果是的话，就直接枚举下一个位置；否则，更新总和，标记覆盖区域，再枚举下一个位置，然后回溯。

当每次枚举完整个矩阵的时候，就更新答案。
### 2. AC 代码

[AC 记录](https://www.luogu.com.cn/record/220041446)。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, a[102][102], b[102][102];
int ans = 0, sum = 0;
void next_dfs(int x, int y);
void dfs(int x, int y){
	int s = 0;
	bool f = 0;
	for (int i = x; i < x + 3; i++) {  // 枚举每个 3 * 3 的矩阵
		for (int j = y; j < y + 3; j++) {
			if (i > n || j > n || b[i][j]) {
				f = 1;
				s = 0;
				goto bk;  // 直接跳转到第 20 行的 bk: 处
			}
			s += a[i][j];  // 求和
		}
	}
	bk:
	if (f) {  // 如果越界了或重叠了就直接下一个
		next_dfs(x, y);
	} else {
		sum += s;
		for (int i = x; i < x + 3; i++) {
			for (int j = y; j < y + 3; j++) {
				b[i][j] = 1;  // 给子矩阵打上标记
			}
		}
		next_dfs(x, y);
		sum -= s;
		for (int i = x; i < x + 3; i++) {
			for (int j = y; j < y + 3; j++) {
				b[i][j] = 0;  // 回溯
			}
		}
		next_dfs(x, y);
	}
}
void next_dfs(int x, int y){  // 枚举下一个位置
	int dx = x, dy = y + 1;
	if (dy > n) {
		dy = 1;
		dx++;
	} 
	if (x == n + 1) {  // 枚举完了整个大矩阵
		ans = max(ans, sum);
		return;
	}
	dfs(dx, dy);
}
signed main(){
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
		}
	}
	dfs(1, 1);
	cout << ans;
	return 0;
}
```

---
由于代码中用到了 `goto` 语句，这里解释一下这个语句：

> goto 语句允许程序无条件跳转到同一函数内的被标记的语句处。

`goto` 后接要跳转的标识符，要跳转的语句前加上标识符和一个 `:`。例如：

```cpp
int a = 10;
goto xxx;
a = 114;
xxx:
cout << a << endl;

// 输出为 10
```

---

## 作者：san_ming (赞：2)

### 题目大意

给定 $n \times n$ 的矩阵，问放置若干个**不重叠**的 $3 \times 3$ 子矩阵后，覆盖的每项元素的和最大是多少。

### 解题思路

$n \le 10$，我们考虑暴力搜索。即，将每个子矩阵的元素和算出来，深搜寻找每个子矩阵相加的最大值。

由于是暴力搜索，所有我们要进行**一定的剪枝**，以防超时。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20][20],ans;
pair<int, int> p[120];
int sum[110]={0};
bool v[15][15] = {0};

int dfs(int t,int maxx)//从第t个开始，maxx是相加的和 
{
	if(t==0)//当t=0，即表示所有子矩阵都深搜完  
    {//ans最大的和 
        ans=max(ans,maxx);//返回目前的和与最大的和哪个大，求最大值 
        return 0;
    }
    
    dfs(t-1,maxx);//情况1：不选该子矩阵 
    
    int x=p[t].first; //情况2：选 
    int y=p[t].second;
    for(int i=x;i<=x+2;i++) 
        for(int j=y;j<=y+2;j++) 
            if (v[i][j]==1) //如果已经被选过了直接返回 
				return 0;
   

    for(int i=x;i<=x+2;i++)
        for(int j=y;j<=y+2;j++) 
			v[i][j]=1;//没选过，打上标记 
        
    dfs(t-1,maxx+sum[t]);//加上该矩阵的和，继续搜 

    for(int i=x;i<=x+2;i++) 
        for(int j=y;j<=y+2;j++) 
            v[i][j]=0;//回溯 
            
    return 0;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	
	int t=0;//子矩阵的数量 
    for(int i=1;i<=n-2;i++) 
	{
        for(int j=1;j<=n-2;j++) 
		{
			t++;
            p[t]={i,j};//储存每个子矩阵的左上角的坐标 
            for(int x=i;x<=i+2;x++) 
                for(int y=j;y<=j+2;y++) 
                    sum[t]+=a[x][y];//算出每个子矩阵的元素和 
        }
    }
    
    dfs(t,0); 
    cout<<ans; 
	return 0;
}
```

- 在最坏情况中，时间复杂度为 $O(2^{(n-2)^2})$。但实际运行时，由于重叠等原因，很多情况会被**提前剪枝**，因此实际运行时间远小于最坏情况（理论情况）。

- 所以该时间复杂度解决该题绰绰有余，不必担心。

---

## 作者：scc36 (赞：1)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4335)
### 思路
其实就是暴力搜索。看看这个 $3 \times 3$ 的矩阵是否与曾经选择过的矩阵重合，如果有就不要它，退出搜索；没有的话就分两种情况：要它或不要它，然后继续搜索。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,a[1001][1001],s,m,ma,ff[101][101],f[101];
struct no{
	int x,y,a;
}b[100001];
void sc(int t,int s){
	int x,y;
	if(t>m){
		ma=max(ma,s);
		return ;
	}
	f[t]=0,sc(t+1,s);//不要它
	
	f[t]=1;
	x=b[t].x,y=b[t].y;
	if(ff[x][y]==1) return ; //判断有没有重复
	if(ff[x+1][y]==1) return ;
	if(ff[x+2][y]==1) return ;
	if(ff[x][y+1]==1) return ;
	if(ff[x][y+2]==1) return ;
	if(ff[x+1][y+1]==1) return ;
	if(ff[x+2][y+2]==1) return ;
	if(ff[x+1][y+2]==1) return ;
	if(ff[x+2][y+1]==1) return ;
	ff[x][y]=1;
	ff[x+1][y]=ff[x+2][y]=ff[x][y+1]=ff[x][y+2]=1;
	ff[x+1][y+1]=ff[x+2][y+2]=1;
	ff[x+1][y+2]=ff[x+2][y+1]=1;	
	sc(t+1,s+b[t].a); //要它
	ff[x][y]=0;  //还原
	ff[x+1][y]=ff[x+2][y]=ff[x][y+1]=ff[x][y+2]=0;
	ff[x+1][y+1]=ff[x+2][y+2]=0;
	ff[x+1][y+2]=ff[x+2][y+1]=0;		
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			cin>>a[i][j];
	for(i=1;i<=n-2;i++)
		for(j=1;j<=n-2;j++){
			s=0;
			s+=a[i][j];
			s+=a[i+1][j]+a[i+2][j];
			s+=a[i][j+1]+a[i][j+2];
			s+=a[i+1][j+1]+a[i+2][j+2];
			s+=a[i+1][j+2]+a[i+2][j+1];	
			m++,b[m].x=i,b[m].y=j,b[m].a=s;
    //记录每一个矩阵的和
		}
	sc(1,0);
	cout<<ma;
} 
```

---

## 作者：no_response (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4335)
## 题意
给定一个整数 $n \times n$ 的矩阵，在矩阵中放置若干个不重叠的 $3 \times 3$ 子矩阵，使它们覆盖的元素和最大，求它们覆盖的元素和。

若没有可以放置任何子矩阵，则答案为 $0$。
## 思路
这题需要深度搜索算法，~~标签上有~~，再加上个剪枝就好了。
### 预处理部分
先求出每个可能的 $3 \times 3$ 矩阵，范围为 $1 \sim n - 2$。然后记录下矩阵左上角的坐标，再记录下每个矩阵中的各个数的和。

代码如下（加输出）：
```cpp
int n;
cin >> n;
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= n; j++) {
		cin >> a[i][j];
  }
}
int t = 0;
for (int i = 1; i <= n - 2; i++) {
	for (int j = 1; j <= n - 2; j++) {
		t++;
		v[t].r = i, v[t].c = j;
		for (int q = i; q <= i + 2; q++) {
			for (int p = j; p <= j + 2; p++) {
				b[t] += a[q][p];
      }
  	}
  }
}
```
### 深搜部分
显然深搜是递归，需要有结束条件，代码如下：
```cpp
if (t == 0) {
  ans = max(maxn, ans);
  return 0;
}
```
进行下一层搜索后，先进行剪枝，判断矩阵是否已重叠，然后把矩阵改为已重叠，代码如下：
```cpp
dfs(t - 1, maxn);
int x = v[t].r,	y = v[t].c;
for (int i = x; i <= x + 2; i++) {
	for (int j = y; j <= y + 2; j++) {
		if (f[i][j] == 1) {
			return 0;
		}
	}
}
for (int i = x; i <= x + 2; i++) {
	for (int j = y; j <= y + 2; j++) {
		f[i][j] = 1;
  }
}
```
后面再进行下一层搜索，还原是否被覆盖的情况，然后返回，代码如下：
```cpp
dfs(t - 1, maxn + b[t]);
for (int i = x; i <= x + 2; i++) {
	for (int j = y; j <= y + 2; j++) {
		f[i][j] = 0;
	}
}
return 0;
```
### 时空复杂度
**时间复杂度**：
因为递归是 $O(2^n)$ 的，所以这段代码的时间复杂度是 $O(2^{{n-2}^{2}})$，但因为有剪枝操作，所以可以通过。

空间复杂度是 $O(n^2)$，应为只开了二维数组，且 $n$ 极小，可以通过。
## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans;
struct board {
	int r, c;
} v[110]; //左上角坐标
int a[15][15], b[110]; //a为输入，b为存储矩阵和
bool f[15][15]; //记录是否已覆盖
int dfs(int t, int maxn) { //maxn代表当前计数
	if (t == 0) { //终止条件
		ans = max(maxn, ans);
		return 0;
	}
	dfs(t - 1, maxn); //下一层搜索
	int x = v[t].r,	y = v[t].c; //矩阵左上角坐标点
	for (int i = x; i <= x + 2; i++) {
		for (int j = y; j <= y + 2; j++) {
			if (f[i][j] == 1) { //若已覆盖，回溯
				return 0; //剪枝
			}
		}
	}
	for (int i = x; i <= x + 2; i++) {
		for (int j = y; j <= y + 2; j++) {
			f[i][j] = 1; //修改f，成已覆盖状态
		}
	}
	dfs(t - 1, maxn + b[t]); //下一层搜索
	for (int i = x; i <= x + 2; i++) {
		for (int j = y; j <= y + 2; j++) {
			f[i][j] = 0; //搜索完后复原
		}
	}
	return 0;
}
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j]; //输入
		}
	}
	//预处理部分
	int t = 0;
	for (int i = 1; i <= n - 2; i++) {
		for (int j = 1; j <= n - 2; j++) {
			t++;
			v[t].r = i, v[t].c = j; //存入坐标点
			for (int q = i; q <= i + 2; q++) {
				for (int p = j; p <= j + 2; p++) {
					b[t] += a[q][p]; //存入可能的矩阵
				}
			}
		}
	}
	dfs(t, 0); //深搜
	cout << ans;
	return 0;
}
```

---

## 作者：linhanmo (赞：1)

# 题解：B4335 [中山市赛 2023] 互质

## 思路

看见 $n\le 10$ 考虑暴搜。

搜索每一个格子

1. 到达边界：不能再放了，更新答案。
   
2. 不放：直接搜索下一个。

3. 放：检查能不能放置，如果可以打上标记，继续往下搜索。

时间复杂度 $O(2^{(n^2)})$，理论上不能通过，可是搜索中有很多不合法的状态，进行一定剪枝后可以过。

## [AC](https://www.luogu.com.cn/record/219649971) code

```
#include <stdio.h>
#include <bitset>
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
constexpr int N = 11;
int n, mx /* 答案 */, a[N][N] /* 矩阵 */, s[N * N];
std::pair<int, int> id[N * N]; // 编号
std::bitset<N> v[N]; // 是否放置的标记
void dfs(int cur /* 现在放到哪儿了 */, int scur /* 现在放了几个 */) {
    if (cur > (n - 2) * (n - 2)) mx = std::max(mx, scur); // 操作 1
    else {
        dfs(cur + 1, scur); // 操作 2
        auto [x, y] = id[cur];
        rep(i, x, x + 2) rep(j, y, y + 2) if (v[i][j]) return; // 检查能不能放置
        rep(i, x, x + 2) rep(j, y, y + 2) v[i].set(j); // 打上标记
        dfs(cur + 1, scur + s[cur]); // 操作 3
        rep(i, x, x + 2) rep(j, y, y + 2) v[i].reset(j); // 恢复原状
    } return;
}
int main(void) {
    scanf("%d", &n);
    rep(i, 1, n) rep(j, 1, n) scanf("%d", &a[i][j]);
    int cnt = 0;
    rep(i, 1, n - 2)
        rep(j, 1, n - 2)  {
    	    id[++cnt] = {i, j};
            rep(x, i, i + 2) rep(y, j, j + 2) s[cnt] += a[x][y];
        } // 预处理编号
    dfs(1, 0), printf("%d", mx);
    return 0;
}
```

---


# [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

## 样例 #1

### 输入

```
4 3
3 7 12 19
```

### 输出

```
1
```

# 题解

## 作者：dbxxx (赞：1902)

`upd on 2020.04.02`
1. 修改了文中已失效的blog链接
2. 再次修改码风

`upd on 2019.12.09:`  
1. 发现很多的人对`vis`数组产生疑问。它是不用写的，这里先去掉吧。  
2. 将代码修改成我现在的码风。
3. 去除了一些无意义废话

------------

`upd on 2019.11.12:`  
过一年了，发现当初的我真的好菜啊。
这道题当时提交的时候开了`freopen`，死活都不知道哪里错了。。。现在想起来真是哈哈哈哈哈哈哈哈哈哈哈

哦对了推销一下`blog:`[here](https://www.cnblogs.com/crab-in-the-northeast)


------------
先上我的代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
bool isprime(int a){
    if(a == 1) return false;
    for(int i = 2; i * i <= a; i++)
        if(a % i == 0)
            return false;
    return true;
}

int n,k;
int a[25];
long long ans;

void dfs(int m, int sum, int startx){
    if(m == k){
        if(isprime(sum))
            ans++;
        return ;
    }
    for(int i = startx; i < n; i++)
        dfs(m + 1, sum + a[i], i + 1);
    return ;
}

int main(){
    scanf("%d%d",&n,&k);
    for(int i = 0; i < n; i++)
        scanf("%d",&a[i]);
    dfs(0, 0, 0);
    printf("%d\n",ans);
    return 0;
}
//本蒟蒻的第一篇题解，求过
```
其实这里的难点是：如何去重？

答案是：不降原则

不降原则是个神马意思呢
```cpp
举个例子：
比如说在6里面随便选5个数，那么选法都是什么呢？
瞎枚举？
12345
12346
前两个还不会弄混
然后很可能就乱了
少点数可能不会乱
但是多了就不好整了
比如说在100里随便选50个数。
1 2 3 4 5 6 7 8 9 10 11 12......
Die.
所以我们可以运用不降原则：
保证枚举的这些数是升序排列
其实真正的不降原则还可以平
比如 1 2 2 3 3 4......
但是请注意这道题也不能平
否则就有重复数字了

拿6个里面选3个举例子
1 2 3
1 2 4
1 2 5
1 2 6
第一轮枚举完毕。
第二个数加一
1 3 ？
这个“？”应该是4，因为是升序排列
1 3 4
1 3 5
1 3 6
接着，就是这样
1 4 5
1 4 6
1 5 6
第一位是1枚举完毕
第一位是2呢?
2 3 4
2 3 5
2 3 6
2 4 5
2 4 6
2 5 6
就是这样的，枚举还是蛮清晰的吧
以此类推.....
3 4 5
3 4 6
3 5 6
4 5 6
然后就枚举不了了，结束。
所以说，这样就可以避免判重了。
```
知道了不降原则，咱们再来`see see` 代码

```
代码中还是一样的老套路
一样的dfs
一样的参数
咱们最主要看其中不降原则的部分
在dfs函数中，我们明显能看到一个参数 startx
是startx而不是start是为了避免关键字
这是个什么东西呢？
就是当前的初始值
也就是最小的，符合不降原则的参数
这样一来，就可以去重了！
```
好的，代码说完了，最后给个带有注释版的程序：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

bool isprime(int a){//判断素数
    /*
    吐槽：题中n的数据范围很奇怪，
    n还有可能=1.....那k<n......
    */
    if(a == 1) return false;
    for(int i = 2;i * i <= a; i++)//不想用sqrt，还要头文件
        if(a % i == 0)//如果整除
            return false;//扔回false
    //程序都到这里的话就说明此为素数
    //否则就被扔回了
    return true;//扔回true
}

int n,k;
int a[25];
long long ans;

void dfs(int m, int sum, int startx){//最重要的递归
//m代表现在选择了多少个数
//sum表示当前的和
//startx表示升序排列，以免算重
    if(m == k){//如果选完了的话
        if(isprime(sum))//如果和是素数
            ans++;//ans加一
        return ;
    }
    for(int i = startx; i < n; i++)
        dfs(m + 1, sum + a[i], i + 1);//递归
        //步数要加一，和也要加
        //升序起始值要变成i+1,以免算重
    return ;//这一个步骤下，所有的都枚举完了
    //直接返回去
}

int main(){
    scanf("%d%d",&n,&k);//输入
    
    for(int i = 0; i < n; i++)
        scanf("%d",&a[i]);//循环读入
    dfs(0,0,0);//调用函数
    printf("%d\n",ans);//输出答案
    return 0;//结束程序
}

```

---

## 作者：bjrjk (赞：1167)

```cpp
#include<iostream>
#include<math.h>
using namespace std;
int x[20],n,k;//依照题目所设
bool isprime(int n){//判断是否质数
    int s=sqrt(double(n));
    for(int i=2;i<=s;i++){
        if(n%i==0)return false;
    }
    return true;
}
int rule(int choose_left_num,int already_sum,int start,int end){//choose_left_num为剩余的k，already_sum为前面累加的和，start和end为全组合剩下数字的选取范围；调用递归生成全组合，在过程中逐渐把K个数相加，当选取的数个数为0时，直接返回前面的累加和是否为质数即可
    if(choose_left_num==0)return isprime(already_sum);
    int sum=0;
    for(int i=start;i<=end;i++){
        sum+=rule(choose_left_num-1,already_sum+x[i],i+1,end);
    }
    return sum;
}
int main(){
    cin>>n>>k;
    for(int i =0;i<n;i++)cin>>x[i];
    cout<<rule(k,0,0,n-1);//调用递归解决问题
}
```

---

## 作者：Ajwallet (赞：1036)

备注：上次写的时候发现k==18那里有一处小错误，所以这次修改了一下

# 此解绝对不是正解！
好吧，其实此题枚举+优化也能过

列举各种情况

当k=1时直接一重循环过去

当k=2时两重循环

当k=3时三重循环

以此类推到k=10

当k=11时先计算一遍总和，再九重循环，用总和减去每次得来的和，判断此数是否为质数

当k=12时同样先计算一遍总和，再八重循环，记住每次使用总和去减

当k=13时同样先计算一遍总和，再七重循环

以此类推

**特殊情况：当n==20或者n==k时直接判断总和是否是负数就行了**

时间复杂度差不多相当于深搜+HASH优化，因为只是10重循环而不是二十重
# 代码
```cpp
#include<stdio.h>
#include<cmath>
#include<cstdlib>
#include<iostream>
using namespace std;
int a[21];
int s,x,n,k;
bool zs(long long y)//判断是否是质数
{
    if (y==1||!y) return 0;
    for (int i=2;i<=sqrt(y);i++)
     if (!(y%i)) return 0;
    return 1;
     
}
void sr()
{
    scanf("%d %d",&n,&k);
    for (int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
     	x+=a[i];//求下总和
    }
}
void js()
{
    if (k==19||k==n-1) {for (int i=1;i<=n;i++) if (zs(x-a[i])) s++;return;}
    if (k==20||n==k) {if (zs(x)) s++;return;}//两个特判
    if (k==1)  
     {
      for (int i=1;i<=n;i++) 
       if (zs(a[i])) s++;//计算
     }
    if (k==2)  
     {
      for (int i=1;i<=n-1;i++) 
       for (int i1=i+1;i1<=n;i1++) 
        if (zs(a[i]+a[i1])) s++;//计算
        return;
     }
    if (k==3)  
     {
      for (int i=1;i<=n-2;i++) 
       for (int i1=i+1;i1<=n-1;i1++) 
        for (int i2=i1+1;i2<=n;i2++) 
         if(zs(a[i]+a[i1]+a[i2]))s++;//计算
         return;
   	 }
    if (k==4)  
     {
       for (int i=1;i<=n-3;i++) 
        for (int i1=i+1;i1<=n-2;i1++) 
         for (int i2=i1+1;i2<=n-1;i2++) 
          for (int i3=i2+1;i3<=n;i3++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]))s++;
          return;
     }
    if (k==5)  
     {
       for (int i=1;i<=n-4;i++) 
        for (int i1=i+1;i1<=n-3;i1++) 
         for (int i2=i1+1;i2<=n-2;i2++) 
          for (int i3=i2+1;i3<=n-1;i3++)
           for (int i4=i3+1;i4<=n;i4++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]))s++;
          return;
     }
    if (k==6)
     {
       for (int i=1;i<=n-5;i++)
        for (int i1=i+1;i1<=n-4;i1++) 
         for (int i2=i1+1;i2<=n-3;i2++) 
          for (int i3=i2+1;i3<=n-2;i3++)
           for (int i4=i3+1;i4<=n-1;i4++)
            for (int i5=i4+1;i5<=n;i5++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]))s++;
          return;
     }
    if (k==7)
     {
       for (int i=1;i<=n-6;i++) 
        for (int i1=i+1;i1<=n-5;i1++)
         for (int i2=i1+1;i2<=n-4;i2++) 
          for (int i3=i2+1;i3<=n-3;i3++)
           for (int i4=i3+1;i4<=n-2;i4++)
            for (int i5=i4+1;i5<=n-1;i5++)
             for (int i6=i5+1;i6<=n;i6++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]))s++;
          return;
     }
    if (k==8)  
     {
       for (int i=1;i<=n-7;i++) 
        for (int i1=i+1;i1<=n-6;i1++) 
         for (int i2=i1+1;i2<=n-5;i2++) 
          for (int i3=i2+1;i3<=n-4;i3++)
           for (int i4=i3+1;i4<=n-3;i4++)
            for (int i5=i4+1;i5<=n-2;i5++)
             for (int i6=i5+1;i6<=n-1;i6++)
              for (int i7=i6+1;i7<=n;i7++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]+a[i7]))s++;
          return;
     }
    if (k==9)
     {
       for (int i=1;i<=n-8;i++) 
        for (int i1=i+1;i1<=n-7;i1++) 
         for (int i2=i1+1;i2<=n-6;i2++) 
          for (int i3=i2+1;i3<=n-5;i3++)
           for (int i4=i3+1;i4<=n-4;i4++)
            for (int i5=i4+1;i5<=n-3;i5++)
             for (int i6=i5+1;i6<=n-2;i6++)
              for (int i7=i6+1;i7<=n-1;i7++)
               for (int i8=i7+1;i8<=n;i8++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]+a[i7]+a[i8]))s++;
          return;
     }
    if (k==10)
     {
       for (int i=1;i<=n-9;i++) 
        for (int i1=i+1;i1<=n-8;i1++) 
         for (int i2=i1+1;i2<=n-7;i2++) 
          for (int i3=i2+1;i3<=n-6;i3++)
           for (int i4=i3+1;i4<=n-5;i4++)
            for (int i5=i4+1;i5<=n-4;i5++)
             for (int i6=i5+1;i6<=n-3;i6++)
              for (int i7=i6+1;i7<=n-2;i7++)
               for (int i8=i7+1;i8<=n-1;i8++)
                for (int i9=i8+1;i9<=n;i9++)
          if(zs(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]+a[i7]+a[i8]+a[i9]))s++;
          return;
     }
    if (k==11)
     {
       for (int i=1;i<=n-8;i++) 
        for (int i1=i+1;i1<=n-7;i1++) 
         for (int i2=i1+1;i2<=n-6;i2++) 
          for (int i3=i2+1;i3<=n-5;i3++)
           for (int i4=i3+1;i4<=n-4;i4++)
            for (int i5=i4+1;i5<=n-3;i5++)
             for (int i6=i5+1;i6<=n-2;i6++)
              for (int i7=i6+1;i7<=n-1;i7++)
               for (int i8=i7+1;i8<=n;i8++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]+a[i7]+a[i8])))s++;//注意这里是用x去减
          return;
     }
    if (k==12)
     {
       for (int i=1;i<=n-7;i++) 
        for (int i1=i+1;i1<=n-6;i1++) 
         for (int i2=i1+1;i2<=n-5;i2++) 
          for (int i3=i2+1;i3<=n-4;i3++)
           for (int i4=i3+1;i4<=n-3;i4++)
            for (int i5=i4+1;i5<=n-2;i5++)
             for (int i6=i5+1;i6<=n-1;i6++)
              for (int i7=i6+1;i7<=n;i7++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6]+a[i7])))s++;
          return ;//以下都是用x去减，注意！
     }
    if (k==13)
     {
       for (int i=1;i<=n-6;i++) 
        for (int i1=i+1;i1<=n-5;i1++)
         for (int i2=i1+1;i2<=n-4;i2++) 
          for (int i3=i2+1;i3<=n-3;i3++)
           for (int i4=i3+1;i4<=n-2;i4++)
            for (int i5=i4+1;i5<=n-1;i5++)
             for (int i6=i5+1;i6<=n;i6++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5]+a[i6])))s++;
          return;
     }
    if (k==14)
     {
       for (int i=1;i<=n-5;i++)
        for (int i1=i+1;i1<=n-4;i1++) 
         for (int i2=i1+1;i2<=n-3;i2++) 
          for (int i3=i2+1;i3<=n-2;i3++)
           for (int i4=i3+1;i4<=n-1;i4++)
            for (int i5=i4+1;i5<=n;i5++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3]+a[i4]+a[i5])))s++;
          return;
     }
    if (k==15)
     {
       for (int i=1;i<=n-4;i++) 
        for (int i1=i+1;i1<=n-3;i1++) 
         for (int i2=i1+1;i2<=n-2;i2++) 
          for (int i3=i2+1;i3<=n-1;i3++)
           for (int i4=i3+1;i4<=n;i4++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3]+a[i4])))s++;
          return;
     }
    if (k==16)
     {
       for (int i=1;i<=n-3;i++) 
        for (int i1=i+1;i1<=n-2;i1++) 
         for (int i2=i1+1;i2<=n-1;i2++) 
          for (int i3=i2+1;i3<=n;i3++)
          if(zs(x-(a[i]+a[i1]+a[i2]+a[i3])))s++;
          return;
     }
    if (k==17)
     {
       for (int i=1;i<=n-2;i++) 
        for (int i1=i+1;i1<=n-1;i1++) 
         for (int i2=i1+1;i2<=n;i2++) 
  		  if(zs(x-(a[i]+a[i1]+a[i2])))s++;
          return;
   	 }
   	if (k==18)
     {
       for (int i=1;i<=n-1;i++) 
        for (int i1=i+1;i1<=n;i1++) 
         if (zs(x-(a[i]+a[i1]))) s++;//之前没有用x去减，给大家造成了一些困扰，在这里说声抱歉
         return;
     }
}
int main()
{
   sr();
   js();
   printf("%d",s);
}
```

---

## 作者：dinghongyu (赞：534)

## 此解为歪解，仅供观赏，切勿模仿
### ~~发现原来漏考虑题中的k等于一的情况了~~
## 思路：题中的k等于几就几个for语句
## 768行代码见下：
```cpp
#include <bits/stdc++.h>
#define ff(i) for (int i=1;i<=n;i++)
#define f(x,y) for (int y=x+1;y<=n;y++)
using namespace std;
bool zs(int x)
{
	for (int i=2;i<=sqrt(x);i++)
	   if (x%i==0)
	     return 0;
	return 1;
}
int n,x,a[25],b[95000001]={0},mx=-1,c=0;
int main()
{
	cin>>n>>x;
	for (int i=1;i<=n;i++)
	   cin>>a[i];
	if (x==1)
	{
		ff(i)
		{
			if (zs(a[i]))
		      b[a[i]]++;
		    if (a[i]>mx)
		      mx=a[i];
		}
	}
	if (x==2)
	{
		ff(i)
		{
			f(i,j)
			{
				int m=a[i]+a[j];
				if (zs(m))
		          b[m]++;
		        if (m>mx)
		          mx=m;
			}
		}
	}
	if (x==3)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
				    int m=a[i]+a[j]+a[k];
		            if (zs(m))
		              b[m]++;
		            if (m>mx)
		              mx=m;
			    }
		    }
	    }
	}
	if (x==4)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		int m=a[i]+a[j]+a[k]+a[l];
		                if (zs(m))
		                  b[m]++;
		                if (m>mx)
		                  mx=m;
					}
			    }
		    }
	    }
	}
	if (x==5)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    		    int m=a[i]+a[j]+a[k]+a[l]+a[ii];
		                    if (zs(m))
		                      b[m]++;
		                    if (m>mx)
		                      mx=m;
		                }
					}
			    }
		    }
	    }
	}
	if (x==6)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj];
		                        if (zs(m))
		                          b[m]++;
		                        if (m>mx)
		                          mx=m;
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==7)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk];
		                            if (zs(m))
		                              b[m]++;
		                            if (m>mx)
		                              mx=m;
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==8)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll];
		                                if (zs(m))
		                                  b[m]++;
		                                if (m>mx)
		                                  mx=m;
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==9)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm];
		                                        if (zs(m))
		                                          b[m]++;
		                                        if (m>mx)
		                                          mx=m;
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==10)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn];
		                                            if (zs(m))
		                                              b[m]++;
		                                            if (m>mx)
		                                              mx=m;
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==11)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo];
		                                                if (zs(m))
		                                                  b[m]++;
		                                                if (m>mx)
		                                                  mx=m;
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==12)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp];
		                                                    if (zs(m))
		                                                      b[m]++;
		                                                    if (m>mx)
		                                                      mx=m;
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==13)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq];
		                                                        if (zs(m))
		                                                          b[m]++;
		                                                        if (m>mx)
		                                                          mx=m;
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==14)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr];
		                                                            if (zs(m))
		                                                              b[m]++;
		                                                            if (m>mx)
		                                                              mx=m;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==15)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													f(rr,ss)
			    													{
			    														int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr]+a[ss];
		                                                                if (zs(m))
		                                                                  b[m]++;
		                                                                if (m>mx)
		                                                                  mx=m;
																    }
															    }
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==16)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													f(rr,ss)
			    													{
			    														f(ss,tt)
			    														{
			    															int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr]+a[ss]+a[tt];
		                                                                    if (zs(m))
		                                                                      b[m]++;
		                                                                    if (m>mx)
		                                                                      mx=m;
																		}	
																	}	
																}	
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==17)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													f(rr,ss)
			    													{
			    														f(ss,tt)
			    														{
			    															f(tt,uu)
			    															{
			    																int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr]+a[ss]+a[tt]+a[uu];
		                                                                        if (zs(m))
		                                                                          b[m]++;
		                                                                        if (m>mx)
		                                                                          mx=m;
																			}
																		}	
																	}	
																}	
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==18)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													f(rr,ss)
			    													{
			    														f(ss,tt)
			    														{
			    															f(tt,uu)
			    															{
			    																f(uu,vv)
			    																{
			    																	int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr]+a[ss]+a[tt]+a[uu]+a[vv];
		                                                                            if (zs(m))
		                                                                              b[m]++;
		                                                                            if (m>mx)
		                                                                              mx=m;
																				}
																			}
																		}	
																	}	
																}	
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	if (x==19)
	{
		ff(i)
	    {
		    f(i,j)
		    {
			    f(j,k)
			    {
			    	f(k,l)
			    	{
			    		f(l,ii)
			    		{
			    			f(ii,jj)
			    			{
			    				f(jj,kk)
			    				{
			    					f(kk,ll)
			    					{
			    						{
			    							f(ll,mm)
			    							{
			    								f(mm,nn)
			    								{
			    									f(nn,oo)
			    									{
			    										f(oo,pp)
			    										{
			    											f(pp,qq)
			    											{
			    												f(qq,rr)
			    												{
			    													f(rr,ss)
			    													{
			    														f(ss,tt)
			    														{
			    															f(tt,uu)
			    															{
			    																f(uu,vv)
			    																{
			    																	f(vv,ww)
			    																	{
			    																		int m=a[i]+a[j]+a[k]+a[l]+a[ii]+a[jj]+a[kk]+a[ll]+a[mm]+a[nn]+a[oo]+a[pp]+a[qq]+a[rr]+a[ss]+a[tt]+a[uu]+a[vv]+a[ww];
		                                                                                if (zs(m))
		                                                                                  b[m]++;
		                                                                                if (m>mx)
		                                                                                  mx=m;
																					}
																				}
																			}
																		}	
																	}	
																}	
															}
														}
													}
												}
											}
										}
									}
								}
							}
		                }
					}
			    }
		    }
	    }
	}
	for (int i=1;i<=mx;i++)
	{
		if (b[i])
		  c+=b[i];
	}
	cout<<c;
	return 0;
}
```

---

## 作者：憧憬未来 (赞：398)

这道题本人也扣了很长时间，不得不说，基础的递归确实较为简单，但在这道题目中处理重复选择问题真的是很费力，在此，我希望通过题解来帮助在这道题折磨下的同志们好好理解一下。如果我不幸碰到哪位大神犇，请不要说这个程序太low，谢谢啦！

代码中的sqrt（x）的用处：举个例子，9，sqrt（9）=3，所以9可以分解为1\*9或3\*3，一旦越过了3（sqrt（9）），那么之后的分解方式比与先前的分解方式重复（9\*1），这个还是需要自己理解理解。for循环从2到sqrt（x）的好处就是可以简化程序的时间复杂度。

```cpp
#include<cstdio>
#include<cmath>//引入头文件 
using namespace std;
int n,k,a[21],s=0,ans=0;//定义全局变量，方便写函数 
bool f[21];//判断该数有没有被选过，用bool型变量 
int ss(int x)//定义判断素数的函数 
{
    if(x==1||x==0)return 0;//考虑特殊情况（虽然和为1或0不太可能，但还是要预防一下极品数据） 
    for(int i=2;i<=sqrt(x);i+=1)//sqrt为平方根函数，需要调用cmath库，sqrt(x)用处详解请见上
    //从2开始循环是因为任何一个数mod(就是%)1都等于0 
        if(x%i==0)//一旦发现该数能mod尽除1和它本身的数，立即返回0 
            return 0;
    return 1;//若一直运行到i==sart(x)时都没有退出，则该数为素数，自动返回1 
}
int xs(int x,int y)//该函数是本程序中最关键的部分，认真看哦 
{//x为已经选了几个数，y为选第几个数 
    for(int i=y;i<=n;i+=1)//从y~n循环是为了避免重复的出现，例如1234中，选3个，已经选过123 
```
{//与124时，准备为13选下一个数，此时若从1~n循环，则程序会先循环到2，又2此时为true，所以
//程序又会选2，所以123又再一次出现了，与先前所选出的123相重复

if(f[i]==true)//如果该数没有被选过，则执行下列语句，反之，则i+=1或回溯

```cpp
        {
            f[i]=false;//标志该数已经被选过 
            s+=a[i];//将相对应的值累加到s中 
            if(x==k)//如果已经加到了k个数，则运行下列语句 
            {
                if(ss(s))ans+=1;//判断和是否为素数，如果是素数，则ans+=1，标志情况多了一种 
            }
            else xs(x+1,i+1);//若还未加到k个数，则继续搜寻下一个数，所以x+1。i+1则是为了
            //搜寻当前数的下一个数，避免重复 
            s-=a[i];//回溯，累加器s减去a[i]的值 
            f[i]=true;//f[i]还原true，没有被选过
            //注意：两句回溯语句一定要放在else外面，x==k时无法继续往下搜寻，也需要回溯 
        }
    }
}
int main()
{
    scanf("%d%d",&n,&k);//读入共有几个数和每次选几个数 
    for(int i=1;i<=n;i+=1)
    {
        scanf("%d",&a[i]);//读入每个数的值 
        f[i]=true;//将判断该数选没选过的bool型数组初始化 
    }
    xs(1,1);//开始调用选数函数 
    printf("%d",ans);//输出结果 
    return 0;//结束程序 
}
```

---

## 作者：华夏心未老 (赞：271)

**首先直接上程序（脉络图）：**
![脉络图](https://s1.ax1x.com/2018/02/13/9YP7Yd.jpg)
**对于质数的判断有很多种方法，这里不展开，本题的关键就是在n个数中任意选取k个数（k<n）**
![分析](https://s1.ax1x.com/2018/02/13/9YiyB8.png)


### **接下来对change函数进行分析：**
```cpp
void change(int a[], int cb[], int bit, int index, int &k, int &n) {
/*
 *变量说明：
  数组a[]：给出的所有数
  数组cb[]：cb表示“组合”，其中包含k个数，从数组a[]内选取3个数（下标从小到大排序）
  bit：位，k个数的k个位置，也是数组cb[]的下标【数组内是k个数的组合】
  index：指标，由于数组cb[]内的数对应于a[]的下标是从小到大排列的，index是cb[]中第x个数的范围为index~n-1
  ◎建议先看下方的图
  
  k、n：即k、n
*/
	int sum; //k个数之和
	for(int i=index;i<n;i++) {
		cb[bit]=a[i]; //cb[bit]可以是index(=bit)到n-1的所有数
		if(bit<k-1)
			change(a,cb,bit+1,i+1,k,n); //继续执行下一bit，但是下一执行的index要大于i
		if(bit==k-1) { //当组合齐全k个数时，进行计算
			sum=0;
			for(int j=0;j<k;j++)
				sum+=cb[j]; //k个数之和
			if(isprime(sum)) //判断质数
				count++; //结果加1
		}
	}
	
}
```

#### index和bit的区别：
![index和bit的区别](https://s1.ax1x.com/2018/02/13/9YF054.png)



这样，加上质数判断，main函数内解决输入问题，调用change，输出结果，就组成了完整的程序。

---

## 作者：LihRek (赞：197)

~~第一次写题解，瑟瑟发抖~~

思路和之前大佬的题解差不多，数据规模小所以直接深搜即可。区别是，我的代码省略了判断这个数又没有被选过，省略原因下面解释。

AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int ans=0, n, k, a[20];

bool prime(int x) {
	int i;
	for (i = 2; i <= floor(sqrt(x)); i++) {
		if (x%i == 0) {
			return false;
		}
	}
	return true;
}
//上面判素数不解释
void rec(int start, int count, int sum) {
	//rec：递归英文recursion缩写
    //start：开始选数的地方
    //count：已经选了几个数
    //sum：到目前为止选的数的和
	
    int i;
	if (count == k && prime(sum)) {
		ans++;
    	//如果已经选了k个数，判断和是不是素数
        //ans是符合条件的和的个数
	}
	
	for (i = start; i <= n; i++) {
    	//从开始选数的地方到n
        //每重循环都是一种可能性
        //例如：选第二个数，start=2,n=4,有三种可能性，调用自身3次
		
        rec(i + 1, count + 1, sum + a[i]);
		
        //参数1：从a里面下一个数开始选
        //参数2：已经选的数的个数+1
        //参数3：sum加上这次选的数
        
        //因为直接从下一个数开始选，所以不可能选到之前选过的数
        //无需判断当前的数是否被选过
	}
}	

int main() {
	
	int i;
	cin >> n >> k;
	for (i = 1; i <= n; i++) {
		cin >> a[i];
	}
	rec(1, 0, 0);
    //从第一个数开始找，已经找了0个数，目前的和是0
	cout << ans << endl;
	return 0;
}

```

---

## 作者：心对心天 (赞：115)

第一篇题解：因为卡的太久所以发一篇纪念一下，想起做题经过真是55555555；

废话不多说，开始说思路

举个栗子：从1,2,3,4，四个数中选三个数，用一种常规方法~~（小学生都会（wo hen cai））~~；顺序如下

123

124

134

234

完毕；

语言功底不好，自己领会一下，

就是不断更新后面的数，越靠前的越迟更新；

或者换个说法：1后面的数可以是2或3（为啥没有4？）；2后面的数可以是3或4；（此处省略一大段相同的话）；

我的语文好差…………

详细说明在代码里，

自己领悟一会？看代码吧！

```cpp
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int n,k,he,ans,a[21];//he代表
k个数的和；ans记录有几种组合，数组开到21是因为我不喜欢用0号位（同喜好的举个爪？）

int sushu(int m)//素数判断，可以对m开根号优化，不过没必要
{
	for(int i=2;i<m;i++)
	{
		if(m%i==0)
		return 0;
	}
	return 1;//返回1表示是素数，0代表不是，这些0或1都会加到ans里
}
void xuanshu(int l,int f)//核心代码，应该是搜索？我很cai，其中l代表差几个够k个数，f表示选到了第几个数，此数之前不选（就是栗子中的：2的后面绝对没有1）
{
	if(l==0){//如果够k个数了，你懂得
	ans+=sushu(he);
	}
	else{
		f++;
	    for(int i=f;i<=n;i++)//从它之后的都能选，还是那个栗子2后面的3,4都可以，在想想那个栗子，如果1之后选了4会发生什么？
	    {
	    	he+=a[i];
	    	l--;
	    	xuanshu(l,i);
	    	he-=a[i];//这两句是为了清空之前选的那个数（的痕迹）
	    	l++;
		}
	}
	
}
int main()//很水的主程序
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	xuanshu(k,0);
	printf("%d",ans);
	return 0;
 } 
```
第一次题解，不足请指出，呵呵呵

ps：过了好久没看了，有好多评论，首先感谢有人支持，能够帮助到一些人真的很开心，然后解释一下这个头文件的事情吧，当时年纪小，比较二，比较执拗，觉得万能头是一个偷懒的行为，担心万能头用多了，其他的头文件都记不住了，但我确实想偷这个懒，所以想至少不能忘记iostream这个最最基本的头文件吧。所以每次写程序都是打这两个头文件，成习惯了，确实是比较冗余，后来也不会这么做了。还有那些说脏话的同学，你在社会上真是找不到一点存在感是吧，你看不惯我可以理解，你也可以直接说，说脏话这个行为真是有啥生，没啥养啊……

---

## 作者：H3d9 (赞：54)

    这个题的关键在于怎么求从n中取k个数的组合。以下简单介绍取全组合的方法，这里采用递归。

- 首先定义一个数组arr[n]。这个数组包含n个数，要从中取k次，那么考虑从右向左开始取数（不从左往右是因为那样要把取数后剩下的数组单独拿出来，但从右往左取直接用原数组就可以了。）

	```cpp
arr[n] = {1,2,3,4,5};
```

- 现在假设第一个数取得是最右边的元素（arr[n-1]）。那么剩下的元素就要从这个数组中剩下的位置中取了，也就是：从arr[0]到arr[n-2].


	  	arr[n] = {1,2,3,4,5};

	                        ↑取走这个
                    
	     剩下的数组是arr[n-1] = {1,2,3,4},之后要从这里边取k-1个数。


- 因此，我们把要做的递归函数总结一下，它的功能是：从原数组中最右边取一个值，然后从剩下的数组中就是取k-1个值了，从k递减到k-1，仍然是原问题的形式，对不对？这里就是递归的核心：他需要返回k-1，并且记录下此时取走的数，可以暂时理解成我们取的最后一个数。然后返回这个数字前边的数组，作为要取k-1个值的数组，我们剩下的k-1个数要在这里边取。我们设置这个函数体声明如下：

	```cpp
void fun(int k, int n, int sum);
```
    其中k是要取多少个数，n是要从多少数取。定义sum为一组排列的和，我们的目的是调用一次fun，输出全部排列的和。

	
- 但是，我们第一次取的数并不一定非要是数组最后一位，他可以是数组下标n-1~k-1的全部数字（之所以到k-1,因为到了k-1再往前的话，就取不够k-1个数了。）然而，我们取走一个数之后，剩下的k-1个数字必须从取走的那个数之前的这个子数组中取，不能从整个数组中取。因为要保证没有重复的。我们实现这一步的循环结构如下：

	for (int i = n - 1; i >= k - 1; i--)

-     现在考虑第一个数字不从数组末尾开始取（因为他可以从任意数字开始组合。）如下：

		arr[n] = {1,2,3,4,5};
	                 ↑这次为我们取4作为第一个k
	    剩下的数组：arr[n] = {1,2,3}
    
	    现在取k-1个数的话，要从这个子数组中取，才能保证不重复。

	这样的话，我们上述for循环的i即为取的第一个数，那么子数组的长度就是i-1了。这样我们递归本函数，从arr[i-1]中取k-1个数值，并且记录下此时已经取出的i值到sum：
    ```cpp
fun(k - 1, i - 1, sum + arr[i]);
```
- 其实到这里，递归的核心就已经完成了。但我们还需要规定递归结束的边界条件，也就是当取完全部数字时,此时k=0.如果判断k=0,就输出sum，然后结束调用。
    
   ```cpp
 if (k == 0) { std::cout << sum; return; }
```
- 所以我们要求Cnk的全组合中，每一个组合的和所用的函数就如下所示：
    ```cpp
void fun(int k, int n, int sum)
{
	if (k == 0) { std::cout << sum << " "; return; }
	for (int i = n - 1; i >= k - 1; i--)
		fun(k - 1, i - 1, sum + arr[i]);
}
```
调用该函数时，首先把你的数组放入arr[]，代入数组长度n,那么fun(n,k,0);就会输出该数组全部排列分别的和啦。

- 至于这个题剩下的部分我想不用我说大家也就清楚了吧，直接把这个函数的输出部分替换成判断是不是质数就好了。



---

## 作者：lenaalyth (赞：50)

这是一个数学问题。。。因为不会剪枝，没法搞定重复选择。。。所以。。。我用了数学做法。。。完全不考虑重复。。。最后直接利用组合数出去他重复的个数。。请大神们指导。在此献给那些和我一样不会剪枝的新手菜鸡们

废话不多说，出代码：

    
    
```cpp
    #include <cstdio>
    #include<cstring>
    #include <string>
    #include <iostream>
    #include <algorithm>
    #include <cmath>
    using namespace std;
    long long int a[30],b[30],n,m,we=0,v=0,g[30],w7,g1=1;
    bool sushu(int x)
    {
        int i,t=1;
        if(x==1){return false;}
        else if(x==2||x==3){return true;}
        for(i=2;i*i<=x;i++)
        {
            if(x%i==0)
            {t=0;
            break;
            }
        }
        if(t){return true;}
        else{return false;}
    }
    void dfs(int x,int y)
    {if(y==0)
    {
        if(sushu(v))
        {we++;}
        return ;
    }
    else
    {
        for(int w1=0;w1<x;w1++)
        {
            if(b[w1]==0)
            {
                b[w1]=1;
                v+=a[w1];
                dfs(x,y-1);
                b[w1]=0;
                v-=a[w1];
            }
        }
    }    
    }
    int main()
    {    
        for(w7=1;w7<21;w7++)
        {g1*=w7;
        g[w7]=g1;
        }
        scanf("%lld %lld",&n,&m);
        for(int w0=0;w0<n;w0++){scanf("%d",&a[w0]);}
        dfs(n,m);
        printf("%lld",we/g[m]);
        return 0;
    }

```

---

## 作者：user_13792298367 (赞：31)

这个题我也是卡了好久，看书的时候突然想到用深度搜索很适合解这道题。
我设置的变量是 
- i,代表第i个数
- nums，代表已经加了几个数
- sum，加了nums个数之后的总和
- ans，要输出的答案，初始化为0

dfs函数如下：dfs（i，nums，sum）
思路是，在面对第i个数时，我们有两种选择，一个是加第i个数，一个是不加第i个数，加的话，我们就把i+1（处理下一个数），sums+1，sum+num[i]放到dfs里递归，不加的话，就把i+1（还是要处理下个数），nums，sum（不用动，因为没有加第i个数）放到dfs里递归。

还有限制条件，如果nums==k时，就代表已经加了k个数，此时检测sum是否是素数，如果是的话，ans++。

还有i要小于等于n，不说了看代码吧

```cpp
#include <iostream>

using namespace std;
bool isPrime(int n)
{
    for(int i=2; i<n; i++)
    {
        if(n%i==0)
        {
            return 0;
        }
    }
    return 1;
}

int num[22]={0};
int n,k,ans=0;

int dfs(int i,int nums,int sum){
    if(nums==k){
        if(isPrime(sum)){
            ans++;
        }
    }
    else if(i<=n){
        dfs(i+1,nums,sum);
        dfs(i+1,nums+1,sum+num[i]);
    }

}

int main()
{
    cin>>n>>k;

    for(int i=1;i<=n;i++){
        cin>>num[i];
    }

    dfs(1,0,0);
    cout<<ans;
    return 0;
}


```

---

## 作者：任弈凡 (赞：18)

这道题就是一个深搜题，每个述数两种情况选或不选，直到选的数有k个或要选的数超过了n
代码如下：
```
#include<iostream>
using namespace std;
int n,a[30003],k,ans;
int js(int x)//判断质数
{
    for(int i=2;i*i<=x;i++)
    if(x%i==0) return 0;
    return 1;
}
void dfs(int p,int x,int sum)
{
    if(x==k)//如果选了k个数
    {
        if(js(sum)==1) ans++;//如果和是质数,ans++
        return ;
    }
    if(p==n+1)
    return ;//如果超过了选的数，直接return 
    dfs(p+1,x+1,sum+a[p]);//两个dfs
    dfs(p+1,x,sum);
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    dfs(1,0,0);
    //dfs(要选的个数，已选的个数,以选的数的和)
    cout<<ans;
}
```

---

## 作者：hoetateyo (赞：14)

本人大概是最弱的橙名了吧...一条咸鱼看着周围的大佬们瑟瑟发抖....

进入正题.这道题暴搜居然没有TLE,心情大好,来发篇题解,希望能帮上有需要的人的忙.

既然放在了过程函数和递归中,首先想到的就是用递归解决.首先考虑得到了一个和,如何判断它是不是质数?朴素方法,设这个数为n,从2至n-1,依此判断是否能整除n,如果发现存在某个整数能够整除n,那么n不是质数,否则是.显然循环次数规模与n相同.

简单优化,显然一个整数n若可以用两个整数的乘积表示,那么其中小一点的约数不会超过&radic;n.我们以60为例 ~~(试图隐藏我不打算证明的事实)~~ :
>60=1\*60=2\*30=3\*20=4\*15=5\*12=6\*10=10\*6=..

显然,当超过&radic;60=7时开始前面的数就是较大的约数了.因此,可以将枚举范围缩小到\[2,&radic;n\],时间复杂度降低到O(&radic;n).简要代码如下:
```cpp
bool isp(int a)//返回a是否为质数
{
  int sq=sqrt(a);//调用函数求a的算术平方根.注意sqrt()函数在cmath中.提前算出可以避免每次循环都计算一次a的算术平方根,可以减小常数
  for(int i=2;i<=sq;i++) if(a%i==0) return false;
  return true;
}
```

考虑可能需要进行多次判断,即使如此优化仍可能超时,考虑一个更优的方法:注意到相加得到的和最大不超过10<sup>7</sup>,可以构造一个质数表,每次检查n是否为质数只需要查表即可.如何构造一个这样的质数表呢?显然由质数的定义可以得到,一个质数的任意整倍数(除其自身外)都不是质数,任意一个整数都可以被表示为某(几)个质数的乘积,也就是说任意的整数都是某(几)个质数的整倍数.因此只需将任意一个质数的二倍及以上的整倍数标记为"非质数",就可以获得这样的一张质数表了.简要代码如下:
```cpp
const int MAX=10000010;
bool notp[MAX];//质数表,当notp[i]==0时i为质数.注意开够空间

void calp(void)//开始构造质数表
{
    for(int i=2;i<MAX;i++) if(!notp[i]) for(int j=i+i;j<MAX;j+=i) notp[j]=1;//当前的i是质数,因此将其所有二倍及以上的整倍数都设为非质数.注意不要越界
    return;
}
```

这样一来就更优了.简单 ~~(胡乱)~~ 分析一波:外层循环将重复约10<sup>7</sup>次,若i不是质数则内层将仅进行1次判断,否则在判断后还将进行约(10<sup>7</sup>-i)/i次赋值操作.实验证明 ~~(再次尝试隐藏自己不打算推式子的事实)~~ ,该函数的循环仅会运行3.95x10<sup>7</sup>次,反复改变MAX的值可以发现运行次数与MAX的一次方成正比,即该方法可以在线性时间内构造质数表.为了确认自己已经理解了这一部分,建议先前去完成[P3383 \[模板\]线性筛素数](https://www.luogu.org/problemnew/show/P3383).

到目前为止,我们获得了初始化时间复杂度为O(n),查询时间复杂度为O(1)的质数表.下面,我们尝试回到原来的问题,看看我们还缺些什么.

我们需要从n个数中选出k个并计算它们的和.为了暴搜,我们需要寻找一种方法唯一地定义当前状态.很容易想到需要一个集合E表示已选择的数.可以用一个数组visited,标记所有已选的数的visited为1.像是这样:
```
//假设选了i
visited[i]=1;
cal();//递归调用
visited[i]=0;//还原确保之后不会漏选某种情况
```

可以很容易的利用visited统计已选的数的个数和和.看起来不错.但是不要容易确保不会选重的同时不选漏.比如

> a[1]+a[2]+a[5],a[5]+a[2]+a[1]

而且每次查找visited也不够优美,应该还有更简单的解决办法.

很容易注意到,每次只向后看是不会漏选的.举例,如当前选到的数中下标最大的是low,那么选下一个数的时候只从下标为\[low+1,n\]的数中选不会导致缺失情况也不会导致重复 ~~(依然不证明)~~ ,因此可以重新定义当前状态:还须选i个数,当前的和为sum,当前已经看完了下标为k及以前的数.这样就确保了每次不需要检查重复的情况,也不需要管具体选择了哪些书,只要一一枚举k以后的数并递归调用就可以了,极大的简化了问题.

递归边界也不难得出:当还须选0个数的时候,已经选够了,判断当前的和是否为质数,如果是返回1,否则返回0.而非边界的时候则进行枚举,计算所有情况得到的返回值的和并返回,我们的函数返回值即使在当前限定条件下(从下标大于k的数中选i个数,在sum的基础上加上选的数的和结果是质数)的情况数.显然在主函数中调用cal(k,0,0)得到的返回值即为结果(注意,这里的k与函数中的k含义不同,此处于题目描述一致,请仔细确认不同k的含义).

最后还有一个小小的可行性剪枝:若cal函数中发现n-k<i则返回0.为了确认理解了k的含义,请自行思考理由.

附上AC代码(上面解释过的部分此处不再加注释):
```cpp
#include<cstdio>//虽然使用的是c++,但由于c的输入输出更快,倾向于使用c的输入输出
using namespace std;
const int MAX=10000010;
bool notp[MAX];
int a[25];//保存数据
int n;//函数中需要使用,为了方便设为全局变量

void calp(void)
{
    for(int i=2;i<MAX;i++) if(!notp[i]) for(int j=i+i;j<MAX;j+=i) notp[j]=1;
    return;
}

int cal(int i,int sum,int k)    //再选i个,当前和为sum,看完了a[k]
{
    if(i==0)
    {
        if(notp[sum]) return 0;
        else return 1;
    }
    
    if(n-k<i) return 0;
    
    int ans=0;
    for(int j=k+1;j<=n;j++) ans+=cal(i-1,sum+a[j],j);
    return ans;
}

int main()
{
    calp();
    int k;
    //关于输入输出的问题请自行查找资料/请教他人解决
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    printf("%d",cal(k,0,0));
    return 0;
}
```
至此,虽然并没有使用更高效率的方法,我们依然以尚可以接受的时间通过了这道题.强烈建议再去完成[P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706),使用类似的方法完成一道题可以加深理解.

最后,本人蒟蒻一棵 ~~(棵?)~~,有不准确的地方请…用力喷\!我会回来改正的.

---

## 作者：KagurazakaKano (赞：12)

看了下好像没状压的题解，那么本蒟蒻来水一发

~~大佬们是看到数据范围没想过就状压吗？~~

具体思路：将每个排列按照01串存储，0代表相应位置的数字没有选中，1代表相应数字选中了。

举个例子：对于序列
```
2 4 5 6 3
```
我们有01串：
```
01001
```
就相当于我们选择了`4和3`两个数。

### 我们难道要开一个非常大的数组来存储和访问这些串？

### 不需要！

我们把每个01串对应的十进制数作为数组下标即可。

例如上面的`01001`，我们可以用9来表示。

这样我们只要枚举每个01串，使得其中的1的个数等于$k$（相当于保证了选中$k$个)，并且选择的数加起来的总和是个素数即可。

那么我们可以用$f$数组来存储每个01串对应的结果即可。

比如上述选择中，$f_9 = 7$

附：代码中的位运算（状压很可能用到，是非常基础的位运算）

| C++写法 | 含义 |
| :----------: | :----------: |
| $a >> 1$ | 将$a$右移一位 |
| $a$ & $1$ | 取$a$的最后一位 |


### 注意：笔者的状压跟之前讲的是反过来写的，也就是说对于前面的01001，笔者按照代码的思路选择的是2和6（正数第一个和第四个），前面讲的是选择倒数第一个和第四个

```
#include <cstdio>
#include <cmath>

using namespace std;

int a[25];
int f[2098000];
//f数组用来存储每个状态，表示每个下标对应的01串的时候，这个总和是多少。
//在状压中一定要注意的一个问题：一般状压只能适用于n <= 20的数据，再大可能就MLE了
//本题中的数据是n <= 20，状态总共有2^20，是2,097,152，保险一点开大点。


int chk(int x){
	for(int i = 2; i * i <= x; i++){
		if(x % i == 0){
			return false;
		}
	}
	return true;
}
//用来判断是否是质数的函数。

int main(){
	int n,k,ans = 0;
	scanf("%d%d",&n,&k);
	for(int i = 1; i <= n; i++){
		scanf("%d",&a[i]);
	}
    //读入
	int q = pow(2, n);
    //求出一共有多少种状态
    
    //以下代码请认真理解！是状压的核心代码部分
	for(int i = 1; i <= q; i++){ //遍历每个状态
		int tmp = i, cnt = 1, tem = 0;
		int hm = 0;
		while(tmp){  //tmp代表的是目前的状态
			if(tmp & 1){  //如果目前的状态的最后一位是1
				tem += a[cnt]; //将a[cnt]加入temp
				hm++;  //选中的位数+1
			}
			cnt++;  //总共的位数+1
			tmp >>= 1;  //tmp右移
		}
		if((chk(tem)) && (hm == k)){//如果这个总和是素数并且选中的数的个数等于k
			ans++;
		}
		tem = 0;
		cnt = 0;
	}
    
    
	printf("%d",ans);
	return 0;
}
```

---

## 作者：traceson (赞：12)

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,k;
int a[30];
int b[30];
bool vis[30];//判重
int sum=0;//答案
bool judge(long long x)//判断x是否是质数
{
    for(int i=2;i<=sqrt(x);i++)//只用枚举到根号下x（也是一个剪枝）
    if(x%i==0) return false;//发现一个因数则可跳出，x就一定不是
    return true;
}
void dfs(int x,int now,long long ans)//分别表示当前选到了第x位，now一共选了多少数，ans选到现在的和
{
    if(now==k)//已经选够了k个数，即已经有了一种方案
    {
        if(judge(ans)) sum++;//判断当前方案是否满足题，可以就将答案加一
        /*for(int i=0;i<now;i++)
        printf("%d ",b[i]);
        printf("\n");*///此处可用于观察每次都选取了那些数
    } 
    else
    {
        for(int i=1;i<=n;i++)
        {
            if(!vis[i]&&i>x)
            {
                vis[i]=true;//标记是否已经选取
                //b[now]=a[i]; //此行只适用于检查，方便大家检查每次选那些数是使用，与本题无关
                dfs(i,now+1,ans+a[i]);//递归找下一个数
                vis[i]=false;//回溯（很重要）！！！！
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    dfs(0,0,0);//解释一下第一个0也就是dfs中的x是用来判重的，这样可以节约时间（因为一组数中选第一第二第三个和
//选第一第三第二个其意义是一样的,如1 5 3 2 4中选1 3 2和选1 2 3是一样的）
    printf("%d",sum);
    return 0;
}
//最后，如有不妥，敬请指教。
```

---

## 作者：lvdzxcvb (赞：11)

[h1 ]简单 深搜。。传递3个参数。一个传递当前选择的数的下标，一个传递已选择数的个数，一个选择以选择的数的总和[/h1 ]


```cpp
[codec ]#include<cstdio>
#include<cmath>
using namespace std;
const int maxn = 22;
int a[maxn];
int ans,n,k;
bool isprim(int num){
    for(int i=2;i<=sqrt(num);i++)
    if(num%i==0) return false;
    return true;
}
void dfs(int cur,int cnt,int num){
    if(cnt==k){
        if(isprim(num)){
           ans++;
        }
        return ;
    }
    for(int i=cur;i<=n;i++){
        dfs(i+1,cnt+1,num+a[i]);
    }
}
int main(){
     freopen("choose.in","r",stdin);
    freopen("choose.out","w",stdout);
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)  scanf("%d",&a[i]);
    dfs(1,0,0);
    printf("%d\n",ans);
    return 0;
}[/codec ]

```

---

## 作者：Imakf (赞：10)

### **题目分析**

题目要求我们在n个数中选出k个数，求出有多少种**和**可能是素数的情况

如何求素数：

#### **线性筛**

```cpp
void pri(int end){
    prime[0]=prime[1]=1;
    for(int i=2;i*i<=end;i++){
        if(!prime[i]){
            for(int j=i*i;j<=end;j+=i)
                prime[j]=1;
        }
    }
}
```
本蒟蒻只会线性筛，其基本流程为
1.建一个数组prime[100000001]用来表示 这个数是不是素数（**true表示不是 false表示是**）


2.给定要求的最大区间maxn

3.将i从2枚举到sqrt(maxn) 若prime[i]==false 则到第四步

4.将j从i\*i 枚举到maxn每次j=+i 然后把prime[j]标记为true 返回第3步

#### **简单dfs与回溯**（解释放入代码中）

```cpp
void search(int gs,int ans,int mx){
                //gs为已经选取的数字个数
                //ans是已经选取的数字和
                //mx是上一次选过的数字的下标+1
                //为什么需要mx？
                //为了不让选择出现重复
    if(gs==k){    //选出了k个数
        if(!prime[ans]){//如果是素数
            rans++;
//            printf("%d\n",ans);
        }    
        return;
    }
    for(int i=mx;i<=n;i++){//从mx开始选择（枚举）
        if(!book[i]){//没被选过
            book[i]=1;
            search(gs+1,ans+a[i],i+1);//继续搜
            book[i]=0;//回溯
        }
    }
}
```
## AC代码
```cpp
#######include<iostream>
#######include<cstdio>
using namespace std;
bool prime[100000001],book[5000000+1];
int n,k,a[5000000+1],rans; //rans是答案
void pri(int end){
    prime[0]=prime[1]=1;
    for(int i=2;i*i<=end;i++){
        if(!prime[i]){
            for(int j=i*i;j<=end;j+=i)
                prime[j]=1;
        }
    }
}
//dfs与回溯------------------------------
void search(int gs,int ans,int mx){
    if(gs==k){
        if(!prime[ans]){
            rans++;
//            printf("%d\n",ans);
        }    
        return;
    }
    for(int i=mx;i<=n;i++){
        if(!book[i]){
            book[i]=1;
            search(gs+1,ans+a[i],i+1);
            book[i]=0;
        }
    }
}
int main(){
    long long max=0;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        max+=a[i];//求出最大可能的素数
    }
    pri(max);
    search(0,0,1);
    printf("%d",rans);
    return 0;
}
```
### 关联题目
P3383 【模板】线性筛素数

P1706  全排列问题


---

## 作者：WHU2017301500335 (赞：10)

我的算法不同于前面几位大牛，我使用递归，代码如下所示

```cpp

//使用数组input保存各个数字是否被用过的标志，使用数组a保存输入的数字
#include <stdio.h>
#include <math.h>
#include <string.h>
#define MAX 40
int sort=0,n,k,a[MAX];
int sushu(int x) //是素数返回1，不是返回0
{
    int i,y;
    y=sqrt(x);
    for(i=2;i<=y;i++)
        if(x%i==0)
            return 0;
    return 1;
}
void f(int input[],int pos,int m) //f(被操作数组，所在位置，选m个数)
{
    if(m==0)
    {
        int j,sum=0;
        for(j=0;j<n;j++)
            if(input[j]==1)
                sum+=a[j];
        if(sushu(sum)==1)
            sort++;
        return;
    }
    else
    {
        int i;
        for(i=pos;i<n;i++)
        {
            if(input[i]==0)
                input[i]=1;
                f(input,i+1,m-1);
                input[i]=0;
        }
    }
    return;
}
int main()
{
    int input[MAX],i;
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++)
        scanf("%d",&a[i]);
    memset(input,0,sizeof(int)*MAX);
    f(input,0,k);
    printf("%d\n",sort);
    return 0;
}

```

---

## 作者：森系 (赞：9)

我的第一篇题解，记录一下。
看到这道题，第一想到的是怎么从n个数中选择k个数，再判断k个数相加是否为素数，是的话，ans+1.
我们先来看看怎么选k个数，我用了一个数组b[k]保存.
代码：
```
void dfs(int x,int y)
{
    if(x==k+1)
    {
        for(int i=1;i<=k;i++)
        {
            printf("%d ",b[i]);
        }
        printf("\n");
        ss=0;
    }
    else
    {
        for(int i=y;i<=n;i++)
        {
            if(f[i])
            {
                b[x]=a[i];
                f[i]=false;
                dfs(x+1,i+1);
                f[i]=true;
            }
        }
    }
}
```


接下来就很简单了，只要稍微改一下，变为b[k]相加，再判断是否为素数，是的话ans++即可
完整代码：
```cpp
# include <cstdio>
# include <cmath>
# include <iostream>
using namespace std;

int n,k,a[22],ss=0,ans=0,b[100];
bool f[22];

int prime(int x)
{
    int i;
    for(i=2;i<x;i++)
    {
        if(x%i==0)
        {
            break;
        }
    }
    if(i>=x)
        return 1;
    else
        return 0;
}

void dfs(int x,int y)
{
    if(x==k+1)
    {
        for(int i=1;i<=k;i++)
        {
            ss=ss+b[i];
        }
        //printf("%d\n",ss);
        if(prime(ss))
        {
            ans++;
        }
        ss=0;
    }
    else
    {
        for(int i=y;i<=n;i++)
        {
            if(f[i])
            {
                b[x]=a[i];
                f[i]=false;
                dfs(x+1,i+1);
                f[i]=true;
            }
        }
    }
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        f[i]=true;
    }
    dfs(1,1);
    printf("%d\n",ans);
	return 0;
}

```


---

## 作者：AlexZy (赞：8)

**Python题解**

并不会什么深搜，只能直接，粗暴地算hhhhhh，蒟蒻警告！

附上

```python
#加载包,numpy用于简化计算，combination用于组合
import numpy as np
from itertools import combinations
#输入和定义变量
nums_len,sum_nums = map(int,input().split())
nums = list(map(int,input().split()))
count = 0
array_sum = 0
#定义一个筛选素数的函数,时间复杂度为根号n/3
def prime_number(number):
    if number <=3:
        return True
    elif number % 2 == 0 or number % 3 ==0:
        return False
    else:
        i = 5
        while i * i <= number:
            if number % i  == 0 or number % (i+2) == 0:
                return False
            i += 6
    return True
#遍历所有组合
for tem_combin in combinations(nums,sum_nums):
    #将组合转化为数组
    array = np.array(tem_combin)
    #数组求和
    array_sum = array.sum()
    #如果为素数，就计数
    if prime_number(array_sum):
        count += 1
print(count)
```

---

## 作者：「QQ红包」 (赞：7)

深搜就好。

然后2+3=5和3+2=5属于一种情况。

```delphi

var n,k,i,j,s,sum:longint;  
    a:array [1..20] of longint;  
    b:array [1..20] of boolean;  
    c:array [1..200] of longint;   
function pd(ss:longint):boolean;  //判断是否为质数
var i:longint;  
    f:boolean;  
begin  
    pd:=true;  
    for i:=2 to trunc(sqrt(s)) do  
    if ss mod i=0 then pd:=false;  
end;  
procedure try(t,x:longint);  //深搜部分
var i,j,l:longint;  
    f:boolean;  
begin  
    for i:=x+1 to n do  
    if b[i] then  
    begin  
        b[i]:=false;  
        inc(s,a[i]);  
        if (t=k) then  
        begin  
            if (pd(s))then inc(sum);  
        end else  try(t+1,i);  
        b[i]:=true;  
        dec(s,a[i]);  
    end;  
end;  
begin  
    read(n,k);  
    sum:=0;  
    for i:=1 to n do  
    read(a[i]);   
    fillchar(b,sizeof(b),true);  
    fillchar(c,sizeof(c),0);  
    try(1,0);  
    write(sum);  
end.  

```

---

## 作者：liuzitong (赞：7)

# dalao们各种秀,各种方法都会,我只会暴搜.
这个题我根据全排列改了改(真难改);

## 本蒟蒻的思落是:全排列+暴搜去重(非最优解)

这道普及-
让本蒟蒻做了一晚上+半个上午(实际我不会深搜回溯,全靠框架+去重);

注释解释的很全,我在前面不说了;

下面让我分享下本蒟蒻的

蒟蒻代
```cpp
/*
                   .-' _..`.
                  /  .'_.'.'
                 | .' (.)`.
                 ;'   ,_   `.
 .--.__________.'    ;  `.;-'
|  ./               /
|  |               / 
`..'`-._  _____, ..'
     / | |     | |\ \
    / /| |     | | \ \
   / / | |     | |  \ \
  /_/  |_|     |_|   \_\
 |__\  |__\    |__\  |__\
 */
 (不要问我为什么是"马")
#include<bits/stdc++.h>
using namespace std;
int n,r,ttt;//n是总数,r是选的数,ttt是答案
int a[1001],b2[1001],c[10001][101];//a用来储存排列的编号,b2用来储存输入的数,c用来去重(储存符合条件的数组的编号)
bool b[1001];//用来判断是否用过
bool ss2(int t[]){//暴搜判重
    int tot=0;//计数器
    for(int i=1;i<=ttt;i++){//循环所有储存的数组
        for(int j=1;j<=r;j++){//循环r次,比较每一个字符
            if(t[j] != c[i][j])//判重
                tot++;
        }
        if(tot==0)//如果没有一个不一样的说明重复
            return 0;
        tot=0;//一定要清空!!!!
    }
    return 1;//如果全不重复,说明不重
}
bool sus(int y){//判断素数
    if(y==0||y==1)//防止特殊值
        return 0;
    if(y==2)
        return 1;
    for(int i=2;i<=sqrt(y);i++){//循环到sqrt就够了
        if(y%i==0)
            return 0;
    }
    return 1;
}
void print(){//其实不能叫print,因为没有输出
    
    int y=0;
    int b3[r+1];//定义新数组避免动原先(a)数组
    for(int i=1;i<=r;i++)//判断素数
        y+=b2[a[i]];
    if(sus(y)==1){//不是素数直接跳过
        for(int i=1;i<=r;i++)
            b3[i]=a[i];
        sort(b3+1,b3+r+1);//一定要排序,因为类似"组合"
        if(ss2(b3)==1){//如果不重复
            u++;//这一步可以不要
            ttt++;//答案加1
            for(int i=1;i<=r;i++)
                c[u][i]=b3[i] ;//如果不要u++这里u要换成ttt 
        }
        
    }
    
}
void ss(int k){//程序主体 
    for(int i=1;i<=n;i++){
        if(b[i] ==0){//只要没标记过就能用 
            a[k]=i;//记录编号 
            b[i]=1;//标记 
            if(k==r) print();//到了r"输出" 
            else ss(k+1);//否则继续 
            b[i]=0;//回溯 
        }
    }
}
int main(){
    cin>>n>>r;//输入 
    for(int i=1;i<=n;i++)
        cin>>b2[i];
    ss(1);//深搜 
    cout<<ttt;//输出答案 
    return 0;
}
```
本蒟蒻的第2篇正经题解(不过审核就按不正经算的话)

---

## 作者：__hao__ (赞：5)

可以深搜一下。。分享一种思路....

i是当前下标，按顺序过一遍， r是还需要选的数的个数，sum是当前已经选了的数的和。

如果n - i剩下能选的 小于 还要选的个数就返回退出

如果选到了k个，即r = 0，就判断下sum是不是质数

然后dfs(i + 1, r - 1, sum + x[i]) 选第i个数的情况




```cpp
dfs(i + 1, r, sum) 不选第i个数的情况
#include <iostream>
#include <cmath>
using namespace std;
bool is_prime(long long n)
{
    for (long long i = 2; i <= sqrt(n); ++i) {
        if (n % i == 0)
            return false;
    }
    return true;
}
int x[25], n, k, cnt;
void dfs(int i, int r, long long sum)
{
    if (n - i < r)
        return;
    if (r == 0) {
        if (is_prime(sum))
            cnt++;
        return;
    }
    dfs(i + 1, r - 1, sum + x[i]);
    dfs(i + 1, r, sum);
}
int main()
{
    cin >> n >> k;
    for (int i = 0; i < n; ++i)
        cin >> x[i];
    dfs(0, k, 0);
    cout << cnt << endl;
}
```

---

## 作者：李孟禹 (赞：4)

我一开始就是在想深度搜索，然后照着全排列的思路来搞了。。。发现不对之后再改的

```cpp
#include<iostream>
using namespace std;
bool list[5000005],book[20];
int n,k,arr[20],counter;

void CreatList(){//筛一个素数表 list 
    for(int i=2;i<=5000000;i++){
        if(list[i]==0)
        for(int j=2;i*j<=5000000;j++){
            list[i*j]=1;
        }
    }
}

bool check(){//检查 是否符合标准 
    int sum=0;
    for(int i=0;i<n;i++){
        if(book[i]==true){
            sum+=arr[i];
        }
    }
    if(list[sum]==0)
        return true;
    return false;
}

void dfs(int step,int before){//深搜 
    if(step==k+1){
        if(check()==true)
            counter++;
    }else{
        for(int i=before+1;i<n;i++){//i从before开始 表示从小开始选 
            if(book[i]==false){
                book[i]=true; //标记一下 表示已经用过了 
                dfs(step+1,i);
                book[i]=false;//关键 
            }
        }
    }
}

int main(){
    CreatList();
    cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    dfs(1,-1);
    printf("%d\n",counter);
    return 0;
}
```

---

## 作者：x_forever (赞：4)

其实这道题用    ***DFS(深度优先搜索)*** 就可以了！

###### （看到很多大神用递归，没有必要）

------------

思路是这样的:

1. 输入

1. 调用DFS(深度优先搜索)的过程

1. - 如果找到一种答案就判断它是否为素数

|如果是素数就ss+1

|如果不是素数就什么都不干

|退出

- 如果并没有找到一种答案就继续试

1. 输出

------------

> 我提供一种素数的判断函数：
------------

```cpp
    function ssx(n:xt):boolean;
    var  i:xt;
    begin
    ssx:=true;
    for i:=2 to trunc(sqrt(n)) do
        if n mod i=0 then exit(false);
        //从2到n的平方根（注意要舍去小数部分，pascal可以用trunc（），C++可以用floor（）），时间优化
    end;
```
------------
> 下面是AC代码：
------------

```cpp
    type
        st=0..20; xt=0..5000000;
    var
    n,k,i:st; ss:integer;
    a:array [1..20] of xt;
    function ssx(n:xt):boolean;                //素数的判断
    var  i:xt;
    begin
    ssx:=true;
    for i:=2 to trunc(sqrt(n)) do  //从2到n的平方根，时间优化
        if n mod i=0 then exit(false);
    end;
    procedure DFS(ans:int64;xx,b:st);    //深度优先搜索，DFS
    var i:st;
    begin
    if xx=k then
        begin if ssx(ans) then inc(ss);exit; end;    //找到一种答案就判断它是否为素数
    for i:=b to n do                //从b开始是为了以防重复
            DFS(ans+a[i],xx+1,i+1);
    end;
    begin
    readln(n,k); ss:=0;
    for i:=1 to n do read(a[i]);
    readln;
    DFS(0,0,1);                    //开始深度优先搜索
    writeln(ss);                   //输出答案
    readln;
    end.
```
------------
很简单吧！但是 ***AC*** 了哟！


---

## 作者：magolor (赞：4)

题解同样是DFS，不同之处在于采用了简化的（自己YY的）Miller-Rabin法判断质数，而不需要质数表，节省了空间和时间!









    
    


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <ctime>
using namespace std;
#define ll long long
#define T 100
#define CARMI 17
ll n,k,a[25];
bool book[25];
ll Carmichael[CARMI] = {1,561,1105,1729,2465,2821,6601,8911,10585,15841,29341,41041,46657,52633,62745,63973,75361};
ll fastpow(ll a, ll n, ll MOD)
{
    for(ll s = a, t = a = 1; n; n >>= 1)
        a = (n&1 ? a*s : a)%MOD, s = s*s%MOD;
    return a;
}
bool Prime_Check(ll x)
{
    srand(time(NULL));
    if(x == 2 || x == 3)
        return true;
    //1. No Carmichael Number
    if(binary_search(Carmichael,Carmichael+CARMI,n))
        return false;
    //2. Fermat Theory
    int cnt = 0;
    for(int i = 0, a; i < T; i++)
    {
        a = rand();
        if(fastpow(a,x-1,x)%x - 1)
            cnt--;
        else
            cnt++;
    }    
    //3. Second Check
    return (cnt >= 0 && ((x-1)*(x-1)%x == 1));
}
ll DFS(ll dfn, ll sum, int pos)
{
    if(dfn == k)
        return Prime_Check(sum);
    ll ans = 0;
    for(int i = pos; i < n; i++)
        if(!book[i])
        {
            book[i] = true;
            ans += DFS(dfn+1,sum+a[i],i+1);
            book[i] = false;
        }
    return ans;
}
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i = 0; i < n; i++)
        scanf("%lld",a+i);
    printf("%lld",DFS(0,0,0));
    return 0;
}
```

---

## 作者：Forgetter (赞：3)

初学java，发表一下自己写的代码，如有错误之处谢谢指出~\(≧▽≦)/~
### 思路：
写一个生成数字组合(无序)的方法、写一个求和的方法、写一个判断是否为素数的方法。每排出一个组合直接调用后面两种方法，是素数则计数+1，最后输出计数结果完事了。
### 代码：
```java
import java.util.*;

public class SuShu {
	private static ArrayList<Integer> arr = new ArrayList<>();
	private static int count;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n,k;
		int[] a;
		while(sc.hasNext()) {//有数据输入程序不停

			int m=count=0;
			n = sc.nextInt();					//总共n个数
			k = sc.nextInt();					//选k个数
			if(n<1||n>20||k>=n) continue;		// (1≤n≤20,k<n)
			
			a = new int[n];					  //new一个新的数组
			for (int i = 0; i < n; i++) {
				m = sc.nextInt();
				if(!(m>=1||m<=5000000)) continue;//(1≤xi≤5000000)
				a[i] = m;						//给n个元素赋值
			}
            

			plxu(0,k,a);
			System.out.println(count);
			
		}sc.close();
	}
	
	//列表求和
	public static int he(ArrayList<Integer> arr){
		int sum = 0;
		for(int i=0;i<arr.size();i++) {
			sum += arr.get(i);		//逐项相加即可
		}
		return sum;
	}
	
	//数字组合(用递归哟)
	public static void plxu(int index,int k,int[] a) {
		if(k == 1) {	//k==1的时候作为递归的出口
			for(int i=index;i<a.length;i++) {
				arr.add(a[i]);	//加最后一个数，到这一步的时候，组合就已经完成了
				//System.out.println(arr.toString()+" 的和为："+he(arr));//打印一下
				if(isPrim(he(arr)))	count++;	//如果"和"为素数则计数+1
				arr.remove(arr.size()-1);	//删除最后一个数，完成for的其他组合情况
			}
			
		}else if(k > 1) {
			for(int i = index;i <= a.length-k; i++) {//范围依据k的大小，起码要可以有k个数
				arr.add(a[i]);			   //加一个数
				plxu(i+1,k-1,a);
				arr.remove(arr.size()-1);	//删除刚刚加的一个数，完成说有的可能
			}
		}else {
			return;			
		}
	}

	//判断是否为素数
	public static boolean isPrim(int a) {	
		boolean flag = true;
		for(int i=2;i<=Math.sqrt(a);i++) {
			if(a%i == 0) {		//被 2~√a 之间的数整除则不是素数哦 
				flag = false;	
				break;			//被一个数判断不是，则后面不用判断
			}
		}
		return flag;
	}
}

```

---

## 作者：合451518 (赞：3)

思路：深度搜索。

解释：深搜dfs函数中，sum指当前选的数的和，step指上一步选的数为a[step]，num指已经选了num个数。

出口：当num=k时，已经选中k个数，判断sum的值，并退出函数。

注意：此处不需要控制step>n的情况，因为在后面for循环中i的取值会控制。

函数后部的for循环穷举下一个选中的数，并每一次都进行下一级的搜索。

注意：

1）为了使最后的值不重复，需要将a[]数组排序（这里用快排纯粹是吃饱了撑的，其实就20个数...）

2）在判断是否为质数时，检验因数中i只需要试到trunc(sqrt(X))

3）切记，dfs函数的出口中，无论sum的值是否满足，都要退出，不能写成




 

 
 
```cpp
  if num=k then if prime(num) then begin inc(ans);exit;end;.
var
 a:array[1..20] of longint;
 n,k,ans,i:longint;
procedure sort(l,r:longint);
var
 i,j,x,t:longint;
begin
 i:=l;
 j:=r;
 x:=a[(l+r) div 2];
 repeat
  while a[i]<x do inc(i);
  while x<a[j] do dec(j);
  if i<=j then begin
   t:=a[i];a[i]:=a[j];a[j]:=t;
   inc(i);
   dec(j);
  end;
 until i>j;
 if l<j then sort(l,j);
 if i<r then sort(i,r);
end;
function prime(x:longint):boolean;
var
 i:longint;
begin
 for i:=2 to trunc(sqrt(x)) do if x mod i=0 then exit(false);
 exit(true);
end;
procedure dfs(sum,step,num:longint);
var
 i:longint;
begin
 if num=k then begin
  if prime(sum) then inc(ans);
  exit;
 end;
 for i:=step+1 to n-(k-num)+1 do dfs(sum+a[i],i,num+1);
end;
begin
 readln(n,k);
 for i:=1 to n do read(a[i]);
 ans:=0;
 sort(1,n);
 dfs(0,0,0);
 write(ans);
end.
```

---

## 作者：hongweixin (赞：3)

这题可以用枚举法，把每个可以组成的数判断是不是素数。

```cpp
type ll=longint;
var a,b,c,d,e,f,g,n,m,i,j:ll;
    ab,ac:array [1..99999] of longint;
procedure dg(x,y,z,z1:longint);
var a1,b1,i1,c1:longint;
begin
 a1:=1;
 if y=0 then
  begin
   for i1:=2 to trunc(sqrt(z1)) do//判断素数
    if z1 mod i1=0 then
     begin
      a1:=0;
      break;
     end;
   if a1=1 then inc(d);
   exit;
  end;
 for i1:=z to m do
  dg(x,y-1,i1+1,z1+ab[i1]);//从这个数的下一个数开始枚举。
end;
begin
 read(m);
 read(n);
 for i:=1 to m do
  read(ab[i]);
 dg(m,n,1,0);
 writeln(d);
end.
```

---

## 作者：Harry_Potter (赞：3)


一个想法是搜索出所有的和，之后对于每个和判断是都合法。
注意到这个题悬殊的顺序是无关要紧的，只和选了那些数有关
所以我们在定义状态的时候可以避开选数的顺序，按照读入顺序一个一个确定是否选择，可以大大缩减时间复杂度
可以将状态定义为当前已经确定了多少个数的状态，选了多少个数以及已经选了的数的和


**请不要抄！**


```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

int n,m,a[1000000],jishu;

int sushu(int x)//判断素数
{
	for(int i=2;i<=sqrt(x);i++)
	{
		if(x%i==0)
		return 0;
	}
	return 1;
}

void DFS(int x,int y,int z)
{
/*
X表示当前需要确定第X个数是否选
y表示之前选了多少个数
z表示之前选的数的和
*/
	if(x>n)//判断是否已经确定所有数是否选。
	{
		if(y==m)
		{
			jishu=jishu+sushu(z);
            //如果恰好选了y个数，就计算这个数是否为素数
		}
		return ;
	}
	DFS(x+1,y+1,z+a[x]);//搜索选择数X的情况
	DFS(x+1,y,z);//搜索不选择数X的情况
}
int main()
{
    cin>>n>>m;//读入
    for(int i=1;i<=n;i++)  cin>>a[i];
    DFS(1,0,0);//从1开始
    cout<<jishu<<endl;//输出
    

	return 0;
}


```

---

## 作者：雨过天青 (赞：2)

# 事先说明：这肯定不是正解
## 本题数据比较水连我这个递归+暴力判断质数的程序都过了。
先说一下思路：我先看到本题时我想的是：线性筛数+递归。
但当我看到（1<=xi<=5000000）时就放弃了，vis数组没法开。
让后就决定自暴自弃用一个很暴力的方法来做。
然后就AC了......
以下是代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<queue>
#include<cmath>       //头文件
using namespace std;
int i,j,k,l,n,m,a[21],ans;
void running(int i,int step,long long s)    //递归
{
	int j,z=0;
	if(step==m)     //判断个数到没有
	{
	for(j=2;j<=sqrt(s);j++)    //有一点优化的判断质数
	if(s%j==0)
	{z=1;break;}
	if(z==0)
	ans++;
	}
	for(j=i+1;j<=n;j++)
	running(j,step+1,s+a[j]);   //从j开始保证不重复
}
int main( )
{
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i]);
	running(0,0,0);
	printf("%d",ans);
}

```

---

## 作者：Misaka_Mikoto (赞：2)

此题略水，利用dfs+剪枝就可以AC了。（不同于前面几位神犇，我没有使用记忆化搜索，详见标程。）

```cpp

#include<stdio.h>
#include<math.h>
#include<string.h>
#include<stdlib.h>
#include<list>
#include<vector>
#include<deque>
#include<queue>
#include<iostream>
#include<algorithm>
int ans=0,a[25],n,m;
int zs(int n){
    int i;
    if(n==0||n==1)return 0;
    if(n==2)return 1;
    for(i=2;i*i<=n;i++)if(n%i==0)return 0;
    return 1;
}
void dfs(int k,int i,int s){
    if(!k){ans+=zs(s);return;}
    for(i;i<=n;i++)dfs(k-1,i+1,s+a[i]);
}
int main(){
    int i;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    dfs(m,1,0);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：linzihao1999 (赞：2)

用递归

```cpp

#include <iostream>
#include <cmath>
using namespace std;
int sum=0;
int pri(int a)//判断素数
{
    for(int i=2;i<sqrt(a);i++)if(a%i==0)return 1;
    return 0;
}

void c(int a[],int l,int end,int num,int p,int s)//l是数组长度，end是应选取的数字个数，num是已选数字的个数，p是当前指向的数字，s是数字之和
{
    if(num==end)
    {
        if(pri(s)==0)sum++;
        return;        //返回上一层
    } 
    else
    {
        for(int i=p;i<l;i++)c(a,l,end,num+1,i+1,s+a[i]);
    }
}
int main(int argc, char \*argv[])
{
    int a[10000],n,m,s=0;
    cin >> n >> m;
    for(int i=0;i<n;i++)cin >> a[i];
    c(a,n,m,0,0,s);
    cout << sum;
    return 0;
}

---

## 作者：Violet9567 (赞：2)

这道题需要把所有数字之和枚举出来，然后再判断是否为质数。

翻了半天题解，居然没有人用栈做，所以我也来发一篇题解

程序结构：

![](https://cdn.luogu.com.cn/upload/pic/25978.png)

AC代码如下：（~~有坑~~小心食用，请勿抄袭）

```cpp
#include<iostream>
#include<cmath> 
#include<cstdlib>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<stack>
#include<queue>//不用管那么多头文件
using namespace std;
const int N = 5 * 1e6 + 10;//根据题意定义常数
int a[N], k, n;//a[N]是用来储存输入的数的，n和k是题目中的变量，
bool z[N];//dfs中需要判断你用的数是否和前面重复
stack<int> sd;//一个栈用来储存答案
bool prime(int n)//这是用来判断素数的一个子函数，不用我多解释吧
{
	int i = 2;
	while ((n%i) != 0 && i*1.0<sqrt(n))
		i++;
	if (i*1.0 > sqrt(n))
		return true;
	else
		return false;
}
void js(int p, int he, int j)//p是当前已经是循环到第几层，he是用来记录当前的和，j是用来防止重复
{
	if (j == n && p <= k)//这里是防止已经循环到n个数，但是没有k个数，导致越界
	{
		return;
	}
	if (p > k)//满足返回条件
	{
		if (prime(he) == true)//判断当前和是否为素数
		{
			sd.push(he);//压入栈
		}
		return;//返回
	}
	else
	{
		for (int i = j; i <= n; i++)//从j开始循环，防止重复计算
		{
			if (z[i] == true)//true表示已经用过这个数
			{
				continue;//进入下一层循环
			}
			else//没有用过这个数
			{
				z[i] = true;//记录
				js(p + 1, he + a[i], i);//进入下一层dfs
			}
			z[i] = false;//还原
		}
	}
}
int main()
{
	scanf_s("%d%d", &n, &k);//其实就是scanf，我用的vs写的
	for (int i = 1; i <= n; i++)
	{
		scanf_s("%d", &a[i]);//输入，同上
	}
	js(1, 0, 1);//开始dfs
	cout << sd.size() << endl;//栈的元素个数就是我们要的答案
	system("pause");//vs没有暂停功能，此处为手动暂停
	return 0;
}
```

希望大佬多多提意见，大家共同进步

---

## 作者：arfa (赞：2)

---

# 最快的选数非我莫属

0ms

很普遍的递归题哦。

---

## I.制造本题DFS
结束条件:当选数个数大于k时,则判断本次的和s是否为素数即可。

递归条件:如果本数没有被选到,则可以加上并递归。

递归内容:
```pascal
1.标识i
2.进入下一次递归:DFS(x+1,s+num[i])
3.释放i
```

---

## II.剪枝DFS
或许暴力搜索不是很好哦,当然数据也不是很大,凡事做完美吗。

我们知道第一个数为头的n-1次可能可行的答案中,其实所有的数都跟第一个数配合过的。不必重复选择!

导论:如果第i个数为此位置,那么后面一个位置的范围是i+1到n。

制作上一次的"last":(last为上一个数的位置+1)
```pascal
定义过程:DFS(x,s,last)
递归内容:DFS(x+1,s+num[i],i+1)
```

---

## III.线性筛素数:欧拉筛法
网页链接:[欧拉筛法](https://www.luogu.org/blog/acking/solution-p3383)

从一开始就可以判断s数是不是素数,到搜索的时候就比较简单了。

欧拉筛法是一种很接近O(n)的一种筛素数的方式,它用于区间求素数,而不是单独的求素数。比起我们之前学的trunc(sqrt(n))乘n的速度会快很多。

欧拉筛法也是埃拉托斯特尼筛法的一种进阶。埃拉托斯特尼筛法的主要思想是把素数的倍数标记为"不是素数"(当i乘素数>n时停止)。

欧拉筛法则是减少重复标记(如素数2时6已经为"不是素数",但3还会)的一种筛法,详见网页链接?

---

## 代码讲解:
```pascal
var 
    num:array[1..20] of longint;
    judge,number:array[1..100000] of longint;
    bz:array[1..20] of boolean;
    i,j,n,k,l,ans:longint;
 
procedure initial_generation(n:longint);//初始筛素数,详见网络链接?
var
    i,tail:longint;
begin
    tail:=0;
    judge[1]:=1;
    for i:=2 to n do
    begin
        if judge[i]=0 then
        begin
            inc(tail);
            number[tail]:=i;
        end;
        for j:=1 to tail do
        begin
            if i*number[j]>n then
                break;
            judge[i*number[j]]:=1;
            if i*number[j]=0 then
                break;
        end;
    end;
end;
   
    
procedure DFS(x,s,last:longint);//开始DFS,是选到第x个数,现在和是s,上一个数的位置是last-1
var
    i:longint;
begin
    if (x=k+1) then//如果选完
    begin
        if judge[s]=0 then//是素数
            inc(ans);
    end
    else
        for i:=last to n do
            if bz[i]=False then//没有选过
            begin
                bz[i]:=True;//标识
                DFS(x+1,s+num[i],i+1);//递归
                bz[i]:=False;//释放
            end;
end;

begin
    read(n,k);
    for i:=1 to n do
    begin
        read(num[i]);
        inc(l,num[i]);
    end;
    initial_generation(l);//筛素数
    DFS(1,0,1);//一开始选第一个数,和为0(还没有选),last为1(这次可行的数)
    writeln(ans);//输出
end.
```



---

## 作者：gryql (赞：1)

不用想太多，一遍遍爆搜就可以过，水数据，懂得？

```delphi

(var sum,ans,n,k,i,j:longint;
   var a:array[1..20] of longint;
    var f:array[1..20] of boolean;
    
    
    function check(x:longint):boolean;
    var j:longint;
    begin 
     for j:=2 to trunc(sqrt(x)) do 
       if x mod j=0 then exit(false);
       check:=true;
       end;
       
      procedure dfs(i,p:longint);//i 要找的第几个数 p从第几个位置开始找
       var j:longint;
        begin 
         
           if i=k+1 then 
           begin 
           if check(sum) then inc(ans); 
              exit;// 如果找了k个 就判断
           end;
          for j:=p to n do 
           if not  f[j] then 
           begin 
            sum:=sum+a[j];
            f[j]:=true;
            dfs(i+1,j+1);//i+1 个数。 从刚才的位置+1
            sum:=sum-a[j];
             f[j]:=false;
            end;
            end;
    
     begin 
       readln(n,k);
        for i:=1 to n do read(a[i]);
        dfs(1,1);// 找第一个数 从第一个位置开始找
        writeln(ans);
     end.)

```

---

## 作者：邱江坤 (赞：1)

介绍一种特殊的做法：MillerRabin算法，用来判定素数；加上回溯+递归枚举，来判断选取的数字和是否是素数，是则ans+1

MillerRabin算法的时间复杂度为$O(k\log^3n)$，空间复杂度为$O(k)$，在我的这个算法中，$k=3$

总的时间复杂度为$O(n^kj\log^3m)$，$m$为数字大小，$j$为上述$k=3$，$n,k$为题目所给
```cpp

#include <iostream>
using namespace std ;
typedef long long ll;

ll pow_mod ( ll a, ll b, ll m )
{
	a %= m;
	ll ans = 1;
	do
	{
		if ( b & 1 )
			ans = ans * a % m;
		a = a * a % m;
	}
	while ( b >>= 1 );
	return ans;
}

bool Miller_Rabin ( ll n, ll a, ll d )
{
	if ( n < 2 ) return false;
	if ( n == 2 ) return true;
	if ( n == a ) return false;
	if ( ~ n & 1 ) return false;
	while ( ~ d & 1 ) d >>= 1;
	ll t = pow_mod ( a, d, n );
	while ( d != n - 1 && t != n - 1 && t != 1 )
	{
		t = t * t % n; //下面介绍防止溢出的办法，对应数据量为10^18次方；
		d <<= 1;
	}
	return t == n - 1 || ( d & 1 ) == 1; //要么t能变成n-1，要么一开始t就等于1
}

bool isprime ( ll n )
{
	static const int a[] = {2, 7, 61}; //或者自己生成[2,N-1]以内的随机数rand（）%（n-2）+2
	for ( int i = 0; i < 3; ++i )
	{
		if ( n == a[i] ) return true;
		if ( !Miller_Rabin ( n, a[i], n - 1 ) ) return false;
	}
	return true;
}

int a[30], selected = 0, ans = 0;
void dfs(int i, int k)
{
	selected += a[i];
	if(k == 0)
	{
		if(isprime(selected))
			++ans;
		selected -= a[i];
		return;
	}
	for(int j = 0; j < i; ++j)
	{
		dfs(j, k-1);
	}
	selected -= a[i];

}
int main()
{
	int n, k;
	cin >> n >> k;
	for(int i = 0; i < n; ++i)
		cin >> a[i];
	dfs(n, k);
	cout << ans << endl;
}



```

---


# [GESP202403 六级] 好斗的牛

## 题目描述


你有 $10^9$ 个牛棚，从左到右一字排开。你希望把 $n$ 头牛安置到牛棚里。麻烦的是，你的牛很好斗，如果他们附近有其他的牛，他们就会不安分地去挑事。其中，第 $i$ 头牛的攻击范围是 $(a_i, b_i)$，这意味着，如果他的左边 $a_i$ 个牛棚或者右边 $b_i$ 个牛棚有其他牛，它就会去挑事。

你想留下一段连续的牛棚，并把其他牛棚都卖掉。请问您最少需要留下多少牛棚，才能保证至少存在一种方案能够把所有的 $n$ 头牛都安置进剩余的牛棚里，且没有牛会挑事？

## 说明/提示

### 样例 1 解释

留下第 1、2、3、4 个牛棚，并在第 $1$、$4$ 两个牛棚分别放下两头牛。

### 数据规模与约定
- 对 $20\%$ 的数据，保证 $n = 2$。
- 另有 $20\%$ 的数据，保证 $n = 3$。
- 对 $80\%$ 的数据，保证 $n \leq 8$。
- 对于所有的测试数据，保证 $1 \leq n \leq 9$，$1 \leq a_i, b_i \leq 10^3$。

## 样例 #1

### 输入

```
2
1 2
1 2
```

### 输出

```
4```

## 样例 #2

### 输入

```
3
1 2 3
3 2 1
```

### 输出

```
7```

# 题解

## 作者：xyx404 (赞：35)

## 思路：
考虑到 $n$ 的最大值只有九，所以可以使用 dfs 算法枚举组合方案，把每一头牛的放置顺序存入一个数组中，当把所有的牛都放好后，算出需要的牛棚，最后输出最小值就可以了。

如何算出需要的牛棚，先画张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/zsnz27oz.png)

观察这张图，可以分四种情况。

第一种情况，上一头牛的 $b$ 大于现在这头牛的 $a$，那么距离是上一头牛的 $b$，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/qaj5t97o.png)

第二种情况，上一头牛的 $b$ 等于现在这头牛的 $a$，那么这两个数都可以是距离，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/6mb0pgbk.png)

第三种情况，上一头牛的 $b$ 小于现在这头牛的 $a$，那么距离是这头牛的 $a$，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/pw3s2uko.png)

第四种情况，没有上一头牛，也就是第一头牛，没有距离，循环直接从第二个放入牛的开始，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/t93srlnf.png)

通过上述分析可以看出，距离是上一头牛的 $b$ 与这头牛的 $a$ 中的最大值。

需要注意的是求完距离后要考虑这一头牛也需要一个牛棚，所以每次求出距离后还要加一才可以算出需要的牛棚，要提前处理第一头牛，可以直接将求需要的牛棚的变量赋值为一。

## 完整代码带注释：
代码与思路完全相同。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int a,b;
}cows[10];// 定义结构体 cows 其实可以不用结构体因为刚开始想的是排序所以用的是结构体但后面不知道怎么排也不想改就这样了
int n,minn=INT_MAX;// 定义把 minn 赋值为 int 的最大值 
bool bj[10];// 标记数组 
int fzsx[10];// 存放置顺序的数组 
void add(){
	int sum=1;// 定义 sum 赋值为 1 因为第一头牛也需要一个牛棚 
	for(int i=2;i<=n;i++){// 从 2 开始因为我们求的是这头牛和上一头牛的距离 
		sum+=max(cows[fzsx[i]].b,cows[fzsx[i-1]].a);// 求这头牛和上一头牛的距离
		sum+=1;// 为什么要加 1 因为上面只是求出了距离这头牛也要一个牛棚 
	}
	minn=min(minn,sum);// 取最小值 
    return ;
}
void dfs(int x){// 通过 dfs 求出组合方案 
	if(x-1==n){// 为什么要 x-1==n 因为我们是从第一个开始搜的当搜完最后一个时再次调用 dfs 时 x 会比 n 大 1 
		add();// 调用 add 函数 
		return ;// 返回空因为 dfs 是 void 类型的 
	}
	for(int i=1;i<=n;i++){
		if(!bj[i]){
			bj[i]=1;// 标记 
			fzsx[x]=i;// 记录 
			dfs(x+1);// 求下一个数 
			bj[i]=0;// 还原 
		}
	}
} 
int main(){
	cin>>n;// 输入 n 
	for(int i=1;i<=n;i++){// 输入 a 
		cin>>cows[i].a;
	}
	for(int i=1;i<=n;i++){// 输入 b 
		cin>>cows[i].b;
	}
	dfs(1);//从第一个开始找 
	cout<<minn<<"\n";// 输出最小值 
	return 0;
}

```

---

## 作者：gengchenghao (赞：21)

# 思路
穷举所有排列对于每一种排列模拟出最短距离。
深搜实现或者调用函数。
```next_permutation()``` 是求当前排列的下一个排列（按字典序升序的下一个序列）
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001], b[100001], ans = 0x7f7f7f7f;
vector<int> p;
int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; ++i) cin >> a[i];
	for (int i = 0; i < n; ++i) cin >> b[i];
	p.resize(n);//用于下面遍历
	for (int i = 0; i < n; i ++) p[i] = i;
	do {
		int len = n;
		for (int i = 1; i < n; ++i) {
			len += max(b[p[i - 1]], a[p[i]]);//求最大值
		}
		ans = min(ans, len);//最大值最小（）
	} while (next_permutation(p.begin(), p.end()));//调用全排列函数
	cout << ans << endl;
	return 0;
}
```

---

## 作者：huangzixi071018 (赞：8)

题目大意：每头牛会攻击左边 $a[i]$ 距离以内的牛和右边 $b[i]$ 距离以内的牛，请问怎样排列才能使牛不互相攻击且牛棚长度最短？

思路：因为数据范围太小了，所以考虑搜索，一个漂亮的搜索就完美结束。~~我也没想到那么水~~。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[15],b[15],s=1e16;
bool v[15];
void dfs(ll x,ll f,ll c){
	if(x>n){
		s=min(s,c);
		return ;
	}
	if(c>=s){
		return ;
	}
	for(ll i=1;i<=n;i++){
		if(!v[i]){
			v[i]=1;
			if(x==1){
				dfs(x+1,i,1);
			}else{
				dfs(x+1,i,c+max(b[f],a[i])+1);
			}
			v[i]=0;
		}
	}
}
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
	}
	for(ll i=1;i<=n;i++){
		cin>>b[i];
	}
	dfs(1,0,1);
	cout<<s<<"\n";
    return 0;
}
```

---

## 作者：Indestructible (赞：7)

# 题解：P10377 [GESP202403 六级] 好斗的牛

## 形式化题意

有一个数组，对于它的第 $i$ 个值为 $1$ 的元素，它向左 $a_i$ 个数、向右 $b_i$ 个数都是 $0$ 或不在这个数组中（越界），求这个数组最小是多大。

## 分析

看完数据范围我笑了，$1 \le n \le 9$，直接全排列就能 AC。

### 全排列讲解

我们首先用 `std` 中的 `next_permutation()` 函数来全排列。`next_permutation()` 的第 $1$ 个参数是起始位置指针，第 $2$ 个参数是结束位置指针 $+1$。比如说在 $a$ 数组里，下标从 $1$ 到 $n$，那么就可以这么写：

```cpp
next_permutation(a + 1, a + 1 + n);
```

然而，用 `next_permutation()` 全排列是要用 `do-while()` 循环的，于是加上循环：

```cpp
do{
    // code
}while (next_permutation(a + 1, a + 1 + n));
```

接下来就要处理题目了~

### 题目讲解

用结构体存数据，通过全排列算出在所有情况下的数组大小，求最小值即可。具体的计算方法也很简单。

假设结构体数组为 $p$：

- $p_1.a$ 和 $p_n.b$ 因为越界，不用计算；
- 第 $i$ 个数和第 $i+1$ 个数间隔 $\max(p_i.b,p_{i+1}.a)$ 个 $0$，$ans=ans+\max(p_i.b,p_{i+1}.a);$，其中 $1 \le i < n;$
- 这 $n$ 个数也占 $n$ 个位置，$ans=ans+n;$
- 取所有 $ans$ 的最小值即为答案。

## 代码

**注意：结构体不能用 `next_permutation()` 函数全排列，需要对代码稍作修改。**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10;
int n;
struct node
{
	int a,b;
};
node p[maxn];
int k[maxn];
int ans = 0x7fffffff; // 初始化 ans 为 maxint 
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++)
	{
		scanf("%d", &p[i].a);
	}
	for (int i = 1; i <= n; i ++)
	{
		scanf("%d", &p[i].b);
	}
	for (int i = 1; i <= n; i ++)
	{
		k[i] = i;
	}
	do // 全排列 
	{
		// 计算这时的数组长度 
		int s = n;
		for (int i = 1; i < n; i ++)
		{
			s += max(p[k[i]].b, p[k[i+1]].a);
		}
		// 更新 ans 
		ans = min(ans, s);
	}while (next_permutation(k + 1, k + n + 1));
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Nightsky_Stars (赞：5)

# 题目大意：

每头牛有攻击范围 $a[i]$ 和 $b[i]$，如果他的左边 $a_i$ 个牛棚或者右边 $b_i$ 个牛棚有其他牛，它就会去挑事。问怎样排列才能使牛不互相攻击且牛棚长度最短。

# 思路：

因为 $n\le9$，数据十分的小，所以直接暴搜就行了。

# CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,a[20],b[20],p[20],s=1e9;
bool vis[20];
void dfs(int x,int c){//深搜 
	if(x>n){//深搜的出口 
		s=min(s,c);
		return ;
	}
	if(c>=s) return ;//小剪枝 
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		vis[i]=1;
		p[x]=i;
		if(x==1) dfs(x+1,1);
		else dfs(x+1,c+max(b[p[x-1]],a[i])+1);
		p[x]=0;
		vis[i]=0;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	dfs(1,1);
	cout<<s<<"\n";
    return 0;
}
```

---

## 作者：spfa_ (赞：5)

[P10377 [GESP202403 六级] 好斗的牛](https://www.luogu.com.cn/problem/P10377)

注意到 $1\le n\le9$，所以我们可以枚举牛之间的所有排列，并进行计算即可。具体地，若排列 $p$ 为当前所有牛的位置（为 $1\sim n$ 的排列），最小牛棚数为

$$n+\sum_{i=1}^{n-1}\max(a_{p_{i+1}},b_{p_i})$$

答案取最小值即可。

代码：

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

int main() {
	int n, ans = 1e9; cin >> n;
	vi a(n+1), b(n+1), p(n+1);
	for (int i = 1; i <= n; ++i) cin >> a[i], p[i] = i;
	for (int i = 1; i <= n; ++i) cin >> b[i];
	do {
		int cur = n;
		for (int i = 1; i < n; ++i) cur += max(a[p[i+1]], b[p[i]]);
		ans = min(ans, cur);
	} while (next_permutation(p.begin()+1, p.begin()+n+1));
	cout << ans;
	return 0;
}
```

---

## 作者：Danny_chan (赞：3)

本人由于搜索不错，就发一篇深搜思路：**我们可以先对奶牛全排列，然后计算需要最少的牛棚数量，取最小值。**

代码：

```
#include <bits/stdc++.h>
using namespace std;
int n;
int a[110],b[110];
int c[110];
bool f[110];
int minn=1e9+1;
void dfs(int x){
    if (x>n){
        int sum=n;//每头牛先要占一个牛棚 
        for(int i=1;i<n;i++){
            sum+=max(a[c[i]],b[c[i+1]]);
        } //计算出牛棚要的最小数。 
        minn=min(minn,sum);//取最小值。 
        return;
    }
    for(int i=1;i<=n;i++){//对奶牛全排列 
        if (f[i]==false){
            c[x]=i;
            f[i]=true;
            dfs(x+1);
            c[x]=0;
            f[i]=false;
        }
    }
}
int main() {
    cin >> n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    dfs(1);
    cout<<minn;
    return 0;
}
```

---

## 作者：ACtheQ (赞：2)

首先观察到数据范围 $n\le 9$，考虑暴力搜索。

每次搜索全排列，对排列进行计算。

可以发现对于每个序列答案为 $n+\sum_{i=2}^n \max(r_{i-1},l_i)$。

其中 $n$ 是每个牛需要占用一个牛棚。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=15;
int l[N],r[N];
bool flag[N];
int id[N];
int ans=INT_MAX;
int n;
void dfs(int x)
{
	if(x>n)
	{
		int cnt=n;
		for(int i=2;i<=n;i++) cnt+=max(r[id[i-1]],l[id[i]]);
		ans=min(ans,cnt);
	}
	for(int i=1;i<=n;i++)
	{
		if(!flag[i])
		{
			id[x]=i;
			flag[i]=true;
			dfs(x+1);
			flag[i]=false;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>l[i];
	for(int i=1;i<=n;i++) cin>>r[i];
	dfs(1);
	cout<<ans;
	return 0;
}

---

## 作者：__qkj__ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10377)
## 解题思路
因为 $1\le n\le 9$，所以直接暴搜。

那 `dfs` 怎么写呢？

当 $t=n+1$（到了），记录最小值；

否则，如果当前 $i$ 没有被搜过，记录当前的 $i$，如果 $t=1$ 则 `dfs(t+1,s)`，否则 `dfs(t+1,s+max(b[c[t-1]],a[i])+1)`。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[20],b[20],c[20],minn=INT_MAX;
bool f[20];
void dfs(int t,int s)
{
	if(t==n+1)
	{
		minn=min(minn,s);
		return;
	}
	for(int i=1;i<=n;i++)
		if(!f[i])
		{
			f[i]=1;
			c[t]=i;
			if(t==1)dfs(t+1,s);
			else dfs(t+1,s+max(b[c[t-1]],a[i])+1);
			f[i]=0;
		}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1,1);
	cout<<minn;
	return 0;
}
```

---


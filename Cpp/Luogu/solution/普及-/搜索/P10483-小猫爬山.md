# 小猫爬山

## 题目描述

Freda 和 rainbow 饲养了 $N(N\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了

Freda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\le C_i,W \le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？

## 样例 #1

### 输入

```
5 1996
1
2
1994
12
29```

### 输出

```
2```

# 题解

## 作者：Ice_rnfmabj (赞：31)

猫猫不可以劈开！猫猫不可以劈开！！猫猫不可以劈开！！！

如果你看了讨论区，你会发现有一种做法，先加上所有猫的体重然后除以缆车的载重。但是很明显这样有时候猫就会被切开。

所以我想正解是 DFS，因为要求的是最少用几辆缆车，那么就先从大到小排个序，然后一只一只猫放到缆车里。当然，要最大化缆车的利用，那么就需要尽可能把猫塞进缆车里。

下面的代码里，我用 $a_i$ 表示每只猫的体重，$sum_i$ 代表第 $i$ 号缆车现在的重量。如果 $sum_i$ 加上 $a_u$ 还小于等于载重的话，那就加上 $a_u$，然后进行下一层 DFS。当然 DFS 完之后还要还原回去。

但是以上是还能塞猫的情况，有时候猫太重了就只能再来一辆缆车了。所以出了循环，把 $a_u$ 放进 $sum_v$ 里，然后 DFS 下一层，开一个新的缆车并且用后面的猫。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101],ans,sum[101];
void dfs(int u,int v){
	if(v>=ans) return;
	if(u==n){
		ans=v;
		return;
	}
	for(int i=0;i<v;i++){
		if(sum[i]+a[u]<=m){
			sum[i]+=a[u];
			dfs(u+1,v);
			sum[i]-=a[u];
		}
	}
	sum[v]=a[u];
	dfs(u+1,v+1);
	sum[v]=0;
}
int main(){
	cin>>n>>m;
	ans=n;
	for(int i=0;i<n;i++) cin>>a[i];
	sort(a,a+n,greater<int>());
	dfs(0,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：27)

### 解题思路
拿到这道题目，我由于不知道数据范围，抱着试一试的心态写了暴力代码。

暴力核心代码：
```cpp
void dfs(int step, int number, int sheng) {
	if (number == 0) {
		ans = min(ans, step);
		return;
	}
	for (int i = 1; i <= n; i++) {
		if (!b[i]) {
			b[i] = 1;
			if (sheng - c[i] >= 0)
				dfs(step, number - 1, sheng - c[i]);
			else
				dfs(step + 1, number - 1, w - c[i]);
			b[i] = 0;
		}
	}
}
```
提交上去，然后只过了一个点。。。

于是我又开始想优化。如果我们现在的缆车数量大于我们已经找到的最少的数量，那么我们就不用继续找了，因为无论如何，答案都不会更新。

交上去，还是只过了一个点。。。

于是，我又开始冥思苦想，忽然想到我们可以先将所有小猫的重量进行从大到小排序，再使用一个数组 $sum$ 维护每辆缆车还可以承受的最大重量。假设现在已经租用 $k$ 辆缆车，那么我们可以枚举 $1\sim k$ 辆缆车能否装下第 $step$ 只小猫，如果能则让这只小猫进入第 $i$ 辆缆车，否则再组一辆缆车。

交上去，一片 `AC` 的绿色。

```cpp
#include <bits/stdc++.h>
using namespace std;
int c[20], sum[20];
int n, w;
bool b[20];
int ans = 2147483646;
void dfs(int step, int number) {
	if (number >= ans)
		return;
	if (step == n + 1) {
		ans = number;
		return;
	}
	sum[number + 1] = w - c[step];
	dfs(step + 1, number + 1); 
	for (int i = 1; i <= number; i++) {
		if (sum[i] - c[step] >= 0) {
			sum[i] -= c[step];
			dfs(step + 1, number);
			sum[i] += c[step];
		}
	}
}
bool cmp(int a, int b) {
	return a > b;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> w;
	for (int i = 1; i <= n; i++)
		cin >> c[i];
	sort(c + 1, c + 1 + n, cmp);
	dfs(1, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：Vitamin_B (赞：15)

dfs 练手题。
# 思路
我们可以把每一辆车上的目前总重量记录下来，然后对于每一只猫枚举每一辆车，要么蹭上一辆车继续 dfs，要么自己新开一辆车 dfs。也可以再加一个最优性剪枝（即如果当前车数大于已知最优解就直接结束）。我这里还用了一个从大到小排序的优化，因为越小的越容易蹭车，不用开新车嘛。
# 代码
```cpp
# include <bits/stdc++.h>
using namespace std;
int n, w, a[20], g[20], ans = 25;
void dfs (int tot, int step) {
	if (tot >= ans)
		return ;
	if (step >= n) {
		ans = tot;
		return ;
	}
	for (int i = 0; i < tot; ++ i)
		if (g[i] + a[step] <= w) {
			g[i] += a[step];
			dfs (tot, step + 1);
			g[i] -= a[step];
		}
	g[tot] = a[step];
	dfs (tot + 1, step + 1);
	g[tot] = 0;
	return ;
}
int main () {
	cin >> n >> w;
	for (int i = 0; i < n; ++ i)
		cin >> a[i];
	sort (a, a + n, greater <int> ());
	dfs (0, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：lbh666 (赞：9)

## 题目大意

给你 $N$ 只小猫的重量和缆车的最大承重 $W$，问最少需要多少辆缆车？

## 思路分析

- 先考虑如何搜索。对于每一只小猫，枚举它能分配到哪一辆缆车上，还要注意单独分配一辆缆车的情况。

在搜索的基础上考虑两种剪枝。

1. 优化搜索顺序。将小猫的重量从大到小排序，因为重量越大，越容易凑出一辆缆车，使搜索树的分支规模缩小。

2. 最优性剪枝。如果当前答案比之前的最优解劣，停止本次搜索。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int n,w,ans=0;
int c[25],a[25];

bool cmp(int x,int y){
	return x>y;
}

void dfs(int now,int cnt){//now表示正在分配的小猫编号，cnt表示已分配的缆车数量 
	if(cnt>=ans)return ;//最优性剪枝，若当前答案劣于最优解，return 
	if(now==n+1){//搜索完了，更新答案 
		ans=min(ans,cnt);
		return ;
	}
	for(int i=1;i<=cnt;++i){//枚举能被分配到哪一辆缆车上 
		if(a[i]+c[now]<=w){
			a[i]+=c[now];
			dfs(now+1,cnt);
			a[i]-=c[now];//回溯 
		}
	}
	a[cnt+1]=c[now];//新配一辆缆车 
	dfs(now+1,cnt+1);
	a[cnt+1]=0;
}

int main(){
	cin>>n>>w;
	ans=n;
	for(int i=1;i<=n;++i)cin>>c[i];
	sort(c+1,c+n+1,cmp);//优化搜索顺序 
	dfs(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：_Star_Universe_ (赞：7)

### [题目传送门](https://www.luogu.com.cn/problem/P10483)
一个深度优先搜索剪枝题。

### 思路
先对变量做一个说明， $c$ 数组用于存每辆缆车的剩余载重量，$a$ 数组用于存每一只小猫的体重，$k$ 表示已使用的缆车数量，$ans$ 是答案，每一轮先选定一只小猫放在一辆空缆车上，继续往当前缆车上添加小猫直至没法再添加，就得再租用一辆缆车了，然后重复如上操作。

这里注意，缆车数量是不可能超过猫的数量的，开始搜索之前就可以令 $ans$ 为 $n$，也就是做好最坏的打算，每一轮开始前比较一下，如果缆车数量大于猫的数量就直接停止程序。

### 代码
```c
#include<bits/stdc++.h>
using namespace std;

int a[25],c[25],n,w,ans;
void f(int s,int k){
	if(k>=ans) return;//缆车数量必定不会大于小猫的数量
	if(s>n){//更新答案
		ans=min(ans,k);
		return;
	}
	for(int i=1;i<=k;i++){
		if(c[i]+a[s]<=w){//判断当前缆车是否还能添加猫
			c[i]+=a[s];
			f(s+1,k);
			c[i]-=a[s];
		}
	}
   	//固定一只小猫到缆车上，开始新一轮搜索
	c[k+1]=a[s];
	f(s+1,k+1);
	c[k+1]=0;
}

int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	ans=n;//先把最大的答案存起来
	f(1,0);
	cout<<ans;
	return 0;
}
```
本题写法比较固定，希望管理员通过这篇题解。

---

## 作者：cyhyeee (赞：4)

## 题解：P10483 小猫爬山
[题目传送门](https://www.luogu.com.cn/problem/P10483)

来简单分析下题意：$N$ 只猫的重量，最大承重量为 $W$ 的缆车，求最少用多少个缆车才能全部装起来。

设最大承重量为 $limit$，所以我们要先按从大到小排序，选定一只猫后，在 `dfs`，用剩下的猫来补缝隙，直到无法补。用一个 $sum$ 数组来表示 $i$ 号缆车现在的重量，$w$ 来表示每只猫的重量，$k$ 表示当前开了几个缆车。如果当前车厢加上这只猫的重量不超过 $limit$ 则 $sum_i \gets sum_i +w_i$。结束后将 $sum_k = w_u$，再 `dfs` 下一层，`dfs` 之后还原 $sum$，即 $sum_u = 0$。

#### code：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 20;
int w[N], sum[N];
int n, limit, ans;
void dfs(int u, int k){
    if (k >= ans) return;//剪枝。
    if (u == n) ans = k;//小猫都装完了，更新答案。
    for (int i = 0; i < k; i++){
        if (sum[i] + w[u] <= limit){
            sum[i] += w[u];
            dfs(u + 1, k);
            sum[i] -= w[u];
        }
    }
    sum[k] = w[u];
    dfs(u + 1, k + 1);//再开一个缆车，同时当前这只小猫已经固定在这个缆车里了，所以是u+1。
    sum[k]=0;
}
int main(){
    cin >> n >> limit;
    ans = n;
    for (int i = 0; i < n; i++){
    	cin >> w[i];
	}
    sort(w, w + n, greater<int>());
    dfs(0, 0);
    cout << ans;
    return 0;
}
```

---

## 作者：xf20280111 (赞：3)

感觉想到状压不难，为什么 TJ 里面没有呢。
## 思路
数据范围不允许暴力搜索，考虑状压 DP。

设 $dp_{i}$ 表示当状态为 $i$ 的时候需要几辆缆车装下，所以 $dp_{0} = 0$，其他值均赋值为无穷大。

然后处理一个数组 $s$，表示每一个状态小猫的重量和。

枚举每个状态 $i$ 的子集 $j$，状态转移方程为：

$$
dp_{i} = \min(dp_{i - j} +1,dp_{i})
$$

转移时还需要判断这个状态 $w$ 能不能装得下。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 18 + 2;
int c[N],s[(1 << N) - 1],dp[(1 << N) - 1];
char ch;
inline void read(int &x)
{
    while((ch=getchar())<48||ch>57);
    x=ch^48;
    while((ch=getchar())<58&&ch>47)
        x=(x<<1)+(x<<3)+(ch^48);
}
inline void write(const int &x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,w;read(n),read(w);
	for (int i = 1;i <= n;i++) read(c[i]);
	int U = (1 << n) - 1;
	memset(dp,0x3f,sizeof(dp));
	dp[0] = 0;
	for (int i = 1;i <= U;i++){
		for (int j = 1;j <= n;j++){
			if (i & (1 << j - 1) ) s[i] += c[j];
		}
	}
	for (int i = 1;i <= U;i++){
		for (int j = i;j;j = i &(j - 1) ){//枚举子集
			if (s[j] > w) continue;
			dp[i] = min(dp[i],dp[i - j] + 1);
		}
	}
	cout << dp[U];
    return 0;
}
```

---

## 作者：sillation (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P10483)

--------
### 思路：
使用贪心和 dfs。只要当前此缆车还能装下任何未装的一只猫，就装上。如果装不下，就再多使用一个缆车。

我们用数组 $sum$ 和 $p$ 记录目前每个缆车上的重量和每个猫的重量。用变量 $u$ 和 $k$ 表示当前该装第几只猫和当前缆车数量。$ans$ 表示最小缆车数量。

#### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,ans,sum[2000],p[2000];
bool cmp(int a,int b){
	return a>b;
}
void dfs(int u,int k){
	if(k>=ans) return ;//剪枝
	if(u==n+1) ans=k;//记录答案
	for(int i=1;i<=k;i++){
		if(sum[i]+p[u]<=w){
			sum[i]+=p[u];
			dfs(u+1,k);
			sum[i]-=p[u];
		}
	}
	sum[k+1]=p[u];
	dfs(u+1,k+1);//多使用一个缆车
	sum[k+1]=0;
}
int main(){
	cin>>n>>w;
	ans=n;
	for(int i=1;i<=n;i++) cin>>p[i];
	//sort(p+1,p+1+n,cmp);//可以不使用排序
	dfs(1,1);
	cout<<ans;
	return 0;
}


```

---

## 作者：__qkj__ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10483)
## 解题思路
先把 $a$ 数组从大到小排序，接着 DFS。

- 当 $t=n+1$ 时，也就是 $n$ 只猫全部坐索道下山了，求缆车个数的最小值，再 `return`，退出搜索；
- 当 $s>minn$ 时，即当前的缆车个数比缆车个数的最小值还要大，直接 `return`（不加会 TLE）；
- 否则，$i$ 从 $1$ 到 $s$ 遍历，从之前的缆车中挑选是否还能坐，如果能坐，加上它的重量，`dfs(t+1,s)`，回溯；
- 最后再开一个新的缆车，记录它的重量，`dfs(t+1,s+1)`，别忘了回溯。

最后输出 $minn$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[30],n,m,minn=LLONG_MAX,b[30];
void dfs(int t,int s)
{
	if(t==n+1)
	{
		minn=min(minn,s);
		return;
	}
	if(s>minn)return;
	for(int i=1;i<=s;i++)
		if(b[i]+a[t]<=m)
		{
			b[i]+=a[t];
			dfs(t+1,s);
			b[i]-=a[t];
		}
	b[s+1]+=a[t];
	dfs(t+1,s+1);
	b[s+1]-=a[t];
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1,greater<int>());
	dfs(1,1);
	cout<<minn;
	return 0;
}

```

---

## 作者：chenlongli (赞：2)

### 思路
我们可以使用深度优先搜索，我们可以让每只小猫都分别选择一次乘坐之前有小猫做过的缆车或者新增加一座缆车，自己先坐上去，当然坐上去之后缆车重量不能超标。

但是这样子的做法依旧只能拿到 $32$ 分。

我们考虑剪枝。

有一个明显的剪枝，就是当前小猫坐的缆车数量如果已经超过了之前的最小答案，那么就可以剪枝。

同时我们可以让重的小猫先上车，如果让轻的猫先上车，那么这个缆车还可以承受的重量就会越大，从而增加搜索的次数，我们可以让重的小猫先上车，这样就可以减少搜索的次数。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,ans=23,sum=0;
int a[20],z[20];
bool cmp(int s1,int s2)
{
    return s1>s2;
}
void dfs(int p)
{
    if (p==n)
    {
        ans=min(ans,sum);
        return;
    }
    if (ans<sum)
    {
        return;
    }
    for (int i=0;i<sum;i++)
    {
        if (z[i]+a[p]<=w)
        {
            z[i]=z[i]+a[p];	
            dfs(p+1);
            z[i]=z[i]-a[p];
        }
    }
    z[sum]=a[p];
    sum=sum+1;
    dfs(p+1);
    sum=sum-1;
    return;
}
int main()
{
   cin>>n>>w;
   for (int i=0;i<n;i++)
   {
       cin>>a[i];
   }
   sort(a,a+n,cmp);
   dfs(0);
   cout<<ans<<endl;
}
```

---

## 作者：gavinliu266 (赞：1)

# 思路
可以考虑使用搜索与回溯算法，对于每一只猫，枚举它能坐的缆车，如果所有猫都放完了，那么就更新答案。

因为是求最小值，所以有一个最优性剪枝，就是当目前的缆车数量已经超过答案时，直接退出搜索（因为答案不会更优）。

# 代码实现
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
int n, w, ans = 20;
int a[25], f[25];
void dfs(int h, int v) {
    if(v >= ans)  // 最优性剪枝
        return;
    if(h == n + 1) {
        ans = v;  // 因为已经剪枝过了，所以这里的 v 肯定比答案小
        return;
    }
    for(int i = 1; i <= v; ++i)
        if(f[i] >= a[h]) {
            f[i] -= a[h];
            dfs(h + 1, v);
            f[i] += a[h];  // 回溯
        }
    f[v + 1] = w - a[h];
    dfs(h + 1, v + 1); // 新建缆车的情况
    return;
}
int main() {
    scanf("%d%d", &n, &w);
    for(int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    f[1] = w;  // 第一个缆车为空
    dfs(1, 1);
    printf("%d\n", ans);
}
```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
第一眼我以为是个背包，但由于是分组，所以有多个缆车，明显不能用背包。我做这题是因为老师要求，那是我们在学深搜减枝，所以我就开始写深搜。

这一题实际上是先选一直最重的猫，然后搞个 $sum$ 数组，每搞一个新缆车的就下一个下标继续放，如果能放就放，当然也要搞一个能放但不放的。减枝就是如果当前所需缆车数量大于 $minans$ 了，就返回。

具体代码很好写。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=101;
int n,w;
int v[N];
int sum[20];
int minans=INT_MAX;
void dfs(int id,int cnt){
    if(cnt>minans) return ;
    if(id>n){
        minans=min(minans,cnt);
        return ;
    }
    for(int i=1;i<=cnt;i++){
        if(w-sum[i]>=v[id]){
            sum[i]+=v[id];
            dfs(id+1,cnt);
            sum[i]-=v[id];
        }
    }
    sum[cnt+1]+=v[id];
    dfs(id+1,cnt+1);
    sum[cnt+1]-=v[id];
}
int main(){
    cin>>n>>w;
    for(int i=1;i<=n;i++) cin>>v[i];
    sort(v+1,v+n+1,greater<int>());
    dfs(1,0);
    cout<<minans;
    return 0;
}
```

---

## 作者：UnfortunatelyDead (赞：0)

题目数据范围没给，其实是很小的可以爆搜（$n \leq 18$）。

我们考虑定义搜索函数 $\text{dfs}(u,s)$ 表示当前是第 $u$ 只小猫，然后用了 $s$ 只缆车。

显而易见，$u$ 只能选择一辆可以容得下自己的缆车，即在 $[1,s+1]$ 直接选择一个剩余空间 $\geq c_u$ 的，选择 $s+1$ 的话表示是新开一辆缆车，那么接下去 $\text{dfs}$ 时就是 $\text{dfs}(u+1,s+1)$ 了。 

显然这样子的复杂度还是很大，是 $O(n!)$ 的，那如果剪枝呢？

首先贪心地想，对于当前 $u$，一定是能不开新的就不开新的对吧，这样才能使得最小，只有在万不得已之时才会去开 $s+1$，于是可以优先处理不开新缆车的情况，得出当前最小答案 $ans$，那么 $s \geq ans$ 时答案就显然要被舍去了。

代码之前写的了，变量名和题解有点出入，不过不影响。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[101], l[101];
int ans = 1145141919;
int n, c;
void dfs(int step, int len){
	if(len >= ans) return ;
	if(step == n+1) {
		ans = min(ans, len);
		return ;
	}
	for(int i = 1; i <= len+1; ++i){
		if(l[i] + a[step] <= c){
			l[i] += a[step];
			dfs(step+1, i > len ? len+1 : len);
			l[i] -= a[step];
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin >> n >> c;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	dfs(1, 0);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Cute__yhb (赞：0)

## 思路
深搜。

递归函数里放两个参数，$x$ 存搜到了第几只猫，$cnt$ 存用了几辆缆车。

对于每一只猫，有两种情况。

- 放在之前的缆车里。

- 新加一辆。

对于第一种情况，遍历一遍之前的缆车，如果之前的重量加上这一只还不超重，就把它放进去。

第二种情况，令 $cnt$ 加一，新的缆车重量为这只小猫的重量。

注意回溯、剪枝。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define re register
#define ri register int
#define rll register long long
#define ld long double
#define endl '\n'
#define fi first
#define se second
#define pii pair<int,int>
#define p_q priority_queue
#define iter iterator
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define nep(i,a,b) for(int i=(a);i>=(b);i--)
#define popcount __builtin_popcount
#define pb push_back
#define mem(a,x) memset((a),x,sizeof(a))
#define eps 1e-8
#define oper operator
#define mk make_pair
ll n,w,c[25],minn=INF,k[25];
void dfs(int x,ll cnt){
	if(cnt>=minn) return ;//剪枝
	if(x==n+1){//搜完了
		minn=min(minn,cnt);
		return ;
	}
	for(int i=1;i<=cnt;i++){
		if(k[i]+c[x]<=w){//不超重
			k[i]+=c[x];//放进去
			dfs(x+1,cnt);
			k[i]-=c[x];//回溯
		}
	}
	k[cnt+1]=c[x];//新建
	dfs(x+1,cnt+1);
}
int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++) cin>>c[i];
	minn=n;
	dfs(1,0);
	cout<<minn;
    return 0;
}
```

---


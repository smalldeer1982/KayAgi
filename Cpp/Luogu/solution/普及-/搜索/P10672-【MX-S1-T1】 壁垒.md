# 【MX-S1-T1】 壁垒

## 题目背景

原题链接：<https://oier.team/problems/S1A>。

## 题目描述

给定一个长度为 $n$ 的仅包含正整数的数列 $a$，保证 $n$ 是偶数。你需要重排 $a$，满足对于 $a$ 的每个长度为偶数的前缀，出现的数字种类数是偶数，或断定这样的重排方式不存在。

如果有多种重排方式满足条件，输出任意一种即可。

## 说明/提示

__【样例解释 1】__

$\{1,3\},\{1,3,3,1\},\{1,3,3,1,2,4\}$ 这些集合的数字种类数都是偶数。

__【数据范围】__

__本题使用子任务捆绑测试。__

对于 $100\%$ 的数据，$2\le n\le 10^5$，$1\le a_i\le n$，保证 $n$ 是偶数。

| 子任务编号 | $n\le $ | $a_i\le $ | 分值 |
| ---------- | ------- | --------- | ---- |
| $1$        | $10$    | $n$       | $20$ |
| $2$        | $20$    | $n$       | $20$ |
| $3$        | $10^5$  | $2$       | $20$ |
| $4$        | $10^5$  | $10$      | $20$ |
| $5$        | $10^5$  | $n$       | $20$ |

## 样例 #1

### 输入

```
6
2 3 3 4 1 1```

### 输出

```
1 3 3 1 2 4```

## 样例 #2

### 输入

```
2
1 1```

### 输出

```
-1```

# 题解

## 作者：Xssion37_XY (赞：8)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P10672)

[更好的阅读体验](https://www.luogu.com.cn/article/tkbx76sg)

### 实际分析

构造题。

首先说一下不满足的情况：元素种类为奇数则不满足。

当元素种类为奇数时，无论如何我们尝试重排这些元素（因为我们要保证每个偶数长度的前缀子数组都要有偶数个元素种类），我们会发现无法通过任何重排方法使得每个偶数长度的前缀子数组的不同元素数量变成偶数。

然后是满足的情况。

观察题目，容易想到一种最好构造的序列：单调递增序列。

举个例子：

```
6
1 3 2 4 6 5
```

我们很容易构造出来：

```
1 2 3 4 5 6
```

那如果我再加两个元素呢？

```
8
1 3 2 4 6 5 2 3
```

答案是：

```
1 2 3 4 5 6 2 3
```

观察上面两个例子，你发现了什么？

没错，构造方法就是先构造序列的单调递增序列，紧接着将剩余元素输出即可。

想想为什么可以这么构造？

因为我们构造序列的单调递增序列**一定包含了**这个序列的所有元素，那么我们这个序列剩下的**一定是**重复的元素，又因为重复的元素它有不算多一种，所以我们在后面直接输出即可正确构造。

其他的细节自己注意一下就行。

### 代码部分

```
#include <iostream>
using namespace std;
const int N = 1e5 + 11;
int a[N],b[N];
int cnt;
signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i];
		b[a[i]] ++;
	}
	for (int i = 1; i <= n; i ++) {
		if(b[i]) {
			cnt ++;
		}
	}
	if (cnt % 2 == 0) {
		for (int i = 1; i <= n; i ++) {
			if (b[i]) {
				cout << i << " "; // 构造单调递增序列
				b[i] --;
			}
		}
		for (int i = 1; i <= n; i ++) {
			if (b[i]) {
				while (b[i] --) {
					cout << i << " "; // 剩余的跟在后面输出
				}
			}
		}
	} else {
		cout << -1;
	}
	return 0;
}
```


完结撒花！

---

## 作者：wimg6_ (赞：7)

注意到，我们可以先统计 $a$ 数组中出现过多少个不同的数字，记为 $s$。

若 $s$ 为奇数，则无论怎么构造，对于 $a$ 的前缀 $a_1\sim a_n$，其一定不符合题意，故输出 $-1$。

若 $s$ 为偶数，则我们可以先取每个出现过的数字各一遍，然后任意取即可。为什么？因为对于前缀 $a_1\sim a_i(2\leq i\leq s,i=2k,k\in \mathbb{Z}_+)$，其出现的数字种类数均为 $i$，而 $i$ 又是偶数，所以成立；而对于前缀 $a_1\sim a_i(s<i\leq n,i=2k,k\in \mathbb{Z}_+)$，其出现的数字种类数均为 $s$，而 $s$ 又是偶数，所以也成立。

```
#include<bits/stdc++.h>
using namespace std;
int n,flag,a[100010],f[100010];
int read(){
    int x=0,p=1;char ac=getchar();
    while(ac!='-' && (ac<'0' || ac>'9')) ac=getchar();
    if(ac=='-') p=-1;
    while(ac>='0' && ac<='9') x=x*10+ac-'0',ac=getchar();
    return x*p;
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read(),f[a[i]]++;
        if(f[a[i]]!=1) flag++;
    }
    if(flag%2) return !printf("-1");
    for(int i=1;i<=100000;i++)
        if(f[i]) printf("%d ",i),f[i]--;
    for(int i=1;i<=100000;i++)
        while(f[i])
            printf("%d ",i),f[i]--;
    return 0;
}
```

**更新日志**

修改了一处笔误。

---

## 作者：_zuoqingyuan (赞：2)

# 思路

我们把重排的过程看成：起初拥有一个空数组，不断的向这个空数组末端插入两个数。直到把所有的数都插入数组中。

我们定义一个集合 $S$，表示上文提到的数组中，当前所含有的数。起初 $S=\varnothing$，我们假设每次插入的数分别是 $a$ 和 $b$，**且在此之前数组的种类数一直是偶数**，如果可以插入到数组末端，在将 $a,b$ 加入集合 $S$。

----

- $a\in S,b\in S$：

数组中数的种类数不变，仍为偶数，为一个合法操作。

- $a\notin S,b\in S$：

数组中数的**种类数奇偶性改变，种类数加一**，为奇数，不符合题意。

- $a\in S,b\notin S$：

与上一种情况类似。

- $a\notin S,b\notin S$：

数组中数的种类数加二，种类数奇偶性不变，为偶数，符合题意。

-----

所以说，我们每次加入元素到这个数组中时，要么加入两个已经存在于 $S$ 中的元素，要么加入两个不存在于 $S$ 中的元素。我们**只关注第二种情况**，易发现这样做的前提就必须保证原数组中数的种类数为偶数。

考虑如何构造一种合法的重排方案（存在很多种），我的做法是：判断有解后，依次将出现在原数组中的数输出一遍，一个数只输出一次；然后再把剩下的数输出。

# $\text{Code}$：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e5+10;
int a[N],sum,n;
int main(){
    scanf("%d\n",&n);
    for(int i=1,x;i<=n;i++){
        scanf("%d",&x);
        if(!a[x])sum++;
        a[x]++;
    }
    n=max(n,10);
    if(sum&1)printf("-1");
    else{
        for(int i=1;i<=n;i++){
            if(a[i])printf("%d ",i),a[i]--;
        }
        for(int i=1;i<=n;i++){
            while(a[i])printf("%d ",i),a[i]--;
        }
    }
    return 0;
}
```


如有错误，请指出。

---

## 作者：sbno333 (赞：1)

我们考虑有解需要满足的条件。

发现如果种类数为奇数，那么最后一个前缀必定不满足条件，无解。

接着我们考虑怎样排列。

我们考虑先让每个种类都尽量快出现，这样后面的前缀都满足条件。

然后就考虑前面的前缀。

发现贪心每个种类先出现一次自然就让前面的前缀满足条件。

因为没有重复，所以长度偶数就是种类偶数。

重复的上述说过只有后头的后缀会发生，此时一定满足条件。

桶维护即可。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
int a[2000009];
int zz;
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int z;
		cin>>z;
		a[z]++;
		if(a[z]==1){
			zz++;
		}
	}
	if(zz&1){
		cout<<-1<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(a[i]){
			cout<<i<<" ";
			a[i]--;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a[i];j++){
			cout<<i<<" ";
		}
	}
	return 0;
}
```

---

## 作者：虫二bug2 (赞：1)

## 题目大意：
长度为偶数序列重新排序，使每次删去序列末尾两个元素后，剩下的序列中元素种类个数恒为偶数。
## 思路：
先记录每个元素出现的次数与元素种类个数，如果元素种类个数为奇数，直接输出 $-1$。

扫一遍，个数是 $1$ 加入队列 $q1$，个数是 $2$ 加入队列 $q2$，个数大于 $2$：奇数，一个放入 $q1$，其余放入 $q3$；偶数：两个放入 $q2$，其余放入 $q3$。

解释一下：$q3$ 中是元素个数大于 $2$ 的元素，把模 $2$ 后剩下的两个两个输出不会影响元素种类个数。

此时，如果 $q1$ 或 $q2$ 元素个数为奇数，输出 $-1$。
如果皆为偶数，就可以输出一个解了。

先直接输出 $q1$，再输出 $q2$，最后输出 $q3$。

代码如下：

```
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,a[N],m=0;
struct st{
    int num,w;
}v[N];
queue<int> q1,q2,q3;
int main(){
    memset(v,0,sizeof(v));
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(!v[a[i]].w){
            m++;
            v[a[i]].w=a[i];
        }
        v[a[i]].num++;
    }
    if(m%2==1){
        cout<<-1;
        return 0;
    }
    for(int i=1;i<=n;i++){
        if(!v[i].w)continue;
        if(v[i].num==1)q1.push(v[i].w);
        else
        if(v[i].num==2)q2.push(v[i].w);
        else
        if(v[i].num%2==1){
            while(v[i].num>1){
                q3.push(v[i].w);
                v[i].num--;
            }
            q1.push(v[i].w);
        }
        else{
            while(v[i].num>2){
                q3.push(v[i].w);
                v[i].num--;
            }
            q2.push(v[i].w);
        }
    }
    if(q1.size()%2==1||q2.size()%2==1){
        cout<<-1;
        return 0;
    }
    while(!q1.empty()){
        cout<<q1.front()<<" ";
        q1.pop();
    }
    while(!q2.empty()){
        int j,k;
        j=q2.front();
        q2.pop();
        k=q2.front();
        q2.pop();
        cout<<j<<" "<<k<<" "<<j<<" "<<k<<" ";
    }
    while(!q3.empty()){
        cout<<q3.front()<<" ";
        q3.pop();
    }
}
```

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10672)

# 前置知识

[STL 算法](https://oi-wiki.org/lang/csl/algorithm/)

# 解法

一个简单的结论：随着前缀长度的增长，出现的数字种类数每次只能增加 $0$ 或 $2$。考虑构造时可以从这里下手。

一种构造方案是这样的：优先让数字种类数增加 $2$，即先将原先没有出现过的数往前放；接着让数字种类数增加 $0$，即后将原先出现过的数往后放。
  - 同时，也解释了当 $1 \sim n$ 中出现的数字种类数是奇数时不存在这样的重排方式。
    
找重复元素时可以借助 ``unique`` 函数，但需要注意的是 ``unique`` 函数对于重复的元素并不是将其删除，而是将其移动赋值，可能会覆盖先前的数，可参考 [C++ 手册](https://zh.cppreference.com/w/cpp/algorithm/unique)，故可以使用一个桶来进行手动统计。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int a[100010],vis[100010];
int main()
{
	int n,m,i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		vis[a[i]]++;
	}
	sort(a+1,a+1+n);
	m=unique(a+1,a+1+n)-(a+1);
	if(m%2==0)
	{
		for(i=1;i<=m;i++)
		{
			vis[a[i]]--;
			cout<<a[i]<<" ";
		}
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=vis[i];j++)
			{
				cout<<i<<" ";
			}
		}
	}
	else
	{
		cout<<"-1"<<endl;
	}
	return 0;
}
```

---

## 作者：JYX0924 (赞：1)

这是一道构造题。

首先，计算出数的种类数。如果种类数是奇数，就无法构造，反之可以。

证明：种类数是奇数时，前 $n$ 个数的种类数就一定是奇数。当种类数是偶数时，设数列中数的种类数为 $k$，则构造数列，使得构造的数列前 $k$ 项均不相同，剩下的位置把剩余的数输出即可。

下面是我的 AC 代码。

```c
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],sum,vis[100005];
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n; for(int i=1;i<=n;i++) cin>>a[i],vis[a[i]]++;
	sort(a+1,a+n+1); sum=1;
	for(int i=2;i<=n;i++) if(a[i]!=a[i-1]) sum++;
	if(sum%2==1) {cout<<"-1"; return 0;}
	cout<<a[1]<<" ";
	for(int i=2;i<=n;i++) if(a[i]!=a[i-1]) cout<<a[i]<<" ";
	for(int i=1;i<=n;i++) while(vis[i]>1) vis[i]--,cout<<i<<" ";
	return 0;
}
```
谢谢大家！！！

---

## 作者：LostKeyToReach (赞：1)

对于这道题，我们可以贪心地去填充数字，按照出现次数依次填充。以样例为例：

$a$ 数列为：$1,3,3,1,2,4$。

出现次数分别为：$2(1),1(2),2(3),1(4)$。

按出现次数排序后的序列为：$1,1,3,3,2,4$。

那我们依此将 $1,3,2,4$ 填入，接着出现次数都减 $1$，那么出现次数变为：$1(1),0(2),1(3),0(4)$。

我们再按照以上步骤填充，最后得到的序列就是答案。就比如样例的答案按照上面的步骤可以变为：$1,3,2,4,1,3$，符合条件。

对于无解的情况，我们只需判断构成的序列是否合法即可。

时间复杂度 $O(n\log n)$。

代码如下：
```cpp
int n, a[100006];
int cnt[100006];
int ans[100006];
int main() {
	read(n);
	FORL(i, 1, n, 1) {
		read(a[i]);
		++cnt[a[i]];
	}
	int c = 0;
	FORL(i, 0, n, 1) {
		if (cnt[a[i]]) ++c;
	}
	if (c & 1) return writes(-1), 0;
	sort(a + 1, a + n + 1, [&](int a, int b) {
		return cnt[a] != cnt[b] ? cnt[a] > cnt[b]:a < b;
		});
	int nowtask = 0;
	int t = n;
	n = unique(a + 1, a + t + 1) - a - 1;
	while (nowtask < t) {
		bool ok = 0;
		FORL(i, 1, n, 1) {
			if (cnt[a[i]]) {
				ans[++nowtask] = a[i];
				--cnt[a[i]];
			}
			else {
				break;
			}
		}
	}
	int now = 0;
	FORL(i, 0, t, 1) {
		cnt[i] = 0;
	}
	FORL(i, 1, t, 1) {
		if (!cnt[ans[i]]) cnt[ans[i]] = 1, ++now;
		if (i & 1);
		else {
			if (now & 1) {
				write(-1);
				return 0;
			}
		}
	}
	FORL(i, 1, t, 1) writes(ans[i]);
}
```
```

---

## 作者：zhujiangyuan (赞：1)

[P10672 【MX-S1-T1】壁垒](https://www.luogu.com.cn/problem/P10672)

诈骗题。

首先判断无解的情况，如果总的数字种类数为奇数，那么一定不合法，因为前 $n$ 个数字中出现的数字种类数是奇数。

对于一定有解的情况，有一个很好的分配方法。设一共有 $m$ 种数字，那么 $1\sim m$ 可以将这 $m$ 种数字各放一个，这样保证长为 $i(1\le i\le m)$ 且 $i$ 为偶数的前缀中数字种类数是偶数。然后对于 $m+1\sim n$ 的数字随便放就行了，因为数字种类都是 $m$，而 $m$ 是个偶数。

代码很好写不放了。

赛时使用了 `unique` 去重，时间复杂度 $O(n\log n)$，但是根本不需要，开个桶 $O(n)$ 去重即可。

---

## 作者：Redamancy_Lydic (赞：1)

~~暑期集训=依托答辩。~~

## 分析

种类数是奇数一定无解。

否则每种数字先输出一次，在此过程中每增加两个数时，因为每个数字种类数都不一样，所以前缀种类数也同时增加 $2$，保证一定为偶数。

然后输出完以后，设总种类数为 $m$，无论以后再怎么加入新数字，前缀种类数一定为 $m$ 不变，后面数字依次输出就行了。

## Code

```cpp
#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/trie_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define int long long
#define V vector<char> 
using namespace std;
using namespace  __gnu_pbds;
//gp_hash_table<string,int>mp2;
//__gnu_pbds::priority_queue<int,less<int>,pairing_heap_tag> q;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e6+10;
int n,a[maxn];
int cnt[maxn];
vector<int> v;
signed main() 
{
	cin>>n;
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(!cnt[a[i]])v.push_back(a[i]);
		cnt[a[i]]++;	
	}
	if(v.size()&1)return 0*printf("-1");
	for(auto i : v)
	{
		cout<<i<<' ';
		cnt[i]--;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=cnt[a[i]];j++)
		{
			cout<<a[i]<<' ';
		}
		cnt[a[i]]=0;
	}
	return 0;
}
```

---


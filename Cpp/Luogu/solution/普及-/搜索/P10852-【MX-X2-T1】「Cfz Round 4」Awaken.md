# 【MX-X2-T1】「Cfz Round 4」Awaken

## 题目背景

原题链接：<https://oier.team/problems/X2A>。

---

能否等到梦醒了的时候。

![图片与题目做法无关，图片来源网络，侵删。QWQ。](https://cdn.luogu.com.cn/upload/image_hosting/wksp5b48.png?x-oss-process=image/resize,m_lfit,h_500,w_500)


## 题目描述

月做了一个梦。在梦中，她拿到了一个长度为 $n$ 的**整数**序列 $a_1, \ldots, a_n$，**其中 $\bm{n \ge 5}$**。

梦醒了。月忘记了这个序列中的一部分元素，留下了空白。所幸，月还记得 $m$ 个非空白的位置。月希望将空白的位置填上，还原整个序列。

月还记得梦中的序列有性质：对于所有满足 $x_2+x_3=x_1+x_4$ 的互异下标 $x_1,x_2,x_3,x_4$，总有 $a_{x_2}+a_{x_3}=a_{x_1}+a_{x_4}$ 成立。

月想知道是否可以还原出一个满足性质的序列（如果不能的话，就是她记错了）。若可以，输出 ```Yes```；否则输出 ```No```。

## 说明/提示

**【样例解释 #1】**

对于第 $1$ 组测试数据，当前序列为 $[1,?,?,4,5]$。可以构造出原序列 $[1,2,3,4,5]$，你可以检查此序列满足性质。

对于第 $2$ 组测试数据，当前序列为 $[1,4,7,1,5,4]$。可以证明不存在满足性质的原序列。这组样例提醒你，**$\bm p$ 不一定升序给出**。

对于第 $3$ 组测试数据，当前序列为 $[?,?,?,?,?]$。可以构造出原序列 $[0,0,0,0,0]$，当然 $[-1,-1,-1,-1,-1]$ 也可以。这组样例提醒你，$m$ 可以等于 $0$，以及原序列可以含有负数或 $0$。


**【数据范围】**

设 $\sum n$ 表示单个测试点中 $n$ 的和。

对于所有测试数据，$1 \le T\le 4\times10^4$，$5\le n\le2\times 10^5$，$\sum n\le 2\times10^5$，$0\le m\le n$，$1\le p_i\le n$，$-10^{9} \le x_i \le 10^{9}$。保证在同一组数据内 $p_i$ 两两不同。

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n\le2000$ 且 $m=n$。
- Subtask 2（30 points）：$n\leq 6$，$|x|\le7$。
- Subtask 3（20 points）：$m=2$。
- Subtask 4（30 points）：无特殊限制。

## 样例 #1

### 输入

```
3
5 3
1 1
4 4
5 5
6 6
1 1
3 7
2 4
5 5
4 1
6 4
5 0```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
1
5 2
1 -2
5 -10```

### 输出

```
Yes```

## 样例 #3

### 输入

```
2
9 6
1 -856675560
8 479857596
5 -92942328
4 -283875636
3 -474808944
9 670790904
10 7
4 -32297373
10 -633066970
9 831032854
5 -43726758
2 -699796467
1 -918486370
8 612342951```

### 输出

```
Yes
No```

# 题解

## 作者：ダ月 (赞：7)

- 我会检查。

注意到 Subtask 1 中 $m=n$。我们依次枚举 $z$，所有满足 $x+y=z$ 的二元对 $(x,y)$，要求 $a_x+a_y$ 的值两两相等。时间复杂度：$O(n^2)$

- 我会暴力。

应该随便写个指数级暴力就能过 Subtask 2 了吧。~~确信~~。

- 我会正解。

先猜一手结论：$a_i$ 是等差序列。接下来进行证明。

若 $n=5$，我们有以下式子：

1. $a_1+a_4=a_2+a_3$;
2. $a_1+a_5=a_2+a_4$;
3. $a_2+a_5=a_3+a_4$。

$2$ 式减去 $1$ 式得到 $a_5-a_4=a_4-a_3$。以此类推，不难发现 $a_i$ 序列为等差数列。

不过要特判 $m\le 1$。

如果 $m\ge 2$，我们只需要算出公差（要求是**整数**），然后看是否能够还原出一个等差数列。

时间复杂度：$O(n+m)$。

```
void solve(){
	//don't forget to open long long;
	int n,m;IO::cin>>n>>m;std::vector<int>v(n,1e9+1);
	while(m--){int x,y;mp[x]++;;IO::cin>>x>>y;x--;v[x]=y;}
	while(!v.empty()&&v.back()==1e9+1)v.pop_back();
	reverse(all(v));
	while(!v.empty()&&v.back()==1e9+1)v.pop_back();
	reverse(all(v));
	if(v.size()<=1)return IO::cout<<"Yes"<<'\n',void();
	int d=v.size()-1;ll L=v[0],R=v[d];
	if((R-L)%d)return IO::cout<<"No\n",void();
	ll B=(R-L)/d;
	for(int i=1;i<=d;i++){
		if(v[i]==1e9+1)v[i]=v[i-1]+B;
		if(v[i]!=v[i-1]+B)return IO::cout<<"No"<<'\n',void();
	}IO::cout<<"Yes"<<'\n';
}
```

代码是去年的代码了，有点丑。/yun

---


# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 样例 #1

### 输入

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 输入

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg```

### 输出

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g```

# 题解

## 作者：灯芯糕 (赞：1635)

### ## 本萌新又来发布题解了
###   ##  这一题，我们用搜索染色
###   ## 在此提供一简易代码：
### 预处理：
```cpp
int c[10000][2],d=0;//c[10000][2]用来存 “y”出现的地址 
int x[9]={0,1,0,1,-1,0,-1,1,-1};//八个方位 
int y[9]={0,0,1,1,0,-1,-1,-1,1};//方便比对 
char a[103][103],b,k[9]=" yizhong";
bool s[102][102];//定义染色体，“0”输出“*” ，“1”正常输出 
```
### 搜索函数：
```cpp
bool f(int i,int j,int m,int n,int next){//i,j为数组位置，m,n是方位 
	if(next>=8){//next是“yizhong”的第几个字符 
		s[i][j]=1;//比对完毕，进行染色； 
		return 1;//返回 
	}
	if(a[i+m][j+n]==k[next])//如果该位置上的字符与对应字符一致，则继续 
	    if(f(i+m,j+n,m,n,next+1)){
	    	s[i][j]=1;//染色 
	    	return 1;//返回上一层
		}
	return 0;//不一致，则结束 
```
### 输入：
```cpp
int n,i,j,o;
	cin>>n;
	for(i=1;i<=n;i++){
	    for(j=1;j<=n;j++){
			cin>>b;
			a[i][j]=b;//输入字符 
			if(b=='y'){
				c[++d][0]=i;//记录“y”的位置 
				c[d][1]=j;//d为“y”的个数 
			}
		}
	}
```
### 全方位搜索：
```cpp
while(d){
		i=c[d][0];
		j=c[d][1];
		for(o=1;o<=8;o++){//全方位递归搜索 
		   if(a[i+x[o]][j+y[o]]=='i')
		     if(f(i+x[o],j+y[o],x[o],y[o],3))
		         s[i][j]=1;
		}
		d--;
```
### 输出：
```cpp
for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(s[i][j])//染了色，便正常输出 
			cout<<a[i][j];
			else cout<<"*";//否则输出“*” 
		}
		cout<<endl;
	}
```
## 你们最爱的完整代码：
```cpp
#include<iostream>
using namespace std;
int c[10000][2],d=0,x[9]={0,1,0,1,-1,0,-1,1,-1};
int                 y[9]={0,0,1,1,0,-1,-1,-1,1};
char a[103][103],b,k[9]=" yizhong";
bool s[102][102];
bool f(int i,int j,int m,int n,int next){
    if(next>=8){
        s[i][j]=1;
        return 1;
    }
    if(a[i+m][j+n]==k[next])
        if(f(i+m,j+n,m,n,next+1)){
        	s[i][j]=1;
        	return 1;
        }
    return 0;
}
int main(){
    int n,i,j,o;
    cin>>n;
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            cin>>b;
            if(b=='y'){
                c[++d][0]=i;
                c[d][1]=j;
            }
            a[i][j]=b;
        }
    }
    while(d){
        i=c[d][0];
        j=c[d][1];
        for(o=1;o<=8;o++){
           if(a[i+x[o]][j+y[o]]=='i')
              if(f(i+x[o],j+y[o],x[o],y[o],3))
                 s[i][j]=1;
        }
        d--;
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            if(s[i][j])cout<<a[i][j];
            else cout<<"*";
        }
        cout<<endl;
    }
    return 0;
}
```
### 码字挺不容易，大家点个赞再走吧\0^◇^0/。

---

## 作者：拱垲 (赞：448)

# 通俗易懂的算法
## 声明
纯属原创，请勿抄袭
我的码风可能有点和别人不太一样（其实就是有点奇怪），~~大家重在意会即可~~。
## 目录

~~这个目录就是用来凑字数的，呵呵哒~~

前言

60分**骗分**代码详解

100分**AC**代码详解

后记
### 前言
  作为一道被卡了1个小时才做出这道水题萌新，表示自己码风有点菜，于是决定多做一点解释，~~毕竟80行的代码可能确实有点水~~QAQ。
### 60分骗分代码详解
  
   首先，为了便于比对单词，我建立了一个**string类对象**存储题目要求的单词（我表示并不清楚这个单词是否有实际意义，如果有哪位大佬知道，欢迎在评论里告诉我）
   
```cpp
string ans=" yizhong";

```
   然后，n与m表示数组下标，用no表示**该下标所应该对应的字母的编号**，如：
```cpp
int dfs(int n,int m,int no)
```

   如果越界：
```cpp
if(n<1||m<1||n>num||m>num)
        return 0;
```
   上深搜代码（解释以注释形式出现在代码中）：
```cpp
int dfs(int n,int m,int no)
{
    if(n<1||m<1||n>num||m>num)//如果越界则返回
        return 0;
    if(a[n][m]==ans[no])//如果是对应字母，则继续深搜
    {
        if(no==7)//如果搜到最后一个，则返回1，表示深搜成功
        {
            book[n][m]=1;
            return 1;
        }	
        else
        {
            //搜索每一种可能
            if(dfs(n+1,m,no+1)||dfs(n,m-1,no+1)||dfs(n,m+1,no+1)||dfs(n-1,m,no+1)||dfs(n+1,m-1,no+1)||dfs(n+1,m+1,no+1)||dfs(n-1,m-1,no+1)||dfs(n-1,m+1,no+1))
            {
            	//若搜索成功，标记该字符是单词的一部分
                book[n][m]=1;
                return 1;
            }
            else
                return 0;	
        }
    }
    else//否则返回0
        return 0;
}
```
大家仔细观察便会发现该代码的漏洞：他搜索所有的方向，因此如果有弯曲的字符连在一起与要求单词相同，它便认为该字符是单词的一部分，然而，题目要求必须是横或竖或斜直着相连的字符串才参与比对，故若有该类型的数据，此代码就会出错（这便是他只能作为骗分代码的原因）
  

最后，上你们最爱的完整代码（第一个和第三个点会WA，原因上面已经解释过，因此只能得60分）

```cpp
#include<iostream>
#include <string>
using namespace std;

char a[102][102];
bool book[102][102]={0};//标记对应字符是否是要求单词的一部分
int num;

int dfs(int n,int m,int no)
{
    if(n<1||m<1||n>num||m>num)//如果越界则返回
        return 0;
    if(a[n][m]==ans[no])//如果是对应字母，则继续深搜
    {
        if(no==7)//如果搜到最后一个，则返回1，表示深搜成功
        {
            book[n][m]=1;
            return 1;
        }	
        else
        {
            //搜索每一种可能
            if(dfs(n+1,m,no+1)||dfs(n,m-1,no+1)||dfs(n,m+1,no+1)||dfs(n-1,m,no+1)||dfs(n+1,m-1,no+1)||dfs(n+1,m+1,no+1)||dfs(n-1,m-1,no+1)||dfs(n-1,m+1,no+1))
            {
            	//若搜索成功，标记该字符是单词的一部分
                book[n][m]=1;
                return 1;
            }
            else
                return 0;	
        }
    }
    else//否则返回0
        return 0;
}
int main()
{
    //读入
    cin>>num;
    for(int i=1;i<=num;i++)
        for(int j=1;j<=num;j++)
        {
            cin>>a[i][j];
        }
    //深搜
    for(int i=1;i<=num;i++)
        for(int j=1;j<=num;j++)
            dfs(i,j,1);
    //输出
    for(int i=1;i<=num;i++)
    {
        for(int j=1;j<=num;j++)
        {
            if(book[i][j])
                cout<<a[i][j];
            else
                cout<<"*";
        }
        cout<<endl;
    }	
    return 0;
}
```
### 100分AC代码详解
我们说，上面的代码只能得60分的原因在于他不判断方向，而深搜所有的方向，因此会出错，解决代码也十分简单：在dfs（）函数中加一个表示方向的参数f即可：
```cpp
int dfs(int n,int m,int no,int f)
{
	if(n<1||m<1||n>num||m>num)//如果越界则返回
		return 0;
	if(a[n][m]==ans[no])//如果是对应字母，则继续深搜
	{
		if(no==7)//如果搜到最后一个，则返回1，表示深搜成功
		{
			book[n][m]=1;
			return 1;
		}	
		else
		{
            //有选择性的搜索
			switch (f)
			{
				case 1:	if(dfs(n-1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 2:	if(dfs(n-1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 3:	if(dfs(n-1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 4:	if(dfs(n,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
                /*case 5表示no==1，
                作为第一个字母，因此是个特例，要向所有方向搜索
                其余情况都只向一个特定方向搜索*/
				case 5:
					if(dfs(n-1,m-1,no+1,1))
						book[n][m]=1;
					if(dfs(n-1,m,no+1,2)) 
						book[n][m]=1;
					if(dfs(n-1,m+1,no+1,3)) 
						book[n][m]=1;
					if(dfs(n,m-1,no+1,4)) 
						book[n][m]=1;
					if(dfs(n,m+1,no+1,6)) 
						book[n][m]=1;
					if(dfs(n+1,m-1,no+1,7)) 
						book[n][m]=1;
					if(dfs(n+1,m,no+1,8)) 
						book[n][m]=1;
					if(dfs(n+1,m+1,no+1,9)) 
						book[n][m]=1;
					break;
				case 6:	if(dfs(n,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 7:	if(dfs(n+1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 8:	if(dfs(n+1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 9:	if(dfs(n+1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
			}
				
		}
	}
	else//如果搜到最后一个，则返回1，表示深搜成功
		return 0;
}
```

你们最爱的100分AC完整代码：

```cpp
#include<iostream>
#include <string>
using namespace std;

string ans=" yizhong";
char a[102][102];
bool book[102][102]={0};
int num;
int dfs(int n,int m,int no,int f);

int main()
{
	freopen("cs.in","r",stdin);
	cin>>num;
	for(int i=1;i<=num;i++)
		for(int j=1;j<=num;j++)
			cin>>a[i][j];
	for(int i=1;i<=num;i++)
		for(int j=1;j<=num;j++)
			dfs(i,j,1,5);
	for(int i=1;i<=num;i++)
	{
		for(int j=1;j<=num;j++)
		{
			if(book[i][j])
				cout<<a[i][j];
			else
				cout<<"*";
		}
		cout<<endl;
	}	
	return 0;
}

int dfs(int n,int m,int no,int f)
{
	if(n<1||m<1||n>num||m>num)//如果越界则返回
		return 0;
	if(a[n][m]==ans[no])//如果是对应字母，则继续深搜
	{
		if(no==7)//如果搜到最后一个，则返回1，表示深搜成功
		{
			book[n][m]=1;
			return 1;
		}	
		else
		{
            //有选择性的搜索
			switch (f)
			{
				case 1:	if(dfs(n-1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 2:	if(dfs(n-1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 3:	if(dfs(n-1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 4:	if(dfs(n,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
                /*case 5表示no==1，
                作为第一个字母，因此是个特例，要向所有方向搜索
                其余情况都只向一个特定方向搜索*/
				case 5:
					if(dfs(n-1,m-1,no+1,1))
						book[n][m]=1;
					if(dfs(n-1,m,no+1,2)) 
						book[n][m]=1;
					if(dfs(n-1,m+1,no+1,3)) 
						book[n][m]=1;
					if(dfs(n,m-1,no+1,4)) 
						book[n][m]=1;
					if(dfs(n,m+1,no+1,6)) 
						book[n][m]=1;
					if(dfs(n+1,m-1,no+1,7)) 
						book[n][m]=1;
					if(dfs(n+1,m,no+1,8)) 
						book[n][m]=1;
					if(dfs(n+1,m+1,no+1,9)) 
						book[n][m]=1;
					break;
				case 6:	if(dfs(n,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 7:	if(dfs(n+1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 8:	if(dfs(n+1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 9:	if(dfs(n+1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
			}
				
		}
	}
	else//如果搜到最后一个，则返回1，表示深搜成功
		return 0;
}

```



### 后记
  相信大家看到这里，便会感到深搜原来就是这么简单！记住：代码长！=晦涩难懂！无需十分在意自己的码风，能AC的代码就是好代码！最后，我辛苦敲了这么多，各位大佬能否给个赞呢？~~~

---

## 作者：hzg0226 (赞：389)

这道题是一个DFS的题目，从八向搜索。可以设置一个八向的常量数组，搜索每一个方向，如果满足条件就递归，否则结束递归。当搜索到第7个单词‘g’时，用vis保存路径，此次DFS也就结束了。

首先在矩阵中搜索，找到y和i相连的方向k，以k方向进行DFS。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=100+10;
struct node
{
    int x,y;
}c[maxn];//记录路径
char fz[maxn][maxn],stand[]="yizhong";//fz保存单词矩阵，stand保存保准的“yizhong”便于匹配
int vis[maxn][maxn];//保存路径，是否该点为答案
int dir[][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};//八向的常量数组
void dfs(int x,int y,node c[],int k,int cur)
{
    if(cur==7){
        for(int i=0;i<7;i++)
            vis[c[i].x][c[i].y]=1;
    }
    else{
        int dx=x+dir[k][0];//沿着正确的k方向搜索
        int dy=y+dir[k][1];
        if(cur==6||fz[dx][dy]==stand[cur+1]){
            c[cur].x=x;c[cur].y=y;
            dfs(dx,dy,c,k,cur+1);
        }
    }
}
int main()
{
    freopen("input.txt","r",stdin);
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%s",fz[i]);
    memset(vis,0,sizeof(vis));
    for(int i=0;i<n;i++)//搜索y，i相连的可能的方向k，以k为方向进行DFS
        for(int j=0;j<n;j++)
            if(fz[i][j]=='y') for(int k=0;k<8;k++){
                    int x=i+dir[k][0];
                    int y=j+dir[k][1];
                    if(fz[x][y]=='i')
                        dfs(i,j,c,k,0);
                    }
    for(int i=0;i<n;i++){//输出结果
        for(int j=0;j<n;j++)
            if(vis[i][j]) printf("%c",fz[i][j]);
            else printf("*");
        printf("\n");
    }
    return 0;
}
```

---

## 作者：Way_How_Fri3nd (赞：217)

# 一个新的思路
通过一个返回值为bool类型的DFS在搜索的同时顺便判断
```cpp
#include<iostream>
using namespace std;
int n,u[8]={0,-1,-1,-1,0,1,1,1},v[8]={1,1,0,-1,-1,-1,0,1};//八个方向
char le[200],chess[101][101];
bool ma[101][101];
bool DFS(int x,int y,char w,int p){//我在哪，我是什么字母，我现在的方向是哪
	if(w=='g'){//最后一个字母判断成功，标记，返回
		ma[x][y]=1;
		return 1;
	}
	int xx=x+u[p],yy=y+v[p];
	if(xx>=1 && yy>=1 && xx<=n && yy<=n && chess[xx][yy]==le[w])//搜索，不解释
	if(DFS(xx,yy,le[w],p)){
		ma[x][y]=1;
		return 1;
	}
	return 0;
}
int main(){
	le['y']='i';
	le['i']='z';
	le['z']='h';
	le['h']='o';
	le['o']='n';
	le['n']='g';//把单词串在一起
	cin>>n;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	cin>>chess[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(chess[i][j]=='y')//如果是单词开头
	for(int k=0;k<=7;k++)//就八个方向搜索
	if(DFS(i,j,'y',k)) ma[i][j]=1; //判断是否成单词
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
		if(ma[i][j]) cout<<chess[i][j];
		else cout<<'*';
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：zhaimingshuzms (赞：132)

#为什们前面代码都挺长，贴一短代码

先用常量a，b分别标记x，y的加减

再寻找“y”的位置

找到后用八个方向去试

如果每一位皆符合那么ans就赋值

最后处理一下ans，输出

-------------------------------------------------

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
string s[111],ans[111];
const int a[8]={0,-1,-1,-1,0,1,1,1},b[8]={1,1,0,-1,-1,-1,0,1};
int t1,t2,kk,k,i,j,n;
bool bb;
int main()
{
    cin>>n;
    for (i=1; i<=n; i++) cin>>s[i];
    for (i=1; i<=n; i++)
    for (j=1; j<=n; j++)
    ans[i]+='0';
    for (i=1; i<=n; i++)
    for (j=0; j<=n-1; j++)
    if (s[i][j]=='y') 
    {
        for (k=0; k<=7; k++)
        {
            t1=i;  t2=j;
            bb=1;
            for (kk=1; kk<=6; kk++)
            {
                t1+=a[k]; t2+=b[k];
                if (t1<1||t1>n||t2<0||t2>n-1) bb=0;
                if (bb==0) break;
                if (kk==1&&s[t1][t2]!='i') bb=0;
                if (kk==2&&s[t1][t2]!='z') bb=0;
                if (kk==3&&s[t1][t2]!='h') bb=0;
                if (kk==4&&s[t1][t2]!='o') bb=0;
                if (kk==5&&s[t1][t2]!='n') bb=0;
                if (kk==6&&s[t1][t2]!='g') bb=0;
            } 
            t1=i; t2=j;
            if (bb) for (kk=0; kk<=6; kk++) ans[t1][t2]=s[t1][t2],t1+=a[k],t2+=b[k];
        }
    }
    for (i=1; i<=n; i++)
    for (j=0; j<=n-1; j++)
    if (ans[i][j]=='0') ans[i][j]='*';
    for (i=1; i<=n; i++)
    cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：fy1234567ok (赞：120)

# 深度优先搜索

## 思路：
	先找y，如果找到y了就说明它附近可能会有我们要找的单词 yizhong 
    于是接下来沿着8个方向找izhong， 如果越界或者不符合就舍弃， 如果找到了就记录在ans数组里面，
    最后输出ans数组
    
## 代码简化技巧
### 1. 方向数组的运用
```cpp
const int dx[] = {1, 1, 1, 0, 0, -1,-1,-1 };  
const int dy[] = {1, 0,-1, 1,-1, 0 , 1,-1 };
```

### 2. 定义常量比较数组
```cpp
const string cmp = "yizhong"; 
```

这样判断是否有izhong的时候就比较方便
可以用一个for循环，比如，x行y列有个“y”，以第i个方向为例：
```
for(int j = 1;j <= 6;j++) { //以1个方向比较 “izhong”   
			int nx = x + j*dx[i];    
			int ny = y + j*dy[i];
			if(nx < 1 || nx > n || ny < 1 || ny > n) { //判越界 
				flag = 0;
				break;
			}
			if(cmp[j] != A[nx][ny]) {  
				flag = 0;
				break;
			}
		}
```

这里j是步长，这里的j正好对应了yizhong 的第j位
所以正好可以对应起来

完整代码：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int maxn = 110;
const int dx[] = {1, 1, 1, 0, 0, -1,-1,-1 };  //方向数组 
const int dy[] = {1, 0,-1, 1,-1, 0 , 1,-1 };
const string cmp = "yizhong"; // 比较数组 

char A[maxn][maxn], ans[maxn][maxn];
int mark[maxn][maxn], n;

void dfs(int x,int y) {
	for(int i = 0;i < 8;i++) {  //枚举8个方向 
		int flag = 1;
		for(int j = 1;j <= 6;j++) { //以1个方向比较 “izhong”   
			int nx = x + j*dx[i];    
			int ny = y + j*dy[i];
			if(nx < 1 || nx > n || ny < 1 || ny > n) { //判越界 
				flag = 0;
				break;
			}
			if(cmp[j] != A[nx][ny]) {  //判断第j位是否符合 
				flag = 0;
				break;
			}
		}
		if(flag == 0) continue;
		for(int j = 0;j <= 6;j++) { //符合就记录在ans数组里 
			int nx = x + j*dx[i];
			int ny = y + j*dy[i];
			ans[nx][ny] = A[nx][ny];
		}
	}
	return;
}

int main() {
	cin >> n;
	for(int i = 1;i <= n;i++) {
		for(int j = 1;j <= n;j++) {
			cin >> A[i][j];
		}
	}
	
	for(int i = 1;i <= n;i++) { 
		for(int j = 1;j <= n;j++) {
			if(A[i][j] == 'y') dfs(i,j);//如果发现有y就开始搜索 
		}
	}
	for(int i = 1;i <= n;i++) { //输出 
		for(int j = 1;j <= n;j++) {
			if(ans[i][j] == 0) ans[i][j] = '*';//如果没有改动就输出* 
			cout << ans[i][j];
		}
		cout << endl;
	}
	return 0;
} 
```


---

## 作者：FLDPMpang (赞：72)

### [P1101题目链接](https://www.luogu.org/problem/P1101)
### [想获得更好的观看体验，请在博客内查看](https://www.luogu.org/blog/Frozen-lobster/p1101)

## 先说一下我的思路吧：
1. 找出首字母Y
1. 找出字母Y旁边的I，记录其扩展方向
1. 依次检查沿Y向I方向的字母
1. 若至字母G时无误记录下其单词扩展路径
1. 输出合法的单词**

### 预定义：
```cpp
char s[105][105];
const string key="yizhong";

int n,idx[105][105]{}; //c++11用法，把idx数组全部初始化为0
//idx[i][j]=1 代表可成为单词，s表示原方阵，key为单词

```

### 主函数
```cpp
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)	scanf("%s",&s[i]);
	for(int i=0;i<n;i++)  	for(int j=0;j<n;j++) {
		if(s[i][j]=='y'){	//找到单词的起点
		for(int dr=-1;dr<=1;dr++) 
				for(int dc=-1;dc<=1;dc++){    //二重循环可用常量数组替代
					if(s[i+dr][j+dc]=='i')   dfs(dr,dc,i,j,0);
                 //dr，dc，代表竖直和水平共8个方向 ，找到搜索方向后进行搜索,      
		}
	}
	for(int i=0;i<n;i++) {
		for(int j=0;j<n;j++){
			if(idx[i][j]) printf("%c",s[i][j]);
			else printf("*");
		}
      //输出答案，记得换行
		printf("\n");
	}
	return 0;
}
```

### 搜索函数
```cpp
void dfs (int dr,int dc,int r,int c,int cnt){
	if(cnt==7) {
		for(int i=1;i<=7;i++) idx[r-dr*i][c-dc*i]=1;
	}
	//搜索终点，如果可成为一个单词，令其路径上的所有字母 idx=1
    
	if( r>=0&&r<n&&c>=0&&c<n &&s[r][c]==key[cnt]) {
		dfs(dr,dc,r+dr,c+dc,cnt+1);
	}
   	//进行下一个字母的检查和搜索
	return;
}
```
### 完整~~压行~~代码
```cpp
#include<cstdio>
#include<string>
using namespace std;
char s[105][105];
const string key="yizhong";
int n,idx[105][105]{};	
void dfs (int dr,int dc,int r,int c,int cnt){
	if(cnt==7)	for(int i=1;i<=7;i++)  idx[r-dr*i][c-dc*i]=1;
	if( r>=0&&r<n&&c>=0&&c<n &&s[r][c]==key[cnt])	dfs(dr,dc,r+dr,c+dc,cnt+1);
}
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)	scanf("%s",&s[i]);
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(s[i][j]=='y') 
    		for(int dr=-1;dr<=1;dr++) for(int dc=-1;dc<=1;dc++)
			if(s[i+dr][j+dc]=='i') dfs(dr,dc,i,j,0);
	for(int i=0;i<n;i++) for(int j=0;j<n;j++){
			if(idx[i][j]) printf("%c",s[i][j]);
			else printf("*");
		}
		printf("\n");
	return 0;
}
```
点个赞再走吧qwq


---

## 作者：circle_star (赞：45)

这道题我用的是一种"染色"的方法

首先枚举y的位置，然后按izhong进行搜索验证

代码如下，注释已经很清楚了

```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
char a[1001][1001];
int b[1001][1001];//b数组用来染色 
char c[6]="izhong";//判断字符 
int next[8][2]={{1,0},{0,1},{1,1},{1,-1},{-1,1},{-1,-1},{0,-1},{-1,0}};//如果两个方向相反则相加为7 
//一共八个方向 
int dx,dy;//是delta x的缩写 
int n;
void ranse(int x,int y,int step,int fang)//显而易见的染色操作 
{
    if(step>=7) return; 
    b[x][y]=1; 
    dx=x+next[fang][0];//向下个方向 
    dy=y+next[fang][1];
    ranse(dx,dy,step+1,fang); //继续往下染色 
} 
void dfs1(int x,int y,int step,int fang)//fang是方向  step用来指向c中对应字符 
{
    if(x<0||y<0||x>n||y>n) return; //防止越界 
    if(step>=6) //如果step为6了则从y出发都满足 
    {
        ranse(x,y,0,7-fang);//注意7-fang为原来方向的反方向 
        //cout<<233<<endl; 
        return;
    }
    dx=x+next[fang][0];
    dy=y+next[fang][1];
    
    if(a[dx][dy]!=c[step])    return;//如果字符不相同则退出这个方向的枚举 
    else dfs1(dx,dy,step+1,fang);//继续往下验证 
}
void dfs2()//这一步是找y如果找到就调用dfs1验证是否满足 
{
    for(int i=1;i<=n;i++)
      for(int j=0;j<n;j++) 
      {
          if(a[i][j]=='y') //寻找y 
          {
              for(int k=0;k<=7;k++)//枚举7个方向 
               dfs1(i,j,0,k); 
          }
      }
} 
int main() 
{
    //yizhong
    cin>>n;
    for(int i=1;i<=n;i++)
        scanf("%s",a[i]);
    dfs2(); 
    for(int i=1;i<=n;i++)
    {
      for(int j=0;j<n;j++)
        if(b[i][j]==1) // 如果被染了色则输出 
        cout<<a[i][j]; 
        else cout<<"*"; //否则输出* 
    cout<<endl; 
    }
}
```

---

## 作者：wick (赞：32)

这道题是一简单DFS题，直接从八向搜索即可。

可以设置一个八向的常量数组dir[8][2]，先找每一个开头的y，再递归搜索每一个方向，如果满足条件就标记一下，否则结束递归，此次DFS也就结束了。

**要记住思路越精简越好。**

下面分段讲述：

**输入**（不用多讲）

```
        sta="yizhong";
	cin>>n;
	for(int i=1; i<=n; i++)
	    for(int j=1; j<=n; j++)
		cin>>s[i][j];
```

刮号能省则省。

**搜索**

```
        for(int i=1; i<=n; i++)
            for(int j=1; j<=n; j++)
		if(s[i][j]=='y') for(int k=0; k<8; k++) dfs(i,j,k);
        //先找每一个开头的y，再递归搜索每一个方向
```
**DFS**

```
void dfs(int x,int y,int di) {
	int  a=x,b=y;
	for(int j=0; j<7; j++) {
		if(sta[j]!=s[a][b]) return;//与“yizhong”不同时。
		a+=dir[di][0];
		b+=dir[di][1];
	}
	for(int j=0; j<7; j++) {//标记
		book[x][y]=1;
		x+=dir[di][0];
		y+=dir[di][1];
	}
 }
```

**输出**

```
        for(int i=1; i<=n; i++) {
	    for(int j=1; j<=n; j++) {
		if(!book[i][j])cout<<'*';
		else cout<<s[i][j];
	       }
		cout<<endl;
	}
```
**定义**

```
        int n;
        string sta;
	char s[105][105];
	int book[105][105];
	int dir[8][2]= {-1,-1,-1,0,-1,1,0,1,1,1,1,0,1,-1,0,-1};//小心打错！！！ 
```

下面上全码：

	```
	#include<bits/stdc++.h>
	using namespace std;
	int n;
	string sta;
	char s[105][105];
	int book[105][105];
	int dir[8][2]= {-1,-1,-1,0,-1,1,0,1,1,1,1,0,1,-1,0,-1};
	void dfs(int x,int y,int di) {
		int  a=x,b=y;
		for(int j=0; j<7; j++) {
			if(sta[j]!=s[a][b]) return;
			a+=dir[di][0];
			b+=dir[di][1];
		}
		for(int j=0; j<7; j++) {
			book[x][y]=1;
			x+=dir[di][0];
			y+=dir[di][1];
		}
	}
	int main() {
		sta="yizhong";
		cin>>n;
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				cin>>s[i][j];
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				if(s[i][j]=='y') for(int k=0; k<8; k++) dfs(i,j,k);
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				if(!book[i][j])cout<<'*';
				else cout<<s[i][j];
			}
			cout<<endl;
		}
            while(1)//防抄袭
		return 0;
	}
```





---

## 作者：北海_Beihai (赞：21)

#暴力！！！

枚举每一个长度为7的字符串（这里我们规定只往下、右、右下、右下四个方向进行枚举），然后判断它们是否为yizhong或它的镜像gnohziy，如果是就对它所覆盖的范围做标记，最后只将打过标记的字符原样输出。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[110],s1("yizhong"),s2("gnohziy");
int f[110][110];
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int j=0;j<=n-7;j++)
        for(int i=0;i<n;i++)
        {
            string s("");
            for(int k=j;k<=j+6;k++) s=s+a[i][k];
            if(s==s1||s==s2) for(int k=j;k<=j+6;k++) f[i][k]=1;
        }
    for(int i=0;i<=n-7;i++)
        for(int j=0;j<n;j++)
        {
            string s("");
            for(int k=i;k<=i+6;k++) s=s+a[k][j];
            if(s==s1||s==s2) for(int k=i;k<=i+6;k++) f[k][j]=1;
        }
    for(int j=0;j<=n-7;j++)
    {
        for(int i=0;i<=n-7;i++)
        {
            string s("");
            for(int k=0;k<=6;k++) s=s+a[i+k][j+k];
            if(s==s1||s==s2) for(int k=0;k<=6;k++) f[i+k][j+k]=1;
        }
        for(int i=n-1;i>=6;i--)
        {
            string s("");
            for(int k=0;k<=6;k++) s=s+a[i-k][j+k];
            if(s==s1||s==s2) for(int k=0;k<=6;k++) f[i-k][j+k]=1;
        }
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++) if(f[i][j]) cout<<a[i][j]; else cout<<'*';
        cout<<"\n";
    }
    return 0;
}
```

---

## 作者：R·Buffoon (赞：11)

这题有$2$种解法，$1$是搜索（不会），$2$是暴力
***
感觉题解里的暴力不够整齐或简洁，于是就来发一波自己的暴力，个人认为比较整洁和简洁（$especially$暴力部分），而且应该也是比较好理解的
```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;

int n;
char c[N][N],ans[N][N];
char s[]={'y','i','z','h','o','n','g'};//预处理要突显的单词

int main()
{
    cin>>n;
    for(RI i=1;i<=n;++i)
    {
    	for(RI j=1;j<=n;++j)
    	{
    		cin>>c[i][j];
    		ans[i][j]='*';//预处理ans数组
		}
	}
	
	for(RI i=1;i<=n;++i)
	{
		for(RI j=1;j<=n;++j)
		{
			if(c[i][j]==s[0])//如果第一个字符匹配，就寻找下一个字符
			{
				int f1,f2,f3,f4,f5,f6,f7,f8;
				f1=f2=f3=f4=f5=f6=f7=f8=1;
				for(RI k=1;k<=6;++k)
				{
					if(c[i+k][j]!=s[k]) f1=0;//右横（8个寻找方向）
					if(c[i-k][j]!=s[k]) f2=0;//左横
					if(c[i][j+k]!=s[k]) f3=0;//下竖
					if(c[i][j-k]!=s[k]) f4=0;//上竖
					if(c[i-k][j+k]!=s[k]) f5=0;//右上
					if(c[i+k][j+k]!=s[k]) f6=0;//右下
					if(c[i-k][j-k]!=s[k]) f7=0;//左上
					if(c[i+k][j-k]!=s[k]) f8=0;//左下
				}
				
				if(f1) for(RI k=0;k<=6;++k) ans[i+k][j]=c[i+k][j];//如果匹配的话，就储存答案
				if(f2) for(RI k=0;k<=6;++k) ans[i-k][j]=c[i-k][j];
				if(f3) for(RI k=0;k<=6;++k) ans[i][j+k]=c[i][j+k];
				if(f4) for(RI k=0;k<=6;++k) ans[i][j-k]=c[i][j-k];
				if(f5) for(RI k=0;k<=6;++k) ans[i-k][j+k]=c[i-k][j+k];
				if(f6) for(RI k=0;k<=6;++k) ans[i+k][j+k]=c[i+k][j+k];
				if(f7) for(RI k=0;k<=6;++k) ans[i-k][j-k]=c[i-k][j-k];
				if(f8) for(RI k=0;k<=6;++k) ans[i+k][j-k]=c[i+k][j-k];
			}
		}
	}
	
	for(RI i=1;i<=n;++i)//输出答案
	{
		for(RI j=1;j<=n;++j)
		{
			cout<<ans[i][j];
		}
		cout<<endl;
	}
    
    return 0;
}
```
用一个循环判断是否匹配，马量较少吧，不到$70$行

~~如果觉得暴力部分好看的话，不要忘了点赞哦~~

---

## 作者：CCCPKeay (赞：9)

此题看见大佬都是用搜索过的,我来一个伪搜索~~模拟~~.

先感谢@my亦客♂dalao 的思路 十分感谢！！！

## 思路:

有题目知,我们要在这个n*n的矩阵里寻找"yizhong"这样的字符串.

且有一定的方向,在由样例我们可以看出字符串"yizhong"能有八个方

向. 那么我们怎么确定方向？很简单只要找出字母'i'即能找出这条字

符串的方向,因为字母'y'和字母'i'连在一起所以由两个字母就可以确

定整个字符串的方向.当我们遍历完整个字符串时,该怎么输出？题目

说明了只需要输出必要的字符串"yizhong".剩下的输出"*". 那我们可

以 用一个bool型数组vis[ ][ ],如果它是我们需要输出的字母,那我

们就把它赋值为"true",否则就赋值为false(即输出"*");

步骤:

1.遍历全图寻找"y";

2.在已经找到的字母"y"上寻找与y相连的字母'i'这是便已经确定方向

3.确定方向后寻找剩下合格的字母.

4.将合格的字符串中的字母赋值为"true".

5.如果为true输出字母否则输出'*';

## 代码:(丑陋冗长的代码)

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <queue>
#include <cstdlib>
using namespace std;
const int  N=100+10;
char Map[N][N];
int n,sx,sy,direct,j;
int dirx[8]={0,1,-1,0,1,-1,1,-1};//八个方向 
int diry[8]={1,0,0,-1,1,-1,-1,1};
bool vis[N][N];
void f(int ,int ,int ); 
void keay(int ,int ,int );
void dfs(int x,int y)
{
	for(j=0;j<8;j++)//找字母'i'由字母'i' 我们可以知道整个字符串的方向; 
	{
		int xx=x+dirx[j];
		int yy=y+diry[j];
		if(xx<1||xx>n||yy<1||yy>n) continue;
		if(Map[xx][yy]=='i')
		{
			f(xx,yy,j);//j为方向  为了构成合格字符串  我们只能往j这个方向寻找 
		}
	}
	return;
}
void f(int x,int y,int direct)
{
	int lens=0;
	int xx=x;int yy=y;
	for(int i=0;i<5;i++)//5次循环找到剩余的5个字母 
	{
		xx=xx+dirx[direct];
		yy=yy+diry[direct];
		if(i==0)//第一次必须是字母'z'; 
		{
			if(Map[xx][yy]=='z')
			lens++;
		}
		if(i==1)//第二次必须是字母'h'; 
		{
			if(Map[xx][yy]=='h')//.......
			lens++;
		}
		if(i==2)
		{
			if(Map[xx][yy]=='o')
			lens++;
		}
		if(i==3)
		{
			if(Map[xx][yy]=='n')
			lens++;
		}
		if(i==4)
		{
			if(Map[xx][yy]=='g')
			lens++;
		}
		if(lens==5)//当寻找的字母长度为5时说明'zhong'已找齐; 
		keay(xx,yy,direct);
	}
}
void keay(int x,int y,int dir)//把需要输出的字母赋值为true; 
{
	vis[x][y]=true; 
	for(int i=0;i<6;i++)//循环依次赋值为true; 
	{
		x=x-dirx[dir];
		y=y-diry[dir];
		vis[x][y]=true; 
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)//输入 
	{
		for(int j=1;j<=n;j++)
		{
			cin>>Map[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(Map[i][j]=='y')//找'y'; 
			{
				sx=i;sy=j;
				dfs(sx,sy);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)//直接判断vis的值为true还是false然后直接输出 
		{
			if(vis[i][j])//因为前面遍历全图将需要输出的字母赋值为true; 
			cout<<Map[i][j];
			else cout<<"*";//不成立的字母我们赋值为false 
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：do_while_true (赞：6)

# 超级暴力解法
###### （不想用dalao们的方法做~~其实是看不懂dalao们的代~~码
思路：循环跑一遍然后遇到y就开始跑判断，如果为yizhong就把这个位置标记，然后输出的时候就可以根据标记输出
###### (对于我这种蒟蒻简直是天堂般 的解法）

------------
具体做法

1：输入

2：循环跑一遍，遇到y开始进入函数判断

3：（函数部分）八个方向暴力判断，符合就标记

4：根据标记输出

------------
还是很好理解的

具体代码贴在下面
```
#include<iostream>
#include<cstdio>
using namespace std;
char a[101][101];
bool b[101][101];
int n;
void iff(int x,int y)
{
		/*当前行前面*/if(a[x][y-1]=='i'&&a[x][y-2]=='z'&&a[x][y-3]=='h'&&a[x][y-4]=='o'&&a[x][y-5]=='n'&&a[x][y-6]=='g') for(int k=0;k<=6;k++) b[x][y-k]=1;//{b[x][y]=1;b[x][y-1]=1;b[x][y-2]=1;b[x][y-3]=1;b[x][y-4]=1;b[x][y-5]=1;b[x][y-6]=1;}
		/*当前行后面*/if(a[x][y+1]=='i'&&a[x][y+2]=='z'&&a[x][y+3]=='h'&&a[x][y+4]=='o'&&a[x][y+5]=='n'&&a[x][y+6]=='g') for(int k=0;k<=6;k++) b[x][y+k]=1;
		/*当前列上面*/if(a[x-1][y]=='i'&&a[x-2][y]=='z'&&a[x-3][y]=='h'&&a[x-4][y]=='o'&&a[x-5][y]=='n'&&a[x-6][y]=='g') for(int k=0;k<=6;k++) b[x-k][y]=1;
		/*当前列下面*/if(a[x+1][y]=='i'&&a[x+2][y]=='z'&&a[x+3][y]=='h'&&a[x+4][y]=='o'&&a[x+5][y]=='n'&&a[x+6][y]=='g') for(int k=0;k<=6;k++) b[x+k][y]=1;
		/*左上*/if(a[x-1][y-1]=='i'&&a[x-2][y-2]=='z'&&a[x-3][y-3]=='h'&&a[x-4][y-4]=='o'&&a[x-5][y-5]=='n'&&a[x-6][y-6]=='g') for(int k=0;k<=6;k++) b[x-k][y-k]=1;
		/*右下*/if(a[x+1][y+1]=='i'&&a[x+2][y+2]=='z'&&a[x+3][y+3]=='h'&&a[x+4][y+4]=='o'&&a[x+5][y+5]=='n'&&a[x+6][y+6]=='g') for(int k=0;k<=6;k++) b[x+k][y+k]=1;
		/*右上*/if(a[x-1][y+1]=='i'&&a[x-2][y+2]=='z'&&a[x-3][y+3]=='h'&&a[x-4][y+4]=='o'&&a[x-5][y+5]=='n'&&a[x-6][y+6]=='g') for(int k=0;k<=6;k++) b[x-k][y+k]=1;
		/*左下*/if(a[x+1][y-1]=='i'&&a[x+2][y-2]=='z'&&a[x+3][y-3]=='h'&&a[x+4][y-4]=='o'&&a[x+5][y-5]=='n'&&a[x+6][y-6]=='g') for(int k=0;k<=6;k++) b[x+k][y-k]=1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	      cin>>a[i][j];//输入 
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	      if(a[i][j]=='y') iff(i,j);//遇到y 跑一遍判断 
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
           {
           	if(b[i][j]==0) cout<<"*";
           	else cout<<a[i][j];
		   }
		cout<<endl;
	}
    return 0;
}
```


---

## 作者：kid1999 (赞：4)

在luogu混了好几个月了，还是很菜，发现大佬都喜欢用C++，但是个人喜欢用Java，所以写了一份和我一样菜但是应该比较容易懂的题解。轻喷。。。

```java
import java.util.Scanner;

public class Main {
  static char[][] dp;  // 输入二维表
  static boolean[][] flag;  // 标记(染色)数组
  static int[][] func;      // 方向数组
  static char[] aim;        // 目标矩阵
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    aim = new char[]{'y', 'i', 'z', 'h', 'o', 'n', 'g'};
    func = new int[][]{{1, 1}, {1, 0}, {1, -1}, {-1, 0}, {-1, 1}, {-1, -1}, {0, 1}, {0, -1}};
    flag = new boolean[n][n];
    dp = new char[n][n];
    for (int i = 0; i < n; i++) {
      dp[i] = sc.next().toCharArray();
    }
    // 遍历数组  找到一个 ‘y’ 然后 在其周围找到一个 ‘i' 确定这个方向继续DFS 搜索染色
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (dp[i][j] == 'y') {
          for (int k = 0; k < func.length; k++) {
            if (i + func[k][0] >= 0 && i + func[k][0] < dp.length && j + func[k][1] >= 0 && j + func[k][1] < dp.length) {
              if(dp[i + func[k][0]][j + func[k][1]] == 'i' && DFS(i + func[k][0], j + func[k][1], func[k][0], func[k][1], 1)){
                flag[i][j] = flag[i + func[k][0]][j + func[k][1]] = true;   // 满足条件都给染色
              }
            }
          }
        }
      }
    }
    // 输入 被染色的 字母
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (flag[i][j]) System.out.print(dp[i][j]);
        else System.out.print("*");
      }
      System.out.println();
    }
  }
  // 当前位置的坐标 和 行进的 方向 y，x，以及当前是第几个字符
  private static boolean DFS ( int i, int j, int y, int x, int index){
    if (aim[index] != dp[i][j]) return false;
    if (aim[index] == dp[i][j] && index == 6){
      flag[i][j] = true;
      return true;
    }
    boolean tmp = false;
    if (i + y >= 0 && i + y < dp.length && j + x >= 0 && j + x < dp.length) {
      tmp = DFS(i+y, j+x, y, x, index+1);   // 满足条件继续搜索
    }
    if(tmp) flag[i][j] = true;
    return tmp;
  }
}
```


---

## 作者：行者_Walker (赞：4)

### 发个不让你头大的短代码
咳咳，先清一下思路

1.要单独开数组存图，方便输出字母；

2.既然题目说了方向不能变，那就在递归的时候传个方向，只向这个方向搜；
（我传的方向是一个数，代表我之前存的fx[ i ] fy[ i ]的 i）

3.因为还要判断是否符合"yizhong"，那还要再传一个数，告诉你应该和哪个字母匹配

4.要从头搜起，找到一个y，就搜它的身体，就像抓虫子一样，从头拎；

5.用来标记与储存的数组要开成int型的，不然有重字母的时候很麻烦，用int型的可以很轻松的存储重边；

我这个代码主旨就是先找到头，再找头的

I am very happy to show you my code.
```cpp
# include <bits/stdc++.h>//压行专用 
using namespace std;
string map[110];//存图 
int ans[110][110]={0};//标记答案 
int fx[]={1,0,-1,0,1,-1,1,-1};//可以不用在括号里标明大小
int fy[]={0,-1,0,1,-1,1,1,-1};//让它自己算大小多少
string pie("yizhong");//用来判断的数组 
int flag=0;//用来标记是否要清0 
int n;//图的大小 
void so(int x,int y,int k,int num)//x,y是当前的坐标，k传送方向，num方便pie[num]判断 
{
	if(num==7)//顺利搜完！！注意，是num=7(pie[6]='g')
	{
		flag=1;return ;//标记一下，不清0数组 
	}
	int xx=x+fx[k];
	int yy=y+fy[k];
	if(xx<0||xx>=n||yy<0||yy>=n) return ;
	if(map[xx][yy]==pie[num])//判断这个字符符合要求不 
	{
		ans[xx][yy]++;
		so(xx,yy,k,num+1);//k不变，同方向搜下一个 
		if(flag==0) ans[xx][yy]--;//消除本次标记 
		return ;
	}
	else return ;
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>map[i];
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	{
		if(map[i][j]=='y')//找到一个头就开搜它的身体
		for(int k=0;k<=7;k++)//方向转换器 
		{
			ans[i][j]++;
			so(i,j,k,1);
			if(flag==0)
				ans[i][j]--;//这条路搜不到就删了头，换方向 
			else
			{
				flag=0;break;
 //break可以防止再次搜其他边而错误地把这一个头删了(剪枝)
 //我就在这里被坑惨了
			}
		}
	}
	for(int i=0;i<n;i++,printf("\n"))
	for(int j=0;j<n;j++)
	{
		if(ans[i][j]>=1) printf("%c",map[i][j]);
        //有标记，不管重了几个点都把原图这个位置的字母输出来 
		else 
		printf("*");
	}
	return 0;
}
```
在代码中，通过ans[ i ][ j ]的++和- -就可以一层层地标记或删除重复的点了

希望能帮助到你，我知道大多数人都喜欢看短代码，me too。

---

## 作者：「QQ红包」 (赞：4)

简单的搜索

简单的搜搜。在有y的地方往八个方向搜，如果组成yizhong的话就在b数组标记。

注意判断交叉。

```delphi

#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int ffxx[8][2]={{0,1},{0,-1},{1,-1},{1,0},{1,1},{-1,-1},{-1,0},{-1,1}};
char s[101][101],b[101][101];
char ss[8]="yizhong";
int n;
void pr(int i,int x,int y)
{
____int xx,yy;
____xx=x;yy=y;
____for(int j=6;j>=0;j--)
____{
________b[xx][yy]=ss[j];
________xx=xx-ffxx[i][0];
________yy=yy-ffxx[i][1];
____}
}
void dfs(int x1,int y1,int sum,int fx/*记录同一方向*/)
{
____if(sum==7)//如果七个字符都有了
____{
________pr(fx,x1,y1);
____} else
____{
________if (b[x1+ffxx[fx][0]][y1+ffxx[fx][1]]!='*')//防止交叉
________{
____________return;
________}
________if ((s[x1+ffxx[fx][0]][y1+ffxx[fx][1]]==ss[sum])
________ &&(x1+ffxx[fx][0]>0)
________ &&(y1+ffxx[fx][1]>0)
________ &&(x1+ffxx[fx][0]<=n)
________ &&(y1+ffxx[fx][1]<=n)//在范围内
________ &&(b[x1+ffxx[fx][0]][y1+ffxx[fx][1]]=='*'))//再次防止交叉
________{
____________dfs(x1+ffxx[fx][0],y1+ffxx[fx][1],sum+1,fx);//深搜
________}
____}
}
int main()
{
____cin>>n;//读入
____for (int i=1;i<=n;i++)
____{
________for (int j=1;j<=n;j++)
________{
____________cin>>s[i][j];
____________b[i][j]='*';
________}
____}
____for (int i=1;i<=n;i++)
________for (int j=1;j<=n;j++)
________{
____________if(s[i][j]=='y')
____________{
________________for(int k=0;k<=7;k++)
________________{
____________________if(b[i][j]=='*') dfs(i,j,1,k);//防止交叉
________________}____
____________}
________}
____for (int i=1;i<=n;i++)
____{
________for (int j=1;j<=n;j++)
________{
____________printf("%c",b[i][j]);//输出
________}
________cout <<endl;
____}
____return 0;
}

```

---

## 作者：PARADIS (赞：3)

这个题本蒟蒻一开始用深搜半天写不对，差点心态爆炸。后来索性不用搜索了。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[8];				//用来与“yizhong”比较的数组
char standard[8]="yizhong";
int n,t=0;				//n是变量
char map[101][101];			//存储地图
int book2[101][101]={0};		//标记图中某一点构成yizhong字样 
int next[8][2]={{0,1},{1,0},{0,-1},{-1,0},{-1,1},{1,1},{1,-1},{-1,-1}};				//方向数组
int main(void)
{
	int i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	 for(j=1;j<=n;j++)
	 cin>>map[i][j];	 
	 int f,k;
	 int u;				//用来记录方向 
	 int tx,ty;
	 a[0]='y';
	for(i=1;i<=n;i++)
	 for(j=1;j<=n;j++)
	 {	if(map[i][j]=='y')
	 	{
	 		for(k=0;k<=7;k++)
	 		{
	 			tx=i+next[k][0];
	 			ty=j+next[k][1];
	 			if(map[tx][ty]=='i')
	 			{
	 				for(t=1;t<7;t++)
	 				{
	 					if(tx<1||tx>n||ty<1||ty>n) break;
	 					a[t]=map[tx][ty];
	 					tx=tx+next[k][0];
	 					ty=ty+next[k][1];
					}
					if(t==7&&strcmp(a,standard)==0)
					{	book2[i][j]=1;
						
						for(f=0;f<7;f++)
						{	tx=tx-next[k][0];
							ty=ty-next[k][1];
							book2[tx][ty]=1;
							
						}
					}
				}
			}
	 		
		 }
	 }
	 for(i=1;i<=n;i++)
	 	for(j=1;j<=n;j++)
	 if(book2[i][j]==0)  map[i][j]='*';
	 for(i=1;i<=n;i++)
	  {
	  	for(j=1;j<=n;j++)
	  	cout<<map[i][j];
	  	cout<<endl;
	  }
	  return 0;
}
```
整体的思路：
从第一个点开始遍历，如果这个点是“y”，则开始向8个方向搜索，一旦找到“i”，就确定了之后搜索的方向，把这个方向上7个点赋值到a数组。
之后与“yizhong”字样比较，如果相同则把这一路上所有的点标记为1，即book2[tx][ty]为1。遍历完所有“y”之后，遍历book2数组，book2中为0的值全部打上“*”，即可。
我这个思路还是蛮简单的，大学生第一次写题解，望各位小学初中高中轻喷^_^

---

## 作者：修罗海神王 (赞：3)

# ******这是一道水中水题******
 
###  _其实也没什么，**暴枚**就行了_ 

### 啥？暴枚？？？


##               说出来你真不信
#### 好了话不多说
# 直接来代码(✪ω✪)(✪ω✪)(＾＿－)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,xx,yy,bo[110][110];
string st,stt;
char a[110][110];
int main()
{
	stt="yizhong";//首先将这个字符串定义出来，存stt
	cin>>n;//读入n,矩阵为n*n的正方形
	getline(cin,st);//换行
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) cin>>a[i][j];//读入字符串，用char来存进去
		getline(cin,st);//换行
	 } 
	for(int i=1;i<=n;i++)//枚举行
	{
		for(int j=1;j<=n;j++)//枚举列
		{
			x=0;//x表示yizhong这个字符串里的位置
			if(a[i][j]==stt[x])//如果a[i][j]和第一个一样
			{
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一
				while(a[xx+1][j]==stt[x]){xx++;x++;if(x==7) {bo[i][j]=bo[i+1][j]=bo[i+2][j]=bo[i+3][j]=bo[i+4][j]=bo[i+5][j]=bo[i+6][j]=1;break;}}//如果上一个和stt[x]一样,xx++,行向上一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
			        xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[xx-1][j]==stt[x]) {xx--;x++;if(x==7) {bo[i][j]=bo[i-1][j]=bo[i-2][j]=bo[i-3][j]=bo[i-4][j]=bo[i-5][j]=bo[i-6][j]=1;break;}}//如果下一个和stt[x]一样,xx--,行向下一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[i][yy-1]==stt[x]) {yy--;x++;if(x==7) {bo[i][j]=bo[i][j-1]=bo[i][j-2]=bo[i][j-3]=bo[i][j-4]=bo[i][j-5]=bo[i][j-6]=1;break;}}//如果左一个和stt[x]一样,yy--,列向左一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[i][yy+1]==stt[x]) {yy++;x++;if(x==7) {bo[i][j]=bo[i][j+1]=bo[i][j+2]=bo[i][j+3]=bo[i][j+4]=bo[i][j+5]=bo[i][j+6]=1;break;}}//如果右一个和stt[x]一样,yy++,列向右一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[xx+1][yy+1]==stt[x]) {xx++;yy++;x++;if(x==7) {bo[i][j]=bo[i+1][j+1]=bo[i+2][j+2]=bo[i+3][j+3]=bo[i+4][j+4]=bo[i+5][j+5]=bo[i+6][j+6]=1;break;}}//如果右上方一个和stt[x]一样,yy++,xx++,列向右一步，行向上一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[xx-1][yy+1]==stt[x]) {xx--;yy++;x++;if(x==7) {bo[i][j]=bo[i-1][j+1]=bo[i-2][j+2]=bo[i-3][j+3]=bo[i-4][j+4]=bo[i-5][j+5]=bo[i-6][j+6]=1;break;}}//如果右下方一个和stt[x]一样,yy++,xx--,列向右一步，行向下一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[xx-1][yy-1]==stt[x]) {xx--;yy--;x++;if(x==7) {bo[i][j]=bo[i-1][j-1]=bo[i-2][j-2]=bo[i-3][j-3]=bo[i-4][j-4]=bo[i-5][j-5]=bo[i-6][j-6]=1;break;}} //如果左下方一个和stt[x]一样,yy--,xx--,列向左一步，行向下一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
				xx=i;yy=j;x=1;//xx是i的代入，yy是j的代入，x变为一，重新开始
				while(a[xx+1][yy-1]==stt[x]) {xx++;yy++;x++;if(x==7) {bo[i][j]=bo[i+1][j-1]=bo[i+2][j-2]=bo[i+3][j-3]=bo[i+4][j-4]=bo[i+5][j-5]=bo[i+6][j-6]=1;break;}}//如果左上方一个和stt[x]一样,yy--,xx++,列向左一步，行向上一步，x++,字符串位置加一，如果全部都对，bo数组全部为一，到时候0就标为*
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
	    {
	  	    if(bo[i][j]==1) cout<<a[i][j];//如果等于1，输出原来的
	  	      else cout<<'*';//否则，输出*
	    }
	    cout<<"\n";//换行
	}
	return 0;
 } 
```
# 怎么样？简单不？



---

## 作者：AuroraIris (赞：3)

只要枚举每一个即可











```cpp
var i,j,n:longint;
a:array[-10..100,-10..110] of char;
b:array[-10..100,-10..110] of boolean;
begin
readln(n);
for i:=1 to n do
begin
for j:=1 to n do
read(a[i,j]);
readln;
end;
fillchar(b,sizeof(b),false);
for i:=1 to n do//开始寻找‘yizhong’。（下同）
for j:=1 to n do
if a[i,j]='y' then
begin
if (a[i,j-1]='i')and(a[i,j-2]='z')and(a[i,j-3]='h')and(a[i,j-4]='o')and(a[i,j-5]='n')and(a[i,j-6]='g') then//如果当前是‘y'，那么去配对其他字母。
begin
b[i,j]:=true;b[i,j-1]:=true;b[i,j-2]:=true;b[i,j-3]:=true;b[i,j-4]:=true;b[i,j-5]:=true;b[i,j-6]:=true;//找到’yizhong‘。赋true（变为‘*’）。
end;
if (a[i,j+1]='i')and(a[i,j+2]='z')and(a[i,j+3]='h')and(a[i,j+4]='o')and(a[i,j+5]='n')and(a[i,j+6]='g') then
begin
b[i,j]:=true;b[i,j+1]:=true;b[i,j+2]:=true;b[i,j+3]:=true;b[i,j+4]:=true;b[i,j+5]:=true;b[i,j+6]:=true;
end;
if (a[i-1,j-1]='i')and(a[i-2,j-2]='z')and(a[i-3,j-3]='h')and(a[i-4,j-4]='o')and(a[i-5,j-5]='n')and(a[i-6,j-6]='g') then
begin
b[i,j]:=true;b[i-1,j-1]:=true;b[i-2,j-2]:=true;b[i-3,j-3]:=true;b[i-4,j-4]:=true;b[i-5,j-5]:=true;b[i-6,j-6]:=true;
end;
if (a[i-1,j+1]='i')and(a[i-2,j+2]='z')and(a[i-3,j+3]='h')and(a[i-4,j+4]='o')and(a[i-5,j+5]='n')and(a[i-6,j+6]='g') then
begin
b[i,j]:=true;b[i-1,j+1]:=true;b[i-2,j+2]:=true;b[i-3,j+3]:=true;b[i-4,j+4]:=true;b[i-5,j+5]:=true;b[i-6,j+6]:=true;
end;
if (a[i-1,j]='i')and(a[i-2,j]='z')and(a[i-3,j]='h')and(a[i-4,j]='o')and(a[i-5,j]='n')and(a[i-6,j]='g') then
begin
b[i,j]:=true;b[i-1,j]:=true;b[i-2,j]:=true;b[i-3,j]:=true;b[i-4,j]:=true;b[i-5,j]:=true;b[i-6,j]:=true;
end;
if (a[i+1,j-1]='i')and(a[i+2,j-2]='z')and(a[i+3,j-3]='h')and(a[i+4,j-4]='o')and(a[i+5,j-5]='n')and(a[i+6,j-6]='g') then
begin
b[i,j]:=true;b[i+1,j-1]:=true;b[i+2,j-2]:=true;b[i+3,j-3]:=true;b[i+4,j-4]:=true;b[i+5,j-5]:=true;b[i+6,j-6]:=true;
end;
if (a[i+1,j]='i')and(a[i+2,j]='z')and(a[i+3,j]='h')and(a[i+4,j]='o')and(a[i+5,j]='n')and(a[i+6,j]='g') then
begin
b[i,j]:=true;b[i+1,j]:=true;b[i+2,j]:=true;b[i+3,j]:=true;b[i+4,j]:=true;b[i+5,j]:=true;b[i+6,j]:=true;
end;
if (a[i+1,j+1]='i')and(a[i+2,j+2]='z')and(a[i+3,j+3]='h')and(a[i+4,j+4]='o')and(a[i+5,j+5]='n')and(a[i+6,j+6]='g') then
begin
b[i,j]:=true;b[i+1,j+1]:=true;b[i+2,j+2]:=true;b[i+3,j+3]:=true;b[i+4,j+4]:=true;b[i+5,j+5]:=true;b[i+6,j+6]:=true;
end;
end;//找完了
for i:=1 to n do
begin
for j:=1 to n do
if b[i,j] then write(a[i,j])
else write('*');
writeln;
end;
end.
```

---

## 作者：circlegg (赞：3)

###这道题基本就是个模拟，每个位置进行八个方向的判断，如果有就存入另一个提前初始化为‘\*’的数组，最后输出即可，虽然较长，但是写完一个方向复制粘贴七次加一点修改即可

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n;
char a[101][101],b[101][101],t[8]={' ','y','i','z','h','o','n','g'};
bool flag;
void dfs(int x,int y){
    if(x-6>=1&&y+6<=n){//右上 
        for(int i=1;i<=7;i++){
            if(a[x-i+1][y+i-1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x-i+1][y+i-1]=t[i];
            }
        }
        flag=0;
    }
    if(y+6<=n){//右 
        for(int i=1;i<=7;i++){
            if(a[x][y+i-1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x][y+i-1]=t[i];
            }
        }
        flag=0;
    }
    if(x+6<=n&&y+6<=n){//右下 
        for(int i=1;i<=7;i++){
            if(a[x+i-1][y+i-1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x+i-1][y+i-1]=t[i];
            }
        }
        flag=0;
    }

    if(x+6<=n){//下 
        for(int i=1;i<=7;i++){
            if(a[x+i-1][y]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x+i-1][y]=t[i];
            }
        }
        flag=0;
    }
    if(x+6<=n&&y-6>=1){//左下 
        for(int i=1;i<=7;i++){
            if(a[x+i-1][y-i+1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x+i-1][y-i+1]=t[i];
            }
        }
        flag=0;
    }
    if(y-6>=1){//左 
        for(int i=1;i<=7;i++){
            if(a[x][y-i+1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x][y-i+1]=t[i];
            }
        }
        flag=0;
    }
if(x-6>=1&&y-6>=1){//左上 
        for(int i=1;i<=7;i++){
            if(a[x-i+1][y-i+1]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x+i-1][y-i+1]=t[i];
            }
        }
        flag=0;
    }
    if(x-6>=1){//上 
        for(int i=1;i<=7;i++){
            if(a[x-i+1][y]!=t[i]){
                flag=1;
            }
        }
        if(flag==0){
            for(int i=1;i<=7;i++){
                b[x-i+1][y]=t[i];
            }
        }
        flag=0;
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            b[i][j]='*'; //初始化
        }
    for(int i=1;i<=n;i++){
        scanf("%s",a[i]+1);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            dfs(i,j);
        }
    }
    for(int i=1;i<=n;i++,puts(""))
        for(int j=1;j<=n;j++){
            printf("%c",b[i][j]);
        }
    return 0;
}
/*
8                    
qyizhong          
gydthkjy          
nwidghji          
orbzsfgz          
hhgrhwth          
zzzzzozo          
iwdfrgng            
yyyygggg    
*/        
```

---

## 作者：x_faraway_x (赞：3)

```cpp
#include <cstdio>
#include <cstring>
const int N = 105;
char s[N][N], a[] = "yizhong";
bool vis[N][N]; // vis数组记录每个字符是否是yizhong字符串的组成部分
int n;
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, //方向数组
    dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};
void dfs(int x, int y, int w, int i) { //x, y为坐标，w是搜索方向，i是搜索到yizhong的第几个字符
    if(i == 7) { //如果搜索yizhong结束
        int xx=x, yy=y;
        for(int j = 1; j <= 7; j++) {
            vis[xx][yy] = true; //标记为字符串的组成部分
            xx-=dx[w], yy-=dy[w]; //按搜索方向倒回标记
        }
        return;
    }
    if(w == -1) { //如果是第一次搜索（找到y，具体见下面代码）
        for(int j = 0; j < 8; j++) { //8个方向搜索
            int xx=x+dx[j], yy=y+dy[j]; 
            if(s[xx][yy] == a[i]) // 如果符合要求
                dfs(xx, yy, j, i+1); // 则按这个方向继续搜索
        }
        return;
    }
    int xx=x+dx[w], yy=y+dy[w]; // 按原方向搜索
    if(s[xx][yy] == a[i])
        dfs(xx, yy, w, i+1);
}
int main() {
    freopen("P1101.in", "r", stdin);
    memset(s, '*', sizeof(s)); //将字符数组初始化为'*'
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%s", s[i]+1); //从s[1][1]开始。因为上面已初始化，搜索时就不用判断越界
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(s[i][j] == 'y') dfs(i, j, -1, 1); //如果找到y，开始搜索
    for(int i = 1; i <= n; puts(""), i++) //将输出回车放在循环控制语句里，代码简洁
        for(int j = 1; j <= n; j++) {
            if(vis[i][j]) putchar(s[i][j]); //如果被标记输出原字符，否则输出*
            else putchar('*');
        }
    return 0;
}
```
/\*
总结：本题是dfs的一个较好的练习题，同时也要掌握好方法。

注释可能不是很清楚，请见谅!

\*/

---

## 作者：vivianru (赞：3)


第一次如此之认真地写标注

个人认为不是太长 思路比较简单吧， 

注意点： 

1.在标注踩过点时最好用++，不用=1，要不然有删错的可能性 

2.在dfs是再加一个深度h,和一个方向k，会简单一点吧 

3.不要忘了返回 

4.感谢@Illegal__swimmer的提醒，加一个判断，减小删错的可能性

5.只要找到一个头就开始搜，我一开始写反了，导致最后一个点半天没AC 应该就辣么多了，看代码吧！



  ```cpp
#include<bits/stdc++.h>
using namespace std;
string ans("yizhong");//目标单词 
string a[110];//地图记录 
int n,visit[110][110],f=0,k;// visit数组记录有无踩过,是否能构成单词; f判断 
int xy[8][2]={{1,1},{1,0},{1,-1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};//8个方向搜索 
void dfs(int x,int y,int k,int h) //k是方向, h是目标单词的对应的第h个字母 
{
    if(h==7)//7个字母都找到了 
    {
        f=1;//有答案 
		return ;//返回 
    }
    else//没找到或没找全 
	{
	    int xx=x+xy[k][0];//新的x
		int yy=y+xy[k][1];//新的y
		if(xx<0||xx>=n||yy<0||yy>=n)//判断:1.是否越界
	    if(a[xx][yy]==ans[h])//判断:2.是否满足目标单词中的下一个字母
	    {
	        visit[xx][yy]++;//踩过一遍,标记一下 
	        dfs(xx,yy,k,h+1);//同方向深搜 
	        if(f==0) //如果没有整个单词
			{
				visit[xx][yy]--;//则清除这一次搜索所标注的所有踩过的点 
			} 
	        return;//如果没有返回,还是要返回滴...否则有可能进入死循环 
	    }
	    else 
		{
			return;//如果不满足判断就尽快返回吧 
		}	
	} 
}
int main()
{
	cin>>n;//输入n
	for(int i=0;i<n;i++)//输入地图 
	{
		cin>>a[i]; 
	}
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			if(a[i][j]=='y')//找到了一个开头 
			{
				for(int k=0;k<=7;k++)//八个方位轮流搜索 
				{
					visit[i][j]++;//先把它自己踩上一遍 
					dfs(i,j,k,1);//深搜 
					if(f==0)//如果没找到 
					{
						visit[i][j]--;//干脆把头删了 
					}
					else//找到一个完整的词了 
					{
						f=0;//让判断再为否定 
						break;//赶紧退出,省得在搜下一个是把这个满足的头也删了 
					}
				}
			}
		}
	}
	for(int i=0;i<n;i++,printf("\n"))
    for(int j=0;j<n;j++)
    {
        if(visit[i][j]>=1) printf("%c",a[i][j]);//只要被踩过一次,就保留 
        else 
        printf("*");
    }
	return 0;//结束!!! 
} 
```


---

## 作者：Kando (赞：2)

###### 两百四十行的纯暴力搜索


其实我也不想把这种题解贴出来

### 但是谁让我跟这题刚上了呢
本来做道纯暴力

我做了,我过了,有什么好说的

但是这代码前前后后让我给改了接近两个小时

这里也有个问题想问一下

关于string类型的

我的定义：
string xl[107];

而在使用的时候：
```cpp
for ( int i = 0 ; i < n ; i++ ){
	for( int j = 0 ; j < n ; j++ ){
		xl[i][j].......
		........ 
	}
} 
```

一旦调试就会报错：
Program received signal SIGSEGV, Segmentation fault.

在网上也没有查到有帮助的信息

求大佬解释一下！！！

代码简单，各个方向进行判断

但一定要单独判断！！！

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

int n;
char xl[107][107];
char bl[107][107],ans[107][107];
bool flag;
char ch[] = { 'y','i' ,'z' ,'h' ,'o' ,'n' ,'g' };

inline void dfs3 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		if ( r-1<=n && c-1<=n && xl[r-1][c-1] == ch[ysc+1] && bl[r-1][c-1] == '*' ){
			bl[r-1][c-1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs3(ysc+1,r-1,c-1);
			bl[r+1][c+1] = bl[r-1][c-1] = bl[r][c] = '*';
		}
	}
}

inline void dfs4 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		if ( r+1<=n && c-1>=0 && xl[r+1][c-1] == ch[ysc+1] && bl[r+1][c-1] == '*' ){
			bl[r+1][c-1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs4(ysc+1,r+1,c-1);
			bl[r-1][c+1] = bl[r+1][c-1] = bl[r][c] = '*';
		}
	}
}

inline void dfs5 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		if ( r-1<=n && c+1<=n && xl[r-1][c+1] == ch[ysc+1] && bl[r-1][c+1] == '*' ){
			bl[r-1][c+1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs5(ysc+1,r-1,c+1);
			bl[r+1][c-1] = bl[r-1][c+1] = bl[r][c] = '*';
		}
	}
}

inline void dfs6 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		if ( r+1<=n && c+1<=n && xl[r+1][c+1] == ch[ysc+1] && bl[r+1][c+1] == '*' ){
			bl[r+1][c+1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs6(ysc+1,r+1,c+1);
			bl[r-1][c-1] = bl[r+1][c+1] = bl[r][c] = '*';
		}
	}
}

inline void dfs2 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		if ( c+1<=n && xl[r][c+1] == ch[ysc+1] && bl[r][c+1] == '*' ){
			bl[r][c+1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs2(ysc+1,r,c+1);
			bl[r][c-1] = bl[r][c+1] = bl[r][c] = '*';
		}
		else if ( c-1>=0 && xl[r][c-1] == ch[ysc+1] && bl[r][c-1] == '*' ){
			bl[r][c-1] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs2(ysc+1,r,c-1);
			bl[r][c+1] = bl[r][c-1] = bl[r][c] = '*';
		}
		
	}
}

inline void dfs1 ( int ysc , int r , int c ){
	flag = false;
	if ( ysc == 6 ){
		int k = 0;
		for ( register int i = 0 ; i < n ; i++ ){
			if ( k == 7 ) {
				flag = true;
				break;
			}
			for ( register int j = 0 ; j < n ; j++ ){
				if ( bl[i][j] != '*' ){
					k++;
					ans[i][j] = bl[i][j];
				}
			}
		}
		return;
	}
	else {
		
		if ( r+1<=n && xl[r+1][c] == ch[ysc+1] && bl[r+1][c] == '*' ){
			bl[r+1][c] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs1(ysc+1,r+1,c);
			bl[r-1][c] = bl[r+1][c] = bl[r][c] = '*';
		}
		else if ( r-1>=0 && xl[r-1][c] == ch[ysc+1] && bl[r-1][c] == '*' ){
			bl[r-1][c] = ch[ysc+1];
			bl[r][c] = ch[ysc];
			dfs1(ysc+1,r-1,c);
			bl[r+1][c] = bl[r-1][c] = bl[r][c] = '*';
		}
		
	}
}

int main() {
	
	cin >> n;
	
	for ( register int i = 0 ; i < n ; i++ ){
		cin >> xl[i];
	}
	
	for ( register int i = 0 ; i < 107 ; i++ ){
		for ( register int j = 0 ; j < 107 ; j++ ){
			bl[i][j] = '*';
			ans[i][j] = '*';
		}
	}
	
	for ( register int i = 0 ; i < n ; i++ ){
		for ( register int j = 0 ; j < n ; j++ ){
			if ( xl[i][j] == 'y' ){
				dfs1(0,i,j);//横
				if ( flag == true ) continue;
				dfs2(0,i,j);//纵
				if ( flag == true ) continue;
				dfs3(0,i,j);//左上
				if ( flag == true ) continue;
				dfs4(0,i,j);//左下
				if ( flag == true ) continue;
				dfs5(0,i,j);//右上 
				if ( flag == true ) continue;
				dfs6(0,i,j);//右下 
			}
		}
	}
	
	for ( register int i = 0 ; i < n ; i++ ){
		for ( register int j = 0 ; j < n ; j++ ){
			cout << ans[i][j];
		}
		cout << endl;
	}
	
	return 0;
}
/*
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg
*/
```

第一篇题解

纪念这个最水的橙名


---

## 作者：香风智乃 (赞：2)

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string k("IiZzHhOoNnGg###");    //大小写比较（后面3个#貌似没什么用）
string a[102];     
int c[8]={0,1,1,-1,0,-1,-1,1};    //8个方向对应的横纵坐标增减
int d[8]={1,0,1,-1,-1,0,1,-1};
int b[102][102]={0};
int e[102][102]={0};    //这是俩标志数组，碰到完整的“yizhong”就标记（其中b存到e去）
int n,u;
int search(int p,int t1,int t2)
{
    int i,j;
    if(p>=12)
    {
        for(i=1;i<=n;i++)
            for(j=1;j<=n;j++)
                if(b[i][j]==1)
                    e[i][j]=b[i][j];
    }          //储存
    else
        if((a[t1+c[u]][t2+d[u]]==k[p])||(a[t1+c[u]][t2+d[u]]==k[p+1]))
        {
            b[t1][t2]=1;
            b[t1+c[u]][t2+d[u]]=1;    //保存
            search(p+2,t1+c[u],t2+d[u]);
            b[t1][t2]=0;
            b[t1+c[u]][t2+d[u]]=0;    //恢复
        }
}
int main()
{
    int i,j;
    string s2("*");
    cin>>n;
    for(i=1;i<=n;i++)
    {    
        cin>>a[i];
        a[i].insert(0,s2);    //在外面加一个外壳(这方法有些奇怪，不过确实起作用了)
    }
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(a[i][j]=='y'||a[i][j]=='Y')    //寻找‘Y’或‘y’
                for(u=0;u<8;u++)
                    {            
                        search(0,i,j);    //从这个点开始寻找
                    }
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(e[i][j]==0)
                a[i][j]='*';    // 不是“yizhong”就用‘*’代替
    for(i=1;i<=n;i++)
    {
        a[i].erase(0,1);    //摘下前面加上的外壳（第一次没注意到要去外壳拿了个0分）
        cout<<a[i]<<endl;    //收工
    }
}
```

---

## 作者：Lian233 (赞：2)

1.搜"yizhong"的首字母‘y’

2.搜到'y'，枚举8个方向与"yizhong"分别进行比对

3.匹配成功，则打上标记，以便输出









```cpp
#include<cstdio>
const int MAXN=100+5;
int d[8][2]={{1,1},{1,-1},{-1,1},{-1,-1},{1,0},{0,1},{-1,0},{0,-1}};
char cmp[7]={'y','i','z','h','o','n','g'} ;  //先打好"yizhong"以及八个方向的表以便使用
int n;
bool mark[MAXN][MAXN]={0};
char map[MAXN][MAXN];
void init(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%s",map[i]+1);
}
void print(){
      for(int i=1;i<=n;i++)
          for(int j=1;j<=n;j++){
              if(mark[i][j])
                putchar(map[i][j]);
              else putchar('*');
              if(j==n) putchar('\n');
      }
}
inline void check(int x,int y){
    int i,j,k; 
    for(k=0;k<8;k++){ //枚举8个方向
        for(i=1;i<=6;i++){
            int nowx=x+i*d[k][0],nowy=y+i*d[k][1]; //计算出用于匹配的nowx和nowy
            if(nowx<1||nowx>n||nowy<1||nowy>n) break; //越界，则退出
            if(map[nowx][nowy]!=cmp[i]) break; //匹配失败，则退出
        }
        if(i==7)   //i=7说明没有退出，匹配成功
         for(j=0;j<=6;j++) mark[x+d[k][0]*j][y+d[k][1]*j]=1; //打上标记，注意y也要打上
    } 
}
void solve(){
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      if(map[i][j]=='y'){  //找'y'以开始匹配
          check(i,j);
      }
}
int main(){
    init();
    solve();
        print();
        return 0;
}
```
测试样例:
8
qyizhong

gydthkjy

nwidghji

orbzsfgz

hhgrhwth

zzzzzozo

iwdfrgng

yyyygggg


---

## 作者：七十七 (赞：2)

简单搜索 每找到一个y就向8个方向搜， 找到i， 确定是怎么变化， 继续走下去， 能找到g即可过








```cpp
#include <iostream>
using namespace std;
char a[101][101], b[8] = {'0', 'y', 'i', 'z', 'h', 'o', 'n', 'g'};//a数组读入数据
int len = 1, bb[101][101];//bb数组记录每个方位有没有单词， 用来输出
void change(int i, int j, int ii, int jj)
{
    int k;
    for(k = 1; k <= 7; ++k)//路径上的数都置为1
    {
        bb[i][j] = 1;
        i = i + ii;
        j = j + jj;
    }
    len = 2;//回search
}
void go(int i, int j, int ii, int jj)
{
    int k, m = 0;
    for(k = 1;;++k)//死循环
    {
        len++;
        if(a[i + ii][j + jj] != b[len])//不是要找的数据， 组不成单词
        {
            m = 1;//标记一下， break
            break;
        }
        else
        {
            i = i + ii;//是数据， 就继续走
            j = j + jj;
        }
        if(len == 7) break;//走到终点
    }
    if(m == 0) change(i, j, -ii, -jj);//搜到了g， 去记录
    len = 2;//不行把len重置为2， 重回search
}
void search(int i, int j)//8个方向
{
    len = 2;
    if(a[i - 1][j - 1] == b[len]) go(i - 1, j - 1,-1, -1);//位置和变化规律传到go
    if(a[i - 1][j] == b[len]) go(i - 1, j, -1, 0);
    if(a[i - 1][j + 1] == b[len]) go(i - 1, j + 1, -1, 1);
    if(a[i][j - 1] == b[len]) go(i, j - 1, 0, -1);
    if(a[i][j + 1] == b[len]) go(i, j + 1, 0, 1);
    if(a[i + 1][j + 1] == b[len]) go(i + 1, j + 1, 1, 1);
    if(a[i + 1][j] == b[len]) go(i + 1, j, 1, 0);
    if(a[i + 1][j - 1] == b[len]) go(i + 1, j - 1, 1, -1); 
}
int main()
{
    int n, i, j;
    cin >> n;
    for(i = 1; i <= n; ++i)
     for(j = 1; j <= n; ++j) cin >> a[i][j];//输入
    for(i = 1; i <= n; ++i)
     for(j = 1; j <= n; ++j) if(a[i][j] == b[1]) search(i, j);//从y开始
    for(i = 1; i <= n; ++i)
    {
        for(j = 1; j <= n; ++j) 
        {
             if(bb[i][j] != 1) a[i][j] = '*';//路径上不是1的都变*
             cout << a[i][j];//是1的原样输出
         }
         cout << endl;//控制输出格式
    }
    return 0; 
}
```

---

## 作者：CoolTeam (赞：2)

**深搜，C代码**

```cpp
#include<stdio.h>
#include<string.h>
char o[10]=" yizhong",A[110][110],ans[110][110];
int i,j,find;
//step:在查找的字母数，x,y：当前坐标(相当于j,i),dx,dy方向。 
void dfs(int step,int x,int y,int dx,int dy) 
{
    if(find) return; //每个起始点'y'最多找1个单词 
    if(step==8) find=1; 
    else
    {
        if(o[step]==A[y+dy][x+dx] && ans[y+dy][x+dx]=='*')
        {
            ans[y+dy][x+dx]=A[y+dy][x+dx];//找到则添加到ans中 
            dfs(step+1,x+dx,y+dy,dx,dy);
            if(!find)  ans[y+dy][x+dx]='*';//没找到则还原为'*'
        }
    }
}
int main(void)
{
    int n;
    memset(A,'*',110*110);
    memset(ans,'*',110*110);
    scanf("%d\n",&n);
    for(i=1;i<=n;i++){gets(&A[i][1]);A[i][n+1]='*';}    
    for(i=1;i<=n;i++) 
        for(j=1;j<=n;j++)//(j,i)为坐标
        {
            //i代表纵坐标，j代表横坐标 
            if(A[i][j]!='y' || ans[i][j]!='*')continue; 
            find=0;//每个起始点'y'最多找1个单词 
            //往8个方向搜索，剪枝(其实完全没必要剪) 
            if(i>=7)            dfs(2,j,i,0,-1);//上
            if(i<=n-6)            dfs(2,j,i,0,1);//下 
            if(j>=7)            dfs(2,j,i,-1,0);//左
            if(j<=n-6)            dfs(2,j,i,1,0);//右
            if(j<=n-6 && i>=7)    dfs(2,j,i,1,-1);//右上
            if(j>=7 && i>=7)    dfs(2,j,i,-1,-1);//左上
            if(j>=7 && i<=n-6)    dfs(2,j,i,-1,1);//左下
            if(j<=n-6 && i<=n-6)dfs(2,j,i,1,1);//右下 
            if(find) ans[i][j]='y';
        }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            putchar(ans[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：kczno1 (赞：2)

这道题常量数组可以存储方向和需要的单词

```cpp

const
need:array[1..7]of char='yizhong';
x:array[1..8]of -1..1=(-1,-1,-1,0,0,1,1,1);
y:array[1..8]of -1..1=(-1,0,1,-1,1,-1,0,1);

var
 n,i,j:longint;
 a:array[1..100,1..100]of char;
 b:array[1..100,1..100]of boolean; //是否显示

function can(x:longint):boolean; //是否在方阵范围内
begin
 if (x>0)and(x<=n) then exit(true);
 exit(false);
end;

procedure try(kx,ky:longint);
var
 i,j:longint;
 ok:boolean;
begin
 for i:=1 to 8 do //八个方向
 if can(kx+x[i]*6) and can(ky+y[i]*6) then
 begin
  ok:=true;
  for j:=0 to 6 do //逐个比较
  if a[kx+x[i]*j,ky+y[i]*j]<>need[j+1] then
  begin
   ok:=false;
   break;
  end;
  if ok then
  for j:=0 to 6 do
   b[kx+x[i]*j,ky+y[i]*j]:=true;
 end;
end;

begin
 readln(n);
 for i:=1 to n do
 begin
  for j:=1 to n do
   read(a[i,j]);
  readln;
 end;
 for i:=1 to n do
  for j:=1 to n do
  if not b[i,j] then
    try(i,j);
 for i:=1 to n do
 begin
  for j:=1 to n do
   if b[i,j] then write(a[i,j])
   else write('*');
  writeln;
 end;
end.

```

---

## 作者：tindon (赞：1)

这道题让我加深了对dfs的理解

### 让我们一起看一看dfs的思想

从某个状态开始， 不断地**转移状态**到无法转移， 然后回退到前一步的状态， 继续转移， 不断重复至**找到解或走不下去**

所以对于穷竭搜索来说， 有转移条件的题， 都能用 dfs

接下来看这道题

------------
### 题目描述
从一个 n * n 的字母方阵， 选出若干组成单词"yizhong"的格子 ， 并把其它格子都变成 '*'

### 转移条件
为单词"yizhong"的一部分

### 终止条件
组成一个完整的"yizhong"


------------
### 思路
遍历整个方阵， 找到为'y'的格子， 然后对其八个方向搜索。 如果该格子能够组成一个完整的"yizhong", 则把组成"yizhong"的格子都变为 true。 最终把所有不为 true 的格子都变成"*".


------------
### 代码如下
```
#include<bits/stdc++.h>
using namespace std;
  
int n, d;
char w[105][105];
bool is[105][105];
int dir[8][2] = { {-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
bool sign;

void dfs(int i, int j, int k)
{
	if(k > 6)
	{
		sign = true;
		is[i][j] = true;
		return;
	}

	char goal;
	switch(k)
	{
		case 1:
		{
			goal = 'i';
			break;
		}
		case 2:
		{
			goal = 'z';
			break;
		}
		case 3:
		{
			goal = 'h';
			break;
		}
		case 4:
		{
			goal = 'o';
			break;
		}
		case 5:
		{
			goal = 'n';
			break;
		}
		case 6:
		{
			goal = 'g';
			break;
		}
	}

	int tx = i + dir[d][0];
	int ty = j + dir[d][1];
	if(tx >= 1 && tx <= n && ty >= 1 && ty <= n && w[tx][ty] == goal)
	{
		dfs(tx, ty, k+1);
	}
	
	if(sign == true)
		is[i][j] = true;
	
	
}

int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
		{
			cin >> w[i][j];
		}
	memset(is, false, sizeof(is));
	
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			for(d = 0; d < 8; d++)
			{
				sign = false;
				if(w[i][j] == 'y')
				{
					dfs(i, j, 1);
					if(sign == true)
					is[i][j] = true;
				}		
			}
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			if(is[i][j] == false)
				w[i][j] = '*';
			cout << w[i][j];
		}
		cout << endl;
	}
}
```




---

## 作者：Rika (赞：1)

来个简短的，不足30行。
```python
directions = [[(0, i) for i in range(7)],
              [(0, -i) for i in range(7)],
              [(i, i) for i in range(7)],
              [(i, -i) for i in range(7)],
              [(i, 0) for i in range(7)],
              [(-i, 0) for i in range(7)],
              [(-i, i) for i in range(7)],
              [(-i, -i) for i in range(7)]]  # 八个搜索方向的数组
n = int(input())
ipt = [input() for i in range(n)]
tg = 'yizhong'
rs = set()  # 用于保存结果的集合
for i in range(n):
    for j in range(n):  # 对于每一个点开始搜索
        for k in directions:  # 搜索每一个方向
            flag = True  # 立下是否搜到的flag
            for pt, l in enumerate(k):
                if (not (0 <= i + l[0] < n and 0 <= j + l[1] < n)) or ipt[i + l[0]][j + l[1]] != tg[pt]:
                    # 如果有不满足的或者数组越界的就break并置flag
                    flag = False
                    break
            if flag:  # 如果搜到了就在结果集合中并上本次搜到的结果
                rs |= set([(i + l[0], j + l[1]) for l in k])
for i in range(n):
    for j in range(n):
        if (i, j) in rs:
            print(ipt[i][j], end='')  # 输出结果
        else:
            print('*', end='')
    print()
```

---

## 作者：VPYEKINDAR (赞：1)

各位大佬的程序 大都已经完美的从各个角度解决了这个问题
我要说的是针对像我这样的蒟蒻的~~折磨我们的~~的一个问题
****
没错! 就是这一题的输入！！！


------------
对于此题的二维字符数组 如果我们直接用输入一个整型矩阵的思路 就像这样

------------
int i,j;   
for(i=0;i<n;i++)

for(j=0;j<n;j++)

scanf("%c",&a[i][j]);

结果输入完全失败 有可能在一场竞赛中你就因为这个原因调了~~一万年~~
最终心态完全爆炸 回去直接AFO~~哈哈哈~~

有人可能问 都是矩阵为什么字符型跟整型的输入不一样呢？
是因为每一个字符串都加了一个\0的关系啦
所以如果要输入这种字符矩阵可以采取这种方案
 
 






------------
for(i=0;i<n;i++)

scanf("%s",a[i]);

可以这样理解 把\0的输入交给%s处理

这一点过了之后 这一题应该就没有什么坑点了 再也不用翻题解了呢！

---

## 作者：teafrogsf (赞：1)

做到一半发现不是搜索是枚举......

于是我就用枚举做了23333

基本想法是**先循环找y然后八个边找i，按这条直线枚举，若确实是yizhong就标记**；

输出的时候按标记输出就可以了。

顺便说一句，**不能用getchar吞换行**，用个字符串吧XD

上代码

```cpp
#include<stdio.h>
char a[110][110];
int dx[10]={0,-1,1,0,0,-1,-1,1,1},dy[10]={0,0,0,-1,1,-1,1,-1,1},flag[110][110],n;
bool book[110][110];
char yz[10]={0,'i','z','h','o','n','g'};
void dfs(int x,int y)
{
    int i,j;
    int xx=x,yy=y;
    for(i=1;i<=8;)
    {
        xx=x+dx[i];yy=y+dy[i];
        //printf("%d %d %c\n",xx,yy,a[xx][yy]);
        if(a[xx][yy]=='i'&&xx>=1&&xx<=n&&yy>=1&&yy<=n)
        {
            if(x+6*dx[i]<1||x+6*dx[i]>n||y+6*dy[i]<1||y+6*dy[i]>n)goto next;
            for(j=2;j<=6;j++)
            {
                //printf("%d %d %c\n",x+j*dx[i],y+j*dy[i],a[x+j*dx[i]][y+j*dy[i]]);
                if(a[x+j*dx[i]][y+j*dy[i]]!=yz[j])goto next;
            }
            for(j=0;j<=6;j++)flag[x+j*dx[i]][y+j*dy[i]]=1;
        }
        next:
        i++;
    }
}
int main()
{
    int i,j;
    char instead[110];
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        gets(instead);
        for(j=1;j<=n;j++)scanf("%c",&a[i][j]);
    } 
    for(i=1;i<=n;i++)
     for(j=1;j<=n;j++)
      if(a[i][j]=='y')dfs(i,j);
    for(i=1;i<=n;i++)
    {
     for(j=1;j<=n;j++)
     {
         if(flag[i][j])printf("%c",a[i][j]);
         else printf("*");
     }
     puts("");
    }
    return 0;
}
```

---

## 作者：magolor (赞：1)

目前题解太复杂了，字符串存下来，预处理移动数组，GO函数单方向判断







```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
char yz[9] = "yizhong", g[105][105];
bool book[105][105];
int n;
int mx[8] = {-1, 0, 1, 0,-1,-1, 1, 1};
int my[8] = { 0, 1, 0,-1,-1, 1, 1,-1};
bool GO(int x, int y, int k)
{
    int tx = mx[k], ty = my[k];
    if(x+6*tx < 1 || x+6*tx > n || y+6*ty < 1 || y+6*ty > n)
        return false;
    for(int i = 0; i < 7; i++)
        if(g[x+i*tx][y+i*ty]-yz[i])
            return false;
    for(int i = 0; i < 7; i++)
        book[x+i*tx][y+i*ty] = true;
    return true;
}
void Find(int x, int y)
{
    int dir = -1;
    for(int i = 0; i < 8; i++)
        if(g[x+mx[i]][y+my[i]] == 'i')
            GO(x,y,i);
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++)
        scanf("%s",g[i]+1);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(g[i][j] == 'y')
                Find(i,j);
    for(int i = 1; i <= n; i++, cout << endl)
        for(int j = 1; j <= n; j++)
            cout << (book[i][j] ? g[i][j] : '*');
    return 0;
}
```

---

## 作者：PhantasmDragon (赞：1)

无脑深搜，每次搜索找到“yizhong”时返回第一个元素进行标记。有点耗时，但还是AC了:-).

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
char grid[101][101];
bool used[101][101];//标记数组 
int N;
bool dfs(char a,int dir1,int dir2,int pos1,int pos2)//无脑深搜 
{
    //检查是否是连续的“yizhong” 
    if(a=='i')
    {
        if(grid[pos1+dir1][pos2+dir2]!='z')
        {
            return false;
        }
    }
    else if(a=='z')
    {
        if(grid[pos1+dir1][pos2+dir2]!='h')
        {
            return false;
        }
    }
    else if(a=='h')
    {
        if(grid[pos1+dir1][pos2+dir2]!='o')
        {
            return false;
        }
    }
    else if(a=='o')
    {
        if(grid[pos1+dir1][pos2+dir2]!='n')
        {
            return false;
        }
    }
    else if(a=='n')
    {
        if(grid[pos1+dir1][pos2+dir2]!='g')
        {
            return false;
        }
    }
    else if(a=='g')
    {
        return true;
    }
    dfs(grid[pos1+dir1][pos2+dir2],dir1,dir2,pos1+dir1,pos2+dir2);
}
void read()//输入数据 
{
    scanf("%d",&N);
    for(int i=0;i<N;i++)
    {
        scanf("%s",grid[i]);
    }
    for(int i=0;i<N;i++)
    {
        for(int j=0;i<N;i++)
        {
            used[i][j]=false;
        }
    }
}
void solve()
{
    read();
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<N;j++)
        {
            //找到一个'y' 
            if(grid[i][j]=='y')
            {
                for(int x=-1;x<=1;x++)
                {
                    for(int y=-1;y<=1;y++)
                    {
                        //找到'i',确定“yizhong”的方向 
                        if(grid[i+x][j+y]=='i')
                        {
                            if(dfs('i',x,y,i+x,j+y)==true)
                            {
                                //返回做标记 ，兼容重合与不重合的情况。 
                                for(int temp=0;temp<=6;temp++)
                                {
                                    if(x==0&&y<0)
                                    {
                                        used[i][j-temp]=true;
                                    }
                                    else if(x==0&&y>0)
                                    {
                                        used[i][j+temp]=true;
                                    }
                                    else if(x<0&&y<0)
                                    {
                                        used[i-temp][j-temp]=true;
                                    }
                                    else if(x<0&&y==0)
                                    {
                                        used[i-temp][j]=true;
                                    }
                                    else if(x<0&&y>0)
                                    {
                                        used[i-temp][j+temp]=true;
                                    }
                                    else if(x>0&&y<0)
                                    {
                                        used[i+temp][j-temp]=true;
                                    }
                                    else if(x>0&&y==0)
                                    {
                                        used[i+temp][j]=true;
                                    }
                                    else if(x>0&&y>0)
                                    {
                                        used[i+temp][j+temp]=true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    //打印，标为“true”的地方打印原字符，“false”的地方打’*‘ 
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<N;j++)
        {
            if(used[i][j]==true)
            {
                printf("%c",grid[i][j]);
            }
            else
            {
                printf("*");
            }
        }
        printf("\n");
    }
}
int main()
{
    solve();
}
```

---

## 作者：Stolf (赞：1)

在dfs函数里，除了坐标再加上step参数和d参数，

其中，step表示已经确认到第几个字符，

d表示当前搜索的方向，因为单词在方阵中是沿着同一方向连续摆放的。

tx， ty用来表示已经确认的能够组成单词的字符的坐标，

如果在搜索时中断，即下一个该方向的字符不属于单词，就重新置为初始值-1，

然后当step为7时，即一个单词搜索完成，就把tx，ty存入mark，

输出时判断mark即可。

```cpp

#include <iostream>  
#include <cstring>  
using namespace std;  
int n, tx[200], ty[200], cnt = 0;  
int dir[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};  
bool vst[200][200], mark[200][200];  
char G[200][200];  
char* word = "yizhong";  
bool check(int x, int y)  
{  
    if (x >= 0 && x < n && y >= 0 && y < n && !vst[x][y])  
        return true;  
    return false;  
}  
void dfs(int x, int y, int step, int d)  
{  
    if (step == 7)  
    {  
        for (int i = 0; i < cnt; i++)  
            mark[tx[i]][ty[i]] = true;  
        return;  
    }  
    if (!check(x, y))  
        return;  
    if (step == 0)  
    {  
        if (G[x][y] == word[step])  
            for (int i = 0; i < 8; i++)  
            {  
                vst[x][y] = true, tx[cnt] = x, ty[cnt++] = y;   
                dfs(x + dir[i][0], y + dir[i][1], step + 1, i);  
                vst[x][y] = false;  
            }  
    }  
    else if (G[x][y] == word[step])  
    {  
        vst[x][y] = true, tx[cnt] = x, ty[cnt++] = y;  
        dfs(x + dir[d][0], y + dir[d][1], step + 1, d);  
        vst[x][y] = false;  
    }  
    else   
    {  
        cnt = 0;  
        memset(tx, -1, sizeof(tx));  
        memset(ty, -1, sizeof(ty));  
        return;  
    }  
}  
int main(int argc, char *argv[])  
{  
    cin >> n;  
    for (int i = 0; i < n; i++)  
        for (int j = 0; j < n; j++)  
            cin >> G[i][j];  
    memset(tx, -1, sizeof(tx));  
    memset(ty, -1, sizeof(ty));  
    for (int i = 0; i < n; i++)  
        for (int j = 0; j < n; j++)  
            dfs(i, j, 0, 0);  
    for (int i = 0; i < n; i++)  
    {  
        for (int j = 0; j < n; j++)  
            if (mark[i][j])  
                cout << G[i][j];  
            else   
                cout << '*';  
        cout << endl;  
    }     
    return 0;  
}  

```

---

## 作者：spacetime (赞：1)

**
//注意！这题不要判重！不要判重！！不要判重！！！如果你进行了判重，你的程序将被判错，你的信心会被打击，你的大脑会被搞混。如果你不判重，你就能一次AC。不要判重！不要判重！！不要判重！！！

**
```cpp

#include<cstdio>
#include<cstring>
#define REP(I,start,end) for(int I=start;I<=end;I++)
using namespace std;
const int dx[8]={1,0,1,-1,0,-1,1,-1};
const int dy[8]={0,1,1,0,-1,-1,-1,1};
const char ch[7]={'y','i','z','h','o','n','g'};
int n;
bool used[101][101];
char map[101][101];
int main()
{
    scanf("%d",&n);
    REP(i,1,n)
    {
        getchar();
        REP(j,1,n)
            map[i][j]=getchar();
    }
    REP(i,1,n)
        REP(j,1,n)
            if(!used[i][j]&&map[i][j]==ch[0])
                REP(k,0,7)
                {
                    int xx=i,yy=j;
                    bool cannot=false;
                    REP(l,1,6)
                    {
                        xx+=dx[k];
                        yy+=dy[k];
                        cannot|=xx<1||yy<1||xx>n||yy>n||
/*[color=red]如果你加上了这条，肯定过不去了233：[/color]used[xx][yy]||*/
map[xx][yy]!=ch[l];
                        if(cannot)
                            break;
                    }
                    if(!cannot)
                        REP(l,0,6)
                            used[i+l*dx[k]][j+l*dy[k]]=true;
                }
    REP(i,1,n)
    {
        REP(j,1,n)
            putchar(used[i][j]?map[i][j]:'*');
        putchar('\n');
    }
    return 0;
}

```

---

## 作者：CancerGary (赞：1)

简单的深度搜索题。

从没被搜索过的点开始判断往八个方向的字符串是否符合条件，符合的话在字符串上标记已搜索记号，之后没被搜索的记号输出\*即可。

【好吧语死早】

代码中使用的常量表示方向，简单粗暴。

```cpp

#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
string map[120];
string yz="yizhong",temp;
bool flag[120][120];
const int pos[9][2]={{-1,0},{-1,-1},{-1,1},{0,1},{0,-1},{1,0},{1,-1},{1,1}};
int main(){
    int i,j,k,l,n;
    cin >>n;
    memset(flag,false,sizeof(flag));
    for (i=1;i<=n;i++){cin>>temp;map[i]=" "+temp;}
    for (i=1;i<=n;i++) for (j=1;j<=n;j++)if (!flag[i][j]) for (k=0;k<9;k++)\
    if (i+pos[k][0]*6>=1&&i+pos[k][0]*6<=n&&j+pos[k][1]*6>=1&&j+pos[k][1]*6<=n){
        bool yoo=true;
        for (l=0;l<=6;l++) if (flag[i+pos[k][0]*l][j+pos[k][1]*l]==true||yz[l]!=map[i+pos[k][0]*l][j+pos[k][1]*l]) yoo=false;
        //cout <<yoo;
        if (yoo) for (l=0;l<=6;l++) flag[i+pos[k][0]*l][j+pos[k][1]*l]=true;
    }
    for (i=1;i<=n;i++) {for (j=1;j<=n;j++) if (flag[i][j]) cout <<map[i][j];
    else cout <<'*';
    cout<<endl;}
}

```

---

## 作者：prefer (赞：1)

## 一个纯模拟，没有用到递归

思路：首先用一个Map数组来把所有的不是yizhong其中一个字母的所有读入的a数组里的字符标记为'*'，接下来一个双层嵌套循环用来枚举每一个点看以这个点为开头的八个方向是否能构成yizhong，如果能构成，则把以这个点为开头记录到初始值全为' * '的ans数组中，然后输出ans就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[105][105],ans[105][105];
map<char,bool>mp;
void check(int x,int y) {//check每一个点
	if(a[x][y]=='*') //如果是*号就不用check了
		return;
	if(a[x][y]=='y'&&a[x+1][y]=='i'&&a[x+2][y]=='z'&&a[x+3][y]=='h'&&a[x+4][y]=='o'&&a[x+5][y]=='n'&&a[x+6][y]=='g') //down
		for(int i=x; i<=x+6; i++)
			ans[i][y]=a[i][y];
	if(a[x][y]=='y'&&a[x][y+1]=='i'&&a[x][y+2]=='z'&&a[x][y+3]=='h'&&a[x][y+4]=='o'&&a[x][y+5]=='n'&&a[x][y+6]=='g') //right
		for(int i=y; i<=y+6; i++)
			ans[x][i]=a[x][i];
	if(a[x][y]=='y'&&a[x-1][y]=='i'&&a[x-2][y]=='z'&&a[x-3][y]=='h'&&a[x-4][y]=='o'&&a[x-5][y]=='n'&&a[x-6][y]=='g') //up
		for(int i=x; i>=x-6; i--)
			ans[i][y]=a[i][y];
	if(a[x][y]=='y'&&a[x][y-1]=='i'&&a[x][y-2]=='z'&&a[x][y-3]=='h'&&a[x][y-4]=='o'&&a[x][y-5]=='n'&&a[x][y-6]=='g') //left
		for(int i=y; i>=y-6; i--)
			ans[x][i]=a[x][i];

	if(a[x][y]=='y'&&a[x+1][y+1]=='i'&&a[x+2][y+2]=='z'&&a[x+3][y+3]=='h'&&a[x+4][y+4]=='o'&&a[x+5][y+5]=='n'&&a[x+6][y+6]=='g')
		for(int i=x,j=y; i<=x+6; i++,j++)
			ans[i][j]=a[i][j];
	if(a[x][y]=='y'&&a[x+1][y-1]=='i'&&a[x+2][y-2]=='z'&&a[x+3][y-3]=='h'&&a[x+4][y-4]=='o'&&a[x+5][y-5]=='n'&&a[x+6][y-6]=='g')
		for(int i=x,j=y; i<=x+6; i++,j--)
			ans[i][j]=a[i][j];
	if(a[x][y]=='y'&&a[x-1][y+1]=='i'&&a[x-2][y+2]=='z'&&a[x-3][y+3]=='h'&&a[x-4][y+4]=='o'&&a[x-5][y+5]=='n'&&a[x-6][y+6]=='g')
		for(int i=x,j=y; i>=x-6; i--,j++)
			ans[i][j]=a[i][j];
	if(a[x][y]=='y'&&a[x-1][y-1]=='i'&&a[x-2][y-2]=='z'&&a[x-3][y-3]=='h'&&a[x-4][y-4]=='o'&&a[x-5][y-5]=='n'&&a[x-6][y-6]=='g')
		for(int i=x,j=y; i>=x-6; i--,j--)
			ans[i][j]=a[i][j];
	return;
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			cin>>a[i][j],ans[i][j]='*';
	mp['y']=mp['i']=mp['z']=mp['h']=mp['o']=mp['n']=mp['g']=1;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			if(!mp[a[i][j]]) //如果不是yizhong的任意一个字母
				a[i][j]='*';
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			check(i,j);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++)
			cout<<ans[i][j];
		puts("");
	}
	return 0;
}
```

---

## 作者：EzioAuditoreFirenze (赞：1)

典型**染色法**的“搜索”题目。  
之所以把搜索打上引号，是因为这道题目不需要回溯，不算是典型意义上的搜索。  
因为不需要回溯，所以我们无需用递归这种容易爆栈容易超时的方法（虽然本题不会出现上述情况）。  
本题基本思路：  
很显然，如果出现字符串"yizhong"，那么一定能找到'y'。我们要做的就是先遍历，然后找出'y'。  
接下来，我们要在八个方向分别扩展，看看这个'y'周围是否出现"yizhong"。如果出现了，就将出现的这部分染上色（book[tx][ty]=1）。  
注意：**一定要在扩展完毕确认出现"yizhong"以后再染色。**否则如果在扩展过程中染色，就算出现半截的"yizhong"比如"yiz"这种情况，也会被染上色，结果就不对了。  
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int way[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}},tx,ty;//八个方向的数组
bool book[10000][10000]={0,},pd=1;//book为染色数组。pd变量表示是否扩展成功发现"yizhong"
char field[10000][10000];
char yizhong[8]="yizhong";
int n;
int main()
{
	//输入部分
    cin>>n;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>field[i][j];
        }
    }
    //以下开始进入重点
    for(int x=0;x<n;x++)
        for(int y=0;y<n;y++)
        {
            if(field[x][y]=='y')//如果发现'y'，开始遍历八个方向
            {
                for(int direction=0;direction<8;direction++)//八个方向依次遍历
                {
                    tx=x;
                    ty=y;
                    pd=1;//我们先假设可以扩展出"yizhong"，如果扩展过程中发现不对，再pd=0
                    if(tx+way[direction][0]<0 || ty+way[direction][1]<0 || tx+way[direction][0]>=n || ty+way[direction][1]>=n)
                        continue;//如果越出区域范围，直接下一轮循环
                    for(int i=1;i<=6;i++)//因为总共是7个字符，去掉我们已经发现的'y'还有6个
                    {
                        if(field[tx+way[direction][0]][ty+way[direction][1]]==yizhong[i])
                        {
                            tx+=way[direction][0];//继续扩展
                            ty+=way[direction][1];//继续扩展
                        }
                        else
                        {
                            pd=0;//如果不符合"yizhong"，说明扩展失败
                            break;
                        }
                    }
                    if(pd)//如果扩展成功，开始染色
                    {
                        tx=x;
                        ty=y;
                        for(int i=0;i<7;i++)
                        {
                            book[tx][ty]=1;
                            tx+=way[direction][0];
                            ty+=way[direction][1];
                        }
                    }
                }
            }
        }
    //以下是输出
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(book[i][j])
                cout<<field[i][j];
            else
                cout<<'*';
        }
        cout<<endl;
    }
    return 0;
}
/*
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg
*/

```

---

## 作者：Jianyang (赞：1)

这是一道很考验编程能力的题目，本蒟蒻的方法是先找到一个‘y’，再向8个方向扩张（预处理一个表（花了我半个小时）），如果符合单词‘yizhong’，就标记经过的点，最后输出

附pascal标程

```cpp
var n,i,j,k,l:longint;
    a:array[-5..355,-5..355]of char;
    f:array[-5..355,-5..355]of boolean;
    d:array[1..8,1..6,1..2]of longint=(
    ((-1,0),(-2,0),(-3,0),(-4,0),(-5,0),(-6,0)),
    ((-1,1),(-2,2),(-3,3),(-4,4),(-5,5),(-6,6)),
    ((0,1),(0,2),(0,3),(0,4),(0,5),(0,6)),
    ((1,1),(2,2),(3,3),(4,4),(5,5),(6,6)),
    ((1,0),(2,0),(3,0),(4,0),(5,0),(6,0)),
    ((1,-1),(2,-2),(3,-3),(4,-4),(5,-5),(6,-6)),
    ((0,-1),(0,-2),(0,-3),(0,-4),(0,-5),(0,-6)),
    ((-1,-1),(-2,-2),(-3,-3),(-4,-4),(-5,-5),(-6,-6)));//d[i,j,1]表示从原坐标到第i个方向第j个x坐标需要增加（或减少）的值，d[i,j,2]则是y坐标需要增加（或减少）的值
begin
  readln(n);
  for i:=1 to n do
  begin
    for j:=1 to n do
    read(a[i,j]);//读入
    readln;
  end;                                   
  for i:=1 to n do//暴力四重循环搜索。。。
  for j:=1 to n do
  if a[i,j]='y'then//如果这个点的字符是‘y’
  for k:=1 to 8 do
  if(a[i+d[k,1,1],j+d[k,1,2]]='i')and(a[i+d[k,2,1],j+d[k,2,2]]='z')
  and(a[i+d[k,3,1],j+d[k,3,2]]='h')and(a[i+d[k,4,1],j+d[k,4,2]]='o')
  and(a[i+d[k,5,1],j+d[k,5,2]]='n')and(a[i+d[k,6,1],j+d[k,6,2]]='g')//判断是否符合单词‘yizhong’
  then
  begin
    f[i,j]:=true;//先要标记
    for l:=1 to 6 do
    f[i+d[k,l,1],j+d[k,l,2]]:=true;//把单词每个字母的坐标在布尔数组里标记
  end;
  for i:=1 to n do
  begin
    for j:=1 to n do
    if f[i,j]then//如果这个字母在单词中
    write(a[i,j])//输出字母
    else
    write('*');//否则输出‘*’
    writeln;//记得换行
  end;
end.
```

---

## 作者：KesdiaelKen (赞：1)

这题虽说标签是深搜题，但其实用不着深搜，因为一旦找到匹配的第一和第二个字母，那么这个单词的方向便是确定的了。所以，只需要让每一个可以作为开头的字母向八个方向延伸，寻找完整的符合要求的单词，便可以找到所有的符合要求的单词，并且知道他们的位置。（错误已改正，感谢Jacob233及时指出）


下为代码：


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    int dir[8][2]={{0,1},{1,0},{1,1},{0,-1},{-1,0},{-1,-1},{1,-1},{-1,1}};//向八个方向延伸每一格所需要移动的坐标
    char ys[100]="yizhong";//存已知需要寻找单词
    int len=7;//存已知需要寻找单词长度
    bool ns[101][101]={0};//判断是否不可以作为单词的开头
    bool sc[101][101]={0};//存是否输出原单词
    char zm[102][102]={0};//存单词矩阵。需要注意，这里要使用包圈的思想，及在原矩阵外包一层一定被判为不可进入的圈。这样便可以不用判定边界
    int hl;//矩阵边长
    scanf("%d",&hl);
    bool tf;//判断单词是否与"yizhong"完全相等
    for(int i=1;i<=hl;i++)
    {
        for(int j=1;j<=hl;j++)
        {
            scanf(" %c",&zm[i][j]);//记住要打空格“ %c”
            if(zm[i][j]!=ys[0])ns[i][j]=true;//是否可以作为开头
        }
    }
    for(int i=1;i<=hl;i++)
    {
        for(int j=1;j<=hl;j++)
        {
            if(!ns[i][j])//可以作为开头
            {
                for(int k=0;k<=7;k++)//总共有八个方向，对应着dir[0]至dir[7]
                {
                    tf=true;//判断是否完全与需判断单词相等
                    for(int m=1;m<len;m++)//已确定第一个单词，还要向外延伸len-1次
                    {
                        if(zm[i+(dir[k][0]*m)][j+(dir[k][1]*m)]!=ys[m])//zm[i+(dir[k][0]*m)][j+(dir[k][1]*m)]为延伸后所到达的字母，刚好对应着ys的第m个字符
                        {
                            tf=false;//不完整
                            break;//无需继续匹配
                        }
                    }
                    if(tf)//如果完全匹配
                    {
                        for(int m=0;m<len;m++)
                        {
                            sc[i+(dir[k][0]*m)][j+(dir[k][1]*m)]=true;//将这些单词记为可输出
                        }
                    }
                }
            }
        }
    }
    for(int i=1;i<=hl;i++)
    {
        for(int j=1;j<=hl;j++)
        {
            if(sc[i][j])printf("%c",zm[i][j]);//可输出
            else printf("*");
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：littleming (赞：1)

代码都很简单，重复的复制粘贴就可以啦，无脑深搜




    

    
    
```cpp
#include<iostream> 
#include<cstdio>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<string> 
#include<algorithm>
#include<queue>
using namespace std;
int n,p;//p指向k 
char a[105][105],an[105][105],ans[105][105];
string k="yizhong";
void dfs(int i,int j,int d)
{
    if(p==7)//成功，保存搜索结果 
    {
        for(int x=1;x<=n;x++)
            for(int y=1;y<=n;y++)
                if(an[x][y]!='0')    ans[x][y]=an[x][y];
        return;
    }
    else if(d==1&&a[i-1][j-1]==k[p]&&i-1>=1&&j-1>=1)    {an[i-1][j-1]=k[p];p++;dfs(i-1,j-1,1);p--;an[i-1][j-1]='0';    return;}
    else if(d==2&&a[i-1][j]==k[p]&&i-1>=1)                {an[i-1][j]=k[p];p++;dfs(i-1,j,2);p--;an[i-1][j]='0';        return;}
    else if(d==3&&a[i-1][j+1]==k[p]&&i-1>=1&&j+1<=n)    {an[i-1][j+1]=k[p];p++;dfs(i-1,j+1,3);p--;an[i-1][j+1]='0';    return;}
    else if(d==4&&a[i][j-1]==k[p]&&j-1>=1)                {an[i][j-1]=k[p];p++;dfs(i,j-1,4);p--;an[i][j-1]='0';        return;} 
    else if(d==5&&a[i][j+1]==k[p]&&j+1<=n)                {an[i][j+1]=k[p];p++;dfs(i,j+1,5);p--;an[i][j+1]='0';        return;}
    else if(d==6&&a[i+1][j-1]==k[p]&&i+1<=n&&j-1>=1)    {an[i+1][j-1]=k[p];p++;dfs(i+1,j-1,6);p--;an[i+1][j-1]='0';    return;} 
    else if(d==7&&a[i+1][j]==k[p]&&i+1<=n)                {an[i+1][j]=k[p];p++;dfs(i+1,j,7);p--;an[i+1][j]='0';        return;} 
    else if(d==8&&a[i+1][j+1]==k[p]&&i+1<=n&&j+1<=n)    {an[i+1][j+1]=k[p];p++;dfs(i+1,j+1,8);p--;an[i+1][j+1]='0';    return;} 
    else if(d==0)//第一次先确定从哪个方向上找“yizhong ” 
    {
        if(a[i-1][j-1]==k[p]&&i-1>=1&&j-1>=1)    {an[i-1][j-1]=k[p];    p++;dfs(i-1,j-1,1);    p--;an[i-1][j-1]='0';} 
        if(a[i-1][j]==k[p]&&i-1>=1)                {an[i-1][j]=k[p];    p++;dfs(i-1,j,2);    p--;an[i-1][j]='0';} 
        if(a[i-1][j+1]==k[p]&&i-1>=1&&j+1<=n)    {an[i-1][j+1]=k[p];    p++;dfs(i-1,j+1,3);    p--;an[i-1][j+1]='0';} 
        if(a[i][j-1]==k[p]&&j-1>=1)                {an[i][j-1]=k[p];    p++;dfs(i,j-1,4);    p--;an[i][j-1]='0';} 
        if(a[i][j+1]==k[p]&&j+1<=n)                {an[i][j+1]=k[p];    p++;dfs(i,j+1,5);    p--;an[i][j+1]='0';} 
        if(a[i+1][j-1]==k[p]&&i+1<=n&&j-1>=1)    {an[i+1][j-1]=k[p];    p++;dfs(i+1,j-1,6);    p--;an[i+1][j-1]='0';} 
        if(a[i+1][j]==k[p]&&i+1<=n)                {an[i+1][j]=k[p];    p++;dfs(i+1,j,7);    p--;an[i+1][j]='0';} 
        if(a[i+1][j+1]==k[p]&&i+1<=n&&j+1<=n)    {an[i+1][j+1]=k[p];    p++;dfs(i+1,j+1,8);    p--;an[i+1][j+1]='0';} 
    }
}
int main()
{
    memset(a,'0',sizeof(a));
    memset(an,'0',sizeof(an));
    memset(ans,'0',sizeof(ans)); 
    cin >> n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==k[0])    
            {
                an[i][j]=k[0];
                p=1;
                dfs(i,j,0);//三个参数的意义：横坐标，纵坐标，方向(0就是没有) 
                p=0;
                memset(an,'0',sizeof(an));
            }
        }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(ans[i][j]=='0')    cout<<"*";
            else    cout<<ans[i][j];
        }
        cout<<endl;
    }
    return 0;
}

```

---

## 作者：傅僧 (赞：1)

因为数据不大，所以可以直接暴力搜索，一个一个遍历然后有‘y'就向8个方向搜索，可以比较轻松地A掉，程序如下：

```delphi
var
  n,i,j,ii,jj:longint;
  a:array[-5..355,-5..355] of char;
  f:array[-5..355,-5..355] of boolean;      //因为会出现y在最边上一圈的情况所以需要把范围扩大至-5~355
  f1,f2,f3,f4,f5,f6,f7,f8:boolean;
procedure judge1(x,y:longint);
begin
  if a[x-1,y]='i'
    then if a[x-2,y]='z'
           then if a[x-3,y]='h'
                  then if a[x-4,y]='o'
                         then if a[x-5,y]='n'
                                then if a[x-6,y]='g'
                                       then for ii:=x downto x-6 do
                                              f[ii,y]:=true;
end;
procedure judge2(x,y:longint);
begin
  if a[x-1,y+1]='i'
    then if a[x-2,y+2]='z'
           then if a[x-3,y+3]='h'
                  then if a[x-4,y+4]='o'
                         then if a[x-5,y+5]='n'
                                then if a[x-6,y+6]='g'
                                       then for ii:=6 downto 0 do
                                              f[x-ii,y+ii]:=true;
end;
procedure judge3(x,y:longint);
begin
  if a[x,y+1]='i'
    then if a[x,y+2]='z'
           then if a[x,y+3]='h'
                  then if a[x,y+4]='o'
                         then if a[x,y+5]='n'
                                then if a[x,y+6]='g'
                                       then for jj:=6 downto 0 do
                                              f[x,y+jj]:=true;
end;
procedure judge4(x,y:longint);
begin
  if a[x+1,y+1]='i'
    then if a[x+2,y+2]='z'
           then if a[x+3,y+3]='h'
                  then if a[x+4,y+4]='o'
                         then if a[x+5,y+5]='n'
                                then if a[x+6,y+6]='g'
                                       then for ii:=6 downto 0 do
                                              f[x+ii,y+ii]:=true;
end;
procedure judge5(x,y:longint);
begin
  if a[x+1,y]='i'
    then if a[x+2,y]='z'
           then if a[x+3,y]='h'
                  then if a[x+4,y]='o'
                         then if a[x+5,y]='n'
                                then if a[x+6,y]='g'
                                       then for ii:=x to x+6 do
                                              f[ii,y]:=true;
end;
procedure judge6(x,y:longint);
begin
  if a[x+1,y-1]='i'
    then if a[x+2,y-2]='z'
           then if a[x+3,y-3]='h'
                  then if a[x+4,y-4]='o'
                         then if a[x+5,y-5]='n'
                                then if a[x+6,y-6]='g'
                                       then for ii:=6 downto 0 do
                                              f[x+ii,y-ii]:=true;
end;
procedure judge7(x,y:longint);
begin
  if a[x,y-1]='i'
    then if a[x,y-2]='z'
           then if a[x,y-3]='h'
                  then if a[x,y-4]='o'
                         then if a[x,y-5]='n'
                                then if a[x,y-6]='g'
                                       then for jj:=6 downto 0 do
                                              f[x,y-jj]:=true;
end;
procedure judge8(x,y:longint);
begin
  if a[x-1,y-1]='i'
    then if a[x-2,y-2]='z'
           then if a[x-3,y-3]='h'
                  then if a[x-4,y-4]='o'
                         then if a[x-5,y-5]='n'
                                then if a[x-6,y-6]='g'
                                       then for ii:=6 downto 0 do
                                              f[x-ii,y-ii]:=true;
end;
procedure judge(x,y:longint);            //判断总共8个方向的情况
begin
  judge1(x,y);
  judge2(x,y);
  judge3(x,y);
  judge4(x,y);
  judge5(x,y);
  judge6(x,y);
  judge7(x,y);
  judge8(x,y);
end;


begin
  fillchar(a,sizeof(a),'b');
  fillchar(f,sizeof(f),false);
  readln(n);
  for i:=1 to n do
    begin
      for j:=1 to n do
        read(a[i,j]);
      readln;
    end;                                   //读入
  for i:=1 to n do
    for j:=1 to n do
      if a[i,j]='y'
        then judge(i,j);                   //判断
  for i:=1 to n do
    begin
      for j:=1 to n do
        if f[i,j]
          then write(a[i,j])
          else write('*');                 //输出
      writeln;
    end;
end.
```
该程序没有考虑交叉的情况，因为题目中明确地说不会出现这样的情况，这个程序对于这样的情况会把交叉的两者都输出。


---

## 作者：萧萧尹 (赞：0)

想不到各位大佬的优美思路 只能写写自己的暴力DFS（6个） 

首先找到y 再八个方向找到i

记录此时的偏转方向 进入其他DFS 

若都满足 则一个个（排好队）更新 详见AC代码 求过```

```
//严格地说 这不是真的dfs 
#include <iostream>
#include <cstdio>
using namespace std;
int n,book;
char map[101][101],cp[101][101];
int dx[8]={1,1,1,0,0,-1,-1,-1};	//四个方向 
int dy[8]={1,0,-1,1,-1,1,0,-1};	//循环
int dfs6(int x,int y,int px,int py)
{
	int xx=x+px;int yy=y+py;
	if(xx<1||xx>n||yy<1||yy>n) return 0;
	if(map[xx][yy]=='g') 
	{
		cp[xx][yy]='g';
		return 1;
		//dfs的最后一层 如果满足一层层更新 
	}
	return 0;
}
int dfs5(int x,int y,int px,int py)
{
	int xx=x+px;int yy=y+py;
	if(xx<1||xx>n||yy<1||yy>n) return 0;
	if(map[xx][yy]=='n')
	{
		if(dfs6(xx,yy,px,py)==1)//判断同向延伸后是否为g 
		{
			cp[xx][yy]='n';
			return 1;
		}
	}
	return 0;	
}
int dfs4(int x,int y,int px,int py)
{
	int xx=x+px;int yy=y+py;
	if(xx<1||xx>n||yy<1||yy>n) return 0;
	if(map[xx][yy]=='o')
	{
		if(dfs5(xx,yy,px,py)==1)//判断同向延伸后是否为n
		{
			cp[xx][yy]='o';
			return 1;
		}
	}
	return 0;
}
int dfs3(int x,int y,int px,int py)
{
	int xx=x+px;int yy=y+py;
	if(xx<1||xx>n||yy<1||yy>n) return 0;
	if(map[xx][yy]=='h')
	{
		if(dfs4(xx,yy,px,py)==1)//判断同向延伸后是否为o
		{
			cp[xx][yy]='h';
			return 1;
		}
	}
	return 0;
}
int dfs2(int x,int y,int px,int py)
{
	int xx=x+px;int yy=y+py;
	if(xx<1||xx>n||yy<1||yy>n) return 0;
	if(map[xx][yy]=='z')
	{
		if(dfs3(xx,yy,px,py)==1)//判断同向延伸后是否为h
		{
			cp[xx][yy]='z';
			return 1;	
		}	
	}
	return 0;
}
void dfs1(int x,int y)
{
	book=0;
	for(int i=0;i<8;i++)
	{
		int xx=x+dx[i];int yy=y+dy[i];
		if(xx<1||xx>n||yy<1||yy>n) continue;
		if(map[xx][yy]=='i')//找到i 记录方向 
		{
			if(dfs2(xx,yy,dx[i],dy[i])==1)//判断同向延伸后是否为z
			{
				cp[xx][yy]='i';
				book=1;	
			}			
		}
	}
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>map[i][j];
			cp[i][j]='*';//初始cp数组 
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(map[i][j]=='y')//找到开头 
			{
				dfs1(i,j);
				if(book==1) cp[i][j]='y';//book=1说明izhong都已经更新 再更新y 
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) cout<<cp[i][j];
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：yubing_lml (赞：0)

### NO.11 **没有用递归的深搜！循环解决所有！**

大家有没有注意到，这道题目说的是单词的方向只有一种！也就是说，如果确定了要搜索的单词方向，之后就没有必要对点进行8个方向的搜索了。

### 那么问题就简化成3步：

（1）找所有的单词首字母 y（在输入的同时找出y）

（2）对y的8个方向依次进行判断

（3）对每个方向，相当于已经确定了x和y的增量，那么只要判断一直沿这个方向走是否会到达单词的末尾即可！（注意循环继续的条件）

### 使用的变量

#### Q 保存每个y的坐标（结构体存储）

#### mark 标记是否是合法单词的一部分

#### a 存储初始的字母矩阵

#### change 存储方向增量

程序的核心就是exist()函数：

### 对每个y的8个方向，都进行如下操作：

dx是x方向上的增量，dy是y方向上的增量，nx是当前的x坐标，ny是当前的y坐标，str保存结果，**next表示下一个期望的字符**。

```cpp
int dx = change[i][0];
int dy = change[i][1];
int nx = x;
int ny = y;
string str = "";
char next = 'y';
```
------------

while循环，若满足条件 1—该点合法 + 2—该点等于期望字符 + 3—字符串长度<7（这里<7是因为如果字符串等于7，就可以直接退出循环判断两个单词是否相等了）

注意next每次的取法： stample[str.size()]; 标本的第stample[str.size()];个元素，从0开始

```cpp
while (legal(nx, ny) && a[nx][ny] == next && str.size() < 7)
{
	str += next;
	nx = nx + dx;
	ny = ny + dy;
	next = stample[str.size()];
}
```

------------

如果结果字符串str等于标本，那么就把**这条直线**上的7个点mark置为true


```cpp
if (str == stample)
 	for (int j = 0; j < 7; j++)
		mark[x + j * change[i][0]][y + j * change[i][1]] = true;
```

------------


### 完整AC代码~

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<queue>
using namespace std;

short int n;
char a[101][101];
bool mark[103][103];
string stample = "yizhong";
short int change[8][2] = { {-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} };
struct pos
{
	int x, y;
};
queue<pos>Q;

bool legal(int x, int y)
{
	if (x<1 || x>n || y<1 || y>n)
		return false;
	return true;
}

void exist(int x, int y)
{
	for (int i = 0; i < 8; i++)
	{
		int dx = change[i][0];
		int dy = change[i][1];
		int nx = x;
		int ny = y;
		string str = "";
		char next = 'y';
		while (legal(nx, ny) && a[nx][ny] == next && str.size() < 7)
		{
			str += next;
			nx = nx + dx;
			ny = ny + dy;
			next = stample[str.size()];
		}
		if (str == stample)
			for (int j = 0; j < 7; j++)
				mark[x + j * change[i][0]][y + j * change[i][1]] = true;
	}//for
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			cin >> a[i][j];
			if (a[i][j] == 'y')
			{
				pos now;
				now.x = i;
				now.y = j;
				Q.push(now);
			}
		}
	memset(mark, 0, sizeof(mark));
	while (!Q.empty())
	{
		pos now;
		now = Q.front();
		Q.pop();
		exist(now.x, now.y);
	}

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
			if (mark[i][j] == true)
				cout << a[i][j];
			else
				cout << '*';
		cout << endl;
	}

	cin >> n;
	return 0;
}
```


---

## 作者：森森鸭 (赞：0)

## ~~正解是搜索，可惜我这个小蒟蒻不会~~
**思路简单易懂，可看文字解析自敲代码or看下面代码+注释**


------------
##  _暴力枚举（小优化）+ifififif……_
- 先循环输入，没技巧，简单不讲
- 建立一个布尔类型的数组做标记，全部赋值为0（1为输出字符，0为输出*）
- 开始循环一个个字符枚举，因为yizhong为y字符开头，只要碰到y字符就开始条件判断（一共八种，正左 正右 正上 正下 左上 左下 右上 右下，每个方向如何推导so easy），若符合判断，将连续的7个字符全部标记为1
- 判断格式举例（正左方向，即gnohziy）
```c
flag=1;
if(flag&&k[i][j-1]!='i') flag=0;
if(flag&&k[i][j-2]!='z') flag=0;
if(flag&&k[i][j-3]!='h') flag=0;
if(flag&&k[i][j-4]!='o') flag=0;
if(flag&&k[i][j-5]!='n') flag=0;
if(flag&&k[i][j-6]!='g') flag=0;
if(flag)
{
	k0[i][j]=1;k0[i][j-1]=1;k0[i][j-2]=1;k0[i][j-3]=1;k0[i][j-4]=1;k0[i][j-5]=1;k0[i][j-6]=1;
}
```
- 一定要加flag，只要一次不对，后面多于操作都不用进行，不然TLE向你招手
- 最后循环，判断当前字符是否标记，标记1输出字符，标记0输出*


------------
## **不知道文字讲的好不好，反正下面是带注释代码，看不懂上面的看下面**
# **勿！抄！袭！**
代码附上
```c
#include <iostream>
using namespace std；
int main()
{
	char k[101][101]；//初始矩阵
	bool k0[101][101]={0}；//记录是否输出原字符or输出*
	int n；//矩阵边长
	cin>>n；
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>k[i][j];//循环输入矩阵
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(k[i][j]=='y')//如果当前字符是y,开始暴力ififif
			{
				
				int flag=1；//记录是否有yizhong,先假装有哒
				//注意!下面一定要有flag存在于if条件内!不然浪费时间然TLE等着你
				//如果之前都已经不可能了,后面也不可能
				if(flag&&k[i][j+1]!='i') flag=0；
				if(flag&&k[i][j+2]!='z') flag=0；
				if(flag&&k[i][j+3]!='h') flag=0；
				if(flag&&k[i][j+4]!='o') flag=0；
				if(flag&&k[i][j+5]!='n') flag=0；
				if(flag&&k[i][j+6]!='g') flag=0；
				if(flag)
				{
					k0[i][j]=1;k0[i][j+1]=1;k0[i][j+2]=1;k0[i][j+3]=1;k0[i][j+4]=1;k0[i][j+5]=1;k0[i][j+6]=1;
				}//第一种 正横向yizhong
				
				flag=1;
				if(flag&&k[i][j-1]!='i') flag=0;
				if(flag&&k[i][j-2]!='z') flag=0;
				if(flag&&k[i][j-3]!='h') flag=0;
				if(flag&&k[i][j-4]!='o') flag=0;
				if(flag&&k[i][j-5]!='n') flag=0;
				if(flag&&k[i][j-6]!='g') flag=0;
				if(flag)
				{
					k0[i][j]=1;k0[i][j-1]=1;k0[i][j-2]=1;k0[i][j-3]=1;k0[i][j-4]=1;k0[i][j-5]=1;k0[i][j-6]=1;
				}//第二种 反横向yizhong
				
				flag=1;
				if(flag&&k[i-1][j]!='i') flag=0;
				if(flag&&k[i-2][j]!='z') flag=0;
				if(flag&&k[i-3][j]!='h') flag=0;
				if(flag&&k[i-4][j]!='o') flag=0;
				if(flag&&k[i-5][j]!='n') flag=0;
				if(flag&&k[i-6][j]!='g') flag=0;
				if(flag)
				{
					k0[i][j]=1;k0[i-1][j]=1;k0[i-2][j]=1;k0[i-3][j]=1;k0[i-4][j]=1;k0[i-5][j]=1;k0[i-6][j]=1;
				}//第三种 正竖向yizhong
				
				flag=1;
				if(flag&&k[i+1][j]!='i') flag=0;
				if(flag&&k[i+2][j]!='z') flag=0;
				if(flag&&k[i+3][j]!='h') flag=0;
				if(flag&&k[i+4][j]!='o') flag=0;
				if(flag&&k[i+5][j]!='n') flag=0;
				if(flag&&k[i+6][j]!='g') flag=0;
				if(flag)
				{
					k0[i][j]=1;k0[i+1][j]=1;k0[i+2][j]=1;k0[i+3][j]=1;k0[i+4][j]=1;k0[i+5][j]=1;k0[i+6][j]=1;
				}//第四种 反竖向yizhong
				
				flag=1;
				if(flag&&k[i+1][j-1]!='i') flag=0;
				if(flag&&k[i+2][j-2]!='z') flag=0;
				if(flag&&k[i+3][j-3]!='h') flag=0;
				if(flag&&k[i+4][j-4]!='o') flag=0;
				if(flag&&k[i+5][j-5]!='n') flag=0;
				if(flag&&k[i+6][j-6]!='g') flag=0;
				if(flag)
				{
				    k0[i][j]=1;k0[i+1][j-1]=1;k0[i+2][j-2]=1;k0[i+3][j-3]=1;k0[i+4][j-4]=1;k0[i+5][j-5]=1;k0[i+6][j-6]=1;
				}//第五种 右下角yizhong
				
				flag=1;
				if(flag&&k[i+1][j+1]!='i') flag=0;
				if(flag&&k[i+2][j+2]!='z') flag=0;
				if(flag&&k[i+3][j+3]!='h') flag=0;
				if(flag&&k[i+4][j+4]!='o') flag=0;
				if(flag&&k[i+5][j+5]!='n') flag=0;
				if(flag&&k[i+6][j+6]!='g') flag=0;
				if(flag)
				{
					k0[i][j]=1;k0[i+1][j+1]=1;k0[i+2][j+2]=1;k0[i+3][j+3]=1;k0[i+4][j+4]=1;k0[i+5][j+5]=1;k0[i+6][j+6]=1;
				}//第六种 右上角yizhong
				
				flag=1;
				if(flag&&k[i-1][j+1]!='i') flag=0;
				if(flag&&k[i-2][j+2]!='z') flag=0;
				if(flag&&k[i-3][j+3]!='h') flag=0;
				if(flag&&k[i-4][j+4]!='o') flag=0;
				if(flag&&k[i-5][j+5]!='n') flag=0;
				if(flag&&k[i-6][j+6]!='g') flag=0;
				if(flag)
				{
					k0[i][j]=1;k0[i-1][j+1]=1;k0[i-2][j+2]=1;k0[i-3][j+3]=1;k0[i-4][j+4]=1;k0[i-5][j+5]=1;k0[i-6][j+6]=1;
				}//第七种 左上角yizhong
				
				flag=1;
				if(flag&&k[i-1][j-1]!='i') flag=0;
				if(flag&&k[i-2][j-2]!='z') flag=0;
			    if(flag&&k[i-3][j-3]!='h') flag=0;
				if(flag&&k[i-4][j-4]!='o') flag=0;
				if(flag&&k[i-5][j-5]!='n') flag=0;
				if(flag&&k[i-6][j-6]!='g') flag=0;
				if(flag)
				{
						k0[i][j]=1;k0[i-1][j-1]=1;k0[i-2][j-2]=1;k0[i-3][j-3]=1;k0[i-4][j-4]=1;k0[i-5][j-5]=1;k0[i-6][j-6]=1;
				}//第八种 左下角yizhong
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(k0[i][j]) cout<<k[i][j];//如果当前字符被标记过,则输出字符
			else cout<<" * ";//不然输出*
		}
		cout<<endl;//记得换行
	}
	return 0;
	//O了
}
```
~~才不告诉你已做防抄袭处理，当然你也可以花一丢丢时间改回来~~
## *小蒟蒻的第一篇题解，求过yyy*

---

## 作者：_starsky (赞：0)

## 记录 P1101 c++题解
关于代码的注释已经很详细了 供自己以后优化同时跟大家分享

```cpp

#include <iostream>

using namespace std;

char map[110][110]; //存放单词矩阵
int  vis[110][110]; //记录这个点是否来过
int _next[8][2] = { { -1, -1 },
                    { -1, 0  }, 
					{ -1, 1  },
					{ 0, -1  },
					{ 0, 1   },
					{ 1, -1  },
					{ 1, 0   },
					{ 1, 1   } };
int n;//表示生成矩阵的大小
char flag[] = "yizhong";


bool inmap(int x, int y)
{
	if (x <= n && x >= 1 && y <= n && y >= 1)return true;
	else return false;
}

//fx作为方向参数代表沿着这个方向一直走
void dfs(int x,int y,int count,int fx)
{
	//当这条路可以走通
	//记录此路径
	if (count == 6)
	{
		vis[x][y] = 1;
		for (int i = 0; i < 6; i++)
		{
			//执行八次
			x = x - _next[fx][0];
			y = y - _next[fx][1];
			vis[x][y] = 1;
		}
		return;
	}
	else 
	{
		int tx, ty;
		tx = x + _next[fx][0];
		ty = y + _next[fx][1];
		//判断这个点是否满足条件 ：
		//1.在地图内
		//2.这个字符和flag对应的字符想等
		if (inmap(tx, ty) == 1 && map[tx][ty] == flag[count+1])
		{
			dfs(tx, ty, count+1, fx);
		}
	}
}


int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			cin >> map[i][j];
		}
	}
	//首先先搜索 y
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if (map[i][j] == 'y')
			{
				//八个方向进行回溯
				for (int k = 0; k < 8; k++)
				{
					dfs(i, j,0,k);
				}
			}
		}
	}

	//输出 
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if (vis[i][j] == 1)
			{
				cout << map[i][j];
			}
			else cout << "*";
		}
			cout << endl;
	}
}

```

---

## 作者：jhdonghj (赞：0)

无脑输表

本方法不需要脑子

```cpp
#include<iostream>
#include<vector>
//#include<fstream>

using namespace std;

//ifstream infile;

int main() {
	//infile.open("D:\\text.txt");
	const char word[] = "yizhong1";
	int n;
	cin >> n;
	//infile >> n;
	vector<vector<char>> map(n,vector<char>(n));
	vector<vector<bool>> judge(n, vector<bool>(n, false));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			cin >> map[i][j];
			//infile >> map[i][j];
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) {
			//left_up
			if (i - 6 >= 0 && j - 6 >= 0)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i - 1][j - 1] =
						judge[i - 2][j - 2] = judge[i - 3][j - 3] =
						judge[i - 4][j - 4] = judge[i - 5][j - 5] =
						judge[i - 6][j - 6] = true;
					else if (map[i - p][j - p] != word[p])
						break;
				}
			//up
			if (i - 6 >= 0)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i - 1][j] =
						judge[i - 2][j] = judge[i - 3][j] =
						judge[i - 4][j] = judge[i - 5][j] =
						judge[i - 6][j] = true;
					else if (map[i - p][j] != word[p])
						break;
				}
			//right_up
			if (i - 6 >= 0 && j + 6 <= n - 1)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i - 1][j + 1] =
						judge[i - 2][j + 2] = judge[i - 3][j + 3] =
						judge[i - 4][j + 4] = judge[i - 5][j + 5] =
						judge[i - 6][j + 6] = true;
					else if (map[i - p][j + p] != word[p])
						break;
				}
			//right
			if (j + 6 <= n - 1)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i][j + 1] =
						judge[i][j + 2] = judge[i][j + 3] =
						judge[i][j + 4] = judge[i][j + 5] =
						judge[i][j + 6] = true;
					else if (map[i][j + p] != word[p])
						break;
				}
			//right_down
			if (i + 6 <= n - 1 && j + 6 <= n - 1)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i + 1][j + 1] =
						judge[i + 2][j + 2] = judge[i + 3][j + 3] =
						judge[i + 4][j + 4] = judge[i + 5][j + 5] =
						judge[i + 6][j + 6] = true;
					else if (map[i + p][j + p] != word[p])
						break;
				}
			//down
			if (i + 6 <= n - 1)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i + 1][j] =
						judge[i + 2][j] = judge[i + 3][j] =
						judge[i + 4][j] = judge[i + 5][j] =
						judge[i + 6][j] = true;
					else if (map[i + p][j] != word[p])
						break;
				}
			//left_down
			if (i + 6 <= n - 1 && j - 6 >= 0)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i + 1][j - 1] =
						judge[i + 2][j - 2] = judge[i + 3][j - 3] =
						judge[i + 4][j - 4] = judge[i + 5][j - 5] =
						judge[i + 6][j - 6] = true;
					else if (map[i + p][j - p] != word[p])
						break;
				}
			//left
			if(j-6>=0)
				for (int p = 0; p <= 7; p++) {
					if (p == 7)
						judge[i][j] = judge[i][j - 1] =
						judge[i][j - 2] = judge[i][j - 3] =
						judge[i][j - 4] = judge[i][j - 5] =
						judge[i][j - 6] = true;
					else if (map[i][j - p] != word[p])
						break;
				}
			//ending    真tmd不容易
		}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (judge[i][j])
				cout << map[i][j];
			else
				cout << "*";
		}
		cout << endl;
	}
	//infile.close();
	return 0;
}
```

---

## 作者：Rlxzmdd (赞：0)

整体的思路：  
遍历每个字符，当为Y时，就开始使用canFind，就遍历dir方向数组，进行四周搜索，搜索周围的字符。   
当有字符i存在时，就使用当前确认的这个方向(dir[i])，继续搜索，如果全部符合，就在ans数组里填写字母显示的位置。   


```C
using namespace std;
bool canFind(int x,int y,int toX,int toY,int num);
int n;
char s[101][101];
int ans[101][101]={0};
int dir[][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
char cTemp[7] = "izhong";
int main(){
    cin >> n;
    for(int x=0;x<n;x++){
        for(int y=0;y<n;y++){
            cin >> s[x][y];
        }
    }
    for(int x=0;x<n;x++){
        for(int y=0;y<n;y++){
            if(s[x][y] == 'y'){
                for(int i=0;i<8;i++){
                    canFind(x, y, dir[i][0], dir[i][1],0);
                    //确认方向，开始搜索
                }
            }
        }
    }
    for(int x=0;x<n;x++){
        for(int y=0;y<n;y++){
            if(ans[x][y]){
                cout<<s[x][y];
            }else{
                cout<<'*';
            }
            //输出答案
        }
        cout << endl;
    }
}
bool canFind(int x,int y,int toX,int toY,int num){
//num为cTemp字符缓存数组的记录，记录查询到了第几个字符
    if(num+1 == 6){
    //当搜索完成时，就对ans数组进行修改
        for(int i=-1;i<num+1;i++){
            ans[x-toX*i][y-toY*i] = 1;
        }
        return true;
    }
    if(s[x+toX][y+toY] == cTemp[num]){
        return canFind(x+toX, y+toY, toX, toY,num+1);
        //符合，继续搜索下一个字符
    }else{
        return false;
    }
}
```

---

## 作者：Soyilieber (赞：0)

来一发pascal的判断
```pascal
var
    i,j,k,n:longint;
    a:array[-5..106,-5..106]of char;//开到1-6,100+6为了下面找路做准备
    v:array[-5..106,-5..106]of boolean;
begin
    readln(n);
    for i:=1 to n do
        begin
            for j:=1 to n do
                read(a[i,j]);//读字符
            readln;
        end;
    for i:=1 to n do
        for j:=1 to n do
            begin
                if (a[i,j]='y')and(a[i,j+1]='i')and(a[i,j+2]='z')and(a[i,j+3]='h')and(a[i,j+4]='o')and(a[i,j+5]='n')and(a[i,j+6]='g') then for k:=0 to 6 do v[i,j+k]:=true;//如果是从左到右横着
                if (a[i,j]='y')and(a[i+1,j]='i')and(a[i+2,j]='z')and(a[i+3,j]='h')and(a[i+4,j]='o')and(a[i+5,j]='n')and(a[i+6,j]='g') then for k:=0 to 6 do v[i+k,j]:=true;//如果是从上到下竖着
                if (a[i,j]='y')and(a[i,j-1]='i')and(a[i,j-2]='z')and(a[i,j-3]='h')and(a[i,j-4]='o')and(a[i,j-5]='n')and(a[i,j-6]='g') then for k:=0 to 6 do v[i,j-k]:=true;//如果是从右到左横着
                if (a[i,j]='y')and(a[i-1,j]='i')and(a[i-2,j]='z')and(a[i-3,j]='h')and(a[i-4,j]='o')and(a[i-5,j]='n')and(a[i-6,j]='g') then for k:=0 to 6 do v[i-k,j]:=true;//如果是从下到上竖着
                if (a[i,j]='y')and(a[i+1,j+1]='i')and(a[i+2,j+2]='z')and(a[i+3,j+3]='h')and(a[i+4,j+4]='o')and(a[i+5,j+5]='n')and(a[i+6,j+6]='g') then for k:=0 to 6 do v[i+k,j+k]:=true;//如果是从左上到右下斜着
                if (a[i,j]='y')and(a[i-1,j-1]='i')and(a[i-2,j-2]='z')and(a[i-3,j-3]='h')and(a[i-4,j-4]='o')and(a[i-5,j-5]='n')and(a[i-6,j-6]='g') then for k:=0 to 6 do v[i-k,j-k]:=true;//如果是从右下到左上斜着
                if (a[i,j]='y')and(a[i+1,j-1]='i')and(a[i+2,j-2]='z')and(a[i+3,j-3]='h')and(a[i+4,j-4]='o')and(a[i+5,j-5]='n')and(a[i+6,j-6]='g') then for k:=0 to 6 do v[i+k,j-k]:=true;//如果是从右上到左下斜着
                if (a[i,j]='y')and(a[i-1,j+1]='i')and(a[i-2,j+2]='z')and(a[i-3,j+3]='h')and(a[i-4,j+4]='o')and(a[i-5,j+5]='n')and(a[i-6,j+6]='g') then for k:=0 to 6 do v[i-k,j+k]:=true;//如果是从左下到右上斜着
            end;
    for i:=1 to n do
        begin
            for j:=1 to n do
                if not v[i,j] then write('*') else write(a[i,j]);//输出
            writeln;
        end;
end.
```

---

## 作者：huang_yue (赞：0)

虽然这一题被归到了搜索这一栏，但是其实不用搜索也可以做。

可以遍历整个数组寻找y，然后向八个方向找是否有izhong。而由于数据只有100^2，这样是可以AC的。

这里的实现可能和各位大佬的不太一样。


    
    

```cpp
    //头文件已省略
    char w[110][110]; //存储字符矩阵
    bool mask[110][110]; //若mask[i][j]==false，说明应该输出*，否则输出w[i][j]的值
    const char* c = "izhong"; //找到y以后，剩下的部分
    int n; //矩阵大小
    void search(int x, int y) {
        if (w[x][y] != 'y') return; //若不为y，则返回
        if (x >= n - 6) goto next1; //这里一大段的解释见下面
        for (int i = 0; i < 6; ++i) { //down
        if (w[x + i + 1][y] != c[i]) goto next1;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x + i][y] = true;
        }
        next1: if (x <= 6) goto next2;
        for (int i = 0; i < 6; ++i) { //up
            if (w[x - i - 1][y] != c[i]) goto next2;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x - i][y] = true;
        }
        next2: if (y <= 6) goto next3;
        for (int i = 0; i < 6; ++i) { //left
            if (w[x][y - i - 1] != c[i]) goto next3;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x][y - i] = true;
        }
        next3: if (y >= n - 6) goto next4;
        for (int i = 0; i < 6; ++i) { //right
            if (w[x][y + i + 1] != c[i]) goto next4;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x][y + i] = true;
        }
        next4: if (x >= n - 6 || y <= 6) goto next5;
        for (int i = 0; i < 6; ++i) { //left-up (y- x+)
            if (w[x + i + 1][y - i - 1] != c[i]) goto next5;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x + i][y - i] = true;
        }
        next5: if (x <= 6 || y <= 6) goto next6;
        for (int i = 0; i < 6; ++i) { //left-down (y- x-)
            if (w[x - i - 1][y - i - 1] != c[i]) goto next6;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x - i][y - i] = true;
        }
        next6: if (x >= n - 6 || y >= n - 6) goto next7;
        for (int i = 0; i < 6; ++i) { //right-up (y+ x+)
            if (w[x + i + 1][y + i + 1] != c[i]) goto next7;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x + i][y + i] = true;
        }
        next7: if (y >= n - 6 || x <= 6) return;
        for (int i = 0; i < 6; ++i) { //right-down (y+ x-)
            if (w[x - i - 1][y + i + 1] != c[i]) return;
        }
        for (int i = 0; i < 7; ++i) {
            mask[x - i][y + i] = true;
        }
    }
    int main() {
        cin >> n;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                cin >> w[i][j]; //输入
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                search(i, j); //遍历数组，寻找'y'
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j)
                cout << (mask[i][j] ? w[i][j] : '*'); //按照mask数组说明的那样输出
            cout << '\n'; //记得换行
        }
        return 0;
```
PS:
上面的代码有五十多行没有解释，其实大家可能已经懂了。如果没有，在这里附加一个:

其实这些代码一共分八段，每一段负责一个方向的搜索。拿前两段为例:


for (int i = 0; i < 6; ++i) { //往下搜索izhong，也就是c里面存的值

if (w[x + i + 1][y] != c[i]) goto next1; //这里加1的原因是，w[x][y]是值为'y'的元素，而它下面的元素才可能是从i开始的

//如果有一个字符不对，就跳到next1，也就是跳过填充mask数组的部分


```cpp
    }
    for (int i = 0; i < 7; ++i) {
        mask[x + i][y] = true; //注意这里不加1，是因为'y'也要填充
    }
    next1: if (x <= 6) goto next2;
    for (int i = 0; i < 6; ++i) { //up
        if (w[x - i - 1][y] != c[i]) goto next2; //原理同上，注意是减一
    }
    for (int i = 0; i < 7; ++i) {
        mask[x - i][y] = true;
    }
其余的依此类推，每一个next标签就是一段。
```

---

## 作者：List (赞：0)

这个题，我没有用一个7个单位大小的数组记录路径，而直接在标记数组上进行操作，需要注意的细节会很多，会加深一点难度，建议用下面题解大佬用的数组记忆路径会比较简单，上代码






```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 110
char s[maxn][maxn],t[]="yizhong";
int n;
int visit[101][101] = {0};///保存路径
int direct[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};///八个方向
int dfs(int x,int y,int k,int i)///(x,y)位置搜索第k个位置的方向dii个字母
{
    if(i>=7)
        return 1;///一共只有7个单词
    int xx = x + direct[k][0];
    int yy = y + direct[k][1];
    if(xx>=0 && xx<n && yy>=0 && yy<n && s[xx][yy] == t[i])///保证不能越界
    {
        if(visit[xx][yy] == 0)///如果之前有路径会标记成2这时候就不能将其标记为1
            visit[xx][yy] = 1;///记录路径
        int m = dfs(xx,yy,k,i+1);///开始搜索下一个字母最后搜索到g如果匹配成功就会返回1，否则返回0
        ///而前面的返回值也就是1或者0
        if(!m && visit[xx][yy]==1)///如果这个单词在别的方向被用过也就是说有重合部分那么不能去除标记
        {
            visit[xx][yy] = 0;///进行回溯
            return 0;///回溯要返回0
        }
        if(!m && visit[xx][yy]==2)
            return 0;///如果这个位置之前用过那么回溯不能去除标记，但是前面的仍然需要进行回溯
        return 1;
    }
    else
        return 0;
}
void cannot(int i,int j,int k)///起点为(i,j)在第k个方向不能被去除标记
{
    int iii=i,jjj=j;
    visit[i][j] = 2;
    for(int t = 1;t<=6;t++)///往这个方向查找6个单词
    {
        iii+=direct[k][0];
        jjj+=direct[k][1]; ///注意要一直往下加
        visit[iii][jjj]=2;
    }
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
            cin>>s[i];
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(s[i][j] == t[0])
            {
                for(int k = 0;k<8;k++)///开始在第k个方向查找下标为1的字母
                {
                    if(visit[i][j] ==0 )
                        visit[i][j]=1;
                    int m = dfs(i,j,k,1);
                    //cout<<m<<endl;
                    if(m == 1)
                    {
                        cannot(i,j,k);///防止去除标记的函数
                    }
                    if(!m && visit[i][j]==1)///如果这一个方向出错，并且这个方向的y没有被用到
                        visit[i][j] = 0;
                //print();
                }
            }
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++)
        {
            if(visit[i][j])
                cout<<s[i][j];
            else
                cout<<"*";
        }
        cout<<endl;
    }
    return 0;
}

```

---

## 作者：微雨燕双飞 (赞：0)

本题乍一看是一道纯粹的搜索题，本身难度也不高。搜索固然是本题的官方解法，但是思考起来有些许难度（仅仅对和我一样渣的童鞋而言）。所以这里我写了一个半搜索半枚举的方法。之所以可以这样做，源于题干中的一句关键句“同一单词摆放时不再改变方向”。这时，有些人可能会问：有什么关键的作用啊？只要稍加推导，就不难发现只要确定单词的前两个字母，就可以得到整个单词的确切位置。所以，我的算法是：枚举“yizhong”中字母“y”的位置，再从该位置向八个方向搜索（这里是伪搜索）。为了增加程序的可读性，我是先找到并标记每一个前两个字母是“yi”的单词，再判断它是否是我们要找的“yizhong”即可。由于本题是以搜索为背景命题，因此数据范围并不是很大，不然搜索可能会面临超时的危险（搜索的时间复杂度是成幂次方递增的）。

下面献上我的AC代码，写得比楼上几位dalao要长一些，大神们不喜勿喷！

```cpp
#include<iostream>
using namespace std;
int total=0,n;
int hang_w[10000][10],lie_w[10000][10]; //记录一个单词中每一个字母的行列位置
char map[110][110];
bool wrong[110][110]; //判断是否找到满足条件的单词
void work(int i,int j,int a,int b) //伪搜，像四面八方递推
{
   total++;
   hang_w[total][1]=i; lie_w[total][1]=j;
   hang_w[total][2]=i+a; lie_w[total][2]=j+b;
   hang_w[total][3]=i+2*a; lie_w[total][3]=j+2*b;
   hang_w[total][4]=i+3*a; lie_w[total][4]=j+3*b;
   hang_w[total][5]=i+4*a; lie_w[total][5]=j+4*b;
   hang_w[total][6]=i+5*a; lie_w[total][6]=j+5*b;
   hang_w[total][7]=i+6*a; lie_w[total][7]=j+6*b;
}
int main()
{
   cin>>n;
   for(int i=1; i<=n; i++)
     for(int j=1; j<=n; j++) cin>>map[i][j];
   for(int i=1; i<=n; i++)
     for(int j=1; j<=n; j++)
       if(map[i][j]=='y') //定y找i，从而确定整个单词的位置
       {
          if(map[i-1][j-1]=='i') work(i,j,-1,-1);
          if(map[i-1][j]=='i') work(i,j,-1,0);
          if(map[i-1][j+1]=='i') work(i,j,-1,1);
          if(map[i][j-1]=='i') work(i,j,0,-1);
          if(map[i][j+1]=='i') work(i,j,0,1);  
          if(map[i+1][j-1]=='i') work(i,j,1,-1);
          if(map[i+1][j]=='i') work(i,j,1,0); 
          if(map[i+1][j+1]=='i') work(i,j,1,1); 
       }
   for(int k=1; k<=total; k++) //判断预处理的单词是否是正确的单词
     if(((map[hang_w[k][1]][lie_w[k][1]]=='y'&&map[hang_w[k][2]][lie_w[k][2]]=='i'&&
          map[hang_w[k][3]][lie_w[k][3]]=='z'&&map[hang_w[k][4]][lie_w[k][4]]=='h'&&
          map[hang_w[k][5]][lie_w[k][5]]=='o'&&map[hang_w[k][6]][lie_w[k][6]]=='n'&&
          map[hang_w[k][7]][lie_w[k][7]]=='g'))) 
     {
        wrong[hang_w[k][1]][lie_w[k][1]]=true;
        wrong[hang_w[k][2]][lie_w[k][2]]=true;
        wrong[hang_w[k][3]][lie_w[k][3]]=true;
        wrong[hang_w[k][4]][lie_w[k][4]]=true;
        wrong[hang_w[k][5]][lie_w[k][5]]=true;
        wrong[hang_w[k][6]][lie_w[k][6]]=true;
        wrong[hang_w[k][7]][lie_w[k][7]]=true;
     }
   for(int i=1; i<=n; i++)
   {
     for(int j=1; j<=n; j++)
       if(!wrong[i][j]) cout<<"*";
         else cout<<map[i][j]; //打印输出
      cout<<endl;
   }
   return 0;
}
```

---

## 作者：xukuan (赞：0)

dfs不是必须的

```cpp
var
 i,j,n:longint;
 a:Array[0..101,0..101] of char;
 f:array[0..101,0..101] of boolean;
 b:array['a'..'z'] of 1..7;
 lx:array[1..8]of -1..1=(-1,-1,-1,0,0,1,1,1);
 ly:array[1..8]of -1..1=(-1,0,1,-1,1,-1,0,1);
```
lx，ly为八个方向
procedure dfs(x,y:longint);

倍数要小心，因为j=0时是y，不是j=1

```cpp
 var
  i,j:longint;
  bo:boolean; 标记
 begin
  for i:=1 to 8 do  穷举方向
   begin
    bo:=true;
    for j:=1 to 6 do
      if b[a[x+lx[i]*j,y+ly[i]*j]]<>j+1 then
       begin
        bo:=false;
        break;
       end;
    if bo then for j:=0 to 6 do f[x+lx[i]*j,y+ly[i]*j]:=true;
   end;
end;
begin
 fillchar(f,sizeof(f),false);
 readln(n);
```
字符数组输入必需换行
```cpp
 for i:=1 to n do
  begin
   for j:=1 to n do
    read(A[i,j]);
   readln;
  end;
 b['y']:=1;b['i']:=2;b['z']:=3;b['h']:=4;b['o']:=5;b['n']:=6;b['g']:=7;方便处理
 for i:=1 to n do
  for j:=1 to n do
   if a[i,j]='y' then dfs(i,j);
 for i:=1 to n do
  begin
   for j:=1 to n do
    if f[i,j] then write(a[i,j])
              else write('*');
   writeln;
  end;
end.
```

---

## 作者：Hydroxyl (赞：0)

近段时间比较忙 也没多少时间写程序 我在这也就有一点的优化方案放上来 过一段时间等我把这题A了我在把代码贴上来：

首先这道题算法为纯搜索，当然啦这肯定的

1、首先在读入和输出当中我们可以做一些处理，例如我们可以开2 个数组，一个记录初识状态并且用于搜索 另一个记录输出状态即最终答案 读一个判断一个，如果不是那个单词中的字母那么就在另一个数组中相应的位置直接变成‘\*’号 并且读入的时候可以直接记录一下y的位置在接下来的搜索中会方便很多



```cpp
for i:=1 to n do for j:=1 to n do b[i,j]:='*';
    word:=['y','i','z','h','o','n','g'];
    readln(n);
    for i:=1 to n do
    begin
     for j:=1 to n do
     begin
       read(a[i,j]);
       if a[i,j] in word then b[i,j]:=a[i,j] else b[i,j]:='*';
       if a[i,j]='y' and (k=1)then begin inc(k); x:=i; y:=j; end;
     end;
     readln;
    end;
```
2、关于找方向，那么个人是建议用一个二维常量数组定义起来循环找方向，在搜索的参数表中可以加入搜索的层数和方向，这样总归处理起来会方便很多  然后在下面就直接按照那样搜索就好了
3、在搜索的时候一个比较强力的剪枝

判断这行中还有多少个数没搜，搜索的字符串中还有多少的字母没有搜，如果没搜的字母比后面的要多那么久直接往下一层跳 例如当数据是这样的时候：


asdyizhong

aisuizhong

asdkjnaedj

asdjnfeank

yizhongask

iasdjiongaz

zhongyizho

haskdjongo

ongjasdjkhh

naskdjhasj

gasdjkzhong(随意打的，可能有偏差反正大致就这个意思了啦）


数据是这样的时候这一步剪枝或许也蛮强的


总而言之

先隐去不是字母的

读入时记录y的坐标然后搜索方便

搜索时如上面的强力剪枝

然后慢慢处理最后这道题相信最后的用时应该是很短的

这真的是非常棒的一道练习搜索的好题

在这里可以练习剪枝什么的，反正都加油啦


---

## 作者：夏色祭 (赞：0)

记忆化搜索，记录每一个去过的地方，并标记。

先从一个地方开始搜索，每次搜索先判断目前所在位置字母是不是单词的第k个字母，如果不是，直接返回false，如果所找字母数大于7，那么说明找到了一个单词，返回true。如果是第一个字母，则需先找向一个方向，再去搜索，接下来一直往这个方向。最后如果这能组成一个单词，返回true。

程序：

```cpp
const
  hehe:array[1..7]of char=('y','i','z','h','o','n','g');
  dh:array[1..8]of longint=(-1,-1,-1,0,0,1,1,1);
  dl:array[1..8]of longint=(-1,0,1,-1,1,-1,0,1);
var
  a:array[0..101,0..101]of char;
  b:array[0..101,0..101]of boolean;
  n,i,j:longint;
  s:ansistring;
  p:boolean;
function try(k,l,r,t:longint):boolean;
var
  x,i,j:longint;
  p:boolean;
  begin 
    p:=false;
    if k>7 then exit(true);//如果大于八，就说明能组成一个单词
    if a[l,r]<>hehe[k] then exit(false);//不等于单词的第k个字母那么返回false
    if k=1 then 
      begin
        for x:=1 to 8 do
          begin
            i:=l+dh[x];
            j:=r+dl[x];
            if try(k+1,i,j,x) then begin b[l,r]:=true;p:=true; end;
          end;
      end//第一次找一个方向去搜索
      else 
        begin
          i:=l+dh[t];
          j:=r+dl[t];
          if try(k+1,i,j,t) then begin b[l,r]:=true;p:=true; end;
        end;//一直往哪个方向去搜索
    if p then exit(true) else exit(false);//判断单词后n-k+1个字母是否都有，如果是的返回真，不是返回false
  end;
begin
  readln(n);
  for i:=1 to n do
    begin
      readln(s);
      for j:=1 to n do 
        a[i,j]:=s[j];
    end;
  for i:=1 to n do
    for j:=1 to n do
      begin
        if (b[i,j]) then continue;//找过就不用找了，记忆化
        if (not(try(1,i,j,0))) then b[i,j]:=false
          else b[i,j]:=true;//如果返回结果为假，说明不能从这个位置开始组成单词，所以为‘*’号，否则为真
      end; 
  for i:=1 to n do
    for j:=1 to n do 
      if not(b[i,j]) then a[i,j]:='*';
  for i:=1 to n do
    begin
      for j:=1 to n do write(a[i,j]);
      writeln;
    end;
end.
```

---

## 作者：安好 (赞：0)

/\*这个题适合练习dfs。首先找到‘y'，然后从这个方向扩展，找下一个字符。这里的字符可以提前用一个数组存起来。当找到第七个字符时，向前标记，最后吧有标记的输出即可\*/



    

```cpp
#include<iostream> 
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 105;
char s[N][N], a[] = "yizhong";
bool vis[N][N];
int n;
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1},
    dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};
void dfs(int x,int y,int w,int i)//x,y,表示坐标，w表示方向，i表示第几个字符。
{
    if(w==-1)//如果是第一次找
    {
        for(int j=0;j<8;j++)
        {
            int xx=x+dx[j];
            int yy=y+dy[j];
            if(s[xx][yy]==a[i]) 
              dfs(xx,yy,j,i+1)//扩展搜索;
        }
        return;
    }
    if(i==7)//如果已经找到这个字符串，回溯标记。
    {
        int xx=x,yy=y;
        for(int j=1;j<=7;j++)
         {
               vis[xx][yy]=1;
               xx=xx-dx[w];
               yy=yy-dy[w];
         }
         return;
    }
    int xx=x+dx[w];
    int yy=y+dy[w];
    if(s[xx][yy]==a[i])
      dfs(xx,yy,w,i+1);
}
int main()
{
    memset(s,'*',sizeof s);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%s",s[i]+1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
          if(s[i][j]=='y') dfs(i,j,-1,1);
    }
    for(int i=1;i<=n;cout<<endl,i++)
      for(int j=1;j<=n;j++) 
      {
         if(vis[i][j]) cout<<s[i][j];
         else cout<<'*';
      }
    return 0;    
}
```

---

## 作者：猪猪 (赞：0)











                

```cpp
//深搜....好麻烦啊...不过还是过了
var a:array[0..101,0..101] of char;
        b:array[0..101,0..101] of boolean;//用于输出。。可以构成就定义为TRUE 反则反之
    n,i,j,sum:longint;
procedure search(x,y:longint; c:string);//x，y是横纵坐标，c表示方向（因为只能朝一个方向一直搜索）
    begin
        if (a[x,y]='y') and (a[x+1,y]='i') and (c='y') then begin  sum:=sum+1; search(x+1,y,'y'); end;//搜右边 //sum是存储现在搜到yizhong中的几个，为了回溯服务
        if (a[x,y]='y') and (a[x,y+1]='i') and (c='s') then begin  sum:=sum+1; search(x,y+1,'s'); end;//搜左边
        if (a[x,y]='y') and (a[x-1,y]='i') and (c='z') then begin  sum:=sum+1; search(x-1,y,'z'); end;//搜下方
        if (a[x,y]='y') and (a[x,y-1]='i') and (c='x') then begin  sum:=sum+1; search(x,y-1,'x'); end;//搜上方
        if (a[x,y]='y') and (a[x+1,y+1]='i') and (c='ys') then begin  sum:=sum+1; search(x+1,y+1,'ys'); end;//搜右上
        if (a[x,y]='y') and (a[x+1,y-1]='i') and (c='yx') then begin  sum:=sum+1; search(x+1,y-1,'yx'); end;//搜右下
        if (a[x,y]='y') and (a[x-1,y+1]='i') and (c='zs') then begin  sum:=sum+1; search(x-1,y+1,'zs'); end;//搜左上
        if (a[x,y]='y') and (a[x-1,y-1]='i') and (c='zx') then begin  sum:=sum+1; search(x-1,y-1,'zx'); end;//搜左下
//以下都同理
        if (a[x,y]='i') and (a[x+1,y]='z') and (c='y') then  begin sum:=sum+1;search(x+1,y,'y'); end;
        if (a[x,y]='i') and (a[x,y+1]='z') and (c='s') then  begin sum:=sum+1;search(x,y+1,'s'); end;
        if (a[x,y]='i') and (a[x-1,y]='z') and (c='z') then  begin sum:=sum+1;search(x-1,y,'z'); end;
        if (a[x,y]='i') and (a[x,y-1]='z') and (c='x') then  begin sum:=sum+1;search(x,y-1,'x'); end;
        if (a[x,y]='i') and (a[x+1,y+1]='z') and (c='ys') then  begin sum:=sum+1;search(x+1,y+1,'ys'); end;
        if (a[x,y]='i') and (a[x+1,y-1]='z') and (c='yx') then  begin sum:=sum+1;search(x+1,y-1,'yx'); end;
        if (a[x,y]='i') and (a[x-1,y+1]='z') and (c='zs') then  begin sum:=sum+1;search(x-1,y+1,'zs'); end;
        if (a[x,y]='i') and (a[x-1,y-1]='z') and (c='zx') then  begin sum:=sum+1;search(x-1,y-1,'zx'); end;
        if (a[x,y]='z') and (a[x+1,y]='h') and (c='y') then  begin sum:=sum+1;search(x+1,y,'y'); end;
        if (a[x,y]='z') and (a[x,y+1]='h') and (c='s') then  begin sum:=sum+1;search(x,y+1,'s'); end;
        if (a[x,y]='z') and (a[x-1,y]='h') and (c='z') then  begin sum:=sum+1;search(x-1,y,'z'); end;
        if (a[x,y]='z') and (a[x,y-1]='h') and (c='x') then  begin sum:=sum+1;search(x,y-1,'x'); end;
        if (a[x,y]='z') and (a[x+1,y+1]='h') and (c='ys') then  begin sum:=sum+1;search(x+1,y+1,'ys'); end;
        if (a[x,y]='z') and (a[x+1,y-1]='h') and (c='yx') then  begin sum:=sum+1;search(x+1,y-1,'yx'); end;
        if (a[x,y]='z') and (a[x-1,y+1]='h') and (c='zs') then  begin sum:=sum+1;search(x-1,y+1,'zs'); end;
        if (a[x,y]='z') and (a[x-1,y-1]='h') and (c='zx') then  begin sum:=sum+1;search(x-1,y-1,'zx'); end;
        if (a[x,y]='h') and (a[x+1,y]='o') and (c='y') then  begin sum:=sum+1; search(x+1,y,'y'); end;
        if (a[x,y]='h') and (a[x,y+1]='o') and (c='s') then  begin sum:=sum+1; search(x,y+1,'s'); end;
        if (a[x,y]='h') and (a[x-1,y]='o') and (c='z') then  begin sum:=sum+1; search(x-1,y,'z'); end;
        if (a[x,y]='h') and (a[x,y-1]='o') and (c='x') then  begin sum:=sum+1; search(x,y-1,'x'); end;
        if (a[x,y]='h') and (a[x+1,y+1]='o') and (c='ys') then  begin sum:=sum+1; search(x+1,y+1,'ys'); end;
        if (a[x,y]='h') and (a[x+1,y-1]='o') and (c='yx') then  begin sum:=sum+1; search(x+1,y-1,'yx'); end;
        if (a[x,y]='h') and (a[x-1,y+1]='o') and (c='zs') then  begin sum:=sum+1; search(x-1,y+1,'zs'); end;
        if (a[x,y]='h') and (a[x-1,y-1]='o') and (c='zx') then  begin sum:=sum+1; search(x-1,y-1,'zx'); end;
        if (a[x,y]='o') and (a[x+1,y]='n') and (c='y') then  begin sum:=sum+1; search(x+1,y,'y');end;
        if (a[x,y]='o') and (a[x,y+1]='n') and (c='s') then  begin sum:=sum+1; search(x,y+1,'s');end;
        if (a[x,y]='o') and (a[x-1,y]='n') and (c='z') then  begin sum:=sum+1; search(x-1,y,'z');end;
        if (a[x,y]='o') and (a[x,y-1]='n') and (c='x') then  begin sum:=sum+1; search(x,y-1,'x');end;
        if (a[x,y]='o') and (a[x+1,y+1]='n') and (c='ys') then  begin sum:=sum+1; search(x+1,y+1,'ys');end;
        if (a[x,y]='o') and (a[x+1,y-1]='n') and (c='yx') then  begin sum:=sum+1; search(x+1,y-1,'yx');end;
        if (a[x,y]='o') and (a[x-1,y+1]='n') and (c='zs') then  begin sum:=sum+1; search(x-1,y+1,'zs');end;
        if (a[x,y]='o') and (a[x-1,y-1]='n') and (c='zx') then  begin sum:=sum+1; search(x-1,y-1,'zx');end;
        if (a[x,y]='n') and (a[x+1,y]='g') and (c='y') then  begin sum:=sum+1; search(x+1,y,'y');end;
        if (a[x,y]='n') and (a[x,y+1]='g') and (c='s') then  begin sum:=sum+1; search(x,y+1,'s');end;
        if (a[x,y]='n') and (a[x-1,y]='g') and (c='z') then  begin sum:=sum+1; search(x-1,y,'z');end;
        if (a[x,y]='n') and (a[x,y-1]='g') and (c='x') then  begin sum:=sum+1; search(x,y-1,'x');end;
        if (a[x,y]='n') and (a[x+1,y+1]='g') and (c='ys') then  begin sum:=sum+1; search(x+1,y+1,'ys');end;
        if (a[x,y]='n') and (a[x+1,y-1]='g') and (c='yx') then  begin sum:=sum+1; search(x+1,y-1,'yx');end;
        if (a[x,y]='n') and (a[x-1,y+1]='g') and (c='zs') then  begin sum:=sum+1; search(x-1,y+1,'zs');end;
        if (a[x,y]='n') and (a[x-1,y-1]='g') and (c='zx') then  begin sum:=sum+1; search(x-1,y-1,'zx');end;
        if a[x,y]='g' then begin  sum:=sum+1; b[x,y]:=true; exit; b[x,y]:=true; end;
        if sum>=7 then b[x,y]:=true;//如果构成了yizhong字串就回溯
    end;
    begin
        readln(n);
        for i:=1 to n do
                begin
                for j:=1 to n do
                    read(a[i,j]);
                        readln;
                end;//读入
        for i:=1 to n do
        for j:=1 to n do
            begin
            sum:=0;//开始搜索前要将计数器清零（一定要清零！！）
            if a[i,j]='y' then search(i,j,'s');//上方
            sum:=0;
            if a[i,j]='y' then search(i,j,'x');//下方
            sum:=0;
            if a[i,j]='y' then search(i,j,'z');//左方
            sum:=0;
            if a[i,j]='y' then search(i,j,'y');//右方
            sum:=0;
            if a[i,j]='y' then search(i,j,'zs');//左上方
            sum:=0;
            if a[i,j]='y' then search(i,j,'zx');//左下方
            sum:=0;
            if a[i,j]='y' then search(i,j,'ys');//右上方
            sum:=0;
            if a[i,j]='y' then search(i,j,'yx');//右下方
            end;
        for i:=1 to n do
        begin
            for j:=1 to n do
                if b[i,j] then write(a[i,j])
                    else write('*');
                        writeln;
        end;
    end.
//打了一个上午终于过了...（泪目）
```

---

## 作者：bobble (赞：0)

【题解区似乎没人用这方法，虽然不是最优。。不过憋了一个多小时没看题解，苦苦debug后终于AC的这感觉。。。

首先在看到这东西时，根本不觉得是DFS【QAQ】，后来想尽方法把它和DFS扯上关系，终于得出了一个奇葩的方法：

.    因为yizhong里每个字母都是独一无二的，所以

.           可以将他们与1，2，3，4，5，6，7一一对应，

.                   即：   1---y,    2---i,    3---z,    4---h,    5---o,   6---n,   7---g



//注：以下说到的层，是指搜索树的每一层【就是DFS里面的深度】

1.      以每行一个string的形式读入数据并转存该方阵到二维布尔数组，

.        将每一个在‘yizhong’里面的字母的坐标分别存在rx和ry，count[i]为该字母的个数；

2.     一层层try，找每一层即找‘yizhong’里的每一个字母（第一层找y,第二层找i,第三层找z……）

.       怎么找呢？ 这时就要用的rx和ry啦  如果对应的坐标能够通过检查，就找下一层（当深度小于7时）

.                 关于这里的检查：  用到一个过程checkfirst和一个函数check，

.                      因为如果找到yi，那么就大致确定了这个yizhong的方向，checkfirst就是这个功能而且顺带判断可不可用

.                     check呢，就是判断这个字母是不是在和前面的在同一直线，且相邻

.      这样找的话，

.     如果能找到第七层（yizhong长7）就说明找到了一个‘yizhong’，

.                    此时就调用chuli过程进行处理(即把ju数组里面的相应位置标记用于输出时判断)

3.输出时，如果ju数组中的元素为false【说明是yizhong的一部分】就输出它本身，否则输出\*




//代码--------------------------------------------------------------------------






```cpp
program dancifangzhen;
//-----------------------------------------------------------------
const
    //  1---y,    2---i,    3---z,    4---h,    5---o,   6---n,   7---g
    bian:array['g'..'z'] of integer=(7,4,2,0,0,0,0,6,5,0,0,0,0,0,0,0,0,0,1,3);
//-----------------------------------------------------------------
var
   n,i,j,lx,ly,pull:longint;
   t:char;
   count:array[1..7] of integer;
   rx,ry:array[1..7,1..10000] of integer;
   ju:array[1..100,1..100] of boolean;
   ans:array[1..7,1..2] of integer;
   inin:set of char;
   inp:array[1..100,1..100] of char;
   st:string;
//-----------------------------------------------------------------
procedure chuli;
var
   z:longint;
begin
   for z:=1 to 7 do
     ju[ans[z,1],ans[z,2]]:=false;          //对应的标记为false
end;
//-----------------------------------------------------------------
procedure checkfirst(a,b:longint);
begin
    pull:=0;
    if (a-lx<-1) or (a-lx>1) then exit;    //不在其上一行，下一行或同一行
    if (b-ly<-1) or (b-ly>1) then exit;    //不在其左一列，有一列或同一列
    if (lx=a) then pull:=1;//1表示在同一行
    if (ly=b) then pull:=2;//2表示在同一列
    if (lx+ly=a+b) then pull:=3;//3表示在同一 ‘/’ 斜线
    if (ly-lx=b-a) then pull:=4;//4表示在同一 ‘\ ’斜线
end;
//-----------------------------------------------------------------
function check(a,b:longint):boolean;
begin
    if (a-lx<-1) or (a-lx>1) then exit(false);   //不在其上一行，下一行或同一行
    if (b-ly<-1) or (b-ly>1) then exit(false);   //不在其左一列，有一列或同一列
    if pull=1 then if a<>lx then exit(false);//1----行
    if pull=2 then if b<>ly then exit(false);//2----列 
    if pull=3 then if lx+ly<>a+b then exit(false);//3---- ‘/’ 斜线
    if pull=4 then if ly-lx<>b-a then exit(false);//4---- ‘\’ 斜线
    exit(true);
end;
//-----------------------------------------------------------------
procedure try(d:longint);
var
  i,x,y:longint;
begin
   for i:= 1 to count[d] do
   begin
     x:=rx[d,i];
     y:=ry[d,i];
     if d<>1 then begin                              //第一个没有前一个字母
                     lx:=ans[d-1,1];  
             ly:=ans[d-1,2];  //记录前一个字母
                  end;
     if d=2 then begin
                   checkfirst(x,y);//第二次才开始要判断
                   if pull=0 then continue;
           //pull等于0时表示它不在上一个的任意一条对角线或横纵线上
                 end;
     if (d>2) and (check(x,y)=false) then continue;  //没通过检查
     ans[d,1]:=x;   ans[d,2]:=y;                     //记录
     if d<7 then try(d+1)                            //还没找完一个继续try
        else chuli;                                  //找完一个就处理
   end;
end;
//-----------------------------------------------------------------
begin
   inin:=['y','i','z','h','o','n','g'];            //‘yizhong’集合
   fillchar(ju,sizeof(ju),true);
   readln(n);
   for i:= 1 to n do
     begin
       readln(st);                           //字符串读入比较好，字符很容易出错
       for j:= 1 to length(st) do
       begin
          inp[i,j]:=st[j];
          t:=st[j];
          if t in inin then begin
                                inc(count[bian[t]]);
                                rx[bian[t],count[bian[t]]]:=i;
                                ry[bian[t],count[bian[t]]]:=j;
                            end;
       end;
     end;
   try(1);
   for i:= 1 to n do
   begin
     for j:= 1 to n do                         //输出过程
      if ju[i,j] then write('*')
        else write(inp[i,j]);
     writeln;
   end;
end.
//99行代码满满的是泪。。。
[acac](http://www.cnblogs.com/tonylim/p/5929503.html "小小传送门")
```

---

## 作者：hz1624917200 (赞：0)

看了楼下大神的题解，我好像有一个优化

由于需要搜索的字符串中开头‘y'只出现了一次，所有的搜索都是从此开始的

所以，可以用一个数组y来存储矩阵中所有’y‘的位置（这里我用了记录类型）

然后从每个点开始向八个方向单向搜字符串，（我用递归check函数）并将它标注

下附蒟蒻代码：

[codep]




```cpp
program p1101;
const
  dir:array[1..8,1..2] of longint=((0,1),(0,-1),(1,0),(-1,0),(-1,1),(-1,-1),(1,1),(1,-1));
  s:string='yizhong';
type
  point=record
    x,y:longint;
  end;
var
  y:array[1..10050] of point;
  map:array[0..105,0..105] of char;
  flag:array[0..105,0..105] of boolean;
  n,i,j,cnt:longint;
function check(now:point;d,ind:longint):boolean;
begin
  if ind>length(s) then exit(True);
  if (now.x>=1) and (now.x<=n) and (now.y>=1) and (now.y<=n) and (map[now.x,now.y]=s[ind]) then
    begin
      inc(now.x,dir[d,1]);
      inc(now.y,dir[d,2]);
      exit(check(now,d,ind+1));
    end;
  exit(False);
end;
procedure search(p:point);
var
  i,j,x,y:longint;
begin
  for i:=1 to n do
    if check(p,i,1) then
      begin
        x:=p.x; y:=p.y;
        for j:=1 to 7 do
          begin
            flag[x,y]:=True;
            inc(x,dir[i,1]);
            inc(y,dir[i,2]);
          end;
      end;
end;
begin
  fillchar(flag,sizeof(flag),False);
  readln(n);
  cnt:=0;
  for i:=1 to n do
    begin
      for j:=1 to n do
        begin
          read(map[i,j]);
          if map[i,j]='y' then
            begin
              inc(cnt);
              y[cnt].x:=i;
              y[cnt].y:=j;
            end;
        end;
      readln;
    end;
  for i:=1 to cnt do
    search(y[i]);
  for i:=1 to n do
    begin
      for j:=1 to n do
        if flag[i,j] then
          write(map[i,j])
        else
          write('*');
      writeln;
    end;
end.
[/codep]
```

---

## 作者：肥婆纳妾 (赞：0)


### 这道题 我是 用 map实现的 
#### 具体步骤如下：
- ####  首先定义结构为：map<pair<int,int>,string>[4]
##### key(pair<int,int>):对应为：坐标
##### value(string):对应的 该坐标的各个方向的 所练成的字符串
##### 这里的数组【4】表示一个坐标四个方向(上、左、右上、左上)的所对应的字符串 
- #### 在数据输入的时候 ，去判断该字符是否为 ‘y’、'g'（分别对应yizhong 的首位 和最后一位 ），若条件成立 ，将数据 压入map中
	##### 最后在遍历一遍 map中的数据，得到相等的str，就记录坐标
    #### 最后将记录 过坐标的值打印即可
	```cpp
#include<bits/stdc++.h>
using namespace std;
#define OBJ_STR "yizhong"
#define OBJ_STR_REVERSE "gnohziy"
bool isShow[101][101];
int main()
{
    map<pair<int, int>, string>data[4];
    int dir[4][2] = { { 0,-1 },{ -1,0 },{ 1,1 },{ -1,-1 } };  //上 、左 、右上 、左上
    char wordTable[101][101] = { 0 };
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) {
            cin >> wordTable[i][j];
            if (wordTable[i][j] == 'y' || wordTable[i][j] == 'g')
                for (int k = 0; k < 4; data[k++][pair<int, int>(j, i)].push_back(wordTable[i][j]));
            for (int k = 0; k < 4; ++k) {
                if (!data[k][pair<int, int>(j + dir[k][0], i + dir[k][1])].empty()) {
                    data[k][pair<int, int>(j, i)] = data[k][pair<int, int>(j + dir[k][0], i + dir[k][1])];
                    data[k][pair<int, int>(j, i)].push_back(wordTable[i][j]);
                }
            }
        }
    for (int i = 0; i < 4; ++i)
        for (auto itor = data[i].begin(); itor != data[i].end(); ++itor) {
            if (itor->second.empty()||itor->second.size()<7)continue;
            if (itor->second.substr(itor->second.size()- 7) == OBJ_STR || itor->second.substr(itor->second.size()- 7) == OBJ_STR_REVERSE)
                for (int x = itor->first.first, y = itor->first.second, j = 0; j < 7; ++j, isShow[y][x] = 1, x += dir[i][0], y += dir[i][1]);
        }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; printf("%c",(isShow[i][j]==true)?wordTable[i][j]:'*'), j++);
        cout << endl;
    }
    return 0;
}
```

---


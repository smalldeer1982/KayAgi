# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# 题解

## 作者：kevin_y (赞：82)

暴力加贪心，n方的复杂度肯定能水过此题

从第1-n个枚举，若高度小于它，左右两端都可包住它的左端点（右端点）就记录到sum里，sum取最大高度

```cpp
#include<iostream>
using namespace std;
int n,a[1001],b[1001],c[1001];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++){
		int sum1=0,sum2=0;
		for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])if(a[sum1]<a[j])sum1=j;//左边下落
		cout<<sum1<<" ";
		for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<c[i]&&c[j]>c[i])if(a[sum2]<a[j])sum2=j;//右边下落
		cout<<sum2<<endl;
	}
}
```


---

## 作者：MCH_Satrimiten (赞：14)

其实这道题只是复杂而已  
--
我们可以先画一个图
***
		 __1___
   	    __2__    ____3____
*** 
这时，如果球要从1的左沿掉下，那么只要判断2的左沿是否小于等于1的左沿，2的右沿是否大于等于1的左沿，如果是，直接输出。  
判断1的右沿则同理，只不过反了而已。  
外加两层循环，就得了以下AC代码：  
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1111],b[1111],c[1111];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i]>>c[i];
    for(int i=1;i<=n;i++)
    {
    	int t=0,s=0;
        for(int j=1;j<=n;j++)
            if(a[i]>a[j]&&b[i]>b[j]&&b[i]<c[j])
                if(a[t]<a[j])
                    t=j;
        cout<<t<<" ";
        for(int j=1;j<=n;j++)
            if(a[i]>a[j]&&c[i]>b[j]&&c[i]<c[j])
                if(a[s]<a[j])
                    s=j;
        cout<<s<<endl;
    }
    return 0;
}
```


---

## 作者：CeLaMbDa (赞：8)

奇怪的题目，明明说好的没有重叠的
写了一下只有50分，折腾了半天，看了题解才知道会出现重叠的....

代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;

struct Tabel { //用来存储每个平台信息的struct
	int id, H, L, R; //id时编号，H, L, R分别为高度、左端点、右端点
	int ansL, ansR; //用来存储答案，分别为左端点第一个触碰到的、
									//右端点第一个触碰到的
};

inline bool pd(Tabel a, Tabel b) { //在sort排序时使用的pd函数
	if (a.H == b.H) { //假如高度相同(重复的)就使用编号排序
		if(a.id > b.id) {
			return false;
		} else {
			return true;
		}
	}
	return a.H > b.H; //当高度不相同时，采用高度排序
}

inline bool pd2(Tabel a, Tabel b) { //用于排序的pd2函数
	if(a.id > b.id) { //按照id排序
		return false;
	}
	return true;
}

int main(int argc, char** args) {
	int n = 0;
	struct Tabel t[1005];
	memset(t, 0, sizeof(t)); //将t全部初始化为0
	scanf("%d", &n);
	for(int i = 0;i < n;i++) {
		scanf("%d %d %d", &t[i].H, &t[i].L, &t[i].R);
		t[i].id = i + 1; //设置每一个平台的id，因为是从1开始的，所以加一
	}
	sort(t, t + n, pd); //按照高度或id排序
	for(int i = 0;i < n;i++) { //判断左端点的触碰，求出答案之一
		t[i].ansL = 0;
		for(int j = i;j < n;j++) {
			if(t[i].L > t[j].L && t[i].L < t[j].R) { //当左端点在某个平台内时(不包括两端)
				t[i].ansL = t[j].id; //记录触碰平台的id
				break; //这里只求第一个触碰到的，所以break
			}
		}
	}
	for(int i = 0;i < n;i++) { //判断右端点的触碰，求出答案，以下同上
		t[i].ansR = 0;
		for(int j = i;j < n;j++) {
			if(t[i].R < t[j].R && t[i].R > t[j].L) {
				t[i].ansR = t[j].id;
				break;
			}
		}
	}
	//这里将序列恢复成原来的样子是应为要按照id的顺序输出
	sort(t, t + n, pd2); //最终将序列恢复成原来的样子
	for(int i = 0;i < n;i++) {
		printf("%d %d\n", t[i].ansL, t[i].ansR); //输出
	} 
}

//AC
```

---

## 作者：Drifterming (赞：8)

```
//记录一下每个平台的高度，左右端点和id
//然后判一下会不会相交就可以了
//按高度排好序之后高度就没用了，就变成了线段是否重叠的问题

//然而其实平板是会重叠的，所以在sort里把id按最小取就行了 

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1005;

int n;
int L[N],R[N];
struct PT
{
	int id,l,r,h;
	bool operator < (const PT &a) const		//按高度降序排，有一样高的按id升序排 
	{
		return h==a.h?id<a.id:h>a.h;
	}
}pt[N];

inline int read()
{
	char c=getchar();int num=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		pt[i].id=i;
		pt[i].h=read(),pt[i].l=read(),pt[i].r=read();
	}
	sort(pt+1,pt+n+1);
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(pt[j].l<pt[i].l&&pt[j].r>pt[i].l)	//左端点 
			{
				L[pt[i].id]=pt[j].id;
				break;
			}
		}
		for(int j=i+1;j<=n;++j)
		{
			if(pt[j].l<pt[i].r&&pt[j].r>pt[i].r)	//右端点 
			{
				R[pt[i].id]=pt[j].id;
				break;
			}
		}
	}
	for(int i=1;i<=n;++i)	//print ans
		printf("%d %d\n",L[i],R[i]);
	return 0;
}
```

---

## 作者：Ufowoqqqo (赞：8)

用O(n^2)的模拟，完全可以不必排序。那么主要思想和@野菜汤 说的差不多了，就是有个地方：其实答案可以不用数组存。

```delphi

var
 n,i,j,max1,max2,ans1,ans2:longint;
 h,l,r:array [1..1000] of longint;
begin
 readln(n);
 for i:=1 to n do readln(h[i],l[i],r[i]);
 for i:=1 to n do
 begin
  for j:=1 to n do
  begin
   if (i<>j){自已总不能掉到自己身上吧} and (h[i]>h[j]){目标平台肯定低于原平台，难不成飞上去么？} and (h[j]>max1){在所有满足条件的平台中找最高的} and (l[i]>l[j]){目标平台要比原平台更靠左} and (l[i]<r[j]){目标平台的右端点要比原平台的左端点靠右，不然就接不住了} then
    begin
     max1:=h[j];
     ans1:=j;
    end;
   if (i<>j) and (h[i]>h[j]) and (h[j]>max2) and (r[i]<r[j]) and (r[i]>l[j]) then//同理
    begin
     max2:=h[j];
     ans2:=j;
    end;
  end;
  writeln(ans1,' ',ans2);
  max1:=0;
  max2:=0;
  ans1:=0;
  ans2:=0;
 end;
end.

```

---

## 作者：野菜汤 (赞：5)

题解：

此题还算是稍有难度的，但也并没有难到哪里去，其实只需要多加思考，运用程序进行模拟既可以通过。以下标程，仅供参考。

```delphi
var h,l,r,l1,r1:array[1..6000] of longint;
    i,j,k,a,b,c,n,m:longint;
begin
  readln(n);
  for i:= 1 to n do
  readln(h[i],l[i],r[i]);
  for i:=1 to n do{有多少个平台模拟多少次}
  begin
  a:=-1;
  b:=-1;
    for j:=1 to n do{对于第i个平台，搜索其他所有平台，看看会落到哪一个上}
    begin
      if i<>j then begin{如果i与j不是同一个平台，那么就判断}
        if (h[i]>h[j])and(l[i]>l[j])and(l[i]<r[j])and(h[j]>a) then begin
          l1[i]:=j;a:=h[j];end;{对于左边缘的判断，如果回落到其上方，那么就记录j平台的序号也就是第j个，然后将a作为标准}
        if (h[i]>h[j])and(r[i]>l[j])and(r[i]<r[j])and(h[j]>b) then begin
          r1[i]:=j;b:=h[j]; end;{对于右边缘的判断，效果与上同}
      end;
    end;
  end;
    for i:=1 to n do begin
    write(l1[i],' ',r1[i]);writeln;end;
end.
```
那么最后在解释一下两个判断句的内容，这才是此题解题的关键，就拿左边缘的判断句来解释：首先，i要高于j确保能掉下去，然后的两个判断是i的左边要超过j的左边并且不超过j的右边，以确保左边缘能掉到j上，最后是这个j要比上一个符合要求的j要高，因为是要找最高的嘛。

那么此题已经详细的解析了，请同学们好好参考，相信会对你有所帮助。


---

## 作者：Ofnoname (赞：4)

其实我没搞懂为什么要排序，反正排完序还是$O(n^2)$的。

对于每一个平台，我们扫描所有的平台，看它的范围是否包括了左端点（右端点），并且高度低于当前高度。所有符合条件的都是备选答案，找到最高并且编号最小的即可。

```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)

int N, h[MAX], l[MAX], r[MAX], ans[2][MAX];

int main()
{
	scanf("%d", &N);
	for (int i = 1; i <= N; i++)
		scanf("%d%d%d", &h[i], &l[i], &r[i]);
	for (int i = 1; i <= N; i++)
	{
		int H1 = 0, H2 = 0;
		for (int j = 1; j <= N; j++)
		{
			if (H1 < h[j] && h[j] < h[i] && l[j] < l[i] && l[i] < r[j])
				ans[0][i] = j, H1 = h[j];
			if (H2 < h[j] && h[j] < h[i] && l[j] < r[i] && r[i] < r[j])
				ans[1][i] = j, H2 = h[j];
		}printf("%d %d\n", ans[0][i], ans[1][i]);
	}
}
```

---

## 作者：autoencoder (赞：4)

这个题目从思路上讲没有什么难度，唯一比较坑的在于如果有两个平台的高度相同且都可以被落到的话，那么会落到编号考前的那个平台。
时间复杂度：O(n^2)
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int N;
struct Platform {
    int H, L, R, k;
} platforms[1001];
int ans_L[1001] = {0}, ans_R[1001] = {0};

bool comp(const Platform &a, const Platform &b){return a.H < b.H;}

int main() {
    
    cin >> N;
    for (int i = 0; i < N; i++) {
        cin >> platforms[i].H >> platforms[i].L >> platforms[i].R;
        platforms[i].k = i + 1;
    }
    /*
    我们希望经过我们对数组的处理之后，最后一个被找到的元素
    就是我们所希望的平台。为了实现这一点，我们首先要将原数
    组逆序，然后使用稳定排序。稳定排序可以保存相同元素之间
    的相对顺序，那么经我们逆序之后，高度相同的平台之间，序
    号小的会被排在后面。由此，当我们顺序从前向后查找的时候
    找到的最后一个满足条件的平台就是我们需要的平台。
    */
    reverse(platforms, platforms + N);
    stable_sort(platforms, platforms + N, comp);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < i; j++) {
            if (platforms[j].L < platforms[i].L && platforms[j].R > platforms[i].L) {
                ans_L[platforms[i].k - 1] = platforms[j].k;
            }
            if (platforms[j].L < platforms[i].R && platforms[j].R > platforms[i].R) {
                ans_R[platforms[i].k - 1] = platforms[j].k;
            }
        }
    }
    for (int i = 0; i < N; i++) {
        cout << ans_L[i] << " " << ans_R[i] << endl;
    }
}

```

---

## 作者：深海鱼的眼泪 (赞：4)

不是说好了不重叠吗？害我用正经排序写WA了两次。高度相同时编号小的优先。下面奉上代码。虽然长了点，但基本就是排序。



```cpp
#include <iostream>
using namespace std;
int n,h[10010],ni[10010],l[10010],r[10010],a[10010],b[10010];
void qs(int li,int ri){             //快排
    int i,j,mid,t,mid1;
    i=li;
    j=ri;
    mid1=(li+ri)/2;
    mid=h[(li+ri)/2];
    do{
        while ((h[i]<mid)||(h[i]==mid&&ni[i]>ni[mid1]))i++;                //高度相同编号小的优先，因为是从后往前找所以>
        while ((h[j]>mid)||(h[j]==mid&&ni[j]<ni[mid1]))j--;
        if (i<=j){
            t=h[i];
            h[i]=h[j];
            h[j]=t;
            t=ni[i];
            ni[i]=ni[j];
            ni[j]=t;
            t=l[i];
            l[i]=l[j];
            l[j]=t;
            t=r[i];
            r[i]=r[j];
            r[j]=t;
            i++;
            j--;
        }
    }while (i<j);
    if (i<ri)qs(i,ri);
    if (j>li)qs(li,j);
    return;
}
int main(){
    int i,j;
    bool x=false;
    cin>>n;
    for (i=1;i<=n;i++){
        cin>>h[i]>>l[i]>>r[i];
        ni[i]=i;
    }
    qs(1,n);
    for (i=1;i<=n;i++){
        x=false;
        for (j=i-1;j>=1;j--){                      //从下面一个平台开始找
            if (l[j]<l[i]&&r[j]>l[i]){
                a[ni[i]]=ni[j];
                x=true;
                break;
            }
        }
        if (!x)a[ni[i]]=0;                 //如果没找到就赋值为0
        x=false;
        for (j=i-1;j>=1;j--){
            if (l[j]<r[i]&&r[j]>r[i]){
                b[ni[i]]=ni[j];
                x=true;
                break;
            }
        }
        if (!x)b[ni[i]]=0;
    }
    for (i=1;i<=n;i++){
        cout<<a[i]<<' '<<b[i]<<endl;
    }
    return 0;
}
```

---

## 作者：我醉了 (赞：4)

我本来是顺着**搜索**的标签来的，，， 但这道题不用搜索也可以

### 献上代码
（本蒟蒻刚学不久，**大佬**们不要喷本**蒟蒻** ） 

（哪里有改进的地方可以和我说声）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm> 
using namespace std;
struct  infor{        //我直接用了结构体
	int xu;           //xu是原序号，因为后面要排序，所以我保存了一下
	int h;           //高度
	int l;		   //左面坐标
	int r;          //右面坐标
	int ll;         
	int rr;         //这两个变量是储存最终结果的
}a[10000];           
int n;
int cmp(infor x,infor y)
{
	return (x.h>y.h)||(x.h==y.h&&x.xu<y.xu);   //因为考虑到会重叠，所以高度相同的地方把序号从小到大排（我也不知道为什么要这样，但它就对了）
}
int dmp(infor x,infor y)
{
	return x.xu<y.xu;//最后要按原来的序号输出，所以我又排回去了
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		a[i].xu=i;
		cin>>a[i].h>>a[i].l>>a[i].r;
		a[i].ll=0;
		a[i].rr=0;
	}
	sort(a+1,a+n+1,cmp);//sort排序
	for(int i=1;i<=n;i++)
	{
			for(int j=i+1;j<=n;j++)
			{
				if(a[i].l>a[j].l&&a[i].l<a[j].r)
				{a[i].ll=a[j].xu;break;}				
			}		
			for(int j=i+1;j<=n;j++)
				if(a[i].r>a[j].l&&a[i].r<a[j].r)
				{a[i].rr=a[j].xu;break;}
	}
	sort(a+1,a+n+1,dmp);//最后再排回去
	for(int i=1;i<=n;i++)
	cout<<a[i].ll<<" "<<a[i].rr<<endl;
	return 0;
}
```

---

## 作者：蹦极僵尸 (赞：2)

#这是我接管@蹦极僵尸之后的第一次发表题解，请重视，谢谢。

这道题可以说是一道经典的排序题目（也许不要排序囧），可以先用归并排序，按高度

排一个降序，O（nlog2 n）再用一次O（n^2）的搜索，对于每次的平台，从当前编号往

后搜，找到一个可以落下的平台，结束循环，将答案存在一个ans数组里，以之前

存下的以平台编号为下标的num数组为ans数组的下标，逐个往后，直到i>n为止。

最后从1到n输出ans\_l和ans\_r(左右侧滚下的平台编号）。

附上程序（第一次不小心排成了升序，只得二十分，以下为正版）。

```delphi

var n,i,j:longint;
    ans_l,ans_r,tmp_l,tmp_r,tmp_h,tmp_n,num,high,left,right:array [0..1000] of longint;
procedure hb(l,mid,r:longint);
var tt,tr,tl:longint;
begin
  tt:=l;tl:=l;tr:=mid+1;
  while tt<=r do begin
    if (tl<=mid)and((tr>r)or(high[tl]>=high[tr])) then begin
      tmp_h[tt]:=high[tl];
      tmp_l[tt]:=left[tl];
      tmp_r[tt]:=right[tl];
      tmp_n[tt]:=num[tl];
      inc(tl);inc(tt);
    end
    else begin
      tmp_h[tt]:=high[tr];
      tmp_l[tt]:=left[tr];
      tmp_r[tt]:=right[tr];
      tmp_n[tt]:=num[tr];
      inc(tr);inc(tt);
    end;
  end;
  for i:=l to r do begin
    high[i]:=tmp_h[i];
    left[i]:=tmp_l[i];
    right[i]:=tmp_r[i];
    num[i]:=tmp_n[i];
  end;
end;

procedure gp(l,r:longint);
var mid:longint;
begin
  if l<>r then begin
    mid:=(l+r) div 2;
    gp(l,mid);gp(mid+1,r);
    hb(l,mid,r);
  end;
end;

begin
  read(n);
  for i:=1 to n do begin
    read(high[i],left[i],right[i]);
    num[i]:=i;
  end;
  gp(1,n);
  for i:=1 to n do begin
    for j:=i+1 to n do
      if (left[j]<left[i])and(right[j]>left[i]) then begin      ans_l[num[i]]:=num[j];break;end;
    for j:=i+1 to n do
      if (left[j]<right[i])and(right[j]>right[i]) then begin ans_r[num[i]]:=num[j];break;end;
  end;
  for i:=1 to n do writeln(ans_l[i],' ',ans_r[i]);
end.

```

---

## 作者：2015C林铮翔 (赞：1)

以下代码是刚开始时的思路。从1号平台开始，往下找。找到符合的条件就输出

```cpp

#include<iostream>
#include<algorithm>
using namespace std;  
struct pt{
    long long h;//高度 
    long long l;//左端点 
    long long r;//右端点
    long long m;//序号 
    long long la;//从第i个平台的左边缘落下后到达的平台序号
    long long ra;//从第i个平台的右边缘落下后到达的平台序号。
}a[1000001];
int comp(const pt &a,const pt &b)
{
    if(a.h>b.h) return 0;
    if(a.h<b.h) return 1;
    return 0;
}
long long n,i,j; 
int main()  
{  
    cin>>n;
    for(i=1;i<=n;i++)
    {cin>>a[i].h>>a[i].l>>a[i].r;a[i].m=i;}
    sort(a+1,a+n+1,comp);
    for(int k=1;k<=n;k++)
    {
        for(int l=1;l<=n;l++)
        {
            if(a[l].m==k) i=a[l].h;
        }//寻找第k行的序号 
        if(a[i].h!=1)
        {
            for(j=a[i].h-1;j>=1;j--)
            {
                if(a[i].l>a[j].l&&a[i].l<a[j].r) //比较：j的右端点>i的左端点>j的右端点 
                {
                    a[i].la=a[j].m;
                    break;//已找到就停止 
                } 
                if(j-1==0) a[i].la=0;//如果已经是最后一行并且还没有找到符合的，赋值为0 
            }
            for(j=a[i].h-1;j>=1;j--)
            {
                if(a[i].r>a[j].l&&a[i].r<a[j].r) //同上 
                {
                    a[i].ra=a[j].m;
                    break;
                } 
                if(j-1==0) a[i].ra=0;
            }
        }
        else a[i].la=a[i].ra=0;
        cout<<a[i].la<<' '<<a[i].ra<<endl;
    }
    return 0; 
}
```cpp

有不懂思路的地方看注释，但上面代码不过，只有20分（我也不知道为什么）

如果你看得懂思路并且重新改正，就能100分


下面的代码是我换了个思路写的。原来是从上往下找，现在是吧所有的都找出来并找出离目标最近的那个答案


上代码

```cpp

#include<iostream>
#include<algorithm>
using namespace std;  
struct pt{
    long long h;//高度 
    long long l;//左端点 
    long long r;//右端点
    long long m;//序号 
    long long la;//从第i个平台的左边缘落下后到达的平台序号
    long long ra;//从第i个平台的右边缘落下后到达的平台序号。
}a[1000001];
long long n,i,j,x=-1234567890,y=-1234567890; 
int main()  
{  
    cin>>n;
    for(i=1;i<=n;i++)
    {cin>>a[i].h>>a[i].l>>a[i].r;a[i].m=i;}
    for(i=1;i<=n;i++)  
    {  
        x=-1234567890,y=-1234567890; //纯粹无聊。。。 
        for(j=1;j<=n;j++)  
        {  
            if(i!=j)  
            {  
                if(a[i].h>a[j].h&&a[i].l>a[j].l&&a[i].l<a[j].r&&a[j].h>x)//判定1、i比j高（这废话）
                //2、j的右端点>i的左端点>j的右端点   3、通过变量x寻找离i最近的平台 
                {  
                    a[i].la=j;  
                    x=a[j].h;  
                }  
                if(a[i].h>a[j].h&&a[i].r<a[j].r&&a[i].r>a[j].l&&a[j].h>y)  
                {  
                    a[i].ra=j;  
                    y=a[j].h;  
                }  
            }  
        }  
    }
    for(i=1;i<=n;i++) 
    {
        cout<<a[i].la<<" "<<a[i].ra<<endl;
    }
    return 0; 
}

```
(话说为什么和楼下的有点像？！！）

这题有点坑爹的地方时数据很大，把结构体数组定义得多一些就AC了


---

## 作者：JamlainHamstone (赞：1)

首先，先阐明一下我的思路：

1.先创建每个平台信息的结构体，并按照高度按照降序排序（这样可以更快速的找到离此平台在高度上最近的平台，可以节省时间）

2.分别找到从左边掉下的答案和右边掉下的答案，满足其的条件分别是左边坐标小于此平台左边坐标&&右平台大于此平台左边坐标  和  左边坐标小于此平台右边坐标&&右平台大于此平台右边坐标

3.一旦找到就储存并break

4.按编号输出

于是得到的代码就是这样的：
```
#include<bits/stdc++.h>
using namespace std;
struct node{//结构体储存平台信息
	int h,l,r,id;
}s[1010];
struct ans{//结构体储存左边和右边答案信息
	int lans=0,rans=0;//初始化为0，当没有找到是就默认为0
}ans[1010];
bool cmp(node a,node b){
	return a.h>b.h;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){//输入并储存各种信息
		cin>>s[i].h>>s[i].l>>s[i].r;
		s[i].id=i;
	}
	sort(s+1,s+n+1,cmp);//从高到低排序
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){//左边答案
			if(s[j].l<s[i].l&&s[j].r>s[i].l){
				ans[s[i].id].lans=s[j].id;
				break;//找到就停止查找
			}
		}
		for(int j=i+1;j<=n;j++){//右边答案
			if(s[j].l<s[i].r&&s[j].r>s[i].r){
				ans[s[i].id].rans=s[j].id;
				break;//找到就停止查找
			}
		}
        //当没有找到是就是0
	}
    //输出
	for(int i=1;i<=n;i++) cout<<ans[i].lans<<' '<<ans[i].rans<<endl;
	return 0;
} 
```
## **但是**，
这样做只有50分。那是因为实际上平台是有重叠的情况的，而当重叠时，答案就是编号更小的那个平台。

所以最后一步的操作就是在给平台排序时，对于高度相同的平台进行由编号的从小到大的排序

只需要把排序改为如下：
```
bool cmp(node a,node b){
	if(a.h!=b.h) return a.h>b.h;
	return a.id<b.id;//编号小的优先
}
```

最后祝各位大佬们AC愉快~~~

---

## 作者：ysner (赞：1)

为什么楼下的题解都喜欢开二重循环去暴搜（数据再大点就过不了了）？

我的程序将二重循环进行一定剪枝，降低了程序复杂度（运算量），这种优化是以将各平台的高度排序（bug：有高度相同的平台，反正在高度相同时我将平台左端点从小到大排序，就能AC，否则只有50分）为前提的。

另外，此题能充分体现结构体的优势，此题必须将三个变量（高度、左端点、右端点）绑在一起（先排序还得绑上编号），用三个数组存大大增加代码长度。另外，没用结构体排序打冒泡费时费力，用结构体排序直接sort一步到位。

排完序后从高平台往低平台搜即可(两个端点都搜到就可跳出，再不是楼下题解的n\*n复杂度了）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int l[10000][2]={};//l[i][0]存小球从编号为i的平台左端点下落到的平台编号，l[i][1]存小球从编号为i的平台右端点下落到的平台编号
struct pt
{
  int g;//平台高度
  int z;//平台左端点
  int y;//平台右端点
  int w;//平台编号
}a[10000]={};
bool com(pt x,pt y)
{
  return (x.g>y.g)||(x.g==y.g&&x.z<y.z);//在高度相同时将平台左端点从小到大排序（100分与50分的距离）
}
int main()
{
  int i,j,k,n,f1,f2;
  cin>>n;
  for(i=0;i<n;i++)
  {
    cin>>a[i].g>>a[i].z>>a[i].y;
    a[i].w=i+1;//编号从1开始，因为小球落到地上编号为0，怕重复
  }
  sort(a,a+n,com);//按高度排序，com为排序规则
  for(i=0;i<n;i++)
  {
    f1=0;//判断左端点的球是否已落在平台上，因已排序，找到的第一个即为正确结果，找到就不找了
    f2=0;//判断右端点的球是否已落在平台上，因已排序，找到的第一个即为正确结果，找到就不找了
    for(j=i+1;j<n;j++)
    {
      if(a[i].z>a[j].z&&a[i].z<a[j].y&&f1==0) {l[a[i].w][0]=a[j].w;f1=1;}
      if(a[i].y>a[j].z&&a[i].y<a[j].y&&f2==0) {l[a[i].w][1]=a[j].w;f2=1;}
      if(f1==1&&f2==1) break;//一点小优化，找到就不找了
    }
  }
  for(i=1;i<=n;i++)
    cout<<l[i][0]<<" "<<l[i][1]<<endl;
  return 0;
}
```

---

## 作者：彭骐飞 (赞：0)

下面发一个pascal题解：

我当时做这题一看就想到了用标记，看了数据就呵呵了：模拟也能过！

下面是简单的思路：

- 读入；

- 定义数组l,r，l[i]保存从左边下落回落到第l[i]个平台上，r[i]是右边；

- 用变量i,j枚举任意两个不重复的平台；

- 判断，平台i的高度>平台j的高度，就看看j是否可以接住平台i左边或右边下落的物体，还要比已保存的平台l[i],r[i]高，反之则是判断i能不能接住平台j上的物体；

- 输出。

详见代码：

```cpp
var a:array[0..1000,0..3] of longint;                                                                  //一定要有0，因为l,r初始化为0，所以0的高度要最小
l,r:array[1..1000] of longint;
n,i,j:longint;
begin
    readln(n);
    fillchar(a,sizeof(a),0);
    fillchar(l,sizeof(l),0);
    fillchar(r,sizeof(r),0);                                                                                 //初始化
    for i:=1 to n do
    readln(a[i,3],a[i,1],a[i,2]);                                                                          //读入
    for i:=1 to n-1 do
        for j:=i+1 to n do                                                                            //枚举两个不同的点i,j
            begin
        if a[i,3]>a[j,3] then                                                                          //如果平台i高
            begin
        if (a[i,1]>a[j,1]) and (a[i,1]<a[j,2]) and (a[l[i],3]<a[j,3]) then l[i]:=j;   //接住平台i左边的物体要能覆盖a[i,1]，还比l[i]更优，才更新
        if (a[i,2]>a[j,1]) and (a[i,2]<a[j,2]) and (a[r[i],3]<a[j,3]) then r[i]:=j;  //接住平台i右边的物体要能覆盖a[i,2]，还比r[i]更优，才更新
            end;
        if a[i,3]<a[j,3] then                                                                          //如果平台j高
            begin
        if (a[i,1]<a[j,1]) and (a[i,2]>a[j,1]) and (a[l[j],3]<a[i,3]) then l[j]:=i;   //接住平台j左边的物体要能覆盖a[j,1]，还比l[j]更优，才更新
        if (a[i,1]<a[j,2]) and (a[i,2]>a[j,2]) and (a[r[j],3]<a[i,3]) then r[j]:=i;  //接住平台j右边的物体要能覆盖a[j,2]，还比r[j]更优，才更新
            end;
            end;
    for i:=1 to n do
    writeln(l[i],' ',r[i]);                                                                                     //输出
end.
···
如有问题需要修正请私信我，完善之后即可获得一封感谢的（私）信。
[问题投诉](https://www.luogu.org/space/show?uid=11358)。


---


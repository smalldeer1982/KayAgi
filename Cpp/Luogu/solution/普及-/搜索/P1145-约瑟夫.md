# 约瑟夫

## 题目描述

$n$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在第一个好人被杀死前，$k$ 个坏人先被杀死。


## 说明/提示

$0\lt k\lt 14$。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

## 样例 #2

### 输入

```
4```

### 输出

```
30```

# 题解

## 作者：doby (赞：164)

来自noip2004的召唤……

```cpp
#include<cstdio>
using namespace std;
int i,find,k,m,begin;
int check(int remain)
{
    int result=(begin+m-1)%remain;
    if(result>=k){//判断出列的那个人
        begin=result;
        return 1;
    }
    else{return 0;}
}
int main(){
    scanf("%ld",&k);
    m=k;
    while(!find)
     {
        find=1;begin=0;//设置第一个
        for(i=0;i<k;i++)
        {
            if(!check(2*k-i))//如果判断好，就可以退出了……
            {
                find=0;break;
            }
        }
        m++;
    }
    printf("%d",m-1);//多加了一个，减回去
    return 0;
}
```

---

## 作者：归来的圣主 (赞：159)

本文从doby得到的启发并进行了改进，特此声明感谢。个人认为堪称此题最精简的题解。
```c
#include <stdio.h>
int main()
{
    int k,i;
    while (scanf("%d",&k)!=EOF)//个人输入习惯，请忽略
    {
        int flag=1,m=k;
        while (flag)
        {
            m++;//m至少为k+1
            int cursor=0;//设置光标的移动
            for (i=0; i<k; i++)
            {
                cursor=(cursor+m-1)%(2*k-i);//下一次出列之人的编号
                if (cursor<k)break;//判断出列的那个人是否小于k，小于就进行下一个m的判断
                if (i==k-1)flag=0;//说明已经找到最小的m
            }
        }
        printf("%d\n",m);
    }
    return 0;
}
```

---

## 作者：夜枭只会舔fufu (赞：124)

da jia hao,wo lai fang song ti jie la la la!!

说人话！！QWQ

大家好，我来给你们发题解啦啦啦!!

（今天是我的生日，赠送一个模板在下面（队列））

```
#include<iostream>//头文件
using namespace std;//命名空间
int num[14]={0,2,7,5,30,169,441,1872,7632,1740,93313,459901,1358657,2504881};//打表
int n;//几个好人几个坏人
int main(){
    cin>>n;//输入n
    cout<<num[n]<<endl;//按表输出
    return 0;//完结撒花
}
```
——————————————————————<-队列时间到
```
#include<iostream>
#include<algorithm>
#include<string.h>
#include<cstring>
#include<string>
using namespace std;
int a[10001];
int t,w;
void clear()
{
	memset(a,0,sizeof(a));
}
bool empty()
{
	if(w==t)
	{
		return 1;
	}
	return 0;
}
int size()
{
	return w-t;
}
void push(int aa)
{
	a[++w]=aa;
}
void pop()
{
	t++;
}
int front_()
{
	return a[t++];
}
int main()
{
	
}
```
BYEBYE

O.O

---

## 作者：InternetExplorer (赞：41)

```
一道经典的题目。
我采用的是找规律法，具体的都在程序里了。
#include<bits/stdc++.h>
using namespace std;
int k,i,sum=0,num=0;
//sum代表被淘汰的人的个数，num代表被淘汰的人的位置
vector <int> a;
bool tle(int i,int sum,int num){
    if(sum==k) //当淘汰了k个人的时候
        return true;
    if(a[(num-1+i)%(2*k-sum)]==1)
        return false;
  /*这里讲一下：
  	比如说 k=3 答案是5,队列为
    1 1 1 0 0 0
    1 2 3 4 5 6
    （1是好人，0是坏人，下面的数字是位置）
    淘汰第一个人后，队列为
    1 1 1 0   0
    1 2 3 4   6
    		^（num的实际位置）
    这个位置是空的，我们只能先-1作为num的临时位置再加上i，
    相当于num退回了一个位置再走i步。
    2*k-sum表示总人数-淘汰过的人数
    */
    if(a[(num+i-1)%(2*k-sum)]==0){
        a.pop_back(); // 删除a的最后一个元素，因为坏人都是0，删除哪个都无所谓
        return tle(i,sum+1,(num+i-1)%(2*k-sum));
    }
}
int main(){
    ios::sync_with_stdio(false); // 快读
    cin >> k;
    for(i=1;i<=2*k;i++){
        if(i<=k)
            a.push_back(1);
        else
            a.push_back(0);
    }
    for(i=k+1;;i++){
        if(tle(i,0,0)){
            cout << i ;
            break;
        }
    }
    return 0;
}  // ps： 这是我的第一片题解，可能讲的不是很清楚，但还是希望管理员通过。
```

---

## 作者：SampleTest518 (赞：23)

分析：正解就是暴力.只要稍微优美那么一点点就能过了，最最最朴素的暴力就是枚举m，然后一位一位地挪，非常慢，正确的方法是直接取模，判断是不是坏人，每一个m最多走k次就会结束游戏，每次删除一个人后把起点变一下，模数变一下就好了.需要注意的一点是每个人的下标要从0开始，不然取模的时候可能会得到0，然后就炸了.
下面请看代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int k,m = 1,beginn = 1;
bool flag = false,flag2 = false;

bool check(int mod)
{
    int t = (beginn + m - 1) % mod;
    if (t >= k)
    {
        beginn = t;
        return true;
     } 
     return false;
}

int main()
{
    scanf("%d",&k);
    m = k;
    while (1)
    {
        beginn = 0;
        flag2 = 0;
        for (int i = 0; i < k; i++)
        {
            if (!check(2 * k - i))
            {
                flag2 = 1;
                break;
            }
        }
        if (!flag2)
        break;
        m++;
    }
    printf("%d\n",m);
    
    return 0;
}
```
祝您AC愉快，切记：勿抄题解，小心屎名哦

---

## 作者：初音赛高 (赞：20)

暴力搜索就好了

由题意可以知道，k个好人在前，k个好人在后。

我们假设他们站成一排，好人编号1 - k，坏人编号k+1 - 2k

模拟，假设数到m杀一个,剩余n个人，从第i号人开始数数，下一个杀掉的是第i+m-1（i+m-1<n）个人。

到后面i+m-1可能会超过n，要回到开头数，所以杀掉的是(i+m-1-1)%n+1个人

只要杀的人的编号>k就不是好人

代码如下

```cpp
#include<ctime>
#include<complex>
#include<iomanip>
#include<bits/stdc++.h>
#include<string>
using namespace std;
int k;
void pwrite(int s){
    if(s<10){putchar(s+'0');return;}
    pwrite(s/10);
    putchar(s%10+'0');
}
void pread(int &k){
    k=0;
    char c=getchar();
    while(c>='0'&&c<='9'){
        k=k*10+c-'0';
        c=getchar();
    }
}
void kill(int s,int now,int p){
    if(p==0){
        pwrite(s);
        exit(0);
    }
//    printf("尝试%d 剩下%d个坏人 现在第%d人\n",s,p,now);
    now=(now+s-2)%(k+p)+1;
    if(now>k)kill(s,now,p-1);
}
int main(){
    pread(k);
    for(int i=k+1;;++i)kill(i,1,k);
    return 0;
}
```

---

## 作者：学无止境 (赞：19)

**Code:**


```cpp
#include<iostream>
#include<cstring> 
using namespace std;
int ans,k,k2;
bool a[30];//1~2*k是人的编号，这个数组存储死没死（真的好残暴） 
bool atry(int m)//判断函数，m不能满足题意就返回0，否则返回1 
{
    int u=0;//重置下标为0，第一个人数了后就是1了 
    memset(a,false,sizeof(a));//每次要先清零 
    for(int j=0;j<k;j++)// j=0;j<k 表示杀k个人，每次杀之前活着的有k-j人 
    {
        int n=m%(k2-j);//精髓一步，降低数据规模，但是我如果直接这样写：int n=m%(k2-j); n可能为0，就"happy"了，所以再特判一下
        if(k2-j<=m)  n+=k2-j;//避免为零，再转一圈 
        for(int j=1;j<=n;j++)
        {
            u++;
            while(a[u]==true)  u++;//u++后若不是活人就继续加，直到活人 
            if(u>k2)  u=1;//队尾回到1 
        }
        a[u]=true;//标记为已死 
        if(u<=k)  return false;//前k个中杀了好人，返回false 
    }
    return ans=m;//这是简写 ,因为成功赋值，所以返回true
}

int main()
{
    cin>>k,k2=k*2;//读入，k2表示总人数 
    for(int i=k+1;!atry(i);i++);//判断，返回值大于0说明找到了 
    cout<<ans;//输出 
    return 0;
}
 
 
```

---

## 作者：Mr_yang1 (赞：4)

# [P1145 约瑟夫](https://www.luogu.com.cn/problem/P1145)
题意已经明确，不过多阐述。

【前置知识：链表】

我们发现嘎人的操作类似链表的删除节点，所以这道题我们可以用枚举+链表来做。

## 思路：

- 首先是框架和链表结构体的创建，data用来记录是好人还是坏人。
```
#include<bits/stdc++.h>
using namespace std;
struct Node{
	bool data;
	Node *next;
};
int main(){
}
```
- 我们从 $k+1$ 开始枚举 $m$，能节约时间。为了不超时我们还可以在特判一下。
```
for(int m=k+1;;m++){//外层循环
  if(m%(k+k)<=k&&m%(k+k)!=0)continue;//一定会嘎到好人的情况
}
```
- 对于每一次枚举，都要先初始化。
```
Node *head=new Node,*tail=head;//创建头和尾
head->data=1;//标记头一定是好人
for(int i=2;i<=k+k;i++){//for循环生成链表
	Node *n=new Node;
	n->data=(i<=k),n->next=nullptr,tail->next=n,tail=n;//加入节点，更新尾
}
tail->next=head,tail=head;//完成一个循环链表
```
- 判断此方案是否可行。
```
int cnt=0;//用计数变量存储嘎了多少坏人
for(int i=1;i<=k;i++){
	for(int j=1;j<=(m-2)%(k+k-cnt);j++)tail=tail->next;//报数操作
	if(tail->next->data)break;//嘎到好人就要break
    tail->next=tail->next->next,tail=tail->next,cnt++;
}
if(cnt==k){cout<<m;return 0;}//如果已经找到就输出
```
- 为了不炸内存，每次枚举完后要将这一个链表释放掉空间。
```
tail=head;
while(tail->next!=head){Node *temp=tail;tail=tail->next;delete temp;}
delete tail;
```
## 完整代码：
```
拒绝抄题解，从你我做起
#include<bits/stdc++.h>
using namespace std;
struct Node{
	bool data;
	Node *next;
};
int main(){
	int k;
	cin>>k;
	for(int m=k+1;;m++){
		if(m%(k+k)<=k&&m%(k+k)!=0)continue;
		Node *head=new Node,*tail=head;
		head->data=1;
		for(int i=2;i<=k+k;i++){
			Node *n=new Node;
			n->data=(i<=k),n->next=nullptr,tail->next=n,tail=n;
		}
		tail->next=head,tail=head;
		int cnt=0;
		for(int i=1;i<=k;i++){
			for(int j=1;j<=(m-2)%(k+k-cnt);j++)tail=tail->next;
			if(tail->next->data)break;
		    tail->next=tail->next->next,tail=tail->next,cnt++;
		}
		if(cnt==k){cout<<m;return 0;}
		tail=head;
		while(tail->next!=head){Node *temp=tail;tail=tail->next;delete temp;}
		delete tail;
	}
} 
```

完结撒花！

---


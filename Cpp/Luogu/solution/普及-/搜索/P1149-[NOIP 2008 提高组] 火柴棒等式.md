# [NOIP 2008 提高组] 火柴棒等式

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。


## 说明/提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

## 样例 #1

### 输入

```
14```

### 输出

```
2```

## 样例 #2

### 输入

```
18```

### 输出

```
9```

# 题解

## 作者：hilsinleri (赞：17)

这题的话，他说n<=24，那么这个假设不出现极端情况，每一个加数都应该在4位及以内。我先做了一个记着0-9所用火柴棒的个数，然后写一个返回火柴棒的函数。下面有，自己看，只要懂c++就能理解。其实就是把一个数每一位都剥下来，返回每一位用的火柴棒的和。

两重循环，枚举加数，在用上面的函数算两个加数、和所用的火柴棒之和，看如果等于n-4，就++ans。

```cpp
#include<cstdio>

int num[11]={6,2,5,5,4,5,6,3,7,6};

int s(int x)
{
    if(x==0)return num[0];
    int ans=0;
    while(x!=0)
    {
        int t=x%10;
        ans+=num[t];
        x/=10;
    }
    return ans;
}

int main()
{
    int n,total=0;
    scanf("%d",&n);
    for(int i=0;i<=1000;++i)
    {
        for(int j=0;j<=1000;++j)
        {
            if(s(i)+s(j)+s(i+j)+4==n)
            {
                ++total;
                
            }
        }
    }
    printf("%d",total);
    return 0;
}
```

---

## 作者：King_and_Grey (赞：14)

## [P1149 [NOIP 2008 提高组] 火柴棒等式 题解](https://www.luogu.com.cn/problem/P1149)
## 题目简述
一共有 $n$ 根火柴，求能拼出多少个 $A + B = C$，且 $A \neq B$。
## 思路讲解
刚刚看到这道题，毫不犹豫地打气暴力枚举，毕竟，暴力出奇迹吗。

首先，先把 $0 \sim 9$ 所以数字所需要的火柴数记录到一个数组中。如何三重循环 $1 \sim 10$，火柴数相加等于 $n$，并且 $A + B = C$。

暴力代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e4;
const int num[] = {0,6,2,5,5,4,5,6,3,7,6};
int n,ans;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= 10;i++){
		for(int j = 1;j <= 10;j++){
			for(int k = 1;k <= 10;k++){
				if(i + j == k && num[i] + num[j] + num[k] + 4 == n && i != j){
					ans++;
				}
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```
[20 分提交记录。](https://www.luogu.com.cn/record/201303319)

这是为什么呢。很简单，这个操作只能进行 $10$ 以内的加法计算。我们需要再建立一个数组，存下 $1 \sim 2000$ 的数字火柴数，然后暴力。

注意点：

1. 第 $12$ 行记得 $j$ 一定要大于 $0$.
2. 第 $16$ 和 $17$ 两行 $i$ 和 $j$ 只能循环到 $1000$，不然报错。
3. 第四行，我一不小心在 $6$ 之前 加了个 $0$。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2000;
const int num[] = {6,2,5,5,4,5,6,3,7,6};
int n,ans,a[maxn + 5];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	a[0] = 6;                                         //数字 0 有 6 个火柴
    for (int i = 1;i <= 2000;i++){
        for (int j = i;j;j /= 10){                    //从最高位开始，一个数位一个数位地加上火柴数
            a[i] += num[j % 10];
        }
    }
    for (int i = 0;i <= 1000;i++){
        for (int j = 0;j <= 1000;j++){
            if (a[i] + a[j] + a[i + j] + 4 == n){    //a[i] 就是第一个数，a[j] 就是第二个数。
                ans++;                               //a[i + j]就是第三个数。加上的 4 就是 + 和 =。
            }
        }
    }
	cout << ans << endl;
	return 0;
}
```
[提交记录。](https://www.luogu.com.cn/record/201307646)

感谢观看，求赞。

---

## 作者：mnlbnkk (赞：5)

## 前言
蒟蒻制作不易，求管理员通过。
## 思路
先将拼出数字零到九需要用到的火柴根数存进 $s$ 数组里。再写一个函数，返回值是所用火柴根数的和。假设进入函数的这个数小于十，那么直接返回,否则将这个的每一位都拆开，判断每一位要用的根数，最后相加。

最后在主函数里循环判断，如满足条件，则等式成立，答案加一。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int s[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
int n, ans;

int sl(int x){
	int sum = 0;
	if(x < 10){
		sum = s[x];
	}
	else{
		int t;
		t = x;
		while(t != 0){
			sum += s[t % 10];
			t /= 10;
		}
	}
	return sum;
}
int main(){
	cin >> n;
	for(int i = 0;i <= 1000;i++){
    	for(int j = 0;j <= 1000;j++){
    		if(sl(i) + sl(j) + sl(i + j) == n - 4){
        //若满足此条件，则等式成立
    			ans++;
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```

有错误请大佬指出！

---

## 作者：TODAYS (赞：3)

## 题目思路

因为 $n\le24$，数据小，我们可以考虑枚举，枚举 $A$ 和 $B$，那么 $C=A+B$，再计算出 $A$，$B$，$C$ 所需的火柴棍，是否等于 $n-4$ 因为加号与等号各自需要两根火柴棍。

知道了方法，就要确定枚举 $A$ 和 $B$ 的范围了，因为 $n\le24$，所以 $A$ $B$ $C$ 的小木棒数量就要小于等于 $8$，那么 $A$ 最大为 $1111$（$8$ 根小木棒）那么 $C$ 一定还是一个四位数，四位数最少要用 $8$ 根小木棒，那 $A$ 和 $C$ 最少一共要用 $16$ 根小木棒，再加上加号与等号所需小木棒，一共是 $20$ 根，$B$ 最多只能用 $4$ 根小木棒，小于等于 $4$ 根的个位数只有 $1$、$4$、$7$，$1111+7=1117$（不符合），**经过以上，所以符合条件的最多是个三位数加法。**

## code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {int x = 0, f = 1;char ch = getchar();while (ch < '0' || ch >'9'){if (ch == '-')f = -1;ch = getchar();}while (ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + (ch ^ 48);ch = getchar();}return x * f;}
inline void write(int x) {if (x < 0) putchar('-'), x = -x;if (x > 9)write(x / 10);putchar(x % 10 + '0');return ;} // 快读和快写
int mu[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // 把各个数字所需小木棒打出表，方便计算总小木棒数
int n, cnt;

int check(int x)
{
	if (x == 0) return mu[x]; //特殊判断
	int ans = 0;
	//计算x的各个位数字所需小木棒之和
	while (x != 0)
	{
		ans += mu[x % 10];
		x /= 10;
	}
	return ans;
}

signed main()
{
	n = read();
	for (int A = 0; A <= 1000; A++)
	{
		for (int B = 0; B <= 1000; B++)
		{
			//枚举A和B
			if (check(A) + check(B) + check(A + B) + 4 == n) //判断是否符合要求
			{
				cnt++;
			}
		}
	}
	write(cnt);
	return 0;
}
```

---

## 作者：ShiYuXuan1234 (赞：2)

## 前言
辛苦管理员审核一下，求通过。

---
## 思路
虽然说这题的标签是**搜索**，但题目中的 $n\le24$ 告诉我，等式中的每一个数不可能超过 $1000$ ，由此可以得出以下结论：
>这是一道暴力枚举题。

我们可以通过枚举第一个加数和第二个加数一个一个尝试两个加数以及和的火柴棍根数是否等于 $n-4$ $($`-4`表示加号和等号需要的 $4$ 根火柴棍$)$，最终求出答案，甚至不需要什么优化。

其中，求每个数需要用几根火柴棍可以用`while`循环实现，不过由于个位可能是 $0$ ,所以最后的个位需要单独计算。

具体计算方式请看【**代码**】部分。

---
## 代码（含注释）

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10]={6,2,5,5,4,5,6,3,7,6};//每个数字需要的火柴棍根数
int main(){
	int n;
	cin>>n;	
	n-=4;//'+'和'='
	int sum=0;//能拼成的不同等式的数目
	for(int i=0;i<=1000;i++){
		for(int j=i;j<=1000;j++){//枚举两个加数（为防止算式重复，加数2从加数1开始）
			int x=0;//两个加数与和需要的火柴棍根数
			int j1=i,j2=j,he=i+j;	//两个加数与和
			while(j1>=10){//while循环求加数1中非个位的火柴棍根数
				x+=a[j1%10];
				j1/=10;
			}
			x+=a[j1];
			j1/=10;//个位单独计算
			while(j2>=10){//while循环求加数2中非个位的火柴棍根数
				x+=a[j2%10];
				j2/=10;
			}
			x+=a[j2];
			j2/=10;//个位单独计算
			while(he>=10){//while循环求和中非个位的火柴棍根数
				x+=a[he%10];
				he/=10;
			}
			x+=a[he];
			he/=10;//个位单独计算
			if(x==n){//判断是否满足题目条件（前面已经n-=4了）
				if(i==j){//遵照题意，如果加数1不等于加数2，算作两个算式，否则算作一个算式
					sum++;
				}else{
					sum+=2;
				}
			}
		}
	}
	cout<<sum<<endl;//输出结果
	return 0;//完美的结束
}
```
最后，[AC 记录](https://www.luogu.com.cn/record/201142441)。

---

## 作者：qhr2023 (赞：2)

## solution

一道暴力枚举题。

暴力枚举 $A$ 和 $B$ 的所有可能数字，设 $f_i$ 表示数字 $i$ 所用火柴数，若 $f_A+f_B+f_{A+B}=n-4$，答案加一，这里减 $4$ 是减去符号所用火柴。

对于如何求 $f_i$，预处理 $0$ 到 $9$ 所用火柴数，将 $i$ 每个数位所用火柴数加起来即可。

对于 $A$ 的最大可能不会太大，事实上枚举到 $1000$ 就足以通过。

[通过记录](https://hydro.ac/record/679af53934d9362afb2c48ed)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[]={6, 2, 5, 5, 4, 5, 6, 3, 7, 6}, n, ans;
int f (int x) {
	if (x<10)
		return a[x];
	return f(x/10)+a[x%10];
}
int main () {
	cin >> n;
	for (int i=0; i<=1000; ++i)
		for (int j=0; j<=1000; ++j)
			ans+=(f(i)+f(j)+f(i+j)==n-4);
	cout << ans;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
这题我们要先根据这张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)
来算出每个数字需要的火柴棒数量，分别是 ```6,2,5,5,4,5,6,3,7,6```个，对应着 $0-9$。

那么接下来，通过拆位，我们可以算出所有数字它所需要的火柴棒数量，用十位上的数字 $+$ 个位上的数字，就可以得出了。

最后，枚举所有可能性，只要满足，计数器就加一，最后输出即可。

---
### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}, b[3000], n, ans = 0;

int main () {
	cin >> n;
	n -= 4;
	for (int i = 0; i <= 999; i++) b[i] = a[i];
	for (int i = 10; i <= 999; i++) b[i] = b[i / 10] + b[i % 10];
	for (int i = 0; i <= 999; i++) {
		for (int j = 0; j <= i; j++) {
			if (b[i] + b[j] + b[i - j] == n) ans++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：nieqiuran (赞：1)

### P1149 题解
[题目传送门](https://www.luogu.com.cn/problem/P1149)

#### 思路
数据比较小，$n$ 只到 $24$ 可以枚举或者直接打表，枚举到一千就可以过。先用数组存好十个数字所需的火柴数，然后开个函数算整个数需要的火柴数，计算出来等于 $n$ 则成立就加一，不要忘了加号和等于号所需的四根火柴。

[Code](https://www.luogu.com.cn/paste/nnrn4ez1)

---

## 作者：z_yq (赞：1)

# 前言
小号跳题跳到了，于是用大号写题解。
# 题意
给定 $n$ 和每个个位数需要的火柴数量，对于每个数字，我们定义它的需要火柴数量为它各个数位的数字需要的火柴数量的和，问有多少个有序对 ${(A,B,C)}$ 满足 $C = A + B$ 并且 $A,B,C$ 需要的火柴数量之和为 $n - 4$。
# 做法
一眼题，看见 $n \le 24$，可以想到 $A$ 能使用的火柴数量为 $6$ 个左右，所以大概 $A$ 的上限就是 $5\times 10^3$ 左右，经过实验果然是 $2\times 10^3$，随后 ${(2\times 10^3)}^2$ 的暴力就可以了，实测能过。
# 代码
```cpp
#include<algorithm>
#include<iostream>
#include<climits>
#include<cmath>

using namespace std;
const int MX=2e3;
int a[19]={6,2,5,5,4,5,6,3,7,6};
inline int getnum(int x){
    int sum=0;
    if(x==0) return 6;
    while(x){
        sum+=a[x%10];
        x/=10;
    }
    return sum;
}
int main(){
    int n,ans=0;
    cin>>n;
    for(int i=0;i<=MX;i++)
        for(int j=0;j<=MX;j++){
            int sum=i+j,tp=getnum(i)+getnum(j)+getnum(sum)+4;
             if(getnum(i)>n+3 || getnum(j)>n+3) break;
            if(tp==n){
                ans++;
            }
        }
    cout<<ans;
}
```

---

## 作者：ZZA000HAH (赞：1)

题目大意：给 $n$ 根火柴棍，求可以拼出形如 $A+B=C$ 的等式的个数。

题目思路：范围 $n\le24$，则可以用枚举，也可以用~~打表~~。$24$ 根火柴棍，拼出的最大数组成的等式为 $1111+1=1112$（实际为 $25$ 根），则枚举的范围为 $[0,1111]$，数字 $[0,9]$ 所需的火柴棍对应为 ${6,2,5,5,4,5,6,3,7,6}$。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10]= {6,2,5,5,4,5,6,3,7,6},n,ans,num;
void make(int x)//计算每个数所用火柴棍的个数
{
	if (x==0) num+=a[0];//判断是否为0
	else
		while (x!=0)
		{
			num+=a[x%10];
			x/=10;
		}
}
int main()
{
	scanf("%d",&n);
	for (int i=0; i<=1111; i++)
		for (int j=0; j<=1111; j++)//枚举1-1111的数
		{
			num=0;
			make(i);
			make(j);
			make(i+j);//缩减到(n^2),算出和
			if ((num+4)==n) ans++;//注意减去4
		}
	printf("%d\n",ans);
	return 0;
}
```
## 打表：
$[0,24]$范围对应能拼出等式的个数：${0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128}$。
### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[25]={0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128},n;
int main()
{
	cin>>n;
	cout<<a[n];
}
```
### End

---

## 作者：blankslpl (赞：0)

# P1149 [NOIP 2008 提高组] 火柴棒等式
## 解题思路：
- 先将数字 $0 \sim 9$ 的用火柴数量用数组存好。
- 考虑到每个数字最多不会超过 $1111$ 不会小于 $0$。
- 然后判断这个式子是否成立就好了。
## Ac code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>inline T read()
{
	T r=0,f=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-') f=-1;c=getchar();
	}
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
int a[10]={6,2,5,5,4,5,6,3,7,6};
int h(int x)//摆数字x要多少根火柴
{
    int cnt=0,xx=x;
    do 
    {
        cnt+=a[x%10];
        x/=10;
    }while(x!=0);
    return cnt;
}
signed main()
{
 	int n=_,ans=0;
    for(int i=0;i<=1111;i++)
    {
    	for(int j=0;j<=1111;j++)
    	{
    		int c=i+j;//和
    		if(h(i)+h(j)+h(c)==n-4)
    		{
    		    ans++;
    		}
		}
	}
	out(ans);
	return 0;
}
```

---

## 作者：mcturtle (赞：0)

题外话：`stick.cpp`。
## 题意
给你 $n$ 根火柴棍，求最多能拼出多少个形如 $A+B=C$ 的等式。
## 思路
因为 $n\le24$，数据范围小，所以考虑枚举。

先用一个数组记录每个数字所需的火柴棒数量，随后将 $1\sim2000$ 的每一个数所需的火柴棒数量记录到 $A$ 数组中，就是双重循环枚举，如果 $3$ 个数的火柴棒总量等于 $n$，答案数累加。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[2001], s;
const int nt[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
int main()
{
    cin >> n;
    a[0] = 6;
    for (int i = 1; i <= 2000; i++)
    {
        for (int j = i; j; j /= 10)
        {
            a[i] += nt[j % 10];
        }
    }
    for (int i = 0; i <= 1000; i++)
    {
        for (int j = 0; j <= 1000; j++)
        {
            if (a[i] + a[j] + a[i + j] + 4 == n)//注意要加4
            {
                s++;
            }
        }
    }
    cout << s;
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

外话：一看到这题我就想到今年的 CSP-J 的第 $3$ 题。  
本题算法：枚举。\
我们可以枚举第一个加数 $i$，再枚举第二个加数 $j$，然后我们就可以算出 $i+j$ 的和。如果 $i+j=(i+j)$ 这个算式刚好用了 $n$ 根小棒，计数器加一。\
除此之外，我们还要定义一个数组 $num$，存的是摆 $0-9$ 这些数字各自需要的小棒数量，数量我们可以从题目的图片中得到。\
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int r=1005;
int num[]={6,2,5,5,4,5,6,3,7,6};
int check(int x)
{
	int a=0;
	if(x==0)//如果x=0需要特判，因为下面的循环进不去
	{
		a=num[x];
		return a;
	}
	while(x)
	{
		int mod=x%10;
		a+=num[mod];
		x/=10;
	}
	return a;
}
signed main()
{
	int n;
	cin>>n;
	int total=0;
	for(int i=0;i<=r;i++)//枚举第一个加数
	{
		for(int j=0;j<=r;j++)//枚举第二哥加数
		{
			int he=i+j;
			if(check(i)+check(j)+check(he)+4==n)//注意，需要加4，因为加号和等于号也需要小棒
			{
				total++;
			}
		}
	}
	cout<<total;
	return 0;
}
```

---

## 作者：hbdcsd (赞：0)

由于 $n\leq24$，本题暴力枚举可过。

枚举每一个可能的 $A$ 和 $B$，算出 $C$，如果 $A$，$B$，$C$ 所需要的火柴棒的和加 $4$ 等于 $n$，答案加 $1$，最后输出就行了。对于枚举的边界，$1000$ 以上的数就会超过 $24$ 了，这里我枚举到了 $1200$。

### 代码

```cpp
#include <iostream>
using namespace std; 
int n, a[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}, cnt;
int f(int x){//计算一个数消耗的火柴棒
	if (x == 0) return 6;//注意特判 0
	int sum = 0;
	while (x > 0){
		sum += a[x%10];
		x /= 10;
	}
	return sum;
}
int main(){
	cin >> n;
	for (int i = 0; i < 1200; i++)
		for (int j = 0; j < 1200; j++) if (f(i) + f(j) + f(i+j) + 4 == n) cnt++;//注意加 4
	cout << cnt;
	return 0;
}
```

---


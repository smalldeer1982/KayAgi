# 组合的输出

## 题目描述

排列与组合是常用的数学方法，其中组合就是从 $n$ 个元素中抽出 $r$ 个元素（不分顺序且 $r \le n$），我们可以简单地将 $n$ 个元素理解为自然数 $1,2,\dots,n$，从中任取 $r$ 个数。

现要求你输出所有组合。

例如 $n=5,r=3$，所有组合为：

$123,124,125,134,135,145,234,235,245,345$。


## 样例 #1

### 输入

```
5 3 
```

### 输出

```
  1  2  3
  1  2  4
  1  2  5
  1  3  4
  1  3  5
  1  4  5
  2  3  4
  2  3  5
  2  4  5
  3  4  5```

# 题解

## 作者：feecle6418 (赞：437)

又来一篇搜索与回溯。。。。。。

这题可以用优化版的dfs

组合与排列还是有很大区别的，不过框架相同，代码出人意料的简洁！

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,a[100],n;
void dfs(int k){//搜索第k个数
    int i;
    if(k>r){
        for(i=1;i<=r;i++){
            cout<<setw(3)<<a[i];//输出，场宽为三
        }
        cout<<endl;
        return ;//回到前一层
    }
    for(i=a[k-1]+1;i<=n;i++){
        a[k]=i;
        dfs(k+1);//直接进行下一次调用
    }
}  
int main()  
{   
    cin>>n>>r;
    dfs(1);
    return 0;  
}  
```

---

## 作者：Uranus (赞：335)

打表法天下第一(逃

洛谷最近规定要查打表(参见：[关于近段时间经常出现的打表的说明](https://www.luogu.org/discuss/show?postid=42701))，不过这样应该不会棕名吧...

```cpp
#include<iostream>
#include<iomanip>
using namespace std;
int nn,rr;
///nn和rr分别表示题目说明中的n和r,双写是怕打表时变量重名
int main()
{
    cin>>nn>>rr;
    ///显然,rr的大小决定了循环层数,所以对rr使用switch就可以完成打表
    switch(rr)
    {
    	///每次组合时的数字从左到右按顺序依次是a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u
        case 1:
        {
            for(int a=1;a<=nn;a++)
                cout<<setw(3)<<a<<endl;
            break;
        }
        case 2:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
                cout<<setw(3)<<a<<setw(3)<<b<<endl;
            break;
        }
        case 3:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<endl;
            break;
        }
        case 4:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<endl;
            break;
        }
        case 5:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<endl;
            break;
        }
        case 6:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<endl;
            break;
        }
        case 7:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<endl;
            break;
        }
        case 8:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<endl;
            break;
        }
        case 9:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<endl;
            break;
        }
        case 10:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<endl;
            break;
        }
        case 11:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<endl;
            break;
        }
        case 12:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<endl;
            break;
        }
        case 13:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<endl;
            break;
        }
        case 14:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<endl;
            break;
        }
        case 15:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<endl;
            break;
        }
        case 16:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<endl;
            break;
        }
        case 17:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
            for(int q=p+1;q<=nn;q++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<setw(3)<<q<<endl;
            break;
        }
        case 18:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
            for(int q=p+1;q<=nn;q++)
            for(int r=q+1;r<=nn;r++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<setw(3)<<q<<setw(3)<<r<<endl;
            break;
        }
        case 19:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
            for(int q=p+1;q<=nn;q++)
            for(int r=q+1;r<=nn;r++)
            for(int s=r+1;s<=nn;s++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<setw(3)<<q<<setw(3)<<r<<endl;
            break;
        }
        case 20:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
            for(int q=p+1;q<=nn;q++)
            for(int r=q+1;r<=nn;r++)
            for(int s=r+1;s<=nn;s++)
            for(int t=s+1;t<=nn;t++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<setw(3)<<q<<setw(3)<<r<<setw(3)<<t<<endl;
            break;
        }
        case 21:
        {
            for(int a=1;a<=nn;a++)
            for(int b=a+1;b<=nn;b++)
            for(int c=b+1;c<=nn;c++)
            for(int d=c+1;d<=nn;d++)
            for(int e=d+1;e<=nn;e++)
            for(int f=e+1;f<=nn;f++)
            for(int g=f+1;g<=nn;g++)
            for(int h=g+1;h<=nn;h++)
            for(int i=h+1;i<=nn;i++)
            for(int j=i+1;j<=nn;j++)
            for(int k=j+1;k<=nn;k++)
            for(int l=k+1;l<=nn;l++)
            for(int m=l+1;m<=nn;m++)
            for(int n=m+1;n<=nn;n++)
            for(int o=n+1;o<=nn;o++)
            for(int p=o+1;p<=nn;p++)
            for(int q=p+1;q<=nn;q++)
            for(int r=q+1;r<=nn;r++)
            for(int s=r+1;s<=nn;s++)
            for(int t=s+1;t<=nn;t++)
            for(int u=t+1;u<=nn;u++)
                cout<<setw(3)<<a<<setw(3)<<b<<setw(3)<<c<<setw(3)<<d<<setw(3)<<e<<setw(3)<<f<<setw(3)<<g<<setw(3)<<h<<setw(3)<<i<<setw(3)<<j<<setw(3)<<k<<setw(3)<<l<<setw(3)<<m<<setw(3)<<n<<setw(3)<<o<<setw(3)<<p<<setw(3)<<q<<setw(3)<<r<<setw(3)<<t<<setw(3)<<u<<endl;
            break;
        }
    }
    return 0;
}

```

---

## 作者：tony123456 (赞：209)

楼下的dalao们都是用dfs，回溯等算法做的，于是我在这里献上一个STL解法

algorithm库里面有一个函数叫next_permutation,可以快速生成全排列，具体[参见这里](https://blog.csdn.net/howardemily/article/details/68064377)

上超短代码：
```cpp
#include<cstdio>
#include<algorithm>
int x[30];//x[i]代表第i选或不选，0代表选，1代表不选
using namespace std;
int main(){
    int n,r;
    scanf("%d%d",&n,&r);//读入n、r
    for(int i=r+1;i<=n;++i)
        x[i]=1; //赋初始值
    do{
        for(int i=1;i<=n;++i)
            if(x[i]==0) printf("%3d",i);//如果是0就输出，注意三个常宽
        printf("\n");//换行
    }while(next_permutation(x+1,x+n+1));//生成下一个
    return 0;//返回
}
```

---

## 作者：ICE_Wol (赞：92)

其实本题递归深搜可以轻松解决问题

但无奈题干不允许使用递归

所以以下给出非递归解法

具体解析参见代码注释

整份代码的核心在于第32行的判断条件,务必要注意

```cpp
#include<iostream>
#include<iomanip>
using namespace std;
int a[1005],n,m,arr = 1;
int main()
{
    cin >> n >> m;
    while(arr){
        if(arr >= m + 1){					//达到边界时打印解
            for(int i = 1;i <= m;i++)
                cout << setw(3) << a[i];	 //注意场宽设置
            cout << endl;
            arr--;						   //回溯到前一位
            continue;
        }
        if(!a[arr]){						 //若该位置为空
            a[arr] = a[arr - 1] + 1;		 //在其前一位基础上加一
            arr ++;
            continue;
        }
        if(a[arr] + m - arr < n){			//**关键** 判定在当前位为a[arr]的情况下向后推(m - arr)位是否超出题目的最大数字限制
            a[arr++] ++;					 //当前位自加后挪至后一位	
            continue;
        }
        a[arr--] = 0;						//将当前位归零,回溯至前一位
    }
    return 0;
}
```

---

## 作者：06ray (赞：66)

此题AC方法是搜索与回溯。组合与排列的区别在于组合里每一个数都要大于前一个数。

代码如下


```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int total=0; 
int a[50]; //a数组存每一次选的数
bool b[50];
int n,r;
void print(){ //打印函数
    for(int i=1; i<=r; i++)
    cout<<setw(3)<<a[i];//定义场宽为3，直接输出只能得10分
    cout<<endl;
} 
void search(int t)//搜索函数
{
    int i;
    if(t>r) { //如果搜完了就输出a数组
        print();
        return;
    }
    for(int i=1; i<=n; i++){ //枚举每一个数
        if(!b[i]&&i>a[t-1]||t==1)//当i木有被使用过且i必须大于前个数但除1之外
{
            a[t]=i; //将i存入a数组
            b[i]=true;//标记i已被使用
            search(t+1);//继续搜索
            a[t]=0;//回溯一步
            b[i]=false; 
        }
    } 
}
int main(){
    cin>>n>>r;//输入
   search(1);
   return 0;
}
```

---

## 作者：Carl66 (赞：51)

# 注意！！
## 此为dfs递归做法，题中已明确禁用

~~不过我试了一下也是可以过的~~

为了让大家巩固一下基础

我还是~~不自量力地~~写一下我的代码（~~第一篇~~QwQ）

#### 如有锅请dalao指正

此题与全排列有相似之处

只不过全排列是n个数占n个位置

此题为n个数占m个位置（m < n）

以样例为例
 
1-5中选三个数

可以想成五个数争夺三个位置，且单调递增

#### 其中有 123,124,125,134,135,145,234,235,245,345

首先定义两个数组，a数组与b数组

a数组标记3个位置的占用情况（1为占，0为空）

b数组容纳已占的a数组对应的数值

然后看临界条件：a中三个位置已满且符合题意

此时用一个print函数输出答案就OK了嘤

以下为完整代码：

```c
#include<cstdio>//头文件简洁会节约时间 
using namespace std;
int n,m;//n为数的个数，m为位置的个数 
int a[22],b[22];//a数组标记位置是否被占，b数组储存对应数值 
void print(){
	for(int i = 1;i <= m;i++)
		printf("%3d",b[i]);//域宽为3，输出数值 
	printf("\n");//换行别忘了 
}
void dfs(int i){//搜索与回溯 
	if(i > m){
		print();//打印出结果 
		return;
	}
	for(int j = b[i - 1] + 1;j <= n;j++){
		if(!a[j]){
			a[j] = 1;
			b[i] = j;
			dfs(i + 1);//下一层递归 
			a[j] = 0;
		}
	}
	return;//回溯 
}
int main(){
	scanf("%d%d",&n,&m);
	dfs(1);//从1开搜 
	return 0;
}
```

看完我~~这很水~~的代码后，希望你能亲自再写一遍，巩固记忆
## 拒绝抄袭！
管理真好看（~~疯狂暗示~~）第一篇代码呢！

---

## 作者：shajjl (赞：33)

## 谁来挑战我的短代码！！嘻~~

其实小生还怪不好意思的，从来就没弄懂递推和回溯……

### 这道题的重点：

1：存储：这道题~~很烦的~~要我们把每次挑出来的组合都输出；所以我建了一个数组，来储存1~r个数；

2：回溯：这里我设了一个计数器t，只要还没到r个数，就继续套函数，到下一遍；

3：判断：（1）如果没有if(i>a[t-1])这一句的话，就会输出所有的排列，而不是组合，因为当t=r时，函数输出并回溯，a[t]就会等于a[t-1]；

就拿n=5；r=3举例：比如现在第一遍挑数结束t=3，必然会输出第1,2,3种组合1 2 3，1 2 4，1 2 5然后函数回溯，现在数组a中a[1]=1;a[2]=2;a[3]=3;回到t=2；继续for(i=t;i<=n;i++)的循环由于是第二次，所以i++，i变成3；所以a[2]=3；现在数组变成a[1]=1;a[2]=3;a[3]=5;

现在t！=r；所以进入函数p（t+1）；开始循环，i=t=3并把a[t]赋值为3，现在就变成了a[1]=1;a[2]=3;a[3]=3;但组合不能出现相同的数；为避免回溯时发生重复，判断i是否大于上一个数，只要保证后面的数比前面的数大，就可以输出；
 
 （2）有可能没听懂？小生再用另一种方式讲一遍：如果我们要手算出所有组合，你会怎么做？
 
 第一种肯定是从1开始加1 也就是1 2 3；
 
 第二、三种发现3后面还有4 5；所以1 2 4,1 2 5；
 
 第四种发现1 2 开头的没了，2+1，开始做1 3……以此类推这就是我们的
 ```
for(i=t;i<=n;i++)
	 {if(i>a[t-1])
	  {a[t]=i;
	   if(t!=r)p(t+1);
```
每次都要加1嘛，所以后面的数肯定比前面的大，也就解释了if(i>a[t-1])的判断和p(t+1)的找下一个；找完1 2 找1 3 也就是t=r并且这个层次的3,4,5都循环后，回溯到t=2并i++；再找1 3开头的，以此类推
```
#include<iostream>//P1157
#include<cstdio>
#include<cstring>
#include<string>
#include<iomanip>
#include <algorithm>
#include<cmath>
#include<vector>
#include<set>
using namespace std;
int a[23],n,r;
int p(int t)
{
	int i,j;
	for(i=t;i<=n;i++)
	 {if(i>a[t-1])
	  {a[t]=i;
	   if(t!=r)p(t+1);//感觉程序已经没什么好解释的了
       else{for(j=1;j<=r;j++)printf("%3d",a[j]);cout<<endl;}}}
	return 0;
}
int main()
{
	cin>>n>>r;
	p(1);
	return 0;
}
```

如果还是没听懂，拿纸和笔自己推一遍就明白了

顺便说一句代码如果看着长请自动忽略头文件…………

顺手留赞，小生万分感激<^_^>

---

## 作者：引领天下 (赞：25)

这题其实就是搜索+回溯（可是我仍然写了 2 小时）

这个题呢，我跟楼下们的思路有一些不一样：

首先，第一组排列一定是 $1\sim k$（前 $k$ 个元素），于是进行一个预处理；

接下来开始搜：

先从第 $k$ 个元素搜，搜完前 $k-1$ 个元素为 $1\sim k-1$ 时最后一个元素的所有情况（边搜边记）；

搜完了（前 $k$ 个元素填满了或任意一个元素 $>n$ 了或前 $k$ 个元素未填满，但目前元素已经到 $n$ 了（下一步就没了））就回溯（第一种情况下输出）；

共搜 $k$ 次，每次范围向前 $1$ 个元素，初始值为 $x$（目前在搜第几个元素）

搜完了就好了。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<cstring>
using namespace std;
int n,k,x,a[25],d;//n和k为组合中的n、r，x为目前搜到第几位，d为目前数字
void print(){//输出函数
    for (int i=1;i<=k;i++)
    printf ("%3d",a[i]);
    printf ("\n");//用%3d输出后换行
}
void dfs(){//搜索
    if (x>k){print();return;}//x>k表示当前这一种情况已经搜完，输出
    if (x<k&&d==n){return;}//还没填满就已经到n了，肯定没戏了
//如果不判这个，可能会出现n=5,k=3时输出1 5 6的情况
    for (int i=1;i+d<=n;i++){//加1，加2，加3……
//这个循环保证了首先元素呈上升趋势，另外，还保证了不会重复（每个元素至少比上一个大1）
        d+=i;//先加上
        a[x++]=d;//存起来
        dfs();//搜索
        x--;//减1，返回上一个节点
        d-=i;//把值改回去
    }
}
int main(void){
    cin>>n>>k;//读入
    for (int i=1;i<=k;i++)a[i]=i;//预处理第1组
    x=k;//从最后一个开始搜
    d=k-1;//初始值为k-1的话，第一次加1正好补为k，不会修改已经预处理好的值
    while (x){//一直向前
        dfs();//搜索
        x--;//向前一个
        d=x;//定下一次初始值
    }
}
```

这样的写法因为不用判重，所以可以节约一定的空间开支。

---

## 作者：test_check (赞：22)

[$ \huge P1157  \ \text{组合的输出}$](https://www.luogu.org/problem/P1157)   
一道$DFS$和回溯算法的入门练手好题。   
还是比较简单的，注释都在代码里，自己看吧。
```cpp
#include<bits/stdc++.h> //万能头
using namespace std;
int m,n,s[100];  //s[]用来标记数
bool vis[100]; //vis[]表示一个数是否可以使用，1表示可以使用，0表示不能使用
void dfs(int k)  //dfs深搜
{
    if(k==n+1)  //前n个位置都填过了
    {
        for(int j=1;j<=n;j++)
        cout<<setw(3)<<s[j];    //将填入的数依次输出
        cout<<endl;  //换行
        return ;  //结束本次调用
    }
    for(int i=s[k-1];i<=m;i++)  //将每个数遍历一遍，注意，后一个数要大于前一个数，所以i要从s[k-1]开始遍历
    {
        if(vis[i])  //如果i这个数还没有使用
        {           //就使用它
            s[k]=i;  //将i这个数填入s数组中
            vis[i]=0;  //标记i这个数已经使用过了
            dfs(k+1);  //调用下一层
            vis[i]=1; //回溯，标记i这个数还未使用
        }
    }
}
int main()
{
    s[0]=1; //初始化，不然dfs(1)时,for循环无法工作
    memset(vis,1,sizeof(vis));   //将vis数组全部标为可以使用
    cin>>m>>n;  //输入
    dfs(1);  //从第一个数开始搜索
}
```

------------
还是来点小解释吧，每$dfs$一次，都将往$a$数组填一个数，直到$k==n+1$为止，那为何不是$n$呢，因为当$k==n$,程序是在填第$n$个数，所以，还没有搜索完。至于其他的代码里说的都很清楚，好了，本题解就这样结了。

------------


---

## 作者：ftx456789 (赞：20)

其实可以用二进制枚举子集来做,因为一共只有21个数字所以可以可以用二进制的每一位来表示每一个数字，然后只用从0枚举到$2^{21}$次就可以了，然后可以把答案存在一个结构体数组里然后对其按照字典序排序即可
```cpp
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <algorithm>
#include <math.h>
using namespace std;
struct node
{
    int v[21];
}a[3000000];
int n,r;
bool cmp(node a,node b)
{
    for(int i=0;i<r;i++)
        if(a.v[i]!=b.v[i])
        return a.v[i]<b.v[i];
}
int main()
{
    scanf("%d%d",&n,&r);
    int num=0;
    for(int i=0;i<(1<<n);i++)
    {
        int cnt=0;
        for(int j=0;j<21;j++)
            if(i&(1<<j))
                cnt++;
        if(cnt==r)
        {
            int k=0;
            for(int j=0;j<21;j++)
                if(i&(1<<j))
            {
                a[num].v[k++]=j+1;
            }
            num++;
        }
    }
    sort(a,a+num,cmp);
    for(int i=0;i<num;i++)
    {
        for(int j=0;j<r;j++)
                printf("%3d",a[i].v[j]);
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：wpy233 (赞：20)

题目中说`现要求你不用递归的方法输出所有组合`，那。。。本人偏偏就要用递归的方法输出所有组合。。。

~~淘气~~

这是一道很善良的题，一个是因为数据，另一个是因为这题除了一个DFS以外就没有其它坑人的东西了。

但是DFS依然很坑啊。。。

所以，下面让偶们来注意一下这题的几个坑点：
```
①组合的数字不能有重复！！！
②后面的数字要比前面大！！！
③输出时一定要带上场宽！！！
④输完后一定要记得换行！！！
⑤递归后一定要状态回溯！！！
```
~~似乎每个坑点都是十个字哦~~

所以，知道了这三个坑点，打起代码来还不是*行云流水*啦~

**其它注意事项，详见代码。**
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n,p;//输入的两个数
int a[21];//输出必备
bool b[21];//判重必备
void dfs(int dep,int last)//核心DFS
{
	if(dep>p)//如果已经搜完了一种组合
	{
		for(int i=1;i<=dep-1;i++)//输出
		{
			cout.width(3);//可恶的场宽！！！
			cout<<a[i];
		}
		cout<<endl;//可恶的换行！！！
		return;//记住要返回。。。
	}
	for(int i=1;i<=n;i++)//生成组合
		if(b[i]==false&&i>last)//判断这个数是否被用过且比上一个数小
		{
			b[i]=true;//把该数标记成用过
			a[dep]=i;//记录
			dfs(dep+1,i);//递归
			b[i]=false;//可恶的状态回溯！！！
		}
}
int main()
{
	cin>>n>>p;//输入
	dfs(1,0);//开始深搜之旅
    return 0;
}

---

## 作者：蛇皮猪 (赞：8)

逛了一圈应该不会有dalao和蛇皮猪做得一样

其实这道题可以看成n进制的加法配上一个不同寻常进位方式
~~似乎会麻烦不少，不过好歹也是一种别样的思维呢~~

所以请各位走过路过的dalao耐心康康以下的思路：
------------
这是样例：
n=5,r=3，所有组合为：

123,124,125,134,135,145,234,235,245,345

从样例来看，每个组合的最后一位会不断增加1，如果增到了n，就向前进一位，自身变为前一位加1

我们按照这样的进位规则，每增加一次就输出一次

于是就有了下面的分步代码

这题的最后一个点是坑，所以我们在输入后先特判：
```c
cin>>n>>m;
	if(m==0){//如果不抽元素的话 
		return 0;//不抽就不给你抽 
	}
```
然后为第一个组合赋值：
```c
for(i=1;i<=m;i++){
		ans[i]=i;//第一个组合 
	}
```
这就是内个不同寻常的进位方式（函数）：
```c
void shit(int j){
	ans[j-1]++;//前一位进一
	if(ans[j-1]>n){//如果这玩意膨胀了 
		k=j-1;//再向前一位 
		shit(k);//只有dalao会遵守题意（手动滑稽）
	} 
	ans[j]=ans[j-1]+1;//这一位变为前一位加一 
	if(ans[j]>n){//如果这玩意也得寸进尺 
		shit(j);//公正执法 
	}
}
```
进入代码的核心循环。

组合的最后一位在r进制下的每自增一次，就输出一次：
```c
while(ans[1]!=n-m+1){//当组合第一位等于n-m+1时，刹车 
		for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出组合的1到m位 
		}
		cout<<endl;//输出一个组合后换行 
		ans[m]++;//最后一位自增 
		if(ans[m]>n){//如果最后一位大于元素数
			j=m;
			shit(j);//堕入老夫的进位陷阱 
		}
	}
```
这样输出后，还要单独输出最后一个组合：
```c
for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出最后剩下的那个组合 
		}
```
现在我们把代码拼起来：
```c
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
int i,j,k,n,m,ans[105];
void shit(int j){
	ans[j-1]++;//前一位进一
	if(ans[j-1]>n){//如果这玩意膨胀了 
		k=j-1;//再向前一位 
		shit(k);//只有dalao会遵守题意（手动滑稽） 
	} 
	ans[j]=ans[j-1]+1;//这一位变为前一位加一 
	if(ans[j]>n){//如果这玩意也得寸进尺 
		shit(j);//公正执法 
	}
}
int main(){
	cin>>n>>m;
	if(m==0){//如果不抽元素的话 
		return 0;//不抽就不给你抽 
	}
	for(i=1;i<=m;i++){
		ans[i]=i;//第一个组合 
	}
	while(ans[1]!=n-m+1){//当组合第一位等于n-m+1时，刹车 
		for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出组合的1到m位 
		}
		cout<<endl;//输出一个组合后换行 
		ans[m]++;//最后一位自增 
		if(ans[m]>n){//如果最后一位大于元素数
			j=m;
			shit(j);//堕入老夫的进位陷阱 
		}
	}
	for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出最后剩下的那个组合 
		}
	return 0;
}
```
康懂了再copy哦~~误~~

这个办法很笨，蛇皮猪の代码也丑，如有雷同，让我删掉哦

可能会有不少可以优化的地方，各位dalao不喜请喷哦

求管理大大过，过了就是蛇皮猪の第一篇题解哦

---

## 作者：yejie (赞：8)

对于这题，与[全排列问题]类似(https://www.luogu.org/problemnew/show/P1706)

不过有以下几个改变：

1、输出的个数是r而不是n

2、顺序换一换算一种（也就是要从小到大）

因此，我们只要在以下几处改一改：

源代码：
```cpp
#include<bits/stdc++.h>//什么东西是万能的？头文件！
using namespace std;//听说用"cstdio"可以不写。
int n,a[10],b[10];//从左到右为：全排列个数、储存数组、标记数组。
void dfs(int x)//先别看这，看主程序！
{
    if(x==n+1)//结束条件。
    {
        for(int i=1;i<=n;i++)//从1循环到n来控制输出。
            printf("%3d",a[i]);//输出当前值，常宽为三。
        cout<<endl;//华丽地换行。
        return;//退出当前函数。
    }
    for(int i=1;i<=n;i++)//从1枚举到n。
        if(!b[i])//判断当前数(i)有没有被用过。
        {
            b[i]++;//标记。
            a[x]=i;//储存。
            dfs(x+1);//转至"dfs"函数。
            b[i]--;//取消标记。
        }
}
int main()//主程序！
{
    cin>>n;//读入n。
    dfs(1);//转至"dfs"函数。
}
```
现在先要把结束条件改一改，因为只要输出r个而不是n个。将
```cpp
if(x==n+1)//结束条件。
    {
        for(int i=1;i<=n;i++)//从1循环到n来控制输出。
            printf("%3d",a[i]);//输出当前值，常宽为三。
        cout<<endl;//华丽地换行。
        return;//退出当前函数。
    }
```
中的
```cpp
if(x==n+1)
```
改为
```cpp
if(x==r+1)
```
然后因为要从小到大，a[x]>a[x-1]，所以枚举时第一个数也要变一变。把
```cpp
for(int i=1;i<=n;i++)//从1枚举到n。
    if(!b[i])//判断当前数(i)有没有被用过。
    {
        b[i]++;//标记。
        a[x]=i;//储存。
        dfs(x+1);//转至"dfs"函数。
        b[i]--;//取消标记。
    }
```
中的
```cpp
for(int i=1;i<=n;i++)
```
改为
```cpp
for(int i=a[x-1]+1;i<=n;i++)
```
即可

贴最后程序：
```cpp
#include<bits/stdc++.h>//什么东西是万能的？头文件！
using namespace std;//听说用"cstdio"可以不写。
int n,r,a[21],b[21];//从左到右为：全排列个数、一次输出个数、储存数组、标记数组。
void dfs(int x)//先别看这，看主程序！
{
    if(x==r+1)//结束条件。
    {
        for(int i=1;i<=r;i++)//从1循环到n来控制输出。
            printf("%3d",a[i]);//输出当前值，常宽为3。
        cout<<endl;//华丽地换行。
        return;//退出当前函数。
    }
    for(int i=a[x-1]+1;i<=n;i++)//从1枚举到n。
        if(!b[i])//判断当前数(i)有没有被用过。
        {
            b[i]++;//标记。
            a[x]=i;//储存。
            dfs(x+1);//转至"dfs"函数。
            b[i]--;//取消标记。
        }
}
int main()//主程序！
{
    cin>>n>>r;//读入n。
    dfs(1);//转至"dfs"函数。
}
```
//蒟蒻的第三篇题解，求赞！


------------
彩蛋！

我这种方法是不是有点坑？

题目说“现要求你不用递归的方法输出所有组合”……

好尴尬……

那为什么还要放在“搜索”这一栏里？

这不是坑是什么？

---

## 作者：Lolierl (赞：7)

//看了题解一遍，发现dalao们全都是用的递归。那么，有没有非递归做法呢？

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
    int n,m;
    cin>>n>>m; //读入
    int a[m+1];
    
    for(int i=0;i<=m;i++)
        a[i]=i;   //赋初始状态。注意a[0]也要赋，因为后面判断边界条件有用。
    
    while(a[0]==0)//边界条件，由于惯性会一直变到a[0]。最好和后面结合起来看。
    {
        for(int i=1;i<=m;i++)
            printf ("%3d",a[i]);//printf不是我的风格啊。。。但是这题输出条件限制，cout要写一大堆if，就只好这么写了。
        cout<<endl;  //换行
            
        int j=m;
        while(a[j]==n-m+j)j--;  //核心部分来了：n-m+j是每个数组元素在保证递增的情况下所取的最大值，可以简单证明。每次找第一个不是最大值的数，然后将其++，同时将它后面每一个数都设为按+1递增，也就是所谓初始状态。最后一次做完后就会因为惯性将a[0]++，就可以通过它来结束，既避免了下标越界，又减少了一些烦人的判断。通过简单的模拟，可以更好地理解。
        a[j]++;
        for(int i=j+1;i<=m;i++)
            a[i]=a[i-1]+1;
    }
    return 0;//一个循环结束后就可以结束了。需要注意m>n的情况，当题目没注明时需特判。
//以下是基础组合计数思想，不懂请看注释。

}

---

## 作者：Laser_Crystal (赞：5)

啦啦啦，~~最简单~~的电风扇（dfs）（居然有大佬说不能用递归？！）

懒得写BFS，太繁琐了。

程序不喜勿喷
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100];//数组484开大了点（记录输出序列）
bool bz[100];//记录是否取过
int n,r;
void dfs(int l,int now)
{
	if(l==r) //如果搜完
	{
		for(int i=1;i<=l;i++) printf("%3d",f[i]);//格式输出
		cout<<endl;
		return;
	}
	for(int i=now+1;i<=n;i++)
	{
		if(!bz[i]) //如果没取过
		{
			f[l+1]=i;//填入数组
			bz[i]=1;//标记
			dfs(l+1,i);//递归
			f[l+1]=0;//抹掉标记，回溯
			bz[i]=0;
		}
	}
}
int main()
{
	cin>>n>>r;
	dfs(0,0);//简短的主程序~QwQ
	return 0;
}
```
Byebye~

~~管理大大看在《未成年人保护法》的份上（QwQ，上初一），给我过吧~~

---

## 作者：liuzitong (赞：5)

~~没有dalao找规律啊,
这规律应该很明显吧~~

好吧,是因为我太弱了,连枚举搜索都不会打

观察一下样例

  1  2  3
  
  1  2  4
  
  1  2  5
  
  1  3  4
  
  1  3  5
  
  1  4  5
  
  2  3  4
  
  2  3  5
  
  2  4  5
  
  3  4  5
  
  
 ### 我们~~容易~~发现
  
 ### 每一次都是最后一位+1,然后倒数第k列不能超过n - k
 
### 如果超过了,那么k - 1列+ 1,k列 = k - 1列 + 1,(这个过程我们叫做进位吧).
### 不过这个规律只适用于进一位,观察一会后发现,在进位过程中如果进多位

### 则从k - (进的位数) 开始有a[i] = a[i - 1] + 1,如果第0列进位,那么所有情况已经写完

交代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];
int main(int argc, char const *argv[])
{
	int n,m;
	cin>>n>>m;
	for (int i = 0; i <= n; ++i)//第一行永远是a[i] = i,a[0] 的话可以设也可以不设
	{
		a[i] = i;
		/* code */
	}
	while(a[0] == 0){//a[0] 如果进位了就结束
		for (int i = 1; i <= m; ++i)//打印
		{
			cout<<setw(3)<<a[i];//别忘了域宽,我被坑了2次
			/* code */
		}
		cout<<endl;
		a[m] ++;//开始进位
		if (a[m] > n)//这个if不要也行
		{
			int k = m;//k统计进到几位
			while(a[k] > n - (m - k)){//进位
				a[k - 1] ++;
				if (k - 1 == 0)//改变a[0]直接退出
				{
					return 0;
					/* code */
				}
				k --;
			}
			k ++;//每次都多－了一次,加上
			for (int i = k; i <= m; ++i)//进位
			{
				a[i] = a[i - 1] + 1;
				/* code */
			}
			/* code */
		}
	}
	return 0;
}
```

最后弱弱的问一句":这个找规律需要很多说明吗

可怜一下连搜索都不会的蒟蒻吧

---

## 作者：zhengleyang (赞：4)

本人萌新，第一次发题解，请见谅

其实本题不用回溯，只要纯DFS
（具体见代码第15行）



```cpp
#include<bits/stdc++.h>
using namespace std;

int n,r,pr[25];//n,r如原题义，pr是储存每种排列情况并用于输出的数组 

void dfs(int dep)
{
	if(dep==r+1)//如果个数到达，输出 
	{
		for(int i=1;i<=r;i++)
			printf("%3d",pr[i]);//格式 
		printf("\n");//格式 
		return;//返回
	}
	for(int i=pr[dep-1]+1;i<=n;i++)//这样循环，避免排列中后面的数小于(等于)前面的，造成结果重复或混乱，也不用回溯 
	{
		pr[dep]=i;//储存 
		dfs(dep+1);//每次进入下一层dfs 
	}
}

int main()
{
	cin>>n>>r;
	pr[0]=0;//选择pr[1]时不用特判，因为pr[0]已赋值 
	dfs(1);
	return 0;
}

```

求上

---

## 作者：523555337a (赞：4)

这题的话，爆搜就过了QWQ
题目要求排列组合
那么每个数肯定不能重复
又因为是组合，所以顺序就要考虑
设minn是当前的值，那循环的时候从minn+1开始
（既避免重复，又保证顺序）
具体的看半AC代码
```
#include<bits/stdc++.h>//万能库大法好 
using namespace std;
int n,r;//n和r按题目来 
int a[30];//开22个就够了 
void work(int n1,int minn)//搜索 ，n1-1是指搜到第几个数，minn用来去重 
{
	if(n1==r+1)//如果取到了r个数就输出 
	{
		for(int j=1;j<=r;++j)
		  cout<<setw(3)<<a[j];//记得设置场宽 
		cout<<endl;//换另一组的时候回车 
	}
	  else for(int i=minn+1;i<=n;++i)//从Minn+1开始 ，从1取到n，循环末尾就是N 
	  {
	  	a[n1]=i;//把数字存起来 
	  	work(n1+1,i);// 往下继续搜 
	  }
	return ;
}
int main()
{
	work(1,0);//搜索 
	return 0;
}
```


---

## 作者：C20212724杨京朝 (赞：3)

搜索（回溯）
------------
【题目】排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r<＝n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。现要求你不用递归的方法输出所有组合。

------------
深搜思路：
两个数组，一个ans[ ]记录答案，另一个used[ ]记录是否使用过，回溯思路就不解释了，注意题目中要求的数字是从小到大，这里有两种处理方式。

------------
80分代码：（TLE）

    #include <cstdio>
    int ans[25],used[25],n,r;
    void print() {//搜完之后对ans数组进行判断并输出
        for(int i = 1;i <= r;i ++) if(ans[i] < ans[i - 1]) return;
        for(int i = 1;i <= r;i ++)	printf("%3d",ans[i]);//三个场宽
        printf("\n");//换行
    }
    void dfs(int cur) {//搜索：太简单了不解释，不懂得题目下面私信我
        if(cur == r + 1) {
            print();
            return;
        }
        for(int i = 1;i <= n;i ++) {
            if(used[i] == 0) {//搜索下一层并回溯
                ans[cur] = i;
                used[i] = 1;
                dfs(cur + 1);
                ans[cur] = 0;
                used[i] = 0;
            }
        }
    }
    int main() {
        scanf("%d %d",&n,&r);
        dfs(1);
        return 0;
    }
------------
AC代码：

    #include <cstdio>
    int ans[25],used[25],n,r;
    void print() {
        for(int i = 1;i <= r;i ++) {
            printf("%3d",ans[i]);
        }
        printf("\n");
    }
    void dfs(int cur,int f) {//两个参数，一个记录当前次数，一个是目前的最大值
        if(cur == r + 1) {
            print();
            return;
        }
        for(int i = f + 1;i <= n;i ++) {//从f往后枚举，确保数字依次递增
            if(used[i] == 0) {
                ans[cur] = i;
                used[i] = 1;
                dfs(cur + 1,f = i);
                ans[cur] = 0;
                used[i] = 0;
            }
        }
    }
    int main() {
        scanf("%d %d",&n,&r);
        dfs(1,0);
        return 0;
    }
------------
PS：太水了，5分钟的题，应该没人会看吧。。。

---

## 作者：syf1201 (赞：3)

```cpp
#include<cstdio>
using namespace std;
int n, r, a[21];
void print() //输出函数
{
    for(int i=r; i>0; i--) //因我为了方便反向存储所以输出你懂得
        printf("%3d", a[i]);
    printf("\n");
}
void dfs(int x, int y) //搜索函数
{
    if(x==0){ //边界条件（是否已存入r个元素）
        print();
        return;
    }
    for(int i=y; i<=n-x+1; i++) //为寻找所有组合，使用循环加搜索
    {
        a[x]=i; //保存该数
        dfs(x-1, i+1); //寻找下一个数
    }
}
int main()
{
    scanf("%d%d", &n, &r); //读入，不解释
    dfs(r, 1); //搜索的开端
    return 0;
}
```

---

## 作者：二元长天笑 (赞：3)

天笑刚开始看的时候，想到了递归，但是后面想一想似乎还要回溯，所以肯定就是搜索了，然后整道题的大体思路就出来了。其实就是利用搜索，**往后**（注意，是往后面找而不是全盘找，否则会重复！）进行寻找，找到一个就让计数器加1，然后标记一下，够了就输出，然后再回溯再找。当天笑认为这道题就这么容易的时候，天笑就把代码交了上去，一下来：10分！再仔细一看题，才发现了本题最坑的地方：输出数字间不是隔一个空格，而是三个场宽，但也没事，改一改就行了。至于有些C/C++的朋友们不知道怎么改，我就在这里说一下啦：

1：用 **printf** ，代码如下：


**printf ("%3d",a);   //a可以为数组或单个变量**

2：用 **cout** ，代码如下：**（一定要调用  iomanip  库）**


**cout<<setw(3)<<a;  //a可以为数组或单个变量**

然后这道题就可以用最普通的搜索搞定啦，下面是AC代码：


```cpp
#include<iostream> 
#include<cstdio> 
int ss(int,int); 
int sc(); 
bool b[10001]={0}; 
long long a[10001]={0}; 
long long c[10001]; 
int n,k,sum,ans,z=1; 
using namespace std; 
int main() 
{ 
    cin>>n>>k; 
    ss(1,z); 
} 
int ss(int j,int z) 
{   
    int i;   
    for(i=z;i<=n;i++)   
    {   
        if(!b[i])   
        {  
            a[j]=i;   
            b[i]=1;   
            if(j==k)   
            {   
                sc();   
            }   
            else
            { 
                z=z+1; 
                ss(j+1,z); 
            }   
            b[i]=0;   
        }   
    }   
}  
int sc() 
{   
    for(int i=1;i<=k;i++)   
    {   
        printf("%3d",a[i]);
    }
    cout<<endl;   
}
```

请对天笑多多支持！


---

## 作者：williamllk (赞：2)

非常明显，这是一道回溯的题目。[组合的输出](https://www.luogu.com.cn/problem/P1157)

这个代码可分为三个部分：一个主程序，两个函数

主程序不必说，直接上代码
```cpp
int main(){
    cin>>n>>r;
    search(1);
}
```
如此简单易懂

接下来就是两个函数：

第一个名为“search”，解析都在代码上了，自己看
```cpp
int search(int k){
    int i;
    for(i=1;i<=n;i++)
	if(!b[i]&&i>a[k-1]){ //第一个判断是否使用过这个数，第二个判断为了保证后面的数大于前面的数 
	    a[k]=i; //加入输出队列 
	    b[i]=1; //标记使用过 
	    if(k==r) print(); //输出函数 
	   	else search(k+1); //继续 
	    b[i]=0; //很重要 ,如果删了那么就只剩了第一个数为 1 的序列 
	}
}
```
如果仔细看过上面的程序，会发现里面有一个print()，这就是后面的输出函数，输出的就是a数组里存的数
```cpp
int print(){
    for(int i=1;i<=r;i++)
	cout<<setw(3)<<a[i]; //每个数字占三位 
    cout<<endl;  //记得换行 
}
```
over [宣传一下](https://williamllk.blog.luogu.org)

---

## 作者：变成一名fw (赞：2)

搜索加回溯；

嗯……

**看题目**

排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r<＝n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。

既然如此

好吧

题目还是比较 ~~简单~~ 的

C++党注意

**3** 个场宽

呃……

不多说了

***上代码***

***
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r;
int a[30];
void dfs(int h)
{
    int i;
    if(h==r)
    {
        for(i=0;i<=r-1;i++)
        {
            if(a[i]<10)//三个场宽我这个蓝名蒟蒻写不出来，见谅。
        cout<<"  "<<a[i];
        else
        if(a[i]>=10 && a[i]<=99)
        cout<<" "<<a[i];
        else
        if(a[i]>=100)
        cout<<a[i];	
    }   
    cout<<endl;
    return ;
    }
    for()//for的条件自己想想，抄题解可是会棕的哦！
    {
        a[h]=i;
        dfs(h+1);
    }
}
int main()
{
    cin>>n>>r;
    dfs(0);
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

############啊哈！刚刚AC了这道题目，突然灵感大发，想出一道题解（生平第一个题解，好兴奋！！）

组合的输出与全排列不一样的是他要输入两个数n,r。n个元素中抽出r个元素排列，那么结构和全排列大体相似，只需要改变其中的几个地方。

那么代码如下：

```cpp
var
  i,j,n,r:longint;
  a:array[0..21] of longint;//a数组为填的那个数
  b:array[0..21] of boolean;//b数组用来判断这个格子还能不能填。
procedure p(k:longint);//回溯过程！k为目前要填第k个格子。
var i:longint;
begin
  if k>r then begin for i:=1 to r do write(a[i]:3);writeln;exit;end;//首先加一个判断，如果k>r，那么就说明格子已经填完了，就输出。
  for i:=a[k-1]+1 to n do//因为要比前一个数大，所以循环可以这样循环。
    if b[i] then begin//如果这一个格子没有数，那么就填掉来
      a[k]:=i;//把i填到第k个格子中
      b[i]:=false;//这个格子不能填了
      p(k+1);//继续回溯，填下一个格子
      b[i]:=true;//别忘了回溯！！这个格子重新为true
    end;
end;
begin
  readln(n,r);
  fillchar(b,sizeof(b),true);
  p(1);//从第一个格子填起
  //close(input);
  //close(output);
end.

```

---

## 作者：自动Wrong机 (赞：2)

var n,m:longint;//我曾经用integer，90分，千万千万用longint

```cpp
l:array[0..21] of longint;//小数组
procedure print;//自创无参子程序
var i:longint;begin
for i:=1 to m do write(l[i]:3);writeln;end;//记住是场宽，不是空格（我也错过），还要换行！！！writeln！！！
procedure create(x,min:longint);//递归子程序
var i:longint;begin
if x>m then print else for i:=min to n do begin l[x]:=i;create(x+1,i+1);//递归
end;end;
begin read(n,m);create(1,1);end. //主程序好短吧
```

---

## 作者：liyifan24 (赞：1)

简单的DFS，适合初学者
少废话，上代码：
```cpp
#include<cstdio>
#include<cmath>
#include<bits/stdc++.h>
using namespace std;
int n,m;
int total; 
int num[10001];    
bool mark[10001]; 
void print()    
{
	for(int i=1;i<=m;i++)
	 cout<<setw(3)<<num[i];//符合题目要求
     cout<<endl;
	total++;
}
void search(int x)  
{  
	for(int i=1;i<=n;i++)//选择所有情况
		if(!mark[i]&&num[x-1]<i)
        //判断是否用过以及是不是比前一个大 
		{
			num[x]=i;
			mark[i]=true; 
			if(x==m) print();//特别注意这里是m 
			search(x+1); 
			mark[i]=false;//回溯
		}
}
int main()
{
	scanf("%d%d",&n,&m);
	num[0]=-1;//这里必须要赋值，否则num[1]进不去
	search(1);  //开始DFS
	return 0;
}
```

---

## 作者：DaftLord (赞：1)

//喜闻乐见的搜索；

这道题其实就是加强版的全排列问题，不同点就是要注意**每个数必须大于前一个数**。

var a:array[1..21] of longint;//a数组用来存储要输出的数

b:array[1..21] of boolean;//b数组用来存储每个数是否用过



```cpp
    n,r,i:longint;
procedure search(x:longint);//搜索过程
var j:longint;
begin
 if x>r then //如果搜完了r个数就输出
 begin
  for j:=1 to r do write(a[j]:3);
  writeln;//别忘记换行
  exit;
 end;
 for j:=1 to n do
  if b[j] and (j>a[x-1]) then//这里需要注意，挑选的数必须比前一个数大
  begin
   a[x]:=j;//存数
   b[j]:=false;
   search(x+1);//搜索
   b[j]:=true;//回溯
  end;
end;
begin
 readln(n,r);
 fillchar(b,sizeof(b),true);//初始化，一开始没有数是被用的
  search(1);//搜索
end.
```

---

## 作者：火星大王 (赞：1)

注意输出格式，一定要注意输出格式，用printf输出要打printf("%3d",a[j]);，打printf("%d",a[j]);得10分

呵呵呵


    
    
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,r;
int a[40]={0};
int b[40]={0};
void dfs(int rr)
{
    int i,j;
    for(i=1;i<=n;i++)
    {
        if(b[i]==0&&a[rr-1]<i)
        {
            a[rr]=i;
            if(rr==r)
            {
                for(j=1;j<=r;j++)
                {
                    printf("%3d",a[j]);
                }
                printf("\n");
            }
            else
            {
                b[i]=1;
                dfs(rr+1);
                b[i]=0;
            }
        }
    }
}
int main()
{
    //freopen("zuhe.in","r",stdin);
    //freopen("zuhe.out","w",stdout);
    cin>>n>>r;
    dfs(1);
    return 0;
}
```

---

## 作者：zqy1018 (赞：1)

非递归版本。

提示：本题有个点很坑，会超时

```cpp
#include <cstdio>
using namespace std;
int a[25],n,k,at=1,big=1,t;
int main(){
    scanf("%d%d",&n,&k);if(k==0)return 0;//对付坑点
    t=1;for(int i=1;i<=k;i++)t=t*(n-i+1)/i;//计算排列组合方案数
    do{
        if(at<k){a[at++]=big;big++;}//如果当前所在数字不是最后一个就填入
        else{
            while(big<n+1){
                a[k]=big;
                for(int i=1;i<=k;i++)printf("%3d",a[i]);printf("\n");
                t--;big++;
            }//输出方案
            while(at>0&&a[at]==at+(n-k))at--;//此处为回溯
            a[at]++;big=a[at];//更新方案
        }
    }while(t);//共输出t个组合
    return 0;      
}
```

---

## 作者：飞翔 (赞：1)

#题解：

最好用非递归做。

程序中还要用到回溯的思想：

** 判断a[i]-i是否<=n-r，如果条件成立，就继续朝下运行，如果i=r就输出，等等，如果条件不满足，就dec(i);inc(a[i]) **

贴代码：

```delphi
var
  i,j,n,r:integer;
  a:array[0..21]of integer;
begin
  readln(n,r);
  for i:=0 to r do a[i]:=i;
  i:=0;
  while a[0]=0 do
  begin
    if a[i]-i<=n-r then
      if i=r then
      begin
        for j:=1 to r do write(a[j]:3);
        writeln;
        a[i]:=a[i]+1;
      end
      else
      begin
        i:=i+1;
        a[i]:=a[i-1]+1;
      end
    else
      if i>0 then
      begin
        i:=i-1;
        a[i]:=a[i]+1
      end;
  end;
end.
```
递归可以过，但我个人不建议使用（别无视题目）。

题目的场宽要注意啦，是:3，不是一个空格……

好啦完成！


---

## 作者：kuaituo (赞：1)

```
#include<cstdio>

using namespace std;
int ans[50],b,c[50],d,li[50]; 


void dfs(int m)
{
    if(m>d){
        
        {
            for(int i=1;i<=d;i++)
    		{
    			printf("%3d",ans[i]);
            }
            printf("\n");
        }
        return;
    }
    for(int i=ans[m-1];i<=b;i++)
    {
        if(c[i]!=1)
        {
            c[i]=1;
            ans[m]=i;
            dfs(m+1);
            c[i]=0;		
        }
    }
}
int main(){
    scanf("%d%d",&b,&d);
    ans[0]=1;
    dfs(1);
    return 0;
}
```
本题是在全排列问题上进行了变形，但要注意下列代码会出现超时，
应通过改变循环条件避免重复计算。
```
#include<cstdio>
#include<cstdio>

using namespace std;
int ans[50],b,c[50],d,li[50]; 

bool ju()
{
    int li;
    for(int i=1;i<d;i++){
        li=ans[i+1]-ans[i] ;
        if(li<0)
        return 0;
    }
    return 1;
    
}
void dfs(int m)
{
    if(m>d){
        if(ju()==1)
        {
            for(int i=1;i<=d;i++)
    		{
    			printf("%3d",ans[i]);
            }
            printf("\n");
        }
        return;
    }
    for(int i=1;i<=b;i++)
    {
        if(c[i]!=1)
        {
            c[i]=1;
            ans[m]=i;
            dfs(m+1);
            c[i]=0;		
        }
    }
}
int main(){
    scanf("%d%d",&b,&d);
    dfs(1);
    return 0;
}
```

---

## 作者：吴爽wh (赞：1)

```cpp
#include <cstdio>
using namespace std;
    int n,r,cnt=0, a[21];
inline void search(int x,int y)  {
	//x为上个最大的数，y为还剩几个数
    if (!y)  {//输出
        for (register int i=1; i<=r; ++i)  {
            printf("%3d",a[i]);//注意场宽
        }
    	printf("\n");
        return;
    }
    for (register int i=x+1; i<=n-y+1; ++i)  {//其实不用怕重复，只要注意枚举顺序
    	//从上一个最大的+1开始到最大的一个（再大后面的放不了）
        a[++cnt]=i;//a数组存放每组排序
        search(i,y-1);（枚举下一个）
        --cnt;//a数组不用管重复，只要覆盖掉就可以了
    }
}
int main()  {
    scanf("%d%d",&n,&r);
    search(0,r);
    return 0;
}
```

---

## 作者：jinhangjie2006 (赞：0)

深搜模板

```cpp
var
  n,m:longint;
  a,b:array[-1..22] of longint;
 procedure try(t:longint);
   var
    i,j:longint;
  begin
   if t=m then//到达了m个数，输出；
      begin
       for j:=0 to t-1 do write(b[j]:3);//t是从0开始搜索的，所以数组的下标从0开始存放；
        writeln;
       exit;
     end;
   for i:=b[t-1]+1 to n do//这m个数，当前数的一定比前面的数大，所以从前一项+1开始搜索；
     begin
       if a[i]=0 then//每个数只能用一次，没用的标记为0；
           begin
            a[i]:=1;//这个数用了，标记为1；
            b[t]:=i;//存放进b数组；
            try(t+1);//下一层；end;
            a[i]:=0;//回溯，a[i]清0；
            b[t]:=0;//清0
end;
end;
end;
begin
  read(n,m);
  try(0);//开始搜索
end.
end.

```

---


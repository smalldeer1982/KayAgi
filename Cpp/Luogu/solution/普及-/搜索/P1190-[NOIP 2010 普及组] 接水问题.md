# [NOIP 2010 普及组] 接水问题

## 题目描述

学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。

现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。

现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。


## 说明/提示

【输入输出样例 \#1 说明】

第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。

第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。

第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。

第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。

【数据范围】

$1 \le n \le {10}^4$，$1 \le m \le 100$，$m \le n$；

$1 \le w_i \le 100$。

NOIP2010 普及组 第二题


## 样例 #1

### 输入

```
5 3
4 4 1 2 1
```

### 输出

```
4```

## 样例 #2

### 输入

```
8 4
23 71 87 32 70 93 80 76
```

### 输出

```
163```

# 题解

## 作者：lk_liang (赞：1573)

## 模拟题


我的代码量很少也比较简单 建议不会的朋友看我的（~~傲娇~~）

这次与上次的题解相比改进了一点 希望管理员通过

 **~~话说我第一次通过审核了 改进了一下管理员咋不批准了。。。~~ ** 

下面进入正题
------------


1. 首先我们要知道模拟什么

   根据题意

   我们要求所有同学都接完水需要多少秒。
   
   那么我们就模拟他们接水的过程
   
   **我们可以用一个循环模拟m个水龙头一秒的接水量** （循环一次就是一秒）
   
   **当然要到数组**
   
   数组下标就是每个水龙头的标号 （1-m）
   
   那么数组的值就是对应的学生对应的接水量
   
   刚开始时1-m个水龙头默认的对应1-m编号学生的接水量
   
   一旦有一个学生接完了 那么就让下一个等待接水的学生来这个水龙头接水
   
   用代码实现的话就是**让下个学生对应的接水值赋值这个这个水龙头对应的数组**
   
   先看这一段的代码
   
		for(int i=1;i<=m;i++)     //  枚举m个水龙头 
		{
			s[i]--;
			if(s[i]==0)
			{
				s[i]=s[t];     //  如果这个学生的水接完了 模拟换下一个学生来这个水龙头
				t++; 
			}
		}
		ans++;      //  以上是模拟的1秒钟的接水时间 所有ans加一 
   
   
    这里的t就是下个等待接水的学生的编号
   

------------

   
核心代码讲完了 来处理下细节 就搞定了
------------

   
   2.当然上面的代码是套在一个while里的  那么循环的终止条件是什么呢
   
   首先我像大家解释t的初始值为m+1 因为一开始m个学生在接 下一个学生就是m+1
     
   那么循环的终止条件就是（t<=m+n)
     
   因为n个学生都接完水会让t最终加n个1 但t的初始值又是m+1
     
   所以当t=m+n+1时意味着所有学生都接完水了 （建议认真思考下这）
   
   下面是完整的AC代码 如果上面有不清楚的地方请借助代码理解
     
	    #include <iostream>
	    using namespace std;
	    int s[11000],ans;    // 根据t的终止条件来想下s的大小
		int main()
		{
		int n,m;cin>>n>>m;
        for(int i=1;i<=n;i++) cin>>s[i];    //  输入每个学生的接水量
		int t=m+1;   // t用来记录下个学生的编号 
		while(t<=n+m)
		{
			for(int i=1;i<=m;i++)     //  枚举m个水龙头 
			{
				s[i]--;
				if(s[i]==0)
				{
					s[i]=s[t];     //  如果这个学生的水接完了 模拟换下一个学生来这个水龙头
					t++; 
				}
			}
			ans++;      //  以上是模拟的1秒钟的接水时间 所有ans加一 
		}
			cout<<ans;
			return 0;
		} 
     
   写题解不易 还望各位点个赞！ 

---

## 作者：xxckie (赞：23)

小学生又来发题解啦！

想必各位dalao都把这道题看复杂了，其实本题只要掌握想法，写起程序就非常easy了.

### 立刻进入正题——

首先，我们理解了题目，哪个人装完水之后，就轮到队伍的下一个人来接水.So,下一个来接水的人，一定是去**当前装水的m个人中最快的那个人的位置**继续装水.

Then,我们就可以从第m+1个人开始帮他找位置（PS：为什么不是从第一个人开始？因为前m个人已经在装水了，他们的位置随便定（写程序的时候不用管））.因为要去速度最快的那个人的位置，所以，**到那个位置装水的人的时间之和**也是最短的！

那么，我们就可以利用数组中前m个位置来储存相对应位置接水的人时间之和.这样的话，每次就可以先找m个接水位置中，当前时间之和最短的来装水（即把a[i]加到a[1]（当前总用时最短的位置）），就OK啦.

最后，再看一下前m个位置中那个用的时间是最短的，cout就可以完成啦！

#### 下面是代码——
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>

using namespace std;
long long n,m;
int a[10010];
bool cmp(int x,int y)
{
	return x>y;//从大到小排序的函数
}
int main()
{
	scanf("%I64d%I64d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);//输入每个人装水的时间
	for(int i=m+1;i<=n;i++)//从第m+1个人开始给TA找位置
	{
		sort(a+1,a+1+m);//sort一下，看看哪个位置总用时最短
		a[1]=a[1]+a[i];//找到之后，把第i个人的时间加上去就好啦（代表那个人已经装完水了）
	}
	sort(a+1,a+1+m,cmp);//最后看一下哪个位置用时最长
	cout<<a[1];//输出最长的那个位置就perfect啦
return 0;
}

```
这道题本蒟蒻就是这样子做的啦，各位dalao有什么问题的话，在右边评论区告诉我哦，下次再见~~

---

## 作者：WsW_ (赞：5)

### 思路
其实这题不是很贪心，更偏模拟。  
注意到**初始接水顺序已经确定**，说明我们不能改变接水顺序，只要按照这个顺序模拟。  
每次要求当前学生中，**最早**接完水的，并让下一个人去接。由于是求**最早**，容易想到用堆来维护正在接水的人。  
堆中只要存每个人接完水的时间，每次取出这些时间中最早的，并让下一个人上。假设最早接完水的人在第 $t$ 秒接完水，下一个人要接 $w$ 秒，那下一个人就得在第 $t+w$ 秒接完水。所以把 $t$ 取出后，再将 $t+w$ 加入栈中。  

最终把所有元素取出堆，里面最大的就是答案。

可以用 `priority_queue` 直接维护堆。  

时间复杂度为 $O(n \log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,w;
int t;
priority_queue<int,vector<int>,greater<int>>q;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&w);
		q.push(w);
	}
	for(int i=1;i<=n-m;i++){
		t=q.top();
		q.pop();
		scanf("%d",&w);
		q.push(t+w);
	}
	while(q.size()>1)q.pop();
	printf("%d",q.top());
	return 0;
}
```

---

## 作者：LinkyChristian (赞：3)

# 模拟 + 贪心
就是这道题的基本思路。
怎么做呢？
## 模拟接水的过程
1. 先让前 $m$个人接水。
做一个函数，判断是否所有人都接水完成：
```
bool empty()
{
	for(int i=1; i<=n; i++) if(w[i]) return false;//一旦遇到不为零的，返回false
	return true;
}
```
有了这个函数，我们就可以做一个$while$循环来模拟整个接水的过程。
2. 每当有人接水结束时，将另一个还未接水的人与此人交换，替补此人上来接水。具体过程如下：

每次判断$w[i]$是否为零，是，则从$m+1$向$n$搜索，将遇到的第一个不为零的$w[j]$与$w[i]$交换（将$w[j]$插入队列），同时将$w[j]$--。否，则将$w[i]$--。


        3. 每次循环之后T++，让时间流逝。
        
最后上代码：
```
#include<iostream>
using namespace std;
int n,m,w[23333],T;

bool empty()
{
	for(int i=1; i<=n; i++) if(w[i]) return false;
	return true;
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1; i<=n; i++) cin>>w[i]; 
	
	while(!empty())
	{
		for(int i=1; i<=m; i++) {
            if(w[i]) w[i]--;
            else for(int j=m+1; j<=n; j++) if(w[j]) {swap(w[i],w[j]);w[i]--;break;}
		}
		T++;
	}
	cout<<T;
	return 0;
}
```

---

## 作者：sieve (赞：2)

## 题解：[P1190](https://www.luogu.com.cn/problem/P1190)

## 思路

直接用优先队列，把 $a_1 , a_2 \cdots a_m$ 全部放进去，注意是放进去负的，因为我们用的是大根堆。

然后从 $m + 1 \sim n$，取出堆顶，堆顶为 $tmp$，删掉堆顶，然后将 $a_i - tmp$ 丢进去。

最后找到堆中的最大值，输出即可。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
int a[1000005],vis[100005],pos;
priority_queue<int,vector<int>,greater<int>> q;
signed main()
{
//	freopen("ccc.in","r",stdin);
//	freopen("ccc.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		if(i<=m) q.push(a[i]);
	}
	for(int i=m+1;i<=n;++i)
	{
		int tmp=q.top();
		q.pop();
		q.push(a[i]-tmp);
	}
	int mx=0;
	while(!q.empty())
	{
		mx=max(mx,q.top());
		q.pop();
	}
	cout<<mx;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
这题，我采用了[小根堆](https://blog.csdn.net/Zj_boring/article/details/105157360)的方式来做。
```cpp
priority_queue<int, vector<int>, greater<int> >p;
```

那么，如果接水人数不大于龙头个数，那最大接水量就是答案。

否则，把所有接水量用小根堆中的 $push$ 存进堆中，再一一将最小接水量 $pop$ 出堆。这样也就可以了。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, t, minn = 0, maxn = 0;
priority_queue<int, vector<int>, greater<int> >p;

int main() {
	cin >> n >> m;
	if (n <= m) {
		for (int i = 1; i <= n; i++) {
			cin >> t;
			maxn = max(t, maxn);
		}
	} else {
		for (int i = 1; i <= m; i++) {
			cin >> t;
			p.push(t);
		}
		for (int i = m + 1; i <= n; i++) {
			cin >> t;
			minn = p.top();
			p.pop();
			p.push(t + minn);
		}
		for (int i = 1; i <= m; i++) {
			maxn = p.top();
			p.pop();
		}
	}
	cout << maxn << endl;
	return 0;
}
```

---

## 作者：mairuisheng (赞：1)

[P1190 [NOIP2010 普及组] 接水问题](https://www.luogu.com.cn/problem/P1190)

主要算法：贪心

分析：想要得到最优的接水方案，就要使每个水龙头接水量的最大值最小，因为他们的初始接水顺序已经确定，所以每次把当前同学的接水量加到目前接水量最小的水龙头上，最后统计所有水龙头中最大的接水量作为答案。
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
inline int read()
{
	char s;
	int x=0;
	s=getchar();
	while(s>='0'&&s<='9')
	{
		x=x*10+(s-48);
		s=getchar();
	}
	return x;
}
int max(int x,int y)
{
	return x>y?x:y;
}
int n,m,ans;
int p[101];//水龙头接水量
int main()
{
	int i,j,minn,k,x;
	n=read();
	m=read();
	for(i=1;i<=n;++i)
	{
		x=read();
		minn=2147483646;//设为一个较大值，方便比较
		for(j=1;j<=m;++j)
		{
			if(p[j]<minn)//找到比目前接水量小的水龙头
			{
				minn=p[j];
				k=j;//保存编号
			}
		}
		p[k]+=x;//将这位同学分配到第k个水龙头
	}
	for(i=1;i<=m;++i)ans=max(ans,p[i]);//取最大值
	printf("%d",ans);
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：1)

本题算法：模拟。  
难度：红或橙。（个人建议为红）  
题目就是让我们模拟整个接水的过程：当一个人接完水后另外一个人就会马上接替他继续接水（不会浪费），当水龙头多余的时候就把多余的水龙头关闭。我们可以用 $while$ 循环来模拟。当 $j≤n+m$ 时就可以继续进行操作。每次将 $w_i$ 减一，也就是将你还要接的水量减少。接完就让下一个人接水，最后把下标 $j$ 更新并让时间加一即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,w[1000005];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>w[i];
    int j=m+1,ans=0;
    while(j<=n+m)
    {
    	for(int i=1;i<=m;i++)
    	{
    		w[i]--;
    		if(w[i]==0) 
    		{
    			w[i]=w[j];
    			j++;
			}
		}
		ans++;
	}
	cout<<ans;
	return 0; 
} 
```

---

## 作者：EarthGiao (赞：1)

## 【思路】
  
贪心 + 模拟    
又是没读好题目惹的祸，    
导致明明是一道很好做的题目花了好久的时间   
明明没有那么复杂，只需要输入的顺序排队就好     
我却因为没读好题目   
想贪心将没接水的人里面需要接水最多的人   
和正在接水的某一个水龙头上目前需要接水的人的接水总量最少的那一个组合在一起   
还想当然的弄了两个优先队列，   
没想到需要按照输入的顺序   
不能插队啊！插队是不文明行为！   
  
贪心思想：   
目前这个需要接水的人应该去水龙头里面目前需要接水的人的接水总量最少的那一个    
这样会使消耗的时间最少   
因为除了选择那一个接水总量最少的，  
你选择别的都会有可能使需要消耗的时间   
也就是接水总量最大值变得更大    
因为 如果 a > b,现在你有一个c，   
你放到a里面之后加起来的值a + c 一定小于 b + c
这是很显然的     
   
只需要用一个优先队列和一个普通队列来储存他们排队的顺序来处理   
现将前m个放入优先队列（小根堆）中，剩余的放入普通队列    
每一次都把普通队列的队首和优先队列的队首（即最小值）拿出来相加起来   
然后再放进优先队列里面   
这样重复下去直到普通队列变为空   
最后输出优先队列里面最后一个元素   
也就是最大值就可以了    

## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
queue<int>q;
priority_queue<int,vector<int>,greater<int> > s;
int main()
{
	int n,m;
	int qwq;
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m;++ i)
		scanf("%d",&qwq),s.push(qwq);
	for(int i = m + 1;i <= n;++ i)
	{
		scanf("%d",&qwq),q.push(qwq);
	}
	while(!q.empty())
	{
		int awa = q.front();q.pop();
		int owo = s.top();s.pop();
		s.push(awa + owo);
	}
	int ans;
	while(!s.empty())
	{
		ans = s.top();
		s.pop();
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Priori_Incantatem (赞：1)

先计算好每一个人都在哪一个水龙头接水，求出每个水龙头使用的时间，使得每个水龙头用的时间差尽量的小（浪费的时间最少）

$n$人接水，只有$m$个水龙头，所以前$m$个人先接水。谁先接完，谁就把水龙头让给下一个人

开始，每个水龙头的使用时间分别为前$m$个人的接水时间。将其升序排列后，每次将下一个人安排给使用时间最少的水龙头，然后利用冒泡排序再次将水龙头排序。因为除第一个水龙头外，其他的水龙头已排序好，所以每次冒泡排序时间复杂度为$O(m)$

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const int Maxn=1e4+5,Maxm=100+5;
int a[Maxn],s[Maxm];//s表示每个水龙头的使用时间
int n,m;
int read()//快读，不理解的用scanf/cin代替
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0' && ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
    a[i]=read();
    for(int i=1;i<=m;++i)
    s[i]=a[i];//给前m个人安排水龙头
    sort(s+1,s+1+m);//排序
    for(int i=m+1;i<=n;++i)
    {
        s[1]+=a[i];//将下一个安排给用时最少的水龙头
        for(int j=1;j<m;++j)//冒泡排序
        if(s[j]>s[j+1])swap(s[j],s[j+1]);
        else break;
    }
    printf("%d\n",s[m]);//输出用时最长的
    return 0;
}
```

---

## 作者：yr409892525 (赞：0)

## 题解：P1190 [NOIP2010 普及组] 接水问题
直接贪心。             
只要水龙头空着就让人去接。             
先把前 $m$ 个人的节水时间放入
使用小根堆维护当前最先接完水的水龙头。            
再把它加上当前这个人节水的时间，继续放入优先队列中。            
答案为最后一个接完的水龙头。                     

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[100005];
priority_queue<int,vector<int>,greater<int>> q;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i<=m) q.push(a[i]);
	}
	for(int i=m+1;i<=n;i++){
		int t=q.top();
		q.pop();
		q.push(t+a[i]);
	}
	int ma=0;
	while(q.size()){
		ma=max(ma,q.top());
		q.pop();
	}
	cout<<ma;
	return 0;
}
```

---

## 作者：kuaiCreator (赞：0)

## 解题思路
记录每个水龙头放水的时间，由于接水的顺序是固定的故只能依次去接水。让第 $i$ 个接水的人选择放水时间最小的水龙头。对于 $n$ 个人每次从 $m$ 个水龙头中获取放水时间最小的水龙头时可以选择用快速排序 $O(m\log m)$，打擂法 $O(m)$ 或堆 $O(\log m)$ 。选出最小时间并累加该水龙头的放水时间。由于 $n,m$ 的数据范围比较小以上三种获取放水最小的水龙头的方法都可以通过本题，这里选用最快的堆的做法。

最后找到所有水龙头放水时间最长的即为所有人接完水时所花费的最短时间。

**贪心策略证明**：如果只有两个水龙头，两个人接水耗时为正数 $a$ 和 $b$，如果第二个人不去选择未接水的水龙头，那么最终所有人接完水时花费的时间为 $a$ 和 $b$，而贪心策略耗时为 $\max(a, b)$。必然存在 $a+b>\max(a,b)$，可以推广到 $n$ 个水龙头和 $m$ 个人的情况。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int, vector<int>, greater<int> > tap;//创建小根堆
int p[10005], n, m, k;
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++)                    //输入n个人接水的时间
		cin >> p[i];
	for (int i = 1; i <= m; i++)             //设置m个水龙头的放水时间为0
		tap.push(0);
	for (int i = 1; i <= n; i++) {                  //第i个人去找结束时间最短的水龙头接水
		int temp = tap.top();                       //取出用时最小的水龙头
		tap.pop();
		tap.push(temp + p[i]);                      //将放水后的水龙头入堆
	}
	for (int i = 1; i < m; i++)                     //弹出小根堆中元素只剩1个
		tap.pop();
	cout << tap.top();                              //最终留下的元素为打水所划分总时间
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：0)

一道模拟
## 思路
根据题意模拟，按顺序遍历每个人，对于每个人，找到一个总排队时间最小的水龙头，让那个人在此水龙头排队，并增加这个水龙头的总排队时间。最后找出最大总排队时间并输出。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int b[105],n,m,a[10005],maxn;//b数组是每个水龙头总排队时间
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int minn=1e9,x;
		for(int j=1;j<=m;j++)
		{
			if(b[j]<minn)//找到总排队时间最少的水龙头
			{
				minn=b[j];
				x=j;//记录位置
			}
		}
		b[x]+=a[i];//增加该位置总排队时间
	}
	for(int i=1;i<=m;i++)maxn=max(b[i],maxn);//找最大总排队时间
	cout<<maxn;//输出
  	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：0)

贪心题。

只要有水龙头空着就让人去接水。

计算时可以枚举现在是几时刻。

但是我们只需要每次减去在接水的人剩余水最少的需要多少时刻才能接完水，所有人减去这个时刻，有人接完水下一个人就立刻上来接水。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,cnt=0,sum=0;
int a[10005];
int q[10005];
signed main(){
//	freopen("ccc.in","r",stdin);
//	freopen("ccc.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		if(cnt<m){
			cnt++;
			q[cnt]=a[i];
		}
	}while(cnt<=n){
		int mini=1e9;
		for(int i=1;i<=m;i++){
			if(q[i]!=0){
				mini=min(mini,q[i]);
			}
		}for(int i=1;i<=m;i++){
			q[i]-=mini;
			if(q[i]==0){
				q[i]=a[++cnt];
			}
		}sum+=mini;
	}int maxi=0;
	for(int i=1;i<=m;i++){
		maxi=max(maxi,q[i]);
	}sum+=maxi;
	cout<<sum;
	return 0;
} 
```

---


# 小 A 的口头禅

## 题目描述

小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。


## 说明/提示

$1 \leq n,m \leq1000$。



## 样例 #1

### 输入

```
5 5
heheh
heheh
heheh
heheh
heheh
```

### 输出

```
10
```

# 题解

## 作者：kkksc03 (赞：114)

作为欢乐赛第一题，自然没有什么难度，标程也是搜索没有优化。本质上完全可以归入入门题一类。附程序：

```delphi

const st='hehe';
var n,m,i,j,s:longint;a:array[1..1000,1..1000]of char;
function find(x,y,k:longint):longint;              //在(x,y)第k个字符开始搜第k+1个
begin                                      //a[x,y]:=’ ‘;全用来标记
  if k=4 then exit(1);
  find:=0;
  if x>1 then
  if a[x-1,y]=st[k+1] then
  begin
  a[x,y]:=' ';
  find:=find+find(x-1,y,k+1);
  end;
  if y>1 then
  if a[x,y-1]=st[k+1] then
  begin
  a[x,y]:=' ';find:=find+find(x,y-1,k+1);
  end;
  if x<n then
  if a[x+1,y]=st[k+1] then
  begin
  a[x,y]:=' ';find:=find+find(x+1,y,k+1);
  end;
  if y<m then
  if a[x,y+1]=st[k+1] then
  begin
  a[x,y]:=' ';find:=find+find(x,y+1,k+1);
  end;
  a[x,y]:=st[k];
end;
begin
  readln(n,m);
  for i:=1 to n do
  begin
  for j:=1 to m do
  read(a[i,j]);
  readln;
  end;
  s:=0;
  for i:=1 to n do                          //搜第一个h
  for j:=1 to m do
  if a[i,j]='h' then
  s:=s+find(i,j,1);
  writeln(s);
end.

```
貌似很长，缩一下行不到40.


---

## 作者：微雨燕双飞 (赞：65)

表示本人是通过随机跳题来到这里的。。（只因为这道题的题号这么吸引人吗？）

做完才懂为什么这题准确率这么低，原来不是要求有多少个“he”，而是要求有多少个“hehe”，怪不得10分一大堆。不过这样例也太坑了，这么做都是对的。。。

好了不多说了，本题根本没必要搜索，跟p1101单词方阵一样，用枚举法就行了（貌似还是那题的退化版，当时我做那题时用的也是穷举）

下面献上AC代码：

```cpp
#include<iostream>
using namespace std;
int n,m;
char map[1005][1005];
int main()
{
  cin>>n>>m;
  for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++) cin>>map[i][j]; //读入方阵
  int ans=0;
  for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++)
      if(map[i][j]=='h') 如果有h，就枚举搜i
      {
        if(map[i-1][j]=='e'&&map[i-2][j]=='h'&&map[i-3][j]=='e') ans++; //向上穷举
        if(map[i+1][j]=='e'&&map[i+2][j]=='h'&&map[i+3][j]=='e') ans++; //向下穷举
        if(map[i][j-1]=='e'&&map[i][j-2]=='h'&&map[i][j-3]=='e') ans++; //向左穷举
        if(map[i][j+1]=='e'&&map[i][j+2]=='h'&&map[i][j+3]=='e') ans++; //向右穷举
      }
  cout<<ans<<endl; //输出答案
  return 0;
} //结束，感觉没什么难懂的吧？
```

---

## 作者：flyingFLY (赞：25)

~~这道题···也是十分的简单呢。    ——唳~~

首先列举一下本蒟蒻发现的坑坑：

## 1.找的是hehe而不是he
亲测，没有什么阔以讲的呢。。。
## 2.斜着的hehe不算
~~水淋淋~~友好的样例告诉大家，斜着的hehe是莫得灵魂的。
## 3.正着的和反着的hehe都算，自上而下或自下而上的hehe也算。
hehe，eheh都算,

h e

e h

h e

e h 也是算的，所以上下左右都要搜de。

~~废话好像有点多，直接为各位dalao奉上AC代码~~
# AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int ans,n,m;
char c[1100][1100];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];//把所有字符输入；
			if(c[i][j]=='h') if(c[i][j-1]=='e'&&c[i][j-2]=='h'&&c[i][j-3]=='e') ans++;//向左先搜一次；
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(c[i][j]=='h')
			{
				if(c[i][j+1]=='e'&&c[i][j+2]=='h'&&c[i][j+3]=='e') ans++;//向右再搜一次；
				if(c[i-1][j]=='e'&&c[i-2][j]=='h'&&c[i-3][j]=='e') ans++;//向上再搜一次；
				if(c[i+1][j]=='e'&&c[i+2][j]=='h'&&c[i+3][j]=='e') ans++;//最后再向下搞一次，完事；
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

~~蒟蒻第一篇题解，求过QAQ~~

---

## 作者：zjy111 (赞：8)

这题难度不大，本质上就是让你找有几个“hehe”或者“eheh”横竖都算

## 但是斜的不算！！！！（这是样例告诉我们的）

具体思路就是读入一个char型的二维数组，并且横竖去看有没有hehe或者eheh，如果有，就把答案+1即可。

对于具体的判断，就是从1到n、从1到m暴力枚举，看以这个点为起点有没有符合条件的字符串。好像其他大多数题解都是直接判断4次的，但其实每次判断第一个字符时，如果是h就不用判断eheh，如果是e就不用去管hehe的情况，这样可以使每次循环时少判断2次以节省时间（这题数据小，不过对于某些可能会TLE的题来说这样稍稍优化一下可能可以多A一个点）

献上码风奇特的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1005][1005];
int i,j,cnt=0,m,n;
int main(){
	cin>>n>>m;
	memset(a,' ',sizeof(a)); //初始化（不过不这么做似乎问题不大）
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++)
			cin>>a[i][j];  //读入char数组
	}
      for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j]=='h'){ //判断有没有hehe
				if(a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e')cnt++;  //横行有没有
				if(a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e')cnt++;  //竖列有没有
			}
           	if(a[i][j]=='e'){  //判断有没有eheh
				if(a[i+1][j]=='h'&&a[i+2][j]=='e'&&a[i+3][j]=='h')cnt++;  //横行有没有
				if(a[i][j+1]=='h'&&a[i][j+2]=='e'&&a[i][j+3]=='h')cnt++;  //竖列有没有
			}
		}
	}
    	cout<<cnt<<endl;
	return 0;
}
```


---

## 作者：CHHC (赞：8)

~~……这道题可以评入门 因为我这样的蒟蒻只能做入门题了~~

嗯，其实这道题还是很有教育意义的

.

## 样例看上去很水，但是至少告诉了我们：

-  **斜着的 hehe || eheh 是不合法的。**

.

除此之外……

我们打重复的代码的时候一定不要 ctrl+c and ctrl+v

~~比如我就因为 ctrl+c and ctrl+v 的时候忘记了改 i，j 去问dalao于是被dalao鄙视了~~

.

（废话好像太多了……上代码：

```
#include<bits/stdc++.h>
using namespace std；

#define MAXN 1000 + 10
char mp[MAXN][MAXN]；             //存储矩形 

int main()
{
	ios::sync_with_stdio(false);  //取消同步，可以加快cin cout的速度，
	                              //但是不能在读string的时候用 
	                              //（其实还是我太懒 && 蒻了）
	int N，M；cin >> N >> M；
	for( int i = 1；i <= N；i++ )
	{
		for( int j = 1；j <= M；j++ )
		{
			cin >> mp[i][j]；
		}
	}
	
	int ans = 0；
	for( int i = 1；i <= N；i++ ) //横着枚举，注意不要漏了“eheh”的情况 
	{
		for( int j = 1；j <= M-3；j++ )
		{
			if( mp[i][j] == 'h' && mp[i][j+1] == 'e' && mp[i][j+2] == 'h' && mp[i][j+3] == 'e' )
			{
				ans++；
			}
			if( mp[i][j] == 'e' && mp[i][j+1] == 'h' && mp[i][j+2] == 'e' && mp[i][j+3] == 'h' )
			{
				ans++；
			}
		}
	}
	for( int i = 1；i <= M；i++ ) //竖着枚举
	{ 
		for( int j = 1；j <= N-3；j++ )
		{
			if( mp[j][i] == 'h' && mp[j+1][i] == 'e' && mp[j+2][i] == 'h' && mp[j+3][i] == 'e' )
			{
				ans++；
			}
			if( mp[j][i] == 'e' && mp[j+1][i] == 'h' && mp[j+2][i] == 'e' && mp[j+3][i] == 'h' )
			{
				ans++；
			}
		}
	}
	
	cout << ans；
	
	return 0；
}

```


---

## 作者：lew2018 (赞：4)

数据很小。。

复杂度大约是O(8*n*m),爆搜可以水过

**做法：**
把每个点都当成起点都搜索一下，状态可以拿一个string来存储，每次向后插入一个元素（注意判断边界），判断一下搜出来的结果是不是hehe或eheh，记录答案即可。

**代码：**
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;

const int N = 1005;
char str[N][N];
int n, m, ans = 0;

void dfs(int x, int y) {
	string a = "";
	if (n - x + 1 >= 4) {
		for (int i = 0; i < 4; i++)
			a += str[x + i][y];
		if (a == "hehe" || a == "eheh") ans++;
	}
	a = "";
	if (m - y + 1 >= 4) {
		for (int i = 0; i < 4; i++)
			a += str[x][y + i];
		if (a == "hehe" || a == "eheh") ans++;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%s", str[i] + 1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			dfs(i, j);
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：dfydada⚡⚡⚡ (赞：3)

这题已经简单的不能在简单了

一个二维,一个一个找过去,如果这个位置是h就枚举上下左右四个方向,看是否能构成hehe.如果可以累加器就加加.

最后输出累加器就可以了

总代码:

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int n,m;
int ans;
char ch[N][N];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>ch[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(ch[i][j]=='h')
			{
				if(ch[i-1][j]=='e'&&ch[i-2][j]=='h'&&ch[i-3][j]=='e')
				{
					ans++;
				}
		        if(ch[i+1][j]=='e'&&ch[i+2][j]=='h'&&ch[i+3][j]=='e')
		        {
		        	ans++;
				}
		        if(ch[i][j-1]=='e'&&ch[i][j-2]=='h'&&ch[i][j-3]=='e')
		        {
		        	ans++;
				}
		        if(ch[i][j+1]=='e'&&ch[i][j+2]=='h'&&ch[i][j+3]=='e')
		        {
		        	ans++;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}

```

如果是60分的话,可以看下自己的n和m在循环条件里有没有出错.

---

## 作者：SIXIANG32 (赞：3)

看到各位大佬都非常地优秀，我这头蒟蒻是真是自愧不如，该题解仅供萌新参考，敲击的水。

~~完美的分割线~~


------------
## 蒟蒻题解
~~真不理解这道题放黄题~~

该题较水，只是一个单纯的模拟。

数据也很水，但告诉我们许多信息

#### 1.斜着的hehe或eheh是不合法的
#### 2.往上或往左的hehe或eheh也是不合法的

只要向下和右搜索即可

写四个if就行了。

主要还是要注意一点：
### 细节
重要的事情说三遍
### 细节  细节  细节
举个例子：
本蒟蒻开数组不小心开成了a[m+1][m+1]，WA了N次，[我的提交之路](https://www.luogu.com.cn/record/list?pid=P1234&user=SIXIANG&page=1)。~~当我没说，别笑~~

送代码!!!
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int main()
{
	freopen("hehe.in","r",stdin);
    freopen("hehe.out","w",stdout);
    while(1)cout<<endl;//防作弊，反抄袭
	int n,m,sum=0;
	cin>>n>>m;
	char a[n+1][m+1];//怕MLE的童鞋可以这样做
	for(int p=1;p<=n;p++)//读入数据
	{
		for(int i=1;i<=m;i++)
		cin>>a[p][i]; 	
	}
	for(int p=1;p<=n;p++){//下面是一波强大的操作
	
		for(int i=1;i<=m;i++)
		{
			if(a[p][i]=='e'&&a[p+1][i]=='h'&&a[p+2][i]=='e'&&a[p+3][i]=='h'){sum++;}
//向右搜索hehe
			if(a[p][i]=='h'&&a[p+1][i]=='e'&&a[p+2][i]=='h'&&a[p+3][i]=='e'){sum++;}
//向右搜索eheh
			if(a[p][i]=='e'&&a[p][i+1]=='h'&&a[p][i+2]=='e'&&a[p][i+3]=='h'){sum++;}
//向下搜索eheh
			if(a[p][i]=='h'&&a[p][i+1]=='e'&&a[p][i+2]=='h'&&a[p][i+3]=='e'){sum++;}
 //向下搜索hehe
		}
	}
	cout<<sum<<endl; 
}	
```


---

## 作者：RKcer21 (赞：3)

## 呵呵

我随手打出来了1234，然后我发现这题，然后发现还是比较水的。

俗话说的好，做题先看数据：1≤n,m≤1000

啊，好舒服的数据啊，一看就知道可以O(nm)模拟
让我们再看看输入样例


```
5 5
heheh
heheh
heheh
heheh
heheh

```
~~刚开始我以为斜的也算，然后交上去就WA了~~

核心思想：枚举起点即可，然后判断它与后面3个字母有没有组成hehe（行），再判断它与下面3个字母有没有组hehe（列）,
然后再反的找一遍(下面代码已经转化成正着找了）{反着找hehe=正着找eheh}

接下来是代码时间
```
#include<bits/stdc++.h>
using namespace std;
char a[1500][1500];
int n,m,i,j,k,t,x,y;
int ans;
int main()
{
    cin>>n>>m;
for (i=1; i<=n; i++)
  for (j=1;j<=m; j++)
    cin>>a[i][j];
for (i=1; i<=n; i++)
  for (j=1; j<=m; j++)
  {
    if ((a[i][j]=='h'&&a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e')) 
      ans+=1;//找到行里面的正hehe
     if (a[i][j]=='h'&&a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e')
     ans+=1;//找到列里面的正hehe
   }
for (i=1; i<=n; i++)
  for (j=1; j<=m; j++)
  {
    if ((a[i][j]=='e'&&a[i][j+1]=='h'&&a[i][j+2]=='e'&&a[i][j+3]=='h')) 
      ans+=1;//找到行里面的反hehe，我这里直接转化为找eheh了      
    if (a[i][j]=='e'&&a[i+1][j]=='h'&&a[i+2][j]=='e'&&a[i+3][j]=='h')
      ans+=1;//找到列里面的反hehe，我这里直接转化为找eheh了
  }
  cout<<ans;
  return 0;
}
```
总之，这题还是比较水的，至于为什么是黄题，我也不知道。

附赠noip用数据来判断的表格：

```
20：2^20=一百万，O(2^n)，搜索

100：100^3=一百万，O(n^3)，Floyd/搜索

1000：1000^2=一百万，O(n^2)，动态规划/图论

500000：O(nlog(2,n))，二分答案/二分查找/快排/归并

1000000：O(n)或 O(1)，数学问题/改变思维方向/贪心
```

（哦，在某位大佬的CSDN里面可以找到的）

---

## 作者：陈LC (赞：2)

此题虽然是黄题，但是十分H2O，可以归为红题。

思想：从头开始一个个枚举，每一个点上下左右四个方向判断，符合条件ans++。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e3+50;
char c[maxn][maxn];
int main(){
    memset(c,'a',sizeof(c));//先把数组打成'a'，以便后面比较，不会越界
    int ans=0,n,m,i,j;//ans归零
    scanf("%d%d",&n,&m);//输入
    //↓↓↓为了保证不会超数组边界，m和n扩大；同理，下面的循环中的i和j也相应扩大
    n+=10;
    m+=10;
    for(i=11;i<=n;i++){
        for(j=11;j<=m;j++){
            cin>>c[i][j];//输入矩阵
        }
    }
    //下面开始枚举
    for(i=11;i<=n;i++){
        for(j=11;j<=m;j++){
            if(c[i][j]=='h'){//接下来开始向四个方向枚举
                if(c[i+1][j]=='e'&&c[i+2][j]=='h'&&c[i+3][j]=='e'){//右
                    ans++;//满足ans++
                }
                if(c[i-1][j]=='e'&&c[i-2][j]=='h'&&c[i-3][j]=='e'){//左
                    ans++;//满足ans++
                }
                if(c[i][j+1]=='e'&&c[i][j+2]=='h'&&c[i][j+3]=='e'){//上
                    ans++;//满足ans++
                }
                if(c[i][j-1]=='e'&&c[i][j-2]=='h'&&c[i][j-3]=='e'){//下
                    ans++;//满足ans++
                }
            }
        }
    }
    printf("%d",ans);//输出
    return 0;//好习惯～～～
}
```


---

## 作者：唔啊唔 (赞：2)

这道题目是我手动跳题找到的，发现其实与P1101单词方阵有点类似，甚至是它的退化版本。

这道题目的情况有4种

```cpp
h   e   hehe
e   h
h   e   eheh
e   h
```

不包括斜着的情况！！！

附上我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,sum;
char q[1010][1010];
int a[1010][1010];
void f(int x,int y){
	if(n-x+1>=4){				//防止越界 
		sum=0;					//一定要记得更新为0 
		for(int i=0;i<=3;i++){
			sum=sum*10+a[x+i][y];	//这个方法比较骚，不想打那么多字来枚举 
		}
		if(a[x][y]==1&&sum==1212)ans++;		
		if(a[x][y]==2&&sum==2121)ans++;		//将找反过来的hehe变为找正着的eheh 
	}
	if(m-y+1>=4){				//下面的与上同理 
		sum=0;
		for(int i=0;i<=3;i++){
			sum=sum*10+a[x][y+i];
		}
		if(a[x][y]==1&&sum==1212)ans++;
		if(a[x][y]==2&&sum==2121)ans++;
	}
	return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>q[i][j];
			if(q[i][j]=='h')a[i][j]=1;			//将字符转成数字，这样我比较顺手 
			if(q[i][j]=='e')a[i][j]=2;			//不能直接让e为0，好像还有别的字母——我就是这么错的 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f(i,j);								//喜欢用函数，比较方便检查 
		}
	}
	cout<<ans;
	return 0;		//功德圆满 
}
```

---

## 作者：Happy_Dream (赞：2)

这道题其实很水（虽然写的是普及，到我估计也就普及-。）
此题思路：判断他的上下左右是否为HEHEH（但需要枚举），并且要写两个左右一个，上下一个。
最后计数。

注意事项；1，是A-3和B-3，否则会爆。

2，要清零

3，是CHAR型数组。

***
```cpp
#include <bits/stdc++.h>
//万能头文件
using namespace std;
int main()
{
//主函数
	int a,b,jsq=0；//清零
	cin>>a>>b;//输入长宽
	char q[5019][5019];//定义
	for(int i=1;i<=a;i++)//两层循环
	{
		for(int j=1;j<=b;j++)
		{
			cin>>q[i][j];//输入字符
		}
	}
	for(int i=1;i<=a;i++)//两层循环
	{
		for(int j=1;j<=b-3/*防止会爆*/;j++)//枚举字符的i-1 j，i-2 j和i+1 j，i+2 j，和他自己(i j)
		{
			if((q[i][j]=='h'&&q[i][j+1]=='e'&&q[i][j+2]=='h'&&q[i][j+3]=='e')||(q[i][j]=='e'&&q[i][j+1]=='h'&&q[i][j+2]=='e'&&q[i][j+3]=='h'))//判断是否为HEHEH
			{
				jsq++;	//计数器加一
			}
		}
	}
	for(int i=1;i<=a-3/*防止会爆*/;i++)//两层循环
	{
		for(int j=1;j<=b;j++)//枚举字符的i j-1,i j+1,和 i j+2,i j-2和它本身（i j）
		{
			if((q[i][j]=='h'&&q[i+1][j]=='e'&&q[i+2][j]=='h'&&q[i+3][j]=='e')||(q[i][j]=='e'&&q[i+1][j]=='h'&&q[i+2][j]=='e'&&q[i+3][j]=='h'))//判断是否为HEHEH
			{
				jsq++;	//计数器加一
			}
		}
	}
	cout<<jsq;//输出
	return 0;//结束
}
//珍惜账号，远离抄袭
//点个赞吧☺

---

## 作者：zhuminghui (赞：2)

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
    int n,m,num;
    char a[1001][1001];//1≤n,m≤1000，一定是字符 
    int i,j; 
    cin>>n>>m;//读入行和列 
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        cin>>a[i][j]; 
        cout<<endl;//记得换行，否则错误 
    }
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    {
        if(a[i][j]=='h'&&a[i][j+1]=='e')//凑成he，则+1 
        num++;
    }
    cout<<num;
    return 0;
}

```

---

## 作者：cjoier_zouzhen1211 (赞：1)

这道题目可以不用搜索做，直接枚举！

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
int n,m,ans;
char a[1001][1001];

int main(){
    scanf("%d%d\n",&n,&m);//输入
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];//输入字符矩形
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]=='h'){//如果扫描到的当前字符为h
                if(i>=4){
                    if(a[i-1][j]=='e'&&a[i-2][j]=='h'&&a[i-3][j]=='e'){
                        ans++;//如果上方有hehe，累加结果.
                    }
                }
                if(i<=n-3){
                    if(a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e'){
                        ans++;//如果下方有hehe，累加结果.
                    }
                }
                if(j>=4){
                    if(a[i][j-1]=='e'&&a[i][j-2]=='h'&&a[i][j-3]=='e'){
                        ans++;//如果左边有hehe，累加结果.
                    }
                }
                if(j<=m-3){
                    if(a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e'){
                        ans++;//如果右边有hehe，累加结果.
                    }
                }
            }
        }
    }
    printf("%d\n",ans);//输出结果
    return 0;
}
```

---

## 作者：ACM1966 (赞：1)

博客已搬迁至cnblogs

地址：
https://CodingPlus.cnblogs.com

短网址：
https://dwz.mn/dfd

---

## 作者：Caishifeng666 (赞：0)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;char a[1001][1001];
void hh(int ans){
	int anss=0;
    for (int x=1;x<=n;x++) for (int y=1;y<=m;y++){
    	if (a[x][y]=='e'&&a[x][y+1]=='h'&&a[x][y+2]=='e'&&a[x][y+3]=='h') anss++;
		if (a[x][y]=='e'&&a[x+1][y]=='h'&&a[x+2][y]=='e'&&a[x+3][y]=='h') anss++;
		if (a[x][y]=='h'&&a[x][y-1]=='e'&&a[x][y-2]=='h'&&a[x][y-3]=='e') anss++;
		if (a[x][y]=='h'&&a[x-1][y]=='e'&&a[x-2][y]=='h'&&a[x-3][y]=='e') anss++;
        if (a[x][y]=='h'&&a[x][y+1]=='e'&&a[x][y+2]=='h'&&a[x][y+3]=='e') ans++;
        if (a[x][y]=='h'&&a[x+1][y]=='e'&&a[x+2][y]=='h'&&a[x+3][y]=='e') ans++;
        if (a[x][y]=='e'&&a[x][y-1]=='h'&&a[x][y-2]=='e'&&a[x][y-3]=='h') ans++;
        if (a[x][y]=='e'&&a[x-1][y]=='h'&&a[x-2][y]=='e'&&a[x-3][y]=='h') ans++;	
    }
    printf("%d",(ans+anss)/2);
    return ;
}
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) cin>>a[i][j];
    hh(0);
    return 0;
} 
```

---

## 作者：yyandy (赞：0)

## 超短程序！
题意很简单，每一个节点上下左右寻找“hehe”

由于有四个方向，我们不妨编写一个子程序计算

大大缩短程序长度（懒）

注释见代码

上代码。。。

```cpp
#include<iostream>
using namespace std;
int x1[5]={0,1,0,-1,0},y1[5]={0,0,1,0,-1},i,j,k,ans,n,m;
char t[5],a[1200][1200];
void mp(int f,int x,int y,int s){
 //f代表方向 1是下 2是向右 3是向左 4是向右
  //x y当前坐标 s 已经找过的字母数量
	if (x<1||y<1||x>n||y>m||t[s]!=a[x][y])return;
  //如果行列坐标越界或者不符合要查找的字母，返回
	if (s==4){++ans;return;	}//找到答案，退出
	mp(f,x+x1[f],y+y1[f],s+1);//下一个
}
int main(){
	cin>>n>>m;
	t[1]='h';t[2]='e';t[3]='h';t[4]='e';//要查找的词hehe
	for (i=1;i<=n;++i)
	for (j=1;j<=m;++j)cin>>a[i][j];
	for (i=1;i<=n;++i)
	for (j=1;j<=m;++j)//枚举每一个点
	for (k=1;k<=4;++k)//枚举四个方向
	mp(k,i,j,1);//子程序计算
	cout<<ans;
}
```
整个程序去掉注释挺短的。。。
子程序带来了便利


---

## 作者：tututu (赞：0)

就是横向，纵向枚举，每个方向有'hehe','eheh'两种情况，我的代码比较短

```cpp
var
  s:array[-1..1002] of ansistring;
  i,j,n,m,sum:longint;
begin
  readln(n,m);
  for i:=1 to n do
    readln(s[i]);
  for i:=1 to n do
    for j:=1 to m-3 do
      begin
        if s[i,j]+s[i,j+1]+s[i,j+2]+s[i,j+3]='hehe' then inc(sum) else
        if s[i,j]+s[i,j+1]+s[i,j+2]+s[i,j+3]='eheh' then inc(sum);
      end;
  for i:=1 to n-3 do
    for j:=1 to m do
      begin
        if s[i,j]+s[i+1,j]+s[i+2,j]+s[i+3,j]='hehe' then inc(sum) else
        if s[i,j]+s[i+1,j]+s[i+2,j]+s[i+3,j]='eheh' then inc(sum);
      end;
  write(sum);
end.

```

---

## 作者：yechenaia (赞：0)

关键就是漏了考虑某种情况（你懂得）

以下是蒟蒻我的代码，仅供参考









```cpp
program hehehehe;
var
n,m,i,j,max:longint;
s:array[1..1000]of ansistring;
begin
readln(n,m);
max:=0;
for i:=1 to n do
  begin{读入并横向处理}
   readln(s[i]);
     for j:=1 to m-3 do
       if (s[i][j]='h') and (s[i][j+1]='e') and (s[i][j+2]='h') and (s[i][j+3]='e')
       then max:=max+1;
     for j:=m downto 4 do
       if (s[i][j]='h') and (s[i][j-1]='e') and (s[i][j-2]='h') and (s[i][j-3]='e')
     then  max:=max+1;
  end;
```
{纵向处理}
     
     
```cpp
for j:=1 to m do
  begin
   for i:=1 to n-3 do
       if (s[i][j]='h') and (s[i+1][j]='e') and (s[i+2][j]='h') and (s[i+3][j]='e')
       then max:=max+1;
   for i:=n downto 4 do
      if (s[i][j]='h') and (s[i-1][j]='e') and (s[i-2][j]='h') and (s[i-3][j]='e')
      then max:=max+1;
  end;
writeln(max);
end.

```

---


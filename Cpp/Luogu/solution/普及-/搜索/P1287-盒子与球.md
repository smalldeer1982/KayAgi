# 盒子与球

## 题目描述

现有 $r$ 个互不相同的盒子和 $n$ 个互不相同的球，要将这 $n$ 个球放入 $r$ 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。

两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。

## 说明/提示

#### 样例输入输出 1 解释

有两个盒子（编号为 $1, 2$）和三个球（编号为 $1, 2, 3$），共有六种方案，分别如下：

| 盒子编号 |   方案 1    |   方案 2    |   方案 3    |   方案 4    |   方案 5    |   方案 6    |
| :------: | :---------: | :---------: | :---------: | :---------: | :---------: | :---------: |
| 盒子 $1$ |  小球 $1$   |  小球 $2$   |  小球 $3$   | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |
| 盒子 $2$ | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |  小球 $1$   |  小球 $2$   |  小球 $3$   |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq r \leq n \leq 10$，且答案小于 $2^{31}$。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
6
```

# 题解

## 作者：brealid (赞：84)

题解：[P1287 盒子与球](https://www.luogu.org/problemnew/show/P1287)

> 不了解的：[stirling数（斯特林数） - 百度百科](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/4938529?fr=aladdin)

分析如下：

> 设有n个不同的球，分别用b1,b2,……bn表示。从中取出一个球bn，bn的放法有以下两种：

> 1) bn独自占一个盒子；那么剩下的球只能放在m-1个盒子中，方案数为：f(n-1, m-1)

> 2) bn与别的球共占一个盒子；那么可以事先将b1,b2,……bn-1这n-1个球放入m个盒子中，然后再将球bn可以放入其中一个盒子中，方案数为 :m*f(n-1,m)

> 3) 边界条件

1. > a) 盒子数 < 0（盒子数“超支”），不成一种方案。

2. > b) 球数 < 盒子数（盒子数“超支”），不成一种方案。

3. > c) 球数 = 盒子数（正好），为一种方案。

so...

```cpp
#define ll long long

ll f(int n, int m)
{
	if (m <= 0 || n < m)
    	return 0;
    if (n == m)
    	return 1;
    else
    	return fun(n-1, m-1) + fun(n-1, m) * m;
}
```

and than...

> 现有r个互不相同的盒子!!!

> 不同!!!

> 所以还要乘上盒子的排列组合

```cpp
#define ll long long

ll fac(int i) // 然而这个函数不用讲什么
{
	if (i == 1)
    	return 1;
    else
    	return i * fac(i - 1);
}
```

so...

```cpp
int main() // 完美主程序
{
    ll n, m;
    cin >> n >> m;
    cout<< f(n, m) * fac(m);
    return 0;
}
```

合成...

```cpp
#include <stdio.h>
#include <iostream>
#define ll long long
using namespace std;

ll f(int n, int m)
{
    if (m <= 0 || n < m)
        return 0;
    if (n == m)
        return 1;
    else
        return fun(n-1, m-1) + fun(n-1, m) * m;
}

ll fac(int i) // 然而这个函数不用讲什么
{
    if (i == 1)
        return 1;
    else
        return i * fac(i - 1);
}

int main() // 完美主程序
{
    ll n, m;
    cin >> n >> m;
    cout<< f(n, m) * fac(m);
    return 0;
}
```

---

## 作者：封禁用户 (赞：32)

这道题是一个比较弱的dp，转移方程f[i][j]=f[i-1][j-1]+j\*[i-1][j]

其实比较好想，如果前面的盒子被填满了，那么最后一个球有j种方法；

如果没填满则=f[i-1][j-1]

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,r,f[100][100]={1};
int jc(int k)
{
    int ans=1;
    for(int i=2;i<=k;i++)
    {
        ans*=i;
    }
    return ans;
}
int main()
{
    cin>>n>>r;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=r;j++)
        {
            f[i][j]=f[i-1][j-1]+j*f[i-1][j];
        }
    }
    cout<<f[n][r]*jc(r);
    return 0;
}
```

---

## 作者：Gumbo (赞：26)

这几天容斥原理有点上头了，看到这个题目的题解里没有这么做的，就来水发题解。

---

正文开始。

首先，题面极为简洁，无需翻译，这边搬运一下：

>$n$ 个球，$m$ 个盒子，彼此互不相同，求将球全部放入盒中的方案数，不允许空盒。

我们先来考虑这一种情况：

>$n$ 个球，$m$ 个盒子，彼此互不相同，求将球全部放入盒中的方案数，允许空盒。

如果这样，是不是就很好做了呢？

答案就是 $m^n$，因为每一个小球的决策都不影响其他小球。

那我们再来看这一种情况：

>$n$ 个球，$m$ 个盒子，彼此互不相同，求将球全部放入盒中的方案数，至少 $k$ 个空盒。

也没有什么难度，我们只要先选出哪些盒子是必须空的，再让剩下的随意分配即可。

答案：$\operatorname C_m^k\times(m-k)^n$

然后就是重点内容：容斥原理。

我们回到原题，如此考虑：

只需将随意分配的结果个数减去有空盒的即可。

而有空盒的又可以这么分：一个空盒、两个空盒……

所以我们引入这样一个柿子：

$$\sum_{i=1}^m{(-1)^{i-1}}\operatorname C_m^i(m-i)^n$$

这就是有空盒的结果个数，是著名的容斥原理的一种应用。

我们只要用 $m^n$ 减去这个柿子，就是我们的答案。

但是，这两个东西可以合在一起：

$$\begin{aligned}&m^n-\sum_{i=1}^m{(-1)^{i-1}}\mathrm C_m^i(m-i)^n \\ =\ & m^n+\sum_{i=1}^m{(-1)^i}\mathrm C_m^i(m-i)^n \\ =\ &(-1)^0\operatorname C_m^0(m-0)^n+\sum_{i=1}^m{(-1)^i}\operatorname C_m^i(m-i)^n \\ =\ &\sum_{i=0}^m{(-1)^i}\operatorname C_m^i(m-i)^n \\\end{aligned} $$

这就是最终的结果计算式。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long qpow(long long a,long long n){
    long long ans=1;
    while(n){
        if(n%2)ans*=a;
        a*=a;
        n>>=1;
    }
    return ans;
}
long long C(long long a,long long b){
    long long ans=1;
    for(long long i=a-b+1;i<=a;++i)ans=ans*i;
    for(long long i=1;i<=b;++i)ans=ans/i;
    return ans;
}
int main(){
    long long a,b;
    cin>>a>>b;
    long long ans=0;
    for(long long i=0;i<b;++i){
        if(i&1)ans-=C(b,i)*qpow(b-i,a);
        else ans+=C(b,i)*qpow(b-i,a);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：listenteresaX (赞：20)

一道动规题，没用stirling数（斯特林数）
~~那写的什么鬼~~
```
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
long long f[15][15];
int main()
{
	cin>>n>>m;
	if(n==0||m>n)//球少于盒子则无解，至于0个球，姑且算0种方案吧 
	{
		cout<<0<<endl;
		return 0;
	}
	f[1][1]=1;//明显边界 
	for(int i=2;i<=n;i++)
	for(int j=1;j<=min(i,m);j++)
	f[i][j]=j*(f[i-1][j]+f[i-1][j-1]);//最后一球放入单独一盒子，共j*f[i-1][j-1];
	                                  //共用盒子，则有j*f[i-1][j]种 
	cout<<f[n][m]<<endl;
	return 0;
}
```

---

## 作者：摆渡 (赞：12)

#### 贴一个和其他题解不一样的做法 QWQ

题意：让我们求出 $N$ 个球放入 $R$ 个盒子且每个盒子都必须放球方案数。

首先，对于每一个球，可以将其放入的盒子数量共有 _R_ 个，所以我们可以知道如果**无需满足**每个盒子都必须放球时的方案数共有 $R^N$ 种方案数（球任意放，允许有空盒子）。

如果我们要满足题目给定的限制条件怎么办呢？
 
先定义 $F[i]$ 为将 $N$ 个球放入 $i$ 个盒子且每个盒子都必须放球的方案数。

考虑要求每个 $F[i]$，我们只需要把球任意放且允许有空盒子的方案数减去有一个空盒子，有两个空盒子到有 $ i-1 $ 个空盒子的方案数之和，并将每个减数项乘上其对应的组合数，即表示在 $i$ 个盒子中选取 $j  (1<j<i)$ 个盒子空着的方案总数 $C^i_j$ 乘以在 $j$ 个盒子里放 $R$ 个球的方案数。（在高中组合数学中称为间接法）。

可以得到状态转移方程：

$ F[i] = i^N - (C^1_i*F[1] + C^2_i*F[2]+…+C^k_i*F[k]) $

其中：$k=i-1$

可以写出代码：

```cpp
#include <bits/stdc++.h>
#define N 17
#define ll long long
using namespace std;
int n,r;
ll f[N],C[N][N];
ll quick_pow(ll a,ll b) //快速幂
{
	ll ret=1;
	while (b)
	{
		if (b&1) ret*=a;
		a*=a;
		b>>=1;
	}
	return ret;
}
int main()
{
	scanf("%d%d",&n,&r);
	
	for (int i=0;i<=n;i++) C[0][i]=1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=i;j++)
			C[j][i]=C[j-1][i-1]+C[j][i-1];
	//预处理组合数		
	for (int i=1;i<=n;i++)
	{
		f[i]=quick_pow(i,n); //计算 i^n
		for (int j=1;j<i;j++) f[i]-=C[j][i]*f[j]; //逐项减去
	}
	printf("%lld",f[r]);
	return 0;
}
```

时间复杂度 $Θ(n^2)$


---

## 作者：yyy2015c01 (赞：9)

排列与组合，自行看注释

```cpp

#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<ctime>
#include<cmath>
#include<map>
#include<vector>
#include<queue>
#include<iomanip>
#include<cstring>
#include<string>
#include<cstdio>
using namespace std;
int a[101][101]={1};//a[i][j]表示有i个球，j个盒子时的方案数（吗？最后要乘上r!）
int jiec(int n)//用来求阶乘的函数
{
    int tot=1;
    for (int i=2;i<=n;i++)
    {
        tot*=i;
    }
    return tot;
}
int main()
{
    ios::sync_with_stdio(false);
    int n,r,ans;
    cin>>n>>r;
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=r;j++)
        {
            a[i][j]=a[i-1][j-1]+a[i-1][j]*j;//程序的核心：递推关系式。每个小球可以放在任何一个盒子里，因此乘上j。嗯哼？不够详细？这是精华，要自己思考，不要想着在赛场上有题解让你copy！
        }
    }
    cout<<a[n][r]*jiec(r)<<endl;//输出结果。至于为什么要乘r!，我想有一定数学功底的人都知道。。
} 


```

---

## 作者：雨落 (赞：7)

情况一：n个相同盒子，m个不同小球，小球放入盒子，不允许盒子为空


直接第二类stir满足第二类stirling数（斯特林数）；

不了解的：http://baike.baidu.com/link?url=EPcGYyqDKzay4fVUasVpBI5tNS-Jqx6XukSIyIsXOUWy0z5HUtlDVDqY4UgXthNY8fkLqlolW6CGlM5c48OmE8IpjQ14I\_4l\_MdxJYI8F-G7emNboerFx\_9ouqsg4DDM

f[i,j]为前i个小球放入前j个盒子，且盒子无空的方案总数：

递推式：

分析如下：

（1）如果n个元素构成了m-1个集合，那么第n+1个元素单独构成一个集合。方案数 S(n,m-1);

（2）如果n个元素已经构成了m个集合，将第n+1个元素插入到任意一个集合。方案数 m\*S(n,m) 。

综合两种情况得：f[i,j]：=f[i-1,j]\*j+f[i-1,j-1];



f[i,0]:=0^n; 

f[1,1]:=1; f[i,i]:=1; f[n,2]:=2^(n-1)-1; f[n,n-1]:=C(n,2); f[n,m]=0;(m>n);ling数，求f[n,m]即可

情况二：n个不同盒子，m个不同的小球，小球放入盒子，不允许盒子有空。


第二类stirling的变形，

结果为f[n,m]\*m!



此题为情况二


---

## 作者：24680esz (赞：6)

发现了方程式，其他就简单了

```cpp
#include <iostream>
using namespace std;
int jc(int n)//阶乘程序
{
    int total=1;
    for (int i=2;i<=n;i++) total*=i;
    return total;
}
int main()
{
    int n,r,a[101][101]={1};
    cin>>n>>r;
    for (int i=1;i<=n;i++) for (int j=1;j<=r;j++) a[i][j]=a[i-1][j-1]+a[i-1][j]*j;//核心方程式，道理自己思考。
    cout<<a[n][r]*jc(r)<<endl;
    return 0;
} 
减少代码复制，共创美好洛谷
```

---

## 作者：fighter_OI (赞：3)

为蒟蒻献上完整思路……

第二类斯特灵数的略微改动

我们用f（i，j）表示在j个盒子里放入i个球（盒子不加区分）的方法数


1. 将前i-1个球放入j个盒子里，再把第i个球任意放入一个盒子里


2. 将前i-1个球放入j-1个盒子里，再把第i个球单独放入一个盒子里

所以：


f[i,j]=f[i-1,j-1]+j\*f[i-1,j]

由于盒子有区分，应乘上盒子数的阶乘

递归+记忆化

```cpp
var n,m:longint;
      f:array[0..100,0..100] of qword;
function jc(n:longint):qword;
begin
 if n=1 then exit(1); exit(jc(n-1)*n);
end;
function work(a,b:longint):qword;
begin
 if a=b then exit(1);
 if a<b then exit(0);
 if b<=0 then exit(0);
 if f[a,b]<>0 then exit(f[a,b]);
 f[a,b]:=work(a-1,b)*b+work(a-1,b-1);
 exit(f[a,b]);
end;
begin
 while not eof do
     begin
      readln(n,m);
      fillchar(f,sizeof(f),0);
      writeln(work(n,m)*jc(m));
     end;
end.
```

---

## 作者：Acerkaio (赞：2)

# P1287 [盒子与球](https://www.luogu.com.cn/problem/P1287) 题解

教练让低基础的人做顺便让我做了这题，码完过后发现题解区的思路或实现方式与我的都不太相同。

## 思路

设 $dp_{i, j}$ 表示顺序枚举到了第 $i$ 个盒子共放了 $j$ 个球的总方案数。

答案即为 $dp_{r, n}$。

现在关注如何转移。

仔细观察，我们发现有：

$dp_{i, j} = \sum_{w = 1}^{n} dp_{i - 1, j - w} \times \tbinom{j}{w} (w > 0, j - w \ge i - 1)
$

其中：$w$ 为第 $i$ 个盒子放的球数。

可解释为：我们现在要共用 $j$ 个球，我们拿出其中 $w$ 个放在第 $i$ 个盒子，那么其方案数就是 $dp_{i - 1, j - w}$ 乘上能选出球的方案数，能选出球的方案数为 $\tbinom{j}{w}$。

注意一下题目中给出不允许有空盒子，即要求 $w > 0$ 且 $j - w \ge i - 1$。

注意几个预处理即可。

## CODE
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int _ = 1e2 + 7;
int dp[_][_];
int exc(int a) {
    if (a == 1) return 1;
    return a * exc(a - 1);
}
signed main() {
    int n, r, ans = 1;
    cin >> n >> r;
    for (int i = 1; i <= r; i++) dp[i][0] = 1;
    for (int i = 1; i <= n; i++) dp[1][i] = 1;

    for (int i = 2; i <= r; i++) {
        for (int j = 1; j <= n; j++) {
            for (int w = 1; w <= n && j - w >= i - 1; w++) {
                dp[i][j] = dp[i][j] + dp[i - 1][j - w] * /*j 选 w*/ exc(j) / exc(w) / exc(j - w);
            }
        }
    }

    cout << dp[r][n] << '\n';
    return 0;
}
// C
```

---

## 作者：Dream_It_Possible (赞：2)

设有n个不同的球，分别用b1,b2,……bn表示。从中取出一个球bn，bn的放法有以下两种：

1)bn独自占一个盒子；那么剩下的球只能放在m-1个盒子中，方案数为：f(n-1,m-1)

2)bn与别的球共占一个盒子；那么可以事先将b1,b2,……bn-1这n-1个球放入m个盒子中，然后再将球bn可以放入其中一个盒子中，方案数为 :m\*f(n-1,m)


代码：





```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long fun(long long n,long long m)
{
    if (m<=0||n<m)
    return 0;
    if (n==m)
    return 1;
    else
    return fun(n-1,m-1)+fun(n-1,m)*m;
}
long long jc(long long n)
{
    if (n==1)
    return 1;
    else
    return n*jc(n-1);
}
int main()
{
    long long n,m;
    cin>>n>>m;
    cout<<fun(n,m)*jc(m);
    return 0;
}

```

---


# 高手去散步

## 题目背景

高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。


## 题目描述

鳌头山上有 $n$ 个观景点，观景点两两之间有游步道共 $m$ 条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。

## 说明/提示

对于 $100\%$ 的数据：$n \le 20$，$m \le 50$，保证观景点两两之间不会有多条游步道连接。

## 样例 #1

### 输入

```
4 6
1 2 10
2 3 20
3 4 30
4 1 40
1 3 50
2 4 60```

### 输出

```
150```

# 题解

## 作者：Diaоsi (赞：46)

$Update:$更新于20191130，去掉了标题行，并不是重复题解，望通过


------------

我是萌新，刚刚上手dfs

~~记得上周一在被柳州小学生神仙吊打的时候就是靠深搜苟了20分~~

这题思路很简单，我的做法是搜索+回溯

当无法达到下一层时（走到尽头或者所有点都被访问过）

就统计此时的最长路，然后更新答案

回溯时就将长度减去，然后搜索下一个点

### dfs代码：

```cpp
void dfs(int st){//深度优先搜索 
	for(int i=1;i<=n;i++){
		if(g[st][i]&&!vis[i]){
			vis[i]=1;
			dist+=g[st][i];
			dfs(i);
			dist-=g[st][i];//回溯 
		}
	}
	max_d=max(max_d,dist);//统计最大深度 
	vis[st]=0;
	return;
}
```
### 在主函数中依次以每个点为起点进行深度优先搜索
```cpp
for(int i=1;i<=n;i++){
    vis[i]=1;
    dfs(i);
    memset(vis,0,sizeof(vis));//记得清空标记数组
}
```
### 最后，完整代码奉上：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int g[N][N],dist,max_d=-10*N,n,m;
bool vis[N];
void dfs(int st){//深度优先搜索 
	for(int i=1;i<=n;i++){
		if(g[st][i]&&!vis[i]){
			vis[i]=1;
			dist+=g[st][i];
			dfs(i);
			dist-=g[st][i];//回溯 
		}
	}
	max_d=max(max_d,dist);//统计最大深度 
	vis[st]=0;
	return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;//读入边和对应的权值 
		g[x][y]=z;
		g[y][x]=z;
	}
	for(int i=1;i<=n;i++){
        vis[i]=1;
        dfs(i);
        memset(vis,0,sizeof(vis));//记得清空标记数组
    }
    cout<<max_d;
	return 0;
}
```
## 萌新发题解求过，如果有问题可以在评论区指出

---

## 作者：环氧乙烷 (赞：18)

这道题因为数据比较小，所以就很好来**模拟**了

先把这个数据转换成一个**双向图**，再依次去选择起点，来选找最大值


------------
就比如4条路（1-2,90，2-4,80，3-1,20 , 4-1,50），四个景点转化成临界矩阵就是 
|  |  1|2  | 3 |  4|
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 |0  | 90 |20  | 50 |
| 2 | 90 |0 |  | 80 |
| 3 |20  |  |  0|  |
|  4| 50 |  80|  |  0|
没有填写的则为到达不了的


------------


话不多数，看代码吧！！

------------
QAQ
```c
#include<bits/stdc++.h>
using namespace std;
int a[21][21],m,sum=0,b[21];
int n,x,y,z,k;
void dfs(int h,int ans)
{
int y=1;//y用来标记是否还有路可走
for(int i=1;i<=m;i++)
	{
	if(a[h][i]!=0&&b[i]==0)
		{
		b[i]=1;
		dfs(i,ans+a[h][i]);//继续查找
		b[i]=0;//回溯
		y=0;//改变y值
		}
	}
if(y==1)sum=ans>sum?ans:sum;//三目运算符，不要我解释吧
}
int main()
{
cin>>m>>n;
for(int i=1;i<=n;i++)
	{
	cin>>x>>y>>z;
	a[x][y]=z;
	a[y][x]=z;//记住是双向图哦
	}
for(int i=1;i<=m;i++)
	{
	k=i;
	memset(b,0,sizeof(b));//记得清空b数组
    b[k]=1;//将起点标记为走过了
	dfs(k,0);
	}
	cout<<sum;
return 0;
}

```


------------
就是这样吧，记住请勿抄袭哦
支持一下吧
------------
~~自欺欺人是没有用的~~

---

## 作者：lzpclxf (赞：18)

[题目传送门](https://www.luogu.org/problem/P1294)

**分析题意：**

知道总共所有的景点$n$, 以及$m$条道路，同时题目也给出了道路的连接情况以及各值

那么接下来的事情就很好办了

使用邻接表存图会使整个程序的效率高很多是$oier$必备技能之一哦， 不会的小可爱可要注意了， 抓紧学！网上有很多讲的不错的文章的。

```cpp
void add(int x, int y, int z) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	e[cnt].w = z;
	head[x] = cnt;
}
```


$dfs$枚举每一个景点作为开始的点， 因为题目中明确指出

_高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束_

```cpp
for(int i = 1; i <= n; i++) 
	vis[i] = 1, dfs(i), vis[i] = 0;
```
这个$vis$数组是用来标记这个景点是否已经游览过的

_她也不喜欢去同一个观景点一次以上_

所以$vis$数组可以确保不会重复浏览景点 这也是$dfs$的一个重要条件


接下来就是$dfs$函数了

```cpp
void dfs(int x) {
	for(int i = head[x]; i; i = e[i].nxt) 
		if(!vis[e[i].to]) {
			vis[e[i].to] = 1;
			ans += e[i].w;
			sum = max(sum, ans);
			dfs(e[i].to);
			ans -= e[i].w;
			vis[e[i].to] = 0;
		}
}
```
 $dfs$函数中的$x$是表示当前的景点， 搜索时搜与他相连的景点即可， 注意回溯过程

开一个变量$sum$来记录最大值， 最后直接输出即可

The Last:

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N =55;
int head[N << 1], cnt, n, m, ans, sum;
bool vis[N];
struct node{
	int nxt, to, w;
}e[N];
int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1;ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
	return s * w;
}
void add(int x, int y, int z) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	e[cnt].w = z;
	head[x] = cnt;
}
void dfs(int x) {
	for(int i = head[x]; i; i = e[i].nxt) 
		if(!vis[e[i].to]) {
			vis[e[i].to] = 1;
			ans += e[i].w;
			sum = max(sum, ans);
			dfs(e[i].to);
			ans -= e[i].w;
			vis[e[i].to] = 0;
		}
}
int main() {
	n = read(), m = read();
	while(m--) {
		int x, y, z;
		x = read(), y = read(), z = read();
		add(x, y, z), add(y, x, z);
	}
	for(int i = 1; i <= n; i++) vis[i] = 1, dfs(i), vis[i] = 0;
	printf("%d\n", sum);
	return 0;
}
```
谢谢收看， 祝身体健康！


---

## 作者：LJZ_C (赞：15)

```cpp
//状压dp
#include<bits/stdc++.h>
#define ref(a, b, c) for(int a = b; a <= c; a++)
#define clr(a, b) memset(a, b, sizeof(a))
#define INF 0x3f3f3f
#define MAX_N 20
using namespace std;
int n, m, mat[MAX_N + 5][MAX_N + 5], f[1 << MAX_N][MAX_N + 5], ans;
int main()
{
    ios :: sync_with_stdio(false);
    scanf("%d%d", &n, &m);
    ref(i, 1, m) {int tmp1, tmp2, tmp3; scanf("%d%d%d", &tmp1, &tmp2, &tmp3); mat[tmp1][tmp2] = mat[tmp2][tmp1] = tmp3;}
    clr(f, -INF); ref(i, 1, n) f[1 << i - 1][i] = 0;
    ref(i, 1, (1 << n) - 1) ref(j, 1, n) if(i & 1 << j - 1) ref(h, 1, n) if(mat[j][h] && !(i & 1 << h - 1)) 
        f[i | 1 << h - 1][h] = max(f[i | 1 << h - 1][h], f[i][j] + mat[j][h]), ans = max(ans, f[i | 1 << h - 1][h]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：ghj1222 (赞：12)

给个cpp的

邻接表实现

就是图的dfs，很简单啊，我用邻接表存储(然而和邻接矩阵差不多嘛)

```cpp
#include <iostream>
#include <cstring>
using namespace std;
struct edge
{
    int v,w,next;
}a[101];
int link[21],n,m;
bool v[21];
void add(int x,int y,int w)
{
    static int p=0;
    p++;
    a[p].v=y;
    a[p].w=w;
    a[p].next=link[x];
    link[x]=p;
}
int dfs(int x)//搜索
{
    if(v[x])return 0;//pd是否被访问
    int ans=0;
    v[x]=true;//把自己标记访问
    for(int i=link[x];i!=0;i=a[i].next)//邻接表遍历
        if(v[a[i].v]==0)//如果没有被访问
            ans=max(ans,dfs(a[i].v)+a[i].w);//访问呗，然后更新答案
    v[x]=false;//别忘了回溯
    return ans;//返回答案
}
int main()//主函数
{
    int x,y,w,ans=0;
    cin >> n >> m;
    for(int i=1;i<=m;i++)
    {
        cin >> x >> y >> w;
        add(x,y,w);//无向图存两次
        add(y,x,w);
    }
    for(int i=1;i<=n;i++)
    {
        memset(v,0,sizeof(v));//这句不写好像也没事儿
        ans=max(ans,dfs(i));
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：RedreamMer (赞：11)

这道题应该十分简单，需要注意的点：

输入的是两景点之间的距离，它是个无向图

（可以用二维数组来记录从点i到j的距离更容易）
```
#include<bits/stdc++.h>
using namespace std;
int a,b,x,y,som;
bool s[21];										//s[i]判断是否来过i点 
int l[21][21];									//二维数组的l[i][j]代表从i到j的距离 
void dfs(int n,int ans){						//用dfs做更容易 
	s[n]=1;										//标记已来过 
	for(int i=1;i<=a;i++)
	if(l[n][i]&&!s[i])							//判断是否来过此点和能否从n到i 
	dfs(i,ans+l[n][i]);
	s[n]=0;										//标记未来过 
	som=max(ans,som);
}
int main(){
	cin>>a>>b;
	for(int i=1;i<=b;i++){
		cin>>x>>y;
		cin>>l[x][y];
		l[y][x]=l[x][y];						//注意是个无向图 
	}
	for(int i=1;i<=a;i++)						//for循环找开始的景点 
	dfs(i,0);
	cout<<som;
	return 0;
}
```


---

## 作者：PrefixAMS (赞：9)

一道dfs搜索图的裸题

可以用vector提前把图存下来

就像这样

```cpp
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		s[a].push_back(b);//存边
		s[b].push_back(a);//双向边
		w[a].push_back(c);//边权 单独开一个vector
		w[b].push_back(c);
	}
```

然后 从每一个点开始搜

因为
```cpp
已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。
```

就像这样

```
for(int i=1;i<=n;i++)
	{
		flag[i]=true;	
		dfs(i,0);
		flag[i]=false;//注意，敲黑板，一定要提前标记（别忘了重置）
	}
                     
                     
```

之后就开始了我们的dfs了

```cpp
void dfs(int now,int l)
{
	ans=max(ans,l);//因为随便一个点都可以结束 所以每一步都取一个max就OK了
	for(int i=0;i<s[now].size();i++)
	{
		if(!flag[s[now][i]])
		{
			flag[s[now][i]]=true;
			dfs(s[now][i],l+w[now][i]);//进入下一步递归
			flag[s[now][i]]=false;//回溯
		}
	}
}
```

最后，献上高清无码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
bool flag[1101];
vector < int > s[1010],w[1010];
void dfs(int now,int l)
{
	ans=max(ans,l);
	for(int i=0;i<s[now].size();i++)
	{
		if(!flag[s[now][i]])
		{
			flag[s[now][i]]=true;
			dfs(s[now][i],l+w[now][i]);
			flag[s[now][i]]=false;
		}
	}
}
int main()
{
	cin>>n>>m;
	
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		s[a].push_back(b);
		s[b].push_back(a);
		w[a].push_back(c);
		w[b].push_back(c);
	}
	for(int i=1;i<=n;i++)
	{
		flag[i]=true;	
		dfs(i,0);
		flag[i]=false;
	}
	cout<<ans;
	return 0;
}
```

代码可能有点丑，勿喷


---

## 作者：do_while_true (赞：8)

# 怕什么 搜！

#### 以机房大佬名言纪念这道橙题难度的黄题
------------
[原题](https://www.luogu.org/problem/P1294)

毫无技巧和创新的图论中的**深度优先遍历**

~~你要写**广搜**也没人拦你~~

**~~强烈要求加强数据！！！~~**

题目描述翻译：n个点m条边连成的**无向图**，求一条最长的路径（可从**任一点**出发）


[复习图论](https://www.cnblogs.com/smile233/p/8228073.html)

------------


### 深度优先遍历顺序

1. 访问顶点now
1. 标记顶点now
1. 深度优先遍历顶点now的所有未被访问的邻接点i
1. 去除标记顶点now

------------

此题只是在深度优先遍历中加了一个边的权值，使之变为无向有权图，但我们实际上还是在深度优先遍历去求权值和

------------

### 代码&解释


```
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,ans;
int a[21][21];//建立邻接矩阵 
bool vis[21];//vis[i]代表第i个点有没有走过
//vis[i]==1为走过  vis[i]==0为没有走过 
inline int read()//快读 
{
	int r=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){r=r*10+ch-'0';ch=getchar();}
	return r*w;
}
inline void dfs(int now,int h)//搜索
//now是当前走到的点，h是走过的路程 
{
	if(h>ans) ans=h;//如果走过的路程大于之前所求答案
	//就更新一遍答案 
	vis[now]=1;//标记当前走到的点 
	for(int i=1;i<=n;i++)//在邻接矩阵中找没有走过且之间有路的点 
	   if(i!=now&&vis[i]==0&&a[now][i]>0) dfs(i,h+a[i][now]);
	   //如果i点没有走过（vis[i]==0） 
	   //并且当前点与i点之间有边相连（a[now][i]>0）
	   //于是从这个点开始搜索，把i传到now里面，h加上当前now点和i点的距离
	   //这里a[i][now]和a[now][i]是相等的，所以写任何一个都可以
	   //因为是有向图 
	vis[now]=0;//回溯 
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)//读入m条边 
	   {
	   	int p,q,t;//p,q是两个点,t是路径长度 
	   	p=read();q=read();t=read(); 
	   	a[p][q]=a[q][p]=t;//存到邻接矩阵中 
	   }
	for(int i=1;i<=n;i++)//枚举每一个点 
	   	dfs(i,0);//从这个点出发开始dfs 
	printf("%d",ans);
	return 0;
}
```

码字不易管理员给过呗QAQ

---

## 作者：我没有小白 (赞：7)

看到下面有大佬用邻接矩阵来存的图，好吧，那我就用一下邻接链表存图。。。。

比他那个高大上（手动滑稽）
这里代码奉上（抖个机灵）
```cpp
#include<bits/stdc++.h>//万能头文件%%% 
using namespace std;
int n,m,ans;
struct edge
{
	int to,next,dist;
} e[100];
int head[100],tot;
int vis[100];
inline void add(int x,int y,int z)
{
	e[++tot].next=head[x];
	e[tot].to=y;
	e[tot].dist=z;
	head[x]=tot;//这里head[x]表示从x出发的最后一条边 
}//以上为邻接链表存图 
void dfs(int x,int tot)
{
	if(tot>ans)ans=tot;//如果搜到的路程比现有的路程更远，就更新ans 
	for(int i=head[x]; i; i=e[i].next)//图的遍历 
	{
		if(!vis[e[i].to])
		{
			vis[e[i].to]=1;
			dfs(e[i].to,tot+e[i].dist);
			vis[e[i].to]=0;//回溯 
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=m; i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);//小伙伴们这里不要忘记存双向图呦 
	}
	for(int i=1; i<=n; i++)
	{
		memset(vis,0,sizeof(vis));
		vis[i]=1;
		dfs(i,0);//这里对应了高手从任何一点出发的条件 
	}
	cout<<ans;//输出ans 
}
//完美撒花biubiubiu 
```
管理大大求过么么哒，小妹谢谢咯~~~~

---

## 作者：Thaumaturge (赞：3)

看到旁边的人在打然后就来军备竞赛了

然后发现。。。是道水题

首先，一眼看过去数据范围，可以发现n特别小，甚至连Floyd都不用写，可以直接搜

但$O($玄学$)$肯定不够优秀，考虑使用状压dp（其实标答就应该是状压的说），用$f[i][bit(S)]$表示当前停留在第$i$个点，走过的点为集合$S$的点的最长路径，bit表示集合中的点状压表示的形式（没学过状压的可以先学一下）。

然后转移就是：

$f[i][bit(j)]=max(f[id(k)][bit(j)-(1<<(id(k)-1))]+e),k∈j$,$e$表示边权,$id(x)$表示点x的标号

如果不好转就改成这样，再用bfs记搜形式转移：

$f[k][bit(j)+(1<<(id(k)-1))]=max(f[k][bit(j)+(1<<(id(k)-1))],f[i][bit(j)]+e),id(k)∈C_uj$，因为是从0开始转的，由bfs性质可知，在转移集合$j$之前，所有$size(k)<size(j)$的集合k都已被转移完毕了，所以不会有后效性

U表示所有的点

边不存在的直接把$e$赋值成$inf$就行。复杂度不太会算，取大一点大概是$O(2^n * n^2)$。因为太过基础了，程序就不给了（其实是懒得打）

看得懂此篇题解的大概也不会来看了吧。。

---

## 作者：夏色祭 (赞：3)

#大难（shui）题

#此题为什么是普及/提高-！！！这难度是妖怪吧。。。

#不过对于搜索刚入门的dalao们倒是道好题

以上属于个人吐槽，请无视

#华丽丽的分割线

**------------------------------------------------------------------------------------------------**

用邻接矩阵存路径，暴力起点，用dfs去把每一条路都走一遍，如果不能走了，就把当前总路径长度和max打个擂台。

AC代码：

```cpp
var
  f:array[0..21,0..21]of longint;
  b:array[0..21]of boolean;
  i,j,k,n,m,x,y,z,max:longint;
procedure try(k,sum:longint);
var
  i:longint;
  begin
    if sum>max then max:=sum;//因为任何点都可以是终点
    for i:=1 to n do 
      if not(b[i]) and (f[k,i]>0) then 
        begin
          b[i]:=not(b[i]);
          try(i,sum+f[k,i]);
          b[i]:=not(b[i]);//回溯
        end;
  end;//dfs
begin
  readln(n,m);
  for i:=1 to m do 
    begin
      readln(x,y,z);
      f[x,y]:=z;
      f[y,x]:=z;
    end;//用邻接矩阵保存路径
  for i:=1 to n do 
    begin
      b[i]:=true;
      try(i,0);
      b[i]:=false;
    end;//暴力起点
  write(max);
end.
```

---

## 作者：jxpxcsh (赞：3)




```cpp
const
     v = 100;
var
     visited:array[1..v]of boolean;
     e:array[1..v,1..v]of integer;
     n,m,ans,i,j,a,b,c:integer;
     procedure dfs(x,len:integer);
     var
         i:integer;
     begin
          visited[x] := true;
         if len > ans then
             ans:=len;
         for i:=1 to n do
             if (not visited[i]) and(e[x,i] <> -1) then
                 dfs(I,len+e[x,i]);
         visited[x] := false;
     end;
     begin
         readln(n,m);
         for i:=1 to n do
             for j:=1 to n do
                 e[i][j] := -1;
         for i:=1 to m do
         begin
             readln(a,b,c);
             e[a][b]:=c;
             e[b][a]:=c;
         end;
         for i:=1 to n do
             visited[i]:=false;
         ans:=0;
         for i:=1 to n do
             dfs(i,0);
         writeln(ans);
     end.

```

---

## 作者：森系 (赞：2)

自己独立思考做出来的第一道dfs，纪念一下~
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,m,a[100][100],b[100],x,y,k;
int mmax=0;
void dfs(int t,int s)
{
    int k=0;
    for(int i=1;i<=n;i++)
    {
        if(a[t][i]!=0 && !b[i])//有路
        {
            k++;
        }
    }
    if(k==0)
    {
        mmax=max(mmax,s);
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(a[t][i]!=0 && !b[i])//有路
        {
            b[i]=1;
            dfs(i,s+a[t][i]);
            b[i]=0;
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<m;i++)
    {
        cin>>x>>y>>k;//无向图
        a[x][y]=k;
        a[y][x]=k;
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        memset(b,0,sizeof(b));
        b[i]=1;
        dfs(i,0);
        ans=max(mmax,ans);
    }
    printf("%d\n",ans);
    return 0;
}

```


---

## 作者：最喜欢saber了 (赞：2)

[题目传送门](https://www.luogu.org/problemnew/show/P1294)

不得不说，这道题其实不太难，（但对我来说很难）我觉得搜索可以轻松的过掉此题，但是我刚开始看到这道题的时候，我以为是有限制的Floyed求最长路，但是我写炸了（我太弱了），所以我想到了暴力，然后想到dfs ，然后我就过了......

直接上代码，我用了两种建图方式：邻接矩阵与邻接表：


## 邻接矩阵：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cctype>
#include<queue>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}
const int maxa = 60;
int n,m,ans,res,vis[maxa],f[maxa][maxa];
void dfs(int x,int sum){//x：当前点
//sum:已经走的路程
	ans=max(ans,sum);//更新答案
	for(int i=1;i<=n;++i){
		if(f[x][i]>0&&!vis[i]){//如果当前位置有景点并且没被标记过，则可以走
			vis[i]=1;//标记为可走
			dfs(i,sum+f[x][i]);//继续搜下几个位置
			vis[i]=0;//回溯
		}
	}
}
int main(){
	memset(f,0,sizeof(f));//把所有的位置都标记为没有景点
	int u,v,w;
	read(n);read(m);
	for(int i=1;i<=m;++i){
		read(u);read(v);read(w);
		f[u][v]=w;
		f[v][u]=w;
	}
	for(int i=1;i<=n;++i){
		memset(vis,0,sizeof(vis));//这个一定要加上，不然可能将标记的点的标记取消，从而与题意不符
		vis[i]=1;//标记以走过
		dfs(i,0);//搜索
	}
	printf("%d",ans);
	return 0;
}
```



## 邻接表：（思路与上面的基本一致）

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cctype>
#include<queue>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}
const int maxa = 60;
int cnt,n,m,vis[maxa],head[maxa],ans,res;
struct node{
	int u,v,w;
}e[maxa<<2];
void add(int u,int v,int w){
	e[++cnt].u=head[u];
	e[cnt].v=v;
	e[cnt].w=w;
	head[u]=cnt;
}
void dfs(int x,int tot){//
	ans=max(ans,tot);
	for(int i=head[x];i;i=e[i].u){//遍历邻接表
		int v=e[i].v,w=e[i].w;
		if(!vis[v]){
			vis[v]=1;
			dfs(v,tot+w);
			vis[v]=0;
		}
	}
}
int main(){
	int u,v,w;
	read(n);read(m);
	for(int i=1;i<=m;++i){
		read(u);read(v);read(w);
		add(u,v,w);add(v,u,w);//连边
	}
	for(int i=1;i<=n;++i){//与上面的想法一样
		memset(vis,0,sizeof(vis));
		vis[i]=1;
		dfs(i,0);
	}
	printf("%d",ans);
	return 0;	
}

```



求过。

---

## 作者：题目SoHard (赞：2)

```cpp
type arr=array[0..1000]of longint;{典型的搜索题}
var n,m,i,j,k,s:longint;
a:array[0..1000]of arr;
b:array[0..1000] of boolean;
c:array[0..1000,0..100] of longint;road:arr;
procedure ss(i,len:longint);
var j,k:longint;             
           begin
b[i]:=false;
for j:=0 to road[i] do 
if b[c[i,j]]  then begin
     ss(c[i,j],len+a[i,c[i,j]]);
           end
        else if len>s then s:=len;
       b[i]:=true;
           end;
begin
fillchar(b,sizeof(b),true);b[0]:=false;
read(n,m);
for i:=1 to m do
begin
    read(j,k);
    inc(road[j]);
   inc(road[k]);
   read(a[j,k]);
   c[j,road[j]]:=k;
   c[k,road[k]]:=j;
   a[k,j]:=a[j,k];
end;
for i:=1 to m do
ss(i,0);
write(s);
end.
```

---

## 作者：小黑 (赞：2)

算法：深度优先搜索

用邻接矩阵存储图（题上已经明确没有重复的路径和自环）


```delphi
var
  map:array[1..20,1..20] of integer;
  a,bool:array[1..20] of integer;
  max,sum:longint;
  n,m,x,y,z,i:integer;
procedure print;
  begin
    if sum>max then max:=sum;
  end;
procedure dfs(m:integer);
  var
    i:integer;
    f:boolean;
  begin
    f:=false;
    for i:=1 to n do
      if (bool[i]=0) and (map[m,i]<>0) then
        f:=true;
    if f then//终止条件是所有有路的景点都走过了
      begin
        for i:=1 to n do
          if (bool[i]=0) and (map[m,i]<>0) then
            begin
              bool[i]:=1;sum:=sum+map[m,i];
              dfs(i);
              bool[i]:=0;sum:=sum-map[m,i];
            end;
      end
    else print;
  end;
begin
  max:=0;
  read(n,m);
  for i:=1 to m do
    begin
      read(x,y,z);
      map[x,y]:=z;
      map[y,x]:=z;//注意是无向图
    end;
  for i:=1 to n do//每一个点都可以作为出发点
    begin
      fillchar(bool,sizeof(bool),0);
      bool[i]:=1;sum:=0;
      dfs(i);
    end;
  write(max);
end.
```

---

## 作者：judgejudge (赞：1)

# 递归程序的深度搜索+链式前向星优化
这道题有点类似于**最长路径**。因此我的方法如下：

1. **递归子程序——深度优先搜索**
2. **链式前向星优化**


------------
## 一.递归子程序——深度优先搜索

把**每一个点**作为起点遍历，把与之**联通**的点跑一遍。如果该点前面没有出现过（注意：本道题存在**回环**，所以本本蒟蒻果断放弃SPFA算法）就对之进行拓展。

```cpp
inline void f(ll x,ll step,ll dis){//跑递归，我觉得有必要记录一下步数
	register int i,j;
	ll p;
	p=step;
	s[p]=x;//感觉p有点多余，此处不要把p定义全局变量，不然30分警告
	for(i=head[s[p]];i!=0;i=a[i].lf){//链式前向星优化，调出来
		ll k=a[i].rt;
		bool b=true;
		for(j=1;j<p;j++)
		if(s[j]==k){
			b=false;
			break;
		}//如果之前没有出现过，就可以对之进行拓展
		if(b==true)f(k,p+1,dis+a[i].len);
	}
	maxl=max(maxl,dis);//取最大值
}
```
其实对于**判重**，在此也可以用**bool数组**进行判断（类比SPFA算法）


------------
## 二.链式前向星优化
因为查找每一个与节点相连的点过于迂腐，且用邻接矩阵存储貌似占内存很大。所以此处用**链式前向星存储图**进行优化。

链式前向星的代码在此就不单独详解。


------------
AC代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
struct node{
	ll lf,rt,len;
}a[100001];
ll s[100001];
ll head[100001];
ll n,m,maxl=-1;
inline void start(ll lf,ll rt,ll len,ll num){//链式前向星代码
	a[num].rt=rt;
	a[num].len=len;
	a[num].lf=head[lf];
	head[lf]=num;
	num++;
	a[num].rt=lf;
	a[num].len=len;
	a[num].lf=head[rt];
	head[rt]=num;
}
inline void f(ll x,ll step,ll dis){//递归子程序搜索
	register int i,j;
	ll p;
	p=step;
	s[p]=x;
	for(i=head[s[p]];i!=0;i=a[i].lf){
		ll k=a[i].rt;
		bool b=true;
		for(j=1;j<p;j++)
		if(s[j]==k){
			b=false;
			break;
		}
		if(b==true)f(k,p+1,dis+a[i].len);
	}
	maxl=max(maxl,dis);
}
int main(){
	register int i,j;
	cin>>n>>m;
	for(i=1;i<=m;i++){
		ll s1,s2,s3;
		cin>>s1>>s2>>s3;
		start(s1,s2,s3,i*2-1);//此处起点不确定，因此往返的路我都存
	}
	for(i=1;i<=n;i++)
	f(i,1,0);//递归
	cout<<maxl<<endl;
	return 0;
}
```


---

## 作者：Hanzire76 (赞：1)

水题，数据很小，直接dfs就OK惹

我这里用的是邻接表存图，不过既然是两两之间有路的，还是邻接矩阵存会更优。

使用vis数组记录每个点的访问情况，遍历每一条出边，返回值是下一个节点开始的最长路加上这一条边的长度。然后回溯。

代码：
```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
using namespace std;

int n, m, tot, head[25], ver[105], nxt[105], w[105], ans, vis[25];

inline int get()
{
    int res = 0;
    char c = getchar();
    while (c < '0' || c > '9')
        c = getchar();
    while (c >= '0' && c <= '9')
    {
        res = res * 10 + c - '0';
        c = getchar();
    }
    return res;
}

inline void add(int x, int y, int z)
{
    ver[++tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
    w[tot] = z;
}

int dfs(int x)
{
    int res = 0;
    for (int i = head[x]; i; i = nxt[i])
    {
        int v = ver[i];
        if (vis[v])
            continue;
        vis[v] = true;
        res = max(res, dfs(v) + w[i]);
        vis[v] = false;
    }
    return res;
}

int main()
{
    n = get(), m = get();
    int x, y, z;
    for (int i = 1; i <= m; i++)
    {
        x = get(), y = get();
        z = get();
        add(x, y, z);
        add(y, x, z);
    }
    for (int i = 1; i <= n; i++)
    {
        memset(vis, false, sizeof(vis));
        vis[i] = true;
        ans = max(ans, dfs(i));
    }
    cout << ans << endl;
    return 0;
}

```


---

## 作者：zhaowangji (赞：1)

水了这么久的红题和橙题，终于做了一条黄题

#### 注意：不去没有路的点，不去走过的点（起始点时要标记+回溯，中途经过点时也要标记加回溯）

方法不算复杂：还可以优化（用vector）

一个三维记录记录点至点之间路的长度，一个一维记录有没有走过同时记录有没有路，ans记录最长路（即答案）

```cpp
#include<iostream>
using namespace std;
int b[57],n,m,u,v,x,ans,a[57][57][3];
//为确保空间不爆，数组加大一点点
void dfs(int k,int length)
//为方便记录当前路长度，不用全局变量，直接用深搜传递
{
    if(length>ans)ans=length;
    //所以要先判断一下是不是超过之前最长的路了
    for(int i=1;i<=n;i++)
        if(b[i]&&a[k][i][1])
        {
            b[i]=0;
            //标记走过
            dfs(i,length+a[k][i][1]);
            //加上两点间路的长度
            b[i]=1;
            //回溯
        }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>u>>v>>x;
        b[u]++;b[v]++;
        //读入，记录该点有路
        a[u][v][1]=x;a[v][u][1]=x;
        //给两点之间的路赋值，记住这是双向图
    }
    for(int i=1;i<=n;i++)
        if(b[i])//如果这个点有路
        {
            b[i]=0;//记得标记走过
            dfs(i,0);
            b[i]=1;//回溯
        }
    cout<<ans;
    return 0;
}
```


---

## 作者：JosephDai (赞：1)

水体一道。~~第一道一次提交就AC的黄题（刚被小b的旅行虐完，发现做完小b的旅行之后做其他题都像是水题了）~~

------------

不多说了，楼下讲的很清楚，flag数组存储是否有边（注意是无向图），然后裸dfs~~（一直担心会超时，可没有任何剪枝的dfs居然都AC了）~~

直接上代码：
```cpp
#include <iostream>
using namespace std;
int n,m,u,v,x;
int a[101][101];
bool flag[101][101];
bool vis[101];
int maxx=0;
int maxn=0;
void dfs(int now,int sum)
{
	maxx=max(maxx,sum);
	for(int i=1;i<=m;i++)
	{
		if(!vis[i] && flag[now][i])
		{
			vis[i]=1;
			dfs(i,sum+a[now][i]);
			vis[i]=0;
		}
	}
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>u>>v>>x;
		a[u][v]=x;
		a[v][u]=x;
		flag[u][v]=1;//为了避免意外，单独建一个flag数组存储是否有边
		flag[v][u]=1;
	}
	for(int i=1;i<=m;i++)
	{
		vis[i]=1;
		dfs(i,0);
		vis[i]=0; 
		maxn=max(maxx,maxn);//个人习惯
		maxx=0;
    }
	cout<<maxn<<endl;
	return 0;//养成好习惯
}
```

---

## 作者：tcswuzb (赞：1)

本题是一道很好的搜索练手题

本蒟蒻用的是深搜（状态比较好清理）

首先 枚举起点

然后 dfs 每一次都更新ans 去过的点打上标记

注意回溯

考到本题数据范围 使用邻接矩阵

# CODE：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define NiuBi 0
#define N 500008
#define ll long long
#define inf 0x7fffffff
#define D double
#define U unsigned
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐---------------------*/
ll mapp[101][101];
ll to[101][101];
ll num[101];
bool vis[1001];
ll ans=-1;
ll x,y,z;
ll n,m;
void dfs(ll a,ll b)
{
    ans=max(ans,b);//更新
    for(ll i=1;i<=num[a];i++)
    {
        ll v=to[a][i];
        if(!vis[v])//一个点只可以走一次
        {
            vis[v]=1;
            dfs(v,b+mapp[a][v]);
            vis[v]=0;//回溯
        }
    }
}
signed main()
{
    read(n);read(m);
    for(ll i=1;i<=m;i++)
    {
    	read(x);read(y);read(z);
    	mapp[x][y]=mapp[y][x]=z;
    	to[x][++num[x]]=y;
    	to[y][++num[y]]=x;
        //邻接矩阵存图
    }
    for(ll i=1;i<=n;i++)//枚举起点
    {
        vis[i]=1;
        dfs(i,0);
        vis[i]=0;//回溯
    }
    cout<<ans<<endl;
    return NiuBi;//防抄袭tag
}
```

---

## 作者：PY_Fighter (赞：1)

水一发py~
```cpp
def dfs(u,s):
    global ans
    global p
    if s>ans:
        ans=s
    for k in range(m+m):
        if x[k]==u:
            if not(y[k] in p):
                p+=[y[k]]
                dfs(y[k],s+w[k])
                p=p[0:len(p)-1]
s=input().split()
n=int(s[0])
m=int(s[1])
x=[]
y=[]
w=[]
for i in range(m+1)[1:m+1]:
    s=input().split()
    x+=[int(s[0])]
    y+=[int(s[1])]
    w+=[int(s[2])]
    x+=[int(s[1])]
    y+=[int(s[0])]
    w+=[int(s[2])]
ans=0
for i in range(n+1)[1:n+1]:
    p=[i]
    dfs(i,0)
print(ans)
    

```
（听说神奇语言更容易过题解~）
    


---

## 作者：不争不闹 (赞：1)

链式前向星+搜索

还算是比较水吧……

注意是无向图，需要存两次

可能存在的错误：DFS后忘记回溯

```cpp
#include <cstdio>
#include <complex>
inline int read()
{//读优 
	int n=0,w=1;register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9')n=n*10+c-'0',c=getchar();
	return n*w;
}
const int N=51;
struct Edge{
	int v,w,nxt;
}edge[N<<1];
int n,m,tot,ans,head[N];
bool vis[N];
inline int max(int x,int y)
{return x>y?x:y;}
inline void add(int u,int v,int w)
{
	edge[++tot].v=v;
	edge[tot].w=w;
	edge[tot].nxt=head[u];
	head[u]=tot;
}
void dfs(int x,int sum)
{
	ans=max(ans,sum);//显然在这里取了max之后答案不会更差 
	for(int v,i=head[x];i;i=edge[i].nxt)
	{//枚举出边 
		v=edge[i].v;
		if(!vis[v])
		{
//			printf("%d ",v);
			vis[v]=true;//标记置为true，表示已经经过了这个点 
			dfs(v,sum+edge[i].w);
			vis[v]=false;//回溯的时候记得标记置为false，表示这条路径上面还没有经过这个点 
		}
	}
}
int main()
{
//	freopen("testdata.in","r",stdin);
	n=read(),m=read();
	for(int u,v,w,i=0;i<m;++i)
	{
		u=read(),v=read(),w=read();
		add(u,v,w);add(v,u,w);
	}
	for(int i=1;i<=n;++i)
	{//每次换不同的起始点
//		printf("%d ",i);
		vis[i]=true;
		dfs(i,0);
		vis[i]=false;
//		printf("\n");
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：fletmer (赞：1)

## 邻接矩阵存图+dfs水题

    
```cpp
#include <iostream>//头文件
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
int n,m;//n个景点，m条路
int f,t,dis,cnt,maxn;//from，to，distance，count，max distance
int path[21][21],che[21];//邻接矩阵
void dfs(int now,int len){//dfs
    che[now]=1;//该景点已到过
    for(int i=1;i<=n;i++){//遍历每一条与该景点相通的点（事实上只有两条）
        if(!che[i]&&path[now][i]>0){//如果未到过该景点且两景点间有路
            che[i]=1,cnt+=path[now][i];//标记为到过，记录当前路径长
            maxn=max(maxn,cnt);//同时更新最大值
            dfs(i,cnt);//以当前景点为起点继续搜
            che[i]=0,cnt-=path[now][i];//恢复状态
        }
    }
}
int main(){
    memset(path,0,sizeof(path));//初始化当做习惯
    memset(che,0,sizeof(che));
    cin>>n>>m;//读入
    for(int i=1;i<=m;i++){//无向图存储
        cin>>f>>t>>dis;
        path[f][t]=dis;
        path[t][f]=dis;
    }
    for(int i=1;i<=n;i++){//枚举每一个出发点
        cnt=0;//！！！
        dfs(i,cnt);
        memset(che,0,sizeof(che));//！！！！
    }
    cout<<maxn;//输出结果就好了
    return 0;//最好还是加上
}
```

---

## 作者：XUCHENGHUI (赞：1)

这里好多pascal的题解，我就来贡献个C++的。

用邻接矩阵存储边的信息，然后搜索，无需剪枝，搜索带三个参数：位置，值，是否是第一个搜的。

如果是第一个搜的，枚举完直接x+1，否则回溯。

代码如下：

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
int i,j,k,n,m,tot,ans;
int b[25],f[55][55];
int read()       //读入优化。
{
    char c;int x;while(c=getchar(),c<'0'||c>'9');x=c-'0';
    while(c=getchar(),c>='0'&&c<='9') x=x*10+c-'0';
    return x;
} 
int max(int a,int b){return a>b?a:b;}
void dfs(int x,int num,int re){       //三个参数
    if(x==n+1){
        ans=max(ans,num);
        return;
    }
    for(int i=1;i<=n;i++)
    if(b[i]==0&&f[x][i]>0)
       {b[x]=1;dfs(i,num+f[x][i],1);b[x]=0;} 
    if(re==0) dfs(x+1,num,0);
    else{
        ans=max(ans,num);
        return;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int x=read();int y=read();
        f[x][y]=f[y][x]=read();
    }
    dfs(1,0,0);
    printf("%d",ans);
    return 0;
}
```

---


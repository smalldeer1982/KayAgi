# 求细胞数量

## 题目描述

一矩形阵列由数字 $0$ 到 $9$ 组成，数字 $1$ 到 $9$ 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$。

## 样例 #1

### 输入

```
4 10
0234500067
1034560500
2045600671
0000000089
```

### 输出

```
4```

# 题解

## 作者：kIG7Z8oP (赞：539)

# 虽然这题已经有45篇题解，但没有一个人想用并查集呢~

-----------
## 介绍一种思考难度稍大的方法

### 1.Begin

（看见题面马上就知道是Floodfill

但因为一些原因，~~**NOIP暂停**~~，我想到了区间维护就换了种做法

**注意！开始讲题（敲黑板）**

样例搬运~

```cpp
4  10
0234500067
1034560500
2045600671
0000000089
```


我们可以认为，在某行的数据可表示为（如第一行）

--------

数值：0，2，3，4，5，0，0，0，6，7

位置：1，2，3，4，5，6，7，8，9，10

----------

在[2,5] ， [9,10]处有数据

同理，第二行中，[1,1]，[3,6]，[8,8]有数据

你看看

**这一行的[3,6]与上一行的[2,5]有交集，所以他们应该在同一联通块中**

### 2.Naive

你要真的这么想，就图样图森破了

那么我想反问一句，为什么不从下往上连呢

~~当然可以~~

因为往下连边可以减少find次数期望，~~推倒~~不难。但笔者不会
$$
LATEX
$$
就不用了罢

以下是代码（直接复制并粘贴有惊喜哦）

```cpp
//能不用尽量别用，O(N*M) 
//27ms
#include<cstdio>
int n,m,a[101][101];//a就是地图 
int tot=0,fa[10010],stlst/*上一行的起始*/,stnow/*这一行的起始*/,qj[10010][2];
int find(int u)
{
	return u==fa[u]?u:fa[u]=find(fa[u]);//板子 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%1d",&a[i][j]);//鸣谢最上面的题解 
	for(int i=1;(i<<1)<=n*m;i++) fa[i]=i;//最多N*M/2个块 
	for(int i=1;i<=n;i++)
	{
		stlst=stnow;
		stnow=tot;
		for(int j=1;j<=m;j++)
			if(a[i][j])
			{
				qj[tot][0]=j;
				while(a[i][j]) j++;
				qj[tot][1]=j-1;
				for(int k=stlst;k<stnow;k++)
					if(qj[k][1]>=qj[tot][0]&&qj[k][0]<=qj[tot][1]) fa[find(k)]=tot;
				tot++;
			}
	}
	int ans=0;
	for(int i=tot-1;i>=0;i--) if(fa[i]==i)/*我上面没有人*/ ans++;
	printf("%d",ans);
}
//People who copied will AK IOI!
```
一片苦心孤诣……可怜可怜我吧……给个赞叭~

---

## 作者：wasa855 (赞：359)

算法前面的dalao已经说得很清楚了，这里，我给大家一种用int数组解题的方法   
用scanf读入整数的时候可以控制读入的位数，比如```
scanf("%2d",&m);
```就是读入一个2位的整数   
所以可以用以下方式读入整个矩阵   
```cpp
for(c=1;c<=m;c++)//循环变量稍微有点奇怪   
{   
	for(d=1;d<=n;d++)   
	{   
		scanf("%1d",&mapp[c][d]);   
	}   
}   
```

---

## 作者：秉烛顷夜 (赞：241)

这题一看到应该就可以反应过来是搜连通块的题

搜法分为dfs和bfs

先看样例发现是一串数字所以无法写以下代码
```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) 
		scanf("%d",&a[i][j]);
```
那该怎么办
```cpp
//用字符呗
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		char c;
		cin>>c;
		a[i][j]=c-'0';
	} 
```
或者
```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) 
		scanf("%1d",&a[i][j]);//%1d表示只读一位
```
输入完那就开始搜索吧

先讲bfs

bfs通常会用到队列

这里我推荐一个stl的双向队列，叫做deque
```cpp
/*
队列基本操作： 
deque<int> q;创建一个数双端队列q,int也可以是别的类型
q.empty();判断队列是否为空，为空返回true
q.push_front(s);将s从队头入队
q.push_back(s);将s从队尾入队,和普通队列方式一样
q.front();只返回队头元素
q.back();只返回队尾元素
q.pop_front();将队头元素弹出
q.pop_back;将队尾元素弹出
q.clear();将队列清空
*/

```
bfs是一层一层搜的
框架如下
```cpp
//bfs模板
struct ed
{
	.....
}
deque<ed>q;
void bfs()
{
	标记起点 
	起点入队列 
	while(!q.empty())//队列不为空 
	{
		ed nw=q.front();//返回队首
		for(拓展出接下来可能的状态)
		{
			ed nxt;
			记录这一状态
			判断状态是否合法 
			标记状态 
			q.push_back(nxt);//状态入队列 
		}
		q.pop_front();//弹出队首 
	}
}
```
所以这题bfs写法如下
```cpp
#include<bits/stdc++.h> 
using namespace std;
struct pp
{
	int x,y;
};
deque<pp> q;//队列 
int n,m,ans=0;//n行m列，ans为答案 
int a[105][105];//存矩阵 
bool used[105][105];//记录是否走过 
int dx[4]={-1,1,0,0};//向上下左右走一步行号和列好的改变 
int dy[4]={0,0,-1,1};
void bfs(int sx,int sy)//bfs 
{
	pp st;
	st.x=sx;st.y=sy;
	used[sx][sy]=1;
	q.push_back(st);
	while(!q.empty())
	{
		pp nw=q.front();
		for(int i=0;i<4;i++)
		{
			pp nxt=nw;
			nxt.x+=dx[i];
			nxt.y+=dy[i];
			if(a[nxt.x][nxt.y]==0 || used[nxt.x][nxt.y]==1) continue;
			used[nxt.x][nxt.y]=1;//把这一连通块的点染色 
			q.push_back(nxt);
		}
		q.pop_front();
	}
}
int main()
{
	cin>>n>>m;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
			scanf("%1d",&a[i][j]);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(used[i][j]==0 && a[i][j]!=0)
			{
			    bfs(i,j);
			    ans++;//若这一连通块没搜过ans++ 
			}
		}
	}
	cout<<ans;	
	return 0;
}
```
那dfs呢
dfs是一次走到底，然后回溯
```
/*
void dfs()
{
	for(拓展状态)
	{
		判断合法
		记录
		dfs(继续搜);
		回溯;
	}
}
*/
```
所以这题dfs代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,m,ans=0;
int a[105][105];
bool used[105][105];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
void dfs(int x,int y)
{
	used[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(a[nx][ny]==0 || used[nx][ny]==1) continue;
		dfs(nx,ny);
	}
}
int main()
{
	cin>>n>>m;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
			scanf("%1d",&a[i][j]);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(used[i][j]==0 && a[i][j]!=0)
			{
				dfs(i,j);
				ans++;
			}
		}
	}
	cout<<ans;	
	return 0;
}
```
拜拜


---

## 作者：Weak_Konjak (赞：182)

BFS正经写法：






------------


```cpp
#include<iostream>
using namespace std;
struct zuobiao{
	int x,y;
}q[30000];
bool map[200][200],p[200][200];//图用bool二维数组储存
int n,m,ans;
char a;
int c[4][2]={0,1,1,0,-1,0,0,-1};//数组储存四个方向
void bfs(int x,int y)
{
	ans++;//新的细胞
	int f=0,r=1,X,Y;//f：队首  r：队尾
	q[1].x=x;
	q[1].y=y;
	while(f<r)
	{
		f++;//入队
		X=q[f].x,Y=q[f].y;
		p[X][Y]=1;//标记已走过
		for(int i=0;i<4;i++)//循环四个方向
		{
			int xx=X+c[i][0];
			int yy=Y+c[i][1];
			if(map[xx][yy]&&(!p[xx][yy]))//是数字且没走过
            //（边界以外都为0，所以可以不用判断边界）
			{
				q[++r].x=xx;//加入队尾等待处理
				q[r].y=yy;
			}
		}
	}
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a;
			map[i][j]=(a!='0');//存储到bool数组中
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(!p[i][j]&&map[i][j])
			{
				bfs(i,j);//如果没被搜索过且是数字，BFS
			}
		}
	}
	cout<<ans;
}
```



------------
~~新手上路，还请大佬指教...~~

---

## 作者：引领天下 (赞：107)

怎么楼下都是bfs啊……

忍不住来了一发dfs

其实dfs也挺快的啊，0ms呢……

思路也很简单，搞一个数组，不为0的地方就是细胞，然后dfs搜连通块，把搜到的都归0，保证不重复。。。

然后就是循环找没被归0的，答案+1。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename _Tp>
inline void read(_Tp &x){
    int w=1;char c=0;x=0;
    while (c^'-'&&(c<'0'||c>'9'))c=getchar();
    if (c=='-')w=-1,c=getchar();
    while (c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x*=w;
}
inline void write(int n){
    if(n==0) return;
    write(n/10);
    putchar(n%10+'0');
}//输入输出优化，请自动忽略
int n,m,ans,dx[]={-1,0,1,0},dy[]={0,-1,0,1},a[105][105];//a即地图，dx和dy方向增量数组就不用我讲了吧
void dfs(int x,int y){
	if (x>n||y>m||x<0||y<0)return;
	a[x][y]=0;//标记为没有
	for (int i=0;i<4;i++)if (a[x+dx[i]][y+dy[i]])dfs(x+dx[i],y+dy[i]);//如果有才搜
}//搜索
int main(){
	read(n),read(m);
	for (int i=0;i<n;i++)
	for (int j=0;j<m;j++)scanf("%1d",&a[i][j]);//只读1位
	for (int i=0;i<n;i++)
	for (int j=0;j<m;j++)if (a[i][j])ans++,dfs(i,j);//找
	write(ans);//输出
	return 0;
}
```
好像挺简单的啊？

---

## 作者：loceaner (赞：85)

### 看到很多大佬用搜索，但身为蒟蒻的我只会打暴力，琢磨着就做对了
一开始我没有输出（连零都没有！），然后我就自闭了，有个同学说要有边界条件的判断，于是打上之后，还是不对，发现只需要判断上下左右四个点，于是我又删了另外四个点的判断，然后身为蒟蒻的我就傻傻的通过啦！

虽然花的时间可能比较多，但是数据水呀！

#### 相信我：水题不能用正常思路来解答

所以就上代码吧

```cpp
#include<bits/stdc++.h>
//懒人专用头文件不解释
using namespace std;

int n,m;
char a[101][101];//
int ans=0;

void shensou(int x,int y) {
    //边界条件判断直接返回
    if(x<1||y<1||x>n||y>m) {
		return ;
	}
    //以下是四个点的判断
    //只要不是0都变成0，然后继续搜索
	if(a[x][y+1]!='0') {
		a[x][y+1]='0';
		shensou(x,y+1);
	}
	if(a[x][y-1]!='0') {
		a[x][y-1]='0';
		shensou(x,y-1);
	}
	if(a[x+1][y]!='0') {
		a[x+1][y]='0';
		shensou(x+1,y);
	}
	if(a[x-1][y]!='0') {
		a[x-1][y]='0';
		shensou(x-1,y);
	}
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cin>>a[i][j];
            //用字符数组输入，因为没有空格
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(a[i][j]!='0') {
				a[i][j]=0;//不是0就变成零
				ans++;
				shensou(i,j);
                //目的是将所有这个细胞中的元素清零
                //这样就可以直接找下一个细胞的某个元素
			}
		}
	}
	printf("%d",ans);//愉快输出答案
	return 0;
}
```

（突然看到已经有暴力打法了，但我的更加简洁，更加易懂，是比较简单的版本）

---

## 作者：扬皓2006 (赞：69)

这是一道用DFS求联通块的题解

本人被坑了10余次

现奉上代码:
```
#include<bits/stdc++.h>//万能头
using namespace std;
int ma[105][105];//地图数组
int m,n,coun=0;
int dx[4]={0,0,1,-1};//四方向数组
int dy[4]={1,-1,0,0};//四方向数组
void dfs(int x,int y){//重点函数
    ma[x][y]=0;//标记为没有
    for(int i=0;i<4;i++){//记住是小于4而不是小于等于4啊
        x+=dx[i];y+=dy[i];//变换坐标
        if(x>0&&x<=n&&y>0&&y<=m&&ma[x][y]!=0)//如果不越界且大于0
		{
			dfs(x,y);、、继续搜索
		}
        x-=dx[i];y-=dy[i];//回溯一步
    }
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
	   for(int j=1;j<=m;j++)
	   {
	   	scanf("%1d",&ma[i][j]);//每个变量只输入一位
	   }
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(ma[i][j]==0)//如果为0
			{
				continue;//返回
			}
			dfs(i,j); //搜索
			coun++;//计数
		}
	}
	cout<<coun;//输出
	return 0;
 } 
 
 这里还有两个普通的深搜模板
深度优先搜索算法框架1
int Search(int k)
　{
　for (i=1;i<=算符种数;i++)
　　if (满足条件)
　　   {
　　　　保存结果
　　　　if (到目的地) 输出解;
　　　           else Search(k+1);
　　　　恢复：保存结果之前的状态{回溯一步}
　 　  }
　}
 深度优先搜索算法框架2
int Search(int k)
　{
　  if  (到目的地) 输出解;
　　　else
　　　　for (i=1;i<=算符种数;i++)
　　　　　if  (满足条件) 
　　　　　　　{
　　　　　　　　保存结果;
　　　                  Search(k+1)
                             恢复：保存结果之前的状态{回溯一步}
　　　　　　　}
　}
 
做完这道题后，大家也可以做一下P1506 P1596 都是DFS求联通块的题目，用来提升自己的编程水平

最后，希望大家能学会DFS，也希望管理大大能通过此篇题解！

---

## 作者：Thomas_Cat (赞：63)

这题其实用 $bfs$ 不好做，最好做的方法是最简单易懂的 $dfs$ 。

首先，我们先来分析一下题目：

- 要找到细胞块，当一个细胞块被 $0$ **围住** 的时候，这个就算是一个细胞块。

- 细胞块只能是 **上下左右** ，斜角是无用的。

- 当你使用 $dfs$ 的时候，注意判断使用的边界是不是 当 $Map_{i,j}$ 的时候 $1 \le i \le n, 1 \le j \le m$ 。

---

那么我们直接来看一下图（关于模拟和查找下一步是不是 **细胞块** 的。

| $(x,y)$ | 1 | 2 | 3 |
| :---: | :---: | :---: | :---: |
| **1** | $\texttt{No solution!}$ | $Map(i,j-1)$ | $\texttt{No solution!}$ |
| **2** | $Map(i-1,j)$ | $Map(i,j)$ | $Map(i+1,j)$ |
| **3** | $\texttt{No solution!}$ | $Map(i,j+1)$ | $\texttt{No solution!}$ |

> 注：上图中使用的 $Map(i,j)$ 正规写法应该是 $Map_{i,j}$ ，但是这里为了贴近代码的数组就没有使用正规写法

显然，我们只用开一个数组 $X_i , Y_i$ 来记录他们的变化规律 （注意 $X_0 , Y_0$ 是 $0$）：

```cpp
int X[5] = { 0,-1,0,1,0 };
int Y[5] = { 0,0,-1,0,1 };
```

---

之后，我们来看一个例子：

如果我从 $Map_{1,1}$ 开始遍历的话，就会做很多的无用功，为什么呢？因为 $Map_{1,1}$ 开始遍历可能就不是遍历到所有 $> 0$ 的点了，会遍历到 $0$ ，所以会做很多的无用功。

因此我们在 $dfs$ 前先加入一个判断：

```cpp
or (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (Map[i][j] != '0' && flag[i][j] == 0) {//如果这个点是细胞并且没有被访问过
				dfs(i, j, ++sum);//dfs
			}
		}
```

---

加下来也就没有什么好说的了，注意这里我的代码的 `init()` 函数是用来控制输入输出的，这样看起来可以简洁明了一些。

总体的代码（无注释）如下：

$\texttt{Ps：}$ 注意输入的是有要用 `char` 而不是 `int` 。

```cpp
#include <iostream>
using namespace std;
int Map[105][105], n, m, sum, flag[105][105];
int X[5] = { 0,-1,0,1,0 };
int Y[5] = { 0,0,-1,0,1 };
void init() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> Map[i][j];
	return;
}
void dfs(int x, int y, int block) {
	flag[x][y] = 1;
	for (int i = 1; i <= 4; i++) {
		int x2 = x + X[i];
		int y2 = y + Y[i];
		if (x2 >= 1 && x2 <= n && y2 >= 1 && y2 <= m && flag[x2][y2] == 1 && Map[x2][y2] != '0')
			dfs(x2, y2, block);
	}
	return;
}
int main() {
	init();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (Map[i][j] != '0' && flag[i][j] == 0) {
				dfs(i, j, ++sum);
			}
		}
	cout << sum;
	return 0;
}
```

---

## 作者：Harry_Potter (赞：22)

问题为求有多少个不包含0的极大连通块。
按照顺序枚举每一个点，在枚举到一个点时，如果他值不
为0且没有被访问过，说明他不属于之前的任意一个连通块，给
答案加一。
之后将这个点放入队列中并标记为访问过，作为开始的唯一
一项，之后进行bfs。
bfs时依次枚举队列中的每一项，再枚举当前项的所有后继
节点，如果没有被访问过，则加入队列并标记为访问过。
最后输出答案即可。
时间复杂度O(n * m)
代码如下，有注释
**请不要抄！**


```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;
int X,Y,qx[100000],qy[100000],use[1000][1000];
int n,m,jishu;
int l,r;
char s[1000][1000];

void BFS(int x,int y)
{
	jishu++;//说明产生一个新的连通块
	l=1;//分别表示队列的开头和结尾
	r=1;
	qx[1]=x;//表示队列中每一个点X的值
	qy[1]=y;//表示对垒中每一个点Y的值
	use[x][y]=1;
	for(;l<=r;l++)
	{
		X=qx[l];//队列中第一项X的值
		Y=qy[l];//队列中第一项Y的值
		if(s[X-1][Y]!='0'&&use[X-1][Y]==0&&X>1)
		{
			r++;
			qx[r]=X-1;
			qy[r]=Y;
			use[X-1][Y]=1;
		}
		if(s[X+1][Y]!='0'&&use[X+1][Y]==0&&X<n)
		{
			r++;
			qx[r]=X+1;
			qy[r]=Y;
			use[X+1][Y]=1;
		}
		if(s[X][Y-1]!='0'&&use[X][Y-1]==0&&Y>1)
		{
			r++;
			qx[r]=X;
			qy[r]=Y-1;
			use[X][Y-1]=1;
		}
		if(s[X][Y+1]!='0'&&use[X][Y+1]==0&&Y<m)
		{
			r++;
			qx[r]=X;
			qy[r]=Y+1;
			use[X][Y+1]=1;
		}
			
	}
}


int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
    	scanf("%s",s[i]+1);
    }
        
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=m;j++)
    	{
    		if(s[i][j]!='0'&&use[i][j]==0)
    		{//如果不是0且没被访问过则广度优先搜索
    			BFS(i,j);
    		}
    	}
    }
    cout<<jishu<<endl;
	return 0;
}


```


如有问题，希望大佬们多多请教

---

## 作者：LoveMind (赞：22)

##算法

队列
##分析

1、从文件中读入m\*n矩阵，将其转换为0、1矩阵存入a数组中；

2、沿a数组矩阵从上到下，从左到右，找到遇到的第一个细胞；将细胞的位置入队q，并沿其上、下、左、右四个方向上搜索，如果遇到细胞(a[i,j]=1)则将其位置入队，入队后的位置a[i,j]数组置为0；

3、将h队的队头出队，沿其上、下、左、右四个方向上搜索，如果遇到细胞则将其位置入队，入队后的位置a数组置为0；

4、重复3，直至h队空为止，则此时找出了一个细胞；

5、重复2，直至矩阵找不到细胞；

6、输出找到的细胞数。

##程序

###C++







    

```cpp
#####include<stdio.h>
#####include<string.h>
#####define MaxN 1000000
const int gx[4]={0,0,1,-1};
const int gy[4]={1,-1,0,0};
int BFS_IAA_(int,int);
char map[1000][1000];
int qx[MaxN],qy[MaxN];
int main(void)
{
    int n,m,ans=0;
    scanf("%d%d\n",&n,&m);
    memset(map,'0',sizeof(map));
    for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
                map[i][j]=getchar();
            getchar();
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if (map[i][j]!='0')
                {
                    BFS_IAA_(i,j);
                    ans++;
                }
    printf("%d\n",ans);
    return 0;
}
int BFS_IAA_(int x,int y)
{
    int head=1,tail=0,tx,ty,count=0;
    map[x][y]='0';
    qx[head]=x;
    qy[head]=y;
    do
    {
        count++;
        tail++;
        tx=qx[tail];
        ty=qy[tail];
        for (int i=0;i<4;i++)
            {
                x=tx+gx[i];
                y=ty+gy[i];
                if ('0'==map[x][y]) continue;
                map[x][y]='0';
                head++;
                qx[head]=x;
                qy[head]=y;
            }
    }    
    while(head!=tail);
    return count;
}
```
#####pascal
```cpp
const dx:array[1..4] of -1..1=(-1,0,1,0);
      dy:array[1..4] of -1..1=(0,1,0,-1);
var int:text;
    name,s:string;
    pic:array[1..50,1..79] of byte;
    bz:array[1..50,1..79] of boolean;
    m,n,i,j,num:integer;
    h:array[1..4000,1..2] of byte;
procedure doing(p,q:integer);
  var i,t,w,x,y:integer;
  begin
    inc(num);bz[p,q]:=false;
    t:=1;w:=1;h[1,1]:=p;h[1,2]:=q;{遇到的第一个细胞入队}
    repeat
      for i:=1 to 4 do{沿细胞的上下左右四个方向搜索细胞}
        begin
          x:=h[t,1]+dx[i];y:=h[t,2]+dy[i];
          if (x>0) and (x<=m) and (y>0) and (y<=n) and bz[x,y]
          then begin inc(w);h[w,1]:=x;h[w,2]:=y;bz[x,y]:=false;end;{为细胞的入队}
end;
inc(t);{队头指针加1}
until t>w;{直至队空为止}
end;
begin
fillchar(bz,sizeof(bz),true);num:=0;
readln(m,n);
for i:=1 to m do
begin readln(s);
for j:=1 to n do
begin pic[i,j]:=ord(s[j])-ord('0');
if pic[i,j]=0 then bz[i,j]:=false;
end;
end;
for i:=1 to m do
for j:=1 to n do if bz[i,j] then doing(i,j);{在矩阵中寻找细胞}
writeln(num);
end.

```

---

## 作者：ZolaWatle (赞：11)

看到大佬们都发的是魔改过后的dfs或者bfs，于是我就发个中规中矩的染色法dfs吧~~~因为太菜了~~


------------
## 由于本题过水，如有雷同纯属巧合。
------------

本题的方法是一种被我称作“搜索染色”的思想。

那么“搜索染色”是指什么？

就像扫垃圾一样，找到垃圾就把它清理干净，相当于置为0.

于是本题主要思路大致如下：

从第一个数组元素开始扫描，找到**不为0**（就是有细胞）的就开搜，四个方向依次试探，把与和这个元素所有相零的并且不为零的元素置为0（不是细胞），下次就不搜了。

整个图处理完之后**依次扫描**，发现有不为零的（细胞）就ans++即可。


------------

首先我们康康这个输入：

![](https://cdn.luogu.com.cn/upload/image_hosting/26xkzhyq.png)

很显然，因为数字之间没有空格，这一定是字符型，但是我们又不想开一个字符数组浪费空间，于是我们可以这样：

```cpp
for(re i=1;i<=n;i++)
	for(re j=1;j<=m;j++)
	{
		char temp;  //一个临时变量用于输入 
		std::cin>>temp;
		map[i][j]=temp-48;  //当前位置的数值等于这个字符的ASCII码值-'0'（也就是48），这样就不用开char了 
	}
```

接下来的步骤就是从1行1列开始搜细胞：

```cpp
for(re i=1;i<=n;i++)
	for(re j=1;j<=m;j++)
		if(map[i][j]!=0)  //是细胞 
		{
			dfs(i,j);  //开始搜，搜索的目的前面讲了 
			map[i][j]=1;  //把自己变得不是零（因为可能搜下一步时走不通就返回到本层了，于是惊奇地发现这一层是走得通的，于是把自己的map值变0了） 
		}
```

前面讲了，搜索的目的是把与自己相邻的元素置为0，思路明确了，这其实是很容易实现的：

```cpp
inline void dfs(int x,int y)
{
	for(re i=0;i<=3;i++)  //四个方向试探 
	{
		re xz=x+ty[i][0];
		re yz=y+ty[i][1];
		//上面这两行算的是下一步的坐标 
		if(xz<1||xz>n||yz<1||yz>m||map[xz][yz]==0)  //如果越界或者走不通 
			continue;  //那就没必要继续了 
		map[xz][yz]=0;  //染色 
		dfs(xz,yz);  //开搜下一层 
	}
}
```

**这个时候我们便要思考一个问题：**

这个：

```cpp
if(xz>=1&&xz<=n&&yz>=1&&yz<=m&&map[xz][yz]!=0)
```

和这个：

```
if(xz<1||xz>n||yz<1||yz>m||map[xz][yz]==0)
```

有什么区别吗？

这个问题只要想清楚了，以后的搜索都会比这个快得多。

上面这个意思是：全部满足执行

下面这个意思是：只要有一个不满足就不执行

哪个更快就很明显了。

```cpp
for(re i=1;i<=n;i++)
	for(re j=1;j<=m;j++)
		if(map[i][j]!=0)  //找到细胞 
			ans++;  //之前已经把与它相邻的元素变成零了，所以直接计数 
```

接下来输出就好了。



------------


### 你们最爱的完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define re register int
using namespace std;

int n,m,ans,map[101][101],ty[4][2]={{1,0},{0,1},{-1,0},{0,-1}};

inline void dfs(int x,int y)
{
	for(re i=0;i<=3;i++)
	{
		re xz=x+ty[i][0];
		re yz=y+ty[i][1];
		if(xz>=1&&xz<=n&&yz>=1&&yz<=m&&map[xz][yz]!=0)
		{
			map[xz][yz]=0;
			dfs(xz,yz);
		}
	}
}

int main()
{
	std::scanf("%d%d",&n,&m);

	for(re i=1;i<=n;i++)
		for(re j=1;j<=m;j++)
		{
			char temp;   
			std::cin>>temp;
			map[i][j]=temp-48; 
		}
			
	
	for(re i=1;i<=n;i++)
		for(re j=1;j<=m;j++)
			if(map[i][j]!=0)
		    {	
	            dfs(i,j); 
                map[i][j]=1;
            }
           
	for(re i=1;i<=n;i++)
		for(re j=1;j<=m;j++)
			if(map[i][j]!=0)
				ans++;
	
	std::printf("%d",ans);
	
	return 0;
} 
```

##### 最后提交一下是这样一个情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/bsizgbbq.png)

最后说一下昂：有一道跟此题方法类似的，[P1596 [USACO10OCT]湖计数Lake Counting](https://www.luogu.org/problem/P1596)，大家去康康吧~



------------
这是萌新也能看懂的题解~

------------
~~打题解不易，管理大大求过~~~

---

## 作者：兀pai (赞：10)

废话少说，直接开始讲做法

本题可以用到染色的思想，就是找完一个细胞以后把这个细胞全部染成0

在主函数里面循环，找到第一个不为0的数就开始调用dfs函数

dfs函数名副其实，用的是dfs的思想

所谓dfs（深度优先搜算）就是找到一个可以深入的点就一搜到底

调用dfs函数是为了染色，把属于这个细胞的部分全部染成0

一直染完整个细胞就直接return就可以了

如果还有不太明白的地方，那就直接看代码吧

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[2000][2000];
int m,n,sum;
int dx[5]={0,0,0,-1,1};
int dy[5]={0,1,-1,0,0};
void dfs(int x,int y){
	if(x<1||x>m||y<1||y>n||a[x][y]=='0') return ;
	a[x][y]='0';
	for(int i=1;i<=4;i++){
		dfs(x+dx[i],y+dy[i]);
	}
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]!='0'){
				dfs(i,j);
				sum++;
			}
		}
	}
	cout<<sum;
	return 0;
} 
```
欢迎大家多多安利我的主页

---

## 作者：徐振羽 (赞：6)

这道题很明显，是一道搜索题，求非零区块数。

搜索非零的区块，并将搜索到的区块全部赋值为零，看看要进行几次操作就好了。

```
如例题:
 4 10
 0234500067
 1034560500
 2045600671
 0000000089
```

```
第1次操作
 0000000067
 1000000500
 2000000671
 0000000089
```

```
第2次操作
 0000000000
 1000000500
 2000000671
 0000000089
```

```
第3次操作
 0000000000
 0000000500
 0000000671
 0000000089
```

```
第4次操作
 0000000000
 0000000000
 0000000000
 0000000000
```
所以共操作四次，答案输出4
我们知道，搜索有深搜和广搜，深搜一般适合解决求次数的问题，可以看作大暴力，广搜则能高效遍历全图，求最短路径和邻接块的问题。

这道题明显广搜适合，虽然深搜能水过，但效率极低，不推荐。

这里其实程序的主函数是一样的，不同的是那个操作，也就是用深搜或广搜去遍历这个区块，将其赋值为零。

主函数如下
```
int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>s;
		for (int j=0;j<s.size();j++) 
			a[i][j+1]=s[j]-'0';
	} //常规读入
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (a[i][j]!=0)//找到区块的第一个点，才进行操作
			{
				ks(i,j);//进行操作
				k++;//统计操作次数
			}
	cout<<k;
	return 0;
} 
```
重要的是操作了

先看深搜
```
void cz(int x,int y)
{
	if (a[x][y]==0) return;判断所在位置是否在要求区块内
	a[x][y]=0;//遍历过了，将这个位置赋值为零
	cz(x+1,y);//向上搜索
	cz(x-1,y);//向下搜索
	cz(x,y+1);//向右搜索
	cz(x,y-1);//向左搜索
}
```
让后广搜
```
int bi[5]={0,1,0,-1,0},bj[5]={0,0,-1,0,1};
queue<int> q1,q2;
void cz(int x,int y)
{	
	q1.push(x);
	q2.push(y);
    //将原位置放入要搜索的队列
	while(!q1.empty())//无可搜索位置时，循环结束
	{
		int x1=q1.front();q1.pop();
		int y1=q2.front();q2.pop();
        //取出要搜素的位置，这个位置没用了，可以踢出队列
		a[x1][y1]=0;//因要搜索的位置处于要求区块，所以直接赋值为零
		for (int i=1;i<=4;i++)
		{
			int xx=x1+bi[i];
			int yy=y1+bj[i];
            //xx,yy表示临近搜索位置的四个点，这几个点有可能能继续搜索
			if (a[xx][yy]!=0)//判断上述的点是否可行
			{
				q1.push(xx);
				q2.push(yy);
                //若可行，将其存入要搜索队列
			}
		}
	}
}
```

---

## 作者：锋芒毕露 (赞：6)

这题十分适合刚学搜索的人做，

# 我来补充个C++的代码

### 搜细胞很简单，

### 只要判断上下左右有没有细胞链接就可以

### 之后就返回成判断的那一个细胞，接下去搜索，

###  并且用bool来判断有没有搜过，搜过的就跳过，
### 避免重置，
代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

int a,b,ans=0;

char xibao1;

int xibao2[105][105];

void dfs(int x,int y){

	xibao2[x][y]=0;
    
	if(xibao2[x-1][y]) dfs(x-1,y);
    
	if(xibao2[x+1][y]) dfs(x+1,y);
    
	if(xibao2[x][y+1]) dfs(x,y+1);
    
	if(xibao2[x][y-1]) dfs(x,y-1);
    
}
int main(){

	cin>>a>>b;
    
	for(int i=1;i<=a;i++){
    
		for(int j=1;j<=b;j++){
        
			cin>>xibao1;
            
			if(xibao1!='0') xibao2[i][j]=1;
            
			else xibao2[i][j]=0;
            
		}
        
	}
    
	for(int i=1;i<=a;i++){
    
		for(int j=1;j<=b;j++){
        
            if(xibao2[i][j]==1 ){
            
            	dfs(i,j);
                
            	ans++;
                
			}
            
		}
        
	}
    
	cout<<ans;
	return 0;
}
```
第一次发题解，
如有不好，
请多多包涵~

---

## 作者：Actinoi (赞：6)

看着诸位大佬的代码是如此短小精悍，我都不好意思发了。。。但总的来说，本代码还是比较容易理解的。。。如有问题，欢迎各位大佬批评指正。
```c
//by Actinoi
//2018-12-23
#include <iostream>
using namespace std;
int matrix[101][101];
int n,m;
bool cango(int x,int y){//判读是否能走 
	if(x>=1&&x<=n&&y>=1&&y<=m&&matrix[x][y]!=0){//不越界且是细胞数字返回 
		return true; 
	}
	return false;
}
void BFS(int x,int y){
	matrix[x][y]=0;//是细胞数字，为避免重复，将其设置为非细胞数字
	//四个方向考虑一下，能走就走 
	if(cango(x+1,y)==true){
		BFS(x+1,y);
	} 
	if(cango(x-1,y)==true){
		BFS(x-1,y); 
	}
	if(cango(x,y+1)==true){
		BFS(x,y+1);
	}
	if(cango(x,y-1)==true){
		BFS(x,y-1);
	}
	return;
}
int main(){
	int ans=0;
	cin>>n>>m;
	char c; 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c;
			matrix[i][j]=c-'0';//读入矩阵 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(matrix[i][j]!=0){//发现细胞数字 
				BFS(i,j);
				ans++;//只要是细胞数字，答案就会增加 
			}
		}
	}
	cout<<ans<<endl;//输出答案 
	return 0;
}
```

---

## 作者：最亮的星_YOU (赞：5)

显然可见，这是一道求联通块的题目

我要在这里介绍一下新人比较易懂的BFS（数组模拟队列）解法

代码如下:
```
#include<bits/stdc++.h>//万能头
using namespace std;
int m,n,coun=0;//横轴，纵轴，计数
int ma[101][101],a[101][101];//地图数组和是否走过数组
int dx[4]={0,0,1,-1};//横轴移动数组
int dy[4]={1,-1,0,0};//纵轴移动数组
struct node{
	int x;//队列.横轴
	int y;//队列.纵轴
}q[10001];//队列queue的缩写q
void bfs(int sx,int sy)
{
	coun++;//计数器++
	q[1].x=sx;q[1].y=sy;//先入队
	int hea=0,tai=1;//队头，队尾
	while(hea<tai)//
	{
		hea++;//入队
		a[q[hea].x][q[hea].y]=1;//标记为已走过
		for(int i=0;i<=3;i++)
		{
			int tx=q[hea].x+dx[i],ty=q[hea].y+dy[i];
			if(tx>=1&&tx<=m&&ty>=1&&ty<=n&&ma[tx][ty]==1&&a[tx][ty]==0)//判断是否越界或者没走过或者是否为细胞
			{
				tai++;//加入队尾等待处理
				q[tai].x=tx;q[tai].y=ty;
			}
		}
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
	for(int j=1;j<=n;j++)
	{
		scanf("%1d",&ma[i][j]);//每个数组变量只读取一位
		if(ma[i][j]!=0)  ma[i][j]=1;//如果不是细胞就为1
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		a[i][j]=0;//把是否走过数组重置为0
	}
	for(int i=1;i<=m;i++)
	for(int j=1;j<=n;j++)
    {
    	if(ma[i][j]==1&&a[i][j]==0)
    	{
    		bfs(i,j);//BFS
		}
	}
	printf("%d",coun);//输出计数器
	return 0;
} 
```
最后希望同学们都能学会BFS(QAQ)

希望管理大大能通过这篇题解鸭（QAQ）


---

## 作者：张曜玺 (赞：5)

不多说这必然广搜

然而我想介绍一个技巧

广搜需要查找四个方向

所以大部分蒟蒻会设置两个数组存储坐标

然而可以这样

int c[6]={-1,0,1,0,-1};

定义这样的一个数组就可以完成对四个方向的查找

其实八个方向的也可以用一个数组解决

自己写写试试吧

提供一下c数组使用的部分23333

```cpp
     for (int i=1;i<=m;i++)
      for (int j=1;j<=n;j++)
      {
          if (a[i][j])
        {
          head=0;tail=0;
          b[head][0]=i;b[head][1]=j;
          while(head<=tail)
          {
              for (int k=0;k<4;k++)
               if(a[b[head][0]+c[k]][b[head][1]+c[k+1]]) //c[ ]数组的实现地方，自己体会它的妙处
               {
                   tail++;
                   b[tail][0]=b[head][0]+c[k];
                   b[tail][1]=b[head][1]+c[k+1];
                   a[b[head][0]+c[k]][b[head][1]+c[k+1]]=0;
               }
               head++;
          }
          sum++;
      }

```

---

## 作者：Drug__Lover (赞：5)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1001][1001];
int sum,m,n;
string s;
void p(int x,int y)
{
    if(x<1||x>m||y<1||y>n||a[x][y]==0) return;//如果越界或者遇到不是细胞的数字，返回 
    a[x][y]=0;       //将细胞数字变成0，防止重复走 
    p(x+1,y);
    p(x-1,y);    //上下左右四个方向搜 
    p(x,y+1);
    p(x,y-1);
}
int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    {
        cin>>s;     //巧妙地输入图 
        for(int k=0;k<n;k++) a[i][k+1]=s[k]-'0';  //转为数字储存 
    }
    for (int b=1;b<=m;b++)
        for (int c=1;c<=n;c++)
        {    
             if (a[b][c]!=0)   //枚举每一个是细胞数字的点 
            {
                p(b,c);
                sum++; //每次个数加一 
            }
        }
    cout<<sum; //输出个数 
    return 0;
}
```

---

## 作者：jike1994 (赞：4)

题目描述：

一矩形阵列由数字0到9组成,数字1到9代表细胞,细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞,求给定矩形阵列的细胞个数。（1<=m,n<=100）?

输入：整数m,n(m行，n列)  矩阵

输出：细胞的个数

输入样例

4  10

0234500067

1034560500

2045600671

0000000089

输出 

4
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int n,m,cnt;
int mp[N][N],st[N][N];
int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
typedef pair<int,int> PII;
void bfs(int x,int y)
{
	queue<PII> q;
	q.push(make_pair(x,y));
	st[x][y]=1;
	while(q.size())
	{
		PII p=q.front();
		q.pop();
		int x=p.first,y=p.second;
		for(int i=0;i<4;i++)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<1||x>n||y<1||y>m||st[xx][yy]||mp[xx][yy]==0) continue;
			st[xx][yy]=1;
			q.push(make_pair(xx,yy));
		}
	}
} 
int main()
{
	cin>>n>>m;
	char ch;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>ch;
			mp[i][j]=ch-'0';
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j]>0&&!st[i][j])
			{
				bfs(i,j);
				cnt++;
			}
		}
	cout<<cnt<<endl;
	return 0;		
} 
```


---

## 作者：lz天下dy (赞：4)

我们不妨使用一下STL队列
队列满足先进先出原则

队列的操作函数：
入队: q.push(x); 将x 接到队列的末端。
出队: q.pop(); 弹出队列的第一个元素，注意，是删除，不会返回被弹出元素的值。
访问队首元素：q.front()；即获取最早被压入队列的元素值。
访问队尾元素：q.back()；即获取最后被压入队列的元素值。
判断队列空：q.empty()；当队列空时，返回true（1）。
访问队列中的元素个数：q.size()；

队列一般用在广度搜索（BFS）中，将能扩展的对象都放到队列里面扩展，直到队列为空（我才不会说是我广搜~~懒得搞指针~~）
```
#include<iostream> 
#include<cstdio>
#include<queue>//头文件
using namespace std;
int n,m,ans=0;
struct zuobiao{//朴素的结构体名称
	int x,y;
};
zuobiao p;
queue<zuobiao>a;
bool map[105][105]={false};//标志
void bfs(int X,int Y){
	if(map[X][Y]==true) return;
	map[X][Y]=true;
	p.x=X;
	p.y=Y;
	a.push(p);
	while(!a.empty()){
		int x=a.front().x;
		int y=a.front().y;
		a.pop();
		if(x-1>0) bfs(x-1,y);//分四次扩展
		if(y-1>0) bfs(x,y-1);
		if(x+1<=n) bfs(x+1,y);
		if(y+1<=m) bfs(x,y+1);
	}
	return;
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int k=1;k<=m;k++){
			char b;//用字符型变量判断
			cin>>b;
			int a=b-48;//换算成值
			if(a==0) map[i][k]=true;//不是细胞
			if(a!=0) map[i][k]=false;
		}
	}
	for(int i=1;i<=n;i++){
		for(int k=1;k<=m;k++){
				if(map[i][k]) continue;
				ans++;
				bfs(i,k);//常规操作
			}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Max_Leo (赞：4)

[传送门](https://www.luogu.org/problem/P1451)
这是最基础的一道
# BFS题
##### 这一题最重要的应该就是
$$\color{red}\text{读入的处理}$$
如果全是数字的话处理起来不方便 本蒟蒻的方法是将所有是细胞的数字转化为1，而非细胞的是0，拿样例来说就是这样：
#### 0234500067 
#### 1034560500
#### 2045600671
#### 0000000089
就可以把它转化成
#### 0111100011
#### 1011110100
#### 1011100111
#### 0000000011
用代码实现其实很简单
```cpp
memset(mp,0,sizeof(mp));
	//把边缘全设为非细胞
for(int i=1;i<=m;i++)
{
	string a;
	cin >> a;
	for(int j=1;j<=n;j++)
		mp[i][j]=(a[j-1]!='0');
		//当a[j-1]=0的时候
		//a[j-1]!=0是不成立的所以mp[i][j]=flase=0
		
		//当a=1,2,3,4,5,6,7,8,9
		//a[j-1]!=0是成立的所以mp[i][j]=true=1
}
```
再就是求有几个联通块的问题
#### queue（队列）的功能
以下所有Q为队列名称
|目的|代码|
| :----------- | :----------- |
|定义|queue<type>Q|
|队列为空|Q.empty()|
|入队|Q.push(元素)|
|出队|Q.pop()|
|队首元素|Q.front()|
|队尾元素|Q.back()|
#### 然后就可以开始打代码了
附上AC代码
 ```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
    int x,y;
};
queue <node> Q;
int det[4][2]={{0,1},{0,-1},{-1,0},{1,0}};
bool used[110][110];
int m,n;
bool mp[110][110];
int main()
{
	memset(used,0,sizeof(used));
    memset(mp,0,sizeof(mp));
	cin >> m >> n;
	for(int i=1;i<=m;i++)
    {
        string a;
        cin >> a;
        for(int j=1;j<=n;j++)
	        mp[i][j]=(a[j-1]!='0');
    }
	    
	int ans=0; 
	for(int i=1;i<=m;i++)
   		for(int j=1;j<=n;j++)
        	if(used[i][j]==0&&mp[i][j]==1) 
        	{
            	node s;
            	s.x=i,s.y=j;
            	used[s.x][s.y]=1;
            	Q.push(s);
            	while(!Q.empty())
            	{
            	    node u=Q.front();
            	    Q.pop();
            	    for(int k=0;k<4;k++)
            	    {
            	        node v;
               		    v.x=u.x+det[k][0];
               	    	v.y=u.y+det[k][1];
                    	if(used[v.x][v.y])continue;
                    	if(mp[v.x][v.y]==0)continue;
                    	Q.push(v);
                    	used[v.x][v.y]=1;
                	}
            	}
            	ans++;
        	}
    cout << ans;
    return 0;
}

```

其实所有的BFS题的格式都差不多是这样，做完这题可以去做[填涂颜色](https://www.luogu.org/problem/P1162)和[拯救oibh总部](https://www.luogu.org/problem/P1506)都是这类题。

---

## 作者：ironwheel (赞：4)

虽然今天上课才学的广搜……

```cpp
#include<iostream>
using namespace std;
int n,m;
char s;//输入时千万要用字符方式输入，要不然一行会被当做一个数【滑稽】 
int a[101][101],x[4]={-1,0,1,0},y[4]={0,1,0,-1},b[101][3],sum=0;
void bfs(int i,int j)//定义，a数组表示该位置上是否为细胞数，xy定义方向搜索，b为队列数组（上一行不够用） 
{//bfs广度优先搜索函数 
    int head=0,foot=1,xx,yy;//head队头指针，foot队尾指针 
    a[i][j]=0;b[1][1]=i;b[1][2]=j;//搜索到的第一个细胞数置0，结点进入队列 
    sum++;//细胞数累加 
    do{
    head++;
    for(int q=0;q<=3;q++){//沿上下左右四个方向搜索 
        xx=b[head][1]+x[q];yy=b[head][2]+y[q];
        if((xx>=0)&&(xx<n)&&(yy>=0)&&(yy<m)&&(a[xx][yy])){//如果当前位置能入队 
            foot++;
            b[foot][1]=xx;
            b[foot][2]=yy;//入队 
            a[xx][yy]=0;//当前位置置0 
            }
        }
    }while(head<foot);
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>s;//字符读入 
            if(s-'0'>=1&&s-'0'<=9){//如果为细胞数 
                a[i][j]=1;//将当前位置置1 
            }
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(a[i][j])bfs(i,j);//逐一搜索，碰到的第一个细胞数则调用广搜函数
        }
    }
    cout<<sum;//输出结果 
}
```

---

## 作者：花园Serena (赞：4)

这题其实不需要$bfs$~~其实是我不会写bfs~~

只需要一个并查集，速度更**快**，看起来更**高端** ！！！

首先，什么是并查集？  其实你们都应该知道，就是一个表示谁是谁爸爸的算法。

但是本蒟蒻不知道把$f$数组变成二维的。。。只好变成一维的。。。

但是怎么变成一维的呢？~~真是个问题啊！！~~

## 首先

我们可以打出一个$5*5$ 的由$0$和$1$组成的矩阵
```
0 0 0 0 0
0 0 0 1 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
在这里，数字1在第二行第四个

```
把它放到一行中。。。
```
0 0 0 0 0 0 0 1 0 0......
而这里是第九个
```
经过一番~~出神入化出生入死~~的观察与分析
如果用$i$表示行数，用$j$表示列数，在$n*n$矩阵中$i$行$j$列的数在这一行数字中在$(i-1)*n+j$个

我们其实只需要按照这样的奇葩的方法吧一个矩阵的爸爸放到一个一维数组中并将附近的数字设为一个爸爸就好了，代码如下

```
#include <bits/stdc++.h>
using namespace std;
int f[10000+2100]/*奇怪的数组*/,tong[10000+2100]/*桶排最后统计爸爸数*/;
bool a[100+10][100+10]={false};
int found(int x);
void mix(int x,int y);
int main()  {
	int m,n,cnt=0; char x;
	scanf("%d%d",&m,&n);
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++){
			cin>>x;/*输入*/ f[(i-1)*n+j]=(i-1)*n+j;/*初始化爸爸*/
			if(x>='1'&&x<='9') a[i][j]=true;/*将数字转化成bool型*/
		}
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++){
			if(a[i][j]){//枚举四周如果是true,就把他们两个的爸爸变成一个爸爸
				if(a[i-1][j])  mix((i-2)*n+j,(i-1)*n+j);
				if(a[i+1][j])  mix(i*n+j,(i-1)*n+j);
				if(a[i][j+1])  mix((i-1)*n+j+1,(i-1)*n+j);
				if(a[i][j-1])  mix((i-1)*n+j-1,(i-1)*n+j);
			}
		}
    //桶排寻找爸爸
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++)
			if(a[i][j]) tong[found(f[(i-1)*n+j])]++;
	//统计爸爸数
    for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			if(tong[(i-1)*n+j]!=0) cnt++;
	printf("%d\n",cnt);
    return 0;
    printf("I am Robert-bear\n");
}
//并查集的操作
void mix(int x,int y)  {f[found(x)]=found(y);}
int found(int x)  {
	while(x!=f[x]) x=f[x]=f[f[x]];//路径压缩
	return x;
}
```

就是这样！！！~~喵~~

---

## 作者：Timothy (赞：3)

#来看正解！！！

【题目描述】

一矩阵由数字0~9组成，数字1~9代表细胞，细胞的定义为沿细胞数字上下左右还是数字的为同一个细胞，求矩阵的细胞个数。

【样例输入】

4  10
0234500067

1034560500

2045600571

0000000089

【样例输出】

4
【算法分析】

将矩阵读入后从左到右，从上到下依次循环，当这个点为细胞时，进行回溯搜索，将同一个细胞的其他清零，并将答案加一，最后输出解。

【C++源代码】

```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,m,a[1001][1001],ans;
string s;
void find (int x,int y)
{
    if (!a[x][y]||x<1||y<1||x>n||y>m)return;
    a[x][y]=0;
    find (x+1,y);
    find (x,y+1);
    find (x-1,y);
    find (x,y-1);
}
int main ()
{
    scanf ("%d%d",&n,&m);
    for (int b=1;b<=n;++b)
    {
        cin >>s;
        for (int c=0;c<m;++c)
          a[b][c+1]=s[c]-'0';
    }
    for (int b=1;b<=n;++b)
    
        for (int c=1;c<=m;++c)
        {    if (a[b][c])
            {
                find (b,c);
                ans++;
                
            }
        }
    printf ("%d",ans);
    return 0;
}

```

---

## 作者：courage (赞：3)

裸的BFS（DFS也可），每当发现一个非0的元素就做一遍floodfill（即新建一个队列，该元素进队。当队列不空时，将队首可扩展到的元素加入队尾，然后队首出队）。注意把进队的点清零即可。

另外貌似本题数据范围有问题，数组开大一点才能过。（100\*100足够了）


```cpp

#include<cstdio>
#include<cstring>
char s[110];
int a[100][100]={0},n,m,p,x,y,q,ans=0,b[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
struct rec{int x,y;};
rec c[10010];
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%s",s);
        for (int j=1;j<=m;j++) a[i][j]=s[j-1]-48;
    }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++) if (a[i][j]){
            p=q=1;
            ans++;
            c[p].x=i;
            c[p].y=j;
            a[i][j]=0;
            while (p<q+1){
                for (int k=0;k<4;k++){
                    x=c[p].x+b[k][0];
                    y=c[p].y+b[k][1];
                    if (x>0 && y>0 && x<=n && y<=m && a[x][y]){
                        q++;
                        c[q].x=x;
                        c[q].y=y;
                        a[x][y]=0;
                    }
                }
                p++;
            }
        }
    printf("%d\n",ans);
}

```

---

## 作者：blackbeanman (赞：3)

此题是一个求连通块的题目，数据比较小，可以dfs或bfs爆搜

当然，求连通块还有一些高效的方法。

比如你可以用并查集来做，查看上面和左边，如果属于同一细胞，就并入同一集合，这样最后记录集合数目就OK了

但是一般解这种题都是用洪水填充，其实是一个类似并查集的思想，无非将同一集合涂成一种颜色（写1，2，3之类的）

最后记录颜色数目，这个其实也像是一个集合优化，使其更加简单明了


---

## 作者：陈灏 (赞：2)

### 深搜DFS
```cpp
#include<iostream>
using namespace std;
int n,m;
int ans;
char a[105][105];
void dfs(int x,int y)
{
    if(x>n ||x<1|| y>m || y<1 || a[x][y]=='0') return;
    a[x][y]='0';
    dfs(x+1,y);
    dfs(x,y+1);
    dfs(x-1,y);
    dfs(x,y-1);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++) cin >> a[i][j];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]!='0') ans++;
			dfs(i,j);
        }
    }
    cout<<ans;
    return 0;
}

```
--------------

**.**
**.**
**.**
**.**
**.**
**.**
**.**
**.**
**.**


### 广搜BFS
```cpp
#include<iostream>
#include<queue>
using namespace std;
int m,n,a[10000][10000],ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
queue<int> cx,cy;
void bfs(int i,int j)
{
	cx.push(i),cy.push(j);
	while(!cx.empty()&&!cy.empty())
	{
		int x=cx.front(),y=cy.front();
		cx.pop(),cy.pop();
		a[x][y]=0;
		for(int k=0;k<=3;k++)
		{
			int xx=x+dx[k],yy=y+dy[k];
			if(xx<1||yy<1||xx>m||yy>n||a[xx][yy]==0) continue;
			cx.push(xx),cy.push(yy);
		}
	}
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			char b;
			cin>>b;
			if(b=='0') a[i][j]=0;
			else a[i][j]=1;
		}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==1)
			{
				ans++;
				bfs(i,j);
			}
		}
	}
	cout<<ans;
	return 0;
}
```
## 勿抄题解

---

## 作者：XQLG (赞：2)

看到下面的题解，大佬们要不就是bfs，要不就是很长很长的代码，~~看到我都不想看了~~。

其实，这道，就是一道水题，dfs判联通块

数字不为零就是联通

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110][110],n,m,ans;
void dfs(int x,int y)
{
	if(x>n||y<1||y>m||x<1||a[x][y]==0) return;
	a[x][y]=0;//标记一下，免得等下再搜回来死循环
	dfs(x+1,y);//四个方向
	dfs(x,y+1);//分别判联通
	dfs(x-1,y);
	dfs(x,y-1);
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int u=1;u<=m;u++)
		{
			char k;
			cin>>k;
			if(k!='0') a[i][u]=1;//其实并不需要，就是打其他题目的时候打惯了
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int u=1;u<=m;u++)
		{
			if(a[i][u]==1)
            {
				ans++;
			    dfs(i,u);
             }
		}
	}
	cout<<ans;
	return 0;
}
```
嘻嘻嘻再见了

---

## 作者：Leaved_ (赞：2)

思路：BFS判断联通块，如果不为 ' 0 '，搜索，把所有入队的点变为 ' 0 '

[二倍经验](https://www.luogu.org/problem/P1596) P1596

```cpp
#include <bits/stdc++.h>

using namespace std;

int go[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//不同于P1596的是，它要求的是4联通
char ma[1001][1001];
int n,m,ans;
pair <int,int> q[1001];

void input() {
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			ma[i][j]='0';
		}
	}
}

void bfs(int x,int y) {
	int head=1,tail=1;
	ma[x][y]='0';
	q[head].first=x;//入队
	q[head].second=y;
	while(head<=tail) {
		int x2=q[head].first;
		int y2=q[head].second;
		head++;//出队
		for (int i=0;i<4;i++) {//4联通
				int x1=x2+go[i][0];
				int y1=y2+go[i][1];
				if (ma[x1][y1]=='0'||x1<1||x1>n||y1<1||y1>m) continue;
				ma[x1][y1]='0';
				tail++;
				q[tail].first=x1;
				q[tail].second=y1;//入队
		}
	}
}

int main() {
	cin>>n>>m;
	input();//初始化
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			char a;cin>>a;
			ma[i][j]=a;
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(ma[i][j]!='0') {//如果是细胞数字
				ans++;
				bfs(i,j);//搜索与它相关联的所有细胞数字
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}


```


---

## 作者：feecle6418 (赞：2)

一种不一样的算法：

我用了深搜，通过传入一个方位的方法，让它不会出现(1,2)->(1,3)->(1,2)这样的重复计算。

代码如下：

```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int n,m;bool u[101][101]={0};char a[101][101];
void dfs(int i,int j,int fw){//方位
    if(i==0||j==0||a[i][j]=='0'||u[i][j]||a[i][j]==0){
        u[i][j]=true;
        return ;
    }
    //cout<<i<<' '<<j<<' '<<endl;
    if(!(i==0||j==0||a[i][j]=='0'||u[i][j]||a[i][j]==0)) {
        u[i][j]=true;
        if(fw==0){
            dfs(i,j+1,3);
            dfs(i,j-1,1);
            dfs(i+1,j,2);
            dfs(i-1,j,4);
        }
        if(fw==1){
            dfs(i,j-1,1);
            dfs(i+1,j,2);
            dfs(i-1,j,4);
        }
        if(fw==2){
            dfs(i,j+1,3);
            dfs(i+1,j,2);
            dfs(i,j-1,1);
        }
        if(fw==3){
            dfs(i,j+1,3);
            dfs(i+1,j,2);
            dfs(i-1,j,4);
        }
        if(fw==4){
            dfs(i,j+1,3);
            dfs(i,j-1,1);
            dfs(i-1,j,4);
        }
    }
}
int main(){
    //freopen("cell.in","r",stdin);
    //freopen("cell.out","w",stdout); 
    int s=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]!='0'&&!(u[i][j])){
                s++;
                dfs(i,j,0);
            }
        }
    }
    cout<<s;
    return 0;
}
```

---

## 作者：zy小可爱ღ (赞：2)

为什么楼下dalao用的都是广搜。。。

我就不用广搜（我才不会告诉你我不会广搜呢）咳咳。。

刚开始被题目描述坑了一下，以为每一种数字就是一种细菌，结果样例一测21，瞬间无语。。。

后面又审了一边题目，才发现0表示墙壁一样的东西。。。

把题目转换一下就变成了求连通块，基础题

具体解释看代码：：：




```cpp
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<cmath>
#include<ctime>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<cstdio>
#include<sstream>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>//妈妈再也不用担心我的头文件了~~~
using namespace std;//咳咳，建议把会的头文件都写上去，免得出现用sort没有#include<algorithm>的悲剧。。。
int n,m,ans;//n，m和输出数据
char a[105][105];//记录细菌
void dfs(int x,int y){//dfs程序
    if(x>n||x<=0||y>=m||y<0||a[x][y]!='1')return;//特判，越界和“墙壁”
    a[x][y]='0';//删除连通块
    dfs(x-1,y);//往左搜
    dfs(x,y-1);//往下搜
    dfs(x+1,y);//往右搜
    dfs(x,y+1);//往上搜
}
int main(){
    cin>>n>>m;//输入
    for(int i=1;i<=n;i++){
        scanf("%s",a[i]);//洛谷的评测环境是Liunx，不能用gets或getline
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++){
            if(a[i][j]!='0'){
                a[i][j]='1';//那么多数字，不如直接用一个循环全部换成1，这题目只要把转换一下，就跟前面有一题一样了，具体哪题不记得了。。。
            }
        }
    }
    for(int i=1;i<=n;i++){//遍历一遍
        for(int j=0;j<m;j++){
            if(a[i][j]!='0'){//发现不是“墙壁的地方”
                ans++;//答案加一
                dfs(i,j);//dfs
            }
        }
    }
    cout<<ans<<endl;//输出答案
    return 0;
}
```
完美结束~~~
祝大家AC！！！


---

## 作者：27531zsz (赞：2)

一道搜索题，不难，深搜，宽搜都一样，我的是宽搜，找到相邻的数字。代码实现如下：附带题解。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},ans=0,x,y,t,w;
//上面花括号的是定义方向，搜索。 
int dl[5000][3];
char spore;
bool bz[111][111];
void bfs(int q,int p)//bfs，宽搜。 
{
    t=1;
    w=1;
    bz[q][p]=false;
    dl[1][1]=q;
    dl[1][2]=p;
    while(t<=w)//当头小于尾的时候才开始循环，避免鬼畜。。 
    {
        for(int s=0;s<4;s++)//四个方向搜索。 
        {
            x=dl[t][1]+dx[s];
            y=dl[t][2]+dy[s];
            if(x>=0&&y>=0&&x<m&&y<n&&bz[x][y])
            {
                w++;
                bz[x][y]=false;
                dl[w][1]=x;
                dl[w][2]=y;
            }
        }
        t++;
    }
}
int main()
{
    cin>>m>>n;
    for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
    {
        cin>>spore;
        if(spore>'0')
        {
            bz[i][j]=true;//如果输入的细胞不为0，则打上true。 
        }
    }
    for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
    {
        if(bz[i][j])
        {
            bfs(i,j);//宽搜一下。 
            ans++;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Dream_It_Possible (赞：2)

这题和P1596十分相似，都是找联通块，但这题是向四面搜，P1596是向八面搜。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath> 
#include<cstring>
using namespace std;
int a[200][200],n,m,ans,i,j;
int b;
void f(int x,int y)
{
    if (!a[x][y])
    return;
    a[x][y]=0;//符0，表示搜过，不在搜了。
    f(x-1,y);//向下。
    f(x+1,y);//向上。
    f(x,y-1);//向左。
    f(x,y+1);//向右。
        //共4个方向。
}
int main()
{
    cin>>n>>m;
    for (i=1;i<=n;i++)
    for (j=1;j<=m;j++)
    {
        scanf("%1d",&a[i][j]);//不要用cin读入!
    }
    for (i=1;i<=n;i++)
    for (j=1;j<=m;j++)
    {
        if (a[i][j]!=0)
        {
            ans++;//找到一个
            f(i,j);//以这一点去搜。
        }
    }
    cout<<ans;//输出
    return 0;
}//建议做完这题可以去看看P1596
```

---

## 作者：DESpairest (赞：2)

此题与填涂颜色有些类似，其实只需分为“等于0”和“不等于0”两种数然后求不等于的堆数。
---------------------------------
然后关键是在搜索到细胞后就要“搜到死”，直到四个方向上都不再是细胞了，则代表此细胞已经凉凉，可以删掉它了，就免去多次遍历。而且为了表示你记住了此细胞，开一个容器sum，在搜到第一个细胞数后直接++；
-----------------------------------------
```
#include<bits/stdc++.h>
using namespace std;
int m,n;
int sum=0;
int a[110][110];
void dfs(int x,int y)
{
	
	if(x>m||x<1||y>n||y<1||a[x][y]==0) return;
	//printf("%d%d\n",x,y);
	a[x][y]=0;
	dfs(x,y-1);
	dfs(x,y+1);
	dfs(x-1,y);
	dfs(x+1,y);
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			scanf("%1d",&a[i][j]);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)		
		{
		if(a[i][j])
			{
				sum++;
				dfs(i,j);
		 	} 	
		}
printf("%d",sum);
return 0;
}
```

---

## 作者：hz4zzhangyue (赞：2)

##这题我主要循环搜索矩形阵列中的细胞（即不为零的数字） 每次找到一个数字就调用过程search进行搜索 将附近所有不为零的数字（同一个细胞）全部置零

具体实现过程在代码注释中均已标明

```cpp
Var
  i,j,m,n,tot:longint;//i，j为循环变量 tot记录细胞总数
  map:array[0..101,0..101] of longint;//边界开大一点点 不然会越界
  c:char;
Procedure search(p,q:longint;flag:boolean);//如果flag为true则代表正在搜索一个新的细胞群 如为false代表正在将整个细胞群置零
  var
    i:longint;
  begin
    if map[p,q]=0 then exit;//这不是细胞 退出
    if flag then//如果正在寻找一个新的细胞群且已找到则累加总数
      inc(tot);
    map[p,q]:=0;//置零此细胞
    search(p+1,q,false);//置零周围细胞
    search(p-1,q,false);
    search(p,q+1,false);
    search(p,q-1,false);
  end;
Begin
  readln(m,n);
  tot:=0;
  for i:=1 to m do begin
    for j:=1 to n do begin
      read(c);//因为输入是连在一起的 这里用了字符类型分离每个数字方便下一步存储在数组里
      map[i,j]:=ord(c)-ord('0');
    end;
    readln;//读完一行 防止读到行尾空格所以换行
  end;
  for i:=1 to m do
    for j:=1 to n do
      search(i,j,true);//枚举整个矩阵
  writeln(tot); 
End.
```

---

## 作者：sedimentaryrock (赞：2)

1、从文件中读入m\*n矩阵，将其转换为0、1矩阵存入a数组中；

2、沿a数组矩阵从上到下，从左到右，找到遇到的第一个细胞；将细胞的位置入队q，并沿其上、下、左、右四个方向上搜索，如果遇到细胞(a[i,j]=1)则将其位置入队，入队后的位置a[i,j]数组置为0；

3、将h队的队头出队，沿其上、下、左、右四个方向上搜索，如果遇到细胞则将其位置入队，入队后的位置a数组置为0；

4、重复3，直至h队空为止，则此时找出了一个细胞；

5、重复2，直至矩阵找不到细胞；

6、输出找到的细胞数。


```cpp
#include<iostream>  
#include<cstring>  
#include<queue>  
#include<cstdio>  
using namespace std;  
const int gx[4]={0,0,-1,1};  
const int gy[4]={1,-1,0,0};  
int m,n,tot=0;  
bool a[110][110];  
void init();  
void work(int,int);  
int main()  
{  
    init();  
    for(int i=1;i<=m;i++)//枚举整个m*n矩阵   
      for(int j=1;j<=n;j++)  
        if(a[i][j])work(i,j);//找到一个细胞，并对该细胞进行处理   
    cout<<tot<<endl;  
    return 0;  
}  
void work(int x,int y)  
{  
    queue<int> qx,qy;//两队列分别存储当前点的行和列   
    int x1,y1;  
    tot++;//细胞数加一   
    qx.push(x);//把当前细胞的行和列入队   
    qy.push(y);  
    a[x][y]=0;//当前细胞因为已计算，赋为false   
    while(!qx.empty())//当队列非空   
    {  
        for(int i=0;i<4;i++)//对当前细胞的上下左右进行搜索   
        {  
            x1=qx.front()+gx[i];  
            y1=qy.front()+gy[i];  
            if(x1>0&&x1<=m&&y1>0&&y1<=n&&a[x1][y1])  
            {  
                qx.push(x1);//如果没有越界且（x1,y1）为细胞 ，入队   
                qy.push(y1);  
                a[x1][y1]=false;   
            }  
        }  
        qx.pop();//for循环结束，a[x][y]相邻细胞处理完成，则将其出队   
        qy.pop();  
    }  
}  
void init()  
{  
    string s;  
    cin>>m>>n;  
    for(int i=1;i<=m;++i)  
    {  
        cin>>s;   
        for(int j=0;j<n;++j)  
          if(s[j]=='0')a[i][j+1]=0;  
          else a[i][j+1]=1;  
    }  
}
```

---

## 作者：HTensor (赞：1)

## Solution P1451

读入可能有困难，这里介绍一种读入方法：

```cpp
int getchar(void) : 返回一个输入缓冲区的字符的ASCII码
```

观察可知，对于一个数字的ASCII码（如‘0’）只要将其 ^ 48 （异或运算）即可得到ASCII码所表示的数字（或者&15（与运算））

如：‘0’ ^ 48 = 0， ‘1’ & 15 = 1

但是getchar有一个弊端，就是会将换行符一起读入，而Linux和Windows丢弃换行符的命令不同，前者需要两个getchar，而后者只需要一个

所以这里再提供一种通用的方法：

```cpp
cin.ignore(int len, char ch) : 它表示忽略从输入流 cin 中提取的字符，如果计数值达到 len 或者读入到 ch ，则停止。
```

故读入部分可以这样写

```cpp
cin >> n >> m;
for(int i = 1; i <= n; i++)
{
	cin.ignore(1024, '\n');
	for(int j = 1; j <= m; j++)
	{
		ma[i][j] = getchar();
		ma[i][j] ^= 48;
	}
}
```



用vis\[x][y]表示第x行第y列是否已经搜过，ma\[x][y]存储第x行第y列的数字，搜索即可：

```cpp
void dfs(int x, int y)
{
	//cout << x << " " << y << endl;
	if(x < 1 || y < 1 || x > n || y > m) return ;
	if(vis[x][y] == 1) return ;
	if(ma[x][y] == 0) return ;
	vis[x][y] = 1;
	dfs(x + 1, y); dfs(x - 1, y);
	dfs(x, y + 1); dfs(x, y - 1);
	return ;
}
int main()
{
	/* ...... */
	int ans = 0;
	
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(vis[i][j] == 0 && ma[i][j] != 0) dfs(i, j), ans++;
	
	cout << ans << endl;
    return 零;
}
```





---

## 作者：sycqwq (赞：1)

这种题目，在我眼中已经算板子题了，用的dfs。

思路：开始对矩阵进行搜索，搜索到一个不为0的数就ans++，开始dfs。

dfs的作用：寻找一片细胞，防止重复，从第一个发现的开始，一直搜索下去，只要有路劲可以到达的，如果不为0就设为0，防止重复。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int w[105][105]={{0,0},{0,1},{0,-1},{1,0},{-1,0}};//上、下、左、右四个方向
	char a[105][105];
	int n,m;
int dfs(int x,int y)
{
	int xx,yy;
	for(int i=1;i<=4;i++)
	{
		xx=x+w[i][0];//移动
		yy=y+w[i][1];
		a[x][y]='0';//已经搜索到了，设为0
		if(xx>n||xx<1||yy<1||yy>m||a[xx][yy]=='0')//判断边界
			continue;
		a[xx][yy]='0';//设为0
		dfs(xx,yy);//继续搜索
		
	}
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	int s=0;
	for(int i=1;i<=n;i++)//开始寻找
		for(int j=1;j<=m;j++)
			if(a[i][j]!='0')
			{
				++s;
				dfs(i,j);//只要是同一个细胞就为0
			}
	cout<<s;
    return 0;
}

```

---

## 作者：自然杀手细胞 (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
string s;//我们看到这个输入数据有毒，没空格，机智地选用string读入。
int ans,n,m; 
int a[110][110];
bool vis[110][110];
int h[10080],k[10080];
int c[5]={0,1,-1,0,0};//手动控制—-—
int d[5]={0,0,0,1,-1};
void bfs(int x,int y)
{
	memset(h,0,sizeof(h));//注意清空数组，以免对后面的答案产生干扰。
	memset(k,0,sizeof(k));
	int head=1,tail=1;
	h[1]=x;//头的点定住
	k[1]=y;
	vis[x][y]=1;//并标记为访问过
	while(head<=tail)//保证循环跳出
	{
		for(int i=1;i<=4;i++)//懒癌晚期
		{
			if(h[head]+c[i]<=n&&h[head]+c[i]>0&&k[head]+d[i]>0&&k[head]+d[i]<=m&&a[h[head]+c[i]][k[head]+d[i]]!=0&&vis[h[head]+c[i]][k[head]+d[i]]==0)//不要被这长长的一坨吓住，他表示的是向下探索的坐标在定义域内，且是细胞的一部分（即不是数字0），最后一点注意的就是这个点没有被访问过。
			{
				tail++;//在满足上面的条件后，就表示我们假设探索的点符合要求，那么就把它加入进来。
				h[tail]=h[head]+c[i];//更新，存储新坐标
				k[tail]=k[head]+d[i];
				vis[h[tail]][k[tail]]=1;//别忘了标记为已经访问过。
			}
		}
		head++;//头向后缩一个单位
	}
	ans++;//a new cell!!!
}
int main()
{
	cin>>n>>m;
	int i,j;注意循环变量开全局可不是个好习惯
	for(i=1;i<=n;i++)
	{
        cin>>s;//读入
        for(j=1;j<=m;j++)
        {
        	a[i][j]=s[j-1]-'0'; //注意一点，字符串的读入是从s[0]开始的，而这里的j从1开始（string的好处就有能与字符数组无缝转换）
        }
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(a[i][j]!=0&&vis[i][j]==0)//，遍历所有的点，如果发现该点未被访问过且是一只细胞
			bfs(i,j);//从当前点开始BFS
		}
	}
	cout<<ans<<endl;//输出结果
	return 0;//蒟蒻没胆子不写return 0；
}


---

## 作者：Arvin2018 (赞：1)

#### 本蒟蒻提交了好多好多次才AC

## 主要是输入的锅！！！

~~害死人的~~输入输出：（10分）https://www.luogu.org/recordnew/show/16440373

AC一个点纯属巧合……

关于Linux的输入，详见[这里](https://www.luogu.org/wiki/show?name=%E5%B8%AE%E5%8A%A9)，主要是换行的锅

下面上AC代码~


```cpp
#include <bits/stdc++.h>
using namespace std;

int a[105][105];//输入
bool v[105][105];//判断
int X[4] = {0, 0, 1, -1};
int Y[4] = {1, -1, 0, 0};//X、Y分别代表四个方向

void dfs(int x, int y){//深搜开始~
    v[x][y] = true;//标记为已访问
    for(int i = 0;i < 4; i++){
        if(a[x + X[i]][y + Y[i]] != 0 && !v[x + X[i]][y + Y[i]]){//4个方向 & 未访问
            dfs(x + X[i], y + Y[i]);
        }
    }
}

int main(){
    int m, n;
    cin >> m >> n;
    string c;
    getline(cin, c);//坑就坑在这儿，这是在LuoguIDE上亲手实践出的T-T
    for(int i = 1;i <= m; i++){
        getline(cin,c);
        for(int j = 1;j <= n;j++){
            a[i][j] = c[j-1] - '0';//输入
        }
    }
    //实践代码，时间紧的飞过去~
//	for(int i = 1;i <= m; i++){
//		for(int j = 1;j <= n;j++){
//			cout << a[i][j] ;
//		}
//		cout << endl;
//	}
	//实践代码结束
    int ans = 0;
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n;j++){
            if(a[i][j] != 0 && !v[i][j] ){//如果这个细胞未被搜索过 并且不是0
                ans++;
                dfs(i,j);
            }
        }
    }
    cout << ans;//输出
    return 0;
}
```





---

## 作者：dudujerry (赞：1)

广搜的框架。

拓展新节点，存入队列。将老结点删除（残忍-.-）。

如果队列空了就说明找到一个细胞。

啊啊啊之前因为有一句赋值写成两个等号找了半个小时才AC啊啊啊！

惨。不说了下面题解。




                
                
            
```cpp
#include<iostream>
//#include<windows.h>
using namespace std;
struct DATA{
    int x;
    int y;
}data[10000];
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};
int m,n,ans;
char _map[100][100];
void search(int x1,int y1)
{
    int t=0,w=1;
    data[0].x=x1,data[0].y=y1;
    while(t<w)
    {
        for(int i=0;i<4;i++)
        {
            int xx=data[t].x+dx[i];
            int yy=data[t].y+dy[i];
            if(xx>=0&&yy>=0&&xx<m&&yy<n)//不出界
            {
                if(t>=w)//队空
                {
                    ans++;
                    return;
                }
                else if(_map[xx][yy]<='9'&&_map[xx][yy]>='1')
                {
                    //拓展节点
                    data[w].x=xx;
                    data[w].y=yy;
                    _map[xx][yy]='0';
                    w++;
                    /*system("cls");
                    for(int i=0;i<m;i++)
                    {
                        for(int j=0;j<n;j++)
                        {
                            cout<<_map[i][j];//测试数据
                        }
                        cout<<endl;
                    }
                    Sleep(1000);*/
                }
            }
        }
        t++;
    }
    ans++;
    return;
}
int main()
{
    cin>>m>>n;
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>_map[i][j];
        }
    }
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(_map[i][j]<='9'&&_map[i][j]>='1')
            {
                search(i,j);//每遇到细胞运行函数
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Drinkkk (赞：1)

/\*
P1451 题解

深度优先搜索

\*/
```cpp
#include <cstdio>//头文件
int dx[4]={1,0,-1,0};//偏移量（横向，注：顺序是下、右、上、左）
int dy[4]={0,1,0,-1};//偏移量（纵向，注：顺序是下、右、上、左）
char ma[101][101];//ma数组是用来存储地图的（因为输入之间没有空格，所以要开char）
void dfs(int x,int y)//深度优先搜索所使用到的函数（int x,int y表示当前在ma数组的[x,y]点）
{
    for(int i=0;i<=3;i++)//按照下、右、上、左的顺序去搜索这个大细胞当中还有没有小细胞
    {
        int nx=x+dx[i];//新的x坐标（即下一步所走的位置的x坐标）
        int ny=y+dy[i];//新的y坐标（即下一步所走的位置的y坐标）
        if(ma[nx][ny]>='1' && ma[nx][ny]<='9')//如果在这个大细胞里面还有一些的小细胞
        {
            ma[nx][ny]='0';//把这个细胞“吃”掉
            dfs(nx,ny);//以这个新的点为基础又在周围的四个点进行搜索
        }
    }
}
int main()//主函数（即main函数）
{
    int n=0,m=0,ans=0;//n和m表示这是一个n行m列的地图，ans表示在这个地图里有ans个大细胞
    scanf("%d %d",&n,&m);//读入n和m
    for(int i=1;i<=n;i++)//读入这一个n行m列的矩阵
    {
        scanf("%s",ma[i]+1);//读入第i行的地图
    }
    for(int i=1;i<=n;i++)//开始寻找有多少个大细胞
    {
        for(int j=1;j<=m;j++)
        {
            if(ma[i][j]>='1' && ma[i][j]<='9')//如果找到这一个大细胞
            {
                ans++;//那么就将ans加1
                dfs(i,j);//进行深度优先搜索
            }
        }
    }
    printf("%d",ans);//输出大细胞的个数
    return 0;//结束程序
}
```

---

## 作者：wqd008 (赞：1)

貌似大家都是深搜的 那就让我这个菜鸟发个广搜吧

其实深搜和广搜皆可 不过看了深搜的代码 似乎会简单点 可惜正在学广搜 只能写广搜啦

与楼上的某一位好像有相似之处

有建议请私信



```cpp
program p1451;
const dx:array[1..4] of -1..1=(-1,0,1,0);//横坐标的变化
      dy:array[1..4] of -1..1=(0,1,0,-1);
var
  s:string;
  pic:array[1..100,1..100] of longint;//存数字 
  bz:array[1..100,1..100] of boolean;//用作判断用 很重要
  m,n,i,j,num:longint;
  h:array[1..4000,1..2] of longint;
procedure doit(p,q:longint);
var i,t,w,x,y:longint;
begin
  inc(num); bz[p,q]:=false;
  t:=1; w:=1;  h[1,1]:=p;  h[1,2]:=q;//遇到的第一个细胞入队
  repeat
    for i:=1 to 4 do//搜索这个细胞的四个方向
    begin
      x:=h[t,1]+dx[i];   y:=h[t,2]+dy[i];
      if (x>0) and (x<=m) and (y>0) and (y<=n) and bz[x,y]
        then begin inc(w);  h[w,1]:=x;  h[w,2]:=y;  bz[x,y]:=false; end;
    end;//搜索到细胞就入队
  inc(t);//队头指针加1
  until t>w;//队空 退出
end;
begin
  fillchar(bz,sizeof(bz),true);
  num:=0;
  readln(m,n);
  for i:=1 to m do
  begin
    readln(s);
    for j:=1 to n do
    begin
      pic[i,j]:=ord(s[j])-ord('0');
      if pic[i,j]=0 then bz[i,j]:=false;
    end;
  end;
  for i:=1 to m do
    for j:=1 to n do if bz[i,j] then doit(i,j);//在矩阵中开始寻找细胞
  writeln(num);
end.
```

---

## 作者：makabaka217 (赞：1)

简单的深搜，每找到一个不是0的细胞就在存储细胞总数的变量中加1，说明这个细胞已经被找到。

将细胞的位置从上，下，左，右四个方向搜索，每找到一个就在b数组相应的位置赋为false，表示这个细胞已经被找到，下次不用搜索了。

把每一个点都搜索一遍就可以得到正确的答案了。

```cpp
const
a:array[1..4,1..2] of -1..1=((1,0),(-1,0),(0,1),(0,-1));//记录了上，下，左，右四个方位
var
n,m,i,j,szj:longint;
s:string;
b:array[0..100,0..100] of boolean;//存储该位置细胞有没有被找过
procedure f(i,j:longint);//广搜过程
var
k,x,y:longint;
begin
b[i,j]:=false;
for k:=1 to 4 do
begin
x:=i+a[k,1];y:=j+a[k,2];//细胞上，下，左，右的位置
if b[x,y] then f(x,y);//没找过就搜索该细胞上，下，左，右
end;end;
begin
readln(n,m);
for i:=1 to n do
begin
readln(s);
for j:=1 to m do
begin
if s[j]<>'0' then
b[i,j]:=true;
end;
end;
for i:=1 to n do
for j:=1 to m do
if b[i,j] then begin f(i,j);inc(szj);end;
writeln(szj);
end.
```

---

## 作者：CallMeTewi (赞：1)

蒟蒻并不会什么高级算法，只用了深搜二维数组的办法；

每搜索到一个新细胞就标记它，知道地图结束。

```cpp
#include <iostream>
#include <string>
using namespace std;

string inp;  //输入字符串用
int map[150][150];//二维数组
int n=0,m=0,ans=0;//坐标，答案

void srch(int,int);//搜索的函数
void sgn(int,int);//标记的函数

int main()
{
    for(int i=0;i<150;i++)
     for(int j=0;j<150;j++)
     {
          map[i][j]=0;  //初始化
     }
        
    cin>>n>>m;
    getline(cin,inp);
    for(int i=0;i<n;i++)
    {
        getline(cin,inp);
        for(unsigned int j=0;j<m;j++)
        map[i][j]=(int)(inp[j])-48;
    }//输入
    
    srch(0,0);//开始搜索
    cout<<ans<<endl;//输出
    return 0;
}

void srch(int a,int b)
{
    if((a>=n)&&(b>=m))return;//递归边界
    if((map[a][b])&&(map[a][b]!=10))
    {
        ans++;  //搜索到新细胞之后的标记操作
        sgn(a,b);
    }
    if(b>=m){srch(a+1,0);}//换行操作
    else {srch(a,b+1);}//下一个
    
    return;
}

void sgn(int a,int b)
{
    if((a<0)||(a>=n)||(b<0)||(b>=m)||(!map[a][b])||(map[a][b]==10))return;//递归边界
    map[a][b]=10;//标记操作
    
    sgn(a,b+1);//搜索方案
    sgn(a+1,b);
    sgn(a,b-1);
    sgn(a-1,b);
    
    return;
}

```

---

## 作者：难上加兰 (赞：1)

使用队列，深搜

```delphi

const
  dx:array[1..4] of -1..1=(-1,0,1,0);//横坐标：上下左右
  dy:array[1..4] of -1..1=(0,1,0,-1);//横坐标：上下左右
var
  s:string;
  a:array[1..50,1..80] of 0..1;//存储矩阵的数组，0：无细胞，1：有细胞
  m,n,i,j,num:integer;
  h:array[1..4000,1..2] of byte;//队列：存细胞的坐标,1:行，2：列;
procedure try(p,q:integer);//处理坐标(p,q)的细胞
var 
  i,t,w,x,y:integer;
begin
  inc(num);
  a[p,q]:=0;
  t:=1;//队头
  w:=1;//队尾
  h[1,1]:=p;
  h[1,2]:=q;//遇到第一个细胞入队
  repeat
    for i:=1 to 4 do  //沿细胞的上下左右四个方向搜索细胞
      begin
        x:=h[t,1]+dx[i];
        y:=h[t,2]+dy[i];
        if(x>0) and (x<=m) and (y>0) and (y<=n) and (a[x,y]=1) then
          begin
            inc(w);
            h[w,1]:=x;
            h[w,2]:=y;
            a[x,y]:=0;
          end;//为细胞的入队
      end;
      inc(t);//队头指针加1，出队
    until t>w ;//直至队空为止
end;
begin  //主程序
  fillchar(a,sizeof(a),0);//初始化数组
  fillchar(h,sizeof(h),0);//初始化队列
  num:=0;
  readln(m,n);
    for i:=1 to m do //读入矩阵
      begin
        readln(s);
        for j:=1 to n do
          if s[j]='0'then a[i,j]:=0 else a[i,j]:=1;
      end;
    for i:=1 to m do
      for j:=1 to n do
        if a[i,j]=1 then try(i,j); //在矩阵中寻找细胞
          writeln(num);//输出细胞个数
end.

```（pascal）


---

## 作者：installb (赞：1)

一道bfs的模板题  
**1.读入**  
先输入m和n  
后面就m行 每行输入n个字符  
这里直接用cin一个一个读 cin读入字符会自动过滤空格和回车  
然后存数组 相应位置的值为当前字符减去'0'的ASCII码  
(1~9中任意一个数字的ASCII码等于0加上该数字)  
**2.搜索**  
先从头到尾循环 如果这个点为0 那么跳过 否则开始搜索  
把所有搜索到的点的值变为0 这样下次访问到这个点就不会搜索下去了  
搜索一次计数器+1 最终计数器中的值就是答案  
由于所有点(包括边界以外)的值初值都为0 这道题不需要判断边界
## 代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
struct node{
	int x,y;
}a;
queue <node> q;
int dx[4] = { 0, 0, 1,-1}; 
int dy[4] = {-1, 1, 0, 0};
int cnt = 0,n,m;
int mp[105][105] = {0};
char ch;
int main(){
	cin >> n >> m;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			cin >> ch;
			mp[i][j] = ch - '0'; // 读入 存数组
		}
	}
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			if(!mp[i][j]) continue;
            // !0 = 1 如果为0就找下一个格子
            // 令x为任意非零整数 !x=0
			cnt ++; // 计数器+1
            // 这个点值是0 是细胞且该细胞第一次被访问
			a.x = i;
			a.y = j;
			q.push(a);
			while(!q.empty()){
				a = q.front();
				q.pop();
				mp[a.x][a.y] = 0;
				for(int i = 0;i < 4;i ++){
                	// 通过建立dx dy数组直接通过for循环枚举四个方向
					int tx = a.x + dx[i];
					int ty = a.y + dy[i];
					if(!mp[tx][ty]) continue;
					q.push({tx,ty}); // 入队
				}
			}
		}
	}
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：HeartBlock_Love (赞：0)

【算法分析】

   ⑴从文件中读入m*n矩阵阵列，将其转换为boolean矩阵存入bz数组中；
   
   ⑵沿bz数组矩阵从上到下，从左到右，找到遇到的第一个细胞；
   
   ⑶将细胞的位置入队h，并沿其上、下、左、右四个方向上的细胞位置入队，入队后的位置bz数组置为flase；

    ⑷将h队的队头出队，沿其上、下、左、右四个方向上的细胞位置入队，入队后的位置bz数组置为flase；

    ⑸重复4，直至h队空为止，则此时找出了一个细胞；
    
    ⑹重复2，直至矩阵找不到细胞；

    ⑺输出找到的细胞数。

    ```
    #include<cstdio>
    using namespace std;
    int dx[4]={-1,0,1,0},
    dy[4]={0,1,0,-1};
    int bz[100][100],num=0,n,m; 
    void doit(int p,int q)
    {
       int x,y,t,w,i;
       int h[1000][2];
       num++;bz[p][q]=0;
        t=0;w=1;h[1][1]=p;h[1][2]=q;       //遇到的第一个细胞入队
       do
     {
     t++;                                          //队头指针加1
     for (i=0;i<=3;i++)                      //沿细胞的上下左右四个方向搜索细胞
      {
        x=h[t][1]+dx[i];y=h[t][2]+dy[i];
        if ((x>=0)&&(x<m)&&(y>=0)&&(y<n)&&(bz[x][y]))  //判断该点是否可以入队
         {
           w++;
           h[w][1]=x;
           h[w][2]=y;
           bz[x][y]=0;
         }                                         //本方向搜索到细胞就入队
      }
    }while (t<w);                            //直至队空为止
     }
    int main()
    {
        int i,j; 
        char s[100],ch;
        scanf("%d%d\n",&m,&n);
        for (i=0; i<=m-1;i++ )
         for (j=0;j<=n-1;j++ )
       bz[i][j]=1;                              //初始化
      for (i=0;i<=m-1;i++)
       {
       gets(s); 
       for (j=0;j<=n-1;j++)
        if (s[j]=='0') bz[i][j]=0;
        }
       for (i=0;i<=m-1;i++)
       for (j=0;j<=n-1;j++)
        if (bz[i][j])
        doit(i,j);                                //在矩阵中寻找细胞
       printf("NUMBER of cells=%d",num);
      return 0;
     }

```


---

## 作者：pyyyyyy (赞：0)

## p党福利
就是道普通的搜索题目

将队头出队，沿其上、下、左、右四个方向上搜索，如果遇到细胞则将其位置入队，入队后的位置a数组置为0；

直至h队空为止，则此时找出了一个细胞；

```pascal
program xibao;{细胞个数}
const dx:array[1..4] of -1..1=(-1,0,1,0);
      dy:array[1..4] of -1..1=(0,1,0,-1);
var int:text;
    name,s:string;
    pic:array[1..50,1..79] of byte;
    bz:array[1..50,1..79] of boolean;
    m,n,i,j,num:integer;
    h:array[1..4000,1..2] of byte;
procedure doing(p,q:integer);
  var i,t,w,x,y:integer;
  begin
    inc(num);bz[p,q]:=false;
    t:=1;w:=1;h[1,1]:=p;h[1,2]:=q;{遇到的第一个细胞入队}
    repeat
      for i:=1 to 4 do{沿细胞的上下左右四个方向搜索细胞}
        begin
          x:=h[t,1]+dx[i];y:=h[t,2]+dy[i];
          if (x>0) and (x<=m) and (y>0) and (y<=n) and bz[x,y]
          then begin inc(w);h[w,1]:=x;h[w,2]:=y;bz[x,y]:=false;end;{为细胞的入队}
end;
inc(t);{队头指针加1}
until t>w;{直至队空为止}
end;
begin
fillchar(bz,sizeof(bz),true);num:=0;
reset(input);
rewrite(output);
readln(m,n);
for i:=1 to m do
begin readln(s);
for j:=1 to n do
begin pic[i,j]:=ord(s[j])-ord('0');
if pic[i,j]=0 then bz[i,j]:=false;
end;
end;
for i:=1 to m do
for j:=1 to n do if bz[i,j] then doing(i,j);{在矩阵中寻找细胞}
writeln(num);
close(input);
close(output);
end.

```


---

## 作者：little_gift (赞：0)

##(Pascal居然只有一个用BFS的题解，那我来写一个)思路：用DFS，找到一个未被标记的细胞后，先累积数量，然后标记它，再对其上下左右进行深搜，若发现未被标记的细胞，则递归...

```cpp
const
  e:array[1..4,1..2] of -1..1=((1,0),(-1,0),(0,1),(0,-1)); //存储上下左右的坐标
var
  n,m,i,j,s:longint;
  st:string;
  b:array[0..81,0..81] of boolean; //存储细胞是否被标记过，true为未标记，false为已标记
procedure f(i,j:longint); //深搜过程
  var
    k,x,y:longint;
  begin
    b[i,j]:=false; //标记这个细胞
    for k:=1 to 4 do
      begin
        x:=i+e[k,1]; //存储上下左右的x坐标
        y:=j+e[k,2]; //存储上下左右的y坐标
        if b[x,y] then //如果未被标记过
          f(x,y); //DFS这个坐标
      end;
  end;
begin
  readln(n,m); //输入n,m
  for i:=1 to n do
    begin
      readln(st); //读入一个字符串，这样可以避免读入回车
      for j:=1 to m do
        begin
          if st[j]<>'0' then
            b[i,j]:=true; //如果它是细胞，就去除标记
        end;
    end;
  for i:=1 to n do
    for j:=1 to m do
      if b[i,j] then //如果未被标记
        begin
          f(i,j); //DFS该细胞
          inc(s); //增加一个细胞数量
        end;
  writeln(s); //输出细胞数量
end.
```

---


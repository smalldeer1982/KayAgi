# 圣诞夜的极光

## 题目背景

圣诞夜系列~~


## 题目描述

圣诞老人回到了北极圣诞区，已经快到 12 点了。也就是说极光表演要开始了。这里的极光不是极地特有的自然极光景象。而是圣诞老人主持的人造极光。

轰隆隆 …… 烟花响起（来自中国的浏阳花炮之乡）。接下来就是极光表演了。

人造极光其实就是空中的一幅幅 $n\times m$ 的点阵图像。只是因为特别明亮而吸引了很多很多小精灵的目光，也成为了圣诞夜最美丽的一刻。

然而在每幅 $n \times m$ 的点阵图像中，每一个点只有发光和不发光两种状态。对于所有的发光的点，在空中就形成了美丽的图画。而这个图画是以若干个（$s$ 个）图案组成的。对于图案，圣诞老人有着严格的定义：对于两个发光的点，如果他们的曼哈顿距离（对于 $A(x_1, y_1)$ 和 $B(x_2, y_2)$ ，$A$ 和 $B$ 之间的曼哈顿距离为 $|x_1-x_2|+|y_1-y_2|$ ）小于等于 $2$。那么这两个点就属于一个图案 …… 小精灵们一边欣赏着极光，一边数着每一幅极光图像中的图案数。伴着歌声和舞蹈，度过了美丽的圣诞之夜。^_^

## 说明/提示

$1 \le n,m \le 100$。

DFS~~

## 样例 #1

### 输入

```
19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------```

### 输出

```
4```

# 题解

## 作者：欢语_暗影 (赞：40)

讲解：

这道题一看，各位读者就知道是DFS求连通图，水~，在此贴出DFS的代码和BFS的代码以及编者自己歪歪出的并查集代码。

代码实现：
DFS:
```cpp
#include<iostream>
using namespace std;
const int nx[13]={0,1,-1,0,0,2,-2,0,0,1,-1,1,-1};
const int ny[13]={0,0,0,1,-1,0,0,2,-2,-1,1,1,-1};//方向数组 
char a[1001][1001];
int n,m,ans;
void dfs(int x,int y)
{
	int i; 
	if(x<1 || x>n || y<1 || y>m || a[x][y]!='#') return;
    //越界或已走过就return 
    a[x][y]='-';//标记已走过 
    for(i=1;i<=12;i++) dfs(x+nx[i],y+ny[i]);
}
int main()
{
	int i,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j]; 
    for(i=1;i<=n;i++)
	{
        for(j=1;j<=m;j++)
		{
            if (a[i][j]=='#')
			{
                ans++;
                dfs(i,j);
            }
        }
    }
    cout<<ans;
}

```
BFS:
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<cmath>
using namespace std;
char a[101][101];
int book[101][101],n,m;
struct note{int x,y;};
void bfs(int x,int y)
{   
    int tx,ty,k;
    int next[12][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1},{-2,0},{0,-2},{0,2},{2,0}};
    queue<note>q;
    note z;
    q.push((note){x,y});
    book[x][y]=1;
    while(!q.empty())
    {   
        z=q.front();
        for(k=0;k<12;k++)
        {   
            tx=z.x+next[k][0];
            ty=z.y+next[k][1];
            if(tx<1||tx>n||ty<1||ty>m)  continue;
            if(a[tx][ty]=='#'&&book[tx][ty]==0)
            {   
                book[tx][ty]=1;
                q.push((note){tx,ty});
            }
        }
        q.pop();
    }
    return;
}
int main()
{   
    int i,j,ans=0;
    scanf("%d%d\n",&n,&m);
    //编者实测，没有\n你会wa（wrong answer） 
    for(i=1;i<=n;i++) gets(a[i]+1);//没有你会tle（超时） 
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) if(a[i][j]=='#'&&!book[i][j]) bfs(i,j),ans++;
    cout<<ans;    
}


```
并查集：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int inf=110;
int a[inf][inf],n,m,ans,i,j,f[(inf+1)*(inf+1)];
int gets(int x)
{
    if(f[x]==x) return x;
    return f[x]=gets(f[x]);
}
void ff(int x,int y)
{
    int t1=gets(x),t2=gets(y);
    f[t1]=t2;
    return;
}
int main()
{
    char ch[inf];
    scanf("%d%d",&n,&m);
    for(i=1;i<=(n+1)*(inf+1)+(m+1);i++) f[i]=i;
    for(i=1;i<=n;i++)
    {
        scanf("%s",&ch);
        for(j=1;j<=m;j++)
        {
            if(ch[j-1]=='-') a[i][j]=0;
            else a[i][j]=1;	
        }
    }
    for(i=1;i<=n;i++)
    {
    	for(j=1;j<=m;j++)
    	{
    		if(a[i][j]==0) continue;
            if(i-1>=1 && a[i-1][j]!=0) ff((i-1)*inf+j,i*inf+j);
            if(i-2>=1 && a[i-2][j]!=0) ff((i-2)*inf+j,i*inf+j);
            if(i+1<=n && a[i+1][j]!=0) ff((i+1)*inf+j,i*inf+j);
            if(i+2<=m && a[i+2][j]!=0) ff((i+2)*inf+j,i*inf+j);
            if(j-1>=1 && a[i][j-1]!=0) ff(i*inf+(j-1),i*inf+j);
            if(j-2>=1 && a[i][j-2]!=0) ff(i*inf+(j-2),i*inf+j);
            if(j+1<=m && a[i][j+1]!=0) ff(i*inf+(j+1),i*inf+j);
            if(j+2<=m && a[i][j+2]!=0) ff(i*inf+(j+2),i*inf+j);
            if(i-1>=1 && j-1>=1 && a[i-1][j-1]!=0) ff((i-1)*inf+(j-1),i*inf+j);
            if(i-1>=1 && j+1<=m && a[i-1][j+1]!=0) ff((i-1)*inf+(j+1),i*inf+j);
            if(i+1<=n && j-1>=1 && a[i+1][j-1]!=0) ff((i+1)*inf+(j-1),i*inf+j);
            if(i+1<=n && j+1<=m && a[i+1][j+1]!=0) ff((i+1)*inf+(j+1),i*inf+j);
        }
    }
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) if(f[i*inf+j]==i*inf+j && a[i][j]!=0) ans++;
    printf("%d",ans);
    return 0;
}


```

---

## 作者：A_villain (赞：12)

#### ~~蒟蒻我又来啦（第三篇喽，上一篇还在审核，希望能通过）~~

这道题不就是标准的dfs嘛

存好图之后，搜索每一个点，搜到一个‘#’之后把能扩展到的都变成 ‘-’，然后答案加一，最后输出一下就好了

思路清晰，我这么久没写dfs，忘记数组这个东西了，就手动去找每一个点，是不是有点傻，下面是没有用数组的代码：

```
#include<bits/stdc++.h>//偷懒专用库
#define ll long long
#define INF 110
#define MAXN 99999//宏定义
using namespace std;

inline int read(){
  char c=getchar();int x=0,f=1;
  while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f;
}

int n,m,ans;
char a[INF][INF];

void dfs(int x,int y)
{
	a[x][y]='-';
	if(a[x+2][y]=='#'&&x+2<=n) dfs(x+2,y);
	if(a[x-2][y]=='#'&&x-2>=1) dfs(x-2,y);
	if(a[x][y+2]=='#'&&y+2<=m) dfs(x,y+2);
	if(a[x][y-2]=='#'&&y+2>=1) dfs(x,y-2);
	if(a[x+1][y]=='#'&&x+1<=n) dfs(x+1,y);
	if(a[x-1][y]=='#'&&x-1>=1) dfs(x-1,y);
	if(a[x][y+1]=='#'&&y+1<=m) dfs(x,y+1);
	if(a[x][y-1]=='#'&&y-1>=1) dfs(x,y-1);
	if(a[x+1][y+1]=='#'&&x+1<=n&&y+1<=m) dfs(x+1,y+1);
	if(a[x+1][y-1]=='#'&&x+1<=n&&y-1>=1) dfs(x+1,y-1);
	if(a[x-1][y+1]=='#'&&x-1>=1&&y+1<=m) dfs(x-1,y+1);
	if(a[x-1][y-1]=='#'&&x-1>=1&&y-1>=1) dfs(x-1,y-1);
}

int main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;++i)
	 for(int j=1;j<=m;++j)
	  cin>>a[i][j];
	for(int i=1;i<=n;++i)
	 for(int j=1;j<=m;++j)
	  {
	  	if(a[i][j]=='#')
	  	 {
	  	 	dfs(i,j);
	  	 	ans++;
		 }
	  }
	cout<<ans;
	return 0;
}
```
之后我又觉得这样误人子弟不太好，于是我又把数组弄了出来，放在下面吧：

```
#include<bits/stdc++.h>//偷懒专用库
#define ll long long
#define INF 110
#define MAXN 99999//宏定义
using namespace std;

inline int read(){
  char c=getchar();int x=0,f=1;
  while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f;
}//快读，可以提供借鉴 

int n,m,ans;//行，列，答案 
char a[INF][INF];//存图 
int f[12][2]={{2,0},{-2,0},{0,2},{0,-2},{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};//这就是找点的数组，画个图就出来了，按照题目给的 

void dfs(int x,int y)//搜索喽 
{
	a[x][y]='-';//直接把能到的变成 '-' 
	for(int p=0;p<12;++p)//一共可以到十二个点，数组也刚好开到11； 
	 {
	 	int dx=x+f[p][0];//扩展到的点的横坐标 
	 	int dy=y+f[p][1];//扩展到的点的纵坐标 
	 	if(dx>=1&&dx<=n&&dy>=1&&dy<=m&&a[dx][dy]=='#')//满足条件，没超界， 并且是  '#'就搜他 
	 	 dfs(dx,dy);//搜他 
	 }
}

int main()//主函数 
{
	n=read();
	m=read();//读入 
	for(int i=1;i<=n;++i)
	 for(int j=1;j<=m;++j)
	  cin>>a[i][j];//存图 
	for(int i=1;i<=n;++i)
	 for(int j=1;j<=m;++j)
	  {
	  	if(a[i][j]=='#')//搜到一个图案 
	  	 {
	  	 	dfs(i,j);//把这个图变成  '-' 
	  	 	ans++;//答案加一 ； 
		 }
	  }
	cout<<ans;//输出 
	return 0;//养成好习惯从你我做起 
}
```
~~（两个代码都是可以AC的，但是不要抄袭哦）~~

能不能给我过和赞呢，萌新题解啊

---

## 作者：1000001001wj (赞：11)

感觉题解还是难了点，其实可以更简单（因为略水，所有没写）

存的方法一样，#是1 -是0

每次读入到#的时候直接检查左侧两个上面2个和左上右上的那俩

如果有1就直接赋1然后下一个

没有再++ans一波，这样读完直接出，不用dfs

复杂度目测7nm


---

## 作者：Hamster_Air (赞：9)

###好久没有写新题解了，2018马上来了，让我留下2017的最后一篇题解吧

###这是一道典型用dfs求联通块的题目，只要会写dfs的应该都能做出来

###具体方法详见代码：

    
    
    
```cpp
    #include<bits/stdc++.h> //万能头文件
    #define f(i,j,n) for(i=j;i<=n;i++) //for循环简写，虽然被同学吐槽很多次了但我还是喜欢用
    #define ll long long //忽略这条没用的语句
    using namespace std;
    const int N=105,M=12;
    int dx[M]={-2,2,-1,1,0,0,0,0,1,1,-1,-1},dy[M]={0,0,0,0,-1,1,-2,2,1,-1,-1,1},n,m; //两个数组分别表示横轴及数轴
    char a[N][N];
    bool Map[N][N]; //bool数组用于记录此字符是否查找过了
    inline void dfs(int x,int y) //inline可以玄学加速，此过程用以查找此坐标的联通块并标记
    {
        Map[x][y]=1;
        int tx,ty,i;
        f(i,0,11)
        {
            tx=x+dx[i],ty=y+dy[i];
            if(tx<1||tx>n||ty<1||ty>m) //越界特判
                continue;
            if(a[tx][ty]=='#'&&!Map[tx][ty]) //满足条件就继续搜下去
                dfs(x+dx[i],y+dy[i]);  
        } 
    }
    int main()
    {
        ios::sync_with_stdio(false); //cin，cout玄学加速
        int i,j,ans=0;
        cin>>n>>m;
        f(i,1,n)
            f(j,1,m)
                cin>>a[i][j]; //读入
        f(i,1,n)
            f(j,1,m)
                if(a[i][j]=='#'&&!Map[i][j]) //只要此处发光且未被查找过，就将包含其的整个联通块查找并标记
                {
                    dfs(i,j);
                    ans++; //一个联通块搜完ans++即可
                }
        cout<<ans<<endl; //最后输出
        return 0; //华丽丽地结束
    }

```

---

## 作者：顾z (赞：8)

题目描述-->[p1454 圣诞夜的极光](https://www.luogu.org/problemnew/show/P1454)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题意概括:**

寻找联通块数量,这里的连通块定义与其他的不同.

这里定义为**曼哈顿距离不超过2的都属于一个联通块**.

什么?不知道曼哈顿距离是啥?

曼哈顿距离简易概括->|x1-x2|+|y1-y2|,两点之间横纵坐标的差的绝对值之和.

详细解释->[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)

## 分析
看到大家都在说12个方向,具体是哪12个方向呢?

假设黄色点为我们当前所在节点.那我们图中标出的红色点,都是满足与黄色点**曼哈顿距离为2**的点.

![](https://cdn.luogu.com.cn/upload/pic/31984.png )

但这才有8个方向啊!

回望题意,**曼哈顿距离不超过2**的都属于一个联通块

曼哈顿距离不超过2,那我们的图应该是这样的↓.

(蓝色点即为与黄色点曼哈顿距离为1的.

![](https://cdn.luogu.com.cn/upload/pic/31985.png )

所以说,现在12个方向就很明确了!

根据标明的坐标,我们很容易打出12个方向对应的位置变化. 像这样↓
```cpp
const int ax[]={-1,-2,1,2,0,0,0,0,1,1,-1,-1};
const int ay[]={0,0,0,0,1,2,-1,-2,1,-1,1,-1};
//const类型可自动识别数组大小.
//不过貌似不加const也可以识别
```
然后~~我们~~我又遇到了**难题**,

**如何输入?**

字符类型,我们一般选择用

scanf("%c"),getchar(),cin来进行输入.

但是这题,用scanf,会出现蜜汁错误.(用scanf只get到了30pts...

而用getchar则会读取行末换行符,需要加判断.

所以我们直接**选用cin来读入字符**.(感觉cin输入字符还是很少出锅的.

因此,我们搜到一个为'#'的位置,就去标记与它在一个联通块中的位置,则联通块个数++即可.

**PS：**

or ==> ||   
and==> &&

---------------------代码--------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,ans;
char res[108][108];
const int ax[]={-1,-2,1,2,0,0,0,0,1,1,-1,-1};
const int ay[]={0,0,0,0,1,2,-1,-2,1,-1,1,-1};
bool vis[108][108];
IL void dfs(int x,int y)
{
	if(vis[x][y])return;
	vis[x][y]=true;
	for(RI i=0;i<12;i++)
	{
		int nx=x+ax[i],ny=y+ay[i];
		if(nx<1 or ny<1 or nx>n or ny>m )continue;
		if(res[nx][ny]=='#'and !vis[nx][ny])dfs(nx,ny);
	}
}
int main()
{
	in(n),in(m);
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
			std::cin>>res[i][j];
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
		{
			if(res[i][j]=='#' and !vis[i][j])
			{
				dfs(i,j);
				ans++;
			}
		}
	printf("%d",ans);
}
```

---

## 作者：仗剑_天涯 (赞：3)


这道题，蒟蒻使用了bfs

拿到bfs题，有三个问题：

1.是什么类型的bfs？

2.它是怎么走的？

3.有没有特殊要求？

开始解题！

1.是什么类型的bfs？

bfs无非就是迷宫问题、最大区域、区域数这三种类型（当然有的会变形）

这道题呢，是一个求区域数的问题。

证据：小精灵们一边欣赏着极光，一边数着每一幅极光图像中的图案数。

第一个问题解决了。

2.它是怎么走的？

这道题有12个方向可以走！因为题目要的是曼哈顿距离。

怎么求曼哈顿距离？

题目给了答案：

对于两个发光的点，如果他们的曼哈顿距离（对于A(x1,y1)和B(x2,y2)，A和B之间的曼哈顿距离为|x1-x2|+|y1-y2|）小于等于2。那么这两个点就属于一个图案。

解题的最好方式就是画图。

于是乎，蒟蒻就画了个图，解决了第二个问题。

图：

![](https://cdn.luogu.com.cn/upload/image_hosting/i75uz3k4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

圆圈所表示的是合法的曼哈顿距离。（很显然，（0,0）是无意义的）

蒟蒻由第二个问题写出的宏定义：
```cpp
const int dy[]={2,1,1,1,0,0,0,0,-1,-1,-1,-2};
const int dx[]={0,-1,0,1,-2,-1,1,2,-1,0,1,0};
```

3.有没有特殊要求？

出题人很良心，没有特殊要求。

至此，分析完毕。


我功夫不到家，b、c从0开始非TLE即WA，只好从1开始了
代码：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring> 
#include<algorithm>//听说万能头文件比赛不能用，吓得我不敢用了
using namespace std;
const int dy[]={2,1,1,1,0,0,0,0,-1,-1,-1,-2};
const int dx[]={0,-1,0,1,-2,-1,1,2,-1,0,1,0};
int n,m,ans;
char ch;
string st;
int c[10010][5],b[110][110];
void bfs(int x,int y)
{
    int h,t,cx,cy;
    h=0;t=1;b[x][y]=1;
    c[1][1]=x;
    c[1][2]=y;
    c[1][3]=0;//记着步数，小心驶得万年船
    while(h<t)
    {
        h++;
        for(int i=0;i<12;i++)
        {
            cx=c[h][1]+dx[i];
            cy=c[h][2]+dy[i];
            if(cx<1||cx>n||cy<1||cy>m||b[cx][cy]) continue;
            t++;
            c[t][1]=cx;
            c[t][2]=cy;
            c[t][3]=c[h][3]+1;//入队
            b[cx][cy]=1;//注意随手锁住走过的点
            //求有几个区域，没有结束条件，填充满整个能走的
        }
    }
}
int main()
{
    cin>>n>>m;
    getline(cin,st); 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>ch;  
            if(ch=='-') b[i][j]=1;
        }   
        getline(cin,st);//getline当读入换行用
    }   
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(!b[i][j])
            {
                bfs(i,j);
                ans++;//记录一个区域
            }    
        }   
    }
    cout<<ans;
    return 0;
} 
```


---

## 作者：RagnaLP (赞：3)

主要是用BFS：


正如其他题解所说的，一共要向12个方向拓展


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
char map[110][110];         //输入的地图
bool visited[110][110];     //是否走过
int change[2][12]= {{0,-1,0,1,-2,-1,1,2,-1,0,1,0},{-2,-1,-1,-1,0,0,0,0,1,1,1,2}};      //用二维数组表示变化的行、列值(要特别注意还要搜索第二圈
int cc=0;   //统计总数
int m,n;
struct point {
    int r,c;
};
queue<point> q;
void BFS(int r,int c) {
    int i,newr,newc;
    point p;
    point cookie;  //避免一不小心改了原值
    p.r=r;
    p.c=c;
    q.push(p);
    visited[r][c]=1;
    while(!q.empty()) {
        p=q.front();
        q.pop();
        for(i=0; i<12; i++) {  //使用for分别探讨12种情况
            newr=p.r+change[0][i];
            newc=p.c+change[1][i];
            if(newc<m&&newc>=0&&newr<n&&newr>=0&&visited[newr][newc]==0&&map[newr][newc]=='#') {    //注意边界
                cookie.r=newr;
                cookie.c=newc;
                q.push(cookie);
                visited[newr][newc]=1;
            }
        }    
    }
    cc++;
}      //每一次只能找出一个图形
int main() {
    //freopen("data.in","r",stdin);
    //freopen("data.out","w",stdout);
    memset(map,'-',sizeof(map));
    memset(visited,0,sizeof(visited));     //一定要初始化
    int i,j;
    cin>>n>>m;
    for(i=0; i<n; i++) {
        for(j=0; j<m; j++)
            cin>>map[i][j];
    }    //输入地图
    for(i=0; i<n; i++) {
        for(j=0; j<m; j++)
            if(visited[i][j]==0&&map[i][j]=='#')   //找出没有走过的点，而且必须是灯（也就是‘#’），再去寻找图案
                BFS(i,j);
    }
    cout<<cc;//输出总数
    return 0;
}
```

---

## 作者：agicy (赞：2)

# 思路

要根据题意求出连通块的个数。显然尽管题目提示使用$DFS$深度优先搜索，但我们还是要使用$BFS$广度优先搜索。

同时，为了写代码方便，我们可以预先写出符合题意的$12$个方向。

>对于$A(x_1,y_1)$和$B(x_2,y_2)$两点，若$|x1-x2|+|y1-y2|≤2$，则$A,B$属于同一图案。

根据题意可得，其中每个方向的横、纵坐标增量的绝对值相加之和都不得超过$2$。

所以我们得出了下面这些代码。

```cpp
int fx[12]={-2,2,-1,1,0,0,0,0,1,1,-1,-1},//注意这里是逗号
fy[12]={0,0,0,0,-1,1,-2,2,1,-1,-1,1};
```

那么我们遍历各个方向时只要使用下面这段代码即可。

```cpp
register int i;
for(i=0;i<12;i++){
	dx=x+fx[i],dy=y+fy[i];
	if(dx<1||n<dx||dy<1||m<dy)
		continue;
	if((map[dx][dy]^'-')&&!f[dx][dy])
		f[dx][dy]=true,
		Qx.push(dx),Qy.push(dy);
}
```

# 代码

代码如下。

```cpp
#include<stdio.h>
#include<iostream>
using std::cin;//使用cin读入字符自动忽略空格和换行符
#include<queue>
using std::queue;//队列

bool f[101][101];//标记访问数组
char map[101][101];
int n,m,
fx[12]={-2,2,-1,1,0,0,0,0,1,1,-1,-1},
fy[12]={0,0,0,0,-1,1,-2,2,1,-1,-1,1};//12个方向
queue<int> Qx,Qy;//两个队列，分别为点的横、纵坐标

void BFS(void);//宽度优先搜索

int main(void){
	register int i,j,ans=0;//寄存器更快些
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			cin>>map[i][j];//读入
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			if((map[i][j]^'-')&&!f[i][j]){//没有访问过的图案
				ans++;//累计答案
				Qx.push(i),Qy.push(j);
				BFS();//查找连通块
			}
	printf("%d",ans);/输出
	return 0;//结束
}

void BFS(void){
	register int i,x,y,dx,dy;//寄存器更快些
	while(!Qx.empty()){
		x=Qx.front(),y=Qy.front();
		Qx.pop(),Qy.pop();
		for(i=0;i<12;i++){
			dx=x+fx[i],dy=y+fy[i];
			if(dx<1||n<dx||dy<1||m<dy)
				continue;
			if((map[dx][dy]^'-')&&!f[dx][dy])
				f[dx][dy]=true,
				Qx.push(dx),Qy.push(dy);
		}
	}
	return;
}
```

## [我的测评记录](https://www.luogu.org/record/show?rid=9524029)

---

## 作者：DaftLord (赞：1)

Pascal dfs；

其实这道题还是比较简单的，用dfs，把每个“#”四周的“#”都变成“-”，也就是每一次次search都搜完整个连在一起的图案。

**需要注意的是，两个点的曼哈顿距离≤2就算连在一起，所以除了一周八个方向外，还需要搜索更外一圈的四个点（ (x-2,y) , (x+2,y) , (x,y-2) ,(x,y+2) )**




```cpp
var a:array[0..100,0..100] of char;//用数组存地图；
    n,m,i,j,ans:longint;
procedure search(x,y:longint);//搜索过程；
var k,t:longint;
begin
 if (x>n) or (y>m) or (x<1) or (y<1) then exit;//如果越界，马上退出；
 if a[x,y]='-' then exit else a[x,y]:='-'; //如果是“-”就退出，不是就把该点变成“-”；
  for k:=-1 to 1 do //向四周八个方向搜索；
   for t:=-1 to 1 do
    search(x+k,y+t);  
   search(x+2,y);//向外层4个方向搜索；
   search(x-2,y);
   search(x,y-2);
   search(x,y+2);
end;
begin
 readln(n,m);//输入；
  for i:=1 to n do
  begin
   for j:=1 to m do read(a[i,j]);
   readln;
  end;
  ans:=0;
   for i:=1 to n do//循环整个地图，
    for j:=1 to m do
    if a[i,j]='#' then //如果发现是“#”的点，
    begin
     search(i,j); //搜索；
     inc(ans); //答案+1；
    end;
  writeln(ans);//输出；
end.
```

---

## 作者：skytstao (赞：1)

用bfs
按条件|x1-x2|+|y1-y2|）小于等于2。那么这两个点就属于一个图案
所以对

(-1,0,1,0,1,1,-1,-1,2,0,-2,0);

(0,1,0,-1,1,-1,1,-1,0,2,0,-2);

这十二个方向搜索每一个点，所过的点标记为0，即可

```delphi

const dx:array[1..12] of -2..2=(-1,0,1,0,1,1,-1,-1,2,0,-2,0);
          dy:array[1..12] of -2..2=(0,1,0,-1,1,-1,1,-1,0,2,0,-2);
var
    s:string;
    pic:array[1..1000,1..1000] of 0..1;    
    m,n,i,j,num:integer;
    h:array[1..10000,1..2] of longint;    
procedure doing(p,q:integer);      
  var i,f,r,x,y:integer;
  begin
      inc(num);{方案数加一}                    
      pic[p,q]:=0;
      f:=1;                              
      r:=1;                             
      h[f,1]:=p;   h[f,2]:=q;   
      repeat
          for i:=1 to 12 do{扩展}         
              begin  
                  x:=h[f,1]+dx[i];    y:=h[f,2]+dy[i];
                  if (x>0) and (x<=m) and (y>0) and (y<=n) and (pic[x,y]=1)
                     then
                         begin
                             inc(r);  h[r,1]:=x;   h[r,2]:=y;   pic[x,y]:=0;{入队}
                         end;  
              end;
          inc(f);                       
      until f>r;                   
  end;
Begin
  fillchar(pic,sizeof(pic),0);   
  num:=0;
  fillchar(h,sizeof(h),0);
  readln(m,n);
  for i:=1 to m do
      begin
          readln(s);
          for j:=1 to n do
              if s[j]='-' then pic[i,j]:=0   
                            else pic[i,j]:=1;{读入}
      end;
  for i:=1 to m do
      for j:=1 to n do 
          if pic[i,j]=1 then doing(i,j){搜索};    
  writeln(num);
End.

```

---

## 作者：迷残云 (赞：1)

先介绍一下bfs:

广度优先搜索,即BFS(Breadth First Search),是一种常用的搜索。

在所有搜索方法中，也有一种广泛运用的搜索方法,就是深度优先搜索(DFS),与BFS一样常用。

下面,我来总结一下它们的优劣:

DFS:容易编写,只需要照着题目的意思模拟即可,但是有时需要遍历的解答树节点太多,时间复杂度较高,需要剪枝,况且有时剪枝后仍然会TLE。

BFS:思维复杂度较高,较难编写,但是整体时间复杂度较低,基本上不用剪枝。


BFS也是一种搜索,所以也需要寻找答案,不过,BFS每次找到的,都是到当前情况的最佳答案,而DFS需要查找所有的情况,这就是BFS比DFS快的原因。

BFS查找答案,需要用到的数据结构正是队列。

为什么?


设搜索初始状况为first,先将first入队:

然后再求出first衍生的最优情况x1,x2,x3,xn,全部入队,first出队。
这样不断循环,当入队元素满足目标条件时,结束循环。

如果永远不满足目标条件呢?

不满足的话,它到最后队列会为空(及所有情况都被枚举了),就可以判断了。

练一道题:P1135 奇怪的电梯


奇怪的电梯解法：[奇怪的电梯](https://www.luogu.org/record/show?rid=14798548)(字体)

//bfs解法
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[12]={0,0,1,-1,1,1,-1,-1,2,-2,0,0},//增量值：移动数组
    dy[12]={1,-1,0,0,1,-1,1,-1,0,0,2,-2};
bool g[110][110];
int n,m,ans;
int q[10010][2];
void bfs(int x,int y)
{
    int h=0,t=1;//头尾赋值
    q[1][0]=x;q[1][1]=y;
    g[x][y]=0;
    while(h<t)
    {
        h++;
        x=q[h][0],y=q[h][1];
        for(int i=0;i<12;i++)
        {
            int x1=x+dx[i],y1=y+dy[i];
            if(x1>=1&&x1<=n&&y1>=1&&y1<=m&&g[x1][y1])//正向思路
            {
                t++;
                q[t][0]=x1;
                q[t][1]=y1;
                g[x1][y1]=0;
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      {
      	char c;
      	cin>>c;
      	if(c=='#')g[i][j]=1;//判断
      }
      for(int i=1;i<=n;i++)
       for(int j=1;j<=m;j++)
       if(g[i][j])
       {
       	++ans;//其实就是搜索联联  通块
       	bfs(i,j);
       }
       cout<<ans;
    return 0;
}
```

---

## 作者：tcswuzb (赞：0)

### 本题题意：

给你一个（n*m）的字符矩阵 

两‘#’之间的曼哈顿距离<=2 这属于一个集合

问这个字符矩阵 有多少个集合

### 题目分析：

判断属于一个集合 就可以用并查集来维护

但是并查集目前好像只适用于一维

怎么办 二维转一维

```cpp
IL int youngsc(int x,int y) {return x*110+y;}
```

这种转移可以防止冲突

然后对于每一个点 

枚举在其合法曼哈顿距离范围之内的点 合法则并入一个集合

最终枚举集合 用多少个不同的祖先就是最终answer

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
char Node[110][110];
int fa[N],key[10010];
bool vis[N];
int n,m,cnt;
IL int youngsc(int x,int y) {return x*110+y;}
IL int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} 
int tox[20]={1,-1,0,0,1,-1,1,-1,2,-2,0,0},
toy[20]={0,0,1,-1,1,1,-1,-1,0,0,2,-2};
IL void bfs(){
	for(R int i=1;i<=n;++i)
	 for(R int j=0;j<m;++j)
	  fa[youngsc(i,j)]=youngsc(i,j);
	for(R int i=1;i<=n;++i)
	 for(R int j=0;j<m;++j)
	 {
	 	if(Node[i][j]=='#')
	 	{
	 		for(R int k=0;k<12;++k)
	        {//是发光点的话 枚举四周
	          int tx=i+tox[k],ty=j+toy[k];
	          if(tx>n || tx<1 || ty>m-1 || ty<0) continue;//要求边界合法
	  	      if(Node[tx][ty]=='#')
	  	      {
	  	      	int fx=find(youngsc(i,j)),fy=find(youngsc(tx,ty));
	  	      	if(fx!=fy) fa[fx]=fy;
                //可以属于一个图案
			  }
	        }
		}
	 }

}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);read(m);
    for(R int i=1;i<=n;++i) scanf("%s",Node[i]);
	for(R int i=1;i<=n;++i)
	{
	 for(R int j=0;j<m;++j)
	 {
	 	if(Node[i][j]=='#') 
        //将发光的点的转一维之后再存入一个数组
	 	 key[++cnt]=youngsc(i,j);
	 }
	}   
	bfs();
    int ans=0; 
	for(R int i=1;i<=cnt;++i)
	{
		int tmp=find(key[i]); 
		if(!vis[tmp]) //用标记数组判断集合
		{
			vis[tmp]=1;ans++;
		}
	}   
	printf("%d\n",ans);
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

 ## _NOIP 2018 RP++_ 

---

## 作者：Yuno (赞：0)

# 求联通块问题的变形
### 首先，题目说两个点的**曼哈顿距离小于等于2即为一个图形**。
#### 传统的求联通块只有**四个方向**,分别是(x+1,y)(x-1,y)(x,y+1)(x,y-1)，这是曼哈顿距离为1的四个方向，而这题有**十二个方向**，多出来的八个是曼哈顿距离为2的，分别是(x+1,y+1)(x+1,y-1)(x-1,y+1)(x-1,y-1)(x+2,y)(x-2,y)(x,y+2)(x,y-2)。
 接着，只要用这**十二个**方向**求联通块**的**数量**即可，
 既可以用**DFS**，也可以用**BFS**，
我用的是**BFS**，并不是因为**BFS**的速度比**DFS**快多少，而是因为用**BFS**看上去比较~~高端~~
```
#include<iostream>
using namespace std;
int a[101][101];
int n,m,ans;
int dx[12]={1,0,-1,0,1,1,-1,-1,2,0,-2,0};
int dy[12]={0,1,0,-1,1,-1,1,-1,0,2,0,-2};
//十二个方向 
int q[100001][3];
//BFS使用的队列，q[][1]=横坐标，q[][2]=纵坐标 
void bfs(int i,int j)
{
	ans++;//图案的数量加一 
	a[i][j]=0;//记录这一格被BFS过了 
	int head=0,tail=1;
	q[1][1]=i;q[1][2]=j;
	//记录坐标 
	while (head<tail)//如果队列内还有元素 
	{
		head++;//队首元素出队 
		for (int w=0;w<12;w++)//往12个方向拓展 
		{
			int x=q[head][1]+dx[w];
			int y=q[head][2]+dy[w];
			//记录下一步的坐标 
			if (x>0&&y>0&&x<=n&&y<=m&&a[x][y])
			//如果这一格不越界且这一格能走 
			{
				tail++;//尾指针++ 
				q[tail][1]=x;
				q[tail][2]=y;
				//入队 
				a[x][y]=0;
				//记录这一格走过了 
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
	{
		char ch;
		cin>>ch;
		if (ch=='#') a[i][j]=1;
		//记录这一格的状态 
	}
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
    if (a[i][j]) bfs(i,j);
	//如果这一格在发光，BFS这一格 
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：孙广宸 (赞：0)

##### 这是一道非常经典的dfs连通块问题，废话少说，直接上代码qwq#### 



 ```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
char a[1001][1001];
int n,m;
int dx[12]={-2,2,-1,1,0,0,0,0,1,1,-1,-1},
	dy[12]={0,0,0,0,-1,1,-2,2,1,-1,-1,1};//12方向
int ans=0;
void dfs(int x,int y)
{
	int tx,ty;
	a[x][y]='-';
    /*
    个人习惯：每找到一个可以延伸的‘#’，就采用一种染色的思想，把他置成‘-’，可以节省一个判断是否走过的数组，看起来更方便（过河拆桥的感觉qwq）
    */
	for(int i=0;i<12;i++)
	{
		tx=x+dx[i];
		ty=y+dy[i];
		if(a[tx][ty]=='#')
			dfs(tx,ty);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]=='#')
			{
				dfs(i,j);
				ans++;//找到一个就加一
			}
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：A_Cute_757 (赞：0)

```cpp
#include<iostream>
using namespace std;
int n,m,ans=0,x1,y1;//int
char a[101][101];//char
int fx[12]={-1,-2,-1,0,0,1,1,2,1,0,0,-1};//定义12个方向数组
int fy[12]={0,0,1,1,2,1,0,0,-1,-1,-2,-1};//定义12个方向数组
void dfs(int x,int y)//洪水填充法
{
    for(int i=0;i<12;i++)//向12个方向都扫一遍
    {
        x1=x+fx[i];//将坐标更新
        y1=y+fy[i];//将坐标更新
        if(x1>=1&&x1<=n&&y1>=1&&y1<=m&&a[x1][y1]=='#')//判断能否发洪水
        {
            a[x1][y1]='-';
            dfs(x1,y1);//发洪水
        }
    }
}
int main()
{
    cin>>n>>m;//按照题意输入n行，m列。
    for(int i=1;i<=n;i++)//双重for
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];//输入点阵
        }
    }
    ans=0;//养成置零的好习惯
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]=='#')
            {
                ans++;
                dfs(i,j);
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：张皓涵 (赞：0)

这个题跟P1451的细胞那题很像，只需要找到一个灯，然后把整个图案清除就好了。	
    
    #include<iostream>
	using namespace std;
	int n,m;
	int ans;
	char a[10001][10001];
	void dfs(int x,int y)
	{
	    if(x>n||x<1||y>m||y<1||a[x][y]=='-') return;  //判断不越界且亮着
	    a[x][y]='-';  //把整个图案弄掉
 	   dfs(x+2,y);
 	   dfs(x-2,y);
 	   dfs(x,y+2);
 	   dfs(x,y-2);
 	   dfs(x+1,y-1);
	    dfs(x-1,y+1);
 	   dfs(x+1,y+1);
	    dfs(x-1,y-1);
	    dfs(x+1,y);
	    dfs(x-1,y);
	    dfs(x,y+1);
	    dfs(x,y-1); //枚举法小心不要漏掉哦
	}
	int main()
	{
	    cin>>n>>m;
 	   for(int i=1;i<=n;i++)
 	       for(int j=1;j<=m;j++) 
	            cin>>a[i][j]; //读入
  	  for(int i=1;i<=n;i++)
  	      for(int j=1;j<=m;j++)
 	           if(a[i][j]=='#') {ans++; dfs(i,j);} //找到亮点,+1清除
	    cout<<ans; 
	    return 0;
	}
    
为了各位看官名字颜色正常,请不要抄袭哦!

---

## 作者：huyufeifei (赞：0)

我看所有的题解都搜的是12个点，那么我来一个搜4个点的题解吧。

DFS的时候传一个```rest```，表示还能走多少步。如果当前是```#```就传```2```，否则就传```rest - 1```，```rest = 0```时返回。

```c++
#include <cstdio>

const int N = 110;

bool G[N][N], vis[N][N];

const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};

void DFS(int x, int y, int rest) {
    if(!G[x][y]) {
        if(rest == 99) {
            return;
        }
        if(rest) {
            for(int i = 0; i <= 3; i++) {
                if(!vis[x + dx[i]][y + dy[i]]) {
                    DFS(x + dx[i], y + dy[i], rest - 1);
                }
            }
        }
        return;
    }
    if(!rest) {
        return;
    }
    vis[x][y] = 1;
    for(int i = 0; i <= 3; i++) {
        if(!vis[x + dx[i]][y + dy[i]]) {
            DFS(x + dx[i], y + dy[i], 2);
        }
    }
    return;
}

int main() {
    int m, n;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            char c = getchar();
            while(c != '-' && c != '#') {
                c = getchar();
            }
            G[i][j] = (c == '#');
        }
    }
    int cnt = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            if(!vis[i][j]) {
                cnt += G[i][j];
                DFS(i, j, 99);
            }
        }
    }
    printf("%d", cnt);
    return 0;
}

```

---

## 作者：ResidualNight (赞：0)

洪水填充法（flood fill）：
```
/
类型 dfs（x，y）
{
	for（i=1 ～ 方向数）
    	if（没走到）
        {
        	标记已走
            dfs（xx，yy）
        }
}
/
```
```cpp
#include<iostream>
using name space std; //emmm
int n,m,ans=0,x1,y1; //n，m是行和列，ans为答案，x1 y1是dfs更新的坐标
char a[101][101]; //储存输入数据
int fx[12]={-1,-2,-1,0,0,1,1,2,2,1,0,0,-1}; //方向数组
int fy[12]={0,0,1,1,2,1,0,0,-1,-1,-2,-1}; //同上
void flood_fill(int x,int y)
{
	for(int i=0; i<12; i++) //12个方向
	{
		x1=x+fx[i]; y1=y+fy[i]; //更新坐标
		if(x1>=1 && x1<=n && y1>=1 && y1<=m && y1<=m && a[x1][y1]=='#')
			{a[x1][y1]=‘-’; dfx(x1,y1);} //发洪水～
	}
}
int main()
{
	cin>>n>>m; //读入
	for(int i=1; i<=m; i++)
		for(int k=1; k<=m; k++)
			cin>>a[i][k]; //同上
	ans=0; //ans清零
	for(int i=1; i<=n; i++)
		for(int k=1; k<=m; k++)
			if(a[i][k]=='#') {ans++; dfs(i,k);}
	cout<<ans<<endl; //愉快的输出
	return 0; //the end
}
```

---

## 作者：zzlh (赞：0)

一道挺简单的深搜题，根据题意|x1-x2|+|y1-y2|得出往12个方向扩展，记得每次走到一个点后标记已走过就行，扩展如下图：
\*
***
*****
***
\*
贴代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
bool a[205][205];
int x[13]={0,0,1,-1,1,-1,-1,1,0,0,2,-2};
int y[13]={1,-1,0,0,1,-1,1,-1,2,-2,0,0};//12个方向扩展
void dfs(int x1,int y1){
    a[x1][y1]=0;
    for(int i=0;i<=11;i++){
        if(a[x1+x[i]][y1+y[i]]){
            dfs(x1+x[i],y1+y[i]);//搜索
        }
    }
    return;
}
int main(){
    int ans=0;
    cin>>n>>m;
    for(int i=2;i<=n+1;i++){
        for(int j=2;j<=m+1;j++){//从2开始存储，防止数组越界
            char ch;
            cin>>ch;
            if(ch=='-')a[i][j]=0;
            if(ch=='#')a[i][j]=1;
        }
    }
    for(int i=2;i<=n+1;i++){
        for(int j=2;j<=m+1;j++){
            if(a[i][j]==1){
                dfs(i,j);
                ans++;//答案+1
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```cpp

---

## 作者：jacky_chen (赞：0)

//那位仁兄写的已经不错了，此处有一个优化在此：


```cpp
#include<iostream>  
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
char c;
int map[100][100],n,m,s=0,i,j;
void jiancha(int x,int y)
{
    if(x<0||x>n-1||y<0||y>m-1||map[x][y]==0)return;
    map[x][y]=0;
    for(int i=x-2;i<=x+2;i++)
    for(int j=y-2;j<=y+2;j++)
    {
        if(i==x&&j==y) continue;
        if(abs(i-x)+abs(j-y)<=2)
        jiancha(i,j);//不必枚举出12种可能，可知，曼哈顿距离最大在方圆2格之内，只要搜索出正确解就行，（不要太虐待自己）
    }
    }
    int main()
    {
        cin>>n>>m;
        for(i=0;i<n;i++)for(j=0;j<m;j++)
        {
            cin>>c;if(c=='#'){map[i][j]=1;}else{map[i][j]=0;}
        }
        for(i=0;i<n;i++)
         for(j=0;j<m;j++)
         {
            if(map[i][j]){jiancha(i,j);s++;}
        }
        cout<<s;
        return 0;
}
```

---

## 作者：封禁用户 (赞：0)

#广搜,往十二个方向搜索

```cpp
#include<iostream>
using namespace std;
int m,n;
int sum=0;
bool board[105][105]={0};
void finds(int i,int j)
{
    board[i][j]=0;//不搜索重复的
    //搜索十二个方向
    if(i-1>=1&&board[i-1][j])/*判断是否过界,是否搜索过*/ finds(i-1,j);
    if(i+1<=m&&board[i+1][j]) finds(i+1,j);
    if(j-1>=1&&board[i][j-1]) finds(i,j-1);
    if(j+1<=n&&board[i][j+1]) finds(i,j+1);
    if(i-2>=1&&board[i-2][j]) finds(i-2,j);
    if(i+2<=m&&board[i+2][j]) finds(i+2,j);
    if(j-2>=1&&board[i][j-2]) finds(i,j-2);
    if(j+2<=n&&board[i][j+2]) finds(i,j+2);
    if(i-1>=1&&j-1>=1&&board[i-1][j-1]) finds(i-1,j-1);
    if(i+1<=m&&j-1>=1&&board[i+1][j-1]) finds(i+1,j-1);
    if(i-1>=1&&j+1<=n&&board[i-1][j+1]) finds(i-1,j+1);
    if(i+1<=m&&j+1<=n&&board[i+1][j+1]) finds(i+1,j+1);
}
int main()
{
    cin>>m>>n;
      for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
          {                　　
              char a;
              cin>>a;
                if(a=='#') board[i][j]=1;//用布尔数组代替字符数组
                else board[i][j]=0;
          }
    for(int i=1;i<=m;i++)
       for(int j=1;j<=n;j++)
         if(board[i][j])
           {
               finds(i,j);
               sum++;//总数
           }
    cout<<sum;
    return 0;
}
```

---

## 作者：doby (赞：0)

怎么只剩了一个题解，还是Pascal的……

dfs直接出解……

```cpp
#include<iostream>
using namespace std;
char c;
int a[100][100],n,m,ans=0,i,j;
void ss(int x,int y)
{
    if(x<0||x>n-1||y<0||y>m-1||a[x][y]==0)return;//出界返回
    a[x][y]=0;//封路
    ss(x-1,y);ss(x,y+1);ss(x+1,y);ss(x,y-1);//十二个方向搜索
    ss(x+1,y+1);ss(x+1,y-1);ss(x-1,y+1);ss(x-1,y-1);
    ss(x+2,y);ss(x,y+2);ss(x-2,y);ss(x,y-2);
}  
int main()  
{
    ios::sync_with_stdio("false");//无用的流优化……
    cin>>n>>m;
    for(i=0;i<n;i++){for(j=0;j<m;j++){cin>>c;if(c=='#'){a[i][j]=1;}else{a[i][j]=0;}}}
    for(i=0;i<n;i++){for(j=0;j<m;j++){if(a[i][j]){ss(i,j);ans++;}}}//如果有极光，就深搜
    cout<<ans;
    return 0;
}
```

---

## 作者：江山_远方 (赞：0)

这是一道经典的bfs好（shui）题（ti）

思路：枚举每个点，若该点未被遍历过，及遍历该点

提示：本题有一个坑点！方向为十二个！

为什么是十二个呢？

题目中有这样一句话：

对于两个发光的点，如果他们的曼哈顿距离（对于A(x1,y1)和B(x2,y2)，A和B之间的曼哈顿距离为|x1-x2|+|y1-y2|）小于等于2。那么这两个点就属于一个图案…… 

经过本人的浓缩后：

如果A和B|x1-x2|+|y1-y2|）小于等于2，那么这两个点就属于一个图案…… 

什么意思呢？

就是指这两个点的行列之差加起来不超过2，即<=2

经过分析后，推出了当a点为（0,0）点时b点的十二种可能

(-1,0)

(0,-1)

(1,0)

(0,1)

(-1,-1)

(-1,1)

(1,1)

(1,-1)

(-2,0)

(0,2)

(2,0)

(0,-2)

这即为十二方向

剩下的就是一个标准的多迷宫宽搜了

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={0,-1,0,1,0,-1,-1,1,1,-2,0,2,0};
const int dy[]={0,0,1,0,-1,-1,1,1,-1,0,2,0,-2};//方向前加零是因为下面方向是1~12,而const定义是从0开始 
int n,m;
int ans;
int b[200][200],c[40000][5];
char ch;
string st;
void bfs(int x,int y)
{
	ans++;
	int h=0,t=1,cx,cy;
	b[x][y]=1;
	c[1][1]=x;
	c[1][2]=y;
	while(h<t)
	{
		h++;
		for(int i=1;i<=12;i++)
		{
			cx=c[h][1]+dx[i];
			cy=c[h][2]+dy[i];//生成新点 
			if(cx<1||cy<1||cx>n||cy>m||b[cx][cy])continue;//越界或遍历过则跳过 
			t++;
			c[t][1]=cx;
			c[t][2]=cy;
			b[cx][cy]=1;//加入队列 
		}
	}
}//bfs求连通图 
int main()
{
	cin>>n>>m;
	getline(cin,st);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			ch=getchar();
			if(ch=='-')b[i][j]=1;
		}
		getline(cin,st);
	}//输入预处理 
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)if(!b[i][j])bfs(i,j); 
	cout<<ans;
}
```


---

## 作者：Hola_chen (赞：0)

# 非喜勿喷
ps:洪水填充法

```cpp
//flood fill洪水填充法
dfs(x,y)
{
    for(int i=1~方向数）
    {
        if（没走过）
        {
            标走过
            dfs（xx，yy）
        }
    }
}
```


|  |  | 1 |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  | 2 | x | 2 |  |
| 1 |x  |@  |x  |1 |
|  |2  | x | 2 |  |
|  |  |1  |  |  | |

```
//dfs延伸
dfs(int k,int x,int y)
{
    if(目标)
    {
        处理;
        return ;
    }
    for(i=i=1~儿子数)
    {
        if(真儿子)
        {
            设置状态
            dfs(k+1,xx,yy)
            恢复状态
        }
    }
}
```

```cpp
#include<iostream>
using namespace std;
int n,m,ans=0,x1,y1;//int
char a[101][101];//char
int fx[12]={-1,-2,-1,0,0,1,1,2,1,0,0,-1};//int
int fy[12]={0,0,1,1,2,1,0,0,-1,-1,-2,-1};//int
void dfs(int x,int y)//void
{
	for(int i=0;i<12;i++)//for
	{
		x1=x+fx[i];
		y1=y+fy[i];
		if(x1>=1&&x1<=n&&y1>=1&&y1<=m&&a[x1][y1]=='#')//if
		{
			a[x1][y1]='-';
			dfs(x1,y1);//dfs
		}
	}
}
int main()
{
	cin>>n>>m;//cin
	for(int i=1;i<=n;i++)//for
	  for(int j=1;j<=m;j++)//for*2
	    cin>>a[i][j];//cin
	ans=0;
	for(int i=1;i<=n;i++)//for
	  for(int j=1;j<=m;j++)//for*2
	{
		if(a[i][j]=='#')//if
		{
			ans++;
			dfs(i,j);//dfs
		}
	}
	cout<<ans<<endl;//cout
    return 0;
}

```


---


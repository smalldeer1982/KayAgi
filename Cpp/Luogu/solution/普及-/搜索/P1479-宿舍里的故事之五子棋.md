# 宿舍里的故事之五子棋

## 题目描述

宿舍里好多好多有趣的事！

7890653 今天看到不知何时流行的五子棋，在宿舍里拿个本子，画一些格子，一个棋盘就做好了。

当 7890653 把目光放到棋上，突发奇想……

在一个 $5 \times 5$ 的棋盘内，放上 $n$ 颗棋子，其中 $5 \le n \le 25$；

这 $n$ 颗棋子可以放到棋盘内任意一个地方，但是不能重叠在一起。于是，便会有五颗棋子排成一行，或一列，或处在同一条对角线上。不同的放法可能会出现不同个数的五子的排列。

本题你要做的是，给你一个 $n$，你要找出不同放法出现的五子连线的数量（设为 $k$），如 $n=11$，有：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)

只有这两种非负的 $k$ 值，（注意 $k$ 不重复），你要输出的便是 $k$ 值的和。

也就是 $1+2=3$。

## 样例 #1

### 输入

```
11```

### 输出

```
3```

# 题解

## 作者：樱式分解 (赞：33)

### 我也不知道这叫什么解法，只知道棋子可以放或不放。
### 因为棋盘较小，可以直接查找多少五子。
## 于是代码如下
```
#include <iostream>
#include <cstring>
using namespace std;
bool f[15];//可连成数
int n;
bool a[6][6]={false};//所有位置都不放
int ans=0;
void c(){
	int q=0;
	for(int i=1;i<=5;i++){
        if(a[i][1]&&a[i][2]&&a[i][3]&&a[i][4]&&a[i][5])q++;
        if(a[1][i]&&a[2][i]&&a[3][i]&&a[4][i]&&a[5][i]q++; 
	}//横竖五子
    if(a[1][1]&&a[2][2]&&a[3][3]&&a[4][4]&&a[5][5])q++;
	if(a[1][5]&&a[2][4]&&a[3][3]&&a[4][2]&&a[5][1])q++;
    //两条斜边五子
	f[q]=true;可连成数标上对；
}
void dfs(int i,int j,int sum){
	if(i==6||sum==n+1){//如果棋子放完或无法继续就停止
	 if(sum==n+1)
	 	c();//如果棋子放满就开始计可连成数。
                return;
	 }
	 if(j==6)dfs(i+1,1,sum);
	 else{
	 a[i][j]=true;//放
	 dfs(i,j+1,sum+1);
	 a[i][j]=false;//不放
	 dfs(i,j+1,sum);
	 a[i][j]=false;//回溯
	 }
}
int main(){
	cin>>n;
	dfs(1,1,1);
    for(int i=1;i<=15;i++){
    	if(f[i])ans+=i;//加上可连成数
	}
	cout<<ans<<endl;输出
    return 0;//拜拜
}
```
## 用心写题解，希望给大家带来点帮助呀！

---

## 作者：Youngsc (赞：14)

[Youngsc](http://youngscc.github.io/)

赤裸裸的搜索.....

显然这道题是~~打表~~可过的

~~打表代码如下~~

```cpp
# include <iostream>
# include <cstdio>
# define R register

using namespace std;

int n;
const int a[27]={0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12};

template <typename T> void in(R T& a){
    R T x=0,f=1; R char c = getchar();
    while(!isdigit(c)){if(c == '-') f=-1; c = getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

int main(){
    in(n);
    printf("%d",a[n]);
    return 0;
}
```
但这么好的题打表就可惜了

我们可以枚举将棋放在棋盘上的所有状态，再加一个可行性剪枝就能过去

## 代码在这里

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long

using namespace std;

int n,f[6][6],ans;
bool v[13];

template <typename T> void in(R T& a){
    R T x=0,f=1; R char c = getchar();
    while(!isdigit(c)){if(c == '-') f=-1; c = getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void check(){
    R int num = 0;
    for(R int i=1; i<=5; ++i)
    {
        if(!f[i][i]) break;
        if(i == 5) num++;
    }
    for(R int i=1; i<=5; ++i)
    {
        if(!f[i][6-i]) break;
        if(i == 5) num++;
    }
    for(R int i=1; i<=5; ++i)
    {
        for(R int j=1; j<=5; ++j)
        {
            if(!f[i][j]) break;
            if(j == 5) num++;
        }
        for(R int j=1; j<=5; ++j)
        {
            if(!f[j][i]) break;
            if(j == 5) num++;
        }
    }
    // printf("%d ",num);
    v[num] = 1;
}

inline void dfs(R int pos,R int num){
    if(!num){
        check();
        return;
    }
    if(25-pos+1 < num) return;//可行性剪枝，如果剩下的格子不够剩下的棋子就返回
    for(R int i=pos; i<=25; ++i)//将5*5的棋盘转化为25个格子的线
    {
        R int x = (i-1)/5+1;//求坐标
        R int y = (i-1)%5+1;
        f[x][y] = 1;
        dfs(i+1,num-1);
        f[x][y] = 0;
    }
}

int yg(){
    in(n);
    dfs(1,n);
    for(R int i=1; i<=12; ++i) if(v[i]) ans += i;
    printf("%d",ans);
    return 0;
}

int youngsc = yg();
int main(){;}

```

---

## 作者：巫妖王 (赞：11)

#### 这赤裸裸的搜索.....
下面是搜索的代码

------------

```pascal
var
  n,sum:longint;
  f:array [0..12] of boolean;
  a:array [0..6,0..6] of longint;
function pd:longint;
var
  i,j:longint;
begin
  pd:=0;
  for i:=1 to 5 do
    begin
      j:=1;
      while a[i,j]=1 do
        j:=j+1;
      if j=6 then
        pd:=pd+1;
      j:=1;
      while a[j,i]=1 do
        j:=j+1;
      if j=6 then
        pd:=pd+1;
    end;
  i:=1;
  while a[i,i]=1 do
    i:=i+1;
  if i=6 then
    pd:=pd+1;
  i:=1;
  while a[i,6-i]=1 do
    i:=i+1;
  if i=6 then
    pd:=pd+1;
end;
procedure dfs(k,i1:longint);
var
  x,i:longint;
begin
  if k=n+1 then
    begin
      if not f[pd] then
        begin
          x:=pd;
          f[x]:=true;
          sum:=sum+x;
        end;//记录状态；
      exit;
    end;
  for i:=i1+1 to 25-n+k do
    begin
      a[(i+4) div 5,(i-1) mod 5+1]:=1;
      dfs(k+1,i);
      a[(i+4) div 5,(i-1) mod 5+1]:=0;//简单搜索；
    end;
end;
begin
  readln(n);
  dfs(1,0);
  writeln(sum);//输出
end.
```


------------
#### ~~不过这题好像大多数人都是打表的~~
##### 代码如下
```pascal
const a:array[5..25] of longint=(1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12)；//一到四都是零
var n:longint;
begin
 read(n);
 write(a[n]);
end.
```

------------
#### ~~良心题解（逃）~~

---

## 作者：封禁用户 (赞：2)

显而易见的打表题
=

因为$n≤25$，所以直接手算就好惹。

```cpp
int a[26]={0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12}
```

不瞒你说，蒟蒻貌似发现了不像规律的规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/txlhzer1.png)

如图$1$，棋盘上要构成一行、一列或一条对角线，必须要有$5$颗棋子。

所以$n≤4$时，$k=0$。

如图$2$，在已有的基础上，如果要有两条线，则至少需要$9$个棋子。

所以$n≥5$时，$k=0+1=1$。

如图$3$，在已有的基础上，如果要再多一条线，则至少需要$12$颗棋子。

所以，$n≥9$时，$k=0+1+2=3$。

如图$4$，在已有的基础上，如果要再多一条线，则至少需要$15$颗棋子。

所以，$n≥12$时，$k=0+1+2+3=6$。

以此类推……

但是这个规律不能用于所有的数据。

比如答案为$35$时，$35!=28+8$，这一点要注意哦~

最后上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[26]= {0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12},n;
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}//快读
int main() {
	n=read();
	printf("%d\n",a[n]);
	return 0;
}
```


---


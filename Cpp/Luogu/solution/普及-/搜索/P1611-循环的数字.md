# 循环的数字

## 题目描述

你曾经因为看见一样的东西一遍又一遍地重复、循环而对电视节目感到厌烦么？好吧，虽然我并不关心电视节目的好坏，不过有时却也很像那样不断循环的数字。

让我们假定两个不同的正整数 $(n, m)$ 是循环的，当且仅当你能通过将 $n$ 末端的几个数字移到它的首端而不改变移动的数字的顺序并使整个数字变成 $m$ 。举个例子，$(12345, 34512)$ 就是一对循环的数字，因为你能把 $12345$ 中末尾的 $345$ 移到 $12$ 前面，从而得到 $34512$。注意，为了成为一对循环的数字，$n$ 和 $m$ 位数必须相同。无论 $n$ 或 $m$ 都没有前置的 $0$。

现在给定正整数 $A$ 和 $B$，并保证 $A$ 和 $B$ 位数相同且均没有前置 $0$，求存在多少循环的正整数对 $(n, m)$，使得 $A \leq n \le m \leq B$ ？

## 说明/提示

$1\le A,B \leq 2\times 10^6$。

## 样例 #1

### 输入

```
1111 2222```

### 输出

```
287```

# 题解

## 作者：Jiyuu_no_Tsubasa (赞：29)

本题是一道经典的枚举题，

考察写码技巧，

若同时枚举 $a$ 与 $b$，

时间复杂度 $O(1.2*10^{13})$

必定超时。

但我们可以想到另一种做法：

只枚举 $n$，

然后枚举所有与 $n$ 构成循环数的的 $m$，

再判断 $m$ 是否在答案范围内，

这样就极大地缩减了时间复杂度。

那么如何枚举 $m$ 呢？

很简单，

因为从 $a$ 循环到 $b$

位数都相同（题面中有。

我们可以预先算出循环范围的位数 $s$，

再预处理出 $10$ 的 $0$ 到 $6$ 次方。

然后每次取出数的最后一位 $*10^{s-1}$，

再加上这个数 $/10$ 即可。

举个例子：

$12345$，

取最后一位得 $5$，

位数 $s$ 为 $5$，

$5*10^{s-1}=5*10^4=50000$

$12345/10=1234$

$50000+1234=51234$

$51234$ 即为 $12345$ 的第一个解

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
long long ans;
int p[7]={1,10,100,1000,10000,100000,1000000};
int main(){
    int a; cin>>a;
    int b; cin>>b;
    int s=0,v=a;
    while(v) v/=10,s++;//计算位数
    for(int i=a,n,m;i<b;i++){//枚举n
        n=i;
        m=(n%10)*p[s-1]+n/10;//如上文计算m
        while(n!=m){//若n==m，则m枚举完毕
            ans+=n<m&&m<=b;//即符合条件，ans++
            m=(m%10)*p[s-1]+m/10;//枚举m
        }
    }
	cout<<ans;
	return 0;
}

```

## 完结撒花

---

## 作者：小恐 (赞：14)

本蒟蒻又来写题解啦！

感觉这题非常的暴力，but和搜索有何关系（~~也许我用的就是搜索，但我不知道，so大佬勿喷~~）？

但如果你又枚举$n$又枚举$m$，辣么你必T无疑。其实只需要枚举$n$，然后将与$n$轮换的$m$都枚举，这样就省了枚举$m$的时间

上代码：
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int ans;//最终答案，全局变量自动设为0 
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	int n,m;
	for(int i=a;i<b;++i)//因为 n < m 所以 i < b 
	{
		n=i;
		int wei=0;//n的位数 
		while(n)
			++wei,n/=10;//得到n的位数 
		n=i;
		m=(n%10)*pow(10,wei-1)+n/10;//第一个与n轮换的
		/*pow(a,b)表示a^b */
		while(m!=n)//m没有枚举一轮（如果m==n的话那么一定枚举一轮了） 
		{
			if(m>n&&m<=b)//如果这个m符合要求 
				++ans;//答案+1 
			m=(m%10)*pow(10,wei-1)+m/10;//下一个m 
		}
	}
	printf("%d",ans);//输出 
	return 0;
}
```
珍爱生命，远离抄袭

~~第2稿，求过~~

---

## 作者：hanker_AFO (赞：11)

这道题目的思路是这样的（敲黑板）

首先我们要对A~B之间的每一个数进行一次爆搜，类似全排列。


举个例子：


对1234进行操作，得到4个数 1234、4123、3412、2341


当然我们会舍去1234，不计入ans。

之后呢我们要在这些数里面找出所有大于1234的数，计入ans

题目中有提到n，m没有前导0，其实不需要判断

首先n是我们循环A~B的时候得到的，本来就没有前导0
而m如果有前导0，则必然小于n，在我们判断m>n时自然会排除。

然后还有一点，重复的要舍去。

举个例子：

对1212操作 得到 2121 1212 2121 1212

我们只能记一次2121。不能算两次。

以下是代码~~（比楼下大佬的代码短！）~~：

```cpp
#include<bits/stdc++.h>
using namespace std;

map<int,bool> mm;

int l,r;
int w;
int ww;
int ans=0;

bool same(int x)
{
    int y=x%10;
    x/=10;
    while(x>0) { int z=x%10; if(z!=y) return 0; x/=10; }
	return 1;  
} 

void check(int x)
{
	mm.clear();
    int tmp=x;
    for(int i=1;i<w;i++)
    {
	    tmp=(tmp%10)*ww+(tmp/10);
	    if(tmp>=l&&tmp<=r&&tmp>x&&!mm[tmp]) { ans++; mm[tmp]=1; }
	}
}

int main()
{
	scanf("%d%d",&l,&r);
	
	w=0; ww=1;
	int tmp=l;
	while(tmp>0) { tmp/=10; w++; ww*=10; }
	ww/=10;
	for(int i=l;i<=r;i++)
	{
	     if(same(i)) continue;
         check(i);
	}

    printf("%d",ans);
		
    return 0;
}
```

---

## 作者：Steinway (赞：6)

嗯..好 可以 ~~没人写题解~~  
嗯..好 可以 ~~很水的爆搜~~    

上面当我没说 写这个题至少交了20遍（小号大发好）  
先是**没看到** n < m  
然后 **我看到了**！ **并且**我看成了 **n <= m**！！  
woc 然后没有过样例 （痛哭）  
怀着这样的心情我交了 然后.. **90！！**  
然后我高兴了**很久**（因为这道题我写了**一天**）  
然后开始看代码 改代码  
就这样，我**又交了20多遍**  
理由？ 对 因为我的给Vis标记的k没有**清0** （很好 这很硬核）  
好了..剩下的看代码吧.. （已经无语了...）  
```cpp
//#define fre yes

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

//这个数据范围..别人都开的挺小的 但是我开小要炸..
const int maxn = 2000005;
bool Vis[maxn];
int crr[maxn];
int arr[maxn];
int brr[maxn];
int g[1125];

int n,m,ans,flag;

//快读
template<typename T>inline void read(T&x)
{
    x = 0;char c;int lenp = 1;
    do { c = getchar();if(c == '-') lenp = -1; } while(!isdigit(c));
    do { x = x * 10 + c - '0';c = getchar(); } while(isdigit(c));
    x *= lenp;
}

//这里是处理 1111、11111 这种所有数都相同的情况
bool solve(int x)
{
    int w = 0;
    int p = x % 10;
    while(x)
    {
        x /= 10;
        if(x == 0) continue;
        w = x % 10;
        if(w != p) return false;
    } return true; 
}

//核心代码 爆搜
void cheak(int x)
{
	int k = 0; //对 就是这里 这里坑了我20次提交
    int t = x; //保存x 以便与m比较

    int tot = 0;
    while(x)
    {
        tot++;
        arr[tot] = x % 10;
        x /= 10;
    } 
    for (int i=tot;i>=1;i--) crr[tot - i + 1] = arr[i];
	//因为我们存的时候是从最后往前存的 所以我们还得翻转一下
    
    for (int i=1;i<tot;i++)
    {
    //这里的for解释：我们总共替换总位数-1次即可 理由..自己想呗
    
        int tnt = 0;
        for (int j=tot-i+1;j<=tot;j++)
        {
            tnt++;
            brr[tnt] = crr[j];
            if(tnt == 1 && brr[tnt] == 0) flag = 1;
        } if(flag == 1) { flag = 0;continue; }
        for (int j=1;j<tot-i+1;j++)
        {
            tnt++;
            brr[tnt] = crr[j];
        }
        
        //最后一步 把上面处理的叠到这里
        int date = 0;
        for (int i=1;i<=tnt;i++)
        {
            if(i == 1) date = brr[i];
            else
            {
                date *= 10;
                date += brr[i];
            }
        } if(date<=m && date>t && Vis[date] == 0 ) { Vis[date] = 1;g[++k] = date;ans++; }
    }

	for (int i=1;i<=k;i++) Vis[g[i]] = 0;
}

//主程序
int main()
{
    read(n);read(m);
    for (int i=n;i<=m;i++)
    {
        if(solve(i)) continue; //如果所有位置都相同 就跳过
        cheak(i);
    } printf("%d\n",ans);
    return 0;
}
```

---

## 作者：yubing_lml (赞：2)

NO.18 本方法涉及知识点包括：字符串与数字的转换，循环嵌套，其他的没啥了。。

起初我是这样做的（代码如下），把区间内的每个数转换成字符串操作，然后用字符串的substr函数取出每个循环数进行判断，期间用到了sstream头文件中的stringstream类进行数据类型的转换，提交后发现超时了，只AC了两个点。。。

（PS：感谢题解区的大佬提醒的**循环数可能重复**的问题，一开始样例总是288，后来才发现是这个原因，mark数组用来判重）

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<sstream>
using namespace std;

int a, b;

inline int calc(int n)
{
	int mark[9];
	int ans = 0;
	stringstream ss;
	string str;
	ss << n;
	ss >> str;
	for (int i = 1; i < str.length(); i++)
	{
		string subs = str.substr(i) + str.substr(0, i);
		int tmp;
		ss.clear();
		ss << subs;
		ss >> tmp;
		if (tmp > n && tmp <= b)
		{
			bool flag = false;
			for (int i = 0; i < ans; i++)
				if (mark[i] == tmp)
				{
					flag = true;
					break;
				}
			if (!flag)
				mark[ans++] = tmp;
		}
	}
	return ans;
}

int main() {
	cin >> a >> b;
	int ans = 0;
	for (int i = a; i < b; i++)
		ans += calc(i);
	cout << ans;
	return 0;
}
```
超时原因我觉得可能是求循环数的方法太费时，所以改成了下面这种，就AC啦~

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
#include<sstream>
using namespace std;

int a, b;

int calc()
{
	int rst = 0;
	int mark[8];
	string str;
	stringstream ss;
	for (int n = a; n < b; n++)
	{
		int ans = 0;
		memset(mark, 0, sizeof(mark));
		ss.clear();
		ss << n;
		ss >> str;
		int size = str.length();
		int tmp = n, c = 10;
		int big = 1;
		while (tmp) { big *= 10; tmp /= 10;}
		for (int i = 1; i < size; i++)
		{
			tmp = (n % c) * (big / c) + (n / c);
			if (tmp > n && tmp <= b)
			{
				bool flag = false;
				for (int i = 0; i < ans; i++)
					if (mark[i] == tmp)
					{
						flag = true;
						break;
					}
				if (!flag)
					mark[ans++] = tmp;
			}
			c *= 10;
		}//for
		rst += ans;
	}
	return rst;
}

int main() {
	cin >> a >> b;
	cout << calc();
	cin >> a;
	return 0;
}
```


---

## 作者：sysong (赞：1)

# 题解P1611 循环的数字

### 题目描述

现在给定正整数 $A$ 和 $B$，并保证 $A$ 和 $B$ 位数相同且均没有前置 $0$，求存在多少循环的正整数对 $(n,m)$，使得 $A \leq n \leq m \leq B$ ？

对于循环的定义： 我们假定两个不同的正整数 $(n, m)$ 是循环的，当且仅当你能通过将 $n$ 末端的几个数字移到它的首端而不改变移动的数字的顺序并使整个数字变成 $m$ 。

---

### $Solution$

模拟可过（~~为什么标签是搜索啊~~）。

对于题目中描述的几个操作，分别解决，然后直接调用即可得到答案。

1. 我们可以选择把数字转换成字符串处理。（~~其实是不想去想怎么循环数字~~）

   数字转字符串很简单，可以直接用一个```while```循环解决。

   代码如下：

   ```c++
   while(k)s[l++]=k%10+'0',k/=10;		// k 即为原数
   ```

   这样我们是倒序存入的，所以字符串转数字稍微麻烦一点：

   ```c++
   inline int toi(int l){				// l 指数字长度
   	R int k=0;
   	for(R int i=l-1;i>=0;i--)		// 由于从 0 开始存储，所以要从 l-1 开始计算
   		k=k*10+s[i]-'0';
   	return k;
   }
   ```

   ---

2. 现在对于循环进行处理。

   **注意：1. 数字首位不为零，如果为零就继续下一个。**

   ​			**2. 这里的循环按照题目定义，不能用```next_permutation```**

   ```c++
   inline int nxt(int l,int k){
   	s[l]=s[0];
   	for(R int i=0;i<l;i++)s[i]=s[i+1];
   	if(s[0]==0)return nxt(l,k);				// 直接进行下一次循环
   	if(toi(l)!=k)return 1;
   	return 0;
   }
   ```

   ---

3. 按照题目描述，从 $A$ 到 $B$ 枚举每一个数字，判断能够组成多少个符合要求的正整数对。

   ```c++
   inline int ck(int k){
   	R int l=0,t,f=k;
   	while(k)s[l++]=k%10+'0',k/=10;		// i to a
   	while(nxt(l,f)){
   		t=toi(l);
   		if(t>f&&t<=m&&!vis[t])++k;		// 这里的 vis 是判断是否等于原数
   	}
   	return k;							// k 可能大于 1
   }
   ```

   ---

4. 把各部分连起来：

   ```c++
   #include <bits/stdc++.h>
   #define R register
   #define gc() getchar()
   using namespace std;
   
   inline int rd(){
   	R int x=0;R char c=gc();//,f=1
   	while(c>'9'||c<'0')c=gc();//{if(c=='-')f=-1;
   	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
   	return x;//*f
   }
   
   int n,m,ans;
   bool vis[2000001];
   char s[100];
   
   inline int toi(int l){
   	R int k=0;
   	for(R int i=l-1;i>=0;i--)
   		k=k*10+s[i]-'0';
   	return k;
   }
   
   inline int nxt(int l,int k){
   	s[l]=s[0];
   	for(R int i=0;i<l;i++)s[i]=s[i+1];
   	if(s[0]==0)return nxt(l,k);
   	if(toi(l)!=k)return 1;
   	return 0;
   }
   
   inline int ck(int k){
   	R int l=0,t,f=k;
   	while(k)s[l++]=k%10+'0',k/=10;
   	while(nxt(l,f)){
   		t=toi(l);
   		if(t>f&&t<=m&&!vis[t])++k;
   	}
   	return k;
   }
   
   int main(){
   	n=rd(),m=rd();
   	for(R int i=n;i<=m;i++){
   		vis[i]=1;
   		ans+=ck(i);
   	}
   	printf("%d\n",ans);
   	return 0;
   }
   
   ```

   
~~好像就我一个写成字符数组的。。。~~

写成这样应该很好理解了吧。

***by jsntsys***

$2020.11.21$

---


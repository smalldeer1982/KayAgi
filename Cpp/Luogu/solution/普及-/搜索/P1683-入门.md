# 入门

## 题目描述

不是任何人都可以进入桃花岛的，黄药师最讨厌像郭靖一样呆头呆脑的人。所以，他在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷砖中的任何一个上，但它也必须是安全的才行。

由于你是黄蓉的朋友，她事先告诉你哪些砖是安全的、哪些砖是不安全的，并且她会指引你飞到第一块砖上（第一块砖可能在任意安全位置），现在她告诉你进入桃花岛的秘密就是：如果你能走过最多的瓷砖并且没有死，那么桃花岛的大门就会自动打开了，你就可以从当前位置直接飞进大门了。

注意：瓷砖可以重复走过，但不能重复计数。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq W,H\le 20$。

## 样例 #1

### 输入

```
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
```

### 输出

```
59```

# 题解

## 作者：梦里调音 (赞：191)

题解前送大家一句话：

## 注意：瓷砖可以重复走过，但不能重复计数

如果你有什么感想，就别看题解了，改改代码吧。

一开始没看到这句话，我zz还用了回溯。

结果，只AC了一个点（算是给我面子）

真是：

# 审题不认真，代码两行泪

```
#include <bits/stdc++.h>
using namespace std;
int x[10000001],y[100000001],ans,sum,w,h,qx,qy;
char c[1001][1001];
bool flag[1001][1001];
int py[]={0,-1,0,1,0},px[]={0,0,1,0,-1};//上下左右 
int se(int sy,int sx){
//	cout<<sy<<" "<<sx<<endl;
    for(int i=1;i<=4;i++){
        ans=max(ans,sum);
        int dy=py[i]+sy,dx=px[i]+sx;
        if(flag[dy][dx]==0&&c[dy][dx]=='.'&&dy<=h&&dy>0&&dx<=w&&dx>0){
            flag[dy][dx]=1;
            sum++;
            se(dy,dx);
            flag[dy][dx]=0;
            sum--;
        }
    }
}
int main(){
    cin>>w>>h;
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++){
            cin>>c[i][j];
            if(c[i][j]=='@')qx=j,qy=i;
        }
    sum++;
    flag[qy][qx]=1;
    se(qy,qx);
    cout<<ans<<endl;
    return 0;
}
```
这是~~该死的~~错误代码，~~欢迎拿走~~


正确代码：

哦对了，我是以第四象限建图的。

用bool标记；

走下步前先判断：

	是否超界
    
    是否走过（走过就不能计数了）
    
    是否能走（即字符为‘.’）

```
#include <bits/stdc++.h>
using namespace std;
int x[10000001],y[100000001],ans,sum,w,h,qx,qy;
char c[1001][1001];
bool flag[1001][1001];
int py[]={0,-1,0,1,0},px[]={0,0,1,0,-1};//上下左右 
int se(int sy,int sx){
//	cout<<sy<<" "<<sx<<endl;
	for(int i=1;i<=4;i++){
		int dy=py[i]+sy,dx=px[i]+sx;
		if(flag[dy][dx]==0&&c[dy][dx]=='.'&&dy<=h&&dy>0&&dx<=w&&dx>0){
			flag[dy][dx]=1;
			sum++;
			se(dy,dx);
		}
	}
}
int main(){
	cin>>w>>h;
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++){
			cin>>c[i][j];
			if(c[i][j]=='@')qx=j,qy=i;
		}
	sum++;
	flag[qy][qx]=1;
	se(qy,qx);
	cout<<sum<<endl;
	return 0;
}
```
请务必点赞，Thanks♪(･ω･)ﾉ

---

## 作者：cyr2003 (赞：41)

### 广度优先搜索 深搜啦
dfs
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<iomanip>
#include<algorithm>//喜欢多加几个头文件
using namespace std;
int n,m;
int ans=0;//答案
char a[21][21];//字符矩阵
bool b[21][21];//标志数组
inline void dfs(int x,int y)//dfs
{
    if (x<1||x>m||y<1||y>n||a[x][y]=='#'|b[x][y]==false) return;//判断是否越界
    b[x][y]=false;//false表示该点走过了
    ans++;//答案加一
    dfs(x+1,y);
    dfs(x-1,y);
    dfs(x,y+1);
    dfs(x,y-1);//向四个方向搜索
}
------------
真正的主程序从这里开始

int main()
{
    ios::sync_with_stdio(false);//加快读入速度
    cin>>n>>m;
    int p,q;//用来记录@，起点
    for (int i=1;i<=m;i++)
     for (int j=1;j<=n;j++) 
      {
        cin>>a[i][j];//读入
        b[i][j]=true;//一开始都可以走
        if (a[i][j]=='@')  {p=i; q=j;}
      }
    dfs(p,q);//深搜
    cout<<ans;//完美输出答案
    return 0;
}

```
求通过（心塞，一开始我把行列搞反了，555）


---

## 作者：那一条变阻器 (赞：21)

# 题意简述：
给你一个图，一个起点，找与起点相连的地板数量

------------
其实这是一道很简单的搜索题，这里给出深搜的做法（~~绝对不是因为不会广搜~~）


------------
首先，我们可以把它转化为数字来处理，走过的和不能走的标记为-1，而没走的可以标记为0，然后就需要把起点找出来，因为起点也算，所以ans的初始值应该为1。

### 本题坑点：
- 输入的方阵长宽是反的（~~想不到吧~~）
- 走一个标记一个，而且不用回溯，因为朝四个方向走，没个路口都能走完
- 自己的那块砖也算！！！ans初始值为1！！！

接下来就是蒟蒻的代码了：
```cpp
#include <bits/stdc++.h>
using namespace std;
int sx , sy , ans = 1/*赋值为1！！！*/ , n , m; 
char st; //输入的字符 
int a[23][33] = {0}; //2333
int dx[] = {0 , 1 , 0 , -1} , dy[] = {1 , 0 , -1 , 0}; 
/*
方向初始化，四个方向时一个不为零时，对应的另一个就要为零； 
而向马这样的，一个为±2，另一个就不为零了； 
八个方向以此类推 
*/
//开搜啦(*^▽^*) 
void g(int x , int y){
	for(int v = 0; v <= 3; v++){ //四个方向依次来 
		int xx = x + dx[v] , yy = y + dy[v]; //开走 
		if(a[xx][yy] == 0 && xx <= n && xx >= 1 && yy <= m && yy >= 1){ //既能走，又不越界 
			a[xx][yy] = -1; //走过了 
			ans++; 
			g(xx , yy); //搜下一步 
		}
	}
}
int main(){
	cin >> m >> n;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			cin >> st;
			if(st == '.') a[i][j] = 0;
			if(st == '#') a[i][j] = -1;
			if(st == '@'){
				sx = i;
				sy = j;
			}
		}
	a[sx][sy] = -1; //起点是走过的 
	g(sx , sy);
	cout << ans;
	return 0;
} 
```
希望对刚学深搜的同学有帮助鸭！ ~~开溜~~


---

## 作者：Jack2007Q (赞：15)

#### 这道题的输入顺序还是反的~~坑了我半个小时~~

# 说一下题意：

### 跟迷宫差不多（个人认为）就是一直走并记录可以访问的'.'的位置

用DFS一直走，走一步打一个标记，千万注意不可以重复走

# 代码附上：
```cpp
#include <iostream>
using namespace std;
int n , m , cnt = 1;
char a[1000][1000];
bool vis[1000][1000];
void dfs(int x , int y){
	int dx[4] = {0 , 0 , -1 , 1};   //横着y坐标走
	int dy[4] = {1 , -1 , 0 , 0};   //竖着x坐标走
	for(int i = 0; i < 4; i++){    //枚举四个坐标
		int xx = x + dx[i];   
		int yy = y + dy[i];      //求要走的xy(横纵)坐标
		if(a[xx][yy] == '.' and vis[xx][yy] != true){  //如果这个点没有被访问过并且没有出界和墙就走
			cnt++;           //计数（一共有多少个可以走到的点）
			vis[xx][yy] = true;   //设为已经走过的路
			dfs(xx , yy);       //继续递归
		}
	} 
	return ;
}
int main(){
	int w , e;
	cin >> m >> n;
	for(int i = 0; i <= n; i++){
		for(int j = 0; j <= m; j++){
			a[i][j] = '0';      //设立边界值
		}
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> a[i][j];      //输入
			if(a[i][j] == '@'){   //如果为起始点就标记以便过会DFS用
				w = i , e = j;   
			}
		}
	}
	dfs(w , e); 		//递归（DFS）
   cout << cnt << endl;  //输出计数
}
```


## 第一次写题解，求赞，求管理员大大通过！！！

---

## 作者：二元长天笑 (赞：13)

这一道题在天笑第一眼看来，就是一道**很纯很纯的广搜**，但是这道题有一些非常坑爹的地方，这是在我做题的时候发现并记下来的：


**1、W和H在搜索和输入的时候弄反。**

我做这道题的时候，并没有过多的去想过这个问题，结果在这上面栽了3次。后面我问了同校的另一些OJer们，他们也有很多栽在了这个点上，**这个点一定要重视！**

**2、边线条件。**

估计只要是搜索的题都会有边界，但有可能有些人只想到了其中一组，往往是最简单的**X>=0 和Y>=0**之类的会忽略掉。

**3、数组问题**

队列数组一定要开得够大，不要吝啬空间，天笑在这个上面就栽了1次，只开到51，结果就爆炸了。


说完上面几点，下面就是AC代码了，**纯纯的广搜**：


```cpp
#include<iostream>
#include<string>
using namespace std;
string str;
int h,w,head=0,tail=1,p1[4]={1,0,0,-1},p2[4]={0,1,-1,0},ans,fx[1001],fy[1001],x,y;  //纯手工队列！
bool l[1001][1001]={false};  //是否走过或能否走
int main()
{
    cin>>w>>h;
    for(int i=1;i<=h;i++)  //来自W和H的淡淡的忧伤
    {
        cin>>str;
        for(int j=0;j<w;j++)
        {
            if(str[j]=='@')
            {
                fx[1]=i;
                fy[1]=j+1;
            }
            if(str[j]=='#')
                l[i][j+1]=true;
        }
    }
    do    //广搜开始啦！
    {
        head++;
        for(int i=0;i<=3;i++)
        {
            x=fx[head]+p1[i];
            y=fy[head]+p2[i];
            if(!l[x][y]&&x<=h&&y<=w&&x>=1&&y>=1)
            {
                ans++;
                l[x][y]=true;
                tail++;
                fx[tail]=x;
                fy[tail]=y;
            }
        }
    }while(head<tail);
    cout<<ans<<endl;    //没啦！
}
```

---

## 作者：zhjzhmh (赞：8)

首先，请大家看大屏幕

————————————————————————————————————————————————

不是任何人都可以进入桃花岛的，黄药师最讨厌象郭靖一样呆头呆脑的人。所以，他

在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷

砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就

死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷

砖中的任何一个上，但它也必须是安全的才行。

————————————————————————————————————————————————

我~~直言不讳地~~说：“这一定是dfs!!!!!!!!!!!!!!!!!!!!!”
朋友们 经典dfs 传统dfs 我爱深搜

废话不多说

深搜不会请搜索右侧网址https://www.so.com/s?ie=utf-8&src=hao_360so_b&shb=1&hsid=138561c53d02a020&q=深搜

------------代码分割线------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={0,0,0,1,-1};
const int dy[]={0,1,-1,0,0};//四方向
int m,n,ans,b[30][30],qx,qy;
string st;
char ch;
void dfs(int x,int y)
{
	for(int i=1;i<=4;i++)
	{
		int cx=x+dx[i];
		int cy=y+dy[i];
		if(cx<1||cx>n||cy<1||cy>m||b[cx][cy]) continue;//判断越界和已走过或此路不通
		ans++;//又多了一块！
		b[cx][cy]=1;//走过的路假设不能再走
		dfs(cx,cy);
        	//无需回溯
	}
}
int main()
{
	cin>>m>>n;//先输入行，再输入列！！！
	getline(cin,st);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			ch=getchar();
			if(ch=='@')
			{
				qx=i;
				qy=j;
			}//标记起点
			if(ch=='#') b[i][j]=1;//此路不通
		} 
		getline(cin,st);
	}
	ans=1;//注意：起点也是地砖！
	b[qx][qy]=1;
	dfs(qx,qy);//开深搜
	cout<<ans;
	return 0;
} 
```
------------代码结束线------------

请勿抄袭qwq

(本人第一篇题解，如有不足之处，请大家多多指教）

---

## 作者：Cxs3 (赞：7)

题目链接：https://www.luogu.org/problemnew/show/P1683  

---

## 题目分析
题为“入门”，真的就是一道搜索入门题呢qwq.

$dfs$与$bfs$均可以采用，这里提供$dfs$的详解。  
~~内心：还不是你不会bfs？！~~  

咳咳  

这道题的坑有两个：  
$1.$ **长和宽是反过来输入的！！！**  
输入$w$和$h$，但下面是一个 **$h$行$w$列的** 的字符矩阵！  
我也是被坑惨了，以前在别的网站上刷题时就遇到过QAQ.  
~~屡教不改~~  

$2.$答案是算第一块砖的，即计数的变量要初始化为$1$。  
在这里栽的人就比较少了，毕竟题目提醒了。  

剩下就是纯粹的$dfs$了qwq.  
这里不再累述。

---

## 代码实现
照例略去头文件、宏定义、uns.
```cpp
int n,m,ans,x[5]={0,-1,1,0,0},y[5]={0,0,0,-1,1};
//本蒟蒻喜欢用n和m
//x和y记录朝四个方向走时横、纵两个方向上坐标的变化（从1开始）
char h[N][N];//字符矩阵
bool f[N][N];//记录是否走过
void dfs(int a,int b)
{
	int i,c,d;
	for(i=1;i<=4;i++)//四个方向
	{
	  c=a+x[i]; d=b+y[i];
	  if(c>0&&c<=n&&d>0&&d<=m&&h[c][d]=='.'&&!f[c][d])
      //若这个点在矩阵范围内且这个点可以走、之前没被走过，走到这个点上去
	  {
	  	ans++;//更新答案
	  	f[c][d]=1;//标记为走过
	  	h[c][d]='#';
	  	dfs(c,d);//从这里继续搜
	  }
	}
}
int main()
{
	int i,j,a,b;
	cin>>m>>n;//n和m要反过来！！！再提醒一遍
	for(i=1;i<=n;i++)
	  for(j=1;j<=m;j++)
	  {
	    cin>>h[i][j];
	    if(h[i][j]=='@'){a=i; b=j;}//记录起点位置
	  }
	ans=1;//初始化为1
    f[a][b]=1;//标记为走过
	dfs(a,b);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：hanbowen (赞：6)

这题真的不是很难，可以用DFS（深搜，一道很好的模板题）

## 注意：
### 1.判断边界（非常重要，否则会炸）

### 2.要标记走过的路

### 3.一定要有回溯！
放上丑陋的代码：
```cpp
#include<iostream>
using namespace std;
int h,w,ans,x,y;
char a[100][100];			//地图
void f(int n,int m)			//DFS的函数，本人喜欢用f
{
    ans++;				//记录来过的数量
    if(a[n-1][m]=='.')			//往深里搜
    {
        a[n-1][m]='#';
        f(n-1,m);
    }
    if(a[n+1][m]=='.')
    {
        a[n+1][m]='#';
        f(n+1,m);
    }
    if(a[n][m-1]=='.')
    {
        a[n][m-1]='#';
        f(n,m-1);
    }
    if(a[n][m+1]=='.')
    {
        a[n][m+1]='#';
        f(n,m+1);
    }
}
int main()
{
    cin>>h>>w;
    for(int i=1;i<=w;i++)
    {
        for(int j=1;j<=h;j++)
        {
            cin>>a[i][j];
            if(a[i][j]=='@')		//找到位置，记录！
            {
                x=i;
                y=j;
            }
        }
    }
    f(x,y);
    cout<<ans;				//漂亮的输出
    return 0;
}
```
求管理员过！~~蒟蒻的第二篇题解~~

---

## 作者：听取TLE声一片 (赞：5)

这是~~本蒟蒻（还是大犇）~~的第一篇题解，神犇勿喷。

这道题是一道标准的搜索题，只是有一个不容易发现的问题：
**行、列要倒过来！** **行、列要倒过来！** **行、列要倒过来！**
按照我们平常的习惯，先读行再读列，而这道题是先读列再读行。
废话不多说，贴上代码。
```
#include<iostream>//一堆头文件
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
using namespace std;
struct point{
	int x,y;
	point(int xx,int yy){//修改函数
		x=xx;
		y=yy;
	}
};
queue<point> q;//point类型队列
char a[110][110];//地图
int book[110][110],don[4][2]={{-1,0},{1,0},{0,-1},{0,1}},tx,ty,start1,start2;
//标记、移动、移动点、开始坐标
int n,m,s;
void bfs(int x,int y){
	q.push(point(x,y));//开始压入队列
	book[x][y]=1;//标记
	while(!q.empty()){//循环
		point p=q.front();
		q.pop();//出队
		for(int k=0;k<4;k++){//入队所有能进入的点
			tx=p.x+don[k][0];
			ty=p.y+don[k][1];//移动点坐标
			if(tx<0||tx>=n||ty<0||ty>=m)//判断
				continue;
			if(a[tx][ty]=='.'&&book[tx][ty]==0){//判断
				book[tx][ty]=1;//标记
				point point1(tx,ty);
				q.push(point1);//入队
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	swap(n,m);//行列倒过来
	for(int i=0;i<n;i++)//从0开始
		for(int j=0;j<m;j++){
			cin>>a[i][j];
			if(a[i][j]=='@'){//记录初始点
				start1=i;
				start2=j;
			}
		}
	bfs(start1,start2);//进行广搜
	for(int i=0;i<n;i++)//扫一遍标记
		for(int j=0;j<m;j++)
			if(book[i][j]==1)
				s++;
	cout<<s;	
	return 0;
}
```
千万不要抄代码！


---

## 作者：孙广宸 (赞：2)

可以说是一道dfs基础题了，数据水的一批


~~（我是不会告诉你我交了4次才AC的）~~


具体看代码解释：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
using namespace std;
bool flag[1001][1001];//标记已经走过来记录步数
char a[1001][1001];//地图
int ans=1,n,m,sx,sy;
int dx[4]={1,-1,0,0},
	dy[4]={0,0,1,-1};//蛇皮走位
int dfs(int x,int y)
{
	
	for(int i=0;i<4;i++)
	{
		int tx=x+dx[i];
		int ty=y+dy[i];
		if(a[tx][ty]=='.'&&!flag[tx][ty])
		{
			flag[tx][ty]=true;
			ans++;
			dfs(tx,ty);
			/*
            这里我用了一种染色的思想，如果有能走到的点，就把他标记为不可走，同时计数器ans++，可能有人会担心直接标记为不可走，会阻挡一些路线之类的，但其实不会的
            */
		}
	}
	return 0;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='@')
			{
				sx=i;
				sy=j;
			}
		}
	dfs(sx,sy);
	cout<<ans;
	return 0;
}

```

---

## 作者：66666a (赞：2)

没有p题解，来一发

深搜，比较基础的，大致思路就是要在外面围一圈#，然后找到@开始深搜

```cpp
var h,w,i,j,x,y:longint;
a:array[0..30,0..30] of char;
b:array[0..30,0..30] of boolean;
function ss(i,j:longint):longint;
var s:longint;
begin
s:=1;
if b[i-1,j] then
begin
b[i-1,j]:=false;
s:=s+ss(i-1,j);
end;
if b[i+1,j] then
begin
b[i+1,j]:=false;
s:=s+ss(i+1,j);
end;
if b[i,j-1] then
begin
b[i,j-1]:=false;
s:=s+ss(i,j-1);
end;
if b[i,j+1] then
begin
b[i,j+1]:=false;
s:=s+ss(i,j+1);
end;
ss:=s;
end;
begin
readln(w,h);
fillchar(b,sizeof(b),#1);
for i:=1 to h do
begin
for j:=1 to w do read(a[i,j]);
readln;
end;
for i:=0 to h+1 do
for j:=0 to w+1 do
if a[i,j]='#' then b[i,j]:=false
else if a[i,j]='@' then
begin
x:=i;
y:=j;
end else if a[i,j]<>'.' then b[i,j]:=false;
b[x,y]:=false;
writeln(ss(x,y));
end.
```

---

## 作者：Grace_White (赞：1)

## 题解 P1683 【入门】
【题目简述】

    ‘#’表示安全的砖块，‘.’表示不安全的砖块，要你从‘@’的位置开始所能安全走过的最多的砖块个数。
【解题算法】

    宽搜或深搜
【解题思路】

    从‘@’点深搜或宽搜一遍就行了。

【AC代码】

    宽搜
```pascal
const e:array[1..4,1..2] of longint=((-1,0),(0,-1),(1,0),(0,1));
var n,m,i,j,t,w,k,x,y,s:longint;
b,c:array[0..1000000] of longint;
a:array[0..21,0..21] of char;
begin
readln(m,n);
for i:=1 to n do
  begin
  for j:=1 to m do
    read(a[i,j]);
  readln;
  end;
for i:=1 to n do
  for j:=1 to m do
    if a[i,j]='@' then
      begin
      t:=1;w:=1;b[1]:=i;c[1]:=j;s:=1;
      while t<=w do
        begin
        for k:=1 to 4 do
          begin
          x:=b[t]+e[k,1];
          y:=c[t]+e[k,2];
          if (x>0) and (y>0) and (x<=n) and (y<=m) and (a[x,y]='.') then
            begin
            inc(w);
            b[w]:=x;
            c[w]:=y;
            inc(s);
            a[x,y]:='#';
            end;
          end;
        inc(t);
        end;
      writeln(s);
      end;
end.
```


    深搜
```pascal
var n,m,i,j,s:longint;
a:array[0..21,0..21] of char;
procedure sc(x,y:longint);
begin
if (x<1) or (y<1) or (x>n) or (y>m) then exit;
if (a[x,y]='#') then exit;
a[x,y]:='#';inc(s);
sc(x+1,y);sc(x-1,y);sc(x,y+1);sc(x,y-1);
end;
begin
readln(m,n);
for i:=1 to n do
  begin
  for j:=1 to m do
    read(a[i,j]);
  readln;
  end;
for i:=1 to n do
  for j:=1 to m do
    if a[i,j]='@' then
      begin
      sc(i,j);
      writeln(s);
      end;
end.
```

//这两个程序都是最基本的程序，所以不加解析了


---

## 作者：CJHGOD (赞：1)

# 这就是一道走迷宫

### 所以说，这道题，是比较入门的dfs，但问题是：这里有个坑——长宽是反的！

所以我们需要注意这几点：

1.长宽问题

2.起点也算一块砖！！！ans要+1

3.无需回溯，走一个标记一个

~~如果你非要把图转化为数字也不为过~~

## 下面是蒟蒻代码

```cpp
#pragma GCC optimize(3)//完美的O3优化
#include<bits/stdc++.h>
using namespace std;
int a[52][52];//状态数组
int ans,n,m;
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};//常量数组
void dfs(int x,int y){//dfs走起！
	for(int i=0;i<4;i++){//四个方向
		int sx=x+dx[i],sy=y+dy[i];//求出现x,y坐标
		if(a[sx][sy]==0&&sx<=n&&sx>=1&&sy<=m&&sy>=1)//边界和能否走的判断{
			a[sx][sy]=INT_MAX;//定义成走过
			ans++;//步数++
			dfs(sx,sy);//继续dfs
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	int ex,ey;
	cin>>m>>n;
	char c;
	for(int i=1;i<=？;i++){
		for(int j=1;j<=？;j++){//防抄袭
			cin>>c;
			if(c=='.')a[i][j]=0;//可走
			if(c=='#')a[i][j]=INT_MAX;//不可走
			if(c=='@'){
				ex=i;ey=j;//起点记录
				a[i][j]=INT_MAX;//其实这条可以不要，后面ans不要加1了
			}
		}
	}
	dfs(？,？);//防抄袭
	cout<<ans+1;//输出
    return 0;//好习惯
}

```

#### ~~本蒟蒻希望能过（已经3篇题解没过了）~~

---

## 作者：zjj20051228 (赞：1)

不是任何人都可以进入桃花岛的，黄药师最讨厌象郭靖一样呆头呆脑的人。所以，他在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷砖中的任何一个上，但它也必须是安全的才行。

由于你是黄蓉的朋友，她事先告诉你哪些砖是安全的、哪些砖是不安全的，并且她会指引你飞到第1块砖上（第1块砖可能在任意安全位置），现在她告诉你进入桃花岛的秘密就是：如果你能走过最多的瓷砖并且没有死，那么桃花岛的大门就会自动打开了，你就可以从当前位置直接飞进大门了。

注意：瓷砖可以重复走过，但不能重复计数。

输入输出格式


输入格式：

第1行两个正整数W和H，分别表示小路的宽度W和长度H，W和H都不大于20。

以下H行为一个H*W的字符矩阵。每一个字符代表一块瓷砖。其中，“.”代表安全的砖，“#”代表不安全的砖，“@”代表第1块砖。

【输出格式】

输出格式：

输出一行，只包括一个数，即你从第1块砖开始所能安全走过的最多的砖块个数（包括第1块砖）。
~~~
#include<bits/stdc++.h>
using namespace std;
int n,m,sum=0;
char a[21][21];
int zx[4]={1,-1,0,0};
int zy[4]={0,0,1,-1};
void dfs(int x,int y)
{
	a[x][y]='#';
	int dx,dy;
	sum++;
    for(int i=0;i<4;i++)
    {
   	    dx=x+zx[i];
   		dy=y+zy[i];
   		if(dx>=1&&dx<=m&&dy>=1&&dy<=n&&a[dx][dy]=='.')
		{
			dfs(dx,dy);
		}
    }
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=m;i++)
    {
    	for(int j=1;j<=n;j++)
		{
			if(a[i][j]=='@')
    		{
       			dfs(i,j);
			}
		}
    }
	cout<<sum;
}
~~~

---

## 作者：xukuan (赞：1)

广度优先搜索bfs

其实就是连通块

**但输入要换行，数组要多开一位！！！！




```cpp
var
 i,j,n,m,p1,p2,x,y:longint;
 a:array[0..30,0..30] of char;地图
 openx:array[0..1010,1..2] of longint;可以通过的位置
 lx:array[1..4] of -1..1=(0,-1,0,1);
 ly:array[1..4] of -1..1=(-1,0,1,0);方向
function find(x,y:longint):boolean;判重
 var
  i:longint;
 begin
  for i:=1 to p2 do
   if (openx[i,1]=x) and (openx[i,2]=y) then如果重复
    exit(false);
  exit(true);
end;
begin
 readln(m,n);
 for i:=1 to n do
  begin
   for j:=1 to m do
    begin
     read(a[i,j]);
     if a[i,j]='@' then找到一号砖
      begin
       openx[1,1]:=i;
       openx[1,2]:=j;
      end;
    end;
   readln;
  end;
 p1:=1; p2:=1;
 while p1<=p2 do广度优先搜索
  begin
   for i:=1 to 4 do
    begin
     x:=openx[p1,1]+lx[i];
     y:=openx[p1,2]+ly[i];
     if (a[x,y]='.') and find(x,y) then边界不用判断，a[i,j]='.'即可
      begin
       inc(p2);尾指针加1
       openx[p2,1]:=x;
       openx[p2,2]:=y;
      end;进入队列
    end;
   inc(p1);头指针加1
  end;
 writeln(p2);
end.

```

---

## 作者：渡海 (赞：1)

楼下dalao已经说得很清楚了，我来解解惑。


第一个坑点：n，m互换输入


第二个坑点：可以重复走，但是不能重复计数（很重要！）


换句话说，只要把开始点能走的路全走了就行，不需要回溯ans。


我的解法是dfs，因为比较简单。


从@开始，向上，下，左，右开始走，碰到能走的就走，多条路的话先走一条然后回来继续走（反正不算步数）



```cpp
#include<cstdio>
#include<cstring>
using namespace std;
char a[50][50];
bool b[50][50];//这里记录走过的路径，也就是变成true的数
int stx,sty,ans=1,m,n;
int dfs(int,int); 
int main(){
    memset(b,false,sizeof(b));//赋值
    scanf("%d%d",&m,&n);//输入（坑1）
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf(" %c",&a[i][j]);
            if(a[i][j]=='@'){
                stx=i;
                sty=j;
            }
        }
```
}//输入结束，不需要解释吧？


```cpp
    dfs(stx,sty);
    printf("%d",ans);
    return 0;
}
int dfs(int x,int y){
    int kx,ky;
    for(int i=0;i<4;i++){
        if(i==0){//上 
            kx=x-1;
            ky=y;
        }if(i==1){//下 
            kx=x+1;
            ky=y;
        }if(i==2){//左 
            kx=x;
            ky=y-1;
        }if(i==3){//右 
            kx=x;
            ky=y+1;
        }
        if(kx<1||kx>n||ky<1||ky>m){
            continue;//如果走到边界就跳出，然后从另一个方向开始走
        }if(b[kx][ky]==false&&a[kx][ky]=='.'){
            b[kx][ky]=true;
            ans++;//这里ans不需要回溯的
            dfs(kx,ky);
        }
    }
}
神犇勿喷..
```

---

## 作者：huangwenlong (赞：1)

开始用dfs死活不会写，后来用bfs问题就迎刃而解了

开个bool二维数组visited记录每个点有没有走到过

从队列取点出来的时候如果已经是visited就直接跳过，否则cnt++

然后把四周的点还没有visited的入队


        
        
```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <queue>
#define maxn 25
using namespace std;
int w,h;
int fx,fy;
bool map[maxn][maxn];
bool visited[maxn][maxn];
int ans=0;
typedef pair<int,int> point;
int main()
{
    cin>>w>>h;
    string str;
    for(int i=1;i<=h;++i)
    {
        cin>>str;
        for(int j=1;j<=w;++j)
        {
            if(str[j-1]=='.')
                map[i][j]=true;
            else if(str[j-1]=='@')
            {
                fx=i; fy=j;
            }
        }
    }
    queue<point> q;
    q.push(make_pair(fx,fy));
    while(!q.empty())
    {
        point p=q.front();
        q.pop();
        int x=p.first, y=p.second;
        if(visited[x][y]) continue;
        visited[x][y]=true;
        ans++;
        if(x-1>=0 && !visited[x-1][y] && map[x-1][y]) q.push(make_pair(x-1,y));
        if(y-1>=0 && !visited[x][y-1] && map[x][y-1]) q.push(make_pair(x,y-1));
        if(y+1<=w && !visited[x][y+1] && map[x][y+1]) q.push(make_pair(x,y+1));
        if(x+1<=h && !visited[x+1][y] && map[x+1][y]) q.push(make_pair(x+1,y));
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：夏真诚 (赞：1)

~~帮帮pascal的吧，连个题解也没有~~

希望对p党有益

还没有pascal的吧，那我来一发

比较纯的的搜索

题目内么长，其实简单来讲，

给你一个二位数组

找出所有与‘@’相连的可以走的方块，将这些方块标记为不可走，在用现在的‘#’数减去

总‘#’的格子总数里可得改变了几个方块

状态 dfs(x,y)坐标

贴代码QAQ

```
var i,j,m,n,x,y,t,t1:longint;
e:array[1..4,1..2] of longint;
a:array[0..21,0..21] of char;

procedure dfs(x,y:longint);
var i,j,g:longint;
begin
  if a[x,y]='#' then exit;//搜到了障碍，返回
    if (x<1) or (y<1) or (x>m) or (y>n) then exit;//搜到了边界，返回
  for i:=1 to 4 do
    begin
      a[x,y]:='#';//记录为障碍
      dfs(x+e[i,1],y+e[i,2]);//搜索搜索QAQ
    end;
end;

begin
 e[1,1]:=0;e[1,2]:=1;//定义四个方向，以便搜索
 e[2,1]:=0;e[2,2]:=-1;
 e[3,1]:=1;e[3,2]:=0;
 e[4,1]:=-1;e[4,2]:=0;
  readln(n,m);
   for i:=1 to m do
     begin
       for j:=1 to n do
        begin
           read(a[i,j]);
           if a[i,j]='@' then begin  x:=i; y:=j; end;//记录初始点
           if a[i,j]='#' then inc(t1);//记录原来障碍的个数
       end;
     readln;
   end;
 dfs(x,y);//搜索，初始位置
 for i:=1 to m do
   for j:=1 to n do
   if a[i,j]='#' then inc(t);//记录现在的个数
 write(t-t1);
end.
```


---

## 作者：张皓涵 (赞：1)

楼下大佬怎么都是用的BFS捏？
让我来一发————DFS
    
    #include<iostream>
	using namespace std;
	string map;
	char a[25][25];
	int dx[6]={0,0,0,1,-1},dy[6]={0,1,-1,0,0},x,y,n,m,ans=1,b[25][25],zg[25][25];
	void dfs(int x,int y)
	{
	    for(int i=1;i<=4;i++)
		{
  	      int tx=x+dx[i],ty=y+dy[i];
        	if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&b[tx][ty]==1&&zg[tx][ty]==0) //判断越界、走过、有毒
			{
 	           ans++;  //+1
				zg[tx][ty]=1;//设为走过
  	          dfs(tx,ty);
  	      }
  	  }
	}
	int main()
	{
	    cin>>m>>n;
	    for(int i=1;i<=n;i++)
		{
 	       cin>>map;
	        for(int j=0;j<m;j++)
			{
 	           if(map[j]=='@')	 {x=i;y=1+j;zg[i][j+1]=1;} //起始点:标记走过+记录位置
  	          if(map[j]=='.') b[i][j+1]=1; //可以走:标记为可走
	            if(map[j]=='#') b[i][j+1]=0; //有毒:标记为不可走(小心被毒死哦)
	        }
 	   }
 	   dfs(x,y);
 	   cout<<ans;
 	   return 0;
	}
为了保证各位看官名字颜色正常,请不要抄题解哟

---

## 作者：Chloris (赞：1)

### 由于我比较喜欢DFS的缘故，这道题我最开始用的是DFS，但由于我太蒟了，DFS写炸了，后来又改写BFS求联通块，然后BFS又写炸了，最后把BFS检查出来后，DFS也fix了，这里我给出两种做法：
----
1.BFS大法：

看了看楼下大佬的题解，都用了一个数组来判断是否走过或是否能走，但是`因为我太蒟了`所以看不懂，我认为对于`新手`而言还是两个数组比较直观。

```cpp
用b[i][j]表示能否走
用vis[i][j]表示是否走过
```

然后就是正常的思路

扩展节点的时候只有当没有越界且这个格子没有走过且这个格子可以走，那就扩展这个节点：
当然，因为这个节点没有被扩展过，所以计数器ans++;

```cpp
if(tx >= 1 && tx <= n && ty <= m && ty >= 1 && b[tx][ty] == 1 && vis[tx][ty] == 0){
                ans++; que[tail].x = tx; que[tail].y = ty; vis[tx][ty] = 1; ++tail;}
```

最后是存图问题，注意这里行和列是反着输入的，比较坑.......

不完整代码（重要部分）：
```cpp

struct QUEUE{//手写队列
    int x,y;
}que[1000];

int head = 1,tail = 1;//队头指针和队尾指针

bool b[25][25];//能走？
bool vis[25][25];//走过？


int dx[6] = {0,0,1,-1};//四个方向
int dy[6] = {1,-1,0,0};

int ans = 1;//初始ans = 1,因为开始的'@'也算上一个

int n,m;

string str;

int main(){
    scanf("%d%d",&m,&n);//反着输入
    for(int i = 1;i <= n; i++){
        cin >> str;//直接读入一行字符串，参考楼下大佬
        for(int j = 0;j < m; j++){//从0开始所以下面j要+1
            if(str[j] == '@'){
                que[tail].x = i; que[tail].y = j + 1; tail++; b[i][j + 1] = 1; vis[i][j + 1] = 1;//扩展开始点
            }
            if(str[j] == '.') b[i][j + 1] = 1;
            if(str[j] == '#') b[i][j + 1] = 0;
        }
    }
    while(head <= tail){//标准广搜
        for(int i = 0;i < 4; i++){//枚举四个方向
            int tx = que[head].x + dx[i];
            int ty = que[head].y + dy[i];
            if(tx >= 1 && tx <= n && ty <= m && ty >= 1 && b[tx][ty] == 1 && vis[tx][ty] == 0){
                ans++; que[tail].x = tx; que[tail].y = ty; vis[tx][ty] = 1; ++tail;
            }
        }
        head++;//别忘了这个
    }
}
```


----

2. DFS大法：

对于DFS解法，应该不是正解吧，所以我也不详细讲了，但是具体的思路是跟BFS类似的，这里的方法只是多了一个数组分开记录是否能走和有无走过，如果只想要用一个数组，请看楼下大佬的解法

贴上完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int stax,stay,n,m,ans = 1;
bool b[25][25];

bool vis[25][25];

char a[25][25];

int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};

void dfs(int x,int y){
    for(int i = 0;i < 4; i++){
        int tx = x + dx[i],ty = y + dy[i];
        if(tx >= 1 && tx <= n && ty >= 1 && ty <= m && b[tx][ty] == 1 && vis[tx][ty] == 0){
            ans++; vis[tx][ty] = true;
            dfs(tx,ty);
        }
    }
}

string str;

int main(){
    scanf("%d%d",&m,&n);
    for(int i = 1;i <= n; i++){
        cin >> str;
        for(int j = 1;j <= m; j++){
            if(str[j - 1] == '@') {stax = i;stay = j; vis[i][j] = 1;}
            if(str[j - 1] == '.') b[i][j] = 1;
            if(str[j - 1] == '#') b[i][j] = 0;
        }
    }
    dfs(stax,stay);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：0)

# DFS
看看程序，发现了吗？我没用额外的bool数组标志是否走过，只用把原数组的相应位置设成障碍
```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int m,n,i,j,d[4][2]={{-1,0},{0,1},{1,0},{0,-1}},ans;
char a[20][20];
void dfs(int t1,int t2)//普通的DFS函数
{
  	ans++;//终于找到一个新的砖头可走了
    a[t1][t2]='#';//相当于把bool标志数组置为已经过
    for(int t=0;t<4;t++)
        if(t1+d[t][0]>=0&&t1+d[t][0]<m&&t2+d[t][1]>=0&&t2+d[t][1]<n&&
           a[t1+d[t][0]][t2+d[t][1]]!='#')
            dfs(t1+d[t][0],t2+d[t][1]);
}

main()//更普通的主函数
{
    scanf("%d%d",&n,&m);
    for(i=0;i<m;i++)scanf("%s",&a[i]);
    for(i=0;i<m;i++)
    {
        for(j=0;j<n;j++)if(a[i][j]=='@')break;//找出发点
        if(j<n)break;
    }
    dfs(i,j);
    printf("%d",ans);
}/**/
```

---

## 作者：Punny (赞：0)

## 发一波pair+queue的题解
先看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[30][30];
bool v[30][30];
int w,h,bx,by,ans=1;
int tx[4]={1,0,0,-1},ty[4]={0,1,-1,0};
void bfs(){
    queue<pair<int,int> >q;
    q.push(make_pair(bx,by));
    while(q.size()){
        int x=q.front().first,y=q.front().second;q.pop();
        for(int i=0;i<4;i++){
            int X=x+tx[i],Y=y+ty[i];
            if(!v[X][Y]&&X<=h&&Y<=w&&X>0&&Y>0){
                ans++;
                v[X][Y]=1;
                q.push(make_pair(X,Y));
            }
        }
    }
}
int main(){
    scanf("%d%d",&w,&h);
    for(int i=1;i<=h;i++){
        for(int j=1;j<=w;j++){
            cin>>mp[i][j];
            if(mp[i][j]=='@') bx=i,by=j,v[i][j]=1;
            if(mp[i][j]=='#') v[i][j]=1;
        }
    }
    bfs();
    cout<<ans;
    return 0;
}
```
BFS部分省略

组要讲一下pair的用法

pair相当于一个小型的结构体可以存储两个类型的数据引用时靠first与second来调用这两个数据。

这里的用法和结构体类似。[戳我 具体了解pair的用法 戳我](https://www.luogu.org/blog/Xiao-Gengtai/pair-de-yong-fa)

---


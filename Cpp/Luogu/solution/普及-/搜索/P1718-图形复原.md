# 图形复原

## 题目描述

HWX 小朋友对几何的热爱在电脑组是出了名的，号称“每题必解”，这天，LXC 在玩 logo 的时候突然想到了一个题目，刚好可以去测试一下他封号的虚实，于是，他 logo 编程画了一个 $n$ 边形，并且将 $n$ 个顶点用 $1, 2, 3, \ldots, n$ 这 $n$ 个连续自然数随手编了个号，为了增加难度，他又画了一些不相交的对角线。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4g8ij0r9.png)

他把所有的边和对角线都写在一张纸上，对于上图，他写了：$(1, 3)$、$(3, 2)$、$(2, 4)$、$(4, 5)$、$(5, 1)$、$(1, 4)$、$(3, 4)$。正得意的时候，电脑突然自动重启了，郁闷的是，他忘记保存刚才的 logo 程序了，此刻的他很想利用纸上记录的信息将这个 $n$ 边形的编号复原，电脑组的你能帮助他吗？


## 样例 #1

### 输入

```
5
1 3
3 2
2 4
4 5
5 1
1 4
3 4
```

### 输出

```
1 3 2 4 5
```

# 题解

## 作者：LJB00125 (赞：22)

# 神奇的深搜！！

~~然而居然有人用tarjan写~~

***大致思路***

使用f[i][j]表示i到j的距离，ans[i]表示答案的第i个数是多少,used[i]表示i这个点是否被用过

dfs时，如果再次搜索到1并且答案长度变成了n+1,说明找到答案（因为字典序最小），输出后直接退出程序；否则，扩展这个点

dfs(nownow,anscnt):nownow表示当前的点，anscnt表示标记了多少个点。

详见注释。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
bool f[51][51],used[2500];
int ans[2500];
void dfs(int nownow,int anscnt)
{
    if(nownow==1&&anscnt==n+1)
    {
        for(int i=1;i<anscnt;i++) printf("%d ",ans[i]);
        exit(0);//输出答案，直接退出
    }
    for(int i=1;i<=n;i++)
        if(i!=nownow&&f[nownow][i]&&(!used[i]||(i==1&&anscnt==n)))//这不是当前的点，并且联通、而且没有用过或者这是1并且搜索完了
        {
            used[i]=1;ans[anscnt+1]=i;//标记为使用过，记录
            dfs(i,anscnt+1);
            used[i]=0;//回溯，重新标记为没有用过
        }
}
int main()
{
    scanf("%d",&n);
    while(scanf("%d %d",&a,&b)!=EOF)
    {
        f[a][b]=f[b][a]=1;//双向的
    }
    ans[1]=1;used[1]=1;//1这个点已经用过了，标记一下
    dfs(1,1);
    return 0;
}

```

---

## 作者：银河AI (赞：5)

### 解题思路

不需要 tarjan ，普通的深搜。

从每个点开始搜，遍历 $n$ 个点，如果遍历到的最后一个点可以到达起点，那么我们一定遍历到了一个环。

这时候因为我们是从小到大开始搜的，所以最后的结果一定是最小的字典序。

我们将第 $i$ 个遍历的点记下来，输出即可。

### AC代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,m,sum,s;
int ans[60];
bool all,flag;
bool a[60][60],vis[60];
void dfs(int k,int cnt){
    if(flag==true) return;
	ans[cnt]=k;
	if(cnt==n&&a[k][s]==1){
        for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
        flag=true;
        return;
    }
    for(int i=1;i<=n;i++){
        if(a[k][i]&&k!=i&&!vis[i]){
            vis[i]=1;
            dfs(i,cnt+1);
            vis[i]=0;
        }
    }
    
}
int main(){ 
	scanf("%d",&n);
	for(int i=1;i<=2*n-3;i++){
	    int x,y;
	    scanf("%d%d",&x,&y);
	    a[x][y]=1;
	    a[y][x]=1;
	}
	for(int i=1;i<=n;i++){   
	    s=i;
	    vis[i]=1;
	    dfs(i,1);
	}
}
```


---

## 作者：Eleveslaine (赞：3)

~~难得遇见题号小于P2000还有题解通道的橙题qwq~~

## 题意

一张无向图，找到它唯一的过所有点的回路。

## 做法

深搜，从任何一点（这里从 $1$）开始遍历整张图；如果发现回到了遍历的起点并且 $n$ 个点都搜过了，结束递归。  
注意到 $\max n=50$，所以用邻接矩阵足矣。另外边没有边权，故邻接矩阵可以只开 `bool` 类型，空间没有问题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 55
int n,a,b;
bool g[maxn][maxn]; // 邻接矩阵
bool vis[maxn]; // 判断是否已经经过
int ans[maxn],lans; // ans：存储答案的数组(下标从0开始)，lans 为其长度
bool dfs(int u,int depth)
{
    if(u==1 && depth==n)
    {
        return 1;
    }
    for(int v=1;v<=n;++v)
    {
        if(g[u][v] && !vis[v])
        {
            vis[v]=1;
            if(dfs(v,depth+1))
            {
                ans[lans++]=v;
                return 1;
            }
            vis[v]=0;
        }
    }
    return 0;
}
int main()
{
    cin >> n;
    while(cin >> a >> b)
        g[a][b]=g[b][a]=1; // 无向图
    dfs(1,0);
    cout << ans[0] << " ";
    for(int i=lans-1;i>=1;--i)
        cout << ans[i] << " ";
    return 0;
}
```

~~注释写不下的~~对代码中一些细节的解释：

- `dfs` 函数的参数：$u$ 为当前节点，`depth` 为递归深度，即遍历的节点个数。  
`dfs` 函数的返回值：$1$ 代表遍历已经结束，处于返回阶段。$0$ 则代表需要继续遍历。

- 与一些走迷宫的题目不同，在调用 `dfs` 前不能 `vis[1]=1`。因为遍历路径是一个回路，最后需要再次搜到 $1$，如果一开始标记 $1$ 就不能再访问 $1$ 了。

- 不能设 `g[i][i]=1`，除非在 `dfs` 中的 `for` 里加上 `if(u!=v)`。

- 注意最后 `ans` 数组输出的顺序：先输出 `ans[0]`，其后的 `ans[1]` 到 `ans[lans-1]` 倒序输出。  
题目要求按字典序输出，而 `ans` 存储了所有 $n$ 个点，所以输出一定要从 $1$ 开始。又因为 `ans[0]` 一定为 $1$（遍历终点为 $1$），故可以先输出 `ans[0]`。之后的部分因为递归返回的顺序与遍历相反，所以需要逆序输出。  
~~另外，似乎有 `lans=n`？~~

---

## 作者：neverreborn (赞：3)

比较有意思的一道题。

关键在于想到问题的本质是搜索一个环，包括所有的顶点。

首先完成一个证明，假如一个多边形，顶点依次是1、2、3..n，没有连接相交的对角线，那么它只有一个包括所有顶点的环。假设存在第二个，那么从1号点开始连接这个环，必有这样一个点i，它连接的不是i+1号点(假如不存在这样的点，就和原多边形一样了），这条由i连向i+j点的线段把整个点集分成了两部分，必然不能形成环，因为如果要形成环，则这两部分必有连线，而连线又必与i->i+j这条线相交，与题设矛盾。

所以我们只要在这个图中搜索出一个回路就可以了，注意按照字典序。


---

## 作者：封二少 (赞：2)

1道简单的深搜

f[i][j] = 1 表示点i与点j相连

题目的意思是让我们找到1个环

我们从点1开始dfs，设ans来储存走过的路,设bo来判断能不能走到第i个点，如果要走就把bo[i]改为1，之后就不能重复走这个点

直到我们搜了n条边并且回到点1就退出,最后循环输出ans就是答案

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
int n, a, b, f[55][55], bo[55], ans[55];
using namespace std;    
inline int get()
{
    char ch;
    int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch != '-')
      res = ch - '0';
    char c;
    while ((c = getchar()) >= '0' && c <= '9')
      res = (res << 3) + (res << 1) + c - '0';
    return ch == '-' ? ~res + 1 : res;
}
void put(int x)
{
    if (x < 0)
      putchar('-'), x = ~x + 1;
    if (x > 9) put(x / 10);
      putchar(x % 10 + '0'); 
}
bool bl(int l, int z)
{
    if (l == n + 1 && z == 1) return true;
    else if (l < n + 1)
    {
        for (int i = 1; i <= n; ++i)
          if (f[z][i] == 1 && bo[i] == 0)
          {
                f[z][i] = 0; f[i][z] = 0; bo[i] = 1; ans[l] = i;
                if (bl(l + 1, i) == true) return true;
                f[z][i] = 1; f[i][z] = 1; bo[i] = 0;
          }
    }
    return false;
}
int main()
{
    n = get();
    while(scanf("%d%d", &a, &b) == 2)
    {
        f[a][b] = 1;
        f[b][a] = 1;
    }
    bl(1, 1);
    put(1); printf(" ");
    for (int i = 1; i <= n - 1; ++i)
      put(ans[i]), printf(" "); 
}
```

---

## 作者：huangjiarui (赞：1)

本题解提供本题的两个多项式复杂度的做法。

包括一个时间复杂度为 $O(n)$ 的做法和一个基于 Tarjan 的时间复杂度为 $O(n^2)$ 的做法。

~~本题的题面数据范围为 n 不大于 50，但实际上数据中 n 不大于20，所以题解中全部是搜索。但事实上截止本题解发出，没有一篇题解可以通过 n=50 的数据。~~

先给出一个结论：若本题存在答案，则不存在两个不同的长度为 n 的环。

证明见该[博客](https://www.luogu.com.cn/blog/user754/solution-p1718)。

那么本题就相当于在图中求出一个长度为 n 的环。

## 做法1 $O(n)$

观察可得如果一个点的度数为 2，那么相邻的两条边一定在长度为 n 的环内。

如果存在一条从 u 到 v 的长度不等于 n-1 的路径，且路径中的每一个边都一定在长度为 n 的环内，那么如果边 (u,v) 存在，那么删去 (u,v) 不影响结果。

于是我们考虑先找到一个度数为 2 的点，然后向两边扩展，在扩展的过程中删去端点间的边。

扩展时有两种情况，扩展到的下一个点 u 未被扩展到过，扩展到的下一个点 u 被扩展到过。

1. 扩展的下一个点 u 未被扩展到过。那么我们就把当前扩展段的端点改成新点，然后判断新点与另一个端点之间是否有边即可。

2. 扩展的下一个点 u 被扩展到过。那么我们就把两个扩展段进行合并，删除端点间的边，然后考虑 u 相连的其他边。应为 u 已经确定了相连的两条边，所以可以遍历与 u 相连的边，直接将其他边删除。

如果发现两个边界度数为 2，不能扩展，那么就换一个点扩展，如下图所示，完成点 1 的扩展后，发现点 2,6 的度数均为 3，那么就换另一个度数为 2 的点（3 或 5）扩展：

![](https://cdn.luogu.com.cn/upload/image_hosting/rnhs6rmv.png)

比如再换成点 5 进行扩展，那么第一次会删除边 (4,6),(2,4)，扩展段的端点即为 2 和 4，第二次扩展到 3 ，然后问题就解决了。

关于正确性，我们需要一个观察：

一个凸 $n(n\ge3)$ 边形中有若干条不交叉的对角线，那么必然存在点的度数为 2。

证明略。

于是每次把度数为 2 的点扩展，相当于将这个扩展段里的点缩成一个大点。如果剩余的点大于 2，那么新的图依旧满足限制条件，可以继续扩展。

最后是一些细节：

1. 上文中有提到扩展扩展段后需要判断端点间是否存在边。下文的代码的实现可以保证每一次操作严格 $O(1)$（说明可以见附注）。但实际上只需要遍历两端点度数较小的点，即可实现每一次操作均摊 $O(1)$，同样可以做到总复杂度 $O(n)$。

2. 合并扩展段可以省掉并查集，因为只有端点会与非该扩展段的点有连边，扩展时只需修改端点的所属扩展段。但是这样可能会在扩展时扩展到段内的结点，所以下文代码中还记录了端点的相邻结点。

时间复杂度分析：

易得边数 $m$ 满足 $n\le m\le 2n-3$。

每一个点至多扩展一次，故扩展总复杂度为 $O(m)=O(n)$。

判断端点间线段至多 $O(n)$ 次，每一次 $O(1)$ ，故总复杂度为 $O(n)$。

合并扩展段时，需要遍历合并点相连的边，每一条边至多被遍历 2 次，这部分的复杂度为 $O(m)=O(n)$。

其他部分复杂度也为 $O(n)$。

所以总复杂度为 $O(n)$。

参考代码：

```
#include<cstdio>
#include<cstring>
const int N = 500010;
int l[N],r[N],col[N],d[N],q[N],sz[N],t,h,dd[N],adj[N];
int ver[N*4],next[N*4],head[N],ecnt = 1;
int _index[N][2],val[N][2],q1[N],cnt1;
bool exist[N*4];
int n,ll,rr,last,nxt,u,v;
void add_edge(int u,int v)
{
    ver[++ecnt] = v,next[ecnt] = head[u],head[u] = ecnt;
}
int find(int u,int v)
{
	if (_index[u][0] == v)
		return val[u][0];
	if (_index[u][1] == v)
		return val[u][1];
	return 0;
}
void delete_edge(int u,int v)
{
	int p = find(u,v)+find(v,u);
	if (p && exist[p])
	{
		exist[p] = exist[p^1] = 0;
		--d[u],--d[v];
	}
}
int find_adj(int u)
{
	for (int i = head[u];i;i = next[i])
		if (exist[i] && col[ver[i]] != col[u] && ver[i] != adj[u])
			return ver[i];
    return 0;
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	scanf("%d",&n);
	while (scanf("%d%d",&u,&v) != EOF)
		add_edge(u,v),add_edge(v,u),++d[u],++d[v];
	memset(exist,0xff,sizeof(bool)*(ecnt+10));
	for (int i = 1;i <= n;++i)
	{
		if (d[i] == 2)
			q[++t] = i;
		dd[i] = d[i];
		if (dd[i] <= 2)
			q1[++cnt1] = i;
	}
   //以下部分是为了下面可以O(1)查询任意两点间是否有边相连
	while (cnt1)
	{
		int x = q1[cnt1--];
		for (int i = head[x];i;i = next[i])
			if (exist[i])
			{
				exist[i] = exist[i^1] = 0,--dd[ver[i]];
				if (_index[x][0])
					_index[x][1] = ver[i],val[x][1] = i;
				else
					_index[x][0] = ver[i],val[x][0] = i;
				if (dd[ver[i]] == 2)
					q1[++cnt1] = ver[i];
			}
	}
   //
	memset(exist,0xff,sizeof(bool)*(ecnt+10));
    while (h++ < t)
    {
        if (col[q[h]])
            continue;
        col[q[h]] = h,sz[h] = 1;
		ll = find_adj(q[h]);
        if (col[ll] == 0)
            col[ll] = h,++sz[h],adj[l[h] = ll] = q[h];
        else
        {
            sz[h] += sz[col[ll]],l[h] = l[col[ll]]+r[col[ll]]-ll,col[l[h]] = col[ll] = h;
            for (int i = head[ll];i;i = next[i])
                if (exist[i] && col[ver[i]] != h && ver[i] != adj[ll])
                    exist[i] = exist[i^1] = 0,--d[ver[i]],--d[ll];
        }
        rr = find_adj(q[h]);
        if (col[rr] == 0)
            col[rr] = h,++sz[h],adj[r[h] = rr] = q[h];
        else
        {
            sz[h] += sz[col[rr]],r[h] = l[col[rr]]+r[col[rr]]-rr,col[r[h]] = col[rr] = h;
            for (int i = head[rr];i;i = next[i])
                if (exist[i] && col[ver[i]] != h && ver[i] != adj[rr])
					exist[i] = exist[i^1] = 0,--d[ver[i]],--d[rr];
        }
        if (l[h] != ll && r[h] != rr)
            delete_edge(ll,rr);
        if (r[h] != rr)
            delete_edge(l[h],rr);
        if (l[h] != ll)
            delete_edge(ll,r[h]);
        if (sz[h] < n)
            delete_edge(l[h],r[h]);
        if (sz[h] == n)
            break;
        while (l[h] != r[h] && (d[l[h]] == 2 || d[r[h]] == 2) && sz[h] < n)
        {
            if (d[l[h]] == 2)
            {
                ll = find_adj(l[h]);
                if (col[ll] == 0)
                    ++sz[h],adj[ll] = l[h],col[l[h] = ll] = h;
                else
                {
					sz[h] += sz[col[ll]],l[h] = l[col[ll]]+r[col[ll]]-ll,col[l[h]] = h;
					for (int i = head[ll];i;i = next[i])
						if (exist[i] && col[ver[i]] != h && ver[i] != adj[ll])
							exist[i] = exist[i^1] = 0,--d[ver[i]],--d[ll];
					delete_edge(ll,r[h]);
				}
			}
			else
			{
				rr = find_adj(r[h]);
				if (col[rr] == 0)
					++sz[h],adj[rr] = r[h],col[r[h] = rr] = h;
				else
				{
					sz[h] += sz[col[rr]],r[h] = l[col[rr]]+r[col[rr]]-rr,col[r[h]] = h;
					for (int i = head[rr];i;i = next[i])
						if (exist[i] && col[ver[i]] != h && ver[i] != adj[rr])
							exist[i] = exist[i^1] = 0,--d[ver[i]],--d[rr];
					delete_edge(l[h],rr);
                }
			}
			if (sz[h] < n)
				delete_edge(l[h],r[h]);
		}
	}
	printf("1"),last = 1,nxt = n;
	for (int i = head[1];i;i = next[i])
		if (exist[i] && ver[i] < nxt)
			nxt = ver[i];
	printf(" %d",nxt);
	for (int i = 1;i <= n-2;++i)
		for (int j = head[nxt];j;j = next[j])
			if (exist[j] && ver[j] != last)
			{
				printf(" %d",ver[j]),last = nxt,nxt = ver[j];
				break;
			}
	puts("");
	return 0;
}
```

## 做法2 $O(n^2)$

该做法非本人 idea，因与上文想法很不相同，故列与此。

考虑到本题的图是一个边双联通分量。

如果删去一条对角线，那么本题的图还是一个边双联通分量。

如果删去一条多边形上的边，那么本题的图就不再是一个边双联通分量。

以上结论证明略。

故对于每一条边，判断其删去后是否为边双联通分量即可。

边数为 $m=O(n)$ ，每一次 Tarjan 时间为 $O(n)$，故总时间复杂度为 $O(n^2)$。

### 附注

上文提到可以做到查询任意两点间是否有边单次 $O(1)$，方法如下：

考虑将一条边 (u,v) 存储在其一个端点上，查询时在两个端点查询。

考虑每一次在图中找到度数不大于 2 的点，将相邻的两条边存在这个点上，然后将这个点和相连的边删掉。

现在的图形如一个中间可能有一些不交叉对角线的凸多边形和一些以多边形的端点为根的树或者一棵树，因为上文的观察，图中总存在度数不大于 2 的点，故可以一直删除。

因为每一个结点保存的边数不大于 2，故单次查询复杂度为 $O(1)$。

鉴于本题当 n 较大时无处评测，故此处提供一个本人写的数据生成器，见[此](https://www.luogu.com.cn/blog/hjrhhh/p1718-ti-xie-san-kao-zi-liao)。

### Reference

[1][https://www.luogu.com.cn/blog/user754/solution-p1718](https://www.luogu.com.cn/blog/user754/solution-p1718)

[2][https://www.luogu.com.cn/blog/hjrhhh/p1718-ti-xie-san-kao-zi-liao](https://www.luogu.com.cn/blog/hjr626824755hhh/p1718-ti-xie-san-kao-zi-liao)

---

## 作者：I_never_left (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1718)

题意：求将 $n$ 个点在不重复的情况下全部遍历一遍的顺序。
### 思路：
这里讲一种深搜方法。
- 首先，这是一个无向图，我们可以用一个二维数组存下来，因为不知道有多少条边，所以我们可以用  ```while``` 
 循环存边，而结果用一个 $b$ 数组存下来。
- 接着，我们就开始搜索图了，因为要是字典序最小，所以我们从点 $1$ 开始搜索。在函数中要先进行判断如果已经全部遍历过了且头尾能相连就输出 $b$ 数组中的元素，否则就遍历，寻找能够到达的点再搜索。
#### 搜索函数代码
 ```cpp
void dfs(int u,int sum){
	if(flag) return;
	if(sum==n){
		if(a[u][1]==1){
			flag=1;
			print();
		}
		return;
	}
	for(int v=1;v<=n;v++){
		if(a[u][v]==1&&!vis[v]){
			vis[v]=1;
			b[sum+1]=v;
			dfs(v,sum+1);
			vis[v]=0;
		}
	}
}
```
+ 最后要注意一点细节：遍历前我们要先把 $b$ 数组的第一位改为 $1$，因为是从 $1$ 点开始。
### 代码
[完整代码请点这里](https://www.luogu.com.cn/paste/81ojebyt)

---

## 作者：Exotic_sum (赞：1)

### 题意

给出一张无向图，找出一条经过所有点的路径，使其字典序最短。
### 思路

我们可以先建个无向图，可以用二维数组存图，也可以用链表或 $vector$ 存图。

然后以 $1$ 开始搜，为什么呢？因为要使字典序最小，以 $1$ 开始能保证是最小的。

搜的过程中用一个数组保存路径就行了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,a[100][100],d[100],f[100];
void out(){
	for(int i=1;i<n;i++)printf("%d ",d[i]);
	printf("%d\n",d[n]);
	exit(0);
}
void dfs(int x,int k){//k可以理解为深度 
	d[k]=x;//标记路径 
	if(k==n){ 
		if(a[x][1])out();
		else return;
	}
	for(int i=1;i<=n;i++){//枚举各个点 
		if(a[x][i]&&!f[i]){
			f[i]=1;
			dfs(i,k+1);
			f[i]=0;
		}
	}
	return;
}
int main(){
	cin>>n;
	while(cin>>x>>y)a[x][y]=a[y][x]=1;//用数组标记,用vector也行 
	f[1]=1;
	dfs(1,1);//从1遍历，因为1开始是字典序最小的 
} 
```


---

## 作者：xiezihanAKIOI (赞：1)

其实当我第一眼看到这道题，第一反应是 tarjian。毕竟数据很小。不用怕超时。但是我打到一半，发现没这么~~简单~~难。

这道题完全可以爆搜啊！

给大家讲讲我的思路。

首先，我们可以确定这是一个 $n$ 边形。并且他肯定会形成一个自环。这里我定义 $cnt$ 表示我们已经搜了 $cnt$ 条边，$u$ 表示我们现在已经搜到了边 $u$。所以我们只要判断当 `if (cnt==n+1&&u==1)` 也就是已经搜了 $n+1$ 条边，也就是搜完了。并且 $u$ 的值为 1。也就表示我们回到了起点。那不就表示我们搜到了环吗。

所以我们只需在爆搜的同时判断是否成环即可。

先给大家看看我的 dfs。

```cpp
bool dfs (int u, int cnt) {
	if (cnt == n + 1 && u == 1) return true;
	for (int i = 1 ; i <= n ; i++) {
		if (a[u][i] && !f[i]) {
			f[i] = 1;
			a[u][i] = a[i][u] = 0;
			scc[cnt] = i;
			if (dfs (i, cnt + 1)) return true;
            f[i] = 0;
			a[u][i] = a[i][u] = 1;
		}
	}
	return false;
}

```
这里我为什么要用 bool 呢，应为假如你已经搜到了环。但是你 return 之后他的上一层循环还在继续。此时他就会浪费许多时间并导致答案错误。那么我们就可以用 bool 优化一下。我这里用数组来保存答案，但是注意，我们在输出的时候不用输出到 $scc_n$。应为他最后一位是 1，应为他出现了自环，回到了原点。所以从 $scc_1$ 输出到 $scc_n-1$ 即可

代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, a[55][55], f[55], scc[55];

bool dfs (int u, int cnt) {
	if (cnt == n + 1 && u == 1) return true;
	for (int i = 1 ; i <= n ; i++) {
		if (a[u][i] && !f[i]) {
			f[i] = 1;
			a[u][i] = a[i][u] = 0;
			scc[cnt] = i;
			if (dfs (i, cnt + 1)) return true;
            f[i] = 0;
			a[u][i] = a[i][u] = 1;
		}
	}
	return false;
}

int main ()
{
    cin >> n;
    int x, y;
    while (cin >> x >> y) a[y][x] = a[x][y] = 1;
    cout << "1 ";
	dfs (1, 1);
	for (int i = 1 ; i < n ; i++) cout << scc[i] << ' ';
    return 0;
}
```


---

## 作者：YB_is_short (赞：0)

## ~~水题~~
用dfs+回溯遍历

字典序较小只需要从小到大枚举，判断每个点是否与当前点连通，且没有被遍历过，具体看代码

### [Code]
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,a[100][100]={},f[100]={},p[100]={};
void print()//输出
{
	for(int i=1;i<n;i++)printf("%d ",p[i]);
	printf("%d\n",p[n]);
	exit(0);
}
void dfs(int x,int k)//dfs遍历，x表示当前点编号，k表示当前到第几个
{
	p[k]=x;//记录编号，输出要用
	if(k==n)
	{
		if(a[x][1])print();//满足条件就输出
		else return;
	}
	for(int i=1;i<=n;i++)//遍历每个点
	{
		if(a[x][i]&&!f[i])//连通且没遍历过
		{
			f[i]=1;
			dfs(i,k+1);//往下遍历
			f[i]=0;//回溯
		}
	}
	return;
}
int main()
{
    
	scanf("%d",&n);
	while(cin>>x>>y)
	{
		a[x][y]=a[y][x]=1;//无向图
	}
	f[1]=1;dfs(1,1);//从第一个点开始遍历
	return 0;
}
```

---

## 作者：VIOLET__FOREVER (赞：0)

题目[传送门](https://www.luogu.com.cn/problem/P1718)
## 思路提供
这是一道简单的深搜题。

我们可以从第一个点开始搜索，如果我们再一次找到了第一个点，那么我们一定就能找到一个环，因为我们是从第一个点（即最小的点），开始搜索，所以我们所得到的数的字典序一定是最小的，所以我们只要记录下搜索时的每个点到最后的时候输出就可以了。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,a[55][55],be[55],ans[55],flag;
void dfs(int x,int cnt){
	if(flag) return ;//flag==1说明已经输出答案了，所以就不用继续找了，不然会死循环
	ans[cnt]=x;
	if(cnt==n){//个数达到
		if(a[x][1]==1){
			for(int i=1;i<=cnt;i++){
				cout<<ans[i]<<" ";
			}//输出答案，并给flag赋值
			flag=1;
		}
		return ;
	}
	for(int i=1;i<=n;i++){
		if(a[x][i] && be[i]==0){//一定是没有走过的值
			be[i]=1;
			dfs(i,cnt+1);//深搜模板，记得要还原现场
			be[i]=0;
		}
	}
}
int main(){
	cin>>n;
	while(cin>>x>>y) a[x][y]=a[y][x]=1;//由于不知道有几个数，所以用 while 读入，记得要记录双向的
	be[1]=1;//开始第一个点一定要标记为已走过
	dfs(1,1);
	return 0;
}
```


---


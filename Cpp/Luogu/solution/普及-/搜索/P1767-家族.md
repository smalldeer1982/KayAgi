# 家族

## 题目描述

在一个与世隔绝的岛屿上，有一个有趣的现象：同一个家族的人家总是相邻的（这里的相邻是指东南西北四个方向），不同的家族之间总会有河流或是山丘隔绝，但同一个家族的人不一定有相同姓氏。现在给你岛上的地图，求出岛上有多少个不同的家族。岛上的地图有 $n$ 行，每行有若干列，每个格子中要么是空格，表示大海，要么是 $\text{``{\tt *}''}$，表示河流或山丘，要么是小写字母，表示一户人家的姓氏。


## 说明/提示

### 数据范围及约定

- $10\%$ 的数据，$n≤1$。
- $30\%$ 的数据，$n≤10$。
- $100\%$ 的数据，$n≤100$，每一行最多不超过 $200$ 个字符。

NOI导刊 2010 普及（10）


## 样例 #1

### 输入

```
4
*zlw**pxh
l*zlwk*hx*
w*tyy**yyy
        zzl
```

### 输出

```
3```

# 题解

## 作者：Ksilver (赞：13)

看各位dalao都用dfs，本蒟蒻就来发一篇bfs，
其实这题~~的确不难~~着实很坑。
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;
const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};
string s;
int n,cnt,l[510],a[550][550];	//最大的坑点，必须开大点，本蒟蒻开210，只有40分
void bfs(int x,int y)
{
    queue< pair<int,int> >q;	//申请队列，用pair封装，方便存取，也可以用结构体
    q.push(make_pair(x,y));
    a[x][y]=0;
    while(!q.empty())
    {
        int cx=q.front().first;		
        int cy=q.front().second;	//取队首元素
        q.pop();	//队首元素出列
        for(int i=0;i<4;i++)
        {
            int nx=cx+dx[i];
            int ny=cy+dy[i];	//向四个方向搜素
            if(nx>=1 && nx<=n && ny>=1 && ny<=l[nx] && a[nx][ny]==1)
            {
                a[nx][ny]=0;	//赋0，避免重复
                q.push(make_pair(nx,ny));	//入队列
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    getline(cin,s);
    for(int i=1;i<=n;i++)
    {
        getline(cin,s);
        l[i]=s.length();
        for(int j=1;j<=l[i];j++)
        {
        	if(s[j-1]>='a' && s[j-1]<='z')
                a[i][j]=1;	//读入预处理，是字母为1，其余为0
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=l[i];j++)
        {
            if(a[i][j]==1)	//遇到字母，bfs
            {
                bfs(i,j);	
                cnt++;	//统计家族数
            }
        }
    printf("%d\n",cnt);
    return 0;
} 
```


---

## 作者：pikabi (赞：8)

~~看到5.7提交 1.4AC我一开始不免有点慌~~

然而仔细一看确实~~显然的~~联通块问题，所以暴力dfs就行了(这道不值得绿吧QAQ

（这些本地跑不停的代码最好在[~~你~~洛谷在线IDE](https://www.luogu.org/ide)跑或者用[freopen](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=freopen&rsv_pq=ec84efde0014f53a&rsv_t=b2b8B04y0VniNw5Bc1N9um5OguBOW1G9Agn0aJcTH%2BMbTL6QxrDVIwYxg6I&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=7&rsv_sug1=7&rsv_sug7=100&rsv_sug2=0&inputT=1843&rsv_sug4=1843&rsv_sug=2))跑一下)（

```cpp
#include <cstdio> 
#include <iostream>

using namespace std;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0}; 
int n, ans, len[1005], a[105][205], cnt, vis[105][205];

char ch;

void dfs(int x, int y){
	vis[x][y] = 1;
	for(int i = 0; i < 4; i++){
		int nx = dx[i] + x, ny = dy[i] + y;
		if(nx >= 1 && ny >= 1 && nx <= n && ny <= len[nx] && !vis[nx][ny] && a[nx][ny] != 32 && a[nx][ny] != 42 && a[nx][ny] != 13)//广搜基操
			dfs(nx, ny);
	}
}

int main(){
	scanf("%d",&n);
	getchar();
	while(scanf("%c",&ch) != EOF){//判停
		if(ch == '\n'){
			cnt++;
			continue;
		}
		else {
			len[cnt]++;//每一行长度
			a[cnt][len[cnt]] = ch;//用int存ASCII码
		}
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= len[i]; j++){
			if(!vis[i][j] && a[i][j] != 32 && a[i][j] != 42 && a[i][j] != 13){//ASCII码对照：32 " ";42 "*";13 "\n"(回车
				dfs(i, j);
				ans++;
			}
		}
	}
	printf("%d",ans);
} 
```

祝大家CSP　RP＋＋  *★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：Cambridge (赞：8)


这道题本蒟蒻觉得真的不难，明显是一道搜索题。懂搜索的大佬应该也会觉得简单吧。

我是把空格一并变成星号，这样会简便一点，如果当前位置不是星号，用搜索找到这一块家族，但是读者们要注意它的边界条件。

废话不多说，代码时间······

	#include<iostream>
	#include<cstring>
	#include<cstdio>
	#include<cmath>
    #include<string>
    #include<cstdlib>
    #include<algorithm>//文件头不多说
    using namespace std;
    int cx[8]={-1,1,0,0};
    int cy[8]={0,0,-1,1};//使当前位置上下左右的数组
    int a[200][200],n,m[10000],h,mm;
    int f[200][200];
    string st;
    void dfs(int x,int y)
    {
    if(x<1||x>n||y<1||y>m[x]||f[x][y]==0)return ;//边界条件使当前回到上一层
    f[x][y]=0;//如果不是边界条件，则当前位置属于当前家族，既然已经搜过，变为0
    for(int i=0; i<4; i++)dfs(x+cx[i],y+cy[i]);//上下左右搜
    }
    int main()
    {
    cin>>n;//读入n
    getline(cin,st);
    for(int i=1; i<=n; i++)
    {
        getline(cin,st);
        m[i]=st.size();//每一行的st.size()不一定相同，用m[i]存起来
          for(int j=1; j<=m[i]; j++)
          {
           if(st[j-1]>='a'&&st[j-1]<='z')f[i][j]=1;//转化成数字
          }
        }
        for(int i=1; i<=n; i++)
        {
            for(int j=1; j<=m[i]; j++)
            {
             if(f[i][j]==1){mm=m[i];dfs(i,j);h++;}//如果当前位置不是0，搜索
            }
        }
        cout<<h;//输出答案
        return 0;//结束程序
        }
喜欢的读者们留下个赞吧！


---

## 作者：塔罗兰 (赞：5)

某蒟蒻发现自己刷的绿题太少了,于是就发现了这道水绿题

这题难道不就是进阶版的[P1451 求细胞数量](https://www.luogu.org/problemnew/show/P1451)吗？

~~这么水的数据，顶多黄题~~

仔细读题就可以发现读入的字符并没有什么卵用,有用的只是长度和是否有人

然后就变成了一个求联通块数量问题,容易用~~大法师~~DFS求

```cpp
#include<bits/stdc++.h>
#define MAX 205
#define MIN 105
using namespace std;
int n,v[MIN][MAX],l[MIN],sum;//全局变量不用初始化清零
inline void dfs(int x,int y)//inline加速调用
{
	v[x][y]=0;//记录已经走过
	if(x+1<=n&&v[x+1][y])//判断是否有人以及超出边界
	dfs(x+1,y);//继续搜
	if(x-1>0&&v[x-1][y])
	dfs(x-1,y);
	if(y+1<=l[x]&&v[x][y+1])
	dfs(x,y+1);
	if(y-1>0&&v[x][y-1])
	dfs(x,y-1);
}
int main()
{
    string s;
    scanf("%d",&n);
    getline(cin,s);//这样能读掉n后面的回车
    for(int i(1);i<=n;++i)
    {
    	getline(cin,s);//读入包括空格的一整行
    	l[i]=s.size();//记录边界
    	for(int j(1);j<=l[i];++j)
    	if('a'<=s[j-1]&&s[j-1]<='z')
    	v[i][j]=1;//记录此处是否有人
	}
	for(int i(1);i<=n;++i)
	for(int j(1);j<=l[i];++j)
	if(v[i][j])
	{
		dfs(i,j);
		++sum;//总数++
	}
	printf("%d",sum);
}
```
注:听说bool数组和int所占空间一样还跑得慢,~~又因为本蒟蒻使用bitset不熟练~~,所以用int存v数组

---

## 作者：Stephzzz (赞：3)

在本题中，相邻状态指的是搜索某个家族的所有成员时，与当前成员相邻
的成员的位置，每个状态要记录的信息包括所处的行列值，这里需要注意
的是广度搜索只是完成了同一个家族成员的搜索，我们要求解的是家族数，
因此我们需要遍历所有的元素。

基本思路是：
对于每一个元素，如果该元素为小写字母，代表是一个姓氏，如果该位
置没有被搜索过，则家族数加一，然后使用广度优先搜索算法标记该家族
的所有成员为已访问。
```cpp
#include <iostream>
#include <string>
#include <queue>
using namespace std;

/************************************************************
广度优先搜索算法的基本思想：
1、对于初始状态入队，设置初始状态为已访问
2、如果队列不为空时，出队队头元素，否则跳到第5步
3、检查出队的元素是否为最终解，如果是则跳到第5步。
4、对于出队的元素，检查所有相邻状态，如果有效并且未访问，则将
   所有有效的相邻状态进行入队，并且设置这些状态为已访问，然后
   跳到第2步重复执行
5、检查最后出队的元素是否为最终解，如果是输出结果，否则说明无解

广度优先搜索是借助于队列这种数据结构进行搜索的，队列的特点是先
进先出（FIFO），通过包含queue这个队列模板头文件，就可以利用c++
的队列模板定义自己的队列了，队列的操作非常简单，主要有以下几个：
q.push() 入队操作
q.front() 取队头元素
q.pop() 队头元素出队
q.size() 获取队列的元素个数
q.empty() 判断队列是否为空，为空返回true，不为空返回false

广度优先搜索算法的关键是要搞清楚求解过程中每一步的相邻状态有哪些，
每个状态需要记录什么信息，在搜索过程中如何标记这些状态为已访问。
*************************************************************/

//定义队列元素的类型，QElement为结构类型，使用typedef可以定义一个新的类型名称，在程序中QElement就像int、float一样，作为一个数据类型的名称使用
typedef struct {
	int row;  //当前搜索的家族成员所处的行
	int col;  //当前搜索的家族成员所处的列
} QElement;

queue<QElement> q; //定义元素类型为QElement的队列q
string s[100];  //数组s用于记录输入数据
int visited[100][200]={0};  //visited用于记录每个元素是否访问过
int n,ans;  //ans用于记录发现的家族数
int movex[]={ 1, 0,-1, 0};  //数组movex表示与当前元素相邻的元素的行差值
int movey[]={ 0, 1, 0,-1};  //数组movex表示与当前元素相邻的元素的列差值

//函数bfs用于搜索包含某个元素（row行，col列）的所有家族成员，并且搜索过程中将所有家族成员标志为已访问
void bfs(int row,int col)
{
	int i,j,k;
	QElement e1,e2;
	
	e1.row=row;
	e1.col=col;
	q.push(e1);  //初始状态入队
	visited[row][col]=1;  //设置当前状态为已访问
	while (!q.empty())  //当队列不为空时，继续宽度优先搜索
	{
		e2=q.front();   //获取队头元素
		q.pop();  //队头元素出队（注意：c++的队列模板类中，获取队头元素并不会将该元素从队列中删除，需要使用pop函数删除该元素）
		for (k=0; k<4; k++)  //对于当前元素，检查上下左右四个方向的元素
		{
			i=e2.row+movex[k];
			j=e2.col+movey[k];
			//第i行第j列元素有效，并且该元素为小写字母，并且未访问过，则入队并且标记为已访问
			if (i>=0 && j>=0 && i<n && j<s[i].length() && s[i][j]>='a' && s[i][j]<='z' && visited[i][j]==0)
			{
				e1.row=i;
				e1.col=j;
				q.push(e1);
				visited[i][j]=1;
			}
		}
	}
}

int main()
{
	string s1,s2;
	int i,j,k;
	
	cin >> n;
	getline(cin,s1);  //先输入一行数据
	i=0;
	if (s1!="") s[i++]=s1; //检查第一行输入数据是否有效，如果有效，则接下来的循环从第二行开始输入（i=1），否则接下来从第一行开始输入（i=0）
	for (; i<n; i++)
	{
		getline(cin,s[i]);
	}
	
	ans=0;
	for (i=0; i<n; i++)
	{
		k=s[i].length();
		for (j=0; j<k; j++)
		{
			//遍历所有元素，如果某个元素为小写字母，并且未访问过，说明发现一个新的家族
			if (s[i][j]>='a' && s[i][j]<='z' && visited[i][j]==0)
			{
				ans++;  //家族数加一
				bfs(i,j);  //遍历该家族的所有成员并且将所有成员标记为已访问，以防止重复计算家族数
			}
		}
	}
	cout << ans;
}
```


---

## 作者：白烛葵 (赞：3)

这题是道很水的搜索题。。。

只不过是对边界的判定有点麻烦

然后，染色标记，ans++就行

可以用DFS和BFS轻松写过QWQ

这题考的是搜索中的基础——染色

# 说人话就是
## 无脑搜索加染色，不需要任何剪枝，设好边界就行
是不是很简单QWQ，马上就能切道绿题，是不是很激动

~~想强化搜索的人可以做状压DP题~~

好了，上代码QWQ
```
#include<bits/stdc++.h>
using namespace std;
int lxy[201][201],n,i,j,k,ans;
string tu[201];//用于毒瘤的字符串读入，因为纵向没有规定长度，所以把一行都读了
int ss(int x,int y)
{
    if(x+1<n&&lxy[x+1][y]==1){lxy[x+1][y]=0;ss(x+1,y);}
    if(x-1>=0&&lxy[x-1][y]==1){lxy[x-1][y]=0;ss(x-1,y);}
    if(y+1<tu[x].size()&&lxy[x][y+1]==1)
    {lxy[x][y+1]=0;ss(x,y+1);}//这里要设好边界
    if(y-1>=0&&lxy[x][y-1]==1){lxy[x][y-1]=0;ss(x,y-1);}
    //没写for循环，直接写出可以怎么走
    return 0;
}
int main()
{
    scanf("%d",&n);
    getline(cin,tu[0]);//读掉换行，getline要这么用
    for(i=0;i<n;i++)
    {
        getline(cin,tu[i]);//读入
        j=tu[i].size();//算长度
        for(k=0;k<j;k++)//开始枚举对lxy数组进行初始化
        if(tu[i][k]>='a'&&tu[i][k]<='z')//有家族标志就标记为1
        lxy[i][k]=1;
    }
    for(i=0;i<n;i++)
    for(k=0;k<tu[i].size();k++)//枚举各个点，开始染色
    if(lxy[i][k]==1)//有家族标记开始搜
    {
        lxy[i][k]=0;//抹除标记
        ss(i,k);//开搜，进行染色处理，抹除周围的标记
        ans++;//一个连通块，ans++；
    }
    printf("%d",ans);//输出答案，成功水了道绿题QWQ
    return 0;
}
```
这是很基础的搜索，想加固基础的可以用DFS和BFS各切一次

如果想加强剪枝能力和对搜索的理解，可以做一些状压DP题

但不管怎么说基础还是最重要的QWQ，所以认真写这道题吧

# 最后，请点赞，关注，~~投食，素质三连~~，谢谢支持QWQ

---

## 作者：a2358972980 (赞：3)

这道题是一道极其水的题。不明白为什么是绿题QWQ。这是一道经典的搜索，不过涉及了字符串的读入。
代码如下
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int map[105][205],n,len,sum,maxx;//定义，map用来存储 
char c[205];//读入是字符，用字符串 
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};//四个方向 
void dfs(int ,int );//emmm，习惯问题，我喜欢把函数移后。 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++)
	{
		gets(c);//输入 
		len=strlen(c);
		maxx=max(len,maxx);//字符串不一定一样长，搜索时用最长的 
		for(int j=0;j<len;j++)
		{
			if(c[j]>='a'&&c[j]<='z')
			map[i-1][j+1]=1; 
			else
			map[i-1][j+1]=0;//字符串转数字，更方便搜索 
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=maxx;j++)
		{
			if(map[i][j])//搜索条件 
			{
				dfs(i,j);//开始搜索 
				sum++;//搜索完一次后家族数加一 
			}
		}
	}
	printf("%d",sum);//输出 
	return 0;//结束 
}
void dfs(int x,int y)//搜索 
{
	map[x][y]=0;//直接更新map数组，方便，省空间，判定搜索条件时更好用，不会重复搜索 
	for(int i=0;i<4;i++)
	{
		int ax=x+dx[i];
		int ay=y+dy[i];//更新坐标 
		if(ax<1||ay<1||ax>n||ay>maxx||!map[ax][ay])
		continue;//小优化 
		dfs(ax,ay);//普通搜索 
	}
}
```

---

## 作者：zero_九霄 (赞：3)

蒟蒻第一次发题解呢。

一道挺水的搜索题。

难的地方要把它转为二维，再进行dfs。
也有点像连通。

贴上AC代码(~~蒟蒻第一绿~~)

	#include<iostream>
	#include<fstream> 
	using namespace std;
	int n,l[205],f,p,ans,f1,vis[205][205];
	string s;
	char st[205][205];
	void dfs(int x,int y) 
	{

		if (st[x][y]<'a'||st[x][y]>'z') return;//边界值判断
		if (vis[x][y]) return;//有标记则退出 
		vis[x][y]=1;//做标记
		dfs(x+1,y);//四个方向搜索
		dfs(x-1,y);
		dfs(x,y+1);
		dfs(x,y-1);
	}
	int main()
	{

		cin>>n;
		for (int i=0; i<=n; i++)
		{
			getline(cin,s);	//字符串读入
			l[i]=s.size();//存入每行长度
			if (i==0) continue;
			for (int j=0; j<l[i]; j++)
			{
				st[i][j]=s[j];
			}
		}
		for (int i=1; i<=n; i++)
			for (int j=0; j<l[i]; j++)
			{
				if (st[i][j]>='a'&&st[i][j]<='z'&&!vis[i][j])//判断是否是字母并未搜过
				{
					ans++;//统计答案
					dfs(i,j);
				}
			}
		cout<<ans;
		return 0;//The end
	}

---

## 作者：YanYou (赞：2)

## Solution
大多数人都想得到用 $dfs$ ,我就不多说了。

注意：题目中说**同一个家族的人不一定有相同姓氏**

## Code
```pascal
const dx:array[1..4] of -1..1=(-1,0,1,0);
const dy:array[1..4] of -1..1=(0,1,0,-1);
var n,i,j,ans:longint;
    s:string;
    a,f:array[0..110,0..210] of longint;
procedure dfs(x,y:longint);
var i,xx,yy:longint;
begin
  for i:=1 to 4 do begin
    xx:=x+dx[i]; yy:=y+dy[i];
    if (xx>0)and(xx<=n)and(yy>0)and(yy<=200)and(a[xx,yy]=1)and(f[xx,yy]=0) then begin
      f[xx,yy]:=1;
      dfs(xx,yy);
    end;
  end;
end;
begin
  readln(n);
  for i:=1 to n do begin
    readln(s);
    for j:=1 to length(s) do if s[j] in ['a'..'z'] then a[i,j]:=1;
  end;
  for i:=1 to n do
    for j:=1 to 200 do if (a[i,j]=1)and(f[i,j]=0) then begin
      inc(ans);
      dfs(i,j);
    end;
  writeln(ans);
end.
```



---

## 作者：曼恩薄荷 (赞：2)

这里用的是像我一样的蒟蒻比较习惯用的dfs联通块，基本方法可参考p1596湖计数（[来自美国人的问候](https://www.luogu.org/problemnew/show/1596 "来自美国人的问候")）。

首先说一下字符处理函数，c++给我们提供了多种函数，如基本的cin,scanf,gets,getline等，但这些函数都有一个共同的缺点，一旦读到空格就会停止，显然不适合本题。

这里就会用到我~~刚刚学会~~本题使用的getline(cin,字符串名)。

上代码：

蒟蒻风格不喜欢 ~~就不喜欢吧~~希望各位dalao不要喷。

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    int a[210][210],ax[4]={1,-1,0,0},ay[4]={0,0,1,-1},n,ans,m=-1;
    string s;
    void dfs(int x,int y)//建议先看完main函数的代码再来看。 
    {
        //printf("%d %d\n",x,y);
        a[x][y]=0;//搜过的直接清掉，防止重复搜。 
        for(int i=0;i<=4;i++)
        {
            int nx=x+ax[i],ny=y+ay[i];
            if(nx>=0&&nx<=n&&ny>=0&&ny<=m&&a[nx][ny]==1)//注意越界判定 。 
                dfs(nx,ny);//一个联通块全部搜完然后划掉。 
        }
    }
    int main()
    {
        scanf("%d",&n);
        getline(cin,s);//读入一个换行符，非常关键！！！要不 后面的字符串 会默认读上那个换行符，其实把n从0开始循环也可以。 
        memset(a,0,sizeof(a));//将图的初始值都设成0。 
        for(int i=1;i<=n;i++)//按行读入 。 
        {
            getline(cin,s);
            int len=s.size();
            m=max(len,m);//记下其中最长的一行的长度。 
            for(int j=0;j<=len-1;j++)//字符数组的下标都是从0开始 ，所以要-1s（膜法少年瑟瑟发抖。 
                if(s[j]>='a'&&s[j]<='z') a[i][j]=1;//如果这里有人家就赋成1。 
        }
        /*for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=m-1;j++)
            {
                printf("%d ",a[i][j]);
            }
            printf("\n");
        }*/
        for(int i=1;i<=n;i++)
            for(int j=0;j<=m;j++)//这儿也要从0开始循环哦。 
                if(a[i][j]==1) dfs(i,j),ans++;//找到没搜的联通块就开始搜,搜到的都清掉，就把ans++; 
        printf("%d",ans);
        return 0;
}
```

---

## 作者：Lin1043 (赞：1)

这道题本身就是一个普通的搜索题（用DFS和BFS都可以，我这里用的是DFS）

然而，关键的考察点在与字符串的读入和边界的处理

对于这道题目来说我个人觉得最好的方式应该是用getline+string的读入

如下
string ch[110]

getline(cin,ch[0]);

    for(int i=0;i<n;i++)

        getline(cin,ch[i]);

这样可以便于我们找到ch[i].size()以及接下来的操作

我们将每一个小写的字母存入我们的表中，这样省去了我们在搜索过程中对是否是字符的判别。

       for(int j=0;j<(int)(ch[i].size());j++)

         if(ch[i][j]>='a'&&ch[i][j]<='z')

           f[i][j]=1;

同时，我们可以将路径记录在当中，省去部分的空间。这非常的重要，如果没有这条就会WA。

在DFS的时候我们考虑一下几点1.对于每个x来说x>=0且x<n即是合法的2.对于每个y来说y>=0且y<lx即是合法的因为在lx以外的地方是不存在新的字母的

接下来就是普通的DFS了

```cpp
const int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
void dfs(int x,int y)
{
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx>=0 && nx<n && ny>=0 && ny<(int)(ch[nx].size()) && f[nx][ny] ){
            f[nx][ny]=0;//记录路径
            dfs(nx,ny);
        }
    }
    return ;
}
```
标程如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
int n,m,f[111][211],Max,ans;
string ch[111];
void dfs(int x,int y)
{
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx>=0 && nx<n && ny>=0 && ny<(int)(ch[nx].size()) && f[nx][ny] ){
            f[nx][ny]=0;
            dfs(nx,ny);
        }
    }
    return ;
}
int main()
{
    cin>>n;getline(cin,ch[0]);
    for(int i=0;i<n;i++){
        getline(cin,ch[i]);
        for(int j=0;j<(int)(ch[i].size());j++)
         if(ch[i][j]>='a'&&ch[i][j]<='z')
           f[i][j]=1;
    }
    for(int i=0;i<n;i++)
     for(int j=0;j<(int)(ch[i].size());j++)
       if(f[i][j])
            f[i][j]=0,dfs(i,j),ans++;
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：kczno1 (赞：0)

基础的广搜

···pascal





```cpp
const
fx:array[1..4] of longint=(1,-1,0,0);
fy:array[1..4] of longint=(0,0,1,-1);
//四个方向
var
 a:string;
 x,y:array[1..20000] of longint;
 b:array[0..101,0..201] of boolean;//该点能否访问，小写字母=true
 len:array[1..100] of longint;
 i,j,n,ans,l,r:longint;
procedure bfs;//用深搜如果深度太大就会爆栈，广搜用数组存，安全
var i,nx,ny:longint;
begin
 repeat
  inc(l);nx:=x[l];ny:=y[l];
  for i:=1 to 4 do
  if b[nx+fx[i],ny+fy[i]] then
  begin
   b[nx+fx[i],ny+fy[i]]:=false;
   inc(r);
   x[r]:=nx+fx[i];y[r]:=ny+fy[i];
  end;
 until l=r;
end;
begin  assign(input,'1.in');reset(input);
 readln(n);
 for i:=1 to n do
 begin
  readln(a);
  len[i]:=length(a);
  for j:=1 to len[i] do b[i][j]:=(a[j]>='a')and(a[j]<='z');
 end;
 for i:=1 to n do
 for j:=1 to len[i] do
 if b[i][j] then
 begin
  inc(ans);
  l:=0;r:=1;x[r]:=i;y[r]:=j;
  bfs;
 end;
 writeln(ans);
end.
```
```cpp

---

## 作者：origin_star (赞：0)

其实这道题考的应该是getline的使用，即对C++函数的熟悉程度，而且这道题由于luogu评测姬的奇特特性，不用getline函数基本是做不出来的.

我一开始把它当一道普通的灌水做，然后就直接炸掉。

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cctype>
using namespace std;
int n,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},ans,k[101];
char g[101][203],c;
bool vis[101][201];
void dfs(int x,int y)
{
    if(x<1 || y<1 || x>n || y>=k[x]) return;
    if(g[x][y]==' ' || g[x][y]=='*' || vis[x][y]) return;
    vis[x][y]=true;
    for(int i=0;i<4;++i){
        dfs(x+dx[i],y+dy[i]);
    }
}
int main()
{
    scanf("%d%c",&n,&c);
    for(int i=1;i<=n;++i){
        k[i]=1;
        scanf("%c",&g[i][k[i]]);
        while(g[i][k[i]]!=0x0a){
            ++k[i];
            scanf("%c",&g[i][k[i]]);
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=0;j<k[i];++j){
            if(!vis[i][j] && isalpha(g[i][j])){
                dfs(i,j);
                ++ans;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

然后，十个点全部WA。

由于在luogu中scanf和cin都不支持读入空白符，导致空格都被忽略掉。

改了一下读入之后就可以AC了。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cctype>
using namespace std;
int n,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},ans,k[101];
bool vis[101][201];
string g[101];
void dfs(int x,int y)
{
	if(x<1 || y<0 || x>n || y>=k[x]) return;
	if(g[x][y]==' ' || g[x][y]=='*' || vis[x][y]) return;
	vis[x][y]=true;
	for(int i=0;i<4;++i){
		dfs(x+dx[i],y+dy[i]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<=n;++i){
		getline(cin,g[i]);
		k[i]=g[i].size();
	}
	for(int i=1;i<=n;++i){
		for(int j=0;j<k[i];++j){
			if(!vis[i][j] && isalpha(g[i][j])){
				dfs(i,j);
				++ans;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

顺便说一下，大家不要直接复制代码，因为我的代码自带防伪。~~（逃）~~

---

## 作者：GZZHX (赞：0)

首先这道题是一道搜索题，看到没有Pascal的DFS解法，于是发一篇，









```cpp
var n,i,j,ans:longint;
    w:char;
    s:string;//每次读入的字符串；
    l:array[0..10000] of longint;
    a:array[0..1000,0..1000] of char;将字符串拆分后的数组
    b:array[0..1000,0..1000] of longint;//判断该点是否访问过的数组
procedure dfs(x,y:longint);
begin
  b[x,y]:=1;
  if (b[x-1,y]=0) and (a[x-1,y]>='a') and (a[x-1,y]<='z') and (x-1>0) then
     begin
       dfs(x-1,y);
     end;
  if (b[x+1,y]=0) and (a[x+1,y]>='a')  and (a[x+1,y]<='z') and (x+1<=n) then
     begin
       dfs(x+1,y);
     end;
  if (b[x,y+1]=0) and (a[x,y+1]>='a') and (a[x,y+1]<='z') and (y+1<=l[x]) then
     begin
       dfs(x,y+1);
     end;
  if (b[x,y-1]=0) and (a[x,y-1]>='a') and (a[x,y-1]<='z') and (y-1>0) then
     begin
       dfs(x,y-1);
     end;
end;
begin
  readln(n);
  fillchar(b,sizeof(b),0);
  for i:=1 to n do
      begin
        readln(s);
        l[i]:=length(s);//储存每次读入字符串的长度
        for j:=1 to l[i] do
            a[i,j]:=s[j];
     end;
  for i:=1 to n do
      for j:=1 to l[i] do
          begin
            w:=a[i,j];
            if (b[i,j]=0) and (w>='a') and (w<='z') then//注意，一定判断是否为小写字母，不然......
               begin
                 dfs(i,j);
                 inc(ans);累加答案
               end;
          end;
  writeln(ans);
end.

```

---


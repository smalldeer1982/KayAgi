# 绳子对折

## 题目描述

FJ 有一个长度为 $L$（$1 \le L \le 10,000$）的绳子。这个绳子上有 $N$（$1 \le N \le 100$）个结，包括两个端点。$FJ$ 想将绳子对折，并使较短一边的绳子上的结与较长一边绳子上的结完全重合，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1spqhchu.png)

找出FJ有多少种可行的折叠方案。


## 说明/提示

(可在 1,2,3,8 点处折叠)


## 样例 #1

### 输入

```
5 10
0 
10 
6 
2 
4
```

### 输出

```
4```

# 题解

## 作者：kkksc03 (赞：77)

枚举每个节，或者节与结点之间的中点，然后两边伸展，看结每一小段的长度是否一致。


---

## 作者：Alex_Wei (赞：71)

### 题解 P1881 【绳子对折】

枚举水题，纯属模拟

1. 枚举位置时的技巧:将长度 $l*2$，储存时将所有结的位置也$*2$，这样枚举时就可以以 $1$ 为跨度，不需要用 $double$，省去了很多麻烦

2. 判断这个位置是否可行:从对折点依次向两端枚举，遇到数值不同的两个位置（即一个点是结，另一个点不是结）即可判定不合法

3. 代码 ~~（码风应该还不错吧？）~~:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,p,r[20004],ans;
int main(){
	cin>>n>>l;
	for(int i=1;i<=n;i++)cin>>p,r[p*2]=1;
	for(int i=1;i<2*l;i++){//枚举位置
		int pd=1,s=0;//pd：是否可行，s为向两端扩张的长度
		while(i>=s&&i+s<=2*l){//是否越界
			if(r[i-s]!=r[i+s])pd=0;
			s++;
		}//枚举长度
		ans+=pd;
	}
	cout<<ans;
	return 0;
}
```

求赞(。-`ω′-)

---

## 作者：wonSSnow (赞：13)

### 这题就一点比较坑——就是两点之间的二分之一点要考虑！！！
还有就是这道题就是模拟，连double都不用开。

第一个循环判断整点对折，加一个相对应的check函数。

第二个循环判断二分之一点，加一个相对应的check2函数。
# code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,L,v[10001],a,ans=0;
inline bool check(int s){
	int x=s-1,y=s+1,sum=0;
	while(x>=0&&y<=L)
	{
		if(v[x]==1||v[y]==1) sum=1;
		if(v[x]==1&&v[y]==0||v[x]==0&&v[y]==1) return 0;
		x--,y++;
	}
	if(sum==0) return 0;
	return 1;
}
inline bool check2(int s){
	int x=s,y=s+1,sum=0;
	while(x>=0&&y<=L)
	{
		if(v[x]==1||v[y]==1) sum=1;
		if(v[x]==1&&v[y]==0||v[x]==0&&v[y]==1) return 0;
		x--,y++;
	}
	if(sum==0) return 0;
	return 1;
}
int main(){
	memset(v,0,sizeof(v));
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		v[a]=1;
	}
	for(int i=1;i<=L-1;i++)
		if(check(i)) ans++;
	for(int i=0;i<=L-1;i++)
		if(check2(i)) ans++;
	printf("%d",ans);
	return 0;
}

```
#### 码风应该还不错吧？

---

## 作者：AloneV (赞：9)

枚举每个节，或者节与结点之间的中点，然后两边伸展，看结每一小段的长度是否一致。两个for循环就行了，注意考虑从节点或节点中间对折
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,l,ans;
int a[100001];
int main()
{
    cin>>n>>l;
   for(int i=1;i<=n;i++)    {cin>>a[i];}
   sort(a+1,a+1+n);//先将所有节点排序
   for(int i=2;i<=n;i++)
   {
        int l=1,r=i;//设两个下标用来标记
        while ((l<=r)&&(a[l+1]-a[l]==a[r]-a[r-1]))//判断每一段是否相同   
    {
            l++;
        r--;//如果相同，继续判断
    }
        if(l>=r)    {ans++;}//如果下标重合或左边大于右边，方案数加一
   }
   for(int i=2;i<n;i++)//同理，只是这样是从节点中间考虑对折
   {
    int l=i,r=n;
    while ((l<=r)&&(a[l+1]-a[l]==a[r]-a[r-1]))   
    {
        l++;
        r--;
    }
    if(l>=r)    {ans++;} 
   }
   cout<<ans;
   return 0;
}

---

## 作者：Konnyaku_ljc (赞：6)

强烈谴责学校老师竟然来这里抄题当模拟赛的行为！！！  
但还是琢磨出来两种做法（在模拟赛的几年后……）  
话不多说——  
## 设mid为中点  
# First  
比较麻烦，就是数学公式，公式为——
```cpp
a[j]=a[2*i-j]或a[j]=a[2*i-j]
```
但是要从0到mid和从l到mid各来一遍，而且会算重一遍（由于篇幅原因，正确性请自己证明）。  
~~好吧，其实是我也不怎么会……~~
```cpp
#include<cstdio>
using namespace std;

int n,m,x,ans;
bool a[10002],f;//判断是否有数字和正确性

int main()
{
    
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++) scanf("%d",&x),a[x]=1;
    //如果这个地方有数字，设为1
    for(int i=1;i<=n/2;i++)
    {
        f=true;//重置
        for(int j=0;j<i;j++)
	{
	    if(a[j]!=a[2*i-j]){f=false;break;}
            //枚举是否符合公式
	}
        if(f){ans++;}//没被针对掉，ans++
        f=true;//重置
        for(int j=0;j<i;j++)
	{
	    if(a[j]=a[2*i-j]){f=false;break;}
            //枚举是否符合公式
	}
        if(f){ans++;}//没被针对掉，ans++
    }
    for(int i=n/2+1;i<=n;i++)
    {
        f=true;//重置
        for(int j=i+1;j<=n;j++)
	{
	    if(a[j]!=a[2*i-j]){f=false;break;}
            //枚举是否符合公式
	}
        if(f){ans++;}//没被针对掉，ans++
        f=true;//重置
        for(int j=i;j<=n;j++)
	{
	    if(a[j]!=a[2*i-j-1]){f=false;break;}
            //枚举是否符合公式
	}
        if(f){ans++;}//没被针对掉，ans++
    }
    printf("%d",ans-1);//上文说过，算重了一次，减掉
    return 0;//AC！！！
}
```
# Next  
好吧，还是枚举……这个代码短，但是跑的慢。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,ans,a[10005];
bool b;
int main()
{
    cin>>n>>x;
    for(int i=1;i<=n;i++){cin>>y,a[y]++;}
    //输入，与上文相同
    for(double i=0.5;i<x;i+=0.5)
    //每0.5枚举一次对称点，但是取值为整数
    {
        int r,l;//左右顶点
	if((int)i<i){r=i-0.5,l=i+0.5;}
        //如果比整值大，就是n.5，变为最近的整数
        else{r=l=(int)i;}//否则，取自己
	b=true;//重置
	while(r>=0&&l<=x)//在图的范围内时
	{
            if(a[r]!=a[l]){b=false;}
            //不对称，针对掉
            //当然也可以加break，快了1ms
	    r--,l++;//左移一单位，右移一单位
	}
	if(b){ans++;}//没有针对掉，ans++
    }
    cout<<ans;//输出
    return 0;//完美AC
}
```
### 谢谢观赏

---

## 作者：TheUltimateLaw (赞：6)

这题题解好少啊。。。。来争取凑个前三。。

作为一个蒟蒻，这题我是WA了一回的。。。。。

但它其实并不难。

大体的思路是这样的：选取一个点，然后依次判断离它角标距离相等的的两个节点是不是可以重合，直至其中一边没有点，

或者说两个节点不可以重合。

因为我们一定要满足离它最近的两个节点的距离是一样的，所以如果这个点不是节点的话，它一定是一段绳子的中点。

好，解决了基础问题，现在具体分析一下数据：

发现它节点数只是个三位数。。。。。

那我们还用担心什么？手动滑稽@

直接枚举之！

上代码！（我做的时候也参照了一下前两位写题解的大犇的思路，这导致了我的代码与其中一位差别好像不是太大。。。。）



        

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define inf 2147483647
#define RE register
using namespace std;
inline int read(){
    int misaka=0,mikoto=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')
            mikoto=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        misaka=misaka*10+(int)(c-'0');
        c=getchar();
    }
    return misaka*mikoto;
}
int n;
int l;
int d[105]={0};
int fa=0;
double zuobian[105];
double youbian[105];
int zuozhi=0;
int youzhi=0;
int main(){
    n=read();
    l=read();
    for(int i=1;i<=n;i++){
        d[i]=read();
    }
    sort(d+1,d+n+1);
    for(double i=0.5;i<l;i+=0.5){  //
        zuozhi=0;
        youzhi=0;
        memset(zuobian,0,sizeof(zuobian));
        memset(youbian,0,sizeof(youbian));
        for(int j=1;j<=n;j++){
            if(d[j]<i){
                zuozhi++;
                zuobian[zuozhi]=i-d[j];
            }
            if(d[j]>i){
                youzhi++;
                youbian[youzhi]=d[j]-i;
            }
        }
        int jishu=0;
        sort(zuobian+1,zuobian+1+zuozhi);
        sort(youbian+1,youbian+1+youzhi);
        for(int b=1;b<=min(zuozhi,youzhi);b++){
            if(zuobian[b]==youbian[b])
                jishu++;
            else break;
        }
        if((jishu==zuozhi)||(jishu==youzhi))
            fa++;
    }
        cout<<fa<<endl;
    return 0;
}

```

---

## 作者：yagyagyag (赞：5)

# 这题本身很水，但有一个很坑的地方，就是非整数点也要考虑
扫了一下题解，好像神犇都是用 +0.5  两个check()函数 之类的方法解决，这里我提供另外一个算法

# *2

把位置，长度都*2,这样原来如果是小数(当然小数部分一定是0.5)，现在的答案就会变为整数，处理的时候就会方便

首先标记节点位置
```cpp
for (int i=1;i<=n;i++){
		int x;
		cin>>x;
		x*=2;//注意这里要*2 
		used[x]=1;
	}
```


只要一个check()
```cpp
bool check(int l,int r,int mid)
{
	while (l>=0 && r<=L){
		while (!used[l]) l--;
		while (!used[r]) r++;
		if (l>=0 && r<=L){
			if (abs(l-mid)!=abs(r-mid)) return 0;
			l--;r++;
		}
	}
	return 1;
}
```
类似于快排，固定好边界，往左找节点，往右找节点，最后再判断一下边界，计算与mid的距离。如果不相等直接return 0，最后函数结尾return 1，表示该位置可行

然后是穷举

```cpp
	for (int i=1;i<L;i++){
		int l=i-1,r=i+1;
		if (check(l,r,i) && i/2<L/2/*这里要注意，因为答案*2，所以还要判断这个点在原来的轴上是否存在*/){
			ans++;
		} 
	}
```
最后就是输出答案

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,L;
bool used[20005];
bool check(int l,int r,int mid)
{
	while (l>=0 && r<=L){
		while (!used[l]) l--;
		while (!used[r]) r++;
		if (l>=0 && r<=L){
			if (abs(l-mid)!=abs(r-mid)) return 0;
			l--;r++;
		}
	}
	return 1;
}
int main()
{
	cin>>n>>L;
	L*=2;
	for (int i=1;i<=n;i++){
		int x;
		cin>>x;
		x*=2;//注意这里要*2 
		used[x]=1;
	}
	
	int ans=0;
	for (int i=1;i<L;i++){
		int l=i-1,r=i+1;
		if (check(l,r,i) && i/2<L/2/*这里要注意，因为答案*2，所以还要判断这个点再原来的轴上是否存在*/){
			ans++;
		} 
	}
	cout<<ans<<endl;
	return 0;
 } 
```



---

## 作者：Right (赞：3)

>>其实这题看到绳子长度如此之短，我们很容易就想到暴力枚举
>>与楼下不同，我的枚举是简洁的纯暴力
>>可能数据水，都0ms能过
>>就是每个节点向两边扩展
具体看代码：

```cpp
#include <cstdio>
int i,l,n,ans,left,right;
bool ton[10008]; >>记录绳子上 有没有节点
int main()
{
    for (scanf("%d%d",&n,&l),i=1; i<=n; ++i) scanf("%d",&ans),ton[ans]=1; ans=0; >>重复利用变量
    for (double i=0.5; i<l; i+=0.5){ >>此题一大坑点，要0.5长度的枚举
        if ((int)i<i) left=i-0.5,right=i+0.5; >>当然节点都是整数啦
        else left=right=(int)i; bool gg=true; >>判断变量not gg
        while (left>=0&&right<=l){
            if (ton[left]!=ton[right]){gg=false; break;} >>向两端扩展判断，不符合就剪枝
            left--; right++;
        }
        if (gg) ans++; >>全部符合方案数++
    }
    printf("%d",ans); >>输出
} //Right
```

---

## 作者：Together_ (赞：2)

这是一道模拟题。



但是要注意：**两点之间二分之一的位置也要算！**

左边从第 $l$ 个结点开始 右边从第 $r$ 个结点开始，判断左边的结点距离 $m$ 的长度与右边的结点距离 $m$ 的长度是否相同。

核心代码：

```cpp
bool check(int l, int r, double m){
	while(l >= 1 && r <= n)
		if(m-a[l--] != a[r++]-m) return false;
	return true; 
} 

```

完整代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, ans, l, a[105];

bool check(int l, int r, double m){
	while(l >= 1 && r <= n)
		if(m-a[l--] != a[r++]-m) return false;
	return true; 
} 

int main(){
	cin>>n>>l;
	for(int i=1; i<=n; i++) cin>>a[i];
	sort(a+1, a+1+n); 
	for(int i=2; i<=n; i++){
		if(check(i-1, i, (a[i-1]+a[i])/2.0)) ans++;
		if(i!=n)
			if(check(i-1, i+1, a[i])) ans++;
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：SevenDawns (赞：2)

很奇迹，\_Pascal\_在这道题居然没有题解，so本蒟蒻为Pascal党来写一篇题解了.


这道题其实很考你的细心和差错能力（作为粗心的我，我就交了3遍才过）。

就是暴力搜索（这里绳子的长度是**1<= L <= 10,000**，不用担心会超时.)

然后这道题的大坑就是：一定一定要**0.5**长度的枚举，否则会有答案会漏掉。


最后附上\_Pascal\_代码（就是有点长）


```cpp
var l,n,i,j,k,s:longint;
    t:extended;  //因为是0.5长度的枚举，所以必须用实数类型。
    bl:boolean; //后面判断用。
    sh:array[0..100000] of longint; //此处开数组必须要开0，模拟绳子。
begin
  read(n,l);
  for i:=1 to n do
    begin
      readln(k);
      inc(sh[k]); //标记绳子上的节点。
    end;
  k:=0; //重复利用变量。
  for i:=1 to l*2-1 do
    begin
      bl:=true;
      t:=i*0.5; //枚举折绳子的点
      if t<=l/2 then  //要分是否在绳子的一半以内，可以更快，但代码会更长。
        begin
          k:=trunc(t);
          for j:=0 to k do
          if ((sh[j]=1)and(sh[trunc(t*2)-j]=0))or((sh[j]=0)and(sh[trunc(t*2)-j]=1)) then //判断节点是否一一对应。
            begin
              bl:=false;
              break;
            end;
          if bl then inc(s); //判断
        end
      else //同样。
        begin
          k:=trunc(t)+1;
          for j:=k to l do
          if ((sh[j]=1)and(sh[trunc(t*2)-j]=0))or((sh[j]=0)and(sh[trunc(t*2)-j]=1)) then
            begin
              bl:=false;
              break;
          end;
          if bl then inc(s);
       end;
    end;
  writeln(s); 
end.
```

---

## 作者：封禁用户 (赞：1)

[题目](https://www.luogu.com.cn/problem/P1881)

为了避免小数，先把绳子的长度和每个结点都$\times2$，然后枚举每个折点，看看每个有结的点折过去对应的是否还是一个结，若不是就退出循环。如果折过去的点对应的数大于了绳的长度就继续看下一个有结的点；如果折过去的点对应的数小于零就退出循环

提示：要把结的位置排序

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l;
int a[20005],num[10005];//num是结的位置在哪，a是有哪些位置有结
int ans;
int main()
{
	cin>>n>>l;
	l=l*2;
	for(int i=1;i<=n;i++)
	{
		cin>>num[i];
		num[i]=num[i]*2;
		a[num[i]]=1;//记录
	}
	sort(num+1,num+n+1);//排序
	for(int i=1;i<l;i++)//注意是小于l，因为头尾不能折
	{
		int s=1,ok=1;//ok标记一下
		while(i+i-num[s]>=0&&s<=n)//i+i-num[s]是求它折过去的点对应的数
		{
			if(i+i-num[s]>l)
			{
				s++;
				continue;
			}
			if(a[i+i-num[s]]==1)
			{
				s++;
				continue;
			}
			ok=0;
			break;//不符合条件
		}
		if(ok==1)
			ans++;//符合条件
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：_Aoi_ (赞：1)

### 骗分方法
```cpp
cout<<n-1;
```

![](https://cdn.luogu.com.cn/upload/image_hosting/x1a2xlhn.png)
### 思路

模拟，随便找一个点对折，判断对折后的点是否重合

### 注意
 - 地址乘上${2}$，就不用开${double}$了
 - 数组大小
 
### code
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,l,a[10001],xian[200001],ans=0;
int main()
{
	memset(xian,0,sizeof(xian));//初始化 
	cin>>n>>l;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		xian[2*a[i]]=1;//乘2 
	}
	for(int i=1;i<l*2;i++)//这也要乘2 
	{
		int x=0,jia=1;
		while(i>=x&&i+x<=l*2)
		{
			if(xian[i-x]!=xian[i+x])//判断对折后的点 
			{
				jia=0;
				break;//节省时间 
			}
			x++; 
		}
		ans+=jia;
	}
	cout<<ans;
	//cout<<n-1; 骗分 
	return 0;
}
```


---

## 作者：李至擎 (赞：1)

[点我看题](https://www.luogu.com.cn/problem/P1881)

思路：因为 $n\le100$ ，所以我们可以考虑枚举对折点。

方法：从头开始枚举对折点，然后枚举距离，左右同时判断是否相同，直到碰到边界。

小技巧：由于找到的中点会有分数存在，所以我们可以在处理时将数据乘2，避免开double。

普通代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,num[20005],ans,p;//n,l如题，num数组存位置，ans是答案，p是临时变量
int main()
{
	cin>>n>>l;//输入
	for(int i=1;i<=n;i++)
	{
		cin>>p;
		num[p*2]=1;//位置乘2存，避免小数
	}
	for(int i=1;i<l*2;i++)//不用枚举左右端点（因为一定不行），即从1枚举到二倍l
	{
		int ok=1;//判断标志
		for(int j=1;i-j>=0&&i+j<=2*l;j++)//枚举距离，判断是否超过边界
		{
			if(num[i-j]!=num[i+j])//不相同
			{
				ok=0;//不能以i为折叠点
				break;//退出循环
			}
		}
		if(ok)ans++;//如果可行，答案+1
	}
	cout<<ans;//输出答案
	return 0;//圆满结束
}
```


---

## 作者：qwaszx (赞：1)

来一发哈希

把有结的地方看成1，没结的地方看成0，那么就是求对于每一个位置i,它的前缀和后缀是否是回文串

这样子就可以哈希了

听说还可以manacher但是我不会啊qwq

因为原来是0,1那么我们就映射到1,2

一个串是回文串那么它翻转过来哈希值不变所以可以借助哈希值判断

做一个前缀哈希和一个后缀哈希

$h1[i]=h1[i-1]*3+a[i],h2[i]=h2[i+1]*3+a[i]$

取值的时候$h1(l,r)=h1[r]-h1[l-1]*3^{r-l+1},h2(l,r)=h2[l]-h2[r+1]*3^{r-l+1}$

这样即可$O(1)$判断了

可以适用于$n,l\leq 1000000$~~如果哈希不被卡的话~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
unsigned long long h1[20000],h2[20000],pw[20000];
int a[20000],n,l,ans;
unsigned long long geths1(int l,int r){return h1[r]-h1[l-1]*pw[r-l+1];}
unsigned long long geths2(int l,int r){return h2[l]-h2[r+1]*pw[r-l+1];}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	n=getin(),l=getin()+1;//l+1方便处理
	for(int i=1;i<=n;i++)a[getin()+1]=1;
	pw[0]=1;
	for(int i=1;i<=l;i++)h1[i]=h1[i-1]*3+a[i]+1,pw[i]=pw[i-1]*3;//预处理3的幂
	for(int i=l;i>=1;i--)h2[i]=h2[i+1]*3+a[i]+1;
	for(int i=2;i<l;i++)//端点不能对折
	{
		if(geths1(1,i)==geths2(1,i))ans++;
		if(geths1(i,l)==geths2(i,l))ans++;
	}
	if(geths1(1,l)==geths2(1,l))ans++;//最后补上整条绳子对折
	cout<<ans<<endl;
}
```

---

## 作者：Randyhoads (赞：1)

这道题竟然没有发现对折点不一定是整数位置的点。。。。。。

这道题直接暴力枚举就可以了，因为数据不大，而且满足条件的点不是小数部分为0.5的点就是整数点，所以一个循环语句

枚举这个绳子上的所有点，因为这个点会把绳子分成两半，就可以用两个数组来记录结离对折点的距离，全部找完后，排序一遍，

一个又一个的比较，因为要一一对应所以只要当前的两个点相对于对折点不等，就说明比较结束，当前相等的数量如果等于右边节点或

左边节点那么就是可行的方案





```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read()
{
    int f=1,x=0;
    char ch;
    do{
      ch=getchar();
      if(ch=='-')
         f=-1;
    }while(ch<'0'||ch>'9');
    do{
       x=x*10+ch-'0';
       ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
```
}//快读


    
    
    

```cpp
int n,l;
int a[201];
double m[201];
double m2[201];
int topa=0;
int topb=0;
int ans=0;
int main()
{
    n=read();
    l=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    sort(a+1,a+n+1);
    for(double i=0.5;i<l;i+=0.5)
    {
        topa=0;
        topb=0;
        memset(m,0,sizeof(m));
        memset(m2,0,sizeof(m2));//每次把记录节点相对位置的数组清空
        for(int j=1;j<=n;j++)
        {
            if(a[j]<i)
            {
                ++topa;
                m[topa]=i-a[j];
            }
            if(a[j]>i)
            {
                ++topb;
                m2[topb]=a[j]-i;
            }
        //记录每个节点相对对折点的位置
        }    
        int cs=0;
        sort(m+1,m+topa+1);
        sort(m2+1,m2+topb+1); //排序
        for(int i=1;i<=min(topa,topb);i++)//找重合的点
        {
            if(m[i]==m2[i])
                cs++;
            else break;
        }
        if(cs==topa||cs==topb)
        { 
            ans++;
            //cout<<i<<endl;
        }
    }
    cout<<ans<<endl;
}
```

---


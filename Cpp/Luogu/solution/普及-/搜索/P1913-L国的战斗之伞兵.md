# L国的战斗之伞兵

## 题目背景

L 国即将与 I 国发动战争！！


## 题目描述

为了在敌国渗透作战，指挥官决定：派出伞兵前往敌国！然而敌国的风十分强烈，能让伞兵在同一高度不停转悠，直到被刮到一个无风区……（可怜的小兵）


## 说明/提示

数据范围：

$1 \leq n \leq 1000$，$1 \leq m \leq 1000$。

## 样例 #1

### 输入

```
5 5
rrrrr
rdddr
rroll
uuuuu
uuuuu
```

### 输出

```
19```

# 题解

## 作者：Angel_Virus (赞：28)

其实这题很简单，找对方法是关键。

找到无风的o点，然后开始推路径，然后将能到的点设为true，最后统计TRUE的个数就AC




   
      
 
    
```cpp
#include<iostream>
using namespace std;
int i,j,n,m,num;
char a[1002][1002];
bool b[1002][1002];
void gui(int i,int j)   //推路径
{  b[i][j]=true; //将这点记为true
  if(a[i+1][j]=='u') gui(i+1,j);
  if(a[i-1][j]=='d') gui(i-1,j);
  if(a[i][j+1]=='l') gui(i,j+1);
  if(a[i][j-1]=='r') gui(i,j-1);
}
int main()
{
   //freopen("Lsan.in","r",stdin);
   //freopen("Lsan.out","w",stdout);
   cin>>n>>m;
   for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j];
   for(i=1;i<=n;i++) for(j=1;j<=m;j++)
      if(a[i][j]=='o') gui(i,j);  //如果是无风点，则开始推路
     for(i=1;i<=n;i++) for(j=1;j<=m;j++) if(b[i][j]) num++; //统计个数
    cout<<num<<'\n'; //个人习惯，喜欢打换行符
 //fclose(stdin);fclose(stdout);
 //system("pause");
 return 0;   
}
```

---

## 作者：Sea_Level (赞：10)

这道题还是比较简单的，只要用搜索就可以了。我用的是深搜。
### 思路：
从o点开始搜索路径，这样可以减少一些不必要的搜索。将能到的点赋值为1，之后在主函数里计算答案。

上代码！

```cpp
#include<iostream>
using namespace std;
int n,m,ans=0,cnt[1010][1010];//n和m不用说了，ans是答案（放伞兵的点数），cnt是用来记录这个点是否能到达。
char a[1010][1010];
void dfs(int i,int j){//深搜函数
	cnt[i][j]=1;//记录为1
	if(a[i-1][j]=='d'){//上面的点是否刮南风  
		dfs(i-1,j);
	}
	if(a[i+1][j]=='u'){//下面的点是否刮北风
		dfs(i+1,j);
	}
	if(a[i][j+1]=='l'){//左面的点是否刮西风
		dfs(i,j+1);
	}
	if(a[i][j-1]=='r'){//右面的点是否刮东风
		dfs(i,j-1);
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='o'){//从无风点开始搜索
				dfs(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(cnt[i][j]==1){//统计能到达的点的个数
				ans++;
			}
		}
	}
	cout<<ans<<endl;//愉快输出
	return 0;//拜拜！
}
```

祝大家早日AC！


---

## 作者：Ca1JH (赞：8)

这道题一开始我是打算一个个点去判断是否可行的，显然代码难打，还容易TLE，完全不符合这道题“普及-”的难度。所以为何不从无风点四周找起来呢？

因为有很多无风点，所以判断四周是个重复的工作，就可以使用递归来进行深搜。

不多说了，详细注释代码里有：

```c

#include<bits/stdc++.h>
using namespace std;
long long n,m,ans;//其实这题的范围不用longlong，个人习惯不会超时就用longlong 
char sa[1005][1005];
bool flag[1005][1005];
void dfs(long long a,long long b)
//深搜
{
    if(sa[a-1][b]=='d'&&a-1>=1)//是上方时判断是否越界
    {
        flag[a-1][b]=1;
        dfs(a-1,b);
    }
	/*注意，这不能打else*/if(sa[a+1][b]=='u'&&a+1<=n)//是下方时判断是否越界
    {
        flag[a+1][b]=1;
        dfs(a+1,b);
    }
    /*这也不可以*/if(sa[a][b+1]=='l'&&b+1<=m)//是右边时判断是否越界
    {
        flag[a][b+1]=1;
        dfs(a,b+1);
    }
    /*同上*/if(sa[a][b-1]=='r'&&b-1>=1)//是左边时判断是否越界
    {
        flag[a][b-1]=1;
        dfs(a,b-1);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    { 
        for(int j=1;j<=m;j++)
        {
			cin>>sa[i][j];
		}    
	}
	//输入 
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=m;j++)
    	{
			if(sa[i][j]=='o')
            {
			    dfs(i,j);//开始深搜 
				ans++;//注意无风点本身也是一个答案 
			}
		}       
	}    
    for(int i=1;i<=n;i++)
    {
		for(int j=1;j<=m;j++)
		{
			if(flag[i][j]==1)
			{
				ans++;//遍历一遍，找出可行的降落点 
			}  
		}     
	} 
    cout<<ans;//输出 
    return 0;//完美结束 
}


```


---

## 作者：Fuko_Ibuki (赞：4)

这题是个用来练二维并查集的好题啊.  
搜索也是可以做的,但是用搜索总感觉不是很舒服,于是我用了并查集.  
和一维并查集一样,如果从这个格子能够到达与它相邻的四个方向的格子之一,就把这个格子连到它所能够到达的格子上面,最后查找有多少个格子的父亲是$'o'$即可.  
加个路径压缩就可以通过这道题了.
```cpp
#include<bits/stdc++.h> //Ithea Myse Valgulious
using namespace std;
#define yi first
#define er second
typedef pair<int,int> node;//用pair存储一个位置.
char c[1010][1010];
int n,m;node fa[1010][1010];//每个位置指向的位置.

node find(node x){
return fa[x.yi][x.er]==x?x:fa[x.yi][x.er]=find(fa[x.yi][x.er]);
}//路径压缩和一维是类似的.

int main(){
int i,j;
scanf("%d%d",&n,&m);
for (i=1;i<=n;++i) for (j=1;j<=m;++j) fa[i][j]=node(i,j);//初始化
for (i=1;i<=n;++i) scanf("%s",c[i]+1);
for (i=1;i<=n;++i){
  for (j=1;j<=m;++j){
    switch(c[i][j]){
      case 'u': fa[i][j]=find(fa[i-1][j]); break;
      case 'l': fa[i][j]=find(fa[i][j-1]); break;
      case 'd': fa[i][j]=find(fa[i+1][j]); break;
      case 'r': fa[i][j]=find(fa[i][j+1]); break;
      }
      /*
      根据4个方向判断它的父亲.这里不直接连接到对应的格子的父亲的话会MLE.
      比如说
      5 5
      rrrrd
      dllll
      rrrrd
      dllll
      rrrro
      这个数据扩大到1000 1000就炸了.
      */
    }
  }
int ans=0;
for (i=1;i<=n;++i){
  for (j=1;j<=m;++j){
    node f=find(node(i,j));
    ans+=c[f.yi][f.er]=='o';
    }
  }printf("%d",ans);
}
```

---

## 作者：GaryH (赞：2)

# 蒟蒻来发题解啦！

### 看见dalao都用的DFS，那我来发一波DP.

首先解释一下题意:给定风向地图，有多少个点满足最后可以吹到无风点（或本来就是无风点）.

那我们可以用**DP**来求解.

我们定义一个dp[1001][1001]代表当前的店是否能被吹向无风点.

那只要在循环中判断当前点是什么风向，再跟据风向转移状态即可.

但要注意，这种方法不是一遍就能把所有的点正确判断的，所以我们还需要多次DP进行求解.

**Code**:
(有解释)

```
#include<bits/stdc++.h>
using namespace std;
bool dp[1001][1001];
char maps[1001][1001];
int n,m,ans,last;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>maps[i][j];//输入地图
			if(maps[i][j]=='o')dp[i][j]=1;//先把无风点标记成1 
		}
	}
	while(1){last=ans;//把上次计算的ans存在last里，方便之后退出while循环 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(maps[i][j]=='r')if(j+1<=m)dp[i][j]=dp[i][j+1];
				if(maps[i][j]=='l')if(j-1>=1)dp[i][j]=dp[i][j-1];
				if(maps[i][j]=='u')if(i-1>=1)dp[i][j]=dp[i-1][j];
				if(maps[i][j]=='d')if(i+1<=n)dp[i][j]=dp[i+1][j];
				//这些是核心代码，根据风向进行状态转移
			}
		}
		ans=0;
		//先把ans清零 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(dp[i][j])ans++;
				//如果标了1就统计 
			}
		}
		if(last==ans){
			cout<<ans;
			return 0;
			/*这里解释一下为什么这样写.
			一遍遍DP后，如果已经是最终答案，那再DP一边答案就应该不变.
			那就用last存上次的答案，在DP完一遍后跟此次ans进行比较，如果不变就可以确定是最终答案了. 
			*/ 
		}
	}
}
```
那题解就结束了，各位再见！

---

## 作者：wangxuye (赞：2)

~~特别申明：本人爱好深搜~~

这题嘛，对每个点的搜一遍，能够到达无风点的都加起来，记忆化一下就行了，不要忘了判边界以及来回走的点就行了

下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int size=1000;
int n,m;

char ch[size+10][size+10];
int yes[size+10][size+10];   //3为正在访问，2为可到达，1为不可到达，0为不知道 

bool dfs(int x,int y)
{
	if(yes[x][y]>0) return yes[x][y]==2;
	yes[x][y]=3;             //一定要记得标正在访问，否则全TLE或MLE
	char chr=ch[x][y];
	int xx=x,yy=y;
	if(chr=='o')             //到达无风点 
	{
		yes[x][y]=2;
		return true;
	}
	if(chr=='u') xx--;
	if(chr=='d') xx++;
	if(chr=='r') yy++;
	if(chr=='l') yy--;
	if(xx<=0||xx>n||yy<=0||yy>m) return false;  //出界
	if(dfs(xx,yy))
	{
		yes[x][y]=2;
		return true;
	}
	else
	{
		yes[x][y]=1;
		return false;
	}
	return 0;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) cin>>ch[i][j];
	memset(yes,0,sizeof(yes));   //初始化为‘0’——不知道
	int cnt=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			bool flag=dfs(i,j);  //能否到达 
			if(flag) cnt++;
		}
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：陈年风褛 (赞：2)

dfs可解，要注意可能一开始就落在“o”上，这也是一个可行的点
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum=0,n,m;
char a[1001][1001];
int di[4]={-1,1,0,0}; 
int dj[4]={0,0,-1,1}; //规定四个方向
char d[4]={'d','u','r','l'};
void search(int line,int row)
{
    for(int i=0;i<4;i++)
    {
    	if(a[line+di[i]][row+dj[i]]==d[i]) //如果找到正好满足条件的点，也就是可以到达无风区的点，
    	{
    		sum++; //答案+1
    		search(line+di[i],row+dj[i]); //以当前点为基点继续搜索，标准dfs...
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
    cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
    if(a[i][j]=='o') //找到一个无风点就开始搜索
    {
     sum++; //无风点也是一个可行点，注意答案要+1
     search(i,j); //开始搜索
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：ezoiHQM (赞：2)

这道题其实是一道非常简单的广搜题，把所有无风带入队，广搜时判断这个点的上下左右方能否到达这个点，如果可以到达就将其入队

```cpp
#include<cstdio>
#include<queue>
using namespace std;
char ch[1010][1010];
int n,m,ans,vis[1010][1010];
struct place{
    int x,y;
    place(int a,int b){
        this->x=a;
        this->y=b;
    }
};
queue<place>q;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%s",ch[i]+1);
        for(int j=1;j<=n;j++)
            if(ch[i][j]=='o'){
                q.push(place(i,j));//如果这个点为无风带，就将这个点入队 
                vis[i][j]=1;
            }
    }
    while(!q.empty()){
        place a=q.front();
        q.pop();
        ans++;
        if(ch[a.x+1][a.y]=='u'&&!vis[a.x+1][a.y]){
            q.push(place(a.x+1,a.y));
            vis[a.x+1][a.y]=1;
```
}//判断这个点的下方点是否为u，如果为u即下方点可到达这个点，就将下方点入队
        if(ch[a.x-1][a.y]=='d'&&!vis[a.x-1][a.y]){

            q.push(place(a.x-1,a.y));

            vis[a.x-1][a.y]=1;

}//判断这个点的上方点是否为d，如果为d即上方点可到达这个点，就将上方点入队

        if(ch[a.x][a.y+1]=='l'&&!vis[a.x][a.y+1]){

            q.push(place(a.x,a.y+1));

            vis[a.x][a.y+1]=1;

}//判断这个点的右方点是否为l，如果为l即右方点可到达这个点，就将右方点入队

        if(ch[a.x][a.y-1]=='r'&&!vis[a.x][a.y-1]){

            q.push(place(a.x,a.y-1));

            vis[a.x][a.y-1]=1;

}//判断这个点的左方点是否为r，如果为r即左方点可到达这个点，就将左方点入队

    }
    printf("%d",ans);

    return 0; 

}

---

## 作者：loadingnow (赞：2)

数据范围很水，可以采用枚举每一个无风点的深度优先搜索结果，即上面的点可以用‘d’来到达，下面的用‘u’，左面的‘r’，右面的‘l’

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MAX=1010;
bool vst[MAX][MAX];
char ch[MAX][MAX];
int n,m;
void run(int x,int y)//dfs深度优先搜索，考虑到不符合下列条件的点无法到达   正在讨论的点，所以没有设置return ；
{
    if(ch[x-1][y]=='d'&&x-1>=1)//上方点，判断越界
    {
        vst[x-1][y]=true;
        run(x-1,y);
    }
    if(ch[x+1][y]=='u'&&x+1<=n)//下方点，判断越界
    {
        vst[x+1][y]=true;
        run(x+1,y);
    }
    if(ch[x][y+1]=='l'&&y+1<=m)//右方点，判断越界
    {
        vst[x][y+1]=true;
        run(x,y+1);
    }
    if(ch[x][y-1]=='r'&&y-1>=1)//左方点，判断越界
    {
        vst[x][y-1]=true;
        run(x,y-1);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>ch[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(ch[i][j]=='o')
                run(i,j),vst[i][j]=true;
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(vst[i][j]==true)
                ans++;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：MloVtry (赞：2)

发现楼下都是先找无风点宽搜的解法，这是把问题转化成了逆向

但是
我们为什么要转化呢？

我们是可以BL的，对，没错，就是深搜

用it[i][j]来表示这个点可不可以到无风点

那么，ans=Σit[i][j]

对于一个点，如果我们之前没有访问过，那么我们可以暴力扩展

扩展途中如果遇到一个曾经扩展过的点，那么它的扩展结果（以及沿途经过点的结果）就都是已知的了：就是那个扩展过的点

那么，每个点都只会扩展一次，复杂度O（N^2）


贴上代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
char map[1010][1010];
bool vis[1010][1010],it[1010][1010];//vis[i][j]表示是否访问过，it记录是否能到达
int n,m,ans;
bool tryit(int i,int j)
{
    if(vis[i][j]==true)
    {
        return it[i][j];//访问过了，直接返回
    }
    vis[i][j]=true;//标记
    if(map[i][j]=='o') return it[i][j]=true;//到达无风点
    if(i>n||j>m||i<=0||j<=0) return it[i][j]=false;//越界
        if(map[i][j]=='u') i--;
    if(map[i][j]=='d') i++;
    if(map[i][j]=='l') j--;
    if(map[i][j]=='r') j++;//判断方向
    return it[i][j]=tryit(i,j);//继续搜索
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            cin>>map[i][j];
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            if(!vis[i][j])//没扩展过，搞比利，呸，暴力
            {
                it[i][j]=tryit(i,j);
            }
            ans+=it[i][j];//然后累和
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Void_f (赞：2)

思路很简单，把每个无风（O）点当起始点向四周扩展，如果可以到达这个起始点，则以这个点也向四周扩展

注意记录扩展过的点




```cpp
#include <cstdio>
#include <cstring>
#define MAXN 1010
using namespace std;
const int dx[4]={-1,1,0,0};
const int dy[4]={0,0,-1,1};
const int ac[4]={2,1,4,3};
int m,n,a[MAXN][MAXN],ans=0;
bool b[MAXN][MAXN];
bool bfs(int x,int y)
{
    ans++;
    b[x][y]=1;
    int xx,yy;
    for(int i=0;i<4;++i)
    {
        xx=x,yy=y;
        xx+=dx[i],yy+=dy[i];
        if(a[xx][yy]==ac[i]) bfs(xx,yy);
    }
    return 0;
}
int main()
{
    freopen("hhh.in","r",stdin);
    freopen("hhh.out","w",stdout);
    scanf("%d%d",&n,&m);
    char ch[MAXN];
    for(int i=1;i<=n;++i)
    {
        scanf("%s",ch);
        for(int j=0;j<m;++j)
        {
            switch(ch[j])
            {
                case 'u':a[i][j+1]=1;break;
                case 'd':a[i][j+1]=2;break;
                case 'l':a[i][j+1]=3;break;
                case 'r':a[i][j+1]=4;break;
                case 'o':a[i][j+1]=-1;break;
            }
        }
    }
    memset(b,sizeof(b),0);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            if(a[i][j]==-1&&!b[i][j]) bfs(i,j);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：yyandy (赞：1)

此题可以这样来思考：

伞兵只有到无凤的o点才能降落

那我们不妨就从o点找起，逆推上去

每次经过一个点，标记一下
（表示这个点可以到o点）

注意：枚举四周能否到达的时候要反一下

比如A在B的北方,A点的伞兵飘到B点需要向南的风

最后数一下标记的个数

注释见代码

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1100][1100];
bool tong[1011][1011];//桶数组标记
int i,j,n,m,s;
void dfs(int x,int y)
{
	if (x<1||y<1||x>n||y>m||tong[x][y])
	return;
	tong[x][y]=1;
	if (a[x+1][y]=='u')
	dfs(x+1,y);//枚举南边的点
	if (a[x-1][y]=='d')
	dfs(x-1,y);//枚举北边的点
	if (a[x][y+1]=='l')
	dfs(x,y+1);//枚举东边的点
	if (a[x][y-1]=='r')
	dfs(x,y-1);//枚举西边的点
}
int main()
{
	cin>>n>>m;
	for (i=1;i<=n;++i)//++i比i++快
	for (j=1;j<=m;++j)
		cin>>a[i][j];
		for (i=1;i<=n;++i)
		for (j=1;j<=m;++j)
		if (a[i][j]=='o')
   	dfs(i,j);//找到一个没有风的点，搜索
	for (i=1;i<=n;++i)
	for (j=1;j<=m;++j)
	if (tong[i][j])s++;//统计能到达的点的数目
	cout<<s;
 } 
```


---

## 作者：清风我已逝 (赞：1)

这是一道很明显的广搜（水）题

从无风点开始扩展

知道不能走为止


奉上代码：

```cpp
#include<bits/stdc++.h>

using namespace std;
int n,m,que[10000][5],h,t,sum;
int mx[5]={0,0,0,1,-1},//1 2 3 4
	my[5]={0,1,-1,0,0};//E W S N//控制方向
bool vis[1005][1005];//标记数组
int a[1005][1005];
void bfs(){
	h=t=1;
	while(h<=t){
		int x=que[h][1],y=que[h][2];
		for(int i=1;i<=4;i++){
			int tx=mx[i]+x,ty=my[i]+y;
			if(tx>=1&&tx<=n&&ty>=1&&tx<=n&&i==a[tx][ty]&&vis[tx][ty]==0){
				vis[tx][ty]=1;sum++;
				que[++t][1]=tx;que[t][2]=ty;
			}
		}
		h++;
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char x;
			cin>>x;
			if(x=='u') a[i][j]=3;
			else if(x=='d') a[i][j]=4;
			else if(x=='l') a[i][j]=1;
			else if(x=='r') a[i][j]=2;
			else a[i][j]=0;//输入时转化方向
		}
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==0){
				que[1][1]=i;que[1][2]=j;sum++;
				bfs();
			}
		}
	}cout<<sum;
	return 0;
}
```
题解里有使用DFS做的，比这更简洁，而且开了O2优化的DFS比我的BFS还要快

吾王剑锋所指，吾等心之所向。

---

## 作者：黎明行者 (赞：1)



    


```cpp
//基本思路：所有无风点都可以直接放置伞兵
//                 如果一个点p可以放置伞兵且它旁边的点k可以到达p，则k也可以放置伞兵
//      注意：此题应该用递归函数搜索  用队列搜索会TLE
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;
int m,n;
char l[1001][1001];
bool ptb[1001][1001];
int ans=0;//最终答案 
struct point//定义  结构体  点 
{
    int x,y;
    point(int px,int py)//构造函数
    {
        x=px;y=py;
    }
    point()//构造函数    这个构造函数一定要写，否则通不过编译
    {
        x=0;y=0;
    }
};
point nwp[1000001];//无风点 
int nwpn=0;//无风点的数量 
void dfs(point tp)//dfs搜索函数
{
    ans++;
    if (l[tp.x][tp.y-1]=='r'&&(!ptb[tp.x][tp.y-1])) dfs(point(tp.x,tp.y-1));//如果tp左边的点的风向向右，则dfs(tp左边的点)
    if (l[tp.x][tp.y+1]=='l'&&(!ptb[tp.x][tp.y+1])) dfs(point(tp.x,tp.y+1));
    if (l[tp.x+1][tp.y]=='u'&&(!ptb[tp.x+1][tp.y])) dfs(point(tp.x+1,tp.y));
    if (l[tp.x-1][tp.y]=='d'&&(!ptb[tp.x-1][tp.y])) dfs(point(tp.x-1,tp.y));
}
int main()
{
    scanf("%d%d",&n,&m);
    char rs[1001];
    memset(ptb,false,sizeof(ptb));
    for (int i=1;i<=n;i++)
    {
        scanf("%s",&rs);
        for (int j=1;j<=m;j++)
        {
            l[i][j]=rs[j-1];
            if (rs[j-1]=='o') nwp[++nwpn]=point(i,j);
        }
    }
    for (int i=1;i<=nwpn;i++)//dfs(所有无风点)
    {
        dfs(nwp[i]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：wanglichao1121 (赞：1)

其实这是一道很简单的[u]广搜[/u]题目：

队列中先存好每个“o”的位置，然后扩展就可以了（扩展好的点记得标示掉）

最后输出总个数（尾指针）

<hr>
上程序：

```delphi

var n,m,h,t,i,j,p,q:longint;a:array[1..1000,1..1000]of char;
    x,y:array[1..1000000]of longint;
begin
  readln(n,m);
  h:=0;t:=0;
  for i:=1 to n do
  begin
  for j:=1 to m do
  begin
  read(a[i,j]);
  if a[i,j]='o' then begin inc(t);x[t]:=i;y[t]:=j;end;//'o'入队
  end;
  readln;
  end;
  repeat//开始搜
  inc(h);
  p:=x[h];q:=y[h];
  if p>1 then
  if a[p-1,q]='d' then  //上面的点风往下吹，就能到这个点
  begin
  a[p-1,q]:='o';//标示
  inc(t);       //入队
  x[t]:=p-1;
  y[t]:=q;
  end;
  if p<n then
  if a[p+1,q]='u' then  //以下同上
  begin
  a[p+1,q]:='o';
  inc(t);
  x[t]:=p+1;
  y[t]:=q;
  end;
  if q>1 then
  if a[p,q-1]='r' then
  begin
  a[p,q-1]:='o';
  inc(t);
  x[t]:=p;
  y[t]:=q-1;
  end;
  if q<m then
  if a[p,q+1]='l' then
  begin
  a[p,q+1]:='o';
  inc(t);
  x[t]:=p;
  y[t]:=q+1;
  end;
  until h=t;
  writeln(t);  //尾指针代表共入队了几个数，就相当于可以放伞兵的点个数
end.

```

---


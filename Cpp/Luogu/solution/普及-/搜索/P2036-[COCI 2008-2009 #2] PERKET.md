# [COCI 2008/2009 #2] PERKET

## 题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。
#### 说明
- 本题满分 $70$ 分。
- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
1
3 10```

### 输出

```
7```

## 样例 #2

### 输入

```
2
3 8
5 8```

### 输出

```
1```

## 样例 #3

### 输入

```
4
1 7
2 6
3 8
4 9```

### 输出

```
1```

# 题解

## 作者：空气树 (赞：657)

这是道简单dfs，但看题解写的太啰嗦，于是想水一发
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int M=15;//养成良好习惯
int a[M],b[M],n,ans=0x7f;
//ans初始化为最大值
void dfs(int i,int x,int y){
//i是表示目前的配料编号，x为酸度，y为甜度
    if(i>n){
    	//注意，必须大于n才表示全部搜完
        if(x==1&&y==0)return;
        //判断清水的情况
        ans=min(abs(x-y),ans);
        //更新ans
        return;
    }
    //分两种情况搜索：1添加 2不添加
    dfs(i+1,x*a[i],y+b[i]);
    dfs(i+1,x,y); 
    //这题无需回溯，不明白为何有些题解居然还用全局变量，非得回溯-_-||
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&a[i],&b[i]);
        //读入，用cin太慢了
    }
    dfs(1,1,0);
    printf("%d\n",ans);
    return 0;
}
```
于是你会蜜汁WA

只因为这题数据太水（毒瘤）所以ans要初始化为0x7fffffff，否则只有42。

dfs很简单，但千万不可想复杂。

第一篇题解，求过！！

---

## 作者：fzj2007 (赞：236)

本蒟蒻再来一篇~

一眼看到这道题，一个**DFS**的思路来了，~~但是本蒟蒻连普及都没有考，水平很低，大佬们的记忆化搜索都不会。。~~

好了，先说一下思路，本蒟蒻外面用一个for循环来代表选取材料的数量，将这个数量当做参数。

然后，说一下坑点：

 这个题目要看清了，我们知道它们各自的酸度S和甜度B。当我们添加配料时，**总的酸度为每一种配料的酸度总乘积；总的甜度为每一种配料的甜度的总和。**

然后，**我们必须添加至少一种配料**。。

下面，看代码（逃）
```
#include<bits/stdc++.h>
using namespace std;
//n为配料个数，minn为最小值，x为酸度（注意声明=1啊），y为甜度
int n,minn,x=1,y;
//a存储酸度，b存储甜度
int a[11],b[11];
//用来标记用过的数
int book[11];
//传的参数代表选配料的个数，刚才忘了说了
void dfs(int c){
	//如果c是0，代表选完了，那么寻找最小值，并返回到上一次查找
	if(c==0){
		minn=min(minn,abs(x-y));
		return;
	}
    //从1到n查找
	for(int i=1;i<=n;i++){
    //是否使用过，没有使用过，即可使用
		if(book[i]){
        //将book[i]改为0，避免重复使用
			book[i]=0;
            //x增加
			x*=a[i];
           //y增加
			y+=b[i];
            //剩余寻找次数减少
			c--;
            //继续搜索
			dfs(c);
            //别忘记恢复现场啊，否则答案是错误的
			c++;
			x/=a[i];
			y-=b[i];
			book[i]=1;
		} 
	}
}
int main(){
   //输入不解释
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    //选择所有配料的情况
	for(int i=1;i<=n;i++){
    //注意乘法
		x*=a[i];
       //加法
		y+=b[i];
	}
    //abs是取绝对值，大家都知道吧，例如（-2）的绝对值是2
	minn=abs(x-y);
    //只选择一种配料的情况
	for(int i=1;i<=n;i++)
    //min方法取最小值，这样可以将最小值复制给minn
		minn=min(minn,abs(a[i]-b[i]));
        //选2~n中一种配料的情况
	for(int i=2;i<n;i++){
    //初始化不解释
		memset(book,1,sizeof(book));
      //别忘了重新初始化
		x=1;
		y=0;
        //神~~深~~搜
		dfs(i);
	}
    //输出
	cout<<minn;
	return 0;
}

```

最后，有几个方法给初学者讲一下：

1、ios::sync_with_stdio(false);这个方法还是要解释一下的

在某些题目中，我们使用普通的cin和cout会超时，所以我们每次只能打scanf和printf，然后一堆的占位符巨麻烦），为什么cin和cout比scanf和printf用的时间多？
**这是因为C++中，cin和cout要与stdio同步，中间会有一个缓冲，所以导致cin，cout语句输入输出缓慢，这时就可以用这个语句，取消cin，cout与stdio的同步，说白了就是提速，效率基本与scanf和printf一致。**


2、abs绝对值

abs 是 absolute value （绝对值）缩写。c++ 中的一个数学函数，计算整型量的绝对值。要头文件 #include <cmath> 或 #include <math.h>
```
算例：
int x=16, y= -6;
cout << abs(x) << endl;
cout << abs(y) << endl;
输出：
16
6
```
  
但是注意浮点数要使用fabs
  
3、min取最小值
  
例如：
  ```
int a=10,b=8;
cout<<min(a,b);

则这段代码会输出8
```

4、memset
  
memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。
  
例如：
```
int a[100001]={1,43,3,2,3,5};
memset(a,0,sizeof(a));

那么a数组所有位置都为0
```

[编程语言 C++ 代码长度 906B 用时 424ms 内存 668.00KB](https://www.luogu.org/record/23186187)
  
  有帮助的，记得点个赞哈！！





---

## 作者：woshishei (赞：124)

楼下几位dalao都用的DFS，我就水一发位运算。

用二进制数表示配料的选择情况，例如有5种配料，二进制数$01101$则表示选择第1、3、4种配料（从右往左）。

可通过`(a>>j)&1`判断从右往左数第$j$位是不是1。

最后计算出酸度和甜度的绝对差，取最小值。

时间复杂度$O(2^n)$

**AC代码：**
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
int N,s[12],b[12],mi=2000000001;
int main()
{
	scanf("%d",&N);
	for(int i=0;i<N;i++)
		scanf("%d %d",&s[i],&b[i]);
	for(int i=1;i<(1<<N);i++)//因为至少有一种配料，所以从1开始
	{
		int S=1,B=0;//注意总酸度初始值为1！
		for(int j=0;j<N;j++)
			if((i>>j)&1)//判断是否为1
			{
				S*=s[j];
				B+=b[j];
			}
		mi=min(mi,abs(S-B));//别忘了绝对值
	}
	printf("%d",mi);
	return 0;
}
```

---

## 作者：空·白 (赞：72)

~~这道题怎么说呢，一开始我是想暴力的，但是呢，我发现暴力比dfs还难就放弃了。~~

------------
一道入门级的dfs，就当是练练手了。

------------

```cpp
#include<bits/stdc++.h>		//非常稳健的万能头
using namespace std;
long long int s[20],b[20],f[20];	//s表示酸度，b表示甜度，f记录是否查找
long long int n,j,c=1,y=0,ans=99999999999;		//ans记录最小值
void dfs(int x)
{
	if(x>n)		//最多选n种调料，超过不做操作
	{
		
	}
	else
	{
		for(int i=1;i<=n;i++)
		{
			if(f[i]==0)		//没有查找过的才操作
			{
				c*=s[i];
				y+=b[i];
				ans=min(ans,abs(c-y));	//取最小值
				f[i]=1;		//记录
				dfs(x+1);
				f[i]=0;		//取消记录
				c/=s[i];
				y-=b[i];
			}
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i]>>b[i];
	}
	dfs(1);
	cout<<ans;
}
```


---

## 作者：Ash_Dr (赞：24)

2020.4.8更新了$LaTeX{}$

蒟蒻来写自己的第一篇题解，求管理大大过啊QAQ
最近在深基上看完了**枚举子集**这一板块 来刷这道红题

看讨论区的大佬都在用DFS，但是本蒟蒻就想用枚举做(~~因为这是枚举板块的习题~~)

好的，废话不多说 看题

首先看一下数据范围，不愧是红题，数据范围十分的友好 n最多只有10，虽然枚举子集的复杂度是$O(2^n)$级别的，但这样的数据范围允许我们使用子集枚举

为什么想到子集枚举呢？(~~不难想到~~)其实这道题本质就是在这些调料中选择适当数目的调料来满足题目要求，自然也就是**枚举整个调料集合的子集**啦

现在介绍如何枚举子集   
我们看这样一个二进制  $(0110)$ 我们可以从右向左，当第几位出现了1，就代表$a[i]$在当前子集中，那么我们只需要枚举$1\text{到}2^n-1$ 即可(具体细节实现读者可以自己画图仔细想想)

给上代码 注释在代码中
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int min(int x, int y ) {return x<y?x:y;}//自定义函数
int s[12],b[12];
int main() {
	int n;
	cin>>n;
	for(int i=0; i<n; i++) {
		cin>>s[i]>>b[i];
	}//注意从0开始存
	int u=1<<n;//对全集的处理，需要用到二进制知识
	int ans=99999999;
	for(int i=1; i<u; i++) {
		int ss=1,bb=0;//用来求积/和的变量
		for(int j=0; j<=n; j++) {//这一层循环用来判断当前数哪几位为1
			if(i&(1<<j)) {
				ss*=s[j];
				bb+=b[j];
			}
		}
		ans = min(ans,(int)abs(ss-bb));//判断
	}
	cout<<ans;
	
} //23ms 680kb
```


---

## 作者：Victory_Defeat (赞：18)

这题一看就知道要用DFS，其实也可以算作是一题新手练手题吧，练练DFS

有人说可以暴力？！反正我只会DFS……

第二篇题解，各位神犇dalao们请谅解（好像两篇都是DFS?）

废话不多说，下面奉上我的AC代码（具体说明见注释）：

```cpp
#include<cstdio>
#include<algorithm>//头文件，min和abs在algorithm中（STL大法好）！
struct perket//定义结构体
{
    int sour,sweet;//sour表示酸度，sweet表示甜度
}a[11];//配料
int s=1,w,ans=2147483646,n;//ans一开始开2147483647莫名RE，用2147483646就好了。。。。。。
long long ok;//ok表示所用配料数
inline void read(int &a)//这里详细解释一下快速读入，inline的作用为加快该函数所用时间，注意：若不止一个输入输出文件，则不可用inline！
{
    char c;//定义字符存储变量
    int k=1;a=0;//定义系数（初始为1）与所读入变量
    c=getchar();//读入字符
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}//如果该字符不为数字，跳过该字符，注意：由于本题有负数，所以要加判断是否为-号，如为-号，系数变为-1
    while(c>='0'&&c<='9'){a=a*10+c-'0';c=getchar();}//如果该字符为数字，原数*10+该字符-‘0’,其实*10+是特别特别有用的一个东西，不在这里详细论述，以后有时间的话会专门发一篇文章来解释*10+与其作用
    a*=k;//原数乘上系数
}
inline void print(int a)//快速输出
{
    if(a>10)print(a/10);//如果当前该数超过10，输出除个位外部分
    putchar(a%10+'0');//输出个位
}
void DFS(int i)//DFS，i表示当前搜索到第i个配料
{
    if(i==n+1)return ;//如果全部搜索完毕，回溯
    s*=a[i].sour;//当前酸度乘上该配料酸度
    w+=a[i].sweet;//当前甜度加上该配料甜度
    ok++;//所用配料数+1
    ans=std::min(ans,abs(s-w));//更新答案，取原答案与甜酸度之差的最小值，有人说可以加一个特判：当ans=0时，直接输出！我没有这么做，因为个人感觉没啥用
    DFS(i+1);//向下继续搜索
    s/=a[i].sour;//当前酸度除以该配料酸度
    w-=a[i].sweet;//当前甜度减去该配料甜度
    ok--;//所用配料数-1
    //这里解释一下：递归之前改变的值，递归过后一定要改回原值，即使你不再向下搜索，这也是递归的基本特征之一！！！
    DFS(i+1);//向下继续搜索，这是为了保证答案的全面性
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++){read(a[i].sour);read(a[i].sweet);}//输入，不解释
    DFS(1);//DFS，从第一种配料开始搜索
    print(ans);//输出答案
}
```
#最后，强调一下：禁止抄袭！禁止抄袭！禁止抄袭！

~~求洛谷一定要给过！~~


---

## 作者：梧桐灯 (赞：16)

这题数据范围很小，用dfs不会超时。





```cpp
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
int a[15],b[15],n,ans=1<<30; //a表示酸度，b表示甜度，ans为最终答案。
void dfs(int i,int sj,int th){
    if(i>n){
        if(!th) //如果没有选任何一种材料。
            return ;
        ans=min(ans,abs(sj-th)); //否则更新答案。
        return ;
    }
    dfs(i+1,sj,th); //选
    dfs(i+1,sj*a[i],th+b[i]); //不选
}
int main(){
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d %d",&a[i],&b[i]);
    dfs(1,1,0);  //搜索，注意酸度初始值一定为1，甜度初始值一定为0.
    printf("%d",ans);
    return 0;
}

```

---

## 作者：李树 (赞：14)

大家好，我第一次发题解，若有什么问题，在评论区提建议；
请海涵！！！！！
(本题使用递归AC)
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,x=1,y;//n:配料个数,x:酸度,y:甜度
long long a[11],b[11];//存x,y的数组
bool nw[11];//判断是否使用过的bool型变量
int ans=0x3f3f3f3f;//记录最小值的变量
void Perket(int p){//函数名不用管#(O O)#
	if(p==n+1){
		return ;
	}//不要这个if也行
	for(int i=1;i<=n;i++){
		if(nw[i]!=true){//判断是否使用过
			x*=a[i];//酸度算法
			y+=b[i];//甜度算法
			if(ans>abs(x-y)){
				ans=abs(x-y);//绝对值
			}
			nw[i]=true;
			Perket(p+1);
			nw[i]=false;
			y-=b[i];
			x/=a[i];//回溯
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
	}
	Perket(1);
	cout<<ans;
	return 0;
}
```
此题解有些简单，希望各位大佬们有更多的牛皮想法。

---

## 作者：林家三少 (赞：9)

又一篇

$$\colorbox{red}{\color{white}入门难度 } $$

我们发现这个数据有点水，直接用DFS就OK了

~~所以......(此处省略n个字~~

代码：

```cpp
#include<bits/stdc++.h>  //这是个好东西
using namespace std;
long long n,ans=10000001,prod=1,sum=0;  //定义变量
struct data  //结构体定义
{
  long long acidity,sweetness;  //容我秀一波英语(其实是翻译来的
}x[100000+10];
bool cmp(data x,data y)  //定义排序
{
  if(x.acidity>y.acidity)return true;  //酸度从大到小来排
  else if(x.sweetness>y.sweetness)return true;  //否则甜度按大到小来排
  return false;
}
void I_am_a_genius(int i)  //DFS开始了！！！
{
  if(i==n+1)
  {
      if(prod==1&&sum==0) return; ans=min(ans,abs(prod-sum)); return;
  }
  prod*=x[i].acidity;
  sum+=x[i].sweetness; I_am_a_genius(i+1);
  prod/=x[i].acidity;
  sum-=x[i].sweetness; I_am_a_genius(i+1);
}  //竭尽全力的缩行qwq
int main()
{
  cin>>n;  //输入
  for(int i=1;i<=n;i++) cin>>x[i].acidity>>x[i].sweetness;  //循环输入酸度和甜度
  sort(x+1,x+n+1,cmp); I_am_a_genius(1);  //排序后进入函数 cout<<ans;  //最后输出
  return 0;  //完美结束
  //备注：I_am_a_genius的中文意思是：我是个天才
}
```
~~(求过~~

---

## 作者：孙广宸 (赞：7)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans=10000001,prod=1,sum=0;
struct node//结构体定义
{
	long long a,b; 
}x[100001];
bool cmp(node t1,node t2)//结构体快排模板
{
	if(t1.a>t2.a)return true;
	else
	{
		if(t1.b>t2.b)return true;
	}
	return false;
}
void dfs(int i)//皮这一下很开心
{
	if(i==n+1)//并不是到n停止，注意一下
	{
		if(prod==1&&sum==0)//如果一个都没选就不存最小值，否则会出现ans=0的情况
		{
			return;
		}
		ans=min(ans,abs(prod-sum));
		return;
	}
	prod*=x[i].a;
	sum+=x[i].b;
	dfs(i+1);
	prod/=x[i].a;//回溯
	sum-=x[i].b;//回溯
	
	dfs(i+1);//没选当前调料的情况
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>x[i].a>>x[i].b;
	sort(x+1,x+n+1,cmp);//话说不排序也可以AC
	dfs(1);
	cout<<ans;
	return 0;
    //
}
```

---

## 作者：我珂真尽梨了 (赞：3)

发现居然没有二进制模拟这么方便的代码

写起来超级简单的（虽然比DFS稍微慢一点点

但是思维复杂度比较低

具体解释看代码吧




    

```cpp
#include<bits/stdc++.h>
using namespace std;
int  n , numsour , numsweet , ans=1000000001 ;
int sour[11] , sweet[11] , b[11] ;
int main()
{
    cin >> n ;
    for ( int i=1; i<=n; i++ )cin >> sour[i] >> sweet[i] ;
    while (true)     //不能把出口写在这，因为不能选择所有调料都不放
    {
        b[n]++ ;numsour=1;numsweet=0;
        for ( int i=n; i>=1; i-- )
            if (b[i]==2)    //**手动进位**
            {
                b[i]=0;
                b[i-1]++;    
            }
        if (b[0]==1)break;    //**出口，当所有情况枚举结束就完成了，PS:一定要...写在里面，我一开始写在WHILE条件上结果WA了**
        for ( int i=1; i<=n; i++ )
            if (b[i]==1)    //B数组表示的是0、1, 0是不选择当前调料，1是选择当前调料
            {
                numsour*=sour[i];
                numsweet+=sweet[i];
            }
        ans=min(ans,abs(numsour-numsweet));
    }
    cout << ans ;
    return 0;
}
```
是不是比起DFS好看多了？？【但是的确会慢点，但那是N<=30的后话了】
应该没什么不懂的吧。。。


---

## 作者：zyn0614 (赞：3)

###看了这里没有P党题解，乘机来一发。


```cpp
var
  n,i,ans:longint;//ans为最终结果
  s,t:array[1..10]of longint;//各种配料的酸度与甜度
procedure dfs(sm,tm,last:longint);//深搜
var
  i,ns,nt:longint;//ns、nt为新产生的甜度与酸度
begin
  for i:=last+1 to n do//记住，此题让我们求的是组合，不是全排列，所以这里从前一个加入的配料的下一种开始枚举
  begin
    ns:=sm*s[i];
    nt:=tm+t[i];//累加累乘
    if abs(ns-nt)<ans then ans:=abs(ns-nt);//比较并选择是否替换
    dfs(ns,nt,i);//继续往下搜索
  end;
end;
begin
  readln(n);ans:=1000000000;//初始化
  for i:=1 to n do
  readln(s[i],t[i]);
  dfs(1,0,0);
  writeln(ans);
end.
```

---

## 作者：曾经的小玄XX (赞：3)

简单看了一下题目，立马就想到了dfs，但是由于过于~~蒟蒻~~不谨慎，把酸度和甜度的累乘和累加看错了，导致样例看了老半天。

这道题看一下C++巨佬都写的好长啊~~全部用快读快输~~感觉Pascal根本写不了那么长。

废话不能多说，代码在下：

```pascal
var n,i,min:longint;s:array[1..100,1..2]of longint;
procedure dfs(s1,s2,t:longint);//s1是酸度累乘，自此初始值为1，s2是甜度累加，t就不解释了
begin
 if(abs(s1-s2)<min)and(s1<>1)and(s2<>0)then//判断是否为最小值的规则
  min:=abs(s1-s2);
 if t>n then//终止条件
  exit;
 dfs(s1*s[t,1],s2+s[t,2],t+1);//继续dfs，将酸度乘起来，甜度加起来（继续放的情况）
 dfs(s1,s2,t+1);//（不放的情况）
end;
begin
 min:=maxlongint；//最小值初始化
 read(n)；
 for i:=1 to n do
  read(s[i,1],s[i,2])；//读入
 dfs(1,0,1)；//正片
 writeln(min)；//输出
end.
```

## 珍爱账号，请勿抄袭！！！

---

## 作者：THMITW (赞：2)

## 二进制穷举
思路：穷举所有情况，找最优解；时间复杂度O(2^n).

注释都贴在代码上了,关于二进制穷举介绍：[详细看这里](https://www.luogu.org/problemnew/solution/P1515?page=3)
```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[21];
int u[15],v[15],ans=0x7fffffff;
inline int abss(int x)
{
	return x>0?x:-x;
}
inline int maxx(int x,int y)
{
	return x>y?x:y;
}
inline int minn(int x,int y)
{
	return x<y?x:y;
}//由于自带函数过慢，二进制穷举复杂度高，自己写
int main()
{
	int n;
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>u[i]>>v[i];
	b[n]=1;
	while(b[0]==0)
	{
		bool flag=0;
		int x=1,y=0;//x表示酸度和，y表示甜度和
		for(int i=1; i<=n; i++)
			x*=maxx(u[i]*b[i],1)/*注意：如果不取不是0而是1*/,y+=v[i]*b[i];
		ans=minn(ans,abss(x-y));//如果有更优解，就选更优的
		int j=n;
		while(b[j]==1)j--;
		b[j]=1;
		for(int i=j+1; i<=n; i++)b[i]=0;
	}//二进制穷举模板
	cout<<ans;
	return 0;
}
```


---

## 作者：felixwu (赞：1)

还是用dfs，不过有一点区别，
o(2^n)的dfs。
0是不取，1是取；
看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100],b[100],n,m,ans=2147483647;//ans开最大
int judge(int x,int y)
{
	if (y==1) return x;
	else return 1;//不能*0所以专门写了一个函数
}
void dfs(int x,int s,int t,int k)//x代表第几个,s是酸度,t是甜度，k是取了几个；
{
	if (x==n+1&&k==0) return;//当没取时，不做
	if (x==n+1&&k>=1){//到达目的地且取了，记录
		ans=min(ans,abs(s-t));
		return ;
	}
	for(int i=0;i<=1;i++){
		dfs(x+1,s*judge(a[x],i),t+b[x]*i,k+i);//core：容易理解的
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
	dfs(1,1,0,0);
	printf("%d",ans);
    return 0;
}
```

---


# 危险区域

## 题目背景

一个恐怖组织在一座城市中安放了定时炸弹，其威力巨大，现在这里的警长想知道最坏的情况下会有多少街区受威胁。

## 题目描述

在一个城市有 $N \times M$ 个街区，每个街区由坐标描述，如图所示：



|  | $1$ | $2$ | $3$ | $\cdots$ | $M$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $(1,1)$ | $(1,2)$ | $(1,3)$ | $\cdots$ | $(1,M)$ |
| $2$ | $(2,1)$ | $(2,2)$ | $(2,3)$ | $\cdots$ | $(2,M)$ |
| $3$ | $(3,1)$ | $(3,2)$ | $(3,3)$ | $\cdots$ | $(3,M)$ |
| $\vdots$ |  |  |  | $\ddots$ |  |
| $N$ | $(N,1)$ | $(N,2)$ | $(N,3)$ | $\cdots$ | $(N,M)$ |

现在已知有一个恐怖组织在其中的一个街区安放了定时炸弹，其威力为 $t$，即所有到这个街区的直线距离小于等于 $t$ 的街区都会受威胁，已知有 $k$ 个可能的炸弹安放位置，现在这里的警长想知道最坏的情况下会有多少街区受威胁。


## 说明/提示

**数据规模与约定**

对于$20\%$的数据 $k=1$。

对于 $50\%$ 的数据 $1 \le n,m \le 1000$，$1 \le k \le 20$，$1\le t \le 100$。

对于 $100\%$ 的数据 $1 \le n,m \le 10^5$，$1 \le k \le 50$，$t \le 300$。

fixed by @[$\color{#5EB95E}{\textsf{Cppsteve}}$](https://www.luogu.com.cn/user/479296)

## 样例 #1

### 输入

```
4 5 3 2
1 2
3 4
4 5
```

### 输出

```
11```

# 题解

## 作者：Atmizz (赞：27)

## 枚举！！！这个最简单（~~因为我不会其他的~~。。）

提醒一下：如果您还没看题的话，请先回去看题，题目有点难以理解，我第一遍就理解错了。
 - 恐怖组织只有一个炸弹（~~真穷~~）；
 - 控制炸弹范围，避免超范围（有点难想到，我是借鉴了一位dalao的思路）。
 
输入一个街区坐标，然后就开始枚举街区，看是否在范围内。尽量不要开数组，因为数据范围大，容易爆空间，连编译都不过（~~手动滑稽~~）。
#### 再就是，两点之间的距离公式->


------------

```cpp
sqrt((x-a)*(x-a)+(y-b)*(y-b))
```


------------

初中的知识点，必须会啊！！！！这个题与[P3717 cover](https://www.luogu.org/problemnew/show/P3717)类似，大家可以做一下。

再一个，此题容易超时，容易得50分（实践出真知，我实践了），建议大家使用函数计算距离。


------------

```cpp
double dis(int x,int y,int a,int b)//取距离函数，很重要 
{
    return sqrt((x-a)*(x-a)+(y-b)*(y-b));//两点之间距离公式 
}
```


------------

#### 好，该说的的都说完了，上code：


------------

```cpp
#include<cstdio>//不建议使用万能头。。 
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,k,t,x,y,ans,maxn=0;//ans表示一个炸弹可以炸的街道，maxn取最大的 
double dis(int x,int y,int a,int b)//取距离函数，很重要 
{
    return sqrt((x-a)*(x-a)+(y-b)*(y-b));//两点之间距离公式 
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&k,&t);//输入 
	for(int q=1;q<=k;q++) {
		ans=0;//不要忘了初始化 
		scanf("%d%d",&x,&y);//线上计算 
		for(int i=max(x-t,1);i<=min(n,x+t);i++) {//借鉴的大佬的思路，特别是这里 
			for(int j=max(y-t,1);j<=min(m,y+t);j++) {
				if(dis(i,j,x,y)<=t)//小于爆炸范围 
					ans++;//计数器加加 
			}
		}
		if(maxn<ans)//取最大值 
			maxn=ans;
	}
	printf("%d",maxn);//输出 
	return 0;//完美の结束！！！ 
}
```

---

## 作者：greenheadstrange (赞：25)

1. 前备知识

![示意图](https://cdn.luogu.com.cn/upload/pic/60625.png)

请大家看这张图，可以证明任何一个圆上的点一定在以它的**直径**为边长的正方形内

所以只用在该正方形内枚举每一个点即可


下见代码:

```cpp
for(int i=max(1,x-t);i<=min(n,x+t);i++)
	for(int j=max(1,y-t);j<=min(m,y+t);j++)
		ans+=(dis(i,j,x,y)<=t);
```
2. 两点间的距离公式

![示意图](https://cdn.luogu.com.cn/upload/pic/60663.png)

能够用勾股定理证明：

**dis=√((x1-x2)^2+(y1-y2)^2);**

下间代码：

```cpp
double dis(int x_1,int y_1,int x_2,int y_2){
    return sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2));
}
```
放个总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,t,maxx,ans,x,y;
double dis(int x_1,int y_1,int x_2,int y_2){//两点间的距离公式 
    return sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2));
}
int main(){
    scanf("%d%d%d%d",&n,&m,&k,&t);
    while(k--){
        scanf("%d%d",&x,&y);
        ans=0;//初始化为最小值
        for(int i=max(1,x-t);i<=min(n,x+t);i++)
        	for(int j=max(1,y-t);j<=min(m,y+t);j++)//上文已进行说明
            	ans+=(dis(i,j,x,y)<=t);//可以取等
        maxx=max(maxx,ans);
    }
    printf("%d",maxx);
}
```


---

## 作者：cheliang (赞：8)

不难，枚举即可。

一个在(x,y)点炸弹能影响到的最大的范围是

行 max(1,x-t)——min(n,x+t)

列 max(1,y-t)——min(m,y+t)

坐标为x，y和坐标为n，m两点距离的计算公式：sqrt((x-n)\*(x-n)+(y-m)\*(y-m))

```cpp
var
    i,j,k,l,n,m,t,x,y,t1,t2:longint;
function js(x,y,n,m:longint):double;
begin
    exit(sqrt((x-n)*(x-n)+(y-m)*(y-m)));
end;
function max(x,y:longint):longint;
begin
if x>y then
    exit(x)
else exit(y);
    end;
function min(x,y:longint):longint;
begin
if x<y then
    exit(x)
else exit(y);
    end;
begin
readln(n,m,k,t);
for l:=1 to k do
    begin
readln(x,y);
        t2:=0;
        for i:=max(1,x-t) to min(n,x+t) do
            for j:=max(1,y-t) to min(m,y+t) do
                if js(i,j,x,y)<=t then
                    inc(t2);
                if t2>t1 then
                    t1:=t2;
                end;
                writeln(t1);
end.
```

---

## 作者：revenger (赞：8)

这个数据范围=\_=枚举就能过啊……【说得好像我知道别的做法一样】

k<=50 t<=300 枚举是kt^2的效率 

行列的范围分别是1-n,1-m;容易知道一个在(x,y)点炸弹能影响到的最大的范围是

行 max(1,x-t)——min(n,x+t)

列 max(1,y-t)——min(m,y+t)

所以对于每一个点枚举 取最大值就好了

两点距离公式应该没有不知道的吧【不知道看代码好了= =

代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define max(a,b) (a>b?a:b) 
#define min(a,b) (a>b?b:a)
using namespace std;
double dis(int x,int y,int a,int b)
{
    return sqrt((x-a)*(x-a)+(y-b)*(y-b));
}
int m,n,k,t,maxx,sum,c,d;
int main()
{
    scanf("%d%d%d%d",&n,&m,&k,&t);
    while(k--)
    {
        scanf("%d%d",&c,&d);
        sum=0;
        for(int i=max(1,c-t);i<=min(n,c+t);i++)
        for(int j=max(1,d-t);j<=min(m,d+t);j++)
        {
            if(dis(i,j,c,d)<=t)
            sum++;
        }
        if(sum>maxx)
        maxx=sum;
    }
    printf("%d",maxx);
}
```

---

## 作者：Doqin07 (赞：7)

## 题意描述：

有T个可安置炸弹的位置，要你求出最坏有几个点会受到影响

## 前置知识：
#### 平面直角坐标系上两点距离公式：


$$\sqrt{(x1-x2)^2+(y1-y2)^2}$$

#### 用勾股证明！我比较懒就不证了QwQ

```cpp

inline double dis(int x,int y,int xx,int yy){
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
```
#### 然后就可以枚举每个炸弹了


------------
## Code
```c

#include<bits/stdc++.h>
using namespace std;
double get(int x,int y,int xx,int yy){
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
int n,m,k,t,x,y,ans,res;
int main(){
	scanf("%d%d%d%d",&n,&m,&k,&t);
	while(k--){
		scanf("%d%d",&x,&y);
		res=0;
		// 每次置为0 
		for(int i=max(1,x-t);i<=min(n,x+t);++i)
		// 枚举行，地图行数最小为1，所以取较大值；地图最大为n，所以取较小值 
			for(int j=max(1,y-t);j<=min(m,y+t);++j)
			// 枚举列，同上 
				if(get(i,j,x,y)<=t)
					res++;
		ans=max(ans,res);
		// 更新答案 
	}
	printf("%d\n",ans);
	return 0;
}
```


---------
### 第一篇题解，求过^_^



---

## 作者：一只小H (赞：3)

## 题意简述

一个矩阵上有一些点，每个点影响范围为 $T$，输出影响力最大的点能影响的范围。

输入：

* 矩阵的尺寸 $N$，$M$，点的个数 $K$ 与影响范围 $T$。（$N,M<=100000$）
* 每个点的坐标。

输出：

* 最大的范围。

## 题目分析

![样例](https://cdn.luogu.com.cn/upload/image_hosting/7l9a0dkk.png)

首先暴力的解法并不难想，枚举矩阵中的每个坐标并判断与点的坐标是否小于等于 $T$ ，然后记录数量输出最小值即可。

但因为 $N$ 和 $M$ 的范围很大，一个个枚举肯定会超时，所以我们要想办法缩小枚举范围。

![分析](https://cdn.luogu.com.cn/upload/image_hosting/jexz17d1.png)

经过观察我们发现，只有紫色区域是需要进行枚举的，而紫色区域的范围即圆所在的正方形和矩形的公共部分。

还有一个小优化，如果圆所在的正方形完全被包括在了矩形内，因为它没有任何地方被浪费，那么它肯定是最优解，直接输出这个解即可。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int N, M;         //矩阵的大小
int K;            //点的个数
int T;            //影响范围
int a, b;         //每个点的坐标
int num;          //当前的解
int ans;          //最终的解
inline bool inc() //判断是否完全被包括
{
    return (a - T >= 0) and (a + T <= N) and (b - T >= 0) and (b + T <= M);
}
inline double dis(const int &x1, const int &x2, const int &y1, const int &y2) //计算两点距离
{
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
int main()
{
    cin >> N >> M >> K >> T;
    while (K--)
    {
        num = 0;
        cin >> a >> b;

        /*缩小范围后的枚举*/
        /**
         * a-T为正方形的左边
         * a+T为正方形的右边
         * b-T为正方形的上边
         * b+T为正方形的下边
         */
        for (int i = max(1, a - T); i <= min(N, a + T); ++i)
        {
            for (int j = max(1, b - T); j <= min(M, b + T); ++j)
            {
                if (dis(i, a, j, b) <= T) //满足条件的统计
                {
                    num++;
                }
            }
        }

        if (inc())
        {
            cout << num; //如果必定是最优解那么直接输出
            return 0;
        }

        ans = max(ans, num);
    }
    cout << ans;
    return 0;
}
```


---

## 作者：zhangzhaoke (赞：3)

我也不会其他算法，只好一个个枚

```cpp
#include<iostream>//头文件 
#include<cmath>//max函数,sqrt函数头文件 
using namespace std;
int m,n,k,t,answer,max,Xi,Yi;//据题定义 ,max是目前值,answer是目前最大值 
int main(){
    cin>>n>>m>>k>>t;//输入 
    for(;;k--){//for循环，个人习惯，while也行呢 
        cin>>Xi>>Yi;//据题定义 
        maxx=0;//注意,一定要重置 
        int i=max(1,Xi-t);//i为两者最大,因为Xi-t有可能出界,此时i为1
        int j=max(1,Yi-t);//同上 
        int hehe,haha;
        if(n<Xi+t)hehe=n;// hehe为两者最小,因为Xi+t有可能出界,此时i为n
        else hehe=Xi+t;
        if(m<Yi+t)haha=m;//同上
        else haha=Yi+t;
        for(;i<=hehe;i++){//双层for枚举，sqrt是个好东西 
        	for(;j<=haha;j++){
            	if((sqrt((i-Xi)*(i-Xi)+(j-Yi)*(j-Yi)))<=t)maxx++;
        	}
		}
        if(max>answer)answer=max;//如果当前最大,就替换掉 
    }
    cout<<answer;//输出答案 
    return 0;
}
```
~~与楼上有点像，但我真是自己写的~~

---

## 作者：jxbe6666 (赞：2)

一道很水的模拟题  



题目介绍
- 恐怖组织只有一个炸弹,所以不用开数组。
- 炸弹的范围一定要控制的紧紧的，超范围了就难办了（我也是听取了同机房 dalao 的思路）。

主要思想  
模拟，模拟，模拟（重要的话说三遍）
还有一点是两点之间的距离公式：
$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ 。  
作为一个小学奥赛的队员自然是非常的熟悉。
```cpp
sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

```
知道了距离公式后，就是枚举街区位置判断是否在炸弹的影响范围之内，如果在影响范围之中，那么计数器 $sum$ 就 $++$。最后与最大值判断，如果比当前最大值大，就把最大值改为 $sum$，记住循环结束后 $sum$ 一定要清零。

下面给出我的 AC Code ：
```cpp
#include <bits/stdc++.h>
#define I return
#define AK 0
#define IOI ;
using namespace std;
int n, m, k, x, y, l, r;
int sum, s, ans;
inline int in()
{ //  快读,可快了
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
inline void out(int X)
{ //快速输出也是灰常快滴
    if (X < 0)
    {
        X = ~(X - 1);
        putchar('-');
    }
    if (X > 9)
        out(X / 10);
    putchar(X % 10 + '0');
}
double jl(int x1, int y1, int x2, int y2)
{
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
int main()
{
    int maxn = INT_MIN;
    x = in(), y = in(), n = in(), m = in();
    while (n--)
    {
        l = in(), r = in();
        ans = 0;
        for (int i = max(l - m, 1); i <= min(x, l + m); i++) //此处的循环条件要看清楚,否则可能会越界
        {
            for (int j = max(r - m, 1); j <= min(y, r + m); j++)
            {
                if (jl(i, j, l, r) <= m)
                    ans++;
            }
        }
        maxn = max(maxn, ans); //更新maxn的值
    }
    out(maxn);
    I AK IOI //一个蒟蒻最后的尊严!!!!!!!!
}

```




---

## 作者：BotDand (赞：1)

# Problems
求一个炸弹最多能炸到的范围。
# Answer
首先要知道一个东东：两点间的距离公式。

就是这个东东^_^：$\sqrt{(x1-x2)^2+(y1-y2)^2}$

怎么来的呢？借一下[waterfall](https://www.luogu.com.cn/user/88137)大佬的图：

![](https://cdn.luogu.com.cn/upload/pic/60663.png)

根据勾股定理（$a^2+b^2=c^2$）可以推出公式。

代码就是这个啦= =：

```pascal
 function js(x,y,n,m:longint):double;begin exit(sqrt((x-n)*(x-n)+(y-m)*(y-m)));end;
```

然后就可以逐个枚举炸弹啦。
# Code
```pascal
uses math;//调用数学库
var
  n,m,k,t,ma,l,x,y,i,j,s:longint;
 function js(x,y,n,m:longint):double;begin exit(sqrt((x-n)*(x-n)+(y-m)*(y-m)));end;//公式
begin
  readln(n,m,k,t);
  ma:=-maxlongint;
  for l:=1 to k do
    begin
      readln(x,y);
      s:=0;
      for i:=max(1,x-t) to min(n,x+t) do
        for j:=max(1,y-t) to min(m,y+t) do//枚举炸弹的位置
          if js(i,j,x,y)<=t then inc(s);//如果炸得了，则累加s
      if s>ma then ma:=s;//找最大值
    end;
  writeln(ma);
end.
```

---


# 地下城主

## 题目描述

你参加了一项秘密任务，在任务过程中你被困在了一个 3D 的地下监狱里面，任务是计时的，你现在需要在最短的时间里面从地牢里面逃出来继续你的任务。地牢由若干层组成，每一层的形状都是长宽一样的矩形，地牢被分成了若干小格，当小格没有被岩石所占据时，你可以前往所在小格的前方，后方，左方，右方，上层，下层的小格。每走一小格花费一分钟时间。

你能不能顺利的从地牢里面逃出来呢？如果可以，那所需要的最短时间又是多少呢？


~~据说出口藏有神器。~~

## 说明/提示

来源：POJ 2251


## 样例 #1

### 输入

```
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E```

### 输出

```
Escaped in 11 minute(s).```

# 题解

## 作者：二元长天笑 (赞：15)

其实这是一道很纯的bfs，但是由于维度加了一维，内存可能会相应的加大，但是没有关系，还是按原来的套路走就好了，我这里用的是**纯手工队列**，然后发现内存并没有爆，所以小伙伴们放心的开吧。现在回到正题，三维的bfs对于二维的来说，只是多了一个**z**坐标，所以我们在增加子节点的时候给他多搜索一个方向，如下：

```cpp
x1=x[head]+d3[i];
            y1=y[head]+d1[i];
            z1=z[head]+d2[i];
```
然后就跟二维的套路一样，判断是否走过和是否越界，都没有的话就入队，如下：

```cpp
if(a[x1][y1][z1]&&x1>=1&&x1<=l&&y1>=1&&y1<=n&&z1>=1&&z1<=m)
            {
                tail++;
                a[x1][y1][z1]=0;
                x[tail]=x1;
                y[tail]=y1;
                z[tail]=z1;
                f[tail]=head;
```
f数组在这里用来统计步数。然后再判断是否到达，如下：

```cpp
if(x1==en1&&y1==en2&&z1==en3)
                {
                    while(f[tail])  //这是一个“非递归”，用来找步数。
                    {
                        tail=f[tail];
                        sum++;
                    }
                    cout<<"Escaped in "<<sum<<" minute(s)."<<endl;
                    return 0;   //找到了就直接输出结束
                }
            }
```
如果一直没有找到，队首就会追上队尾，然后就结束循环，在最后再输出无法到达。

全部代码如下：

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;
int n,m,l,be1,be2,be3,en1,en2,en3,x[10001],y[10001],z[10001],d1[6]={1,-1,0,0,0,0},d2[6]={0,0,-1,1,0,0},d3[6]={0,0,0,0,1,-1},tail=1,head=0,x1,y1,z1,f[10001],sum;
bool a[31][31][31]={0};
int main()
{
    cin>>l>>n>>m;
    for(int i=1;i<=l;i++)
        for(int j=1;j<=n;j++)
        {
            cin>>s;
            for(int k=0;k<m;k++)
            {
                if(s[k]=='.')
                    a[i][j][k+1]=1;
                if(s[k]=='S')
                {
                    be1=i;be2=j;be3=k+1;
                }
                if(s[k]=='E')
                {
                    en1=i;en2=j;en3=k+1;
                    a[i][j][k+1]=1;
                }
            }
        }
    x[tail]=be1,y[tail]=be2,z[tail]=be3;
    do
    {
        head++;
        for(int i=0;i<6;i++)
        {
            x1=x[head]+d3[i];
            y1=y[head]+d1[i];
            z1=z[head]+d2[i];
            if(a[x1][y1][z1]&&x1>=1&&x1<=l&&y1>=1&&y1<=n&&z1>=1&&z1<=m)
            {
                tail++;
                a[x1][y1][z1]=0;
                x[tail]=x1;
                y[tail]=y1;
                z[tail]=z1;
                f[tail]=head;
                if(x1==en1&&y1==en2&&z1==en3)
                {
                    while(f[tail])
                    {
                        tail=f[tail];
                        sum++;
                    }
                    cout<<"Escaped in "<<sum<<" minute(s)."<<endl;
                    return 0;
                }
            }
        }
        
    }while(head<tail);
    cout<<"Trapped!"<<endl;
}
```

还有一点要注意，那就是输入这个地牢的时候坐标特别容易弄错，大家三思而后行啊！


---

## 作者：Stuch (赞：11)

## 其实，这是一道非常水的广搜。只是从二维变成了三维。格式还是没变的。
# 先奉上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={0,0,0,0,1,-1};//偏移数组,最后两个是上楼或下楼
const int dy[]={1,-1,0,0,0,0};
const int dz[]={0,0,1,-1,0,0};
int l,r,c,posx1,posy1,posz1,posx2,posy2,posz2;
struct node{
	int x,y,z,t;
};
queue<node> q;//定义结构体队列,标配
char a[55][55][55];
inline bool check(int x,int y,int z)
{
	if(x>=1&&x<=l&&y>=1&&y<=r&&z>=1&&z<=c&&a[x][y][z]!='#') return true;
	return false;
}
inline int bfs(int x,int y,int z,int t)
{
	a[x][y][z]='#';
	q.push(node{x,y,z});
	while(!q.empty())
	{
		int xx=q.front().x;
		int yy=q.front().y;
		int zz=q.front().z;
		int tt=q.front().t;
		q.pop();
		for(int i=0;i<6;i++)
		{
			int nx=xx+dx[i];
			int ny=yy+dy[i];
			int nz=zz+dz[i];
			if(nx==posx2&&ny==posy2&&nz==posz2) return tt+1;
			if(check(nx,ny,nz))
			{
				a[nx][ny][nz]='#';
				q.push(node{nx,ny,nz,tt+1});
			}
		}
	}
	return -1;//搜完了矩阵,队列都空了还没到终点就返回-1
}
int main()
{
		cin>>l>>r>>c;
		for(int i=1;i<=l;i++)
		{
			for(int j=1;j<=r;j++)
			{
				for(int k=1;k<=c;k++)
				{
					cin>>a[i][j][k];
					if(a[i][j][k]=='S')
					{
						posx1=i;
						posy1=j;
						posz1=k;//起始层数,行与列
					}
					if(a[i][j][k]=='E')
					{
						posx2=i;
						posy2=j;
						posz2=k;//终点层数行与列
					}
				}
			}
		}
		int p=bfs(posx1,posy1,posz1,0);//可以开搜了
		if(p!=-1) cout<<"Escaped in "<<p<<" minute(s)."<<endl;
		else cout<<"Trapped!"<<endl;
		return 0;
}
```
# 


------------
## 这道题拿来练广搜很好,主要是练习仔细,不要急躁

---

## 作者：InternetExplorer (赞：6)

```
看各位都是用三维数组解的，本蒟蒻就来发一篇二维数组的解法
```
```cpp
#include<bits/stdc++.h>
using namespace std；
int main(){  
    int k,n,m,i,j,kk,nn=0,mm=0,x,y,x1,y1,p[1000][40]={0},p1[1000][40]={0},wx,wy;
    //nn为行的计数器，mm为列的计数器
    char c[1000][40];
    int f[6]={1,0,-1,0};
    int f1[6]={0,1,0,-1,0,0};
    //方向
    memset(c,'.',sizeof(c));
    queue <int> aa;
    queue <int> bb;
    cin >> k >> n >> m;
    f[4]=n;
    f[5]=-n;
    /*比如说
    3 3 3
    ...
    ...
    ... <
    
    ...
    ...
    ... <
    
    ...
    ...
    ... <
    从第6行上一层其实就是加n格，下一层就是减n格*/
    for(i=0;i<k;i++){
        for(j=0;j<n;j++){
            nn++;
            mm=0;
            for(kk=0;kk<m;kk++){
                mm++;
                cin >> c[nn][mm];
                if(c[nn][mm]=='#')
                    p1[nn][mm]=1;
                if(c[nn][mm]=='S'){
                    x=nn;
                    y=mm;
                }
                if(c[nn][mm]=='E'){
                    wx=nn;
                    wy=mm;
                }
            }
        }
    }
    aa.push(x);
    bb.push(y);
    p1[x][y]=1;
    while(!aa.empty() && !bb.empty()){
        for(i=0;i<6;i++){
            x1=aa.front()+f[i];
            y1=bb.front()+f1[i];
            if(aa.front()%n==0 && f[i]==1 || (aa.front()-1)%n==0 && f[i]==-1)
                continue;
            /*因为会有
            2 3 3 
            ...
            ...
            S..
            
            E..
            ...
            ...
            或
            ...
            ...
            E..
            
            S..
            ...
            ...
            造成一秒到达终点的情况，所以要加一个特判*/
            if(x1>=1 && y1>=1 && x1<=nn && y1<=m && !p1[x1][y1]){
                p[x1][y1]=p[aa.front()][bb.front()]+1;
                p1[x1][y1]=1;
                if(x1==wx && y1==wy){
                    cout << "Escaped in " << p[x1][y1] << " minute(s).";
                    return 0;
                }
                aa.push(x1);
                bb.push(y1);
            }
        }
        aa.pop();
        bb.pop();
    }
    cout << "Trapped!";
    return 0; 
    return 0;
}
```



---

## 作者：TsReaper (赞：5)

基础广搜题。

由于地图是三维的，我们设从出发点走到第p层，第i行，第j列的格子的最短步数为dis(i,j,k)，行走方向上由四方向改为六方向就好了，其它同最基础的四方向迷宫没有区别。


---

## 作者：little_gift (赞：4)

#一道水水的宽搜，就是多加了一维#

```cpp
#include <bits/stdc++.h> //万能头文件
using namespace std;
const int e[6][3]={{-1,0,0},{1,0,0},{0,-1,0},{0,1,0},{0,0,-1},{0,0,1}}; //六个能走的方向
char a[32][32][32],L,R,C,i,j,k,l,r,c;
queue<int>ql,qr,qc,qs; //队列，保存三个坐标以及步数
string st;
int main()
{
    scanf("%d %d %d",&L,&R,&C);
    for (i=1;i<=L;i++)
    {
        for (j=1;j<=R;j++)
        {
            cin>>st; //用字符串读入，避免回车的困扰..
            for (k=0;k<st.size();k++)
            {
                a[i][j][k+1]=st[k];
                if (st[k]=='S') //如果发现出发点
                {
                    ql.push(i);
                    qr.push(j);
                    qc.push(k+1);
                    qs.push(0); //初始化所有的队列,初始化为出发点
                }
            }
        }
    } //读入地图
    while (!qs.empty())
    {
        for (i=0;i<6;i++)
        {
            l=ql.front()+e[i][0];
            r=qr.front()+e[i][1];
            c=qc.front()+e[i][2]; //依次搜索所有能走的方向
            if (a[l][r][c]=='E') //如果发现终点
            {
                printf("Escaped in %d minute(s).\n",qs.front()+1); //输出
                return 233;
            }
            if (a[l][r][c]=='.') //如果能走
            {
                ql.push(l);
                qr.push(r);
                qc.push(c);
                qs.push(qs.front()+1); //在队尾插入新元素
                a[l][r][c]='#'; //去重
            }
        }
        ql.pop();
        qr.pop();
        qc.pop();
        qs.pop(); //队首元素出队
    }
    puts("Trapped!"); //判断未能走出的情况(第一次没看到..)
 return 666;
}
```

---

## 作者：ahhsst (赞：3)

这是一道很简单的~~DP~~好吧是bfs(~~dfs~~TLE在招手）
本质就是一个迷宫问题，但是多了一维（难度~~增加了很多~~）

~~直接看代码吧~~（蒟蒻的代码）
```cpp
#include<bits/stdc++.h>
using namespace std;
queue <int> qz,qx,qy,qs;//蒟蒻一只，不喜欢结构体····· 层 行 列 步数
int l,r,c,xx,yy,zz,qxx,qyy,qzz,a[50][50][50];
int dz[7]={0,-1,1,0,0,0,0};//可爱的增量
int dx[7]={0,0,0,-1,1,0,0};
int dy[7]={0,0,0,0,0,-1,1};
int main(){
	char x;
	int nx,ny,nz,s=1;
	cin>>l>>r>>c;
	for(int i=1;i<=l;i++)
		for(int j=1;j<=r;j++)
			for(int k=1;k<=c;k++){
				cin>>x;
				if(x=='.')
					a[i][j][k]=1;
				if(x=='#')
					a[i][j][k]=0;
				if(x=='S'){
					a[i][j][k]=1;
					qzz=i;qxx=j;qyy=k;//记一下起点
				}
				if(x=='E'){
					a[i][j][k]=2;
					zz=i;xx=j;yy=k;//记一下终点
				}
			}
	qz.push(qzz);
	qx.push(qxx);
	qy.push(qyy);
	qs.push(0);
    a[qzz][qxx][qyy]=0;//一个好习惯
	while(!qx.empty()&&s){
		 for(int i=1;i<=6;i++){//6中分支 上下左右前后······
		 	nz=qz.front()+dz[i];
		 	nx=qx.front()+dx[i];
		 	ny=qy.front()+dy[i];
		 	if(a[nz][nx][ny]){
		 		qz.push(nz);
		 		qx.push(nx);
		 		qy.push(ny);
		 		qs.push(qs.front()+1);
		 		if(a[nz][nx][ny]==2){
		 			cout<<"Escaped in "<<qs.back()<<" minute(s)."<<endl;
		 			s=0;
				 }
				a[nz][nx][ny]=0;
			 }
		 }
		 qz.pop();
		 qx.pop();
		 qy.pop();
		 qs.pop();
	} 
    if(qx.empty())//如果因为无路可走才出循环
		cout<<"Trapped!"<<endl;

	return 0;
}

```

---

## 作者：eaten_apple (赞：1)

```c
#include<bits/stdc++.h>
using namespace std;
struct tNode
{
	int x;//层 
	int y;//行 
	int z;//列 
	int step;
}q[27050];
int a,b,c,sx,sy,ex,ey,sz,ez;
int dx[6]={1,-1,0,0,0,0};//上下前后左右 
int dy[6]={0,0,1,-1,0,0};//上下前后左右
int dz[6]={0,0,0,0,1,-1};//上下前后左右
char ditu[32][32][32];//第一维表示高度，第二维表示行，第三维表示列，ditu[i][j][k]表示第i层第j行第k列 
void bfs(int sx,int sy,int sz,int ex,int ey,int ez)
{
	int l=1,r=1;
	q[l].x=sx;
	q[l].y=sy;
	q[l].z=sz;
	q[l].step=0;
	ditu[sx][sy][sz]='#';
	while(l<=r)
	{
		for(int i=0;i<6;i++)
		{
			if(q[l].x+dx[i]>=1 && q[l].x+dx[i]<=a && q[l].y+dy[i]>=1 && q[l].y+dy[i]<=b && q[l].z+dz[i]>=1 && q[l].z+dz[i]<=c && ditu[q[l].x+dx[i]][q[l].y+dy[i]][q[l].z+dz[i]]!='#')
			{
				r++;
				q[r].x=q[l].x+dx[i];
				q[r].y=q[l].y+dy[i];
				q[r].z=q[l].z+dz[i];
				q[r].step=q[l].step+1;
				if(ditu[q[l].x+dx[i]][q[l].y+dy[i]][q[l].z+dz[i]]=='E')
				{
					cout<<"Escaped in "<<q[r].step<<" minute(s)."<<endl;
					return;
				}
				ditu[q[l].x+dx[i]][q[l].y+dy[i]][q[l].z+dz[i]]='#';
			}
		}
		l++;
	}
	cout<<"Trapped!"<<endl;
}
int main()
{
	cin>>a>>b>>c;
	getchar();
/*	for(int j=1;j<=b;j++)
		gets(ditu[1][j]+1);
	for(int i=2;i<=a;i++)
	{
		getchar();
		for(int j=1;j<=b;j++)
			gets(ditu[i][j]+1);
	}*/
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=b;j++)
			cin>>ditu[i][j]+1;
	}
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=b;j++)
		{
			for(int k=1;k<=c;k++)
			{
				if(ditu[i][j][k]=='S')//如果第i层第j
				{
					sx=i;
					sy=j;
					sz=k;
				}
				else if(ditu[i][j][k]=='E')
				{
					ex=i;
					ey=j;
					ez=k;
				}
			}
		}
	}
	bfs(sx,sy,sz,ex,ey,ez);//调用函数
	return 0;
} 
```


---

## 作者：marTixx (赞：1)

没人结构体队列那我就水一发。
广搜，只是多了一维而已

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 30;

struct node
{
	int step; // 所花步数
	int l;  
	int r;
	int c;
    //坐标
}s, ss, sss;

int dx[7] = {0, -1, 1, 0, 0, 0, 0};
int dy[7] = {0, 0, 0, -1, 1, 0, 0};
int dz[7] = {0, 0, 0, 0, 0, -1, 1};

int L, R, C;
int vis[MAXN + 10][MAXN + 10][MAXN + 10];
char dungeon[MAXN + 10][MAXN + 10][MAXN + 10];

queue < node > q;

int main()
{
	cin >> L>> R>> C;
	for (int i = 1; i <= L; ++i) //++i其实比i++快
		for (int j = 1; j <= R; ++j)
			for (int k = 1; k <= C; ++k) 
			{
				cin >> dungeon[i][j][k];
				if (dungeon[i][j][k] == 'S')
				{
					s.step = 0;
					s.l = i;
					s.r = j;
					s.c = k;
					vis[i][j][k] = 1;  //记录起点
				}
				if (dungeon[i][j][k] == 'E')
				{
					ss.l = i;
					ss.r = j;
					ss.c = k;
					dungeon[i][j][k] = '.';  //记录重点并将其变为可走
				}
			}
	q.push(s);  //起点入队
	
	while ( !q.empty() )
	{
		s = q.front();
		if (s.l == ss.l && s.r == ss.r && s.c == ss.c )
		{//找到答案输出
			cout <<"Escaped in "<< s.step <<" minute(s)."<<endl;
			return 0;	
		}
			
		for (int i = 1; i <= 6; i++)
		{
			if (s.l + dx[i] > 0 && s.l +dx[i] <= L && s.r + dy[i] > 0 && s.r +dy[i] <= R && s.c + dz[i] > 0 && s.c +dz[i] <= C ) 
            //判断是否越界
				if (vis[s.l + dx[i] ][s.r + dy[i] ][s.c + dz[i] ] == 0 && dungeon[s.l + dx[i] ][s.r + dy[i] ][s.c + dz[i] ] == '.' )
                //判断能不能走
				{
					vis[s.l + dx[i] ][s.r + dy[i] ][s.c + dz[i] ] = 1;
                    //标记走过
					sss.l = s.l + dx[i];
					sss.r = s.r + dy[i];
					sss.c = s.c + dz[i];
					sss.step = s.step + 1;
					q.push(sss); //入队
				}	
		}	
		q.pop();
    }
    
    cout <<"Trapped!"<< endl;
    
	return 0;
}
```

---

## 作者：xukuan (赞：1)

三维的BFS迷宫，6个方向

字符输入记得换行


```pascal
const
 lx:array[1..6] of -1..1=(0,0,0,0,1,-1);//楼
 ly:array[1..6] of -1..1=(-1,0,1,0,0,0);//行
 lz:array[1..6] of -1..1=(0,-1,0,1,0,0);//列

var
 openy:array[0..64010] of longint;
 //可以到达的点的步数
 a:array[0..40,0..40,0..40] of char;
 //监狱地图
 openx:array[0..64010,1..3] of longint;
 //可以到达的点的坐标
 i,j,k,l,r,c,x,y,z,x1,y1,z1,x2,y2,z2,p1{头指针},p2{尾指针}:longint;
begin
 readln(l,r,c);
 for i:=1 to l do
  begin
   for j:=1 to r do
    begin
     for k:=1 to c do
      begin
       read(a[i,j,k]);//输入
       case a[i,j,k] of
        'S':begin
         x1:=i;
         y1:=j;
         z1:=k;
         a[i,j,k]:='.';
        end;//标记起点
        'E':begin
         x2:=i;
         y2:=j;
         z2:=k;
         a[i,j,k]:='.';
        end;//标记终点
       end;
      end; 
     readln;//换行
    end;
   readln;//换行
  end;

 p1:=1; p2:=1;
 openx[p1,1]:=x1;
 openx[p1,2]:=y1;
 openx[p1,3]:=z1;//初始化
 while p1<=p2 do//BFS
  begin
   for i:=1 to 6 do
    begin
     x:=openx[p1,1]+lx[i];
     y:=openx[p1,2]+ly[i];
     z:=openx[p1,3]+lz[i];//将要移动的点
     if (x=x2) and (y=y2) and (z=z2) then//到了终点
      begin
       writeln('Escaped in ',openy[p1]+1,' minute(s).');//输出，要Ctrl+C和Ctrl+V，不然很可能会打错
       exit;//直接退出
      end;
     if a[x,y,z]='.' then//这个点可以过，以此可以避开边界的判断
      begin
       a[x,y,z]:='#';//改成不能过
       inc(p2);//尾指针+1
       openx[p2,1]:=x;
       openx[p2,2]:=y;
       openx[p2,3]:=z;
       openy[p2]:=openy[p1]+1;
      end;//进入队列
    end;
   inc(p1);//头指针+1
  end;
 writeln('Trapped!');//不能达到
end.
```

---

## 作者：ljc20020730 (赞：1)

##看了下没有 pascal 的题解，就来发一发

最快的程序：

 ![](https://cdn.luogu.com.cn/upload/pic/5261.png) 

[传送门](https://www.luogu.org/record/show?rid=2109741)

这道题就是输入输出比较恶心

每一层读完，还要换行。

另外，就是多了个维度，变成3D bfs。

学过bfs就可以做；

还有就是

dx dy dz 坐标增量的取，2D时就是4个，3D加了个上下就是6个；

```cpp
      dx:array[1..6]of integer=(-1,0,1,0,0,0);
      dy:array[1..6]of integer=(0,1,0,-1,0,0);
      dz:array[1..6]of integer=(0,0,0,0,1,-1);
```
标程如下：

```cpp
type rec=record
x,y,z,step:longint;
end;
const dx:array[1..6]of integer=(-1,0,1,0,0,0);
      dy:array[1..6]of integer=(0,1,0,-1,0,0);
      dz:array[1..6]of integer=(0,0,0,0,1,-1);
var ex,ey,ez,sx,sy,sz,x,y,z,n,m,h,head,tail:longint;
    a:array[1..900]of rec;
    u:array[1..30,1..30,1..30]of boolean;
    s:string;
    map:array[1..30,1..30,1..30]of 0..1;
    f:boolean;
procedure bfs;
var i,xx,yy,zz:longint;
begin
 head:=0; tail:=1;
 while head<tail do begin
  inc(head);
  for i:=1 to 6 do begin
   xx:=a[head].x+dx[i];
   yy:=a[head].y+dy[i];
   zz:=a[head].z+dz[i];
   if (xx>n)or(xx<=0)or(yy>m)or(yy<=0)or(zz>h)or(zz<=0)then continue;
   if (u[xx,yy,zz])or(map[xx,yy,zz]=0) then continue;
   inc(tail);
   a[tail].x:=xx;
   a[tail].y:=yy;
   a[tail].z:=zz;
   a[tail].step:=a[head].step+1;
   u[xx,yy,zz]:=true;
   if (xx=ex)and(yy=ey)and(zz=ez) then begin
    f:=true; exit;
   end;
  end;
 end;
end;
begin
 readln(h,n,m);
 for z:=1 to h do begin
  for x:=1 to n do begin
   readln(s);
   for y:=1 to m do
    case s[y] of
    'S':begin sx:=x; sy:=y; sz:=z; map[x,y,z]:=1; end;
    'E':begin ex:=x; ey:=y; ez:=z; map[x,y,z]:=1; end;
    '.':begin map[x,y,z]:=1; end;
    '#':begin map[x,y,z]:=0; end;
    end;
   end;
   if z<>h then  readln;
   end;
 fillchar(u,sizeof(u),false);
 a[1].x:=sx;
 a[1].y:=sy;
 a[1].z:=sz;
 a[1].step:=0;
 u[sz,sy,sz]:=true;
 f:=false;
 bfs;
 if not f then writeln('Trapped!')
 else writeln('Escaped in ',a[tail].step,' minute(s).');
end.
```

---

## 作者：Corsair (赞：1)

###  刚才看了楼下的题解，发现在统计答案上可以优化，不需要再用一次循环统计，可以直接在队列里标记。


### 不会广搜的同学可以试着做做这题，把模板改一下就好了，只是多了一维。（~~想起当年的我是怎么学搜索的，多么痛的回忆~~）


#### 下面上代码


------------
```
#include<bits/stdc++.h>
using namespace std;

int p1,p2,p3;

int a,b,c;
//终点位置 

int ans=-1;
int fc[6]={1,-1,0,0,0,0};
int fx[6]={0,0,1,-1,0,0};
int fy[6]={0,0,0,0,1,-1};
//方向数组，不会的同学可以模拟一下。
 
char l[100][100][100];
bool check[100][100][100];
struct node
{
	int c;
	int x;
	int y;
	
	int s;//统计答案 
}q[10000000];

void work(int k1,int k2,int k3)
{
	int first=1,last=2,nc,nx,ny,ns,pc,px,py,ps;
	q[first].c=k1,q[first].x=k2,q[first].y=k3;check[k1][k2][k3]=1;
	while(first<last)
	{
		nc=q[first].c,nx=q[first].x,ny=q[first].y,ns=q[first++].s;
		if(nc==a&&nx==b&&ny==c)
		{
			ans=ns;
			//更新答案，这里很重要！！ 
			break;
		}
		for(int i=0;i<6;i++)
		{
			pc=nc+fc[i];px=nx+fx[i];py=ny+fy[i];ps=ns+1;
			if(l[pc][px][py]!='#'&&check[pc][px][py]==0&&pc>=1&&pc<=p1&&px>=1&&px<=p2&&py>=1&&py<=p3)
			{
				//注意这里是  !='#'  不是  =='.' 。要不然遇到终点时会跳过。 
				q[last].c=pc;q[last].x=px;q[last].y=py;q[last++].s=ps;check[pc][px][py]=1;
			}
		}
	}
}

void in()
{
	char ch;
	scanf("%d%d%d",&p1,&p2,&p3);
	for(int i=1;i<=p1;i++)
		for(int j=1;j<=p2;j++)
			for(int k=1;k<=p3;k++)
			{
				cin>>ch;
				l[i][j][k]=ch;
				if(ch=='E') a=i,b=j,c=k;
			}
}
 
int main()
{
	in();
	for(int i=1;i<=p1;i++)
		for(int j=1;j<=p2;j++)
			for(int k=1;k<=p3;k++)
				if(l[i][j][k]=='S')
				{
					//找到起点，开始搜索。 
					work(i,j,k);
					if(ans!=-1) printf("Escaped in %d minute(s).",ans);
					else printf("Trapped!");
					//这里一定要加个判断 。 
					return 0;
				}
	return 0;
}
```


---


# yyy2015c01挑战算周长

## 题目背景

yyy2015c01 快速的解决了问题，受到邻居们的赞许，高兴的回到家，把糖给了妈妈，吃了香喷喷的午饭，又睡了一个甜甜的午觉，感觉人生真美好。下午爸爸回到家，听说了 yyy2015c01 帮老师及邻居们解决了难题，准备带她去游乐场玩她平日最喜欢玩的跳舞机作为奖励，yyy2015c01 听了，兴奋的一蹦三尺高。

## 题目描述

游乐场里人头攒动，每台跳舞机前都围满了人，怎么办呢？人这么多，想玩上估计要等好久了，yyy2015c01 左顾右盼，突然发现一台跳舞机前面没人， “哈哈，被我发现一台没人的，赶快去……”，结果到了面前才发现这台新机器的玩法与众不同，脚下的格子随机位置显示出很多的 `X`，踩到一个格子，就要根据规则先算出它对应的周长，然后把正确周长输入机器，最后的胜利者还可以获得游乐城的免费游戏券一张，yyy2015c01 心动了，小朋友们，你们可以帮助 yyy2015c01 顺利拿到游戏券么？

游戏规则如下：

新跳舞机踏板上有许多要分析的目标，由脚踩确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的周长。新跳舞机的踏板是一个矩形的网格，里面点 `.`，表示空的地方；有大写字母 `X`，表示目标的一部分。

方格中的一个 `X` 是指一个完整的网格方形区域，包括其边界和目标本身。网格中心的 `X` 与其边界上 $8$ 个方向的 `X` 都是相邻的。任何两个相邻的 `X`，其网格方形区域在边界或拐角处是重叠的，所以它们的网格方形区域是相邻的。一个目标是由一系列相邻 `X` 的网格方形区域连接起来构成的。在网格 $1$ 中，一个目标填充了全部网格；在网格 $2$ 中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的 `X` 属于另一个目标。

yyy2015c01 总是能踩到一个 `X`，以选中包含该 `X` 的目标，记录脚踩时的坐标。行列号是从左上角开始，从 $1$ 开始编号的。一个有用的统计参数是目标的周长。 假定每个 `X` 的每条边上有一个方形的单元。

目标中不会包含任何完全封闭的孔。


## 说明/提示

$1\leq M\leq 20$，$1\leq N\leq 20$，$1\leq X\leq M$，$1\leq Y\leq N$。


## 样例 #1

### 输入

```
2 2 2 2 
XX
XX```

### 输出

```
8```

## 样例 #2

### 输入

```
6 4 2 3 
.XXX
.XXX
.XXX
...X
..X.
X...```

### 输出

```
18```

# 题解

## 作者：Alex_Wei (赞：24)

#### 主要思路：dfs（深度优先搜索）

#### 注意点：网格中心的'X'与其边界上8个方向的'X'都是相邻的，但是算周长的时候只能算上下左右4个方向

具体思路见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,x,y,ans,pd[22][22],dx[8]={-1,-1,1,1,-1,0,0,1},dy[8]={-1,1,-1,1,0,-1,1,0}; 
//pd:判断这个方格有没有被访问过，dx和dy:搜索时的方向（0-3是四个角，4-7是上下左右） 
char k[22][22];
void dfs(int a,int b)
{
	pd[a][b]=1;//标记这个方格已经被访问过 
	for(int c=0;c<8;c++){
		int d=dx[c]+a,e=dy[c]+b;
		if(d>0&&d<=m&&e>0&&pd[d][e]==0&&k[d][e]=='X')dfs(d,e);//如果这个格子没出界，没被访问过并且显示的是'X'，就访问这个格子
		if(c>3&&(d<=0||d>m||e<=0||e>n||k[d][e]!='X'))ans++;//如果方向是上下左右，并且出界了或者显示的不是'X'，周长就要+1 
	}
}
int main()
{
	cin>>m>>n>>x>>y;
	for(int a=1;a<=m;a++)
		for(int b=1;b<=n;b++)
			cin>>k[a][b];
	dfs(x,y),cout<<ans;
	return 0;
}
```

---

## 作者：TsReaper (赞：12)

一道比较容易的广搜题。

通过八方向搜索，找出题中给定X所在的连通块。在进行广搜的时候，我们可以同时统计答案。

设ans为最终答案，一开始ans = 0。当我们处理一个新的X时，ans += 4，如果该X的上下左右也存在X，那么每存在一个X，ans -= 1。之后进行八方向搜索，将周围还没有入队的X入队即可。


---

## 作者：樱式分解 (赞：11)

## 这题算法是深搜，目地是求联通块的周长。
### 求联通块需要八面搜索。
### 周长有一个特点：在边界或x旁不能走的边，注意是边。
### 于是可以轻松找了。
```cpp
#include <iostream>
using namespace std;
int n,m,ans=0,a[21][21];
int x,y;
int vis[21][21];
char p;
bool h=true;
void dfs(int i,int j){
	if(i<1 || i>n || j<1 || j>m || !a[i][j]){
        if(!h)ans++;//若不是斜角则算1条边
	return;}
	if(vis[i][j])return;//走过的就回去
	vis[i][j]=1;标记
	h=false;//边
	dfs(i+1,j);
	h=false;
	dfs(i-1,j);
	h=false;
	dfs(i,j+1);
	h=false;
	dfs(i,j-1);
	h=true;//角
	dfs(i-1,j-1);
	h=true;
	dfs(i+1,j-1);
	h=true;
	dfs(i-1,j+1);
	h=true;
	dfs(i+1,j+1);
	h=false;
	return;
}
int main(){
    cin>>n>>m>>x>>y;
    for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
        cin>>p;
		if(p=='.')a[i][j]=0;//比较喜欢用普通数组。
		else a[i][j]=1;
	}
	dfs(x,y);
	cout<<ans<<endl;
} 
```
### 第一篇题解，求过。
### 用心写题解，希望给大家带来点帮助。

---

## 作者：agicy (赞：3)

# 思路

很明显，这道题要求我们算出**点$(x,y)$所在的连通块**的**周长**。

## 连通块

我们可以使用**广度优先搜索**算法，（深度优先搜索算法也可以，但广度优先搜索算法更为简单易懂，且效率更高）。

## 周长

我们只需要**遍历整个连通块的四边**即可。

# 代码

代码如下。

```cpp
#include<stdio.h>
#include<iostream>
using std::cin;//使用cin读入自动忽略换行和空格
#include<queue>
using std::queue;//队列

bool f[21][21];
char map[21][21];
int n,m,x,y,ans,
fx[8]={0,0,-1,1,-1,-1,1,1},
fy[8]={-1,1,0,0,-1,1,-1,1};//8个方向
queue<int> Qx,Qy;//两个对联，分别为点的横、纵坐标

void BFS(void);//广度优先搜索

int main(void){
	register int i,j,k,dx,dy;//寄存器更快些
	scanf("%d%d%d%d",&m,&n,&x,&y);
	Qx.push(x),Qy.push(y);
	for(i=1;i<=m;i++)
		for(j=1;j<=n;j++)
			cin>>map[i][j];//读入
	BFS();//进行搜索
	for(i=1;i<=m;i++)
		for(j=1;j<=n;j++)
			if(f[i][j])
				for(k=0;k<4;k++){//遍历四周
					dx=i+fx[k],dy=j+fy[k];
					if(!f[dx][dy])
						ans++;
				}
	printf("%d",ans);//输出
	return 0;//结束
}

void BFS(void){
	register int i,x,y,dx,dy;//寄存器更快些
	while(!Qx.empty()){
		x=Qx.front(),y=Qy.front();
		Qx.pop(),Qy.pop();//队首出队
		f[x][y]=true;//标记
		for(i=0;i<8;i++){//八个方向
			dx=x+fx[i],dy=y+fy[i];
			if(dx<1||m<dx||dy<1||n<dy)
				continue;//越界，忽略
			else if(map[dx][dy]=='X'&&!f[dx][dy])//此处可走，元素入队
				Qx.push(dx),Qy.push(dy);
		}
	}
	return;
}
```

## [我的测评记录](https://www.luogu.org/record/show?rid=9493232)

---

## 作者：zhangyuhan (赞：3)

这道题对于我来讲很眼熟，因为它是AHOI 2012小学组最后一道题！

这道题数据范围较小，直接用DFS就可以得到正解。
AC代码奉上（里面有注释）
```cpp
#include<iostream>
using namespace std;
int ans,n,m,x,y,dir[8][2]={{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};
char wg[21][21];
void search(int x,int y)//用于寻找输入的X所在区域的所有X
{
	wg[x][y]='a';//把属于题目中输入的X所在网格变成一个题目中没有的字符，方便于统计周长
	for(int i=0;i<8;i++)
	{
		int nextc=x+dir[i][0],nextr=y+dir[i][1];
		if(nextc>=1&&nextc<=n&&nextr>=1&&nextr<=m&&wg[nextc][nextr]=='X')
            search(nextc,nextr);
	}
}
int main()
{
	cin>>n>>m>>x>>y;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>wg[i][j];
	search(x,y);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(wg[i][j]=='a')//统计周长部分
			{
				if(wg[i-1][j]=='.'||i==1)//如果X上侧是'.'或处于整个图形的边缘，就属于输入的所在区域的边缘，周长应加1。
					ans++;
				if(wg[i][j+1]=='.'||j==m)//如果X右侧是'.'或处于整个图形的边缘，就属于输入的所在区域的边缘，周长应加1。
					ans++;
				if(wg[i+1][j]=='.'||i==n)//如果X下侧是'.'或处于整个图形的边缘，就属于输入的所在区域的边缘，周长应加1。
					ans++;
				if(wg[i][j-1]=='.'||j==1)//如果X左侧是'.'或处于整个图形的边缘，就属于输入的所在区域的边缘，周长应加1。
					ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：灵光一闪 (赞：3)

这题是广搜是吧？

我还就不用广搜，我就要用深搜！~~（群众：明明是你不会广搜！！）~~

这题深搜感觉比广搜好理解，写出来的代码也特别漂亮~

```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;
int ans;
char a[233][233]={'.'};
bool vis[233][233];//这些数组开到22就够了，不过我皮（划掉
int n,m,x,y;
const int dx8[]={-1,-1,-1,0,0,1,1,1};
const int dy8[]={-1,0,1,-1,1,-1,0,1};
const int dx[]={0,0,-1,1};
const int dy[]={-1,1,0,0};
void dfs1(int x,int y){
    vis[x][y]=true;
    a[x][y]='*';
    for(int i=0;i<8;i++){//8联通DFS模板
        if(!vis[x+dx8[i]][y+dy8[i]]&&a[x+dx8[i]][y+dy8[i]]=='X'){
            dfs1(x+dx8[i],y+dy8[i]);
        }
    }
    return;
}
void dfs2(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){//遍历整个数组
            if(a[i][j]=='*'){//找到了一个
                for(int k=0;k<4;k++){//这里是4联通！
                    if(a[i+dx[k]][j+dy[k]]!='*'){//然后如果不是‘*’就可以证明这条边是边长
                        ans++;//加加
                    }
                }
            }
        }
    }
    return;
}
int main(){
    cin>>n>>m>>x>>y;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];//输入环节不解释
        }
    }
    dfs1(x,y);//首先把联通块标注一下
    dfs2();//然后算周长
    cout<<ans<<endl;//输出
    return 0;
}
```
The End

---

## 作者：sunken (赞：2)

该题用DFS深搜比较容易理解

首先用a数组存哪些格子是X，0表示'.'，1表示'X',数组预设边界，下标0--m+1，0--n+1

例2的数据转换为:

000000

001110

001110

001110

000010

000100

010000

000000

然后用DFS向八方向深搜相邻格子（a数组） ，如果为1，则表示相连，作如下处理：**数组元素置为2，继续由该点深搜。**直到全部搜完为止。最后a数组状态如下：

000000

002220

002220

002220

000020

000200

010000

000000

可以看到2为所求区域，求该区域周长，可以对每一个为2的元素判断左，右，上，下格子是否为0，若为0表示存在一段边界，周长加1。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[8]={-1,0,1,-1,1,-1,0,1};
int dy[8]={-1,-1,-1,0,0,1,1,1};
int dax[4]={-1,1,0,0};
int day[4]={0,0,-1,1};
int n,m,a[25][25],sum=0;
int bx,by;
char c;
int dfs(int x,int y){
	int nx,ny;
	a[x][y]=2;
	for (int i=0;i<8;i++){
		nx=x+dx[i];
		ny=y+dy[i];
		if (a[nx][ny]==1)dfs(nx,ny);
	}		
}

int main(){
	cin>>m>>n>>bx>>by;
	memset(a,0,sizeof(a));
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			cin>>c;
			if(c=='X')a[i][j]=1;
		}
	dfs(bx,by);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]==2){
				for(int k=0;k<4;k++){
					if(a[i+dax[k]][j+day[k]]==0)sum++;
				}
			}
	cout<<sum;	
}
```


---

## 作者：wza_whitenight (赞：2)

# 注意条理
## 慢慢搜索
### OK了
代码附上：
```cpp
#include<iostream>
using namespace std;
bool n[20][20],use[20][20];
int a,b,ans=0,sa,sb;
void run(int x,int y)
{
	//使用检查（是否访问过） 
	if(use[x][y])	return;
	else			use[x][y]=true;
	//检查周围的8个格子，如符合条件，进入运行 
	if(n[x+1][y]&&(x+1)<a)					run(x+1,y);
	if(n[x][y+1]&&(y+1)<b)					run(x,y+1);
	if(n[x-1][y]&&(x-1)>=0)					run(x-1,y);
	if(n[x][y-1]&&(y-1)>=0)					run(x,y-1);
	if(n[x+1][y+1]&&(x+1)<a&&(y+1)<b)		run(x+1,y+1);
	if(n[x+1][y-1]&&(x+1)<a&&(y-1)>=0)		run(x+1,y-1);
	if(n[x-1][y+1]&&(y+1)<b&&(x-1)>=0)		run(x-1,y+1);
	if(n[x-1][y-1]&&(x-1)>=0&&(y-1)>=0)		run(x-1,y-1);
	//检查周围的4个格子，符合条件，计算周长 
	if((!n[x+1][y]&&(x+1)<a)||!((x+1)<a))		ans++;
	if((!n[x][y+1]&&(y+1)<b)||!((y+1)<b))		ans++;
	if((!n[x-1][y]&&(x-1)>=0)||!((x-1)>=0))		ans++;
	if((!n[x][y-1]&&(y-1)>=0)||!((y-1)>=0))		ans++;
	return;
}
int main()
{
	//使用数组初始化 
	for(short i=0;i<20;i++)
		for(short j=0;j<20;j++)
		{
			use[i][j]=false;
		}
	//输入 
	cin>>a>>b>>sa>>sb;
	for(short i=0;i<a;i++)
		for(short j=0;j<b;j++)
		{
			char op;
			cin>>op;
			if(op=='.')			n[i][j]=false;
			else if(op=='X')		n[i][j]=true;
		}
	//运行 
	run(sa-1,sb-1);
	//输出 
	cout<<ans;
	return 0;
} 
```
# 重要的事情说三遍：不要抄题解，不要抄题解，不要抄题解！！！
# --------------/（忽视‘-’）
# 否则会变SHI名的！！！

---

## 作者：Suiseiseki (赞：1)

这题能用深搜，先统计这一个点四周空的格子（周长，统计在一个变量内），再遍历相邻的点。


也没什么好讲的，下面就是代码


```cpp
#include <cstdio>
char mp[25][25];
const int d[8][2]={{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{-1,1},{1,-1},{1,1}};//方向增量
int ans;
int n,m,x,y;
void dfs(int x,int y){//深搜
    if(x<1||x>n||y<1||y>m||mp[x][y]=='.'){
        ans++;
        return;
    }//统计周长
    if(mp[x][y]==' '){
        return;
    }
    int nx,ny;
    mp[x][y]=' ';//标记
    /*
    下面的解法不唯一，很多种，我分段做的
    */
    for(int i=0;i<4;i++){
        nx=x+d[i][0];
        ny=y+d[i][1];
        dfs(nx,ny);
    }//有周长的部分
    for(int i=4;i<8;i++){
        nx=x+d[i][0];
        ny=y+d[i][1];
        if(nx<1||ny<1||nx>n||ny>m){
            continue;
        }
        if(mp[nx][ny]=='X'){
            dfs(nx,ny);
        }
    }//无周长的部分
}
int main(){
    scanf("%d%d",&n,&m);
    scanf("%d%d",&x,&y);
    for(int i=1;i<=n;i++){
        scanf("%s",mp[i]+1);//读入
    }
    dfs(x,y);
    printf("%d\n",ans);//输出结果
    return 0;
}

```

---


# kkksc03考前临时抱佛脚

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。


## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。


## 说明/提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

## 样例 #1

### 输入

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 输出

```
20```

# 题解

## 作者：hmh13951417981 (赞：450)

### 贪心题:既然是算较短的时间，如果左脑所用时间少就加在左脑，如果右脑所用时间少就加在右脑


------------

```c
#include<bits/stdc++.h>
using namespace std;
int a[5],i,j,sum1,sum2,t,homework;
int main(){
    for(i=1;i<=4;i++)
        cin>>a[i];//输入
    for(i=1;i<=4;i++){
    sum1=sum2=0;//两边脑子时间清零
    for(j=1;j<=a[i];j++)
        {cin>>homework;
        if(sum1<=sum2) sum1+=homework;
        else sum2+=homework;}//哪边时间短就加在哪边
        t+=max(sum1,sum2);//取较长时间累加
    }cout<<t;//输出
    return 0;
}
```
### 满怀期待的提交后，结果有点震惊 [结果](https://www.luogu.org/recordnew/show/17877263)
### 果然，贪心不是正解
### 后来思考了一下，便感觉是dp，对于一道题只有两个状态，一是加到左脑，二是加到右脑，所以是01背包
### 这里还可以用另一个思想，将一边的脑子加到最接近一半则另一边脑子时间就是正解
```c
#include<bits/stdc++.h>
using namespace std;
int a[5],i,j,k,sum,t,homework[21],dp[2501];
int main(){
	for(i=1;i<=4;i++)
		cin>>a[i];
	for(i=1;i<=4;i++){
		sum=0;	
		for(j=1;j<=a[i];j++)
			{cin>>homework[j];//输入
			sum+=homework[j];}//总时间累加
		for(j=1;j<=a[i];j++)
			for(k=sum/2;k>=homework[j];k--)//只要是总和的一半
				dp[k]=max(dp[k],dp[k-homework[j]]+homework[j]);//01背包
		t+=sum-dp[sum/2];//累加为另一个脑子
		for(j=1;j<=sum/2;j++)
		dp[j]=0;//清零
	}
	cout<<t;//输出
	return 0;
}
```


---

## 作者：长河落日 (赞：349)

蒟蒻学不来DP所以第一反应是搜索……

看了一下数据范围

20?emmm

于是放心大胆地2^n枚举了

枚举每道题交给哪边的脑子解决，找到两边时间较大值的最小值

于是愉快地解决了……剪枝都不用放

```cpp
#include<bits/stdc++.h>
using namespace std;
int Left,Right,minn,ans;
int s[5];
int a[21][5];
void search(int x,int y){
	if(x>s[y]){
		minn=min(minn,max(Left,Right));
		return;
	}
	Left+=a[x][y];
	search(x+1,y);
	Left-=a[x][y];
	Right+=a[x][y];
	search(x+1,y);
	Right-=a[x][y];//毫无技巧的搜索回溯
}
int main(){
	cin>>s[1]>>s[2]>>s[3]>>s[4];
	for(int i=1;i<=4;i++){//减少码量
		Left=Right=0;
		minn=19260817;
		for(int j=1;j<=s[i];j++)
			cin>>a[j][i];
		search(1,i);
		ans+=minn;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Sino_E (赞：180)

本题一眼看过去，贪心。

本着大胆猜想，不用证明的原则，打了两个贪心策略交上去。

策略1：左脑若比右脑耗时多，右脑取目前最大值放入；否则左脑取目前最小值放入。看似平衡的做法，实则交上去全WA....

策略2：始终选一个耗时少的脑，将目前最大值放入；跟答案近了一点但还是错的....

emmm贪心怕是想不出来了，冷静分析。

**四个科目其实就是四组数据。考虑一个科目单独分析。**

**显然若当前要处理的问题的时间和为t，最佳答案是t/2，也就是两边脑所耗时间差为0。**

**于是现在要求的问题就是使得两边脑所耗时间差尽量小。**

于是我想到了二分，胡乱分析一番，想不出来先放一边。进一步分析。

**如果只考虑一边脑耗时，由于两边脑是对称的，我们假设这个耗时肯定比t/2小。那么我们要使这个耗时尽量接近t/2。**

**然后又想到了背包。保证比t/2小，又要使取得的价值尽量大，可以转化为一个费用与价值相同的背包问题。背包大小为t/2，一个题目的费用和价值相等，都是所耗的时间。**

**假设背包求得的最大价值为v,显然另一个脑耗时为t-v，则总耗时为max(v,t-v)。**

**四组数据按照相同方法处理。**

看了看范围：背包大小最大1200/2=600，总共20个物品，emmmm

虽然感觉总是有点问题打了代码忐忑不安的交上去，A了......原本一直以为贪心是正解的我.....

```cpp
#include<bits/stdc++.h>
using namespace std;

int len[4];
int sub[30];
int f[21][1201];

int main(){
    ios::sync_with_stdio(false);
    for(int i=0;i<4;i++) cin>>len[i];
    int tot=0;
    for(int i=0;i<4;i++){
        int v=0;
        for(int j=1;j<=len[i];j++) cin>>sub[j],v+=sub[j];
        int t1=0;
        for(int j=1;j<=len[i];j++)
            for(int k=0;k<=v/2;k++){
                f[j][k]=f[j-1][k];
                if(k>=sub[j])f[j][k]=max(f[j][k],f[j-1][k-sub[j]]+sub[j]);
                t1=max(f[j][k],t1);
            }
        tot+=max(t1,v-t1);
    }
    cout<<tot<<endl;
    return 0;
}
```

---

## 作者：早右昕 (赞：66)

####论如何简洁地写代码(二) 题解 By Plue Jheng/InfoEoR

首先理清思路:

- 1.所求最少时间即4科最少时间的总和

- 2.因为kkksc03是双核,故单科最少总时间分配给两核的时间应尽量相同

- 3.故:以单科总时间一半为界限,做01背包是所花时间尽量靠近与HALF

- 4.背包结束后 dp[HALF]总是小于等于ALL-dp[HALF],应累加较大值即后式

详见代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[5],a[5][21],tot,ALL,dp[100010];
int main()
{
    for(int i=1; i<=4; i++) scanf("%d",&s[i]);
    for(int i=1; i<=4; i++) {//采用二维数组的方式对代码进行精简 
        for(int j=1; j<=s[i]; j++){
            scanf("%d",&a[i][j]);
            ALL+=a[i][j];//统计总重 
        }
        for(int p=1;p<=s[i];p++) {//装箱问题 
            for(int q=ALL>>1;q>=a[i][p];q--) {//a>>1即a/2 
                dp[q]=max(dp[q],dp[q-a[i][p]]+a[i][p]);
            }
        }//累加最接近ALL/2的值 
        tot+=ALL-dp[ALL>>1],ALL=0;
        if(i!=4) memset(dp,0,sizeof dp);
    }
    printf("%d\n",tot);
}
```
还不错


---

## 作者：「QQ红包」 (赞：49)

输入N个数，将这N个数能够分成两组，使得两组总数最接近就是本题的解法。可以用搜索，递归，也可以用01背包。由于我太弱……所以用的深搜……


```delphi

var s1,s2,s3,s4,x,y,i,j,s,min,min2:longint;
    a:array[1..4,1..20] of integer;
procedure try(n,t,ss:longint);//深搜
begin
    if  t-1=ss then
    begin
        if abs(x-y)<min then 
        begin
             min:=abs(x-y);
             if x>y then min2:=x else min2:=y;
        end;
        exit;
    end;
    x:=x+a[n,t];
    try(n,t+1,ss);//继续搜
    x:=x-a[n,t];
    y:=y+a[n,t];
    try(n,t+1,ss);//继续搜
    y:=y-a[n,t];
end;
begin
    read(s1,s2,s3,s4);
    for i:=1 to s1 do
    read(a[1,i]);
    for i:=1 to s2 do
    read(a[2,i]);
    for i:=1 to s3 do
    read(a[3,i]);
    for i:=1 to s4 do
    read(a[4,i]);
    min:=maxlongint;try(1,1,s1);x:=0;y:=0;inc(s,min2);
    min:=maxlongint;try(2,1,s2);x:=0;y:=0;inc(s,min2);
    min:=maxlongint;try(3,1,s3);x:=0;y:=0;inc(s,min2);
    min:=maxlongint;try(4,1,s4);inc(s,min2);
    write(s);
end.

```
别人用递归写的代码（别问我为什么是别人的）其实和dfs差不多……

```delphi

var
         x:array[0..1000] of longint;
         s:array[0..1000] of longint;
         n,i,j,ansa,ansb,min,max,num,k:longint;
procedure dg(dep,a,b:longint);
begin
  if dep>s[j] then
   begin
      if abs(a-b)<min
      then
      begin
            min:=abs(a-b);
            ansa:=a;
            ansb:=b;
      end;
      exit;
   end;
  dg(dep+1,a+x[dep],b);
  dg(dep+1,a,b+x[dep]);
end;


begin
         readln(s[1],s[2],s[3],s[4]);
         for j:=1 to 4 do
         begin
                  min:=maxlongint;
                  for i:=1 to s[j] do read(x[i]);
                  dg(1,0,0);
                  if ansa>=ansb then num:=num+ansa else num:=num+ansb;
         end;
         writeln(num);

end.

```

---

## 作者：不存在之人 (赞：39)

## 时间是体积，也是价值，再跑一个n个物品，体积为m/2（m为时间总和）的01背包即可。

### 附代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define MAXN 25
#define MAXM 610
using namespace std;
int s1,s2,s3,s4;
inline int read()
{
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int work(int n)
{
	int m=0;
	int a[MAXN],f[MAXM];
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		m+=a[i];
	}
	for(int i=1;i<=n;i++)
	for(int j=m/2;j>=a[i];j--)
	f[j]=max(f[j],f[j-a[i]]+a[i]);
	return max(f[m/2],m-f[m/2]);
}
int main()
{
	s1=read();s2=read();s3=read();s4=read();
	int ans=work(s1)+work(s2)+work(s3)+work(s4);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：yzz200125 (赞：34)

记得之前做到过这道题

小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多5号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用5个小时，有的可能就只能使用3个小时。显然如果他只有两个电池一个能用5小时一个能用3小时，那么他只能玩3个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用3、3、5小时，他可以先使用两节能用3个小时的电池，使用半个小时后再把其中一个换成能使用5个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用2.5个小时），这样总共就可以使用5.5个小时，没有一点浪费。
（noi.openjudge.cn 4.6贪心 2469）

没想到这个人不能分开做题目，开始一道就必须做完

先说一下上面这道题的想法

对于每一门学科，先求出题目需要的时间的最大值，再与其他时间和作比较

1、如果一根电池就比其他所有电池时间和都长，那么最短时间就是这最长的电池持续的时间

2、如果这根电池时间比其他总和短，那么最短时间就是所有持续时间总和/2（可以证明）

于是我看到这道题的时候就直接糊了（应该很多人都是这样）

```cpp
#include<iostream>
using namespace std;
int main()
{
	int tot=0,k,i,j,s[5]={0},t[5]={0},m[5]={0};//t-时间总和，m-时间最大值 
	cin>>s[1]>>s[2]>>s[3]>>s[4];
	for(j=1;j<=4;j++)
	{
		for(i=1;i<=s[j];i++)
		{
			cin>>k;
			if(k>m[j])m[j]=k;
			t[j]+=k;
		}
		if(t[j] % 2 ==0)//这里我注意到没有小数解（其实这里暗示了不能拆开做题）所以考虑奇数偶数 
		{
			if(m[j]>=t[j]/2)tot+=m[j];//一道题就比其他时间和长（也就是大于总和的一半） 
			else tot+=t[j]/2;//小于总和的一半 
		}
		else//示例中2 3 4例结果为5，应该是4与2+3 
		{
			if(m[j]>=(t[j]+1)/2)tot+=m[j];
			else tot+=(t[j]+1)/2;
		}
	}
	cout<<tot<<endl;
}
```
只有40分

蒟蒻不会DP

只能暴力搜索，还好数据量不算太大

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int l,r,minn,tot=0;
int s[5]={0};
int a[5][21]={0};
void doit(int x,int y){
    if(y>s[x])
	{
        minn=min(minn,max(l,r));
        return;
    }
    l+=a[x][y];
    doit(x,y+1);
    l-=a[x][y];
    r+=a[x][y];
    doit(x,y+1);
    r-=a[x][y];
}
int main()
{
	int i,j;
    cin>>s[1]>>s[2]>>s[3]>>s[4];
    for(i=1;i<=4;i++)
	{
		minn=114514;
        l=0;
		r=0;
        for(j=1;j<=s[i];j++)
        {
            cin>>a[i][j];
        }
        doit(i,1);
        tot+=minn;
    }
    cout<<tot<<endl;
}
```
没有什么好解释的（我不知道什么叫剪枝太菜了）

---

## 作者：源氏可以吃吗 (赞：30)

## 典型的01背包问题
几乎是01背包模板题，无脑刷过
## 不同点
要分四次记录答案
## 坑
记牢每次一定要初始化背包数组
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[5],a[21],f[1210],ans=0;
int main()
{
    for(int i=1;i<=4;i++)
        cin>>s[i];//四个背包
    for(int k=1;k<=4;k++)//依次进行枚举
    {
        int sum=0;
        for(int j=1;j<=s[k];j++)
            
            {
                cin>>a[j];
                sum+=a[j];//记录背包大小
            }
        memset(f,0,sizeof(f));//清空背包
        f[0]=1;//初始化
        for(int i=1;i<=s[k];i++)
            for(int j=sum;j>=0;j--)
                if(f[j])//如果上一个大小可以取
                    f[j+a[i]]=1;//那么加上物品后的容量也可以取
        int tmp=sum,res;
        for(int i=0;i<=sum;i++)//枚举答案
            if(f[i]&&tmp>=abs(i-(sum-i)))
            {
                tmp=abs(i-(sum-i));
                res=max(i,sum-i);
            }
        ans+=res;//将答案记录下来
    }
    cout<<ans<<endl;
}

```


---

## 作者：Altria_Pendragon_ (赞：15)

\*P党的福利\*

这道题可以用dp的方法来做。其实和01背包差不多。

其实就是将每个科目的所有复习时间分成两部分，尽量使得两部分的总时间都接近一半。

背包结束后f[m/2]总是小于等于m-f[m/2]，要加最大值。~~这就是这道题的唯一坑点吧……~~

没学过01背包请先看看 [P2871](https://www.luogu.org/problem/show?pid=2871) ，链接放这不谢。一定要学会哦~

下面上代码：

```cpp
var
w:array[1..100000] of longint;
f:array[1..100000] of longint;
a,b,c,d,ans,i:longint;
function max(a,b:longint):longint;
begin
if a>b then exit(a)
else exit(b);
end;
procedure dp(n:longint);//dp函数，要用就拿来用
var
i,j,cnt:longint;
begin
fillchar(f,sizeof(f),0);
cnt:=0;
for i:=1 to n do inc(cnt,w[i]);
for i:=1 to n do
for j:=cnt div 2 downto w[i] do
f[j]:=max(f[j],f[j-w[i]]+w[i]);//状态转移方程
inc(ans,cnt-f[cnt div 2])//（坑点）
end;
begin
readln(a,b,c,d);
ans:=0;
for i:=1 to a do read(w[i]); readln; dp(a);
for i:=1 to b do read(w[i]); readln; dp(b);
for i:=1 to c do read(w[i]); readln; dp(c);
for i:=1 to d do read(w[i]); readln; dp(d);
writeln(ans);
end.
```

---

## 作者：Captain_Paul (赞：13)

这道题可以运用dp方法求解，建议与P1489猫狗大战配合食用，效果更佳。

这道题的目的就是将每一科目的所有数分成两部分，使得两部分的差最小。

首先，对于每一科目，用布尔类型数组f[i][j]表示i个数中取得总和j是否可行，可行则为true，否则为false。

显然，初始化使得f[0][0]=1.

本题的输入数据可以用二维数组来存储，那么状态转移方程可以表示为:f[j][k]=f[j][k]||f[j-1][k-a[t][i]]
然后我们可以从sum[t]>>1开始枚举，若f[j][i](1<=j<=n)为true，则答案为max(i,sum[t]-i)，退出函数即可。

将以上过程重复四次，累加所得答案，输出andAC！

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int f[25][1205];
int s1,s2,s3,s4,a[5][25];
int ans[5],sum[5],answer;
void dp(int t,int n)
{
    int nn;
    if (n==1) 
    {    
        ans[t]=sum[t];
        return;
    }
    memset(f,0,sizeof(f));
    f[0][0]=1;
    //if (n&1) nn=n/2+1;
    //else nn=n/2;
    for (int i=1;i<=n;i++)
      for (int j=n;j>=1;j--)
        for (int k=sum[t]>>1;k>=a[t][i];k--)
          f[j][k]=f[j][k]||f[j-1][k-a[t][i]];
    for (int i=sum[t]>>1;i>=0;i--)
      for (int j=1;j<=n;j++)
        if (f[j][i])
        {
            ans[t]=max(i,sum[t]-i);
            return;
        }
}
int main()
{
    int i,j;
    scanf("%d%d%d%d",&s1,&s2,&s3,&s4);
    for (i=1;i<=s1;i++) scanf("%d",&a[1][i]),sum[1]+=a[1][i];
    for (i=1;i<=s2;i++) scanf("%d",&a[2][i]),sum[2]+=a[2][i];
    for (i=1;i<=s3;i++) scanf("%d",&a[3][i]),sum[3]+=a[3][i];
    for (i=1;i<=s4;i++) scanf("%d",&a[4][i]),sum[4]+=a[4][i];
    dp(1,s1); dp(2,s2); dp(3,s3); dp(4,s4);
    //cout<<ans[1]<<" "<<ans[2]<<" "<<ans[3]<<" "<<ans[4]<<endl;
    for (i=1;i<=4;i++) answer+=ans[i];
    printf("%d\n",answer);
    return 0;
}
```

---

## 作者：chauchat (赞：8)

上一个dp做法

总体上保证两边差值最小，然后设tot为总重一半

最优解必然是最接近tot/2的，于是转化为装箱问题。





```cpp
#include<iostream>
using namespace std;
#include<cstdio>
#include<cstring>
int a,b,c,d,ans,tot;
int temp[5010];
int dp[100000];
int work(int k)
{
    int t = tot / 2;;
    for(int i = 1;i <= k;i++)
        for(int v = t;v >= temp[i];v--)
            dp[v] = max(dp[v-temp[i]] + temp[i],dp[v]);
    return max(dp[t],tot - dp[t]);
}
int main()
{
    cin>>a>>b>>c>>d;
    memset(temp,0,sizeof(temp));
    memset(dp,0,sizeof(dp));
    for(int i = 1;i <= a;i++)
    {
        scanf("%d",&temp[i]);
        tot += temp[i];
    }ans += work(a);
    memset(temp,0,sizeof(temp));
    memset(dp,0,sizeof(dp));
    tot = 0;
    for(int i =1;i <= b;i++)
    {
        scanf("%d",&temp[i]);
        tot += temp[i];
    }ans += work(b);
    memset(temp,0,sizeof(temp));
    memset(dp,0,sizeof(dp));
    tot = 0;
    for(int i =1;i <= c;i++)
    {
        scanf("%d",&temp[i]);
        tot += temp[i];
    }ans += work(c);
    memset(temp,0,sizeof(temp));
    memset(dp,0,sizeof(dp));
    tot = 0;
    for(int i =1;i <= d;i++)
    {
        scanf("%d",&temp[i]);
        tot += temp[i];
    }ans += work(d);
    cout<<ans;
    return 0;
}
```

---


# 自然数的拆分问题

## 题目描述

任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。


## 说明/提示

数据保证，$2\leq n\le 8$。

## 样例 #1

### 输入

```
7
```

### 输出

```
1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4```

# 题解

## 作者：_棉花糖_ (赞：924)

蒟蒻初学回溯，做了这样一道经典的题目（第一次过于自信直接提交结果编译没过？？！！）AC后翻了一下《信息学奥赛一本通》，发现书上的算法比我的快~~很多？？~~

以下是书上的算法：


```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
using namespace std;
int a[10001]={1},n;
int search(int,int);
int print(int);
int main()
{
	cin>>n;
	search(n,1);//将要拆分的数n传递给s
	return 0;
}
int search(int s,int t)
{
	int i;
	for(i=a[t-1];i<=s;i++)
		if(i<n)//当前数i要大于等于前一位数，且不超过n
		{
			a[t]=i;//保存当前拆分的数i
			s-=i;//s减去数i，s的值将继续拆分
			if(s==0)print(t);//当s=0时，拆分结束输出结果
				else search(s,t+1);//当s>0时，继续递归
			s+=i;//回溯：加上拆分的数，以便产生所有可能的拆分
		}
}
int print(int t)
{
	for(int i=1;i<=t-1;i++)//输出一种拆分方案
		cout<<a[i]<<"+";
	cout<<a[t]<<endl;
}
```

### 另：附上我的打表程序（暴力出奇迹，打表过样例）

```cpp
//打表的程序不作解释，仅供娱乐，请认真学习回溯

#include<iostream>
#include<cstdio>
using namespace std;
int n;
int main()
{
	cin>>n;
	if(n==1)printf("\n");
		else if(n==2)printf("1+1\n");
			else if(n==3)printf("1+1+1\n1+2\n");
				else if(n==4)printf("1+1+1+1\n1+1+2\n1+3\n2+2\n");
					else if(n==5)printf("1+1+1+1+1\n1+1+1+2\n1+1+3\n1+2+2\n1+4\n2+3\n");
						else if(n==6)printf("1+1+1+1+1+1\n1+1+1+1+2\n1+1+1+3\n1+1+2+2\n1+1+4\n1+2+3\n1+5\n2+2+2\n2+4\n3+3\n");
							else if(n==7)printf("1+1+1+1+1+1+1\n1+1+1+1+1+2\n1+1+1+1+3\n1+1+1+2+2\n1+1+1+4\n1+1+2+3\n1+1+5\n1+2+2+2\n1+2+4\n1+3+3\n1+6\n2+2+3\n2+5\n3+4\n");
								else printf("1+1+1+1+1+1+1+1\n1+1+1+1+1+1+2\n1+1+1+1+1+3\n1+1+1+1+2+2\n1+1+1+1+4\n1+1+1+2+3\n1+1+1+5\n1+1+2+2+2\n1+1+2+4\n1+1+3+3\n1+1+6\n1+2+2+3\n1+2+5\n1+3+4\n1+7\n2+2+2+2\n2+2+4\n2+3+3\n2+6\n3+5\n4+4\n");
	return 0;
}
```

### 既然都看到这儿了，赞一个呗（求过~）

-------------

友链：点击[这儿]进入我的Blog(https://www.luogu.org/blog/user67087/)

---

## 作者：Ensemble (赞：159)

## 来自 ~~魔芋~~ 蒟蒻的题解， 大佬勿喷～～

------------
很典型的一道**深搜**，一路搜到底得到一种方案，本次方案排列完毕后，**回溯**搜索下一方案


------------
### 奉上代码：



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n, p[11]={1}, cnt=1, m;
void print(int aa){//输出方案
	for(int i=1; i<aa; i++)
		cout<<p[i]<<"+";
	cout<<p[aa]<<endl;
}
void dfs(int a){//通过DFS得到排列， a计数
	for(int i=p[a-1]; i<=m; i++){//回溯后跳出分支
		if(i==n) continue;//防止最后一行输出n
		p[a]=i;
		m-=i;
		if(m==0) print(a);//m减完时，该方案已排列完毕，进行输出
		else dfs(a+1);//否则继续搜索
		m+=i;//回溯
	}
}
int main(){
	cin>>n;
	m=n;
	dfs(1);
	return 0;
}
```

---

## 作者：放纵ir (赞：143)

# 第一次发题解,请大佬指教
## 也是正在摸索dfs,不好请见谅
	#include<stdio.h>

	int n,a[9];

	void print(int b){//输出函数

		for(int i=0;i<b;i++){
			if(i==0){
				printf("%d",a[i]);
			}
			else{
				printf("+%d",a[i]);
			}
		}
		printf("\n");
		return ;
	}

	void dfs(int x,int y,int z){ //x为从x开始选,y为所选数字之和,z为选第z+1个数

		if(x==n)return ;//防止单独输出n
    
		if(y==n){
			print(z);
			return ;
		}
		for(int i=x;i<=n-y;i++){
			a[z]=i;//记录选的数
			dfs(i,y+i,z+1);//从i为了防止重复,按升序排列
		}
	}

	int main(){

		while(~scanf("%d",&n)){
			dfs(1,0,0);
		}
	  	return 0;
	}

---

## 作者：zhouxuanbo (赞：72)

这是一道DFS的题目。

这道题你仔细观察样例，可以发现：输出的数是从小到大的。
所以我们要有一个qs。下一次直接从qs开始枚举；

```cpp
#include<iostream>
using namespace std;
int n,a[10];
void dfs(int he,int c,int qs){
	if(he==n){
		for(int i=1;i<=c-2;i++){
			cout<<a[i]<<'+';
		}//输出。
		cout<<a[c-1]<<endl;
		return ;
	}
	if(he>n) return;//过头返回。
	for(int i=qs;i<=n-1;i++){
		a[c]=i;//记录输出。
		dfs(he+i,c+1,i);
		a[c]=0;//改回原来的0；
	}
}
int main(){
	cin>>n;
	dfs(0,1,1);
	return 0;
}
```

---

## 作者：razx (赞：40)

递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多，在竞赛中如果系统栈很小的话，过深的递归会让栈溢出。解决方法是手工模拟递归中栈的操作，将递归转化为非递归算法。
程序中，p相当于堆栈的指针，指向当前拆分的数的位置。sum为已经拆分出来的数的和，如果和小于N，则继续往下拆分，下一个拆分的数不小于前一个拆分的数；如果和等于N，则输出这一组解；如果和大于N，则返回到上一个数，并把上一个数加1后继续查找下一组解。
```cpp
//自然数拆分 - 非递归算法
#include <bits/stdc++.h>
using namespace std;

int Num[100];
int n,sum;

void Print(int k)
{
  printf("%d",Num[1]);
  for(int i=2; i<=k; i++)
    printf("+%d",Num[i]);
  printf("\n");
}

int main()
{
  cin>>n;
  Num[1]=1;
  for(int p=1; p>=1;)          //p为堆栈的指针
    if(sum+Num[p]<n)
    {
      sum+=Num[p];
      p++;                     //指向下一个数的位置 
      Num[p]=Num[p-1];         //后面的数至少不小于前面的数 
    }
    else                       //加起来的和大于等于n的情况 
    {
      if(sum+Num[p]==n && p!=1)//p!=1防止出现n=n的输出
        Print(p);              //找到一组解，输出 
      p--;                     //返回上一个数的位置 
      sum-=Num[p];
      Num[p]++;                //上一个数加1，继续寻找下一组解 
    }
  return 0;
}
```


---

## 作者：panda_wang (赞：27)

# 【题意】
### 给出一个整数 n , 输出所有加起来等于n的自然数的特定格式的字符串
# 【解决方法】
### 使用语言：C++
### 解决方案：枚举暴力，因为 n <= 8 ，所以不会超时. 写一个八重嵌套循环，分别从a赋值到g，在**每个**循环中写判断语句。
### 代码：
```cpp
#include <bits/stdc++.h>
#include <cmath>
using namespace std;
const int N = 15 ;
int n , a[N] , tmp; 

void search(int x)
{
	int a = 1 , b = 2 , c = 3 ,d = 4 , e = 5 , f = 6 ,g= 7;
	for (a = 1 ; a < 8 ; a ++)
	{
		for (b = a ; b < 8 ; b ++)
		{
        	if (a + b == x)
			{
				cout << a << "+"<<b<<endl ; 
			}
			for (c = b ; c < 8 ; c ++)
			{
            	if (a + b + c == x)
				{
					cout << a << "+"<<b<<"+"<<c<<endl ; 
				}
				for (d = c ; d < 8 ; d ++)
				{
                	if (a + b + c +d == x)
					{
						cout << a << "+"<<b<<"+"<<c<<"+"<<d<<endl ; 
					}
					for (e = d ; e < 8 ; e ++)
					{
                    	if (a + b + c +d + e == x)
						{
							cout << a << "+"<<b<<"+"<<c<<"+"<<d<<"+"<<e<<endl ; 
						}
						for (f = e ; f < 8 ; f ++)
						{
							if (a + b + c +d + e + f == x)
							{
								cout << a << "+"<<b<<"+"<<c<<"+"<<d<<"+"<<e<<"+"<<f<<endl ; 
							}
							for (g = f ; g < 8 ; g ++)
							{
								if (a + b + c +d + e + f + g == x)
								{
									cout << a << "+"<<b<<"+"<<c<<"+"<<d<<"+"<<e<<"+"<<f<<"+"<<g<<endl ; 
								}
							}
						}
					}
				}
			}
		}
	}	
} 

int main()
{
	cin >> n;
	if (n == 8)
	{
		// 打表部分省略
	}
	search(n);
	
	return 0 ;
}

}
```
# 【坑点分析】
### 1.特判：由于我们的循环语句中是小于8所以只会执行7次，所以就要打一下n == 8的情况下的表。

---

## 作者：土间太平 (赞：25)

解决方法：深度搜索+调整剪枝。问题的实质就是对输入的n进行拆分。根据样例建立的一颗如图所示的搜索树。

#图被洛谷吃了

由样例图可知，每一组数据存在两个数字，前一个数字为依次需要拆分的数字，另一个为下一拆分起点最大数值（该数值在取值过程中需要进行适当的调整，与先前所拆分的数值进行比较，取两者较小数值为再次拆分对象，即为下一层搜索对象的起始值，目的避免重复拆分数值，进行适度调整剪枝），然后对该数值进行递归处理，判断剩余的数值是否为0，是则打印，并回溯至上一层，继续该层中其他数值的拆分。不是则按序穷举当前层的所有取值，并递归深搜下一层剩余数值的拆分。

以上图拆分5=2+2+1和5=2+1+1+1为例。首先在完成前一组数值拆分恢复现场，回溯穷举至2（第一层），得第一个拆分数值2，余下的数值5-2，即为3，剩下数值3与已拆分前一个所得数值比较取较小值2（避免5再次拆分成2和3），获得拆分数值穷举范围即2-1，进入第二层搜索，首先是穷举2，获得第二个拆分数值2，计算剩余数值得1，然后递归调拆分余下的数值1，首先判断剩下的数值是否为0（完成拆分），不是，该数值与前一个拆分所得的数值2比较取小数值得1，获得该数的数值拆分范围为1-1，进入第三层搜索，取第三个拆分数值1，同时剩下的数值减去该数值得0，递归调用，拆分余下的数值0，在递归调用过程中，发现剩余数值为0，递归调用结束，即打印该拆分数即4=2+2+1，恢复现场至上一层，得剩余数值为1，再次恢复现场至上一层（第二层），得剩余数值为3，穷举下一个拆分数值1，据悉完成5=1+1+1+1+1的拆分。

【程序代码】

```cpp
program  snumber;
const maxn=50;
var a:array[0..maxn]of integer;  //用于存放拆分的数值；
  left,n:integer;变量left用于存放n拆分以后所剩下的值
  total:longint;
procedure dfs(k:integer);
var i,min:integer;
begin
  if left=0 then begin   当剩下的的值为“0”时，完成一组拆分，累加
      write(n,'=',a[1]);total:=total+1;
      for i:=2 to k-1 do write('+',a[i]);writeln;
   end
   else begin
      if left<a[k-1] then min:=left else min:=a[k-1];
      for i:=min downto 1 do begin 
         a[k]:=i;left:=left-i;
         dfs(k+1);
         left:=left+i;
      end;
   end;
end;
begin
   assign(input,'snumber.in');reset(input);
   assign(output,'snumber.out');rewrite(output);
   readln(n);a[0]:=n;left:=n;total:=0;
   dfs(1);writeln(total);
   close(input);close(output);
end.

```

---

## 作者：Ciyang (赞：17)

## 众题解中竟没有用数组作函数参数记录数据的做法
### 在此本弱用无全局变量的方法做出这道题(好像并没有什么用啊,但我强迫症能不用全局变量就不用,不知道有没有同道中人) 
**总体方法是暴力搜索+回溯,题目很简单,先分析样例,~~首先是有+号~~,后面加的数字不低于前面加的数字**
### 其他没什么好说的,直接放代码解释:


```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
void choosenumber(int numth,int total,int lastnum,int maxnum,int record[]){
//函数参数解释:
//numth为当前的加数是第几个,从1开始
//total为当前所有加数之和
//lastnum为上一个加数,毕竟当前加数>=上一个加数
//maxnum为最终之和
//record[]是数组记录所有加数的数据
	if(total==maxnum){
//判断是否当前和已经为最终值和
		for(int i=1;i<numth;i++){
//从一开始
			if(i!=1)cout<<"+";
			cout<<record[i];
		}
		cout<<endl;
		return;
	}
	else{
		int nownum[numth+1];
//再定义一个数组,标号为当前加数的个数+1
		for(int i=0;i<numth;i++){
//从0(可以从1开始)到上一次加数的个数
			nownum[i]=record[i];
//给新定义的数组逐个赋值为上一次的数据
		}
		for(int i=lastnum;i<=maxnum-total;i++){
//从上一个加数开始,到最终和-当前加数总和
			if(i==maxnum)break;
//监测i==maxnum(监测此加数是不是为最终和)防止7=7这种情况
			nownum[numth]=i;
//记录当前加数
			int nowtotal=total+i;
			choosenumber(numth+1,nowtotal,i,maxnum,nownum);
//调用自己,加数个数+1,当前加数之和,此次加数,最终和不变,现在已记录的数据
		}
		return;
	}
}
int main(){
	int n;
	cin>>n;
	int a[2]={0};
//数组标号最小为2
//记录和输出时都是从1-N,所以第0个可以随意
	choosenumber(1,0,1,n,a);
//第一次调用,初始化
	return 0;
}
```

---

## 作者：doby (赞：15)

深搜……

其实可以打表，据亲测，n<10……这数据也是醉了……

```cpp
#include<iostream>
using namespace std;
int a[10],n;
int p(int t)//打印
{
    for(int j=1;j<=t-1;j++){cout<<a[j]<<"+";}
    cout<<a[t]<<endl;
}
int js(int s,int t)
{
    if(s==0){p(t-1);return 0;} 
    for(int k=1;k<=s;k++){if((a[t-1]<=k)&&(k<n)){a[t]=k,s=s-k;js(s,t+1);s=s+k;}}//深搜
}
int main()
{
    cin>>n;
    js(n,1);
}
```

---

## 作者：封禁用户 (赞：14)

更新日志：

2020/6/7 当时写题解贴了一个无法AC的代码（格式问题），本意是防抄袭，今有人反馈，觉得会误导他人，故更新代码。

一道十分经典的$dfs$题。

[双倍经验](http://ybt.ssoier.cn:8088/problem_show.php?pid=1318)

萌新简单的思路：

先读入，定义一个$dfs$函数。

$dfs$里边，

循环枚举要拆分的数。如果$i<n$（够减），就当前的拆分数为$i$。如果$n$被拆完了，则输出。

AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001]= {1},n;
int search(int,int);
int print(int);
int search(int s,int t) {
	for(int i=a[t-1]; i<=s; i++) {
		if(i<n) {
			a[t]=i;
			s-=i;
			if(s==0) print(t);
			else search(s,t+1);
			s+=i;
		}
	}
}
int print(int t) {
	for(int i=1; i<=t-1; i++)
		cout<<a[i]<<"+";
	cout<<a[t]<<endl;
}
int main() {
	cin>>n;
	search(n,1);
	return 0;
}
```
- 为什么$dfs$中循环$i$最小为$a_{t-1}$？

因为输出要保证拆分的数必须有序，而且没有说拆分的数要相同，所以应该是$a_{t-1}$。

[完结](https://guzha0728.github.io/)

---

## 作者：变成一名fw (赞：4)

搜取每个节点，如节点没搜到，回溯；


**送上代码**
```
#include<bits/stdc++.h>

using namespace std;

int n;

int a[1000];

void dfs(int x,int h)

{
	int i;
    
	if(x==0&&h>2)
    
	{
    
		cout<<a[1];
        
		for(i=2;i<h;i++)
		cout<<"+"<<a[i];
		cout<<endl;
		return ;
	}
	for(i=a[h-1];i<=x;i++)
	{
		if(i>=1)
		{
			a[h]=i;
			dfs(x-i,h+1);
		}
	}
}
int main()
{
	cin>>n;
	dfs(n,1);
	return 0;
} 
```

---

## 作者：ljcljc (赞：4)

```cpp
#include<iostream>
using namespace std;
int num[100],n;
void print(int k)
{
    int i;
      cout<<num[1];
      for(i=2;i<=k;i++)
          cout<<"+"<<num[i];                 
      cout<<endl;
      t++;   
}
void split(int n,int m)//n是需要拆分的数，m表示拆分的位数 
{
    int r;    
    for(int i=1;i<=n;i++)//从1开始尝试拆分   
    if(i>=num[m-1])//拆分的数大于或等于前一个
    {
        num[m]=i ;// 将这个数计入结果中          
          r=n-i ;// 剩下的数是n-i
          if(r==0&&m>1)//若剩余数为0且总拆分个数大于1，则打印结果 
              print(m);
          else split(r,m+1);// 否则将剩下的数继续进行拆分
          num[m]=0;//取消本次结果，恢复初始值，进行下一次拆分即回溯
    }
}
int main()
{
    cin>>n;
      split(n,1);//从第1位数开始拆分 
      return 0;
}
```

---

## 作者：梦里调音 (赞：4)

回溯？没看到。

本蒟蒻在主程序内使用DFS做的。

因为是组合，所以我们保证后一个数大于等于前一个数。

输出是要判断：项数要大于1,（见样例）

具体算法：

	数的和大过输入的数则退栈；
    相等则输出；
    否则进栈且归零；
    最后栈顶++。
    

```cpp
#include <iostream>
using namespace std;
int main(){
	int i,j,k,p;//栈 
	int s[1001];
	int m,n;
	cin>>n;
	s[1]=1;
	p=1;
	while(p>0){
		if(s[p]>n)p--;
		else{
			int sum=0;
			for(i=1;i<=p;i++)sum+=s[i];
			if(sum==n){
				if(p!=1){
					for(i=1;i<p;i++)cout<<s[i]<<"+";
					cout<<s[p]<<endl;
				}
			}
			else if(sum<n){
				p++;
				s[p]=s[p-1]-1;
			}
            if(sum>n)p--;
		}
		s[p]++;
	}
}
```

---

## 作者：tmp27 (赞：3)

大体思路：由于题目数据极小用$dfs$做不会超时，$dfs$每一次从z开始，到x
（要拆分的数）。用$a$数组来记录拆分后的元素继续$dfs$。如要拆分的数没有了也就是$x==0$时，就输出$a$数组里所有的元素（拆分后的数）。
```
#include<iostream>
using namespace std;
int a[10],n;//数组开10以免出错
void dfs(int p,int z,int x) //p是指针、z现在最小拆分数、x是最大拆分数。
{
    
    if(x==0)//如果拆分完毕输出
    {
        if(p==2) return ;//自己不能拆分成自己，不然你删掉试试！
        for(int i=1;i<p-1;i++)//注意：p-1！
        {
            cout<<a[i]<<"+";//输出
        }
        cout<<a[p-1]<<endl;//输出最后一个

        return ;//结束
    }
    for(int i=z;i<=x;i++)//从z到x
    {
        a[p]=i;//记录下来
        dfs(p+1,i,x-i);//继续拆分
    }
    return ;
}
int main()
{
    cin>>n;
    
    dfs(1,1,n);//从1开始拆分
    return 0;
} 
```

---

## 作者：公元某年的猫 (赞：3)

可以用来作为练习dfs的题目

很经典



        

```cpp
#include<iostream>
using namespace std;
int n, a[10001], temp;//利用temp来计入数组的值 
void print() {
    int count = 1;
    while (a[count]) {
        if (!a[count + 1]) cout << a[count];//最后一次输出 
        else cout << a[count] << "+";//其它输出 
        count++;
    }
    cout << endl;
    return ;
}
void dfs(int x) {
    int i;
    if (temp == n) {//当temp的值达到要拆分的自然数的值的时候 
        print();
        return ;
    }
    for (i = 1; i < n; i++) {
        if (i >= a[x - 1]) {//算式后面的数要比前面的数大或相等 
            a[x] = i;
            temp += a[x];
            if (temp > n) {
            temp -= a[x];//防止temp数过大 
            a[x] = 0;
            break;
            }
            dfs(x + 1);
            temp -= a[x];
            a[x] = 0;    
            //回溯 
        }
    }
}
int main() {
    cin >> n;
    dfs(1);
    return 0;
}
```

---

## 作者：MR_DENGOU (赞：3)

# C语言程序，一道回溯题

# 思路如下：


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int a[10001]= {1},n,total;
void print(int t) {
    for(int i=1; i<=t-1; i++)//输出一种方案解
        cout<<a[i]<<'+';
    cout<<a[t]<<endl;
    total++;//方案数加一
}
void search(int s,int t) {
    for(int i=a[t-1]; i<=s; i++)
        if(i<n) {//当前数 i 要大于等于前 1 位数，且不超过 n
            a[t]=i;//保存当前拆分数 i
            s-=i;// s 减去数 i，s 的值继续拆分
            if(s==0) print(t);//当 s=0 时，拆分结束输出结果
            else search(s,t+1);//当 s>0 时，继续递归
            s+=i;//回溯：加上拆分的数，以便产生所有可能的拆分
        }
}
int main() {
    cin>>n;
    search(n,1);//将要拆分的数 n 传递给 s
    return 0;
}
```

---

## 作者：Sophon (赞：2)

直接递归，不想回溯，~~因为不会~~

```cpp
#include <iostream>
#include <string>
using namespace std;

void work(int total,  int temp_max, int left, string ans)
{//total是输入的待分解的目标，temp_max是当前已分解中最大的一项
//left是当前未分解完剩下的，ans是已选择的项组合成的字符串
	string copy_ans=ans;//复制一份，保证递归调用时的ans与上一次调用work时的ans一样
	if (left == 0)//如果不剩
	{
		if(ans.length()==2)//如果ans为"+n"型
			return;
		ans=ans.erase(0,1);//否则去掉ans最前面的'+'
		cout << ans << endl;
		return;
	}
	if (left < temp_max )//如果不够取
	{
		return;
	}
	for (int i = temp_max; i <= left; i++)//每次不能取超过式子中最大项，在剩下的里面分类递归
	{
		ans=copy_ans;//保证递归调用时的ans与上一次调用work时的ans一样
		ans = ans + "+"+ char('0' + i);//选取数字拼接到最后
		work(total, i, left - i, ans);//递归
	}
}

int main()
{
	int n;
	cin >> n;
	work(n, 1, n, "");
}
```
~~不知道复制一份，废了大白天~~

---

## 作者：elegy_for_end (赞：2)

```cpp
var
 a:array[0..1000] of longint;
 n,t:longint;
procedure print(t:longint);
 var i:longint;
 begin
 for i:=1 to t-1 do
  write(a[i],'+');
 writeln(a[t]);//输出一种方案解
 end;
procedure find(s,t:longint);
 var i:longint;
 begin
  if s=0 then begin print(t-1);exit;end;//当 s=0 时，拆分结束输出结果
  for i:=1 to s do
   if (i>=a[t-1]) and (i<n) then begin//当前数 i 要大于等于前 1 位数，且不超过 n
   a[t]:=i;//保存当前拆分数 i
   s:=s-i;// s 减去数 i，s 的值继续拆分
   find(s,t+1);//当 s>0 时，继续递归
   s:=s+a[t];//回溯：加上拆分的数，以便产生所有可能的拆分
   end;
  end;
 begin
 readln(n);
 find(n,1);//将要拆分的数 n 传递给 s
end.
```

---

## 作者：lin_secret (赞：2)

解决方法：深度搜索+调整剪枝。问题的实质就是对输入的n进行拆分。根据样例建立的一颗如图所示的搜索树。

每一组数据存在两个数字，前一个数字为依次需要拆分的数字，另一个为下一拆分起点最大数值（该数值在取值过程中需要进行适当的调整，与先前所拆分的数值进行比较，取两者较小数值为再次拆分对象，即为下一层搜索对象的起始值，目的避免重复拆分数值，进行适度调整剪枝），然后对该数值进行递归处理，判断剩余的数值是否为0，是则打印，并回溯至上一层，继续该层中其他数值的拆分。不是则按序穷举当前层的所有取值，并递归深搜下一层剩余数值的拆分。

以上图拆分5=2+2+1和5=2+1+1+1为例。首先在完成前一组数值拆分恢复现场，回溯穷举至2（第一层），得第一个拆分数值2，余下的数值5-2，即为3，剩下数值3与已拆分前一个所得数值比较取较小值2（避免5再次拆分成2和3），获得拆分数值穷举范围即2-1，进入第二层搜索，首先是穷举2，获得第二个拆分数值2，计算剩余数值得1，然后递归调拆分余下的数值1，首先判断剩下的数值是否为0（完成拆分），不是，该数值与前一个拆分所得的数值2比较取小数值得1，获得该数的数值拆分范围为1-1，进入第三层搜索，取第三个拆分数值1，同时剩下的数值减去该数值得0，递归调用，拆分余下的数值0，在递归调用过程中，发现剩余数值为0，递归调用结束，即打印该拆分数即4=2+2+1，恢复现场至上一层，得剩余数值为1，再次恢复现场至上一层（第二层），得剩余数值为3，穷举下一个拆分数值1，据悉完成5=1+1+1+1+1的拆分。然后这个是有错误的，只要加一个排序就可以了！！！


程序：






```cpp
const maxn=50;
var a:array[0..maxn]of longint;  //用于存放拆分的数值；
  left,n:longint;//变量left用于存放n拆分以后所剩下的值
  total:longint;
procedure dfs(k:longint);
var i,min:integer;
begin
  if left=0 then begin   //当剩下的的值为“0”时，完成一组拆分，累加
      write(a[1]);total:=total+1;
      for i:=k-1 downto 2 do write('+',a[i]);writeln;
   end
   else begin
      if left<a[k-1] then min:=left else min:=a[k-1];
      for i:=1 to min do begin
         a[k]:=i;left:=left-i;
         dfs(k+1);
         left:=left+i;
      end;
   end;
end;
begin
   readln(n);a[0]:=n;
   left:=n;total:=0;
   dfs(1);
end.

```

---

## 作者：xdc呀 (赞：1)

想法
------------


这题就是不断拆分一个数，拆到它等于0为止。
设一个rest（要拆分的数）。不断拆rest。   
PS：每个拆分后的序列中的数字从小到大排序。 
解析：后面那个数比前面的大。所以后面选数的范围在f[dep-1]~rest;  
![](https://cdn.luogu.com.cn/upload/pic/59224.png)

PS：拆分过程用递归。（DFS）

AC代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[15];
void out(int n){
    for (int i=1;i<=n-1;i++) cout<<f[i]<<'+';
    cout<<f[n]<<endl;
}
void dfs(int dep,int rest){
    if (rest==0){//rest等于0时，有了一种拆分方法；
        if(dep>2) out(dep-1);
        return;
    }else{
        for (int i=f[dep-1];i<=rest;i++){
            f[dep]=i;
            dfs(dep+1,rest-i);
        }
    }
}
int main(){
    int n;
    cin>>n;
    f[0]=1;//第一个数的范围是f[0]~rest；
    dfs(1,n);
    return 0;   
}
```

---

## 作者：VTloBong (赞：0)

# 回溯算法经典题
#### 给出一个整数n,以字典序输出所有加起来等于n的自然数组合
#### 因为 n <= 8 ，所以可以用~~打表~~回溯做。  
~~模拟几次可得：~~  
### 大体思路为：  
>不断修改一个数组，使其从  
n>>1,n-(n>>1)  
成为    
1,1,1,1,1,1......1（n个1）  
并在回溯时**逆序输出**

###  如何实现？  
>初始化:a[0]=1;  
	x=n>>1;  
	y=n-x;  
	len=1;  
对x,y依次在dfs中进行如下操作：    
1.若x-1>=a[len-1]dfs（x-1，y+1）；  
2.若x<=(y>>1)令a[len]=x,len++,dfs（y>>1,y-(y>>1);  
3.**令len++,a[len-1]=x,a[len]=y,输出整个数组**  
4.**len--**（不要忘记）  
~~正确性显然（逃~~  
参考代码：
```
#include<stdio.h>
int n,len,a[10];//
void output(){
	for(int i=1;i<=len;i++){
		putchar(a[i]+48);//输出数都是个位数，为节省时间用字符输出 
		if(i<len)putchar('+');//输出加号 
		else putchar('\n');//换行
	}
}//输出
void dfs(int x,int y){
	int h=y>>1;
	if(x-1>=a[len-1]){
		dfs(x-1,y+1);//第一步 
	}
	if(x<=h){
		a[len]=x;
		len++;
		dfs(h,y-h);//第二步 
		len--;
	}a[len]=x;len++;
	a[len]=y;
	output();//输出
	len--;
}
int main(){
	scanf("%d",&n);
	len=1;
	a[0]=1;
	int half=n>>1;//输出
	dfs(half,n-half);
	return 0;
}

---

## 作者：未来miss (赞：0)

可怕的深搜
--
本蒟蒻已经怕到不行，直接看着模板写
---
各位大佬请参考
--
代码其丑无比，见谅
---
```pascal
var
i,j,n,m,s:longint;
a:array[1..10] of longint;
procedure f(c,y,x:longint);//开始搞事情
var 
i:longint;
begin
if x=0 then
begin
for i:=1 to c-2 do
write(a[i],'+');//输出
if a[c-1]<>n then write(a[c-1]);//因为最后一个数没有加号
writeln；
end;
for i:=y to x do
if x-i>=0 then begin
a[c]:=i;
f(c+1,i,x-i);//代码之精华（个P）
end;
end;
begin
readln(n);
s:=0;
f(1,1,n);//传参数
end.
```
祝大家能AC
--

---

## 作者：龙啸空 (赞：0)

解释：
每个分支可以一路到底，输出用了一种比较小白的办法，望包涵！
```cpp
// luogu-judger-enable-o2
//o2大法好
#include<iostream>
using namespace std;
int vis[100]={1},n;
void printans(int step)
{
	for(int i=1;i<step-1;i++)
	{
		cout<<vis[i]<<"+";
	}
	cout<<vis[step-1]<<endl;
}
void dfs(int left,int step)
{
	if(left==0&&step!=2)
	{
		printans(step);
		return;
	}
	else
	{
		for(vis[step]=vis[step-1];vis[step]<=left;vis[step]++)//从上一项开始暴力搜索，保证不会重复
		{
			left-=vis[step];
			dfs(left,step+1);
			left+=vis[step];
		}
		vis[step]=1;
	}
}
int main()
{
	cin>>n;
	dfs(n,1);
	return 0;
}

```

---

## 作者：xiaofan (赞：0)

```delphi

var
 a:array[0..1000] of longint;
 n,t:longint;
procedure print(t:longint);
 var i:longint;
 begin
 for i:=1 to t-1 do
  write(a[i],'+');
 writeln(a[t]);
 end;
procedure search(s,t:longint);
 var i:longint;
 begin
  if s=0 then begin print(t-1);exit;end;
  for i:=1 to s do
   if (i>=a[t-1]) and (i<n) then begin
   a[t]:=i;
   s:=s-i;
   search(s,t+1);
   s:=s+a[t];
   end;
  end;
 begin
 readln(n);
 search(n,1);
 end.

```
很经典的一道回溯题，也很简单。


---


# 国王的魔镜

## 题目描述

国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。


## 样例 #1

### 输入

```
ABBAABBA```

### 输出

```
2```

# 题解

## 作者：CmhDL (赞：251)

这是一道很不（e）错（xin）的题目，让我们来看看。


------------
很明显，此处应要判断项链是否是回文串。我用了一个递归函数来判断回文串：
```cpp
int jc(int n){                  //n为搜索右界
	if((n+1)%2)return n+1;  //如果是奇数直接输出长度
	if(n==0)return 1;       //如果只剩1个字母直接输出1
	int l=0,r=n;            //设置左右界
	while(l<r){
		if(s[l]!=s[r])
			return n+1;//输出当前长度
		++l; --r;       //左界右移，右界左移
	}
	return jc(r);           //返回下一段最短长度
}
```
这下，main函数里就干净多了：
```cpp
string s;
int main(){
	cin>>s;
	printf("%d",jc(s.size()-1));//直接调用
	return 0;
}
```
总代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int jc(int n){
	if((n+1)%2)return n+1;
	if(n==0)return 1;
	int l=0,r=n;
	while(l<r){
		if(s[l]!=s[r])
			return n+1;
		++l; --r;
	}
	return jc(r);
}
int main(){
	cin>>s;
	printf("%d",jc(s.size()-1));
	return 0;
}
```
唠叨几句：

1、回文串标程请务必记住！！！

2、审题请务必仔细！！！

~~3、看完题解一定要点赞+评论！！！~~

---

## 作者：МiсDZ (赞：27)

本蒟蒻第二次发题解，要认真写（怕被拒）

本蒟蒻在刚开始做这题时第一反应就是递归，题目不难，但我提交了n次才过。

下面粘代码，我的代码冗长，但思路非常明确。

```cpp
#include<bits/stdc++.h>//看到大佬们都不推荐使用，但我还是会使用，因为到目前为止我还没有遇到一个与它有关的问题
using namespace std;
char a[1000010];//利用a来进行存储原始的排列顺序。
int ans=0;//ans用来记录分解的次数。
void fj(int r)//递归操作
{
    int mid=r/2;//进行分解，对半
    if(r%2==1){//如果分解后发现是奇数则不能再分解直接输出并返回
        cout<<r;
        return;
    }
    else{
        for(int i=0,j=r-1;i<mid;i++,j--){//这里是我与其他大佬方法最不同的地方了，别人直接a[i]!=a[len-i-1]，这样我认为没那么好理解，这里i从第一个数开始，j从最后一个开始往内前进。
            if(a[i]!=a[j]){//发现如果有不同则输出并返回
                cout<<r;
                return;
            }
        } 
    }
    ans++;//计数
    fj(mid);递归操作，再判断1~mid是否可以再分解
}
int main()//主函数是不是很简单明了
{
    gets(a);char t;//gets()也不推荐用，因为它会有溢出的问题。
    int len=strlen(a);//strlen(字符数组名)是输出字符串的长度，非常好用。
    fj(len); //递归
}
//理解万岁
```
对于这道题，我之所以每次都wa，一是因为在调试时写了一些输出中间值的代码，二是因为我忘记了gets()读取数组是从a[0]

读起，古人云：”吃一堑，长一智“下次不犯就好了，可怜我的AC率啊！

我的：[http://www.gyzxjtxc.icoc.me/](http://www.gyzxjtxc.icoc.me/)        [https://www.luogu.org/blog/Douglas/](https://www.luogu.org/blog/Douglas/)


---

## 作者：xh39 (赞：21)

# 我的方法是先判断是否回文，判断是否回文代码如下
```cpp
bool hw(string a){
	int n=a.size()-1;
	int i;
	for(i=n;i>=0;i--){
		if(a[i]!=a[n-i]){
			return false;
		}
	}
	return true;
} 
```
# 然后再判断是2的倍数（因为变换过程是把字符串抄2遍（有一个反着抄，但长度不变））
## 判断是否是2的倍数很简单，一句话：
```cpp
n%2==0 //如果满足条件就是2的倍数。
```
# 需要while,判断是否回文并且是2的倍数
```cpp
	while(n%2==0&&hw(a))
```
AC代码:
```
#include<iostream>
using namespace std;
bool hw(string a){
	int n=a.size()-1;
	int i;
	for(i=n;i>=0;i--){
		if(a[i]!=a[n-i]){
			return false;
		}
	}
	return true;
} 
int main(){
	string a;
	cin>>a;
	int n=a.size();
	while(n%2==0&&hw(a)){
		n/=2;
		a.erase(n,n*2);
	}
	cout<<n;
	return 0;
}
```

---

## 作者：Drifting (赞：16)

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int mirror(string s)//使用这个函数判断字符串是否是镜像的（是否是回文的） 
    {
        if(s.length() % 2 != 0)    return s.length();//若字符串s是奇数位的 ，那么此时的字符串长度就是最短长度。 
        string s1(s,0,s.length() / 2);
        string s2(s,s.length() / 2,s.length() / 2);//将原字符串s从中间分成两半。一半是s1，另一半是s2; 
        reverse(s2.begin(),s2.end());//倒置函数，相当于把字符串s2颠倒。 属于algorithm库。 
        if(s1 == s2) //判断字符串s是否是镜像的。
            return mirror(s1); //如果字符串是镜像的，再 mirror(s1) 判断 s1 是否是镜像的。 
        else return s.length();//如果字符串并不是镜像的，那么此时的字符串长度就是最短长度。 
    }
    int main()
    {
        string len;
        cin>>len;
        cout<<mirror(len);
    }

```

---

## 作者：Imakf (赞：14)

P2799 【国王的魔镜】

# **题目分析**

该题让我们读入一个字符数组（字符串），要求进行回文判断，若回文则取出回文的这一段继续进行判断，直到不回文，输出该子串的长度

例
1.ABBA|ABBA

2.AB|BA

3.AB
4.不回文，输出长度2

可见每一次的分割都在该子串中间，那么显而易见的是，若子串长度为奇数，就可不用判断了。

#### **AC代码**

```cpp
#######include<iostream>
#######include<cstdio>
#######include<algorithm>
using namespace std;
char ring[100000];
bool hw(char *a,int len){ //判断回文 本蒟蒻认为用指针还是比较方便
    for(int i=1;i<=len/2;i++){
        if(a[i]!=a[len-i+1])//注意此处的+1
        return 0;
    }
    return 1;
}
int main(){
    int i=1;
    while((ring[i++]=getchar())!=EOF);//读入项链 坑爹的是文件末尾没有'\n'所以只能用EOF判断
    ring[i]='\000';
    i--,i--;//求出项链原本的长度
            //第一个i--是把i++减掉
            //第二个i--是把EOF减掉
    while(hw(ring,i)&&!(i%2)){ //子串回文并长度为奇数
        i/=2; //将长度改为一半
    }
    cout<<i;//输出长度
    return 0;
}
```

---

## 作者：vectorwyx (赞：9)

提供一种时间复杂度为$O(n)$的解法


------------
读题，魔镜的作用抽象出来便是：

对于一个字符串，**在其后面衔接上它的逆序串**。

这个操作实际上就是镜像复制（对称）。

为了方便描述，我们不妨把得到的字符串叫作“魔镜串”。

------------
那么，“魔镜串”有什么特点吗？

由于它是由一个字符串+该字符串的逆序串得到的，

所以它的**长度为偶**，且为**回文串**


------------
继续，题目要求我们做什么？

给定一个字符串，求“原始串”最小长度

我们把魔镜的操作**逆推**一下，即：

判断该字符串是否为“魔镜串”——

	是，把它一分为二，取前半段继续逆推

	否，则它的长度就是最终答案



------------

因此，我们定义一个变量$r$，用它存储字符串的长度。

然后，用while循环不断判断当前字符串是否为“魔镜串”：

	是，r减半，继续循环
    
    不是，跳出循环
    
最后输出$r$的值就是最终答案


------------
一个字符串为“魔镜串”需满足两个条件：

长度为偶，且为回文串


------------


回文串的判断方法可以参考回文数的判断方法，即：

不断**取首尾相比较**

------------
代码如下：
```cpp
#include<iostream>
using namespace std;
int main(){
	string s;//给定的字符串
	cin>>s;
	int r=s.size();
	bool flag;
	while(r){//while循环
		flag=0;//标记是否是“魔镜串”
		if(r%2!=0){
        //长度不为偶，说明不是“魔镜串”，跳出循环
			break;
		}
		for(int i=0;i<r/2;++i){//循环取首尾
			if(s[i]!=s[r-i-1]){//一旦有不同
				flag=1;//不是“魔镜串”
				break;//跳出第一层循环
			}
		}
		if(flag){
			break;//跳出第二层循环
		}
		r>>=1;//等价于r/=2，但速度更快
	}
	cout<<r;
	return 0;
}
```


---

## 作者：开挂老司机 (赞：9)

### 简单的dfs+字符串
废话少说先上代码：
```
#include<iostream>
#include<cstring>//字符串头文件
using namespace std;
string s;
void dfs(string s1)//深搜函数
{
	if(s1.length()%2==1)//如果字符串长度为奇数
	{
		cout<<s1.length()<<endl;//输出字符串长度
		return ;//退出函数
	}
	int h=0,t=s1.length()-1;//头尾指针
	while(h<t)//当头小于尾
	{
		if(s1[h]!=s1[t])//如果头尾指针指向的字符不同
		{
			cout<<s1.length()<<endl;//输出字符串长度
			return ;//退出函数
		}
		h++;//头指针加
		t--;//尾指针减
	}
	dfs(s1.substr(0,s1.length()/2));//递归
}
int main()
{
	getline(cin,s);//整行读入，比较快
	dfs(s);//开始搜索
	return 0;
}
```
跪求各位大佬给个赞qwq

#  _orz_ 

---

## 作者：Djsknjnd (赞：6)

一道题干很SAO的题目          
实际上就是判断回文字符串的题目           
用递推判断直到找到一个非回文串就行       
那么这里还有一个要注意的地方        
这个回文串一定是偶数串  
我们来看看题目  
把任何接触镜面的东西变成原来的两倍  
也就是说接触到镜面的那个字符也要被复制下来  
所以我们就需要把奇数串排除掉
代码如下

----------迷人的分割线----------

```cpp
program kingsmirror(input,output);
 var           //这里的数据范围一定要注意  
  s:ansistring;//定小了就只有80         
  i,l:longint;
  p:boolean;
 begin
  read(s);
  l:=length(s);
  p:=true;//先默认是偶数回文串
  while ((l mod 2)=0) and p do
   if (l mod 2)=1 then begin//奇数串就直接输出长度
                        write(l);
                        exit
                       end
    else begin
          for i:=1 to l do
           if s[i]<>s[l-i+1] then begin
                                   p:=false;//不是回文就改变布尔变量
                                   break
                                  end;
          if p then l:=l div 2
         end;
  write(l)
 end.
```

---

## 作者：wpy233 (赞：5)

这题似乎不需要用什么乱七八糟的递归和DFS？

直接模拟一下，二分得出答案就行了。。。

①判断当前字符串的长度是不是单数。如果是，直接输出并终止程序；

②判断左右lft和rgt指向的字符是不是相等。如果不是，直接输出并终止程序。

③判断lft和rgt是不是已经搜完了字符串。（lft>rgt）如果是，二分，继续搜索。

Tips:不过有一个坑，就是while里不能continue，害偶一开始还WA了两个点。。。

④lft++,rgt--;
*****
至于其它的注意事项，*详见代码*
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
string a;//输入的字符串
int main()
{
	cin>>a;//输入
	int lft=0,rgt=a.size()-1;//lft和rgt指针初始化
	int s=a.size();//当前的字符串长度
	while(1)//开一个死循环
	{
		if(s%2||a[lft]!=a[rgt])//点①和点②
		{
			cout<<s<<endl;//直接输出当前的字符串长度
			exit(0);//终止程序
		}
		if(lft>rgt)//点③
		{
			s/=2;//字符串长度/2
			lft=-1;//好坑啊。。。因为下面要执行，所以lft=0-1=-1
			rgt=s;//因为下面要执行，所以rgt=s-1+1=s
		}
		lft++;//左指针右移
		rgt--;//右指针左移
	}
    return 0;
}

---

## 作者：封禁用户 (赞：5)

## 数组开大点

~~这题老师给我们出在了模拟赛里，当时很多人都是骗分的。。~~

首先，我们要考虑一点：

怎么样的字符串不是最初的项链？

这个$01$串必须具备两个条件：

1. 它的长度是一个偶数
1. 它是一个回文串

回文串就是左边读和右边读一模一样的字符串。

我们可以定义变量$l,r$，每次枚举左端点和右端点，来判断当前的$01$串是否为回文串。

具体代码如下：

```cpp
bool f(int x) {
	int l=0,r=x-1;
	while(l<r) {
		if(a[l]!=a[r]) return 0;
		l++;
		r--;
	}
	return 1;
}
```

如果$a_l!=a_r$，那么就不是一个回文串，$return 0$。

如果$while$循环结束，当前函数仍在执行，说明这是一个回文串，$return 1$。

然后就比较好办了，$main$ $code$：

```cpp
int main() {
	scanf("%s",a);
	len=strlen(a);//求出长度
	if(len%2==1) {//如果长度不是偶数，就是初始状态的项链
		printf("%d\n",len);
		return 0;
	} else {
		while(len%2==0 && f(len)==1) {//要求长度是偶数并且是一个回文串
			len/=2;//切成两半
		}
	}
	printf("%d\n",len);//输出初始状态的项链长度
	return 0;
}
```

>PS:字母数$≤100000$

---

## 作者：Cplayer (赞：2)

我来写个C代码吧

本弟弟C只学了一个月，写的不好还望见谅

~~但是已经够浅显了~~

其实这题题意很有意思 无论怎么接触镜面 最开始的那一段必然是头尾

那么只要用递归往前推就行了

还有就是如果推到奇数，可以直接返回，这时一定是最开始的那一段了
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

char str[100001];
int length;
bool flag = false;

int solve(int length){
    if (length % 2 != 0){	//判断是否为奇数
        flag = true;
        return length;
    }
    bool cycle = true;
    for (int i = 0; i < length / 2; i++){
        if (str[i] != str[length - i - 1]){
            cycle = false;	//判断是否可以回文
        }
    }
        if (cycle) solve(length / 2);	//这里如果是回文就不return了直接进行递归，避免麻烦
        else return length;
}


int main(void){
    scanf("%s", str);
    length = strlen(str);

    printf("%d", solve(length));
}

```
最后我想说的是希望自己明年再来看自己的代码会觉得很烂


---

## 作者：飞翔 (赞：2)

此题还是很简单的，只是注意数据范围哦。

```pascal
var
  s,s1:string;
    len:longint;
function fct(x:string):boolean;//判断回文
var
  j,n:longint;
begin
  n:=length(x);
  for j:=1 to n div 2 do
      if x[j]<>x[n-j+1] then exit(false);
    exit(true);
end;
begin
  read(s);
    while length(s) mod 2=0 do//如果项链个数是奇数还怎么分割
    begin
      if not fct(s) then break;
        len:=length(s);
        s1:=copy(s,1,len div 2);
        s:=s1;//继续分割
    end;
    write(length(s));
end.
```
注：如果你把我的程序复制上去，应该得80分。至于为什么，请看数据范围。


---

## 作者：焚魂 (赞：1)

其实对于我来说，我不是特别擅长递归，所以我特地搜索了递归的题来做。
我用循环和递归分别做了一遍，其实我觉得自己递归做的不是很好，但是还是3ms过了，上代码：
1.循环
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	char a[100010];
	cin>>a;
	int la=strlen(a);
	//cout<<la<<endl;
	if(la%2!=0)//如果长度不是2的倍数，那么肯定没有被魔镜照到过。
	{
		cout<<la;
		return 0;
	}
	else
	{
		do
	{
		int tl=la,tt=la;
		tl=tl/2;
		tt=tt/2-1;
		while(tt>=0&&tl<=la)//从头到尾找，类似于判断回文
		{
			if(a[tt]!=a[tl])
			{
				cout<<la;
				return 0;
			}
			tt--;
			tl++;
		}
		la/=2;
		if(la==1)
		{
			cout<<la;
			return 0;
		}
		if(la%2!=0)
		{
			cout<<la;
			return 0;
		}
	}while(la>=1);
	}
}
```
好了，接下来是递归代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void dfs(int l);
char a[100010];
int main()
{
	cin>>a;
	int la=strlen(a);
	dfs(la);
	return 0;
}
void dfs(int l)
{
	int tl=l,tt=l;
	tl=tl/2;
	tt=tt/2-1;
	while(tt>=0&&tl<=l)
		{
			if(a[tt]!=a[tl])
			{
				cout<<l;
				return;
			}
			tt--;
			tl++;
		}
	if(l%2!=0)
	{
		cout<<l;
		return;
	}
	if(l==1)
	{
		cout<<l;
		return;
	}
	else
	dfs(l/2);
}
```
我这个递归其实就是根据上面那个循环改过来的，很好理解吧。
好了，继续刷题去了，拜拜~~~

---

## 作者：听取TLE声一片 (赞：1)

这道题真的很水。~~楼下大佬为什么写的那么复杂~~

其实这道题不需要递归，但是我~~为了偷懒~~用了函数。

下面是我的思路：

我们可以看出，开始时，项链一定是不回文的，是因为只要镜像一次，项链一定回文。所以，只要每次取半，直到不回文，输出长度即可。

代码：

```cpp
#include<iostream>//头文件
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
using namespace std;
string a;//字符串
int pd(string x){//判断回文函数
	if(x.length()%2==1)//这个很重要，值至少4个点
		return 0;
	for(int i=0,j=x.length()-1;i<x.length();i++,j--)
		if(x[i]!=x[j])
			return 0;
	return 1;
}
void cut(){
	string b;//截半函数
	for(int i=0;i<a.length()/2;i++)
		b.push_back(a[i]);
	a=b;
}
int main()
{
	cin>>a;
	while(pd(a))//循环
		cut();
	cout<<a.length();//输出
	return 0;
}

```

---

## 作者：Scarlet_Lightning (赞：1)

# 思路：

1. 先读入整个字符串
2. 判断该字符串是否回文（我这里用的是最土的方法）
3. 把该字符串截半，对剩余部分继续重复以上操作
4. 直到该字符串不是回文字符串，输出当前长度

###  就这么简单

## CODE

```cpp
/*language:C++  0.53KB*/
/*Time:0ms  Memory:2109KB*/
#include<iostream>
#include<cstring>
using namespace std;
char xl[1000001];
bool hw(int l)//判断是否回文的函数
{
    int i=0,j=l-1;bool flag=true;
    while(i<=j)//两个指针，一个从左往右扫，一个从右往左扫，如果两个指针对应的值全部相等，那么该字符串是回文的
    {
        if(xl[i]!=xl[j])
        {
            //cout<<"i="<<i<<" j="<<j<<" xl[i]="<<xl[i]<<" xl[j]="<<xl[j]<<endl;
            flag=false;
            break;
        }
        
        else 
        {
            //cout<<"i="<<i<<" j="<<j<<" xl[i]="<<xl[i]<<" xl[j]="<<xl[j]<<endl;
            i++;j--;	
        }
    }
    return flag;
}
int main()
{
    cin>>xl;
    int len=strlen(xl);
    while(hw(len)&&len%2==0)//如果当前字符串为回文字符串且还能进行截半操作
    {
        len/=2;//截半
    }
    cout<<len<<endl;//输出答案即可
    return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：1)

虽然这一道水题我第一次就写对了。。。

然而还是有必要写一篇 题解 让那些刚入门（坑）的同学看一看，学递归。

附注释的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
char a[100010];
bool check(int x){//判断是否是左右对称
     for(int i=1;i<=x/2;i++)if(a[i]!=a[x-i+1])return true;//拆成两半，对比，若不是左右对称，返回 true
     return false;
}
void work(int x){
     if(x%2){//如果长度为奇数，则 打印出答案 并 跳出递归 ，当然有可能用不到，不过还是加上的好。。。
            printf("%d\n",x);
            return;
            }
     if(check(x)){//如果不是左右对称，则 打印出答案 并 跳出递归 
                  printf("%d\n",x);
                  return;
                  }
     else work(x/2);//否则 拆成两半 继续递归
}
int main(){
    scanf("%s",a+1);//习惯下标从 1 开始
    n=strlen(a+1);//字符长度
    work(n);
    return 0;
}

```

---

## 作者：_Eterna1 (赞：1)

刚转C++对字符串之类还不是很熟悉

只好用P。。。


```cpp
var
  s:ansistring;  _ //100000的字母string存不下用ansistring_
  len:longint;
function pd:boolean;  _//判断剩下的一段项链是不是复制出来的_
var
  i:longint;
begin
  if(len mod 2=1)then exit(false);          _//因为是从镜子里复制出来所以长度一定是2的整数倍 如果项链长度是奇数肯定就是最初长度_
  for i:=1 to(len div 2)do
    if(s[i]<>s[len-i+1])then exit(false);          _//与判断回文数类似 两端不相等就返回假_
  exit(true);                                      _//循环顺利结束返回真_
end;
begin
  read(s);
  len:=length(s);
  while(pd=true)do len:=len div 2;                _ //如果可以分割 就继续判断剩下的一半_
  writeln(len);                                        _  //输出最后不可分割的长度_
end.

```

---

## 作者：Preccc_LHW (赞：1)

>###**\_本质上与判断回文相同。不用递归，循环就行。\_**

>###**\_用一个循环不停地恢复，每次取一半，终止的条件（不能再恢复了）是：\_**

>###**\_（长度变为了奇数 ||（或） 不对称了）就输出当前长度。\_**

放两行代码


```cpp
#include <iostream>
#include <string>
using namespace std;
int a,l;
string s;
void dg(){if(a%2==1)return;l=1;for(int i=0;i<a/2;i++){if(s[i]!=s[a-i-1]){l=0;break;}}if(l==1){a/=2;dg();}return;}
int main(){getline(cin,s);a=s.size();dg();cout<<a;return 0;}
```

---

## 作者：_xcc_ (赞：1)

本质上与判断回文相同。不用递归，循环就行。

用一个循环不停地恢复，每次取一半，终止的条件（不能再恢复了）是：

（长度变为了奇数 ||（或） 不对称了）就输出当前长度。 
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
    char a[100002];
    int l,i;  //l：当前项链长度。i：循环变量。 
    cin>>a;
    l=strlen(a);  //求当前项链长度。 
    while(1)  //此循环用来不停地折半 
    {
        if(l%2==1){  //判断奇偶 
            cout<<l<<endl;
            return 0;
        }
        for(i=0;i<l;i++)  //此循环用来确定是否对称 
        {
            if(a[i]!=a[l-i-1]){
            cout<<l<<endl;
            return 0;
            }
        }
        l/=2;  //折半恢复一次 
    }
}
```

---

## 作者：龙尊下凡 (赞：1)

很简单的一道题

(⊙v⊙)嗯！！！

其实方法和楼下C++有点相像

就是先判断字符串长度是奇是偶

如果是奇，那么直接输出此时长度，如果是偶，选取一半长度，前后依次对应看是否一样

如果一样，那么选取一半继续判断，否则直接输出此时长度

以下是代码：

```cpp
var
s:string;
procedure p(v:string);
 var
  k,q:longint;
 begin
 if length(v) mod 2=1 then writeln(length(v)) else begin
  q:=length(v) div 2;
  for k:=1 to q do
   if v[k]<>v[length(v)-k+1] then begin writeln(length(v));halt; end;
  v:=copy(v,1,q);
  p(v);
  end;
 end;
begin
 readln(s);
 p(s);
end.
```
**千万不要直接抄我的题解，否则只有80**
**至于为啥，自己想！！！**

**严禁抄袭**(⊙v⊙)嗯


---

## 作者：1jia1 (赞：1)

这题其实蛮简单的……有点想搜索or分治题……

思路楼下lzh已经说得蛮清楚了，所以……我就再说一遍吧。

核心思路：先看看当前的字符串是不是对称的，如果是，那么就截前半段，然后继续判断……最后剩下来的就是答案啦。其实输出项链一开始的样子都很容易的。

来吧，戴马（划掉）代码

```cpp
-#include <iostream> -
-#include <string>-
-using namespace std;-
-int a,l;-
-string s;-
-void dg()---递归
-{-
-    if(a%2==1)return;---如果当前字符串长度为奇数，说明它的生命已经到了尽头了（划掉）说明它已经到最小了，所以就结束。
-    l=1;---判断变量
-    for(int i=0;i<a/2;i++)-
-    {-
-        if(s[i]!=s[a-i-1]){l=0;break;}---如果不对称，那就标记
-    }-
-    if(l==1)---如果对称
-    {-
-        a/=2;---截一半
-        dg();---递归
-    }-
-    return;-
-}-
-int main()-
-{-
-    getline(cin,s);-
-    a=s.size();---记下s的长度
-    dg();---递归
-    cout<<a;-
-    return 0;-
-}-
```

---

## 作者：浅沐 (赞：0)

## c++题解

### 解决方法：递归

### 解决思路：

这个题只要利用镜子的对称性就可以了

将项链长度n二分，镜子中项链的分成两部分，前一部分从第一颗珠子数到第n/2，后一部分从第n颗数到n/2，不一样的话就是不对称。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
string a;
int cnt;

int dfs(int num)
{
	cnt=0;
	int mid=num/2;
	if(num%2==1) return num;
	else
	{
		for(int i=0;i<mid;i++)
			if(a[i]==a[num-(i+1)])
				cnt++;
		if(cnt==mid) dfs(num/2);
		else return num;
	}
}

int main()
{
	cin>>a;
	printf("%d",dfs(a.length()));
	return 0;
}
```

---

## 作者：right_cat (赞：0)

其实这道题没有想的那么复杂，我的思路比较暴力，可以先把输入的字符串s的前半部分倒转后赋给s1，后半部分赋给s2，再将s1与s2比较，如果相同就递归，如果不同就输出s的长度即可。

代码实现：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
void solve(string s)
{
    int lens=s.length(); //先求出s的长度
    string s1,s2;
    for(int i=lens/2-1;i>=0;i--)
        s1+=s[i]; //将s的前半部分倒转后赋给s1
    for(int i=lens/2;i<lens;i++)
        s2+=s[i]; //将s的后半部分赋给s2
    if(s1==s2) solve(s1); //如果两者相同就继续递归
    else
    {
        cout<<lens<<endl; //否则直接输出最初的项链可能的最小长度
        return; //然后结束
    }
}
int main()
{
    string s;
    cin>>s; //输入字符串
    solve(s); //调用函数
    return 0; //结束程序
}

```

---

## 作者：MyukiyoMekya (赞：0)

本蒟蒻的题解和楼下大佬的Imakf的题解有些类似，但本蒟蒻觉得楼下的代码对新人有些不友好（while读入），所以就写了这篇比较适合新手的题解

算法的核心是怎么判断这个字符串是回文字符串

先来看样例：ABBAABBA

那我们就是要比对

0-7 

1-6 

2-5 

3-4

实际上就是比对字符串的0位到len/2-1位和末位到len/2位的字符是否相同

在这里就是比对0-3位和7-4位是否相同

于是核心代码就出来了
```cpp
bool pd(int len)
{
	if(len&1)
		return false;
	for(int i=0;i<len/2;++i)
		if(a[i]!=a[len-i-1])
			return false;
	return true;
}
```
完整代码如下：
```cpp
#include<stdio.h>
#include<string.h>
using namespace std;
char a[100001];		//字符串，要定义成全局，否则在判断函数里要加指针
bool pd(int len)		//判断是否回文（被魔镜复制过）
{
	if(len&1)			//等价于if(len%2==1)
		return false;		//如果字符串长度为奇数，那绝对不是回文字符串
	for(int i=0;i<len/2;++i)	//暴力比对，由于i=0时也会比对第7位，所以除以二降低复杂度
		if(a[i]!=a[len-i-1])	//比对第一个-倒数第一个、第二个-倒数第二个......
			return false;		//如果比对出现错误，这就不是回文字符串了
	return true;		//比对完后还没发现错误，说明这是回文字符串
}
int main(void)
{
	int len;
	scanf("%s",a);
	len=strlen(a);
	while(len!=1)		//如果字符串只剩一个字符了，那就直接输出
		if(pd(len))		//判断a是不是回文字符串
			len/=2;		//如果是，不用删除字符什么的，直接长度减半
		else			//如果不是了，那就退出，输出现在长度
			break;
	printf("%d",len);	//输出长度
	return 0;
}
```

---

## 作者：Mitsui (赞：0)

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100100];
int whether(int m)
{
	if(m%2)
		return m;//判断是否为奇数，奇数直接跳出 
	int mid=m/2;//查找中间数，从两边开始往中间查找 
	for(int i=0;i<mid;i++)
		if(a[i]!=a[m-1-i])//判断是否为回文，不是的话就跳出 
			return m;
	return whether(mid);//递归 
}
int main()
{
	cin>>a;
	int l=strlen(a);//字符串长度 
	cout<<whether(l);
}
```

---

## 作者：清风我已逝 (赞：0)

字符串模拟题


啊啊啊，这水题我竟然提交了四次，伤感情啊

水题也是有坑的（质量派，良心出题人啊）

简单思路：

从两边向中间判断，若可行，字符串长度/2，继续进行

需要特判两个条件：

	1.l=0时，如输入：A 会陷入死循环，特判
    2.l%2==1时，如输入ABA ，上述条件仍然成立，但实际并不符合要求，特判当l%2==1时就break掉，或是if(i==j&&l%2!=0) tp=1;

奉上代码：

```cpp
#include<iostream>
#include<string>

using namespace std;
string s;
int tp,i,j,l;
int main()
{
	cin>>s;
	l=s.length()*2;
	while(tp!=1){
		 l/=2;
		 for(i=0,j=l-1;i<=j;i++,j--){
		 	if(s[i]!=s[j]) tp=1;
		 	if(i==j&&l%2!=0) tp=1;
		 }
		 if(l==0){l=1;break;}
	}
	cout<<l;
	return 0;
}
```

---

## 作者：_Qer (赞：0)

### 想了想，这题其实还是递归容易，做起来不算麻烦吧。

#### 主要思路就是反着模拟变项链的过程，一次一次切，直到发现当前项链不是回文，返回当前的长度（最小长度）。

```cpp
#include<string>
#include<cstring>     
//以上两个头文件是因为需要string以及和字符串有关的函数
#include<iostream>
#include<algorithm>   
//这个是需要reverse字符串倒置函数
using namespace std;
int f(string str,int len){
	//递归函数，两个参数一个是当前项链，另一个是当前长度
    string a(str,0,len/2);
    //这是当前项链前半段，直接从当前项链中“切”过去
    string b(str,len/2,len);
    //当前项链后半段，也是“切”过去的
    reverse(b.begin(),b.end());
    //因为魔镜生成的是倒的，所以用reverse把它倒过去
    if(a==b&&len%2==0){
    //如果这是回文的并且当前项链长度为奇数（不然没法切啊）
        return f(a,len/2);
        //把前半段作为当前项链，长度减半继续递归
    }else{
        return len;
        //当前不是回文，直接返回长度
    }
}
int main(){
    string s;
    cin>>s;
    //不要gets!!
    int l=s.length();
    //项链长度
    cout<<f(s,l);
    //这个递归函数是有返回值的，不在递归函数里输出，所以这样写
    return 0;
}
```

---

## 作者：laduiw (赞：0)

水题一道 大家写的太长了，直接while，直到l为基数或者字符串不为回文串（l为字符串长度，可以用函数简单快捷），每次l/=2，最后直接输出l即可，不懂看以下注释。。。


附上AC c++代码


```cpp
#include<bits/stdc++.h>//黑科技
using namespace std;
char s[100010];
int l;
int pd(int x,int y)//判断x到y区间是否回文
{
    int m=(y-x+1)/2,p=0; 
    for (int i=x;i<=m;i++) //判断回文只需前一半与后一半比较，所以循环到(y-x+1)/2即可 
        if (s[i]!=s[y-i]) {
            p=1;break;//一旦不回文直接跳出
        }
        return p;
}
int main()
{
    gets(s);//读入
    l=strlen(s);//函数求长度
    while (pd(0,l-1)==0 && l%2==0)//注意字符串是从零开始，所以l-1，直到l为基数或者字符串不为回文串
     l=l/2;
    cout<<l<<endl;
}
```

---

## 作者：detect (赞：0)

经典递归，判断类似回文数。

具体见代码注释-------

```cpp
#include<iostream>
#include<cstring>//库
long long n;
int y=0;int x;//全局定义！
char a[1000001];//小心题目！
using namespace std;
int dp(char a[]);//设定函数dp（）
int main()
{
     cin>>a;
     n=strlen(a);
     dp(a);
     cout<<n;
     return 0;
}
int dp(char a[])
{
        int n1=n;
        if(n%2==1)
        return n;//判断递归边界1！
        else
        {
           for(int i=0;i<n/2;i++)
           if(a[i]!=a[n-1-i])
           {
               y++;//用y判断回文
           }
           if(y==0)
           {
                n=n/2;    
                return dp(a);//递归
           }    
           else
           return n;//判断递归边界2！
        }
}

```

---

## 作者：鹭天 (赞：0)

#一题模拟

##但是需要找到相应的条件，才能完成这道题目

###如果条件没达到，就一直做，直到做到条件符合了为止

那么条件如下：

1、因为题目上说是将魔镜扩大两倍，所以我们可以将一个字符串分成两个部分，不过，另一部分是反的，所以我们要倒的看。如果这两部分不相同，那么就可以退出；反之，继续做

2、当长度为奇数的时候，退出；反之，继续做

#注：当一个条件满足的时候就可以退出，但只有两个条件都未满足的时候才能继续做。

代码如下:

```cpp
  var
  i,j,n,m,k:longint;
  s,s1,s2:ansistring;
begin
  readln(s);
  n:=length(s);
  while true do begin//如果条件为满足，就一直做
    if odd(n) then break;//如果长度为奇数，就退出
    s2:='';//s2为倒的数(因为倒得往前累加不能拷贝(copy)，所以只能用for循环，那么累加之前就要清空
    s1:=copy(s,1,n div 2);//第一部分
    for i:=n downto n div 2+1 do s2:=s2+s[i];//第二部分
    if s1<>s2 then break;//如果不相等，就退出循环
    n:=n div 2;//再进行分区
  end;
  write(n);
end.
```

---

## 作者：guobaipeng0 (赞：0)

献上pascal程序


```cpp
var a,b,st:ansistring;
  i,t:longint;
begin
  readln(st);
  t:=length(st);  //测长度
  if t mod 2=0 then  //判断是否能还原，如果是奇数，就证明没有使用国王的魔镜
  begin
    repeat
      if t mod 2=0 then  //判断是否能够进行还原项链
      begin
        a:=copy(st,1,t div 2);  //将前面的存到a里，准备还原
        for i:=length(st) downto t div 2+1 do b:=b+st[i];  //将后面的存到b里
        if a=b then begin t:=t div 2; st:=copy(st,1,t); b:=''; end else begin writeln(t); exit; end;
        //如果能进行还原长度，就还原；否则输出最终长度，退出
      end;
      until t mod 2<>0; //直到不能缩减
    writeln(t); exit;  //输出最终长度
  end;
  writeln(t);  //输出
end.
```

---


# 回家

## 题目描述

[](https://paste.ubuntu.com/p/DSg5bzrrjs/)

小 H 在一个划分成了 $n \times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。

地图上有五种格子：

`0`：障碍物。

`1`：空地， 小 H 可以自由行走。

`2`：小 H 出发点， 也是一片空地。

`3`：小 H 的家。

`4`：有鼠标在上面的空地。

小 H 能否安全回家？如果能， 最短需要多长时间呢？


## 说明/提示

对于所有数据，$1 \le n,m \le 9$。

2021.9.2 增添一组 hack 数据 by @囧仙

## 样例 #1

### 输入

```
3 3
2 1 1
1 1 0
1 1 3```

### 输出

```
4```

# 题解

## 作者：Jameswood (赞：587)

[原题链接](https://www.luogu.org/problemnew/show/P2802)


不知道自己怎么错的看过来，这有六种错法 
------------


难度：普及-（但是要小心，多坑）

------------


较为普通的 DFS ，输入时记录初始点，将开始的 mouse（鼠标）数量设为 6，直接开始递归。但要注意以下几点：

1. “ 一旦小H的 血量降到 0， 他将死去 ”，也就是说当小 H 血量为 1，且本格不能补充，就已经可以视为死亡了。我的做法是在每次递归开始时判断，如果鼠标数量为 0 就直接返回。

1. “ 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量 ” 即每次遇到可以拾取鼠标的点后鼠标数量回到 6。

1. 本题是求最小值的 DFS 算法，所以并没有明确的结束标记，我的做法是将 m*n 即所有点的数量设为上线。

#### 记我的失败之路（无特殊说明错误均为 wrong answer）：

------------


1. 在移动后进行边界判断时，将 m 和 n 搞反
   - 得分 40 可以通过测试点 1 、3 、4 、7（5 、8 TLE ）。[失败样例一](https://www.luogu.com.cn/record/8880915)

1. 在遇到可以拾取鼠标的点后，先将血量回复到 6 。
   - 得分 90 第 10 个点错误。[失败样例二](https://www.luogu.com.cn/record/8880544)
   
1. 将步数上界设置得过小，比如 m*n/2 。
   - 得分 50 可以通过测试点 1 、2 、3 、7 、10 。[失败样例三](https://www.luogu.com.cn/record/8880050)
   
1. 没有设置步数上界
   - 得分 40 可以通过测试点 1 、2 、4、 7 （ 其余 MLE 错误 ）。[失败样例四](https://www.luogu.com.cn/record/8880003)

1. 在超出步数上界后将回答设为 -1 。
   - 得分 60 未通过测试点 5 、6 、8 、9。[失败样例五](https://www.luogu.com.cn/record/8879980)

1. ans 初值过小或者捡到鼠标后只血量只加一亦或者捡到鼠标后血量恢复到5。
   - 得分80 未通过测试点 6 、9。[失败样例六](https://www.luogu.com.cn/record/8887268)

代码实现：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
void dfs(int x,int y,int mou);
long long a[11][11],dir[4][2]={1,0,-1,0,0,1,0,-1};
//此处的 dir 数组用于计算 小H 的移动
int tx,ty,lx,ly,n,m,mou=6,times=0,minans=1<<30;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(a[i][j]==2){
                tx=i;ty=j; 
                //记录开始点
            }
            if(a[i][j]==3){
                lx=i;ly=j;
                //记录结束点
            }
        }
    dfs(tx,ty,mou);
    //开始搜索
    if(minans!=1<<30) cout<<minans<<endl;
    else cout<<-1<<endl;
    //如果此时 minans 与初值相等，则没有找到可行路径 QAQ
    return 0;
} 
void dfs(int x,int y,int mou){
	if(mou==0||times>m*n||times>minans) return;
    //如果血量为0或者超出步数上界或者此时的步数已经超过了答案
	if(a[x][y]==4) mou=6;
    if(x==lx&&y==ly) minans=min(times,minans);
    else{
        for(int i=0;i<4;i++){
            tx=x+dir[i][0];
            ty=y+dir[i][1];
            if(tx<=0||tx>n||ty<=0||ty>m||a[tx][ty]==0) continue;
            //边界判断和是否撞墙
            ++times;
            dfs(tx,ty,mou-1);
			--times;
        }
    }
}
```

[测试详情](https://www.luogu.com.cn/record/8885686)

------------

看在我这么多次出错，又把它们都好好总结的份上，不通过，不点赞你对的起你的良心吗……（写完题解的作者已泪崩）你们看我这么可耐，就别欺负我了

![此处应该有一张头像，但是没有加载](https://cdn.luogu.com.cn/upload/pic/24967.png )

[记这万红之中的一抹亮色](https://www.luogu.com.cn/record/list?user=52428&pid=P2802&language=&orderBy=0&page=1)

---

## 作者：KesdiaelKen (赞：82)

看到有同学做了20多次都没有AC，于是也把这题找来做了一做，然而竟然AC了……

好吧，说一下这一题的思路。很明显的bfs啊……

bfs求最短路这里就不解释了。关键是一些本题特有的判断。首先，因为0代表障碍，所以我们可以将外面memset成0，然后照样读入就行了。然后再bfs时，连同原本的障碍物一同判掉就可以了。

另外，血量也是个神奇的东西。考虑到，如果你的血量只剩1了，而此时你还没有完成任务，那么你无论再怎么走都是GAMEOVER的。所以，血量剩1时，直接就跳出就行了。

那么，如何判重呢？如果不判重，那么就可能会陷入无限的死循环……而此题又难以直接用是否到过一点判重，例如下图：

#020
#010
#010
#010
#410
#013
##那么，唯一可以完成任务的路线是：(1,2)->(2,2)->(3,2)->(4,2)->(5,2)->(5,1)->(5,2)->(6,2)->(6,3)。

可以发现，点(5,2)是被走了两次的！所以，如果按传统方式判重就会WA。

那么，如何判重呢？我们可以引入一点贪心的思想。我们可以将visit数组从bool型转为int型，存储目前到达它的路径中，到达它时血量最多的一次的血量。因为是bfs，所以简单的证明可以知道，如果一条路径到达一个已经到达过的点，且血量还小于等于visit时，那么即使完成了任务，其步数也不会时最优的。反之，如果到达一个点，其血量值可以更大，那么这就一种可能的路径，并不是重复到达。这样，就可以既保证了答案得正确性，又保证了不会TLE。

还有一些细节的问题，会在下面的程序中标注。此题是挺好的一道搜索练手题，希望大家有所收获。

下为代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<string>
#include<cmath>
#include<queue>
using namespace std;
int jz[20][20]={0};//存储原地图
struct NODE//一个节点，即一个状态
{
    int x,y,bs,xl;//位置，步数与血量
}qc,fr;
int zl[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//增量，即向四周可能走的位置
int visit[20][20]={0};//visit int版数组
queue<NODE>wz;//bfs队列
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int sx,sy;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%d",&jz[i][j]);
        if(jz[i][j]==2)sx=i,sy=j;//记录出发位置
    }
    wz.push((NODE){sx,sy,0,6});//推入队列，这里用了强制类型转换
    visit[sx][sy]=6;//初始位置设置其visit值
    bool tf=true;//判断是否完成任务，tf==false即完成
    while(!wz.empty()&&tf)//直到完全失败或成功
    {
        qc=wz.front();//取队列最前面的节点
        wz.pop();//弹出队列
        if(qc.xl==1)continue;//如果血量为1，则继续
        for(int i=0;i<4&&tf;i++)//四个方向
        {
            if(jz[qc.x+zl[i][0]][qc.y+zl[i][1]])//如果可以到达
            if(visit[qc.x+zl[i][0]][qc.y+zl[i][1]]<qc.xl-1)//如果血量更大
            {
                fr.x=qc.x+zl[i][0];
                fr.y=qc.y+zl[i][1];
                fr.bs=qc.bs+1;//更新新的节点
                fr.xl=jz[fr.x][fr.y]==4?6:qc.xl-1;//如果下一个节点是有鼠标的，那么有变成6
                visit[fr.x][fr.y]=qc.xl-1;//更新visit
                if(jz[fr.x][fr.y]==3)tf=false;//如果任务完成，那么tf更新
                wz.push(fr);//加入队列
            }
        }
    }
    if(tf)printf("-1");//如果任务失败
    else printf("%d",fr.bs);//如果任务成功，则输出结果
    return 0;
}
```

---

## 作者：BurningEnderDragon (赞：62)

[题目链接：P2802 回家](https://www.luogu.com.cn/problem/P2802)

## 引言

显然，这是一道迷宫类的题目，而解决迷宫类题目最常用的算法是广度优先搜索（Breadth First Search，简称 BFS）。

如果你还不知道什么是 BFS，可以参考[这道题目](https://www.luogu.com.cn/problem/AT896)，以及我的[题解](https://www.luogu.com.cn/blog/BurningEnderDragon/solution-AT896)。

当然，这道题也有使用深度优先搜索（Depth First Search，简称 DFS）的解法。一定程度上，DFS 解决迷宫问题会比 BFS 麻烦，如果你想尝试，可以参考其他人的题解，在此不再赘述。

## 细节

若小 H 在鼠标或家所在的格子上 HP **刚好**降为 $0$，小 H 也会死去。如下面这组数据：

```
1 7
2 0 0 0 0 0 3
```

小 H 无法安全到家。

**所以当小 H 的 PH 为 $1$ 时，我们即可判定小 H 已经死亡，因为他无论下一步走到何种格子上都会直接死去。**

## 解法

在传统的迷宫问题中，每个格子最多只能被搜索一次，所以可以使用一个 `bool` 型的 `visited[]` 数组来记录每个格子是否被访问过。

而在本题中，稍加思考就会发现，因为捡鼠标可以补充 HP，所以可能会出现最优解**需要多次经过同一个格子**的情况，例如下面这组数据：

```plain
6 6
2 0 0 0 0 0
1 0 0 0 0 0
1 0 0 0 0 0
1 1 4 0 0 0
1 0 0 0 0 0
1 4 1 1 1 3
```

作图如下：

![P2802_Solution_P1](https://cdn.luogu.com.cn/upload/image_hosting/duuhca6g.png)

令 $(i,j)$ 表示第 $i$ 行第 $j$ 列的格子，则图中：

- $(1,1)$ 的绿色格子表示小 H 的出发点；
- $(6,6)$ 的绿色格子表示小 H 的家；
- $(4,3)$ 和 $(6,2)$ 的蓝色格子表示鼠标；
- 其余的黑色格子表示障碍物，白色格子表示空地。

小 H 回家的路径如下图的红色箭头所示：

![P2802_Solution_P2](https://cdn.luogu.com.cn/upload/image_hosting/zexti4qn.png)

显然，在这组数据中，存在且仅存在这一种回家的路径，因为如果小 H 不捡 $(4,3)$ 的鼠标，他将在 $(6,2)$ 刚好死去。

**即在某些情况中，若不重复经过一些格子，根本无法到达终点。**

在这个路径中，$(4,1)$ 和 $(4,2)$ 都被经过了两次。

**本题的突破点在于：在何种情况下，一个格子可以被重复经过？**

**答案是本次经过这个格子时剩余的 HP 都大于（不是大于或等于）之前经过时剩余的 HP 时。**

**因为多次经过一个格子时，步数必定比之前经过时大，所以若当前状态比之前的状态更优，则必定 HP 更高。因此上述结论成立。**

仍用上面这组数据举例：

$(4,1)$ 在第一次被经过时，步数为 $3$，HP 为 $3$，而第二次被经过时步数为 $7$，HP 为 $4$；

$(4,2)$ 在第一次被经过时，步数为 $4$，HP 为 $2$，而第二次被经过时步数为 $6$，HP 为 $5$。

所以把传统 BFS 中的 `visited[]` 数组改为 `int` 类型，用于**记录经过这个格子时最大的 HP** 即可，

当尝试扩展一个空地时，若发现当前 HP 大于之前的最大 HP，即可成功扩展。

**而有鼠标的格子最多只能被经过一次，因为每次经过这个格子时，HP 都会补满。**

## 代码

完整 AC 代码如下：

其中 `exit()` 函数用于直接结束程序，函数参数为 $0$ 时表示程序正常结束，可在输出最终答案后免去函数返回的麻烦，它包含在 `<cstdlib>` 头文件中。

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>

using std::queue;

struct Place  //用结构体存储经过一个格子时的状态：当前格子的横纵坐标、步数以及 HP
{
	int x,y,step,HP;
};

int n,m;
int square[10][10]={};  //格子的种类
int visited[10][10]={};  //经过一个格子时的最大 HP
int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};

queue<Place> que;  //广度优先搜索需要的队列

void BFS()  //广度优先搜索
{
	while(!que.empty())
	{
		int x=que.front().x,y=que.front().y,step=que.front().step,HP=que.front().HP;
		que.pop();
		if(square[x][y]==3)
		{
			printf("%d\n",step);  //第一次扩展到家所在的格子，直接输出当前步数并结束程序
			exit(0);
		}
		if(HP>1)  //HP 小于或等于 1 则判定死亡
		{
			for(int i=0;i<=3;++i)
			{
				int nx=x+dx[i],ny=y+dy[i];
				if(nx>=1 && nx<=n && ny>=1 && ny<=m)  //确保尝试扩展的格子坐标在合法范围内
				{
					if(square[nx][ny]==1 || square[nx][ny]==3)  //尝试扩展的格子是空地或小 H 的家
					{
						if(visited[nx][ny]<HP-1)  //本次经过这个格子时的 HP 小于之前经过时的最大 HP
						{
							visited[nx][ny]=HP-1;
							que.push(Place{nx,ny,step+1,HP-1});  //步数增加 1，HP 减少 1
						}
					}
					if(square[nx][ny]==4)  //尝试扩展的格子有鼠标
					{
						if(!visited[nx][ny])  //有鼠标的格子最多只能被经过一次
						{
							visited[nx][ny]=1;
							que.push(Place{nx,ny,step+1,6});  //步数增加 1，HP 补满
						}
					}
				}
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			scanf("%d",&square[i][j]);
			if(square[i][j]==2)
			{
				que.push(Place{i,j,0,6});  //将出发点入队
			}
		}
	}
	BFS();
	puts("-1");  //搜索结束后仍没有到家，判定无解
	return 0;
}
```

---

## 作者：飞翔 (赞：32)

作为出题人来水题解哈

```pascal
var
  n,m,i,j,max:longint;
  z:array[0..12,0..12] of longint;
  f:array[0..12,0..12,0..6] of longint;//f[i,j,k]表示走到(i,j)，血量为k的最优解
procedure search(a,b,t,r:longint);
begin
  if t=0 then exit;
  if z[a,b]=0 then exit;
  if z[a,b]=4 then t:=6;
  if f[a,b,t]<r then exit;//避免重复
  if z[a,b]=3 then
    if (max=-1)or(r<max) then
      begin
      max:=r;
      exit;
    end;
  f[a,b,t]:=r;//更新最优值
  search(a+1,b,t-1,r+1);
  search(a-1,b,t-1,r+1);
  search(a,b+1,t-1,r+1);
  search(a,b-1,t-1,r+1);//向四个方向搜索
end;
begin
  readln(n,m);
  for i:=1 to n do
    for j:=1 to m do
          read(z[i,j]);
  fillchar(f,sizeof(f),$7f);
  max:=-1;
  for i:=1 to n do
    for j:=1 to m do
          if z[i,j]=2 then
            begin
        search(i,j,6,0);
        break;
      end;
  end;
  write(max);
end.
```
注意，有时候向家走并不是一个好的选择。

比如地图

2 0 0 0 0

1 0 4 0 0

1 1 1 1 3

实际上，如果你不去吃掉鼠标，你就无法完成任务。而暂时的偏移（就是先补充血量）可能是最优解。


---

## 作者：xieyikai2333 (赞：15)

# 搜索水题

- [题目传送门](https://www.luogu.com.cn/problem/P2802)

- 事实上，这题因为是求最短的路径，所以应该是用 bfs 更快一点，找到路径就可以直接输出。但是因为数据比较友好而且 dfs 比较好写，所以这里写一篇 dfs 题解。

- update：2021.11.19 通过了新的 hack 数据。

---

先写一个深搜板子。

接下来要做一些改动：首先，如果你只有 $1$ 滴血了。那么你已经没戏了——不管下一个点有什么你都不能成功。所以这可以作为一个终止条件。但是，光这样子还不行，你会发现你 WA 了。为什么呢？

当我们判断一个点是否已经走过，以及走过这个点所需的最小步数时，我们用的是一个二维数组 $book_{x,y}$。但是，我们还需要考虑一个条件，那就是走到这个点时的血量。当你满血走到这个点和残血走到这个点这两种情况是截然不同的。所以应该建应该三维数组，加一维记录血量，把血量不同走到同一个点当做不同的点考虑，再随便加几个常规优化，就可以 AC 了。

---

**AC 代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
int a[10][10],book[10][10][8],n,m,sx,sy,ans=INT_MAX;
void dfs(int x,int y,int step,int hp)
{
	if(a[x][y]==3)
	{
		ans=step;
		return;
	}
	if(a[x][y]==4)hp=6;
	if(hp<=1||step>=ans||a[x][y]==0||step>=book[x][y][hp])return;
	book[x][y][hp]=step;
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		dfs(nx,ny,step+1,hp-1);
	}
	return;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			if(a[i][j]==2)sx=i,sy=j;
		}
	}
	memset(book,0x3f,sizeof(book));
	dfs(sx,sy,0,6);
	if(ans<INT_MAX)cout<<ans;
	else cout<<"-1";
	return 0;
}
```

---

## 作者：大头冲锋车丶 (赞：11)

[题目传送门 P2802](https://www.luogu.org/problemnew/show/P2802)

首先最短路一开始想到的是dijkstra或者bfs。

而这题由于会回满血的缘故，dijkstra较为难描述
****
**当然，咱都是搜索dfs进来的**

分析这道题可注意到以下几点：

- **障碍物、边界外是肯定不走的，这在模拟每步之前就要排除滴**
- 除去障碍物、边界外，在小H还没到达家时，你看看，无论我从哪走开，我都要扣血1**（这是重点！一定要注意，题目是说，离开一个空地才扣血，不是到达空地！意思就是说，我在模拟每一次走到下一个格子之前，我的血量一定要大于1！不然我走到下一个格子，我的血量就是0，无论我的下一个格子是家还是鼠标，小H已经死了！！！不能安全到家或回满血！）**
- 众所周知，dfs通常有一个数组来标记是否走过这个点，当然，这里也需要用vis数组来记录下了，**但是这里并不只是标记走没走过，下面会讲！（你想想，如果不标记的话，那我不是可以在有鼠标的一小范围内转圈？题目还有说，这个格子的鼠标捡完是还有的哦。死循环不是。）那这里到底怎么标记呢？如果像往常一样，标记的不走，合理么？**

**比如这组数据：**

**0 0 0 4 0 0 0**

**0 0 0 1 0 0 0**

**3 1 1 ① 1 1 2**

**注意打圈的①那个点，我虽然直线从2走到3正好是没血的，不能到家，但是我可以走到①然后往上走，回满血，之后再从①出口，往家走，这样步数为10。然而我们发现，我们不能标记每一格只走一次，所以在这里，我们的vis应该是步数限制而不是  走过了就不走！我试了一下，最多可以设置到，每个格子至多走22次，多了会超时或栈溢出MLE**
                   
    			    
                  

接下来就在代码里了~

```cpp
#include<bits/stdc++.h>
#define MAXN 10
#define inf 0x3f3f3f3f
using namespace std;
int a[MAXN][MAXN], vis[MAXN][MAXN];
int n, m, sx, sy, fx, fy;// (sx,sy)为起点坐标，(fx,fy)为终点坐标，当然n，m是行和列
int sum;//用来统计最少步数的，一开始要初始化为最大(如上面预处理inf）
int to[][2] = { {0,1},{0,-1},{-1,0},{1,0} };//模拟4个方向
void dfs(int u, int v,int ans,int t)//(u,v)代表当前小H所在坐标，ans记录当前的血量，t记录到目前为止已耗费的时间
{
	if (u == fx && v == fy)//到家啦~
	{
		sum = min(sum, t);//保留最小步数
		return;
	}
	if (t >= sum)//这个if是后加的，是为了剪枝（之前没加也过了。。）当然，如果都模拟到这一步了，小H还没到达终点时，t就已经比之前的一种到达家的路径所耗费时间更多了，这条路就不再下去了
		return;
	if (ans > 1)//这是之前所说的，我在模拟每一步之前，我的血量一定要大于1，不然就返回了（返回相当于这段的dfs没执行了，因为if外边下面啥没有= =）
	{
		for (int i = 0; i < 4; i++)//模拟出上下左右走
		{
			int q = u + to[i][0], w = v + to[i][1];//模拟走一格之后的坐标
			if (q >= 0 && q < n&&w >= 0 && w < m && vis[q][w]<=22 && a[q][w] != 0)//走到这个格子时，我不能超边界&&限制每个格子所走的步数&&不能是大板墙~
			{
				vis[q][w] ++;//走过的次数+1
				if (a[q][w] == 4)
				{
					dfs(q, w, 6, t + 1);//如果我走到了4了，当然我就回满血了~~ 并且步数+1
				}
				else
				{
					dfs(q, w, ans - 1, t + 1);//否则我走到这只是扣血，步数也要+1
				}
				vis[q][w] --;//减少这个格子的次数，消除影响
			}
		}
	}
}
int main()
{
	cin >> n >> m;
	sum = inf;//初始化
	memset(vis, 0, sizeof(vis));//初始化
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> a[i][j];
			if (a[i][j] == 2)
				sx = i, sy = j;//找出起点坐标
			else if (a[i][j] == 3)
				fx = i, fy = j;//找出家坐标
		}
	}
	dfs(sx, sy, 6, 0);//从起点开始，血量为6，步数为0。开始深搜
	if (sum == inf)//如果sum没有被更新，那就说明没有达到家
		cout << "-1" << endl;
	else
		cout << sum << endl;//否则输出这个最短时间
}
```
**祝各位以及忙碌的审核人新年快乐~**

---

## 作者：伟大的王夫子 (赞：8)

这道题，明显的广搜啊~

但是，和一般的广搜又有一些小区别。

因为一个点走过之后，仍然可能再走一次，因为第二次走到这个点上的血量说不定会比第一次高。

那样的话，我们的一个决策就会有三个元素 $(hp,x,y)$。设 $v_{hp,x,y}$ 表示这个状态是否访问过即可。

然后对于一个决策 $(hp,x,y)$ 当 $hp=0$ 时，直接跳过这个决策。然后若 $a_{x, y} = 4$，那么令这个决策中的 $hp$ 赋值为 $6$。将这个状态加入队列，并且修改 $v$ 数组的值。当我们第一次取出终点这个点时，那么我们广搜得到的必然是最优解。

时间复杂度 $O(nmh)$，且较为稳定。$h$ 为最大的血量值。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[10][10], ans = 1e9;
bool v[7][10][10];
struct P {
	int x, y, hp, c;
	P(int _x, int _y, int _hp, int _c) {
		x = _x, y = _y, hp = _hp, c = _c;
	}
	P() {
	}
};
P st, ed;
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, -1, 1};
bool valid(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= m;
}
int main() {
	scanf("%d%d", &n, &m);
	for (register int i = 1; i <= n; ++i)
		for (register int j = 1; j <= m; ++j) {
			scanf("%d", a[i] + j);
			if (a[i][j] == 2) st = P(i, j, 6, 0);
			if (a[i][j] == 3) ed = P(i, j, 6, 0);
		}
	queue<P> q;
	q.push(st);
	v[st.hp][st.x][st.y] = 1;
	while (q.size()) {
		P x = q.front();
		if (x.x == ed.x && x.y == ed.y) {
			printf("%d\n", x.c);
			return 0;
		}
		q.pop();
		for (register int i = 0; i < 4; ++i) {
			int nx = x.x + dx[i], ny = x.y + dy[i];
			P ne(nx, ny, x.hp - 1, x.c + 1);
			if (ne.hp == 0) continue;
			if (a[nx][ny] == 4) ne.hp = 6;
			if (!valid(nx, ny) || v[ne.hp][nx][ny] || a[nx][ny] == 0) continue;
			v[ne.hp][nx][ny] = 1;
			q.push(ne);
		}
	}
	puts("-1");
}
```

---

## 作者：wangyibo201026 (赞：8)

## dfs 不懂怎么过的看这

本题解乃是用 dfs 做的时间复杂度最低的题解，时间复杂度： $O(n^4)$。

基础模板大家应该都会写，这里主讲优化。

## 优化

楼上的题解都是用的三维的数组来优化，而我是用的四维，具体请看：

定义 bool 数组 vis，四个维度分别为当前的行坐标，当前的列坐标，当前的血量，以及当前的步数。

为什么怎么定，因为不管在哪种情况下，这个 vis 数组的每个位置都是唯一的，一旦重复出现，后面就会做一样的情况，这点可以自己思考。

那么，它需要回溯吗？不需要，因为同一种情况只能出现一次，如果有重复出现，可以直接 return 掉，因为后面做过的操作，前面已经做过了。

下一步，第四个维度：步数。为什么说步数难，因为这道题题目说明可以走回头路，而以上题解都说的不够准确，因为步数**不一定**小于格子数量。但是，由于数据小，步数肯定在 $100$ 步以内，所以，第四个维度的大小要设为 $105$ 不然就会数组越界。

另外，个人建议把血量和步数当个参数，会更方便。

## 代码

理清思路，代码就出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;

bool vis[15][15][7][105];     //搞懂它是什么意思
int n, m, a[15][15], sx, sy, fx, fy, mini = 1e9;
int dx[10] = {0, 0, -1, 1};
int dy[10] = {-1, 1, 0, 0};

void dfs(int x, int y, int xue, int ans){    //个人建议传参
	if(x < 1 || x > n || y < 1 || y > m || a[x][y] == 0 || xue == 0 || ans > 100 || vis[x][y][xue][ans]){     //如果当前这一步不行
		return ;
	}
	vis[x][y][xue][ans] = true;    //此次状态标记为true
	if(a[x][y] == 4){     //回满血
		xue = 6;
	}
	if(x == fx && y == fy){     //到达终点
		mini = min(mini, ans);
		return ;
	}
	for(int i = 0; i < 4; i++){     //4个方向
		dfs(x + dx[i], y + dy[i], xue - 1, ans + 1);
	}
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> a[i][j];
			if(a[i][j] == 2){    //记录起点和终点
				sx = i;
				sy = j;
			}
			if(a[i][j] == 3){
				fx = i;
				fy = j;
			}
		}
	}
	dfs(sx, sy, 6, 0);
	cout << (mini == 1e9 ? -1 : mini);   //三目运算符，如果mini为1e9，输出-1，否则，输出mini 
	return 0;
}
```

## 最后提醒

1. 用此方法可以 AC 此题，[提交记录](https://www.luogu.com.cn/record/58400680)

2. 此方法名为**状态图遍历**。

3. 模板不会打的看上面几位大佬的代码

4. 证明时间复杂度为： $O(n^4)$，可以证明，此处不过多解释。

---

## 作者：Cure_Wing (赞：6)

### 题目大意
找一条路回家
### 解法(dfs)
这道题与平常不同的是，人物多了一种属性，血量值和获得血量。为了回家，小H可能要一先绕一圈去鼠标加血之后才能回家，所以就有了一条路重复走好多遍的可能性。为了解决这个~~绝世大~~难题，我们可以假设无敌状态（刚刚走过的路不算数），这种思路是面对于需要原路返回的时候所用的，原路返回时，发现有多条路径的时候，解除无敌状态，选择未走过的路继续走下去，直到找到家。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,k[20][20],ans=2147483647;
int fx[]={0,-1,1,0,0},
	fy[]={0,0,0,-1,1};
bool flag[20][20],cnd;//cnd->无敌时间判定
int fk(int kx,int ky){//统计连通个数
	int sum=0;
	for(int i=1;i<=4;++i)
		sum+=bool(k[kx+fx[i]][ky+fy[i]]);
	return sum;
}
void dfs(int nx,int ny,int step,int b){//nx,ny是当前位置,step为步数,b为血量
	if(b==0) return ;
	if(k[nx][ny]==3){
		ans=min(step,ans);
		return ;
	}
	if(k[nx][ny]==4) b=6,cnd=1;int ck=0;//无敌判定（拾取鼠标）
	if(ck=fk(nx,ny),ck>2||ck>1&&min(n,m)==1) cnd=0;//解除无敌（连通个数>1）
	for(int i=1;i<=4;++i){
		int cx=nx+fx[i],
			cy=ny+fy[i];
//		printf("%d %d %d %d\n",cx,cy,flag[cx][cy],cnd); 
		if(1<=cx&&cx<=n&&1<=cy&&cy<=m&&(!flag[cx][cy]||cnd)&&k[cx][cy]){
			flag[cx][cy]=1;
			dfs(cx,cy,step+1,b-1);
			flag[cx][cy]=0;
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			scanf("%d",&k[i][j]);
			if(k[i][j]==2) sx=i,sy=j;//记录起点
		}
	flag[sx][sy]=1;
	dfs(sx,sy,0,6);
	flag[sx][sy]=0;
	return printf("%d\n",ans==2147483647?-1:ans),0;
}
```
还需要稍微优化一下，如果说当前走的步数大于当前最优解或最大可能步数时，就不必再搜了。  
尽管如此还是会被@囧仙的数据卡掉：
```
输入数据：
9 9
2 0 1 4 1 1 4 1 1
1 0 4 1 1 4 1 1 1
1 4 1 1 4 1 1 1 4
4 1 1 4 1 4 1 4 1
1 1 4 1 1 1 4 1 1
1 4 1 1 1 4 1 1 1
4 1 4 1 4 1 1 1 1
1 1 1 4 1 1 1 1 1
1 1 4 1 1 1 1 1 3
输出数据：
-1
```
所以我还用了某位的意见，当搜索的次数太大时，说明不可能回家时，输出 `-1`，直接结束程序（避免了由于无敌时间导致的死循环）。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,k[20][20],ans=2147483647,pk;//pk为搜索次数
int fx[]={0,-1,1,0,0},
	fy[]={0,0,0,-1,1};
bool flag[20][20],cnd;//cnd->无敌时间判定
int fk(int kx,int ky){//统计连通个数
	int sum=0;
	for(int i=1;i<=4;++i)
		sum+=bool(k[kx+fx[i]][ky+fy[i]]);
	return sum;
}
void dfs(int nx,int ny,int step,int b){//nx,ny是当前位置,step为步数,b为血量
    ++pk;
    if(pk>1000000){//优化#2，其实这么小的数据范围也没必要开这么大，感觉这样比较稳
        puts("-1");
        exit(0);
    }
	if(b==0||step>n*m||step>ans) return ;//优化#1
	if(k[nx][ny]==3){
		ans=min(step,ans);
		return ;
	}
	if(k[nx][ny]==4) b=6,cnd=1;int ck=0;//无敌判定（拾取鼠标）
	if(ck=fk(nx,ny),ck>2||ck>1&&min(n,m)==1) cnd=0;//解除无敌（连通个数>1）
	for(int i=1;i<=4;++i){
		int cx=nx+fx[i],
			cy=ny+fy[i];
//		printf("%d %d %d %d\n",cx,cy,flag[cx][cy],cnd); 
		if(1<=cx&&cx<=n&&1<=cy&&cy<=m&&(!flag[cx][cy]||cnd)&&k[cx][cy]){
			flag[cx][cy]=1;
			dfs(cx,cy,step+1,b-1);
			flag[cx][cy]=0;
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			scanf("%d",&k[i][j]);
			if(k[i][j]==2) sx=i,sy=j;//记录起点
		}
	flag[sx][sy]=1;
	dfs(sx,sy,0,6);
	flag[sx][sy]=0;
	return printf("%d\n",ans==2147483647?-1:ans),0;
}
```


---

## 作者：囧仙 (赞：6)

## 题解

虽然本题看上去像是一个 $\text{bfs}$ 模板题，但是容易出现这样一种情况：第一次经过某个点的时候血量较低，接着到别的格子捡到了鼠标并回来，血量变得更高了。尽管看上去后者多走了路，但很有可能前者因为血量不足而到达不了某些格子。

考察到这样一个事实：假如我们以 $h$ 的血量经过了某个点 $(i,j)$，那么当我们再次经过这个点，如果血量不大于 $h$，后者**必然更劣**。原因在于，血量越高越好，如果以较低血量重新经过了一个点，而地图上没有发生任何变化，而且还花费了更多的时间，所以是更劣的。于是我们可以将后者作为额外的枝剪掉。

因此，假如我们以 $(i,j,h)$ 为三元组记录一个点的状态，**当走到之前经过的状态时直接跳过**，相当于剪去了所有必然更劣的状态。这题由于血量上限最大也才只有 $6$，因此状态的总量不会更多。

然后就是套 $\text{bfs}$ 板子就行了。总时间复杂度为 $\mathcal O(nmh)$，稳稳通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef tuple <int,int,int,int> Node;
const int MAXN =9+3,MAXM=100+3,MAXH=6+3;
const int D[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
int n,m,W[MAXN][MAXN],V[MAXN][MAXN][MAXH]; queue <Node> Q;
int main(){
    ios_base::sync_with_stdio(false);
    cin>>n>>m; up(1,n,i) up(1,m,j){
        cin>>W[i][j]; if(W[i][j]==2) Q.push({i,j,0,6});
    }
    while(!Q.empty()){
        int x,y,t,h; tie(x,y,t,h)=Q.front(); Q.pop();
        up(0,3,d){
            int nx=x+D[d][0],ny=y+D[d][1],nt=t+1,nh=h-1;
            if(W[nx][ny]==0||nh==0) continue;
            if(W[nx][ny]==3) printf("%d\n",nt),exit(0);
            if(W[nx][ny]==4) nh=6;
            if(V[nx][ny][nh]) continue;
            Q.push({nx,ny,nt,nh}),V[nx][ny][nh]=true;
        }
    }
    cout<<-1<<endl;
    return 0;
}
```

---


# [COCI 2017/2018 #2] ​Košnja

## 题目描述

**题目大意：**

给定一个$n*m$的矩阵，每次你可以选择前进一格或转弯（90度），求在不出这个矩阵的情况下遍历全部格点所需最少转弯次数。有多组数据

## 样例 #1

### 输入

```
2
1 10
10 1
```

### 输出

```
0
0```

## 样例 #2

### 输入

```
3
1 1
3 3
3 4
```

### 输出

```
0
4
4```

## 样例 #3

### 输入

```
2
5 8
6 4```

### 输出

```
8
6```

# 题解

## 作者：damage (赞：23)

### 这道题其实只要思考一下就可以轻易解答了
因为没有障碍物等干扰设施，所以这道题目无疑没有你想象的那么难。

这种题目的进阶类型就是给定起点和终点以及障碍物，求最少转弯次数，当然就要用到**搜索**了，就不会有入门那么简单了。

## 回到正题
每个矩阵的起点可以自己设定，但是为了转弯次数最少，当然是设在边角上了（理由自己想）。

但这题却绝对不是什么模拟、搜索题，只要掌握其中的规律就可以了。

通过观察样例，发现每个矩阵的最少转弯次数K就是矩阵的长和宽N和M中较少的一个的两倍-2，即写成表达式为**2*(min(n,m)-1)**

仔细思考一下就会发现：从边角出发，若想使转弯次数最少，就必须得走到尽头再转弯，而转弯次数却和另一条边有关系，设另一条边的长度为X，每走到尽头就要转弯一次并向前走一步再转弯走到尽头······如此循环，就是最容易想到的最简单的最少转弯次数了，到最后一条路时就转了**2*(X-1)**次弯。易知X越小越好（废话），所以X就是矩阵长和宽中M和N较小的一个了。

代码：

```cpp
#include<stdio.h>
int t,temp,temp2;
int main()
{
	scanf("%d",&t);
	while(t--)              //多组数据
	{
		scanf("%d%d",&temp,&temp2);
		if(temp<temp2) printf("%d\n",(temp-1)*2);   //选择较小的一个按表达式输出
		else printf("%d\n",(temp2-1)*2);
	}
	return 0;
}
```

---

## 作者：sam_hengxuan (赞：10)

## 看了许多 _Dalao_ 的题解，好像没有人写有规律的原因，那我就发一篇题解来说说为什么 ans = (min(n, m) - 1) * 2（其实也就是证明一下ans = (min(n, m) - 1)）
其实我感觉这道题更想一道递推题

首先，只要转一次就走到头，并且不瞎转，出来的结果基本所需最少转弯次数，所以我走的策略是没有问题的（你也可以自己找策略），上一张图4 * 3的长方形遍历图

![](https://cdn.luogu.com.cn/upload/image_hosting/77mxe6nf.png)

（黄色代表起始点）

第一点：我们可以看出，其实3 * 4的长方形与边长为3的正方形转弯次数是一样的，只不过是横着走时要多走一格，但那与我们要数的转弯次数无关（样例2也说明了这一点）

所以我们要算的其实就是遍历边长为min(n, m)的正方形所需转弯次数，问题变成了这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lzvqju2a.png)

这时，再上一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/8gcht825.png)

第二点：我们可以发现，边长为3（或者说是n）的正方形遍历最小转弯数（整张图）其实就是边长为2（或者说n - 1）的正方形遍历最小转弯数（粉色部分） + 2（浅蓝色园圈出来的点）

那么我们设边长是n形的正方形遍历最小转弯数为f[n],则f[n] = f[n - 1] + 2,而f[1] 等于0（没什么好说的）这就是一道递推题了！

这时我们再化简，f[n] = （n - 1） * 2  (这也没什么好说的)，在结合第一点，就可以得出 ans = (min(n, m) - 1) 了

论证完毕

上代码！！！！

```cpp
#include <iostream>
using namespace std;

int main()
{
	int k;
	cin >> k;
	for(int i = 1; i <= k; i++)
	{
		int n, m;
		cin >> n >> m;
		cout << (min(n, m) - 1) * 2 << endl;
	}
	return 0;
}
```


完结散花！

~~最后再无耻地求波赞~~

萌新第一次发题解，管理员大大求过！



---

## 作者：冷墨—— (赞：6)

# 人生第一篇题解

### 首先 
  这个题很有意思（水）
  
  就在我想用dfs解决这个有意思（水）题时，我画了个图，然后。。。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/6gpvs1qy.png)
  
  
我们会发现在一个的矩阵中，若列长较小，则横着走，若行长较小，则竖着走
而在这个3*4的矩阵中，第一行转了一次，第二行转了两次，第三行转了一次

如果我们在画几个图就会发现除第一行和最后一行外都转了两次，所以如果把第一行和最后一行当做一行我们就可以得出转弯次数=（行数-1）*2

而又因为我们要找较短的一边做标准，所以一个n*m的矩阵的转弯次数就可以看作是（min(n,m)-1）*2

这就是规律了。。。

废话不多说  上代码——

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
//象征性打一个快读快写
inline int in(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void out(int x){
    if(x<0) 
	x=-x,putchar('-');
    if(x>9) 
	out(x/10);
    putchar(x%10+'0');
}
int k,n,m;
//把函数命名成dfs，就当我打了个搜索吧。。
int dfs(int x,int y){
	//返回用规律求得的值
	return (min(x,y)-1)*2;
}
int main(){
	//cin大法好
	cin>>k;
	for(int i=1;i<=k;i++){
                //输入
		cin>>n>>m;
                //输出
		cout<<dfs(n,m)<<endl;
	}
        //完美结束
	return 0;
}
```


---

## 作者：Grace_White (赞：6)

### 第一次写coci的题解，本蒟蒻内心还是十分激动的

### 有些刚入门的同学看到题目可能会认为是一道搜索

### 不过我要告诉你，这其实只是一道简单的找规律

### 规律是这样的：

### 最少转弯次数为2(min(n,m)-1)

### 所以这题就变的十分简单

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
int main()
{
	scanf("%d",&n);
	while (n--)//多组数据
	  {
	  	scanf("%d%d",&x,&y);
	  	printf("%d\n",(min(x,y)-1)*2);//按照规律输出
	  }
	return 0;
}
```


---

## 作者：伯伦希尔 (赞：3)

~~发现一道炒鸡简单的题目我兴致冲冲地跑来发题解~~

前面两个大佬已经把规律讲的清清楚楚了，我只能发一个比他们快一丢丢的代码了 ~~本来想最优发现别人比我优好多，被刷到了第二版~~

~~~cpp 
#pragma GCC optimize(3)//无耻的我开了O3
#include <iostream>
#include <cstdio>
using namespace std;
#define re register
#define isnum(x) (x<58&&x>47)//自己定义判断是否为数字，机房里的大佬说这样比自带函数快一丢丢 
inline int read(){//数据很小根本用不上，但是习惯性打上的快读 
	int ans=0;
	char ch=getchar();
	while(!isnum(ch)){
		ch=getchar();
	}
	while(isnum(ch)){
		ans=(ans<<1)+(ans<<3)+ch-48;
		ch=getchar();
	}
	return ans;
}
int main(){
	int k=read();
	for(re int i=1;i<=k;i++){
		int n=read(),m=read();
		n<m?printf("%d\n",(n-1)<<1):printf("%d\n",(m-1)<<1);//蒟蒻的我推了好久才发现的规律 
	}
	return 0;
}
~~~
~~蒟蒻第一次发题解，求通过~~
~~复赛前加点人品~~

---

## 作者：亿年已过 (赞：1)

这是本蒟蒻的第一篇题解，讲得可能不太好，请大家多多包容。

#### 其实这题并不难，只要大家花一点时间，去画一下图，就可以找到规律了。

让我们来模拟一下题中的情况，如3*4（4行三列）的矩阵：

![](https://cdn.luogu.com.cn/upload/pic/75170.png)

~~图画得不太好，将就一下吧~~

要转弯的次数最少，那么我们可以从角落出发，走到尽头再转弯

![](https://cdn.luogu.com.cn/upload/pic/75168.png)

再举一个例子：4*5

5005

0550

0000

0000

0505

注：5表示转弯

结果：ans=6

到这里，我们就可以找到规律了

最少的转弯数=较小的边*2-2

```
ans=(min(n,m)-1)*2
```

最后附上AC代码
```
#include<bits/stdc++.h> //万能头文件
using namespace std;
int main()
{
    int k,n,m,ans;	
    cin>>k;
    for(int i=0;i<k;i++)
    {
        cin>>n>>m;
        ans=(min(n,m)-1)*2;//上面的规律
  		cout<<ans;
  		ans=0;		//清零
    }
    return 0;
}
```




---

## 作者：Raw_Aya9285 (赞：0)

## 找规律大法好！！！

**这题怎么做呢？**

我们来模拟一下样例里面的情况。

有一个4*3的方阵，如下：

0000

0000

0000

------

我们要怎么走呢？

从左下角开始走：

→→→↘

↙←←↙

↘→→→

共计4次。

再来：

000

000

000

000

这回是3*4，但是也一样：

660

000

000

066

共4次。

---
可以发现规律了：每次转弯都是在**短边**上，且每边的转弯数为**边长-1**.

所以！！！规律就是！

```cpp
	(min(n,m)-1)*2
```

min是找短边，乘2是因为短边有2条。

最终AC代码如下：
---
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int k,n,m;
    cin>>k;
    for(int i=0;i<k;i++){
        cin>>n>>m;
        cout<<(min(n,m)-1)*2; //套上面的公式
    }
    return 0;
}
```

感谢观看！！

---

## 作者：不到前10不改名 (赞：0)

这题其实根本就不用搜索2333...（多亏隔壁大佬提示，搜索做完后才发现）
```
#include<stdio.h>
int t,n,m,i;
int main()
{
    scanf("%d",&t);
    for(i=1;i<=t;i++)              
    {scanf("%d%d",&n,&m);
    if(n<m) 
    printf("%d\n",(n-1)*2);  
    else 
    printf("%d\n",(m-1)*2);}
    return 0;
}
```
那位大佬解释不全的地方我来解释吧！  
为了转弯次数最少，设在从边角上开始搜索的理由是可以一次走一条边的长度才转一次弯。  
至于2(min(n,m)-1)是为什么：  
min是因为从长边走，转弯次数自然就和长边无关而和短边有关联了  
2(x)是因为走完一条边有转到这条边上和转出这条边上两次转弯，  
-1则是因为初始点那条边不需要转进来

---


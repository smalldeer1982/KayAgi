# 小埋与扫雷

## 题目背景

小埋总是在家中打游戏，一天，她突然想玩Windows自带的扫雷，在一旁的哥哥看见了，想起了自己小时候信息课在机房玩扫雷的日子，便兴致勃勃地开始教小埋扫雷。然而，小埋还是不明白 $\mathrm{3bv}$（Bechtel's Board Benchmark Value，每局将所有非雷的方块点开所需最少左键点击数，参见[扫雷网的教程](http://saolei.net/BBS/Title.asp?Id=227) ）怎么算，于是她找到了你。

![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)

## 题目描述

小埋会告诉你一盘扫雷，用一个 $n\times m$ 的矩阵表示，$1$ 是雷 ，$0$ 不是雷，请你告诉她这盘扫雷的 $\mathrm{3bv}$ 。 

周围八格没有“雷”且自身不是“雷”的方格称为“空格”，周围八格有“雷”且自身不是“雷”的方格称为“数字”，由“空格”组成的八连通块称为一个“空”。$\mathrm{3bv}=\ $周围八格没有“空格”的“数字”个数$+$“空"的个数。

如果看不懂上面的计算方式，可以看题目背景中给出的教程，或者看下面的样例解释。

注：[八连通](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)

## 说明/提示

$1\le n,\ m\le 1000$

## 样例解释

![](https://i.loli.net/2018/10/04/5bb5bc4644183.jpg)

## 样例 #1

### 输入

```
8 8
0 0 0 1 1 0 0 0 
1 0 0 1 0 0 0 1 
1 0 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0 ```

### 输出

```
13```

# 题解

## 作者：Arse、三千体 (赞：76)

### ~~听说考试前发题解rp+=0x7f呢~~
这是个~~简单的~~dfs联通快，需要注意的地方就是:八联通（不仔细读题的惨痛教训）

（此外作为一个蒟蒻来说，雷图的初始化我想了好久（好久>=半小时））

上代码
```cpp
#include<bits/stdc++.h>//万能大法好
using namespace std;
int a[1000][1000],m,n;//a是雷图，mn是边界
bool booka[1000][1000];//联通快时判重
int xz[8]={-1,-1,-1,0,0,1,1,1},yz[8]={-1,0,1,-1,1,-1,0,1};//八联通！！！
int bv3,lt; //第一个3bv，lt是联通快的数量
void dfs(int x,int y)//联通快
{
	for(int i=0;i<8;i++)
    {
    	int xx=x+xz[i],yy=y+yz[i];
    	if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0&&!booka[xx][yy])//判断边界与重复
    	{
    		booka[xx][yy]=true;//打标记
    		dfs(xx,yy);
    	}
    }
}
void b(int x,int y)//初始化雷图用的，把格子里填数字
{
	for(int p=0;p<8;p++)
	{
		int i=x+xz[p],j=y+yz[p];
		if(i>=0&&i<n&&j>=0&&j<m&&a[i][j]!=-1) 
                                          a[i][j]++;
	}
}
int iff(int x,int y)//判断周围八格是否有空格
{
	for(int i=0;i<8;i++)
	{
		int xx=x+xz[i];
		int yy=y+yz[i];
		if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0)//判空格
                                               return 0;
	}
	return 1;
}
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
		{
			cin>>a[i][j];
			if(a[i][j]==1) a[i][j]=-1;//读入，把雷标记为-1，便于区分数字为 1的无雷格
		}
	}
	for(int i=0;i<n;i++)
	    for(int j=0;j<m;j++)
		    if(a[i][j]==-1)
		        b(i,j);//把有雷格周围八格数字自增
	for(int i=0;i<n;i++)
	    for(int j=0;j<m;j++)
		    if(a[i][j]!=0&&a[i][j]!=-1&&iff(i,j))
		        bv3++;//周围八格无雷的数字的数量
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
		{
			if(a[i][j]==0&&!booka[i][j])
			{
				lt++;//联通快数量
				dfs(i,j);
			}
		}
	}
   bv3+=lt;
	cout<<bv3;//输出答案
	return 0;
}
完美AC
虽然不短，但思路清晰......吧
```
### 第一篇题解，求过啊！

---

## 作者：Konnyaku_ljc (赞：25)

看看……好像没有相似的题解……
### 我绝对不会承认是被小埋吸引进来的！！！

其实很简单，只要dfs跑一次就行了，题义也很明确，八连通也告诉你了，3bv怎么算也说了，计算一下就好。

```cpp
#include<iostream>

using namespace std;

const int X[8]={-1,-1,-1,0,0,1,1,1};//因为是八连通 
const int Y[8]={-1,0,1,-1,1,-1,0,1};// 所以八个方向 
int a[1005][1005];// 图 
int n,m,ans;// ans代表点击数 

void dfs(int x,int y)//搜索 
{
    a[x][y]=3;//周围没雷，但是跑了 
    for(int i=0;i<8;i++)//八个方向，八次循环
    {
        if(x+X[i]>=1&&x+X[i]<=n&&y+Y[i]>=1&&y+Y[i]<=m)
        //剪枝，在图的范围内；
        {
            if(!a[x+X[i]][y+Y[i]])//剪枝，此点没有走过时 
            dfs(x+X[i],y+Y[i]);//搜索此点
        }
    }
}

int main()
{
    cin>>n>>m;//输入 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        cin>>a[i][j];//输入
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(!a[i][j])//如果本身不是雷，判断周围有没有雷 
            for(int l=0;l<8;l++)
            {
                if(a[i+X[l]][j+Y[l]]==1)
                //如果这个点已经跑过一次
                a[i][j]=2;//并且周围有雷的话，a[i][j]=2 
            }   
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]==2)//如果周围有雷 
            {
                int wa=1;//用wa进行判断 
                for(int l=0;l<8;l++)
                {
                    if(a[i+X[l]][j+Y[l]]==0&&i+X[l]>=1&&i+X[l]<=n&&j+Y[l]>=1&&j+Y[l]<=m)
                    wa=0;//如果周围没雷且在图内，wa=0； 
                }   
                if(wa==1)ans++;// 如果不合上文，就要多点一次
            }  
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(!a[i][j])//如果没有走
            {
                ans++;
                xx(i,j);// 搜索 
            }
        }
    }
    cout<<ans;//居然AC了！！！
    return 0;
}
```

---

## 作者：ouuan (赞：17)

这题考察~~读题能力以及~~基本的dfs

看懂题目后，按题目所述，先求出所有的数字和空格，然后对每个空格dfs求空的个数，最后对每个数字判断周围是否有空格即可。

稍微优化一点的做法是先把所有数字记录答案，dfs时遇到数字把答案减一并不继续dfs。这样码量可以略小一点（本来就不大），时间优化也不大。

### 参考代码

```
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int dir[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}}; //用数组记录8个方向便于枚举

void dfs(int x,int y);

int n,m,g[1010][1010],ans;
bool vis[1010][1010];

int main()
{
	int i,j,k;
	
	memset(g,-1,sizeof(g)); //初始化为-1方便判断边界
	
	cin>>n>>m;
	
	for (i=1;i<=n;++i)
	{
		for (j=1;j<=m;++j)
		{
			cin>>g[i][j];
		}
	}
	
	for (i=1;i<=n;++i)
	{
		for (j=1;j<=m;++j)
		{
			if (g[i][j]==1)
			{
				for (k=0;k<8;++k)
				{
					if (g[i+dir[k][0]][j+dir[k][1]]==0)
					{
						g[i+dir[k][0]][j+dir[k][1]]=2; //把所有数字设为2
						++ans;
					}
				}
			}
		}
	}
	
	for (i=1;i<=n;++i)
	{
		for (j=1;j<=m;++j)
		{
			if (g[i][j]==0&&!vis[i][j])
			{
				dfs(i,j);
				++ans;
			}
		}
	}
	
	cout<<ans;
	
	return 0;
}

void dfs(int x,int y)
{
	if (vis[x][y]||g[x][y]==-1)
	{
		return;
	}
	
	vis[x][y]=true;
	
	if (g[x][y]==0)
	{
		for (int i=0;i<8;++i)
		{
			dfs(x+dir[i][0],y+dir[i][1]); //dfs到空格继续dfs
		}
	}
	
	else
	{
		--ans; //dfs到数字将答案减一
	}
}
```

---

## 作者：SunnCloud (赞：16)

~~洛谷管理员什么的最帅了~~
## 明显的DFS题，但读题很重要！八联通！！！

	#include<bits/stdc++.h>
	using namespace std;
	int a[1010][1010],xx[8]={1,1,1,0,0,-1,-1,-1},yy[8]={1,0,-1,1,-1,1,0,-1}/*方向数组*/,ans,m,n;
	void dfs(int x,int y)
	{
	if(x==0||x>m||y==0||y>n)return;//判断是否越界
	if(a[x][y])return;//若这格是雷或是已经搜过
    a[x][y]=2;//若以上流程皆通过，那么恭喜这个格子，我们用‘2’来表示这个格子被搜过
	for(int i=0;i<8;i++)
	{
		if(a[x+xx[i]][y+yy[i]]==1)return;
	}//判定它周围是否有雷（仅给周围无雷的格子dfs权限）
	for(int i=0;i<8;i++)
		dfs(x+xx[i],y+yy[i]);//继续搜周围的格子
	}
	int main()
	{
	bool flag;
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)cin>>a[i][j];//输入（这个应该不用解释吧qwq）
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			flag=0;//flag重置
			if(a[i][j]==1)continue;
			for(int k=0;k<8;k++)
				if(a[i+xx[k]][j+yy[k]]==1)flag=1;//若它周围有雷，flag=1
			if(flag)continue;若flag=1（周围有雷），则跳过
			if(a[i][j]==0)ans++;//若它还没有被搜过，则进入了一个新的联通块，ans++
			dfs(i,j);//将联通块搜一遍
		}
	}
    //接下来就是剩下的格子了！
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==1||a[i][j]==2)continue;//若它为雷或被搜过，跳过
			for(int k=0;k<8;k++)
				if(a[i+xx[k]][j+yy[k]]==2)continue;//若它周围有被搜过的联通块，则这个格子肯定也被“翻”过了，跳过
			ans++;通过上面的流程，剩下的就是还未被翻过的格子了！ans++
		}
	cout<<ans;//愉快的输出答案，青草池塘处处...AC!
	return 0;
 	} 
---
2024.4.21
用洛谷IDE检验组合题的时候偶然发现了这篇远古题解有虫，遂顺手改之，对可能受到过该题解误解的OIer道个歉（主要问题是标记为2的定义当时没弄清晰）
回忆四年半之前的OI时光，与当下即将前往高考考场的现实生活形成了刺眼的对比，还请来者且行且珍惜。

---

## 作者：派大那个星 (赞：10)

## ~~小埋最可爱了~~
### 题意：求空格连通块个数和周围没有空格的数字个数之和。
### 错误点：八连通而不是四连通，边界处理。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1010][1010],Map[1010][1010],sum,vis[1010][1010];
//a表示初始状态，Map表示数字，vis表示递归过程中的空格是否已被访问
int dx[]={1,-1,0,0,1,1,-1,-1};//八连通
int dy[]={0,0,1,-1,-1,1,-1,1};
void dfs(int x,int y)
{
	vis[x][y]=1;
	for(int i=0;i<=7;i++)
	{
 		int tx=x+dx[i],ty=y+dy[i];
		if(Map[tx][ty]==0&&vis[tx][ty]==0&&tx>0&&tx<=n&&ty>0&&ty<=m)dfs(tx,ty);
	}//判断边界，灌水
}
void paint(int x,int y)
{
	Map[x][y]=9;//将炸弹与数字区分，数字不可能大于8
	for(int i=0;i<=7;i++)if(Map[x+dx[i]][y+dy[i]]!=9)Map[x+dx[i]][y+dy[i]]++;
	//将炸弹周围的数字加1
}
bool check(int x,int y)
{
	for(int i=0;i<=7;i++)if(Map[x+dx[i]][y+dy[i]]==0)return false;
	return true;
    //判断是否满足数字周围没有空格
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<=m+1;i++)Map[0][i]=Map[n+1][i]=1;
    //处理边界，将四边赋1
	for(int i=0;i<=n+1;i++)Map[i][0]=Map[i][m+1]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j]==1)
			paint(i,j);
		}//计算数字
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(Map[i][j]==0&&vis[i][j]==0)
			{
				sum++;
				dfs(i,j);
			}//如果是空格，答案加1，将周围空格vis刷成1
			else 
			{
				if(Map[i][j]!=9&&check(i,j))
				sum++;
			}//如果是数字，判断其周围是否有空格，如果没有，答案加一
	printf("%d\n",sum);//愉快地输出答案
}
```


---

## 作者：梦里调音 (赞：6)

我也来水篇题解。

标签给了dfs，其实我觉得更主要的是模拟吧。

题你首先要看懂。

然后很容易可以归纳出代码要完成的$tasks$:

	1.输入
    2.区别“数字”和“空格”
    3.记录“空”的个数
    4.计数:周围八格没有“空格”的“数字”个数
    5.输出
    
然后每一步跑一遍两个$for$循环，时间完全充足。

只有第$3$步才需要$dfs$，然后也不用回溯什么的，拿个标记就好了。

~~这就是传说中的dfs大水题吧~~

代码：

```
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[1001][1001];//0:未标记 1:雷 2:空格 3:数字
bool tag[1001][1001];//标记空
int py[]={-1,-1,-1,0,1,1,1,0},px[]={-1,0,1,1,1,0,-1,-1};//位移数组

void idfy(int y,int x)
{
	bool lei=false;//判断四周是否有雷
	for(int i=0;i<8&&!lei;i++)
	{
		int yy=y+py[i];
		int xx=x+px[i];
		if(yy>0&&yy<=n&&xx>0&&xx<=m)
			if(a[yy][xx]==1)
				lei=true;
	}
	if(!lei)//空格
		a[y][x]=2;
	else//数字
		a[y][x]=3;
	return;
}

void dfs(int y,int x)
{
	tag[y][x]=true;
	for(int i=0;i<8;i++)
	{
		int yy=y+py[i];
		int xx=x+px[i];
		if(yy>0&&yy<=n&&xx>0&&xx<=m)
			if(a[yy][xx]==2&&tag[yy][xx]==false)
				dfs(yy,xx);
	}
	return; 
}

bool check(int y,int x)
{
	bool ans=true;
	for(int i=0;i<8&&ans==true;i++)
	{
		int yy=y+py[i];
		int xx=x+px[i];
		if(yy>0&&yy<=n&&xx>0&&xx<=m)
			if(a[yy][xx]==2)
				ans=false;
	}
	return ans;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(!a[i][j])
				idfy(i,j);
	int cnt=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]==2&&!tag[i][j])
			{
			 
				dfs(i,j),cnt++;//计数:空
			} 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]==3)
				if(check(i,j))cnt++;//计数:周围八格没有“空格”的“数字”个数
	cout<<cnt<<endl;
	return 0;
}
```


---

## 作者：hylong (赞：4)

这是一道深搜题，但如果你用广搜也是可以AC的[BFS题解链接](https://www.luogu.org/blog/Amorpk/solution-p4961)~~（这位同学的题解比较**亮眼** ）~~
##### 思路:
DFS找连通块 ~~（如果你用像Lake Counting一样的BFS找我也无法反驳）~~，之后再找没有和空格相邻的数字。
##### 坑点：
 边界处理问题 ~~（险些把我坑死）~~+八连通 ~~（还好我没瞎）~~
##### 代码（对拍可以，请勿抄袭）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int mv[8][2]={{1,0},{1,1},{1,-1},{0,1},{0,-1},{-1,-1},{-1,0},{-1,1}};//mv=move缩写，代表移动
int mapp[1001][1001];
int vis[1001][1001];
void dfs(int x,int y)
{
	int k,tx,ty;
	vis[x][y]=1;
	for(k=0;k<8;k++)
	{
	 tx=x+mv[k][0];ty=y+mv[k][1];
	 if(mapp[tx][ty]==0 && vis[tx][ty]==0 && tx>0 && tx<=n && ty>0 && ty<=m)//考虑到边界是不能走的，所以要加这些条件
	  dfs(tx,ty);
	}
}
int read()
{
	int x=0;
	char b=getchar();
	while(b>'9' || b<'0')
	 b=getchar();
	while(b>='0' && b<='9')
	{
	 x=x*10+b-'0';
	 b=getchar();
	}
	return x;
}//玄学快读（加inline还慢了？？？）
int main()
{
	int i,j,k,ans=0;
	n=read();m=read();
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++)
	  mapp[i][j]=-read();//把1改为-1会好判断一点
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++)
	  if(mapp[i][j]!=-1)
	   for(k=0;k<8;k++)
	    if(mapp[i+mv[k][0]][j+mv[k][1]]==-1)
	     mapp[i][j]++;//写数字
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++)
	  if(mapp[i][j]==0 && vis[i][j]==0)
	   dfs(i,j),ans++;//DFS寻找连通块
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++)
	  if(mapp[i][j]!=-1 && mapp[i][j])
	  {
	   ans++;
	   for(k=0;k<8;k++)
	    if(vis[i+mv[k][0]][j+mv[k][1]]!=0)
	    {
	     ans--;
	     break;
	    }//懒人写法（不想动脑子）
	  }
	printf("%d\n",ans);//输出
	return 0;//好习惯
}
```
开O2优化303ms

---

## 作者：Wi110w (赞：3)

朴素到不能再朴素的思路了（可能这就是蒟蒻把），没有任何优化，比较好理解。

首先把这道题看成两道题，普通dfs(dfs1)和联通块dfs(dfs2)。分成两部分来写，于是我就写了两个dfs(可能这就是蒟蒻把），check函数的作用就是查出地图上的0，当然这里也可以dfs，不过直接循环会简单一些。然后搜数字(dfs1)的时候，只需要从上往下，从左往右搜就行了，没必要搜八个方向。

对于ans2的处理，每次搜“空”(dfs2)的时候加一就行了，然后把联通的就标记访问，就不会重复了。

下面对方向的处理我没有用循环，直接手打qwq（当然也可以用循环加数组来写的），算了算了，还是看代码把（空间有点大，可能这就是蒟蒻把）。


	#include<bits/stdc++.h>//谨慎食用(滑稽） 

	#define N 1005  
	using namespace std;

	int map1[N][N];//地图 

	bool vis1[N][N],vis2[N][N];//vis1查数字用,vis2查空用 

	int n,m,ans1,ans2;

	void dfs1(int x,int y) {//这里是查没有周围空的数字 

		if(vis1[x][y]) return ;//访问过就没必要访问了
		if(map1[x][y] == -1) return ;//边界    
		vis1[x][y] = 1;//标记访问 
		if(map1[x][y]==2&&map1[x+1][y]!=0&&map1[x-1][y]!=0&&map1[x][y-1]!=0&&map1[x][y+1]!=0&&map1[x-1][y-1]!=0&&map1[x-1][y+1]!=0&&map1[x+1][y-1]!=0&&map1[x+1][y+1]!=0)//鬼畜的八个方向
			ans1++;
		dfs1(x+1,y);//从上往下 
		dfs1(x,y+1);//从左往右 
	}

	void dfs2(int x,int y,int ans) {//求联通块 

		if(vis2[x][y]||map1[x][y]!=0) return ;//同上
		if(map1[x][y] == -1) return ;//同上
		vis2[x][y]=true;//标记访问 
		dfs2(x+1,y,ans);
		dfs2(x-1,y,ans);
		dfs2(x,y-1,ans);
		dfs2(x,y+1,ans);
		dfs2(x+1,y+1,ans);
		dfs2(x-1,y+1,ans);
		dfs2(x+1,y-1,ans);
		dfs2(x-1,y-1,ans); //鬼畜的八个方向 
	}

	void check() {

		for(int i=1; i<=n; i++)
			for(int j=1; j<=m; j++)
				if(map1[i][j]==0&&vis2[i][j]==false)//判断是否是没有搜过的"空” 
					dfs2(i,j,++ans2);//每次搜的时候ans2就加1       
	}

	int main() {

		memset(map1,-1,sizeof(map1));//预处理成-1，方便判断边界 
		scanf("%d%d",&n,&m);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=m; j++)
				scanf("%d",&map1[i][j]);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=m; j++) {
				if(map1[i][j]==1) {
					if(map1[i+1][j]==0) map1[i+1][j] = 2;
					if(map1[i-1][j]==0) map1[i-1][j] = 2;
					if(map1[i][j-1]==0) map1[i][j-1] = 2;
					if(map1[i][j+1]==0) map1[i][j+1] = 2;
					if(map1[i+1][j+1]==0) map1[i+1][j+1] = 2;
					if(map1[i+1][j-1]==0) map1[i+1][j-1] = 2;
					if(map1[i-1][j+1]==0) map1[i-1][j+1] = 2;//把炸弹周围的空都值为2,代表数字，反正这又不是真正的扫雷(滑稽） 
					if(map1[i-1][j-1]==0) map1[i-1][j-1] = 2;//鬼畜的八个方向
				}
			}
		dfs1(1,1);//开搜 
		check();//查“0” 
		int ans=ans1+ans2;//两部分答案整合起来 
		printf("%d",ans);
		return 0;
	}

---

## 作者：蒟蒻CGZ (赞：2)

# P4961 小埋与扫雷

## 思路：
### 1.我们需要三个函数：

NO.1 b(i,j) 将a[i][j]周围八格+1，此函数为初始化雷图使用；

NO.2 iff(i,j) 检测周围八格有无空格，如果有，在点掉那个联通块时，就可以点开这个格子了；如无，则点开这个格子需要单独点一次，也就是说要3bv++。

NO.3 dfs(i,j) 标记函数。当且仅当满足于a[i][j]为空格时可用，将a[i][j]所处的联通块中的所有空格标记为点开状态true，下次检验就不会重复将3bv++了。（每个联通块要且仅要点一次）

### 2.大体思路：

我们先输入（废话），在输入时需要注意将雷标记为-1，当然，-2-3-4-5-6-7-8…也都可以，便于区分。 用b函数初始化数字，接着统计**周围八格无空格且本身为数字**（需要单独点一次）的格子，这些格子每一个都要3bv++。然后运用dfs函数，计算联通块数量，每个联通块也都要点一次。最后输出3bv。（还是废话）
    
## 有坑:
八联通！非四联通也！！！！！！！！！！！

## AC代码（别抄）

```
#include<bits/stdc++.h>
using namespace std;
int a[1000][1000],m,n;//a图，mn边
bool bol[1000][1000];//联通快判重用滴 
int xz[8]={-1,-1,-1,0,0,1,1,1},yz[8]={-1,0,1,-1,1,-1,0,1};//八联通
int bv,lt; //3bv，lt是联通快的数量
void dfs(int x,int y)//联通快
{
    for(int i=0;i<8;i++)
    {
        int xx=x+xz[i],yy=y+yz[i];
        if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0&&!bol[xx][yy])//判断边界与重复
        {
            bol[xx][yy]=true;//打标记
            dfs(xx,yy);
        }
    }
}
void b(int x,int y)//初始化雷图用的，把格子里填数字
{
    for(int p=0;p<8;p++)
    {
        int i=x+xz[p],j=y+yz[p];
        if(i>=0&&i<n&&j>=0&&j<m&&a[i][j]!=-1)a[i][j]++;
    }
}
int iff(int x,int y)
{
    for(int i=0;i<8;i++)
    {
        int xx=x+xz[i],yy=y+yz[i];
        if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0)return 0;
    }
    return 1;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cin>>a[i][j];
            if(a[i][j]==1) a[i][j]=-1;//雷为-1
        }
    }
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if(a[i][j]==-1)
                b(i,j);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if(a[i][j]!=0&&a[i][j]!=-1&&iff(i,j))
                bv++;//周围八格无雷的数字的数量
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(a[i][j]==0&&!bol[i][j])
            {
                lt++;//联通快数量
                dfs(i,j);
            }
        }
    }
    bv+=lt;
    cout<<bv<<endl;
    return 0;
}
```

[偶滴博客](https://www.luogu.org/blog/cgz2006/#)

---

## 作者：超级小周 (赞：2)

为了~~做出这道题~~**小埋**我特意去玩了扫雷（还好机房用的是老机子）

这题的意思是我们要找出这盘扫雷的3bv（3bv我的理解就是扫雷通关的点方块的次数）我是用分步求解的办法，先找雷，再判断为不为空格。这题dfs,bfs都可以做出来，我用的是dfs，加上快输时间是330ms。
```c
#include<bits/stdc++.h>
using namespace std; 
int m,n,ans;//ans记录点几次 3bv其实就是点几次图只剩雷没显现出来的次数 
int tu[1111][1111];//我光棍，我快乐 （呜呜呜，我本来想用五个1的，结果内存炸了） 
int tx[8]={0,0,1,-1,1,1,-1,-1};// 这不可能不知道吧 
int ty[8]={1,-1,0,0,1,-1,1,-1};//。。这不可能不知道吧
int read()
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}//这题让我很想用快读 
bool zao(int i,int j)
{
    for(int k=0;k<8;k++){
	int x=i+tx[k];
	int y=j+ty[k];
	if(tu[x][y]==-2)
	return false;
	}
	return true;
}
void lei(int i,int j)
{
	for(int k=0;k<8;k++){
	int x=i+tx[k];
	int y=j+ty[k];
	if(tu[x][y]==-1)
	tu[i][j]++;//作为一名资深扫雷玩家，当然是要把附近的雷的数量都找出来！ 
	}
}
void dfs(int i,int j)
{
    if(tu[i][j]==0)
    {
    tu[i][j]=-2;//再标记空格 
    for(int k=0;k<8;k++){
	int x=i+tx[k];
	int y=j+ty[k];
	dfs(x,y);}
    }
}
int main()
{
    m=read();
    n=read();
    memset(tu,2333333,sizeof(tu));//众所周知这行是用来装弱的. PS：被识破 
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++){
    tu[i][j]=read();
    if(tu[i][j]==1)//找到个雷，标-1 。 
    tu[i][j]=-1;} //为什么标-1？因为雷不能踩啊啊啊啊qaq... （其实是为了方便） 
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++){
    if(tu[i][j]!=-1)//找到不是雷的方块
    lei(i,j);} //在四周看看有没有雷 
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    {
    if(tu[i][j]==0)//这下tu[i][j]==0就是空格了（应该是周围没雷） 
    {
    dfs(i,j);//模拟扫雷把相邻空格都找出来 
    ans++;//这也算点一次 
    }
    }
/////////////////////////////////////////////////////////////////////华丽而又漂亮的分割线 
    for(int i=1;i<=m;i++)//最后找不得不点的 
    for(int j=1;j<=n;j++){//哈哈哈哈哈 
    if(zao(i,j)&&tu[i][j]!=-1&&tu[i][j]!=-2)
    ans++;//看来不得不点了 
	}
    cout<<ans;//有约不来过夜半,闲敲棋子落AC？ 
    return 0;
} 
```


---

## 作者：cecilia_sankta (赞：2)

为什么你们都用dfs呀qwq

于是这就是一个bfs算法！

bfs常数小，跑起来快，没卡什么常也rk14(20:23测试)，311ms

```
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>
using namespace std ;
int mat[1926][1926] ;
int what[1926][1926] ;
int n , m ;
//what[i][j]=1 - 空格
//what[i][j]=2 - 数字
//what[i][j]=3 - 雷
bool inq[1005][1005] ;
void get (int i , int j){
	if(mat[i][j]==1) what[i][j] = 3 ;
	else if(!mat[i-1][j]&&
			!mat[i-1][j+1]&&
			!mat[i-1][j-1]&&
			!mat[i][j+1]&&
			!mat[i][j-1]&&
			!mat[i][j]&&
			!mat[i+1][j]&&
			!mat[i+1][j+1]&&
			!mat[i+1][j-1]&&
			!mat[i+1][j]) what[i][j] = 1 ;
	else what[i][j] = 2 ;
}
//得到mat[i][j]的状态

void bfs(int startx , int starty){
	queue< pair<int,int> > Q ;
	Q.push(make_pair(startx , starty)) ; inq[startx][starty] = true ;
	while(!Q.empty()){
		int ouuantql = Q.front().first , orzouuan = Q.front().second ; Q.pop() ;
		if(what[ouuantql+1][orzouuan]==1&&
		   !inq[ouuantql+1][orzouuan])
			Q.push(make_pair(ouuantql+1,orzouuan)) , inq[ouuantql+1][orzouuan] = true ;
		if(what[ouuantql+1][orzouuan-1]==1&&
		   !inq[ouuantql+1][orzouuan-1])
			Q.push(make_pair(ouuantql+1,orzouuan-1)) , inq[ouuantql+1][orzouuan-1] = true ;
		if(what[ouuantql+1][orzouuan+1]==1&&
		   !inq[ouuantql+1][orzouuan+1])
			Q.push(make_pair(ouuantql+1,orzouuan+1)) , inq[ouuantql+1][orzouuan+1] = true ;
		if(what[ouuantql][orzouuan-1]==1&&
		   !inq[ouuantql][orzouuan-1])
			Q.push(make_pair(ouuantql,orzouuan-1)) , inq[ouuantql][orzouuan-1] = true ;
		if(what[ouuantql][orzouuan+1]==1&&
		   !inq[ouuantql][orzouuan+1])
			Q.push(make_pair(ouuantql,orzouuan+1)) , inq[ouuantql][orzouuan+1] = true ;
		if(what[ouuantql-1][orzouuan]==1&&
		   !inq[ouuantql-1][orzouuan])
			Q.push(make_pair(ouuantql-1,orzouuan)) , inq[ouuantql-1][orzouuan] = true ;
		if(what[ouuantql-1][orzouuan-1]==1&&
		   !inq[ouuantql-1][orzouuan-1])
			Q.push(make_pair(ouuantql-1,orzouuan-1)) , inq[ouuantql-1][orzouuan-1] = true ;
		if(what[ouuantql-1][orzouuan+1]==1&&
		   !inq[ouuantql-1][orzouuan+1])
			Q.push(make_pair(ouuantql-1,orzouuan+1)) , inq[ouuantql-1][orzouuan+1] = true ;
	}
}
//bfs爆搜

int ans = 0 ;
int main(){
	memset(what , 0 , sizeof(what)) ;
	scanf("%d %d",&n , &m) ;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",& mat[i][j]) ;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			get(i,j) ;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(what[i][j]==1&&!inq[i][j]) bfs(i,j) , ++ans ;
		}
	}
    //bfs统计
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(what[i][j]==2&&
			   !inq[i-1][j+1]&&
			   !inq[i-1][j]&&
			   !inq[i-1][j-1]&&
			   !inq[i][j+1]&&
			   !inq[i][j-1]&&
			   !inq[i+1][j]&&
			   !inq[i+1][j+1]&&
			   !inq[i+1][j-1]) ++ans ;
		}
	}
    //特判
	printf("%d\n",ans) ;
	return 0 ;
}
```

---

## 作者：嘟嘟cqy (赞：0)

本题可以通过联通块和普通的dfs模拟解决
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,_map[1111][1111];
const int INF=0x3f3f3f;
void prepare(int i,int j)
{
    if(_map[i-1][j]==-1)
        _map[i][j]++;
    if(_map[i-1][j-1]==-1)
        _map[i][j]++;
    if(_map[i-1][j+1]==-1)
        _map[i][j]++;
    if(_map[i+1][j]==-1)
        _map[i][j]++;
    if(_map[i+1][j-1]==-1)
        _map[i][j]++;
    if(_map[i+1][j+1]==-1)
        _map[i][j]++;
    if(_map[i][j+1]==-1)
        _map[i][j]++;
    if(_map[i][j-1]==-1)
        _map[i][j]++;	
}
void dfs(int i,int j)
{
    if(_map[i][j]==0)
    {
        _map[i][j]=-2;
        dfs(i+1,j);
        dfs(i+1,j+1);
        dfs(i+1,j-1);
        dfs(i-1,j);
        dfs(i-1,j-1);
        dfs(i-1,j+1);
        dfs(i,j+1);
        dfs(i,j-1);
    }
}

bool search(int i,int j)
{
    if(_map[i][j-1]!=-2&&_map[i][j+1]!=-2&&_map[i-1][j+1]!=-2&&_map[i-1][j-1]!=-2&&_map[i+1][j+1]!=-2&&_map[i+1][j]!=-2&&_map[i+1][j-1]!=-2&&_map[i-1][j]!=-2)
        return true;
    return false;
}

int main()
{
    int ans=0;
    cin>>m>>n;
    memset(_map,INF,sizeof(_map));
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>_map[i][j];
            if(_map[i][j]==1)
                _map[i][j]=-1;  //地雷=-1   else =0
        }
    }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            if(_map[i][j]!=-1)
                prepare(i,j);   //地雷=-1  else =its number
        }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            if(_map[i][j]==0)
            {
                dfs(i,j);    //space——-2
                ans++;
            }
        }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            if(search(i,j)&&_map[i][j]!=-1&&_map[i][j]!=-2)
            {
                ans++;
            }
                
        }
    cout<<ans<<endl;
    return 0;
} 
```

---


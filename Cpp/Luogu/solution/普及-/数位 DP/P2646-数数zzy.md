# 数数zzy

## 题目描述

zzy 自从数学考试连续跪掉之后，上数学课就从来不认真听了（事实上他以前也不认真听）。于是他开始在草稿纸上写写画画，比如写一串奇怪的字符串。然后他决定理♂性♂愉♂悦♂一下：统计这串字符串当中共有多少个为 `zzy` 的子序列，**注意是子序列而非子串**。但是由于他写的字符串实在是太长啦，而且他是个超级大蒟蒻，根本就数不过来。所以他决定请求你这个超级大神犇的帮助。你可以帮帮他吗？

## 说明/提示

#### 数据规模与约定

约定 $|s|$ 表示字符串 $s$ 的长度。

- 对于 $70\%$ 的数据，保证 $|s| \le 100$。
- 对于 $100\%$ 的数据，保证 $1 \le |s| \le 10^6$，答案不超过 $2^{63}-1$。

## 样例 #1

### 输入

```
zlzhy```

### 输出

```
1```

# 题解

## 作者：Conical (赞：17)

首先，再此orz我们班的神犇zzy。

[color=white][delete]lu~~~[/delete][/color]

本题看起来很神，然而做起来也很神~~~

言归正传，这题先依次读入字符串，遇到‘z'  记录下来

然后遇到 ‘y’就用组合数算出来。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

long long  NumberOfZ,Answer;
char c;

int main()
{    
    freopen("abao.in","r",stdin);
    freopen("abao.out","w",stdout);

    while(scanf("%c",&c)!=EOF) {
        if(c=='z')++NumberOfZ;
        
        if(c=='y')Answer+=NumberOfZ*(NumberOfZ-1)/2;
    }
    
    cout<<Answer;
    
    return 0;
}
```

---

## 作者：greenheadstrange (赞：8)

## 前序知识

C（n,m）表示在n个数中选m个数的方案数

C（n,m）=A(n,m)/A(n,n)

特殊的：

在n个数中选两个数的方案为**C（n，2）=n*(n-1)/2**

------------
说回这道题

读入一个字符时，当字符为z时，sum++

当字符为y时答案加上C（sum，2）

直接上代码:

```cpp
#include<bits/stdc++.h>//定义万能头文件
using namespace std;//使用std空间
string s;//定义一个字符串
long long ans,sum;//注意开long long，sum为当前字符z的个数，ans为答案
long long C(int n,int m){//计算C（n，m），其实不用写函数
	long long x=1;
	for(int i=1;i<=m;i++)x*=(n-i+1);
	for(int i=1;i<=m;i++)x/=i;
	return x;
}//C（n,m）=A(n,m)/A(n,n)
int main(){
	cin>>s//读入字符串
	for(int i=0;i<s.length()/*字符串的长度*/;i++){
		if(s[i]=='z')sum++;//字符z的个数加1
		else if(s[i]=='y')ans+=C(sum,2);//统计答案，上文已经讲
	} 
	cout<<ans;//输出答案
	return 0;
}
```

结束语：不开**long long**见祖宗，本蒟蒻祝大家AK IOI!

---

## 作者：人间凡人 (赞：5)

这道题其实是一道模拟题。

思路：我们可以统计出当前状态上$z$的个数，用$tot$来存储。因此，在扫描过程中一出现了$z$就将$tot+1$。如果出现了$y$,那么就说明我们要在前面找出两个位置不同的$z$出来组成$zzy$。相信大家学过组合数吧，从$n$个数中选出两个数方案数为$C^2_n=n*(n-1)/2$ 所以只用将答案加上$tot*(tot-1)/2$即可。

现在让我们根据思路来模拟一下样例:$zlzhy$

第$1$位：字符为$z$ 将$tot+1$ $tot=1$ $ans=0$

第$2$位：字符为$l$ 不操作 $tot=1$ $ans=0$

第$3$位：字符为$z$ 将$tot+1$ $tot=2$ $ans=0$

第$4$位：字符为$h$ 不操作 $tot=2$ $ans=0$

第$5$位：字符为$y$ $ans$加上$tot*(tot-1)/2$ $tot=2$ $ans=1$ 结束 输出 $1$

$Code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[1000005];
long long ans,tot;
int len;
int main() {
	scanf("%s",s);len=strlen(s);ans=0;
	for(int i=0;i<len;i++){
		if(s[i]=='z')tot++;
		if(s[i]=='y')ans+=tot*(tot-1)/2;
	}
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：KesdiaelKen (赞：5)

由于我比较笨，没有想到直接进行计数，所以使用了DP（.^.^.）

用z1,z2,y三个数组存储DP值，第i个位置分别存储的是在前i+1个位置中，"z","zz","zzy"的个数分别有多少。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
char xl[2000000];
long long z1[2000000]={0},z2[2000000]={0},y[2000000]={0};
int main()
{
    scanf("%s",xl);
    int len=strlen(xl);
    for(int i=0;i<len;i++)
    {
        if(i==0)z1[0]=xl[0]=='z'?1:0;//第一个特判
        else
        {
            z1[i]=z1[i-1]+(xl[i]=='z'?1:0);//递推
            z2[i]=z2[i-1]+(xl[i]=='z'?z1[i-1]:0);//递推关系，若本位为z，则新增加前i-1位中z的个数
            if(i>=2)//长度至少为3
            {
                y[i]=y[i-1]+(xl[i]=='y'?z2[i-1]:0);//递推，同z2
            }
        }
    }
    printf("%lld",y[len-1]);
    return 0;
}
```

---

## 作者：_扶笙_ (赞：2)

P来了，楼下的代码(Pascal)不能满分，现在我放个。
题目其实很容易读懂，我一开始想用DP，但觉着太烦，就换了思路。
如果读入的是z那么计数器+1，如果碰到了一个y，那可以直接累加总和了，就是z的计数器的组合数，最后输出。
注意注意：int64别忘记。
以下是蒟蒻的代码：
```
var a,b:int64;//a是“z”的个数，b是"zzy”的个数，int64很重要
c:char;//c是读入的
begin
read(c);//先读入一个字符
while not eof do//判断没有到文件末尾
  begin
  if c='z' then a:=a+1;//如果是z，计数器+1
  if c='y' then b:=b+a*(a-1) div 2;//如果是y直接累加前面z的组合数
  read(c);//别忘了继续读入
  end;
writeln(b);//输出方案数
end.
```
读完之后你会发现按回车不会回到程序，因为判断有没有道文件的终止需要按4（还是2来着）次Ctrl+Z,然后按回车，就可以回到程序了。

---

## 作者：AmadeusSG (赞：1)

第一眼看觉得没这么简单，还觉得是dp

后来仔细一看，这就是一道**组合数学题**

因为只要2个z和一个y就能组成一个zzy。根据公式**C(n,m)=P(n,m)/P(m,m) =n！/m！（n-m）！**，所以答案为***n*(n-1)/2**。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s;
ll len,num,ans;
ll sum[1000005];
int main()
{
	cin>>s;
	len=s.length();
	for(ll i=1;i<=1000005;++i)sum[i]=sum[i-1]+i;
	for(ll i=0;i<len;++i)
	{
		if(s[i]=='z')++num;
		if(s[i]=='y')ans+=sum[num-1];//（n-1）*n/2，如果num==1则结果为0，所以这里的情况num>=2。我直接用的等差数列计算公式转换
	}
	cout<<ans;
	return 0;
}

```

Ps：记得开long long


---

## 作者：zhangzhaoke (赞：1)

首先，先看看题

很明显，这题很简单难读懂

实际就是每一组zz后的y都是一组

注意范围，需要longlong

由于无字符串长度，所以需要strlen来测

代码如下：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int main(){
long long n=0/*计z的个数*/,a=0/*答案*/;
string k;//定义字符串   
getline(cin,k) ;//好习惯，可以输入空格
for(int i=0;i<k.size();i++){
//循环，strlen(k)的意思是k的长度 但仅限char，所以要用k.size()
    if(k[i]=='z')n++;//寻找到z后计数  
    else if(k[i]=='y'){//寻找到y后进行寻找z并进行运算 
    a+=n*(n-1)/2;//每两个z均可和一个y组成1组解 ，Cn2=n*(n-1)/2
    }   
}
cout<<a<<endl; 
//输出  
return 0;//好习惯
}
```

---

## 作者：max0810 (赞：1)

这题看了别人，感觉自己有点笨，但还是发吧。

zzy = zz + y，那么遇到一个y，就用组合数C(y前面z的数量，2）= y前面z的数量   x (y前面z的数量-1）÷ 2

代码如下
```cpp
#include<iostream>
#include<string>
using namespace std;
long long az[1000005];//az[i]表示a[0~i]里z的数量
long long ans;//记得用long long
int main()
{
    string a;
    cin >> a;
    for(int i = 0;i < a.size();i++)
    {
        if(a[i] == 'z')az[i] = (i==0?1:az[i-1]+1);//等于0时特判
        else az[i] = (i == 0?0:az[i-1]);
    }
    for(int i = 2;i < a.size();i++)
        if(a[i] == 'y')ans+=az[i]*(az[i]-1)/2;
    cout << ans;
    return 0;
}

```


---

## 作者：King_of_gamers (赞：0)

这道题需要用到动态规划的思想。

用zs【i】寄存到i为止有多少个z

用ys【i】寄存从i开始有多少个y

最后枚举i出现的位置，根据你们的数学功底，都应该知道怎么算答案了吧？更新答案（ans：=ans+zs【i-1】\*ys【i+1】）。

注意1：由于输入没有固定，所以要用到判断eof（是否输入完毕）。

注意2：由于本人有些偷懒所以没打高精度，请读者注意要用到高精度来记录答案ans，如果像我一样用int64就只有90分了。

下附上Pascal代码（偷懒版，好吧，其实是让复制代码的读者不能满分，嘿）：

```cpp
var
        m,i:longint;
        ans:int64;
        st:array[1..1000000]of char;
        zs,ys:array[0..1000000]of longint;
begin
        m:=0;
        while not eof do
        begin
                inc(m);
                read(st[m]);
        end;
        for i:=1 to m do
        if st[i]='z' then zs[i]:=zs[i-1]+1
        else zs[i]:=zs[i-1];
        for i:=m downto 1 do
        if st[i]='y' then ys[i]:=ys[i+1]+1
        else ys[i]:=ys[i+1];
        for i:=1 to m do
        if st[i]='z' then ans:=ans+zs[i-1]*ys[i+1];
        writeln(ans);
end.

```

---


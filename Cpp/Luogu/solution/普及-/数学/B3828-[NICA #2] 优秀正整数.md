# [NICA #2] 优秀正整数

## 题目描述

Aya 定义符合如下条件的正整数 $x$ 为优秀正整数：

- $x$ 为一个完全平方数；
- $x$ 的各位数位和为质数；

例如说，$25$ 是一个优秀正整数，因为 $25=5\times 5$，为完全平方数，且 $2+5=7$，为质数。

现在给定 $L,R$，请求出 $L$ 到 $R$（包含 $L$ 和 $R$）的正整数中，所有优秀正整数的乘积，对 $998244353$ 取模的值。若不存在优秀正整数，则输出 $0$。

## 说明/提示

数据保证，对于所有数据，$1 \leq L \leq R \leq 10^{12}$。

## 样例 #1

### 输入

```
1 30```

### 输出

```
400```

# 题解

## 作者：Not_defined (赞：9)

思路：本题只需要枚举 $[\sqrt{L},\sqrt{R}]$ 的数即可，平方求各数位之和，再跑一下质数筛。由于 $ R\le 10^{12}$ 所以各数位之和一定小于等于 $108$。所以这题也是非常的水，朴素筛法埃筛和线性筛均可过此题。
### My code
```c
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int l,r;
bool vis[110];
signed main()
{
	scanf("%lld%lld",&l,&r);
	vis[1]=vis[0]=1;
	for(int i=2;i<=110;i++)
	{
		for(int j=2;j*i<=110;j++)vis[i*j]=1;
	}
	int x=sqrt(l),y=sqrt(r),ans=1,flag=0;
	for(int i=x;i<=y;i++)
	{
		if(i*i<l)continue;
		int sum=0;
		int num=i*i;
		while(num)
		{
			sum+=(num%10);
			num/=10; 
		}
		if(!vis[sum])ans=((ans%mod)*(i*i%mod))%mod,flag=1;
	}
	if(!flag)puts("0");
	else printf("%lld",ans);
	return 0;
}
```


---

## 作者：maomao233 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B3828)

---

在本题中，我们既可以枚举 $[L,R]$ 区间内的所有优秀正整数，也可以直接枚举 $[1,10^{12}]$ 区间内的所有优秀正整数。这里我们以第二种为例。

首先需要判断正整数 $i$ 是否为完全平方数。当然，这不用判断，我们在循环枚举的时候，就可以直接使用 $i\times i$ 这个正整数。也就是说，我们在进行循环枚举的时候，直接在 $[1,\sqrt{10^{12}}=10^6]$ 这个范围内枚举即可。

然后开始判断 $i$ 的各位数位和是否为质数。首先先一位一位地将 $i$ 的各位数位累加求和，注意到 $i\le10^6$，于是可以直接使用普通质数判断。这样下来若满足“各位数位和为质数”条件，则直接存入数组即可。

接下来就是读入 $[L,R]$，并在数组里扫一遍，若此数在 $[L,R]$ 范围内，则直接将其对答案求积并取余即可，最后输出答案即可完成本题。

不过考虑到答案可能很大，于是开个 `__int128` 是个不错的主意。因为此代码的时间复杂度正确，也不会有太多常数。

最后特别地，若求积变量仍为初始值，则说明在 $[L,R]$ 区间内没有一个优秀正整数，输出 $0$ 即可，需要特判。

于是得代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int __int128
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
const int p=998244353;
inline bool chk(int x)
{
	if(x<=1)
	{
		return 0;
	}
	for(int i=2;i*i<=x;i++)
	{
		if(x%i==0)
		{
			return 0;
		}
	}
	return 1;
}
int a[1000001];
signed main()
{
	int cnt=0;
	for(int i=1;i*i<=1e12;i++)
	{
		int x=i*i;
		int ans=0;
		while(x)
		{
			int t=x%10;
			ans+=t;
			x/=10;
		}
		if(chk(ans))
		{
			cnt++;
			a[cnt]=i*i;
		}
	}
	int l,r;
	rd(l,r);
	int ans=1;
	for(int i=1;i<=cnt;i++)
	{
		if(a[i]>=l&&a[i]<=r)
		{
			ans=(ans*a[i])%p;
		}
	}
	wtl(ans==1?0:ans);
	return 0;
}
```

---

## 作者：Jasoncwx (赞：2)

## 题目思路
对于这道题，我们可以枚举 $[L,R]$ 之间的完全平方数，在判断数位和是否为质数即可。

如何知道 $[L,R]$ 时间的平方数呢？

我们可以求出 $\lfloor\sqrt{L}\rfloor$ 和 $\lfloor\sqrt{R}\rfloor$，$[\lfloor\sqrt{L}\rfloor,\lfloor\sqrt{R}\rfloor]$ 就是 $[L,R]$ 里所有平方数的平方根。

最后记得答案要对 $998244353$ 取模。
## 代码
```cpp
//By Jasoncwx
#include<bits/stdc++.h>
#define R register
#define us unsigned
#define ll long long
inline ll read(){R ll s=0,w=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}return s*w;}
inline void print(ll x){if(x<0){putchar('-');x=-x;}if(x>=10)print(x/10);putchar(x%10+'0');return;}
using namespace std;
const int mod=998244353;
bool f(ll n){//判断是否为质数
	if(n<=1)return false;
	for(int i=2;i*i<=n;i++){
		if(n%i==0)return false;
	}
	return true;
}
int main(){
	ll l=read(),r=read(),ans=1;
	ll b=sqrtl(l),e=sqrtl(r);//l和r之间的平方数的平方根
	bool ff=false;
	for(ll i=b;i<=e;i++){
		if(i*i<l)continue;
		if(i*i>r)break;
		ll t=i*i,sum=0;
		while(t){//数位分解
			sum+=t%10;
			t/=10;
		}
		if(f(sum)){
			ans=((ans%mod)*(i*i%mod))%mod;ff=true;//答案
		} 
	}
	if(!ff)cout<<0;//无解
	else cout<<ans;
	return 0;
}
```


---


# [NICA #2] 回溯的雨

## 题目描述

小 Ran 有两个正整数 $x,y$，她还有两个长度为 $n$ 的正整数序列 $a$ 与 $c$ 满足 $a_ix+y=c_i$ （$1\le i\le n$）。

很可惜的是，她忘记了所有 $a_i$ 的值与 $y$ 的值。她给你了 $x$ 的值与序列 $c$，并希望你能还原出一组 $y$ 的值与序列 $a$ 使得原先的条件被满足。

当然，可能存在很多组这样的解，所以她希望你能最大化 $y$ 的值并输出它（注意到你并不需要输出 $a$ 序列）。如果不能还原出这样一组数，请输出 $-1$ 来报告无解。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$，$1 \leq x \leq 10^{12}$，$1 \leq c_i \leq 10^{18}$。

## 样例 #1

### 输入

```
5 2
4 6 8 10 12```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
3 6 9 12 15```

### 输出

```
-1```

# 题解

## 作者：fish_shit (赞：7)

对于这道题，我们先判断无解的情况

$1$：输入的 $c_i$ 小于等于 $x$。因为 $y$ 和 $a_i$ 都为正整数，也就是说它们一定大于 $0$。所以 $c_i$ 一定大于等于 $x + 1$，也就是大于 $x$。
 
$2$：$c$ 序列中相邻的元素的差不能被 $x$ 整除。为了满足 $a_ix+y=c_i$，$c$ 序列中的所有元素一定是模 $x$ 的同余类。

除了无解的情况，我们只需输出 $c$ 序列中最小的元素减去 $x$ 就行了。

**注意：一定要开 long long！**

最后，附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[100100];
int main(){
	long long n,x;
	cin>>n>>x;
	long long minn=1e18+100;
	for(int i=1;i<=n;i++){
		cin>>c[i];
		if(c[i]<=x){//第一种无解情况
			cout<<"-1";
			return 0;
		}
		if(i>=2){
			if((c[i]-c[i-1])%x!=0){//第二种无解情况
				cout<<"-1";
				return 0;
			}
		}
		if(c[i]<minn){//取最小值
			minn=c[i];
		}
	}
	cout<<minn-x;//输出
	return 0;
}
```
望管理员大大通过！

---

## 作者：User757711 (赞：3)

# [B3830 [NICA #2] 回溯的雨](https://www.luogu.com.cn/problem/B3830)题解
### 简要题意
 给定一个数 $x$ 和一个序列 $c$，构造一个序列 $a$ 和一个数 $y$，对任意的 $1\le i\le n$，满足 $a_ix+y=c_i$，无解输出 $-1$。
### 首先，我们来分析一下无解的情况，无解有两种情况：
 1：$c_i$ 小于等于 $x$。因为 $y$ 和 $a_i$ 都大于等于 $0$ ，所以 $c_i$ 一定大于 $x$。
 
 2：$c$ 序列任意两个元素模 $x$ 的结果不同。题目中说到 $a_ix+y=c_i$，所以 $c$ 序列中的任意元素模 $x$ 都同余。

### 如果不是无解：
为了让 $y$ 能够尽量大，所以只能让 $a_i$ 尽量小，所以可以将序列 $c$ 排序从小到大，输出最小元素减 $x$，即 $c_1-x$。
### 一定要注意：不开long long见祖宗！！！
### 最后：附上AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans=1e18+114514;
ll c[100050]; //一定开long long
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	ll n,x;
	cin>>n>>x;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];
	}
	sort(c+1,c+1+n); //从小到大排序
	for(int i=1;i<=n;i++)
	{
		if(c[i]<=x||i>=2&&c[i]%x!=c[i-1]%x) //判断是否无解
		{
			cout<<-1;
			return 0;
		}
	}
	cout<<c[1]-x; //输出答案
	return 0;
}
```
### 本人码风奇丑，大佬勿喷。
### 望管理大大通过QwQ。

---

## 作者：Chenyichen0420 (赞：3)

## 简要题意

给你一个数 $x$ 和一个数列 $c$，请你构造一个数列 $a$ 和一个数 $y$，使得对于所有的 $1\le i \le n$，满足 $a_i x+y=c_i$。

## 思路分析

实际上，如果我们忽略原式中的 $y$，即将原式的两端都减去 $y$，那么有 $a_i x=c_i-y$，所以如果对于所有的 $1\le i \le n$，满足 $c_i-y$ 能被 $x$ 整除，那么 $a$ 一定有解，反之无解。

换言之，我们可以得到 $c_1 \equiv c_2 \equiv c_3 \equiv\dots\equiv c_n \pmod x$。

因此，我们可以以此为依据判断是否有解。

接下来的问题是 $y$ 的最大值怎么求？

这个其实非常好办。既然他要求这些数列是正整数序列，那我就让 $c$ 中的最小值变为 $x$，即使 $a_i=1$，这样就可以让其对应的 $y$ 值更大。

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define int long long
int n, x, c[100001];
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> x;
	for (register int i = 1; i <= n; ++i) cin >> c[i];
	sort(c + 1, c + n + 1);
	if (c[1] < x) {
		cout << "-1\n";
		return 0;
	}
	for (register int i = 2; i <= n; ++i) {
		c[i] -= c[1];
		if (c[i] % x != 0) {
			cout << "-1\n";
			return 0;
		}
	}
	cout << c[1] - x << endl;
	return 0;
}
```

---

## 作者：Undertale_chara (赞：2)

其实这是一道简单的数学结论题。

首先，不难得出 $a_i=(c_i-y)/x$，因为 $x,y,a_i,c_i$ 均为正整数。
# SO。
得出结论：若存在符合题意的序列 $a$ 及正整数 $y$，则序列 $c$ 中的元素为模 $x$ 的同余类。

那么我们只需对 $c$ 中的元素依次判断是否模 $x$ 同余即可判断是否存在符合题意的序列及正整数 $y$。

其次，怎么求出 $y$ 的最大值呢？

很简单，找出只要序列 $c$ 的最小值，再运用我们之前的结论不难得出。

$y$ 的最大值等于序列 $c$ 的最小元素减去 $x$ 的值。

大功告成！

我的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
/*快读*/
ll read()
{
    ll x=0,w=1;
    char c=0;
    while(c<'0'||c>'9')
    {
        if(c=='-')
            w=-w;
        c=getchar();
    }
    while(c>='0'&&c<='9')
        x=x*10+(c-'0'),
        c=getchar();
    return x*w;
}
/*快写*/
void write(ll x)
{
    x<0?x=-x,putchar('-'):0;
    static ll sta[35];
    ll top=0;
    do
        sta[top++]=x%10,x/=10;
    while(x);
    while(top)
        putchar(sta[--top]+'0');
}
ll n,x,c[100005];
int main()
{
	n=read();x=read();
	for(long long i=1;i<=n;++i)
		cin>>c[i];
	sort(c+1,c+1+n);
	/*特判*/
	if(c[1]<x)
		write(-1),
		exit(0);
	/*判断同余*/
	for(ll i=2;i<=n;++i)
		if((c[i]-c[1])%x)
			write(-1),
			exit(0);
	write(c[1]-x);
}
```


---

## 作者：ljk8886 (赞：1)

# 分析
现将 $c$ 数组排序。由于题目中说到，$a_ix+y=c_i$，即每个 $c_i$ 同余。为了使 $y$ 尽量大，而 $x$ 和 $c_i$ 又是固定的，所以只能让 $a_i$ 尽量小，而 $1 \le a_i$，所以答案就是 $c$ 数组中最小的数减去 $x$，即 $c_1-x$。但是有些情况是无解的，当 $c_i$ 除以 $x$ 不同余或 $c_i<x$ 时，就不可能满足题意，直接特判即可。

**注意**：不开 `long long` 见祖宗。

# 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e5+5;
#define int long long//开long long 
int c[N],n,x;
signed main()
{
    cin>>n>>x;
    for(int i=1;i<=n;i++)
    {
        cin>>c[i];
    }
    sort(c+1,c+n+1);//排序 
    for(int i=2;i<=n;i++)
    {
        if(c[i]%x!=c[i-1]%x)//判断是否同余 
        {
            cout<<-1<<endl;
            return 0;
        }
    }
    if(c[1]-x<0)cout<<-1<<endl;//判断c数组中的数字是否大于x 
    else cout<<c[1]-x<<endl;
    return 0;
}
```

---

## 作者：Terry2011 (赞：0)

# 题目分析
首先，我们先化简一下式子，移项得 $a_i=\frac{c_{i}-y }{x} $，乍眼一看，$y$ 多像小学数学中的余数呀！但有一点，这里的 $y$ 不一定要小于除数 $x$。但这并不影响 $c_{i} \bmod {x}$ 为定值 $y$。这样一来就简单了！我们先判断 $c_{i} \bmod {x}$ 是否一样。不一样直接输出 $-1$ 即可华丽结束。如果一直都为定值的话，最后用 $c$ 数组中的最小值减去 $x$ 就是 $y$ 的最小值了。由此可见，如果 $c$ 数组中的最小值小于 $x$，方为无解。最后，注意数据范围就行了。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,c[1000050];//不开long long见祖宗，全局变量
int main(){
	{cin>>n>>x;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
   //输入
   }
	{long long yu=c[1]%x;
	for(int i=1;i<=n;i++){
		if(c[i]%x!=yu){
			cout<<-1;
			return 0;
		}
	}
   //余数判断环节
   }
   {sort(c+1,c+1+n);//排序，注意左闭右开
	if(c[1]<x){
    cout<<-1;
   }else{
    cout<<c[1]-x;
   }
   //最终特判
   }
	return 0;
}
```

---

## 作者：Clarinet (赞：0)

# 简要题意
给出公式 $a_{i}x+y=c_{i}$ 这一公式和 $x$ 与**正整数**序列 $c$，让我们求出最大的 $y$ 或在无解的情况下输出 -1。
# 分析
又是一道数学题，学过小学除法的你肯定能快速地将原式化作 $(c_{i}-y) \div x=a_{i}$。在这个式子中，不难发现 $y$ 很像除法中的余数。不过不同的是在这个式子中 $y$ 不一定要比 $x$ 小。同时为了保证 $y$ 作为定值一直不变，我们可以先判断整个 $c$ 数组取余 $x$ 的余数是否不变，再排序找到 $c$ 数组的最小值减去 $x$ 就是 $y$ 的最大值啦。  
**一定要记得开 long long！**
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,c[100010];//记得一定要开long long哦 
int main(){
	cin>>n>>x;
	for(int i=1;i<=n;i++){//输入 
		cin>>c[i];
	}
	sort(c+1,c+1+n);
	long long pd=c[1]%x;//判断余数是否相同 
	for(int i=1;i<=n;i++){
		if(c[i]%x!=pd){
			cout<<-1;
			return 0;
		}
	}
	if(c[1]<x)cout<<-1;//特判一种情况 
	else cout<<c[1]-x;
	return 0;
}
```
感谢阅读！

---


# [中山市赛 2024] 除法运算

## 题目描述

Jimmy 开始学习除法啦！一开始他学习了余数为 $0$ 的除法（也就是我们常说的整除），后来又学习了余数不为 $0$ 的除法，所以 Jimmy 对被除数、除数、商、余数这些概念都已经了如指掌了。

有一天，他忽然思考起一个问题——给一个正整数 $n$ 作为被除数，除数 $k$ 可以取任意正整数，那么会有多少互不相同的商呢？

例如：被除数 $n = 5$，无论除数 $k$ 如何变化，商最多也只有 $4$ 个不同的值，分别为 $0, 1, 2, 5$。这是因为：

* $5 \div 6 = 0 \dots 5$
* $5 \div 5 = 1 \dots 0$
* $5 \div 4 = 1 \dots 1$
* $5 \div 3 = 1 \dots 2$
* $5 \div 2 = 2 \dots 1$
* $5 \div 1 = 5 \dots 0$

Jimmy 作为一个天才，对这么简单的问题自然是手到擒来，于是他拿着这个问题向你发起了挑战。你能回答这个问题吗？

## 说明/提示

### 数据范围

- 对于 50% 的数据，保证 $1 \leq n \leq 10^5$。
- 对于 100% 的数据，保证 $ 1 \leq T \leq 10$，$1 \leq n \leq 10^9$。

## 样例 #1

### 输入

```
2
5
11```

### 输出

```
4
0 1 2 5
6
0 1 2 3 5 11```

# 题解

## 作者：_Pioneer_ (赞：6)

这道题第一感觉就是暴力，即枚举从１到 $n+1$ 作为除数的商。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a[10000000];
int main()
{
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		int p=1,cnt=0;
		for(int i=n+1;i>=1;i--){
			int k=n/i;
			if(k==p)continue;
			else a[++cnt]=k,p=k;
		}
		cout<<cnt<<endl;
		for(int i=1;i<=cnt;i++)cout<<a[i]<<" ";
		cout<<endl;
	}
    return 0;
}
```
然而，不出意外，[TLE了一半](https://www.luogu.com.cn/record/204683326)。

所以优化是本题的关键。枚举的时候可以联想到判断一个数是否为素数时，仅需枚举到 $\sqrt{n}$。

同理，此题我们处理除数时，枚举到 $i$ 时，同时将 $n/i$ 压入数组内，枚举到 $\sqrt{n}$ ，最后再用 sort 排列一下就行了。（需要注意当 $n$ 为完全平方数时仅需压入一个）

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a[10000000];
int main()
{
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		int cnt=1;
		a[cnt]=0;
		for(int i=1;i<=sqrt(n);i++){
			if(n/i==i)a[++cnt]=i;
			else {a[++cnt]=i;a[++cnt]=n/i;}
		}
		sort(a+1,a+cnt+1);
		cout<<cnt<<endl;
		for(int i=1;i<=cnt;i++)cout<<a[i]<<" ";
		cout<<endl;
	}
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

# 我的解题思路
- 在每次输入循环中，定义 $dis$ 数组，用于存储 $n$ 的所有因数。再定义一个 $c$，一定要赋值成 $0$，再定义一个一个计数器，用于记录因数的数量。
- 寻找因数，定义 $q=n\div k$，计算 $k$ 是否是 $n$ 的因数，如果是，则 $q$ 也是 $n$ 的因数。接着，将 $q$ 添加到因数数组中，然后判断：如果 $k$ 和 $q$ 不相等（即 $k$ 和 $q$ 是不同的因数），则将 $k$ 也添加到因数数组中。
- 在因数数组的末尾添加一个标志值 $0$，表示因数数组的结束。
- 对 $dis$ 数组进行 sort 排序。
- 到了输出部分，在每一个循环中，都要先输出因数的总数 $c$，换行；然后输出 $dis$ 数组，每个元素之间用空格隔开。
# 上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n;
int main() {
    cin>> t;
    while(t--) {
        cin>> n;//前面的都是输入。
        int dis[200001], c=0;//dis 用于存储 n 的所有因数，c 用于计算因数的个数。
        for (int k=1;k<=sqrt(n);k++) {
            int q=n/k;
            dis[c++]=q; 
            if (k!=q) dis[c++]=k;
        }//这个循环用于寻找因数
        dis[c++]=0;在因数数组的末尾添加一个标志值 0，表示因数数组的结束。
        sort(dis,dis+c);//排序
        cout<<c<<endl;//输出的因数个数
        for (int i=0;i<c;i++) cout<<dis[i]<<" ";//输出存储 n 的因数。
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：yedalong (赞：2)

挺有趣的一道思考题。
## Solution
假设我们现在有一个式子：$n\div x=y…z$。  

由于数据很大，没法暴力枚举每一个 $x$，因此，我们就尽可能的让每一次枚举都是不同的 $y$。  
观察到，如果我们将 $x$ 减去 $1$，在 $y$ 不变的情况下，$z$ 会加上 $y$，这个地方大家可以停下思考一下。  
那么，对于当前除数和余数的差距，我们可以直接用 $O(1)$ 的时间复杂度算出 $x$ 要减到多少才能使得 $x\le z$，由于余数必须小于除数，所以这时候就相当于 $y$ 会改变。  
具体要怎么计算呢？对于 $x-z$ 的差距，$x$ 每减去 $1$，都能缩进 $y+1$ 的距离，因此，计算方式就显而易见了。  

都讲到这里了，建议大家先自己试着打打看代码，不要急着看我的代码，因为其实还有一个小细节，你们可以去思考一下。
## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n,ans,cnt;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		ans=1;
		for(int i = n;i>=1;i--){
			ans++;
			i-=(i-n%i)/(n/i+1)-((i-n%i)%(n/i+1)==0);//这里为什么要减去这玩意呢？试着自己思考一下
		}
		cout<<ans<<'\n';
		cout<<"0 ";
		for(int i = n;i>=1;i--){
			cout<<n/i<<' ';
			i-=(i-n%i)/(n/i+1)-((i-n%i)%(n/i+1)==0);//这里为什么要减去这玩意呢？试着自己思考一下 
		}
		cout<<'\n';
	}
	return 0;
}
```
这里公布一下细节。由于我的写法，每次循环结束 $x$ 都会自动减 $1$，所以对于可以整除的情况，那就是除数和余数相等了，这时候也是不行的，再减去 $1$ 就多减了，因此要加回来。  
对于另一种写法，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n,ans,cnt;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		ans=1;
		for(int i = n;i>=1;){
			ans++;
			i-=(i-n%i)/(n/i+1)+((i-n%i)%(n/i+1)>0);
		}
		cout<<ans<<'\n';
		cout<<"0 ";
		for(int i = n;i>=1;){
			cout<<n/i<<' ';
			i-=(i-n%i)/(n/i+1)+((i-n%i)%(n/i+1)>0);
		}
		cout<<'\n';
	}
	return 0;
}
```

对于小细节，一样的道理，这里就不多赘述了。

---

## 作者：bjcakioi (赞：1)

很明显的让我们去重，所以我们可以用 STL 中的 set 来去重。

直接暴力会 TLE 一半的点，只有 50 分，所以需要优化。

每一次除法都会有一个除数和商，商到了自己做除数的时候，以前的除数就是商了，所以可以显著的减少循环次数。

最后用 set 去重一遍输出就可以了。

贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n;
	for(int i=1;i<=n;i++){
        cin>>m;
		set<int>s{0};
		for(int j=1;j<=sqrt(m);j++){
			s.insert(m/j);
            s.insert(j);
		}
		cout<<s.size()<<endl;
		 for(int p:s){
             cout<<p<<" ";
         }
        cout<<endl;
		
	}
	return 0;
} 
```

---

## 作者：DemonPlayer (赞：0)

### 思路：
枚举所有除数，考虑到因数是成对出现的，所以只要到 $\sqrt{n}$，但还要记录另一个因数，存起来，再排序。
```cpp
#include<bits/stdc++.h>
using namespace std;

int T,n,to,ans[1000005],tmp,len;

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		to=sqrt(n);
		len=0;
		for(int i=1;i<=to;i++){
			tmp=n/i;
			ans[++len]=tmp;
			if(i!=tmp){
				ans[++len]=i;
			}
		}
		sort(ans+1,ans+len+1);
		cout<<len+1<<"\n0 ";
		for(int i=1;i<=len;i++){
			cout<<ans[i]<<' ';
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4184 [中山市赛 2024] 除法运算](https://www.luogu.com.cn/problem/B4184)
## 思路：
注意啦！注意啦！各位，我先在这里提醒一下，本题务必优化！不然要超时！

既然题目让我们求的是一个正整数 $n$ 作为被除数，除以 $k$ 会有多少互不相同的商。通过题目给的例子可以发现，除数 $k$ 只要从 $1$ 枚举到 $n+1$ 即可。为了优化时间，除数 $k$ 只要从 $1$ 枚举到 $\sqrt{n}$ 即可，再把所得到的商存入数组中去即可。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[10000000],k;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		k=1;a[k]=0;
		for(int i=1;i<=sqrt(n);i++)
			if(n/i==i)a[++k]=i;
			else a[++k]=i,a[++k]=n/i;
		sort(a+1,a+k+1);
		cout<<k<<'\n';
		for(int i=1;i<=k;i++)cout<<a[i]<<" ";
		cout<<'\n';
	}
}
``````

---

## 作者：Bill_luogu (赞：0)

## 题目思路：
我们枚举每一个除数，我们都知道商等于被除数除以除数，于是我们开两个数组，一个用来标记当前的商有没有出现过，一个用来记录商，最后把商按从小到大排序。时间复杂度大约为：$\Theta(T\times\sqrt{n})$，可以通过。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int t;
long long n,cnt,a[100000010];
bool v[1000000010];
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		cnt=0;
		a[++cnt]=0;
		for(long long i=1;i*i<=n;i++)//枚举除数
		{
			if(!v[n/i])//判断商是否出现过
			{
				a[++cnt]=n/i;//记录商
				v[n/i]=1;
			}
			if(!v[i])
				a[++cnt]=i;//除数自己也可以是商，因为n/(n/i)的结果也可以是商（这里的i是上面的除数）
		}
		sort(a+1,a+1+cnt);//排序
		cout<<cnt<<endl;
		for(long long i=1;i<=cnt;i++)
		{
			cout<<a[i]<<' ';
			v[a[i]]=0;//一定要记得清空
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：DashZhanghanxu (赞：0)

# 解析
可以尝试用桶排序去重，但每次初始化桶排序数组花费时间太长，因此我建议用 set 去重。

枚举每个除数，计算答案（答案为除数与商，因为商做除数时，答案就是之前的除数，这样可以减少循环次数），将答案储存到 set 中，利用 set 去重，最后从小到大循环输出答案即可。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int T,n;cin>>T;
    while(T--){
        cin>>n;
        set<int> s{0};
        for(int k=1;k*k<=n;k++) s.insert(n/k),s.insert(k);
        cout<<s.size()<<'\n';
        for(int x:s) cout<<x<<' ';
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：Eterna (赞：0)

对于 $\displaystyle f(x)= \frac{n}{x} $ 显然不增。

随着 $x$ 的增长，$[f(x)-f(x+1)]$ 也会逐渐减小。

但是题目中的是 $\lfloor \displaystyle \frac{n}{x} \rfloor$，$ \displaystyle (\lfloor \frac{n}{x} \rfloor - \lfloor \frac{n}{x+1} \rfloor)$ 并非严格不增，但是向下取整最多使不增差 $1$。

也就是说，当一个商 $k$ 至少出现了 $2$ 次，则 $[0,k]$ 的所有整数都可以为商。

而只出现一次的商数量是 $O(\sqrt{n})$ 的，我们可以枚举这些商，然后特判其他的商。

我使用了 `map` 判重，复杂度为 $O(T \sqrt{n} \log n)$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;vector<int> v;
map<int,int> mp;
void solve()
{
	cin>>n;mp.clear(),v.clear();
	for(int i=1;i<=n+1;i++)
	{
		if(!mp[n/i])mp[n/i]=1,v.push_back(n/i);
		if(i>1&&n/i==n/(i-1))break;
	}
	sort(v.begin(),v.end());
	cout<<v[0]+v.size()<<'\n';
	for(int i=0;i<v[0];i++)cout<<i<<' ';
	for(int i=0;i<v.size();i++)cout<<v[i]<<' ';
	cout<<'\n';
}
signed main()
{
	int T;cin>>T;
	while(T--)solve();
	return 0;
}
```

以下 update。

突然想到使用 `map` 是没有必要的。

因为我们找的就是出现次数不少于 $2$ 的数，只需要判断相邻的两个商是否相等即可。

时间复杂度 $O(T\sqrt{n})$，运行时间只有上面代码的一半。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;vector<int> v;
void solve()
{
	cin>>n;v.clear();
	for(int i=1;i<=n+1;i++)
	{
		if(i>1&&n/i==n/(i-1))break;
		v.push_back(n/i);
	}
	sort(v.begin(),v.end());
	cout<<v[0]+v.size()<<'\n';
	for(int i=0;i<v[0];i++)cout<<i<<' ';
	for(int i=0;i<v.size();i++)cout<<v[i]<<' ';
	cout<<'\n';
}
signed main()
{
	int T;cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：canwen (赞：0)

## Solution
简单题，提供 $O(T\sqrt{n})$ 的做法。

首先枚举 $i\gets 1 \sim \sqrt{n}$，我们可以同时统计 $\lfloor \frac{n}{i} \rfloor$ 以及 $\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$ 这两个商有没有出现过，使用 `map` 内部自动排序，遍历答案即可。

~~常数巨大，大家不要学习~~。
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
int n,T;
std::map <int,bool> m;
signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0), std::cout.tie(0);
	std::cin>>T;
	while(T--){
		std::cin>>n;
        int cnt = 0;
		m.clear();
        m[0] = 1, cnt++;
		for(int i=1;i<=sqrt(n);++i){
			if(m[n/i] == 0){
				m[n/i]=1, ++cnt;
			}
            if(m[n/(n/i)] == 0){
                m[n/(n/i)] = 1, ++cnt;
            }
		}
        std::cout << cnt << '\n';
        for(auto j:m){
            std::cout << j.first << " ";
        }
		std::cout<< '\n';
	}
}
```

---


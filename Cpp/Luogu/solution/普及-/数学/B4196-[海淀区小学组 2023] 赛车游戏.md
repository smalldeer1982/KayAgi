# [海淀区小学组 2023] 赛车游戏

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

陶陶和天天喜欢玩赛车游戏，在游戏中有一条直赛道长度为 $ l $，陶陶的赛车在起点为 $0$ 的位置，准备向终点行驶，天天的赛车在终点为 $ l $ 的位置，准备向起点行驶。赛车的初始速度都为 $1$，在赛道上有 $ n $ 个加速带，第 $ i $ 加速带的位置为 $ a_i $，当小车经过一个加速带时，它的速度就增加 $1$，请你帮忙计算出两车相遇时间。

## 说明/提示

对于 $100\%$ 的数据： $ 1 \leq T \leq 10^4 $， $ 1 \leq n \leq 10^5 $， $ 1 \leq l \leq 10^9 $， $ 1 \leq a_1 < a_2 < \ldots < a_n < l $。

保证所有测试用例中 $ n $ 的总和不超过 $ 10^5 $。

## 样例 #1

### 输入

```
5
2 10
1 9
1 10
1
5 7
1 2 3 4 6
2 1000000000
413470354 982876160
9 478
1 10 25 33 239 445 453 468 477```

### 输出

```
3.000000000000000
3.666666666666667
2.047619047619048
329737645.7500000
53.70000000000000```

# 题解

## 作者：Sliarae (赞：5)

首先预处理 $s_i$ 表示正着从 $0$ 走到 $a_i$ 的最小代价，$p_i$ 表示倒着从 $l$ 走到 $a_i$ 的最小代价。

钦定两个人最终在第 $i$ 到第 $i + 1$ 个加速带之间相遇。那么前面的人会花费 $s_i$ 的时间，后面的人会花费 $t_{i + 1}$ 的时间。中间还有 $d = a_{i + 1} - a_i$ 的距离要两个人一起走。

此时考虑让两个人中用时小的一个先走，如果他用这个时间差将 $d$ 的路程走完了说明不合法。否则这时两个人用时相同，此时他们的速度之和可以看作 $n + 2$，在将 $\frac{d}{n + 2}$ 加到答案中即可。

时间复杂度 $O(n)$。

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

const int kN = 1e5 + 5;
const double Inf = 1e9;

int n;
int a[kN];
double p[kN], s[kN];

void Solve () {
	cin >> n >> a[n + 1];
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	p[0] = 0; 
	for (int i = 1; i <= n; ++i) 
		p[i] = p[i - 1] + (a[i] - a[i - 1]) * 1.0 / i;
	s[n + 1] = 0; 
	for (int i = n; i; --i)
		s[i] = s[i + 1] + (a[i + 1] - a[i]) * 1.0 / (n - i + 1);
	double ans = Inf;
	for (int i = 0; i <= n; ++i) {
		double d = a[i + 1] - a[i];
		double x = p[i], y = s[i + 1];
		if (x < y) {
			d -= (y - x) * (i + 1);
			x = y; 
		}
		else {
			d -= (x - y) * (n - i + 1);
			y = x;
		}
		if (d > 0)
			x += d / (n + 2);
		ans = min(ans, x);
	}
	cout << fixed << setprecision(12) << ans << '\n';
}

int main () {
	cin.tie(0)->sync_with_stdio(0);
	int T;
	cin >> T;
	while (T--) Solve();
	return 0; 
}
```

---

## 作者：zhaiziyiJoey (赞：4)

# 题目传送门：
### [B4196 赛车游戏](https://www.luogu.com.cn/problem/B4196)
# 思路：
用双指针的方法，两辆车分别从左端和右端向中间移动，每一次计算一下两辆车跟各自最近的加速点的距离，哪个近就把这辆车移动到跟它最近的加速点那里，然后更新总时间、两辆车的位置与速度，并更新距离它最近的加速点的编号。

当两辆车之间不存在任何加速点时，就应跳出循环，同时因为它们的速度已经固定，所以最后的最终的相遇时间公式为： 
$总时间+(两车距离)/(两车速度和)$。

# 代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a[100010];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,l;
		cin>>n>>l;//n代表有几个加速点，l代表赛道长度
		for(int i=1;i<=n;i++) cin>>a[i];//加速点的位置
		double ap=0,bp=l,time=0,t1=0,t2=0;
        //ap是a车的位置，bp是b车的位置，time是总时间
        //t1是a车到离它最近的加速点的时间，t2是b车到离它最近的加速点的时间
		int na=1,nb=n,v1=1,v2=1;
        //na是a车的下一个加速点的编号，nb是b车的下一个加速点的编号
        //v1是a车的速度，v2是b车的速度
		while(na<=nb){
			t1=(a[na]-ap)/v1;
			t2=(bp-a[nb])/v2;
			if(t1<t2){
				ap=a[na];//更新位置
				bp-=t1*v2;//更新位置
				v1++;//更新速度
				na++;//更新a车下一个加速点的编号
				time+=t1;//更新总时间
			}
			else{
				ap+=t2*v1;//更新位置
				bp=a[nb];//更新位置
				v2++;//更新速度
				nb--;//更新b车下一个加速点的编号
				time+=t2;//更新总时间
			}
		}
        //输出按上面的公式就行了
		cout<<fixed<<setprecision(6)<<time+(bp-ap)/(v1+v2)<<endl;
	}
	return 0;
}
```

第一篇题解，求过！

---

## 作者：hlsnqdmz (赞：2)

感觉自己的做法很奇怪，不过还是过了。

具体来说，就是以双指针表示两辆赛车的位置，搜索离两辆赛车最近的加速带，让到加速带时间更短的赛车（后称为时间短的车，另一辆车称为时间长的车或另一辆车）位置更新到此加速带，另一辆前进相对的距离，直到加速带全部搜索完后再让答案加上两车距离除以两车速度之和，因为没有加速带后两车的速度不会改变，由于会有小数的存在，所以答案和双指针都改为 double 就好了（另外如果不知道 deque 是什么的继续往下看就好了）。

具体代码如下：

```
//Just Sayori
#include <bits/stdc++.h>
using namespace std;
#define ll long long//定义宏，但这道题没什么用处。
inline ll read()//快读，如果不清楚可以直接 cin 或者 scanf。
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}
int a;
deque<int> q;//双端队列，用来记录加速带。
int main()
{
    int t = read();
    while (t--)
    {
        int n = read(), m = read();
        for (int i = 1; i <= n; i++) a = read(), q.push_back(a);
        double l = 0, r = m, sl = 1, sr = 1, ans = 0; //记得开 double。
        while (!q.empty())//如果有加速带。
        {
            if ((q.front() - l) * 1.0 / sl <= (r - q.back()) * 1.0 / sr)//判断两辆车到各自最近的加速带的时间。
            {
                r -= (q.front() - l) * 1.0 / sl * sr;//另一辆车移动相应的距离。（时间乘上自身速度）
                ans += (q.front() - l) * 1.0 / sl;//答案增加。
                l = q.front();//时间短的车直接移动到该加速带。
                q.pop_front();//删除加速带。
                sl++;//时间短的车速度增加
            }
            else
            {
                l += (r - q.back()) * 1.0 / sr * sl;
                ans += (r - q.back()) * 1.0 / sr;
                r = q.back();
                q.pop_back();
                sr++;
            }
        }
        ans += (r - l) * 1.0 / (sl + sr) * 1.0;//最后加上两车之距与两车速度和的商。
        printf("%.15lf\n", ans);//输出答案可以直接不加小数位数的输出。
    }
    return 0;
}

```
另外记得判断的是两车到下一加速带花费的时间，而非距离，另一辆车移动的距离也是时间短的车移动花费的时间乘上时间长的车的速度，答案记录的也是花费的时间，否则如果两车都移动时间短的车到下一加速带的距离，答案增加的也是两车移动距离之和除以速度之和就会只得十分（除了我这样的蒟蒻也没有人会这样写吧）
比如：

```
while (!q.empty())
{
  if (q.front() - l <= r - q.back())
  {
      r -= (q.front() - l);
      ans += (q.front() - l) * 2.0 / (sl + sr);
      l = q.front();
      q.pop_front();
      sl++;
  }
  else
  {
      l += (r - q.back());
      ans += (r - q.back()) * 2.0 / (sl + sr);
      r = q.back();
      q.pop_back();
      sr++;
  }
}
```
最近 deque 用多了什么题都在用，这里也可以用数组代替（不过更麻烦？），因为这道题加速带给出的位置是递增的，简单讲解一下：deque 是 C++STL（标准模板库）的一个容器，它允许在两端进行插入和删除操作，功能非常强大，使用它需要包含头文件 include<deque> 当然用万能头就不用担心了，它的用法如下：

```
//定义：
deque<int> q1;
deque<long long>q2;
deque<double> q3;
deque<string> q4;
```
```
//常见函数：
deque<int> q;//先定义。
int x;
q.push_front(x);//在队列头部插入元素。
q.push_back(x);//在队列尾部插入元素。
q.pop_front();//在队列头部删除元素。
q.pop_back();//在队列尾部删除元素。
q.front();//返回队列头部元素。
q.back();//返回队列尾部元素。
q.empty();//如果队列为空，返回 1，否则返回 0。
q.size();//返回队列长度。
//不要像我这样把队列元素删完还让队列返回值，会出事的。
```
感谢您的观看！

---

## 作者：liwanxian (赞：1)

## 前置知识

速度公式：$V = \frac{S}{T}$。

路程公式：$S = V \times T$。

时间公式：$T = \frac{S}{V}$。

## 思路：

本题可以通过模拟两车的行驶过程来计算相遇时间。

- 对于每组测试数据，定义两辆车的位置、速度、下一个加速带的下标位置和总时间的变量。特别的，如果你定义这些变量是在**循环外**，要记得**清空原变量的值**，不然爆零两行泪啦。

- 在两车还未经过所有加速带时，计算两辆车到达下一个加速带所需的时间。

- 根据两车到达下一个加速带的时间关系，更新两车的位置、速度和总时间。

- 当两车经过所有加速带后，计算两车之间的剩余距离。而因为**加速带全部使用**，两车的当前速度**已经固定**，所以可以直接相遇时间。

  
  - 相遇时间公式：$T + (B - A) \div (Va + Vb)$。

最后输出结果就好啦！

## 代码

我希望你看它不是用来抄袭。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--){
		int n,l;
		cin>>n>>l;
		int a[n+5];
		memset(a,0,sizeof(a)); 
		for(int i=1;i<=n;i++) cin>>a[i];
		double tm1=0,tm2=0,anst=0,a_pos=0,b_pos=l;
		int left=1,right=n,va=1,vb=1;//赛车初始速度为 1 
		while(left<=right){
			tm1=(a[left]-a_pos)/va;
			tm2=(b_pos-a[right])/vb;
			if(tm1<tm2){
				a_pos=a[left];
				b_pos-=vb*tm1;//b 车在这段时间，即 tm1 的时间里继续行驶 
				va++,left++,anst+=tm1;//根据题目，速度加 1 
			}
			else{
				a_pos+=va*tm2;//继续走 
				b_pos=a[right];
				right--,vb++,anst+=tm2;
			}
		}
		printf("%.6f\n",anst+(b_pos-a_pos)/(va+vb));
	}
	return 0;
}
```

[我](https://www.luogu.com.cn/record/208403550)是记录。

---

## 作者：封禁用户 (赞：0)

# 思路
用双指针模拟两辆车的行动过程，最后在两者相遇一秒内使用公式 $time+\dfrac{S}{V}$ 计算，其中 $S$ 是两车距离，$V$ 是两车速度和。

**注意精度问题。**

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+4;
int t,n,l,a[N];
int main(){
	cin>>t;
	while(t--){
		cin>>n>>l;
		for(int i=1;i<=n;i++) cin>>a[i];
		double aa=0,bb=l,tm=0,t1=0,t2=0;
        //aa是a车的位置，bb是b车的位置，tm是总时间
        //t1是a车到离它最近的加速点的时间，t2是b车到离它最近的加速点的时间
		int anet=1,bnet=n,va=1,vb=1;
        //anet是a车的下一个加速点的编号，bnet是b车的下一个加速点的编号
        //va是a车的速度，vb是b车的速度
		while(anet<=bnet){
			t1=(a[anet]-aa)/va;
			t2=(bb-a[bnet])/vb;
			//以下是更新 
			if(t1<t2){
				aa=a[anet];
				bb-=t1*vb;
				va++;
				anet++;
				tm+=t1;
			}
			else{
				aa+=t2*va;
				bb=a[bnet];
				vb++;
				bnet--;
				tm+=t2;
			}
		}
		printf("%.6f",tm+(bb-aa)/(va+vb));//保留6位小数 
	}
	return 0;
}
```
**请勿照抄题解。**

---


# [朝阳区小学组 2019] square

## 题目背景

数据为洛谷自造。本场比赛第六题为 [P2261 余数求和](https://www.luogu.com.cn/problem/P2261)，请前往该题目交题。

## 题目描述

任意一个边长是整数的长方形都可以分割成若干个边长是正整数的正方形，分割的方式有很多种，你需要找到分割出的所有正方形边长之和最小的那一种分割方法。

即：将边长为正整数 $A,B$ 的长方形划分成若干边长均为正整数，且每个正方形的边均平行于长方形的相应边，试求这些正方形边之和的最小值 $\min$。

如果这个长方形可以分成 $N$ 个正方形，其中每个边长为 $C_i$，那么 $\min=C_1+C_2+\dots+C_N$。注意，数组 $C$ 中的元素可能相等。

## 说明/提示

对于 $30\%$ 的数据，$A_i,B_i$ 为 `int` 范围内的正整数；

对于 $100\%$ 的数据，$A_i,B_i$ 为 `long long` 范围内的正整数。

## 样例 #1

### 输入

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1```

### 输出

```
1
2
3
4
5
6
7
8
9
10```

# 题解

## 作者：_Pioneer_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4269)

~~原题解被 Hack 了，为发泄重新再写了一篇。~~

好了不多说，再来解答一下题目。

这是一道带有贪心思想的题。题意很清晰，总结下来就是：**对于每个长方形，我们尽可能地少划分出正方形**。

那么如何划分就是本题的关键。为了划分更少的正方形，我们应该使划分出的正方形的边长越大。所以划分出的正方形边长就为 $\min(A,B)$。

再进一步分析，不妨算出当前有多少个这样边长为 $\min(A,B)$ 的正方形。（假设个数为 $k$，则 $k= \max(A,B) / \min(A,B)$）所以 $sum \gets \min(A,B) \times k + sum$。之后就让较长的边减去所截取的所有正方形的长度，即 $\max(A,B) \gets \max(A,B) - \min(A,B) \times k$。

最后进行特判一下，当 $A \le 0$ 或者 $B \le 0$ 时，输出 `sum`，结束程序。

**提醒：** 一定要开 `unsigned long long`，否则会导致数据溢出而只能得 30 分。

### AC code

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
inline void work(){
	int a,b,sum=0;scanf("%llu%llu",&a,&b);
	while(true){
		if(a<=0||b<=0){printf("%llu\n",sum);return;}
		int maxn=max(a,b),minn=min(a,b);
		int k=maxn/minn;sum+=k*minn;
		if(a==maxn)a-=k*minn;
		else b-=k*minn;
	}
}
signed main(){int t=10;while(t--)work();return 0;} 
```

尾记：[Hack 后的代码](https://www.luogu.com.cn/record/210268881)。

---

## 作者：no_response (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4269)
## 题目大意
对于一个长和宽分别为 $A$ 和 $B$ 的长方形，要求每个长方形分割出的正方形边长之和的最小值。
## 解题思路
输入完 $A$ 和 $B$ 后，显然分割后长或宽不可能为非正数。

所以需要循环 $A$ 为正数且 $B$ 为正数时进行判断。
判断如下：
- 如果长大于等于宽，认为分割长更优，答案与长进行修改。
- 反之，认为分割宽更优，答案与长进行修改。
```cpp
if (a > b) {
  ans += a / b * b, a %= b;
} else {
  ans += b / a * a, b %= a;
}
```
## 注意
题目中明确要求了数据范围，所以定义 $A$ 和 $B$ 的语句应写成：`long long a, b;`。

**特别注意一下：**  
答案变量需要将答案变量的定义写成：`unsigned long long ans = 0;`。

不然就只能得三十分。
## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	for (int i = 1; i <= 10; i++) {
		unsigned long long ans = 0; //答案可能连long long都装不下，所以需要开unsigned（无符号）
		long long a, b; //题意要开 long long
		cin >> a >> b;
		while (a > 0 && b > 0) { //判断分割的长和宽是否大于0
			if (a > b) { //长更优
				ans += a / b * b, a %= b; //修改
			} else { //宽更优
				ans += b / a * a, b %= a; //修改
			}
		}
		cout << ans << endl; //答案输出
	}
	return 0;
}
```

---

## 作者：zzq3 (赞：1)

# 思路
一看完题，我心里就萌生出了两个字——递归！ 直接写函数  $f(a,b)$ 代表长为  $a$ ，宽为 $b$ 的长方形能分割出的正方形边长之和最小值。于是我写出了以下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = unsigned long long;//不用这个只能得30分
ll f(ll a, ll b) {
    if (a == b) {
        return a;//是正方形直接返回
    }
    if (a < b) {
        swap(a,b);// a 长边 b 短边
    }
  // 切出一个边长为 B 的正方形，递归处理剩余部分
    return b + f(a - b, b);
}
int main() {
    for (int i = 1; i <= 10;i++) {
        ll a, b;
        cin >> a >> b;
        cout << f(a, b) << endl;
    }
    return 0;
}    
```
完事！提交！AC !  
# [完不了一点](https://www.luogu.com.cn/record/211087686)
如你所见我喜提一个 TLE ……
# 优化
不难发现，如果数据是  $a=1,b=n$ 那么递归将会运行 $n$ 次。题目中还说了 $a,b$ 的范围到 long long ，明显大于时间范围。  
所以我们可以做如下优化：取 $a/b=sum$ ,每次递归直接取走 $sum$ 个边长为 $b$ 的正方形，这样就可以大大减少递归的次数。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = unsigned long long;
ll f(ll a, ll b) {
	if(a==0||b==0) return 0;//边界条件
    if (a < b) swap(a,b);
    ll sum = a/b;//取sum个边长为b的正方形
    ll yu = a%b;//a线剩余的长度
    return b*sum + f(yu, b);//继续递归
}
int main() {
    for (int i = 1; i <= 10;i++) {
        ll a, b;
        cin >> a >> b;
        cout << f(a, b) << endl;
    }
    return 0;//华丽结尾
}    
```
制作不易，给个赞吧（）

---

## 作者：guoshengyu1231 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4269)
## 初步思考
既然题目让我们求最值，那应该是贪心没错了，于是考虑贪心。那既然是贪心，那我们应该用什么来做贪心的依据呢？换句话说，那就是以什么标准来贪心。通过读题我们可以知道，这题是要我们用若干个正方形来填充一个矩形，要使所有正方形的边长之和最小。而这题的贪心依据其实就是我们小学三年级在学长方形与正方形时学到的一个定理。那就是一个正方形边长扩大 $x$ 倍，面积就扩大 $x^2$ 倍。换句话说，一个边长为 $2$ 的正方形面积相当于四个边长为 $1$ 的正方形。那肯定是优先填较大的正方形。
## 具体步骤
每次输入 $a$ 和 $b$ 时调用函数求解，函数具体流程如下：

-  $ans\gets ans+\min(a,b)$
-  如果 $a=b$，函数调用结束。
-  如果 $a<b$，则 $b\gets b-a$，否则 $a\gets a-b$。然后继续递归调用函数求解。
最后输出 $ans$ 即可。
## 代码
开 `long long` 是不够的，应为题目只说明 $a$ 和 $b$ 都是 `long long` 范围内的正整数，说不定加起来就超过 `long long` 级别了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll n,m,ans;
void solve(ll n,ll m)
{
	ll c=min(n,m);
	ans+=c;
	if(n==m) return;
	if(c==n) solve(n,m-c);
		else solve(n-c,m);
}
int main()
{
	int tot=10;
	while(tot--)
	 {
		ans=0;
		cin>>n>>m;
		solve(n,m);	
		cout<<ans<<"\n";
     } 
	return 0;
}
```
## 优化
以上代码虽然也能通过所有的数据，但是它的时间复杂度是不对的。在极端情况下，此代码的时间复杂度为 $O(n)$，所以还需要优化。观察求解的函数，发现每次减都是一次一次地减。所以我们只需要再优化这一点就行了。 $\\$ 
如何优化这一点？试想一下，如果一开始是 $a$ 较大，在执行减法操作后，还是 $a$ 较大。那我们就没必要去一次一次减了，我们直接减至 $a<b$ 即可。也就是用两数相除，算出一共可以减多少次，一次性减掉就行了。 $\\$ 
代码就不放了，和上面的差不多。

---

## 作者：darklf (赞：1)

# 题解：B4269 [朝阳区小学组 2019] square
### [题目传送门](https://www.luogu.com.cn/problem/B4269)
## 思路
根据题意可知，要是分成正方形的边长和最小，就需要让分出的正方形尽可能地大，而能在目前状态分出的最大正方形的边长是就是长方形的宽。由于~~作者没有脑子~~没用除法被审核驳回了，于是~~优化了一下~~改出现在的代码。
## 附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long x,y,ans;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	for(int i=1;i<=10;i++){
		ans=0;
		cin>>x>>y;
		while(true){
			if(x==0||y==0)break;
			if(x==y){ans+=x;break;}
			if(x<y)swap(x,y);
			ans+=(unsigned long long)(x/y)*y;
			x%=y;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```
完结撒花。

---

## 作者：Priestess_SLG (赞：1)

目前这题 C++ 题解全都可以被下面数据 hack：

```
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
1 100000000000000000
```

所以这里提供一份可以通过数据和 hack 的 C++ 题解。

考虑贪心。很显然把一个边长为 $a$ 的正方形劈开一定不会更好，因此考虑贪心的在长方形中选取最大的正方形。发现这就是辗转相除法，因此直接按辗转相除法模拟即可。时间复杂度为 $O(T\log n)$ 其中 $T=10$ 为数据组数。

给个图方便理解：

[![pEDUHFx.png](https://s21.ax1x.com/2025/03/26/pEDUHFx.png)](https://imgse.com/i/pEDUHFx)

笑点解析：不开 unsigned long long 拿 $30$，时间复杂度错了拿 $100$。

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define int long long
using namespace std;
const int N=4010;
signed main(){
    // freopen("1.out","w",stdout);
    cin.tie(0)->sync_with_stdio(false);
    for(int tc=0;tc<10;++tc){
        int a,b;cin>>a>>b;
        unsigned int sum=0;
        while(a&&b){
            if(a>b)swap(a,b);
            sum+=1ull*(b/a)*a;b%=a;
        }
        cout<<sum<<'\n';
    }
}
```

---

## 作者：2789617221guo (赞：0)

## 做法
- 数学和贪心。
## 思路
这题中让我们**最小化**所有正方形的边长和，那么我们应该使每个分割的正方形边长**最大化**。不懂的可以看下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tyw7fkeh.png)

不难发现，这 $2$ 种方法都计算了待分割的矩形的周长，但是第 $2$ 种方法（最小化边长）还多计算了 $4$ 条边，而第 $1$ 种（最大化边长）没有，所以，我们应该每次都选择最大的边长。这就是我们本题的贪心策略。

随后每次循环时分割正方形，最后当 $2$ 边的长度 $a$ 和 $b$ 都等于 $0$ 时就退出分割，然后输出答案。

记得使用 `unsigned long long` 类型存储长度和答案，否则有可能溢出。
## 代码
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long

using namespace std;

int main(){
	for(int i=1;i<=10;i++){
		ull a,b,ans=0;
		cin>>a>>b;
		while(1){
			if(a==0||b==0){ //分割不了了 
				break;
			}
			if(a==b){//现在就是一个正方形 
				ans+=a;
				break;
			}
			if(a>b) swap(a,b); //时刻保证a比b小 
			ans+=b/a*a; //ull是为了防止溢出 
			b%=a; //计算出分割完毕后还剩下多长 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
## AC 记录
[点这里！](https://www.luogu.com.cn/record/211022462)

---

## 作者：longyitongxue (赞：0)

# 正文前提示
![](https://cdn.luogu.com.cn/upload/image_hosting/93vimc4p.png)
**由于输入范围在 $-\textbf{2}^{\textbf{63}}\sim\textbf{2}^{\textbf{63}}-\textbf1$，所以一定要开开 `unsigned long long`！不然会 $\textbf{30}$ 分！！！**
- - -
[题目传送门](https://www.luogu.com.cn/problem/B4269)
# 主要思路
这是一道带有贪心思想的题。分析后，我们发现目标是让我们尽可能少地划分出正方形。也就是说，划分出的正方形的边长要尽可能的大。那么划分出的正方形的边长就为 $\min\left(a,b\right)$。

那么一个长方形内有多少边长为 $\min\left(a,b\right)$ 的正方形呢？我们可以把长方形分割成 $k$ 个边长为 $\min\left(a,b\right)$ 的正方形，把这 $k$ 个正方形边长累加到答案里去，然后让长方形的长（也就是 $\max\left(a,b\right)$）减去 $k\times\min\left(a,b\right)$，直到长方形的任意一边被减到 $0$，输出答案即可。

那么这个 $k$ 怎么求呢？其实很简单，根据下面这幅图，就可以推断出是 $\left\lfloor\dfrac{\max\left(a,b\right)}{\min\left(a,b\right)}\right\rfloor$。  
![](https://cdn.luogu.com.cn/upload/image_hosting/vg15r59u.png)
- - -
接下来就是代码实现了。
# [AC](https://www.luogu.com.cn/record/210857697) code

```cpp
#include<iostream>
#define ull unsigned long long
using namespace std;
int main(){
    for(int i=1;i<=10;i++){
        ull a,b,ans=0;
        cin>>a>>b;
        while(a!=0&&b!=0){//两条边没有到 0 的时候不要停。
            ull k=max(a,b)/min(a,b);//依思路
            ans+=(k*min(a,b));
            if(a==max(a,b))a-=(k*min(a,b));
            else b-=(k*min(a,b));
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：2b2b2bbb (赞：0)

# 题意
将一个方形拆分成若干个正方形，要求最小的正方形之和是多少。
# 思路
要求最小的正方形之和，我们如果把一个原本可以更大的正方形变成多个小的正方形的话，边长就会增加。那么我们每次就拆成当前的最大正方形。

然后我们就会发现，我们写出来的代码中先减去两个边长中的最小的一个，那么不就可以用辗转相除法写吗？
## code

```cpp
	#include<bits/stdc++.h>
	#define int unsigned long long
	using namespace std;
	
	signed main(){
		ios::sync_with_stdio(0);
		cin.tie(0),cout.tie(0);
		for(int i = 1 ; i <= 10 ; i ++){
			int x,y;
			cin >> x >> y;
			int ans = 0;
			while(x && y){
				if(x > y)swap(x , y);
				ans += (y / x) * x;
				y %= x;
			}
			cout << ans << '\n';
		}
		return 0;
	}
```

---

## 作者：Yi_chen123 (赞：0)

## 题外话

弄完后发现竟然有 hack，但是我为什么无视，直接一遍过？

## 思路

边长之和必须最小，那么分出来的单个正方形边长必须要保证尽量地大，不难想到贪心求解。\
如果当前的长方形长、宽分别是 $a,b$，那么可以分出的最大正方形边长一定为 $\max(a,b)$，并可以分出来 $\lfloor \dfrac{\max(a,b)}{\min(a,b)} \rfloor$ 个一样大小的正方形。正方形的边长和为 $\min(a, b)\times\lfloor \dfrac{\max(a,b)}{\min(a,b)} \rfloor$ 此时进行一个简单分讨：

- 如果 $a \ge b$，$a \gets a \bmod b$。
- 否则，$b \gets b \bmod a$。

重复以上过程，直到 $a \le 0$ 或 $b \le 0$，即整个长方形都被裁剪干净。\
最后，将所有正方形的边长相加，即为最终的答案。

## 写代码前必看

题目中会涉及若干个 `long long` 大小的整数相加，因此可能会导致最终答案的溢出，因此需要用 `unsigned long long` 代替。

## 代码

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;

signed main(){
    for(int i = 0; i < 10; ++i){
    	int a, b;
    	cin >> a >> b;
        int ans = 0;
        while(true){
        	if(a <= 0 || b <= 0) break; //循环终止条件
        	int x = max(a, b), y = min(a, b);
        	ans += y * (x / y); //记录本次裁剪下来的正方形边长之和
        	if(a >= b) a %= b;
        	else b %= a;
		}
		cout << ans << endl;
	}
    return 0;
}
```

---

## 作者：LINYUHENG2 (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/B4269)
## 思路
要想使边长之和最小，那就要使每个填充的正方形都尽可能的大，使用贪心思想。

那如何贪心呢？对于一个长为 $A$，宽为 $B$ 的长方形，设 $x=\min(A,B)$，即 $x$ 为长方形所能包含的最大的正方形边长。被减去最大正方形的长方形长为 $A-x$，宽为 $B-x$。随之不断贪心，直到长方形被填充完毕。
## 注意事项
本题 $A$ 和 $B$ 的数据范围为 `long long`，在累加时可能会爆 `long long`，所以，要将变量类型设置为 `unsigned long long`。
## 代码

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
ull a,b,ans;

int main(){
    int t=10;
    while(t--){
        ans=0;
        scanf("%llu%llu",&a,&b);
        while(a>0&&b>0){
            if(a>=b){
                ans+=a/b*b;
                a%=b;
            }else{
                ans+=b/a*a;
                b%=a;
            }
        }
        printf("%llu\n",ans);
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/210536084)

---

## 作者：stardusts (赞：0)

原题解被 hack 掉了，重新写一下。

# 总结题意

对于一个长和宽分别为 $A$ 和 $B$ 的长方形，求若干个能将其填满的正方形的边长之和的最小值。

# 分析题目

要想使边长之和最小，那很显然要使每个填充的正方形都尽可能的大，很容易就可以想到贪心思想。

思考怎么贪心，对于一个长和宽分别为 $A$ 和 $B$ 的长方形，设 $x=\min(A,B)$。长方形所能包含的最大的正方形边长为 $x$，被减去最大正方形后的长方形长和宽分别为 $A-x$ 和 $B-x$。随后不断进行贪心，直到整个长方形被填充完毕。

在填充过程中，对答案 $ans$ 进行累加当前最大正方形的边长。填充结束后输出 $ans$ 即为答案。

接下来思考如何减小时间复杂度，很容易想到辗转相除法，即使用乘除而非加减以提高代码效率。

# 注意事项

本题 $A$ 和 $B$ 在 long long 范围内，考虑到 $ans$ 在累加时可能会超 long long，故需要将变量类型调整为 unsigned long long。

# 代码

以下为可通过hack的代码
（个人觉得码风清晰易读）

```cpp
# include <bits/stdc++.h>
# define ull unsigned long long
using namespace std;
ull a,b,ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	for (int u=1;u<=10;u++)
	{
		ans=0;
		cin>>a>>b;
		while (a>0&&b>0)
			if (a>=b)
				ans+=a/b*b,a%=b;
			else
				ans+=b/a*a,b%=a;
		cout<<ans<<'\n';
	}
	return 0;
}
```

[原题解](https://www.luogu.com.cn/article/x2l57481)

---

## 作者：yyycj (赞：0)

~~之前被 Hack 了，再写一遍。~~

## 题目简述
给定一个长方形的长和宽，求这个长方形分割成若干个小正方形后正方形的**边长**之和的最小值。注意：正方形大小可不一致。

## 主要思路
为了使边长和最小，肯定要将每次分割出的正方形最大，否则内部的正方形边长也会计算。在一个长方形中分割出最大的正方形，正方形的边长即为 $\min(A,B)$。很容易就能想到不断使 $A$ 或 $B$ 不断减 $B$ 或 $A$ 直到为 $0$ 的方法，但如果 $|A-B|$ 很大，就会导致 `TLE`（#10）。

假设 $A>B$，那么 $A-B$ 可能会很大，$A$ 就可能是 $B$ 的很多倍，让 $A$ 不断减 $B$ 就会导致减了很多次 $\min(A,B)$ 却还是 $B$，所以可以直接让答案增加 $\lfloor\frac{A}{B}\rfloor \cdot B$，表示长为 $A$ 宽为 $B$ 的长方形中最大可以分割出边长为 $B$ 的正方形且能分出 $\lfloor\frac{A}{B}\rfloor$ 个，并使 $A \gets A \bmod B$，一步保证下一次计算时 $A<B$；反之答案增加 $\lfloor\frac{B}{A}\rfloor \cdot A$，并使 $B \gets B \bmod A$。这个过程直到 $A=0$ 或 $B=0$ 时停止。

## 注意事项
题目中只保证了数据在 `long long` 范围内，但如果输入是两个 `long long` 极限，那么一加就会炸，所以要开 `unsigned long long`。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long double db;
typedef unsigned long long ll;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
// ----------------------------

// ----------------------------

// ----------------------------


int main() {
	ll a, b, ans;
	for (int i = 1; i <= 10; i++) {
		cin >> a >> b;
		ans = 0;
		while (a > 0 && b > 0) {
			if (a > b) {
				ans += a / b * b;
				a %= b;
			}
			else {
				ans += b / a * a;
				b %= a;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

显然，短边的每一个坐标都有一条平行的分割线（往外是长边的剩余部分），所以答案至少要消除最大边长的方块（一定是最大的，内部不要分割，显然同一组面积直接消是最简洁的）累加短边直至长边变成短边，以此类推，直到长短边相等可以一气呵成消除。直接想到辗转相除法，得出结论 $A+B-\text{gcd}(A,B)$。
```python
import math
try:
    while 1:a,b=map(int,input().split());print(a+b-math.gcd(a,b))
except:0
```

---


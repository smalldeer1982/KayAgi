# [ROIR 2023] 矩形分割 (Day 1)

## 题目背景

翻译自 [ROIR 2023 D1T1](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day1.pdf)。

## 题目描述

有一个大小为 $a\times b$ 的由单位方格组成的矩形，你需要通过 $k$ 次垂直或水平的切割将其分成 $m$ 个小矩形。小矩形大小不一定要相等。

每次切割不允许切割一半，必须从一边切到另外一边。只允许在网格线上进行切割。

## 说明/提示

本题使用捆绑测试。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $18$ | $a=1$ |
| $2$ | $19$ | $m\le10^5$ |
| $3$ | $20$ | $1\le k\le10^5$ |
| $4$ | $21$ | $m\le10^9$ |
| $5$ | $22$ | 无 |

所有数据均满足 $1 \le t \le 100$，$1 \le a, b \le 10^9$，$0 \le k \le 2 \times 10^9$，$1 \le m \le 10^{18}$，且 $k < m$。

## 样例 #1

### 输入

```
3
2 2 1 2
1 2 2 3
3 5 5 12```

### 输出

```
0 1
-1
2 3```

# 题解

## 作者：harmis_yz (赞：3)

## 分析

解方程。

设我们横着切了 $x$ 刀，竖着切了 $y$ 刀。则有最终矩形数量 $c=(x+1)\times(y+1)$。所以题目就是让我们求：$\left\{ 
    \begin{aligned}
    &(x+1)\times (y+1)=m& \cr 
    &x+y=k&\cr
    &x < a \cr
    & y < b
    \end{aligned}
\right.$ 的 $x$ 最小 $y$ 最大整数解。

令 $m'=m-k-1$。把前面两个方程消元一下就变成了：$y \times k - y^2-m'=0$。这是一个一元二次方程，它的解为：$y=\frac{k\pm\sqrt{k^2-4 \times m'}}{2}$。然后取两组 $x,y$ 中满足限制且 $x$ 最小的一组即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline

il int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}

int a,b,k,m;

il void solve(){
	a=read(),b=read(),k=read(),m=read();
	m=m-k-1;
	if(m<0) return printf("-1\n"),void(0);
	if(m==0){
		if(k<b) return printf("%lld %lld\n",0,k),void(0);
		if(k<a) return printf("%lld %lld\n",k,0),void(0);
		return printf("-1\n"),void(0);
	}
	if(k*k-4*m<0) return printf("-1\n"),void(0);
	if((int)sqrt(k*k-4*m)*(int)sqrt(k*k-4*m)!=k*k-4*m) return printf("-1\n"),void(0);
	int x=sqrt(k*k-4*m);
	if((k+x)&1) return printf("-1\n"),void(0);
	int ans1=(k+x)/2,ans2=(k-x)/2;
	int Min=1e18;
	if(k-ans1<a&&ans1<b) Min=min(Min,k-ans1);
	if(k-ans2<a&&ans2<b) Min=min(Min,k-ans2);
	if(Min>=1e18) return printf("-1\n"),void(0);
	printf("%lld %lld\n",Min,k-Min);
	return ;
}

signed main(){
	int t=read();while(t--)
	solve();
	return 0;
}
```


---

## 作者：2022linzhiyi (赞：2)

# 解法
根据题目列出方程 $(x+1)(k-x+1)-m=0$，化简可得 $x^2-kx+m-k-1=0$，得出：
$$x_{1,2}=\frac{k\pm\sqrt{k^2-4(m-k-1)}}{2}$$
此时，若根号下的值小于零或者两根不为整数就都为无解。

否则就令
$$x_1=\frac{k-\sqrt{k^2-4(m-k-1)}}{2}$$
$$x_2=\frac{k+\sqrt{k^2-4(m-k-1)}}{2}$$
其中 $x_1$ 表示水平切割的次数，$x_2$ 表示垂直切割次数，判断两个值是否合法，合法就输出，不合法就先交换再判断。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin >> t;
	while (t --) {
		unsigned long long a,b,k,m,d,x1,x2;
		cin >> a >> b >> k >> m;
		d=k*k-4*(m-k-1);
		if (d < 0 || sqrt(d) != (int)sqrt(d)) {
			cout << "-1\n";
			continue;
		}
		if ((k-(unsigned long long)sqrt(d))%2 != 0) {
			cout << "-1\n";
			continue;
		} 
		x1=(k-sqrt(d))/2; x2=(k+sqrt(d))/2;
		if (x1 < a && x2 < b) cout << x1 << " " << x2 << '\n';
		else {
			swap(x1,x2);
			if (x1 < a && x2 < b) cout << x1 << " " << x2 << '\n';
			else cout << "-1\n";
		}
	}
	return 0;
}
```

---

## 作者：cff_0102 (赞：2)

根据题意，不难列出：

$$\left\{\begin{aligned}&x+y=k \\&(x+1)(y+1)=m \\&0\le x<a \\&0\le y<b\end{aligned}\right.$$

将 $y=k-x$ 代入第二个式子：

$$(x+1)(k-x+1)=m$$
$$kx-x^2+x+k-x+1-m=0$$
$$-x^2+kx+(k-m+1)=0$$
$$x_1=\dfrac{k-\sqrt{k^2+4k-4m+4}}{2},x_2=\dfrac{k+\sqrt{k^2+4k-4m+4}}{2}$$
$$y_1=\dfrac{-k+\sqrt{k^2+4k-4m+4}}{2},y_2=\dfrac{-k-\sqrt{k^2+4k-4m+4}}{2}$$

如果这个方程无实数根（$k^2+4k-4m+4<0$），或者这两个解都不在 $a,b$ 范围内，就输出 `-1`。如果恰好有一个在范围中的解，就将其输出。如果这个方程的两个解都在规定范围中，输出 $x_1$ 和 $y_1$，也就是答案更小的那个。

来放个官方这道题的 std：

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;
typedef long long int ll;
bool check(ll a, ll b, ll k, ll m, set<pair<ll, ll>> &ans) {
    ll D = k * k + 4LL * (k - m + 1LL);
    if (D < 0LL) {
        return false;
    }
    ll sqrtD = (ll) sqrt(D);
    if (sqrtD * sqrtD != D) {
        return false;
    }
    if ((k - sqrtD) >= 0LL && (k - sqrtD) % 2LL == 0LL) {
        ll x_1 = (k - sqrtD) / 2LL;
        ll y_1 = k - x_1;
        if (0LL <= x_1 && x_1 < a && 0LL <= y_1 && y_1 < b) {
            ans.insert({x_1, y_1});
        }
    }
    if ((k + sqrtD) >= 0LL && (k + sqrtD) % 2LL == 0LL) {
        ll x_2 = (k + sqrtD) / 2LL;
        ll y_2 = k - x_2;
        if (0LL <= x_2 && x_2 < a && 0LL <= y_2 && y_2 < b) {
            ans.insert({x_2, y_2});
        }
    }
    return (!ans.empty());
}
int main() {
    ll t;
    cin >> t;
    for (ll i = 0LL; i < t; i++) {
        ll a, b, k, m;
        set<pair<ll, ll>> ans;
        cin >> a >> b >> k >> m;
        if (check(a, b, k, m, ans)) {
            pair<ll, ll> p = *ans.begin();
            cout << p.first << " " << p.second << "\n";
        } else {
            cout << -1 << "\n";
        }
    }
    return 0;
}
```

---

## 作者：无名之雾 (赞：0)

# [ROIR 2023 Day 1] 矩形分割 题解

~~又来水题解了，没想到抢了个最优解！~~

## 思路

这题，一眼看完给人的感觉就是解方程。我们设水平切割次数为 $h$，垂直切割次数为 $v$。


### 列方程：

有方程组：$= \begin{cases} h+v=k \\(v+1) \times (h+1)=m
\end{cases}$

注意限定 $h$ 和 $v$ 的取值范围：$= \begin{cases} 0 \le h < a \\ 0 \le v < b
\end{cases}$

求出 $h$ 的最小值及同时 $v$ 的最大值。

### 解方程：

 $$(v+1)\times (h+1)=vh+v+h+1=m=vh+k+1$$
 
 
 $$vh=m-k-1=v \times (k-v)=vk-v^2 $$
 
 $$vk-v^2-m+k+1=0$$

解得：$= \begin{cases} v=\frac{k\pm\sqrt{k^2-4m+4k+4}}{2} \\
					h=\frac{-k\pm\sqrt{k^2-4m+4k+4}}{2}
\end{cases}$

## 实现

若该方程无解，则输出 $-1$。其余正常模拟。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int a,b,k,m;
        cin>>a>>b>>k>>m;
        m=m-k-1;
        if(m<0){
            cout<<-1<<"\n";
            continue;
        }
        if(m==0){
            if(k<b)cout<<0<<" "<<k<<"\n";
            else if(k<a)cout<<k<<" "<<0<<"\n";
            else cout<<-1<<"\n";
            continue;
        }
        if(k*k-4*m<0){
            cout<<-1<<"\n";
            continue;
        }
	    if((int)sqrt(k*k-4*m)*sqrt(k*k-4*m)!=k*k-4*m){
            cout<<-1<<"\n";
            continue;
        }
	    int v=sqrt(k*k-4*m);
	    if((k+v)&1){
            cout<<-1<<"\n";
            continue;
        }
	    int ans1=(k+v)/2,ans2=(k-v)/2;
	    int minn=1e18;
	    if(k-ans1<a&&ans1<b) minn=min(minn,k-ans1);
    	if(k-ans2<a&&ans2<b) minn=min(minn,k-ans2);
	    if(minn>=1e18){
            cout<<-1<<"\n";
            continue;
        }
        cout<<minn<<" "<<k-minn<<"\n";
    }
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P10094题目](https://www.luogu.com.cn/problem/P10094)

### 解题思路
设 $x$ 为水平切割次数，则垂直切割次数为 $(k-x)$ 次，可列出方程：
$$(k-x+1)\times(x+1)=m$$
化简此方程得：
$$kx-x^2=m-k-1$$
解得：
$$x=\frac{k±\sqrt{k^2+4k+4-4m}}{2}$$
计算出水平切割次数和垂直切割次数后，判断是否满足这 $4$ 个条件：
- $0\le x<a$
- $0\le k-x<b$
- $k^2+4k+4-4m\ge0$
- $x$ 为非负整数

若这 $4$ 个条件均满足则输出水平和垂直切割次数，否则输出 `-1`。

### Code
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
#define int long long
bool pd(int k,int d)//判断是否合法
{
	if(d<0||(int)sqrt(d)*(int)sqrt(d)!=d)
		return false;
	if((k-(long long)sqrt(d))%2==1)
		return false;
	return true;	
}
signed main()
{
	int t;
	scanf("%lld",&t);
	for(int i=1;i<=t;i++)
	{
		int a,b,k,m;
		scanf("%lld%lld%lld%lld",&a,&b,&k,&m);
		int d=k*k+4*k+4-4*m;
		if(pd(k,d)==false)
		{
			puts("-1");
			continue;//不要忘了结束此轮循环
		}
		int x,xx;
		x=(k-sqrt(d))/2,xx=(k+sqrt(d))/2;
		if(x>=a||xx>=b)
		{
			swap(x,xx);//交换x和xx
			if(x>=a||xx>=b)
			{
				puts("-1");
				continue;
			}
		}
		printf("%lld %lld\n",x,xx);
	}
	return 0;
}
```

---

## 作者：Jorisy (赞：0)

首先按题意列出方程 $(x+1)(k-x+1)=m$，然后化简得到 $x^2-kx+m-k-1=0$。

于是我们先判 $\Delta\ge0$，然后就可以大力开根，看解得的 $x=\dfrac{k\pm\sqrt\Delta}2$ 是否符合题意即可。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

void sol()
{
	int a,b,k,m;
	cin>>a>>b>>k>>m;
	int d=k*k-4*(m-k-1);
	if(d<0||(int)sqrt(d)*(int)sqrt(d)!=d)//delta<0 或者 delta 不是完全平方数
	{
		puts("-1");
		return;
	}
	int p=sqrt(d);
	if(k+p&1)//x 不是整数
	{
		puts("-1");
		return;
	}
	int x1=(k-p)/2,x2=(k+p)/2;
	if(x1<a&&k-x1<b) cout<<x1<<' '<<k-x1<<endl;
	else if(x2<a&&k-x2<b) cout<<x2<<' '<<k-x2<<endl;//优先看水平切割次数较少的方式是否符合条件
	else puts("-1");
}

signed main()
{
	int t;
	cin>>t;
	while(t--) sol(); 
 	return 0;
}
/*
(x+1)(k-x+1)=m
kx-x^2+x+k-x+1=m
-x^2+kx+1+k-m=0
x^2-kx+m-k-1=0
0<=x<a 0<=k-x<b
*/
```

---

## 作者：Aveiro7 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10094)

### 题目大意

有一个大小为 $a\times b$ 的由单位方格组成的矩形，你需要通过 $k$ 次垂直或水平的切割将其分成 $m$ 个小矩形。小矩形大小不一定要相等。

每次切割不允许切割一半，必须从一边切到另外一边。只允许在网格线上进行切割。

### 思路：

设进行了 $v$ 次垂直切割，则进行了 $(k-v)$ 次水平切割。

因为最终分割出的矩形数等于垂**直切割次数加一与水平切割次数加一的积**，所以可列出方程：

$$(v+1)\times(k-v+1)=m$$

解得 

$$v=\frac{k\pm \sqrt{k^2-4m+4k+4}}{2}$$

我们所需要做的就是把 $k$ 和 $m$ 读入后去解方程，如果方程无解则输出 ``-1``，反之则解方程后输出 $(k-v)$ 和 $v$ 即可。

### Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,k,m,T,v,ans;
int main()
{
	cin>>T;
	while(T--){
		cin>>a>>b>>k>>m;
		ans=k*k-4*m+4*k+4;
		if(ans<0)
		{
			cout<<-1<<endl;
		}
		else 
		if(ans==0)
		{
			if(k%2!=0)
			{
				cout<<-1<<endl;
			}
			else
			{
				v=k/2;
				if(v<b&&k-v<a)
					cout<<k-v<<" "<<v<<endl; 
				else 
					cout<<-1<<endl;
			}
		}
		else
		{
			ll x=sqrt(ans*1.0);
			if(pow(x,2)!=ans)
			{
				cout<<-1<<endl;
				continue;
			}
			else
			{
				if((k+x)%2!=0)
				{
					cout<<-1<<endl;
					continue;
				}else
				{
					int a1=(k+x)/2,a2=(k-x)/2;
					if(a1<b&&k-a1<a)
						cout<<k-a1<<" "<<a1<<endl; 
					else 
					if(a2<b&&k-a2<a)
						cout<<k-a2<<" "<<a2<<endl;
					else 
						cout<<-1<<endl;
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：jbjbjbjb (赞：0)

设需要 $x$ 次垂直的切割，因为需要通过 $k$ 次垂直或水平的切割，所以需要 $(k-x)$ 次水平的切割。所以可以列出方程：
$$(x+1)(k-x+1)=m$$
化简得：
$$x^2-xk+(m-k-1)=0$$
所以，
$$x= \frac{k \pm \sqrt{k^2-4(m-k-1)}}{2}$$
只需要判断 $x$ 的取值是否成立就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t,a,b;
	long long k,m;
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%lld%lld",&a,&b,&k,&m);
		long long g=k*k-4*(m-k-1);
		if(g<0){
			printf("-1\n");//方程无解
		}else if(g==0){
			if(k%2!=0){
				printf("-1\n");//x不是整数
			}else{
				long long x=k/2;
				if(x<b&&k-x<a)printf("%d %d\n",k-x,x);//判断x取值是否成立 
				else printf("-1\n");
			}
		}else{
			if(pow(int(sqrt(g*1.0)),2)!=g){//看x是否可能是整数 
				printf("-1\n");
				continue;
			}else{
				int u=sqrt(g*1.0);
				if((k+u)%2!=0){//x不是整数 
					printf("-1\n");
					continue;
				}else{
					int x1=(k+u)/2,x2=(k-u)/2;
					if(x1<b&&k-x1<a)printf("%d %d\n",k-x1,x1);//先找水平的切割少的 
					else if(x2<b&&k-x2<a)printf("%d %d\n",k-x2,x2);
					else printf("-1\n");
				}
			}
		}
	}
	return 0;
}

```


---

## 作者：tder (赞：0)

如果只横着切 $h$ 刀，则显然可以分为 $h+1$ 块。同理，如果只竖着切 $v$ 刀，则可以分为 $v+1$ 块。综上，共可以分为 $(h+1)(v+1)$ 块，且有 $h+v=k$。

那么，有方程组：

$$
\begin{cases}
(h+1)(v+1)=m\\
h+v=k
\end{cases}
$$

将下面的代入上面的，得：

$$
\begin{aligned}
(h+1)(k-h+1)&=-h^2+kh+(k+1) \\
&=m
\end{aligned}
$$

移项，有：

$$
\begin{aligned}
-h^2+kh+(k-m+1)&=h^2-kh-(k-m+1) \\
&=0
\end{aligned}
$$

由[一元二次方程](/problem/P9750)，可得：

$$
h=\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}=\dfrac{k\pm\sqrt{k^2+4k-4m+4}}{2}
$$

那么，代入原式，有：

$$
v=\dfrac{-k\pm\sqrt{k^2+4k-4m+4}}{2}
$$

题意即求 $h$ 的较小整数解。无解情况同理易得，当且仅当满足以下条件任意一条时：

- $\Delta=k^2+4k-4m+4<0$
- $h\notin[0,~a]$
- $v\notin[0,~b]$

---


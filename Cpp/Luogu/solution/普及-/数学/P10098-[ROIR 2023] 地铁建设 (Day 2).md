# [ROIR 2023] 地铁建设 (Day 2)

## 题目背景

翻译自 [ROIR 2023 D2T1](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day2.pdf)。

用于铺设地铁隧道的盾构机有 $n$ 个发动机。所有发动机是并联的，所以所有发动机两端的电压都相同。

每个发动机有两种模式，假设所有发动机接收到的电压都为 $x$，则当 $x\le z_i$ 时第 $i$ 个发动机在第一模式下工作，否则它在第二模式下工作。

第 $i$ 个发动机在第一模式下的单位电流为 $a_i$，在第二模式下的单位电流为 $b_i$。所以，根据 $P=UI$，当发动机处于第一模式时，每增加 $1$ 单位电压，其功率增加 $a_i$ 单位；当发动机处于第二模式时，每增加 $1$ 单位电压，其功率增加 $b_i$ 单位。换句话说，当电压为 $x$ 单位电压，如果第 $i$ 个发动机处于第一模式下，它以 $a_i\times x$ 的单位功率运行；如果处于第二模式下，它以 $a_i\times z_i + b_i\times(x - z_i)$ 的单位功率运行。

## 题目描述

最少需要提供多大的电压（电压需要是整数），才能使所有发动机的总功率大于或等于 $p$？

## 说明/提示

本题使用捆绑测试。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $n=1$ |
| $2$ | $20$ | $a_i,b_i\le100,p\le10^5$ |
| $3$ | $20$ | 所有 $z_i$ 均相等 |
| $4$ | $20$ | $n\le2$ |
| $5$ | $20$ |  |

对于 $100\%$ 的数据，$1 \le n \le 100,1 \le p \le 10^{12},1 \le z_i \le 10^9,1 \le a_i,b_i \le 10^4$。

## 样例 #1

### 输入

```
1 6
4 1 2```

### 输出

```
5```

## 样例 #2

### 输入

```
3 15
2 3 3
4 2 1
5 2 2```

### 输出

```
3```

# 题解

## 作者：longlinyu7 (赞：11)

# 解决方法
电压越大，所得的总功率也就越大，而电压越小，所得的总功率也就略小，即电压与总功率满足单调性，可以考虑**二分查找**，写一个判断函数即可。
- 当总功率大于等于 $p$ 时，缩小右端点。

- 当总功率小于 $p$ 时，就扩大左端点。

判断函数中，注意对每一个机器的 $z$ 值进行讨论。判断函数时间复杂度为 $O(n)$。

最后，注意 $p$ 的范围，不要开小了。

# 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=105;
struct node{
    long long z,a,b;
}mp[N];
int n;
long long p;
bool judge(long long x){//二分查找
    long long sum=0;
    for(int i=1;i<=n;i++){
        if(x<=mp[i].z){
            sum+=mp[i].a*x;
        }
        else sum+=(mp[i].a*mp[i].z+mp[i].b*(x-mp[i].z));
    }
    return sum>=p;//比较
}
int main(){
    cin>>n>>p;
    for(int i=1;i<=n;i++){
        cin>>mp[i].z>>mp[i].a>>mp[i].b;
    }
    long long l=1,r=p,mid,ans=0; //开 long long
    while(l<=r){
        mid=(l+r)>>1;
        if(judge(mid)){
            r=mid-1;
            ans=mid;
        }
        else {
            l=mid+1;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：DHT666 (赞：5)

## 题意

[传送门](https://www.luogu.com.cn/problem/P10098)

有 $n$ 个发动机，在输入电压小于 $z_i$ 时，它的功率为 $a_i\times x$，当输入电压大于 $z_i$ 时，它的功率为 $a_i \times z_i+b_i\times (x_i-z_i)$，现在想让你求出最小的输入电压，使得所有发动机的输出功率大于等于 $p$。

## 思路
二分查找，因为答案越大，输出功率越大，两者成正比。

于是在答案可能出现的范围内二分查找答案，判断答案是否满足条件。

## 代码
~~~cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 110;

// 此题需要开 long long
ll n,p;
ll a[N],b[N],z[N];

bool check(ll x) {
	ll tot = 0; // 累加输出功率
	for(int i=1;i<=n;i++) {
		if(x > z[i]) tot += a[i] * z[i] + b[i] * (x - z[i]);
		else tot += a[i] * x;
	}
	return tot >= p; // 判断是否满足条件
}

int main() {
	cin>>n>>p;
	
	for(int i=1;i<=n;i++) {
		cin>>z[i]>>a[i]>>b[i];
	}
	
	ll l = 0,r = 1e12; // 范围开大一点
	while(l <= r) { // 二分查找板子
		ll mid = l + r >> 1;
		if(check(mid)) r = mid - 1;
		else l = mid + 1;
	}
	
	cout<<l;
		
	return 0;
}
~~~

---

## 作者：cff_0102 (赞：2)

可以使用二分。

每次二分需要的电压 $U$，然后计算此时的总功率 $P$。如果 $P<p$，那么要找的 $U$ 应该比现在的 $U$ 小，反之亦然。最后就可以 $O(n\log n)$ 找到最终需要的电压，其中二分本体是 $O(\log n)$ 的，二分的 `check` 函数，也就是上面说的计算总功率是 $O(n)$ 的。

非官方代码：

```python
def calculate_total_power(voltage, engines):
    total_power = 0
    for z, a, b in engines:
        if voltage <= z:
            total_power += a * voltage
        else:
            total_power += a * z + b * (voltage - z)
    return total_power

def find_minimum_voltage(n, p, engines):
    left = 1
    right = 10**18

    while left < right:
        mid = (left + right) // 2
        total_power = calculate_total_power(mid, engines)

        if total_power >= p:
            right = mid
        else:
            left = mid + 1

    return left

# Read input
n, p = map(int, input().split())
engines = []
for _ in range(n):
    z, a, b = map(int, input().split())
    engines.append((z, a, b))

# Find minimum voltage
minimum_voltage = find_minimum_voltage(n, p, engines)

# Print the result
print(minimum_voltage)
```

---

## 作者：ZBH_123 (赞：1)

## 题目分析
显然，根据 $P=UI$，当 $U$ 逐渐变大时，$P$ 肯定单调不减。那么，我们可以对 $U$ 进行二分答案。当以 $U$ 为电压时的总电功大于等于 $p$ 时，二分的下限 $l$ 应该向上调整，否则向下调整。

**AC code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;
ll m,a[105],b[105],c[105];
void init(){
	scanf("%d %lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld %lld %lld",&a[i],&b[i],&c[i]);
	}
}
bool check(ll x){
	ll sum=0;
	for(int i=1;i<=n;i++){
		if(x<=a[i]){
			sum+=x*b[i];
		}
		else{
			sum+=a[i]*b[i]+(x-a[i])*c[i];
		}
	}
	return sum>=m;
}
void solve(){
	ll l=0,r=m,ans;
	while(l<=r){
		ll mid=(l+r)/2;
		if(check(mid)){
			ans=mid,r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	printf("%lld",ans);
}
int main(){
	init();
	solve();
	return 0;
}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

## P10098 [ROIR 2023 Day 2] 地铁建设 题解

### Solution（解析）

首先，总功率是跟着电压走的，电压大总功率就大。综上，可以二分。

我们二分枚举电压（这里把 $r$ 初始值定为 $p$），每一次调用判断函数（`check` 函数），先遍历一遍求出总功率 $r$，然后分为以下情况：

+ $r \ge p$，缩小 $r$。

+ $r < p$，把 $l$ 扩大。

时间复杂度为 $O(n \log p)$（因为 $r$ 初始值定为 $p$）。

### Code（代码）

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iomanip>

using namespace std;

using ll = long long;

const int kMaxN = 110, kInf = (((1 << 30) - 1) << 1) + 1, kMod = 1e9 + 7;
const ll kLInf = 9.22e18;

ll n, p;

struct node {
  ll a, b, z;
} a[kMaxN];

bool Check(ll mid) {
  ll r = 0;
  for (int i = 1; i <= n; ++ i) {
    if (mid <= a[i].z) {
      r += mid * a[i].a;
    } else {
      r += (a[i].a * a[i].z + a[i].b * (mid - a[i].z));
    }
  }
  return (r >= p);
}

int main() {
  cin >> n >> p;
  for (int i = 1; i <= n; ++ i) {
    cin >> a[i].z >> a[i].a >> a[i].b;
  }
  ll l = 1, r = p, ans = 0, mid;
  for (; l <= r; ) {
    mid = (l + r) >> 1;
    if (Check(mid)) {
      r = mid - 1, ans = mid;
    } else {
      l = mid + 1;
    }
  }
  cout << ans << '\n';
  return 0;
}
```

---

## 作者：2021zjhs005 (赞：0)

一眼望去，二分。

[题目传送门](https://www.luogu.com.cn/problem/P10098)。



------------
仔细一看，只要电压越多，发动机的总功率就越多；反之，则越少。

这种情况可以考虑二分。

二分电压，每次用 $check$ 函数确定是左区间还是右区间。

$check$ 函数内，用 $\mathcal O(n)$ 的时间复杂度求出总功率，记为 $sum$，然后和 $p$ 比较。

- $sum\le p$，电压还可以更小，$r\gets mid-1$。

- $sum<p$，电压太小了，$l\gets mid+1$。

最后输出 $l$ 即可。

二分时间复杂度为 $\mathcal O(\log (r-l+1))$，所以总时间复杂度为 $\mathcal O(n\log (r-l+1))$，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read(){ll s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}//快读优化，这里有压行。
const ll N=105;
ll n,p,i,l,r,a[N],b[N],z[N];
bool check(ll mid){
    ll sum=0;
    for(i=1;i<=n;i++)
        if(mid<=z[i]) sum+=a[i]*mid;
        else sum+=a[i]*z[i]+b[i]*(mid-z[i]);
    return sum>=p;
}
signed main(){
    n=read();p=read();
    for(i=1;i<=n;i++){
        z[i]=read();a[i]=read();b[i]=read();
    }
    l=0;r=1e12;//r 的上限我定为 p 的最大值，保险一点。
    while(l<=r){//二分。
        ll mid=(l+r)>>1;
        if(check(mid)) r=mid-1;
        else l=mid+1;
    }
    printf("%lld\n",l);
    return 0;
}
```

---


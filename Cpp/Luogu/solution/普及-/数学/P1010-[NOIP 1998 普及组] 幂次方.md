# [NOIP 1998 普及组] 幂次方

## 题目描述

任何一个正整数都可以用 $2$ 的幂次方表示。例如 $137=2^7+2^3+2^0 $。

同时约定次方用括号来表示，即 $a^b$ 可表示为 $a(b)$。

由此可知，$137$ 可表示为 $2(7)+2(3)+2(0)$

进一步：

$7= 2^2+2+2^0$  ( $2^1$ 用 $2$ 表示)，并且 $3=2+2^0$。

所以最后 $137$ 可表示为 $2(2(2)+2+2(0))+2(2+2(0))+2(0)$。

又如 $1315=2^{10} +2^8 +2^5 +2+1$

所以 $1315$ 最后可表示为 $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^4$。

NOIP1998 普及组 第三题

## 样例 #1

### 输入

```
1315```

### 输出

```
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)```

# 题解

## 作者：_xcc_ (赞：530)

看了下面大佬们的题解，有点复杂，本蒟蒻来一发简单的

主要思路是递归/分治，因为分解出的指数还要继续分解，是重复的但规模更小的问题

关于求$log_2 x$,暴力枚举即可，数据很小
```
#include<iostream>
#include<cmath>
using namespace std;
int a;
void fff(int x)
{
    for(int i=14;i>=0;i--) //两万的数据最多是2（14）
    {
        if(pow(2,i)<=x){
        //pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方
            if(i==1) cout<<"2"; //2（1）不用再往后分解了且2^1输出为2，单独出来
            else if(i==0) cout<<"2(0)"; //2（0）也不用再往后分解了，单独出来
            else{ //若i>1则继续分解指数i
                cout<<"2(";
            fff(i);
            cout<<")";
            }
            x-=pow(2,i); //继续循环分解余下的
            if(x!=0) cout<<"+";
            //加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号
        }
    }
}
int main()
{
    cin>>a;
    fff(a);
    return 0;
}
```

---

## 作者：Fading (赞：76)

upd on $2018.10.2$

你们评论区的想干什么?放过我吧,一年前写的 pascal ,就当做是一个 p 党福利吧 qwq 

~~这道题看起来恶心，其实很简单。~~

就是把一个数$n$转换成 $2^a+2^b+2^c+...$的形式。

自然就会想到二进制了。

先用一个函数，把一个数转成二进制，存在一个数组里面：

类似于:$10=2^3+2^1$

这个数组就是$[3,1]$

$137=2^7+2^3+2^0$

数组即为$[7,3,0]$//也就是这个数等于$2^a[1]+2^a[2]+2^a[3]...$
```
type num=array[0..100000] of longint;
var i,j,k,l,n,m,o,p,h:longint;
//这里的a[0]指数组长度。
function ejz(s:longint):num;//要转的数
var i,j,k:longint;
    ans:num;
begin  
  i:=s; j:=0; k:=0; //让变量i赋值为要转的数s
  fillchar(ejz,sizeof(ejz),0);
  fillchar(ans,sizeof(ans),0);
  while i>0 do
  begin
    inc(j);
    ejz[j]:=i mod 2;
    i:=i div 2;  //转2进制的过程在此。
  end;
  for i:=j downto 1 do
    if ejz[i]=1 then begin inc(k); ans[k]:=i-1; end;//若2进制的第n位为1，那么数组中必有n-1。这个应该知道吧
  ans[0]:=k;
  exit(ans);
end;
```
然后是处理。
显然，数组中的数还需要继续处理下去。

譬如：$137=2^7+2^3+2^0$

那么$137=2(7)+2(3)+2(0)$

然后处理$7 \ 3\  0$

$7=2^2+2^1+2^0 $

那么$7=2(2)+2+2(0)$

递归下去，然后以此类推即可
```pascal
procedure search(a:longint);
var n:num; i:longint;
begin
  if a=0 then begin write('2(0)'); exit; end; //如果要处理0，那么...
  if a=1 then begin write('2'); exit; end;    //如果要处理1，那么...
  n:=ejz(a);
  for i:=1 to n[0]-1 do
  begin
    if (n[i]<>1) and (n[i]<>0) then write('2(');//这里要注意了!2^1不是2(1)!!!
    search(n[i]);//递归处理数组里的数
    if (n[i]<>1) and (n[i]<>0) then write(')');
    write('+');//不要把加号输多了!
  end;
  if (n[n[0]]<>1) and (n[n[0]]<>0) then write('2(');
    search(n[n[0]]);
    if (n[n[0]]<>1) and (n[n[0]]<>0) then write(')');
end;
begin
  readln(n);
  search(n);
end.

```


---

## 作者：Mr_Wu (赞：72)

#####这道题其实不算难=-=

#####我的思路是这样的：

#####定义divide(int x)函数，其实就是本程序的核心了，这个函数先分解传进来的数，例如137就分解为[7,3,0]，再对每一项输出，如果不是0或1就再递归一层，否则输出2(0)或2，因为数据量不大，所以这样是不会超时的

#####具体见代码：

#####1、准备部分

```cpp
#include <iostream> //不解释
#include <cmath> //其中有log2(x)和pow(x,y)函数，具体作用往下看
using namespace std;
```
#####2、边分解边输出边递归的divide函数

```cpp
void divide(int x)
{
    bool flag = false; //...判断是否是第一个，如果是的话就不输出加号
    while (x != 0)
    {
        int t = int(log2(x));
        /*
        log2(x)这个函数求以2为底x的对数，例如log2(8)返回3，因为2^3=8
        而这里把返回值强制转换为int是为了找到离x最近又小于x的能表示为2^k的数
        例如int(log2(137))就能返回7，而2^7=128，恰为离137最近的能表示为2^k的数
        */
        if (flag) cout << "+"; //开头不输出加号
        if (t == 1) cout << "2"; //如果这一项是1，输出2，不递归
        else if (t == 0) cout << "2(0)"; //如果这一项是0，输出2(0)，不递归
        else
        {
            cout << "2(";
            divide(t); //递归一层，把括号里的数分解输出
            cout << ")";
        }
        x -= pow(2,t); //继续处理下一项
        flag = true;
    }
}
```
#####3.根本不需要解释的主程序

```cpp
int main()
{
    int n;
    cin >> n;
    divide(n);
    return 0;
}
```
#####完结撒花=-=


---

## 作者：CoolTeam (赞：70)

这是我的方法，分治+递归，解释得足够详细了。

感觉题目其实是有提示了，137第一步变成三个子问题，分治求解，子问题与子问题之间用加号连接。

对于每个子问题必然都要先求到最大幂，如第一个子问题最大幂是7，幂不是0、1、2就要把幂当成一个子问题，对幂递归求解。

```cpp
#include<stdio.h>  
int a[30];  
int dfs(int n)  
{  
//幂为0、1、2则直接输出，>=3则递归求解。   
    int i=0;  
    if(n!=0)  
    {    
        while(n>=a[i]) i++; i--; //找到最大的幂  
        n-=a[i];//下面12~20行是处理减去的这部分。   
        printf("2");   
        if(i!=1)printf("(");//注意1次幂是2而不是2(1)      
        if( i==0 || i == 2 ) printf("%d)",i);//幂为0、1、2时可输出幂(幂1时无输出)   
        //如果幂>=3，对幂递归，不输出幂。   
        if(i>=3) {dfs(i);printf(")");}//递归求解，再添加右括号。  
        if(n!=0) {printf("+");dfs(n);}//子问题与子问题之间用+连接;处理剩余的n(子问题)。  
    }  
    return;  
}  
int main(void)  
{  
    int i,n;  
    a[0]=1;  
    for(i=1;i<50;i++)  
        a[i]=a[i-1]*2; //a：1 2 4 8 16 32……   
    scanf("%d",&n);  
    dfs(n);  
    return 0;   
}
```
另外如果注意到数据范围n<=20000，而20000<2^15，所以可以用打表的方法，列出幂分别为1~14时候的输出。每次查找最大幂来输出。比如137，"幂7输出+幂3输出+幂0输出"就完了。


---

## 作者：Rapiz (赞：33)

这种题就是求最短代码还要思路清晰！

我的代码，应该比之前所有的都好，美中不足是有俩小补丁。po上来以飱后人，希望有人能把我的代码继续进行逻辑简化！

```cpp

#include<iostream>
using namespace std;
int n;
void solve(int a){//假设它可以按要求输出a 
    if (a==0) cout<<0;//补丁，写到后来加上的，你暂且往下读就明白作用了 
    else if(a==1) cout<<"2(0)";
    else if(a==2) cout<<"2";//显然的边界 
    else{
        int t=a,i=0;
        while(t) t>>=1,i++;//找出数a在二进制下的位数 
        bool f=1;//是不是第一个输出的数字，用来指示加号的输出 
        for(i=i-1;i>=0;i--)//i=i-1得到最高位标号，i指示位数，从高到低依次遍历所有位，功能是把数a分解成2的幂的和 
            if((a>>i)&1) {//当前位是否为1 
                if(f) f=0; 
                else cout<<"+";//控制加号输出 
                if(i==1) cout<<2;//第二个补丁……不加这句会出现2(2(0))，它等于2 
                else cout<<"2(",solve(i),cout<<")";//当前位可以分解成2^i，用solve(i)表示出指数 
            }
    }
}
int main(){
    cin>>n;
    solve(n);
}

```

---

## 作者：CYC的幸福生活 (赞：20)

# 递归水过

#### 简单讲下思路

首先一个标准的$dfs()$，然后打完发现还是$gg$，为什么呢？

我们的代码容易将$2^1$输出成2(2(0)),然而答案是2

所以加一个特判，如果这个数不是2的一次方，再进行递归就好了

ac代码($a^n$的数组需要预处理)：

```cpp
#include "bits/stdc++.h"
#define int long long
using namespace std;
int a[200] = {1};
void find(int n){
	if(n == 1){cout << "2(0)"; return;}
	if(n == 2){cout << "2";return;}
	int i;
	for(i = 0;i < 200; i++)
		if(a[i] <= n && a[i+1] > n) break;
	cout << "2";
	if(i != 1){
	cout << "(";
	find(i);
	cout << ")";
	}
	if(n > a[i]){
		cout << "+";
		find(n-a[i]);
	}
}
signed main(){
	for(int i = 1;i < 200; i++) a[i] = a[i-1] * 2;
	int n;
	cin >> n;
	find(n);
	return 0;
}
```



---

## 作者：李若谷 (赞：16)

似乎没有题解详细讲位运算的

发一篇题解

首先，根据题目的137 = 2^7 + 2^3 + 2^0，我们可以发现其实对应着 137 的二进制

137的2进制就是  10001001

二进制中是1的下表从右往左数是  0   3   7
也对应着 2^0   2^3    2^7

所以不难想出，这道题就是转2进制，递归

对于每一个数，把他二进制下包含1的坐标递归然后输出

那么怎么找出一个数在2进制下某一位包不包含1呢？

首先，以137为例

137的二进制是 10001001，我们想知道它的第3位有没有1（从右往左，第一个下表是0）

我们可以将 137 & 1<<3

1<<3 在二进制下是 1000 （也就是1，然后后面添加3个零）

&上以后就会让1<<3的第3位跟137的第3位比，如果137的第3位是1，就返回一，否则返回零

不懂的话就看代码注释吧：


```cpp
#include <iostream>
#include <cmath>
using namespace std;
void f(int x)
{
	if(x==0)
	{
		cout<<0;
		return ;
	}
	int n = log(x)/log(2);   //判断一个数在二进制下的位数（log2(x) = log10(x) / log10(2)
	bool first = 1;  //判断一个数是否是第一次
	for(int i=n;i>=0;i--)   //因为输出要从大到小输出，所以for得反着来（否者的话位运算的下表是从右到左，会先输出 2(0) + ...
	{
		if(x&(1<<i))
		{
			if(i==1)      //如果是2^1次方的话，不用输出2(1)直接输出2，所以要特判
			{
				if(first)
				{
					first = 0;
					cout<<"2";
				}
				else

				continue;
			}
			if(first)
			{
				first = 0;
				cout<<"2"<<"(";
				f(i);
				cout<<")";
			}
			else 
			{
				cout<<"+"<<"2"<<"(";    //如果不是第一次的话就要前面加一个+号
				f(i);
				cout<<")";
			}
		}
	}
}
int main()
{
	int n;
	cin>>n;
	f(n);
	return 0;
}
```




---

## 作者：shajunguang (赞：16)

严格按照提示类型来做：递归（滑稽）  
先说思路：  
1.做递归嘛，最开心的是找到触底条件，不然要累死（无限循环）  
2.本题中我将1,2,3作为了触底条件，1打印2(0),2打印2,3打印2+2(0)，  
至于为何打印3,代码注释有讲。（其实触底条件加什么不重要，重要时让递归程序  
递下去了，能归回来）  
3.然后就是打印过程了，主要分为两步：  
1）首先打印高阶部分，就是找到最接近n的部分。  
2）其次打印剩余部分，就是n-2^i部分。  

## 下面是弱子代码，看官多多指正  

------------
```cpp
#include <bits/stdc++.h>
using namespace std;

int base_two(int n){  // 手写的计算2的阶乘,不想用pow（嗯）
    int sum=1;
    for(int i=0;i<n;i++)
        sum *=2;
    return sum;
}
// 递归过程,重要的是知道触底条件
void print(int n){
    if(n==1)
        { printf("2(0)"); return;}
    if(n==2)
        { printf("2"); return; }
    if(n==3)
        { printf("2+2(0)"); return; }  // 萌新第一次没加这个,总是把3打印成2(2(0))+2(0)
    int t;
    // 这里找到最接近n的幂次,准备打印
    for(int i=2;i<=15;i++)
        if(base_two(i)>n){
            printf("2("); //从左开始打印
            t=i-1;
            break;
        }
    print(t);
    printf(")"); // 结束高阶打印
    if(n-base_two(t)==0)    return; // 由于前面寻找的t没考虑相等情况,相等其实结束了
    printf("+");
    print(n-base_two(t));  //打印剩余部分
}

int main()
{
    int n;
    cin>>n;
    print(n);
    return 0;
}
```


---

## 作者：Sweetlemon (赞：11)

应当注意到，这题数据很小(n<=20000)！由14<log(2) 20000<15得，我们只要把2的0到14次方用“零二表示法”表示出来，再根据这个数的二进制输出相应的位就好啦！20行AC，靠的就是这种奇怪的方法……

当然，还是希望大家能练习更好、更通用的方法，这只是作为一个“思维拓展”啦！

下面上代码：

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(void){
    int n;
    int i;
    bool first=true;
    string t[15]={"2(0)","2","2(2)","2(2+2(0))","2(2(2))","2(2(2)+2(0))","2(2(2)+2)",
    "2(2(2)+2+2(0))","2(2(2+2(0)))","2(2(2+2(0))+2(0))","2(2(2+2(0))+2)",
    "2(2(2+2(0))+2+2(0))","2(2(2+2(0))+2(2))","2(2(2+2(0))+2(2)+2(0))",
    "2(2(2+2(0))+2(2)+2)"};//此为“零二表示法”的表
    cin >> n;
    for (i=14;i>=0;i--){ //由于这题要求降幂排列，因此从高位到低位迭代
        if ((n>>i)&1){ //意思是“如果n的二进制形式从右往左数第i位是1”，不理解的同学请补习位运算
            cout << (first? (first=false,"") :"+"); //如果不是第一项，就输出"+"号
            cout << t[i];
        }
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：8)

由于本蒟蒻没学过递归，几次超时都没找出原因，终于，AC了......

这题其实挺晕的，（如果试图用脑子来模拟递归过程的话）

首先要看清题目：‘符合约定的n的0，2表示’

包括：2（2）、2、2（0）；

即只有4、2、1符合要求，其他一律要分解（递归）；

注意几点：

1、每次分解要记得将分解数t减少，分解完记得将总量n减少；

2、记得每次分解添加加号；

3、注意括号位置，第一次分解不用在前后加括号；

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int n;
void ss(int n)
{
    int s=0,t1=0,t=0;//t1记得清零 
    while (n>0)//分解 
    {
        s=1;t=0;//每次s清1，t记得清零 
        while (s*2<=n)//算出0每次n能承受的2的最大次方数 
        {
            t++;//如果可以乘，记得加1 
            s*=2;//改变s值（*2） 
        }
        if (t!=0&&t!=1&&t!=2) {printf("2(");ss(t);n-=s;printf(")");}
        //如果不符合 2（2）、2、2（0），就用递归分解，分解完记得把n-相对应的s，注意不要漏掉括号
        //下面则是判断，符合，输出相对应的次方，记得把n-对应数s； 
        if (t==0) printf("2(0)"),n-=1;
        if (t==2) printf("2(2)"),n-=4;
        if (t==1) printf("2"),n-=2;
        if (n>0) printf("+");//n>0代表后面还要加，输出加号 
    }
}
int main()
{
    cin>>n;//输入n 
    ss(n);//运行ss 
    return 0;
}

```

---

## 作者：Adam_Ng (赞：4)

发一个伪打表的方法
如果是奇数末位必输出"+(2(0))"，那么我们就单独把他存起来，然后所有数按偶数处理。
这道题范围比较小，那么我们用数组a存20000以内2的几次幂，ai表示2的i次幂。每次n减去数组中小于n的最大值，并且输出这个ai的幂次方。循环此操作直到n=0，如果在一开始判断出是奇数就输出"+(2(0))"
因为输出加号的问题，而且本蒟蒻不会用\b，所以我们单独处理第一趟，再在后面几趟里面输出的开头输出一个加号。
```cpp
#include<iostream>
#include<cstdlib>
using namespace std;
int n,que,k,a[15]={0,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384};//存储小于20000的2的几次幂
int main()
{ 
	cin>>n;
	if(n&1)
	{
		n--;que=1;
	}//判断是否是奇数，如果是就用que记下来，然后n--按偶数处理
	if(n)//单独处理第一趟
	for(int i=13;i>=0;i--)//从后往前找，也就是从大往小枚举
	{
		if(n-a[i]>=0)//找到第一个小于n的数
		{
			k=i;//存起来次数
			n-=a[i];//减去最大值，之后处理剩下的部分
			
			switch(k)//switch判断
			{
				case 14:cout<<"2(2(2+2(0))+2(2)+2)";break;
				case 13:cout<<"2(2(2+2(0))+2(2)+2(0))";break;
				case 12:cout<<"2(2(2+2(0))+2(2))";break;
				case 11:cout<<"2(2(2+2(0))+2+2(0))";break;
				case 10:cout<<"2(2(2+2(0))+2)";break;
				case 9: cout<<"2(2(2+2(0))+2(0))";break;
				case 8: cout<<"2(2(2+2(0))";break;
				case 7: cout<<"2(2(2)+2+2(0))";break;
				case 6: cout<<"2(2(2)+2)";break;
				case 5: cout<<"2(2(2)+2(0))";break;
				case 4: cout<<"2(2(2))";break;
				case 3: cout<<"2(2+2(0))";break;
				case 2: cout<<"2(2)";break;
				case 1: cout<<"2";break;
			}//分解完之后的每一个情况，这里不详细说了
			break;//做完一次就退出，再去找减去后的最大值
		}
	}
	while(n)//一直找最大值并减去，直到n==0
	for(int i=13;i>=0;i--)
	{
		if(n-a[i]>=0)
		{
			k=i;
			n-=a[i];
			
			switch(k)
			{
				case 14:cout<<"+2(2(2+2(0))+2(2)+2)";break;
				case 13:cout<<"+2(2(2+2(0))+2(2)+2(0))";break;
				case 12:cout<<"+2(2(2+2(0))+2(2))";break;
				case 11:cout<<"+2(2(2+2(0))+2+2(0))";break;
				case 10:cout<<"+2(2(2+2(0))+2)";break;
				case 9: cout<<"+2(2(2+2(0))+2(0))";break;
				case 8: cout<<"+2(2(2+2(0)))";break;
				case 7: cout<<"+2(2(2)+2+2(0))";break;
				case 6: cout<<"+2(2(2)+2)";break;
				case 5: cout<<"+2(2(2)+2(0))";break;
				case 4: cout<<"+2(2(2))";break;
				case 3: cout<<"+2(2+2(0))";break;
				case 2: cout<<"+2(2)";break;
				case 1: cout<<"+2";break;
			}//这边开头要输出个加号
			break;
		}
	}//同上
	if(que)cout<<"+2(0)";//末位判断，如果是奇数补上这个输出
}
```

---

## 作者：HQK_TJU (赞：4)

思路：十进制转二进制



```cpp
#include<bits/stdc++.h>
#define INF 2147483647

using namespace std;
int n;
void Change(int x){
	int Binary[16]={0};
	int n=0;
	int x1=x;
	int sum=0;
    //二进制转十进制
	while(x!=0){
		Binary[n++]=x%2;
		x/=2;
	}
	n--;
    
    //倒序处理
	for(int i=n;i>=0;i--)
		if(Binary[i]!=0){
        	//sum用来控制+号输出
		    sum+=pow(2,i);		
			cout<<2;
            //如果i！=1，则需要输出括号
			if(i!=1){
			    cout<<'(';
                //如果i=2或i=0，直接输出
			    if(i==2||i==0)
			        cout<<i;
                //否则对次数再次进行转换输出
			    else
			        Change(i);
			    cout<<')';
			}
            //如果输出的数总和还没有达到原来的数，说明还没完，输出+号
			if(sum!=x1)
			    cout<<'+';
		}
}

int main(){
	//输入数据
	cin>>n;
	
	//处理并输出数据
	Change(n);
	cout<<endl;
	return 0;
}
```

---

## 作者：CBW2007 (赞：3)

> 原题链接：[ P1010 幂次方 - 洛谷 | 计算机科学教育新生态](https://www.luogu.org/problemnew/show/P1010)

在我的博客食用效果更佳！<https://www.cbw2007.tk/posts/luogu-P1010-sol>

## 分析

看各位大佬都用二进制等高端算法，蒟蒻都不会啊！QAQ只好用了最朴素的递归与模拟。

这里要理清这两点：

1. 在分解一个数时，不能出现重复的，因为$2^x+2^x=2^{x+1}$。
2. 分解出来的幂的指数要尽可能的大。

然后，程序的具体思路是：

1. 先找一个尽可能大的、小于k的幂。
2. 特判，将指数为0和1的单独挑出来输出。
3. 递归指数。
4. 减去已经找到的幂次方数，返回第一步。

这样说可能有点迷，上代码更简单！

## 核心代码

```cpp
void dfs(int k)//传入一个数
{
    while (k!=0)//如果这个数还没有处理完
    {
        int t=2,i;//指数为1
        for (i=1;t<=k;i++)//指数不断增加，直到当前幂次方已经大于k
            t*=2;
        i--; t/=2;//因为这时候t已经比k大了，所以指数减一
        if (i==0)//如果指数为零
        {
            cout<<"2(0)";
            k-=1;//同k-=t
            goto last;
        }
        if (i==1)//如果指数为一
        {
            cout<<"2";
            k-=2;//同k-=t
            goto last;
        }
        cout<<"2(";
        dfs(i);//递归指数
//		cout<<i;//可以把这一步取消注释，把上一步进行注释，观察指数未分解时是否正确
        cout<<")";
        k-=t;//减去已经找到的幂次方数
        last:
        if (k!=0)
            cout<<"+";//如果k没处理完，输出加号
    }
}
```



---

## 作者：Hope2075 (赞：3)

直接用main函数递归，参数用变量pass传递

```cpp
#include<iostream>
using namespace std;
int pass;
bool first=true;//控制数值来源
int main(){
	int n;
	if(first){
		cin>>n;
		first=false;
	}else{
		n=pass;
	}
	if(n==2){
		cout<<"2";
		return 0;
	} else if(n==0){
		cout<<"0";
		return 0;
	}
	bool f=false;//防止第一项前出现加号
	for(int i=31;i>=0;i--){
		if(n>>i){
			if(i==1){//特判分解出2
				if(f){
					cout<<"+";
				}
				f=true;
				cout<<"2";
				n-=1<<i;
				continue;
			}
			if(f){
				cout<<"+";
			}
			f=true;
			cout<<"2(";
			pass=i;
			main();
			n-=1<<i;
			cout<<")";
		}
	}
	return 0;
} 
```

---

## 作者：邹榆冬 (赞：3)

说实话，这是典型的递归。

代码如下：

        
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long int a;//long long int 纯粹是为了防炸。
void f(long long int a){
    while(a>0){
        long long int t=1,b=0;//t 代表比这个函数中的a小的最大的2的次方，b 代表t的指数（long long int 也是为了防炸（尽管没有必要））
        while(a>=t*2){
            t*=2;//不多说，上面解释了
            b++;
        }
        a-=t;
        if(b==1){
            printf("2");//题目说了2的一次方直接输出2
            }
        if(b==0){
            printf("2(%d)",b);//2的零次方也直接输出
        }
        if(b!=1 && b!=0){
            printf("2(");//都不是的话，就要对b进行一次递归
            f(b);
            printf(")");
        }
        if(a>0){//最后一位不输出加号，所以设个if语句
            printf("+");
        }
    }
}
int main(){
    long long int a;
    scanf("%d",&a);//输入
    f(a);//调用函数
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

发一个神奇的题解：

先简单介绍一下思路：

初始判断条件，如果n为1或2则直接输出

j每次乘2,如果大于了n就分解结束，i为当前次数

确定是否需要继续 2()

如果n分解之后还有剩余的数，那么继续分解


代码：

```cpp
#include<iostream>
#include<math.h>
using namespace std;
int div(int j)
{
    while(j>0)
    {
        int m=int(log2(j));
        for(int i=m;i>=0;i--)
        {
            if(pow(2,i)<=j&&j>0)
            {
                j-=pow(2,i);
                if(i>2){cout<<"2(";div(i);cout<<")";if(j>0) cout<<"+";}
                else if(j>0&&i!=1)cout<<"2("<<i<<")+";
                else if(j>0&&i==1)cout<<"2+";
                else if(i!=1)cout<<"2("<<i<<")";
                else cout<<"2";
            }
        }
    }
}
int main()
{
    int n;
    cin>>n;
    div(n);
}
```

---

## 作者：陈新月 (赞：2)

首先说思路

1.首先想到的是把数化成二进制，便于计算

2.将数化成二进制后，如果2的指数大于2，则进行递归计算

3.保存答案，在递归函数的结尾记录当前数值所表示的字符串，减少重复计算

4.输出答案


下面贴代码





    
    



```cpp
#include<iostream>
#include<stack>
#include<string>
using namespace std;
string num[20009];   //用于存储已经计算过的幂次方值 
string solve(int now){
    if(num[now] != "")return num[now];   //如果在之前已经计算过当前值的幂次方则直接返回，减少计算量 
    string ans;               //答案 
    stack<int> sta;            // 存二进制的栈 
    int x = now;        //将当前数字now化成二进制用栈存储 
    while(x){
        sta.push(x%2);
        x /= 2;
    }
    int len = sta.size(),first = 1;   //first为输出变量，用于正确输出加号，Len为栈大小， 
    for(int i = len; i >= 1; i--){
        x = sta.top(); sta.pop();
        if(x != 0){
            if(first)first = 0;     
            else ans += '+';
            if(i == 1)ans += num[1];        //特判 
            else if(i == 2)ans += num[2];   //特判 
            else {
                ans += "2(";                //指数部分大于2则递归计算答案，并存入ans          
                ans += solve(i-1); 
                ans += ")";
            }
        }
    }
    num[now] = ans;                       //对当前now值进行记忆化，减少计算 
    return ans;
}
int main(){
    int n;
    cin >> n;
    num[1] = "2(0)";             //底层数据初始化 
    num[2] = "2";
    num[3] = "2+2(0)";
    num[4] = "2(2)";
    string ans = solve(n);
    cout << ans <<endl;
    return 0;
}
```

---

## 作者：蠢萌_小三爷 (赞：2)

貌似没人用bitset，我来水一波

#STL大法好

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <bitset>
using namespace std;
int n;
void solve(int x)
{    
    if(x==1||x==2||x==0)return ;//1,2,0不作分解 
    bitset<32> b=x;//STL大法好啊 
    int sum=b.count(),s=0;//记录何时到最后一位，以便输出"+" 
    for(int i=b.size()-1;~i;--i)//从高阶位遍历 
        if(b[i])//如果是1，则处理 
        {
            s++;//记录已经走过的位数 
            printf("2");
            if(i!=1)printf("(");//只有次幂不为一时输出括号 
            solve(i);//递归 
            //递归输出： 
            if(i==0||i==2)printf("%d",i);//只输出2,0 
            
            if(i!=1)printf(")");
            if(s<sum)printf("+");
        }
}
int main()
{
    cin>>n;
    if(n==1)return printf("2(0)"),0;//特殊点判断 
    if(n==2)return printf("2"),0;
    solve(n);//进入递归 
    return 0;
}
```

---

## 作者：feecle6418 (赞：2)

好像还没人像我这么做的，赶紧水一发。

思路：先用log2()函数求出最大的，比N小的二的次方数，然后开始递归。

看看代码就懂啦！^\_^

```cpp
#include<iostream>
#include<cmath>
using namespace std;
void cg(int n){
    if(n==0){//前面五种特判
        return ;
    }
    if(n==1){
        cout<<"2(0)";return ;
    }
    if(n==2){
        cout<<2;return ;
    }
    if(n==3){
        cout<<"2+2(0)";return ;
    }
    if(n==4){
        cout<<"2(2)";return ;
    }
    int x=log2(n);//记录二的次方数
    cout<<"2(";//输出前半段
    cg(x);//把括号内的数变成符合约定的n的0，2表示
    cout<<")";//括号完成
    if(n==pow(2,x)){//若N直接是2的次方数就完了，退出
        return ;
    }
    cout<<"+";//若不是，则继续加
    cg(n-pow(2,x));//减去前面的，递归转换
    return ;
}
int main(){
    int n;
    cin>>n;
    cg(n);
    return 0;
}
```

---

## 作者：桀骜的野心家 (赞：2)

我的方法是先转2进制

```cpp
#include<cstdio>  
#include<cmath>  
using namespace std;  
void sillyB(int k)  
{int i,j,l,p;  
 int a[16];  
 bool boo;  
 boo=false;  
 l=0;        
 p=k;  
 while (p>0)  
     {  
     a[l]=p%2;  
     p=p/2;  
     l++;  
     }  //转2进制
 l--;  
 for (i=l;i>=0;i--)  
     if (a[i]==1)//2进制位数上如果是1就处理，是0就不处理  
       { if (boo) printf("+");  
             else boo=true;  
         if (i==0) printf("2(0)");  
         if (i==1) printf("2");  //如果位数是0或1是就直接输出，1以上就继续向下递归
         if (i>1)  {  
                    printf("2(");  
                    sillyB(i);  
                    printf(")");  
                   }  
       }      
}  
int main()  
{int n;  
   scanf("%d",&n);  
   sillyB(n);     
}
```

---

## 作者：PhantasmDragon (赞：2)

其实题目已经帮你把递归步骤写好了，你只需要模拟出来

不多说了，代码里有注释

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
void dis(int a)
{
    char s[1000];
    int mark=0,t,ta=a;
    for(int i=0;ta>0;i++)//分解成二进制，存到字符串里面
    {
        if(ta%2==1)
        {
            s[i]='1';
            mark++;
            ta/=2;
        }
        else
        {
            s[i]='0';
            mark++;
            ta/=2;
        }
    }
    ta=a;
    mark--;
    for(;mark>=0;mark--)//反向遍历字符串
    {
        if(s[mark]=='1')//当是1的时候才干事。。。
        {
            t=1;
            for(int i=0;i<mark;i++)//与后面的判定加号相关。
            {
                t*=2;
            }
            ta-=t;
            if(mark==0)//如果是基础单位，直接输出，并判定加号。
            {
                printf("2(0)");
                continue;
            }
            if(mark==1)
            {
                printf("2");
                if(s[mark-1]=='1')
                {
                    printf("+");
                }
                continue;
            }
            if(mark==2)
            {
                printf("2(2)");
                if(s[mark-1]=='1'||s[mark-2]=='1')
                {
                    printf("+");
                }
                continue;
            }
            printf("2(");
            dis(mark);//递归
            printf(")");
            if(ta>0)//判定加号
            {
                printf("+");
            }
        }
    }
}
void solve()
{
    int n;
    scanf("%d",&n);
    dis(n);
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：Rachel_in (赞：1)

**打表大法好！！！打表大法好！！！打表大法好！！！**

本题我用了一种奇怪（？）的打表方法。打表的思路跟之后的算法差不多。

因为2^14<n<2^15 所以打表是很方便的

思路是：把n减去最大的小于n的2的幂次方，然后把打的表用字符串记下。

注意：要把最后的加号删去。



```cpp
var
 a:array[0..15]of string;
 b:array[0..15]of longint;
 i,j,k,n,m:longint;
 s:string;
begin
 readln(n);
 a[0]:='2(0)';//1
 a[1]:='2';//2
 a[2]:='2(2)';//4
 a[3]:='2('+a[1]+'+'+a[0]+')';//8
 a[4]:='2(2(2))';
 a[5]:='2('+a[2]+'+'+a[0]+')';
 a[6]:='2('+a[2]+'+'+a[1]+')';
 a[7]:='2('+a[2]+'+'+a[1]+'+'+a[0]+')';
 a[8]:='2('+a[3]+')';
 a[9]:='2('+a[3]+'+'+a[0]+')';
 a[10]:='2('+a[3]+'+'+a[1]+')';
 a[11]:='2('+a[3]+'+'+a[1]+'+'+a[0]+')';
 a[12]:='2('+a[3]+'+'+a[2]+')';
 a[13]:='2('+a[3]+'+'+a[2]+'+'+a[0]+')';
 a[14]:='2('+a[3]+'+'+a[2]+'+'+a[1]+')';
 a[15]:='2('+a[3]+'+'+a[2]+'+'+a[1]+'+'+a[0]+')';
 b[0]:=1;
 for i:=1 to 15 do
  b[i]:=b[i-1]*2;
 for i:=15 downto 0 do
 if n>=b[i] then
  begin
   s:=s+a[i]+'+';
   n:=n-b[i];
  end;
 delete(s,length(s),1);
 writeln(s);
end.
```

---

## 作者：bzy369258147 (赞：1)


```cpp
//本题很水，一个递归即可搞定
**include<bits/stdc++.h>**//万能头文件
using namespace std;//流操作命名空间
//递归
string dfs(int n){
//返回处理后的字符，一直递归直至全部处理完（0,1,2必须特判跳出）；
    string out="";//存储输出
    int k=-1,i=1;bool ff[16];//临时变量;
    //
    for(int i=0;i<=15;i++){
        ff[i]=n&1;n=n>>1;//二进制取位运算，取得所有的为1的二进位表示可以操作
    }
    for(int i=15;i>=0;i--){
        if(ff[i]){//判断是否为1
            if(i>=2)out+="2(" + dfs(i) + ")+";//二以上则再次递归指数
            if(i==1)out+="2+";//特判1
            if(i==0)out+="2(0)+";//特判0
        }
    }
    return out.substr(0,out.size()-1);//返回//去除尾部‘+’
}
int main(){
    int n;cin>>n;
    cout<<dfs(n);
    return 0;
}
```

---

## 作者：shijunfeng00 (赞：1)

管你们怎么想,,,我就觉得好难

主要是括号的位置和+号的位置不好判断

其他都没难度

我能说我是拼凑出来的嘛

if(m[j])if(j==1)if(m[0]!=0)cout<<"2+";else cout<<'2';

else{cout<<"2(";if(j>2)find(j);else cout<<j;cout<<")";if(j!=t&&j!=0)cout<<j<<"+";}

写了这么一堆我差点自己都没看懂,反正答案就对了..哈哈...

——————————

首先将n转化成二进制数

比如137=1001001,存入数组

数组循环,i=1 to max.对于每个m[i]==1的数

递归查找

很好找出来

重要的就是什么时候加括号什么时候有加号的问题...

这个一言难尽啊,,看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
void find(int n)
{
    int t=n;
    int m[18]={0},i=0,j=0;                    //全部都是临时变量,数组15位就足够了 
    while(n!=0)                              //20000二进制是100111000100000 
    {
        m[i++]=n%2;                           //转换成二进制并标记上 
        n/=2;                              
    }
    int maxxx=0;                              //找到最后一个数字的位置,他的后面没有加号  
    for(j=i;j>=0;j--)                         //从这里开始逻辑就有点乱了 
        if(m[j])maxxx=j;                      //我能说我是拼出来的嘛,,反正就对了 
    for(j=i;j>=0;j--)
    if(m[j])if(j==1)
        if(m[0]!=0)cout<<"2+";
        else cout<<'2';                       ///2^1次方特殊对待 
    else
    {
        cout<<"2(";
        if(j>2)find(j);                       //递归查找 
        else cout<<j;cout<<")";
        if(j!=maxxx)cout<<"+";
    }
}
int main()
{
    int n;
    cin>>n;
    find(n);                               //调用函数 
} 

```

---

## 作者：不知名的龙xx (赞：1)

这道题其实可以用递归的思维方式来做，首先要录入2的N次方的各个值（N自己定）。然后再逐个筛选谁接近n最后

确认那个数，再把那个数进行上面的处理（假如是2的0次方或是2的2次方免了）。最后判断加号和括号在哪儿加。



```cpp
var
        n,i:longint;
        a:array[0..15]of longint;
procedure dg(x:longint);
var
        j,m:longint;
begin
        m:=x;
        j:=15;
        while x>0 do
        begin
                        if a[j]<=x then
                        begin
                                if j=1 then
                                begin
                                        if x<m then write('+');
                                        write('2');
                                end
                                else
                                begin
                                if x<m then write('+');
                                write('2(');
                                if j=0 then write('0')
                                else dg(j);
                                write(')');
                                end;
                                x:=x-a[j];
                        end;
                dec(j);
        end;
end;
begin
        readln(n);
        a[0]:=1;
        for i:=1 to 15 do
                a[i]:=a[i-1]*2;
        dg(n);
end.
```

---

## 作者：foreverpiano (赞：1)

代码在下面，写的应该比较详细了




```cpp
#include<bits/stdc++.h>//暴力无敌强大的头文件 
using namespace std;
int n;
int last(int *a,int i)//判断是否在最后是否需要打加号，注意*a的使用 
{
  for(int k=i-1;k>=0;k--)
    if(a[k]==1)
      return 1;
    return 0;
}
int search(int m)
{
   int a[100];//我是定义数组一个一个搜，虽然空间大，但是好写。 
   memset(a,0,sizeof(a));//清空 
   int k=-1;
   int mm=m;
   while(m>=1)
    {
    a[++k]=m%2;
    m=m/2;
```
}//转为2进制，写到这里记得调试
             
                          
    

```cpp
      for(int i=k;i>=0;i--)
    {
       if(a[i]==1)//下面为多种情况，仔细看应该可以看得懂 
       {
               if(i==1)
                        cout<<"2";
              if(i==0)
                        cout<<"2(0)";
               if(i>=2)//自己调用自己，在内部继续寻找 
                        {
                             cout<<"2(";
                           search(i);
                           cout<<")";
                        }
                if(last(a,i)) cout<<"+";
            }
    }
}
int main()
{
    int k=0;
    cin>>n;
  search(n);
   return 0;
}
```

---

## 作者：GNAQ (赞：1)

直接模拟数学的分解法，简单粗暴，不使用二进制的分治（好像这种思路没有题解于是我来一发吧）

 ![](https://cdn.luogu.com.cn/upload/pic/5391.png) 

看明白就可以明白那个Markx是干什么的了


##请勿直接抄袭代码


```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
using namespace std;
int n;//读入的数
void getresult(int x)
{
    int markx[50]={0},counter1=0,nowstatus=0;//nowstatus是现在与x相乘的2^m的指数m
    while (x>1)                  //开始拆数 具体原理请看上图
    {
        if (x%2==1)
        {
            markx[counter1]=nowstatus;
            counter1++;
        }
        x=x/2;
        nowstatus++;
    }
    if (nowstatus==1) printf("2"); //如果指数是1，输出2
    else if (nowstatus==0) printf("2(0)"); //特判指数为0
    else //指数大于1的情况，分治求解
    {
        printf("2(");
        getresult(nowstatus);
        printf(")");
    }
    if (counter1>0) for (int i=counter1-1;i>=0;i--)  //后面都要输出前导“+”号
    {
        if (markx[i]==1) printf("+2"); //特判指数
        else if (markx[i]==0) printf("+2(0)");//特判指数
        else //指数大于1的情况，分治求解
        {
            printf("+2(");
            getresult(markx[i]);
            printf(")");
        }
    }
    return;
}

int main()
{
    scanf("%d",&n);
    if (n==0)//特判0，不知道用上了没
    {
        printf("0\n");
        return 0;
    }
    getresult(n);//开始求解
    printf("\n");//换行结束
    return 0;
}
```

---

## 作者：秋名山车神 (赞：1)

递归算法，这题略有难度，关于如何把一个数拆成2的次方表现形式，其实就是二进制表达一个数，例如137，二进制为10001001，下标是76543210，二进制中每个1的位置表示为2^下标，最后加起来就是137

```cpp
var
k:integer;
procedure zh(n:integer);
var
a:array[0..1000] of integer;
i,j:integer;
begin
  if n=0 then write(0)  //递归终结条件有两个，一个是被分解到0 一个是到2
  else if n=2 then write(2)
    else
    begin
      i:=-1;
      fillchar(a,sizeof(a),0);  //初始化数组
      repeat
        inc(i);
        a[i]:=n mod 2;
        n:=n div 2;
      until n=0;  //repeat里的这一段表示转化二进制
    for j:=i downto 0 do
      if a[j]=1 then
      begin
        if j<>i then write('+');  //如果它在第一位，那么不输出加号
        if j=1 then write(2)  //这一步很重要！！！如果它已经到2那么无需再递归，直接输出2即可，因为题目要求2（1）写成2，不然会出现2（2（0））
        else
        begin
          write('2(');
          zh(j);
          write(')');
        end;
      end;
    end;
end;
begin
  read(k);
  zh(k);
end.
```

---

## 作者：Demon (赞：1)

由于这道题的数据量很小，所以完全可以打表来完成然后二分查找。这样时间复杂度会很小。

#include<stdio.h>

int biao[16]= {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};//2的幂

void mi(int n)

{//递归

```cpp
    while(n>0)
    {
        int i=find(0,15,n);
        n-=biao[i];
        if(i==1)
            printf("2");
        else if(i==0)printf("2(0)");
        else
        {
            printf("2(");
            mi(i);
            printf(")");
        }
        if(n>0)printf("+");
    }
}
int find(int l,int r,int x)
```
{//二分在表中查找
```cpp
    int mid=(l+r)/2;
    if(l+1<r)
    {
        if(x>=biao[mid])
            return find(mid,r,x);
        else
            return find(l,mid,x);
    }
    else
        return l;
}
int main()
{
    int n;
    scanf("%d",&n);
    mi(n);//调用函数
    return 0;
}
```

---

## 作者：__hao__ (赞：1)

这是一个作死的事例，使用了gcc的黑魔法。。。

显得没事用了下string其实直接输出也可以。

用了内置位运算判断是不是2的幂次。如果是二的幂次就会只有一个位是1，其它都是零，

所以前导0和后导0加起来应该有32 - 1 = 31个（即\_\_builtin\_clz(1))。

gcc还有\_\_builtin\_popcount数是1的二进制位的个数。

其实判断是不是2的幂次还可以直接判断是不是(i & (-i)) == i



```cpp
#include <iostream>
#include <string>
using namespace std;
string f(int n)
{
    if (n == 1)
        return "2(0)";
    if (n == 2)
        return "2";
    int nlz = __builtin_clz(n), ntz = __builtin_ctz(n), bits = __builtin_clz(1);
    int i = bits - nlz, base = 1 << i;
    if (nlz + ntz == bits)
        return "2(" + f(i) + ")";
    return f(base) + "+" + f(n - base);
}
int main()
{
    int n;
    cin >> n;
    cout << f(n) << endl;
}
```

---

## 作者：睡在墙上的猫 (赞：1)

建议你们先不要看程序，先把137的二进制写出来，在看看什么么规律，就知道了，其实很简单！！

```cpp
#include<iostream>
using namespace std;
void dfs(int k)
{
    if (k==1) {cout<<"2(0)";return;
    }
    if (k==2) 
    {cout<<"2";return;
    }
    int i,l=0;
    int s[10000];
    bool good=false;//是否为第一次加，如果为true则打印+
    while(k)//二进制转换，最后全到s数组
    {    
        //s数组一定要从0开始，（二进制）0次方
        s[l]=k%2;
        k/=2;l++;
    }
    for (i=l-1;i>=0;i--)//逆序
    {
        if (good==true&&s[i]==1) cout<<"+"; 
        else if (good==false&&s[i]==1) good=true;
        if (s[i]==1&&i>=2) cout<<"2(",dfs(i),cout<<")";
        else if (s[i]==1&&i==1) cout<<"2";
        else if (s[i]==1&&i==0) cout<<"2(0)";
               //i=1,i=0可以直接处理
    }
} 
int main()
{
    int f;
    cin>>f;
    dfs(f);
    return 0;
}

```

---

## 作者：吴国铨 (赞：1)

良心题解，话说如果静下心来这题可过



```cpp
//这题丧病TAT……
program exz;
var s:string;//最后需要输出的字符串
    n:integer;//求的那个数
    bo:boolean;//判断最后一个2的n次方以便结束递归
procedure search(x:integer);//递归程序（写成函数也可以）
var a:array[0..100] of integer;//存放二进制的数组，放在递归里便于回溯
    i,j,k:longint;
begin
  fillchar(a,sizeof(a),0);//数组初始化
  bo:=true;//判断初始化
  k:=0;//计数器初始化
  repeat//求二进制
    inc(k);
    a[k]:=x mod 2;
    if (x mod 2<>0)and(bo) then
    begin
      bo:=false;
      j:=k;
    end;
    x:=x div 2;
  until x=0;
  for i:=k downto 1 do if a[i]<>0 then//模拟（2^7+2^3+2^0）的形式
  begin
    if i>j then//如果还没有搜索到最后
    begin
      if i>2 then
      begin
        s:=s+'2(';
        search(i-1);//深搜
        s:=s+')+';//补全括号
      end else
      if i=2 then s:=s+'2+' else
      if i=1 then s:=s+'2(0)+';
    end;
    if i=j then//如果搜索到最后了
    begin
      if i>2 then
      begin
        s:=s+'2(';
        search(i-1);//目标不是1或2依然要深搜
        s:=s+')';//补全括号
      end else
      if i=2 then
      begin
        s:=s+'2';
        exit;//到最后了，可以直接退出
      end else
      if i=1 then
      begin
        s:=s+'2(0)';
        exit;
      end;
    end;
  end;
end;
begin
  readln(n);
  if n=0 then//各种特判
  begin
    writeln(0);
    halt;
  end else
  if n=2 then
  begin
    writeln(2);
    halt;
  end;
  search(n);//深搜
  writeln(s);
end.

```

---

## 作者：lightningboosLXY (赞：1)

```cpp
var n:longint;
procedure mi(k:longint);
var s,m:longint;
begin
  m:=0;
  s:=1;
  while s*2<=k do
    begin
      s:=s*2;
      inc(m);
    end;//求k为2的多少次方。
  case m of
    0:write('2(0)');
    1:write(2);
    2:write('2(2)');//因为该题只能输出2,0和括号，所以如果m大于等于3，则需要递归，小于3则直接输出
    else begin write('2(');mi(m);write(')');end;
  end;
  if k-s<>0 then
    begin
      write('+');
      mi(k-s);//如果有余数，则将余数继续递归
    end;
end;
begin
  readln(n);
  mi(n);
  writeln;
end.
```

---


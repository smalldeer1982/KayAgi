# [NOIP 1998 提高组] 车站

## 题目描述

火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？


## 说明/提示

对于全部的测试点，保证 $1 \leq a \leq 20$，$1 \leq x \leq n \leq 20$，$1 \leq m \leq 2 \times 10^4$。

NOIP1998 提高组 第一题

## 样例 #1

### 输入

```
5 7 32 4
```

### 输出

```
13
```

# 题解

## 作者：xiejinhao (赞：2983)

# P1011 车站 题解  ~~绝非正解~~
## 没做的先看看思路，别急着看代码
### 严正声明：禁止抄袭本题解


------------

- 在做之前，我们先找找规律：
1. 第一站：上车 $a$ 人；车上有 $a$ 人；
2. 第二站：假设上车 $u$ 人，则下车 $u$ 人；车上仍然是 $a$ 人；
3. 第三站：上车人数等于前两站上车人数之和：$a+u$ 人，下车人数等于上次上车人数 $u$ 人；净上车人数为 $a$ 人；车上有 $2a$ 人；
4. 第四站：上车人数 $=a+2u$，下车人数 $=a+u$；净上车人数 $=u$；车上有多少人呢？就是 $2a+u$；
5. 第五站：上车人数 $=2a+3u$，下车人数 $=a+2u$，净上车人数 $=a+u$；车上有 $3a+2u$ 人；
6. 第六站：上车人数 $=3a+5u$，下车 $2a+3u$ 人，净上车人数 $=a+2u$；车上有 $4a+4u$ 人……

这里不必在列下去了，发现规律了吗？

将第三站净上车人数看作 $x_1$，第四站看作 $x_2$，第五站为 $x_3$，第六站为$x_4$，有 $x_1+x_2=x_3, \ x_2+x_3=x_4…$ **这不是斐波那契数列么？**

- 知道了起始人数 $a$，知道了终止人数，这里的 $u$ 就可求了；
不过计算机不认识方程，所以我们要想个办法：


- **把 $a$ 和 $u$ 分开处理！！！**

---

**我们不妨把每一站中 $a$ 的关系看作 $a$ 的斐波那契数列，而 $u$ 的关系看作  $u$ 的斐波那契数列。**

- 由于是从第三站开始出现了这样的规律，所以第一项为第三站，第二项就是第四站

我们不妨自己再次总结 $a$ 的规律，于是得到下面的代码:
```cpp
int p = 1, q = 0, k = 0, sum1 = 0;
for(int i = 1; i <= n - 5; i++) {
	k = p + q;
	sum1 += k;
	p = q;
	q = k;
}
```
常规斐波那契就不解释了，但注意，这里统计的 $sum1$ 是 $a$ 的系数！

细心的小伙伴就会发现了，这里满足的条件是 $n>5$，其实 $n≤5$ 也可以，但是代码较为复杂，后面说；

且注意：第三项 $a$ 的系数为 $1$，第四项为 $0$，所以定义 ```p = 1，q = 0```；
这里 ```sum1 = sum1+2```（从第五项开始计算，前面还有 $2a$，不能忽略）

- 同样的，我们得到了计算 $u$ 系数的代码

```cpp
int e = 0, t = 1, g = 0, sum2 = 0;
for(int i = 1; i <= n - 5; i++) {
	g = e + t;
	sum2 += g;
	e = t;
	t = g;
}
```

同样的 ```sum2=sum2+1```；（第五项开始算，前面还有一个 $u$）
那么 $u=?$ 这个大家自己思考，后面给代码再给答案.


------------


- **以上内容针对 $n>5$，那么我们就可以较为整齐地处理 $n≤5$ 的情况了。**

这个如何处理？


大家思考一下，根据我们列出的上面的式子，车站数是肯定 $≥2$ 的，车最少要经过两站。那么无论 $n=2$ 还是 $3$，输出的不都是 $a$ 么？后面的大家自己推理；

- **那么对于 $n≤5$ 也讨论完了，对于 $n>5$ 呢？**

这时又与 $x$ 有关了，根据上面推导的斐波那契数列的规律，那到第 $x$ 站的 $a$ 有几个？$u$ 有几个？（人数 $=t×a+i×u$）还是需要分类讨论的，没有做的思考一下，再看下面代码：

```cpp
if(x <= 5) {
	if(x == 1 || x == 2)cout << ？;
	else if(x == 3)cout << ？;
	else if(x == 4)cout << ？;
	else if(x == 5)cout << ？;
} else {
	for(int i = 1; i <= x - ？; i++) {
		k = p + q;
		sum1 += k;
		p = q;
		q = k;
	}
	sum1 += 2;
	for(int i = 1; i <= x - ？; i++) {
		g = e + t;
		sum2 += g;
		e = t;
		t = g;
	}
	sum2 += 1;
}
```

这里的“？”是什么供大家思考，**最后会给出源码**，参考以上的推导。


$\texttt{Update} \ 2019.7.23\&2023.10.20$
------------
再次使用LaTeX进行了渲染优化了码风，删除了部分内容，附上~~高清无码~~完整代码：

```cpp
    #include<cstdio>
    using namespace std;
    int a, n, m, x, u=1, z, y;
    int main()
    {
        scanf("%d %d %d %d", &a, &n, &m, &x); 
        if(n <= 5) {
            if(n == 2||n == 3)
                printf("%d", a);
            else if(n == 4) {
                if(x == 1 || x == 2) printf("%d", a);
                else if(x == 3) printf("%d", a * 2);
            }
            else if(n == 5) {
                if(x == 1 || x == 2) printf("%d", a);
                else if(x == 3) printf("%d", a * 2);
                else if(x == 4) 
                    printf("%d", (m - a * 3) / 2 + a * 2);
            }
        }
        else {
            int p = 1, q = 0, k = 0, sum1 = 0;
            for(int i = 1; i <= n - 5; i++) { 	
                k = p + q;
                sum1 += k;
                p = q;
                q = k;
            }
            int s1 = sum1 + 2;
            int e = 0, t = 1, g = 0,sum2 = 0;
            for(int i = 1; i <= n - 5; i++) {
                g = e + t;
                sum2 += g;
                e = t;
                t = g;
            }
            int s2 = sum2 + 1;
            int S = (m - s1 * a) / s2;
            q = k = e = g = sum1 = sum2 = 0;
            p = t = 1;
            if(x <= 5) {
                if(x == 1 || x == 2) printf("%d", a);
                else if(x == 3)  printf("%d", a * 2);
                else if(x == 4) printf("%d", S + a * 2);
                else printf("%d", S * 2 + a * 3);
            }
            else {
                for(int i = 1; i <= x - 4; i++) {
                    k = p + q;
                    sum1 += k;
                    p = q;
                    q = k;
                }
                sum1 += 2;
                for(int i = 1; i <= x - 4; i++) {
                    g = e + t;
                    sum2 += g;
                    e = t;
                    t = g;
                }
                sum2 += 1;
                printf("%d", sum1 * a + sum2 * S);
            }
        }
        return 0;
    } 
```
~~不给代码感觉还是不太好？~~$orz$

不知道大家看到这里是否清晰呢？不清楚可以评论，代码还有待优化，欢迎大家提出意见~

本人在文末最后声明一次：代码中加入问号**本意是希望大家多思考**，最后已经给出完整代码（**2019年更新**），本人已经删除最初版源码，有任何其他问题可以**直接私信**。

**辛苦管理再次审核一下了……**



最后声明：禁止抄袭本题解
------------

第一篇题解，虽然写的不好，但看我这么辛苦，不**点个赞**再走吗？

---

## 作者：Jack2015633 (赞：206)

### 希望读此题解的人更注重题目的思路而非代码本身
## 严禁抄袭题解！

虽然题目看上去不太常规，但由于这道题目给出了车站上下车人数的关系，可以按照题意，手动模拟一波。（~~看上去像一道数学题？~~）

由于第二站上下车的人数是不确定的，我们可以设一个变量（比如y）来表示。这样就得到了下表：

[![eqw0Wd.png](https://s2.ax1x.com/2019/08/09/eqw0Wd.png)](https://imgchr.com/i/eqw0Wd)

i：站数  
+：该站上车人数  
--：该站下车人数  
Δ：该站人数变化量  
num[i]：从该站**开出**时车上的人数  
( **注意！！！** 题目要求的 **不！是！到达**该站时的人数 而 **是！ 开出**时的人数)


------------

#### 重点来了！
观察表格中第二行当i=2以及i=3时，y的系数均为1。由题意，后面上车人数为前两次上车人数之和。  
因此，随着i逐渐增大，y的系数的排列为斐波那契数列 (Fibonacci series)（i>=3）。 
同理，我们也能发现第二行a的的系数的排列也符合该规律（i>=4）。

继续观察，我们还能发现第三行，第四行中a,y的系数也符合类似的规律。

如果把斐波那契数列的第i项记作f[i]，我们可以总结出当 i=n-1 或 i=x 时, +,--,Δ 的值：( n>=5,x>=4 )

[![eq0iTO.png](https://s2.ax1x.com/2019/08/09/eq0iTO.png)](https://imgchr.com/i/eq0iTO)

 当 i>=4 时，车从站台开出时的人数 num[i] 可以用 2*a+每一次的变化量Δ之和 表示。

即  
[![eqGSyD.gif](https://s2.ax1x.com/2019/08/09/eqGSyD.gif)](https://imgchr.com/i/eqGSyD)(*) 

[![eqGpOe.gif](https://s2.ax1x.com/2019/08/09/eqGpOe.gif)](https://imgchr.com/i/eqGpOe)(1)



------------
至此，我们已经把题目中四个已知量中的三个都用上了，并且设了一个未知量y来表示题目要求的解 num[x] 。 
接下来要做的便是建立等量关系，求解y。

还有一个没有用到的已知量：m。m表示第n站下车的人数。考虑到终点站人必须下车，因此m也为第n-1站时从车站**开出**时车上的人数，即  

[![eqUyLT.gif](https://s2.ax1x.com/2019/08/09/eqUyLT.gif)](https://imgchr.com/i/eqUyLT) (2)


------------

将(1),(2)联立，解得：  

[![eqanXV.gif](https://s2.ax1x.com/2019/08/09/eqanXV.gif)](https://imgchr.com/i/eqanXV)

将y带回

[![eqGSyD.gif](https://s2.ax1x.com/2019/08/09/eqGSyD.gif)](https://imgchr.com/i/eqGSyD)(*)

即可。

代码实现时，用数组 sum[ ] 记录 f[ ] 的前缀和。

另外，i<=3 时需要程序特判。


------------


精简代码如下：
```cpp
#include <iostream>
using namespace std;
int a,n,m,x,ans;
int f[20],sum[20];
int main()
{
	cin>>a>>n>>m>>x;
	ans=a;
	if(x>=3)
		ans+=a;//特判
	if(x>=4)
	{
		f[1]=f[2]=1;	
		for(int i=3;i<=n-4;i++)
			f[i]=f[i-1]+f[i-2];//求斐波那契数列
		for(int i=1;i<=n-4;i++)
			sum[i]=sum[i-1]+f[i];//求前缀和
		int y=(m-sum[n-5]*a-ans)/sum[n-4];//用推出的公式求y
		ans+=sum[x-4]*a+sum[x-3]*y; //将答案加回
	}
	cout<<ans<<endl;
	return 0;
}
```
PS: 如果觉得此题解有帮助，请帮忙点个赞，谢谢！


---

## 作者：昊蒻 (赞：92)

这是我作为蒟蒻的第一个题解

p1011车站

一个21年的老题

相信大家一定看过表格推得的题解

而对于我这种~~暴力~~的博主

一定要用一种暴力的方法

对于本题的数据范围，暴力应该很好解决


------------
首先应该想到的是，本题第二站上下车人数对于结果来说至关重要，所以应该从求得第二站上车（或下车）的人数入手，由于我比较懒，所以直接就把每一个站上下车人数都顺带求出来了，这里我们设第二站上车人数为i

所以本题解题的关键是一个字：“**试**”

由于第二站上下车人数无上限，所以应该用死循环，然后利用我们一个一个“试”出来的数向后推到n-1站

因为最后一站下车人数即为倒数第二站发车时剩余人数，所以当第n-1站发车时，如果人数恰好等于m，此时的i就“试”出来了



------------
上代码
```cpp
#include<iostream>
using namespace std;
int ans,a,n,m,x,ren,sh[21],xia[21];
int main()
{
	cin>>a>>n>>m>>x;
	for(int i=0;;i++)
	{
		for(int k=1;k<=n;k++)
		{
			sh[k]=0;
			xia[k]=0;
		}
		sh[1]=a;
		ren=a;
		sh[2]=i;
		xia[2]=i;
		for(int j=3;j<=n-1;j++)
		{
			xia[j]+=sh[j-1];
			sh[j]+=sh[j-1]+sh[j-2];
			ren+=sh[j]-xia[j];
			if(ren>m)
			break; 
		}
		if(ren==m)
		break;
	}
	ans=a;
	for(int k=3;k<=x;k++)
	{
		ans+=sh[k]-xia[k];
	}
	cout<<ans;
 } 
```
看完是不是感觉数论都不用学了？

程序不就是为了解决反复反复的问题嘛！

# 觉得好点个赞鼓励一下新人哦！


---

## 作者：Hecarm7 (赞：73)

第一眼看以为可以方程解 后来发现似乎似乎似乎不可以解方程......
好了 其实都看得出 这题是可以推公式的 斐波那契数列而已。

话不多说 以下是我的题目步骤 看一下就会懂，就先推六个吧。

注 a=初始上客数 b=第二站上客数。

|站台数N  |1  |2  |3  |4  |5  |6  |...  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 上客数 | a |b  | a+b |a+2b  |2a+3b  |3a+5b  |...  |
| 下客数|  0|  b|  b|a+b  |a+2b  |2a+3b  |...  |
|  总数|  a|(b)-(b)+a=a|(a+b)~~-(b)+(b)~~-(b)+a=2a  |(a+2b)~~-(a+b)+(a+b)-(b)+(b)~~-(b)+a=2a+b  | (2a+3b)~~-(a+2b)+(a+2b)-(a+b)+(a+b)-(b)+(b)~~-(b)+a=3a+2b | (3a+5b)~~-(2a+3b)+(2a+3b)-(a+2b)+(a+2b)-(a+b)+(a+b)-(b)+(b)~~-(b)+a=4a+4b |  ...|

好了 这样可见 当N>=2时  总数m=当前上客数-第二站上客数+初始上课数。

在n=1 另做 其他通过公式 求出b的值 再套入其中 便可求出。

辣鸡代码 大佬别喷


```pascal
var
 a1,b1,i,j,n,m,k,t,max:longint;
 a,b:array[1..25] of longint;
begin
  read(a1,n,m,k);
  a[1]:=1;
  a[2]:=0;
  b[1]:=0;
  b[2]:=1;//初始化
  for i:=3 to n do
   begin
   a[i]:=a[i-1]+a[i-2];
   b[i]:=b[i-1]+b[i-2];//建造表格
   end;
  if n=1 then 
         begin
         write(m);//n=1时特别注意
         exit;
         end;
  b1:=(m-(a[n-1]+1)*a1) div (b[n-1]-1);//最后一个下车数为前一个车站的总人数
  write((a[k]+1)*a1+(b[k]-1)*b1);
end.
```

---

## 作者：朱江黄河 (赞：65)

/******************************************************************

数学思考题

看下面的表

 $\ \ \ \ \ \ \ \ \ \ |\ 1\ |\ 2\ |\ \ \ \ 3\ \ \ \ |\ \ \ \ 4\ \ \ \ \  |$
上车人数$|\ n\ |\ b\ |n+b\ |n+2b|$
下车人数$|\ 0\ |\ b\ \ |\ \ \ \ b\ \ \ \ | \ n+b\ |$
车上人数$|\ n\ |\ n\ |\ \ 2n\ \ \ |2n+b  |$

可以推出第i站上车人数为f[i-2]n+f[i-1]b (i>=2)

下车人数为f[i-3]n+f[i-2]b (i>=3)

车上人数为f[i-2]n+n+f[i-1]b-b（i>=2)

最后一站下车人数就=倒数第二站车上人数带入可解得b

再带入公式解得第x站车上人数 注：x=1时要特判

******************************************************************/

```cpp
#include<cstdio>
int f[25]={0,1};
int main(){
    int n,a,m,x,b;scanf("%d%d%d%d",&a,&n,&m,&x);
    for(int i=2;i<n;i++)f[i]=f[i-1]+f[i-2];
    b=(m-f[n-3]*a-a)/(f[n-2]-1);
    if(x==1)printf("%d",a);
    else printf("%d",(f[x-2]+1)*a+(f[x-1]-1)*b);
    return 0;
}
```

---

## 作者：ykuouzf (赞：36)

# 一道小学生都会做的数学题。。。
## 看了几篇题解，感觉写得都有点长啊，其实远没那么麻烦。
## 没抓住此题的精髓——
首先我们可以把上下车的人数列一个表格，把第二站上车的人数设为b：
| 车站 | 第一站 | 第二站 | 第三站 | 第四站 | 第五站 | 第六站 | 第七站 | 第八站 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 上车 | a | b | a+b | a+2b | 2a+3b | 3a+5b | 5a+8b | …… |
| 下车 | 0 | b | b | a+b | a+2b | 2a+3b | 3a+5b | …… |
1，1，2，3，5，8……
 
发现了什么？
 
### 不就是斐波那契数列吗？

那么我们就可以求出一个站上上车的人数（分别有几个a和b）

由于第一站和第二站a没有连续增加，从第三站才开始连续加，所以一个站上上车的a的系数就是f[第几站-2]。

由于b从第二站就开始连续加了，所以一个站上上车的b的系数就是f[第几站-1];

所以一个站上上车的人数就是f[第几站-2]*a+f[第几站-1]*b;

通过观察表格可知，每一站上还有的人，除这一站上车的人，第一站上车的a人和第二站下车的b人，其余都可以消掉。（自己去看看就知道了）所以在每个站上还有的人数就是：(f[第几站-2]+1)*a+([第几站-1]-1)*b

m实质上就是上一站还有的人，最关键的方程就列出来了：

### m=f[n-1-2]*a+f[n-1-1]*b+a-b

化简得：

### b=(m-(f[n-3]+1)*a)/(f[n-2]-1)

再把算出来的b带到第x站就行啦！代码很简洁：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,n,m,x,b,f[20];
int main(){
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1]=1;
    for(int _=2;_<=n-1;f[_]=f[_-1]+f[_-2],_++);
    b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
    cout<<(f[x-2]+1)*a+(f[x-1]-1)*b<<endl;
    return 0;
}
```

---

## 作者：揽月摘星辰 (赞：10)

  1. 引言： 显而易见的，这是一道和斐波那契数列有关的数论题。对于大多数提高组oier的正常状态来说，此题应该是可以轻易的a掉。但天有不测风云，人总有状态不好的时候。在考场上，如果你突然脑袋短路，找不到其中的规律，那么必然会惊慌失措，方寸大乱。从而使你愈发难以想出正解。即使你跳过了此题，不甘与惶恐也将把你攻陷。所以，我们为了预防这种情况，就需要找到一种稳定而好想的解题方法。
  

------------
  1. 转入正题，此题最好想的解法无疑是模拟。题目要问我们车上的人数，我们就模拟这个公交的行进过程。即使用up数组表示上车人数，down数组表示下车人数。而up[j]=up[j-1]+up[j-2]，down[j]=up[j-1]，也是题目上就告诉我们的。
  1. 但我们现在还面对这一个问题，我们并不知道第二站上车人数，所以无法求出第x站车上人数。但我们观察题面，发现他给了我们最后一站车上的人数。顿时，如何求第二站上车人数的方法也能脱口而出————枚举！我们可以枚举第二站上车的人数，在递推到最后一站，看是否满足。
  1. 因此，我们得到了第二站上车人数，第x站也可以顺利成章的推出了。
  

------------
代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int up[100],down[100],a,n,m,x,i,j,ans;
int main()
{
	cin>>a>>n>>m>>x;
	up[1]=a;
	for(i=0;i<=m;i++)//枚举，注意第二站可能上0个人
	{
		up[2]=i;
		ans=a;
		for(j=3;j<=n-1;j++)  //推断是否满足条件
		{
			up[j]=up[j-1]+up[j-2];
			down[j]=up[j-1];
			ans+=up[j]-down[j];
		}
		if(ans==m){
			ans=a;
			for(j=3;j<=x;j++)  //推出答案
			{
				ans+=up[j]-down[j];
			}
			cout<<ans;
			return 0;
		}
	}
}
```

------------
ALL IN ALL：
因为这题的数据并不大，且不算强，我们用这个方法可以ac掉。而考场上肯定不会有这么好的运气。但是它山之石可以攻玉，我们可以在考场上模拟出答案，在通过答案寻找规律，这样比起自己苦想要简单不少。与此同时，在有了这份暴力分的保障，我们的心态也能更加从容。


------------
ALL IN ALL IN ALL:祝各位oier rp++，考出好成绩

------------
本人刚入提高蒟蒻，代码或思路如有问题，欢迎指出。



---

## 作者：学委 (赞：6)

下面这种方法是偏方，思维上严重比不过众位巨佬的斐波那契数列算法，但这正是它的优点……

鉴于本题的数据规模很小，然而想要求出“第二站上下车到底有多少人”需要一些计算。于是我懒得算，决定让程序强行凑出这个数字。无脑打模拟：

```cpp
#include<bits/stdc++.h>
using namespace std;

int t[1001];
int tot;

int main()
{
	int a, n, m, x, ans;
	scanf("%d %d %d %d", &a, &n, &m, &x);
    
	for(int i = 0; i <= 10001; i++)
	{
		//假设第2站上车人数为i，看看是否满足”最后一站下车人数为m“ 
		//既然数据规模小，可把i的上限开得大一点 
        
		memset(t, 0, sizeof(t));
		t[1] = a;//t[j]为第j站的上车人数，即可表示第j+1站的下车人数 
		t[2] = i;
		tot = a;//在第2站开出时的总人数为a 
        
		for(int j = 3; j <= n-1; j++)//一站一站往下走 
		{
			t[j] = t[j-1] + t[j-2];//本站上车人数为前两站上车人数之和 
			tot += t[j];//人们上车 
			tot -= t[j-1];//本站下车人数为上一站上车人数t[j-1] 
		}
        
		if(tot == m)
		{//凑到了 
			ans = i;//ans记录第二站的真正上车人数 
			break;
		}
	}
    
	if(tot != m){//这里是检验，看看到底有没有满足条件的i，当然题目中都有 
		printf("FALSE!\n");
		return 0;
	}	
    
	//下面重新走一次，到指定站 
	memset(t, 0, sizeof(t));
	t[1] = a;
	t[2] = ans;
	tot = a;
	for(int j = 3; j <= x; j++)
	{
		t[j] = t[j-1] + t[j-2];
		tot += t[j];
		tot -= t[j-1];
	}
	printf("%d\n", tot);
	return 0;
}
```



---

## 作者：诗乃 (赞：5)

设第二站上车b人,f[i]为每站上车人数

依题意得

>f[1]=a
>f[2]=b
>f[3]=1b+a
>f[4]=2b+a
>f[5]=3b+2a
>f[6]=5b+3a
>……

可以发现a,b系数为斐波那契数列

设fibo[]为斐波那契数列

fibo[]={1,1,2,3,5,8,13,21,34……}

则第i站上车人数(i>2)为


f[i]=fibo[i-1]\*b+fibo[i-2]\*a;

∵下车人数=上一站上车人数

∴中间的上下车不必模拟，没有意义，可以忽略

再者，终点站没有人上车

不难得出

m=f[n-1]+a-b

上一站上车+起始站人数-第二站上车的人数=最后下车的人数


然后求出b就好啦!

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
int main()
{
    int a,b,n,m,x,fibo[21]={0};
    scanf("%d%d%d%d",&a,&n,&m,&x);
    fibo[0]=0;fibo[1]=1;
    for(int i=2;i<=n;i++)
        fibo[i]=fibo[i-1]+fibo[i-2];
    //f[n-1]=fibo[n-2]*b+fibo[n-3]*a
    //m=fibo[n-2]*b+fibo[n-3]*a+a-b
    //m=(fibo[n-2]-1)*b+(fibo[n-3]+1)*a
    b=(m-(fibo[n-3]+1)*a)/(fibo[n-2]-1);
    printf("%d",(fibo[x-1]-1)*b+(fibo[x-2]+1)*a);
}
```

---

## 作者：曹老师 (赞：3)

**~~好多斐波那契数列！！！~~**

数据规模不大，直接**暴力模拟**就可以

刚开始的时候以为 m 是一个没有用的量

**其实不然！！！**

因为题目中说 第二站上车和下车的人数相等

但是你并不知道上了多少人 下了多少人

因为 第二站的人数关系到后面的答案

所以 我直接用**work函数**模拟了一遍来求 **第二站上了多少人**

然后 再跑一遍模拟 就跑出答案来了 

具体还会在代码中注释

# 程序代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue> 
#define MAXN 10005
#define LL long long
#define MOD 100000007
using namespace std;
int a,n,m,x,b[25],c[25]; // b数组：总人数 c数组：上了多少人 
int work(int x) //求第二站上了多少人 
{
    int bb[25],cc[25];
    bb[1]=a;bb[2]=a;cc[1]=a; // bb cc 数组为临时的b c数组 与b c数组功能相同 
    cc[2]=x;
    for(int i=3;i<n;i++)
    {
        bb[i]=bb[i-1]+cc[i-2];
        cc[i]=cc[i-2]+cc[i-1];
    }
    if(bb[n-1]==m)
        return 1;
    return 0;
}
int main()
{
    scanf("%d%d%d%d",&a,&n,&m,&x);
    b[1]=a;b[2]=a;c[1]=a;
    for(int i=0;;i++) // i 其实可以有循环的右边界 不过不会死循环 
        if(work(i)==1)
        {
            c[2]=i;
            break;
        }
    if(x==m)// 特判一下 不知道有没有用 
    {
        printf("0");
        return 0;
    }
    if(x==1||x==2) // 特判一下 
    {
        printf("%d",a);
        return 0;
    }
    for(int i=3;i<n;i++) // 模拟部分 
    {
        b[i]=b[i-1]+c[i-2];
        c[i]=c[i-2]+c[i-1];
    }
    printf("%d",b[x]);
    return 0;
}
```

---

## 作者：QwQ_operator (赞：3)

话说这道题真心挺恶心，现推的时候还是挺麻烦的。。。

来吧，看下面表格。。。

在这个地方我们规定在第二站上车的人数为t。f[]为斐波那契数列前几项。

站点标号      上车人数    下车人数             车上人数       变化人数

1    a    0    a    a

2    t            a    a    0

3       a+t    t           2a    a

4                   a+2t             a+t    2a+t    t

5    2a+3t    a+2t    3a+2t    a+t

6    3a+5t    2a+3t    4a+4t    a+2t

7    5a+8t    3a+5t    6a+7t    2a+3t

8    0    6a+7t    0    4a+4t

通过看上面的表格有没有发现一个规律？？

在站点上车人数满足f[n-2]\*a+f[n-1]\*t;

通过观察整个过程，你还会哦发现这样一个关系：最后一站的人数m+第二站上车的人数等于倒数第二站上车的人数+第一站的人数。

即：m+t=f[n-1-2]\*a+f[n-1-1]\*t+a;

通过这个关系我们可以很快的求出t的值，这样在第x站上车的人数等于：f[x-2]\*a+f[x-1]\*t;

在车上的人数等于：（f[x-2]）\*a+（f[x-1]+1）\*t


代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 1001
using namespace std;
int a,n,m,x,t,f[N];
int main()
{
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1]=1;f[2]=1;
    for(int i=3;i<=n;i++)
     f[i]=f[i-1]+f[i-2];
    t=(m-(f[n-3]+1)*a)/(f[n-2]-1);
    printf("%d",(f[x-2]+1)*a+(f[x-1]-1)*t);
    return 0;
}

```

---

## 作者：chenkaixing (赞：3)

大家都可以发现这个问题和斐波那契数列有关（当我废话）；【以下多余文字请自动省略】

那么问题是如何简单解决的呢？【抄袭某位da lao的】

我们需要一个简单的模拟，也就是我们已经知道这个斐波那契数列有多少项了，也知道初值是多少，现在只要求出第二站上车的人是多少就可以知道答案了

1   k   1+k   2\*k+1   3\*k+2...这是每次上车的人数，然后我们需要知道的是最后一次的b的系数，然后就可以知道b是多少了，然后题目让我们求的是x站时车上还剩下多少人

下面我用的是s,u两个核心数组（好像很NB de 词汇），先解释一下，不然有点难堪

==============================================================

```cpp
  1  2  3  4  5...//这是站数
u:1  0  1  1  2...//这个是存第一次上站的人数在后面每次上车人数中占的系数比
   0  1  1  2  3...//这个是存第二次上站的人数在后面每次上车人数中占的系数比
==============================================================
```
1  2  3  4  5...
s:1  1...

0  0...

//用来存当前车上还有多少人，因为每次都有下车的（好烦），而且分别是第一次和第二次上车人数占的比例

【这个比例就是系数的意思，因为一开始是a我用1简化一下，需要运算的时候再乘一下就行了】

（下面是我的code，请欣赏，简单暴力，为了防止某些人强迫症，我分割线打得很整齐）

==============================================================

```cpp
program station;
var
      s,u:array[1..20,1..2]of longint;
      i,j,n,m,a,x,k:longint;
begin
      //assign(input,'station.in');reset(input);
      read(a,n,m,x);
      s[1,1]:=1;s[2,1]:=1;//此处需赋初值，至少两个站
      u[1,1]:=1;u[2,2]:=1; 
      for i:=3 to n do
      begin
            u[i,1]:=u[i-1,1]+u[i-2,1];//典型的斐波那契数列
            u[i,2]:=u[i-1,2]+u[i-2,2];
            s[i,1]:=u[i-2,1]+s[i-1,1];//不同于直接求和，大家可以想一下，为什么这么加，有助于帮你理清思路
            s[i,2]:=u[i-2,2]+s[i-1,2];
      end;
      k:=(m-s[n-1,1]*a)div s[n-1,2];//把第一次上车的人系数a给它乘上，然后就可以求上面所说的b了
      write(s[x,1]*a+s[x,2]*k);//由于我有这个数组，可以直接算出结果了（舒服）【>~<】
end.

```

---

## 作者：yubing_lml (赞：2)

NO.19 一道斐波那契数列的应用题，外带解一元一次方程组~

上车下车的规则给得很清楚，一开始做的时候搞不懂13是怎么来的，再次读题发现，第二次上车的人数不一定是a，我当成a了，所以就没有算对。。。

推倒可以发现，每一站上车的人数只和上车的人数有关，第i站上车的人数等于第[i-2]站上车的的人数。最后得到的一元一次方程组的形式如下：

n*a+c*x=m;（第n-1站时车上的人数等于最后一站n下车的人数）

其中，n是a出现的次数，x是第二次上车的未知人数的系数，我们要求出x就可以得到最后的结果~（PS：这个x并非题目中给的x）

### 主要思路：

分别用aa和xx两个数组记录每站上车的人数中a和x出现的次数，由推导可知，这两个数组均满足斐波那契数列。

注意记录要求的站的人数值（for循环中实现~）


其余的大家看代码就好啦~
```cpp
#include<iostream>
using namespace std;

int a, n, m, x;
int aa[20],xx[20];

int main()
{
	cin >> a >> n >> m >> x;
	aa[1] = a; aa[2] = 0;
	xx[1] = 0; xx[2] = 1;
	if (x == 1 || x == 2)
	{
		cout << a;
		return 0;
	}
	int bus = a; int cc = 0, ans1, ans2;
	for (int i = 3; i < n; i++)
	{
		aa[i] = aa[i - 1] + aa[i - 2];
		xx[i] = xx[i - 1] + xx[i - 2];
		bus += aa[i - 2];
		cc += xx[i - 2];
		if (i == x)
		{
			ans1 = bus;
			ans2 = cc;
		}
	}
	int tmp = (m - bus) / cc;
	int rst = ans1 + ans2 * tmp;
	cout << rst;
	return 0;
}
```

---

## 作者：仁和_童博扬 (赞：2)

这题可采用斐波那契数列的方法做，下面的dalao们都已经讲得非常非常清楚了，我这种初二的蒟蒻也只好发一篇**纯模拟**的题解了。

【题外话】我一开始提交时只有50分。在调试过程中，我发现第1个数据（输入：1 6 7 4 输出：4）的第二站上车、下车人数为2人，但数据告诉我第二站未到达前人数只有1人。这就意味着有一个人在第二站时有人上车后马上下车，但哪有人会刚上车就下车啊！我作为一个蒟蒻无法解释这一问题。。。也许是题目本身就不符合常规吧。。。

这道题的其它题解（除了打表）的时间复杂度均为O(n)，而我代码的时间复杂度是:

50分代码：O(an) 

100分代码：O(20n)近似于O(n)

其实纯模拟时间复杂度也不高啦~~~

我的模拟代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[21][3];//第i站上车f[i][0]人，下车f[i][1]人,还剩f[i][2]人 
int main()
{
    int a, n, m, x;
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1][0] = a;
    f[1][1] = 0;
    f[1][2] = a;
    for(int i = 0; i <= 20; i++)//枚举第二站上下车人数
    //50分的代码中，这个for循环为
    //for(int i = 0; i <= a; i++)
    {
        f[2][0] = i;
        f[2][1] = i;
        f[2][2] = a; 
        //printf("第2站:上车%d人，下车%d人,还剩%d人\n",f[2][0],f[2][1],f[2][2]);//可供调试
        for(int j = 3; j < n; j++)//从3开始模拟上下车过程
        {
            f[j][0] = f[j-1][0] + f[j-2][0];
            f[j][1] = f[j-1][0];
            f[j][2] = f[j-1][2] + f[j][0] - f[j][1];
            //printf("第%d站:上车%d人，下车%d人,还剩%d人\n",j,f[j][0],f[j][1],f[j][2]);//可供调试
        }
        if(f[n-1][2] == m)
        {
            printf("%d\n",f[x][2]);
            return 0;
        }
    }
    printf("Impossble!");//这句话可省略
    return 0;
}
```

其实也可以进一步优化空间复杂度（虽然数据规模较小）

使用3个变量降低数据维度到1维。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[21];//第 i站还剩f[i]人 
int in_now = 0, in_last = 0, out = 0;
int main()
{
	int a, n, m, x;
	scanf("%d%d%d%d",&a,&n,&m,&x);
	in_last = a;
	out = 0;
	f[1] = a;
	for(int i = 0; i <= 20; i++)
	{
		in_last = a;//这句话很重要，保证in_last不会被上个过程影响 
		in_now = i;
		out = i;
		f[2] = a; 
		//printf("第2站:上车%d人，下车%d人,还剩%d人\n",in_now,out,f[2]);
		for(int j = 3; j < n; j++)
		{
			out = in_now; //这里的in_now为上次的上车人数 
			in_now = in_now + in_last;
			in_last = out;
			//f[j][0] = f[j-1][0] + f[j-2][0];
			//f[j][1] = f[j-1][0];
			f[j] = f[j-1] + in_now - out;
			//f[j][2] = f[j-1][2] + f[j][0] - f[j][1];
			//printf("第%d站:上车%d人，下车%d人,还剩%d人\n",j,in_now,out,f[j]);
		}
		if(f[n-1] == m)
		{
			printf("%d\n",f[x]);
			return 0;
		}
	}
	return 0;
}
```

也许我的代码有问题，欢迎指正！

---

## 作者：封禁用户 (赞：2)

这题原是堂堂noip，而洛谷却给出一堆那么水的数据，我也是醉了

我用的也是递推，但是我总觉得我的递推和dalao们有些不同，于是就写了这篇题解

我们假设第二站上来的人数是x人，一直往下推：

第一站上了a人，车上剩a人

第二站上了x人，下了x人，车上剩a人

第三站上了a+x人，下了x人，车上剩2a人

第四站上了2x+a人，下了a+x人，车上剩2a+x人

第五站上了3x+2a人，下了2x+a人，车上剩3a+x人

以此类推

这是一个表：

车上人数-------车上人数------下车人数

1a+0x-----------0x+1a---------1x+0a

1a+0x-----------0x+1a---------1x+0a

2a+0x-----------1a+1x---------1x+0a

2a+1x-----------2x+1a---------1a+1x

3a+2x-----------3x+2a---------2x+1a

1a+4x-----------5x+3a---------3x+2a

6a+7x-----------8x+5a---------5x+3a

9a+12x---------13x+8a-------- 8x+5a

14a+20x-------21x+13a-------13x+8a

22a+33x-------34x+21a-------21x+13a

35a+54x-------55x+34a-------34x+21a

56a+88x-------89x+65a-------55x+34a

于是我们很容易发现

在某一站中剩的人数是t1[i]\*a+t2[i]\*x（t1[i]，t2[i]为自然数）

而t1[i]从第四站开始就有了规律，及t1[i]=t1[i-1]+t1[i-2]-1;

而t2[i]则是t2[i]=t2[i-1]+t2[i-2]+1;

所以，很明显当总站数或询问站数小于等于3时都需要特判，

而打出上面的表后，很容易就可以找到要输出的内容，这里不明确说明

而实现主要是先算出题目给出的总站数的两个系数t1，t2，然后用(m-t1\*a)/t2这条算式算出x

而如果算出小数，说明不可行，输出"No answer."。

而如果可行，则再循环一次，算出询问站数的系数t1，t2，最后直接用t1\*a+t2\*x就是结果了

注意，如果询问站数是最后一站，直接输出0，因为题目已明确表明在最后一站中人会下光；

还有，为了防止有人照套题解给出算式，我故意让某些变量重叠，请管理员们不要见怪。

由于洛谷的反作弊系统已经完善，我放心地给出代码，不给解释：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
long long a,n,x,t1,t2,s1,s2,tt,ss;
double t,m;
int main()
{
    cin>>a>>n>>m>>x;
    if (n==x) {cout<<0<<endl;return 0;}
    if (x<=2||n<=3) {cout<<a<<endl;return 0;}
    if (x==3) {cout<<a*2<<endl;return 0;}
    t1=1;t2=2;s1=s2=0;
    for (int i=4;i<=n-1;i++)
    {    
        tt=t1;t1=t2;
        t2=tt+t2-1;    
        ss=s1;s1=s2;
        s2=ss+s2+1;    
    }    
    t=(m-t2*a)/s2;
    if (trunc(t)<t) {cout<<"No answer.";return 0;}
    t1=1;t2=2;s1=s2=0;
    for (int i=4;i<=x;i++)
    {    
        tt=t1;t1=t2;
        t2=tt+t2-1;    
        ss=s1;s1=s2;
        s2=ss+s2+1;    
    }    
    cout<<t2*a+s2*t;
    return 0;
}
```

---

## 作者：圣光天子 (赞：1)

设第二站上车人数为t，第一站a人，那么模拟一下过程就可以得到：

第3站：2a

第4站：2a+t

。。。。。。（根据题意模拟）

然后就可以得到 一个方程。。。。。

比如到第5站时是3a+2t

然后根据题目给的最终站人数解方程求t

然后就可以直接求第x站的人了！！

代码如下：

···var

```cpp
  inin,up:array[1..20] of record al,x:longint; end;
  i,j,n,m,k,a,xl:longint;
begin
  readln(a,n,m,k);
  inin[1].al:=1; up[1].al:=1; inin[2].al:=1; up[2].x:=1;
  for i:=3 to n do begin
    up[i].al:=up[i-1].al+up[i-2].al;
    up[i].x:=up[i-1].x+up[i-2].x;
    inin[i].al:=up[i-2].al+inin[i-1].al;
    inin[i].x:=up[i-2].x+inin[i-1].x;
  end;
  m:=m-inin[n-1].al*a;
  xl:=m div inin[n-1].x;
  writeln(inin[k].al*a+inin[k].x*xl);
end.···
```

---

## 作者：lcx64579 (赞：1)

暴力枚举第二站上车人数即可。数据太弱所以这么就过了，看了题解突然觉得我能这么过好幸运2333




```cpp
#include<iostream>
using namespace std;
int a, n, m, x, ans;
int ontrain[21], geton[21], getdown[21];
int main(){
    cin>>a>>n>>m>>x;
    geton[1] = a;
    ontrain[1] = a;
    for(int i=0; ; i++){    //注意这里第二站也可能一个人也不上车！ 之前从1枚举导致第三个点TLE了
        geton[2] = i;
        getdown[2] = i;
        for(int j=2; j<=n-1; j++){
            ontrain[j] = ontrain[j-1]+geton[j]-getdown[j];
            geton[j+1] = geton[j]+geton[j-1];
            getdown[j+1] = geton[j];
        }
        if(ontrain[n-1]==m) break;
    }
    cout<<ontrain[x]<<endl;
    return 0;
}
```

---


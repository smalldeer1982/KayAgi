# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# 题解

## 作者：樱雪喵 (赞：677)

upd on 2020/06/12：修改了部分解释不够清楚和有歧义的地方。  
upd on 2022/07/21：添加了 Latex。 


#### 前置知识

- 最大公约数（即 $\gcd$） 和最小公倍数（即 $\operatorname{lcm}$）的求法。



该题的关键点在于，**两个数的积等于它们最大公约数和它们最小公倍数的积**。公式表示为 $a\times b=\gcd(a,b) \times \operatorname{lcm}(a,b) $。设作为答案的两个数为 $x$ 和 $y$，我们要使它们同时满足以下三个条件，并统计这样的 $x$ 和 $y$ 的个数（$P,Q$ 含义见题目描述）：

- $x \times y=P \times Q$
- $\gcd(x,y)=P$
- $\operatorname{lcm}(x,y)=Q$

我们可以枚举 $x$，判断是否存在满足条件 $1$ 的整数 $y$（即，$x$ 能否被 $P,Q$ 的积整除）。满足第一个条件后，再分别判断当前的 $x,y$ 是否能够同时满足另外两个条件即可。显然，这种做法会超时。

考虑优化这个程序。我们其实并不需要枚举两次，因为对于不同的 $x,y$ ，交换它们的值一定可以得到另一组与之对应的解。因此，从 $1$ 到 $\sqrt{P\times Q}$ 枚举一遍，每发现一组答案就将 $ans$ 的值加上 $2$ 即可。

一组 $x,y$ 有对应解时有条件：$x,y$ 的值不同。如果它们相同，交换后并不能得到与之对应的另一组数。当 $x=y$ 时，易得 $x=y=\gcd(x,y)=\operatorname{lcm}(x,y)$。
所以要对此进行特判，若 $P,Q$ 相等，这种情况就存在， $ans$ 里要减去 $1$。

**一些代码实现技巧：**

- c++ 里有一个自带的求 $\gcd$ 的函数叫 `__gcd` 。upd：现在 NOIP 已经可以使用了。

- 当积相同且 $\gcd$ 相同时，$\operatorname{lcm}$ 也一定相同，因此只需判断是否满足一、二两个条件即可。

AC 代码：（应该是目前最短的）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,ans;
int main(){
	cin>>m>>n;
	if(m==n) ans--;
	n*=m;//把两数的积存入n中 
	for(long long i=1;i<=sqrt(n);i++){
		if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
	}
	cout<<ans;
	return 0;
}
```

**评论区常见问题统一回答：**

Q：$\gcd$ 是什么？  
A：是“最大公约数”的缩写。同理，$\operatorname{lcm}$ 是“最小公倍数”的缩写。

Q：代码中为什么枚举到 $\sqrt{n}$？  
A：前文提到，我们要避免重复，因此循环时只算 $x\le y$ 的情况。当 $x=y$ 时，$x=\sqrt{n}$。再使 $x$ 变大就会使 $x>y$ 了，计算会重复。




---

## 作者：sochiji (赞：259)

*去数学专业蹭过课的软件工程专业的蒟蒻大学生来谈谈自己的见解。*  
*尽量避免生搬公式符号，多使用通俗的语言来说明。*

## 符号约定
我们使用$(a,b)$表示$a,b$这两个数的最大公因数，使用$[a,b]$表示$a,b$这两个数的最小公倍数。

我们使用$a\mid b$表示$a$能整除$b$，或者说$b$能被$a$整除；  
我们使用$a\nmid b$表示$a$不能整除$b$，或者说$b$不能被$a$整除。

---

## 算术基本定理 
任何大于1的整数都可以被分解成若干个素数的幂的乘积，且不计素因子的排列顺序时分解方法是唯一的。
>例：$720=2^4\cdot 3^2\cdot 5^1$

上面的操作叫做**素因数分解**。若将素因子从小到大排列，就得到了**标准素数分解式**。

---

## 最大公因数和最小公倍数与素数分解式有什么联系呢？

举个例子：  
我们尝试分解样例中的提到的一组数$12,15$：  
$12=2^2\cdot 3^1,\quad 15=3^1\cdot 5^1$

为了方便下面的讨论，尽管$12$没有素因子$5$，$15$没有素因子$2$，但我们还是要把**非共有的素因子**写成$0$次幂的形式：  
$12=2^2\cdot 3^1\cdot 5^0,\quad 15=2^0\cdot 3^1\cdot 5^1$

将两个数素数分解式中每个素因子的**指数部分**取两个中的**最小值**，就得到了两个数的**最大公因数**：  
$(12,15)=2^0\cdot 3^1\cdot 5^0=3$

将两个数素数分解式中每个素因子的**指数部分**取两个中的**最大值**，就得到了两个数的**最小公倍数**：  
$[12,15]=2^2\cdot 3^1\cdot 5^1=60$

倒着推我们可以发现，要使$(P,Q)=3$且$[P,Q]=60$，$P,Q$这两个数的素数分解式必须满足下面3个条件：
>素因子$2$的指数的最大值为$2$，最小值为$0$.$\quad \Rightarrow$ 其中一个素数分解式中$2$的指数为$2$，而另一个为$0$；

>素因子$5$的指数的最大值为$1$，最小值为$0$.$\quad \Rightarrow$ 其中一个素数分解式中$5$的指数为$1$，而另一个为$0$；

>素因子$3$的指数的最大值为$1$，最小值为$1$.$\quad \Rightarrow$ 两个素数分解式中$3$的指数均为$1$；

像$2$和$5$这样的，指数在$x_0,y_0$的素数分解式中不同的素因子，能导致$P,Q$可变；而像$3$这样的，指数在$x_0,y_0$的素数分解式中相同的素因子，在$P,Q$中的指数一定是相同的，没法变化。

---

## 计算方法
### 如何快捷地寻找$x_0,y_0$的指数不同的素因子呢？  
对$\dfrac{y_0}{x_0}$进行素因数分解，得到的**指数大于0的素因子**即是导致$P,Q$可变的素因子。  
我们只需要统计这样的素因子的数量，就像把每种素因子看成不同的球，要放进$P,Q$这两个不同的袋子里，每一种素因子都有**放进**$P$和**放进**$Q$这两种选择。  
假设$\dfrac{y_0}{x_0}$的指数大于0的素因子有$n$个，那么就能产生$2^n$对$P,Q$的组合。

### 如果$x_0$不能整除$y_0$呢？

这表明不存在符合条件的$P,Q$.  
**反证**：  
不妨假设存在符合条件的$P\in\mathbb Z_+$，  
使得：$x_0$是$P$的因数，那么将有$x_0\mid P$；  
使得：$y_0$是$P$的倍数，那么将有$P\mid y_0$；  
根据整除的传递性，有$x_0\mid y_0$；  
这个结论与题设矛盾，故假设不成立。

于是当$x_0\nmid y_0$时，我们输出`0`作为答案。

---

## C++代码
```cpp
#include <iostream>
int main()
{
    int x, y;
    std::cin >> x >> y;
    if (y % x != 0)
        std::cout << 0;
    else
    {
        int quotient = y / x;
        int count = 0;        //统计素因数的个数
        int currentFactor = 2; //用来试验整除性的因数
        while (quotient > 1) //等于1时标志着分解完毕
        {
            if (quotient % currentFactor == 0)
            {
                count++;
                while (quotient % currentFactor == 0)
                    quotient /= currentFactor;//若能整除就除到底
            }
            currentFactor++;
        }
        std::cout << (1 << count);//使用位运算来产生2的方幂
    }
    return 0;
}
```

## 谢谢阅读。


顺便宣传一波自己的经常挖坑不填的[知乎专栏](https://zhuanlan.zhihu.com/p/74477008)。

---

## 作者：zhangboju (赞：61)

本文符号简述（大佬自行跳过）：

$d|a$ : $a \% d =0$

$a \in Z$ a为整数

$a \in N^* $ a为自然数

$\lfloor a \rfloor$ a向下取整

$gcd(a,b)$  $a$ , $b$的最大公约数

首先，这题暴力枚举是肯定会TLE的

那么我们用什么方法呢？

辗转相除法求gcd！


有定理：

由 $ d|a$ 并且 $ d|b $    $ (d,a,b \in N^* ) $

可得 $ d|(xa + yb)$  $ (x,y \in Z)$


证明如下：

可设$xa=xk_1  d$  , $yb=yk_2d$ $ (k_1,k_2 \in N ^ * ) $

$\because xk_1d+yk_2d=(xk_1+yk_2)d$

$\therefore xa +yb=(xk_1+yk_2)d$

$\because d|(xk_1+yk_2)d$

$\therefore d|(xa+yb)$

得证。

那么怎样求$gcd$呢？

又有定理：

$$ gcd(a,b)=gcd(b,a \% b) (a,b \in N^* ) $$ 

证明如下：

若想证明上式，则需证明：

>①.$a$ 和 $b$ 的任一约数都是 $b$ 和 $a \% b$ 的约数

>②.$b$ 和 $a \% b$ 的任一约数都是 $a$ 和 $b$ 的约数


设 $a$ 和 $b$  的一个约数为 $c$

则 $c |a $ $\&$ $c|b $

设 $\lfloor \frac{a}{b} \rfloor = k$

则$a \% b=a-bk$

$\because $ $c |a $ $\&$ $c|b $

$\therefore c | (a-bk)$ 即 $c|(a\%b)$

①.得证

同理可证②.

则定理得证。

那么，求$gcd$就只需要递归求解，当当前$a$ , $b$满足 $b|a$ 时，$gcd(a,b)=b$ , 否则 $gcd(a,b)=gcd(b,a\%b)$

实现：

```cpp
inline int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
```

那么问题来了，这只是最大公约数，那最小公倍数呢？

又有定理：

>两个数最大公约数与最小公倍数的乘积即为这两个数的乘积

证明：

设两个数为$x$ , $y$ , $gcd(x,y)=a$ , 最小公倍数为 $b$

设$x=p_1a$ , $y=p_2a$ ，由 $gcd$ 的定义可知：$p_1$ 与 $p_2$互质

$\therefore$ 这互质的两数 $p_1$ , $p_2$ 最小公倍数为 $p_1p_2$

$\because \frac{xy}{a}=\frac{p_1* a * p_2* a}{a}=p_1p_2a$

$\therefore$ $\frac{xy}{a}$ 是 $x$ 的倍数，$\frac{xy}{a}$ 是 $y$ 的倍数

那么我说：$p_1p_2a=b$

假设 $p_1p_2a\not=b$ ：

$\because$ $p_1p_2a$ 一定是 $x,y$ 的公倍数

$\therefore p_1p_2a>b$

则分两种情况讨论：

1. 若有更大的 $p_1p_2$ 满足条件 ，则此时 $a$ 不取最大值
，矛盾

2. 若有更大的 $a$ 满足条件 ，矛盾

综上：$p_1p_2a=\frac{xy}{a}=b$

$\therefore xy=ab$

定理得证

那么此题算法也就清楚了。

枚举xy的所有因数 $1 \sim \sqrt {xy}$,如果满足 $gcd(i,\frac{xy}{i})=x$ , 则答案加上1。最后答案$\times2$即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y;
inline int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
int main()
{
	cin>>x>>y;
	int ans=0;
	for(int i=1;i<=sqrt(x*y);i++)
	{
		if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
	}
	cout<<ans*2;
	return 0;
}
```

然后你发现错了一个点。

其实如果 $\sqrt{xy}$ 满足条件的话，我们会重复计算。

此时， $x=y$

$AC$ $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y;
inline int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
int main()
{
	cin>>x>>y;
	int ans=0;
	for(int i=1;i<=sqrt(x*y);i++)
	{
		if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
	}
	ans*=2;
  	if(x==y) ans--;
   	cout<<ans;
	return 0;
}
```

其实还有一点不完美，就是 $x \times y$ 有可能会爆 $int$ , 所以改用 $long$ $long$

```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y;
inline long long gcd(long long x,long long y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
int main()
{
	cin>>x>>y;
	long long ans=0;
	for(long long i=1;i<=sqrt(x*y);i++)
	{
		if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
	}
	ans*=2;
  	if(x==y) ans--;
   	cout<<ans;
	return 0;
}
```

$P.S:$ 为什么要写这么多呢？ 因为别的题解都没有数学证明啊

---

## 作者：getchar_unlocked (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1029)

### 思路

已知对于任何 $2$ 个数 $P$ 和 $Q$，都满足 $\gcd(P,Q)\times\operatorname{lcm}(P,Q)=P\times Q$。基于这一点，可以从 $1$ 枚举到 $x_0\times y_0$，统计 $x_0\times y_0$ 有多少个质因数即可。

然而这样做会超时。又发现对于两质因子为 $P$ 和 $Q$ 的情况，一定也会出现两质因子为 $Q$ 和 $P$ 的情况。于是可以只枚举到 $\sqrt{x_0\times y_0}$，并将统计出的结果乘 $2$。注意需要判断 $x_0\times y_0$ 是否是完全平方数，若是，就将答案减 $1$，因为自身统计了 $2$ 遍。

**注意事项**

- 不要以 `y0` 作为变量名。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}

signed main(){
	int n=read(),m=read(),cnt=0;
	bool flag=false;
	for(int i=1;i*i<=n*m;++i)
		if(n*m%i==0&&__gcd(i,n*m/i)==n){
			++cnt;
			if(i*i==n*m)
				flag=true;
		}
	printf("%lld\n",cnt*2-flag);
	return 0;
}
```

---

## 作者：kunkun127 (赞：1)

## 题意

题目给定两个正整数 $ x $ 和 $ y $，要求找到所有满足以下条件的正整数对 $ (a, b) $：

1. $ \gcd(a, b) = x $
2. $ \text{lcm}(a, b) = y $

其中，$ \gcd(a, b) $ 表示 $ a $ 和 $ b $ 的最大公约数，$ \text{lcm}(a, b) $ 表示 $ a $ 和 $ b $ 的最小公倍数。

## 思路

首先，我们需要理解最大公约数和最小公倍数之间的关系。对于任意两个正整数 $ a $ 和 $ b $，有以下关系式：

$$
\gcd(a, b) \times \text{lcm}(a, b) = a \times b
$$

根据题目条件，$ \gcd(a, b) = x $ 且 $ \text{lcm}(a, b) = y $，因此可以得到：

$$
x \times y = a \times b
$$

也就是说，$ a \times b = x \times y $。我们可以将 $ a $ 和 $ b $ 表示为：

$$
a = x \times k, \quad b = x \times m
$$

其中 $ k $ 和 $ m $ 是互质的正整数（即 $ \gcd(k, m) = 1 $），因为 $ \gcd(a, b) = x $。

将 $ a $ 和 $ b $ 代入 $ a \times b = x \times y $，得到：

$$
(x \times k) \times (x \times m) = x \times y \implies x^2 \times k \times m = x \times y \implies k \times m = \frac{y}{x}
$$

因此，我们需要找到所有满足 $ k \times m = \frac{y}{x} $ 且 $ \gcd(k, m) = 1 $ 的正整数对 $ (k, m) $。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll gcd(ll x, ll y)
{
    if (y == 0)
    {
        return x;
    }
    return gcd(y, x % y);
}

int main()
{
    ll x, y, cnt = 0;
    cin >> x >> y;
    ll t = x * y;
    for (ll i = 1; i <= sqrt(t); i++)
    {
        if (t % i == 0 && gcd(i, t / i) == x)
        {
            cnt += 2;
            if (i * i == t) cnt--;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：1)

## 题目大意
给定 $x_0, y_0$，求有序数对 $(P, Q)$ 使得 $(P, Q) = x_0, [P, Q] = y_0$ 的数量。

## 思路
首先一看到这是一道有关于 $\gcd$ 和 $\operatorname{lcm}$（即最大公约数和最小公倍数）的问题，就简单地把欧几里得算法（即辗转相除（减）法）浅讲一下吧。

#### 欧几里得算法
其实这就是一个很简单的港式大家记住就行：
$$
 (a,b) = (b, a - b)  (a > b)
$$
那么我们把这个操作进行很多很多次，直到其中一个为 $0$，那么我们就得到这样一个形式 $(a,b) = (0, k) = k$，也就得出了 $(a,b)$ 的值。

#### 小结论
下面是一个再次体重要用到的结论：
$$
(a,b) \times [a,b] = ab
$$

随手证明一下吧。我们设：
$$
a=p_1^{\alpha_1}p_2^{\alpha_2}\dots p_n^{\alpha_n}
$$

$$
b=p_1^{\beta_1}p_2^{\beta_2}\dots p_n^{\beta_n}
$$

这里，$p_1,p_2\dots p_n$ 为 $a, b$ 的所有的不同质因数。

由于
$$
(a,b)=\prod_{i=1}^{n} p_i^{\min(\alpha_i,\beta_i)}
$$

$$
[a,b]=\prod_{i=1}^{n} p_i^{\max(\alpha_i,\beta_i)}
$$

代入到左式
$$
(a,b) \times [a,b]=\prod_{i=1}^{n} p_i^{\alpha_i+\beta_i} = ab
$$

得证。

-----
接下来，我们正式开始做这道题。

首先，题目给出了 $x_0, y_0$，那么我们根据这个，就可以求出 $P\times Q$ 的值，接下来，对于每一组 $(P, Q)$，检验 $(P, Q)$ 是否等于 $x_0$，若成立，即可将其计入正确组数。

考虑优化。

由于对于每一组 $(a, b)$ 满足题意（即 $ab = PQ, (a,b) = x_0$，那么 $(b,a)$ 也应当满足题意。所以我们只需枚举到 $\sqrt{PQ}$，并检验 $a$ 的正确性，假若正确，我们就能将这两组均计入可行方案。（建议不要直接讲循环的终止条件改为 `i <= sqrt(n)`，而是 `i * i <= n`，这样精度会好些）

再者，有一些数据会使得 $P=Q$，那就没有上述交换的必要，所以只能加上一组。

## 代码

接下来就是代码咯


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll gcd(ll a, ll b) {return b == 0 ? a : gcd(b, a % b);}
ll lcm(ll a, ll b) {return a * b / gcd(a, b);}

int main() {
    ll x, y, ans;
    cin >> x >> y; x *= y;
    for(ll i = 1; i * i <= x; i++) {
        if(!(x % i)) {
            ll a = i, b = x/i;
            if(lcm(a, b) == y) {
                if(a != b) ans++;
                ans++;
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：陈嘉逸2012 (赞：1)

~~有点难，听了课才会。~~
## 题意简述
给定正整数 $x,y$，求满足 $\gcd(P,Q)=x,\operatorname{lcm}(P,Q)=y$ 的正整数 $P,Q$ 个数。
## 思路
由题意可得 $\operatorname{lcm}(x, y)=\gcd(x,y)$，所以 $xy=\gcd(x,y) \times \operatorname{lcm}(x,y)=PQ$。

直接枚举 $P,Q$ 复杂度太高，$\Theta(x^2y^2)$，显然会超时。

仔细观察上面的式子，你会发现这本质上是在对 $x,y$ 做因式分解，所以我们从 $1\sim\sqrt{xy}$ 枚举 $P$。
* 如果 $Q=\frac{xy}{P}$ 是整数，且 $\gcd(P,Q)=x$，这样就是一种答案。
* 如果 $P \neq Q$，$Q,P$ 也是一种答案，要特判 $P=Q$ 的情况。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,ans;
int main(){
	cin>>x>>y;
	for(long long p=1;p*p<=x*y;p++){
		if(x*y%p) continue;
		long long q=x*y/p;
		if(__gcd(p,q)!=x) continue;
		ans+=2-(p==q);
	}
	cout<<ans;
}
```
时间复杂度 $\Theta(\sqrt{xy})$。

---

## 作者：sybs1145 (赞：1)

# [[NOIP 2001 普及组] 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029) 题解

## 前置芝士

最大公约数 $\gcd$，这里提供一种参考写法（当然你也可以用内置函数`__gcd()`）：

```cpp
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
```

以及最小公倍数 $\operatorname{lcm}$（当然本题也可以不求 $\operatorname{lcm}$，后面会说到）：

```cpp
int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
    //这里先除再乘是好习惯，避免溢出
}
```

## 思路

本题我们可以利用关于最大公约数与最小公倍数的小小的性质，即：

$$
\gcd(a,b)\times \operatorname{lcm}(a,b)=a\times b
$$

所以，对于任意一组合法的 $p,q$，一定有 $xy=pq$。

然后我们就可以枚举 $xy$ 的因数，判断其是否符合题目所给条件。

### Tips
- 在枚举的时候只需要枚举到 $\sqrt{xy}$ 就行，对于每组合法数据，计算两次答案即可。
- 对于 $x=y$ 的情况，在计算答案时会有重复，最后的答案是 $ans-1$。

## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int x, y, n, ans;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
}
int main()
{
    ios::sync_with_stdio(0);
    cin >> x >> y;
    n = x * y; //用n来记录x与y的积
    for (int i = 1; i <= __builtin_sqrt(n); i++)
    /*
        __builtin_sqrt()与sqrt()功能相同，只不过速度更快,
        直接使用sqrt()也能通过本题
    */
        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y)
            ans += 2;
    if (x == y) //去重
        ans--;
    cout << ans << '\n';
    return 0;
}
```
当然这段代码还可以优化，因为在乘积相等且最大公约数符合条件，最小公倍数也一定符合条件，所以我们可以省略第三个条件的判断，以下是简化版代码。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int x, y, n, ans;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int main()
{
    ios::sync_with_stdio(0);
    cin >> x >> y;
    n = x * y;
    for (int i = 1; i <= __builtin_sqrt(n); i++)
        if (n % i == 0 && gcd(i, n / i) == x)
            ans += 2;
    if (x == y)
        ans--;
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：zjinyi (赞：1)

# P1029 最大公约数和最小公倍数问题 题解

## 题面
输入两个正整数 $x_0, y_0$，求以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数的正整数 $P, Q$ 的个数。（NOIP 2001 普及组第二题）

## 思路
### 数学分析
如果 $P, Q$ 以 $x_0$ 为最大公约数，那么它们各除以 $x_0$ 后一定互素，否则 $\gcd(P, Q)$ 将会大于 $x_0$。

我们就可以设 $P = mx_0, Q = nx_0, \gcd(m, n) = 1$。

![短除法](https://cdn.luogu.com.cn/upload/image_hosting/ipd6ij4s.png)

由图片中的短除法，我们就可以得出 $mn \cdot x_0 = y_0, mn = \dfrac{y_0}{x_0}$。

于是，我们枚举 $\dfrac{y_0}{x_0}$ 的因数 $n, m$，如果 $\gcd(n, m) = 1$，答案变量增加。 

### 相关例题
**已知 $\gcd(x, y) = 6, xy = 288$，求：$x, y$。**

---

由 $\gcd(x, y) = 6$，设 $x = 6m, y = 6n, \gcd(m, n) = 1$。

由 $xy = 288$，得 $6m \cdot 6n = 288, mn = 8$。

由 $\gcd(m, n) = 1$，得 $\begin{cases}
m = 1, 8\\
n = 8, 1\\
\end{cases}$。

由 $x = 6m, y = 6n$，得 $\begin{cases}
x = 6, 48\\
y = 48, 6\\
\end{cases}$。

## 代码
在测试点 4 中，输入为 `12 4096`，$4096$ 不能被 $12$ 整除，所以不存在满足要求的 $P, Q$。我们要在代码中写一个特判，当 $y_0$ 不能被 $x_0$ 整除时，输出 `0`。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int x, y;
    cin >> x >> y; // 输入
    if (y % x > 0) // 特判
    {
    	cout << 0;
    	return 0;
	}
    int num = y / x, cnt = 0;
    for (int i = 1; i <= num; ++i) // 枚举 y / x 的因数
    {
        if (num % i == 0 && num % (num / i) == 0)
        {
            if (__gcd(i, num / i) == 1) // 判断 n, m 是否互素
            {
                cnt += 1; // 计数
            }
        }
        
    }
    cout << cnt; // 输出答案
    return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
由题目可知，这题是关于最大公约数与最小公倍数的。

那么，我们就要先写出最大公约数的代码，可以直接用：
```cpp
__gcd(x, y);
```
这样的方式。

但是更好的是，手写递归版的：
```cpp
int gcd(int x, int y) {
	if (y == 0) return x; 
	return gcd(y, x % y);
}
```
那么，接下来就要循环从 $x_0$ 至 $y_0$。如果 $x_0 \times y_0$ 除以 $i$ 的余数为零，并且 $i$ 与 $x_0 \times y_0 \div i$ 的最大公约数等于 $x_0$，那么，计数器加一，说明我们找到了一组满足条件的数了。最后输出计数器即可。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int x, y, ans = 0;

int gcd(int x, int y) {
	if (y == 0) return x; 
	return gcd(y, x % y);
}

int main() {
	cin >> x >> y;
	for (int i = x; i <= y; i++) {
		if (x * y % i == 0 && gcd(i, x * y / i) == x) ans++;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：fyn1234 (赞：0)

### 思路

因为两个数的积等于它们最大公约数和它们最小公倍数的积，即：

$P \times Q = x_0 \times y_0$

$\gcd(P,Q) = x_0$

$\operatorname{lcm}(P,Q) = y_0$

从 $1$ 到 $\sqrt[]{x_0 \times y_0}$ 枚举 $P$，逐个判断有没有满足第一个条件的 $Q$，再带着 $P$ 和 $Q$ 判断一下能不能满足后面的两个条件。（注意：对于 $P$ 和 $Q$ 两个数不同的情况，交换这两个数也一定能得到另一组解）

**注：**

- 可以使用 C++ 自带的函数 `__gcd()` 来求最大公倍数 $\gcd$。

- 如果 $P = Q$，易得 $P = Q = \gcd(P,Q) = \operatorname{lcm}(P,Q)$，只有一种情况，但是这种情况只有在 $x_0 = y_0$ 时会出现，所以特判一下就好了。

### solution

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,ans;
int main(){
	cin>>x>>y;
	if(x==y) ans--;
	y*=x;
	for(int i=1;i<=sqrt(y);i++){
		if(y%i==0&&__gcd(i,y/i)==x) ans+=2;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zhouchuer (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P1029)
### 前置知识
对于两个数 $x,y$，可以证明 $\operatorname{lcm}(x,y) \cdot \gcd(x,y)=x \cdot y$。$\gcd$ 和 $\operatorname{lcm}$ 分别表示最大公因数和最小公倍数。[证明过程](https://www.zhihu.com/question/326472814/answer/697927617)。

### 思路
不难发现，我们可以枚举 $x$ 的值，根据两数乘积等于最大公因数乘以最小公倍数，可以算出 $y$，但是大部分情况都是不符合的，必须同时满足 $\gcd(x,y)=P$ 和 $\operatorname{lcm(x,y)}=Q$ 才能取，分支语句判断即可。需要注意的是，遍历到符合的值将 $ans$ 加 $2$ 可以避免重复遍历。

因为上面遍历到一组就将答案加 $2$，所以遍历 $i$ 至 $\sqrt{n}$ 即停（$n=P \cdot Q$），这种做法可节省时间复杂度。

最大公因数可以用辗转相除法求，不过我还是推荐使用 C++ 自带的 `__gcd` 函数。

### 代码
为了题解观感更好放在[知乎专栏](https://zhuanlan.zhihu.com/p/23472516743)。

---


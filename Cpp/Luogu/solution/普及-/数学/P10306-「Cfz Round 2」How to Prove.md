# 「Cfz Round 2」How to Prove

## 题目描述

给定一个正整数 $n$。

我们定义，对于一个集合 $S$，$\Omega(S)$ 为集合 $S$ 的所有的 **非空子集的元素和** 所组成的集合。

形式化地，$\Omega(S)=\{x\mid x=\sum\limits_{i\in T}i,T\subseteq S,T\neq \varnothing\}$。

例如，当 $S=\{2,0,-3,5\}$ 时，$\Omega(S)=\{-3,-1,0,2,4,5,7\}$。

你需要构造一个大小为 $n$ 的集合 $S$，满足：

- 集合 $S$ 中的所有元素均为不大于 $10^9$ 且不小于 $-10^9$ 的整数；
- $|\Omega(S)|$ 最小，即 $\Omega(S)$ 所包含的元素个数最少。

## 说明/提示

#### 「样例解释 #1」

对于第 $1$ 组数据，$S=\{3\}$，$\Omega(S)=\{3\}$。当然，$\{0\}$、$\{-2\}$ 等也为满足条件的集合 $S$。

对于第 $2$ 组数据，$S=\{0,5\}$，$\Omega(S)=\{0,5\}$。

对于第 $3$ 组数据，$S=\{2,0,-2,4\}$，$\Omega(S)=\{-2,0,2,4,6\}$。

可以证明以上构造均满足条件。

#### 「数据范围」

设 $\sum n$ 表示单个测试点中 $n$ 的和。

对于所有数据，$1 \le T \le 100$，$1 \le n \le 10^6$，$\sum n \le 10^6$。

**只有你通过本题的所有测试点，你才能获得本题的分数。**

## 样例 #1

### 输入

```
3
1
2
4```

### 输出

```
3
0 5
2 0 -2 4```

# 题解

## 作者：s4CRIF1CbUbbL3AtIAly (赞：9)

题意：$\Omega(S)$ 为集合 $S$ 的所有**非空子集的元素和**所组成的集合，构造使得 $|\Omega(S)|$ 最小的 $S$。

观察样例并不能得到什么很好的结果，因此开始手动构造。

简单构造一会发现对于大小为 $n$ 的集合，最优的情况大概就是 $-\frac n2\sim\frac n2$ 所有整数。当然这里可以统一缩放。

众所周知想要证明一个东西的最小值就是先找到一个下界满足所有可能值都不会小于它，之后给出一个值为下界的构造。现在我们猜测这个情况就是下界，考虑证明。

首先我们注意到 $0$ 非常厉害，它可以使集合增加一个元素并且不影响答案。于是接下来的证明分成两部分。

## 1. 如果集合中不含 $0$

假设这个集合中的元素为 $a_1<a_2<\dots<a_k<0<a_{k+1}<a_{k+2}<\dots<a_n$。

于是，我们发现下面这个巨大的式子：

$$
\begin{aligned}
0>&a_k>a_{k-1}>\dots>a_1\\
>&a_1+a_k>a_1+a_{k-1}>\dots>a_1+a_2\\
>&a_1+a_2+a_k>a_1+a_2+a_{k-1}>\dots>a_1+a_2+a_3\\
\vdots\\
>&a_1+a_2+\dots+a_k
\end{aligned}
$$

其中，第一行有 $k$ 个数（不包括 $0$），第二行有 $k-1$ 个数，最后一行有 $1$ 个数。

因此，至少有 $k+(k-1)+\dots+1=\frac{k(k+1)}2$ 种不同的**负**结果。

同理，至少有 $\frac{(n-k)(n-k+1)}2$ 种不同的**正**结果。

因此答案至少为 $\frac{k(k+1)+(n-k)(n-k+1)}2=\frac{2k^2+n^2-2nk+n}2$。

容易发现在 $k$ 取 $\lfloor \frac n2\rfloor$ 或 $\lceil\frac n2\rceil$ 时答案最小。

## 2. 如果集合中含 $0$

假设这个集合中元素为 $a_1<a_2<\dots<a_{k-1}<a_k=0<a_{k+1}<a_{k+2}<\dots<a_n$。

类似于上面的情况，至少有 $\frac{k(k-1)}2$ 种**负**结果和 $\frac{(n-k)(n-k+1)}2$ 种**正**结果，以及 $0$。

于是答案为 $\frac{k(k-1)+(n-k)(n-k+1)}2+1=\frac{2k^2-2k+n^2-2nk+n}2+1$。

此时 $k=\lfloor\frac{n+1}2\rfloor$ 或 $\lceil\frac{n+1}2\rceil$ 时答案最小。

比较上下两个式子，容易发现不含 $0$ 比含 $0$ 大了 $k-1$，而根据题目条件以及最小取值 $k$ 至少为 $1$，因此含 $0$ 比不含 $0$ 要更不劣。

这样我们不仅证明完了含 $0$ 更不劣，也顺便证明出了理论的最小值。

构造上面已经说过了，证明时也说明了取最小值的情况。

```cpp
int n;
cin>>n;
for(int i=1;i<=n;i++)cout<<(i&1?-i/2:i/2)<<" ";
cout<<"\n";
```

---

## 作者：ggylz49 (赞：6)

## 题意剖析
本题的精华在于理解题意。

题目说的很隐晦，只是说 $\Omega(S)$ 为集合 $S$ 的所有的 **非空子集的元素和** 所组成的集合，让我们让 $Ω(S)$ 集合中包含的元素个数最少。然而对于一个数 $n$，$n$ 个元素所组成的集合的子集个数应该是相同的（不同位置的元素组成的子集算独立的子集）。那么，怎么说“集合中包含的元素个数最少的子集呢”？

如果这个能想出来的话，本题就不难了。的确，如果要让元素个数尽量少，就要让相同的元素更多。举个例子。

>
> 对于集合 $\{2,3,4,8\}$，它是一个由 $4$ 个元素所组成的集合。这时，$\Omega(S)=\{2,3,4,5,6,7,8,9,10,11,12,13,15,17\}$，共有 $14$ 个元素；
>
> 然而对于集合 $\{-2,0,2,4\}$，它同样是由 $4$ 个元素所组成的集合。这时，$\Omega(S)=\{-2,0,2,4,6\}$，只有 $5$ 个元素。
>

为什么元素数量不同了呢？实际上，第二个集合的非空子集元素和的集合和第一个子集一样，也有 $14$ 个元素，分别是 $\{-2,-2,0,0,0,2,2,2,2,4,4,4,6,6\}$，只是不少的子集元素和重复了。

所以，解决本题的要点在于让重复的子集元素和更多。
## 思路点拨
那么，如何达成这个目的呢？

**相反数嘛！**
### 浅显解释：
其实，答案就是 $\{\ldots,-2x,-x,0,x,2x,\ldots\}$（$x$ 可以是任何自然数），这个集合如果将所有元素都取绝对值，它是大致对称的。这种集合有很多，例如 $\{-6,-4,-2,0,2,4\},\{-4,-2,0,2,4\},\{-4,-2,0,2,4,6\}$ 等。

可以发现，这是一个等差数列。为什么是这样呢？

- 首先，大部分的数都能找到一个数和它相加为 $0$。这点可以观察出。
- 这种数列最容易制造重复。任选几个数相加，它们的和依旧是 $x$ 的倍数，也就是上面集合中的数（某些数不在最终的 $S$ 中，但大部分都在）。

例如对于集合 $\{-3x,-2x,-x,0,x,2x\}$：
$$0+x=x,0+2x=2x,x+(-x)=0,-x+(-2x)=-3x,x+(-2x)=x \ \cdots$$

此处不再列举。当你明白这个道理时，你会发现：**这其实就是相反数！** 于是，这道题差不多就 over 了，实际实现所需的时间其实很少。
## Code
```cpp
#include <iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for (int i=1;i<=t;i++)
    {
        long n;
        cin>>n;
        //选取相邻两项差1的等差数列，不容易爆10的9次方
        long o=-1*(n/2);//负数个数是 n/2 （一半），最左边的数就乘上 -1
        for (int i=1;i<=n;i++)cout<<o<<' ',o++;//输出
        cout<<endl;//记得换行
    }
    return 0;
}
```
## 结语
- 做题记得带脑子，不然你做不出这题；
- 不明白多打草稿 ~~，不然你不能理解这篇题解~~；
- 做题要多试，说不定你的想法是对的。

---

## 作者：szh_AK_all (赞：3)

### 分析
既然我们要让 $\Omega(S)$ 中的元素尽可能少，不妨让 $S$ 的所有的非空子集的元素和所组成的**可重集合**中的相同元素尽可能多。

首先考虑让两个元素之和尽可能重复的构造方案。

很显然，我们将元素两两分组，最多会有 $\lfloor n\div 2 \rfloor$ 组两两元素之和相同。为了方便起见，可以让每组的元素都互为相反数。

那么在这种构造下，多个元素之和重复的数量也是最多的，我们可以将两两分组的元素合并成一个元素，那么合并的这些元素，便都为 $0$。所以这种构造是最优的。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			cout << ans << " ";
			if (ans == 0 || ans < 0)
				ans = -ans + 1;
			else
				ans = -ans;
		}
		cout << endl;
	}
}
```

---

## 作者：dlzlj_2010 (赞：2)

首先题目要求**使 $\Omega(S)$ 的元素最小**，而我们知道，集合是**不可重**的，那么问题其实就相当于使 $S$ 的子集的和**尽量重复**，为了方便，我们把这个和设为 $0$，那么我们就会自然地想到构造**几组相反数**。
## code:
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int T;
	cin>>T;
	while(T--){
		int n;
		bool f=0;//判断输出正数还是负数
		cin>>n;
		for(int i=1;i<=n;i++){
			if(f) cout<<-i/2<<" ";//负数
			else cout<<i/2<<" ";//正数
			f=!f;
		}
		cout<<endl;
	}
	return 0;
}
```

---


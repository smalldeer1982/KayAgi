# 「QFOI R2」寺秋山霭苍苍

## 题目背景

本题可能用到的公式：

两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\frac{a+b+c}{2}$，则三角形面积为 $S=\sqrt{p(p-a)(p-b)(p-c)}$。

## 题目描述

小 R 是一个可爱的女孩子，她的几何太差了，于是她向你求助这道几何题。

在平面直角坐标系中，有一个 $\triangle\textrm{ABC}$，其顶点坐标为 $\textrm{A}(x_1,y_1),\textrm{B}(x_2,y_2),\textrm{C}(x_3,y_3)$。

对于**实数** $p\in(0,1)$，在 $\textrm{BC},\textrm{CA},\textrm{AB}$ 边上分别取点 $\textrm{D},\textrm{E},\textrm{F}$，使得 $\frac{|\textrm{AF}|}{|\textrm{AB}|}=\frac{|\textrm{BD}|}{|\textrm{BC}|}=\frac{|\textrm{CE}|}{|\textrm{CA}|}=p$，则称 $\triangle\textrm{DEF}$ 为 $\triangle\textrm{ABC}$ 的“$p$ 比例三角形”。

请在 $[l,r]$ 范围内选择实数 $p$，使得 $\triangle\textrm{ABC}$ 的“$p$ 比例三角形”的面积最小。你需要求出这个面积。

## 说明/提示

**样例 $1$ 解释**

可以证明，当 $p=0.5$ 时面积最小，为 $2.5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/stzw0bwl.png)

---

**样例 $2$ 解释**

可以证明，当 $p=0.4$ 时面积最小，为 $2.8$。

![](https://cdn.luogu.com.cn/upload/image_hosting/hf4xj9tc.png)

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

你的输出被认为是正确的，当且仅当其与标准答案的绝对或相对误差不超过 $10^{-4}$。

---

**数据范围**

**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**

对于全部数据：$0 < l < r < 1$，$0\le x_1,y_1,x_2,y_2,x_3,y_3\le 10^5$，保证输入构成三角形，所有实数的小数点后位数不超过 $2$。

- 子任务一（$20$ 分）：$l=0.10,r=0.90$。
- 子任务二（$20$ 分）：$x_1=y_1=y_2=x_3=0.00$。
- 子任务三（$20$ 分）：$x_1=y_1=y_2=0.00$。依赖子任务二。
- 子任务四（$40$ 分）：无特殊限制。依赖子任务一、二、三。

---

**提示**

本题可能用到的公式：

两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\frac{a+b+c}{2}$，则三角形面积为 $S=\sqrt{p(p-a)(p-b)(p-c)}$。

## 样例 #1

### 输入

```
0.40 0.60 0.00 0.00 4.00 0.00 1.00 5.00```

### 输出

```
2.500000000000```

## 样例 #2

### 输入

```
0.20 0.40 0.00 0.00 4.00 0.00 1.00 5.00```

### 输出

```
2.800000000000```

# 题解

## 作者：rui_er (赞：18)

考查内容：

- 【1】代数（初中部分）。
- 【1】几何（初中部分）。
- 【3】平方根函数。

本文将介绍两种较为简单的方法。

**方法一**

容易由海伦公式计算出 $S_{\triangle\textrm{ABC}}$。

根据三角形面积公式 $S=\frac{1}{2}ah$，$\triangle\textrm{AFC}$ 与 $\triangle\textrm{ABC}$ 有相同的高，且底边长度之比 $\frac{|\textrm{AF}|}{|\textrm{AB}|}=p$，因此 $\frac{S_{\triangle\textrm{AFC}}}{S_{\triangle\textrm{ABC}}}=p$。同理，$\frac{S_{\triangle\textrm{AFE}}}{S_{\triangle\textrm{AFC}}}=1-p$，即得 $S_{\triangle\textrm{AFE}}=p(1-p)S_{\triangle\textrm{ABC}}$。同理可证 $S_{\triangle\textrm{AFE}}=S_{\triangle\textrm{FBD}}=S_{\triangle\textrm{EDC}}=p(1-p)S_{\triangle\textrm{ABC}}$。

用割补法可以得到 $S_{\triangle\textrm{DEF}}=S_{\triangle\textrm{ABC}}-3p(1-p)S_{\triangle\textrm{ABC}}$。至此，初中几何部分结束。

注意到 $S_{\triangle\textrm{DEF}}$ 是关于 $p$ 的开口向上的二次函数，对称轴为 $p=\frac{1}{2}$。因此，若 $l\le\frac{1}{2}\le r$，取 $p=\frac{1}{2}$ 最优；否则取 $p$ 为更靠近 $\frac{1}{2}$ 的区间端点最优。至此，初中代数部分结束。

```cpp
inline double calc(double S, double p) {
    return S - 3.0 * (S * p * (1.0 - p));
}

double l, r, x1, y1, x2, y2, x3, y3;
cin >> l >> r >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
double a = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
double b = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));
double c = sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));
double p = (a + b + c) * 0.5;
double S = sqrt(p * (p - a) * (p - b) * (p - c));
double k = 0.5;
k = min(k, r);
k = max(k, l);
cout << fixed << setprecision(12) << calc(S, k) << endl;
```

**方法二**

令 $p$ 以一定的精度遍历 $[l,r]$，也就是说枚举 $p=l+k\Delta p\le r$（$k$ 为非负整数），使用定比分点公式计算出 $\textrm{D},\textrm{E},\textrm{F}$ 的坐标，使用海伦公式计算出 $S_{\triangle\textrm{DEF}}$，再取得到的所有结果中最小的。

根据方法一中的证明，精度 $\Delta p$ 取 $0.01$ 就足以通过本题，取 $10^{-6}$ 等其他精度也可。

```cpp
const double eps = 1e-9;

inline double calc(double x1, double y1, double x2, double y2, double x3, double y3) {
    double a = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    double b = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));
    double c = sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));
    double p = (a + b + c) * 0.5;
    double S = sqrt(p * (p - a) * (p - b) * (p - c));
    return S;
}

double l, r, x1, y1, x2, y2, x3, y3;
cin >> l >> r >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
double S = 1e100;
for(double k = l; k <= r + eps; k += 0.01) {
    double x4 = x1 + (x2 - x1) * k;
    double y4 = y1 + (y2 - y1) * k;
    double x5 = x2 + (x3 - x2) * k;
    double y5 = y2 + (y3 - y2) * k;
    double x6 = x3 + (x1 - x3) * k;
    double y6 = y3 + (y1 - y3) * k;
    chkmin(S, calc(x4, y4, x5, y5, x6, y6));
}
cout << fixed << setprecision(12) << S << endl;
```

---

## 作者：MoonCake2011 (赞：1)

拿到题，先来看一下比例为 $p$ 时最后算出来的面积为多少。

两个公式。

```cpp
double dist(double a,double b,double c,double d){
	return sqrt((c-a)*(c-a)+(d-b)*(d-b));
}
double Helen(double x,double y,double z){
	double p=(x+y+z)/2;
	return sqrt(p*(p-x)*(p-y)*(p-z));
}
```
可以用相似三角形来算。

![](https://cdn.luogu.com.cn/upload/image_hosting/87liyjn9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以将小三角形中 $y,z$ 边长的边的公共点看作 $D,E,F$。

$A,B,C$ 就是 $py,pz$ 边长的边的公共点。

算出来是。
```cpp
double Dx=x+(x2-x)*p,Dy=y+(y2-y)*p;
double Ex=x2+(x3-x2)*p,Ey=y2+(y3-y2)*p;
double Fx=x3+(x-x3)*p,Fy=y3+(y-y3)*p;
double DE=dist(Dx,Dy,Ex,Ey);
double EF=dist(Ex,Ey,Fx,Fy);
double DF=dist(Dx,Dy,Fx,Fy);
cout<<Helen(DE,EF,DF)<<"\n";
```

$p$ 取 $0.5$ 时，根据中位线定理，面积为 `Helen(AB/2,BC/2,AC/2)`。

$p=0.5$ 变大或减少，都会使半周长更大（感性去想），也会使半周长与边长的差更大。

所以，面积也差不多会大。

这只是我的粗略理解，详细证明可以去看官方题解。

你还可以用低精度打表验证。

于是，取范围内最接近 $0.5$ 的数即可。

那只有三种取值 $0.5,l,r$。

分类即可。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
double l,r,x,y,x2,y2,x3,y3;
double dist(double a,double b,double c,double d){
	return sqrt((c-a)*(c-a)+(d-b)*(d-b));
}
double Helen(double x,double y,double z){
	double p=(x+y+z)/2;
	return sqrt(p*(p-x)*(p-y)*(p-z));
}
int main() {
	cin>>l>>r>>x>>y>>x2>>y2>>x3>>y3;
	if(l<=0.5 && 0.5<=r){
		double AB=dist(x,y,x2,y2);
		double BC=dist(x2,y2,x3,y3);
		double AC=dist(x,y,x3,y3);
		cout<<Helen(AB/2,BC/2,AC/2)<<"\n";
	}
	else if(l>0.5){
		double Dx=x+(x2-x)*l,Dy=y+(y2-y)*l;
		double Ex=x2+(x3-x2)*l,Ey=y2+(y3-y2)*l;
		double Fx=x3+(x-x3)*l,Fy=y3+(y-y3)*l;
		double DE=dist(Dx,Dy,Ex,Ey);
		double EF=dist(Ex,Ey,Fx,Fy);
		double DF=dist(Dx,Dy,Fx,Fy);
		cout<<Helen(DE,EF,DF)<<"\n";
	}
	else{
		double Dx=x+(x2-x)*r,Dy=y+(y2-y)*r;
		double Ex=x2+(x3-x2)*r,Ey=y2+(y3-y2)*r;
		double Fx=x3+(x-x3)*r,Fy=y3+(y-y3)*r;
		double DE=dist(Dx,Dy,Ex,Ey);
		double EF=dist(Ex,Ey,Fx,Fy);
		double DF=dist(Dx,Dy,Fx,Fy);
		cout<<Helen(DE,EF,DF)<<"\n";
	}
	return 0;
}

---

## 作者：Jadonyzx (赞：0)

方法一：模拟退火

```cpp
#include<bits/stdc++.h>
#define down 0.95
#define int double
using namespace std;
double x,y,xx,yy,xxx,yyy,ans,l,r,s,ansp;
double get(int Xx,int Yx,int XXx,int YYx){
	return 1.000*sqrt(1.000*(Xx-XXx)*(Xx-XXx)+1.000*(Yx-YYx)*(Yx-YYx));
}
double gets(int X,int Y,int XX,int YY,int XXX,int YYY){
	double l1,l2,l3,p;
	l1=get(X,Y,XX,YY);
	l2=get(X,Y,XXX,YYY);
	l3=get(XX,YY,XXX,YYY);
	p=(l1+l2+l3)*0.500000;
	return 1.000*sqrt(1.0000*p*(p-l1)*(p-l2)*(p-l3));
}
void sa(){
	double T=3000;
	while(T>1e-15){
		double sp=max(l,min(ansp+(2*rand()-RAND_MAX)*T,r));
		double reans=gets(x+sp*(xx-x),y+sp*(yy-y),xx+sp*(xxx-xx),yy+sp*(yyy-yy),xxx+sp*(x-xxx),yyy+sp*(y-yyy));
		if(reans<ans){
			ans=reans;
			ansp=sp;
		}
		else if(exp(-(reans-ans)/T)*RAND_MAX>rand()){
			ansp=sp;
		}
		T*=down;
	}
	return;
}
signed main(){
	cin>>l>>r>>x>>y>>xx>>yy>>xxx>>yyy;
	s=gets(x,y,xx,yy,xxx,yyy);
	ans=gets(x+ansp*(xx-x),y+ansp*(yy-y),xx+ansp*(xxx-xx),yy+ansp*(yyy-yy),xxx+ansp*(x-xxx),yyy+ansp*(y-yyy));
	for(int i=1;i<=100;++i)sa();
	cout<<ans;
	return 0;
}
```
方法二：正解

简单代数证明：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/7ub4tqkq.png)

连接 BE，可得 $\frac{S_{\bigtriangleup BEC}}{S_{\bigtriangleup ABC}} = 1-p$，$\frac{S_{\bigtriangleup DEC}}{S_{\bigtriangleup BEC}} = p$，$S_{\bigtriangleup DEC} = p\times(1-p)$，同理可得 $S_{\bigtriangleup AFE}$ 和 $S_{\bigtriangleup BDF}$,$S_{\bigtriangleup DEF} = S_{\bigtriangleup ABC}\times3\times p\times (1-p)$。

显然总面积已知的情况下是关于 $p$ 的二次函数，且在 $p=0.5$ 时取最小值，其他条件下由于函数图像开口向上，取离 $0.5$ 更近的点。

code：

```cpp
#include<bits/stdc++.h>
#define int double
using namespace std;
double x,y,xx,yy,xxx,yyy,ans,l,r,s;
double get(int Xx,int Yx,int XXx,int YYx){
	return 1.000*sqrt(1.000*(Xx-XXx)*(Xx-XXx)+1.000*(Yx-YYx)*(Yx-YYx));
}
double gets(int X,int Y,int XX,int YY,int XXX,int YYY){
	double l1,l2,l3,p;
	l1=get(X,Y,XX,YY);
	l2=get(X,Y,XXX,YYY);
	l3=get(XX,YY,XXX,YYY);
	p=(l1+l2+l3)*0.500000;
	return 1.000*sqrt(1.0000*p*(p-l1)*(p-l2)*(p-l3));
}
signed main(){
	cin>>l>>r>>x>>y>>xx>>yy>>xxx>>yyy;
	s=gets(x,y,xx,yy,xxx,yyy);
	if(0.5>=l&&0.5<=r)l=0.5;
	else if(r<0.5)l=r;
	ans=s;r=1.000-l;//cout<<l<<' '<<r<<'\n';
	ans=min(ans,gets(x+l*(xx-x),y+l*(yy-y),xx+l*(xxx-xx),yy+l*(yyy-yy),xxx+l*(x-xxx),yyy+l*(y-yyy)));
	cout<<ans;
	return 0;
}
```

---

## 作者：xingshuyan000 (赞：0)

[题目传送门：洛谷 P10410](https://www.luogu.com.cn/problem/P10410)

一道初中的几何题，但是我用了高中方法来做。

# 题目分析
### 题目解释
已知三角形三个顶点的坐标，且已知 $\large\frac{AF}{AB}=\frac{BD}{BC}=\frac{CE}{CA}=m$，且 $m\in \left[ l,r \right]$，$l,r$ 也已知，求 $DE,DF,EF$ 三边围成的三角形面积的最小值。（为了避免与海伦公式中三角形半周长的变量 $p$ 弄混，所以我在这里把题目中的 $p$ 改成了 $m$）


------------
### 引理

首先，我需要补充一个与解这道题有关的一个定理：余弦定理。

 _余弦定理一般是到高一下学期才学，所以这里仅作为补充，证明需要用到平面向量，故证明从略，直接给出结论。如果感兴趣的话可以去网上搜一下余弦定理的证明。_ 

余弦定理：**对于任意一个三角形，三角形中任意一边的平方，等于其他两边的平方和减去这两边与它们夹角的余弦的积的两倍。** 用符号表示为：

设三角形 $ABC$ 的三个角 $A,B,C$ 对应的三条边分别为 $a,b,c$，则

$a^2=b^2+c^2-2bc\cos A$，

$b^2=c^2+a^2-2ca\cos B$，

$c^2=a^2+b^2-2ab\cos C$。

由余弦定理，我们可以得到如下的推论：

$\cos A=$ $\Large\frac{b^2+c^2-a^2}{2bc}$，

$\cos B=$ $\Large\frac{c^2+a^2-b^2}{2ca}$，

$\cos C=$ $\Large\frac{a^2+b^2-c^2}{2ab}$。


------------
### 本题具体分析
#### 下面是求解三角形 $DEF$ 的面积的过程。

我们可以先画出来一个一般的三角形，进行分析。

![](https://cdn.luogu.com.cn/upload/image_hosting/1wv1ait2.png)

~~我画图能力不行，请见谅~~

现在这个三角形三个顶点的坐标都已知，也就说明三角形 $ABC$ 是一个完全确定的三角形，该三角形可解。

首先，可以通过两点间距离公式，求出来 $AB,AC,BC$ 的长度；

然后，用余弦定理的推论，在三角形 $ABC$ 中，求出 $A,B,C$ 的余弦值：

$\cos A=$ $\Large\frac{AB^2+AC^2-BC^2}{2AC\cdot AB}$，
   
$\cos B=$ $\Large\frac{AB^2+BC^2-AC^2}{2AB\cdot BC}$，
    
$\cos C=$ $\Large\frac{AC^2+BC^2-AB^2}{2AC\cdot BC}$；

接着，既然 $\large\frac{AF}{AB}=\frac{BD}{BC}=\frac{CE}{CA}=m$，那么 $AF,BD,CE$ 长度也能求，都等于 $m$ 乘上该线段所在三角形边的长度，从而 $AE,BF,CD$ 的长度也都能求出来；

第四步，在三角形 $AEF$ 中，用余弦定理求出 $EF$ 的长度：

$EF=\sqrt{AE^2+AF^2-2AE\cdot AF\cdot \cos A}$；

同理，也能求出来 $DE,DF$ 的长度；

第五步，在三角形 $DEF$ 中，因为三边长都已知，所以直接用海伦公式求解三角形的面积：

设 $△DEF$ 的面积为 $S$，三角形 $DEF$ 的半周长为 $p$，则

$p=$ $\Large\frac{DE+DF+EF}{2}$，

$S=\sqrt{p(p-DE)(p-DF)(p-EF)}$。

至此，三角形 $DEF$ 的面积求解完毕。


------------
#### 下面是求解三角形 $DEF$ 面积最小值的过程。

我们可以先定义一个 `double` 类型的变量 $mmin$，并让 $mmin$ 的初始值等于 $2\times 10^9$，让 $S$ 与 $mmin$ 打擂台，每次都取最小值，让 $mmin$ 等于它们的最小值。

既然 $m\in \left[l,r\right]$，$l,r\in\left(0,1\right)$，这道题又采用 `Special Judge`，只要与标准答案的绝对误差或相对误差不超过 $10^{-4}$ 都算对，那么我们可以让 $m$ 从 $l$ 开始循环，一直循环到 $r$，每次让 $m$ 加上 $10^{-6}$，每次都得出一个面积 $S$ 的值，与 $mmin$ 的大小进行比较，如果 $S<mmin$，则 $mmin=S$。等到循环结束，直接输出 $mmin$ 即可。

至此，三角形 $DEF$ 面积的最小值求解完毕，剩下的就是写程序求解了。

~~我这个思路的计算量特别大，但这毕竟还是计算机，计算量大这个问题不用担心哈哈哈 QwQ~~
 
# Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	double l,r,x1,y1,x2,y2,x3,y3;
	cin>>l>>r>>x1>>y1>>x2>>y2>>x3>>y3;
	double mmin=2e9,ab,ac,bc;
	ab=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));//要注意在编程里面，变量名一定要与前面声明的变量名完全一致，否则会编译错误
	ac=sqrt((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1));
	bc=sqrt((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2));
	double cosA,cosB,cosC;
	cosA=(ac*ac+ab*ab-bc*bc)*1.0/(2*ac*ab);
	cosB=(bc*bc+ab*ab-ac*ac)*1.0/(2*ab*bc);
	cosC=(ac*ac+bc*bc-ab*ab)*1.0/(2*ac*bc);
	double ae,ec,cd,db,af,fb;
	double de,df,ef,p,S;
	for(double i=l;i<=r;i+=0.000001)//这里的i相当于前面的m
	{
		ec=i*ac;
		ae=ac-ec;
		af=i*ab;
		fb=ab-af;
		db=i*bc;
		cd=bc-db;
		de=sqrt(ec*ec+cd*cd-2*ec*cd*cosC);
		df=sqrt(db*db+fb*fb-2*db*fb*cosB);
		ef=sqrt(ae*ae+af*af-2*ae*af*cosA);
		p=(de+df+ef)*1.0/2;
		S=sqrt(p*(p-de)*(p-df)*(p-ef));
		mmin=min(S,mmin);
	}
	printf("%0.6lf",mmin);//输出保留6位小数，肯定能过
	return 0;
}
```

---


# [NOIP 2012 普及组] 质因数分解

## 题目描述

已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。


## 说明/提示

$1 \le n\le 2\times 10^9$

NOIP 2012 普及组 第一题


## 样例 #1

### 输入

```
21```

### 输出

```
7```

# 题解

## 作者：Stephen_Curry (赞：6199)

这题真的不难，只不过数据点有点坑，因此要多多留意（小心！！！）

大多数人首先想到的就是for循环从(n - 1)一直枚举下去，贴代码：

```
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = n - 1; i >= 2; i--) if (n % i == 0) { 
        cout << i;
        break;
    }
    return 0;
}
```
可是这样的[结果](https://www.luogu.org/recordnew/show/20168306)是... ...

有人说，其实没必要枚举到2，枚举到n的平方根就行了。

代码见下：

```
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = n - 1; i > sqrt(n); i--) if (n % i == 0) { 
        cout << i;
        break;
    }
    return 0;
}
```
然鹅[结果](https://www.luogu.org/recordnew/show/20168411)也并不尽如人意... ...

其实还有一种更简便的方法！

大家应该知道，约数是成对出现的（平方数除外），也就是说，一个数的第一小约数乘第一大约数相乘等于这个数，第二小约数乘第二大约数相乘也依然等于这个数！

因此，只要找出n的最小约数（1除外），再用n除以这个数，就能得到结果了！

贴上代码：

```
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) if (n % i == 0) { 
        cout << n / i;
        break;
    }
    return 0;
}
```
终于通过了... ...

其实，中间的for循环也可以改成while循环，核心代码见下：

```
while (i <= sqrt(n)) {
	if (n % i == 0) break;
	i++;
}
cout << n / i;
```
# 这篇题解或许不怎么完美，但你看得如此认真，就不能点个赞再走么？

---

## 作者：hilsinleri (赞：845)

感觉楼下们说的不是很详细，所以最为一个蒟蒻，发一个有说明的题解。

本题考数学。

首先要知道唯一分解定理:一个数能且只能分解为一组质数的乘积。可知，若输入的数满足题目条件，他就只能分解为两个质数的乘积。所以在比他小且大于1的自然数中，只有那两个数能整除它，之间不可能再有任何合数或质数能整除它了，因为最小的能整除它的合数已经是他本身了。

所以代码就很容易实现了

```cpp
#include<cstdio>
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=2;i<=n;++i)
            if(n%i==0)
            {
                    printf("%d",n/i);
                    return 0;
            }
}
```

---

## 作者：Templ_1 (赞：199)

来自月赛的怨念

我看了看，应该没人写Pollard rho算法...好吧...发一份

```cpp
// 搞一搞int...这里不用long long , 但是int的第31位可能是1，所以用unsigned，否则慢速乘法会爆
#include<cstdlib>
#include<iostream>
#include<fstream>
#define uint unsigned int
using namespace std;


uint ksc(uint a, uint b, uint modu) // 计算a*b mod (modu), 防止a*b爆int,采用模拟竖式
{
  uint ans = 0;
  a = a%modu;
  while(b)
    {
      if(b&1) ans = (ans+a)%modu;
      a=(a<<1) % modu;
      b>>=1;
    }
  return ans;
}

uint ksm(uint a, uint u, uint modu) // 计算a^u % modu
{
  uint ans = 1;
  while(u)
    {
      if(u&1) ans= ksc(ans,a,modu);
      u>>=1;
    }
  return ans;
}

uint miller_robin(uint p) // 判断p是否为质数
{
  if( p == 2) return 1;
  if( p%2 == 0 || p <= 1) return 0;
  uint u = p-1;
  uint t = 0;
  while((u&1) == 0) u>>=1,t++;
  uint kase = 5; 
  while(kase--)
    {
      uint a = rand() % (p-1) + 1;
      uint x = ksm(a,u,p);
      for(uint i = 1; i <= t; i++)
      {
        uint y = ksc(x,x,p);
        if( y == 1 && x != p-1 && x != 1) return 0;
        x = y;
      }
      if( x != 1) return 0;
    }
  return 1;
}

uint gcd(uint a, uint b)
{
  return b==0? a: gcd(b,a%b);
}

int f(int x, int modu, int c)
{
  return (ksc(x,x,modu) + c)%modu;
}

uint pollard_rho(int x)
{
  if(miller_robin(x)) return 0; // ERROR! is a prime!
  long long a = rand() % (x-1) +1;
  long long b = a;
 A: // 这里用了很不好的goto语句...
  long long c = rand() % 12345677;


  while(1)
    {
      a = f(a,x,c);
      b = f(b,x,c);
      b = f(b,x,c);

      if( a == b) // RING!
    goto A;
      uint d = gcd( abs(b-a), x);

      if( d> 1 && d < x)
    return d;
    }
}
      


int main()
 {
  uint N;
  cin>>N;

  uint t1 = pollard_rho(N);
 uint t2 = N/t1;
 cout<<max(t1,t2);
  return 0;
}
      
    
```

---

## 作者：小周猪猪 (赞：137)

这道题吧,主要还是靠读题，其实只要认真读题后发现这题其实很水

因为题目上说这个所给的数是两个数的乘积，而不是多个数

那么这道题最简单的算法就是：

找到这个数最小的因数，再用这个·数除以这个最小的因数即可（即较大的那个因数）

这么做有两个省力之处：

1.不用挨个分解质因数

2.不用判断素数

so 这个代码也就很简短了

----------------------------------------

pascal：

```cpp
var n,i:longint;
begin  
  read(n);  //输入这个数
  for i:=2 to n do //用for循环判断较小的因数
    if n mod i=0 then break;//找到因数后直接break，则i为较小的因数
  write(n div i);//最后用这个数除以较小的因数就是较大的因数，大功告成！
end.
```
------------------------------------------------------------
顺便附上c++代码

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
    int n;
    cin>>n;//输入这个数
    for (int i=2;i<=n;i++)//用for循环查找最小的因数
      if (n%i==0)//如果i是n的因数
        {
            cout<<n/i;//输出较大的因数
            break;跳出循环
        } 
    return 0;
}
```

---

## 作者：封禁用户 (赞：12)

惊！这题还能发题解！

那萌新我就来写一篇吧~


普及一下基本知识：
质因数分解，就是把一个合数看做几个质数相乘的积。

如，$24$的质因数分解为$2*2*2*3=24$，注意被分解的数要写在等号后面。

[详细介绍](https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749?fromtitle=%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3&fromid=10305400&fr=aladdin)

我们一般的分解质因数就是从$2$开始，依次试过去，如果是因数，就除以这个数，直至无法分解（也就是被除数为$1$）。


这题其实不难，只要想明白就好了。

### 思路：

$a*b=c$


$c$不变，$a$越小，$b$越大。

举几个栗子：

$c=10$

$1*10=10$

$2*5=10$

$5*2==10$

$10*1=10$

-----------------------

$c=20$

$1*20=20$

$2*10=20$

$4*5=20$

$5*4=20$

$10*2=20$

$20*1=20$

所以，不用依次寻找+比较哪个大+赋值。

由此分析，我们只要找到$c$最小的质因数$i$，答案就是$c/i$。（找到后直接退出即可）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin>>n;
	for(int i=2; i<=sqrt(n); i++) {
		if(n%i==0) {//如果是最小的质因数
			cout<<n/i<<endl;//输出相对应的质因数
			return 0;
		}
	}
	return 0;
}
```

这内容也不少吧，入门水题都是这样的啊【求过QAQ】

---

## 作者：ryf2011 (赞：6)

# 题目思路
由于 $n$ 的范围很大，我们不能通过直接枚举找到答案，如何解决呢？

我们从小到大寻找第一个 $n$ 的因数，即 $n$ 的最小因数，此时输出 $n$ 除以这个数即为另一个较大的质数。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
		if(n%i==0){ //如果 n%i==0，说明找到了 n 的因数，直接输出 n/i，退出循环。 
			printf("%d",n/i); 
			return 0;
		}
	}
	return 0;
} 
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：kunkun127 (赞：4)

## 思路

这道题题面短，意思明了。唯一难点就是对 $1 \le n\le 2\times 10^9$ 范围的优化。

- $60pts$
  
  很多人看到较大的数，就会直接从 $n - 1$ 开始搜到 $2$，一满足条件就返回。但是对于题面所说的范围，肯定会[超时](https://www.luogu.com.cn/record/197701649)。

- $100pts$

  换一种思路，我们知道因数是成双成对出现的。因此，我们直接从 $2$ 开始搜，找到其中小的数后，输出 $n / i$ 即可得到大的数。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) 
	{
		if (n % i == 0) 
		{
			cout << n / i << endl;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：cff_0102 (赞：3)

从 $2$ 开始枚举更小的那个质数，找到了（设为 $x$）就输出 $\frac nx$ 即可。$n$ 是两个质数的乘积，那么更小的那个质数不会大于 $\sqrt n$，所以时间复杂度是 $O(\sqrt n)$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int x=1;
	while(x++){
		if(n%x==0){
			cout<<n/x;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：collegiate (赞：2)

既然要求**较大的那个质数**，那么我们就通过枚举**最小的因数**。

为什么呢？原理很简单！

我们知道对于一个数 $n$，它的因数都是对应起来的，平方数除外。比如数字 $8$，它的因数有 $1,2,4,8$，而其中数字 $1$ 和 $8$ 是对应的，数字 $2$ 和 $4$ 是对应的。

那么我们只要通过找到最小的因数，再用 $n$ 去除以那个因数，得到的不就是那个最大的吗？

所以我们从前往后枚举，对于枚举的数字 $i$，如果 $i$ 为 $n$ 的因数，那么我们直接输出用 $n$ 去除以那个因数的值即可了。


```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) 
        if (n % i == 0) { 
            cout << n / i;
            return 0;
        }
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

首先要知道一个数除以一个越小的数，得到的商反而越大。所以我们可以枚举 $n$ 的因数。如果 $i$ 是 $n$ 的因数，那么 $\frac{n}{i}$ 就绝对是我们要求的答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    for(int i=2;i<=n/2;i++)
	{
		if(n%i==0)
		{
			cout<<n/i;
			return 0;
		}
	} 
	return 0;
}
```

---

## 作者：Eason0324 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1075)

## 思路
比较简单，因为只有 $2$ 个数相乘，找到小的那个 $i$ 然后答案就是 $n \div i$。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n;
int main(){
	cin>>n; 
	for(int i=2;i*i<=n;i++){
	    if(n%i==0){
	        cout<<n/i<<endl;
	        break;
	    }
	}
	return 0; 
}
```

---

## 作者：hbdcsd (赞：0)

## 思路

较小的质数一定在 $2$ 到 $\sqrt{n}$ 之间。从 $2$ 枚举到 $\sqrt{n}$，如果是质数且可以整除 $n$，那么这个数是较小的质数，就可以求出较大的质数。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
bool prime(int x){//判断是否为质数的函数
	if (x <= 1) return 0;
	for (int i = 2; i*i <= x; i++)
		if (x%i == 0) return 0;
	return 1;
}
int main(){
	int n;
	cin >> n;
	for (int i = 1; i*i <= n; i++){
		if (n%i == 0 && prime(i)){
			cout << n/i;
			break;
		}
	}
	return 0;
}
```

---


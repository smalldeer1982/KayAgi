# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# 题解

## 作者：yummy (赞：510)

简单地逛了逛题解区，发现大部分题解分为两种：
- `next_permutation`
- 手写 `next_permutation`

于是，我为了不让题解区太单调，也为了拓宽大家的思维，就经过几分钟的努力，想出了一种与众不同的方法。

**Updated on 2022.7.14: 添加 $\LaTeX$，增加变进制数加法的讲解。**

> 变进制数

我们的目标是把全排列转化成一个变进制数，以方便我们进行加法。   
对于第 $i$ 根手指，它有 $n-i+1$ 种选择，根据位值原理，要想让每个数对应一个全排列，就要让这一位数是 $n-i+1$ 进制的。

那么，整个过程分为三步：
1. 将火星数变成变进制数
2. 将变进制数加上 $m$
3. 将变进制数变成火星数

我们来看一个实例：
将 $1,4,5,2,3$ 变成变进制数：
- 首位 $1$ 是 $5$ 种选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，故变为 $0$（从0开始）
- 次位 $4$ 是 $4$ 种选择 $\{2,3,4,5\}$ 的第 $3$ 种，故变为 $2$
- 中间位 $5$ 是 $3$ 种选择 $\{2,3,5\}$ 的第 $3$ 种，故变为 $2$
- 次低位 $2$ 是 $2$ 种选择 $\{2,3\}$ 的第 $1$ 种，故变为 $0$
- 末位 $3$ 是 $1$ 种选择 $\{3\}$ 的第 $1$ 种，故变为 $0$
- 最后，排列 $1,4,5,2,3$ 变成了$(02200)_{unknown}$

接下来给它加上 $3$ 变成 $(02203)$，并处理进位：
- 末位是 $1$ 进制的，进 $3$ 得 $(02230)$。
- 次低位是 $2$ 进制的，满 $2$ 进一得 $(02310)$。
- 中间位是 $3$ 进制的，满 $3$ 进一得 $(03010)$。
- 次位是 $4$ 进制的，$3<4$，不进位，得 $(03010)_{unknown}$。

最后将 $(03010)_{unknown}$ 变回火星数。

- 首位 $0$ 表示这位应选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，即 $1$
- 次位 $3$ 表示这位应选择 $\{2,3,4,5\}$ 的第 $4$ 种（$1$ 被选过了），即 $5$
- 中间位 $0$ 表示这位应选择 $\{2,3,4\}$ 的第 $1$ 种，即 $2$
- 次低位 $1$ 表示这位应选择 $\{3,4\}$ 的第 $2$ 种，即 $4$
- 末位 $0$ 表示这位应选择 $\{3\}$ 的第 $1$ 种，即 $3$

所以本题答案为 `14523` $+3=$ `15243`。

代码 $37$ 行，应该是除 STL 外较短的了。
```
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}
```
---

这篇题解是我较早时候发的，通过评论区我纠正了举个栗子那个部分的小问题。   
现在我也通过评论区知道我这方法叫做康托展开。如果你想了解更多，可以看[这篇博客](https://www.luogu.org/blog/abc123-yummy/huoxingren).

---

## 作者：ylsoi (赞：266)

这一题开始看到有一点蒙逼，但是有一种直觉告诉我，这个顺序就是全排列的顺序，所以我的想法是模拟一下深度优先搜索，就是说第一次搜索的时候直接到达外星人给出的那个结点，然后再慢慢回溯，等到求到的全排列是外星人给出的加上我们要加的数字时，我们就可以直接输出再结束程序了

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=10000+10;
int n,m,a[maxn],flag,flagx;
bool s[maxn];
void dfs(int step)
{
    if(flagx==1)
    return;
    if(step>n)
    {
        flag++;
        if(flag==m+1)//现在到了我们要加上的那个数的全排列的时候，我们就直接地输出，然后标记flagx，一直return，结束程序
        {
            for(int j=1;j<=n;j++)
            printf("%d ",a[j]);
            printf("\n");
            flagx=1;
        }
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(flag==0)i=a[step];//当还在外星人给出的排列这个阶段的时候，我们就直指外星人给出的序列中的数    
        if(s[i]==0)
        {
            s[i]=1;
            a[step]=i;
            dfs(step+1);
            s[i]=0;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    dfs(1);
    return 0;
}
```

---

## 作者：lingerleaf (赞：255)

这道题只要自带函数背得多，两分钟之内解决
了解自带函数真的有用啊！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	int ord[n+1];
	for(int i=1;i<=n;++i)	cin>>ord[i];
	for(int i=1;i<=m;++i)	next_permutation(ord+1,ord+1+n);
	for(int i=1;i<n;++i)	cout<<ord[i]<<' ';
	cout<<ord[n];
}
```

---

## 作者：FP·荷兰猪 (赞：198)

































     




     





















```cpp
//非STL详细解答
#include <iostream>
using namespace std;
int b[10000+1]; 
int i,j,k,m,n,t;
void init()
{
  cin>>n>>m;
  for(i=1;i<=n;i++)
    cin>>b[i];
}
void out()
{
  for(i=1;i<=n-1;i++)
    cout<<b[i]<<' ';
  cout<<b[n]<<endl;
}
void work()
{
  for(i=1;i<=m;i++)//增1 共M次 
  {
     for(j=n-1;j>=1;j--)//找到最后可增加的位，即定位 
       if(b[j]<b[j+1])//例如12354加1，则只有3可增加位数 
         break;
     for(k=n;k>=1;k--)//找到最小可增加的数字 
       if(b[k]>b[j])//例如12354加1，最小可增加的数字是4 
         break;
     t=b[j];//交换，把原排列增大 ，
     b[j]=b[k];//例如12354加1，即3和4交换，交换结果为12453 
     b[k]=t;  //但12453并不是最终结果，而是12435即要排序 
     j=j+1;//向后移一位 
     k=n;
     while((j<k))//把后面的逆序，相当于从小到大排序 
     {
       t=b[j];  
       b[j]=b[k];
       b[k]=t;
       j++;
       k--;
     }
  }
}
int main()
{
  init();
  work();
  out();
  return 0;
}
```

---

## 作者：zhi_zhang (赞：90)

不知道有没有与我的想法相同的题解已经发布

但是我觉得这是最为直观易懂的方法

而且讲的也是直观易懂

按照人脑的思维去模拟增加的过程

下面是**模拟过程**：

**刚开始所有的数已经使用过**

**从最后一位开始**

**要判断当前的数位是否还有更高的未标记数可以使用**

**如果有，那就使用找到的数替换该位置的数，然后剩余未标记的数按照从小到大的顺序塞回去**

**如果没有，那就取消当前数位的标记，搜索上一数位**

_样例： 1 2 3 4 5，加3次_

_**第一次**_

_（5）数位为5，判断后发现此时已经没有更高的未标记数_

_5取消标记，搜索上一数位_

_（4）数位为4，当前有更高的5未被标记_

_（4）数位用5代替，4取消标记_

_剩下的（5）数位用仍未标记的4代替_

_第一次结束,得到 1 2 3 5 4_

_**第二次**_

_（5）数位的4和（4）数位的5取消标记_

_（3）数位的3用4代替，3取消标记_

_把3,5按从小到大顺序依次填入（4）（5）数位_

_第二次结束，得到 1 2 4 3 5_

_**第三次**_

_（5）数位5取消标记_

_（4）数位3用5代替，3取消标记_

_将3填入（5）数位_

_第三次结束，得到1 2 4 5 3_

**代码自带输出调试**

以下是代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int MAXN=10010;
int finger[MAXN];
int N,M;
int vis[MAXN];
int ad(int);
void prin();
int main()
{
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)//输入 
	{
		vis[i]=1;
		scanf("%d",&finger[i]);
	}
	while(M--)//计算还剩多少步 
	{
		for(int i=N;i>=1;i--)//倒着进行判断 
		{
			int k=ad(finger[i]);
			if(k!=-1)//如果能够增加 
			{
				vis[finger[i]]=0;
//				printf("%d取消标记\n",finger[i]);
				finger[i]=k;//那么当前指头变为序号更大的指头
				vis[k]=1;
//				printf("(%d)处手指变为%d\n",i,k);
//				printf("%d标记\n",k);
				for(int j=i+1;j<=N;j++)//剩下的指头从小到大向后排序 
				{
					for(int p=1;p<=N;p++)//从小到大检索 
					{
						if(!vis[p])//如果p手指还没进入 
						{
//							printf("(%d)处手指变为%d\n",j,p);
							finger[j]=p;//该手指则为p 
							vis[p]=1;//p手指已进入 
//							printf("%d标记\n",p);
							break;
						}
					}
				}
//				prin();
				break;
			}
			else//如果不能增加 
			{
				vis[finger[i]]=0;//该手指退出，然后搜索下一个手指 
//				printf("%d取消标记\n",finger[i]);
			}
		}
	}
	prin();
	return 0;
}
int ad(int poi)//检索该手指 
{
	for(int i=poi+1;i<=N;i++)//向上搜索直到 
	{
		if(!vis[i])//搜索到还未入队的更大的数 
		{
			return i;//返回该数 
		}
	}
	return -1;//检索不到则返回-1
}
void prin()
{
	for(int i=1;i<=N;i++)
	{
		printf("%d ",finger[i]);
	}
	printf("\n");
}
```

**因为题目上说了是加了一个很小的数，所以不会因为模拟次数过多超时**

---

## 作者：Believe_R_ (赞：65)


## 此题是一道练全排列函数的好题！
传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

至于什么是全排列函数，我们先来看一道**模板题**：[P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706)

**一句话题意**：输出 $n$ 的全排列。

```cpp
样例输入：
	3
样例输出：
	1	2	3
    1	3	2
    2	1	3
    2	3	1
    3	1	2
    3	2	1
```

看看自己2年前写的代码，用**递归**来做（不得不承认，这是一道递归的好题），下面贴上递归代码（初学者都会写）！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k;
int a[10]={0},bj[10]={0};
void dfs(int x)
{
    int i,j;
    if(x==n+1)
    {
        for(i=1;i<=n;++i)
        printf("%5d",a[i]);
        cout<<endl; 
    }
    else
      for(i=1;i<=n;++i)
        if(bj[i]==0)
        {
            a[x]=i; bj[i]=1;
            dfs(x+1);
            a[x]=0; bj[i]=0;
        }
}
int main()
{
    cin>>n;
    dfs(1);
    return 0;
}
```



然而到今天，我突然翻出这道题，发现这道题不就是**全排列函数的模板题**吗？下面就请我们今天的主角上场：

$$
 \Large \texttt{next \_ permutation}
$$

这个函数每运行一次就可以排列出下一个全排列的序列 （**<algorithm>** 中有许多好用的函数）。

用法即是 next_permutation(数组开头，数组结尾)  【和 sort 用法差不多】

伪代码如下：

```cpp
#include <algorithm>
// #include <bits/stdc++.h>    //用这个我也没意见

int a[1000];
int n;
int main()
{
    令a[i]=i;
    int tot=n所有全排列的数量;
    for i=1 to tot
    {
        next_permutation(a+1,a+n+1);  //因为我 a 数组是从下标1开始存的
    }
    return 0;
}
```

那现在还有一个问题：$tot$ 怎么求呢？

这就涉及到排列组合的问题了。

全排列的数量即是 $A_n^n = n !$ （不懂的话可以自己去学习一下）

那么每次运行这个函数之前，输出数组 $a$ 的值即可！

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[100];
int main()
{
    scanf("%d",&n);
    int tot=1;
    for(int i=1;i<=n;++i)
    {
        a[i]=i;
        tot*=i;
    }
    for(int i=1;i<=tot;++i)
    {
        for(int j=1;j<=n;++j) printf("    %d",a[j]);    //输出格式注意
        next_permutation(a+1,a+n+1);
        printf("\n");
    }
    return 0;
}
```



### 这道模板题做了后，再回来看这道题目吧：


传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

题目看过了，自己可以先想一下………………

别看这是一道**普及组T4** 的题目，但是我觉得它连 **T2** 的难度都没有 ~~（只要你掌握了这个函数）~~

**一句话题意： 求出一个给定长度的序列经过 $m$ 次全排列变化后的序列。**

甚至比上一题还简单，改变的次数都跟你说了~  \^~^   ~

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100000];
int n,m;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f;
}
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
//简单吧~
```



---

## 作者：Matoi (赞：28)

# Pascal题解

- 这题我并没有用数学模型，而是找规律

#### 规律如下

- 找一个尽量靠后的数（m），使其后为一个连续下降序列（只含一个数也行）。并交换该数与其后序列中最小的但比该数大的数

- 交换这个序列中第a大与第a小的数(1<=a<=序列长div 2)

### 以1 2 3 4 5 为例

1. m=4，4与5交换，变为1 2 3 5 4。序列为4，长为1，不交换。

1. m=3，3与4交换，变为1 2 4 5 3。序列为5 3，交换后为1 2 4 3 5。

1. m=3,3与5交换，变为1 2 4 5 3。序列为3，长为1，不交换。

1. 输出1 2 4 5 3。

------------

#### 加上m即为重复m次

------------



    
    
```cpp
    var m,n,i,j,k,l,min,count:longint;
        a:array[0..10000]of longint;
    procedure swap(u,v:longint);//交换a[u]与a[v]的过程
    var t:longint;
    begin
      t:=a[u];
      a[u]:=a[v];
      a[v]:=t ;
    end;
    begin
      fillchar(a,sizeof(a),0);//不赋初值可能会错
      readln(n);
      readln(m);
      for i:=1 to n do read(a[i]);//读入各数据
      for i:=1 to m do//相当于加上m
        begin
          k:=n; //k指针从后向前找
          while a[k]<a[k-1] do dec(k);//因为该序列尾在最后一个数处，且连续。若加上前一个数条件仍成立，则将该数纳入序列。a[k-1]即为m。
          min:=maxint; //初始化min，使其在之后定能被赋一个值
          for j:=k to n do 
          if (a[j]<min)and(a[j]>a[k-1]) then//寻找大于m的最小数
            begin
              min:=a[j];//记录最小值
              count:=j;//记录最小值的位置
            end;
          swap(k-1,count);//规律1，交换m与序列中最小的但比m大的数
          for j:=k to (k+n)div 2 do//j即为a
            swap(j,n+k-j);//规律2，前后交换
        end;
      for i:=1 to n do
        write(a[i],' ');//输出结果
    end.

```

---

## 作者：Lynkcat (赞：18)

这是个来自P党的垃圾题解！

看到这道题目，你脑子里第一个冒出来的词语是什么？

全排列！！！

那么怎样求全排列呢？

又第一个想到DFS！！！

一看手指位数是10000，想必不少蒟蒻都会放弃这个念头。

但是关键点不在这儿，

**在于加上的位数！！！**

再看n<=100，

加上剪枝，放心大胆的去做吧！！！
```pascal
var h,i,p,n,t,ans:longint;b,e:array[0..10000]of longint;c,f:array[1..10000]of boolean;sub:boolean;
procedure dfs(k:longint);
var j,y:longint;
begin
  if k>n then
  begin
    dec(t);
    exit;
  end;//如果产生完毕则退出
  if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;//若已经找到则输出再退出程序
  if f[k] then y:=1 else y:=e[k];//这里是重点，剪枝的一个重要环节！！！
  for j:=y to n do
    if c[j]=false then
    begin
      b[k]:=j;
      c[j]:=true;
      dfs(k+1);
      if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;
      c[j]:=false;//别忘记回溯
    end;
  f[k]:=true;//设此层已访问
end;
begin
  readln(n);
  read(t);inc(t);
  for i:=1 to n do
    read(e[i]);
  dfs(1);//开始深搜
end.

```


---

## 作者：Forever丶CIL (赞：17)

这个题就是一个部分的全排列，如果用 next\_permutation(a,a+n);

这种stl函数水过去就太没意思了，也练不了自己的代码能力

不如试着写一下全排列，当然全部全排列肯定会TLE的

我们可以从当前排列（就是火星人手指表示的那个排列）开始，做m次排列，

即找按顺序排列的全排列中，排在当前序列之后m个的那个序列

其实也差不多就是手动做一下 next\_permutation(a,a+n);做的工作

解释留到代码中

qaq


------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m,tot=1;
int vis[10101];
int sl[10101];
int f[10101];
void print()//输出函数 
{
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sl[i]);
    }
    printf("\n");
}
void dfs(int cur)//从当前数列开始全排 
{
    if(cur==n+1)
    {
        m--;
        //return ;
    }
    if(m==-1)
    {
        print();
        return ;
    }
    else for(int i=(f[cur]?1:sl[cur]);i<=n;i++)//这一步做的工作是将现在的dfs迅速递归到找到最初序列的状态 
    {
        if(!vis[i])//基本的全排列 
        {
            sl[cur]=i;
            vis[i]=1;
            dfs(cur+1);
            if(m==-1) return ;
            vis[i]=0;
        }
    }
    f[cur]=1;
    return ;
}
int main()
{
    /*scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
    }*/
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
        //vis[i]=1;
    }
    dfs(1);
    return 0;
}
```


------------

可能大家不是很懂dfs中的那个for 其实想一想，我们在求全排列的时候
是递归求的，我们每求得一中全排列，它背后是有一个递归层的

所以当我们想从任意一种排列开始求它后面的排列时，就需要先把

它的这个递归层先建立起来，然后顺着继续递归就好了

qaq rp++




---

## 作者：RedContritio (赞：17)

这个题目核心就是从给定的一个排列开始进行M次全排列。

首先，简单暴力是绝对不行的，复杂度吃不消。

那么我们可以简单整理思路，大致如下：

1、读入所有有效数字

2、dfs深搜全排列

3、深搜到指定位置时强制结束全排

4、输出全排结果

但是为了降低复杂度，我们从深搜的部分降低其复杂度，也就是说，我们从给定排列直接开始。

我们先定义一个bool数组，用来计算是否曾经访问过这一位置，若为真，则从1开始，否则从给定排列开始。

代码实现如下（一次AC）：

CPP

```cpp
#include <cstdio>
#include <cstdlib>
bool used[12000],fs[12000]; // 分别作为 全排列的辅助数组和 是否访问过的标记
int finger[12000]; // 排列状况
    int N,M; // 如题意
void search(int p); // 深搜，用 p 表示当前位置
int main()
{
    scanf("%d%d",&N,&M);
    for(int i=0;i<N;i++)scanf("%d",&finger[i]); // 读入
    M++; // M+1，用来表示访问最初排列的次数
    search(0); // 深搜开始
    for(int i=0;i<N;i++)printf("%d%c",finger[i],(i<N-1)?0x20:0x0A); // 完全输出
}
void search(int p)
{
    if(p>=N) // 如果搜索成功
    {
        M--; // 减少次数
        return ;
    }
    if(M==0)return ; // 若访问结束，结束搜索
    for(int i=(fs[p]?1:finger[p]);i<=N;i++) // 设置循环变量
    {
        if( used[i] == false )
        {
            used[i] = true ;
            finger[p] = i;
            search(p+1);
            if(M==0)return ;
            used[i] = false ;
        }
    }
    fs[p] = true; // 标记访问过这一层
    return ;
}
```

---

## 作者：_Sein (赞：13)

在我多年观察题解区的经验上，难道这不是一道数据结构题吗？

其实核心思想就是康托，但1e4的全排列受不鸟，考虑优化康托。
 
其实康托个数就是排列个数

因此第一个位置可以有$n$种选择，由于第一个数被选了，第二个数只有$(n-1)$种选择，以此类推，恰好为$n!$，正好对应进制数，第$i$位的进制就是$n-i+1$。

再考虑$+m$，其实也就是字典序$+m$，可以将$unkown$进制的最低位直接加上一个m，让后模拟加法进位即可，进制数每一个位上的数$a_i+1$，也就对应着康托展开第$(a_1+1)*(a_2+1)*\cdots*(a_n+1)$


用树状数组维护一下a[i]之前出现的数字，转为unkown进制，每一位为n-i+1进制。

再用权值线段树找到第k大的数，输出即为答案

Q.E.D

## AC code

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#define gc getchar()
#define ll long long
using namespace std;
const int N=1e4+10;
template<class o>
inline void qr(o &x)
{
    x=0;char c=gc;
    while(c<'0'||c>'9')c=gc;
    while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
}
void qw(ll x)
{
    if(x/10)qw(x/10);
    putchar(x%10+48);
}
ll a[N];int c[N],n; ll m;
void add(int x){for(;x<=n;x+=x&-x)++c[x];}
int ask(int x){int ans=0;for(;x;x-=x&-x)ans+=c[x];return ans;}
struct segtree{int l,r,sum;}t[N*4];int cnt;
void build(int &x,int l,int r)
{
	x=++cnt;
	if(l==r){t[x].sum=1;return ;}
	int mid=(l+r)>>1;
	build(t[x].l,l,mid);
	build(t[x].r,mid+1,r);
	t[x].sum=t[t[x].l].sum+t[t[x].r].sum;
}
void change(int l,int r,int x,int pos)
{
	--t[x].sum;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(l,mid,t[x].l,pos);
	else change(mid+1,r,t[x].r,pos);
}
int query(int l,int r,int x,int k)
{
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(k<=t[t[x].l].sum)return query(l,mid,t[x].l,k);
	else return query(mid+1,r,t[x].r,k-t[t[x].l].sum);
}
int main()
{
    qr(n),qr(m);
    for(int i=1;i<=n;i++)qr(a[i]);
    for(int i=1;i<=n;i++)
    {
        int x=a[i];add(a[i]);
        a[i]=a[i]-ask(a[i]-1)-1;
    }
    a[n]+=m;
    for(int i=n;i>=2;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    int root=0;
    build(root,1,n);
    for(int i=1;i<=n;i++)
    {
        ++a[i];
        a[i]=query(1,n,1,a[i]);
        qw(a[i]),putchar(' ');
        change(1,n,1,a[i]);
    }
    puts("");
    return 0;
}
```

---

## 作者：ld_k_s (赞：8)

# P1088 c++
看到这道题，我一下子想到了一个函数：
### next_permutation ！！！

这样做，代码很很简单！这个函数可以自动生成下一个数。大家可以看一下 Lyrics 写的题解，思路与我一样，我在这里也就不多说了。我复制一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],n,m;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)scanf("%d",&a[i]);
    while(m--)    next_permutation(a,a+n);
    for(int i=0;i<n-1;i++)    printf("%d ",a[i]);    printf("%d",a[n-1]);
    return 0;
}
```

#### 但是，这不是考试，是刷题！next_permutation的原理是什么？是怎么写出来的？这些，我们也许也需要明白！

当然，我翻了一下，也有许多人手写了next_permutation，但是我没有看到与我的方法重复的方法！

排序？这是必定的（可以用sort，但我手写了）。
```cpp
for (i = n - 1; i >= 1; i--) {
	for (j = n; j >= i + 1; j--) {
		if (x[i] < x[j]) {
			swap(x[i], x[j]);			
		}
	}
}
```
![](https://cdn.luogu.com.cn/upload/pic/61314.png)
会TLE！
所以得缩小一下范围...

取下一个数，改变后火星人手指的排列顺序：
```cpp
if (i + 1 != n) {
	for (u = i + 1; u <= n - 1; u++) {
		for (v = u + 1; v <= n; v++) {
			if (x[u] > x[v]) {
				swap(x[u], x[v]);
			}
		}
	}
}
```
主程序部分不用我讲了吧：
```cpp
int main() {
	cin >> n >> m;
	for (i = 1; i <= n; i++) {
		cin >> x[i];
	} 
	while (m > 0) {
		next();
	}
	for (i = 1; i <= n; i++) {
		if (i != n) {
			cout << x[i] << " ";
		} else {
			cout << x[i] << endl;
		}
	}
	return 0;
}
```
###### 接着，上代码！
```cpp
#include <bits/stdc++.h> //万能头文件
using namespace std; //声明姓名空间

int n, m, x[100000], i, j, u, v;

void next() { //相当于next_permutation
	for (i = n - 1; i >= 1; i--) {
		for (j = n; j >= i + 1; j--) {
			if (x[i] < x[j]) { //排序
				m--; //缩小下次的范围，使程序AC！
				swap(x[i], x[j]);
				if (i + 1 != n) { //核心部分
					for (u = i + 1; u <= n - 1; u++) {
						for (v = u + 1; v <= n; v++) {
							if (x[u] > x[v]) {
								swap(x[u], x[v]);
							}
						}
					}
				}
				return ;
			}
		}
	}
}

int main() {
	cin >> n >> m;
	for (i = 1; i <= n; i++) {
		cin >> x[i];
	} 
	while (m > 0) {
		next();
	}
	for (i = 1; i <= n; i++) {
		if (i != n) {
			cout << x[i] << " ";
		} else {
			cout << x[i] << endl; //我写的太严谨，把if else去了，直接输出，也没问题
		}
	}
	return 0;
}
```
#### 谢谢观看，如有问题，请评论，谢谢！

---

## 作者：WuYongxuan (赞：8)

我们知道，做这题不需要知道手势是第几个，直接用 next\_permutation 就好了，也不必要加特判，附上程序（不知道头文件，所以用了万能，请各位大神私信告诉我）

###
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(void)
{
    int n,k,i;
    cin>>n>>k;
    int a[n];
    for (i=0;i<n;i++)
        cin>>a[i];
    for (i=0;i<k;i++)
        next_permutation(a,a+n);
    for (i=0;i<n;i++)
        cout<<a[i]<<' ';
}

```

---

## 作者：Tanktt (赞：7)

小学的时候曾做过这道题目，同时也大概是关于数学的第一道题吧。记得我那时候垃圾，没有做出来，从此就对产生了~~极大的恐惧~~。

现在再看，发现不就是一道~~模拟~~吗（其实只是模拟这个数怎样变化，主要还是数学）。而且这个全排列好像文化课也会将吧。另外c语言还有个大福利——
```cpp
#include<cstdio>
#include <algorithm>
using namespace std;
int n,m,a[10012];
int main()
{
    scanf("%d",&n);
    scanf("%d",&m);
    for (int i=1; i<=n; i++) scanf("%d",&a[i]);
    while (m--) //***//next_permutation(a+1,a+1+n);//***//
    for (int i=1; i<n; i++) printf("%d ",a[i]);
    return printf("%d\n",a[n]),0;
}
```
那就是  next_permutation()

不过我们还是回归正轨：
1. 我们在每次模拟中都从后往前找第一个比后面一个数小的数的位置，因为这个值可以变换且变换后改动最小。
1. 再在它之后的数中找比这个数大的最小值，并交换，理由同上。
1. 再把第一步中找到的位置之后的数从小到大排列，具体方法代码中会讲。

OK，这道在小学里难住我的题如今就被我做完并写题解了。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[10012];
int main()
{
	scanf("%d",&n);
	scanf("%d",&m);
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	int j,k;
	for (int i=1; i<=m; i++)
	{
		for (j=n; j>=1; j--) if (a[j]>a[j-1]) break;
		j--;//第一步
		for (k=n; k>j; k--) if (a[j]<a[k]) break;
		swap(a[j],a[k]);//第二步
		j++;k=n;
		while (j<k) swap(a[j],a[k]),j++,k--;
        //第三步。
        //因为从第一步中可以知道，j之后的所有数都已经有序了，将他们从小到大只需两两交换即可。
        //还有在j和k交换后也有序，因为k+1这个数最大只能是k这个数-2（a[k+1]≠a[j]≠a[k])。
	}
	for (int i=1; i<n; i++) printf("%d ",a[i]);
	return printf("%d\n",a[n]),0;
}
```

---

## 作者：xiejinhao (赞：6)

# P1088 火星人 题解
### 水题一题，但是在介绍之前，我们要知道全排列的运作方式
（附全排列题目[P1706 全排列](https://www.luogu.org/problemnew/show/P1328)）

虽然STL里面有全排列函数（算了顺便讲一下）：


------------

- 调用algorithm库
	
```cpp
		#include<algorithm>
```

    
1. next_permutation下一个排列
```cpp
      	#include<algorithm>
      	using namespace std;
      	int a[50]
      	……
      	next_permutation(a+1,a+50)
      	//数组从0开始就不用a+1；
```

- 函数模板：next_permutation(arr, arr+size);
- arr： 数组名   size：数组元素个数
- 优点：遍历一个不重数组的接下来全排列


------------

2. prev_permutation上一个排列
```cpp
        #include<algorithm>
        using namespace std;
        int a[50]
        ……
        prev_permutation(a+1,a+50)
        //数组从0开始就不用a+1；
```
- 函数模板：prev_permutation(arr, arr+size);
- arr： 数组名  size：数组元素个数
- 优点：遍历一个不重复数组的之前的全排列


------------

下面把全排列函数做法发一下吧，烂大街了（~~不想写了~~）
------------
```cpp
  //认真看，杜绝抄袭  
  #include<cstdio>
  #include<algorithm>
  const int MAX_N=100005+10;
  int n,m,a[MAX_N];
  using namespace std;
  int main()
  {
      scanf("%d%d",&n,&m);
      for(int i=1;i<=n;i++)
          scanf("%d",a+i);
      for(int i=1;i<=m;i++)
          next_permutation(a+1,a+n+1);
      for(int i=1;i<=n;i++)
      {
          if(i!=n)printf("%d ",a[i]);
          else printf("%d",a[i]);
      }
      return 0;	
  } 
```

Dalao路过，不妨点个赞？
------------

---

## 作者：彼岸朱砂 (赞：5)

**STL**提供了两个用来计算排列组合关系的算法，分别是next_permutation和prev_permutation。

首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。考虑三个字符所组成的序列{a,b,c}。

这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序(lexicographical)的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。acb是次一个排列组合，因为它是固定了a(序列内最小元素)之后所做的新组合。

同样道理，那些固定b(序列中次小元素)而做的排列组合，在次序上将先于那些固定c而做的排列组合。以bac和bca为例，bac在bca之前，因为次序ac小于序列ca。面对bca，我们可以说其前一个排列组合是bac，而其后一个排列组合是cab。序列abc没有“前一个”排列组合，cba没有“后一个”排列组合。

** next_permutation()**会取得[first,last)所标示之序列的下一个排列组合，如果没有下一个排列组合，便返回false;否则返回true。这个算法有两个版本。版本一使用元素型别所提供的less-than操作符来决定下一个排列组合，版本二则是以仿函数comp来决定。


------------

 
** 算法思想：**


1.首先从最尾端开始往前寻找两个相邻元素，令第一元素为*i,第二元素为*ii,且满足*i<*ii。


2.找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于*i的元素，令为*j，将i,j元素对调(swap)。

3.再将ii之后的所有元素颠倒(reverse)排序。


 举个实例，假设有序列{0,1,2,3,4}，下图便是套用上述演算法则，一步一步获得“下一个”排列组合。图中只框出那符合“一元素为*i,第二元素为*ii,且满足*i<*ii ”的相邻两元素，至于寻找适当的j、对调、逆转等操作并未显示出。
 
 ![](https://img-blog.csdn.net/20151214221316417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
 
 ```
template<calss BidrectionalIterator>
bool next_permutation(BidrectionalIterator first,BidrectionalIterator last)
{
     if(first == lase) return false; /* 空区间 */
     BidrectionalIterator i = first;
     ++i;
     if(i == last) return false;  /* 只有一个元素 */
     i = last;                    /* i指向尾端 */  
     --i;
     for(;;)
     {
         BidrectionalIterator ii = i;
         --i;
         /* 以上锁定一组(两个)相邻元素 */
         if(*i < *ii)           /* 如果前一个元素小于后一个元素 */
         {
             BidrectionalIterator j = last; /* 令j指向尾端 */
             while(!(*i < *--j));     /* 由尾端往前找，直到遇到比*i大的元素 */
             iter_swap(i,j);          /* 交换i,j */
             reverse(ii,last);        /* 将ii之后的元素全部逆序重排 */
             return true;
         }
         if(i == first)       /* 进行至最前面了 */
         {
             reverse(first,last);    /* 全部逆序重排 */
             return false;
         }
     }
}
```


**简单应用**

输出序列{1,2,3,4}字典序的全排列。

[代码实现]

```
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
     int ans[4]={1,2,3,4};
     sort(ans,ans+4);    /* 这个sort可以不用，因为{1，2，3，4}已经排好序*/
     do                             /*注意这步，如果是while循环，则需要提前输出*/
     {
         for(int i=0;i<4;++i)
             cout<<ans[i]<<" ";
         cout<<endl;
     }
     while(next_permutation(ans,ans+4));
     return 0;
 }
```

**拓展**

1.能否直接算出集合{1, 2, ..., m}的第n个排列？

举例说明：如7个数的集合为{1, 2, 3, 4, 5, 6, 7}，要求出第n=1654个排列。

(1654 / 6!)取整得2，确定第1位为3（从0开始计数），剩下的6个数{1, 2, 4, 5, 6, 7}，求第1654 % 6!=214个序列；

(214 / 5!)取整得1，确定第2位为2，剩下5个数{1, 4, 5, 6, 7}，求第214 % 5!=94个序列；

(94 / 4!)取整得3，确定第3位为6，剩下4个数{1, 4, 5, 7}，求第94 % 4!=22个序列；

(22 / 3!)取整得3，确定第4位为7，剩下3个数{1, 4, 5}，求第22 % 3!=4个序列；

(4 / 2!)得2，确定第5为5，剩下2个数{1, 4}；由于4 % 2!=0，故第6位和第7位为增序<1 4>；

因此所有排列为：3267514。

```
 #include<iostream>
 #include<algorithm>
 using namespace std;
 int main()
 {
     int ans[7]={1,2,3,4,5,6,7};
     sort(ans,ans+7);  /* 同上可以不用sort */
     int n=0; 
     do                             //注意这步，如果是while循环，则需要提前输出
     {
         if(n == 1654)
         {
              for(int i=0;i<7;++i)
             cout<<ans[i];
             cout<<endl;
             break;
         }
         n++;
      }
      while(next_permutation(ans,ans+7));
     return 0;
 }
```

2. 给定一种排列，如何算出这是第几个排列呢？

和前一个问题的推导过程相反。例如3267514：

后6位的全排列为6!，3为{1, 2, 3 ,4 , 5, 6, 7}中第2个元素（从0开始计数），故2*720=1440；

后5位的全排列为5!，2为{1, 2, 4, 5, 6, 7}中第1个元素，故1*5!=120；

后4位的全排列为4!，6为{1, 4, 5, 6, 7}中第3个元素，故3*4!=72；

后3位的全排列为3!，7为{1, 4, 5, 7}中第3个元素，故3*3!=18；

后2位的全排列为2!，5为{1, 4, 5}中第2个元素，故2*2!=4；

最后2位为增序，因此计数0，求和得：1440+120+72+18+4=1654


这个的代码实现，可以用一个数组a保存3267514,然后while调用next_permutation(),用n计数，每次与数组a比较，相等则输出n;




------------


------------


------------

[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

```
#include <bits/stdc++.h>
using namespace std;
int main(void)
{
    int n,k,i;
    cin>>n>>k;
    int a[n];
    for (i=0;i<n;i++)
        cin>>a[i];
    for (i=0;i<k;i++)
        next_permutation(a,a+n);
    for (i=0;i<n;i++)
        cout<<a[i]<<' ';
}
```
 

---

## 作者：LMB_001 (赞：5)

STL大法好啊，咱就用c++的next\_permutation函数（也就是STL里面的求下一种排列函数），其实也可以用普通全排列写，求第m+1种排列，不过我太~~懒~~累，这道题之前用Pascal写了38行，现在用c++只用10行！

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int a[10000],n,m,i;
    cin>>n>>m;//因为cin可以检测换行，所以可以一起读
    for (i=1;i<=n;i++) cin>>a[i];//首先要把a数组读入
    for (i=1;i<=m;i++) next_permutation(a+1,a+n+1);//循环m次，每次求下一种排列，如果数组是从0读入到n-1的，直接next_permutation(a,a+n）就行了
    for (i=1;i<n;i++) cout<<a[i]<<" ";//由于题目说明输出最后没有空格，所以先循环到n-1，输出a[i]加一个空格
    cout<<a[n];最后再输出a[n]
}
```
完美结束，谢谢大家

---

## 作者：ljcljc (赞：5)

~~水一发题解~~

## 【分析】
这是一道c++福利题，因为可以直接用  $next\_permutation$
（这就没什么好说的了）

贴一下代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 100010;
int n, m, a[N];

int main() {
	cin >> n >> m;
	for(int i=1; i<=n; i++) cin >> a[i];
	for(int i=1; i<=m; i++) next_permutation(a+1, a+n+1);
	for(int i=1; i<=n; i++) cout << a[i] << ' ';
	return 0;
}
```


------------

此外，这里我们还可以考虑一下如何手动模拟$next\_permutation$函数。

对于所给定的一个序列，我们想求出比它大的最小的序列。
就可以从后往前遍历这个序列，找到第一个可以让序列的字典序变得更大的位置。

可以想到只有当序列单调下降时，它才不存在更大的序列，因此要找的位置就是第一次出现  a[k−1]<a[k] 的位置。

那么此时将a[k−1]成比它大的最小数，然后将剩余部分从小到大排序，所得到的排列就是比原排列大的最小排列了。

**p.s.一个小优化：**
由于a[k−1]后面的部分已经从大到小排好序，因此只需将其翻转，就可以得到从小到大排序的结果了，不需要使用 sort，时间复杂度可以降到O(n)。

代码：~~（码风大雾，不喜勿喷）~~
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 10010;
int n, m, a[N];

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; i++) cin >> a[i];
    while(m--) {
        int k = n;
        while(a[k-1] > a[k]) k--;
        k--;
        int t = k;
        while (t+1 <= n && a[t+1] > a[k]) t++ ;
        swap(a[t], a[k]);
        reverse(a + k + 1, a+n+1);
    }
    for (int i=1; i<=n; i++) cout << a[i] << ' ';
    return 0;
}

```



---

## 作者：MiniAst (赞：5)

咳咳,这里介绍一种稀奇古怪的解法，可以处理m很大时候的问题哦~~（开个小玩笑QAQ，理论上m<2^63或更大,需要再加一点小优化~）~~

首先我们不难看出题意，给定一个1~n的排列，求比这个排列在全排列中的次序（构成的n位数的大小，这算字典序嘛。。）大m的另一个排列;

容易想到的做法是连续m次使排列的次序加1，楼下各位已经讲的很全面了，这里不再赘述——-

不过，既然唯一的次序对应唯一的排列，我们当然也可以建立两个映射，一个将次序映射向排列，另一个反向即可;

那么开始一波胡乱分析....


------------


- **从排列向次序的映射**

事实上，1~n共有n!种排列，每个排列在全排列中对应唯一的次序，我们这里以n = 5为例：

5
1 2 3 4 5

这个排列的次序是1

显然，n <= 10000时遍历是不可行的，在n = 12时，全排列共有479001600种，已经超过了时空界限;

现在我们看看排列的内容是如何体现次序的：

如果我们在第一个位置填1，那么剩余的4个位置有 4! = 24 种填法；这意味着当我们将2作为第一个元素时改排列的次序下界为 4!+1 ;同理，3开头时下界为 2\*4!+1 ..以此类推;

而假设我们固定3为第一个元素，剩余的4个数为1 2 4 5,排列的次序在 2\*4!+1 ~ 3\*4! 之间；这时我们发现，如果在第二个位置填1，则对次序下界无影响，若填2，则下界

增加 3! ,填4则增加 2\*3! ...以此类推

值得注意的一点是，此时由于4是剩下的数中第3大的，所以填4时不再使下界增加 3\*3! ,而是 2\*3! ,也就是4代替了原来3的位置，这说明下界的增量仅与所填数在当前所剩数中的大小序数有关；

很显然，若我们已填好i个数，剩余的数为n-i，那么在填第i+1位置时，若我们使用的数在剩余的数中排列的序数为j（1<=j<=n-i）,则会使下界增加 j\*(n-i)! ,此处我们计0!为1；

问题转化为**求排列中的每一个数在从当前位置到数组尾这个序列中的序数**，依次累加下界，当累加到数组尾时，显然**上界 = 下界 = 次序**；在这个问题中，我们每确定一个数的序数，

需要将比该数大的所有数的序数－1，也就是区间修改，单点查询，参见：[模板]树状数组2；

例如排列 3 4 1 5 2 处理后的数据为 3 3 1 2 1 ，代表着次序为2\*4! + 2\*3! + 0\*2! + 1\*1! + 0\*0! + 1 = 62的排列；

- 累加问题

目前我们的目标为次序为62+m的排列，观察一下次序的计算方法，我们不难看出这是一种加法(认为33121是一个5位数)，对于第i位采取i+1进制，即满i+1进1(每一位至少为1)；

将m也处理成阶乘形式:以 m = 35 为例，m = 4! + 3! + 2\*2! + 1!;

累加后得到新的次序序列: 4 4 3 3 1

从后往前处理一遍，满i+1进1，第i位向前进位后减去的数为i: 5 1 1 1 1

- 从次序到排列的映射

我们建立一个1~n的优先队列。。初始时每个元素的值为元素的序数，显然我们在取掉某个数之后，其后的元素序数加1；

不过，这个队列是无法用简单树状数组做的。。(这里我就不介绍什么平衡树和离散化树状数组了= =)

干脆打个标记依次选取好了，由于常数很小和上述算法的优化，最后一步（n^2）也没什么关系（无需O2~）；


------------


接下来贴代码咯

```cpp
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<cstdlib>
    using namespace std;
    int n,m,t;
    int v[10005],trv[10005],ord[10005],ans[10005],chan[10005];
    int read()
    {
        char ch = getchar();
        int re = 0;
        while(ch<'0'||ch>'9') ch = getchar();
        while(ch>='0'&&ch<='9')
          {
              re = (re<<3) + (re<<1) + ch - '0';
              ch = getchar();
          }
        return re;
    }
    int lowbit(int x)
    {
        return x&-x;
    }
    void add(int loc,int x)
    {
        while(loc<=n)
          {
              trv[loc]+=x;
              loc+=lowbit(loc);
          }
    }
    int vfind(int loc)
    {
        int re=0;
        while(loc>=1)
          {
              re+=trv[loc];
              loc-=lowbit(loc);
          }
        return re;
    }
    void solve(int re)
    {
        if(re == 0) return;
        int sta=1,cnt=0;
        while(sta<=re) {cnt++;sta*=cnt;}
        sta/=cnt; chan[++t] = cnt-1;
        changeit(re-sta);
    }
    int main()
    {
        int del;
        n = read(); m = read();
        for(int i=1;i<=n;++i) {v[i] = read();add(i,1);}
        for(int i=1;i<=n;++i) 
          {
            ans[i] = vfind(v[i]);
            add(v[i],-1);
```
}//提取出原排列的选取序
```cpp
        solve(m);//拆分m 
        for(int i=1;i<=t;++i) ans[n-chan[i]]++;//模拟进制式加法
        for(int i=n;i>=1;--i)
          while(ans[i] > n+1-i)
              {ans[i-1]++; ans[i] -= n+1-i;}//制表出新排列的选取序
        bool vis[10005] = {false};
        for(int i=1;i<=n;++i)//n^2水一水~ 
          {
              for(int j=1,ord=0;i<=n;++j)
                {
                    if(!vis[j]) ord++;
                    if(ord == ans[i]) {vis[j] = true; ans[i]=j;break;}
              }
            printf("%d ",ans[i]);
          }
        return 0;
}
```

---

## 作者：Rika (赞：3)

致力于提供更短的代码——（差不多能与那些使用STL的cpp代码有的一拼了）
```python
def add(ipt: list):  # 主要处理函数
    for _ in range(m):  # 循环m次
        for idx, elem in reversed(list(enumerate(ipt))):  # 从低位到高位搜寻
            available = set(range(elem + 1, n + 1)) & set(ipt[idx:])  # 判断在该位能否递增
            if elem != n and len(available) != 0:  # 若可以递增
                ipt[idx:] = [min(available)] + sorted(list((set(ipt[idx:]) | {elem}) - {min(available)}))# 递增该位并将低位顺序排列
                break
    return ipt
n, m = int(input()), int(input())# 接受输入
[print(__, end=' ') for __ in add([int(_) for _ in input().split()])]# 循环输出

```

---

## 作者：天狗的手帖 (赞：3)

楼下的神犇太强了，咱这讲个我等蒟蒻比较好懂的


我们发现这道题目其实就是让我们求某个指定字典序之后的第m个字典序，所以先讲一下朴素的搜索思路：搜索这n个数的全排列，发现当前全排列和指定字典序相同时开始记录答案，直到答案为m时输出当前搜索到的字典序。

但是假如直接去搜索长度为n(n<=10000)的字典序的话，显然会TLE。


所以我们要研究一下搜索出的字典序全排列的规律

1.当我们在搜索出某个指定字典序之后的第k个字典序时，他们的前x位是相同的，而在第x+1位那第k个字典序必然会大于指定字典序

2.假如这n个数是有序的，后搜索到的全排列和先搜索到的进行位比较时也严格有序

3.由1、2可见，假如我们把n个数从小到大排序之后搜索全排列，那么实际上对于任何一个比指定序列更小的搜索都是没有意义的。


同时我们还发现，这道题目虽然n很大，但是m是很小的

所以实际上，我们只要按从小到大的序列去搜索全排列，并把比指定的序列小的搜索结果都跳过，就可以快速得出答案了


由于人太弱无法分析时间复杂度，不过对于n=10000，m=100的数据这种方法还是可以轻松过的


```cpp

#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#define N 10005  
  
using namespace std;  
  
int p[N],data[N],tmp[N];  
int n,m,ans;  
bool flag,FLAG,hash[N];   

void solve(int k)  
{  
    if (FLAG) return;  
    if (k>n)  
    {  
        if (!flag)  
        {  
            flag=true;  
            return;  
        }  
        ans++;  
        if (ans==m)   
        {  
            for (int i=1;i<=n;i++) printf("%d ",p[i]);  
            printf("\n");  
            FLAG=true;   
        }  
        return;  
    }  
    for (int i=1;i<=n;i++)  
        if (flag or (tmp[i]>=data[k]) )  
            if (hash[i])  
            {  
                p[k]=tmp[i];  
                hash[i]=false;  
                solve(k+1);  
                hash[i]=true;  
            }  
    return;  
}  
  
int main()  
{  
    scanf("%d%d",&n,&m);  
      
    for (int i=1;i<=n;i++) scanf("%d",&data[i]);  
    for (int i=1;i<=n;i++) tmp[i]=data[i];  
    sort(tmp+1,tmp+n+1);  
    for (int i=1;i<=n;i++) hash[i]=true;  
    flag=false;FLAG=false;  
    ans=0;  
      
    solve(1);  
}  

```

---

## 作者：BonJour866 (赞：2)

萌新首篇题解：多多关照

------------
全排列的题，先上H2O代码，标准的十行
```cpp
#include<bits\stdc++.h>
using namespace std;
int n,m,a[10001];
int main(){
	scanf("%d%d",&n,&m); 
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	for(int i=0;i<m;i++)next_permutation(a,a+n);
	for(int i=0;i<n;i++)printf("%d ",a[i]);
	return 0;
} 
```
next_permutation(a,a+n);函数在algorithm里有定义，将数组a改为下一个全排列序列。

------------
再来个对next_permutation的伪造：
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
int n,m,a[10001];
int dfs(int*a,int n){
	for(int i=n-2;i>=0;i--){
		if(a[i]<a[i+1]){
			int j;
			for(j=i+1;a[j]>a[i]&&j<n;j++);
			swap(a[i],a[j-1]);
			sort(a+i+1,a+n);
			return 0;
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>a[i];
	while(m--)dfs(a,n);
			for(int p=0;p<n;p++)cout<<a[p]<<" ";
			cout<<"\n";
	return 0;
}
```
因为全排列的最终产物是一个递减序列，所以我们从最后一位开始找出那个不和谐的家伙(序号i)，再从i之后的递减序列中找到最靠近a[i]的比a[i]大的数（序号j），这样j就可以替换i了，后面的数们从新开始，执行m次，就是**AC**

最后\
CSP rp++;(^∇^*)

---

## 作者：江南小巫 (赞：2)

看了其他大牛们的代码，突然觉得我一个大蒟蒻的代码好短。。。(共27行)

(PS：其实没必要写那么长，三个循环的子函数就搞定了)

上代码！！！


```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,a[20000],i,j,t;

bool next(int p[],int n){ //数据存入p[0]~p[n-1]
    int i,j,t;
    for(i=n-2;i>0 && p[i]>p[i+1];i--); //从右向左，找第一个升序i (a[i]<a[i+1]) 
    if(i<0)return false; //当前是字典序
    for(j=n-1;p[i]>p[j];j--); //在i之后,找比a[i]大的最小元素a[j] 
    t=p[i];p[i]=p[j];p[j]=t; //a[i]与a[j]交换 
    for(i++,j=n-1;i<j;i++,j--){ //a[i+1]~a[n]逆置 
        t=p[i];p[i]=p[j];p[j]=t;
    }
    return true;
}

int main(){
    cin>>n>>m;
    for(i=0;i<n;i++)cin>>a[i];
    while(m--)next(a,n);
    for(i=0;i<n;i++)cout<<a[i]<<' ';
    return 0;
}
```

---

## 作者：AKB48 (赞：2)

各种全排列算法，大概一共有4种：字典序法，递增进位制数法，递减进位制数法，邻位对换法。

字典序:一自然数N，设N为3，则关于N的字典序排列为123，132，213，232，312，321，也就是把一个整数和比它小的整数的全排列由小到大的列出。求一个字典序的算法就是要能找出已得到排列的下一个排列，下一个即最临近的一个，列如前面的123，它的下一个就是132。具体的方法是有公式的，但是公式不易理解我就直接举列来说。如排列839647521，首先从最右端开始，找到第一个比它的右临位小的数字，即4，然后从该数字的右边找到比它大的最小的数字，即5，交换两数字，原排列变为839657421最后将5位置右端的数字倒序排列，即变为839651247，这就是原排列的下一排列。于是我们的程序就只需要从1234……n，开始不停的找它的下一排列，直到不存在比他的右临位小的数字（n……4321）为止。

此题数据不是很强可以直接模拟,数据规模大时用递归式求字典序.


---

## 作者：秀才加点冰 (赞：2)

生成全排列主要用的是递归的方法，但同时也有递推的写法，由于本题要求“m个状态之后的排列情况”，那么递推的方法是很容易想到的。




   
   
   
    

    

```cpp
#include<iostream>
#include<string>
#include<algorithm> 
using namespace std;
int n,m,a[10002],tmp; //定义变量，由于n<=10000，所以m<=n(n-1)/2在int的范围内。
int main()     //主函数
{
  cin>>n>>m;             //读入n、m
  for(int i=1;i<=n;i++) //循环n次 
   cin>>a[i];                 //读入原先的排列
                         //那么接下来，我们就要在这个排列的基础上，再进行m次递推
  int j,k;              //定义用于标记位置的临时变量
  for(int i=1;i<=m;i++)    //进行m次递推
  {
   for(j=n;j>=1&&a[j]<a[j-1];j--);       //从后往前检查，找出第一个非降序的项a[j-1]
   for(k=j;k<=n&&a[j-1]<a[k];k++);  //从该为向后检查，找到最后一个大于a[j-1]的数
   k--; 
                                //交换之
    tmp=a[j-1];
    a[j-1]=a[k];
    a[k]=tmp;
                               //那么现在由第j项到第n项仍是降序的
                              //因此将他们反序，使其变为升序，则此时达到了在1值j-1项不变的情况下最小的一项，从而继续递推即可
   for(int l=j;l<(n+j+1)/2;l++) //进行反序
   {
    tmp=a[l];      
    a[l]=a[n-l+j];
    a[n-l+j]=tmp;           //交换之
   }
  /*for(int i=1;i<=n;i++)    //在检查时可以用到此程序段
   cout<<a[i];
   cout<<endl;  */             //提交时别忘了删除哦
  }  
  cout<<a[1];                              //输出即可
    for(int i=2;i<=n;i++)              //(我也不知道最后一个空格能不能输出，总之这样分着写应该稳一些
   cout<<" "<<a[i];
return 0; //结束程序
}
递推全排列比较玄学，建议可以背下来。
```

---

## 作者：sqc1999 (赞：2)

用STL中的next\_permutation就行了

```cpp

#include<iostream>
#include<algorithm>
using namespace std;
int a[10000];
int main()
{
    int n,m;
    cin>>n>>m;
    for (int i=0;i<n;i++) cin>>a[i];
    int cnt=0;
    while (cnt<m)
    {
        next_permutation(a,a+n);
        cnt++;
    }
    for (int i=0;i<n;i++) cout<<a[i]<<" ";
    return 0;
}

```

---

## 作者：jinruihai_2006 (赞：1)

## 直接上代码
```
#include <cstdio>   
#include <iostream> 
#include <algorithm> 
#include <cmath> 
#include <cstdlib> 
#include <cstring> 
#include <vector> 
#include <list> 
#include <map> 
#include <stack> 
#include <queue> 
using namespace std; 
#define ll long long
int a[11111];
int main() 
{
	int n,m;
	while(cin>>n>>m)
	{
		for(int i=0;i<n;i++)
			cin>>a[i];
		while(m--)
			next_permutation(a,a+n);
		for(int i = 0;i < n-1;i++)
			cout<<a[i]<<' ';
		cout<<a[n-1]<<endl;
	} 
    return 0; 
} 
```
说了那么多的数据库其实……
用他就行了
```
#include<bits/stdc++.h>    
using  namespace std;         
int main() 
```
#### 谢谢各位大佬对本人的关心！！！


---

## 作者：s_ShotღMaki (赞：1)

# 先贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10010];
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	while(m--)
	next_permutation(a+1,a+n+1);
	for(int i=1;i<=n-1;i++)
	cout<<a[i]<<" ";
	cout<<a[n];
	return 0;
}
```
# 好了我知道你想问什么
所以我已经~~整♂理~~好了

```cpp
 STL提供了两个用来计算排列组合关系的算法，分别是next_permutation和prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。考虑三个字符所组成的序列{a,b,c}。

      这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序(lexicographical)的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。acb是次一个排列组合，因为它是固定了a(序列内最小元素)之后所做的新组合。

      同样道理，那些固定b(序列中次小元素)而做的排列组合，在次序上将先于那些固定c而做的排列组合。以bac和bca为例，bac在bca之前，因为次序ac小于序列ca。面对bca，我们可以说其前一个排列组合是bac，而其后一个排列组合是cab。序列abc没有“前一个”排列组合，cba没有“后一个”排列组合。

     next_permutation()会取得[first,last)所标示之序列的下一个排列组合，如果没有下一个排列组合，便返回false;否则返回true。这个算法有两个版本。版本一使用元素型别所提供的less-than操作符来决定下一个排列组合，版本二则是以仿函数comp来决定。
算法思想：

1.首先从最尾端开始往前寻找两个相邻元素，令第一元素为*i,第二元素为*ii,且满足*i<*ii。

2.找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于*i的元素，令为*j，将i,j元素对调(swap)。

3.再将ii之后的所有元素颠倒(reverse)排序。


   举个实例，假设有序列{0,1,2,3,4}，下图便是套用上述演算法则，一步一步获得“下一个”排列组合。图中只框出那符合“一元素为*i,第二元素为*ii,且满足*i<*ii ”的相邻两元素，至于寻找适当的j、对调、逆转等操作并未显示出。
   
```
## RT
![1](http://thyrsi.com/t6/649/1546506438x2890174315.jpg)

## 举个例子

题目 输出1234的所有字典序

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int ans[4]={1,2,3,4};
	sort(ans,ans+4)/这个sort可以不用，因为{1234}已经排好序
	do/注意这步，如果是while循环，则需要提前输出
	{
		for(int i=0;i<4;++i)
			cout<<ans[i]<<" ";
		cout<<endl;
	}while(next_permutation(ans,ans+4));
	return 0;
}
```
# 学会了嘛qwq

---

## 作者：总想玩世不恭 (赞：1)

运用c++ stl库里面的next\_permutation函数。

这函数，非常的有用。

主要作用为：生成所有比当前排列大的排列，顺序是从小到大。

举个例子，有个12345的排列，这函数就自动帮你往后生成。

具体模板为：

开一个数组a【】={1 ，2 ，3 ，4，5}

while（next\_permutation（a，a+n））

```cpp
{
   for(int i=0;i<n;i++)
     cout<<a[i];
}
```
大家可以动手试一试的...还有一个相反的函数，叫prev\_permutation()，作用就是生成比原排列小的排列

底下贴一发代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000000],b[1000000];
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
     cin>>a[i];
     int ok=0;
    int i=0;
    while(next_permutation(a,a+n))//由于返回值是bool类型，要输出第m大的，想了半天就想了这么个办法
    {
       i++;
           if(i==m)
           {
               for(int j=0;j<n;j++)
                cout<<a[j]<<" ";
               ok=1;
           }
        else if(i<m) continue;
        else if(ok) break;   
    }
    return 0;
}
```

---

## 作者：1261687299kid (赞：1)

看了其他的题解，我觉得都还是有点难懂的，其实还有一个更简单的方法。可以直接进行全排列。由于m<=100,所以只要从给的数开始进行全排列，第m+1个就是需要的数。不管n多大，只需要列举m次

```cpp
var
  a,f:array[1..10000] of longint;
  b:array[1..10000] of boolean;
  n,m,i,x:longint;
procedure wm(j:longint);
  var i,k:longint;
  begin
    if j=n+1 then begin //当j=n+1时，说明列举好了一个
                    inc(x);
                    if x=m then
                      begin
                        for i:=1 to n-1 do//输出
                          write(f[i],' ');
                        write(f[n]);
                        halt;//这个过程可能有些人没见过，这是直接退出整个程序
                      end;
                    exit;
                  end;
    if x=-1 then k:=a[j] //当x还等于-1的时候，可以直接从a[j]开始，节省时间
            else k:=1;
    for i:=k to n do
      if b[i] then// 这里就是普通的全排列，不作说明
        begin
          f[j]:=i;
          b[i]:=false;
          wm(j+1);
          b[i]:=true;
        end;
  end;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      read(a[i]);
      b[i]:=true;
    end;
  x:=-1;//当x=m时，就已经列举到了+m后的数
  wm(1);
end.
```

---

## 作者：翠竹叶飞 (赞：1)

寻找排列的后继，方法：每次找到最长降序的后缀，那么前面位置的数待更新，

把它变成稍大的那个数，更新后面即可

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int i,n,m,x;
int a[10001];
void swap(int &a, int &b)
{
    int t = a;
    a = b;
    b = t;
}
int search()
{
    int maxn=a[n],p=n-1;
    while (a[p] > maxn) //寻找最长降序的后缀 
    {
        maxn = a[p];
        p--;
    }
    int minn=maxn,r;
    for (int i=p+1; i<=n; i++)
      if (a[i] > a[p] && a[i] <= minn)
      {
          minn=a[i];
          r=i;
      }
    swap(a[r],a[p]); //将第1位变大1，后面的排列 
    return p+1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1; i<=n; i++)
      scanf("%d",&a[i]);
    for (i=1; i<=m; i++)
    {
        x = search();
        sort(a+x,a+n+1); //最小排列 
    }
    for (i=1; i<=n; i++)
      printf("%d ",a[i]);
    return 0;
}
```

---

## 作者：multiverse_ (赞：1)

### 一道链表题

 ~~蒟蒻我是stl的忠实粉丝，因为我懒~~ 
 
然而这道题目如果用stl的链表会非常的烦，蒟蒻我编译一大堆错，交上去还要RE

于是发现手工链表非常简单，于是就0编译错误，开心的AC了

（有时候stl是个宝，如火星人（50行压到10行），有时候非常的烦，如此题）
	 
程序的核心就在这里：
	
	如果将a插在b的右边
		1.a的右指向b
		2.a的左变成了b的左
		3.b的左变成了a
		4.（最容易遗漏的一点）：
		   b原来左边那个数的右边要指向a 
		   
	如果把a删掉：
		1.把a左边的数的右边指向a右边的数
		2.把a右边的数的左边指向a左边的数 
	（是不是很像绕口令） 
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
bool erased[100010];//记录第i个数有没有已经被删除 
struct info{
	int left,right;
	
}a[100010];
//对于a[i],i为此数，left为此数的左节点的编号， right为此数的左节点的编号
int head=1;//维护头部的下标，遍历时方便 
int main() {
	cin>>n;
	a[1].left=0,a[1].right=0;
	//开始时，节点1的左右都是0（没有节点） 
	for(int i=2;i<=n;i++){
		int num,opt;
		cin>>num>>opt;
		if(opt==0){
			a[a[num].left].right=i;//对应4
			a[i].left=a[num].left;//对应2
			a[num].left=i;//对应3 
			a[i].right=num;//对应1 
			if(a[i].left==0)head=i;//如果左边为空更新头部编号 
		}else if(opt==1){//和上面差不多，左右颠倒一下就行 
			a[a[num].right].left=i; 
			a[i].right=a[num].right;
			a[num].right=i;
			a[i].left=num;
			if(a[i].left==0)head=i; 
		} 
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		if(erased[x]==true)continue;//如果已经把此数删掉过了就不删了 
		int zuo=a[x].left,you=a[x].right;
		a[zuo].right=you;
		a[you].left=zuo;
		if(a[you].left==0)head=you;//更新头部 
		erased[x]=true;//打标记 
	}
	int p=head;
	while(p!=0){
		cout<<p<<" ";
		p=a[p].right;
	}
	cout<<endl;
	//输出链表 
	return 0;
}
```
    

---

## 作者：姜一洲 (赞：1)

通过next\_permutation()这题可以轻松实现，其实就是全排列。。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,k,i,a[10002];
int main(void){
    scanf("%d%d",&n,&k);
    for (i=1;i<=n;++i) scanf("%d",&a[i]);
    while(k!=0) --k, next_permutation(a+1,a+n+1);
    for (i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
```

---

## 作者：毛梁智洲666 (赞：0)

看到这道题，我一下子想到了一个函数：

 next_permutation ！！！

这个函数可以自动生成下一个数。

格式为：
```
do{

...

}while(next_permutation(a,a+n));
```

但是，这不是考试，是刷题！next_permutation的原理是什么？是怎么写出来的？这些，我们也许也需要明白！

当然，我翻了一下，也有许多人手写了next_permutation，但是我没有看到与我的方法重复的方法！

排序？这是必定的（可以用sort，但我手写了）。

```
for (i = n - 1; i >= 1; i--) {
    for (j = n; j >= i + 1; j--) {
        if (x[i] < x[j]) {
            swap(x[i], x[j]);           
        }
    }
}
```
**于是蜜汁TLE了**

所以得缩小一下范围...

取下一个数，改变后火星人手指的排列顺序：
```
if (i + 1 != n) {
    for (u = i + 1; u <= n - 1; u++) {
        for (v = u + 1; v <= n; v++) {
            if (x[u] > x[v]) {
                swap(x[u], x[v]);
            }
        }
    }
}
```

这下可以了。


上代码：
```
#include <bits/stdc++.h> //万能头文件
using namespace std; //声明姓名空间

int n, m, x[100000], i, j, u, v;

void next() { //相当于next_permutation
    for (i = n - 1; i >= 1; i--) {
        for (j = n; j >= i + 1; j--) {
            if (x[i] < x[j]) { //排序
                m--; //缩小下次的范围，使程序AC！
                swap(x[i], x[j]);
                if (i + 1 != n) { //核心部分
                    for (u = i + 1; u <= n - 1; u++) {
                        for (v = u + 1; v <= n; v++) {
                            if (x[u] > x[v]) {
                                swap(x[u], x[v]);
                            }
                        }
                    }
                }
                return ;
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (i = 1; i <= n; i++) {
        cin >> x[i];
    } 
    while (m > 0) {
        next();
    }
    for (i = 1; i <= n; i++) {
        if (i != n) {
            cout << x[i] << " ";
        } else {
            cout << x[i] << endl; //我写的太严谨，把if else去了，直接输出，也没问题
        }
    }
    return 0;
}
```

---

## 作者：gary2005 (赞：0)

这是一题很好的全排列题，但听说有人用stl的，我还是建议大家手打一下。

非常简单，首先全排列就是递归一层一层的算重复了就跳出。就像这样。
```cpp
void pailie(int now){
	if(flag) return;//是否找到答案
	if(now==n){
		for(int i=1;i<=n;i++){//判断是否已达到火星人表示的数
			if(ans[i-1]!=num[i]) break;//发现错误跳出
			if(i==n){//没有发现错误
				flag3=true;//可以开始计数
			}
		if(flag3){//开始计数
			if(!m){//计数结束
			flag=true;
			for(int i=0;i<n;i++) cout<<ans[i]<<" ";//输出
			}
			m--;//目标数-1
		}
		return;
	}
	for(int i=1;i<=n;i++){//从最小的‘1’开始
		if(check[i]==true) continue;//已被表示
		check[i]=true;//已表示
		ans[now]=i;//记录当前答案
		pailie(now+1);//下一个全排列
		check[i]=false;//回溯
	}
	return;
}
```
# 但是会超时！
![](https://cdn.luogu.com.cn/upload/pic/46838.png)
真的非常惨，都跑到9000ms了

但是我们发现在火星人表示的数前的计算都是无用的，所以我们只要从火星人的手指处开始算就好了。于是剪枝方案就完成了。

我们发现：
火星人的手指：
```pascal
1 5 3 2 4
```
那要比他大就必须第一位至少要≥1如果大于了那后面随便什么数都可以了，我们可以设置一个flagbig=false是否前面有>num[i]的（注意是>如果没有就从num[now]开始取）
具体看下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[10001]={0};
int ans[10001]={0};
bool check[10001]={0};
int n;
int m;
long long times=-1;
bool flag=false;
bool flagbig=false;
void pailie(int now){
	if(now==0) flagbig=false;
	if(flag) return;
	if(now==n){
		times++;
		if(m==times){
		flag=true;
		for(int i=0;i<n;i++) cout<<ans[i]<<" ";
		}
		return;
	}
	for(int i=1;i<=n;i++){
	if(i>=num[now+1]||flagbig){
		if(i>num[now+1]) flagbig=true;//只有>才可以
		if(check[i]==true) continue;
		check[i]=true;
		ans[now]=i;
		pailie(now+1);
		check[i]=false;
	}
	}
	return;
}
int main(){
	cin>>n>>m;
	
	for(int i=1;i<=n;i++){
		cin>>num[i];
	}
	if(m==0)for(int i=1;i<=n;i++){//0特判
		cout<<num[i]<<" ";
	}
	pailie(0);
	return 0;
}
```
这时候就只有400ms了.
## AC!!

---

## 作者：bzy369258147 (赞：0)

/\*###其实代码很短的，25行递推就可以了AC\*/

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//流操作命名空间
//手指数组10000
int finger[10000];
//主函数
int main(){
    int a,b;cin>>a>>b;//输入总数与加数
    for(int i=0;i<=a-1;i++)cin>>finger[i];//输入手指
    for(int i=0;i<=b-1;i++){
         //加多少就操作几次；
        for(int j=a-1;j>=1;j--){
                //从尾部查询，查到可以交换的就用sel记录值,point记录位置，若有更小符合要求，就更新。
                int sel=65536,point=a;
            for(int u=a-1;u>=j;u--){
                if(finger[u]>finger[j-1] and finger[u]<sel){point=u;sel=finger[u];}    //更新
            }
            if(point^a){//位运算等价于！=；表示为找到可以交换的数字，否则搜索下一位
                int tmp=finger[point];finger[point]=finger[j-1];finger[j-1]=tmp;//交换
                sort(finger+j,finger+a);break;//将交换后的后位重新排序
            }
        }
    }
    for(int k=0;k<=a-1;k++)cout<<finger[k]<<" ";//输出
    return 0;
}
```

---

## 作者：hz1624917200 (赞：0)

应该是一道全排列吧

因为m<=100，所以我们可以一次次模拟它的进位情况。

我的启发是行驶里程表，末尾数到“9”后，末尾的“9”全部清零，它的上一位进位。

本题也一样，只要找到以最后一个元素为尾的最长不升连续子序列，它的前一位必须要“进位”。

既然要进位，就必须在后面找一个大于它的最小的数，将他们两个交换。

由于以上交换，不升连续子序列的性质并没有被破坏（可以自己模拟下）。

接下来就是清零了，就要找出子序列里字典序最小的（就是子序列的不降排列）。

个人认为不需要重新排序，由于有不升子序列的性质，翻转后就可得到不降排列。

然后，附代码：

[codep ]




```cpp
program p1088;
var
  a:array[0..10500] of longint;
  n,m,i:longint;
procedure swap(var a,b:longint); //用于翻转、交换
var
  t:longint;
begin
  t:=a;
  a:=b;
  b:=t;
end;
procedure succ;  //求下一个排列
var
  i,p:longint;
begin
  p:=n;
  while (p>1) and (a[p]<a[p-1]) do dec(p);  //找最长不升连续子序列
  dec(p);  //交换位
  for i:=n downto p+1 do  //找大于它的最小值
    if a[i]>a[p] then
      break;
  swap(a[i],a[p]);
  for i:=p+1 to (n+p) div 2 do  //p+(n-p) div 2=(n+p) div 2  //翻转
    swap(a[i],a[n+p-i+1]);
end;
begin
  readln(n);
  readln(m);
  for i:=1 to n do
    read(a[i]);
  for i:=1 to m do
    succ;
  for i:=1 to n do
    write(a[i],' ');
  writeln; 
end.
[/codep ]
```

---

## 作者：Juliet (赞：0)

实际上当年noip不允许使用stl模板，所以用next\_permutation()的可以走开了；

下面的代码片断即用来定位一个排列到下一个排列的第一个变化位置。

```cpp
[color=red]
for(j=n-1;j>=1;j--)//找到最后可增加的位，即定位 
  if(b[j]<b[j+1])//例如12354的第一个变化位置为3 
    break;
```
[/color]
找到了第一个变化位置b[j]，那么b[j]和后面的哪一位数交换呢？显然是从右往左数，第一个大于b[j]的数。下面的代码片断即用来定位与第一个变化位置交换的数字。

```cpp
[color=red]
for(k=n;k>=1;k--)//定位可交换的数字 
  if(b[k]>b[j])//例如12354与3交换的数字是4 
    break;
```
[/color]
那么，是不是两个数字互相交换一下，即是下一个排列了呢？显然不是，例如12354交换后的排列为12453，而实际上12435才是正确的结果。所以还需对第一个变化位置后面的数字进行由小到大的排序。




     
     

```cpp
[color=red]
#include <iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int b[10000+1]; 
int i,j,k,m,n,t;
void init()
{
  cin>>n>>m;
  for(i=1;i<=n;i++)
    cin>>b[i];
}
void out()
{
  for(i=1;i<=n-1;i++)
    cout<<b[i]<<' ';
  cout<<b[n]<<endl;
}
void work()
{
  for(i=1;i<=m;i++)//增1 共M次 
  {
     for(j=n-1;j>=1;j--)//找到最后可增加的位，即定位 
       if(b[j]<b[j+1])//例如12354加1，则只有3可增加位数 
         break;
     for(k=n;k>=1;k--)//找到最小可增加的数字 
       if(b[k]>b[j])//例如12354加1，最小可增加的数字是4 
         break;
     t=b[j];//交换，把原排列增大 ，
     b[j]=b[k];//例如12354加1，即3和4交换，交换结果为12453 
     b[k]=t;  //但12453并不是最终结果，而是12435即要排序 
     j=j+1;//向后移一位 
     k=n;
     while((j<k))//把后面的逆序，相当于从小到大排序 
     {
       t=b[j];  
       b[j]=b[k];
       b[k]=t;
       j++;
       k--;
     }
  }
}
int main()
{
  init();
  work();
  out();
  return 0;
}
[/color]
```

---

## 作者：peter·z (赞：0)

这其实是一道非常“下流”（别介意）的题目，

我来给几个例子

12345

首先 他先把最后一段降序的找出来——“12345”中

只有最后一个“5”是降序（单独一个）

所以把降序前面的那个数——x（在本例中是“4”）跟降序里面比x大的最小数交换

变成“12354”


第二步再把“12354”中的降序找出——“54”是降序

于是把降序前面的“3”与降序中最小的数“4”对调——变成“12453”

但还没完，必须把最后调过位置的将序列排序

变成“12453”

接下来就是以此类推了~

附上核心程序

 ```delphi
for i:= 1 to m do
  begin
    sum:=maxlongint;
    o:=n-1;
    while a[o+1]<a[o] do begin dec(o); end;{求出降序序列长度}

    for k:= o+1 to n do
    begin
       if a[k]>a[o] then
       begin
         if a[k]<sum then begin sum:=a[k];total:=k;end;
       end;
    end;{找出比“x”大的最小的数}

    tmp:=a[total];
    a[total]:=a[o];
    a[o]:=tmp;{交换位置}
    qs(o+1,n);{快排降序数列}
  end;
```
加油吧，骚年们~


---

## 作者：keyingkai (赞：0)

我用的是[color=heliotrope]临位交换法[/color]

先举个例子:

1 2 3 4\_ 5    ->1 2 3 5 4

1 2\_ 5 4 3    ->1 3 2 4 5

1\_ 5 4 3 2    ->2 1 3 4 5

大家观察前一个数字，它后面的数到最后一个数都是一个下降的，而它加上前面这个数却不是下降的了。

而在进一步观察就可以发现它前面的这个数的位置将要与最后一个数交换，然后把下划线后面的数进行反转，就可以了。


代码:

```delphi

{$A+}\编译器开关，加快运行速度
var
  i,m,n:longint;
  a:array[1..5000] of longint;
procedure swap;
var i,p,min,k,t:longint;
begin
  p:=n-1;min:=n;
  while(a[p]>a[p+1]) do dec(p);\找到需要交换的两位
  for i:=p+1 to n do
    if(a[i]-a[p]<min) and (a[i]-a[p]>0) then
     begin
       min:=a[i]-a[p];
       k:=i;
     end;
  t:=a[k]; a[k]:=a[p]; a[p]:=t;
  for i:=p+1 to (n-p)div 2+p do begin  t:=a[i]; a[i]:=a[n+1-i+p]; a[n+1-i+p]:=t;end;\反转
end;
begin
  readln(n);
  readln(m);
  for i:=1 to n do read(a[i]);
  for i:=1 to m do swap;\计算下一个全排列的值
  for i:=1 to n do write(a[i],' ');
end.

```

---

## 作者：CJHGOD (赞：0)

不要费心做全排

要知道，STL容器中，有一个~~神奇的~~——

next_permutation!!!

next_permutation!!!

next_permutation!!!

你n行的事情，十几行搞定

# ~~（其实这就是一个变态版的全排列）~~

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,a[10100];
	int t=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	while  (next_permutation(a+1,a+n+1)){
		t++;
		if(t==m)break;
	}
	for(int i=1;i<n;i++)cout<<a[i]<<" ";
	cout<<a[n];
	return 0;
}

```


---

## 作者：AdzearDisjudge (赞：0)

此题意思就是加一个数，就向前进行一次全排列。

考虑stl的全排列函数，并且可以适当优化。

（PS：被zcy神犇嘲讽了以后，我再也不会在题解里写此题大水了！！！）

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],n,m;
int main()
{
    cin>>m>>n;
    for(register int i=0;i<m;++i)
    cin>>a[i];
    for(register int i=1;i<=n;++i)
    next_permutation(a+0,a+m);//全排列函数
    for(register int i=0;i<m;++i)
    cout<<a[i]<<' ';
    return 0;
}
//PS：%%%红太阳thx！！！
```

---


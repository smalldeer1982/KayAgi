# 碧树

## 题目背景

[English statement](https://www.luogu.com.cn/problem/U505210). **You must submit your code at the Chinese version of the statement.**

小 T 不知道交流是什么。

是为了弄懂一串奇怪的符号，然后再把它放入他人的大脑吗？

是为了得到一些抽象的知识，然后再用它打破自己的习惯吗？

为了交流，小 T 最终决定接通了 $\text{220V}$ 的电压。

## 题目描述

> t1k1x1ww。

小 T 注视着这一串自己不能理解的符号，决定先和你交流一个 OI 题目。

小 T 有一棵有根树，它共有 $k$ 个叶子结点，同时他还告诉了你，其叶子结点的深度分别为 $a_1\dots a_k$。请你帮他计算，这棵树最少包含多少个结点。小 T 保证存在至少一棵这样的树。

如果您不熟悉题面中的若干定义，我们乐意提醒您：

- 图上的 **简单路径** 指一条经过顶点不重复、经过边不重复的路径。
- 一棵 **树** 是一张联通，且任意两点之间有且仅有一条简单路径的图。在一棵树里，我们会选择一个节点为根结点。
- 树上的 **叶子结点** 为不是根结点，且度数为 $1$ 的结点。
- 树上一个节点的 **深度** 是该结点到根结点的简单路径上结点的个数。

## 说明/提示

### 样例解释

- 对于第一组数据，下面是一棵可能的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/kh6cgtyp.png?x-oss-process=image/resize,m_lfit,h_400,w_400)

其大小为 $8$，其中叶子 $3, 5, 6, 8$ 的深度分别为 $2, 3, 4, 5$。容易证明没有大小 $\leq 7$ 的树符合题意。

### 数据规模与约定

**本题采用捆绑测试和子任务依赖。**

- Subtask 0（0 pts）：样例。
- Subtask 1（30 pts）：$k = 2$。
- Subtask 2（30 pts）：$a_1 = a_2 = \dots = a_k$。
- Subtask 3（40 pts）：无特殊限制。依赖于子任务 $0 \sim 2$。

对于所有数据，保证 $1 \leq k \leq 10^5$，$2 \leq a_i \leq 10^5$，且保证存在至少一棵这样的树。

## 样例 #1

### 输入

```
4
2 3 4 5```

### 输出

```
8
```

## 样例 #2

### 输入

```
7
6 6 7 8 4 2 4```

### 输出

```
14
```

# 题解

## 作者：HYLW (赞：4)

> 以学献教，以教献学。

## 前置知识

**有根树**，即有明确根的树形图，例如下图就是一个以不同字母为节点的树状结构（或说图）。\
其中标记了 $\text{\color{red}end}$ 的就是**子叶节点**，即没有子节点的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/y7taksol.png)

**深度**如题所述，就是节点到根节点的简单路径上节点的个数，根节点的深度即是 $1$。

## 题目描述

[原题链接](https://www.luogu.com.cn/problem/P11242)

存在一棵树，已知树的子叶节点数量及其对应所在深度，求这样一棵树最少可以有多少个节点？

## 题解

那么首先分析一下可能存在的答案，手搓一个例子如下：

```
2
2 3
```

对于答案（指满足要求的树）来讲，她可以是下图中三棵树中的任意一个，

![](https://cdn.luogu.com.cn/upload/image_hosting/89n7nacl.png)

但是显然我们需要其中节点数最小的那个，观察发现，

- 若她节点数尽量少，则**其最深节点的深度不应当超过要求子叶节点中的最深深度**，因为若树的深度大于要求子叶节点中的最深深度，那么一定会导致存在更多节点，例如如比较上图右一和右二，显然后者更优；
- 为了使她节点数尽量少，应当尽量**避免过多的无意义分支，所有的分支存在的意义就是构造所需的子叶节点**；

那么此时我们发现，我们可以以第一个发现为基础，**先构造一个条线性节点的树**以**满足树中最深节点深度等于要求子叶节点的深度**，   
接着，显然其他子叶节点都可以以这条线（链）上的深度减一的节点为父节点，**一个一个接上去**。

![](https://cdn.luogu.com.cn/upload/image_hosting/4wszj2bu.png)

此时我们发现，树中每个节点都是必不可少的，不可能再删去某个节点，否则不满足要求。

于是我们得到答案，即是 $\max\limits_{1\leq i\leq n}(a_i)+n-1$。

## 样例代码

还需要 std 吗？放一个赛时代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	int n,ma=0;
	scanf("%d",&n);
	for(int i=1,a;i<=n;i++)
		scanf("%d",&a),ma=max(ma,a);
	printf("%d",(ll)ma+n-1);
	return 0;
} 
```

## 闲话好说

- 比赛时校队组团比赛，这题在线性代数大佬（
  @JustPureH2O）手上没撑过 $10$ 分钟，震惊全队，然后我最后一个做出这道题。
- 第一张图其实是搬自[字典树](https://www.luogu.com.cn/article/ctydoy6a)的图，偷个小懒～

---

审核管理员辛苦了，谨以个人对你们对社区的贡献表示无限的感谢！

---

## 作者：Aventurine_stone (赞：3)

## 1. 题目分析
这道题题面有树，但其实就是一个简单的结论题，~~样例解释都把结论喂你嘴里了~~，注意一下输入的是**叶子节点**即可。
## 2. 题目做法
题目要我们包含的节点数最少，又因为输入的是叶子节点，所以我们构造的树必须有一个主干，也就是一条没有叶子节点的链，所有的输入的数都连接在主干上。  
我们用主来表示主干上的节点，输来表示输入的节点，构造的树也就是下面这张图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/not9qac5.png)  
由于节点深度小于 $10^5$，我们可以用一个数组 $cnt$ 记录当前深度我们要放多少个叶子节点，并同时记录，深度最大的叶子节点深度为 $mx$，接下来只用从 $1$ 到 $mx$ 依次遍历 $cnt$ 数组即可，答案每次加 $cnt_i + 1$。由于这样算会使主干的结尾多一个点，所以最后让答案减一即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int n;
int a,mx,cnt[N],s;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a=read(),cnt[a]++,mx=max(mx,a);
	for(int i=1;i<=mx;i++)
		s+=cnt[i]+1;
	printf("%d",s-1);
	return 0;
}
```

---

## 作者：AkihabaraQ (赞：2)

# P11242 碧树
[题目传送门](https://www.luogu.com.cn/problem/P11242)


------------

### 提示：本篇题解较为详细，对树有基本了解的大佬请自觉~~忽略~~跳过普及知识并有选择性阅读部分内容。


------------


### 一、题意概括

给出一颗有根树中 $n$ 个叶子结点的深度，想要求出这棵树最少包含几个结点。


------------

### 二、普及知识（借鉴题面）
1.**简单路径**：指一条经过**顶点不重复**、经过**边不重复**的路径。

2.**度数**：一个结点拥有的**子树**的数目。

3.**父结点**：一般称**上**端结点为**下**端结点的父结点。

4.**子结点**：相对地，称**下**端结点为**上**端结点的子结点。

5.**树**：一张联通，且任意两点之间**有且仅有一条简单路径**的图。在一棵树里，我们会选择一个结点为**根结点**（**没有父结点**）。

6.**叶子结点**:不是根结点，且度数为*$0$ 的结点。

7.**深度**：一个结点到根结点的简单路径上**结点的个数**。

8.**层次**：**根结点**所在为第 $1$ 层，从根结点往下层数**依次递增**。

**（*：题面给的是 $1$ ，好像错了。当时做题时没仔细看，后来写题解发现了，在查阅相关资料后，发现叶子结点的度数应该是 $0$，即没有子结点（树））。**

光说概念~~有的人已经晕了~~理解的不彻底，我们来结合图例具体分析一下，看下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/q944jm7a.png)

（画图手搓，很不~~精美~~，还请各位海涵）。

对于这棵树来说（结合上述普及知识），其中：
- 根结点：$1$。
- 叶子结点：$3$、$5$、$7$、$8$、$10$。
- 各个深度的结点：(**1**)$1$；(**2**)$2$、$3$、$4$；(**3**)$5$、$6$、$7$；(**4**)$8$、$9$；(**5**)$10$。

讲完了前置知识，相信各位对树已经有了基本了解，~~虽然不多~~，但已经够我们解决这道题目了。


------------

### 三、题目分析
因为给出了 $n$ 个叶子结点的深度，显然的一个方面，结点个数将直接与这 $n$ 个结点的**深度的最大值**有关。可以类似理解为想要使结点达到这个最大深度，前面必须有一些结点为其“铺路”。

知道了这个，题目要求这棵树结点数目的最小值，考虑贪心思想。


------------

### 四、解题步骤
观察题面给出的图片：
![](https://cdn.luogu.com.cn/upload/image_hosting/kh6cgtyp.png?x-oss-process=image/resize,m_lfit,h_400,w_400)

发现图中除了所给出的满足深度要求 $n$ 个叶子结点以外，**不存在**其他叶子结点（~~好像~~是废话但是这其实是构造的思路）。
可以把整棵树理解为现实中的一棵树，我们想让它在某个高度（**深度**）长出一些枝条（**结点**），使这 $n$ 个枝条的高度满足题目要求，而在这个过程之中又要使枝条数**尽可能少**，则每次延伸深度尽可能花费少的枝条（ $1$ 个结点）。

到这里，这道题目的解已经显而易见了：读入 $n$ 个结点的深度，在这个过程中用一个变量 $ma$ 更新**深度最大值**，最后题目的答案即为 $ma-1$ 的值（可理解为达到这个深度所“**延伸**”的结点个数，之所以要 $-1$ 是因为根结点所代表的**深度** $1$ 在一开始已经准备好，只需要从**深度** $2$ 开始继续向下延伸），加上 $n$ （叶子结点的个数，此处由叶子结点的定义可得，叶子结点**没有**子结点，故其本身不能起到“延伸”作用，可理解为“**树干**”上分出的“**树枝**”）。


------------

### 五、代码实现
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int ans=0;	//答案初始化为0，虽然可以不加，但还是养成好习惯啊 
int main(){
	scanf("%d", &n);	//读入n
	int ma = -1e9;    //初始化ma为一个极大值，以便后续更新 
	for(int i = 1; i <= n; ++i){
		int x; 
		scanf("%d", &x);	//读入叶子结点的深度 
		ma = max(ma, x);	//更新深度的最大值 
	}
	ans += ma - 1 + n;    //计算答案 
	printf("%d\n", ans);    //输出 
	return 0;
}
```


------------

---

## 作者：___AaAa_bBcCd___ (赞：2)

不嫩发现可以每次记录树去掉最高非叶子节点的深度  $high$，如果当前 $a_i$ 比 $high$ 大则要在原先 $high$ 的基础上新建 $a_i-high$ 个节点（本质就是从最高的非叶子处旁逸斜出一条树枝使得这条树枝的叶子深度为 $a_i$），否则直接从之前的某个非叶子处加上一个叶子。

如 `6 6 7 8 4 2 4`，先建立起一条深度为 $6$ 的链，然后对于第二个节点，从深度为 $6-1=5$ 的非叶子节点出伸出一个子节点，之后的 $7$ 则从 $5$ 处伸出一个 $6$，再垒上一个 $7$；$8$ 同理，不能用之前的叶子节点。对于 $4$ 则从深度为 $3$ 的中间节点处伸出一条枝干，$2$、$4$ 同理。见图（按黑红橙黄绿蓝紫顺序）：

![](https://cdn.luogu.com.cn/upload/image_hosting/63euyudw.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,high,sum,a[100001];
int main(){
    cin>>k;
    for(int i=1;i<=k;i++){
        cin>>a[i];
        if(a[i]>high){
            sum+=a[i]-high;
            high=a[i]-1;
        }
        else{
            sum++;
        }
    }
    cout<<sum;
    return 0;
}
```

[可以 AC](https://www.luogu.com.cn/record/186990549)。

---

## 作者：Zskioaert1106 (赞：1)

题目传送门：[P11242 碧树](https://www.luogu.com.cn/problem/P11242)

本题考察简单的树论。

### 思考过程

从 $n$ 个叶子里找到最深的一个 $a_{mx}$，则满足它的最小树是一条深度为 $a_{mx}$ 的链。

对于其它的 $n-1$ 个叶子节点，我们总能给在这个链上的某个非叶子节点添加一个叶子满足它的要求。

以样例 1 为例，可以想象成在一个深度为 $5$ 的链上加了 $3$ 个叶子节点。

所以答案为 $n-1+\max(a_1,a_2,\dots,a_n)$。这样构造的树是只有 $n$ 个叶子节点的，并且删掉任意一个非叶子都会使最高的叶子深度改变。

### 代码编写

```cpp
#include<iostream>
using namespace std;
int main(){
    int n,a,mx=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a;
        mx=max(mx,a);
    }
    cout<<mx+(n-1);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/186666111)。（编号是 $\texttt{186666111}$ 诶）

---

## 作者：DDD_et (赞：0)

# P11242 Solution

**做法：找规律**

## 题意

给你 $k$ 个叶子结点的深度 $a_1 \dots a_k$，问这棵树最小节点数是多少。

## 思路

首先，假设当前在某一层有 $p$ 个叶子结点，那么由于这 $p$ 个节点是叶子结点，所以这一层至少有 $p+1$ 个节点；因为需要多出一个节点来“传宗接代”，连到下一层，否则就没有下一层了（这也告诉我们最后一层只需要 $p$ 个节点，因为本来就没有下一层了）。

那么可以统计 $\max_{i=1}^{k} a_i$，表示树的最大深度，并用一个桶数组记录每层的叶子结点个数，用一个变量记录总答案数即可。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, t[N], maxx;
long long sum; //保险开long long

int main ()
{
    cin >> n;
    for (int i = 1; i <= n; i ++)
    {
        int x; cin >> x;
        t[x] ++, maxx = max (maxx, x);
        //t是桶数组，maxx是最大层数
    }
    for (int i = 1; i <= maxx; i ++)
        sum += t[i] + 1; //就算这一层没有节点也要多一个连到下一层，这也是为什么要记录最大层数
    cout << sum - 1; //最后一层不用多加，减1即可
    return 0;
}
```

### 写在最后

评橙很合理，属于中位橙。

**谢谢观看！**

---

## 作者：none_note4763 (赞：0)

## 题目大意

给定你 $k$ 个叶子节点，构造一棵树，使得节点数最少，并输出最少的节点数。

## 解题思路

首先看两个有特殊性质的子任务。

先看 $a_1 = a_2 = \dots = a_k$ 这个特殊性质。这个性质意味着所有叶子节点的深度是相同的。由于题目要求节点数最少，所以，我们可以从根节点引出长度为 $a_1-1$ 的一条链（这里用 $a_1$ 举例，这里换成任意的 $a_i$ 都成立），然后在 $a_1-1$ 号节点引出一个 $k$ 叉树即可。答案即为 $a_1-1+k$。

再看 $k=2$ 这个特殊性质。这个性质表示只有 $2$ 个叶子节点。那么，我们就可以取 $a_1$ 和 $a_2$ 的最大值，构造长度为两数最大值的链。我们已经构造出一个叶子节点，剩下一个叶子节点再额外添加一个节点，与深度为 $\max(a_1,a_2)+1$ 的节点连接即可。

再看一遍题目，我们就有思路了。我们就可以取 $a_1,a_2,\dots,a_k$ 的最大值（这里记为 $q$），构造一个长度为最大值的链，对于剩下 $k-1$ 个叶子节点，将深度为 $a_i-1$ 的节点与一个深度为 $a_i$ 的新叶子节点连接即可。答案即为 $q+k-1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int k,maxx=-1;
    cin>>k;
    for(int i=1;i<=k;i++){
        int l;
        cin>>l;
        maxx=max(maxx,l);
    }
    cout<<maxx+k-1<<endl;
}
```

---

## 作者：Claire0918 (赞：0)

我们发现叶子节点是互相独立的。具体来说，它们之间不会互相影响。于是答案只与最深点相关。

我们考虑构造一个长度为 $\max\{a_i\} - 1$ 的链，然后对于每个 $a_i$ 在链上找到一个 $dep_u = a_i - 1$ 的节点，将第 $i$ 个叶子节点作为 $u$ 的儿子。

这样显然是可以构造的。同时又必须要存在深度为 $\max\{a_i\} - 1$ 的点，所以这样是最优的。答案即为 $\max\{a_i\} + n - 1$。

时间复杂度同输入。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

int n, res = -1;

int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
        int a;
        scanf("%d", &a);
        res = max(res, a);
    }
    printf("%d", res + n - 1);

return 0;
}
```

---

## 作者：Camellia2025 (赞：0)

看样例解释，记 $maxn$ 为深度最大的值，不难想到可以在一条长度为 $maxn - 1$ 的链上维护，如果有一个深度 $val$ 的节点，那么就在深度为 $val - 1$ 的链节点上面新引一条边连接该节点，既保证了该节点一定是叶子节点，又用最少的长度连接起来，因为只用了一条链作为连接。

最后答案就为输入的节点个数加上链节点个数。

### code


```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int n, maxn;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int v;
		cin >> v;
		maxn = max (maxn, v);
	}
	cout << n + maxn - 1;
	return 0;
}
```

---

## 作者：篮网总冠军 (赞：0)

毫无难度的思维题。

我们统计出最大深度，再给每个深度出现的次数记录一下，接着依次枚举每个深度就好了。

$s_i$ 代表 $a$ 数组中元素为 $i$ 的数量。

第 $i$ 需要的节点数为 $s_i+1$。

最后不要忘了给答案减 $1$。

其实有更简单的方法，但不想想了。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100005]; 
int s[100005];
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int k;
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];
		s[a[i]]++;
	}
	int cnt=0;
	sort(a+1,a+1+k);
	int r=a[k];
	for(int i=1;i<=r;i++){
		cnt+=(s[i]+1);
	} 
	cout<<cnt-1<<endl;
	return 0;
}
```

---

## 作者：wuyouawa (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11242)

### 思路

随便找几棵树算，可以发现规律是 $k+a_i$ 中的最大值再 $-1$，然后直接输出即可，找一棵树算的过程就是先把叶子节点画出来，缺少的且应补的补上，最后再数。

### CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ma;//由于最大值，所以赋一个比a[i]小的值，也就是小于2的值
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)  cin>>a[i],ma=max(ma,a[i]);//求最大值
    cout<<n+ma-1;//规律
    return 0;
}
```

---

## 作者：MnZnOIer (赞：0)

### 解题思路
根据题意，我们可以先构造出一条链，深度为 $\max_{i=1}^n{a_i} - 1$。这个时候，对于每个叶子结点的深度，我们在该叶子结点深度加一的位置连一条边，并且不再在下面连边，那么就满足了一个条件，以此类推。

关于这个做法的正确性：首先，我们的树高一定不会超过叶子结点的最大深度，对于一个叶子结点，最优的情况就是路径尽量的重合，所有叶子结点的路径重合的部分就会是一条链，在它高度加一的位置连一条边，形成一个叶子结点。如样例图。

![图挂了去题面上看](https://cdn.luogu.com.cn/upload/image_hosting/kh6cgtyp.png?x-oss-process=image/resize,m_lfit,h_400,w_400)

显然，这棵树除掉叶子结点就是一条深度为 $4$ 的链，即最深的叶子结点的深度减一。

### 代码部分
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, c[100005], a, dep, ans;
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n;
	for (int i = 0; i < n; ++ i)
	{
		cin >> a;
		++ c[a];//统计该深度的叶子结点的数量。
		dep = max (dep, a);//因为最深的叶子结点可能不止一个，所以只能在最后的答案处减一。
	}
	for (int i = 2; i <= dep; ++ i)ans += c[i];
	cout << ans + dep - 1;//这条链的深度要减一。
	return 0;
}
```

---


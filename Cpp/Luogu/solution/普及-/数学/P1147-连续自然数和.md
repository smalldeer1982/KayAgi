# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# 题解

## 作者：gzw2005 (赞：525)

## 本蒟蒻第一篇题解

设首项为 $L$，末项为 $R$，那么 ${\rm sum}(L,R)=\dfrac{(L+R)(R-L+1)}{2}=M$.

即 $(L+R)(R-L+1)=2M$.

可以把 $2M$ 分解成两个数之积，枚举假设分成了两个数 $k_1,k_2$，我们令 $k_1<k_2$，

可以列一个二元一次方程组$\begin{cases}
R-L+1=k_1\\
L+R=k_2
\end{cases}$，

解得 $\begin{cases}
L=\dfrac{k_2-k_1+1}{2}\\
R=\dfrac{k_1+k_2-1}{2}
\end{cases}$.

显然当 $k_1,k_2$ **一奇一偶** 时，$L,R$ 才是整数.

但是 $L=R$ 的情况是被不允许的，

即 $\dfrac{k_2-k_1+1}{2}\neq\dfrac{k_1+k_2-1}{2}$，即 $k_1\neq1.$


```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
int main(){
    cin>>m;
    for(int k1=sqrt(2*m);k1>1;k1--)//枚举k1(注意是k1>1而不是k1>=1)
        if(2*m%k1==0 && (k1+2*m/k1)%2){//如果K2是整数而且与K1一奇一偶
            int k2=2*m/k1;
            cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;//输出答案
        }
    return 0;
}
```

时间复杂度 $O(\sqrt M).$

（upd：$\rm LATEX$ 优化）

---

## 作者：chy010827 (赞：225)

下面许多dalao，神犇用了打表，前缀和，数学方法等天花乱坠的方法，令本蒟蒻深感佩服

##下面说说本蒟蒻自己的暴力解法

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,sum,j;
int main()
{
    cin>>n;     //读入       
    for(int i=1;i<=n/2;i++)
    {
        sum=0;     //sum归零
        for(j=i;j<n;j++)   //枚举每一个i对应的j，这个j是最小的，从i加到j总和大于等于n的自然数
        {
            sum+=j;            //sum记录从i加到j的总和
            if(sum>=n)break;    //当sum>=n时，跳出循环
        }
        if(sum==n)cout<<i<<' '<<j<<endl;   //输出
    }
    return 0;
}
```

---

## 作者：Frenix (赞：150)

## 尺取法（two pointers）
	看到没有尺取法的题解我来补一篇吧。
    用i，j代表区间的左右端点
    当sum小于目标值M时，将右端点右移（j++），sum会变大
    当sum大于目标值M时，将左端点右移（i++），sum会变小
    在双指针移动的过程中，如果有sum==M的情况就输出。
    因为两个指针都是单调向右移动，也只扫一遍，可以证明时间复杂度为O(n)
    左端点大于m/2时即可停止，因为只要长度为2的连续序列和就一定大于m
    
```cpp
#include<cstdio>

int m;

int main()
{
	scanf("%d",&m);
	int sum=3;
	for(int i=1,j=2;i<=m/2;)
	{
		if(sum==m)
		{
			printf("%d %d\n",i,j);
			sum-=i;
			i++;
		}
		else if(sum<m)
		{
			j++;
			sum+=j;
		}
		else 
		{
			sum-=i;
			i++;
		} 
	}
	return 0;
}
```

---

## 作者：3269224138刘 (赞：57)

感觉楼下的大佬们好强，打表，前缀和，暴力都有，不过我感觉只要枚举左右两个端点就可以了


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans=0;//ans记录左端点l到右端点r的区间和
int main(){
    scanf("%d",&n);
    int l=1;
    for (int r=1;r<n;r++)//因为题目要求是自然数段，所以不能有n到n的区间
    {
      ans+=r;//ans一直加上右端点的数，记录l到r的区间的和
      while (ans>n)
          ans-=l++;//如果ans加得太多，从左端点开始减，当ans<=n的时候就可以继续枚举右端点，还要注意l的细节问题，当ans减去l后，l还要加1，举样例来说，如果ans-17等于n了，l还要加1等于18，当然，l要从1开始枚举
      if (ans==n)
        printf("%d %d\n",l,r);//ans等于n，输出左右端点
    }
    return 0;
}
//时间复杂度的话。。。我不太会算，最坏的情况应该是O(2n)左右，最好的情况应该是O(n)左右
```

---

## 作者：lamboo (赞：32)

本题可以通过等差数列求和，解一元二次方程得出答案

这样做效率达到了O(n)，应该是很高的了

设首项是i,末项是x，和为n,则

```cpp
   (i+x)(x-i+1)/2=n (等差数列求和)
     (i+x)(x-i+1)=2n
ix-i^2+i+x^2-ix+x=2n  (多项式乘多项式)
   x^2+x-i^2+i-2n=0  (合并同类项)
```
运用一元二次方程求根公式，得
x1=(-1-sqrt(1-4(i-i^2-2n)))/2

x2=(-1+sqrt(1-4(i-i^2-2n)))/2

我们在这里就只要保留x2就可以了，应为x1必定小于i

如果x2是整数且大于i，那么它就符合了题目要求

我们只要枚举i就可以得到结果

```cpp
#include<cmath>
#include<iostream>
using namespace std;
int main()
{
    int n;
    long long y;
    long double x;
    cin>>n;
    for (int i=1;i<n;i++)
    {
        y=i;  
        //注意，一定要先把i保存到y里，不然下面在运行i*i是，结果是暂存在i里的，数据大了就会炸（我就因为这个原因改了2个小时）
        if (1-4*(y-y*y-2*n)>=1)  
        //根的判别式(我们要满足(-1+sqrt(1-4(i-i^2-2n)))是正数)
        {
            y=1-4*(y-y*y-2*n);
            x=(-1+sqrt(y))/2;  //求此方程的解
            if ((x==floor(x))and(x>i))  
            //判断此方程的根是否为正数且大于i cout<<i<<" "<<floor(x)<<endl;
        }
    }
}
```

---

## 作者：芬特 (赞：29)

回顾一下，发现这道题并不用推式子，可以使用前缀和直接做，再二分查找一下，这里用stl的lowerbound，就当练习，主要看代码

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<set>
using namespace std;
const int maxn=2000001;
long long int array[maxn];

int main()
{
    long long int n;
    cin>>n;
    for(int i=1;i<=n;i++) array[i]=array[i-1]+i;    
    for(int i=1;i<=n;i++)
    {
        long long int mid=array[i-1]+n;
        long long int a=lower_bound(array,array+n+1,mid)-array;
        if(array[a]-array[i-1]==n) 
        {
        if(i!=a) cout<<i<<" "<<a<<endl;
        }
    }
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：16)

模拟会超时……然后优化都要有……

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
using namespace std;
int n,i,j,sum;
int main()
{
    scanf("%d",&n);//读入 
    for (i=1;i<=n/2;i++)//只算到n/2会错，因为n可能为奇数，例如：5=3+2; 
    {
        for (j=i+1;j<=n/2+1;j++)
        {
            sum=(i+j)*(j-i+1)/2;//等差数列求和 
            if (sum==n) printf("%d %d\n",i,j);//如果满足条件就输出 
            if (sum>n) break;//由于我是从前往后搜的，所以sum到后面会越来越大，如果超过了就跳出，不然会超时 
        }
    }
    return 0;
}

```

---

## 作者：feecle6418 (赞：14)

就我一个用了二分答案！！！？？？

下面说说思路吧。

算法一：56分

直接前缀和暴力枚举。时复度$O(N^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL n,a[2000001]={0,1};
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){
        a[i]=a[i-1]+i;
    }
    for(int i=0;i<n-1;i++){
        for(int j=i+1;j<=n;j++){
            if(a[j]-a[i-1]==n){
                cout<<i<<' '<<j<<'\n';
            }
        }
    }
    return 0;
}
```
算法二：100分

观察到前缀和数组是有序的，所以试着使用二分。

二分找什么呢？找使$a[j]-a[i-1]=n$的$j$。时复度$O(Nlog_2N)$。

毫不犹豫地写出：

```cpp
int search(int l,int r,LL kk){//直接替换掉原来暴力代码的第二层循环就好啦！
    if(l>r)return -1;
    int m=(l+r)/2;
    if(a[m]-kk==n)return m;
    else if(a[m]-kk>n)search(l,m-1,kk);
    else if(a[m]-kk<n)search(m+1,r,kk);
}
```
（P.S.）这题二分直接把我卡到492ms，看着别人的8ms，惭愧。。。


---

## 作者：老部长 (赞：13)

## **水一发题解（~~顺便拯救我的咕值~~）**

### **代码很好理解**

此题用普通前缀和就行了

题目中：10≤M≤2000000

1. 连续的自然数（最少两个）加起来等于m，最大的就是m/2+m/2-1（大概接近这个数），即m/2，
所以先大致算一下：加起来是2000000最大为1000000

2. 开1000000的数组，计算前缀和然后枚举两个端点

3. 我是先枚举右断点i，再从i-1到1中枚举左端点

**优化**：枚举左端点时，右端点要倒叙枚举，如果sum[i]-sum[j-1]大于m就结束（正序直接全T）

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
int sum[1000005];
int main()
{
	cin>>m;
	for(int i=1;i<=1000000;i++)//第一条
	{
		sum[i]=sum[i-1]+i;//前缀和
	}
	for(int i=1;i<=m/2+1;i++)//枚举左端点
	{
		for(int j=i;j>=1;j--)//枚举右端点
		{
			if(sum[i]-sum[j-1]>m)break;//优化
			if(sum[i]-sum[j-1]==m&&i!=j)
			{
				printf("%d %d\n",j,i);
			}
		}
	}
	return 0;//好习惯
}
```

---

## 作者：大头 (赞：13)

由题目知道，M=(a1+(a1+n-1))\*n/2

所以，（2a1+n-1）\*n=2M

枚举2M因数，判断a1是否合理

左右边界分别是（2M/n-n+1）/2,（2M/n-n+1）/2+n-1

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cmath>
#include<string>
#include<iostream>
#include<algorithm> 
#define ll long long
int n;
int main(){
    scanf("%d",&n);
    n*=2;
    for (int i=2000;i>1;i--)
        if (n%i==0&&i*i<=n&&(n/i-i+1)%2==0)
            printf("%d %d\n",(n/i-i+1)/2,(n/i-i+1)/2+i-1);
    return 0;
}
```

---

## 作者：xizeroplus (赞：9)

可以用前缀和处理区间和，利用单调性解决。详见代码。

```cpp

#include<cstdio>
#define lint long long
using namespace std;

lint s[1000009];

int main()
{
    int n,i,j;
    scanf("%d",&n);
    int m=(n+1)>>1;
    s[0]=0;
    for (i=1;i<=m;i++)
        s[i]=s[i-1]+i;
    i=0;j=1;
    while(i<=m&&j<=m)
    {
        if (s[j]-s[i]==n)
        {
            printf("%d %d\n",i+1,j);
            i++;j++;
        }
        else if (s[j]-s[i]>n)
            i++;
        else 
            j++;
    }
    return 0;
}

```

---

## 作者：樱式分解 (赞：8)

### 这是一道比较简单的前缀和问题，如果直接暴力的话会超时，那就每次枚举，判断连续和如果大于M,就直接退，不然就输出继续枚举，代码如下：
```
#include <iostream>
using namespace std;
int n;
long long a[2000010];//long long大点；
void dfs(int i,int t,int sum){
	if(sum>n)return;//中途暂停；
	if(sum==n&&t>=2)
        cout<<i-t+1<<" "<<i<<endl;
	if(i-t==1)return;//边界退出；
	dfs(i,t+1,a[i]-a[i-t-1]);//枚举前缀和；
}
int main(){
        a[0]=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		a[i]=a[i-1]+i;
                if(i>1)//足够长再说；
                dfs(i,-1,a[i]-a[i]);//一开始什么都没有；
	}
    return 0;//完成。
} 
```
## 用心写题解，希望给大家带来点帮助呀！

---

## 作者：封禁用户 (赞：6)

[原题链接](https://www.luogu.org/problem/P1147)

题意：找出一串连续的自然数，要求改串自然数之和为$M$，输出所有可能性。（注意只要输出首项和末项）

给大家介绍一个数学知识（知道的非萌新请跳过）

**等差数列**

等差数列是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列。

我们把这个数列的第一个数称之为**首项**，把最后一个数称之为**末项**，把这个数列中自然数的个数称之为**项数**。

项数=（首项+末项）/公差+1

等差数列求和的公式为：

（首项+末项）*项数/2


先贴上毋庸置疑TLE的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c;
int main() {
	cin>>n;
	for(a=1; a<=n-1; a++) {
		for(b=a+1; b<=n; b++) {
			c=(b-a)+1;
			if(((a+b)*c/2)==n) {//利用等差数列求和的公式
				cout<<a<<b<<endl;
			}
		}
	}
	return 0;
}
```

- 为什么毋庸置疑T？

1.都这个节骨眼上了，用$cin$和$cout$能行吗？

2.为什么找到了答案还要继续循环下去？


好，改进一下~

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c;
int main() {
	scanf("%d",&n);
	for(a=1; a<=n-1; a++) {
		for(b=a+1; b<=n; b++) {
			c=(b-a)+1;
			if(((a+b)*c/2)==n) {
				printf("%d ",a);
                printf("%d\n",b);
				break;
			}
		}
	}
	return 0;
}
```

还是不行，只有$70$分。

那怎么办？

我们可以用一个剪枝。

就是如果$a+......+b$不符合条件并且已经比$M$大时，应该$break$。

最后贴上丑陋不堪的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c;
int main() {
	scanf("%d",&n);
	for(a=1; a<=n-1; a++) {
		for(b=a+1; b<=n; b++) {
			c=(b-a)+1;
			if(a*c>=n) break;//剪枝
			if(((a+b)*c/2)==n) {
				printf("%d ",a);
				printf("%d\n",b);
				break;
			}
		}
	}
	return 0;
}
```

~~开氧~~

---

## 作者：Ori_Wilson (赞：5)

# ****本蒟蒻的第一篇题解**** #
### ~~应该是比较简单的方法吧~~

------------**求大佬包含（~~不不不说错了是神犇~~）**
```


首先用等差求和公式
{a[n]}
前n项和=(a[1]+a[n])*n/2;
计算出总和（即题目输入数据）
然后把尾项通过公式表达出来
ans=(sqrt(8*n+4*i*i-4*i+1)-1)/2;
定义一个实数数据，一个整数数据
实数数据记录sqrt(8*n+4*i*i-4*i+1)的值
令整数数据=实数数据
然后进行比较
如果两个数据相等并且整数数据为奇数（后面有减1）
把i和ans输出
```
```




具体代码如下
```
```p


#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n,ans,y,i;
double x;
int main()
{
    cin>>n;
    for(i=1;i<=n/2;i++){
        x=sqrt(8*n+4*i*i-4*i+1);//计算判别式
        y=x;//整数类型化
        ans=(y-1)/2;
        if(x==y and i<ans and y%2==1){
            printf("%lld %lld\n",i,ans);//输出数据
            continue;
        }
    }
    return 0;//功德圆满
}
```

---

## 作者：康师傅 (赞：5)

### 等差数列的一个简单应用  
$$S_n=\frac{(a_1+a_n)*n}{2},n>=1$$

$$a_n=a_1+(n-1)d,n>=1$$
我们变形一下，用题目中的$m$代替$S_n$，又因为是连续自然数，公差$d=1$，于是有
$$\frac{\frac{2*m}{n}-n+1}{2}=a_1$$
为什么不通分呢，因为有$\frac{1}{2}$不好处理，但是看式子我们发现有两个未知数耶~怎么办呢，当然是枚举咯，稍微想一想我们知道枚举$n$比较方便，所以直接枚举就好  
看样例是从小到大输出，所以这里我们$n$要从大到小枚举，接下来注意一点细节：
- 出现分数一定要判断分子能不能整除分母
- 注意$a_1$的正负  

就这样~剩下的一个数字我们利用公式就可以直接算出来了！  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,up=1,a;
int main(){
	cin>>m;
	for(n=m-1;n>1;--n){
		if(2*m%n!=0)	continue;
		up=2*m/n-n+1;	
		if(up<=0||up&1)	continue;
		a=up>>1;
		printf("%lld %lld\n",a,a-1+n);
	}
	return 0;
}
```


---

## 作者：zzozz (赞：5)

关于这道题，并不需要什么前缀和。

我们每次枚举L判断能不能找到整数R满足这段自然数的和为M

首先对于L到R是一个等差数列，用一个等差数列求和公式可知sum（L,R） = （L + R）\*（R - L + 1）/ 2。

要是这个等于M也就是

求解方程M = （L + R）\*（R - L + 1）/ 2；

然后对其整理变成 0 = R\*R + R - （L\*L - L + 2\*M）；

用求根公式进行判断就行

tips：开longlong，不然GG，开始没开longlong直接输出过少（后面的爆了）直接返回-1；


下面是代码：





```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
long long m;
long long check(long long l){
    double delta = 1 + 4 * (2 * m + l * (l - 1));
    if (delta < 0) return -1;
    delta = sqrt(delta);
    if (delta != (long long)delta) return -1;
    long long r1 = (-1 + delta) / 2;
    if ((-1 + (long long)delta) % 2 || r1 <= l) r1 = -1;
    return r1;
}
int main(){
    cin >> m;
    for (long long l = 1;l < m;l ++){ 
        long long r = check(l);
        if (r == -1) continue;
        else cout << l << " " << r << endl;
    }
    return 0;
}
[广告](http://www.cnblogs.com/zzozz/p/7684053.html)
```

---

## 作者：__CrossBow_EXE__ (赞：4)

# 前言

我的想法与其他题解有不同之处。不同在于：我使用了一种比较新颖的办法——个人称为升降法，以及数形结合的思想。

# 题解

首先，观察这幅图：（图丑见谅）

![](https://pic.imgdb.cn/item/67375dfcd29ded1a8cd1370e.png)

不难发现，这些矩形就像是题目中的加数，依次递增，而且公差为一。我们想求它们的和，等价于求它们的**面积和**。

接着，我们将这些矩形拦腰截断：

![](https://pic.imgdb.cn/item/67375e83d29ded1a8cd1c021.png)

此时，图形分为上下两部分：上方可以看作一个三角，下方可以看作一个矩形。全图的面积自然是它们两个的面积之和。

## 三角形

我们小学时就学过，三角形的面积公式为 $S= \frac{1}{2}ah$，底乘高的积除以二。

不过，值得注意的一点是，这个三角形的底和高相等，都是那条红线。所以，它的面积也可以表示为 $S=\frac{1}{2}a(a+1)$。

## 矩形

这个就更简单了，就是底乘高嘛。

经过上面的分析，我们发现：无论是三角形还是矩形，他们的面积都与下面的矩形的长和宽有关。

所以，我们可以枚举它的长和宽，看看面积和是否为 $m$，如果是的话输出即可。

至于输出什么，肯定是左边矩形的高度和右边矩形的高度了。如果用 $i,j$ 表示矩形的长和宽，那答案就是 $i,i+j-1$。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define endl '\n'
using namespace std;
int m;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
    cin>>m;
    for(int i=1;i<=m;i++){//底座高度 
    	for(int j=2;i*j<=m;j++){//底座宽度 
    		int up=(j-1)*j/2;//上面的三角 
    		int down=i*j;//下面的底座 
	    	if(up+down==m) cout<<i<<' '<<i+j-1<<endl;
		}
	}
	return 0;
}
```

感谢观看！

---

## 作者：HenryHuang (赞：4)

一个循环的神奇数学方法

我们都知道，1+2+3+···+n=(1+n)\*n/2

那如果，把这个公式代入进本题呢？

那就可以用最坏情况复杂度为o（n）的枚举来解决啦

输入的数n=(首项+首项+项数-1）\*项数/2（由于是连续自然数，所以(首项+首项+项数-1）与项数**奇偶性**相反）

详见代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    n*=2;//将公式中除以2移向
    int g=n;
    for(int i=g-1;i>1;i--)
    {
        if(n%i==0&&(n/i)%2!=i%2&&n/i>=i)//由于从小枚举，所以要判断n/i>=i，否则会出现负数 
        {
        printf("%d %d\n",(n/i-i+1)/2,n/i-(n/i-i+1)/2);
        g=n/i;//更改边界，节约时间 
        }
    }
return 0;
}
```

---

## 作者：BB2655 (赞：4)

用二分的思想

首先说一下等差数列求和

$$ sum=(fir+lst)*num/2 $$

其中

$$ num=(lst-fir)/q+1 $$

```
 sum为等差数列各项之和
 fir为首相
 lst为末项
 num为项数
 q为公差
```

由此可以得出代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int m;
    scanf("%d",&m)  //按题设输入
    for(int i=1;i<=m/2;i++)  //此处枚举首项，最大为m/2
    {
        int l=i,r=m/2+1;  //左边界和右边界
        while(l<=r)  //二分
        {
            int mid=((r-l)>>1)+l;  //l,r的中间值（防止爆int的方法）
            long long h=((long long)(i+mid)*(long long)(mid-i+1))>>1;
            if(h>m)  r=mid-1;
            else if(h<m)  l=mid+1;
            else
            {
                printf("%d %d\n",i,mid);
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：不恃 (赞：3)

# 第一篇博客，发道题解，希望**抛砖引玉**
## 数学方法吧  ：-D
### 假设n能过被分为连续的i个数的和，这时有两种情况；
①i是偶数，此时（**最中间的两个数的和***i/2）==n，那么n对这两数的和取余等于0；

②i是奇数，此时（**最中间的数***i）=n，那么n对此数取余等于0。

### 按以上方法，从i=2时开始递增。如果n可以被分为连续的i个数的和：

①这i个数中的最小值不是自然数或者最大值大于n（其实会同时出现啦）；此时跳出循环，因为i取更大值的时候依然会超出0和n的界限，

②这i个数都是0-n之间的自然数；此时将这i个数中的最小值和最大值压入栈(此处不用二维数组是因为不知道有几种方案)中。

### 最后依次输出：

```cpp
#include<iostream>
#include<stack>
using namespace std;

struct id{
	int x,y;
}ss;

int main(){
stack<id> s;
	int i,n;
	cin>>n;
	for(i=2;;i++){
		if(i%2==0&&n%(n/i*2+1)==0){
			ss.x=n/i-i/2+1;
			ss.y=n/i+i/2;
			if(ss.x<=0||ss.y>=n)	break;
			else s.push(ss);
		}
		else if(i%2==1&&n%i==0){
			ss.x=n/i-i/2;
			ss.y=n/i+i/2;
			if(ss.x<=0||ss.y>=n)	break;
			else s.push(ss);
		}
	}
	while(!s.empty()){
		cout<<s.top().x<<' '<<s.top().y<<endl;
		s.pop();
	}
return 0;
}
```
## 写代码的习惯不太好：-D


---

## 作者：Log_x (赞：3)

其实这题还有一种更简单的方法——前缀和

代码如下：

```cpp
#include<cstdio>
using namespace std;
int f[2000001],n;
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=2000000; ++i) f[i]=i+f[i-1]; //f[i]存储1+2+3+…+i的和
    for (int i=1; i<2000000; ++i)    
     for (int j=i+1; j<=2000000; ++j)//枚举一个区间[i,j]
     if (f[j]-f[i-1]==n) printf("%d %d\n",i,j);//则f[j]-f[i-1]=i+(i+1)+(i+2)+…+j的和
      else if (f[j]-f[i-1]>n) break;//由于i,j会枚举到两百万，很容易超时，所以加上这个优化：
//f[j+1]，f[j+2]…f[n]必然大于当前的f[j]，如果f[j]-f[i-1]>n，再次枚举就没必要了
}
```

---

## 作者：EarthGiao (赞：2)

####【思路】
暴力、枚举 
很有意思的一道题目，看着很简单，会往最简单最暴力的方法上去想
但是数据很容易让人心生胆怯，然后就不敢用，只能绞尽脑汁去想着怎么优化怎么减少复杂度
我就在这么一道明明很简单的题目上，
想优秀的解法上面耗费了大量的时间 
但是殊不知，最最暴力的方法确实最最可行的方法
直接暴力枚举1 - n/2个数然后枚举每一个数是否有可行的区间就可以了
这里说一下为什么要枚举到n/2而不是 n
拿样例举个例子吧 
因为这题中连续的区间虽然没有明说但是从数据里面可以推断出，
区间长度必须是大于1，因为样例的输出里面没有本身10000 - 10000这个区间
所以至少一个区间是有2个数的，
而2个数可以拼出10000的应该是比10000 / 2的值小或者等于的，
因为如果大于n / 2那是不可能有两个连续的数拼出n的，不信你可以自己试试（滑稽）
所以说只需要枚举到n / 2就可以了 

代码里面有一个小细节用注释标注出来了 
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
	int n; 
	cin >> n;
	int qwq = n / 2;
	int sum = 0;
	for(int i = 1;i <= qwq;++ i)
	{
		sum = 0;
		int j;
		for(j = i;j <= n;++ j)//解释一下这里为什么是n
		//如果输入的数据是偶数的话，那是不会有任何毛病的
		//但是如果你输入的是奇数，拿1919来举例的
		//这个1919 / 2之后等于959.5，这个刚好是有一个可行区间为959 - 960的也就是将两个959.5分配了一下凑出来两个相邻的整数
		//这样如果只枚举到n / 2就是jj掉 
		{
			sum += j;
			if(sum >= n)
				break;
		}
		if(sum == n)cout << i << " " << j << endl; 
	}
	return 0;
} 
```

---

## 作者：八重樱 (赞：2)

d为1的等差数列求和公式(a+b)\*n/2，a是首项，b是末项，其中b=a+n-1。所以m=(2a+n-1)n/2，即2m=(2a+n-1)n。

必有n<=2a+n-1，且n与2a+n-1一奇一偶。

将2m分解为一奇一偶两个因数，2m中的“2”必集中于同一个因数。


···cpp

```cpp
//Code By 1677
#include<iomanip>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<algorithm>
#include<bitset>
using namespace std;
int m,no,coefficient[65],aa,bb,rs=1;
bool except=0;
```
unsigned short
    b[9],prime[9],amount=0,ans=0,

    table[303]=

    {
3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,

151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,

307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,

457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,

601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,

751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,

907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,

1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,

1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,

1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,

1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,

1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,

1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,

1951,1973,1979,1987,1993,1997,1999,2003

```cpp
    };        //打了个sqrt(2m)的素数表
int intpow(short int aa,short int bb)        //aa的bb次方啦
{
    int ss=1;
    while(bb--)
    {
        ss*=aa;
    }
    return ss;
}
void gointo(int rsc)
{
    if(except)        //如果存在“一个超出sqrt(2m)的奇质因子”，需要记录有无的两种情况。
    {
        int rsb=rsc*no,kk=m/rsc;
        rsc=min(rsc,kk);        //用min取小值为n
        kk=m/rsb;
        rsb=min(rsb,kk);
        coefficient[ans]=rsc;
        ans++;
        coefficient[ans]=rsb;
        ans++;
    }
    else        //不存在直接记录
    {
        int kk=m/rsc;
        rsc=min(rsc,kk);
        coefficient[ans]=rsc;
        ans++;
    }
}
void dfs(short int it)
{
    if(it==amount)        //符合条件则记录。不能直接输出，因为需要从大到小。
    {
        gointo(rs);        //用来把“n”记录到coefficient里的函数
    }
    else        //不符合条件继续搜索。
    {
        for(short int i=0;i<=b[it];i++)        //prime[it]这个奇质因子所存在的状态
        {
            dfs(it+1);
            rs*=prime[it];
        }
        rs/=intpow(prime[it],b[it]+1);        //人生若只如初见(回溯)
    }
}
int main()
{
    scanf("%d",&m);
    int no=m;        //因为m一会要用到，用no储存一下
    m*=2;        //根据公式取2m
    while(!(no%2))
    {
        no/=2;
    }        //把“2”都剔除，剩下所有奇质因子乘积
    for(short int i=0;i<303;i++)        //找一遍素数表
    {
        if(no%table[i]==0)
        {
            prime[amount]=table[i];        //prime用来储存奇质因子，amount是奇质因子个数
            while(no%table[i]==0)
            {
                no/=table[i];
                b[amount]++;        //b用来储存奇质因子对应指数
            }
            amount++;
        }
    }
    if(no!=1)        //m最多只含一个超出sqrt(2m)的奇质因子，若含，则此时no为此质因子
    {
        except=1;        //记录“含”
    }
    dfs(0);        //“0”与amount对应
    sort(coefficient+1,coefficient+ans);        //STL的快排不叨叨
    for(short int i=ans-1;i>0;i--)        //a从大到小输出，此时n大的a小
    {
        aa=(m-coefficient[i]*coefficient[i]+coefficient[i])/(2*coefficient[i]);        //方程m=(2a+n-1)n/2的解
        bb=aa-1+coefficient[i];
        printf("%d %d\n",aa,bb);
    }
    return 0;
}
//NOI>>qinghua(这个是我每写一个程序都会立的flag大家可以忽略)
```
···

没看是枚举算法，以为很容易超时，于是用了dfs找因数，还打了个素数表。

费了整整两个半小时写出的代码，其中忘了加一行代码“dfs(0);”害得我检查了半个小时。

还有510510的爆栈和771的超short int也是不小的问题。

不过经过优化，时间复杂度和空间复杂度就是闹着玩的不存在的，算法可以AC掉高精以下全部测试数据。

当然定义数组范围、无符超长整型、素数表自己改。


---

## 作者：XiXi (赞：2)

别想得太难，其实很简单，代码仅仅十行：

```delphi

Var n,p,s,i:longint; 
Begin 
Readln(n); 
For i:=1 to n div 2+1 do 
Begin s:=0; p:=i; 
repeat s:=s+p; inc(p);
if s = n then begin writeln(i,' ',p-1); break; end; 
Until s > n - p; 
End; 
End.
```
(view plain可以省去前面的编号直接复制）

看懂再抄，否则永远不懂


---

## 作者：Zachary_260325 (赞：2)

 ### 本蒟蒻又想发题解了~~（怕是不能过）~~
 各位神犇记得小学学过等差数列求和公式吗？

- 等差数列之和等于其首项加末项的和乘以项数除以2。

 ~~（我是个听话的蒟蒻，背的可熟练了）~~

假如以i表示本题要求的首项的值，j表示本题要求的末项的值，可以带入公式（因为知道等差数列的两数之间的差等于1，故项数可求）

**我的化简~~（复杂化）~~如下**

------------

```cpp
(i+j)*(j-i+1)/2=n //原公式,需要保证j>i
i*j-i*i+i+j*j-i*j+j=2*n //嗯,拆开括号,移项
2*n+i*i-i=j*j+j //随意化简一下之后
```
------------
本蒟蒻比较垃圾,只知道可以暴力嵌套循环来求i和j,但是可以依靠已知的条件化简一下过程：

1. j>i,故内嵌的求j循环可以直接从**i+1**开始循环

2. 在内嵌求j循环中,**2\*n+i\*i+i**的值是不变的，所以只用在进入内嵌循环前求一遍,不必反复求（特别是在用于判断时，由于进行判断次数奇多，肯定超时）

3. 在内嵌求j循环中,如果符合**2\*n+i\*i+i=j\*j+j**便可以直接输出，并且开始求下一个i值去了，因为此i值最多只能有一种解

4. 在内嵌求j循环中,如果**2\*n+i\*i+i>j\*j+j**则说明j值小了，则继续循环;反之,如果**2\*n+i\*i+i<j\*j+j**则说明j值已经过大,此i值没有解了，便可以去下一个试i值了。

### 那么上代码，代码很短......~~也很暴力。~~

------------


```cpp
#include<cstdio>
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1,tmp=2*n+1*1-1;i<=n/2;++i,tmp=2*n+i*i-i)
		for(int j=i+1;j<n;++j)
		{
			if(tmp<j*j+j)
				break;
			else 
				if(tmp==j*j+j)
				{
					printf("%d %d\n",i,j);
					break;
				}
		}
	return 0;
}
```
------------

代码还有很多可以优化的,比如算出更接近的j值，减少内嵌求j循环的循环次数，思路如下（只有思路，没写代码...）

------------
```cpp
2*n+i*i-i=j*j+j //上面的化简代码
j=sqrt(2*n+i*i-i-j) //移项,开根
j<sqrt(2*n+i*i+i) //因为j>0,2*n+i*i-i>j*j
j>i //已知
//所以j可以由ceil(sqrt(2*n+i*i+i))循环到i+1
```
------------

就这些，希望可以帮上各位神犇...

---

## 作者：Provence_24 (赞：2)

```cpp
#include<bits/stdc++.h>
using namespace std;
  int i,n;
  long long temp,temp1;//temp是-a*a+a，temp1是b*b+b 
  int main(){
    //用数学公式，设首项为 a，末项为 b，
    //总和 n 为（a+b）*（b-a+1）/2 
  	cin>>n;//化简：2*n=-a*a+a+b+b*b 
  	int m=2*n;//方便计算 
   
   
   //以上数学推导 
  	
    
    for (i=1;i<=n/2;i++)//循环 
  	{
  	    temp=(long long) (1-i)*i;//注意强制转换 
		temp1=(long long)m-temp;//用上述公式推导 
		for (int j=trunc(sqrt(temp1));j>i;j--)
		{   //用循环来确定末项 
		   if ((long long)j*j+j==temp1)//找到末项 
		   {
		   	  cout << i<< " "<< j<<endl;//输出 
		   	  continue;//输出就跳出循环 
		   }	
		}	
	}
	return 0;//结束 
  } 

```

---

## 作者：lsy2006 (赞：1)

# 这道题是一道数论题

题目让我们求出所有连续的所有数之和为M的自然数段的首相和末项。

知道小学~~奥数~~学过的求和公式

**A1+A2+A3+...+An=(A1+An)(An-A1+1)/2**

利用乘法分配律

A1An-A1²+A1+An²-A1An+An=2M

由于M和A1（枚举）是已知的，所以只要求出An就可以了

整理后可得An²+An=2M+A1²+A1

最后解一元二次方程[求根公式](https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B/7231190?fr=aladdin)

在这里a=1,b=1,c=2M+A1²+A1

算出An=(-1+sqrt(1 + 8 * M + 4 * L^2 - 4 * L) )/2
~~其实就是不会打根号和分数线~~

上代码：

```cpp
double solve(int M,int L){
	double ans;
	ans=(sqrt(1+8*M+4*pow(L,2)-4*L)-1)/2;
	return ans;
}
```

------------

那么怎么判断此时的A1和An是否能成为一对正确答案呢？

很简单：只要判断现在的答案是不是正整数就行了

先定义一个int变量c记录它的整数部分(m/1)

然后定义一个double变量a=m-c

如果a=0,那么它是整数，否则不是。

```cpp
bool is_int(double x){
	double a;
	int c;
	c=x/1;
	a=x-c;
	if(a==0) return true;
	else return false;
}
```


------------
最后从1枚举到m/2(因为m/2+一个数>m/2一定大于m)，找到正确的i、j输出就行了

```cpp
#include<bits/stdc++.h>
using namespace std;
double m;
bool is_int(double x){
	double a;
	int c;
	c=x/1;
	a=x-c;
	if(a==0) return true;
	else return false;
}
double solve(int M,int L){
	double ans;
	ans=(sqrt(1+8*M+4*pow(L,2)-4*L)-1)/2;
	return ans;
}
int main(){
	cin>>m;
	for(int i=1;i<=m/2;i++)
		if(is_int(solve(m,i)))
			cout<<i<<" "<<solve(m,i)<<endl;
}
```
------------





---

## 作者：GlitterL (赞：1)

我本来想用这种十分暴力的方法试一下，没想到直接过了。
恩...

也不算暴力吧，时间复杂度还是可以的。

首先，用到等差数列求和公式——Sn = n*a1+n(n-1)d/2。

其次，就从1 - n 直接暴力。但是这里有两个小技巧。

（一）我们这里知己让 an = M/i+i 然后让 an-- 一个一个的判断。

（二）在判断的时候如果 sum 小于了 M 的话就已经说明了 i 不满足要求了，直接跳出循环。

下面是代码：

```cpp
#include<iostream>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdlib>

using namespace std;

int n;

int main()
{
    scanf("%d",&n);
    double sum=0;
    for(int i=1;i<n;i++){
        for(int j=n/i+i;j>i;j--)
        {
            sum=(j+i)/2.0*(j-i+1);
            if(sum==n){
                printf("%d %d\n",i,j);
                break;
            }
            else if(sum<n){
                break;
            }
        }
    }
}

```


---

## 作者：clouds (赞：1)

/\*
楼下的大佬们，打表，前缀和，暴力都有。

但是这真的只是一个数学问题。

等差数列求和，所以直接利用中项来找。


n ÷ i=k


1.当i为奇数时，k为整数时， 即可满足，此时k为中项

2.当i为偶数时，k为小数位是0.5的小数，即可满足，


\*/
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int n;
    cin>>n;
    for(int i=n;i>1;i--)
    {
        if(i&1)
        {
            //为奇数
            int x=n/i;
            //n%i==0判断x为整数，x-i/2>0判断第一项大于0
            if(n%i==0 && x-i/2>0) cout<<x-i/2<<" "<<x+i/2<<endl;
        }
        else
        {
            //i为偶数
            double x1=n*1.0/i;
            int x2=n/i;
            //x1-x2==0.5000000000判断小数位为0.5，x2-i/2+1>0判断第一项大于0
            if(x1-x2==0.5000000000 && x2-i/2+1>0) cout<<x2-i/2+1<<" "<<x2+i/2<<endl;
        }
    }
    return 0;//优雅的结束
}

```

---

## 作者：yanghay (赞：1)

翻了前几个没发现有人用尺取法做啊……

'''cpp

    
        
            
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int n;
    int ans=0;
    int t=1;
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        if(ans<=n)ans+=i;
        while(ans>n)
        {
                    ans=ans-t;t++;//大于n了就依次减去t，再多再减
        }
        if(ans==n)//满足条件就输出
            {
            printf("%d %d\n",t,i);
            }
    }    
    cin>>n;
    return 0;
}
'''
```

---

## 作者：年轻人 (赞：1)

看见大部分都是C语言写的于是发一波pascal的，思想很简单枚举就好

```cpp
program P1147;
type
  shu=record
    x,y:longint;//记录第一个数和最后一个数
end;
var
sum,i,j,k,m:longint;
a:array[1..100] of shu;//用数组储存这个记录
begin
readln(m);
k:=0;//检测是否有解
for i:=1 to m do begin//第一个数从第一个开始枚举
  sum:=i;
  for j:=i+1 to m do begin//依次往后加直到大于或等于所给数
  sum:=sum+j;
  if sum<m then continue//若不等则i值加1继续枚举
  else if sum=m then begin
    inc(k);
    a[k].x:=i;
    a[k].y:=j;
    end
    else begin break; end;//若等于则储存值然后值加1继续循环
    end;
end;
if k<>0 then//若有解则输出
for i:=1 to k do
writeln(a[i].x,' ',a[i].y);
end.
```

---

## 作者：dragon_bra (赞：1)

……为什么大家的题解代码都这么长呢？


首先：（首项+末项）\*项数/2 = 和。等差数列求和公式，没有问题吧？


然后我们设首项为a，项数为n，则有 末项 = a+n-1，那么原式可以写成(a+a+n-1)\*n/2=和。


然后设其中(2a+n-1)那部分为tsum（代码中的变量），就有首项a=(tsum-n+1)/2，末项=(tsum+n-1)/2。


接着我们只要找到能 被总和 整除，首项 是 大于0 的正整数 且首项+末项=tsum（可能因为int取整导致不满足） 就 可以了。


（反正我是这么做的也过了。。除了觉得i循环的位置是只是写了一个大概的范围外，感觉这份代码做这题没有问题啊。对我代码有异议的可以私信我，我也很好奇为什么我的这么短。。）


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
int main()
{
    cin>>n;
    int i;
    int cmp = n*2 ;
    for(i=n/2;i>=2;i--)
    {
        if(cmp%i==0)
        {
            int tsum = cmp/i;
            if(tsum-i+1>0 && (tsum-i+1)/2 + (tsum+i-1)/2 == tsum)
                cout<<(tsum-i+1)/2<<' '<<(tsum+i-1)/2<<endl;
        }
    }
    return 0;
}
```

---

## 作者：fblogy (赞：1)

枚举长度x，设第一项a1，(a1+a1+x-1)\*x/2=n,

2\*a1=n\*2/x+1-x，判断2\*a1是否为偶数即可，其中x为n的因数

算完后按a1排序

```cpp

#include<cstdio>  
#include<algorithm>  
#include<cmath>  
#include<cstring>  
  
using namespace std;  
int i,j,k,n,m,x,sum;  
  
struct node{  
int a,b;  
};  
  
node a[5000000];  
bool cmp(const node &a,const node &b){  
return a.a<b.a;  
}  
int main(){  
    scanf("%d",&n);n*=2;  
    for (i=2;i<=(int)sqrt(n);i++)if (n%i==0){  
        x=n/i+1-i;if (x%2==0 && x>0) {sum++;a[sum].a=x/2;a[sum].b=i;}  
        x=n/(n/i)+1-(n/i);if (x%2==0 && x>0) {sum++;a[sum].a=x/2;a[sum].b=n/i;}  
    }  
    sort(a+1,a+sum+1,cmp);  
    for (i=1;i<=sum;i++)  
        printf("%d %d\n",a[i].a,a[i].b+a[i].a-1);  
    return 0
}

```

---

## 作者：LMSH7 (赞：1)

### 题意：
对一个给定的自然数M，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为M。

例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为M=10000的一个解。

------------
我们设$i$为自然数段的长度！
- 2：0+1、1+2、2+3...
- 3：0+1+2、1+2+3、2+3+4...
- 4：0+1+2+3、1+2+3+4、2+3+4+5...
- $i$：0+$s[i-1]+k*i$


易证：每一个长度为$i$的自然数段**可能**有一个$k$值所对的自然数段的和为$n$

   $n= s[i-1]+k*i$

AC—code
------------

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=2000000+5;
long long a[N];
int main(){
    int n;
    cin>>n;
    for(int i=2;i<=n;i++){
        a[i]=a[i-1]+i-1;//此处的a[i]为前缀和[i-1]
    }
    for(int i=n;i>=2;i--){
        if(n-a[i]>=0&&(n-a[i])%i==0){
            printf("%d %d\n",(n-a[i])/i,(n-a[i])/i+i-1);
        }
    }
    return 0;
}
```

---

## 作者：q_sum (赞：0)

本蒟蒻来发第二篇题解了！

此题是大水题，双重暴力直接解决。

第一重，枚举第一个数。

第二重，枚举最后一个数。

此方法时间复杂度不是特别优秀，需要有剪枝才能保证不TIE。

剪枝：如果和大于等于n，就没必要做下去了。

普及一下等差求和：s=（首项+尾项）*项数/2；高斯求和。

那么，就直接上代码吧！

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n;
int main()
{
    cin>>n; //简单的输入
    //暴枚，i枚举第一个数，j枚举最后一个数
    for(int i=1;i<=n/2;++i)//i枚举第一个数
        for(int j=i+1;j<=n/2+1;++j)//j枚举最后一个数
        {
            if((i+j)*(j-i+1)/2==n)//判断是否符合输出条件
            {
            //输出
                cout<<i;
                putchar(' ');//putchar速度快
                cout<<j;
                putchar('\n');//putchar速度快

            }
            //唯一的剪枝，保护程序不TIE
            //如果和大于等于n，就没必要做下去了
            if((i+j)*(j-i+1)/2>=n)//判断是否符合剪枝条件
              break;//跳出循环
        }
    return 0;//完美的结尾
}
```
//附带：不要抄题解

---

## 作者：memory_frv (赞：0)

首先我们要了解一个高斯求和公式，例如1一直加到一百=50*51，高斯求和公式为首项加尾项乘项数除以二
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
    int n,l,r,x,y;
    cin>>n;
    for(int i=n/2;i>=2;i--){
        x=2*n/i;
        y=(x-(i-1))/2;
        if((x-i+1)%2==1){
            continue;
        }
        if(y<0||x-y<0){
            continue;
        }
        if((y+x-y)*i/2==n){
            cout<<y<<" "<<x-y<<endl;
        }
    }
    return 0;
}
```
我们在这里不枚举首和尾，我们枚举项数i 设首项为l，尾项为r，则有(l+r)i/2=n 则l+r=2n/i;我们设l+r等于x 则有一元一次方程 设首项为a x-a-a=i-1 x我们已知，i-1为尾项减去首项 则有x-2a=i-1 移项后为x-i+1=2a 等号前我们已经知道，可求出a 程序中，首项我们是y 套用高斯求和公式 (y+x-y)i/2=n x*i/2=n 如果满足这个条件，就可以求得一组公式

---

## 作者：Delight_ (赞：0)

#  这道题我是用等差中项做的~~（大佬们的方法太强了）~~
1. 首先说一下什么是等差中项：就是一个等差数列中a（n）+a（m）=a（p）+a（l）

   条件是 _n+m=p+l_ 那么p=l=c时就是a（n）+a（m）=2×a（c）
1. 所以我们只需要从左到右搜一遍去找合适的等差中项就好了

1. 在搜的时候会出现俩种情况：第一种是这段数有奇数项，那么就很简单了，直接算出项数找出首末项就可以;第二种就是有偶数项，如果这样我们就找出中间的一对数的和，再去除m就知道了一共有多少对，这样就可以算出首末项了

```cpp
#include<cstdio>

using namespace std;

int m;

int main()
{
    scanf("%d",&m);
    for(int i=1;i<=m/2;i++)
    {
       if(m%i==0&&m/i%2==1)//如果有奇数项
       {
          int t=m/i;//项数
          t=t/2;
          if(i-t<=0||i+t>m)continue;//检查是否越界
          else
          {
             printf("%d %d\n",i-t,i+t);
             continue;
          }
       }
       int s=i*2+1;//中间俩项的和
       if(m%s==0)
       {
          int t=m/s;//一共有多少对
          if(i-t+1<=0||i+t>=m)continue;
          else
          {
             printf("%d %d\n",i-t+1,i+t);
          }
       }
    }
    return 0;
}
```

---

## 作者：totorato (赞：0)

# O(M)枚举

说明如下的事实：

既然是一个连续的数列，那么它们的和等于他们的平均数×项数

所以可以知道，它们的平均数一定是M的因数，且项数一定为奇数。

所以我们可以枚举项数，再判断是否合法。最终将所有合法答案排序输出即可

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;
int M;
typedef struct node_t
{
    int l,r;
    inline bool operator < (const node_t t)const{return l<t.l;}
}node;
vector<node>ans;
inline void work()
{
    node t;
    for(register int i=M;i>=2;i--)
        if((i&1)&&(M%i==0))
        {
            t=(node){M/i-i/2,M/i+i/2};
            if(t.l==0)t.l++;
            else if(t.l<0)t.l=-t.l+1;
            if(t.l>t.r)swap(t.l,t.r);
            ans.push_back(t);
        }
    sort(ans.begin(),ans.end());
    for(register int i=0;i<ans.size();i++)printf("%d %d\n",ans[i].l,ans[i].r);
}
int main()
{
    scanf("%d",&M);
    work();
    return 0;
}
```
# O(sqrt(M))枚举

由于数列的平均数是M的因数，因此我们可以做到O(sqrt(M))

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>

using namespace std;

int M;
typedef struct node_t
{
    int l,r;
    inline bool operator < (const node_t t)const{return l<t.l;}
}node;
vector<node>ans;
inline void work()
{
    node t;
    for(register int i=2;i*i<=M;++i)
        if((i&1)&&(M%i==0))
        {
            t=(node){M/i-i/2,M/i+i/2};
            if(t.l==0)t.l++;
            else if(t.l<0)t.l=-t.l+1;
            if(t.l>t.r)swap(t.l,t.r);
            ans.push_back(t);
        }
    for(register int i=1;i*i<M;++i)
        if(((M/i)&1)&&(M%i==0))
        {
            t=(node){i-(M/i)/2,i+(M/i)/2};
            if(t.l==0)t.l++;
            else if(t.l<0)t.l=-t.l+1;
            if(t.l>t.r)swap(t.l,t.r);
            ans.push_back(t);
        }
    sort(ans.begin(),ans.end());
    for(register int i=0;i<ans.size();i++)printf("%d %d\n",ans[i].l,ans[i].r);
}

int main()
{
    scanf("%d",&M);
    work();
    return 0;
}
```

---

## 作者：hl666 (赞：0)

```cpp
   var n,i,j,k:longint;
      begin
     readln(n);
     for i:=1 to n div 2+1 do//第一个数不可能大于你div2，安全起见枚举到你div2 +1；
     begin k:=i;//k用来统计总和
      for j:=i+1 to n div 2+1 do
     begin k:=k+j;//加上连续的那个数
           if k=n then writeln(i,' ',j);//如果等于这个数就输出
           if k>n then//大于了就说明这个数不行
     begin break;//退出循环
           k:=0; //计数器清零  end;  end;
     end;
     end.
```

//和数论有毛关系。。。。。。

//枚举第一个数和接下来连续的数，如果大于m就退出。


---

## 作者：_J_C_ (赞：0)

/\*为什么它会被归入”简单的数学问题“？

因为这确实可以当成数学问题去做……

我们知道(首项+尾项)\*项数/2 是求连续自然数和的公式。

那么翻过反反过来，一旦首项确定，我们可以通过解二次方程得出尾项……

当然，可能尾项是个无效值（小数）**

上代码\*/

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
int dest;
long long int record[2][1000];//记录输出的数字
int iEnd(0);
int main()
{
    scanf("%d", &dest);
    for (long long int i(0); i <= dest / 2; ++i)
    {
        double a((-1 + sqrt(static_cast<double>(1 + 4 * (i*i - i + 2 * dest)))) / 2);/*因为a>i，所以我们只需要取比i大的解就可以了，但要注意精度丢失，所以用double*/
        if (a==static_cast<int>(a) && i < a)//判读a是否为整数 并且 判断a是否大于i
        {
            record[0][iEnd]=i;
            record[1][iEnd++]=a;
        }
    }
    if (iEnd == 0)return 0;//这个……谁知道会不会无解
    printf("%lld %lld", record[0][0], record[1][0]);//格式控制，保证无多余空格
    for (int i(1); i != iEnd; ++i)
    {
        printf("\n%lld %lld", record[0][i], record[1][i]);
    }
    //system("pause");
    return 0;
}
```

---

## 作者：wayne_lee (赞：0)

看看前面各位dalao的方法，感觉都比较高端，我这个蒟蒻来自告奋勇的说一下我的暴力方法（真的很暴力/doge）

这道题因为是要的是连续的自然数，即为等差数列，所以他的中项一定是一个整数（奇数）或是两个相邻整数的平均数即n.5（偶数）且等于平均数。

所以我们就暴力的循环所分分出数字的个数，用总数相除就是中间那个数。若组数是奇数，则中间那个数必须是整数，若组数是偶数，则中间的那个数一定得是 n.5 。

如果判中了，就意味着我们知道了一个连续自然数列的中间的数且知道了这个数列的长度，所以就可以轻松的输出首相和末项了。

```cpp
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int i,j,n;
    double ans;
    scanf("%d",&n);
    for(i=n-1;i>1;i--)
    {
        ans=(double)n/(double)i;
        if(i%2==1&&ans-(int)ans==0&&ans>=i/2+1&&n-ans+1>=i/2+1)
        printf("%d %d\n",(int)ans-i/2,(int)ans+i/2);
        if(i%2==0&&ans-(int)ans==0.5&&(int)ans>=i/2&&n-(int)ans>=i/2)
        printf("%d %d\n",(int)ans-i/2+1,(int)ans+i/2);
    }
}
```
注：记得要判断这一列数会不会出界。
虽然复杂度是O（n),但是我觉得i循环的其实和结尾应该是可以缩小不少的，但我懒得算了，反正Nmax也就2,000,000


---

## 作者：撩妹凛酱 (赞：0)

最初是在学校训练的时候做到这道题，很多人一时都做不出来，也有大神各种数学推理给出正解。然而麻烦的数学推理对于我这种学弱来说简直是天书...后来发现其实枚举是可以过的，而且不像很多人想的会超时。这里就具体讲一下枚举的思路。看到下面其实已经有差不多的做法了，但是同学还是表示看不懂，于是这里具体的讲讲。

总的来说枚举的做法就像是一条分很多节的毛毛虫，靠在后面添加和在前面减少来达到预期的长度（值）。因此枚举就要从1开始，到最后可以在m div 2的位置结束（因为最后的数段就是奇数m div 2+m div 2+1或偶数m div 2-1+m div 2）。

枚举时用一个数组a来储存当前的队列并用sum表示当前队列的和，在sum=m时输出。如果sum未达到m则在后面加数，当sum大于m，则将队列最前面的数删掉继续枚举。

主要的框架：

```cpp
    i:=0;
   while i<= m div 2+1 do begin
      inc(i);inc(j);
      a[j]:=i;
      sum:=sum+i;
      if sum=m then print;
      if sum<m then continue;
      if sum>m then sum:=sum-(?)
end;
```

---

## 作者：ling (赞：0)


//Pascal代码怎么都又臭又长，我来个浅显易懂的



```cpp
var
  n:int64; //怕数据太大爆
  i,j:longint;
begin
  read(n);
  for i:=1 to n div 2+1 do //到n div 2+1 为了减少搜索次数
    for j:=i+1 to n div 2+1 do//不能到n div 2 比如说n=3就不对了
    begin
      if (i+j)*(j-i+1) div 2=n then writeln(i,' ',j);//等差数列，不解释，找到就输出
      if (i+j)*(j-i+1) div 2>n then break;//加起来超了就找下一个，可以大大缩短时间，没加70分
    end;
end.
//AC
```

---

## 作者：Small (赞：0)

这道题可以枚举起点，设起点为a，终点为b，所有数的总和为n，则得到算式(a+b)(a-b+1)/2=n。

把多项式展开并移项，可以得到b^2=a^2-a-b+2n，b^2<a^2+2n，b<sqrt(a^2+2n)，由此可以得到b的值的上限。

为了方便查看，再写一遍证明过程，具体如下：

```cpp
- (a+b)(a-b+1)/2=n
- b^2=a^2-a-b+2n
- b^2<a^2+2n
- b<sqrt(a^2+2n)
```
由此得到了b的上限，其实sqrt(a^2+2n)向下取整就是我们得到的b值，证明过程如下（这个证明并不重要，但是为了题解的严谨精神还是写上了），没有兴趣的可以直接跳过：
(此证明为证明sqrt(a^2+2n)<b+1)

- (b+1)^2=b^2+2b+1

- (b+1)^2=a^2-a-b+2n+2b+1

- b+1=sqrt(a^2-a-b+2n+b+b+1)>sqrt(a^2-a-b+2n+b+a)>b(a为起点，因此a一定小于b+1)

通过上述证明，我们得出结论，b=sqrt(a^2+2n)(b是整型变量)，因此只需要枚举起点a即可计算出终点b，然后根据(a+b)(a-b+1)/2判断这对a,b是否符合条件，符合条件则输出。

接下来附上我的代码（总耗时12ms）：

``` cpp
#include<iostream>//大部分头文件在这个题里都没用，忽略即可
#include<string.h>
#include<stdio.h>
#include<algorithm>
#include<map>
#include<queue>
#include<stack> 
#include<vector>
#include<math.h> 
#define ll long long//这个有用，下面的ll就是long long的意思
#define maxn 0x7fffffff
#define mod 1000000007 
using namespace std;
ll tem,n;//tem的作用是暂时存储在当前起点a得到的和，n为题目所给的总和
ll pow(int a,int b)//这个是快速幂函数，在本题中无用，请忽略
{
    ll ans=1;
    while(b>0)
    {
        if((b&1)==1) ans*=a;
        a*=a;
        b>>=1;
    }
    return ans;
}
ll getans(ll st)//怕超出int范围所以用的long long，其实不会超
{
    ll ed=sqrt(st*st+2*n),tem=(ed-st+1)*(ed+st)/2;//st代表起点，ed代表终点
    if(tem==n)
    {
        cout<<st<<' '<<ed<<endl;
    }
}
int main()
{
    scanf("%lld",&n); 
    for(ll i=1;i<=n/2;i++)//如果n是奇数，则起点最大为(n-1)/2
    {
        getans(i);
    }
    return 0;
}
```

---

## 作者：Ste_ (赞：0)

/\*
这里是一个很快的数学方法，复杂度为O（根号n）

具体的算法是由于等差数列的通项公式 Sn=(a1+an)n/2

可以通过枚举因子来找到首项末项和

然后解方程：a1+an=首项末项和 an-a1+1=项数求出a1和an

注意项数小于首项末项和，原因看方程，所以O根号n枚举项数就行

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int Mx=2e7+5;
int n;
int main()
{
    cin>>n;
    for(int i=int(sqrt(2*n)); i>=2; i--)//这里枚举项数
        {
            if(2*n%i==0)
                {
                    int x=(i+2*n/i-1)/2;
                    int y=2*n/i-x;
                    if(x<n&&x-y+1==i) //这里判断解是否符合条件，考虑到i为偶数的情况x不为整数，所以要特判。 
                    cout<<y<<' '<<x<<endl;
                }
        }
    return 0;
}

```

---

## 作者：wsh958871969 (赞：0)

用平均数思想

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double N;
int main()
{
    cin>>N;
    for(int i=N;i>=2;i--)
    {
        double M;
        M=N/i;
        int k=2*M;
        if(i%2==0&&k==2*M&&k%2==1)
        {
            double j=i-1;
            j/=2;
            if(M-j>0)
            cout<<M-j<<' '<<M+j<<endl;
        }
        else if(i%2==1&&M==(int)M)
        {
            double j=(i-1)/2;
            if(M-j>0)
            cout<<M-j<<' '<<M+j<<endl;
        }
    }
    return 0;
}
```

---

## 作者：fighter_OI (赞：0)

枚举序列长度，由等差数列求和公式可得长度必为和的因数

分奇数和偶数讨论负数的越界情况

```cpp
var n,i,j,s:int64;
begin
 read(n);
 s:=0;
 for i:=n downto 2 do//枚举长度
  begin
   if (i mod 2=0)and(n*2 mod i=0)and(n mod i<>0)and((n*2 div i)-i+1>0) then//偶数
    writeln(((n*2 div i)-i+1) div 2,' ',((n*2 div i)+i-1) div 2);
   if (i mod 2=1)and(n mod i=0)and(n div i-i div 2>0) then//奇数
    writeln(n div i-i div 2,' ',n div i+i div 2);
  end;
end.
```

---

## 作者：ZLJHHH (赞：0)

//枚举   用  总和=（首项+末项）乘 项数 除以 2

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int a;
    cin>>a;
    a=a*2;
    for(int i=a/2;i>=2;i--)
    {
        if(a%i==0)
        {
            int j=a/i;
            for(int k=1;k<=j/2;k++)
            {
                if((j-k)-k+1==i)
                cout<<k<<" "<<j-k<<endl;
            }
        }
    }
    return 0;
}
```

---

## 作者：Stolf (赞：0)

可以用自然数求和公式来防止超时。

```cpp

#include <iostream>  
long long n, sum, j;  
int main(int argc, char *argv[])  
{  
    std::cin >> n;  
    for (long long i = 1; i <= n; i++)  
    {  
        for (j = i + 1; j < n; j++)  
        {  
            sum = (i + j) * (j - i + 1) / 2;  
            // 自然数求和公式  
            // #1 Sn = n * (n + 1) / 2  
            // #2 Smn = (n + m)(n - m + 1) / 2   
            if (sum >= n)   
                break;  
        }  
        if (sum == n)  
            std::cout << i << ' ' << j << std::endl;  
    }  
} 

```

---

## 作者：Mr_Li (赞：0)

因为设数列a1,a2,a3,...,an是等差数列，

n
则  ∑  ai=n·(a1+an)/2.

    i=1

所以我们可以求出m的每个因数ai，

并通过ai构造和等于m的等差数列b+1,b+2,b+3,...,b+m/ai，

易得ai=(b+1+b+m/ai)、2,

即只要n-m/ai>=b>=-1,

此数列就是m的一个解。

求因数的时间复杂度为O（n），

求b值的时间复杂度是O（1），

判断数列是否是m的一个解的时间复杂度为O（1），

所以总的时间复杂度为O（n）。

附代码：

```cpp

#include<iostream>
using namespace std;
int m,i;
int main ()
{
    cin>>m;
    for (i=m-1;i>1;i--)
    if (m*2%i==0)
    if (m%i==0&&i%2==1&&m/i-i/2>0)
    cout<<m/i-i/2<<' '<<m/i+i/2<<endl;
    else
    if (m%i==i/2&&i%2==0&&m/i-i/2+1>0)
    cout<<m/i-i/2+1<<' '<<m/i+i/2<<endl;
    return 0;
} 

```

---

## 作者：影天亾 (赞：0)

            
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
int s;
int a,b;
int main()
{
    scanf("%d",&s);
    for(int i=s/2;i>=2;i--) /*i是项数进行循环，通过首项x，末项y联立方程组1.(x+y)*i/2=s
2.(y-x)+1=i 解得x=(2*s-i*i+i)/(2*i) ,y=(2*s+i*i-i)/(2*i) 单循环不会超时 */
    {
            a=(2*s+i*i-i)%(2*i);
            b=(2*s-i*i+i)%(2*i);
            if(a==0 && b==0 &&(2*s-i*i+i)/(2*i)>0)//验首项末项是否是整数并大于0
            { 
                            printf("%d %d\n",(2*s-i*i+i)/(2*i),(2*s+i*i-i)/(2*i));   
            }
    }
    return 0;
}

```

---


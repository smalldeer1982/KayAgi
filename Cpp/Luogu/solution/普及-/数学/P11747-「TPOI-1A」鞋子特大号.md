# 「TPOI-1A」鞋子特大号

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/71n3gd2r.png)

You may click here to read English statement.

> 我戴着圆顶礼帽 鞋子特大号
>
> 我手拿拐杖留着胡子 大家好
>
> 别什么你都想要快乐却找不到
>
> 幽默是挫折中优雅的礼貌
>
> ——周杰伦《[鞋子特大号](https://www.bilibili.com/video/BV1Wt4y1P74C)》

## 题目描述

给定一个数 $x$，你可以对其进行以下操作若干次，直到无法再操作：

- 选择一个数 $y$ 满足 $1 \le y < x$ 且 $\gcd(x,y) \not = 1$，并将 $x$ 变为 $\gcd(x,y)$。

现在有以下两种询问共 $T$ 个：

- `1 x`：给定 $x$，求 $x$ 最多能进行几次操作；

- `2 q`：给定 $q$，求出一个**最小的** $x$，使得 $x$ 最多能进行恰好 $q$ 次操作。


## 说明/提示

【样例 #1 解释】

对于 `1 2310`，以下是其中一种操作方式：

- 选择 $y=1890$，则此时 $x=\gcd(2310,1890)=210$；
- 选择 $y=84$，则此时 $x=\gcd(210,84)=42$；
- 选择 $y=18$，则此时 $x=\gcd(42,18)=6$；
- 选择 $y=2$，则此时 $x=\gcd(6,2)=2$。

此时无法再操作，所以结果为 $4$。

可以证明不存在一种方法可以操作超过 $4$ 次。

---

对于 `2 6`，可以证明，无法找出一个比 $128$ 小的数，使得其可以进行 $6$ 次操作。

【数据范围】

**本题采用捆绑测试。你只有通过一个子任务内的所有测试点，该子任务才会得分。**

|$\text{Subtask}$|特殊性质|分值|
|:-:|:-:|:-:|
|$0$|样例|$0$|
|$1$|$T \le 2,2 \le x \le 100,q \le 5$|$40$|
|$2$|$T \le 10^5,x \le 10^3,q \le 25$|$30$|
|$3$|无特殊性质|$30$|

对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le x \le 10^6$，$1 \le q \le 62$。

## 样例 #1

### 输入

```
2
1 2310
2 6```

### 输出

```
4
128```

# 题解

## 作者：Eason_cyx (赞：5)

签到题。

先看 `1` 询问：

分析一次操作，例如 $2310$ 和 $1890$ 进行操作。将两个数分解质因数得到，$2310=2\times3\times5\times7\times11$，$1890=2\times3\times5\times7\times3\times3$。操作完毕得到的数为 $210=2\times3\times5\times7$。可以看出，一次操作之后会将 $x$ 的质因子至少删去一个。当所有因子只剩下一个时，不能再删了，即为不能操作。

那么为了尽可能多地操作，我们只需要保证一次删去一个质因子即可，那么记初始 $x$ 的质因子个数为 $n$（例：$2310=2\times3\times5\times7\times11$，所以 $n=5$），那么最大操作次数显然是 $n-1$。

于是我们直接 $\Theta(\sqrt n)$ 枚举出 $x$ 的质因子个数即可。

再看 `2` 询问：

给定 $q$，求出一个**最小的** $x$，使得 $x$ 最多能进行恰好 $q$ 次操作。

那么既然能进行 $q$ 次操作，如果我们按最优方式操作，这个数一定只有 $q+1$ 个质因子。为了让这个 $x$ 最小，那么所有质因子也应该尽可能小。我们知道最小的质数为 $2$，所以这个询问的答案就是 $2^{q+1}$。$\Theta(q)$ 计算即可。

最终的时间复杂度为 $\Theta(T\sqrt{n})$，可以通过本题。记得开 `unsigned long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool isp(int x) {
	if(x <= 1) return false;
	for(int i = 2;i * i <= x;i++) {
		if(x % i == 0) return false;
	}
	return true;
}
int main() {
	int t; cin >> t;
	while(t--) {
		int opt,x; cin >> opt >> x;
		if(opt == 1) {
			int cnt = 0;
			for(int i = 2;i * i <= x;i++) {
				if(x % i == 0 && isp(i)) {
					while(x % i == 0) {cnt++; x /= i;}
					if(x == 1) {cnt--; break;}
				}
			}
			cout << cnt << endl;
		}
		else {
			unsigned long long p = 1;
			for(int i = 1;i <= x+1;i++) p *= 2;
			cout << p << endl;
		}
	}
	return 0;
} 
```

---

## 作者：canwen (赞：2)

简单题，建议橙。

对于第一种询问，显然是对其进行质因数分解，例如 $2310=2\times3\times5\times7$，即将 $2310$ 依次变成 $1155,385,77,11$ 即可，当然换成其他顺序依次除以质因子也可以，注意如果本身就是一个质数的话不能，因为题目规定 $1 \le y <x$；第二种询问，质因子全部是 $2$ 显然最小，那么跟第一问一样注意的点，答案是 $2^{k+1}$。

注意到 `long long` 的范围是 $-2^{63}\sim 2^{63}-1$ 的，所以最坏情况下 $2^{63}$ 会超过该范围，需要开 `unsigned long long`。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar_unlocked('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar_unlocked();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar_unlocked();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar_unlocked();return k*kk;}
void out(int a){if(a<0) putchar_unlocked('-'),a=-a;if(a>9) out(a/10);putchar_unlocked('0'+a%10);}

void work(){
	int op = in();
	if(op == 1){
		int x = in(), cnt = 0;
		_rep(i,2,sqrt(x)){
			while(x%i==0&&x!=i){
				x /= i, ++cnt;
			}
		}
		out(cnt), pc;
	}else{
		int q = in();
		out(1ull<<(q+1)),pc;
	}
}
signed main(){
	int T = in();
	while(T--){
		work();
	}
	return 0;
}
```

---

## 作者：__youzimo2014__ (赞：2)

引理：一次操作等价于选择一个不是 $1$ 且不是 $x$ 本身的一个 $x$ 的因子，因为只要令 $y$ 为这一因子，满足 $\gcd(x, y) = y$。

对于一个待操作的 $x$，不难发现最优策略是：每次让 $x$ 除以它的一个质因子。

于是可以得出：$x$ 的最大操作次数就是 $x$ 的质因数的个数（如果有重复那么都计算在里面）减一（因为最后要留一个）。

对于询问 $2$，我们知道最小的质数是 $2$，所以只要输出 $2^{q + 1}$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
ull factorize(ull x) { // 将 x 分解质因数后质因数的数量
    ull result = 0ull;
    for (ull i = 2ull; i * i <= x; i++) {
        while (x % i == 0ull) {
            result++;
            x /= i;
        }
    }
    if (x > 1 || result == 0) result++;
    return result;
}
int main() {
    int T;
    cin >> T;
    while (T--) {
        int op; cin >> op;
        if (op == 1) {
            ull x; cin >> x;
            cout << factorize(x) - 1ull << endl;
        } else {
            ull q; cin >> q;
            if (q == 0) cout << 0 << endl;
            else cout << (1ull << (q + 1ull)) << endl;
        }
    }
    return 0;
}
```

---

## 作者：CCY20130127 (赞：2)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P11747)

## 题目思路：
这一道题需要好好的分析一下。对于第一个操作，需要观察样例一，观察发现：
$$2310=2\times3\times5\times7\times11$$ 
$$1890=2\times3\times3\times3\times5\times7$$
$$210=2\times3\times5\times7$$
于是我们会发现，对于第一种操作，实际上是分解质因数后取相同的质因数部分再组成一个新数。综上所述，我们要不断删去 $$x$$ 的质因数，因为要得到最优解。观察得每次删去的个数为 $1$ 时最优，此时答案为 $$n-1$$。

对于第二个操作：

综上所述，$$x$$ 的质因子个数应为 $$q+1$$。睁大眼睛仔细看，最小值！最小值！最小值！为了使这个数最小，这个数中的所有质因子都是 $$2$$。所以答案为 $$2^{q+1}$$。

## 正解：
答案时刻到！记得开长整型。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll t,a,b;
bool prime(ll x){
	if(x<=1) return false;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0) return false;
	}
	return true;
}
void eiw(ll b){
	ll cnt=0;
	for(int i=2;i<=sqrt(b);i++){
		if(b%i==0&&prime(i)){
			while(b%i==0) cnt++,b=b/i;
			if(b==1) {
				cnt--;
				break;
			}
		}
	}
	cout<<cnt<<"\n";	
}
void dgsgsdg(ll b){
	ll ans=1;
	for(ll i=1;i<=b+1;i++) ans*=2;
	cout<<ans<<"\n";
}
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>a>>b;
		if(a==1) eiw(b);
		else dgsgsdg(b);
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：2)

奶龙验题人题解。

每次操作都会把 $x$ 变为其真因子。那么为了使操作数尽量多，我们每次操作只让 $x$ 除以一个素数即可。那么询问一答案为 $x$ 的素因子个数减一，注意特判 $x=1$ 的情况。对于询问二，我们让每次减少的素数都为 $2$ 即可，答案为 $2^{q+1}$。注意 $q+1\le63$，而 $2^{63}=9223372036854775808$ 要开 `unsigned long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t;cin>>t;
	while(t--){
		int op,x;cin>>op>>x;
		if(op==1){
			//2310=2*3*5*7*11
			int sum=0;
			for(int i=2; i*i<=x; i++) while((x%i==0)) x/=i,sum++;
			if(x>1) sum++;
			cout<<max(sum-1,0)<<"\n";
		}
		else{
			unsigned long long ans=2;
			for(int i=1; i<=x; i++) ans*=2;
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：yedalong (赞：1)

## Solution

相信很多同学拿到这道题跟我一样没思路，但是当我们发现这道题与最大公约数有关后，就可以朝这个方向想一下。

首先我们先看问题 $1$，要怎么做才能使得操作次数最多呢？我们可以很容易地发现一个性质，操作次数最多的做法，每一次操作的 $\gcd(x,y)$ 一定是等于 $y$ 的，这是很好想到的。那么 $x$ 就一定是 $y$ 的倍数了，也就是每一次操作将 $x$ 除以它的其中一个因子，要使得操作次数最多，那就一定是除以它的质因子了。所以，我们设 $x$ 的质因子数量为 $k$，答案就为 $k-1$，这里要再减去 $1$ 的原因是：当我们只剩下一个质因子是，就会发现它与任何一个比它小的数的最大公约数为 $1$，违背了题意。\
最后只需对 $x$ 进行质因数分解就能愉快的结束第一小问了。

然后我们看问题 $2$。有了第一问的基础，我们会发现答案的质因子个数为 $q+1$，由于是最小，所以我们可以让这 $q+1$ 个质因子全部为最小的质数 $2$，那么答案就是 $2^{q+1}$ 了。这里有一个小坑点，题目中说 $q\le62$，再让 $q$ 加上 $1$ 后答案最大可以达到 $2^{63}$，已经超出了 `long long` 的范围，需要使用 `unsigned long long` 才能通过此题。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
int t,opt,x,q,ans;
bool is_prime[1000005];
signed main(){
    cin>>t;
    for(int i = 2;i<=1000000;i++){
        if(!is_prime[i]){
            for(int j = 2;j*i<=1000000;j++){
                 is_prime[i*j]=1;   
            }
        }
    }
    for(int i = 2;i<=1000000;i++) is_prime[i]^=1;
    while(t--){
        cin>>opt;
        if(opt==1){
            ans=0;
            cin>>x;
            for(int i = 2;i*i<=x;i++){
                while(x%i==0&&is_prime[i]){
                    if(x==i) break;
                    x/=i;
                    ans++;
                }
                if(x==i) break;
            }
            cout<<ans<<'\n';
        }
        else{
            cin>>q;
            ans=2;
            while(q--) ans*=2;
            cout<<ans<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：LG086 (赞：1)

现有两种询问，一种是求 $x$ 最多能进行几次操作，另一种是求出一个最小的满足条件的 $x$。

先看看这操作：选择一个数 $y$ 满足 $1\le y\lt x$ 且 $\gcd(x,y) \not = 1$ 并将 $x$ 变为 $\gcd(x,y)$。有另一种操作方式，与上述操作本质上是相同的：选择一个数 $y$ 满足 $1\le y\lt x$ 且 $\gcd(x,y) \not = 1$ 并将 $x$ 变为 $\dfrac{x}{y}$。两种操作都是将 $x$ 变为一个小于它本身的非 $1$ 的约数。

什么时候无法操作呢？显然，当 $2$ 到 $x-1$ 的数都和 $x$ 互质时，无法继续操作，也就是当 $x$ 为一个**质数**的时候。  
想到这，考虑对输入的 $x$ 经行质因数分解。假设 $x = {p_1}^{a_1} \times {p_2}^{a_2} \times \dots \times {p_k}^{a_k}$，那么每次操作可以选择其中的一个 ${p_{i}}$，将 $x$ 变为 $\dfrac{x}{p_{i}}$，直到 $x$ 是一个质数。

由上可得询问一的答案，就是 $a_1+a_2+\dots+a_k-1$。**注意**，若一开始输入的 $x$ 是 $1$，请输出 $0$。

那么询问二该如何解决？已知对 $x$ 最多可以操作 $a_1+a_2+\dots+a_k-1$ 次，而 $x = {p_1}^{a_1} \times {p_2}^{a_2} \times \dots \times {p_k}^{a_k}$，所以每个 $a_i$ 相加应该等于输入的 $q$ 再加 $1$。  
要想 $x$ 变小，那么就让 $a_i$ 大，$p_i$ 小。$p_i$ 最小是 $2$，$2^{q+1}$ 显然就是最小的符合条件的 $x$。**注意**，因为 $q \le 62$，这个 $2^{63}$ 太大了，所以记得使用 `unsigned long long`。

代码略。

---

## 作者：DrDuck (赞：1)

第一问：

我们重新考虑最大公因数的本质，其实就是取两个数的公共质因子。又由于 $1 \le y < x$，每次做取最大公因数的操作时，结果与原数相比，质因子必定比原来少。根据贪心，肯定是每次操作只筛去一个质因子是最优的。设 $x$ 的质因子数为 $p$，那么答案就是 $p - 1$。注意 $x = 1$ 要特判。

第二问：

这个最小的 $x$ 肯定是当 $x$ 的质因子全为 $2$ 的时候是最优的。采用反证法，假设 $x$ 有一个大于 $2$ 的质因子，那么把它替换成 $2$ 能得到的数质因子数与原数相同，但是替换后得到的数肯定比原数小，这与 $x$ 最小矛盾。所以答案就是 $2^{q + 1}$。注意当 $q = 62$ 时会爆 long long。
# 赛时代码 #
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e+6 + 6;
int t;
int fac(int x)
{
    int cnt = 0;
    for (int i = 2; i * i <= x; i++)
    {
        while (x % i == 0)
        {
            x /= i;
            cnt++;
        }
    }
    if (x != 1)
    {
        cnt++;
    }
    cnt--;
    return cnt;
}
signed main()
{
    cin >> t;
    while (t--)
    {
        int op, x;
        cin >> op >> x;
        if (op == 1)
        {
            if (x == 1)
            {
                cout << 0 << '\n';
            }
            else
            {
                cout << fac(x) << '\n';
            }
        }
        else
        {
            unsigned int p = 1;
            for (int i = 1; i <= x + 1; i++)
            {
                p *= 2;
            }
            cout << p << '\n';
        }
    }
    return 0;
}
```

---

## 作者：C_0_a4S (赞：1)

修改了一处错误。

又修改了一处错误。
### 题目

给定一个数 $x$，你可以对其进行以下操作若干次，直到无法再操作：

- 选择一个数 $y$ 满足 $1 \le y < x$ 且 $\gcd(x,y) \not = 1$，并将 $x$ 变为 $\gcd(x,y)$。

现在有以下两种询问共 $T$ 个：

- `1 x`：给定 $x$，求 $x$ 最多能进行几次操作；

- `2 q`：给定 $q$，求出一个**最小的** $x$，使得 $x$ 最多能进行恰好 $q$ 次操作。

### 解法

#### 第一问

为了使操作次数最多，我们要使 $\gcd(x,y)$ 尽可能大。

我们知道，当 $y \mid x (x \ge y)$ 时，$\gcd(x,y)=y$。

又因为 $1 \le y < x$（不然就能无限次操作了），所以我们要找到 $x$ 最小的且不等于 $1$ 的因子（设其为 $m$），使 $y=x \div m$。由于 $m$ 要最小，所以 $m$ 一定是一个素数。

答案显然是 $x$ 的素数因子减去 $1$（素数无法进行操作）。我们只需分解质因数即可。

**注意特判 $x=1$ 的情况（输出 $0$），不然只有 $40$ 分。**

#### 第二问

由第一问的解释可得，要使 $m$ 最小，而最小的素数是 $2$，所以 $m=2$。

为了能进行最多 $q$ 次操作且 $x$ 最小，我们让每一次操作的 $m=2$，然后 $y=x \div m$。

当 $x=2^{q+1}$ 时，一共可进行 $q$ 次操作且 $x$ 最小。

**注意 $2^{63}$ 会爆 **`long long`**。**

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

void debug(int u){
	cerr<<u<<"-\n";
} 
inline int read(){
	int x=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		f|=ch=='-';
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return f?-x:x;
} 
bool isprime(int u){
	if(u==1)	return 0;
	else{	
		int k=sqrt(u);
		for(int i=2;i<=k;i++){
			if(i*(u/i)==u)	return 0;
		}
		return 1;
	}
}

inline void write(int x){
	if(x<0)
		putchar('-'),x=-x;
	if(x<=9){
		putchar(x+'0');
		return;
	}
	write(x/10);
	putchar(x%10+'0');
}
int divs[114514];
signed main(){
	int t=read();
	while(t--){
		int op=read();
		int n=read();
		if(op==1){
			if(n==1){
				cout<<0<<'\n';
				continue;
			}
			if(isprime(n)){
				cout<<0<<'\n';
				continue;
			}
			int cnt=0;
			for(int i=2;i*i<=n;i++){
				while(n%i==0){
					n/=i;
					divs[++cnt]=i;
				}
			}
			if(n!=1)	divs[++cnt]=n;
			cout<<cnt-1<<'\n';
		}
		else{
			cout<<(2ull<<n)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Perfect_Youth (赞：1)

感觉很一眼。

本题的意思其实比较明确，如果询问是 $1$，你就进行质因数分解，答案在减一即可。$x=1$ 需要特判输出 $0$。

询问为 $2$ 的更简单，既然要最小那就质因数只有 $2$ 就可以了，而是询问 $1$ 的逆向思维，所以输出 $2^{q+1}$ 就行了，$q=62$ 的时候 $2^{63}$ 已经爆 `long long`，可以开 `unsigned long long` 或者特判就行了。

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1 , 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

inline
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

int t, opt, x, cnt;

signed main() {
	t = read();
	while (t--) {
		opt = read(), x = read();
		if (opt == 1) {
			cnt = 0;
			if (x == 1) cnt++; 
			for (int i = 2; 1llu * i * i <= x; i++) {
				while (x % i == 0) {
					x /= i;
					cnt++;
				}
			}
			if (x != 1) cnt++;
			printf ("%llu\n", cnt - 1);
		} else {
			printf ("%llu\n", 1llu << x + 1);
		}
	}
	return 0;
}
```

---

## 作者：ridewind2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11747)

## 思路

一道思维题，暴力就会得到 TLE 的拥抱，所以我们来找找规律。

### 一操作

先看 $1$ 操作，我们举个例子：

$x=600$;

$y=300,x=\gcd(600,300)=300$；

$y=150,x=\gcd(300,150)=150$；

$y=75,x=\gcd(150,75)=75$；

$y=25,x=\gcd(75,25)=25$；

$y=5,x=\gcd(25,5)=5$；

无法再进行操作，结束。

可以发现，我们每次消掉 $x$ 的一个**质因数**（因为合数可以拆分成多个质数，如果用合数就会把多次操作合成一次，就无法让操作次数尽可能多），直到 $x$ 变成一个质数，就可以让操作次数尽可能多，每次的 $y$ 就等于 $x$ 除以 $x$ 的一个质因数，所以答案就是 $x$ 的质因数数量减 $1$，我们将 $x$ 分解质因数即可。

注意，$y=1$ 需要特判，输出 $0$。

### 二操作

我们接下来看 $2$ 操作，我们来找找规律：



|q|答案|
|:-:|:-:|
|1|4|
|2|8|
|3|16|
|4|32|
|5|64|
|6|128|
|7|256|
|8|512|
|9|1024|

我们很容易就会找到规律，答案是 $2_{}^{q+1}$。

注意：要开 unsigned long long。


## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
signed main(){
    int t;
    cin>>t;
    while(t--){
        int op;
        cin>>op;
        if(op==1){
            int x;
        	cin>>x;
            if(x==1){//特判
                cout<<"0\n";
                continue;
            }
            int c=0;
            for(int i=2;i<=x/i;i++){//分解质因数
                while(x%i==0){
                    x/=i;
                    c++;
                }
            }
            if(x>1)c++;
            cout<<c-1<<"\n";
        }else if(op==2){
        	int q;
        	cin>>q;
            cout<<(1ull<<(q+1))<<"\n";
        }
    }
	return 0;
}
```

---

## 作者：luozihang (赞：1)

### [题目真不错](https://www.luogu.com.cn/problem/P11747)

## 问题分析
### 本题有两种询问类型：

****类型 1****：给定一个数 $x$，求 $x$ 最多能进行几次操作$。$操作规则是选择一个数 $y$ 满足 $1 < y < x $且 $y$ 是 $x$ 的因子，然后将 $x$ 变为 $x / y。$

****类型 2****：给定一个数 $q$，求出一个最小的数，使得该数最多能进行恰好 $q$ 次操作$。$

## 解题思路
****对于类型 $1$ 询问****：要使操作次数最多，每次应选择最小的非 $1$ 因子 $y$ 进行操作，直到 $x$ 变为 $1$。可以通过不断分解质因数来计算操作次数$。$

****对于类型 $2$ 询问****：为了得到最小的数进行恰好 $q$ 次操作，应选择最小的质数依次相乘$。$因为每次选择最小的质数作为因子进行操作，能保证操作次数达到要求且数最小$。$

### 代码呢？嘿嘿

```cpp
#include <iostream>
#include <vector>

// 计算 x 最多能进行几次操作
int maxOperations(int x) {
    int count = 0;
    for (int i = 2; i * i <= x; ++i) {
        while (x % i == 0) {
            x /= i;
            ++count;
        }
    }
    if (x > 1) {
        ++count;
    }
    return count;
}

// 求出一个最小的数，使得该数最多能进行恰好 q 次操作
int findMinNumber(int q) {
    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
    int result = 1;
    for (int i = 0; i < q; ++i) {
        result *= primes[i];
    }
    return result;
}

int main() {
    int n;
    std::cin >> n;

    for (int i = 0; i < n; ++i) {
        int type, num;
        std::cin >> type >> num;

        if (type == 1) {
            std::cout << maxOperations(num) << std::endl;
        } else if (type == 2) {
            std::cout << findMinNumber(num) << std::endl;
        }
    }

    return 0;
    防 Copy ;
}
```
求过/(ㄒoㄒ)/~~

---

## 作者：never_knew (赞：0)

先讨论一操作，不难发现每次操作都要除以他的因子，想要尽可能多的操作次数，就不妨每次只除他的一个质因子，需要注意的是，我们要留一个质因子，因为 $y$ 要小于 $x$。

再讨论二操作，由一操作可知，最多 $q$ 次操作意味着有 $q$ 个质因子，发现 2 是最小的质因数，由于最后需要留一个质因数，所以答案是 $2^{q+1}$。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+1;
bitset<N> shu;
vector<int> ss;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline unsigned long long read() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
void write(unsigned long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
    return;
}
void write1(unsigned long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
    return;
}
signed main()
{
    int t;
    cin>>t;
    int N1=N-1;
    shu[1]=shu[0]=1;
    for(int i=1;i<=N1;i++)
    {
        if(shu[i]==0) ss.push_back(i);
        for(int j=0;j<ss.size();j++)
        {
            if(i*ss[j]>N1) break;
            shu[i*ss[j]]=1;
            if(i%ss[j]==0) break;
        }
    }
    while(t--)
    {
         unsigned long long x=read(),n=read();
        if(x==1)
        {
            int cnt=0;
            if(n==1) {cout<<0<<endl;continue;}
            for(int i=0;i<ss.size()&&n!=1;i++)
            {
                 while(n%ss[i]==0) n/=ss[i],cnt++;    
            }
            write(cnt-1+(n!=1));
        }
        else
        {
            unsigned long long mul=1ull;
            write((mul<<(n+1ull)));
        }
        puts("");
    }
    return 0;
}
```

---

## 作者：zhoumurui (赞：0)

### 题面展示

给定一个数 $x$，你可以对其进行以下操作若干次，直到无法再操作：

- 选择一个数 $y$ 满足 $1 \le y < x$ 且 $\gcd(x,y) \not = 1$，并将 $x$ 变为 $\gcd(x,y)$。

现在有以下两种询问共 $T$ 个：

- `1 x`：给定 $x$，求 $x$ 最多能进行几次操作；

- `2 q`：给定 $q$，求出一个**最小的** $x$，使得 $x$ 最多能进行恰好 $q$ 次操作。

### 解题思路

前置知识：数论基础。

注意到选择一个数 $y$ 进行操作等价于选择 $\gcd(x,y)$ 进行操作。

理由是只要 $y$ 能够被选择，那么就有 $1 \le y < x$ 且 $\gcd(x,y) \not = 1$，这时选择 $\gcd(x,y)$ 进行操作也会把 $x$ 变为 $\gcd(x,y)$。

每次操作可以简化为选择 $x$ 的一个**因数** $y$ 满足 $1 \le y < x$，并将 $x$ 变为 $y$。

容易想到每次将 $x$ 除以一个质数。这一定是最优的，因为如果有一次操作将 $x$ 除以一个合数，那么将这个合数分解成质数就可以增加操作数。

当 $x$ 是质数时，无法再进行操作。也就是说，询问 $1$ 的答案就是 $x$ 能分解出的质数的数量再减 $1$。

如 $2310=2 \times 3 \times 5 \times 7 \times 11$，答案是 $4$。再如 $12=2 \times 2 \times 3$，答案是 $2$。

我们只需要计算 $x$ 能分解出多少个因数就可以了。

接下来看询问 $2$。先给结论：答案是 $2^{q+1}$。

由前面的结论，$2^{q+1}$ 一定能进行 $q$ 次操作。那么为什么它是最小的呢？

**证明** 用反证法。

- 假设存在一个数 $X<2^{q+1}$ 能进行 $q$ 次操作，那么它一定能分解成至少 $q+1$ 个质数的乘积。
- 由于 $2$ 是最小的质数，所以它一定不小于 $q+1$ 个 $2$ 的乘积，也就是说 $X \ge 2^{q+1}$。
- 这与假设矛盾。因此假设不成立，原命题得证。

证明完毕，也就是说询问 `2 q` 的答案是 $2^{q+1}$。我们只需计算这个值。注意 $q \le 62$，$2^{63}$ 恰好爆 long long。

### 核心代码展示

```
int n,m;
int h[100005],e[1000005],ne[1000005],idx;
int cal(int x){
    int cnt=0;
    for (int i=2;i*i<=x;i++){
        while (x%i==0){
            //cout<<x<<"\n";
            x/=i;
            cnt++;
        }
    }
    if (x>1)cnt++;
    return cnt-1;
}
signed main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        int op,x;
        cin>>op>>x;
        if (op==1){
            if (x==1)cout<<0<<"\n";
            else cout<<cal(x)<<"\n";
        }
        else {
            if (x==62)cout<<2*((unsigned long long)(1LL<<x))<<"\n";
            else cout<<(1LL<<x+1)<<"\n";
        }
    }
    return 0;
}
```

---

## 作者：ran_qwq (赞：0)

对于第一问，因为 $y<x$，所以当 $x$ 不为质数时，至少除以一个质因子。而可以令 $y=\dfrac xp$，这里的 $p$ 是任一个质因子，可以执行质因子个数（重复算多次）减 $1$ 次。注意特判 $x=1$ 的情况。

对于第二问，根据第一问把质因子构造成 $2$ 最优，即答案为 $x=2^{q+1}$。

```cpp
void QwQ() {
	int o=rd(),x=rd();
	if(o==1) {
		if(x==1) return wr(0,"\n"); int c=0;
		for(int i=2;i*i<=x;i++) while(x%i==0) x/=i,c++;
		if(x!=1) c++; wr(c-1,"\n");
	} else printf("%llu\n",1ull<<x+1);
}
```

---

## 作者：fish_love_cat (赞：0)

只过了这题，遗憾离场。

---

**第一部分求操作数：**

特判 $x=1$。

观察性质，每次操作后 $x$ 就会少一个质因子。

当 $x$ 是质数时无法操作。

所以答案就是 $x$ 的质因子数量减一。

枚举出 $x$ 的质因子数量就可以得到答案了。

---

**第二部分求最小值：**

显然此时质因子数量为 $x+1$。

那么我们全部堆最小的质数就行了。

答案为 $2^{x+1}$。

---

然后要开 `ull`。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
void solve1(int x){
    int ans=0;
    for(int i=2;i*i<=x;i++){
        while(x%i==0){
            x/=i;
            ans++;
        }
    }
    cout<<ans-(x==1)<<'\n';
}
void solve2(int x){
    cout<<(1ull<<(x+1))<<'\n';
}
void solve(){
    int op,x;
    cin>>op>>x;
    if(x==1&&op==1){
        puts("0");
    }else if(op==1)solve1(x);
    else solve2(x);
}
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：M1__ (赞：0)

# 题解：P11747 「TPOI-1A」鞋子特大号
[题目传送门](https://www.luogu.com.cn/problem/P11747)
## 题目思路
对于第一种操作：
  - 首先观察样例 $1$，因为我们选择了 $y=1890$ 使 $x=\gcd(2310,1890)=210$。分解质因数得：
    - $2310=2 \times 3 \times 5 \times 7 \times 11$
    - $1890=2 \times 3 \times 3 \times 3 \times 5 \times 7$
    - $210=2 \times 3 \times 5 \times 7$
  - 于是我们会发现，对于第一种操作，实质上是分解质因数后取相同的质因数部分再组成一个新数。也就是说，我们要不断删去 $x$ 的质因数。显然每次删去的个数为 $1$ 时最优。此时答案为 $n-1$。

对于第二种操作：
  - 同上文，$x$ 的质因子个数应当为 $q+1$。
  - 显然为了使这个数最小，这个数中的所有质因子当且仅当它们都为 $2$。
  - 因此答案为 $2^{q-1}$。

所以我们可以借助 $3$ 个函数来实现。即质数筛、操作一对应的函数和操作二对应的函数。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll T,a,b;
bool szs(ll x){
	if(x<=1) return 0;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0) return 0;
	}
	return 1;
}
void op1(ll b){
	ll cnt=0;
	for(int i=2;i<=sqrt(b);i++){
		if(b%i==0&&szs(i)==1){
			while(b%i==0) cnt++,b=b/i;
			if(b==1) {
				cnt=cnt-1;
				break;
			}
		}
	}
	cout<<cnt<<"\n";	
}
void op2(ll b){
	ll ans=1;
	for(ll i=1;i<=b+1;i++){
		ans=ans*2;
	}
	cout<<ans<<"\n";
}
int main(){
	cin>>T;
	while(T--){
		cin>>a>>b;
		if(a==1) op1(b);
		if(a==2) op2(b);
	}
	return 0;
}
```

---

## 作者：glass_goldfish (赞：0)

让我们思考，对于一个 $x$，我们能够找到的符合题意的 $y$ 有什么条件。由于 $\gcd(x,y)\not=1$ 且 $1\le y<x$，说明 $y$ 是 $x$ 的一个因数且 $y\not=1$ 且 $y\not=x$。

接下来，对于第一种查询，考虑贪心：每次寻找当前 $x$ 的最小的因数（$1$ 和 $x$ 除外，这个数记为 $r$），然后 $x\gets \frac{x}{r}$，直到 $x$ 成为质数或 $1$（没有除了 $1$ 和 $x$ 之外的因数了）。

对于第二种查询，因为得出的数要最小，说明每次的最小的因数为 $2$，但是由于 $2$ 是质数，无法进行操作，所以，当 $q=1$ 时答案为 $4$，最终答案为 $2\times 2^{q}$，即为 $2^{q+1}$。

代码：
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define INF 0x3f3f3f
using namespace std;
int t,opt,x,p[3000001];
signed main(){
	cin>>t;
	for(int i=2;i<=1200000;i++)
		p[i]=1;
	for(int i=2;i<=1200000;i++){
		if(p[i]){
			for(int j=2;i*j<=1200000;j++)
				p[i*j]=0;
		}
	}//筛质数
	while(t--){
		cin>>opt>>x;
		if(opt==1){
			int ans=0;
			while(x>1&&(!p[x])){
				for(int i=2;i*i<=x;i++)
					if(!(x%i)){
						ans++;//统计次数
						x/=i;
						break;
					}
			}
			cout<<ans<<"\n";
		}
		else{
			int ans=1;
			for(int i=1;i<=x+1;i++)
				ans*=2;//计算
			cout<<ans<<"\n";
		}
	}
	return 0; 
}
```

---

## 作者：andycode (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11747)
## 思路
显然，每一次操作过后 $x$ 便会变成自己的一个因数，所以不妨将每次操作都看成，将 $x$ 变为一个小于自身且不等于 $1$ 的因数。

由于要求操作次数最大，所以每次操作过后，$x$ 都应该尽量大。所以操作时，我们要将 $x$ 变成其最大的非自身的因数，而这个数正是 $x$ 除以它的最小质因子。所以我们将 $x$ 依次除以自己的质因子，直到 $x$ 为 $1$ 或一个质数（因为这时，$y$ 无论取多少，$\gcd(x,y)$ 都等于 $1$）即可。

举个例子，当 $x=18$ 时，先将其分解质因数，$18=2\times3^2$。我们先将 $18$ 和 $18\div2$ 即 $9$ 进行 $\gcd$ 变成 $9$，再和 $9\div3$ 进行 $\gcd$ 变成 $3$，然后就无法进行操作，最大操作次数为 $2$，容易证明没有更好的方案。

所以当询问类型为一时，答案为 $x$ 所有质因子的指数相加再减一（因为 $x$ 最终可能为它的一个质因子，所以要减一）,但是要特判 $x=1$ 的情况要直接输出 $0$，否则将输出 $-1$，因为 $1$ 没有质因子。

而当询问类型为二时，根据上面的结论，答案的所有质因子的指数相加过后应当等于 $q+1$，又因为要求答案最小，所以答案的质因子只能为 $2$，所以答案为 $2^{q+1}$。需要注意的是，$q$ 最大为 $62$，结果要使用 `unsigned long long` 存储。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,tp,x;
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&tp,&x);
        if(tp==1){
            if(x==1){//特判
                puts("0");
                continue;
            }
            int sum=0;
            for(int i=2;i*i<=x;i++)
                while(x%i==0)
                    sum++,x/=i;
            if(x>1)
                sum++;//统计质因子指数相加的数量
            printf("%d\n",sum-1);
        }else{
            printf("%llu\n",(unsigned long long)1<<x+1);//注意答案的大小会爆long long
        }
    }
    return 0;
}
```

---


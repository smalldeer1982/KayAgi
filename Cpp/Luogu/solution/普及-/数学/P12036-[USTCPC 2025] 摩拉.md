# [USTCPC 2025] 摩拉

## 题目背景

USTCPC 设置 2s 时限为了使得 python 通过。洛谷改为 1s 时限。

## 题目描述

克露丝卡尔酱喜欢 os！（`o` 代表圆，通原，`s` 代表神），里面有一位名叫凝光的角色。

璃月的天权星凝光大人最热衷的就是赚取摩拉。

近日她研究出了一种生财之道。如果她能在第一天赚 $p$ 个摩拉，就能在第二天赚 $p+1$ 个摩拉，并从第三天开始，每天所赚的摩拉是前两天赚的摩拉之和。

现在凝光想知道，按照这种赚钱方法，如果在第 $a$ 天赚到了 $x$ 个摩拉，那么在第 $b$ 天能赚多少摩拉？

## 说明/提示

对于 `3 5 4` 的情况，第一天 $p=2$ ，第二天 $3$，第三天 $5$，第四天 $8$。

对于 `3 4 6` 的情况，不存在使得第三天 $4$ 的情形。

## 样例 #1

### 输入

```
3
1 1 2
3 5 4
3 4 6```

### 输出

```
2
8
-1```

# 题解

## 作者：yingxi (赞：11)

# [题面传送门](https://www.luogu.com.cn/problem/P12036)
### 分析题目
这道题目描述了一个特殊的赚钱序列：
- 第一天赚 $p$ 摩拉
- 第二天赚 $p+1$ 摩拉
- 从第三天开始，每天赚的钱是前两天赚的钱之和

给定第 $a$ 天赚的钱 $x$ ，问第  $b$  天能赚多少钱。如果不存在这样的  $p$ ，使得第  $a$  天赚  $x$  摩拉，则输出  $-1$ 。

### 解题思路
序列生成规则：这个序列类似于斐波那契数列，但是前两项是  $p$  和  $p+1$ 。我们可以预计算所有可能的  $a$  和  $b$  组合对应的关系。

推导：对于第  $n$  天赚的钱，可以表示为关于  $p$  的式子：`f(n) = k[n] * p + c[n]`

- `f(1) = p = 1 * p + 0`
- `f(2) = p + 1 = 1 * p + 1`
- `f(3) = f(1) + f(2) = 2 * p + 1`
- `f(4) = f(2) + f(3) = 3 * p + 2`
- `f(5) = f(3) + f(4) = 5 * p + 3`

可以看出系数  $k$  和  $c$  都遵循斐波那契数列的规律

预处理系数：我们可以预先计算出对于每个  $a$  和  $b$ ，对应的  $k$  和  $c$  系数，这样在处理查询时可以快速计算。

解方程求  $p$ ：对于给定的  $a$  和  $x$ ，我们有方程 `k[a] * p + c[a] = x`。需要解这个方程得到整数  $p$  且在 $1 ≤ p ≤ 10^6$ 范围内。

验证并计算答案：如果找到合法的  $p$ ，就用这个  $p$  计算第  $b$  天的值；否则返回 $ -1$ 。

知道了这些，我们就可以开始敲代码了！
### 代码实现：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
vector<int> k(21), c(21);
signed main() 
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	// 预计算系数 k 和c
	k[1] = 1;
	k[2] = 1;
	c[1] = 0;
	c[2] = 1;
	for (int i = 3; i <= 20; i++)
	{
		k[i] = k[i-1] + k[i-2];
		c[i] = c[i-1] + c[i-2];
	}
	int T;
	cin >> T;
	while (T--)
	{
		int a, b, x;
		cin >> a >> x >> b;
		// 解方程 k[a] * p + c[a] = x
		int num1 = x - c[a];
		int num2 = k[a];
		if (num1 <= 0 || num2 == 0)
		{
			cout << "-1\n";
			continue;
		}
		if (num1 % num2 != 0)
		{
			cout << "-1\n";
			continue;
		}
		int p = num1 / num2;
		if (p < 1 || p > 1000000)
		{
			cout << "-1\n";
			continue;
		}
		// 计算第 b 天的值
		int res = k[b] * p + c[b];
		cout << res << '\n';
	}
	return 0;
}
```
**时间复杂度：**
1. 预处理  $O(20)$ 
1. 每个查询  $O(1)$ ， $T$ 次就是  $O(T)$ 
所以总复杂度  $O(20*T)$ ，省略常数就是  $O(T)$ 

不会超时哒

---

## 作者：kimino_tree (赞：3)

## 思路
这道题主要用到的是斐波那契数列。  
第一天赚 $p$ 个摩拉，第二天赚 $p+1$ 个摩拉，接下来每天所赚的摩拉是前两天赚的摩拉之和，那么第三天就赚到 $2p+1$ 个摩拉，第四天可以赚到 $3p+2$ 个摩拉。以此类推，就可以找到规律。      
## 找规律
可以用列表法寻找规律。

|第一天|第二天|第三天|第四天|第五天|
|:-:|:-:|:-:|:-:|:-:|
|$p$|$p+1$|$2p+1$|$3p+2$|$5p+3$|

|第六天|第七天|第八天|第九天|第十天|
|:-:|:-:|:-:|:-:|:-:|
|$8p+5$|$13p+8$|$21p+13$|$34p+21$|$55p+34$|

若把每一天的钱数看为 $kp+b$ ，则 $b$ 是斐波那契数列中 $k$ 前的一个数。再看数据范围，$a,b≤20$ ,可以枚举斐波那契数列的前 $20$ 个数，然后再解一元一次方程解出 $p$ ，最后把 $b$ 代入天数算出 $ans$ 。

# AC Code
代码中 $kkk[i][1]$ 用于记录第 $i$ 天的 $k$ 值，$kkk[i][1]$ 用于记录第 $i$ 天的 $b$ 值。
```cpp
#include<bits/stdc++.h>
#define kkkzuikeai return 0;//kkk最可爱!
using namespace std;
long long t,a,x,b,k[1314520],kkk[1314][1314],p;
int main(){
    cin>>t;
    memset(k,0,sizeof(k));
    k[1]=1,k[2]=2;
    for(int i=3;i<=100;i++){
        k[i]=k[i-1]+k[i-2];//斐波那契数列
    }
    kkk[1][1]=1,kkk[1][2]=0,kkk[2][1]=1,kkk[2][2]=1;//用于记录 p=0和p=1时的结果
    for(int i=3;i<=50;i++){
        kkk[i][1]=k[i-1],kkk[i][2]=k[i-2];//转换
    }
    while(t--){
        cin>>a>>x>>b;
        if((x-kkk[a][2])%kkk[a][1]==0)p=(x-kkk[a][2])/kkk[a][1];//解一元一次方程
        else{
            cout<<"-1\n";//解出来为小数输出-1
            continue;
        }
        cout<<p*kkk[b][1]+kkk[b][2]<<'\n';//将p代入天数算出答案
    } 
    kkkzuikeai
}
```

---

## 作者：hgckythgcfhk (赞：2)

广告：[USTCPC2025 题解汇总（部分）](https://www.luogu.com.cn/article/xl8dsc9j)。

显然赚到的钱是一个关于 $p$ 的一次多项式，设第 $a$ 天的钱为 $k_a\cdot p+b_a$，则有 $k_a\cdot p+b_a=x$，解得 $p=\dfrac{x-b_a}{k_a}$ ，由于所有数都是整数，所以无解当且仅当这里不整除，这两个系数可以维护一个两个元素的结构体递推出来，事实上这就是斐波那契数列。

以下是线下选手 $42$ 队提供的赛时代码，非常感谢 $42$ 队。

```cpp
#include <bits/stdc++.h>
#define il inline
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("C.in","r",stdin),freopen("C.out","w",stdout)
#define int rg unsigned
#define void il void
#define ll long long
#define ull unsigned ll
#define lll __int128
#define db double
#define vector basic_string
#define pq priority_queue
#define vint vector<unsigned>
#define vll vector<ll>
#define vull vector<ull>
#define ump unordered_map
#define ust unordered_set
#define deq deque
#define mkp make_pair
#define pii pair<unsigned,unsigned>
#define pll pair<ull,ull>
#define fi first
#define se second
#define Bool(a,n) bitset<n>a
#define sca(a) for(int $=0;$<n;cin>>a[++$])
#define cle(a) memset(a,0,sizeof a)
#define tmx(a) memset(a,0x3f,sizeof a)
#define tmn(a) memset(a,0xbf,sizeof a)
#define tif(a) memset(a,0xff,sizeof a)
//#define ge getchar_unlocked()
#define pu putchar_unlocked
#define lik(x) __builtin_expect((x),1)
#define ulk(x) __builtin_expect((x),0)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
//#define abs(a,b) (a>b?a-b:b-a)
#define fls cout<<endl;
#define PP pop_back()
#define PS push
#define BK back()
#define SZ size()
//inline ll max(const rg ll a,const rg ll b){return a>b?a:b;}
//inline ll min(const rg ll a,const rg ll b){return a<b?a:b;}
inline ll abs(const rg ll a,const rg ll b){return a>b?a-b:b-a;}
using namespace std;constexpr unsigned N=1<<17,M=4e3+2;//constexpr ll inf=1e9+7;
//unsigned p;
constexpr unsigned p=998244353;
//constexpr unsigned p=1e9+7;
//自动取模类
/**/
namespace mod{
	void add(int&a,cit b){a+=b,a>=p?a-=p:0;}
	void sub(int&a,cit b){add(a,p-b);}
	il unsigned mul(cit ll a,cit ll b){return a*b%p;}
	il unsigned pw(int ll a,int b){int ll s=1;for(;b;b>>=1,a=a*a%p)b&1?s=s*a%p:0;return s;}
	il unsigned inv(cit a){return pw(a,p-2);}
	void div(int&a,cit b){a=mul(a,inv(b));}
	il unsigned div(cit a,cit b){return mul(a,inv(b));}
}
using mod::add;
using mod::sub;
using mod::mul;
using mod::inv;
using mod::pw;
/**/
/**/
namespace IO{unsigned char b[1<<22],*l=b,*r=b;
	#define ge (ulk(l==r)?r=(l=b)+fread(b,1,1<<22,stdin):0,ulk(l==r)?'\0':*l++)
	il unsigned rd(){int char c=ge;int s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;return s;}
	void rd(int&s){int char c=ge;s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;}
}using IO::rd;
struct A{ull a,b;il A operator+(A c){c.a+=a,c.b+=b;return c;};il A(){a=0,b=0;}il A(cit ll x,cit ll y){a=x,b=y;}}_[22];
unsigned a,b;ull x;
void init(){cin>>a>>x>>b;
    
    
}void solve(){init();if(_[a].b>x){cout<<"-1\n";return;}
    x-=_[a].b;if(x%_[a].a){cout<<"-1\n";return;}
    x/=_[a].a;cout<<1ll*x*_[b].a+_[b].b<<'\n';
}signed main(){open;int t=1;cin>>t;_[1]=A(1,0),_[2]=A(1,1);
    for(int i=3;i<=20;++i)_[i]=_[i-1]+_[i-2];
	while(t--)solve();}
```

删除了引用的被注释掉的 `hgckythgcfhk.h` 的内容，保证这部分全是注释。

---

## 作者：easy42 (赞：1)

观察发现，每天赚的钱都可以分为一个未知项和一个常数项来表示。

不妨把它表示为 $y=kx+t$，其中：

- $day_1=px$
- $day_2=px+1$

往下递推即可。

若可以在第 $a$ 天赚到 $x$ 个摩拉，则有

$$
day_a=day_{a_k} \times p + day_{a_t}=x
$$

解方程得到：

$$
p=\frac{x-day_{a_t}}{day_{a_k}}
$$

检验即可。

第 $b$ 天赚的摩拉为：

$$
day_{b_k} \times p + day_{b_t}
$$

此时将 $p$ 带入即可。

注意需要高精度。

```python
tt = int(input())
t = [{'n': 0, 'm': 0} for _ in range(300)]
t[1]['n'] = 1
t[2]['n'] = 1
t[2]['m'] = 1

for i in range(3, 201):
    t[i]['n'] = t[i - 1]['n'] + t[i - 2]['n']
    t[i]['m'] = t[i - 1]['m'] + t[i - 2]['m']

for _ in range(tt):
    a, x, b = map(int, input().split())
    k = (x - t[a]['m']) // t[a]['n']
    if not (1 <= k <= 1000000 and (x - t[a]['m']) % t[a]['n'] == 0):
        print(-1)
    else:
        print(t[b]['n'] * k + t[b]['m'])
```

---

## 作者：封禁用户 (赞：1)

# 思路

假设克露丝卡尔酱第一天能赚 $p$ 个摩拉，那她第二天就能赚 $p+1$ 个摩拉，第三天能赚 $2p+1$ 个摩拉，以此类推。

可以发现每天赚取的摩拉数量可以表示成 $ap+b$ 的形式，且 $a$ 和 $b$ 都是整数。

克露丝卡尔酱在第 $a$ 天赚了 $x$ 个摩拉，可以得到方程。

$$
ap+b=x
$$

可以求出 $p$。

$$
p=\frac{x}{a}-b
$$

$a$ 和 $b$ 是可以用递推求出来的！

求出来之后再代入公式求答案。

## 可如何判断无解？

很简单，只需要判断 $\frac{x}{a}$ 是否是整数就行了。

# code!

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[21],p[21];//不开long long见祖宗
int main(){
    f[1]=1;p[1]=0;//递归的初始量
    f[2]=1;p[2]=1;//f数组是a,p数组就是b
    for (int i=3;i<=20;i++) {//递推
        f[i]=f[i-1]+f[i-2];
        p[i]=p[i-1]+p[i-2];
    }
    int t;
    cin >> t;
    while(t--){
        int a,b;
        long long x;
        cin >> a >> x >> b;
        bool valid=true;
        long long w=0;
        if(a==1){//两种情况要特判！！！
            w=x;
        }else if(a==2){
            w=x-1;
        }else {
            if(x<p[a]||(x-p[a])%f[a]!=0) {//无解
                valid=false;
            }else{
                w=(x-p[a])/f[a];//求ap+b里面的p
            }
        }
        if(valid){
            cout << f[b]*w+p[b] << endl;//答案
        }else{
            cout << -1 << endl;
        }
    }
    return 0;
}
```

---

## 作者：LG086 (赞：0)

有 $f_{i(3\le i)}  = f_{i-1}+f_{i-2}$，设 $f_1=p,f_2=p+1$，已知 $f_a = x$，求 $f_b$。

进行递推，得到 $f_1=p,f_2=p+1,f_3=2p+1,f_4=3p+2,f_5=5p+3,f_6=8p+5\dots$。

发现 $f_i$ 中 $p$ 的系数以及 $f_i$ 的常数项很有规律，于是联系到斐波那契数列 $1,1,2,3,5,8\dots$。发现 $f_i$ 中 $p$ 的系数即为斐波那契数列中第 $i$ 个数字。而 $f_{i(2\le i)}$ 的常数项的值即为斐波那契数列中第 $i-1$ 个数字。

记 $fib_i$ 为斐波那契数列第 $i$ 个数字的值。


因为 $fib_a \cdot p + fib_{a-1} = x$，所以 $p = \dfrac{x-fib_{a-1}}{fib_a}$。因为 $p$ 是整数，所以先判断 $\dfrac{x-fib_{a-1}}{fib_a}$ 是否是整数，如果是，求出 $p$ 的值，则 $f_b = fib_b \cdot p + fib_{b-1}$。


做完了。

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P12036)

## 题目分析：
这道题其实很考验思维能力，那废话不多说，开始分析！

这道题一看就要用斐波那契数列，设第 $n$ 天的赚取摩拉为 $f(n, p)$，那么就有：
$$f(1,p)=p$$
$$f(2,p)=p+1$$
$$f(n,p)=f(n-1,p)+f(n-2,p)$$
我们要计算 $$f(b,p)$$。

那就开始暴力枚举！
$$f(1,p)=p$$
$$f(2,p)=p+1$$
$$f(3,p)=f(2,p)+f(1,p)=2p+1$$
$$f(4,p)=f(3,p)+f(2,p)=3p+2$$
$$f(5,p)=f(4,p)+f(3,p)=5p+3$$
那么发现 $f(n,p)=a(n) \times p+b(n)$，其中 $a(n)$ 和 $b(n)$ 是依赖于 $n$ 的系数。不难发现，$$a(n)$$ 和 $$b(n)$$ 也遵循斐波那契递推关系。这边定义 $F(n)$ 为斐波那契数组，则有：
$$f(n,p)=F(n) \times p+F(n-1)$$

## 求解方程：
综上所述，这边定义 $$f(a,p)=x$$，则有：
$$p=(x-F(a-1)) \div F(a)$$
则 $p$ 存在的条件有： 
1. $(x - F(a-1))$ 能被 $F(a)$ 整除。
2. $(x - F(a-1)) \div F(a)$ 是一个正整数。

如果有一条不符合，那就输出 $-1$。

## 计算答案：
我们要算的是 $f(b,p)$。则：

$$f(b,p)=F(b) \times p+F(b-1)$$
所以我们还要先处理一下斐波那契数组。

最后就可以输出答案了！

## 正解：
上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,a,x,b;
vector<int> f(25);
void init(){
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=20;i++) f[i]=f[i-1]+f[i-2];
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	init();
	while(t--){
		cin>>a>>x>>b;
		int c=f[a],d=f[a-1];
		int num=x-d;
		if(num<=0||num%c!=0){
			cout<<"-1\n";
			continue;
		}
		int p=num/c;
		if(p<1||p>1000000){
			cout<<"-1\n";
			continue;
		}
		int e=f[b],k=f[b-1];
		int ans=e*p+k;
		cout<<ans<<"\n";
	}
	return 0;
}
```
这道题我花了一个上午，给个赞吧！

---

## 作者：dsj2012 (赞：0)

根据题目的规律我们可以发现，与斐波那契数列十分相似。但是初始值是不定的，那么我们手推一下规律。假设第一天的值是 $p$。

$1p,1p+1,2p+1,3p+2,5p+3,8p+5$。

那么我们要怎么求 $p$ 的值呢？我们观察把加号去掉后的 $p$ 是几倍呢？$1,1,2,3,5,8$ 很容易发现系数就是斐波那契数列。

然后加法也是斐波那契数列，只不过初始值是 $0,1$ 的斐波那契数列。那么我们可以直接统计一下每一次的斐波那契数列就可以了。
## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp1[105],dp2[105];
int T;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	dp1[1] = 1;
	dp1[2] = 1;
	dp2[2] = 1;
	for(int i = 3 ; i <= 20 ; i ++){
		dp1[i] = dp1[i - 1] + dp1[i - 2];
		dp2[i] = dp2[i - 1] + dp2[i - 2];
	}
	cin >> T;
	while(T --){
		int a,x,b;
		cin >> a >> x >> b;
		if((x - dp2[a]) % dp1[a] != 0){
			cout << -1 << "\n";
			continue;
		}
		int p = (x - dp2[a]) / dp1[a];
		cout << p * dp1[b] + dp2[b] << "\n";
	}
	return 0;
}
```

---

## 作者：star_field (赞：0)

### 题目大意

~~原神启动~~

凝光第一天能赚 $p$ 摩拉，第二天赚 $p+1$ 摩拉，之后每天赚的钱是前两天之和，现在给出 $a,x,b$ , 问第 $a$ 天赚 $x$ 摩拉的凝光第 $b$ 天能赚多少钱。

### 解题思路

看到“每天所赚的摩拉是前两天赚的摩拉之和”，考虑斐波那契数列。因为 $a,b\le 20$，直接打表。然后我们可以列式（$m_i$ 表示第 $i$ 天赚的摩拉数）：

$m_1=p,m_2=p+1,m_3=2p+1,m_4=3p+2,m_5=5p+3\dots$

注意到 $m_i=F_{i+1}\cdot p+F_i$（$F$ 为斐波那契数列，$(0,1)$ 开头）

那太好了，我们直接上代码

### code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T,a,b,p,x,f[21]={0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765}; //为防止取余时溢出，全开long long
int main(){
	cin>>T;
	while(T--){
		cin>>a>>x>>b;
		if((x-f[a-1])%f[a]!=0) cout<<-1<<endl; 
		else{
			p=(x-f[a-1])/f[a]; //套用推出的公式
			cout<<p*f[b]+f[b-1]<<endl;
		}
	}
	return 0;
}
```

切记取余运算可能会爆 `int`

[惨痛的教训](https://www.luogu.com.cn/record/212099447)

---

## 作者：qwer6 (赞：0)

## 0.废话

这不是水题吗？怎么没人写题解？  

## 1.Description  

对于一个整数 $p$，定义一个对应的数列 $c$ 满足 $c_i=\begin{cases}p\ (i=1)\\p+1\ (i=2)\\c_{i-1}+c_{i-2} (i\ge 3)\end{cases}$。  
现在给定 $a,x,b$，表示已知 $c_a=x$，求 $c_b$，若是不存在一个 $p$ 满足条件，那么输出 $-1$。

## 2.Solution  

显然对于不同的 $p$，数列 $c$ 都不同，但是有两个序列是不随 $p$ 变化，我们定义 $f_i$，$g_i$ 满足 $c_i=f_i\times p+g_i$，那么 $f$ 和 $g$ 的递推式显然：  
$f_i=\begin{cases}1\ (1\le i\le 2)\\ f_{i}+f{i-1}\ (i\ge 2)\end{cases},g_i=\begin{cases}0\ (i=1)\\1\ (i=2)\\ g_{i}+g{i-1}\ (i\ge 2)\end{cases}$。  
可以直接预处理出来前 $20$ 项对应的 $f_i$ 和 $g_i$。  
那么其实就是 $p$ 的求解就是一个解方程的问题了，也就是 $f_a\times p+g_a=x$，所以 $p=\frac{x-g_a}{f_a}$，如果 $p$ 是一个整数，那么说明有解，答案为 $f_b\times p+g_b$，否则说明无解，输出 $-1$ 即可。

## 3. Code  

其实代码十分短。

```c++
/*by qwer6*/
/*略去缺省源和快读快写*/
int a,b,x,p;
int f[25],g[25];
signed main(){
	f[1]=1,g[1]=0;
	f[2]=1,g[2]=1;
	for(int i=3;i<=20;i++){
		f[i]=f[i-1]+f[i-2];
		g[i]=g[i-1]+g[i-2];
	}
	int t;
	read(t);
	while(t--){
		read(a),read(x),read(b);
		p=(x-g[a])/f[a];
		if(p*f[a]+g[a]!=x){
			puts("-1");
			continue;
		}
		write(p*f[b]+g[b]),Nxt;
	}
}
```

---

## 作者：canwen (赞：0)

注意到 $a,b\le 20$，第 $i$ 天赚到的摩拉个数都可以被表示成 $k_i = f_ip+ff_i(f_i\ge 1, ff_i \ge 0)$，预处理 $y_i,k_i$ 出来。

然后若 $(x-ff_a) \bmod f_a = 0$，就可以得出 $p = \frac{x-ff_a}{f_a}$，从而算出 $k_b = f_bp+ff_b$，否则由于 $p$ 保证是整数，无解，输出 $-1$。

[通过记录](https://www.luogu.com.cn/record/212080460)。

---

## 作者：yhylivedream (赞：0)

奇怪的做法。

考虑先确定 $p$ 再计算第 $b$ 天花的钱。

首先枚举确定肯定是不行的，发现随着 $p$ 的增长第 $a$ 天赚的钱单调递增，考虑二分即可。

注意 `long long`。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int T, a, x, b, f[25];

signed main() {
  for (cin >> T; T--;) {
    cin >> a >> x >> b;
    int l = 0, r = 1e6 + 1;
    for (; l + 1 < r;) {
      int mid = (l + r) / 2;
      f[1] = mid, f[2] = mid + 1;
      for (int i = 3; i <= a; i++) {
        f[i] = f[i - 1] + f[i - 2];
      }
      f[a] >= x ? r = mid : l = mid;
    }
    f[1] = r, f[2] = r + 1;
    for (int i = 3; i <= max(a, b); i++) {
      f[i] = f[i - 1] + f[i - 2];
    }
    cout << (f[a] == x ? f[b] : -1) << '\n';
  }
}
```

---


# [KOI 2024 Round 2] 寻宝游戏

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

你正与朋友小彬在如下图所示的无限长数轴上玩寻宝游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/2l3vf80d.png)

首先，你会将两件宝物藏在数轴上两个不同的位置 $L$ 和 $R$ 上（满足 $L < R$）。下图为将宝物藏在 $L = -2$ 和 $R = 3$ 的一个例子。用橙色标示的两个格子中藏有宝物。

![](https://cdn.luogu.com.cn/upload/image_hosting/m8lyeu2d.png)

你藏好宝物后，小彬便开始找宝物。她将从你指定的起始位置 $S$ 出发，按照以下顺序进行：

- 第一步：检查当前位置 $S$；
- 第二步：向右移动 $1$ 格，检查位置 $S + 1$；
- 第三步：向左移动 $2$ 格，检查位置 $S + 1 - 2$；
- 第四步：向右移动 $3$ 格，检查位置 $S + 1 - 2 + 3$；
- 第五步：向左移动 $4$ 格，检查位置 $S + 1 - 2 + 3 - 4$；
- 第六步：向右移动 $5$ 格，检查位置 $S + 1 - 2 + 3 - 4 + 5$；
- …

也就是说，第 $x$ 步时，如果 $x$ 是偶数，小彬会向右移动 $x - 1$ 格；如果 $x$ 是奇数，小彬会向左移动 $x - 1$ 格，然后检查所到达的位置。

如果某一步检查的位置上有宝物，游戏就结束。

例如，在 $L = -2$、$R = 3$、$S = 0$ 的情形下，小彬会在第 $5$ 步检查位置 $-2$，那里藏有宝物，因此游戏会在第 $5$ 步结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/qcbtzy39.png)

## 说明/提示

**样例 1 说明**

- 第一个例子如题面图所示，小彬第 $5$ 步找到了位置 $-2$ 的宝物。
- 第二个例子中，小彬从 $6$ 出发：
  - 第 1 步：$6$
  - 第 2 步：$7$
  - 第 3 步：$5$
  - 第 4 步：$8$ ← 找到宝物，游戏结束。
  
**约束条件**
- 所有输入为整数。
- $1 \leq T \leq 10\,000$
- $-100\,000\,000 \leq L < S < R \leq 100\,000\,000$


**子问题**
1. （8 分）$T = 1,\ R = 1,\ S = 0$  
2. （9 分）$T = 1,\ L = -1,\ S = 0$  
3. （15 分）$-1\,000 \leq L \leq -1,\ 1 \leq R \leq 1\,000,\ S = 0$  
4. （16 分）$-1\,000 \leq L < S < R \leq 1\,000$  
5. （52 分）无额外限制条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2
-2 3 0
4 8 6```

### 输出

```
5
4```

## 样例 #2

### 输入

```
9
-1 1 0
-2 1 0
-3 1 0
-1 2 0
-2 2 0
-3 2 0
-1 3 0
-2 3 0
-3 3 0```

### 输出

```
2
2
2
3
4
4
3
5
6```

# 题解

## 作者：Clare613 (赞：3)

~~吸取教训，现在就抢。~~
## 思路：
此题不难，主要是理解题目在说什么。不难发现，第一次操作后在原点加 $1$ 处，第二次操作后在原点减 $1$ 处，第三次操作后在原点加 $2$ 处，第四次操作后在原点减 $2$ 处。那么只需要算出原点经过几次操作就可以到达 $L$ 或 $R$ 这两个点之一，两者的式子通过上述规律可得：点 $L$ 的为 $\operatorname{abs}(L-S)\times2+1$。点 $R$ 的为 $\operatorname{abs}(R-S)\times2-1+1$。注意，$\operatorname{abs}()$ 为绝对值运算。有人问为什么要加 $1$，其实就是因为最开始也算一次。取最小值就 A 了。
## code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	int T;
	cin>>T;
	while(T--){
		int l,r,s;
		cin>>l>>r>>s;
		int q=abs(l-s);
		int w=abs(r-s);
		cout<<min(q*2,w*2-1)+1<<"\n";
	}
	return 0;
}
```
顺手拿了[最优解](https://www.luogu.com.cn/record/218866881)。

---

## 作者：zhunxin666 (赞：2)

思路：分类讨论。
看看两个宝藏的位置谁离着起点最近，
若左端点的宝藏距离起点的距离小于右端点的宝藏距离起点，那么无脑选左。若左端点的宝藏距离起点的距离大于等于右端点的宝藏距离起点，那么无脑选右。（等于也选右是因为每次是先向右边走）。
### AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,l,r,s;
void solve(){
	cin>>l>>r>>s;
	if(abs(s-l)>=abs(s-r)){
		cout<<abs(s-r)*2<<endl;
	}else if(abs(s-l)<abs(s-r)){
		cout<<abs(s-l)*2+1<<endl;
	}
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--) solve();
	return 0;
}

```

---

## 作者：0Io_oI0 (赞：2)

没有人写题解吗？来一篇吧！

分析一下题目移动的规律可以知道，第 $x$ 步分两种情况：

1. 若 $x$ 为偶数，则向右移动 $x-1$ 步。
2. 若 $x$ 为奇数，则向左移动 $x-1$ 步。

所以，当步数 $x$ 为奇数时，位置为：$S-\frac{x-1}{2}$。否则，位置为：$S-\frac{x}{2}$。

所以，宝物 $L$ 位于 $S$ 的左侧，只能在奇数步被遇到，宝物 $R$ 位于 $S$ 的右侧，只能在偶数步被遇到。所以，我们只需要分别计算遇到 $L$ 和 $R$ 的最小步数，然后取两者中的最小值。

由于 $S-\frac{x-1}{2}=L$ 所以 $x=(S-L)\times2+1$，且 $S-\frac{x}{2}=R$ 所以 $x=(R-S)\times2$。

上代码！

```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
#define int long long
#define double long double
#define R register
I AK IOI;
int t;
i_will ak IMO{
    cin>>t;
    while(t--){
        int l,r,s;
        cin>>l>>r>>s;
        cout<<min(2*(s-l)+1,2*(r-s))<<'\n';
    }
    i_ak ioi;
}
```

---

## 作者：kuaiCreator (赞：2)

## 解题思路
考虑 $L\lt S\lt R$ 因此起点必然在两个点中间。观察规律可以转化为两个人分别从起点往左和往右轮流各走一步，判断两个小人的其中一个走到目标点的最少步数和。由于向右的小人先走，故如果起点到右目标点的距离等于左目标点距离时，右边先到。直接计算即可。效率为 $O(T)$。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int T, l, r, s;
	cin >> T;
	while (T--) {
		cin >> l >> r >> s;
		int dl = abs(s - l), dr = abs(r - s);
		if (dr <= dl) {
			cout << (dr * 2) << endl;
		} else {
			cout << (dl * 2) +1 << endl;
		}
	}
	return 0;
}
```

---

## 作者：ZSYhaouuan (赞：2)

很简单的一道模拟题。找他目前位置到左边的需要次数，和目前位置到右边宝藏的需要次数，再取一个最小值输出即可，关键是要找出步数和需要次数之间的关系即可。

具体看代码解析：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t;
int main() {
	cin >> t;
	while (t--) {
		ll l, r, s;
		cin >> l >> r >> s;
		//x1 : 到左边宝藏的距离
		//x2 : 到右边宝藏的距离
		ll x1 = s - l, x2 = r - s;
		//k1 : 到左边宝藏的需要次数
		//k2 : 到右边宝藏的需要次数
		ll k1 = x1 * 2 + 1, k2 = x2 * 2;
		cout << min(k1, k2) << "\n";//输出最小值
	}
	return 0;
}
```

---

## 作者：swate114514 (赞：1)

## Part 1：错解
> 我会暴力！

直接按题意模拟即可，时间复杂度玄学。

这样就拿到了 48 的高分。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
	int t;
	scanf("%d", &t);
	
	while (t--) {
		int l, r, s;
		scanf("%d %d %d", &l, &r, &s);
		
		int p = 0;
		int cnt = s;
		while (cnt != l && cnt != r) {
			p++;
			if (p & 1) cnt += p;
			else cnt -= p;
		}
		
		cout << p + 1 << '\n';
	}
}
```

## Part 2：正解
> 我会数学！

可以观察到，第 $x$ 步检查的位置可以这么表示：

- 如果 $x$ 是奇数，则位置为 $S - \frac{x - 1}{2}$。

- 如果 $x$ 是偶数，则位置为 $S + \frac{x}{2}$。

我们需要找到一个步数 $x$，使得第 $x$ 步检查的位置等于 $L$ 或 $R$。

对于奇数 $x$：
$$S - \frac{x - 1}{2} = L$$
或 
$$S - \frac{x - 1}{2} = R$$
解这个方程：
$$\frac{x - 1}{2} = S - L \quad \Rightarrow \quad x = 2(S - L) + 1$$
或
$$\frac{x - 1}{2} = S - R \quad \Rightarrow \quad x = 2(S - R) + 1$$
因为 $x$ 必须是正整数，且 $S - R$ 通常为负数（因为 $S < R$），所以只有 $x = 2(S - L) + 1$ 可能有效。

对于偶数 $x$：
$$S + \frac{x}{2} = L$$
或
$$S + \frac{x}{2} = R$$
解这个方程：
$$\frac{x}{2} = L - S \quad \Rightarrow \quad x = 2(L - S)$$
或
$$\frac{x}{2} = R - S \quad \Rightarrow \quad x = 2(R - S)$$
因为 $L < S < R$，所以 $L - S$ 为负数，$R - S$ 为正数。因此只有 $x = 2(R - S)$ 可能有效。

所以，对于给定的 $L$，$R$，$S$，计算以下可能的 $x$：
- 奇数 $x$：$x = 2(S - L) + 1$（如果 $S - L \geq 0$）。

-  偶数 $x$：$x = 2(R - S)$。

检查这些 $x$ 是否满足第 $x$ 步的位置确实是 $L$ 或 $R$。

取所有满足条件的 $x$ 中的最小值作为答案。

Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int solve(int L, int R, int S) {
	int ans = INT_MAX;
	
	int odd_L = 2 * (S - L) + 1;
	if (odd_L > 0 && (odd_L & 1)) {
		int pos = S - (odd_L - 1) / 2;
		if (pos == L) {
			ans = min(ans, odd_L);
		}
	}
	
	int even_R = 2 * (R - S);
	if (even_R > 0 && !(even_R & 1)) {
		int pos = S + even_R / 2;
		if (pos == R) {
			ans = min(ans, even_R);
		}
	}
	
	return ans;
}

int main() {
	
	int T;
	scanf("%d", &T);
	
	while (T--) {
		int L, R, S;
		scanf("%d %d %d", &L, &R, &S);
		
		int ans = solve(L, R, S);
		printf("%d\n", ans);
	}
	
	return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：1)

> 呜呼！哀哉！吾长求咕值不减，缺见其已损大半也！

## 思路

很明显是一道计算题。

抽象一下，就是求 $S+1-2+3-4+\cdots$ 的和。首先 $L$ 一定在 $S$ 的左边，$R$ 一定在 $S$ 的右边，若我们想走到 $L$，则我们需要：$S+(1-2)+(3-4)+\cdots$，也就是说**每往左走一步，我们需要捣腾 $2$ 步**，同理不难发现，**每往右走一步，我们需要比上一次往左走多捣腾 $1$ 步**。

于是得到，若 $L$ 离 $S$ 近，需要操作 $2(S-L)$ 次，反之，操作 $2(R-S)-1$ 次（不清楚手动模拟一下）。别忘了这是次数，最后结果要加一，这是搜查结点数。

数据范围很大，所以要开 ~~int~~ long long。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    int l,r,s;
    int left=0;
    int right=0;
    while(t--){
        left=0,right=0;
        cin>>l>>r>>s;
        left=s-l;
        right=r-s;
        left*=2,right=right*2-1;
        cout<<min(left,right)+1<<endl;
    }
    return 0;
}
```

---

## 作者：lcycl (赞：0)

# 思路
题目中的移动是左右交替的，可以将两次移动合并，看作每两步都在原来移动的位置的基础上向左一格、向右一格（先向右，再向左）。即点 $i$ 到点 $l$，$r$ 的移动步数分别是 $(i-l)\times2$ 和 $(r-i)\times2-1$。因为在一开始还要花一步检查当前位置，所以输出 $(i-l)\times2$ 和 $(r-i)\times2-1$ 中的最小值再加 $1$ 就好了。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e8+1;
int T;
int l,r,s;
signed main(){
	cin>>T;
    while(T--){
        cin>>l>>r>>s;
        cout<<min((s-l)*2,(r-s)*2-1)+1<<"\n";
    }
	return 0;
}
```

---


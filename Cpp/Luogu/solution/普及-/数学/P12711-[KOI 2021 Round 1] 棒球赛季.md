# [KOI 2021 Round 1] 棒球赛季

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 棒球联赛有 $N$ 个地区联赛，每个地区联赛有 $M$ 支队伍，因此整个联赛由 $N \times M$ 支队伍构成。

在一个赛季中，每支队伍不仅需要与同一地区联赛的其他队伍进行比赛，还需要与其他地区联赛的队伍进行比赛。与同一地区联赛队伍之间的每队比赛次数记作 $A$，对所有地区联赛都相同。也就是说，某支队伍 $X$ 会与同一地区联赛中的每支其他队伍 $Y$（$X \ne Y$）各进行 $A$ 场比赛。  
此外，与其他地区联赛队伍之间的每队比赛次数记作 $B$，也对所有队伍都相同。也就是说，队伍 $X$ 会与所有来自其他地区联赛的队伍 $Z$（$X \ne Z$）各进行 $B$ 场比赛。  
但 $A$ 与 $B$ 之间需满足关系：$A = k \times B$，其中 $k$ 是大于等于 1 的整数。

受全球性流行病影响，今年的 KOI 棒球联赛决定缩短赛季，只要总比赛场数不超过 $D$，并尽可能接近 $D$ 即可。因此，需要重新决定 $A$ 与 $B$ 的值，但仍需满足 $A = k \times B$，且 $k$ 不变。此外，每支队伍与其他任何一支队伍至少要有一场比赛，也就是说需满足 $A \geq 1$ 且 $B \geq 1$。

例如，当 $N = 2$，$M = 3$，$k = 3$，最大比赛场数限制 $D = 60$ 时，若设 $A = 6$，$B = 2$，则与其他地区队伍的总比赛场数为 18，与同一地区队伍的总比赛场数为 36，整个联赛的比赛总场数为 54，这就是不超过 $D$ 且最接近 $D$ 的方案。

现在，给定地区联赛数量 $N$，每个地区联赛的队伍数量 $M$，乘积因子 $k$（满足 $A = k \times B$），以及最大比赛数限制 $D$，请编写程序计算出不超过 $D$ 的最大联赛总比赛场数。

## 说明/提示

**约束条件**

- 所有给定数据均为整数
- 每组输入数据中，测试用例数量在 1 到 1000 之间
- $2 \leq N, M \leq 100$
- $1 \leq k \leq 100$
- $1 \leq D \leq 1\,000\,000\,000$

**子任务**

1.（5 分）$N = 2$  
2.（5 分）$M = 2$  
3.（5 分）$k = 1$  
4.（85 分）无附加约束条件

## 样例 #1

### 输入

```
3
2 3 3 60
2 2 1 18
2 2 1 4```

### 输出

```
54
18
-1```

# 题解

## 作者：liuyuantao (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12711)  
对于区内赛，每支队伍与区内的 $M-1$ 队比 $A=kB$ 场，共有 $M$ 支队伍，$N$ 个区域，故总共比了 $\frac{kBNM(M-1)}{2}$ 场（去重）。  
对于区外赛，每支队伍与区外的 $(N-1)M$ 队比 $B$ 场，共有 $NM$ 支球队，总共比了 $\frac{BN(N-1)M^2}{2}$ 场。  
故总场数为 $\frac{kBNM(M-1)}{2}+\frac{BN(N-1)M^2}{2}=\frac{BNM[k(M-1)+(N-1)M]}{2} \le D$，解得 $B \le \frac{2D}{NM[k(M-1)+(N-1)M]}$，故 $B=⌊\frac{2D}{NM[k(M-1)+(N-1)M]}⌋$。  
之后代回计算即可。  
复杂度显然是 $O(T)$ 的。

[AC code](https://www.luogu.com.cn/record/219829371)  

```cpp
#include <bits/stdc++.h>

using namespace std;

#define LL long long

LL n,m,k,T,q,cnt,ans,sum;

int main(){
	ios::sync_with_stdio(0);
	cin>>T;
	while(T--){
		cin>>n>>m>>k>>q;
		sum=m*k*(m-1);
		cnt=m*n*(n-1);
		ans=floor(1.0*2*q/(cnt+sum));
		cout<<(ans*sum+ans*cnt)/2<<endl;
	}
	
	return 0;
}
```

---

## 作者：cute_zczc_qwq (赞：1)

# [P12711](https://www.luogu.com.cn/problem/P12711) [KOI 2021 Round 1] 棒球赛季

## 题意
共有 $N$ 个地区，$M$ 个队伍，在同一地区的任意两支队伍进行 $A$ 场比赛，不在同一地区的任意两支队伍进行 $B$ 场比赛，且满足 $A = k \times B$，求不超过 $D$ 的最大总比赛次数。

### 思路
相同地区总共会进行 $N \times C^{2}_{M} \times A$，即 $N \times \displaystyle \frac {M \times (M-1)} {2} \times k \times B$ 次，因为共有 $N$ 个地区，同一地区中任意选两个队伍总共有 $C^{2}_{M}$ 种，每两队要进行 $k \times B$ 次比赛。

不同地区总共会进行 $(A^{2}_{N \times M} - C^{2}_{M}) \times B$，即 $[(N \times M) \times (N \times M -1) - \displaystyle \frac {M \times (M-1)} {2}] \times B$ 次比赛，从所有队伍中任意选两个队伍总共有 $A^{2}_{N}$，去掉同一地区的情况后剩下的就是不同地区的情况，不同地区的任意两支队伍要进行 $B$ 场比赛。

两种相加就是总共进行的比赛数了。

而取最大值就是求最大的 $B$，不难想到最大情况下 $B = \left \lfloor \displaystyle \frac {D} {N \times C^{2}_{M} \times k + A^{2}_{N \times M} - C^{2}_{M}} \right \rfloor$。

所以最终结果就是：
$$
\left \lfloor \displaystyle \frac {D} {N \times C^{2}_{M} \times k + A^{2}_{N \times M} - C^{2}_{M}} \right \rfloor \times (N \times C^{2}_{M} \times k + A^{2}_{N \times M} - C^{2}_{M})
$$
注意如果所得的结果等于 $0$ 要输出 $-1$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long t,n,m,k,d,s;
    cin>>t;
    while(t--){
        cin>>n>>m>>k>>d;
        s = ((n*m)*(n*m-1)/2)-(n*m*(m-1)/2)+(n*m*(m-1)*k/2);
        if(d/s*s == 0){    //整数相除默认向下取整。
        	cout<<-1<<endl;
		}
		else{
			cout<<d/s*s<<endl;
		}
    }
    return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：1)

## 思路

我们知道一个地区有 $M$ 个队伍，每个队伍与**同一地区**的队伍赛 $M\times(M-1)\times A$。这样计算会多算一次，所以要除二；我们还有 $N$ 个区域，所以答案为 $\dfrac{N\times M\times(M-1)\times A}{2}$。

同理，在**不同地区**，需要在同一地区的基础上加上 $N-1$ 个区域和 $M$ 个队伍的场数，即 $\dfrac{N\times M\times(N-1)\times M\times B}{2}$。

总和即为 $\dfrac{N\times M\times(M-1)\times A+N\times M\times(N-1)\times M\times B}{2}$。

记这个和为 $C$，我们要求 $C\le D$。

记得开 **long long**。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int n,int m,int k,int d){
    long long cnt = (long long)n * m * (k * (m - 1) + m * (n - 1));
    long long c=cnt/2;
    long long ans=d/c;
    if(ans<1)return -1;
    return ans*c;
}
int main(){
    int t;
    cin>>t;
    while(t--){
        int n,m,k,d;
        cin>>n>>m>>k>>d;
        int ans=f(n,m,k,d);
        cout<<ans<<"\n";
    }


    return 0;
}
```

---


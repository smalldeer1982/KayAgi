# [蓝桥杯 2025 国 Python A] 特殊整数对的数量

## 题目描述

我们称一对正整数 $(a, b)$ 是 “特别互素对”，如果满足以下条件：

1. $1 \leq a < b \leq 10^6$ 。
2. $a$ 与 $b$ 互素，即 $a$ 和 $b$ 的最大公约数为 $1$ 。
3. $a + b$ 是 $2025$ 的倍数。

请计算一共有多少对 $(a, b)$ 是 “特别互素对”。

# 题解

## 作者：Sunrise_up (赞：3)

一道需要优化的暴力题。

~~我们可以发现这题数学解法不可行。~~

首先我们可以打个暴力，是平方级的，根本算不完。当然你有时间的话可以试试。

我们观察到 $a+b$ 要是 $2025$ 的倍数，所以我们可以枚举 $2025$ 的倍数。

这样就快多了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int sum=0;
int main(){
	for(int k=1;k*2025<=2000000;k++){
		for(int i=min(k*2025-1,1000000);k*2025-i<=1000000&&i>=1;i--){
			if(__gcd(i,k*2025-i)==1&&k*2025-i>i)sum++;
		}
	}
	cout<<sum;
	return 0;
}
```

所以我们经过计算，答案是 $93816892$，让我们使用简短的 python 代码：


```python
print(93816892)
```

你也可以使用时间更快的 C++ 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<93816892;
	return 0;
}
```


这样就可以了。

所以，能不能点个小小的赞呢 qwq？

---

## 作者：ziyaojia (赞：2)

## P12869 \[蓝桥杯 2025 国 Python A] 特殊整数对的数量

我们如果按照普通的 $O(n^2 \log n)$ 的时间复杂度是肯定做不出来的。所以说我们可以通过第三条规则来用 a 去求出 b 的。

我们通过一个循环来枚举这是 2025 的第几倍（最大值是 987）, 再用一个循环枚举 a（最大值为 `max(1,s-1000000)`，确保 $b=s-a\le10^6$, 最小值为 `min((s-1)/2,999999)`， 确保 $a<b$ 且 $a\le999999$）

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e6;
long long ans;
int main(){
    for(int i=1;i<=987;i++){
    	int s=2025*i;
    	int a_min=max(1,s-max_n);
    	int a_max=min((s-1)/2,max_n-1);
    	if(a_min>a_max)continue;
		for(int a=a_min;a<=a_max;a++){
			int b=s-a;
            if(__gcd(a,b)==1){
				ans++;
				//cout<<a<<' '<<b<<endl;
			}
		}
    }
    cout<<ans;
    return 0;
}
```

当然直接提交上去是不行的，所以我们需要在本地软件运行过后在输出答案，最后结果为 93816892。

### [AC](https://www.luogu.com.cn/record/220775868) Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<93816892;
    return 0;
}
```

---

## 作者：l_b_x (赞：2)

# 题解
## 方法
 方法就是爆搜，搜索到了正确答案后就输出就可以 ac 了。

 不要管什么时间复杂度，因为这是提交答案题。

## 代码
有个好东西叫 __gcd(）求最大公约数，用它我们可以轻松解掉此题。

```cpp
#include <bits/stdc++.h> // 万能头 
using namespace std;



int main()
{

 	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	 
	int n = 0, ans = 0; //定义变量 
 	// 这里 i <= 200000 / 2025 是因为 a <= 1000000, b <= 1000000 a + b <= 2000000, 但有个小错, 后面会讲到 
	for (int i = 1; i <= 2000000 / 2025; i++)
	{
		for (int a = 1; a < i * 2025; a++) // a 的取值范围 
		{
			int b = 2025 * i - a; // 注意, b 不是i - a, 而是 2025 * i - a 
			if (__gcd(a, b) == 1 /*判断是否互质*/ && a < b && a <= 1000000 && b <= 1000000 /*不写这句话会有问题, 反例 : a = 1000001, b = 1000 会有错*/ ) ans++;
			
		}
	}
	cout << ans; // 输出 
	return 0;
}

```
但这串代码输出很慢，所以我直接把答案给大家。

## 答案

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{

 	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cout << 93816892;
	return 0;
        //AC qwq
}
// 答案, 不做过多解释
```
管理大大求过

---

## 作者：rui_er (赞：2)

鉴于这里是洛谷并且本题为 Python 组题目，本题解同时提供 C++ 和 Python 语言的代码。

- Q：提交答案题与传统题的区别是什么？
- A：传统题的时间限制是 $1$ 秒，而提交答案题的时间限制是整场比赛时长！

因此不必像传统题一样追求极致的效率，只需编写出一个能在合理时间内求出答案的程序即可。

我们可以枚举所有 $a$ 的值，忽略 $a\perp b$ 的要求，先只考虑 $b$ 的范围以及 $2025\mid(a+b)$ 的要求。设 $a\bmod 2025=m$，则 $b\bmod 2025$ 必须等于 $(2025-m)\bmod 2025$，据此可以求出最小的 $b$ 为 $b_{\min}=a+(2025-2a\bmod 2025)$，所有可能的 $b$ 值满足 $b=b_{\min}+2025k$（其中 $k\in\N$）。

设 $N=10^6,M=2025$，可以估算需要枚举的 $(a,b)$ 对数大约为 $\frac{N^2}{2M}\approx 246913580$。事实上，写一个程序验证发现准确数值为 $246913304$。

我们可以断言该数值乘以求 gcd 带来的 $\log N$ 后所需的计算时间仍在合理范围内。依照上述代码逻辑，可以编写出以下程序：

C++ 程序（我的电脑上运行时间约为 $8\sim 9$ 秒）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int ans = 0;
    for(int a = 1; a <= 1000000; ++a) {
        for(int b = a + (2025 - 2 * a % 2025); b <= 1000000; b += 2025) {
            if(__gcd(a, b) == 1) ++ans;
        }
    }
    cout << ans << endl;
    return 0;
}
```

Python 程序（我的电脑上运行时间约为 $35\sim 36$ 秒）

```python
import math
ans = 0
for a in range(1, 1000001):
    for b in range(a + (2025 - 2 * a % 2025), 1000001, 2025):
        if math.gcd(a, b) == 1:
            ans += 1
print(ans)
```

在不到一分钟的时间内，我们得到了答案 $93816892$，使用对应的语言输出这个数即可。

---

## 作者：_WCW_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12869)
## 解题思路
这道题其实就是一道暴力枚举题，不用在意时限，因为这是一道结果填空题。但是如果直接枚举所有的 $a$ 和 $b$ 时间会太长，一共需要 $10^{12}$ 次枚举，需要优化一下。

我们可以枚举 $a$ 和 $b$ 的和，之后枚举每个 $a$，求出对应的 $b$，之后进行判断即可。
## 代码
### C++ 枚举代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans=0;
signed main()
{
    for(int sum=2025;sum<=2e6;sum+=2025)//枚举所有的和，由于a和b最大到10^6，所以总和为2*10^6
    {
        for(int a=1;a<=1e6;a++)//枚举所有的a
        {
            int b=sum-a;//通过总和与a求出b
            if(__gcd(a,b)==1 && b>a && b<=1e6) ans++;//判断是否满足条件，满足就加一
            //__gcd(a,b)求出a和b的最大公因数
        }
    }
    cout<<ans;//输出

    return 0;
}
```
等待几分钟后，可以得到输出结果是 $93816892$，直接输出就可以。
### C++ [AC](https://www.luogu.com.cn/record/221010591) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<93816892;

    return 0;
}
```
### Python [AC](https://www.luogu.com.cn/record/221020629) 代码

```python
print(93816892)
```

---

## 作者：tengteng666666 (赞：1)

### 思路：
1. 因为 $a+b$ 必须是 $2025$ 的倍数，所以枚举 $k$ ，使得 $a+b=2025\times k$，其中 $k$ 最大到 $987$（因为 $2025\times987\approx2\times 10^6$）。
2. 对于每个 $k$，的范围是 $\max(1, 2025k - 10^6)$ 到$\lfloor\frac{2025k - 1}{2}\rfloor$（保证 $a<b$）。
3. 在 $a$ 的范围内，统计和 $2025k$ 互质的数的个数：$\gcd(a,b) = \gcd(a,2025k - a) = \gcd(a,2025k) = 1$
4. 用质因数分解和容斥原理快速计算区间内和某个数互质的数的个数。
5. 对于每个 $m=2025k$，我们需要计算区间 $[L,R]$ 内与 $m$ 互质的整数个数。具体步骤如下：
 + 质因数分解：将 $m$ 分解为 $m = \prod_{i=1}^{t} p_i^{e_i}$，其中 $p_i$ 是质因数。例如 $2025 = 3^4 \times 5^2$，所以当 $k=1$ 时，$m$ 的质因数为 $3$ 和 $5$。
 + 容斥公式：区间内与 $m$ 互质的数个数为：
   $$
   \Phi(L,R,m) = (R-L+1) - \sum \left\lfloor \frac{R}{p_i} \right\rfloor - \left\lfloor \frac{L-1}{p_i} \right\rfloor \\
   + \sum \left\lfloor \frac{R}{p_ip_j} \right\rfloor - \left\lfloor \frac{L-1}{p_ip_j} \right\rfloor \\
   - \cdots + (-1)^t \left( \left\lfloor \frac{R}{\prod p_i} \right\rfloor - \left\lfloor \frac{L-1}{\prod p_i} \right\rfloor \right)
   $$
 + 位运算实现：用二进制位表示质因数的组合：对每个非空子集 $S \subseteq \{1,...,t\}$：计算乘积 $P = \prod_{i\in S} p_i$，根据子集大小的奇偶性决定加减。
### Python 代码：
```python
import sys

N = 10**6 + 10
p = [0] * N
v = [0] * N
m = 0
cnt = 0

def init():
    global cnt
    for i in range(2, N):
        if v[i] == 0:
            cnt += 1
            p[cnt] = i
        j = 1
        while j <= cnt and i * p[j] < N:
            v[i * p[j]] = 1
            if i % p[j] == 0:
                break
            j += 1

f = [0] * 20
t = 0

def fac(x):
    global t
    t = 0
    i = 1
    while i <= cnt and p[i] * p[i] <= x:
        if x % p[i] == 0:
            t += 1
            f[t] = p[i]
            while x % p[i] == 0:
                x //= p[i]
        i += 1
    if x > 1:
        t += 1
        f[t] = x

def cal(L, R):
    res = 0
    s = 1
    while s < (1 << t):
        k = 1
        b = 0
        for i in range(1, t+1):
            if s & (1 << (i-1)):
                k *= f[i]
                b += 1
        c = R // k - (L-1) // k
        if b & 1:
            res += c
        else:
            res -= c
        s += 1
    return (R - L + 1) - res

def main():
    init()
    ans = 0
    for k in range(1, 988):
        M = 2025 * k
        if M > 2 * 10**6:
            continue
        L = max(1, M - 1000000)
        R = (M - 1) // 2
        if L > R:
            continue
        fac(M)
        ans += cal(L, R)
    print(ans)

if __name__ == "__main__":
    main()
```
### C++ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int p[N],v[N],m,cnt;
void init(){
    for(int i=2;i<N;i++){
        if(!v[i])p[++cnt]=i;
        for(int j=1;j<=cnt&&i*p[j]<N;j++){
            v[i*p[j]]=1;
            if(i%p[j]==0)break;
        }
    }
}
int f[20],t;
void fac(int x){
    t=0;
    for(int i=1;i<=cnt&&p[i]*p[i]<=x;i++){
        if(x%p[i]==0){
            f[++t]=p[i];
            while(x%p[i]==0)x/=p[i];
        }
    }
    if(x>1)f[++t]=x;
}
int cal(int L,int R){
    int res=0;
    for(int s=1;s<(1<<t);s++){
        int k=1,b=0;
        for(int i=1;i<=t;i++)
            if(s&(1<<(i-1)))k*=f[i],b++;
        int c=R/k-(L-1)/k;
        if(b&1)res+=c;
        else res-=c;
    }
    return (R-L+1)-res;
}
int main(){
    init();
    int ans=0;
    for(int k=1;k<=987;k++){
        int M=2025*k;
        if(M>2e6)continue;
        int L=max(1,M-1000000);
        int R=(M-1)/2;
        if(L>R)continue;
        fac(M);
        ans+=cal(L,R);
    }
    cout<<ans<<endl;
    return 0;
}
```
**将 C++ 代码转化为 Python 代码的工作由 deepseek 完成。**

---

## 作者：SuyctidohanQ (赞：1)

### 思路分析

看到要求 $a + b$ 必须是 $2025$ 的倍数，这就说明了 $a + b \mod 2025 = 0$。

如果直接枚举 $a,b$，会多出来不必要的枚举次数，因为这些枚举次数都是 $a + b$ 的和都不是 $2025$ 的倍数，就不满足条件 $3$。

```cpp
for(LL i = 2025; i <= (LL)(1e6); i += 2025)
```

对于条件 $2$，$a$ 和 $b$ 互素，即 $a$ 和 $b$ 的最大公约数为 $1$。这里可以使用 `__gcd()` 函数计算最大公因数，判断一下是不是 $1$ 就好了，即 $\gcd(a,b) = 1$。

```cpp
if(a < b && __gcd(a, b) == 1)
```

对于条件 $1$，这就是我们枚举的上限。

### 代码实现

这里提供一份 C++ 的暴力代码：

```cpp
#include<bits/stdc++.h>
#define please return 
#define AC 0

using namespace std;

typedef long long LL;
LL ans = 0;
signed main() {
	for(LL i = 2025; i <= (LL)(2e6); i += 2025) {
		for(LL j = max(1LL, i - (LL)(1e6)); j <= min(i * 1LL, (LL)(1e6)); j++) {
			LL x = i - j;
			if(j < x && __gcd(j, x) == 1) ++ans;
		}
	}
	printf("%lld\n", ans);
	please AC; 
}
```

运行可得答案为 $93816892$。

使用 Python 输出答案：

```python
print(93816892)
```

---

## 作者：longyitongxue (赞：1)

[题目の传送门](https://www.luogu.com.cn/problem/P12869)
# 主要思路
这道题既然是提交答案题那就好办了，我们可以暴力求出有多少对满足 $1\le a<b\le10^6$ 且 $\gcd\left(a,b\right)=1$ 且 $\left(a+b\right)\bmod2025=0$ 的 $\left(a,b\right)$。我们可以写一个双重循环，外层循环 $a$ 从 $1$ 到 $10^6$，里层循环 $b$ 从 $i+1$ 到 $10^6$（既然 $1\le a<b\le10^6$，那么 $b\le a$ 的情况就没必要考虑了），如果满足以上三个条件，答案就加一，最后输出答案即可。

## 暴力代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	long long ans=0;
	for(int a=1;a<=1e6;a++){
		for(int b=a+1;b<=1e6;b++){
			if((a+b)%2025==0&&__gcd(a,b)==1)ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

然后我们耐心等待~~一下~~（甚至出去外面走走回来一看还没运行完），发现答案就是 $93816892$，这就是我们要提交的东西了。

![](https://cdn.luogu.com.cn/upload/image_hosting/xxrd6qd3.png)

# [AC](https://www.luogu.com.cn/record/220773691) code
```cpp
#include<iostream>
using namespace std;
int main(){
    cout<<93816892;
    return 0;
}
```

---

## 作者：TCY1234567 (赞：1)

## P12869 题解

### 题意

有两个数 $a$ 和 $b$, 需要满足三个条件

$1≤a<b≤10^6$

$a$ 与 $b$ 互质

$a+b$ 是 $2025$ 的倍数

问有多少个数对 $(a,b)$ 满足这些条件。

### 思路

介绍一种很好理解的办法。

首先我们如果暴力枚举 $a$ 和 $b$ 的话，那么时间复杂度是  $O((10^6)^2)$，显然会炸飞，所以考虑优化。

观察到 $a+b$ 是 $2025$ 的倍数，且 $a+b$ 最大就是 $2 \times 10^6$ ,所以我们可以枚举出 $a+b$ 的和，然后再枚举 $a$，最后将 $b$ 求出，最后一一判断每一个条件即可，此时时间复杂度是 $O(\frac{10^6 \times (2 \times 10^6)}{2025})$，大概是 $9 \times 10^8$ 左右，等几秒就可以得到答案了。

参考代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int ans = 0;
	for(int i=2025;i<=2e6;i+=2025)
	{
		for(int x=1;x<=i/2;x++)
		{
			int y = i-x;
			int gcdd = __gcd(x,y);
			if(gcdd==1&&y>x&&y<=1e6) ans++;//判断各个条件
		}
	}
	printf("%d\n",ans);
}
```

最后答案是 $93816892$，输出即可。

---

## 作者：封禁用户 (赞：0)

由于 $a,b \le {10}^6$，直接枚举 $a$ 和 $b$ 的值会非常慢。因为要求 $a+b$ 是 $2025$ 的倍数，考虑先枚举 $a+b$ 的值再枚举 $a$ 的值，然后计算答案。

C++ 暴力代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long ans=0;
    for(int i=2025;i<=2000000;i+=2025){
        for(int a=max(1,i-1000000);a<=min(i,1000000);a++){
            int b=i-a;
            if(a<b&&__gcd(a,b)==1)ans++;
        }
    }
    cout<<ans<<endl;
}
```

运行可得答案为 $93816892$。

Python 代码：

```python
print(93816892)
```

---

## 作者：M1__ (赞：0)

# 题解：P12869 [蓝桥杯 2025 国 Python A] 特殊整数对的数量

[Link](https://www.luogu.com.cn/problem/P12869)

- 值得注意的是，这是一道提交答案题。

- 所以我们不必考虑题目中的时间限制，直接暴力（当然需要优化一下）即可。

暴力枚举复杂度为 $O(10^{12})$，显然会炸。我们可以考虑优化一下。因为 $a+b$ 是 $2025$ 的倍数且 $a+b<10^6$，所以我们可以直接枚举 $a+b$。然后单独枚举 $a$ 并求出 $b$。最后判断是否满足 $a \perp b$ 且 $1 \le a < b < 10^{6}$ 即可。

最后答案为 $93816892$。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll cnt;
int main(){
	for(ll i=2025;i<=2e6;i+=2025){
		for(ll a=1;a<=i/2;a++){
			ll b=i-a;
			if(__gcd(a,b)==1&&b>a&&b<=1e6) cnt++;
		}
	}
	cout<<cnt;
    return 0;
}
```

```python
print(93816892)
```

---

## 作者：Ashankamiko (赞：0)

# 题目简述
### 题意
求满足下列要求的 $(a,b)$ 的个数:
- $1 \leq a < b \leq 10^6$ 。
- $a$ 与 $b$ 互素，即 $a$ 和 $b$ 的最大公约数为 $1$ 。
- $a + b$ 是 $2025$ 的倍数。
### 思路
暴力枚举，参考以下代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long

signed main() {
	int cnt = 0;
	for (int i = 1; i <= 1e6; i++)
		for (int j = (2025 - i % 2025) % 2025 + (int)(i / 2025) * 2025; j <= 1e6; j += 2025) //第二重循环记得优化，不然时间复杂度过高
			if (__gcd(i, j) == 1 && i < j) //如果互质且i<j，符合条件
				cnt++;
	out << cnt;
	return 0;
}
```
附上 Python 代码，和 C++ 代码的思路一致。
```python
import math
cnt = 0
for i in range(1, 1000000, 1):
    for j in range(int((2025 - i % 2025) % 2025 + (i / 2025)), 1000000, 2025):
        if math.gcd(i, j) == 1:
            cnt += 1
print(cnt)
```

那么最后输出 `93816892` 即可。

---


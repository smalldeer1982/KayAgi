# 取数游戏 II

## 题目描述

有一个取数的游戏。初始时，给出一个环，环上的每条边上都有一个非负整数。这些整数中至少有一个 $0$。然后，将一枚硬币放在环上的一个节点上。两个玩家就是以这个放硬币的节点为起点开始这个游戏，两人轮流取数，取数的规则如下：

1.  选择硬币左边或者右边的一条边，并且边上的数非 $0$；
1.  将这条边上的数减至任意一个非负整数（至少要有所减小）；
1.  将硬币移至边的另一端。

如果轮到一个玩家走，这时硬币左右两边的边上的数值都是 $0$，那么这个玩家就输了。

如下图，描述的是 Alice 和 Bob 两人的对弈过程（其中黑色节点表示硬币所在节点）。

 ![](https://cdn.luogu.com.cn/upload/pic/93.png) 

各图的结果为：

- $\text{A}$：轮到 Alice 操作；
- $\text{B}$：轮到 Bob 操作；
- $\text{C}$：轮到 Alice 操作；
- $\text{D}$：轮到 Bob 操作。

$\text{D}$ 中，轮到 Bob 走时，硬币两边的边上都是 $0$，所以 Alice 获胜。

现在，你的任务就是根据给出的环、边上的数值以及起点（硬币所在位置），判断先走方是否有必胜的策略。

## 样例 #1

### 输入

```
4
2 5 3 0
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
0 0 0
```

### 输出

```
NO
```

# 题解

## 作者：intruder (赞：93)

楼下说的都很好，但是我想应该没有那么复杂

首先，对于一条链a1,a2,a3,a4......0 如果是偶数条边，那么现手一定赢，因为他每一次都只用把后面一条取完，例如

5 4 3 6 5 0

先手取完5，后手没法回到前一个位置，而无论接下来后手去多少，先手继续取完3，再然后取完5，后手没办法再去，先手赢。就这样，如果从起点到第一个出现0的地方一共有偶数条边，先手可以一步一步将后手被迫向前逼近，直到无法移动（由于是环，还应该考虑向后逼近）。

同样的，如果这有奇数个，那么先手第一步无论怎么取，都将自己置于一个必败状态（此时对于后手来说边数变成偶数），就一定没有必胜状态



            
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,a[25];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=1;i<=n;i++)
        if(a[i]==0){
            if(i%2==0)return puts("YES"),0;
            break;
        }
    for(int i=n;i>=1;i--)
        if(a[i]==0){
            if((n-i+1)%2==0)return puts("YES"),0;
            break;
        }
    puts("NO");
    return 0;
}
```

---

## 作者：远航之曲 (赞：27)

这是一道数学题。。。

 我们来举个例子：有一条边R从x指向y，它的数值大于0，AB对弈，现在A走


 那么如果数值为1，A走过去，数值变为0，B就走不回来了


如果数值为2，A走过去，数值变为1，如果B走回来，A不就死了？我们认为他们都足够聪明，怎么会做这种事情呢？（假设过来的前一条边已经走完了，数值为0）


如果数值大于3（我们假定为3），A走过去，数值变为2，B如果仁慈地走回来，数值变为1，这样不就浪费了一步？


B如果按照题意残忍地用最佳行动走回来，取光所有数值，那么数值变为0，这条路就封死了，A做了一件无意义的事情，还封死了自己可以走的一条路，这对于先手的A而言是不利的，


这两种方法都明显有违双方最优的前提。


[/color][b]所以我们可以知道，无论是A走还是B走，即无论是先手走还是后手走，每走过一条路都一定取完，这样问题就简单了[/b]


因为至少有个0，所以就简单了一点。。谁把对手逼到死路（两边都是0的）就赢了


从起始点开始向两边找，只要有一边到0边距离为奇数就是先手赢反之后手赢


代码如下


```cpp
#include<cstdio>
#define    judge(value) (value&1)
int n,s[1000];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&s[i]);
    int a=0;while(s[++a]);
    int b=0;while(s[n+1-(++b)]);
    if (judge(--a)||judge(--b))  printf("YES");  else printf("NO");
}
```

---

## 作者：Telaris11321 (赞：26)

一方无路可走意味着另一方胜利，而一次移动最多只能创造出一条0边，这就意味着造成终局的步骤，一定是赢家主动走到了一条0边旁，也就是下图。

![checkmate，将死](https://cdn.luogu.com.cn/upload/pic/62682.png)

我们发现如果一方创造出一条0边，另一方如果不复读行为的话，就创造出对方速胜的局面。因此，当一个人创造出一条0边的时候，两人就必须沿着既定方向狂奔，一直到撞到一条0边。

那么，当甲先手时，如果他到两个其中一个端点（端点为可移动范围的两端）的距离为奇数条边的时候，他可以选择向其进入狂奔，必胜，因为最后一条边一定是甲取。

反之，如果两个距离都是偶数，那么如果甲开始狂奔，那么输，如果甲不创造零边，那么给乙创造出两奇数必胜的局面。

## 考察先手位置到两端点的距离大小的奇偶性即可。
# AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int lf=100000000,rf=-1;
int N;
int e[5000000]={0}; 
int main(){
    cin>>N;
    for(int i=1;i<=N;i++) scanf("%d",&e[i]);
    for(int i=1;i<=N;i++) if(e[i]==0){
    	lf=min(lf,i);
    	rf=max(rf,i);
	}
	lf--;
	rf=N-rf;
	if(lf&1||rf&1){
		printf("YES");
	}
	else{
		printf("NO");
	}
} 
```


---

## 作者：zzr8178541919 (赞：15)

对于博弈论的题目来说，大部分的题目都需要思维。

往往思维想到了，写起来就很容易，今天，我们就拿这道题为例找到一些博弈论中的规律。

对于一个新的规则，我们怎么分析呢？

首先我们当然要了解题目的意思。

![](https://cdn.luogu.com.cn/upload/pic/93.png)

如图所示，这就是题干中的图片。有四个操作
#### 1.把黑点移到右上角，经过的路径为0（先手）
#### 2.把黑点移到右下角，经过的路径为1（后手）
#### 3.把黑点重新移到右上角，经过的路径为0（先手）
#### 此时后手无法继续移动，先手胜利。

那肯定有人问：那第二步后手把经过的路标记为0不行吗？
#### 会发现，这样先手仍然能取得胜利、
如果第三步先手将黑点移到左下角，把路径改成0，先手也赢。

#### 我们会初步感觉，只要走过某条路后将路径赋值为0，下一步肯定只能将路径赋值成0。
 分析一下，加入下一步不赋值成0，就会被对方跳回去。对方就赢了！

#### 接着我们发现第二个规律。这个游戏永远不可能跳过0。也就是说从当前的位置，最远只能跳到左右两边最近的0的前一个位置（理解一下，可以多读几遍）
理由很简单，因为跳不过去呀。。。。

我们在这就可以把向左和向右的最近的0的长度处理出来

#### 接着我们又发现了一个小规律！！
#### 每次跳跃最优的方案都是将边值改为0
仔细想一下，为什么呢？

别急，我们来证明一下，假设对于初始情况的黑点（这里讨论的是两边都不为0的情况，因为若有一边为0就只有一种选择）

现在黑点有两种选择：1.向左跳。2.向右跳,实际上向左向右都一样，我们以向右跳为例子。

那么向右跳又有两种情况：
#### 1.将边赋值成0
#### 2.将边赋值成大于0的数
如果赋值成0，那么相当于后手只有唯一的移动方法。可以看做断了后手的一条退路。

而如果赋值成一个大于0的数。
那么此时对于后手来说，它如果向右跳，就和方案一一样。但后手此时比方案一多一种情况，它可以向左跳！

后手向左跳又有两种选择
#### 1.将边改为0（断了先手的退路，先手此时处于被动局面）
#### 2.将边改为大于0的数（相当于游戏又重来了）
对比可以发现，将边改为0要比将边改为1好。

那事情就变得很容易了。
#### 对于第一步，有两种操作向左或向右。且操作完双方都会按照规则一直向前走一直走到0。（这样我们就能用奇数偶数的方法判断出谁先没有路可走）。
如果两边有一边先手可以胜利，那么先手就一直往那边走即可。

### 这样，一个游戏就美好地得到了解决。
代码实现起来也不难！
```cpp
#include<cmath>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<iostream>
using namespace std;
int a[105];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int wns1=0;
	int wns2=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=0)
    	   	wns1++;
		else
    		break;
	}
	for(int i=n;i>=1;i--)
	{
		if(a[i]!=0)
    		wns2++;
		else
    		break;
	}
	if(wns1%2==1 || wns2%2==1)
	{
		printf("YES\n");
	}
	else
    	printf("NO\n");
	return 0;
}
```
 \\(^o^)/~



---

## 作者：MrYqy (赞：9)

嗯，沉迷数（kuang）学（da）物（you）理（xi）的信息蒟蒻发布的第一篇题解。
这道题看起来比较困难，其实不需要考虑环上的权值，先手者将一边改为0后可以决断后手方的方向或者直接结束游戏，所以当玩家始终处于先手状态（即非零权值为奇数时）即可使对方时刻处于被动状态导致最后没有路可以走而落败；


------------

就好比三子棋一样，先手方每一步都可以强迫后手方下固定的一步来应对，因为三子棋9格（奇数），所以一定会导致后手方落败，因为他们的下棋步数一定为偶数（一个打一个挨），所以，经过简单的模拟推论。得出本题目的博弈原理（奇数原理），代码如图；
tips：不可以将0算入格数，因为0表示边界，不可以下；
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tot=0;
int a[21];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]!=0)tot++;//0作为边界不记入tot 
	}
	if(tot%2==1)cout<<"YES";//数据不包含第一步就死棋的情况故不考虑
	else cout<<"NO";
	return 0;
}
```
多谢诸位观看记得点赞哦，如有建议欢迎私信，咕叽咕叽

---

## 作者：__stdcall (赞：8)

我的题解没有楼下的几位分析的那么透彻

但确实是一点一点分析出来的，毕竟我也是刚开始学博弈论

新手也可以参考一下我的

首先尝试无脑的博弈搜索，60分

然后开始想优化。。。

对于状态0\*0，\*表示当前处在的位置，是我们知道的第一个必败状态

那么对于状态0\*n 0，就是必胜状态，对称的时候同理

然后0\*1 n 0就是必败状态，因为只能转移到0\*n 0

我们还知道0 n\*m 0是必胜状态

所以0\*n m 0就是必败状态，因为只能转移到0\*n 0（必胜）和0 a\*b 0（必胜）

于是0\*a b c 0就是必胜状态，0 a\*b c 0是必胜状态

所以0\*a b c d 0是必败状态

由以上可得知，对于0\*a b c d e...0的状态，如果两个0中间的长度为偶数，必败，长度为奇数，必胜

然后对于任意的0 a\*...和...\*a 0的状态，必胜

然而还是TLE三个点啊。。。继续分析吧

好像有一个很简单的优化，根据上面的分析得知

如果当前状态是0 a b...\*...c d 0

这时候可以选择把左边相邻状态变为0或者把右边相邻的变为0

如果这两种有一个必败状态，则此状态必胜

过了。。。大成功。

不过我还是不会分析复杂度啊，博弈搜索好像很多玄学的样子，每次都要实验才能知道算法能不能过，这样下去吃枣药丸







```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
int n;
int a[25];
int next( int idx ) {
    if( idx == n-1 ) return 0;
    else return idx+1;
}
int prior( int idx ) {
    if( idx == 0 ) return n-1;
    else return idx-1;
}
bool dfs( int idx ) {
    if( a[idx] == 0 && a[prior(idx)] == 0 ) return false;
    if( a[idx] != 0 && a[next(idx)] == 0 ) return true;
    if( a[prior(idx)] != 0 && a[prior(prior(idx))] == 0 ) return true;
    if( a[idx] == 0 ) { // 确定状态，右边为0
        int cnt = 0;
        for( int i = prior(idx) ; a[i] != 0 ; i = prior(i) ) ++cnt;
        if( (cnt&1) ) return true;
        else return false;
    }
    if( a[prior(idx)] == 0 ) {
        int cnt = 0;
        for( int i = idx ; a[i] != 0 ; i = next(i) ) ++cnt;
        if( (cnt&1) ) return true;
        else return false;
    }
    // 把右边变为0
    int tmp = a[idx]; a[idx] = 0;
    if( dfs(next(idx)) == false ) {
        a[idx] = tmp;
        return true;
    }
    a[idx] = tmp;
    // 把左边变为0
    tmp = a[prior(idx)]; a[prior(idx)] = 0;
    if( dfs(prior(idx)) == false ) {
        a[prior(idx)] = tmp;
        return true;
    }
    a[prior(idx)] = tmp;
    // 其他的各种尝试
    for( int i = 1 ; i < a[idx] ; ++i ) {
        a[idx] -= i;
        if( dfs(next(idx)) == false ) {
            a[idx] += i;
            return true;
        }
        a[idx] += i;
    }
    for( int i = 1 ; i < a[prior(idx)] ; ++i ) {
        a[prior(idx)] -= i;
        if( dfs(prior(idx)) == false ) {
            a[prior(idx)] += i;
            return true;
        }
        a[prior(idx)] += i;
    }
    return false;
}
int main() {
    scanf( "%d" , &n );
    for( int i = 0 ; i < n ; ++i ) scanf( "%d" , &a[i] );
    if( dfs(0) ) printf( "YES\n" );
    else printf( "NO\n" );
    return 0;
}

```

---

## 作者：Priori_Incantatem (赞：4)

我们可以把这个环想象成两条路，如果路的尽头没有边权为 $0$ 的边，那么两条路径就是一样的。

对于一条路径，设 $Alice$ 为先手，那么她将她走过的路径边权变为 $0$。轮到 $Bob$ 时，他最多也只能有一条路可以走。如果他选择不将该路边权变为 $0$，下一步 $Alice$ 一折返他就输了。如果他将边权变为 $0$，那么就变成重复以上操作了  
最后如果路径长度为奇数，$Alice$ 还是赢；路径长为偶数的话 $Alice$ 就没有必胜策略

这样这题就被转化成判断两条路径奇偶性了

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int Maxn=30;
int a[Maxn],n;
int ans,tot; // 储存两条路长度
int main()
{
//	freopen("in.txt","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	scanf("%d",a+i);
	
	int i=1;
	while(i<=n && a[i])++ans,++i;
	i=n;
	while(i>0 && a[i])++tot,--i;
	
	if((ans & 1) || (tot & 1))puts("YES");
	else puts("NO");
}
```

---

## 作者：Yscore (赞：2)

本菜鸡第一次看错题目没看到至少有一个0，所以试着做了这道题的升级版。本题解讨论重点就变成**没有**“至少有一个0”约束下题目的解答，如有错误请大家批评指正。
## 有“至少有一个0”约束
当某位玩家行动时发现硬币的旁边有一条0边，那他只能将他唯一可走的那条边变成0然后继续（如果不变成0的话对面往回走把这条边变成0那就一定输了）。

对于“至少有一个0”约束下的情况，先手方有两个方向走到最近的0边，而如果其中有一条路间隔的边数为奇数的话，先手一定必胜（先手玩家只要往间隔边数为奇数的方向走，把走过的边变成0就能赢，因为最后一定是自己拿完非0的一条边）。如果两条路的间隔都为偶数，那无论先手方怎么走，后手方都会有方向与最近的0边间隔边数变为奇数，此时先手必败。

## 当所有边都可以不为0时
如果总边数N为奇数，先手只需要第一步走出0即可胜利，因为此时后手两个方向与0边的距离为$(0, N-1)$，均为偶数，后手必败。

如果总边数N为偶数，情况就变得有些复杂了，我们先来看一个比较简单的情况。
```
Input：
4
2 1 1 1

Output:
YES

```
先手方将第一个2改成1就赢了。我们可以猜测此时决定胜负的变成了两个方向与最小边的距离的奇偶性，在上面的例子中，最小的边值为1，先手方两个方向与最小边的距离为$(1, 0)$，存在一个奇数1，因此先手胜利。

下面的是该猜想正确性的证明，之后假设有两个玩家A，B，玩家的状态会用$(x, y)$表示，代表两个方向与最小边的距离。

在A的状态已经为$(x, y)$（x, y均为偶数）的情况下，他能怎么做呢？

1. 下一步产生唯一的最小边。此时B为$(0, N-1)$，N-1为奇数，B只需要走相同方向的相同步即可，下一步A仍为$(0, N-2)$，A的状态无法改变。如：A把3 3 3 3走成3 3 3 1，B只需继续走成1 3 3 1即可。
2. 下一步产生最小边，与已存在的最小边值相等。此时B为$(0, y-1)$或者$(x-1, 0)$，存在一个奇数。B仍然只需要走相同方向的相同步即可，下一步A会变成$(0, y-2)$，$(x-2, 0)$，均为偶数，A的状态无法改变，或者遇到已存在的最小边而不得不产生唯一的最小边从而变为情况1，A必败。
3. 下一步不产生最小边。此时B为$(x-1, y+1)$或者$(x+1, y-1)$，均为奇数。B可以在下一步产生最小边，与已存在的最小边值相等。此时A的情况为$(0, y+2)$，$(x, 0)$，$(x+2, 0)$，$(0, y)$，均为偶数，A的状态无法改变。

所以只要B走的没错，A将一直保持$(\text{even}, \text{even})$状态，而$(\text{even}, \text{even})$状态的最终情况就是$(0, 0)$且最小边为0，此时A无路可走。得出结论：

**与最小边两个方向距离均为偶数是必败态**

## AC代码
```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>
#include <numeric>
#include <map>
#include <set>
#include <cstring>

using namespace std;

int N;
vector<int> v;

int main()
{
    cin >> N;
    int k;
    for (int i = 0; i < N; ++i)
    {
        cin >> k;
        v.push_back(k);
    }
    k = *(min_element(v.begin(), v.end()));
    auto first_itr = find(v.begin(), v.end(), k);
    auto last_itr = find(v.rbegin(), v.rend(), k);
    int first_dis = first_itr - v.begin();
    int last_dis = last_itr - v.rbegin();
    if (k != 0 && N % 2 == 1)
    {
        cout << "YES" << endl;
        return 0;
    }
    if (first_dis % 2 == 0 && last_dis % 2 == 0)
        cout << "NO" << endl;
    else
        cout << "YES" << endl;
    return 0;
}
```


---

## 作者：塔罗兰 (赞：2)

这是今天教练给我们模拟考的题，AC了，BUT发现教练把题目复杂化了，所以在洛谷上WA了两次……  
这题主要是找规律，规律如下：  
从起点出发，只要有一端有奇数个连续正整数，那么就有必胜策略。  
上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,i,j,a[150],l,p;
	scanf("%d",&m);
	j=0;
	for(j=0;j<m;j++)
	scanf("%d",&a[j]);
	j=0;//初始化
	p=0;//初始化
    l=0;//初始化
	while(a[j]!=0&&j<m)//顺时针搜
	{
		j++;
		l++;//累加连续正整数数
	}
	if(j<m)
	{
		j=m-1;
		while(a[j]!=0)//逆时针搜
		{
			j--;
			p++;//累加连续正整数数
		}
	}
	if(l%2==0&&p%2==0)//判断是否符合规律
	printf("NO\n");//注意大小写
	else
	printf("YES\n");//注意大小写
	return 0;//完美结束
}
```
从这件事我们得出结论：千万不要相信教练……
orz求过

---

## 作者：Xiao_Ling (赞：2)

# 博弈论的题只要想到了解法就很简单

## 以下，我将详细的讲讲该怎么想

### 这题给了一个圈，给了边的权值，而且是要判断能否先手赢，所以可以简单的模拟一下过程

### 最后你可以看到，如果 **要赢，最后一条边必须自己走** 而你又是先走的那一个

### 我们可以求极限，只有两条边可以走 ，那么我们走完后剩一条，给对手了，然后就输了，，，

### 如果有三条边，模拟一下就可以知道最后一条边是自己走，然后 **胜利QwQ**

### 因此只要能到达的路有奇数条就可以了~~~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,sum=0;
int a[30]={0};//记录 
bool flag=false;//赢与否的判断 0.0 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) 
    //正着走 
    {
        if(a[i]) sum++;
        else 
        {
            if(sum%2==1) flag=true; 
        }
    }
    sum=0;
    if(!flag)
    for(int i=n;i>=1;i--)
    //反着走 
    {
        if(a[i]) sum++;
        else 
        {
            if(sum%2==1) flag=true;
        } 
    }
    if(!flag) cout<<"NO";
    else cout<<"YES";
    return 0;
}
### (注意是个环，有两个方向) 

```

---

## 作者：01190220csl (赞：1)

用a1表示顺时针走首次遇到0的步数，a2表示逆时针首次遇到0的步数。

1.a1=0（a2=0时类似）：必须逆时针走1步，把数据改成0（否则对方返回，再把数据改成0后对方胜），同理，下一步对方也会这么做。即获胜条件为a2为奇数。

2.a1为奇数（a2为奇数时类似）：顺时针方向走一步，把数据改成0为必胜策略[接下来可用第一种情况证明对方无必胜策略（即对方必败）]。

3.a1，a2均为偶数：无必胜策略（可用第二种情况证明不论第一步怎么走，后方总有必胜策略）。

故先方有必胜策略的充要条件为a1为奇数或a2为奇数。

补充：若不保证有一条边的权值为0，则只需把a1，a2的定义中0改为所有边中权值最小的那一条边的权值，结论不变，即有一边权值为0是一种特殊情况。证明从略。


---

## 作者：浮川壹渡 (赞：0)

借鉴第一篇题解的思路整理如下

一个环 顺时针道路的值2 5 3 0

要保证先手获胜 就要让后手逐渐靠近0，最后前后都为0


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
int n,a[25];
 
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) 
      if(a[i]==0) 
         { 
           // if(i==1) break;
            if((i-1)%2) {cout<<"YES";return 0;}
            break;
         }
    for(int i=n;i>=1;i--) 
        if(a[i]==0) 
        {
           // if(i==n) break;
            if(((n-i)%2)) {cout<<"YES";return 0;}
            break;
        }
    cout<<"NO";
    return 0;
}
```


以上代码比较不好理解的地方在于if((i-1)%2)和if((n-i)%2) 

因为这题既有路又有点 要梳理好关系

假如环是顺时针读的

先顺时针绕一圈 

先2后5先3

则此时 消完3后总步数为i-1(就是两个点之间道路为i-1)，此时这个环已经全0，那么判断a[4]=0，后手再走就gg 

而先手赢的条件就是i-1是奇数，这表示先手刚好走完 环变为全0

倘若顺时针无解，再逆时针试试，同理，例如顺时针环0 5 3 2

先2后3先5

当先手消完5，此时环全为0，步数为n-i,再进行下一个点即一号点的判断，发现a[1]=0,那么后手被包围了， gameover。

同理 先手赢的条件就是n-i为奇数 这时先手走完 环变为全0 

END.

~~怎么觉得我说话好啰嗦~~


~~应该是太弱了怕脑袋捋不清楚只好详细描述惹~~

~~也许有时间应该再学一学标准解法..？？~~




---

## 作者：miaokehao (赞：0)

如果两个人都考虑最优情况；

------------
- 假设边权为1，则走完1让对手无处可走是最优的
- 假设边权为2，则走完2让对手无处可走是最优的，否则给对手击败自己的机会

所以每次操作取完边上所有权值总是最优，所以只需考虑边权>0的边的个数
```
#include <bits/stdc++.h>
#define res register int
using namespace std;
int n,x,num;
inline int read()
{
  int X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
int main()
{
  //n=read();
  for(res i=1; i<=n; i++)
  {
    x=read();
    if(x) num++;
  }
  if(num&1) puts("YES");
  else puts("NO");
  return 0;
}
```

---

## 作者：agicy (赞：0)

# 思路

## 过程$1$

根据题意可得，当硬币左右两端都是$0$时，这一轮的玩家必输。再扩展一下，可以得出下图。

![](https://cdn.luogu.com.cn/upload/pic/24240.png)

图中红色代表此轮玩家必输，绿色代表此轮玩家必胜。

∴我们可以得出**结论$1$**：**到$0$边的距离为$1$的点的此时的玩家必胜。**

## 过程$2$

下面是先手在一般情况下的游戏方式。（一般情况指两边的值都是正整数）

![](https://cdn.luogu.com.cn/upload/pic/24246.png)

显然，当先手走完以后，后手不可以返回原来的位置，因为先手已经将到初始位置的边清零，所以后手只能遵循先手的方向继续前进，不能反向移动。

∴我们得出了**结论$2$**：**在整局游戏中，硬币移动的方向恒定不变且取决于先手的选择。**

## 过程$3$

**结合结论$1$和结论$2$，我们可以得出一个最终结论**，下面是结论的图示，其中未标出边的数值均大于$0$，**两条$0$边连在一起形成环**，红色代表此轮玩家必输，绿色代表此轮玩家必胜。

![](https://cdn.luogu.com.cn/upload/pic/24252.png)

经过归纳，我们得出了**最后的结论**：

**当且仅当环中有$0$边时，若先手距离$0$边的距离为奇数，则先手必胜，否则必输。**

# 代码

根据上面写出的最后结论，我们写出了代码，如下：

```cpp
#include<stdio.h>//头文件

bool flag;//先手是否必胜
int n,l[32],sum;//sum为先手到0边的距离

int main(void){
	
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&l[i]);
    //读入部分如上
    
	for(int i=n;i>=1;i--)//i从n到1，统计逆时针到0边的距离
		if(l[i]!=0)
			sum++;
		else
			break;
	if(sum&1)
		flag=true;//如果sum为奇数，先手必胜
    
	sum=0;//将sum清零
	for(int i=1;i<=n;i++)//i从1到n，统计顺时针到0边的距离
		if(l[i]!=0)
			sum++;
		else
			break;
	if(sum&1)
		flag=true;//如果sum为奇数，先手必胜
    
	if(flag)//先手胜
		puts("YES");
	else
		puts("NO");
	return 0;
}
```

---

## 作者：Skywalker_David (赞：0)

考虑了一段时间，其实只是一个统计的问题。。。。。。

```delphi

var
    n,ans,total,i:longint;
    a,b:array[1..31] of longint;
begin
    readln(n);
    ans:=0;
    total:=0;
    for i:=1 to n do
        read(a[i]);
    for i:=n downto 1 do
        b[i]:=a[n-i+1];
    for i:=1 to n do
        begin
            if a[i]=0 then break;
                inc(ans);
        end;
    for i:=1 to n do
        begin
            if b[i]=0 then break;
                inc(total);
        end;
    if (ans mod 2=1)or(total mod 2=1) then write('YES')
        else write('NO');
end.

```

---

## 作者：ttt_TTT (赞：0)

~~emmmmm 个人感觉算法有问题~~
**但莫名ac**
如果前面奇数个数，0，后面奇数个数，则环长为偶数，应输出NO，但他会输出YES。然而并没有这样的数据2333。
```

#include<cstdio>
using namespace std;

int n,in,cnt,ans;

int main()
{
    scanf("%d",&n);
    
    while(n--)
    {
        scanf("%d",&in);
        if(in!=0) ++cnt;
        else ans|=(cnt&1),cnt=0;
    }
    
    ans|=(cnt&1);
    
    if(ans) puts("YES");
    else puts("NO");
    
    return 0;
}
```

---

## 作者：易极feng (赞：0)

#博弈论是什么？我只知道贪心...


对于楼下大神的SG函数本蒟蒻只能表示一脸懵逼……


可是在研究题目之后可以发现：

选取一个方向，

每次沿该方向的边移动，

并将此条边上的数值删为零。

如果该边还未移动时数值就是零，

则说明现在轮到的人已经亡了。


所以直接可想出贪心算法：

从最初点向正反两个方向枚举，

若当前边为零，

则判断已走过的边数的奇偶性，

由于是先手，

所以如果是奇数则赢，

偶数则输。


于是便AC了。


```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n;
int a[25];

int main(){
    int i;
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
    }
    a[0]=a[n],a[n+1]=a[1];
    
    for(i=1;i<=n;i++){
        if(a[i]==0){
            if(i%2==0){
                cout<<"YES";
                return 0;
            }
            else break;
        }
    }
    
    for(i=n;i>=1;i--){
        if(a[i]==0){
            if((n-i)%2==1){
                cout<<"YES";
                return 0;
            }
            else break;
        } 
    }
    
    cout<<"NO";
    return 0;
} 
```

---

## 作者：jxpxcsh (赞：0)

策略：先手每一步走都把经过的边变为0，那么二手只有一个方向可走，如果二手不把他走过的边变为0，那么先手可以在下一步中往回走，也就是走刚才二手走的边，并把这条边变为0，由此，二手则必败。也就是说，在这种策略下，二手必须把经过的边变为0，但是最后到底是谁获胜呢？

研究可知，这和初始的时候0所在的位置有关

如果先手的位置走过奇数步（一直往左走或者往右走），能够到达0这条边之前的那个点，那么先手必胜，否则，先手必败。

```delphi

var a:array[0..1000]of longint;
    n,i,x,y:longint;
    p:boolean;
begin
  readln(n);
  p:=false;
  for i:=1 to n do
   read(a[i]);
  readln;
  for i:=1 to n do
   if a[i]=0 then begin x:=i;break;end;
  for i:=n downto 1 do
   if a[i]=0 then begin y:=i;break;end;
  if (x mod 2=0)or((n-y)mod 2=1)then p:=true;
  if p=true then writeln('YES')else writeln('NO');
  readln;
end.

```

---


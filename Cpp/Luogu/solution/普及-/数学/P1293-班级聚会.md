# 班级聚会

## 题目描述

毕业25年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。

不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。


## 说明/提示

### 数据范围及约定

对于全部数据，保证城市数量 $ \le 150$，距离 $ \le 10000$，同学个数 $ \le 50$。

## 样例 #1

### 输入

```
7 9289 Vladivostok
5 8523 Chabarovsk
3 5184 Irkutsk
8 2213 Yalutorovsk
10 0 Moscow
```

### 输出

```
Yalutorovsk 112125
```

# 题解

## 作者：lz2018 (赞：34)

大佬的题解看着好晕，来一个简单的C++代码，至少目前最简单。   
看到这道题，第一印象就是结构体。                              
花费怎么算呢，以要计算的城市为中心，将所有城市减一遍取绝对值。  
如果比上个城市的花费小，替换。
代码如下：
```
#include<bits/stdc++.h>
using namespace std;
long long o=1,minn=10000000,m;
struct pa{
    long long s;
    long long j;
    string n;
    long long cost;
};
pa	p[10005];
int main()
{
    while(cin>>p[o].s>>p[o].j>>p[o].n)
        o++;
    for(int i=1;i<o;i++)
    {
        for(int g=1;g<o;g++)
            p[i].cost+=abs(p[i].j-p[g].j)*p[g].s;
        if(p[i].cost<=minn)
        {
            minn=p[i].cost;
            m=i;
        }
    }
    cout<<p[m].n<<" "<<p[m].cost<<endl;
    return 0;
} 
```

---

## 作者：秋雨 (赞：13)

sort最完美了！

加上struct更完美！

					—————一位C++编程手
第一步：

定义结构体，把什么人数、路程、钱（卢布）、城市名一股脑儿的全部给装进去；

第二步：

输入，没给N,就把输入作为循环条件用while循环（别忘了下标一定要++）；

第三步：

循环一~tot（下标），算要花多少卢布（挨个儿扫一遍，加上路程乘人数的积，一定要abs，除非你分开处理，不需判断同一个城市，同一个城市为路程为零，乘人数还得零）；

第四步：

sort排序，先看卢布一样不一样，不是就比较卢布；一样就比较路程（离莫斯科近）；

第五步：

输出排序后的a[0].name，a[0].lb（最少的钱、最短的路）

完成！

贴代码：
```
#include<bits/stdc++.h> 
using namespace std;
struct city{
	int men,km,lb;
	string name;
}a[150];
bool cmp(city a,city b){
	if(a.lb!=b.lb) return a.lb<b.lb;
	return a.km<b.km;
}
int money=1000000,tot,lb;
string n;
int main(){
	while(cin>>a[tot].men>>a[tot].km>>a[tot].name) tot++;
	for(int i=0;i<tot;i++){
		a[i].lb=0;
		for(int j=0;j<tot;j++){
			a[i].lb+=abs(a[j].km-a[i].km)*a[j].men;
		}
	}
	sort(a,a+tot,cmp);
	cout<<a[0].name<<' '<<a[0].lb;
}
```
求过

---

## 作者：herofox (赞：9)

首先将城市想象为数轴上的点，其中Moscow为原点，右为正方向。

我们在读入时就可以计算出如果在原点举行聚会的花费。

我们考虑将举行聚会的城市向右移动。

每移动一个城市，这个城市左侧的所有人的花费将增加移动的距离，而右侧的所有人的花费将减少移动的距离。

我们只要在读入时预处理一个前缀和，就可以在

$O(1)$的时间内进行每次移动的修改。

所以我们从原点开始向右进行，对每一个城市进行修改花费的操作，然后记录花费最小的城市。

时间复杂度为$O(n)$。

    
    
    
```cpp
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    const int N = 50000;
    int n, cost = 0;
    int people[N], dis[N], Suf[N], val[N], sum = 0, ans = 0;
    char name[200][200];
    int main()
    {
        int i = 1;
        while(scanf("%d%d%s", &people[i], &dis[i], name[i]) != EOF)
        {
            cost += people[i] * dis[i];
            Suf[i] = Suf[i - 1] + people[i];
            sum += people[i];
            ++i;
        }
        val[i] = cost;
        for(int j = i - 1;j >= 1;--j)
        {
            val[j] = val[j + 1] + abs(dis[j] - dis[j + 1]) * (sum - Suf[j]) - (abs(dis[j] - dis[j + 1]) * Suf[j]);
            if(val[j] < cost)
                cost = val[j], ans = j;
        }
        printf("%s %d\n", name[ans], cost);
        return 0;
}
```

---

## 作者：Donald_Ducka (赞：7)

## ~~热爱刷水题~~
### 这明明是一道暴力模拟，为啥子算法标签为~~数论~~
### 这本身就是一道为萌新而准备的题为啥大佬代码那么高深
### 我来发一篇详细的题解帮助各位萌新解答！


------------
# 思路：
#### 看到某些变量相互关联，且数据类型不同时
#### （当然数据类型一样时也可以用）
#### 我第一个想到的就是结构体
#### 有些小伙伴解决不掉输入，我会在下面代码中详解
#### 让我们愉快的读下下题——
#### 我们可以看到让输出的数仅仅是某些数运算的最小结果
#### 又看到数据范围
#### 直接确定——结构体加排序加暴力
#### ~~sort万岁，暴力万岁！~~
# 直接上代码，附带详细注释——


------------
```
#include<bits/stdc++.h>//我爱万能头
using namespace std;
struct node{
	int lu;//与莫斯科的距离
	int tong;//同学的个数（很形象吧）
	string s;//名字
	int zong;//以此地为聚会地点，各路同学门所花费的money
}a[100001];
//定义node 类型的数组
int n=0;//用与储存地点的个数
bool camp(node g,node h) // 自定义排序函数，后面sort会用到
{
 //属于结构体基本操作
	if(h.zong==g.zong)//如果两地运费相同，
   //则返回距离首都最近的那个地点
	{
		return g.lu<h.lu;
	}
	return g.zong<h.zong; //返回费用少的在前
   //以zong为条件的升序
}
int main()
{
	while(true)//开始解决读入问题
   //通过看题我们不难发现题中讲到：
   // ~~最后一个输入的是莫斯科的信息~~
   //也就是说，当输入的字符串为莫斯科时
   //或者输入的第二个变量为0时，就可以结束循环
	{
		++n;//下标从一开始
		cin>>a[n].tong>>a[n].lu>>a[n].s;//输入
		if(a[n].s=="Moscow") break;//判断是否为莫斯科
        //如果是就结束循环
	}
	for(int i=1;i<=n;i++)//开启暴力之路——150*150完全不超
  //外层循环为以第i个点为最终地点
	{
		for(int j=1;j<=n;j++)
    //内层枚举所有的地点到i地点
		{
			a[i].zong+=abs(a[j].lu-a[i].lu)*a[j].tong;
    //统计所有点到a[i]的钱
    //钱=j地点到i地点的距离 * 此地的人数 
    //因为为每人每千米花费1卢布，所以省略不乘
    //两地的距离=i点与j点到莫斯科的距离差的绝对值（大家可以画个图理解）
		}
	}
	sort(a+1,a+n+1,camp);//按照camp规则排序
	cout<<a[1].s<<" "<<a[1].zong;//输出最终答案
	return 0;//结束！
}
```


------------
管理员大大求过呀~~

---

## 作者：liujiayuan (赞：4)

    
    #include<iostream>
    #include<cstring>
    #include<cmath>
    using namespace std;
    struct node
    {
        int a,b;
        string s;
    };
    int main()
    {
        node na[10005];
        string end;
        long long num=0,ans=0xfffffff,n=0;
        while(cin>>na[n].a>>na[n].b>>na[n].s)
        {
            if(na[n].b==0)
            break;
            else
            n++;
        }
        for(int i=0;i<=n;i++)
        {
            num=0;
            for(int j=0;j<=n;j++)
            {
                num=num+(na[j].a*abs(na[j].b-na[i].b));
            }
            if(ans>=num)
            {
                ans=num;
                end=na[i].s;
            }
        }
        cout<<end<<" "<<ans<<endl;
        return 0;
    }

---

## 作者：EDqwq (赞：4)

[My blog](https://www.luogu.com.cn/blog/294562/)

这道题我看很多人说是暴力题，当然，**暴力非常可行**，**代码量也很少**。

只是，作为一名数学爱好者，我只想说：

### 你们不能侮辱我的最小消费问题！！！

~~我自己起的名字~~

对于这种题，有一个通用的方法：把每条路的长度都给算出来，然后从左和右开始，往相反方向数，并且加上当前路径的长度，哪个小哪个就先走。

~~I know it's hard to understand~~，但是我举个例子你们（可能）就懂了。

假设现在有四个城市，分别叫 A B C D E，我们设置A 到 B 的距离为 1，A 到 B 的距离为6，B 到 C 的距离为4，C 到 D 的距离为2，D 到 E 的距离为3。

我们现在分别从A 和 E 来数，A 向右数，E 向左数（相反方向）。A 数一格为6（A 到 B），E 数一格为 3 （E 到 D）。

我们判断，3 小于 6，所以我们现在只数右边，知道右边大于左边。现在右边为3，往左数一格是3 + 2 = 5，还是小于6，继续数。5 + 4 = 9，9 大于 6，虽然9 大于 6，但是我们不用左边数了，因为已经到同一点了（B 点）所以最终答案就是B 点。

可能我讲的很差，如果您没有听懂的话，您可以~~查看四年级奥数书~~，里面有详细的讲解。（上网搜当然也可以）

**所以说我们要做的就是把这道题转换成我的这道题目。题目中说是到 Moscow 的距离，我们就用一个数组把到Moscow的距离转换成每两个点之间的距离（直接减法）。然后两边同时向中间移动，知道左边点位置等于右边点位置即可。最后，再将最终答案用循环算出来即可**

代码我已经写出来了，但我无法处理人数这个问题（也就是无法完全将这道题转换成我的那道题），只是样例过了，并没有 AC ，请各位不要研究我的代码，请研究我的思路。

#### 蒟蒻的代码：
```
#include<bits/stdc++.h>

#define M 150

using namespace std;

struct node{
	int num;
	int dis;
	string name;
}a[M + 5];

int many;
int f[M + 5][M + 5];
int ans;
int ff[M + 5][M + 5];

int main(){
	for(int i = 1;;i ++){
		int numm;
		int diss;
		string namee;
		cin>>numm>>diss>>namee;
		a[i].num = numm;
		a[i].dis = diss;
		a[i].name = namee;
		if(diss == 0 && namee == "Moscow"){
			many = i;
			break;
		}
	}
	for(int i = 1;i <= many - 1;i ++)
		for(int j = 1;j <= many - i;j ++)
			if(a[j].dis > a[j + 1].dis){
				swap(a[j].dis,a[j + 1].dis);
				swap(a[j].num,a[j + 1].num);
				swap(a[j].name,a[j + 1].name);
			}
	//Moscow是第1站
	 for(int i = 1;i <= many - 1;i ++)f[i][i + 1] = a[i + 1].dis - a[i].dis,f[i + 1][i] = f[i][i + 1];
	 for(int i = 1;i <= many - 1;i ++)ff[i][i + 1] = f[i][i + 1] * (a[i].num + a[i + 1].num);
	 int left = f[1][2],num1 = 2;
	 int right = f[many - 1][many],num2 = many - 1;
	 while(1){
	 	if(left < right){
	 		left += f[num1][num1 + 1];
	 		num1 ++;
	 	}
	 	if(right < left){
	 		right += f[num2][num1 - 1];
	 		num2 --;
	 	}
	 	if(num1 == num2)break;
	 }
	 for(int i = 1;i <= many;i ++){
	 	if(i == num1)continue;
	 	int now = 0;
	 	if(i < num1){
	 		for(int j = i;j <= num1 - 1;j ++)now += f[j][j + 1];
	 	}
	 	else if(i > num1){
	 		for(int j = num1;j <= i - 1;j ++)now += f[j][j + 1];
	 	}
	 	ans += now * a[i].num;
	 }
	 cout<<a[num1].name<<" "<<ans;
	 return 0;
}
```


#### 注：如果有大佬改进我的代码后 AC 了，请加我qq 2251604066 或者洛谷私信告诉我您的思路或者代码，谢谢。

好了，本篇分享思路的题解到此结束了。

###### 这是我写过最长的题解，求管理大大给过（小声）

~~拜拜！~~

---

## 作者：ArachnidaKing (赞：3)

本题解和第二篇略像，但还是有较大不同的，同时更注重细节，该scanf/printf就用scanf/printf，该++前置绝不后置，养成细节好习惯从我做起！
本题第二测试点有个大啊啊bug！具体见代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

#define itn int//防本人手残（事实证明多处起作用） 
#define maxn 151//他们说这样快······
#define ll long long//宏long long（或许吧···）

struct city
{
	itn num;//人数 
	itn s;//距墨西哥（手残划掉）莫斯科的距离 
	string name;//城市名不用解释 
}cs[maxn];//最多150个城市，个人为方便就开151数组 

int i=1,j,n=0;
ll minn=0x7fffffff,money=0;
string minc;//目前最小城市名 

itn main()
{
	while(i)
	{
		++n;//本题不告知城市总数，手动记录城市数 
		scanf("%d%d",&cs[i].num,&cs[i].s);//输入第i个城市的数据 
		cin>>cs[i].name;//在这里请教各位神犇有没有输入string更好的办法QAQ 
		if(!cs[i].name.compare("Moscow"))//如果输入了莫斯科 
		{
			break;//就跳出循环 
		}
		++i;//像指针，每次后移一位 
	}
	for(i=1;i<=n;++i)//遍历终点城市 
	{
		for(j=1;j<=n;++j)//遍历起点城市 
		{
			if(cs[i].s>=cs[j].s)//别问我，用不了abs，我也不知道为啥QAQ有没有神犇讲解 
			{
				money+=(cs[i].s-cs[j].s)*cs[j].num;
			}
			else
			{
				money+=(cs[j].s-cs[i].s)*cs[j].num;
			}
		}
		if(money<=minn)//注意，一定是<=而非<！！题目应该注明“在有两个城市的花费相同时，选后输入的那个”，具体见第三篇讨论 
		{
			minc=cs[i].name;//这就是——最低成本城市名！ 
			minn=money;//这就是——最低成本！ 
		}
		money=0;//下一次遍历和变回0 
	}
	cout<<minc;//同上，请教路过神犇有没有输出string更好的办法QAQ 
	printf(" %lld",minn);//该输出输出不用解释了 
	return 0；//回溯一步（滑稽·^v·^）
}//已进行防抄袭处理^v^
```

---

## 作者：Soyilieber (赞：2)

来发一波中位数来求解的answer。

代码及注释如下：

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cmath>
using namespace std;
int n,mid;
long long a[301],dis[301],ans,sum,k;
string s[301];
int main(){
	while (1){
		n++;
		cin>>a[n]>>dis[n];//读入
		cin>>s[n];
		sum+=a[n];//累计人数总数
		if (s[n]=="Moscow") break;//读到Moscow退出循环
	}
	sum/=2;//总数div2
	for (mid=n;mid>=1;mid--){//求人数总数的中位数
		k+=a[mid];
		if (k>=sum){
			break;//找到中位数
		}
	}
	for (int i=1;i<=n;i++){
		ans+=a[i]*abs((dis[i]-dis[mid]));//人数*离中位城市的距离，要加上绝对值
	}
	cout<<s[mid];
	printf(" %lld\n",ans);//输出
	return 0;
}

```

---

## 作者：MaoHanKun (赞：1)

	#include<algorithm>//排序用。 
	#include<cstdio>//输入用。 
	#include<cstring>//strcpy用。 
	using namespace std;
	struct xx{
		int n,m,ans;//n为人数，m为距离，ans为各个城市到此城市的距离。 
		char z[20];//城市名称。 
	}s[152];
	char ss[]="Moscow";//判断用。 
	int k;//记录城市个数。 
	bool cmp(xx x,xx y){
		return x.m<y.m;
	}//按距离远近从小到大排序。 
	bool cmp1(xx x,xx y){
		if(x.ans==y.ans) return x.m<y.m;//第二的测试点的坑（离Moscow近的优先）。 
		return x.ans<y.ans;//将费用从小到大排序。 
	}
	int main(){
		while(~scanf("%d%d%s",&s[k].n,&s[k].m,s[k].z)){
			if(strcmp(ss,s[k++].z)==0) break;//strcpy判断两个字符串是否相同。 
		}
		sort(s,s+k,cmp);
		for(int i=0;i<k;++i){
			for(int j=0;j<i;++j) s[i].ans+=s[j].n*(s[i].m-s[j].m);//计算此城市之前到其的费用。 
			for(int j=i+1;j<k;++j) s[i].ans+=s[j].n*(s[j].m-s[i].m);//计算此城市之后到其的费用。
		}
		sort(s,s+k,cmp1);//按价格排序。 
		printf("%s %d",s[0].z,s[0].ans);//输出第一个值。 
		return 0;
	}//完美结束。 

---

## 作者：loi_hjh (赞：1)

本题的读入没有直接告诉城市数量，就要用奇奇怪怪的读入

附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
struct gg{
	int num,dis;//有几个人，距离本地有多远，名字 
	char name[1001]; 
}city[1001]; 
int l,cnt,money,ans=2147483647;//答案名字的长度，城市个数，每个城市花的钱，最少花费 
char ans2[1001];//答案的名字 
in void gg(int x){
	money=0;
	for(ri i=1;i<=cnt;i++)//枚举从其他城市到这个城市的钱数 
		money+=city[i].num*abs(city[x].dis-city[i].dis);//绝对值是因为有可能距离本地更远，也可能更近 
	if(money<=ans){//本来写的是<，75分，后来改成<=就过了，其实只是改了名字，钱没减少，也不知为啥，题目也没说钱数相同输出那个 
		ans=money; 
		l=strlen(city[x].name+1);//把答案的名字更新 
		memset(ans2,0,sizeof(ans2));
		for(ri i=1;i<=l;i++)
			ans2[i]=city[x].name[i];
	}
}
int main(){
	while(1){
		cnt++;
		scanf("%d%d%s",&city[cnt].num,&city[cnt].dis,city[cnt].name+1);
		if(!city[cnt].dis) break;//这个读入很神奇，距离本地是0时读入结束 
	}
	for(ri i=1;i<=cnt;i++)//枚举每个点 
		gg(i); 
	printf("%s",ans2+1);//输出答案 
	putchar(' ');
	printf("%d",ans);
	return ~~(0-0);
}

```

---


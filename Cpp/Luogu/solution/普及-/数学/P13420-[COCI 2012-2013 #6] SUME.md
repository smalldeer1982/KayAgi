# [COCI 2012/2013 #6] SUME

## 题目描述

很久很久以前，存在一个长度为 $N$ 的正整数序列 $A$。你并不知道这个序列的具体内容，但你知道该序列任意两个元素之和的值。请你求出序列 $A$！


## 说明/提示

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
2
0 2
2 0```

### 输出

```
1 1```

## 样例 #2

### 输入

```
4
0 3 6 7
3 0 5 6
6 5 0 9
7 6 9 0```

### 输出

```
2 1 4 5```

# 题解

## 作者：封禁用户 (赞：2)

# [P13420 [COCI 2012/2013 #6] SUME](https://www.luogu.com.cn/problem/P13420)
## 题目介绍：

给定一个 $n \times n$ 的矩阵 $s$，其中：

1. 对角线元素 $s[i][i] = 0$（$1 \leq i \leq n$）。
2. 非对角线元素 $s[i][j] = a[i] + a[j]$（$i \neq j$）。

要求根据这个矩阵还原出原始的正整数序列 $a$。

## 分析做法：

主要步骤：

1. 处理 $n = 2$ 的特殊情况。
2. 对于 $n \geq 3$：先计算 $a[1] = (s[1][2] + s[1][3] - s[2][3]) / 2$，再计算其他 $a[i] = s[1][i] - a[1]$。

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n;
	cin >> n;
    int s[1001][1001];
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
	        cin >> s[i][j];
	    }
	}
	int a[1001];
	if (n == 2) {
	    a[1] = 1;
	    a[2] = s[1][2] - a[1];
	} else {
	    a[1] = (s[1][2] + s[1][3] - s[2][3]) / 2;
	    for (int i = 2; i <= n; ++i) {
	        a[i] = s[1][i] - a[1];
	    }
	} 
	for (int i = 1; i <= n; ++i) {
	    cout << a[i] << " ";
	}
	cout << endl;
	return 0;
}
```

谢谢观看，求过求赞。

---

## 作者：DemonPlayer (赞：2)

### 思路：
  本题的难点在于如何求出 $a_1$，可以参考前缀和的思想，通过和的加减求出，显然 $[S(1,2)+S(1,3)-S(2,3)]\div 2$ 就可以，因为如果将这个式子展开 $(a_1+a_2+a_1+a_3-a_2-a_3)\div 2$，既然求出了 $a_1$，就能使用 $S(1,i)-a_1$ 求出 $a_i$ 了。 
### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;

int sum[maxn][maxn];
int a[maxn],n,a1;

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&sum[i][j]);
		}
	}
	if(n==2){
		cout<<sum[1][2]/2<<' '<<sum[1][2]/2;
	}else{
		a1=(sum[1][2]+sum[1][3]-sum[2][3])/2;
		cout<<a1;
		for (int i=2;i<=n;i++){
			cout<<' '<<sum[1][i]-a1;
		}
	}
	return 0;
}
```

---

## 作者：b__b (赞：1)

没有看起来那么难，是个水题。

我们先考虑 $N \geq 3$ 的情况。

我们有：
$$
S(1,2)=A_1+A_2 \\
S(1,3)=A_1+A_3 \\
S(2,3)=A_2+A_3
$$

于是，
$$
\begin{aligned}
\frac{S(1,2)+S(1,3)+S(2,3)}{2}&=\frac{A_1+A_2+A_1+A_3-(A_2+A_3)}{2}\\
&=\frac{2 \times A_1}{2} \\
&=A_1
\end{aligned}
$$

这样，我们就只用三个式子推出来了 $A_1$。

同理，对于 $A_i$，我们选取另外两个正整数 $j,k$，使得三个数两两不等，于是：
$$
S(i,j)=A_i+A_j \\
S(i,k)=A_i+A_k \\
S(j,k)=A_j+A_k \\
\begin{aligned}
\frac{S(i,j)+S(i,k)+S(j,k)}{2}&=\frac{A_i+A_j+A_i+A_k-(A_j+A_k)}{2}\\
&=\frac{2 \times A_i}{2} \\
&=A_i
\end{aligned}
$$

当 $N=2$ 时，我们无法选择另外两个正整数。但是：
> 保证对于任意输入数据，都存在且仅存在一个满足条件的正整数序列 $A$。

如果 $A$ 序列中有数字大于 $1$，那么我们交换两个数字后得到的表 $S$ 不变，同时可以产生一个新的 $A$ 序列，这与题目矛盾，因此 $A$ 序列只有可能是 $1,1$。

具体实现可看下面代码：
```cpp
#include <cstdio>
int s[1005][1005];
int main() {
    int n;
    scanf("%d", &n);
    if (n == 2) {puts("1 1"); return 0;}
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) scanf("%d", &s[i][j]);
    for (int i = 0; i < n; ++i) {
        int othera, otherb;
        if (i) {
            othera = 0;
            if (i == 1) otherb = 2;
            else otherb = 1;
        } else othera = 1, otherb = 2;
        printf("%d ", (s[i][othera] + s[i][otherb] - s[othera][otherb]) / 2);
    }
}
```
时间复杂度：处理中的循环只需要循环 $N$ 次，时间复杂度为 $O(N)$，如果考虑到输入那么时间复杂度为 $O(N^2)$。

空间复杂度：需要一个二维数组存储 $S$，空间复杂度为 $O(N^2)$。

---

## 作者：Doraeman (赞：1)

第二道~~灰~~题题解！  
上一道我写的时候是灰，已经评红了。  
[我在题解中预言成功！（题号：P13419 [COCI 2012/2013 #6] BAKA）](https://www.luogu.com.cn/article/j4iupi6d)。  
这一道大概率橙题。

## 表达式
题目已经明确给出：当 $i\not=j$ 时，$S(i,j)=A_i+A_j$。

根据这个式子，我们就可以推导出正确答案。

## 详细分析
### 数学示例
首先抛开编写代码不谈，如果现在这里有 $4$ 个正整数 $A_1,\dots,A_4$ 满足以下表格中的内容，你能用数学知识将它们分别求出来吗？   
|$S(i,j)=A_i+A_j$|$j=1$|$j=2$|$j=3$|$j=4$|
|:-:|:-:|:-:|:-:|:-:|
|$i=1$|$\$|$3$|$6$|$7$|
|$i=2$|$3$|$\$|$5$|$6$|
|$i=3$|$6$|$5$|$\$|$9$|
|$i=4$|$7$|$6$|$9$|$\$|

此处比较考验数学。例如，如果我们想求 $A_1$ 的值。  
$$
\because\begin{cases}
S(1,2)=A_1+A_2=3\\
S(1,3)=A_1+A_3=6\\
S(2,3)=A_2+A_3=5\\
\end{cases}
$$
$$
\therefore A_1=\big(S(1,2)+S(1,3)-S(2,3)\big)\div2
$$
上式中所有数都是已知的，所以可以求得 $A_1=(3+6-5)\div2=4$。

### 推广
除了上面的式子可以表示 $A_1$ 的值，还有没有别的式子呢？

其实思考可以发现，上式中 $A_2,A_3$ 并不是必须的值。  
所以，我们还可以得到以下式子。  
$$
A_1=\big(S(1,2)+S(1,3)-S(2,3)\big)\div2\\
\ \ \ \ \ \ =\big(S(1,2)+S(1,4)-S(2,4)\big)\div2\\
\ \ \ \ \ \ =\big(S(1,3)+S(1,4)-S(3,4)\big)\div2
$$

同时，以上这些所有的值都是已知的（题目已给出）。

综上，我们就得到了公式（设有 $N$ 个数）：第 $i$ 个元素（$1\leq i\leq N$）$A_i$ 的表示方式如下。  
$$
A_i=\big(S(i,j_1)+S(i,j_2)-S(j_1,j_2)\big)\div2
$$
其中 $j_1,j_2$ 满足 $1\leq j_1\leq N,1\leq j_2\leq N,j_1\not=j_2\not=i$。  
同理，以上这些数也都是已知的，无需另外推导。

## 公式应用到代码中
首先输入所有的 $S(i,j)$ 并保存。

接下来，循环 $N$ 次，每次都有一个 $i$，**任意找两个数 $j_1,j_2$ 满足 $1\leq j_1\leq N,1\leq j_2\leq N,j_1\not=j_2\not=i$ 这个条件，就可以得到 $A_i$ 的值了。**

最后输出 $A_i$ 的值。

## 彩蛋：技巧
我在找 $j_1,j_2$ 时，为了使其满足条件，设  
$$
\begin{cases}
j_1=i-1\\
j_2=i+1
\end{cases}
$$
此时，对于 $1<i<N$ 的情况，$j_1,j_2$ 都可以满足条件。但当 $i=1$ 时，$j_1=0$，此时可以特殊处理。  
同理，$i=N$ 时，$j_2=N+1$，也可以特殊处理。

## 特判
行百里者半九十。

最后还有一个很重要的点：如果 $N=2$，你无法找到 $2$ 个 $j_1,j_2$ 满足条件（参考自测样例 $1$）。

然而，**题目保证唯一解**。当 $N=2$ 时，为了保证唯一解，必须有 $S(1,2)=(2,1)=2$，此时解得 $A_1=A_2=1$，故**直接输出** ```1 1```。

其实我不确定是否有这个测试点，但最好还是加上。

## 代码
```cpp
// a[i]=(S(i,j1)+S(i,j2)-S(j1,j2))/2

#include<bits/stdc++.h>
using namespace std;
const int N = 1e3+5;

int n, s[N][N];

int main(){
    cin >> n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            cin >> s[i][j];

    // 特殊处理 
    if(n == 2){
        cout << "1 1";
        return 0;
    }

    // 此时 n≥3
    for(int i=1; i<=n; i++){
        int j1 = i-1, j2 = i+1;
        if(i == 1) j1 = i+2;
        if(i == n) j2 = i-2;
        int x = (s[i][j1]+s[i][j2]-s[j1][j2])/2;
        cout << x << ' ';
    }
}
```

---

## 作者：bayiran (赞：1)

水题，建议评红。

## 思路
在下表中，定义 $S_{i,j}$ 代表题中 $A_i$ 与 $A_j$ 的和。由于矩阵关于主对角线（左上到右下）对称（加法交换律），所以我只画一半。



|X|$S_{0,1}$|$S_{0,2}$|$S_{0,3}$|$S_{0,4}$|
|-|-|-|-|-|
||**X**|$S_{1,2}$|$S_{1,3}$|$S_{1,4}$|
|||**X**|$S_{2,3}$|$S_{2,4}$|
||||**X**|$S_{3,4}$|
|||||**X**|

我们发现，第一行的数都是 $A_0$ 加上一个数而得来的，故只要求出 $A_0$ 的值就可以了。

怎么求 $A_0$ 呢？可以通过添项来解决。

$$
\begin{aligned}

  2A_0 &= A_0 + A_0 + A_1 + A_2 - A_1 - A_2
  
\\
  &= (A_0+A_1) + (A_0+A_2) - (A_1+A_2)
\\
  &= S_{0,1} + S_{0,2} + S_{1,2}
\end{aligned}
$$

所以 $A_0 = \frac{S_{0,1} + S_{0,2} + S_{1,2}}{2}$。

求出 $A_0$ 后，用第一行的数每个减去 $A_0$ 可以得到数列剩余的项。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin>>n;
    int s[1500][1500];
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            cin>>s[i][j];
        }
    }
    int a[1500];
    a[0] = (s[0][1] + s[0][2] - s[1][2]) / 2;
    for(int i=1;i<n;i++){
        a[i] = s[0][i] - a[0];
    }
    for(int i=0;i<n;i++){
        cout<<a[i]<<" ";
    }
    return 0;
}

```

---

## 作者：wuyouawa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13420)

### 思路

数学题。

首先，我们要想知道每一个数，就得求总和。

然后我们很容易发现每一个数在二维数组 $s$ 中恰好都出现 $2n-2$ 次，于是我们求出二维数组中所有数的和，再用它除以 $2n-2$，便求出序列和。

接着我们像如何求 $a_1$。其实也很简单，可以先把 $s$ 的第一行的数全加起来，这样算出来化简一下就是 $n-2$ 个 $a_1$ 加序列和。我们用刚刚算出的和减之前算出的和，就是 $n-2$ 个 $a_1$。

那么 $a_1$ 就可以求出来了。最后用 $s_{1,2}-a_2$ 就可以求 $a_2$，那以此类推，序列的其它数也都可以求了。

注意特判 $n=2$。
### 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1005][1005],s,b[1005],s2;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%lld",&a[i][j]);
			s+=a[i][j];
		}
	}
	s=s/(n-1)/2;
	for(int i=1;i<=n;i++)
	{
		s2+=a[1][i];
	}
	if(n==2)  b[1]=s2/2;
	else  b[1]=(s2-s)/(n-2);
	cout<<b[1]<<" ";
	for(int i=2;i<=n;i++)
	{
		b[i]=a[1][i]-b[1];
		cout<<b[i]<<" ";
	}
	return 0;
}
```

---

## 作者：xxJoy0420 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13420)
### 思路
第一眼：这不就是大水题吗！！！  
首先，我们要求出序列 $A$ 的元素和。  
想了想，推出了以下式子：$A$ 的序列和=表 $S$ 全部元素的总和 $\div (2N-2) $。因为，根据表 $S$ 可以推出表 $S$ 第 $i$ 行的和为
$$
  a_i \times (N-2) +\sum_{i = 1}^{n} A_i
$$
这样，$N$ 行的和即为  
$$
  \sum_{i = 1}^{n} A_i \times N +\sum_{i = 1}^{n} A_i \times (N-2)
$$
元素和搞定了，接下来就要求序列 $A$ 了。  
根据上面的式子，很容易推出 $a_i$ 等于表 $S$ 的第 $i$ 行的和减去序列 $A$ 的元素和再除以 $(2N-2)$ 。  
说到这里，就不给代码啦。（~~反正已经讲得很简单了~~）   
**注意：要特判 $N=2$ 的情况！**  
第一次写，写得不好请见谅，我会尽力改正的。

---

## 作者：Chenxuhang_play (赞：0)

## 前言
记 $a$ 为输入的矩阵，$a_{i,j}$ 表示数组中第 $i$ 行，第 $j$ 列的值，$A$ 表示题目中最终需要输出的数，$A_i$ 表示这些数中的第 $i$ 个。

**注意**：在这篇题解中下标从 $0$ 开始到 $n-1$。

## 思路

可以发现在整个数组中有两个行、列可以作为突破口。

它们是第 $0$ 行（即对于所有的 $a_{0,i}$，其中 $i\in[0,n-1]$）和第 $n-1$ 列（即对于左右的 $a_{i,n-1}$，其中 $i\in[0,n-1]$）。
  
根据题意，可以得到如下信息（其中 $i\in[0,n-1]$）。
$$
a_{0,i}=A_0+A_i\\
a_{i,n-1}=A_i+A_{n-1}
$$

如果我们把 $a_{0,i}$ 与 $a_{i,n-1}$ 相减就可以得到一个惊人的事实（其中 $i\in[0,n-1]$）。

$$
a_{i,n-1}-a_{0,i}=(A_i+A_{n-1})-(A_0+A_i)=A_{n-1}-A_0
$$

$a_{i,n-1}$ 和 $a_{0,i}$ 是已知的，由上面的式子能够求出 $A_{n-1}-A_0$（可以证明，这里无论 $i$ 取多少，$A_{n-1}-A_0$ 的值总是固定的）。根据题意，$a_{0,n-1}=A_0+A_{n-1}$。我们都知道，对于两个实数 $x,y$ 能够知道 $x+y$ 和 $x-y$，就能分别求出 $x$ 和 $y$，公式是 $x=\frac{(x+y)+(x-y)}{2}$。这里我们求出了 $A_{n-1}-A_0$ 和 $A_0+A_{n-1}$。所以可以求出 $A_0$。

求出 $A_0$ 之后，只需要将所有的 $a_{0,i}$ 减去 $A_0$ 即可求出所有的 $A_{i+1}$（其中 $i\in[1,n-1]$）。

## 代码

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n;
	cin>>n;
	long long a[n][n],a1[n],a2[n];
	if(n==2)
	{
		cout<<"1 1";
		return 0;
	}
	for(long long i=0;i<n;i++)
	{
		for(long long j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(long long i=0;i<n;i++)
	{
		a1[i]=a[0][i];
	}
	a1[0]=(a[0][n-1]-(a[1][n-1]-a[0][1]))/2;
	for(long long i=1;i<n;i++)
	{
		a1[i]=a1[i]-a1[0];
	}
	for(long long i=0;i<n;i++)
	{
		cout<<a1[i]<<" ";
	}
	return 0;
}
```

---

## 作者：xtzhangziche (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13420)

## 思路
我们可以先求出 $A_1$，因为 $S$ 数组的第一行都跟 $A_1$ 有关。

```cpp
t=(s[1][2]+s[1][3]-s[2][3])/2;
```

然后输出 $A_1$，再输出 $A_2$ 到 $A_n$（$A_i \gets S_{1,i}-A_1$）。

```cpp
cout<<t<<' ';
for(int i=2;i<=n;i++)
    cout<<s[1][i]-t<<" ";
```
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s[1005][1005],a[1005],t;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>s[i][j];
    t=(s[1][2]+s[1][3]-s[2][3])/2;
    cout<<t<<' ';
    for(int i=2;i<=n;i++)
        cout<<s[1][i]-t<<" ";
    return 0;
}
```

---


# 又是毕业季I

## 题目背景

“叮铃铃铃”，随着高考最后一科结考铃声的敲响，三年青春时光顿时凝固于此刻。毕业的欣喜怎敌那离别的不舍，憧憬着未来仍毋忘逝去的歌。$1000$ 多个日夜的欢笑和泪水，全凝聚在毕业晚会上，相信，这一定是一生最难忘的时刻！

## 题目描述

为了把毕业晚会办得更好，老师想要挑出默契程度最大的 $k$ 个人参与毕业晚会彩排。可是如何挑呢？老师列出全班同学的号数 $1,2,\ldots ,n$ 并且相信 $k$ 个人的默契程度便是他们的最大公约数（这不是迷信哦~）。这可难为了他，请你帮帮忙吧！

PS：一个数的最大公约数即本身。

## 说明/提示

对于 $20\%$ 的数据，$k \le 2$，$n \le 10^3$。

对于另 $30\%$ 的数据，$k \le 10$，$n \le 100$。

对于 $100\%$ 的数据，$k \le 10^9$，$n \le 10^9$，$n \ge k \ge 1$（神犇学校，人数众多）。

## 样例 #1

### 输入

```
4 2
```

### 输出

```
2
```

# 题解

## 作者：封禁用户 (赞：529)

此题简化后，求的是：从1~n中取k个数，使这k个数的最大公约数最大

因为两个数成倍数关系时，它们的最大公因数是两数中的较小数，也就是相对来说最大公因数较大

返回题目，这k个数其实就是：x\*1,x\*2......x\*k，及x的1~k倍，但必须保证x\*k小于n，在上述条件下，能知道，符合条件的最大的x就是答案，为了找出最大的x，必须使x\*k尽量接近n，因为c++的整数除法有自动取整的功能，所以所有情况下，n/k都是最终答案

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,k;
int main()
{
    cin>>n>>k;
    cout<<n/k;
    return 0;
}
```

---

## 作者：kkksc03 (赞：331)

By lzn
数论水题一道。

首先，若可能的最大公约数为a，取出的k个数为X1，X2，……，Xk且满足X1<X2<……<Xk，那么有X1>=a，X2>=2a，……，Xk>=ka。又∵Xk<=n，∴n>=ka，∴a<=n/k，又∵a为整数，∴a<=[n/k]（[]为取整符号）。

另一方面，我们取[n/k]，2\*[n/k]，……，k\*[n/k]，它们的最大公约数a=[n/k]，且它们都小于等于n大于等于1，且互不相等，满足条件。

∴答案即为[n/k]。

算法复杂度o(1)


---

## 作者：war1111 (赞：57)

二分查找

n/k真的没有想到唉

我找的最大公约数，如果当前的mid对应的个数比k大，就往大了找，否则往小里找，

对于边界问题，要加一些特判。



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
bool p(int x)
{
    int i;
    for(i=0;i<=n&&i*x<=n;i++){
    }
    if(i-1>=k)
    return true;
    return false;
}
int main()
{
  cin>>n>>k;
  if(n==k)
  {
      cout<<1;
      return 0;
  }
  int l=1,r=n,mid;
  while(l<r)
  {
    mid=(l+r)>>1;
    if(p(mid))
    l=mid+1;
    else
    r=mid;    
  }
  if(k==1)
  cout<<n;
  else
  cout<<max(l-1,1);
  return 0;
}

```

---

## 作者：康师傅 (赞：28)

## ~~数论不好真是急死人~~
### 这题用二分可以~~暴力~~解决！！
如果要找$k$个数的最小公约数，且这几个数可以表示成：$a×1$，$a×2$，$a×3$，$a×4$……$a×k$的话，很显然$a(a>=1)$就是他们的最小公约数。  
这样为什么这样找到的就是最大的呢？如果这些数字中间出现有了互质的数字，那么由质数的性质我们可以知道，两个质数的最大公约数为$1$，所以说不一定符合题意。 

那么接下来就是找这个数字了，先找到中间的数字$mid$，用$mid×k$与$n$进行比较，如果比$n$大，就说明我们找的中间这个数字太大了，于是我们将右边界移动到$mid-1$(为什么不移动到$mid$呢？因为$mid*k$比要找的数字大呀，直接放弃就$OK$了。),否则就移动左边界到$mid$,注意退出条件 $l+1<r$ ，为什么不是 $l<mid$ 呢？因为若 $l=3,r=4,mid=3$ 此时符合条件，接下来就有 $l=mid=3$ ,于是就进入了死循环！！！  
怎么保证找出的数字最大呢？只需要最后特判一下 $(l+1)*k$ 与$n$的关系，如果小于$n$,那么答案就是$l+1$,否则就是 $l$。  
### 贴代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,n,k,mid;
long long js(int l,int r){
	while(l+1<r){
		mid=l+(r-l>>1);//先减后加防溢出 
		if(mid*k>n)	r=mid-1;
		else l=mid;
	}
	return l;
}
int main(){
	cin>>n>>k;
	x=js(1,n);
	if((x+1)*k<=n)	cout<<x+1;
	else cout<<x;
	return 0;
}
```   
### 于是我们再想一想！！！
我们要找的中间数字要满足什么规律？？？  
$$mid*k<=n$$
变一下形：  
$$mid <= n/k$$  
 ## ！！！自闭了！！！
所以正解就是：   
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main(){
	cin>>n>>k;
	cout<<n/k;
	return 0;
}
```


---

## 作者：夜刀神十香ღ (赞：23)

首先，对于这个问题，我们可以想到一种一定可行的设m=n/k，则必有不等的k个数使得第i个数ai=i\*m<=n，且这k个数的最大公约数为m。

以下证明这个解为最优解（m为任取k个数中最大的最大公约数）：

假设存在另一个解p>m，依题意，p为所取不等的k个数的最大公约数，则第j个数bj=cj\*p，{c}为元素个数为k的集合且其中每个元素都为正整数。由于cj≠0，所以{c}中最大的元素cmax一定大于等于k。若cmax>=k，则cmax\*p>k\*m>n，显然不合题意。

故不存在另一个更优解p>m。

所以答案为(n/k);

代码还要给吗……

```cpp
#include<cstdio>
int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    printf("%d",n/k);
    return 0;
}
```

---

## 作者：用户已注销 (赞：9)


一眼望去就是[N/K]啊

所以代码超过三行就显得不够优秀了啊

所以我的代码就三行啊

```cpp
#include <cstdio>
inline int R(){int A;scanf("%d",&A);return A;}
int main(){return not printf("%d\n",R()/R());}
```

这样不久优秀了啊

---

## 作者：蒟蒻CGZ (赞：7)

## 分析题意

这道题取了一个如此销魂的题目，又有如此~~宏大的~~背景，逼逼了这么多，说到底就是这样：

在1~n这n个数中，选出k个，使得这k个数的最大公约数最大（也就是题目中说的“默契值”，下文我们称其为x）。~~我提炼得是不是很牛逼？~~

## 思路解析

这道题，我原先是这么想的：

枚举！暴力枚举所有的k个数！

这当然是不行的。（你让电脑连续运行k个循环来枚举每个数，电脑同意，题目的时间限制也不同意啊QWQ）

------------

**正确思路：**

首先我们要明确一点：**确定了x和k，就能肯定所有数的最小值（额，有点拗口，看实例）比如——x=3，则a1=3,a2=6,a3=9……直到ak=3k。**

其中k是手动输入，我们不用管他，就当它是确定的好了。

那么，我们何必再去枚举那k个数呢？——直接枚举x不就行了？~~哈哈，我真是个天才~~

明确了这点，我们再来想一想，x是多大都行吗？当然不是了！我们首先要满足k*x <= n，那么这时候的x才符合题目中的条件。换句话说，x的最大值就等于——

划重点！划重点！

```cpp
x=floor(n/k);
```

理解了这个，怎么做就不用我多说了吧？
## AC代码

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
int k,n;
int main(){
  cin>>n>>k;
  cout<<n/k<<endl;//输出的时候，系统会自动向下取整。
  return 0;
}
```

~~cgz出品，必是精品。~~

---

## 作者：ljc20020730 (赞：7)

设可能的最大公约数为a，取出的k个数为X1，X2，……，Xk且满足X1<X2<……<Xk，那么有X1>=a，X2>=2a，……，Xk>=ka。

又∵Xk<=n，∴n>=ka，∴a<=n/k，又∵a为整数，∴a<=[n/k]（[]为取整符号）。

另一方面，我们取[n/k]，2\*[n/k]，……，k\*[n/k]，它们的最大公约数a=[n/k]，且它们都小于等于n大于等于1，且互不相等，满足条件。

∴答案即为[n/k]。

所以，哼哼……

这种题还出20个点……

```cpp
var
a,b:longint;
begin
 readln(a,b);
 writeln(a div b);
end.
```

---

## 作者：Ophelia (赞：6)

这题我们用一种新的方法来进行讲解

此题简化后就是：从1~n中取k个数，使这k个数的最大公约数最大

那么，我们索取的k个数之间应该具有某种倍数关系。

那么，如果我们把整个区间分成多个段，这些段的长度相同。这样就可以让它们的最大公约数尽量大。

因为，如果只有两个数，它们的最大公约数如果想要最大，那么只有在它们的差最接近最小的数的情况下最大公约数是最大的。一个数的最大公约数就是它本身，那么两个数的最大公约数就是它们两个数的最小值。

我们把n个数看做一个区间

如果k为2，那么只有两个数。这两个数应该为这个区间的中点和末尾。

如果k=3，那么要把区间分成三份。这三个数就是区间的1/3、2/3、末尾。

那么如果有k个数，就要把区间划分成k份。这k个数就是区间的1/k、2/k、3/k······n。

那么它们的最大公约数就是这些数的最大公约数。而k个数的最大公约数在它们具有倍数关系的情况下就是它们的最小值。也就是这些区间端点的最小的一个。那就是n/k。

---

## 作者：YZL11111 (赞：5)

题目链接：https://www.luogu.org/problem/P1372

## 【题目描述】
为了把毕业晚会办得更好，老师想要挑出默契程度最大的k个人参与毕业晚会彩排。可是如何挑呢？老师列出全班同学的号数1，2，……，n，并且相信k个人的默契程度便是他们的最大公约数（这不是迷信哦~）。这可难为了他，请你帮帮忙吧！

PS：一个数的最大公约数即本身。

## 【输入格式】
两个空格分开的正整数n和k。（n>=k>=1）

## 【输出格式】
一个整数，为最大的默契值。

## 【解题思路】

![](https://cdn.luogu.com.cn/upload/image_hosting/vajcgv45.png)

## 【AC代码】
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
int main()
{
	int n, k;
	scanf("%d%d", &n, &k);
	printf("%d\n", n / k);
	return 0;
}
```


---

## 作者：Genius (赞：3)

By lzn
数论水题一道。

首先，若可能的最大公约数为a，取出的k个数为X1，X2，……，Xk且满足X1<X2<……<Xk，那么有X1>=a，X2>=2a，……，Xk>=ka。又∵Xk<=n，∴n>=ka，∴a<=n/k，又∵a为整数，∴a<=[n/k]（[]为取整符号）。

另一方面，我们取[n/k]，2\*[n/k]，……，k\*[n/k]，它们的最大公约数a=[n/k]，且它们都小于等于n大于等于1，且互不相等，满足条件。

∴答案即为[n/k]。

算法复杂度o(1)



<hr>
Genius @ 2014\12\12 17:16

补充标程：

```cpp

#include <cstdio>

int main()
{
     int n,k;
     scanf("%d%d",&n,&k);
     printf("%d\n",n/k);
    return 0;
}


```

---

## 作者：zhutier (赞：2)

看完题解觉得自己想复杂了。。。

好像也没想多复杂但是代码很复杂？？

不过感觉这样很好理解呀23333

①两个相邻的数的最大公因数是1

所以k>n/2时 存在相邻的数 答案为1

②k<=n/2时

最终得到的是一个等差数列

答案就是等差数列的差

同时也是等差数列最小项的值

```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
int n,k;
int main(){
	scanf("%d%d",&n,&k);
	if(k>n/2){
		printf("1\n");
		return 0;
	}
	else{
		for(int i=n;i>=1;i--)
			if(i%k==0){
				printf("%d\n",i/k);
				break;
			}
	}
	return 0;
} 
```

---

## 作者：DEVILK (赞：2)

这种数论题最重要的就是打表找规律QwQ

对于给定范围的n以及k（1 <= k <= n）
通过暴力搜索得到解再输出到屏幕（或文件）里.

打表程序：
```cpp
#include<bits\stdc++.h>
using namespace std;

int a[1001], ans = 1;
bool used[1001];
int gcd(int a, int b) { return b ? gcd(b, a%b) : a; }

int work(int num) {
	int ans = a[1];
	for(int i = 2; i <= num; i++) ans = gcd(ans, a[i]);
	return ans;
}
void dfs(int t, int n, int k) {
	if(t == k + 1) {
		ans = max(ans, work(k));
		return;
	}
	for(int i = 1; i <= n; i++) {
		if(!used[i]) {
			a[t] = i;
			used[i] = 1;
			dfs(t + 1, n, k);
			a[t] = used[i] = 0;
		}
	}
}
int main() {
	for(int n = 1; n <= 100; n++) {
		printf("------n = %d------\n", n);
		for(int k = 1; k <= n; k++) {
			printf("k = %d: ", k);
			ans = 1;
			dfs(1, n, k);
			printf("%d \n", ans);
		}
		puts("");
	}
}
```
------n = 1------

k = 1: 1

------n = 2------

k = 1: 2
k = 2: 1

------n = 3------

k = 1: 3
k = 2: 1
k = 3: 1

------n = 4------

k = 1: 4
k = 2: 2
k = 3: 1
k = 4: 1

------n = 5------

k = 1: 5
k = 2: 2
k = 3: 1
k = 4: 1
k = 5: 1

------n = 6------

k = 1: 6
k = 2: 3
k = 3: 2
k = 4: 1
k = 5: 1
k = 6: 1

------n = 7------

k = 1: 7
k = 2: 3
k = 3: 2
k = 4: 1
k = 5: 1
k = 6: 1
k = 7: 1

------n = 8------

k = 1: 8
k = 2: 4
k = 3: 2
k = 4: 2
k = 5: 1
k = 6: 1
k = 7: 1
k = 8: 1

------n = 9------

k = 1: 9
k = 2: 4
k = 3: 3
k = 4: 2
k = 5: 1
k = 6: 1
k = 7: 1
k = 8: 1
k = 9: 1

------n = 10------

k = 1: 10
k = 2: 5
k = 3: 3
k = 4: 2
k = 5: 2
k = 6: 1
k = 7: 1
k = 8: 1
k = 9: 1
k = 10: 1
不难发现答案就是[n / k]

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n, k;
int read();

int main() {
	n = read();
	k = read();
	printf("%d\n", n / k);
}

int read() {
	int x = 0, flag = 1;
	char ch = getchar();
	if(ch < 0) flag = false;
	while(ch < '0' || ch >'9') ch = getchar();
	for(; ch >= '0' && ch <= '9'; ch = getchar())
		x = x * 10 + ch - '0';
	return flag ? x : -x;
}
```

---

## 作者：HPXXZYY (赞：1)

我们首先来看本题的代码。

$[code]$:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k;
int main(){
	scanf("%d%d",&n,&k);
	printf("%d",n/k);
	return 0;
}
```
很好理解，但为什么呢？

首先，我们看看$gcd(a,b)$（设$a>b$）的取值范围：

$1$、当$a=kb$时($k$为整数，且$1 \leq k$，下同），则$gcd(a,b)=b$

$2$、当$a\neq kb$,则$gcd(a,b) < b$

所以，我们发现这$m$个数为$x,x \times 2,x \times 3...x \times m$时其最大公约数最大

所以，我们要让$x$最大且$x \times m \leq n$，所以$x$最大为$n / m$，所以代码如上。

---

## 作者：TJQ队长 (赞：1)

P1372 又是毕业季I

我们设最大公约数为x，则选出的k个人的编号分别为1*x，2*x，3*x，……，k*x

而k*x<=n 2333333

故x=n div k 2333333

就这样奇迹般地求出了答案就是_n div k_

呃，水题……不愧是入门难度的……

~~哦，好吧，说真的，我都想吼一声了：这么简单的题加那么多文字描述你们不累我们累啊~~

好了，废话不多说 , 上代码：

------------（我是华丽的分割线）
------------
```
var 
    a,b:longint;
begin
read(a,b);
writeln(a div b);
end.
```





---

## 作者：基建160282 (赞：1)

~~这道题就是一垃圾~~

思路不用多说了吧，人数肯定等于 $ceil(n / k)$
考虑到这题这么水却是普及-难度，我心想这其中一定有诈，所以我想来想去——只有可能在数据上做文章了
保险起见，我写了一个$gaojingdu$

话不多说，代码
```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>
# include "cmath"
# include <bits/stdc++.h>
# define FOR(i, a, b) for (int i = a; i <= b; ++i)
# define _FOR(i, a, b) for (int i = a; i >= b; --i)

using namespace std;
//这里说明一下，为了防止狡猾的(呸)出题人在数据上做文章，所以要写高精度，另外，友情提供高精度模板
struct BigInt {
    static const int M = 12000;
    static char str[M];
    int num[M];
    BigInt()
    {
        memset(num, 0, sizeof(num));
        num[0] = 1;
        isf=false;
    }

    void read()
    {
    	//使用快速读入
        scanf("%s", str);
        num[0] = strlen(str);
        FOR(i, 1, num[0])
            num[i] = str[num[0] - i] - '0';
    }

    void print()
    {
    	//按每项输出
        _FOR(i, num[0], 1) printf("%d", num[i]);
        puts("");
    }

    

    BigInt operator / (const int &x) const
    {
    	//高精度除法
        BigInt B = *this;
        _FOR(i, num[0], 1) B.num[i] += B.num[i + 1] % x * 10;//预处理
        _FOR(i, num[0], 1) B.num[i] /= x;//除法
        while (B.num[0] > 1 && !B.num[B.num[0]]) --B.num[0];//防止出现不合理的数
        return B;//返回
    }
    //至于高精除高精······自己想去
};
char BigInt::str[M];
int main()
{
 	BigInt a, b;
 	int k;
 	a.read();
 	cin >> k; //输入
 	b = a / k;//处理（自动取整）
 	b.print();//输出
    return 0;
}
```

---

## 作者：YangQuijote (赞：1)

这道题....是真的坑。

乍一看过去难度似乎吓死人，一开始的思路想到了分解因数等乱七八糟的东西上去。。。结果完全没有头绪，没办法，开始拿小数据找规律，然后。。。这不就是n/k嘛！。。。奥数规律题？

放下代码，溜了溜了。。。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    printf("%d",n/k);
    return 0;
}
```

---


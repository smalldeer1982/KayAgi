# [AHOI2005] 约数研究

## 题目描述

科学家们在 Samuel 星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机 Samuel II 的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用 Samuel II 进行数学研究。

小联最近在研究和约数有关的问题，他统计每个正数 $N$ 的约数的个数，并以 $f(N)$ 来表示。例如 $12$ 的约数有 $1,2,3,4,6,12$，因此 $f(12)=6$。下表给出了一些 $f(N)$ 的取值：

| $N$    | $1$  | $2$  | $3$  | $4$  | $5$  | $6$  |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- |
| $f(N)$ | $1$  | $2$  | $2$  | $3$  | $2$  | $4$  |

现在请你求出：

$$
\sum_{i=1}^n f(i)
$$

## 说明/提示

- 对于 $20\%$ 的数据，$N \leq 5000$；
- 对于 $100\%$ 的数据，$1 \leq N \leq 10^6$。



## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# 题解

## 作者：Kelin (赞：323)

其实这题没那么难优化什么的

$[1,n]$里约数有$i$的个数是$\lfloor\frac ni\rfloor$

所以$ans=\sum_{i=1}^n\lfloor\frac ni\rfloor$然后我们打表发现

有很多$\lfloor\frac ni\rfloor$都是一样的 对于这些一样的数我们每次算一次 似乎很浪费时间

所以我们每次$i$跳到$\lfloor\frac nj\rfloor=\lfloor\frac ni\rfloor+1$这样的$j$上 对于中间一样的数一次性算掉

这样的复杂度又是多少呢?打表测试一下就好了 复杂度$O(2\sqrt n)$//其实这道题数据范围可以出到$10^{14}$的 ~~手动滑稽~~

```
#include<cstdio>
int n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1,j;i<=n;i=j+1){
        j=n/(n/i);
        ans+=(n/i)*(j-i+1);
    }
    printf("%d",ans);
return 0;
}
```

---
$upd:2018.3.30$

突然发现好多评论哇$qwq$

告诉泥萌还有$O(n^{\frac13}\log n)$的做法呢

详见[$[Spoj26073]DIVCNT1$](https://www.luogu.org/problemnew/show/SP26073)

---

## 作者：引领天下 (赞：151)

看到题解基本上都是数学方法，我就来个不一样的思路吧（说白了就是暴力）

首先，我们看一下数学方法的思路：

- 数学方法：

重点在于一个公式：

$$f(i)=\frac{n}{i}$$

至于公式的含义，看我解释：

$1\sim n$ 的因子个数，可以看成含有 $2$ 这个因子的数的个数 $+$ 含有 $3$ 这个因子的数的个数 $+\dots+$ 含有 $n$ 这个因子的数的个数。

在 $1\sim n$ 中含有“2”这个因子的数有 $\frac{n}2$ 个，3 有 $\frac{n}3$ 个，以此类推，公式就出来了。

数学方法代码：

```cpp
#include<iostream>
using namespace std;
int n,ans;
int main(void){
    cin>>n;
    for(int i=1;i<=n;i++)ans+=n/i;
    cout<<ans;
}
```

- 非数学方法：

概括起来就俩字：**暴力**！

但是纯暴力是绝对超时的，这题要是暴力不想超时的话，就得借用筛法的思想：

```cpp
void H(){
    for (int i=1;i<=n;i++){
        for (int j=i;j<=n;j+=i)a[j]++;
        s+=a[i];
    }
}
```

$i$ 就是循环的因子，从 $1$ 到 $n$，$j$ 是 $i$ 的倍数，由于是从 $i$ 开始的，所以 $a[i]$ 本身也加了一次，既然是 $i$ 的倍数，那么就含有 $i$ 这个因子，加 1。

最后 `s+=a[i];` 累加所有 $a[i]$，由于此时已经更新过 $a[i]$ 了，可以放心加。

$i$ 这个循环跑了一遍后，$s$ 就是总的因子个数了。

非数学方法代码：

```cpp
#include <cstdio>
int n,a[10000001],s;
void H(){//筛法函数，上面解释过了
    for (int i=1;i<=n;i++){
        for (int j=i;j<=n;j+=i)a[j]++;
        s+=a[i];
    }
}
int main(){
    scanf ("%d",&n);
    H();
    printf ("%d",s);//输出
    return 0;
}
```

---

## 作者：Ophelia (赞：128)

首先我们来看这张约数表
![](https://cdn.luogu.com.cn/upload/pic/53063.png)
我们可以看出问题可以进行转化。

原问题是1~n的约数数量之和

根据不完全归纳法，1~12中只有2的倍数的约数中有2，只有3的倍数的约数中有3···只有k的倍数的约数中有k。

那么问题就可以转化为：1~n中k(1,2,3,···n)的倍数的数量之和。

还是不完全归纳法，1~12中1的倍数的数量是12/1=12,2的倍数的数量是12/2=6,3的倍数的数量是12/3=4···n的倍数的数量是n/n=1。

每一项设为k，那么问题就是求n/k（1,2,3···n）的和了。

代码如下
```
#include<cstdio>
#include<iostream>
using namespace std;
int n,sum;
int main()
{
	cin>>n;
	for(int k=1;k<=n;k++)
		sum+=n/k;
	cout<<sum<<endl;
	return 0;
}
```


---

## 作者：ikka (赞：42)

惊了，竟然没有纯数学证明的题解
$$ \sum_{i=1}^{n}\sigma(i)=\sum_{i=1}^{n}\sum_{d|i}1 $$
$$=\sum_{i=1}^{n}\sum_{d=1}^{n}[d|i]$$ 
$$=\sum_{d=1}^{n}\sum_{i=1}^{n}[d|i]$$
 $$=\sum_{d=1}^{n}\lfloor\frac{n}{d}\rfloor$$

$\lfloor\frac{n}{d}\rfloor$只有大约$\sqrt{n}$种取值，所以可以分块求解，时间复杂度$O(\sqrt{n})$

 代码
 
 ``` cpp
#include <bits/stdc++.h>
long long ans;
int main() {
  int n;
  scanf("%d", &n);
  for (int i = 1, j; i <= n; i = j + 1) {
    j = std::min(n, n / (n / i));
    ans += (long long)(j - i + 1) * (n / i);
  }
  printf("%lld\n", ans);
  return 0;
}
 ```

---

## 作者：JustinRochester (赞：22)

[题目](https://www.luogu.org/problem/P1403)

看到题解区很多人直接给出结论：答案为 $\displaystyle \sum_{i=1}^n\lfloor{n\over i}\rfloor$ ，没给出证明，这里给出证明

---

**【分析】**
---

首先，我们可以知道 $\displaystyle f(n)=\sum_{d\mid n}1$

有的同学看不懂这个公式，我解释一下，这个公式表达：

枚举 $n$ 的因数 $d$，每枚举一个因数 $d$， $f(n)$ 加 $1$

> $d\mid n$ 指 $d$ 是 $n$ 的因数

这样一来，我们就可以和题目的对应上了： $f(n)$ 代表 $n$ 的因数个数

---

$\displaystyle f(n)=\sum_{d\mid n}1$ 还有一种表达方式是 $\displaystyle f(n)=\sum_{d=1}^n[d\mid n]$

后面那个鬼东西 $[d\mid n]$ 是一个判断正误的函数，正确为 $1$ ，错误为 $0$

这个应该理解起来也不难：

枚举每一个数 $d$ ，当 $d$ 是 $n$ 的因数时， $f(n)$ 加 $1$

---

题目要求的 $\displaystyle M=\sum_{i=1}^n f(i)$

我们代入上面的定义式：

$\quad \displaystyle M$

$\displaystyle=\sum_{i=1}^n\sum_{d\mid i}1$

$\displaystyle=\sum_{i=1}^n\sum_{d=1}^i[d\mid i]$

我们调换一下枚举的顺序，把 $d$ 的枚举提前。

> 相当于考虑 $d=1$ 时，对 $i=1,2,3\dots n$ 的贡献； $d=2$ 时对 $i=1,2,3\dots n$ 的贡献； $\dots$ ；$d=n$ 时对 $i=1,2,3\dots n$ 的贡献

$\displaystyle=\sum_{d=1}^n\sum_{i=1}^n[d\mid i]$

对于一个固定的 $d$ ，$\displaystyle\sum_{i=1}^n[d\mid i]$ 的意义非常直观：

$1$~$n$ 中，有多少个数以 $d$ 为因数，即多少个数是 $d$ 的倍数

应该是 $\lfloor{n\over d}\rfloor$ 吧

所以我们得到 $\displaystyle M=\sum_{d=1}^n\lfloor{n\over d}\rfloor$

---

**【代码】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了：

C++ 版：
```cpp
#include<iostream>
using namespace std;
int main(){
    int n,ans=0;
    cin>>n;
    for(int i=1;i<=n;i++) ans+=n/i;
    cout<<ans;
}
```


Python 3 版：

```python
ans=0
n=int(input())
for i in range(1,n+1):
    ans+=n//i
print(ans)

```

最后安利一下[本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：天权3940 (赞：21)

# 一篇蒟蒻的题解

## 正解
先说下看了楼上各种大牛们的数学解法后自己的一些理解

ps：可以参照三楼大佬[@Ophelia](https://www.luogu.com.cn/user/79011)
的图片，可以更直观的看出规律

在[1,n]中

- 1的倍数是1x1,1x2,1x3…………；

	即每隔1个数就是1的倍数（含有因子1）；

	含有因子1的数的个数就为n/1；


- 2的倍数是2x1,2x2,2x3…………；

	即每隔2个数就是2的倍数（含有因子2）；

	含有因子2的数的个数就为n/2；

- 3的倍数是3x1,3x2,3x3…………；

	即每隔3个数就是3的倍数（含有因子3）；

	含有因子3的数的个数就为n/3；
    
## **综上：在[1,n]中含有因子i的个数为n/i**

 代码如下：

~~（就这么点？？？哭了/(ㄒoㄒ)/~~~~）~~
```cpp
#include<iostream>
#include<cstdio>
#define re register int
using namespace std;
int n,ans;
int main()
{
	scanf("%d",&n);
	for(re i=1;i<=n;++i)//枚举1--n中因子有i的数的个数
		ans+=n/i;
	printf("%d",ans);
} 
```

------------


------------

### 下面是本蒟蒻打这道题的经过

前天半夜来看了看这道题，只看了几眼，以为只是求n的约数的和，
然后就睡了，第二天又重新看了一遍才发现不简单，
~~（就说为什么会有这种水题）~~

后来打了个暴力试了下，稳妥妥的TLE
###### ~~（论算时间复~~~~杂度的重要性）~~

于是本蒟蒻便来尝试打表，因为在上周我们期末考试中，本蒟蒻为了打几个质数表花了几个小时，
~~:( 忘了欧拉筛~~

于是乎，我就把f[1]~f[10000000]全都打了出来，花了大概半分钟计算，又开开心心的写出来了个O(n)的程序，把10^7的数考过来，把电脑都要卡炸了

测试一遍，O(n)就是快，~~（就是编译个几分钟）~~

但当我一卡一顿地打开luogu时，却太大交不了，瞬间崩溃，开始思考人生
~~（打开B站平复了下心情）~~

然而拯救我的是讨论，我翻了翻讨论，看见一位大牛提到了筛法，又开始思考起来……
~~（打开了新世界的大门）~~

终于我写出了这篇筛法，但还是没想到数学解法


------------

- ### 筛法思路
	就像质数的线性筛法一样，i的倍数的因子一定含有i

- ### 筛法代码
```cpp
#include<iostream>
#include<cstdio>
#define re register int
using namespace std;
int n,ans,f[1000001];//f存每个数的因子个数
int main()
{
	scanf("%d",&n);
	for(re i=1;i<=n;++i)
	{
		re j=i;
		while(j<=n)
			++f[j],j+=i;//i翻倍，其倍数j一定含有因子i，++f[j];
	}
	for(re i=1;i<=n;++i)
		ans+=f[i];//求和
	printf("%d",ans);
} 
```


---

## 作者：λᴉʍ (赞：19)

可以看我的这篇博客：http://www.cnblogs.com/xzz_233/p/8365414.html


可以线性筛前N个数的约数个数。


（这个好像叫$d$函数）


看$d=(a_1+1)(a_2+1)\cdots(a_k+1)$


然而还不行，你还要记这个数的$a_1$（定义在上面）记为$f$


首先，$d(p)=2,f(p)=1$


然后，将合数$n$分解成$n=px$（p是n最小的质因子），


若$p\nmid x$则$d(n)=2d(x),f(n)=1$（d乘2相当于是要不要新选p）


否则$f(n)=f(x)+1,d(n)=d(x)*\frac{f(n)+1}{f(x)+1}$


```cpp
// It is made by XZZ
#include<cstdio>
#include<algorithm>
#define il inline
#define rg register
#define vd void
#define sta static
typedef long long ll;
il int gi(){
    rg int x=0,f=1;rg char ch=getchar();
    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int maxn=1000001;
int pr[maxn],d[maxn],f[maxn];
bool flg[maxn];
int main(){
    int n=gi();
    for(rg int i=1;i<=n;++i)d[i]=1;
    for(rg int i=2;i<=n;++i){
        if(!flg[i])pr[++pr[0]]=i,d[i]=2,f[i]=1;
        for(rg int j=1;i*pr[j]<=n&&j<=pr[0];++j){
            flg[i*pr[j]]=1;
            if(i%pr[j]==0){
                f[i*pr[j]]=f[i]+1;
                d[i*pr[j]]=d[i]/(f[i]+1)*(f[i*pr[j]]+1);
                break;
            }
            f[i*pr[j]]=1;
            d[i*pr[j]]=d[i]*2;
        }
    }
    ll m=0;
    for(rg int i=1;i<=n;++i)m+=d[i];
    printf("%lld\n",m);
    return 0;
}
```

---

## 作者：fanhaotian (赞：10)

自以为找到了一种不错的方法···结果往下一翻就有人给出了···@野菜汤。

我们通过研究题目发现：

考虑每个数k，他的约数中有k的数是n/k个,所以k给答案加上n/k。

所以答案就是sigma(n/i)(符号打不出来···)

给C++标程

```cpp

#include<iostream>
using namespace std;
int main()
{
    int n,i,s=0;
    cin>>n;
    for(i=1;i<=n;i++)
        s+=n/i;
    cout<<s;
    return 0;
}

```

---

## 作者：谁懂谁伤心 (赞：6)

这题数字很大，一个一个数去算会超时，不过我们可以枚举m从1到n/2，把所有小于n的m倍数加起来，就可以轻松AC。

    ```cpp
#include <iostream>  
    using namespace std;  
    int main()  
    {  
    int a,js=0;  
    cin >>a;   
    for (int s=1;s<=a;s++) js+=a/s;  
    cout <<js;  
    return 0;  
    }  
```

---

## 作者：LATB (赞：5)

....emmmmm
有点懵逼.

------------
我又来(第一次啦~~~)水水了...（我划我划...）
说实话，被这题的标签和标题吓到了，但仔细一看发现，似乎又能水了耶（手动滑稽）


------------
正经：这个题，乍一看   直接求因数有一点点麻烦.
So：我们倒~着瞅———对于每个数i，在1到n的范围内有多少个数是它的倍数？~~~~答案显然是n/i。于是最终的答案就是∑(n/i)。（嘿，划呀划）附上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        int sum=0;
        for(int i=1;i<=n;i++)
            sum+=n/i;
        cout<<sum<<endl;
    }
    return 0;
}
```


------------
水水更健康-_-||!

---

## 作者：坏坏惹人爱 (赞：3)

我有一个大胆（简单）的想法，结果AC了

原理：若i\*j<=n{若i=j则ans++，否则ans+=2}//i<=j

手写一遍n=6的看一看：

```cpp
1*1=1 ans++                                   1--1
1*2=2 ans+=2                                 2--2
1*3=3 ans+=2                                 3--2
1*4=4 ans+=2  2*2=4 ans++          4--3
1*5=5 ans+=2                                 5--2
1*6=6 ans+=2  2*3=6 ans+=2       6--4
```
ans--14
即可得到答案

代码见下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=sqrt(n);i++){
        for(int j=i;j<=n/i;j++){
            if(i==j) ans++;
            else ans+=2;
        }
    }
    printf("%d",ans);
}
```

---

## 作者：菜鸡gyf (赞：2)

看到这一题，大家的第一想法肯定是依次计算每一个数的约数，时间复杂度为O（n^2)，稍微优化一下就可以把计算每个数约数的时间优化到sqrt(n),时间复杂度为O(n*sqrt(n)),但是这只能拿到60分。

60分代码：
```
#include<cstdio>
#include<cmath>
using namespace std;
long long ans=1;
int n;
void ys(int k)
{
	int i;
	if(k>n)
	return;
	for(i=1;i<=sqrt(k);++i)
		if(k%i==0)
		{
			ans+=1;
			if(k/i!=i)
			ans+=1;
		}
	ys(k+1); 
}
int main()
{
	scanf("%d",&n);
	ys(2);
	printf("%lld",ans);
	return 0;
}
```

问题出在哪里？

这样写每一个数的约数个数都能求出来，但是我们根本不需要知道这一点。上面是枚举每一个数，我们还可以枚举约数。

高斯记号想必大家都明白，[n],表示不超过n的最大整数,如[3.7]=3。

我们知道1到n有多少个数能整除2的表达方式是[n/2],3呢？[n/3]。由此可得，约数数量=[n/1]+[n/2]+……。而c++中整数除以整数就是向下取整，不然还要写一个floor()

这样一来，时间复杂度优化到了O(n).

AC代码：
```
#include<cstdio>
using namespace std;
long long ans=0;
int n;
int main()
{
	int i; 
	scanf("%d",&n);
	for(i=1;i<=n;++i)
		ans+=n/i;
	printf("%lld",ans);
	return 0;
}
```

只有13行代码，是不是很简洁？

---

## 作者：Mr_QwQ (赞：2)

楼下的大佬们都是用数学方法，我在普及模拟考里面遇到过这题，所以介绍一下我的临场方法。

嗯，我当时没想到$n/1+n/2+...+n/n$的写法，所以猜猜我是怎么过的……

#打表！！！

然而代码是有长度限制的，怎么办呢？

我的临场方法是：分块打表。

具体地说，我先把n=1000\*i的这些数据先算出来，然后拷进一个数组里。

打表程序如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
    //freopen(".in","r",stdin);
    freopen("QAQ.out","w",stdout);
    int n,ans=0;
    for(int i=1;i<=1000000;i++)
    {
        for(int j=1;j*j<=i;j++)
        {
            if(i%j==0){
                ans+=2;
                if(j*j==i)--ans;
            }
        }
        if(i%1000==0)printf("%d,",ans);
    }
    return 0;
}
```
之后再写主程序即可。具体实现上，把整千部分的答案算出来，对于零头进行一个暴力即可。事实上这份代码跑的相当快，只要4ms（虽然正解更快）。

提交的代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int ans[1001]={0,7069,15518,24496,33805,43376,53141,63071,73147,83358,93668,104076,114587,125182,135828,146572,157370,168230,179174,190135,201177,212276,223384,234555,245792,257036,268353,279696,291063,302474,313925,325398,336908,348467,360022,371645,383279,394926,406610,418345,430062,441814,453632,465405,477263,489132,500986,512916,524837,536769,548725,560731,572734,584742,596800,608860,620928,633034,645138,657264,669422,681582,693760,705990,718170,730412,742646,754914,767172,779468,791780,804072,816444,828758,841124,853491,865895,878295,890717,903111,915548,928026,940458,952964,965469,977923,990435,1002980,1015512,1028034,1040630,1053179,1065729,1078332,1090960,1103530,1116181,1128773,1141451,1154114,1166750,1179409,1192131,1204776,1217512,1230246,1242939,1255651,1268428,1281148,1293935,1306709,1319460,1332242,1345063,1357827,1370670,1383504,1396309,1409152,1421996,1434837,1447711,1460568,1473458,1486353,1499272,1512112,1525051,1537965,1550902,1563803,1576773,1589716,1602688,1615655,1628616,1641576,1654567,1667566,1680578,1693609,1706562,1719602,1732663,1745676,1758696,1771765,1784798,1797910,1810953,1824016,1837121,1850229,1863304,1876373,1889532,1902630,1915719,1928872,1942002,1955139,1968316,1981427,1994592,2007788,2020943,2034100,2047339,2060477,2073666,2086921,2100110,2113287,2126545,2139740,2152977,2166198,2179439,2192685,2205986,2219195,2232468,2245733,2258986,2272290,2285583,2298900,2312181,2325500,2338763,2352119,2365418,2378715,2392026,2405417,2418736,2432065,2445430,2458762,2472113,2485530,2498835,2512238,2525625,2538972,2552349,2565784,2579170,2592603,2606008,2619367,2632806,2646231,2659636,2673043,2686550,2699971,2713394,2726861,2740315,2753778,2767251,2780652,2794165,2807654,2821119,2834590,2848139,2861602,2875085,2888622,2902115,2915594,2929155,2942616,2956167,2969702,2983237,2996742,3010305,3023848,3037411,3050958,3064521,3078100,3091633,3105204,3118793,3132390,3145958,3159554,3173177,3186720,3200293,3213908,3227513,3241090,3254737,3268352,3281973,3295610,3309223,3322834,3336521,3350158,3363787,3377428,3391091,3404698,3418435,3432044,3445767,3459422,3473053,3486750,3500421,3514066,3527807,3541502,3555195,3568862,3582639,3596261,3609972,3623721,3637416,3651137,3664900,3678599,3692338,3706037,3719772,3733551,3747296,3761047,3774742,3788546,3802339,3816064,3829833,3843582,3857339,3871104,3884933,3898706,3912507,3926226,3940082,3953841,3967622,3981469,3995266,4009043,4022878,4036699,4050462,4064319,4078145,4091958,4105787,4119620,4133467,4147272,4161159,4174974,4188812,4202667,4216520,4230399,4244274,4258103,4271964,4285913,4299723,4313590,4327517,4341370,4355227,4369128,4382991,4396913,4410836,4424711,4438640,4452511,4466398,4480293,4494275,4508154,4522065,4536030,4549913,4563836,4577766,4591683,4605638,4619651,4633504,4647461,4661460,4675376,4689311,4703306,4717223,4731162,4745152,4759097,4773048,4787069,4801042,4815029,4829005,4842964,4856989,4870956,4884941,4898990,4912964,4926883,4940922,4954929,4968982,4982928,4996979,5010974,5024971,5039024,5053016,5067033,5081120,5095103,5109170,5123154,5137203,5151236,5165317,5179322,5193384,5207455,5221472,5235535,5249640,5263698,5277683,5291828,5305861,5319931,5334034,5348079,5362138,5376227,5390305,5404404,5418489,5432570,5446662,5460779,5474890,5488931,5503108,5517116,5531225,5545418,5559483,5573577,5587710,5601837,5615940,5630100,5644159,5658342,5672495,5686578,5700734,5714865,5728986,5743143,5757291,5771442,5785585,5799760,5813896,5827997,5842200,5856343,5870487,5884706,5898853,5912964,5927210,5941349,5955518,5969709,5983869,5998060,6012287,6026406,6040628,6054843,6069000,6083184,6097429,6111580,6125813,6139969,6154172,6168405,6182652,6196878,6211021,6225270,6239475,6253693,6267916,6282111,6296367,6310600,6324821,6339070,6353304,6367555,6381794,6396048,6410269,6424458,6438777,6452951,6467250,6481511,6495814,6509982,6524281,6538526,6552802,6567089,6581348,6595588,6609909,6624142,6638449,6652713,6667034,6681237,6695621,6709826,6724143,6738426,6752684,6766973,6781292,6795578,6809883,6824238,6838468,6852793,6867128,6881421,6895735,6910036,6924353,6938695,6953022,6967297,6981629,6995992,7010277,7024605,7038974,7053293,7067636,7081966,7096331,7110642,7124980,7139289,7153668,7168012,7182325,7196714,7211106,7225399,7239740,7254124,7268535,7282878,7297248,7311563,7325956,7340298,7354711,7369028,7383430,7397809,7412130,7426562,7440973,7455326,7469746,7484107,7498504,7512950,7527253,7541640,7556148,7570495,7584848,7599314,7613655,7628080,7642514,7656887,7671322,7685738,7700125,7714536,7728996,7743375,7757822,7772206,7786669,7801082,7815494,7829949,7844326,7858852,7873259,7887676,7902128,7916533,7931004,7945450,7959819,7974346,7988788,8003231,8017730,8032146,8046609,8061051,8075504,8089951,8104431,8118960,8133333,8147853,8162258,8176707,8191265,8205724,8220199,8234627,8249152,8263552,8278049,8292578,8307100,8321541,8336042,8350476,8364997,8379540,8394026,8408481,8423009,8437498,8451989,8466557,8481014,8495533,8510049,8524478,8539004,8553549,8568056,8582522,8597109,8611626,8626122,8640655,8655190,8669670,8684221,8698749,8713298,8727807,8742333,8756844,8771442,8785945,8800484,8815072,8829537,8844066,8858640,8873195,8887717,8902322,8916847,8931403,8945974,8960513,8975059,8989682,9004160,9018743,9033388,9047896,9062445,9077003,9091590,9106125,9120757,9135246,9149878,9164473,9178998,9193598,9208179,9222774,9237328,9251927,9266535,9281074,9295751,9310293,9324920,9339464,9354115,9368638,9383292,9397829,9412455,9427128,9441625,9456253,9470950,9485482,9500085,9514694,9529316,9543919,9558603,9573156,9587781,9602391,9617002,9631654,9646249,9660900,9675504,9690157,9704783,9719460,9734106,9748655,9763300,9777962,9792577,9807227,9821898,9836495,9851153,9865834,9880440,9895051,9909784,9924374,9939041,9953713,9968324,9982994,9997663,10012276,10026992,10041685,10056257,10070946,10085639,10100289,10114972,10129666,10144315,10158983,10173682,10188339,10202999,10217718,10232400,10247045,10261748,10276428,10291089,10305799,10320512,10335124,10349903,10364532,10379194,10393971,10408621,10423300,10438018,10452717,10467454,10482110,10496781,10511477,10526246,10540910,10555635,10570308,10585038,10599751,10614491,10629166,10643920,10658673,10673330,10688058,10702823,10717489,10732230,10746980,10761705,10776448,10791146,10805893,10820567,10835364,10850034,10864777,10879577,10894322,10908999,10923783,10938482,10953222,10968005,10982719,10997454,11012220,11026987,11041716,11056514,11071221,11086009,11100698,11115436,11130231,11145096,11159740,11174541,11189253,11204058,11218810,11233661,11248349,11263106,11277950,11292653,11307400,11322210,11336921,11351785,11366568,11381310,11396075,11410875,11425646,11440411,11455201,11469990,11484796,11499595,11514337,11529186,11543994,11558713,11573543,11588376,11603137,11617889,11632730,11647492,11662347,11677185,11691900,11706734,11721507,11736313,11751140,11765955,11780761,11795616,11810432,11825197,11840025,11854868,11869598,11884447,11899307,11914112,11928928,11943815,11958594,11973408,11988249,12003095,12017876,12032740,12047519,12062371,12077220,12092062,12106845,12121749,12136568,12151419,12166269,12181098,12195936,12210819,12225585,12240472,12255302,12270133,12284969,12299866,12314700,12329547,12344423,12359278,12374140,12389025,12403876,12418752,12433603,12448377,12463266,12478206,12493045,12507881,12522768,12537630,12552461,12567377,12582228,12597086,12611991,12626845,12641670,12656664,12671567,12686334,12701272,12716167,12731033,12745944,12760780,12775675,12790511,12805428,12820350,12835289,12850061,12865002,12879904,12894811,12909645,12924562,12939476,12954343,12969373,12984174,12999122,13014029,13028895,13043874,13058721,13073587,13088548,13103452,13118301,13133247,13148200,13163108,13178019,13192891,13207830,13222720,13237685,13252589,13267460,13282442,13297369,13312289,13327228,13342154,13357039,13372007,13386918,13401876,13416759,13431745,13446636,13461636,13476463,13491463,13506398,13521286,13536267,13551241,13566172,13581058,13596043,13610985,13625924,13640884,13655773,13670825,13685752,13700640,13715577,13730597,13745576,13760468,13775525,13790403,13805372,13820360,13835287,13850267,13865232,13880144,13895133,13910137,13925114,13940026,13955099,13970034},n,tmp;
int main()
{
    scanf("%d",&n);
    for(int i=n/1000*1000+1;i<=n;i++)
    {
        for(int j=1;j*j<=i;j++)
        {
            if(i%j==0){
                tmp+=2;
                if(j*j==i)--tmp;
            }
        }
    }
    printf("%d",tmp+ans[n/1000]);
    return 0;
}
```

---

## 作者：枫华丶夜幻 (赞：2)

各位dalao都在用数学方法解啊
我这个蒟蒻数学太菜表示看不懂......
这里给大家一个暴力的算法，很好懂哟~~~
直接上代码吧~
```cpp
#include<iostream>
#include<cstdio> //头文件不解释 
using namespace std;
int sum[1000001]; //sum[i]表示i这个数有几个约数
                  //比如sum[6]=4就表示6的约数有4个 
int main()
{
	int n,ans=0; //n输入,ans结果 
	scanf("%d",&n);
	//下面这两个循环是关键 
	for(int i=1;i<=n;i++) //第一层循环用来枚举1~n这n个数 
		for(int j=i;j<=n;j+=i) //这一层循环用来枚举i的倍数 
			sum[j]++; //这里的意思是i的所有倍数都有i这个约数
					  //所以他们的约数个数加1 
	for(int i=1;i<=n;i++) //最后将所有数的约数个数相加就好了
		ans+=sum[i];
	printf("%d",ans);
	return 0; //完美结束
}
```

---

## 作者：GlitterL (赞：1)

这个题可以有两种解法。
## （一）通过筛法求解
根据素数筛的思想来做
```cpp
for(int i=2;i<=n;i++)
{
	for(int j=i*2;j<=n;j+=i){
		jilu[j]++;
   }
}
```
## （二）数学分析法
我们可以发现 1-n 中以 i 为因子的数有 n/i 个，例如 n=6 ，则以 2 为因子的数有 6/2=3 个，因此直接将这些数求和就好了。
```cpp
#include<iostream>
#include<iomanip>
#include<algorithm>
#include<cmath>>
#include<cstdio>
#include<string>

using namespace std;

int n;

int main()
{
    long long sum=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) sum+=(n/i);
    printf("%lld\n",sum);
}
```


---

## 作者：xukuan (赞：1)

开始傻傻的纯模拟，本地TLE一片。

一天后————

#f(i)=n div i(pas)!

#f(i)=n/i(cpp)!

数学题。

```cpp
var
 i,n,sum:longint; 
begin
 readln(n);
 for i:=1 to n do
  inc(sum,n div i);
 writeln(sum);
end.

```

---

## 作者：翟绪尧 (赞：1)

这T  千万不要想多

…………

开始比较坑 我想过用大表

然而
不说了 看代码 真正重要的就一句话


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
//    freopen("o.txt","w",stdout);
    long long n,s=0;
    cin>>n;
    for(long long  i=1;i<=n;i++)
    {
        s+=n/i;                            //这T 其实就是每n个数 有几个i；
    }
    cout<<s;
}
```

---

## 作者：t14t41t (赞：1)

本题考察数形结合思想。

约数个数和说白了就是求平面直角坐标系的第一象限内，双曲线x\*y=n下方整点的个数。作直线y=x把双曲线下方区域分成两部分，然后只统计一部分即可。

```cpp
i = 1 -> sqrt(n):
    s += n/i - i + 1;     //[m/i]为双曲线上点坐标（下取整）,-i+1包括了n可整除i的情况
s=s*2- i + 1;　//这里减去重复计算的直线上的整点，+1是因为跳出循环时i已经大于sqrt(n)
return s;
```
时间复杂度O(sqrt(n))
```cpp

#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
const int a[6] = {0, 1, 3, 5, 8, 10};
ll f(int m)
{
    if(m <= 5) return a[m];
    //n太小的话还是直接输出的好
    ll sum = 0;
    int i;
    for(i = 1; i * i <= m; ++i)
    {
        sum += m / i - i + 1;
    }
    return ((sum << 1) - i + 1);
}
int main()
{
    int n;
    scanf("%d", &n);
    printf("%lld\n", f(n));
    return 0;
}

```

---

## 作者：PaulFrank (赞：1)

这题说真的不就是约数和的简化版吗？

这题我们用ans累计从1~n中每一个因子出现的个数

最好用long long !!

最后送上代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int i,n; 
unsigned long long ans;
int main(){
    freopen("1403.in","r",stdin);
    freopen("1403.out","w",stdout);
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        ans+=(long long)n/i;
    printf("%lld\n",ans);
    return 0;
}
希望有所帮助
```

---

## 作者：visitor (赞：1)

这题开始时真的想不到正解， 直到看了楼下大佬们的题解才恍然明白。

于是乎开始时便打了暴力的埃式筛法， 只能30分， 其他点都超时！！！！（哭）

写了点优化， 竟然也能过。

见没人发， 那就发一波。。



那么\_以下是代码：：：







    
    
    
    
    
    
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, ans;
int prime[1000010] = {0};
bool pd[1000010] = {0};
int pNum = 0;
int minz[1000010] = {0};
int read()
{
    int x = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * w;
}
int divide(int x)
{
    int k = minz[x];
    int an = 1;
    int cnt = 0;
    while(x > 1)
    {
        if(k != minz[x])
        {
            an *= (cnt + 1);
            k = minz[x];
            cnt = 0;
        }
        x /= minz[x];
        cnt ++;
    }
     return an * (cnt + 1);
}
int main()
{
    n = read();
    pd[0] = 1; pd[1] = 1;
    for(int i = 2; i <= n; i++)
    {
        if(!pd[i]) 
        {
            prime[++pNum] = i;
            minz[i] = i;
        }
        for(int j = 1; j <= pNum && i * prime[j] <= n; j++)
        {
            pd[prime[j] * i] = true;
            minz[prime[j] * i] = prime[j];
            if(i % prime[j] == 0) break;
        }
    }
    for(int i = 1; i <= n; i++)
    {
        ans += divide(i);
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：weak_ddb (赞：0)

这道题让我们求的就是$1-N$之间每个数的约数之和。

我们看一下数据范围$N<=1000000$。朴素算法的时间复杂度应该是$O(N\sqrt N)$
约等于$1000000 \times 1000=10^9$ 次运算，肯定超时，仅仅想要骗分的同学请看下一篇题解。

**说起约数，我们需要知道一个很重要的知识点。**

> 一个数最大的约数是它本身

如果一个数为$a(a>0)$，那么拥有它作为约数的最小数必然就是$a$，而他的倍数$2a$，$3a$等必然含有约数$a$。

------------
把题目中的问题转化一下，求$\displaystyle \sum^{i=n}_{i=1}{f(i)}$,由于约数的出现是有规律的，所以我们不能按照$i=1$,$i=2$,$i=3$时分别考虑，而是要按照约数$1$在$n$个数里出现了多少次，约数$2$在$n$个数里出现了多少次等。

而对于任意一个数$a$，要求在$1$~$n$里有多少个数含有约数$a$，只要谨记一点，只有$a$的倍数才会含有约数$a$（很明显，不懂可以去看上面）。那么问题的答案就是$n/a$ （$/$是整除）。

------------
想到这里，程序就很明显了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	long long ans=0;
	for(int i=1;i<=n;i++)
	ans+=(n/i);//统计a的倍数有多少个
	cout<<ans;
	return 0;
}
```


---

## 作者：wmyQAQ (赞：0)

最近刚学习的数学，发篇题解纪念一下

### 首先想到了什么？？暴力啊！
然后每一遍都找它的因数个数，复杂度：$O(n^2)$，但是$n$是$10^6$，肯定会爆（30分）的；
### 然后就想优化
对于$1$到$n$，以$i$为因数的有$\left\lfloor\dfrac{n}{i}\right\rfloor$个。并不难想到，举个栗子：

$n$为$4$的时候，$ans$=$1$+$2$+$2$+$3$=$8$。

以$1$作为因数的有$\left\lfloor\dfrac{4}{1}\right\rfloor$=$4$个（$1$,$2$,$3$,$4$）

以$2$作为因数的有$\left\lfloor\dfrac{4}{2}\right\rfloor$=$2$个（$2$,$4$）

以$3$作为因数的有$\left\lfloor\dfrac{4}{3}\right\rfloor$=$1$个（$3$）

以$4$作为因数的有$\left\lfloor\dfrac{4}{4}\right\rfloor$=$4$个
（$4$）

所以$ans$=$4$+$2$+$1$+$1$=$8$

所以只要求$\sum\limits_{i=1}^n\left\lfloor\dfrac{n}{i}\right\rfloor$ 就可以了。

复杂度：$O(n)$

$ps:c++$默认除不尽时向下取整，$floor$为$cmath$的向下取整函数。


## 代码
~~十分简洁~~
```
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

int n,ans;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        ans+=floor(n/i);
    printf("%d\n",ans);
}
```

---

## 作者：Skyjoy (赞：0)

有时候我们要从不同的角度考虑问题。——洛谷最蒻的Skyjoy

按题目要求，最简单的视角就是枚举1~n中的所有数，并统计因数个数。As we know，我们在小学学了2种统计一个数因数个数的方法：配对法和因数个数定理（别告诉我你不会）。因数个数定理要分解质因数，写程序过于辣鸡，想试的自己试。配对法倒是种好想法，就是要特判i是否为完全平方数，上一上函数：

```cpp
int cnt(int n){
	int sum=0;
	for(int i=1;i<=n;i++){
    for(int j=1;j<=sqrt(i);j++){
		if(i%j==0&&j!=sqrt(i)){
   			  sum+=2;//正常配对
      }
      else if(i%j==0&&j==sqrt(i)){
           sum++;特判
      }
     }
   }
return sum;                               
}                                
```
当你满怀希望准备交上去时，你多半会TLE~~其实怕死的我并没有把这个思路的程序交上去~~。Why?

入门组的童鞋看了这个程序，一定会想起埃氏筛。大家看看数据规模，埃氏筛过不去，这个程序一定会挂！

怎么办呢？

看看我开头写的话，我们不妨换个视角，从所有可能的因数开始统计，也就是枚举因数并统计因数所存在的个数（本人语文不好，描述可能不清晰，大家好好理解一下）。而在1~n以内，i的因数为n/i个，只用将i迭代，就可以统计总个数了！上代码：

```cpp
#include<iostream>
using namespace std;
int main(){
	int n;
	cin>>n;//输入
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=n/i;//统计个数
	}
	cout<<ans;//输出
	return 0;//结束程序
}
```
我写得算题解里面认真的了，大家记得关注本蒟蒻的[博客](https://www.luogu.org/blog/Skyjoy-Wang/)点个赞再走哦！

祝大家NOIp rp++！

---

## 作者：bingliang (赞：0)

先看数据

N<=1000000

就是说  O（N）的算法，没毛病，只要不卡就能过，一提交就过了。

只要认真思考那个O(n)的算法还是很好想的，毕竟通向公式简单  最次也能找规律。

至于利用筛法思想优化的方法   个人感觉如果这题数据再开大点  卡了o（n），提高+省选 难度应该是有的。

下面是o（n）代码

有好多字符都是  搜狗输入法的  编译不过。自己改下吧



```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
{    
ans+=n/i;
} 
   cout<<ans;
return 0;
}

```

---

## 作者：Snitro (赞：0)

- 思考本题目是不应该从枚举后求对应的约数个数然后累加的角度思考

- 应该思考对于 k ，在 1 - n 中有多少个数是他的倍数

- 也就是说在1 - n 中有多少个数的约数含有 k；

- 对于 j 中有多少个数是 k 的倍数的问题的答案自然是 j / k;

- 那么我们就可以从 1 - n 枚举 i后将结果累加即可



```cpp
 #include<iostream>
#include<cstdio>
using namespace std;
int main(){
    int ans = 0,n;
    cin >> n;
    for(int i = 1;i <= n;i++)
        ans += n / i;
    cout << ans;
}
```

---

## 作者：_Qer (赞：0)

本题要求f(1)+f(2)...+f(n)

经过简化成为n+n/2+n/3...+n/n

```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
    int n,tmp=0;//tmp记录结果，n记录输入
    cin>>n;
    for(int i=1;i<=n;++i){
            tmp+=n/i;//执行n+n/2+n/3...+n/n
            }
    cout<<tmp;输出最后的和
    system("pause");
    return 0;
}

```

---

## 作者：skylee (赞：0)

本题考察的是数学分析能力

如果按照题目的描述手动模拟，将F(i)一个一个求出来，绝对会超时（虽然没试过）。

其实加以分析，会发现1~n中每一个数字的约数个数之和等于1~sqrt(n)中没一个数字的倍数个数之和。

于是就有了下列程序：

'''pascal

```cpp
var
    n,i,ans:longint;
begin
    readln(n);
    for i:=1 to n do begin
        ans:=ans+n div i
    end;
    writeln(ans)
end.
'''
```

---

## 作者：nixi (赞：0)

开始一见这道题，想用欧拉函数（辗转相除），但考虑到时间复杂度太高。后又考虑筛法，结果筛着筛着就发现了新的规律：

其实只要顺次相除n/1,n/2,n/3......n/n,就可以求出1,2,3，，，n的每一个数作为约数出现的次数，然后累加即可。

    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int main()
{
    scanf("%d",&n);
    int ans=0;
    for(int i=1;i<=n;i++)
     ans+=n/i;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Memorize (赞：0)

做完过后才发现这道题有规律 不过无所谓了 似乎用欧拉函数一个一个的求每个数的约数 刚好能卡过最后两个点（800多ms）

其实求一个数n的约数可以用欧拉函数做  不过求一坨约数的总数的话可以先找找规律，说不定就有新的发现呢！

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
int ans=0,n; 
int num(int x)
{
  int k=2,res=1;
  while(k*k<=x)
  {
    int p=1;
    while(x%k==0){
       x/=k;
       p++;
    }
    k++;
    res*=p;
  }
  if(x>1) res*=2;
  return res;
}
int main()
{ 
    scanf("%d",&n);
    for(int i=1;i<=n;i++) ans+=num(i);
    printf("%d",ans);
    return 0;
} 

```

---

## 作者：川蜀霸王 (赞：0)

线性筛

直接筛出f





```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
#include<cstdlib>
#include<algorithm>
const int N = 1e6 + 7;
int n, ans, prime[N], tot, f[N], g[N];
bool vis[N];
int main () {
    scanf ("%d", &n);
    ans = f[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) prime[++tot] = i, f[i] = 2, g[i] = 1;
        for (int j = 1; j <= tot && (long long) i * prime[j] <= n; ++j) {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) {
//                if (i * prime[j] == 4) puts ("sdf");
                f[i * prime[j]] = f[g[i * prime[j]] = g[i]] + f[i];
                break;
            } else {
                f[i * prime[j]] = f[i] << 1;
                g[i * prime[j]] = i;
            }
        }
        ans += f[i];
    }
//    for (int i = 1; i <= 10; ++i) printf ("%d\n", f[i]);
    printf ("%d\n", ans);
    return 0;
}

```

---

## 作者：CoolTeam (赞：0)

开始考虑从1~n去枚举每个数的约数个数，但时间上不允许，然后想到了从1~n去枚举每个约数有多少个。比如n=10. 包含约数1的数有10个，包含约数2的个数有10/2个，包含约数3的个数有10/3个……

于是规律就有了。


---

## 作者：Micar (赞：0)

用分块方法做这道题，挺简单的。

```cpp
#include <iostream>
using namespace std;
int  k1;
unsigned long long ans = 0;
int devide(int n) {
    for(int k = 1;k1 != n;k = k1 + 1) {
        k1 = n / (n / k);
        ans += (k1 - k + 1) * (n / k);
    }
}
int main() {
    int n;
    cin >> n;
    devide(n);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：野菜汤 (赞：0)

题解：

此题的数学性是非常强的，其实我们完全没有必要去一个个例举，因为直接找前几个数的答案就会发现其中的规律：


**j:=(n/1)+(n/2)+……+(n/n-1)+(n/n)**

 
所以呢，完全无需技巧，只需要闲来无事，另辟蹊径，找找规律，既可以得出答案。那么我的程序就在下方，仅供参考。

```delphi
var
  n,i,j:longint;
begin
  readln(n);
  for i:=1 to n do j:=j+n div i;
  writeln(j);
end.
```

---

## 作者：loheagn (赞：0)

其实我的做法和下面的其他几位同学的一样，只不过算法优化的方式不同，，，，，，

基本都是在[1,n]的范围内对于每个数i，从1到i，依次取数j，使得i\*j<=n，如果i不等于j，则在最终的总数上加2，否则加1。这样做的时间复杂度要达到O(n^2)。


进行优化，在[1,i]中进行枚举之前，先用n/i，求得j可能得到的最大值jmax，然后根据jmax的大小决定在总数num上加上多少个数对。这样即可把时间复杂度控制在O(n)。


下面是代码。


    
```cpp
    #include <iostream>
    using namespace std;
    int main()
    {
        int n;
        cin>>n;
        int i=1;
        unsigned long long num=0;//保险起见。。
        for(;i<=n;i++)
        {
            int jmax=n/i;
            if(jmax>=i)
            num=num+2*i-1;//由于j的取值最大只能是i，所以jmax大于i的那一部分是无效的
            else
            num+=jmax*2;
        }
        cout<<num<<endl;
        return 0;
}
```

---


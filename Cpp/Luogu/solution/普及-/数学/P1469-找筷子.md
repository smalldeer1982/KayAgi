# 找筷子

## 题目描述

经过一段时间的紧张筹备，电脑小组的“RP 餐厅”终于开业了，这天，经理 LXC 接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题：筷子！

CX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮 CX 找出这只落单的筷子的长度吗？


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7 + 1$，$1 \leq a_i \leq 10^9$。


#### 提示

- 请注意数据读入对程序效率造成的影响。
- 请注意本题的空间限制为 $4$ Mb。

## 样例 #1

### 输入

```
9
2 2 1 3 3 3 2 3 1
```

### 输出

```
2```

# 题解

## 作者：t162 (赞：270)

我们考虑异或的两个小小的性质：

1. $k$ 个相同的数的异或和，当 $k$ 为奇数时，结果是这个数本身，否则结果是 $0$。
2. 任何数与 $0$ 的异或值是它本身。

然后注意到题目。题目需要求 $n$ 个数中出现奇数次的那个数，且保证这个数存在且只有一个。于是我们根据上面两个性质得出，答案就是这 $n$ 个数的异或和。

原理：

根据性质1，成对的筷子异或后就变成 $0$ 了，只剩下落单的那一根。把这些 $0$ 和落单的那一根的长度异或起来，根据性质2，结果显然就是落单的那一根的长度。

代码如下：

```cpp
#include<cstdio>
int x,n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&x),ans^=x;
    printf("%d\n",ans);
}
```

---

## 作者：pigstd (赞：48)

这道题一眼看上去很简单，但是看到空间限制为 $4$ Mb的时候，就不能用普通的方法来解决了。就算你开一个$10^7$的数组你就MLE了。

但是考虑到异或的性质（如果你不知道异或，请点击[这里](https://baike.baidu.com/item/异或/10993677?fr=aladdin)）：异或满足交换律和结合律，而且相同两个数异或起来就是$0$，$0$异或任何一个数都是这个数，所以如果我们把所有的数都异或起来，那么如果长度为$a$的筷子是成双的，那么两个$a$异或就是$0$，那么最后的结果就是落单的筷子的长度

c++代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int ans,n,a;//ans是所有数异或之后的结果，也就是题目所求的落单的筷子的数目

int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
   	  	scanf("%d",&a);
		ans^=a;//把所有的数都异或起来
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：xrdrsp (赞：15)

第 $012$ 篇题解。

## Main Idea

给你 $n$ 个数，求那个出现了奇数次的数是哪个。

## Analysis

由于 $1 \leq n \leq 10^7 + 1$ 且 $1 \leq a_i \geq 10^9$，我们必须在 $\mathit{O}(n)$ 的时间复杂度里完成计算。

此题使用位运算比较合适（快）。

`c++` 中，按位异或（`^`）运算：相应位上的值相同，就返回 $0$，否则返回 $1$（当然是二进制中）。如 `09` 和 `11` 异或的结果是 `02`。详细运算如下：

```plain
1001 (09)
1011 (11)
----
0010 (02)
```

那么怎么算呢？

注意到 **按位异或运算具有交换律**。即 $a \oplus b = b \oplus a$。可得将所有数全异或一边跟对排好序后异或是一样的。

则：

$$
\underbrace{(a \oplus a \oplus \cdots \oplus a)}_{\text{偶数个}}
\oplus
\underbrace{(b \oplus b \oplus \cdots \oplus b)}_{\text{偶数个}}
\oplus \cdots 
\underbrace{(n \oplus n \oplus \cdots \oplus n)}_{\text{偶数个}} = 0
$$

$$
\{\underbrace{(a \oplus a \oplus \cdots \oplus a)}_{\text{偶数个}}
\oplus
\underbrace{(b \oplus b \oplus \cdots \oplus b)}_{\text{偶数个}}
\oplus \cdots 
\underbrace{[(n-1) \oplus (n-1) \oplus \cdots \oplus (n-1)]}_{\text{偶数个}}\}
\oplus
\underbrace{(n \oplus n \oplus \cdots \oplus n)}_{\text{奇数个}} = 0 \oplus n = n
$$

其中 $\oplus$ 表异或。

排好序异或会使出现 $2k - 1$ 次的那种数 $x$ 异或结果就是那个数 $x$。 

所以不用排序了。

在此题中，每读入一个 $a_i$，就把当前答案与 $a_i$ 异或。以 `2 1 2` 为例，每次异或的结果是这样的：

```plain
// INPUT
3
2 1 2

// OUTPUT
2 3 1
```

模拟运算过程：

```plain
0000 (00)
0010 (02)
----
0010 (02)
0001 (01)
----
0011 (03)
0001 (01)
----
0010 (02) // 即，目前出现奇数次的是 2。
```


## Code

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    int n;
    int ans = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        ans ^= x;
        // cout << ans << " ";
    }
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：ez_lcw (赞：4)

显然，看到 $n\leq 10^7+1$ 就知道这道题肯定是 $O(n)$ 的。

然后再看到 4MB 就知道这题存不了数组……

考虑通过哪种方式能在极小内存和时间内求出答案。

普通的数组判重肯定是不可行的。

那么可以考虑一下用一些巧妙的方法判重。

容易想到用异或的方式判重。

能判重的原因：

1. $a \oplus a=0$

1. 异或满足交换律和结合律。

那么当所有筷子的长度异或起来后，相同长度的异或之后会变成 $0$，最后剩下的就是落单的筷子的长度了。

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,sum;

int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^'0');
        ch=getchar();
    }
    return x;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) sum^=read();
    printf("%d\n",sum);
    return 0;
}
```


---

## 作者：james1BadCreeper (赞：4)

可以发现本题的最大难点是空间限制，所以我们需要边读边算。

关于异或有一个性质 $x \oplus x=0$，且因为异或满足交换律，所以可以使用异或来解决此题：把每个数都异或起来（即求异或和），因为交换律的关系，成对的筷子异或结果为 $0$ ，而剩下的那个就是落单的。

code：

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

inline int read(void)
{
    register int x=0,c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}

int main(void)
{
    int n,x,ans=0;
    n=read();
    for(register int i=1;i<=n;++i)
    {
        x=read();
        ans^=x;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：chenpengda (赞：4)

通过异或运算。

先贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,input;
int main()
{
    scanf("%d",&input);
    for(int i=1;i<=input;++i)
    {
        int a;
        scanf("%d",&a);
        ans^=a;//灵魂！
    }
    cout<<ans<<endl;
    return 0;
}
```

首先需要**快读/scanf&printf**否则会**TLE**

之后解释一下灵魂的意义：

关于异或的概念，左转[百度百科](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)

我们可以看到这样一段描述。

>同一变量与另一变量和其异或值异或等于另一个数，如（a^b）^b=a。

那么就可以解释啦，比如三个数分别是$3,3,5$那么会算(3^3)^5=(5^3)^3=3。

---

## 作者：SUNCHAOYI (赞：3)

阅读题目，有这句话：这些筷子中只有一只筷子是落单的，其余都成双。因此我们由这句话可以受到一些启发。再看题目的内存限制，只有 $4$MB，所以对空间有了很大的要求。

根据题意，我们需要找到落单的筷子，那么如何进行成双的配对呢？很简单，就是**异或**。两个相同的数 `x^x` 的值一定为 $0$。所以我们只需要从 $1$ 至 $n$ 扫一遍，进行异或 `ans ^= x`。若第 $x$ 个数的长度已经配对，那么这个数将与之前的某个数得到 $0$的结果，则最后 `ans` 的值也就是落单的筷子的长度了。

**注意：数据读入对程序效率造成的影响！** 因此我们在程序设计时使用快读，代码如下：
```
#include <iostream>
#include <cstdio>
using namespace std;
inline int read();
int main()
{ 
	int n,x,ans = 0;
	n = read();
	for(register int i = 1;i <= n;++i) x = read(),ans ^= x;
	printf("%d\n",ans);
	return 0;
}
inline int read()
{
    long long s = 0,f = 1;
    char ch = getchar();
    while((ch < '0' || ch > '9') && ch != EOF)
	{
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar();
    }
    return s * f;
}
```


---


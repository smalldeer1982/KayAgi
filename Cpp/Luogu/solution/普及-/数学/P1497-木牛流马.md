# 木牛流马

## 题目背景

孔明造出了木牛流马。

> 木牛者，方腹曲头，一脚四足，头入领中，舌著于腹。载多而行少，宜可大用，不可小使；特行者数十里，群行者二十里也。曲者为牛头，双者为牛脚，横者为牛领，转者为牛足，覆者为牛背，方者为牛腹，垂者为牛舌，曲者为牛肋，刻者为牛齿，立者为牛角，细者为牛鞅，摄者为牛秋轴。牛仰双辕，人行六尺，牛行四步。载一岁粮，日行二十里，而人不大劳。流马尺寸之数，肋长三尺五寸，广三寸，厚二寸二分，左右同。前轴孔分墨去头四寸，径中二寸。前脚孔分墨二寸，去前轴孔四寸五分，广一寸。前杠孔去前脚孔分墨二寸七分，孔长二寸，广一寸。后轴孔去前杠分墨一尺五分，大小与前同。后脚孔分墨去后轴孔三寸五分，大小与前同。后杠孔去后脚孔分墨二寸七分，后载克去后杠孔分墨四寸五分。前杠长一尺八寸，广二寸，厚一寸五分。后杠与等版方囊二枚，厚八分，长二尺七寸，高一尺六寸五分，广一尺六寸，每枚受米二斛三斗。从上杠孔去肋下七寸，前后同。上杠孔去下杠孔分墨一尺三寸，孔长一寸五分，广七分，八孔同。前后四脚，广二寸，厚一寸五分。形制如象，靬长四寸，径面四寸三分。孔径中三脚杠，长二尺一寸，广一寸五分，厚一寸四分，同杠耳。（《三国志·亮集载作木牛流马法》）

可是在现实中它有个缺陷，就是两个不能在同一行或同一列！

## 题目描述

孔明兴高采烈的叫庞统来参观，孔明存心想难一难庞统，他把 $k$ 个木牛流马放在一个大的 $n \times n$ 的格子地板上，并且给他们都染上色，想让庞统帮着算算有多少种不同的合理布局情况？

## 说明/提示

不需要高精度，并且孔明规定在格子地板上不能翻转，也就是说如果两种布局在翻转后是一样的仍算两种。

## 样例 #1

### 输入

```
4 4 1
4
```

### 输出

```
24
```

# 题解

## 作者：Creroity (赞：39)

啊，又一道可以打题解的题！我已经~~跃跃欲试~~了呢！

**咳咳，回归正题。**

像这种题目，我们可以画一下图。

当然，这题也有两个步骤，先要考虑放置的方法数：（我们拿样例来举个例子）

先是画一个边长为4的正方形格子，这个应该不用我多说。

![](https://cdn.luogu.com.cn/upload/image_hosting/aivh64jd.png)

#### 然后是第一个木牛流马：
从图上不难看出这里每个格子都是可以放的，共有 $ 4\times 4 $ 种可能。

（这里就先随便放一个位置了）

![](https://cdn.luogu.com.cn/upload/image_hosting/lr4uxxhn.png)

红色的叉叉代表木牛流马的位置，但是题目中说：

```
可是在现实中它有个缺陷，就是两个不能在同一行或同一列！
```
所以，放置过木牛流马的同一行同一列需要标记去掉。（图中的蓝色线表示删除）

接着，我们也不难发现剩下来可以放的位置刚好少了一行、一列。

所以剩下的位置放置方法数 $ ans=(4-1) \times (4-1) $ 。

#### 再放第二个木牛流马：
（也先随意放一个位置）

![](https://cdn.luogu.com.cn/upload/image_hosting/3qcpzle7.png)

欸？接下来的位置刚好又是少了一行、一列呢！

所以，到这儿，我们应该可以找到规律了。

------------

对，所以可以得出木牛流马的放置方法数 $ ans=n^2 \times (n-1)^2 \times (n-2)^2 \times \ldots \times (n-k+1)^2 $

------------

#### 接着再看颜色的影响：
我们还是拿样例举例子。

假设我们是这么放木牛流马的：

![](https://cdn.luogu.com.cn/upload/image_hosting/bah2yut7.png)

但是按照一开始假设的来讲，这里的任何一个都可以是第一个放的。

也就是说，这里的所有颜色都被我们假设成了不一样的。

所以我们还得要将颜色造成的多出来的方法数去掉。

首先，我们算出这种方法在颜色全都不同时的可能性共有几种。

很容易算出，共有 $4 \times 3 \times 2 \times 1$ 种也就是 $4!$ 种可能性。

但是因为颜色数等于4，所以实际上只有一种方法。那么它就使答案多了 $4!$ 种方法数。

那我们再假设，此时 $h=2$ ，第一种颜色个数是1，第二种颜色个数是3。

考虑第一种颜色，共一个，所以假设剩下的颜色还是都不相同的，那么可能性就变成了 $4 \times 3 \times 2$ 个，也就是 $4! \div 1$ 。

再考虑第二种颜色，是三个，那么可能性又变成了4个，也就是 $4! \div 3!$ 个。

------------

那么我们又可以得出结论了，每一种颜色，都会造成答案多出 $C_i$ 种可能性，那么我们只用把答案除以 $C_1! \cdot C_2! \cdot \ldots \cdot C_h!$ 就可以得出正确答案了。

------------

啊，那么终于到了上代码的时间了！

##### （因为前面讲得比较清楚，所以代码里有一些注释就没有加）
### 来！咱们上代码！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,h;
long long ans=1,c;//十年OI一场空，不开long long见祖宗 
int main(){
	cin>>n>>k>>h;
	//有人说这里要加一个特判，但其实不需要，因为当k>n时，后面的（n-i+1）就会有一个变成0，那么答案就一定是0了 
	for(int i=1;i<=k;i++){
		ans*=(n-i+1)*(n-i+1);  
	}
	for(int i=1;i<=h;i++){
		cin>>c;
		for(int j=1;j<=c;j++)ans/=j;
	}
	cout<<ans;
	return 0;//记得养成好习惯 
}
```

---

## 作者：Alex_Wei (赞：17)

### 思路:先考虑摆放的位置，再考虑颜色

这里要运用到两个~~小学的~~知识点（摘自百度）：

排列的定义：
从 $n$ 个不同元素中取出 $m(m≤n)$ 个元素的所有排列的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的排列数，用符号 $A(n,m)$ 表示。

#### 计算公式：

$$A(m,n)=\prod_{n-m+1}^{n}=\frac{n!}{(n-m)!}$$

组合的定义：从 $n$ 个不同元素中取出 $m(m≤n)$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的组合数。用符号 $C(n,m)$ 表示。

#### 计算公式：

$$C(m,n)=\frac{A(m,n)}{m!}=\frac{n!}{m!(n-m)!}$$

有了这两个公式，做这题就轻松多了

#### 回归正题，该如何考虑摆放的位置(假设都是一样的颜色)？
先看摆哪一些行：从 $n$ 行里选 $k$ 行，自然就是 $C(k,n)$ 了

再看列该怎么摆：从 $n$ 列里选 $k$ 列，并与行对应(其实就是排列)，共有 $A(k,n)$ 种方法。
#### $∴$ 摆放的位置共有 $C(k,n)*A(k,n)$ 个

考虑完位置，该看颜色了

每次从 $k$ 个木牛流马中选出 $i$ 个涂一种颜色，都有 $C(i,k)$ 种涂法。但是要注意涂完颜色都要从 $k$ 里减去 $i$，因为

#### 这i个已经涂过颜色，不能再涂了

根据上文的推理，得到代码：
```cpp
#include<bits/stdc++.h>//懒人专用万能头
using namespace std;
#define ll long long
ll i,ans=1,k,h,num;//记得开long long,int会炸；ans为总方案数
ll c(char lx,int m,int m)//计算排列组合，lx=='a'为排列，lx=='c'为组合
{
    ll s=1;
    for(int x=n;x>n-m;x--)s*=x;//根据排列公式计算A(a,b)
    if(lx=='c')for(int x=m;x>0;x--)s/=x;//如果是组合就要除以m!
    return s;
}
int main()
{
    cin>>num>>k>>h;
    ans*=c('c',k,num);//选择摆哪一些行: C(k,num)
    ans*=c('a',k,num);//列的摆法: A(k,num)
    for(int x=1;x<=h;x++){
		cin>>i;//i为该颜色木牛流马的个数
		ans*=c('c',i,k);//从k个木牛流马中选择i个涂颜色
		k-=i;//一定要记得减去i，这i个不能再涂了！！ 
	}
    cout<<ans;//输出答案 
    return 0;
}
```

$\small{UPD:2019.8.11\text{ 修改部分文字，添加LATEX，美化文章}}$

---

## 作者：agicy (赞：8)

# 思路

##  过程$1$

根据题意，当$k>n$时，答案为$0$。

## 过程$2$

若不考虑颜色，则：

对第$1$个木牛流马而言，它总共有$n^2$种选择；

对第$2$个木牛流马而言，它总共有$(n-1)^2$种选择；

对第$3$个木牛流马而言，它总共有$(n-2)^2$种选择；

···

对第$k$个木牛流马而言，它总共有$(n-k+1)^2$种选择；

根据乘法原理，不考虑颜色时，总的可能数共有

$(n^2(n-1)^2(n-2)^2...(n-k+1)^2)=(n(n-1)(n-2)...(n-k+1))^2$

## 过程$3$

若考虑颜色的重复问题，则对于每种颜色$c_i$数量都会产生$h_i!$种重复的可能。

根据乘法原理，总的重复情况共有$c_1!c_2!...c_n!$种

根据乘法原理，答案等于过程$2$与过程$3$结果之商，即

$ans=\frac{(n(n-1)(n-2)...(n-k+1))^2}{c_1!c_2!...c_n!}$

# 代码

根据公式，代码如下。

```cpp
#include<stdio.h>//头文件

int n,k,h;
long long ans=1,temp;//用long long防止结果过大

int main(void){
	register int i,j;
	scanf("%d%d%d",&n,&k,&h);//读入
	if(k>n)//如果k>n，答案为0
		return puts("0"),0;
	for(i=n-k+1;i<=n;i++)
		ans*=i;//求n(n-1)(n-2)...(n-k+1)
	ans*=ans;//算平方
	for(i=1;i<=h;i++){
		scanf("%lld",&temp);
		for(j=2;j<=temp;j++)//因为除以1没有用，所以j从2开始
			ans/=j;//进行除法
	}
	printf("%lld",ans);//输出
	return 0;
}
```

---

## 作者：Thinking (赞：6)

第二个。。。

此题非常简单，根据乘法原理，不考虑颜色，摆放方案有P(n,k)^2种（相当于在n个位置中放k个不同的物品，因为是二维的，结果再平方），但因为有颜色一样的，所以答案要除以c1!\*c2!\*c3!\*......\*ck!（即k种颜色的个数阶乘）。

贴代码(pascal):

```pascal
var
  n,k,h,i,j,t:longint;
  s:qword;
begin
  readln(n,k,h);
  s:=1;
  for i:=n-k+1 to n do s:=s*i;
  for i:=1 to h do begin
    readln(t);
    for j:=2 to t do s:=s div j
  end;
  for i:=n-k+1 to n do s:=s*i;
  write(s)
end.
```

---

## 作者：qwq___qaq (赞：5)

### Update

2023/2/23 修改了错别字（你用 $\rightarrow$ 利用，初一 $\rightarrow$ 除以）

***

对于初始状态：

第一个全都空着，可以选择 $n^2$ 个；

第二个被删去了一行一列，只可以选择 $(n-1)^2$ 个；

……

同理，第 $k$ 个木牛流马删去了 $k-1$ 行和 $k-1$ 列方法数即为 $(n-k+1)^2$。

利用乘法原理，我们可以得到 $s\gets n^2\times(n-1)^2\times...\times(n-k+1)^2$。初始完毕后，就是计算了，还是输入 $t$，但此时我们就可以直接用初始状态直接除以 $t$ 的阶乘，复杂度就更低了。并且此时不需特判，因为如果 $n<k$，那么 $s$ 一定乘了一次 $0$，但还是要注意 `long long` 的问题。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int jc(int t){
	if(t==0)
		return 1;
	int sum=1;
	for(int i=2;i<=t;i++)
		sum*=i;
	return sum;
}//阶乘
int t,s=1,n,k,h;//s一定要为1
signed main(){
	cin>>n>>k>>h;
 	for(int i=1;i<=k;i++)
		s*=pow(n-i+1);//初始化
	while(h--){
		cin>>t;
		s/=jc(t);
	}
	cout<<s<<endl;
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：5)

需要用到的公式：

排列数：

$$\Large A^{m}_{n}=\dfrac{n!}{(n-m)!}$$

组合数：

$$\Large C^{m}_{n}=\dfrac{n!}{m!(n-m)!}$$

由于不能再同一行同一列，所以我们必须分开考虑。

首先是考虑列，在 $n$ 列中选择 $k$ 列，由于我们无需考虑他们的顺序，所以应该是组合数，故：

$$\Large C^{k}_{n}=\dfrac{n!}{k!(n-k)!}$$

然后考虑行。

这里需要注意的是，由于不同的列没有限制因素，所以不需要计算排列，但是当我们计算行的时候，我们将其和列一一对应形成确定的点，这时候必须要计算排列了！

读者可以自行画图看一看结论是否如此。

接着我们利用公式来写一下吧！

$$\Large A^{k}_{n}=\dfrac{n!}{(n-k)!}$$

我们利用乘法原理，两个相乘得到的结果是：

$$\dfrac{n!}{(n-k)!}\times\dfrac{n!}{k!(n-k)!}$$

$$\dfrac{n!n!}{(n-k)!k!(n-k)!}$$

$$\dfrac{(n!)^2}{k!((n-k)!)^2}$$

然后考虑染色。

对于每种颜色，$k$ 个中可以选择 $x$ 个，此时组合数为 ：

$$C^{x}_{k}=\dfrac{k!}{x!(k-x)!}$$

相乘实现即可。

---

## 作者：明月几时有 (赞：5)

//1947 木牛流马

其实这题还是~~蛮水的~~

先假设每个牛颜色都不相同

利用组合数的公式求出： 

(n(n-1).....(n-k+1))^2，记为sum1

又因为并不是所有的牛颜色都不同，颜色有重复

所以再将刚才的结果除以 h1! * h2 即可得出最终结果

# code
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define ll long long
int n,k,h;
ll sum=1,sum1=1,ans;
inline int read(){
    int x=0,k=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')k=-1;c=getchar();
    }
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c-'0'),c=getchar();
    return x*k;
}
int main(){
    n=read(),k=read(),h=read(); //读入，不必解释了吧 
    if(k>n){//特判 
        puts("0");
        return 0;
    }
    for(int i=1,x;i<=h;i++){ 
        x=read();
        for(int j=1;j<=x;j++) sum*=j;
    }
    for(int i=n;i>=n-k+1;i--) sum1*=i*i;
    ans=sum1/sum;//利用如上公式计算答案 
    printf("%lld\n",ans); //输出 
    return 0;
}
```

求管理员通过✧⁺⸜(●˙▾˙●)⸝⁺✧

---

## 作者：Beep_Monkey (赞：2)

先来模拟题目中的样例，

4 4 1

4

$4 \times 4$ 的棋盘里，如果放一个木牛流马，那么他就会少一行一列，而这样子的方案数有 $4 \times 4 = 16$ 种，接下来棋盘就只剩 $3 \times 3$ 了，则此时方案数有 $3 \times 3 = 9$ 种，则此时就可得出规律，$ans = n ^ 2 \times ( n - 1 ) ^ 2 \times ( n - 2 ) ^ 2 \times … ( n - k + 1 ) ^ 2$ 。

颜色只是一个排列组合 每多一种颜色，都会造成答案多出 $ C_i $ 种可能性，那么我们只要把答案除以 $C_1! \cdot C_2! \cdot … \cdot C_h!$ 就可以了。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,h;
long long ans=1,c;//注意初值 
int main(){
	scanf("%d%d%d",&n,&k,&h);
	for(int i=1;i<=k;i++)
		ans*=(n-i+1)*(n-i+1);
	for(int i=1;i<=h;i++){
		scanf("%lld",&c);
		for(int j=1;j<=c;j++) ans/=j;//除以颜色 
	}
	printf("%lld",ans);
	return 0;
}
```


---


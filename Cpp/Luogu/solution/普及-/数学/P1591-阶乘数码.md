# 阶乘数码

## 题目描述

求 $n!$ 中某个数码出现的次数。


## 样例 #1

### 输入

```
2
5 2
7 0```

### 输出

```
1
2```

# 题解

## 作者：Dream_It_Possible (赞：90)

此题为高精度\*单精度，所以代码并不是非常难写( Dev-c++:那你还调了N遍？！）,但要注意数组要清零，否则后果不堪设想（全WA），上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int a[5000];
int main()
{
    int t;
    cin>>t;
    while (t--)
    {
        for (int i=1;i<=1001;i++)
        a[i]=0;//将数组清零。
        a[1]=1;//必须设为1。不能为0，不然怎么乘都是0。
        int n,i,j,k,m;
        int p=1,jw=0;//p代表位数，jw代表进位。
        scanf("%d%d",&n,&m);
        for(i=2;i<=n;i++)//从2开始，反正任何数乘1还等于它本身。
        {
            jw=0;
            for(j=1;j<=p;j++)//高精度*单精度。
            {
                a[j]=a[j]*i+jw;//高精度*单精度+进位。
                jw=a[j]/10;//设置进位。
                a[j]=a[j]%10;
            }
            while(jw>0)//如果还有进位，处理进位。
            {
                a[j]=jw%10;
                jw/=10;
                j++;
            }
            p=j-1;
        }
        long long sum=0;
        for (i=p;i>=1;i--)//搜索n!里有几个指定数字。
        {
            if (a[i]==m)
            sum++;
        }
        cout<<sum<<endl;//输出。
    }
    return 0;
}

```

---

## 作者：Laser_Crystal (赞：62)

### 一道高精度好题
高精度乘单精度，应该不是很难吧……

但是数组开小了就会RE:

![](https://cdn.luogu.com.cn/upload/image_hosting/6wgwu1jt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所以还是开大点的好……

```cpp
#include <bits/stdc++.h>
using namespace std;
int c[100000];
int main()
{
  int t,n,a;
  cin>>t;
  for(int i=0; i<t; i++)
  {
    cin>>n>>a;
    memset(c,0,sizeof(c));
    c[0]=1;
    int l=1;
    for(int j=2; j<=n; j++)//开始阶乘计算
    {
      int w=0;
      for(int k=0; k<l; k++)//高精度乘单精度
      {
        c[k]=c[k]*j+w;
        w=c[k]/10;
        c[k]%=10;
      }
      while(w>0)//处理多进位
      {
        c[l]=w%10;
        l++;
        w/=10;
      }
    }
    int sum=0;
    for(int j=0; j<l; j++)
      if(c[j]==a) sum++;//统计个数
    cout<<sum<<endl;
  }
  return 0;
}
```
数组开成100000后：

![](https://cdn.luogu.com.cn/upload/image_hosting/hyr038kw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

完美AC

886~~~

---

## 作者：Lee02 (赞：38)

比较简单，算是**高精乘单精**的板子题

不同于高精乘高精，高精乘单精只需要将高精度数每一位都乘上单精度数字。

建议大家试着将程序**模块化**，这样可以提高功能的**通用性**和**可重复性**

上代码
```cpp
#include<bits/stdc++.h>
#define Endl endl
using namespace std;
int a[10000005];
int t,n,m,sum=0;
void mul(int a[],int k)//乘法部分
{
	for(int i=1;i<a[0];i++)//乘法
	a[i]*=k;
	for(int i=1;i<a[0];i++)//进位，这样进位是为了让程序更有可读性
	{
		if(a[i]>9)
		{
			a[i+1]+=a[i]/10;
			a[i]%=10;
		}
	}
	while(a[a[0]])//在最高位不为零时接着进位
	{
		a[a[0]+1]+=a[a[0]]/10;
		a[a[0]]%=10;
		a[0]++;
	}
}
void check()//查询数码
{
	for(int i=1;i<a[0];i++)
	{
		if(a[i]==m)
		sum++;
	}
}
int main ()
{
	scanf("%d",&t);
	while(t--)
	{
		memset(a,0,sizeof(a));//记得每组输入之前初始化
		sum=0;
		a[0]=1,a[1]=1;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		mul(a,i);
		check();
		cout<<sum<<Endl;
	}
	return 0;
}
```
加油！

---

## 作者：2x6_81 (赞：38)

简单易懂的Python：
```python
t=int(input());
while t>0:
    tmp=input().split(); #切片
    n=int(tmp[0]);
    x=1;
    while n>0:
        x=x*n;
        n=n-1;           #计算阶乘(n!)
    y=int(tmp[1]);
    ans=0;
    while x>0:
        if x%10==y:
            ans=ans+1;   #计算个数
        x=x//10;
    print(ans);          #输出
    t=t-1;
```
原理和C++差不多，懒得用高精了

---

## 作者：Link_Space (赞：26)

~~本蒟蒻的第一篇题解~~
这套题普普通通高精乘低精即可
我的方法可能会有一些麻烦，但是自认为还好理解，求神犇轻虐


------------

```cpp
#include<iostream>
using namespace std;
int a[11][10000];//二维数组存储每一组数据的阶乘
int s[11];//存储n！中指定数码出现次数
int main()
{
	int n,i,x,j,k,q;
	cin>>n;//输入数据组数
	for(i=1;i<=n;i++)
	{
		a[i][0]=1;//为每一组数据阶乘的位数
		a[i][1]=1;//为下一步乘做准备
	}
	for(i=1;i<=n;i++)
	{
		int sum=0;//记录数码出现次数
		cin>>x;
		cin>>q;//输入要求阶乘的数和制定数码
		for(j=1;j<=x;j++)
		{
			for(k=1;k<=a[i][0];k++)
			{
				a[i][k]*=j;
			}
			for(k=1;k<=a[i][0];k++)
			{
				a[i][k+1]+=a[i][k]/10;
				a[i][k]%=10;
			}
			while(a[i][a[i][0]+1]>0)
			{
				a[i][0]++;
				a[i][a[i][0]+1]+=a[i][a[i][0]]/10;
				a[i][a[i][0]]%=10;
			}
		}//普普通通高精乘低精
		for(j=a[i][0];j>=1;j--)
		{
			if(a[i][j]==l)
			sum++;
		}//如果指定数码出现一次就++
		s[i]=sum;//将每一组数据的指定数码出现次数存在数组中，方便输出
	}
	for(i=1;i<=n;i++)
	{
		cout<<s[i]<<endl;
	}
	return 0;
}
```
大功告成！！！
完结撒花！！！

---

## 作者：JOHNKRAM (赞：16)

数据范围这么小，直接使用裸的高精乘就可以过了。

高精乘没有人不会吧？？？


---

## 作者：密期望 (赞：14)

写题解的起因是在知乎上看到了有关计算阶乘的问题，于是给出了这个做法，复杂度为$O(nlog^2n)$，优于一般高精的$O(n^2)$，常数较大，故在小数据上劣于一般高精。但在大数据上吊锤一般高精。

一般高精的局限在于在高精乘低精时无法使用fft（或ntt）优化，从而使复杂度卡在$O(n^2)$下不来，因此我们优化的主要思路是将问题转化为高精乘高精。

很简单，将阶乘的递推公式从

$n!=(n-1)!*n$

变为

$\Pi_{i=l}^{r}i=(\Pi_{i=l}^{mid}i)*(\Pi_{i=mid+1}^{r}i) $

即可。分析复杂度发现递归$O(logn)$层，每层复杂度$O(nlogn)$，总复杂度$O(nlog^2n)$。

本人愚钝，只能想到这个比较常规的分治优化方案，如果有更好的优化方法请一定联系我，谢谢各位神犇了！

代码：
```
#include<cstdio>
#include<algorithm>
#include<vector>
using std::vector;
using std::swap;
typedef long long ll;
const int N=1e6+10;
const ll P=998244353;
const ll G=3;
ll read(){
    ll a=0;int op=1;char ch=getchar();
    while(ch<'0'||'9'<ch){if(ch=='-')op=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){a=(a<<3)+(a<<1)+(48^ch);ch=getchar();}
    return a*op;
}
ll pow(ll a,ll n){
    ll ret=1;
    while(n){
        if(n&1)ret=ret*a%P;
        a=a*a%P;
        n>>=1;
    }
    return ret;
}
void ntt(ll *a,int n,int op){
    static ll* const pos=new ll[N];
    static int last_n=-1;
    if(last_n!=n){
        last_n=n;
        pos[0]=0;
        for(int i=1;i<n;i++){
            pos[i]=(pos[i>>1]>>1)|((i&1)*(n>>1));
        }
    }
    for(int i=0;i<n;i++)if(i<pos[i])swap(a[i],a[pos[i]]);
    ll A,B,w1,wi;
    for(int l=1;l<n;l<<=1){
        w1=pow(G,(P-1)/(l<<1));
        if(op==-1)w1=pow(w1,P-2);
        for(int i=0;i<n;i+=l<<1){
            wi=1;
            for(int j=0;j<l;j++,wi=wi*w1%P){
                A=a[i+j];
                B=a[i+j+l]*wi%P;
                a[i+j]=(A+B)%P;
                a[i+j+l]=(P+A-B)%P;
            }
        }
    }
}
class Int{
    private:
        vector<ll>data;
        Int(const vector<ll> data_):data(data_){
        }
    public:
        Int(ll a=0){
            do{
                data.push_back(a%10);
                a/=10;
            }while(a);
        }
        int len()const{
            return data.size();
        }
        ll get(int i)const{
            return data[i];
        }
        Int operator*(const Int a_)const{
            static ll* const a=new ll[N];
            static ll* const b=new ll[N];
            int n=1;
            while(n<=(int)data.size()+(int)a_.data.size())n<<=1;
            for(int i=0;i<(int)data.size();i++)a[i]=data[i];
            for(int i=(int)data.size();i<n;i++)a[i]=0;
            for(int i=0;i<(int)a_.data.size();i++)b[i]=a_.data[i];
            for(int i=(int)a_.data.size();i<n;i++)b[i]=0;
            ntt(a,n,1);ntt(b,n,1);
            vector<ll>c(n,0);
            for(int i=0;i<n;i++)c[i]=a[i]*b[i]%P;
            ntt(c.data(),n,-1);
            ll l=pow(n,P-2);
            for(int i=0;i<n;i++)c[i]=c[i]*l%P;
            for(int i=0;i+1<n;i++){
                c[i+1]+=c[i]/10;
                c[i]%=10;
            }
            while(!c.back())c.pop_back();
            return c;
        }
};
Int multiply(int begin,int end){
    if(begin==end)return Int(begin);
    if(begin==end-1)return Int(ll(begin)*end);
    int mm=begin+(end-begin)/2;
    return multiply(begin,mm)*multiply(mm+1,end);
}
void do_something(){
    int n,a;
    n=read();
    a=read();
    Int x=multiply(1,n);
    int ans=0;
    for(int i=0;i<x.len();i++)ans+=(x.get(i)==a);
    printf("%d\n",ans);
}
int main(){
    int n;
    n=read();
    for(int i=0;i<n;i++)do_something();
    return 0;
}
```

---

## 作者：ttcwws (赞：11)

# 高精的题目怎能没有Python和Java
## 赶紧 ~~趁势水一波~~ fa个题解
阶乘采用递归的方式计算
### 把阶乘转成字符串再用count完事
直接贴代码


```python
ans = [] #记录答案,本人强迫症,集中输出
n = int(input())

def jc(a):
    if a == 1: return 1
    return a * jc(a - 1)

for i in range(0, n):
    a, b = map(int, input().split()) #空格间隔输入
    ans.append(str(jc(a)).count(str(b)))
    '''
    分步看
    jc(a)  阶乘
    str() 转成字符串
    count() 计算出现次数
    '''
for i in range(0, n):
    print(ans[i])
```

外挂一般的Python

再 ~~水~~ 发一波Java
```java
import java.math.BigInteger;

import java.util.Scanner;


public class Main {
    public static BigInteger jc(int a) { //阶乘运算,用大数
        BigInteger ret = BigInteger.valueOf(a);

        if (a == 1) {
            return BigInteger.valueOf(a);
        }

        return ret.multiply(jc(a - 1)); //乘法
    }

    public static int countinString(String a, char b) { //在字符串里面找字符出现次数
        int len = a.length();
        int cnt = 0;
        char[] t = a.toCharArray();

        for (int i = 0; i < len; i++)
            if (t[i] == b) {
                cnt++;
            }

        return cnt;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        int[] ans = new int[t];

        for (int i = 0; i < t; i++)
            ans[i] = countinString(jc(sc.nextInt()).toString(), sc.next().charAt(0)); //调用countinString,阶乘转字符串,第二个就不读整数了,直接读字符串转字符(Scanner没法直接读字符,所以用charAt)

        for (int i = 0; i < (t - 1); i++)
            System.out.println(ans[i]);

        System.out.print(ans[t - 1]); //强迫症,最后一个输出不换行
    }
}
```
但是面向对象好长啊~~
###### ~~还是用Python吧~~

---

## 作者：doby (赞：10)

直接高精乘……

没有什么好解释的了……

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int t,n,ans[5009],a,fir,sum;
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        cin>>n>>a;
        memset(ans,0,sizeof(ans));
        fir=0,sum=0,ans[1]=1;
        for(int j=1;j<=n;j++)//高精乘
        {
            for(int k=1;k<=5000;k++){if(ans[k]==0){continue;}ans[k]=ans[k]*j;}
            for(int k=1;k<=5000;k++){if(ans[k]>9){ans[k+1]=ans[k+1]+ans[k]/10,ans[k]=ans[k]%10;}}
        }
        for(int j=5000;j>=1;j--){if(ans[j]==0&&fir==0){continue;}fir++;if(ans[j]==a){sum++;}}//一个个找+去前导0
        cout<<sum<<endl;
    }
    return 0;
}
```

---

## 作者：Go灬Fire (赞：8)

最近在学习java，来一发java~~水一哈~~

一开始担心会不会T掉，就悄摸摸地把询问按照第一关键字排了个序。

蒟蒻表示初入坑java不会调用函数，只能自己手写了个小归并。

~~(表示第一次给类创建数组，然后排序，还是蛮好玩的)~~
```java
import java.math.BigInteger;
import java.util.Scanner;
class Ques{
    int id,data,val;
}
public class Main {
    public static Ques[] a=new Ques[15];
    public static Ques[] b=new Ques[15];
    public static int[] ans=new int[15];
    public static String s;
    public static void mergeSort(int l,int r){
        if(l==r) return;
        int mid=(l+r)>>1;
        mergeSort(l,mid);mergeSort(mid+1,r);
        int i=l,j=mid+1,k=l;
        while(i<=mid && j<=r){
            if(a[i].data<a[j].data) b[k++]=a[i++];
            else b[k++]=a[j++];
        }
        while(i<=mid) b[k++]=a[i++];
        while(j<=r) b[k++]=a[j++];
        for(i=l;i<=r;i++) a[i]=b[i];
    }
    public static void main(String[] args){
        for(int i=0;i<15;i++){
            a[i]=new Ques();
            b[i]=new Ques();
        }
        Scanner cin=new Scanner(System.in);
        int T=cin.nextInt();
        for(int i=1;i<=T;i++) {
            a[i].id=i;
            a[i].data=cin.nextInt();
            a[i].val=cin.nextInt();
        }
        mergeSort(1,T);
        BigInteger now=BigInteger.ONE;
        int j=1;
        for(int i=1;i<=T;i++){
            while(j<=a[i].data){
                now=now.multiply(BigInteger.valueOf(j));
                j++;
            }
            s=now.toString();
            int len=s.length();
            int num=0;
            for(int k=0;k<len;k++)
                if(s.charAt(k)-'0'==a[i].val) num++;
            ans[a[i].id]=num;
        }
        for(int i=1;i<=T;i++) System.out.println(ans[i]);
    }
}

```


---

## 作者：fighter_OI (赞：6)

较简单。高精度乘法。

对于每个数，用高精度求阶乘，搜一遍即可。

标程：

```cpp
type arr=array[0..10000] of longint;
var m,n,i,j,k,s:longint; a:arr;

function cheng(a:arr;b:longint):arr;//低精度乘高精度
var k,i:longint;
begin
 cheng[0]:=a[0];
 k:=0;
 for i:=1 to cheng[0] do
  begin
   cheng[i]:=a[i]*b+k;
   k:=cheng[i] div 10;
   cheng[i]:=cheng[i] mod 10;
  end;
 while k>0 do
  begin
   inc(cheng[0]);
   cheng[cheng[0]]:=k mod 10;
   k:=k div 10;
  end;
end;
begin
 read(m);
 for i:=1 to m do
  begin
   read(n,k);
   a[0]:=1;
   a[1]:=1;
   for j:=2 to n do//求阶乘
    a:=cheng(a,j);
   s:=0;
   for j:=1 to a[0] do if a[j]=k then inc(s);//计数
   writeln(s);
  end;
end.
```

---

## 作者：Terrible (赞：5)

**思路**：高精+枚举

**首先**，我们计算出来n!用高精储存。

如果用int型数组存储的话，其实每一个int的数可以存储6位(0-999999)。
```cpp
#include<cstdio>
int main()
{
	int i=0x7FFFFFFF;
	printf("%d %d",i,i/1000);
}
```
这个程序输出： _2147483647_   _2147483_ ，那么意味着6位最大的int数乘以1000也不会爆炸。

用6位的int参与计算可以提速，减少内存。因此我们可以充分地利用int。

**然后**，我们枚举每一位的数字是不是数码a即可。
```cpp
#include<cstdio>
#define N 1000000 //宏定义，每个int变量取6位存储 
int main()
{
	int x[500]={}; //500个int变量，足以表示 1000! 
	register int T,n,h,a,i,j,sum;  //register提速 
	scanf("%d",&T);
	while(T--)  //T组数据 
	{
		scanf("%d%d",&n,&a);
		x[0]=1,h=0,sum=0;  //每次开始都要赋初值 
		for(i=1;i<=n;i++)  //计算n! 其中h表示栈顶 
		{
			for(j=0;j<=h;j++) //各位相乘 
				x[j]*=i;
			for(j=0;j<=h;j++) //进位 
				x[j+1]+=x[j]/N,x[j]%=N;
			if(x[h+1])h++; //如果溢出原来的栈顶，栈顶+1 
		}
		while(x[h]) //栈顶数据的6位不是每一位都可以枚举 
		{           //比如000001，数码a=0的话前5个0不能要 
			if(x[h]%10==a)sum++;
			x[h]/=10;  //这里可以方便计算，顺便清零 
		}
		for(i=0;i<h;i++)  //非栈顶数据枚举各位数字 
		{
			j=6; //枚举6次 
			while(j--)
			{
				if(x[i]%10==a)sum++;
				x[i]/=10;  //这里可以方便计算，顺便清零 
			}
		}
		printf("%d\n",sum);  //输出 
	}
}
```


---

## 作者：dqa2022 (赞：4)

这一道题涉及高精度；

计算出n的阶乘之后一位位判断是否为a，如果是则累加，最后输出累加结构即可.

代码（重载运算符版）：

```cpp
#include<cstdio>
#include<cstring>
const int MAXN=2570;
struct hprecision//结构体内重载运算符
{
    int len,s[MAXN];
    hprecision()//最初把每个高精度数赋值为0
    {
        len=1;
        memset(s,0,sizeof s);
    }
    void operator=(const char *a)//赋值定义
    {
        len=strlen(a);
        for (int i=0;i<len;i++)
            s[i]=a[len-i-1]-48;
    }
    void operator=(const int a)
    {
        char ch[11];
        sprintf(ch,"%d",a);
        *this=ch;
    }
    hprecision(const char *a)//赋值操作
    {*this=a;}
    hprecision(const int a)
    {*this=a;}
    hprecision operator*(const hprecision a)//重载“*”
    {
        hprecision b;
        b.len=len+a.len;
        for (int i=0;i<len;i++)
            for (int j=0;j<a.len;j++)
            {
                b.s[i+j]+=s[i]*a.s[j];
                b.s[i+j+1]+=b.s[i+j]/10;
                b.s[i+j]%=10;
            }
        if (!b.s[b.len-1])
            b.len--;
        return b;
    }
    hprecision operator*=(const hprecision a)//重载“*=”
    {
        *this=*this*a;
        return *this;
    }
}num;
int t,n,a,ans;
int main()
{
    scanf("%d",&t);
    while (t--)
    {
        scanf("%d%d",&n,&a);
        num=1;//勿忘初始化
        ans=0;
        for (int i=2;i<=n;i++)
            num*=i;
        for (int i=0;i<num.len;i++)
            if (num.s[i]==a)
                ans++;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：不到前10不改名 (赞：3)

//总体难度不高，是一道板子题
```
#include<stdio.h>
#include<string.h>
int srx[10001],sry,t,n,mzy,zjq,ylj,i,j,lhy;
void lgx(int t)//高精度阶乘
{
    srx[1]=1;//初始化
    sry=1;
    for(int i=1;i<=t;i++)
    {lhy=0;//清除余数
    for(int j=1;j<=sry;j++)
    {srx[j]=srx[j]*i+lhy;//千万不能先加余数，会影响下一次乘法运算时的值！
    lhy=srx[j]/10;//余数计算
    srx[j]%=10;}//进位
    srx[sry+1]+=lhy;//最后一个余数没有参与计算
    while(srx[sry+1])//处理位数
    {if(srx[sry+1]>=10)
    {srx[sry+2]=srx[sry+1]/10;
    srx[sry+1]%=10;}
    sry++;}}
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;++i)
    {scanf("%d%d",&mzy,&zjq);
    lgx(mzy);//阶乘
    for(j=sry;j>=1;--j)
    if(zjq==srx[j])//统计个数（反正我又没有压位，这题也不需要...）
    ylj++;//高精里（尤其是无压位情况，都不用分解数字，正方便找出现次数）
    printf("%d\n",ylj);
    memset(srx,0,sizeof(srx));//清0
    ylj=0;}
    return 0;
    }
```

---

## 作者：agicy (赞：3)

# 思路

显然，这道题要用**高精度+模拟**。

我们主要是要解决高精度算法中的数组大小问题。

根据我的**~~手动~~**计算，题目中最大的数据$1000!(n≤1000)$为：

> $40238726007709377354370243392300398571937486421071463254379...$（后面省略）

共$2568$位，为了保险起见，我们将数组大小设定为$3072$，即$3×2^{10}$

# 代码

代码如下。

```cpp
#include<stdio.h>
#include<string.h>

struct BIG_NUMBER{
	#define MAX_LENGTH 3072//使用宏定义，便于修改
	int NUMBER_UNIT[MAX_LENGTH+1],LENGTH;//数位与大小
	BIG_NUMBER(void){}
	BIG_NUMBER(const int num){
		memset(NUMBER_UNIT,0,sizeof(NUMBER_UNIT));
		NUMBER_UNIT[0]=num;
		Refresh();
		return;
	}
	void Refresh(void){//作用：更新每一个数位以及数的位数
		register int i;//寄存器更快些
		for(i=0;i<MAX_LENGTH;i++)
			if(NUMBER_UNIT[i]>=10)
				NUMBER_UNIT[i+1]+=NUMBER_UNIT[i]/10,
				NUMBER_UNIT[i]%=10;
		LENGTH=1;
		for(i=MAX_LENGTH-1;i>=0;i--)
			if(NUMBER_UNIT[i]){
				LENGTH=i+1;
				break;
			}
		return;
	}
	void operator*=(const int num){//重载运算符，使用更方便
		register int i;//寄存器更快些
		for(i=0;i<LENGTH;i++)
			NUMBER_UNIT[i]*=num;
		Refresh();
		return;
	}
	void Print(void){//输出，调试用
		register int i;//寄存器更快些
		for(i=LENGTH-1;i>=0;i--)
			printf("%d",NUMBER_UNIT[i]);
		return;
	}
};

int T,n,a;
BIG_NUMBER BIGNUMBER;//高精度数

int main(void){
	register int i,ans;//寄存器更快些
	scanf("%d",&T);
	while(T--){
		ans=0;//记得初始化
		scanf("%d%d",&n,&a);
		BIGNUMBER=1;//记得初始化
		for(i=2;i<=n;i++)
			BIGNUMBER*=i;//累乘，求阶乘
		for(i=0;i<BIGNUMBER.LENGTH;i++)
			if(BIGNUMBER.NUMBER_UNIT[i]==a)
				ans++;//统计答案
		printf("%d\n",ans);
	}
	return 0;
}
```

## [我的测评记录](https://www.luogu.org/recordnew/show/9534001)

---

## 作者：Drinkkk (赞：1)

/\*
P1591 题解

多次高精度乘低精度+循环枚举

\*/
```cpp
#include <cstdio>//头文件
#include <cstring>//头文件
int s[10001]={0},t=0,n=0//定义变量，s数组是用来存储答案的，因为答案可能会很大，所以要用高精，t表示这个数（即答案）有t位，n表示接下来要进行一次n的阶乘，即（n!）
int Cheng(int n)//用来进行乘法的函数（即Cheng）
{
    for(int i=1;i<=t;i++)//首先，先从1到n进行循环，让s数组的每一位都乘上一个n
    {
        s[i]*=n;//将s数组的第i位乘以n
    }
    for(int i=1;i<=t;i++)//从1到t进行循环（即循环s数组的每一位）
    {
        if(s[i]>9)//如果s数组的第i为需要进行进位操作
        {
            s[i+1]+=s[i]/10;//根据满十进一的原则，那么，我们可以得到（s[i+1]+=s[i]/10）
            s[i]%=10;//进完位之后剩下的（也可以写成s[i]=s[i]-(s[i]/10)*10）
            if(i+1>t)//如果当前所在的第i位是最高位
            {
                t++;//那么就将t加1
            }
        }
    }
    return 0;//返回0（结束这个函数）
}
int main()//主函数
{
    int c=0;//c代表的是接下来将会有c组数据
    scanf("%d",&c);//读入c（即读入接下来会有多少组数据）
    while(c--)//做c次循环（也可以写成for循环）
    {
        int ans=0,l=0;//初始化变量
        memset(s,0,sizeof(s));//将s数组的每一位都刷成0
        s[1]=1;//第一位一定要是1，因为0乘以任何数的结果都为0，所以s数组的第一位要是1
        t=1;//一开始这个数只有一位（请想一想t为什么不能为0）
        scanf("%d %d",&n,&l);//读入n和l（表示要问n!里面有多少个l这个数字）
        for(int i=1;i<=n;i++)//开始求n的阶乘（即n!）
        {
            Cheng(i);//将s数组乘以i这个数字
        }
        for(int i=t;i>=1;i--)//开始找n!里面有多少个l这个数字
        {
            if(s[i]==l)//如果找到了一个
            {
                ans++;//那么就将答案数加1
            }
        }
        printf("%d\n",ans);//输出答案
    }
    return 0;//结束程序
}
```

---


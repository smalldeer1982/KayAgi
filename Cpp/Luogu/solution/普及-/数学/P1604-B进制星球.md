# B进制星球

## 题目背景

进制题目，而且还是个计算器~~


## 题目描述

话说有一天，小 Z 乘坐宇宙飞船，飞到一个美丽的星球。因为历史的原因，科技在这个美丽的星球上并不很发达，星球上人们普遍采用 $B\ (2 \le B \le 36)$ 进制计数。星球上的人们用美味的食物招待了小 Z，作为回报，小 Z 希望送一个能够完成 $B$ 进制加法的计算器给他们。现在小 Z 希望你可以帮助他，编写实现 $B$ 进制加法的程序。

## 说明/提示

### 数据范围及约定

记 $n,m$ 分别表示两个 $B$ 进制数字的长度。

对于全部数据，$1\le n,m\le 2000$。

## 样例 #1

### 输入

```
4
123
321
```

### 输出

```
1110```

# 题解

## 作者：Taduro (赞：69)

让刚学高精加的蒟蒻发一下题解吧。

相信很多跟我一样的蒟蒻在看到B<=36时都吓到了，之后这题就一直没敢做，直到最近学了高精加才做出来。于是决定写一篇题解来帮助像我一样的蒟蒻理解一下高精加。

我们常用的高精加是在十进制下进行的，主要思路是将读入的字符串**逆序**转化成数组，（注意，逆序很重要，否则你无法解决加法的进位问题，个位也难以对齐），之后按位加减，当出现进位情况时，我们把十位上的数取出，当做进位加入下一位中，原位只保留个位。

在本题中并不一定是10进制，但基本思路是一样的。

不同之处：
    1. 输入会出现大写字母，但我们可以将大写字母转换成十进制下的两位数，这并不影响计算，最后再转成字母就好了

 2.计算时不是逢十进一而是逢B进一。
 
 3.想找不同也找不到了

付丑陋的代码：

```
#include<iostream>
#include<cstring>
using namespace std;
int a[2010],b[2010],c[2018],i,y,x,l1,l2,z;
char n[2001],m[2001];
int main(){
	cin>>z;
	cin>>n; cin>>m;
	l1=strlen(n); l2=strlen(m);
	for (i=0; i<l1; i++)
	  if (z>10&&n[i]>='A') a[l1-i]=n[i]-'A'+10;//字符串逆序存储
	  else a[l1-i]=n[i]-'0';//遇到字母转换成数字
	for (i=0; i<l2; i++)
	  if (z>10&&m[i]>='A') b[l2-i]=m[i]-'A'+10;//同上
	  else b[l2-i]=m[i]-'0';
	while (x<=l1||x<=l2){//高精加
		x++;//x是位数指针
		c[x]=y+a[x]+b[x]; //y是进位
		y=c[x]/z; c[x]%=z;//在z禁止下逢z进1
	}
	while (c[x]==0&&x>1) x--; //去除前导零
	for (i=x; i>=1; i--){
		if (c[i]<10) cout<<c[i];
        else cout<<(char)(c[i]+'A'-10);//z>10是要输出大写字母，类型要转换成char,否则会输出ASCII码
	}
	return 0;
}```

---

## 作者：憨憨儿 (赞：24)

根据题意，两个B进制数求和（2<=B<=36）

------------

我的答题思路如下：1.存下36进制所需要的数。这样可以寻找到每个进制中字母的对应数。
```c
char jinzhi[36]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'};
```
x，y数组用于存入，x1，x2用于转化整型用高精，ans存答案
```c
char x[2020],y[2020];
int x1[2020],t[2020],ans[2020];
```
照常存入和清零数组
```c
int n,l1,l2,i;
	cin>>n;
	cin>>x;
	cin>>y;
	l1=strlen(x);
	l2=strlen(y);
	for(int i=0;i<2020;i++)
	ans[i]=0,x1[i]=0,t[i]=0;
```
倒序存入整型数组，x1[0]为个位
```c
for(i=l1-1;i>=0;i--)
	{
		for(int j=0;j<36;j++)
		{
			if(x[i]==jinzhi[j])x1[l1-i-1]=j;
		}
	}
	for(i=l2-1;i>=0;i--)
	{
		for(int j=0;j<36;j++)
		{
			if(y[i]==jinzhi[j])t[l2-i-1]=j;
		}
	}
```
进行高精加法
```cpp
for(i=0;i<max(l1,l2);i++)
	{
		ans[i]+=x1[i]+t[i];
		if(ans[i]>=n)
		{
			ans[i+1]+=ans[i]/n;
			ans[i]%=n;
		}
	}
```
去除前导零
```c
int flag=0;//flag用于标记，清除前导0 
	for(int i=(max(l1,l2))+1;i>=0;i--)
	{
		if(ans[i]!=0)flag=1;
		if(flag==0)continue;
		else if(flag==1)
		{
			cout<<jinzhi[ans[i]];
		}
	}
```
好的，本蒟蒻的题解到此了，具体代码下面呈现，各位不喜勿喷。
```c
#include<bits/stdc++.h>
using namespace std;
char jinzhi[36]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'};
char x[2020],y[2020];
int x1[2020],t[2020],ans[2020];
int main()
{
	int n,l1,l2,i;
	cin>>n;
	cin>>x;
	cin>>y;
	l1=strlen(x);
	l2=strlen(y);
	for(int i=0;i<2020;i++)
	ans[i]=0,x1[i]=0,t[i]=0;
	for(i=l1-1;i>=0;i--)
	{
		for(int j=0;j<36;j++)
		{
			if(x[i]==jinzhi[j])x1[l1-i-1]=j;
		}
	}
	for(i=l2-1;i>=0;i--)
	{
		for(int j=0;j<36;j++)
		{
			if(y[i]==jinzhi[j])t[l2-i-1]=j;
		}
	}
	for(i=0;i<max(l1,l2);i++)
	{
		ans[i]+=x1[i]+t[i];
		if(ans[i]>=n)
		{
			ans[i+1]+=ans[i]/n;
			ans[i]%=n;
		}
	}
	int flag=0;//flag用于标记，清除前导0 
	for(int i=(max(l1,l2))+1;i>=0;i--)
	{
		if(ans[i]!=0)flag=1;
		if(flag==0)continue;
		else if(flag==1)
		{
			cout<<jinzhi[ans[i]];
		}
	}
	return 0;
}
```



---

## 作者：Continue (赞：22)





```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=2000+200;
const char* output="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
//输出时直接对应值，不需要将字母与数字分开讨论 
char s1[maxn],s2[maxn];
int a[maxn],b[maxn],c[maxn];
int change(char ch)
{
    if(isalpha(ch)) return ch-'A'+10;//是字母，就从10开始 如：A是10 
    else return ch-'0';//是数字，减去'0' 
}
int main()
{
    int mod;
    scanf("%d",&mod);//B进制数的实质是0~B-1的数组成，逢B进1 
    scanf("%s%s",s1,s2);
    int l1=strlen(s1),l2=strlen(s2);
    for(int i=0;i<l1;i++) a[i]=change(s1[l1-i-1]);//逆序转存至数组 
    for(int i=0;i<l2;i++) b[i]=change(s2[l2-i-1]);//方便进位 
    int l3=max(l1,l2);
    for(int i=0;i<l3;i++) {
        c[i]+=a[i]+b[i];
        c[i+1]+=c[i]/mod;//进位处理 
        c[i]%=mod;
    }
    if(c[l3]) l3++;//若存在最高位进位，len++ 
    for(int i=l3-1;i>=0;i--) printf("%c",output[c[i]]);
    return 0;
}
```

---

## 作者：xdc呀 (赞：15)

看到这一题，我第一个想的问题是进制的问题例如9到A，然后我就想用一个数组来存。  
```cpp
即
char jz[39]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
```
后面的话就和高精度加法一样了，只不过进制变了
```cpp
即
void pluss()
{
	int x=0;
    lc=1;
    while(lc<=la||lc<=lb)
    {
        c[lc]=a[lc]+b[lc]+x;
        x=c[lc]/n;
        c[lc]=c[lc]%n;
        lc++;
    }
    c[lc]=x;
   if(c[lc]==0) lc--;
}
```


这一题难度不大，主要是考怎么想进制转换的部分和高精度加法。






AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,la,lb,lc,a[2005],b[2005],c[3005];
char jz[39]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
string s1,s2;
//模块化思想
void in()
{
scanf("%d",&n);
cin>>s1;
cin>>s2;
}
int num(char yu)
{
	if(yu>='0'&&yu<='9')
	return yu-48;
	if(yu>='A'&&yu<='Z')
	return yu-55;
}
void pluss()
{
	int x=0;
    lc=1;
    while(lc<=la||lc<=lb)
    {
        c[lc]=a[lc]+b[lc]+x;
        x=c[lc]/n;
        c[lc]=c[lc]%n;
        lc++;
    }
    c[lc]=x;
   if(c[lc]==0) lc--;
}
void out()
{
	for(int i=lc;i>=1;i--)
	cout<<jz[c[i]];
}
int main()
{
    in();
    la=s1.size();
    lb=s2.size();
    for(int i=1;i<=la;i++)
    {
        a[i]=num(s1[la-i]);
    }
    for(int i=1;i<=lb;i++)
    {
        b[i]=num(s2[lb-i]);
    }
    pluss();
    out();
}
```


---

## 作者：_Holo_ (赞：10)

## ~~萌新题解，大佬勿喷，建议新手看~~
### 思路就是将输入的字符串转化为数字，然后逢b(这里是n)进一，然后输出
```
#include<iostream>
#include<string>
#include<cstring>
#include<math.h>
using namespace std;
int n;
string a,b;
int a2[2010],b2[2010];
int main()
{
	cin>>n>>a>>b;
	int l=a.size(),ok=2001;
	for(int i=l-1;i>=0;i--)//把字符串转化为数字并存在数组里
	{
		ok--;
		for(int j=0;j<26;j++)//判断是否为字母
		if(a[i]==j+'A')
		{
			a2[ok]=a[i]-'A'+10;
			break;
		}
		for(int j=1;j<=9;j++)//判断是否为数字
		if(a[i]-'0'==j)
		{
			a2[ok]=a[i]-'0';
			break;
		}
	}
	l=b.size(),ok=2001;
	for(int i=l-1;i>=0;i--)//和上面一样
	{
		ok--;
		for(int j=0;j<26;j++)
		if(b[i]==j+'A')
		{
			b2[ok]=b[i]-'A'+10;
			break;
		}
		for(int j=1;j<=9;j++)
		if(b[i]-'0'==j)
		{
			b2[ok]=b[i]-'0';
			break;
		}
	}
	for(int i=2000;i>=2000-l+1;i--)//做加法
	{
		a2[i]+=b2[i];//加法
		int i2=i;
		while(a2[i2]>=n)//判断是否要进位
		{
			a2[i2-1]+=a2[i2]/n;//进位
			a2[i2]%=n;//去掉进位部分
			i2--;
		}
	}
	for(int i=0;i<=2000;i++)//把零去掉
	if(a2[i])//判断不为零
	{
		ok=i;
		break;
	}
	for(int i=ok;i<=2000;i++)//输出
	{
		if(a2[i]>9) cout<<char('A'+a2[i]-10);//判断是否要转化为字母输出
		else cout<<a2[i];
	}
	return 0;
}
```

---

## 作者：brealid (赞：10)

> 题目:[P1604 B进制星球](https://www.luogu.org/problemnew/show/P1604)

> 本人提交记录:[R6292872](https://www.luogu.org/record/show?rid=6292872)

作为一个~~极其无聊~~的人，我~~没事干地~~写了operator。。。

思路很简单：

> 读入b

> 读入b进制的x，y

> ans = x + y

> 输出ans

用了operator，貌似难解释一点。

但我认为，以大家那**都高于我**的智商，不会不理解高精加法。

我只需要介绍一下一些变量和函数%%%

```pseudocode
全局变量 b : b进制
struct类型 bint : b进制高精数
bint类型 x，y，ans : x，y用于输入，ans存储答案值
```
还要介绍一下bint类型的变量&方法orz：
```pseudocode
beta 存储高精数
len 存储高精数长度

bint() 初始化
mem() 初始化，形参为初始化后每位的值
operator + () 加法operator定义
operator >> () 输入operator定义
operator << () 输出operator定义
```
最后上代码：

```cpp
#include <string.h>
#include <iostream>
#define MAX 2001
using namespace std;

int b;

struct bint {
	int beta[MAX];
	int len;
	bint()
	{
		mem(0);
		len = 0;
	}
  	void mem(int cmd)
  	{
  		memset(beta, cmd, sizeof(beta));
  	}
  	bint operator + (const bint &other) const
  	{
		if (len == 0) return other;
		if (other.len == 0) return *this;
		bint ans;
		int maxlen = len > other.len ? len : other.len;
		for (int i = 0; i < maxlen; i++) {
			ans.beta[i] += beta[i] + other.beta[i];
			ans.beta[i + 1] += ans.beta[i] / b;
			ans.beta[i] = ans.beta[i] % b;
		}
		if (ans.beta[maxlen] != 0) ans.len = maxlen + 1;
		else ans.len = maxlen;
		return ans;
  	}
  	friend istream &operator >> (istream &in, bint &other)
  	{
		string str;
		in >> str;
		for (int i = 0; i < str.size(); i++) {
			if (str[i] > '9') other.beta[str.size() - i - 1] = str[i] - 55; 
			else other.beta[str.size() - i - 1] = str[i] - 48;
		}
		other.len = str.size();
  	}
  	friend ostream &operator << (ostream &out, bint &other)
  	{
		for (int i = other.len - 1; i >= 0; i--) {
			if (other.beta[i] > 9) out << (char)(other.beta[i] + 55); 
			else out << (char)(other.beta[i] + 48);
		}
  	}
};

int main()
{
	bint x, y, ans;
	cin >> b;
	cin >> x;
	cin >> y;
	ans = x + y;
	cout << ans;
    return 0;
}
```
~~慢慢~~看。。。

---

## 作者：gy5461 (赞：7)

```java
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.LinkedHashSet;
import java.util.Iterator;
import java.io.*;
import java.applet.*;
import  java.util.Collections.*;
public class Main {
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int b;
        b = sc.nextInt();
        String t1=sc.next(),t2=sc.next();
        //从原进制转换为10进制
        String s1 = new BigInteger(t1,b).toString(10);
        String s2 = new BigInteger(t2,b).toString(10);
        //两个十进制的大数相加
        BigInteger x,y;
        x = new BigInteger(s1);
        y = new BigInteger(s2);
        x = x.add(y);
        //将相加结果转换为原进制
        String ans=new BigInteger(x.toString(),10).toString(b);
        System.out.println(ans.toUpperCase());
    }
}

```

---

## 作者：血色心魔 (赞：6)

n进制，其实和高精唯二的区别就是模数不同，同时数字里多了ABCDEFG...XYZ这26个字母，那么只需改一下读入，改一下输出就行了。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
struct num{
	int a[100003];
	//bool zf;
};
num a,b,c;
int n;
inline void getin(num &a){
	string s;
	cin>>s;
	a.a[0]=s.length();
	for(int i=1;i<=a.a[0];i++){
		if(s[a.a[0]-i]>='0'&&s[a.a[0]-i]<='9')a.a[i]=s[a.a[0]-i]-'0';
		else if(s[a.a[0]-i]>='A'&&s[a.a[0]-i]<='Z'){
			a.a[i]=s[a.a[0]-i]-55;//A=10，B=11，......
		}
	}
}
inline void add(num a,num b){
	int i=1,x=0;
	while(i<=a.a[0]||i<=b.a[0]){
		c.a[i]=a.a[i]+b.a[i]+x;
		x=c.a[i]/n;
		c.a[i]%=n;//模数由10变成n，其实和压位差不多，压位的模数是1*10^n（n为要压的位数）
		i++;
	}
	c.a[i]+=x;
	while(!c.a[i]&&i>1)i--;
	c.a[0]=i;
}//高精加，模拟竖式
int main(){
	cin>>n;
	getin(a);
	getin(b);
	add(a,b);
	for(int i=c.a[0];i>0;i--){
		if(c.a[i]<10)cout<<c.a[i];
		else if(c.a[i]==11)cout<<"B";
		else if(c.a[i]==12)cout<<"C";
		else if(c.a[i]==13)cout<<"D";
		else if(c.a[i]==14)cout<<"E";
		else if(c.a[i]==15)cout<<"F";
		else if(c.a[i]==16)cout<<"G";
		else if(c.a[i]==17)cout<<"H";
		else if(c.a[i]==18)cout<<"I";
		else if(c.a[i]==19)cout<<"J";
		else if(c.a[i]==20)cout<<"K";
		else if(c.a[i]==21)cout<<"L";
		else if(c.a[i]==22)cout<<"M";
		else if(c.a[i]==23)cout<<"N";
		else if(c.a[i]==24)cout<<"O";
		else if(c.a[i]==25)cout<<"P";
		else if(c.a[i]==26)cout<<"Q";
		else if(c.a[i]==27)cout<<"R";
		else if(c.a[i]==28)cout<<"S";
		else if(c.a[i]==29)cout<<"T";
		else if(c.a[i]==30)cout<<"U";
		else if(c.a[i]==31)cout<<"V";
		else if(c.a[i]==32)cout<<"W";
		else if(c.a[i]==33)cout<<"X";
		else if(c.a[i]==34)cout<<"Y";
		else if(c.a[i]==35)cout<<"Z";
		else if(c.a[i]==10)cout<<"A";//输出所有数对应的字母
	}
	return 0;
}
```


---

## 作者：CreeperK (赞：5)

##其实此题只需要在读入时进行小小的修改，把A~Z转换成相应的数字，就可减少代码量，输出同理。

其它就是高精度加法，难度不大。

###附上代码，希望能对大家有所帮助：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[2005],b[2005],c[4005];
void add(){//加法函数 
    c[0]=a[0]>b[0]?a[0]:b[0];//确定数位 
    int g=0;
    for(int i=1;i<=c[0];i++){
        c[i]=a[i]+b[i]+g;//加法 
        g=c[i]/n;//计算余数 
        c[i]%=n;
    }
    if(g!=0){
        c[++c[0]]=g;
        g=0;
    }//消掉余数 
}
void write(){//输出 
    for(int i=c[0];i>=1;i--){
        if(c[i]>=10)printf("%c",(char)c[i]+55);//>10时输出A~Z 
        else printf("%d",c[i]);//输出数字 
    }
}
void read(int e[]){//读入 
    char str[2005];
    scanf("%s",str);
    int len=strlen(str);
    for(int i=0;i<len;i++){
        if(str[i]>='A'&&str[i]<='Z')e[len-i]=str[i]-'A'+10;//A~Z读入的转换 
        else e[len-i]=str[i]-'0';
    }
    e[0]=len;
    while(e[len]==0&&len!=1)len--;//去掉前导0 
    e[0]=len;
}
int main(){
    scanf("%d",&n);//读入进制 
    read(a);
    read(b);//读取数字 
    add();//相加 
    write();//输出 
}
```

---

## 作者：咖喱茴香 (赞：4)

高精问题怎么能没有python的题解

我先来水一篇

直接将2个数分别转换为10进制相加

然后将结果转换为n进制输出就行了

具体看代码注释

上代码

```python
# 用来存 0~Z 对应的数值
dic = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12,
       'D': 13, 'E': 14, 'F': 15, 'G': 16, 'H': 17, 'I': 18, 'J': 19, 'K': 20, 'L': 21, 'M': 22, 'N': 23, 'O': 24,
       'P': 25, 'Q': 26, 'R': 27, 'S': 28, 'T': 29, 'U': 30, 'V': 31, 'W': 32, 'X': 33, 'Y': 34, 'Z': 35}

# 求字符串对应的10进制的值
def init_10(str):
    count = len(str) - 1
    ans = 0
    for num in str:
        ans += dic[num] * n**count
        count -= 1
    return ans

# 将10进制的值转换为n进制的字符输出
def init_n(num):
    l = []
    while num:    # 反复取余数
        l.append(num % n)
        num //= n
    ans = l[::-1]    # 将列表翻转,再从前往后遍历
    for i in ans:
        if 0 <= i <= 9:
            print(i, end='')     # 如果是0~9则原样输出
        else:
            print('%c' % chr(ord('A') - 10 + i), end='')   # 转化为对应的字符再输出


n = int(input())
a = input().strip()   # 一定要加strip() 不然会RE
b = input().strip()
a = init_10(a)   # 转化为10进制的数
b = init_10(b)
init_n(a+b)    # 将2个10进制的数相加后转换为nj进制输出

```


---

## 作者：木兮 (赞：2)

C++题解
思路简单
高精加法+进制维护
具体见代码注释
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
int a1[2005],b1[2005];
char nu[37]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
//非常暴力的作法，但是很方便 
using namespace std;
int main()
{
	int n,la,lb,lc,k;
    string a,b;
	//用string类型进行存储，不会的自行学习
	//注意string类型和char[]类型的区别，百度上很多，自己去看 
    cin>>n;
    cin>>a>>b;
    la=a.size();
    lb=b.size();//获取两个加数的长度，好转换为int类型 
    lc=max(la,lb)+1;//a、b之和的长度最大不超过两数中较大的那个的长度+1 
    k=1; 
    for(int i=la-1;i>=0;i--)
	{
		if(a[i]>='0'&&a[i]<='9')a1[k++]=a[i]-'0';
		else  a1[k++]=a[i]-55;
	}//倒序转换为int（注意string从0开始） 
	//注意大写字母和数字的ASCII码不是连在一起的，注意判断！！ 
	//还有判断数字是从0到9，不是1到9或1到10！！
	//各位擦亮你们的眼睛了，不要一个眼花就像我一样了啊 
    k=1;
    for(int i=lb-1;i>=0;i--)
	{
		if(b[i]>='0'&&b[i]<='9')b1[k++]=b[i]-'0';
		else  b1[k++]=b[i]-55;
	}//同上 
    for(int i=1;i<=lc;i++) b1[i]+=a1[i];//直接相加，不管进位 
    for(int i=1;i<=lc;i++)
    {
		b1[i+1]+=b1[i]/n;
		b1[i]%=n;
	}//进行b进制进位处理 
	while(b1[lc]==0) lc--;//去除前导0 
	for(int i=lc;i>=1;i--) printf("%c",nu[b1[i]]);
	//刚刚倒序存的，现在倒序 输出 （注意是输出b1[i]对应的字符） 
    
    return 0;
}
```

---

## 作者：汇文客 (赞：2)

这道题关键是要理解高精度算法的本质——模拟。十进制如此，B进制是一样的。还有一点就是字母，输入时将其转化为相应数字，输出时再转化回去。

```delphi

var s1,s2:ansistring;
    a,b,c:array[1..2010]of integer;
    i,l,n:integer;
procedure swap(var s1,s2:ansistring);
var s:ansistring;
begin
  s:=s1;
  s1:=s2;
  s2:=s;
end;

begin
  readln(n);
  readln(s1);
  readln(s2);
  fillchar(a,sizeof(a),0);
  fillchar(b,sizeof(b),0);
  fillchar(c,sizeof(c),0);
  if((length(s1)=length(s2))and(s1<s2))
  or(length(s1)<length(s2))then swap(s1,s2);
  l:=length(s1);
  for i:=1 to l do
  begin
    a[l-i+1]:=ord(s1[i])-48;
    if a[l-i+1]>=17 then
    dec(a[l-i+1],7);
  end;
  for i:=1 to length(s2) do
  begin
    b[length(s2)-i+1]:=ord(s2[i])-48;
    if b[length(s2)-i+1]>=17 then
    dec(b[length(s2)-i+1],7);
  end;
  for i:=1 to l do
  begin
    c[i]:=a[i]+b[i]+c[i];
    if c[i]>=n then
    begin
      c[i+1]:=c[i+1]+c[i] div n;
      c[i]:=c[i] mod n;
    end;
  end;
  if c[l+1]>0 then inc(l);
  for i:=l downto 1 do
  if c[i]<=9 then write(c[i])
  else write(chr(c[i]-10+ord('A')));
  writeln;
end.

```（pascal）

---

## 作者：royzhu (赞：2)


这题很水，就是一个高精加和两个转进制

1，先把两个b进制数转成十进制

2，高精加这两个数

3，转回b进制，输出


```cpp
#include<cstdio>
#include<cstring>
char e[4100],f[4100],jz[41]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};//暴力把两个数转回b进制 
int a[4100],b[4100],c[4100],a1,b1,c1,n;
int main()
{
    scanf("%d %s %s",&n,e+1,f+1);//输入 
    a1=strlen(e+1);b1=strlen(f+1);//得到e和 f的长度 
    /////////////////////////////////////////////// 把两个b进制数转成十进制（要倒着转进制） 
    for(int i=1;i<=a1;i++)
    {
        if(e[i]>='1'&&e[i]<='9')a[a1-i+1]=e[i]-'0';//读数字 
        else if(e[i]>='A'&&e[i]<='Z')a[a1-i+1]=10+e[i]-'A';//读字母（A表示10，所以要加10） 
    }
    for(int i=1;i<=b1;i++)//同上 
    {
        if(f[i]>='1'&&f[i]<='9')b[b1-i+1]=f[i]-'0';//读数字
        else if(f[i]>='A'&&f[i]<='Z')b[b1-i+1]=10+f[i]-'A';//读字母（A表示10，所以要加10） 
    }
    ////////////////////////////////////////////高精加
    c1=a1>b1?a1:b1;//高精加的最高位（没转进制前） 
    for(int i=1;i<=c1;i++)
    {
        c[i]=a[i]+b[i];
```
}//这两段不要合起来（合起来会有问题）
```cpp
    for(int i=1;i<=c1;i++)
    {
        if(c[i]>=n)
        {
            c[i+1]+=c[i]/n;
            c[i]%=n;
            if(i+1>c1)c1++;
        }
    }
    for(int i=c1;i>=1;i--)printf("%c",jz[c[i]]);//暴力把两个数和转回b进制 
}
```

---

## 作者：邱彦祖 (赞：1)

和一般的高精度加法类似，只需要作两点小小的改动：

1、
将原来的%10改为%B，将原来的/10改为/B。

2、
当结果大于10时，不再储存为ans + ‘0’，而是 ans - 10 + ‘A’，当加数的对应的位为字母时，需要通过同样的关系转化为对应的数字。

下面是AC代码：


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
void add(int B,char a[],char b[],char ans[]);
char a[2003],b[2003],ans[2004];

int main()
{
    int i,j,B;

    while(cin>>B)
    {
        cin>>a>>b;
        add(B,a,b,ans);
        cout << ans<<endl;
    }
    return 0;
}
void add(int B,char a[],char b[],char ans[]) //保证a比b长。
{
    int i,len1,len2,cnt,j,k,temp;

    len1 = strlen(a),len2 = strlen(b);
    cnt = 0;
    for(i=len1-1,j=len2-1,k=0;j>=0;i--,j--,k++)
    {
        if(a[i]>='0'&&a[i]<='9')
            a[i]-='0';
        else a[i]=a[i]-'A'+10;
        if(b[j]>='0'&&b[j]<='9')
            b[j]-='0';
        else b[j]=b[j]-'A'+10;
        temp = a[i]+b[j]+cnt;
        if(temp%B<=9)
        ans[k]=temp%B+'0';
        else ans[k] = temp%B+'A'-10;
        cnt = temp/B;
    }
    for(;i>=0;i--,k++)
    {
        if(a[i]>='0'&&a[i]<='9')
            a[i]-='0';
        else a[i]=a[i]-'A'+10;
        temp = a[i]+cnt;
        if(temp%B<=9)
        ans[k]=temp%B+'0';
        else ans[k] = temp%B+'A'-10;
        cnt = temp/B;
    }
    if(cnt)
    ans[k++]=cnt+'0';
    for(i=0,j=k-1;i<j;i++,j--)
        swap(ans[i],ans[j]);
    ans[k]='\0';
}


```

附上一般的高精度加法：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
void  add(char a[],char b[],char ans[]);
int main()
{
    char a[505],b[505],ans[505];

    cin>>a>>b;
    if(strlen(a)>strlen(b))
    add(a,b,ans);
    else  add(b,a,ans);
    cout << ans<<endl;
    return 0;
}
void add(char a[],char b[],char ans[]) //保证a比b长。
{
    int i,len1,len2,cnt,j,k,temp;

    len1 = strlen(a),len2 = strlen(b);
    cnt = 0;
    for(i=len1-1,j=len2-1,k=0;j>=0;i--,j--,k++)
    {
        temp = a[i]-'0'+b[j]-'0'+cnt;
        ans[k]=temp%10+'0';
        cnt = temp/10;
    }
    for(;i>=0;i--,k++)
    {
        temp = a[i]-'0'+cnt;
        ans[k] = temp%10+'0';
        cnt = temp/10;
    }
    if(cnt)
    ans[k++]=cnt+'0';
    for(i=0,j=k-1;i<j;i++,j--)
        swap(ans[i],ans[j]);
    ans[k]='\0';
}

```

---

## 作者：元夕 (赞：1)


### 本题构成：高精度+进位制
### 实现方法：string+数组（高精度）

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int maxn = 2000 + 5;
int a[maxn],b[maxn],c[maxn],i,up;//a,b为加数，up为进制
string add1,add2;//a,b的字符串输入
int g(char c){
    if(isalpha(c)){
        return c-'A'+10;//如果c是字符（数据保证为大写字母A~Z），改为数字
        //'A'是10
    } else {
        return c-'0';//不是字母，则为数字，减掉'0'即可（字符减字符为ASCLL码相减）
    }
}//字符变更为数字函数
int main(){
    cin>>up;
    cin>>add1; cin>>add2;
    int l1=add1.size(),l2=add2.size();//l1是add1的长，l2是add2的长
    for (i=0; i<l1; i++)
        a[l1-i]=g(add1[i]);
   	for (i=0; i<l2; i++)
        b[l2-i]=g(add2[i]);//倒序处理
   	int l=max(l1,l2);//l为最大长度
    for (i=1;i<=l;i++){
        c[i]+=a[i]+b[i]; //相加
        if(c[i]>=up){//进位
            c[i+1]++;
            c[i]-=up;
        }
    }
    if(c[l+1])l++;//如果处理l+1有l的进位，则l=l+1
    for (i=l; i>=1; i--){
        if (c[i]<10) cout<<c[i];
        else cout<<(char)(c[i]+'A'-10);
    }//倒回来输出
    return 0;
}
```

---

## 作者：tjztjz (赞：1)

题目很简单，做一个高精度加法就好了，只需要稍微做一个进制转换就好了。
没想到数据那么的水...不加优化就能过...
    
    
    
    
    
    
    #include <iostream>
	#include <cmath>
	#include <cstring>
	#include <cstdlib>
	#include <cstdio>
	#include <algorithm>
    using namespace std;
	int n, i;
	char ina[100001], inb[100001];
	int a[100001], b[100001];
	int c[100001];
	int main()
	{
    	cin >> n;
    	cin >> ina >> inb;
    	int la, lb;
    	la = strlen(ina); lb = strlen(inb);
    	for (i = 1; i <= la; ++i)
    	{
			if (ina[la - i] >= 'A' && ina[la - i] <= 'Z')
				a[i] = ina[la - i] - 'A' + 10;
			else
				a[i] = ina[la - i] - '0';
		}
		for (i = 1; i <= lb; ++i)
    	{
			if (inb[lb - i] >= 'A' && inb[lb - i] <= 'Z')
				b[i] = inb[lb - i] - 'A' + 10;
			else
				b[i] = inb[lb - i] - '0';
		}
		for (i = 1; i <= max(la, lb) + 10; ++i)
		{
			if (a[i] == 0 && b[i] == 0 && c[i] == 0)
			{
				continue;
			}
			c[i] += a[i] + b[i];
			if (c[i] >= n)
			{
				c[i + 1] = c[i] / n;
				c[i] = c[i] % n;
			}
		}
		for (i = 100000; i >= 1; --i)
		{
			if (c[i] != 0)
			{
				break;
			}
		}
		for (; i >= 1; --i)
		{
			if (c[i] >= 10)
				cout << char(c[i] - 10 + 'A');
			else
				cout << c[i];
		}
 	   return 0;
	}


---

## 作者：juju527 (赞：1)

适合刚入门高精度新手做~~（像本蒟蒻）~~

```c
#include <bits/stdc++.h>
using namespace std;
char a1[3000],b1[3000];
int a[3000],b[3000],c[3000],la,lb,lc=1,x=0;
int main()
{
	int B;
	cin>>B;
	cin>>a1;cin>>b1;
	la=strlen(a1);lb=strlen(b1);
	for(int i=0;i<la;i++){
		if(a1[i]>='0'&&a1[i]<='9')
		a[la-i]=a1[i]-'0';
		else
		a[la-i]=a1[i]-'A'+10;
	}
	for(int i=0;i<lb;i++){
		if(b1[i]>='0'&&b1[i]<='9')
		b[lb-i]=b1[i]-'0';
		else
		b[lb-i]=b1[i]-'A'+10;
	}
	while(lc<=la||lc<=lb){
		c[lc]=a[lc]+b[lc]+x;
		x=c[lc]/B;
		c[lc]%=B;
		lc++;
	}
	c[lc]=x;
	while(c[lc]==0&&lc>1)lc--;
	for(int i=lc;i>=1;i--){
		if(c[i]>=10)
		cout<<(char)(c[i]+'A'-10);
		else
		cout<<c[i];
	}
	return 0;
}
```

---

## 作者：shengmingkexue (赞：1)

使用普通的高精度加法，但有以下几点要注意：

1.进位的时候模B而不是模10

2.读入时读到字母要特殊处理（ascii码-55）

3.输出时碰到大于等于10的数字要转化成相应的字母（ascii码+55）


---

## 作者：Lngstart (赞：0)

就是一个高精度的问题！不过在这里的进制发生了变化，是由自己输入的进制!

我们可以用数组模拟加法的运算过程，这也就是高精度！

这里就不赘述了！在代码中会有详细的注释！

题目中进制的范围为2~36就是把26个字母也加了进来，我们在运算的时候可以把它们转化成十进制，计算完之后就可以判定输出！

代码如下：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

vector<int> add(vector<int> a, vector<int> b, int n) {
	if (a.size() < b.size()) return add(b, a, n);//在这里保证了a的字符的长度会大于等于b

	vector<int> c;//定义了一个临时的空间
	int t = 0;//定义的一个记录每次每个位上的相加大小（带进位）
	for (int i = 0; i < a.size(); ++i) {
		t += a[i];
		if (i < b.size()) t += b[i];//因为a的长度会大于等于b的长度
		c.push_back(t % n);
		t = t / n;
	}
	if (t) c.push_back(t);//判定是否要进行最后的进位
	return c;
}
int main() {
	vector<int> a, b;
	int n;
	string str;
	cin >> n;
	cin >> str;
	for (int i = str.size() - 1; i >= 0; --i)//利用string进行输入，然后逆序储存在vector中
		if (str[i] > '9')
			a.push_back(str[i] - 'A' + 10);//如果是非数字类型的那么就转化成十进制进行运算
		else
			a.push_back(str[i] - '0');
	cin >> str;
	for (int i = str.size() - 1; i >= 0; --i)
		if (str[i] > '9')
			b.push_back(str[i] - 'A' + 10);//同理上述
		else 
			b.push_back(str[i] - '0');
	vector<int> c = add(a, b, n);//调用函数
	for (int i = c.size() - 1; i >= 0; --i)
		if (c[i] > 9)
			cout << char(c[i] - 10 + 'A');//进行判断输出
		else
			cout << c[i];
	return 0;
}
```

---

## 作者：F201843 (赞：0)

java题解
```java
import java.util.Scanner;
import java.math.BigInteger;
public class Main {
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
       int x = cin.nextInt(); //读入进制
        String ss=cin.nextLine(); //读取数字后的空格
        String s = cin.nextLine();//读入数值
        String s2=cin.nextLine();//读入数值
        String s11=Transform(s,x,10);//转成10进制
        String s21=Transform(s2,x,10);
        BigInteger val=new BigInteger(s11,10);//字符串转大数
        BigInteger val2=new BigInteger(s21,10);
        BigInteger ll=val.add(val2);//两个大数相加
        String po=String.valueOf(ll);//大数转字符串
        String poo=Transform(po,10,x);//十进制和转为输入的进制
         System.out.println(poo.toUpperCase());//输出，注意字母大写
    }
    s:要转的字符串，x:原数进制，y:要转的进制
    public static String Transform(String s,int x,int y)
    {
        return new java.math.BigInteger(s,x).toString(y);
    }

}
```


---

## 作者：_CHO (赞：0)

### 非常不错的一道题，进制转换与高精度的完美结合
这道题的总体难度不高，但是也有一些点需要注意，不然就会各种~~WA RE CE~~

下面进入正题，首先是读入数据，这一部分的难点在于进制大于10时如何处理——这也时整道题的难点之一。

这里我们选择分类讨论的思想，对读入的每一位数字，0-10常规处理（关于这种常规方法这里就不再赘述啦），A-Z（大于10）则采取另一种处理方法，没错！同样是利用ASCII这个神奇的东西。ASCII这个东西嘛，自己去看一下相信你会恍然大悟的。~~只可意会不可言传~~。

对于每一位A-Z的数字，由char型转变为int型只需减掉55，~~你非要写成'7'也不是不行~~，下面代码
```
scanf("%s",s1);
scanf("%s",s2);
int l1=strlen(s1);
int l2=strlen(s2);
for(int i=0;i<l1;++i)
{
	if(s1[i]>=48 && s1[i]<=57)
	{
		a[l1-i] = s1[i]-48;
	}
	else if(s1[i]>=65  && s1[i]<=90)
	{
		a[l1-i] = s1[i]-55;
	}
}
for(int i=0;i<l2;++i)
{
	if(s2[i]>=48 && s2[i]<=57)
	{
		b[l2-i] = s2[i]-48;
	}
	else if(s2[i]>=65  && s2[i]<=90)
	{
		b[l2-i] = s2[i]-55;
	}
}
```
下面就是计算的部分啦，在此之前，我们可以先回忆十进制的高精度加法，是如何进位的呢？？应该是这个样子
```cpp
res[i]+=(a[i]+b[i]);
if(res[i]/10)
{
	res[i+1]+= res[i]/10;
	res[i]%=10;
}
```
第一步，将加数与被加数相加得到对应的和；第二步，判断是否能进位：如果不能，结束；如果能，模拟**进位的过程**
那么仅为的过程是如何实现的呢？？代码已经很清晰了，10就是进制！

同样，这本题中，我们可以把进制约定为k，那么进位的部分就应该这样写：
```
for(int i=1;i<=l1||i<=l2;++i) //模拟竖式，依次相加每一位
{
	res[i]+=(a[i]+b[i]);
	if(res[i]/k)
	{
		res[i+1]+= res[i]/k;
		res[i]%=k;
	}
}
```

到这里，计算的过程已经Ok，下面需要处理的是仍然是一些细节。

前导零的处理，这一直是令很多萌新头疼的事，到底从第几位开始判定很难确定，不过我们可以多留出几位，比方说，由常识可知某一位一定为前导零，那么我们就从这一位开始判定，代码
```
int p=l1+l2;
while(res[p]==0 && p!= 1)
{
	--p;
}
```
PS：~~虽然这个方法比较容易去想，但是毕竟不利于自身的提高，继续学习建议使用更精准的方法~~

下面是输出的过程，由前面我们可以知道，应该从第p位，也就是res[p]开始输出，当然，我们在输出的过程中也要注意处理进制的问题。 这里我们仍然采用分类讨论的思想（具体看前面），代码如下：
```
for(int i=p;i>=1;--i)
{
	if(res[i]>=0 &&res[i]<=9)
	{
		printf("%d",res[i]);
	}
	else if(res[i]>=10&&res[i]<=35)
	{
		printf("%c",res[i]+55);
	}
}
```
到这里就OK啦，下面是完整代码：
```
#include <bits/stdc++.h>
using namespace std;

int k;
const int N=2000+10;
char s1[N],s2[N];
int a[N],b[N],res[N+N];

int main()
{
	scanf("%d",&k);
	scanf("%s",s1);
	scanf("%s",s2);
	int l1=strlen(s1);
	int l2=strlen(s2);
	
	for(int i=0;i<l1;++i)
	{
		if(s1[i]>=48 && s1[i]<=57)
		{
			a[l1-i] = s1[i]-48;
		}
		else if(s1[i]>=65  && s1[i]<=90)
		{
			a[l1-i] = s1[i]-55;
		}
	}
	
	for(int i=0;i<l2;++i)
	{
		if(s2[i]>=48 && s2[i]<=57)
		{
			b[l2-i] = s2[i]-48;
		}
		else if(s2[i]>=65  && s2[i]<=90)
		{
			b[l2-i] = s2[i]-55;
		}
	}
	
	for(int i=1;i<=l1||i<=l2;++i)
	{
		res[i]+=(a[i]+b[i]);
		if(res[i]/k)
		{
			res[i+1]+= res[i]/k;
			res[i]%=k;
		}
	}
	
	int p=l1+l2;
	while(res[p]==0 && p!= 1)
	{
		--p;
	}
	
	for(int i=p;i>=1;--i)
	{
		if(res[i]>=0 &&res[i]<=9)
		{
			printf("%d",res[i]);
		}
		else if(res[i]>=10&&res[i]<=35)
		{
			printf("%c",res[i]+55);
		}
	}
	
	return 0;
}
```

完结，撒花！！！

---

## 作者：Shmily_389704 (赞：0)

### 先来看一下十进制下的高精度加法：
##### （如果对高精度加法已经了解，可以跳过）
#### 1.字符串读入，再逐位分放到高精度数组里（注意！倒序放入，方便计算）
#### 2.像小学竖式加法一样一位一位的加起来，处理进位
#### 3.最后倒着输出；
### 以上步骤要记得记录位数，可以用结构体
## 看代码
### 字符串读入（函数）：
```
string s;
void init(HP &A,int l,int r)
{
    A.len=r-l+1;
    for(int i=1,j=r-1;j>=l-1;i++,j--)
        A.d[i]=s[j]-'0';
}
```
### 高精度加法（函数）：
```
void add(HP &a,HP X,HP Y)
{
    memset(a.d,0,sizeof(a.d));
    for(int i=1;i<=max(X.len,Y.len);i++)
    {
         a.d[i]=a.d[i]+X.d[i]+Y.d[i];
         if(a.d[i]>=10)//大于等于10就要进位
         {
            a.d[i+1]=a.d[i+1]+1;
            a.d[i]=a.d[i]%10;
         }
    }
     for(int i=maxn;i>=1;i--)
      if(a.d[i])//最高位一定不为0
      {
         a.len=i;
         break;
      }
}
```
### 倒序输出（函数）：
```
void pr(HP X)
{
    for(int i=X.len;i>=1;i--)
        cout<<X.d[i];
    cout<<endl;
}
```
### 下来看本题
####    本题不一样的就是它限定了是几进制，但这不影响，一样的做法，只是把基数（十进制下是10）改掉就好了
```
void add(HP &a,HP X,HP Y,int mod)
{
    memset(a.d,0,sizeof(a.d));
    for(int i=1;i<=max(X.len,Y.len);i++)
    {
         a.d[i]=a.d[i]+X.d[i]+Y.d[i];
         if(a.d[i]>=mod)
         {
            a.d[i+1]=a.d[i+1]+1;
            a.d[i]=a.d[i]%mod;
         }
    }
   for(int i=maxn;i>=1;i--)
      if(a.d[i])
      {
         a.len=i;
         break;
      }
}
```
#### 还有一个问题： 数字的每一位属于{0，1，2，3，4，5，6，7，8，9，A，B……}
#### 所以我们要在读入和输出的时候判断一下
### 读入
```
string s;
void init(HP &A,int l,int r)
{
    A.len=r-l+1;
    for(int i=1,j=r-1;j>=l-1;i++,j--)
    {   
       if(s[j]>='0'&&s[j]<='9')//直接放入数组
           A.d[i]=s[j]-'0';
       else//是字母，把它转化成大于等于10的数字
           A.d[i]=s[j]-'A'+10;
    }
}
```
### 输出
```
void pr(HP X)
{
    for(int i=X.len;i>=1;i--)
    {    
        if(X.d[i]>=10)//转化成字母输出
           cout<<char('A'+X.d[i]-10);
        else
           cout<<X.d[i];
    }
    cout<<endl;
}
```
### 完整代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=5000;
struct HP{
       int d[maxn];
       int len;
};
void add(HP &a,HP X,HP Y,int mod)
{
    memset(a.d,0,sizeof(a.d));
    for(int i=1;i<=max(X.len,Y.len);i++)
    {
         a.d[i]=a.d[i]+X.d[i]+Y.d[i];
         if(a.d[i]>=mod)
         {
            a.d[i+1]=a.d[i+1]+1;
            a.d[i]=a.d[i]%mod;
         }
    }
   for(int i=maxn;i>=1;i--)
      if(a.d[i])
      {
         a.len=i;
         break;
      }
}
string s,g;
void inits(HP &A,int l,int r)
{
    A.len=r-l+1;
    for(int i=1,j=r-1;j>=l-1;i++,j--)
    {   
        if(s[j]>='0'&&s[j]<='9')
           A.d[i]=s[j]-'0';
        else
           A.d[i]=s[j]-'A'+10;
    }
}
void initg(HP &A,int l,int r)
{
    A.len=r-l+1;
    for(int i=1,j=r-1;j>=l-1;i++,j--)
    {   
        if(g[j]>='0'&&g[j]<='9')
           A.d[i]=g[j]-'0';
        else
           A.d[i]=g[j]-'A'+10;
    }
}
void pr(HP X)
{
    for(int i=X.len;i>=1;i--)
    {    
        if(X.d[i]>=10)
           cout<<char('A'+X.d[i]-10);
        else
           cout<<X.d[i];
    }
    cout<<endl;
}
HP a,b,ans;
int mod;
int main()
{
    cin>>mod;
    cin>>s>>g;
    inits(a,1,s.length());
    initg(b,1,g.length());
    add(ans,a,b,mod);
    pr(ans);
    return 0;
}
```
蒟蒻第一次写题解，大佬轻喷

---

## 作者：寒武纪 (赞：0)

出于纯C的题解太少就水了一下(新手，勿喷)

思路:先计算A+B，然后从左往右扫描，大于N-1的**位**往前进1，**该位的新位值**等于**位值-N**(N表示n进制)。因为进1后前面可能会有等于N的部分，所以重复扫描多次即可。


输入:

获取字符串，再将字符串对应的只**值**储存到int数组，并且右对齐(方便计算A+B)

输出:16以上进制包含字母，但是int数组储存的是字符串对应的**数值**，直接输出结果是不对的。

解决方法:
char str[]={"0123456789ABCDEFGHIJKHIJKLMNOPQRST....Z"};
输出时以**位值**做为str的下标，依次输出即可。

完整代码:
```c
#include<stdio.h>
#include<string.h>
#define LEN 10000
int N;
int main() {
  char tempStr[LEN];
  char str[]={"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
  scanf("%d%s", &N, tempStr);
  int A[LEN] = { 0 }, B[LEN] = {
  0}, len = strlen(tempStr);
  for (int i = 0; i < len; i++)
    A[LEN - len + i] = tempStr[i] - (tempStr[i] > '9' ? 55 : '0');
  scanf("%s", tempStr);
  len = strlen(tempStr);
  for (int i = 0; i < len; i++)
    B[LEN - len + i] = tempStr[i] - (tempStr[i] > '9' ? 55 : '0');
  for (int i = 0; i < LEN; i++)
    A[i] += B[i];//计算A+B
  for (int temp = 0; temp <= N*2; temp++)//重复扫描N*2次
    for (int i = 1; i < LEN; i++)
      if (A[i] > N - 1) {
        A[i - 1] ++;
        A[i]=A[i] - N;
      }//进位
  int state = 0;
  for (int i = 0; i < LEN; i++) {
    if (!state && A[i])//过滤掉前面的0
      state = 1;
    if (state)
      printf("%c", str[A[i]]);
  }
  return 0;
}

```


---

## 作者：tcswuzb (赞：0)

暴力出奇迹   模拟过黑题

打表加乱搞   蒟蒻变dalao

------------------------------------吐槽时间---------------------------------------

更好的阅读体验 ？？？？

# [戳这里](https://www.luogu.org/blog/LovToLZX/)

首先 看到这道题的第一反应 不就是那高精吗？？

可是再看一眼 没那么简单~~就能去爱~~

我们需要使用正常的方法 用我们可以理解的数值运算来处理字符对应数值 的 运算 


楼下dalao 手写结构体+operator 本蒟蒻表示~~真心~~不会

可是我们该怎么改进高精呢 ？？？？

介绍一下本蒟蒻的几个**暴力**工具（dalao勿喷）

①STL的map ②高精度计算 ③线段树（现已成为暴力数据结构 其实是本蒟蒻不会好好用）④spfa算法 ⑤打表

本题如果使用 **map + 打表**

可以 加快计算 以及转换 

首先 map用字符对应数值  打的表用数值对应字符

相加时 

先用map转成数值运算  再用打的表转成字符存储ans

可以说是高精度的数据结构加打表的优化

-------------------------------吐槽再一次开始---------------------------------

（蒟蒻一开始**存储数位的数组没有开够** 竟然显示WA）

（开了氧气优化显示RE 于是才发现 最终AC）

**衷心祝愿各位不要再重蹈覆辙**

--------------------------------吐槽再一次结束--------------------------------

弱弱的奉上代码

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
char key[40]={'0','1','2','3','4','5','6','7','8',
'9','A','B','C','D','E','F','G','H',
'I','J','K','L','M','N','O','P','Q',
'R','S','T','U','V','W','X','Y','Z'};
map<char,int> Q;
int B,lena,lenb,lenc;
char s1[5011],s2[5010],s3[5010],s4[5010];
char ans[5010];
int main()
{
//	freopen("testdata.in","r",stdin);
//	freopen("testdata.out","w",stdout);
    read(B);
    Q['0']=0;Q['1']=1;Q['2']=2;Q['3']=3;Q['4']=4;Q['5']=5;Q['6']=6;Q['7']=7;
    Q['8']=8;Q['9']=9;Q['A']=10;Q['B']=11;Q['C']=12;Q['D']=13;Q['E']=14;Q['F']=15;
    Q['G']=16;Q['H']=17;Q['I']=18;Q['J']=19;Q['K']=20;Q['L']=21;Q['M']=22;Q['N']=23;
    Q['O']=24;Q['P']=25;Q['Q']=26;Q['R']=27;Q['S']=28;Q['T']=29;Q['U']=30;Q['V']=31;
    Q['W']=32;Q['X']=33;Q['Y']=34;Q['Z']=35;
/*    for(R int i=0;i<=35;++i)
     printf("%d to youngsc %c  too MlovTry %d %d\n",i,key[i],Q[key[i]],(Q[key[i]] == i ?  2333 : 555666));*/
    cin>>s1>>s2;lena=strlen(s1);lenb=strlen(s2);
    for(R int i=0;i<lena;++i) s3[lena-i]=s1[i];
    for(R int i=0;i<lenb;++i) s4[lenb-i]=s2[i];
/*    for(R int i=1;i<=lena;++i) cout<<s3[i];
    cout<<endl;
    for(R int i=1;i<=lenb;++i) cout<<s4[i];
    cout<<endl;*/
    lenc=1;int x=0;
    while(lenc<=lena || lenc<=lenb){
    	int tmp=Q[s3[lenc]]+Q[s4[lenc]];
//    	cout<<lenc<<" ---- "<<tmp<<"  ~~~~~~  "<<x<<"  youngsc is a dalao  "<<" aaaaaa "<<endl;
    	ans[lenc]=key[(tmp+x)%B];
    	x=(tmp+x)/B;
    	lenc++;
	}
	if(x) ans[lenc]=key[x];
	while(Q[ans[lenc]]==0 && lenc>1) lenc--;
	for(R int i=lenc;i;--i) cout<<ans[i];
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

其实有的时候 

我们过于追求卓越高效的解法 

却忽略了那些平凡朴素 但是简洁高效 照样可以AC的算法

所以 一道题 没有百分百把握 先写暴力 再写正解

**这是2018年我们学校参加HEOI省选的学长的血的教训**

NOIP 2018 即将到来 祝愿各位dalao RP++

---

## 作者：JustinRochester (赞：0)

这边来了一个励志于把主函数写得短小精悍而写了 $operator$ 的蒟蒻......

---

**【分析】**
--

很明显，题目就是把[P1601](https://www.luogu.org/problemnew/show/P1601)的进制改了改,数据范围改了改，其他都是不变的。

介于有一些人可能还不了解高精度，这边做一个简单的讲解(注意，前方玄学讲解)

已经了解的大犇请跳到下一条分割线下

对于一个整数，我们一般用 $int$ 储存，而对于更大的，我们需要用到 $long$ $int$ 、 $long$ $long$ $int$ 甚至 $unsigned$ $long$ $long$ $int$

而对于再大一点的，我们就没办法用已有的变量来存了($int128$ 除外，那个好像很多地方不能用)

因此，我们必须靠手写一个新的变量

这个跨越可能对于第一次接触的人来说挺匪夷所思的，但其实很好理解。就如对于已有的函数不能满足我们需求的时候，我们需要自己写函数

好的，我们继续

对于这个新的变量，它要储存一个很大的数，我们暂且称呼它为大数($bignum$)

那么，对于大数，我可以把它的每一位都看作一个单独的数，那么，这个大数就可以用一个数组来描述。

比如，我对于 $314159265358972718281829$ 这个数，我们用一个数组$n_i$去描述它

那么，我们该把 $3$ 视为 $n_0$ 还是把 $9$ 视为 $n_0$ 呢？

我们来考虑一下进位

如果两个数进行运算后需要进位，那么进位是进在最左边那个数字的左边

如果我们把 $3$ 作为 $n_0$ ，那么进位时多出来的数字得往前存到 $n_{-1}$ ，这岂不是匪夷所思吗？

相反，如果我们把 $9$ 作为 $n_0$ 那么，进位时 $3$ 的进位只要再往后一个就可以了

因此，我们习惯把数字的最后一个数作为 $n_0$ ，倒数第二个为 $n_1$ ，以此类推(这里暂时不考虑压位)

对此，我们还要一个东西来描述这个数字，就是这个数字是几位数

它的意义就是数组 $n_i$ 的大小，我们可以一个变量 $l$ 来维护

那么，对于这题，我们还需要一个变量 $b$ 来维护其进制数

---

好的，那我们接下来考虑如何实现 $bignum$ 的加法

我们通过列竖式可以发现，我们进行十进制数的加法时，习惯先求和同一个位上的数，再把它大于 $10$ 的部分进位，其余的留下

十进制数的意义实质上就是满 $10$ 进 $1$ ，因此，对于题目中的 $b$ 进制，就是满 $b$ 进 $1$ 。

所以，我们对于加法可以这么实现：

先重新定义一个 $bignum$ 变量为

这个 $bignum$ 变量中的每一位 $n_i$ 都由相加的两个 $bignum$ 变量求和而得

之后， $n_0$ 开始往前进位

最后，我们重新检查一下这个 $bignum$ 的 $l$ 与它实际长度是否相同，不同的话我们要进行修改(比如 $999+1$)

---

接下来讲个本蒟蒻的个人习惯

个人喜欢把主函数写的比较短小精悍，那么，这些~~有的没的~~全部可以用一个结构体封装起来

那么，如果我们再对 $bignum$ 写读入输出操作、初始化操作就可以很优雅的将主函数缩短了

这部分不难，就不做讲解了，各位可以看本蒟蒻代码自行理解

对于字母转成数字的怎么办呢？

当然也是强行封装啦 ~~2333333~~

---

**【代码】**
--

那本蒟蒻就放代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c) for(int a=b;a<=c;a++)
#define g(a,b,c) for(int a=b;a>=c;a--)
struct bignum{
	int b,l,n[2048];
	inline void clr() { l=1; f(i,0,2047) n[i]=0; }
	bignum(int b):b(b) { clr(); }
	inline int tra(char c){
		if((c>='0')&(c<='9')) return c-'0';
		if((c>='A')&(c<='Z')) return c-'A'+10;
		return -1;
	}
	inline char tra(int c){
		if(c<=9) return c+'0';
		else return c-10+'A';
	}//这两个函数虽然函数名一样，但其传入的变量是不一样的，计算机会自己识别该用哪一个
	inline void init(){
		int stack[2048]={0},size=0;
		char c=getchar();
		while(tra(c)<0) c=getchar();
		while(tra(c)>=0) stack[size++]=tra(c),c=getchar();
		clr(); l=0;
		while(size--) n[l++]=stack[size];
	}//读入
	inline void outit() { g(i,l-1,0) putchar(tra(n[i])); }
    //输出
	bignum operator + (const bignum &x){
		bignum y(b);
		y.l=(l>x.l)?l:x.l;
		f(i,0,y.l-1) y.n[i]=n[i]+x.n[i];
		f(i,0,y.l-1) y.n[i+1]+=y.n[i]/y.b,y.n[i]%=y.b;
		while(y.n[y.l]) y.l++;
		return y;
	}//加法实现
};
int main(){
	int b; scanf("%d",&b);
	bignum x(b),y(b),z(b);
	x.init();
	y.init();
	z=x+y;
	z.outit();
	return 0;
}
```

---

## 作者：飞翔 (赞：0)

```cpp
var
  a,b:array[1..10001]of integer;
  i,g,l1,l2,len:integer;
  s1,s2:ansistring;
  s:set of 'A'..'Z';
begin
  s:=['A'..'Z'];
  readln(g);
  readln(s1);
  l1:=length(s1);
  for i:=1 to l1 do
    if s1[i] in s then a[l1-i+1]:=ord(s1[i])-55 else a[l1-i+1]:=ord(s1[i])-48;
  readln(s2);
  l2:=length(s2);
  for i:=1 to l2 do
    if s2[i] in s then b[l2-i+1]:=ord(s2[i])-55 else b[l2-i+1]:=ord(s2[i])-48;
  i:=1;
  while (i<=l1)or(i<=l2) do
  begin
    a[i]:=a[i]+b[i];
    if a[i]>=g then
    begin
      a[i+1]:=a[i+1]+1;
      a[i]:=a[i]-g;
    end;
    inc(i);
  end;
  if a[i]>0 then len:=i else len:=i-1;
  for i:=len downto 1 do
    if a[i]>=10 then write(chr(a[i]+55)) else write(a[i]);
end.
```
普通高精度加法加一些模拟，不难，但太坑。尤其是输出的for i:=len downto 1 do if a[i]>=10 then write(chr(a[i]+55)) else write(a[i]);害的我一直是60分。
注意三点：

一：进位时注意啦，是B进制的加法，不是10进制啦！

二：输入时注意字母，要特殊处理！

三：输出时还要注意字母，还要特殊处理！

注：字母Ａ的ASCLL码是65，但是考虑进位10，所以在程序里要写55


---

## 作者：ROOToj (赞：0)

高精度+进制转换。先将B进制的数转换为10进制并用高精度储存，然后进行高精度加法，再将10进制的高精度结果转换为B进制输出。注意：在判断前导0时应该用int的数组判断，因为char的数组中“0”对应的ASCLL码非零！！也可以用char的数组和‘0’（即0的ASCLL）比较。


附上AC源代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
using namespace std;
#define MAXN 1000010
int base,i,len1,len2,cur=0,len,sum[MAXN],jw,first=1,a[MAXN],b[MAXN];
char s1[MAXN],s2[MAXN],sum_s[MAXN];
int main()
{
    scanf("%d",&base);
    scanf("%s",s1);len1=strlen(s1);
    scanf("%s",s2);len2=strlen(s2);
    for(i=len1-1;i>=0;i--)
        if(isalpha(s1[i]))a[++cur]=s1[i]-'A'+10;
        else a[++cur]=s1[i]-'0';
    cur=0;
    for(i=len2-1;i>=0;i--)
        if(isalpha(s2[i]))b[++cur]=s2[i]-'A'+10;
        else b[++cur]=s2[i]-'0';
    len=max(len1,len2)+1;
    for(i=1;i<=len;i++)
    {
        sum[i]=(a[i]+b[i]+jw)%base;
        jw=(a[i]+b[i]+jw)/base;
    }
    for(i=1;i<=len;i++)
        if(sum[i]>9)sum_s[i]=sum[i]-10+'A';
        else sum_s[i]=sum[i]+'0';
    for(i=len;i>=1;i--)
        if(first&&!sum[i])continue;
        else{first=0;printf("%c",sum_s[i]);}
    putchar('\n');
    return 0;
}

```

---

## 作者：夏色祭 (赞：0)

**这题怎么会是普及/提高-**

**这题怎么会是普及/提高-**

**这题怎么会是普及/提高-**

重要的事情说三遍。

其实很简单，高精度处理就行了，最后输出时，在判断如果大于10，就进行特殊处理。

AC代码如下：

```cpp
var
  a,b:array[0..2001]of longint;
  n,i,j:longint;
  s1,s2:ansistring;
begin
  readln(n);
  readln(s1);
  readln(s2);
  for i:=1 to length(s1) do 
    if s1[i] in ['0'..'9'] then a[length(s1)-i+1]:=ord(s1[i])-ord('0')
      else a[length(s1)-i+1]:=10+ord(s1[i])-ord('A');//把读进来的第一个数存入a数组
  for i:=1 to length(s2) do 
    if s2[i] in ['0'..'9'] then b[length(s2)-i+1]:=ord(s2[i])-ord('0')
      else b[length(s2)-i+1]:=10+ord(s2[i])-ord('A');//把读进来的第二个数存入b数组
  for i:=1 to 2000 do 
    begin
      a[i]:=a[i]+b[i];
      a[i+1]:=a[i+1]+a[i] div n;
      a[i]:=a[i] mod n;
    end;//高精度加法
  j:=2000;
  while a[j]=0 do dec(j);
  for i:=j downto 1 do 
    if a[i]>=10 then write(chr(ord('A')+a[i]-10))
      else write(a[i]);//输出
end.
```

---

## 作者：斯德哥尔摩 (赞：0)

这题就是 高精 ，加上一个并不怎么难的 进制转换 ，

注意，进制转换数组 是 36 个，0~9 和 A~Z

剩下的就是高精度加的事了。。

附代码（缩进不喜勿喷。。。）：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define MAXN 2010//稍微开大一点，防止溢出
using namespace std;
const char s[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};//进制转换数组，无须解释了吧。。。
char num1[MAXN],num2[MAXN];
int n,l1,l2,a[MAXN],b[MAXN],c[MAXN];
int main(){
    int l;
    scanf("%d%s%s",&n,num1,num2);// %s 是一个很好用的东东。。
    l1=strlen(num1);
    l2=strlen(num2);
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));//全部清0
    for(int i=1;i<=l1;i++){//字符转换成数字，每个数组元素存一到两位
            if(num1[l1-i]>='0'&&num1[l1-i]<='9')
            a[i]=num1[l1-i]-'0';//分两种情况：数字 或 大写字母
            else
            a[i]=num1[l1-i]-'A'+10;
            }
    for(int i=1;i<=l2;i++){
            if(num2[l2-i]>='0'&&num2[l2-i]<='9')
            b[i]=num2[l2-i]-'0';//同上
            else
            b[i]=num2[l2-i]-'A'+10;
            }
    l=max(l1,l2);//两大数之和的位数是两数中 最长位数 或 最长位数+1
    for(int i=1;i<=l;i++){
            c[i]+=a[i]+b[i];
            if(c[i]>=n){//进位问题
                        c[i]%=n;
                        c[i+1]++;
                        }
            }
    if(c[l+1]!=0)l++;//开头多一位的解决
    for(int i=l;i>=1;i--)
    printf("%c",s[c[i]]);//输出，直接用 %c 字符
    return 0;//收尾。。。
}

```

---


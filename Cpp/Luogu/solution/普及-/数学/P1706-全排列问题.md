# 全排列问题

## 题目描述

按照字典序输出自然数 $1$ 到 $n$ 所有不重复的排列，即 $n$ 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。


## 说明/提示

$1 \leq n \leq 9$。

## 样例 #1

### 输入

```
3```

### 输出

```
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
```

# 题解

## 作者：shajjl (赞：2441)

## c++朝这看！！！

看了这么多大佬的文章，小生忍不住也来写一篇题解；

你知道吗，在#include <algorithm>里有一个函数，全排列函数：
  
 ### next_permutation！

小生管他叫字典排函数；
  
这个函数每运行一次就可以把数组排成下一个字典排数列；与之对应的是prev_permutation，即排出上一个字典序； <algorithm>里有好多实用的函数，建议大家百度一下；
  
回到题上，我们怎样求出所有的组合呢？这是个组合排列问题，形如下图：

![](https://cdn.luogu.com.cn/upload/pic/27420.png)
  
那么现在我们做的就是从n个数种拿n个数排列；也就是有n！种排列；理论完毕，代码如下：

```
#include<iostream>//P1706
#include<cstdio>
#include<cstring>
#include<string>
#include<iomanip>
#include <algorithm>
#include<cmath>
#include<vector>
#include<set>
using namespace std;
int a[10];
int main()
{
	int n,i,j=1,k;
	cin>>n;
	for(i=1;i<=n;i++)
	 {a[i]=n-i+1;j*=i;}//题目好像没说要从小到大输出
     //但保险起见还是初始赋值为最大序列
     //即a[1~n]=n~1;顺便计算n!
	for(i=1;i<=j;i++)
	 {next_permutation(a+1,a+n+1);
	  for(k=1;k<=n;k++)
	   cout<<"    "<<a[k];//排一次输出一次
       //空格建议复制
	  cout<<endl;
	 }
	 return 0;
}
```

观此题解小生不胜荣幸，请顺手留赞，感谢<^~^>

---

## 作者：和泉正宗 (赞：692)

**算法解析**


DFS，对楼上的回溯+剪枝进行详解。


我们以N=3为例，构造一棵搜索树（或说是状态树）来进行搜索。


同时构造出三个格子，用来存放搜索树中的结果。


现在，我们从第一格开始搜索。第一格填1的搜索树如下：

 ![](https://cdn.luogu.com.cn/upload/pic/7293.png) 

所以N=3的情况下，第一格填1的排列情况共有两种123,132.


第一格填2的搜索树如下：

 ![](https://cdn.luogu.com.cn/upload/pic/7294.png) 

所以N=3的情况下，第一格填2的排列情况共有两种 213,231.


如果你看懂了，请你自己画画第一格填3的搜索树。


**程序实现**


我们总结一下在上一部分中的思路在程序中如何实现。


先定义两个数组，一个是用来存放解的，一个是用来标记该数是否用过。


我们可以先写一个用于打印的函数print()，每当深搜时找到一个符合条件的解时，则print()一下，输出这个解（注意题目输出要求）。


接下来就是写深搜的函数了。主要思路：先判断格子是否填满了，如果填满，则print()一下。


如果没有填满，则开始循环，在循环中先判断当前填的数是否用过，如果没有，则填入，搜索下一格。


程序实现如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,pd[100],used[100];//pd是判断是否用过这个数
void print()//输出函数
{
    int i;
    for(i=1;i<=n;i++)
    printf("%5d",used[i]);//保留五位常宽
    cout<<endl;
}
void dfs(int k)//深搜函数，当前是第k格
{
    int i;
    if(k==n) //填满了的时候
    {
        print();//输出当前解
        return;
    }
    for(i=1;i<=n;i++)//1-n循环填数
    {
        if(!pd[i])//如果当前数没有用过
        {
            pd[i]=1;//标记一下
            used[k+1]=i;//把这个数填入数组
            dfs(k+1);//填下一个
            pd[i]=0;//回溯
        }
    }
}
int main()
{
    cin>>n;
    dfs(0);//注意，这里是从第0格开始的！
    return 0;
}
```

---

## 作者：Kai_Admin (赞：333)

其实可以直接用main()来递归

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool vis[15];
int step=1;
int a[15];
int main()
{
    if(step==1)
    {
//        freopen("pai.in","r",stdin);
//        freopen("pai.out","w",stdout);
        cin>>n;
    }
    int i;
    if(step-1==n)
    {
        for(i=1;i<=n;i++)
        printf("%5d",a[i]);
        printf("\n");
    }
    for(i=1;i<=n;i++)
    {
        if(vis[i]==0)
        {
            vis[i]=1;
            a[step]=i;
            step++;
            main();
            step--;
            vis[i]=0;
        }
    }
    return 0;
}
```

---

## 作者：wxy_god (赞：271)

来一发**不定层数循环**题解。

# 什么是不定层数循环

不定层数循环的效果类似于$dfs$，不过唯一的区别是$dfs$要用递归，而不定层数循环不需要用递归。

**为了让大家熟悉不定层数循环，所以我们先求组合数**

在不定层数循环中，我们需要一个变量$x$（反正我习惯这样用），表示$dfs$中的第几层。然后我们需要一个$n$ 和 $m$，来表示有$n$个数，取出其中的$m$个。我们还需要一个$a$数组，表示第几个数的状态（这个在不同题目中不一样，在此题中代表第几个数）。

主体循环是这样的：外框是一个$while$循环，循环条件是$x>0$（初始化时$x$要设成一个非$0$的数）。一进循环后就将$x$设为$m$（如果你是倒着搜的话），然后$a[x]++$。这个的意思就是枚举下一种情况。那么问题来了，如果最后一个数超过了$n$，那怎么办呢？有些大佬想到了，写一个循环条件是$while(a[x] == n - m + x + 1)$的一个循环，循环体里面写着$x -- ;$不就行了？其实这种做法是有误的。因为当你$x -- ;$的时候，没有枚举下一种情况！所以还要加一句$a[x] ++ ;$才可以，否则就会死循环。最后还差一步，将$x + 1$一直到$m$的$a$数组规划成$a[i - 1] + 1$。如果要输出所有解的话，要在这个$while$循环一开始进去时输出，输出答案数量的话也是在同样的位置计数。

$code:$

```
#include <cstdio>

int n, m;
int a[1001], x = 1;

inline void print () {
	for(int i = 1; i < m; i ++ )
	    printf("%d ", a[i]);
	printf("%d\n", a[m]);
}

int main () {
		
	scanf("%d%d", &n, &m);
	
	for(int i = 1; i <= m; i ++ )
	    a[i] = i;
	    
	while(x > 0) {
		
		x = m;
	    print();
		a[x] ++ ;
		
		while(a[x] == (n - m + x + 1) && x > 0) {
			x -- ;
			a[x] ++ ;
		}
		
		for(int i = x + 1; i <= m; i ++ )
		    a[i] = a[i - 1] + 1;
	}
	
	return 0;
}
```

而排列数相对来说难一点。由于排列数顺序可能有颠倒，所以就需要一个数组来记录下来，在这里我使用的是$b$。$b$是一个$bool$数组，$b[i]==true$表示第$i$个数用过了，否则就没用过。上来先写一个$while$循环，条件是$x > 0$，每次要将$b[a[x]]$设成$false$，然后从$a[x]+1$开始枚举，结束条件为$i <= n$，发现一个没有填过的数时，赋值后**不要忘记将$b[i]$设成$true$。**出循环时如果发现$i <= n$了，那么说明找到解了，直接$break$掉。否则$x -- $，进入下一层循环，再枚举，直到找到一组合适的解。

出这层$while$后，如果$x > 0$，那么说明$x$后面的数需要重新赋值。先定义一个$cnt$，表示已经选了几个数。循环的初始值为$1$，表示从第$1$个数开始枚举。结束条件为$x + cnt <= m$ $and$ $i <= n$，前一个条件是防止越界（具体为什么类似于组合数的小$while$条件），后一个条件是也是防止数过大。里面的与刚才的那个$while$类似，只不过赋值时$a$数组的下标从$x$变成了$x + cnt$。

输出要左对齐$5$位，需要```printf("%5d", a[i]);```。

那么放一下$code$吧：

```
#include <cstdio>

int main () {
	
	int n, m; 
	int x = 1, s = 0;
	int a[1001];
	bool b[1001];
	
    scanf("%d", &n);
    m = n;//此题是求全排列问题，所以n == m
    
    for(int i = 1; i <= n; i ++ )
		b[i] = false;
		
	for(int i = 1; i <= m; i ++ ) {
		a[i] = i;
		b[i] = true;
	}

	while(x > 0) {
		
		s ++ ;
		printf("%d: ", s);
		
		for(int i = 1; i <= m; i ++ )
			printf("%5d", a[i]);
		printf("\n");
		
		x = m;
		
		while(x > 0) {
			b[a[x]] = false;
			int i;
			for(i = a[x] + 1; i <= n; i ++ ) {
				if(b[i] == false) { 
				    a[x] = i; 
				 	b[i] = true;
				 	break;
				}
			}
			
			if(i <= n)
				break;
			x -- ;
		}
		
		if(x > 0) {
			int cnt = 1;
			for(int i = 1; x + cnt <= m && i <= n; i ++ ) {
				if (b[i] == false) {
					a[x + cnt] = i;
					b[i] = true;
					cnt ++ ;
				}
			}
		}
		
	}
	
	printf("%d", s);
	
	return 0;
}
```

# 大家觉得还行的话请到顶部点个赞吧（逃）

---

## 作者：Xxzxx (赞：200)

初学状态压缩，拿这道水题练练手。

~~虽然说时间只快了一丢丢~~~~，但~~这也是
一个很好的剪枝

1.创建一个数组，下标是二的n次方的位置里存的是n；1<<几就是2的几次方。（举个例子：下标是32的位置里存的是5，下标是1024的位置存的是10）

2.在dfs里加上一个形参s，是状态压缩的二进制数，1代表当前位置可以搜，反之是0。

3.改一下递归部分的for（创建一个临时变量ss，替代当前一层的s；条件是s不为0；去掉ss的最后一位；）

4.因为懒，就创建了一个临时变量。普及一下：一个数a求它二进制数的最右面一位1，就这么求：a&（-a)

5.因为状态压缩的每一位的数值就是2的（那一位）位数次方，所以lg数组起到了把位数上的值转变成位数的作用。

6.这里递归时s减掉最后一位就行了。

（PS:这里就不用标记数组啦！s就相当于是标记数组了呢。）

```
#include<iostream>
#include<cstdio>
using namespace std;
int n,lg[1030],ans[10];
void dfs(int i,int s)//2
{
    if(i>n){for(int p=1;p<=n;p++)
            printf("%5d",ans[p]);
        cout<<endl;return;}
    for(int ss=s;ss>0;ss-=ss&(-ss))//3
    {
        int temp=ss&(-ss);//4
        ans[i]=lg[temp];//5 
        dfs(i+1,s-temp);//6
    }
}
int main()
{
    cin>>n;
    lg[1]=1;
    for(int i=2;i<=n;i++)
        lg[1<<(i-1)]=i;//1
    dfs(1,(1<<n)-1);//第一次递归时所有位置都没搜
    return 0;
}

```

题解里没有状态压缩做的，我就发一篇（求管理员给过QWQ)

---

## 作者：Yue_qiu (赞：170)

## 本题解绝非正解，仅适用于初学者，没有涉及DFS及其他高端技术，会枚举就能看懂。求大佬勿喷。
### 咱是个蒟蒻，咱不会DFS,也不会高端做法，打表费时，所以，暴力枚举出奇迹！（逃）
其实就是枚举所有数字，反正就1-9，范围小，打表也可以，但表会分行，这时候要么在表里行前行尾加“”然后用printf（"...""..."......）输出，要么用C11里的raw string literals，cout<<R"..."输出。咱都用不熟咋治？
#### 枚举呗
枚举思想很简单，n最大是9，那就用9个for循环分别枚举，从1-n，只输出1-n的全排序，那就每个循环后面加个判断语句，看是否到第n个数了，到了的话直接输出。

下面是代码,代码很长，但很好打，各部分都差不多，写的时候复制一部分黏贴，在后面加一段就行
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[10];
	for(int i=1;i<=9;i++) a[i]=i;
	int n;
	cin>>n;
	for(int i1=1;i1<=n;i1++)//把第一个数从1-n枚举 
	{
		if(n==1)//如果n是1，即从1-1全排序 
		{
			cout<<"    "<<i1<<"\n" //输出全排序结果 
			continue;//跳过后面几个数的枚举
		}
		for(int i2=1;i2<=n;i2++)//把第二个数从1-n枚举 ，后面嵌套的for循环同理，即把第3、4、5...9个数枚举 
		{
			if(i2==i1) continue;//当i2和前面的数重复时，跳过后面的判断，继续循环。后面嵌套的循环同理，即当i3、i4、i5、......i9和前面数重复时，跳过后面的判断，继续循环 
			if(n==2)//如果n是2 ，即从1-2全排序。后面同理，即从1-3、1-4......1-9全排序 
			{
				cout<<"    "<<i1<<"    "<<i2<<"\n";//输出全排序结果，后面同理 
				continue;//跳过后面几个数的枚举，后面同理 
			}
			for(int i3=1;i3<=n;i3++)
			{
				if(i3==i2||i3==i1) continue;
				if(n==3)
				{
					cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"\n";
					continue;
				}
				for(int i4=1;i4<=n;i4++)
				{
					if(i4==i3||i4==i2||i4==i1) continue;
					if(n==4)
					{
						cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"\n";
						continue;
					}
					for(int i5=1;i5<=n;i5++)
					{
						if(i5==i4||i5==i3||i5==i2||i5==i1) continue;
						if(n==5)
						{
							cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"    "<<i5<<"\n";
							continue;
						}
						for(int i6=1;i6<=n;i6++)
						{
							if(i6==i5||i6==i4||i6==i3||i6==i2||i6==i1) continue;
							if(n==6)
							{
								cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"    "<<i5<<"    "<<i6<<"\n";
								continue;
							}
							for(int i7=1;i7<=n;i7++)
							{
								if(i7==i6||i7==i5||i7==i4||i7==i3||i7==i2||i7==i1) continue;
								if(n==7)
								{
									cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"    "<<i5<<"    "<<i6<<"    "<<i7<<"\n";
									continue;
								}
								for(int i8=1;i8<=n;i8++)
								{
									if(i8==i7||i8==i6||i8==i5||i8==i4||i8==i3||i8==i2||i8==i1) continue;
									if(n==8)
									{
										cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"    "<<i5<<"    "<<i6<<"    "<<i7<<"    "<<i8<<"\n";
										continue;	
									}	
									for(int i9=n;i9<=n;i9++)
									{
										if(i9==i8||i9==i7||i9==i6||i9==i5||i9==i4||i9==i3||i9==i2||i9==i1) continue;
										cout<<"    "<<i1<<"    "<<i2<<"    "<<i3<<"    "<<i4<<"    "<<i5<<"    "<<i6<<"    "<<i7<<"    "<<i8<<"    "<<i9<<"\n";
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：Harry_Potter (赞：96)


这是一道DFS的基础题
比较直端的想法是将当前用了几个数，每个数是都已经被使用作为状态进行搜索。
因为要求字典徐从小到大，所以在搜索的每一层中，我们都从小到大枚举当前选择哪个数
时间复杂度为O（n！）   n！为n的阶乘

代码如下，有注释！



**请不要抄**
```cpp


#include<bits/stdc++.h> 
using namespace std;
int n;
int ans[15];//保存当前的方案
int use[15];//表示每个数是否被用过
void dfs(int x){//X表示当前搜索到那个数
	if(x>n){//如果N位都搜索完了，就输出方案并返回
		for(int i=1;i<=n;i++)
			printf("% 5d",ans[i]);//输出方案 
		puts("");
		return;
	}
	for(int i=1;i<=n;i++)//从小到大枚举
	if(!use[i]){//判断这个数是否用过
		ans[x]=i;//保存到方案中
		use[i]=1;//标记这个数被使用了
		dfs(x+1);//进行下一步搜索
		use[i]=0;//撤销标记
	}
}
int main()
{
	
	scanf("%d",&n);//输入
	dfs(1);//从第一个数开始搜索；
}

```

如有错误，希望大佬们多多指教

---

## 作者：NeosKnight (赞：87)

这是一道好题，用STL的好题



next\_permutation( ) 直接求出下一个排列

仅需10行代码即可AC


```cpp
#include<cstdio>
#include<algorithm>
#define rep(a,b,c) for(register int a=b;a<=c;a++)
using namespace std;
int x[11];
int main()
{
    int n;scanf("%d",&n);rep(i,1,n) x[i]=i,printf("    %d",i);
    while(next_permutation(x+1,x+1+n)){printf("\n");rep(i,1,n) printf("    %d",x[i]);}
}
```cpp

---

## 作者：la_un_ty (赞：55)

这篇题解就当做我学习搜索的开端，纪念一下。


------------
### 大大的算法标签->深度优先 ![](https://i.loli.net/2019/01/03/5c2e16fbd2ce8.bmp)
主要思路：利用搜索，逐个的确定数字，最后输出。

代码有详细注释

方法：
1. 先定义一个输出函数用于输出全排列
```
void print(){
	for(int i=1;i<=n;i++) printf("%5d",a[i]);
	printf("\n"); 
}
```
1. 再定义一个深搜函数，以及递归边界和内容，像这样：
```
void dfs(int dee){//dee是深度
	if(dee>n){//递归边界
		print();return;//如果达到n，那么输出
	}
	for(int i=1;i<=n;i++){//for轮流固定数字
		if(!gd[i]){//判断数字是否用过
			gd[i]=1;//若没用过，将其标记为用过
			a[dee]=i;//将这个数字固定下来
			dfs(dee+1);//递归深搜
			gd[i]=0;//深搜完毕，将其取出，开始下一轮
		}
	}
	return;
}
```
1. 接下来是主函数
```
int main(){
	scanf("%d",&n);//读入n
	dfs(1);//从第一个数字搜索
	return 0;
} 
```
1. 完整代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int gd[15],a[15],n;//gd判断该数是否用过
void pt(){
	for(int i=1;i<=n;i++) printf("%5d",a[i]);//%5d是占5个场宽
	printf("\n"); 
}
void dfs(int dee){//Depth First Search
	if(dee>n){
		pt();return;
	}
	for(int i=1;i<=n;i++){
		if(!gd[i]){
			gd[i]=1;
			a[dee]=i;
			dfs(dee+1);
			gd[i]=0;
		}
	}
	return;
}
int main(){
	scanf("%d",&n);
	dfs(1);
	return 0;
} 
```
### 说明：
深搜函数是深度优先搜索的精髓，需要根据实际情况来传递参数，可以达到很好的效果。

谢谢参观。



---

## 作者：SYGFchen (赞：42)

这是一道标准的深搜

AC代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
int n,a[10],pp=1;
bool b[10];
using namespace std;
int print()       //该程序为输出
{
    for (int i=1;i<=n;i++)
    printf("%5d",a[i]);
    printf("\n");
}
int search(int k)
{
    for (int i=1;i<=n;i++)  //找到所有的可能，则是1~n
    {
        if (!b[i])    //判断该数是否用过
        {
            b[i]=1;    //没有用过就把他设置成用过
            a[pp]=i;       //储存
            pp++;
            if (k==n)     //如果存了n个数了，就输出，否则继续搜索
            print();
            else search(k+1);
            pp--;
            b[i]=0;      //回溯
        }
    }
}
int main()
{
    scanf("%d",&n);    //输入n
    memset(b,0,sizeof(b));    //把所有数先设为没出现过
    search(1);           //开始搜索
}
```

---

## 作者：Spidey (赞：13)

/\*
解题思路：

假设数字是牌，排序相当于将牌放进盒子里面，以此解题

\*/
```cpp
#include<stdio.h>
int a[10],book[10]={0};//a代表盒子，book代表手上的牌 
int n;//n代表1~n 
void dfs(int step){
    int i;
    if(step==n){
        for(i=0;i<n;i++){
            printf("    %d",a[i]);
        }
        printf("\n");
        return;
    }
    for(i=0;i<n;i++){
        if(book[i]==0){
            a[step]=i+1;//将手上的牌放进盒子中去 
            book[i]=1;//表示牌已经不在手上 
            dfs(step+1);//递归 
            book[i]=0;//如果返回，就将牌从盒子里面抽出 
        }
    }
}
int main(){
    scanf("%d",&n);
    dfs(0);
    return 0;
}
```

---

## 作者：nexure (赞：11)

看到大佬们都用DFS做的，但是~~因为不会DFS~~看到这么小的数据范围，我便想到了一种奇怪的做法：

## （仅供娱乐，比赛勿用！）

### 观察可得，当输入数据为N时，输出数据全部小于等于N，且每组各不相同。

输出数据全部小于等于N？

没错！

# 进制转换！

输入N，就创建一个N+1紧致的N位数进行累加，当数字中每一位数都不相同时输出。

Tip:~~因为我懒~~在此发现一个规律，对于一定数量的数，和于积分别相等的组合是唯一的。

我不知道这个规律是否已经存在，也不知道是否成立，反正10以下没问题，此题可用，暂且称为CZY猜想，有待大佬证明。这样有助于减少时间复杂度。

**话不多说，上代码！**

```
#include<iostream>
using namespace std;
int used[10],ans[10];
int num,bflag,cflag,pans,cans=1;
int pans1,cans1=1;
void jia(int n){//对数组模拟的N+1进制数进行累加
	if(ans[n]+1>=num+1&&n>=2){
		ans[n]=0;
		jia(n-1);
	}
	else{
		if(n==1&&ans[n]+1>=num+1){//如果第一位最大，跳出死循环
			bflag=1;
			return;
		}
		else{
			ans[n]++;
			return;
		}
	}
}
int main(){
	cin>>num;
	for(int i=1;i<=num;i++){//求出描述中提到的和与积
		pans1+=i;
		cans1*=i;
	}
	for(int i=num;i>=1;i--){
		ans[i]=i;
        //使用递增序列，也就是符合规则的第一个数字组合，可减少时间复杂度
	}
	while(1){
		if(bflag==1)break;//跳出条件
		for(int i=1;i<=num;i++){
			pans+=ans[i];
			cans*=ans[i];
		}
		if(pans==pans1&&cans==cans1){//对比数字是否符合
			for(int i=1;i<=num;i++)cout<<"    "<<ans[i];//输出符合的数字序列
			cout<<endl;
		}
		pans=0;
		cans=1;
		jia(num);//累加
	}
	return 0;
} 
```

# 再次声明！此方法仅供娱乐！

为什么呢？如果不吸氧优化第三个点耗时999ms……如果运气不好还可能T掉……吸氧之后耗时减少，但和std还是没法比……别忘了这才1—9的数据范围啊，比赛用的话除非你不想活了……

还可以优化，不过~~我懒~~算法既然不优就没有优化的必要了（手动滑稽）

---

## 作者：panlin (赞：10)

#### 这道题用到了STL中
## next_permutation函数



该函数头文件为#include<algorithm>

简要介绍一下next_permutation函数的功能
  
  next_permutation()函数功能是输出所有比当前排列大的排列，顺序是从小到大。当排列已经是最大，返回假，否则真。
  ```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int a[10];
	int n;
	cin >> n;
	for(int i = 1;  i<= n; i++) {
		a[i] = i;
	}
	do {
		for(int i = 1; i <= n; i++) {
		cout << "    " <<a[i];
	}
		cout << endl; 
	}while(next_permutation(a + 1, a + n + 1));
	return 0;
}
```


---

## 作者：「QQ红包」 (赞：10)

简单的回溯……而且不要加任何优化也不会超时……

```delphi

var n:longint;
    a:array [1..9] of boolean;
    b:array [1..9] of integer;
procedure try(t:longint);
var i,j:longint;
begin
    for i:=1 to n do
    begin
        if not a[i] then 
        begin
            a[i]:=false;
            b[t]:=i;
            if t=n then 
            begin
                for j:=1 to n do 
                    write(a[i]);
            end else try(t+1);
            a[i]:=false;
        end;
    end;
end;
begin
    read(n);
    try(1);
end.


```

---

## 作者：某某x (赞：8)

**本文将会用for循环、递归讲解如何生成全排列**

刚看到全排列的时候可能会有一种不知道怎么生成的感觉，我们先观察下[1 2 3] 的全排列：
```cpp
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
```

首先一个很明显的规律，**递增**，我们很容易的就能想到枚举每一位的数字，最后就可以判断一下是否有重复了，我们先写一个[1,2,3]的实现，

```cpp
#include<stdio.h>
int main() {
//用for循环模拟显然是递增的
  for(int i = 1; i <= 3; i++) {
    for(int j = 1; j <= 3; j++) {
      for(int k = 1; k <= 3; k++) {
        if(i != j && i != k && j != k) {//判断出现的数字是否相同，不相同则输出
          printf("%d %d %d\n", i, j, k);
        }
      }
    }
  }
}
```
然后这题就做完了！
等等，题目要求是求任意的长度的全排列呀，难道每种长度我都要写一个吗？？？
其实动动脑筋的话可以把枚举改变一下，观察上面的for循环。如果把i，j，k当成百位，十位，个位来看的话：111,112,113,121,122......
不就是自然数的增加嘛，只不过把一些不可能的数字去掉了，那我们换一种枚举方式吧！枚举自然数，再把每一位取出来比较是否是恰好是[1-n]
对于一个n，它的下界是 $10^n$ 上界是$10^{n+1} -1$,这里可以用到pow函数，取它的每一位的话可以用一个数组来保存，最后判断是否满足条件的话可以使用一个技巧，用一个数组来记录它出现的次数，如果数字i出现了，则b[i]++，最后只需要检查一下b数组里面是否都是1就可以了。
但是，上午测试的时候TLE了很多次。要加一些剪枝才可以，首先l = 123..n， r = n..321
然后遇到0的话我们就直接跳过一大段。（还得开O2优化）看代码吧

```cpp
#include<stdio.h>
int b[11], c[11], a[11]; //a数组用于剪枝， b数组用于记录数字出现的次数，c数组用于存各个位的数字 
int main() {
  a[0] = 1;
  int l = 0, r = 0, n;//上界与下界
  scanf("%d", &n);
  for(int i = 1; i <= n; i++) l = l * 10 + i, r = r * 10 + (n - i + 1), a[i] = a[i-1] * 10;
  for(register int i = l, j, flag, cnt; i <= r; i++) { 
    j = i, flag = 1, cnt = 0;
    while(j) { 
      if(j % 10 > n) break;//某位大于n则直接退出 
      if(j % 10 == 0) j++, i += a[cnt];//某位为0则直接跳过一大段例如 200000，直接改为211111，主要剪枝 
      b[j%10]++;
      c[cnt++] = j % 10;
      j /= 10;      
    } 
    //判断每位数字是否只出现了一次，顺便刷新b数组 
    for(j = 1; j <= n; j++) { 
      if(b[j] != 1) { 
        flag = 0;
      } 
      b[j] = 0;
    } 
    if(flag) {  //打印输出，记住是逆序 
      for(int j = n-1; j >= 0; j--) printf("%5d", c[j]);
      puts("");
    }  
  } 
} 
```

上面的为两个for循环的做法。第一种算法要针对不同的n来写判断条件。所以特别的长。。.那么能换一种写法吗，之所以我们要针对不同的n来写，不正是因为我们无法动态的添加for循环吗？那么我们可以通过函数的递归来实现这种动态的添加for循环吧，稍微思考一下。首先我们要怎么知道各层函数是哪个for循环呢？简单，用个参数来控制；

```cpp
void dfs(int num);//num代表我是第几次调用这个函数，也就是当前在第几个for循环中；
```
然后里面要写什么呢？递归一定要有的两部分：自身调用，终止条件。啥时候终止呢？不就是当层数为n+1的时候吗？（因为前面的n个函数都是在枚举）那我们来完善一下

```cpp
int n, a[10];//n代表层数，a数组用于存各层的枚举的数
void dfs(int num) {
  if(num == n + 1) {
    for(int i = 1; i <= n; i++) {//判断是否有相等的数，若有则直接退出，反之则输出；
      for(int j = i + 1; j <= n; j++) {
        if(a[i] == a[j]) return ;
      } 
    }
    for(int i = 1; i <= n; i++) 
      printf("%5d", a[i]);
    printf("\n");
    return ;
  }
  for(int i = 1; i <= n; i++) {
    a[num] = i;
    dfs(num+1);
  }
}

```
~~经过第二种for循环写法的洗礼我们应该自然的想到优化优化代码。。~~ 一个很显然的优化，如果我们发现这个数前面几层已经用过，那么我们能不能直接跳过呢？怎么实现呢？？思考一下我们前面所用的判断方法

> 用一个数组来记录它出现的次数，如果数字i出现了，则b[i]++，最后只需要检查一下b数组里面是否都是1就可以了。

我们可以稍微改一下，如果当前的枚举的是 i，它的 b[i] 已经为1了那我们就直接跳过吧，如果不为1我们就去标记一下。具体实现：

```cpp
void dfs(int num) {
  if(num == n + 1) {
    for(int i = 1; i <= n; i++) 
      printf("%5d", a[i]);
    printf("\n");
    return ;
  }
  for(int i = 1; i <= n; i++) {
    if(b[i]) continue;//如果出现过则直接跳过
    b[i] = 1;//没有使用过那就标记一下吧。
    a[num] = i;
    dfs(num+1);
    b[i] = 0;//使用完之后清空哦
  }
}
```
那么全排列问题到这里就结束了。c++ STL库里也有全排列函数 next_permutation() 具体咋用大家就翻翻别的题解吧0.0 ~~虽然我也是用STL过的~~ 

若有问题希望各位dalao能指出




---

## 作者：sukamoka (赞：7)

**看了大佬们的方法，主要是搜索(主要是深搜),STL之类的高级玩意~~(但像我这种蒟蒻怎么可能看得懂呢)~~。所以，我就用了机房老师教的栈~~(也不知道是不是真的)~~写了一篇~~不知所云的~~玩意**

### 代码+注释

```cpp
#include <cstdio>
using namespace std;
int s[10]={0,1},p=1,n;//s[]:栈数组,p:栈指针,n:全排列个数
bool k;
int main()
{
	scanf("%d",&n); 
	while(p>0)//所有情况都跑完了一遍,停止循环
	{
		if(s[p]>n) p--;//退栈
		else{
			k=0;//判断有没有重复的数字
			for(int i=1;i<p;i++)//在前面的所有成员中进行查找
			if(s[p]==s[i])//如果有重复
			{
				k=1;//标记一下
				break;//退出,节约时间(其实不加也能过)
			}
			if(!k)//如果没有重复
			{
				if(p==n)//如果栈内成员达到容量
				{
					for(int i=1;i<=p;i++) printf("%5d",s[i]);//格式化输出
					printf("\n");//换行
				}
				else s[++p]=0;//反之进栈
			}
		}
		s[p]++;
	}
	return 0;//好习惯
}
```

**最后,弱弱地请教一句,代码还能请各位大佬再帮忙优化一下吗?~~(一次厚颜无耻的提问)~~**

---

## 作者：灵乌路空 (赞：6)

## 提供一种基于排序 的 非搜索 做法

------------

思路:  

将答案数组进行二分,  
以变量 $nn$ 为界,  
前半部分为有序区,后半部分为无序区  
对无序区按照字典序进行排序 


每次递归,  
都循环从无序区中取出元素,  
并加入有序区
并将边界后移一位  

之后重新对无序区  
按照字典序进行排序,
然后将改变后的数组作为参数,  
传到下一层递归中


当有序区的长度等于 $l$ 时,  
便找到了一组解,输出即可


------------
#### 附上代码：

------------
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
int l; 
using namespace std;
void p(int nn,char b[10])   	 //将字符串分为有序区和无序区,以nn为界 
{
	for(int i=nn;i<=l;i++)  	 //从分界线上开始,依次枚举无序区元素 
	  {
	    char c[10];        	     //储存当前的 字符串 
	    for(int k=0;k<=9;k++)
	      c[k]=b[k];
	  	swap(c[nn],c[i]);    	 //令c[nn]等于找到的字符 
	  	if(nn+1<=l)        	     //边界小于l,则重排序无序区 
	  	  sort(c+(nn+1),c+l+1);
	  	if(nn==l)           	 //若到达尾部,则输出 
	  	  {
	  	  	for(int j=0;j<=l;j++)
	  	  	  printf("%5c",c[j]);//输出坑点 
	  	  	printf("\n");
		  }
	  	else
	  	  p(nn+1,c);  			 //继续找下一个
	  }
}
char a[10];
int b;
int main()
{
	cin>>b;    
	for(int i=0;i<b;i++)//初始化答案数组 
	  a[i]=i+'1'; 
	l=strlen(a)-1;
	p(0,a);  
}
```
------------


---

## 作者：时光刺客 (赞：6)

```cpp
#include<iostream>
#include<cstdio>//由于后面要用到printf来保留5个常宽，所以用这个头文件
using namespace std;
int a[10],book[10],n;//a[10]用来存放数值；book[10]有很重要的作用，用来标记哪些数已经用过
void dfs(int step)//不用返回值，用void类型
{
    int i;
    if(step==n+1)//如果已经搜索到n+1,那么已经搜索完毕，打印全排列
    {
        for(i=1;i<=n;i++)
        printf("%5d",a[i]);//用循环读入数据，其中注意题目要求保留5个常宽，这个功能用cout语句难以做到
        cout<<endl;//每输出一种全排列，按题目要求，注意换行
        return;//返回原来dfs的那一步，再次开始（深搜标准格式）
    }
    for(i=1;i<=n;i++)//注意这两个循环不同，这个用来搜索（尝试每一种可能）
    {
        if(book[i]==0)//book数组用来标记，如果未被标记，证明这个数还没用
        {
            a[step]=i;//将这个数存入数组
            book[i]=1;//标记这个数已用过
            dfs(step+1);//用递归，再次进入函数（注意不是循环），进入下一次的全排列判断；如果排列完毕（也就是到达边界），那么就会执行上面的输出
            book[i]=0;//注意此处一定要清零，然后进入下一次的函数，如果不清零，那么下一次输出全排列时，所有的数都被标记过，将无法输出
        }
    }
    return;//深搜最后一定要退出函数，否则会永无止境的执行函数，导致程序爆炸
}
int main()
{
    cin>>n;
    dfs(1);//使用dfs函数，从1开始
    return 0;
}
```
/\*附上深搜一般格式：
void dfs(int n)

  {
判断边界，如果已经到边界，返回，退出函数（有时需要打印数据）

尝试每一种可能 for(i=1;i<=n;i++)

    {
函数体；

继续下一步  dfs(n+1)

    }
返回 return;

  }
\*/

---

## 作者：zy小可爱ღ (赞：6)

这题倒也花了我不少时间，不停想节省空间，但这也确实是最省的了。。。

主要思路呢，要注意标记数有没有选过，并标记每个数的输出顺序。。

具体注释见代码：：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n;//输入的数
int a[15],b[15];//第一个用来标记数有没有选过，第二个标记输出数的顺序
void sc(){//输出函数
    for(int i=1;i<=n;i++)
        printf("%5d",b[i]);//注意题目要求“每个数字保留5个常宽”
    cout<<endl;//换行
}
void dfs(int l){
    if(l>n){//判断停止条件
        sc();//调用函数
        return;//返回
    }
    for(int i=1;i<=n;i++){//循环
        if(!a[i]){//如果数没有被选过
            a[i]=l;//数被选过了
            b[l]=i;//数是第几个被选的，也就是输出顺序
            dfs(l+1);//回溯
            b[l]=0;
            a[i]=0;
        }
    }
}
int main(){
    cin>>n;//输入
    dfs(1);//调用函数
    return 0;
}
最后，祝大家AC！！！
```

---

## 作者：_LHF_ (赞：6)

# 全排列？？递归
## 本宝宝来一个主函数递归吧：
注意点：本题输出时场宽为5，建议使用: printf("%5d",&s\[i\]);

代码如下：
```cpp
//--主函数递归--
#include<cstdio>
using namespace std;
bool bz[20],p=true;
int n,s[20],a;
int main()
{
	if(p)//进入读入部分
	{
		scanf("%d",&n);
		p=false;//锁住读入部分
		a=1;
		for(int i=1;i<=n;i++)
		{
			bz[i]=true;//先把全部数标记为true
		}
	}
	//递归区域
	if(a>n)//判断是否要输出
	{
		for(int i=1;i<=n;i++)
		{
			printf("%5d",s[i]);
		}
		printf("\n");
		return 0;//返回
	}
	for(int i=1;i<=n;i++)
	{
		if(bz[i])//判断是否没被选
		{
			bz[i]=false;//标记它为false
			s[a]=i;//选中这个数
			a++;//指向下一个数
			main();//搜索下一个数
			a--;//指回这一个数
			bz[i]=true;//标记它为true
		}
	}
}
```
C++还有一个STL模板专门针对此题的，就是next_permutation函数，有兴趣的可以上网搜一搜，献上代码：
```cpp
//STL模板
#include<algorithm>//STL库
#include<cstdio>
using namespace std;//使用STL时必须要的东西
int s[10],k=1,n;
int main()
{
	scanf("%d",&n);
  	//初始化，计算个数，输出第一组
	for(int i=1;i<=n;i++)s[i]=i,printf("%5d",i),k*=i;
	printf("\n");
	for(int i=1;i<k;i++)
	{
		next_permutation(s+1,s+n+1);//寻找下一个
		for(int j=1;j<=n;j++)printf("%5d",s[j]);
		printf("\n");
	}
	return 0;
}
```
哈哈，挺简单的吧。
## 欢迎大佬点评。

---

## 作者：骗分过样例 (赞：4)

### 注意：此题解仅供c++参考。

看了那么多大佬的代码，小生也来给大家一个 外星科技————————

next_permutation！！！！！！！

反正别管，它挺有用的。具体用法如下：

```cpp
int a[n]; //基本定义
do
{
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
    cout<<endl; //输出
}while(next_permutation(a,a+n); //要加';'
```

就是有一点不好，next_permutation 必须要是数组有序。别问我为什么，要问就问 [baidu](www.baidu.com)或是c++程序员去。

最后，就是你们要的：

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;
int main()
{
	int a[10001];
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		a[i]=i; //把数组设成1~n的数 
	do
	{
		for(int i=1;i<=n;i++)
			cout<<setw(5)<<a[i]; //输出 
		cout<<endl; //endl别忘加 
		//next_permutation
	}while(next_permutation(a+1,a+n+1)); //全排列函数 
	return 0;
}
//

```

最后是数据：

1

输出

1

++++++++++++++++++++++++++++++++++++++++

3

输出

    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
    
++++++++++++++++++++++++++++++++++++++++

5

输出

    1    2    3    4    5
    1    2    3    5    4
    1    2    4    3    5
    1    2    4    5    3
    1    2    5    3    4
    1    2    5    4    3
    1    3    2    4    5
    1    3    2    5    4
    1    3    4    2    5
    1    3    4    5    2
    1    3    5    2    4
    1    3    5    4    2
    1    4    2    3    5
    1    4    2    5    3
    1    4    3    2    5
    1    4    3    5    2
    1    4    5    2    3
    1    4    5    3    2
    1    5    2    3    4
    1    5    2    4    3
    1    5    3    2    4
    1    5    3    4    2
    1    5    4    2    3
    1    5    4    3    2
    2    1    3    4    5
    2    1    3    5    4
    2    1    4    3    5
    2    1    4    5    3
    2    1    5    3    4
    2    1    5    4    3
    2    3    1    4    5
    2    3    1    5    4
    2    3    4    1    5
    2    3    4    5    1
    2    3    5    1    4
    2    3    5    4    1
    2    4    1    3    5
    2    4    1    5    3
    2    4    3    1    5
    2    4    3    5    1
    2    4    5    1    3
    2    4    5    3    1
    2    5    1    3    4
    2    5    1    4    3
    2    5    3    1    4
    2    5    3    4    1
    2    5    4    1    3
    2    5    4    3    1
    3    1    2    4    5
    3    1    2    5    4
    3    1    4    2    5
    3    1    4    5    2
    3    1    5    2    4
    3    1    5    4    2
    3    2    1    4    5
    3    2    1    5    4
    3    2    4    1    5
    3    2    4    5    1
    3    2    5    1    4
    3    2    5    4    1
    3    4    1    2    5
    3    4    1    5    2
    3    4    2    1    5
    3    4    2    5    1
    3    4    5    1    2
    3    4    5    2    1
    3    5    1    2    4
    3    5    1    4    2
    3    5    2    1    4
    3    5    2    4    1
    3    5    4    1    2
    3    5    4    2    1
    4    1    2    3    5
    4    1    2    5    3
    4    1    3    2    5
    4    1    3    5    2
    4    1    5    2    3
    4    1    5    3    2
    4    2    1    3    5
    4    2    1    5    3
    4    2    3    1    5
    4    2    3    5    1
    4    2    5    1    3
    4    2    5    3    1
    4    3    1    2    5
    4    3    1    5    2
    4    3    2    1    5
    4    3    2    5    1
    4    3    5    1    2
    4    3    5    2    1
    4    5    1    2    3
    4    5    1    3    2
    4    5    2    1    3
    4    5    2    3    1
    4    5    3    1    2
    4    5    3    2    1
    5    1    2    3    4
    5    1    2    4    3
    5    1    3    2    4
    5    1    3    4    2
    5    1    4    2    3
    5    1    4    3    2
    5    2    1    3    4
    5    2    1    4    3
    5    2    3    1    4
    5    2    3    4    1
    5    2    4    1    3
    5    2    4    3    1
    5    3    1    2    4
    5    3    1    4    2
    5    3    2    1    4
    5    3    2    4    1
    5    3    4    1    2
    5    3    4    2    1
    5    4    1    2    3
    5    4    1    3    2
    5    4    2    1    3
    5    4    2    3    1
    5    4    3    1    2
    5    4    3    2    1
    
最后，祝大家~~水过~~这道题！！！！

---

## 作者：liujiayuan (赞：4)

嗯，这道题的确是一道DFS的入门题，适合蒟蒻熟悉套路

~~可我还是不争气地被输出空格卡了一次，代码末端的注释就是我数空格的证明~~

#### 上代码，注释在其中
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num[20],flag[20]={0}; 
//num存每一位数，flag是标记数组
void out_put()  //输出函数，小心空格个数！！！是4个！！！
{
	for(int i=1;i<=n;i++)
	{
		cout<<"    "<<num[i];
	}
	cout<<endl;
}
void dfs(int a)   //dfs板子
{
	for(int i=1;i<=n;i++)   //从1到n枚举，可以保证字典序输出
	{
		if(flag[i]==0)   //遇到没选过的
		{
			num[a]=i;   //num的第a个存下当前数字
			flag[i]=1;   //flag数组标记走过
			dfs(a+1);    //dfs下一个数
			flag[i]=0;    //回溯
		}
	}
	if(a==n)   //满了就输出
	{
		out_put();
		return;
	}
}
int main()
{
	cin>>n;
	dfs(1);   //从1开始，从0开始也无所谓，输出改一下就好了
	return 0;
}
/*
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
*/
```


---

## 作者：夙_晏清 (赞：4)


# 算法解析

### DFS，对楼上的回溯+剪枝进行详解。

我们以N=3为例，构造一棵搜索树（或说是状态树）来进行搜索。

同时构造出三个格子，用来存放搜索树中的结果。

现在，我们从第一格开始搜索。第一格填1的搜索树如下：

所以N=3的情况下，第一格填1的排列情况共有两种123,132.

第一格填2的搜索树如下：

所以N=3的情况下，第一格填2的排列情况共有两种 213,231.

如果你看懂了，请你自己画画第一格填3的搜索树。

程序实现

我们总结一下在上一部分中的思路在程序中如何实现。

先定义两个数组，一个是用来存放解的，一个是用来标记该数是否用过。

我们可以先写一个用于打印的函数print()，每当深搜时找到一个符合条件的解时，则print()一下，输出这个解（注意题目输出要求）。

接下来就是写深搜的函数了。主要思路：先判断格子是否填满了，如果填满，则print()一下。

如果没有填满，则开始循环，在循环中先判断当前填的数是否用过，如果没有，则填入，搜索下一格。

程序实现如下：```

```



---

## 作者：赤瞳之鸦 (赞：4)

#    思路:

其实一开始是有点蒙蔽的，并不知道要说啥，后来看了仔细看了看大概懂了= =

其实题目要求的很简单，就是一个搜索挨个搜一遍而且n<=9所有的数字都不允许重复

那问题就简单了

只要开一个bool数组，判断这个数字有没有用过就行了

而且是排列数所以不需要去重复那就简单的搜索咯

边界是now=n+1的时候

此时输出就行了

特别注意一点

题目中有要求输出保留五个带宽就是printf("%5d",ans)待会介绍下!




#    关于 printf("%5d",ans)

输出方式为“%5d”表示按5位的固定位宽输出整型数值。如果不足5位，则在前面补空格；超过5位，则按实际位数输出

下面放上一段简单的测试

、、、

    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int a=123456789;
    int b=12;
    printf("%5d",a);
    cout<<endl;
    printf("%5d",b);
    cout<<"←";
    return 0;
}  
```
、、、
通过结果可以看到它不满5位的前面的123位就用空格来补上了

而%-5d则是后面不足5位的用空格补全


#    分析:

说实话一道简单的水题做成这个样子，我也是没谁了，经典的DFS模板真的很经典

仔细想了下发现就是《啊哈~算法》里面的那个分卡片问题= =我真是ZZ



忽略掉我那惨不忍睹的测试点

我特么真ZZ= =

判断是否相等我居然打成了赋值!!!!!!

没救了，看来已经是星际韩宗选手了= =

明天开始改行打星际吧= =


、、、




```cpp
#include<iostream>
#include<cstdio>            //千万不能忘了，不然不能用printf!!! 
#include<algorithm>
using namespace std;
int n,ans[10];
bool a[10];                    //bool函数默认的初始值是false所以放心大胆的用
void search(int now)        //now代表的是层数也可以理解成第几个小人
{
//    cout<<now<<endl;
    if(now==n+1)            //边界  
    {
//        cout<<now<<endl;
        for(int i=1;i<=n;i++)
        {
            printf("%5d",ans[i]);            //这里就是%5d的用到的地方！就是题目中说的那个
        }
        cout<<endl;
        return;    
    }
    for(int i=1;i<=n;i++)
    {
//        cout<<i<<endl;
//        cout<<"ha"<<endl;        
        if(a[i]==false)
        //判断是否相等的要用"=="!!! 
        {
            a[i]=true;
            ans[now]=i;
//            cout<<"ha"<<endl;
            search(now+1);
            a[i]=false;    
        }    
    }
}
int main()
{
    cin>>n;
    search(1);
    return 0;
}
```
、、、


---

## 作者：Mr_Wolfram (赞：4)

###康托展开

对于没有重复元素的全排列来说，存在如下的对应关系

X=an\*(n-1)!+an-1\*(n-2)!+...+ai\*(i-1)!+...+a2\*1!+a1\*0!

ai为整数，并且0<=ai<i(1<=i<=n)


这种对应称为康托展开，是一种全排列与整数的双射，n位（0~n-1）全排列后，其康托展开唯一且最大约为n!

可用于压缩状态，可作为Hash函数。

康托展开：

```cpp
int contor(int num[]){
    int k=1;
    for(int i=1;i<=n;i++){
        int t=0;
        for(int j=i+1;j<=n;j++){
            if(num[i]>num[j]){
                t++;
            }
            
        }k+=t*fac[n-i];
    }
    return k;
}
```
康拓逆展开：

```cpp
void recontor(int num[],int k){
    int t=0;k--;
    bool f[12]={0};
    for(int i=1;i<=n;i++){
        t=k/fac[n-i];
        int j;
        for( j=1;j<=n;j++){
            if(!f[j]){
                if(t<=0) break;
                t--;
            }
        }
        num[i]=j;
        f[j]=1;
        k%=fac[n-i];
    }
}
```
AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
using namespace std;
int init(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int fac[15]={1,1,2,6,24,120,720,5040,40320,362880};
int n=9,m[15]={0,1,2,3,4,5,6,9,7,8};
int contor(int num[]){
    int k=1;
    for(int i=1;i<=n;i++){
        int t=0;
        for(int j=i+1;j<=n;j++){
            if(num[i]>num[j]){
                t++;
            }
            
        }k+=t*fac[n-i];
    }
    return k;
}
void recontor(int num[],int k){
    int t=0;k--;
    bool f[12]={0};
    for(int i=1;i<=n;i++){
        t=k/fac[n-i];
        int j;
        for( j=1;j<=n;j++){
            if(!f[j]){
                if(t<=0) break;
                t--;
            }
        }
        num[i]=j;
        f[j]=1;
        k%=fac[n-i];
    }
}
int main(){
    freopen("in.txt","r",stdin);
    n=init();
    int cnt=1;
    while(cnt<=fac[n]){
        recontor(m,cnt);
        for(int i=1;i<=n;i++){
            printf("%5d",m[i]);
        }
        printf("\n");
        cnt++;
    }
    fclose(stdin);
    return 0;
}
```

---

## 作者：xlous (赞：4)

其实这题可以用C++的STL中提供的next\_permutation函数来做的，非常方便

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
```
- - - - - - - - - - - - - - - -


```cpp
int main()
{
- - - - int n, p[10];//定义一个数组用来存放排列的结果
- - - - cin >> n;
- - - - for(int i = 0; i < n; i++) p[i] = i + 1;//按照顺序将结果输入数组p中
          //STL库函数next_permutation的使用
- - - - do{
- - - - - - - - for(int i = 0; i < n; i++)
- - - - - - - - printf("%5d", p[i]);//千万要注意输出的格式
- - - - - - - - printf("\n");
- - - - }while(next_permutation(p, p+n));
- - - - return 0;
}

```

---

## 作者：xxckie (赞：3)

小学生来发题解了！

### 这题全排列，本蒟蒻是用**搜索**来做的

a数组是用来存放当前选择的排列顺序，b数组则是用来判断当前数是否在a数组中

出现过（其中1表示出现过，0表示未出现过）.

本题解思路是这样的：

按1~n的顺序枚举第i位（**用搜索来过渡**），再逐个判断1~n中哪个数是当前序

列没有出现过的——如果出现过，则将它存储到a数组中，继续下一位的枚举；否

则就继续下一个数的枚举.当第n位枚举完1~n时，就可以直接输出a数组.完事后，

再退回上一位，如果上一位也枚举完1~n后，就再继续退回；如果未枚举完，则把

a的当前位置清空，把b[i]的数变成0（就是代表没有出现过）.  

最后，如果n位都枚举完1~n之后，就可以stop了...

献上代码——
```c
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<fstream>
#include<cstring>
#include<string>
using namespace std;
int n,a[20],b[20];
void print()
{
	for(int i=1;i<=n;i++)
		printf("%5d",a[i]);//注意这里，意思是每个数字保留5个场

宽
	cout<<endl;
}
void dfs(int k)//k代表的是现在枚举到第k位
{
	if(k>n)//如果a数组中n位都有数了
	{
		print();//则输出现在填满的a数组
		return ;//返回上一位
	}
	for(int i=1;i<=n;i++)
	{
		if(b[i]==0)//如果现在i是没有在a中用过的
		{
			a[k]=i,b[i]=1;//那么就把i存到a中，标记b中i已经

出现过了
			dfs(k+1);//接着呢就继续枚举下一位
			a[k]=0,b[i]=0;//枚举完后面的位再返回到当前位时

，就把当前数从a中删去，标记在b中为0
		}
	}
}
int main()
{
	cin>>n;
	dfs(1);//从第一位开始搜索
	return 0;
}

```
这题的题解就是这样啦，886

---

## 作者：Adis_FireDevil (赞：3)

这是我这个蒟蒻发布的第一份题解，So—大佬勿喷。

有什么问题可以私信告诉我，给我提一些建议。

好!今天废话不多说,直接给大家~~解说一场赛马比赛~~讲解一道dfs题

全排列问题是一道特别特别特别简单的一道dfs（深度优先搜索）题

思路很简单 每一个数都搜一遍就好了

怎么搜？

注意要去重不然你的程序会 Boom

注意搜够了数就收手不然你的程序会 Boom

看不懂？代码有注释，哪里不会看哪里，so easy！

不说了 代码供上

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[9],n,ans[9];
bool k[9];
void out() {
	for(int i=1; i<=n; i++)cout<<setw(5)<<ans[i];	//输出答案，用setw 
	cout<<endl;
}
void search(int j) {
	for(int i=1; i<=n; i++) {
		if(!k[i]) {					//判断这个数是否被取过 
			j++;
			k[i]=true;				//记录这个数是否被取过 
			ans[j]=a[i];				//记录答案 
			if(j<n)search(j);			//判断是否取够数了，如果取够了则输出答案，否则继续搜索 
			else {				
				k[i]=false;
				j--;
				out();				//用out函数输出答案 
				return;
			}
			k[i]=false;				//回溯 
			j--;					//回溯 
		}
	}
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++)a[i]=i;
	search(0);
}
```
—————Adis_FireDevil的第一封题解 完——————

---

## 作者：xgl0520 (赞：3)

#全排列问题（PMN）其实就是一个深搜的问题。

核心代码：

```cpp
void mysearch(int i)
{
    int j,k;
    if (i>=n)
    {
        for (j=0; j<=n-1; j++)
        {
            cout<<setw(5)<<a[j];
        }
        cout<<endl;
    }
    else for (k=1; k<=n; k++)
            if (b[k])
            {
                a[i]=k;
                b[k]=false;
                mysearch(i+1);
                b[k]=true;
            }
}
```
##举一个3个数的全排列问题：
有三个盒子与三个数，你要把三个数分别放入盒子中。

先把1放入第一个盒子，这样还剩下两种选择。

再把2放入第一个盒子，这样第三个盒子只能装3。

第一种就出来了：1 2 3。

输出完后，把3从第三个盒子里拿出，3又可以用了，但现在你手上只有3，

于是我们在倒退一步，2也可以用了，你手上有两个数 2与3，

所以可以把3放入第二个盒子，2则放入第三个盒子

又是一种排列： 1 3 2.

同理，六种排列全出来了，问题解决。

#这就是深搜的思想

代码如下：



```cpp
#include <iostream>
#include<iomanip>
using namespace std;
int a[10],n;//定义
bool b[10];//判断这个数是否别使用过的变量（布尔数组）
void mysearch(int i)//搜索
{
    int j,k;
    if (i>=n)//已经有了n个数，构成了一种排列
    {
        for (j=0; j<=n-1; j++)
        {
            cout<<setw(5)<<a[j];//输出，注意：要保留5个常宽
        }
        cout<<endl;
    }
    else for (k=1; k<=n; k++)
            if (b[k])//此数没被使用过
            {
                a[i]=k;//赋值
                b[k]=false;//让此数使用过（术语：置位）
                mysearch(i+1);//继续搜索
                b[k]=true;//让此数以后可以使用（术语：复位）
            }
}
int main()
{
    cin>>n;
    for (int i=0; i<=n+1; i++) b[i]=true;//让所有数没被使用
    mysearch(0);//从0开始往后搜索
    return 0;
}

```

---

## 作者：hilsinleri (赞：3)

介绍两个stl的模版

prev\_permutation(beg,end,comp);

next\_permutation(beg,end,comp);

第一个函数使得[beg,end)区间变为上一个全排列。其中comp可选。如果已经是第一个了，则变为最后一个并返回false，否则返回true;

第二个函数使得[beg,end)区间变为下一个全排列。其中comp可选。如果已经是最后一个了，则变为第一个并返回false，否则返回true;

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10]={0,1,2,3,4,5,6,7,8,9},n;

int main()
{
    scanf("%d",&n);
    while(1)
    {
        for(register int i=1;i<=n;++i)
            printf("%5d",a[i]);
        putchar('\n');
        if(!next_permutation(a+1,a+n+1))
            break;
    }
    return 0;
}
//PS:%%%red sun thx & jj
```
#注意，第一遍写关于全排列的程序，建议不要用STL，否则你体会不到全排列的精华。关于普通全排列做法，我想楼下们已经讲的很详细了，我就不讲了。


---

## 作者：GEM_IU_077 (赞：3)

###dfs（pascal）！！！

采用方法：可以采用全排的手段，也可以采用**回溯+去重剪枝**。本题实质就是对n个数进行排列组合，并打印出所有的组合。现以n=3为例建立一棵搜索树，每一条路径代表一个组合。但是根据题意在对n个数值进行组合的过程中，不允许出现相同的数字，为此在对搜索树搜索的过程中可以进行适当的剪枝，这样可以大大提高搜索效率。

在程序实现的过程中定义一个函数确定该数是否被使用，没有则递归处理下一位数，否则剪枝回溯，直到k>n。

下附代码：

```pas
var
  a:array[1..100] of longint;
  i,n:longint;

function pd(k,i:integer):boolean;   //判断需排列的数字是否重复
  var
    m:longint;
  begin
    m:=1;
    while (m<k)and(i<>a[m]) do m:=m+1;   //与排列的数字比较判重
    if m=k
      then
        exit(true)
      else
        exit(false);
  end;

procedure dfs(k:integer);   //回溯搜索全排组合
  var
    i:longint;
  begin
    if k>n
      then
        begin
          for i:=1 to n do write(a[i]:5);   //完成一次数字排列后打印
          writeln;
        end
      else
        for i:=1 to n do   //从1-n完成按次序实现全排
          if pd(k,i)   //判重，逐个按序选出需排列的数字
           then
             begin
               a[k]:=i;   //选出的数字放入数组a中
               dfs(k+1);   //回溯调用排列下一位数字
             end;
  end;

begin
  readln(n);
  dfs(1);
end.
```

---

## 作者：I_will (赞：2)

### 小小回溯，大大用处！
我又来发题解！
今天的题是[P1706 【全排列问题】](https://www.luogu.org/problem/P1706),是一道运用了回溯的问题。

主要讲了：

- 输入一个数。
- 输出1~n中有几种排列方法？
- 因为n的范围不定，不能使用多重for（达标版的除外）
- 本蒟蒻运用的是**回溯**。

回溯头具体如↓
```
void quanpailie(int k)
......
quanpailie(1);
```
K的意思是第几层，达到第n+1层，就输出方案！
```
if(k>n)
{
		for(int i=1;i<=n;i++)
	{
		printf("%5d",c[i]);
	}
	cout<<endl;
	return;
}
```
就这套行云如水的程序，~~满分应该的呵呵！~~

全套程序如下↓：
```
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cmath>
int n;
int b[105];
int c[105];
int a[105];
using namespace std;
void quanpailie(int k)
{
	if(k>n){
	for(int i=1;i<=n;i++)
		{
			printf("%5d",c[i]);
		}
		cout<<endl;
		return;
}
	
	for(int i=1;i<=n;i++)
	{
		
		if(b[i]==0){c[k]=i;b[i]=1;quanpailie(k+1);b[i]=0;}
	}
	
}
int main()
{
	cin>>n;
	
	
quanpailie(1);

	return 0;
}

```
##### 希望洛谷能给我个过！

---

## 作者：lin_secret (赞：2)

采用方法：可以采用全排的手段，也可以采用回溯+去重剪枝。本题实质就是对n个数进行排列组合，并打印出所有的组合。现以n=3为例建立一棵如下图所示的搜索树，每一条路径代表一个组合。但是根据题意在对n个数值进行组合的过程中，不允许出现相同的数字，为此在对搜索树搜索的过程中可以进行适当的剪枝，这样可以大大提高搜索效率。图中用“\”实现对n=3数值的剪枝。

在程序实现的过程中定义一个函数确定该数是否被使用，没有则递归处理下一位数，否则剪枝回溯，直到k>n。

【程序代码】


```cpp
var a:array  [1..10000]  of  integer; i,n:integer;
function pd(k,i:integer):boolean;  //判断需排列的数字是否重复；
var  m:integer;
begin
  m:=1;
  while (m<k)and(i<>a[m]) do m:=m+1;//与排列的数字比较判重；
  if  m=k  then  pd:=true  else  pd:=false;
end;
procedure  try(k:integer);   //回溯搜索全排组合；
var  i:integer;
begin
  if k>n then begin                 //完成一次数字排列后打印
    for  i:=1  to  n  do write(a[i]:5);
```
writeln
 
```cpp
   end
   else
     for  i:=1  to  n  do        //从1-n完成按次序实现全排
       if  pd(k,i)  then  begin  //判重，逐个按序选出需排列的数字
        a[k]:=i    //选出的数字放入数组a中；
        try(k+1);   //回溯调用排列下一位数字; 
       end;
end;
begin
  readln(n);
  try(1);
end. 

```

---

## 作者：codesonic (赞：2)

这可能是最简单最偷懒的题解了，STL大法好啊。才23行

说道这里可能已经有人知道我的思路了吧，不知道的请看以下这个函数：

next\_permutation()

还有它的逆运算：

prev\_permutation()

第一个函数的作用求一个排序的下一个排列，可以利用它来遍历全排列,

要包含头文件<algorithm>，另外它的返回值若该序列不是最后一个排列则返回真，是最后一个排列返回0。

第二个恰好反之，就不做过多介绍

所以代码很简单：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[15];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        a[i-1]=i;
    }
    for(int i=0;i<n;i++)
        cout<<"    "<<a[i];
    cout<<endl;
    while(next_permutation(a,a+n))//利用返回值
    {
        for(int i=0;i<n;i++)
            cout<<"    "<<a[i];
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：Visors (赞：2)

这题还是尝试不用<algorithm>库函数为好，可以达到训练的目的。

若指定具体的n，我们可以很容易与穷举算法联系起来，但事实是这题的n是不定的（好在范围不大），可以利用深度优先搜索算法（DFS）解决问题。

```cpp
#include<cstdio>
int a[10],book[10],n;/*因为是全局变量，可以不用赋初值。book数组的作用是记录数字是否被填过，可以用short或bool或char替换掉，起到节约空间的作用，这一点上a也是一样。不过我们只用开一共20个空间，所以没有太大的差异。*/
void dfs(int step)   //深搜，step表示从左往右数的位数
{
    int i;
    if(step==n+1)
    {
        for(i=1;i<=n;i++)
            printf("%5d",a[i]);    //这是题目要的位宽
        printf("\n");
        return;
    }
    for(i=1;i<=n;i++){
        if(book[i]==0){
            a[step]=i;
            book[i]=1;
            dfs(step+1);      //递归下一步嘛
            book[i]=0;//book==1时意味着牌已经用过了，所以每次要记得在最后重置
        }
    }
    return;
}
int main()
{
    scanf("%d",&n);
    dfs(1);   //因为dfs里面已经写进打印了，所以直接调用即可
    return 0;
}
```（c/c++）


---

## 作者：好记一点的 (赞：2)

学C++的有福辣！

其实这题并不用下面几位神犇写的这么麻烦，蒟蒻来叫你们一种方法。

（PS.P党快转C++吧！STL炒鸡方便，我已经是晚期患者了昂）

在C++的algorithm库中有一个叫next\_permutation的函数，与之相反的有prev\_permutation，这两个用法是一样的，前者是求当前序列的下一个排列，后者反之。当有满足的序列时，返回true并且改变当前序列。大家可以到我签名里找到我的博客，里面我有写更详细的昂。

下面贴出AC代码

```cpp

#include<iostream>
#include<algorithm>
#define ff long long
#define Rep(x,a,b) for (int x=a;x<=b;x++) 
using namespace std;
ff i,j,k,l,m,n,c[1000];
int main()
{
    std::ios::sync_with_stdio(false);
    cin>>n;
    cout<<"    ";
    Rep(i,1,n) { c[i]=i; cout<<c[i]<<"    "; } cout<<endl;
    while (next_permutation(c+1,c+n+1))
    {
        cout<<"    ";
        Rep(i,1,n) cout<<c[i]<<"    "; cout<<endl;
    }
    return 0;
}

```

---

## 作者：我叫小明0_0 (赞：2)

简单的深度优先搜索，不用剪枝。。。

用printf("%5d",xxxx);按格式输出。。。

用辅助数组判重。。。

代码如下：

```cpp
  
#include<cstdio>  
#include<iostream>  
#include<cstring>  
#include<cstdlib>  
using namespace std;  
int a[10],b[10];  
int n,cnt=0;     //cnt记录答案数量
void dfs(int i){    //标准dfs框架
    if(i==n) {  
        cnt++;  
        for(int j=1;j<=n;j++) printf("%5d",a[j]);  
        cout<<endl;  
    }  
    else{  
        for(int j=1;j<=n;j++)  
            if(!b[j]){  
                a[i+1]=j;  
                b[j]=1;    //表示已用过
                dfs(i+1);  
                b[j]=0;   //记得去掉
            }  
    }  
}  
int main(){  
    cin>>n;  
    memset(b,0,sizeof(b));  //这句话并没有什么卵用。。。
    dfs(0);  
    return 0;  
} 
```

---

## 作者：courage (赞：2)

回溯即可，详见代码

如要加速可以使用putchar代替printf

事实证明常数优化的威力不容小觑

```cpp

#include<cstdio>
inline void out(int x){
    putchar(' ');
    putchar(' ');
    putchar(' ');
    putchar(' ');
    putchar(x+'0');
}
int a[10]={0},n;
bool v[10]={0};
void work(int k,int x){
    if (k==n){
        for (int i=1;i<=n;i++) out(a[i]);
        putchar('\n');
        return;
    }
    for (int i=1;i<=n;i++) if (!v[i]){
        a[k+1]=i;
        v[i]=1;
        work(k+1,i);
        v[i]=0;
    }
}
int main(){
    scanf("%d",&n);
    work(0,0);
}

```

---

## 作者：Resical (赞：2)

```cpp
//头函数系列
//这是一道标准dfs
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
int a[9]={0};
int book[10]={0};
//这里的a用来输出全排列，book用来记录，book【i】=1表示已经使用，book【i】=0表示尚未使用
int n;
void dfs(int step)
{
//这里的step是指现在在判断a[step]中可以放哪个数
    int i;
//当step==n+1时说明输出数组a中已经满了可以输出（例如输入3，那么会输出3个数，当step=4的时候说明a【1】，a[2],a[3]中都有数了可
//以输出，这里注意一定要return）
    if (step==n+1)
        {
            for (i=1;i<=n;i++)
                printf("%5d",a[i]);
//输出的格式注意要是%5d
            printf("\n");
//再强调一遍要return，不然会死循环
            return;
        }
//以上的部分为dfs中判断边界的部分
    for (i=1;i<=n;i++)
    {
//book数组是记录当你到达a【step】时数字【i】是否在a【k】（k<step）上使用过（就是说你手中还有什么数字没有用过）
        if(book[i]==0)
        {
            a[step]=i;
            book[i]=1;
            dfs(step+1);
//算法核心，以第一个为例，在a【1】中放入1后进入a【2】，此时你手中还有2-n可以放入a【2】分别尝试2-n放入a【2】一直到手上的用
//完为止，然后返回上一层，尝试下一个数
            book[i]=0;
//book【i】=0是让你在尝试下一个数的时候把之前那个数拿起来，比如你将2放入尝试后要尝试3，那么要把2从a【i】中拿出来，表现为记
//录数组book【i】=0；
        }
    }
    return;
//这里的return也是关键
}
//开始主函数
int main ()
{
    scanf("%d",&n);
//我们从输出数组a中的a【1】开始到a【n】结束
    dfs(1);
//因为step代表的是你现在处于a【step】中，所以我们应该从1开始即为dfs（1）
    return 0;
//收工
}
```

---

## 作者：fjsmghj (赞：2)

```cpp
//P1706 全排列问题
//写一个非递归的全列排问题
#include<iostream>
#include<iomanip>//setw(5)的头文件 
using namespace std;
int b[10];
int  Nextprime(int a[],int len)
{
    int i=0;
    int j=len-2,k=len-1;
    int r=len-1,s=0;
    while(a[j]>a[j+1])
    {
        j--;
        if (j==-1) return 0;
    }
    while (a[j]>a[k]) k--;
    swap(a[j],a[k]);
    s=j+1;
    while (r>s)
    {
        swap(a[r],a[s]);
        r--;
        s++;
    }
    return 1;
}
void print(int a[],int len)
{
    for (int i=0;i<len;i++)
    {
        cout<<setw(5)<<a[i];
    }
}
int main()
{
    int n;
    cin>>n;
    for (int i=0;i<n;i++)
    {
        b[i]=i+1;
    }
    print(b,n);
    cout<<endl;
    while (Nextprime(b,n))
    {
        print(b,n);
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：The_Key (赞：2)

简单的递归程序

```cpp
#include<iostream>
using namespace std;
void work(int n,int *a,int cur)//cur是记录当前数组长度的
{
    if(cur==n)//达到边界即数组已经填满，就进行输出
    {
        for(int i=1;i<=n;i++)
        cout<<"    "<<a[i];
        cout<<endl;
    }
    else //未达到边界的话就判定还有哪个数可用并将这个数填上
    for(int i=1;i<=n;i++)
    {
        int ok=1;
        for(int j=1;j<=cur;j++)
        if(a[j]==i) ok=0;//ok变量负责记录这个数有没有用过，1代表没用过，0代表用过了
        if(ok) 
        {
            a[cur+1]=i;//如果可用，把它放入数组的后边
            work(n,a,cur+1);//将调整好的数组当作参数继续进行递归
        }
    }
}
int main()
 {
     int nn[1000];
     int n;
     cin>>n;
     work(n,nn,0);
     return 0;
}//本人代码不精，大神勿喷
```

---

## 作者：Kidd (赞：2)

普及下深搜概念，深搜，是在for、while、repeat循环节无法完成时，则用深搜实现。


切记！深搜及其浪费时间，在有其他选择时，莫用深搜！！

































```cpp
var n:longint;a:array[1..9] of boolean;
procedure try(c,s:longint);
var i,j,x,m:longint;b:array[1..10] of longint;
begin
   if c>n then
   begin
      m:=0;//m初始化，否则会错
      x:=s;
      while x<>0 do
      begin
         inc(m);
         b[m]:=x mod 10;
         x:=x div 10;
      end;
      for j:=m downto 1 do
      write(b[j]:5);
      writeln;
      exit;
   end;//以上为判断到底层了木有，有输出各个数字，再把它终结掉
   for i:=1 to n do
   if not a[i] then//判断这数是否被锁，没锁则深搜。
   begin
      a[i]:=true;//锁住
      try(c+1,s*10+i);//开始深搜
      a[i]:=false;//搜完解放
   end;
end;
begin
   readln(n);
   try(1,0);//接着就交给子程序吧，子程序，我做不了，你来做，我相信你！！
end.
说实话，这是个回溯算法，不会多看
```

---

## 作者：浪遏 (赞：2)

最简单的回溯，不用任何剪枝，貌似是这道题开启了我搜索的大门…………

顺便说一下，楼下一位p党什么鬼，自己没试过吗……会误导新手的。

```cpp
var n,i:longint;
a:array [1..9] of boolean;
b:array [1..9] of integer;
procedure f(t:longint);
var i,j:longint;
begin
for i:=1 to n do
begin
if a[i] then  //如果此数没有被运用，则运用
begin
a[i]:=false;//表示此数被用过了
b[t]:=i;//存储
if t=n then begin for j:=1 to n do write(b[j]:5);writeln;end //进行输出，记得换行；还有，输出格式很无语，场宽为5，不要加空格       
else f(t+1);
a[i]:=true;//回溯
end;
end;
end;
begin
readln(n);
for i:=1 to n do
a[i]:=true;//初始化，都为真
f(1);
end.
好简单…………
```

---

## 作者：JamlainHamstone (赞：1)

从来没有写过题解的本蒟蒻突然今天心血来潮开始写题解。。。

这道题可以以树和递归为基础用回溯方法做出。

可以把每一次进行排列时的选数过程看成是一个节点，每选一次便进入下一个节点，也就是进入下一层。
当计算到最底端的一层时(第n层），（要排列的数的个数n），就是递归的边界。

程序实现如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000],b[1000];
void search(int x){//表示从第x层开始搜索
	if(x==n+1){//搜索到底，到达递归边界
		for(int i=1;i<=n;i++){
			printf("%5d",b[i]);//输出
		}
		cout<<endl;
		return;
	}
	for(int i=1;i<=n;i++){
		if(a[i]==0){
			b[x]=i;//储存被选择排列的数
			a[i]=1;//标记已被选择的数
			search(x+1);//搜索下一层
			a[i]=0;//回溯
		}
	}
}
int main(){
	cin>>n;
	search(1);
	return 0;
}
```


---

## 作者：Drinkkk (赞：1)

/\*
P1706 题解

深度优先搜索

\*/
/\*
再给出代码之前，我们可以先看一看3的全排列：

1    2    3

1    3    2

2    1    3

2    3    1

3    1    2

3    2    1

我们可以观察一下，第一个数先是1，再是2，最后才是3，你会发现，后面也是这样的，思想：

我们可以先看一看第一位还有那些数字没有用过，我们就将这个数放到这一位上（即a[x]=i，x表示当前要选一个数放在第x位上），并标记一下b[i]为1（即表示i这个数字已经用过了），然后继续去下一位搜索，然后再将b[i]标记为0即可，然后，如果这个x刚好等于n+1，那么就表示已经做完了整个过程了，可以输出答案了。

再提供一下2和4的全排列（注意观察）：

2的全排列：

1    2
2    1
4的全排列：

1    2    3    4

1    2    4    3

1    3    2    4

1    3    4    2

1    4    2    3

1    4    3    2

2    1    3    4

2    1    4    3

2    3    1    4

2    3    4    1

2    4    1    3

2    4    3    1

3    1    2    4

3    1    4    2

3    2    1    4

3    2    4    1

3    4    1    2

3    4    2    1

4    1    2    3

4    1    3    2

4    2    1    3

4    2    3    1

4    3    1    2

4    3    2    1

以下就是代码部分了：

\*/
```cpp
#include <cstdio>//头文件
int a[10001],b[10001];//定义数组，a数组是用来存数的，b数组是用来表示这个数有没有被用过的
int n=0;//定义变量，n表示的是要求的是从1到n的全排列
void dfs(int x)//深度优先搜索（x表示的是当前要存储的是第x个数，即a[x]）
{
    if(x==n+1)//如果全部都做完了（请想一下为什么要写成x==n+1，而不是x==n）
    {
        for(int i=1;i<=n;i++)//输出这n个数
        {
            printf("%5d",a[i]);//输出第i个数（即a[i]）
        }
        printf("\n");//输出换行
        return ;//结束该函数
    }
    for(int i=1;i<=n;i++)//从1~n进行循环选数
    {
        if(b[i]==0)//如果这个数没有用过
        {
            a[x]=i;//存一下数
            b[i]=1;//标记一下这个数i已经用过了
            dfs(x+1);//继续去下一个位置搜索
            a[x]=0;//清零（也可以不写这句话）
            b[i]=0;//标记一下这个数i还没有用过
        }
    }
}
int main()//主函数
{
    scanf("%d",&n);//输入n（表示接下来要求的是从1到n的全排列）
    dfs(1);//从第一个位置开始搜索（即从第一个位置开始选数）
    return 0;//结束程序
}
```

---

## 作者：须一心 (赞：1)


    
  
                 
         
  
  

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<iomanip>
 using namespace std;
 int a[1000]={0},n;   ** //a数组控制当前情况下数字的控制a[1]代表第一位数字,a[2]代表第二位数字......**
 bool b[1000]={0};     **//b数组控制当前情况下某数字是否被占用b[1]==0代表数字1没有被占用b[2]==1代表数字2被占用**
 int print()                  **//输出函数**
  {
    for(int i=1;i<=n;i++)
     {
       cout<<setw(5)<<a[i];    **//一定要注意这里带宽为5许多人没过掉就是因为这**
     }
       cout<<endl;  
  }
  int search(int k)   ** //k代表位数,第一位第二位......**
   {  
      for(int i=1;i<=n;i++)
       {
          if(!b[i])
           {
                a[k]=i;
                b[i]=i;
                if(n==k)  //如果此种排列组合完成则输出
                 print();
                 else search(k+1);
            b[i]=0;//回溯
           }
       }
   }
 int main()
  {
    cin>>n;
    search(1);
    cout<<endl;
}
```

---

## 作者：秋名山车神 (赞：1)

递归算法，这题其实和8皇后问题差不多，但是因为不用考虑皇后会互相攻击，要简单一些，思考时建议脑补出一个国际象棋盘，这样下面那些”行“就看的懂了

```cpp
var
n:integer;
a,f:array[1..1000]of integer;
Procedure dfs(k:integer);
var
i,j:integer;
begin
  if k>n then // 当k>n的时候，就是到了这一行数的边缘，所以输出这一行数
  begin
    for i:=1 to n do write(a[i]:5);  //注意输出格式
    writeln;
  end
  else
  for j:=1 to n do
  begin
    if f[j]=0 then //f[j]=0，说明这一行还没有数字
    begin
      a[k]:=j;  //没有数字，就把当前这个填上
      f[j]:=1;  //于是这行就被占用了
      dfs(k+1);  //考虑下一个数字
      f[j]:=0;  //因为每一层之后要把下一个数字作为起点那个，所以回归每一行都是0
    end;
  end;
end;
begin
  read(n);
  dfs(1);
end.
```

---


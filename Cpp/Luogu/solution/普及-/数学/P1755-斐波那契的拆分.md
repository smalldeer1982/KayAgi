# 斐波那契的拆分

## 题目背景

无

## 题目描述

已知任意一个正整数都可以拆分为若干个斐波纳契数，现在，让你求出 $n$ 的拆分方法。


## 说明/提示

若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组。

对于$100\%$的数据，$t \leq 1000$，$1 \leq n \leq 10^{9}$。

## 样例 #1

### 输入

```
1
1
```

### 输出

```
1=1```

## 样例 #2

### 输入

```
1
10```

### 输出

```
10=2+8```

# 题解

## 作者：shame_djj (赞：40)

这题作为橙题我觉得技术含量还是挺高的

众所周知 fibonacci数列在第92项时会很大

（用我们教练的话来说就是“long long也救不了你”）

但是fibonacci会在多少项时爆int呢

这是一个问题

于是我们就需要先算一算第几项爆int

这个过程当然是交给计算机来做

由于太简单我就不粘代码了

但是这也体现了我们编程的实用性

用代码来解决实际的问题（而不是仅仅的用来参加算法竞赛什么的）

所以解这道题第一点是算fibonacci

至于第二点怎么模拟就比较简单了

从小到大1的输出

一个简单的贪心思路：从最大的fibonacci数开始选

能选就一直选，直到选不了了

从小到大输出，我们可以通过stack来实现

（~~当然你也可以直接反着输出~~）

至此这题就完了

下面奉上我鬼畜的代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <stack>

using namespace std;

long long int f[100] = {1, 1};
stack <int> s;

int main() {
	for (register int i = 1; i <= 45; i ++)
		f[i] = f[i - 1] + f[i - 2];
	int T, n; cin >> T; for (; T; T --) {
		cin >> n; cout << n << '=';
		for (register int i = 45; i >= 1; i --) {
			while (n >= f[i]) s.push(f[i]), n -= f[i];
			if (n == 0) break;
		}
		while (s.size()) {
			if (s.size() == 1) {
				printf ("%d\n", s.top());
				s.pop();
				break;
			}
			printf ("%d+", s.top());
			s.pop();
		}
	}
	return 0;
}
```
祝大家 Noip rp++

也希望我以后能更努力一些，加油!

---

## 作者：蒟蒻lxy (赞：19)

# 这题可以用暴力打表
经测试，到第46项爆int，
所以：
```
#include<bits/stdc++.h>
using namespace std;
int f[101];
int feb(int i)
{
	if(f[i]!=0)
		return f[i];
	if(i==1 || i==2)
	{
		f[i]=1;
		return 1;
	}
	f[i]=feb(i-1)+feb(i-2);
	return f[i];
}
int main()
{
	feb(100);
	for(int i=1;i<=45;i++)
		cout << f[i] <<',';
	return 0;
}

```


------------

#### 打到txt里
#### 然后
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[1000001];
int feb[46]={0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170};
int main()//大型打表
{
	int t,n;
    cin >> t;
    for(int i=1;i<=t;i++)
	{
        cin >> n;
        int a=n;
        int len=0;
        for(int k=45;k>=1;k--)//处理
		{
            if(feb[k]<=a && a>=0)
			{
                a-=feb[k];
                ++len;
                b[len]=feb[k];
			}
        }
        printf("%d=",n);
        for(int k=len;k>=1;k--)//输出
        {
			if(k!=len)
				cout <<'+';
            cout << b[k];
		}
        cout << endl;
    }
    return 0;
}

```
就这样。。。

---

## 作者：jun1lesszZZ (赞：11)

## 写一种新做法：

- ### 首先用筛法的思想将所有菲波那契数筛出来，用bool型数组记录，因为bool型占空间小所以可以开到$1e9$；
- ### 在线处理每一次询问的值 $test$，从 $test$ 开始从大到小循环枚举每一个数，检查是否是菲波那契数，如果是则将当前数压入储存答案的栈中（从大到小循环是因为答案要求选择右边较大的，而用栈保存答案可以保证从小到大输出）
- ### 储存当前数后让 $test$ 减去选择的数,当 $test$ 变为$0$时说明所选择的菲波那契数已经组成了询问的值，break； 


------------

### 接下来是代码：
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <stack> 
const long long N = 1134903199;
bool fib[N];
using namespace std;
int main() {
    int n;
    scanf("%d",&n);
    fib[1] = fib[2] = 1;
    long long a,b,temp;temp = a = b = 1;
    for(int i = 1;i <= 44;i ++) {//最大数据1e9，斐波那契数列的增长是非常恐怖的，只需要循环到44次便超过了1e9
        fib[b] = 1;//标记此数为菲波那契数
        temp = a;
        a = b,b = temp + b;
    }
    int test;
    for(int i = 1;i <= n;i ++) {
        scanf("%d",&test);//输入询问值
        stack<int>qwq;
        printf("%d=",test);
        for(int j = test;j >= 1;j --) {
            if(fib[j] && test > 0) {//满足j为菲波那契数&&test>0的要求时才合法
                 qwq.push(j);
                 test -= j;
                 j = test + 1;
            }
            if(test == 0) break;
        }
        printf("%d",qwq.top());qwq.pop();//输出当前询问结果
        while(! qwq.empty()) {
            printf("+%d",qwq.top());
            qwq.pop();
        }
        printf("\n");
    }
}

---

## 作者：lamboo (赞：8)

本题其实只要模拟就可以了（再加上一点贪心思想）

先求出每一个斐波那契数，再判断是否小于当前数（也就是可以取）

贪心：要使得最后结果数最少，那么我们每次都取能取里的最大的，让剩下的数小

我们可以从后往前判断当前斐波那契数是否能取，如果能取，他一定是能去中最大的

我们接下来只要从当前剩下的数里找就可以了，这样做每个数只需要一趟，不然会超时两个点


代码：

```cpp
#include <string.h>
#include <cstdio>
using namespace std;
int main()
{
    int a[50],b[50],n,t,w,x,y;
    a[1]=1;a[2]=1;
    for (int i=3;i<=45;i++) 
        a[i]=a[i-1]+a[i-2];  //a数组保存斐波那契数列
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        w=0;
        scanf("%d",&t);
        x=t;
        memset(b,0,sizeof(b));  //初始化
        while (t>0)
        {
            y=45;
            while (y>0)
            {
                if (a[y]<=t)  //可以取
                {
                    w++;  //统计取的数量
                    b[w]=a[y];  //将取的数保存
                    t=t-a[y];
                }
                else y=y-1;  //有可能会有两个相同的数，如4=2+2，要注意这种情况
            }
        }
        printf("%d%s",x,"=");
        for (int j=w;j>0;j--)  //因为b里是从大到小排序的，所以我们反着输出
            if (j==1) printf("%d\n",b[j]);  
            else printf("%d%s",b[j],"+");
    }
}
```

---

## 作者：FR_qwq (赞：5)

这道题我们可以这样做：
先找出在那个数中最大的斐波那契数，然后再把那个最大的斐波那契数给减掉，之后再以上面的方式继续做，最后对所得到的数进行快排，输出结果。

以下程序段为拆分那个数：
```pascal
procedure chai(n:longint);
begin
t:=t+1;//用t来计算数组总数据
a[t]:=fei(n);//等会儿给你们展示fei这个函数
n:=n-fei(n);//拆分
if n=0 then exit;//拆分完毕，退出
chai(n);//继续拆
end;
```
这就是fei这个function：
```pascal
function fei(k:longint):longint;
var x,y,p:longint;
begin
x:=1;y:=1;//赋初值
while y<=k do
  begin
  p:=x;x:=y;y:=y+p;//斐波那契
  end;
exit(x);//注意：这里不是返回y，是x（p也行）
end;
```
现在就可以把程序编出来了：
```pascal
var i,n,t,j,x:longint;
a:array[1..1000000] of longint;//数组可以开大一点
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;//从C盘里“偷来”的快排
function fei(k:longint):longint;
var x,y,p:longint;
begin
x:=1;y:=1;
while y<=k do
  begin
  p:=x;x:=y;y:=y+p;
  end;
exit(x);
end;//刚才的fei
procedure chai(n:longint);
begin
t:=t+1;
a[t]:=fei(n);
n:=n-fei(n);
if n=0 then exit;
chai(n);
end;//刚才的chai
begin
readln(n);
for i:=1 to n do
  begin
  fillchar(a,sizeof(a),0);{等于for j:=1to t do a[j]:=0;}
  t:=0;//注意赋初值0
  read(x);
  chai(x);//把x给拆了
  sort(1,t);//要从小到大输出哦
  write(x,'=');
  for j:=1 to t-1 do
    write(a[j],'+');
  writeln(a[t]);//植树问题，最后一个不用加加号
  end;
end.
```


---

## 作者：_tommysun_ (赞：4)

这道题其实挺简单的，随便贪心一下就能过。

**整体思路如下**：

- 首先，求出范围内所有斐波那契数（可以通过baidu或者自己写代码来确定范围，判断是否超过了范围。本人算出来是45左右）。

- 由于输出时需要从小到大，可以用栈来解决
（STL大法好）。当然用数组模拟一下栈也是可以的。

- 接下来就开始贪心了。为了使个数最小，所以要从最大的斐波那契数开始枚举。斐波那契数都要存到栈中，方便输出。可以用一个布尔型变量来解决加号的问题，具体可以看下面的代码

代码：
```
#include<bits/stdc++.h>
using namespace std;
stack <int> st;
int main(){
	int n;
	cin>>n;
	int f[50];
	f[1]=f[2]=1;
	int a[n+10];
	for(int i=0;i<n;i++){
		cin>>a[i];
	} 
	bool flag=true;  //判断是否要加"+" 
	for(int i=3;i<=45;i++){
		f[i]=f[i-1]+f[i-2];
	}
	for(int i=0;i<n;i++){
		cout<<a[i]<<"=";
		for(int j=45;j>=1;j--) /*开始贪心。*/
		{
			while(a[i]>=f[j])  //使拆分出的斐波那契数最大
			{
				a[i]-=f[j]; 
				st.push(f[j]);        //向栈中添加一个元素。 
			} 
		} 
		while(!st.empty()) //empty能判断栈是否为空，加上一个逻辑非便使其意义相反。 
		{
			if(flag==true){
				cout<<st.top(); flag=false;
			} 
			else cout<<"+"<<st.top(); //top返回栈顶
			st.pop(); //删除栈顶元素 
		} 
		cout<<endl; 
		flag=true; //别忘了重新给flag赋值！ 
	}
	return 0;
}
```


---

## 作者：剪夏罗 (赞：4)

蒟蒻一枚，看题解很少，就来发一下我已经过了的代码，请大神多多指教。

数据貌似很弱，所以数组随便开了一个，2333……

接下来是代码，以及我做题的思路：


    
    
```cpp
#include<cstdio>
const int maxn=1000000;
long long b[maxn],tree[maxn];
int main()
{
    //计算100以内斐波那契数列 100的斐波那契= 1167376323 >> 10^9 
    tree[0]=1,tree[1]=1;//先定几个初值，以便推导计算 
    for(int i=2;i<=100;i++){
        tree[i]=tree[i-1]+tree[i-2];//斐波那契数列的推导公式 
    }
    int t,n;
    scanf("%d",&t);//输入t 
    for(int i=1;i<=t;i++){//i<=t 接收t组数据并处理 
        scanf("%d",&n);
        int a=n;//将要拆分的数赋值，防止被更改 
        int len=0;//计算拆分斐波那契的个数 
        for(int k=100;k>=1;k--){
            if(tree[k]<=a && a>=0){//a==0时结束，代表已拆分完毕 
                a-=tree[k];//每拆分一个就减掉一个 
                ++len;
                b[len]=tree[k];//记录下来 
//                printf("%d\n",a)；
//                printf(len == 1 ? "%d" : "+%d",tree[k]);打印中间值，判断思路是否正确
            }
        }
        printf("%d=",n);
        for(int k=len;k>=1;k--){//倒序输出 
            printf(k==1 ? "%d" : "%d+",b[k]);//三目运算符用于保证格式的正确输出 
        }
        printf("\n");//若有多组数据需换行 
    }
    return 0;
}
```

---

## 作者：Tgotp (赞：3)

这道题预处理就好了！

然后答案倒序输出




```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,t,b[100000];
long long a[10000];
long long f(long long x)
{
    if(x<=2)return a[x]=1;
    if(a[x])return a[x];
    else return a[x]=f(x-1)+f(x-2);
} 
int main()
{
    cin>>t;//读入次数 
    int k;
    f(45); //预处理 
```
/\*
    for(int i=1;i<=45;i++)

    printf("%d\n",a[i]);

\*/
```cpp
    while(t--)
    {
        scanf("%d",&n);
        printf("%d=",n);
        int ans=0;
        for(int i=45;i;i--)     //计算，找最大小于n的数，然后保存位置 
        {
            if(n>=a[i])
            {
                b[ans++]=i;
                n-=a[i];
                i++;
            }
            if(n==0)break;
        }
        while(ans)
        {
            if(ans==1)
            {
                printf("%d\n",a[b[0]]);         //倒序输出 
                break;
            }
            printf("%d+",a[b[--ans]]);
        }
    }
    return 0;
}
```

---

## 作者：MilkyCoffee (赞：2)

本题其实是一道模拟再加一点点贪心

首先，求出每一个斐波那契数，再判断**是否小于当前数**（也就是可以取）

贪心：如果我们要让最后结果数**最少**，那么我们每次都取**能取里的最大的**，让剩下的数小

我们需要**从后往前**判断当前斐波那契数是否能取，如果能取，一定是能取中最大的

我们接下来只要从当前剩下的数里找就可以了，这样做每个数只需要一趟，不然会 $T$ 两个点

代码：
```
#include <bits/stdc++.h>
using namespace std;

int a[50], b[50], n, t, w, x, y;

int main() {
    a[1] = 1;
    a[2] = 1;
    for (int i = 3; i <= 45; i++)  a[i]=a[i-1]+a[i-2];
    cin >> n;
    
    for (int i = 1; i <= n; i++) {
        w = 0;
        cin >> t;
        x = t;
        memset(b, 0, sizeof(b));// 每次都要初始化b
        while (t > 0) {
            y = 45;
            while (y > 0) {
                if (a[y] <= t) {
                    w++;
                    b[w] = a[y];
                    t -= a[y];
                }
                else y--;  //有可能会有两个相同的数
            }
        }
        cout << x << "=";
        for (int j = w; j > 0; j--)  //反着输出
            if (j == 1) cout << b[j] << endl 
            else cout << b[j] << "+";
    }
}
```

---

## 作者：Invalid_index (赞：2)

看了各位犇犇的做法  
我发现大多用了栈  
（其实栈更简单一些  
这道题作为一道橙题  
对一些刚入门的比我强的OIer不太友好  
所以
## 我选择用数组
###### 顺便加个时间优化
某OI教练如是说：  
斐波那契数列在92项就爆了long long  
所以我们先把斐波那契数列处理一下
```
unsigned long long fib[92];
void fi() {
	fib[1]=fib[0]=1;
	for(int i=2; i<92; i++) {
		fib[i]=fib[i-1]+fib[i-2];
	}
	return;
}
```
但是看了这题范围  
貌似。。。。int就够了  
~~没事，你这么蒻没人会说你（逃~~  
接下来就是我们的拆分部分  
这里是一种时间复杂度稍微高一点的做法  
```
maxx=92;
for(int j=maxx; j>0; j--) {
	if(temp>=fib[j]) {
		temp-=fib[j];
		k++;
		ans[k]=fib[j];
	}
	if(temp==0){
		j=0;
	} 
}
```
这个代码，你会发现在每一次减完了之后会再从92在重新找一遍，各位犇犇由于开的是int有45项不用担心，但是我们要考虑出现pow(2,64)-1（详见2019 CSP-S D1 T1）的情况，所以我们要考虑大一点的解。  
### 一次被卡unsigned long long 十年怕unsigned long long  
接下来是优化了一下的做法
```
for(int j=maxx; j>0; j--) {
	if(temp>=fib[j]) {
		temp-=fib[j];
		maxx=j;//这里就是优化
		k++;
		ans[k]=fib[j];
	}
	if(temp==0){
		j=0;
	} 
}
```
我们可以看到由于斐波那契的特性  
后一项一定是前一项的二倍小   
所以一项不会出现两遍  
直接记录下来这个位置就可以继续向前面继续搜比他小的  
由于我们已经记录下来了有k项  
可以直接sort排序  
之后直接按照格式输出  
什么？  你输出总是在后面又有一个+号？  
直接把他判掉
```
	if(i==k) {
		continue;
	}
	cout<<"+";
```
你以为这样就结束了？  
不！  
因为你用的是数组，又有多组数据。  
所以你需要memset一下  
当然你也需要更新k  
还要输出换行  
否则50分
##### 通过率的教训
```
	cout<<endl;
	memset(ans,0,sizeof(ans));
	k=0;
```   
##### 避免50分三件套，多组数据必备每次养成好习惯  
原代码就不需要放这了吧  
相信各位看了本蒻筠的题解之后也有思路了吧  
祝各位RP++

---

## 作者：ljw2005 (赞：2)

``` cpp
在题解里好像没有看见用栈的
右边的项最大，就得数组从后往前找
我不知道有多少个数字，就开栈了
还有一些细节见代码
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
int f[50];
int main()
{
	int i,t,n,l,m,len;
	f[0]=1,f[1]=1;
	for(i=2;i<=45;i++) f[i]=f[i-1]+f[i-2];
    //造斐波那契数列,地45项为1836311903
	scanf("%d",&t);
	while(t--){
		l=45,len=0;//第一次提交放在了外面，结果就错了，提醒大家要小心，len为栈里有多少个数字,l是上一次的下标，第一次开始，从最后找
		stack <int> a;//开循环里面，直接清零
		scanf("%d",&n);
		m=n;
		while(n)
			for(i=l;i>=1;i--)
				if(f[i]<=n&&f[i+1]>n) a.push(f[i]),n-=f[i],l=i,len++;//循环处理
		printf("%d=",m);
		while(len>1) printf("%d+",a.top()),a.pop(),len--;//最后一个单独输出
		printf("%d\n",a.top()),a.pop();//习惯性出栈
	}
	return 0;
}
希望能帮到大家
```

---

## 作者：北北北北 (赞：1)

有两种做法，第一种用七层for嵌套暴力搜就可以了，第二种就是

用贪心来解决，即要斐波那契数个数最少，则需要让n从最大的斐

波那契数减起，其中在减的时候，我们要确保n要比当前和它做差的

斐波那契数要大，若n小于当前这个斐波那契数，则看下一个斐波那

契数，直至n=0或所有斐波那契数看完。




------------


```c
#include <stdio.h>

int fib[30];
int ans[10];

int main(){
    int t,n,sum,index;
    int i;
    
    fib[0] = 1;
    fib[1] = 1;
    for(i = 2; i < 30; i++){
        fib[i] = fib[i-1]+fib[i-2];
    }
    scanf("%d", &t);
    while(t){
    	index = 0;
        scanf("%d", &n);
        sum = n;
        for(i = 29; i >= 0; i--){
			sum -= fib[i];
			ans[index] = fib[i];
			index++;
			if(sum < 0){
				sum += fib[i];
				index--;
			}
			if(sum == 0){
				break;
			}
		}
		if(sum == 0){
			printf("%d=%d", n,ans[index-1]);
			for(i = index-2; i >= 0; i--){
				printf("+%d", ans[i]);
			}	
		}
		else{
			printf("%d=%d", n,n);
		}
		printf("\n");
        t--;
    }
    
    return 0;
}
```


---

## 作者：Laser_Crystal (赞：0)

## 我们坚信：暴力出奇迹！
这题其实打一个暴力就能过，具体思路是先把斐波那契数列的前45项求出来（只要大于10^9就行了，弄个五的倍数吉利~QAQ~）

斐波那契数列求出来了后，进行一个贪心（**当前最大可选那个**），从后面大的数据开始算（原题：**若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组**）

贪心过后，把答案存在一个数组里，逆序输出。

代码如下（纯净代码）
```cpp

#include<bits/stdc++.h> //懒人专用，但比赛可能会爆ling。
using namespace std;
long long a[45];
void fen(int x)
{
	cout<<x<<"=";
	int q[45],w=0;
	memset(q,0,sizeof(q));//个人习惯
	int k=x;
	while(k>0)
	{
		int l=45-1;
		while(a[l]>k&&l>=0) l--;
		q[w]=a[l];
		w++;
		k-=a[l];
	}
	cout<<q[w-1];//格式输出
	for(int i=w-2;i>=0;i--) cout<<"+"<<q[i];
	cout<<endl;//洛谷识别不出/n
}
int main()
{
	a[0]=a[1]=1;
	for(int i=2;i<45;i++) a[i]=a[i-1]+a[i-2];
    //构造数列
	int t,n;
	cin>>t;
	while(t--) 
	{
		cin>>n;
		fen(n);//自动忽略函数名T_T
	}
	return 0;
}
```
这是本蒟蒻的第四篇题解，管理大大求过

---

## 作者：BLUE_EYE (赞：0)

本来以为还要暴搜  因为看数据不大  A了看题解才看到直接做就好

下面贴上代码  其实暴搜不是很必要 并没有什么用

其实只要模拟即可

——-——-——-分割线——-——-——-——

        
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[60],i,j,x,t,tot,pd,b[60],all;//B数组用于记录
void work(int k)//暴搜
{
    if(k==0)
    {
        pd=1;
        return;
    }
    for(int i=all;i>=1;i--)
    {
        while(k-a[i]>=0)
        {
            k-=a[i];
            b[++tot]=a[i];
            work(k);
            if(pd==1)
                return;
            tot--;
            k+=a[i];
        }
    }
}
int main()
{
    a[1]=1;a[2]=2;i=3;
    while(a[i-1]<=1e9)//预处理兔子数列
    {
        a[i]=a[i-1]+a[i-2];
        i++;
    }all=i-1;
    scanf("%d",&t);
    for(i=1;i<=t;i++)
    {
        scanf("%d",&x);
        pd=0;
        cout<<x<<"=";
        work(x);
        for(j=tot;j>=2;j--)
        {
            cout<<b[j]<<"+";
            b[j]=0;
        }
        cout<<b[1]<<endl;
        b[tot]=0;//初始化
        tot=0;//初始化
    }
}
```

---

## 作者：七心海棠 (赞：0)

P党的看过来！！！

思路很简单，对数字n进行如下操作：

1、找到n以内最大（包括n）的斐波纳契数

2、存入这个斐波纳契数

3、n-这个斐波纳契数，如果<>0则重新再来。

代码如下：

```cpp
program li;
var
  n,h,i,ns,j,max:longint;
  a,b,c:array[1..100000] of longint;
procedure faf(k:longint);//输出
var
  i:longint;
begin
  write(h,'=');
  for i:=k-1 downto 2 do
  write(c[i],'+');
  writeln(c[1]);
end;
procedure fac(nn,k:longint);//执行3条命令
var
  i:longint;
begin
 if nn=0 then begin faf(k);exit;end;
 for i:=1 to ns do
 if b[i]>nn then begin c[k]:=b[i-1];fac(nn-b[i-1],k+1);break;end
            else if (b[i]=nn) and (k=1) then begin writeln(h,'=',b[i]);exit;end;//如果本身就是质数则直接输出
end;
begin
 readln(n);
 for i:=1 to n do
 begin
 readln(a[i]);
 if a[i]>max then max:=a[i];//找到输入最大的数，以便读入斐波那契数
 end;
 b[1]:=1;
 b[2]:=1;
 i:=2;
 while b[i]<max do
 begin
 inc(i);
 b[i]:=b[i-1]+b[i-2];
 end;//把斐波那契数都找出来
 ns:=i;
 for i:=1 to n do
 begin
 h:=a[i];
 if a[i]=1 then writeln(1,'=',1)//1的话直接输出
           else fac(a[i],1);
 end;
end.
这是本人第一次发题解，有错请勿喷。
```

---


# 质因子分解

## 题目描述

对 $N!$ 进行质因子分解。

## 说明/提示

$10! = 3628800 = (2^8) \times (3^4) \times (5^2) \times 7$。

## 样例 #1

### 输入

```
10```

### 输出

```
2 8
3 4
5 2
7 1```

# 题解

## 作者：张皓涵 (赞：162)

这题主要思想是：开个数组，存质数个数，先定义为全为0，以便输出时判断，然后1、2、3...、n分别求质因子，不用判断是不是质数，因为每个质因子我们都一直除，直到不能再除，以后也不会出现可以除的数是此数的倍数了，相当于已经筛掉了，看代码吧。
    
        
    #include<iostream>
	using namespace std;
	int a[10001]={0},n; //数组很大，记得开在外面哦
	int main()
	{
		cin>>n;
		for (int i=2;i<=n;i++) //1就不用了，从2到n一个一个来
		{
		 	int i2=i;  //备份一下，不然等会被除掉了
			for (int j=2;j<=i;j++)  //从2开始判断是否可以整除
				while (i2%j==0) {a[j]++; i2/=j;} 
                //记得使用while，不是if，要一除到底
		}
		for (int i=1;i<=10000;i++)  //输出
        	if (a[i]!=0)
        		cout<<i<<" "<<a[i]<<endl;
	}

---

## 作者：用户已注销 (赞：99)


（拍桌子）

 **N的范围为什么是一万啊！至少也是四十万啊！**

分解(N!)的质因数是一道数论的裸题啊，而且完全可以做到接近线性的时间。

既然有更优秀的算法，我们当然要学习咯！

首先要用线性筛素数，筛出N以内的所有素数（不会线性筛也要写个埃式筛法啊）。

由于(N!) = 1 × 2 × 3 × …… × N

所以对于N以内的质数P，出现的次数为

[N/P] + [N/P^2] + [N/P^3] + …… + [N/P^(log(P)N)]

为什么呢？首先P的倍数有1个质因子P，P平方的倍数有2个质因子P，由于P平方的倍数一定是P的倍数，所以先前已经计入过一次，就只需再计入一次，P立方等等也是同理。

那不是就做完了吗，代码三十多行，而且时间复杂度O(NloglogN)，比朴素算法还好写。（为什么复杂度有两个log请自行百度埃式筛法）

**再说一遍啊！我们程序员追求的是最优解呐！**

---

## 作者：5ab_juruo (赞：30)

作为小学奥数学生，~~被这种题虐过无数次~~知道这种题的神奇做法。

## 方法就是

将一个质数不断除本来的阶乘最大数，并把这些商全部加起来。编程代码即为：
```cpp
while (base > 0)
{
	base /= prime;
	count += base;
}
```
为什么呢？我们来想一想: （以100！举例）

假如我们把所有会贡献质因子的数列出来的话，就是这样：

$1,2,3,4,5,6 …… 97,98,99,100$

我们不妨想一想，这当中有哪些会贡献一个2？
列出来的话，就是这样：

$  2 ,  4  , 6 ……    98  ,  100$

可以看到，正好占了$[ n/2 ]$个。

那这些数中，又有几个数会再贡献一个2？

$4, 8, 12 …… 96, 100$

也可以看出，占了$[n/2^2]$个。

这样就容易看出，为100！贡献的2共有：
$[n/2]+[n/2^2]+[n/2^3]+……$

这样虽然是个无穷数列，但是一旦$2^k>n$，后面就全是0。

所以我们仅需计算$[n/2]+n[n/2^2]+……+[n/2^{k-1}]$即可。

其余质因数也同理，所以我们先要算出所有比$n$小的质数：
```cpp
memset (&isprime[0], true, 10001 * sizeof (bool));
isprime[0] = isprime[1] = false;

for (int i = 2; i <= fact_base; i++)
	if (isprime[i])
	{
		primes[Index] = i;
		for (int j = 2 * i; j <= fact_base; j += i)
			isprime[j] = false;
		Index++;
	}	
```

然后就可以开始愉快地算啦~~
```cpp
for (int i = 0; i < Index; i++)
{
	int count = 0, prime = primes[i], base = fact_base;
	while (base > 0)
	{
		base /= prime;
		count += base;
	}
	
	cout << prime << " " << count << endl;
}
```

若想知道代码效果，[这里走，顺便带走全部代码](https://www.luogu.org/record/show?rid=13900912)。


---

## 作者：大魔鬼灿灿 (赞：18)

### 这道赤裸裸的数论，一个比较简单的办法，找质数加判断是不是整除i，直到该n！变成1

## 上思路

### 主要思路
```

 1.筛素数，因为n的范围是10000，所以要筛到10000，这样就不怕     素数不够了

 2.开始分解n！，不用把n的阶乘求出来，只需要一个循环，从2循     环到n，把每个数分解的变成1即可。

 3.把所有质因数输出来就可以了

```
### 我的代码：

```

1.a数组存n！的质因数，pd数组判断质数

2.初始所有数都是质数，a数组清空,输入n

3.开始筛素数，循环只需从2循环到100就可以了

  筛掉所有质数的倍数，剩下的就是合数

4.开始分解n！，i从2到n，b是当前的i

  质因数分解b，直到b变成1

5.输出有质因数和个数就可以了

```
## 上代码

```
#include<cstdio>
#include<cstring>
#include<algorithm>
int n,a[10001];
bool pd[10001];
int main()
{
    memset(pd,1,sizeof(pd));
    memset(a,0,sizeof(a));
    scanf("%d",&n);
    for(int i=2;i<=100;i++)
      if(pd[i])
    	for(int j=2;i*j<=10000;j++)
    	  pd[i*j]=0;
    for(int i=2;i<=n;i++)
    {
        int b=i;
        for(int j=2;j<=n;j++)
          if(pd[j])
            while(b%j==0)
            {
                a[j]++;
                b/=j;	
            }
    }
    for(int i=2;i<=n;i++)
      if(a[i]!=0)
    	printf("%d %d\n",i,a[i]);
    return 0;
}

```

---

## 作者：Clever_Jimmy (赞：15)

upd on 2019/8/30 ： 谢谢@のののの指出的错误：

原代码的`prime(x)`函数中的`return 1;`应放在`else`中。

这道题4个要点：

1.怎么判别因子？

2.怎么判别质数？

3.怎么统计个数？

4.阶乘太大会爆unsigned long long怎么办？

解决办法也很简单：

1.用模运算%；

2.用自定义函数prime(x)；

3.用类似于桶排序的概念，用一个数组来统计个数；


		即如果k是某个数的质因子，则count[k]++;

4.如果会爆内存，就一步一步算，不要一次性把结果算出来。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int prime(int x)
{
	int i;
	if(x<2)
		return 0;//小于2的肯定不是质数
    else
	{
		for(i=2;i<=sqrt(x);i++)//从2开始到sqrt(x)枚举，注意，这里是<=，等号要包含进去
			if(x%i==0)
				return 0;//如果可以整除，那么一定不是质数
        return 1;
    }
}//质数判别函数
int main()
{
	int n,i,j,k;
    int count[100000]={0};
    scanf("%d",&n);
    for(i=2;i<=n;i++)
    {
		j=i;//找个替代品
        for(k=1;k<=i;k++)
			while((j%k==0) && (prime(k)==1) && j>1)//如果k是j的因子，并且k还是质数，也就是k是j的质因子，而且j>1
			{
            	count[k]++;//计数++
                j=j/k;//不停地除
            }
    }
    for(i=0;i<=n;i++)
		if(count[i]!=0)//如果有这个质因子
			printf("%d %d\n",i,count[i]);//输出
	system("pause");
	return 0;
}

```

---

## 作者：irisalt (赞：11)

这道题数据范围给的很小以至于暴力就可以A掉啦

但是因为自己手推出了公式所以当然要秀一手【划掉
------------
首先对于一个数n，分解n!可以看作将1~n之间所有数分解质因数。
#### 很好理解的是，n！的质因数必定是1~n中所有的质因数
### 接下来是每个质因数的个数：cnt[Pi]= n/Pi + n/Pi^2 +…+ n/Pi^k (Pi^k<=n)
这个地方比较有意思，拿样例来说，n！中有多少个2呢？像装桶一样，2、4、6、8、10各有一个2（10/2个2），此时就当做是已经从桶中各取出一个2了；可是没完！4和8（和某想着递推的大佬脑袋）里面还有好多好多2呢，那此时桶中有2的编号，就已经是4的倍数了，那么就是（10/4=10/2^2），继续下去直到2^k <=n(这里就是2^3)
#### 到此为止，基本就可以解决问题了。其中还有一个素数判断我就直接简单筛了，【毕竟线性筛是强者的的世界嘛
下面就放代码啦（如果写的不好请尽情吐槽hack）
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[10005],ans[10005];
bool a[10005];
int main()
{
	int m,i,j,n,cnt=0,k;
	cin>>n;
	a[1]=true;
	for(i=2;i<=n;++i)
	{
		if(a[i]) continue;
			ans[++cnt]=i;
			k=i;
			while(k<=n)
			{
				p[cnt]+=n/k;
				k*=i;
			}
		for(j=i*i;j<=n;j+=i)
		{
			a[j]=true;
		}
	}
	for(i=1;i<=cnt;++i)
	{
		cout<<ans[i]<<" "<<p[i]<<endl;
	}
	return 0;
 } 
```


---

## 作者：JeffWang2019 (赞：7)

### 又是一道质因数题（非常常见）

其实就是编数论函数

不多说了直接将入门题代码亮出来
```cpp
#include <bits/stdc++.h>//万能头文件   偷懒用
using namespace std;//这个最好无论如何都加上
int n,a[10001];//全局变量，为了在函数里能用
void divi(int x)//分解质因数
{
    for (int i=2;i<=x;i++)//小于x就全部枚举
    {
        int t=i;//保存在临时变量中
        for (int j=2;j<=i;j++)//内循环枚举
        {
            while (t%j==0)//如果能整除
            {
                a[j]++;//标注不再为0
                t/=j;//除以j
            } 
        }
    }
}
void out()//输出
{
    for (int i=1;i<=n;i++) // 只要找小于n的就行了
    {
        if (a[i]!=0)//如果前面出现过了
        {
            printf("%d %d\n",i,a[i]);//先输出底数，再输出指数，注意千万不要忘了换行
        }
    }
}
int main()//主函数
{
    memset(a,0,sizeof(a));//初始化a数组
    scanf("%d",&n);//输入
    divi(n);//将n分解质因数
    out();//输出
    return 0;//结束整个程序
}
```

各位，有不懂的，可以在评论区说哦~~

---

## 作者：ez_lcw (赞：6)

# **正解：~~高精度~~线性筛**

看到高精度是不是吓坏了，其实正解肯定不是这样：

因为$n!=1\times2\times3......\times n$，所以我们只用枚举$1$~$n$，把它们各自的质因数求出来，记录一下，最后加上就可以啦。

分解质因数的过程，我们可以把所有小于$n$的质数$prime[]$先求出来，再枚举每一个质数，如果能整除当前要分解的数$k$，那么就将$k$除以这个质数，然后把这个质数加入到$k$的质因数内。

而具体的求素数，我们可以用欧拉线性筛法~~（貌似有点超纲了）~~，不会的可以看一下我的[博客](https://www.luogu.org/blog/lc-2018-Canton/ou-la-xian-xing-shai-fa-qiu-su-shuo-yang-xie-ji-mu-ban-leetcode-count-post)，然后左转去[P3383](https://www.luogu.org/problemnew/show/P3383)先做一下。

具体代码如下：

```cpp
#include<cstdio>
#include<cstring>

int n,ans[2001],prime[2001],cnt;
bool notprime[10001];

void LCP()//线性筛模板
{
	for(int i=2;i<=n;i++)//枚举1~n
	{
		if(!notprime[i])prime[++cnt]=i;
		for(int j=1;j<=cnt&&prime[j]*i<=n;j++)
		{
			notprime[prime[j]*i]=true;
			if(!(i%prime[j]))break;
		}
	}
}

int main()
{
	scanf("%d",&n);
	LCP();//先筛一遍
	for(int i=1;i<=n;i++)//枚举1~n的每一个数
	{
		int k=i;//记得附值给另一个数，不然会改变i的大小
		for(int j=1;k!=1&&j<=cnt;j++)//枚举每个质因数
		{
			while(!(k%prime[j]))//如果可以整除，就证明有这个质因数，因为可能不止有1个这种质因数，所以要用while
			{
				k/=prime[j];//记得除
				ans[j]++;//记录
			}
		}
	}
	for(int i=1;i<=cnt;i++)//枚举每一个质因数
	{
		if(ans[i])//如果有这种质因数的分解的话（其实一定有）
		{
			printf("%d %d\n",prime[i],ans[i]);//记住的一个数不是i，那只是标号，应该是prime[i]
		}
	}
	return 0;
}
```

---

## 作者：fzj2007 (赞：5)

本蒟蒻又来了~

看到这道题，~~第一感暴力~~，但是看到阶乘和n<=10000,想到，必须分步。

下面，说一下思想

1、我们从2开始（1不用搜索），一直到n，分解每一个数
2、分解出的数是质因数，所以，加一个简单的质数判断（上代码）
```
bool isp(int x){
//小于2，肯定不是
	if(x<2) return false;
    //搜索i*i<=x就可以啦，i*i可以节省时间，但是别忘了是≤
	for(int i=2;i*i<=x;i++)
    //这个。。什么都不想说了
		if(x%i==0) return false;
	return true;
}
```
3、查找每个数，所有的数分解出来的存在p数组里（代码~~）
```
//这里是核心代码，大家注意看【敲黑板】
void solve(int x){
//逐个搜索是否可以除尽并且是质数，可以除尽就查找x/i,类似于搜索
	for(int i=2;i<=x;i++){
		if(x%i==0&&isp(i)){
        //存入这个数组
			p[i]++;
            //走索x/i
			solve(x/i);
            //别忘记break
			break;
		} 
	}
	return;
}
```

最后，上代码~~【逃】~~
```
//头文件省略了哈
using namespace std;
int p[10001];//定义数组
int n;//不解释了
//质数判断
bool isp(int x){
//小于2，肯定不是
	if(x<2) return false;
    //搜索i*i<=x就可以啦，i*i可以节省时间，但是别忘了是≤
	for(int i=2;i*i<=x;i++)
    //这个。。什么都不想说了
		if(x%i==0) return false;
	return true;
}
solve函数不说了
void solve(int x){
	for(int i=2;i<=x;i++){
		if(x%i==0&&isp(i)){
			p[i]++;
			solve(x/i);
			break;
		} 
	}
	return;
}
int main(){
//正常读入。。。
	scanf("%d",&n);
    //疯狂寻找
	for(int i=2;i<=n;i++)
		solve(i);
        //暴力输出
	for(int i=1;i<=n;i++) if(p[i]) printf("%d %d\n",i,p[i]);
	return 0;
}华丽结束

```
看到这里的，点个赞，打题解很累的~~

AC链接[用时 43ms 内存 796.00KB 真够慢。。大佬勿喷](https://www.luogu.org/record/23173770)


---

## 作者：fletmer (赞：5)

#质因子分解方法：，有一个数num，从最小质数2开始枚举，若2|num（2整除num）则继续判断2|（num/2），若仍能整除则继续判断，若不能整除则用第二小质数3判断，递推判断直到num被分解到1。然而这题进行一个数的阶乘的质因数分解，若以原方法做必然爆精度，所以我们能将该数的结果表示成1\*2\*3\*.....\*n，然后逐个分解每一个数记录质因子即可
    
```cpp
#include <cstring>
#include <string>
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
int re[10001];//记录某一个质因子的个数
int ss[10001];
int n;
void db(){//打表判断质数，用数组下标代替该数
    ss[1]=0; ss[2]=1;//1不是质数，2是质数
    for(int i=2;i<=10000;i++){
        if(ss[i]){
            for(int j=2;j<=10000/i;j++){
                ss[i*j]=0;
            }
        }
    }
}
void divide(int k){//分解质因数函数
    int t=k;//防止运行混乱加一个数引用要分解的数
    if(ss[k]){//如果该数本身即为质数则不需多加判断
        re[k]++;
        return ;
    }
    for(int i=2;i<=t;i++){//如果该数为一个合数
        if(ss[i]){
            if(k%i==0){//如果该数为质因子
                re[i]++;//这个质因子个数+1
                k/=i;//原数除以质因子
                if(k==1) return ;//如果分解完毕则退出函数
                i--;//模拟上述方法
            }
        }
    }
    return;
}
int main(){
    memset(ss,1,sizeof(ss));//初始化，注意初始化一定要看好是1还是0（吃过大亏）
    memset(re,0,sizeof(re));
    cin>>n;
    db();
    for(int i=2;i<=n;i++) divide(i);//分解每一位
    for(int i=1;i<=n;i++){
        if(re[i]){//如果分解过程中出现了该质因子
            cout<<i<<" "<<re[i]<<endl;//输出该质因子与该质因子的个数
        }
    }
    return 0;
}
```

---

## 作者：critnos (赞：2)

正解是 $O(n)$ 的。

如何快速求出 $n!$ 内有多少个质因数 $p$？

一个 $\log n$ 的算法：$ans=\lfloor\dfrac n p\rfloor+\lfloor\dfrac n {p^2}\rfloor+\lfloor\dfrac n {p^3}\rfloor\dots$

```
s=0;
for(j=n/p;j;j/=p)
	s+=j;
```
欧拉筛出 $n$ 以内的素数是 $O(n)$ 的。

对每个素数都求一下，这道题就做完了。

根据素数个数公式，当 $n$ 趋向于 $\inf$ 时 $\pi(n)$（$n$ 以内的素数个数）等于 $\dfrac n {\log n}$，每个素数计算的复杂度为 $\log n$，所以 $\dfrac n {\log n} \times \log n=n$，故而时间复杂度为 $O(n)$，证毕。

---

## 作者：ViXbob (赞：2)

[打个广告](http://www.vixbob-lwc.pw/)

首先这道题是不用线性筛素数的，可以直接从1跑到sqrt(x),然后进行判断就行了，然后有个小细节就是把从1到n的素数存下了，然后直接取就行了这个是跑的很快的，详细的见代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n,is[10000],num[10000],sum[10000],cnt,res=1;
bool judge(int x){
    if(x<=1)return false;
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0)return false;
    return true;
}//判断素数的函数
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        if(judge(i))is[i]=1,sum[++cnt]=i;//将素数存下来
    for(int i=1;i<=n;i++){
        res*=i;//把上一次没有除干净的乘上
        for(int j=1;j<=cnt&&res>=sum[j];j++)//开始跑，并且如果现在这个个数比你要除的素数小直接退出就行了
            if(res%sum[j]==0){
                while(res>=sum[j]&&res%sum[j]==0){
                    num[sum[j]]++;res/=sum[j];//这个while循环是因为有可能一个数可以被一个素数除多遍
                }
            }
    }
    for(int i=1;i<=cnt;i++)
        if(num[sum[i]])printf("%d %d\n",sum[i],num[sum[i]]);//输出就好了
    return 0;
}
```
OVER

---

## 作者：du33169 (赞：2)

论数论的重要性= =。

**其实这道题完全不需要开数组**

数论结论：若n!=(p1^r1)\*(p2^r2)\*(p3^r3)...(pn^rn)，则r[pi]=[n/pi]+[n/(pi2)]+...+[n/(pi^k)]...+(直到后面都是零）

说明：[x]表示不大于x的最大整数（在此题中可用int强制转换）

好了，上代码：

```cpp
#inclu/de<iostream>
#include<cstdio>
#includ/e<cstring>
#in/clude<cmath>
using namespace s/td;
int n;
int r(int p)
{
    int sum=0;
    for(int /i=p;i<=n;i*=p)
    {
        sum+=(int)n/i;//此处(int)也可以省略
    }
    return sum;
}
bool isPrime(int num)//朴素的判断素数
{
    for(int i=2;i<=sqrt(num);++i)
    {/
        if(num%i==0/)return false;
    }
    return true;
}
int main()
{
    scanf("%d",&n);
    for(int i=2;i<=n;++i)
    {
        if(isPrim/e(i))
        {
            printf("%d %dd\n",i,r(i));
        }
    }
    return 0;
}
```

---

## 作者：Heartlessly (赞：2)

# 看见楼下的题解都比较复杂，为大家奉上一个简单易懂的题解

- ## 先说说具体思路

- **题目看似是高精，其实不然，解题步骤如下：**

- 1.用筛法找出 N 以内的所有素数，因为所有的质因子都是素数；

- 2.用三重循环枚举 2 ~ N 所有数，逐个判断计数；

- 3.输出每个质因子以及它们的数量。

# 代码及解释如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n , prime[10001] , c = 1 , t[10001] , x;// n 表示输入的数，prime 数组用来存 N 以内的所有素数，c 用来计 prime 数组边界值，t 数组用来计每个质因子的数量，x 为临时变量。
bool f[10001];//用布尔型数组筛选素数。
int main()
{
    scanf ( "%d", &n );//输入 n 。
    for ( int i = 2 ; i <= n ; i++ )//阶乘中 1 可以不用考虑。
    {
        x = i;// x 用来存 i 的值。
        if ( ! f[i] )
        {
            for ( int j = i * 2 ; j <= n ; j += i )
            f[j] = true;
            prime[c++] = i;
        }//筛法求素数。主要原则：默认所有数为 0 (false) ，如果碰到一个数是 0 ，就把它 N 以内的所有倍数标记成 1 ，并将这个数存进 prime 数组。
        for ( int j = 1 ; j < c ; j++ )//枚举 N 以内的所有素数，注意是 j < c 。
        {
            while ( x % prime[j] == 0 )//当 x 可以整除某个质因子时，
            {
                t[j]++;//该质因子的数量增加 1 。
                x /= prime[j];// x 变为整除该质因子后的数。如果还能整除该质因子，则继续；不能就退出。这就是 while 循环相比 for 循环的优点。
            }
        }
    }
    for ( int i = 1 ; i < c ; i++ )
    cout << prime[i] << " " << t[i] << endl;//输出每个质因子以及它们的数量。
    return 0;
//其实还可以优化，后一半质因子的数量肯定为 1 ，但是由于 n 范围较小和数据较水，完全不用考虑，毕竟这只是道入门难度的题。
}
```
# 码字不易，希望此题解对大家有帮助！


---

## 作者：Atlicd (赞：1)

###first：  
要理解什么是阶乘  
n！ = 1到 n 这 n 个数的乘积  
###讲一下  
这个题就是一个分解质因数，  
因为分解为的数一定不能有因数，所以一定是质数  

###解决方案：  
~~先打个表~~，没错，就是打一个 10000 以内的质数表  
打表程序如下：  
```
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std ;

inline bool judge(int x)
{
	if(x == 2 || x == 3)
		return 1 ;
	if(x % 2 == 0 || x % 3 == 0)
		return 0;
	
	for(int i = 5 ; i * i <= x ; i += 6)
		if(x % i == 0 || x % (i + 2) == 0)
			return 0;
	return 1 ;
}
int ans ;
int main()
{
	freopen("out.txt" , "w" , stdout);
	int n = 10000 ;
	for(int i = 2 ; i <= n ; ++ i)
	{
		if(judge(i))
		//判断质数 
		printf("%d,",i), ++ans ;
	}
	printf("\n%d",ans);
	//判断一共有多少个质数，确定数组开多大 
}
```
因为不会用线性筛，就用了一个个判断的方式打表  
最后得出  
``` ans = 1229 ; ```   
所以我们只需要每个阶乘的数字跑一下分解质因数就行   
###那么问题来了，怎么分解？？？  
我们开始~~日常~~操作  
###主体函数：  
将一个数分解为质数的形式：
#####code
```
inline void fen(int x)
{
	//我存质数从a[1]开始存的所以循环从1开始
	for(int i = 1 ; i <= 1230 ; ++ i)
	{
		while(x % zh[i] == 0)
        //直到这个因数不能再除为止
		{
			num[i] ++ ;
            		//记录一下出现了几次
			x /= zh[i] ;
            		//不要忘记除一下，否则卡循环了
		}
		if(x == 1)
        	//判断临界条件，剪枝吧...
			return ;
	}
}
```
核心代码就是如此，下面附上AC代码：   
```
#include <algorithm>
#include <iostream>
#include <cstdio>

using namespace std ;

int zh[1500] ={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973};
//质数表 
int n ;
int num[1500] ;

inline void fen(int x)
//和上面一样 
{
	for(int i = 1 ; i <= 1230 ; ++ i)
	{
		while(x % zh[i] == 0)
		{
			num[i] ++ ;
			x /= zh[i] ;
		}
		if(x == 1)
			return ;
	}
}

int main()
{
	scanf("%d" , &n);
	for(int i = 2 ; i <= n ; ++ i) fen(i);
	//阶乘每个都跑一边 
	for(int i = 1 ; i <= 1230 ; ++ i)
		if(num[i])
		//如果没有这个因子就不用输出了 
			printf("%d %d\n" , zh[i] , num[i]) ;
	return 0 ;
}
```
~~遛~~

---

## 作者：_无v名_ (赞：1)

首先，依题意得，n<=1000（好像是1000还是10000来着，都差不多吧），直接求阶乘明显会炸，所以我们需要根据阶乘的性质，以及质因数分解的目的，得出，可以一个个求其质因数。

代码如下

```cpp
#include<iostream>
#include<cstdlib>
using namespace std;
int n,i;
int a[10001];
void doo(int x)
{
    int k=x;
    for(int i=2;i<=x;i++)
    if(k==1) break;
    else
    while(k%i==0) {a[i]++;k/=i;}
}
int main()
{
    cin>>n;
    for(i=2;i<=n;i++) doo(i);
    for(i=2;i<=10001;i++) if(a[i]) cout<<i<<" "<<a[i]<<endl;
}
好的这么看来应该是n<=10000，但是这不是重点，重点在于，有一个小小的优化（其实算不上优化，只是一个补丁而已……），就是if(k==1) break;可以节省大量的时间，各位oier需要学习一下哦，竞赛场上这是有大用处的（提高组的就别学了，待会我被你们比下去了……虽然好像你们应该早就会了……）。
```

---

## 作者：KesdiaelKen (赞：1)

大家用的都是神方法啊……o(╥﹏╥)o

本人只会用暴力直接枚举，开的数组都超大，有点类似桶排的思路……

本人的方法：枚举从1-n的所有数，将每一个数都暴力质因数分解，再开一个数组暴力存储在质因数分解时出现过的所有质数，最后在遍历一遍输出所有遍历过的数（即为出现过的质数）就行了。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int appear[100000]={0};//存储所有在质因数分解时出现的质因子分别个数
    int n;//输入
    int store;
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
            store=i;//分解质因数时所需要的复制变量
            for(int j=2;store!=1;j++)//store==1时，既无法继续分解
            if(store%j==0)while(store%j==0)appear[j]++,store/=j;//枚举此质因子的个数，用appear记录总共出现的次数
```
}//不可能出现非质数因子被枚举到的情况，因为它已经被小于它的质数因子分解掉了
```cpp
    for(int i=1;i<=n;i++)
    {
        if(appear[i])printf("%d %d\n",i,appear[i]);//查找，输出（若appear值为0，则在质因数分解的过程中未出现该数）
    }
    return 0;
}
```

---

## 作者：Running_Coder (赞：1)

对N！进行质因子分解，因为计算的都是乘法，所以只要把1~N每个数的质因子分解后累加就可以了。

先筛一下素数，保存备用（直接打表也未尝不可）；

然后对i=1~N进行分解并累加结果。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<string>
#include<ctime>
#include<cstdlib>
#include<algorithm>
using namespace std;
bool pd[10001];
int prime[5001];
int js=0;
int sl[5001]={0};
int temp,p;
int i,j,n;
int main(){
    scanf("%d",&n);
    memset(pd,1,sizeof(pd));
    for(i=2;i<=n;i++)
        if(pd[i]){
            for(j=i*2;j<=n;j+=i)pd[j]=0;
            js++;
            prime[js]=i;
        }
    for(i=2;i<=n;i++){
        temp=i;
        p=1;
        while(temp>1){
            while(temp%prime[p]==0){
                temp/=prime[p];
                sl[p]++;
            }
            p++;
        }
    }
    for(i=1;i<=js;i++)
        if(sl[i]!=0)printf("%d %d\n",prime[i],sl[i]);
    return 0;
}
```

---

## 作者：tmp27 (赞：0)

学过数学的一般都知道质因子分解是什么意思，我就不多说了   
这道题的数据范围是$10000$，如果直接去计算$n!$就会爆炸。   
因此我们只能选择逐个分解。         
首先，先得开两个个数组用来存质数和个数（我就直接定义一个$struct$了）。                           
再用一个函数来选出$1$~$n$中的质数。        
然后就可以为所欲为的拆分了。                   
接着我们来看一下代码：          
上代码！
```
#include<iostream>//头文集
using namespace std;//空间命名
int n;//定义$n$符合题意
struct js{
	int su;//这是数
	int gs;//这是个数
}zss[10005];//开数组，定义一个struct
int p,t=1;//p是zss数组的长度。t是分解时的零时变量
bool check(int x)
{
	if(x<2) return false;//0~1都不是质数
	for(int i=2;i*i<=x;i++)
	{
		if(x%i==0) return false;//是合数
	}
	return true;//是质数
}//判断是否是质数
void cz()
{
	for(int i=1;i<=n;i++)
		if(check(i)==true) zss[++p].su=i;//选出1~n中的质数。
}
void print()
{
	for(int i=1;i<=p;i++)
	{
		if(zss[i].gs>0) cout<<zss[i].su<<" "<<zss[i].gs<<endl;//如果有这个质因数就输出
	}
}//输出。
int main()
{
	cin>>n;
	cz();//调用	
	for(int i=2;i<=n;i++)
	{
		int y=i;//来个好心人来存一下
		t=1;//位置
		while(y>1)//当还没分完是继续分。
		{
			if(y%zss[t].su==0)//哇！可以分解
			{
				zss[t].gs++;//个数自增
				y=y/zss[t].su;//那就分呗！
			}
			else t++;//下一个
		}
	}
	print();//调用。
	return 0;
}
```
看了代码是不是感觉很简单？                     
求通过！

---

## 作者：SS003 (赞：0)

其实这道题用模拟就能过

------------

1. 创建范围内的质数表:
```cpp
#include<cstdio>
long long zsi,zsii,ms=0,k=0;
void zs(){
 for(zsi=2;zsi<=10000;zsi++){
  for(zsii=2;zsii<=zsi-1;zsii++){
   if(zsi%zsii==0){ms=1;break;}
  }
  if(ms==0){s[k]=zsi;k++;}else{ms=0;}//判断是否质数
 }
}//生成质数
int main(){
 zs();
return 0;
}
```
2. 输入 n 并模拟阶乘,1×2×3×...×n

阶乘时乘的数都是n!的因数

所以把阶乘时乘的数÷质数表中的质数,就得到质因子的数量

------------

代码如下:
```cpp
#include<cstdio>
using namespace std;
 long long ss[10001],s[1231]/*存放质数表*/;
 long long n,i,ii,si;
 long long zsi,zsii,ms=0,k=0;
void zs(){
 for(zsi=2;zsi<=10000;zsi++){
 for(zsii=2;zsii<=zsi-1;zsii++){
  if(zsi%zsii==0){ms=1;break;}
 }if(ms==0){s[k]=zsi;k++;}else{ms=0;}}
}//生成质数
int main(){
 zs();
 scanf("%lld",&n);
 for(i=2;i<=n;i++){si=i;/*模拟阶乘*/
  for(ii=0;ii<=1228;ii++){
   while(si%s[ii]==0){if(si%s[ii]==0){si=si/s[ii];ss[s[ii]]++;}}
  }/*质因子数量*/
 }
 for(i=0;i<=1228;i++){
  if(ss[s[i]]>0){printf("%lld %lld\n",s[i],ss[s[i]]);}//输出质因子
 }//输出
return 0;
}
```

希望这篇题解能帮助到你.

---

## 作者：gxjj (赞：0)

各位大佬都好厉害，作为小菜鸡的我看了看大佬的神解后嘤嘤嘤。小弱鸡说一下自己的思路，~~大佬勿喷~~   
1、先用筛选法求出10000以内的素数

2、来一个for循环，i从2到n;在for循环外设置一个变量t=1，让t=t*i

3、对t进行质因数分解.

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn=130100;
int num[maxn];
int prim[maxn];
int x[maxn];
int cnt;
void init()
{
    for(int i=2; i<maxn; i++)
    {
        if(num[i] == 0)
        {
            for(int j=i*2; j<maxn; j+=i)
            {
                num[j] = 1;
            }
        }
    }

    for(int i=2; i<maxn; i++)
    {
        if(num[i] == 0)
        {
            prim[cnt++]=i;
        }
    }
}

int main()
{
    init();
    int n,i,t=1;
    cin>>n;
    for(i=2; i<=n; i++)
    {
        t*=i;
        for(int j=0; j<cnt; j++)
        {
            if(prim[j]>t)
                break;
            while(t%prim[j] == 0)
            {
                x[prim[j]]++;
                t=t/prim[j];
            }
        }
    }
    for(i=2; i<cnt; i++)
    {
        if(x[i]!=0)
            cout<<i<<" "<<x[i]<<endl;
    }
    return 0;
}

```


---

## 作者：CYSCYS (赞：0)

这里用到了分解质因数的一个巧妙方法：

```cpp
for (a=2;x>1;a++)
    if (x%a)
    {
        x/=a;
        a--;
    }
```
这时的a必定为x的质因数。

代码：



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int sum[10001];
void fenjie(int x);
bool pz(int x);
int main()
{
    int a,b,c,d,e;
    int l,m,n,s,q;
    cin>>n;
    for (a=2;a<=n;a++)
        if (!pz(a)) fenjie(a);
        else sum[a]++;
    for (a=2;a<=n;a++)
        if (sum[a])
            cout<<a<<' '<<sum[a]<<endl;
    return 0;
}
bool pz(int x)
{
    int a,b=sqrt(x)+1;
    for (a=2;a<=b;a++)
        if (x%a==0) return 0;
    return 1;
}
void fenjie(int x)
{
    int a;
    for (a=2;;a++)
    {
        if (x%a==0)
        {
            sum[a]++;
            x/=a;
            a--;
        }
        if (x<=1) break;
    }
}
```

---

## 作者：飞奔的蜗牛 (赞：0)

C++程序闪亮登场！！！

当当当！！！

好吧，这道题虽说是入门难度，我认为可能还是有普及-的

因为如果用普通判质数的话最后一个点会超时

# 所以这题我用的是质数的线性筛法

具体代码如下

其实是C党的肯定都看得懂，所以我下面也不加注释了

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;     //呵呵，习惯没事干开这么多库
int a[20010],s;     //a和s在这道题中起辅助作用，其中a既参与了筛法，也参与了最后的输出
int ans[20010]={1,1};     //ans在这道题中是判断数i或j是不是质数的一个数组，如果是，ans[i]=0，否则=1
int n;     //呵呵，n就不用说了吧，n就是输入的那个数
int main()
{
    for (int i=2;i<20005;i++) {     //素数线性筛法
        if (!ans[i])     //如果这个数是质数
            a[s++]=i;
        for (int j=0;j<s && i*a[j]<20005;j++) {     //将这个数之后的所有的是该数的倍数的数全都标记为合数，因为这个合数有这个数做因子
            ans[i*a[j]]=1;     //标记为合数
            if (!(i%a[j])) break;     //这个是一个非常重要的句子，它将普通晒法的时间复杂度降低了很多，具体降低了多少，我也不太记得了，但是普通晒法合快速筛法的唯一区别就是这一句话。这句话是说，如果a[j]是i的因数，那就退出循环，不再标记
        } 
    } 
    cin>>n;     //输入n
    for (int i=1;i<=n;i++)
        a[i]=0;     //将a[i]清零，因为之前已经用过a[i]来扶衬ans，现在还需要一个数组，就懒得再开一个，于是把它清零继续凑合着用。现在的a是用来统计有几个质数j的因子
    for (int i=2;i<=n;i++)     //i从2到n循环，因为1什么都不会输出（1是打酱油的）所以就跳过1，从2开始循环到n
        for (int j=2;j<=i;j++) {     //做i的阶乘，同样，1也是打酱油的
            int s=i;     //找个替身代替i
            if (!ans[j] && s%j==0)     //如果j是质数而且j是i的倍数
                while (1) {     //循环，每次把a[j]+1，并且令s除以j，一直到除不了为止
                    a[j]++; s/=j;
                    if (s%j!=0) break;
                }
        }
    for (int i=2;i<=n;i++)     //输出
        if (!ans[i] && a[i]!=0) cout<<i<<" "<<a[i]<<endl; 
    return 0;
}
```

---

## 作者：hanker_AFO (赞：0)

自己写的代码。因为比较容易，所以写的比较标准一点。

为还在用Pascal的选手加油！！！

  



```cpp
var
  n,ans:longint;
function prime(x:longint):boolean;//判断质数（常规方法，无话可说。）
var
  i:longint;
begin
  if(x=2)then exit(true);
  if(x mod 2=0)then exit(false);
  for i:=2 to trunc(sqrt(x)) do
    if(x mod i=0) then exit(false);
  exit(true);
end;
procedure js(x:longint); //利用了公式。例：8！中因子2的个数=8/2+（8/2）/2+((8/2)/2)/2......直到结果为0为止。
var
  a:longint;
begin
  a:=n;
  while(a<>0)do
  begin
    a:=a div x;
    ans:=ans+a;
  end;
end;
var
  i,j:longint;
begin
  j:=0;
  readln(n);
  for i:=2 to n do
    if(prime(i)) then begin ans:=0; js(i); writeln(i,' ',ans); inc(j) end;//先判断质数，后用公式求解，ans用来统计个数。
end.//一定不要忘记打end.！！！
以上为本人十五分钟的心血，各位大佬们，献丑啦！！
```

---

## 作者：Cagulo (赞：0)

###简单易懂的代码

//用的是数论中的：唯一分解定理——一个数一定可以分解成 ：N=P1a1P2a2P3a3......Pnan，这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=10000+500;
int n,f[maxn];
int sum[maxn];
int fenjie(int x)
{
    int k=2;
    while(k*k<=x)
    {
        while(x%k==0)//如果能被整除的话就除，这样可以避免4、6、8等重判 
        {
            sum[k]++;//记录当前因子的个数 
            x=x/k;
        }
        k++;
    }
    if(x>1) sum[x]++;//如果x>1说明当前的数不能整除完，那么一定是个质数，记录下来 
}
int  main()
{
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        f[i]=i;
        fenjie(i);
    }
    for(int i=2;i<=n;i++)//枚举到N，因为有可能N是一个质数； 
    {
        if(sum[i]!=0)
        {
            printf("%d %d\n",i,sum[i]);
        }
    }
    return 0;
}
```

---

## 作者：子谦。 (赞：0)

###将阶乘的质因数的数目转化为每个因子质因数的数目

直接上代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
const int maxn=10001;//既然题目说n最大10000，那就卡着边来（这不是个好习惯）
int n,a[maxn],zhi[maxn],b,z=1,pp[maxn];//zhi数组存的是n以内的质数，b表示质数的数目，z表示质因数的数目，pp存的是出现的质因数，a数组是每个质因数的出现次数
bool c[maxn];//表示这个数是不是一个质数，接下来会用到
int main()
{
    c[2]=1;//2,3,5,7都是质数
    c[3]=1;
    c[5]=1;
    c[7]=1;
    zhi[1]=2;//存上
    zhi[2]=3;
    zhi[3]=5;
    zhi[4]=7;
    b=5;//接下来如果存就是第5个了
    cin>>n;//输入n
    for(int i=11;i<=n;i+=2){//从11开始，质数筛
        int z=sqrt(i);
        bool p=1;
        for(int j=2;j<=z;j++)
            if(i%j==0){
                p=0;
                break;
            }
        if(p){
            zhi[b++]=i;
            c[i]=1;
        }
    }
    b--;//此时b比真实个数多1
    for(int i=2;i<=n;i++){//1没有质因数，所以从2开始，一直到n
        if(!c[i])//如果他不是质数
            for(int j=1;j<=b;j++){
                if(zhi[j]>i)break;
                if(i%zhi[j]==0){
                    int zz=i;
                    while(zz!=1){
                        a[zhi[j]]++;
                        if(a[zhi[j]]==1)
                            pp[z++]=zhi[j];
                        zz/=zhi[j];
                        if(zz%zhi[j]!=0)break;
                    }
                    
                }
            }
        else{//如果是一个质数，那么直接它本身出现次数加1
            a[i]++;
            if(a[i]==1)
                pp[z++]=i;
        }
    }
    for(int i=1;i<z;i++){//此时z多1，和b的情况是一样的
        cout<<pp[i]<<' '<<a[pp[i]]<<endl;
    }
    return 0;
}
```
#感谢观看，请勿复制


---

## 作者：按Ctrl加w会AC (赞：0)

这题我的方法是——先用筛法挖素数，然后计算出n!有多少个质因子pi

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define maxn 10005
#define maxp 1235
using namespace std;
int n,p[maxp];
//p数组用来存素数
bool vis[maxn];
//vis用来判断是否素数，是的话为1，否则为0
void make_p(){
    memset(vis,1,sizeof vis);
    vis[0]=vis[1]=0;
    for (int i=1;i<=sqrt(n);i++) if (vis[i])
    for (int j=i*i;j<=n;j+=i) vis[j]=0;
    for (int i=1;i<=n;i++) if (vis[i]) p[++p[0]]=i;
}
//筛法挖素数
int count(int x){
    int s=0,w=n;
    while (w){
        s+=w/x;
        w/=x;
    }
    return s;
}
//这是求n!里有多少个x因子
//n!里的x因子的个数是n/x+n/(x*x)+n/(x*x*x)+n/(x*x*x*x)+n/(x*x*x*...*x)直到n/(x*x*x...*x)=0为止
int main(){
    scanf("%d",&n);
    make_p();
        //挖素数
    for (int i=1;i<=p[0];i++)
        printf("%d %d\n",p[i],count(p[i]));
```
输出结果
    return 0;

}

---

## 作者：ljc20020730 (赞：0)

这道题数据较小，所以一边入一边判。最后见到不是零就打印。

给pas党一点福利，多多写题解，造福社会

```cpp
var n,i,k,t:longint;
     a:array[1..10000]of longint; //a数组统计 
begin
 readln(n);
 for i:=1 to n do begin //入值 
  t:=i; k:=1;
  while t<>1 do begin
   inc(k);
   if t mod k=0 then begin //判断，并打标记，数组里的累加
    t:=t div k;
    inc(a[k]);
    k:=k-1;
   end;
  end;
 end; //分解 
 for i:=1 to 10000 do
  if a[i]<>0 then writeln(i,' ',a[i]);  //输出 
end.
```

---

## 作者：AdzearDisjudge (赞：0)

此题看似高精度，实际上，我们可以把它分解成多个数的质因数。

例如：5！=1\*2\*3\*4\*5，分解质因数为：2^3,3^1,5^1.

实际上，它就是2\*3\*2\*2\*5,4分解为2^2.最后结果和“高精度阶乘再分解”一样。

AC代码：

```cpp
#include<iostream>
using namespace std;
int n,a[10001]={0};
int main()
{
    cin>>n;
    int i,j,k,s;
    for(i=1;i<=n;++i)  //此循环用于分解阶乘每一个数（如5！分解为1,2,3,4,5）
    {
        k=i;
        while(k>1)  //此循环用于分解质因数
        {
            for(j=2;j<=n;++j)  //此循环为对每一个质因数分解，对于非质的因数（如4）已经被分解掉了质因数（如4中的2），不会影响结果
            {
                while(k%j==0)  //判断能否分解
                {
                    k/=j;
                    ++a[j];
                }
            }
        }
    }
    for(s=2;s<=n;++s)  //输出
    if(a[s]!=0)
    cout<<s<<' '<<a[s]<<endl;
    return 0;
}
```

PS:据说此题有递归版本，蒟蒻不会写，求大神指教


---

## 作者：李白666 (赞：0)

\_**本人水平较差，请各位大神多多指教！**\_

\_**这道题数据较小，所以一边入一边判。最后见到不是零就打印。**\_


附AC代码：


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
long long int n,i,k,t,a[10005];    //a数组统计 
int main()
{
    cin>>n;      //入值 
    for(i=1;i<=n;i++)
    {
        t=i;k=1;
        while(t!=1)       
        {
            k++;
            if(t%k==0)      //判断，并打标记，数组里的++ 
            {
                t=t/k;       
                a[k]++;
                k--;
            }        
        }                //分解 
    }
    for(i=1;i<=10005;i++)
    {
        if(a[i]!=0) cout<<i<<' '<<a[i]<<endl;
    }           //输出 
    return 0;
}
```

---

## 作者：自动Wrong机 (赞：0)

不需要高精度算法算n!，即使算出来也会超时（后面不好算）

于是Pacal。。

所以我直接枚举所有从2到n所有数字

开个大数组玩玩

代码：

```cpp
var n,i,i2,j:longint;
      a:array[1..10000] of longint;//开大数组
begin
    fillchar(a,sizeof(a),0);//全部清为0，初始化
    readln(n);//读入n
    for i:=2 to n do //从2开始，1浪费时间（加不加无所谓）
        begin
            j:=2;//1不是质数，那么从2开始吧
            i2:=i;//超级无敌替身
            while true do//俺喜欢死循环
                if i2 mod j=0 then
                    begin
                        inc(a[j]);//加上这个数字
                        i2:=i2 div j;//缩小，要不然也会死循环跳不出来
                    end
                else
                    if j<i2 then
                        inc(j)
                else //直到j比i2大
                    break;//又死循环当然要有跳出
        end;
    for i:=1 to n do
        if a[i]>0 then //过滤0
            writeln(i,' ',a[i]);
end.
```

---

## 作者：zqy1018 (赞：0)

数据量很小所以直接枚举

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
int n,b[10005]={0},factor(int ne);//b数组储存质因数p的个数
int factor(int ne){//质因数分解函数
    int tmp,i,now=ne;
    tmp=(int)floor(sqrt(ne)+0.5);
    for(i=2;i<=tmp;i++)
        if(now%i==0)
            while(now%i==0){b[i]++;now/=i;}
    if(now>1)b[now]++;
        //质因数分解过程
}int main(){
    scanf("%d",&n);int i;for(i=1;i<=n;i++)factor(i);
    for(i=1;i<=10000;i++)if(b[i])printf("%d %d\n",i,b[i]);
    return 0;
}
```

---


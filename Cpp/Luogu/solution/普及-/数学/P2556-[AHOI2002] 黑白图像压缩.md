# [AHOI2002] 黑白图像压缩

## 题目描述

选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。

所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8\*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。

小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。

每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。

例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。

像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。


## 说明/提示

$1\leq n\leq 8\times 10^4$。

## 样例 #1

### 输入

```
8 0```

### 输出

```
8```

## 样例 #2

### 输入

```
24 210 0 255```

### 输出

```
130 1 129 2 129 9 136```

# 题解

## 作者：ICEMAGE (赞：19)

本题直接暴力模拟就好了。

如果当前的颜色和之前的不同，就把之前的值输出，当前的覆盖上去。

如果相同就直接+1

只用注意一下第一次和最后结束时的情况就好了



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dq,add,x,wz[10];
int main()
{
    scanf("%d",&n); dq=2; add=0;  //这里把第一次设为强制更新值 
    for (int i=1;i<=n/8;i++)
    {
        scanf("%d",&x);
        for (int j=8;j>0;j--)     //把每位上的数分解出来 
        {
            wz[j]=x%2;
            x=x/2;
        }
        for (int j=1;j<=8;j++)     
        if (dq!=wz[j])                                              //不同的输出和更新值
        {
            if (dq!=2) printf("%d ",add+128*dq); // 去掉第一次的输出
            dq=wz[j];
            add=1;
        }
         else add++;                                      //相同+1
    }
    printf("%d ",add+128*dq);                      //结束了就直接输出
}
```

---

## 作者：UnyieldingTrilobite (赞：7)

上手鉴定大膜你。

~~方法没什么好说的吧，就是二进制串存下来然后统计连续0和1.~~

STL大法：

一：bitset快速整数转二进制字符串

二：string加法省时省力。

废话少说上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string h;
int main(){
	cin>>n;
	for(int i=1;i<=(n>>3);++i){
		int a;cin>>a;
		bitset<8>s(a);
		h=h+s.to_string();//STL大法好！现在字符串h已经接上a的二进制了。
	}h=h+'#';//哨兵，方便下面判断
	for(int pos=0;pos<h.size()-1;++pos){
	//注意这不是简单的遍历！！！上限额外-1是因为哨兵的存在,++pos见下，是指这串已经都处理完了转下一串
		int num=1;//统计数量
		for(;h[pos]==h[pos+1];++pos)++num;
		//统计（现在发现哨兵的用处了）
		if(h[pos]==49)num|=128;//处理最高位
		printf("%d ",num);//输出
	}
	return 0;
}
```
Over.

应该属于题解里相当短而且比较不容易出错的一篇。

STL真好啊！

---

## 作者：Light_az (赞：5)

# 一道模拟题
说实话，这道题我一开始没有看懂，后来反复看了题目描述才懂了大概意思，首先对于题目给的 $n$ 输入 $n/8$ 个数，对着几个数进行二进制拆分，我们就能得到一个序列，如题目描述所说，再次拆成几个数字相同的片段，输出 $8$ 个数，其中第一位数是该片段中相同的数，剩下 $7$ 位是长度个数的二进制，因为最高位是第 $8$ 位，所以我们将它乘以 $2$ 的 $8$ 次方，再加上长度个数即为答案，注意，可能该序列最后一个片段完全相同，需要特判进行输出，下面是完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
const int N=1e5+10; 
int a[N];
int main(){
	cin>>n;
	for(int i=1;i<=n/8;i++){//输入n/8个数 
		cin>>x;
		for(int j=8;j>=1;j--){//数位拆分 
			a[j+(i-1)*8]=x%2;//j是第i个片段的第j位,需要加上(i-1)*8来拼接序列 
			x/=2;
		} 
	}
	int last=a[1],sum=1;//记录第一位开始，长度为1 
	for(int i=2;i<=n;i++){//从第二位开始 
		if(a[i]==last){//如果相等，长度加1 
			sum++;
		}			
		else{
			cout<<sum+last*128<<" ";//输出长度+最高位*pow(2,8)的结果 
			last=a[i];//改变上一个的值 
			sum=1;//更新长度 
		}
	}
	cout<<sum+last*128<<" ";//最后一个片段特判 
	return 0;
}
```
最后向同志们致敬。

---

## 作者：Ofnoname (赞：4)

题目前一半都是废话，耐心读完可以发现并没有难度。

我们把每一个数读进来，它的范围在$[0, 255]$之间，那么把它的后8位直接从高到低排列即可，就可以得到对应的01序列。

然后从前往后遍历01序列，所有只含0或1的字段长度就是答案，注意答案占7位，不能超过127，如果是1的长度还要在或上`1 << 8`。

```cpp
#include <bits/stdc++.h>
#define MAX (80000 + 7)

int N, ac, now, sum, a[MAX];

int main()
{
	scanf("%d", &N);
	for (int i = 1, x; i <= N>>3; i++)
	{
		scanf("%d", &x);
		for (int p = 7; p >= 0; p--)
			a[++ac] = x >> p & 1;
	}
	
	now = a[1], sum = 1;
	for (int i = 2; i <= N; i++)
	{
		if (a[i] != a[i-1] || sum==127) {
			printf("%d ", now << 7 | sum);
			now = a[i], sum = 1;
		}
		else sum++;
	} printf("%d ", now << 7 | sum);
}

```

---

## 作者：agicy (赞：4)

# 思路

将数据转化为二进制，然后进行操作。

## 将数据转化为二进制

使用$STL$容器`bitset`（头文件为`<bitset>`），通过赋值，它会自动`int`等标准数据类型转化为对应的二进制。

# 代码

代码如下。

```cpp
#include<stdio.h>
#include<bitset>//使用bitset
using std::bitset;

int n,num;
bitset<32> temp;//int为32位有符号整数，所以这里开32位
bitset<80001> Ans;

int main(void){
	register int i,j,sum;
	scanf("%d",&n);
	for(i=0;i<(n>>3);i++){
		scanf("%d",&num);
		temp=num;//赋值，自动转化为对应的二进制
		for(j=0;j<8;j++)
			Ans[j+(i<<3)]=temp[8-j-1];//接上答案
	}
	Ans[n]=!Ans[n-1];//最后一个元素要跟它前面的不一样，保证最后一个元素会被输出
	for(i=sum=0;i<n;i++)
		if(Ans[i]==Ans[i+1])
			++sum;//累计答案
		else
			printf("%d ",sum+1+(Ans[i]?128:0)),sum=0;//输出
	return 0;//结束
}
```

## [我的评测记录](https://www.luogu.org/recordnew/show/9969906)

---

## 作者：快乐一凡 (赞：3)

## 题目：
[黑白图像压缩](https://www.luogu.com.cn/problem/P2556)
## 分析：
采用读一个数，处理一个数的方法，先把十进制数化为二进制数逆序存放在一个数组里，然后再判断相邻的数字是否相同，相同则继续，反之则根据像素来算出其对应的十进制数，如果像素是 $1$ ，则最后在 $finally$ 上加 $128$  ，如果是  $0$ ，则不用。然后把得出的数放在 $OUT$ 数组中，最后打印出 $OUT$ 数组即可。其中定义了一个 $F$ 变量，主要是在判断是 $0$ 像素，还是 $1$ 像素。

总结：
做这个题目时，没能考虑到一个数全为 $0$ ，或者一个数二进制的最后一位为
$1$ ，而下一个数的二进制第一位为 $0$ 的情况。

## 代码：
```cpp
#include<cstdio>
int a[80000],b[80000];
int main()
{
  int n,k=0,lab=1;
  scanf("%d",&n);
    n/=8;
  for (int i=0;i<n;i++) scanf("%d",&a[i]);
  for (int i=0;i<n;i++)
    for (int j=7;j>=0;j--)
    {
      k=i*8+j;
      b[k]=a[i]%2;
      a[i]/=2;
     }
    int i;
  for (i=1;i<n*8;i++)
    if (b[i]!=b[i-1])
    {
      if (b[i-1]==1) printf("%d ",lab+128); else printf("%d ",lab);
      lab=1;
    }
      else lab++;
  if (b[i-1]==1) printf("%d \n",lab+128); else printf("%d \n",lab);
  return 0;
}
```


---

## 作者：_111_ (赞：2)

一道非常无聊的模拟...
### 简要题意
- 首先输入  $  \frac{n}{8} $ 个数（这里默认都是正整数）。
- 把这 $ \frac{n}{8} $ 个数都转为二进制形式，然后依次排列。
- 这时会得到一段 $01$ 序列，把它按同种数字分段。举个例子：假定得到的序列为 $11010010$，按 $0$ 和 $1$ 分段得：$11, 0,1,00,1,0$。
- 将这些数字段转为八位二进制形式，第一位表示它是什么数字，后七位为数字个数的二进制表示。如序列 $11$ 一共有 $2$ 个 $1$，数字为 $1$，而 $2$ 的七位二进制形式为 $0000010$，所以它的八位二进制表示是 $10000010$。
- 最后，输出每个八位二进制的十进制形式就可以了。

## code
```c
#include<bits/stdc++.h>
using namespace std;
int n,cntt=0;
int a[9],b[80005];
int main(){
	scanf("%d",&n);
	n/=8;
	while(n--){
		memset(a,0,sizeof(a));
		int cnt=8,x;
		scanf("%d",&x);//输入这 n/8 个数 
		while(x){
			a[cnt--]=x%2;
			x/=2;
		}//转为二进制形式 
		for(int i=1;i<=8;i++)
			b[++cntt]=a[i];//将这些二进制数依次排列 
	}
	int sum=1,t=b[1];//sum 为数字个数，t 为数字类型 
	for(int i=2;i<=cntt;i++){
		if(b[i]==t) 
			sum++;//按同种数字分段 
		else{
			printf("%d ",sum+t*128);//因为最高位是t，所以直接加上 t*2^7 就好了 
			t=b[i],sum=1;
		}
	}
	printf("%d\n",sum+t*128);//别忘了最后还有一个要输出！！！ 
	return 0;
}
```


---

## 作者：No_Rest (赞：2)

## 题目简述

这道题描述得很绕，无非就是：

- 给定一个数 $n$ 和 $\frac{n}{8}$ 个数 $x_{1...\frac{n}{8}}$。
- 把这 $\frac{n}{8}$ 个数转成2进制，并把他们按数字分段，如 $11011101$ 分成 $11,0,111,0,1$ 几段。
- 然后用一个 $8$ 位的二进制数表示段，其中头位是数字，后面七位是数的数量。还拿上面的举栗子，$11$ 可以表示成 $10000010$，表示数字是1，共有$(10)_2$ 也就是 $2$ 个 $1$，得到 $10000010,000000001,10000011,00000001,10000001$。
- 最后把它转回 $10$ 进制，得到 $130,1,131,1,129$。

## 题目分析

1. 先输入 $n$。
1. 输入 $x$（不开数组，可以省一些空间）。
1. 把 $x$ 分解成二进制数。
1. 遍历这个二进制数，每次都判断这个位置跟上一个是不是一模一样
>1. 如果一样，就是一段的，那么长度加 $1$。
>1. 如果不一样，就输出，然后初始化一下长度。

### 坑点：

1. 最开始的数不能是 $0$ 或 $1$，要进行特判。
1. 最后还要再输出一次，否则最后一段输出不了（想想看）。

## 代码

>### 注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, now = 114514, len, a[10];//now一定要赋不为0或1的初始值
int main(){
    scanf("%d", &n);
    for(int i = 0; i < n / 8; i++){
        scanf("%d", &x);
        for(int j = 8; j > 0; j--){//转换成2进制
            a[j] = x % 2;
            x /= 2;
        }
        for(int j = 1; j <= 8; j++){//遍历二进制数
            if(a[j] == now){//如果跟上一个数一样
                len++;//长度加一
            } else {//不一样
                if(now != 114514){//不是最开始的
                    printf("%d ", now * 128 + len);//输出
                }
                now = a[j];//更新now
                len = 1;//长度初始化为1
            }
        }
    }
    printf("%d ", now * 128 + len);//最终输出
    return 0;//好习惯
}
```

>### 无注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, now = 114514, len, a[10];
int main(){
    scanf("%d", &n);
    for(int i = 0; i < n / 8; i++){
        scanf("%d", &x);
        for(int j = 8; j > 0; j--){
            a[j] = x % 2;
            x /= 2;
        }
        for(int j = 1; j <= 8; j++){
            if(a[j] == now){
                len++;
            } else {
                if(now != 114514){
                    printf("%d ", now * 128 + len);
                }
                now = a[j];
                len = 1;
            }
        }
    }
    printf("%d ", now * 128 + len);
    return 0;
}
```

---

## 作者：____233____ (赞：2)

~~本题是一道可以暴力模拟的题（废话）~~

对于这道题，我运用了字符串的方法

首先，读入数据，并将数据转化为二进制，存储在字符串里

**注意：转化为二进制数时，若位数不足8位，需在前方添加前导0**

然后，在字符串里进行操作（方法类似[P1320 压缩技术（续集版）](https://www.luogu.org/problemnew/show/P1320)）

如果读入颜色为白色，在输出时仅需加上128.

```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
int n,k;
string t(int m,string b)
{
    char h;
    h=m%2+48;
    b=h+b;
    m/=2;
    //十进制转二进制
    if(m==0)
    {
        while(b.size()<8) b='0'+b;//不足八位添加前导0
        return b;
    }
    return t(m,b);//再进行二进制转化
}
int main()
{
    cin>>n;
    for(int i=1;i<=n/8;i++)
      {
          cin>>k;
          a+=t(k,"");//在原字符串后加上一个新字符串
      }
    for(int i=0;i<a.size();)
    {
        int c=1;//用于统计个数
        while(a[i]==a[i+1]) //进行比较
          {i++;c++;}
        if(a[i]=='1') cout<<c+128<<" ";//颜色为白色时
        else cout<<c<<" ";//颜色为黑色时
        i++;//指向下一位
    }
    return 0;
}
```

---

## 作者：Eason_AC (赞：1)

## Content
题目描述太过于繁琐而无法简化，请前往原题面查看。

**数据范围：$1\leqslant n\leqslant 8\times 10^4$。**
## Solution & Code
一个个人认为比较繁琐的模拟，但是思维难度奇低。

可能我的方法和题解区里面的大部分题解相比过程可能要复杂些，果然还是把简单问题想复杂化了……但是思路应该是清晰的。

话回正题，我们将所要做的程序分为四部分，本题解根据这四部分分开讲解，并且代码也只会分部分给。
### Part 1 读入&转化为二进制
我们将这 $\frac n8$ 个数读入进来之后，首先最主要的就是将这些数转化为八位的二进制数。我们可以考虑开个空字符串，每一轮将当前数 $x\bmod 2$ 的余数放到字符串的最后面，然后再 $x\leftarrow \left\lfloor\frac x2\right\rfloor$。最后再将整个字符串翻转过来就好了。注意，如果原数转换为二进制不足 $8$ 位，则要在前面补足前导零。最后将得到的 $\frac n8$ 个字符串按顺序拼接在一起，得到大字符串 $t$。

```cpp
n = Rint;
F(int, i, 1, n / 8) {
    int x = Rint; string tmp = "";
    while(x) tmp += (x % 2 + '0'), x /= 2;
    int len = tmp.size();
    if(len < 8) F(int, j, 1, 8 - len) tmp += "0";
    reverse(tmp.begin(), tmp.end()); //由于我们得到的字符串是反过来的，因此需要翻转一下，用到的是 STL 中的 reverse 函数。
    t += tmp;
}
```
### Part 2 分段
这一个部分比较简单，我们扫一遍字符串 $t$，一碰到和前面的字符不相等的情况就直接新建一段，存储当前这一段子串（其实只要存储第一个字符）及其长度。

```cpp
string tmp = "";
F(int, i, 0, n) {
    if((i == 0 || t[i] == t[i - 1]) && i != n) tmp += t[i];
    else a[++cnt] = (node){tmp, (int)tmp.size()}, tmp.clear(), tmp += t[i]; 
}
```
### Part 3 用二进制表示片段
有了前面的二进制转化的借鉴，这里就不用我再多说了吧，直接上代码。

```cpp
F(int, i, 1, cnt) {
    newt[i] += a[i].s[0];
    int p = a[i].t;
    string tmp2 = "";
    while(p) tmp2 += (p % 2 + '0'), p /= 2;
    reverse(tmp2.begin(), tmp2.end());
    int len = tmp2.size();
    if(len + 1 < 8) F(int, j, 1, 7 - len) newt[i] += "0";
    newt[i] += tmp2;
}
```
### Part 4 转化为十进制&输出
首先看二进制如何转化为十进制的问题。我们都知道，二进制的规则是“满二进一”，所以不难发现，**从低到高的第 $i$ 位上面的数字 $x$ 转换到十进制就是 $x\times 2^{i-1}$**。

因此，我们按照这种思路将十进制转换为二进制就很简单了，然后这道题目就这么愉快地做完了。

放上最后一部分的代码。

```cpp
F(int, i, 1, cnt) {
    int ans = 0;
    F(int, j, 0, 7) ans += (newt[i][j] - '0') * (1 << (7 - j));
    printf("%d%c", ans, " \n"[i == cnt]);
}
```

总体来说思维难度不是很大（起码我觉得比题解区的好想），实现起来有点麻烦，但也是一种行之有效的方法。

最终代码就把上面着四个部分拼接起来就好了，那么就不放完整代码了。

---

## 作者：the___ (赞：0)

# 思路
简单模拟。
具体方法：
1. 输入。
1. 判断对首个元素（总）进行特殊处理（判断该片段元素中像素的颜色）。
1. 取出每个二进制位。
	1. 若与前一元素相同，前一片段长度加 $1$。
   1. 若与前一元素不同，输出前一片段，并处理新片段首元素。
1. 输出最后片段。

补充说明：由于首位表示该片段元素中像素的颜色，所以若颜色为 $0$ 则将片段值初始化为 $0$，否则初始化为 $2^7$，即 $128$。

注意：$n$ 表示 $n$ 个像素，并非 $n$ 个数，应为 $\frac{n}{8}$ 个数。
# 代码
奉上代码：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
    int n,q=-1,sr,d=0,k=0;
    cin>>n;
    for(int i=1;i<=n/8;i++){
        cin>>sr;
        if(i==1 && sr>>7==1)                     //首个元素特殊处理
            d+=128;
        for(int j=8;j>=1;j--){
            if((sr%(1<<j))>>(j-1)==q)            //若与前一元素相同
                d++;
            else{                                //若与前一元素不同
                if(k)
                    cout<<d<<" ";
                q=(sr%(1<<j))>>(j-1);
                d=1;
                if(q==1)
                    d+=128; 
                k=1;
            }
        }
    }
    cout<<d;                                         //输出最后片段
    return 0;
}
```
若有疏漏、不详之处，恳请大佬指点。

---

## 作者：Erotate (赞：0)

### 题意：

一个图像有 $n$ 格像素，$0$ 为白色像素，$1$ 为黑色像素。将每 $8$ 个像素所表示的二进制数转换成一个十进制的数，现在输入 $n \div 8$ 个十进制数来表示这个图像，求每段连续的相同颜色的像素的长度与这段像素的颜色所组成的二进制数（这个二进制数有八位，最高位为它的颜色，后七位为它的长度）转换为十进制之后的值。

---
思路，先把所有输入的数转换成连续的二进制的数，用数组存起来，然后模拟：如果当前位置的值和上一个位置的值一样，那就长度加一，继续比较下一个位置。否则，按题目要求输出并把初始长度置为一。最后把最后一段的值也输出即可（大家自己想想为什么还要输出一个数）。

代码：

```cpp
#include<bits/stdc++.h>
#define N 80005
using namespace std;
int n,a[N],b[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n/8;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n/8;++i)
		for(int j=8;j>=1;--j){
			b[(i-1)*8+j]=a[i]%2;
			a[i]/=2;
		}
	int len=1;
	for(int i=2;i<=n;++i){
		if(b[i]!=b[i-1]){
			printf("%d ",b[i-1]?len+128:len);
			len=1;
		}
		else ++len;
	}
	printf("%d ",b[n]?len+128:len);
	return 0;
}
```



---

## 作者：WanderingTrader (赞：0)

这道题乍一看好像很难，其实不然，纯粹是字符串模拟。
### 题目分析&代码
第一步要做的，是把十进制整数转成二进制。为了方便，这里采用字符串保存。我们可以把它封装成一个函数，方便操作。  

举个例子，比如把十进制整数 `60` 转成字符串：
1. 创建一个新字符串ans，初始为空
1. 拉成二进制  
$60=(111100)_2$。

2. 从尾部抽出一个数字，转成字符  
得到 `'0'`，加在ans头部，现在ans是`"0"`  
4. 重复第3条操作，一共8次（因为题目中说数字都是8位无符号二进制）  

最后得到的ans即为`"00111100"`，非常简单。  

代码实现如下：
```cpp
string int_to_str(const int& k)
{//整数变成二进制串 
	string s;
	int x = k;
	for(int i = 1;i <= 8;++i,x >>= 1)
		s = (char)((x&1)+'0') + s;
	return s;
}
```
基本上就是把刚刚的思路模拟一遍。  

那么我们在读入$\dfrac{n}{8}$个数的时候就将它们转成二进制串，并且拼接在一起，如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
string str;
string int_to_str(const int& k)
{//整数变成二进制串 
	string s;
	int x = k;
	for(int i = 1;i <= 8;++i,x >>= 1)
		s = (char)((x&1)+'0') + s;
	return s;
}
int main()
{
	int n,k;
	scanf("%d",&n);
	for(int i = 0;i < n;i += 8)
	{
		scanf("%d",&k);
		str += int_to_str(k);
	}
	return 0;
}
```
接下来就是把这个str按01拆分，有点类似 [P1319 压缩技术](/problem/P1319)，有兴趣可以尝试完成这道题，还是很容易。  

我们先定义一个$cnt=1$(为什么是1稍后解释)  
```cpp
int cnt = 1;
```
然后从1开始直到n-1(不是0开始)枚举，如果$str[i]\ne str[i-1]$，那么就输出$cnt+128\times(str[i-1]-48(0$的ASCII码$))($第一位表示0或1$)$，当然 $cnt$ 要设成0。  

无论如何，每次枚举做一次$cnt+1$。  
```cpp
for(int i = 1;i < n;++i)
{
	if(str[i] != str[i-1])
	{
		int num = cnt + (1<<7)*(str[i-1]-'0');
		printf("%d ",num);
		cnt = 0;
	}
	++cnt;
}
```
可见因为i从1开始，所以cnt初始值应为1。  

但这样的话又有一个问题：枚举完了以后，岂不是还少一个数字没有输出吗？  
再做一次运算也未尝不可。不过这里有更好的方法：  

给str做一个预处理，令str[n]为str[n-1]相反的字符，这样枚举时多走一步，走到str[n]这里时势必会输出一下，str[n]相关的数值却不会输出了。  
于是修改后的代码如下：
```cpp
int cnt = 1;
str += (str[n-1] == '0' ? '1' : '0');
for(int i = 1;i <= n;++i)
{
	if(str[i] != str[i-1])
	{
		int num = cnt + (1<<7)*(str[i-1]-'0');
		printf("%d ",num);
		cnt = 0;
	}
	++cnt;
}
```
全部代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
string str;
string int_to_str(const int& k)
{//整数变成二进制串 
	string s;
	int x = k;
	for(int i = 1;i <= 8;++i,x >>= 1)
		s = (char)((x&1)+'0') + s;
	return s;
}
int main()
{
	int n,k;
	scanf("%d",&n);
	for(int i = 0;i < n;i += 8)
	{
		scanf("%d",&k);
		str += int_to_str(k);
	}
	int cnt = 1;
	str += (str[n-1] == '0' ? '1' : '0');
	for(int i = 1;i <= n;++i)
	{
		if(str[i] != str[i-1])
		{
			int num = cnt + (1<<7)*(str[i-1]-'0');
			printf("%d ",num);
			cnt = 0;
		}
		++cnt;
	}
	return 0;
}
```
复杂度仅为$O(n)$，还是非常高效的（每个测试点用时不超过$60ms$）。  

$$\mathrm{The\ End.}$$

---

## 作者：Ludo (赞：0)

## 题目大意

把每个数转换为二进制 每个数用8个位储存 不足八位补零

那么我们预设留空8位即可

## 代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
using namespace std;
int n,lxl,op[80001],op2[80001],now,cnt;//80000个位 n<=80000
int pol(int n,int lxl) //把十进制化为二进制
{
	int p=lxl,c=8,a[9]={0}; //预留八位 使用a数组储存
	do //模拟二进制转换
	{
		a[c--]=p%2;//逆序存储 每执行一次 就有一个位被记下 从低位到高位获取
		p/=2;
	}
	while (p>0);
	for (int i=n*8+1;i<=n*8+8;i++)
	{
		op[i]=a[i-n*8]; //把目前的记下 方便处理
	}
}
int change(int now,int cnt)
{
	int p=cnt;
	if (now==1) p+=128; //1 的情况 就是最高位加一 由于2^7=128 那么直接+128就可 
	return p;
}
int main(void)
{
	cin>>n;
	for (int i=1;i<=n/8;i++)
	{
		cin>>lxl;
		pol(i-1,lxl);
	}
	now=op[1],cnt=1;
	for (int i=2;i<=n;i++)
	{
		if (now!=op[i]) //和当前位不同 需要处理
		{
			cout<<change(now,cnt)<<' '; //先把上一次的输出
			now=op[i];cnt=1; //重置计数器 把标识设为当前位
		}
		else cnt++; //和前面相同 计数器加1
	}
	cout<<change(now,cnt);//由于最后一次还没有处理 因此直接输出
	return 0;
}

```


---


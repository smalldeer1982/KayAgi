# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# 题解

## 作者：YLWang (赞：37)

正常的题解已经够多了，现在我来讲一下打表方法。

打表，是一种极其实用的方法。尤其是打质数表。在不想打 $O(n)$ 素数筛法的时候，可以用打表代替。

对于这道题目，虽然直接暴力也能过，但要是把 $n$  改为 $1000000$ 暴力就全线崩溃了。只要在 $O(1)$  时间内判断出某个数是否为质数，就可以轻松过掉如上数据。

~~其实上面的都是废话~~

那究竟如何打表呢？

首先，我们要创建一个打表程序，像这样：

```
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, j, k) for(int i=(j);i<=(k);i++)
#define INF (2147483647>>1)
using namespace std;
inline int read()
{
    int num=0;
    char c=' ';
    bool flag=1;
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag=0;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return flag?num:-num;
}
//这是暴力判断
bool pd(int x) {
	if(x == 1 || x == 0) return 0;
	if(x == 2) return 1;
	int g = sqrt(x) + 1;
	For(i, 2, g) {
		if(!(x % i)) {
			return 0;
		}
	}
	return 1;
} 
int main()
{
	//打出来的字符太多，屏幕上存不下QAQ，所以只能输出到文件内
	freopen("stone.txt", "w", stdout);
	For(i, 1, 10000) {//输出每个数
		if(pd(i)) printf("1,");                    
		else printf("0,");
	}
	
	return 0;
}
```
接下来打开stone.txt。注意：请使用写字板！把这些东西复制下来，存进要提交的代码。

于是最终代码长这样：
```
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, j, k) for(int i=(j);i<=(k);i++)
#define INF (2147483647>>1)
using namespace std;
inline int read()
{
    int num=0;
    char c=' ';
    bool flag=1;
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag=0;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return flag?num:-num;
}
#define N 10005
int p[N] = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0...};//省略
int main()
{
	int n = read(), k = read();
	bool flag = 0;
	For(i, 1, n-k) {
		if(p[i] && p[i+k]) {
			printf("%d %d\n", i, i+k);
			flag = 1;
		}
	}
	if(!flag) {
		printf("empty\n");
	}
	return 0;
}
```
OK!

---

## 作者：青蛙王子 (赞：11)

## 这个题其实打表就可以啦~

n<=10000(这个可以打表)

当然，我们需要获取10000以内的素数。

二话不说上一个代码（超不超时不要紧反正**不交**）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int f;
int prime(int a)//正常判断素数
{
	for(int i=2;i<=sqrt(a);i++)
	  if(a%i==0&&a!=i)
		return 0;
	return 1;
}
int main()
{
	freopen("a.out","w",stdout);//因为输出太长所以我们用文件输出
	for(int i=2;i<=10000;i++)//枚举
	{
		if(prime(i))
		  cout<<i<<",";//这儿有个逗号（方便粘贴）
	}
	fclose(stdout);
	return 0;
}
```

然后我们得到了：

```cpp
2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973
```

（有逗号真好！**最后一个逗号被我删了**，没有回车可直接粘贴！）

## 随后——

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int pri[10001]={0,/*2……9973*/};//太长了所以省略（其实上面有），前面的0有必要~
int n,k,f;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	  for(int j=1;j<i;j++)
	  	if(pri[i]-pri[j]==k&&pri[i]<=n&&pri[j]<=n)//判断很重要！否则40分！
	  	{
	  		cout<<pri[j]<<" "<<pri[i]<<endl;
	  		f=1;
	  	} 
	if(!f)  cout<<"empty";//别忘了
	return 0;
}
```

---

## 作者：引领天下 (赞：8)

来发一个比楼下们快的方法。

本题我用的是筛法，但是我优化了！

具体优化的方法呢，就是楼下们太暴力了，竟然直接暴力！（从 $1$ 到 $n$）

然而我们有更快的方法！

在筛法打质数表的时候，我不仅保留了 bool 数组（用来判断），还开了一个整数数组，存下了质数，这样，我们就直接用质数表暴力。

这样，就可以直接循环质数，提高了效率。

上代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;
int n,k,a[3000],ps;//n，k为题目中的变量，a数组为质数数组，ps为质数下标
bool s[10005]={1,1},ok=1;//s数组为桶，ok为判断有没有满足条件的质数对的变量
void $(){
    for (int i=2;i<10001;i++)//筛法标准做法
    if (!s[i]){//s[i]=1表示不为质数，=0则是
        a[ps++]=i;//把i这个质数存下来
        for (int j=i*2;j<10001;j+=i)s[j]=1;//循环标记
    }
}
int main(){
    $();//预处理
    scanf ("%d%d",&n,&k);
    for (int i=0;a[i]<=n&&a[i]+k<=n;i++)if (!s[a[i]+k])//暴力，符合条件就输出
    ok=!printf ("%d %d\n",a[i],a[i]+k);
    if (ok)printf ("empty");//没有就输出empty
        //不要被题目中“相差为k的质数对”所迷惑，实际上，如果你多判一次a[i]-k，答案会输出两遍。具体为什么，自己想。
    return 0;
}
```

---

## 作者：Qing_s (赞：7)

## P2640 神秘磁石

超超超超级大水题。 ~~虽然我交了5,6次。~~

照例先看题。
一共就两个条件：
>    若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。

>若两个磁石相距为 k ，那么磁石间的破坏力将会达到当前磁力的峰值。

略读一遍，我们可以简化为以下两点:
- 两个磁石的坐标一定都是在 __素数__ 坐标上。
- 两个磁石相隔距离为 k 。

继续往下读：
>那么请问给出长度不超过 n 的一维坐标系，有哪几对坐标间磁石破坏力最大。

破坏力最大？这不就是 ~~有手就行~~ 满足我们分析得出的两个条件不就可以了。

最后来看看输出有什么条件：
>所有小于等于 n 的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出 empty。

注意：若没有找到任何素数对，__输出 empty__ 。

那我们来看看满足我们的条件都需要什么：
1. 素数筛。
1. 判断是否有满足条件的素数对，没有输出 empty 。
1. ~~没了~~

素数筛简单的 hen 啊。一看数据范围：
>$1≤k≤n≤10^4$

直接朴素 ~~暴力~~ 算法不就好了吗。

我们直接从2开始一直循环到 n - m 。

因为大于了 n - m 那么就直接超出范围了。

于是：
```cpp
for( int i = 2 ; i <= n - m ; i++ ){
    if( prime( i ) )
        if( prime( i + m ) ){
            cout << i << " " << m + i << endl ;
            flag = true ;
        }
}
```
flag 就是我们判断是否有素数对的标识。

prime 函数直接写朴素的就可以了哦。
```cpp
bool prime( int x ){
    int stop = sqrt(x) + 1 ;
    if( x == 2 )
    	return 1 ;
    if( x % 2 == 0 )
    	return 0 ;
    for ( int i = 3 ; i <= stop ; i += 2 )
    	if( x % i == 0 )
    		return 0 ;
    return 1 ;
}
```

完整代码就不放啦。pj-思维难度也不是很高适合初学素数筛的人刷。

~~我才不是为了咕值呢。~~

求通过(小声bb。

---

## 作者：陈LC (赞：5)

首先我要吐槽一句：~~这题太水了！！！~~

嗯，进入正题。这道题可以用质数的线性筛解决。

话不多说，上代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=10005;
int f[maxn]={0,0};//不是为0,是为1
void ko(int i){//用来标记是否为质数
	int j=i;
	for(i*=2;i<=10000;i+=j){//重点！以i的倍数增加，每一个i的倍数（除i本身）都赋值为0，不是质数
		f[i]=0; 
	}
}
void s(){
	int i,j;
	for(i=0;i<=10000;i++){
		for(j=2;j<=10000;j++){
			if(f[j]==1){
				ko(j);
			}
		}
	}
}
int main(){
	int n,k,i;
	bool flag=true;//表示有没有找到质数
	for(i=2;i<=10000;i++){
		f[i]=1;//先全部打成1（是质数）
	}
	s();//调用函数
	scanf("%d%d",&n,&k);//输入
	n-=k;
	for(i=2;i<=n;i++){
		if(f[i]==1&&f[i+k]==1){
			printf("%d %d\n",i,i+k);//输出记得换行
			flag=false;//标记为假
		}
	}
	if(flag){
		printf("empty");//如果没有输出empty
	}
    return 0;
}
```

---

## 作者：likztime (赞：5)

这道题，采用了新方法:Miller\_Rabin 算法

因为这道题数据太小，所以也可以用其他方法

但是用这种算法的话会极大提升效率，时间复杂度为O（n），特别是遇到特别大的数的时候，更加明显，不过这种算法不稳定，但是这种不稳定的概率极小，小到几乎可以忽略不计

#算法的理论基础：

###1. Fermat定理：若n是奇素数，a是任意正整数(1≤ a≤ n−1)，则 a^(n-1) ≡ 1 mod n。

###2. 推演自Fermat定理（具体过程我没看懂，Orz）, 如果n是一个奇素数，将n−1表示成2^s\*r的形式，r是奇数，a与n是互素的任何随机整数，那么a^r ≡ 1 mod n或者对某个j (0 ≤ j≤ s−1, j∈Z) 等式a^(2jr) ≡ −1 mod n 成立。

##那么我们按照上述的定理2，首先重复n次实验。对于每一次实验，随机取检验算子a，带入定理2进行检验，看看在算子a下，n能否满足

##a^r ≡ 1 mod n或者对某个j (0 ≤ j≤ s−1, j∈Z) 等式a^(2jr) ≡ −1 mod n

如果任意一次实验不满足，则判定不是素数，如果都满足，可近似可以认为是素数（错误率极小）


    
    
    
    
    
    
```cpp
    #include <iostream>
    #include <cstdio>
    #include <algorithm>
    #include <cmath>
    #include <cstring>
    #include <map>
    using namespace std;
    const int times = 20;
    int number = 0;
    map<long long, int>m;
    long long Random( long long n )            //生成[ 0 , n ]的随机数
    {
        return ((double)rand( ) / RAND_MAX*n + 0.5);
    }
    long long q_mul( long long a, long long b, long long mod ) //快速计算 (a*b) % mod
    {
        long long ans = 0;
        while(b)
        {
            if(b & 1)
            {
                b--;
                ans =(ans+ a)%mod;
            }
            b /= 2;
            a = (a + a) % mod;
        }
        return ans;
    }
    long long q_pow( long long a, long long b, long long mod ) //快速计算 (a^b) % mod
    {
        long long ans = 1;
        while(b)
        {
            if(b & 1)
            {
                ans = q_mul( ans, a, mod );
            }
            b /= 2;
            a = q_mul( a, a, mod );
        }
        return ans;
    }
    bool witness( long long a, long long n )//miller_rabin算法的精华
    {
        //用检验算子a来检验n是不是素数
        long long tem = n - 1;
        int j = 0;
        while(tem % 2 == 0)
        {
            tem /= 2;
            j++;
        }
        //将n-1拆分为a^r * s
        long long x = q_pow( a, tem, n ); //得到a^r mod n
        if(x == 1 || x == n - 1) return true;    //余数为1则为素数
        while(j--) //否则试验条件2看是否有满足的 j
        {
            x = q_mul( x, x, n );
            if(x == n - 1) return true;
        }
        return false;
    }
    bool miller_rabin( long long n )  //检验n是否是素数
    {
        if(n == 2)
            return true;
        if(n < 2 || n % 2 == 0)
            return false;                //如果是2则是素数，如果<2或者是>2的偶数则不是素数
        for(int i = 1; i <= times; i++)  //做times次随机检验
        {
            long long a = Random( n - 2 ) + 1; //得到随机检验算子 a
            if(!witness( a, n ))                        //用a检验n是否是素数
                return false;
        }
        return true;
    }
    int main( )
    {
        std::ios::sync_with_stdio(false);
        bool ok=0;
        long long n,k;
        cin>>n>>k;
        for(long long i=1;i<=n;++i)
        {
            if(miller_rabin(i)&&miller_rabin(i+k)&&i<=n&&i+k<=n)
            {
                cout<<i<<' '<<i+k<<endl;
                ok=1;
            }
        }
        if(ok==0)cout<<"empty"<<endl;
        return 0;
}
```

---

## 作者：_Grey (赞：4)

[更好的阅读体验(安利自己的博客)](https://lllinea.github.io/%E9%A2%98%E8%A7%A3-%E7%A5%9E%E7%A7%98%E7%A3%81%E7%9F%B3/)

~~题解

很少做数论的题因为窝汰蒟蒻鸭~

窝们只需要从2和2+k开始枚举判断就可以了

记得拉一个flag 做标记特判鸭

话说给各位安利一个原理 ~~(应该叫原理，窝不知道)~~

6倍原理 ：素数只可能出现在6的倍数附近

判断素数的效率真的很高啊QAQ

代码特意加了反作弊QAQ

```
#include <bits/stdc++.h>
using namespace std;
int n,k;
bool su(int a){
    if(a == 1) return 0;
    if(a == 2|| a == 3) return 1;
    if(a%6!=1&&a%6!=5) return 0;
    register int temp = sqrt(a);
    for (int i = 5;i <= temp;i += 6)
        if(a % i == 0 or a%(i+2)==0) return 0;
    return 1;
}
bool flag;
int main(){
	freopen("node.in","r",stdin);
	freopen("node.out","w",stdout);
	ios :: sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 2;i <= n;++i){
		if(su(i) && (i + k <= n) && (su(i+k))){
			flag = true;
			cout << i << " "<< i + k << endl;
		}
	}
	if(!flag)cout << "empty" << endl;
	return 0;
}
```

---

## 作者：zhaowangji (赞：4)

题目不是太难

~~貌似刚进洛谷时在比赛里看到过类似的
一下子就跳过了~~

其实有桶排思想在里面，类似校门外的树。链接：[校门外的树](https://www.luogu.org/problemnew/show/P1047)

把坐标系想成一个数组，默认为一个值，一个循环判断其中的素数，把下表为素数的成员改值，然后进行判断
```cpp
#include<iostream>
using namespace std; 
int a[10001],n,k,t;//t为判断变量
int main()
{
   cin>>n>>k;
   a[1]=1;//要记住1不是素数
   //不然可能会有多一个解
   for(int i=2;i<=n;i++)
   for(int j=2;j*j<=i;j++)
   if(i%j==0)a[i]=1;//判断素数
   for(int i=1;i<=n-k;i++)
   if(a[i]==0&&a[i+k]==0)
   //找间隔为k的两个素数
   {t=1;cout<<i<<' '<<i+k<<endl;}
   if(t==0)cout<<"empty";
   //要记住没有数对要输出empty
   //不然会有两个点卡住
   //一开始没看见还WA了
   return 0;
}
```

---

## 作者：JackcreaM (赞：3)

嗯嗯，看到这道数学题题解这么少，我就来一发~~

是的，这题利用了一种**素数筛法**！

我们举个栗子：

这有30个数

1 2 3 4 5 6 7 8 9 10

11 12 13 14 15 16 17 18 19 20

21 22 23 24 25 26 27 28 29 30

1不是素数，去掉。剩下的数中2最小，是素数，去掉2的倍数，余下的数是:

3 5 7 9 11 13 15 17 19 21 23 25 27 29

剩下的数中3最小，是素数，去掉3的倍数，如此下去直到所有的数都被筛完，求出的素数为:

2 3 5 7 11 13 17 19 23 29

是不是比那种一个个试的方法好很多呢？？

上代码：
```
#include<bits/stdc++.h>//头文件
using namespace std;
long long  n,k,i,j,a[100001];
//这里我们假设数组项为0（默认），就是素数，不然不是
int main()
{
	cin>>n>>k;
	a[1]=1;//1不是素数！
	for(i=1;i<=n;i++)
	{
		if(a[i]==0)//判断这个数能不能用，即上面解释中“最小”的数
		{
			j=i+i;//可不要把选好的数否定了
			while(j<=n)
			{
				a[j]=1;//否定
				j+=i;//i的下一个倍数
			}
			
        }
	}
	long long ans=0;//为输出“empty”做准备
	for(i=1;i<=n-k;i++)//因为i+k会判断的，所以求到n-k就好了
	{
		if(a[i]==0&&a[i+k]==0)//能不能用
		cout<<i<<" "<<i+k<<endl,ans++;
	}
	if(ans==0)
	cout<<"empty";
	return 0;
}
```

这个方法在许多题目中都会用到，希望大家记牢:)

蒟蒻题解，大神勿喷

---

## 作者：lzhdbfs (赞：2)

##### 蒟蒻第一次~~阀体街~~

### 正常的题解已经够多了，我就再来一篇吧~~~/手动滑稽

其实吧 ~~这就是一个简单的判断素数~~

#### 如果 i是素数且 i+k也是 就输出

并且标记一个bool数组

废话不多说 上代码

```
#include<bits/stdc++.h>//最牛逼的（几乎）万能头文件
using namespace std;
bool su(int n){//素数判断
  if(n==1) return 0;
	for(int i=2;i<=sqrt(n);i++){
		if(n%i==0) return 0;
	}
	return 1;
}
int a,b,n,k;
bool t;
int main(){
	cin>>a>>b;//n和k
	for(int i=2;i<=a-b;i++){//不可以i<=a 可能会超出限制
		 n=i,k=i+b;
		if(su(n)==1&&su(k)==1){
			cout<<n<<" "<<k<<endl;
			t=1;//标记
		}
	}
	if(t==0){//标记为零则是没有
		cout<<"empty"<<endl;
	}
	return 0;
}
```
安利一下dalao博客

[前缀自动机·宋](https://www.luogu.org/blog/floyd-qianzhuihe/)

---

## 作者：Leaved_ (赞：2)

有人和我思路一样吗？

我用的是~~纯暴力~~

呸，朴素算法

bool 函数判断i和i+k是否是素数

如果是，标记，输出

如果没有标记，则没有，输出empty.

~~话说竟然没超时~~

```cpp
#include <bits/stdc++.h>

using namespace std;

int n,k;
bool su_;

bool is_su(int x) {
	for(int i=2;i*i<=x;i++) {
		if(!(x%i)) return false;
	}
	return true;
}//bool函数判断是否是素数

int main() {
	cin>>n>>k;
	for(int i=2;i+k<=n;i++) {//类似于“剪枝”，没必要从2枚举到n
		if(is_su(i)&&is_su(i+k)) {//满足条件
			su_=1;//标记，以便判断无解的情况
			cout<<i<<" "<<i+k<<endl;
		}
	}
	if(!su_) {//无解
		cout<<"empty"<<endl;
	}
	return 0;
}
```
暴力AC！！！

---

## 作者：Atmizz (赞：1)

看到各位dalao的打表，不觉心中一颤。
### 【思路】：
其实这个题的话数据很弱，完全可以用线性筛素数来A掉。然后的话就是有一个坑点，就是判重，先粘一下我的80分代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <iomanip>

using namespace std;

int n,k,ans=0;
bool prime[10001]={0};
int main()
{
    scanf("%d%d",&n,&k);
    prime[1]=1;
    
    for(int i=2;i<=n;++i)
        if(prime[i]==0)	//线性筛素数 
            for(int j=2;j*i<=n;++j)
                prime[j*i]=1;	//原理：素数的倍数一定是合数 
    
    for(int i=2;i<=n-k;++i)	//循环到n-k就可以，大于了n-k就不可能在n范围内了 
        if(prime[i]==0 && prime[k+i]==0) {	//两者都是素数 
            prime[i]=1;	//置1，就不会重复扫了 
            prime[k+i]=1;
            ans++;	//判断是否为空 
            printf("%d %d\n",i,k+i);
        }
    if(ans==0)	//为空 
        printf("empty");
    return 0;
}
```
很明显，判重会失败，因为当k小的时候，prime[i+k]还是有可能很被扫到的，所以会需要把prime[i]置为1就可以，因为他扫完一边不可能被扫到第二遍。AC代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <iomanip>

using namespace std;

int n,k,ans=0;
bool prime[10001]={0};
int main()
{
	scanf("%d%d",&n,&k);
	prime[1]=1;
	
	for(int i=2;i<=n;++i)
		if(prime[i]==0)	//线性筛素数 
			for(int j=2;j*i<=n;++j)
				prime[j*i]=1;	//原理：素数的倍数一定是合数 
	
	for(int i=2;i<=n-k;++i)	//循环到n-k就可以，大于了n-k就不可能在n范围内了 
		if(prime[i]==0 && prime[k+i]==0) {	//两者都是素数 
			prime[i]=1;	//置1，就不会重复扫了 
			ans++;	//判断是否为空 
			printf("%d %d\n",i,k+i);
		}
	if(ans==0)	//为空 
		printf("empty");
	return 0;
}
```

---

## 作者：我是蒟弱 (赞：1)

题目传送门：[P2640 神秘磁石](www.luogu.org/problemnew/show/P2640)

## 思路：**线性筛素数**

本题要求求出两个差k的质数，很多的题解都是暴力枚举，这里我不多说。下面我要讲一种线性筛判断素数的方法。

所谓线性筛，速度也达到了线性，不妨给大家透露一下，本题我的线性筛做法28ms，每个点最高3ms。那么这个线性筛到底是什么呢？

洛谷上有一道线性筛的模板题：[P3383 【模板】线性筛素数](https://www.luogu.org/problemnew/show/P3383)
，这道题暴力过不去。

线性筛模板：
```cpp
int t=0,prime[N];
bool f[N];//N是多少看题目要求
int main(){
	memset(f,true,sizeof(f));
    f[0]=f[1]=false;
    for(int i=2;i<=n;i++){
        if(f[i]){
			prime[++t]=i;
		} 
        for(int j=1;j<=t&&i*prime[j]<=n;j++){
            f[i*prime[j]]=false;//做线性筛
            if(i%prime[j]==0){
				break; 
			} 
        }
    }
}
```
优化部分：
```cpp
if(i%prime[j]==0){
	break; 
} 
```
为什么这么做，看不懂别急，下面解释。

以n为10为例子，走循环：
```
f数组储存是不是素数

i=2:
f[2]=true，prime[1]=2,t=1;
从1~1循环
f[2*prime[1]]=false;
就是说f[2*2],f[4]=false;

i=3:
f[3]=true,prime[2]=3，t=2;
从1~2循环
j=1:
f[3*prime[1]]=false→f[3*2]=false→f[6]=false;
3%2!=0,3*(2+1)<=10,j=2;
f[3*prime[2]]=false→f[3*3]=false→f[9]=false;

i=4:
f[4]=false,第一个if语句不进
从1~2循环（t没变）
f[4*prime[1]]=false→f[4*2]=false→f[8]=false;
4%2==0,跳出循环；

i=5:
f[5]=true,t=3,prime[3]=5;
从1~3循环 
f[5*prime[1]]=false→f[5*2]=false→f[10]=false;
5%2!=0&&5*(1+1)<=10,j=2
f[5*prime[2]]=false→f[5*3]=false→f[15]=false;
5%3!=0,但5*（2+1）>10,跳出循环

i=6:
f[6]=false,if不进
从1~3循环
判断:6*prime[1]→6*2=12,12>10,进不去循环

i=7:
f[7]=true,t=4,prime[4]=7;
7*prime[1]→7*2=14,14>10,无法进入循环

i=8:
f[8]=false,if不进
8*prime[1]→8*2=16,16>10,无法进入循环

i=9:
f[9]=false,if不进
9*prime[1]→9*2=18，18>10,不进入循环

i=10:
f[10]=false,if不进
10*prime[1]→10*2=20,20>10,不进入循环
```
推完了，你发现，每个非素数的数被筛了并且只筛了一遍，这就是为什么线性筛快。

要是不理解的，可以参考P3383的代码，位置：[P3383题解](https://www.luogu.org/blog/your-luogu-boke/solution-P3383)

那么，现在上这道题的代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10005//声明N，和 const int N=10005 一样 
using namespace std;
int n,q,t,prime[N],x;
bool f[N];
int main(){
    scanf("%d%d",&n,&q);//输入，n为范围，q为差距 
    memset(f,true,sizeof(f));//全部赋值 
    f[0]=f[1]=false;//筛掉0,1 
    for(int i=2;i<=n;i++){//进行线性筛 
        if(f[i]){//质数 
			prime[++t]=i;//储存 
		} 
        for(int j=1;j<=t&&i*prime[j]<=n;j++){//不断地筛数 
            f[i*prime[j]]=false;//倍数，筛掉 
            if(i%prime[j]==0){//优化 
				break; 
			} 
        }
    }
    bool output=false;//判断是否输出 
    for(int i=2;i<=n-q;i++){//循环
		//到n-q就行了，因为再往上循环，i+q的那个磁石也会超范围 
        if(f[i]&&f[i+q]){//两个都是素数 
        	printf("%d %d\n",i,i+q);//输出i和i+q并换行 
        	output=true;//已经输出了 
		}
    }
    if(output==false){//没有输出 
    	printf("empty");//按照题意，输出empty 
	}
    return 0;//完美结束 
}
```
大家有不理解的，欢迎评论。

推一下蒟蒻的博客，虽然只有孤零零的几篇文章：[我的博客](https://www.luogu.org/blog/your-luogu-boke/)

管理员求通过QwQ

---

## 作者：TheAurora (赞：1)

打表法~~~~

首先可以编写一个额外程序来算出10000以内的所有素数，然后放入数组,免去判断素数的过程，节省时间（内存应该足够）
```cpp
int num[10000]={
2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,2\
23,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,4\
57,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,7\
19,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,9\
97,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,12\
23,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,14\
59,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,16\
93,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,19\
49,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,22\
03,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,24\
23,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,26\
93,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,29\
39,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,32\
21,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,34\
91,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,37\
27,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,40\
03,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,42\
59,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,45\
47,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,48\
13,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,50\
87,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,53\
99,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,56\
53,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,58\
97,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,62\
11,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,64\
73,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,67\
79,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,70\
27,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,73\
49,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,76\
21,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,79\
19,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,82\
31,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,85\
37,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,88\
03,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,90\
91,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,93\
77,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,96\
49,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,99\
29,9931,9941,9949,9967,9973,10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,\
10193,10211,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,10429,10433,1045\
3,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10\
709,10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,\
10973,10979,10987,10993,11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,11159,11161,11171,11173,11177,11197,11213,1123\
9,11243,11251,11257,11261,11273,11279,11287,11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,11447,11467,11471,11483,11\
489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,11779,\
11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,1198\
7,12007,12011,12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,12161,12163,12197,12203,12211,12227,12239,12241,12251,12\
253,12263,12269,12277,12281,12289,12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,12451,12457,12473,12479,12487,12491,\
12497,12503,12511,12517,12527,12539,12541,12547,12553,12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,12697,12703,1271\
3,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12\
973,12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,\
13219,13229,13241,13249,13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,13417,13421,13441,13451,13457,13463,13469,1347\
7,13487,13499,13513,13523,13537,13553,13567,13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,13709,13711,13721,13723,13\
729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,13997,\
13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,1430\
3,14321,14323,14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,14461,14479,14489,14503,14519,14533,14537,14543,14549,14\
551,14557,14561,14563,14591,14593,14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,14741,14747,14753,14759,14767,14771,\
14779,14783,14797,14813,14821,14827,14831,14843,14851,14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,15017,15031,1505\
3,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15\
287,15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,\
15527,15541,15551,15559,15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,15683,15727,15731,15733,15737,15739,15749,1576\
1,15767,15773,15787,15791,15797,15803,15809,15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,15973,15991,16001,16007,16\
033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,16273,\
16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,1656\
7,16573,16603,16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,16747,16759,16763,16787,16811,16823,16829,16831,16843,16\
871,16879,16883,16889,16901,16903,16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,17041,17047,17053,17077,17093,17099,\
17107,17117,17123,17137,17159,17167,17183,17189,17191,17203,17207,17209,17231,17239,17257,17291,17293,17299,17317,17321,17327,17333,17341,17351,17359,17377,1738\
3,17387,17389,17393,17401,17417,17419,17431,17443,17449,17467,17471,17477,17483,17489,17491,17497,17509,17519,17539,17551,17569,17573,17579,17581,17597,17599,17\
609,17623,17627,17657,17659,17669,17681,17683,17707,17713,17729,17737,17747,17749,17761,17783,17789,17791,17807,17827,17837,17839,17851,17863,17881,17891,17903,\
17909,17911,17921,17923,17929,17939,17957,17959,17971,17977,17981,17987,17989,18013,18041,18043,18047,18049,18059,18061,18077,18089,18097,18119,18121,18127,1813\
1,18133,18143,18149,18169,18181,18191,18199,18211,18217,18223,18229,18233,18251,18253,18257,18269,18287,18289,18301,18307,18311,18313,18329,18341,18353,18367,18\
371,18379,18397,18401,18413,18427,18433,18439,18443,18451,18457,18461,18481,18493,18503,18517,18521,18523,18539,18541,18553,18583,18587,18593,18617,18637,18661,\
18671,18679,18691,18701,18713,18719,18731,18743,18749,18757,18773,18787,18793,18797,18803,18839,18859,18869,18899,18911,18913,18917,18919,18947,18959,18973,1897\
9,19001,19009,19013,19031,19037,19051,19069,19073,19079,19081,19087,19121,19139,19141,19157,19163,19181,19183,19207,19211,19213,19219,19231,19237,19249,19259,19\
267,19273,19289,19301,19309,19319,19333,19373,19379,19381,19387,19391,19403,19417,19421,19423,19427,19429,19433,19441,19447,19457,19463,19469,19471,19477,19483,\
19489,19501,19507,19531,19541,19543,19553,19559,19571,19577,19583,19597,19603,19609,19661,19681,19687,19697,19699,19709,19717,19727,19739,19751,19753,19759,1976\
3,19777,19793,19801,19813,19819,19841,19843,19853,19861,19867,19889,19891,19913,19919,19927,19937,19949,19961,19963,19973,19979,19991,19993,19997
} ; 
```
接下来只要跟着题意走就行了，AC代码附上
```cpp
#include<bits/stdc++.h>
using namespace std; 
int num[10000]={....} ;//此处太长，省略，自己知道就行
int main()
{
	int n,k; 
	cin>>n>>k; 
	bool flag=false;//标记
	for(int i=0;num[i]+k<=n;++i)//查找小于n的素数
	{
		for(int j=0;num[j]<=num[i]+k;++j)
	     if(num[i]+k==num[j])//判断符合要求的素数队
	     {
		 cout<<num[i]<<' '<<num[j]<<endl;
		 flag=true;  	//如果存在符合要求的素数队，加上标记,表示存在答案
		 }
	}
	if(!flag)
	cout<<"empty"; //如果没有符合要求的素数队，输出empty 
    while(1){}//只可意会,不可言传
	return 0; 
}
 
```

---

## 作者：微香玉烛暗 (赞：1)

这道题用一个函数判断质数，在一个一个的枚举。先不多说，上代码：
```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;

bool prime(int x){//判别质数函数
    if(x<5)if(x==2||x==3)return 1;//省时
    else return 0;
    if(!(x%6==5||x%6==1)) return 0;
    else
    {for(int i=2;i*i<=x;i++)
        if(x%i==0)return 0;
        return 1;}
}

int main(){
    int n,k;
    bool t=1;//特征变量t
    cin>>n>>k;
    for(int i=2;i<=n-k;i++)//从2—n-k枚举
        if(prime(i)&&prime(i+k)){//只要i和i+k都是质数，
            cout<<i<<" "<<i+k<<endl;//就打印
            t=0;//特征变量清零
        }
    if(t)cout<<"empty";//判别t,打印empty
    return 0;//华丽收尾
}
```

---

## 作者：逍遥__天赐 (赞：1)

看只有一个题解，我就来造福一下大家

思路：首先我们要判断一下k和n的关系

若它们形不成任何素数对，则提前结束

然后素数打表

接下来判断有没有素数对，用flag来记录有没有

注意：2要特判，这样可以省时

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
bool p[10001]={1,1};
int main()
{
    int n,k;
    cin>>n>>k;
    if(n<k+2)
    {
        cout<<"empty\n";
        return 0;
    }
    bool flag=0;
    int t=sqrt(n);
    for(int i=2;i<=t;i++)
    {
        if(p[i]) continue;
        for(int j=i+i;j<=n;j+=i) p[j]=1;
    }
    if(!p[2]&&!p[2+k]) 
    {
        cout<<2<<' '<<2+k<<endl;
        flag=1;
    }
    for(int i=3;i+k<=n;i+=2)
    {
        if(p[i]||p[i+k]) continue;
        cout<<i<<' '<<i+k<<endl;
        flag=1;
    }
    if(!flag) cout<<"empty\n";
    return 0;
}

---

## 作者：flynn0512 (赞：0)

# P2640 神秘磁石
### 一、分析数据
6924是素数范围， 809是素数之差， 只需从2 811试到6115 6924既可以（方法虽笨但不超时）
### 二、编写框架
1. 筛出素数表
1. 循环检验
1. 直至输出完毕或输出empty
### 三、填入内容
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
bool prime[10005];//布尔素数表，存在表示素数，不存在表示非素数
int main(){
	int n, k, f=1;//f是一个flag变量
	scanf("%d%d", &n, &k);
	memset(prime, true, sizeof(prime));//强制把素数表都转为素数
	prime[1]=false;//一不是素数
	for(int i=2;i<=10005;i++)
		if(prime[i])
			for(int j=2;i*j<=10005;j++)
				prime[i*j]=false;//筛素数模块！！！
	for(int i=1;i+k<=n;i++){//是较大数不抄范围！！！
		if(prime[i]&&prime[i+k]){
			printf("%d %d\n", i, i+k);
			f*=0;//改变flag
		}
		else f*=1;
	}
	if(f) printf("empty");//如果一直没找着，输出“empty”
	return 0;
}
```

### 四、错误原因
我第一次评测只拿了三十分，原因在于忘了考虑较大数不抄范围了，甚至有一个RE……
### 五、回顾总结
1. 记住筛法模块！
1. 记住数据范围！


---

## 作者：chenjiarui (赞：0)

## 普及组的模拟题都是挺简单的，而且这是一道黄题，并不难。
### 下面贴上代码：
```cpp
#include<cstdio>
#include<cstring>
#define maxn 10039//数组定义，我懒，这个比较方便
using namespace std;
int n,k,cnt;//定义
int b[maxn];
bool a[maxn];
void FLY(int x) {//函数FLY1
	memset(a,1,sizeof a);
	a[0]=a[1]=false;
	for(register int i=2; i<=x; i++) {
		if(a[i]) b[++cnt]=i;
		for(register int j=1; j<=cnt; j++) {
			register int k=i*b[j];
			if(k>x) break;
			a[k]=false;
			if(i%b[j]==0) break;
		}
	}
}
bool FLY2() {//函数FLY2
	int num=0;
	for(register int i=1; i<=cnt; i++) {
		register int f=b[i]+k;
		if(f>n) 
		break;
		if(a[f]) 
		printf("%d %d\n",b[i],f),num++;
	}
	if(!num) 
	printf("empty");//判断num是否为零，是就输出empty
}
int main() {
	scanf("%d%d",&n,&k);//输入
	FLY(n);
	FLY2();
	return 0;
}
```


---

## 作者：御坂10027号 (赞：0)

# 打开题解一看，就看到红名dalao在发打表题解，我在这里先膜拜一下

机房里新来了一位学长，为了了解一下我们的水平，就给我们几道题刷刷，结果他找错了题，于是就让我们刷了几道普及的题，出于无聊，发一篇题解玩玩。

题目大意就是让你找出在1~n中所有相隔k的素数对。

判断素数很简单（当然，我懒得打太多代码，所以打了一个比较慢的）：
```
inline bool ss(int x) {
	for(int i = 2; i <= sqrt(x); ++i)
	if(x % i == 0) return false;
	return true;
}
```
当然，越简单的题，就越容易翻车。

题目中说：“若没有找到任何素数对，输出empty。”

如果你没看到，那就好玩了（手动滑稽）

完整代码：
```
#include <bits/stdc++.h>

using namespace std;

int n, k, num;

inline bool ss(int x) {
	for(int i = 2; i <= sqrt(x); ++i)
	if(x % i == 0) return false;
	return true;
}

int main() {
	cin >> n >> k;
	for(int i = 2; i <= n - k; ++i) {
		if(ss(i) && ss(i + k)) {
			cout << i << " " << i + k << endl;
			num++;
		}
	}
	if(num == 0) cout << "empty";
	return 0;
}
```


---

## 作者：Sinwind (赞：0)

------------

# 思路

1. 列举一对数中较小的一个数small（small ∈ [2, len - distance]，且small ∈ N+），注意这里**small最大为len - distance**，若small > len - distance，big = small + distance > len，超出范围；

2. 判断small是否为素数（[普通判断素数](https://www.luogu.org/blog/Singularwind/prime-number-or-not)）；
- 若small为合数（is_prime_small == false），跳过本次循环，执行下次循环；
- 若small为素数（is_prime_small == true），继续判断big是否为素数；
	- 若big是合数（is_prime_big == false），跳过本次循环；
    - 若big也是素数（is_prime_big == true），存在素数对（yon = true），输出small和big的值。

3. 若不存在素数对（yon == false），输出"empty"。

------------

# 代码

```cpp
#include <iostream>

using namespace std;

int main(void)
{
	int len;    		//一维坐标系的长度
	int distance;   	//两个数的距离
	bool yon = false;       //是否存在素数对
	
	cin >> len >> distance;
	
	for(int small = 2; small <= len - distance; small++)
	{
		//是否为素数
		bool is_prime_small = true, 	//small是否为素数
			 is_prime_big = true;   //big是否为素数
		
		//先判断small是否为素数
		for(int i = 2; i * i <= small; i++)
		{
			if(small % i == 0)
			{
				is_prime_small = false;
				break;
			}
		}
		
		//small为素数
		if(is_prime_small)
		{
			int big = small + distance;

            //再判断big是否为素数
			for(int i = 2; i * i <= big; i++)
			{
				if(big % i == 0)
				{
					is_prime_big = false;
					break;
				}
			}
			
			//big为素数
			if(is_prime_big)
			{
				yon = true;
				cout << small << " " << big << endl;
			}
		}
	}
	
	//不存在素数对
	if(yon == false)
	{
		cout << "empty" <<endl;
	}
	
	return 0;
}
```


---

## 作者：米奇奇米 (赞：0)

```cpp
#include<bits/stdc++.h>
using namespace std;
bool ac(int n)//定义函数，判断质数
{
	if(n<2) return false;//小于2的不是质数
	for(int i=2;i*i<=n;i++)//检验到一个数的平方根就够了，时间会快很多，要不然会TLE
	 if(n%i==0) return false;
	return true; 
}
int main(){
    int n,k;
    bool t=1;
    cin>>n>>k;//输入
    for(int i=2;i<=n-k;i++) 
        if(ac(i)&&ac(i+k))//调用函数判断质数
        {
            cout<<i<<" "<<i+k<<endl;
            t=0;//特殊标记t（用true，false也可以的）
        }
    if(t)cout<<"empty";//依照题意输出即可
    return 0;
}

这道题就是用了一个判断质数函数，只要仔细一点就能够AC的！
```

---

## 作者：HPXXZYY (赞：0)

比较简单，难点：判断素数

判断素数也比较简单

一个好习惯：把sqrt用一个数保存

好处：1、提高速度  2、降低出错率

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
bool jub(int m){
    int k=sqrt(m),i;
    for(i=2;i<=k;i++)
    if (m%i==0) return 0;
    return true;
}
int n,m,i,f=1;
int main(){
    scanf("%d%d",&n,&m);
    for(i=2;i<=n;i++){
        if (i+m>n) break;
        if (jub(i)&&jub(i+m)){
            printf("%d %d\n",i,i+m);
            f=0;
        }
    }
    if (f) puts("empty");
    return 0;
}
```
杜绝复制copy

---

## 作者：Mr_浓氨 (赞：0)

这道题，我竟然用了一个叫做python3的东西来A这道题，竟然成功了，也帮助我加深了对python的理解，这道题首先用线性筛（虽然我是欧拉筛但没什么区别），然后直接枚举复杂度O（N）；

下面，QAQ，晒代码了;

```python
a,b = map(int, input().split())
n=int(a);
k=int(b);
c=[1];
bb=[1];
for i in range(2,n+5):
    c+=bb;
for i in range(2,n+1):
    if c[i]==1:
        for j in range(2,n+1):
            if i*j>n:
                break;
            c[i*j]=0;
sum=int(0);
for i in range(2,n):
    if i+k>n:
        break;
    if c[i]==1 and c[i+k]==1:
        print(i,i+k);
        sum=sum+1;
if sum==0:
    print("empty");
```

不知道能不能过，QAQ

---

## 作者：ricky_lin (赞：0)

### 我看了看楼下的大佬们的代码根本就看不懂，觉得还是我的好理解
#### 我用暴力解决这道题但是又在有些地方投机取巧了一下
##### 下面是我的代码：
```cpp
#include<iostream>//cin,cout必备
using namespace std;
int n,k;
bool a;//判断有没有
bool p(int num)//判断是不是质数
{
	for(int i=2;i*i<=num;i++)
		if(num%i==0) return false;//返回false,意思是:不是质数
	return 1;//否则,返回true,意思是:是质数
}
int main()//主函数
{
	cin>>n>>k;//输入
	if(p(2+k))//2是唯一的偶质数所以先判断2+k是不是质数
		cout<<2<<" "<<2+k<<endl;a=1;//输出加设置状态为真，意思为有满足条件的素数对
	for(int i=3;i+k<=n;i+=2)//判断奇数
	{
		if(p(i))//判断比较小的数
//如果两个数一起判断就会判断太多次有可能超时但我没试过QWQ
			if(p(i+k))//判断比较大的数
				cout<<i<<" "<<i+k<<endl;a=1;//输出加设置状态为真，意思为有满足条件的素数对
	}
	if(!a) cout<<"empty";//没有则输出"empty"
    while(1);//反抄袭
	return 0;
}
```

---

## 作者：maorui_cow (赞：0)

楼下的各位都把题想难了。此题只需从1——n暴力枚举即可，代码如下
```
#include<bits/stdc++.h>
using namespace std;
int zs(int a)//判断质数
{
	int i;
	for(i=2;i*i<=a;i++)//这里用的是判质数的优化，不需要循环到a
	{
		if(a%i==0)
		{
			return 0;
		}
	}
	return 1;//返回0或1判断正误
}
int main()
{
	int i,n,k,bj=0;
	scanf("%d%d",&n,&k);
	for(i=2;i<=n-k;i++)//这里只要循环到n-k，因为n-k+k即为n，就是最大限度
	{
		if(zs(i)==1&&zs(i+k)==1)//如果i和i+k都是质数就输出
		{
			printf("%d %d\n",i,i+k);
			bj=1;
		}
	}
	if(bj==0)//如果一次也没有满足则输出empty
	{
		printf("empty\n");
	}
	return 0;
}

```

---

## 作者：YWY_wys (赞：0)

#题意

-  让你找到n以内差为k的数对，

#题解

- 那么处理n以内的素数，获得一个isprime的bool数组和一个素数数组，遍历一遍素数数组每次，查询此素数+k是否为素数（利用isprime数组可做到O（1）的查询）

#复杂度O（n）

##题外话

-这里提供了一种线性素数筛——欧拉筛，见代码中的euler（）函数

**-------**

-代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=10005;
int n,k,cnt;
int pri[maxn];//没有maxn个 但是.......懒！！ 
bool isp[maxn];
void euler(int x){//欧拉筛
    memset(isp,1,sizeof isp);
    isp[0]=isp[1]=false;
    for(int i=2;i<=x;i++){
        if(isp[i]) pri[++cnt]=i;
        for(int j=1;j<=cnt;j++){
            int k=i*pri[j];
            if(k>x) break;
            isp[k]=false;
            if(i%pri[j]==0) break;
        }
    }
} 
bool print(){
    int num=0;
    for(int i=1;i<=cnt;i++){
        int sec=pri[i]+k;
        if(sec>n) break;
        if(isp[sec]) printf("%d %d\n",pri[i],sec),num++;
    }
    if(!num) printf("empty");
}
int main(){
    scanf("%d%d",&n,&k);
    euler(n);
    print();
} 
```

---

## 作者：wangweiba (赞：0)

#模拟

###题目的意思就是在N范围内找素数对，让两数的差=k如果有多对一起输出啊！先在范围内找素数，如果是素数在给它加上k如果还是素数就输出然后接着找，边找边做记号，找到记号为1，没找到为0，最后再判断记号的值，如果为0输出empty，数据较小不会爆！~~因为输出没有换行而提交N次的人写~~

```cpp
var n,s,i,j,x:longint;
    f:array[1..100000] of boolean;
begin
  read(n,s);
  for i:=1 to n do f[i]:=true;
  f[1]:=false;
  for i:=2 to n do 
    if f[i] then for j:=2 to n div i do f[i*j]:=false;
  for i:=1 to n-s do if (f[i])and(f[i+s]) then begin
    x:=1;
    writeln(i,' ',i+s);
  end;
  if x<>1 then writeln('empty');
end.

```

---

## 作者：Demons (赞：0)

如果定义i为第一个数，i+k为第二个数，那么这个题的实质是令i和i+k同时是素数

同时满足i>=2，（0和1都不是素数，从2开始找），i+k<=n

数据规模较小，如果加一些优化用普通的素数判断也能过，但这里将要用筛法筛素数


普通筛法：在范围n内的每个非负整数p(显然p要大于等于2才行)，删除2p,3p,4p....（这些数一定是合数）

用这个思想，加上一个标记数组，就能写出下面的筛法程序



```cpp
memset(vis,0,sizeof(vis));//初始化标记数组
vis[0]=vis[1]=1//先标记考虑不到的情况
for(int i=2;i<=n;i++)
    for(int j=i*2;j<=n;j+=i)vis[j]=1//标记合数为1
```
这样数组中值为1的数据的编号就是合数，素数就是值为0的编号，这样就能判断素数
这个筛法程序的时间复杂度小于nlogn，是书上的结论，理论上在10^6范围内的所有素数都可以很快的用这个代码生成，对于本题已经足够

但追求一下极限，因为一些合数被筛了很多次，所以继续优化

假定抽出来的数p就是一个素数，减少重复筛的次数，实现这个假设的方法就是第一层循环时判断i是不是素数，因为筛法是从前往后筛，能做到这一点

内层循环也可以不从i\*2开始，从i\*i开始，之前的合数已经在更之前就筛掉了，所以有了一份更加高效的代码


```cpp
memset(vis,0,sizeof(vis));//初始化标记数组
vis[0]=vis[1]=1;
int m=sqrt(n);
for(int i=2;i<=m;i++)//i*i＜n，所以上界到sqrt(n)即可
    for(int j=i*i;j<=n;j+=i)vis[j]=1//标记合数为1
```
这个筛法更加的高效.下面就是用这个筛法完成的程序


```cpp
#include "cstdlib"
#include "iostream"
#include "cstdio"
#include "math.h"
#include<cmath>
#include <algorithm>
#include "math.h"
using namespace std;
int p[10005];
int main()
{ //筛法部分
    memset(p, 1, sizeof(p));
    p[0] = p[1] = 0;
    int m = 100;//直接手动算了sqrt(n)
    for (int i = 2; i <= m; i++)if (p[i])
        for (int j = i*i; j <= 10000; j += i)p[j] = 0;//和刚才不太一样，标记0为合数，本质是一样的
    int n, k;
    cin >> n >> k;
    int ma = n - k;//i+k<=n，所以i的上界是n-k
    int flag = 0;//判断是否有输出，没有就输出empty
    for (int i = 2; i <= ma; i++)
    {
        if (p[i] && p[i + k]){ cout << i << " " << i + k << endl; flag = 1; }//如果i和i+k都是质数，那么就可以输出
    }
    if (!flag)cout << "empty";
    return 0;
}
```

---

## 作者：lizehan888 (赞：0)

for pascal初学者（大佬勿看）

1.筛法求素数

由于n<=10000,时间不会爆

2.枚举

esay!

```cpp
var
  f:array[2..10001]of 0..1;
  i,j,n,k,t:longint;
begin
  readln(n,k);
  for i:=2 to n do//筛法好
      if f[i]=0 then 
          for j:=2 to n div i do
            f[i*j]:=1;
  for i:=2 to n-k do
   //……
   //自己想
  if t=0 then writeln('empty');
end.
```

---

## 作者：Tom_com (赞：0)

    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n,k,e=0;                     //e标记有没有满足条件的质数对
    int i,j,h=0;
    int o=0;
    int a[10000];
    cin>>n>>k;
    for(i=2;i<10000;i++)                                   //判断10000内质数
    {
        o=0;
        for(j=2;j<=sqrt(i);j++)
            if(i%j==0)  o++;
        if(n<i)
            break;
        if(o==0)
        {
            h++;
            a[h]=i;
        }
    }
    for(i=1;i<=h;i++)                           //满足条件就输出
        for(j=1;j<i;j++)
            if(a[i]-a[j]==k)
            {
                cout<<a[j]<<" "<<a[i]<<endl;
                e++;
            }
            if(e==0)                                        //没有就输出empty
                cout<<"empty";
    return 0;    
}
```

---


# 正整数序列

## 题目描述

kkk制造了一个序列，这个序列里的数全是由正整数构成的。你别认为她的数列很神奇——其实就是1, 2, …, n而已。当然，n是给定的。kkk的同学lzn认为0是一个好数字（看上去很饱满有木有），所以他机智的趁kkk不在把这个序列全变成了0（其实只是准备窝）~

可是kkk突然回来了！于是lzn的计划破灭了。但是他并不甘心，就和kkk说：我可以每次从这个序列中选取一些数，然后一起减去一个相同的数（当然也是正整数）。然后经过有(wu)限(qiong)次这样的操作后，这个序列就可以全变成0。

kkk当然不信咯，于是lzn就求出了他最少要做几次这样的操作，才能使这个序列全部变成0。


## 说明/提示

1<=n<=10^9


## 样例 #1

### 输入

```
2```

### 输出

```
2```

# 题解

## 作者：Alex_Wei (赞：155)

Upd on 2020.7.29：修正 Latex。

---

#### 所有正整数都可以被表示为 $2$ 的次方相加的形式。

例如 : 

$10=2^1+2^3$。

$24=2^3+2^4$。

$59=2^0+2^1+2^3+2^4+2^5$。

$127=2^0+2^1+2^2+2^3+2^4+2^5+2^6$。

通过观察，我们可以发现:

#### 所有正整数都可以被拆成不大于 $\log_2 n+1$ 个互不相同的 $2$ 的次方相加。

解决这个题目主要就是根据这个定理。

当 $n=8$ 时，序列是这样的:

$1\quad 2\quad 3\quad 4\quad 5\quad 6\quad 7\quad 8$

把这个序列的所有数按照上面的方法表示出来。

$2^0\quad 2^1\quad 2^0+2^1\quad 2^2\quad 2^0+2^2\quad 2^1+2^2\quad 2^0+2^1+2^2\quad 2^3$

#### 这样操作的方法就一目了然了吧？

Step 1：将所有 " $2^0$ " 减去，得到序列：

$0\quad 2^1\quad 2^1\quad 2^2\quad 2^2\quad 2^1+2^2\quad 2^1+2^2\quad 2^3$。

Step 2：将所有 " $2^1$ " 减去，得到序列：

$0\quad 0\quad 0\quad 2^2\quad 2^2\quad 2^2\quad 2^2\quad 2^3$。

Step 3：将所有 " $2^2$ " 减去，得到序列：

$0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 2^3$。

$step4$ : 将所有 " $2^3$ " 减去，得到序列：

$0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 0$。

这样，我们就把这个序列里的所有数全部变成了 $0$。

总共 $\log_2 n+1=\log_2 8+1=3+1=4$ 次操作。

#### 所以，对于所有的 $n$ ，操作的次数为 $\log_2 n+1$。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    cout<<(int)log2(n)+1;
    return 0;
}
```

求赞 (〃'▽'〃) 。

---

## 作者：sunyufei (赞：14)

包含贪心。

如本来序列1,2,3,4,5,6,7,8,9;

可将a[i]>=5的全-5，得1,2,3,4,0,1,2,3,4

再将a[i]>=3的全-3，得1,2,0,1,0,1,2,0,1

再将a[i]>=2的全-2，得1,0,0,1,0,1,0,0,1

最后将a[i]>=1的全-1，得0,0,0,0,0,0,0,0,0

共4次。

于是发现，我们可以这样操作，每次找到当前序列中最大的数maxn，

将所有a[i]>=maxn/2+1的全减maxn/2+1,直到序列全为零。

通过找规律，可得：当序列长度为n时，最少需log2(n)+1次操作；

于是简洁的代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    int ans=log10(n)/log10(2)+1;//通过换底公式求log2(n)+1
    printf("%d",ans);
    return 0;
}
```

---

## 作者：C_Cong (赞：13)

其实为什么要递归，直接整除除就好了

规律仔细观察一下，答案其实是 a/2 ans次后等于0

## 附上代码QWQ~~~

------------

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long ans=0,a,b,c;
    cin>>a;
    if(a==1)/*特判*/
    {
        cout<<-1<<endl;
        return 0;
    }
    while(a/2!=0)
    {
        ans++;
        a=a/2;
    }
    cout<<ans<<endl;/*输出*/
}
```

---

## 作者：shadowice1984 (赞：10)

蛤，其实不用log就行的

模拟一下就好

把n如果是奇数就-1除2；偶数直接除2；

这样的操作次数，奏是结果~\(≧▽≦)/~啦啦啦；

```cpp
#include<stdio.h>
using namespace std;
int n;int res=0;
void divide(int x)
{
    if(x==0)return;
    res++;
    if(x%2==1)x-=1;
    x/=2;
    divide(x);
}
int main()
{
    scanf("%d",&n);
    divide(n);
    printf("%d",res);
    return 0;
}

```

---

## 作者：sermoon (赞：5)

把spirit dalao（！）和本蒟蒻的想法大致描述一下


本蒟蒻想法同楼下一致，

给楼下补个最优性证明：

定义 mid = (1 + n) / 2

如果我们选择一个数a（a < mid）

那么序列就分为 1 - a 和 a - mid两段

相减后最优为 1 - a和 1 - n - mid

但因为 a < mid

而取 mid 相减后为1 - mid 和 1 - mid

因此最大的数（n）减小的幅度没有取 (1 + n) / 2时大

而当 a > (1 + n) / 2 时

证明是类似的


spirit dalao（！）想法：

把1 - n看作二进制数

如 n = 5:

0001 0010 0011 0100 0101

每一次某些数减去当前（二进制下）最高位的权值

如相减后变为：

0001 0010 0011 0000 0001

再相减

0001 0000 0001 0000 0001

再相减

0000 0000 0000 0000 0000

这个想法还是很妙的。

orz dalao

这个显然是log2的操作次数。


下面


```cpp
#include <cstdio>
using namespace std;
int n, ans;
int main() {
    scanf("%d", &n);
    printf("%d", log2n + 1);
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：3)

贪心+数学，没什么好说的。

首先，把每个数二进制表示：

例如$10$就是$(1010)_2$

然后对于每一位，所有这一位是$1$的数就减掉这一位位权。

$[\operatorname{log}_2n]+1$次就能减完。

**下说明这是最小次数。**

首先，减的顺序没有影响，所以可以认为是无序。

设减了$k$次，每次减$w_k$

**一个数$m$要想被这$k$次减到0，当且仅当：**

存在$f_1,f_2,...,f_k$使得

$\sum_{i=1}^k{w_i\times f_i}=m$

其中$f_i$为$1$或$0$,表示第$i$次减时这个数减没减。

**由于单个$f_i$只有2种取值，所以$m$至多有$2^k$种取值。**

$m$要遍历$1$到$n$,而且$f_i$全部取$0$时一定能取到$0$.

**所以$n+1\le 2^k$**.

**所以$k>\operatorname{log}_2{(n+1)}$**

又$k$为整数，所以变形可得$k_{min}=[\operatorname{log}_2n]+1$

**Over**

最后是代码：
```cpp
#include<stdio.h>
#include<math.h>
int main(){
    int n;
    scanf("%d",&n);
    printf("%d\n",(int)log2(n)+1);
    return 0;
}
```

---

## 作者：dfydada⚡⚡⚡ (赞：3)

题解上有位大佬的数学公式我并不是很懂，反正也能AC。我还是喜欢非公式的写法（以为看的懂）。

数学公式代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=500000+10;
int n;
int ans;
int main()
{
	cin>>n;
	ans=log10(n)/log10(2)+1;
	cout<<ans;
	return 0;
}

```

下面是非数学公式：

通过打表唯一要输出-1的只有当n为1的时候。
所以只要特判一下就好了。

其余的通过打表发现只要一直把n除于2直到为0位置，每除一次累加器就增加。

最后输出累加器就可以了。

如果有什么不明白，也可以自己去打个表找找规律。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int n;
int ans;
int main()
{
    cin>>n;
    if(n==1)
    {
        cout<<-1;
        return 0;
    }
    while(n)
    {
        ans++;
        n=n/2;
    }
    cout<<ans;
    return 0;
}

```


---

## 作者：丿王者之路 (赞：3)

看来一下其他的题解好像都很6的样子，这里蒟蒻是一个个计算然后找的规律>\_<；

e.g.               n=1  2-3 4-7  8-15  16-31......

最小步数分别是 1    2     3     4         5

然后这就很好写了。

参考代码：















































































```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n; 
int main()
{
    scanf("%d",&n);
    int k=1,ans=1;
    while(k<=n)
    {
        ans++;
        k+=(k+1); 
    }
    printf("%d",ans);
}   
我是sb
```

---

## 作者：户山香澄 (赞：2)

通过找规律，发现长度为n的序列最少需要log2(n)+1次操作（和楼下的结论一样）。

但是我要吐槽楼下的syf dalao：您真的不知道C++有log2么？？？

换底公式是好，但是没有直接用方便啊。。。

顺便说一句由于某些原因n=1时会挂，所以加了一个特判。

上代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    
    int n;
    cin>>n; 
    if (n==1) cout<<1<<endl;
     else cout<<(int)log2(n)+1<<endl;
    
    return 0;
}
```

---

## 作者：nydzsf_qwq (赞：1)

**看到很多篇题解都没有给出为什么答案不能比 $\lfloor\log_{2}{n}+1\rfloor$  小，所以我打算写一下这个结论的证明**

考虑 $0$、$1$、$\cdots$、$n$ 这 $n+1$ 个数，目标就是把所有数均变为 $0$，最初有 $n+1$ 种数字。

假设一次操作前还有 $k$ 种数，则在一次操作后**至少**还有 $\lfloor\dfrac{k}{2}\rfloor$ 种数。

因此将所有数均变为 $1$ 种数**至少**需要 $\lceil\log_{2}{(n+1)}\rceil$ 次，也就是 $\lfloor\log_{2}{n}+1\rfloor$ 次。

接下来证明为什么 $\lfloor\log_{2}{n}+1\rfloor$ 次一定可行。

$n$ 的二进制表示共有 $\lfloor\log_{2}{n}+1\rfloor$ 位，第 $i$ 次将所有二进制从后往前第 $i$ 位为 $1$ 的所有数减去 $2^{i-1}$，这样操作就能通过 $\lfloor\log_{2}{n}+1\rfloor$ 次操作将所有数变为 $0$。

因此结果一定为 $\lfloor\log_{2}{n}+1\rfloor$。

### Code:

```c++
#include<bits/stdc++.h>
using namespace std;
int n;
int main() {
    scanf("%d",&n);
    if(n==1) printf("1\n");
    else printf("%d\n",int(log2(n))+1);
    return 0;
}
```



---

## 作者：bym666 (赞：0)

# P3152 正整数序列
这道题目的算法标签是数论和递归。话说这道题要递归干什么？找找规律很容易AC的。这道题规律很简单，就是n一直除以2，一直除到0，再输出除的次数就可以AC了。

废话不多说，上代码（此处自带音效：当当当当）：
```
#include <bits/stdc++.h>//万能头文件 
using namespace std;
long long ans,n;
int main()
{
    cin>>n;//输入 
    if(n==0)//记得特判，否则可能会错 
    {
        cout<<-1;//因为无解，所以输出-1 
        return 0;//此处一定要结束程序 
    }
    while(n/2!=0)
    {
        ans++;
        n/=2;
    }
    cout<<ans+1;//记得加一，否则全WA不怪我没说 
    return 0;//完美结束 
}
```

---

## 作者：mengdai (赞：0)

竟然没有人发题解,好吧。那我来一发吧,这题很水。。。

直接递归求解f(n/2)+1;n==1的时候返回1

恩，大概就这样吧

接下来举个例子吧

设n==6如下，1 2 3 4 5 6 那么我们 4 5 6都减去3

变成了1 2 3 1 2 3,恩，想到了，其实两个1,2,3是可以看为合并在一起的

那么接下来就是求解f(3)了，扩大范围可得出f(n)=f(n/2)+1



---


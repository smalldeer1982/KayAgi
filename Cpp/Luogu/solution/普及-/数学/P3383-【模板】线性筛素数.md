# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数  
提示：如果你使用  `cin` 来读入，建议使用 `std::ios::sync_with_stdio(0)` 来加速。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# 题解

## 作者：学委 (赞：1148)

*2020-02-01 更新*

想要快速地筛出一定上限内的素数？

下面这种方法可以保证范围内的每个合数都被删掉（在 bool 数组里面标记为非素数），而且任一合数只被：

**“最小质因数 × 最大因数（非自己） = 这个合数”**

的途径删掉。由于每个数只被筛一次，时间复杂度为 $O(n)$。

# 欧拉筛

先浏览如何实现再讲其中的原理。
___

## 实现

```cpp
#include <cstdio>
#include <cstring>

bool isPrime[100000010];
//isPrime[i] == 1表示：i是素数
int Prime[6000010], cnt = 0;
//Prime存质数

void GetPrime(int n)//筛到n
{
	memset(isPrime, 1, sizeof(isPrime));
	//以“每个数都是素数”为初始状态，逐个删去
	isPrime[1] = 0;//1不是素数
	
	for(int i = 2; i <= n; i++)
	{
		if(isPrime[i])//没筛掉 
			Prime[++cnt] = i; //i成为下一个素数
			
		for(int j = 1; j <= cnt && i*Prime[j] <= n/*不超上限*/; j++) 
		{
        	//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数
            //当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的
			isPrime[i*Prime[j]] = 0;
            
			if(i % Prime[j] == 0)//i中也含有Prime[j]这个因子
				break; //重要步骤。见原理
		}
	}
}

int main()
{
	int n, q;
	scanf("%d %d", &n, &q);
	GetPrime(n);
	while (q--)
	{
		int k;
		scanf("%d", &k);
		printf("%d\n", Prime[k]);
	}
	return 0;
}

```
___

## 原理概述

代码中，外层枚举 $i = 1 \to n$。对于一个 $i$，经过前面的腥风血雨，如果它还没有被筛掉，就加到质数数组 $Prime[]$ 中。下一步，是用 $i$ 来筛掉一波数。

内层从小到大枚举 $Prime[j]$。$i×Prime[j]$ 是尝试筛掉的某个合数，其中，**我们期望 $Prime[j]$ 是这个合数的最小质因数 (这是线性复杂度的条件，下面叫做“筛条件”)**。它是怎么得到保证的？

**$j$ 的循环中，有一句就做到了这一点：**

```cpp
			if(i % Prime[j] == 0)
				break; 
```

$j$ 循环到 $i \mod Prime[j] == 0$ 就**恰好需要停止**的理由是：

* 下面用 $s(smaller)$ 表示小于 $j$ 的数，$L(larger)$ 表示大于 $j$ 的数。

* **① $i$ 的最小质因数肯定是 $Prime[j]$。**

    （如果 $i$  的最小质因数是 $Prime[s]$ ，那么 $Prime[s]$ 更早被枚举到（因为我们从小到大枚举质数），当时就要break）

    既然 $i$ 的最小质因数是 $Prime[j]$，那么 $i × Prime[j]$ 的最小质因数也是 $Prime[j]$。所以，$j$ 本身是符合“筛条件”的。

* **② $i × Prime[s]$ 的最小质因数确实是 $Prime[s]$。**

    （如果是它的最小质因数是更小的质数 $Prime[t]$，那么当然 $Prime[t]$ 更早被枚举到，当时就要break）
    
    这说明 $j$ 之前（用 $i × Prime[s]$ 的方式去筛合数，使用的是最小质因数）都符合“筛条件”。

* **③ $i × Prime[L]$ 的最小质因数一定是 $Prime[j]$。**
	
    （因为 $i$ 的最小质因数是 $Prime[j]$，所以 $i × Prime[L]$ 也含有 $Prime[j]$ 这个因数（这是 $i$ 的功劳），所以其最小质因数也是 $Prime[j]$（新的质因数 $Prime[L]$ 太大了））
    
    这说明，如果 $j$ 继续递增（将以 $i × Prime[L]$ 的方式去筛合数，没有使用最小质因数），是不符合“筛条件”的。

*小提示：*

*当 $i$ 还不大的时候，可能会一层内就筛去大量合数，看上去耗时比较大，但是由于保证了筛去的合数日后将不会再被筛（总共只筛一次），复杂度是线性的。到 $i$ 接近 $n$ 时，每层几乎都不用做什么事。*

建议看下面两个并不复杂的证明，你能更加信任这个筛法，利于以后的扩展学习。

## 正确性（所有合数都会被标记）证明

设一合数 $C$（要筛掉）的最小质因数是 $p_1$，令 $B = C / p_1$（$C = B × p_1$），则 $B$ 的最小质因数不小于 $p_1$（否则 $C$ 也有这个更小因子）。那么当外层枚举到 $i = B$ 时，我们将会**从小到大**枚举各个质数；因为 $i = B$ 的最小质因数不小于 $p_1$，所以 $i$ 在质数枚举至 $p_1$ 之前一定不会break，**这回**，$C$ 一定会被 $B × p_i$ 删去。

**核心：亲爱的 $B$ 的最小质因数必不小于 $p_1$。**

例：$315 = 3 × 3 × 5 × 7$，其最小质因数是 $3$。考虑 $i = 315 / 3 = 105$ 时，我们从小到大逐个枚举质数，**正是因为** $i$ 的最小质因数**也**不会小于 $3$（本例中就是 $3$），所以当枚举 $j = 1 (Prime[j] = 2)$ 时，$i$ 不包含 $2$ 这个因子，也就**不会break**，直到 $Prime[j] = 3$ **之后**才退出。

*当然质数不能表示成“**大于1的某数×质数**”，所以整个流程中不会标记。*

## 线性复杂度证明

注意这个算法一直使用“某数×质数”去筛合数，又已经证明一个合数一定会被它的最小质因数 $p_1$ 筛掉，所以我们**唯一要担心的就是同一个合数是否会被“另外某数 × $p_1$ 以外的质数”再筛一次导致浪费时间**。设要筛的合数是 $C$，设这么一个作孽的质数为 $p_x$，再令 $A = C / p_x$，**则 $A$ 中一定有 $p_1$ 这个因子**。当外层枚举到 $i = A$，它想要再筛一次 $C$，却在枚举 $Prime[j] = p_1$ 时，因为 $i \mod Prime[j] == 0$ 就退出了。因而 $C$ 除了 $p_1$ 以外的质因数都不能筛它。

**核心：罪恶的 $A$ 中必有 $p_1$ 这个因子。**

例：$315 = 3 × 3 × 5 × 7$。首先，虽然看上去有两个 $3$，但我们筛数的唯一一句话就是
```cpp
			isPrime[i*Prime[j]] = 0;
```
所以，$315$ 只可能用 $105 × 3$ 或 $63 × 5$ 或 $45 × 7$ 这三次筛**而非四次**。然后，非常抱歉，后两个 $i = 63, i = 45$ 都因为贪婪地**要求对应的质数** $Prime[j]$ 为 $5$ 、$7$，而**自己被迫拥有** $3$ 这个因数，因此他们内部根本枚举不到 $5$ 、$7$，而是枚举到 $3$ 就break了。

以上两个一证，也就无可多说了。

___

更新日志：

2019-02-22 原理简化；用词修改或订正。

2019-04-02 一些用词更准确；加入更多括号内的注释，减少回看上文的需要。

2020-02-01 题面修改了，补充一下答案输出。

---

## 作者：Lylighte (赞：141)

题意:「查找第 $k$ 小的质数」。  
这需要~~打表~~生成质数数组（`prime[i]`表示第 $i$ 个质数）。  
***  
如下是一般的筛法(**埃氏筛**)：  
```cpp
//生成不大于 n 的所有质数
bool numlist[100000001];
int prime[20000001], cnt;
void work(int n){
	for(int i=2; i<=n; i++){
		if(numlist[i]==false){
			prime[++cnt] = i ;
			for(int j=i; i*j<=n; j++)
				numlist[i*j] = true;
		}
	}
	return;
}
```
埃氏筛的思想是：要想得到 $n$ 以内的质数，就要把不大于 $\sqrt n$ 的质数的倍数全部剔除，剩下的就是质数。从 $2$ 开始，把 $2$ 的倍数（不包括本身）标记为合数，然后向后枚举，查到一个未标记为合数的，就把它的倍数（不包括本身）标记为合数。以此类推，查到 $n$ 为止。  
有一个小优化，把 $t$ 的倍数标记为合数时，不是从 $2t$ 开始，而是从 $t^2$ 开始（因为小于 $t^2$ 的 $t$ 的倍数在枚举到 $t$ 前就被标记过了）。  
当然，埃氏筛效率还是低了些。例如一个数 $24$，它会被 $2$, $3$, $4$ 三个数标记，这就重复了两次，更大的数同理。时间复杂度 $O(n\log\log n)$，对于 $10^8$ 的数据，会超时。  
所以，用这种方法提交，会爆零（我是这样的）。
*** 
那么，现在要避免重复筛，要用到另一种筛法：**欧拉筛**。  
先上代码：
```cpp
bool numlist[100000001];
int prime[20000001], cnt;
void work(int n){
	for(int i=2; i<=n; i++){
		if(numlist[i]==false)
			prime[++cnt] = i ;
		for(int j=1; j<=cnt&&i*prime[j]<=n; j++){
			numlist[i*prime[j]] = true ;
			if(i%prime[j]==0)
				break;
		} 
	}
	return;
}
```
避免重复筛，应找到筛合数的一种原则：这个合数只会被它的**最大非自身因数**（对应最小质因数）筛。这样能保证每个合数只会被筛一次。  
（*运行过程*）从 $2$ 开始，$2$ 加入 prime 数组，再从小到大枚举质数（现在只有 $2$），筛掉质数与 $2$ 的乘积（$4$ 被筛掉）。  
到了 $3$，$3$ 加入 prime 数组，从小到大枚举质数（此时有 $2$,$3$），筛掉质数与 $3$ 的乘积（$6$,$9$ 被筛掉）。
到了 $4$，$4$ 没加入 prime 数组，枚举质数（有$2$,$3$），筛掉 $8$ 后，因为 $4\bmod2=0$，触发退出条件。（不触发，就会筛掉 $12$，而 $12=2\times 2 \times 3$，又会被 $2$ 和 $6$筛一次）  
以此类推，可做出一张表：  
  

|$i$ 的值  |质数表  |筛去的数  |
| :----------- | :----------- | :----------- |
|2  |2  |4  |
|3  |2, 3  |6, 9  |
|4  |2, 3  |8  |
|5  |2, 3, 5  |10, 15, 25  |
|6  |2, 3, 5  |12  |
|7  |2, 3, 5, 7  |14, 21, 28, 35  |
|$\cdots$  |$\cdots$  |$\cdots$  |
每个质数只被筛一次，复杂度变为 $O(n)$ ，可以AC。  
***
2020/02/01	写完。  
2020/02/12	小小的修改。

---

## 作者：Theophania (赞：45)

关于欧拉筛的原理其他几篇题解已经写的很清楚了，我只做一点小小的补充：这道题需要开一个长度为 $1\times 10^8$ 的巨大数组，即便将数组类型设置为bool也需要很大的空间开销（超过110MB），而使用C++的bitset可以将空间的消耗减少到45MB左右，优化了近60%！

bitset可以近似看作bool数组，它的每个元素只占1位（bit），即一个字节（byte）的 $\frac{1}{8}$，并且可以单独访问、修改。使用bitset前需要包含头文件 `<bitset>`（当然万能头也是包含了这个的），定义bitset数组需要这样写：

```cpp
bitset<100> b;//在<>内定义bitset的元素个数，b是这个bitset的名字
```
访问和修改的操作与bool数组类似，并且bitset还有很多强大的函数，[这里](https://www.cnblogs.com/magisk/p/8809922.html)和[这里](https://www.cnblogs.com/RabbitHu/p/bitset.html)的两篇教程已经写的很详细了。

最后贴上代码：
```cpp
#include <bits/stdc++.h>
//define mian main 别直接抄
using namespace std;
inline int read()
{
    int data = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')
			ch = getchar();
    while (ch >= '0' && ch <= '9')
    {
        data = (data << 3) + (data << 1) + ch - '0';
        ch = getchar();
    }
    return data;
}
void write(int f)
{
    if (f > 9)
        write(f / 10);
    putchar(f % 10 + '0');
}
const int maxn = 1e8 + 1;
bitset<maxn> num;
vector<int> prime;//vector并没有比数组慢多少
inline void init(int n)
{
    for (int i = 2; i <= n; ++i)
    {
        if (!num[i])
            prime.push_back(i);
        for (int j = 0; j < prime.size(); ++j)
        {
            if (i * prime[j] >= n)
                break;
            num[i * prime[j]] = 1;
            if (i % prime[j] == 0)
                break;
        }
    }
}
int mian()
{
    int n = read(), q = read(), x;
    init(n);
    while (q--)
    {
        x = read();
        write(prime[x - 1]);
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：rainygame (赞：31)

> **本题非正解，仅为 $O(n \log \log n)$ 的埃氏筛法解。若想学习 $O(n)$ 的欧拉筛法解，请参考其它题解。**

首先，我们考虑如何筛出质数。我们知道，在大于 $1$ 的自然数中，不是质数就是合数，所以我们可以换个角度，考虑筛出所有的合数。

而我们又知道，合数是由若干个质数相乘得来的，所以，我们可以考虑这样的方式筛出所有的合数：

1. 如果一个数没有被标记是合数，就把它所有不超过 $n$ 的都标记成合数。（这里又有个小优化，如果从 $i^2$ 开始往后找和从 $2i$ 往后找是一样的。因为 $2i$、$3i$ 等肯定被之前的标记过了）
2. 如果它被标记了，那就不鸟它。

然后所有被标记的数都是合数，没有被标记的就是质数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100000001

int n, q, ind, k;
int prime[MAXN];
bool is_prime[MAXN];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> q;

    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i*i<=n; i++){
        if (is_prime[i]){
            for (int j=i*i; j<=n; j += i) is_prime[j] = false;
        }
    }

    for (int i=2; i<=n; i++){
        if (is_prime[i]) prime[++ind] = i;
    }

    while (q--){
        cin >> k;
        cout << prime[k] << '\n';
    }

    return 0;
}
```

它的时间复杂度为 $O(n \log \log n)$，是十分优秀的（如果不加上面的小优化就是 $O(n \log n)$ 的）。所以它通过了，但是用时约 $6.3$ s，比欧拉筛慢了许多……

这时候，我们就可以用我们的神器：`bitset` 了！

我们可以这样写：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100000001

int n, q, ind, k;
int prime[MAXN];
bitset<MAXN> is_prime;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> q;

    is_prime.set();
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i*i<=n; i++){
        if (is_prime[i]){
            for (int j=i*i; j<=n; j += i) is_prime[j] = false;
        }
    }

    for (int i=2; i<=n; i++){  // 注意不要写进上面那个循环里！
        if (is_prime[i]) prime[++ind] = i;
    }

    while (q--){
        cin >> k;
        cout << prime[k] << '\n';
    }

	return 0;
}
```

用时 $2.5$ s 通过，差不多是前面的 `bool` 数组的 $\dfrac{1}{2}$。

这样不仅可以通过本题，还可以获得比题解还要优秀 $3\sim4$ 倍的效率。但是这对欧拉筛有反作用。

---


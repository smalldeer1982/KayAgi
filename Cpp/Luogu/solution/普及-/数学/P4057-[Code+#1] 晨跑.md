# [Code+#1] 晨跑

## 题目描述

“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”


在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每$a$天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息$a-1$天，然后第$a$天继续去晨跑，并以此类推。


王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每$b$天早起跑步一次，而小针决定每$c$天早起跑步一次。


某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第$0$天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/12819.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/何昊天 命题/何昊天 验题/卢政荣

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
2 3 5
```

### 输出

```
30```

## 样例 #2

### 输入

```
3 4 6
```

### 输出

```
12```

## 样例 #3

### 输入

```
10 100 1000
```

### 输出

```
1000```

# 题解

## 作者：lrj124 (赞：43)

像我这种juruo只能发水题题解了qwq

三个数的lcm就是其中两个的lcm和第三个数的lcm

```
//压行严重【逃
#include <bits/stdc++.h>
using namespace std;
int main() {
    long long a,b,c;
    scanf("%lld%lld%lld",&a,&b,&c);
    printf("%lld",a*b*c/__gcd(b,c)/__gcd(a,b*c/__gcd(b,c)));
    return 0;
}
```

---

## 作者：Drinkkk (赞：39)

UPD on 2021.3.13。

没想到小学生时期写的题解还有人看。

思路：其实这是一道使用 $\gcd()$ 来求 $\text{lcm}()$ 的数论题。这题很显然就是求 $\text{lcm}(a,b,c)$，但是如何求出 $\text{lcm}$ 呢？我们不妨先求出 $\text{lcm}(a,b)$。我推出了 $\text{lcm}(a,b)=ab \div \gcd(a,b)$，但是求三个数的最小公倍数是不是$abc \div \gcd(a,b)/\gcd(a,c)/\gcd(b,c)$ 呢，我们可以发现，这样对于某些数据会输出一些错误的答案。但是根据我们的求两个数的最小公倍数的方法就是 $\text{lcm}(a,b)=ab/\gcd(a,b)$ 呀，有没有其他办法呢？既然求两数的最小公倍数可以这样求，那能不能够用两数的最小公倍数乘以 $c$ 再除以两数的最大公约数呢？其实这个才是正确的结论，所以我们得出：

$\text{lcm}(a,b,c)$

$=\text{lcm}(\text{lcm}(a,b),c)$

$=\text{lcm}(\dfrac{ab}{\gcd(a,b)},c)$

$=\dfrac{\dfrac{ab}{\gcd(a,b)}c}{\gcd(\dfrac{ab}{\gcd(a,b)},c)}$

下面上满分代码，同时感谢@hiuseues 的反馈~

```cpp
#include <cstdio>
long long max(long long x,long long y)
{
	return x>y?x:y;
}
long long gcd(long long x,long long y)
{
	if(!y)
	{
		return x;
	}
	else
	{
		return gcd(y,x%y);
	}
}
int main()
{
	long long x=0,y=0,z=0;
	scanf("%lld %lld %lld",&x,&y,&z);
	x=x*y/gcd(x,y),x=x*z/gcd(x,z);
	printf("%lld",x);
	return 0;
}
```

---

## 作者：shenzuxin (赞：8)

题目比较简单，就是求三个数的最小公倍数，可是我第一次提交就WA了3个点，只得了85分。

```cpp
#include<iostream>
using namespace std;
long long g(long long a,long long b)
{
  int r,t1,t2;
  t1=a;t2=b;
  while (t1%t2>0){r=t1%t2;t1=t2;t2=r;}
  return a*b/t2;
}//辗转相除法（虽然我知道gcd,但是不想用）
int main()
{
    long long  a,b,c;
    cin>>a>>b>>c;
	cout<<g(g(a,b),c);
return 0;
}
```
然后我换了一种方法，还是85分。额。。。。。

```cpp

#include<iostream>
using namespace std;
int g(long long a,long long b)
{
  int  i,t1,t2;t1=a;t2=b;
  for (i=b;i>=1;i--)if (t1%i==0&&t2%i==0)break;
  return a*b/i;
}//搜索最大公约数
int main()
{
    long long  a,b,c;
    cin>>a>>b>>c;
    cout<<g(g(a,b),c);
return 0;
}
```

再换，95分了。
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long  a,b,c,i,s=1;
    cin>>a>>b>>c;i=a+b+c;
    while (i>1){
	    i--;if(a%i==0&&b%i==0){a=a/i;b=b/i;s=s*i;}
		else if(a%i==0&&c%i==0){a=a/i;c=c/i;s=s*i;}
		else if(c%i==0&&b%i==0){b=b/i;c=c/i;s=s*i;};
}//手写短除法
s=s*a*b*c;
cout<<s;
return 0;
}
```
~~这个代码到现在我都没找到错~~

最后发现了前两个代码的错，现附上满分代码
```
//第一个
#include<iostream>
using namespace std;
long long g(long long a,long long b)
{
  long long r,t1,t2;//千万要用long long
  t1=a;t2=b;
  while (t1%t2>0){r=t1%t2;t1=t2;t2=r;}
  return t2;
}
int main()
{
    long long  a,b,c,d,e;//也要用long long
    cin>>a>>b>>c;
    d=a*b/g(a,b);e=d*c/g(d,c);//要保存结果
	cout<<e;
return 0;
}

```


------------
```cpp
//第二个
#include<iostream>
using namespace std;
long long g(long long a,long long b)
{
  long long  i,t1,t2;
  t1=a;t2=b;
  for (i=b;i>=1;i--)if (t1%i==0&&t2%i==0)break;
  return i;
}
int main()
{
    long long  a,b,c,d,e;
    cin>>a>>b>>c;
	d=a*b/g(a,b);e=d*c/g(d,c);
    cout<<e;
return 0;
}
```


---

## 作者：fallingdust (赞：8)

这题是一道很简单的最小公倍数问题，那么就来普及一下关于最小公倍数的知识点吧。（神犇勿喷，鉴于是写题解，所以就写得细一点）

首先，了解一下最大公约数——GCD。

1：辗转相除法

辗转相除法， 又名 欧几里德算法（Euclidean algorithm）

设两数为a、b(a>b)，用gcd(a,b)表示a，b的 最大公约数，r=a (mod b) 为a除以b的余数，k为a除以b的商，即a÷b=k .......r。辗转相除法即是要证明gcd(a,b)=gcd(b,r)。

第一步：令c=gcd(a,b)，则设a=mc，b=nc

第二步：根据前提可知r =a-kb=mc-knc=(m-kn)c

第三步：根据第二步结果可知c也是r的因数

第四步：可以断定m-kn与n 互质(假设m-kn=xd，n=yd (d>1)，则m=kn+xd=kyd+xd=(ky+x)d，则a=mc=(ky+x)cd，b=nc=ycd，则a与b的一个公约数cd>c，故c非a与b的最大公约数，与前面结论矛盾)，因此c也是b与r的最大公约数。

从而可知gcd(b,r)=c，继而gcd(a,b)=gcd(b,r)。

其次，了解一下最小公倍数（LCM）

假设：a=10,b=15,求他们的最小公倍数。

先质数分解：

a=2*5,b=3*5;

求他们的最小公倍数，若他们互质，则ans=a*b;

但是a,b有共同的因子（最大公约数）,所以：

ans=a*b/(gcd(a,b));

现在上代码：

首先：GCD——辗转相除：

	long long gcd(long long x,long long y){

		if (x%y==0){
			return y;
		}
		return gcd(y,x%y)；
	}
    
其次，最小公倍数——LCM：
	
	long long lcm(long long x,long long y){
		return x*y/gcd(x,y);
	}
    
注：数据原因，用long long。

原本的最小公倍数是两个数，但是，此题是三个数，也没关系，先求a,b的LCM，记为x，再求x和c的LCM，然后就结束了，输出答案。

完整代码：

	#include <iostream>
	#include <algorithm>
	#include <cstdio>
	#include <cstring>
	#include <cmath>
	using namespace std;//头文件
	
	long long a,b,c;//三个晨跑的人（周期）

	long long gcd(long long x,long long y){//辗转相除求最大公约数
		if (x%y==0){
			return y;
		}
		return gcd(y,x%y);//重点
	}

	long long lcm(long long x,long long y){//最小公倍数（用GCD求）
		return x*y/gcd(x,y);
	} 

	int main()
	{
		//freopen(".in","r",stdin);
		//freopen(".out","w",stdout);
		scanf ("%lld%lld%lld",&a,&b,&c);//读入
		long long ans=0;
		ans=lcm(a,lcm(b,c));//直接求答案
		cout<<ans<<endl;//输出
		return 0;
	}



---

## 作者：zzxzzxzzxzzx (赞：7)

###### 本蒟蒻第一次发题解（~~因为之前发的都没过~~）
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long a,b,c;//数据原因
int main()
{
	scanf("%lld%lld%lld",&a,&b,&c);
	long long gcd1=__gcd(a,b);//先求a,b的最大公约数
	long long lcm1=a*b/gcd1;//因为a*b=(a,b)*[a,b],反求出最小公倍数
	long long gcd2=__gcd(lcm1,c);//再求第三个
	long long lcm2=lcm1*c/gcd2;//同理
	printf("%lld",lcm2);//华丽丽的输出
	return 0;
} 
```
###### 代码不长，思路明显  ~~很蒟蒻~~  重在理解
###### 求过QWQ
###### 鸣谢‘土著人’

---

## 作者：爱晚亭哦 (赞：2)

化简题意：求三个数的最小公倍数。

思路：先求前两个数的最小公倍数，求出来的数再与第三个数求最小公倍数。

**注意，要用long long存储，用int后三个点会爆**

~~好像就我没用函数做这题~~

```
#include<cstdio>
int main()
{
    long long gy,gb,gy2,gb2,p,a,b,i,c;//其中gy、gy2为最大公约数，gb、gb2为最小公倍数（用long long存储，否则最后三个点会爆） 
    scanf("%lld %lld %lld",&a,&b,&c);//读入三个数 
    p=a;//进行前两个数的判断 
    if(p>b)
    {
		p=b;//判断两个数哪个小 
	}
    for(i=p;i>=1;i--)//从较小的数开始比较 
    {
    	if(a%i==0&&b%i==0)
    	{
        	gy=i;//得到前两个数的最大公约数 
        	break;//得到了就走人~~~ 
    	}
    }
    gb=a*b/gy;//得到前两个数的最小公倍数
    p=gb;//开始第二次运算 
    if(p>c)
    {
		p=c;//判断两个数哪个小 
	}
    for(i=p;i>=1;i--)
    {
    	if(gb%i==0&&c%i==0)
    	{
        	gy2=i;//得到三个数的最大公约数 
        	break;
    	}
    }
    gb2=gb*c/gy2;//得到三个数的最小公倍数 
    printf("%lld",gb2);//输出 
	//好习惯是不存在的 
}
//qwq dalao勿喷 
```

---

## 作者：天际之光 (赞：1)

本题本来打算两个两个地求最大公约数，但是我用了另一种方法~~（怕麻烦）~~，把每个数分解质因数，然后求每个因数的数量的最大值，然后将它们相乘即可。
上代码，大神勿喷：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,aa[100001],bb[100001],cc[100001],ans=1,k,ansk;
int main(){
	cin>>a>>b>>c;
	for(int i=2;i*i<=a;i++){
		if(a%i==0){
			aa[i]++;
			a/=i;
			i--;
		}
	}
	if(a!=1) aa[a]++;
	for(int i=2;i*i<=b;i++){
		if(b%i==0){
			bb[i]++;
			b/=i;
			i--;
		}
	}
	if(b!=1) bb[b]++;
	for(int i=2;i*i<=c;i++){
		if(c%i==0){
			cc[i]++;
			c/=i;
			i--;
		}
	}
	if(c!=1) cc[c]++;
	for(int i=2;i<=100000;i++){
		k=max(aa[i],bb[i]);
		ansk=max(k,cc[i]);
		for(int j=1;j<=ansk;j++){
			ans*=i;
		}
		k=0;
		ansk=0;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：_•́へ•́╬_ (赞：1)

我来教大家一个
# “一行手写gcd”
```cpp
#include<bits/stdc++.h>
#define logn long
#define rpt(n) for(register int ttxyc=0;ttxyc<n;++ttxyc)
main()
{
    register logn logn a,b,c,ans;//手残。。。
    scanf("%lld%lld",&a,&b);ans=a*b;
    for(;a%b;c=a%b,a=b,b=c);//这就是gcd
    b=ans/b;//lcm(a,b)=ab/gcd(a,b)
    scanf("%lld",&c);ans=b*c;
    for(;b%c;a=b%c,b=c,c=a);//这就是gcd
    printf("%lld",ans/c);//lcm(a,b,c)=(lcm(a,b)c)/gcd(lcm(a,b),c)
}
```
## 希望对大家有帮助~~

---

## 作者：Aehnuwx (赞：1)

~~这道题目光看看三个样例就能大概猜出来要干什么了吧。~~

简明题意就是说让你求$lcm(a, b, c)$。

我们知道：$gcd(a, b)*lcm(a, b)=ab$，那么我们可以求出$a$和$b$的最大公约数，再拿$ab/gcd(a, b)$，就可以得到$lcm(a, b)$了。

最后再按照上面的方法求出$lcm(lcm(a, b), c)$即是答案。

$code$

```
#include<cstdio>
using namespace std;
inline int gcd(long long x, long long y) {
    int r = x % y;
    if(r == 0) return y;
    return gcd(y, r);
}
int main() {
    long long x, y, z;
    scanf("%lld%lld%lld", &x, &y, &z);
    x = x * y / gcd(x, y);
    x = x * z / gcd(x, z);
    printf("%lld", x);
    return 0;
}
```

---

## 作者：kenlig (赞：1)

写个新题解qwq
首先我们来分析这个题：
```
所以王队长决定每aa 天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息a-1a−1 天，然后第aa 天继续去晨跑，并以此类推。
```
并且其他俩人也是这么个跑法
所以我们可以得知，如果要三个人相遇，其实也就是三个人一起跑，就是时间相一致的啦。
很多同学会问：那么直接a*b*c不就odk了吗？
那么我们来举个栗子（输入数据）：
```
2 3 6
```
很显然，他们是在第六天相遇，然而a*b*c=36天，直接WA掉。
所以本题已经转换成了求取三个的最小公倍数，我们可以写lcm来解决。
放代码：
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

long long gcd(long long a,long long b){
	if(b==0) return a;
	else return gcd(b,a%b);
}

long long lcm(long long a,long long b){
	return a*b/gcd(a,b);
}

int main(){
	long long a,b,c;
	scanf("%lld%lld%lld",&a,&b,&c);
	cout<<lcm(lcm(a,b),c);
	return 0;
}
```

---

## 作者：反手for循环 (赞：0)

用了**递归版二进制gcd（最大公约数）算法**。比普通递归gcd算法性能更高，更快，更强。更适合求高精度的最大公约数。（像这题）
先看看它是怎么运作的：
```cpp
递归终止条件： gcd(m,m)=m;
递归关系式：
如果m<n时：gcd(m,n)=gcd(n,m) //交换一下而已

如果m为偶数，n为偶数时：gcd(m,n)=2*gcd(m/2,n/2) 

如果m为偶数，n为奇数时：gcd(m,n)=gcd(m/2,n)

如果m为奇数，n为偶数时：gcd(m,n)=gcd(m,n/2)

如果m为奇数，n为奇数时：gcd(m,n)=gcd(n,m-n)       
```

我们会发现这个算法在不停地除于2（只要有一个数是偶数），这样会比辗转相除法好多了。

两个数的最大公倍数就是这两个数乘积除于他们的gcd。

还有一个要注意的：最后三个数据点用int 爆了，要换上long long （不仅变量要换，子程序的变量也要换，我交了两次才意识到。）

附上AC代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long a,b,c,s1;
unsigned long long s2; //long long 也行。
long long gcd(long long  m,long long n){
    if(m==n)return m;
    if(m<n) return gcd(n,m);
    if(m%2==0){
        if(n%2==0) return 2*gcd(m/2,n/2);
        else return gcd(m/2,n);
    }
    else
    {
    if(n%2==0) return gcd(m,n/2);
        else return gcd(n,m-n);	
    }
}
int main()
{
    cin>>a>>b>>c;
    s1=(a*b)/gcd(a,b);
    s2=(c*s1)/gcd(c,s1);
    printf("%lld",s2); 
    return 0;
}
```
希望管理员能让这份题解过，谢谢。

---


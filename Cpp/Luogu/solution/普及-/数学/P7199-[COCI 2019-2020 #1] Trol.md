# [COCI 2019/2020 #1] Trol

## 题目描述

Stjepan 最近在萨格勒布大学获得了数学学士学位。他的父母自然而然地为他感到骄傲，并决定给他所有不超过 $2^{60}$ 的正整数作为礼物。为了保证它们的安全，他迅速地将所有数存入了一个序列 $A$，使得 $A_i=i$。

一个妒忌他的朋友 Marin 决定做一个恶作剧：**不断地把 $A$ 中的每个元素替换为其所有数位之和，直到最终只剩下一位数。**

例如，第 $197$ 个元素的初始值为 $197$。Marin 先将这个值变为 $1+9+7=17$，然后再一次改变了它，使其变为 $1+7=8$。

Stjepan 对此极为震惊，并请求 Marin 把序列变回初始状态。不幸的是，在他正确回答 $Q$ 个询问之前，Marin 并不会如此。对于每一个询问，Stjepan 需要回答 $A$ 序列中第 $l$ 项至第 $r$ 项元素的总和。

来帮 Stjepan 回答这些询问吧！

## 说明/提示

#### 数据规模及约定

对于 $20\%$ 的数据，所有询问满足 $1 \le l_i \le r_i \le 9$。

对于 $60\%$ 的数据，所有询问满足 $r_i-l_i \le 1000$。

对于 $100\%$ 的数据，$1 \le Q \le 100$，所有询问满足 $1 \le l_i \le r_i \le 2^{60}$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #1](https://hsin.hr/coci/archive/2019_2020/contest1_tasks.pdf)  _T1 Trol_ 。**

## 样例 #1

### 输入

```
1
1 5```

### 输出

```
15```

## 样例 #2

### 输入

```
2
9 13
44 45```

### 输出

```
19
17```

## 样例 #3

### 输入

```
1
1998 2018```

### 输出

```
102```

# 题解

## 作者：Thomas_Cat (赞：29)

一些 wyy 的基础骗分的算法就不讲了，这里就简单的说说一个普通的算法：

solution：

对于 $100\%$ 的数据，如果我们使用 $\mathcal{O}(Q\times(r-l+1))$ 的算法会 TLE ，现在给出一种算法：

对于一个数 $\overline{abcd}$ 来说，我们可以令该算法为 $g(x)$ ，其实就是不断的相加：$a+b+c+d \cdots$ 加到一个 **个位数** 为止。（最后发现 $g(\overline{abcd})$ 的所有数字之和为 $g(x)\in[1,9]$）。

因此我们只需要知道：$\sum\limits_{i=1}^9 i=45$ ，因此只需要找出 $\div 9$ （取整）的数量加上额外的数量即可。

注意因为本题数据范围 $>2^{60}$ ，因此需要使用 $\texttt{long long}$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin>>n;
	while(n--) {
		long long l, r;
		cin>>l>>r;
		long long times=(r-l+1)/9;//周期统计的个数
		long long sum=times*45; 
		for(long long i=l+times*9;i<=r;i++)//计算从l之后的不完整周期的选择，注意在这里的数据是有规律可循的，因此 /9 即可
			sum+=(i-1)%9+1;	
		cout<<sum<<endl;
	}
	return 0;
}
```

复杂度为 $\mathcal{O}(q \times \dfrac{r-l-\text{次数}}{9})$

---

## 作者：hensier (赞：18)

~~洛谷题库里面终于有我的题了（虽然是一道搬运的 COCI），必须发一份题解庆祝一下。~~

这道题难度较易，主要考察了 $9$ 作为模数的特征，而且部分分也很足，适合入门。

### $\text{Solution 1: 递归}$

期望得分：$30$ 分

我们不妨使用最直接的方法，对每一个数的数字和进行求解，最后进行相加。

例：求解元素 $137$ 在若干次操作之后的结果。

先计算 $137$ 所有数位之和：$1+3+7=11$。

再计算 $11$ 所有数位之和：$1+1=2$。

这时发现 $2$ 为一位数，因此 $137$ 在操作之后的结果为 $2$。

我们发现，上述的过程一直在重复，而且规律可循。因此可以建立一个函数，不停地调用它，唯一改变的是参数。只要得到的数在我们想要的范围之内，就可以停止调用。

于是考虑编写递归函数。

`C/C++` 代码：

```cpp
#include<stdio.h>
int Q;
long long getsum(long long x)
{
    long long s=0;
    while(x)
    {
        s+=x%10;
        x/=10;
    }
    if(s<10)return s;//递归出口——为一位数时，就不再继续求解
    return getsum(s);//否则再一次调用同一函数，唯一不同的是更换参数进行求解
}
int main()
{
    scanf("%d",&Q);
    while(Q--)
    {
        long long l,r,s=0;
        scanf("%lld%lld",&l,&r);
        for(long long i=l;i<=r;i++)s+=getsum(i);
        printf("%lld\n",s);
    }
    return 0;
}
```

### $\text{Solution 2: 记忆化搜索}$

期望得分：$30$ 分

在朴素递归的过程中，很多较小的数会被重复计算。

例：分析 $27$ 和 $93456$ 在操作后的结果。

对于 $27$，操作为 $27 \to 9$。

对于 $93456$，操作为 $93456 \to 27 \to 9$。

我们发现，$27$ 被重复调用了。因此我们可以把不同参数调用函数的结果保存在数组中。如果该数组元素没有被赋过值，那么就正常计算。否则可以直接返回数组中的值。这种方法被称为记忆化搜索。

然而，在本题中，由于函数最多只调用一次自己（即拓展一次），因而优化的意义不是很大。但在每层拓展两次及以上的函数中，还是比较实用的。

由于本题的数据小于等于 $2^{60}$，故开普通的数组内存会爆掉，因此可以考虑使用 `map`。

`C/C++` 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<long long,long long>ans;//能实现任意两种类型之间的一一对应
int Q;
long long getsum(long long x)
{
    if(x<10)return x;
    if(ans.count(x))return ans[x];//ans.count(id) 返回 id 下标是否被赋值过
    long long s=0;
    while(x)
    {
        s+=x%10;
        x/=10;
    }
    return ans[x]=getsum(s);
}
int main()
{
    scanf("%d",&Q);
    while(Q--)
    {
        long long l,r,s=0;
        scanf("%lld%lld",&l,&r);
        for(long long i=l;i<=r;i++)s+=getsum(i);
        printf("%lld\n",s);
    }
    return 0;
}
```

### $\text{Solution 3: 简单数论法}$

期望得分：$30 \to 50$

时间复杂度：$\mathcal O(Q \times (r-l+1)) \to \mathcal O(Q)$

> 一个整数模 $9$ 同余它的各数位之和。

假设有一个数 $x$，其各数位之和为 $S_0$，最终结果为 $\text{ans}$。

则 $x \equiv S_0 \mod 9$。设对于 $S_i$（$i \ge 0$），其各数位之和为 $S_{i+1}$，则 $S_i \equiv S_{i+1} \mod 9$。而必定有一个整数 $i$，使得 $S_i$ 为若干次操作之后的结果。因此 $x \equiv \text{ans} \bmod 9$。

因为 $\text{ans} \lt 10$，所以我们可以得到结论：

$$
\text{ans}=
\begin{cases}
9& x \bmod 9 = 0\cr
x \bmod 9& x \bmod 9 \neq 0
\end{cases}
$$

`C/C++` 代码：

```cpp
#include<stdio.h>
int Q;
int main()
{
    scanf("%d",&Q);
    while(Q--)
    {
        long long l,r,s=0;
        scanf("%lld%lld",&l,&r);
        for(long long i=l;i<=r;i++)
        {
            if(i%9)s+=i%9;
            else s+=9;
        }
        printf("%lld\n",s);
    }
    return 0;
}
```

但是，这份代码还是只拿了 $30$ 分。这是因为，每次询问如果范围很大，那么 `for` 循环一定会超时。

接下来我们可以进行优化，使得每次询问的时间复杂度可以几乎降至 $\mathcal O(1)$。

如果 $r-l \le 9$，则可直接跑一个 `for` 循环进行求解（可参考刚才的代码）。

否则，我们可以先找到一个最小的整数 $i$，使得 $i$ 为 $9$ 的正整数倍，且 $i \ge l$。同理，再找到一个最大的整数 $j$，使得 $j$ 为 $9$ 的正整数倍，且 $j \le r$。我们再通过 `for` 循环单独处理完 $[l,i)$ 和 $(j,r]$ 区间之后，只需要处理 $[i,j]$ 区间即可。

由于 $i,j$ 均为 $9$ 的正整数倍，因此 $i,j$ 之间有 $\dfrac{j}{9}-\dfrac{i}{9}+1$ 个数是 $9$ 的正整数倍，并且模 $9$ 分别余 $1 \sim 8$ 的数各有 $\dfrac{j}{9}-\dfrac{i}{9}$ 个。

因此总和为：

$$\sum_{I=1}^8 I(\dfrac{j}{9}-\dfrac{i}{9})+9(\dfrac{j}{9}-\dfrac{i}{9}+1)=5j-5i+9$$

再加上前面 `for` 循环的结果，即可直接输出。

代码：

```cpp
// C/C++
#include<stdio.h>
int Q;
int main()
{
    scanf("%d",&Q);
    while(Q--)
    {
        long long l,r,s=0,i,j;
        scanf("%lld%lld",&l,&r);
        if(r-l<=9)
        {
            for(i=l;i<=r;i++)
            {
                if(i%9)s+=i%9;
                else s+=9;
            }
            printf("%lld\n",s);
            continue;
        }
        for(i=l;i%9&&i<=r;i++)s+=i%9;
        for(j=r;j%9&&i>=l;j--)s+=j%9;
        printf("%lld\n",s+5*j-5*i+9);
    }
    return 0;
}
```

```pascal
// Pascal
var
    q:integer;
    l,r,s,id,i,j:int64;
begin
    read(q);
    for id:=1 to q do
        begin
            s:=0;
            read(l,r);
            if r-l<=9 then
                begin
                    for i:=l to r do
                        begin
                            if (i mod 9<>0) then inc(s,i mod 9)
                            else inc(s,9);
                        end;
                    writeln(s);
                    continue;
                end;
            for i:=l to r do
                begin
                    if (i mod 9=0) then break;
                    inc(s,i mod 9);
                end;
            for j:=r downto l do
                begin
                    if (j mod 9=0) then break;
                    inc(s,j mod 9);
                end;
            writeln(s+5*j-5*i+9);
        end;
end.
```

```python
# Python 3
q = int(input())
for idx in range(q):
    s = 0
    l, r = map(int, input().split())
    i, j = l, r
    if r - l <= 9:
        for i in range(l, r + 1):
            if i % 9 != 0: s += i % 9
            else: s += 9
        print(s)
        continue
    for i in range(l, r + 1):
        if i % 9 == 0: break
        s += i % 9
    for j in range(r, l - 1, -1):
        if j % 9 == 0: break
        s += j % 9
    print(s + 5 * j - 5 * i + 9)
```

---

## 作者：luckydrawbox (赞：13)

这里你通常可以看到一个[传送门](https://www.luogu.com.cn/problem/P7199)

看见一道红题，第一直觉——**打表**

![打表](https://cdn.luogu.com.cn/upload/image_hosting/mnapv1bo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以看出，每一个数被替换到最后是$1-9$的循环，而要求第$l$项到第$r$项的和，我们可以利用前缀和推出是$sum_r-sum_{l-1}$（$sum_i$为前$i$项替换后的数字的和）。

此时，代码已经浮出水面：

```cpp
#include<bits/stdc++.h> 
using namespace std;
long long sum(long long x)//求前x项的和
{
    return x/9*45+(x%9)*(x%9+1)/2;
}
int main()
{
    int q;
    cin>>q;
    long long l,r;//本题数据达到2^60，要用long long
    for(int i=1;i<=q;i++)
    {
        cin>>l>>r;
        cout<<sum(r)-sum(l-1)<<endl;//求第l项到第r项的和
    }
    return 0;
}
```


---

## 作者：John_yangliwu (赞：6)

- ### 算法1
直接模拟，对于每一个数：

1. 若该数有两位以上，累加每个数字，令和为$sum$。否则，累加到答案
2. 对$sum$执行步骤 1

期望得分：$20pts$

---
- ### 算法2
设原数为$x$，通过推导式子得知：
$$res=\begin{cases}9\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x\mod{9}=0\\x\mod{9}\ \ \ \ \ x\mod{9}\ne0\end{cases}$$
其中$res$为对$x$进行操作的结果。

那么我们就可以枚举$(l,r)$中每一个数，通过以上公式在$O(1)$复杂度之内算出$res$，累加到最终答案中。

时间复杂度：$O(Q\times(r-l+1))$，期望得分：$30pts$

---
- ### 算法3
举个例子：

原数：$1\ \ 2\ \dots\  9\ 10\ 11 \dots\ 18$

结果：$1\ \ 2\ \dots\  9\ \ \ 1\ \ \ 2 \ \dots\ \ 9$

我们发现，结果是有周期的。

因此我们只需要算出周期个数，将它乘以$45$($1+2+\dots+9$，即每个周期的结果之和)，在加上不完整的周期就好了。

别忘了开 long long 。

时间复杂度：$O(Q)$，期望得分：$50pts$

代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int q;

int main() {
		
	cin>>q;
	while(q--) {
		ll l, r;
		cin>>l>>r;
		
		ll c = (r-l+1)/9;//完整周期个数
		ll ans = c*45; 
		
		for(ll i=l+c*9;i<=r;i++) {//计算不完整的周期
			ans += (i-1)%9+1;	
		}
		
		cout<<ans<<endl;
	}
	
	return 0;
}
```


---

## 作者：Wu_while (赞：5)

### 一、直接模拟（20分）
看到题第一想法就是直接模拟，毕竟只是一道红题。

模拟代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll unsigned long long
using namespace std;
int q;
ll l,r;
ll ans;
ll f(ll n)
{
	int r;
	int a=0;
	while(n/10!=0)
	{
		a=0;
		while(n!=0)
		{
			r=n%10;
			a+=r;
			n/=10;
		}
		n=a;
	}
	return n;
}
int main()
{
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		cin>>l>>r;
		ans=0;
		for(int j=l;j<=r;j++)
			ans+=f(j);
		cout<<ans<<endl;
	}
	return 0;
 } 
```
然而TLE，只得了[20分](https://www.luogu.com.cn/record/44726841)（这个题满分是50分）。

### 二、数论
看一下题目标签，发现是**数论**。
~~乍一看没看出来~~，于是**打表**找规律：
```cpp
#include<iostream>
#include<cstdio>
#define ll unsigned long long
using namespace std;
ll f(ll n)
{
	int r;
	int a=0;
	while(n/10!=0)
	{
		a=0;
		while(n!=0)
		{
			r=n%10;
			a+=r;
			n/=10;
		}
		n=a;
	}
	return n;
}
int main()
{
	for(int i=1;i<=100;i++)
		cout<<f(i)<<' ';
	return 0;
 } 
```
![](https://cdn.luogu.com.cn/upload/image_hosting/9tlvk1v0.png)
发现有规律，9个一循环，于是出代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll unsigned long long
using namespace std;
int q;
ll l,r;
ll ans,s;
int main()
{
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		cin>>l>>r;
		s=(r-l+1)/9;//9个一循环，s为总共的正循环数
		ans=s*45;//9个循环总和为45
		for(ll j=l+s*9;j<=r;j++)//剩下的不足一个循环的
			ans+=(j-1)%9+1;
		cout<<ans<<endl;
	}
	return 0;
 } 
```
**[AC](https://www.luogu.com.cn/record/44727296)**

蒟蒻的第一篇题解，求管理员大大通过

---

## 作者：efgh123 (赞：1)

## 题意

[传送门](https://www.luogu.com.cn/problem/P7199)

Stjepan 最近在萨格勒布大学获得了数学学士学位。他的父母自然而然地为他感到骄傲，并决定给他所有不超过 $2^{60}$ 的正整数作为礼物。为了保证它们的安全，他迅速地将所有数存入了一个序列 $A$，使得 $A_i$=$i$。

一个妒忌他的朋友 Marin 决定做一个恶作剧：**不断地把 $A $中的每个元素替换为其所有数位之和，直到最终只剩下一位数。**

例如，第$197$个元素的初始值为$197$,Marin先将这个值变为$1$+$9$+$7$=$17$,然后再一次改变了它，使其变为 $1$+$7$=$8$.

Stjepan 对此极为震惊，并请求 Marin 把序列变回初始状态。不幸的是，在他正确回答 $Q $个询问之前，Marin 并不会如此。对于每一个询问，Stjepan 需要回答$A_l$到$A_r$的总和。

## 思路

上图
![](https://cdn.luogu.com.cn/upload/image_hosting/90wrdd9h.png)
可看出：

1.对于正整数$n$,运算结果为$n$ mod 9（非0，0为9）

2.成**1，2......9，1**的顺序

公式：

头+中间+尾

即
$$
(o1+9) * (10-o1)/2+(1+o2) * (o2)/2+(((e-b)-((10-o1)+(o2))+1)/9 * 45)
$$
（$o1$指$l$  mod 9,$o2$指 $r$  mod 9,详见Code）

## Code

### C++

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	long long q;
	cin>>q;
	while(q--) {
		long long l,r;//注意2^60要用long long
		cin>>l>>r;
		int o1=l%9,o2=r%9;
		if(o1==0)o1=9;
		if(o2==0)o2=9;
		cout<<(o1+9)*(10-o1)/2+(1+o2)*(o2)/2+(((r-l)-((10-o1)+(o2))+1)/9*45)<<"\n";
	}
	return 0;
}

```

### C/C++

```c
#include<stdio.h>
int main() {
	int q;
	scanf("%d",&q);
	while(q--) {
		long long l,r;//注意2^60要用long long
		scanf("%lld%lld",&l,&r);
		int o1=l%9,o2=r%9;
		if(o1==0)o1=9;
		if(o2==0)o2=9;
		long long n=(o1+9)*(10-o1)/2+(1+o2)*(o2)/2+(((r-l)-((10-o1)+(o2))+1)/9*45);
		printf("%lld\n",n);
	}
	return 0;
}
```



---

## 作者：xingchenyu (赞：1)

### 题意
将一个 $l$ 到 $r$ 的区间中每一个数替换为各位之和，直到替换成一位数。

### 以下正经题解：

那么问题是，这个数到底是个啥

如果这个数是 
$\overline{a_n a_{n-1} \ldots a_1}$ 
这个数等于 

$\quad a_n \times 10^n + a_{n-1} \times 10^{n-1} + \ldots + a_1$

$= a_n \times 99 \ldots 9 + a_{n-1} \times 99 \ldots 9 + \ldots + a_n + a_{n-1} + \ldots + a_1$

由此得出，原数和得到的数模 $9$ 得到的结果相等，又因为最后得到的是一位数，所以最后得到的数是原数模 $9$ 

如果直接模 $9$ 然后相加，那么恭喜你 $TLE!$

只要算出整周期个数 $\times 45$ 再加上不完整周期的数就可以了
```cpp
#include<bits/stdc++.h>
using namespace std;
int q;
long long l,r;
int main(){
	cin >> q;
	for(int i = 1;i<=q;i++){
		cin >> l >> r;
		long long ans = (r-l+1)/9; //整周期数
		ans*=45;
		for(long long j = l;j<l+(r-l+1)%9;j++){
			ans+=(j-1)%9+1; // 不完整的
		}
		cout << ans << endl;
	}
} 
```


---


# 『JROI-3』田径

## 题目背景

你准备玩起 MC。

## 题目描述

你需要用栅栏框住一个长方形区域，假设这个长方形区域大小为 $a \times b$ 个像素格，则需要长为 $a+1$，宽为 $b+1$ 规模的栅栏框住这个区域。

现在你发现他的羊和牛需要**恰好** $n$ 个像素格才够生存，而你的背包里有 $m$ 个栅栏，你想知道，你用你所拥有的的栅栏是否能框出 $n$ 个像素格？

不需要用光所有栅栏，只要框出区域大小为 $n$ 个像素格的长方形即可。

注意，上面的 $a,b,n,m$ 都应是整数。

## 说明/提示

#### 样例 1 解释

第一组数据：

实测可证，无法用 $1$ 个栅栏围出 $4$ 个像素格。

第二组数据：

可以考虑围出如下 $4=1 \times 4$ 的像素格。

![](https://cdn.luogu.com.cn/upload/image_hosting/bho8z78k.png)

用下方的方式只需要用 $14$ 个栅栏即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/o8s6bz81.png)

栅栏宽为 $1+1=2$，长为 $4+1=5$，$(2+5) \times 2=14$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（30 pts）：$1\le n,m \le 10^4$，$T \leq 10^3$；
- Subtask 2（70 pts）：$1\le n,m \le 10^{8}$，$T \leq 10^3$。

----
在本题中栅栏是**抽象化**的而非具象化的，即栅栏将会**退化成一个点而非一个方格**，也就是我们可以通过**求周长的方式**求出一个栅栏框所需消耗的栅栏（如果不理解可以看看样例 1 解释）。

## 样例 #1

### 输入

```
2
4 1
4 20```

### 输出

```
Miss
Good```

# 题解

## 作者：Eason_AC (赞：19)

## Update
- $\texttt{2021.10.11}$ 修改了一处公式错误，麻烦管理重新审核一下这篇**已审核通过**文章。

## Content
你在一个无限大的格子平面上，并且有 $m$ 个长度为 $1$ 的栅栏，你需要用不多于 $m$ 个栅栏围住一个面积**恰好**为 $n$ 的区域，求是否可行。

如果你需要围住一个 $a\times b$ 的区域，你需要用长为 $a+1$，宽为 $b+1$ 的栅栏才能围住它。

**数据范围：$t$ 组数据，$1\leqslant t\leqslant 10^3$。$1\leqslant n,m\leqslant 10^8$。**
## Solution
首先引出我们小学就学过的东西：**一个长方形在一定面积下，长与宽差得越小，周长也就越小**。因此，我们由此想着求出一个长与宽差得最小的一个面积为 $n$ 的区域。

我们先假设这个面积为 $n$ 的区域是一个正方形，那么它的边长就是 $\sqrt{n}$，因此，我们不妨从 $\lfloor\sqrt n\rfloor$ 开始向下枚举每一个可能的宽，如果枚举到了一个 $\leqslant\lfloor\sqrt n\rfloor$ 的整数 $x$ 使得 $x\mid n$，那么可以直接计算出最短周长为 $2(x+\frac nx+2)$，再拿这个东西和 $m$ 比较就可以了。
## Code
```cpp
namespace Solution {
    ll n, m;

    iv Main() {
        MT {
            read(n, m);
            ll a, b;
            for(a = sqrt(n); a >= 1; --a) if(!(n % a)) break;
            b = n / a;
            ll mn = (a + b + 2) * 2;
            if(mn <= m) puts("Good");
            else puts("Miss");
        }
    }
}
```
## Advertisement
欢迎来看我扒的 R.I.P. 的谱子！

![](bilibili:BV1EU4y1w7h8)

---

## 作者：快斗游鹿 (赞：11)

本题是一道比较基础的数论题。

因为输入的 $n$  是面积，而题目中的“栅栏数”是指周长。

所以，我们要先求出长和宽。

有据可证，在面积相等的情况下，长与宽之差越小，周长就越小 （所以题目中给的样例解释并非最优解）。

就拿 $n=4$ 时来说

$4=1\times4=2\times2$

样例解释（$a=4,b=1$）：$(1+4)*2+4=14$

最优解：（$a=2,b=2$）：$(2+2)*2+4=12$

那要如何求长和宽呢？

其实只需要从 $1$ 开始，遍历到 $sqrt(n)$ 暴力求解即可，这样还能保证求得的长和宽最接近。

Q: 为什么不用遍历到 $n$?

A: 因为如果这个数能被 $i$ 整除,那他一定能被 $n/i$ 整除。

得出最为接近的一对长和宽后，就可以开始计算周长了。

公式： $(a+b)\times2+4$

注：本处 $a,b$ 指的不是最终围成的栅栏的长、宽。

AC 代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t,n,m,ii,jj;
    scanf("%d",&t);
    for(int i=1;i<=t;i++){
        scanf("%d%d",&n,&m);
        for(int j=1;j<=sqrt(n)+1;j++){
            if(n%j==0){//求长和宽
                ii=j;
                jj=n/j;
            }
        }
        if(ii*2+jj*2+4<=m)cout<<"Good"<<endl;//判断是否可以围下
        else cout<<"Miss"<<endl;
        //cout<<ii<<' '<<jj<<endl;
    }
} 
```


---

## 作者：Cripple_Abyss (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P7892)

## Description ：
- 判断能否用 $m$ 个栅栏围成 $n$ 个像素格。

## Solution :
- 我们可以先求 $n$ 个像素格最少需要多少个栅栏。

- 进而判断能否用 $m$ 个栅栏围成。

- 小学一定学过一个知识：面积相等的长方形，两边长越接近，周长越短（栅栏数越少）。

- 从 $\sqrt n$ 从大到小找到第一个 $n$ 的因数，记为 $x$。

- 最短栅栏数为 : $2((x+1)+(n/x+1))$

## Code：
```cpp
#include <cstdio>
#include <cmath>
typedef int ll;
inline void in(ll &x) {
	x=0;
	ll f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=f;
}
inline void out(ll x) {
	if (x<0) putchar('-'),x=-x;
	if (x>9) out(x/10);
	putchar(x%10+'0');
}
ll T,n,m,ans1,ans2;
int main() {
	in(T);
	while (T--) {
		in(n),in(m);
		for (ll i=sqrt(n); i; --i) 
			if (n%i==0) {
				ans1=i;
				break;
			}
		ans2=n/ans1;
		if (2*(ans1+1+ans2+1)<=m) puts("Good"); 
		else puts("Miss"); 
	}
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：4)

验题人题解。

题意很简明了，找出是否存在 $a\times b=n,2\times \left(a+1+b+1\right)\leq m$

小学奥数有一个口诀：积定和最小，也就是基本不等式的结论 $2\sqrt{ab}\leq a+b$，显然当 $\left|a-b\right|$ 最小时，$ab$ 有最小值（这个证明不用我说了吧）。

显然 $\forall p\mid n \ \ p\leq \sqrt n$.那么只需从 $\lfloor\sqrt n\rfloor$ 向下枚举因子即可，第一个枚举到的即为合适栅栏长。

在按照题意判断一下输出就好了。

---

## 作者：哈士奇憨憨 (赞：3)

# [传送门](https://www.luogu.com.cn/problem/P7892)

# 题目大意
求
$
\begin{cases}
a ×b = n\\
(a +1+b+1)×2 \le m
\end{cases}
$  是否有解

---
# 思路

根据积一定，和小差小的原理，枚举每种可能的正整数 $ a $ , $ b $ , 找到最优解，判断 $(a +1+b+1)×2 \le m$ 是否满足。
每一次找到合理的正整数就更新答案。

这里要注意：
- 枚举到 $\sqrt{n}$ 就行。
- 是判断 $(a+1+b+1)×2 \le m$ 是否有解，不是判断 $(a+b)×2 \le m$ 是否有解！
                
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
void Solve(int n,int m){
    int a = 0,b = 0;
	for(int i = 1; i * i <= n; i++){//找最优解
   //不能写成for(int i = 1; i <= n; i++)
   //因为当i > sqrt(n)时，答案会变得更劣
		if(n % i == 0){
			a = n / i,b = i;//更新答案
		}
	}
	if((a + b + 2) * 2 <= m){//判断，等同于(a + 1 + b + 1) * 2 <= m
		cout << "Good" << endl;
	}else cout << "Miss" << endl;
}
int main(){
	cin >> t;
	while(t--){
		cin >> n >> m;
		Solve(n , m);//调用函数
	}
	return 0;
}
```


---

## 作者：Hollis_Yang (赞：2)

题目意思:  
是否有一个a,b,使得:  
$a*b=n$  
$2*(a+b)+4<=m$  
对于30%的数据,我们可以使用$m$举$ab$  
把$m$然后枚举$ab$  
时间复杂度$O(m)$,显然,对于1e8的数据,肯定会TLE   
我们考虑用$n$来枚举$ab$  
因为必须要$a*b=n$,所以可以枚举$n$的每一个分解   
时间复杂度$O(\sqrt{n})$  
### AC Code   
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t,n,m,i;
	cin>>t;
	while(t--){
		bool flag=false;
		cin>>n>>m;
		for(i=1;i*i<=n;i++){
			if(n%i==0){
				if((4+2*(i+n/i))<=m){
					flag=true;
					break;
				}
			}
		}
		if(flag) cout<<"Good"<<endl;
		else cout<<"Miss"<<endl;
	}
} 
```


---

## 作者：syf2008 (赞：2)

这是一道~~水~~题

题意简述：

一个 $a \times b$ 格的像素格，则需要长为 $a+1$，宽为 $b+1$ 规模的栅栏框住这个区域。

你是否能用 $\leq m$ 个栅栏框出 $n$ 个像素格？

根据题目，我们需要尝试

以第二组数据为例：

当 $m=20$ ， $n=4$ 时，有这么两种方法

1.![](https://cdn.luogu.com.cn/upload/image_hosting/o5mgnjuq.png)

2.![](https://cdn.luogu.com.cn/upload/image_hosting/uqgvy40z.png)

推一推后，就会发现，所构造的矩形两边越接近，所需栅栏越少，所以我们可以构造一个两边最接近的矩形，算出它的边长，与m比较。

上代码：
```
#include <bits/stdc++.h>
using namespace std;
int t,n,m,a,b,f;
int main()
{
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--)
	{
		a=b=f=0;
		cin>>n>>m;
		f=sqrt(n);
		for(int i=f;i>=1;i--)//构造一个两边最接近的矩形
		if(n%i==0)
		{
			a=n/i;
			b=i;
			break;
		}
		if(2*(a+b+2)<=m)//算边长与m比较。
		cout<<"Good"<<endl;
	else cout<<"Miss"<<endl;
	}
	return 0;
}
```

---

## 作者：小小蒟弱 (赞：2)

### 思路
~~枚举暴力即可。~~

我们只要枚举长方形的边，求出另一条边的长，算出需要的栅栏，小于 $m$ ，就输出 $Good$ ，如果无论边长是多少，栅栏都不够就输出 $Miss$ ，我来踩踩本题的坑：

1. 需要的栅栏数要加上$4$个角,因此一共需要 $2\times{a}+2\times{b}+4$ 个栅栏。

2. 在枚举边长时，需要加一个时间上的小优化，让枚举的时间变成 $O(\sqrt[2]{n})$。

### $Code:$
```cpp
#include <bits/stdc++.h>
int main()
{
    int k,a,b;
    scanf("%d",&k);
    while(k--)
    {
        int f=0,n,m;
        scanf("%d%d",&n,&m);
        for(int i=1;i*i<=n;i++)//小优化
        {
            if(n%i==0)//能否作为其中一个边长
            {
                int a=i,b=n/i;//算出长宽
                if(a*2+b*2+4<=m)//加 4 个角
                {
                    f=1;
                    break;//打上标记，退出循环
                }
            }
        }
        if(f) printf("Good\n");
        else printf("Miss\n");
    }
}

```

第一篇题解，望通过$QAQ$。

---

## 作者：Da_un (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P7892)
作为月赛的第一题，还是蛮简单的。
## 思路
首先，不要被样例所迷惑，样例给出的只是一种可行的方案，但并不是最优解，最优解应是围出一个 $2\times2$ 的像素格，所需的栅栏数为 $(2+1)\times2+(2+1)\times2=12$。

接下来，因为题目中说明围成的像素格一定是一个长方形，所以可以根据长方形的周长与面积关系来做的，当这个长方形的面积一定时，构成这个长方形的不相邻的两条边差的绝对值越小，构成这个长方形的周长越小。

证明：
可以根据基本不等式 $a+b>=2\sqrt{ab}$ 推出 $(\dfrac{a+b}{2})^2>=ab$，当且仅当 $a=b$ 时等号成立。因为 $ab$ 是已经确定的值了，所以当 $a=b$ 时可以取到 $ab$ 这一最小值，此时的 $a+b$ 也一定是最小的即此时的周长也一定是是最小的，以此类推，也就推出了上面的结论。

知道了这些，剩下的也就比较简单了，可以先把输进来的面积 $n$ 开方，然后找到离开方后的数最近的整数并且保证是 $n$ 的因数即可求得最小的范围，最后求出周长即可。

具体看代码。
## code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int T;
long long l,n,m,ans;//保险
double f;//开方用
int main()
{
	scanf("%d",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		f=sqrt(n);
		l=f;
		for(int i=l;i>=1;i--)//从最近的小于等于它的数往前找
			if(n%i==0){//可以构成长方形
				ans=(i+1)*2+(n/i+1)*2;
            			//i与n/i是构成面积为n的长方形的最短的两条不相邻的边
                    	//ans算最终结果
				break;//省时
			}
		if(ans>m)//判断
			cout<<"Miss"<<endl;
		else
			cout<<"Good"<<endl;
	}
	return 0;
}
```
完结撒花~~

---

## 作者：Buried_Dream (赞：1)

这是一道月赛签到题~~可我还是想了很久~~

## 题意：

将一个面积为 $n$ 的矩形用最多 $m$ 个栅栏围起来，注意不是刚好用 $m$ 个栅栏围起来，我一开始被这里坑了好久，注意题目中给的信息，

![](https://cdn.luogu.com.cn/upload/image_hosting/ckceu4tv.png)


所以本题的思路已经确定，就是判断是否存在 $a \times  b = n $，同时      $ 2 \times (a + b + 1 + 1) <= m$;

具体就是从 $\sqrt{n}$ 开始枚举，因为在另一部分总是有一个因子和他相对，所以说从这里枚举，测试点时间限制是 $150ms$ ，这样跑足够了。


# AC Code：
```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
#include<cstring>
#define il inline
#define re register
#define inf 0x3f3f3f3f
#define maxn 100010
using namespace std;

inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-'){w = -1;}ch = getchar();}
	while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
	return s*w;
} 
int t;
int n,m;
int ans;
signed main(){
	t = read();
	for(re int i = 1; i <= t; i++) {
		int flag = 0;
		n = read(), m = read();
		for (re int k = 1; k * k <= n; k++) {
				if(n % k == 0) {//k是n的因子 
					if ((n / k + k + 2) * 2 <= m) {//判断
						flag = 1;//用来看是否有解的
						break;
					}
				}
		}
		if(flag) cout<<"Good\n";
		else cout<<"Miss\n";
	}
}

```


---

## 作者：Mortis_Vampire (赞：1)

~~这道题前面一大堆背景都是没用的~~
### 简化题意
问能否构造出一周长小于等于 $m-4$ 的面积为 $n$ 的矩形。
## 思路
我们知道，在面积相等的情况下，矩形中周长最小的是长与宽最接近的矩形。
在本题中，对于面积为 $n$ 的矩形，我们可以从 $\sqrt n$ 开始往下找，直到找到可以整除 $n$ 的宽 $a$，此时的周长（$2*({a+\dfrac{n}{a}})$）一定是最小的。判断这个周长是否满足条件即可。

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
inline int rd() {
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0')
		x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
int T,n,m;
int main() {
	T=rd();
	while(T--) {
		n=rd(),m=rd();
		int k;
		for(int i=sqrt(n); i>=1; i--)//寻找最小的周长
		if(n%i==0){k=i;break;}
		if(m>=(n/k+1+k+1)*2)puts("Good");//判断
		else puts("Miss");
	}
	return 0;
}
```


---

## 作者：BotDand (赞：0)

# $\text{Problems}$

求一根长为 $m$ 的绳子能否围出大小为 $n$ 的长方形（包括正方形）。

# $\text{Answer}$

可以枚举 $n$ 的因子。

因为 $a^{2}>(a-b)(a+b)$，所以要尽量围成一个正方形，或长和宽的差最小。

于是可以从 $\sqrt{n}$ 枚举到 $1$，如果是因子判断即可。

时间复杂度 $O(\sqrt{n})$。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n,m;
int a,b;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void work()
{
    n=read();m=read();
    for(a=sqrt(n);n%a;--a);
    b=n/a;
    if(2*(a+b+2)<=m) puts("Good");
        else puts("Miss");
}
signed main()
{
    t=read();
    while(t--) work();
    return 0;
}
```


---

## 作者：qwq___qaq (赞：0)

### Update
2022.7.18 更改了错别字（“北京”改为“背景”）
***
这道题是月赛的签到题，还是比较水的。（本题背景太长，建议 A 了再看）

其实在题目中也有提示：在本题中栅栏是**抽象化**的而非具象化的，即栅栏将会**退化成一个点而非一个方格**，也就是我们可以通过**求周长的方式**求出一个栅栏框所需消耗的栅栏。

### 【题意简述】

求用 $m$ 个栅栏能否框出 $n$ 个像素格。

下面来讲讲我自己的思路：首先，因为 $m$ 为整数，因为在周长相等的时候，长方形的面积最大（正方形看做特殊的长方形），我们可以得到在面积相等的时候，长方形的周长最小。所以本题只用枚举长和宽即可，又因为长方形具有对称性，所以我们只需枚举到 $O(\sqrt{n})$ 即可，如果在循环的过程中求出一组小于 $m$ 的栅栏数，可以直接输出 `Good`，否则如果循环结束都没找到答案，就输出 `Miss`，时间复杂度最坏 $O(T\sqrt{n})$，时限 $150$ 毫秒（大概可以跑 $1.5 \times 10^7$ 的数据），可以过。

### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t; 
bool flag;
int main(){
	scanf("%d",&t);
	while(t--){//多组数据
		flag=0;//初始化
		scanf("%d%d",&n,&m);
		for(int i=1;i*i<=n;i++){
			if(n%i)
				continue;
			int a=i,b=n/i;//a记录长，b记录宽
			if(2*(a+b)+4<=m){
				puts("Good");
				flag=1;
				break;
			}
		}
		if(!flag)
			puts("Miss");
	}
	return 0;
}
```

---

## 作者：ycw123 (赞：0)

## Description
给定矩形面积 $n$，栅栏长度 $m$，问是否存在一组 $a,b$ 使得 $a\cdot b=n \text{且}2(a+b+2) \le m$（$a,b$ 为正整数，$2(a+b+2)$ 即周长）
## Solution

在周长一定时，正方形的面积是矩形中最大的。反之，面积一定时，正方形的周长最小。

当 $n$ 是完全平方数时 $a=b=\sqrt{n}$ 周长最小；

当 $n$ 不是完全平方数时 找出差最小的一组 $a,b$ 周长最小。

这样问题就转化为了找 $n$ 的约数。

因为要找差最小的，所以从 $\sqrt{n}$ 开始递减试除，找到第一组后判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int n,m,i,j;

int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(i=sqrt(n);i>=1;i--){
			if(n%i==0) break;
		}
		j=n/i;
		if(m>=(i+j+2)*2) printf("Good\n");
		else printf("Miss\n");
	}
	
	return 0;
}
```


---

## 作者：a1ioua (赞：0)

由小学数学可知，当长方形的面积一定时，长与宽的差越大周长就越大，当长和宽相等（即正方形时）时周长最小。
因为题目要求 $a,b\in \mathbb{N}$（见题意），所以我们可以从 $\sqrt n$（$n$ 见题意）开始枚举，当枚举到整数时判断（此时 $n$ 个像素格的周长最小），与 $m$ 比较即可。  
$\text{p.s.}$ 样例解释那个周长 $14$ 不要管，是出题人用来迷惑人的。  
$\text{p.p.s}$ **多测不换行，保龄两行泪。**
```cpp
#include <bits/stdc++.h>
using namespace std;
signed solve() {
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++) {
		int n, m;
		scanf("%d%d", &n, &m);
		for (int j = sqrt(n); j >= 1; j--) {
			if (n % j == 0) {
				if (m >= (j + n / j + 2) * 2) printf("Good\n");
				else printf("Miss\n");
				break;
			}
		}
	}
	return 0;
}
signed main() { return solve(); }
```

---

## 作者：tongziyu (赞：0)

作为 $Div$ $2$ 的 $T1$，不算特别难。~~（但我还是挂了 2 次）~~


我一开始认为只要能围成一个不小于 $n$ 的像素格即可。

但是。。。被 WA 无情打脸。。。。

之后我调整了思路。


------------


### 补充结论：
当两个任意正数 $a$, $b$ 之和等于一个定值时，$ \left|a - b\right|$ 的值越小， $a$ $*$ $b$ 的值越大。

------------


我们只需从 $\sqrt{n}$ 开始，逐个向下枚举一条边的长度。若与当前枚举的边相对的另一条边的长度是整数，则判断此时的周长是否大于 $m$。若大于，则根据补充结论，往下枚举下去一定没有可行解，输出 "Miss" , 否则可行，输出 "Good"。

其实正着枚举也可以，不过倒着枚举时间会稍微优化一点。

### AC code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int n, m;
int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &n, &m);
		for (int i = sqrt(n); i >= 1; --i) 
		{
			if (n % i == 0)
			{
				int x = i, y = n / i;
				if (x + y + 2 << 1 <= m) puts("Good");
				else puts("Miss");
				break;
			} 
		}
	}
	return 0;
}
```


---

## 作者：Trafford1894 (赞：0)



小奥题石锤

### Solution

其实这题给定了一个长方形，两边为 $a, b$ （题干中没给，自己设的），$a\times b=n$，$2\times (a+1+b+1)=m$

问 $a,b$ 是否存在

可以算出长方形中 $m$ 的最小值，具体从 $\sqrt{n}$ 枚举到 $1$，找到第一个整数边长就跳出，判断能否存在。

具体如何证明？

根据小奥原理，积一定差小和小。而 $\sqrt{n}$ 如果合法一定最优，所以可以成立，且时间复杂度能够承受。

时间复杂度 $\Theta(T\sqrt{n})$

### Code

```cpp


#include <cstdio>
#include <cmath>

using namespace std;

void Calc(int num, int length) {
	for (int i = sqrt(num); i > 0; i--) {//从sqrt(n) 开始枚举
		if (num % i == 0) {//找到了最小的
		    puts((i + (num / i)) * 2 + 4 > length ? "Miss" : "Good");//最小的都不行，那就一定不行了
		    return;
		}
	}	
}

int main() {
	int t;scanf("%d", &t);
	for (int i = 0; i < t; i++) {
		int square;
		int length;
		scanf("%d%d", &square, &length);
		Calc(square, length);
	}
	
	return 0;	
}
```


---

## 作者：一只书虫仔 (赞：0)

**Subtask 1**

将 $m$ 除 $2$ 之后枚举长和宽直到乘积大于等于 $n$。

**Subtask 2**

考虑求出 $n$ 个像素格至少需要多少栅栏，积一定差小和小，因此只要长和宽趋近于 $\sqrt n$ 就可以。但是长和宽需要是整数，不过 C++ 会给你自动下取整，我们可以借这个优势，直接在 $\lfloor\sqrt n\rfloor$ 到 $1$ 枚举宽，直到能被 $n$ 整除为止，则最小的周长也就固定了，设枚举到的第一个合法宽为 $a$，则 $m$ 应满足：

$$m \in \left[2a+\frac {2n} a+4,+\infty\right)$$

最劣的复杂度是当 $n$ 为质数时的，为 $\mathcal O(\sqrt n)$。

---

## 作者：Infinity_Detail (赞：0)

一道签到题，可蒟蒻想复杂了还调了好久。。。

### 题意：
给你一个场地的面积，再给你一些栅栏，问这些栅栏够不够把场地围起来。

#### 注意，围起来是指大于等于这个场地的 周长 $ c+ 4 $ 。

### 思路：

首先找出一对可行的长和宽，可以在循环里判断：

只要 $n$ 是 $i$ 的倍数，那长和宽就是 $i$ 和 $\tfrac{n}{i}$ 。


然后判栅栏够不够，根据周长公式 $c=(a+b)×2$ ，可以得到栅栏必须大于等于 $c+4$ 也就是 $ (a+b)×2+4$ 。

但是注意到这里 $n$ 非常大，有 $1e8$ ，而又是多组数据， $t$ 又有 $1e3$ ，所以我们暴力枚举所有长和宽肯定是不行的。那怎么办呢？

枚举到 $\sqrt{n}$ 即可。

由于 $\sqrt{n} × \sqrt{n} = n$ ,而面积为 $n$ 的长和宽肯定相差越小周长越大。

而 $\sqrt{n}$ 与 $\sqrt{n}$ 相差为0 。

所以我们枚举到 $\sqrt{n}$ 完全不影响结果，而且还会把时间复杂度优化到 $O(T\sqrt{n})$。

时限是150ms，跑过这道题足够了。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m; 
bool flag=0;
int main(){
	int t;
	cin>>t;
	while(t--){
		flag=0;
		cin>>n>>m;
		for(int i=1;i<=sqrt(n);i++){
			if(n%i!=0){
				continue;
			}
			int a=i,b=n/i;
			if(2*(a+b)+4<=m){
				cout<<"Good"<<endl;
				flag=1;
				break;
			}
		}
		if(!flag){
			cout<<"Miss"<<endl;
		}
	}
	return 0;
}
```


---


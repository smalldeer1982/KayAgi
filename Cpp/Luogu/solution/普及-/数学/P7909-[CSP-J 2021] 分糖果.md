# [CSP-J 2021] 分糖果

## 题目背景

红太阳幼儿园的小朋友们开始分糖果啦！

## 题目描述

红太阳幼儿园有 $n$ 个小朋友，你是其中之一。保证 $n \ge 2$。

有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。

由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 $R$ 块糖回去。

但是拿的太少不够分的，所以你至少要拿 $L$ 块糖回去。保证 $n \le L \le R$。

也就是说，如果你拿了 $k$ 块糖，那么你需要保证 $L \le k \le R$。

如果你拿了 $k$ 块糖，你将把这 $k$ 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有**不少于** $n$ 块糖果，幼儿园的所有 $n$ 个小朋友（包括你自己）都从篮子中拿走**恰好**一块糖，直到篮子里的糖数量**少于** $n$ 块。此时篮子里剩余的糖果均归你所有——这些糖果是**作为你搬糖果的奖励**。

作为幼儿园高质量小朋友，你希望让**作为你搬糖果的奖励**的糖果数量（**而不是你最后获得的总糖果数量**！）尽可能多；因此你需要写一个程序，依次输入 $n, L, R$，并输出你最多能获得多少**作为你搬糖果的奖励**的糖果数量。

## 说明/提示

**【样例解释 #1】**

拿 $k = 20$ 块糖放入篮子里。

篮子里现在糖果数 $20 \ge n = 7$，因此所有小朋友获得一块糖；

篮子里现在糖果数变成 $13 \ge n = 7$，因此所有小朋友获得一块糖；

篮子里现在糖果数变成 $6 < n = 7$，因此这 $6$ 块糖是**作为你搬糖果的奖励**。

容易发现，你获得的**作为你搬糖果的奖励**的糖果数量不可能超过 $6$ 块（不然，篮子里的糖果数量最后仍然不少于 $n$，需要继续每个小朋友拿一块），因此答案是 $6$。

**【样例解释 #2】**

容易发现，当你拿的糖数量 $k$ 满足 $14 = L \le k \le R = 18$ 时，所有小朋友获得一块糖后，剩下的 $k - 10$ 块糖总是**作为你搬糖果的奖励**的糖果数量，因此拿 $k = 18$ 块是最优解，答案是 $8$。

**【数据范围】**

| 测试点 | $n \le$ | $R \le$ | $R - L \le$ |
|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $5$ | $5$ |
| $2$ | $5$ | $10$ | $10$ |
| $3$ | ${10}^3$ | ${10}^3$ | ${10}^3$ |
| $4$ | ${10}^5$ | ${10}^5$ | ${10}^5$ |
| $5$ | ${10}^3$ | ${10}^9$ | $0$ |
| $6$ | ${10}^3$ | ${10}^9$ | ${10}^3$ |
| $7$ | ${10}^5$ | ${10}^9$ | ${10}^5$ |
| $8$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |
| $9$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |
| $10$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |

对于所有数据，保证 $2 \le n \le L \le R \le {10}^9$。

【感谢 hack 数据提供】  
[wangbinfeng](/user/387009)

## 样例 #1

### 输入

```
7 16 23
```

### 输出

```
6
```

## 样例 #2

### 输入

```
10 14 18
```

### 输出

```
8
```

## 样例 #3

### 输入

```
见附件中的 candy/candy3.in。```

### 输出

```
见附件中的 candy/candy3.ans。```

# 题解

## 作者：滑_稽 (赞：240)

# 0 前言

这道题是两年来我做过的代码量最少的一道普及组题目，考场上 $\text{10min}$ 推出结果，$\text{100pts}$ 应该没问题。（三个样例都过了，你谷民间数据也没错）

---

# 1 简化题意

给定正整数 $n,L,R(2\le n\le L\le R\le10^9)$，求 $\max\limits_{k\in[L,R]}\{k\bmod n\}$。

---

# 2 题目分析

拿到手，发现这是一道明显的~~幼儿园高质量小朋友求偶人类高质量女性~~数学结论题。

>$R-L\le 10^9$

明显 $O(n)$ 的做法不可取，怎么办？

自然地想到分析 $L,R$ 与 $n$ 之间的倍数关系。（因为要使 $k\bmod n$ 最大，就一定要找尽量大的小于 $n$ 的倍数的数）

记 $l=\left\lfloor\dfrac{L}{n}\right\rfloor,r=\left\lfloor\dfrac{R}{n}\right\rfloor$，容易发现如果 $l=r$ 的话，$[L,R]$ 里面从小到大所有数模 $n$ 的值是**单调递增**的，于是 $k=R$ 时 $k\bmod n$ 最大。

如果 $l<r$，说明在 $(L,R]$ 中有**至少一个** $n$ 的倍数（记为 $N$）。显然，当 $k=N-1$ 时，$k\bmod n$ 最大，为 $n-1$。

可以结合样例理解上述结论。

---

# 3 代码实现

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n,l,r;

int main(){
	cin>>n>>l>>r;
	if(l/n==r/n) cout<<r%n;
	else cout<<n-1;
	return 0;
}
```

---

## 作者：Lethifold (赞：158)

简单数学题

**题意简述**：

给你三个数 $n,l,r$，让你在 $[l,r]$ 中找到一个整数 $x$，使 $n\bmod x$ 最大，输出这个最大的 $n\bmod x$

**70分思路：**

暴力枚举 $[l,r]$ 中的每一个整数并统计答案。

**100分思路：**

取余运算的两个简单性质：

~~（大概是小学知识吧）~~

1.	$n$ 对任何正整数取余的结果都在 $[0,n-1]$范围内

2.	若 $x\bmod n=y$，则 $(x+n)\bmod n=y$

因此我们能知道：

若 $r-l+1\geq n$，则 $[0,n-1]$ 中的每个正整数都能在 $[l,r]$中的正整数对 $n$ 取余的结果中找到，此时答案为 $n-1$

若 $r-l+1 \lt n$，则再分类讨论：

若 $l\bmod n\leq r\bmod n$，如下图

![图1](https://cdn.luogu.com.cn/upload/image_hosting/4looize3.png)

此时能取到的数的范围为上图的红色部分，这时答案为 $r\bmod n$

**注意：** 这里的分类是 $l\bmod n\leq r\bmod n$，而非 $l\bmod n\lt r\bmod n$

若 $l\bmod n\gt r\bmod n$，如下图

![图2](https://cdn.luogu.com.cn/upload/image_hosting/cmlueo16.png)

此时能取到的数的范围为上图的红色部分，这时答案为 $n-1$

**总结：**

此题解题关键为分类讨论，必须贯彻**不重不漏**的原则，否则有可能出错

**代码如下:**
```
#include<cstdio>
using namespace std;
int n,L,R;
int main(){
	freopen("candy.in","r",stdin);
	freopen("candy.out","w",stdout);
	scanf("%d%d%d",&n,&L,&R);
	if(R-L+1>=n)printf("%d\n",n-1);
	else{
		if(L%n<=R%n)printf("%d\n",R%n);
		else printf("%d\n",n-1);
	}
	return 0;
}
```

**一些闲话：**

考场上一开始以为是二分搜索，推了一会儿才发现只用分支结构就可以A了，我是脑瘫QAQ

感谢观看，如果觉得对您有帮助不妨点个赞

---

## 作者：ZBAA_MKC (赞：22)

### 一些吐槽

本人因为 BJ 一些 [奇奇怪怪的规定](https://noi.cn/gs/xw/bj/2021-10-22/746059.shtml) 没能去参加 CSP-J2，提高组回来有时间了赶紧把 T1 水过~（~~我绝不会告诉你我调了半个小时~~）

### 正题开始

这是一道数学题

一开始我还想了一堆什么左端点模数和右端点模数的最大值，后来发现我想多了，其实非常简单：

如果 `r - r % n` 还大于 $l$，那么说明 $r-l$ 中必然包含了最大可以取到的 $n-1$。 在这种情况下我们输出 $n - 1$ 即可。

否则说明 $r - l$ 中不包含最大可以取到的 $n - 1$，则 `r % n` 必然为正确的答案。

时间复杂度和空间复杂度均为 $O(1)$。

代码很简单，就不贴了。

---

## 作者：_caiji_ (赞：21)

分类讨论。

一句话题意：求 $\max\limits_{i=l}^{r}\{i\bmod n\}$

首先画个数轴，按除以 $n$ 向下取整的商把这些整数分块，大概是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/wgyd1p7v.png)

容易看出每块中的整数 $\bmod n$ 的值单调递增，越往右越大。

接着，如果 $l$ 和 $r$ 不在同一块：

![](https://cdn.luogu.com.cn/upload/image_hosting/xqhq3xab.png)

那么 $l$ 和 $r$ 一定会跨过一个块的右端点，所以 $ans=n-1$。

如果 $l$ 和 $r$ 在同一块：

![](https://cdn.luogu.com.cn/upload/image_hosting/yhhllnu7.png)

那 $ans$ 最多能取到 $r\bmod n$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
LL n,l,r;//其实不开 LL 也行
int main(){
	freopen("candy.in","r",stdin);
	freopen("candy.out","w",stdout);
	scanf("%lld%lld%lld",&n,&l,&r);
	if(l/n!=r/n) printf("%lld\n",n-1);
	else printf("%lld\n",r%n);
	return 0;
}

```


---

## 作者：qwq___qaq (赞：17)

作为唯一的数学题，本题还是有思维难度，本人在考场上的思路如下：设 $l = k \times n + x, r = m \times n + t$，若 $k=m$，则答案为 $\max{x,t}$，也就是 $\max{l \bmod n,r\bmod n}$；否则易得 $ t=(k+1)\times n - 1$，一定在答案范围内，输出 $n-1$。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
int main(){
    cin>>n>>l>>r;
    if(r/n==l/n)
        cout<<r%n<<endl;
    else
        cout<<n-1<<endl;
    return 0;
}
```

---

## 作者：Shunpower (赞：16)

考场上唯一 A 的题，T3 因为没写返回值造成的差异爆掉了。

## 题意简述

在开区间 $(l,r)$ 取一个数 $x$ 使得 $x\bmod n$ 的最大。

## 思路

很容易想到暴力，把 $l$ 到 $r$ 全扫一遍就行，得分 $70$。

但是可以发现，在 $(l,r)$ 这一段里，只有两种情况：

- 包含一个 $x$ 使得 $n$ 可以整除 $x$。
- 如果不包含那么 $r$ 一定是最大的，因为 $(l,r)$ 中若没有 $x|n$ 那么这一段中每一个数 $\bmod n$ 的值一定递增并在 $r$ 处达到段内的顶峰。

所以我们可以检查 $l+(n-l\bmod n-1)$ 的值（即使得 $\bmod n=n-1$ 最小的 $x$）是否在区间内，如果是可以直接输出 $n-1$，否则输出 $r\bmod n$。

## AC 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,l,r;
int main(){
	cin>>n>>l>>r;
	int k=l%n;
	if(l+(n-1-k)<=r){
		cout<<n-1<<endl;//情况1
	}
	else{
		cout<<r%n<<endl;//情况2
	}
	return 0;
}
```

---

## 作者：wweiyi (赞：14)

时隔多年回来看普及组的题目我仍然感慨万千

首先 第一种算法就是直接枚举 $[l,r]$ 的区间，然后 `mod  n` 求一个最大值

时间复杂度 $O(r-l+1)$

另外一种算法就可以 $O(1)$ 水过去

我们考虑如果 $l \space mod \space n+(r-l)$ 小于 $n$ 的话，我们就直接取他们两个分别 $mod \space n$ 的最大值

如果大于 $n$ 的话，显然我们模 $n$ 的意义下已经经过了 $[1,n-1]$ 的每一个值，所以我们直接输出 $n-1$ 即可

```cpp
#include <iostream>
using namespace std;
long long n,l,r;
int main()
{
	cin>>n>>l>>r;
	if((l%n+(r-l))>=n)
	cout<<n-1<<endl;
	else
	cout<<max(l%n,r%n)<<endl;
	return 0;
}
```

upd：评论区的一组hack可以通过

---

## 作者：int32 (赞：13)

注：因为暂无数据，复现的考场程序不一定 AC，如果没过评论一下，思路应该是没错的。

一道偏向 CF 的数学题。

容易发现，自己最后的奖励是 $k\bmod n$。 

但是循环遍历肯定超时，$10^9$ $1\text{s}$ 是跑不过的。

于是我们设 $x=\dfrac{L}{n},y=\dfrac{R}{n},a=L\bmod n,b=R\bmod n$，则 $nx+a=L,ny+b=R$，如下分讨：

- $x=y$

	很明显，当搬 $R$ 个糖果最划算，因为 $R>L$，所以 $b>a$，输出 $b$。

- $x\neq y$

	这时必定有一种方案使得 $k=nt+n-1\ (L\leq k\leq R)$，所以输出 $n-1$。
    
程序如下：

```cpp
//T1
#include<bits/stdc++.h>
using namespace std;
int l, r, n;
int x, y;
int a, b;
signed main(){
	cin>>n>>l>>r;
	x=l/n, y=r/n;
	a=l%n, b=r%n;
	if(x==y) cout<<b;
	else cout<<n-1;
	return 0;
}
```

---

## 作者：Terraria (赞：9)

过了冥间数据，应该是没啥问题。来一篇题解。

首先我们不难发现，对于确定的 $x$，“你”能够得到的奖励的糖果数就是 $x\%n$，那我们的目标就是要找到这个 $x$。

对于确定的 $[l,r]$，有如下几种情况：

- $l \leq kn-1\leq r,k$ 为任意正整数。我们可以发现 $\lfloor\dfrac{l}{n}\rfloor<\lfloor\dfrac{r}{n}\rfloor$；

- $kn-k-1< l \leq r <kn-1,k$ 为任意正整数。我们可以发现，$\lfloor\dfrac{l}{n}\rfloor=\lfloor\dfrac{r}{n}\rfloor$。

所以我们可以通过比较 $\lfloor\dfrac{l}{n}\rfloor,\lfloor\dfrac{r}{n}\rfloor$ 的大小，来判断 $l,r$ 与 $k(n-1)$ 的位置关系。

对于能取到 $kn-1$ 的，一定要取。否则就取 $r$，以 $r \%n$ 作为答案。

代码就不放了。

---

## 作者：luckydrawbox (赞：8)

## 题意

找到一个数 $k$，使 $L\le k\le R$，且 $k\bmod n$ 最大，输出这个最大值。

## 分析

显然 $k\bmod n$ 的最大值为 $n-1$，于是我们找到 $L\sim R$ 中最大的 $n$ 的倍数 $\left\lfloor\frac{R}{n}\right\rfloor\times n$，若 $\left\lfloor\frac{R}{n}\right\rfloor\times n-1$ 仍在 $L\sim R$ 中，则答案可取到最大值 $n-1$。

反之，若不满足上述条件，那么有$\left\lfloor\frac{R}{n}\right\rfloor\times n\le L\le R<(\left\lfloor\frac{R}{n}\right\rfloor+1)\times n$，此时 $R-\left\lfloor\frac{R}{n}\right\rfloor\times n$ 为最大答案。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
//const int N=;
ll n,l,r;
int main(){
	n=read();l=read();r=read();
	if(r/n*n-1>=l)
		write(n-1);
	else
		write(r-r/n*n);
	return 0;
}
```


---

## 作者：信息向阳花木 (赞：7)

这题肯定不能用暴力，对吧！（对，$max(R-L)=10^9$）

找规律：
如果 $r\mod  n > l \mod n$，什么 $l$ 和 $r$ 一定经过了一个轮回。

如果没有经过轮回，那么 $r \mod n$ 一定大于 $l \mod n$。

怎么判断有没有经过轮回呢？

> 若有 $l \mod n + r - l$ 大于等于 $n$ 的话，说明经过了一个轮回。

> 因为 $l \mod n$ 加上 $l$ 到 $r$ 的差的大于等于 $n$ 的话，说明 $[l,r]$ 中至少有一个数 $\mod n = n-1$。

话不多说，上代码！
```cpp
#include <iostream>
using namespace std;
int main()
{
	int n,l,r;
	cin>>n>>l>>r;
	if((l%n+r-l)>=n)cout<<n-1;
	else cout<<r%n;
}
```

---

## 作者：山田リョウ (赞：4)

题外话：今年题太简单了吧。。。我都能阿克。。。

题意：找出 $\left[l,r\right]$ 区间内所有数除以 $n$ 的余数的最大值。

显然，如果 $\left[l,r\right]$ 中包含除以 $n$ 余 $n-1$ 的，答案肯定就是 $n-1$，不然的话就输出 $r$ 除以 $n$ 的余数，因为如果不包含除以 $n$ 余 $n-1$ 的数的话，这些数除以 $n$ 的余数肯定也是单调递增的。

考场代码：
```cpp
#include<stdio.h>
inline int max(int a,int b){return a>b?a:b;}
int main(){
	FILE *in=fopen("candy.in","r"),*out=fopen("candy.out","w");
	int l,r,n;
	fscanf(in,"%d%d%d",&n,&l,&r);
	if(r-r%n>l)fprintf(out,"%d",n-1);
	else fprintf(out,"%d",r%n);
	fclose(in);
	fclose(out);
	return 0;
}
```

---

## 作者：lichengyun (赞：3)

# CSP-J第二轮的签到题

首先，我们将这道题转化为~~小学~~数论题目。

题意：在 $[l,r]$ 区间内取数$k$,使 $k$ 除以 $m$ 的余数最大。

------------

下面来进行求解。

1、

$$[\frac{l}{m}]=[\frac{r}{m}]$$

此时由$L \leq k \leq R$，所以 $k$ $\bmod$ $m$ 在 $L$ $\bmod$ $m$ 与 $R$ $\bmod$ $m$ 之间,当 $k=R$ 时 $k$ $\bmod$ $m$ 取最值。

2、

$$[\frac{r}{m}]-[\frac{l}{m}] \geq 1$$

此时必有

$$k=([\frac{r}{m}]+1)*m-1$$

使 $k \bmod m=m-1$ 且 $L \leq k \leq R$

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long m,l,r;cin >> m >> l >> r;
	long long lz = l / m, rz = r / m;
	if(lz == rz){
		cout << r % m << endl;
	}else{
		cout << m - 1 << endl;
	}
	return 0;
}

```


---

## 作者：fz20181223 (赞：3)

题意简化：给出 $n,l,r$，求在区间 $[l,r]$ 内对 $n$ 取模后的最大值

暴力做法：枚举。过于直白，不再多谈

正解：仔细观察自然数对 $n$ 取余后的函数，可发现大致是这样的（然而这是实数的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6h2rpulo.png)

所以我们只需找出一段区间内函数值最大的自然数就行了

对于 $\left\lfloor\dfrac{l}{n}\right\rfloor=\left\lfloor\dfrac{r}{n}\right\rfloor$，则 $l$ 到 $r$ 之间的图像为递增关系（如样例2所说），直接给出 $r\bmod n$ 即可。

否则在 $l$ 和 $r$ 之间总会存在一个数 $k$ 使得 $k \bmod n=n-1$，而一个数的余数是不可能大于等于其本身的，故输出 $n-1$ 即可。

源代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
int main(){
	scanf("%d %d %d",&n,&l,&r);
	if(r/n==l/n) printf("%d",r%n);
	else printf("%d",n-1);
	return 0;}
```

---

## 作者：Chenyu_Ye (赞：3)

### 题意简述
在 $L$ 到 $R$ 的区间内选一个数，使得此数除以 $n$ 的余数最小。

### 分析
显然的结论题。

首先分析，可以取到的最大余数是 $n-1$ 。

而当 $R \div n$ $-$ $L \div n$ $\geq$ $1$时（或$R$ $mod$ $n$ $=$ $n-1$时）才可能取到$n-1$。

否则，若 $R \div n$ $=$ $L \div n$，因为 $R$ $\geq$ $L$，所以可以取到的较大余数是 $R$ $mod$ $n$。

判断后输出即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, l, r;
int main()
{
    scanf("%d%d%d", &n, &l, &r); //scanf输入
    int a1 = l/n, a2 = l%n, b1 = r/n, b2 = r%n; //a1表示l/n的商，a2表示l/n的余数，b1，b2同理
    if (b1-a1 >= 1) cout << n-1; //如果R/n-L/n >= 1 则取到最大余数
    else cout << b2; //否则输出 R mod n
    return 0;
}
```


---

## 作者：lcyxds (赞：3)

# **题目描述**
给定正整数 $n,L,R$，求满足 $L\le k \le R$ 的正整数 $k$ 中，$k\mod n$ 的最大值。
# **题解**
当 $\lfloor \frac Ln\rfloor=\lfloor \frac Rn\rfloor$ 时，$\lfloor \frac Ln\rfloor=\lfloor \frac kn\rfloor=\lfloor \frac Rn\rfloor$，又因为 $x\mod n=x-n\lfloor \frac xn\rfloor$，故 $k$ 取最大值 $R$ 时，$k\mod n$ 取最大值 $R\mod n$。

当 $\lfloor \frac Ln\rfloor<\lfloor \frac Rn\rfloor$时，$\lfloor\frac{n\lfloor \frac Ln\rfloor+n-1}n\rfloor=\lfloor \frac Ln\rfloor<\lfloor \frac Rn\rfloor$，而 $L\leq n\lfloor \frac Ln\rfloor+n-1$，故可取 $k=n\lfloor \frac Ln\rfloor+n-1<R$，此时 $k\mod n$ 取最大值 $n-1$。

代码如下：
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int main() {
  int n, l, r;
  scanf("%d%d%d", &n, &l, &r);
  printf("%d", r/n==l/n?r%n:n-1);
  return 0;
}

```


---

## 作者：Coros_Trusds (赞：3)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15442992.html)

上午参加了 $\rm CSP-J$ 中午来补题解。

感觉今年的 1= 分数线会相对而言低一点。

# 题目大意

给定 $n,l,r$，求 $\max\limits_{i=l\operatorname{mod}~n}^{r\operatorname{mod}~n}~$ 的最大值。

观察到 $r-l\le10^9$，那么答案可能和这个有关（不然给你这个干啥）。

否则，如果 $r-l\ge n$，那么说明区间 $[l,r]$ 之间一定有 $n$ 的某个倍数 $-1$，要想 $\operatorname{mod}~n$ 最大，答案就是 $n-1$。

否则，即 $r-l\lt n$，因为 $n\le l\le r$，所以此时最大值为 $r~\operatorname{mod}~n$。

**最后还需要特判一个点，如 `30 118 123` 之类的数据，我的考场代码会 WA 掉。**

当 $\dfrac{r}{n}>\dfrac{l}{n}$ 时，输出 $n-1$。

# 代码

```cpp
int main(void)
{
	//freopen("candy.in","r",stdin);
	
	//freopen("candy.out","w",stdout);
	
	int n,l,r;
	
	n=read(),l=read(),r=read();
	
	if(r-l>=n)
	{
		printf("%d\n",n-1);
	}
	
	else if(r/n>l/n)
	{
		printf("%d\n",n-1);
	}
	
	else
	{
		printf("%d\n",r%n);
	}
	
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

~~话说 j 组真的一年比一年水~~

### 题目简述
给一个 $n$，求 $x\in[l,r]$，$x \mod n$ 的最大值。

### 解题思路
第一眼看上去，貌似是数论。仔细一看，发现 $x\mod n<n$，也就是只要判断 $[l,r]$ 之间是否有模 $n$ 余 $n-1$ 的数就好了。否则，苹果肯定拿得越多越好，输出 $r\mod n$。

下面给出考场代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,l,r;
int main(){
	//freopen("candy.in","r",stdin);
	//freopen("candy.out","w",stdout);
	cin>>n>>l>>r;
	if(l/n+1<=(r+1)/n)
		cout<<n-1;
	else
		cout<<r%n;
	return 0;
}
```


---


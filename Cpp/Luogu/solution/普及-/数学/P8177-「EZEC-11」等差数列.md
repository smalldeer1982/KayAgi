# 「EZEC-11」等差数列

## 题目描述

给你一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

从 $x$ 中任选两个数 $x_i,x_j$（$i\neq j$），同时满足：

- $x_i+x_j$ 为偶数。
- $x$ 中没有 $\frac{x_i+x_j}{2}$。

那么你就可以将 $\frac{x_i+x_j}{2}$ 加入 $x$ 中，称为一次操作。

**注意：新加入的数也可被选择。**

问你最多能进行几次操作？

## 说明/提示

**【样例 1 解释】**

对于第一组数据，$x=[1,2,3]$，无法进行任何操作。

对于第二组数据，$x=[2,4]$，可以选择 $2$ 和 $4$，将 $\frac{2+4}{2}=3$ 加入数列中。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（10 points）：$d=1$。
-  Subtask 2（10 points）：$n=2$。
-  Subtask 3（30 points）：$T\le 10$，$n\times d\le 10^3$，$a=0$。
-  Subtask 4（50 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$2\le n\le 10^9$，$-10^9\le a\le 10^9$，$1\le d\le 10^9$。

## 样例 #1

### 输入

```
2
3 1 1
2 2 2```

### 输出

```
0
1```

# 题解

## 作者：lichengyun (赞：11)

本蒟蒻提供一种单组询问 $\Theta(1)$ 的解法。

$\because$ 设 $a_i=a_0+d \times i$

$\therefore    {a}$ 为等差数列。

$\because a_i < \frac{a_i+a_{i+1}}{2} < a_{i+1}$

由对称性，我们只考虑区间 $[a_0,a_1)$。

令 $b_1=a_0+\frac{d}{2}$

$\therefore$ 故 $b_1$ 可以由 $\frac{a_0+a_1}{2}$ 得到。

$\therefore$ 同理可知，在 $[a_0,a_1)$ 中可取的全部数为 $a_0,a_0+\frac{d}{2^i},a_0+ \frac{2d}{2^i},\cdots,a_0+\frac{(2^{i}-1)d}{2^i}$

($i$ 为整除 $d$ 的最大 $2^p (p \in \mathrm{N}$))

综上，最多可添加 $(n-1)\times (\operatorname{lowbits}(d)-1)$个数。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int T,n,a,d;
    //I/O流优化
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin>>T;
    while(T--){
        cin>>n>>a>>d;
        cout<<(1ll*(n-1)*((d&(-d))-1))<<endl;
    }
    return 0;
}
```


---

## 作者：luozhichen (赞：11)

[题目直通车](https://www.luogu.com.cn/problem/P8177)

## 题目大意：

这道题就是问你这个等差数列能往里面加几个数字，使改动后的数列依然是等差数列。

## 思路：

思路很简单，就是看它的公差是否为偶数，是的话就继续，否则输出即可。
具体解释看代码。

## 代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long//记得long long
using namespace std;
int t;
int n,a,b;
signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin >> t;
	while(t--){
		cin >> n >> a >> b;
		int s = 1;//记得初始化
		while(b % 2 == 0){//判断它的公差是否为2的倍数
			s <<= 1;//是就加上一倍
			b >>= 1;//公差减小一倍
		}
		cout << (s - 1) * (n - 1) << endl;//最后输出
	}
	return 0;
}

```


---

## 作者：LCat90 (赞：7)

蒟蒻第一次打月赛，激动地点开第一题：
> ~~哇，好简单！~~

30min 后，终于 AC 了。（我好菜啊）

-----
## 正文：

首先，这个数列是等差数列，也就是说，**每两个相邻元素所构成的子区间 $[x_i,x_{i+1}]$ 中，能产生的新数是一样的**。那么，我们就只用算出每两个元素之间能产生多少个新数，再乘以子区间数 $n-1$ 即可。

可能大家会有疑问，万一两个不同子区间中产生的新数又产生了新数呢？

其实原因很简单，因为这两个数所产生的新数，**必定会由其中一个子区间中的数产生**，那么这时候就重复计算了。所以直接把问题简化成计算两个相邻元素产生的新数即可。

我们来推导一下吧：

设有一集合 $A$，当前有两个元素 $\left \{ A_1,A_2 \right \}$。

首先判断 $A_1+A_2$ 是否是偶数，若不是，则不能再产生数。

根据题目，$A_1$ 为首项，公差为 $d$。

$\therefore A_2 = A_1 + d$

$\therefore A_1 + A_2 = 2A_1 + d$

$\therefore \frac{A_1 + A_2}{2} = A_1 + \frac{d}{2}$

所以，**判断 $A_1 + A_2$ 是否为偶数，就是 $d$ 是否为偶数**。这也就等于，如果 $d$ 为奇数，就连一个数也产生不了，答案为 $0$。

若设 $d$ 为偶数，则第一次后的集合变成了 $\left \{ A_1,\frac{A_1+A_2}{2}, A_2 \right \}$。这个数列也是一个等差数列，因为前后两个子区间产生的新数是一样的，所以直接判断左子区间 $\left \{ A_1,\frac{A_1+A_2}{2} \right \}$。此时 $d$ 又更新为 $\frac{A_1+A_2}{2}-A_1$。继续判断 $d$ 的奇偶，直到 $d$ 为奇数才停止。

又容易发现：

$\because d_1 = \frac{A_1+A_2}{2}-A_1$

$\therefore d_1 = \frac{A_1}{2}+\frac{A_2}{2}-A_1=\frac{A_2}{2}-\frac{A_1}{2}=\frac{A_2-A_1}{2}$

又 $\because d_0 = A_2 - A_1$

$\therefore d_1 = \frac{d_0}{2}$

即，**每次产生新数后，公差 $d$ 就除以 $2$**。

到此，思路就已经出来了。

本题像是一个二分，每次二分子区间，只取左或右区间，每次将 $d$ 除以 $2$，判断其奇偶。

开始，子区间数量为 $1$，没有新数。

第一次，子区间数量为 $2$，原来的新数为 $0$，产生的新数为 $1$，共产生 $1$ 个数。

第二次，子区间数量为 $4$，原来的新数为 $1$，产生的新数为 $2$，共产生 $3$ 个数。

第三次，子区间数量为 $8$，原来的新数为 $3$，产生的新数为 $4$，共产生 $7$ 个数。

每次产生的新数比原来多 $1$。设答案为 $ans$，则 $ans_i = 2ans_{i-1}+1$。

## Code:（其中的位运算有解释）

```cpp
#include <cstdio>
int t;
long long n, a, d; // 注意开 long long
int main() {
	scanf("%d", &t);
	while(t--) {
		scanf("%lld %lld %lld", &n, &a, &d);
		long long ans = 0;
		while(!(d & 1)) { // d 为偶数
			ans = (ans << 1) + 1; // ans = ans * 2 + 1
			d >>= 1; // d /= 2;
		}
		printf("%lld\n", ans * (n - 1)); // n - 1 个相邻的数对，每个数对答案为 ans
	}
	return 0;
}   
```

#### 第一次写题解，若有错误请大佬指出。

---

## 作者：TernaryTree (赞：5)

## 题目大意

给定一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

每次操作可选取 $x_i,x_j\ (i\ne j)$ 当满足 $x_i+x_j\bmod2=0$ 且 $\frac{x_i+x_j}{2}$ 不在原数列中可以将 $\frac{x_i+x_j}{2}$ 加入原数列。

新加入的数也可以被选择。

求最多能进行的操作数。

## 思路分析

我们把 $x_i$ 都看成是一个 $t$ 数组的下标。

![](https://cdn.luogu.com.cn/upload/image_hosting/xibpalmr.png)

现在假设有等差数列 $\{3,6,9\}$。标出对应下标。

![](https://cdn.luogu.com.cn/upload/image_hosting/xlhn39c9.png)

发现 $3$ 和 $6$ 之间相差 $3$ 格，所以无法选取 $3$ 和 $6$ 进行一次操作。

所以当公差为奇数的时候，相邻两个数之间是无法进行操作的。

同时发现 $3$ 与 $9$ 为偶数，但 $\frac{3+9}{2}=6$，已经在数列中。所以无法操作。

扩展到任意等差数列：

$$\frac{x_i+x_j}{2}=x_{\frac{i+j}{2}} \ (|i-j|\bmod 2=0)$$

所以我们是无法选取在 $x$ 中下标相差为偶数的元素进行操作的。

再来看一组数据：$x=\{2,6,10\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wmtgogpt.png)

首先，我们一段一段看。即分为 $\{2,6\}$ 与 $\{6,10\}$。

$\{2,6\}$ 可以进行操作。得到 $4$。

$\{6,10\}$ 可以进行操作。得到 $8$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cwphoukr.png)

等差数列公差减少了一半，变成了 $n=5,a=2,d=2$ 的等差数列了。

可以继续进行操作。

还是一段一段看。

$\{2,4\}$ 可以进行操作。得到 $3$。

$\{4,6\}$ 可以进行操作。得到 $5$。

$\{6,8\}$ 可以进行操作。得到 $7$。

$\{8,10\}$ 可以进行操作。得到 $9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zbi467mj.png)

这下就不能进行操作了。

我们可以发现，等差数列的变化规律：

1. $n=3,a=2,d=4$

2. $n=5,a=2,d=2$

3. $n=9,a=2,d=1$

易发现 $n_i=n_{i-1}\times 2 - 1,a_{i} = a_{i-1}$。

而 $d$ 仅当为偶数时可以进行操作。奇数时停止。

其实就是求 $d$ 转换为二进制后从低位开始第一个 $1$ 到之前所有 $0$ 组成的新数。通俗一点，就是最大的整除 $d$ 的 $2$ 的整数次幂。代码：

```cpp
k = 1;
while (d % 2 == 0) {
	d /= 2;
	k *= 2;
}
k--;
```

当然，学过树状数组的童鞋可能会知道 `lowbit` 这个东东，所以就可以 $O(1)$ 求解啦！

```cpp
k = (d & (-d)) - 1;
```

当然这个位运算的背后原理比较复杂，这里简单提一下，有兴趣的同学可以上网了解一下。

这里的 $k$ 是每一段可以进行的次数，一共有 $n - 1$ 段，所以答案显而易见：

$$ans=((d\ \& \ (-d)) - 1) \times (n-1)$$

## 完整代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int c;
int n, a, d;

inline int read()
{
	int X=0; bool flag=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') flag=0; ch=getchar();}
	while(ch>='0'&&ch<='9') {X=(X<<1)+(X<<3)+ch-'0'; ch=getchar();}
	if(flag) return X;
	return ~(X-1);
}
inline void write(int X)
{
	if(X<0) {X=~(X-1); putchar('-');}
	if(X>9) write(X/10);
	putchar(X%10+'0');
}

signed main() {
	c = read();
	while (c--) {
		n = read(), a = read(), d = read();
		write(((d & (-d)) - 1) * (n - 1));
		puts("");
	}
	return 0;
}
```

为了抢一个最优解，附上了快读。~~不过最后还是没抢到~~

---

## 作者：DPseud (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8177)

作为月赛的第一题，这道题目实在是毒瘤（虽然有可能是我太菜了），尤其是题意可能有点难理解，理解了就能推公式了。

首先，有一点很显然，那就是无论你怎么选 $x$ 和 $y$，结果都是一样的。

接着就是题目中啰啰嗦嗦说了一大堆，其实就是求两个数的整数平均数，那很明显我们只需要找两个平均数是整数的数就行了，因为在哪里开始找都是可行的。

还有便是判断是否能进行操作时，只需要判断相邻每两个数的平均数是否是整数，因为相隔偶数个数的两个数的平均数已经存在；而相隔奇数个数的两个数的平均数不是整数（可以举例说明，我就不说了）。

![](https://cdn.luogu.com.cn/upload/image_hosting/onhi9nw6.png)

如图，黑色的是原来的数列，红色的是第一次遍历数组进行操作后的数列，蓝色是第二次，接着因为相邻两个数的平均数是小数了，所以就不能进行操作了。

咳咳，接下来进入正题：

题目问进行多少次操作，其实就是最后的数列和最开始的数列相差多少个数，以上图的数列为例，答案是 $12$，也就是 $3 \times 4$，不难发现，$4$ 是项数 $n$ 减去 $1$，而 $3$ 是什么回事呢？

显然 $3$ 与公差 $d$ 能平均分多少次有关的，能平均分多少次，就是这个数包含多少个因数 $2$，因此我们可以推出式子，设公差包含因子 $2$ 的格数为 $v$，$j$ 是 $2$ 的 $v$ 次方，答案为 $w$，式子就是：

$w=(n-1)\times(j-1)$

但是，你以为这就完了吗？

注意看题目数据范围，显然不可以使用 int，因此我们需要开 long long。

而且，因为要开 long long，所以求次方不能用 pow 函数了，得自己打。

最后是你们都喜欢的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for(int i=0;i<t;i++)
    {
    	long long n,a,d;
    	scanf("%lld %lld %lld",&n,&a,&d);
    	long long dd=d;//公差
    	long long bb=0;//指数
    	long long jj=2;
    	long long ll=1;//幂
    	while(dd!=1)
    	{
    		if(dd%jj==0)
    		{
    			dd/=jj;
    			if(jj==2)bb++,ll*=2;
			}
    		else break;
		}
    	printf("%lld\n",(n-1)*(ll-1));//输出
	}
    return 0;
}
```


---

## 作者：GI录像机 (赞：3)

## [-----------题目传送门-----------](https://www.luogu.com.cn/problem/P8177)

## 赛时结论：

若 $d$ 为奇数，则不可进行操作。

若 $d$ 为偶数，则可进行 $n-1$ 次操作。其中 $n$ 为**当前**数列长度。若首项与最后一次操作中添加的数之和为偶，则再进行一轮操作，直至首项与最后一次操作中添加的数之和为奇。

## 赛后证明：

(感性证明，重在理解)

当 $d$ 为奇数时，因为偶+奇=奇，奇+奇=偶，因此相邻两数间奇偶性必然改变，只能选取相隔一个数的两数做操作，但由于是等差数列，$\frac{a_x+a_{x+2}}{2}$ 必然等于 $a_{x+1}$，故无法进行任何操作。

当 $d$ 为偶数时，等差数列中的数的奇偶性一定相同，因此我们选择相邻的两数做操作（想一想，为什么选相邻的）。然后我们获得新的 $n-1$ 个数，$n$ 为**当前**数列长度。由于先前的数列已经判断过了，所以我们只需要判断新加的数与之前的数能否进行操作。而新加的数的集合也为等差数列，奇偶性相同。所以如果首项与新加的任意一个数之和为偶，则每一个新加的数和之前的每个数都可以进行操作，还是因为是等差数列，去重后同样是 $n-1$ 次操作。此时知道了数列中的数奇偶性仍然相同，故只需重复以上步骤至无法再进行操作。

## 代码示例：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	long long f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(long long x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
int main()
{
	long long t = read();
	while (t--)
	{
		long long n = read(), a = read(), d = read();
		long long ans = 0;
		long long s = a + d;
		while (!((a + s) & 1))
		{
			ans += n - 1;
			n = 2 * n - 1;
			s = (a + s) >> 1;
		}
		write(ans);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：sgl654321 (赞：2)

### 题目大意
- 给定一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

- 在数列中任选两个数 $x_i$ 与 $x_j$，若 $x_i+x_j$ 为偶数且 $\dfrac{x_i+x_j}{2}$ 不在数列中，那么将该数插入等差数列中。

- 输出最多能插入的数的个数。

整理信息，我们可以将题目大意转换为：
- 给定一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

- 若 $x_{i+1}-x_i$ 为偶数，那么在数列中插入 $\dfrac{x_i+x_{i+1}}{2}$，一直操作下去，直至所有的 $x_{i+1}-x_i$ 都为奇数。

- 输出最多能插入的数的个数。

### 解题思路
看数据规模，就知道是数学题。解决数学题，有一种非常高效的方法，那就是~~找规律~~**从特殊到一般，推导公式**。

显然，答案与首项 $a$ 无关。

咱们就以下面这个数据为例：$n=4$，$a=10$，$d=24$。即这个数列为 $[10,34,58,82]$。

- 第一次操作后：$[10,22,34,46,58,70,82]$，共插入了 $3$ 个数。

- 第二次操作后：$[10,16,22,28,34,40,46,52,58,64,70,76,82]$。共插入了 $6$ 个数。

- 第三次操作后：$[10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,58,61,64,67,70,73,76,79,82]$，共插入了 $12$ 个数。

总共插入了 $21$ 个数，所以应当输出 $21$。

我们发现，**每一次插入的数都是上一次插入的数的二倍**。如果我们将每次插入的数的个数定为一个序列 $s$，则有 $s_i=s_{i-1}\times 2$。

那么 $s_1$ 为多少呢？显然，$s_1=n-1$。

所以我们只需要求出序列 $s$ 有几项，再进行求和，就可以得到答案了。

再一次对操作进行分析：

- 原数列的公差为 $24$。
- 第一次操作后，数列的公差为 $12$。
- 第二次操作后，数列的公差为 $6$。
- 第三次操作后，数列的公差为 $3$。至此，无法继续添加数了。

每一次操作后，公差都变为上一次的一半，直到公差成为一个奇数。
所以，序列 $s$ 的项数，就是公差 $d$ 的 $2$ 的**因数的个数**，可以将它记为 $k$。因为时间充裕，我是用暴力求出 $k$ 的。当然，实际上也可以用 $O(1)$ 求出来。

因此答案就是 $(n-1)(2^k-1)$。经检验发现公式是正确的。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a,d;
long long k,f[100];
int main(){
	cin>>t;
	while(t--){
		k=0;
		cin>>n>>a>>d;
		while(1){
			if(d%2==1)break;
			d/=2;
			k++;
		}
		cout<<(n-1)*((1<<k)-1)<<endl;
	}
	return 0;
}
```




---

## 作者：奥斯卡小冰人 (赞：2)

题意比较简单这里不再赘述。

## 思路
我们发现合法的操作次数其实就是操作后序列中增加的数的个数。因此可以观察操作后的序列。

没有进行过操作的等差数列 $x$ 应该如下所示：

$x_1 = a$

$x_2 = a + d$

$x_3 = a + 2d$

$x_4 = a + 3d$

$x_5 = a + 4d$

$\vdots$

$x_n = a + (n - 1)d$

如果就以上面的数进行操作，可以得到如下的数列：

$x_1 = a$

$x_2 = a + \dfrac{d}{2}$

$x_3 = a + 2d$

$x_4 = a + \dfrac{3d}{2}$

$x_5 = a + 3d$

$\vdots$

$x_{2n - 2} = a + \dfrac{(n - 1)d}{2}$

$x_{2n - 1} = a + (n - 1)d$

对比原来的序列，会发现多出了诸如 $\dfrac{d}{2}$ 这样的分数（假设 $d$ 可以被 2 整除），如果再就以这些数进行操作，就会多出诸如 $\dfrac{d}{4}$ 这样的分数（假设 $d$ 可以被 4 整除）。

也就是说，我们可以通过判断 $d$ 是否可以被 2，4，8，16 $\ldots$ 整除，来确定可以增加进序列的数的数量，即合法的操作次数。

这样的时间复杂度是 $O(\log d)$ 的，可以通过这道题。

而计算增加进序列中的数也比较简单。假设 $d$ 可以整除的最大的 2 的 $n$ 次幂 为 $x$，则序列中数的总数为 $x(n - 1) + 1$。再减去原来的 $n$ 也就是 $x(n - 1) + 1 - n$ 。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        ll n,a,d;
        scanf("%lld%lld%lld",&n,&a,&d);
        for(ll i = 1;;i <<= 1)
        {
            if(d & 1) 
            {
                printf("%lld\n",i * (n - 1) + 1 - n);
                break;
            }
            d >>= 1;
        }
    }
    return 0;
}
```

---

## 作者：Firstly (赞：1)

这是一道数学题。

## **题目思路：**

根据题意可知：如果两个数之和为偶数且它们的平均值不在数列内，则将这个平均值加入数列中。这个操作实际上就是将这个等差数列的公差压缩至不能被 2 整除为止。

证明：如果一个等差数列公差为偶数，那么相邻的两个数必定会同奇偶性，那么这两个数之和必定为偶数。又因为这两个数本身就是相邻的，中间没有其它数字，那么它们的平均值必定可以添加到数列中；反之，若这个等差数列公差为奇数，那么相邻的两个数不同奇偶性，则它们两数之和必定为奇数。此时不满足条件，无法被添加到数列中去了。

那么，我们可以求原数列的项数，再将公差不断除以 2，除到不能被 2 整除为止，再求此时数列的项数。将此时数列的项数减去原数列的项数，即可得最大操作次数。

## **Code：**

```cpp
#include<cstdio>
#include<cmath>
#define int long long
using namespace std;
int t,n,a,d;
inline int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-48,ch=getchar();
	return s*w;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
inline int getval(int x){
	int cnt=0;
	while(x%2==0)x/=2,cnt++;
	return cnt;
}
signed main(){
	t=read();
	while(t--){
		n=read();a=read();d=read();
		if(d&1)write(0),putchar('\n');//如果原本公差就是奇数，那么就不可以再进行操作了。
		else{
			int m=getval(d);
			int nd=d/pow(2,m);//除到不能被 2 整除为止
			int mx=(n-1)*d;
			int ans=mx/nd+1;//求出现在数列的项数
			ans-=n;//将现数列项数减去原数列项数即可得出答案
			write(ans);
			putchar('\n');
		}
	}return 0;
}
```


---

## 作者：JackMerryYoung (赞：1)

# 前言

类似于分治思想的思维题。

考场上没想出来也没关系。

注：$0$ 是偶数。

# 正文

对于公差 $D$ 进行分类讨论。

## 1. $D$ 为奇数

显然，当公差为奇数时不能进行任何一次操作。

证明：

设 $S_i$ 为数列的第 $i$ 项，$S_j$ 为数列的第 $j$ 项。

先设 $S_k$ 为将 $S_i$ 与 $S_j$ 合并的结果。

则易知：

$$
S_k = \frac{S_i + S_j}{2}
$$

变换亿下，可知：

$$
S_k = \frac{A + D \times (i - 1) + A + D \times (j - 1)}{2}
$$

合并同类项：

$$
S_k = \frac{2A + D \times (i + j - 2)}{2}
$$

化简得：

$$
S_k = A + D \times (\frac{i + j}{2} - 1)
$$

则易知 $k = \frac{i + j}{2}$。

根据 $i + j$ 的奇偶性再分类。

### 1.1 $i + j$ 为奇数

手玩数据发现，公差为奇数时，下标之和若为奇数，两数之和也为奇数。

证明：

若首项为奇数，那么数列的奇偶性将会变成：奇偶奇偶...

若首项为偶数，那么数列的奇偶性将会变成：偶奇偶奇...

然鹅下标之和为奇数，也就意味着你要隔偶数个数选另一个。

那么就发现两个数无论怎么选，和都是奇数。

那么就不符合题意了。

### 1.2 $i + j$ 为偶数

然后你就发现 $\frac{i + j}{2}$ 是个出现过的下标，也不符合题意。

## 2. $D$ 为偶数

第二种情况跟 1.2 一毛一样，这里不再赘述。

所以只有第一种情况符合题意。

## 终极求解

至此，分类讨论结束了。但问题还没完。

对于问题的求解，我们先把相邻两个数进行操作。

然后就有 $N - 1$ 次操作，衍生出了同样数目的数，总计 $2N - 1$ 个数。

这时发现新序列的 $D$ 变为了 $\frac{D}{2}$。 

那么经过细致思考加上验证，我们只要一直对序列操作，直到新序列不满足 $D$ 为偶数，那么答案就出来了。 

至于为什么不会漏数，多观察就可以发现 $(S_i, S_{i + k})$ （$k$ 为奇数）进行操作得到的数与 $(S_{i +\frac{i + k}{2} - 1}, S_{i + \frac{i + k}{2}})$ 进行操作得到的数是相同的，所以将相邻两数进行操作是不会漏数的。

# 代码

~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code..

``` cpp
#include <bits/stdc++.h>
using namespace std;

unsigned long long T;
unsigned long long N, A, D;

signed main()
{
    scanf("%llu", &T);
    while(T --)
    {
        scanf("%llu%llu%llu", &N, &A, &D);
        if(D % 2 == 1)
        {
            puts("0");
        }

        if(D % 2 == 0)
        {
            unsigned long long yuanN = N;
            while(D % 2 == 0 && D != 0)
            {
                D >>= 1;
                N = N * 2 - 1;
            }

            printf("%llu\n", N - yuanN);
        }
    }
    return 0;
}
```

# 后言

话说本题黄题应该还是有的吧...

---

## 作者：pengzy___ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8177)

## 思路：

等差数列，首项和长度都是固定的，所以首先要思考公差。

如果公差为奇数，答案肯定是 $0$ 。因为前一个数是奇数，后面的就是偶数，前面是偶数，后面就是奇数，相邻的两项相加肯定不可能是偶数，所以永远不可能满足条件一，也就不能进行操作。

如果公差为偶数，答案是没有规律的。但经过举例可以发现，公差如果为 $2$ 的倍数，是可以生成新的数的。因为公差为偶数，相邻的两数相加肯定也是偶数，满足条件一；而除以二后的数在数列中肯定是没有的，因为两数相邻。一但公差已经不是 $2$ 的倍数了，就不可能再进行操作了。

### 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,a,d;
int main()
{
	cin>>T;
	while(T--) {
		cin>>n>>a>>d;
		if(d&1)cout<<0<<endl;
		else {
			ll dis=(n-1)*d;
			while(d%2==0)d>>=1;
			cout<<dis/d+1-n<<endl;
		}
	}
	return 0;
}
```

$dis$ 变量记录的是首项到末项的距离。如果公差还是 $2$ 的倍数，除 $2$ 就行了，最后扣除公差，表示公差中已经不能再进行操作了。右移其实就是在二进制下进行除 $2$ ，但是速度更快。

~~比赛的时候因为我把偶数当成 2 的次方了所以只拿了 10 分~~

---

## 作者：tongyanmin (赞：1)

显而易见，最大操作次数即最多能往原数列中插入几个数。

我们不妨把等差数列写成如下形式：

$$a,a+d,a+2d,...,a+(n-1)d$$

则 $a_i=a+(i-1)d,a_j=a+(j-1)d$。

则 $\frac{x_i+x_j}2=a+(\frac{i+j}{2}-1)d$。

不难发现，若不考虑 $x_i+x_j$ 为偶数的限制，则原数列中的数经过配对后，会形成一个新的公差为 $\frac d2$ 的等差数列：

$$a,a+\frac12d,a+d,a+\frac32d,...,a+(n-\frac32d),a+(n-1)d$$

而使这个数列符合限制的充要条件为 $2\mid d$。

同理再对这个新数列进行同样的操作，会形成一个新的公差为 $\frac d4$ 的等差数列：

$$a,a+\frac14d,a+\frac12d,a+\frac34d,a+d,...,a+(n-\frac54d),a+(n-1)d$$

使这个数列符合限制的充要条件为 $4\mid d$。

以此类推，我们可以发现，每一轮合法的操作都会向数列的两个元素之间插入一个新数。则 $t$ 轮操作之后，对原数列中相邻的两个元素 $a_i,a_{i+1}$ 而言，它们之间都插入了 $2^t-1$ 个元素：
$$ a+(i-1+\frac1{2^t})d,a+(i-1+\frac2{2^t})d,a+(i-1+\frac3{2^t})d,...,a+(i-1+\frac{2^t-1}{2^t})d$$

不难得出最后的计算式为 $s=(n-1)(2^t-1)$，其中 $t$ 为 $d$ 的质因数中 $2$ 的个数。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,d,T;
signed main(){
	cin>>T;
	while(T--){
		cin>>n>>a>>d;
		int cnt=0;
		while(d%2==0){
			d/=2;
			cnt++;
		}
		cout<<(n-1)*((1<<cnt)-1)<<endl;
	}
	return 0;
}
```







---

## 作者：pengzy___ (赞：0)

## 思路：

等差数列，首项和长度都没有什么用，首先要思考公差。

如果公差为奇数，答案肯定是 $0$ 。因为前一个数是奇数，后面的就是偶数，前面是偶数，后面就是奇数，相邻的两项相加肯定不可能是偶数，所以永远不可能满足条件一，也就不能进行操作。

如果公差为偶数，答案是没有规律的。但经过举例可以发现，公差如果为 $2$ 的倍数，是可以生成新的数的。因为公差为偶数，相邻的两数相加肯定也是偶数，满足条件一；而除以二后的数在数列中肯定是没有的，因为两数相邻。一但公差已经不是 $2$ 的倍数了，就不可能再进行操作了。

### 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,a,d;
int main()
{
	cin>>T;
	while(T--) {
		cin>>n>>a>>d;
		if(d&1)cout<<0<<endl;
		else {
			ll dis=(n-1)*d;
			while(d%2==0)d>>=1;
			cout<<dis/d+1-n<<endl;
		}
	}
	return 0;
}
```

$dis$ 变量记录的是首项到末项的距离。如果公差还是 $2$ 的倍数，除 $2$ 就行了，最后扣除公差，表示公差中已经不能再进行操作了。右移其实就是在二进制下进行除 $2$ ，但是速度更快。


---

## 作者：joy2010WonderMaker (赞：0)

### 题目大意

给定一个序列，不断的把序列的公差缩小一半，直到公差变成奇数，求这时的元素个数比最开始多多少。

### 题目分析

很明显当 $d$ 本身就是奇数是根本没有多的。所以来分析 $d$ 是偶数的情况。

我们可以将 $d$ 不断的 $\div 2$，直到是一个奇数为止。在每次除之前都把结果加上 $n-1$，然后将 $n$ 加上 $n-1$。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){//快读
    char c=getchar();
	int x=0;
	bool f=0;
    for(;!isdigit(c);c=getchar())
		f^=!(c^45);
    for(;isdigit(c);c=getchar())
		x=(x<<1)+(x<<3)+(c^48);
    if(f)
		x=-x;
	return x;
}
void write(int x){//快输
	if(x<0)
		putchar('-'),x-=x*2;
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
int T,n,a,d,ans;
signed main(){
	T=read();
	for(int i=1;i<=T;i++){
		ans=0;//多测清空
		n=read(),a=read(),d=read();
		for(;!(d&1);d>>=1)//枚举
			ans+`=n-1,n+=n-1;
		write(ans),puts("");
	}
	return 0;
}

```


---

## 作者：rzh123 (赞：0)

# P8177 题解  

题目链接：[P8177 「EZEC\-11」等差数列](https://www.luogu.com.cn/problem/P8177)  


首先，本题解中所说的“一遍操作”指的是在等差数列中**不选择新加入的数**，进行所有能进行的操作。

## 思路

不妨设每次加入数就从小到大排序，然后就可以得出以下结论：  

### 1. 只有差为偶数的两个数可以操作。

必须差为偶数，才是同奇或同偶，加起来才是偶数。  

### 2. 等差数列中，如果能进行一遍操作，只需要对所有相邻两个数操作。

不相邻的两个数，它们的平均数一定是已经存在的数或已经添加的数。  
设 $i \le j$ 且 $i+1 \neq j$,$k=\left\lfloor \frac{i+j}{2} \right\rfloor$  

当 $i+j$ 为奇数时，  

$i+j=2k+1$  

$\frac{x_i+x_j}{2}$  

$=\frac{(x_k-(k-i)\times d)+(x_{k+1}+(j-k-1)\times d)}{2}$  

$=\frac{x_k+x_{k+1}+(j+i-2k-1)\times d}{2}$  

$=\frac{x_k+{x_{k+1}}}{2}$  

这个一定添加过。


当 $i+j$ 为偶数时，  

$i+j=2k$  

$\frac{x_i+x_j}{2}$  

$=\frac{(x_k-(k-i)\times d)+(x_{k}+(j-k)\times d)}{2}$  

$=\frac{2 x_k+(j+i-2k)\times d}{2}$  

$=\frac{2 x_k}{2}$  

$=x_k$  

这个一定本来就有。

### 3. 等差数列经过一遍操作，一定还是等差数列。  

能操作说明公差为偶数，根据 $2$，相邻两个数取平均数并加在它们之间，差会变成原来的 $\frac{1}{2}$。整个数列中每两个之间的差仍然相等，公差变为原来的 $\frac{1}{2}$。  
因为每两个数产生一个新数，所以项数会增加 $n-1$。  

## 解法  

根据上面的结论，只需要记录公差、项数，每次一遍操作，公差除以 $2$，项数加上 $n-1$，重复操作，直到公差为奇数为止。  
答案就是最终的项数减去初始的项数。  

时间复杂度 $\mathcal{O}(\log n)$

## 代码  

```cpp
#include <cstdio>
typedef long long ll;
int main(){
    ll t,n,n0,d;
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%*lld%lld",&n0,&d);
        n=n0;
        while(!(d&1)){
            n+=n-1;
            d>>=1;
        }
        printf("%lld\n",n-n0);
    }
    return 0;
}
```  

[AC 记录](https://www.luogu.com.cn/record/70214670)

---

## 作者：3a51_ (赞：0)

### 思路分析

首先，对于两个数 $a,b$，第一次能够计算需要满足 $a+b$ 为 $4$ 的倍数，第二次需要满足 $a+b$ 为 $4$ 的倍数，以此类推，可以得到第 $n$ 次操作需要满足 $a+b$ 为 $2^n$ 的倍数。

接下来考虑 $a$ 和 $a+d$ 能够进行几次操作。发现和为 $2 \times a+d$，$2 \times a$ 是 $2$ 的倍数，所以只要考虑 $d$ 就行了，并且两端都有 $a$，所以每次操作完了之后再算和还是 $2\times a+?$。

由于相邻两数和永远是奇数，所以无论如何 $d$ 的系数都是奇数。所以每两个相邻元素答案都是一样的。

那每一次操作会增加多少元素呢？不难发现两数之间第一次增加 $1$ 个元素，第二次增加 $2$ 个元素，所以第 $i$ 次增加 $2^{i-1}$，总结一下，假如能够操作 $p$ 次，那么总增加元素数就是 $2^0+2^1+ \cdots +2^{p-1}=2^p-1$。设 $d$ 含有 $x$ 个 $2$，于是最终答案就是 $(2^x-1) \times (n-1)$。如果前面的分析没看懂可以看代码。

### code

```cpp
#include<iostream>
#define int long long
using namespace std;
signed main(){
	int t;
	cin>>t;
	for(int i=1;i<=t;i++){//数据组数
		int n,a,d,x=0;
		cin>>n>>a>>d;//读入
		while(d%2==0){//将 d 中的 2 分离出来
			d/=2;
			x++;//x与上同意
		}
		cout<<((1<<x)-1)*(n-1)<<endl;//1<<x 表示 2 的 x 次方
	}
	return 0;
}
```

---


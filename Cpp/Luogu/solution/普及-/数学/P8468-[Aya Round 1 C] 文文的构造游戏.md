# [Aya Round 1 C] 文文的构造游戏

## 题目背景

**Problem Number:** [$\textit{23}$](https://www.luogu.com.cn/training/1392)

众所周知，射命丸文和琪露诺是好朋友。但是文是大妖怪，非常聪明，而琪露诺是个笨蛋。为了提升琪露诺的智商，文便给琪露诺出了一道简单的题目。

## 题目描述

对于一个长度为 $l$ 的数列 $p$，定义 $S(p)$ 为所有元素的**异或和**，其中 $\oplus$ 指[按位异或运算](https://baike.baidu.com/item/%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C)。

给定整数 $s,m$，判断能否构造一个长度为 $n$（$n$ 值自定）的数列 $a$，满足：

- $1 \le n \le m$。
- $1 \le a_i \le s$。
- $S(a)=0$。
- $a_1+a_2+\cdots+a_n=s$。

试构造任意一组合法解或报告无解。

## 说明/提示

### 样例解释

- 对于数据 $1$，容易发现 $3\oplus5\oplus6=0$，$3+5+6=14$。符合要求。
- 对于数据 $2$，发现数列 $\{3\},\{1,2\},\{1,1,1\}$ 均不符合要求，故无解。

### 数据范围与约定

对于 $100\%$ 的数据，有 $1\le s\le 10^{18}$，$1 \le m$，$1 \le \sum m \le 10^6$。

**友情提示，您可能需要使用较快的 I/O 方式。**

## 样例 #1

### 输入

```
2
14 9
3 3```

### 输出

```
3 3 5 6
-1```

# 题解

## 作者：chen_zhe (赞：23)

# 文文的构造游戏

## 解法

观察到当 $m=1$ 则必定无解。

当 $m=2$ 时，对于偶数 $s$，可以将其拆成两个 $\dfrac{s}{2}$，这样异或和为 $0$ 且加起来为 $s$。即，当 $s$ 为偶数且 $m \geq 2$ 都存在一种构造方式。

当 $s$ 为奇数时是必定无解的。将 $s$ 拆成若干个正整数相加，会发现 $a_1,a_2,\dots,a_n$ 的二进制最末位必定出现奇数次 $1$，这就使得 $1$ 无法完全抵消，最后的 $a_1 \operatorname{xor} a_2\operatorname{xor} \dots a_n$ 的最小值也是 $1$。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        long long s,m;
        cin >> s >> m;
        if (m==1 || (s&1))
            puts("-1");
        else
            cout << 2 << " " << s/2 << " " << s/2 << endl;
    }
    return 0;
}
```

---

## 作者：落花月朦胧 (赞：3)

update 1 2022/8/8： 根据评论更改了小错误。

# 题意

构造。
你需要构造一个长度不大于 $m$ 的数组。

以下使对于这个数组的要求:


+ 数组内所有元素异或和为 $0$
+ 数组内所有元素的和为 $s$

如果无解输出 `-1`。


# 题解

从位运算的角度思考，只要满足任何一个二进制位出现的次数为偶数就可以满足异或和为 $0$ 的条件。

显然，想要满足上面的条件，这个数组里不同元素出现的次数一定是偶数。

于是就要求和为偶数，那么无解的情况就可以判断了：
只要 $s$ 不是一个偶数，就报告无解。

由于长度不大于 $m$，我们就要想一个长度最短的数组。

显然，由于 $s$ 是一个偶数，我们不妨把它除以 2，得到两个相同的数，直接满足了条件。

于是对于任意的 $s$，我们都有了最小长度的构造方案，判断一下 $m$ 是否大于等于 $2$ 即可。

这种构造出的很好，按照思维的路线一路思考下去就可以得到答案，代码也很简单。

```cpp
void solve() {
    int m; i64 s;
    std::cin >> s >> m;
    if (s & 1 || m < 2) {
        std::cout << -1 << '\n';
        return;
    }
    std::cout << 2 << " " << i64(s >> 1) << " " << i64(s >> 1) << '\n';
    return;
}
```

---

## 作者：xzy090626 (赞：1)

# P8468 题解
## 前言
这题一看十分难懂，导致很多人不敢做就跳了，但其实非常容易，就是这异或和赛时确实让很多人蒙了。
## 分析
一眼性质题。

首先看到需要报告无解情况，所以我们先考虑什么时候会出现无解。

手玩几组数据观察可得，当 $m=1$ 时，由于 $1 \le s$，所以此时唯一的 $a_i = s \ge 1$，异或和肯定不为 $0$，无解。

我们其实没有必要去枚举 $n$ 的取值。通过异或和的性质可知，一个数异或上它本身一定为 $0$。那么我们可以直接使 $n = 2$，$a_1 = a_2 = {1 \over 2}s$。容易发现这种解法一定正确。

这时有同学就要问了：那如果 $s \bmod 2$ 的值为 $1$ 怎么办？

显然无解，因为此时一定有至少一个二进制位无法通过异或变为 $0$。

但是不要忘了，题目并没有说 $s \ge m$。但是因为 $a_i\le1$，所以此时一定无解。
## 实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int rd(){
    int ret = 0,f=1;
    char c = getchar();
    while(!isdigit(c)){
    	if(c=='-') f = -1;
    	c = getchar();
	}
    while(isdigit(c)){
    	ret=ret * 10 + c - '0';
		c = getchar();
	}
    return ret*f;
}
signed main(){
	int T = rd();
	for(int i=0;i<T;++i){
		int s = rd(),m = rd();
		if(s<m || s%2 || m==1) puts("-1");
		else printf("2 %lld %lld\n",s/2,s/2);
	}
	return 0;
}
```
完结撒花。

---


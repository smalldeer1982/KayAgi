# 毕业后

## 题目背景

毕业后，同学们都在热烈讨论高中的计划。所有人总是难以避开一个话题——学考。

在浙江，高中生除了要参加普通高等学校招生全国统一考试（简称高考）以外，还要参加普通高中学业水平考试（简称学考）。学生要在高一下、高二上和高二下各参加一次学考。

## 题目描述

**注意：题目中的部分描述可能和现实有所出入。**

学考会考查高中所有科目，并根据成绩分层评级，自高到低为 A~E。每门科目都会按照一个确定的比率 $w$（所有学科都相同）确定 E 等人数。如果学考有**大于一门**科目拿到了 E 等（不合格），该学生将不能毕业。

在另一个平行世界里，高中总共有 $a$ 门科目。全省共有 $b$ 名考生。如果 E 等的分数线过高，可能会导致总存在某些人毕不了业的情况。现在，考试院院长找到了你，希望你确定学考 E 等占所有考生的**最大**比例（即，最大化 $w$ 的值），使得**存在**至少一种方案，能使浙江所有考生都能毕业。

如果按照某个比例算出来的 E 等考生数不为整数，则将考生数**向上**取整。

## 说明/提示

#### 样例 1 解释

将 E 等比率设成 $\frac{1}{2}$，此时每门科目都恰好有一名考生不合格。当第一名考生在第一门科目不合格，第二名考生在第二门科目不合格时，所有考生都能毕业。所以 $\frac{1}{2}$ 是满足要求的。

可以证明不存在更优的方案。

### 数据规模与约定

对于所有数据，$1\le a, b\le 10000$。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|}\hline
\bf{测试点} & \bf{特殊性质}
\\
\hline
1\sim3 & b=1\\\hline
4\sim6 & a=b \\\hline
7\sim10 & /\\\hline
\end{array}
$$

做完这道题，你能否说明，为什么现实中，浙江 E 等不能超过 $5\%$ 呢？

## 样例 #1

### 输入

```
2 2```

### 输出

```
0.5000000000000000```

## 样例 #2

### 输入

```
114 514```

### 输出

```
0.0077821011673152```

## 样例 #3

### 输入

```
191 9810```

### 输出

```
0.0051987767584098```

# 题解

## 作者：5ab_juruo (赞：9)

简单推式子题。也可以找规律。

### subtask1

$b=1$ 即只有一名考生。对于所有学科，E 等人数要么是 $0$ 要么是 $1$。

如果 $a=1$ 则答案为 $1$，否则答案就是 $0$。

### subtask2

$a=b$ 是给式子推错的选手送的分。

### subtask3

显然要将 E 等尽可能摊到每个人身上各一个最优。

设 E 等比率为 $w$。即：
$$
\begin{aligned}
   a\lceil bw\rceil &\le b\\
   \lceil bw\rceil &\le \frac{b}{a}\\
\end{aligned}
$$
这里直接把 $b$ 消掉是错的，如果真的这么干，那就跌到子任务 2 去了。

注意到 $\lceil x\rceil\le y \Leftrightarrow x\le \lfloor y\rfloor$。所以：
$$
\begin{aligned}
    bw&\le \left\lfloor\frac{b}{a}\right\rfloor\\
    w&\le \frac{\left\lfloor\frac{b}{a}\right\rfloor}{b}
\end{aligned}
$$

```cpp
/* name: b
 * author: 5ab
 * created at: 22-07-02 21:38
 */
#include <iostream>
#include <iomanip>
using namespace std;

typedef long long ll;

signed main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int a, b;
	
	cin >> a >> b;
	cout << fixed << setprecision(10) << double(b / a) / b;
	
	return 0;
}
```



---

## 作者：hycqwq (赞：7)

## 简化题面

简单来说，就是有 $a$ 门科目和 $b$ 个考生，每科最后 $w$（$w$ 是比例）的考生不及格，如果一个考生有 $2$ 科或更多科目不及格则无法毕业。

## 思路

一个很简单的容斥原理，每科 E 等人数之和不能超过 $b$，即每科 E 等人数最多为 $\lfloor b \div a \rfloor$。

最后再把每科最多 E 等人数除以 $b$ 得到它在全部考生中的占比，$w_{\max} = \dfrac{\lfloor b \div a \rfloor}{b}$。

## 代码

```cpp
#include <cstdio>
using namespace std;

int main()
{
	int a, b;
	scanf("%d%d", &a, &b);
	printf("%.15lf\n", 1.0 * (b / a) / b);//记得(b / a)加括号，因为要取整
	return 0;
}
```

双手奉上评测记录，~~请慢用~~：[R85977937](https://www.luogu.com.cn/record/85977937)。

---

## 作者：Adolfo_North (赞：3)

这道题其实二分答案也可以做，因为其答案具有单调性，请看第一个样例输出为 $0.5$，那么 $0.4$ 这个答案可以吗，显然是可以的。

不会二分，请移步[二分查找与二分答案](https://www.luogu.com.cn/training/111)。

二分也没啥好讲的，直接看代码吧。不得不说 $O(1)$ 的大佬是真厉害。
```
#include<iostream>
#include<math.h>
using namespace std;
double m=0.00000000001;//由于题目开了Special Judge,m=1/10^6应该也能过 
int a,b;
bool check(double mid){
	int p;
	p=ceil(b*mid)*a;//利用ceil函数向上取整 
	return p<=b;
}
int main()
{
	cin>>a>>b;
	double l=0,r=1,mid,ans=0;
	while(r-l>=m){
		mid=(l+r)/2;
		if(check(mid)){
			ans=mid;//记得存结果哦 
			l=mid+m;//将比例上调 
		}
		else{
			r=mid-m;//将比例下降 
		}
	}
	cout<<ans;
    return 0;
}

```


---

## 作者：_XHY20180718_ (赞：2)

一道推式子题目，可以说**读懂题意**并列出式子就能想到。
## 简要题意：
给出 $a$ 和 $b$,求：
$$
\left\lfloor abx\right\rfloor=b
$$
## 题解：
众所周知：
$$
\left\lfloor\dfrac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor=\left\lfloor\frac{a}{bc}\right\rfloor
$$
所以我们很简单就能推出：
$$
x=\frac{\left\lfloor\frac{a}{b}\right\rfloor}{b}
$$
## 代码：
```cpp
#include<bits/stdc++.h>
#define re register
#define int long long
#define gt getchar
using namespace std;
int n,a,b;
double ans;
string s;
inline int read()
{
	re int x=0;
	re char ch;
	while(ch<48||ch>57)ch=gt();
	while(ch>=48&&ch<=57)x=(x<<1)+(x<<3)+(ch^48),ch=gt();
	return x;
}
signed main()
{
	a=read(),b=read();
	ans=1.0*(b/a)/b;
	printf("%.16lf",ans);
	return 0;
}
```

---

## 作者：Tzs_yousa (赞：2)

# 思路
由题意我们知道一个人要是想毕业，最多只能有一个不合格，那我们最坏的情况就是每个人拿一个不合格，然后恰好是一种成立的所有人都可以毕业的情况。

那就是有多少人就一共有多少个 $E$ 等，所以平分到每个科目就是有 $b / a$ 个，这里向下取整就可以，因为所有人都要毕业，那已经知道了多少个 $E$ 等，直接再除以总人数就可以了。

# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a, b;

signed main() {
	scanf("%lld%lld", &a, &b);
	double x = b / a;
	printf("%.16lf", x / b);
	return 0;
}
```


---

## 作者：ran_qwq (赞：2)

额，题解好像没有二分的，我来发一下。

首先，题目是个最小值最大的问题，所以可以用二分求解。

然后，设当前 E 等分数线为 $x$，那么一门科目 E 等人数为 $\lceil bx\rceil$。因为每人不能在两门科目取得 E 等，所以 $a\lceil bx\rceil\leq n$。二分 $x$ 求解即可。

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=1e5+10;
int a,b;
signed main()
{
	scanf("%d%d",&a,&b);
	double l=0,r=1;
	while(r-l>1e-12)
	{
		double mid=(l+r)/2;
		if(a*ceil(b*mid)<=b)
			l=mid;
		else
			r=mid-1e-12;
	}
	printf("%.15lf",l);
	return 0;
}
```


---

## 作者：xiaohaoaibiancheng66 (赞：2)

# 思路
设 $r$ 为**每科的不及格人数**，则 $r \times a \le 1 \times b$，要求 $\dfrac{\max r}{b}$。

则整理式子后，得出：求 $\dfrac{\lfloor \frac{b}{a}\rfloor}{b}$。

根据**容斥原理**，一定会有一个符合要求的方案。
# AC code
```cpp
#include<bits/stdc++.h> 
using namespace std;

int main()
{
	double a,b;
	cin>>a>>b;
	int rs=b/a;//向下取整
	double ans=rs/b;
	printf("%.10f",ans);
	return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：0)

分享一个神奇的做法 ~~（其实是由于化简柿子失误发现的）~~：
## 思路
设要求的数为 $x$，那么我们可以列出一个不等式：$\lceil b\times x\rceil \times a\leq b$。  
怎么化简呢？~~不会了，于是乱搞~~：

我们先把向上取整摘掉：  
原式就可以化为 $x\times a\leq 1$。  
此时 $x$ 的最大取值就是 $\dfrac 1a$。

而这时，因为向上取整，我们算出来的 $\lceil b\times x\rceil \times a$ 不一定能小于等于 $b$。  
怎么办呢？枚举！

因为输出与答案的差的绝对值只要在 $10^{-6}$ 之内就算正确，所以 $x$ 可以每次减去 $10^{-6}$ 后检查原式，满足时输出 $x$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,x;
const double eps=1e-6;
int main(){
	cin>>a>>b;
	x=1.0/a;
	while(ceil(b*x)*a>b)x-=eps;
	cout<<fixed<<setprecision(20)<<x;
}
```


---

## 作者：fengxiaoyi (赞：0)

2022.9.8 18:13 修改了部分错别字。

~~考场蒙了 $20$ 分，看完 5ab 的讲解才会的~~

## 题意

给你两个正整数 $a,b$ 且 $1\le a,b \le 10000$，让你求使得 $\lceil bx\rceil\le\frac{b}{a}$ 的最大 $x$。

## 解法

题意已经讲得很清楚了，就是解这个方程了。

**暴力枚举？** 这显然不行。

所以我们看一下面的式子：
$$\lceil x\rceil\le y\Leftrightarrow x\le\lfloor y\rfloor$$
这个式子的意思是如果 $\lceil x\rceil\le y$，则 $x\le\lfloor y\rfloor$。

### 证明

考虑**反证法**，也就是如果 $\lceil x\rceil\le y$，而 $x\gt\lfloor y\rfloor$

由 $x\gt\lfloor y\rfloor$ 可得 $\lfloor x\rfloor\ge\lfloor y\rfloor$。

那么 $\lceil x\rceil$ 一定会比 $y$ 大，矛盾，所以命题成立。

就这我们就可以把 $\lceil bx\rceil\le\frac{b}{a}$ 变成 $x\le\frac{\lfloor\frac{a}{b}\rfloor}{b}$。

这样我们只要求 $\frac{\lfloor\frac{a}{b}\rfloor}{b}$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
inline int read(){
   int x=0;
	bool flag=0;
   char ch=getchar();
   if(ch=='-'){
    	flag=1;
	}
   while(ch<'0'||ch>'9'){
      ch=getchar();
	}
   while(ch>='0'&&ch<='9'){
   		x*=10,x+=ch-'0',ch=getchar();
	}
   if(flag) return -x;
   return x;
}
int main(){
	a=read(),b=read();
	printf("%.10f\n",1.0*ci(b/a)/b);
	return 0;
}
```


---

## 作者：ArcherHavetoLearnWhk (赞：0)

### 题意：

学考有 $a$ 门科目，$b$ 名考生，每科有 $w$ （比率）的人 E 等。如果考生有大于一门科目 E 等就无法毕业。在所有学生都可能毕业的情况下最大化 $w$  的值。

### 解题思路：
每个考生至多一科是 E 等才能毕业，要想最大化 $w$，则设每个考生都有一门学科是 E 等，总共 $b$ 个 E 等。算出每科最多有 $\lfloor b/a\rfloor$ 个人 E 等（共 $b$ 个人给 $a$ 门科分），那么在每一科考试中这些 E 等的占参考人数（ $b$ 人）的比率最大（答案）为 $\Large\frac{\lfloor b/a\rfloor}{b}$ 。

### 极短代码：
```cpp
#include<bits/stdc++.h>
double a,b,c;
int main(){
    scanf("%lf%lf",&a,&b);
    printf("%.12lf",floor(b/a)/b);
}
```
**小技巧：** 如果看不懂题目/想不到解法应该分析一下样例。我发现样例中给出的 $b*w$ 为整数（用计算器算），$b$ 和 $w$ 有一定关联，然后我如此 2min 就想出了正解。

（这次模拟赛题目质量非常好，我受益匪浅）

---

## 作者：Ask_sum (赞：0)

# P8507 毕业后 题解

[题目传送门](https://www.luogu.com.cn/problem/P8507)

很明显，题目的意思就是叫你求出最大的 $w$，使得**没有一个人**会不合格的科目数量大于 $1$。

## Sol 0 顺序遍历 0pts

从小到大顺序遍历求最大的 $w$。

很显然，若 E 等人数比率为 $w$，每门科目就会挂掉 $\lceil bw \rceil$ 个人，那么 $a$ 门科目总共会挂掉 $a\left\lceil bw \right\rceil$ 个人，然而由于每个人**最多只能挂掉一门**，所以总共 $b$ 个人最多只能挂掉 $b$ 门科目。

所以由此易得 $a\left\lceil bw \right\rceil \leq b$，由此从小到大找 $w$ 判断一下符合不符合就行了。

~~（我觉得没有哪个正常的人会选择用这种方法吧）。~~

## Sol 0.5 二分答案 50pts

同样是想办法求出最大的 $w$，还是过不了，但比上一个解法已经好很多了。~~（至少比纯暴力好多了）。~~

原理就是二分求 $w$，至于怎么判断和上面一样。

## Sol 1 数学法 正解

实际上，能想出前两个解法中的判断 $w$ 允不允许怎么写，就应该能马上想到正解了。

既然已有刚才的式子 $a\left\lceil bw \right\rceil\leq b$，

然后对它变形可得 $\left\lceil bw \right\rceil\leq\dfrac{b}{a}$，

$\because$ 若存在 $\left\lceil m \right\rceil\leq n$ 则一定有 $m\leq\left\lfloor n \right\rfloor$

$\therefore bw\leq\left\lfloor\dfrac{b}{a}\right\rfloor$

$\therefore w\leq\dfrac{\left\lfloor\dfrac{b}{a}\right\rfloor}{b}$

此时，若想要使得 $w$ 最大，很显然 $w=\dfrac{\left\lfloor\dfrac{b}{a}\right\rfloor}{b}$，答案就自然出来了。


注意精度~

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
double a, b;
int main(){
	cin >> a >> b;
	printf("%.16f", floor(b / a) / b);//就是刚才推出来的公式
	return 0;
}

---

## 作者：封禁用户 (赞：0)

## 题意简述

给你两个正整数 $a$ 和 $b$。代表有 $a$ 门学科，$b$ 位考生。

其中每门不及格的人数为 $\lceil b \times w \rceil$，如果一位考生有 $\geq 2$ 门学科为不及格，那么他将无法顺利毕业。

试求最大的 $w$，使得所有考生最后都能够顺利毕业。

本题使用自定义校验器，与标准答案之间的绝对误差在 $10^{-6}$ 以内的结果都算作正确答案。

## 题目分析

很明显：如果每位考生正巧有 $1$ 门考生不合格，那么我们此时的 $w$ 就能够最大。即：$\lceil b \times w \rceil \times a = b$。

### 暴力乱搞

因为这一题的答案的误差只要在 $10^{-6}$ 以内即可 AC，所以我们就可以从 $1$ 开始枚举，每一次减去 $10^{-7}$，一旦发现合法就输出。这样我们最多要枚举 $10^7$ 个数，很明显不会 TLE。

这是我在考场上的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

void fastio() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
}

int main() {
	fastio();
	double a, b, w = 1.0;
	cin >> a >> b;
	while (ceil(b * w) * a > b) w -= 0.000001;
	cout << w << endl;
	return 0;
}
```

### 推式子（正解）

上文的运行时间还是不够快，我们有没有一种方法能更快地解决这道题呢？很明显我们需要推式子。

由 $\lceil b \times w \rceil \times a = b$ 得 $\lceil b\times w \rceil = \frac{b}{a}$。因为 $\lceil a \rceil \leq b$ 即为 $a \leq \lfloor b \rfloor$，所以我们可以把式子变为 $b \times w = \lfloor \frac{b}{a} \rfloor$，即为 $w = 
\frac{\lfloor \frac{b}{a} \rfloor}{b}$，直接输出答案即可。

$O(1)$ 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

void fastio() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
}

int main() {
	fastio();
	double a, b;
	cin >> a >> b;
	cout << floor(b / a) / b << endl;
	return 0;
}
```

AC 代码因为上文已经有了就不放了。

---

## 作者：immortal_water (赞：0)

前置芝士：[抽屉原理](https://cn.bing.com/search?q=%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86)

前言：不太理解公式为什么能 AC，毕竟在我的认知里过程中取整的题用公式套会 WA（也可能是我蒟蒻了 233），所以这篇题解是二分。

### 目录:

1. 判别式；

1. 普及 - 特有的二分讲解；

## 判别式

首先，每科要有 $\lceil b\times w\rceil$ 个人不合格，则不合格的总人次为 $a\times\lceil b\times w\rceil$，如果把每个学生看做集合，把不合格的人次看做元素，根据[抽屉原理](https://cn.bing.com/search?q=%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86)，那当总人次大于总人数时必有一个人有两科不合格，此人无法毕业。

所以判别式是 $a\times\lceil b\times w\rceil\leqslant b$，代码表现为 `a*ceil(b*w)<=b`

## 普及 - 特有的二分讲解

二分，顾名思义，每次把答案区间分成两份，通过判断中点值来舍去左区间或右区间，最后答案区间的长度满足要求就结束。

能用二分的题必须满足如下条件：已知一种不严格单调的对应关系（函数）$f(x)$ 和一个 $ans$，求 $a$ 使 $f(a)=ans$。

因为 $f(x)$ 是单调函数所以如果有 $f(m)>ans$ 则 $\forall x\in (m,+\infty),f(x)>ans$ （单调递增）或 $\forall x\in (m,+\infty),f(x)<ans$ （单调递减）。

二分的一般形式如下：
```cpp
	int l=0,r=MAX;//答案区间
	for(;r-l>0;)//循环到答案区间长度为0,即只有一个答案
	{
		int m=(l+r)/2;
		if(f(x)<ans)l=m+1;//这里是单增的情况,因为int型取中点会自动取整,手动+1防止死循环
		else r=m;
	}
	cout<<l;//左右端点都是答案
```
那么对于这一题来说，判别式的左边 $f(w)=a\times\lceil b\times w\rceil$ 就很明显是一个单增函数了，所以：
```cpp
	double l=0.0,r=1.0;
	for(;r-l>=jd;)
	{
		double m=(l+r)/2;
		if(ceil(b*m)*a<=b)l=m;
		else r=m;
	}
	cout<<l;
```
那么加个输入输出就是 AC 码了。

---

## 作者：oddy (赞：0)

## 题意解释

有 $a$ 门科目，$b$ 名考生。每一门科目会有 $w$ 的考生不及格。最大化 $w$ 使得有一种方案让每名考生至多有一个科目不及格。

## 解题思路

显而易见地，每个科目最多有 $\left\lfloor\dfrac ba\right\rfloor$ 个考生不及格，因为如果再多一个，不及格科目总数就会超过 $b$。这样，根据狄利克雷原理，没有方案使得每名考生至多有一个科目不及格。

所以，最终要求的 $w=\dfrac{\left\lfloor\dfrac ba\right\rfloor}b$。

## 代码

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

long double a, b;

int main() {
    cin >> a >> b;
    cout << fixed << setprecision(20) << floorl(b / a) / b << '\n';
    return 0;
}
```

---

## 作者：arrow_king (赞：0)

# P8507 毕业后

### 题意

>有 $a$ 门科目，有 $b$ 个考生，考生中有 $\left\lceil b\times w\right\rceil$ 名考生会拿到 E 等成绩。若使这 $b$ 名学生中每名学生拿到 E 等成绩的次数都不大于 $1$，最大化 $w$。
>
>$1\leq a,b\leq10^4$，与标准答案绝对误差误差不超过 $10^{-6}$ 的答案即可通过。

### 思路

发现 $1\leq a,b\leq10^4$，还要精确到小数点后 $6$ 位，值域巨大，枚举肯定过不了，所以考虑二分答案。

那么如何二分呢？

首先 $0\leq w\leq1$，所以 $l=0,r=1$，每次找中间值 $mid$ 来判断。关键在判断，即 `check(mid)` 函数上。

这里 `check` 可以用贪心的思路，每门学科都会有 $\left(100\times mid\right)\%$ 的学生得 E，那么 $a$ 个学科就会有 $a\times \left\lceil b\times mid\right\rceil$ 次 E。如果这些“E”能够平均分配到每个学生，使得每个学生最多有 $1$ 次 E，那么 $mid$ 就是可行的，否则就是不可行的。

具体可以看下面这张图：~~（图太丑了，不要在意）~~

![](https://cdn.luogu.com.cn/upload/image_hosting/j7u07o18.png)

图中 $w$ 就是二分的中间值 $mid$。

如果 $a\times \left\lceil b\times mid\right\rceil$ 小于等于 $b$，那 $mid$ 就是可行的。

这就是 `check(mid)` 所要干的事。

## $Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const double eps=1e-7;
int a,b;
bool check(double mid) {
	int sum=0;
	for(int i=1;i<=a;i++) sum+=ceil(b*1.0*mid);		//统计得E的人次数
	return sum<=b;
}
int main() {
	scanf("%d%d",&a,&b);
	double l=0,r=1,best=0,mid;
	int step=100;
	while(step--) {		//实数二分，二分上100次精度就很足够了，精度可以达到1e-16，也就是样例的精度
		mid=(l+r)/2;
		if(check(mid)) {		//mid可行
			l=mid;
			best=mid;
		}
		else r=mid;
	}
	printf("%.16lf\n",best);
	return 0;
}
```

---

## 作者：McIron233 (赞：0)

在适当的理解题目后，可以发现简要题意：给定两个实数 $a,b$，求 $\max(w)$，满足 $a \lceil bw \rceil \leq b$。

### 考场做法：二分
实际得分 $50$

考虑到 $0 \leq w \leq 1$，于是对答案二分，循环多次求解，最后输出答案。考场代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)
#define FILE freopen("test.in","r",stdin);freopen("test.out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
#define int long long
#define I inline
#define N 100005
#define modd 32767
using namespace std;
double a,b;
signed main(){
    cin>>a>>b;
    double rate=b/a,mid;
    for(double l=0,r=1,i=1;i<=114514;mid=(l+r)/2.0,i++){
    	if(ceil(mid*b)==rate)break;
    	else if(ceil(mid*b)<rate)l=mid;
    	else r=mid;
	}
	printf("%.16lf",mid);
	return 0;
}
```

### 正解：数学
我们可以对这个式子 $a \lceil bw \rceil \leq b$ 进行转化。则有：
$a \lceil bw \rceil \leq b \Leftrightarrow \lceil bw \rceil \leq \frac{w}{a}$

此时，我们需要考虑将 $b$ 移到右边，但是我们**不可以直接将它往右边挪**，否则会影响到答案。

那么，我们就需要把这个向上取整去掉。

考虑到 $\lceil x \rceil \leq y \Leftrightarrow x \leq \lfloor y \rfloor$，所以 $\lceil bw \rceil \leq \frac{b}{a} \Leftrightarrow bw \leq \lfloor \frac{b}{a} \rfloor$，于是正解呼之欲出：$w \leq \frac{\lfloor \frac{b}{a} \rfloor}{b}$，题目欲求 $\max(w)$，所以答案就是 $\frac{\lfloor \frac{b}{a} \rfloor}{b}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b;
signed main(){
    scanf("%lf%lf",&a,&b);
    printf("%.16lf",floor(b/a)/b);
	return 0;
}
```

---


# 『JROI-8』雷雨天特别行动科

## 题目背景

![1663764044201.png](https://img-kysic-1258722770.file.myqcloud.com/639b5f084b6aa779f0a90253f9eef153/b2f5e91db29b9.png)

>“天使可没有假期”\
“啊，又来了……还是不要勉强自己会比较好哦”

**已获得转载授权。**

## 题目描述

对于**非负整数**变量 $x$，记以下为一轮操作：

1. 将 $x$ 增加 $1$；
2. 如果 $x$ 是 $3$ 的倍数，则将 $x$ 除以 $3$。

给定初始的 $x,k$，试求 $k$ 轮操作后 $x$ 的值。

**请注意，大样例不以文件附加形式给出，而直接放在题目的 输入输出样例 中的 样例 #3**

## 说明/提示

【样例解释】

对于样例一， $x$ 的变化过程如下：$1\rightarrow 2\rightarrow (3\rightarrow 1)\rightarrow 2$。

其中括号内为一次操作。

【数据范围与提示】

对于全部的测试数据，满足 $0\leq x,k\leq 10^{18}$。

**特别的，第 $1\sim 2$ 测试点中的 $k\leq 0$ 等价于 $k=0$，$3\sim 4$ 的 $x$ 同理**。

| 测试点编号 | 分数 | $x\leq$ | $k\leq$ |
| -----------: | -----------: | -----------: | -----------: |
| $1\sim 2$ | $20$ | $5$ | $0$ |
| $3\sim 4$ | $20$ | $0$ | $10^{18}$ |
| $5\sim 6$ | $20$ | $10^{18}$ | $10^6$ |
| $7 \sim 10$ | $40$ | $10^{18}$ | $10^{18}$ |

## 样例 #1

### 输入

```
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 3```

### 输出

```
5```

## 样例 #3

### 输入

```
1919810 3```

### 输出

```
213313```

# 题解

## 作者：绿野 (赞：14)

### 优化的思路
如题
$0\leq x,k\leq 10^{18}$

然而 $3^{36} \approx 10^{18}$

因此若一直除 $3$，则 $n$ 顶多 $72$ 次运行到达个位。

但到达个位时，就可以找到一处“特殊的数字”来省去之后的运行。

#### 特殊的数字
“一生二，二生三，三生万物。”

此数字就是 $1$。

经过调试很容易得到若剩余奇数次操作结果便为 $2$，不然为 $1$。

### AC
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,k;
int main(){
    cin>>x>>k;
    while(k--){
        x++;
        if(x%3==0)x/=3;
        if(x==1){//对1的特判切记莫放在x++前
            if(k%2==1){
                cout<<2;
                return 0;
            }
            else{
                cout<<1;
                return 0;
            }
        }
    }
    cout<<x;
    return 0;
}

---

## 作者：Tis员工 (赞：11)

### 0 前言
这是本人第二篇题解。

报了比赛，结果中途去上课，从某种角度上来说，我只做了 $10$ 分钟，结果可想而知 $40$ 分，排到 $2000$ 多名去了。

因为没有足够的钱（或者说哪怕五角钱也没有），所以并没有听洛谷的讲评，自己摸索了好久才想出来的。

本题解结构为 $20$ 分 $\to 40$ 分 $\to 60$ 分$\to 100 $分，所以想要直接看正解的就往下拉一下。
### 1 二十分做法
题目非常清晰，所以不解释。

看数据范围的 $1 \sim 2$ 测试点，会发现 $k=0$

直接输出 $x$ ,输出 $20$ 分。
### 2 四十分做法
看数据范围的 $3 \sim 4$ 测试点，会发现 $x=0$

找规律：
- $k = 0$ 时，$x=0$
- $k = 1$ 时，$x=1$
- $k = 2$ 时，$x=2$
- $k = 3$ 时，$x=1$
- $k = 4$ 时，$x=2$
- $k = 5$ 时，$x=1$
- $k = 6$ 时，$x=2$
- ......

所以得到规律：
- 当 $k = 0$ 时，$x=0$
- 当 $k$ 为奇数时，$x=1$
- 当 $k$ 为偶数时(不包括 $0$)，$x=2$

因为 $x$ 的计算过程就是 $1 \to 2 \to (3 \to 1) \to 2 \to (3 \to 1) \to ...$

所以容易得到规律，可得40分。

### 3 六十分做法
看数据范围的 $5 \sim 6$ 测试点，会发现 $k \le 10^6$

直接暴力循环，即可可以得到 $60$ 分代码。
### 4 一百分做法
这道题数据范围，良心大大滴坏，$k≤10^{18}$，而一个程序执行一条语句，执行 $10^8$ 次就会超时。所以暴力循环必然是不能满分的。

但我们可以想一下，我们真的要把 $x$ 算 $10^{18}$ 次吗？如果我能在某个时刻，发现之后 $x$ 与 $k$ 的关系，那么后面的循环可以直接省略掉，从而使时间减少许多。

先看一个东西：当 $x$ 为 $1$ 时：

$1 \to 2 \to (3 \to 1) \to 2 \to (3 \to 1) \to 2 \to (3 \to 1) \to 2 \to (3 \to 1) \to ...$

我们会发现，$x = 1$ 时，无论 $k$ 多大，最后 $x$ 的值只和 $k$ 的奇偶性有关。

那如果 $x$ 不为 $1$ 呢？

其实，随便举几个数算一下就可以发现，只要 $k$ 足够大，那么一定有 $x$ 变成 $1$ 的时候。

因为 $ 3^{30} > 10^{18} > 3^{29} $，所以在最坏情况下，$x$ 变成 $1$ 最多只要 $100$ 次（$30 \times 3 = 90$ ,先大点就 $100$ 了）。

还是举三个数来说明：$x = 3$ , $x = 12$ 和 $x = 37$

| $k$ | $x_1$ | $x_2$ | $x_3$ |
| -----------: | -----------: | -----------: | -----------: |
| 0 | 3 | 12 | 37 |
| 1 | 1 | 4 | 38 |
| 2 | 2 | 5 | 13 |
| 3 | 1 | 2 | 14 |
| 4 | 2 | 1 | 5 |
| 5 | 1 | 2 | 2 |
| 6 | 2 | 1 | 1 |
| 7 | 1 | 2 | 2 |
| ... | ... | ... | ... |

举别的数来试，也会发现，到最后一定是 $1212121212...$ 的循环。所以 $x=1$ 时，要么输出 $1$，要么输出 $2$。

**AC CODE**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,x;
int main()
{
    cin>>x>>k;
    if(x==0){
    	if(k==0)cout<<0;
    	else if(k%2==1)cout<<1;
    	else cout<<2;
    	return 0;
	}
	while(k>0){
		if(x==1){
			if(k%2==1)cout<<2;
			else cout<<1;
         //因为这里的是把k减下去，所以输出与表格相反(k%2是1的时候输出的是2而不是表格中的1)
			return 0;
		}else{
			x++;
			if(x%3==0)x=x/3;k--;
		}
	}
	cout<<x;
	return 0;
}

```

---

## 作者：CLCK (赞：5)

非常简单的一道题目，但是不要想得太简单（好歹是橙题不是红题（狗头

问题出在题目的数据范围上——发现一道 $10^{18}$ 的题目，不仅要想到 `long long` ，还要注意到以 $\Theta{(K)}$ 的复杂度直接模拟一定是没法通过的。

那么怎么办呢？仔细阅读题目发现，$x$ 始终在 $3$ 的余数中产生循环，因此打个表可以发现规律：

```
19 20 21->7 8 9->3 4 5 6->2 
3->1 2 3->1 2 3->1 2 3->1 ...
```

既然如此，我们可以发现：如果 $x$ 比 $2$ 大前就结束循环，则可以直接输出计算的值，且因为 $\log_{3}{10^{18}}\approx38$，在 $38 \times 3$ 左右次循环中即可实现，复杂度可以通过；如果 $x$ 最后等于 $1$ 或 $2$，则说明它已经进入了 `1->2` 的循环之中，只需要通过 $k$ 的奇偶性分类讨论即可。

以下是代码。

```cpp
#include <iostream>
using namespace std;
long long x, k;
int main() {
	cin >> x >> k;
	while (k--) {
		x ++;
		if (x % 3 == 0) x /= 3;
		if (x == 1) break; //在x=2时没有break，是为了减少后续处理的难度
	}
	if (k <= 0) cout << x << endl;
	else if (k % 2 == 0) cout << 1 << endl;
	else if (k % 2 == 1) cout << 2 << endl;
	return 0;
}
```

完结撒花～


---

## 作者：zhangyuanxiao (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8588)

## 题意
- 对**非负整数** $x$ 的一轮操作为：先将 $x$ 加 $1$。如果加 $1$ 后的 $x$ 是 $3$ 的倍数，就将 $x$ 除以 $3$。
- 给定 $x,k$，求 $k$ 轮操作后 $x$ 的值。
- $0 \le x,k \le 10^{18}$。

## 分析
根据题意，我们可以立刻写出朴素的代码，按照题意模拟。代码如下：
```cpp
#include<iostream>
#define int long long
using namespace std;
int x,k;
signed main(){
    cin>>x>>k;
    while(k--){
        x++;
        if(x%3==0) x/=3;
    }
    cout<<x;
    return 0;
}
```
然而只拿了 $40$ 分，**TLE** 了六个点。当 $k=400000000$ 时，在洛谷在线 IDE 上运行就已经超时了。我们必须要加一些优化。

- 当 $x \equiv 0 \pmod 3$ 时，$3$ 次操作后，$x$ 就会变为 $\dfrac{x}{3}+1$。

- 当 $x \equiv 1 \pmod 3$ 时，$2$ 次操作后，$x$ 就会变为 $\dfrac{x+2}{3}$。

- 当 $x \equiv 2 \pmod 3$ 时，$1$ 次操作后，$x$ 就会变为 $\dfrac{x+1}{3}$。

可以发现，最多经过 $3$ 次操作，$x$ 就会变为原来的 $\dfrac{1}{3}$。因此 $x$ 会一直缩小。当 $x$ 缩小到 $1$ 后，接下来再操作时，$x$ 会按照下面的规律变化：

$1\rightarrow 2\rightarrow 1\rightarrow 2\rightarrow\cdots$。

所以我们可以在 $x$ 变为 $1$ 后，直接用奇偶性判断输出 $1$ 还是 $2$。时间复杂度 $O(\log_3x)$，足够通过本题。

## 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int x,k;
signed main(){
	cin>>x>>k;
	while(k--){
		x++;
		if(x%3==0) x/=3;
		if(x==1){
			if(k%2==0) cout<<1;
			else cout<<2;
			return 0;
		}
	}
	cout<<x;
	return 0;
}
```

如有错误，欢迎私信指出。


---

## 作者：YH_Eternally (赞：2)

## 题意
给定一个数 $x$，定义一次操作为 
1. 将 $x$ 增加 $1$；
1. 如果 $x$ 是 $3$ 的倍数，则将 $x$ 除以 $3$。

问 $k$ 次操作后，$x$ 的值。

## 思路
最开始思路：$O(k)$ 大暴力，准备交后再一看数据范围：$k \leq 10^{18}$。~~人差点没了~~。

十分明显的找规律题，手造了一组 $k$ 比较大的数据后发现 $x$ 到 $1$ 之后就会一直按照一个规律变化：$1 \to 2\to 3\to 1\to 2\to \cdots$。

于是就有了一下思路：

- 当 $x=0$ 时，先操作 $3$ 次，也就是将 $k$ 减去 $3$，如果 $k<0$，答案就是 $k+3$。否则，就依照上面的规律推出答案公式 $ans=1+k\bmod2$。时间复杂度为 $O(1)$。
- 当 $x \not= 0$ 时，可以先暴力将 $x$ 变换到 $1$，如果变换过程中 $k<0$，答案就为 $x+k$。如果在 $x=1$ 后 $k$ 依然大于 $0$，就可以依照上面的公式得出答案公式 $ans=1+k\bmod2$。由于 $n$ 最高就是 $10^{18}$，变化到 $1$ 最多只用 $2\times \log_3n$ 次，所以时间复杂度为 $O(2 \times \log_3x)$。

**注意：记得开 `long long` !**

## 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

inline long long read() {
    long long x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();}
    return x * f;
}

int main() {
	long long x, k;
	x = read();
	k = read();
	if(x == 0) {// 特判 x = 0 的情况
        k -= 3;
		if(k < 0) {
			printf("%lld\n", k + 3);
			return 0;
		} else {
			printf("%lld\n", 1 + k % 2);
			return 0;
		}
	}
	while(1) {
		long long lsbl = x % 3;
		if(lsbl == 1) x += 2, k -= 2;
		else if(lsbl == 2) x += 1, k -= 1;
		else x += 3, k -= 3;
		if(k < 0) {
			printf("%lld\n", x + k);
			return 0;
		}
		x /= 3;
		if(x == 1) {
			printf("%lld\n", 1 + k % 2);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：xwh_Marvelous (赞：2)

这一题好像这一题 [P5727](/problem/P5727)。

但是略难一点。

根据样例解释，我们能看到当 $x\in \{1,2\}$ 时，$x$ 会不断 $1,2$ 里循环。剩下的就是确保无论什么数，经过若干次操作能变为 $1$。

我们在小学三年级就学过：

$$\because \sum_{i=1}^{\left\lfloor\log_{10}x\right\rfloor+1}x \bmod 10 \equiv0\pmod{3} $$
$$\therefore x\equiv0\pmod{3}$$

直白地说就是一个数各个位数上的数之和如果是 $3$ 的倍数，那么这个数也是 $3$ 的倍数。

那么就可以看出，最多连续 $3$ 次的操作无法除以 $3$。

又因为连续加三次后，对于除以 $3$ 后的数最多也就是增加 $1$，而这是肯定比不上原本数的三分之二。

描述成数学：

$$\left\lfloor\dfrac{x}{3}\right\rfloor+1\le\dfrac{2x}{3}\ (x\ge3)$$

那么我们就可以确保 $x$ 在 $O(\log_3x)$ 的时间里能逐步缩成 $1$。

$x=0$ 时也没必要特判，因为经过一次操作后也会变成 $1$。

**AC code**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,k;
int main(){
	scanf("%lld%lld",&x,&k);
	while(k&&x!=1){
		x++;
		if(x%3==0)x/=3;
		k--;
	}
	if(k==0)printf("%lld",x);
	else{
		k%=2;
		if(k==1)printf("2");
		else printf("1");
	}
	return 0;
}
```


---

## 作者：joyslog (赞：2)

## 『JROI-8』雷雨天特别行动科


对于**非负整数**变量 $x$，记以下为一轮操作：

1. 将 $x$ 增加 $1$；
2. 如果 $x$ 是 $3$ 的倍数，则将 $x$ 除以 $3$。

给定初始的 $x,k$，试求 $k$ 轮操作后 $x$ 的值。

$0\le x,k \le 10^{18}$


### 题解

很容易发现，对于任何 $x$，它在进行操作的时候整体趋势是变小的，最终会陷入 $1$ 和 $2$ 的循环。即当 $k \to +\infty$ 时，有 $x \in \{1,2\}$。

于是当 $x = 1$ 时，就可以跳出循环了，然后用剩下的轮数找循环节个数，从而知道是 $1$ 还是 $2$。

不严谨的时间复杂度表示： $O(\min(\log_{3}x, k))$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll read() {
	ll ret = 0, w = 1; char c = getchar();
	while(!isdigit(c)) {if(c == '-')	w = -1; c = getchar();}
	while(isdigit(c)) {ret = (ret << 1) + (ret << 3) + (c ^ 48); c = getchar();}
	return ret * w;
}
inline void write(ll x) {
	if(x < 0)	putchar('-'), x = -x;
	if(x > 9)	write(x / 10);
	putchar(x % 10 + '0');
}

int main() {
	int x = read(), k = read();
	while(x != 1 && k) {
		x++; k--;
		if(x % 3 == 0)	x /= 3;
	}
	if(k)	write(k % 2 ? 2 : 1);
	else	write(x);
	
	return 0;
}
```



---

## 作者：_JF_ (赞：1)


## P8588 『JROI-8』雷雨天特别行动科 

题目大意：给出一个数，每次对他加 $1$，如果加完后是 $3$ 的倍数就除以 $3$ ，问操作 $k$ 次后的结果。

### Subtask 1，3：

枚举操作次数，然后每一次按照题目模拟，时间为 $O(k)$。

### Subtask 2：

对于 $n=0$ ，就必然只会在 $1$,$2$, 中间循环出现，如果 $k$ 是奇数，则为 $1$，偶数即为 $2$。

### Subtask 4

经过 Subtask2 的启发，加上自己手推几个数据，不难发现，一个数，经过 $x$ 次操作，终究可以回到 $1$，$2$ 的循环，这样就可以大大减少循坏次数，只用枚举从 $n$ 变到 $1$ 的次数即可。如果 $k \leq x$ 就在循环内直接输出 $n$ 即可，若 $k > x$ 即回到 Subtask2 。但要注意，这一次 $n=1$。时间 $O(3 \times \log_3k)$。

最后要注意特判 $k=0$ 的情况。

$Code$

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,k,sum=0;
	cin>>n>>k;
	if(k==0)
		cout<<n<<endl,exit(0);
	while(n!=1)
	{
		n++;
		if(n%3==0)
			n/=3;
		sum++;
		if(sum==k)
			cout<<n<<endl,exit(0);
	}
	int now=k-sum;
	if(now%2==0)
		cout<<1<<endl;
	else 
		cout<<2<<endl;
}
```

---

## 作者：Nygglatho (赞：0)

由于如果 $x \bmod 3 = 0$，$x$ 就除以 $3$，那么显然，连续 $x + 1$（指中间不除以 $3$）的次数一定不超过 $3$ 次。

那么只有 $x = 1$ 时，才会保持在 $1 \to 2 \to 1 \to 2 \cdots$，其他情况，$x$ 都会不断减少。

例如 $x = 4$ 时，是 $4 \to 5 \to (6 \to 2) \to (3 \to 1)$。

所以，我们可以先将 $x \ne 1$ 时先枚举出来，接下来再根据剩下操作数的奇偶性（因为是 $1 \to 2 \to 1 \to 2$ 这样循环），判断是 $1$ 还是 $2$。如果剩下是偶数，则答案为 $1$，否则答案为 $2$。

当然，如果 $k$ 实在太小了，在最开始的枚举的时候就用完了，那么直接输出当时的数即可。

时间复杂度约为 $O(\log_3 k)$。

代码：
```c
#include "bits/stdc++.h"
using namespace std;
typedef long long ll;

int main() {
	ll x, k;
	scanf ("%lld%lld", &x, &k);
	for(; ;) {
		if (k == 0ll) {
			printf ("%lld", x);
			return 0;
		} 
		if (x == 1ll) {
			break;
		}
		++x;
		if (x % 3ll == 0ll) x /= 3ll;
		--k;
	}
	//1 -> 2 -> 1
	if (k % 2 == 0) puts("1");
	else puts("2");
}
```

---

## 作者：xiaohaoaibiancheng66 (赞：0)

# 思路
由于对于任意一个 $x$，它最多执行两次操作后就会被除以 $3$，所以它在不超过 $2\times \log_3 x$ 次操作后就会变为 $1$。

最大的 $x$ 仅为 $10^{18}$，所以对于任意的一个 $x$，在不超过 200 次操作后就会变为 $1$,

而对 $1$ 进行 $k$ 次操作，又分两种情况：
- 若 $k$ 为偶数，因为对 $1$ 进行两次操作后还是 $1$，所以此时结果为 $1$。
- 若 $k$ 为奇数，可以理解为操作偶数次后再操作一次，所以此时结果为 $2$。

所以可以得到一个思路：
1. 先对 $x$ 进行操作直到 $x=1$。若未达到条件时已打 $k$ 次，则直接输出当前的 $x$ 并结束程序。
2. 当 $x=1$ 时，对于**剩余的** $k$ 分类讨论即可。

# AC code

```cpp
#include<bits/stdc++.h> 
using namespace std;

int main()
{
	long long x,k;
	cin>>x>>k;
	if(!k)//特判k=0
	{
	    cout<<x;
	    return 0;
	}
	while(x!=1)
	{
		x++;
		if(x%3==0)x/=3;
		k--;
		if(!k)
		{
			cout<<x;
			return 0;
		}
	}
	cout<<k%2+1;//这是一个有意思的写法。
	return 0;
}
```

---


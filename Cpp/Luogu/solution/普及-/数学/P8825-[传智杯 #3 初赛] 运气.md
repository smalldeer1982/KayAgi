# [传智杯 #3 初赛] 运气

## 题目背景

YYH Land(Yoauld,Youthful & Happy Land) 是位于炽蓝仙野的一片神奇的国度，那里的人们过着无拘无束的的快乐生活。

## 题目描述

哈兰·斯威提是 YYH Land 远近闻名的注铅骰子爱好者。有一天他碰到了这么一个问题：

你有一枚 $6$ 个面的骰子，分别写了 $1,2,3,4,5,6$ ，每一面朝上的概率是均等的。

现在哈兰想知道，如果他投掷 $n$ 次，并且将结果按顺序写在纸上成为一个数。（比如说如果哈兰扔了 $3$ 次，分别是 $3,2,5$ ，那么他最后得到的数就是 $325$）他现在想知道这个数是 $k$ 的倍数的可能情况有多少种，其中 $k$ 是一个特定的数。

由于这个方案数可能会很大，所以请你输出结果对 $10^9+7$ 取模的结果。

## 说明/提示

**样例解释**

在投掷两次骰子总共 $36$ 种可能中，只有 $("11","22","33","44","55","66") $ 是符合条件的。所以答案是 $6$。

**数据规模与约定**

对于 $40\%$ 的数据，满足 $n$ 分别为 $1,2,3,4$；  
对于另外 $30\%$ 的数据，满足 $ 1 \leq k \leq 3$；  
对于 $100\%$ 的数据，满足 $1 \leq n \leq 10, 1 \leq k\leq 1000$；

## 样例 #1

### 输入

```
2 11```

### 输出

```
6```

# 题解

## 作者：Ja50nY0un9_as_AgNO3 (赞：14)

想必看到这篇题解的人也看过这个碰运气通过了的[暴力搜索做法](https://www.luogu.com.cn/blog/363302/solution-p8825)吧。

笔者自感跟大牛们的差距，于是去自学了一下数位dp，自认为弄懂了，就有了这篇题解。

### 思路：

因为前面的掷骰不会对之后有所影响，如上所述，考虑数位dp。

我们用 $f_{i,j}$ 表示选到第 $i$ 个数，模 $k$ 余 $j$ 的方法数。

显然，每一个 $f_{i,j}$ 因为在原来的基础上数位增加了一位，所以其余数就增加到了原来的十倍。

那么我们就可以得到转移方程：

```cpp
f[i][(l * 10 + j) % k] += f[i - 1][l];
```

此处 $j$ 枚举的是本次掷出的数，而 $l$ 枚举的是上一次掷骰后构成的数模 $k$ 的余数。

初始状态是，我们在什么都没有掷的时候，模 $k$ 显然只能余 $0$，此时方案为一种。

所以，初始状态是 $f[0][0]=1$。

都想到了这里，想必代码实现就不是问题了。

为了防止有些人无脑复制，我就只放上dp初始化和转移部分的代码吧。

```cpp
f[0][0] = 1;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= 6; j++)
        for (int l = 0; l < k; l++){
            f[i][(l * 10 + j) % k] += f[i - 1][l];
        }
cout << f[n][0];
```

至此，我们就通过数位dp拿到了本道题的正解。

这篇题解的方法就不用卡时了，复杂度 $\Theta(nk)$，可以在三十至四十毫秒内轻松跑过。

---

## 作者：Ja50nY0un9_as_AgNO3 (赞：13)

chen_zhe 曾经在 P8438 的题解中说过，要对洛谷评测机的运算能力有高度了解。

那篇题解中说到洛谷评测机能每秒进行大概 $1.2\times10^9$ 次 `unsigned long long` 的乘法运算。

于是笔者猜测计算 `int` 的取模虽然很慢但大概也慢不了多少。

于是就有了这篇完全不用数学方法的题解。

当然，用数位dp可以在多项式复杂度时间内跑过此题，在我的[另一篇题解](https://www.luogu.com.cn/blog/363302/another-solution-p8825)里面。

### 思路：

思路非常简单，就是运用 $n$ 层 $\operatorname{dfs}$ 暴力枚举出所有可能组出的数。

然后暴力判断是否可以被 $k$ 整除，如果能整除就更新答案。

不开 O2 的情况下最大的点跑了 679 毫秒，还是挺快的。

不多哔哔，放代码。

搜索部分如下，通过代码在其基础上稍加调整即可，为了防止某些读者直接复制过去就不放了。

```cpp
void dfs(int step, long long num){
    if (step > n){
        if (num % k == 0) cnt++;
        return;
    }
    num *= 10;
    for(int i = 1; i <= 6; i++)
        dfs(step + 1, num + i);
}
```

复杂度高达 $\Theta(6^n)$ ，但最多取模次数仅仅有大约 $6\times10^7$ 次，足以通过本题。

洛谷神机果然名不虚传。

至此，我们就用切一道红题的方法切掉了一道黄题。

---

## 作者：VitrelosTia (赞：6)

题链：[P8825 [传智杯 #3 初赛] 运气](https://www.luogu.com.cn/problem/P8825)

### 题意
求有多少个只由 $1$ ~ $6$ 组成的 $n$ 位数是 $k$ 的倍数。

### 思路
爆搜，每位数有 $6$ 种可能就向 $6$ 个方向搜索。每次在末尾添上数，位数到了 $n$ 就计算是否是 $k$ 的倍数。

记得开 `long long`。

### code
```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll n,k,cnt;
void dfs(int x,ll sum){//当前位数，当前搜索的数
    if(x==n){//位数到了
        if(sum%k==0) cnt++;//如果满足条件就计数器加一
        return;
    }
    for(int i=1;i<=6;i++) dfs(x+1,sum*10+i); //位数加一，在后面补数
}
int main(){
    cin>>n>>k;
    dfs(0,0);//从0位数，当前数为0开始搜索
    cout<<cnt%1000000007;//记得取模
}
```

---

## 作者：KK_lang (赞：4)

## 题目大意

有一个 $n$ 位数，每位数都是 $1$ 到 $6$ 的整数，求一共有多少个这样的数整除 $k$。

## 思路

既然是 $n$ 位数，每个数还有固定范围，那么就枚举不就完了吗？dfs 枚举每位的数字，最后判断。

时间复杂度 $O(6^n)$，$n \leq 10$，完全能过。

## AC Code

具体实现，看代码注释。

```cpp
#include<bits/stdc++.h>
using namespace std;

const long long mod = 1e9 + 7; // 记得取模
int n, k;
long long ans;

int ch[15]; // 每位的数字，记录一下
void dfs(int step)
{
    if (step > n) // 记得是大于，不是等于，因为初始为 1，等于的话就会漏掉最后一个
    {
        long long now = 0; // 现在组成的数
        for (int i = 1; i <= n; i++) now = now * 10 + ch[i]; // 计算现在的数
        if (now % k == 0) ans = (ans + 1) % mod; // 符合就加上
        return; // 记得 return！
    }
    for (int i = 1; i <= 6; i++) // 1~6
    {
        ch[step] = i; // 记录
        dfs(step + 1); // 下一个
    }
}

int main()
{
    cin >> n >> k; // 输入
    dfs(1); // 枚举
    cout << ans << endl; // 输出
    return 0; // 完美收尾~
}
```
希望大家都可以 AC（黄题呢）！

---

## 作者：lwx20211103 (赞：3)

### Update on 2022.11.28:错别字修改，对原先解法详细说明


------------


这是一个简单的搜索题目，搜索在组成中有多少能被 $k$ 整除即可。

至于组成的数字，我们记要下一个搜索的数字为 $now$，上一个数字 $sum$，为我们可以由位数的知识得出：$now = sum \times 10 + i$ （$i \in (1, 6)$）。

核心代码就出来了。
```cpp
void dfs(int times, int sum)//times表示次数，sum表示数字。
{
	if (times == n)//递归边界
	{
		if (sum % k == 0)
		{
			ans++;
		}
		return;
	}
	int i;
	for (i = 1; i <= 6; i++)
	{
		dfs(times + 1, sum * 10 + i);//向六个面搜索
	}
}
```


因为 $n \leq 10$，根据乘法原理，总和不超过 $6 ^{10}$，达不到 $10^9 + 7$，直接方案数加起来即可，注意要全程开 `long long`，除了 $n$ 和 $k$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

long long n, k, ans;

void dfs(int times, int sum)
{
	if (times == n)
	{
		if (sum % k == 0)
		{
			ans++;
		}
		return;
	}
	int i;
	for (i = 1; i <= 6; i++)
	{
		dfs(times + 1, sum * 10 + i);
	}
}

main()
{
	cin >> n >> k;
	dfs(0, 0);
	cout << ans;
	return 0;
}
```


---

## 作者：Ray662 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8825)

[更好的阅读体验](https://www.luogu.com.cn/blog/sunrize/solution-p8825)

题目描述很友好，这里无需阐释。

---

### 分析

这题不难想到 $O(6^n)$ 的做法，直接枚举每次骰子投出的是哪个数，最后判断是否是 $k$ 的倍数即可。

DFS 实现即可。

$n$ 只有 $10$，可以通过本题。

---

code：

```cpp
#include <bits/stdc++.h>
#define int long long
#define _for(i, a, b)  for (int i = (a); i <= (b); i ++ )
#define _all(i, a, b)  for (int i = (a); i >= (b); i -- )
using namespace std;
const int P = 1e9 + 7;
int n, k, ans;
void dfs(int x, int now) {
	if (x == n + 1) {
		if (now % k == 0)  (ans += 1) %= P;
		return ;
	}
	_for (i, 1, 6)  dfs(x + 1, now * 10 + i);
}
signed main() {
	cin >> n >> k;
	dfs(1, 0);
	cout << ans << endl;
	return 0;
}
```

---


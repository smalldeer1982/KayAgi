# 『MdOI R5』Jump

## 题目描述

数轴上有一个人，设他所在的位置为 $x$，初始时 $x=0$。第 $i$ 秒中他可以选择往左或往右跳 $2^{i-1}$ 单位长度，即将 $x$ 增大或减小 $2^{i-1}$。问他至少需要多少秒才能到达 $n$，即在某一秒结束的时刻使得 $x=n$。如果永远都不可能到达 $n$，那么输出 $-1$。

**本题每个测试点中有多组数据。**

## 说明/提示

对于 $100\%$ 的数据，$1\le T\le 10^3$，$1\le n\le 10^9$。

$\operatorname{Subtask} 1(30\%)$：$n\le 100$。

$\operatorname{Subtask} 2(40\%)$：$n=2^k$，其中 $k$ 是一个非负整数。

$\operatorname{Subtask} 3(30\%)$：无特殊限制。

#### 样例说明 1

$n=1$ 时只需要在第一秒中往右跳即可。

$n=2$ 时可以证明永远都不可能到达 $n$。

## 样例 #1

### 输入

```
10
1
2
7
8
9
10
11
935
101
2023```

### 输出

```
1
-1
3
-1
4
-1
4
10
7
11```

# 题解

## 作者：Kubic (赞：12)

只有第一秒走的长度为奇数，后面每一秒走的长度都为偶数，因此所有除 $0$ 外的偶数点都是不可达的。

当 $n$ 为奇数时，设 $d$ 为满足 $\sum\limits_{i=1}^d 2^{i-1}\ge n$ 的最小值。可以证明答案为 $d$。

证明：

初始令每一秒都是往右走的，我们需要将某一些秒调整为往左走使得最终恰好走到 $n$。

设 $m=\sum\limits_{i=1}^d 2^{i-1}-n$。显然 $m$ 为偶数。

我们需要找到一些秒，使得这些秒中走的距离之和恰好为 $\dfrac{m}{2}$，并将这些秒调整为往左走。

只需要找出 $\dfrac{m}{2}$ 的二进制表示，将它分解为若干个互不相同的 $2$ 的幂之和，这样就一定可以得到一组方案。

时间复杂度 $O(T)$ 或 $O(T\log n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n;
void slv()
{
	scanf("%d",&n);
	if(n&1) printf("%d\n",32-__builtin_clz(n));
	else printf("-1\n");
}
int main()
{
	scanf("%d",&T);
	while(T--) slv();return 0;
}
```

---

## 作者：Moon_Traveller (赞：5)

[传送门](https://www.luogu.com.cn/problem/P8918)

# 方法：观察样例+打表

## 题意简述：

一个人在数轴上 $0$ 的位置，他在第 $i$ 秒时，**只能**向左或向右走 $2^{i-1}$ 的距离（注意不能在原地停留），问走到 $n$ 需要多少秒。如果走不到，就输出 `-1`。

## 分析：

$2^0=1$，因为每一次都必须从 $0$ 走，并加或减 $1$，而 $2$ 的正整数次幂都为偶数，所以符合条件的 $n$ 一定是一个奇数。

## 40分做法：

观察题目最下面的 $\text{Subtask 2}$，可以看到数据都是 $2^{k}$，那么除了 $2^0=1$ 以外，输出都为 `-1`。

所以对于 $\text{Subtask 2}$ 来说，只需要特判一下是不是输入是不是 $1$ 就可以了。即：

```cpp
if(n == 1)
{
    cout << 1 << endl;
}
else
{
    cout << -1 << endl;
}
```

喜提 $40$ 分。

## 100 分做法

我们可以尝试从 $i=1$ 开始打个表，看看走了 $i$ 秒（步）时，可以走到哪些地方：

```python
i = 1:  -1, 1;
i = 2:  -3, -1, 1, 3;
i = 3:  -7, -5, -3, -1, 1, 3, 5, 7;
i = 4:  -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15;
···
```

由此可以推论出：

走了 $i$ 秒（步）时，可以走到区间 $[-2^{i},2^{i}]$ 中的任意一个奇数点。

而由于题目中给出的 $n$ 都是正整数，所以我们只需要考虑其中的正数部分即可，即 $[1,2^{i}]$，那么走到 $n$ 需要的最小步数就是 “大于且最接近 $n$ 的 $2^{i}$ 的指数 $i$”。

代码：

```
#include <iostream>
#include <cmath>
using namespace std;
#define int long long

int T;
int n;
int m[35];

void mi() // 记录2的非负整数次幂
{
    m[0] = 1;
    for(int i = 1; i <= 30; i++)
    {
        m[i] = m[i - 1] * 2;
    }
    return;
}

signed main()
{
    mi();
    cin >> T;
    for(int t = 1; t <= T; t++)
    {
        cin >> n;
        if(n % 2 == 1)
        {
            for(int i = 0; i <= n; i++)
            {
                if(m[i] > n) // 注意不是>=
                {
                    cout << i << endl;
                    break; // 不要忘了跳出循环
                }
            }
        }
        else // 如果n为整数，则直接输出-1
        {
            cout << -1 << endl;
        }
    }
    return 0;
}
```

PS：其实这就相当于 $i= \lfloor \log_{2} n\rfloor + 1$。

###### 撒花~

---

## 作者：yummy (赞：4)

考虑到这道题是简单题，读者仍然会比较依赖代码，因此不同的语言是必须的。

**本文将仅提供 Python 3 代码。**

## 做法

看到每次跳 $2$ 的整数次幂，不难想到二进制。再想想它和二进制之间的联系。

每一步向左或向右太麻烦，不如我们先**强制**向右 $2^k$ 步，然后**允许不记步数地**向左 $2^{k+1}$ 步。不难发现这和原来说的是一回事。

向左跳的总长度可以是 $2,4,8,\ldots$ 的任意组合，显然可以组成所有**自然数中的偶数**。

向右跳 $k$ 秒可以跳 $2^{k+1}-1$ 步，因此如果 $2^{k+1}-1\ge n$，并且 $2^{k+1}-1-n$ 是个偶数，那么 $k$ 就一定是合法的。

## 实现

多测的实现：用 `int(input())` 读入 $T$ 后，使用 `for i in range` 生成一个循环。你不必担心 `int(input())` 被调用多次，因为第一次输入 $T$ 后，这个 `range` 就确定了。

接下来求最小的 $k$ 使得 $2^{k+1}-1\ge n$。我们发现这个问题相当于问 $n$ 的二进制是几位数。

注意到 Python 3 自带 `bin` 函数，返回一个有 `0b` 前缀的字符串。因此，如果 `s=bin(int(input()))`，那么减去 $3$ 就是所需的 $k$。

最后判断它是不是偶数。我的写法将要输出的 $-1$ 或 `len(s)-3` 写进列表，看二进制末位是不是 $0$，并将布尔值转为下标取出对应的结果。

把上面三句话连在一起，就得到了本题代码：

```python
for i in range(int(input())):
	s=bin(int(input()))
	print([-1,len(s)-3][s[-1]!='0'])
```

**如果你的 Python 还不熟练，你可以不压行，将上面每个功能拆开写，更容易理解。**

---

## 作者：Convergent_Series (赞：3)

分类讨论。

由于仅有第一步距离为奇数且必须跳，所以当 $n\bmod 2=0$ 时无解。

当 $n=2^x-1$ 时，其二进制为 $111···1$ ，不断向右跳即可，答案为 $x$ 。

否则，若 $n$ 的二进制中含有如 $10$ 的串，则向左一步向右一步。设 $n$ 的二进制有 $m$ 为，则 $m$ 步后与 $n$ 的差必为 $2^m$ ，答案为 $m+1$ 。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int main(){
	int i,fl;
	cin>>t;
	while(t--){
		cin>>n;
		if(n%2==0) cout<<"-1\n";
		else {
			i=0;
			fl=0;
			while(n){
				n>>=1;
				if(n%2==0) fl=1;//含0
				i++;
			}
			cout<<i+fl-1<<"\n"; 
		}
	}
	return 0;
}
```

---

## 作者：maomao233 (赞：1)

### 题意
一个人站在 $0$ 的位置上，第 $i$ 秒中他可以选择往左或往右跳 $2^{i-1}$ 单位长度，问至少需要多少秒才能到达 $n$ 。如果他永远都不可能到达 $n$，则输出 $-1$。
### 分析
- 仔细观察一下样例就能发现：只要 $n$ 为偶数，那必然是无解的，此处可以特判。

- 接下来进行模拟。判断如果现在所在的位置加上 $2^{i-1}$ 能不能超过 $n$ ，如果超过了，就直接输出当前的 $i$ 就行了，否则就将 $x$ 加上 $2^{i-1}$ 。码量还是挺少的。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
    	int n;
    	cin>>n;
    	if(n%2==0)
    	{
    		puts("-1");
    		continue;
		}
    	int x=0,i=1;
    	while(x+pow(2,i-1)<n)
    	{
			x+=pow(2,i-1);
			i++;
		}
		cout<<i<<endl;
	}
    return 0;
}
```

赛事还写一个前缀和，把前面 $31$ 个 $2^{i-1}$ 的值先算出来， $x$ 再加的时候就不用再写 ```pow(2,i-1)``` 了。代码就不放了。


---

## 作者：Infinite_Eternity (赞：1)

# Description

[P8918 『MdOI R5』Jump](https://www.luogu.com.cn/problem/P8918)

对于一个 $x=0$，在第 $i$ 秒中，可以将 $x$ 增大或减小 $2^{i-1}$。需要多少秒才能使得 $x=n$。如果永远都不可能使得 $x=n$，那么输出 $-1$。

数据范围：$1\le T\le 10^3$，$1\le n\le 10^9$。

# Analysis

结论题。

- 对于 $n=1$ 的情况，明显第 $1$ 秒使得 $x$ 增加 $2^0=1$ 即可。

- 对于 $n$ 为偶数的情况，因为有且仅有第 $1$ 秒时可以使得 $x$ 增加或减少 $1$；其余秒时，$x$ 都将增加或减少 $2$ 的整数倍。根据 `奇数+偶数=奇数` 和 `奇数-偶数=奇数`。因此，无法使得 $x$ 为偶数，输出 $-1$；

- 对于剩下的情况，答案应为$\left\lfloor\log_2 n\right\rfloor+1$。[证明见此。](https://www.luogu.com.cn/blog/119621/solution-p8918)

时间复杂度 $\mathcal{O}(T)$。

# Code

```cpp
#include <stdio.h>
#include <math.h>
int main()
{
    int T,a;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&a);
        if (a==1) printf("%d\n",1);
        else if (!(a&1)) printf("%d\n",-1);
        else printf("%d\n",(int)log2(a)+1);
    }
    return 0;
}
```

---

## 作者：McIron233 (赞：1)

- 观察样例，不难发现当 $n$ 为偶数且 $n \not= 0$ 时无解，又 $1 \leq n \leq 10^9$，故输入数据中的所有偶数 $n$ 均无解。

- 当 $n$ 为奇数时，再次观察样例，可以发现答案即为满足 $2^a \ge n$ 的最小 $a$ 值。

理由如下：

- 当 $n$ 为偶数时，因为只有第一步走的长度是 $1$ 为奇数，而此后每一步的长度都为偶数，所以此后能到达的点的坐标只能为奇数，故非零的 $n$ 均无解。

- 当 $n$ 为奇数时，最开始时每一步都可以假作向右走，现在需要将一些步向左调来保证 $a$ 步后的位置为 $n$，那么我们可以设多出来的距离是 $d$，可以发现原来走的长度为奇数，而 $n$ 为奇数，所以 $d$ 为偶数。于是需要一种方案使这些向左走的步长是 $\frac{d}{2}$，可以发现它是非负整数。根据二进制，可以将 $\frac{d}{2}$ 分成若干个不同的 $2$ 的非负整数次幂之和，所以一定有一种方案，得证。

---

## 作者：what_can_I_do (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8918)

水。

我们可以发现，$2^0=1$，而其它 $2$ 的幂次都为偶数，所以不管如何，$n$ 为偶数都不可能到达，输出 $-1$。

我们观察样例可以发现当 $n=9$ 或 $n=11$ 时，答案都为 $4$，而 $n=7$ 答案为 $3$。我们可以发现，$n=7$ 时要达成它过程是 $1+2+4$，所以 $n=9$ 时就不能靠着 $1$，$2$，$4$ 三个数字来组成，因为原本它们就已经全加在一起了，所以得多加一个数字 $8$ 来达成。

我们通过~~玄学~~推断出答案跟 $2$ 的幂次有关，可以发现 $2^3\le 9\le 2^4$，所以答案为 $4$，$2^3\le 11\le 2^4$，所以答案也为 $4$，我们还可以靠着样例中 $n=101$ 来检验结论。

所以答案为比 $n$ 大的最小的 $2$ 的幂次的数的 $2$ 的指数。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		int n,k=0;
		scanf("%d",&n);
		if(n%2==0){puts("-1");continue;}
		while(n) n=n>>1,k++;
		printf("%d\n",k);
	}
	return 0;
}
```

---

## 作者：strcmp (赞：1)

**题目大意：** 给定 $t$ 组询问，每次询问给出一个正整数 $n$，同时给定初始位置 $x=0$，初始时间为 $i=1$。**每次你可以将 $x$ 加上或者减去 $2^{i-1}$，并将 $i$ 加上 $1$。** 求是否存在方法，使得 $x$ 可以到达 $n$，如果存在，求最小的 $i - 1$。

### Solution

签到题，这里给出一个最优的构造方法。

首先，考虑 $i = \lceil \log_2 (n + 1) \rceil$ 时的情况，如 $x = 101$ 时的所有合法情况：

```
±1±2±4±8±16±32±64
```

此时可得到的最大值为 $127$（全为加号的情况下），与 $n$ 的距离为 $26$。$26$ 可以从 $16 + 8 + 2$ 得到，从而将 $8,\,4,\,1$ 前面的加号替换为减号即可。（将 $a$ 的加号替换为减号后，贡献从加上 $a$ 变为减去 $a$，与原贡献的差距为 $2a$。故如果与原贡献的差距为 $2^i$，则应当将位置 $2^{i-1}$ 前的加号变为减号）

考虑将这个算法扩展，**对于 $n$ 的询问，得 $k = 2^{\lceil \log_2(n + 1) \rceil + 1} - n - 1$。如果 $k$ 为奇数则无解，否则最优步数即为 $\lceil \log_2(n + 1) \rceil$。**

这个算法的最优性是显然的（至少经过 $\lceil \log_2(n + 1) \rceil$ 步的加法才能超过 $n$ 的值），但是判断无解的正确性还需要一些证明。

考虑 $k$ 为奇数的情况，如果 $k$ 为奇数，则减去 $a$ 使得 $k$ 为偶数，必须使得 $a$ 也为奇数。但是由于将任意正整数数列中的**数 $a$ 的正负性改变，则对总和的影响为 $2a$** ，而 $2a$ 必然为偶数，所以当总和为奇数时，改变某数的正负性不能使得总和变为偶数，从而不存在方案使得总和为 $0$，也就不存在方案使得距离 $k$ 变为 $0$。

如果增加步数，显然加入的数是 $2$ 的正整数次幂，是一个偶数，仍然不存在方案使得 $k$ 可以变为 $0$。正确性证毕。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(); cout.tie(); 
    int t; ll n; cin >> t;
    while (t--) {
        cin >> n;
        ll k = 1, d = 0, ans = 0;
        while (d < n)d += k, k <<= 1, ++ans; k >>= 1; ll c = d - n;
        if (c & 1)cout << "-1\n";
        else cout << ans << "\n";
    }
    return 0;
}
```


---

## 作者：InversionShadow (赞：0)

## P8918 『MdOI R5』Jump 题解

### 题意：

$T$ 组数据，每组一个整数 $n$，一个人一开始位于 $0$，在第 $i$ 秒他可以选择向左或向右跳 $2^{i-1}$ 步，请问他是否可以到达 $n$，如果不行，输出 `−1`。

### 思路：

先来分析偶数，因为 $2^0$ 是 $1$，所以他在第一秒跳的是奇数长度，而以后的 $2^{i-1}(i>1)$ 跳的长的为偶数，我们知道奇数加偶数等于奇数，所以答案一定为奇数，如果 $n$ 为偶数，输出 `-1`。

再来分析奇数，可以证明，任意奇数均有解。我们可以把这道题的意思变简单：用连续的 $2^n$ 次相加或相减得到 $n$。我们参考官方题解。设 $d$ 为答案，设 $m=\sum\limits_{i=1}^d2^{i-1}-n$，那 $m$ 为一偶数，任意一个偶数均可以为几个较大的 $2^m$(注意：这里不是 $2^m$ 乘上个数，而是可以不连续的的，比如：$2^3+2^7$，又如 $2^{10}+2^{15}+2^1$) 的和减去较小的 $2^k$ 之和。而不管是加法还是减法，没操作一次，都要加上一秒。所以，$d=\left\lceil\log_2(n)\right\rceil$。

### Code:

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, t;

int S(int x) {
  for (int i = 1; i <= 32; i++) {  // 设置一个边界
    if (pow(2, i - 1) < x && pow(2, i) > x) {  // 找出第一个 2^i > n 的 i
      return i;
    }
  }
}

signed main() {
  cin >> t;
  while (t--) {
    cin >> n;
    if (n == 1) {
      cout << "1" << endl;
      continue;
    }
    if (n % 2 == 0) {
      cout << "-1"  << endl;
      continue;
    }
    cout << S(n) << endl;
  }
  return 0;
}
```



---

## 作者：VitrelosTia (赞：0)

写出 $n$ 的二进制表示再转化成 $2$ 的幂和。$n=\sum_i2^{a_i},$ 其中 $a_1<a_2<\dots <a_k.$

发现 $2^{a_{i+1}-1}-\sum\limits_{j=a_i}^{a_{i+1}-2}2^j=2^{a_i}$。因此当 $n$ 为奇数时均可以 $a_k+1$ 步到 $n$。

于是结论就是：当 $n$ 为偶数时，无解，否则解答为 $\left\lfloor\log_2 n\right\rfloor+1$ 。

```
#include<stdio.h>
#include<math.h>
int main(){
    int t,n;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        if(!(n&1)) puts("-1");
        else printf("%d\n",int(log2(n))+1);
    }
}
```

---

## 作者：hycqwq (赞：0)

~~终于有大月赛了哈哈哈~~

## 思路

一上来，看着有点像倍增，于是我们就思考：

> 如果要使用倍增，那么我们应该可以在某些时刻不跳。

但是题目要求每秒钟都必须跳，于是我们就来寻找有没有办法可以让我们想不跳的操作无效。

在多次尝试之后我们发现：

$$2^{n - x} = 2^n - \sum\limits_{i = 1}^{x} 2^{n - i}$$

其中 $x$ 为正整数且 $0 \le x \le n$。

所以这意味着什么呢？我们找到让操作无效的方法了。

我们只需要在每一秒跳之前先看一下，下一步要不要停？如果要停就向反方向跳，否则就分两种情况：

1. 如果当前这一步本来就要跳，那就按原计划跳；
2. 如果当前这一步本来要停止，那就按上一次本来要跳但是因为前面说的情况想反方向跳的一步的原方向跳。

但是第 $1$ 秒很特殊，因为第一秒没有上一秒，所以只有第 $1$ 秒是不能跳过的，于是我们发现：只要 $n$ 是偶数就无法到达，否则就可以到达。

虽然我们刚刚是用倍增的思路去分析的，但是~~这道题目很拉胯~~我们需要求的答案就是 $\lfloor \log_2n + 1 \rfloor$，所以我们并不需要真的在代码里用倍增。

## 代码

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
#define elif else if

int n;

int main()
{
    scanf("%d", &n);
    for (int i = 1, x; i <= n; i++)
    {
        scanf("%d", &x);
        if (x % 2 == 0)
            printf("-1\n");
        else
            printf("%d\n", int(log2(x) + 1));
    }
    return 0;
}
```

评测记录：[R98630963](https://www.luogu.com.cn/record/98630963)。


---


# 不死「火鸟　−凤翼天翔−」

## 题目背景

拥有了「不死」的能力的藤原妹红，同时获得了操纵火焰的力量，是不死鸟的化身。

不死鸟，和凤凰是同一种生物吗？

## 题目描述

妹红可以操纵火鸟。火鸟可以看作在边长**无限大**的棋盘上放置着的一枚棋子 $A$，$A$ 位于 $(x_1,y_1)$ 处。$A$ 以如下规则移动：

- 在奇数次移动时，$A$ 只能向右上或者左下移动一格，如下图红色箭头；
- 在偶数次移动时，$A$ 只能向右下或者左上移动一格，如下图蓝色箭头。

![](https://cdn.luogu.com.cn/upload/image_hosting/rk4bjeya.png)

由于棋盘无限大，因此 $x,y$ 的取值可以为负数。

每一步行动时 $A$ 不能待在原地不移动。现在需要把 $A$ 移动到坐标为 $(x_2,y_2)$ 的 $B$ 位置，最少要多少步？特别地，若不存在这样的方案，输出 $-1$。

如下图所示是 $A=(2,7)$，$B=(5,2)$ 的情况。一种移动次数最小的方案已在图上标出，需要 $9$ 步。红色线段表示奇数次的移动，蓝色线段表示偶数次的移动。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzwrv7q0.png)

## 说明/提示

### 数据范围及约定

对于全部数据，保证 $0\le x_1,y_1,x_2,y_2\le 10^9$。

## 样例 #1

### 输入

```
2 7 5 2```

### 输出

```
9```

## 样例 #2

### 输入

```
2 2 3 2```

### 输出

```
-1
```

## 样例 #3

### 输入

```
0 0 1000000000 1000000000
```

### 输出

```
2000000000```

# 题解

## 作者：Night_sea_64 (赞：7)

因为它两格为一个周期，所以我们两步两步地看。

枚举两步每步往哪里走，发现它其实每两步就是向上、下、左、右走两格。

如果在国际象棋的棋盘上，起点在黑格。那么如果按照要求移动一定不会跑到白格上去。而黑白格是通过行列和的奇偶性判断的。所以如果起点和终点行列和的奇偶性不同，输出 $-1$。

然后，如果起点与终点 $x$ 坐标之差与 $y$ 坐标之差都是偶数，说明能直接通过每次向上下左右走两格的方法走到，输出曼哈顿距离 $\div2$。

否则，那么我们可以先走到 $(x_2-1,y_2-1)$ 或者 $(x_2+1,y_2+1)$ 的位置，再多走一步。输出这两种情况最小值再 $+1$。

```cpp
#include<iostream>
#include<cmath>
#define int long long
using namespace std;
signed main()
{
    int a,b,c,d;
    cin>>a>>b>>c>>d;
    if((a+b)%2!=(c+d)%2)cout<<-1<<endl;
    else if((int)(abs(a-c))%2==0)cout<<abs(a-c)+abs(b-d)<<endl;
    else cout<<min(abs(a-(c+1))+abs(b-(d+1))+1,abs(a-(c-1))+abs(b-(d-1))+1)<<endl;
    return 0;
}
```

---

## 作者：wuhan1234 (赞：5)

## 1. 编程思路。

火鸟在移动时有四种选择：

1）向右上移动 $1$ 格，设为操作 A，此操作将使 X 坐标加 $1$，Y 坐标也加 $1$。

2）向右下移动 $1$ 格，设为操作 B，此操作将使 X 坐标加 $1$，Y 坐标减 $1$。

3）向左下移动 $1$ 格，设为操作 C，此操作将使 X 坐标减 $1$，Y 坐标也减 $1$。

4）向左上移动 $1$ 格，设为操作 D，此操作将使 X 坐标减 $1$，Y 坐标加 $1$。

在移动过程中，奇数步只能选择操作 A 或操作 C，偶数步只能选择操作 B 或操作 D。

我们可以这样来考虑。先将 X 坐标移动到位。为了使移动步数最少，如果 $x_2>x_1$，奇数步只能选择操作 A，偶数步只能选择操作 B，每次操作均将 X 坐标加 $1$，一直从 $x_1$ 移到 $x_2$，移动次数 $dx$ 为 $x_2-x_1$。此时，Y 坐标的变化是 $+1,-1,+1,-1,...$。也就是说，若移动次数 $dx$ 是偶数，则 Y 坐标保持不变，若是奇数，则 Y 坐标加 $1$，即 $y_1+1$。

如果 $x_2<x_1$，则奇数步只能选择操作 C，偶数步只能选择操作 D，每次操作均将 X 坐标减 $1$，一直从 $x_1$ 移到 $x_2$，移动次数 $dx$ 为 $x_1-x_2$。此时，Y 坐标的变化是 $-1,+1,-1,+1,...$。也就是说，若移动次数 $dx$ 是偶数，则 Y 坐标保持不变，若是奇数，则 Y 坐标减 $1$，即  $y_1-1$。

X 坐标移动到位后，再来考虑将 Y 坐标移动到位。

如果 $y_2>y_1$，则奇数步选择操作 A，偶数步选择操作 D，每次移动均将 Y 坐标加 $1$，移动次数 $dy$ 为 $y2-y1$。

如果 $y_2<y_1$，则奇数步选择操作 C，偶数步选择操作 B，每次移动均将 Y 坐标减 $1$，移动次数 $dy$ 为 $y1-y2$。

由于在移动 Y 坐标到位的过程中，X 坐标已提前到位。因此，为保证 X 坐标不变，$dy$ 必须是偶数，否则无解。
若 $dy$ 是偶数，则可行的最少移动步数为 $dx+dy$。

## 2. 源程序。

```c
#include <stdio.h>
int main()
{
	int x1,y1,x2,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	int t;
	int dx=x2-x1;      // 先将x坐标走到位
	if (dx<0) { dx=-dx; t=-1;}
	else t=1;
	if (dx%2==0) t=0;  // 如果x到位过程走偶数步，y坐标是不变的
	y1=y1+t;
	int dy=y2-y1;     // 再看y坐标能否到位
	if (dy<0) dy=-dy;
    if (dy%2==0)     // 为了在y坐标到位的过程中x坐标保持不变，只能走偶数步
        printf("%d\n",dx+dy);
    else
        printf("-1\n");
	return 0;
}

```




---

## 作者：ダ月 (赞：2)

### 题目分析：

我们可以记**完整的操作**为一次偶数操作加一次奇数操作。显然，一次完整的操作可以沿 $x$ 轴或者 $y$ 轴走 $2$ 格（可反方向）。

由此可以推出该题与两个点 $x,y$ 坐标差的奇偶性有关。

记 $x$ 轴的差为 $dx$，记 $y$ 轴的差为 $dy$。（**取绝对值**）

- 若 $dx$ 与 $dy$ 都是偶数，显然可以最少走 $\frac{dx}{2}\frac{dy}{2}$ 完整操作就可以走到。此时答案为 $dx+dy$。

- 若 $dx$ 与 $dy$ 中有一个奇数，一个偶数。显然走不到。因为无论是否是完整的操作，坐标的该变量和都是偶数，而此时的要求该变量为奇数。

- 若 $dx$ 与 $dy$ 中都是奇数。
	- 若 $(x_2,y_2)$ 在 $(x_1,y_2)$ 右上角或者左上角，那么可以走到 $(x_2,y_2)$ 离 $(x_1,y_2)$ 最近的一个对角后使用奇数次操作，答案为 $dx+dy-1$。
    
   - 否则，那么对于前一个情况，还要在走一个完整的操作，使得奇数次操作正对着 $(x_2,y_2)$，答案为 $dx+dy+1$。
   
### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
//=====
//这里为缺省源，略。
//=====
ll a,b,c,d;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>a>>b>>c>>d;
	ll dx=abs(a-c),dy=abs(b-d);
	if(dx%2==0&&dy%2==0){printf("%lld\n",dx+dy);}
	else if(dx%2==0||dy%2==0){puts("-1");}
	else printf("%lld\n",dx+dy+((a>c)^(b>d)?1:-1));
	return 0;
}


```

时间复杂度：$O(1)$。


---

## 作者：2c_s (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9204)

# 思路

一道画图找规律题。

先判断不可能到达的位置：画图举例可以发现，当 $|x_1-x_2|+|y_1-y_2|$ 是奇数的时候，不可能到达 $(x_2,y_2)$ 的位置，直接输出 ``-1``。

如果能到达，就判断 $8$ 个方向的到达方式所用的距离。先对两组坐标进行处理，将 $(x_1,y_1)$ 设为坐标系的原点（即 $(0,0)$），之后将 $x_2$ 和 $y_2$ 分别减去 $x_1$ 和 $y_1$ 的初始值，将坐标系转化。之后画图找规律发现：

$A.$ 当 $x_1=x_2$ 时，所用的步数是 $|y_1-y_2|$。

$B.$ 当 $y_1=y_2$ 时，所用的步数是 $|x_1-x_2|$。

$C.$ 当 $(x_2,y_2)$ 在 $(x_1,y_1)$ 的右上或左下：如果 $|x_2|$ 和 $|y_2|$ 均为奇数，所用的步数为 $|x_1-x_2|+|y_1-y_2|-1$；否则为 $|x_1-x_2|+|y_1-y_2|$。

$D.$ 当 $(x_2,y_2)$ 在 $(x_1,y_1)$ 的左上或右下：如果 $|x_2|$ 和 $|y_2|$ 均为奇数，所用的步数为 $|x_1-x_2|+|y_1-y_2|+1$；否则为 $|x_1-x_2|+|y_1-y_2|$。

# AC 代码

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int x,xx,y,yy;
int main(){
	cin>>x>>y>>xx>>yy;
	if(abs(x-xx)+abs(y-yy)&1){
		cout<<-1;
		return 0;
	}
	int tmpx=x,tmpy=y;
	x=0,y=0;
	xx-=tmpx,yy-=tmpy;
	if(x==xx)cout<<abs(yy-y);//A.
	else if(y==yy)cout<<abs(xx-x);//B.
    
	else if(x<xx&&y<yy||x>xx&&y>yy){//C.
		if(abs(xx)%2==0&&abs(yy)%2==0)cout<<abs(xx-x)+abs(yy-y);
		else cout<<abs(xx-x)+abs(yy-y)-1;
	}
    
	else if(x>xx&&y<yy||x<xx&&y>yy){//D.
		if(abs(xx)%2==1&&abs(yy)%2==1)cout<<abs(xx-x)+abs(yy-y)+1;
		else cout<<abs(xx-x)+abs(yy-y);
	}
	return 0;
}
~~~

---


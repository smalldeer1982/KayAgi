# 藤原「灭罪寺院伤」

## 题目背景

藤原氏，权倾一时的重臣。凭借着炙手可热的权势，杀害了政敌长屋王而触碰到了最高的权力。

是天谴吗？即使修缮寺庙积德行善，藤原四兄弟最终覆灭在了天花之下。

## 题目描述

环环相扣的因果报应可看成平面上的 $n$ 个小正方形，它们的边长分别为 $1,2,3,\cdots,n$。初始时，编号较小的正方形被编号较大的正方形完全包含：

![](https://cdn.luogu.com.cn/upload/image_hosting/w5f6nucw.png)

为了方便记录正方形的位置，我们取正方形左上角的坐标 $(x_i,y_i)$ 为正方形的坐标。此时可以唯一确定该正方形。

现在需要将最小的正方形的位置移动到 $(x_{\rm end},y_{\rm end})$，移动过程满足：

- 每次**最多移动一个**正方形，可以往上下左右四个方向之一移动一个单位长度。
- 在移动过程中，需要保证**较小正方形会被较大的正方形包含**。

请求出最少次数。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/dcghf89y.png)

### 数据范围及约定

对于全部数据，$1\le n\le 10^5$，$0\le x_i,y_i,x_{\mathrm{end}},y_{\mathrm{end}}\le 10^9$。

## 样例 #1

### 输入

```
3 2 1
1 0
1 0
0 1
```

### 输出

```
3

```

## 样例 #2

### 输入

```
15 8 4
9 0
9 1
9 1
8 1
8 2
8 3
7 3
6 3
5 3
4 3
3 3
2 4
2 5
1 6
0 7
```

### 输出

```
24
```

# 题解

## 作者：Night_sea_64 (赞：4)

我们最终的目的，其实就是让每个正方形都包含比它小的正方形，并且也包含 $(x_{\text{end}},y_{\text{end}})$。

但是我们一开始所有正方形都包含比它小的正方形。而且我们需要最少步数。可证如果每个正方形都通过最少的移动使得包含 $(x_{\text{end}},y_{\text{end}})$，那么这些正方形一定会包含所有比它小的正方形。

于是我们只需要算出每个正方形需要包含 $(x_{\text{end}},y_{\text{end}})$ 的最少步数之和了。

```cpp
#include<iostream>
#define int long long
using namespace std;
int n,fx,fy;
signed main()
{
    cin>>n>>fx>>fy;
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        cin>>x>>y;
        if(fx<x)cnt+=x-fx;//在左方
        else if(fx>x+i-1)cnt+=fx-(x+i-1);//在右方
        //cout<<i<<" "<<cnt<<endl;
        if(fy<y-i+1)cnt+=(y-i+1)-fy;//在下方
        else if(fy>y)cnt+=fy-y;//在上方
        //cout<<i<<" "<<cnt<<endl;
    }
    cout<<cnt<<endl;
    return 0;
}
```

---

## 作者：0zhouyq (赞：1)

[传送门](https://www.luogu.com.cn/problem/P9205)

### 思路：
发现“在移动过程中，需要保证较小正方形会被较大的正方形包含”这个条件完全不会影响移动的步数。因为加上这个条件后，对于一个正方形，移动小正方形不会影响它的最少步数，只要在它里面的小正方形一步步跟着它一起移动就可以了。移动比它大的正方形也不会影响它的最少步数，只要比它大的正方形先于它移动这一步就可以。

所以统计一下所有正方形，用最小的步数使每个正方形覆盖到终点就行。

### AC Code:

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	ll n,ex,ey,ans=0;
	scanf("%lld %lld %lld",&n,&ex,&ey);
	for(ll i=1;i<=n;i++){
		ll x,y;
		scanf("%lld %lld",&x,&y);
		if(x>ex) ans+=(x-ex);//统计
		if(x+i-1<ex) ans+=(ex-x-i+1);
		if(y<ey) ans+=(ey-y);
		if(y-i+1>ey) ans+=(y-i+1-ey);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Dreamer_Boy (赞：1)

按题意模拟即可。

读完题，我们会发现有四种情况：在左边、在右边、在上边、在下边。

我们先看向左移，我们只要将现在输入的 $x$ 减去原来的 $yx$ 即可，前提是原来的小于现在的。

再看右移，由于是整个正方体在移动，所以用原来的 $yx$ 减去 $x+i-1$ 就行了，与上一条类似。

左和右就不用细说了，就是左、右的一个变型罢了。

最后，我们用 $res$ 累加起答案，这题就解决了。

```
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
typedef long long ll;

ll n, yx, yy;
ll x[N], y[N];
ll res;
int main() {
	cin >> n;
	cin >> yx >> yy;
	
	for (ll i = 1; i <= n; i++) {
		cin >> x[i] >> y[i];
	}
	for (ll i = 1; i <= n; i++) {
		if (yx < x[i]) {//左
			res += (x[i] - yx);
		}

		else if (yx > x[i] + i - 1) {//右
			res += (yx - (x[i] + i - 1));
		}
      if (yy > y[i]) {//上
			res += (yy - y[i]);
		}
		else if (yy < y[i] - i + 1) {//下
			res += ((y[i] - i + 1) - yy);
		}


	}
	cout << res << endl;
	return 0;
}
```

---

## 作者：comcopy (赞：0)

由于大正方形必须包含小正方形，所以可以了解到小正方形包含的所有点必然要被大正方形包含，所以直接求出所有正方形到目标点需要移动的最小次数求和就行了。


```cpp
#include<bits/stdc++.h>
#define mi(...) <%__VA_ARGS__%>
#define int long long
using namespace std;

namespace Faster {
inline bool _u(char ch) { return ch >= '0' && ch <= '9'; }
//char buf[1 << 23], *p1 = buf, *p2 = buf;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 23, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {int x = 0, f = 1;char ch = getchar();for (; !_u(ch); ch = getchar())if (ch == '-')f = -f;for (; _u(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);return x * f;}
inline void write(int num) {static int sta[39], top = 0;if (num < 0)putchar('-'), num *= -1;do sta[++top] = num % 10, num /= 10;while (num);while (top) putchar(sta[top--] | 48);return;}
}using namespace Faster;

int n,x,y;
int ans,tmp;
signed main() {
	cin>>n>>x>>y;
	for(int i=1,x2,y2;i<=n;++i){
		cin>>x2>>y2;
		int j=x2,n=x2+i-1,t=y2,m=y2-i+1;
		int tmp=min(abs(n-x),abs(x-j));
		if(j>x||x>n)ans+=tmp;
		tmp=min(abs(m-y),abs(y-t));
		if(m>y||y>t)ans+=tmp;
	}
	cout<<ans<<endl;
	return(0-0);
}
```

---

## 作者：ダ月 (赞：0)

### 题目分析：

题目一开始给定的条件是大的正方形包含小的正方形。

我们不必考虑小正方形必须在大一级的正方形内移动，因为小正方形移动一下，大正方形移动一下，最后小正方形到达目的地，小正方形还是走他那些路。

所以我们**从小到大**考虑：

- 若终点已经被当前正方形包含，那么接下来比它大的正方形就不考虑了，因为当前如果包含，显然接下来的正方形也会包含终点。

- 否则，我们计算当前正方形存在终点的点最小的步数。最小移动方式就各显神通了。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
//===
//缺省源
//===
int n;
ll a,b,x,y,ans=0;
ll dis(ll a,ll b,ll c,ll d){
	ll rs=0;
	if(x<=a)rs+=a-x;
	if(x>=c)rs+=x-c;
	if(y<=b)rs+=b-y;
	if(y>=d)rs+=y-d;
	return rs;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>x>>y;
	for(int i=1;i<=n;i++){
		cin>>a>>b;
		if(x>=a&&x<=a+i-1&&y<=b&&y>=b-i+1)
			break;
		ans+=dis(a,b-i+1,a+i-1,b);
	}printf("%lld\n",ans);
	return 0;
}


```

时间复杂度：$O(n)$。

---


# 异或积

## 题目背景

$\texttt{id: 4d7e}$

小 H 在课堂上学习了异或运算。

对于两个非负整数 $x,y$，它们的**异或**是指，将它们作为二进制数，对二进制表示中的每一位进行如下运算得到的结果：

- $x$ 和 $y$ 的这一位上不同时，结果的这一位为 $1$；
- $x$ 和 $y$ 的这一位上相同时，结果的这一位为 $0$。

$x$ 和 $y$ 的异或被记为 $x \operatorname{xor} y$ 或 $x \oplus y$。

在 C++ 中，你可以用 `x ^ y` 得到 $x$ 与 $y$ 的异或值。

另外，若干个数的异或称之为**异或和**。

## 题目描述

小 H 还了解到，一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
	
例如，数列 $\{1, 2, 3, 4\}$ 的异或积为 $\{5, 6, 7, 0\}$。
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
现在，小 H 有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

## 说明/提示

### 样例 1 解释

此样例即为题目描述中的例子。

### 样例 2 解释

第 $1$ 次异或积变换：$\{0,0,0,1\}\to\{1,1,1,0\}$；

第 $2$ 次异或积变换：$\{1,1,1,0\}\to\{0,0,0,1\}$。

### 数据规模与约定

对于 $100\%$ 的测试数据，$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

| 测试点编号 | $n\leq$  | $k \leq$  |特殊性质|
| :----------: | :----------: | :----------: | :-----------: |
| $1 \sim 3$ | $100$ | $100$ | |
| $4 \sim 5$ | $1000$ | $1000$ | |
| $6 \sim 7$ | $3$ | $10^{18}$ | |
| $8 \sim 10$ | $10^5$ | $3$ | |
| $11 \sim 13$ | $10^5$ | $10^{18}$ | $a$ 中所有数的异或和为 $0$ |
| $14 \sim 15$ | $10^5$ | $10^{18}$ | $n$ 为奇数 |
| $16 \sim 17$ | $10^5$ | $10^{18}$ | $n$ 为偶数 |
| $18 \sim 20$ | $10^5$ | $10^{18}$ | |

### 提示

在 C++ 中，对于数据范围 $0\le x<2^{32}$，你可以：

- 使用 `unsigned int x` 来定义；
- 使用 `cin >> x` 或 `scanf("%u", &x)` 来输入；
- 使用 `cout << x` 或 `printf("%u", x)` 来输出。 

## 样例 #1

### 输入

```
1
4 1
1 2 3 4```

### 输出

```
5 6 7 0```

## 样例 #2

### 输入

```
1
4 2
0 0 0 1```

### 输出

```
0 0 0 1```

## 样例 #3

### 输入

```
见附件中的 samples/xor3.in```

### 输出

```
见附件中的 samples/xor3.ans```

# 题解

## 作者：卷王 (赞：25)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/P9227)

## 思路

为什么感觉大家的题解代码都那么复杂？其实根本不需要啊。

首先，我们可以猜测这就是找规律题，因为我们不可能在 $1$ 秒内跑 $10^{18}$ 的数据。

我们可以发现，除非是 $n$ 和 $k$ 均为偶数，其他都必须进行一次操作。

比如：$n=4$。

我们把它进行转换：

$(a_1,a_2,a_3,a_4)$ $\rightarrow$ $(a_2 ⊕a_3⊕a_4,a_1⊕a_3⊕a_4,a_1⊕a_2⊕a_4,a_1⊕a_2⊕a_3)$ $\rightarrow$ $(a_1,a_2,a_3,a_4)$ $\rightarrow...$

可以发现当 $n$ 为偶数时，答案将会在 **原来的式子** 与 **变换一次的式子** 之间徘徊。

同样，我们也可以验证 $n$ 是奇数的性质：除第一次外其他都是 **变换一次的式子**。

只需要特判 $n$ 和 $k$ 均为偶数时即可。

其中进行一次操作有些技巧，具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T, n; ll k;
ll a[100007], b[100007];
inline void work() {
	ll sum = 0;
	for(int i = 1; i <= n; i++) sum ^= a[i];
	for(int i = 1; i <= n; i++) b[i] = sum ^ a[i];
}
inline ll read() {
	ll x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
int main() {
	T = read();
	while(T--) {
		n = read(), k = read();
		for(int i = 1; i <= n; i++)
			a[i] = read();
		if(n % 2 == 0 && k % 2 == 0) {
			for(int i = 1; i <= n; i++)
				printf("%lld ", a[i]);
			printf("\n");
			continue;
		}
		work();
		for(int i = 1; i <= n; i++)
			printf("%lld ", b[i]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：hhoppitree (赞：14)

出题人题解。

#### 题意简述

定义 $f(a_n)=\{b_1,b_2,\cdots,b_n\}$，其中 $b_{i}=\bigoplus\limits_{j=1}^{n}[j\ne i]a_j$，求 $f^{k}(a_n)$。

**多组询问。**对于全部数据，$T\le10$，$n\le10^5$，$k\le10^{18}$。

#### 题目解法

先考虑暴力解法，发现由于异或的性质，若记 $S=\bigoplus\limits_{j=1}^{n}a_j$，则由异或的性质得相当于**一次操作相当于将 $a_i$ 变为 $a_i\oplus S$**。

直接模拟，时间复杂度 $\mathcal{O}(nk)$，无法通过。

发现经过一次操作后，$S$ 变为 $\bigoplus\limits_{i=1}^{n}(a_i\oplus S)=\bigoplus\limits_{i=1}^{n}S\oplus\bigoplus\limits_{i=1}^{n}a_i=\bigoplus\limits_{i=1}^{n}(S)\oplus S$，即 **$(n+1)$ 个 $S$ 的异或和**。

当 $n$ 为奇数时，经过一次操作后的 $S$ 变为 $0$，后面 $a$ 数组不再发生改变；

当 $n$ 为偶数时，经过一次操作后的 $S$ 不变，所以再经过一次操作后 $a$ 变回原数列，所以两次操作之间会相互抵消，初始时将 $k$ 对 $2$ 取模即可。

对 $n$ **分奇偶进行讨论**，记得开 $\texttt{unsigned int}$，单组询问时间复杂度 $\mathcal{O}(n)$。

#### 总结

运用异或的性质得到快速计算的方法，再观察到其中重要变量的变化，即可从中找到规律。

---

## 作者：Link_Cut_Y (赞：7)

考场上被逼去写作业了，痛失水赛。

---------------

[点此看题](https://www.luogu.com.cn/problem/P9227)


看到 $k \leq 10 ^ {18}$，复杂度要么是线性的要么带个 $\log k$。这样的情况最适合举几个例子手模一下。（主要因为我垃圾的数学水平肯定证不出来）。

比如现在有三个数 $[a_1, a_2, a_3]$，进行第一轮操作之后变成
$$[a_2 \oplus a_3, a_1 \oplus a_3, a_1 \oplus a_2]\ \ (1)$$

再操作一轮以后变成

$$[a_1 \oplus a_3 \oplus a_1 \oplus a_2, a_2 \oplus a_3 \oplus a_1 \oplus a_2, a_2 \oplus a_3 \oplus a_1 \oplus a_3]$$
$$= [a_2 \oplus a_3, a_1 \oplus a_3, a_1 \oplus a_2]\ \ (2)$$

可以发现，$(1)$ 式与 $(2)$ 式相同。因此我们后面不论怎么变化，数列都不会改变了。

接下来再手推一下 $n = 4, 5 \cdots$ 的例子，可以发现以下规律：

1. 当 $n$ 为奇数时，异或积在第一次操作后将不再发生变化。
2. 当 $n$ 为偶数时，异或积在第 $i$ 次操作（$i$ 为奇数）后得到的异或积与第一次操作的相同。否则与原序列相同。

---------------------

下面有一个公式很丑而且不是很严谨的证明：

定义连续异或运算 $f(S) = \oplus_{1}^{n} S_i$ 表示序列 $a$ 前 $n$ 个数的异或和。

那么第一次操作后的数列为：

$$S_1 = \{f(a) \oplus a_1, f(a) \oplus a_2 \cdots f(a) \oplus a_n\}$$

其中 $f(S_1) = \begin{cases}
n \equiv 0(\bmod\ {2}) \ \ f(a)\\
n \equiv 1(\bmod\ 2) \ \ 0
\end{cases}.
$

第二次操作后的序列为：

$S_2 = \{f(S_1) \oplus S_{1, 1}, f(S_1) \oplus S_{1, 2} \cdots f(S_1) \oplus S_{1, n}\}$

$= \{ f(S_1) \oplus f(a) \oplus a_1, f(S_1) \oplus f(a) \oplus a_n \cdots f(S_1) \oplus f(a) \oplus a_n \}$

$= \begin{cases} n \equiv 0(\bmod\ {2}) \ \ a \\ n \equiv 1(\bmod\ {2}) \ \ S_1\end{cases}$

可以看到，如果 $n$ 为奇数，第二次操作的序列与原序列相同。否则与第一次相同。由此导出上面的结论。

----------------------

下面是喜闻乐见的代码，复杂度显然为 $O(Tn)$：

```cpp
#include <cstdio>

using namespace std;

const int N = 100010;
int T, n;
long long k, a[N];

int main() {
	scanf("%d", &T);
	while (T -- ) {
		scanf("%d%lld", &n, &k);
		for (int i = 1; i <= n; i ++ )
			scanf("%lld", &a[i]);
		if ((n % 2 == 0 && k % 2 == 1) || (n % 2 != 0)) {
			long long sum = 0;
			for (int i = 1; i <= n; i ++ )
				sum ^= a[i];
			for (int i = 1; i <= n; i ++ )
				printf("%lld ", sum ^ a[i]);
		}
		else {
			for (int i = 1; i <= n; i ++ )
				printf("%lld ", a[i]);
		} 
        puts("");
	}
	return 0;
}
```

---

## 作者：sto_5k_orz (赞：5)

我先说个结论：

当 $k\equiv 1\pmod 2$ 时，进行 $1$ 次操作。

当 $k\equiv 0\pmod 2$ 时，进行 $2$ 次操作。

证明：

定义 $f(a)$ 为 $a$ 变换一次的结果。

* 当 $k\equiv 1\pmod 2$ 时：

$f(f(f(a)))=f(f(a_2\oplus a_3\cdots \oplus a_n,a_1\oplus a_2\cdots \oplus a_n,\cdots,a_1\oplus a_2\cdots a_{n-1}))$

$=f(a_1\oplus a_2\oplus a_2\cdots \oplus a_n\oplus a_n,a_2\oplus a_1\oplus a_1\cdots \oplus a_n \oplus a_n,\cdots,a_1\oplus a_1\oplus a_2\oplus a_2\cdots \oplus a_n)$

$=f(a_1,a_2,\cdots,a_n)$

$=f(a)$

同理可得，当 $k\equiv 1\pmod 2$ 时，进行 $1$ 次操作。

* 当 $k\equiv 0\pmod 2$ 时：

通过之前的证明，令 $b=f(a)$。

$f(f(f(f(a))))=f(f(f(b)))=f(b)=f(f(a))$

那么一次两次就是直接暴力就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline
#define W while
#define gc getchar
#define pc putchar
#define int long long
namespace SlowIO { // 慢读慢写 
	I int read() {
		int x = 0, f = 1; char ch = gc();
		W(ch < '0' || ch > '9') {if(ch == '-') f = -f; ch = gc();}
		W(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
		return x * f;
	}
	I void Read(int &x) {x = read();}
	I void Read(int &x, int &y) {Read(x), Read(y);}
	I void write(int x) {
		if(x < 0) pc('-'), x = -x;
		if(x > 9) write(x / 10);
		pc(x % 10 + '0');
	}
	I void Write(int x) {write(x); pc(' ');}
} using namespace SlowIO;
const int N = 100010; int n, k, a[N];
signed main() {
	int q; Read(q); W(q--) {
		Read(n, k); k &= 1; for(int i = 1; i <= n; i++) Read(a[i]); if(!k) k = 2;
		W(k--) {
			int s = 0; for(int i = 1; i <= n; i++) s ^= a[i];
			for(int i = 1; i <= n; i++) a[i] ^= s;
		}
		for(int i = 1; i <= n; i++) Write(a[i]); pc('\n');
	}
	return 0;
}
```

---

## 作者：Register_int (赞：5)

由于是异或，所以只需要单独考虑每一位的影响，最后累加即可。

枚举每一位。由于数的顺序并不影响异或积的结果，可以直接统计个数。设该位为 $1$ 的数有 $x$ 个，为 $0$ 的有 $y$ 个。分成四种情况讨论：

#### 当 $x$ 为奇数，$y$ 为偶数时：

经过一次操作后，每一位均会变为奇数个 $1$ 的异或，得到 $x$ 个 $0$，$y$ 个 $1$。之后所有操作都不会影响二进制位，所以会保留在这个状态。

#### 当 $x$ 为偶数，$y$ 为奇数时：

与上个情况的最终状态相同，不会改变。

#### 当 $x$，$y$ 均为奇数时：

经过每次操作后，每个 $1$ 的位置上的数都为偶数个 $1$ 异或的结果，$0$ 则相反，二进制位都会反转，而个数的奇偶性不变，因此每一位由 $k$ 的奇偶性决定。

#### 当 $x$，$y$ 均为偶数时：

同理，个数奇偶性不变，每个 $1$ 的位置上的数都为奇数个 $1$ 异或的结果，$0$ 则相反，二进制位不变。

---

综上，可以总结出以上分支结构：

- 当 $x+y=n$ 为奇数时：
	- 如果 $x$ 为奇数，则将每位反转。
   - 否则，保持原样。
- 否则：
	- 如果 $x$ 为奇数：
		- 如果 $k$ 为奇数，则将每位反转。
		- 否则，保持原样。
	- 否则，保持原样。
    
时间复杂度为 $O(n\log V)$，可以通过。

# AC 代码 
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned uint;

const int MAXN = 1e5 + 10;

int t, n, k;

uint a[MAXN];

int main() {
	for (scanf("%d", &t); t--;) {
		scanf("%d%d", &n, &k);
		for (int i = 1; i <= n; i++) scanf("%u", &a[i]);
		for (int p = 0, x, y, z; p < 32; p++) {
			x = y = 0;
			for (int i = 1; i <= n; i++) a[i] >> p & 1 ? ++x : ++y;
			if (n & 1) for (int i = 1; i <= n; i++) a[i] ^= (x & 1) << p;
			else if (x & 1) for (int i = 1; i <= n; i++) a[i] ^= (k & 1) << p;
		}
		for (int i = 1; i <= n; i++) printf("%u ", a[i]); puts("");
	}
}
```

---

## 作者：GeorgeAAAADHD (赞：5)

这一题考察对异或性质的运用。让我们先来分类讨论一下:


------------

1. $n$ 为奇数的情况。

举个例子:

```cpp
2
3 1
1 3 2
3 2
1 3 2
```

我们发现，这两组数据的答案是一样的。

这是因为我们在进行第二次操作时，每个数会变成剩余偶数个数的异或和，而剩余的每个数加起来包含了偶数个原数组下操作数对应下标的数和奇数个其他下标下的数。而偶数个相同的数的异或和为 $0$，因此结果为原数组下其他下标上的数的异或和，也就是操作数。

还是按上面样例解释一下:

```cpp
1 3 2 //原数组
1 3 2 //第一次操作后
3^2 1^2 1^3 //第二次操作过程
1^2^1^3 3^2^1^3 3^2^1^2 //分解
2^3 1^2 1^3 //就是第一次操作的过程
```

相信大家应该懂了吧，当 $n$ 为奇数时，输出原数组异或积一次后的数组。

------------
2. $n$ 为偶数的情况。

还是来举个例子:

```cpp
4
4 1
1 2 3 4
4 2
1 2 3 4
4 3
1 2 3 4
4 4
1 2 3 4
```

我们发现，所有 $k$ 为奇数下的答案是相同的，所有 $k$ 为偶数的答案也是相同的。

按照 $n$ 为奇数时的推导过程，可以推出操作数变为了偶数个原数组的其他下标上的数的异或和与奇数个原数组对应下标上的数的异或和相异或的结果。而偶数个相同的数的异或和为 $0$，因此结果就是原数组上对应下标上的数。

仍然是解释一下样例:

```cpp
1 2 3 4 //原数组
5 6 7 0 //第一次操作后的结果
6^7^0 5^7^0 5^6^0 5^6^7 //第二次操作过程
1^3^4^1^2^4^1^2^3
2^3^4^1^2^4^1^2^3
2^3^4^1^3^4^1^2^3
2^3^4^1^3^4^1^2^4
//分解后的四个数
1 2 3 4 //化简后得到了原数组
```

------------
综上，我们得到了结论:

- 当 $n,k$ 中有一个为奇数时，输出原数组异或积一次后的数组。

- 否则输出原数组。

------------
那么问题来了，如何快速得到异或积一次后的数组？

其实很简单，只需要先计算原数组的异或和。因为异或积后每个数变为原数组其他下标上的数的异或和，并且两个相同的数异或后会变成 $0$，因此异或积后每个数变为原数组的异或和与原数组对应下标上的数异或后的结果。

这样，我们就能愉快地 AC 本题了！

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,t;
unsigned int a[100001],sum=0;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>k;
        sum=0;//初始赋值为0
        for(int i=1;i<=n;i++){
            cin>>a[i];
            sum^=a[i];
        }
        if(n%2||k%2){
            for(int i=1;i<=n;i++){
                cout<<(sum^a[i])<<' ';
            }
        }
        else{
            for(int i=1;i<=n;i++){
                cout<<a[i]<<' ';
            }
        }
        cout<<endl;//记得换行
    }
    return 0;
}
```

The end~

---

## 作者：_Remake_ (赞：5)

可以先设 $S_i$ 为进行 $i$ 次异或积变换之后序列内所有元素的异或和。

可以发现，当 $n$ 为奇数时，无论 $S_0$ 的值为多少，$S_1$ 一定为 `0`。
之后的变换也不会改变序列内元素的值。又因为 $k\geq1$，所以当 $n$ 为奇数时，答案为 $a_i \ \text{xor}\ S_0$。 

当 $n$ 为偶数时，可以发现 $S_i$ 的值始终不变。则每个元素有两种取值。

当 $k$ 为奇数时，答案为 $a_i \ \text{xor}\ S_0$。

当 $k$ 为偶数时，答案为 $a_i$。

---

## 作者：Elairin176 (赞：5)

[传送门](https://www.luogu.com.cn/problem/P9227)            
异或性质和找规律的好题。        
我们可以对 $n$ 和 $k$ 进行分类讨论，从奇偶性上分出四种情况：     
### $n$ 和 $k$ 都为偶数 
我们假设 $n=4$ 并且 $k=2$，那么对于第一次变换，新的 
- $a_1=a_2\bigoplus a_3\bigoplus a_4$
- $a_2=a_1\bigoplus a_3\bigoplus a_4$
- $a_3=a_1\bigoplus a_2\bigoplus a_4$
- $a_4=a_1\bigoplus a_2 \bigoplus a_3$          

进行第二次变换，则有 $a_i=a_i(i∈[1,n])$。        
所以对于这种情况，$a$ 不变。           
### $n$ 为偶数，$k$ 为奇数          
根据我们前面举的例子，容易发现对于这种情况，$a$ 变换了一次。         
### $n$ 为奇数，$k$ 为偶数     
我们假设 $n=3$ 并且 $k=2$，那么对于第一种变换，有：         
- $a_1=a_2\bigoplus a_3$
- $a_2=a_1\bigoplus a_3$
- $a_3=a_1\bigoplus a_2$     

接下来，进行第二次变换，有：        
- $a_1=a_2\bigoplus a_3$
- $a_2=a_1\bigoplus a_3$
- $a_3=a_1\bigoplus a_2$      

所以，在这种情况中 $a$ 进行了一次变换。       
### $n$ 和 $k$ 都为奇数  
根据我们前面的结论，易知 $a$ 都是进行了一次变换，因为 $k≠0$，所以我们不用考虑 $k=0$ 的特殊情况。            

总时间复杂度为 $O(tn)$，可以通过本题。        
[CODE](https://www.luogu.com.cn/paste/ekduu56f)

---

## 作者：Nuyoah_awa (赞：4)

### 题目大意
一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i=\bigoplus\limits_{j=1}^{n}[j\ne i]a_j$$
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出数列 $a$ 经过 $k$ 次异或积变换之后得到的数列。

### 前置知识

本题需要运用**异或**知识，如果不会异或或不清楚异或的性质，可以在 <http://oi-wiki.com/math/bit/> 上自学一下。

### 题目分析

首先想暴力求解，我们可以进行 $k$ 次异或积变换，每回 $\mathcal O(n)$ 求出 $b_i$，然后将 $a_i$ 替换为 $b_i$。

但是时间复杂度是 $\mathcal O(T \times n ^ 2 \times k)$ 的，只能过 $5$ 个点。

根据异或知识，我们知道如果 $x \oplus y = z$，那么，$z \oplus y = x$。由此，我们可以得出：

$$b_i=\bigoplus\limits_{j=1}^{n}[j\ne i]a_j = (\bigoplus\limits_{j=1}^{n}a_j) \oplus a_i$$

我们可以先 $\mathcal O(n)$ 预处理出 $\bigoplus\limits_{i=1}^{n}a_i$，然后就可以 $\mathcal O(1)$ 求出 $b_i$ 了。

于是我们就可以 $\mathcal O(T \times n \times k)$ 求解了，但是题目的数据范围规定 $1 \le k \le 10^{18}$，依旧过不了，我们发现：对于一个偶数位的数组 $a$，无论经过几次异或积变换，$\bigoplus\limits_{i=1}^{n}a_i$ 始终不变，对于一个奇数位的数组，从第 $2$ 次开始，每次异或积变换后，$\bigoplus\limits_{i=1}^{n}a_i$ 不变，于是我们只需要分类讨论一下，然后 $\mathcal O(n)$ 求解就行了。

具体分类如下：

- 如果 $n$ 为偶数，进行一次异或积变换。

- 如果 $n$ 为奇数，进行两次异或积变换。

> ps：见题面，记得开 `unsigned long long`。

### code
```cpp
#include <iostream>
#include <cstdio>
#define int unsigned long long
using namespace std;
const int N = 1e5 + 5;
int T, n, k, a[N], b[N], sum;
signed main()
{
	scanf("%u", &T);
	while(T--)
	{
		scanf("%u %u", &n, &k);
		sum = 0;
		for(int i = 1;i <= n;i++)
		{
			scanf("%u", &a[i]);
			sum ^= a[i];
		}
		k %= 2;
		k += n % 2;
		for(int i = 1;i <= k;i++)
		{
			for(int i = 1;i <= n;i++)
				b[i] = sum ^ a[i];
			sum = 0;
			for(int i = 1;i <= n;i++)
			{
				a[i] = b[i];
				sum ^= a[i];
			}
		}
		for(int i = 1;i <= n;i++)
			printf("%u ", a[i]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：August_Light (赞：2)

# P9227 异或积 题解

[题目传送门](https://www.luogu.com.cn/problem/P9227)

## 题意简述

### 定义

一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即

$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$

**异或积变换**是指将一个数列用它的异或积替换的过程。

### 问题

$T$ 组数据，给定一个长度为 $n$ 的数列 $a$，输出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

### 数据规模与约定

$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

## 前置知识

异或运算的性质：

- $a \oplus a = 0$
- $a \oplus 0 = a$

## 解法

### 暴力与优化

朴素暴力的时间复杂度为 $\mathcal O(n^2k)$，不能通过。

设 $sum(x)$ 为 $\bigoplus \limits_{j = 1}^{n} x_j$。

由异或运算的性质，发现

$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j \\

= a_i \oplus \bigoplus \limits_{j = 1}^{n} a_j \\

= a \oplus sum(a)$$

在每次变换前都 $\mathcal O(n)$ 预处理 $sum(a)$，可以把单次变换的时间复杂度从 $\mathcal O(n^2)$ 优化为 $\mathcal O(n)$。总时间复杂度 $\mathcal O(nk)$，但是依然不能通过。

## 正解

设 $c$ 数列为 $b$ 数列再变换一次得到的数列。

$$c_i = b_i \oplus sum(b) \\

=(a_i \oplus sum(a)) \oplus \bigoplus \limits_{j = 1}^{n} (a_i \oplus sum(a)) \\

=a_i \oplus sum(a) \oplus sum(a) \oplus \bigoplus \limits_{j = 1}^{n} sum(a) \\

= a_i \oplus \bigoplus \limits_{j = 1}^{n} sum(a) \\$$

也就是说:

- 当 $n$ 是偶数时，$c_i = a_i = b_i \oplus sum(a)$。即两次变换会相互抵消。此时看 $k$ 的奇偶性即可。

  - $k$ 为偶则全部抵消，直接输出 $a$。

  - $k$ 为奇则只需进行一次变换，输出 $b$。

- 当 $n$ 是奇数时，$c_i = a_i \oplus sum(a) = b_i$。$b_i = c_i$ 意味着：进行第一次变换之后再次变换就不会再发生变化。直接输出 $b$。

总结：

$n$ 与 $k$ 中有任何一个是奇数时，进行一次变换。否则不变。

时间复杂度 $\mathcal O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef unsigned int uint;
const int MAXN = 1e5 + 100;
int n; LL k;
uint a[MAXN];
void mov() {
    uint sum = 0;
    for (int i = 1; i <= n; i++)
        sum ^= a[i];
    for (int i = 1; i <= n; i++)
        a[i] ^= sum;
}
void print() {
    for (int i = 1; i <= n; i++)
        cout << a[i] << " \n"[i == n];
}
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int T; cin >> T; while (T--) {
        cin >> n >> k;
        for (int i = 1; i <= n; i++)
            cin >> a[i];

        if (n % 2 == 1 || k % 2 == 1)
            mov();
        print();
    }
    return 0;
}
```

---

## 作者：joyslog (赞：1)

给定长度为 $n$ 的数列 $a$。令数列 $F(a)$ 满足以下式子： 

$$F(a)_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
		
	
有 $k$ 轮变换，每次变换为 $a\gets F(a)$ 。输出最终会得到的数列。

$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

## 题解

一次变换相当于先求出序列的异或和 $sum$，然后将数列每个元素经过如下操作：

$$a_i \gets a_i \oplus sum$$

这是因为此时 $a_i$ 被异或了两遍，抵消了贡献。

然后我们考虑**第一次操作**之后，新的序列的异或和 $sum'$ 有什么性质。由于异或运算有交换律和结合律，我们有可以这样推导：

$$sum'=\bigoplus \limits_{i = 1}^n (a_i\oplus sum)=sum\oplus \bigoplus \limits_{i = 1}^n sum=\begin{cases}0 & n \text{为奇数} \\ sum & n \text{为偶数}\end{cases}$$

我们按 $n$ 的奇偶性来分类。

1. 如果 $n$ 为**奇数**，则 $sum'=0$。所以 $a_i\oplus sum'=a_i$。这种情况下，无论进行多少次变换数列都**不会再变化**了，因为异或和始终为 $0$。

2. 如果 $n$ 为**偶数**，则 $sum'=sum$，所以$a_i \oplus sum'=a_i\oplus sum$，相当于 $sum$ 被异或了两次抵消，所以 $a_i$ 会变成最初的 $a_i$。所以若进行多次变换，数列只会在**两种状态下来回变化**。只要判一下 $k$ 的奇偶性即可。

我们只需要按 $n$ 和 $k$ 的奇偶性分类，最终输出的数列一定为原数列或进行一次变换的数列。

时间复杂度 $\mathcal{O}(Tn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll read() {...}
char buf[50];
inline void write(ll x) {...}

const int MAX_N = 1e5 + 10;
ll T, n, k;
unsigned int sum, a[MAX_N];

int main() {
	T = read();
	while(T--) {
		n = read(), k = read();
		sum = 0;
		for(int i = 1; i <= n; i++)
			a[i] = read(), sum ^= a[i];
		if((n & 1) || (!(n & 1) && (k & 1))) {
			for(int i = 1; i <= n; i++)
				write(sum ^ a[i]), putchar(' ');		
		}
		else {
			for(int i = 1; i <= n; i++)
				write(a[i]), putchar(' ');	
		}
		putchar('\n');
	}
	return 0;
}
```


---


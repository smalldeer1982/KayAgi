# 「KDOI-06-J」翻转与反转

## 题目描述

小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。

在第 $i$ 次操作中（$1\le i\le n$），小 W 将按顺序执行以下**两种**变换：

1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\ldots,a_{1},a_{i+1},a_{i+2},\ldots,a_n$。
2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\le j\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。

小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。

## 说明/提示

**【样例解释 #1】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 序列 $a$ 的变化 |
| :--: | :--: |
| $1$ | $[1,1,1]\to [1,1,1]\to[0,1,1]$ |
| $2$ | $[0,1,1]\to [1,0,1]\to[0,1,1]$ |
| $3$ | $[0,1,1]\to [1,1,0]\to[0,0,1]$ |

**【样例解释 #2】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $[1,0,1,1,1,0,0,1]$ |
| $1$ | $[0,0,1,1,1,0,0,1]$ |
| $2$ | $[1,1,1,1,1,0,0,1]$ |
| $3$ | $[0,0,0,1,1,0,0,1]$ |
| $4$ | $[0,1,1,1,1,0,0,1]$ |
| $5$ | $[0,0,0,0,1,0,0,1]$ |
| $6$ | $[1,0,1,1,1,1,0,1]$ |
| $7$ | $[1,0,0,0,0,1,0,1]$ |
| $8$ | $[0,1,0,1,1,1,1,0]$ |

**【样例 #3】**

见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。

**【样例 #4】**

见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。


**【数据范围】**

对于所有数据保证：$1\le n\le 2\times 10^6$，且对于任意 $1\le i\le n$，$a_i=0$ 或 $1$。

| 测试点编号 | $n\le$ |  特殊性质 |
| :-----------: | :-----------: | :----------: |
| $1\sim 3$ | $10^3$ | 无 |
| $4\sim 5$ | $10^5$ | 无 |
| $6 \sim 7$ | $2\times 10^6$ | $a_i=0$ |
| $8\sim 10$ | $2\times 10^6$ | 无 | 


## 样例 #1

### 输入

```
3
1 1 1
```

### 输出

```
0 0 1 
```

## 样例 #2

### 输入

```
8
1 0 1 1 1 0 0 1
```

### 输出

```
0 1 0 1 1 1 1 0 
```

# 题解

## 作者：wjx38223 (赞：28)

模拟可得 $O(n)$ 的做法。

根据题意可知，共有 $n$ 个元素，进行 $n$ 次操作，每一次操作的范围是 $[1],[1,2],[1,2,3],[1,2,3,4] .....$，那么第 $1$ 个元素操作 $n$ 次，第 $2$ 个元素操作 $n-1$ 次，以此类推，**第 $i$ 个元素需要操作 $n-i+1$ 次**。

对于第 1 个变换，可以发现，第 $i$ 位在进行它的第一次操作时向去前移动了 $i-1$ 位，而它的第二次操作时向后移动 $i$ 位，它的第三次操作时又向前移动  $i-1$ 位，**推理可知，操作两次共往后移动了 $1$ 位，如果有剩余，那么就是再往前移动了 $i-1$ 位**。

对于第 2 个变换，现象就很明显了，**操作奇数次时**（例如 $0$ -> $1$ -> $0$ -> $1$）**，这一位上会变换，反之，操作偶数次时，这一位上不会变换**（例如 $0$ -> $1$ -> $0$）。

联合以上我们总结出的规律，可以写出 $O(n)$ 的代码：

```cpp
#include<bits/stdc++.h>
#define int long long //常开long long好习惯
using namespace std;
int n;
char s[2000010]; //s用来存储原序列
char ans[2000010]; //ans用来存储答案序列
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	//对于1，每次往前0位往后1位 
	//对于2，每次往前1位往后2位 
	//对于n，每次往前n-1位往后n位，那么两次往后1位 
	//对于i，操作n-i+1次 
	//只需要判断操作次数的奇偶，以此类推 
	for(int i = 1; i<=n; i++){
		cin >> s[i];
	}
	int p; 
	for(int i = 1; i<=n; i++){
		int at = 0; //at代表移动后的位置
		p = n-i+1;//p代表第i位共计的操作次数
		if(p%2==0){ //如果操作次数是偶数
			at = p/2;//直接向后移动p/2位（两次操作前进一位）
			ans[i+at] = s[i];
		}else{
			p--; 
			at += p/2*i;//一共向后移动了p/2*i位（一次移动i位）
			at -= (p/2+1)*(i-1);//一共向后移动了(p/2+1)*(i-1)位（一次移动i-1位）
			if(s[i]=='0'){ //因为是奇数次操作，所以要改变原元素
				ans[i+at] = '1';
			}else{
				ans[i+at] = '0';
			}
		}
		
	}
	for(int i = 1; i<=n; i++){
		cout << ans[i] << " "; //输出答案即可
	}
	return 0;
}


```

---

## 作者：Eleveslaine (赞：17)

规律题当然看到就要手动模拟啦！

考虑 $n=5$，初始序列是 $a_1,a_2,a_3,a_4,a_5$，我们来模拟一下：（方便起见，这里令 $!x$ 表示 $x$ 取反）

第一次操作：

$$!a_1,a_2,a_3,a_4,a_5$$ 

第二次操作，先把 $a_1,a_2$ 交换顺序，再分别取反，由于 $!(!a_1)=a_1$，所以结果为

$$
!a_2,a_1,a_3,a_4,a_5
$$

以此类推（请读者自行模拟剩余操作），最终结果为

$$
!a_5, !a_3, !a_1, a_2, a_4
$$

可以发现原下标为奇数的现在都取反并按照下标降序跑到了左边，偶数都按照下标升序跑到了右边。然后再试一下 $n=4$，最终结果为：

$$
!a_4, !a_2, a_1, a_3
$$

可以发现原下标为偶数的现在都取反并按照下标降序跑到了左边，奇数都按照下标升序跑到了右边。所以分 $n$ 的奇偶两种情况讨论即可。这种结论自己模拟找找规律很容易发现的，所以不再麻烦地证明。

时间复杂度 $O(n)$。因为只会在开头、末尾添加数，所以可以用 STL 链表模拟。

这样我们就随手秒掉了这题！

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e6+5;
int n;
bitset <maxn> a;
list <bool> ans;
int main()
{
    cin >> n;
    for(int i=1,x;i<=n;++i)
        cin >> x,a.set(i,x);
    if(n&1) // n&1：n 是奇数
    {
        for(int i=1;i<=n;++i)
            if(i&1)
                ans.push_front(!a[i]);
            else
                ans.push_back(a[i]);
    }
    else // n 是偶数
    {
        for(int i=1;i<=n;++i)
            if(i&1)
                ans.push_back(a[i]);
            else
                ans.push_front(!a[i]);
    }
    for(bool x:ans)
        cout << x << ' ';
    return 0;
}
```

后记：T1 `NaN` 打成 `Nan` 怒挂 $60$。

---

## 作者：Y_Aridy (赞：12)

# [题目传送门](https://www.luogu.com.cn/problem/P9741)
## Part 1：
**前言：**

看到本题直接暴力，看完数据范围后很明显的 TLE，只有 $ 30 $ 分（[记录](https://www.luogu.com.cn/record/129725644)）。

在 $ O(n) $ 复杂度的压迫下，硬推半个小时才推出来的 T2 ~~（橙题推半个小时，我太蒻了）~~。

------------
## Part 2：
**题意理解:**

我们有长度为 $ n $ 的 $ 01 $ 串，我们进行 $ n $ 次操作将其变为我们所求答案。

对于第 $ i $ 次操作，我们有两个具体形式：

1. 将 $ 1 \sim i $ 之间的数翻转。

	即：
    ```
	for(int k=1;k<=i/2;k++){
		swap(a[k],a[i-k+1]);
	}
	```
2. 将 $ 1 \sim i $ 之间的数做取反操作。

	即：
    ```
	for(int k=1;k<=i;k++){
		a[k]^=1;
	}
	```

在进行完 $ n $ 次操作后，输出最终串。

------------
**部分分:**

具体地，我们暴力模拟每一次操作，输出答案即可。

复杂度为 $ O(n^2) $，对于前三个测试点 $ n \le 10^3 $ 的范围可以通过，分数为 $ 30 $，记录详见 Part 1。

------------
**推导:**

我们对样例 $ 1 $ 做推导解释。

**样例 $ 1 $：**

| | $ 1 $ | $ 2 $ | $ 3 $ |
| :----------: | :----------: | :----------: | :----------: |
| $ 1 $ | $ 1 \rightarrow 1 $ | $ 2 \rightarrow 1 $ | $ 3 \rightarrow 1 $ |
| $ 2 $ | - | $ 1 \rightarrow 2 $ | $ 2 \rightarrow 2 $ |
| $ 3 $ | - | - | $ 1 \rightarrow 3 $ |

这样定义：第一行为我们当前的操作数，以下为每个数对应的转移。

什么意思，我们拿 $ 1 \rightarrow 3 $ 来解释：

用上一次操作的 $ 1 $ 取反得到这一次操作的 $ 3 $。

表格是怎么列出来的，返回我们的题意部分，两个代码块综合一下，我们可以发现**这一次的操作是由翻转对应的数的上一次操作的结果取反得到的**，具体地：

| 下标 | $ 1 $ | $ 2 $ | $ 3 $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 对应串 | $ 1 $ | $ 1 $ | $ 1 $ |

对于第三次操作，下标 $ 3 $ 翻转对应下标 $ 1 $，所以我们第三次操作的下标 $ 3 $ 对应串是由第二次操作的下标 $ 1 $ 对应串取反得到的。

第一次操作：

只有下标 $ 1 $ 的对应串变动，是由原下标 $ 1 $ 对应串取反得到的，变为：

| 下标 | $ 1 $ | $ 2 $ | $ 3 $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 对应串 | $ 0 $ | $ 1 $ | $ 1 $ |

第二次操作：

此时下标 $ 1 $ 对应下标 $ 2 $，由原下标 $ 2 $ 对应串取反得到，下标 $ 2 $ 对应下标 $ 1 $，由操作 $ 1 $ 中下标 $ 1 $ 对应串取反得到，变为：

| 下标 | $ 1 $ | $ 2 $ | $ 3 $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 对应串 | $ 0 $ | $ 1 $ | $ 1 $ |

第三次操作：

下标 $ 1 $ 对应下标 $ 3 $，由原下标 $ 3 $ 对应串取反得到，下标 $ 2 $ 对应下标 $ 2 $，由第二次操作中下标 $ 2 $ 对应串取反得到，下标 $ 3 $ 对应下标 $ 1 $，由第二次操作中下标 $ 1 $ 对应串取反得到，变为：

| 下标 | $ 1 $ | $ 2 $ | $ 3 $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 对应串 | $ 0 $ | $ 0 $ | $ 1 $ |

我们由第 $ n $ 次操作顺次向前推，推得每个对应下标最终值由原串哪一下标决定。

对此不难发现：
```
a[1]=a[3]^1;a[2]=a[1]^1;a[3]=a[2];
```
对于样例 $ 2 $，我们有这样的表格：

|  | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $ 1 \rightarrow 1 $ | $ 1 \rightarrow 2 $ | $ 1 \rightarrow 3 $ | $ 1 \rightarrow 4 $ | $ 1 \rightarrow 5 $ | $ 1 \rightarrow 6 $ |$ 1 \rightarrow 7 $  | $ 1 \rightarrow 8 $ |
| $2$ | - | $ 2 \rightarrow 1 $ | $ 2 \rightarrow 2 $ | $ 2 \rightarrow 3 $ | $ 2 \rightarrow 4 $ | $ 2 \rightarrow 5 $ | $ 2 \rightarrow 6 $ | $ 2 \rightarrow 7 $ |
| $3$ | - | - | $ 3 \rightarrow 1 $ | $ 3 \rightarrow 2 $ | $ 3 \rightarrow 3 $ | $ 3 \rightarrow 4 $ | $ 3 \rightarrow 5 $ | $ 3 \rightarrow 6 $ |
| $4$ | - | - | - | $ 4 \rightarrow 1 $ | $ 4 \rightarrow 2 $ | $ 4 \rightarrow 3 $ | $ 4 \rightarrow 4 $ | $ 4 \rightarrow 5 $ |
| $5$ | - | - | - | - | $ 5 \rightarrow 1 $ | $ 5 \rightarrow 2 $ |$ 5 \rightarrow 3 $  | $ 5 \rightarrow 4 $ |
| $6$ | - | - | - | - | - | $ 6 \rightarrow 1 $ | $ 6 \rightarrow 2 $ | $ 6 \rightarrow 3 $ |
| $7$ | - | - | - | - | - | - | $ 7 \rightarrow 1 $ | $ 7 \rightarrow 2 $ |
| $8$ | - | - | - | - | - | - | - | $ 8 \rightarrow 1 $ |

我们同样顺次往前推，可以得到：
```
a[1]=a[8]^1;a[2]=a[6]^1;a[3]=a[4]^1;a[4]=a[2]^1;
a[5]=a[1];a[6]=a[3];a[7]=a[5];a[8]=a[7];
```
不难发现， **$ 1 $ 由 $ n $ 决定，$2$ 由 $n-2$ 决定 $\cdots$ $\left\lceil\dfrac{n}{2}\right\rceil$ 由 $1$（$n$ 为奇数）或者 $2$（$n$ 为偶数）决定（均为对应取反）。**

**$n$ 由 $n-1$ 决定，$n-1$ 由 $n-3$ 决定 $\cdots$ $\left\lceil\dfrac{n}{2}\right\rceil+1$ 由 $2$（$n$ 为奇数）或者 $1$（$n$ 为偶数） 决定（均为直接赋值）。**

于是我们有了我们的核心代码：
```
//求解 1~ceil(n/2) 
int i=1;
//从n开始，每次-2，对应取反 
for(int t=n;t>=1;i++,t-=2){
	now[i]=pas[t]^1;
}
//求解 n~ceil(n/2)+1 
int j=n;
//从n-1开始，每次-2，对应赋值 
for(int t=n-1;t>=1;j--,t-=2){
	now[j]=pas[t];
}
```

------------
## Part 3：
**完整代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+7;
int n;
int now[maxn];
int pas[maxn];
int main(){
//	freopen("revflip.in","r",stdin);
//	freopen("revflip.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>pas[i];
	}
	//求解 1~ceil(n/2) 
	int i=1;
	//从n开始，每次-2，对应取反 
	for(int t=n;t>=1;i++,t-=2){
		now[i]=pas[t]^1;
	}
	//求解 n~ceil(n/2)+1 
	int j=n;
	//从n-1开始，每次-2，对应赋值 
	for(int t=n-1;t>=1;j--,t-=2){
		now[j]=pas[t];
	}
	for(int k=1;k<=n;k++){
		cout<<now[k]<<' ';
	}
	return 0;
}
```

写题解不易 T^T，如有错误，请 dalao 指出~~并踩爆~~。

---

## 作者：Xdwjs (赞：8)

对于“翻转”（第一种变换），我们不妨设原数列为 ```123456789```，找个规律。

以下第 $i$ 次操作中，只列举转了的前 $i$ 个数。

第一次：数列为 ```1```。

第二次：数列为 ```21```。

第三次：第二次的数列翻过来，加一个 ```3```，即为 ```312```。

第四次：第三次的数列再翻过来，加一个 ```4```，即为 ```4213```。

以此类推。第九次操作后，数列为 ```975312468```。

我们可以很明显地观察出，奇数位最后总是堆在一边，偶数位总是堆在另一边。至此，我们找到规律：

- 当数列长度 $n$ 为奇数时，前 $(n+1)\div2$ 个数为从 $n$ 到 $1$ 的连续奇数，后 $(n-1)\div2$ 个数为从 $2$ 到 $n-1$ 的连续偶数；

- 当数列长度 $n$ 为偶数时，前 $n\div2$ 个数为从 $n$ 到 $2$ 的连续偶数，后 $n\div2$ 个数为从 $1$ 到 $n-1$ 的连续奇数。

而对于“反转”（第二种变换），容易想到，如果数列长度为 $n$，第 $1$ 个数字就被变换了 $n-1$ 次，第 $2$ 个数字就被变换了 $n-2$ 次，以此类推，第 $i$ 个数字就被变换了 $n-i$ 次。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[2000005];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if((n-i+1)%2==1) a[i]=!a[i];
    }
    for(int i=n;i>=1;i-=2) cout<<a[i]<<" ";
    for(int i=(n%2==0?1:2);i<=n;i+=2) cout<<a[i]<<" ";
    //system("pause");
    return 0;
}
```

---

## 作者：MarsTraveller (赞：7)


# 前言：
这是一道 T2，我们应该使用数学、找规律。

先看一下数据范围： $n \le 2 \times 10^6$。

暴力复杂度 $O(n^2)$，喜提 30pts。

**所以：找规律，启动！！**

# 思路简述：
题目中有两个操作，分别是反转数组反转数值。
我们可以将两个操作分开考虑。

## 1.反转数组：
每次操作只会在对前 $i$ 个数进行改动，所以我们可以看做长度为 $i-1$ 的操作即是长度为 $i$ 的操作的前缀。

这样，长度为 $i$ 的数据位置即是将位置 $i$ 放在最前面，接上长度为 $i-1$ 的数据位置的反转。

举个例子：

长度为 $3$ 的数据位置为：
``` 3 1 2```。

长度为 $4$ 的数据位置为：
```4``` 和 ```2 1 3```。

即：```4 2 1 3```。

这样我们可以构建出一个数据位置数组 $id$：

```
1
2 1
3 1 2
4 2 1 3
5 3 1 2 4
6 4 2 1 3 5
7 5 3 1 2 4 6
...
```
我们观察每一行，找到 $1$ 的位置，再次寻找 $2$，$3$，$4$ 的位置，我们惊奇的发现，这些数一左一右的排列着。我们列出序列的性质：
- 相邻两数 $x$ 和 $x+1$ 之间的距离为 $x$。
- 当序列长度 $n$ 为奇数时，从 $1$ 开始先向右构造；为偶数时，先向左构造。

根据如下性质，可以通过 $O(n)$ 的复杂度构造这个序列。

接下来，我们只需要思考操作二的规律了。

## 2.反转数值：

有了数据位置的数组，我们就可以统计这个位置的数值被反转了几次。

联系 Part1 中的数组 $id$，我们构造出如下反转次数序列：
```
1
1 2
1 3 2
1 3 4 2
1 3 5 4 2
1 3 5 6 4 2
1 3 5 7 6 4 2
...
```
由于反转两次后就相当于没反转，所以当反转次数为偶数时，相当于反转 $0$ 次；为奇数时，相当于反转 $1$ 次，我们可以修改序列：

```
1
1 0
1 1 0
1 1 0 0
1 1 1 0 0
1 1 1 0 0 0
1 1 1 1 0 0 0
...
```

再次观察 $1$ 和 $0$ 的分布和数量，得出如下性质：

- $1$ 的数量为 `(n+1)/2`。
- $1$ 和 $0$ 分布在数组两侧。

只需要用一个变量记录反转的个数，分段输出即可。
# 代码：

总时间复杂度 $O(n)$。
```cpp
#include <iostream>
#define big long long
using namespace std;
big n;
big a[2000006];
big id[2000006];
big q,h;
void init(big k,big op,big l,big w) // 变量表示：当前数据编号，左或右，距离，当前位置
{
	if(k == n+1)
	{
		return;
	}
	if(op == 1)
	{
		id[w+l] = k;
		init(k+1,0,l+1,w+l);
	}
	if(op == 0)
	{
		id[w-l] = k;
		init(k+1,1,l+1,w-l);
	}
}
int main()
{
	cin >> n;
	for(big i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	big mid = (n+2)/2;
	id[mid] = 1;
	if(n%2 == 1) // 构造数据位置数组
	{
		init(2,1,1,mid);
	}
	else
	{
		init(2,0,1,mid);
	}
//	for(big i = 1;i <= n;i++)
//	{
//		cout << id[i];
//	}
	q = (n+1)/2; // 需要反转的数量
	for(big i = 1;i <= q;i++)
	{
		cout << (a[id[i]]^1) << " ";
	}// 输出反转的
	for(big i = q+1;i <= n;i++)
	{
		cout << a[id[i]] << " ";
	}// 输出其余的
	return 0;
}
```

---

## 作者：User_Artist (赞：6)

# 「KDOI-06-J」翻转与反转

## 审题

 题面传送门 [P9741「KDOI-06-J」翻转与反转](https://www.luogu.com.cn/problem/P9741)。

 概括：希望在一个长度为 $n$ 的序列 $a$ 中，对前 $i$ 个数字（$1 \le i \le n$）依次进行以下下操作：

1. 整段数字首尾翻转（以下称 **Rev** 操作）；
2. 所有非零数变为 $1$，所有 $0$ 变为 $1$（以下称 **Flip** 操作）。
 
------------

 那么，方法**很简单**~~（不会有人去模拟吧？）~~：

1. 因为对于 $1 \le i \le n$ 的每个 $a_i$，一定执行过 **Flip** 操作，所以可以建立序列 $b$ 存储操作结果，其中只有 $0$ 和 $1$。
2. 由于从前 $1$ 个数到前 $n$ 个数依次执行 **Rev** 操作，所以最终序列 $b$ 的顺序（未 **Flip** 操作）为 $a_n, a_{n - 2}, \dots, a_3, a_1, a_2, \dots, a_{n - 3}, a_{n - 1}$。对此，可理解为将 $a_n, a_{n - 2}, \dots$ 依次放到 $b$ 的前端，将 $a_{n - 1}, a_{n - 0}$ 依次放到 $b$ 的后端。
```
	l = 1, r = n;
	for(int i = 0; i < n; ++ i)//不是最终代码
		if(i % 2) b[r --] = a[n - i];
		else b[++ l] = a[n - i];
``` 
3. 由于每执行两次 **Flip** 操作会抵消，所以可以理解为对于 $a_n, a_{n - 2}, \dots$ 不用执行 **Flip** 操作，而对于 $a_{n - 1}, a_{n - 0}$ 只用执行一次 **Flip** 操作。
```
	if(i % 2) b[r --] = (a[n - i] == 1) ? 1 : 0;
	else b[++ l] = (a[n - i] == 1) ? 0 : 1;
``` 

4. 经过分析，复杂度为 $\operatorname{O}(n)$，可行。

------------

### 完整代码

```cpp
#include <cstdio>
int n, l, r, a[2000006], b[2000006];
int main() {
	scanf("%d", &n), r = n;
	for(int i = 1; i <= n; ++ i) scanf("%d", a + i);
	for(int i = 0; i < n; ++ i)
		if(i % 2) b[r --] = (a[n - i] == 1) ? 1 : 0;//Flip 偶数次
		else b[++ l] = (a[n - i] == 1) ? 0 : 1;//Flip 奇数次
	for(int i = 1; i <= n; ++ i) printf("%d ", b[i]);
}
```
------------

### 完结撒花
 欢迎提出疑惑和进行题目上的交流！

---

## 作者：1004779564bzbjj (赞：5)

~~这就是一道数学题？~~

## 思路

题目要求对一个长度为 $n$ 的 $01$ 序列进行 $n$ 次操作，很显然，暴力是过不了全部数据的。

于是，我们对操作进行一些分析：

首先，是**按下标翻转**：

假设原有下标是 $1,2,3,\ldots,n$ ，

经过第一次翻转，在 $1$ 到 $1$ 这个区间翻转，下标顺序变成了：
$$1,2,3,\ldots,n$$
经过第二次翻转，在 $1$ 到 $2$ 这个区间翻转，下标顺序变成了：
$$2,1,3,\ldots,n$$
第三次翻转后：
$$3,1,2,\ldots,n$$
以此类推，我们发现，这个序列最终会变成：
$$n,n-2,n-4,\ldots,n-5,n-3,n-1$$
例如，长度为 $5$ 的序列翻转后的顺序为：
$$5,3,1,2,4$$
经过分析，可以得到，当序列长度为偶数且 $i$ 为奇数或序列长度为奇数且 $i$ 为偶数时，第 $i$ 个数的最终位置为 $\lfloor n/2 \rfloor + \lfloor i/2 \rfloor + 1$。

否则，第 $i$ 个数的最终位置为 $\lfloor n/2 \rfloor - \lfloor i/2 \rfloor + 1$。

至此，我们做完了这道题的一半，题目还要求我们进行另一种操作：**按数值翻转**。

相对于按下标翻转，按数值翻转就简单多了，经过分析，我们可以很容易得到：当序列长度 $n$ 为奇数时，原下标为奇数的数经过奇数次翻转，当序列长度 $n$ 为偶数时，原下标为偶数的数经过奇数次翻转。

反之，当序列长度 $n$ 为奇数时，原下标为偶数的数经过偶数次翻转，当序列长度 $n$ 为偶数时，原下标为奇数的数经过偶数次翻转。

由于该序列是一个 $01$ 序列，所以偶数次翻转等于不翻转，只要在输出时将奇数次翻转的数 $+1$ 再对 $2$ 取模即可。

通过前面关于按照下标翻转的分析，我们知道，序列长度为奇数时，序列的前 $\lceil n/2 \rceil$ 项是奇数，序列长度为偶数时，序列的前 $\lceil n/2 \rceil$ 项是偶数。

所以，在输出时，只要我们对数组下标小于等于 $\lfloor (n+1)/2 \rfloor$ 的数值 $+1$ 再对 $2$ 取模后输出，其余数值直接按照数组下标输出即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n;
int a[2000100];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		if(i%2+n%2==1){
			cin>>a[n/2+i/2+1];
		}
		else{
			cin>>a[n/2-i/2+1];
		}
		//将按下标翻转后的数值存入数组
	}
	for(int i=1;i<=n;i++){
		if(i<=(n+1)/2)//n/2的向上取整
			cout<<(a[i]+1)%2<<" ";
			//处理后输出
		else
			cout<<a[i]<<" ";
	}
	return 0;
}
```


---

## 作者：__zhuruirong__ (赞：5)

说实在的，这道题真的不难，只是题面太毒瘤，足足卡了我两个半小时。

## 算法一：

直接暴力求解，流程没什么好讲的。算法复杂度 $\mathcal O(n^2)$，期望得分三十分。

## 算法二：

很容易发现，在被取反次数为偶数时，不需要对这个数的值进行修改，在为奇数时，去翻转一次就行了，所以每个数操作后的值可以预处理。这是算法一的一个小小的优化，算法复杂度还是 $\mathcal O(n^2)$。

## 算法三：

结合算法二可得知，我们只需要知道操作完成后每个数的位置，就可以还原整个数组。

我们可以看一下每个位置的变化规律：

$1\rightarrow1\rightarrow2\rightarrow2\rightarrow3\rightarrow3\rightarrow4\rightarrow4\rightarrow5\rightarrow5
\cdots$

$2\rightarrow2\rightarrow1\rightarrow3\rightarrow2\rightarrow4\rightarrow3\rightarrow5\rightarrow4\rightarrow6
\cdots$

$3\rightarrow3\rightarrow3\rightarrow1\rightarrow4\rightarrow2\rightarrow5\rightarrow3\rightarrow6\rightarrow4
\cdots$

$4\rightarrow4\rightarrow4\rightarrow4\rightarrow1\rightarrow5\rightarrow2\rightarrow6\rightarrow3\rightarrow7
\cdots$

$\cdots$

可以发现，对于每个 $1\le i\le n$，前 $i$ 个数字都是 $i$（当 $i$ 为 $1$ 时，第 $i+1$ 位置上还有一个 $1$，但不影响结果，所以不用太在意），并且第 $i+1$ 个位置上的数字一定为 $1$。

再仔细观察，又可以发现对于第 $i$ 个排列，从 $i+1$ 位置开始看，第偶数个数字是前一个数字加 $i$，第奇数个数字是前一个数字数字减 $i-1$。

这样，时间复杂度被我们优化到了 $\mathcal O(n)$，期望得分一百分。

## AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e6 + 10;
int n;
int a[N];
int ans[N];

int main() {
	
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) { 
		int num = n - i + 1;      // 数列的长度
		int j = i + num / 2;      // 前面num/2*2个数字的贡献为num/2*2
		if(num & 1) j -= i - 1;   // 如果还多出了一个数字，则需要减去i-1
		if(num & 1) ans[j] = !a[i]; // 赋值
		else ans[j] = a[i];
	}
	for(int i = 1; i <= n; i++) cout << ans[i] << " ";
	
	return 0;
}
```

完结撒花！

~~我太蒻了，规律横着看的，没想到竖着找规律跑的快一些~~

---

## 作者：yuanbao2013 (赞：4)

## 前言
打比赛的时侯手动模拟了一下，发现了一个能 AC 的规律，于是想发篇题解
## 前置芝士：list
list 是 c++ 的双向链表，使用如下。
```cpp
list<int>my_list;//定义一个空list
bool e=my_list.empty()//返回list是否为空
int s=my_list.size()//返回list的长度
my_list.push_front(114514)//在链表前面插入114514
my_list.push_back(1919810)//在链表后面插入1919810
int f=my_list.front()//返回链表最前面的数
int b=my_list.back()//返回链表最后面的数
my_list.pop_front()//删除链表最前面的数
my_list.pop_back()//删除链表最后面的数
```
## 思路
看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/i6ltm0tu.png)

我们可以发现如果 $i \bmod 2 = n \bmod 2$ 那我们要把 $\lnot a_i$ 插入到链表的前面；否则我们要把 $a_i$ 插入到链表的后面。得出了结论就开始写代码吧。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2000001];
list<int>l;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(n%2==i%2)
			l.push_front(!a[i]);
		else
			l.push_back(a[i]);
	}
	while(!l.empty()){
		printf("%d ",l.front());
		l.pop_front();
	}
	return 0;
}
```

---

## 作者：403notfound (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P9741)
## 题意简述
给出一个长度为 $n$ 的 $01$ 序列，对这个序列进行 $n$ 次操作，对于第 $i$ 次操作，先翻转 $[1,i]$ 区间内的值，再将 $[1,i]$ 内的值进行非运算。求该操作后该序列每个元素的值。
## 求解
对于一个序列 $a_1,a_2,\ldots, a_n$。

当 $n$ 为偶数时，有一个序列 $a_1,a_2,\ldots, a_n$。
| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $a_1,a_2,\ldots, a_n$ |
| $1$ | $!a_1,a_2,\ldots, a_n$ |
| $2$ | $!a_2,a_1,\ldots, a_n$ |
| $3$ | $!a_3,!a_1,a_2,\ldots, a_n$ |
| $\ldots$ | $\ldots$ |
| $n$ | $!a_n,!a_{n-2},\ldots,!a_2,a_1,a_3,\ldots,a_{n-3},a_{n-1}$ |

当 $n$ 为奇数时，有一个序列 $a_1,a_2,\ldots, a_n$。
| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $a_1,a_2,\ldots, a_n$ |
| $1$ | $!a_1,a_2,\ldots, a_n$ |
| $2$ | $!a_2,a_1,\ldots, a_n$ |
| $3$ | $!a_3,!a_1,a_2,\ldots, a_n$ |
| $\ldots$ | $\ldots$ |
| $n$ | $!a_n,!a_{n-2},\ldots,!a_1,a_2,\ldots,a_{n-3},a_{n-1}$ |

## 模拟
如果 $n$ 为 $2$ 的倍数，先输出 $a_n,a_{n-2},\ldots,a_2$ 的取反后的值，再输出 $a_1,a_3,\ldots,a_{n-1}$ 的值。

如果 $n$ 不为 $2$ 的倍数，先输出 $a_n,a_{n-2},\ldots,a_1$ 的取反后的值，再输出 $a_2,a_4,\ldots,a_{n-1}$ 的值。

注意，$n$ 的范围为 $1\le n\le 2\times 10^6$！

## 代码
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n , a[2000005];
int main(){
	scanf("%lld",&n);
	for (int i = 1;i <= n;i++) scanf("%lld",&a[i]);
	if (n % 2 == 1){
		for (int i = n;i >= 1;i -= 2) printf("%lld ",!a[i]);
		for (int i = 2;i <= n - 1;i += 2) printf("%lld ",a[i]);
	} 
	else{
		for (int i = n;i >= 2;i -= 2) printf("%lld ",!a[i]);
		for (int i = 1;i <= n - 1;i += 2) printf("%lld ",a[i]);
	}
	return 0;
} 
``````


---

## 作者：CarlosLiu (赞：1)

## 题意描述
给你一个长为 $n$ 的序列。对于每一个不超过 $n$ 的 $i$ 将依次进行下标翻转和数值翻转。求最后序列的样子。
## 解题思路
对于原来是第 $i$ 项的那个数，总共会受到 $n-i+1$ 次数值翻转。可以跟据此数奇偶性判断最后变成的数。但是，这个数在哪里呢？根据数学归纳法和少量尝试，可以发现 $i\le\lfloor \frac{n+1}{2} \rfloor$ 时原第 $2+n-2i$ 项变到第 $i$ 项。而 $i>\lfloor \frac{n+1}{2} \rfloor$ 时原第 $2i-1-n$ 项变到第 $i$ 项。运用这两点，可以直接求出每一项的值。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,a[2000009],b[2000009];
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	if(n%2==0) {
		for(int i=1;i<=n/2;i++) b[i]=2+n-2*i;
		for(int i=n/2+1;i<=n;i++) b[i]=2*i-1-n;;
	}else {
		for(int i=1;i<=n/2+1;i++) b[i]=2+n-2*i;
		for(int i=n/2+2;i<=n;i++) b[i]=2*i-1-n;
	}
	for(int i=1;i<=n;i++) {
		if((n-b[i]+1)%2==0) cout<<a[b[i]]<<" ";
		else cout<<1-a[b[i]]<<" ";
	}
	return 0;
}
```


---


# 矩阵乘法

## 题目描述

计算两个矩阵的乘法。$n \times m$ 阶的矩阵 $A$ 乘以 $m \times k$ 阶的矩阵 $B$ 得到的矩阵 $C$ 是 $n \times k$ 阶的，且 $C[i][j]=A[i][0] \times B[0][j]+A[i][1] \times B[1][j]+$ …… $+A[i][m-1] \times B[m-1][j](C[i][j]$ 表示 $C$ 矩阵中第 $i$ 行第 $j$ 列元素）。

## 样例 #1

### 输入

```
3 2 3
1 1
1 1
1 1
1 1 1
1 1 1```

### 输出

```
2 2 2
2 2 2
2 2 2```

# 题解

## 作者：·糯· (赞：31)

## 题目分析
此题的新矩阵只需按题目中所说，再加一重循环来把新矩阵的点当作计数器计算，注意矩阵的换行。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110][110],b[110][110],c[110][110],m,n,k;
double s;
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=m;i++)
		for(int j=1;j<=k;j++)
			cin>>b[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
			for(int l=1;l<=m;l++)
				c[i][j]+=a[i][l]*b[l][j];//将新矩阵的每一个点都看作计数器来计算
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++)
			cout<<c[i][j]<<" ";
		cout<<endl;//注意换行
	}
	return 0;
}
```


---

## 作者：Daidly (赞：20)

矩阵乘法中第一个矩阵的列要等于第二个矩阵的行,一个 $n\times m$ 的 $A$ 矩阵，和一个 $m\times k$ 的 $B$ 矩阵相乘，将得到一个 $n\times k$ 的矩阵 $C$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5hzg2f3m.png)

$$c_{i,j}=\sum^m_{p=1}{a_{i,p}b_{p,j}}$$

模拟即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 105
int n,m,k,a[MAXN][MAXN],b[MAXN][MAXN],c[MAXN][MAXN];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=m;++i){
		for(int j=1;j<=k;++j){
			cin>>b[i][j];
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=k;++j){
			for(int p=1;p<=m;++p){
				c[i][j]+=a[i][p]*b[p][j];
			}
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=k;++j){
			cout<<c[i][j]<<" ";
		}cout<<endl;
	}
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：8)

这道题是 [B2024](https://www.luogu.com.cn/problem/B2104) 的升级版，但整体较为简单。

题目要求：C矩阵的每一项分别为

$C[i][j]=A[i][0] \times B[0][j]+A[i][1] \times B[1][j]+$ …… $+A[i][m-1] \times B[m-1][j]$

根据这个要求，我们每一项都这么暴力查询，就可以求出 C 数组。

```cpp
#include <cstdio>

using namespace std;

const int ma=105;

int a[ma][ma],b[ma][ma],c[ma][ma];

int n,m,k;

int main(void)
{
	scanf("%d%d%d",&n,&m,&k);
	
	for(register int i=0;i<n;i++)
	{
	    for(register int j=0;j<m;j++)
	    {
	        scanf("%d",&a[i][j]);
	    }
	}
	
	for(register int i=0;i<m;i++)
	{
	    for(register int j=0;j<k;j++)
	    {
	        scanf("%d",&b[i][j]);
	    }
	}
			
	int sum;
	
	for(register int i=0;i<n;i++)
	{
	    for(register int j=0;j<k;j++)
	    {
		    sum=0;
		    
		    for(register int k=0;k<m;k++)
			{
			    sum+=a[i][k]*b[k][j];
			}
			
		    c[i][j]=sum;
	    }
	}
	
    for(register int i=0;i<n;i++)
    { 
	    for(register int j=0;j<k;j++)
	    {
		    printf("%d ",c[i][j]); 
	    }
	    
	    printf("\n");
    } 
	
	return 0;
}
```


---

## 作者：5k_sync_closer (赞：6)

# 思路
用二维数组输入，保存 $A,B$。

接着，枚举所有 $c[i][j]$，根据公式求值。

可以看出，公式中变化的下标是从 $0$ 到 $m$ 的。

所以可以从 $0$ 到 $m$ 枚举这个下标。

注意每次枚举的边界。
# 代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[101][101], b[101][101], c[101][101], n, m, k;
int main()
{
    cin >> n >> m >> k;
    for(int i = 0;i < n;++i)
        for(int j = 0;j < m;++j)
            cin >> a[i][j]; //输入a(n*m)
    for(int i = 0;i < m;++i)
        for(int j = 0;j < k;++j)
            cin >> b[i][j]; //输入b(m*k)
    for(int i = 0;i < n;++i) //枚举所有c[i][j](n*k)
        for(int j = 0;j < k;++j)
            for(int o = 0;o < m;++o) //枚举变化的下标
                c[i][j] += a[i][o] * b[o][j]; //累加求值
    for(int i = 0;i < n;++i)
    {
        for(int j = 0;j < k;++j)
            cout << c[i][j] << " "; //输出
        cout << endl;
    }
    return 0;
}
```


---

## 作者：crystallinum (赞：5)

## Step 1.Analyse
这道题整体比较简单。  
根据题面所说，我们不难发现：对于每一个 $C_{i,j}$，都有：
$$C_{i,j} = \sum_{t=1}^{m} A_{i,t} \times B_{t,j}$$
题目给出的数据范围是：$1 \le n,m \le 100$。  
由此估计，纯暴力的时间复杂度约在 $O(nmk)$ 左右，代入数据可知远小于 $10^8$。  
因此这道题可以暴力计算得出结果。  
## Step 2.Code
AC 代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int mtxA[105][105],mtxB[105][105],mtxC[105][105];
int n,m,k;
int main()
{
    cin>>n>>m>>k;
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m;j++)
        {
            cin>>mtxA[i][j];
        }
    }
    for (int i=1;i<=m;i++)
    {
        for (int j=1;j<=k;j++)
        {
            cin>>mtxB[i][j];
        }
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=k;j++)
        {
            for (int l=1;l<=m;l++)
            {
                mtxC[i][j]+=mtxA[i][l]*mtxB[l][j];//对于每一个 mtxC[i][j] 进行计算。
            }
            cout<<mtxC[i][j]<<" ";
        }
        cout<<endl;//注意换行
    }
    return 0;
}
```

---

## 作者：Eason_AC (赞：5)

## Content
给定一个 $n\times m$ 的矩阵 $A$ 和一个 $m\times k$ 的矩阵 $B$，求两个矩阵相乘得到的矩阵。

$n\times m$ 的矩阵 $A$ 和一个 $m\times k$ 的矩阵 $B$ 相乘会得到一个 $n\times k$ 的矩阵 $C$，并且有以下关系：

$$C_{i,j}=\sum\limits_{p=1}^mA_{i,p}+B_{p,j}$$

**数据范围：$1\leqslant n,m\leqslant 100$。**
## Solution
根据题意，我们先循环 $i$，再循环 $j$，最后在循环 $p$，按照公式直接求 $A_{i,p}$ 和 $B_{p,j}$ 的和，加入 $C_{i,j}$ 中即可得到 $C$ 矩阵。

多提一嘴：**当且仅当 $A$ 矩阵的列数等于 $B$ 矩阵的行数时，$A\times B$ 才有意义**。
## Code
```cpp
#include <cstdio>
using namespace std;
int n, m, k, a[107][107], b[107][107], c[107][107];

int main() {
    scanf("%d%d%d", &n, &m, &k)
    for(int i = 1; i <= n; ++i) for(int j = 1; j <= m; ++j) scanf("%d", &a[i][j]);
    for(int i = 1; i <= m; ++i) for(int j = 1; j <= k; ++j) scanf("%d", &b[i][j]);
    for(int i = 1; i <= n; ++i) for(int j = 1; j <= m; ++j) for(int l = 1; l <= k; ++l) c[i][j] += a[i][l] * b[l][j];
    for(int i = 1; i <= n; ++i) {for(int j = 1; j <= k; ++j) printf("%d", c[i][j]); puts("");}
    return 0;
}
```

---


# [语言月赛 202308] 小粉兔的元素反应

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/bowegye7.png)

## 题目描述

在小粉兔所处的 Tivat（蒂瓦特）世界，有 $n$ 种元素。其中每种元素都可以蕴含一定的能量，且不同元素之间可以进行反应。

小粉兔现在掌握了这 $n$ 种元素。初始时，他所掌握的每种元素所蕴含的能量依次为 $a _ 1, a _ 2, \cdots, a _ n$。

不同元素之间的反应相关细节如下：

**反应条件**：对于任意两种元素 $i, j$（$i \neq j$），如果 $a _ i \times a _ j$ 是 $154$ 的倍数或 $147$ 的倍数，则二者可以进行反应。**元素不可与自身反应**。  
**反应结果**：包含这两种元素在内，所有的 $n$ 种元素所蕴含的能量均翻倍（即，所有 $a _ i$ 均变为原来的两倍）。  
**反应次数**：任意两种元素之间的反应次数均没有限制（即，同两种元素，在一直符合反应条件的情况下，可以反应多次）。

现在，小粉兔想要通过元素反应，使得自己手头的元素能量总和大于等于 $k$，从而打败 Tivat 世界最强大的怪兽——地文（Devil）。他现在想要知道，通过若干次（$0$ 次亦可）反应后，$a _ 1 + a _ 2 + \cdots + a _ n$ 是否可以大于等于 $k$。

## 说明/提示

### 样例 1 解释

首先，小粉兔可以选择 $143$ 与 $238$ 做乘法，结果为 $143 \times 238 = 34034 = 154 \times 221$。此时所有元素能量翻倍，变为 $286, 476, 348, 398$，而 $286 + 476 + 348 + 398 = 1508 \geq 1395$，因此小粉兔可以通过一次操作达到目的。

### 样例 2 解释

$677 + 293 + 859 + 751 = 2580 \geq 1441$，因此小粉兔不操作便可达到目的。

### 样例 3 解释

小粉兔无法引发任何元素反应，最终四能量相加 $< 1295$，因此小粉兔不可以达到目的。

### 数据规模与约定

设 $N = \sum n$，代表单个测试点内所有测试数据的 $n$ 的总和。设 $K$ 代表单个测试点内所有测试数据的 $k$ 的长度总和。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n, N \leq 10 ^ 6$，$1 \leq k \leq 10 ^ {10 ^ 5}$，$1 \leq a _ i \leq 10 ^ 9$，$1 \leq K \leq 2 \times 10 ^ 6$。


| 测试点编号 | $n$ | $k$ | $a _ i$ |
| :----------: | :----------: | :----------: | :----------: | 
| $1$ | $= 1$ | $\leq 10 ^ 9$ | $\leq 10 ^ 9$ |
| $2 \sim 3$ | $\leq 100$ | $\leq 10 ^ {9}$ | $\leq 10 ^ 5$ |
| $4$ | $\leq 1000$ | $\leq 10 ^ {9}$ | $\leq 13$ |
| $5$ | $\leq 1000$ | $\leq 10 ^ {18}$ | $\leq 10 ^ 9$ |
| $6 \sim 7$ | $\leq 1000$ | $\leq 10 ^ {10 ^ 5}$ | $\leq 10 ^ 9$ |
| $8 \sim 10$ | $\leq 10 ^ 6$ | $\leq 10 ^ {10 ^ 5}$ | $\leq 10 ^ 9$ |


## 样例 #1

### 输入

```
1
4 1395
143 238 174 199```

### 输出

```
Yes```

## 样例 #2

### 输入

```
1
4 1441
677 293 859 751```

### 输出

```
Yes```

## 样例 #3

### 输入

```
1
4 1295
136 875 196 34```

### 输出

```
No```

# 题解

## 作者：Maxmilite (赞：17)

## Source & Knowledge

2023 年 8 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定 $n$ 和 $a _ 1, a _ 2, \cdots, a _ n$。当 $a$ 序列中某两个元素相乘后是 $147$ 或 $154$ 的倍数，所有 $a _ i$ 变为原来的两倍。求能否通过若干次（或 $0$ 次）相乘，使得 $a _ 1 + a _ 2 + \cdots + a _ n \geq k$。
	
## 题目分析

本题考察较复杂的模拟。

不难发现这样几条性质：

1. 单个元素（$n = 1$）一定无法反应。
2. 如果两个元素 $a _ i, a _ j$ 可以反应，那么它们就可以一直反应，使得序列无限翻倍。
3. $a _ i \leq 10 ^ 9$，那么 $a _ 1 + a _ 2 + \cdots + a _ n$ 不会超过 $10 ^ 9 \times 10 ^ 6 = 10 ^ {15}$。那么，当 $k > 10 ^ {15}$ 时，如果元素无法反应，那么一定无法达到目的。 
4. $k$ 的位数 $\geq 17$ 时，$k \geq 10 ^ {16}$，而 $10 ^ {16}$ 可以被 `long long` 容纳下。
5. $154 = 2 \times 7 \times 11$。如果两个元素 $a _ i, a _ j$ 乘积为 $154$ 的倍数，且这两个元素均不是 $154$ 的倍数，那么其中一个元素一定是 $2 \times 7 = 14$ 或 $2 \times 11 = 22$ 或 $7 \times 11 = 77$ 的倍数，而另一个元素需要对应的是 $11$ 或 $7$ 或 $2$ 的倍数。
6. $147 = 3 \times 7 \times 7$。如果两个元素 $a _ i, a _ j$ 乘积为 $147$ 的倍数，且这两个元素均不是 $147$ 的倍数，那么其中一个元素一定是 $3 \times 7 = 21$ 或 $7 \times 7 = 49$ 的倍数，而另一个元素需要对应的是 $7$ 或 $3$ 的倍数。


因此，对于每组数据，我们可以按照以下步骤处理：

### $k$ 的处理

由性质 3 和性质 4，我们使用字符串 `std::string` 或 `char[]` 读入 $k$。读入后，首先判断 $k$ 的长度是否 $\geq 17$。如果是，我们直接将整数类型的 $k$ 设为 $10 ^ {16}$；否则，我们手动模拟/使用库函数，将字符串类型的 $k$ 转换为整数类型。

C++ 的 `std::stoll()` 可以将 `std::string` 转换为 `long long` 类型，这里使用这种方法进行转换。

```cpp
string s;
cin >> s;
if (s.length() < 17) {
    k = stoll(s);
} else {
    k = 1e16;
}
```

### 对 $n = 1$ 的特殊处理

对于 $n = 1$，由于单个元素无法反应（性质 1），因此只需要判断仅有的一个元素 $a _ 1$ 和 $k$ 的大小关系。

```cpp
if (n == 1) {
    if (a[1] >= k) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }
    continue;
}

```

### 直接判断当前元素是否总和 $\geq k$

我们只需读入时将所有元素相加，并与处理后的整数 $k$ 作比较，即可得到一个初步判断。

### 找到可能反应的元素

由性质 5 和性质 6，我们可以遍历一次数组，找到能够整除 $14, 22, 77, 21, 49$ 的元素。但是，对于另一个元素，如果我们再进行同样的遍历，时间复杂度为 $O(n ^ 2)$，不能接受。

所以我们考虑分别记录能够整除 $2, 3, 7, 11$ 的元素的数量。

```cpp
int cnt[15];
int ops[] = { 2, 3, 7, 11 };
memset(cnt, 0, sizeof(cnt));
for (int i = 1; i <= n; ++i) {
    for (int j = 0 ; j < 4; ++j) {
        if (a[i] % ops[j] == 0) {
            ++cnt[ops[j]];
        }
    }
}
```

首先我们可以扫描查找是否有直接为 $147$ 或 $154$ 的倍数的元素，如果有则直接输出 `Yes`，进行下一组数据的运算。

如果没有，接下来，遍历数组查找能够整除 $14, 22, 77, 21, 49$ 的元素，并分别判断有多少能够整除 $11, 7, 2, 7, 3$ 的元素。对于 $14, 22, 77, 49$，只要有一个对应的另一个元素即可；但是对于 $21$，由于 $21$ 本身可以整除 $7$，因此需要有至少两个对应的元素。

```cpp
int flag = 0;
for (int i = 1; i <= n; ++i) {
    if (a[i] % 154 == 0 || a[i] % 147 == 0) { cout << "Yes" << endl; flag = 1; break; }
    if (a[i] % 21 == 0 && cnt[7] >= 2) { cout << "Yes" << endl; flag = 1; break; }
    if (a[i] % 49 == 0 && cnt[3]) { cout << "Yes" << endl; flag = 1; break; }
    if (a[i] % 77 == 0 && cnt[2]) { cout << "Yes" << endl; flag = 1; break; }
    if (a[i] % 14 == 0 && cnt[11]) { cout << "Yes" << endl; flag = 1; break; }
    if (a[i] % 22 == 0 && cnt[7]) { cout << "Yes" << endl; flag = 1; break; }
}
if (!flag)
    cout << "No" << endl;
```

通过以上步骤，我们就可以完成所有判断。

## 视频讲解

视频题解后续将会上传。

---


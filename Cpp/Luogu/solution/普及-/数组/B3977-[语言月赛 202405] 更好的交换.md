# [语言月赛 202405] 更好的交换

## 题目描述

小 S 有一个奇怪的机关拼图。这个拼图可以看作一个 $n$ 行 $n$ 列的方阵 $A$，第 $i$ 行第 $j$ 列的位置上有一个正整数 $A_{i, j}$。

与寻常拼图不同的是，这个机关拼图上的数字不能随意移动，必须按照如下规则**之一**操作：

- 选择拼图上的第 $x$ 行和第 $y$ 行，交换这两**行**；
- 选择拼图上的第 $x$ 列和第 $y$ 列，交换这两**列**。

为了复原这个拼图，小 S 将会操作共 $m$ 次，每次操作格式如下：

- `1 x y`，表示交换第 $x$ 行和第 $y$ 行；
- `0 x y`，表示交换第 $x$ 列和第 $y$ 列；

请你输出复原后的拼图。

## 说明/提示

### 样例 1 解释

第一次操作，交换了第 $2$ 列和第 $3$ 列；第二次操作，没有发生变化。

### 样例 2 解释

第一次操作，交换第 $2$ 行和第 $3$ 行，拼图变为：
$$
\begin{aligned}
11 \ 12 \ 13\\
\textcolor{red}{31 \ 32 \ 33}\\
\textcolor{blue}{21 \ 22 \ 23}
\end{aligned}
$$

第二次操作，交换第 $2$ 列和第 $3$ 列，拼图变为：
$$
\begin{aligned}
11 \ \textcolor{red}{13} \ \textcolor{blue}{12} \\ 
31 \ \textcolor{red}{33} \ \textcolor{blue}{32} \\
21 \ \textcolor{red}{23} \ \textcolor{blue}{22}
\end{aligned}
$$

### 数据范围

对于前 $30 \%$ 的数据，保证每一行数字相同；  
对于前 $60 \%$ 的数据，保证 $1 \leq m \leq 3 \times 10^3$。  
对于 $100 \%$ 的数据，保证 $1 \leq m \leq 10^6, 1 \leq n, A_{i, j} \leq 10^3, 1 \leq x, y \leq n$，$0 \leq op \leq 1$。

## 样例 #1

### 输入

```
3 2
4 5 6
3 2 1
9 8 7
0 2 3
0 2 2
```

### 输出

```
4 6 5 
3 1 2 
9 7 8
```

## 样例 #2

### 输入

```
3 2
11 12 13
21 22 23
31 32 33
1 2 3
0 2 3
```

### 输出

```
11 13 12 
31 33 32 
21 23 22
```

## 样例 #3

### 输入

```
4 4               
12 32 42 82
53 43 34 98
90 32 42 53
37 17 88 10
0 2 4
1 2 4
0 1 4
1 1 3
```

### 输出

```
32 53 42 90 
17 10 88 37 
32 82 42 12 
43 98 34 53
```

# 题解

## 作者：ShiRoZeTsu (赞：12)

## Source & Knowledge

2024 年 5 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定一个 $n \times n$ 的方阵，每次操作交换某两行或某两列，求最终方阵。

## 题目分析

首先有一个非常显然的暴力，就是直接在每次操作时暴力修改，这样单次操作就是 $O(n)$ 的，对于本题的全部数据来说无法通过，只能拿到 $60$ 分：

```cpp
for(int i = 1, op, x, y; i <= m; i++) {
    cin >> op >> x >> y;
    if(op == 1) for(int j = 1; j <= n; j++) swap(a[x][j], a[y][j]);
    else for(int j = 1; j <= n; j++) swap(a[j][x], a[j][y]);
}
```

考虑如何优化。不难发现，行和列之间的修改是**无关**的。我们可以将行和列的操作分开处理。

现在我们假设只有行操作，没有列操作该如何处理。

实际上，我们可以不用真的去交换每一行。考虑用一个数组 $p_i$ 来表示**当前**第 $i$ 行里所存储的是**初始的**哪一行。那么，对于一次交换 $x$ 行和 $y$ 行的操作，我们只需要交换 $p_x$ 和 $p_y$ 即可：

```cpp
if(op == 1) swap(p[x], p[y]);
```

同理，如果只有列操作，没有行操作，该如何处理呢？可以开一个 $q_i$ 数组，表示**当前**第 $i$ 列里存储的是**初始的**哪一列，然后也只需要交换 $q_x$ 和 $q_y$ 即可。

```cpp
if(op == 0) swap(q[x], q[y]);
```

由于行和列的操作互不相干，所以以上两个方法可以同时进行。也就是说，我们只要用数组 `p` 和 `q` 来代替每次的修改就可以了：

```cpp
for(int i = 1, op, x, y; i <= m; i++) {
    cin >> op >> x >> y;
    if(op == 1) swap(p[x], p[y]);
    else swap(q[x], q[y]);
}
```

接下来考虑如何输出答案。在用二重循环枚举行和列时，直接输出 $a[p_i][q_j]$ 即可：

```cpp
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++)
        cout << a[p[i]][q[j]] << ' ';
    cout << '\n';
}
```

## 视频讲解

![](bilibili:BV1nf42127oB?page=8)

---


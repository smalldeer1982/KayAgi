# 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**


## 说明/提示

$1 \le m, n \le 100$


## 样例 #1

### 输入

```
10 3```

### 输出

```
3 6 9 2 7 1 8 5 10 4```

# 题解

## 作者：KesdiaelKen (赞：454)

并没有人打出如此简单的代码吧……

其实，此题就是一个模拟题。按照题意去做，用visit记录下已经出队了的人，然后模拟，一个个的加就行了。

还要注意，一开始，加的数要赋值为0。还有visit数组要开始全部赋值为false（早就知道了？我第一遍就忘了……）

代码如下：

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n,m,s=0;scanf("%d%d",&n,&m);//入读
    bool visit[200]={0};//visit赋初始值
    for(int k=0;k<n;k++){//总共要出队n次
        for(int i=0;i<m;i++){if(++s>n)s=1;if(visit[s])i--;}//类似取模，而因为序列是从1开始的，所以不取模，加判断；若visit过，则i--，使其继续循环
        printf("%d ",s);visit[s]=true;//输出，记录已出队
    }
    return 0;
}
```

---

## 作者：Mickey_snow (赞：330)

由于这题数据范围非常小，因此可以用很多比较奇怪的算法。不过，命题者的初衷是希望我们使用链表进行模拟。

在这里，我使用了一个结构体 `Peo` 存储一个双向链表：


```cpp
struct Peo
{
    int ID;                    //编号
    Peo *next, *front;
};
```
其中 `ID` 代表这个人的编号，输出时使用，另外两个指针分别指向上一个和下一个人，不过我们先要对其初始化。
使用两个变量 `tot`, `outNum` 来分别存储总人数和出局的数，然后让链表之间互相链接，最后首尾相连。

 
```cpp
    for (int i = 1; i < tot - 1; i++) { n[i].front = n + i - 1; n[i].next = n + i + 1; n[i].ID = i + 1; }
    n[0].front = n + tot - 1; n[0].next = n + 1; n[tot - 1].front = n + tot - 2; n[tot - 1].next = n;
    n[0].ID = 1; n[tot - 1].ID = tot;
```
链表初始化完成之后，我们可以使用一个结构体指针 `now` 来表示我们现在模拟到哪一个人了。

```cpp
Peo *now = n;            //指向目前报数的人的指针
```

最后，我们需要用一种方法来删除链表当中的某一项，可以这样考虑，如果当前需要删除的项是 `now`, 那么链表中需要修改的变量只有它前一项和后一项的两个指针，在代码实现上，将 `now->front` 的 `next` 更改为`now->next`，然后 `now->next` 的 `front` 更改为`now->front` 就可以了。我们使用一个函数封装这一过程。

 
```cpp
     void _Cut(Peo *num)
    {
        num = num->front;
        num->next = num->next->next;
        num = num->next;
        num->front = num->front->front;
    }
```
这样，剩下的就是依据题意模拟了，过程虽然看似有些复杂，但是这大致就是题目期望我们去做的全部过程。
 
    
    
    
    

```cpp
#include<iostream>
using namespace std;

struct Peo
{
    int ID;                                    //编号
    Peo *next, *front;

    Peo(){ next = front = nullptr; }
}n[100];

void _Cut(Peo *num)
{
    num = num->front;
    num->next = num->next->next;
    num = num->next;
    num->front = num->front->front;
}

int main()
{
    int tot, outNum, nowNum = 1;
    Peo *now = n;            //指向目前报数的人的指针
    cin >> tot >> outNum;        //数据读入
    
    for (int i = 1; i < tot - 1; i++) { n[i].front = n + i - 1; n[i].next = n + i + 1; n[i].ID = i + 1; }
    n[0].front = n + tot - 1; n[0].next = n + 1; n[tot - 1].front = n + tot - 2; n[tot - 1].next = n;
    n[0].ID = 1; n[tot - 1].ID = tot;
    //初始化链表
    
    while (tot > 0) {
        if (nowNum == outNum) {
            cout << now->ID << " ";        //输出出局的人的编号
            
            _Cut(now);                    //出局
            nowNum = 1;                    //初始化数字
            tot--;                        //总人数-1
            now = now->next;            //下一个人
        }
        else {
            nowNum++;                    //数字+1
            now = now->next;            //下一个人
        }
    }
    
    return 0;
}
```
## 方法2：队列
若是使用链表，这题的代码实现复杂程度无疑大大上升了，其实，我们完全用不着那么麻烦，一个个地报数，可以想象成一个队列，一个人报完数后，判断他所报的数是不是出局的数，如果是，直接弹出，但若不是，将其移动至队尾。

我们使用一个队列 `q` 进行模拟，在读取总人数和出局数字后，把这些人一个个地压入队列尾部。在使用队列之前，需要先加上头文件 `<queue>`.

 
```cpp
     int tot, outNum, nowNum = 1;
        queue<int> q;
        cin >> tot >> outNum;                        //读取数据
        for (int i = 1; i <= tot; i++)q.push(i);    //初始化队列
```
完成这些之后，开始模拟，整个过程非常直观，在这里就不详细解释了。以下是完整代码。
 
    
```cpp
    #include<iostream>
    #include<queue>
    using namespace std;
    
    int main()
    {
        int tot, outNum, nowNum = 1;
        queue<int> q;
        cin >> tot >> outNum;                        //读取数据
        for (int i = 1; i <= tot; i++)q.push(i);    //初始化队列
        while (!q.empty())                    //在队列不为空时继续模拟
        {
            if (nowNum == outNum)
            {
                cout << q.front() << " ";    //打印出局的人的编号
                q.pop();                    //出局
                nowNum = 1;                    //初始化现在的数字
            }
            else
            {
                nowNum++;
                q.push(q.front());            //排至队尾
                q.pop();
            }
        }
        cout << endl;
        return 0;
}
```

-----

14-3-2020 UPD： 替换了正文部分错误或模棱两可的表述。规范了第一段代码中不合适的实现细节。

---

## 作者：PrincessYR✨～ (赞：206)

这是一道很好的队列问题

首先我们需要模拟一个队列，将所有的元素压进队列

在进行循环（直到队列为空为止）
首先你要知道：

队列只可以在head删除，那么这就要求我们只要这个人经过判断并且不会被剔除，那么就必须把他排在队尾；

若这个人正好被剔除，那先输出他，再踢除。

下面废话不多说，直接上代码：
```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
queue<int> a;
int main()
{
	int b,c,d,e=1,f=0;
	cin>>b>>c;
	for(int i=1;i<=b;i++)
	{
		a.push(i);//模拟队列 
	}
	while(!a.empty())
	{
		if(e==c)//如果这个人正好被踢 
		{
			cout<<a.front()<<" ";//先输出 
			a.pop();//再删除 
			e=1;//再从1开始报数 
		}
		else if(e!=c)//如果不被剔除 
		{
			e++;//报的数+1 
			a.push(a.front());//先把head压进队尾 
			a.pop();//再把head删除 
		}
	}
	return 0;//结束程序（完美） 
}
```
//by：鱡舞
//date：2019.8.14

---

## 作者：yangrunze (赞：191)

## 本魔芋来发题解啦！在此先%%%%%%拜大佬
约瑟夫问题是一个**链表**的典型题目。为啥要用到链表呢？因为链表的**优越性**实在太多啦~

------------
### 首先，有一个叫“循环链表”的东西非常适合这道题 
比如样例中**n=3，m=10**的情况，我们可以建立一个这样的**循环链表**：
```
1→2→3→4→5→6→7→8→9→10
↑                  ↓
 ← ← ← ← ← ← ← ← ←
```
**第10个的下一个正好指向第1个**，非常符合题目的设定
### 其次，链表的删除操作非常简便
如果要删掉数组中的一个元素，需要把它之后的所有元素都向前移一个单位，**太麻烦了**有木有？！而链表恰恰相反，**删除数据**的操作很简单，只需要**改变他们建立的联系**就行
######  
什么意思呢？还是用样例解释：**当第3个人出圈之前**，他们的关系是这样的：
```
1→2→3→4→5
```
而**出圈之后**，他们的关系就成了这样：
```
   → →
  ↑    ↓
1→2  3→4→5
```
也就是说，我们**把第2个的下一个直接指向了第4个**，从而**跳过了第3个**


------------
链表好归好，但好多小伙伴肯定会像我一样，一提链表，“**指针恐惧症**”就犯了
对不对？？？
### 没关系，我们不用指针，用数组也能搞个链表出来！

链表的**关键核心**在哪？当然在于**某个元素与其它的元素建立的联系**，通俗易懂来讲，连表可以轻松地操作某个元素的**下一个元素**是谁。
######
那咱们只要把每个元素的下一个元素找出来不就行了？我们可以**定义一个数组，来存每个元素的下一个元素**。数组名就叫......**next**好了
######
因为这个题的数据是1~n**连续**的，所以我们可以用**数组的下标**来代表数据的内容。比如**next[1]=2就是指第1个人的下一个是第2个**，以此类推，next[2]=3,next[3]=4.......第10个（还是用样例）的下一个当然是第1个了。
######
|数据  |1  |2  | 3 |4  | 5 | 6 |7  |8  | 9 |10  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| next |  2  | 3 | 4 |5  | 6 |7  |8  |9  | 10 |1  |
######
代码实现是这样的
```cpp
    int n,m;
    cin>>n>>m;//输入，没啥好说的
    for(int i=0;i<n;i++)//为什么从0开始后边会说
    	next[i]=i+1;//前n-1个的下一个就是第i+1个
    next[n]=1;//最后一个的下一个是第一个，特殊处理
```
这样数组的初始化就完成了


------------
模拟出圈过程也不难。比如**第3个人出圈时，把2的下一个从3改成4**，下次到这里的时候从2就会直接到达4，从而跳过3
#####
|数据  |1  |2  | 3 |4  | 5 | 6 |7  |8  | 9 |10  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| next |  2  | **④**| 4 |5  | 6 |7  |8  |9  | 10 |1  |
######
接下来的任务就是**数m个，输出，删掉**，再
数m个，输出，删掉......一直**重复n次**，**嵌套循环**就能完美解决
######
首先，咱们定义一个变量p，类似于一个指针。一直**重复m次p取下一个的操作**。
然后**输出出圈人的位置**，然后把**出圈人的前一个指向他的下下个**来跳过出圈人就行了
### 那么问题来了，如何利用next数组访问下一个呢？
观察咱们列的表表就会发现，我们**要访问的数组下标（也就是人的位置）正是next[下标]的值**，也就是说
### p=next[p];
------------

事已至此，大体的思路就已经搞定了，接下来就是细节的问题。
######
首先，**最好不要让p到达出圈人的位置**，因为**出圈人的位置是要被跳过的**，p留在这里就会很不方便
######
那咋办呢？？？把p放在**出圈人的前一个位置**就OK了，输出的话就**输出p的下一个**，然后**把next[p]改成next[p]的下一个，也就是next[next[p]]**
######
除此之外，还要注意一个小小的问题：既然是把p放到出圈人的前一个位置，那就要**把p=next[p]执行（m-1）次**。但第一次如果从1开始，执行（m-1）次还是到了出圈人的位置，只要**把p初始化为0，把next[0]设成1**，就万事大吉了，这也是前面代码中next数组的初始化从0开始的原因。
######
说了这么多，放代码！
```cpp
	int p=0;
//建立p变量（类似指针）来遍历数组，初始化成0
	for(int i=1;i<=n;i++){//n个人出圈n次
		for(int j=1;j<m;j++){
//移动（m-1）次，到达出圈人人的前一个位置
			p=next[p];//p到达下一个
		}
//此时p到达出圈人的前一个位置
		cout<<p[next]<<" "//输出出圈人的位置;
		next[p]=next[next[p]];
//把p指向p的下下个，跳过（删掉出圈人）
	}
```
万事俱备，只欠AC，这就是用**数组模拟链表**，你学会了吗？
```cpp
#include<iostream>
using namespace std;
int next[1000005];
int main(){
    int n,m;
    cin>>n>>m;//输入n、m
    for(int i=0;i<n;i++)//初始化
    	next[i]=i+1;
	next[n]=1;
	int p=0;
	for(int i=1;i<=n;i++){//开始模拟出圈过程
		for(int j=1;j<m;j++)
			p=next[p];//p位置右移
		cout<<p[next]<<" ";//输出出圈人的位置
		next[p]=next[next[p]];//删掉出圈人
	}
	return 0;//功德圆满
}
```
## The End


---

## 作者：雪颜 (赞：116)

看到之前一群神犇写链表等本蒟蒻看不懂的方法，于是本蒟蒻就自己写了一个简单的模拟代码。如下：

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
const int ML=105;
int n,m;
int a[ML];
int main(){
    scanf("%d %d",&n,&m);
    int num=n,last=1;
    while(num){//只要还有人就不停
        int cnt=0;
        for(int i=last;cnt!=m;i++){
            if(i>n) i%=n;//保证都是那几个人在循环
            if(a[i]==-1) continue;//当前这位仁兄已经被踢出列
            ++cnt;
            if(cnt==m){//当前报数的正好报到m
                a[i]=-1;//标记踢出
                num--;//人数又少了一个
                last=i+1;//记下下次数的位置
                printf("%d ",i);//输出：这个人现在被踢出
                break;
            }
        }
    }
    return 0;
}

```

---

## 作者：绝顶我为峰 (赞：75)

### 约瑟夫的~~杀人~~题目

我以为很多人会用这种方法~~来杀人~~呀……

翻了所有题解发现居然没有！(ΩДΩ)

那我就来补个~~杀人~~方法吧(｡◕ˇ∀ˇ◕)

先把代码贴上：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int m,n,k,a[1009];
int main()
{
    cin>>m>>n>>k;//输入 PS：我把n，m打反了，大家凑合着看-_-||
    for(int i=0;i<m;i++)
        a[i]=i+1;//建立一个模拟链表
    int p=0;//起始点
    for (;m>0;--m)//开始杀人(´⊙ω⊙`)
    {
        p=(p+n%m-1+m)%m;//找出倒霉的那个人的位置，也是核心公式，其作用稍后解释
        cout<<a[p]<<(m==1?'\n':' ');//手起刀落_(:з」∠)_PS：三目运算符最可爱qwq
        copy(a+p+1,a+m,a+p);//(O_O)?
    }
    return 0;//ヽ(*^ｰ^)人(^ｰ^*)ノ
}
```

注释已经基本写出思路，详细解释两点：

1.p=(p+n%m-1+m)%m;很多人问这是什么，我给大家解释一下，其实所有约瑟夫~~杀人~~问题都可以套这个公式。

p相当于指针，指向下一个要被杀的人；

n%m是由于n可能会比m打，为了减小运算量，对他先取余；

再加上p是由于这一回要从p的位置开始数，所以+p；

减去1是因为p本身也数，我们多数了一个，所以减去1；

只要有减法就可能会出现负数，防止越界要再多数一圈，也就是加m；

最后再对m取余，得出p——下个~~被杀~~出圈的人。

2.copy(a+p+1,a+m,a+p);大家更好奇的也许是这个小东西，是时候让他闪亮登场啦！【鲜花，掌声】

我们先声明一个数组a，copy需要三个参数。例如：copy(a+1,a+i+1,a+i);表示把a+1到a+i+1这区间的数拷贝到首地址是a+i的数组元素中，其原来的数值将被覆盖。

那么copy(a+p+1,a+m,a+p);大家就不难理解了，在这里正好起到了一个把刚被杀死的人从圈里踢出的作用。正好循环里写的是m--，同时圈内的人数也减少了一个，不影响运算。

我要讲的就是这么多，大家懂了吗？(*￣︶￣)

---

## 作者：fengzi8615 (赞：72)

## 线段树
### 没想到线段树还能解决约瑟夫环吧


------------
观察题目,我们可以发现：题目要求我们执行两个操作  
1. **查询某一元素的位置**
2. **删除某个元素**

这不线段树的功能么,**单点查询**和**单点修改**啊  
那我们考虑如何使用线段树来A掉这题  
+ 我们可以 一开始的时候把每个叶子结点设为1,表示这个结点(即位置)有人了。  
+ 后面踢人的时候,把叶子结点更新为0即可
+ 然后考虑维护前缀和,前缀和的作用就在于报数的时候,直接查询左右子树的前缀和即可.

## Code：
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int N=100;

int n,m;

struct Stree
{
	int l,r;
	int dat;
}t[N<<2];
//结构体 

//建树 
void build(int p,int l,int r)
{
	t[p].l=l;t[p].r=r;
	if(l==r)
	{
		t[p].dat=1;
		//初始化为1,表示这里是有人的 
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	t[p].dat=t[p<<1].dat+t[p<<1|1].dat; 
} 

//把 x 踢出去 
void change(int p,int x)
{
	if(t[p].l==t[p].r)
	{
		t[p].dat=0;
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(x<=mid) change(p<<1,x);
	else change(p<<1|1,x);
	t[p].dat=t[p<<1].dat+t[p<<1|1].dat;
}

//查询 x 的位置 
int query(int p,int x)
{
	if(t[p].l==t[p].r)
		return t[p].l;
	//如果左边的剩余位置小于这个编号,那就在右边区域查找左边区域放不下的 
	if(x>t[p<<1].dat) return query(p<<1|1,x-t[p<<1].dat);
	else return query(p<<1,x);
}

int main()
{
	scanf("%d%d",&n,&m); 
	if(n==0) return 0;
	build(1,1,n);
	int pos=1;
	while(n)
	{
		pos=(pos+m-2)%t[1].dat+1;//t[1].dat即剩余总人数 
		//先给 pos-1, 避免出现mod 完变成0的情况,mod完之后在 +1 
		//处理位置 
//		if(pos==0) pos=t[1].dat;
		int qwq=query(1,pos);
		//查寻当前这个人的位置 
		cout<<qwq<<" ";
		//输出 
		change(1,qwq);
		//踢出队伍 
		n--;
	}
	
	return 0;
 }
 //By Yfengzi
```
### [练习题传送门](http://poj.org/problem?id=2886)
### 刷线段树的朋友可以看看
希望管理给过$QaQ$

---

## 作者：陷语 (赞：50)

# 链表解约瑟夫环
这道题我是用链表结构做的，这题难度在于数到n时要把它弹出来，也就是把它删掉，这时候你就要重新连接前后结点，不然的话它就会变成野指针（就是结点间连接不上），具体操作在这里：
```cpp
		temp = p -> next;//用temp储存要删除的结点
		p -> next = temp -> next;//注意！这步就是连接要删除的那个结点的上一个结点和要删除的那个结点的下一个结点，也可以写成 temp = p -> next - >next;
		p = p -> next;//更新p 的结点
		free(temp);//释放空间 
```
还有就是这个链表在读入完数据之后要将它的尾巴和头相连，具体实现如下
```cpp
tail -> next = head -> next;
```
以此来构成循环链表

题解如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>//用free（）要用这个库
using namespace std;
int m, n;
struct Node{
	int data;
	Node *next;
} *head, *p, *tail, *temp;
int main(){
	scanf("%d%d",&m,&n);
	head = new Node;
	head -> next = NULL;
	tail = head;
	for(int i = 1; i <= m; i++){
		p = new Node;
		p -> data = i;
		p -> next = NULL;
		tail -> next = p;
		tail = p;
	}
	p = head -> next;
	tail -> next = head -> next;// 链接尾和头 
	for(int i = 1; i <= m; i++){
		for(int j = 1; j < n - 1; j++){
			p = p -> next;
		}
		printf("%d ",p -> next -> data);
		temp = p -> next;
		p -> next = temp -> next;//连接要删除那个结点上下结点
		p = p -> next;//更新
		free(temp);//释放空间 
	}
	return 0;
}
```


---

## 作者：ysj1173886760 (赞：49)

这道题直接模拟什么的话理论复杂度应该是$O(n^{2})$的吧，如果是比较大的数据范围就会挂掉,所以我们考虑$O(nlogn)$的算法。
最简单的当然就是树状数组啦。。

我们将问题转换一下，假设当前已经删除的人是第k大的，那么接下来要删除的人就是第（k+m-1）大的，这里暂时不考虑环。

那么我们就要维护一个数据结构，每次满足单点修改，全局查kth....

那就是权值树状数组啦。

也就是说下标就是人的编号，1和0代表人在不在

对于环形来说，我们每次对当前剩余人数取模即可。

还有最后的找kth的操作，我的另一篇博客里有具体的解释，有兴趣可以看看，网上也有类似的。

上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxn=3e4+10;
int n,m,maxx;
int bit[maxn];

inline int lowbit(int x)
{
	return x&-x;
}
inline void add(int pos,int x)
{
	for(int i=pos;i<=maxx;i+=lowbit(i))bit[i]+=x;
}
inline int find_kth(int k)
{
	int ans=0,now=0;
	for(int i=15;i>=0;i--)
	{
		ans+=(1<<i);
		if(ans>maxx||bit[ans]+now>=k)ans-=(1<<i);
		else now+=bit[ans];
	}
	return ans+1;
}

int main()
{
	scanf("%d %d",&n,&m);
	maxx=n;		//这里因为n后面会改变，所以先记录一下n的值。 
	for(int i=1;i<=n;i++)bit[i]=lowbit(i);//这里完全等价于add(i,1),因为一开始都是1，所以bit[i]=i-(i-lowbit(i)+1)+1=lowbit(i) 
	int now=1;//从1开始 
	while(n)
	{
		now=(now-1+m-1)%n+1;//这里是小细节，本来的式子应该是(now+m-1)%n的，但是考虑如果只剩下2个元素，而我们当前要找的就是第二个元素呢？直接模就是0了，所以用一个+1 -1 的小操作更改取模运算的值域，这样就可以取到n的值了，而对别的无影响 
		int ans=find_kth(now);//找kth 
		add(ans,-1);//把这个人删除 
		printf("%d ",ans);
		n--;
	}
	return 0;
}
```

---

## 作者：lumineux (赞：43)

## 一路看下去，pascal的题解都垫底了，那我来写一篇吧。

------------
### 【题意分析】
第一次做差点错了，还以为只要不断MODn就可以了，没想到还要杀……咳咳……踢人。回到这道题目，我的做法是模拟（和很多人一样），但不同的是我在中间用的是while跳过已出圈的人，用t记录当前数到几，h记录当前谁在报数，通过不断累加t并将t清0模拟报数情况。

具体见代码：

------------
```pascal
var
  n,m,i,j,h,t:longint;
  a:array[1..100] of boolean;
begin
  readln(n,m);
  j:=n; h:=0;
  while j<>0 do//判断圈中是否还有人
    begin
      inc(h);
      if h=n+1 then
        h:=1;
      while a[h] do//跳过已出圈的人
        begin
          inc(h);
          if h=n+1 then
            h:=1;
        end;
      inc(t);//累加t
      if t=m then
        begin
          write(h,' ');
          a[h]:=true;
          t:=0;//清零
          dec(j);//踢人
        end;
    end;
end.

```

------------

---

## 作者：liao (赞：17)

这是一道模拟题，模拟虽然简单，但是，我们可以用循环链表来实现。  
它更简洁，更高效。  

循环链表是啥？？？  
度娘：循环链表是另一种形式的链式存贮结构。  
额，我想我没听懂。  
来看看这个：  
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548999754483&di=78707225e4e80d7d4199494602794abe&imgtype=0&src=http%3A%2F%2Fimg5.coin163.com%2F90%2F44%2FvQJrYr.gif)  
这就是循环链表。  
除了尾节点以外，其他节点都指向下一个节点。  
尾节点捏？？  
尾节点指向头结点。  
  
~~讲了大半天废话~~，辣么，题目怎么写呢？？  
我们可以建立一个指针数组，为了方便~~（其实是我不会指针）~~，我们可用数组实现。  
先读入n、m，然后初始化链表。  
  
---
```cpp
//初始化
for(i=1; i<n; i++)
	next[i]=i+1;//除了尾节点以外，其他节点都指向下一个节点
next[n]=1;//尾节点指向头结点。
```
---  
  
然后，开始踢人了！  
首先，我们知道，游戏结束的条件是只剩下一个人，对吧。  
我们可以每踢掉一个人后，就把要被踢掉的人之前的人指向要被踢掉的人的后面。  
可能有点难懂，来看看样例：（n=10，m=3）
![](https://i.loli.net/2019/02/01/5c54407ff3773.png)
首先踢掉3号，对吧？  
于是成了这样。  
![](https://cdn.luogu.com.cn/upload/pic/50703.png)
继续踢6号。  
![](https://cdn.luogu.com.cn/upload/pic/50705.png)
踢完9号后，变成了这样。
![](https://cdn.luogu.com.cn/upload/pic/50704.png)
要注意了，这一次要踢的，是2号。如图（从9号开始踢人）
![](https://cdn.luogu.com.cn/upload/pic/50707.png)
然后踢到7号
![](https://cdn.luogu.com.cn/upload/pic/50708.png)
以此类推。  
结束条件便是当某一个数指向他自己时（只剩下他自己了）。

---
```cpp
//核心代码
while(p!=next[p]) {//边界
	for(i=1; i<=m-2; i++)
		p=next[p];//往后跳m-2步，这样的话，下一个人就要被踢
	printf("%d ",next[p]);//输出
	next[p]=next[next[p]];//踢人了
	p=next[p];//继续
}
printf("%d",p);//别忘了我哦
```
---
我想大家应该都明白了吧！  
噢，对了，还有一个坑点：  

---
```cpp
//特判一下
if(!n&&!m)return 0;
```
---
完整代码：

---
```cpp
#include<stdio.h>
int n,m,next[101],i,p;
int main() {
	scanf("%d%d",&n,&m);
	if(!n&&!m)return 0;
	for(i=1; i<n; i++)next[i]=i+1;
	next[n]=1,p=1;
	while(p!=next[p]) {
		for(i=1; i<=m-2; i++)
			p=next[p];
		printf("%d ",next[p]);
		next[p]=next[next[p]];
		p=next[p];
	}
	printf("%d",p);
	return 0;
}
```
---

不喜勿喷哦

---

## 作者：sjl40 (赞：17)

/\*不用看下面的了C党，我的是最简单的，没有之一。我的是while枚举，因为这题数据小到爆，可以用数组进行一个一个的判断。\*/

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,s,k,g,a[105],i,w;
int main()
{
 cin>>n>>k;
 g=n;//统计圈里有多少人的变量，一开始有n人。
 while(g!=0)//如果全部出圈就退出
 {
  w++;//不断变化位置
  if(w>n)w-=n;//如果超过n那就变回第1个。
   if(a[w]==0)s++;//这条if和上面的if不能变位置，变了位置那么就会判断到圈外的。
 if(s==k){cout<<w<<' ';a[w]=1;g--;s=0;}//统计够k没有，够了就输出现在的位置，并把数的数给清0.
 }
}
```

---

## 作者：瞎子谦的爱人 (赞：12)

我一个蒟蒻看着大佬们的题解，看的我胆战心惊：
### 一道模拟普及-题，至于吗？
以下是本蒟蒻的思考：
我们可以用一维数组来直接存储号码，用变量i来指向剩余的位置（即要跳过已经出列的位置），用变量j来累加间隔位置。
### 因此，j要对m进行取模运算，即j=j%m+1
附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101],i,j,r=1;
int main()
{
	scanf("%d%d",&n,&m);
	for(i=0;i<=n;i++) a[i]=i;
	for(i=1,j=1;r<=n-1;i=i%n+1,j=j%m+1){
		while(a[i]==-1) i=i%n+1;
		if(j%m==0){
			printf("%d ",a[i]);
			a[i]=-1,j=0,r+=1;
		}
	}
	for(i=0;i<n;i++) if(a[i+1]!=-1) printf("%d\n",a[i+1]);
	return 0;
} 
```
谢谢大家支持~

---

## 作者：没有输入 (赞：11)

# 数据结构 · 队列

约瑟夫问题（猴子选大王）是一道经典的**队列模板题**。本题考查对队列这一数据结构的熟悉，一般只要对队列有一定的了解，就能完成该题。

## 解题思路

定义一个队列来模拟圈（**直接上STL**）
```cpp
queue <int> q;
```
先按编号1~n依次入队
```cpp
for(int i=1; i<=n; i++) q.push(i);
```
每次圈内前m-1个人都依次先出队然后入队
```cpp
for(int i=1; i<m; i++) q.push(q.front()),q.pop();
```
第m人直接输出其编号并出队（**不用再入队**）
```cpp
printf("%d ",q.front());
q.pop();
```
即可完成题目。

## 拓展

### STL库

顺便来说说STL。STL模板库是个好东西（~~偷懒必备利器~~），可以
省去手写实现各种操作的麻烦，而且有时还比手写更加优化，举个例子，队列很容易浪费空间，但STL库中的队列自带循环，不会浪费空间，不用再去手写循环队列。但STL有一个**缺点，致命的缺点**：**复杂度极高**。因为经过了封装，还加了各种鬼畜的操作，导致其复杂度比手写大大增加，所以正式比赛的时候不建议用。

### 队列

队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。

队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。

## 程序

### 标程
```cpp
#include<bits/stdc++.h>
using namespace std;
queue <int> q;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) q.push(i);
	while(!q.empty())
	{
		for(int i=1; i<m; i++) q.push(q.front()),q.pop();
		printf("%d ",q.front());
		q.pop();
	}
	return 0;
}
```

### 压行（逛了一圈题解，没人比我短）
```cpp
#include<bits/stdc++.h>
std::queue <int> q;
int n,m,i;
int main() {
	for(scanf("%d%d",&n,&m),i=1; i<=n; i++) q.push(i);
	while(!q.empty()) {
		for(i=1; i<m; i++) q.push(q.front()),q.pop();
		printf("%d ",q.front()),q.pop(); } }
```


---

## 作者：兮水XiShui丶 (赞：10)

看见其他人的STL和我的都不太一样，就发个题解了

```cpp
#include<iostream>
#include<queue>
using namespace std;
int pe[105];
queue <int> ys;//STL库的队列，不用说了吧，，，，
int main()
{
    int n,m,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        pe[i]=i;  //给第几个元素rank值;
        ys.push(pe[i]);//元素进队列
    }
    while(!ys.empty())//队列不空
    {
        for(int i=1;i<m;i++)
        {
            k=ys.front();//k为队头，因为STL库的循环队列要出队，先把队头存起来
            ys.pop();
                ys.push(k);     //再将k加入队尾，就是循环队列      
        }
        cout<<ys.front()<<" ";//输出报完数后的队头，就是需要出列的人
        ys.pop();//这个人出队
    }
    return 0;
}
```

---

## 作者：exit0 (赞：8)

# 直接模拟就可以
 ~~这个题我竟然想了好久~~~
 
发现题解中竟然没有用for循环模拟的，这真是坑像我这样不会while循环的人，那我来发一篇纯模拟&&纯for循环的题解：
本蒟蒻思路如下：

用两个for循环来解决问题：

第一个循环：给所有数赋值

第二个循环：纯模拟

代码如下：
```cpp
#include <iostream>
using namespace std;
int n,m,a[10010],cnt,e;
int main()
{
    cin>>n>>m;//输入
	for(int i=1;i<=n;i++)a[i]=i;//第一个循环：赋值
	for(int i=1;;i++)
	{
		if(a[i]!=-1)cnt++;//如果遇到被踢出的人就不加计数器
		if(cnt==m&&a[i]!=-1)//如果计数器刚刚到m并且那个人没有被踢出
		{
		cout<<a[i]<<" ";//踢出||输出
		a[i]=-1;//模拟被踢出
		e++;//当前被提出的人+1
		cnt=0;//清空计数器
		}
		if(i==n)i=0;//如果到了循环末尾，就重新开始
		if(e==n)break;//如果被踢出的人到达了n，终止循环
	}
    return 0;//我爱return 0;
}
```
AC~~~~

---

## 作者：沉MO_Official (赞：7)

这道题虽说普及-，但还算比较简单的。解法有很多，~~希望不要重复~~。

我用的是直接模拟游戏过程的算法，下面直接贴代码。
```
#include <iostream>//cin cout不说了
#include <cstring>//memset要用cstring库。
bool a[110];//用来记录该player是否在圈内，ture为在圈内，false为出圈。
int m,n,x=0,y=0,z=0;//x为报到第x个数，y为到第y人，z为已经z人出圈。 
using namespace std;
int main()
{
	memset(a,true,sizeof(a));//把a初始化为true，以前学pas的不要把ture和sizeof位置搞错
	cin>>n>>m;//读入
	while(z!=n)//当还有人未出圈时
	{
		y++;//人+1
		if (y==n+1) y=1;//当人数到n+1时，因为是环型，所以重新回到1.
		if (a[y]) x++;//如果这个人还在圈里就报数。
		if (x==m)//当之个人很倒霉，报到那个数字时
		{
			x=0;//把报到的数字归0。
			cout<<y<<' ';//把这个人的序号输出
			a[y]=false;//这个人出圈了
			z++;//多一个出圈的人
		}
	}
	return 0;
}
```
简不简单？？？

---

## 作者：一E孤行 (赞：6)

# ~~蒟蒻的第一次题解~~
## 先来看一下题目背景：  我只想说：~~大快人心！~~
切入正题，分析一下题目：
n个人围成一个圈，然后报数，数到m的就出队，挺简单的模拟。

NO.1 模拟
我们可以声明一个变量表示剩下的人数，只要人数不为零，就代表队里还有人。声明两个个变量，一个表示数到谁了（这个思路的出队只是表示这个人不在队里，所以数到了这个人，要是他不在队里，实际上他并没有报数，所以报数的数量不加一），还有一个表示这个人报数报道了几。建一个数组，存这个人是否仍然在队里，如果在，就判断是不是到达了该出队的人，是，就出队，输出，然后报数重新计数为1；不然就数到的数+1（数到头就变成1）。

整体思路很简单

（一条华丽的分割线，附上你们最爱的AC代码）
------------
——————————————————————————————
```cpp
#include<cstdio>
using namespace std;
int t;
int shu;
int a[102]; //数组表示他有没有在队里 
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	shu=n; //剩下的人数 
	int b=0; //报数报道第几位了 
	while(shu>0)  //只有有人仍然留下 
	{
		if(!a[b])  //数到的这个人在队里 0表示在队里，1表示已经出队，这个地方并没有报数 
		{
		if(t==m)  //t表示报数报到几 
		{
			a[b]=1; //已经出队 
			shu--;  //在队里的人数减一 
			printf("%d ",b); //输出 
			t=1; //该重新报数了 
			continue;
		}
		else
		{
			if(b==n)  //数到了头 
			b=1; 
			else
			b++;
			t++;
		}
		}
		else
		{
			if(b==n) //另一种情况(这个人不在队里，跳过上面）数到头 
			b=1;
			else
			b++;
		}
	}
	printf("\n");
	return 0;
}
```

NO.2 队列
我们~~思考一下~~ 看一下标签，是队列。这种模拟很麻烦，判断这判断那的。我们可以思考：这个队列是循环的，~~废话~~ 也就是说一个人报完数后要转一圈才能到他。这就代表他到了队尾。所以，我们的队列发挥了作用：如果判断他不是该出队的人，就把他放到队尾去。只要队列不空，也就是说还剩下人。 代码也不难写——~~stl真好用~~

（一条华丽的分割线，附上你们最爱的AC代码）
------------
——————————————————————————————
```cpp
#include<cstdio>
#include<queue> //队列头文件 
using namespace std;
queue<int> q; //定义队列 
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	q.push(i); //按顺序入队 
	int a=0;
	while(!q.empty()) //队列不空，有人 
	{
		a++; //报的数+1
		if(a==m) //与上一篇不同的是，这里不在队列里，就真的不在了，所以不需要想判断他该不该报数，只要他在队列里，就一定该报数。 
		{
			printf("%d ",q.front()); //输出 
			q.pop(); //出队 
			a=0; //报数从新计数 
		}
		else
		{
			q.push(q.front()); //把队尾添加队头元素 
			q.pop(); //队头出队，这两句相当于把队头的元素插到了队尾 
		}
	}
	return 0;
}
```

NO.3 队列（还是队列，微微有不同）

其实是一样的，只不过改成了手写。。。然而本蒟蒻~~不会循环队列~~所以只好写普通队列了。。。 这样浪费了空间但是提高了时间（开O2氧气的话好像也没有提高，但是NOIP~~我是不是该叫CSP，现在谁也不知道CCF想干嘛~~才不给你开O2氧气呢）各位会写循环队列的大佬就自己写循环吧

你们最爱的AC

（一条华丽的分割线）
------------
——————————————————————————————
```cpp
#include<cstdio>
using namespace std;
int f[10001]; //队列，其他都一样 
int front=1,tail=0; //队头，队尾(队尾是0考虑到由于读入先tail+1所以要是开1则1号位置没有元素 
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	tail++,f[tail]=i;
	int a=0;
	while(front<=tail)
	{
		a++;
		if(a==m)
		{
			printf("%d ",f[front]);
			front++; //出队 
			a=0;
		}
		else
		{
			tail++; 
			f[tail]=f[front]; 
			front++; //头到尾 
		}
	}
	return 0;
}
```

本蒟蒻第一次发题解，求过鸭~蟹蟹啦

---

## 作者：Huangc (赞：6)

先建立一个循环的数组，模拟一个环形（f[1]=2,f[2]=3...f[n-1]=n,f[n]=1）接着循环n次，每次再循环m次，其中使用一个指针j，每次循环后，j=a[j]，这样下来，再进行输出，接着用a[j]=a[a[j]]直接把这个人忽略掉。

```cpp
int n,m,a[10001],j;
int main()
{
    cin >> n >> m;
    for(int i=1;i<n;i++)   
      a[i]=i+1;
    a[n]=1;
    j=n;               //赋值
    for(int i=1;i<=n;i++)
    {
      for(int o=1;o<m;o++)
        j=a[j];        //利用环形数组
      cout << a[j] << " ";
      a[j]=a[a[j]];    //忽略此人
    }
    return 0;
}
```

---

## 作者：45dino (赞：6)

# 大家好，蒟蒻我又来了
## 自从上次题解不通过后(见博客)，本人一直很难受
### 终于有机会~~装逼~~证明自己了！！！
很久以前写的代码了，改了一下，见证了从0分到80分到100分的过程（下了两次数据）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	std::ios::sync_with_stdio(0);//快速输入输出，防TLE
	std::cin.tie(0);
	int a[100],m,n;
	cin>>m>>n;
	if(!m&&!n)//第3个测试点太坑
		return 0;
	int x=m;
	int y=n;
	for(int i=1;i<=m;i++)
		a[i]=i;
	for(int l=1;l<x;l++)
	{
		y%=m;
		if(y==0)//这一步只能看悟性了
			y+=m;
		cout<<a[y]<<" ";//'\0'不能过
		for(int i=y;i<m;i++)
			a[i]=a[i+1];
		y+=n-1;
		m-=1;		
	}
	cout<<a[1];
	return 0;	
}
```
跪求通过，谢谢！


---

## 作者：Elzat (赞：5)

看题解里没有人用循环队列（~~也可能是我没找到~~）就写了个循环队列的题解~~

------------

那么首先，解释一下**我口中的**循环队列是个什么吧：

```
对于一个队列a，a[i].next表示i的下一个数的下标
那么可以知道初始化的队列a是这样的：

a.posi  | 1 2 3 ... n-1 n

a.next  | 2 3 4 ...  n  1
```

这样就用数组模拟了一个环~~

------------


然后看这道题，要解决两个问题：

- 如何实现报数
- 如何实现出队



------------


如果用$next[i]$来表示第$i$个人的下一个人是谁的话：

对于第一个问题就很简单了：创建一个变量$t$，当$t \lt m$时，$t++$,每次使$i = next[i]$就行了~~



------------


再来看第二个问题：**当使一个人出队时，那么 前一个人的下一个人 应变成 当前这个人的下一个人 这样下次回来的时候当前这个人就会被跳过了**


如果是用$i$表示当前这个人的话，会出现这种情况：

	前一个人	当前的人	下一个人
     ???		   i		 next[i]

~~前一个人的下标是多少啊喂~~，这样还要维护一个$pre$数组来存储前一个人，但是太麻烦了，舍弃~~


------------


那么，重要的来了，用$next[i]$来表示当前的人的话：

	前一个人	当前的人	下一个人
       i		next[i]	     next[next[i]]

这样的话这三个人都能表示出来了！！

那么如果$next[i]$出队了，只需要将$next[i]=next[next[i]]$就行了~~

以下是代码~~

```cpp
#include<cstdio>
int next[101];//存储当前这个人的下一个人的数组 
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	
	for(int i = 1;i <= n;i ++) next[i] = i + 1;//预处理next数组 
	next[n] = 1;//注意第n个人的下一个是第1个人 
	
	int i = n;//虽然说next[i]是存储下一个人
        //但实际上要用next[i]来表示当前这一个人
	//所以i=n,这样next[i]就是第1个人了 
	
	while(n)//直到所有人出队 
	{
		int t = 1;//这个变量存储当前报了几个数
                //初始化1是因为当前这个人也要报1个数
		//那么接下来的人就要报m-1个数 
		while(t < m)
		{
			t ++;
			i = next[i]; //轮到下一个人报数 
		}
		
		printf("%d ",next[i]);//输出出队的人（为什么是next[i]前面已解释） 
		next[i] = next[next[i]];//十分重要！！！！表示这个人出队了！！！ 
		
		n --;//总人数减一 
	}
	return 0;
}
```


---

## 作者：GavinZheng (赞：5)

************************************************

# 这是这道题最简单的解法，没有之一

这道题很多人用数组来模拟，但是极其麻烦。

所以这里我来演示一下队列的做法

************************************************

```cpp
#include<iostream>
#include<queue>    //队列头文件调用
using namespace std;
int main()
{
    queue<int>map;  //用map模拟这个圈；
    int n,m;
    cin>>n>>m;
    if(n==0)
    {                          //如果人数为零，就直接结束程序。十分重要！！！这就是我当初拿80分的原因。。。
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        map.push(i);     //让每个人依次进入队列，编号为一的在前，编号为n的在最后
    }
    int a;                         //用a来作为一个临时储存的变量；
    while(map.size()>1)   //一直执行到只剩最后一人
    {                             
        for(int i=1;i<=m-1;i++)     //循环m-1次
        {                                       
            a=map.front();       //让在队首的人出队
            map.pop();
            map.push(a);        //再让他重新进入
        }                                   //这时在队首的就是第M个人，找到了即将出圈的人
        cout<<map.front()<<' ';   //输出这个人的编号
        map.pop();    //出队，表示这个人出圈
    }                //重新循环开始报数
    cout<<map.front();         //当队列只有最后一个元素时，输出最后一个人的编号，程序结束
    return 0;
}
```

---

## 作者：十四LO (赞：4)

//一个简单的模拟题，但是，约瑟夫是一个无聊的人！！！

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
int x[10001]={0};//初始设置每个人都是活着的
int main(){
  int i=0,j=0,k,m,n,sum=0;
  scanf("%d%d",&n,&m);
  while(sum<n){
    i++;  
    if(i>n)
      i=1;//再一次循环
    if(x[i]==0)//活着的进行，死的忽略
      j++;
    if(j==m){
      printf("%d ",i);//输出
      sum++;//死亡人数
      x[i]++;//记录死亡
      j=0;//j清零
    }
  }
  printf("\n");
  return 0;
}
```

---

## 作者：Nekroz (赞：4)

看dalao们都用了一个vis数组，我就来写一个数组模拟链表的题解吧。
首先初始化next数组，让0~n-1的next都指向后面一个元素，n的next指针指向1（相当于构成一个环，0的地方跳进去）。
然后position = 0，每次报数就是position = next[position],当报道m-1的时候停下（这个很重要），将next[position]输出（position是报了m-1次的结果，next[position]是报了m次的结果），然后令next[position] = next[next[position]]，这个对初学者有点难理解，画个图就可以了，相当于跳过了一个数。
```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>

int next[1000];

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++) next[i] = i + 1;
	next[n] = 1;
	int position = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < m; j++)
			position = next[position];
		printf("%d ", next[position]);
		next[position] = next[next[position]];
	}
	return 0;
}
```

---

## 作者：修罗海神王 (赞：3)

这道题我们在编程班刚刚学过，
不过用的方法是：
# 指针！！！
不要小看了它，

我在学这个问题时认为可以不用指针，

但是写的代码却是：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main()
{
	cin>>n>>m;
	k=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) 
		{
			k++;
			if(k>n) k=1;//这一步写出来了
		}
		cout<<k<<" ";
		if(k==n) …… //但这一步想了半天没想出来
	}
	return 0;
}
```
于是我只好愣在那边，等待这老师讲解如何“杀人”。

结果，其实代码用指针特别方便：

第1个问题：将人想象成链子，从中间取出一颗，设坐标为5.

第2个问题：断开的链子不能用，必须将两边接起来，于是，4的右边变成了6,6的左边变成了4，这一步就是这样：

### a[a[k].right].left=a[k].left;

### a[a[k].left].right=a[k].right;
现在你们懂了吧？？
代码先上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
struct node
{
	int left,right;
}a[110];
int main()
{
	cin>>n>>m;
	k=0;
	for(int i=1;i<=n;i++) a[i].left=i-1,a[i].right=i+1;
	a[1].left=n;a[n].right=1;a[0].right=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) k=a[k].right;
		cout<<k<<" ";
		a[a[k].right].left=a[k].left;
		a[a[k].left].right=a[k].right;
	}
	return 0;
}
```
滋滋洛谷


---

## 作者：SbasdianJulian (赞：3)

**队列入门题**

先介绍一下队列与队列的基本用法

![](http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif)

思路

**1.建立一个队列**

**2.先让这些人排队（就是输入）**

**3.不妨把出列看成拉出来人道毁灭，没被毁灭的重新回到队尾，循环往复**

**4.所以我们可以得到一个循环条件，队列不空 （ysf.empty()!=true）**

**5.没被毁灭的孩子用top记录，pop弹出第一个元素，再用push压入top**

**6.被毁灭的就输出，然后把他删掉**

**7.循环下去，直到世界核平为止**

#### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;

queue<int>ysf;
int num,die,top;

int main()
{
    cin>>num>>die;
    for(int i=1;i<=num;i++)
        ysf.push(i);
    
    for(int i=1;ysf.empty()!=true;i++)
    {
          if(i%die!=0)
        {
         top=ysf.front();
         ysf.pop();
         ysf.push(top);
         top=0;
        }
         if(i%die==0)
        {
         cout<<ysf.front()<<" ";
         ysf.pop();
        }
    }
    return 0;
}
```

图片来源

**版权声明：本文为博主原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/MoreWindows/article/details/6950917**




---

## 作者：strike (赞：3)

##基本数组解法

题解区各种高谈阔论解法，此处一条基本数组解法照顾低基础同学；


（这题本来很简单有木有？？！）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[1000]={0},x,n,m;//初始放0，状态为未出圈；x代表下标； 
int main()
{    int i,tt=0;       //tt计数器，记录报数次数； 
    cin>>n>>m;
    
    for(i=1;i<=n;i++)
    {    while (tt<m)     //报数开始，只要报数不等于m就不停； 
        {    if(x<n)x+=1; //下标+1循环找人； 
                else x=1;  //跑到头了就把下标充1，重来； 
            if (a[x]==0) //只要该同学是0报数就继续； 
            tt++;                 //计数器+1； 
        }                           
        cout<<x<<' ';a[x]=1;tt=0;  //一旦tt=m，该人出圈，状态为1 已出圈，计数器清零，继续循环； 
    }
                      //到这儿一切都结束了。。。 
                      
return 0;}
```

---

## 作者：陈驭儒 (赞：3)

# 水题一枚！
本蒟蒻第一次发题解，请各位有更好解法的神犇们勿喷！  
  
此题可以用队列来解。  
  
废话少说，先上代码，具体看注释！
```cpp
#include<iostream>//好的代码，从引入iostream开始！
#include<queue>//队列头文件
using namespace std;
int n, m;
queue<int> q;//新建队列
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
    	q.push(i);//把1~n压到队列里面
    }
    for(int i = 1; i <= n; i++){//一共加上最后一个的人要死n个
        for(int j = 1; j <= m - 1; j++){//每m-1个人都先从后面进再从前面出
            q.push(q.front());//进
            q.pop();//出
        }
        cout << q.front() << " ";//第m个人输出
        q.pop();//第m个人死亡
    }
    return 0;//完美结束！
}
```
相信大家都知道，这也是数学中的约瑟夫抽杀！  
  
祝大家AC愉快！

---

## 作者：sycqwq (赞：2)

# 思路部分
比较简单的模拟，最主要的是一个圈的思想，用一个数组来储存是否出局，没出局的话就计数器++，每当计数器到m，就将此人出圈。

# 样例部分
```
样例输入：
10 3
样例输出：
3 6 9 2 7 1 8 5 10 4
分析：一共10个人，首先报到3号，3号出局，接下来报到6号，6号出局，接下来报到9号，9号出局，接下来从10开始报，报到2号，2号出局。由于3号已经出局，从4号开始报，报到7号，7号出局...
大概就是这样，相信大家已经明白是怎么回事了。
```
# 代码部分

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int m,n,t=0;//t为已经出局的人数
    int a[105]={0};//a数组为每个人是否出局，默认为都没出局
    cin>>m>>n;
    int j=0,i=0;//i代表是第几个人，j是计数器
    if(n==0&&m==0)//特判
		return 0; 
    while(1){
        i++;
        if(i==m+1)//如果i比人数多，将i定为一，即从一继续报数
            i=1;
        if (a[i]==0){//如果还未出局
            j++;//计数器++
            if (j==n){ //如果计数器到了n
                a[i]=1;//第i个人出局
                cout<<i<<' ';//输出
                t++; //又多了一个出局人数
                j=0;  //计数器清0
                if(t==m)//如果全部出局，结束程序
                    return 0;
            }
        }
    }
}
```

---

## 作者：love好o (赞：2)

# 牛牛 链表

## 初始化

L(左箱箱编号） R（右箱箱编号） Z（保存数值） bh（数组编号）
| 10 | 2 | 1 | 1 |
| -----------: | -----------: | -----------: | -----------: |
| 1 | 3 | 2 | 2 |
| 2 | 4 | 3 | 3 |
| 3 | 5 | 4 | 4 |
| 4 | 6 | 5 | 5 |
| 5 | 7 | 6 | 6 |
| 6 | 8 | 7 | 7 |
| 7 | 9 | 8 | 8 |
| 8 | 10 | 9 | 9 |
| 9 | 1 | 10 | 10|
代码：

```
for(int i=1;i<=n;i++){
	if(i==1)sz[i].l=n,sz[i].r=i+1,sz[i].z=1;
	else if(i==n)sz[i].l=i-1,sz[i].r=1,sz[i].z=n;
	else sz[i].l=i-1,sz[i].r=i+1,sz[i].z=i;
}
```
## 删去
从链表中删去2 4 3 3

| 10| 2 | 1 | 1 |
| -----------: | -----------: | -----------: | -----------: |
| 1 | **3-->4** | 2 | 2 |
| ~~2~~ | ~~4~~ | ~~3~~ | 3 |
| **3-->2** | 5 | 4 | 4 |
| 4 | 6 | 5 | 5 |
| 5 | 7 | 6 | 6 |
| 6 | 8 | 7 | 7 |
| 7 | 9 | 8 | 8 |
| 8 | 10 | 9 | 9 |
| 9 | 1 | 10 | 10|
数值“消失了”，但箱箱仍在。
| 10 | 2 | 1 | 1 |
| -----------: | -----------: | -----------: | -----------: |
| 1 | 4 | 2 | 2 |
|  |  |  | 3|
| 2 | 5 | 4 | 4 |
| 4 | 6 | 5 | 5 |
| 5 | 7 | 6 | 6 |
| 6 | 8 | 7 | 7 |
| 7 | 9 | 8 | 8 |
| 8 | 10 | 9 | 9 |
| 9 | 1 | 10 | 10|

代码
```
//(编号)now=3,sz[now].l=2,sz[now].r=4
sz[sz[now].l].r=sz[now].r;
sz[sz[now].r].l=sz[now].l;
```

## 插入

新建箱箱
| 0| 0| 7.5| 11 |
| -----------: | -----------: | -----------: | -----------: |
将其插入数值7和8之间

| ... | ... | ... | ... |
| -----------: | -----------: | -----------: | -----------: |
| 5 | 7 | 6 | 6 |
| 6 | 8-->11 | 7 | 7 |
| 7-->11 | 9 | 8 | 8 |
| 8 | 10 | 9 | 9 |
| 9 | 1 | 10 | 10|
| 0-->7| 0-->8| 7.5| 11 |

  | ... | ... | ... | ... |
  | -----------: | -----------: | -----------: | -----------: |
  | 5 | 7 | 6 | 6 |
  | 6 | 11 | 7 | 7 |
  | 11 | 9 | 8 | 8 |
  | 8 | 10 | 9 | 9 |
  | 9 | 1 | 10 | 10|
  | 7| 8| 7.5| 11 |
代码
```
//now=7,back=10;
sz[++back].l=now,sz[back].r=sz[now].r;
sz[sz[now].r].l=back,sz[now].r=back;
```
## 题目描述
**n个人(n<=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号.**

```
#include <iostream>
#include <algorithm>
using namespace std;
int n,m;
struct dllss{
	int l,r;
	int z;
}sz[110];
int rs=0;
int main(int argc, char** argv) {
	cin>>n>>m;
	rs=n;
        //初始化
	for(int i=1;i<=n;i++){
		if(i==1)sz[i].l=n,sz[i].r=i+1,sz[i].z=1;
		else if(i==n)sz[i].l=i-1,sz[i].r=1,sz[i].z=n;
		else sz[i].l=i-1,sz[i].r=i+1,sz[i].z=i;
	}
	for(int i=1,k,now=1,next;i<=n;i++){
                //从当前位置向后数
		k=m-1;
		if(k>rs)k%=rs;
		while(k)now=sz[now].r,k--;
		cout<<sz[now].z<<" ";
        	//删去now
		sz[sz[now].l].r=sz[now].r;
		sz[sz[now].r].l=sz[now].l;
        	//下一个
		now=sz[now].r;
	}
	return 0;
}
```



---

## 作者：Dreamstar (赞：2)

好多人都在大模拟O(NM)233...，我来个O(N^2)的算法好了，以防m过大。

我的思想对于有n个人，数到m（这是本轮情况）和有n+1个人，数到m（这是上轮情况）两种情况，我们从本轮第一个报数的同学开始排列，如果此时某人在本轮的位置为k，那么它在上轮的位置应当是(k + m)%(n + 1)，当然如果%得0，我们将其设置为n + 1即可

由于每轮的淘汰位置总是m，所以我们直接将初值设为m，向上循环即可。

注意：由于m可能超过某一轮的总人数，我们可以仿照上文%一下即可。

```cpp
#include<bits/stdc++.h>
#define rg register
using namespace std;
//注意：本题解所说的位置始终是每轮从第一个报数的人开始重排的位置，而非编号，由于第一轮的位置就是编号，得解 
int main(){
	rg int n,m;
	cin >> n >> m;
	for (rg int i = n;i>=1;--i){
		rg int x = m;//这是我们设置的初值 
		for (rg int j = i;j<n;++j){
				if (!(x % j)) x = j;
				else x = x % j;//这两行是我们防止x越界的操作 
				if (!((x + m)%(j + 1))) x = j + 1; //防止越界 
				else x = (x + m)%(j + 1);//这两行是向上“递归”的操作 ，j+1为上轮人数 
		}
		cout<<x<<' ';
	}
	return 0;	
}
```

---

## 作者：gb530 (赞：2)

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,m,frt[105],nxt[105];//存每个元素的前一个和后一个
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){//构建循环链表
		if(i==1) frt[i]=n;//第一个的前一个是最后一个
		else frt[i]=i-1;
		if(i==n) nxt[i]=1;//最后一个的前一个是第一个
		else nxt[i]=i+1;
	}
	int pos=n;//记录当前位置
	for(int i=1;i<=n;i++){
		for(int i=1;i<=m;i++)
			pos=nxt[pos];//找出m个后的pos
		cout<<pos<<" ";//输出
		nxt[frt[pos]]=nxt[pos];
		frt[nxt[pos]]=frt[pos];
		//拆除当前元素
	}
	return 0;//AC!!!
}
```

---

## 作者：狸狸养的敏敏 (赞：2)

思路：  
本蒟蒻不采用取出，检测，再放回的思路，而是将其取出后，若不符合要求。则加入下一批的检测。即分批检测当前报到的数字是否符合要求。符合要求的输出并删去，不符合要求的再放回去。可能难以理解，不过确实是个$Beautiful$的方法。(~~强行要~~$\LaTeX$)

给你们秀一波本题最短代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,tot;//n,m如题意,tot记录报的数字
	queue<int>que;//定义队列
	for(int i=1;i<=n;i++)
	que.push(i);//初始化
	while(!que.empty())//当队列里还有人就一直循环
	{
		int k=que.front();//取出队首
		que.pop();//删除队首
		tot++;//报的数字加1
		if(tot%m==0)write(k),putchar(' ');//如果是M的倍数，那么输出
		else que.push(k);//否则再放进队尾
	}
	return 0;//程序结束啦
}
```

---

## 作者：707001933K (赞：2)

不得不说这题数据水的。。。

n最大只有100

= =
这里给大家拓展一下

对于n《=500000怎么办呢？

答案是树状数组。

具体细节可以看我的博客：[http://blog.csdn.net/no1\_terminator/article/details/51820165]


这里就只给上代码：



```cpp
#include<cstdio>  
#include<algorithm>  
#include<cstring>  
#include<ctime>  
#define maxn 1000000  
using namespace std;  
int bit[maxn];  
int n,k;  
int sum(int i){  
    int s=0;  
    while (i>0){  
        s+=bit[i];  
        i-=(i&(-i));  
    }  
    return s;  
}  
void add(int i,int x){  
    while (i<=n){  
        bit[i]+=x;  
        i+=(i&(-i));  
    }  
}  
int binary_search(int id){  
    int l=0,r=n+1;  
    while (l<r){  
        int mid=(l+r)>>1;  
        if (sum(mid)<id)l=mid+1;  
            else r=mid;  
    }  
    return l;  
}  
int main(){  
    freopen("input.in","r",stdin);  
    freopen("output.out","w",stdout);  
    while (scanf("%d%d",&n,&k)==2){  
        int id=1;  
        memset(bit,0,sizeof(bit));  
        for (int i=1;i<=n;i++)  
            add(i,1);  
        for (int i=1;i<=n;i++){  
            id=(id+k-2)%(n-i+1)+1;  
            int newid=binary_search(id);  
            printf("%d ",newid);  
            add(newid,-1);  
        }  
    }  
    printf("\nUsed Time=%.2f",(double)clock()/CLOCKS_PER_SEC);  
    return 0;  
}  
```
另外，这数据水还可以从哪里看出来，因为我一开始输出了id，而不是newid，看了我的博客的同学应该知道这区别，但我还是过了一个点
= =希望大家都可以从我的博客学到东西


---

## 作者：1721555739sam (赞：2)

强势应用ASCII码表。。

我是不是很厉害


```cpp
var
  a,b,c,i,j,k,n,m:longint;
  x,y,t:string;
begin
  readln(n,m);
  if n=0 then exit;
  t:='';
  for i:=1 to n do
    t:=t+chr(i+10);
  k:=m;
  while k>length(t) do
        dec(k,length(t));
      write(ord(t[k])-10,' ');
       delete(t,k,1);
  while length(t)>0 do
    begin
      inc(k,m-1);
      while k>length(t) do
        dec(k,length(t));
      write(ord(t[k])-10,' ');
      delete(t,k,1);
    end;
end.

```

---

## 作者：李璨 (赞：2)

一道比较简单的模拟题

方法：死的出局，活的继续，

其实直接用队列就可以过了

貌似还可以用暴搜。数据不咋滴，不过有坑就是有n=0的情况。


附上AC代码


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm> 
using namespace std;
int n,m,p,t,j,nex[105];
int main()
{
    cin >> n >> m; 
    for(int i = 1; i < n; i++)
        nex[i] = i+1; 
    for(nex[0]=nex[n]=1, p=n, t=0, j=1; t<n; cout << nex[p] << ' ',t++,nex[p] = nex[nex[p]],j = 1)
        while(j++ < m)
            p = nex[p];
     return 0;
}
```

---

## 作者：川蜀霸王 (赞：2)

# 树状数组 + 倍增求解约瑟夫问题

## ** 时间复杂度n log n **

```cpp

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<string>
#include<iostream>
#include<set>

const int Maxn=3e5+7;
#define lowbit(x) ((x)&(-x))
int N,m,pos,a[Maxn];
int p;
int search(int x) {
//    printf("\ndasasd %d\n",x);
    int bz = 20;
    int g,c=0,i;
    for(;bz!=-1;--bz) {
        g = 1<< bz;
        i = g + c;
        if(i <= N && a[i] <= x) {
            x -= a[i];
            c = i;
        }
    }
    return c + 1;
}

void Add (int x,int data) {
    for(;x<=N;x+=lowbit(x)) a[x] += data;
}

int main() {
    scanf("%d%d",&N,&m); --m;
    for(int i=1;i<=N;++i) a[i] = lowbit(i);    
    for(int n=N;n>=1;--n) {
        (pos += m) %= n;
        p = search (pos);
        printf("%d ",p);
        Add (p,-1);
    }
    return 0;
}

```

---

## 作者：崔鸣泉 (赞：2)

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
int a[10001],n,m,p,x;
int main()
{
    //freopen("","r",stdin);
    //freopen("","w",stdout); 
    cin>>m>>n;
    for(int i=1;i<=m;i++)// m=8 
    {    
        while(p<n)      //n=3
        {
            if(x<m)
              x++;
            else
              x=1;
            if(a[x]==0)
              p++;
        }
        cout<<x<<' ';
        a[x]=1;
        p=0;  //楼下的有错误，这里应该等于零，而不是加一
    }
    return 0;
}
```

---

## 作者：11223344w (赞：2)

看了那么多pascal，就没有链表，发一段链表。

next存下标，data存数值，具体不说了，自己看

```cpp
var
  i,n,m,e,j:longint;
  next,data:array[0..100005]of longint;
begin
  readln(n,m);
  for i:=1 to n do
  begin
    data[i]:=i; next[i]:=i+1;
  end;
  next[n]:=1; e:=n;
  for i:=1 to n do
  begin
    for j:=1 to m-1 do e:=next[e];
    write(data[next[e]],' ');  //末尾有无空格没有关系
    next[e]:=next[next[e]];
  end;
end.
```

---

## 作者：yin_sy (赞：2)

这个可是高速的约瑟夫。

```cpp
var
  n,m,xb,i,dq,out:longint;
  a:array[0..100000] of longint;
begin
  readln(n,m);
  for i:=1 to n do
    a[i]:=i;
  xb:=1;
  while out<>n do
  begin
    xb:=(xb+m-1-1) mod (n-out)+1;{因为下标多了一，所以减一，-1+1后确保产生的数在1--n-out，理解有点难，多想会}
    inc(out);{每次跳到死的那个人}
    writeln(a[xb]);{输出死的人}
    for i:=xb+1 to n do
      a[i-1]:=a[i];{所有的人往前，死的人的位置被后一个人占，后一个的被再后一个占}
    if xb=n-out+1 then xb:=1;{如果杀掉人后，后面空了，那么转到第一个位置}
  end;
end.
```

---

## 作者：清辉暮翊晨 (赞：2)

不行，这橙题我交了五遍，必须写篇题解纪念下qwq

不说废话，先上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tot;//tot存当前出队的人数
int a[100005],v[100005];
int main()
{
	scanf("%d%d",&n,&m);
	int sum=1,num=0;
	if(n==0)return 0;//第一个坑点 没有人时直接结束程序
	if(m!=n)m=m%n;//第二个坑点 因为是环 m大于n时可以进行m=m%n处理 但要考虑n==m的情况
	for(int i=1;i<=10*n;i++)//需要跑n次才能出n个人 
	{
		int num=1;//此时num为人的编号 破环为链
		for(int j=sum;j<=n+sum;j++)
		{
			a[j]=num;
			num++;
		}
		sum+=n;//每次依次填n个人 
	}
	for(int i=1;i<=sum;i++)
	{
		if(v[a[i]])continue;//如果标记过就跳过
		num++;//此时num为当前报数
		if(num==m)//如果该人需要出列
		{
			tot++;
			num=0;//重置报数
			v[a[i]]=1;//标记该人已经出列
			printf("%d ",a[i]);
		}
		if(tot==n)break;//如果全部出队直接退出循环
	}
	return 0;
}
//复制数组 标记出列 
```

代码思路大概是这样的：将1到n依次填入数组，反复填，类似于破环为链；再在处理好的长链上直接跑报数，已经出列的人用v数组记录，再次扫到该人时直接跳过，没有出列的报数加一，如果当前人报数为m，则标记该人，输出该人，并且重置报数



---

## 作者：FREEH (赞：2)

纯模拟

```cpp
#include<cstdio>
int n,m,b,a,s[10005],sw=0;
int main()
{
    scanf("%d%d",&n,&m);
    for (;sw<n;)//人还没有死光，继续循环 
    {
        b++;//人的编号+1 
        a++;//数的人数+1 
        if (b>n) b-=n;//避免越界 
        while (s[b]==1)
        {
            b++;
            if (b>n) b-=n;
```
}//如果找到的人已经死了，不断地向后找到一个没死的
```cpp
        if (a==m)
        {
            s[b]=1;//标记该人已死  PS：变量名有点…… 
            printf("%d ",b);//输出人的位置 
            sw++;//死亡人数+1 
            a=0;//数清空 
        }
    }
    return 0;
}
```

---

## 作者：ArnoD (赞：2)

模拟
```delphi

var
  a:array[1..10000] of longint;
  n,m,out,i,dq:longint;
begin
  readln(n,m);
  out:=0;
  dq:=1;
  for i:=1 to n do
    a[i]:=i;
  while out<n do
  begin
    dq:=(dq+m-1-1) mod (n-out)+1;//决定谁下一个被杀
    write(a[dq],' ');//输出被杀的人的编号
    for i:=dq to n-out-1 do
      a[i]:=a[i+1];//一个人死了，别的人靠拢，不留出空位
    inc(out);//累加死的人数
  end;
end.

```

---

## 作者：Sinwind (赞：1)

# 1.分析

1. 变量定义：

- 用$num(num\in [0,m],num\in N)(num$从零开始计数$)$记录报数，用$index(index\in [1,n],index\in N_+)(index$，即编号从$1$开始$)$记录下标编号，需要**分别计算**；

- 已出圈的人不需要重复计算，因此用$people$数组记录对应编号的人是否出圈，$true$代表已出圈，$false$代表未出圈；

- $cnt$用来计算出圈人数，当人全都已出圈$(cnt==n)$时，结束循环。

2. 报数：

- 当对应编号的人未出圈$(people[index]==false)$时，才会报数$(num++)$；

- 当需要出圈$(num==m)$时，$num$清零$(num=0)$，以便之后再次报数；将已出圈的状态改变$(people[index]=true)$，输出编号下标$(index)$，出圈人数增加$(cnt++)$；

3. 下表编号：

- 无论有没有报数，下表编号都要增加$(index++)$；

- 当下表编号超出范围$(index>n)$时，变为$1$。
 
# 2.代码

```cpp
#include <iostream>

using namespace std;

int n;              //圈的总人数
int m;              //出圈的数
int index = 1;      //下标编号
int num = 0;   		//报数
int cnt = 0;        //出队人数
bool people[101];   //false代表未出圈，true代表已出圈

int main(void)
{
	cin >> n >> m;
	
	while(cnt < n)
	{
		if(people[index] == false)
		{
			num++;
		}
		if(num == m)
		{
			num = 0;
			people[index] = true;
			cout << index << " ";
			cnt++;
		}

		index++;
		if(index > n)
		{
			index = 1;
		}
	}
	
	return 0;
}
```


---

## 作者：zhuixun_ (赞：1)

写个队列模拟的题解
```cpp
#include <iostream>
#include<queue>
#include<cstdio>
using namespace std;
int n,m;
queue<int > Q;
int main(int argc, char** argv) {
	scanf("%d%d",&n,&m);
	while(!Q.empty())  Q.pop();
	for(int i=1;i<=n;i++)
		Q.push(i);
	while(!Q.empty()){
		int i=1;
		for(;i<=m-1;i++){
			int x=Q.front();
			Q.pop();
			Q.push(x);
		}
		if(i==m){
			printf("%d ",Q.front());
			Q.pop();
		}
	}
	return 0;
}
```

---

## 作者：LJB00125 (赞：1)

坑点1:居然有n、m均等于0的情况

坑点2:有n==m的情况


首先,使用结构体yuesefu ~~我实在想不出应该取什么名字~~

```cpp
struct yuesefu
{
    int data; //记录这一项的数据
    bool used; //记录这一项是否使用过
}a[105];
```
读入后应该判断是否是n、m均等于0的情况(坑1)

```cpp
int n,m;
scanf("%d %d",&n,&m); //读入
if(n==0&&m==0) return 0; //特判
```
为了节省时间，m需要对n取模(但是切记当m等于0时将m赋值为n！)(坑2)

```cpp
m%=n; //取模
if(m==0) m=n; //特判
```
之后将每一项的data标记为i,并且没有使用过:

```cpp
for(int i=1;i<=n;i++)
    a[i].data=i,a[i].used=0; //标记data为i，没有使用过
```

由于之后没什么坑了，就直接上代码:~~似乎上面那段代码就没坑~~

```cpp
for(int i=1;i<=n;i++)
{
    //now:记录现在位于第几项
    jia=m; //还要加上m次
    while(jia>0) //只要还需要加
    {
        now++;
        now%=n; //将now变为下一项且取模
        if(now==0) now=n; //如果now==0就将now赋值为n！！！
        if(a[now].used==0) //如果并没有使用过
            jia--; //那么将还需要加的次数减1（否则不变）
    }
    printf("%d ",a[now].data); //输出这个点的数据
    a[now].used=1; //并标记为使用过
}
```

---

## 作者：twogoat (赞：1)

```cpp
//用一个结构体做
#include<iostream>
#include<string>
using namespace std;
struct xy{        //一个包含的信息 
    bool pd=1;    //判断这人是否已出列 
    int bh;     //这个人的编号 
    int numble; //这个人报到第什么数 
};
xy r[101]; //定义100个人 
int main()
{
    int n,m,i=1,s=1,l=0;
    //i为到第几个人
    //s为报到第几个数 
    //l为计数已有多少人出列 
    cin>>n>>m;
    if(n==0&&m==0)return 0;    //如果n和m都是0,直接退出程序 
    for(int k=1;k<=n;k++)r[k].bh=k;    //给每个人定一个编号 
    while(1)
    {
        if(r[i].pd==1)    //r[i].pd=1表示这个人还未出列 
        {
            r[i].numble=s;     //r[i]报道的数为s 
            s++; //到下一个数 
        }
        if(r[i].numble==m&&r[i].pd==1)//当这个人报到m并且他还未出列时运行 
        {
            s=1; //报的数又1开始 
            cout<<r[i].bh<<" "; //输出出列的人的编号 
            l++; //已有l人出列 
            r[i].pd=0; //这r[i].pd=0表示个人已出列 
            if(l==n)return 0; //如果所有人都出列了，直接结束程序 
        }
        i++; //到下一个人 
        if(i==n+1)i=1; //如果到尾了就从头开始报 
    }
}
```

---

## 作者：Kosmlso (赞：1)

\*用了栈来做，看下面好像没有..\*

**仅供参考.水平有限**


    
```cpp
#include<iostream>     
#include<stack>
using namespace std;
int main(){
    int a[100001];     //emmmm..
    stack<int> umi;     //就叫umi好了
    int n,m,n1;   //n是多少个人 m为数的数 n1下面用来构成循环(圈子?.
    cin>>n>>m;
    n1=n;  //存一下
    for(int i=1;i<=n;i++){
        a[i]=i;}    //编个号
    int count=0,c=0;     //count 用来判断是否数到  c 用来判断有没有输完n个人的编号.
    for(int i=1;c<n;i++){   
        count++;
        n1++;
        a[n1]=a[i];
        umi.push(a[i]);
        if(count==m){   
            cout<<umi.top()<<" ";   //那咱们就输出数到数的人咯
            c++;       //输出的话，就记一下
            umi.pop();    //那这个人就下场了(die??
            n1--;     //因为他走了，咱就不能让那个位置空着.
            count=0;   //清零
            continue;  //继续
        }
    }
    return 0;
}
*噎死，大概就是这样..能力有限..*
```

---

## 作者：bingliang (赞：1)

数据结构体 基本思路就是看看你要维护那些信息，可以丢弃那些信息，并根据题面进行估计时空复杂度，然后用你想到的数据结构

瞎jb维护就好了。 基本就是模拟。

本体考虑 情况十个环 每次向一个方向转 就可以用 并茶几（错别字不少请见谅）（老鸟勿喷）。。。

就是对并茶几增加一个 del操作，有点像链表 。

每次顺这走，如果那人退出游戏，就把他del掉。

下面是代码


```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,first,cnt,ans;
struct node
{
int dad;
int son;
}pre[100000];
int main()
{
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        pre[i].dad=i+1;
//        cout<<pre[i]<<" "<<i<<endl;
    }    
    pre[n].dad=1;
    for(int i=2;i<=n;i++)
    {
        pre[i].son=i-1;
    }
    pre[1].son=n;
//    cout<<pre[n]<<endl;
    first;
    cnt=n;
    first=1;
    int p;
while(cnt!=0)
{
    int j=m-1,l;
//    first=1;
//    cout<<first<<endl;
    while(j!=0)
    {
        p=pre[first].dad; 
    //    cout<<first<<" ";
        first=p;
    j--;
    //first++;
    }
     l=pre[first].dad;
    // cout<<first<<" ";
    //first%=cnt;
//   cout<<cnt<<endl;
    pre[pre[first].son].dad=pre[first].dad;
    pre[pre[first].dad].son=pre[first].son;
    pre[first].dad=0;
    pre[first].son=0;
    cout<<first<<" ";
    first=l;
    cnt--;
}
    return 0;
}
```

---

## 作者：wangweiba (赞：1)

很经典的一道题模拟题，难点是如果轮流报到m的人要出列并输出，果断选择做记号

程序如下：


```cpp
var n,m,i,t,s:longint;
     f:array [0..100000] of 1..0;
begin
  read(n,m);
  for i:=1 to n do f[i]:=1;     //如果记号为1，那么说明这个人在队伍里
  t:=n;
  while t>0 do begin      //所有人出圈终止循环
    for i:=1 to n do begin
      if f[i]:=1 then s:=s+1;    //如果第i个人还在圈内，那就开始报数
     if s=m then begin        //如果某个人报到的m这个数字
       write(i,' ');                   //输出这个人的号码
       f[i]:=0;                     //将记号改为0，表示出圈
       s:=0;                      //报数器从新开始
       t:=t-1;                    //在圈内的人数减一
     end;
  end;
end.

```

---

## 作者：maozi (赞：1)

用的是指针写的约瑟夫，简单的指向问题，指针移动停止的地方进行输出 并标记为0 ，k代表相隔几个输出一个元素，其中加了一个特判， 当n=0的时候，直接结束。代码如下：

    
    
```cpp
#include<iostream>
using namespace std;
int main()
{
    int i,k,m,n,num[110],*p,c;
//    cout<<"input number of person:n=";
    cin>>n>>c;
    p=num;
    for(i=0;i<n;i++)
    {
        *(p+i)=i+1;
    //    cout<<*(p+i)<<" ";
    }
//    cout<<endl;
    //cout<<"^^^^^^^^以上为指针所指向每个地址所赋的值^^^^^^^^^======================"<<endl;
    i=0;k=0;m=0;
    if(n==0)
        return 0;
    while(m<n-1)
    {
    //    cout<<"以k来计数当到了k=c进行另一个条件,当前的k值："<<k<<"++++++++++++++++++++++++++++++++"<<endl;
        if(*(p+i)!=0)   k++;
        if(k==c)
        {
            cout<<*(p+i)<<" ";
            *(p+i)=0;
            k=0;
            //cout<<k<<"从新计数"<<endl;
            m++;
        //    cout<<m<<"m为消掉的数 用作外循环的终止条件"<<endl;
        }
        i++;   //是指针不断指向下一个值
        if(i==n)   //当i到n时将其返回0 从新进行向下搜寻
            i=0;
    }
    while(*p==0)      //用指针指向空间为0 来计数 直到不为0时便找到了最后一个没有被消掉的数
        p++;
    cout<<*p<<endl;
return 0;
}
```

---

## 作者：SovietPower✨ (赞：1)

一道模拟题，我觉得不需要什么太多的基础

感觉其它题解写的很复杂，其实这题就可以单纯模拟整个过程，

分享一下我的做法

```cpp
#include<iostream>
using namespace std;
int n,m;
bool out[102];//out[i]:记录点i是否已经出圈,为true则已出圈,之后循环需要跳过i;false则表示还未出圈 
int main()
{
    scanf("%d%d",&n,&m);
    int cnt=0,now=0,tot=0;//cnt:当前数的数  now:当前轮到第几个人   tot:已出圈人数,用来在达到条件时结束循环(等于总人数n) 
    while(tot!=n)
    {
        cnt++;now++;
        if(cnt==m+1)//循环处理,形成一个环 
          cnt=1;
        if(now==n+1)//同上 
          now=1;
        while(out[now])//当now这个人已经出圈时,应跳过now,直到找到下个未出圈的人(out[now]=false) 
        {
            ++now;
            if(now==n+1)//形成环 
              now=1;
        }
        if(cnt==m)//当前数到m,now出圈,总出圈人数+1 
          out[now]=1,++tot,printf("%d ",now);
    }
    return 0;
}
```

---

## 作者：EkiXu (赞：1)

###高效线段树题解

分析一下，我们有以下两种操作：

1． 找到剩余队列中第K个人在数组中的位置

2． 删除第K个人

假如我们一开始给每个人一个权值1，然后维护一个前缀和s(n)那么，操作1就变成了找到前缀和为i的位置。当将第i个人删除时，只需将其权值置0，维护好前缀和，这样剩余队列中第i’个人的实际位置就在原先第i人后面了。

我们可以把前缀和转换为区间和，所以我们可以用线段树进行快速操作。

具体实现见代码注解

```cpp
#include<cstdio>
#define MAXN 1000000
#define lson x<<1,l,mid
#define rson x<<1|1,mid+1,r
#define MID int mid=(node[x].l+node[x].r)/2;
struct Node{
    int l;
    int r;
    int sum;
}node[MAXN<<2];
inline int Query(int x,int k){//查找出圈者
    if(node[x].l==node[x].r) return node[x].l;
    if(node[x<<1].sum>=k){
        return Query(x<<1,k);
    }else return Query(x<<1|1,k-node[x<<1].sum);
}
inline void Update(int x,int v){//单点更新
    if(node[x].l==node[x].r){node[x].sum=0; return;}
    else{
        MID;
        if(v<=mid) Update(x<<1,v);
        else Update(x<<1|1,v);
    }
    node[x].sum=node[x<<1].sum+node[x<<1|1].sum;
}
inline void Build_Tree(int x,int l,int r){//普通地建树
    node[x].l=l,node[x].r=r;
    if(l==r) {node[x].sum=1;return ;}
    MID;
    Build_Tree(lson);
    Build_Tree(rson);
    node[x].sum=node[x<<1].sum+node[x<<1|1].sum;
}
int main(){
    int N,M;
    scanf("%d%d",&N,&M);
    if(N==0) return; //防神奇数据的特判 
    Build_Tree(1,1,N);
    int i=1,p,m;
    do{
        m=(i+M-1)%N;//计算绝对位置 
        if(m==0) m=N;
        p=Query(1,m);
        printf("%d ",p);
        Update(1,p);
        i=m%(N--);//下一次的相对位置 
        if(i==0) i=1;
    }while(N>1);
    printf("%d\n",Query(1,1));
    return 0;
}
```
有关其他约瑟夫问题求解的方法见本人博客

[http://ozem.pw/archives/518](ozem.pw/archives/518)


---

## 作者：Kidd (赞：1)

死模拟……

var n,m,i,x,r:longint;a:array[0..100000] of boolean;t:boolean;


```cpp
begin
   read(n,m);
   while true do//死循环，很霸气吧
   begin
      inc(r);//数到了几
      for i:=0 to n-1 do//这个方便操纵
      if a[i]=false then begin t:=false;break;end else t:=true;
      if t then break;//活门就是这个，都死了就跳
      t:=false;
      if a[r mod n]=false then inc(x);
      if (x mod m=0) and (a[r mod n]=false) then
      begin
            a[r mod n]:=true;//标记
            if r mod n=0 then write(n,' ')
                                  else write(r mod n,' ');end;//输出
       end;
end.
如果你粘贴我的代码只能拿80分，因为这题数据有误，真要AC看其他题解
```

---

## 作者：shadow_z (赞：1)

```cpp
#include <iostream>
using namespace std;
int main()
{
    int m,n;
    cin>>n>>m;
    int a[n+1],j=n,k=1,p=0;
    for(int i=1;i<n;i++) //建立链表
        a[i]=i+1;
    a[n]=1; //第n个人指向第1个人，形成一个环
    while (p<n)  //直到n个人都出队为止
    {
        while(k<m)   //报数，计数器加1
        {
            j=a[j];
            k++;
        }
        cout<<a[j]<<" ";   //数到m，此人出队，计数器置1
        p++;
        a[j]=a[a[j]];
        k=1;
    }
    return 0;
}

```

---

## 作者：lucahan (赞：1)

```cpp

#include<iostream>
#include<queue>
using namespace std;
int main()
{
  queue<int>q;
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    q.push(i);
  }
  int i=1;
  while(!q.empty())
  {
    if(i==m)
    {
      cout<<q.front()<<" ";
      q.pop();
      i=1;
    }
    q.push(q.front());
    q.pop();
    i=i+1;
  }
  return 0;
}

```

看到这题解，我表示哪有那么复杂，直接用队列不就好了吗。如果最后剩下一个，那也还是出队入队，达到指定的次数就可以了啊


---

## 作者：spacetime (赞：1)

//坑啊，输入数据里居然有个n=0的，结果WA了一次。。

//总之，纯模拟。因为不想用链表所以用了move函数，高效解决线性表删除问题

```cpp
var
  n,m,i,place:longint;
  a:array[1..30000]of longint;
begin
  read(n,m);
  if n=0 then halt;
  for i:=1 to n do a[i]:=i;//初始化
  place:=0;
  for i:=n downto 2 do begin
    inc(place,m);//place模拟指针向后移
    while place>i do dec(place,i);//指针上溢倒退处理
    write(a[place],' ');//输出当前元素
    move(a[place+1],a[place],(i-place)<<2);//神奇的move。。高效实现删除元素
    dec(place);//指针随删除元素而倒退
  end;
  writeln(a[1]);
end.
```

---

## 作者：GUIDE (赞：1)

```cpp
var a:array[1..10000] of boolean;
n,m,s,f,i:integer;
begin
readln(n,m);
for i:=1 to n do
a[i]:=false;
f:=0; i:=0; s:=0;
repeat
i:=i+1;{逐个枚举圈中所有位置}
if i=n+1 then i:=1;{最后一个与第一个相连}
if a[i]=false then{有人的话，则报数}
s:=s+1;
if s=m then
begin
s:=0;{清空}
write(i,' ');{输出}
a[i]:=true;
f:=f+1;
end;
until f=n;{直到所有人都出圈}
readln;
end.
```

---

## 作者：XiXi (赞：1)

附上超简代码：

```delphi

var  
n,m,i,s,p:integer;  
a:array[1..10000] of integer;
begin  read(n,m);
for i:=1 to n do    
a[i]:=1;p:=0;s:=0;
repeat    
for i:=1 to n do    
begin    if a[i]=0    
then   continue; 
s:=s+a[i];
if s=m then
begin     
write(i,' ');
a[i]:=0;
p:=p+1;
s:=0;
end; end;  until p=n;
end.
```
难点在于数到那一个人时，就不存在了


---

## 作者：ROOToj (赞：1)

简单模拟，重复的暴搜即可。


附上AC源代码：


```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define MAXN 1000010
int n,m,a[MAXN],cur=0,k=0,first=1,i;
int main()
{
    scanf("%d%d",&n,&m);
    memset(a,0,sizeof(a));
    for(i=1;i<=n;i++)
    {
        for(;;)
        {
            cur=(cur%n)+1;
            if(!a[cur])k++;
            if(k==m)
            {
                a[cur]=1;
                if(first){printf("%d",cur);first=0;}
                else printf(" %d",cur);
                break;
            }
        }
        k=0;
    }
    putchar('\n');
    return 0;
}

```

---


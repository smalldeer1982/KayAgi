# [朝阳区小学组 2019] nonzero

## 题目背景

数据为洛谷自造。

## 题目描述

小明最近对阶乘很感兴趣，但是阶乘增长的太快了。如 $13!$ 就必须用 $64$ 位整数类型来存储，$70!$ 即使浮点数也存不下。小明想知道阶乘最后面的非零位是多少。

例如：$5!=1\times 2\times 3\times 4\times 5=120$，所以 $5!$ 最后面的非零位是 $2$。

$7!=1\times 2\times 3\times 4\times 5\times 6\times 7=5040$，所以 $7!$ 最后面的非零位是 $4$。

## 样例 #1

### 输入

```
7```

### 输出

```
4```

# 题解

## 作者：TheTrash (赞：2)

### 思路

由于 $N\le1000$，所以可以用高精度求出 $N!$，再从最后一位一直找上去，找到一个非零位就输出该位并结束程序。

### 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int f[10005];//一万位足够了
int main(){
	cin>>n;
	f[0]=1;
	for(int i=2;i<=n;i++){
		for(int j=0;j<10000;j++) f[j]*=i;//无脑乘
		for(int j=0;j<10000;j++) if(f[j]>9) f[j+1]+=f[j]/10,f[j]%=10;//进位
	}
	for(int i=0;;i++){//最后一位从 0 开始
		if(f[i]!=0){
			cout<<f[i];
			break;
		}
	}
}
```

---

## 作者：guoshengyu1231 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4268)

此处提供两种做法。
# 做法一
## 思路
既然不需要考虑末尾的 $0$，那我们在每次累乘答案的时候去掉末尾的 $0$，最后再输出答案的末位即可。
## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int mod=10000; 
int n,ans=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	 {
		ans*=i;
		while(ans%10==0) ans/=10;
		ans%=mod;	
	 }
	cout<<ans%10;
	return 0;
}
```
# 做法二
## 思路
还可以从数论的角度来思考问题，先统计 $1$ 到 $n$ 中能分解出多少个 $5$。再从 $1$ 到 $n$ 中消除同数量的 $2$。最后相乘即可。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10000;
int n,a[1005],cnt,ans=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	 {
		a[i]=i;
		while(a[i]%5==0)
		 {
			a[i]/=5;
			cnt++;	
		 }	
	 }
	for(int i=1;i<=n;i++)
	 {
		if(cnt==0) break;
		while(a[i]%2==0&&cnt)
		 {
			a[i]/=2;
			cnt--;
	     }
	 }
	for(int i=1;i<=n;i++)
	 {
		ans*=a[i];
		ans%=mod;
	 }
	cout<<ans%10;
	return 0;
}
```

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4268)

# Problem

求出 $n!$ 的最后面的非零位是多少。

# Solution

首先如何将 $n!$ 的最后一位算出？

推论：对于加法、乘法、乘方运算，算好后取余和边算边取余是等价的。

> 证明：
>
> 以加法为例：
>
> $(a+b+c+\cdots +d)\bmod m$
>
> 将 $a,b,c,\cdots ,d$ 分解成 $z_1m+k_1,z_2m+k_2,z_3m+k_3\cdots z_4m+k_4$。
>
>则原式：
>
>$=(z_1m+k_1 , z_2m+k_2 , z_3m+k_3+\cdots +z_4m+k_4)%m$
>
>$=(k_1+k_2+k_3+\cdots +k_4)%m$
>
>$=(a\bmod m+b\bmod m+c\bmod m+\cdots +d\bmod m)$
>
> 乘法也是类似。

随后就是将 $n!$ 的零位去除，可以不断将 $n!\bmod 10$ 如果是 $0$ 则去除它，也就是 $n{\div} 10$。

如果你按上面的步骤并且开 `unsigned long long`，你只能得 $30$ 分。这时你需要设一个值最好是 $10$ 的次方，不断将 $n\bmod$ 这个值，可以减少复杂度。这里我使用 $10^4$。

# Code

复杂度：$O(\frac{n\log_{10}n}{10^4})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,sum=1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		sum*=i;
		while(sum%10==0){
			sum/=10;
		}
		sum%=10000;
	}
	cout<<sum%10<<endl;
	return 0;
}
/*

*/
```

---

## 作者：dear_deer_land (赞：0)

## 题意
计算一个数的阶乘从右到左第一个非 $0$ 数。
## 思路
暴力肯定是不可行的，$21$ 的阶乘使用 $64$ 位整数都存不下。那么我们考虑把阶乘拆开，因为 $1$ 的阶乘是 $1$，所以我们从 $2$ 开始枚举到 $n$，把每一个数累乘，因为 $10$ 只能由因子 $2$ 和 $5$ 凑出来，所以我们对于每一个要累乘的数去除因子 $2$ 和 $5$ 之后，累乘并取余 $10$ 计算末位。因为阶乘结果中因子 $2$ 的数量和 $5$ 的数量大概率不同，并且我们可以知道，$2$ 的倍数一定比 $5$ 的倍数的个数多，所以因子中 $2$ 的数量一定不少于 $5$ 的数量。我们记一个 $lst$ 为因子中 $2$ 的数量减去 $5$ 的数量的结果，循环 $lst$ 次，每次把累乘的结果乘 $2$ 并对 $10$ 取模，就可以得出最终的结果了。
## 代码
```
#include <bits/stdc++.h> 
using namespace std; 
int n,cnt2,cnt5,ans=1;//cnt2记录因子中2的个数，cnt5记录因子中5的个数。
//ans初始值赋为1是因为1!=1
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){
        int x=i;
        //去除因数2
        while(x%2==0){
            cnt2++;
            x/=2;
        }
        //去除因数5
        while(x%5==0){
            cnt5++;
            x/=5;
        }
        //累乘剩余的数,并取模10
        ans=(ans*x) % 10;
    } 
    //处理多余的因数2或因数5
    int lst=cnt2-cnt5;
    //lst记录多余的2的数量,因为因子中2的数量永远多于5的数量,所以lst始终非负
    while (lst > 0) {
        ans=(ans * 2)%10;
        lst--;
    }
    cout<<ans<<endl; 
    return 0; 
}
```

---

## 作者：LINYUHENG2 (赞：0)

## 思路
为什么阶乘的末尾会有 $0$？因为 $2$ 和 $5$ 相乘，得到了 $10$，末尾便有了 $0$。

换句话说，$2 \times 5=10$，正是因为有了这个 $10$，末尾就会多出一个 $0$。

那么，怎么知道末尾有多少 $0$ 呢？是看 $2$ 还是看 $5$？显然，因式分解后，$5$ 的数量明显比 $2$ 少，那么，末尾 $0$ 的个数就是因式分解后 $5$ 的个数。

因为只需要知道最后面的非零位，所以，其他数我们只需要个位。

于是，我们得到了以下这个等式：
$$
\text{阶乘最后面的非零位} = (2^{(2 \text{的个数}- 5 \text{的个数})} \times \text{其他数}) \bmod 10
$$
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,cnt,sum=1;
int qiu(int a){
    int b=a;
    while(b%2==0){
        b/=2;
        cnt++;
    }
    while(b%5==0){
        b/=5;
        cnt--;
    }
    return b;
}
int main(){
    scanf("%d",&n);
    for(int i=2;i<=n;i++){
        sum=sum*qiu(i)%10;
    }
    for(int i=1;i<=cnt;i++){
        sum=sum*2%10;
    }
    printf("%d",sum);
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/209940554)

---


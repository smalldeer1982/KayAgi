# [GESP202406 五级] 小杨的幸运数字

## 题目描述

小杨认为他的幸运数字应该恰好有两种不同的质因子，例如，$12=2\times 2\times 3$ 的质因子有 $2,3$，恰好为两种不同的质因子，因此 $12$ 是幸运数字，而 $30=2\times3\times5$ 的质因子有 $2,3,5$，不符合要求，不为幸运数字。

小杨现在有 $n$ 个正整数，他想知道每个正整数是否是他的幸运数字。

## 说明/提示

### 样例解释

$7$ 的质因子有 $7$，只有一种。

$12$ 的质因子有 $2,3$，恰好有两种。

$30$ 的质因子有 $2,3,5$，有三种。


### 数据范围

子任务编号|数据点占比|$n$|正整数值域
:-:|:-:|:-:|:-:
$1$|$40\%$|$\leq 100$|$\leq 10^5$
$2$|$60\%$|$\leq 10^4$|$\leq 10^6$

对于全部数据，保证有 $1\leq n\leq 10^4$，每个正整数 $a_i$ 满足 $2\leq a_i\leq 10^6$。

## 样例 #1

### 输入

```
3
7
12
30```

### 输出

```
0
1
0```

# 题解

## 作者：PokerKing (赞：17)

## 题意

如果一个数的质因子中只有两个不同的数则输出 $1$，否则输出 $0$。

## 思路
从第一个质因子遍历到 $sum$ 的话很明显是 $O(nt)$ 最大是 $n^{10}$ 很明显会炸掉。

所以遍历到 $sum$ 是不行的，考虑正整数 $n$ 最大的质因数是 $\sqrt{n}$ 所以遍历到 $\sqrt{n}$ 即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int lucky(int sum) {//函数处理是否为幸运数 
	int ans=0;
	int a=sum;
	for(int i=2; i*i<=a; i++) {
		if(sum%i==0) {
			ans++;
			while(sum%i==0) {
				sum/=i;
			}
		}

	}
	if(sum>1) {
		ans++;
	}
	if(ans==2) {
		return 1;
	} else {
		return 0;
	}
}
int main() {
	int n;
	cin>>n;
	int a;
	while(n--) {
		scanf("%d",&a);
		cout<<lucky(a)<<endl;
	}
	return 0;
}
```

---

## 作者：Eason_cyx (赞：11)

对于每一个数直接进行暴力质因数分解（即，从 $2$ 枚举到 $\sqrt n$，如果一个数是 $n$ 的因数且为质数，就不断用它除 $n$，直到除不尽为止，如果 $n$ 已经为 $1$，结束分解），判断质因数是否只有不同的两个即可。

讲几个优化：

- 如果 $n$ 变成了一个质数，那么直接判断当前不同质因数个数是否为 $1$。

- 如果 $n$ 初始时就是质数，那么一定只有一个质因子，即为 $n$，可以直接判断不是小杨的幸运数字。

代码不放了。

---

## 作者：HasNoName (赞：10)

### 思路

用一个函数得出一个数中不同质因数的个数。

从一道 $\sqrt{n}$ 中每个判断是否能整除 $n$，能整除则尽量去除，这样就可以得出所有 $n$ 小于等于 $\sqrt{n}$ 的因数。

因为大于 $\sqrt{n}$ 的 $n$ 的因数最多一个，再特判一下即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int n)
{
	int c=n,ans=0;
	for(int i=2;i*i<=c;i++)//从2到[sqrt(n)]枚举因数
	{
		if(n%i==0)
		{
			ans++;
			while(n%i==0)n/=i;
		}
	}
	if(n>1)ans++;//大于sqrt(n)的因数
	return ans;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T,n;
	cin>>T;
	while(T--)
	{
		cin>>n;
		if(f(n)==2)cout<<"1\n";
		else cout<<"0\n";
	}
	return 0;
}
```

---

## 作者：Dioretsa (赞：4)

对于每个数 $x$ 进行质因数分解，判断其质因子的个数是否恰好为 $2$ 个即可。

不会质因数分解可以看：[B3871 [GESP202309 五级] 因数分解 题解](https://www.luogu.com.cn/problem/solution/B3871)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
int main() {
	cin>>n;
	while(n--){
		int x,cnt=0;
		cin>>x;
		for(int i=2;i<=sqrt(double(x));i++){
			if(x%i==0){
				while(x%i==0) x/=i;
				cnt++;
			}
		}
		if(x!=1) cnt++;
		if(cnt==2) cout<<1<<endl;
		else cout<<0<<endl;
	}
	return 0;
}

```

---

## 作者：lailai0916 (赞：3)

## 原题链接

- [洛谷 P10720 [GESP202406 五级] 小杨的幸运数字](https://www.luogu.com.cn/problem/P10720)

## 解题思路

循环遍历 $[2,\sqrt{a}]$ 之间的整数 $i$，检查 $i$ 是否是 $a$ 的因子。如果是，就不断从 $a$ 中去除 $i$ 因子，直到 $a$ 不能被 $i$ 整除为止。

显然 $a$ 至多有 $1$ 个质因子大于 $\sqrt{a}$。循环结束后，如果 $a>1$，那么此时 $a$ 也是一个质因子。

统计质因子的种数，判断其是否等于 $2$。时间复杂度 $O(n\sqrt{a})$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin>>n;
	while(n--)
	{
		int a;
		cin>>a;
		int cnt=0,t=a;
		for(int i=2;i*i<=t;i++)
		{
			if(a%i==0)
			{
				cnt++;
				while(a%i==0)a/=i;
			}
		}
		if(a>1)cnt++;
		cout<<(cnt==2)<<'\n';
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：3)

枚举给定整数的质因子，若数量已经超过两个则直接判断不是幸运数字。最后判断是否有且仅有两个质因子即可。 

```c++
#include<bits/stdc++.h>
using namespace std;

int islucky(int x){
	if(x<6) return 0;
	int sum=0;
	for(int i=2; i*i<=x; i++){
		if(x%i==0){
			sum++;
			if(sum==3) return 0;
			while(x%i==0) x/=i;
		}
	}
	if(x!=1) sum++;
	if(sum==2) return 1;
	return 0;
}

int main(){
	int n;cin>>n;
	while(n--){
		int m;cin>>m;
		cout<<islucky(m)<<"\n";
	}
	return 0;
}

```

---

## 作者：SkyLines (赞：3)

## Solution

求出 $n$ 的所有质因数，如果刚好有 $2$ 个，则是幸运数字，否则不是。

可以预处理 $10^6$ 以内的质数，每次询问枚举所有质数即可。$10^6$ 以内的质数只有 $78498$ 个（用素数筛）。

每次枚举第 $i$ 个质数时，要判断 $i \le 78498$ 和这个质数 $p_i \le n$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int t, n, tot, pri[N], num;
bool flag[N];
void solve(){
	tot = 0;
	scanf("%d", &n);
	for(int i = 1; i <= num && pri[i] <= n; i++){
		if(!(n % pri[i])){
			tot++;
		}
		while(!(n % pri[i])){
			n /= pri[i];
		}
	}
	printf("%d\n", tot == 2);
}
int main(){
	for(int i = 2; i <= 1e6; i++){
		if(!flag[i]){
			pri[++num] = i;
		}
		for(int j = 1; j <= num && i * pri[j] <= 1e6; j++){
			flag[i * pri[j]] = 1;
			if(i % pri[j] == 0) break;
		}
	}
	scanf("%d", &t);
	for(int kk = 1; kk <= t; kk++) solve();
	return 0;
}
```

---

## 作者：zhuxiangrui_2010 (赞：2)

## 题意
给定 $N$ 个正整数，求每个正整数是否恰好有两种不同的质因子。
## 思路
由于数据规模较大，所以暴力记录一定会超时，可以考虑从 $2$ 枚举到 $a_i$ 的平方根记录质因子，若 $a_i$ 不为一时加一即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
int main(){
	cin>>n;
	while(n--){
		int x,t=0;
		cin>>x;
		for(int i=2;i<=sqrt(x);i++){
			if(x%i==0){
				t++;
			}
			while(x%i==0){
			    x/=i;
			}
		}
		if(x!=1){
		    t++;
		}
		if(t==2){
		    cout<<1<<endl;
		}else{
		    cout<<0<<endl;
		}
	}
	return 0;
}
```

---

## 作者：lucasincyber (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10720)
## 思路
这道题可以直接分解质因数，然后判断有多少个质因子，最后按题目要求输出。

分解质因数时间复杂度为 $O(\log{n})$，总时间复杂度为 $O(t \times \log{n})$。$t$ 为数据组数，$n$ 为需要求解的数。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int t, n;

bool check(int x)
{
    int cnt = 0;
    for (int i = 2; i <= x / i; i++)
    {
        if (x % i == 0)
        {
            cnt++;
            while (x % i == 0)
                x /= i;
        }
    }
    if (x > 1) cnt++;
    return (cnt == 2);
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &n);
        printf("%d\n", check(n));
    }
    return 0;
}
```

---

## 作者：JYX0924 (赞：1)

首先，使用筛法筛出需要用到的所有质数，然后对于每一次询问暴力枚举它的质因子即可。

下面是我的 AC 代码。

```c
#include<bits/stdc++.h>
using namespace std;
int T,n,sum[100005],num,vis[1000005];

void zhishu()
{
	for(int i=2;i<=1000000;i++)
	{
		if(vis[i]==1) continue;
		sum[++num]=i;
		for(int j=1;i*j<=1000000;j++) vis[i*j]=1;
	}
}

int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>T; zhishu();
	while(T--)
	{
		cin>>n; int tt=n,t=0;
		for(int i=1;i<=num;i++)
		{
			if(sum[i]>tt) break;
			int flag=0;
			while(tt%sum[i]==0) tt/=sum[i],flag=1;
			if(flag==1) t++;
		}
		if(t==2) cout<<"1\n";
		else cout<<"0\n";
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：maomao233 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10720)

显然我们需要先将 $a_i$ 分解质因数。  
首先从小到大枚举 $a_i$ 的因数，然后找到单个或者多个相同的质因数，用一个“桶”记录。最后判断“桶”的大小是否为 $2$ 即可。

我爱 STL！  
map 是 STL 中的一个容器，它提供一对一的数据处理能力。在这道题中 map 或许比静态数组更实用，可以直接使用 `.size()` 计算“桶”的大小。  
不过两种“桶”都需要多测清空。

```cpp
map<int,bool>mp;
signed main()
{
	int t;
	rd(t);
	while(t--)
	{
		mp.clear();
		int n;
		rd(n);
		for(int i=2;i*i<=n;i++)
		{
			while(n%i==0)
			{
				n/=i,mp[i]=1;
			}
		}
		if(n!=1)
		{
			mp[n]=1;
		}
		wtl(mp.size()==2);
	}
	return 0;
}
```

---

## 作者：gh_AC (赞：0)

# # P10720 [GESP202406 五级] 小杨的幸运数字 题解

## 思路：

首先一看到题目，发现只是分解质因数，可仔细一看，发现数据规模很大，直接记录质因子在进行计数必定会超时，这时我们就需要思考一下：

- 首先我们可以发现：如果输入的是一个质数，那它的质因子就只有它本身，也就只有一个，可题目要求我们有两个质因数的才是幸运数字，所以我们就可以在输入完判断如果是质数就直接输出 $0$。
  
- 然后我们知道：质数中除了 $2$ 以外的都是奇数，所以我们在后面用循环计数时就可以先将 $2$ 拿出来单独算，然后后面从 $3$ 开始，每一次都加二就又能缩短些时间。
  
- 在循环中我们计算质因子的个数时，如果超过了 $2$ 就可以直接跳出循环，因为只有质因数为 $2$ 的才算幸运数字。
  

知道怎样不会超时后就可以开始写了，我们在循环中每一次判断如果当前的 $i$ 是我们输入的数的质因数就将它除尽，然后将我们计数的变量加一。

最后判断这个数的质因子数量不是二就输出 $0$，是二就输出 $1$。

下面是代码，有不懂的可以根据代码来理解，还是比较简单的。

## 代码：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int n,a;
bool p(int x){
	if(x<2) return false;
	else
		for(int i=2;i<=sqrt(x);i++)
			if(x%i==0) return false;
	return true;
}// 判断质数 
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&a);
		if(p(a)) printf("0\n");
		// 如果是质数就输出0 
		else{
			int s=0;
			if(a%2==0){
				while(a%2==0) a/=2;
				s++;
			}
			for(int i=3;i<=a;i+=2){ 
				if(a%i==0){
					while(a%i==0) a/=i;
					// 每一次都将质因数除尽 
					s++;
					// 质因子个数加一 
					if(s>2) break;
					// 质因子个数大于2就不是幸运数字，直接跳出循环 
				}
		    }
		    // 算出质因子个数 
		    if(s!=2) printf("0\n");
		    else printf("1\n");
		    // 判断输出 
		}
		
	}
	return 0;
}
```

---

## 作者：luuia (赞：0)

### 题目大意

给定 $n$ 个正整数，判断每一个是否恰好含有两个不同的质因子。

### Solution

我们先线性筛出素数，然后对于每一个数，判断每个比它小的素数是不是它的因数，如果质因数个数恰好为 $2$ ，那么输出答案即可。

### Code

[AC 记录](https://www.luogu.com.cn/record/164800308)
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
bool vis[10000010];
int p[6000010],cnt,num,ans,n,x,q,k;

int main()
{
	// freopen("input.in","r",stdin);
	cin >> n;
	memset(vis,1,sizeof(vis)),vis[1] = 0;
	for(int i = 2;i <= N;i++) {if(vis[i]) p[++cnt] = i;for(int j = 1;j <= cnt && i*p[j] <= N;j++) {vis[i*p[j]] = 0;if(i % p[j] == 0) break;}}
	for(int i = 1;i <= n;i++)
	{
		int num = 0;cin >> x;
		for(int j = 1;p[j] <= x;j++)
		{
			if(x % p[j] == 0) num++;
			if(num > 2) break;
		}
		cout << (num == 2) << endl;
	}
	return 0;
}
```

---

## 作者：daitangchen2008 (赞：0)

**题意分析**

这是一道数论题。首先我们把素数求出来，然后判断输入的每个数有多少个不同的素数即可。


**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[200005];
bool prime(int x)
{
	for(int i=2;i*i<=x;i++)
		if(x%i==0)
			return false;
	return true;
}
int main()
{
	int n;
	scanf("%d",&n);
	int cnt=0;
	int y;
	for(int i=2;i<=1e5;i++)
		if(prime(i))
			p[++cnt]=i;
	while(n--)
	{
		int x;
		cin>>x;
		int ans=0;
		for(int i=1;i<=cnt;i++)
			if(x%p[i]==0)
			{
				ans++;
				if(ans>2)
					break;
			}
		if(ans==2)
			printf("%d\n",1);
		else
			printf("%d\n",0);
	}
	return 0;
}
```

---


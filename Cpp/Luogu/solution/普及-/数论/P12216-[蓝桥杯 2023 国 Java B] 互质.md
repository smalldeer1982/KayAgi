# [蓝桥杯 2023 国 Java B] 互质

## 题目描述

请计算在 $[1,2023^{2023}]$ 范围内有多少个整数与 $2023$ 互质。由于结果可能很大，你只需要输出对 $10^9+7$ 取模之后的结果。

# 题解

## 作者：b__b (赞：5)

简单数论（运用容斥原理及快速幂）。
## 容斥原理
对于有两个集合的容斥原理小图片，我们有这个公式：$|A \cup B|=|A|+|B|-|A \cap B|$。

![](https://ts1.tc.mm.bing.net/th/id/R-C.0bd2e6ed0b12244e0d080abc78d37e5c?rik=jS655D8RjgvLMA&riu=http%3a%2f%2fwww.exam8.com%2fzige%2fUploadFiles%2f201408%2f20140812153640558.png&ehk=ME6SZ20DGV2aM2axbiypoujWQHgyvjFVLXIU2%2bLh7Ec%3d&risl=&pid=ImgRaw&r=0)
## 正文
~注意到~通过质因数分解可得 $2023=7\times 17^2$。

设 $[1,2023^{2023}]$ 范围内有 $n$ 个整数，则在这个范围内可以被 $7$ 整除的数的数量为 $\lfloor\frac{n}{7}\rfloor$，可以被 $17$ 整除的数的数量为 $\lfloor\frac{n}{17}\rfloor$，既可以被 $7$ 整除又可以被 $17$ 整除的数的数量为 $\lfloor\frac{n}{7\times17}\rfloor$。

因此答案为 $n-\lfloor\frac{n}{7}\rfloor-\lfloor\frac{n}{17}\rfloor+\lfloor\frac{n}{7\times17}\rfloor$（由容斥原理可得可以被 $7$ 或 $17$ 整除的数为 $\lfloor \frac{n}{7} \rfloor+\lfloor\frac{n}{17}\rfloor-\lfloor\frac{n}{7\times17}\rfloor$，再用 $n$ 减去）。

但是 $n$ 是一个极其巨大的数，因此我们会用到快速幂。

## 代码
下列给出 Java 与 C++ 代码。
### Java
```java
public class HuZhi {
	static final long MOD = 1000000007;
	static long pw(long b, long e) {
		long r = 1;
		while (e > 0) {
			if ((e & 1) == 1) r = r * b % MOD;
			b = b * b % MOD;
			e >>= 1;
		}
		return r;
	}
	public static void main(String[] args) {
		//a为2023^2023/7,因此可以表示为(2023/7)^2023*7^2022
		//下文同理，不再给出解释
		long n = pw(2023, 2023), a = pw(7, 2022) * pw(289, 2023) % MOD, b = pw(17,  2022) * pw(119, 2023) % MOD, c = pw(119, 2022) * pw(17,  2023) % MOD;
		System.out.print((n - a - b + c) % MOD);
	}
}
```
### C++
```cpp
#include <cstdio>
typedef long long ll;
const ll MOD = 1000000007;
ll pw(ll b, ll e) {
    ll r = 1;
    while (e) {
        if (e & 1) r = r * b % MOD;
        b = b * b % MOD;
        e >>= 1;
    }
    return r;
}
int main() {
	ll n = pw(2023, 2023), a = pw(7, 2022) * pw(289, 2023) % MOD, b = pw(17,  2022) * pw(119, 2023) % MOD, c = pw(119, 2022) * pw(17,  2023) % MOD;
    printf("%lld", (n - a - b + c) % MOD);
    return 0;
}
```
答案为 $640720414$。

---

## 作者：Wzmois (赞：4)

前记：虽然算出答案了，但是不想给抄题解的人看，所以把[**提交记录**](https://www.luogu.com.cn/record/214160216)留在这里证明我 AC 了。所以只展示推演过程。
## Solution
- 判断不大于某个大整数互质的算法：欧拉函数。不曾听闻那就[**回去**](https://zhuanlan.zhihu.com/p/151756874)多补补。下面展现思路过程。
1. 分解 $2023$ 的质因数：

$$
2023=7\times17^2
$$
2. 使用欧拉函数：

$$
\varphi(2023)=2023\times(1-\dfrac{1}{7})\times(1-\dfrac{1}{17})=1632
$$
3. 所以与 $2023$ 互质的数有 $1632$ 个。
4. 于是在区间 $[1,2023^{2023}]$ 中，互质的个数：

$$
2023^{2023}\times\dfrac{\varphi(2023)}{2023}=2023^{2022}\times1632
$$
5. 最后只需使用**快速幂**计算出 $(2023^{2022}\times1632)\bmod(10^9+7)$ 即可。

---

## 作者：Yi_chen123 (赞：2)

## 前置知识

欧拉函数的表示：$\varphi(n)$\
意义：在 $[1, n]$ 区间内与 $n$ 互质的整数数量。\
计算方法：设整数 $n$ 的质因数分解形式为：

$$
n = p_1^{x_1} \times p_2^{x_2} \times \cdots \times p_k^{x_k}
$$

那么，其欧拉函数 $\varphi(n)$ 有：

$$
\varphi(n) = n(1 - \dfrac{1}{p_1})(1 - \dfrac{1}{p_2})\cdots(1 - \dfrac{1}{p_k})
$$

举个栗子：比如计算 $\varphi(18)$，首先对 $18$ 进行质因数分解：$18 = 2^1 \times 3^2$，则：

$$
\varphi(18) = 18 \times (1 - \dfrac{1}{2}) \times (1 - \dfrac{1}{3}) = 18 \times \dfrac{1}{2} \times \dfrac{2}{3} = 6
$$

而在 $[1, 18]$ 区间内，有 $1,5,7,11,13,17$ 与 $18$ 互质，因此得 $\varphi(18) = 6$ 正确。

## 思路

很明显，一道数学推理题。

求互质数的数量一般与欧拉函数密不可分，题目中，我们要求的是在 $[1,2023^{2023}]$ 区间内，与 $2023$ 互质的个数，因此我们不妨先求出 $2023$ 的欧拉函数值 $\varphi(2023)$。\
对 $2023$ 进行质因数分解，得：

$$
2023 = 7^1 \times 17^2
$$

则 $\varphi(2023)$ 的值为：

$$
\varphi(2023) = 2023 \times (1 - \dfrac{1}{7}) \times (1 - \dfrac{1}{17}) = 1632
$$

但是，~~只要你脑袋不短路~~，就能发现一个问题：$\varphi(2023)$ 求的是 $[1,2023]$ 区间内与 $2023$ 互质的整数数量，但我们要求的区间是 $[1,2023^{2023}]$，咋办？

别着急，上引理！

> **引理**：对于任意正整数 $m,n$，在区间 $[1,m]$ 内与 $n$ 互质的整数数量比例趋近于 $\dfrac{\varphi(n)}{n}$，使用算式表达即：
> $$\lim_{m\to\infty} \dfrac{\text{cnt}}{m} = \dfrac{\varphi(n)}{n}$$
>  其中 $\text{cnt}$ 代表在区间 $[1,m]$ 内与 $n$ 互质的整数数量。

**证明：**

1. 将 $[1,m]$ 区间分成若干长度为 $n$ 的完整部分，以及一个不完整的部分：
   - 完整部分：长度为 $n$，有 $t = \lfloor\dfrac{m}{n}\rfloor$ 个。
   - 不完整部分：长度为 $m\bmod n$，有 $1$ 个
2. 在这些完整部分中，每一个部分对 $n$ 取模的余数覆盖了区间 $[0,n-1]$，因此一个完整部分有 $\varphi(n)$ 个与 $n$ 互质的整数。
3. 那不完整的部分呢？我们令 $r = m\bmod n$，$\varphi(n,x)$ 代表区间 $[1,x]$ 与 $n$ 互质的整数个数，由于不完整部分对 $n$ 取模的余数仅覆盖区间 $[0,r-1]$， 因此得出：
   $$
   \text{cnt} = t\times \varphi(n) + \varphi(n, r)
   $$
   显然，$\varphi(n) \ge \varphi(n,r)$。
   那么：
   $$
   \dfrac{\text{cnt}}{m} = \dfrac{t\times \varphi(n) + \varphi(n, r)}{tn + r}
   $$
4. 当 $m$ 趋于无穷大时，$t$ 一样趋于无穷大，而 $r$ 总是保证 $r \in [0, n - 1]$，因此，误差项 $\varphi(n,r)$ 和 $r$ 对于庞大的 $t \times \varphi(n)$ 来说可以忽略不计，因此：
   $$\lim_{m\to\infty} \dfrac{\text{cnt}}{m} = \dfrac{t \times \varphi(n)}{tn}$$
    消去分子、分母的 $t$，得：
   $$\lim_{m\to\infty} \dfrac{\text{cnt}}{m} = \dfrac{\varphi(n)}{n}$$

证毕。

因此，对于区间 $[1,2023^{2023}]$，我们可以把它分成 $2023^{2022}$ 个长度为 $2023$ 的区间，且没有剩余，故最终答案为：

$$
[2023^{2022} \times \varphi(2023)] \bmod (10^9 + 7)
$$

其实这么小的指数，根本用不着快速幂（~~绝对不是因为我不会写~~），循环解决即可。

## 代码

```java
public class Main {
    public static void main(String []args) {
       long mod = 1000000007L;
	   long phi = 1632L;
	   long now = 1;
	   for(int i = 0; i < 2022; ++i){
		   now *= 2023;
		   now %= mod;
	   }
	   System.out.println(now * phi % mod);
    }
}
```

---

## 作者：ArenaBreakout78 (赞：1)

找了半天终于找到一道能交题解的~~水~~题了。

言归正传，我们直接看思路。

## 前置知识：

[欧拉函数](https://zhuanlan.zhihu.com/p/151756874)。

## 思路：

要解决这道题，我们需要使用到欧拉函数计算在区间 $\begin{bmatrix} 1, 2023^{2023} \end{bmatrix}$ 内与 $2023$ 互质的整数的个数。但是直接计算这个范围内的数肯定会超时，所以我们就需要利用数论中的**欧拉函数**和**容斥原理**了，那么废话不多说，我们直接进入正题。

## 正题：

### Step1 分解质因数：

首先，我们需要先将 $2023$ 的质因数分解，也就是：

$$
\begin{aligned}
 \ 2023 &= 7 \times 17 \times 17 \\
 &= 7 \times 17^2
\end{aligned}
$$

### Step2 求整数个数：

将 $2023$ 的质因数分解后，我们可以利用欧拉函数来求与 $2023$ 互质的数的个数，也就是：

$$
\begin{aligned}
 \ φ(2023)&=2023 \times (1 - \frac{1}{7}) \times (1 - \frac{1}{17})\\
 &= 2023 \times (\frac{6}{7}) \times (\frac{16}{17}) \\
 &= 1632
\end{aligned}
$$

所以与 $2023$ 互质的数就会有 $1632$ 个。

### Step3 求区间互质：

于是在这个区间的 $\begin{bmatrix} 1 , 2023^{2023} \end{bmatrix}$ 中，与 $2023$ 互质的个数为：

$(2023^{2023}) \times \frac{φ(2023)}{2023} =2023^{(2023 - 1)} \times φ(2023) = 2023^{2022} \times 1632$

### Step4 求最终答案：

最后用快速幂求出 $2023^{2022} \times 1632 \bmod (10^9+7)$ 就是最终答案了。

## AC CODE：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
long long ksm(long long a,long long b,long long mod){
    long long ans=1;
    a%=mod;
    while(b>0){
        if(b%2==1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        b/=2;
    }
    return ans;
}
int main(){
    long long p1=2023*(7-1)/7*(17-1)/17;
    long long p2=ksm(2023,2022,MOD);
    cout<<(p1*p2)%MOD;
    return 0;
}

```

---

## 作者：langmouren (赞：1)

# 题目解析
小于等于一个数，且与这个数互质，很容易想到欧拉函数。

因为 $2023 \mid 2023^{2023}$，所以一个数如果和 $2023$ 互质，那么它肯定和 $2023^{2023}$ 互质。

所以求在 $1$ 到 $2023^{2023}$ 中和 $2023$ 互质的数的数量，等同于求 $\varphi(2023^{2023})$。

因为欧拉函数的的性质，并且 $2023$ 可以分解出质因数 $7$ 和 $17$，我们可以做出以下转化：

$$
\begin{aligned}
\varphi(2023^{2023}) &= 2023^{2023} \times \frac{6}{7} \times \frac{16}{17} \\
&= 2023^{2022} \times 2023 \times \frac{6}{7} \times \frac{16}{17} \\
&= 1632 \times 2023^{2022}
\end{aligned}
$$

也就是我们需要计算这个数对 $10^9 +7$ 取模的值。

大指数，有取模，我们想到了什么？快速幂！

关于快速幂怎么写，可以移步[本人的快速幂题解](https://www.luogu.com.cn/article/4qpl2qji)。

## 程序实现
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int unsigned long long
#define mod 1000000007

int fast_pow(int a,int b,int p){
    int ans=1;
    while(b>0){
        if(b&1) ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}

signed main(){
    cout<<fast_pow(2023,2022,mod)*1632%mod;
    return 0;
}
```
可以计算出答案为 $640720414$。

---

## 作者：gaomingshuo (赞：1)

# 题解P12216
## 思路
利用**容斥原理**，求出小于 2023 的正整数中有多少个数与 2023 互质，即 $2023-(2023\div7+2023\div17-2023\div\left[7,17\right])=1632$（个），解释：2023 的质因数有 7 和 17，将 7 和 17 的倍数相加减去它们的公倍数就是小于 2023 的正整数中与 2023 **不互质**的数的个数，再用 2023 减去它就是小于 2023 的正整数中与 2023 **互质**的数的个数。

如果 $m$ 与 $n$ 互质，那么 **$m+n\times p$ 也与 $n$ 互质**（$p$ 是任意一个正整数）。$m$ 与 $n$ 不互质时也是同理。

那么问题就变成了：$\dfrac{1632}{2023}\times2023^{2023}$，化简后得：$1632\times2023^{2022}$，再对 $10^9+7$ 取模。

考虑到指数很大，需要使用快速幂算法并取模运算。
## [AC](https://www.luogu.com.cn/record/214463004) code

```cpp
#include<bits/stdc++.h>
using namespace std;
long mod=1e9+7;
// 快速幂函数
long fastPow(long b,long e){
    long ans=1;//初始化结果为 1，因为任何数的 0 次幂为 1
    while(e>0){
        if(e%2==1)/*如果指数为奇数*/ ans=(ans*b)%mod;//将当前结果乘以底数并对 mod 取模
        b=(b*b)%mod;//底数平方并对 mod 取模
        e/=2;//指数减半
    }
    return ans;
}
int main(){
    long b=2023,e=2022,m=1632;
    long anspow=fastPow(b,e);//2023^2022 对 mod 取模的结果
    cout<<(m*anspow)%mod/*1632*2023^2022 对 mod 取模的结果*/;
    return 0;
}
```
也可以直接输出答案：640720414。

---

## 作者：Chase12345 (赞：0)

注意到与 $2023$ 互质的数与 $2023^{2023}$ 互质，那么转化为求 $[1,2023^{2023}]$ 与 $2023^{2023}$ 互质的数的个数，即 $\varphi(2023^{2023})$。如果没有学过欧拉函数，请参考[这里](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850)。

注意到欧拉函数是积性函数，则 $\varphi(2023^{2023})=\varphi(7^{2023}) \times \varphi(17^{4046})$。根据欧拉函数的性质，对于质数 $p$，$\varphi(p^k)=p^k \times (1-\frac{1}{p})$。所以 $\varphi(7^{2023})=7^{2023} \times (1-\frac{1}{7})$，且 $\varphi(17^{4046})=17^{4046} \times (1-\frac{1}{4046})$，则所求转化为 $96 \times 7^{2022} \times 17^{4045} \bmod (10^9+7)$。使用快速幂求解。直接附上答案：$640720414$。

---

## 作者：jnxx_zhuyueqi (赞：0)

# 前言
由于本题是结论题，知道如何推导即可，我希望别人能够学会推导过程而不是一味地抄代码，所以不放代码，这里是我的 [AC 记录](https://www.luogu.com.cn/record/214549535)。
# 分析
首先，我们都知道，与 $2023$ 互质的数一定与 $2023^{2023}$ 互质。那么我们就可以将题目转化为求 $[1,2023^{2023}]$ 范围内与 $2023^{2023}$ 互质的数。

因为欧拉函数的性质，所以我们要先对 $2023$ 进行质因数分解，$2023 = 7 \times 17^2$，故 $\varphi (2023^{2023}) = 2023^{2023} \times \frac{6}{7} \times \frac{16}{17}$，经过简单计算后得到 $\varphi (2023^{2023}) = 1632 \times 2023^{2023}$，由于题目要求我们算出这个数对 $10^9+7$ 取模之后的结果，所以我们就想到快速幂计算出答案。

所以最后只要输出 $1632 \times 2023^{2023} \bmod (10^9+7)$ 即可。我们可以用快速幂来求出这个答案，当然数据这么小直接循环暴力也是可行的，实在不行你可以在电脑里的计算器上算出然后输出，最终答案为 $640720414$。

---

## 作者：yanmingqian (赞：0)

显然，如果一个数与 $2023$ 互质，它一定和 $2023^{2023}$互质。因此可以将题意转化为求 $[1,2023^{2023}]$ 范围内与 $2023^{2023}$ 互质的正整数的个数。这不就是我们 $\varphi(2023^{2023})$ 的定义吗。直接开推！

以下推导可能用到了部分欧拉函数的推论。如果你不知道欧拉函数是啥，可以去看我的全站推荐文章[数论](https://www.luogu.com.cn/article/l60ov7h3)，其中有提及。

$$
\begin{aligned}
\varphi(2023^{2023})
&=\varphi(7^{2023})\times\varphi(17^{2023\times2})\\
&=(7^{2022}\times(7-1))\times(17^{4045}\times(17-1))\\
&=96\times7^{2022}\times17^{4045}
\end{aligned}
$$

然后直接快速幂就好。

代码：

```cpp
#include<iostream>
using namespace std;
#define int long long
const int mod=1e9+7;
int ksm(int a,int b){
    int ans=1;
    while(b){
        if(b&1){
            ans=(ans*a)%mod;
        }
        a=(a*a)%mod;
        b>>=1;
    }
    return ans;
}
signed main(){
    cout<<96*ksm(7,2022)%mod*ksm(17,4045)%mod;
    return 0;
}
```

---


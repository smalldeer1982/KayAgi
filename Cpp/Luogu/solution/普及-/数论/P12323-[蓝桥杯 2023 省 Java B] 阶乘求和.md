# [蓝桥杯 2023 省 Java B] 阶乘求和

## 题目描述

令 $S = 1! + 2! + 3! + \cdots + 202320232023!$，求 $S$ 的末尾 $9$ 位数字。

提示：答案首位不为 $0$。

# 题解

## 作者：weifengzhaomi (赞：3)

## 题意 & 化简

这道题要我们求，从 $1$ 的阶乘一直加到 $202320232023$。

## 思路 1.0

这道题数据非常大，所以我们考虑高精度，用 $1998$ 年普及组阶乘之和的做法，来写此题，数组开到 $10 ^ 8$ 差不多就够了。

## 思路 2.0

高精度也许能过此题，但是极其麻烦，甚至还有超时的风险，所以，我们要想一种方法来解决。

首先，为了使计算量少，我们肯定希望 $2$ 和 $5$ 越多越好，这样 $0$ 就越多。

于是，我们可以贪心一下，我们希望的是有一个数的阶乘，后面 $9$ 位都是 $0$，而且，某个数后九位是 $0$，比他大的数的阶乘不会后九位不是 $0$。所以，我们只要先求出最小的、后九位是 $0$ 数即可。

在纸上求质因数发现，只要到 $40$ 的阶乘所产生的 $0$ 就大于 $9$ 了，因为 $40$ 的阶乘所相乘的每一个数字分解质因数后 $2$ 和 $5$ 都**严格大于等于** $9$ 个。

所以，我们可以枚举 $1$ 到 $39$，来记录阶乘的和，并且要在过程中取模 $10 ^ 9$。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,f = 1;
const long long P = 1e9;
int main(){
	for (int i = 1;i <= 39;i++){
		f = (f * i) % P;// 这里有个小技巧，每一个阶乘都是前一个乘i，这样还省了一个log时间复杂度。
		ans += f;
		ans %= P;
	}
	printf("%lld\n",ans);
}
```


## 思路 3.0

这道题我们可以手算，只要不嫌麻烦，可以根据上面的思路来一步一步计算，只要不算错，就可以了，算出来取模 $10 ^ 9$ 的结果为 $420940313$。

### 代码：

```cpp
#include<bits/stdc++.h>
int main(){printf("420940313");}
```

---

## 作者：JIN_LONG (赞：2)

## 解题思路：
对于 $n \ge 40$，$n!$ 的末尾至少有 $9$ 个零（因为 $40!$ 包含足够多的因子 $2$ 和 $ 5$），因此 $n!$ 对 $10^9$ 取模的结果为。

- 这意味着只需计算 $1!$ 到 $39! $ 的和，再对 $10^9$ 取模即可。
- 所以，我们只需要循环 $39$ 次即可，一边计算，一边取模。
## 代码：

```
#include <bits/stdc++.h>//万能头 
using namespace std;
const long long mmod=1e9;
int main(){
    long long sum=0,a=1;//不开long long见祖宗。 
    for(int i=1;i<=39;i++){
        a=(a*i)%mmod;
        sum=(sum+a)%mmod;
    }
    cout<<sum;
    return 0;//养成好习惯。 
}
```

---

## 作者：tengteng666666 (赞：2)

### 思路：
- 众所周知，阶乘大到一定程度时，由于因子中有很多 $2$ 和 $5$，所以会包含很多个因子 $10$。这会导致阶乘末尾出现很多 $0$。
- 经过计算，当要求阶乘的数 $n\ge40$ 时，阶乘末尾的 $0$ 个数会达到 $9$ 个以上。
- 也就是说，只用计算 $1$ 到 $39$ 的阶乘即可。由于结果过大，需要取余。
### 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
const int MOD = 1e9;//末尾9位数字 
using namespace std;
int ans = 0; 
signed main(){
	for(int i = 1;i<=39;i++){
		int sum = 1;//i的阶乘 
		for(int j = 1;j<=i;j++){
			sum *= j;
			sum %= MOD;
		}
		ans += sum;
		ans %= MOD;
	}
	cout<<ans;
	return 0;	
} 
```

---

## 作者：ArenaBreakout78 (赞：2)

# 题解：P12323 [蓝桥杯 2023 省 Java B] 阶乘求和

~~大水题。~~

言归正传，我们直接进入正题。

## 思路：

首先，我们不难发现从 $1$ 的阶乘一直加到 $202320232023$ 的阶乘，直接存下是完全不可能的，所以我们只能找规律。经过了我一段时间的思考后（半小时），我们不难发现当 $n \ge 40 $ 的时候，$n!$ 末尾始终会有 $9$ 个零（因为有足够多的因子 $2$ 和 $5$）。

但是，我们在计算阶乘之和时，每一步得出的结果都需要进行 $sum \bmod 10^9$（防止数值过大，$sum$ 代表每一步得出的结果），于是，我们就成功做出了这道大水题。

## AC CODE：


```cpp
#include <bits/stdc++.h>
using namespace std;
const long long MOD=1e9;
int main(){
    long long sum=0;
    long long f=1;
    for(int i=1;i<=39;i++){
        f=(f*i)%MOD;
        sum=(sum+f)%MOD;
    }
    cout<<sum;
    return 0;
}

```

---

## 作者：Hongfr (赞：2)

我们需要计算出以下带有阶乘的式子的末尾 $9$ 位数字：

$$S=1!+2!+3!+…+202320232023!$$ 

也就是求 $S \bmod 10^9$，这便是纯数论题了，因为你要用高精解决这道问题明显不合适。

### 寻找规律
对于求 $n!$，当 $n\ge5$ 的时候，就会出现末尾是 $0$ 的情况。因为 $n!$ 中，包含着若干个因子 $2$ 和若干个因子 $5$ 。那会不会有一个范围，使得 $n!$ 的末尾会有 $9$ 个 $0$，即 $n! \bmod 10^9=0$？

这里插入一个公式，在计算 $n!$ 中因子 $5$ 的个数可以用一下公式计算（$\lfloor x \rfloor$ 意为对 $x$ 进行向下取整）：

$$count=\lfloor\frac{n}{5}\rfloor+\lfloor\frac{n}{5^2}\rfloor+\lfloor\frac{n}{5^3}\rfloor+…$$

举个一般的例子，当 $n\ge 25$ 时，$n!$ 中至少包含有 $6$ 个因子 $5$，因子 $2$ 只会被因子 $5$ 的个数更多，而 $10^6=2^6\times5^6$，所以 $n! \bmod10^6=0$。

再看题目，我们要求到 $202320232023!$，我们是否可以利用以上的方法，缩小本题计算的范围，那接下来的目标就是寻找到 $n$ 使得 $n! \bmod 10^9=0$。

### 缩小计算范围
我们需要寻找的 $n$ 应满足 $n!$ 至少有 $9$ 个因子 $5$ ，则 $count=\lfloor\frac{n}{5}\rfloor+\lfloor\frac{n}{5^2}\rfloor+\lfloor\frac{n}{5^3}\rfloor+…$ 的值的和至少就是 $9$。

通过枚举每个 $5$ 的倍数，找到 $n=40:count=8+1=9$。

因此，对于 $n\ge40$，$n! \bmod 10^9=0$。

### 利用计算机计算

题目已经可以简化到 $1!+2!+3!+…+39!$ 了，但对于笔算来说还是十分的难，但参赛选手可以使用高精算法写出 $1!+2!+3!+…+39!$，这里我附上高精算法的题目，不懂高精算法的可以阅读一下[P1009 \[NOIP 1998 普及组\] 阶乘之和](https://www.luogu.com.cn/problem/P1009)的题解。

此处再提供一个简化思路，可以**不使用高精算法**，当我们计算到 $13! = 6227020800$ 时，因为 $6227020800\ge10^9$，所以我们可以先取模，即 $13! \bmod 10^9=227020800$，紧接着计算 $14!=13!\times14$ 的时候，我们可以使用 $(227020800\times14)\bmod 10^9$ 来计算 $14!$ 的后 $9$ 位数字，本次计算阶乘时，再用一个长整形的求和变量进行累加。这里的累加同理，每加一个数就可以取模  $10^9$，对结果时不会有影响的。

### 最终结果
如果上述过程没有任何问题，那很容易（bushi）就得到：

$$S\bmod10^9=420940313$$

因此，$S=1!+2!+3!+…+202320232023!$ 的末尾 $9$ 个数字是 $\huge 420940313$。

---

## 作者：封禁用户 (赞：2)

## P12323 题解：

思路，思考得出 $45$ 的阶乘的尾数就是答案，所以只需要枚举 $1$ 到 $45$ 就可以得出答案，每次更新一下阶乘 $(fact \times n)\bmod10^{9}$ 和 $(S+fact)\bmod10^{9}$。

## [AC](https://www.luogu.com.cn/record/214898168) 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MOD = 1000000000;
int main() {
    long long S = 0,fact = 1;
    for (int n = 1; n < 45; ++n) {
        fact = (fact * n) % MOD;
        S = (S + fact) % MOD;
    }
    cout<<S<<endl;
    return 0;
}
```

---

## 作者：Aurelia_Veil (赞：1)

# 题解：P12323 \[蓝桥杯 2023 省 Java B] 阶乘求和

看似很难，实际很~~难~~简单。

首先，题目让我们只求出末尾 $9$ 位，所以 $n!$ 末尾有 $9$ 个及以上的 $0$ 的就可以不用参与运算了。

那什么时候末尾会出现**一个** $0$ 呢，因为 $2 \times 5 = 10$，所以只需要偶数和 $5$ 的奇数倍数与 $10$ 的倍数总共出现了 $9$ 对，就可以不用参与计算了。我手算了一下，是 $40$。

所以我们只用算出 $1$ 到 $39$ 的阶乘和即可，**记得取余**。

代码如下咩：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9;
int main(){
	long long ans=0;
	long long top=1;
	for(int i=1;i<=39;i++){
		top=(top*i)%mod;
		ans+=top;
		ans%=mod;
	}
	printf("%d",ans);
}
```

---

## 作者：shy_lihui (赞：1)

答案就是求最后的数模 $10^9$，注意到 $40!$ 含有因子 $10^9$，也就是说 $40 \sim 202320232023$ 的阶乘都是 $10^9$ 的倍数。一取模直接就没了，所以答案直接等于 $\sum_{i=1}^{39}i!$。边乘边取模即可。

关于 $40!$ 含有因子 $10^9$ 的证明：结尾出现一个 $0$ 需要质因子 $2$ 和 $5$，$2$ 显然够用，$0$ 的个数取决于 $5$ 的个数。$40!$ 中有 $9$ 个质因子 $5$，所以是 $10^9$ 的倍数。

扩展一点 $n!$ 的质因子 $k$ 的数量为：

$$
\sum_{i=1}^{\infty} \lfloor  \frac{n}{k^i} \rfloor

$$

- java
```java
public class Main
{
    private static final long MOD=1000000000L;

    private static long jc(int x)
	{
        if(x==1)
		{
            return 1;
        }
        return jc(x-1)*x%MOD;
    }
    public static void main(String[] args)
	{
        long ans=0;
        for(int i=1;i<=39;i++)
		{
            ans=(ans+jc(i))%MOD;
        }
        System.out.println(ans);
    }
}
```
- c++

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=1e9;
int jc(int x)
{
	if(x==1)
	{
		return 1;
	}
	return jc(x-1)*x%MOD;
}
int ans;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	for(int i=1;i<=39;i++)
	{
		ans+=jc(i);
		ans%=MOD;
	}
	cout<<ans;
	return 0; 
}
```

---

## 作者：htl2025 (赞：1)

## 思路：
阶乘中包含因子 $2$ 和 $5$ 的数量决定其末尾有多少个 0。每多一对 $(2, 5)$ 就多一个 $0$。我们要找的是从哪里开始，每一项 $n!\bmod10^9$ 都为 $0$。

对于任意整数 $n$，其阶乘末尾 0 的个数是：
$$\left\lfloor \frac{n}{5} \right\rfloor + \left\lfloor \frac{n}{25} \right\rfloor + \left\lfloor \frac{n}{125} \right\rfloor + \cdots$$
只要这个值 $\le 9$，那么 $ n!\bmod10^9=0$。

通过计算，从 $40!$ 开始，每项的值 $ n!\bmod10^9=0$ ，不再对最终结果有贡献，因此可以提前终止循环以加速计算。
```cpp
#include<iostream>
using namespace std;
int main()
{
    int s = 0, f = 1;
    for (int i = 1; i < 40; ++i) {
        f = 1LL * f * i % 1000000000;
        s = (s + f) % 1000000000;
    }
    cout << s;
}
```

---

## 作者：kuaiCreator (赞：0)

## 解题思路
显然直接算数字很大，考虑到阶乘很大时，后面 $9$ 位全是 $0$，因此可以写个简单的程序看看大概多少的阶乘末尾 $9$ 位都是 $0$。结果大概 $30$ 至 $50$ 之间。非常的小。直接模拟边算边模即可。
## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
long long s = 0, jc = 1;
long long MOD = 1e9;
int main() {
	for (int i = 2; i <= 50; i++) {
		s = (s + jc) % MOD;
		jc = (jc * i) % MOD;
	}
	cout << s;
	return 0;
}
```

---

## 作者：zhz_cptbtptp (赞：0)

题目看起来很恐怖，从 $1$ 的阶乘加到 $202320232023$ 的阶乘，~~怎么想都做不到吧~~，其实不然题目告诉了我们一个**非常非常**重要的条件，**求末尾九位数字**并且**答案首位不为零**。

大家可以想一想什么时候一个数的阶乘末尾会有零，当然是在有**足够多的二和五的因子**时，比如五的阶乘，就有一个二和一个五，推出这里后，剩下的就很简单了。

我们通过推公式可以得到，当 $n$ 大于四十后，他的阶乘的末尾一定有九个零（原因，$40!$ 可以分解出 $10\times20\times30\times40\times2\times5\times4\times25\times6\times15\times8\times35$，就会有 $9$ 个 $0$ ）。

话不多说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,jc,mod=1e9;//因为只需要末尾九位，所以每一次计算都对结果取模
int main() {
	for(int i=1;i<=40;++i){
		jc=1;//存每一次的阶乘
		for(int j=1;j<=i;++j){
			jc=(jc*j)%mod;
		}
		ans+=jc;//求阶乘的总和
		ans%=mod;
	}
	cout<<ans;
	return 0;
}
```
华丽的结束。

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
数据超级大，模拟显然不行。手搓几个数发现，数据里每有一对二和五，末尾就多一个零。易得，过若干个数后后九位全为零，对答案无影响。

口算得到 $40$ 后九位均为零。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a=1,p=0,mod=1000000000;
int main(){
    for(int i=1;i<=40;i++){
        a*=i;
        a%=mod;//阶乘
        p+=a;
        p%=mod;//和
    }
    cout<<p;//答案
    return 0;
}
```

---


# 排版

## 题目背景

某兄弟学校就是这么良(sang)心(xin)温(bing)暖(kuang)，国庆节作业写了满满一黑板，连信息技术都有作业！更过分的是，作业就是做一个“国庆旅游计划”PPT。（老师，您能再假一点吗）


## 题目描述

然而，XHY同学并不会做PPT，于是她找到了CYD大神求助。她想把N张4\*3的照片不重叠，无缝隙地拼成一个矩形作为背景图片。为了美观，她希望背景图片的长与宽尽可能接近，并且在长宽均相等的情况下，使得旋转的照片张数尽可能少。（4\*3的不算旋转，3\*4的算作旋转，且照片只能有这两种尺寸）。

请你帮CYD大神写一个程序，帮XHY同学设计一种满足她要求的照片排列方式，使得旋转的照片张数最少。


## 说明/提示

对于20%数据，N<=10。

对于30%数据，N<=20。

对于50%数据，N<=50。

对于70%数据，N<=233。

对于100%数据，N<=900。


## 样例 #1

### 输入

```
6```

### 输出

```
0```

## 样例 #2

### 输入

```
7```

### 输出

```
3```

# 题解

## 作者：newbeeglass (赞：8)

一开始以为这是一道找规律的题，后面发现 $n\le900$ ，所以想到了枚举。

大矩形的面积一定为 $12n$ ，所以可以先枚举一条边，再定另一条边。具体枚举的方式如下：

因为要找两边最接近的，那就从正方形开始，也就是从 $i=\sqrt{n}$ 开始，一直减到 $3$ ，因为首先要满足边接近，所以此时第一个找到的符合题意的答案就是最终答案，直接 break 就好了。

我们可以先定一条边为 $a$ ，另一条边为 $b$ ，因为都为整数，且 $a\times{b}=12n$ ，所以 $a$ 和 $b$ 中要么一个是 $12$ 的倍数，要么一个是 $3$ 的倍数，另一个是 $4$ 的倍数，所以我们可以先定一条边比如 $a$ 是 $3$ 的倍数，那么 $b$ 就可以分解为 $4x+3y$ ，此时就又可以通过枚举的方式判断 $b$ 是否合法存在（ $x$ 和 $y$ 都是整数）。

全部判断合法后，开始记录旋转照片的数量。前面我们已经将 $b$ 分解为 $4x+3y$ ，如果 $b$ 作为纵向边，那么一列上旋转过的矩形就有 $x$ 个，可以自行模拟一下，每列纵向摆放的矩形数量都是一样的，所以最终旋转的矩形数为 $\frac{ax}{3}$ ，当 $a$ 为纵向边时，旋转数与前者相加一定正好等于总数 $n$ ，是 $n-\frac{ax}{3}$ 。
### AC code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int ans=0x3f;
	int n;
	bool flag=0;
	cin>>n;
	int s=sqrt(12*n);//从s开始枚举 
	for(int i=s;i>=3;i--){
		if((12*n)%i==0){//i肯定是整数，保证另一边是整数再进行运算 
			int a,b;
			if(i%3==0){
				a=i;
				b=(12*n)/i;
			}
			else{
				b=i;
				a=(12*n)/i;
			}
			for(int j=0;j<=b/4;j++){
				if((b-4*j)%3==0){//保证其为整数 
					ans=min(ans,j*a/3);
					ans=min(ans,n-j*a/3);//由于我只将a作为3的倍数的边，所以两种情况都要判断
					flag=1; 
				}
			}
		}
		if(flag){
			break;//找到的就是边长最接近的，直接break 
		}
	}
	cout<<ans;
	return 0;//养成好习惯 
}

```


---

## 作者：Untitled_unrevised (赞：5)

最终的矩形面积为 $12N$ ，题目要求长和宽尽可能接近。

我们令其中一条边为 $a$ ，然后 $a$ 从 $\sqrt{12N}$ 到 $1$ 一个个枚举过去， 直到找到一个 $a$ 使得 $a$ 和 $\frac{12N}{a}$ 都是整数。设另一条边为 $b=\frac{12N}{a}$ ， 显然 $ab$ 必为 $12$ 的倍数。

两种情况：

① $a$ 和 $b$ 一个是 $4$ 的倍数，另一个是 $3$ 的倍数。

显然所有的照片全部朝同一个方向排就可以了。此时旋转的照片数量可以为 $0$ 。

② $a$ 和 $b$ 一个是 $12$ 的倍数，另一个与 $12$ 互质。（不妨设 $b$ 是与 $12$ 互质的数，如果不是调换 $a$ 和 $b$ 的值即可）

设 $b=4x+3y$ ，令 $b$ 为最终矩形的纵边长，那么有 $x$ 行旋转的照片，总数为 $\frac{ax}{3}$ 。将该方案旋转一下就得到了有 $N-\frac{ax}{3}$ 张旋转照片的方案。

由于 $N$ 最大只有 $900$ ，讨论 $x$ 的过程可以直接暴力枚举，然后找出所有的 $\frac{ax}{3}$ 和 $N-\frac{ax}{3}$ 里面最小的值即可。

代码：

```cpp
#include <cmath>
#include <cstdio>

int main() {
	int N;
	scanf("%d", &N);
	int area = 3 * 4 * N;
	for(int a = std::sqrt(area); a > 0; --a) {
		if(area % a == 0) { //find
			if(a % 4 == 0 && (area / a) % 3 == 0) {
				puts("0");
				return 0;
			}
			else if(a % 3 == 0 && (area / a) % 4 == 0) {
				puts("0");
				return 0;
			}
			else {
				int b;
				if(a % 12 != 0) {
					a = area / a;
				}
				b = area / a;	//then a must be 12*L, b should be 4x + 3y style. xxxxyyy
				int minn = 0x7fffffff;
				for(int x = 1; 4 * x < b; ++x)
					if((b - 4 * x) % 3 == 0) {
						int cnt = (a / 3) * x;
						minn = (minn > cnt) ? cnt : minn;
						minn = (minn > (N - cnt)) ? (N - cnt) : minn;
					}
				printf("%d", minn);
				return 0;
			}
		}
	}
	return 0;
}
```


---

## 作者：_wjr_ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P4904)

### 解题思路

由于每张照片的大小是恒定的，所以总面积也是固定的 $12N$。又因为 $n \le 900$，所以这题的主要思想还是枚举暴力。

首先的要求是要整个矩形的长和宽尽量接近，因为面积是知道的，所以最接近的长和宽也能通过枚举得到。

然后的要求便是要让旋转的照片个数最少。不妨设一边为 $a$，一边为 $b$，这时我们便可以分为以下情况进行讨论：

1. $a , b$ 中一个是 $4$ 的倍数，另一个是 $3$ 的倍数，这样无需旋转任何图片，输出 `0`。
2. $a , b$ 中一个是 $12$ 的倍数，一个既不是 $3$ 的倍数也不是 $4$ 的倍数（否则为第一种情况）。那这样的话，不妨设 $a$ 是 $12$ 的倍数，则 $b$ 一定可以表示为 $4x + 3y$ 的形式。证明略。则，旋转的照片的照片为 $\dfrac{a\cdot x}{3}$ 或者 $n - \dfrac{a\cdot x}{3}$，即 $\dfrac{a\cdot y}{4}$。我们只需要找出所有满足 $b$ 为 $4x + 3y$ 的形式，即可找出需要旋转的照片的最小值。

~~完结撒花！~~

### AC Code

```cpp

#include<bits/stdc++.h>

using namespace std;

int main()
{
    int n, c;
    cin >> n;
    int S = 12 * n;
    for (int i = sqrt (S); i >= 3; i--)//计算在何情况下长与宽尽量接近
        if (S % i == 0) 
        {
            c = i;
            break;
        }
    int a = c, b = S / c;
    if ((a % 4 == 0 && b % 3 == 0) || (a % 3 == 0 && b % 4 == 0))
    //一个是3的倍数，另一个是4的倍数，无需旋转任何照片，直接输出0
    //这里曾有人，写的是 a % 4 == 0 || a % 3 == 0 而一直拿80分，警钟长鸣
    {
        cout << 0;
        return 0;
    }
    else
    {
        if (a % 12 != 0) swap (a, b);//让a为12的倍数
        int mn = 2000000000;
        for (int i = 0; i <= b / 4; i++)//计算最少的照片旋转数
            if ((b - i * 4) % 3 == 0)
            {
                int x = i, y = (b - i * 4) / 3;
                mn = min (mn, min (a * x / 3, a * y / 4));
            }
        cout << mn;
        return 0;
    }
    return 0;
}
```
现在，我们终于可以撒花了。

---

## 作者：X_SpiderMan (赞：2)

来自前人的警示：这道题先看数据范围，再看题面。

大家应该都会注意到 $100\%$ 的数据中 $n\le900$。

那一目了然：暴力枚举即可。

### 思路：
首先我们得出 $S_\texttt{矩阵} = 12N$。我们可以采用逐边枚举的方式进行枚举。知道了枚举方式，为了确保两边尽量接近，大家肯定知道两边最接近的矩阵为正方形。也就是说从 $i=\sqrt{n}\to3$ 时第一个符合题意的答案就是最终答案。

### CODE:
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,ans=0x3f3f3f,n,s;
bool flag;
int main(){
	cin>>n; s=sqrt(12*n);
	for(int i=s;i>=3;i--){
		if((12*n)%i==0){
			if(i%3==0) a=i,b=12*n/i;
			else b=i,a=12*n/i;
			for(int j=0;j<=b/4;j++)
				if((b-4*j)%3==0){
					ans=min(ans,min(j*a/3,n-j*a/3));
					flag=1; 
				}
		}
		if(flag){
            cout<<ans;
            return 0;
        }
	}
}
```

---

## 作者：一只绝帆 (赞：2)

## 题面[P4904](https://www.luogu.com.cn/problem/P4904)

首先根据题意，易得 $S=12n$。

为了保证**矩形两边尽量接近**，我们将一边 $a$ 从 $\sqrt{S}$ 向 $1$ **枚举**，则另一边 $b$ 为 $\frac{S}{a}$，这样枚举到的第一组**整数**对 $(a,b)$ 就是所求方案的长宽。

由于 $S$ 为 $12$ 的倍数，其中一边必然为 $3$ 的倍数，不妨假设 $a$ 为这一边，然后我们将 $b$ 拆分成 $4j+3k$。
1. 如果 $b$ 为纵边，每列旋转的矩形共有 $j$ 个，整个图共有 $\frac{aj}{3}$ 个。

2. 如果 $b$ 为横边，则原来非旋转的变为旋转的，旋转的变为非旋转的，整个图旋转的矩形有 $n-\frac{aj}{3}$ 个。

因为 $n$ 很小，拆分的过程可以直接枚举 $j$，然后在 $k$ 为整数的前提下取 $ans=\min(ans,\text{旋转的矩形})$。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tmp,ans=0x7f7f7f7f;
int main()
{
	cin>>n;
	tmp=sqrt(12*n);
	for(int i=tmp;i>=1;i--)//i一边 (12*n)/i另一边
	{
		if((12*n)%i!=0) continue;//保证另一边为整数
		int a=i,b=(12*n)/i;
		if(a%3!=0) swap(a,b);
		for(int j=0;4*j<=b;j++)//把b拆成4*j+3*k
		{
			if((b-4*j)%3!=0) continue;//保证k为整数
			ans=min(ans,j*a/3);
			ans=min(ans,n-j*a/3);
		}
		break;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Jasonshan10 (赞：1)

[题目传送](https://www.luogu.com.cn/problem/P4904)

### Part1：题意

本题题意十分简单。

题目所求为 $n$ 张尺寸为 $4 \times 3$ 的照片没有重叠、无缝隙拼成一个长和宽尽可能相等的长方形（正方形）。

$4 \times 3$ 的不算旋转，$3 \times 4$ 的算作旋转时最小的旋转次数。

###  Part2：思路

准确的说，本蒟蒻第一次做这题时认为这是一道找规律的题，但是发现，我根本不会做啊！

于是我去看了一下题目的数据范围，惊喜的发现：

对于 $100\%$ 的数据，$1\le n \le 900$。

$n$ 在这个范围内，所以普通暴力 $O(n^2)$ 都是随随便便能过的，于是这道题就是一道暴力枚举题。

首先根据题意，便可以得出长方形的面积 $S=12n$。

我们为了保证长方形的长和宽尽可能的相近，那么我们就从正方形开始，令 $m=\sqrt n$，一直减，减到 $3$。

我们首先要满足边接近，所以按照此方法找到的第一个找到的符合题意的答案就是最终答案，直接输出就行了。

我们定义两条边，$x,y$，因为 $x,y$ 都是整数，所以满足我们之前得出的公式，即 $x \times y=12n$。

接下来分为两种情况：

1. $x$，$y$ 中的一个是 $12$ 的倍数。

2. $x$，$y$ 中又一个是 $3$ 的倍数，另一个是 $4$ 的倍数。

我们考虑 $3 \mid x$ 的情况，根据公式，此时 $y=\frac{12n}{a}$，根据题意便可知存在两个整数 $a,b$，满足 $3a+4b=y=\frac{12n}{x}$。

枚举 $a$，若与其相对应的 $b$ 为正整数则合法，我们可以更新答案。

而对于 $4\mid a$ 的情况则同理。

若我们找到了合法的 $a$，$b$，则有以下两种情况：

1. $x$ 为纵向边，此时旋转的数量为 $12-\frac{x}{3} \times a$。

2. $y$ 为纵向边，此时旋转的数量为 $\frac{x}{3} \times a$。

将上面两种情况取 $\min$ 即可。

### part3 Code：

[提交记录](https://www.luogu.com.cn/record/117648084)


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXX=1e9+7;
signed main(){
	int ans=MAXX;
	int n,flag=0,m,x,y;
	scanf("%d",&n);
	m=sqrt(12*n);
	for(int i=m;i>=3;--i){
		if((12*n)%i==0){
			if(i%3==0){
				x=i,y=(12*n)/i;
			}
			else{
				x=(12*n)/i,y=i;
			}
			for(int j=0;j<=y/4;++j){
				if((y-4*j)%3==0){
					ans=min(ans,min(j*x/3,n-j*x/3));
					flag=1; 
				}
			}
		}
		if(flag==1){
			printf("%d\n",ans);
			return 0;
		}
	}
	return 0;
}
```



---

## 作者：Gaogao2011 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4904)


------------

### 题意

把 $n$ 张尺寸为 $4 \times 3$ 的照片**不重叠**且**无缝隙**地拼成**长和宽尽可能接近的矩形**。求最少旋转次数。

### 思路

$\because$ 最终矩形的面积为 $12n$。

$\therefore$ 令矩形其中一条边为 $a$，则另一条边 $b$ 为 $\frac{12n}{a}$。

$\therefore$ $ab$ 为 $12$ 的倍数。

设 $b = 4x + 3y$，$x$ 行旋转的照片的总数为 $\frac{ax}{3}$，该方案旋转后得到有 $n - \frac{ax}{3}$ 种旋转方案。

由于 $n \leqslant 900$，枚举找出所有 $\frac{ax}{3}$ 和 $n - \frac{ax}{3}$ 中的最小值即可。

### 代码

AC Code.

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int small(int x, int y) {
	return x > y ? y : x;
}
int main() {
	int n, a, b, min = 2e9;
	bool flag = false;
	scanf("%d", &n);
	for (int i = sqrt(12 * n); i >= 3; i--) {
		if (12 * n % i) continue;
		if (i % 3 == 0) a = i, b = 12 * n / i;
		else a = 12 * n / i, b = i;
		for (int j = 0; j <= b / 4; j++) {
			if ((b - 4 * j) % 3 == 0) {
				min = small(small(min, j * a / 3), n - j * a / 3);
				flag = true;
			}
		}
		if (flag == true) break;
	}
	printf("%d", min);	
	return 0;
}

```


---

## 作者：zk_y (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4904)

我们看一下这道题目。

首先的要求是需要找出最后组成的矩形的长和宽。因为这个矩阵的面积 $S$ 一定在 $12N\le 12\times 900=10800$ 之内，所以直接暴力枚举长和宽就可以了。

现在我们来考虑第二个要求：

> 帮XHY同学设计一种满足她要求的照片排列方式，使得旋转的照片张数最少。

我们怎么满足这个呢？

我们可以分情况考虑：（在这里我们设两条边是 $X$ 和 $Y$）

如果说 $X$ 和 $Y$，一个是 $4$ 的倍数，另一个是 $3$ 的倍数。那么，我们就知道这样的矩形是一个都不用调整的。

那么如果不是这种情况呢？

我们知道如果有一条边不是 $3$ 或 $4$ 的倍数，那么这条边一定不是 $12$ 的倍数。但是我们整体矩形的面积却是 $12$ 的倍数。因为有 $XY=S=12N$，而其中 $X$ 不是 $12$ 的倍数（假设一下），那么我们就可以得出 $Y$ 一定是 $12$ 的倍数，而 $X$ 可以写成形如 $X=3x+4y$。我们设 $x$ 是在 $X$ 边上为 $3$ 的矩形的数量。设 $y$ 是在 $X$ 边上为 $4$ 的矩形的数量，其中 $x,y\ne 0$。

因为 $X$ 数据范围也不大，那我们就直接暴力枚举 $x$ 和 $y$ 的值就可以了。

我这里的代码比较麻烦，有一些重复的代码，请大家不要抄袭！

---
# AC 代码
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int n;
int y,x;
int main(){
	scanf("%d",&n);
	n*=12;
	for(int i=(int)sqrt(n);i>=1;i--){
		if(n/i*i==n){
			y=n/i,x=i;
			if(x%4==0&&y%3==0){//x是4的倍数，y是3的倍数
				printf("0");
				return 0;
			}
			if(y%4==0&&x%3==0){
				printf("0");
				return 0;
			}
			break;
		}
	}
	if(x%12==0){//是12的倍数
		int minn=1e9;
		for(int i=1;i<=y/4;i++){//每次枚举y
			if((y-i*4)%3==0){
				minn=min(minn,min(x/3*i,x/4*(y-i*4)/3));//取最小值
			}
		}
		printf("%d",minn);
		return 0;
	}
	if(y%12==0){
		int minn=1e9;
		for(int i=1;i<=x/4;i++){
			if((x-i*4)%3==0){
				minn=min(minn,min(y/3*i,y/4*(x-i*4)/3));
			}
		}
		printf("%d",minn);
	}
	return 0;//结束！
}
```


---

## 作者：xhz0311 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4904)
## 思路分析
数据范围很小，可以直接枚举。

由于有 $n$ 张照片，每张照片为 $3\times4$，故总面积为 $12n$。设一边长为 $a$，一边为 $b$，则 $ab=12n$。

由于边长都是整数，可知 $a$ $b$ 中：
1. 一个是 $12$ 的倍数；
2. 一个是 $3$ 的倍数，一个是 $4$ 的倍数。

考虑 $3\mid a$（整除）时的情形，此时 $b=\dfrac{12n}{a}$。由题意知存在两个正整数 $x$ $y$，满足 $3x+4y=b=\dfrac{12n}{a}$。枚举 $x$，若 对应的 $y$ 为正整数则合法，可以记录并更新答案。

$4\mid a$ 时的情形同理。

若我们找到了合法的 $x$ $y$，则分类如下：
1. $b$ 为纵向边，此时旋转的数量为 $\dfrac{a}{3}\times x$；
1. $a$ 为纵向边，此时旋转的数量为 $12-\dfrac{a}{3}\times x$。

取其较小者即可。

## 代码
```
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n,a,b,ans=2147483647;
	bool flag=0;
	scanf("%d",&n);
    //下方 for 枚举 a 的取值
	for (int i=sqrt(12*n); i>= 3; i--)//需要尽可能接近正方形
    {
		if (12*n%i！=0)//判断当前枚举到的 a 的取值是否合法
        {
        	continue;//不合法
        }
		if (i%3==0)//合法的取值，3|a
        {
        	a=i;
            b=12*n/i;
        }
		else//4|a
        {
        	a=12*n/i；
            b=i;
        }
		for (int j=0; j<=b/4; j++)//枚举 x 的取值
        {
			if ((b-4*j)%3==0)//y 是正整数
            {
				ans=min(min(ans,j*a/3),n-j*a/3);
				flag=1;
			}
		}
		if (flag)//找到了解
        {
        	break;
        }
	}
	printf("%d", ans);	
	return 0;
}
```

注意从 $\sqrt{12n}$ 开始枚举 $a$，因为要最接近正方形。

---


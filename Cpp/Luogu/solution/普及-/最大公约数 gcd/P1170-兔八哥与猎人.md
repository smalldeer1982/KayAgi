# 兔八哥与猎人

## 题目描述

兔八哥躲藏在树林旁边的果园里。果园有 $M  \times  N$ 棵树，组成一个 $M$ 行 $N$ 列的矩阵，水平或垂直相邻的两棵树的距离为 $1$。兔八哥在一棵果树下。

猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。

如果猎人与兔八哥位置的连线上没有其它的果树，猎人就可以看到兔八哥。

现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全。

## 说明/提示

$1\le n \le 10^5$，$1 \le  a_x, a_y, b_x, b_y \le  10^8$。

## 样例 #1

### 输入

```
1
1 1
1 2```

### 输出

```
no```

# 题解

## 作者：beng (赞：145)

# 有陷阱！

第一眼看这道题时，估计很多人与我也一样认为只应判断兔八哥周围八个格（如下图A与B,A与C的关系）是否存在猎人，然而事实并非如此！！！（你们想太少了）

 ![](https://cdn.luogu.com.cn/upload/pic/3807.png) 

1. 如图，我们可以很直观的看出其实若猎人在E、F，可怜的兔八哥A可谓在劫难逃，所以我们发现猎人的合理站位不局限于兔八哥周围八个格。

2. 如图，我们还能知道若猎人在D、G两点兔八哥是安全的，所以我们便要拿这两个点开刀（并与C、E做对比）。

3. 我们假设兔八哥的坐标是(0,0)，则D为(2,2)，C为(1,1)；G为(-2,-4)，E为(-1,-2)。

4. 我们可以发现兔八哥要想成功躲避猎人，它与猎人横坐标之差的绝对值肯定和它与挡住他（它）们的那棵树横坐标之差的绝对值呈**倍数关系**，纵坐标亦然（句子有点长，请自行理解）。所以兔八哥要想躲避猎人的攻击，它与猎人横纵坐标之差的绝对值必须**同时**是一个大于1的整数的**倍数**，所以它们的最大公约数非1，意思是它们**不互质**（输出yes）。所以猎人要想杀死兔八哥，自然要将它们**互质**（输出no）。

5. 完毕！

——————分割不完全的分割线——————

以下是pascal代码：

```cpp
var n,m,i,j,k,x1,y1,x2,y2:longint;
function go(x,y:longint):longint;//求最大公约数（辗转相除法）
begin
  if y=0 then
  exit(x)
  else
  go:=go(y,x mod y);
end;
begin
  readln(n);//读入数据组数
  for m:=1 to n do
  begin
    readln(x1,y1);//读入猎人的坐标
    readln(x2,y2);//读入兔八哥的坐标
    if go(abs(x1-x2),abs(y1-y2))=1 then//判断是否互质（最大公约数为1）
    writeln('no')
    else
    writeln('yes');
  end;
end.
```

---

## 作者：修罗海神王 (赞：86)

# 无为  蒟蒻 

当本蒟蒻看到这道题时，以为兔兔和猎猎不能在同八个圈内，就不会被逮到，可惜呀，原来在外面8个点里也可以抓到的，原来兔爸爸这么可怜啊！！

解决问题：：

1、输入n

2、循环输入每一次询问

3、获得ax/ay/bx/by,即为可恶的猎猎和可怜的兔兔在森林里的坐标

4、让我们求出可恶的猎猎和可怜的兔兔列之差和可恶的猎猎和可怜的兔兔的行之差。

5、进行gcd，判断他们的列之差和行之差是否互质，如果是的话，就说明可怜的兔兔会被可恶的猎猎给逮到，所以输出no，否则，就说明我们可怜的兔兔当了一回幸运儿，没有被逮到，输出yes

#### 6、来一个gcd补充，gcd即为两个数之间的最大公约数，比如说3、12的最大公约数为3，而7、9的最大公约数为1，在数学中我们称它为互质。（仅为小学生看）

AC抱回洛谷：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ax,ay,bx,by;
int gcd(int x,int y)
{
	if(y==0) return x;
	  else return (gcd(y,x%y));
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&ax,&ay,&bx,&by);
		if(gcd(abs(ax-bx),abs(ay-by))==1) cout<<"no\n";
		  else cout<<"yes\n";
	}
	return 0;
}
```
# 防抄袭万岁！！

---

## 作者：UnyieldingTrilobite (赞：36)

~~写过的最短的题解~~

肯定有人第一眼看成只判断周围8个格子的吧······

~~要不是小学奥数的记忆太过刻骨铭心我估计也会掉坑。~~

把题目抽象一下，其实相当于给你两个点，判断连线上是否有其它点。

方便起见设起点为原点。

**众所周知，若有别的点，别的点与终点连线和原来的线斜率一定相同（注意所有点均为整点）故起点与终点横纵坐标之差必定不互质（为什么？根据互质定义反证说理即可）。**

**反之，若不互质，可设中点坐标为$(xd,yd)$，其中$x,y,d$均为整数，$d>0,d\not=1 $,则$(x,y)$也在这条线上，则线上一定有点**

上方不是结论的严格推导，只是简要说明。

于是······我们就得到，兔八哥有危险当且仅当它与猎人的横纵坐标之差互质。

代码······普通代码其他dalao都讲得很清楚，不再赘述，来个最短代码挑战吧：
```cpp
#include<bits/stdc++.h>
main(){
    int T,a,b,c,d;
    std::cin>>T;
    while(std::cin>>a>>b>>c>>d)
    puts(abs(std::__gcd(a-c,b-d))>1?"yes":"no");
}
```

---

## 作者：YLWang (赞：28)

考虑用解析几何的方法证明结论

以兔八哥（O）为原点重新建立平面直角坐标系。

设$\Delta x = abs(x_a - x_b)$
$\Delta y = abs(y_a - y_b)$

则设猎人A($\Delta x ,\Delta y$)（等价于猎人位于原来的位置，感性理解即可）, $AO:y = \Delta y / \Delta x * x$;

则若输出no，意味着在x$(\Delta x, 0)$区间内，不存在$x_0$使得$\Delta y / \Delta x * x_0$为整数

因为$\Delta y / \Delta x * x_0 = \Delta y * (x_0 / \Delta x)$


又因为，$x_0 = \Delta x / gcd(\Delta y, \Delta x)$使得$(\Delta x / x_0) | \Delta y$,

又因为$x_0$取不到$\Delta x$

故只需使$gcd(\Delta y, \Delta x) = 1$，即$\Delta x ,\Delta y$互质，才会输出no

所以结论就出来了

代码：
```
#include <bits/stdc++.h>
#define For(i,j,k) for(int i = (j); i <= (k); i++)
#define inf INT_MAX
using namespace std;

inline int read()
{
    int num = 0,flag = 1;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num * flag;
}
int main() {
	int T = read();
	while(T--) {
		int ax = read(), ay = read(), bx = read(), by = read();
		int dy = abs(ay-by), dx = abs(ax-bx);
		printf(__gcd(dy, dx) == 1 ? "no\n" :"yes\n");
	}
	return 0;
}


```

---

## 作者：hsfzLZH1 (赞：14)

题目中所求是两个整点之间是否存在其他整点

根据直线在平面直角坐标系上的定义，点(x,y)在点(x1,y1)和点(x2,y2)所确定的线段上，当且仅当(x-x1):(y-y1)==(x-x2):(y-y2)=(x1-x2):(y1-y2)（范围x1<=x<=x2,y1<=y<=y2）

由此，我们可以得知，两个整点之间存在其他的整点的话，必然有(x-x1):(y-y1)==(x-x2):(y-y2)，因为x,y,x1,y1,x2,y2都是整数，那么(x-x1),(y-y1),(x-x2),(y-y2),(x1-x2),(y1-y2)必然都是整数，且他们的比值相等。易证，如果存在这样的一组数，那么gcd(abs(x1-x2),abs(y1-y2))!=1，所以，我们只需求出gcd的值。

求gcd的值是基础数论中的内容，本篇题解用辗转相除法解决此问题，在此不做赘述。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int t,ax,ay,bx,by;//变量意义如题目所示
inline int abs(int a){return a<0?-a:a;}//自己编写的求绝对值的函数
int gcd(int x,int y){return y?(x%y?gcd(y,x%y):y):-1;}//求最大公约数的函数，注意在y==0的时候要返回错误值，否则会运算错误导致RE
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%d%d",&ax,&ay,&bx,&by);
        if(gcd(abs(ax-bx),abs(ay-by))==1)printf("no\n");//如果差的绝对值的最大公约数不是1，那么兔子处于危险状态
        else printf("yes\n");
    }
    return 0;
}
```
在此介绍一个基本语法知识：三目运算符?:的意义为

```cpp
表达式?语句块1:语句块2
```
即为在表达式的值为真的时候执行语句块1，否则执行语句块2，这样编写代码的复杂度和时间比单纯用if()语句要快。

### 变式题：

在平面直角坐标系上，两个整点之间有多少个整点？

经过计算可知，两个整点(x1,y1)和(x2,y2)中，一共有gcd(abs(x1-x2),abs(y1-y2))-1个整点，证明略。


---

## 作者：zr太弱了 (赞：7)

看到题目时，我的第一反应是猎人在兔八哥周围的8个点时，（如下图）

>O O O

>O X O   兔八哥为X，猎人在O点能看到

>O O O

能看到兔八哥，其余则相反；所以我开开心心的贴上了简单的判断代码，~~心想这题一定没有普及难度~~，结果WA了，我仔细想了想，忽然发现了真相：

>T O T O T

>O T T T O

>T T X T T

>O T T T O

>T O T O T

其中，T为树，X是兔八哥，猎人在O点也能看到兔八哥！

同理,猎人还可以在更远处的8个位置看到兔八哥，所以我们需要对该问题进行转换：

>在平面直角坐标系上，两个整点之间有多少个整点？

两个整点(x1,y1)和(x2,y2)中，一共有gcd(abs(x1-x2),abs(y1-y2))-1个整点（证明有点长，百度上好像有，可以自己搜索一下）

这个问题就变成了求两个数的最大公约数（gcd），我们可以用辗转相除法实现：

>辗转相除法， 又名欧几里德算法(Euclidean algorithm)，是求两个正整数之最大公约数的算法。它是已知最古老的算法， 其可追溯至公元前300年前。

>它的具体做法是：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。 

（另一种求两数的最大公约数的方法是更相减损法,如果我以后有空会写上的）

递归实现：

```cpp
int chu(int a,int b)
{
    if(b==0)
        return a;
    return (chu(b,a%b));
}
```
递归就是核心代码，剩下的就不难写出了（剩下的注释都放代码里了）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int chu(int a,int b)//辗转相除求最大公约数
{
    if(b==0)
        return a;
    return (chu(b,a%b));
}
int main()
{   long long n,x1,y1,x2,y2,i;//两人（一人一兔？）的坐标
    cin>>n;
    for(i=0;i<n;i++)
    {
        cin>>x1>>y1>>x2>>y2;
        if(chu(abs(x1-x2),abs(y1-y2))==1)//证明结果，本题不用手写abs，STL里的不会炸，时间再压一下就要手写了
            puts("no"); 
        else
            puts("yes");//其实cout也可以，不过最近在写AT的题，习惯用puts
    }
    return 0;
}
```


---

## 作者：初学者1 (赞：4)

本题主要有些坑人，有些人一下子会以为只有周围8个地方才会不安全，其实不是这样的。本题的做法主要是：算出兔八哥与猎人的横坐标差及纵坐标差，判断这两个数是否互质。若互质，输出‘no’；不互质则输出‘yes’。程序如下：

```delphi
var i,n,x1,y1,x2,y2,s1,s2:longint;  
function gcd(a,b:longint):longint;  
begin  
  if b=0 then gcd:=a else gcd:=gcd(b,a mod b); //判断是否互质 
end;  
begin  
  readln(n);  
  for i:=1 to n do begin  
  readln(x1,y1);readln(x2,y2);  
  s1:=abs(x1-x2);s2:=abs(y1-y2);  
  if gcd(s1,s2)=1 then writeln('no')  
  else writeln('yes');  
  end;  
end.
```

---

## 作者：Megumi_Cold (赞：3)

不止周围，还可以这样连

同意楼上观点

.   .   .

\
. \ .   .

\
.   .   .

```cpp
 
#include<cstdio>
using namespace std;
int xcf(int a,int b)//辗转相除法 
{
    if(b==0)
    return a;
    else
    return (xcf(b,a%b));
}
int abs(int a)//要自己写，不然会出错 
{
    if(a<0)
    return -a;
    else
    return a;
}
int main()
{
    int n,a,b,c,d,e,f;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d%d%d%d",&a,&b,&c,&d);//输入 
        a=abs(a-c);
        b=abs(b-d);
        if(xcf(a,b)==1)
        printf("no\n");//输出 
        else
        printf("yes\n");//输出 
    }
}

```

---

## 作者：潇洒乜逍遥 (赞：3)

#### 这题还是挺水的，主要是考最大公约数,这应该是最短代码。

#### 附上AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int a,int b)//用函数求最大公约数
{
    if(b==0)  return b;
    if(a%b==0)  return b;
    else return gcd(b,a%b);
}
int main()
{
	int n,a,b,c,d;//不放到全局变量的原因是函数中已经定义了a和b，如果放到上面去可能会出错。
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a>>b>>c>>d;//输入4个数
        if(gcd(max(a,c)-min(a,c),max(b,d)-min(b,d))==1)  cout<<"no"<<endl;
        else cout<<"yes"<<endl;//如果a和c中最大减最小和b和d中最大减最小互质的就输出“no”，否则输出“yes”。
    }
    return 0;//完美结束
}```
```

---

## 作者：jbc392 (赞：3)

~~此题就是一个水题~~

其实就是求最大公约数是否为1,如果是1就能看到,否则不能看到

怎么证明呢???

首先兔八哥与猎人的位置有4种

|  | 兔八哥 | 猎人 |
| -----------: | -----------: | -----------: |
| 1 |左上 | 右下|
| 2 | 左上 | 右上 |
| 3 | 左下 | 右上 |
| 4 | 左下 | 右下 |


总的来说4种都可以转化为第3种

所以要用一次函数

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/z5neaf46.png)

我们在函数中要找一个整点(x,y)

如果找到了就不能看见

因为y = kx

所以y / x = k

k为整数时x与y最大公因数必不为1

证毕

于是蒟蒻就写了一份代码




```
#include <bits/stdc++.h>
using namespace std;

int n ,rx ,ry ,hx ,hy ,lx ,ly;

int read() {
    int x = 0,y = 1;
    char c = getchar();
    while(c > '9' || c < '0'){
        if(c == '-')y = -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0'){
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * y;
}

int gcd(int x,int y){
	return y ? ( x % y ? gcd(y , x % y) : y) : -1;
}

int main(){
	

	n = read();
	
	for(int i = 1;i <= n;i++){
		
		rx = read();ry = read();
		hx = read();hy = read();
		lx = hx - rx;ly = hy - ry;
		
		if(lx == ly){
			cout << "no";
			continue;
		}
		
		if(gcd(lx,ly) == 1)cout << "no";
		else cout << "yes";
		
		cout << endl;
	}
	
	return 0;
	
}
```

交上去RE了,突然发现没加abs(QwQ)

下面是AC代码

```
#include <bits/stdc++.h>
using namespace std;

int n ,rx ,ry ,hx ,hy ,lx ,ly;

int read() {
    int x = 0,y = 1;
    char c = getchar();
    while(c > '9' || c < '0'){
        if(c == '-')y = -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0'){
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * y;
}

int gcd(int x,int y){
	return y ? ( x % y ? gcd(y , x % y) : y) : -1;
}

int main(){
	

	n = read();
	
	for(int i = 1;i <= n;i++){
		
		rx = read();ry = read();
		hx = read();hy = read();
		lx = hx - rx;ly = hy - ry;
		
		if(lx == ly){
			cout << "no";
			continue;
		}
		
		if(gcd(abs(lx),abs(ly)) == 1)cout << "no";
		else cout << "yes";
		
		cout << endl;
	}
	
	return 0;
	
}
```

---

## 作者：yanying (赞：2)

一开始不出意外的被坑了。。

后来检查发现要使横坐标之差与纵坐标之差互质。。

原因各位大佬已经说过了，下面本蒟蒻补充一下为什么直接判断
最大公因数是否为1即可。

若兔子与猎人同行或同列，由辗转相除法得到的数为两者的直线距离，如果等于1则说明两者相邻，有危险，反之没有；

若兔子与猎人同45度对角线，由辗转相除法得到的数也刚好为两者的纵坐标或横坐标之差（反正都一样）如果等于1则有危险，反正没有。

故直接判断最大公因数是否为1已经把相邻情况以及两个坐标差的绝对值相等的情况一起考虑进去了。不用再分开考虑。
附上本蒟蒻的代码：
```c
#include <stdio.h>

#include <math.h>
int main (void){
	
    int n;
	int x1,y1,x2,y2;
	scanf("%d",&n);
	int i=1;
	while(i<=n){
		i++;
		scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
		int q=fabs(x1-x2);
		int p=fabs(y1-y2);
			int r=q>p?q:p;
			int l=q>p?p:q;
			int x;
			while(l>0){
				x=r%l;
				r=l;
				l=x;
			}
			if(r==1)
			printf("no\n");
			else
			printf("yes\n");
		}
	return 0;
}
```


---

## 作者：YCIrving (赞：2)

本题的思路已经没有什么多说的了，就是坐标求差后判断一下是否互素。

我贴出代码的意图是想跟大家分享另一个问题，就是cin和scanf的问题。

如果你写的是C++，那么很可能会倾向于使用cin来读取数据，因为这样

既简单又方便。可是做这道题时，你会发现如果你用cin读，后两个测试

点会超时，这就涉及到了cin和scanf原理的一些问题了。建议大家去网上

搜一下，或者移步这里简单了解一下：

http://www.clanfei.com/2012/03/235.html

解决方法就是在程序中加入一行代码（具体位置我也不知道哪里合适，加在main中

应该不会有错）

std::ios::sync\_with\_stdio(false);

这样即使是cin也能AC了。

（结果显示用时仍然大于scanf，所以如果大家以后有超时的错误，不妨检查下自己的输入输出）


```cpp

#include<iostream>
#include<math.h>
using namespace std;
//int gcd(int a,int b)//递归求法
//{
//  return (b>0)?gcd(b,a%b):a;
//}
int gcd(int a,int b)//非递归求法
{
   while(b!=0)
    {
        int c=b;
        b=a%b;
        a=c;
    }
    return a;
}
int main()
{
    std::ios::sync_with_stdio(false);//重点！！
    int n,a,b,c,d,x,y;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        //scanf("%d%d%d%d",&a,&b,&c,&d);
        cin>>a>>b>>c>>d;
        x=abs(a-c);
        y=abs(b-d);
        if(gcd(x,y)==1)
            cout<<"no"<<endl;
            //printf("no\n");
        else
            //printf("yes\n");
            cout<<"yes"<<endl;
    }
    return 0;
}

```（c/c++）


---

## 作者：sxtm12138 (赞：1)

**相信各位大佬都已经发现只要两点之间的纵坐标之差与横坐标之差互质，两点之间的连线就不会经过其他整点，所以这里就不过多展开。判断两数互质的方法中，最简单的应该就是__gcd函数了，然后发生的事情大家应该已经猜出来了（多么痛的领悟！），但为了偷懒，我进行了特判，也通过了这道题（虽然最后也没少几个字）。**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],b[100005],c[100005],d[100005],n;
int main()
{cin>>n;
 for(int i=1;i<=n;i++)
   {cin>>a>>b>>c>>d;
    if(a==c||b==d)
    //特判，排除兔和人在同行或同列的情况，防止__gcd函数出错
      if(abs(a-c)+abs(b-d)<=1)  cout<<"no"<<endl;
      //在同行或同列的情况下，若曼哈顿距离小于等于1则不安全
      else cout<<"yes"<<endl;
      //否则兔子和猎人间至少有一棵树，兔子是安全的
    else if(__gcd(abs(a-c),abs(b-d))==1) cout<<"no"<<endl;
    //判断两点之间的纵坐标之差与横坐标之差是否互质,互质则两点间没有树
         else cout<<"yes"<<endl;//反之人兔间至少有一棵树
   }
return 0;
}

```
（弱弱地插一句：两点间的曼哈顿距离=|x1-x2|+|y1-y2|）

如果有人想通过这道题举一反三，挑(xiao)战(mo)极(shi)限(jian)，可以尝试一下这道题目：**P2158 [SDOI2008]仪仗队**

---

## 作者：ysy666 (赞：1)

这其实是个数学问题；

如果不明白自己画个坐标系，标几个点，看看他们如果在一条直线上时有没有什么规律；

你会发现如果两个坐标之差的最大公约数为1，那么他们之间就没有整点；

如果不是1，兔子就能存活；

然后代码就比较简单了；


附上萌新代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int gcd(int a,int b)//递归求最大公约数 
{
    if(b==0)  return b;//一定要考虑到一个数为0的情况 
    if(a%b==0)  return b;
    else return gcd(b,a%b);
}
int main()
{
    int n;
    cin>>n;
    int rx,ry,lx,ly;//rx，ry兔子坐标，lx，ly猎人坐标 
    for(int i=1;i<=n;i++)
    {
        cin>>rx>>ry>>lx>>ly;
        int m,n;
        if(rx<lx)
        {
            int t=rx;  rx=lx;  lx=t;//简单交换，没有应该也行。。 
        }
        if(ry<ly)
        {
            int t=ry;  ry=ly;  ly=t;
        }
        m=rx-lx;
        n=ry-ly;
        if(gcd(m,n)==1)  cout<<"no"<<endl;//求gcd,输出 
        else cout<<"yes"<<endl;
    }
    return 0;
}
```

---

## 作者：yoy68 (赞：1)

这其实是个数学问题；

如果不明白自己画个坐标系，标几个点，看看他们如果在一条直线上时有没有什么规律；

你会发现如果两个坐标之差的最大公约数为1，那么他们之间就没有整点；

如果不是1，兔子就能存活；

然后代码就比较简单了；

附上萌新代码：

```
#include<bits/stdc++.h>
using namespace std;
int gcd(int x,int y){//递归求最大公约数 
	if (y==0)return 2;//如果有一个数是0，只要不是1就行
	if (x%y==0)return y;//x能被y整除，返回y
	return gcd(y,x%y);否则递归
}
int main (){
	int n;
	scanf ("%d",&n);//输入
	while (n--){
		int a,b,a1,b1;
		scanf ("%d%d\n%d%d",&a,&b,&a1,&b1);//输入坐标
		int p=fabs(b1-b);//求两点的横纵坐标差
		int q=fabs(a1-a);
		if (gcd(p,q)==1)printf ("no\n");
                //如果最大公约数为1，输出NO
		else printf ("yes\n");否则输出yes
	}
	return 0;
}
```


---


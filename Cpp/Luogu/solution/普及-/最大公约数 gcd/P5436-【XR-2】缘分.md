# 【XR-2】缘分

## 题目背景

> 世间万物都置身于缘分编织的大网中。缘分未到，虽历经千劫，却不能相遇。缘分到了，在草原上都能等到一艘船。——《一禅小和尚》

## 题目描述

一禅希望知道他和师父之间的缘分大小。可是如何才能知道呢？

一禅想了个办法，他先和师父约定一个正整数 $n$，接着他们各自在心里想一个不超过 $n$ 的正整数。

一禅认为，他和师父心里想的这两个数的**最小公倍数**越大，则意味着他和师父之间的缘分越大。

师父觉得这个办法很合适，不过他想知道这两个数的最小公倍数最大会是多少。

师父的数学不太好，于是问一禅。一禅也觉得这个问题很困难，他希望你能告诉他答案。

## 说明/提示

【样例 $1$ 说明】

不超过 $3$ 的两个正整数的最小公倍数的最大值为 $\mathrm{lcm}(2,3) = 6$。

【数据规模与约定】

对 $50\%$ 的数据，$1 \le T,n \le 100$。

对 $100\%$ 的数据，$1 \le T \le 100, 1 \le n \le 10^9$。

## 样例 #1

### 输入

```
1
3
```

### 输出

```
6
```

# 题解

## 作者：Koakuma (赞：49)

**题意**：给定一个正整数 $n$，对于两数 $a$ 和 $b$ $(1\leq a,b \leq n)$，求出 $\max\{\ lcm(a,b)\ \}$ .

结论题。

显然对于相邻两数 $x-1$ 和 $x$ ，它们是互质的。

对于此题，$lcm(n-1,n)$ 即为小于等于 $n$ 范围内两数的最大 $lcm$ .

因此最终解即为 $n \times (n-1)$ .

特别地，当 $n=1$ 时，结果应为 $1$ .

注意最终解可能超过 $int$ 范围。

---

## 作者：xht (赞：21)

#### 题目大意

> 求两个不超过 $n$ 的正整数的最小公倍数的最大值。

#### 前置知识

- 最小公倍数

#### 题解

略...

注意特判 $n = 1$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        if (n == 1) {
            puts("1");
            continue;
        }
        cout << 1ll * n * (n - 1) << endl;
    } 
    return 0;
}
```



---

## 作者：StudyingFather (赞：8)

一道非常不错的签到题。

首先，$ \operatorname{lcm}(a,b) = a * b / \gcd (a,b) $ 。要想让 $ \operatorname{lcm}(a,b) $ 尽可能大，当然要让 $ \gcd (a,b) $ 尽可能小。所以我们要取两个互质的整数 $ a,b  $ 。

怎样让 $ a * b $ 尽可能大呢？当然是让两个数都尽可能大。于是我们的方案就呼之欲出了：我们取 $ n $ 和 $ n-1 $ 两个数字。

特别地，当 $ n=1 $ 时，我们取的两个整数都是 $ 1 $ ，答案也是 $ 1 $ 。

```cpp
#include <iostream>
using namespace std;
int main()
{
 int t;
 cin>>t;
 while(t--)
 {
  long long x;
  cin>>x;
  if(x==1)cout<<1<<endl;
  else cout<<x*(x-1)<<endl;
 }
 return 0;
}
```


---

## 作者：Aehnuwx (赞：6)

真·小学奥数

要想让两个不超过 $ n $ 的数的 lcm 最大，显而易见，它们必须要互质。

因为```相邻两个自然数互质```，在这道题中，$ ans=(n-1)n $。

**然而这并不是绝对的。**

注意几个坑（？）点：

1、答案超过了 int 范围，要开 ll，或者强制类型转换；

2、当 $ n = 1 $ 时，如果依然用上面的公式，答案将会是 $ (1-1)\times1=0 $，**而实际上，这两个数应该都是 1，这样答案将是 1.**

所以实际上的公式是：

$ \begin{cases} ans=1 \qquad \qquad \quad \  (n=1) \\ ans=(n-1)n \qquad (n\not=1) \end{cases} $

$ \rm code $

```cpp
# include <bits/stdc++.h>
using namespace std;
void read(int &);
int main() {
    int T, n;
    for(read(T); T; --T) {
        read(n);
        if(n == 1) puts("1");
        else cout << (long long)n * (long long)(n - 1) << '\n';
    }
    return 0;
}
void read(int &x) {
    x = 0;
    char ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch & 15), ch = getchar();
}
```


---

## 作者：Fatalis_Lights (赞：6)

[题目传送门](https://www.luogu.org/problemnew/show/P5436)

我拿道题第一反应是暴力的打个表...于是诞生了solution1

**solution1：**(50 pts)
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 10009
using namespace std;
int T,f[N],n;

int gcd(int m,int n){
    return n==0? m:gcd(n,m%n);
    return 0;
} //gcd相信大家都会，直接用辗转相除法就可以了QwQ

int main(){
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                f[i]=max(f[i],i*j/gcd(i,j));//lcm(i,j)=n*m/gcd(i,j);
        cout<<f[n]<<endl;
        for(int i=1;i<=n;i++) f[i]=0;
    }
    return 0;
}

```

**solution2:** (100pts)

我们观察打表：

n==1时，ans==1;

n==2时，ans==2;

n==3时，ans==6;

n==4时，ans==12;

······//以此类推

我们似乎发现了什么: 

当n==1时，ans=1;

当n!=1时，ans=n*(n-1);

于是我们尝试去证明如上的结论：（敲黑板）

当n!=1时，易知gcd(n,n-1)==1;(即n,n-1互素)

而lcm(n,n)==n < lcm(n,n-1)==n*(n-1) ;

这说明...

ans==n*(n-1) ; 大于其他所有解

于是有了如下的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T;

void read(ll &x){
    ll f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}

void print(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
} ~~//快读模板，你值得拥有~~

int main(){
    read(T);
    while(T--){ //多组数据要注意鸭
        ll n,ans;
        read(n);
        if(n==1) ans=1;
        else ans=n*(n-1);
        print(ans);
        puts("");
    }
    return 0;
}

```

感谢观看（QvQ）



---

## 作者：TheWaySoFar (赞：4)

签到题

就是一个最小公倍数的判断 挂一个代码吧
```
#include <stdio.h>
#include <stdlib.h>
#include <iostream>  
#include <string>  
#include <cstring>  
#include <cstdio>  
using namespace std;  
  
const int maxn = 1000;  
  
struct bign{  
    int d[maxn], len;  
  
    void clean() { while(len > 1 && !d[len-1]) len--; }  
  
    bign()          { memset(d, 0, sizeof(d)); len = 1; }  
    bign(int num)   { *this = num; }   
    bign(char* num) { *this = num; }  
    bign operator = (const char* num){  
        memset(d, 0, sizeof(d)); len = strlen(num);  
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';  
        clean();  
        return *this;  
    }  
    bign operator = (int num){  
        char s[20]; sprintf(s, "%d", num);  
        *this = s;  
        return *this;  
    }  
  
    bign operator + (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] += b.d[i];  
            if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;  
        }  
        while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;  
        c.len = max(len, b.len);  
        if (c.d[i] && c.len <= i) c.len = i+1;  
        return c;  
    }  
    bign operator - (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] -= b.d[i];  
            if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;  
        }  
        while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;  
        c.clean();  
        return c;  
    }  
    bign operator * (const bign& b)const{  
        int i, j; bign c; c.len = len + b.len;   
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++)   
            c.d[i+j] += d[i] * b.d[j];  
        for(i = 0; i < c.len-1; i++)  
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;  
        c.clean();  
        return c;  
    }  
    bign operator / (const bign& b){  
        int i, j;  
        bign c = *this, a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            c.d[i] = j;  
            a = a - b*j;  
        }  
        c.clean();  
        return c;  
    }  
    bign operator % (const bign& b){  
        int i, j;  
        bign a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            a = a - b*j;  
        }  
        return a;  
    }  
    bign operator += (const bign& b){  
        *this = *this + b;  
        return *this;  
    }  
  
    bool operator <(const bign& b) const{  
        if(len != b.len) return len < b.len;  
        for(int i = len-1; i >= 0; i--)  
            if(d[i] != b.d[i]) return d[i] < b.d[i];  
        return false;  
    }  
    bool operator >(const bign& b) const{return b < *this;}  
    bool operator<=(const bign& b) const{return !(b < *this);}  
    bool operator>=(const bign& b) const{return !(*this < b);}  
    bool operator!=(const bign& b) const{return b < *this || *this < b;}  
    bool operator==(const bign& b) const{return !(b < *this) && !(b > *this);}  
  
    string str() const{  
        char s[maxn]={};  
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';  
        return s;  
    }  
};  
  
istream& operator >> (istream& in, bign& x)  
{  
    string s;  
    in >> s;  
    x = s.c_str();  
    return in;  
}  
  
ostream& operator << (ostream& out, const bign& x)  
{  
    out << x.str();  
    return out;  
}
int main()
{
    bign num;
    cin >> num;
    for(bign i=0;i<num;i=i+1)
    {
        bign a;
        cin>>a;
        if(a==1) cout << 1 << endl;
        else
        cout << a*(a-1) << endl;
    }
    return 0;
}
```

具体的实现方式就是这样了 不过比赛还是不建议采用这种方法 仅供学习和参考使用


---

## 作者：米奇奇米 (赞：4)

## 一题很简单的数论题
### $1.1$ 题目意思
找两个整数$a,b(1<=a,b<=n)$使得$lcm(n,m)$最小
### $2.1$ $Solution$
先打一个$n^2$暴力试试看，大力发现其实答案就是$x*(x-1)$,
然后对$1$的情况进行特判就可以了。证明其实也很简单，我们只要找一个与$n$互质最大整数，那么就一定是$n-1$。



---

## 作者：Register (赞：3)

### 解题思路
要想让两个不超过$n$的数的$LCM$最大，有以下两个因素：

- 互质

- 尽量大

我们观察第二个条件，如果两个数都是$n$，那么$LCM$就是$n$，显然不靠谱

如果我们改成$n$和$n-1$呢？我们知道，两个相邻的正整数必定是互质的，而两个互质的数$LCM$就是这两个数的乘积

$n\times(n-1)$这个方案既满足了尽量大又有满足了互质，必定是最优的

但是题目的数据中$n$可以是$1$，所以这个式子的值就会为$0$，因此我们需要特判
### 注意事项
题目中$1\le n\le 10^9$，$n^2$会爆```int```，因此要开```long long```
### 代码
```cpp
#include <cstdio>
#define int long long
int t,n;
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
signed main(){
    t=read();
    while(t--) {n=read();printf("%lld\n",n==1?1:n*(n-1));}
    return 0;
}
```


---

## 作者：1saunoya (赞：2)

心血来潮写篇题解


·前置芝士

$$lcm(x , y) = x * y / gcd(x , y) $$
$$gcd(x,x-1) = 1 $$


我们这里求的是 n 以内两个数 最大 的最小公倍数

那么根据柿子可以推出 ： $ans = n * (n - 1)$

注意 1 的情况 50分就是因为没有特判 1 


不放代码了

---

## 作者：nxt_permutation (赞：1)

- 【XR-2】第一题：找规律。

- 这两个数的最小公倍数越大意味着这两个数越大越好，且相差应为一。所以答案为n*(n-1).(需注意当n=1时这两个数的最小公倍数为1，我就在这上卡了10分钟）

```
#include<iostream>
using namespace std;
int main()
{
    int t;//输入情况数
    cin>>t;
    while(t--)
    {
        long long n;
        cin>>n;
        if(n==1) cout<<1<<endl;//特判
        else cout<<n*(n-1)<<endl;
    }
    return 0;//完美结束
}
```

---


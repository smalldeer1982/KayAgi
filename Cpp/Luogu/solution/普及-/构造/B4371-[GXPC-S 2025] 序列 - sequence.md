# [GXPC-S 2025] 序列 / sequence

## 题目背景

题目来源：2025 年广西中小学生程序设计挑战赛复赛（进阶组[试题](https://mp.weixin.qq.com/s?__biz=MzI3NDM3MzcwNQ==&mid=2247490166&idx=5&sn=e7ba7e3bc8126027b9abd662518c208b&chksm=ea9c06dd4d18206ed9d88124cc78b947298df2555889e98620204c2ea1471f58c135c00f99fb&mpshare=1&scene=23&srcid=0724dNJdhMxpUHag1dqkhiqL&sharer_shareinfo=7e47197d6e5c044ae705613db988029c&sharer_shareinfo_first=7e47197d6e5c044ae705613db988029c#rd)）。

## 题目描述

求知的隐士将知识传授给懵懂无知的凡人，隐士每年提出 $n$ 个正确的观点和 $m$ 个错误的观点，且 $n \leq m$。其中正确的观点用数字 “1” 表示，错误的观点用数字 “0” 表示。例如，如果他提出了 3 个正确观点和 2 个错误观点，序列可能是 “11100” 或 “10101”。人们按序列的顺序讨论这些问题。

隐士定义，一条观点序列是好的：当且仅当序列中错误观点数量与正确观点数量之差为 $K$。也就是说，$K = m - n$。隐士同时注意到：当某个观点序列的所有子段中，$K$ 的最大值恰好是 $k$ 时，人们获得知识的效果最好可理解。现在隐士希望小景编写一个程序，使他不必手造观点序列。



序列需恰好包含 $n$ 个 1 和 $m$ 个 0，并且所有子段的 $K$ 的最大值恰为 $k$。保证输出的数一定存在符合要求的序列。

形式化地，设某序列 $s$ 包含 $n_s$ 个 1 和 $m_s$ 个 0，则 $K$ 为：

$$
K = t_s = m_s - n_s 
$$

所有子段构成集合 $\{ s_1, s_2, \dots, s_n \}$，此时：

$$
k = \max( t_{s_1}, t_{s_2}, \dots, t_{s_n} )
$$


---


子段：原序列中一段连续的非空子序列。例如，假定原序列为 $\texttt{abcde}$，其子段有 $\texttt{a}$，$\texttt{c}$，$\texttt{de}$，$\texttt{abc}$，$\texttt{bcde}$，$\texttt{abcde}$ 等。

字典序：对于数字，不同排列的字典序是从左到右依次对应的数字的先后决定的。例如对于 4 个数字的排列 1234 和 1243，排列 1234 在前（称为字典序更小），排列 1243 在后（称为字典序更大）。

## 说明/提示

#### 样例解释

- 对于样例 1 的解释：

取前 2 位（$\texttt{00}$），可以取得所有子段的 $K$ 的最大值，恰为 $2$，且字典序最小。


- 对于样例 2 的解释：

取前 8 位，可以取得所有子段的 $K$ 的最大值，恰为 8，且字典序最小。

#### 数据范围

- 对于 $10\%$ 的数据：$1 \leq n, m \leq 50$；
- 对于 $60\%$ 的数据：$1 \leq n, m \leq 10^4$；


对于 $100\%$ 的数据，保证：

- $m - n \leq k \leq \max(m, n)$，$n + m \geq 1$；
- $1 \leq n, m \leq 2 \times 10^5$，且 $n \leq m$。

## 样例 #1

### 输入

```
2 3 2```

### 输出

```
00101```

## 样例 #2

### 输入

```
5 10 8```

### 输出

```
000000001010111```

# 题解

## 作者：Yxa_Sheep (赞：8)

**[题目传送门](https://www.luogu.com.cn/problem/B4371)**
## 题意
让一个序列中包含 $n$ 个 $1$ 与 $m$ 个 $0$，使得/这个序列的每个子序列中/ $1$ 与 $0$ 的数量的差/的最大值/为 $k$（多么精妙的断句）。记住，要输出字典序最小的。如果你是因为没看懂题意来看题解的话，请在评论区发一个 `1` 再回去写，也可以点个赞。
## 思路
这里要输出字典序最小的，于是我们很容易想到，尽量放 $0$，如果实在放不了了再放 $1$。  
那么什么时候是放不了的呢？第一种是没有 $0$ 了，我们可以每放一个 $0$，$m$ 就减一，如果 $m$ 等于 $0$ 就放不了了。第二种我们可以用 $x$ 记录下当前最大的 $K$（题目里这样叫的，见题目描述第二段开头），如果 $x$ 小于 $k$（这个是输入时的 $k$，见输入格式），那么就可以放进去一个 $1$， $x$ 也要加一。  
其他具体细节见代码，这里不再赘述。
## 代码
```cpp
#include <bits/stdc++.h>
#define code using
#define from namespace
#define Yxa_Sheep std
code from Yxa_Sheep;
int n, m, k, x;
string ans;
int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m >> k;
    while (n || m)
    {
        if (m && x < k)
            ans += '0', x++, m--;
        else
            ans += '1', x--, n--;
    }
    cout << ans;
    return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4371)**

---

## 作者：Lava_Dreamer (赞：3)

俗话说得好：有些题看似很麻烦，实际很简单。
## 思路：
为了让字典序尽可能小，开头一定是尽可能多的 0。但是，开头最多只能包含 $k$ 个 0，因为一旦超过 $k$ 个，就会出现一个 $K$ 大于 $k$ 的子段。  
很多人就要问了，万一 $k>m$，0 不够用了怎么办？因为题目中说 $k \le \max (n,m)$，而 $n \le m$，所以 $k \le m$，不会出现 0 不够用的情况。

开头的 $k$ 个 0 后面不能再跟 0 了，所以只能跟 1。但是跟完 1 后这个子段的 $K$ 就变成了 $k-1$（因为包含 $k$ 个 0 和 $1$ 个 1），所以后面可以跟一个 0。而跟完 0 后这个子段的 $K$ 又变成了 $k$，又只能跟 1 了。跟完 1 后又只能跟 0，跟完 0 后又可以跟 1……那么后面要跟多少个 10 呢？众所周知，开头已经有了 $k$ 个 0，还剩 $m-k$ 个 0，所以后面还能跟 $m-k$ 个 10。  
很多人又要问了，万一剩下的 1 还没有 0 多怎么办？题目中又说 $m-n \le k$，而将不能等式两边同时加 $n$ 再减 $k$ 就可以得到 $m-k \le n$，因此剩下的 1 一定不比 0 少。

那么 0 已经用完了，就只剩 $n-m+k$ 个 1 了，所以最后只用再跟 $n-m+k$ 个 1 就可以了。  
很多人又又要问了，万一最后剩下 1 的个数比 $k$ 大怎么办？因为题目中又又说 $n \le m$，所以 $n-m$ 一定是一个小于等于 $0$ 的数。而一个小于等于 $0$ 的数加上 $k$，得到的值也肯定是小于等于 $k$ 啦（不得不说，出题人给的数据范围是真严谨啊）。

最后总结一下：
1. 输出 $k$ 个 0；
2. 输出 $m-k$ 个 10；
3. 输出 $n-m+k$ 个 1；
## 代码：
**抄袭不是好习惯！！！**
```cpp
#include<bits/stdc++.h>//万能头万岁
using namespace std;
int n,m,k;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++) cout<<0;//k 个 0
    for(int i=1;i<=m-k;i++) cout<<10;//m-k 个 10
    for(int i=1;i<=n-m+k;i++) cout<<1;//n-m+k 个 1
    return 0;
}
```

---

## 作者：Little_rock (赞：3)

题意简化：有一个由 $n$ 个`1`, $m$ 个`0`组成的01序列，要求输出满足
1. 字典序最小的；
2. 其中所有子段中`0`的个数减去`1`的个数最大值 $K$ 恰好为 $k$。

先解决字典序最小：

抛开其他条件，这个序列必定长成 `0 ... 01 ... 1`。

不难发现，当 $m=k$ 时，这个序列就是满足所有条件的答案。

再来看第二个。

因为长度大于 $k$ 的子段与全`0`的长度为 $k$ 的子段才能满足所有条件，而长度大于 $k$ 的子段要想字典序最小满足前 $k$ 位为`0`，就是包含了全`0`的长度为 $k$ 的`01`序列，所以求出合法满足包含有全`0`长度为 $k$ 的字段的`01`序列即可。

有全`0`长度为 $k$ 的子段要想满足条件必定满足其中之一:

1. $m=k$ （这个是字典序最小的也是唯一的一个序列，就是上面提到的 `0 ... 01 ... 1`序列）。
2. 是 $k+x$ 个`0`与 $x$ 个 $1$ 构成的一个子串（形如`0000110010`，其中 $k=4$）。

对于第二点，注意：
- $k+x$ 个`0`不能连接，否则 $K>k$；
- 这个序列不是字典序最小。

观察样例：
答案为：`000000……`，然后是`101010……`，最后是`111111……`。

$k$ 个`0`在前面；剩下 $m-k$ 个`0`和`1`间隔放置，保证最大值不变且字典序最小；剩下 $n-(m-k)$ 个`1`放在最后。

结束。

## CODE：

```cpp
#include <iostream>
using namespace std;
int n,m,k;
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++) cout<<"0";
    for(int i=1;i<=m-k;i++) cout<<"10";
    for(int i=1;i<=n-m+k;i++) cout<<"1";
    return 0;
}
```

---

## 作者：New_Void (赞：2)

## [B4371 [GXPC-S 2025] 序列 / sequence](https://www.luogu.com.cn/problem/B4371)

### 思路

显然这是一道构造题目。我们要想使字典序最小，那必然是要让零在前面，一在后面。所以我们如果零放置的个数减去一放置的个数小于 $k$ 的话，那我们就一直放零，否则的话就放一，但是前提条件是一的个数得够用，所以我们在放零和一的时候要将 $n$ 和 $m$ 减一。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int read(){
    int k=0,f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9') k=k*10+c-'0',c=getchar();
    return k*f;
}
signed main(){
    int n=read(),m=read(),k=read();
    string res="";
    int cnt1=0,cnt0=0;
    while (n>0 || m>0){
        if (m>0 && (cnt0-cnt1)<k){
            res+='0';
            cnt0++;
            m--;
        }
        else if (n>0){
            res+='1';
            cnt1++;
            n--;
        }
        else{
            res+='0';
            cnt0++;
            m--;
        }
    }
    cout<<res;
    return 0;
}

```

---

## 作者：Mark_Pei (赞：1)

## Solution

我们需要构造一个由 $n$ 个 $1$ 和 $m$ 个 $0$ 组成的 $01$ 字符串，满足以下条件：

- 所有子段的 $K$ 的最大值恰好为 $k$，其中 $K$ 是子段中 $0$ 的数量减去子段中 $1$ 的数量。

- 在所有满足条件的字符串中，选择字典序最小的那个。

要构造满足条件的字符串，我们需要确保贪心：

- 字典序最小的字符串应该尽可能将 $0$ 放在前面。

- 为了确保所有子段的 $K$ 的最大值是 $k$，我们需要控制 $0$ 和 $1$ 的分布，避免出现某个子段的 $K$ 超过 $k$。

- 特别地，最长的连续 $0$ 的子段会贡献最大的 $K$ 值。因此，我们可以先放置 $k$ 个连续的 $0$，这样这些 $0$ 的子段的 $K$ 就是 $k$。

- 然后，我们需要确保其他子段的 $K$ 不超过 $k$。可以通过交替放置 $1$ 和 $0$ 来实现这一点。

#### 构造方法：

1. 首先放置 $k$ 个 $0$。这样，这 $k$ 个 $0$ 的子段的 $K$ 就是 $k$。

2. 然后，将剩余的 $0$ 和 $1$ 以 $10$ 的形式交替放置。这样，每个 $10$ 对的 $K$ 是 $1 - 1 = 0$，不会增加 $K$ 的最大值。

3. 最后，如果还有剩余的 $1$，直接放在末尾。因为 $1$ 会减少 $K$，所以不会影响最大值。

代码其实很短。

**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)// 第一步：输出 k 个 0
        cout<<0;
    m -= k; // 剩余的 0 的数量
    for(int i=1;i<=m;i++) // 第二步：交替输出 1 和 0，每次输出 "10"，共 m 次
        cout<<10;
    n -= m; // 剩余的 1 的数量
    for(int i=1;i<=n;i++)// 第三步：输出剩余的 1
        cout<<1;
    return 0;
}
```

---

## 作者：SXY83296647 (赞：1)

## 思路
题目要求我们构造一个 01 序列。首先可以得知该序列包含 $n$ 个 1 和 $m$ 个 0，以及满足所有子段 $K$ 的最大值恰好为 $k$。

为了使构造的 01 序列的字典序最小，我们可以先让尽可能多的 0 出现在序列的前面。由题意，子段 $K$ 的值为该子段 0 的个数减去该子段 1 的个数（即题目中的 $K = m_s - n_s$），所以序列前面的 0 的个数应为 $K$ 的最大值 $k$，然后将 $m$ 减去 $k$ 得到剩余的 0 的个数。最后，为了使序列的字典序最小，可以将剩余的 1 与 0 交错输出（为了让 $K$ 不超过最大值，一定要将 1 放在前面），当 0 的个数不够时直接输出 1。以下给出代码：
## AC Code
C++：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
int main()
{
    cin >> n >> m >> k;
    m-=k;
    while(k--) putchar('0');
    while(m--&&n--){
        putchar('1');
        putchar('0');
    }
    while(n--) putchar('1');
    return 0;
    //用时34ms
}
```
Python：
```python
n,m,k = map(int, input().split())
ans = ['0']*k
m -= k
while n > 0 and m > 0:
    ans += ['1', '0']
    n -= 1
    m -= 1
ans += ['1']*n
print(''.join(ans))
#用时219ms
```
pascal
```pascal
program Sequence;
var
  n, m, k, i: LongInt;
begin
  readln(n, m, k);
  m := m - k;
  for i := 1 to k do
    write('0');
  while (m > 0) and (n > 0) do
  begin
    write('1');
    dec(n);
    write('0');
    dec(m);
  end;
  for i := 1 to n do
    write('1');
end.
```
时间复杂度：$O(n+m)$

---

## 作者：scc36 (赞：1)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4371)  
### 提一嘴
题目描述中说 $n \geq m$，而数据范围中说 $n \leq m$。  
根据题目描述，$m-n=K \geq 0$，故 $n \leq m$，故判断题目描述第一段中为笔误。  
~~这是我写了一半的工单，但很明显这样一来题目描述第一段都要改，所以就懒得改了。~~
### 思路
贪心题，因为要输出满足条件且字典序最小的 01 字符串，就应当把最多的 0 放在前面。  
开头最多放 $k$ 个 0，再多放，很明显不满足定义。  
对剩下的 $m-k$ 个 0，以 10 串的形式输出。10 串的 $K$ 的值为 0，不影响最大值。这里要注意不能是 01 串，这样的话从 $s_1$ 到 $s_{k+1}$ 都是 0，最大值为 $k+1$ 而非 $k$。   
剩下所有位置都放 1。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,i;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(i=1;i<=k;i++) cout<<0;
	for(i=1;i<=m-k;i++) cout<<"10";
	for(i=1;i<=n-(m-k);i++) cout<<1;
}
```

---


# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# 题解

## 作者：ingu (赞：262)

#本题主要考查树的遍历方法

1.建树。按照题意是在递归过程中建立树，建树的方法实际上就是树的先序遍历（先根节点，再左右子树）。当本节点长度大于1时递归建立子树。

2.输出。而输出过程是对树的后序遍历（先左右子树，再根节点），这里有个技巧就是可以和建树过程集成在一起。只需将代码放在递归调用之后就可以了。

3.判断。最后是判断当前节点的FBI树类型，可以用B（初始值为1）保存全是‘0’的情况，如果遇到‘1’就将B置为0，用I（初始值为1）保存全是‘1’的情况，如果遇到‘0’就将I置为0。最后判断B和I中的值，如果两个都为0则输出F（不全为‘0’，不全为‘1’）。

参考代码如下：


```cpp
#include <iostream>
using namespace std;
char s[1050];
void maketree(int x,int y){
    if(y>x){
        maketree(x,(x+y)/2);
        maketree((x+y+1)/2,y);
    }    
    int B=1,I=1;
    for(int i=0;i<=y-x;i++){
        if(s[x+i]=='1'){
            B=0;
        }else if(s[x+i]=='0'){
            I=0;
        }
    }
    if(B){
        cout<<'B';
    }else if(I){
        cout<<'I';
    }else{
        cout<<'F';
    }
}
int main() {
    int n;
    cin>>n>>s;
    maketree(0,(1<<n)-1);
    return 0;
}
```

---

## 作者：wuhao1027 (赞：148)

递归即可。跟二分查找的思想有点像。想起以前学长跟我说的，很多树的题目事实上根本不用把树建立出来，虽然当时觉得这个思想很惊奇(marvel)，但现在自己也算真正的理解了这句话了。

在输入一长串的时候，写 A+1 就能从 A[1] 开始输入了，这很贴合人的语言习惯，但问题是这样就不能使用 strlen 了，所以使用了 math 来计算 2 的 n 次






```cpp
#include<stdio.h>
#include<math.h>
char A[1025];
void work(int low, int up)
{
    int mid = (low+up)/2;
    if (low!=up){
        work(low, mid);
        work(mid+1,up);
    }
    int i,a=0,b=0;
    for (i=low;i<=up;i++)
        if (A[i]=='0') a++;
        else b++;
    if (a&&b) printf("F");
    else if (a) printf("B");
    else printf("I");
}
int main()
{
    int n;
    scanf("%d", &n);
    scanf("%s", A+1);
    work(1, pow(2,n));
    return 0;
}
```

---

## 作者：传说饭 (赞：122)

第一次做那么奇怪的问题，因为输入的第一个变量完全多余！其实只需要读一个字符串，然后二分就行了。
学数据结构的时候，二叉树后序遍历可以说是基础问题！只有几行递归代码！
以下代码为链式二叉树遍历函数。
```
void BinTree::Print(Node *p)//核心函数
{
	if(p==NULL)
		return;
	Print(p->lchild);//访问左子树
	Print(p->rchild);//访问右子树
	cout<<p->data<<" ";//遍历
}
```

然后转换成此题就成如此这般了，是不是很像？：）
```
#include <iostream>
#include <string>

using namespace std;

char FBI(string s);

int main() 
{
	int n;
	cin >> n;
	string s;
	cin >> s;
	cout << FBI(s);
	return 0;
}

char FBI(string s) 
{
	if (s.length() > 1)
	{
		cout << FBI(s.substr(0, s.length()/2));
		cout << FBI(s.substr(s.length()/2, s.length()/2));
	}
	if (s == string(s.length(), '0')) return 'B';
	if (s == string(s.length(), '1')) return 'I';
	return 'F';
}
```

---

## 作者：我是蒟弱 (赞：84)

# **神犇勿喷，这是初级的蒟蒻AC算法** 

### 递归之结构体建树后序算法（虽然有点长，但比较好理解）

好了，说了这么多，不明白[后序遍历](https://baike.baidu.com/item/后序遍历/1214806?fr=aladdin)也是白搭。点开有颜色的字查看哦！

至于说字符串的长度，是2^n,树的节点数是2^(n+1)-1个。根据此结论开数组2048长度即可。

```cpp
struct node{//定义节点 
    int num;//节点号 
    string str;//所在的串 
    int father_num;//父节点 
    int sonl=0,sonr=0,visit;//sonl：左孩子，sonr：右孩子，visit：判断输没输出，用于后序遍历函数 
}n [2048];//已经讲过2048的来历啦！
```
#### 结构体就是这么定义的。左孩子和右孩子先定义成0，为了建树与遍历需要！拥有几个变量，FBI树AC无疑！

样例注意：有一个样例**n=0**，要这么判断：
```cpp
if(a.length()==1){//长度为1，注意！有点卡这这里！ 
    if(a=="0"){//为0 
        cout<<"B";//输出B 
    }else{//为1 
        cout<<"I";//输出I 
    } 
    return 0;//不要手下留情！
}
```
构造树殊不知大家是怎么想的，或许本蒟蒻想法比较奇葩：先序构树，后序输出。

先序构树思路：建立根，建立左子树，建立右子树

后序遍历思路：访问左孩子，访问右孩子，访问自己。

**注意：**

**到了叶节点千万别忘了return！会死循环的！**

**思路一定得清晰，对于树形结构计算一定不要出错！**

下面上代码了。代码如下**↓↓↓↓↓**
```cpp
#include<bits/stdc++.h>//完美的开头是成功的一半
using namespace std;//完美的开头是成功的一半
struct node{//定义节点 
    int num;//赋的值 
    string str;//所在的串 
    int father_num;//父节点 
    int sonl=0,sonr=0,visit;//sonl：左孩子，sonr：右孩子，visit：判断输没输出，用于后序遍历函数 
}n [2048];//已经讲过2048的来历啦！
int t=1;//所赋的值的变量，说实话也就是给每个点标的号 
string a;//输入的字符串 
void gou_zao_shu(int from/*字符串起始点*/,int to/*字符串截止点*/,int l/*从哪里来（所谓的父节点）*/,int pds/*判断是父节点的左或右孩子*/){
    n[t].num=t;//标号 
    n[t].father_num=l;//把l标记成父节点（因为1个点只有一个父节点） 
    string s;//本节点的字符串 
    for(int i=from;i<=to;i++){
        s+=a[i];//连接（+在这里是连接的意思） 
    }
    n[t].str=s;//存储字符串 
    if(pds==0){//来路是左孩子 
        n[l].sonl=n[t].num;//存为父节点的左孩子 
    }else{//来路是右孩子 
        n[l].sonr=n[t].num;//存为父节点的右孩子 
    }
    t++;//标记的值++
    if(from==to){//字符串长度为1（叶节点） 
        return;//免得死循环 
    }
    int root=t-1;//把此次设成根（叶节点已经return了，不用担心叶节点死循环） 
    gou_zao_shu(from,(from+to)/2,root,0);//已验证过开始和结束，搜索左孩子，标记父节点，各位犇犇们可以自己算一算起始或终止哦！ 
    gou_zao_shu((from+to)/2+1,to,root,1);//已验证过开始和结束，搜索左孩子，标记父节点，各位犇犇们可以自己算一算起始或终止哦！ 
    return;//完美
}
void hou_xu_bian_li(int x){//后序遍历函数 注明一下：结构体visit其实并没有什么用，因为一个点只可能走一遍，但并不影响 
    if(n[x].num==0){//超出范围（想了想没太大用，但安全）  
        return;//拽回来 
    }
    if(n[x].sonl==0&&n[x].sonr==0){//叶节点（左右孩子均为0）     
        bool fbi=true;//输出判断的变量 
        for(int i=0;i<n[x].str.length();i++){//循环判断 
            if(n[x].str[i]!=n[x].str[0]){//与第一个不一样 
                fbi=false;//有重的说明有重复，记为false 
                cout<<"F";//混合输出F 
                break;//跳出循环 
            }
        } 
        if(fbi==true){//无重 
            if(n[x].str[0]=='1'){//第一个为1 
                cout<<"I";//输出I 
            }else{//第一个为0 
                cout<<"B";//输出B 
            }
        }
        n[x].visit=1;//标记已经处理过 
        return;//返回上一级 
    }
    hou_xu_bian_li(n[x].sonl);//后序左孩子 （先遍历左） 
    hou_xu_bian_li(n[x].sonr);//后序右孩子 （先遍历右） 
    if(n[n[x].sonl].visit==1&&n[n[x].sonr].visit==1){//左右孩子都被遍历 
        bool fbi=true;//和上面叶节点的做一样处理进行输出 
        for(int i=0;i<n[x].str.length();i++){//循环每个字符 
            if(n[x].str[i]!=n[x].str[0]){//不一样 
                fbi=false;//改值 
                cout<<"F";//输出混合的要求 
                break;//跳出循环 
            }
        }
        if(fbi==true){//无重 
            if(n[x].str[0]=='1'){//按照要求输出 
                cout<<"I";
            }else{
                cout<<"B";
            }
        }
        n[x].visit=1;//标记 
        return;//返回 
    }
    return;//更安全 
}
int main(){//终于到主函数了！ 
    int nothing;//我认为给2^n无用 
    scanf("%d",&nothing);//把这个无用的玩意输入进来 
    cin>>a;//输入字符串 
    if(a.length()==1){//长度为1，注意！有点卡这这里！ 
        if(a=="0"){//为0 
            cout<<"B";//输出B 
        }else{//为1 
            cout<<"I";//输出I 
        } 
        return 0;
    }
    //进行正常处理
	//进行根节点处理 
    n[t].num=1;//整个串标为1，根节点 
    n[t].father_num=0;//无父节点 
    n[t].str=a;//储存字符串 
    t++;//把标记的变量++ 
    //构造字符串树 
    gou_zao_shu(0,a.length()/2-1,1,0);//构造树（左孩子们）
    gou_zao_shu((a.length()+1)/2,a.length()-1,1,1);//构造树（右孩子们） 
    //下面开始遍历
    n[0].visit=1;//设置范围，避免越界 
    n[0].str="3";//设置，更保险 
    hou_xu_bian_li(1);//后序遍历 
    return 0;//完美收尾，代码再见！
}
```
大家理解了吗？**欢迎在评论区留言！**

---

## 作者：Kano (赞：48)

这道题~~就是要我们建树 然后后序遍历输出~~   
但是我对于边建树边输出的算法只能望洋兴叹 （因为不会   

我们来用一种特别淳朴的存树方式来表示这棵二叉树   
$i$表示父节点 $\quad2*i$和$2*i+1$分别表示左儿子和右儿子   
然后让$1$作为根节点

认真观察一下题目 可以看出这是棵满二叉树   
节点的个数是$2^{n+1}-1$个 $(n$是题目里的$n)$ $\quad$所以就知道数组该开多大了   
题目输入的那行01串可以看出是整棵树最底层的节点 认真想一想就知道下标从$2^n$开始   
然后倒着建树就可以了

但求这么多$2$的正整数次幂用循环写会不会太慢啊？   
~~打表大法好！~~   
**位运算大法好！**

在位运算中 `1<<n` 就等价于$2^n$   
所以我们就可以不打表了

【代码部分】

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char node[1<<(10+1)];
char give1(char u){
    return u=='1' ? 'I' : 'B';
}
char give2(char u,char v){
    return u==v ? u : 'F';  //子节点如果相同便相同  不同便是F
}
int n;
void print(int i){      //常规后序遍历输出
    if(i>=(1<<(n+1)))//即不在这棵树中
    	return;
    print(i*2);
    print(i*2+1);
    putchar(node[i])；
}
int main(){
    string s;
    cin>>n>>s;
    for(int i=0;i<s.size();i++)
        node[(1<<n)+i]=give1(s[i]);   //建出最底层树的字母
    for(int i=(1<<n)-1;i;i--)         //倒着建树
        node[i]=give2(node[i*2],node[i*2+1]);  //父节点的字母由他的子节点确定
    print(1);
    return 0;
}
```
~~应该会比打表快？~~

---

## 作者：耶梦加得 (赞：35)

## 一个函数也没有的代码来啦！
在输入的过程中，对于第 k*(2^n) 个数， 我们可以直接把它和兄弟节点“合并”之后**直接输出直接替换**作为父节点
![箭头表示与兄弟节点“合并”为父节点](https://cdn.luogu.com.cn/upload/pic/61476.png)
##### 在一条链上（用箭头表示）的元素都用同一个变量存储

替换的具体方法是：当节点本身与兄弟节点不同时， 父亲节点为F ~~显而易见~~

否则， 两个节点相同，则父节点就是右子节点（即不变）

因为是后序遍历，所以输出两个子节点就可以直接输出父亲啦！

```
#include<bits/stdc++.h>
using namespace std;
int fbi[1025], n;
int p2[11] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}; // 打表2的次方
int main() {
    cin >> n; char t;
    for(int i = 1; i <= p2[n]; ++i) {
        cin >> t; 
        fbi[i] = t - '0';
        if(fbi[i] == 0)printf("B"); 
  		else if(fbi[i] == 1)printf("I"); 
  		else printf("F");
        for(int k = 1; k < 11; ++k) {//合并过程
            if(i % p2[k] == 0){
                if(fbi[i] != fbi[i - p2[k - 1]])fbi[i] = 2;
                if(fbi[i] == 0)printf("B"); 
  		else if(fbi[i] == 1)printf("I"); 
  		else printf("F");
            }
        }
    }
    return 0;
}
```
要注意的是合并过程中k的初值**千万不能设为0**~~不然节点1和谁合并呢~~

还有就是不要不小心输入整数类型，而且千万不要用getchar()（看我的提交记录就知道了）

---

## 作者：二哥啃菜包 (赞：26)

对于这题，各种神奇的大佬都有递归等神奇做法，但是......

这题还有一种更神奇的做法
## 线段树

啊啊，这怎么维护啊？

首先我们知道线段树要可以满足结合律，我们来分析一下：

设$l$到$r$区间需要确定，已确定$l$到$(l+r)/2$和$(l+r)/2+1$到$r$，

那我们发现若左区间是B且右区是B则该区间一定为B。

若有F则一定为F。

若左区间为$I$且右区间为$I$则该区间一定为$I$。

但是我查错的时候把他改掉了，直接改成了暴力枚举9个排列，写到手断......

好吧，talk is cheap,show me the code;
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
int n,len;
const int N=1030;//开到2^10
const int M=N<<4;
char a[N];
struct segment_tree{
    int l,r;
    char w;
}tree[M];
int lc(int k){return k<<1;}
int rc(int k){return k<<1|1;}
void build(int k,int l,int r){
    tree[k].l=l;tree[k].r=r;//叶子节点直接赋值
    if(l==r){
        if(a[l]=='0')tree[k].w='B';
        if(a[l]=='1')tree[k].w='I';
        return;
    }
    int mid=(l+r)>>1;
    build(lc(k),l,mid);
    build(rc(k),mid+1,r);//暴力判断
    if(tree[lc(k)].w=='F' && tree[rc(k)].w=='B')tree[k].w='F';
    if(tree[lc(k)].w=='F' && tree[rc(k)].w=='F')tree[k].w='F';
    if(tree[lc(k)].w=='F' && tree[rc(k)].w=='I')tree[k].w='F';
    if(tree[lc(k)].w=='B' && tree[rc(k)].w=='B')tree[k].w='B';
    if(tree[lc(k)].w=='B' && tree[rc(k)].w=='F')tree[k].w='F';
    if(tree[lc(k)].w=='B' && tree[rc(k)].w=='I')tree[k].w='F';
    if(tree[lc(k)].w=='I' && tree[rc(k)].w=='B')tree[k].w='F';
    if(tree[lc(k)].w=='I' && tree[rc(k)].w=='F')tree[k].w='F';
    if(tree[lc(k)].w=='I' && tree[rc(k)].w=='I')tree[k].w='I';
}
void dfs(int k){
    if(k>len)return;//若超过了线段树大小则可直接返回
    dfs(lc(k));
    dfs(rc(k));
    cout<<tree[k].w;
    return;
}
int main(){
    cin>>n;
    cin>>a;
    len=(1<<n+1)-1;
    n=strlen(a);
    build(1,0,n-1);
    dfs(1);
    return 0;
}

```

---

## 作者：编程入坟指南 (赞：17)

#### 题解区的一股~~泥石流~~清流
看着dalao们的递归算法，本蒟蒻瑟瑟发抖。于是我决定另辟蹊径（其实是用不来递归），用萌新们喜闻乐见的暴力加二维矩阵来解。却卡在了后续遍历,在同机房dalao的指点下，~~与无数头发的祭献~~，我成功模拟了树的后序遍历。

------------
总结一下我的思路，就是暴力的在二维矩阵中建立出树，然后模拟后序遍历。

------------
暴力建树
```
for(int i=0;i<n1;i++)
	{
		k=0;
		for(int j=0;j<n;j+=2)
		{
			if(a[j][i]!=a[j+1][i])
			{
				a[k][i+1]='F';
				k++;
			}
			if(a[j][i]=='B'&&a[j+1][i]=='B')
			{
				a[k][i+1]='B';
				k++;
			}
			if(a[j][i]=='I'&&a[j+1][i]=='I')
			{
				a[k][i+1]='I';
				k++;
			}
			if(a[j][i]=='F'&&a[j+1][i]=='F')
			{
				a[k][i+1]='F';
				k++;
			}
		}
		n/=2;
	}
```
n1为输入的n，n为2的n1次方。大家应该发现‘B’与‘B’结合还是‘B’，‘I’与'I结合还是‘I’，两个不同或有一个是‘F’结合后是‘F’。因此，我的思路为，先将输入的数字转换为‘B’和‘I’，然后将第一层两两分开，暴力求出下一层，然后存入矩阵。

------------
本思路的难点在模拟后序遍历输出。
```
for(int i=0;i<n2;i++)
	{
		cout<<a[i][0];
		g[0]++;
		for(int j=0;j<n1;j++)
		{
			if(g[j]%2==0&&g[j]!=0&&v[g[j]/2-1][j+1]==0)
			{
				g[j+1]++;
				cout<<a[g[j]/2-1][j+1];
				v[g[j]/2-1][j+1]=1;
			}
		}
	}
```
从第一层起一个个输出，用g数组存模拟每一层处理到的数。第一层每输出一个，就扫描每一层有没有处理到逢二的元素，有的话下一层处理的数加1，并输出与这个元素对应的下一层的元素。注意一定要用v数组来记录已经输出的数，不然会重复输出，这非常重要（我才不会告诉你我是在吃午饭时恍然大悟的）。

------------
接下来上完整代码
```
#include<bits/stdc++.h>
using namespace std;
int n1,n=1,k=0;
string a1;
char a[1050][15];
bool v[1050][15];
int g[15];
int main()
{
	cin>>n1;
	cin>>a1;
	for(int i=0;i<n1;i++)n*=2;
	for(int i=0;i<n;i++)
	{
		if(a1[i]=='1')a[i][0]='I';
		if(a1[i]=='0')a[i][0]='B';
	}
	int n2=n;
	for(int i=0;i<n1;i++)
	{
		k=0;
		for(int j=0;j<n;j+=2)
		{
			if(a[j][i]!=a[j+1][i])
			{
				a[k][i+1]='F';
				k++;
			}
			if(a[j][i]=='B'&&a[j+1][i]=='B')
			{
				a[k][i+1]='B';
				k++;
			}
			if(a[j][i]=='I'&&a[j+1][i]=='I')
			{
				a[k][i+1]='I';
				k++;
			}
			if(a[j][i]=='F'&&a[j+1][i]=='F')
			{
				a[k][i+1]='F';
				k++;
			}
		}
		n/=2;
	}
	k=0;
	for(int i=0;i<n2;i++)
	{
		cout<<a[i][0];
		g[0]++;
		for(int j=0;j<n1;j++)
		{
			if(g[j]%2==0&&g[j]!=0&&v[g[j]/2-1][j+1]==0)
			{
				g[j+1]++;
				cout<<a[g[j]/2-1][j+1];
				v[g[j]/2-1][j+1]=1;
			}
		}
	}
}
```


---

## 作者：_somnambulist_ (赞：11)

## P1087   FBI树  题解
   看了前面辣么多大佬用构造树和指针访问，我蒟蒻就发一篇极简递归码。
### 核心思路
首先是怎么判断F,B,还是，I（或者就是FBI？？）（划掉）\
我想过用逆推，就以测试数据为例:       
              
                     1 0 0 0 1 0 1 1
按题意画一棵树

![](C:\Users\lenovo\Desktop)

可以看到，I和I的父亲是I，I和B的父亲是F，B和B的父亲是B，而F的父亲一定是F。
所以可以用以下方法解决。
```cpp
char get_TYPE(char v[],int k)//v是存的数组，k是要求的下标
{
	if(v[k-1]=='F'||v[k-2]=='F)return 'F';
    else
	{
		if(v[k-1]==v[k-2])return v[k-1];
		else return 'F';
	}
}
```
但这样的话输出有点麻烦，所以我就用了一种比较粗暴的方法
```cpp
char get_TYPE(string x)//x是需要判断的字符串
{
	char y;
	y=x[0];
	for(int i=1;i<x.size();i++)
		if(x[i]!=y)return 'F';
	if(y=='0')return 'B';
	else return 'I';
}
```
那么，怎么输出呢？
### 第二个核心思路（所以哪个是核心？）
因为是后续遍历，我一下子又个好主意

边递归边输出！具体我是这么做的
```cpp
void FBI(int beg,int end){//beg是串的开头，end是结尾
	if(beg==end)
	{
		cout<<get_TYPE(a.substr(beg,end-beg+1));//截取子串
		return;
	}
	FBI(beg,(beg+end)/2);//遍历左子树
	FBI((beg+end)/2+1,end);//右子树，别忘了加1
	cout<<get_TYPE(a.substr(beg,end-beg+1));
	return;
}//hualijieshu
```
具体代码自己写吖（其实只剩6行了），AC界面在此 [点我](https://www.luogu.org/recordnew/show/20747324)
第一次写题解，希望管理员通过，

---

## 作者：mohei0 (赞：10)

此题实际可以不用建树，但作死的我还是建了呢~

因为最后一层节点为2^n个，由此推出这个二叉树是满二叉树。

然后就可以用递归来解决啦（包括输出）~

然而我还是写了一个遍历，并没有在递归中一起输出。

递归思路：

从根开始找孩子的值（f是2，b是0，i是1）。

再用孩子的值来推出根的值。

因为是满二叉树，所以某节点的左孩子是某节点乘二，右孩子乘二加一。


附上代码~

    
    
```cpp
    #include<iostream>
    #include<string>
    #include<cmath>
    using namespace std;
    int n,ch[2049]={0},m;
    string ch2;
    //n是叶子有n个节点，m是整棵树有m个节点
    //ch用来存节点是F(2)或B(0)I(1)
    //ch2是最开始输入的字符串
    //这个dg函数s是层数，ll是树的第ll个节点
    int dg(int s,int ll)
    {
        if(s==n+1) return ch[ll];
        int a=dg(s+1,ll*2),b=dg(s+1,ll*2+1);
        //满二叉树某节点左孩子编号是节点编号*2，右孩子*2+1
        if(a==b&&a==1) ch[ll]=1;
        if(a==b&&a==0) ch[ll]=0;
        if(a==b&&a==2) ch[ll]=2;
        if(a!=b) ch[ll]=2;
        return ch[ll];
    }
    //last函数是后续遍历，ll是当前递归到的节点
    void last(int ll)
    {
        if(ll>m) return;
        last(ll*2);
        last(ll*2+1);
        if(ch[ll]==0) cout<<"B";
        if(ch[ll]==1) cout<<"I";
        if(ch[ll]==2) cout<<"F";
    }
    int main()
    {
        cin>>n;
        m=pow(2,n)*2-1;
        cin>>ch2;
        for(int i=0;i<ch2.size();i++) ch[m-i]=ch2[ch2.size()-i-1]-'0';
        dg(1,1);
        last(1);
}
```

---

## 作者：huang_yue (赞：9)

具体操作一下样例，就很容易得到本题的思路，纯粹模拟就可以完成。具体的细节见下面的注释。

(大家好像都喜欢用数组，个人感觉指针挺好理解的，除了析构函数怎么也写不出来)


    
    
    
    
```cpp
    //头文件已省略
    struct Tree { //存储一棵树
        char ty; //自己的类型
        Tree *left, *right; //左右子树
        Tree(): left(0), right(0) {} //构造函数，把左右子树都置为0（空指针），以防垃圾值
    } *root = new Tree(); //树根
    char typeof(const string& s) { //获得s的类型：F，B还是I
        int cnt0 = count(s.begin(), s.end(), '0'); //数0的个数，注意是字符'0'而不是数字0
        int cnt1 = s.size() - cnt0; //总字符数减去0的个数就是1的个数
        if (cnt0 != 0 && cnt1 != 0) return 'F'; //0，1都有，是F
        if (cnt0 == 0) return 'I'; //没有0，也就是只有1，是I
        if (cnt1 == 0) return 'B'; //没有1，也就是只有0，是B
    }
    void construct(Tree* f, string s) { //建树
        if (s.size() == 1) { //长度为1，按照题目要求应该返回
            f->ty = (s == "0" ? 'B' : 'I');
            return;
        }
        //记得要先new出来才能访问其中的字段
        f->left = new Tree(); f->right = new Tree();
        f->ty = typeof(s); //获取自身的类型
        construct(f->left, s.substr(0, s.size() / 2)); //递归建树
        construct(f->right, s.substr(s.size() / 2));
    }
    void post(Tree* f) { //输出后序遍历，左子树+右子树+根结点
        if (f->left) post(f->left);
        if (f->right) post(f->right);
        cout << f->ty;
    }
    int main() {
        int n; cin >> n; //其实这个没用
        string fbi; cin >> fbi;
        construct(root, fbi);
        post(root);
        return 0;
}
```

---

## 作者：小老虎3018 (赞：6)

脑热想着从下到上构建树，似乎也节省不了什么时间……


**判断**

-首先从单个字符的层面（叶子）判断其字符类型并记录数据。（这时deep=0）

-判断完任意一个子树的两个孩子的字符类型（例如第一个和第二个字符,deep=0）后，转而判断该子树的根对应的类型（第一、二个字符组成起来的字符串,deep=1），记录数据。

-如果再上一层子树的右孩子还未判断，则继续判断下一个字符（这时deep又回到0）。


**判断结束**

（如果不想用strlen）到最后，deep就会等于输入的n，判断结束。

或是类似代码中，从第一个字符判断到最后一个字符结束。


**输出**

其实判断的过程和后序遍历的过程是一样的，将判断得出的数据依次输出就好。

（最后发现从下到上构建的唯一好处就是这个……）


代码如下：

```cpp
//luogu.org P1087
#include<cstdio>
#include<cstring>
using namespace std;

struct tree{
    char data;
    //int parent;
}node[2060];
char getstr[1030],
     scantr[11][1030]={0};
int  scande[11][2]={0},top=-1;

void build(int deep,int num){
    //printf("%d\n",deep);
    int temp,i,u;
    if(deep==0){//第一层
        if(getstr[num-1]=='0'){
            scantr[deep][num]='B';
        }
        else{
            scantr[deep][num]='I';
        }
    }
    else{
        bool a=0,b=0,c=0;
        temp=num;
        for(i=deep-1;i>=0;i--){
            temp*=2;
            for(u=temp-1;u<=temp;u++){
                if(scantr[i][u]=='F'){
                    scantr[deep][num]='F';
                    c=true;
                    break;
                }
                else if(scantr[i][u]=='B'){
                    scantr[deep][num]='B';
                    b=true;
                }
                else if(scantr[i][u]=='I'){
                    scantr[deep][num]='I';
                    a=true;
                }
                if(a&&b){
                    scantr[deep][num]='F';
                    c=true;
                    break;
                }
            }
            if(c)
                break;
        }
    }//确认字符串类型
    node[++top].data=scantr[deep][num];
    scande[deep][0]++;//在该深度检索+1
    if(scande[deep][0]%2==0){
        //node[top].parent=top+1;
        //node[scande[deep][1]].parent=top+1;
        build(deep+1,num/2);
    }
    else{
        scande[deep][1]=top;
    }
}

int main(){
    int n,i;
    scanf("%d",&n);
    scanf("%s",&getstr);
    for(i=1;i<=strlen(getstr);i++)
        build(0,i);
    for(i=0;i<=top;i++)
        printf("%c",node[i].data);
    return 0;
}
```

---

## 作者：3water (赞：5)

个人认为还是把这道题写复杂了……

用的是朴素的二叉树，我也不知道怎样形容。~~（于是干脆不形容）~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[12]={1,2,4,8,16,32,64,128,256,512,1024,2048};//数组开到十二，至于为什么接下来会讲
char c,bi[2]={'B','I'};//0为B，1为I
struct fbi{//定义二叉树
	int ch[2];//左右孩子
	char self/*自己的状态（F或B或I）*/,clr[2]/*左右孩子的状态*/;
}tr[2050];
void find(int k){//寻找自己的状态
	if(tr[k].self)return;//如果是叶子节点则直接return
	if(tr[k].clr[0]==tr[k].clr[1])tr[k].self=tr[k].clr[0];//如果左右孩子同为B或同为I，则将自己设为B或I，同为F则为F
	else tr[k].self='F';//不一样则为F
}
void line(int k){//输出，后序遍历
	if(tr[k].ch[0])line(tr[k].ch[0]);//先输出左子树
	if(tr[k].ch[1])line(tr[k].ch[1]);//后输出右子树
	cout<<tr[k].self;//左右子树输出后输出本身
}
int main(){
	cin>>n;
	for(int i=a[n];i<=a[n+1]-1;i++){//若只开到11会爆
		cin>>c;
		tr[i].self=bi[c-'0'];//初始定义叶子节点为B或I
		tr[i/2].ch[i%2]=i;//为父亲节点定义孩子（是否存在）
		tr[i/2].clr[i%2]=tr[i].self;//为父亲节点定义孩子的状态
	}
	for(int i=a[n]-1;i;i--){
		find(i);//用孩子的状态决定自己的状态
		tr[i/2].ch[i%2]=i;//继续找自己的父亲，并为他定义孩子
		tr[i/2].clr[i%2]=tr[i].self;//自己的父亲的孩子的状态
	}
	line(1);//输出结果
}//33行
```


---

## 作者：知光 (赞：4)

我有一个较小空间的方法。

------------

在一边输入一边处理的过程中之前的数据其实已经没有价值了，并不需要一个a[1024]来记录它们。
由于最终构建的是一个二叉树，我们每输入两个数据就处理一次，也就是输出这两个数据对应字符和合成后的对应字符，再判断前面输入过的所有叶节点是否能构成一个完整的二叉树，如果可以就输出这个树的类型。

是不是有点蒙？莫慌，以样例为例。
![](https://imgsa.baidu.com/forum/w%3D580/sign=cef0ecc379c6a7efb926a82ecdfbafe9/20a5c4029245d688fddefbb8abc27d1ed31b24a3.jpg)
![](https://imgsa.baidu.com/forum/w%3D580/sign=a09373d814d5ad6eaaf964e2b1ca39a3/648e1f7e9e2f07085ab0621ce624b899a801f2cb.jpg)
nice！简直完美！
代码奉上。
```cpp
#include<bits/stdc++.h> 
using namespace std;
int b[10];//记录每层有多少个未合并的节点
char c[10][2];//如图
char unify(char a,char b){//合成
	if(a=='F'||a!=b)
	return 'F';
	else if(a=='I')
	return 'I';
	else return 'B';
}
void check(){//检查是否可以构成一个树
	for(int i=1;i<=10;i++)
	if(b[i]==2)
	{
	 c[i+1][b[i+1]]=unify(c[i][0],c[i][1]);
	 cout<<c[i+1][b[i+1]];
	 b[i]=0;
	 b[i+1]++;
	 check();	
	}
	return ;
}

int main(){
	int n,t=1,k=0,x;
	scanf("%d",&n);
	if(n==0){//特判一下
		cin>>x;
		if(x==1)
		cout<<'I';
		else
		cout<<'B';
		return 0;
	}
	t=t<<n;
	for(int i=1;i<=t;i++)
	 {
	 	cin>>c[0][k];
	    if(c[0][k]=='1')
	    c[0][k]='I';
	    else
	    c[0][k]='B';
	  k++;
	   if(k==2)
	  {
	  	k=0;
	  	c[1][b[1]]=unify(c[0][0],c[0][1]);
	  	cout<<c[0][0]<<c[0][1]<<c[1][b[1]];
	  	b[1]++;
	  	check();
	  }
	 }
	 return 0;
}
```


---

## 作者：pyyyyyy (赞：4)

博客食用效果更佳

[来玩啊](https://www.cnblogs.com/pyyyyyy/p/11095551.html)

~~看博客首页有惊喜~~


#题目链接

[P1087 FBI树](https://www.luogu.org/problemnew/show/P1087)

#思路



#思路一

首先题目中说明了"01"串的长度是$2^n$,也就是说这是一棵满二叉树，也就是可以用$tree[i]$来表示根$tree[2*i]$来表示左孩子，$tree[2*i+1]$来表示右孩子

所以思路就有了直接递归把树的节点弄成"F","B","I".

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<string>
#include<cstring>
using namespace std;
const int maxn=999999999;
const int minn=-999999999;
inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int tree[100010];
char s[10001];
int len;
int build(int l,int r,int num) {
	if(num==2*len) {
		return 0;
	}
	if(l==r) {
		if(s[l]=='0') {
			tree[num]='B';
			return 'B';
		} else {
			tree[num]='I';
			return 'I';
		}
	}
	char ll=build(l,(l+r)/2,2*num),rr=build((l+r)/2+1,r,2*num+1);
	if(ll=='F'||rr=='F') {
		tree[num]='F';
		return 'F';
	} else {
		if(ll != rr) {
			tree[num]='F';
			return 'F';
		} else {
			if(ll == 'B')	{
				tree[num] = 'B';
				return 'B';
			} else {
				tree[num] = 'I';
				return 'I';
			}
		}
	}
}
void print(int x) {
	if(tree[2*x]) print(2*x);
	if(tree[2*x+1]) print(2*x+1);
	cout<<char(tree[x]);
}
int main() {
	int x=read();
	scanf("%s",s+1);
	len=strlen(s+1);
	build(1,len,1);
	print(1);
	return 0;
}

```

#思路二

仔细观察会发现只要先递归左边在递归右边最后输出就是树的后序遍历，然后就直接计算字串里的$01$数量就行了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<string>
#include<cstring>
#define ll long long int
using namespace std;
const int maxn=999999999;
const int minn=-999999999;
inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int a[10001];
int n;
char s[382479];
void dfs(int l,int r) {
	if(l<r) {
		int mid=(r-l)/2;
		dfs(l,l+mid);
		dfs(l+mid+1,r);
	}
	int sum0=0;
	int sum1=0;
	for(int i=l; i<=r; ++i) {
		if(a[i]==0) sum0++;
		else sum1++;
	}
	if(!sum1) cout<<'B';
	else if(!sum0) cout<<'I';
	else  cout<<'F';
}
int main() {
	cin>>n;
	scanf("%s",s+1);
	int len=strlen(s+1);
	for(int i=1; i<=len; ++i) {
		a[i]=s[i]-'0';
	}
	dfs(1,len);
	return 0;
}
```

#优化

利用前缀和来优化计算01的数量的循环
如果全是$0$则$f[r]-f[l-1]$相减为$0$;
如果全是$1$则$f[r]-f[l-1]$相减是$r-l+1$;
反之是$0,1$都有

```cpp


#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<string>
#include<cstring>
#define ll long long int
using namespace std;
const int maxn=999999999;
const int minn=-999999999;
inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int n;
char s[382479];
int f[1000101];
void dfs(int l,int r) {
	if (l!=r) {
		int mid=(l+r)/2;
		dfs(l,mid);
		dfs(mid+1,r);
	}
	if(f[r]-f[l-1]==r-l+1) {
		cout<<'I';
	} else if(f[r]-f[l-1]==0) {
		cout<<"B";
	} else cout<<"F";
}
int main() {
	cin>>n;
	scanf("%s",s);
	n=(1<<n);
	for(int i=1; i<=n; i++)
		f[i]=f[i-1]+s[i-1]-'0';
	dfs(1,n);
	return 0;
}

```

---

## 作者：zhengrunzhe (赞：4)

# FBI联邦调查局树：

l代表左指针，r是右指针 (l,r)区间可以表示一段树

当l!=r(有子树)时，将区间分为两段，左右子树，分别表示为(l,(l+r)/2),((l+r)/2+1,r)

详细见代码：

```cpp
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
int n,i;
string s;
char fbi(int L,int R)   //返回是F还是B还是I
{
    if (find(s.begin()+L,s.begin()+R+1,'1')==s.begin()+R+1)return 'B';   //如果没找到'1'，那么就是只有'0'，就是一棵B树
    if (find(s.begin()+L,s.begin()+R+1,'0')==s.begin()+R+1)return 'I';    //如果没找到'0'，那么就是只有'1'，是I树
    return 'F';   //如果找到了'0'也找到了'1'，那么就是F树
}
void bl(int l,int r)   //后序遍历
{
    if (l!=r)   //如果可以分割
    {
        bl(l,(l+r)/2);   //左边
        bl((l+r)/2+1,r);   //右边
    }
    cout<<fbi(l,r);   输出
}
int main()
{
    cin>>n>>s;  //奇妙的读入  其实n并没有什么(luan)用
    bl(0,s.length()-1);   先从一整串0到2^n-1，之后再左右分割 因为定义的是string，所以直接s.length()-1，所以n没用.
    return 0;   //华丽结束
}
```

---

## 作者：dingcx (赞：4)

好多大佬都是边算边输出，然而我太弱了，只好分开做。

**我这个思路有点像——**

## 线段树

~~是不是很奇葩？~~

方法：

1.定义一个数组(a)记录每个节点的状态，0表示B，1表示I，2表示F；

2.读入应该读数组最底层 $2^{n}$到$2^{n+1}-1$，然后从$2^n-1$到$0$依次一层一层遍历；

3.输出从1往后遍历，到最底层就输出，左右子节点都遍历完了也输出。

提示：位运算节省大量时间，代码中1<<n相当于$2^{n}$，i<<1相当于2i，i<<1|1相当于2i+1

如果还没懂，请看下面的超短代码：

```cpp
#include<cstdio>
using namespace std;
int a[5000],n,s[3]={'B','I','F'};//打表输出
char c;//下面输入用
void dfs(int fa){//递归输出，建议先看main函数
	if(fa>=(1<<n)){//边界条件：如果到底层
		printf("%c",s[a[fa]]);//输出
		return;//直接返回
	}
	dfs(fa<<1);//遍历左子节点
	dfs(fa<<1|1);//遍历右子节点
	printf("%c",s[a[fa]]);//输出此节点
}
int main(){
	scanf("%d\n",&n);
	for(int i=(1<<n);i<(1<<(n+1));i++){
		scanf("%c",&c);//必须用字符输入
		a[i]=c-'0';//转换成树并存进数组
	}
	for(int i=(1<<n)-1;i>0;i--){//往根节点遍历
	    if(a[i<<1]==a[i<<1|1]) a[i]=a[i<<1];//只有都为0或1时不是2
		else a[i]=2;//否则都是2
	}
	dfs(1);//输出
	return 0;//华丽结束
}
```

---

## 作者：LJLYROCK (赞：3)

一看就知道是递归

（我很菜打不出超短代码。。。如果想要超短代码可以去其他巨佬的题解）

还不了解二叉树的可以去网上自学一下，还是比较简单的。不了解后序二叉树规则是没法做这道题的

输入一个字符串，全0输出B，全1输出I，都有输出F。 然后一分为二建立两个子树，一直到字符串长度为1。求这个二叉树的倒序输出

~~以前死活不会回过头来看好简单。。。可能是做过了P1030先序排列吧~~

第一次做我以为要把每个节点求出来存储到数组里然后再后序输出结果难度飞升，但其实根本不需要


------------
原理：递归代码：
```
void go (char a[], int l) {   //a[]为字符串，l为字符串长度
	if (l == 1) {     //当字符串长度为1时停止分裂return    
	    if (a[1] == '0') cout << "B";//判断
		else cout << "I"; 
		return;
	} 
	bool tfl = false, tfy = false;//tfl判断是否有0，tfy判断是否有1
    char b[1025], c[1025];//建两个char数组，b为前半段即左子树，c为后半段即右子树
	for (int i = 1; i <= l; i++) {
	    if (i <= l / 2) b[i] = a[i];//前半段
		else c[i - l / 2] = a[i];//后半段
		if (a[i] == '1') tfy = true;//判断
		if (a[i] == '0') tfl = true;  
	} 
	go (b, l / 2);
	go (c, l / 2); 
	if (tfy && tfl) cout << "F";//判断
	else if (tfy) cout << "I";
	else if (tfl) cout << "B"; 
} 
```


以1010为例
```c
      1011
   10      11
1   0    1    1
            F（7）
      F（3）         I（6）
  I（1）   B（2）  I（4）    I（5）
  后序：IBFIIIF(遍历顺序已标注）

```
（编号为二叉树深度）

1.比如1010，很明显是F

2.然后先不输出，先遍历左子树10（F）

3.还是不输出先遍历左子树1（I）

3.发现不能再分（长度为1时停止）输出 I

2.回到10 继续遍历右子树0（B）

3.发现不能再分，输出B

2.回到10， 所有子树遍历完毕，于是输出F

1.回到1010，遍历右子树11（I）

2.先不输出，继续遍历左子树1（I）

3.发现不能再分，输出I

2.回到11， 遍历右子树1（I）

3.发现不能再分，输出I

2.回到11，子树全部遍历完毕，于是输出I

1.回到1011，输出F


------------

递归代码如下（实在没啥好讲的，代码都有注释）
```c
#include<bits/stdc++.h>
using namespace std;

int n;
int len;
char a[1025];

void go (char a[], int l) {   //a[]为字符串，l为字符串长度
	if (l == 1) {     //当字符串长度为1时停止分裂return    
	    if (a[1] == '0') cout << "B";//判断
		else cout << "I"; 
		return;
	} 
	bool tfl = false, tfy = false;//tfl判断是否有0，tfy判断是否有1
    char b[1025], c[1025];//建两个char数组，b为前半段即左子树，c为后半段即右子树
	for (int i = 1; i <= l; i++) {
	    if (i <= l / 2) b[i] = a[i];//前半段
		else c[i - l / 2] = a[i];//后半段
		if (a[i] == '1') tfy = true;//判断
		if (a[i] == '0') tfl = true;  
	} 
	go (b, l / 2);//注意！由于是后序输出所以先遍历到最底层再逐步往上，这个是个逻辑问题搞不懂的可以把随便一个字符串带进去试试
	go (c, l / 2); 
	if (tfy && tfl) cout << "F";//判断
	else if (tfy) cout << "I";
	else if (tfl) cout << "B"; 
} 
 
int main () {
	cin >> n;
    len = pow (2, n); 
    for (int i = 1; i <= len; i++) cin >> a[i]; //输入
    go (a, len);//运行
    return 0;
} 
```


---

## 作者：FirCoder (赞：3)

很基础的一道构建树然后遍历树的题，先依据题意将树构建，然后再后序遍历。
如果有大佬知道改进方法，请不吝赐教。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef struct tree
{
    char v;
    struct tree *l = NULL;
    struct tree *r = NULL;
} Tree; // 树的结构体
Tree *Create(int l, int length); // 函数参数为所求“01”字符串的起始位置和长度
void Post(Tree *root);
string nums; // 字符串存放“01”串
int main()
{
    Tree *root;
    int n;
    cin >> n;
    cin >> nums;
    root = Create(0, nums.size()); // 构造
    Post(root); // 后序遍历
    return 0;
}
Tree *Create(int l, int length) 
{
    Tree *root;
    root = (Tree *) malloc (sizeof(Tree));
    string temp;
    temp.assign(nums, l, length); // 将所求段子符串给temp
    // cout << temp << endl;
    if (length == 1) //长度为1就开始返回
    {
        if (temp == "1") root->v = 'I';
        else root->v = 'B';
    }
    else
    {
        if (temp.find("0") != temp.npos && temp.find("1") != temp.npos) // 如果0 1都存在 
            root->v = 'F';
        else if (temp.find("0") == temp.npos) // 只有 1
        root->v = 'I';
        else root->v = 'B'; // 只有 0
        root->l = Create(l, length/2);
        root->r = Create(l+length/2, length/2);
    }
    return root;
}
void Post(Tree *root)
{
    if (root == NULL) return ;
    Post(root->l);
    Post(root->r);
    printf("%c", root->v);
    return ;
}
```
[博客](https://www.luogu.org/blog/zrfnb/)

---

## 作者：wucstdio (赞：3)

关于这道题，我有一个全新的解法。

首先，按照题目要求，我画出了题目中的树：

F
/       \

F            F

/  \         /  \

F     B      F     I

/ \   / \    / \  / \

I  B  B B   I  B I   I

分析这棵树，我得到了几个重要结论：

1、如果一个节点的左右子节点都是B，则这个节点也是B，如果一个节点的左右子节点都是I，则这个节点也是I；其余，都是F。

2、若后序遍历，则每输出两个第i层的节点，下一个节点必定是第i-1层的节点。换句话说，这其实是二进制。

综上，我们只需要保存每一层的2个节点，就可以输出这棵树的后序遍历。为了简便，用0代表B，1代表I，2代表F，开一个int型的sum数组存储，相当于二进制的每一个数位。然后就一位一位地扫描每一个节点，根据满二进一的原则，输出后序遍历。

```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
int n,sum[12][5];//存储每一个节点。第一个下标表示第几层（简便起见，0表示最底层），第二个下标表示第几个节点，用sum[i][0]表示第i层已经存了几个节点
bool a[(1<<10)+5];//原序列
int main()
{
    scanf("%d",&n);
    string num;
    cin>>num;//然而我到现在也不会用scanf输入string
    for(int i=0;i<(1<<n);i++)。
    {
        if(num[i]=='0')a[i]=0;
        if(num[i]=='1')a[i]=1;
    }
    for(int i=0;i<(1<<n);i++)//扫描原序列
    {
        if(a[i]==0)
        {
            printf("B");
            sum[0][++sum[0][0]]=0;//在第0层存储
        }
        if(a[i]==1)
        {
            printf("I");
            sum[0][++sum[0][0]]=1;//在第0层存储
        }
        int j=0;
        while(sum[j][0]==2)//满二进一
        {
            sum[j][0]=0;
            if(sum[j][1]==1&&sum[j][2]==1)//左右子节点都是I
            {
                printf("I");
                sum[j+1][++sum[j+1][0]]=1;//进位
            }
            else if(sum[j][1]==0&&sum[j][2]==0)//左右子节点都是B
            {
                printf("B");
                sum[j+1][++sum[j+1][0]]=0;//进位
            }
            else//其它情况
            {
                printf("F");
                sum[j+1][++sum[j+1][0]]=2;//进位
            }
            j++;
        }
    }
    printf("\n");
    return 0;
}
```

---

## 作者：Tgotp (赞：3)

水了一发线段树（其实是不知道怎么做）

按题目要求建树；

首先能看出，如果分成了一个单数的话，肯定只能是i或者b。

然后儿子如果一样肯定就是i或者b。如果不一样的话就是f。

按要求建树以后就可以利用后序遍历寻找了，其实还可以支持修改，不过没写。



c++代码如下：









```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 10000 +5;
int n;
char a[N];
struct node
{
    int left,right,fa;
    char val;
}tree[N];
void build(int id,int l,int r)
{
    tree[id].left=l,tree[id].right=r;
    if(l==r)
    {
        if(a[l]=='0') tree[id].val='B';
        else tree[id].val='I';
    }
    else
    {
        int mid=(l+r)/2;
        build(id*2,l,mid);
        build(id*2+1,mid+1,r);
        if(tree[id*2].val=='F' || tree[id*2+1].val=='F')tree[id].val='F';
        else if((tree[id*2].val == 'B'&& tree[id*2+1].val=='I')||(tree[id*2].val == 'B'&&tree[id*2+1].val=='I'))tree[id].val='F';
        else if(tree[id*2].val=='I'&& tree[id*2+1].val=='I')tree[id].val='I';
        else if(tree[id*2].val=='B'&& tree[id*2+1].val=='B')tree[id].val='B';
        else tree[id].val='F';
    }
}
void found(int id,int l,int r)
{
    if(tree[id].left==tree[id].right)printf("%c",tree[id].val);
    else
    {
        int mid=(tree[id].left+tree[id].right)/2;
        found(id*2,l,mid);
        found(id*2+1,mid+1,r);
        printf("%c",tree[id].val);
    }
}
int get(int i)
{
    int ans=1;
    while(i--)ans=2*ans;
    return ans;
}
int main()
{
    cin>>n;getchar();
    n=get(n);
    scanf("%s",a+1);
    build(1,1,n);
    found(1,1,n);
    return 0;
}
```

---

## 作者：Maxwell (赞：3)

//http://image18-c.poco.cn/mypoco/myphoto/20160807/00/18324203120160807001346049\_640.jpg

//至少我是钻研了题意很久，最后看到这幅图才恍然大悟


```cpp
#include<iostream>
#include<string>
using namespace std;
string str;
int n;
void dfs(int sta, int end)   
{
    //由树梢进行建树的过程其实就是后序遍历的过程，故可在过程中直接输出。
    int mid = (end + sta) / 2;//中段位置
    if (sta != end)//串长大于1时继续搜索
    {
        dfs(sta, mid);//先搜左，再搜右
        dfs(mid + 1, end);
    }
    int sum0 = 0, sum1 = 0;
    for (int i = sta; i <= end; i++)//统计每个子串中0与1的出现次数，存入sum
    {
        if (str[i] == '0')sum0++;
        else sum1++;
    }
    //end-sta+1:子串长度
    if (end - sta + 1 == sum0)cout << 'B';//子串长度等于0出现的次数 则输出B
    else if (end - sta + 1 == sum1)cout << 'I';//子串长度等于1出现的次数 则输出I
    else cout << 'F';//01均出现 输出F
}
int main()
{
    cin >> n >> str;
    int len = str.size();
    dfs(0, len - 1);
    cout << endl;
    return 0;
}
```

---

## 作者：SiTer (赞：3)

```cpp

//2015-10-12 22:50
/*
洛谷1087 FBI树
本题地址： http://www.luogu.org/problem/show?pid=1087

题目描述
我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。
FBI树是一种二叉树，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2^N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：
1)      T的根结点为R，其类型与串S的类型相同；
2)      若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。
现在给定一个长度为2^N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。
输入输出格式
输入格式：
第一行是一个整数N（0 <= N <= 10），第二行是一个长度为2^N的“01”串。

输出格式：
包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。

输入输出样例
输入样例#1：
3
10001011
输出样例#1：
IBFBBBFIBFIIIFF
说明
对于40%的数据，N <= 2；
对于全部的数据，N <= 10。

noip2004普及组第3题
*/

/*
简单的建树，建的过程中直接判断FBI并赋值节点就行了，01串只存在于Build函数中 
没仔细学二叉树怎么建的 就套线段树结构了
由于string方法的存在开始给出的N完全没有用
可以学习一下string操作
*/

#include <iostream>
#include <string>
#include <cstdio>
using namespace std;
const int MAX=5000;
struct Node{
    char sign;
    int left,right;
    Node():left(0),right(0){};
}tree[MAX];

char judge(string list)
{
    if(list.find("0") == list.npos)
        return 'I';
    if(list.find("1") == list.npos)
        return 'B';
    return 'F';
}

void Build(int i,string list)
{
    tree[i].sign=judge(list);
    if(list.size() == 1) return ;
    tree[i].left=i<<1;
    tree[i].right=(i<<1)+1;
    int mid=list.size()/2;
    string ltemp,rtemp;
    ltemp=list.substr(0,list.size()/2); 
    rtemp=list.substr(list.size()/2,list.size()+1);
    Build(i<<1,ltemp);
    Build((i<<1)+1,rtemp);
}

void DFS(int i)
{
    if(tree[i].left)
        DFS(tree[i].left);
    if(tree[i].right)
        DFS(tree[i].right);
    cout<<tree[i].sign;
}

int main()
{
    string list;
    int N;
    cin>>N>>list;
    Build(1,list);
    DFS(1);
    return 0;
}


```

---

## 作者：lxzy_Zby (赞：2)

首先我们考虑要进行后序遍历，也就是说先遍历左子树，再遍历右子树，再遍历父亲。

所以我们再分治递归的过程中可以选择 (l,l+(r-l)/2)和(1+l+(r-l)/2,r)两种情况。

第一种是左子树，第二种是右子树。

递归到只剩下一个的时候也就是l==r的时候到达边界值。

我们就可以结束递归改为输出结果。

用一个tmp表示有几个0

用一个tmp1表示有几个1

那我们可以知道

当tmp=0时，有0个0，表示这个子串全是1，输出I

反之，当tmp1=0的时候，有0个1，表示这个子串全是0，输出B

当tmp!=0并且tmp1!=0的时候子串既有0又有1，输出F

#当进行到这里的时候，我们的程序就写完了。

代码如下

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int const Maxn=10000;
int n,a1[Maxn<<1],l;
char a[Maxn<<1];
void work(int l,int r){
    if(l<r){//分状态
        work(l,l+(r-l)/2);
        work(1+l+(r-l)/2,r);
    }
    int tmp,tmp1;//计数
    tmp=tmp1=0;
    for(int i=l;i<=r;i++)
        if(a1[i])tmp1++;
        else tmp++;
    if(!tmp) printf("I");
    else if(!tmp1) printf("B");
    else printf("F");
}
int main()
{
    scanf("%d",&n);
    scanf("%s",&a[1]);//首地址为1的字符串
    l=strlen(&a[1]);//字符总长度
    for(int i=1;i<=l;i++)//把字符串变成int型数组
        a1[i]=a[i]-'0';
    work(1,l);//分治递归
    return 0;

}

```

---

## 作者：何卓然 (赞：2)

本题难度主要在于建树，我们发现由于得到的序列长度是2的幂，所以得到的树是一棵完全二叉树，


我们按照层数对每个节点逐一进行编号，可以发现，一个节点（编号为 i）的左儿子编号为 ;  i << 1        右儿子编号为： (1 << i) | 1


可以直接生成出要求的树，进行后序遍历时加以判断即可。


---

## 作者：比热鸮 (赞：2)

//很劣质的模拟型解法，对数学好的初学者友善

//做了错误化处理，以防抄袭（但不影响理解）




```cpp
#include<cstdio>
char a[20000],fbi[20000];//a存二进制，fbi存结果，开大点没坏处
void h(int y,int x)//后序输出，这里不会百度“后序遍历”吧
{
    if(y*2<=x)
        h(y*2,x);
    if(y*2+1<=x)
        h(y*2+1,x);
    printf("%c",fbi[y]);
    return;
}
int main()
{
    int n;
    scanf("%d%s",&n,&a);
    int i,m=1,j,k,p,l;//开足变量，后面介绍
    bool y,e;//用于判断01存在
    for(i=0;i<=n;i++) m*=2;//m存fbi树长度2^(n+1)-1，之所以不减一偷懒写法
    j=m/2;//j存当前fbi节点对应二进制树长度，这里预设值2^n全长
    k=1;//k存对应长为j的fbi节点个数，长为全长自然预设1个
    l=0;//l存位置，用于写入fbi树
    n=j;//n存二进制树长度
    for(i=1;i<=k;i++)//处理对应长为j二进制数的fbi节点
    {
        y=0;
        e=0;//标记归零
        l++;//处理下一个节点，l递增
        p=i-1;
        for(p*=j;p<i*j;p++)//对该二进制数遍历，确定0,1存在性
        {
            if(a[p]=='0')    y=1;
            if(a[p]=='1')    e=1;
            if(y&&e)    break;//防止大数tle，实际上从子节点反向推直接避免这一问题
```
/\*即
子节点为I,I->父节点I

等共九种情况\*/

```cpp
        }
        if(y&&e)//根据遍历结果写入
            fbi[l]='F';
        if(y&&!e)
            fbi[l]='B';
        if(!y&&e)
            fbi[l]='I';
        if(l<m)//处理完毕对应长为j二进制数的fbi节点，若j可以更短处理下一j的值
                    //这里判断语句有多种写法，读者不妨一一尝试
        {
            k*=2;
            j/=2;
            i=0;
        }
    }
    h(1,m);
    return 0;
}
```

---

## 作者：Excim (赞：2)

注释应该很清楚了吧

```cpp
#include<cstdio>
#include<cstring>
int n,i;
char a[2100],c[5000];//数组开大点总是没有错的，a是初始数据,c是树 
void hou(int x)//十分正常的后序遍历 
{
    if(c[x]!='B'&&c[x]!='I'&&c[x]!='F') return;
    hou(x*2);
    hou(x*2+1);
    printf("%c",c[x]);
}
int main()
{
    scanf("%d%s",&n,a+1);
    int len1=1<<n,len2=(2<<n)-1;//len1是a的长度,len2是c的长度 
    int j=len1;
    for(i=len2;i>=len1;i--)
    {
        if(a[j]=='0') c[i]='B';
        if(a[j]=='1') c[i]='I';// 比较树的最后一层，此时这些都是叶节点（即没有子节点） 
//        printf("%d %d %c %c\n",i,j,a[j],c[i]); 输出中间结果 请忽略 
        j--;
    }
    for(i=len2;i>=3;i-=2)
    {
        if(c[i]==c[i-1]&&c[i]!='F') c[i/2]=c[i];//比较子树，如果都是0（两个B）或者都是1（两个I），那么根也是全0或者全1 
        else c[i/2]='F';//否则根就是“混合序列”，也就是同时有0和1，然后根的的根的根（好绕口）也是“混合序列” 
    }
    hou(1);
    return 0;
}
```

---

## 作者：CmhDL (赞：1)

~~话说看到那么多dalao在建树做，可是这题好像不用建树吧...~~

分享一下我的做法：

## 二分递归转换输出

下面我们一个个来看。

### 一、转换部分

题目中说到要把对应的字符串转换成‘F’、‘B’和‘I’输出，于是我首先就写了一个字符串转换函数：

```cpp
char check(string x){ //这里我用了STL中的string来做，不懂的童鞋也可以用char数组！
	bool h0=false,h1=false;//有0和有1的标记
	int len=x.size();
	for(re int i=0;i<len;++i)
		if(x[i]=='0')h0=true;
		else h1=true;
	if(h0&&h1)return 'F'; //有0也有1返回‘F’
	else if(h0)return 'B'//只有0返回‘B’
	else return 'I'; //只有1返回‘I’
}
```
### 二、二分递归+输出部分

这里其实无需建树后再后序遍历，只要把一个字符串分两半，再分两半，再分两半...（滑稽

代码：

```cpp
void bl(string x){//对字符串做处理
	int len=x.size();//取长度
	if(len==1){//如果已经无法再分，就直接输出其类型
		putchar(check(x));
		return;
	}
	int mid=len/2;//取中间点，二分递归调用
	bl(x.substr(0,mid));//先输出左右两半的类型（substr函数是c++库函数，可以取string类型字符串的子串）
	bl(x.substr(mid));
	putchar(check(x));//最后输出自身类型
}
```
### 三、主体部分

只需在~~mian~~main函数里输入n和字符串后调用bl函数即可！

$\color{green}\text{完整AC代码：}$
```cpp
#include <bits/stdc++.h>//偷了个懒，用了一下万能头文件【捂脸】
#define re register//把register加在int前可以稍微卡卡常（详细内容请自行百度）
using namespace std;
int n;
string s;
char check(string x){
	bool h0=false,h1=false;
	int len=x.size();
	for(re int i=0;i<len;++i)
		if(x[i]=='0')h0=true;
		else h1=true;
	if(h0&&h1)return 'F';
	else if(h0)return 'B';
	else return 'I';
}
void bl(string x){
	int len=x.size();
	if(len==1){
		putchar(check(x));
		return;
	}
	int mid=len/2;
	bl(x.substr(0,mid));
	bl(x.substr(mid));
	putchar(check(x));
}
int main(){
	cin>>n>>s;//string类型用cin输入很方便（忽略空白符' '和'\n'），推荐！
	bl(s);
	return 0;
}
```
最后：

题解有什么问题请尽管留言！

## THE END

---

## 作者：苏拉威西3号 (赞：1)

# 蒟蒻题解第二弹！！

刚在题解区逛了一圈，各路大老玩什么的都有，不过好像没有多少人用字符串来做啊。

## 分析

二叉树性质：

- 对于第n层的结点编号，是从2^(n-1)到2^n-1;
- 对于任意结点，设其坐标为x，则其左儿子坐标为2*x，其右儿子坐标为2*x+1;

## 实现

将题目要求读入后，按从下到上的顺序，将二叉树的每行存入数组中，且将最后一层与其余各层分开计算。
```
for(int i=(1<<n);i<=(1<<(n+1))-1;i++)
	{
		if(a[k++]=='0')
			b[i]='B';
		else 
			b[i]='I';
	}
```
这是对于树最后一层的实现

而对与其余各层```

```
for(int i=n-1;i>=0;i--)
		for(int j=(1<<i);j<=(1<<(i+1))-1;j++)
		{
			if(b[2*j]=='B'&&b[2*j+1]=='B')
				b[j]='B';
			else if(b[2*j]=='I'&&b[2*j+1]=='I')
				b[j]='I';
			else 
				b[j]='F';
		}
```
从下到上逐层填充，若他的左右儿子不相同，则赋值为'F',相同则等于为其儿子的值，将整个二叉树存入数组中后按其后序输出。
```
void visit(int node)
{
	if(node>(1<<(n+1))-1)
		return;
	visit(node*2);
	visit(node*2+1);
	cout<<b[node];
}
```
对于每一个结点，由于是按后序输出，所以先找他的左儿子，再找他的右儿子，最后输出他。

整个代码是这样的

```
#include<bits/stdc++.h>
using namespace std;
int n;
char a[3001],b[3001];
void build(char *s,int n)
{
	int k=0;
	for(int i=(1<<n);i<=(1<<(n+1))-1;i++)
	{
		if(a[k++]=='0')
			b[i]='B';
		else 
			b[i]='I';
	}
	for(int i=n-1;i>=0;i--)
		for(int j=(1<<i);j<=(1<<(i+1))-1;j++)
		{
			if(b[2*j]=='B'&&b[2*j+1]=='B')
				b[j]='B';
			else if(b[2*j]=='I'&&b[2*j+1]=='I')
				b[j]='I';
			else 
				b[j]='F';
		}
}
void visit(int node)
{
	if(node>(1<<(n+1))-1)
		return;
	visit(node*2);
	visit(node*2+1);
	cout<<b[node];
}
int main()
{
	cin>>n;
	cin>>a;
	build(a,n);
	visit(1);
	return 0;
}
```
如有错误，还请指正

---

## 作者：Maktub (赞：1)

这个题建树太麻烦，显然也不需要建树，因为是后序遍历，很显然，读入两个就能多输出一个，最底层为第一层的话，这样第二层就多了个节点，第一层输出4个，第二层又能输出一个，这样第三层又能输出一个....

有思路就可以打了，尽管很麻烦，但或许比建树简单。

很显然，有2的N次方个节点的话树的深度为N，按照上面的思路来设计解决问题。

用dep[i]来存第i层的节点是否有两个，如果有两个，就将dep[i]更新为0，同时dep[i+1]++。然后再向上判断就可以了。

这样就解决了输出的问题，那输出什么这么判断呢？用一个tree[i][k]保存第i层第k个字母，dep[i]==2时，tree[i][k]与tree[i][k-1]就能合并输出一个字母了。同时更新tree[i+1][k/2]。

具体代码如下，代码中有注解：

```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int dep[22];
int n;
char tree[22][2222];
int main(){
	char c;
	cin>>n;
	int s=1;
	for(int i=1;i<=n;i++)s*=2;
	n=s;//处理节点的个数
	for(int i=1;i<=n;i++){//用上述思路来解决问题，避免建树。
		cin>>c;
		if(c=='1'){
			cout<<'I';
			tree[1][i]='I';//更新最底层的节点
		}
		if(c=='0'){
			cout<<'B';
			tree[1][i]='B';
		}
		int top=1;
		dep[top]++;//最底层的节点增加。
		int k=i;
		if(dep[top]==2){如果可以合并
			while(dep[top]==2){向上不断更新。
				dep[top]=0;
			if(tree[top][k]!=tree[top][k-1]||tree[top][k]=='F'||tree[top][k-1]=='F'){
				cout<<'F';
				tree[++top][k/2]='F';//更新上一层的节点
				dep[top]++;//上一层的节点+1，如果此时该层节点为2，就能继续向上更新。
				k/=2;//合并后上一层的节点位置
			}
			else{//三种情况
				if(tree[top][k]=='B'){
					cout<<'B';tree[++top][k/2]='B';
					dep[top]++;
				k/=2;
				}
				else{
					cout<<'I';tree[++top][k/2]='I';
					dep[top]++;
					k/=2;
				}
			}
			}
			
		}
	}
	return 0;
}
```

30ms跑完不算太慢，可能理解代码不太容易（我想的时候就很难受），但思路是非常简单暴力的。

---

## 作者：q2368126021 (赞：1)

##### 此题可用递归来做，可以在先建出左子树，然后判断，在建造右子树，然后再行判断，最后还要在判断根节点一次。

```cpp
#include<iostream>

using namespace std;

int n;

string st;

int judge(int l,int r){

	int a=0,b=0,c=0;
	int i;
    
	for(i=l;i<=r;i++){//开始判断其子串
	 if(st[i]=='0')a=1;
	 if(st[i]=='1')b=1;
	 if(a&&b){
	  c=1;
	  break;
      }
	}
    
	if(c){cout<<"F";return 0;}
	if(a){cout<<"B";return 0;}
	if(b){cout<<"I";return 0;}//输出
    
}
//以上都是判断，以下便是建树过程
int build(int left,int right){

	int mid=(left+right)/2;
	if(left==right)return 0;
	build(left,mid);//建左子树
	judge(left,mid);//判断
	build(mid+1,right);//建右子树
	judge(mid+1,right);//判断右子树
}
int main(){

	cin>>n;
	cin>>st;
	build(0,st.length()-1);
	judge(0,st.length()-1);//由于其没有判断根节点，故而还要再判断根节点1一遍
}

---

## 作者：孤独的观测者 (赞：1)

## 思路：按照题意建树，后根遍历，具体思路见代码注释

```java
package 洛谷;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class P1087FBI树
{

	public static void main(String[] args) throws NumberFormatException, IOException
	{
		BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in));
		int n=Integer.parseInt(bufferedReader.readLine());
		String string=bufferedReader.readLine();
		P1087Tree root=cTree(string);
		lastRoot(root);
	}

	/**
	 * 后根遍历
	 * @param root
	 */
	private static void lastRoot(P1087Tree root)
	{
		if (root.leftchild!=null)
		{
			lastRoot(root.leftchild);
		}
		if (root.rightchild!=null)
		{
			lastRoot(root.rightchild);
		}
		System.out.print(root.i);
	}

	/**
	 * 依据题目创建树
	 * @param string
	 * @return
	 */
	private static P1087Tree cTree(String string)
	{
		P1087Tree ree=new P1087Tree();
		//叶子节点
		if (string.length()==1)
		{
			//B类型 一下类推
			if (string.contains("0"))
			{
				ree.setI('B');
			}
			else 
			{
				ree.setI('I');
			}
			ree.leftchild=null;
			ree.rightchild=null;
			return ree;
		}
		//节点
		if (!string.contains("1"))
		{
			ree.setI('B');
		}
		else if(!string.contains("0")){
			ree.setI('I');
		}
		else {
			ree.setI('F');
		}
		//递归创建
		ree.leftchild=cTree(string.substring(0,string.length()/2));
		ree.rightchild=cTree(string.substring(string.length()/2));
		return ree;
	}
	
}

class P1087Tree
{
	char i;
	P1087Tree leftchild;
	P1087Tree rightchild;
	public char getI()
	{
		return i;
	}
	public void setI(char i)
	{
		this.i = i;
	}
	public P1087Tree getLeftchild()
	{
		return leftchild;
	}
	public void setLeftchild(P1087Tree leftchild)
	{
		this.leftchild = leftchild;
	}
	public P1087Tree getRightchild()
	{
		return rightchild;
	}
	public void setRightchild(P1087Tree rightchild)
	{
		this.rightchild = rightchild;
	}
	@Override
	public String toString()
	{
		return "P1087Tree [i=" + i + ", " + (leftchild != null ? "leftchild=" + leftchild + ", " : "")
				+ (rightchild != null ? "rightchild=" + rightchild : "") + "]";
	}
	
}

```
###### 一想到还有四篇思想报告没写就只能边写边想题了（逃

---

## 作者：dj114133643 (赞：1)

模拟线段树的模板，无比简洁！！！！

叶子节点直接输出，

非叶子节点等孩子完成后也完成了，就该输出

--------------------------------------------------------------我是华丽的分割线----------------------------------------------------------------

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
int a[1100];
char kind[4100];
void fib(int l,int r,int id)
{
    int sum=0,i;
    for(i=l;i<=r;i++)
        sum+=a[i];
    if(sum==r-l+1) kind[id]='I';
        else if(!sum) kind[id]='B';
            else kind[id]='F';
    if(l==r) {printf("%c",kind[id]);return;}
    fib(l,(l+r)/2,id*2);
    fib((l+r)/2+1,r,id*2+1);
    printf("%c",kind[id]);
    return;
}
int main()
{
    int n,i,now=1;
    scanf("%d\n",&n);
    n=(now<<n);
    for(i=1;i<=n;i++)
        scanf("%1d",&a[i]);
    fib(1,n,1);
    return 0;
}
```

---

## 作者：C2H6O (赞：1)

然而这道题并不需要建树，你建立树的过程中其实实现了对每个节点dfs，只需处理完每条枝之后输出该节点对应类型就是后序遍历的实现。

```cpp
#include <iostream>
#include <string>
using namespace std;
string read;
int n, length=1;
void build(string st,int depth) {
    if (!depth) {//depth=0说明已经划分为单个字符
        switch (st[0]) {
        case '0':cout << "B"; break;
        case '1':cout << "I"; break;
        }
        return;
    }
    int len = st.size() / 2;
    build(st.substr(0, len), depth - 1);
    build(st.substr(len, len), depth - 1);   //划分子树
    char tp;
    bool f = 1;
    tp = st[0];
    for (int i = 1; i < len * 2; i++) {
        if (st[i] != tp) {
            f = 0;
            break;
        }
    }
    if (f == 0) cout<<"F";
    else if (tp=='1') cout<<"I";
    else cout<<"B";            //相当于后序遍历输出节点类型
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) length *= 2;
    cin >> read;
    build(read,n);
    cout << endl;
    return 0;
}
```

---

## 作者：Hydroxyl (赞：1)

主要的思路就是从下网上建树然后就是这样了

读入然后刚开始就是分开的节点逐渐往上 只要两者之间有个f那么他的双亲节点就是f 如果ib混合双亲还是f 都i或都b那就是原本的就好了


————————————————————————————code by cjz————————————————————————




```cpp
var s:ansistring;
    n,i,sum,j,last,t,hand,endl,m:longint;
    a:array[0..1024] of char;
procedure build(deep,num:longint);
begin
    if deep<1 then exit;      少于1 就好了啊这不解释
    if num mod 2 =0 then exit
    else
    begin
      if (a[num-1]='B') and (a[num]='B') then
         begin a[(num-1) div 2]:='B'; end;
       if (a[num-1]='I') and (a[num]='I') then
         begin a[(num-1) div 2]:='I'; end;
       if (a[num-1]='F') and (a[num]='F') then
         begin a[(num-1) div 2]:='F'; end;
       if (a[num-1]='I') and (a[num]='B') then
         begin a[(num-1) div 2]:='F'; end;
       if (a[num-1]='B') and (a[num]='I') then
         begin a[(num-1) div 2]:='F'; end;
       if (a[num-1]='F') and ((a[num]='B') or (a[num]='I'))  then
         begin a[(num-1) div 2]:='F'; end;
       if ((a[num-1]='B') or (a[num-1]='I')) and (a[num]='F') then
         begin a[(num-1) div 2]:='F'; end;
       if (a[num-1]='F') and (a[num]='F') then
         begin a[(num-1) div 2]:='F'; end;
    end;                       恶心的打表
    build(deep-1,(num-1) div 2);      继续
end;
procedure pout(k:longint);      后序遍历输出答案 前序中序也都是一样的我下面给贴上来
begin
    if k>j then exit;
    pout(k*2);
    pout(k*2+1);
    write(a[k]);
end;
begin
    assign(input,'fbi.in');
    reset(input);
    assign(output,'fbi.out');
    rewrite(output);
    readln(n);
    readln(s);
    j:=1;
    m:=1;
    j:=j<<n+1;
    m:=m<<n;
    dec(j);
    for i:=1 to length(s) do
    if s[i]='1' then a[j-m+i]:='I'
              else a[j-m+i]:='B';        //第一步的处理
    for i:=j-m+1 to j do
    build(n+1,i);      建立一个树
    pout(1);       后序输出
    close(output);
end.
```
————————————————————————————————————————————————————————
这道题的思路让我想到比赛的单淘赛制的那个成绩表一样

说好的前序和中序




```cpp
procedure pout(k:longint);    
begin
    if k>j then exit;
    write(a[k]);
    pout(k*2);
    pout(k*2+1);
 end;
procedure pout(k:longint);    
begin
    if k>j then exit;
    pout(k*2);
    write(a[k]);
    pout(k*2+1);
 end;
```
温馨提示千万不要打成writeln 会死人的





---

## 作者：shenyi1343395317 (赞：1)

来一个新解法，各位新年快乐哦~~~~~   10ms，比平均要慢2ms  但是好理解.~\(≧▽≦)/~啦啦啦

用二维数组构建树，然后再遍历

程序如下

```cpp
program sss;
  var s:ansistring;                           //pas党记得用ansistring哦.
      i,j,m,n,k:longint;
      a:array[-5..10000,-3..15] of string;                          //习惯开大数组.... 注意：此解法用char会自动留出空格而爆0
      flag2:array[-9..10000,-3..16] of boolean;
  function flag1(f,h:longint):boolean;                                        //此函数用来判断一个节点的叶子节点是否被遍历过
  var i,j:longint;
  begin
  flag1:=false;
  if h=1 then exit(true);
  if ((flag2[2*f-1,h-1]=false) and (flag2[2*f,h-1]=false)) then exit(true);
  end;
  procedure dfs(f,h:longint);                     //f 表示 节点编号，h表示二叉树的层数（叶子节点为1）
  begin
  if h>n+1 then exit;                               //n 还是有点用的，用来做终止条件
  if flag1(f,h) then
   begin
   write(a[f,h]);                                         //如果叶子节点已经遍历完了，就遍历根节点
   flag2[f,h]:=false;                                  //标记一下
   if (f mod 2)=0 then dfs(f div 2,h+1)    //递归向上搜索
    else dfs(f+1,h);                               //递归向右搜索
   end else dfs(2*f-1,h-1);                   //如果叶子节点没有遍历完，遍历子节点
  end;
  procedure op(a1,a2,a3,a4,a5,a6:longint);   //参数比较多..  这个过程用来构建二叉树
  var i:longint;                                            //a1,a2,a3,a4表示两个子节点，a5，a6表示父亲节点
  begin
  if ((a[a1,a2]='B') and (a[a3,a4]='B')) then a[a5,a6]:='B'
   else if ((a[a1,a2]='I') and (a[a3,a4]='I')) then a[a5,a6]:='I'
    else a[a5,a6]:='F';                              //依题意就这么构建
   end;
  begin
  readln(n);
  readln(s);
  for i:=1 to length(s) do
   if s[i]='1' then a[i,1]:='I' else a[i,1]:='B';   //首先构建完所有叶子节点
  k:=length(s);
  for i:=1 to k do
   for j:=1 to 11 do flag2[i,j]:=true;
  j:=1;
  i:=1;                    //初始化
  repeat                      //两个repeat 构建二叉树
  inc(j);
   k:=k div 2;              //还好是满二叉树，父亲节点数目可由此得到
   if k=0 then break;   //终止条件
   repeat
   op(2*i-1,j-1,2*i,j-1,i,j);
   inc(i);                       //在这里，由两个儿子构建父亲节点
   until i=k+1;
  i:=1;
  until j=12;          //其实，这个终止条件没什么用..
  dfs(1,1);              //遍历即可
  readln;
end.
```

---

## 作者：kisah (赞：1)




```cpp
var
  s:ansistring;  //string大小不够，所以用ansistring
  a:array[1..1025] of boolean;
  n,i:longint;
procedure dfs(l,r:longint);//字符串左右两点
begin
 if l = r then begin if a[l] then write('I') else write('B'); exit; end;//把字符串长度为1作为边界
 dfs(l,(l+r) div 2);  //后序
 dfs((l + r) div 2 + 1,r);
 for i:=l to r do
  if a[l] xor a[i] then begin write('F'); exit; end;//有一个不同即为不同
 if a[l] then write('I') else write('B');
end;
begin
  readln(n);//其实n是一个可有可无的数
  readln(s);
  for i:=1 to length(s) do
   begin
    if s[i] = '1' then a[i]:=true  //用boolean类型做更方便
    else a[i]:=false;
   end;
  dfs(1,length(s));//开始dfs
end.
```

---

## 作者：nkoi18 (赞：1)

无意当中想到了一种较巧妙的解法

先利用输入的字符串直接求出叶子类型

而易看出：

1两儿子为b父亲为b;

2两儿子为i父亲为i；

否则为f；

附上代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
int tree[3000];
void solve(int n,int i)//后序遍历
{
    if(2*i<n)
      {
       solve(n,2*i);
       solve(n,2*i+1);
      }
    if(tree[i]==-1)
      cout<<"B";
    if(!tree[i])
      cout<<"F";
    if(tree[i]==1)
      cout<<"I";
}
int main()
{
    int n,k,z;
    char s[2000];
    cin>>n;
    scanf("%s",s);
    k=pow(2,n);
    z=k*2-1;
    for(int i=k;i<=z;i++)//先求出叶子
      if(s[i-k]=='0')
        tree[i]=-1;
      else
        tree[i]=1;
    for(int i=k-1;i>0;i--)//判断父亲
      if(tree[2*i+1]*tree[2*i]==1)  
        tree[i]=tree[2*i];
      else
        tree[i]=0;
    solve(z,1);
    return 0;
}
```

---

## 作者：lcx64579 (赞：1)

递归地分割串。记F=0,B=-1,I=1.

int divide(string 当前的子串, int 这个子串的长度){

如果长度为1{

是0就输出B，是1就输出I。相应的，return -1或1.

}否则{

将这个串中分为两部分，分别divide，得到结果0,-1或1.

如果两部分的结果一样，相应地输出F,B或I。

如果不一样，输出F。

相应的，return 0,-1或1.

    }
}
读入的n直接变为2^n（真实的串长）传给divide。





```cpp
#include<iostream>
#include<string>
#include<cstdio>    //putchar()
#include<cmath>   //pow()
using namespace std;
// F 0     B -1     I 1
int n;
string str;
int divide(string s, int len){
    if(len==1){
        if(s[0]=='1'){
            putchar('I');
            return 1;
        }
        else{
            putchar('B');
            return -1;
        }
    }
    int a = divide(s.substr(0,len/2), len/2);
    int b = divide(s.substr(len/2, len), len/2);
    if(a==b){
        switch(a){
            case 0:{
                putchar('F');
                return 0;
                break;
            }
            case -1:{
                putchar('B');
                return -1;
                break;
            }
            case 1:{
                putchar('I');
                return 1;
                break;
            }
        }
    }else{
        putchar('F');
        return 0;
    }
}
int main(){
    cin>>n;
    cin>>str;
    n=pow(2, n);
    divide(str, n);
    return 0;
}
```

---

## 作者：Fizzmy (赞：1)

仔细观察可以发现输出的顺序就是树的后序遍历

然后就可以递归遍历树

用一个数组cnt[l][r]表示l-r这个区间用什么字母表示

cnt[l][r]可以通过cnt[l][mid]和cnt[mid+1][r]求得

###
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,sum=1;
bool a[2000];
char cnt[1025][1025];
int dfs(int l,int r)
{
    int mid=(l+r)>>1;
    if (l==r)
    {
        if (a[l]==0) cnt[l][r]='B'; else cnt[l][r]='I';
        cout<<cnt[l][r];
        return 0;
    }
    dfs(l,mid);
    dfs(mid+1,r);
    if (cnt[l][mid]==cnt[mid+1][r] && cnt[l][mid]=='B') cnt[l][r]='B';
        else if (cnt[l][mid]==cnt[mid+1][r] && cnt[l][mid]=='I') cnt[l][r]='I';
            else cnt[l][r]='F';
    cout<<cnt[l][r];//直接输出，存储是为了记录状态
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++) sum*=2;
    for (int i=1;i<=sum;i++)
        scanf("%1d",&a[i]);
    dfs(1,sum);
//    for (int i=1;i<=t;i++) cout<<cnt[i];
}
```

---

## 作者：hz1624917200 (赞：1)

和楼下大神一样，都是递归求解。

但是做了个优化：

字符串在过程里整个传来传去的很浪费时间，特别是如此长的ansistring……

但是可以只传下标啊，把左右下标放进参数里就比整个字符串快多了

下附蒟蒻代码勿笑：

[codep ]



```cpp
program p1087;
var
  s:ansistring;
  n:longint;
procedure work(l,r,n:longint);
var
  i,mid:longint;
  flag:char;
begin
  flag:='.';
  for i:=l to r do
    begin
      if flag='F' then break;
      if s[i]='0' then
        if (flag='.') or (flag='B') then
          flag:='B'
        else
          flag:='F'
      else
        if (flag='.') or (flag='I') then
          flag:='I'
        else
          flag:='F';
    end;
  if n=0 then
    begin
      write(flag);
      exit;
    end;
  mid:=(l+r) div 2;
  work(l,mid,n-1);
  work(mid+1,r,n-1);
  write(flag);
end;
begin
  {assign(input,'input.txt');
  reset(input);
  //} 
  readln(n);
  readln(s);
  work(1,length(s),n);
  writeln;
end.
[/codep ]
```

---

## 作者：Ouaoan (赞：1)

这题可以直接dfs搜索，从根节点开始向下，遇到了叶子节点就打印。

叶子节点是B还是I取决于输入的串。如果这个节点的编号是i，如果a[i]为1，就打印 'I' ,否则打印 'j'。

没有必要把树存储起来的，回溯的时候打印自然就是后续遍历的啦。

搜索的时候别忘了先左后右。


```cpp
<source lang="cpp">
#include<stdio.h>
#include<iostream>
using namespace std;
int n;    //'0''1'串的长度
int d;    //二叉树的高度
int a[1025]= {0};    //存储'0''1'的串
int sqrt2(int x) {    //计算二的x次方
    int y=1;
    for(int i=1; i<=x; i++) {
        y*=2;
    }
    return y;
}
int search(int x,int y) {    //搜索左右子树 
    if(x==d) {
        if(a[y]==1) {
            cout<<"I";
            return 1;
        } else {
            cout<<"B";
            return 0;
        }
    }
    int i=search(x+1,2*y-1),j=search(x+1,2*y);
    if(i==1&&j==1) {
        cout<<"I";
        return 1;
    } else if(i==0&&j==0) {
        cout<<"B";
        return 0;
    } else {
        cout<<"F";
        return 2;
    }
}
int main() {
    cin>>n;    //输入
    d=n+1;     //计算深度
    n=sqrt2(n);    //将n改成实际长度
    for(int i=1; i<=n; i++) {    //输入串a
        char x;
        cin>>x;
        a[i]=x-'0';
    }
    search(1,1);
    return 0;
}
</source>
```

---

## 作者：fl_334 (赞：1)

//提交题解时俨然发现和下面那位大叔的算法貌似差不多。。。做了个优化。。

```cpp
var
        n:longint;
        s:ansistring;
procedure ss(s1:ansistring);
var
        l,x,y:longint;
begin
        l:=length(s1);
        if l>1 then
        begin
        ss(copy(s1,1,l div 2));           //搜左子树
        ss(copy(s1,l div 2+1,l));        //搜右子树
        end;
        x:=pos('0',s1);      //楼下你是没学过pos函数咩。。。
        y:=pos('1',s1);    //找1，找0
        if y=0 then write('B');     //没有1，说明全是0
        if x=0 then write('I');      //没有0， 则说明全是1；
        if (x>0) and (y>0) then write('F');       //既有1，又有0，要输出f
end;
begin
        readln(n);
        readln(s);
        ss(s);
end.
```

---

## 作者：kczno1 (赞：1)

1 预处理：f[i,j]表示串中i到j所属的类型 O（N2)

2 搜索:按后续遍历左中右的顺序，输出。O（log2(N))


```delphi

const m:array[0..10] of longint=
(1,2,4,8,16,32,64,128,256,512,1024);
 c:array['0'..'1']of char=('B','I');

var
  n,i,j:longint;
  a:array[1..1024] of char;
  f:array[1..2048,1..2048] of char;

procedure try(l,r:longint);
begin
 if r>l then
 begin
  try(l,(l+r) div 2);
  try((l+r) div 2+1,r);
 end;
 write(f[l,r]);
end;

begin
 readln(n);  n:=m[n];
 for i:=1 to n do
 begin
  read(a[i]);
  f[i,i]:=c[a[i]];
 end;
 for i:=2 to n do
  for j:=1 to n-i+1 do
   if (f[j,j+i-2]='B')and(a[j+i-1]='1') then f[j,j+i-1]:='F'
   else
   if (f[j,j+i-2]='I')and(a[j+i-1]='0') then f[j,j+i-1]:='F'
   else f[j,j+i-1]:=f[j,j+i-2];
 try(1,n);
end.

```

---

## 作者：难上加兰 (赞：1)

数组方式：

```delphi

program fbi(input,output);
var a:array[1..10000]of '0'..'1';
    n,i,l:integer;
    treeb,treei:boolean;
    tree:char;
procedure bianli(x,y:integer);               {递归过程，x,y为所要遍历的树的叶结点在数组a中位置}
 begin
  if x=y then case a[x] of
               '0':write('B');
               '1':write('I');
              end                  {输出叶结点}
         else begin
               bianli(x,x+(y-x+1) div 2-1);          {遍历左子树}
               bianli(x+(y-x+1)div 2,y);                {遍历右子树}
               treei:=false;treeb:=false;
               for i:=x to y do if a[i]='0' then treeb:=true else treei:=true; {求出树的父结点}
               if treei and treeb then tree:='F'
                else begin
                      if treei then tree:='I';
                      if treeb then tree:='B'              {输出父结点}
                     end;
               write(tree);
              end
 end;
begin
 assign(input,'fbi.in'); reset(input); 
 assign(output,'fbi.out');rewrite(output); 
 readln(n);l:=1;
 for i:=1 to n do l:=l*2;
 for i:=1 to l do read(a[i]);                   {读入数据,l为字符串长度}
 bianli(1,l);writeln;
 close(input); close(output)
end.


```

---

## 作者：kkke (赞：1)

做这道题时要考虑到二叉树的特性，那就是第n行的第一个数是a[2^n],这一行共有2^n个数，这样的话从最底层开始计算这棵树就简单得多了；如果一个节点的2个儿子不一样，那它一定是F节点，如果一样的话那它类型一定和儿子相同；这样就能不用把每个字符串存下来了，而且不用挨个判断了.

以下给出我的程序：


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int n;
char kkke[3000];
int hehe[2000];
int ac[]={1,2,4,8,16,32,64,128,256,512,1024,2048};

void work(int a)
{
    if(hehe[a]==-1)
    {
        work(a*2);
        work(a*2+1);
        if(hehe[a*2]==hehe[a*2+1])hehe[a]=hehe[a*2+1];
        else hehe[a]=2;
    }
    switch(hehe[a])
    {
        case 0:
            printf("B");
            break;
        case 1:
            printf("I");
            break;
        default:
            printf("F");
    }
}

int main()
{
    scanf("%d",&n);
    scanf("%s",kkke);
    memset(hehe,-1,sizeof(hehe));
    for(int i=ac[n],j=0;i<ac[n+1];i++,j++)hehe[i]=kkke[j]-48;
    work(1);
    printf("\n");
    return 0;
}

```

---

## 作者：DLYJ (赞：0)

### 来源
### NOIP2004普及组第三题
分析：DFS模拟，然后search_value(x,y)表示输出用x, y组成的树的后序遍历，返回0就是都是0，1就是都是1，2就是0，1都有。。

下面给出AC代码：

```cpp
 #include <bits/stdc++.h>
 using namespace std;
 ];
 ]={'B','I','F'};
 inline int read()
 {
     ,f=;
     char ch=getchar();
     ')
     {
         if(ch=='-')
             f=-;
         ch=getchar();
     }
     ')
     {
         x=x*+ch-';
         ch=getchar();
     }
     return x*f;
 }
 inline int search_value(int st,int ed)
 {
     if(st==ed)
     {
         printf(']);
         ';
     }
     ;
     int x=search_value(st,mid);
     ,ed);
     if(x==y)
     {
         printf("%c",write[x]);
         return x;
     }
     else
     {
         printf("F");
         ;
     }
 }
 int main()
 {
     int n;
     n=read();
     cin>>str;
     search_value(,strlen(str)-);
     ;
 }
```
# 树：
递归枚举当前01串，返回值分三种：

返回1，表示当前01串为I串，即全部为1
返回0，表示当前01串为B串，即全部为0
返回3，表示当前01串为F串，即全部为3
于是你就问了，为什么F串要返回3而不返回-1或2呢

我们先把递归的格式搞清楚，每次递归的是这个01串的左子树与右子树
左子树与右子树有以下几种返回值：

左 0 1 3

右 0 1 3

若左右子树全部返回0，返回值为0时，当前串为B串
若左右子树全部返回1，返回值为2时，当前串为I串
而当前串为F串有许多情况：0+3，1+3，3+3，0+1
你会发现以上值有一个共同特点：不等于0或2

这就是为什么F串返回3
然后就没什么了，在递归过程中按左-右-根的顺序即可


貌似这题是二叉树的板子题，可以建立一棵二叉树，学习一下

 ```cpp
 #include<cstring>
#include<iostream>
using namespace std;
char s[(1<<10)+10];
int work(int l,int r)
{
    if(l==r)
    {
        if(s[l]=='0') cout<<"B";
        else cout<<"I";
        return s[l]=='1';
    }
    int sl,sr,m=(l+r)/2;
    sl=work(l,m);
    sr=work(m+1,r);
    if(sl+sr==0)
    {
        cout<<"B";
        return 0;
    }
    else if(sl+sr==2)
    {
        cout<<"I";
        return 1;
    }
    else
    {
        cout<<"F";  
        return 3;
    }
}

int main()
{
    cin>>s>>s;
    work(0,strlen(s)-1);
    return 0;
}
```


---

## 作者：花落丶宸星 (赞：0)

### 这道题我一开始觉得很难，但是后来摸透了规律。。。
当我过了这道题后，看了一下题解，发现我的代码可能会有点长，但是好理解。      
我的思路是：这是一棵二叉树，我们可以将其模拟成线段树。  ~~我一看到题就这么想的~~          
其次，我们可以利用线段树的pushup操作，完成FBI树的建造。
最后，我们利用分治的思想，对树进行遍历，输出后序遍历即可。
上代码（我是P党）：
```pascal
var
  sum:array[0..70000]of char;//模拟线段树
  ch:char;
  n,x,x1:longint;
procedure pushup(rt:longint);
begin
  if (sum[rt*2]='F')or(sum[rt*2+1]='F')then//建造FBI树
    sum[rt]:='F' else
    if ((sum[rt*2]='B')and(sum[rt*2+1]='I'))or((sum[rt*2]='I')and(sum[rt*2+1]='B'))then
      sum[rt]:='F' else
      if sum[rt*2]=sum[rt*2+1] then
        sum[rt]:=sum[rt*2];
end;
function two(n:longint):longint;
var
  i:longint;
  s:longint;
begin
  s:=1;
  for i:=1 to n do
    s:=s*2;
  exit(s);
end;
procedure build(l,r,rt:longint);//建树操作
var
  m:longint;
begin
  if l=r then
  begin
    read(ch);
    if ch='1' then
      sum[rt]:='I' else
      sum[rt]:='B';
    exit;
  end;
  m:=(l+r)div 2;
  build(l,m,rt*2);
  build(m+1,r,rt*2+1);
  pushup(rt);
end;
procedure find(rt:longint);//遍历操作
begin
  if rt*2>x1 then
  begin
    write(sum[rt]);
    exit;
  end;
  if rt*2<=x1 then
    find(rt*2);
  if rt*2+1<=x1 then
    find(rt*2+1);
  write(sum[rt]);
end;
begin
  readln(n);
  x:=two(n); x1:=two(n+1)-1;
  build(1,x,1);
  find(1);
end.

```
~~突然发现主程序好短~~
希望管理员大大能给我通过。
今天是2018/10/13，希望大家NOIPRP++。

---

## 作者：人殇物已非 (赞：0)

我这个FBI树完全就是一个暴力的模拟。

主要思路是从树的根开始，根为1号点，然后
依次标号，这里用到了一个小技巧，因为是一个二叉树，而且是满二叉树，所以完全满足满二叉树的性质。

即：自己的父亲节点==自己的节点数/2；而一个节点的两个儿子分别是自己的节点数* 2 和自己的节点数* 2+1；
如：根为1，左儿子为2，右儿子为2+1=3；
或者一个节点为6，则左儿子为12，右儿子为12+1=13；

例子：         

。。。。。。。。。。1。。。。。。。。。。//不这样1就过不来。。

               2             3
           4      5       6      7
          8 9   10 11   12 13  14 15
（就是样例输入）
这样我们就可以从1开始，遍历每个叶子，然后算出它的type，最后按需输出。

其实呢。。我是先建树，再遍历。
建树时，需要不断二分一个叶子它父亲的那个01串，再算出自己的。
若每个叶子都带一个01串，空间太大没必要，我们发现，原来01串的顺序不会变化，
因此，我们只要每个叶子带上一个“l”和“r”,分别是左端点和右端点，而a[i]（l->r）就是它自己的01串。

然后就需要判断它的type了，这里有很多方法，我的很粗暴，把这个01串求和sum，然后因为r-l+1就是它的长度，比较它的sum和它的长度，若相等，则全是1，若sum是0，则全是0，若sum！=0且sum<长度，则有0有1；

最后：
就剩下最后一个问题了，就是这个遍历顺序，其实非常简单，两行代码就搞定，
我们若从左往右（那个字符串）会发现。。好难啊。。不知道怎么办，但是若从右往左，会发现就找到了一个规律：从根开始，先一直向右到头，再回来一个向左，然后再回来一个向左，回到根后向左一个马上向右，再向左一个马上向右，到结束。

是不是懵了，其实总结一下就一句话：能向右就向右，不能就向左；
就是这样：
```cpp
void print_tree(int k){
    ptf[++o]=le[k].type;
    if(k*2+1<lon) print_tree(k*2+1);//k*2+1就是右儿子，即向右
    if(k*2<lon) print_tree(k*2);//lon是叶子总数再加1，
    //如果能满足向右（第一个if）,就会一直递归到不能，出来那个函数时
    //就相当于往回走了一个。
```
完全的代码：
```cpp
#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
struct leaf{
    int type;  //0:B;1:I;2:F;
}le[2000];//可以表示在树上的位置，1为根,2、3往后.... 
int n,a[2000],lo=1,lon,l,r,o=0;
int ptf[2000];
inline int mi(int a,int b)
{
    if(b==0) return 1;
    int c=a;
    for(int i=2;i<=b;i++)
    c*=a;
    return c;
}
inline int get_l(int k);
inline int get_r(int k){
    if(k==1) return lo;
    if(k%2==0) return (get_r(k>>1)+get_l(k>>1))/2;
    return get_r(k>>1);
}
inline int get_l(int k){
    if(k==1) return 1;
    if(k%2==0) return get_l(k>>1);
    return (get_r(k>>1)+get_l(k>>1))/2+1;
}
void bulid_tree(int k){
    if(k==lon) return;
    l=get_l(k);
    r=get_r(k);
    
    int tot=0;
    for(int i=l;i<=r;i++)
        tot+=a[i];	
    le[k].type=2;
    if(tot==r-l+1) le[k].type=1;
    if(tot==0) le[k].type=0;

    
    bulid_tree(++k);
}
void print_tree(int k){
    ptf[++o]=le[k].type;
    if(k*2+1<lon) print_tree(k*2+1);
    if(k*2<lon) print_tree(k*2);
}
int main(){
    cin>>n;
    lo=mi(2,n);
    for(int i=1;i<=lo;i++)
        scanf("%1d",&a[i]);
    lon=lo*2;
    bulid_tree(1);
    print_tree(1);
    for(int i=o;i>=1;i--)
    {
        if(ptf[i]==1) printf("I");
        if(ptf[i]==0) printf("B");
        if(ptf[i]==2) printf("F");
    }
    return 0;
} 
```

---

## 作者：moongazer (赞：0)

很明显，这是一道在树上的递归，需要用到字符串，具体实现很简单。

**技巧：**函数的返回值有时很重要，比如这一题。

将函数返回值设为char型，即'F'，'B'和'I'，这样就不用将01串扫一遍来获得答案了。

由于是后续遍历输出，即“左右根”，只用先递归在输出就行了

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstdlib>
#include<algorithm>
using namespace std;
char a[2000];
char gwork(int n,int l);//声明递归函数，n为01串长度，l为起始地址
int main(){
    int n,i;
    char c;
    cin>>n;
    n=(1<<n);//01串的长度
    for(i=1;i<=n;i++){
        cin>>c;
        if(c=='0'){//处理01串，0为B，1为I
            a[i]='B';
        }else{
            a[i]='I';
        }
    }
    gwork(n,1);//调用递归函数
    cout<<endl;
    return 0;
}
char gwork(int n,int l){//定义递归函数
    char L,R;//左右字数的“FBI值”
    if(n==1){//若长度为1，就不递归下去
        L=R=a[l];
        goto con;
    }
    L=gwork(n/2,l);//递归左子树
    R=gwork(n/2,l+n/2);//递归右子树
    con:;
    if(L==R){//如果左右子树“FBI”值相同，输出，返回相同的那个值
        cout<<L;
        return L;
    }else{//若不同，则为F，即有1有0
        cout<<'F';
        return 'F';
    }
}
```

---

## 作者：wanzzhehe (赞：0)

看了看上面给的题解，长的都挺麻烦的，短的呢又强行模拟线段树还开数组。。


实际上可以直接函数处理完字符串后返回字符串的类型，然后如果左右两个字符串类型相等，那么当前字符串就一定是这个类型；如果不相等，那么就一定是F串


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

inline char getc(void) { 
    static char buf[1 << 18], *fs, *ft;
    return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}

inline int read(void) { 
    int res = 0;
    char tmp = getc();
    while(!isdigit(tmp)) tmp = getc();
    while(isdigit(tmp))
        res = ((res + (res << 2)) << 1) + (tmp ^ 0x30),
        tmp = getc();
    return res;
}

inline int read(char *s) { 
    char *p = s;
    while(!isgraph(*p = getc()));
    while(isgraph(*(++p) = getc()));
    *p = '\0';
    return p - s;
}

char Build(int l, int r);

char s[1050];
int N;

int main() { 
    N = 1 << read();
    read(s + 1);
    putchar(Build(1, N));
    return 0;
}

char Build(int l, int r) { 
    char ret;
    if(l ^ r) { 
        char a1, a2;
        int M = (l + r) >> 1;
        putchar(a1 = Build(l, M));// 输出左子串类型
        putchar(a2 = Build(M + 1, r));// 输出右子串类型
        if(a1 == a2) ret = a1; // 如果左右两个子串的类型一样
        else ret = 'F'; // 如果左右两个子串的类型不一样，那么当前子串的类型一定是F
    } else if(s[l] == '0') ret = 'B'; // 子串长度为1
    else ret = 'I';
    return ret;
}
```

---

## 作者：RyanFox (赞：0)

关于如何理解这道题，楼下已经解释的超级清楚了，所以这段跳过。

那么接下来才是我要讲的。。。


依题目看，这颗树一定是完全二叉树。

我们不必要去打后序遍历（滑稽）。


这棵树的先序遍历很简单，在函数里能直接取到先序，但后序麻烦，于是我就尝试避开打后序的代码，用先序得到正确答案。

以样例为例子，


10001011


先序可以得到FFFIBBBBFFIBIII，然而答案是IBFBBBFIBFIIIFF。

将先序反过来得到IIIBIFFBBBBIFFF，这就是从右下角的叶节点开始的后序遍历（后序遍历都是从左下角的叶节点开始的）。

但是从左下角的叶节点开始的后序遍历才能得到答案。

那么我们就可以将先前的数据处理一遍，将数据反过来。


11010001


得到先序，再从后向前输出就能得到正确答案了。

下面是代码。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char fdata[1030],data[1030],r[2060];
int cnt;
char judge(int x,int y){
    int f=0,b=0;
    for(int i=x;i<=y;i++){
        if(b==1 && f==1) break;
        if(data[i]=='0'){
            b=1;
        }
        else{
            f=1;
        }
    }
    if(f==1 && b==1){
        return 'F';
    }
    else if(f==1 && b!=1){
        return 'I';
    }
    else{
        return 'B';
    }
}
void tree(int x,int y){
    if(x==y){
        return;
    }
    int mid1=(x+y)/2,mid2=mid1+1;
    cnt++;
    r[cnt]=judge(x,mid1);
    tree(x,mid1);
    cnt++;
    r[cnt]=judge(mid2,y);
    tree(mid2,y);
    return;
}
int main(){
    int n,m;
    cin>>n;
    if(n==0){
        m=1;
    }
    else{
        m=2;
        for(int i=1;i<=n-1;i++){
            m*=2;
        }
    }
    cin>>fdata;
    for(int i=0,f=m;i<=m-1;i++,f--){
        data[f]=fdata[i];
    }
    cnt++;
    r[cnt]=judge(1,m);
    tree(1,m);
    for(int i=cnt;i>=1;i--){
        cout<<r[i];
    }
}

```

---

## 作者：SKTT1Faker (赞：0)

这道题说白了就是一道求后序遍历的题。


这道题含有分治与搜索还有二分的思想。


我们只要只要把一个字符串分成俩段相同的就可以了。

 
举个例子吧


10001101

第一步，平均分成2分

1000 1101

分成4分

10 00 11 01

分成8份

1 0 0 0 1 1 0 1

所以可以构成一棵树

10001101

1000              1101

10        00         11        01

1     0     0    0     1    1  0      1


```cpp
var
a:longint;
x:ansistring;
function pd(x:ansistring):char;        ////判断当前字符串是‘I’ 还是 ‘B' 还是 ’F'
var
i:longint;
t,f:boolean;
begin
  t:=false; f:=false;          
  for i:=1 to length(x) do
  begin
    if x[i]='1' then t:=true;
    if x[i]='0' then f:=true;
  end;
  if (t) and (f) then exit('F');       如果1和0都出现过，则‘F'
  if t then exit('I');
  if f then exit('B');
end;
procedure fz(x:ansistring);
begin
  if length(x)<>1 then         //  当长度只有一时直接输出，无须再分治
  begin
    fz(copy(x,1,length(x) div 2));       // 左子树
    fz(copy(x,length(x) div 2+1,length(x) div 2));     //右子树
  end;
  write(pd(x));         // 由于是后序遍历，所以根最后输出
end;
begin
  readln(a);
  readln(x);
  fz(x);
end.
```

---

## 作者：keyword_ (赞：0)

一些细节改了好久QwQ 其实这道题不用建树也可以完成 可以直接用递归做 方法很多 这里提供链表储存树+建树+后序的方法

每次将01子串平均分为左右两部分 来建左子树和右子树 同时根据子串中01出现的状况判断根节点的类型  直到子串只有一个字符 判断是B类型还是I类型

建树完成后用后序遍历输出树的每个节点的类型

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int n,w;
char a[1030];
struct node;
typedef node *tree;
tree p;
struct node
{
    char c;//树的类型
    tree lc,rc;//左孩子和右孩子
};
void hx(tree p)//后序遍历输出
{
    if (p)//指针非空 有孩子
    {
        hx(p->lc);//先输出左孩子
        hx(p->rc);//再输出右孩子
        printf("%c",p->c);//最后输出根
    }
}
void fbi(int l,int r,tree &p)//p指针必须要改变 要用实参 否则指针仍为空
{
    bool f1=0,f2=0;
    p=new node;//申请一个新的指针空间
    p->c='F';//先让类型初始化为F 若符合B或I则过后更改
    if (l>r) return;//防止左端点大于右端点
    if (l==r) //左右端点重合 说明子串中只有一个字符 当前节点为叶节点 不需要继续分为两部分
    {
        if (a[l]=='0') p->c='B';
        else p->c='I';
        p->lc=p->rc=NULL;//当前点为叶节点 没有孩子 指针为空
    }
    else 
    {
        for (int i=l;i<=r;i++)
        {
            if (a[i]=='0') f1=1;//注意判断BI类型的巧妙方法 出现过0则f1=1 出现过1则f2=1 f1和f2必须只能有一个是1才符合B或I型
            if (a[i]=='1') f2=1;
        }
        if (f1&&!f2) p->c='B';
        if (f2&&!f1) p->c='I';
        fbi(l,(l+r)/2,p->lc);//将字符串分为两半分别建树 (l+r)/2是前一半的结束点 建左子树
        fbi((l+r)/2+1,r,p->rc);//建右子树
    }
}
int main()
{
    scanf("%d\n",&n);//防止接下来的%c读入回车符 所以要换行
    w=pow(2,n);
    for (int i=0;i<w;i++)
        scanf("%c",&a[i]);
    fbi(0,w-1,p);//从0开始储存字符串 起点为0 结束点为w-1
    hx(p);
    return 0; 
}
```

---

## 作者：qaqRose (赞：0)

很多人都用递归求解，貌似没人用我这种方法，那我就强行来一波题解。

首先我们注意到s=2^n,所以FBI是一颗满二叉树（百度百科：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树），

**不断地将s拆分成两半，最后s中的每一个字符就成了树的叶子结点，所以我们可以将S中的每一个字符按FBI的形式保存在树的叶子节点**，

由于这是一颗满二叉树，那么第一个叶子节点的位置也很好计算，刚好是 2^n -1 (下标从1开始)。

**然后我们再从底向上，从右到左得构建这棵树，通过比较左右子树的类型，**

可以得到当前节点的类型，最后当然是后序遍历啦。时间为0ms


```cpp
#include<iostream>
#include<memory.h>
using namespace std;
int n;
const int t[13]={1,2,4,8,16,32,64,128,256,512,1024,2048};
char s[2050];
char tree[100010];
void after_order(int v){            //后序遍历 
    if(tree[v]==' ') return;
    after_order(v*2);
    after_order(v*2+1);
    cout<<tree[v];
}
int main(){
    freopen("2.txt","r",stdin);
    memset(tree,' ',sizeof(tree));  //初始化 
    cin>>n;
    cin>>s;
    for(int i=0;i<t[n];i++){        //把01串 转化成 FBI 形式保存在 树的叶子节点 
        if(s[i]=='1')
            tree[i+t[n]]='I';
        else if(s[i]=='0'){
            tree[i+t[n]]='B';
        }
    }
    for(int i=t[n]-1;i>=1;i--){        //从下往上，从右到左，更新FBI树 
        char l,r;
        l=tree[i*2];                //左右子树 
        r=tree[i*2+1];
        if(l=='I'&&r=='I') tree[i]='I';
        else if(l=='B'&&r=='B') tree[i]='B';
        else tree[i]='F';
    }
    after_order(1);                    //后序遍历 
    return 0;
}
```

---


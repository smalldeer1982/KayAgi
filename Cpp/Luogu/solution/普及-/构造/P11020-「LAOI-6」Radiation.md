# 「LAOI-6」Radiation

## 题目描述

小 T 和 小 U 在一个 $n \times m$ 的初始为空的棋盘上玩游戏。小 T 先在上面摆 $k$ 个石头，然后小 U 会使用宇宙射线毁掉所有石头。但是小 U 的宇宙射线威力有限，只能每次销毁一行或一列的石头。

小 U 不想过多用他的宇宙射线发射器，所以他会按照最优策略销毁石头。反之，小 T 偏偏想让小 U 发射最多的宇宙射线，所以他会摆放石头以做到这一点。问题来了：小 T 不会摆放了。你能够找到一种方法帮助小 T 达到目标吗？

## 说明/提示

**本题采用捆绑测试。**

子任务 1（$20$ 分）：保证 $k \leq \min(n,m)$。

子任务 2（$12$ 分）：保证 $n = 2$。

子任务 3（$18$ 分）：保证 $T,n,m \leq 10$。

子任务 4（$20$ 分）：保证 $T \leq 10$，$n,m \leq 300$。依赖子任务 $3$。

子任务 5（$30$ 分）：无特殊限制。依赖子任务 $1 \sim 4$。

对于所有数据，保证 $1 \leq T \leq 10^4$，$1 \leq n,m \leq 2 \times 10^3$，$0 \leq k \leq nm$，$\sum nm \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
2
3 5 2
5 4 7```

### 输出

```
S....
....S
.....
S..S
...S
S.S.
...S
.S..```

# 题解

## 作者：Milmon (赞：9)

当 $k \leq \min(m,n)$ 时，只需把 $k$ 个石头放在不同的行和列（例如放在对角线的前 $k$ 个位置），这样至少需要 $k$ 次宇宙射线才可以全部销毁，显然是最优的。

当 $k > \min(m,n)$ 时，由于不管怎么样都可以通过至多 $\min(m,n)$ 步全部销毁（直接对每行或每列依次销毁即可），所以可以先按照对角线放，多余石头随意摆放即可达到 $\min(m,n)$ 步。

有兴趣的读者可以思考一下 checker 的实现。

特别注意：不要每组数据都把整个数组 `memset`，否则会 TLE！

```cpp
#include<bits/stdc++.h>
using namespace std;

char mp[2000][2001];

int main(){
    int T; scanf("%d",&T);
    while(T--){
        int n,m,k;
        scanf("%d%d%d",&n,&m,&k);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)mp[i][j]='.';
            mp[i][m]='\0';
        }
        for(int i=0;i<min({n,m,k});i++)mp[i][i]='S';
        int i=0,j=0; k-=min({n,m,k});
        while(k){
            if(mp[i][j]=='.')mp[i][j]='S',k--;
            j++;
            if(j==m)i++,j=0;
        }
        for(int i=0;i<n;i++)
            printf("%s\n",mp[i]);
    }
    return 0;
}
```

---

## 作者：Hy13_xsm (赞：3)

## 形式化题意

有一个 $n\times m$ 大小的矩阵，一开始格子全是白色。可以再其中选择 $k$ 个格子填成黑色。操作完毕后，使用横线、竖线经过**所有**黑格子。要求使用横线、竖线的条数的**最小**值**最大**。

现在的任务是：给出 $n,m,k$ 三个参数，构造一个矩阵使其满足要求。

## 题目分析

从样例中就可以看出规律。当 $k\le \text{min}(n,m)$ 时，可以构造出一个使每一根横、竖线都只经过 $1$ 个黑格子的矩阵。从坐标 $(1,1)$ 开始填涂，填完时，包括这个点的横、竖线上就不能填涂了。（保证每次横、竖线只经过一个点为最优）。然后合理使用空间，不难发现，下一个就应该填涂 $(2,2)$。以此类推，直到填满 $k$ 个为止。

举一个例子，当要求在 $3\times 3$ 的矩阵中填涂 $3$ 个格子时，$k\le \text{min}(n,m)$，所以可以采取上述思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/uldi9ws3.png)

然后如果不满足上述条件的话，也显而易见了。当按上述方式填涂了 $\text{min}(n,m)$ 个格子时，剩下的就可以随便填，因为此时无论如何填涂，都可以用 $\text{min}(n,m)$ 条横、竖线经过所有黑格子。到这里，整道题就结束了。

这是一道比较简单的推理题，希望大家能从中获取经验，日后做出更加有难度的题目。

## AC 代码（禁止抄袭）


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,k,x,y;
char ans[2005][2005];
int main()
{
	cin>>t;
	while(t--)
	{
		for(int i=1;i<=x;i++)
		{
			for(int j=1;j<=y;j++)
			ans[i][j]=0;
		}
		cin>>n>>m>>k;
		for(int i=1;i<=min(n,m)&&i<=k;i++)
			ans[i][i]='S';
		k-=min(n,m);
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(k<1)break;
				if(!ans[i][j])
				{
					k--;
					ans[i][j]='S';
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(!ans[i][j])cout<<".";
				else cout<<ans[i][j];
			}
			cout<<endl;
		}
		x=n;y=m;//不要忘了清空数组
	}
	return 0;
}
```

---

## 作者：jiangyunuo (赞：2)

### 题目意思：
很简单，我们要帮小 T 求出在一个 $n \times m$ 的棋盘上如何摆石子才能保证小 U 要发射最多的宇宙射线才能消除完，一个格子上只能摆一个石子或不摆，而宇宙射线只能消除一行或一列的石子。  
注意：有多组数据。
### 大体思路：
发射一次宇宙射线即可消除一行或一列石子，实际上，不管怎么摆石子，让小 U 发射宇宙射线次数最多是不会超过 $\min(n,m)$，宇宙射线是消除行和列的，一个斜边是不能消除的，我们只要把石子摆成斜线，因为这样就能保证需要花最多的宇宙射线才能消除，样例上的解法其实是迷惑你的，我们只要斜着摆就可以了，这样不管怎么消都要发射最多的次数，如果石子多出来了，随便摆即可。  
### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
	int t,f;
	scanf("%d",&t);
	for(int i=1;i<=t;i++){
		scanf("%d%d%d",&n,&m,&k);
		f=k-min(n,m);     //f 表示除去那些摆斜线的石子外剩下的石子。
		k=min(k,min(n,m));   //k 是摆斜线的石子数量。
		if(f<0)f=0;
		for(int j=1;j<=n;j++){
			for(int l=1;l<=m;l++){
				if(l==j&&k){printf("S");k--;}   //摆斜线。
				else if(f){f--;printf("S");}   //将没用来摆斜线的石子随便摆。
				else printf(".");  //剩下的空着。
			}
			printf("\n");
		}
	}
	return 0;
}
```
### 证明：
当我们将石子摆成斜线时，我们可以获得最优解，举个例子，一个 $3 \times 3$ 的棋盘，只要 $3$ 次即可消除全棋盘的石子，只要我们斜着摆 $3$ 个石子就需要花 $3$ 次消除，之后多加几个石子都不会改变结果，少几个，斜着摆依旧最优。  
但如果 $n \ne m$ 斜着摆依旧是一样的，这是因为，斜着的不能被一下消掉，而是一个一个消，同样的，多几个少几个依旧是斜着摆最优。

---


# 一道搞笑的构造题

## 题目背景

Many thanks to idea provider @[vegetable_king](https://www.luogu.com.cn/user/477443)!

------

构造题真的有那么难吗？

## 题目描述

设 $a$ 是一个序列，定义 $\operatorname{MEX}(a)$ 为 $a$ 中最小没有出现的正整数，$a[l, r]$ 为 $a$ 的第 $l$ 项到 $a$ 的第 $r$ 项组成的连续子序列。

给你 $n$，让你构造一个 $1 \sim n$ 的排列 $a$，使得

$$
\sum\limits_{l = 1}^n  \sum\limits_{r = l}^n \operatorname{MEX}(a[l, r])
$$

的值最大。（如果看不懂可以看题目末尾）

如果有多个 $a$ 的构造方案，请你输出字典序最小的一个。

## 说明/提示

**【样例解释】**

对于第二组测试数据（$n=2$）：

$a[1, 1] = \{1\}$，最小没有出现的正整数是 $2$。

$a[2, 2] = \{2\}$，最小没有出现的正整数是 $1$。

$a[1, 2] = \{1, 2\}$，最小没有出现的正整数是 $3$。

上述式子的值为 $2 + 1 + 3 = 6$。

对于第三组测试数据（$n=3$）：

$a[1, 1] = \{2\}$，最小没有出现的正整数是 $1$。

$a[2, 2] = \{1\}$，最小没有出现的正整数是 $2$。

$a[3, 3] = \{3\}$，最小没有出现的正整数是 $1$。

$a[1, 2] = \{2, 1\}$，最小没有出现的正整数是 $3$。

$a[2, 3] = \{1, 3\}$，最小没有出现的正整数是 $2$。

$a[1, 3] = \{2, 1, 3\}$，最小没有出现的正整数是 $4$。

上述式子的值为 $1 + 2 + 1 + 3 + 2 + 4 = 13$。

可以证明，没有其他的排列可以使得上述式子的值比答案更大，且没有其他的排列可以使得上述式子的值与答案相等的同时字典序比答案小。

**【数据范围】**

记一个测试点所有的 $n$ 之和为 $\sum n$。

对于 $30\%$ 的数据：$\sum n \le 9$。

对于 $100\%$ 的数据：$1 \le n \le 10^6$，$1 \le t \le 10^6$，$\sum n \le 10^6$。

**【温馨提示】**

$$
\sum\limits_{l = 1}^n ( \sum\limits_{r = l}^n \operatorname{MEX}(a[l, r]))
$$


的伪代码如下：

```
for each l in range(1,n):
	for each r in range(l,n):
		result = result+MEX(l,r)
```

最终结果为 $result$。


## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
1
1 2
2 1 3```

# 题解

## 作者：Clare613 (赞：3)

## 思路：
这道题其实不难，我们要明白个特性：越中间，可以包含这个点的区间越多。那么就是说答案就是将 $1$ 放中间，接着放 $2$ 和 $3$，最后构造出如下的序列：
> $n-1,n-3,\dots,2,1,3,\dots,n-2,n$

特别的，要注意字典序最小。
## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
signed main(){
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		for(int i=1;i<=n/2;i++){
			a[i]=n-i*2+1;
			a[n-i+1]=n-i*2+2;
		}
		if(n%2==1){
			a[n/2+1]=1;
		}
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" \n"[i==n];
		}
	}
	return 0;
}
```

---

## 作者：luckyyunji (赞：2)

*P12973 一道搞笑的构造题*

~~不愧是橙题，确实简单。~~

分析：

让结果变大的方法是让区间中小的数字增多。

更多区间都会包含中间的位置，所以要把小的数字放中间，即将 $1$ 放在最中间，将最大的两个数 $n,n-1$ 放在最外面。

**注意**：构造出来的结果应是一个排列且字典序最小，所以 $n-1$ 永远是第一个，$n$ 永远是最后一个。以此类推，$n-3$ 永远是第二个，$n-2$ 永远是倒数第二个……

当 $n$ 为偶数时：

$$
n-1,n-3,\dots,3,1,2,\dots,n-2,n
$$

当 $n$ 为奇数时：

$$
n-1,n-3,\dots,2,1,3,\dots,n-2,n
$$

构造完成。

具体来说，从第 $1$ 项到第 $\lfloor \frac{n}{2} \rfloor$ 项是公差为 $2$ 的等差序列。从第 $n$ 项到第 $\lceil \frac{n}{2} \rceil$ 项也是公差为 $2$ 的等差序列。

第 $1$ 个等差序列观察易得第 $i$ 项为 $n-2i+1$。

第 $2$ 个同理，仅仅是将第 $1$ 个序列反转同时每项加 $1$。

特别地，两个序列有可能重复，故需要特判。

详见代码：

```cpp
/*
luckyyunji
luogu.com.cn
c++98 -O2
*/

#include <bits/stdc++.h>
using namespace std;
// Is it quite easy?
// No, it is.
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T, n;
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 1; i <= n / 2; i++) {
			cout << n - i * 2 + 1 << ' ';
		}
		if (n % 2) {  // 注意 n 为奇数
			cout << 1 << ' ';
		}
		for (int i = n / 2; i >= 1; i--) {	// 注意顺序
			cout << n - i * 2 + 2 << ' ';
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：Clouds_dream (赞：1)

### 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12973)

### 题目分析
我们只要根据 $n$ 的奇偶性，分别生成两部分序列并合并即可：

- 当 $n$ 为偶数时：先生成从 $n-1$ 到 1 的奇数序列（递减），再生成从 2 到 $n$ 的偶数序列（递增）。

- 当 $n$ 为奇数时：先生成从 $n-1$ 到 2 的偶数序列（递减），再生成从 1 到 $n$ 的奇数序列（递增）。

#### 正确性证明
**偶数情况（$n = 2k$）**：
- **同一对内的相邻元素**：$|i - (i+k)| = k = n/2$，满足条件。
- **不同对之间的相邻元素**：
  - 当前对的第二个元素为 $i+k$，下一对的第一个元素为 $i-1$。
  - 差值为 $(i+k) - (i-1) = k+1 > k$，满足条件。
- 序列覆盖 $1$ 到 $n$ 的所有整数，且无重复。

**奇数情况（$n = 2k+1$）**：
- **同一对内的相邻元素**：$|i - (i+k)| = k = \lfloor n/2 \rfloor$，满足条件。
- **不同对之间的相邻元素**：
  - 当前对的第二个元素为 $i+k$，下一对的第一个元素为 $i-1$。
  - 差值为 $(i+k) - (i-1) = k+1 > k$，满足条件。
- **最后元素与 $1$ 的相邻**：
  - 最后一对为 $(2, 2+k)$，其后输出 $1$。
  - 差值为 $(2+k) - 1 = k+1 > k$，满足条件。
- 序列覆盖 $1$ 到 $n$ 的所有整数，且无重复。

### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

void f(){
	int n;
	cin>>n;
	vector<int>res;
	if(n%2==0){
		for(int i=n-1;i>=1;i-=2){
			res.push_back(i);
		}
		for(int i=2;i<=n;i+=2){
			res.push_back(i);
		}
	}
	else{
		for(int i=n-1;i>=2;i-=2){
			res.push_back(i);
		}
		for(int i=1;i<=n;i+=2){
			res.push_back(i);
		}
	}
    for(int num:res){
        cout<<num<<" ";
    }
    cout<<endl;
}

signed main()
{
	fst
	int t;
	cin>>t;
	while(t--){
		f();
	}
	return 0;
}
```

### UPD
2025.7.21 增加正确性证明。

---

## 作者：Sunny_Boybgfcxc (赞：1)

# P12973 一道搞笑的构造题 题解
[更好的阅读体验](https://www.luogu.com.cn/article/opho96fc/edit)
## 题意简述
&nbsp;&nbsp;要求构造一个 $1 \sim n$ 的排列 $a$，使 $a$ 的所有连续子序列中没有出现的最小正整数的和最大，且在所有符合要求的序列中，$a$ 的字典序最小。
## 解题思路
&nbsp;&nbsp;要想让 $a$ 的所有连续子序列中没有出现的最小正整数的和最大，那么 $a$ 中较小的数要被较多的连续子序列包含，同时 $a$ 中较大的数要被较少的子序列包含。  
&nbsp;&nbsp;我们先把 $n$ 和 $n-1$ 分别放在 $a$ 的首尾两端，这样可以使它们被最少的子序列包含。此时整个问题就转化成了规模为 $1 \sim {n-2}$ 的子问题，可以按照同样的逻辑构造下去，直到只剩下一个数字或者一个数字也不剩。  
&nbsp;&nbsp;再考虑使整个序列的字典序最小，我们最终得到的应该是这个：
$${n-1},{n-3},{n-5},\cdots,1,\cdots,{n-4},{n-2},n$$
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
void work(int x){
    if(x==0)return;
    if(x==1){cout<<"1 ";return;}
    cout<<x-1<<" ";work(x-2);cout<<x<<" ";
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t,n;
    cin>>t;
    while(t--){
        cin>>n;
        work(n);
        cout<<'\n';
    }
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/225870119)

---

## 作者：Sabre (赞：1)

对于一个排列的子数组，$\operatorname{MEX}$ 的值取决于子数组中包含的数字。为了使总和最大，我们需要让尽可能多的子数组的 $\operatorname{MEX}$ 尽可能大。

最大贡献的子数组包含所有 $1$ 到 $k$ 的子数组的 $\operatorname{MEX}$ 至少为 $k+1$。特别是整个排列的子数组的 $\operatorname{MEX}$ 是 $n+1$，这是最大的可能值。为了使总和最大，应该让较大的数字尽可能早地出现在子数组中。具体来说，将较大的数字放在中间，较小的数字放在两边，可以增加包含较大数字的子数组的数量。

构造方法：

初始化一个数组 $a$ 大小为 $n$。

将 $1$ 放在 $a[\lfloor n/2 \rfloor]$。

左边部分从 $a[0]$ 开始，放置 $2,3,...,\lfloor n/2 \rfloor+1$。

右边部分从 $a[\lfloor n/2 \rfloor+1]$，开始放置 $\lfloor n/2 \rfloor+2,...,n$。

---

## 作者：_ByTT_ (赞：1)

# 题解：P12973 一道搞笑的构造题
### 题意
构造一个序列 $a$，使得 $a$ 的所有非空且连续的子序列中，每个序列第一个没有的最小的正整数的和最大。
### 思路
很明显，越靠中间的数加入的子序列越多，也就意味着中间的数应当更小，并且要由小到大依次向周围扩散，直到成为一个按要求诞生的序列，同时，要按字典序排序，即同等扩散时，小的在前，大的在后面。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T;cin>>T;
	while(T--){
		int n;cin>>n;
		int sum=n;
		if(n%2==1){
			for(int j=1;j<=n/2;j++) cout<<sum-j*2+1<<' ';
			for(int j=1;j<=n;j+=2) cout<<j<<' ';
		}else{
			for(int j=1;j<=n/2;j++) cout<<sum-j*2+1<<' ';
			for(int j=2;j<=n;j+=2) cout<<j<<' ';
		}
		cout<<'\n';
	}
	return 0;
}
//Case #x: y
```

---

## 作者：tujiaqi12 (赞：1)

#### 找规律

| $n$ |answer| $n$ |answer|
|:-:|:-:|:-:|:-:|
|1|1|6|5 3 1 2 4 6|
|2|1 2|7|6 4 2 1 3 5 7|
|3|2 1 3|8|7 5 3 1 2 4 6 8|
|4|3 1 2 4|9|8 6 4 2 1 3 5 7 9|
|5|4 2 1 3 5|10|9 7 5 3 1 2 4 6 8 10|

可见，$1 - n$  的排列是从中间的 $1$ 开始，向外左一个右一个地向外排列。
附上代码。

```cpp
#include <bits/stdc++.h>
using namespace std; 
#define ll long long
ll n;
ll t;
ll a[2000015];
int main(){
	scanf("%lld",&t);
	while(t--){//多组数据 
		scanf("%lld",&n);
		ll l = 1000000,r = 1000000;
		a[l] = 1;//选取中心点 
		//先选第二种方式进行排列
		//若字典序不是最小，逆向输出即可 
		for(ll i = 2;i <= n;i++){
			if(i%2){//2，4，6，8往右放 
				a[--l] = i;
			}
			else{//3，5，7，9往左放
				a[++r] = i;
			}
		}
		//选择字典序小的方式输出 
		if(a[l] < a[r]){
			for(ll i = l;i <= r;i++){
				printf("%lld ",a[i]);
			}
		}
		else{
			for(ll i = r;i >= l;i--){
				printf("%lld ",a[i]);
			}
		}
		printf("\n");//记得换行 
	}
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：1)

首先我们要使 $1$ 在这堆区间中出现的尽量多，其次在这些区间中要使 $2$ 出现的尽量多……

一个位置的 $a_i$ 在所有区间中出现的次数是 $i(n-i+1)$，根据矩形的面积，越靠近中间出现次数越多。所以考虑把 $1$ 放在中间。

然后发现剩下的最靠近中间的位置能覆盖它的区间又是最多的，原因：一、它本身区间就多，二、它可以通过向一侧长度大于 $1$ 的所有区间跟 $1$ 连接。

总之结论就是，形如 $4,2,1,3,5$ 或者 $3,1,2,4$ 这样的构造。

```cpp
#include<iostream>
using namespace std;
int t,n;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1,m=n+1>>1;i<=n;i++){
            if(n&1){
                if(i<m)cout<<(m-i)*2<<' ';
                else cout<<(i-m)*2+1<<' ';
            }
            else{
                if(i>m)cout<<(i-m)*2<<' ';
                else cout<<(m-i)*2+1<<' ';
            }
        }
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：__Harry__Potter__ (赞：0)

~~我觉得这道题可以打表。~~

像这种只有一个输入的构造题，我们可以写一个暴力，然后输入一些（~~所有~~）数据，再找一找规律（~~打一打表~~）。

 $1:1$；

 $2:1\ 2$；

 $3:2\ 1\ 3$；

 $4:3\ 1\ 2\ 4$；

 $5:5\ 3\ 1\ 2\ 4$；

 $6:5\ 3\ 1\ 2\ 4\ 6$。

易得输出的前一部分是 $n-1$ 到 $1$ 或 $2$ 的所有奇或偶数，后一部分是 $1$ 或 $2$ 到 $n$ 的所有奇或偶数。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		if(n==1){
			cout<<"1\n";
			continue;
		}for(int i=n-1;i>=1;i-=2) cout<<i<<" ";
		if(n%2) for(int i=1;i<=n;i+=2) cout<<i<<" ";
		else for(int i=2;i<=n;i+=2) cout<<i<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Aurelia_Veil (赞：0)

# 题解：P12973 一道搞笑的构造题

构造题找规律。

首先，为了保证更多的区间的最小的正整数尽量大，我们就要将小的数放在更多区间都会包含的位置，也就是中间。

因此，我们就将越小的数放在越靠近中间的位置，也就是：

$n-1,n-3,\cdots,2,1,3,\cdots,n-2,n$

随后，找规律，非常简单，就不说了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int n;
        scanf("%d",&n);
        if(n%2==1){
            for(int i=1;i<=n;i++){
                if(i*2<=n){
                    printf("%d ",(n/2-i+1)*2);
                }else{
                    printf("%d ",(i-n/2)*2-1);
                }
            }
        }else{
            for(int i=1;i<=n;i++){
                if(i*2<=n){
                    printf("%d ",(n/2-i+1)*2-1);
                }else{
                    printf("%d ",(i-n/2)*2);
                }
            }
        }
        printf("\n");
    }
    return 0;
}
```

---


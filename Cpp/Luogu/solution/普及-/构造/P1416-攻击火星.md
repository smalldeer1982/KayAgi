# 攻击火星

## 题目描述

一群外星人将要攻击火星。

火星的地图是一个 $n$ 个点的无向图。这伙外星人将按照如下方法入侵，先攻击度为 $0$ 的点（相当于从图中删除掉它），然后是度为 $1$ 的点，依此类推直到度为 $n-1$ 的点。

所有的点度统计是动态统计的。（一个点删掉后，与之相连的点的点度都会 $-1$）。外星人攻击度为某个数的点时是同时攻击的。

你需要设计这个图的边的方案来使得未被攻击的点最多。注意：你设计的图**不允许自环及重边**。



## 说明/提示

【样例解释】

一种可能的方案是 $1\leftrightarrow 2\leftrightarrow 3$，这样首先删掉度为 $1$ 的点 $1$ 和点 $3$，此时点 $2$ 度数为 $0$，不会被删去。

【数据范围】

- 对于 $20\%$ 的数据 $1\le n\le 10$；
- 对于 $100\%$ 的数据 $1\le n\le 5\times 10^4$。

【题目来源】

tinylic改编


## 样例 #1

### 输入

```
3```

### 输出

```
1```

# 题解

## 作者：kkksc03 (赞：103)

By tinylic

经过找规律可以发现答案为n-2.

以下是证明：

令d[i]为i 的度数。

考虑一个点i 不被删去的条件，必然是前面与i 相邻的点j（可以是多个）被删去，导致d[i]

减小至小于等于d[j].

1)易知ans!=n。

2)考虑ans能否是n-1，也就是只删一个点，设这个点为i。

因为i 是唯一被删去的点，所以d[i]一定不是最大的，即d[i]<n-1。

其次删去i 导致其余点的d[]均发生改变，从而无法被删去。

即i 和其余点都相连，d[i]=n-1，矛盾。

所以ans!=n-1.

3)我们可以构造出ans=n-2的情况：

构造完全图G,删去一条边(i,j)。这样d[i]=d[j]=n-2,其余d[]均为n-1.

首先删去VI,Vj，这样其余点各少两条边，d[]均变成n-3,不用被删去。

由此n-2是合法的解，也是最大的解，所以答案就是n-2.


---

## 作者：Vanilla_chan (赞：52)

# 洛谷 P1416 攻击火星

[原题P1416](https://www.luogu.com.cn/problem/P1416)

## Update

20210307 修复了挂掉的图片

20210307 重构排版

## Solution

### understand

首先，你弄明白了什么是度吗？

一个点的度，等于与它连接的边的数量。

那这题怎么模拟鸭？50000点，邻接表都开不了耶……

接着，我们从特殊到一般来构造这道题——

### special situation

#### n=1

只有一个点，这个点一定会被删掉，`ans=0`

#### n=2

有了两个点，但是度数相同，都会被删掉，`ans=0`

#### n=3

样例中也是三个点，使用的是一条链的构造方法。

`ans=1`

欸？这个**链**会不会是一个提示？

#### n=4

我们试试用一条链

![](https://cdn.luogu.com.cn/upload/image_hosting/c5ol2qmi.png)

也是这样最优，`ans=4`

难道说链就是正确的构造方法吗？

再试试吧

#### n=5

继续使用链：

由于删去了两个末端节点后，中间的那个节点的度仍为2。所以它会在d=2时被删去！

有没有一种方法，可以避免这种悲剧的发生呢？

当然有的！我们换一种构造方法。请看好了——

以$n=6$为例：

选出两个末端节点------牺牲品

![](https://cdn.luogu.com.cn/upload/image_hosting/mjjcrrp8.png)

把两个末端节点与所有非末端节点相连

![](https://cdn.luogu.com.cn/upload/image_hosting/7al9nw0p.png)

再把非末端节点与所有非末端节点相连（并标上每个点的度）

![](https://cdn.luogu.com.cn/upload/image_hosting/49ankad1.png)

肯定是两个末端节点先被删除了

但是，当它们被删除时，其他所有的节点都会被改变！

完美的错过当前的d+1

![](https://cdn.luogu.com.cn/upload/image_hosting/fqdir4vr.png)



这，就是本题的思想：

删去一些节点后，让其他节点的度都改变为那时的d

这样“其他节点”都不会狗带咯！

### general situation

当有n个点时，**取其中的两个节点当牺牲品**。（所以$n<2$时 仍有`ans=0`）

**把两个末端节点与所有非末端节点相连**

**再把非末端节点与所有非末端节点相连**

最终，

末端节点的度都等于n-2

非末端节点的度都等于n-1（除它本身以外全连）

那么末端节点会先被删除（$d=n-2$）

同时，非末端节点的度-=2 -> n-3

这时，d++（$d=n-1$）

非末端节点们就安全了！

如果还是不懂，欢迎评论！

## Code

```c++
#include<iostream>
using namespace std;
int n;
int main()
{
    cin>>n;
    if(n==1) cout<<0;
    else cout<<n-2;
    //也可以是这样的
    /*
    cout<<max(n-2,0);
    */ 
    return 0;
}
```

---

## 作者：Daidly (赞：27)

# STEP1
首先，我们发现题中出现了一个新的名词“度”。

“度”是什么呢，“度”就是一个点所连线段的个数。例如：
```
          A._____B.
          |\ 
          | \
          C. D.
```
如图，点$A$所连线段的个数有三个，分别是$AB$，$AC$，$AD$。



------------
接下来，我们知道外星人是按照“度”的大小来从小到大攻击的

点的，如果有一个小于它刚才攻击度数的点，它就不能继续攻

击。

而且我们要注意，如果删掉一个点后，和那个点相连的点的度都

会减一，外星人攻击度为某个数的点时是同时攻击的（不分先

后）。


------------
# STEP2
所以，在这里我们要用到一个相对来说~~比较笨~~的方法--枚举法。

(括号中的数代表着这个点的度数)

当$n=1$时，只有一个点一定会被删掉，输出$0$。
```
A(0).
```
当$n=2$时，只有两个点也一定会被删掉，输出$0$。
```
A(1).______B(1).
```
当$n=3$时，有两个点一定会被删掉，输出$1$，表示点$B$。
```
A（1）.____B（2）.____C（1）.
```
当$n=4$时，有三个点一定会被删掉，输出$2$,表示点$B$和点$C$。
```
A(1).____B(2).____C(2).____D(1).
```
......

由此，我们可以发现一个规律：除了小于二的点数外$-2=$最多
的最后未被攻击的点。这样，我们就可以轻易的$AC$这道题了。
# STEP3
$AC$代码:
```c
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n<=2) cout<<0;
    else cout<<n-2;
  
    return 0;
}
```
如果你喜欢的话，就挥动你的小鼠标点点赞吧！




---

## 作者：云浅知处 (赞：17)

这题考构造，难度适中。
***
[更好的阅读体验？](https://www.luogu.com.cn/blog/wwwluogucn/solution-p1416)

___
首先来说说什么是“度”。

在这里，一个点的“度”指的就是与这个点连接的边的数量。

比如下图中，点$A$的度是$3$，点$B$、点$C$的度是$2$，点$D$的度是$1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/04kbrvy4.png)

***
接下来，开始讲题。

本蒟蒻看到题后，第一反应是不会做，第二反应就是拿几组数据试一下，找找规律。

当$n=1$时，唯一的一个点一定会被删掉，故答案为$0$。

当$n=2$时，这两个点要么连着，要么分开。连着的时候两个点的度都是$1$，分开的时候两个点的度都是$0$。所以，不管怎样，答案都是$0$。

当$n=3$时，样例已经解释清楚了，用队列法，答案是$1$。

当$n=4$时，我们可以试着学学样例，用队列法构造这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2aslhph0.png)

此时，由于没有度为$0$的点，所以外星人会直接删除度为$1$的点，即$A,D$。

然后图就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/bv8nrvac.png)

此时，外星人应该删除度为$2$的点，但上一步操作使得$B,C$的度都变成了$1$，外星人无法删除$B,C$，故$B,C$幸存了下来。

故答案为二。

难道题目就是想让我们用队列法？**当然不是！**

当$n=5$时，如果我们继续用队列法，那么会变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/sr7y5ywz.png)

我们惊讶地发现：点$C$居然也被删除了！！！

于是，队列法宣告失败。

不过，在我们前面的枚举中，我们似乎看出了什么端倪：

（下面的表格在题解区有可能会爆，建议去博客区观看。如果表格没爆，请忽略这句话。）

$\begin{matrix}n=2&ans=0&ans=n-2\\n=3&ans=1&ans=n-2\\n=4&ans=2&ans=n-2\end{matrix}$

莫非......答案真的是$n-2$ ？

下面就让我们一起来看一看吧。
***
以$7$个点为例：

我们先选取两个点$A,B$，再把$A,B$与除了彼此之外的所有点相连。

![](https://cdn.luogu.com.cn/upload/image_hosting/syca82xp.png)

对于剩下的五个点，把每个点与其余的点相连。

![](https://cdn.luogu.com.cn/upload/image_hosting/n8jcpjns.png)

（已经帮各位标过每个点的度了～）

然后，邪恶的外星人删除了度最小的点，即$A,B$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xdudktun.png)

此时，外星人刚刚删除了两个度为$5$的点，应该删除度为$6$的点。

但是删除$A,B$后，剩下的五个点的度都变成了$4$，外星人无法删除它们，所以这五个点留了下来。

下面证明对于所有情况，都有$ans=n-2$。
***
$1.$ 显然，$ans\neq n$。

$2.$ 假设 $ans=n-1$，那么只删除了$1$个点，设为$A$。

由于在$n$个点中，每个点最多只能与除了自身之外所有的点相连，所以每个点的度都不超过$n-1$。

又，点$A$被删去了，所以点$A$的度小于$n-1$。

如果删去点$A$影响不到其他点的度，那么必有点$A$的度为$0$。

于是，删去点$A$后，外星人完全可以删去其他的点，这是因为其他点的度一定大于等于$0$，矛盾。

所以删去点$A$必然影响其他点。

又因为外星人只删除了一个点，至多使其他点的度减$1$。

而之前已经说过点$A$的度小于 $n-1$，一定存在至少$1$个点与点$A$不相连。（如果与其余点都相连那么点$A$的度就是 $n-1$ 了）

又因为点$A$被删去了，所以点$A$的度一定小于其余的点。

所以外星人删去点$A$后，与点$A$不相连的点不受影响，它们的度仍然大于点$A$的度，所以外星人仍然能够继续删除那些与点$A$不相连的点。

所以$ans\neq n-1$。

$3.ans=n-2$

这个之前已经说过构造方法了，是成立的。

所以$n-2$是合法的解，也是最大的解，所以答案就是$n-2$。
***
不过，有一个地方需要注意：当$n<2$，即$n-2<0$时，答案仍然是$0$。
***
最后，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	if(n<2){
		cout<<0;
	}
	else{
		cout<<n-2;
	}
	/*
	当然也可以这么写：
	cout<<max(0,n-2);
	这个语句在n-2<0时自动输出0与n-2中小的那个，而n-2<0，所以会输出0。
	*/
	return 0;
}
```
$\text{The\ end.}$

---

## 作者：wd050602 (赞：4)

具体的思路及推算过程，我们的副站长已经讲的很清楚了，不过注意有一个坑点，n<0的话必须n=0，第一个点就是这个坑，坑了我一次QwQ。

算了，不说了，贴代码（其实也没意思）

```cpp
#include <bits/stdc++.h>//
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstdlib>
#include <string>
#include <iomanip>
#include <cstring>
#include <ctime>
#include <algorithm>
#include <queue>
#include <string.h>
using namespace std;
int n;
int main(){
    scanf("%d",&n);//读入
    printf("%d\n",n-2>=0?n-2:0);//输出
    return 0;//就这样结束了？？
}

```

---

## 作者：Andysun06 (赞：4)

### 刚开始一看，哇！一脸蒙，仔细一看，也太简单了，如果n-2<=0就输出‘0’（不用输出单引号）。如果n-2>0就输出n-2（想知道具体怎么推算见 kkk 的题解）
#### 上代码：
    var n:longint;
    begin
     read(n);
     if n-2>=0 then
      write(n-2)
     else
      write(0);
    end.
####  0ms 4.38MB 0.11KB（开了O2）
####  0ms 4.38MB 0.08KB（不开O2）

---

## 作者：Zenith_Yeh (赞：3)

我们可以通过打表的方式发现，$ans=n-2$。但是显然是不严谨的，让我们来证一证。

# first：

首先显然$ans \neq n$。

# second:

接下来证$ans \neq n-1$。由于只有一个，所以它的度一定不是最大的。但又因为这个点要影响其他所有的点，所以度为$n-1$,此时度为最大的。矛盾。

下证$ans=n-2$

# third:

我们其实可以构造出$ans=n-2$的情况：

构造完全图$G$,删去一条边$(i,j)$。这样$d_i=d_j=n-2$,其余$d$均为$n-1$。（设$d_i$为$i$的度）

首先删去$V_i,V_j$，这样其余点各少两条边，$d$均变成$n-3$,不用被删去。

由此$n-2$是合法的解，也是最大的解，所以答案就是$n-2$。

## 上菜

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{   int n;
    cin>>n;
    cout<<max(0,n-2);//由于n-2可能会变成负数，所以与0取一个max。
    return 0;
}
```


---

## 作者：听取MLE声一片 (赞：2)

本提建议采用归纳总结法

我先来展示几个图(数字表示点，其他的表示连接线,0表示被替换的点,#表示消失的线)

$1.$ 三个点
```
   1
    \
     \
2     3
```

第一步：

```
   0
    #
     #
2     3
```

没有符合的点，结束

---

$2.$四个点

```
1  2
  |
  |
3  4

```
第一步
```
0  2
   |
   |
3  4
  
```
第二步
```
0  0
   #
   #
3  4
```
没有符合的点，结束

---
$3.$五个点（跳了一步）
![](https://cdn.luogu.com.cn/upload/image_hosting/ruay71by.png)

总上所述，我们要求的答案就是$n-2$（有兴趣者可以继续研究）。

代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;
int n;
int main()
{
	cin>>n;
	if(n>2)
		cout<<n-2;
	else cout<<0;
	return 0;
}
```

谢谢大家！


---

## 作者：易水笙箫 (赞：2)

第一次写题解呜（

首先我们可以知道，不可能没有点被删去（这似乎没必要解释？

然后我们考虑能不能只删去一个点。那么这样的话，这个点肯定是所有的点里度最小的一个点（否则不可能最先被删去，也就不可能成为仅有的被删去的那个点）这个点被攻击之后所有和它连着的点的度-1，没和它连着的点的度不动。根据我们上面的分析，这个被攻击的点是所有的点里度最小的，如果有其他n-1个点里的某个点没有和它连在一起，那么这些点的度在这个点被攻击后不变，然后因为外星人是按度数从低到高攻击的，那么这些点必然在之后被攻击。因此我们可以得到：**这个点和其它所有的点都连在一起并且度最小**。

接下来我们分析这个点被攻击之后的情况。根据上面的分析，被攻击之后所有的点度-1。如果要让这些点在之后不被攻击的话，必须有**这些点的度相等并等于被攻击的那个点的度+1**（否则被攻击的点的度n-1(n就是点的总个数），假设某个点的度是m,m>n,且m点的度是所有度大于n的点的度中最小的（好像有点拗口）那么之后外星人开始攻击度为n,n+1,···的点，则m点必被攻击,矛盾）因此在n-1点被干掉之后所有的点的度都等于n-1。但是此时只有n-1个点，不可能有某个点的度大于n-2,矛盾。于是我们证明了n-1个点不被攻击不可能。

最后证明n-2是可行的。就是说我们要考虑能不能有这样一个构造，使得两个点被攻击后所有点的度都降到最后被攻击的那个点的度以下（或相等）。那么我们可以知道第二个被干掉的点一定和所有最后剩下的的点相连（因为第二个被干掉的点在被干掉之前它的度是最低的）我们可以构造这么一个图:首先取出n-2个点构成完全图，剩下两个点与这些点都相连但彼此不连接，于是开始的时候有2个点的度是n-2,而另外n-2个点的度是n-1，然后这2个点会在外星人攻击度为n-2的点的时候一起被干掉，其它的点的度降为n-3，接下来外星人攻击度为n-1的点，不会攻击剩下的点。于是我们成功获得了保护n-2个点的方法。

综上所述，n-2就是所求答案。

**但是要记得在n=1的时候特别写一下**

代码就很简单啦（语言：Python3)

```python
n=int(input())
if n==1:
    ans=0
else:
    ans=n-2
print(ans)
```




---

## 作者：xgwpp6710 (赞：1)

第一眼看上去：what？！什么难题？！！！没思路……

但是这是道`普及-`的题目，不会那么duliu的。

我们开始找规律：

$1$ 个点，没啥好说，直接被删。

$2$ 个点，也是没啥好说，直接被删。

$3$ 个点，连成一条线可以留下一个点，而连成三角形一个也无法留下。至多保留 $1$ 个点。

$4$ 个点，以下方案最佳，可留下 $2$ 个点：

![](https://cdn.luogu.com.cn/upload/image_hosting/58mis91b.png)

$5$ 个点，以下方案最佳，可留下 $3$ 个点：

![](https://cdn.luogu.com.cn/upload/image_hosting/0alxu4hw.png)

$6$ 个点，以下方案最佳，可留下 $4$ 个点：

![](https://cdn.luogu.com.cn/upload/image_hosting/5x97gtgy.png)

找到规律了吗？就是如果点的数量 $≥3$ ，只需要删除两个点，实现方法就是：用 $n-2$ 个点构成一个连通图，另外两个点与这 $n-2$ 个点都连起来就可以了。（请自行推导删点过程）

证明：删除一个点不行

首先，既然可以只删一个点，那么它就是度唯一最小的一个点（不妨设为 $a_i$ ），则  $a_i$ 必定不和其他所有点都相连，那么必定有一个点 $a_j$ 与它不相连。因此删除 $a_i$ 后， $a_j$ 的度不变（且大于 $a_i$ 的度），也会被删掉。

代码（很简单，不用解释了）：
```cpp
#include<bits/stdc++.h>
int n;
int main()
{
	scanf("%d",&n);
	printf("%d",std::max(n-2,0));
	return 0;
}
```

---

## 作者：小恐 (赞：1)

咦？木有Python 2题解，赶紧水一波

~~我怎么觉得这是小奥中的构造论证？~~

1. $n=1$: 
貌似直接就被攻击了
2. $n\ge2$:一个点如果安全了，辣么肯定是与它相邻的一个点凉了，结果就成了它的“挡箭牌”（它的度少了，因此躲过了攻击）。
下面枚举一下有几个点没被攻击的情况：
	1. $n$个点没被攻击（怎么可能？）
 	2. $(n-1)$个点没被攻击（那一定是被攻击的那个点连着所有的点，但如果它被攻击了，其它的点肯定都在它前面或与它同时被攻击了呀）
  	3. $(n-2)$个点没被攻击（貌似可以）

构造：

有$n$个点，编号为1 ~ $n$：

1、2分别连着$3$~$(n-1)$，4 ~ $n$

3 ~ $n$构成一个完全图（就是每两个点都连着啦）

1、2度为$(n-3)$，3、n度为$(n-2)$，剩下的度为$(n-1)$

1、2凉了，3 ~ n就每个点都成了度为$(n-3)$，就都保住了。

构造完了，贴代码：
```python
n=input()
if n==1:
    print(1)
else:
    print(n-2)
```
$\color{black}\colorbox{black}{其实我是学c++的（逃}$

~~第二稿，求过~~

PS：2020-04-24：之前没加$\LaTeX$,现在加上了

---

## 作者：tommychen (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P1416)

### 题意
火星的地图是一个 $n$ 个点的无向图。外星人将按照如下方法入侵，先攻击度为 $0$ 的点（相当于从图中删除掉它），然后是度为 $1$ 的点，依此类推直到度为 $n-1$ 的点。\
所有的点度统计是动态统计的。(一个点删掉后，与之相连的点的点度都会$-1$）。外星人攻击度为某个数的点时是同时攻击的。
你需要设计这个图的边的方案来使得未被攻击的点最多。

### 输入格式
一个整数$n$

### 输出格式
一行一个整数，表示最多的最后未被攻击的点。

-----------
### 思路
输出一定是 $n-2$\
证明:
- $ans≠n$  
	- ~~这很显然~~
- $ans≠n-1$ 
	- 由于只有一个点，它的度一定不是最大的，而它又要影响其他的它，此时度最大，前后矛盾。
- $ans=n-2$

	- 我们可以构造出$ans=n-2$的情况：\
    构造完全图$G$,删去一条边($i$ , $j$)。这样$d_i$ = $d_j$ = n-2,其余 $d$ 均为 $n-1$.首先删去$V_i$,$V_j$，这样其余点各少两条边，$d$ 都会变成 $n-3$,不用被删去。
    
-----------

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    if(n==1) cout<<0;//不特判会出现负数
    else cout<<n-2;
    return 0;
}
```
撒花撒花✿✿ヽ(°▽°)ノ✿

---


# [COCI 2015/2016 #3] ESEJ

## 题目描述

小 M 要写一篇文章。

- 这篇文章至少 $a$ 个词，最多 $b$ 个词，
- 每个单词至少 $1$ 个字母，最多 $15$ 个字母。
- 文章至少包含 $\dfrac{b}{2}$ 个不同的单词。

小 M 昨晚熬夜打 Codeforces，所以请你帮他写作文。

作文只能有一段（只有一行），只能使用英文字母的小写字母和空格。

**注：作文的句意可以不通顺，语法也可以不正确，只要符合要求的作文，均可以 $\color{green}\texttt{AC}$。**

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1\le a, b \le 10^5$。

#### 说明
- 样例 #2 和样例 #3 由于输出过长放置在了这里：[样例 #2 与样例 #3](https://www.luogu.com.cn/paste/we9k25k1)。
- 翻译自 [COCI 2015-2016 #3 B ESEJ](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)，满分 80。
- 感谢 @[tiger2005](https://www.luogu.com.cn/user/60864) 提供的 checker.cpp。

## 样例 #1

### 输入

```
2 7
```

### 输出

```
this shakespeare fella is good```

# 题解

## 作者：Karl_Aurora (赞：21)

#### [~~无耻地推销个人博客qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7227)

#### [题目传送门](https://www.luogu.com.cn/problem/P7227)

------------

**一道生成字符串的氵题**

这道题要求我们生成最少 $ a $ 个、最多 $ b $ 个单词，其中要求每个单词最多不超过 $ 15 $ 个字母，且至少要有 $ b \div 2 $ 个单词

由于 $ 10 ^ {15} $ 远大于 $ 10 ^ 5 $ ，所以我们完全可以靠从短到长、字典序从小到大的顺序生成包含 ```a``` \~ ```j``` 的字符串，从而氵过这道题

至于生成的方法也很简单，直接 ```for``` 循环生成数字，再分解每一位，将其 ```+'a'``` ，再输出即可

为了保险，我们最好从 $ 1 $ 生成到 $ b $，反正才 $ 10 ^ 5 $，绝对T不飞（逃

最后放上AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, cnt;
int main()
{
	cin >> n;
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
		cnt = i;
		while (cnt) {putchar((cnt % 10) + 'a'); cnt /= 10;}
		putchar(' ');
	}
	return 0;
}
```

在题解的最后，求赞求滋磁啦0v0

---

## 作者：Computer1828 (赞：4)

Python 标算吊打我。~~SPJ 返回 Wrong Andwer 大草。~~

------------

给定的是词数的范围 $[a,b]$，但又规定了不少于 $\dfrac{b}{2}$ 个词，判断到底要生成几个词可能不太好，还不如直接生成一篇长度为 $b$ 的文章。

既然每个词不多于 $15$ 个字母，而 $26^{15}$ 远大于 $10^5$，所以直接按字典序排字母，就像 Excel 第一行的列坐标那样：

```
A B C ... X Y Z AA AB AC ...
```

但显然，并不需要用到那么多字母，根据十进制，可以用十个字母分别对应十个数字：

```
A B C D E F G H I J
0 1 2 3 4 5 6 7 8 9
```

然后从 $1$ 枚举到 $b$ 的时候把枚举变量的每一位替换成上面的字母即可，也就是数位分离。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=m;++i){
		int tmp = i;
		while(tmp>0) putchar((tmp%10)+'a'),tmp /= 10;//字母倒序不影响结果
		putchar(' ');
	}
	return 0;
}
```

---

## 作者：_caiji_ (赞：2)

这道题使用随机化算法可以通过，亲测 `srand(114514)` AC。

我们可以 $\operatorname{rand}()$ 两个东西：单词长度、每个字母。

单词长度可以使用 $\operatorname{rand}()\bmod 15+1$，为什么这是正确的呢？我们可以模拟一下极端情况。如果 $\operatorname{rand}()\bmod 15=0$，那么这个单词的长度是 $1$，符合题意；如果 $\operatorname{rand}()\bmod 15=14$，那么这个单词的长度是 $15$，也符合题意。

同理，每个字母可以使用 $\texttt{'a'}+\operatorname{rand}()\bmod 26$，注意不要 $\bmod 27$（$\texttt{'a'}+26=\texttt{'\{'}$）。

还有一个要注意的地方，题目说要至少 $\frac{b}{2}$ 个不同的单词，如果只输出 $a$ 个单词有可能会被卡。为了保险，$a$ 我们不要了，直接输出 $b$ 个单词。

有了这些，我们可以写出以下代码：
```cpp
#include <cstdio>
#include <cstdlib>
using namespace std;
void f(int x){
    for(int i=1;i<=x;i++)
        putchar('a'+rand()%26);//随机字母
    putchar(' ');
}
int n;
int main(){
    srand(114514);
    scanf("%*d%d",&n);//%*d表示读取这个数字但不保存
    for(int i=1;i<=n;i++) f(rand()%15+1);//随机长度当参传
    return 0;
}
```

---

## 作者：WinterRain208 (赞：1)

P7227 【[COCI2015-2016#3] ESEJ】

#### 题意分析

显然，这是一道构造题，构造的是若干个字符串。

根据题目：

不超过$b$个，不少于$a$个。

至少有$b/2$个互不相同。亲测，向上取整就能过。

长度不超过$15$。

#### SOLUTION

首先考虑构造字符串，因为长度少于$15$，只能由小写字母组成，我们用$abcdefghijklmno$，长度正好为十五，每次输出输出它的下一个全排列。

然后考虑输出多少个，为了方便，我们不输出那些相同的，所以最少要输出$b/2$个字符串。

其次，字符串数量有下限，如果$b/2$比$a$小，那输出$a$个，否则输出$b/2$个。

这题不难找到方法就可以，主要代码还是决定输出多少个字符串。

至于全排列。。。。两种方法。

$STL$自带函数，格式如下：

```
next_permutation(begin,end);
```

如果没有字典序更大的全排列，会返回$-1$，这题数据$10^5$，远小于$15!$，不用考虑。

第二种是递归，或者直接模拟，有点麻烦。

具体学习[戳这里](https://www.luogu.com.cn/problem/solution/P1088)

这题讲到这里就完美解决啦！

上代码。

### $CODE$

```
#include<bits/stdc++.h>

using namespace std;

string a="abcdefghijklmno"; 
int main(){
	int n,m;
	scanf("%d%d",&m,&n);
	n=(n%2?(n+1)/2:n/2);
   	n=(n<m?m:n)
	while(n--){
		next_permutation(a.begin(),a.end());
		cout<<a<<" ";
	} 
	puts("");
    return 0;
}

```

欢迎私信指出错误，代码较为简洁。

附：

```
n=(n%2?(n+1)/2:n/2);
```
这行不加不会错误，只是输出会比较多。

```
n=(n<m?m:n)
```
这行不加$48$。





---

## 作者：Error_Eric (赞：1)

### 前言

挑战最短解

### 正文

枚举 $1$ 到 $b$ ,输出 $26$ 进制。

```cpp
#include<stdio.h>
int a,b;
void f(int x){
	do putchar(x%26+'a'),x/=26; while(x);
	putchar(' ');
}
int main(){
	scanf("%d%d",&a,&b);
	for(register int i=0;i<b;i++)f(i);
}
```
极致压行，你值得拥有。

---

## 作者：Meng142857 (赞：1)

# 本蒟蒻的一篇题解（P7227）
为了节省时间，我们选择输出尽量少的单词，即 $max(a,\frac{b}{2})$ 个，直接造个字典序就可以。  
为了 ~~方便~~ （其实是因为本蒟蒻太蒟了），本蒟蒻造的字典序是反的，请dalao们谅解。  
AC代码如下，请勿抄袭：
```cpp
#include<iostream>
using namespace std;
int main(){
	int a,b;
	cin>>a>>b;
	for(int i=1;i<=max(a,b/2);i++){
		int j=i;
		while(j>0){
			cout<<(char)((j-1)%26+'a');
			j/=26;
		}
		cout<<" ";
	}
	return 0;
}
```

---

## 作者：Wu_while (赞：1)

~~按照惯例~~这里需要一个[传送门](https://www.luogu.com.cn/problem/P7227)

挨个**分析题意**：

1. 这篇文章至少 $a$ 个词，最多 $b$ 个词。

	---限定了范围，直接**造$b$个**比较方便。
    
2. 每个单词至少 $1$ 个字母，最多 $15$ 个字母。

	---显然一个正常的人都不会用$15$个字母的。

3. 文章至少包含 $\dfrac{b}{2}$ 个不同的单词。

	---还是**全部都不同**来的容易。

分(hu)析(che)完毕。

众所周知，从$1$到$b$的自然数是绝对不会有重复的。

那为什么不**用数来代替字母**呢？

将$0$到$9$的数与$a$到$j$的字母一一对应：

|$0 $  | $1 $ | $2 $ |$3 $  | $4 $ | $5 $ | $6 $ | $7 $ | $8 $ | $9 $ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $a $ | $b $ | $c $ | $d $ | $e $ | $f $ | $g $ | $h $ | $i $ | $j $ |

然后从$1$枚举到$b$，把每一位转化为对应的字母，就能产生不重复的 ~~单词~~ 字符串了。
# $Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a,b;
string s="abcdefghij";//与数字对应
void f(int n)//数字转化成字母
{
	int r;
	while(n!=0)
	{
		r=n%10;
		n/=10;//这样是倒着的
		cout<<s[r];//但是没关系
	}
	cout<<' ';
	return;//好习惯
}
int main()
{
	cin>>a>>b;
	for(int i=1;i<=b;i++)//枚举
		f(i);//处理
	return 0;//撒花
 } 
```

[AC 80分](https://www.luogu.com.cn/record/45820995)

---

## 作者：int32 (赞：0)

这题非常有趣，写篇题解。

#### 思路

$a$ 其实并没有用处，直接输出 $b$ 个单词即可。

考虑从 $1$ 遍历至 $b$，输出每个数字的 $26$ 进制。

#### 代码

```cpp
int a, b;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(a),read(b);
	for(int i=1;i<=b;i++){
		int top=i;
		while(top){
			putchar('A'+top%26);//大小写均可
			top/=26;
		}
		putchar(' ');
	}
	return 0;
}
```

---

## 作者：Iron_Heart (赞：0)

## 思路

我们可以输出 $b$ 个单词。

那么从 $1$ 枚举到 $b$，输出每个数字的 $26$ 进制即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b;

int main() {
    scanf("%d%d", &a, &b);
    for (int i = 1; i <= b; ++i) {
        int n = i;
        while (n) {
            putchar('a' + (n % 26));
            n /= 26;
        }
        putchar(' ');
    }
    return 0;
}
```


---

## 作者：juun07 (赞：0)

# 一道很有趣的题目（

看了题目觉得很好玩，就来交一发题解

## 题目大意

- 输入一篇文章的词数范围 $[a,b]$
- 至少有 $\dfrac{b}{2}$ 个不重复的单词
- 输出一篇符合以上要求的文章

## 解题思路

可以看出至少需要 $a$ 个词，可还不能少于 $\dfrac{b}{2}$ 个重复的，有点麻烦，在这里直接写一篇有 $b$ 个词的文章貌似更方便一些

我们还要使单词**不重复**，可以直接使用字典序输出

像这样：

```A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC AD AE AF ...```

以此类推，我们可以枚举$[1,b]$之间的所有数，输出它的“26进制”所对应的那个字母就可以生成一篇长度为 $b$ 并且每个单词都不重复的文章了

## AC Code

```cpp
#include<iostream>
using namespace std;
int main()
{
	int a,b,x;
	char c;
	cin>>a>>b;
	for(int i=1;i<=b;i++)
	{
		x=i;	
        	//可以理解成对i做一个“备份”，防止i改变 
		while(x!=0)	
		{
			c=97+x%10;x/=10;	
            		//对应字典序输出 
			cout<<c;
		}
		cout<<' ';
	}
	return 0;
}
```
## 感谢阅读
~~话说这样写作文会被打吧（~~

---

## 作者：ZolaWatle (赞：0)

## P7227 题解

### 题目大意

写一篇**英语**作文，满足以下要求：

- 作文的词数在 $[a, b]$ 上。
- 单词长度均在 $ [1, 15] $ 上。
- 作文至少包含 $ \frac{b}{2} $ 个不同的单词。

### 解题思路

首先，英语中的单词，根据保守估计一共有五十万个。就算去掉十五个字母以上的单词（大多数时候是医学等专业的名词），也能够满足本题中五万个不同单词的限制。因此，只要您有足够多的肝，打表来做显然可以。（但有没有 50kb 的代码长度限制那就不得而知）

本题的第一篇题解介绍了一种通过 $\text{STL}$ 中 $\text{next\_permutation}$ 函数求排列的做法。这种做法在时间上是很为优秀的，但从文学的角度来看，这篇文章中包含的单词会显得不美观，而且单词的局部是重复累赘的。

为了解决这样的问题，我们考虑**随机生成**这篇作文，让小M的文章更加引人入胜，生动多样，更容易获得高分。

为了简化程序的实现，我们做如下考虑：

- 作文包含 $b$ 个单词。
- 每个单词不会重复。

这两种考虑显然满足题目中的要求。

这样一来，我们可以开一个计数器 $cnt$，当随机生成出一个并未使用过的单词时，令其自增，并将这个单词加入作文；如果碰巧这个单词使用过了，则舍弃，重新生成。当 $cnt=b$ 时，输出这篇作文即可。对于单词有没有出现过的判断，我们考虑使用 $\text{map}$ 实现。

当然，这样的考虑是基于”小M是好学生“这个假设而来的。

代码的实现细节请看：

### 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
/*随机必备的两行*/
#include <cstdlib>
#include <ctime>
/*随机必备的两行*/
#include <map>
#include <cmath>
#define ll long long
#define re register int
#define rl register ll
#define rep(i,a,b) for(re i=(a),i##end=(b);i<=i##end;++i)
#define pre(i,a,b) for(re i=(a),i##end=(b);i>=i##end;--i)
using namespace std;

int a,b,cnt;
string ans;
map <string,int> app;

inline int rint()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48); ch=getchar();}
	return x*f;
}

inline int random(int n){return (ll)rand()*rand()%n;} //这个函数的功能为随机返回一个 0~n 之间的数 

int main()
{
	srand((unsigned)time(0));  //初始化随机种子 
	a=rint(),b=rint();
	while(cnt<b)
	{
		re len=random(15)+1;  //随机生成单词长度，1<=len<=15 
		string tmp="";  //单词 
		rep(i,1,len)
		{
			char ch=(char)(random(26)+97);  //随机生成单词上的第 i 位字符，其中 97 为 a 的 ASCII 码值 
			tmp+=ch;  //将此字母加入单词 
		}
		if(!app[tmp])  //如果未被使用 
		{
			app[tmp]=1;
			if(ans=="")
				ans=tmp;
			else
			{
				ans+=' ';
				ans+=tmp;
			}  //如果这篇作文中已经有单词了，加入的时候要记得单词之间的空格 
			cnt++;
		}
	}
	cout<<ans;
	return 0;
}
```

感谢阅读！

---


# [THUPC 2017] 玩游戏

## 题目描述

ljcc 和他的学妹在玩游戏，这个游戏共有 $n$ 轮，在第 $i$ 轮获胜会获得 $i$ 分，没有平局。

现在给出 ljcc 和学妹的得分，求是否有一种方案符合当前得分。

## 说明/提示

**由于 SPJ 问题，禁止输出行末空格、回车**。

$a,b\le 2^{31}-1,1\le n\le 10^5$
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
10 5```

### 输出

```
5 1 2 3 4```

# 题解

## 作者：luckydrawbox (赞：11)

[传送门](https://www.luogu.com.cn/problem/P7427)

## 分析

易得 ljcc 和学妹的总得分必定为 $1+2+3+……+n$，由小学学过的**等差数列求和**可得总得分为 $\tfrac{n(n+1)}{2}=a+b$，如何求 $n$ 呢？

$$∵n^2<n(n+1)<(n+1)^2$$

$$∴n^2<2(a+b)<(n+1)^2$$

$$∴n<\sqrt{2(a+b)}<n+1$$

$$∴\ n=\left\lfloor\sqrt{2(a+b)}\right\rfloor$$

即 ``n=sqrt(2*(a+b))``。

我们求出 $n$ 后，判断 $n(n+1)$ 是否与 $2(a+b)$ 相等。

- 若不相等，说明无解，直接输出 ``No``，结束程序。

- 若相等，说明有解，输出 $n$，接下来开始**构造**：

构造的想法与[P7071 [CSP-J2020] 优秀的拆分](https://www.luogu.com.cn/problem/P7071)的**贪心**相似，枚举 $i$ 从 $n$ 到 $1$，若 $a≥i$，则令 ``a-=i``，并输出 $i$，即尽量减去**较大**的得分，可以用**决策包容性**证明这个贪心是正确的。

当然，你会注意到 $a,b$ 的最大值为 $2^{31}−1$，加起来一定会超过 ``int`` 范围，所以要开 ``long long``。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,n;//long long莫忘 
int main()
{
    cin>>a>>b;
    n=sqrt(2*(a+b));//求n 
    if(n*(n+1)!=2*(a+b))//判断是否相等 
    {
    	//无解 
    	cout<<"No";
    	return 0;
	}
	//有解 
	cout<<n;
    for(int i=n;a;i--)//从n开始向下枚举 
    {
    	if(a>=i)
    	{
    		a-=i;//尽量减大的 
    		cout<<" "<<i;//注意格式 
		}
	}
	return 0;
}
```


---

## 作者：wangbinfeng (赞：5)

首先，感谢大家阅读这篇题解
# 1. 思路：
（1）我们看到这个题，可先考虑最好想的，即如何判断 ```No```：

> $\;$解：设总分为x，进行了n轮，则：

>$\qquad$ ∵x=a+b= $\frac{n*(n+1)}{2}$

>>> 这一步是为什么呢。我们知道1+2+3+...+n=$\frac{n*(n+1)}{2}$（等差数列求和）

>>>如果不这道等差数列求和的同学，让我们一起把等差数列求和公式推一边：

>>>$\;$1+2+3+...+n

>>>=(1+2+3+...+n)+(n+(n-1)+(n-2)+...+1)/2

>>>=((n+1)+(n+1)+(n+1)+...+(n+1))/2 $\quad$ $\quad$ //n个（n+1）

>>>=$\frac{n*(n+1)}{2}$

>$\qquad$∴a+b= $\frac{n*(n+1)}{2}$

>$\qquad$∴n= $\sqrt{2(a+b)}$

即如果 $\sqrt{2(a+b)}$ 不等于 $\frac{n*(n+1)}{2}$，就输出 ```No```。

（2）做到这里，答案也就呼之欲出了——暴力搜索。既然其他题解的重头戏都在这里，我也就不浪费地方了。下面的介绍，选自[@W文韬武略W](https://www.luogu.com.cn/blog/_post/318428)，大家自己阅读，不懂得可以在评论区问我呦：
> 我们从大到小遍历每一个数，如果 a 大于这个数，那么这个数就是答案之一，将其输出再让 a 减去这个数即可。具体可见代码。

# 2. ~~代码：~~
都讲~~这么清楚~~了，代码就不用给出了吧！
# 3. 题外话：
（1）这篇题解与其他题解不同之处：其他的题解都注重暴力搜索的方法，这篇题解照顾基础比较差的同学 ~~（me too）~~ ，基础讲的比较细致。

---

## 作者：cyffff (赞：3)

#### [_传送门_](https://www.luogu.com.cn/problem/P7427)
~~我为什么会无聊到写这种题的题解？~~
## 题意
~~我直接复制题面好了~~

两个人在玩游戏，这个游戏共有 $n$ 轮，在第 $i$ 轮获胜会获得 $i$ 分，没有平局。

现在分别给出两个人的得分，求是否有一种方案符合当前得分并输出方案。
## 思路
玩了 $n$ 轮，总分一定为 $\dfrac{n(n+1)}2$，如果 $a+b$ 不能表示成这种形式，那么一定无解。

那么接下来怎么构造解呢？

我们令 $i$ 从 $n$ 向 $1$ 扫，如果当前的 $a\ge i$，就输出 $i$，并 $a\gets a-i$。

证明这样构造一定有解：

首先目标为 $a=0$，那么假设 $a$ 无法变为 $0$，即 $a\ge 1$，那么 $a$ 要减去 $1$，若仍不能达到答案，则 $a\ge2$，那么 $a$ 要减去 $2$，以此递推，又 $a\le \dfrac{n(n+1)}2$，所以假设不成立。

最后一定不要输出行末空格、回车啊！

~~这种题需要代码吗？~~

---

## 作者：Solgareo (赞：2)

~~ljcc是谁啊~~

# 题意

共有 $ n $ 轮游戏，在第 $ i $ 轮获胜会获得 $ i $ 分，没有平局。
给定两个得分，求合理方案。

数据范围：
 $a$ , $b$ $≤$ $2^{31}$ − $1$ , $1$ $≤$ $n$ $≤$ $10^5$

# 思路

### 判断无解

根据等差数列得 $n$ 轮游戏总分必为 $\frac{n(n+1)}{2}$，
即如果 $n$ ≠ $\sqrt{2(a+b)}$ 输出No



```cpp
int n = sqrt(2 * (a + b));
if (a + b != n * (n + 1) / 2){
	cout << "No";
	return 0;
}
cout << n << " ";
```

---

### 计算可能结果

为了防止出现一轮赢两次的情况，我们从大到小遍历：

如果 $a$ $≥$ $i$ ，那么 $i$ 就是其中一个解， $a$ 减去 $i$ 后继续遍历。

```cpp
for(int i = n ; i > 0 ; i --){
	if(i < a){      //不包括等于，行末不要空格
		cout << i << " ";
		a -= i;
	}
	else if(i == a){//如果相等那么必为最后一个结果
		cout << i;
		return 0;
	}
}
```

题目比较简单，完整代码就不放了（记得开long long）

---

## 作者：HYdroKomide (赞：2)

~~恶评！建议降红！~~
# **正文：**
## 题意：
这明显是一道构造题，两个人游戏分数的总和必为 $a+b=n*(n+1)/2$，否则无解。我们也可以通过 $a+b$ 反推出 $n$，即 $n=\left\lfloor\sqrt{2*(a+b)}\right\rfloor$。这时我们再回头，通过 $n$ 来判断是否有解。最后通过贪心求出最终结果即可。时间复杂度：$O(n)$
## 程序如下：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long long a,b,n;//注意这里要开long long
int main(){
	scanf("%lld%lld",&a,&b);
	n=sqrt(2*(a+b));
	if(n*(n+1)!=2*(a+b)){
		printf("No");
		return 0;
	}
	printf("%lld",n);
	for(long long i=n;i>0;i--)
		if(a>=i){//i从大到小枚举，如果a>=i，就将i输出并将a减去i，以此贪心
			printf(" %lld",i);//不能加额外的空格或回车
			a-=i;
		}
	return 0;
}
```
# **THE END**

---

## 作者：Unordered_OIer (赞：2)

# P7427 题解

~~水一波构造题~~

## Description
给定一个人的得分值为 $a$，另一个为 $b$。第 $i$ 个时间的得分为 $i$，求是否有可能为给出的得分情况。

## Solution
首先得判断一下 $a+b$ 是否合法，时刻都是整数时刻，所以 $a+b$ 一定可以表示为 $\sum\limits_{i=1}^ni$ 的形式，即 $a+b=\dfrac{n \times (n+1)}{2}$。

于是就把 $\sqrt{2(a+b)}$ 的整数部分提取出来然后回溯判断一下就能判无解了。

然后考虑构造一个解。

首先总共玩的时间就是 $\left\lfloor\sqrt{2(a+b)}\right\rfloor$。

然后枚举 $i$，依次把 $a$ 减去 $i$ 直到无法可减为止。需要注意的是当 $a$ 无法减去当前的 $i$ 时需要回溯上一步的 $i$。因此我们不妨把 $i$ 从大到小进行枚举就可以避免这个问题。

复杂度 $\mathcal O(\left\lfloor\sqrt{2(a+b)}\right\rfloor)$

---

## 作者：Karl_Aurora (赞：1)

**[~~无耻地推销个人博客qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7427)**

**[题目传送门](https://www.luogu.com.cn/problem/P7427)**

------------

## 题意

给定两个正整数 $ a , b $ ，求一正整数 $ n $ ，使得 $ \sum\limits_{i = 1}^{n} i = a + b $ ，并从 $ [ 1, n ] $ 中挑选若干个数，使其和为 $ a $


## 解法

因为 $ \sum\limits_{i = 1}^{n} i = \frac{n(n+1)}{2} $ ，且 $ 1 \leq n \leq 10^5 $ ，故我们可以直接二分枚举 $ n $ ，并检验是否合法（当然你也可以直接用公式QwQ

至于方案，我们只需枚举 $ i = n \rightarrow 1 $ ，每当 $ a ＞ i $ 时，$ i $ 一定在合法解中，同时将 $ a $ 减去 $ i $

最后输出所有在当前合法解中的 $ i $ 即可

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define maxn 100000
ll a, b, l, r, mid, x;
bool f = true;
int main() 
{
    cin >> a >> b;
    b += a; //存储得分总和
    ll l = 0, r = maxn;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        x = (mid * (mid + 1)) >> 1;
//      cout << l << " " << r << endl;
        if (x < b) l = mid + 1;
        else if (x > b) r = mid - 1;
        else {l = mid; f = false; break;}
        //二分枚举最终进行了多少次游戏
    }
//  cout << l << " " << r << endl;
    if (f) {cout << "NO" << endl; return 0;} //如果无法得到，则输出"NO"
    cout << l ;
    for (ll i = l; i && a; --i)
    {   
        if (a >= i) {
            a -= i;
            cout << " " << i ;
        }
    }
    return 0;
}
```

至此，愉快AC，完结撒花0v0

---

## 作者：int32 (赞：0)

~~不会构造的蒟蒻口胡一波。~~

### 思路

#### 1. 局数的求法

若已经比完了 $n$ 轮，那么 $a+b=\sum_{i=1}^n=\frac{n(n+1)}{2}$（若不符合，直接输出`No`）, 即 $n(n+1)=2(a+b)$。

考虑 $n(n+1)$ 的转化, 我们知道 $n^2<n(n+1)<(n+1)^2$ 所以 $n^2<2(a+b)<(n+1)^2$, 所以 $n=\left \lfloor \sqrt{2(a+b)} \right \rfloor$。

这样我们求出 $n$ 了。

#### 2. 赢的回合

从 $n$ 到 $1$ 遍历，若 $a\ge i$, 则 $a\gets (a-i)$ 输出 $i$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a, b;
signed main(){
	scanf("%lld%lld",&a,&b);
	int n=sqrt(2*(a+b));
	if(n*(n+1)!=2*(a+b)){
		puts("No");
		return 0;
	}
	printf("%lld",n);
	for(int i=n;i>=1;i--) if(a>=i) printf(" %lld",i),a-=i;
	return 0;
}
```

---

## 作者：naroanah (赞：0)

显然，他们分数的总和是一个等差数列的和，由此可得 $a+b=\dfrac{n(n-1)}{2}$，如果不符则无解；根据此式可反推出 $n=\sqrt{2(a+b)}$，解出第一问。

然后是一个贪心，我感觉有点像[CSP-J2020]优秀的拆分。倒序枚举，如果此时$a\ge i$，就直接输出，然后令 $a$ 减去 $i$ 即可。

最后注意开`long long`和输出格式就好了，代码过水就不放了。

---

## 作者：RyanCh (赞：0)

这道题的题意很容易理解。

玩一个游戏有 $n$ 轮，在第 $i$ 轮获胜会获得 $i$ 分，没有平局，请你提供1种方案。

思路：

1. 我们要先判断游戏进行了几轮，因为数据较小，可以直接用循环实现。

2. 判定完进行了多少轮后，判定是否合理，若不合理直接输出```No```

3. 用```stack```(栈)和贪心思想，将得分分配。

具体实现过程：

首先，已知 ljcc 和学妹的得分之和一定是全部的分数，

利用等差数列的规则，我们根据题意，设$n$为游戏的轮数，

则$\dfrac{n \times (n+1)}{2}=a+b$

只要符合这个原则，那么就有成立方案。

否则就没有输出```No```。

接下来，我们要从大到小进行分配，

因为如果从小到大进行分配，

那么最后就会有可能只剩下一个比较小的数（比当前循环的数要小），

那么就没有办法了。

因为要从小到大分配，所以，想把数从小到大输出的话，用```stack```(栈)就可以了。

因此，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long a,b;
	scanf("%lld%lld",&a,&b);
	long long n=0;
	while(n*(n+1)/2<a+b)
		n++;
	if(n*(n+1)/2!=a+b){
		printf("No");
		return 0;
	}
	printf("%d",n);
	stack<long long> s;
	for(long long i=n;i>=1&&a>0;i--)
	{
		if(a<i) continue;
		s.push(i);
		a-=i;
	}
	while(!s.empty()){
		printf(" %lld",s.top());
		s.pop();
	}
	return 0;
}
```


---


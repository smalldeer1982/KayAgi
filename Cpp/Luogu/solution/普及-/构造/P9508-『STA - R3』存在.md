# 『STA - R3』存在

## 题目描述

构造一个长度为 $n$ 的序列，满足对于任意长度不小于 2 的子区间存在主元素。在此基础上，要求序列元素的种类数最大。其中序列的主元素定义为出现次数不小于序列长度的一半的数。

你构造的数列中每个元素必须是 $0$ 到 $10^9$ 之间的整数。

## 说明/提示

**本题采用捆绑测试。**

数据范围：
- Subtask 1 (10pts)：$n\le 5$。
- Subtask 2 (40pts)：$n$ 是 $3$ 的倍数。
- Subtask 3 (50pts)：无特殊限制。

对于全部数据，$1\le n\le 10^3$。

## 样例 #1

### 输入

```
3```

### 输出

```
1 1 2```

# 题解

## 作者：lemon_qwq (赞：13)

看到题面很容易想到形如 $1,2,1,3,1,4,1,5,1,6\cdots$ 的序列。

很明显这个序列是不对的，因为如果选中类似 $2,1,3$ 的子区间会发现不满足条件。

根据条件进行修改即可。

序列变为 $1,2,1,1,3,1,1,4,1,1\cdots$。

提交会发现有一个点不正确，因为这个方法不是最优的。

继续修改，把整个序列整体向前移一位。

序列变为 $2,1,1,3,1,1,4,1,1,5\cdots$。

这样便是最优的，因为省掉了开头不需要的 $1$，节省下来了一个位置。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,a=2,b=0；
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		if(b==0){
			cout<<a<<" ";
			a++;
			b=2;
		}
		else{
			b--;
			cout<<1<<" ";
		}
	}
	return 0;
}
```
完结撒花。

---

## 作者：rainygame (赞：6)

发现题解区里的都是 $O(n)$ 的题解，那我只好放一个 $O(n^2)$ 的题解了。毕竟 $n \le 10^3$ 嘛。

其实就是贪心。对于每一个 $i$，如果对于**任意** $1 \le j < i$，$[j,i)$ 里出现次数最多的数都达到了 $\lceil \dfrac{i-j+1}{2}\rceil$，那么说明可以放一个之前都没有出现过的；否则只能放 $[1,i)$ 里面出现次数最多的。

其实还可以优化的，但是不想优化了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1001

int n, maxn, flag, res, ind, ind2;
int a[MAXN], cnt[MAXN];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i(1); i<=n; ++i){
    	for (int j(1); j<=i; ++j) cnt[j] = 0;
    	maxn = flag = 0;
    	for (int j(i-1); j>=1; --j){
    		++cnt[a[j]];
    		if (maxn < cnt[a[j]]){
    			maxn = cnt[a[j]];
    			ind = a[j];
			}
    		res = i-j+1;
    		if (maxn < (res>>1)+(res&1)) flag = 1;
		}
		if (!flag) a[i] = ++ind2;
		else a[i] = ind;
		cout << a[i] << ' ';
	}

    return 0;
}
```


---

## 作者：jijidawang (赞：5)

因为 Kaguya 先走一步了，所以题解是我写的。

结论：构造的序列形如 `1 2 2 3 2 2 4 2 2 ...`。

首先序列显然满足任意子区间存在主元素，关于元素种类数最大，考虑任意长为三的子区间至少有两个数相同，那么任意长为三的区间至多有两种颜色。假如三个数分成一组，那么考察相邻的两组，如果出现了四种不同元素，那么肯定形如 $a,b,b,c,d,d$，可以注意到整个区间是不存在主元素的，所以任意相邻两组必然存在一种元素相同。

那么，讨论 $n\bmod 3$ 的值：
- 如果 $n\bmod 3=0$，那么有 $\frac n3$ 组，从而此时至多有 $\frac n3+1$ 种颜色，因为最多有 $\frac n3$ 个不同的，$1$ 个公共的。
- 如果 $n\bmod 3=1$，那么有 $\frac{n-1}3$ 组，从而此时至多有 $\frac{n-1}3+2$ 种颜色，因为最多有 $\frac{n-1}3+1$ 个不同的，$1$ 个公共的。
- 如果 $n\bmod 3=2$，那么有 $\frac{n-2}3$ 组，从而此时至多有 $\frac{n-2}3+2$ 种颜色，因为最多有 $\frac{n-2}3+1$ 个不同的，$1$ 个公共的。

综合，可以知道最多有 $\lfloor\frac{n-1}3\rfloor+2$ 种颜色。注意到这个构造正好取到这个界，于是构造方案就是满足元素种类数最大的了。

那么这题就做完了，时间复杂度 $O(n)$，可以通过。

---

## 作者：啊吧怪 (赞：1)

### 题意 

构造一个长度为 $n$ 的序列，满足对于任意长度不小于 $2$ 的子区间里满足有一个元素的出现次数不小于该子区间长度的一半，且元素种类最多。

### 解析

首先观察 Subtask $2$ 部分分的提示，然后考虑对于任意长度为三的区间内应有两个相同元素，同时若连续两个长度为三的子序列合为一个长度为六的子序列时，若两个子序列中的主元素不同，易证无法构成合法序列。

以此类推，易证对于所有长度为三的子序列中的主元素相同，不妨设该元素为 $1$。

然后构造序列，由于要求元素种类最多，所以除去 $1$ 后，每个长度为三的子序列中剩余的一个元素不应相同。

最优序列可根据代码进行进一步理解。

### 代码
```

#include <bits/stdc++.h>
using namespace std;
int n,x=1;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		if(i%3!=0) cout<<"1 ";
		else cout<<++x<<' ';
	}
	return 0;
}
```

---

## 作者：ys_kylin__ (赞：0)

乍一看到这题可能觉得很难写，毕竟提到了“区间”。但是其实提示已经在特殊性质中告诉你了！也就是部分数据 $n$ 是 $3$ 的倍数。为什么这么说？很明显，当 $n$ 是 $3$ 的倍数时,只需要两个相同的数（以后均称为 $20110804$）,一个不同的数就行了，那其实不是 $3$ 的倍数也很简单，也就是：

1. 余一，在序列中放入一个不同的数就可以了。
2. 余二，放入一个不同的数，一个 $20110804$。

循环一遍，从 $1$ 到 $n$ 枚举，如果 `i%3==1` 输出 $i$（不同的数）。否则输出 $20110804$，这样恰好能完成目标。


------------
代码很简单，就十行。
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		if(i%3==1) printf("%d ",i);
		else printf("20110804 ");//可以自定义
	return 0;
}

---

## 作者：KAqwq (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9508)

## 构造方法
考虑以 $1$ 为每个子序列的主元素，并保证在每一个长度 $\geq 3$ 的子序列中都有至少 $\lceil \frac{n}{2} \rceil$ 个 $1$，这样的构造是合法的。

## 思路
考虑 $n=8$ 的情况，据上方法构造后的序列如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/xnxqyhib.png)
显然对于每个长度为 $3$ 的序列，这样的构造是合法的，以此类推，直到子序列长度与 $n$ 相等。

可以在 $\lfloor \frac{n}{3} \rfloor$ 次的循环中，每一次都输出一个依次递增的自然数 `res`，之后输出两个由空格隔开的 $1$，在最后判断 $n \bmod 3$，当 $n \bmod 3 = 1$ 时
，输出 `res`，当 $n \bmod 3 = 2$ 时输出 `res` 和一个 $1$。

由于本题开启 `spj`，所以只需要输出一组合法的构造即可。

## Code

```
#include<bits/stdc++.h>
typedef long long LL;
LL n,res=2;
int main(){
	std::cin>>n;
	for(LL i=1;i<=n/3;++i){
		std::cout<<res<<' '<<1<<' '<<1<<' ';
		++res;
	} 
	if(n%3==1) std::cout<<res;
	if(n%3==2) std::cout<<res<<' '<<1;
	return 0;
}
```

---


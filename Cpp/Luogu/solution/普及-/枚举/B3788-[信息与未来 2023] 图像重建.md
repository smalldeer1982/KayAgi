# [信息与未来 2023] 图像重建

## 题目背景

JWST (詹姆斯·韦伯太空望远镜，James Webb Space Telescope) 是一台红外波段的大型太空望远镜，由美国国家航空航天局 (NASA)、欧洲航天局 (ESA) 和加拿⼤航天局 (CSA) 共同合作开发。它是哈勃太空望远镜的科学继任者，旨在解决⼀系列重要的天文学问题，包括宇宙的起源、星系的形成和演化、恒星和行星系统的形成，以及寻找宜居⾏星和生命迹象。

以下是 JWST 望远镜 5 ⽉ 23 ⽇采集的深空图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/nmcrklbq.png)

## 题目描述

太空望远镜在采集数据时，并不像我们日常生活中的手机或相机 “一次拍摄成像” 直接从传感器数据得到照⽚，而是由多次不同时段拍摄的图像拼接而成。在这个问题中，我们也来实现图像的拼接重建。

我们已经对⼀个区域拍摄了**两张**黑白图像。这两张图像面向同⼀区域拍摄，因此我们预期它们有相当⼀部分都是重叠的。你的任务就是将两张图像经过上下左右平移后尽可能 “重叠” 在⼀起，满⾜重叠部分所有像素均完全相同，且**重叠部分的⾯积尽可能⼤（即重叠部分的像素数量尽可能多）**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq n,m\leq 50$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
3 3
0 0 0
0 1 1
0 1 1

2 4
1 1 0 0
1 1 0 1```

### 输出

```
4```

# 题解

## 作者：szh_AK_all (赞：8)

[传送门](https://www.luogu.com.cn/problem/B3788)

这道题可以用**暴力枚举**来做（本人是没有更好的方法了），枚举方法是：将横轴从 $-n1$（第一张图像的行数）枚举到 $n1$，将纵轴从 $-m1$（第一张图像的列数）枚举到 $m1$（枚举平移时所移动的行、列），再依次判断重叠部分有多少个像素相同。
##  初始作法（20分）
```c
#include<iostream>
#include<cstring>
using namespace std;
int a[55][55],b[55][55];
int main()
{
    int n1,m1;
    cin>>n1>>m1;
    for(int i=1;i<=n1;i++)
        for(int j=1;j<=m1;j++)
            cin>>a[i][j];
    int n2,m2;
    cin>>n2>>m2;
    for(int i=1;i<=n2;i++)
        for(int j=1;j<=m2;j++)
            cin>>b[i][j];
    int ans=0;
    for(int i=-n1;i<=n1;i++)//枚举
        for(int j=-m1;j<=m1;j++)
        {
            int tmp=0;
            for(int k=1;k<=n1;k++)//判断
                for(int t=1;t<=m1;t++)
                {
                    if(a[k][t]==b[k-i][t-j])
                        tmp++;
                }
            if(tmp>ans)
                ans=tmp;
        }
    cout<<ans;
    return 0;
}
```
像这样做，我们会发现评测时有三处 RE 了，原因是：数组越界了，在极端情况下，代码中的 `k-i` 会达到 $-49$，而数组无法接受为负数的下标。当然还有一点原因是题目中说“满足重叠部分所有像素均完全相同”，这是我们没考虑到的一点。
## 满分做法
```c
#include<iostream>
#include<cstring>
using namespace std;
int a[55][55],b[55][55];
int main()
{
    int n1,m1;
    cin>>n1>>m1;
    for(int i=1;i<=n1;i++)
        for(int j=1;j<=m1;j++)
            cin>>a[i][j];
    int n2,m2;
    cin>>n2>>m2;
    for(int i=1;i<=n2;i++)
        for(int j=1;j<=m2;j++)
            cin>>b[i][j];
    int ans=0;
    for(int i=-n1;i<=n1;i++)//枚举
        for(int j=-m1;j<=m1;j++)
        {
            int tmp=0;
            for(int k=1;k<=n1;k++)//判断
            {
                int p=0;//开关
                for(int t=1;t<=m1;t++)
                {
                    if((k+i)>=1&&(k+i)<=n2&&(t+j)>=1&&(t+j)<=m2)//注意：这里应判断(k+i)<=n2而不是n1
                    {
                        if(a[k][t]!=b[k+i][t+j])
                        {
                            p=1;
                            tmp=0;
                            break;//不符合“满⾜重叠部分所有像素均完全相同”这一要求，需退出循环
                        }
                        else
                        tmp++;
                    }
                }
                if(p==1)
                break;//退出循环
            }
            if(tmp>ans)//打擂
                ans=tmp;
        }
    cout<<ans;
    return 0;
}
```


---

## 作者：_Joseph_ (赞：6)

# B3788 题解

[题目传送门](https://www.luogu.com.cn/problem/B3788)

## 题目大意：

给你两张图它们可以随意的平移，求平移后完全重合的最多格点数。

## 思路：

首先看到说明提示。

对于百分之一百的的数据，满足 $1 \le n,m \le 50$ 我们就可以想到用**暴力枚举的方法**。~~其实是我是蒟蒻想不到其他办法了。~~

那我们要怎么搜呢？分别枚举图 $2$ 的 $x$ 和 $y$ 轴再和图 $1$ 来对比就行了。

~~都快看完了点点赞吧。~~

## 最期待的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 55;
int n1, n2, m1, m2, res = -0x3f;//第一张图和第二张图的n和m,res是重合的最大值;
bool xy1[N][N], xy2[N][N];//第一张图和第二张图的像素;

int main() {
//读入数据;
	cin >> n1 >> m1;
	for(int i = 1;i <= n1;i++)
		for (int j = 1;j <= m1;j++)
			cin >> xy1[i][j];
	cin >> n2 >> m2;
	for(int i = 1;i <= n2;i++)
		for(int j = 1;j <= m2;j++)
			cin >> xy2[i][j];
//开始暴力枚举;
for(int dx = -n1;dx <= n1;dx++)//枚举x轴移动方向
	for(int dy = -m1;dy <= m1;dy++){//枚举y轴移动方向
	int ans = 0,f = 1;
	for(int i = 1;i <= n2;i++)//扫数组
		for(int j = 1;j <= m2;j++){
		int nx = i + dx,ny = j + dy;
		if(nx > 0 && nx <= n1 && ny > 0 && ny <= m1) {
			if(xy1[nx][ny] == xy2[i][j]) ans++;
			else f = 0;//有不同的直接清零;
		}
	}
	res = max(res, ans * f);
}
cout << res << endl;
	return 0;//完美结束;
}
```


---

## 作者：Wi_Fi (赞：5)

看到对于 $100\%$ 的数据，满足 $1\leq n,m\leq 50$。

所以直接暴力枚举即可。

但是暴力枚举也是应该有方法的。我们怎么暴力枚举呢？

左上-右下：我们先让第二个矩阵的左上角元素依次与第一个矩阵的每一个元素位置重合，然后让第一个矩阵的左上角元素依次与第二个矩阵的每一个元素位置重合，就可以枚举出所有情况。

左下-右上：我们先让第二个矩阵的右上角元素依次与第一个矩阵的每一个元素位置重合，然后让第一个矩阵的右上角元素依次与第二个矩阵的每一个元素位置重合，就可以枚举出所有情况。


代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=55;
int i,j,ii,jj,n,m,nn,mm,a[N][N],b[N][N],ans;
void lu_rd(int n,int m,int nn,int mm,int a[N][N],int b[N][N])
{
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			int flag=0,sum=0;
			for(ii=i;ii<=min(n,i-1+nn);ii++)
			{
				for(jj=j;jj<=min(m,j-1+mm);jj++)
				{
					if(a[ii][jj]!=b[ii-i+1][jj-j+1])
					{
						flag=1;
						break;
					}
					else sum++;
				}
			}
			if(flag==0)ans=max(ans,sum);
		}
	}
}
void ld_ru(int n,int m,int nn,int mm,int a[N][N],int b[N][N])
{
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			int flag=0,sum=0;
			for(ii=i;ii<=min(n,i-1+nn);ii++)
			{
				for(jj=max(1,j-mm+1);jj<=j;jj++)
				{
					if(a[ii][jj]!=b[ii-i+1][mm-j+jj])
					{
						flag=1;
						break;
					}
					else sum++;
				}
			}
			if(flag==0)ans=max(ans,sum);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)cin>>a[i][j];
	}
	cin>>nn>>mm;
	for(i=1;i<=nn;i++)
	{
		for(j=1;j<=mm;j++)cin>>b[i][j];
	}
	lu_rd(n,m,nn,mm,a,b);
	lu_rd(nn,mm,n,m,b,a);
	ld_ru(n,m,nn,mm,a,b);
	ld_ru(nn,mm,n,m,b,a);
	cout<<ans;
	return 0;
}
```


---

## 作者：fantastic_dream (赞：3)

分享一个码量大但是跑得快的解法。

一个相当锻炼码力的模拟题，暴力思路相当好想：我们知道如果把一张照片以固定位置放在另一张上面，那重叠的数量是一定的，所以可以枚举照片的固定位置，以照片左上角和右上角为基准遍历另一张照片的每个位置。

但是这种解法边界情况比较麻烦，可以画图理解：
![](https://cdn.luogu.com.cn/upload/image_hosting/32qvvq4r.png)

左上是第一个矩形，右下是第二个，重叠部分的起点是 $(i,j)$，终点是 $(n_1, m_1)$，我们求矩形边长即可。很明显，长即为 $m_1-j+1$，宽为 $n_1-i+1$，所以行列上遍历的上下界就出来了，还不懂的可参见代码。

当然还有右上角重叠的情况，图放这里，可以自己推边长，注意这里坐标都是相对于上面的矩形。
![](https://cdn.luogu.com.cn/upload/image_hosting/hc2hepmx.png)

当然还有其他重叠的方法，只要把第一个矩形换成第二个就行，遍历数组重叠部分，如果有不同，直接退出。

这样的方法吸个氧轻松跑到最优解。复杂度为 $O(n^4)$，下面是冗长的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n1,m1,n2,m2,sz1[55][55],sz2[55][55],ans=0;
int main(){
	cin>>n1>>m1;
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=m1;j++){
			cin>>sz1[i][j];
		} 
	}
	cin>>n2>>m2;
	for(int i=1;i<=n2;i++){
		for(int j=1;j<=m2;j++){
			cin>>sz2[i][j];
		} 
	}
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=m1;j++){
			bool yj=0;int re=0;
			for(int ii=1;ii<=min(n2,n1-i+1);ii++){
				for(int jj=1;jj<=min(m2,m1-j+1);jj++){//第一个图中的情况 
					if(sz1[i+ii-1][j+jj-1]!=sz2[ii][jj]){
						yj=1;
						break;
					}
					re++;
				}
				if(yj)	break;
			}
			if(!yj)	ans=max(ans,re);
		} 
	}
	for(int i=1;i<=n2;i++){
		for(int j=1;j<=m2;j++){
			bool yj=0;int re=0;
			for(int ii=1;ii<=min(n1,n2-i+1);ii++){
				for(int jj=1;jj<=min(m1,m2-j+1);jj++){
					if(sz2[i+ii-1][j+jj-1]!=sz1[ii][jj]){
						yj=1;
						break;
					}
					re++;
				}
				if(yj)	break;
			}
			if(!yj)	ans=max(ans,re);
		} 
	}
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=m1;j++){
			bool yj=0;int re=0;
			for(int ii=i;ii<=min(i+n2-1,n1);ii++){
				for(int jj=max(1,j-m2+1);jj<=j;jj++){
					if(sz1[ii][jj]!=sz2[ii-i+1][m2-j+jj]){
						yj=1;
						break;
					}
					re++;
				}
				if(yj)	break;
			}
			if(!yj)	ans=max(ans,re);
		} 
	}
	for(int i=1;i<=n2;i++){
		for(int j=1;j<=m2;j++){
			bool yj=0;int re=0;
			for(int ii=i;ii<=min(i+n1-1,n2);ii++){
				for(int jj=max(1,j-m1+1);jj<=j;jj++){
					if(sz2[ii][jj]!=sz1[ii-i+1][m1-j+jj]){
						yj=1;
						break;
					}
					re++;
				}
				if(yj)	break;
			}
			if(!yj)	ans=max(ans,re);
		} 
	}
	cout<<ans;
} 
```


---

## 作者：cuiyuchen (赞：3)

# B3788题解

算法 ：暴力枚举

这一题不难，只需要枚举可能的移动方向，再扫一遍数组，看有几个重叠，然后取最大值。
以下是代码：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n1,m1,n2,m2,mans;
bool a1[55][55],a2[55][55]; 
signed main(){
	cin >> n1 >> m1;
	for(int i = 1;i <= n1;i++)
	    for (int j = 1;j <= m1;j++)
	        cin >> a1[i][j];
	cin >> n2 >> m2;
	for(int i = 1;i <= n2;i++)
	    for(int j = 1;j <= m2;j++)
	        cin >> a2[i][j];
	for(int dx = -n1;dx <= n1;dx++)//x轴移动方向
	    for(int dy = -m1;dy <= m1;dy++){//y轴移动方向
	    	int ans = 0;
	    	bool flag = true;
	    	for(int i = 1;i <= n2;i++)//扫数组
	    	    for(int j = 1;j <= m2;j++){
	    	    	int nx = i + dx;
	    	    	int ny = j + dy;
					if(nx > 0 && nx <= n1 && ny > 0 && ny <= m1){
	    	    		if(a1[nx][ny] == a2[i][j])
	    	    		    ans++;
	    	    		else
	    	    		    flag = false;
					}
				}
			mans = max(mans,ans * flag);
		}
	cout << mans << endl;
	return 0;
}

```
****

---

## 作者：wangweichen666 (赞：2)

## 题目大意

这道题要用到暴力枚举，暴力枚举不算简单，~~毕竟也是个橙题~~，这道题给定了两个二维序列，需要我们求出这两个二维序列的其中一个序列经过上下左右的平移操作后，**最多**有多少个像素（即数字）重合（即相等）。
## 题目分析

“对于 $100\%$ 的数据，满足 $1\le n,m \le 50$”，这说明了什么？说明了我们可以用最简单的暴力枚举！



## 解法

刚拿到这道题的时候，我已经打出了这个代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,n2,m2,ans=0,maxx=INT_MIN;
bool a[60][60],b[60][60];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>n2>>m2;
	for(int i=1;i<=n2;i++)
		for(int j=1;j<=m2;j++)
			cin>>b[i][j];
	for(int i=-n;i<=n;i++){
		for(int j=-m;j<=m;j++){
			ans=0;
			for(int k=1;k<=n2;k++){
				for(int x=1;x<=m2;x++){
					if(a[i][j]==b[k][x]&&k<=n&&x<=m) ans++;
					
				}
			}
			if(ans>maxx) maxx=ans;
		}
	}
	cout<<maxx;
	return 0;
}
```
然后我发现样例也过了，就信心满满的交了这道题，于是就只得了 $20$ 分。回过头来一想，这道题并没有这么简单。

实际上，以上代码的 $i$ 和 $j$ 不能从 $1$ 开始枚举，我们可以把 $i$ 理解成 $x$ 轴，$j$ 理解成 $y$ 轴。这样的话我们就能发现，$i$ 应该从 $-n$ 开始枚举，$j$ 应该从 $-m$ 开始枚举。并且，在枚举时我们需要建立两个变量，表示 $x,y$ 轴上的动量，一个赋值为刚才提供代码中的 $i+k$，另外一个赋值为 $j+x$。

解决完上述问题，基本这道题就搞定了，但是还有一个要点：一种重叠方式发现有不同必须立即退出循环，但是有些人可能会一步一步的 break，就像这样：
```cpp
for(int i=-n;i<=n;i++){
	for(int j=-m;j<=m;j++){
		ans=0;
		bool tf=0;
		for(int k=1;k<=n2;k++){
			for(int x=1;x<=m2;x++){
				int blx=i+k,bly=j+x;
				if(blx>0&&bly>0&&blx<=n&&bly<=m) 
					if(a[blx][bly]==b[k][x]) ans++;
					else{
						tf=1;
						break;
					}
			}
			if(tf) break;
		}
		if(!tf) maxx=max(ans,maxx);
	}
}
```
如果按上面的代码这样写的话会非常的麻烦，代码的行数也会很多，我们其实可以设置一个布尔变量，初始值为 $1$，如果一种重叠方式发现有不同就把这个布尔变量设为 $0$，否则就还是 $1$，然后在最后求最大值的时候把计数变量乘上这个布尔变量，如果布尔变量的值是 $0$，那么这个计数变量就会变为 $0$，就相当于一步一步的 break，而且代码行数更少。

最后放出 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,n2,m2,maxx=INT_MIN;//定义变量，INT_MIN等价于-2147483647 
bool a[60][60],b[60][60];//定义a数组与b数组 
int main(){
    ios::sync_with_stdio(0);//输入输出加速 
    cin.tie(0),cout.tie(0);//输入输出加速 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>n2>>m2;
	for(int i=1;i<=n2;i++)
		for(int j=1;j<=m2;j++)
			cin>>b[i][j];
//读入数据↑ 
	for(int i=-n;i<=n;i++){//遍历x轴移动方向
		for(int j=-m;j<=m;j++){//遍历y轴移动方向
			int ans=0;
			bool tf=1;
			for(int k=1;k<=n2;k++){//遍历b数组的行 
				for(int x=1;x<=m2;x++){//遍历b数组的列 
				    int blx=i+k,bly=j+x;//x,y轴上的动量 
					if(blx>0&&bly>0&&blx<=n&&bly<=m) 
						if(a[blx][bly]==b[k][x]) ans++;
						else tf=0;
				}
			}
			maxx=max(ans*tf,maxx);
		}
	}
	cout<<maxx;
	return 0;
}
```

---

## 作者：Red0rangE (赞：2)

## 题意理解

给出两张图，每张图的第一行两个数表示行列数量，两张图之间空一行。

两张图可以任意平移，求平移后完全重合的最多格点数。

## 思路阐述

直接暴力寻找，先固定一张图，再将另一张的四个角对上来，按照对上来这张图的方向遍历每一个点。

如图：蓝色点是基础点，黑色是基础图，红色是另一张图，绿色是遍历方向。

左上角

![](https://cdn.luogu.com.cn/upload/image_hosting/4lzp7yq8.png)

右下角

![](https://cdn.luogu.com.cn/upload/image_hosting/924txcvl.png)

左下角

![](https://cdn.luogu.com.cn/upload/image_hosting/5a1ii70j.png)

右上角

![](https://cdn.luogu.com.cn/upload/image_hosting/3gvywklr.png)

具体方法：遍历第一张图的每一个点，再以这个点为基础，将第二张图的左上角、左下角、右上角、右下角分别对应上去搜索。当然还要以第二张图为基础用同样的方式再遍历一次。

优化：因为两张图必须完全重合才在答案考虑范围内，所以只要有一格不对应即可直接退出这种情况。

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

int a,b;//第一张图的行列
int c,d;//第二张
bool mp1[55][55];//图一
bool mp2[55][55];//图二
int x;//辅助输入
int ans,cnt;//计数
bool f;//标记是否在重合范围内各个格子都相同
string s;//吃掉中间的空行

signed main(){
    
    scanf("%d%d",&a,&b);
    for (int i=1;i<=a;i++)
        for (int j=1;j<=b;j++){
            scanf("%d",&x);
            if (x) mp1[i][j]=1;
        }
    getline(cin,s);//吃掉中间的空行
    scanf("%d%d",&c,&d);
    for (int i=1;i<=c;i++)
        for (int j=1;j<=d;j++){
            scanf("%d",&x);
            if (x) mp2[i][j]=1;
        }
    for (int i=1;i<=a;i++)
        for (int j=1;j<=b;j++){//遍历图一
            cnt=0;
            f=1;//初始化变量
            for (int k=1;k<=c;k++){
                if (i+k>a) break;//注意遍历图二时不要超图一范围
                for (int l=1;l<=d;l++){//对应左上角
                    if (j+l>b) break;
                    if (mp1[i+k][j+l]==mp2[k][l]){
                        cnt++;//相同
                    }
                    else{
                        f=0;//不同，标记
                        break;//退出
                    }
                }
                if (!f) break;//有不同的，退出
            }
            if (f) ans=max(ans,cnt);//没有问题，取最大值

            cnt=0;
            f=1;
            for (int k=c;k>=1;k--){
                if (i-(c-k)<1) break;
                for (int l=d;l>=1;l--){//右下角
                    if (j-(d-l)<1) break;
                    if (mp1[i-(c-k)][j-(d-l)]==mp2[k][l]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);

            cnt=0;
            f=1;
            for (int k=c;k>=1;k--){
                if (i-(c-k)<1) break;
                for (int l=1;l<=d;l++){//右上角
                    if (j+l>b) break;
                    if (mp1[i-(c-k)][j+l]==mp2[k][l]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);

            cnt=0;
            f=1;
            for (int k=1;k<=c;k++){
                if (i+k>a) break;
                for (int l=d;l>=1;l--){//左下角
                    if (j-(d-l)<1) break;
                    if (mp1[i+k][j-(d-l)]==mp2[k][l]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);
        }
    
    for (int i=1;i<=c;i++)
        for (int j=1;j<=d;j++){//以第二张图为基础的遍历
            cnt=0;
            f=1;
            for (int k=1;k<=a;k++){
                if (i+k>c) break;
                for (int l=1;l<=b;l++){
                    if (j+l>d) break;
                    if (mp1[k][l]==mp2[k+i][l+j]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);

            cnt=0;
            f=1;
            for (int k=a;k>=1;k--){
                if (i-(a-k)<1) break;
                for (int l=b;l>=1;l--){
                    if (j-(b-l)<1) break;
                    if (mp1[k][l]==mp2[i-(a-k)][j-(b-l)]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);

            cnt=0;
            f=1;
            for (int k=1;k<=a;k--){
                if (i+k>c) break;
                for (int l=b;l>=1;l--){
                    if (j-(b-l)<1) break;
                    if (mp1[k][l]==mp2[i+k][j-(b-l)]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);

            cnt=0;
            f=1;
            for (int k=a;k>=1;k--){
                if (i-(a-k)<1) break;
                for (int l=1;l<=b;l--){
                    if (j+l>d) break;
                    if (mp1[k][l]==mp2[i-(a-k)][j+l]){
                        cnt++;
                    }
                    else{
                        f=0;
                        break;
                    }
                }
                if (!f) break;
            }
            if (f) ans=max(ans,cnt);
        }
    printf("%d",ans);//输出
    return 0;
    
}
```

希望可以帮到各位大佬。

---

## 作者：__zfy__ (赞：0)

## 思路
看到题，首先想到暴力枚举，接着看数据范围，证明方法可行。

对于 $100\%$ 的数据，满足 $1\leq n,m\leq 50$。

小于等于 $50$，方法可行。针对两张图片的重合，可以分为以下两点：
1. 左上的点和另一张图片的每一个点，枚举出这些情况。
2. 与第 $1$ 相反，第二张图片的右下的点，和第一张图片的每一个点。

以上两种方法可以直接把所有的点全部枚举一遍。
## 代码
来自[这位大佬](https://www.luogu.com.cn/user/417807)的代码。
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=55;
int i,j,ii,jj,n,m,nn,mm,a[N][N],b[N][N],ans;
void lu_rd(int n,int m,int nn,int mm,int a[N][N],int b[N][N])
{
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			int flag=0,sum=0;
			for(ii=i;ii<=min(n,i-1+nn);ii++)
			{
				for(jj=j;jj<=min(m,j-1+mm);jj++)
				{
					if(a[ii][jj]!=b[ii-i+1][jj-j+1])
					{
						flag=1;
						break;
					}
					else sum++;
				}
			}
			if(flag==0)ans=max(ans,sum);
		}
	}
}
void ld_ru(int n,int m,int nn,int mm,int a[N][N],int b[N][N])
{
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			int flag=0,sum=0;
			for(ii=i;ii<=min(n,i-1+nn);ii++)
			{
				for(jj=max(1,j-mm+1);jj<=j;jj++)
				{
					if(a[ii][jj]!=b[ii-i+1][mm-j+jj])
					{
						flag=1;
						break;
					}
					else sum++;
				}
			}
			if(flag==0)ans=max(ans,sum);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)cin>>a[i][j];
	}
	cin>>nn>>mm;
	for(i=1;i<=nn;i++)
	{
		for(j=1;j<=mm;j++)cin>>b[i][j];
	}
	lu_rd(n,m,nn,mm,a,b);
	lu_rd(nn,mm,n,m,b,a);
	ld_ru(n,m,nn,mm,a,b);
	ld_ru(nn,mm,n,m,b,a);
	cout<<ans;
	return 0;
}
```


---


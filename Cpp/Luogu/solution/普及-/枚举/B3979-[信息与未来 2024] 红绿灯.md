# [信息与未来 2024] 红绿灯

## 题目描述

七段数码管是一种用来显示数字的电子元件，由七个可以发光的小段组成，这些小段排列成一个数字 $8$ 的形状。通过点亮不同的段,数码管可以显示出从 $0$ 到 $9$ 的数字。每个小段都有一个名字，从 $\tt A$ 到 $\tt G$，按下图方式排列和命名：

![](https://cdn.luogu.com.cn/upload/image_hosting/vmi6e5km.png)

数码管通过点亮不同的段显示不同的数字。例如：

- 数字 $0$ 需要点亮 $\tt{A,B,C,D,E,F}$ 段。

- 数字 $1$ 需要点亮 $\tt{B,C}$ 段。

- 数字 $2$ 需要点亮 $\tt{A,B,D,E,G}$ 段。

Dr. X 发现，红绿灯上的数码管经常发生故障，故障分为两类：**常亮**和**不亮**：

- 如果数码管的某段发生了**常亮**故障，这一段都会始终保持点亮的状态。

- 如果数码管的某段发生了**不亮**故障，这一段都会始终保持不亮的状态。

今天，Dr. X 感觉红绿灯的一个数字显示异常,因此记录了数码管显示数字的日志。Dr. X 希望
你根据日志推测数码管的每一段分别可能发生了怎样的故障?

## 说明/提示

对于 $100\%$ 的数据，满足 $0 \leq n \leq 100$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
3
1BCD
7BCD
7DCB```

### 输出

```
x--X---```

## 样例 #2

### 输入

```
3
0
1
8G```

### 输出

```
xxxxxx-```

# 题解

## 作者：DFs_YYDS (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/B3979)
# 题目大意
给你红绿灯在显示 $n$ 次数字时，亮了哪些数码管，问你这些数码管有没有常亮（即无论什么数字都会亮）或不亮（即无论什么数字都不亮）。
# 方法一（不推荐）
## 具体思路
按照题意模拟。

$n$ 条日志，对于每条日志，首先处理常亮的情况。如果显示这个数字不需要显示该数码管，但是数码管亮了，就说明它是常亮的。然后再处理不亮的情况，如果显示这个数字需要显示该数码管，但是数码管没亮，就说明它是不亮的，将每个数码管的情况用一个 $ans$ 数组存起来，最后输出即可。
## 完整代码
```cpp
#include<bits/stdc++.h>//万能头。 
using namespace std;
char ans[10];//数码管的状态，由于题目中说常亮用大写X，不亮用小写x，没发现故障用-，所以用字符数组来表示。 
string book[10]={"ABCDEF ","BC ","ABGED ","ABGCD ","FGBC ","AFGCD ","AFDECG ","ABC ","ABCDEFG ","ABCDFG "};//book[i]表示显示第i个数需要显示的数码管编号。 
int main(){//主函数。 
	int n;//n次记录。 
	cin>>n;//输入n。 
	for(int i=0;i<7;i++)ans[i]='-';//刚开始将7个数码管的状态初始化为-，没发现任何故障。 
	for(int i=0;i<n;i++){//有n条日志，循环n次。 
		string s;//由于日志是由数字和字母组成的，中间又没有空格，所以用字符串存储比较方便。 
		cin>>s;//输入字符串s。 
		int x=s[0]-'0'/*本次记录的数字*/,len=s.size()/*字符串的长度*/;
		//处理常亮的情况。 
		for(int i=1;i<len;i++){//循环这次记录的字符串，注意从1开始，因为前面还有一位是数字。 
			int flag=1;//是否损坏。
			for(int j=0;book[x][j]!=' ';j++){//由于显示每个数字需要的数码管不一样，所以统一最后有一个空格。 
				if(book[x][j]==s[i]){//如果这个数码管本来就需要亮。 
					flag=0;//没有损坏。 
					break;//直接跳出循环，减少时间。 
				}
			}
			if(flag)/*如果这个数码管不需要亮，但它亮了*/ans[s[i]-'A']='X';//这个数码管的状态就是常亮。 
		}
		//处理不亮的情况。 
		for(int i=0;book[x][i]!=' ';i++){//循环显示x需要的数码管，遇到空格结束。 
			int flag=1;//是否损坏。 
			for(int j=1;j<len;j++){//循环日志中记录的亮的数码管，注意从1开始。 
				if(book[x][i]==s[j]){//如果这个数码管在记录中确实亮了。 
					flag=0;//没有损坏。 
					break;//跳出循环。 
				}
			}
			if(flag)/*如果这个数码管需要亮，但它没亮*/ans[book[x][i]-'A']='x';//这个数码管的状态就是不亮。 
		}
	}
	for(int i=0;i<7;i++)cout<<ans[i];//输出ans数组。 
	return 0;//好习惯。 
}
```
但是代码未免有些太长了，怎么缩短呢？
# 方法二（推荐）
## 具体思路
方法一代码长的原因在于，用了两个循环双重循环分别处理常亮和不亮的情况，如果我们将常亮和不亮在同一个循环中一起处理，代码就会缩短很多。

参考方法一，使用数组把显示每个数字需要亮的数码管存起来。但是跟方法一不一样的是，我们用的是 `int` 的二维数组（`bool` 也行）来存。$book_{i,j}$ 表示在显示数字 $i$ 时第 $j$ 个数码管是否需要亮，如果是 $1$ 表示需要亮，如果是 $0$ 表示不需要亮。

同样，在 $n$ 个日志中。先建一个数组 $a$，$a_i$ 表示第 $i$ 个数码管是否亮了。然后循环每个数码管，如果 $a_j$ 为 $1$ 但 $book_{x,j}$ 为 $0$，也就是说第 $j$ 个数码管不应该亮但是亮了，这个数码管就是常亮的；如果$book_{x,j}$ 为 $1$ 但 $a_j$ 为 $0$，也就是说第 $j$ 个数码管应该亮但是没亮，这个数码管就是不亮的，将状态存入答案数组 $ans$ 中。

这样，我们就将两个循环缩减为一个循环，大大的减少了代码量。
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char ans[10];//答案数组。 
int book[10][7]={1,1,1,1,1,1,0,
				0,1,1,0,0,0,0,
				1,1,0,1,1,0,1,
				1,1,1,1,0,0,1,
				0,1,1,0,0,1,1,
				1,0,1,1,0,1,1,
				1,0,1,1,1,1,1,
				1,1,1,0,0,0,0,
				1,1,1,1,1,1,1,
				1,1,1,1,0,1,1,};
int main(){
	int n;
	cin>>n;
	for(int i=0;i<7;i++)ans[i]='-';//初始化。 
	for(int i=0;i<n;i++){
		string s;
		cin>>s;
		int x=s[0]-'0',len=s.size(); 
		int a[10];//实际上a数组开到7就行了，这里开10保险一点。 
		for(int j=0;j<7;j++)a[j]=0;//在循环内定义数组要先全部初始化为0。 
		for(int j=1;j<len;j++)a[s[j]-'A']=1;//这个数码管亮了。 
		for(int j=0;j<7;j++){
			if(a[j]==1&&book[x][j]==0)ans[j]='X';//如果这个数码管亮了但是实际上不应该亮，这个数码管就是常亮的。 
			if(a[j]==0&&book[x][j]==1)ans[j]='x';//如果这个数码管没亮但是实际上应该亮，这个数码管就是不亮的。 
		}
	}
	for(int i=0;i<7;i++)cout<<ans[i];//输出答案数组。 
	return 0;//华丽结束。 
}
```
如果你还觉得长是因为 $book$ 数组的原因，我们将 $book$ 数组放到一行，就不觉得长了。
## 最终完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char ans[10];//答案数组。 
int book[10][7]={1,1,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,};
int main(){
	int n;
	cin>>n;
	for(int i=0;i<7;i++)ans[i]='-';//初始化。 
	for(int i=0;i<n;i++){
		string s;
		cin>>s;
		int x=s[0]-'0',len=s.size(); 
		int a[10];//实际上a数组开到7就行了，这里开10保险一点。 
		for(int j=0;j<7;j++)a[j]=0;//在循环内定义数组要先全部初始化为0。 
		for(int j=1;j<len;j++)a[s[j]-'A']=1;//这个数码管亮了。 
		for(int j=0;j<7;j++){
			if(a[j]==1&&book[x][j]==0)ans[j]='X';//如果这个数码管亮了但是实际上不应该亮，这个数码管就是常亮的。 
			if(a[j]==0&&book[x][j]==1)ans[j]='x';//如果这个数码管没亮但是实际上应该亮，这个数码管就是不亮的。 
		}
	}
	for(int i=0;i<7;i++)cout<<ans[i];//输出答案数组。 
	return 0;//完结撒花！ 
}
```

---

## 作者：King_and_Grey (赞：4)

# [B3979 [信息与未来 2024] 红绿灯](https://www.luogu.com.cn/problem/B3979)

这一题前天参加比赛时做过，现在看没人写题解，蒟蒻就发一篇。


------------
**先附上七段数码管点亮每个数字时需要显示的不同的段的编号：**

数字 $ 0 $：A,B,C,D,E,F。

数字 $ 1 $：B,C。

数字 $ 2 $：A,B,D,E,G。

数字 $ 3 $：A,B,C,D,G。

数字 $ 4 $：B,C,F,G。

数字 $ 5 $：A,C,D,F,G。

数字 $ 6 $：A,C,D,E,F,G。

数字 $ 7 $：A,B,C。

数字 $ 8 $：A,B,C,D,E,F,G。

数字 $ 9 $：A,B,C,D,F,G。

## 思路：
我们可以用把字母转换成 ASCII 码来储存每段灯亮的次数，并把每段灯应该亮的次数记下来。最后判断如果实际亮的次数比应该亮的次数少，那就说明这段灯**不亮**，如果实际亮的次数比应该亮的次数多，那就说明这段灯**常亮**，否则说明这段灯正常。

**$ A $ 到 $ G $ 的 ASCII 码值是 $ 65 $ 到 $ 71 $。**


#### 最后奉上AC代码（内附注释）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,ans;
int shiji[72],yinggai[72];//注意，要多开1位（因为开到71只能存储0 ~ 71,G没地方存）。
string s;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);//关闭同步，加快速度。
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> s;
		//处理应该亮的灯的段数。
		if(s[0] == '0'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[69]++;
			yinggai[70]++;
		}
		if(s[0] == '1'){
			yinggai[66]++;
			yinggai[67]++;
		}
		if(s[0] == '2'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[68]++;
			yinggai[69]++;
			yinggai[71]++;
		}
		if(s[0] == '3'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[71]++;
		}
		if(s[0] == '4'){
			yinggai[66]++;
			yinggai[67]++;
			yinggai[70]++;
			yinggai[71]++;
		}
		if(s[0] == '5'){
			yinggai[65]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[70]++;
			yinggai[71]++;
		}
		if(s[0] == '6'){
			yinggai[65]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[69]++;
			yinggai[70]++;
			yinggai[71]++;
		}
		if(s[0] == '7'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[67]++;
		}
		if(s[0] == '8'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[69]++;
			yinggai[70]++;
			yinggai[71]++;
		}
		if(s[0] == '9'){
			yinggai[65]++;
			yinggai[66]++;
			yinggai[67]++;
			yinggai[68]++;
			yinggai[70]++;
			yinggai[71]++;
		}
		//实际亮的灯的段数。
		for(int j = 1;j < s.size();j++){
			shiji[(int)s[j]]++;
		}
	}
	//输出。
	for(int i = 65;i <= 71;i++){
		if(shiji[i] > yinggai[i]){
			cout << "X";
		}else if(shiji[i] < yinggai[i]){
			cout << "x";
		}else{
			cout << "-";
		}
	}
	cout << endl;
	return 0;//AC!!!
}
```
感谢观看！！！

---

## 作者：沉石鱼惊旋 (赞：3)

如果一个数应该亮的位置没亮，说明一定不亮。

如果一个数不该亮的位置亮了，说明一定常亮。

我们根据生活常识把每种灯应该点亮的位置存下来，对于这两种情况判断即可。

表格如下。请自行在程序内根据这个表格判断。

```
0: A B C D E F 
1: B C 
2: A B D E G 
3: A B C D G 
4: B C F G 
5: A C D F G 
6: A C D E F G 
7: A B C 
8: A B C D E F G 
9: A B C D F G 
```

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> a[10];
int n;
string ans = "-------";
int main()
{
    a[0] = {0, 1, 2, 3, 4, 5};
    a[1] = {1, 2};
    a[2] = {0, 1, 3, 4, 6};
    a[3] = {0, 1, 2, 3, 6};
    a[4] = {1, 2, 5, 6};
    a[5] = {0, 2, 3, 5, 6};
    a[6] = {0, 2, 3, 4, 5, 6};
    a[7] = {0, 1, 2};
    a[8] = {0, 1, 2, 3, 4, 5, 6};
    a[9] = {0, 1, 2, 3, 5, 6};
    cin >> n;
    while (n--)
    {
        string s;
        cin >> s;
        int k = s[0] ^ '0';
        for (int i = 1; i < s.size(); i++)
        {
            bool ok = 0;
            for (int j : a[k])
                if (j == s[i] - 'A')
                    ok = 1;
            if (!ok)
                ans[s[i] - 'A'] = 'X';
        }
        for (int j : a[k])
        {
            bool ok = 0;
            for (int i = 1; i < s.size(); i++)
                if (j == s[i] - 'A')
                    ok = 1;
            if (!ok)
                ans[j] = 'x';
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：chenlongli (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3979)
### 思路
我们可以直接按照题意进行模拟。

初始的时候，我们先将所有灯的状态设置为正常，随后每输入一个指令，我们就可以检查应该要出现的灯是否出现过，如果这个灯应该要出现，但是它没有亮，那么这个灯就是发生了不亮故障，如果说这个灯不应该亮，结果这个灯亮了，那么这个灯就发生了常亮故障。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    char ans[7]={'-','-','-','-','-','-','-'};
    for (int i=0;i<n;i++)
    {
        string a;
        cin>>a;
        int d=a.length();
        if (a[0]=='0')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','1','1','1','1','0'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='1')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'0','1','1','0','0','0','0'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='2')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','0','1','1','0','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='3')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','1','1','0','0','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='4')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'0','1','1','0','0','1','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='5')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','0','1','1','0','1','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='6')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','0','1','1','1','1','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='7')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','1','0','0','0','0'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='8')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','1','1','1','1','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
        if (a[0]=='9')
        {
            char c[7]={'0','0','0','0','0','0','0'};
            char y[7]={'1','1','1','1','0','1','1'};
            for (int j=1;j<d;j++)
            {
                c[(int)a[j]-65]='1';
            }
            for (int j=0;j<7;j++)
            {
                if (c[j]=='1')
                {
                    if (y[j]=='0')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='X';
                        }
                    }
                }
                else
                {
                    if (y[j]=='1')
                    {
                        if (ans[j]=='-')
                        {
                            ans[j]='x';
                        }
                    }
                }
            }
        }
    }
    for (int i=0;i<7;i++)
    {
        cout<<ans[i];
    }
    cout<<endl;
}
```

---

## 作者：遥遥领先 (赞：0)

# 题解：B3979 [信息与未来 2024] 红绿灯

## 思路

一道简单的模拟。

先把 $0$ 到 $9$ 的数码管正常显示情况打表出来，再把输入数码管的显示情况打表出来，最后做判断，整理答案即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

string s[10];
string ans;

void solve()
{
	s[0] = "1111110";
	s[1] = "0110000";
	s[2] = "1101101";
	s[3] = "1111001";
	s[4] = "0110011";
	s[5] = "1011011";
	s[6] = "1011111";
	s[7] = "1110000";
	s[8] = "1111111";
	s[9] = "1111011";
	ans = "-------";
	int n;
	cin >> n;
	while (n--)
	{
		string aa;
		cin >> aa;
		string a = aa.substr(1);
		int num = aa[0]-'0';
		string now = "";
		sort(a.begin(),a.end());
		for (int i = 0,j = 0;j < 7;j++)
		{
			char t = char(j+'A');
			if (a[i] == t) now += '1',i++;
			else now += '0';
		}
		for (int i = 0;i < 7;i++)
		{
			if (now[i] > s[num][i]) ans[i] = 'X';
			if (now[i] < s[num][i]) ans[i] = 'x';
		}
	}
	cout << ans;
}

signed main()
{
	solve();
	return 0;
}

```

---


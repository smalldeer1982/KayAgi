# [中山市赛 2024] 象战

## 题目描述

国际象棋的棋盘可以表示为一个 $8$ 行 $8$ 列的格子图，其中每个格子都可以放一枚棋子。我们将第 $1$ 行第 $2$ 列的格子用  $(1, 2)$ 来表示，以此类推。

为了帮助妹妹认识国际象棋中的“象”这种棋子，Jimmy 可谓是煞费苦心——他首先教会妹妹：“‘象’是一种能够飞檐走壁的棋子，它不仅可以攻击自己所在的位置，还可以攻击它所在的两条斜线上的所有格子。”说着，Jimmy 将一只“象”随意地摆放在棋盘上，并且顺便用水彩笔将“象”能攻击到的所有格子涂成了红色。

![](https://cdn.luogu.com.cn/upload/image_hosting/tm3c2ym0.png)

就在此时，Chen 老师一个电话把 Jimmy 叫去收作业了。等到他回来后，他发现妹妹已经将棋盘推开了，棋盘上的“象”也不知所踪。Jimmy 只记得他没有把“象”放在棋盘的四个角落上（即 $(1, 1),(1, 8),(8, 1),(8, 8)$ 这四个格子）。现在他想知道，原来的“象”摆在了哪个格子上。

## 样例 #1

### 输入

```
.....#..
#...#...
.#.#....
..#.....
.#.#....
#...#...
.....#..
......#.```

### 输出

```
4 3```

# 题解

## 作者：AW_BCH (赞：7)

## 题解：B4183 [中山市赛 2024] 象战

[题目传送门](https://www.luogu.com.cn/problem/B4183)

[更好的阅读体验](https://www.luogu.com.cn/article/h28xwboo)

### 题目分析

一道纯模拟，可以培养全面思考问题的能力，适合新手做。

观察 "象" 所在的位置，发现如果令 "象" 的坐标为 $(x,y)$，那么 $(x+1,y+1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x-1,y-1)$ 都会是 "象" 可以攻击到的。

所以，如果 $(x,y)$ 是 ```#```，且 $(x+1,y+1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x-1,y-1)$ 也都是 ```#```，那么这个点就是 "象" 所在的位置。

### 代码实现

- 我们用 ```mp``` 字符数组来表示这个棋盘。

- 我们用 ```pd``` 函数来表示这个点是否符合成为 "象" 的标准。

**代码：**

```cpp
//洛谷 B4183 [中山市赛 2024] 象战
#include<bits/stdc++.h>
using namespace std;
//#define int long long//
#define endl '\n'
#define emdl '\n'
typedef long long ll;
const int MAXN=8+5;
int n=8;
char mp[MAXN][MAXN]; 
bool pd(int x,int y){
	if(mp[x][y]=='#'){
		if(mp[x+1][y+1]=='#'){
			if(mp[x+1][y-1]=='#'){
				if(mp[x-1][y+1]=='#'){
					if(mp[x-1][y-1]=='#'){
						return 1;
					}
					else return 0;
				}
				else return 0;
			}
			else return 0;
		}
		else return 0;
	}
	else return 0;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(pd(i,j)){
				cout<<i<<" "<<j<<endl;
				return 0;
			}
		}
	}
	return 0;
}
```
如果你是这么写的话，恭喜你，[喜提 70 分](https://www.luogu.com.cn/record/205454958)。

### 为什么会这样呢？

仔细分析一下题意，我们会发现我们漏了一种情况没讨论。

什么情况呢？没错！是 "象" 所在的点在棋盘边缘的情况。

想到了情况，我们该怎么实现呢？

我想到了两种解决方案：

1. 一种比较笨的方法。具体是枚举 "象" 在边缘的所有可能，并特殊处理。

2. 比较聪明的办法。我们发现，无论 "象" 在边缘的哪里，实际上只用判断两种在棋盘内部的可能，另外两种可能会在棋盘外部，所以不妨初始化每个棋盘外部的点为 ```#```，然后特判一下棋盘的四个顶点即可。

容易证明，上述方法都是对的。

### 真-代码实现

这里采用方案 2。

和上面代码不同的地方已近用注释展示了。

变量、数组、函数所表示的含义皆与上面的代码相同。

**代码：**

```cpp
//洛谷 B4183 [中山市赛 2024] 象战
#include<bits/stdc++.h>
using namespace std;
//#define int long long//
#define endl '\n'
#define emdl '\n'
typedef long long ll;
const int MAXN=8+5;
int n=8;
char mp[MAXN][MAXN];
bool pd(int x,int y){
	if(mp[x][y]=='#'){
		if(mp[x+1][y+1]=='#'){
			if(mp[x+1][y-1]=='#'){
				if(mp[x-1][y+1]=='#'){
					if(mp[x-1][y-1]=='#'){
						return 1;
					}
					else return 0;
				}
				else return 0;
			}
			else return 0;
		}
		else return 0;
	}
	else return 0;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	//32 至 36 行有增改 
	for(int i=0;i<=n+1;i++){
		for(int j=0;j<=n+1;j++){
			mp[i][j]='#';
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			//45 至 48 行有增改 
			if(i==1&&j==1) continue;
			if(i==1&&j==n) continue;
			if(i==n&&j==1) continue;
			if(i==n&&j==n) continue;
			//这里一定要 continue
			//题目保证了 "象" 不会在这里，无需担心正确性
			if(pd(i,j)){
				cout<<i<<" "<<j<<endl;
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：LINYUHENG2 (赞：2)

[题目传送门。](https://www.luogu.com.cn/problem/B4183)

## 题意
国际象棋中，已知象的攻击范围，求象的位置。
## 思路
只需判断一个点的左上点、左下点、右上点、右下点是否属于攻击范围，若是，则输出该点的坐标，结束程序。

要注意的是，因为象不在 $(1,1),(1,8),(8,1),(8,8)$ 四个位置，所以要进行特判，方法如下：
1. 若 $i+j \ne 2$，则位置不在 $(1,1)$。
2. 若 $i+j \ne 16$，则位置不在 $(8,8)$。
3. 若 $\left | i-j \right | \ne 7$，则位置不在 $(1,8)$ 或 $(8,1)$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char c[10][10];

int main(){
    for(int i=1;i<=8;i++){
        for(int j=1;j<=8;j++){
            cin>>c[i][j];
        }
    }
    for(int i=1;i<=8;i++){
        for(int j=1;j<=8;j++){
            if(c[i+1][j+1]!='.'&&c[i+1][j-1]!='.'&&c[i-1][j+1]!='.'&&c[i-1][j-1]!='.'&&c[i][j]=='#'&&i+j!=2&&i+j!=16&&abs(i-j)!=7){
                cout<<i<<' '<<j;
                return 0;
            }
        }
    }
    return 0;
}
```

---

## 作者：TJB_LHY (赞：1)

# 思路

一道~~简单的~~模拟题，只要多注意细节即可。由于数据较水，只有 $8\times8$ ，朴素算法即可。在题目中，“Jimmy 只记得他没有把“象”放在棋盘的四个角落上”，因为若“象”在对角线上，四个角落能成立，所以这四处需要特判！那么……完事？

# 代码


```cpp
#include<bits/stdc++.h>

#define ll long long
using namespace std;
char s[10][10];
bool check(int x, int y) {//判断函数
    int i, j;
    i = x, j = y;
    while (!(i > 8 || j > 8 || i < 1 || j < 1)) {
        if (s[i][j] != '#') return 0;
        i--;
        j--;
    }
    i = x, j = y;
    while (!(i > 8 || j > 8 || i < 1 || j < 1)) {
        if (s[i][j] != '#') return 0;
        i++;
        j--;
    }
    i = x, j = y;
    while (!(i > 8 || j > 8 || i < 1 || j < 1)) {
        if (s[i][j] != '#') return 0;
        i--;
        j++;
    }
    i = x, j = y;
    while (!(i > 8 || j > 8 || i < 1 || j < 1)) {
        if (s[i][j] != '#') return 0;
        i++;
        j++;
    }
    return 1;
}
int main() {
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            cin >> s[i][j];
        }
    }//读入
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if ((i==1 || i==8) && (j==1 || j==8)) continue;//特判
            if (check(i, j)) {
                cout << i << ' ' << j;//输出
                return 0;
            }
        }
    }
    return 0;
}
```
完结撒花~

---

## 作者：lty2023 (赞：1)

枚举棋盘上除了角以外的每个格子，依次向左上、右上、左下、右下延伸。    
如果发现有没涂色的格子，就跳过这个格子，枚举下一个格子。     
如果一直没有跳过，就输出答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[8][8];
int main(){
	for(int i=0;i<8;i++){
		for(int j=0;j<8;j++){
			char c;
			cin>>c;
			if(c=='.'){
				a[i][j]=0;
			}
			else{
				a[i][j]=1;
			}
		}
	}
	for(int i=0;i<8;i++){
		for(int j=0;j<8;j++){
			if((i==0&&j==0)||(i==7&&j==7)||(i==0&&j==7)||i==7&&j==0){
				continue;
			}
			if(a[i][j]==0){
				continue;
			}
			bool b=0;
			for(int i1=i-1,j1=j-1;i1>=0&&j1>=0;i1--,j1--){
				if(a[i1][j1]==0){
					b=1;
					break;
				}
			}
			if(b){
				continue;
			}
			
			for(int i1=i-1,j1=j+1;i1>=0&&j1<8;i1--,j1++){
				if(a[i1][j1]==0){
					b=1;
					break;
				}
			}
			if(b){
				continue;
			}
			
			for(int i1=i+1,j1=j-1;i1<8&&j1>=0;i1++,j1--){
				if(a[i1][j1]==0){
					b=1;
					break;
				}
			}
			if(b){
				continue;
			}
			
			for(int i1=i+1,j1=j+1;i1<8&&j1<8;i1++,j1++){
				if(a[i1][j1]==0){
					b=1;
					break;
				}
			}
			if(b){
				continue;
			}
			cout<<i+1<<" "<<j+1;
			return 0;
		}
	}
}
```

---

## 作者：yedalong (赞：1)

## Solution
最简单的就是“象”不在棋盘的边缘。只需判断“象”的四个斜方向是否都是 `#` 即可。  

对于在棋盘边缘，分四类讨论。每一类的判断都很相似，只需判断四个斜方向中的两个斜方向即可，用上复制粘贴很快就能完成。   

只需要枚举每一个点并完成上面所说的判断即可。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
char mp[9][9];
bool check(int i,int j){
	if(mp[i][j]=='#'&&mp[i+1][j+1]=='#'&&mp[i-1][j-1]=='#'&&mp[i+1][j-1]=='#'&&mp[i-1][j+1]=='#') return 1;
	if(mp[i][j]=='#'&&mp[i+1][j+1]=='#'&&mp[i-1][j+1]=='#') return 1;
	if(mp[i][j]=='#'&&mp[i+1][j+1]=='#'&&mp[i+1][j-1]=='#') return 1;
	if(mp[i][j]=='#'&&mp[i-1][j-1]=='#'&&mp[i-1][j+1]=='#') return 1;
	if(mp[i][j]=='#'&&mp[i-1][j-1]=='#'&&mp[i+1][j-1]=='#') return 1;
	return 0;
}
int main(){
	for(int i = 1;i<=8;i++){
		for(int j = 1;j<=8;j++){
			cin>>mp[i][j];
		}
	}
	for(int i = 1;i<=8;i++){
		for(int j = 1;j<=8;j++){
			if(check(i,j)){
				cout<<i<<' '<<j;
			}
	}	}
	return 0;
}
```

---

## 作者：TheTrash (赞：0)

### 思路

由于棋盘为 $8$ 行 $8$ 列，所以可以枚举每个格子，判断这个格子能不能被攻击，同时它周围的八个格子中有没有四个格子能被攻击到。当这个格子在棋盘边缘时只需判断这个格子能不能被攻击同时它周围的五个格子中有没有两个能被攻击到，因为题目中说“象”不在棋盘的四个角落上。

### 代码

```cpp
#include<iostream>
using namespace std;
char c[10][10];
int main(){
	for(int i=0;i<8;i++)
		for(int j=0;j<8;j++)
			cin>>c[i][j];
	for(int i=0;i<8;i++){
		for(int j=0;j<8;j++){
			if(i==0){
				if(c[i][j]=='#'&&c[i+1][j-1]=='#'&&c[i+1][j+1]=='#') cout<<i+1<<' '<<j+1,exit(0);//下标从0开始，所以要输出i+1和j+1
			}
			else if(i==7){
				if(c[i][j]=='#'&&c[i-1][j-1]=='#'&&c[i-1][j+1]=='#') cout<<i+1<<' '<<j+1,exit(0);
			}
			else if(j==0){
				if(c[i][j]=='#'&&c[i+1][j+1]=='#'&&c[i-1][j+1]=='#') cout<<i+1<<' '<<j+1,exit(0);
			}
			else if(j==7){
				if(c[i][j]=='#'&&c[i-1][j-1]=='#'&&c[i+1][j-1]=='#') cout<<i+1<<' '<<j+1,exit(0);
			}
			else if(c[i][j]=='#'&&c[i-1][j-1]=='#'&&c[i+1][j-1]=='#'&&c[i-1][j+1]=='#'&&c[i+1][j+1]=='#') cout<<i+1<<' '<<j+1,exit(0);
		}
	}
}
```

---

## 作者：linan04007 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4183)
### 题目分析
本题要求根据国际象棋棋盘上被涂红的格子来找出“象”原先摆放的位置。已知“象”能攻击自身所在位置以及其所在的两条斜线上的所有格子，且“象”不在棋盘的四个角落（即 $(1, 1)$ 、$(1, 8)$ 、$(8, 1)$ 、$(8, 8)$ 这四个格子）。输入是一个 $8\times8$ 的棋盘，用 `#` 表示被涂红的格子，`.` 表示正常格子，需要输出“象”原先所在的行和列。

### 解题思路
我们可以通过遍历棋盘上的每个格子（排除四个角落），对于每个格子，检查它是否满足“象”的攻击规则。具体来说，就是检查该格子所在的两条斜线上的所有格子是否都被涂红。如果满足条件，那么这个格子就是“象”原先摆放的位置。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    char m[10][10];
    // 读取棋盘信息
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            cin >> m[i][j];
        }
    }
    // 遍历棋盘上的每个格子
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            // 排除四个角落的格子
            if ((i == 1 && j == 1) || (i == 1 && j == 8) || (i == 8 && j == 1) || (i == 8 && j == 8)) continue;
            // 如果当前格子是正常格子，跳过
            if (m[i][j] == '.') continue;
            bool f = true;
            // 检查左上斜线
            for (int k = 1; i - k >= 1 && j - k >= 1; k++) {
                if (m[i - k][j - k] != '#') {
                    f = false;
                    break;
                }
            }
            if (!f) continue;
            // 检查左下斜线
            for (int k = 1; i + k <= 8 && j - k >= 1; k++) {
                if (m[i + k][j - k] != '#') {
                    f = false;
                    break;
                }
            }
            if (!f) continue;
            // 检查右下斜线
            for (int k = 1; i + k <= 8 && j + k <= 8; k++) {
                if (m[i + k][j + k] != '#') {
                    f = false;
                    break;
                }
            }
            if (!f) continue;
            // 检查右上斜线
            for (int k = 1; i - k >= 1 && j + k <= 8; k++) {
                if (m[i - k][j + k] != '#') {
                    f = false;
                    break;
                }
            }
            // 如果四条斜线都满足条件，输出该格子的位置
            if (f) {
                cout << i << " " << j;
                return 0;
            }
        }
    }
    return 0;
}
```
### 注意事项
在检查斜线时，需要注意边界条件，避免数组越界。例如，在检查左上斜线时，要确保行和列的索引不小于 $1$ ；在检查右下斜线时，要确保行和列的索引不大于 $8$ 。

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4183 [中山市赛 2024] 象战 题解](https://www.luogu.com.cn/problem/B4183)
## 思路：
不难发现，“象”只能朝左上、左下、右上、右下四个方向走，所以我们只需要枚举每一个点，找到字符是井号的点，再判断四个方向上是否都是井号，若全是，则“象”就在这里。
注意四个角上需要特判一下。
## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
char c[10][10];
bool check(int i,int j){
	if(i==1){
		if(c[i+1][j-1]=='#'&&c[i+1][j+1]=='#')return 1;
		else return 0;
	}
	else if(i==8){
		if(c[i-1][j-1]=='#'&&c[i-1][j+1]=='#')return 1;
		else return 0;
	}
	else if(j==1){
		if(c[i-1][j+1]=='#'&&c[i+1][j+1]=='#')return 1;
		else return 0;
	}
	else if(j==8){
		if(c[i-1][j-1]=='#'&&c[i+1][j-1]=='#')return 1;
		else return 0;
	}
	else{
		if(c[i-1][j-1]=='#'&&c[i-1][j+1]=='#'&&c[i+1][j-1]=='#'&&c[i+1][j+1]=='#')return 1;
		else return 0;
	}
}
int main(){
	for(int i=1;i<=8;i++)
		for(int j=1;j<=8;j++)
			cin>>c[i][j];
	for(int i=1;i<=8;i++)
		for(int j=1;j<=8;j++){
			if(i==1&&j==1||i==1&&j==8||i==8&&j==1||i==8&&j==8)continue;
			if(c[i][j]=='.')continue;
			if(check(i,j)){
				cout<<i<<" "<<j;return 0;
			}
		}
}
``````

---

## 作者：DashZhanghanxu (赞：0)

# 解析
简单题。

通过观察图像，不难得出，红色格子有两种情况（即两条象的移动轨迹），一条移动轨迹是横坐标加纵坐标相等，一条移动轨迹是横坐标减纵坐标值相等，因为两条轨迹只有一个重合点，因此那个点就是象。

如何判断移动轨迹呢？观察一下，不难发现，当横纵坐标相加值固定时，相减值不固定，而横纵坐标相减值固定时，相加值不固定，因此，当一个轨迹上相加值有两个相等，那么它就是相加值固定的轨道，固定相加值就可以得出，同理，相减值也是如此。

最后枚举每个点，若有横纵坐标相加值等于固定相加值，且横纵坐标相减值等于固定相减值，该点即为象。
# CODE
```cpp
#include<bits/stdc++.h>
//AC
//by Dashzhanghanxu
using namespace std;
#define int long long
char a[9][9];
int flag1[81],flag2[81];
signed main(){
	int cha=2147483647,he=-1;
	//for(int i=1;i<=8;i++)for(int j=1;j<=8;j++)cin>>a[i][j];
	for(int i=1;i<=8;i++){
		for(int j=1;j<=8;j++){
			cin>>a[i][j];
			if(a[i][j]=='#'){
				flag1[(i+j)]++;
				flag2[i-j]++;
				if(flag1[i+j]>=2)he=i+j;
				if(flag2[i-j]>=2)cha=i-j;
			}
		}
	}
	for(int i=1;i<=8;i++){
		for(int j=1;j<=8;j++){
			if(a[i][j]=='#'&&i-j==cha&&i+j==he){
				cout<<i<<" "<<j;
				return 0;
			} 
		}
	}
	return 0;
}
```

---

## 作者：SatoruXia (赞：0)

# B4183 [中山市赛 2024] 象战
## 题目分析及实现方法
一道不算难的好题。  
本题是考察对二维数组的应用，简单来说就是个枚举加比较复杂的判断，~~但我使用了vector~~  
其实它们本质上是一样的。调用索引的代码都一样，有区别吗？所以不用vector也没事。  
## 代码思路
题目给出了一个 $8\times8$ 的棋盘以及上面象的攻击范围，要求我们给出象的位置，所以只要弄清**象的攻击方式**就好办了。然后我们从第一个位置枚举到最后一个位置，因为象能攻击它所在的格子，所以碰到`.`可以直接跳过（即该位置不可能为象）。碰到`#`时，向它的四个方向东北、东南、西北、西南枚举，如果不是`#`也跳过。一旦符合所有条件（即该位置可以为象）就输出然后结束程序。这样的细节可以提升运行速度，虽然这道题不这样也不会超时。
## 实现方式
### 象的攻击范围
![](https://cdn.luogu.com.cn/upload/image_hosting/i6k7vj0t.png)  
如题意，象的攻击方式为下列四种：
- 东北方向（行号减少，列号减少）
- 东南方向（行号减少，列号增加）
- 西北方向（行号增加，列号减少）
- 西南方向（行号增加，列号增加）

但问题也来了，要避免超出边框。这并不难解决，我们可以想到最大情况（象位于 $(5,5)$ 时）时的边界坐标，以这个坐标为最大值进行尝试。  
因此我们可以用一个`check`函数来检验该位置是否可能为象。如果四个方向均无不符合之处，它就是象的位置。
### 主函数实现
主函数核心就是枚举。用`vector<string> board(8);`模拟棋盘，读入棋盘后开始枚举。这里要注意一点就是**要跳过四个角落**，然后调用函数检验。由于肯定有解，无需考虑无解情况。  
## 代码

```cpp
#include<iostream>
#include<vector>
using namespace std;
//程序核心部分就在这里，如何确定该位置能否成为象
bool check(const vector<string>& board, int r, int c) {//与二维数组其实是一样的
    //
    int i, j;
    //检验该位置如果是象的话，是否符合条件
    //即检查四条对角线上的所有格子是否都被标记为#
    //1.东北方向（行号减少，列号减少）
    i = r - 1, j = c - 1;
    while (i >= 0 && j >= 0) {//在不超出边界时枚举（下同）
        if (board[i][j] != '#') return false;//不符合条件直接结束（下同）
        i--;
        j--;
    }
    //2.东南方向（行号减少，列号增加）
    i = r - 1, j = c + 1;
    while (i >= 0 && j < 8) {//注意是小于8
        if (board[i][j] != '#') return false;
        i--;
        j++;
    }
    //3.西北方向（行号增加，列号减少）
    i = r + 1, j = c - 1;
    while (i < 8 && j >= 0) {
        if (board[i][j] != '#') return false;
        i++;
        j--;
    }
    //4.西南方向（行号增加，列号增加）
    i = r + 1, j = c + 1;
    while (i < 8 && j < 8) {
        if (board[i][j] != '#') return false;
        i++;
        j++;
    }
    return true;//如果所有条件均符合，此位置便可为象！
}
int main(){
    vector<string> board(8);
    for (int i = 0; i < 8; i++) {
        cin >> board[i];//读取输入（8*8棋盘）
    }
    for (int r = 0; r < 8; r++) {//还是注意r和c都是小于8
        for (int c = 0; c < 8; c++) {
            //按题目规定跳过四个角落
            if ((r == 0 && c == 0) || (r == 0 && c == 7) || (r == 7 && c == 0) || (r == 7 && c == 7)) {
                continue;
            }
            if (board[r][c] == '.') continue;
            // 检查当前位置是否可能是象的位置
            if (check(board, r, c)) {
                cout << r + 1 << ' ' << c + 1;
                return 0;//题目唯一解，无需继续枚举
            }
        }
    }
    //由于肯定有解，无需考虑无解情况
    return 0;//完结！
}
```

---


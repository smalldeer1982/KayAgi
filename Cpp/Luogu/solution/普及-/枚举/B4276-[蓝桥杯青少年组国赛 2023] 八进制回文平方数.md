# [蓝桥杯青少年组国赛 2023] 八进制回文平方数

## 题目背景

- **八进制数**：指逢 $8$ 进位的一种进位计数制，以 $0$、$1$、$2$、$3$、$4$、$5$、$6$、$7$ 共八个数码表示。例如：十进制数 $8$ 等于八进制数 $10$，十进制数 $64$ 等于八进制数 $100$，以此类推。  
- **回文数**：反向排列与原来一样的数。例如，$12321$ 是回文数，$1231$ 不是回文数。  
- **平方数**：可以写成某个整数的平方的数。例如，$9 = 3^2$，$9$ 是一个平方数。  

## 题目描述

给定一个十进制正整数 $N$（$1 \leq N \leq 10^9$），请从小到大输出 $1 \sim N$ 之间（含 $1$ 和 $N$）所有满足以下要求的数：  
1. 这个数转换为八进制后是一个回文数；  
2. 这个数是一个平方数。  

**例如**：$N=20$，在 $1 \sim 20$ 之间满足要求的数有 $1$、$4$、$9$，因为有：  
- $1$ 转换为八进制为 $1$，是一个回文数；且 $1 = 1^2$，是一个平方数；  
- $4$ 转换为八进制为 $4$，是一个回文数；且 $4 = 2^2$，是一个平方数；  
- $9$ 转换为八进制为 $11$，是一个回文数；且 $9 = 3^2$，是一个平方数。  

故输出 $1\ 4\ 9$。

## 样例 #1

### 输入

```
20```

### 输出

```
1 4 9```

# 题解

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

考虑暴力，枚举 $1 \sim n$，判断每个数是否合法，复杂度 $O(n\log n)$。

考虑优化，我们可以尝试枚举所有的平方数，再判断转换为八进制后是否一个回文数，时间复杂度 $O(\sqrt n\log \sqrt n)$。

### AC_Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int n;

bool is_pali(string str)
{
    string rts = str;
    reverse(rts.begin(), rts.end());
    return rts == str;
}

string get(int x)
{
    string res;
    while (x)
        res += x % 8 + '0', x /= 8;
    return res;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n / i; ++ i )
        if (is_pali(get(i * i)))
            cout << i * i << ' ';
    
    return 0;
}
```

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4276)

考虑模拟。

暴力枚举小于 $N$ 的平方数会有 $O(N)$ 的复杂度，可以使用变量 $i$ 枚举，如果 $i^2\le N$，就是小于 $N$ 的平方数的平方根。这样可以将复杂度节省至 $O(\sqrt{N})$。

接着将 $i^2$ 进行 $8$ 进制转化，就是不断对 $8$ 反着取余。例如 $9$，$9\bmod 8=1$，然后让 $9{\div} 8$，重复，反着取余数得到 $11_{(8)}$。

随后遍历如果转化成 $8$ 进制的长度为 $l$ 的数字对于每个 $i(0\le i<l)$，都有 $i$ 位和 $l-i-1$ 相等就是回文数。

代码：

复杂度：$O(\sqrt N \log_{10} N)$。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e9+1;
int n,ans=0;
bool is_huiwen(int x){
	string x8="";
	while(x){
		char t=(x%8+'0');
		x8=t+x8;
		x/=8;
	}
	int l=x8.length();
	for(int i=0;i<l;i++){
		if(x8[i]!=x8[l-i-1]){
			return false;
		}
	}
	return true;
}
signed main(){
	cin>>n;
	for(int i=1;i*i<=n;i++){
		if(is_huiwen(i*i)){
			cout<<i*i<<" ";
		}
	}
	return 0;
}
/*

*/
```

---

## 作者：Yi_chen123 (赞：1)

## 思路

非常简单的模拟和枚举题！\
首先，我们需要思考如何进行进制转换。一般来说，将 $10$ 进制数 $X$ 转为 $M$ 进制，我们使用的是短除法，具体步骤如下：

- 将 $X \bmod M$ 的值记录下来。
- $X \gets \lfloor\dfrac{X}{M} \rfloor$。
- 重复以上步骤，直到 $X=0$，此时进制转换结束，令第 $i$ 次的做除法所求得的余数为 $K_i$，共进行了 $N$ 次除法，则最终的 $M$ 进制数为 $\overline{K_n,K_{n-1},\cdots,K_1}$。

下面是将数字 $45$ 转换为 $8$ 进制的例子（图有点丑，将就着看吧）：

![](https://cdn.luogu.com.cn/upload/image_hosting/kcujm1ee.png)

我们可以枚举每一个数，判断其是否为一个完全平方数，并且在八进制下为一个回文数，时间复杂度估计如下：

- 判断 $N$ 个数是否为完全平方数：$O(N\sqrt{N})$
- 对 $N$ 个数转换成 $8$ 进制 $O(N\log_8N)$
- 共计：$O(N\log_8N + N\sqrt{N})$

可是，我却因为 $N\le10^9$ 的庞大数据望而却步……\
此时不难想到优化，在循环时索性跳过不是完全平方数的数，因此只需要判断 $\sqrt{N}$ 个数在 $8$ 进制下是否为回文数，复杂度降为 $O(\sqrt{N} \times \log_8N)$，在 $N\le 10^9$ 的情况下，显然可以通过。

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;

bool check(int x){
    string ans = "";
	while(x){ //短除法
		int k = x % 8;
		ans += (k + '0');
		x /= 8;
	}
    string ans1 = ans;
    reverse(ans.begin(), ans.end()); //将字符串反转
    return ans1 == ans; //判断是否为回文数
}
int main(){
    int n;
    cin >> n;
    for(int i = 1; i * i <= n; ++i){ //此处只需要对完全平方数进行回文判断
    	if(check(i * i)) cout << i << ' ';
	}
    return 0;
}
```

---

## 作者：__UrFnr__ (赞：1)

**题目思路**：

刚看题目时，我想暴力去解决，但是 $1\le N\le10^9$，所以要进行优化。

$1\sim10^9$ 之间大约有 $10^5$ 个完全平方数（我是算 $1\sim10^{10}$ 的），先把这些完全平方数筛出来，存在一个数组里。

然后再写一个函数用来判断这个数转为八进制后是否是回文数。接着我们遍历数组里存的完全平方数，如果 $>N$，那就退出，否则判断一下这个数转为八进制后是否是一个回文数（用写的判断函数判断），如果是，那就输出这个数。

温馨提示：由于我筛的是 $1\sim10^{10}$ 中的完全平方数，所以要开 `long long`。

AC Code:


```cpp
#include <bits/stdc++.h>
#define int long long//不开long long 见祖宗
using namespace std;
int n;
vector <int> v;//存完全平方数的数组
bool szbhw (int x) {//判断函数
    string ans = "", sum = "";
    int num = x;
    while (num) {
        ans += (num % 8 + '0');
        num /= 8;
    }//转八进制
    sum = ans;
    reverse (sum.begin (), sum.end ());
    return sum == ans;//判断是否回文
}
signed main () {
    cin >> n;
    for (int i = 1; i <= 1e5; i ++) v.push_back (i * i);//筛
    for (auto a : v) {//进行遍历判断
        if (a > n) break;
        if (szbhw (a)) cout << a << ' ';
    }
}
```

---

## 作者：Starry_Sky_135 (赞：1)

#   思路

首先 $n$ 的范围很大，不能直接枚举，会超时。

其次不难发现，如果每次枚举都判断是不是平方数，浪费了很多时间，于是可以枚举 $1$ 到 $\sqrt{n}$，判断这些数的平方转换为八进制是不是回文数。

进制转换用短除法即可。

#   [AC](https://www.luogu.com.cn/record/211595339) 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[25];
bool work(int x)
{
    memset(a,0,sizeof(a));
    int k=0;
    while(x)
    {
        a[++k]=x%8;//这里正反没区别，因为只需要判断是否回文就可以了
        x/=8;
    }
    for(int i=1;i<=k;i++)
    {
        if(a[i]!=a[k-i+1]) return false;
    }
    return true;
}
int main()
{
	cin>>n;
	n=sqrt(n);
	for(int i=1;i<=n;i++)
	{
	    int x=i*i;
	    if(work(x)) cout<<x<<" ";
	}
	return 0;
}
```

---

## 作者：wanghonghui123 (赞：0)

## 思路

### 60 分

我们可以写一个函数 `check`，判断这个数的八进制是否回文且这个数是否是平方数。但不难发现：$10^9$ 的数据显然是抗不下来的，一定会 TLE。

### 正解（100 分）

由于我们需要缩小时间复杂度，因此我们可以直接在 for 循环里就设成 $i \times i$ 了，就直接去判断每个平方数的八进制是否回文，减少了许多不必要的损失。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
inline bool check(int x){
	bool f=0;
	vector<int> v;
	while(x){
		v.push_back(x%8);
		x/=8;
	}
	string s="";
	for(int i=v.size()-1;i>=0;i--){
		s.push_back(v[i]+'0');
	}
	string res=s;
	reverse(res.begin(),res.end());
	f=(res==s);
	return f;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(NULL);
	int N;
	cin>>N;
	for(int i=1;i*i<=N;i++){
		if(check(i*i)){
			cout<<i*i<<' '; 
		}
	}
	return 0;
} 
```

---

## 作者：yyycj (赞：0)

## 题目简述
给定一个数 $N$，判断不超过 $N$ 的数中有几个数满足：
1. 为完全平方数
2. 转为八进制下为一个回文数

## 主要思路
考虑枚举。可以直接枚举 $N$ 以内的完全平方数，然后判断八进制下是否为一个回文数即可。

对于十进制数转八进制数，可以使用短除法：使答案与这个数取模 $8$ 的结果拼接，再让这个数除以 $8$，直到这个数为 $0$，最后翻转过来即可。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
typedef long double db;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
inline ll _abs(ll a) { if (a < 0) return -a; return a; }
inline ll _pow(ll a, ll b) { ll x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }
// ----------------------------

// ----------------------------

// ----------------------------
string to_base8(int x) {  // 转八进制函数
	string res = "";
	while (x) {
		res += char(x % 8 + '0');
		x /= 8;
	}
	reverse(res.begin(), res.end());
	return res;
}

int main() {
	int n; cin >> n;
	// ----------------------------
	string s1, s2;
	int x = 1;
	while (x * x <= n) {
		s1 = to_base8(x * x);
        // 翻转字符串判断是否为回文数
		s2 = s1; reverse(s2.begin(), s2.end());
		if (s1 == s2) cout << x * x << ' ';
		x++;
	}
	return 0;
}
```

---

## 作者：LINYUHENG2 (赞：0)

## 思路
由于本题 $n$ 的范围很大，所以直接枚举 $1 \sim n$ 会超时。

因此，我们可以枚举 $1 \sim \sqrt n$，判断它们的平方是否是八进制回文数。这样不仅降低了时间复杂度，还省去了判断平方数的时间，一举两得。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[25];
bool work(int x){
    memset(a,0,sizeof(a));
    int k=0;
    while(x>0){
        a[++k]=x%8;
        x/=8;
    }
    for(int i=1;i<=k;i++){
        if(a[i]!=a[k-i+1]) return 0;
    }
    return 1;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i*i<=n;i++){
        if(work(i*i)) printf("%d ",i*i);
    }
    return 0;
}
```

---

## 作者：SatoruXia (赞：0)

# [蓝桥杯青少年组国赛 2023] 八进制回文平方数
模拟即可。  
我们要寻找这样的数：
- 转化为八进制后为回文数。
- 十进制下为完全平方数。

然后我们就有了这样的思路：在范围内枚举自然数，求该自然数平方后的结果，将结果转为八进制数，判断其是否是回文数，是的话输出。  
这里有一个细节：**可以边转八进制边构造回文数**。怎么做到呢？我们都知道，短除法在最后要把结果倒过来，所以构造回文数时只要直接除不倒过来就行了。短除法就不讲了。这样的作法比字符串快得多。  
第二个细节：如何构造完全平方数？题目输入数据 $N$，便可写出以下的代码：`for (int i = 1; i * i <= N; ++i)`，这样便避免了`sqrt()`函数的麻烦。  
代码如下：
```cpp
#include <iostream>
using namespace std;
//判断回文数
bool check(int num) {
    int old = num;
    int new_ = 0;//new是关键字
    while (num > 0) {
        new_ = new_ * 8 + (num % 8);//短除法
        num /= 8;
    }
    return old == new_;//是否相等
}
int main() {
    int N;
    cin >> N;
    //判断完全平方数
    for (int i = 1; i * i <= N; ++i) {//简单写法
        int square = i * i;//平方
        if (check(square)) {
            cout << square << ' ';//直接输出
        }
    }
    return 0;
}
```

---

## 作者：Mark_Pei (赞：0)

## Solution

一道**进制转换**和**回文**题。

  首先我们会发现：$$1≤n≤10^9$$， 所以 $n$ 的范围很大，如果直接暴力枚举、复杂度为 $O(n)$ 的话，会超时。

其次我们不难发现，如果每次枚举都判断是不是平方数，浪费了很多时间，于是可以枚举 $1$ 到 $\sqrt{n}$，这样所有的数都是平方数，时间复杂度优化为 $O(\sqrt{n})$，判断这些数的平方转换为八进制是不是回文数即可。

至于进制转换，使用短除法即可。

**AC** code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
bool p(int x)
{
    int k=0,a[103];
    memset(a,0,sizeof(a));
    while(x>0)//进制转换
    {
        k++;
        a[k]=x%8;
        x/=8;
    }
    for(int i=1;i<=k;i++)//判断回文
    {
        if(a[i]!=a[k-i+1]) return false;
    }
    return true;
}
int main()
{
	cin>>n;
	for(int i=1;i<=sqrt(n);i++)
	{
	    if(p(i*i)) cout<<i*i<<" ";
	}
	return 0;
}
```

---

## 作者：xf20280111 (赞：0)

## 思路
直接枚举 $i$ 的值，时间复杂度 $\mathcal{O}(n)$。

显然过不了。

枚举 $1$ 到 $\sqrt{n}$，再将他们平方之后转化成 8 进制后是不是回文数。

枚举回文数只需要转化进制时存入一个数组，然后判断是否对称即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100 + 10;
int a[N];
bool jz(int n){
    int i = 0;
    while(n != 0){
        a[i ++] = n % 8;
        n /= 8;
    }//转换进制
    for (int j = 0;j < i / 2;j++){
        if (a[j] != a[i - j - 1]) return false;
    }//判断回文
    return true;
}
int main()
{
    int n;cin >> n;
    for (int i = 1;i * i/*写成 sqrt(n) 精度容易出问题*/ <= n;i++){
        int x = i * i;
        if (jz(x)) {
            cout << x << " ";
        }
    }
    return 0;
}
```

---

## 作者：liwanxian (赞：0)

[前置知识一](https://www.baidu.com/s?wd=%E5%85%AB%E8%BF%9B%E5%88%B6&rsv_spt=1&rsv_iqid=0xf96a19ef0005033a&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&rsv_sug3=10&rsv_sug1=10&rsv_sug7=101&rsv_sug2=0&rsv_btype=i&prefixsug=%25E5%2585%25AB%25E8%25BF%259B%25E5%2588%25B6&rsp=5&inputT=3182&rsv_sug4=3182)，[前置知识二](https://www.baidu.com/s?wd=%E5%9B%9E%E6%96%87%E6%95%B0&rsv_spt=1&rsv_iqid=0xf96a19ef0005033a&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&oq=%25E5%2585%25AB%25E8%25BF%259B%25E5%2588%25B6&rsv_btype=t&inputT=1585&rsv_t=a5cahmUmzwMDUQvCsOrJvsxV3IktoL5zSCXnyyHvHbqd%2Bk1OK915tTzhACL1YY6l4pXy&rsv_pq=be2905200004d956&rsv_sug3=20&rsv_sug1=15&rsv_sug7=100&rsv_sug2=0&rsv_sug4=1585)，[前置知识三](https://www.baidu.com/s?wd=%E5%B9%B3%E6%96%B9%E6%95%B0&rsv_spt=1&rsv_iqid=0xf96a19ef0005033a&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&oq=%25E5%259B%259E%25E6%2596%2587%25E6%2595%25B0&rsv_btype=t&inputT=2087&rsv_t=502bSRnP7conWN18Mth28C6dNUzfoF%2FTP%2BsjPH3KJ%2F0Y%2BqVgAJtPVSfDvT43K0Vsmg62&rsv_pq=b59780b800050146&rsv_sug3=33&rsv_sug1=25&rsv_sug7=100&rsv_sug2=0&rsv_sug4=37743)。

## 思路

枚举！

根据题意，输入整数 $N$，判断从 $1 \sim N$ 之间（含 $1$ 和 $N$）所有满足以下要求的数：

1. 这个数转换为**八进制**后是一个**回文数**。
2. 这个数是一个**平方数**。

那么为了判断此八进制是否为回文数，我们需要：

- 将十进制数转换为八进制。
- 用字符串类中的 `reverse` 函数判断是否回文。

接下来就是判断**是否平方数**了。但是，比起判断此数是否平方数，本人更倾向于**直接寻找**平方数。即通过遍历 $1 \sim \sqrt{N}$ 之间的整数 $i$，计算 $i ^ 2$，并判断 $i ^ 2$ 是否为八进制回文数。

最后，我们将符合要求的数存入动态数组 $res$ 中，一并输出就好啦！

## 实现代码


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>res;
// 将十进制数转换为八进制字符串
string bjz(int n){
    string oct="";
    while(n>0){
        oct=to_string(n%8)+oct;
        n/=8;
    }
    return oct;
}
// 判断一个字符串是否为回文串
bool is_pal(string s){
    string re=s;
    reverse(re.begin(),re.end());
    return s==re;
}
int main(){
    int n;
    cin>>n;
    for (int i=1;i*i<=n;i++){
        int sq=i*i;
        string oct=bjz(sq);
        if (is_pal(oct))
            res.push_back(sq);
    }
    for (int i=0;i<res.size();i++)
        cout<<res[i]<<" ";
    return 0;
}    
```

[AC 记录](https://www.luogu.com.cn/record/211681077)。

---


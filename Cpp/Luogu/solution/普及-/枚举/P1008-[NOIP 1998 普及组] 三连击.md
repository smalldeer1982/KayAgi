# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# 题解

## 作者：Kelin (赞：1104)

应该是最短写法吧

```cpp
#include<cstdio>
#include<cstring>
int i,j,v;bool a[10];//ai表示第i个数已经用过了
int main()
{
    for(i=192;i<=327;i++)//第一个数最小192，最大327。其实不知道的情况下简单来说是从123-329的但是算出来是最值就稍微改了下下
    {
        memset(a,0,sizeof(a));v=0;//清零
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;//统计数字
        for(j=1;j<=9;j++) v+=a[j];//v表示1-9这些数字是否全部齐了
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);//如果齐了就输出
    }
return 0;
}
```

---

## 作者：鸩羽 (赞：609)

题目非常明了，但是对于新人感觉十分不友好，纯模拟，表示身为蒟蒻一开始做的时候是手动筛选的。。

第一次发题解可能版面看起来有些。。。 不要介意

话不多说上代码，自我认为比较好理解，大佬勿喷。

```cpp
#include<iostream>
using namespace std;
int gw; //个位 
int d[9];//用来计数，因为一个数的个位只可能是1,2，3...到9，所以只要9位
int cf(int x){//我们定义一个函数，拆分我们组合出来的每一位数，所以它叫拆分√ 
    while(x!=0){        
        gw=x%10;
        x=(x-gw)/10; //其实完全可以x/10，为了理解方便，我们将x的个位减为0，然后/10把0削去，不断将当期的数拆分
        d[gw]++;//计数器加1
    }
}
int main(){
    int a,b,c;
    for (int i=1;i<=9;i++)
        for (int j=1;j<=9;j++)
            for (int k=1;k<=9;k++){
                a=i*100+j*10+k;
                b=a*2;
                c=a*3;
                cf(a);//将创造出的满足条件的数扔到函数中拆分
                cf(b);
                cf(c);
                if(d[1]==1&&d[2]==1&&d[3]==1&&d[4]==1&&d[5]==1&&d[6]==1&&d[7]==1&&d[8]==1&&d[9]==1){//如果这3个创造出来的数满足每一位都被使用且只用1次，输出
                    cout<<a<<" "<<b<<" "<<c<<endl;
                }
                for (int e=1;e<=9;e++){//判断之后将计数的数组置为0，方便下次使用，不然你一个数都不会输出
                    d[e]=0;//其实可以用memset重置，但是懒得修改了。不了解memset的可以百度一下
                }
            }
            return 0;//华华丽丽的结束
}
```

---

## 作者：Usami_Hearn (赞：455)

个人认为比较浅显易懂.. 但比较麻烦


```cpp
#include<iostream>
using namespace std;
int main()
{ int i,j,k,q,w,e,r,t,y,u,p,o,a[9],m,n,v=0;
for(i=1;i<=3;i++)//百位不可能大于4，否则乘三大于999
 for(j=1;j<=9;j++)//0不符合从1开始
  for(k=1;k<=9;k++)//同上
  {q=i*100+j*10+k;//第一个数
  w=q*2;//第二个
  e=q*3;//第三个
  r=w/100;//第二个数百位
  t=(w%100)/10;//十位
  y=w%10;//个位
  u=e/100;//第三个数百位
  p=(e%100)/10;//十位
  o=e%10;//个位
  a[0]=i;//储存第一二三个数的百十个位数
  a[1]=j;
  a[2]=k;
  a[3]=r;
  a[4]=t;
  a[5]=y;
  a[6]=u;
  a[7]=o;
  a[8]=p;
  v=0;
  for(m=0;m<=8;m++)//一个数一个数比较，若有相同v=1
   for(n=m+1;n<=8;n++)
   {if(a[m]==a[n])
   v=1;
   }
  if(v!=1&&e<=999&&t!=0&&y!=0&&o!=0&&p!=0)//如果没有相同的就输出
  cout<<q<<" "<<w<<" "<<e<<endl;
  }
return 0;
}
望神犇指教
```

---

## 作者：静沐暖阳 (赞：450)

作为新手村的一道题

一定有暴力方法可以解的

我的思路是：

生成 1~9 的所有的全排列，

并将全排列裂解为三项，

做比值，输出。

当然，生成全排列对于这道题的方法就是暴力9层循环

VS编译，请选择性无视 scanf\_s 的问题

还有一些测试用的printf注释也当咩看见吧


【话说我们班有个dalao用的next\_permutation的说】



```cpp
#include <stdio.h>
#include <cstdlib>
int main()
{
    int i[9];
    for (i[0] = 1; i[0] <= 9; i[0]++)
    {
        for (i[1] = 1; i[1] <= 9; i[1]++)
        {
            int p1=0;
            if (i[1] == i[0]) p1 = 1;
            if (p1 != 1) {
                for (i[2] = 1; i[2] <= 9; i[2]++)
                {
                    int p2=0;
                    for (int j2 = 0; j2 < 2; j2++) if (i[2] == i[j2]) p2 = 2;
                    if (p2 != 2) {
                        for (i[3] = 1; i[3] <= 9; i[3]++)
                        {
                            int p3=0;
                            for (int j3 = 0; j3 < 3; j3++) if (i[3] == i[j3]) p3 = 3;
                            if (p3 != 3) {
                                for (i[4] = 1; i[4] <= 9; i[4]++)
                                {
                                    int p4=0;
                                    for (int j4 = 0; j4 < 4; j4++) if (i[4] == i[j4]) p4 = 4;
                                    if (p4 != 4) {
                                        for (i[5] = 1; i[5] <= 9; i[5]++)
                                        {
                                            int p5=0;
                                            for (int j5 = 0; j5 < 5; j5++) if (i[5] == i[j5]) p5 = 5;
                                            if (p5 != 5) {
                                                for (i[6] = 1; i[6] <= 9; i[6]++)
                                                {
                                                    int p6=0;
                                                    for (int j6 = 0; j6 < 6; j6++) if (i[6] == i[j6]) p6 = 6;
                                                    if (p6 != 6) {
                                                        for (i[7] = 1; i[7] <= 9; i[7]++)
                                                        {
                                                            int p7=0;
                                                            for (int j7 = 0; j7 < 7; j7++) if (i[7] == i[j7]) p7 = 7;
                                                            if (p7 != 7) {
                                                                for (i[8] = 1; i[8] <= 9; i[8]++)
                                                                {
                                                                    int p8=0;
                                                                    for (int j8 = 0; j8 < 8; j8++) if (i[8] == i[j8]) p8 = 8;
                                                                    if (p8 != 8) {
                                                                        //printf("%d %d %d %d %d %d %d %d %d\n", i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8]);
                                                                        int a = 100 * i[0] + 10 * i[1] + i[2];
                                                                        int b = 100 * i[3] + 10 * i[4] + i[5];
                                                                        int c = 100 * i[6] + 10 * i[7] + i[8];
                                                                        double d1 = double(a) / b;
                                                                        double d2 = double(c) / b;
                                                                        if (d1 == 0.5 && d2 == 1.5)
                                                                        {
                                                                            printf("%d %d %d\n", a, b, c);
                                                                            //system("pause");
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    system("pause");
    return 0;
}

```

---

## 作者：Drug__Lover (赞：362)

```cpp
//提供一个易理解的解哈！
#include<iostream>
using namespace std;
int main()
{
    for(int i=123;i<333;i++)//从123枚举到333，因为最大是999，所以就不用枚举了哈
    {
        int a[10]={0},b[10]={0},c[10]={0};
        a[1]=i%100%10;//第一个数的个位
        a[2]=i%100/10;//第一个数的十位
        a[3]=i/100;//第一个数的百位
        b[1]=2*i%10%10;//第二个数的个位
        b[2]=2*i%100/10;//第二个数的十位
        b[3]=2*i/100;//第二个数的百位
        c[1]=3*i%10%10;//第三个数的个位
        c[2]=3*i%100/10;//第三个数的十位
        c[3]=3*i/100;//第三个数的百位
        if(a[1]*a[2]*a[3]*b[1]*b[2]*b[3]*c[1]*c[2]*c[3]==362880&&a[1]+a[2]+a[3]+b[1]+b[2]+b[3]+c[1]+c[2]+c[3]==45)//因为1~9这些数加起来和乘起来之后是一定的，所以可以用这个判断哈
        {
            cout<<i<<" "<<i*2<<" "<<i*3<<endl;//依次输出这三个数
        }
    }
    return 0;
}
//第一次来，错误之处多见谅哈
```

---

## 作者：MrBlack (赞：37)

一种新的思路。**九个数字，和为1加到9，积为9的阶乘，只有两种情况**（这又牵涉到了另外一个问题），即为123456789和124445799

很显然最小数的百位数字区间为[1，3]，因为它乘上3要是三位数。124445799中如果**1是最小数的百位数字**，由于没有3，则2一定也是百位数字（乘2）。最小数的个位就不能是4和5和7（乘3不满足）和9（乘2不满足）。如果**2是最小数的百位数字**，则7一定也是百位数字（乘3）。最小数的个位就不能是1和4和5和9（乘3）。因此得到结论，满足**各个位的数字和为1加到9，积为9的阶乘的三个三位数，只有1到9的组合！！**

下面给出程序

```
#include<iostream>
using namespace std;
int main()
{
	int a, b, c;
	for(int i=1;i<=3;i++)   //最小数的百位
		for(int j=1;j<=9;j++)   //最小数的十位
			for (int k = 1; k <= 9; k++)   //最小数的个位
			{
				if (j == i || j == k || k == i)   //排除掉最小数各个位的数字相同的情况
					continue;
				a = 100 * i + 10 * j + k;  //最小数
				b = 2 * a;
				c = 3 * a;
				if (c >= 1000)
					return 0;
				int l = b / 100, m = (b - l * 100) / 10, n = b % 10;  //提取三个三位数的各个位的数字
				int o = c / 100, p = (c - o * 100) / 10, q = c % 10;
				if (i + j + k + l + m + n + o + p + q == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 &&
					i*j*k*l*m*n*o*p*q == 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9)
					cout << a << " " << b << " " << c << endl;
			}
	return 0;
}
```

---

## 作者：usercjh123 (赞：30)

看到大家有很多用9个`for`循环，我很惊讶（其实我一开始也想这样写），但是`c++`的`STL`有个非常神奇（小众）的函数：`next_permuntation`，给出字典序拍下一个的排列，具体定义参见[cppref](http://www.cplusplus.com/reference/algorithm/next_permutation/)

总之，就是有下一个排列，就返回`true`，并把数组修改成下一个排列，没有，就返回false，参见代码：
```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
const ll maxn = 9;
ll num[9];\\存储每一位
ll get_num(ll l, ll r){
	ll temp = 0;
	for(int i = l ; i < r ; i++){
		temp += num[i];
		temp *= 10;
	}
	temp += num[r];
	return temp;
}\\返回[l,r]区间内的数字
int main(){
	for(int i = 0 ; i < 9 ; i++){
		num[i] = i + 1;
	}
	do{
		ll a = get_num(0,2);
		ll b = get_num(3,5);
		ll c = get_num(6,8);
		if(a * 2 == b && a * 3 == c){
			cout << a << " " << b << " " << c << endl; 
		}//判断是否合法
	}while(next_permutation(num,num+9));//下一个排列
}```
这里使用`do...while`是因为不想忽视'123 456 789'这一种情况（其实忽略也没有关系）


---

## 作者：zhm411821 (赞：29)

···
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int v,w[10],n,j,k;
int main(){
    for(int i=1;i<333;i++){//因为三个数为n,n*2,n*3,n*3<=1000,所以n<333
        j=i*2;
        k=i*3;
        n=0;
        memset(w,0,sizeof(w));
        w[i/100]=1;w[i/10%10]=1;w[i%10]=1;//判断是否有重复数字
        w[j/100]=1;w[j/10%10]=1;w[j%10]=1;
        w[k/100]=1;w[k/10%10]=1;w[k%10]=1;
        for(int t=1;t<10;t++)
            n=w[t]+n;
        if(n==9)//如果九个数都有，输出
            cout<<i<<" "<<j<<" "<<k<<endl;
        }
    return 0;
}
···
```

---

## 作者：zyg20010121 (赞：22)

```cpp

#include<stdio.h>
int check(int t1,int t2,int t3);
int main()
{int x;
for(x=123;x<333;x++)  //最小从123开始；最大不超过333
if(check(x,2*x,3*x))  
printf("%d %d %d\n",x,2*x,3*x);//输出结果
return 0;
}
int check(int t1,int t2,int t3) //三个数的数字之和与数字之积都为123456789的和或积，则说明不重复
{ int lRc;//return code
int temp1=45; //1+2+...+9 
long temp2=362880;//1*2*...*9 
long a1=t1%10+t1/10%10+t1/100%10;
long b1=t2%10+t2/10%10+t2/100%10; 
long c1=t3%10+t3/10%10+t3/100%10; 
long a2=(t1%10)*(t1/10%10)*(t1/100%10); 
long b2=(t2%10)*(t2/10%10)*(t2/100%10);
long c2=(t3%10)*(t3/10%10)*(t3/100%10);
if(((a1+b1+c1)==temp1) && (a2*b2*c2==temp2))   
lRc=1;
else lRc=0; 
return lRc;
}

```
其实就是先算1：2：3然后取符合题设的三位数。。。

我只是菜鸟，略知一二。。。


---

## 作者：liuyubobobo (赞：18)

生成 1-9 的全排列进行验证，复杂度O(9!)

全排列的生成使用C++的库函数：next\_permutation


```cpp

#include <vector>
#include <algorithm>
#include <cstdio>

using namespace std;

int main(){

    vector<int> v = vector<int>();
    for( int i = 1 ; i <= 9 ; i ++ )
        v.push_back(i);

    do{
        int a = v[0]*100+v[1]*10+v[2];
        int b = v[3]*100+v[4]*10+v[5];
        int c = v[6]*100+v[7]*10+v[8];

        if( a*2 == b && a*3 == c )
            printf("%d %d %d\n",a , b , c );

    }while( next_permutation( v.begin() , v.end() ) );

    return 0;
}

```

---

## 作者：「QQ红包」 (赞：12)

只要模拟第一个数，第二个数是第一个数的2倍，第三个数是第一个数的3倍。

然后去判读。

```delphi

{将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成1：2：3的比例，试求出所有满足条件的三个三位数。}
var a,b,c,d,e,f,g,h,i,j,s1,s2,s3,s:longint;
     aa:array [0..10] of boolean;
     ff:boolean;
begin
     for a:=1 to 3 do
          for b:=1 to 9 do
              for c:=1 to 9 do
     begin
           fillchar(aa,sizeof(aa),false);
           aa[a]:=true;
           aa[b]:=true;
           aa[c]:=true;
           aa[(a*2+(b*2) div 10) mod 10]:=true;
           aa[((b*2) mod 10+(c*2) div 10)mod 10]:=true;
           aa[(c*2) mod 10]:=true;
           aa[(a*3+(b*3) div 10)mod 10]:=true;
           aa[((b*3) mod 10+(c*3) div 10)mod 10]:=true;
           aa[((c*3) mod 10)mod 10]:=true;
           ff:=false;
           for j:=1 to 9 do
           if aa[j]=false then  ff:=true;
           if ff then continue;
           s1:=a*100+b*10+c;
           s2:=s1*2;
           s3:=s1*3;
           if (s1*2=s2) and (s1*3=s3) then writeln(s1,' ',s2,' ',s3);
     end;
end.


```

---

## 作者：LiHC (赞：11)

```cpp
#include<iostream>
#include<cstring>
using namespace std;
//存储每个数字各出现了多少次
int s[11]={};

//记录x中各个数位上出现的数
void  div(int x)
{
    while(x>0)
    {
        s[x%10]++;//计数
        x/=10;
    }
    return;
}

int main()
{
    int x,y,z;
    //循环1倍数x，三个位上不重复的话最小是123，最大是
    //329，因为如果再大一点的话，第三个数就会超过999，
    //进入四位数的范畴
    for(x=123;x<=329;x++)
    {
        memset(s,0,sizeof(s));//数组清零
        y=x*2;
        z=x*3;
       //分别将一倍数，两倍数和三倍数拆解，并计入s数组
        div(x);
        div(y);
        div(z);
        //判断这组数是否达成条件
        bool f=true;
        //遍历9个数位
        for(int i=1;i<=9;i++)
        {
        	//如果有一个数被记录了多次，或是有一个
            //数没被记录，则这组数肯定不符合条件，
            //直接跳出循环，并更改布尔变量f为false
            //就好了。原因如下：如果这组数符合条件，
            //那么s数组里应该每个数都只记录了一次如
            //果一个数被记了多次，则定然有没被记录
            //的空缺，和被重复记录的数，不管遇到那种
            //情况，都证明这组数不合格。
            if(s[i]!=1)
            {
                f=false;
                break;
            }
        }
        //如果这组数合格，则输出这组数
        if(f)
        {
            cout<<x<<" "<<y<<" "<<z<<endl;
        }
    }
    return 0;
}
```

---

## 作者：WHU2017301500335 (赞：9)

```cpp

#include <stdio.h>
#include <string.h>
int main()
{
    int flag[10],s[3],i,j,c;
    for(s[0]=123;s[0]<=329;s[0]++)
    {
        memset(flag,0,10*sizeof(int));
         s[1]=s[0]*2;
        s[2]=s[0]*3;
        for(i=0;i<3;i++)
        {    flag[s[i]/100]=1;
            flag[(s[i]/10)%10]=1;
            flag[s[i]%10]=1;
            c=0;
            for(j=1;j<10;j++)
                c=c+flag[j];
        }
        if(c==9)
            printf("%d %d %d\n",s[0],s[1],s[2]);
    }
    return 0;
}

```
我的方法，最小的那个三位数从123试到329（因为329\*3=987），flag数组做9个数字的标志（判断都用到没），如果有数字重复的话，flag数组9个数字之和就会小于9，否则打印三个三位数


---

## 作者：silveryelf (赞：6)

DFS深搜C++版

/\*
\* main.cc

\*
\*  Created on: 2014年12月19日

\*      Author: miss

\*/
```cpp
#include<iostream>
#include<cstring>
using namespace std;
bool used[10]={false};
int first,second;
void dfs(int k, int num)
{
    if(k==3)
    {
        first=num;
        num=0;
    }
    else if(k==6)
    {
        second = num;
        num=0;
    }
    else if (k == 9)
    {
        if(num%3==0 and num/3==first and first*2==second)
            cout<<first<<' '<<second<<' '<<num<<endl;
        return;
    }
    for(int i=1;i<=9;i++)
    {
        if(not used[i])
        {
            used[i]=true;
            dfs(k+1, num*10+i);
            used[i]=false;
        }
    }
}
int main()
{
    memset(used, 0, sizeof(used));
    for(int i=1;i<=9;i++)
    {
        used[i]=true;
        dfs(1, i);
        used[i]=false;
    }
    return 0;
}
```

---

## 作者：bzcxl (赞：5)

这道题蛮有意思的，我的思路是暴力枚举。

枚举一个数字，算出另外两个数字，判断是否合法（即是否有相同数字）

这种枚举思路其实很好用，在noip2016年普及第二题的回文日期即是如此，枚举年份倒序检查月日是否合法，题外话不多说。

注意点：

1.这里的数字是1~9，并不包括0，所以可以看到下面我的程序把桶数组b的b[0]在操作之前设为1。

2.小心由第一个数字算出另外两个数字后超出999，所以要加一个判断条件

3.每枚举一个数字就把桶清零

下面程序：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int b[10];
int main()
{
	for(int i=1;i<=9;i++)
	 for(int j=1;j<=9;j++)
	  for(int k=1;k<=9;k++)
	  if(i!=j&&j!=k&&i!=k&&i*100+j*10+k<=333)
	  {
	  	 memset(b,0,sizeof(b));
	  	 b[0]=1;
	  	 int n1=i*100+j*10+k;
	  	 int n2=n1*2,n3=n1*3;
	  	 b[i]=1;b[j]=1;b[k]=1;
	  	 if(b[n2%10]==0&&b[n2/10%10]==0&&b[n2/100]==0) {b[n2%10]=b[n2/10%10]=b[n2/100]=1;} else continue;
	  	 if(b[n3%10]==0&&b[n3/10%10]==0&&b[n3/100]==0) {cout<<n1<<' '<<n2<<' '<<n3<<endl;} 
	  }
}
```
当然，我们很容易发现，这个枚举思路可以反过来。

即我们深搜枚举三个数（枚举9个数字的排列），最后再验算三个数的比例关系。这里我没有打深搜的代码（~~因为很明显循环枚举舒服一点吧~~）。

好了这题，就是这样了。


---

## 作者：野菜汤 (赞：5)

这个题没有什么，穷举吧。设abc:def:ghi=1:2:3 

但是穷举也有多种方法。例如生成123456789的每个排列再求，显然要枚举 9!=362880次，不爽。其实只需枚举abc就可以了，乘以2和3就得到def和ghi, 最后判断有没有相等的。 

显然c<>5, a<=3,枚举次数仅为3\*8\*7=168次。不用我再说了吧。 为了方便，连c<>5也不要了。用字符串更方便。 呵呵，多枚举了几次，但是程序短呀！程序见附件。 

```delphi
var 
  i:integer;   
  s,ss:string;   
  c:char; 
begin 
  for i:=123 to 327 do  {最小数的可能范围} 
  begin 
    str(i,ss); 
    str(i*2,s); 
    ss:=ss+s;     
    str(i*3,s);
    ss:=ss+s;
    for c:='1' to '9' do 
    if pos(c,ss)=0 then break;
    if pos(c,ss)=0 then continue;
    writeln(i,' ',i*2,' ',i*3);   
    end;
 end.
```

---

## 作者：Memory_of_winter (赞：5)

暴力搜索第一个点

```cpp
var
 a,b,c,d,n,m:longint;
 x:array[1..9]of longint;
begin
 for a:=111 to 333 do//a有这几种可能，因为时间够，数字重复可以后面判断。
  begin
   b:=a*2;//b是a的2倍
   c:=a*3;//c是a的3倍
   x[1]:=a mod 10;//记录a的个位
   x[2]:=a mod 100 div 10;//记录a的十位
   x[3]:=a div 100;//记录a的百位
   x[4]:=b mod 10;//记录b的个位
   x[5]:=b mod 100 div 10;//记录b的十位
   x[6]:=b div 100;//记录b的百位
   x[7]:=c mod 10;//记录c的个位
   x[8]:=c mod 100 div 10;//记录c的十位
   x[9]:=c div 100;//记录c的百位
   n:=1;
   for d:=1 to 9 do n:=n*x[d];//判断数字是否相同，1~9的乘积一定是362880
   m:=0;
   for d:=1 to 9 do m:=m+x[d];//判断数字是否相同，1~9的和一定是45
   if (n=362880) and (m=45) then writeln(a,' ',b,' ',c);//判断数字是否相同，如果否就输出
  end;
end.
```

---

## 作者：monna (赞：4)

![题目原文](https://cdn.luogu.com.cn/upload/pic/41938.png )

此题我的解题思路为：
1.通过三重循环构造出1-9可能的所有三位数组合；
2.通过筛选条件：三位数，无重复构造数字 确定第一个有效的三位数，由得到的三位数分别*2，*3，得出符合1：2：3条件的一组数，筛选符合三位数要求的一组数；
3.通过分解三位数，循环判断这组三位数中是否包含重复的数字

------------
关键代码：
int a=i*100+j*10+k;
num[0]=a/100;
num[3]=(a/10)%10;
num[6]=a%10;
for (int i = 0; i < num.length-1; i++) {
	for (int j = i+1; j < num.length; j++) {
		if (num[i]==num[j]) {
			result=false;
		}
	}
}

```java
public class ThreeCombo {
	
	public boolean isStoreValue(int a,int b,int c) {
		boolean result=true;
		int [] num=new int [9];
		num[0]=a/100;
		num[1]=b/100;
		num[2]=c/100;
		num[3]=(a/10)%10;
		num[4]=(b/10)%10;
		num[5]=(c/10)%10;
		num[6]=a%10;
		num[7]=b%10;
		num[8]=c%10;
		if (num[0]!=0&&num[1]!=0&&num[2]!=0&&num[3]!=0&&num[4]!=0&&num[5]!=0&&num[6]!=0&&num[7]!=0&&num[8]!=0) {
			for (int i = 0; i < num.length-1; i++) {
				for (int j = i+1; j < num.length; j++) {
					if (num[i]==num[j]) {
						result=false;
					}
				}
			}
		}else {
			result=false;
		}
		return result;
	}
	
	/**
	 * 排列组合1-9成三位数
	 * @return
	 */
	public void setupNum() {
		int count=0;  //符合条件的数字个数
		for(int i=1;i<10;i++) {
			for(int j=1;j<10;j++) {
				for(int k=1;k<10;k++) {
					if ((i!=j)&&(j!=k)&(i!=k)) {
						//组成符合1：2：3条件的三个三位数
						int a=i*100+j*10+k;
						int b=a*2;
						int c=a*3;
						//保证符合条件的b,c为三位数
						if (b/1000==0&&c/1000==0) {
//							判断a,b,c的各个位数是否不重复
							if (isStoreValue(a, b, c)) {
								System.out.println(a+" "+b+" "+c);
							}
						}
					}
				}
			}
		}
	}
	
	public static void main(String[] args) {
		new ThreeCombo().setupNum();
	}
}
```

---

## 作者：chenyy (赞：4)

看题解里没有C++的字符串解法，自己写一个好了

```cpp

#include <cstdio>
using namespace std;
int main(){
    for (int i=123;i<=333;i++){
        char a[4],b[4],c[4];//字符串结束符占用一个字符空间
        sprintf(a,"%d",i);//将int转换为char
        sprintf(b,"%d",i*2);
        sprintf(c,"%d",i*3);
        bool num[10] = {0};
        num[a[0]-48] = true;//ascii码中，0-9对应48-57
        num[a[1]-48] = true;
        num[a[2]-48] = true;
        num[b[0]-48] = true;
        num[b[1]-48] = true;
        num[b[2]-48] = true;
        num[c[0]-48] = true;
        num[c[1]-48] = true;
        num[c[2]-48] = true;
        if (num[0]) continue;//题目要求1-9的数字，出现0即为Wrong Answer
        int count = 0;
        for (int i=0;i<10;i++) if (num[i]) count ++;
        if (count == 9){
            printf("%s %s %s\n",a,b,c);
        }
    }
    return 0;
}


```

---

## 作者：Tellack (赞：4)

可能是这题最简单粗暴的破解办法，也可能是最短的写法。

利用C++ STL提供的集合，把得到的三位数逐位放到命名为cache的这个集合(set)里，集合里出现零就跳过，集合元素数够9了就输出

耗时2ms过了

头文件就不堆了，直接上核心代码：


#define INS(x) cache.insert(x/100); cache.insert(x%100/10); cache.insert(x%10); //宏定义一个把三位数往cache插的插入方法

```cpp
using namespace std;
int main(){
    for(int a=111;;a++){
        int b=a*2,c=a*3; //枚举所有满足1:2:3的整数
        if(c>1000)break;
        set<int> cache;
        INS(a)
        INS(b)
        INS(c)
        if (cache.count(0)) continue; //集合里出现零就跳
        if (cache.size()==9) //集合够九个数字就输出
            printf("%d %d %d\n",a,b,c);
    }
    return 0;
}
```

---

## 作者：hanghang0702 (赞：3)

[color=red]这题比较简单，穷举第一个数字，求出第二三个数字，判断重复数字和0以及位数，合法输出，不合法不输出。[/color]

标程：

```delphi
var a,b,c:longint;
    f:array['0'..'9'] of longint;//重复数字判断数组
function check(a,b,c:longint):boolean;//判断重复数字函数
var st,s1,s2,s3:string;//定义
    i:char;j:longint;
begin
 fillchar(f,sizeof(f),0);//赋初值，此语句不可删！(枚举要重复的。)
 str(a,s1);str(b,s2);str(c,s3);//获取字符串状态的三数字
 st:=s1+s2+s3;//为了方便，使用一个字符串
 for j:=1 to 9 do
  inc(f[st[j]]);//桶计数
 if f['0']<>0 then exit(false);//若有0
 for i:='1' to '9' do
  if (f[i]>1) or (f[i]=0) then exit(false);//若有数字没用或用多
 exit(true);//正确的一组
end;
begin
 for a:=123 to 400 do//枚举
 begin
  b:=a*2;c:=a*3;//求出1:2:3
  if (b<1000) and (c<1000) then//若在1000内
   if check(a,b,c) then//判断通过
    writeln(a,' ',b,' ',c);//输出
 end;
end.
```

---

## 作者：chenshijian (赞：3)




```cpp
#include <iostream>
using namespace std;
bool pd[11];  //开个bool，真为数字用过，假为数字没有过 
bool fenjie ( int x )  //分解数位子程序 
{
    int p;
    while ( x!=0 )
    {
           p=x%10;  //每个数位上的数  
           x/=10;   
           if( pd[p] )  return false;  //判断有没有重复    
           else pd[p]=true;
    }
    return true ;    //如果可以逃出while循环，证明这个符合条件 
} 
int main()  //主程序 
{
    int b=0,c=0;
    pd[0]=true;   //避免0的情况出现 
    for( int i=123;i<=333;i++ )
    {
        for( int i=1;i<=9;i++ )  pd[i]=false;  //这条初始语句如果放在了循环的末端，遇到了continue就糟糕了，因为根本不执行。 
        if( !fenjie( i ) )  continue;   //如果第一个数不符合条件，则进入下一次循环 
        else  //如果第一个数符合条件
       {
            b=i*2;   
            if( !fenjie( b ) )  continue;  //如果第二个数不符合条件，则进入下一次循环 
            else   //如果第二个数也符合条件
           {
                 c=i*3;
              if( !fenjie( c ) )  continue; ////如果第三个数不符合条件，则进入下一次循环 
              else 
              cout<<i<<" "<<b<<" "<<c<<endl;  //否则，就可以输出了，因为经过重重判断，这三个数在一次都符合条件了 
           }
        }
    }
    return 0;
}
```

---

## 作者：motuiluola (赞：3)

```cpp

#include<iostream>
using namespace std;
void split(int num,char *a,char *b,char *c)
{
    *a=num/100+'0';
    *b=num/10%10+'0';
    *c=num%10+'0';
}
char fig[9];
bool isDifferent(void)
{
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            if(i==j)
            {
                continue;
            }
            if(fig[i]==fig[j]||fig[i]=='0')
            {
                return 0;
            }
        }
    }
    return 1;
}
int main()
{
    for(int i=100;i<=333;i++)
    {
        int j,k;
        j=i+i;
        k=j+i;
        split(i,fig,fig+1,fig+2);
        split(j,fig+3,fig+4,fig+5);
        split(k,fig+6,fig+7,fig+8);
        if(isDifferent())
        {
            cout<<i<<' '<<j<<' '<<k<<endl;
        }
    }
}

```
枚举从100到333，算出他的二倍和三倍，看三个数中数字有无重复或等于0，若没有即符合要求

数组中存的是每个数字的字符的编码，其实就等于该数字+’0‘的编码

主函数中的数组名+自然数n，就是该数组第n个元素的地址


---

## 作者：CancerGary (赞：3)

虽然题目很水，不过试了下STL的全排列感觉桑心病狂= =

[c++]
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    int a[]={1,2,3,4,5,6,7,8,9};
    int i,j;
    for (i=1;i<=362880;i++){
        //for (j=0;j<5;j++) cout << a[j] << " ";
        if (((a[0]*100+a[1]*10+a[2])*3==(a[6]*100+a[7]*10+a[8]))&&
        ((a[0]*100+a[1]*10+a[2])*2==(a[3]*100+a[4]*10+a[5]))) {
            for (j=0;j<3;j++) cout << a[j*3] << a[j*3+1]<< a[j*3+2]<<" ";
            cout <<endl;
        }
        next_permutation(a,a+9);//STL全排列函数
    }
    return 0;
}
[/c++]
```

---

## 作者：天狗的手帖 (赞：3)

依次枚举这三个数貌似会超时吧。。我们可以枚举第一个数然后构造出另外两个，这样就是一组合法的三连击。然后再判断这9个数字都不为0且互易即可。


```cpp

#include<cstdio>

using namespace std;

int main()

{
    
    int a,b,c;
    
    int adl=1+2+3+4+5+6+7+8+9;
    int mul=1*2*3*4*5*6*7*8*9;
    
    int tadl,tmul,i;
    
    int p[10];
    
    for (a=123;a<=333;a++)
    
    {
        b=a*2;
        c=a*3;
        
        p[1]=a%10;
        p[2]=a/100;
        p[3]=(a/10)%10;
        
        p[4]=b%10;
        p[5]=b/100;
        p[6]=(b/10)%10;
        
        p[7]=c%10;
        p[8]=c/100;
        p[9]=(c/10)%10;
        
        for (i=1;i<=9;i++) 
        
            if (p[i]==0) continue;
        
        tadl=0;
        tmul=1;
        
        for (i=1;i<=9;i++) tadl=tadl+p[i];
        for (i=1;i<=9;i++) tmul=tmul*p[i];
        
        if ( (tadl==adl) and (tmul==mul) )
        
            printf("%d %d %d\n",a,b,c);
            
    }
    
    return 0;
    
}
        
        

```

---

## 作者：wswhy (赞：2)

这题看似麻烦，其实思路很简单，样例中是1:2:3，用这三个数作为循环开始，2:4:6,3:6:9.。。。。。。一遍一遍的试，符合则输出，简单粗暴，一遍ac。。。望采纳。。。


```cpp
    var  
      i,i2,i3,q,w,q2,www,o:integer;  
      a,b,c,s:string;  
      w2:array[1..9] of integer;  
    begin  
      for i:=1 to 9 do w2[i]:=i;  www:=0;  
      for i:=192 to 329 do  
        begin  
          i2:=i*2;  
          i3:=i*3;  
          str(i,a); str(i2,b); str(i3,c);  
          s:=a+b+c;  
          for q:=1 to length(s) do  
          begin  
          w:=ord(s[q])-48;  
           for q2:=1 to 9 do  
            if w=w2[q2] then w2[q2]:=0;  
            end;  
            for q2:=1 to 9 do if w2[q2]<>0 then www:=1;  
            if www=0 then writeln(i,' ',i2,' ',i3);  
        for o:=1 to 9 do w2[o]:=o;  www:=0;  
         a:=''; b:=''; c:='';  
        end;  
end.
```

---

## 作者：1446435502l (赞：2)

```cpp
#include<iostream>//我来发一波回溯题解
#include<cstdio>
using namespace std;
int a[10];
int n;
bool vis[10];
void dfs(int nn)//nn指的是我们开始找第几个数（我们一共要找9个数）
{
    int i;
    if(nn==10)//当我们开始找第十个数，也就是要求的九个数都找完了，我们就来到了递归的终点
    {
        if((3*(a[1]*100+a[2]*10+a[3])==(a[7]*100+a[8]*10+a[9]))&&(2*(a[1]*100+a[2]*10+a[3])==(a[4]*100+a[5]*10+a[6])))//按照题目要求判断
        {
            for(i=1;i<=9;i++)//符合要求就输出
        {
            printf("%d",a[i]);
            if(i%3==0)
            {
                printf(" ");
            }
        }
        printf("\n");
        }
        return;
    }
    for(i=1;i<=9;i++)//我们来穷举每一个数
    {
        if(!vis[i])//如果这个数还没用过我们就用上
        {
            a[nn]=i;
            vis[i]=true;
            dfs(nn+1);
            vis[i]=false;//回溯
        }
    }
}
int main()
{
    dfs(1);//我们从第一个数开始找起
}
```

---

## 作者：迪哥铁粉002 (赞：1)

```cpp
#include<iostream>
using namespace std;
int a[10];
int zf(int x,int b,int c)
{
    for (int i=1;i<=3;++i)
    {
        a[x%10]++;//下行以及本行都为统计数字部分 
        a[b%10]++;//统计1-9是否都是只有出现了1次 
        a[c%10]++;
        x/=10;
        b/=10;
        c/=10;
    }
    if (a[1]==1&&a[2]==1&&a[3]==1&&a[4]==1&&a[5]==1&&a[6]==1&&a[7]==1&&a[8]==1&&a[9]==1)
```
{//判断是否1-9都只出现了一次，如果是，return 1，否则 return 0。
for (int i=1;i<=9;++i) a[i]=0;//注意这个地方真的很重要，一定要把数组清零！

```cpp
        return 1;
    }
    for (int i=1;i<=9;++i) a[i]=0;//这里也得清零一次，否则return 1之后就没法清零了！ 
    return 0;
}
int main()
{
    int n;
    for (int i=100;i<=999;++i)//这个地方不用用三重循环，太费时间，一重即可。 
        if (zf(i,i*2,i*3))//题目说1:2:3，这里就可以用倍数关系输入函数了！ 
        cout<<i<<" "<<i*2<<" "<<i*3<<endl;//判断正确的话，就输出即可~ 
    return 0;
}//程序886~~~
```

---


# [ROIR 2024] 双调序列 (Day 1)

## 题目背景

翻译自 [ROIR 2024 D1T2](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day1.pdf)。

称一个序列 $[b_1, b_2, \dots, b_k]$ 为双调序列（Bitonic Sequence），当且仅当存在一个 $1 \leq i \leq k$ 使得 $ b_1 < b_2 < \dots < b_i > \dots > b_k $。

例如，序列 $[1]$，$[2,4,5,7,5,4]$，$[1, 4, 10]$，$[3, 2]$ 都是双调序列，而序列 $[1, 1]$，$[5,4,2,4,5,7]$，$[1,1,4,5,1,4]$ 都不是。

## 题目描述

给定一个序列 $[a_1, a_2, \dots, a_n]$。要求计算满足条件的 $(l, r)$ 对的数量，其中 $1 \leq l \leq r \leq n$ 并且序列 $[a_l, a_{l+1}, \dots, a_r]$ 是双调序列。

## 说明/提示

在样例一中，满足条件的 $(l, r)$ 对如下：
- $(1, 1)$，对应序列 $[1]$；
- $(2, 2)$，对应序列 $[1]$；
- $(2, 3)$，对应序列 $[1, 2]$；
- $(2, 4)$，对应序列 $[1, 2, 3]$；
- $(2, 5)$，对应序列 $[1, 2, 3, 1]$；
- $(3, 3)$，对应序列 $[2]$；
- $(3, 4)$，对应序列 $[2, 3]$；
- $(3, 5)$，对应序列 $[2, 3, 1]$；
- $(4, 4)$，对应序列 $[3]$；
- $(4, 5)$，对应序列 $[3, 1]$；
- $(5, 5)$，对应序列 $[1]$。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $27$ | $n\le500$ |
| $2$ | $14$ | $n\le5000$ |
| $3$ | $20$ | 所有 $a_i$ 互不相等 |
| $4$ | $39$ | 无 |

对于 $100\%$ 的数据，$1 \leq a_i \leq n \leq 300000$。

## 样例 #1

### 输入

```
5
1 1 2 3 1```

### 输出

```
11```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
3```

# 题解

## 作者：Forge_Unique (赞：6)

## 题目描述
称一个序列 $[b_1, b_2, \dots, b_k]$ 为双调序列（Bitonic Sequence），当且仅当存在一个 $1 \leq i \leq k$ 使得 $ b_1 < b_2 < \dots < b_i > \dots > b_k $。

例如，序列 $[1]$，$[2,4,5,7,5,4]$，$[1, 4, 10]$，$[3, 2]$ 都是双调序列，而序列 $[1, 1]$，$[5,4,2,4,5,7]$，$[1,1,4,5,1,4]$ 都不是。

给定一个序列 $[a_1, a_2, \dots, a_n]$。要求计算满足条件的 $(l, r)$ 对的数量，其中 $1 \leq l \leq r \leq n$ 并且序列 $[a_l, a_{l+1}, \dots, a_r]$ 是双调序列。

## 思路
定义两个数组 $s_i$，$f_i$ 分别表示 $a$ 数组中以 $i$ 为结尾的最长上升子序列和 $a$ 数组中以 $i$ 为开头的最长下降子序列。根据组合数学可知，以 $i$ 为分段处的答案就是 $s_if_i$。而 $s_i$，$f_i$ 这两个数组可以用 $O(n)$ 的时间复杂度递推求出来。所以总时间复杂度为 $O(n)$ 可以通过本题。

## 代码
[code](https://www.luogu.com.cn/paste/bh501h9l)

---

## 作者：DFs_YYDS (赞：5)

# 题目大意
给你 $n$ 个数，问你这 $n$ 个数中有多少个双调序列，也就是说前半段严格上升，后半段严格下降。
# 具体思路
我们可以将一个双调序列拆分成两个部分，分别是左边的上升序列和右边的下降序列。我们用两个数组 $f$ 和 $f2$ 分别表示以 $i$ 结尾的上升序列有多少个和以 $i$ 开头的下降序列有多少个。

如何计算 $f$ 和 $f2$ 呢？首先是 $f$，$f_1$ 显然是 $1$，接着从左往右推，如果 $a_i>a_{i-1}$，$f_i$ 就是 $f_{i-1}+1$，否则 $f_i$ 就为 $1$。

同理，$f2_n=1$，从右往左推.如果 $a_i>a_{i-1}$，$f2_i$ 就是 $f2_{i+1}+1$，否则 $f2_i$ 就为 $1$。

那么，对于每一个 $i$，以 $i$  为峰值的双调序列个数就是 $f_i\times f2_i$，最后再累加起来就行。
# 完整代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[300005];
int f[300005],f2[300005];
signed main(){
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1]=f2[n]=1;//初始化
	for(int i=2;i<=n;i++){
		if(a[i]>a[i-1])f[i]=f[i-1]+1;
		else f[i]=1;
	}//计算f。
	for(int i=n-1;i>0;i--){
		if(a[i]>a[i+1])f2[i]=f2[i+1]+1;
		else f2[i]=1;
	}//计算f2。
	for(int i=1;i<=n;i++)ans+=f[i]*f2[i];//相乘。
	cout<<ans;
	return 0;//完结撒花！
}
```

---

## 作者：Jason_Teng (赞：2)

这一题其实就是严格上升序列+一个严格下降序列。

参考[合唱队形](https://www.luogu.com.cn/problem/P1091)。

没啥可讲的，上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000001],f[1000001],g[1000001];
signed main()
{
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 1;i <= n;i++)
	{
        if(a[i] > a[i - 1]) f[i] = f[i - 1] + 1;
        else f[i] = 1;
    }
    for(int i = n;i >= 1;i--){
        if(a[i] > a[i + 1]) g[i] = g[i + 1] + 1;
        else g[i] = 1;
    }
    int sum = 0;
    for(int i = 1;i <= n;i++) sum += f1[i] * f2[i];
    cout << sum << endl;
    return 0;
}
```

---

## 作者：WegestGao (赞：1)

重要的事情说三遍！
#### 开 long long！
#### 开 long long！
#### 开 long long！

## 思路

对于双调序列来说，最重要的就是峰值。无论你是单枪匹马（即一个点）、还是威武雄狮（即很多个点），你都可以构成一个双调序列，只要那个峰值存在。本题中，双调队列是严格的。前段是严格递增，后端是严格递减。

由于**每个点都可以成为一个峰值的点**，所以我们需要遍历每一个点，然后找到所有符合的点（即左端、右端），最后作组合统计。由于无论如何都要经过峰值，我们不难发现当该点作为峰值时的情况数为左侧（包括自己）的个数 $l$ 与右侧（包括自己）的个数 $r$ 的乘积。例如对于子段
``
1 2 3 1
``
来说（其中以 `3` 作为峰值，`3` 是对应 $l_1$ 和 $r_1$，左侧的 `2` 对应 $l_2$，左侧的 `1` 对应 $l_3$，右侧的 `1` 对应 $r_2$），子段情况有
$$
(l_1 ,r_1),(l_2,r_1),(l_3,r_1),(l_1,r_2),(l_2,r_2),(l_3,r_2)
$$
于是，令 $l$ 为左侧情况的个数（本例中是 $3$），令 $r$ 为右侧情况的个数（本例中是 $2$），则当 $l_1,r_1$ 共同的元素 $i$ 为峰值时，情况数 $k_i$ 为：
$$
k_i=l\cdot r
$$
简单地，我们写出了如下代码：
```
for(int i=1;i<=n;i++){
  l=1;
  r=1;
  for(int j=i-1;j>=1;j--){
  	if(a[j]<a[j+1]) l++;
    else break;
  }
  for(int j=i+1;j<=n;j++){
    if(a[j-1]>a[j]) r++;
  	else break;
  }
  ans+=l*r;
}
```
但是显然会 TLE 掉！

怎么办？**递推**解决。

对于左侧来说，只要它一直严格上升，说明它仍然可以作为左侧的一部分。这个时候：
$$
l_i=l_{i-1}+1
$$
但是如果它等于或小于怎么办呢？它就是~~出头鸟~~第一个！
$$
l_i=1
$$
整合一下，可以得到
$$
l_i = \begin{cases}
l_{i-1}+1 & l_i>l_{i-1}\\
1 & l_i \le l_{i-1}
\end{cases}
$$
对于右侧来说，我们可以用同样的方法，得到：
$$
r_i = \begin{cases}
r_{i+1}+1 & r_i > r_{i+1}\\
1 & r_i \le r_{i+1}
\end{cases}
$$
所以我们可以开数组 $l$ 和 $r$，在数据输入后递推得到所有数据，再进行计算就会很省时间。

最后，就像开头说的：

`` #define int long long ``！

附上 AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
int n;
int a[300010];
int l[300010],r[300010];
int ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	a[0]=INT_MAX;
	a[n+1]=INT_MAX;
	for(int i=1;i<=n;i++){
		if(a[i]>a[i-1]) l[i]=l[i-1]+1;
		else l[i]=1;
	}
	for(int i=n;i>=1;i--){
		if(a[i]>a[i+1]) r[i]=r[i+1]+1;
		else r[i]=1;
	}
	for(int i=1;i<=n;i++){
		ans+=l[i]*r[i];
	}
	cout<<ans;
	return 0;
}
```
（这里的 $a_0$ 和 $a_{n+1}$ 的 ` INT_MAX ` 的赋值可以保证 $a_1$ 和 $a_n$ 所对应的 $l,r=1$）

~~好久没打题解了，请管理员大大手下留情！~~

---

## 作者：cff_0102 (赞：1)

枚举每个“子双调序列”的最大点，那么以它为最大点的双调序列数量就是它左边的严格递减序列的长度乘以右边的严格递减序列的长度（即在左边取一个 $l$，右边取一个 $r$ 的方案数）。一个双调序列只有一个最大点，所以枚举所有最大点就能找到所有方案。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=300005;
int a[N],l[N],r[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		if(a[i]>a[i-1])l[i]=l[i-1]+1;
		else l[i]=1;
	}
	for(int i=n;i>=1;i--){
		if(a[i]>a[i+1])r[i]=r[i+1]+1;
		else r[i]=1;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=l[i]*r[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

非常简单的一道题。

不难发现，双调序列可以拆为严格递增序列和严格递减序列，那么我们分别求一下以第 $i$ 个数结尾的最长严格递增子串长度 $p_i$ 和以第 $i$ 个数开头的最长严格递减子串长度 $s_i$，可得答案为：

$$
\sum_{i = 1} ^ n p_is_i
$$

时间复杂度 $O(n)$。

代码如下：

```cpp
#include <iostream>
#define int long long
using namespace std;
int n, a[300005];
int pre[300005], suf[300005];
int32_t main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) cin >> a[i];
  pre[1] = suf[n] = 1;
  for (int i = 2; i <= n; ++i) pre[i] = (a[i - 1] < a[i] ? pre[i - 1] : 0) + 1;
  for (int i = n - 1; i ; --i) suf[i] = (a[i + 1] < a[i] ? suf[i + 1] : 0) + 1;
  int ans = 0;
  for (int i = 1; i <= n; ++i) ans += pre[i] * suf[i];
  cout << ans;
}
```

---

## 作者：2022linzhiyi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11121)

显然可以发现双调序列可以分为前面的单调递增序列和后面的单调递减序列。

考虑枚举中间的分界点，算出所有以该节点为终点的最长上升序列和以该节点为起点的最长下降序列的长度，分别记在 $l$ 数组和 $r$ 数组中。又因为以该点为分界点，所以从这点开始往左的 $l_i$ 长度中都可作为左端点，右端点同理，所以对于该点贡献的答案即为：$l_i \times r_i$。

计算两个数组只需要正着扫一遍数组和反着扫一遍数组即可，具体看代码。

那么最终答案记为所有点的贡献之和，时间复杂度 $O(n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300010;
int n,a[N],l[N],r[N];
long long res;
int main()
{
	cin >> n;
	for (int i=1;i<=n;i++) cin >> a[i];
	for (int i=1,cnt=0;i<=n;i++) {
		if (a[i] > a[i-1]) cnt ++;
		else cnt=1;
		l[i]=cnt;
	}
	for (int i=n,cnt=0;i>=1;i--) {
		if (a[i] > a[i+1]) cnt ++;
		else cnt=1;
		r[i]=cnt;
	}
	for (int i=1;i<=n;i++) res += (long long)l[i]*r[i];
	cout << res;
	return 0;
}
```

---

## 作者：OIer6666 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11121)

## 解题思路：

我们把一个双调序列（$[b_1, b_2, \dots, b_k]$）拆成 $3$ 部分：

1. $[b_1, b_2, \dots, b_{i-1}]$。
1. $[b_i]$。
1. $[b_{i+1}, b_{i+2},\dots, b_k]$。

那么我们可以选择第一部分中的 $[b_n, b_{n+1}, \dots, b_{i-1}]$，$1\le n\le i-1$，再选择第三部分中的 $[b_{i+1}, b_{i+2},\dots, b_m]$，$i+1\le m\le k$，合成一个双调序列，那么就有 $i\times (k-i+1)$ 种不同的双调序列。

为了求出解，我们可以枚举 $i$，将算出的东西累加。

### 提醒：

如果你 $41$ 分，那么一定要开 `long long`！

## 代码：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define int long long
int a[1919810],suml[1919810],sumr[1919810],ans;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
		suml[i]=(a[i]>a[i-1]?suml[i-1]:0)+1;
	for(int i=n;i>=1;i--)
		sumr[i]=(a[i]>a[i+1]?sumr[i+1]:0)+1,ans+=sumr[i]*suml[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P11121 题目](https://www.luogu.com.cn/problem/P11121)

### 解题思路
定义 $b_i$ 为满足 $a_k<a_{k+1}<\cdots<a_i$ 的最小的 $k$，$c_i$ 为满足 $a_k<a_{k-1}<\cdots<a_i$ 的最大的 $k$。

那么不难发现，当 $a_i>a_{i-1}$ 时，$b_i=b_{i-1}+1$，否则 $b_i=1$，特别的，$b_1=1$。$c$ 数组同理。

我们可以枚举的双端队列最大值，当最大值为 $a_i$ 时，显然双端队列的个数为 $b_i\times c_i$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[300002],ll[300001],rl[300001];
signed main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]>a[i-1])
			ll[i]=ll[i-1]+1;
		else
			ll[i]=1;
	}
	for(int i=n;i>=1;i--)
	{
		if(a[i]>a[i+1])
			rl[i]=rl[i+1]+1;
		else
			rl[i]=1;
	}
	int s=0;
	for(int i=1;i<=n;i++)
		s+=ll[i]*rl[i];
	cout<<s;
	return 0;
}
```

---

## 作者：JoeZYQ (赞：0)

### 思路
维护 $l_i$ 为以 $i$ 为结尾的最长递增子串长度，维护 $r_i$ 为以 $i$ 为开头的最长递减子串长度。

由题可知：$l$ 一定在以 $i$ 为结尾的最长递增子串之中，也就是有 $l_i$ 种可能；$r$ 一定在以 $i$ 为开头的最长递减子串之中，也就是有 $r_i$ 种可能，通过乘法原理即可算出答案。

---

## 作者：ZG10086 (赞：0)

## 题意

计算一个给定序列中满足双调序列性质的子序列的数量。双调序列的定义是：一个序列先严格递增，后严格递减。特殊情况下，整个序列可以是单调递增或单调递减的。

## 思路

先遍历整个序列，看是递增还是递减，判断是满足双调序列性质。如果当前元素和前一个元素相等，无法构成双调序列，因此必须从这个元素重新开始计算新的子序列。

## 实现

维护一个数组，表示以当前元素结尾的双调序列的起始位置。当我们遍历每个元素时，根据当前的趋势来更新起点，并累计符合条件的子序列数。对于每个元素，计算从数组中到当前元素构成的子序列数量，最终加起来就完了。

由于答案可能过大，记得开 long long。

时间复杂度 $O(n)$

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[300010],sum[300010];
long long ans=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int x=0;//表示趋势 
	sum[1]=1; 
	for(int i=2;i<=n;i++)
	{
        if(a[i]==a[i-1]){
            sum[i]=i;
            x=0;
        }else if(x==0){
            x=(a[i]>a[i-1])?1:-1;
            sum[i]=sum[i-1];
        }else if(x==1&&a[i]<a[i-1]){
            x=-1;
            sum[i]=sum[i-1];
        }else if(x==-1&&a[i]>a[i-1]){
            sum[i]=i-1;
            x=1;
        }else{
            sum[i]=sum[i-1];
        }
        ans+=i-sum[i]+1;
    }
    cout<<ans;
}
```

由于蒟蒻太菜了，所以过程比较繁琐，有什么问题请指出。

---

## 作者：T_Wan29_Summer_AC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11121)

## 题目分析
我们需要计算一个给定序列中的双调子序列的数量。双调序列的定义是：存在一个峰值，使得在该峰值之前的元素严格递增，而在该峰值之后的元素严格递减。

也就是说，我们需要计算满足条件的 $(l,r)$ 对的数量，其中 $[a_l,a_{l+1},\dots,a_r]$ 是双调序列。

## 解题步骤
**1. 从左到右遍历，计算递增的长度：**
```cpp
    for (int i = 1; i < n; i++) {
        if (a[i] > a[i - 1]) {
            left[i] = left[i - 1] + 1;
        }
}
```
**2. 从右到左遍历，计算递减的长度：**
```cpp
    for (int i = n - 2; i >= 0; i--) {
        if (a[i] > a[i + 1]) {
            right[i] = right[i + 1] + 1;
        }
}
```
**3. 统计双调序列的数量：**
```cpp
 long long count = 0;
    for (int i = 0; i < n; i++) {
        int l = left[i];
        int r = right[i];
        count += (long long)l * r;
}
```
**4. 最后输出即可。**

---

## 完整代码
时间复杂度 $O(n)$。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    vector<int> left(n, 1), right(n, 1);

    // 计算左侧递增的长度
    for (int i = 1; i < n; i++) {
        if (a[i] > a[i - 1]) {
            left[i] = left[i - 1] + 1;
        }
    }

    // 计算右侧递减的长度
    for (int i = n - 2; i >= 0; i--) {
        if (a[i] > a[i + 1]) {
            right[i] = right[i + 1] + 1;
        }
    }

    long long count = 0;

    // 统计双调序列的数量
    for (int i = 0; i < n; i++) {
        // 对于每个峰值 i，计算左边的长度和右边的长度
        int l = left[i];
        int r = right[i];
        count += (long long)l * r;
    }

    cout << count << endl;
    return 0;
}
```

---

## 作者：xueshengyi (赞：0)

~~好玩的题。~~

题目中的双调序列可以拆分成一个升序序列和一个降序序列，而降序序列经过反转又可以变成倒序的升序序列。

将以每一个点为结尾的正序的升序序列 $s_{i}$ 和倒序的升序序列 $p_{i}$ 相乘之后再加起来即可。即：

$$
\sum_{i=1}^{n}s_{i}x_{i}
$$

记得开 long long。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<=(y);i++)
#define foR(i,x,y,...) for(int i=(x),##__VA_ARGS__;i>=(y);i--)
#define Rep(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<(y);i++)
#define endl '\n'
#define debug(...)
#define debug1(a,i,...) cout<<i<<" "<<a[i]<<endl;
typedef long long ll;
#define fi first
#define se second
#define PII pair<int,int>
#define me(s,x) memset(s,x,sizeof s)
#define pb emplace_back

template<typename T=int>T read(){T x;cin>>x;return x;}
const int mod=998244353;
struct mint{
	int x;mint(int x=0):x(x<0?x+mod:x<mod?x:x-mod){}
	mint(ll y){y%=mod,x=y<0?y+mod:y;}
	mint& operator += (const mint &y){x=x+y.x<mod?x+y.x:x+y.x-mod;return *this;}
	mint& operator -= (const mint &y){x=x<y.x?x-y.x+mod:x-y.x;return *this;}
	mint& operator *= (const mint &y){x=1ll*x*y.x%mod;return *this;}
	friend mint operator + (mint x,const mint &y){return x+y;}
	friend mint operator - (mint x,const mint &y){return x-y;}
	friend mint operator * (mint x,const mint &y){return x*y;}
};mint Pow(mint x,ll y=mod-2){mint z(1);for(;y;y>>=1,x*=x)if(y&1)z*=x;return z;}
const int N=3e5+10;
ll a[N];
ll s[N],x[N];
unsigned long long ans;
void MAIN(){
	int n;
	cin>>n;
	For(i,1,n) cin>>a[i];
	For(i,1,n) s[i]=a[i]>a[i-1]?s[i-1]+1:1;
	foR(i,n,1) x[i]=a[i]>a[i+1]?x[i+1]+1:1;
	For(i,1,n) ans+=(s[i])*(x[i]);
	cout<<ans<<endl;
}int main(){
	int t=1;while(t--){
		MAIN();
	}
	return 0;
}
```

---

## 作者：T_TLucas_Yin (赞：0)

首先一定要注意这里的双调队列是指严格双调的队列，即整个序列中没有相邻的两个元素是相等的。

注意到一个双调序列可以拆分成一个由峰值向左延申的递增序列和一个由峰值向右延申的递减序列。

那么以一个位置为峰值，向左能延伸多长的递增序列就有多少种左端点取值，向右能延伸多长的递减序列就有多少种右端点取值，相乘即为以该位置为峰值的答案总数。

需要用到的前缀最长递增序列和后缀最长递减序列（可以看成逆向的前缀递增）都可以通过线性递推求出。详见代码。

最后把每个位置的答案累加起来即可。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000005],f1[1000005],f2[1000005];
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        if(a[i]>a[i-1]) f1[i]=f1[i-1]+1;
        else f1[i]=1;
    }
    for(int i=n;i>=1;i--){
        if(a[i]>a[i+1]) f2[i]=f2[i+1]+1;
        else f2[i]=1;
    }
    int sum=0;
    for(int i=1;i<=n;i++) sum+=f1[i]*f2[i];
    cout<<sum;
    return 0;
}
```

---


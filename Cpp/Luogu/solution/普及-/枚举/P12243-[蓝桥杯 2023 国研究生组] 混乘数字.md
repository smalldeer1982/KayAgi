# [蓝桥杯 2023 国研究生组] 混乘数字

## 题目描述

混乘数字的定义如下: 对于一个正整数 $n$，如果存在正整数 $a, b$，使得 $n = a \times b$，而且 $a$ 和 $b$ 的十进制数位中每个数字出现的次数之和与 $n$ 中对应数字出现次数相同，则称 $n$ 为混乘数字。

例如，对于正整数 $n = 126$，存在 $a = 6, b = 21$ 满足条件，因此 $126$ 是一个混乘数字。

又如，对于正整数 $n = 180225$，存在 $a = 225, b = 801$ 满足条件，因此 $180225$ 是一个混乘数字。

请你帮助计算出，$1 \sim 1000000$ (含)之间一共有多少个数字是混乘数字。

# 题解

## 作者：what_can_I_do (赞：3)

[传送门](https://www.luogu.com.cn/problem/P12243)

考虑写一份程序来求答案后输出该答案。

先枚举 $a$ 和 $b$，且保证 $a\times b$ 小于等于 $10^6$。接下来枚举 $a\times b$ 在十进制下每一位数字并开一个桶记录 $0$ 到 $9$ 出现的次数。然后枚举 $a$ 和 $b$ 在十进制下的每一位数字，枚举一位之后就将它在桶中的出现次数减一。最后判一下这个桶中 $0$ 到 $9$ 每一位所表示的出现次数是否都为 $0$，如果是就给 $a\times b$ 打上标记。然后将 $1$ 到 $10^6$ 中所有打过标记的数字个数统计一下即可。

最终求出答案为 $590$。

# CODE：
## 答案求解程序：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
bool v[1000010];
int ans=0;
int main()
{
	for(register ll a=1;a<=1e6;a++)
		for(register ll b=1;a*b<=1e6;b++)
		{
			int cnt[20]={0};
			ll t=a*b;
			while(t) cnt[t%10]++,t/=10;
			t=a;
			while(t) cnt[t%10]--,t/=10;
			t=b;
			while(t) cnt[t%10]--,t/=10;
			int f=1;
			for(register int i=0;i<=9;i++) if(cnt[i]){f=0;break;}
			if(f) v[a*b]=1;
		}
	for(register int i=1;i<=1e6;i++) ans+=v[i];
	printf("%d\n",ans);
	return 0;
}
```
## 答案输出程序：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
    puts("590");
	return 0;
}
```

---

## 作者：_Null_Ptr (赞：3)

# [蓝桥杯 2023 国研究生组] 混乘数字 题解

思路：线下算出题暴力即可，可以将枚举因数 $a$ 和 $b$，拼接得到字符串 $\texttt{ab}$。同时将 $n$ 也转换为字符串。对 $\texttt{ab}$ 和 $\texttt{n}$ 这两个字符串进行排序，若排序后的结果一致，说明 $a$ 和 $b$ 中数字出现次数之和与 $n$ 中对应数字出现次数相同，即 $n$ 是混乘数字。

下面贴上~~打表~~代码。

```python
count = 0
for n in range(1, 1000001):
    for a in range(1,int(n**0.5) + 1):
        if n % a ==0:
            b=n//a
            a_str = str(a)
            b_str = str(b)
            ab_str = a_str + b_str
            n_str = str(n)
            if sorted(ab_str) == sorted(n_str):
                count += 1
                break
print(count)

```
代码输出 $590$，直接输出即可。

---

## 作者：__xxy_free_ioi__ (赞：3)

# 题解：P12243 \[蓝桥杯 2023 国研究生组] 混乘数字

模拟。

## 解法

暴力枚举 $i$ 和 $j$，且 $i \times j \le 10^6$。然后，对 $i$，$j$，$i \times j$ 进行数位分解，最后判断一下即可。如若 $i \times j$ 已经出现且产生了贡献，直接跳过。

## 代码

```
#include <bits/stdc++.h>

using namespace std;

#define int long long

int judge(const vector<int>& a, const vector<int>& b) {
    for (int i = 0; i < 10; i++)
        if (a[i] != b[i]) return 0;
    return 1;
}

signed main() {
    int res = 0;
    vector<int> vis(1e6 + 10);
    for (int i = 1; i <= 1e6; i++) {
        for (int j = 1; i * j <= 1e6; j++) {
            int n = i * j;
            vector<int> vn(10), vij(10);
            int x = i, y = j;
            while (n) vn[n % 10]++, n /= 10;
            while (x) vij[x % 10]++, x /= 10;
            while (y) vij[y % 10]++, y /= 10;
            if (judge(vn, vij) && !vis[i * j]) res++, vis[i * j] = 1;
        }
    }
    cout << res << '\n';
    
    return 0;
}
```

---

## 作者：Yang18630303 (赞：1)

题意：正整数 $n$ 为混乘数字，当且仅当其可以分解为 $a \times b$，且 $a,b$ 的各位数字可以经过排序与 $n$ 相同。

输出 $1 \sim 1000000$ 之间一共有多少个数字是混乘数字。

显然个位数没有混乘数字，所以我们可以从两位数开始枚举。

对于一个待检测的 $n$，我们可以直接枚举其因数，利用数组统计各数字的出现次数，进而判断是否满足条件。

一道答案题，不用太考虑运行效率问题，完全地暴力即可。

```cpp
#include <iostream>
#include <cmath>
#define int long long
using namespace std;
signed main(){
	int ans=0,p,q,m[15],n[15];
	bool f;
	for(int i=10;i<=1000000;i++){
		int j=i;
		for(int k=0;k<10;k++){
			m[k]=0;
		}
		while(j>0){
			m[j%10]++;
			j/=10;
		}
		for(int k=2;k<=sqrt(i);k++){
			if(i%k!=0)continue;
			p=k;
			q=i/k;
			f=0;
			for(int l=0;l<10;l++){
				n[l]=0;
			}
			while(p>0){
				n[p%10]++;
				p/=10;
			}
			while(q>0){
				n[q%10]++;
				q/=10;
			}
			for(int l=0;l<10;l++){
				if(m[l]!=n[l])f=1;
			}
			if(!f){
				ans++;
				break;
			}
		}
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：wnqnld_llx (赞：1)

## 题目大意
对于一个正整数 $n$，如果存在正整数 $a, b$，使得 $n = a \times b$，而且 $a$ 和 $b$ 的十进制数位中每个数字出现的次数之和与 $n$ 中对应数字出现次数相同，则称 $n$ 为混乘数字。

找出 $1 \sim 1000000$ 之间一共有多少个数字是混乘数字。

## 思路
- 遍历 $1 \sim 1000000$。
- 对于每个属 $n$ 找出所有它的因数对 $(a,b)$，使得 $a\times b=n$。
- 判断 $a$ 和 $b$ 的十进制数位中每个数字出现的次数之和与 $n$ 中对应数字出现次数是否相同。
## 实现过程
首先我们要一个函数去分解出每个数字出现的次数。
```cpp
void tj1(int n){
	int n1=n;
	while(n1){
		if(cntn[n1%10]>=1) cntn[n1%10]++;//记录个数。
		else cntn[n1%10]=1;
		n1/=10;
	}
	return ;
}
```
然后我们要因数分解并判断。
```cpp
bool check(int n){
	for(int i=1;i*i<=n;i++){//因数分解。
		if(n%i==0){
			for(int i=0;i<=9;i++){
				cntn[i]=0,cntj[i]=0,cnti[i]=0;//分别表是n,j,i中每个数字出现的个数。
			} 
			int j=n/i;//i*j==n
			tj1(n);
			tj2(i);
			tj3(j);
			bool flag=1;
			for(int i=0;i<=9;i++){
				if(cntn[i]!=cnti[i]+cntj[i]){//判断出现次数是否相等。
					flag=0;
					break;
				}
			}
			if(flag) return true;
		}
	}
	return false;
}
```
最后逐个判断 $1 \sim 1000000$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int sum,cntn[10],cnti[10],cntj[10];
void tj1(int n){//分离n。
	int n1=n;
	while(n1){
		if(cntn[n1%10]>=1) cntn[n1%10]++;
		else cntn[n1%10]=1;
		n1/=10;
	}
	return ;
}
void tj2(int n){//分离a。
	int n1=n;
	while(n1){
		if(cnti[n1%10]>=1) cnti[n1%10]++;
		else cnti[n1%10]=1;
		n1/=10;
	}
	return ;
}
void tj3(int n){//分离b。
	int n1=n;
	while(n1){
		if(cntj[n1%10]>=1) cntj[n1%10]++;
		else cntj[n1%10]=1;
		n1/=10;
	}
	return ;
}
bool check(int n){
	for(int i=1;i*i<=n;i++){
		if(n%i==0){
			for(int i=0;i<=9;i++){
				cntn[i]=0,cntj[i]=0,cnti[i]=0;
			} 
			int j=n/i;
			tj1(n);
			tj2(i);
			tj3(j);
			bool flag=1;
			for(int i=0;i<=9;i++){
				if(cntn[i]!=cnti[i]+cntj[i]){
					flag=0;
					break;
				}
			}
			if(flag) return true;
		}
	}
	return false;
}
signed main(){
	//cout<<check(126); 
	
	for(int i=1;i<=1000000;i++){
		if(check(i)) sum++;
	}
	cout<<sum;
	return 0;
} 
```

## 最终答案
由于题目只要求输出一个结果，所以我们可以跑完这个程序然后记下答案输出即可。

最终答案是 590。

[记录](https://www.luogu.com.cn/record/214404703)

---

## 作者：CuteGirlGC (赞：0)

暴力的美感。

## Solution

因为是提交答案，我们不需要考虑效率。

考虑直接枚举 $x, y$，然后检查 $x \times y$ 是否为混乘数字。我们使用 `to_string` 和 `sort` 函数来直接检查两个数字排序之后是否相等。

我们可以发现跑的很快，只需要不到两分钟。

## Code

```cpp
#include <algorithm>
#include <iostream>
#include <ctime>
#include <set>

using namespace std;

set<int> ans;

void C(int x, int y) {
  int z = x * y;
  string a = to_string(x) + to_string(y), b = to_string(z);
  sort(a.begin(), a.end()), sort(b.begin(), b.end());
  (a == b) && (ans.insert(z), 0);
}

int main() {
  freopen("ans.txt", "w", stdout);
  for (int i = 1; i <= 1000000; i++) {
    // cout << i << '\n';
    for (int j = 1; i * j <= 1000000; j++) {
      C(i, j);
    }
  }
  cout << ans.size() << '\n' << clock();
  return 0;
}
```

---

## 作者：dengmuyang (赞：0)

## 思路
可以先按照题目的意思暴力去做，但是会超时。你就会发现你只用运行出来，再输出答案就行了。  
先分解 $n$，再分解 $a$ 和 $b$。把 $a$ 和 $b$ 分解的数量合起来，看一看等不等于 $n$ 的数量，假如不等于就继续，假如等于就结束第二层循环（注意，$a$ 只要循环到 $\sqrt{n}$ 就行了，因为大于 $\sqrt{n}$ 就等于 $a$ 和 $b$ 互换）。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
signed main() {
    vector<int>a(11,0);
    vector<int>b(11,0);
    int ans=0;
    for(int i=1;i<=1000000;i++){
        int i1=i;
        fill(a.begin(),a.end(),0);
        fill(b.begin(),b.end(),0);//初始化，因为是vector，所以不能用memset
        while(i1){
            a[i1%10]++;
            i1/=10;
        }
        bool flag=false;
        for(int j=1;j*j<=i;j++){
            if(i%j!=0)continue;
            int j1=j;
            while(j1){
                b[j1%10]++;
                j1/=10;
            }
            int jj=i/j;
            while(jj){
                b[jj%10]++;
                jj/=10;
            }
            if(a==b){
                flag=true;
                break;
            }
            fill(b.begin(),b.end(),0);
        }
        if(flag)ans++;
    }
    cout<<ans<<endl;
	return 0;//好习惯
}
```

---


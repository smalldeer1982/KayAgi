# [KOI 2023 Round 1] 避难所

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在二维平面上的 KOI 村庄里有 $N$ 个房屋。每个第 $i$ 个房屋的位置是 $(X_i, Y_i)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1lvrlm22.png)

第 $i$ 个房屋和第 $j$ 个房屋之间的距离是 $|X_i − X_j| + |Y_i − Y_j|$，也就是两个房屋之间的距离是 X 坐标差和 Y 坐标差的和。例如，位于 $(1, 6)$ 的房屋与位于 $(2, 4)$ 的房屋之间的距离是 $(2 - 1) + (6 - 4) = 3$。

KOI 村庄计划在发生灾难时，在 $K$ 个房屋里安装避难所，以便居民能够安全撤离。为了考虑所有居民的安全，计划选择 $K$ 个房屋作为避难所，使得每个居民到达最近避难所的距离尽可能小，其中最远的距离要尽量小。

以下是 $5$ 个房屋的位置，分别是 $(1, 5)$、$(3, 0)$、$(3, 3)$、$(6, 12)$ 和 $(8, 9)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/7l0hj66f.png)

在这个村庄里，计划安装 $2$ 个避难所。如果我们将避难所分别安装在 $(3, 0)$ 和 $(1, 5)$ 位置，剩下的 $3$ 个房屋到最近避难所的距离分别是 $3$、$11$、$12$，其中最远的距离是 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq9jb7vi.png)

但是，如果将避难所安装在 $(3, 3)$ 和 $(6, 12)$ 位置，最远的距离是 $5$，即位于 $(8, 9)$ 的房屋到 $(6, 12)$ 的距离为 $5$。

无论如何安装避难所，最远的距离无法小于 $5$，因此我们要找出最小的最大距离。

![](https://cdn.luogu.com.cn/upload/image_hosting/phkiiogm.png)

给定 KOI 村庄中房屋的位置和安装避难所的数量，要求你输出在所有可能的安装方案中，最近的避难所和房屋之间的距离的最大值最小的情况下的最大距离。

## 说明/提示

**限制条件**

- 所有输入的数值均为整数。
- $1 \leq K \leq 3$
- $K \leq N \leq 50$
- $0 \leq X_i \leq 100,000$
- $0 \leq Y_i \leq 100,000$
- 同一位置上不会有多个房屋，即 $(X_1, Y_1), (X_2, Y_2), \dots, (X_N, Y_N)$ 都是不同的。

**子问题**

1. （5 分）$N = K + 1$
2. （7 分）$K = 1$，且所有房屋的 X 坐标分别为 $X_i = i$ 且 Y 坐标为 0。
3. （10 分）$K = 1$
4. （18 分）$K = 2$
5. （35 分）$K = 3$，并且 $1 \leq i \leq N-1$ 且 $X_i < X_{i+1}$ 且所有房屋的 Y 坐标为 0，即 X 坐标按升序排列。
6. （25 分）$K = 3$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
5 2
1 5
3 0
3 3
6 12
8 9```

### 输出

```
5```

## 样例 #2

### 输入

```
4 2
0 0
0 5
5 0
5 5```

### 输出

```
5```

## 样例 #3

### 输入

```
4 1
1 0
2 0
3 0
4 0```

### 输出

```
2```

## 样例 #4

### 输入

```
2 1
20 23
5 14```

### 输出

```
24```

# 题解

## 作者：wangyang168 (赞：3)

### 思路：
这是一道很简单的枚举题。简单在它的数据范围较小，以下为题目给出的数据范围。
- $1 \leq K \leq 3$
- $K \leq N \leq 50$
- $0 \leq X_i \leq 100,000$
- $0 \leq Y_i \leq 100,000$
  
这其中最好的消息就是 $1 \leq K \leq 3$，正是因此当输入所有数据后我们可以直接定义变量 $ans$ 表示最终答案，判断 $K$ 的值，从而实行不同方案。
1. 如果 $K=1$，我们先套一个循环模拟选取庇护所的过程，里面定义一个变量代表选取这个房屋当庇护所时的最远路程，然后再用一个循环来计算每一个房屋到这个庇护所的距离，从而找出最远距离，更新 $ans$。
2. 如果 $K=2$，我们需要套两个循环，分别表示两个庇护所，注意两个庇护所不能是同一个房屋，里面定义一个变量代表选取这个房屋当庇护所时的最远路程，然后再用一个循环来计算每一个房屋到距离它最近的庇护所的距离，从而找出最远距离，更新 $ans$。
3. 如果 $K=3$，我们需要套三个循环，分别表示三个庇护所，注意不能出现多个庇护所是同一个房屋的情况，里面定义一个变量代表选取这个房屋当庇护所时的最远路程，然后再用一个循环来计算每一个房屋到距离它最近的庇护所的距离，从而找出最远距离，更新 $ans$。

当然我们可以在开头先定义一个距离函数计算两个房屋之间的距离，这对后面的计算有帮助，可以节省码量；在所有循环都结束之后，我们只需要输出 $ans$ 就能通过这道题了。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, x[55], y[55];
int dis(int i, int j) {
    return abs(x[i] - x[j]) + abs(y[i] - y[j]);//距离函数，对后面有帮助
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);//输入加速
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        cin >> x[i] >> y[i];
    int ans = 1e9;
    if (k == 1) {
        for (int i = 1; i <= n; i++) {
            int tmp = 0;
            for (int w = 1; w <= n; w++) 
                tmp = max(tmp, dis(i, w));
            ans = min(ans, tmp);
        }
    }
    else if (k == 2) {
        for (int i = 1; i <= n; i++)
            for (int j = i + 1; j <= n; j++) {
                int tmp = 0;
                for (int w = 1; w <= n; w++)
                    tmp = max(tmp, min(dis(i, w), dis(j, w)));
                ans = min(ans, tmp);
        }
    }
    else {
        for (int i = 1; i <= n; i++)
            for (int j = i + 1; j <= n; j++)
                for (int p = j + 1; p <= n; p++) {
                    int tmp = 0;
                    for (int w = 1; w <= n; w++)
                        tmp = max(tmp, min({ dis(i, w), dis(j, w),dis(p,w) }));
                    ans = min(ans, tmp);
            }
    }
    cout << ans;
}
```

---

## 作者：Ghosty_Neutrino (赞：3)

## 题意
二维平面上有 $N$ 个房屋，给出他们的坐标，并选择 $K$ 个作为避难所，使得每个房屋到最近避难所的最大距离最小。
## 分析
做题好方法：先看数据范围因为有一定概率会有惊喜。

先来看看 $K$ 的取值，$1 \le K \le 3$，实在是太小了直接上暴力保证没问题。我们可以枚举所有可能的避难所组合然后计算每种组合下的最大距离，最后取所有组合中的最小值。

布尔数组 $f$ 生成所有可能的 $K$ 个房屋的组合。初始化 $f$ 数组的前 $K$ 个元素为 $1$，其余为 $0$。使用 $\texttt{prev\_permutation}$ 函数生成所有可能的排列，确保每次生成的组合中恰好有 $K$ 个 $1$，每个 $1$ 对应的房屋索引即为当前组合下的避难所位置。

对于每个生成的组合，遍历所有房屋并计算其到最近避难所的距离：对于每个房屋 $i$，遍历所有避难所，计算房屋 $i$ 到每个避难所 $j$ 的曼哈顿距离，打擂台求最小的距离值 $minn$，更新当前组合的最大距离 $maxn$ 为所有 $minn$ 中的最大值。

最后对于每个组合计算得到的 $maxn$ 打擂台求最小的最大距离。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k;
bool f[60]={false};
struct D{
    int x,y;
}h[60];
int distance(D a,D b){//曼哈顿距离
    return abs(a.x-b.x)+abs(a.y-b.y);
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d%d",&h[i].x,&h[i].y);
    int minmaxn=INT_MAX;//初始化最小的最大距离为无穷大
    for(int i=0;i<k;i++) f[i]=true;
    do{
        int maxn=0;//计算当前组合的最大距离
        for(int i=0;i<n;i++){
            int minn=INT_MAX;
            for(int j=0;j<n;j++){//遍历所有避难所，找到最近的距离
                if(f[j]){
                    int dis=distance(h[i],h[j]);
                    minn=min(minn,dis);
                }
            }
            maxn=max(maxn,minn);
        }
        minmaxn=min(minmaxn,maxn);
    }while(prev_permutation(f,f+n));
    printf("%d",minmaxn);
    return 0;
}
```

---

## 作者：zhoujunchen (赞：2)

暴力枚举，考虑到 $1\le K\le3$，可以分类讨论 $K$ 的三种取值，例如 $K=3$，就开三层循环枚举避难所在哪些房屋，然后计算每个房屋跑到最近避难所的距离最大值，最终答案对最大值取最小（可能有点绕）。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x[55],y[55],ans=1e9;
int get(int i,int j,int k){
	int maxx=0;
	for(int idx=1;idx<=n;idx++)
		maxx=max(maxx,(min({(abs(x[i]-x[idx])+abs(y[i]-y[idx])),(abs(x[j]-x[idx])+abs(y[j]-y[idx])),(abs(x[k]-x[idx])+abs(y[k]-y[idx]))})));
	return maxx;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
    if(k==1)
    	for(int i=1;i<=n;i++)ans=min(ans,get(i,i,i));
	else if(k==2)
		for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++)ans=min(ans,get(i,j,i));
    else
		for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++)
				for(int k=j+1;k<=n;k++)ans=min(ans,get(i,j,k));
	cout<<ans;
    return 0;
}
```

---

## 作者：SatoruXia (赞：1)

这是一个典型的设施选址问题。首先观察标签，发现“枚举”。然后观察数据范围，发现 $k$ 只有三个值可以取，那直接暴力枚举就好了。  
具体操作：分三种情况考虑，即 $k=1$，$k=2$ 和 $k=3$。每次进行所有房屋位置的遍历，运用题目中的公式计算距离。然后简单地打个擂台，输出最小的最大距离即可。几乎没有技术含量，但注意循环的起点和终点别写错，要么统一从 $0$ 开始，要么统一从 $1$ 开始。
```cpp
#include <iostream>
#include <algorithm>
#include <climits>//INT_MAX要用
using namespace std;
//用结构体存储房子的坐标（二维数组和pair也可）
struct House {
    int x, y;
};
int main() {
    //读入加速
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //初始化
    int N, K;
    cin >> N >> K;
    House houses[55];//题目中N的最大值为50
    for (int i = 0; i < N; ++i) cin >> houses[i].x >> houses[i].y;
    int MINM = INT_MAX;
    //三种情况分类讨论
    if (K == 1) {
        for (int i = 0; i < N; ++i) {//统一起点
            int MAXM = 0;
            for (int j = 0; j < N; ++j) {
                int dist = abs(houses[i].x - houses[j].x) + abs(houses[i].y - houses[j].y);
                if (dist > MAXM) MAXM = dist;//打擂台
            }
            if (MAXM < MINM) MINM = MAXM;//要求最小
        }
    }
    else if (K == 2) {
        for (int i = 0; i < N; ++i) {//房子1
            for (int j = i + 1; j < N; ++j) {//房子2
                int MAXM = 0;
                for (int k = 0; k < N; ++k) {
                    int dist1 = abs(houses[i].x - houses[k].x) + abs(houses[i].y - houses[k].y);
                    int dist2 = abs(houses[j].x - houses[k].x) + abs(houses[j].y - houses[k].y);
                    int min_dist = min(dist1, dist2);
                    if (min_dist > MAXM) MAXM = min_dist;//同上
                }
                if (MAXM < MINM) MINM = MAXM;
            }
        }
    }
    else if (K == 3) {
        for (int i = 0; i < N; ++i) {//房子1
            for (int j = i + 1; j < N; ++j) {//房子2
                for (int l = j + 1; l < N; ++l) {//房子3
                    int MAXM = 0;
                    for (int k = 0; k < N; ++k) {
                        int dist1 = abs(houses[i].x - houses[k].x) + abs(houses[i].y - houses[k].y);
                        int dist2 = abs(houses[j].x - houses[k].x) + abs(houses[j].y - houses[k].y);
                        int dist3 = abs(houses[l].x - houses[k].x) + abs(houses[l].y - houses[k].y);
                        int min_dist = min({ dist1, dist2, dist3 });//多个数的写法
                        if (min_dist > MAXM) MAXM = min_dist;
                    }
                    if (MAXM < MINM) MINM = MAXM;
                }
            }
        }
    }
    //输出
    cout << MINM << endl;
    return 0;
}
```
顺带提一句：如果数据范围使本题无法写暴力，可以使用二分。

---

## 作者：lcfollower (赞：1)

观察到题目的数据范围：$1\le n\le 50$，$1\le k\le 3$。

于是按一下计算器，发现 $C_{50}^3 = 19600$，非常小！

于是我们暴力枚举避难所是哪 $k$ 所，然后按照题意模拟求答案即可。

求答案是 $\mathcal O(nk)$ 的，总时间复杂度约为 $\mathcal O(C_{n}^{k}nk)$，足以通过。

代码：

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e14

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

constexpr int N = 55;
int n ,k ,p[N] ,res = inf;
struct point {int x ,y;}a[N];

inline int dis (point x ,point y) {return abs (x.x - y.x) + abs (x.y - y.y);}
inline void dfs (int x ,int y){
  if (x == k + 1) {
    int ans = 0;
    up (i ,1 ,n){
      int mn = inf;
      up (j ,1 ,k) mn = min (mn ,dis (a[i] ,a[p[j]]));
      ans = max (ans ,mn);
    }
    res = min (res ,ans);//模拟。
    return ;
  } up (i ,y + 1 ,n){
    p[x] = i ;//暴力搜索这 k 个避难所。
    dfs (x + 1 ,i);
    p[x] = 0 ;
  }
} signed main (){
  n = read () ,k = read ();
  up (i ,1 ,n) a[i].x = read () ,a[i].y = read ();
  dfs (1 ,0);
  writeln (res);
  return 0 ;
}
```

---

## 作者：lzx111218 (赞：0)

# P12655 [KOI 2023 Round 1] 避难所
[题目传送门](https://www.luogu.com.cn/problem/P12655https://www.luogu.com.cn/problem/P12655)
## 思路
我们需要在二维平面上的 $N$ 个房屋中选择 $K$ 个作为避难所，使得所有房屋到最近避难所的距离的最大值尽可能小。这题其实就是个组合优化问题。

通过 `next_permutation` 生成所有可能的 $K$ 就不用手写函数了。[不知道的戳我。](https://blog.csdn.net/weixin_52115456/article/details/127626074?ops_request_misc=%257B%2522request%255Fid%2522%253A%252252a469f987fddb405ce6a39c47ee8336%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=52a469f987fddb405ce6a39c47ee8336&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-127626074-null-null.nonecase&utm_term=next_permutation%20&spm=1018.2226.3001.4450)

满足特定条件的基因的数量条件包括：
1.  **不相交：** $0 \leq a \leq b < c \leq d < n$。这意味着第一个基因在第二个基因的左边，并且两者之间没有重叠。
2.  **相同长度：** $b - a + 1 = d - c + 1$。
3.  **每个位置恰好相反：** 对于所有 $k$ 使得 $0 \leq k \leq b - a$，有 $s_{a+k} 
eq s_{c+k}$。这意味着如果 $s_{a+k}$ 是 $0$，则 $s_{c+k}$ 必须是 $1$，反之亦然。

剩下的都比较简单，直接模拟即可。

总时间复杂度：
- 当 $K=1$ 时：$O (N^2)$。
- 当 $K=2$ 时：$O (N^3)$。
- 当 $K=3$ 时：$O (N^4)$。

总空间复杂度为 $O(n)$。
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct P {
  int x, y;
};
int main() {
    int n, k;
    cin >> n >> k;
    vector<P> h(n);
    for (int i = 0; i < n; ++i) cin >> h[i].x >> h[i].y;
    int m = INT_MAX;
    vector<bool> mask(n);
    fill(mask.begin(), mask.begin() + k, true);
    do {
        vector<P> s;
        for (int i = 0; i < n; ++i) if (mask[i]) s.push_back(h[i]);
        int c = 0;
        for (auto house : h) {
            int d = INT_MAX;
            for (auto shelter : s) {
                int dist = abs(house.x - shelter.x) + abs(house.y - shelter.y);
                if (dist < d) d = dist;
            }
            if (d > c) c = d;
        }
        if (c < m) m = c;
    } while (prev_permutation(mask.begin(), mask.end()));
    cout << m;
    return 0;
}
```

---

## 作者：LG086 (赞：0)

$n$ 个房子，$k$ 个避难所，求每个房子到最近的避难所的距离的最大值，最小是多少。注意到 $1\le k \le 3$ 同时 $1 \le n \le 50$，暴力解决就行了。

我们设 $k_1,k_2,k_3$ 分别是三个避难所所在房子的编号。计算房子间距离，房子 $p$ 和房子 $q$ 间的距离就是 $(|x_p-x_q|+|y_p-y_q|)$。所以计算距离的函数如下：

```cpp
ll dis(ll p,ll q){
 return abs(x[p]-x[q])+abs(y[p]-y[q]);
}
```



接下来分类讨论。  
当 $k=1$，避难所可以是 $1$ 到 $n$ 的每个房子，所以双重循环，最内层循环枚举每个房子编号，求出 $cnt=\max\{dis(i,k_1)\}$，然后 $ans\leftarrow \max(ans,cnt)$。外层枚举每个 $k_1$。  
当 $k=2$，三重循环，最内层还是循环枚举每个房子编号，求出 $cnt=\max\{\min(dis(i,k_1),dis(i,k_2))\}$，然后 $ans\leftarrow \max(ans,cnt)$。最外两层循环枚举每个 $k_1$ 和 $k_2$。  
当 $k=3$，四重循环，求出 $cnt=\max\{\min(dis(i,k_1),dis(i,k_2),dis(i,k_3))\}$，然后 $ans\leftarrow \max(ans,cnt)$。外层枚举 $k_1,k_2,k_3$。

这样就做完了。  
下面给出核心代码。

```cpp
if(k==1){
 for(int k1 = 1;k1 <= n;k1 ++){
  ll cnt = 0;
  for(int i = 1;i <= n;i ++)
   cnt = max(cnt,dis(i,k1));
  ans=min(ans,cnt);
 }
}else if(k==2){
 for(int k1 = 1;k1 <= n;k1 ++)
  for(int k2 = k1+1;k2 <= n;k2 ++){
   ll cnt = 0;
   for(int i = 1;i <= n;i ++)
    cnt = max(cnt,min({dis(i,k1),dis(i,k2)}));
   ans=min(ans,cnt);
  }
}else{
 for(int k1 = 1;k1 <= n;k1 ++)
  for(int k2 = k1+1;k2 <= n;k2 ++)
   for(int k3 = k2+1;k3 <= n;k3 ++){
    ll cnt = 0;
    for(int i = 1;i <= n;i ++)
     cnt = max(cnt,min({dis(i,k1),dis(i,k2),dis(i,k3)}));
    ans=min(ans,cnt);
   }
}
```

---


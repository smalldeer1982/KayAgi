# 【MX-X13-T2】「KDOI-12」不要去思考未来，把这留给未来的你。

## 题目背景

未来的你在打一场模拟赛。

## 题目描述

模拟赛中共有 $T$ 道题，每道题有 $n$ 个子任务和 $m$ 个特殊性质。每个子任务均满足 $m$ 个特殊性质的一个子集。

定义一组子任务依赖 $(i,j)$ 表示子任务 $j$ 依赖子任务 $i$，也就是只有通过了子任务 $i$ 才能通过子任务 $j$。

考虑到模拟赛有懒惰的出题人和愚蠢的在线法官，子任务依赖的条数必然是越少越好。现在你想知道最少配置多少组子任务依赖才能保证：

* 不存在一对子任务 $x,y$ 使得满足子任务 $y$ 的数据必然满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**仍然有可能**通过子任务 $y$；
* 不存在一对子任务 $x,y$ 使得存在满足子任务 $y$ 的数据**不**满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**无法**通过子任务 $y$。

形式化地讲，设第 $i$ 个子任务的特殊性质集合为 $S_i$，那么你要选择尽可能少的 $(u_x,v_x)$ 二元组使得：

* 对于任意 $(i,j)$ 满足 $S_i\subseteq S_j$，均存在 $j=p_1,p_2,\dots,p_M=i$ 使得对于任意 $1\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$；
* 对于任意 $(i,j)$ **不**满足 $S_i\subseteq S_j$，均**不**存在 $j=p_1,p_2,\dots,p_M=i$ 使得对于任意 $1\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$。

并求出选择二元组数量的最小值。

## 说明/提示

**【样例解释】**

对于第二道题目：不妨设四个特殊性质分别为 $\text{ABCD}$，那么五个子任务分别符合特殊性质 $\{\text{ABC}\}$、$\{\text{AB}\}$、$\{\text{A}\}$、$\{\text{D}\}$、和 $\varnothing$。可以证明，配置以下子任务依赖符合要求且最优：

* $(1,2)$；
* $(2,3)$；
* $(3,5)$；
* $(4,5)$。

**【数据范围】**

| 测试点编号 | $n,m\leq$ | 特殊性质 |
|:--:|:--:|:--:|
| $1\sim2$ | $2$ | 无 |
| $3\sim9$ | $5$ | 无 |
| $10\sim13$ | $10$ | 无 |
| $14\sim20$ | $16$ | A |
| $21\sim25$ | $16$ | 无 |

* 特殊性质 A：保证每个子任务最多满足两个特殊性质。

对于所有数据：$1\leq T\leq 6$，$1\leq n,m\leq16$，输入的字符串由 `0` 和 `1` 组成，保证不存在两个子任务满足的特殊性质相同。

## 样例 #1

### 输入

```
3
4 2
00
01
10
11
5 4
1110
1100
1000
0001
0000
7 4
0101
1101
1001
0010
1110
0100
1000```

### 输出

```
4
4
7```

# 题解

## 作者：chenzefan (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P13007)
## 前言
哪有那么难的——橙题？？

害！没有题解！不知道思路！

于是我瞪呀瞪，瞪出了二进制思路。

就这样，此题第一篇题解诞生了。

希望能帮到同样经历的你……
## 思路
先引用题目的重点：
> * 不存在一对子任务 $x,y$ 使得满足子任务 $y$ 的数据必然满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**仍然有可能**通过子任务 $y$；
> * 不存在一对子任务 $x,y$ 使得存在满足子任务 $y$ 的数据不满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**无法**通过子任务 $y$。

为啥说这玩意重要呢？因为它是保证条件：
> 现在你想知道最少配置多少组子任务依赖才能保证

于是，对比形式化的讲法：
> * 对于任意 $(i,j)$ 满足 $S_i\subseteq S_j$，均存在 $j=p_1,p_2,\dots,p_M=i$ 使得对于任意 $1\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$；
> * 对于任意 $(i,j)$ **不**满足 $S_i\subseteq S_j$，均**不**存在 $j=p_1,p_2,\dots,p_M=i$ 使得对于任意 $1\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$。

不难发现，这题是有关二进制内 $1$ 的个数的题。

瞅一眼数据范围：$1\le T\le 6$，$1\le n,m\le16$，于是，$O(T \times n^3)$ 暴力走起！

样例应该不难懂，开始讲我的思路。

首先将输入的 `01` 串转成十进制整数保存在数组里。第 $i$ 个字符串我保存在了 $a_i$ 里。

因为要想判断 $i$ 是否依赖于 $j$ 就是在看 $i$ 转成二进制中的 $1$ 的位置在 $j$ 的二进制数中是否是 $1$，理解成位运算就是看 $i$ 位与 $j$ 是否就是 $j$，就简化成了判断 $a_i \& a_j=a_j$。

通过形式化的讲法，知道要引进第三元 $k$。判断方法同上。

于是可以敲代码了，我给一下我的 AC 代码。
## 代码（含注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25; 
int t,n,m,a[N];
int main(){
	scanf("%d",&t);
	while(t--){//t 道题目 
		scanf("%d%d",&n,&m);
		memset(a,0,sizeof(a));
		for(int i=1;i<=n;i++){
			string s;cin>>s;
			for(int j=0;j<s.size();j++) if(s[j]=='1') a[i]+=pow(2,j);//算二进制，后面会用 
		}int ans=0; 
		for(int i=1;i<=n;i++)//枚举 
			for(int j=1;j<=n;j++)
				if(i!=j&&(a[i]&a[j])==a[i]){//判断 j 是否属于 i （二进制位与） 
					bool f=0;
					for(int k=1;k<=n;k++)
						if(i!=k&&j!=k&&(a[i]&a[k])==a[i]&&(a[k]&a[j])==a[k]){f=1;break;}//同上 
					if(!f) ans++;
				}
		printf("%d\n",ans);
	} 
	return 0;
}

```
撒花！

~~切橙题不容易啊！~~

---

## 作者：Ghosty_Neutrino (赞：3)

## 题意
我们要为模拟赛的子任务配置最少的依赖关系，使得：
* 若子任务 $i$ 的性质集合是子任务 $j$ 的子集，则 $j$ 到 $i$ 必须存在依赖路径。
* 若子任务 $i$ 的性质集合不是子任务 $j$ 的子集，则 $j$ 到 $i$ 不能存在依赖路径。
* 输出子任务依赖数量的最小值。
## 分析
这是一个求集合包含关系的哈斯图边数的问题。哈斯图是偏序集的最小边表示，仅包含直接覆盖关系的边，去掉了所有可通过传递得到的边。

将每个子任务的字符串转换为整数，便于位运算判断集合包含关系。

对于每个子任务 $j$，找到所有子任务 $i$，满足：
*  $i$ 的性质集合是 $j$ 的真子集。
* 不存在中间子任务 $k$，使得 $i$ 的性质集合是 $k$ 的真子集且 $k$ 的性质集合是 $j$ 的真子集。
* 所有这样的 $(i,j)$ 对即为哈斯图中的边，统计其数量。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,m,sets[20];
string s;
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&m);
        // 将01串转换为整数表示的集合
        for(int i=0;i<n;i++){
            cin>>s;
            int num=0;
            for (int j=0;j<m;j++){
                if(s[j]=='1'){
                    num|=1<<j; // 第j位对应2^j，s[0]是最低位
                }
            }
            sets[i]=num;
        }
        int ans=0;
        // 遍历每个子任务j
        for(int j=0;j<n;j++){
            int sj=sets[j];
            // 遍历所有可能的前驱i
            for(int i=0;i<n;i++){
                if(i==j) continue; // 跳过自身
                int si=sets[i];
                // 检查si是否是sj的真子集
                if((si&sj)!=si||si==sj) continue;
                // 检查是否存在中间集合sk
                bool mid=false;
                for(int k=0;k<n;k++){
                    if(k==i||k==j) continue; // 跳过i和j
                    int sk=sets[k];
                    // sk必须是si的真超集且是sj的真子集
                    if((si&sk)==si&&(sk&sj)==sk&&si!=sk&&sk!=sj){
                        mid=true;
                        break;
                    }
                }
                // 无中间集合时，si是sj的直接前驱
                if(!mid) ans++;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：swate114514 (赞：3)

给定一组子任务，每个子任务有一个特殊性质的集合，要求构建一个依赖关系图，使得：
1. 对于任意两个子任务 $i$ 和 $j$，如果 $i$ 的性质集合是 $j$ 的子集（即 $S_i \subseteq S_j$），那么在依赖关系图中必须存在一条从 $j$ 到 $i$ 的路径。
2. 对于任意两个子任务 $i$ 和 $j$，如果 $i$ 的性质集合不是 $j$ 的子集（即 $S_i \not\subseteq S_j$），那么在依赖关系图中不能存在从 $j$ 到 $i$ 的路径。

我们的目标是找到满足上述条件的最少依赖边数。

---
这个问题可以转化为构建一个**传递闭包**的最小边集问题。

首先，我们需要根据子任务的性质集合建立一个偏序关系。对于任意两个子任务 $i$ 和 $j$，如果 $S_i \subseteq S_j$，那么我们说 $j$ 可以到达 $i$（即 $j \geq i$）。

在偏序关系中，Hasse 图是一个有向无环图（DAG），其中边 $(u, v)$ 表示 $u$ 直接覆盖 $v$（即 $u > v$，且不存在 $w$ 使得 $u > w > v$）。Hasse 图的边数是最少的，同时能够保持偏序关系的传递闭包。

Hasse 图的边数就是我们要求的最小依赖边数。

### Code
```cpp
#include <bits/stdc++.h>
#define qwq(i,a,b) for(int i=(a);i<=(b);++i)
#define qaq(i,a,b) for(int i=(a);i>=(b);--i)

using namespace std;

using un = unsigned;

const int N = 20;

bool c[N][N];

int main() 
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int T;
	cin >> T;
	while (T--) {
		int n, m;
		cin >> n >> m;
		vector<un> s(n);
		qwq(i, 0, n - 1) {
			string str;
			cin >> str;
			un mask = 0;
			for (char c : str) {
				mask = (mask << 1) | (c - '0');
			}
			s[i] = mask;
		}

		qwq(i, 0, n - 1) {
			qwq(j, 0, n - 1) {
				c[i][j] = (s[i] & s[j]) == s[i];
			}
		}

		int e = 0;
		qwq(i, 0, n - 1) {
			qwq(j, 0, n - 1) {
				if (i == j) continue;
				if (c[i][j]) {
					bool f = false;
					qwq(k, 0, n - 1) {
						if (k != i && k != j && c[i][k] && c[k][j]) {
							f = true;
							break;
						}
					}
					if (!f) {
						e++;
					}
				}
			}
		}

		cout << e << '\n';
	}
}
```

---

## 作者：ZZ_junning (赞：1)

## 题目大意

由于本题的题目太过抽象，我简单概括一下。

给你 $ n $ 个点,每个点是一串二进制,第 $ i $ 个二进制表示为 $ s_i $,对于每个 $ ( i , j ) $ 分为两种情况。

### test 1

$ s_i $ 是 $ s_j $ 的子串，则一定有一条 $ j $ 到 $ i $ 的路径。

### test 2

$ s_i $ 不是 $ s_j $ 的子串，则一定不存在一条 $ j $ 到 $ i $ 的路径。

## 思路

看做一道简单的建图最少边问题。

1.先把输入的字符串转换成二进制，可以用数组也可以用 ` bitset `。

2.再通过循环判断 $ n $ 个二进制之间是否有子串关系，有就标记一下,这里要注意不是建立双向的，而是单向的，详情看代码。

3.开始判断有哪些路径不需要，也就是可以由其他路径拼接而来，输出即可。

## Code

本人马蜂比较丑，因为是比赛时打的。

```cpp
#pragma G++ optimize(3,"Ofast","inline")
#include <bits/stdc++.h>
#define int long long
#define mid (l+r>>1)
#define lson (u<<1)
#define rson (u<<1|1)
#define eb emplace_back
#define pii pair<int,int>
#define lowbit(x) ((x)&(-(x)))
#define swap(x,y) (x)^=(y)^=(x)^=(y)
using namespace std;
inline void out(int k){if(k<0)putchar('-'),k=-k;if(k<10)putchar(k+'0');else out(k/10),putchar(k%10+'0');}
inline int read(){int x=0,f=1;char ch=getchar();while(ch>57||ch<48){if(ch==45)f=-1;ch=getchar();}while(ch>=48&&ch<=57){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
bitset<20> s[20];
int T,n,m;
bool sub[20][20];
signed main(){
    T=read();
	while(T--){
		n=read(),m=read();
		memset(sub,0,sizeof(sub));//初始化!!!
		for(int i=1;i<=n;++i){
			s[i]=0;
			for(int j=0;j<m;++j){
				char ch;
				cin>>ch;
				if(ch=='1')s[i].set(j);
			}
		}
		int ans=0;
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				if(i==j)continue;
				if((s[i]&s[j])==s[i]){
					sub[i][j]=true;//单向
				}
			}
		}
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				if(i==j||!sub[i][j])continue;
				bool is_lj=true;
				for(int k=1;k<=n;++k){
					if(sub[i][k]&&sub[k][j]&&i!=k&&j!=k){
						is_lj=false;
						break;
					}//是否可以有其他路径拼接而成
				}
				if(is_lj)++ans;//是必须建边的路径
			}
		}
		printf("%lld\n",ans);
	}	
	return 0;
}
```

给个赞吧 QwQ ，比赛的时候只对了前两题。

---

## 作者：__CJY__ (赞：1)

## 思路
将每个子任务的性质集合视为一个元素，这些元素构成一个偏序集，其中偏序关系是集合的包含关系。我们需要构建一个图，使得图中的边能够反映这个偏序关系。

在偏序集中，如果 $S_i \subseteq S_j$，并且不存在另一个 $S_k$ 使得 $S_i \subseteq S_k \subseteq S_j$，那么 $S_j$ 直接覆盖 $S_i$。

我们需要为所有直接覆盖关系添加边 $(j,i)$，这样就能保证所有子集关系可以通过路径表达，而非子集关系则没有路径。

根据偏序集的性质，最小边数等于覆盖关系的数量。

---
我们可以使用 `bitset` 来存储每个子任务的性质集合，这样方便比较集合的包含关系。

对于每对子任务 $(i,j)$，检查 $S_i$ 是否是 $S_j$ 的子集：
* 如果是，进一步检查是否存在中间子任务 $k$ 使得 $S_i \subseteq S_k \subseteq S_j$。
* 如果没有这样的 $k$，则 $(j,i)$ 是一个直接覆盖关系，需要添加这条边。

接下来统计所有直接覆盖关系的边数，即为答案。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;cin>>T;
	while(T--){
		int n,m;cin>>n>>m;
		vector<bitset<16>>a;
		for(int i=0;i<n;i++){
			string s;cin>>s;
			bitset<16>t;
			for(int j=0;j<m;j++){
				if(s[j]=='1') t.set(j);
			}
			a.push_back(t);
		}
		vector<pair<int,int>>e;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				if(i==j) continue;
				if((a[i]&a[j])==a[i]){
					bool f=1;
					for(int k=0;k<n;k++){
						if(k==i||k==j) continue;
						if((a[i]&a[k])==a[i]&&(a[k]&a[j])==a[k]){f=false;break;}
					}
					if(f) e.push_back({j,i});
				}
			}
		}
		cout<<e.size()<<'\n';
	}
}
```

---

## 作者：Lacuna (赞：0)

### 前言：

个人感觉不止橙。

### 题意：

题意看的头大，实际上就是把每个子任务的特殊性质看成集合 $s_i$。当 $s_j$ 是 $s_i$ 的子集时，则要满足通过 $j$ 之前要先通过 $i$。

否则，要满足通过 $j$ 之前不需要要先通过 $i$。

我们要删掉一些关系，使得满足上面的性质，求出剩余的最少的关系数。

### 思路：

首先拿一个邻接矩阵存边，若两个集合之间存在 $i$ 是 $j$ 的子集的情况，则从 $i$ 向 $j$ 连边表示这个关系。

接下来你得会[这个东西](https://www.luogu.com.cn/problem/B3611)，我们对这个图跑一遍，将所有满足可达关系的两个节点都连一条边。紧接着枚举看一下有哪些边是没必要的，即删去后传递闭包不变。例如一条边 $i \to j$，若中间有一个中间节点 $k$，满足 $i \to k \to j$，则 $i \to j$ 就不是必要的边，我们可以通过另外一个点间接到达，如果没有这个节点则 $i \to j$ 是必要边。

最后看一下有多少条边是必要的就行。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pb push_back
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
int T,n,m,cnt;
char s[25][25];
bool e[25][25],w[25][25];
bool check(int x,int y){
	bool flag=0;
	for(int i=1;i<=m;i++){
	  if(s[x][i]=='1'&&s[y][i]=='0') return false;
	  if(s[x][i]=='0'&&s[y][i]=='1') flag=1;
	}
	return flag;
}
int main(){
	scanf("%d",&T);
	while(T--){
	  scanf("%d%d",&n,&m);
	  for(int i=1;i<=n;i++)
	    scanf("%s",s[i]+1);
	  for(int i=1;i<=n;i++)
	  	for(int j=1;j<=n;j++){
		  if(i!=j&&check(i,j)) e[i][j]=1;
        }
	  for(int k=1;k<=n;k++)
	    for(int i=1;i<=n;i++)
	      for(int j=1;j<=n;j++){
	        e[i][j]=e[i][j]||(e[i][k]&&e[k][j]);
	      }
	  for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++){
	      if(!e[i][j]||i==j) continue;
          bool flag=0;
	      for(int k=1;k<=n;k++){
            if(k==i||k==j) continue;
	      	if(e[i][k]&&e[k][j]){flag=true; break;}
		  }
		  if(!flag) w[i][j]=true;
	    }
	  for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++){
	      if(i!=j&&w[i][j]) cnt++;
	    }
	  printf("%d\n",cnt);
	  cnt=0;
	  memset(e,0,sizeof e);
      memset(w,0,sizeof w);
	}
    return 0;
}
```

---

## 作者：jiangyunuo (赞：0)

### 题目意思：
这个题目我也是花了好久才理解，这边用一种我自己的话来概括一下：  
对于一道题目，有 $n$ 个子任务和 $m$ 个特殊性质（这个自己尝试[出题](https://www.luogu.com.cn/problem/new?type=U)就可以知道），我们要保证，若第 $y$ 个子任务满足的所有特殊性质包含了第 $x$ 个子任务满足的所有特殊性质，那么必须保证只有通过第 $x$ 个子任务才可以通过第 $y$ 个子任务。  
### 大体思路：
如果第 $x$ 个子任务和第 $y$ 个子任务满足前面说的关系，那么，就需要子任务依赖帮忙，可是，题目需要的是子任务依赖数量最少的情况，说明，肯定不是所有满足以上条件的子任务都需要子任务依赖。  
我们不难想到，如果第 $y$ 个子任务依赖于第 $x$ 个子任务，而第 $z$ 个子任务依赖于第 $y$ 个子任务，那么就相当于第 $z$ 个子任务依赖于第 $x$ 个子任务。这里有三组依赖关系，但实际只是用了两个子任务依赖，而这也就可以解释样例中第二组数据为什么只需要 $4$ 个子任务依赖。  
我们要使用子任务依赖，就要满足两个条件：

1. 即题目意思中的条件。
2. 要使用子任务依赖的两道题中的任何一个题目所依赖的任何一个题目都不依赖于要使用子任务依赖的另一个题目。

对于第一个条件，我们可以写个函数判断，我不多说，具体见代码。  
对于第二个条件，我们为了方便，可以使用结构体，记录每个子任务满足的特殊条件的数量，接着进行结构体排序，按照满足的特殊条件数量从小到大排序（毕竟满足特殊性质数量多的子任务满足的特殊性质才可能包含了满足特殊性质数量少的子任务满足的特殊性质）。接着，我们可以利用一个 `bool` 型的二维数组 $z$ 来表示两个子任务是否有依赖关系，如 $z_{i,j}=1$ 表示第 $j$ 个子任务依赖于第 $i$ 个子任务，这样，数组 $z$ 可以判断条件二是否成立。值得注意的是，如果第 $i$ 个子任务与第 $j$ 个子任务满足上述两个条件，不仅 $z_{i,j}=1$，如果子任务 $k$ 也依赖子任务 $j$，则 $z_{i,k}=1$。**注意事项**：循环判断子任务 $i$ 和 $j$ 时候（判断的是子任务 $j$ 时候要使用子任务依赖保证 $j$ 依赖于 $i$）满足条件时，$j$ 一定是从 $i-1$ 的值开始的，一直判断到 $1$。如果 $j$ 大于 $i-1$，那么 $j$ 满足的特殊性质的数量就大于或等于子任务 $i$ 满足的特殊性质的数量，肯定不行。而从 $i-1$ 判断到 $1$ 则是因为 $j$ 从大开始就可以提前把那些依赖于子任务 $j$ 的子任务给找出来，并记录在数组 $z$ 中，从而在判断到这些子任务时不用再来一次子任务依赖。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;     //n 和 m 见题目，ans 记录答案。
struct node{
    string ch;    //记录每个子任务满足特殊情况的状况。
    int top;    //记录每个子任务满足特殊情况的数量。
}a[20];
bool z[20][20];
bool cmp(node x,node y){
    return x.top<y.top;
}
bool pd(int x,int y){
    for(int i=0;i<m;i++){
        if(a[x].ch[i]=='0'&&a[y].ch[i]=='1')return 0;
    }
    return 1;
}
int main(){
    int t;
    cin>>t;
    while(t){
        t--;
        cin>>n>>m;
        ans=0;
        for(int i=1;i<=n;i++){
            cin>>a[i].ch;
            a[i].top=0;
            for(int j=0;j<m;j++){
                if(a[i].ch[j]=='1')a[i].top++;
            }
        }
        sort(a+1,a+n+1,cmp);   //结构体排序。
        for(int i=1;i<=n;i++){
            for(int j=i-1;j>=1;j--){
                if(pd(i,j)&&z[i][j]==0){   //函数判断是否满足条件一，z 数组判断是否满足条件二
                    ans++;
                    z[i][j]=1;
                    for(int k=1;k<j;k++){
                        if(z[j][k])z[i][k]=1;
                    }    //补充依赖关系，具体见前文中的大体思路。
                }
            }
        }
        cout<<ans<<endl;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                z[i][j]=0;
            }
        }
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/221914726)

---

## 作者：lw393 (赞：0)

一道图论建模题，但是我题解中给出的做法很不像一道签到题的做法。

考虑什么情况下可以连出一条从 $u$ 到 $v$ 的边？题目给的很清晰：在 $S_v \subseteq S_u$ 时。

由于题目要求最小的边的数量，我们设全部满足上述条件的边组成的集合为 $E$，我们需要去除一些可以删去的边。经过样例的提示，我们发现具有这样条件的边可以被删除：在 $(u, v)\in E,(v, w) \in E,(u,w)\in E$，则可以删去 $(u, w)$ 的这条边而不影响边集依旧符合题目所需要的情况。

于是就可以写出代码（为了方便明晰集合间的包含关系，用位运算来表示）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20;

string c[N];
bitset<N>a[N];
vector<int>G[N], G_rev[N];
pair<int, int> num_id[N];
bool flag[N];
#define pb push_back

void solve(){
  int n, m; cin >> n >> m; memset(flag, 0, sizeof(flag));
  for(int i = 1; i <= n; i++){
    G[i].clear(); a[i].reset(), G_rev[i].clear();
    cin >> c[i]; for(int j = 1; j <= m; j++) a[i][j] = (c[i][j - 1] - '0');
  }
  for(int i = 1; i <= n; i++){
    for(int j = 1; j <= n; j++){
      if(i == j) continue;
      if((a[i] & a[j]) == a[i]) { G[j].pb(i); G_rev[i].pb(j); }
    }
  }
  for(int i = 1; i <= n; i++) num_id[i] = {a[i].count(), i};
  sort(num_id + 1, num_id + 1 + n); vector<set<int> >vv(n + 1);
  int ans = 0;
  for(int i = 1; i <= n; i++){
    for(auto v : G[i]){
      vv[v].insert(i); ans++;
    }
  }
  for(int to = 1; to <= n; to++){
    map<int, int>mm;
    for(auto v : vv[to]){
      for(auto u : G_rev[v]){
        if(vv[to].find(u) != vv[to].end()) ans -= (mm[u] ^ 1), mm[u] = 1;
      }
    }
  }
  cout << ans << '\n';
}

int main(){
  int t = 1;
  cin >> t;
  while(t--){
    solve();
  }
  return 0;
}
```

时间复杂度的话由于 $n,m$ 同阶，最劣情况是 $O(n ^ 3 \log n)$ 的，那个 $\log$ 是 set 带来的，而且参考代码中的常数较大。

---


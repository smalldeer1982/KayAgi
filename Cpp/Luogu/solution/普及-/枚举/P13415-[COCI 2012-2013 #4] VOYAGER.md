# [COCI 2012/2013 #4] VOYAGER

## 题目描述

旅行者一号（Voyager 1）探测器（不要与 Intrepid 级星舰混淆）早在 1977 年就被发射升空，如今正接近离开我们的太阳系。在它不断穿梭于太空的旅途中，它被编程为在遇到的每一个恒星系统中留下无线电信号标记，以尽可能长时间地标记探测器的轨迹。

我们假设一个恒星系统可以用一个 $N$ 行 $M$ 列的矩形网格表示，将空间划分为 $N \times M$ 个相等的格子。每个格子可以包含一个行星、黑洞，或者为空。探测器会从一个预定的空格子中，以某个轴对齐的方向（"U"-上，"R"-右，"D"-下，"L"-左）发出信号。

信号发射后，会沿当前行/列的直线方向传播，直到遇到行星，此时信号会被偏转 $90$ 度，转向另一个方向。有两种类型的行星，分别用 "/" 和 "\\" 表示。偏转规则如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zoyosa0s.png)

当信号进入黑洞格子，或离开矩形网格边界时，信号会永久离开该系统。已知信号从当前格子传播到相邻格子需要 $1$ 秒。

请编写程序，确定探测器应以哪个方向发射信号，才能使信号在系统中停留的时间最长，并输出最佳方向以及最长停留时间。如果信号可以在系统内无限循环，请输出 "Voyager" 替代时间。


## 说明/提示

在价值至少 50% 分数的测试数据中，信号不可能在系统内无限循环。

第一个样例的说明（"*" 表示信号的路径）：

![](https://cdn.luogu.com.cn/upload/image_hosting/5b6kat2r.png)

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
5 5
../.\
.....
.C...
...C.
\.../
3 3 ```

### 输出

```
U
17```

## 样例 #2

### 输入

```
5 5
....\
\..\.
./\..
\../C
.\../
1 1```

### 输出

```
D
12```

## 样例 #3

### 输入

```
5 7
/.....\
../..\.
\...../
/.....\
\.\.../
3 3 ```

### 输出

```
R
Voyager```

# 题解

## 作者：wenqinghua1001 (赞：3)

## 前言

本题类似于 [CSP-J 2024 T2](https://www.luogu.com.cn/problem/P11228)。

[题目传送门](https://www.luogu.com.cn/problem/P13415)

## 思路

看到这题，首先想到的是暴力，没错！就是暴力。

暴力大家都会，但途中一定有两个问题。

第一个问题，就是如何判断信号是否可以在系统内无限循环。很好解决，只需判断在同一个点是否有一次以上**向相同的方向**发出信号。对于样例三，很明显，在第 $16$ 次遍历，信号在第 $3$ 行第 $3$ 列，出现了两次在同一个点向相同的方向发出信号，所以输出 `Voyager`。

第二个问题，输入的字符有 `\`，在编译的时候会报错。也好解决，在输入的时候把这个字符换成其它字符就行了。

首先，输入，我是将 `\` 改成了 `%`。

```cpp
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		string x;
		cin>>x;
		for(int j=1;j<=m;j++){
			a[i][j]=x[j-1];
			if(int(x[j-1])==92) // 92 = int('\')
				a[i][j]='%';
		}
	} 
	int x,y;
	cin>>x>>y;
```

接着进行递归，用 $g$ 数组来存储在同一个点是否有一次以上向相同的方向发出信号，记得清空。

```cpp
	memset(g,0,sizeof(g));
	int U=dfs(x,y,1);
	memset(g,0,sizeof(g));
	int R=dfs(x,y,2);
	memset(g,0,sizeof(g));
	int D=dfs(x,y,3);
	memset(g,0,sizeof(g));
	int L=dfs(x,y,4);
```

然后输出，注意优先级，这就是主函数，$op$ 在 DFS 中解释。

```cpp
	int ans=max(max(U,R),max(D,L));
	if(ans==U)
		cout<<"U";
	else if(ans==R)
		cout<<"R";
	else if(ans==D)
		cout<<"D";
	else
		cout<<"L";
	cout<<"\n";
	if(op==1)
		cout<<"Voyager";
	else
		cout<<ans;
```

最后，是最主要的遍历函数，用来暴力求出信号在系统中停留的最长时间，具体解释在代码中。

```cpp
char a[505][505];
int g[505][505];
int n,m,op=0;
int dfs(int x,int y,int f){
	if(x<1||x>n||y<1||y>m||a[x][y]=='C'||op==1) // (1) 
		return 0;
	// 超出边界，遇到黑洞，无限循环
	// 返回 0，退出 dfs 
	if(a[x][y]=='/'){
		if(f==1) f=2;
		else if(f==2) f=1;
		else if(f==3) f=4;
		else if(f==4) f=3;
	}
	// 反弹情况 1 
	if(a[x][y]=='%'){
		// % 替换 \
		// 不然会报错 
		if(f==1) f=4;
		else if(f==2) f=3;
		else if(f==3) f=2;
		else if(f==4) f=1;
	}
	// 反弹情况 2
	if(g[x][y]==f){
		op=1;
		return 0;
		// 有环，op 标记一下，作为最优答案。
		// 后面不用判断了，(1)处的 op==1 特判就是此作用。 
	}
	g[x][y]=f;
	// 标记，用于判断循环 
	if(f==1) return dfs(x-1,y,f)+1;
	if(f==2) return dfs(x,y+1,f)+1;
	if(f==3) return dfs(x+1,y,f)+1;
	if(f==4) return dfs(x,y-1,f)+1;
	// 四个方向 
}
```

## 代码

[AC 记录](https://www.luogu.com.cn/record/226756742)

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[505][505];
int g[505][505];
int n,m,op=0;
int dfs(int x,int y,int f){
	if(x<1||x>n||y<1||y>m||a[x][y]=='C'||op==1)
		return 0;
	if(a[x][y]=='/'){
		if(f==1) f=2;
		else if(f==2) f=1;
		else if(f==3) f=4;
		else if(f==4) f=3;
	}
	if(a[x][y]=='%'){
		if(f==1) f=4;
		else if(f==2) f=3;
		else if(f==3) f=2;
		else if(f==4) f=1;
	}
	if(g[x][y]==f){
		op=1;
		return 0;
	}
	g[x][y]=f;
	if(f==1) return dfs(x-1,y,f)+1;
	if(f==2) return dfs(x,y+1,f)+1;
	if(f==3) return dfs(x+1,y,f)+1;
	if(f==4) return dfs(x,y-1,f)+1;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		string x;
		cin>>x;
		for(int j=1;j<=m;j++){
			a[i][j]=x[j-1];
			if(int(x[j-1])==92)
				a[i][j]='%';
		}
	} 
	int x,y;
	cin>>x>>y;
	memset(g,0,sizeof(g));
	int U=dfs(x,y,1);
	memset(g,0,sizeof(g));
	int R=dfs(x,y,2);
	memset(g,0,sizeof(g));
	int D=dfs(x,y,3);
	memset(g,0,sizeof(g));
	int L=dfs(x,y,4);
	int ans=max(max(U,R),max(D,L));
	if(ans==U)
		cout<<"U";
	else if(ans==R)
		cout<<"R";
	else if(ans==D)
		cout<<"D";
	else
		cout<<"L";
	cout<<"\n";
	if(op==1)
		cout<<"Voyager";
	else
		cout<<ans;
	return 0;
}
```

---

## 作者：WJF891210 (赞：2)

~~作为一名蒟蒻，这是我的第一次发布题解，望管理员大大通过 qwq~~。

[可以播客园食用](https://www.cnblogs.com/wjfakeverthing/articles/19033450)

[可以博客食用](https://www.luogu.com.cn/article/06gx6exc)

废话不多说我们直接进入正题。

[题目传送门](https://www.luogu.com.cn/problem/P13415)

# 正文

## 分析题目

先从题目分析着手。

本题的大致意思是在一个 $$ n \times m $$ 的格子中通过类似于光的运动轨迹来移动，在超出格子时或者是碰到 C 这类格子时就结束的一道小模拟题目。

既然是在一种格子中移动，那么就可以考虑通过 DFS 来实现本题，只不过本题与普通的 DFS 不同点是在格子中移动是**无法自主决定移动方向**，必须通过特殊的格子来改变，所以严格意义上来说这道题是一道模拟题只不过可用 DFS 来**递归**处理。并且，这道题是需要求**最长**的移动轨迹。

既然我们知道了难点就来一一处理掉。

## 处理难点

### 读入

在读入宇宙格子中，我们可以先判断将字符转为 int 类型为后期处理做铺垫。

但，在读入 ```\``` 字符时，如果直接判断会出错。所以可以 用判断语句 ```if(s == '\\')``` 或者 ```if((int)s == 92)``` 来处理这里我偏向第一者。

代码片段：

```cpp
//	-----字符转数字类型操作-----
	char s;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			cin >> s;
			if(s == '.') maze[i][j] = 0;		//空地区域
			else if(s == '\\') maze[i][j] = 1;  //行星格子类型1
			else if(s == '/')  maze[i][j] = 2;  //行星格子类型2
			else if(s == 'C')  maze[i][j] = -1; //黑洞格子
		}
	}
```

### 模拟

既然要求最长停留时间，并要向四个方向移动，那就要用四个数表示四个方向，那么移动就可以用四个变化量来处理。

```cpp
const int dx[] = {0, -1, 0, 1, 0},dy[] = {0, 0, 1, 0, -1}; 
// 除去第0位分别是 Up, Right, Down, Left -> U, R, D, L
```
既然都已经表示方向了，那么在处理上一个格子的状态就可以用**方向** **dir** 这个变量来记录。此时，我们分两个方式：

1. 记录上一个格子处于当前格子的什么方向。但这种方式需用多次判断来处理转移。所以我个人在这里不是特别推荐。

2. 记录当前格子原本记录意图移动方向，也就是上一个格子的移动方向。

此时 DFS 的变量，当前格子的位置，方向，和停留在格子中的时间。

```cpp
inline int dfs(int x,int y,int dir,int tim)
//变量的意思： 当前格子的行号，当前格子的列号，方向，停留时间
```
为什么这里的函数要用 int 类型呢？因为在判断结束时好返回结束的时间。

需要注意的是循环的处理 ~~（这个我们稍后再说）~~。

#### 空地格子

不管当前的状况直接向下一个同方向的地方移动。

```cpp
int tx = x + dx[dir], ty = y + dy[dir];
if(maze[x][y] == 0) return dfs(tx, ty, dir, tim + 1);
```

#### 行星格子

![](https://cdn.luogu.com.cn/upload/image_hosting/9rvne014.png)

那么处理的代码如下：

```cpp
if(maze[x][y] == 1){
	if(dir == 1) return dfs(x, y-1, 4, tim + 1);
	if(dir == 2) return dfs(x+1, y, 3, tim + 1);
	if(dir == 3) return dfs(x, y+1, 2, tim + 1);
	if(dir == 4) return dfs(x-1, y, 1, tim + 1);
}
if(maze[x][y] == 2){
	if(dir == 1) return dfs(x, y+1, 2, tim + 1);
  if(dir == 2) return dfs(x-1, y, 1, tim + 1);
	if(dir == 3) return dfs(x, y-1, 4, tim + 1);
	if(dir == 4) return dfs(x+1, y, 3, tim + 1);
}
```

#### 处理停止的格子
代码片段如下：

```cpp
if(!(1<=x&&x<=n && 1<=y&&y<=m) || maze[x][y] == -1) return tim;
```

#### 处理循环

如果当前格子从上一个格子来过了，那么就弹出一个 $$inf$$ 值。

因为 $$1 \le n \le 500$$ 并且 $$1 \le n \le 500$$ 所以 $$inf$$ 的值可以设为 $ 1e6 + 5 $。

但如果用四维的 $vis$ 数组存储那必定会超边界。所以用方向代替后两维。

那么代码如下：

```cpp
if(vis[x][y][dir] == 1) return inf;
vis[x][y][dir] = 1;
```
#### 答案处理

处理答案时，需要用 struct 存储，并用 sort 排序。

```cpp
struct Node{
	int time,id;
}a[5];
```
struct 处理。

```cpp
inline bool cmp(Node xx, Node yy){
	if(xx.time == yy.time) return xx.id < yy.id;
	return xx.time > yy.time;
}

sort(a+1, a+5, cmp);
```
排序处理。

```cpp
for(int i = 1;i <= 4;i ++){
memset(vis, 0, sizeof(vis));
a[i].time = dfs(stx, sty, i, 0);
a[i].id = i;
}
```

答案记录。

```cpp
	char ans[5] = {' ','U','R','D','L'};
	cout << ans[a[1].id];
	
	if(a[1].time == inf) cout << "\nVoyager";
	else cout << "\n" << a[1].time;
```

输出。

## 写在最后

记得每次模拟时记得清空 $vis$ 数组。

代码 code ：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 505, inf = 1e6 + 5;
struct Node{
	int time,id;
}a[5];
int n, m, maze[N][N], stx, sty;
bool vis[N][N][5] = {0};
const int dx[] = {0, -1, 0, 1, 0},dy[] = {0, 0, 1, 0, -1}; // 除去第0位分别是 Up, Right, Down, Left -> U, R, D, L
inline int dfs(int x,int y,int dir,int tim){
	if(vis[x][y][dir] == 1) return inf;
	vis[x][y][dir] = 1;
	if(!(1<=x&&x<=n && 1<=y&&y<=m) || maze[x][y] == -1) return tim;
	if(maze[x][y] == 1){
		if(dir == 1) return dfs(x, y-1, 4, tim + 1);
		if(dir == 2) return dfs(x+1, y, 3, tim + 1);
		if(dir == 3) return dfs(x, y+1, 2, tim + 1);
		if(dir == 4) return dfs(x-1, y, 1, tim + 1);
	}
	if(maze[x][y] == 2){
		if(dir == 1) return dfs(x, y+1, 2, tim + 1);
		if(dir == 2) return dfs(x-1, y, 1, tim + 1);
		if(dir == 3) return dfs(x, y-1, 4, tim + 1);
		if(dir == 4) return dfs(x+1, y, 3, tim + 1);
	}
	int tx = x + dx[dir], ty = y + dy[dir];
	if(maze[x][y] == 0) return dfs(tx, ty, dir, tim + 1);
}

inline bool cmp(Node xx, Node yy){
	if(xx.time == yy.time) return xx.id < yy.id;
	return xx.time > yy.time;
}

int main(){
	cin >> n >> m;
//	-----字符转数字类型操作-----
	char s;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			cin >> s;
			if(s == '.') maze[i][j] = 0;		//空地区域
			else if(s == '\\') maze[i][j] = 1;  //行星格子类型1
			else if(s == '/')  maze[i][j] = 2;  //行星格子类型2
			else if(s == 'C')  maze[i][j] = -1; //黑洞格子
		}
	}
//	-----模拟开始-----
	cin >> stx >> sty;
	for(int i = 1;i <= 4;i ++){
		memset(vis, 0, sizeof(vis));
		a[i].time = dfs(stx, sty, i, 0);
		a[i].id = i;
	}
	
//	-----答案处理-----
	sort(a+1, a+5, cmp);
	
	char ans[5] = {' ','U','R','D','L'};
	cout << ans[a[1].id];
	
	if(a[1].time == inf) cout << "\nVoyager";
	else cout << "\n" << a[1].time;
	
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### 题目解析：

我们需要模拟探测器在恒星系统中发射信号后的传播路径。信号会在网格中传播，遇到行星时方向会偏转 90 度，遇到黑洞或离开网格时终止传播。目标是找到使信号停留时间最长的发射方向，如果信号无限循环则输出 `Voyager`。题目就这么简单 awa。

### 如何做

模拟方法：

- 信号沿现在方向移动，直到遇到行星、黑洞或边界。这些情况。

- 遇到行星时，根据行星类型改变信号方向。

- 使用访问记录数组检测无限循环。

结果比较：比较四个方向的模拟结果，选择停留时间最长的方向。

最后输出。听起来可能有点枯燥，来看一下代码吧 awa

### AC 代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAX = 505;
char c[MAX][MAX];
int n, m, pr, pc;
int ti = -1;
char ans = 'U';

// 方向：上、右、下、左
const int dx[] = {-1, 0, 1, 0};
const int dc[] = {0, 1, 0, -1};
const char fang[] = {'U', 'R', 'D', 'L'};

void dfs(int u) {
    int r = pr - 1, c = pc - 1; 
    int dir = u;
    int time = 0;
    bool vis[MAX][MAX][4];
    memset(vis, 0, sizeof(vis));

    while (true) {
        if (r < 0 || r >= n || c < 0 || c >= m) {
            break;
        }
        if (c[r][c] == 'C') {
            break;
        }
        if (vis[r][c][dir]) {
            // 无限循环
            if (ti == -1 || ti < 0) {
                ti = -2;
                ans = fang[u];
            } else if (ti == -2) {
                // 已经有无线循环的情况，选择优先级更高的方向
                if (u < ans) {
                    ans = fang[u];
                }
            }
            return;
        }
        vis[r][c][dir] = true;

        if (c[r][c] == '/') {
            // 方向转换
            if (dir == 0) dir = 1;      // U -> R
            else if (dir == 1) dir = 0; // R -> U
            else if (dir == 2) dir = 3; // D -> L
            else if (dir == 3) dir = 2; // L -> D
        } else if (c[r][c] == '\\') {
            // 方向转换
            if (dir == 0) dir = 3;      // U -> L
            else if (dir == 1) dir = 2; // R -> D
            else if (dir == 2) dir = 1; // D -> R
            else if (dir == 3) dir = 0; // L -> U
        }

        r += dx[dir];
        c += dc[dir];
        time++;
    }

    if (ti == -2) {
        return; // 已经有无限循环的情况，无需处理有限时间
    }
    if (time > ti) {
        ti = time;
        ans = fang[u];
    } else if (time == ti) {
        if (u < ans) {
            ans = fang[u];
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> c[i][j];
        }
    }
    cin >> pr >> pc;

    for (int dir = 0; dir < 4; ++dir) {
        dfs(dir);
    }

    cout << ans << endl;
    if (ti == -2) {
        cout << "Voyager" << endl;
    } else {
        cout << ti << endl;
    }

    return 0;
}
```

完结散花 (＾－＾) V，点个赞或关注一下吧 awa

---

## 作者：liyuhongtiga (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13415)  
## 题目大意
一个信号在网格里传递，遇到 `.` 就前进，遇到 `/` 或 `\` 就改变方向，遇到 `C` 或超出边界就没了，一格跑一秒，问朝哪个方向发射信号跑得最久。  
## 做法分析
很显然是一道暴力递归的题目。从给出的起始坐标分别向四个方向出发，并分别搜索一番即可。特判一下是否超出网格，即看 $x$ 和 $y$ 是否超过 $n$ 和 $m$，以及是否低于1，或者当前格子为 `C`，就说明跑到头了，和 $ans$ 打擂台比较，记录下最大值和最大值对应的方向。

特别注意：**要用一个数组来记录每次到达点的坐标和方向**，如果重复，则说明陷入循环，直接输出方向和 `Voyager` 即可。  

还有一点，注意搜索的顺序，**按照“上、右、下、左”的顺序来搜索**，避免出现顺序错误。  
## AC代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,vis[505][505][5],ans,aim;
char a[505][505];
int d1[4]={-1,1,0,0};
int d2[4]={0,0,-1,1};
void dfs(int x,int y,int fx,int cf,int sj){
	if(x<1||x>n||y<1||y>m||a[x][y]=='C'){//看是否失去信号 
		if(sj>ans){
			ans=sj;
			aim=cf;
		}
		return;
	}
	if(vis[x][y][fx]==1){//判断是否循环 
		if(cf==1){
			cout<<"U\n";
		}else if(cf==2){
			cout<<"D\n";
		}else if(cf==3){
			cout<<"L\n";
		}else{
			cout<<"R\n";
		}
		cout<<"Voyager";
		exit(0);
	}
	vis[x][y][fx]=1;
	if(a[x][y]=='.'){//直接前进 
		dfs(x+d1[fx-1],y+d2[fx-1],fx,cf,sj+1);
	}else{//改变方向 
		if(fx==1){
			if(a[x][y]=='/'){
				fx=4;
			}else{
				fx=3;
			}
		}else if(fx==2){
			if(a[x][y]=='/'){
				fx=3;
			}else{
				fx=4;
			}
		}else if(fx==3){
			if(a[x][y]=='/'){
				fx=2;
			}else{
				fx=1;
			}
		}else{
			if(a[x][y]=='/'){
				fx=1;
			}else{
				fx=2;
			}
		}
		dfs(x+d1[fx-1],y+d2[fx-1],fx,cf,sj+1);
	}
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	cin>>x>>y;
	dfs(x,y,1,1,0);
	memset(vis,0,sizeof(vis));
	dfs(x,y,4,4,0);
	memset(vis,0,sizeof(vis));
	dfs(x,y,2,2,0);
	memset(vis,0,sizeof(vis));
	dfs(x,y,3,3,0);
	if(aim==1){
		cout<<"U\n";
	}
	if(aim==2){
		cout<<"D\n";
	}
	if(aim==3){
		cout<<"L\n";
	}
	if(aim==4){
		cout<<"R\n";
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__coderyc__ (赞：1)

## 思路
模拟题，首先分析一下题意。

给你一个 $N \times M$ 的镜面地图，空地为 `.`，镜子分为 `\` 与 `/`，光线碰到镜子会改变方向，若碰到 `C` 则光线被吸收。
现在有一点作为发射地，请选择一个方向让光线经过的空地最多，输出这个方向及经过的格子数。特别的，如果光可以在地图内无限循环，输出 `Voyager`。

想到了 2024 CSP-J T2，肯定先存图，然后每次循环如果光还在地图中，将步数加一。如果碰到一个镜子，对应的将方向改变，每一次循环都按照这个方向走一步。经过一个格子，将这个位置中以这种方向走的打上标记，如果有一次走到一个格子的时候有标记，退出循环，判定为无限循环。什么时候走出地图或碰到 `C` 的时候退出循环，记录步数。四个方向都走一遍比个大小就行了，时间还挺充裕的说实话。

## 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 505;
char grid[MAXN][MAXN];
bool vis[MAXN][MAXN][4]; //三维数组，最后一维表示方向
int n, m, pr, pc;

const int dirs[4][2] = {{-1,0}, {0,1}, {1,0}, {0,-1}};  //方向
const char dir_names[4] = {'U', 'R', 'D', 'L'};  //方向表示

int simulate(int dir) {
    memset(vis, 0, sizeof(vis));
    int r = pr, c = pc, steps = 0;
    while (1) {
        if (r < 1 || r > n || c < 1 || c > m) return steps;
        if (grid[r][c] == 'C') return steps;
        if (vis[r][c][dir]) return -1;
        vis[r][c][dir] = true;
        if (grid[r][c] == '/') {
            dir = dir ^ 1;  //改方向
        } else if (grid[r][c] == '\\') {
            dir = 3 - dir; //改方向
        }
        r += dirs[dir][0];
        c += dirs[dir][1];
        steps++;
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> grid[i][j];
        }
    }
    cin >> pr >> pc;
    int max_time = -1, best_dir = 0;
    bool infinite = false;
    for (int dir = 0; dir < 4; ++dir) {
        int time = simulate(dir);
        if (time == -1) {
            cout << dir_names[dir] << "\nVoyager\n";
            return 0;
        }
        if (time > max_time) {
            max_time = time;
            best_dir = dir;
        }
    }
    cout << dir_names[best_dir] << '\n' << max_time << '\n';  //格式化输出
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 题意简述
给定一个 $n\times m$ 的矩阵网格，用来描述整个地图。我们需要在起点发射一束光线，通过镜子反射，使其的路线最长。 $\\$ 

有两种类型的镜子，分别用“/”和“\”表示，两种镜子均可以使光线偏转 $90$ 度。具体可以看原题的图。 $\\$ 

当光线射出地图或是来到了标着“C”的位置，则结束传播。
# 思路
这题就是纯模拟，没什么可讲的，这题主要考察的是大家的程序设计能力以及调试程序时的耐心。所以这里我直接讲操作流程了。 $\\$ 

大致框架：
-  首先根据题意，第一步应该是枚举初始方向，我们可以用 $0$ 到 $3$ 来**分别**对应上、右、下、左四个方向。对于每一个初始方向，算出最长路径。
-  由于需要输出具体的方向，我们可以先建一个表来记录每个数字对应的方向，方便最后输出。最后输出方向以及对应的路径长度即可。 $\\$
  
算最长路径的步骤：
- 首先我们既然用 $0$ 到 $3$ 来**分别**对应上、右、下、左四个方向。那我们需要建立一个数组来存四个方向对于行列分别的偏移量。
- 接下来是主体部分，首先，我们需要用一个变量 $cnt$ 来记录光线传播了多久。
- 接着就是光线传播的过程。至于怎么判断光线是否在地图内无限循环，只需要看看 $cnt$ 是否大于 $n\times m$ 即可。
  - 第一步：根据方向对应的偏移量计算下一步要到达那个位置。
  - 第二步：如果出界或到达了标着“C”的位置，则结束传播，返回当前 $cnt$。
  - 第三步：如果当前位置为镜子，则改变方向，具体可以看代码。
  - 第四步：更新光线位置，别忘了累加 $cnt$ 的值。
  - 第五步：如果发现 $cnt$ 大于 $n\times m$，即光线在地图内无限循环，则返回一个特殊的极大值，用来最后判断。
 $\\$ 

以上便是大致的思路，如果还有不懂的，就看注释吧。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
const int fx[4][2]={-1,0,0,1,1,0,0,-1};
char dir[4]={'U','R','D','L'};
//0:上 , 1:右 , 2:下 , 3:左
int n,m,sx,sy,ans,k;
char a[505][505];
int pp(int x,int y,int d)
{
	int cnt=0;//计数器
	while(1)
	 {
        if(cnt>n*m) return 1145145;//如果光线在地图内无限循环
	 	cnt++;
	 	int nx=x+fx[d][0],ny=y+fx[d][1];//计算下一个位置
	 	if(nx<1||nx>n||ny<1||ny>m||a[nx][ny]=='C') break;	//如果出界或到达了标着“C”的位置
	 	if(a[nx][ny]=='\\') d=3-d;
		if(a[nx][ny]=='/') 
		 if(d<2) d=1-d;
		 else d=5-d;//改变方向
		x=nx;y=ny;//到达新的位置
	 }
	return cnt;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);//每次读入一行字符
	cin>>sx>>sy;
	for(int i=0;i<4;i++)//枚举方向
	 {
	 	int s=pp(sx,sy,i);//算出当前方向可以停留的最长时间
	 	if(s>ans) ans=s,k=i;//更新答案
	 }
	cout<<dir[k]<<"\n";
	if(ans==1145145) cout<<"Voyager";
	else cout<<ans;
	return 0;
}
```

---

## 作者：lyh1190 (赞：1)

## 我来抢题解啦！
# [传送](https://www.luogu.com.cn/problem/P13415)
**先来浅浅分析一下题目：**  
这是一道枚举题，按照规则枚举即可（简单来说就是暴力）。  
这道题的主要思路就是模拟信号在网格中的传播过程，判断信号的路径、停留时间，枚举所有情况并找出最优发射方向。

再重复一下**规则**:  
1. 信号沿直线传播从当前格子传播到相邻格子需要 $1$ 秒，遇到行星（`/` 或 `\`）则转 $90°$，遇到黑洞（ `C`）或出界则终止。
2. 两种行星的转向规则不同（需严格按题目图示或逻辑实现转向）。
3. 若信号路径重复（同一位置 + 同一方向再次/多次到达），则进入无限循环（输出 `Voyager`）。

### 过程分析:
输入就不多说了，直接看过程：
1. **遍历方向**：按 `U→R→D→L` 顺序遍历四个方向（规则里说了，可以回去看看），对每个方向调用 `cbsj`（传播时间） 模拟。
2. **无限循环处理**：若模拟返回 $-1$，直接输出当前方向和 `Voyager`，程序终止。
3. **最优方向选择**：比较各方向的停留时间，记录最长时间及对应方向，最终输出。

好，上代码：

```cpp
#include <iostream>//需要用的头文件 
#include <cstring>
using namespace std;
const int fx[4][2]={{-1,0},{0,1},{1,0},{0,-1}};//方向:上、右、下、左(按优先级顺序)os:拼音真不错 
const char fxbs[4]={'U','R','D','L'};//对应方向字符
char wg[505][505];//网格数据
bool visit[505][505][4];//记录(x,y,dir)是否已访问过(用于检测无限循环)
int N,M;
int startx,starty;//探测器初始位置(转换为0基索引(人习惯1基索引,而电脑反之))
//模拟信号传播,返回停留时间，-1表示无限循环
int cbsj(int dir)
{
    int x=startx,y=starty;
    int time=0;
    memset(visit,0,sizeof(visit));//每次模拟重置访问状态
    while(true)
	{
        if(x<0||x>=N||y<0||y>=M||wg[x][y]=='C')//检查是否越界或进入黑洞
		{
            return time;
        }
        if(visit[x][y][dir])//检查是否已访问过该状态（无限循环）
		{
            return -1;
        }
        visit[x][y][dir]=true;
        //沿当前方向移动
        int nx=x+fx[dir][0];
        int ny=y+fx[dir][1];
        time++;
        if(wg[nx][ny]=='/')//遇到行星，改变方向
		{
            //根据当前方向转向
            if(dir==0)
				dir=1;//上->右
            else if(dir==1)
				dir=0;//右->上 
            else if(dir==2)
				dir=3;//下->左
            else if(dir==3)
				dir=2;//左->下 
        }
		else if(wg[nx][ny]=='\\')
		{
			//同上所述 
            if(dir==0)
				dir=3;//上->左
            else if(dir==1)
				dir=2;//右->下
            else if(dir==2)
				dir=1;//下->右
            else if(dir==3)
				dir=0;//左->上
        }
        //更新位置
        x=nx;
        y=ny;
    }
}
//主函数 
int main()
{
    cin>>N>>M;//输入网格尺寸
    for(int i=0;i<N;i++)
	{
        cin>>wg[i];
    }
    cin>>startx>>starty;//输入探测器位置
    startx--;
    starty--;
    int maxtime=-1;
    char bestfx=' ';
    for(int i=0;i<4;i++)//按优先级遍历四个方向:U->R->D->L
	{
        int time=cbsj(i);
        if(time==-1)//发现无限循环,直接输出结果
		{
            cout<<fxbs[i]<<endl;
            cout<<"Voyager"<<endl;
            return 0;
        }
        if(time>maxtime)//更新最长时间和最优方向
		{
            maxtime=time;
            bestfx=fxbs[i];
        }
    }
    //输出结果
    cout<<bestfx<<endl;
    cout<<maxtime<<endl;
    return 0;//好习惯 
}
```
### 复杂度分析：
- **时间复杂度**：每个方向最多模拟 
$O(N\times M\times 4)$次状态（位置 $\times$ 方向），总复杂度为$O(N\times M\times 4\times 4)$（四个方向遍历），由于 $N$、$M\le 500$，实际运行效率足够（最多 $500\times 500\times 4\times 4=4000000$次操作）。
- **空间复杂度**：三维数组 `visit[505][505][4]` 占用约 $505\times 505\times 4=1020100$ Byte，空间足够。

### 总结
此题通过输入、模拟信号传播、检测状态、判断，最终找出最优发射方向或判断是否会无限循环。
# 谢谢观看！
![](https://fecdn.luogu.com.cn/luogu/ac-congrats.png?ce96b99faabe0d91e25e00917ef494af)

---

## 作者：Doraeman (赞：1)

这道题和 [P11228 [CSP-J 2024] 地图探险](https://www.luogu.com.cn/problem/P11228)（CPS-J $2024$ 年 T$2$）比较像，都是在一个地图上进行模拟、计数。

## 思路
1. 写 while 循环，每次根据当前格子的符号更行 $x,y$ 坐标，同时统计经过的格子数量。  
   退出循环的条件可以如下方这样写。  
   ```c++
   if(
     x < 1 || x > n ||
     y < 1 || y > m ||
     a[x][y] == 'C'
   )
       break;
   ```
2.写 dfs 深搜函数。同理，如果遇到上面那种情况就直接返回。

## 符号处理
### ```.``` 符号
根据题意，```.``` 所在的位置是**空格子**，可以直接忽略，**不用单独处理**。

### 字母 ```C```
这个地方是黑洞，退出循环，或 dfs 函数返回。

### ```/``` 符号
由于遇到这个符号会改变方向，所以设当前方向为 $d\isin\{0,1,2,3\}$（分别表示上、右、下、左）；下一步方向为 $d'$，表示方式同理。  
分情况处理。
1. $d=0$，根据题目的图示，可以观察出 $d'=1$。
2. $d=1$，同理可知 $d'=0$。
3. $d=2$，可知 $d'=3$。
4. $d=3$，可知 $d'=2$。

#### 处理代码
```cpp
if(a[x][y] == '/'){
    if(d == 0) d = 1;
    else if(d == 1) d = 0;
    else if(d == 2) d = 3;
    else d = 2;
}
```

### ```\``` 符号
与上方同理，此处不过多赘述，直接给出代码。
```cpp
if(a[x][y] == '\\'){
    if(d == 0) d = 3;
    else if(d == 1) d = 2;
    else if(d == 2) d = 1;
    else d = 0;
}
```
此处需要注意的是，**直接写 ```'\'``` 是不正确的，因为 ```\``` 本身有特殊含义，直接放在 ```''``` 内会出现错误，需要在其前面再加入一个 ```\```，即 ```'\\'```。**

## Voyager 判定
我最开始使用了 $vis$ 数组记录每个点是否被经过，如果被经过 $2$ 次及以上就认定为循环，永远不会出界，但这显然是错误的，可以用本题的第 $2$ 个自测样例进行验证。

其实有一个很简单的办法：可以使用 $cnt$ 记录经过的格子数量，当其达到一定数量时就表明 $cnt$ 经过格子太多，可以判定为死循环。  
我在尝试时设这个边界值为 $N_{max}\times M_{max}$，即 $10^6$，可以正确通过。

## 代码
注：为了方便处理，我给不同符号编了号。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e2+5;

int n, m, x, y, d, a[N][N];
// .=0, C=-1, /=1, \=2
int dx[] = {-1, 0, 1, 0},
    dy[] = {0, 1, 0, -1},
    maxi = -1, sec[10];
char dir[] = {'U', 'R', 'D', 'L'};

// 判定是否在界内 
bool in(int x, int y){
    return 1 <= x && x <= n && 1 <= y && y <= m;
}

int go(int x, int y, int d, int cnt){
    if(cnt >= N*N) // 判定死循环 
        return INT_MAX;

    if(!in(x, y) || a[x][y] == -1) 
        return cnt;

    if(a[x][y] == 1){
        if(d == 0) d = 1;
        else if(d == 1) d = 0;
        else if(d == 2) d = 3;
        else d = 2;
    }
    else if(a[x][y] == 2){
        if(d == 0) d = 3;
        else if(d == 1) d = 2;
        else if(d == 2) d = 1;
        else d = 0;
    }
    
    return go(x + dx[d], y + dy[d], d, cnt + 1);
}

int main(){
    cin >> n >> m;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++){
            char c; cin >> c;
            if(c == 'C') a[i][j] = -1;
            if(c == '/') a[i][j] = 1;
            if(c == '\\') a[i][j] = 2;
        }
    cin >> x >> y;

    for(int d=0; d<4; d++){
        // dfs 函数
        sec[d] = go(x, y, d, 0);
        maxi = max(maxi, sec[d]);
    }

    for(int i=0; i<4; i++)
        if(sec[i] == maxi){ // 如果是最大值 
            if(sec[i] == INT_MAX) printf("%c\nVoyager",dir[i]);
            else printf("%c\n%d",dir[i],sec[i]);
            return 0;
        }
}
```

---

## 作者：b__b (赞：1)

暴力大法好！

我们可以枚举四个方向，并算出四个方向最多能走多远。于是我们考虑在一个方向上如何模拟走的过程。

下文设方向为 $d$。

当 $d=1$ 时，代表方向向上。

当 $d=2$ 时，代表方向向右。以此类推。

当信号在一颗行星上时，由图得：
- 对于类型为`\`的行星：
  - 当 $d=1$ 时，$d \gets 4$；
  - 当 $d=2$ 时，$d \gets 3$；
  - 当 $d=3$ 时，$d \gets 2$；
  - 当 $d=4$ 时，$d \gets 1$；
- 对于类型为`/`的行星：
  - 当 $d=1$ 时，$d \gets 2$；
  - 当 $d=2$ 时，$d \gets 1$；
  - 当 $d=3$ 时，$d \gets 3$；
  - 当 $d=4$ 时，$d \gets 4$。

整理规律：
- 对于类型为`\`的行星，$d \gets 5-d$；
- 对于类型为`/`的行星，当 $d$ 为偶数时 $d \gets d-1$，当 $d$ 为奇数时 $d \gets d+1$。

设现在的坐标为 $(x,y)$，我们：
- 当 $d=1$ 时，$y \gets y-1$；
- 当 $d=2$ 时，$x \gets x+1$；
- 当 $d=3$ 时，$y \gets y+1$；
- 当 $d=4$ 时，$x \gets x-1$；
- 设时间为 $t$，走完之后 $t \gets t+1$。

我们如何判断可以无限循环？我们增加一个判重数组，当我们以相同的方向走到之前走过的格子里面时就可以判断是无限的。

实现时，我们可以设置一个常量，表示时间可以无限循环（一定要比实际可以走的时间长），例如：
```cpp
const int INF = 0x44417A9F; //如果可以无限循环就将时间设为这个值
```
代码：
```cpp
#include <cstdio>
#include <cstring>
char map[505][505];
bool pc[505][505][5];
 //是否是合法字符
bool check(char c) {return c == '/' || c == '\\' || c == 'C' || c == '.';}
const int INF = 0x44417A9F;
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) while (!check(map[i][j] = getchar()));
    int x, y;
    scanf("%d%d", &x, &y);
    int ans1 = -1, ans2 = 0;
    for (int i = 1; i <= 4; ++i) {
        if (i != 1) memset(pc, 0, sizeof pc);
        int tmpx = x, tmpy = y, nowfx = i, time = 1;
        for (; tmpx && tmpy && tmpx <= n && tmpy <= m; ++time) {
            if (pc[tmpx][tmpy][nowfx]) {time = INF; break;}
            pc[tmpx][tmpy][nowfx] = 1;
            switch (map[tmpx][tmpy]) {
                case '\\':
                    nowfx = 5 - nowfx;
                    break;
                case '/':
                    if (nowfx & 1) ++nowfx;
                    else --nowfx;
                    break;
                default: if (map[tmpx][tmpy] != '.') goto end;
            }
            switch (nowfx) { //其实这里的x与y是反过来的
                case 1: --tmpx; break;
                case 2: ++tmpy; break;
                case 3: ++tmpx; break;
                case 4: --tmpy;
            }
        }
        end:
        if (time > ans2) ans2 = time, ans1 = i;
    }
    switch (ans1) {
        case 1: putchar('U'); break;
        case 2: putchar('R'); break;
        case 3: putchar('D'); break;
        case 4: putchar('L');
    }
    putchar('\n');
    if (ans2 == INF) puts("Voyager");
    else printf("%d", ans2 - 1);
}
```

---

## 作者：_aszxqw_ (赞：0)

这题和去年 J 组 T2 很像，直接按照题目说的模拟就可以了，但是只用二维数组在这不好记录，所以记录初始方向，逐步移动信号，步数可以用三维数组。用三维数组来标记是否访问过某个位置和方向，以便检测循环。     
### AC 代码
```
#include <bits/stdc++.h>
using namespace std;
char g[515][515];
int n,m,pr,pc,dr[]={-1,0,1,0},dc[]={0,1,0,-1},ms=-1;
char bd='U',ds[]={'U','R','D','L'};
int ss(int d){
    bool vis[515][515][4]={0};
    int r=pr-1,c=pc-1,s=0;
    while(1){
        if(r<0||r>=n||c<0||c>=m)return s;
        if(g[r][c]=='C')return s;
        if(vis[r][c][d])return -1;
        vis[r][c][d]=1;
        if(g[r][c]=='/')d^=1;
        else if(g[r][c]=='\\')d=3-d;
        r+=dr[d],c+=dc[d],s++;
    }
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;++i)cin>>g[i];
    cin>>pr>>pc;
    for(int i=0;i<4;++i){
        int t=ss(i);
        if(t==-1){cout<<ds[i]<<"\nVoyager\n";return 0;}
        if(t>ms)ms=t,bd=ds[i];
    }
    cout<<bd<<'\n'<<ms<<'\n';
}
```

---


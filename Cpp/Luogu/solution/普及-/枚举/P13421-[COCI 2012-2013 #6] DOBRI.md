# [COCI 2012/2013 #6] DOBRI

## 题目描述

给定一个长度为 $N$ 的整数序列 $A$（不要与上一题的序列混淆）。如果第 $i$ 个元素等于序列中编号严格小于 $i$ 的某三个元素之和（同一个元素可以在和中多次使用），我们称第 $i$ 个元素是**好元素**。

请问这个序列中有多少个好元素？

## 说明/提示

在至少 $40\%$ 分数的测试数据中，$N \leq 50$。

在至少 $70\%$ 分数的测试数据中，$N \leq 500$。

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
2
1 3```

### 输出

```
1```

## 样例 #2

### 输入

```
6
1 2 3 5 7 10```

### 输出

```
4```

## 样例 #3

### 输入

```
3
-1 2 0```

### 输出

```
1```

# 题解

## 作者：hanxiaofensheng (赞：4)

统计一个序列中"好元素"的数量。好元素的定义是：对于第 $i$ 个元素，如果它能表示为前面 $i-1$ 个元素中任意三个元素的和（同一个元素可重复使用），那么这个元素就是一个好元素。

每次循环，判断 $a_i$ 是否存在前面三个元素（可重复）的和等于 $a_i$。记得用哈希集合来存储所有可能的值，时间复杂度会从优化到 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e3+5;
int n, a[maxn], ans;
unordered_set<int> t;
int main() {
    cin >> n;
    for (int i = 0;i < n;i++) cin >> a[i];
    for (int i = 0;i < n;i++) {
        bool f = 0;//用于检查是否存在 a[j]+a[k]+a[l]=a[i]。 
        for (int j = 0;j < i && !f;j++)
			if (t.find (a[i] - a[j]) != t.end())
				f = 1;
        if(f) ans++;
        for (int j = 0;j <= i;j++)
			t.insert (a[i]+a[j]);
    }
    cout<<ans;
}
```

---

## 作者：b__b (赞：2)

我们通过数据范围猜复杂度。因为 $1 \leq N \leq 5000$，我们猜想要用一个 $O(N^2)$ 的算法。

我们可以想到把三个数的和拆成另外两个数的和加上一个数，于是我们存储一个哈希表 $h$，当 $h_i$ 为真时代表存在两个数相加之和为 $i$。我们每次遇到一个新元素，就用它**之前的元素或它自己**与它的和更新 $h$。（因为题目要求编号严格小于，并且和可以重复使用。）

于是我们判断是否是一个好元素的时候（设判断的元素为 $A_i$）就可以变成判断是否存在另一个元素 $A_j$（$j < i$），使得 $h_{A_i-A_j}$ 为真。

我们尝试实现。注意我们要先判断再更新。因为更新时会让 $h_{A_i+A_j}$ 为真，而我们需要编号严格小于。

实现时要小心更新和判断的循环条件能否取等号。
```cpp
#include <cstdio>
struct { //定义一个结构体将负数下标转换为可以正常读取的下标
    bool arr[600000];
    bool &operator[](const int p) {return arr[p + 200000];}
} hash;
int a[5005];
int main() {
    int N;
    scanf("%d", &N);
    for (int i = 0; i < N; ++i) scanf("%d", a + i);
    int ans = 0;
    for (int i = 0; i < N; ++i) {
        //这是判断的循环。这个循环不能取等号，因为好元素的判断需要严格小于。
        for (int j = 0; j < i; ++j) if (hash[a[i] - a[j]]) {++ans; break;}
        //这是更新的循环。这个循环可以取等号，因为同一个元素可以在和中多次使用。
        for (int j = 0; j <= i; ++j) hash[a[i] + a[j]] = 1;
    }
    printf("%d", ans);
}
```
时间复杂度：双重循环的时间复杂度为 $O(N^2)$，修改和查找哈希的复杂度为 $O(1)$，总体时间复杂度为 $O(N^2)$。

空间复杂度：需要一个数组存储 $A$ 序列，同时需要一个大小为值域大小的哈希表。总体复杂度为 $O(W+N)$（$W$ 为值域大小）。

---

## 作者：bayiran (赞：1)

## 解题思路

1. 暴力解法‌：看到这题先想到暴力，但对于每个元素 $A_i$ 都检查前面所有可能的三元组组合，时间复杂度为 $O(N^4)$，对于 $N=5000$ 显然不可行‌。

2. 优化解法‌：存储所有可能的二元组和，然后对于每个 $A_i$，检查是否存在一个前面的元素 $A_j$，使得 $A_i-A_j$ 存在。这样可以将时间复杂度优化到 $O(N^2)$。

3. 进一步优化：利用哈希表存储所有可能的两数之和，将问题转化为查找是否存在 $A_i-A_j$ 于哈希表中。

对于 $N=5000$，$O(N^2)$ 的复杂度是可行的。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    int cnt = 0;
    // 预处理前两个元素的两数之和
    unordered_set<int> ss;//上面所说的哈希表
    ss.insert(a[0] + a[0]);
    ss.insert(a[0] + a[1]);
    ss.insert(a[1] + a[1]);
    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(ss.find(a[i]-a[j]) != ss.end()){
                cnt++;
                break;
            }
        }
        for(int j=0;j<=i;j++){
            ss.insert(a[i]+a[j]);
        }
    }
    cout<<cnt<<endl;
    return 0;
}

```

---

## 作者：Zayn_Pan (赞：0)

## 题目 

戳 [这里](https://www.luogu.com.cn/problem/P13421) 看题目。

## 思路

我们可以记录 $a_i$ 在数组中最早出现的位置。然后暴力枚举此位数字 $i$ 和两个位置严格小于当前位置的数字 $j$ 和 $k$，如果 $i-j-k$ 在数组中严格小于当前位置的位置出现，那么答案增加 $1$。

这样写的时间复杂度 $O(n^3)$，期望得分 $70$。

继续优化，发现 $a_i=a_j+a_k+a_l$ 可以转化为 $a_i-a_l=a_j+a_k$。记录 $a_j+a_k$ 最早出现的位置。枚举 $i$ 和 $l$ 如果 $a_i-a_l$ 在之前的位置出现过，将答案增加 $1$。

具体实现和细节看代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>m;
int main(){
    int n,a[5005];
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)for(int j=1;j<=i;j++){
    	//i和j可以相等 
    	if(!m[a[i]+a[j]]){
    		m[a[i]+a[j]]=i;
		}
	}
    int ans=0;
    for(int i=1;i<=n;i++)for(int j=1;j<=i;j++){
    	//i和j不可以相等 
    	if(m[a[i]-a[j]]&&m[a[i]-a[j]]<i){
    		ans++;
    		break;//直接退出 
		}
	}
    cout<<ans;
    return 0;
}
```

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13421)

# 题目分析

设 $i$ 为好元素，则存在 $k_1$，$k_2$，$k_3$，使得 $A_i=A_{k_1}+A_{k_2}+A_{k_3}$，其中 $k_1$，$k_2$，$k_3$ 都小于 $i$ 且可以相等。移项得 $A_i-A_{k_1}=A_{k_2}+A_{k_3}$。由于 $n$ 很小，所以对于第 $i$ 个元素可枚举 $k_1$，并判断在第 $i$ 个元素以前的元素是否存在两个元素之和等于 $A_i-A_{k_1}$。这样，我们就由三层循环变成了两层。

下面就是处理和。这里设一个和 $s$ 的指标为最小的 $i$ 使得存在 $k_2$，$k_3$ 小于等于 $i$ 满足 $s=A_{k_2}+A_{k_3}$，设为 $I_s$。

由于内存限制，不能对每个 $i$ 开一个 map 存储哪些和的指标为 $i$，否则就会得到[这样的结果](https://www.luogu.com.cn/record/227688895)。为避免这种情况，我们可以反过来，存储每个和的指标。可以这样做是因为对于任意 $i>I_s$，必然能找到上述的 $k_2$，$k_3$。

这样，对于 $i$，枚举 $A_i$ 以前的所有元素，设枚举到第 $j$ 个元素，设 $s=A_i-A_j$。如果 $I_s$ 存在且 $I_s<i$，则该元素为好元素，否则不是。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 10001
using namespace std;
map<int,int>mp;
int a[N];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		for(int j=1;j<=i;j++){
			if(!mp[a[i]+a[j]]){
				mp[a[i]+a[j]]=i;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(mp[a[i]-a[j]]<=i-1&&mp[a[i]-a[j]]>0){
				ans++;
				break;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---


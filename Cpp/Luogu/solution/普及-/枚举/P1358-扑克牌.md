# 扑克牌

## 题目描述

组合数学是数学的重要组成部分，是一门研究离散对象的科学，它主要研究满足一定条件的组态（也称组合模型）的存在、计数以及构造等方面的问题。组合数学的主要内容有组合计数、组合设计、组合矩阵、组合优化等。

随着计算机科学的日益发展，组合数学的重要性也日渐凸显，因为计算机科学的核心内容是使用算法处理离散数据。

今天我们来研究组合数学中的一个有趣的问题，也是一个简单的计数问题：

从一副含有 $n$ 张的扑克牌(每张扑克牌都不相同)中，分给 $m$ 个人，第 $i$ 个人得到 $a_i$ 张牌，求一共有几种分法，这个数可能非常大，请输出此数模 $10007$ 后的结果。

## 说明/提示

对于 $50\%$ 的数据：$a_i=1$。

对于 $100\%$ 的数据：$1 \leq n \leq 10^4$，$1 \leq m \leq 100$，$0 \leq a_i \leq 100$。



## 样例 #1

### 输入

```
5 2
3 1
```

### 输出

```
20
```

## 样例 #2

### 输入

```
20 19
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

### 输出

```
8707
```

# 题解

## 作者：guobaipeng0 (赞：60)

C++简短题解，蒟蒻看不懂楼下高深算法，由此我想到了用二维数组杨辉三角求组合数，a[i][j]=a[i-1][j-1]+a[i-1][j]这样就不会像楼下所说枚举超时。要注意求杨辉三角时取模10007，以及求方案数时取模10007，接着扑克牌数量要减去第i个人拿的牌。

注：其实数据很大，10000\*10000的数组根本装不下，所以有点坑数据的成分，因为猜测m<=100，所以二维数组后面改成10000\*100


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,s=1,t,a[10005][105];
int main()
{
    cin>>n>>m;
    a[0][0]=1;
    for (i=1; i<=10000; i++)
     for (j=0; j<=100; j++)
      a[i][j]=(a[i-1][j-1]+a[i-1][j])%10007;  //杨辉三角求组合数
    for (i=1; i<=m; i++)
    {
        cin>>t;
        s=s*a[n][t]%10007;  //记得取模
        n-=t;  //由于第i个人拿了t张，扑克牌数量减少t
    }
    cout<<s;
    return 0;
}
```

---

## 作者：王奕瑜 (赞：43)

### 算法：数论——组合数

------------

### 分析
- 先看样例一，第一个人先当于是从五张牌里取出三张牌，为C(5,3),第二个人相当于是从剩下的两张牌里取出1张牌，为C(2,1)。最后把方案数相乘即可。只要想到这一步，代码的50%就写出来了：

------------

```cpp
    int n,m;
    in(n);in(m);//读入
    int sum=0;
    for (int i=0;i<m;i++)
    {
    	in(a[i]);//读入
    	sum+=a[i];//求和
    }
    if (sum>n)//如果要的牌比现有的牌还多，那么直接输出0结束
              （第8个点错的都是在这）
    {
    	printf ("0");
    	return 0;
    }
    long long ans=1ll;//保险起见，用long long存储
    for (int i=0;i<m;i++)
    {
    	ans=(ans*C(n,a[i],10007))%10007;//求C(n,a[i]),与ans相乘
    	n-=a[i]; //这时总共剩下（n-a[i]）张牌
    }
    printf ("%lld",ans);//输出

```

------------

- 那么，问题的根本不就是求C(n,m)%mod吗？
- 这里教一个方法——**求重数**
- 写一个函数cal(n,x),这个函数能够求n!的因子中x的个数，我们知道，C(n,m)=n!/m!(n-m)!，所以C(n,m)因子中x的个数为cal(n,x)-cal(m,x)-cal(n-m,x).当然，**x必须为质数**。
- 那么cal怎么写呢?很简单，就是求n内x的整数倍的个数，x^2的整数倍的个数，......，最后求和即可。代码如下：

------------

```cpp
    int cal(int n,int x)//求重数
    {
	int ans=0;
	while (n>0)
	    ans+=n/=x;//求和
	return ans;
    }
```

------------

- 用这个方法不容易出错，而且简单方便。

------------

### 代码
- 下面是整道题的代码，上面已解释的不做解释。

------------

```cpp
#include <cstdio>
using namespace std;
void in(int &n)//快读
{
	n=0;int f=1;char c=getchar();
	while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
	while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
	n*=f;
}
int p[100005],b[100005];
int s;
int cal(int n,int x)
{
	int ans=0;
	while (n>0)
		ans+=n/=x;
	return ans;
}
long long C(int n,int m,int mod)//求C(n,m)%mod
{
	long long ans=1;
	for (int i=0;i<s;i++)
	{
		int k=cal(n,p[i])-cal(m,p[i])-cal(n-m,p[i]);
                                 //求C(n,m)中因子为p[i]的个数
		for (int j=0;j<k;j++)//把k个p[i]相乘
			ans=(ans*p[i])%mod;
	}
	return ans;
}
int a[105];
int main()
{
    b[0]=b[1]=1;
    for (int i=2;i<=100000;i++)//埃筛
    	if (!b[i])
    	{
    		for (int j=2*i;j<=100000;j+=i)
    			b[j]=1;
    		p[s++]=i;
    	}
	int n,m;
    in(n);in(m);
    int sum=0;
    for (int i=0;i<m;i++)
    {
    	in(a[i]);
    	sum+=a[i];
    }
    if (sum>n)
    {
    	printf ("0");
    	return 0;
    }
    long long ans=1ll;
    for (int i=0;i<m;i++)
    {
    	ans=(ans*C(n,a[i],10007))%10007;
    	n-=a[i]; 
    }
    printf ("%lld",ans);//输出
	return 0;
}

```


---

## 作者：QwQ蒟蒻wjr (赞：18)

都没人用组合的乘法原理吗？
~~一定是大佬装弱~~本蒟蒻上代码
```cpp
#include<cstdio>
using namespace std;
inline int read()//快读
{
	register int x=0b0;
	register char s=getchar();
	while(s<'0'||s>'9')
		s=getchar();
	while(s>='0'&&s<='9')
	{
		x=(x<<1)+(x<<3)+s-'0';
		s=getchar();
	}
	return x;
}
inline int A(int n,int m)
{
	int sum=1;
	for(register int i=1; i<=n; i++)
		sum=(sum*(m-i+1))%10007;
	return sum;
}
inline int c(int n,int m)
{
	int sum=1;
	for(register int i=1; i<=n; i++)
		sum=(sum*(m-i+1))%10007;
	for(register int i=1;i<=n;i++)
	{
		while(sum%i!=0)sum+=10007;
		sum/=i;
	 } 
	return sum;
}
int n,m,a[10010],sum=0;
int main()
{
	m=read();
	n=read();
	for(register int i=1; i<=n; i++)
	{
		a[i]=read();
		sum+=a[i];
	}
	if(sum>m)
	{
		printf("0\n");
		return 0;
	}
	sum=1;
	for(register int i=1; i<=n; i++)
	{
		sum=(sum*c(a[i],m))%10007;
		m-=a[i];
	}
	printf("%d\n",sum);
	return 0;
}
```



---

## 作者：s_a_b_e_r (赞：10)

##递推

看到这个题，开始没有思路。

看到这是在n张扑克中选a\_1张，然后在n-a\_1中选a\_2张.......就想到这次noip的组合数问题

![](http://http://pic.baike.soso.com/ugc/baikepic2/5694/20160719132818-402564969.jpg/300)

连续推几行就会发现对于C\_i,j;有如同杨辉三角的形状**第i行第j个数恰好等于从j个物品中选i个的性质！**

因为对于a\_i的值全小于101，所以三角只用到100就好了。

然后根据公式(a\*b)%p=((a%p)\*(b%p))%p就不用担心超int了

c[i]表示第i次选总共有多少物品

代码附上

···
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int a[121][100001];
const int mod=10007;
int n,m,b[100001],c[100001],ans=1;
void FB(){
     for(int i=0;i<=100000;i++)a[0][i]=1;
     for(int i=1;i<=100000;i++)
      for(int j=1;j<=100;j++)
       a[j][i]=(a[j-1][i-1]+a[j][i-1])%mod;
}
int main(){
    FB();
    cin>>n>>m;
    c[1]=n;
    for(int i=1;i<=m;i++){
            cin>>b[i];
            c[i+1]=c[i]-b[i];}
    for(int i=1;i<=m;i++)
    {
       ans=(ans*a[b[i]][c[i]])%mod;
    }
    cout<<ans;
    return 0;
} 
```
···


---

## 作者：什么叫中二呀 (赞：5)

可以考虑一个一个人拿扑克牌。

设第$i$个取之前剩下的牌数为$l_i$

$ans=\prod_{i=1}^N C_{l_i}^{a_i}$ $mod$ $10007$

其中$C_{l_i}^{a_i}$是组合数

$C_{l_i}^{a_i}=\frac{l_i!}{a_i!*(l_i-a_i)!}=l_i!*a_i!^{-1}*(l_i-a_i)!^-1$

又$a^{-1}≡a^{p-2}(mod$ $p)(p是质数)$

所以代码就很容易写了。(压行了不要管我)

```cpp
#include<cstdio>
#define ll long long
ll fac[10005]={1},inf[10005]={1},N,t,k,s=1,m=10007;
ll C(ll a,ll b){return fac[a]*inf[b]%m*inf[a-b]%m;}//计算组合数
ll p(ll a,ll b){return b?p(a*a%m,b>>1)%m*(b&1?a:1)%m:1;}//快速幂求逆元
int main()
{
	for(int i=1;i<10005;i++)fac[i]=fac[i-1]*i%m,inf[i]=p(fac[i],m-2)%m;//打出阶乘及逆元表
	for(scanf("%lld%lld",&N,&t);scanf("%lld",&k)!=EOF&&t;N-=k,t--)s=s*C(N,k)%m;
	printf("%lld",N<0?0:s);//计算以及输出
	return 0;
}
```

---

## 作者：梦回还 (赞：5)

50%的数据M = 1这就给了我们一个启发，能不能先把所有人获得的扑克牌看作一个整体呢？显然是可以的。而由于每一张牌都不相同，每一次的分法是一样的，我们考虑先求一个组合数，与后面的组合数相乘。

对于每一次获得的牌，若共有sum张，第一个人所取的牌为a[i]，那么剩下的人取牌方式便是从每次第一个人取剩下的sum - a[i]张牌中取自己的牌，以此类推。

（PS：真的醉了，自己怼代码%炸了三次int，看了楼下巨擘的方法才发现——我真的不应该求什么乘法逆元与组合数公式，自讨苦吃，希望大家平时做数论题注意好取模qwq）

0ms偷偷得意一下……~~虽然据我所知很多人都这样~~






```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 10005, p = 10007;
int n, m, a[N], sum, mul[N], ans;
int read() {
    int x = 0; char ch = getchar(); bool f = 0;
    while(!isdigit(ch)) {
        if(ch == '-') f = 1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ '0');
        ch = getchar();
    }
    return ! f ? x : -x;
}
int swift(int x, int k) {//费马小定理求逆元
    int tmp = 1; x %= p;
    while(k) {
        if(k & 1) tmp *= x, tmp %= p;
        x *= x; x %= p;
        k >>= 1;
    }
    return tmp;
}
int main() {
    n = read(); m = read(); mul[0] = 1;
    for(int i = 1; i <= m; i++) a[i] = read(), sum += a[i];
    for(int i = 1; i < N; i++) mul[i] = (mul[i - 1] * i) % p;//递推阶乘
    ans = (mul[n] * swift(mul[sum] * mul[n - sum], p - 2)) % p;//处理出上文所述的第一步
    for(int i = 1; i <= m; i++) {
        ans = (ans * ((mul[sum] * swift(mul[a[i]] * mul[sum - a[i]], p - 2)) % p)) % p;
        sum -= a[i];
```
}//枚举每一次剩下的情况
    printf("%d", ans);

    return 0;

}

---

## 作者：贵族血统 (赞：3)

题目意思很简单 如样例1 答案为c（5,3）\*c（5-3，1）

关键问题是如何求c（i，j）如果暴力会超范围，我试着用质因数分解优化一下，然后就超时了，代码如下（3个点超时只有70分）

```cpp
#include <cstdio>  
const int maxn=1000000; 
#include <vector>  
using namespace std; 
bool arr[maxn+1]={false}; 
vector<int> produce_prim_number() 
{ 
        vector<int> prim; 
        prim.push_back(2); 
        int i,j; 
        for(i=3;i*i<=maxn;i+=2) 
        { 
                if(!arr[i]) 
                { 
                        prim.push_back(i); 
                        for(j=i*i;j<=maxn;j+=i) 
                                arr[j]=true; 
                } 
        } 
        while(i<maxn) 
        { 
                if(!arr[i]) 
                        prim.push_back(i); 
                i+=2; 
        } 
        return prim; 
} 
//计算n!中素数因子p的指数  
int cal(int x,int p) 
{ 
        int ans=0; 
        long long rec=p; 
        while(x>=rec) 
        { 
                ans+=x/rec; 
                rec*=p; 
        } 
        return ans; 
} 
//计算n的k次方对m取模，二分法  
int pow(long long n,int k,int M) 
{ 
        long long ans=1; 
        while(k) 
        { 
                if(k&1) 
                { 
                        ans=(ans*n)%M; 
                } 
                n=(n*n)%M; 
                k>>=1; 
        } 
        return ans; 
} 
//计算C（n，m）  
int combination(int n,int m) 
{ 
        const int M=10007; 
        vector<int> prim=produce_prim_number(); 
        long long ans=1; 
        int num; 
        for(int i=0;i<prim.size()&&prim[i]<=n;++i) 
        { 
                num=cal(n,prim[i])-cal(m,prim[i])-cal(n-m,prim[i]); 
                ans=(ans*pow(prim[i],num,M))%M; 
        } 
        return ans; 
} 
int main() 
{ 
        int m,n; 
        while(~scanf("%d%d",&m,&n),m&&n) 
        { 
                printf("%d\n",combination(m,n)); 
        } 
        return 0; 
} 
```
然后只能换一个思路了= =直接把c（i，j）的表递推出来。参考01背包，得到递推关系c[i][j]=(c[i-1][j-1]+c[i-1][j])
然后就简单了

    
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int c[20000][200];
int main()
{
    int n,m,k,s=1;
    cin>>n>>m;
    c[0][0]=1;
    for (int i=1;i<=10001;++i){
        c[i][0]=1;
        for (int j=1;j<=101;++j) 
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%10007;
    }
    for(int a=1;a<=m;++a)
    {
        cin>>k;
        s=s*c[n][k]%10007;
        n-=k;
        if (n<0) break;
    }
    cout<<s;
}

```

---

## 作者：白木偶君 (赞：2)

**n个不同物品，m个组，每个组有容量,求物品放置方案数**

### ans=C(a[1],n)C(a[2],n-a[1])C(a[3],n-a[1]-a[2])...

### 简化一下

### ans=$\prod_{i=1}^m$C(a[i],n-sum[i-1])

预处理C数组,然后按照公式算就可以了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int mod=10007,N=1e4+5;
#define int long long
int n,m,a[N],sum[N];
int jc[N],inv[N];
inline int ksm(int x,int y){int ans=1;while(y){if(y&1)ans=ans*x%mod;x=x*x%mod;y>>=1;}return ans;}
int C(int x,int y){if(x>y)return 0;return jc[y]*inv[x]%mod*inv[y-x]%mod;}
inline void pre(){
	jc[0]=1;for(int i=1;i<=n;i++)jc[i]=jc[i-1]*i%mod;
	inv[n]=ksm(jc[n],mod-2);
	for(int i=n-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;
}
signed main(){
	cin>>n>>m;pre();
	for(int i=1;i<=m;i++)scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i];
	int ans=1;
	for(int i=1;i<=m;i++)
	ans=(ans*C(a[i],n-sum[i-1]))%mod;
	cout<<ans<<endl;
}
```

---


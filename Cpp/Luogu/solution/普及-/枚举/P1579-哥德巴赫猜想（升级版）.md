# 哥德巴赫猜想（升级版）

## 题目背景

1742 年 6 月 7 日，哥德巴赫写信给当时的大数学家欧拉，正式提出了以下的猜想：任何一个大于 $9$ 的奇数都可以表示成 $3$ 个质数之和。质数是指除了 $1$ 和本身之外没有其他约数的数，如 $2$ 和 $11$ 都是质数，而 $6$ 不是质数，因为 $6$ 除了约数 $1$ 和 $6$ 之外还有约数 $2$ 和 $3$。**需要特别说明的是 $1$ 不是质数。**

这就是哥德巴赫猜想。欧拉在回信中说，他相信这个猜想是正确的，但他不能证明。

从此，这道数学难题引起了几乎所有数学家的注意。哥德巴赫猜想由此成为数学皇冠上一颗可望不可及的“明珠”。

## 题目描述

现在请你编一个程序验证哥德巴赫猜想。

先给出一个奇数 $n$，要求输出 $3$ 个质数，这 $3$ 个质数之和等于输入的奇数。

## 样例 #1

### 输入

```
2009```

### 输出

```
3 3 2003```

# 题解

## 作者：IOCTYCNconbill (赞：198)


##//翻看了一下各位大犇的代码，好像没有和我一样的，鼓起勇气发一篇题解//代码有点短。
###  这个题目求任意一个大于九的奇数等于三个质数的和，题目说明了第一个质数要最小，其次第二个，据此可以进行优化循环的次数。然后就是进入正题了 ,首先先要明白一件事，三个数相加为奇数，只有两种可能
### ①两个偶数加一个奇数.
### ②三个奇数.
#### ①先判断前两个质数都是偶数的情况，因为偶数中只有2是素数，那么就只要判断这个（n-4）是否为素数，如果是，就直接输出2,2，n-4。
#### ②如果这三个数都是质数，那么从i=3开始循环，并保证i为奇数并且i为素数，再在第二重循环里面让j=i并保证j为奇数且j为素数，最后只要判断（n-i-j)是否为奇数且为素数就行了，满足就输出答案。


------------
```c
#include<bits/stdc++.h>
using namespace std;
int check(int x){
	for (int i=2;i*i<=x;i++)
	if(x%i==0) return 0;
	return 1;
}
int main(){
	int n;
	cin>>n;
	if(check(n-4)) {
	cout<<"2 "<<"2 "<<n-4;
    return 0;
    }     //第一种情况
	for (int i=3;i<n;i++)//第二种情况
	if((i%2)!=0&&check(i))//优化
	for (int j=i;j<n;j++)
		if((j%2)!=0&&check(j))//优化
		if(check(n-i-j)) {
		cout<<i<<" "<<j<<" "<<n-i-j;return 0;//不用循环第三个数，优化。
        }
	
}
```

---

## 作者：不准睡觉 (赞：59)

emmmm

看过那么多的大佬都是_O(n^2)_那我在这里发一个_O(n)_的来吸引大佬好了
```cpp
#include <bits/stdc++.h>
using namespace std;

int isNotPrime[20005] = {1};

int main()
{
    for (int i = 2; i < 20005; ++i)
        for (int j = i * 2; j < 20005; j += i)
            isNotPrime[j] = 1;
    
    int n;
    scanf("%d", &n);
    for (int i = 2; i < n - 2; ++i)
        if (!isNotPrime[i])
            if (!isNotPrime[n - 2 - i])
            {
                printf("2 %d %d\n", i, n - 2 - i);
                return 0;
            }
    for (int i = 3; i < n - 2; ++i)
        if (!isNotPrime[i])
            if (!isNotPrime[n - 3 - i])
            {
                printf("3 %d %d\n", i, n - 3 - i);
                return 0;
            }
    return 0;
}
```

做法：对于第一个数，2和3各试一次就行。
为什么是对的呢？
用现代的数学语言，哥德巴赫猜想可以陈述为：

_任一大于2的偶数，都可表示成两个素数之和。	_

并且已知哥德巴赫猜想在 _n < 4 * 10 ^ 18_ 的范围内并没有找到反例，所以偷个懒，就只试了2和3.（n 是奇数，那么 n - 3 一定是偶数啊）

---

## 作者：majorli (赞：23)

# 看到那么多题解没人用到埃筛所以忍不住把我的代码发上来

这个题目似乎非常适合用埃氏筛子先把20000以内的质数全部筛出来，然后一个简单的嵌套循环就可以解了。不知道为什么看了那么多大佬的题解都没有用埃筛的，就算有先打质数表的也基本都是用逐个测试质数的方法。

第一次忍不住发题解，说明以下几点：
1. 由于工作后一直从事大型软件开发，所以对代码风格比较注重。即使是算法编程我也坚持能不用全局变量就不用全局变量。所以我的代码里用引用传数组，有不明白的可以先了解一下C++ 使用引用传数组的语法。
2. 由于工作中纯C、Java和Python用得比C++都多得多，所以无可救药地喜欢printf和scanf，对不住喜欢cin，cout的大佬们了。
3. 因为一些诡异的强迫症病毒感染严重，所以从来不用无返回值的函数，所有函数都有返回值，确实没必要返回什么值的也会返回一个整数0，所以大佬们请原谅我的函数里有莫名其妙的return 0。
4. 为了方便初始化，我的埃筛用的数组和通常课本上的是反的，bool primes[]数组元素值为false的表示是质数，true反而表示不是质数。可能我把数组名字改成bool composite[]更合适，狂汗！大佬们求原谅。
5. 代码本身超级简单，主要是两个函数，erato()用来在指定的bool数组中进行质数筛选，find()用来分解n。另有一个工具函数next_prime用来迭代下一个质数。没有用到什么高大上的技术，从头到尾都是平铺直叙的代码。
6. find()函数由于第1个和第2个质数都是从2开始循环，所以带有点贪婪属性，可以保证第一个找到的解就是满足题目所要求的那种解。

好吧，直接看代码吧，刚刚AC的，速度也很快，每个测试点都是10ms以内的。埃氏筛子经过一些简单的优化，效率还是相当高的。


```cpp
#include <cstdio>

const int N = 20000;    // 长期从事工程开发的强迫症后果

int erato(bool (&primes)[N]);
int next_prime(int p, bool (&primes)[N]);
int find(int n, bool (&primes)[N]);

int main()
{
	bool primes[N] = { false };
	erato(primes);      // 埃筛，筛出所有质数先

	int n;
	scanf("%d", &n);
	find(n, primes);    // 去寻找解

	return 0;
}

int erato(bool (&primes)[N])
{
	for (int t = 2; t * t <= N;) {
		for (int i = t * t; i <= N ; i++) {
			if (primes[i]) continue;
			if (i % t == 0) primes[i] = true;
		}
		while (primes[++t]);
	}

	return 0;
}

int next_prime(int p, bool (&primes)[N])
{
	while (primes[++p]);
	return p;
}

int find(int n, bool (&primes)[N])
{
	bool found;
	for (int p1 = 2; p1 < n; p1 = next_prime(p1, primes)) {
		found = false;       // 有没有找到解的flag
		for (int p2 = 2; p2 < n; p2 = next_prime(p2, primes)) {
			int p3 = n - p1 - p2;
			if (p3 < 2)      // 说明这一轮p2全部试玩，应该换p1了
				break;
			if (primes[p3])  // p3不是质数，循环下一个p2
				continue;
			printf("%d %d %d\n", p1, p2, p3);
			found = true;    // 找到解了，把flag立起来，该返回了
			break;
		}
		if (found)           // 解已经找到，任务结束，跳出循环
			break;
	}

	return 0;
}

```

---

## 作者：Ge_er (赞：19)

# 这是本蒟蒻发布的第一篇题解，请各位大神多多指教！

主要思路：定义一个判断质数的函数，然后直接暴力枚举

~~真草率！~~ 

附上AC代码：
```
# include <cstdio>
using namespace std;

bool prime(int n)
{
	for (int i = 2; i * i <= n; i++)
		if (n % i == 0) return false;
	return true;
}

int main()
{
	int x;
	scanf ("%d", &x);
	for (int i = 2; i <= x / 3; i++)
	{
		if (!prime(i)) continue;
		for (int j = 2; j <= (x - i) / 2; j++)
		{
			if (!prime(j)) continue;
			int k = x - i - j;
			if (prime(k))
			{
				printf ("%d %d %d\n", i, j, k);
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：百里亦守约_test (赞：16)

看到这题的第一反应是难，但是打了一个质数表就感觉不难了。我的方法是枚举第一个数和第二个数，我们可以先用一个for循环枚举第一个数，如果在质数表里是质数，那么再用一个for枚举第二个数，如果第二个数和第三个数都是质数，那么就输出，并且结束循环。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,b,o;
int a[100000];
int main()
{
    cin>>n;
    a[1]=1;
    a[0]=1;
    for(int i=1;i<=trunc(sqrt(n));i++)
    {
        if(a[i]==0)
        {
          for(int j=2;j<=n/i;j++)
          {                     //质数表
              a[i*j]=1;
          }    
        }
    }
    for(int i=2;i<=n;i++)
    {
        b=n;
        if(a[i]==0)        //枚举第一个数
        {
            b-=i;
            for(int j=2;j<=b;j++)
            {
                if((a[j]==0)&&(a[b-j]==0))            //枚举第二个数和第三个数
                {
                    cout<<i<<" "<<j<<" "<<b-j<<endl;         //输出。
                    return 0;
                }
            }
        }
    }
}
```

---

## 作者：wfstupig (赞：8)

在下认为最简单的C语言程序

```cpp
#include <stdio.h>
int zs (int a)  //判断a是否为质数,是的话输出1，否则输出0
{int i;
 if (a==1) return 0;
 for (i=2;i*i<=a;i++)  //i从2到根号a，如果a整除i，就说明a不是质数
   if (a%i==0) return 0;
 return 1;
}
int n,a,b,c;
int main()
{scanf("%d",&n);  //输入一个数，这里我想说一下，事实上没必要管大于小于9的，题目肯定会给你合理的数
 for (a=2;a<=n-4;a++)  //a，b，c查找
   for (b=2;b<=n-4;b++) {
     c=n-a-b;
     if (zs(a) && zs(b) && zs(c)) {
       printf("%d %d %d",a,b,c);  //如果a，b，c都为质数，则输出，然后结束程序
       return 0;
     }
   }
}
```

---

## 作者：Vel_ (赞：5)

## Code  $O(n^2)$

当然最朴素的方法是遍历2个数`i,j`，对`i`,`j`,`n-i-j`验证素数。素数验证优化得好的话大约是$O(n^2\sqrt n)\rightarrow O(n\sqrt n)$吧。。

```c++
bool is_prime(int number){
    for(int i = 2; i*i <= number; i+=1)  //i*i是优化
        if(!(number % i)) return 0;
    return 1;
}
```

### Force $O(n^3)\rightarrow O(n)+O(n)$

如果做过之前的回文素数题的话，这道题就相当简单辣。。套板子就行。

先生成n范围内的质数（比如欧拉筛法），然后暴力组合验证。。不稳定。

```c++
#include<bits/stdc++.h>
using namespace std;

#define MAX_N 20005

bool prime[MAX_N];
int p_numbers[MAX_N], size = 0; //reserve primes

void Euler(int Length){  //about O(n)
    prime[0] = prime[1] = 0;
    for(int i = 2; i <= Length; ++i) prime[i] = 1; //initialize all as true
    for(int i = 2; i <= Length; ++i){
        if(prime[i]){
            p_numbers[size++] = i;
        }
        for(int j = 0; j <size && i*p_numbers[j] < Length; j++){
            prime[ i*p_numbers[j] ] = 0;  //sieve i*p_numbers[j]
            if(i % p_numbers[j] == 0)  //special
               break;
        }
    }
}

int main(){
    int n; cin>> n;
    Euler(n);
    for(int i = 0; i < size; ++i)
        for(int j = i; j < size; ++j)
            for(int k = j; k < size; ++k){
            	if(p_numbers[i]+p_numbers[j]+p_numbers[k]==n){
            		cout<<p_numbers[i]<<" "<<p_numbers[j]<<" "<<p_numbers[k];
            		return 0;
				} 
			}
}
```

### 稍微优化一下 $O(n^2)\rightarrow O(n)+O(n)$

注意到我们**并不需要遍历第三个循环**，因为`n`已知，第3个数一定是`n-p[i]-p[j]`。

然后就可以借助`prime`数组进行O(1)的判断辣。

> ~~怎么又是这个套路，好熟悉的感觉~~。。orz

```c++
#include<bits/stdc++.h>
using namespace std;

#define MAX_N 20005

bool prime[MAX_N];
int p_numbers[MAX_N], size = 0; //reserve primes

void Euler(int Length){  //about O(n)
    prime[0] = prime[1] = 0;
    for(int i = 2; i <= Length; ++i) prime[i] = 1; //initialize all as true
    for(int i = 2; i <= Length; ++i){
        if(prime[i]){
            p_numbers[size++] = i;
        }
        for(int j = 0; j <size && i*p_numbers[j] < Length; j++){
            prime[ i*p_numbers[j] ] = 0;  //sieve i*p_numbers[j]
            if(i % p_numbers[j] == 0)  //special
               break;
        }
    }
}

int main(){
    int n; cin>> n;
    Euler(n);
    for(int i = 0; i < size; ++i)
        for(int j = i; j < size; ++j)  //直接少了一个循环
        	if(prime[n - (p_numbers[i]+p_numbers[j])]){
        		cout<<p_numbers[i]<<" "<<p_numbers[j]<<" "<<n - (p_numbers[i]+p_numbers[j]);
        		return 0;
			} 
}
```

# 

---

## 作者：wanglishuang (赞：4)

水题，不多说，直接上程序

[codec ]

```cpp
#include<iostream>
#include<math.h>
using namespace std;
bool zhishu(int x)//判断是不是质数;
{
for(int i=2;i<=sqrt(x);i++)
if(x%i==0)
return false;
return true;
}
int main()
{
int m,a,b,c;
cin>>m;
for(a=2;a<=m;a++)//根本不需要刻意的去看结果的大小，只需要按顺序枚举就行了; 
for(b=2;b<=m;b++)
{
c=m-a-b;
if(zhishu(a)&&zhishu(b)&&zhishu(c)&&c>=2)//因为c是m-两数之和得来的，所以它要判断大小 
{
cout<<a<<" "<<b<<" "<<c;
return 0;
}
}
}
```
[/codec ]
新人发帖，望采纳！！！


---

## 作者：linzihao1999 (赞：3)


```cpp

#include <iostream>  
#include <cmath>  
using namespace std;  
int pri(int a)  //判断质素
{  
    for(int i=2;i<=sqrt(a);i++)if(a%i==0)return 1;  
    return 0;  
}  
int main(int argc, char *argv[])  
{  
    int n,a,b,c;  
    cin >> n;  
    for(int i=2;i<n;i++) // 找到第一个数
    {  
        if(pri(i)==0) for(int j=2;j<n-i;j++)  //判断第一个数是否为质素，如果是这寻找第二个数
        {  
            if(pri(j)==0&&pri(n-i-j)==0) //找到2个数自然确定了第三个数 ，并判断第二和第三个数为质素
            {cout << i << ' ' << j << ' '<< n-i-j; return 0;}  
        }  
    }  
}  

```

---

## 作者：凌墨 (赞：2)

###  蒟蒻首发
在两位巨佬@蒟蒻365 @BCZSX的帮助下成功AC,为表感恩，供上题解。
请各位巨佬多多指教！
~~10009的数据快把小蒟蒻逼疯了~~
废话不多说，上代码：
```c
#include<bits/stdc++.h>
using namespace std;
int zhishu(int x) {
    if(x==0||x==1) return 0;
    for(int i=2; i*i<=x; i++) {
        if(x%i==0) {
            return 0;
        }
    }
    return 1;
}
int main() {
    int n;
    cin>>n;
    if(zhishu(n-4)){
        cout<<"2"<<" "<<"2"<<" "<<n-4;
        return 0;
    }
    for(int i=3;i<n;i+=2){
        if(zhishu(i))
        {
            for(int j=3;j<n;j+=2)
            {
                if(zhishu(j)&&zhishu(n-i-j))
                {
                    cout<<i<<" "<<j<<" "<<n-i-j;
                    return 0;
                }
            }
        }
    }
}
```











```c
include<bits/stdc++.h>
using namespace std;

int zhishu(int x){

for(int i=2;i*i<=x;i++){

    if(x%i==0){

        return 0;
    }
}
return 1;
} int main(){

int n;

cin>>n;
if(zhishu(n-4)){
    cout<<"2"<<" "<<"2"<<" "<<n-4;
    return 0;
}
for(int i=3;i<n;i+=2){
    if(!zhishu(i)) continue;
    for(int j=i;j<n;j+=2){
        if(zhishu(j)){ 
            if(zhishu(n-i-j)==1){
                cout<<i<<" "<<j<<" "<<n-i-j;
                return 0;
            } 
        }
    }

}
}
```

---

## 作者：plazum (赞：1)

也可以先用朴素的筛法把质数/素数筛出来……

```cpp

#include<iostream>
#include<memory.h>
using namespace std;
int n,i,j/*,pnum,p[2262]*/;
bool f[20001];
void shai()
{
    int k=1;
    memset(f+2,true,sizeof(f)-2);
    while(k<=n){
        do k++;while(!f[k]);
        for(j=k*2;j<=n;j+=k)f[j]=false;
    }
//    for(j=2;j<=n;j++)if(f[j])p[pnum++]=j;
}
int main()
{
    cin>>n;
    shai();
//    for(;i<pnum;i++)cout<<p[i]<<' ';
    for(i=2;i<=n/3;i++)
        for(j=i;j<=n/2;j++)
            if(f[i]&&f[j]&&f[n-i-j]){cout<<i<<' '<<j<<' '<<n-i-j;return 0;}
    
    return 0;
}

```

---

## 作者：Das_Reich (赞：1)

从小到大枚举就可以了·····

```delphi

program p1579;
var
  i,j,n:longint;
function prime(num:longint):boolean;
var
  i:longint;
begin
  if (num=1)or(num=0) then exit(false);
  if num=2 then exit(true);
  for i:=2 to trunc(sqrt(num)) do if num mod i=0 then exit(false);
  exit(true);
end;
begin
  readln(n);
  for i:=1 to n do
    begin
      if not prime(i) then continue;
      for j:=i to n-i-1 do
        begin
          if not prime(j) then continue;
          if prime(n-i-j) then
            begin
              writeln(i,' ',j,' ',n-i-j);
              halt;
            end;
        end;
    end;
end.

```

---

## 作者：herofox (赞：1)

首先需要先用一个函数来判断质数

然后在main函数中生成20000以内的所有质数（用p[]保存，p[0]可直接初始化为2）

输入后开始循环，查找方法，为了确保输出时是从小到大输出，if语句中的条件如代码所示

最后一定要注意两点：

1.输出的最后一个质数之后没有空格

2.切记及时退出循环，否则可能输出多组答案

```cpp

#include <iostream>
#include <cmath> 
using namespace std;
bool prime(int x)
{
    bool b=true;
    for(int i=2;i<=sqrt(x);i++)
    {
        if(x%i==0)
            b=false;
    }
    return b;
}
int main()
{
    bool b=false;
    int n;
    long long p[30000];
    int i,j=1;
    p[0]=2;
    for(int i=3;i<20000;i+=2)
    {
        if(prime(i)==true)
        {
            p[j]=i;
            j++;
        }
    }
    cin>>n;
    for(int i=0;i<2263;i++)
    {
        for(int j=i;j<2263;j++)
        {
                if(prime(n-p[i]-p[j])==true&&(n-p[i]-p[j]>0)&&(p[i]<=p[j])&&(p[j]<=n-p[i]-p[j]))
                {
                    cout<<p[i]<<" "<<p[j]<<" "<<n-p[i]-p[j];
                    b=true;
                    break; 
            }
        }
        if(b==true)
            break;
    }
}

```

---

## 作者：chenjianye (赞：1)

我做这个题有三次：

第一次，暴力枚举

把1~10000的质数从网上抠下来，再用按键精灵敲',',代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int i,n;
	int a[10001]={0,2,3,5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359,367 ,373 ,379 ,383 ,389 ,397 ,401 ,409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521 ,523 ,541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643 ,647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757 ,761,769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839 ,853, 857, 859, 863, 877, 881, 883 ,887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973};//暴力不！！！
	cin>>n;
	int j,k,l;
	for(j=1;j<=n;j++)
	{
		for(k=1;k<=n;k++)
		{
			for(l=1;l<=n;l++)
			{
				if(a[j]+a[k]+a[l]==n)
				{
					cout<<a[j]<<" "<<a[k]<<" "<<a[l];
					return 0;
				}
			}
		}
	}
	return 0;
}
```
结果wa。

第二次，
略有改进，把素数都打到一个数组离去；

代码如下

```cpp

using namespace std;
int i,j,k,l;
bool ok(int x)
{
    for (int i=2;i<=sqrt(x);i++)
        if (x%i==0)
            return false;
    return true;
}
int main()
{
	int a[10001],sum=1,n;
    cin>>n;
    for(i=2;i<=10000;i++)//打进数组
    {
    	if(ok(i)==true)
    	{
    		a[sum]=i;
    		sum++;
		}
	}
	for(j=1;j<=n;j++)
	{
		for(k=1;k<=n;k++)
		{
			for(l=1;l<=n;l++)
			{
				if(a[j]+a[k]+a[l]==n)
				{
					cout<<a[j]<<" "<<a[k]<<" "<<a[l];
					return 0;
				}
			}
		}
	}
}
```
此为60分代码。

第三次，
继续完善，不用打到数组离去，直接判断，去掉'k'的循环
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,i,j,k;
bool ok(int x)
{
    for (int i=2;i<=sqrt(x);i++)
        if (x%i==0)
            return false;
    return true;
}
int main()
{
    cin>>a;
    for(i=2;i<=a-4;i++)
        for(j=2;j<=a-4;j++)
        {
            k=a-i-j;//得到k
            if(ok(i)&&ok(j)&&ok(k)) //判断i,j,k是否为素数
            {
                cout<<i<<' '<<j<<' '<<k;
                return 0;
            }
        }
}
```
最后 100分了！！！！

仅供参考，禁止抄袭！！！！！！

---

## 作者：lych (赞：1)

其实本题还是十分简单的，只要在原有基础上再加一点点就可以了，因此直接给出程序，思路也在程序中给出。

```delphi
var
  i,n:longint;
function prime(x:longint):boolean;
var i:longint;
begin
  for i:=2 to trunc(sqrt(x)) do//到平方根就足矣了
    if x mod i=0 then exit(false);
  exit(true);
end;//判断是否是质数
begin
  read(n);
  if prime(n-4) then//首先判断它-4是否是质数
    begin write(2,' ',2,' ',n-4); halt; end;
  write(3,' ');//否则一定是三开头的，因为一个偶数一定能拆分为两个质数
  n:=n-3;//减去三再做哥德巴赫
  for i:=3 to n shr 1 do
    if prime(i) and prime(n-i) then
      begin writeln(i,' ',n-i); break; end;//哥德巴赫，不多解释
end.[cedep/]


---

## 作者：noall (赞：0)

哇！A一道橙题居然$TLE$了三次，难道这个年代连暴力都水不过去吗？

突然感觉~~水多了黄题，橙题都不会做了~~

### ispriem(num)枚举
作为一个橙题题解，也需要详细一点啦！

~~实际上是为了求管理员大人通过~~$QwQ$

这个函数是判断是否为素数，是则```true```，非则```false```

实现很简单

自然可以枚举从小到大的每个数看是否能整除

**当然，除数不能为`1`和原数`num`，所以从2开始，到num-1结束**

```c++
bool isprime(int num){
    for(int i=2;i<num;++i){
        if(!(num%i)){
            return false;
        }
    }
    return true;
}
```

### 40分代码
直接暴力枚举这三个数，三个```for```直接刚上去，我\*\*，那个爽，$40$分，$TLE$

用```sum```判断$i+j+z$是否等于$n$

```c++
#include<cstdio>
bool isprime(int num){
    for(int i=2;i<num;++i){
        if(!(num%i)){
            return false;
        }
    }
    return true;
}
int main(){
    int n,sum=0;
    scanf("%d",&n);
    for(int i=2;i<n;i++){
        if(isprime(i)==true){//如果是素数
            sum+=i;
            for(int j=2;j<n;j++){
                if(isprime(j)==true){//如果是素数
                    sum+=j;
                    for(int z=2;z<n;z++){//其实完全不需要这个for，只需要（n-i-j）即可，但我当时傻啊！
                        if(isprime(z)==true){//如果是素数
                            sum+=z;
                            if(sum==n){//如果找到了这三个数，输出并退出即可
                                printf("%d %d %d",i,j,z);
                                return 0;
                            }
                            sum-=z;//不是这个数
                        }
                    }
                    sum-=j;//不是这个数
                }
            }
            sum=0;//不是这个数
        }
    }
}
```
这个就不消讲了吧！
### 讲80分代码之前，讲一下isprime(num)优化
我们虽然可以枚举，但毕竟效率太低，怎么办呢？

其实我们不必要每个数都需要判断

很容易发现这样一个事实：如果$x$是$a$的约数，那么$\frac{a}{x}$也是$a$的约数。

这个结论告诉我们，对于每一对$(x,\frac{a}{x})$，只需要检验其中的一个就好了。为了方便起见，我们之考察每一对里面小的那个数。不难发现，所有这些较小数就是$[1,\sqrt{a}]$这个区间里的数。

那么，综上所述，也就有了新一代```isprime(num)```

```c++
bool isprime(int num){
	for(int i=2;i*i<=num;++i){
		if(!(num%i)){
			return false;
		}
	}
	return true;
}
```

### 80分代码
```c++
#include<cstdio>
bool isprime(int num){
    for(int i=2;i*i<=num;++i){
        if(!(num%i)){
            return false;
        }
    }
    return true;
}
int main(){
    int n,sum=0;
    scanf("%d",&n);
    for(int i=2;i<n;i++){
        if(isprime(i)==true){
            sum+=i;
            for(int j=i;j<n;j++){
                if(isprime(j)==true){
                    sum+=j;
                    for(int z=j;z<n;z++){
                        if(isprime(z)==true){
                            sum+=z;
                            if(sum==n){
                                printf("%d %d %d",i,j,z);
                                return 0;
                            }
                            sum-=z;
                        }
                    }
                    sum-=j;
                }
            }
            sum=0;
        }
    }
}
```

就是将```isprime```优化了一下

### （~~AK~~）AC代码
优化到这里，我懵了，还能怎么优化。

我真是太弱了，十分钟之后，我明白了。

最后那个```for```根！本！不！需！要！

因为是三个数，而且结果一定是$i+j+z==n$,那么```for(z)```就可以被替换为```(n-i-j)```

```c++
#include<cstdio>
bool isprime(int num){
	for(int i=2;i*i<=num;++i){
		if(!(num%i)){
			return false;
		}
	}
	return true;
}
int main(){
	int n,sum=0;
	scanf("%d",&n);
	for(int i=2;i<n;i++){
		if(isprime(i)==true){
			sum+=i;
			for(int j=i;j<n;j++){
				if(isprime(j)==true){
					sum+=j;
					if(isprime(n-i-j)==true&&(n-i-j)>0){//要判断必须大于0
						sum+=(n-i-j);
						if(sum==n){
							printf("%d %d %d",i,j,n-i-j);
							return 0;
						}
						sum-=(n-i-j);
					}
					sum-=j;
				}
			}
			sum=0;
		}
	}
}
```

我太弱了！！！

---

## 作者：qAzXsW_ (赞：0)

看了半天好像没有直接枚举素数的……

感觉这样会快一点点，所以我偷偷地

（要是有重复当我没发好了



思路：打表，把小于输入的数的素数挑出来，然后用两重for循环枚举..我表达不出来，还是看代码吧
```
#include<bits/stdc++.h>
using namespace std;
int js,p[20005],prime[3000],cnt=1;
```
js：输入的奇数（毫无逼格的变量名

p和prime下面再解释，cnt是输入的数字之内的素数个数

```
int main()
{
	cin>>js;
	for(int i=2;i<=js;i++)
	{
		p[i]=i;
	}
	for(int i=2;i<=js;i++)
	{
		if(p[i]==i)
		{
			prime[cnt]=i;
			cnt++;
			for(int j=i*2;j<=js;j+=i)
			{
				p[j]/=i;
			}
		}
	}
	cnt-=1;
```
打素数表。我不知道是什么筛，反正写得很爽...

由代码我们可以知道，如果p[i]==i，那么i是素数；prime[1]~prime[cnt]里面的都是素数，而且从小到大排列。

然后我们就可以暴力了。

```
	for(int a1=1;a1<=cnt;a1++)
	{
		for(int a2=1;a2<=cnt;a2++)
		{
			int left=js-prime[a1]-prime[a2];
			if(p[left]==left&&left!=0)
			{
				cout<<prime[a1]<<" "<<prime[a2]<<" "<<left;
				return 0;
			}
		}
	}
```

left不是左，是leave的形容词形式，是输入的数减去前面枚举的质数之后剩下的数。

这个算法的时间复杂度是多少呢？可能是nlogn吧，可能是cnt^2吧……本蒟蒻不会算，但就是觉得很舒服。（逃

---

## 作者：桑棋宗 (赞：0)

这题可以用线性筛质数来水（雾）
```c
#include <iostream>
#include <cstdio>
#include <cmath>
#define I 2000000
using namespace std;
int p[I],c[I],n;
/*n为给出数，c[I]用来判断是否为质数和将非质数存上消掉它的较小的质数的下标（看看代码你就懂了），p[I]用来存质数*/
int k=0;
void prime(int n)  /*求出1~n内所有的质数*/
{
	c[0]=c[1]=1;//是质数就为0，不是就存上其他数（2以后的非质数不能乱存）
	for(int i=2;i<=n;i++)
	{
		if(!c[i])//判断当前的数是否为质数
		{
			p[++k]=i;//存质数
			for(int j=1;j<=k&&i*p[j]<=n;j++)//判断是否超界
			   c[i*p[j]]=j;//将质数的倍数排除并做上标记
		}
		else
		{
			for(int j=1;j<=c[i]&&i*p[j]<=n;j++)
			c[i*p[j]]=j;//将非质数的倍数再排除
		}
	}
}

int main()
{
    scanf("%d",&n);
    
    prime(n);
    
    int m;
    
    m=n;
    
    for(int i=1;i<=k;i++)//因为要输出要前2项最小，所以直接从最小的开始算
    
    {   m-=p[i];//减去最小的第一项
    
    	for(int j=i;j<=k&&m>0;j++)
        
    	{	
        m-=p[j];//减去最小的第二项项
			if(!c[m]&&m>0)//直接用c[I]判断是否为质数,注意要判断m是否为正数
            { 
            cout<<p[i]<<" "<<p[j]<<" "<<m; return 0;//符合答案，直接输出与结束
            }
		m+=p[j];//减掉的要补回来
		}
	m+=p[i];//减掉的要补回来
	}
    return 0;
}
```

---

## 作者：bobble (赞：0)

其实直接暴力枚举就可以了，不过要注意在判断质数时要排除小于2的数，恩，上代码————

```cpp
program gdbh;
var
  n,i,j:longint;
function check(temp:longint):boolean;
var
  xx:longint;
begin
  if temp<2 then exit(false);
  for xx:= 2 to trunc(sqrt(temp)) do
    if temp mod xx=0 then exit(false);
  exit(true);
end;
begin
  readln(n);
  for i:= 2 to n-1 do
    if check(i) then 
      for j:= 2 to n-i do
        if (check(j)) and (check(n-i-j)) then begin
                                                 writeln(i,' ',j,' ',n-i-j);
                                                 halt;
                                              end;
end.
```

---

## 作者：Lynx (赞：0)

```cpp

#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;
bool ss(int i)//判断素数 
{
    int x=2;
    while(x<=floor(sqrt(i))&&i%x!=0)
        x++;
    if(x>sqrt(i))
        return 1;
    return 0;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=2;i<=n-4;i++)//枚举 
        if(ss(i))//若不为素数，则继续寻找 
            for(int j=i;i+j<=n-2;j++)//保证n-i-j>=2 
                if(ss(j))
                    if(ss(n-j-i))
                        {
                            printf("%d %d %d\n",i,j,n-j-i);//输出 
                            return 0;
                        }
    return 0;
}

```

---

## 作者：smzzl (赞：0)

有毒的题目，本来以为要用哥德巴赫猜想（普通版）的方法来改进，结果做不出来，后来看了题解说爆搜就ac了，水体，但注意别用for循环，会超时一个点（pascal）

```delphi
program ffsadfsdfds;  
var i2,j2,k2,i1,j1,k1,n:longint;  
    function prime(x:longint):boolean;  
    var i,j,k,l:longint;  
    begin  
    prime:=true;  
    if x=1 then prime:=false  
      else if x=2 then prime:=true  
        else begin  
             i:=2;  
             while (i<=round(sqrt(x))) and (x mod i<>0) do i:=i+1;  
             if i<=round(sqrt(x)) then prime:=false;  
             end;  
    end;  
  
    procedure dayin(i,j,k:longint);  
    begin  
   // writeln(i,j,k);  
    if (i<=j) and (i<=k) then begin write(i,' '); if k<=j then write(k,' ',j) else write(j,' ',k); exit;end;  
    if (j<=k) and (j<=i) then begin write(j,' '); if k<=i then write(k,' ',i) else write(i,' ',k);exit;end;  
    if (k<=j) and (k<=i) then begin write(k,' '); if i<=j then write(i,' ',j) else write(j,' ',i);exit;end;  
    end;  
  
begin  
readln(n);  
i1:=2;  
j1:=2;  
k1:=2;  
while i1<=n do  
 begin j1:=1;  
  while j1<=n do  
   begin k1:=1;  
    while k1<=n do  
     begin  
        if (i1+k1+j1=n) and (prime(i1)=true) and (prime(j1)=true) and (prime(k1)=true) then begin dayin(i1,j1,k1);      halt; end;  
  
         if k2<>100 then begin k2:=100; k1:=k1+1;end else k1:=k1+2 ;  
     end;  
     if j2<>100 then begin j2:=100; j1:=j1+1;end else j1:=j1+2 ;  
    end;  
   if i2<>100 then begin i2:=100; i1:=i1+1;end else i1:=i1+2 ;  
   end;  
  end.  
  
  
  
  
end.  
```

---

## 作者：LXHLXH (赞：0)

```cpp
var n,i,j,s,k,f:longint;
    a,b:array[0..20006] of longint;
begin
  readln(n);
  for i:=1 to n do a[i]:=1;//记得一定清
  a[1]:=0;//记得一定清
  for i:=2 to trunc(sqrt(n)) do//求素数
    if a[i]=1 then
      for j:=2 to n div i do
        a[i*j]:=0;
  s:=0;
  for i:=2 to n do
    if a[i]=1 then
      begin
        inc(s);
        b[s]:=i;
      end;
  f:=0;
  for i:=1 to s do
    begin
      for j:=1 to s do
        begin
          for k:=s downto 1 do//AC的不会超
            if b[i]+b[j]+b[k]=n then
              begin
                writeln(b[i],' ',b[j],' ',b[k]);
                f:=1;
                break;
              end;
          if f=1 then break;
        end;
      if f=1 then break;
    end;
end.
```

---

## 作者：wuliang1 (赞：0)

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
using namespace std;
#define N 40000
#define QN 200
int a[N];
int prime[N];
int main()
{
    int n;
    cin>>n;
    memset(a,0,sizeof(a));
    for(int i=2; i<QN; i++)//打素数表
        if(!a[i])
        {
            for(int j=i*i; j<N; j+=i)a[j]=1;
        }
    int ans=0;
    for(int i=2; i<N; i++)
        if(!a[i])prime[ans++]=i;//取出所有素数放进数组
    for(int i=0; i<ans; i++)
        for(int j=0; j<ans; j++)
            for(int k=0; k<ans; k++)
            {
                if(prime[i]+prime[j]+prime[k]==n)//枚举所有情况
                {
                    cout<<prime[i]<<" "<<prime[j]<<" "<<prime[k]<<endl;
                    return 0;
                }
            }
}

```

---

## 作者：ZYR_ (赞：0)




```cpp
program gdbhcx(input,output);
label 1;
var
a,b,i,j,k,t1,t2,t3:longint;
function zs(n:integer):boolean;        //判断素数
var
i,t:longint;
begin
t:=0;
for i:=2 to n-1 do
if n mod i=0 then inc(t);
if t=0 then zs:=true
       else zs:=false;
end;
begin
t1:=100000;
t2:=100000;
t3:=100000;
readln(a);
for i:=2 to a div 3 do
  for j:=2 to a div 3 do
    for k:=2 to a-4 do      //放心，不会超时
    if (i+j+k=a) and (zs(i)=true) and (zs(j)=true) and (zs(k)=true) then if i<t1 then if j<t2 then begin t1:=i; t2:=j; t3:=k; writeln(i,' ',j,' ',k); end
                                                                                              else goto 1
                                                                                 else goto 1;
1:end.
```
我的思路好像和上面几位大神的不一样，反正AC了

---

## 作者：eagadsgbsadfhb (赞：0)

这题主要考验枚举和判质数，关键是要会有方法得枚举，地毯式搜索可能超时。

```cpp
#include<stdio.h>
#include<math.h>\开math库，因为用了sqrt(开方)
int main(){
    int n,k,i,j;
    bool c[20010];
    scanf("%d",&n);
    for (i=2;i<=int (sqrt(n));i++)
        if (!c[i])
            for (j=i*i;j<=n;j=j+i)
                c[j]=1;\给所有质数赋值为1
    for (i=2;;i++)\在循环内部终止，所有不设终止条件
        {
        k=n;\以免改变n
        if (!c[i])\i不是质数就继续循环
           {
            k=k-i;
            for (j=2;j<=k-2;j++)
                if (!(c[j]||c[k-j]))
                    {
                    printf("%d %d %d",i,j,k-j);
                    goto n;\都是质数就跳出循环
                }
        }
    }
    n:;
    return 0;
}
```

---

## 作者：ZStarShadow (赞：0)

这道题相当水，可以先将2~n-4之间的素数先算出来。


```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> dealCheck;

void dealFindCheck(int in)
{
    for (int i = 2; i <= in - 4; i++) {
        bool dealCheckTemp = false;
        for (int j = 2; j <= i - 1; j++) {
            if (i % j == 0) {
                dealCheckTemp = true;
                break;
            }
        }
        if (dealCheckTemp == false) dealCheck.push_back(i);
    }
}

int main()
{
    int inN = 0;
    cin >> inN;
    dealFindCheck(inN);
    for (int i = 0; i <= dealCheck.size() - 1; i++) {
        for (int j = 0; j <= dealCheck.size() - 1; j++) {
            for (int k = 0; k <= dealCheck.size() - 1; k++) {
                if ((dealCheck[i] + dealCheck[j] + dealCheck[k]) == inN) {
                    cout << dealCheck[i] << ' ' << dealCheck[j] << ' ' << dealCheck[k] << endl;
                    return 0;
                }
            }
        }
    }
}
```（c/c++）


---

## 作者：雷电音 (赞：0)

实际上只要枚举就可以过此题，不过无论是在时间还是空间方面估计都不算最优。

```delphi

var a,n,b,c,gb:longint;
    zhishu:array[1..2262] of longint;
    shu:array[2..20000] of longint;
procedure sf;
begin
 for a:=2 to 20000 do
   if shu[a]<>0 then
     begin
      zhishu[gb]:=shu[a];
      inc(gb);
      for b:=2 to 20000 div shu[a] do shu[shu[a]*b]:=0;
     end
   else continue;
 dec(gb);
end;
begin
 readln(n);
 gb:=1;
 for a:=2 to 20000 do shu[a]:=a;
 sf;
 for a:=1 to 2262 do
   for b:=a to 2262 do
     for c:=b to 2262 do
       if zhishu[a]+zhishu[b]+zhishu[c]=n then
         begin
          writeln(zhishu[a],' ',zhishu[b],' ',zhishu[c]);
          exit;
         end
         else continue;
end.

```

---

## 作者：Ufowoqqqo (赞：0)

首先，三个加数必须是质数，因此我们先枚举2~n范围内的质数，这些数都有可能作为加数。

其次，枚举前两个加数，第三个加数自然也就求出来了，判断其是否质数，如果是则满足条件，输出解并退出即可。

注意：此解法仅适用于数据范围较小的情况下，更大范围的数据还需要更优算法来实现！

```delphi

var
 n,i,j:longint;
 a:array [0..20000] of longint;
 b:array [0..20000] of boolean;

function prime(n:longint):boolean;//判断质数
var
 i:longint;
begin
 prime:=true;
 for i:=2 to trunc(sqrt(n)) do
  if n mod i=0 then exit(false);
end;

begin
 read(n);
 for i:=2 to n do
  if prime(i) then
   begin
    inc(a[0]);
    a[a[0]]:=i;
    b[i]:=true;//桶排，供后面判断第三个加数是否质数时用
   end;
 for i:=1 to a[0]-1 do//枚举
  for j:=1 to a[0] do
   if (a[i]+a[j]<=n){当a[i]+a[j]>n时该方案肯定不成立} and (b[n-a[i]-a[j]]) then
    begin
     writeln(a[i],' ',a[j],' ',n-a[i]-a[j]);
     halt;
    end;
end.

```

---

## 作者：xvhuanlin (赞：0)

因为数据范围小，可以用普通的素数筛，筛出所有范围内的素数，然后按大小枚举，找到正确解即输出，结束程序即可。


---

## 作者：上进的z君 (赞：0)





```cpp
var
i,j,k,n:longint;
a:array[1..2300]of longint;
l:array[1..3]of longint;
procedure zs;
var i,j:longint;f:boolean;
begin
k:=1;a[1]:=2;
for i:=3 to 19999 do
begin
f:=true;
for j:=1 to k do
if i mod a[j]=0 then begin f:=false;break;end;
if f then begin inc(k);a[k]:=i;end;
end;
end;
procedure search(t,sum:longint);
var i,j:longint;
begin
if t>3 then begin
if sum=0 then begin writeln(l[1],' ',l[2],' ',l[3]);halt;end;
exit;end;
for i:=1 to k do
if sum>=a[i] then begin
sum:=sum-a[i];l[t]:=a[i];
search(t+1,sum);
sum:=sum+a[i];
end;
end;
begin
zs;
readln(n);
search(1,n);
end.
事实上，可以直接枚举三个数，然后判断是否为质数就可以过了。
```

---


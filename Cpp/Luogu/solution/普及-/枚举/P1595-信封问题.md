# 信封问题

## 题目描述

某人写了 $n$ 封信和 $n$ 个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 20$。

## 样例 #1

### 输入

```
2```

### 输出

```
1```

## 样例 #2

### 输入

```
3```

### 输出

```
2```

# 题解

## 作者：Planet6174 (赞：1104)

**点赞请戳屏幕右下角粉色的圆 QwQ**

洛谷不支持 Flash 很蛋疼啊  
我本来想做成交互式内容的，现在只能疯狂贴图……

---

### 你需要知道哪些信息学知识：
递推/简单DP。没了。

---

### 面向小学生的（并非严谨的）数学前置技能
1. 数集：一堆的**互不相同的**数放在一起。
2. 元素：数集中的一个数称为这个数集的一个元素。
3. 数学上的函数：$f(x)=$ 表达式  
转化为信息学的写法长成这样：
```cpp
double f(double x) {
     return 表达式;
}
```
4. 一一对应：通俗的说法就是一个萝卜一个坑。  
数学上两个数集一一对应指的是：  
有两个数集 $A$ 和 $B$，  
对于 $A$ 里面任意一个数，在 $B$ 中都能找到一个数与之对应；  
并且对于 $B$ 里面任意一个数，在 $A$ 中也一定能找到一个数与之对应，  
那么，数集 $A$ 与数集 $B$ 一一对应。

---

### 问题

> 有 $n$ 个箱子，颜色分别为 $1\dots n$；还有 $n$ 个球，颜色也分别为 $1\dots n$。现在要将每一个球分别放入一个箱子里，并且一个箱子里只能放一个球。

![1.png](https://i.loli.net/2018/08/13/5b70c96309855.png)

> 试求有多少种方案满足：每个箱子，和它里面球的颜色，都不一样。

> 下图使用一种不知道叫啥的线表示哪个球**不能放进**哪个箱子里（再三强调**不能放进**，有些小盆友还以为是哪个球放哪个箱子里……）。后文还会多次出现这种不知道叫啥的线。

![2.png](https://i.loli.net/2018/08/13/5b70c96ce2e27.png)

→→此处我们把 $X$ 号球 **不能放进** $Y$ 号箱称为一组**对应关系**，简写为 $X\sim Y$（注意，这不是书上正经的讲法和符号，这里这样写只是为了方便），画在图中就用这种不知道叫啥的线。←←

于是，我们换一种方式描述题目：试求有多少种方案满足：$1\sim 1$，$2\sim 2$，……，$n\sim n$。

很多人学错排问题时，就只知道上面这种形式。然而，他们没有抓住错排问题的本质。我变一下，如果 $1\sim 2$，$2\sim 3$，……，$n-1\sim n$，$n\sim 1$，答案和上面一样吗？

![3.png](https://i.loli.net/2018/08/13/5b70c96f04b27.png)

一样吧？那下面这种对应关系呢？

![4.png](https://i.loli.net/2018/08/13/5b70c9711d204.png)

有点乱，但答案一样吧？但是，下面这几个呢？

![5.png](https://i.loli.net/2018/08/13/5b70d078d4cd3.png)

![6.png](https://i.loli.net/2018/08/13/5b70d078d604a.png)

看起来不对劲。前者出现了一对多、多对一，后者出现了有些球和箱子没有对应。没错，答案会不一样。

那么，你搞清楚了正确定义了吗？

$\ $

有 $n$ 个球，$n$ 个箱子。某个箱子不能放某一个球，其他球都可以放进去；反过来，某个球一定不能放进某个箱子，并且其他箱子都允许放进去。  
现在要将每个球分别放进一个箱子里，一个箱子里只能放一个球。求方案数。

$\ $

---

现在，我们进入核心部分：

### 递推式

回到开头给的题目。

数学上我们用 $D_n$ 表示有 $n$ 个球 $n$ 个箱子时的方案数。自己简单算一下可以得出 $D_1=0,$ $D_2=1,$ $D_3=2$。

我们来看下 $D_n(n\ge 4)$ 的情况。要推出怎么做，需要分类讨论。不妨分成 $n-1$ 种情况：$n$ 号球放进了 $1$ 号箱子，$n$ 号球放进了 $2$ 号箱子…… $n$ 号球放进了 $n-1$ 号箱子（现在我们在讲开头的题目，所以 $n$ 号球不能放进 $n$ 号箱子）。注意，分类讨论时要搞清楚是否涵盖了所有的情况。我们可以把所有情况列出来：

> 把 $n$ 号球放进： 
> - $1$ 号箱子
> - $2$ 号箱子
> - ……
> - $(k-1)$ 号箱子
> - **$\text{k}$ 号箱子**
> - $(k+1)$ 号箱子
> - ……
> - $(n-1)$ 号箱子

现在，我们只着眼于一种情况：$n$ 号球放进了 $k$ 号箱子。

![7.png](https://i.loli.net/2018/08/14/5b72a7c8aa242.png)

现在，我们再分为两种情况：一种是 $k$ 号球放进了 $n$ 号箱子，另一种是 $k$ 号球没有放进 $n$ 号箱子。

> 把 $n$ 号球放进： 
> - $1$ 号箱子
> - $2$ 号箱子
> - ……
> - $(k-1)$ 号箱子
> - $\text{k}$ 号箱子
>  * **$\text{k}$ 号球放进了 $\text{n}$ 号箱子**
>  * **$\text{k}$ 号球没有放进 $\text{n}$ 号箱子**
> - $(k+1)$ 号箱子
> - ……
> - $(n-1)$ 号箱子

如果 $k$ 号球放进了 $n$ 号箱子：

![8.png](https://i.loli.net/2018/08/14/5b72a7c8a98a7.png)

我们可以发现，如果不看 $k$ 号球 $k$ 号箱子 $n$ 号球 $n$ 号箱子，那么，将剩下的球按规定放进剩下的箱子有 $D_{n-2}$ 种方案。

> 把 $n$ 号球放进： 
> - $1$ 号箱子
> - $2$ 号箱子
> - ……
> - $(k-1)$ 号箱子
> - $\text{k}$ 号箱子
>  * $\text{k}$ 号球放进了 $\text{n}$ 号箱子 $\longrightarrow$ $D_{n-2}$ **种方案**
>  * $\text{k}$ 号球没有放进 $\text{n}$ 号箱子
> - $(k+1)$ 号箱子
> - ……
> - $(n-1)$ 号箱子

$\ $

为了和上面区分，这里我们描述为：如果 $k$ 号球**不能**放进 $n$ 号箱子。

动脑筋想想，这个东西是不是可以写成 $k\sim n$？（回到上面读读 $\sim$ 的定义）

![9.png](https://i.loli.net/2018/08/14/5b72a84108568.png)

我们可以发现，如果不看 $n$ 号球和 $k$ 号箱子，那么，将剩下的球按规定放进剩下的箱子有 $D_{n-1}$ 种方案。还没看懂？那我把 $k$ 号球移过来，你能不能看懂？

![10.png](https://i.loli.net/2018/09/13/5b99fc99deb4d.png)

还没看懂？回到上面读读错排问题的正确定义。

> 把 $n$ 号球放进： 
> - $1$ 号箱子
> - $2$ 号箱子
> - ……
> - $(k-1)$ 号箱子
> - $\text{k}$ 号箱子
>  * $\text{k}$ 号球放进了 $\text{n}$ 号箱子 $\longrightarrow$ $D_{n-2}$ 种方案
>  * $\text{k}$ 号球没有放进 $\text{n}$ 号箱子 $\longrightarrow$ $D_{n-1}$ **种方案**
> - $(k+1)$ 号箱子
> - ……
> - $(n-1)$ 号箱子

$\ $

我们发现，把 $n$ 号球放进 $\text{k}$ 号箱子后的两种情况我们都能够求出答案。现在，我们可以把两者合起来！

> 把 $n$ 号球放进： 
> - $1$ 号箱子
> - $2$ 号箱子
> - ……
> - $(k-1)$ 号箱子
> - $\text{k}$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**
>  * $\text{k}$ 号球放进了 $\text{n}$ 号箱子 $\longrightarrow$ $D_{n-2}$ 种方案
>  * $\text{k}$ 号球没有放进 $\text{n}$ 号箱子 $\longrightarrow$ $D_{n-1}$ 种方案
> - $(k+1)$ 号箱子
> - ……
> - $(n-1)$ 号箱子

这个 $k$ 是一个未知数，也就是说，无论 $k=1$ 还是 $2$ 还是多少，答案是不变的！

> 把 $n$ 号球放进： 
> - $1$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**
> - $2$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**
> - ……
> - $(k-1)$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**
> - $\text{k}$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ 种方案
> - $(k+1)$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**
> - ……
> - $(n-1)$ 号箱子 $\longrightarrow$ $D_{n-2}+D_{n-1}$ **种方案**

最后一步，你会了吗？

$\ $

$$\large D_1=0$$
$$\large D_2=1$$
$$\large D_n=(n-1)(D_{n-1}+D_{n-2})(n\ge 2)$$

---

### 通项公式

下面这些我没有和小学生讲，错排的通项公式对小学生还是太难了一点。

$$D_n=n!\left[\frac{1}{2!}-\frac{1}{3!}+\dots+(-1)^n\frac{1}{n!}\right]$$


还有一个原因，这东西没法子快速计算……  

顺便讲一下这东西怎样从递推式推导为通项公式的。以下内容来自维基。

设 $D_n = n!M_n$，则 $M_1 = 0, M_2 = \dfrac {1}{2}$。
当 $n\ge 3$ 时，$D_n = (n-1)(D_{n-1} + D_{n-2})$，即
$$n!M_{n}=(n-1)\times (n-1)!M_{n-1}+(n-1)\times (n-2)!M_{n-2}=n!M_{n-1}-(n-1)!M_{n-1}+(n-1)!M_{n-2}$$
化简得
$$nM_{n}-nM_{{n-1}}=-M_{{n-1}}+M_{{n-2}}$$  
于是
$$M_{n}-M_{{n-1}}=-{\frac  {1}{n}}(M_{{n-1}}-M_{{n-2}})=...=(-{\frac  {1}{n}})(-{\frac  {1}{n-1}})...(-{\frac  {1}{3}})(M_{2}-M_{1})=(-1)^{n}{\frac  {1}{n!}}$$
所以
$$\begin{aligned}M_{{n}}-M_{{n-1}}&=(-1)^{{n}}{\frac  {1}{n!}}\\M_{{n-1}}-M_{{n-2}}&=(-1)^{{(n-1)}}{\frac  {1}{(n-1)!}}\\\vdots \quad &=\quad \vdots \\M_{2}-M_{1}&=(-1)^{2}{\frac  {1}{2!}}\\ \end{aligned}$$
将上面式子分边累加，得
$$M_{n}=(-1)^{2}{\frac  {1}{2!}}+(-1)^{3}{\frac  {1}{3!}}...+(-1)^{{n}}{\frac  {1}{n!}}$$
因此，我们得到错排的通项公式 $$D_{n}=n!M_{n}=n!\left[{\frac {1}{2!}}-{\frac {1}{3!}}+...+(-1)^{n}{\frac {1}{n!}}\right]$$

---

## 作者：YoungNeal (赞：83)

题解在博客[食用](http://www.cnblogs.com/YoungNeal/p/8485399.html)效果更佳哦~

我们先来科普一下错排问题，oier们以后也会用到/

错排问题指考虑一个有 $n$ 个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 $n$ 个元素的错排数记为 $D(n)$ 。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。  ---《百度百科》

看上去这就是一个递推问题，那么递推式是如何推出来呢？
当 $n$ 个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用 $D(n)$ 表示，那么 $D(n-1)$ 就表示 $n-1$ 个编号元素放在 $n-1$ 个编号位置，各不对应的方法数，其它类推.  
第一步，把第 $n$ 个元素放在一个位置，比如位置 $k$ ，一共有 $n-1$ 种方法；  
第二步，放编号为 $k$ 的元素，这时有两种情况：⑴把它放到位置 $n$ ，那么，对于剩下的 $n-1$ 个元素，由于第 $k$ 个元素放到了位置 $n$ ，剩下 $n-2$ 个元素就有 $D(n-2)$ 种方法；⑵第 $k$ 个元素不把它放到位置 $n$ ，这时，对于这 $n-1$ 个元素，有 $D(n-1)$ 种方法；  
综上得到   
    $D(n) = (n-1) *(D(n-2) + D(n-1))$  
特殊地，$D(1) = 0, D(2) = 1$.

这就是错排问题。理解了这个，还可以去做一道省选的错排[裸题](https://www.luogu.org/problemnew/show/P3182).

上代码
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int f[25],n;
int main()
{
	scanf("%d",&n);
	f[1]=0;f[2]=1;f[3]=2;
	if(n==1||n==2||n==3)
	{
		printf("%d",f[n]);
		return 0;
	}
	for(int i=4;i<=n;i++)
	{
		f[i]=(i-1)*(f[i-1]+f[i-2]);
	}
	printf("%d",f[n]);
	return 0;
 } 
```

---

## 作者：枫林晚 (赞：28)

### 题目大意：

某人写了n封信和n个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。

### 分析：

方法一：递推

已经处理了f[0]~f[n-1],考虑f[n],新来了一个数n，这个数要放错位，有n-1种情况。其他的数的放置每次都有f[n-1]种情况，被n占用位置的数k，将k放在n位置，可以再多出f[n-2]种情况。

证明：可以将n位置想成是一个k的原位置，由于之前f[n-1]种情况中，不会出现让k在原位置的情况，所以现在把k放在这个n的“新”原位置上，不会将方案数重复计算。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[30];
int n;
int main(){
	cin>>n;
	f[0]=1;
	f[1]=0;
	for(int i=2;i<=n;i++)
	 f[i]=(i-1)*(f[i-1]+f[i-2]);
	cout<<f[n];
	return 0;
}
```

方法二：容斥

首先有n!种排列，减去单个信放正确的情况，每个有(n-1)!种，但是每2个信封被放重复的情况多减了，所以再加回来。再减去3个，加上4个...

dfs容斥。预处理阶乘
```cpp
#include<bits/stdc++.h>
using namespace std;
long long fac[30];
int n;
long long ans;
void dfs(int x,int k)
{
	if(x==n+1)
	{
		if(k&1) ans-=fac[n-k];
		else ans+=fac[n-k];
		return;
	}
	dfs(x+1,k);
	dfs(x+1,k+1);
}
int main()
{
	cin>>n;
	fac[0]=1;
	for(int i=1;i<=n;i++)
	 fac[i]=fac[i-1]*i;
	dfs(1,0);
	cout<<ans;
	return 0;
}
```


---

## 作者：FallenGemini (赞：12)

> ~~这道题是我从刚学会递推到现在三年还是不会做的一道递推题，于是我决定用容斥把它水过去，顺便水一篇题解。~~

## solution

显然对于一个有 $n$ 个数字的全排列方案有 $n!$ 种，问题是我们应该如何去掉不符合条件的方案。

而不符合条件的方案=至少有一个信封放的是正确的信。

而这个又不好计算，那不妨先算对于第 $i$ 个信封放的信是正确的信的方案数，显然方案数 $cnt=(n-1)!$ （即去掉该信封后其他信的全排列）。而 $1\le i\le n$，所以至少有一个信封放的信是正确的信的方案数有 ${n\choose 1} \cdot (n-1)!$

但是这样子我们又会把两封信放到正确的位置的方案数计算两次

> 例：我们在第一个位置放错的方案数中包含了第二个位置放错，在第二个放错的方案数中包含了第一个位置放错，而对于第一个位置第二个位置都放错的方案数计算了两次（手动模拟一下比较显然）

那么我们需要把多去掉的方案数补回来，而补回来又会多补一些方案数回来，所以又要减去$\cdots$

这样我们就得到了答案$ans=\displaystyle\sum _{i=0\to n} (-1)^{i}\cdot (n-i)!\cdot C_n^i$

又因为此题不需要取模，所以没有逆元，又可以进一步化简式子$ans=\displaystyle\sum _{i=0\to n} (-1)^i\cdot\dfrac{n!}{i!}$

预处理一下阶乘就可以了

## Code

```c++
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,ans,fac[30];
int main()
{
	fac[0]=1;for(LL i=1;i<=20;i++) fac[i]=fac[i-1]*i;
	scanf("%lld",&n);
	for(int i=0;i<=n;i++)
	{
		LL sum=0;
		sum=fac[n]/fac[i];
		if(i&1) ans-=sum;
		else ans+=sum;
	}
	printf("%lld\n",ans);
    return 0;
}
```



---

## 作者：_AIR (赞：10)

**关于本题二项式反演的做法**

直接问恰好没有信封放对不太好做，那么可以转换一下。

设 $f(i)$ 表示至少有 $i$ 个信封放对。

可以推导得：
$$
f(i)={n\choose i}(n-i)!
$$
接下来套二反，设 $g(i)$ 表示恰好有 $i$ 个信封放对位置。

由二项式反演公式得：
$$
g(k)=\sum_{i=k}^{n}(-1)^{i-k}{{i}\choose {k}}f(i)
$$
将 $k=0$ （即恰好没有信封放对位置）代入：
$$
g(0)=\sum_{i=0}^{n}(-1)^{i}{{i}\choose {0}}f(i)
$$
将 $f(i)$ 代入得：
$$
g(0)=\sum_{i=0}^{n}(-1)^{i}{{n}\choose {i}}(n-i)!
$$
那么就好做了，预处理阶乘，时间复杂度 $O(N)$ 。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans;
int fac[25];
int C(int n,int m)
{
    if(n<m)return 0;
    return fac[n]/fac[m]/fac[n-m];
}
signed main()
{
	scanf("%lld",&n);
    fac[0]=1;
    for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i;
    for(int i=0;i<=n;i++)
    {
        if(i&1)ans-=(C(n,i)*fac[n-i]);
        else ans+=(C(n,i)*fac[n-i]);
    }
    cout<<ans;
 } 
```

---

## 作者：Angel_s_Shadow (赞：10)

我貌似发现了一种奇怪的解法啊，类似打表？

其实有些算法题里也可以找规律？？

此题

你可以用两个示例先打表
    
就是数组A = {0,0,1,2}

   这就是0,1,2,3个信封的解
   
   然后我fa现了
    
   当下一个数是偶数的时候
    
   答案为A[i-1]*i+1
    
   奇数则是A[i-1]*i-1
    
   于是就产生了打表的解法（滑稽）
    
   上代码：
   ```cpp
   #include <iostream>
using namespace std;
int main(){
    unsigned long long arr[101] = {0,0,1,2};//根据题目示例打表
    bool o = true;//是否为偶数
    for(int i=4;i<=100;i++){
        arr[i]=arr[i-1]*i+(o?1:-1);//按方法计算打表的值
        o = !o;//数字类型变成另一种
    }
    int n;
    cin>>n;
    cout<<arr[n];//输入输出
}
   ```
    
  就这样搞定了？

---

## 作者：zyj_Orz (赞：9)

# 前言

看各位dalao洋洋洒洒写一大堆，真心表示叹服……可是真的需要这么复杂么？



-------------------------------------------华丽的分割线--------------------------------------------

# 题目简介

这个问题推广一下，就是错排问题，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。

错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的装错信封的问题。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况?又比如四人各写一张贺年卡互相赠送，有多少种赠送方法?自己写的贺年卡不能送给自己，所以也是典型的错排问题。



------------
# 方法介绍

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.

第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法;

第二步，放编号为k的元素，这时有两种情况:⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法;⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法;



------------
# DUANG！公式！

综上可得

D(n) = (n-1) [D(n-2) + D(n-1)]

D(n) = (n-1) [D(n-2) + D(n-1)]

特殊地，D(1) = 0, D(2) = 1.

下面通过这个递推关系推导通项公式:

为方便起见，设D(k) = k! N(k), k = 1, 2, …, n,

则N(1) = 0, N(2) = 1/2.

n ≥ 3时，n! N(n) = (n-1) (n-1)! N(n-1) + (n-1)! N(n-2)

即 nN(n) = (n-1) N(n-1) + N(n-2)

于是有N(n) - N(n-1) = - [N(n-1) - N(n-2)] / n = (-1/n) [-1/(n-1)] [-1/(n-2)]…(-1/3) [N(2) - N(1)] = (-1)^n / n!.

因此

N(n-1) - N(n-2) = (-1)^(n-1) / (n-1)!,

N(2) - N(1) = (-1)^2 / 2!.

相加，可得

N(n) = (-1)^2/2! + … + (-1)^(n-1) / (n-1)! + (-1)^n/n!

因此

D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].

此即错排公式。


------------

------------
# 容斥原理

用容斥原理也可以推出错排公式:

正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除;……;继续这一过程，得到错排的排列种数为

D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n*n!/n! = ∑(k=2~n) (-1)^k * n! / k!,

即D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + ... + (-1)^n/n!].

其中，∑表示连加符号，k=2~n是连加的范围;0! = 1，可以和1!相消。



------------
# 样例对照

怕不对？这里有答案，让你随便对！（因为怕有人打表，所以只列出1~10）

D(0) = 1(所有的元素都放回原位、没有摆错的情况)

D(1) = 0(只剩下一个元素，无论如何也不可能摆错)

D(2) = 1(两者互换位置)

D(3) = 2(ABC变成BCA或CAB)

D(4) = 9

D(5) = 44

D(6) = 265

D(7) = 1854

D(8) = 14833

D(9) = 133496

D(10) = 1334961



------------
# 终极BOSS：代码！

翻了这么久，终于来正经的啦！

11行代码，炒鸡简单！

当然，想用容斥做的宝宝们得自己去打啦~反正都有公式啦~

```
#include<bits/stdc++.h>
using namespace std;
long long d[30],n;
int main(){
    cin>>n;
    d[0]=1; d[1]=0;
    for(int i=2;i<=n;i++)
    d[i]=(i-1)*(d[i-1]+d[i-2]);
    cout<<d[n];
    return 0;
}
```





---

## 作者：vivarock (赞：9)

//oier蒟蒻汗水结晶

主要思路：

用f【i】表示i个数的错排；

第一步：考虑放第n个元素，有n-1种；

第二步：考虑第k个元素，如果第n放在了位置k，则还有f【i-1】种。否则还有f【i-2】种；

递推公式：f【i】=（i-1）\*(f【i-1】+f【i-2】)；

递推边界：f【0】=0；f【1】=0；f【2】=1；

```cpp
#include<bits/stdc++.h>//万能头文件
#define For(i,j,n) for(int i=j;i<=n;++i) //宏定义，很好用
using namespace std;
int a[25];//递推数组
int main(){//主函数
    ios::sync_with_stdio;//让cin和scanf一样快
    int n;
    cin>>n;//读入
    a[0]=0;a[1]=0;a[2]=1;//递推边界
    For(i,3,n)a[i]=(i-1)*(a[i-1]+a[i-2]);//递推过程，可能有点难理解，自己用草稿纸按我思路来推一下，就知道了
    cout<<a[n];//输出
    return 0;
}
//蒟蒻思路，神犇勿喷
```

---

## 作者：8atemak1r (赞：7)

## Solution
可以用容斥的方法考虑错排问题。

**每个元素都错排的方案数 = 所有方案数 - 有元素不错排的方案数**

考虑容斥出有元素不错排的方案数。

首先枚举一下至少有 $x$ 个元素在位置上，那么剩下的方案数为 $(n-x)!$，根据容斥原理，设 $f_n$ 表示 $n$ 个元素的错排：
$$
\begin{aligned}
f_n &= n! - \sum^n_{i=1}(-1)^{i-1}\dbinom{n}{i}(n-i)!\\
&= n! - \left(\sum^{n}_{i=0}\left[(-1)^{i-1}\dbinom{n}{i}(n-i)!\right]+n! \right)\\
&=-\sum^{n}_{i=0}(-1)^{i-1}\dbinom{n}{i}(n-i)!\\
&=\sum^{n}_{i=0}(-1)^{i}\dbinom{n}{i}(n-i)!\\
&= \sum^{n}_{i=0}(-1)^i\dfrac{n!}{i!(n-i)!}(n-i)!\\
&= \sum^{n}_{i=0}(-1)^i\dfrac{n!}{i!}\\
&= (-1)^n + \sum^{n-1}_{i=0}(-1)^i\dfrac{n!}{i!}\\
&= (-1)^n + n\sum^{n-1}_{i=0}(-1)^i\dfrac{(n-1)!}{i!}\\
&= (-1)^n + n\sum^{n-1}_{i=0}(-1)^i\dbinom{n-1}{i}(n-1-i)!\\
&= (-1)^n + nf_{n-1}
\end{aligned}
$$
再注意到 $1$ 个元素没有错排，递归处理即可。

## Code
```cpp
#include<bits/stdc++.h>
int n;
long long f(int x) {
	if(x == 1) return 0;
   	return (x & 1 ? -1 : 1) + x * f(x - 1);
}
int main(){
	std :: cin >> n;
	std :: cout << f(n);
   	return 0;
}
```

---

## 作者：Akoasm_X (赞：7)

#### 这是一篇有故事的题解
#### 想看正解的同学可以跳过了
#### 因为这道题只有55分
```cpp
故事是这样的：有位大佬在手写了数字三角形之后，
觉得信息竞赛很容易。后来我就把这道题拿出来了。
一节自习课过后，我去慰问那位朋友，看到他密密麻麻的暴力枚举，
我不禁笑出了声。

故事就这样结束了，言归正传，此后我突然意识到貌似真的可以暴力
用字典序刷一遍，然后分别判断每一种情况，满足ans++；很无脑。

#include<bits/stdc++.h>
using namespace std;
int n,a[50];
unsigned long long ans;
bool stop()//判断是否循环完了，因为阶乘会炸，但55分的代码不会 
{
	for(int i=1;i<=n;i++)
		if(a[i]!=n-i+1)
			return true ;
	return false ;
}
bool judge()//判断是否满足错排条件 
{
	for(int i=1;i<=n;i++)
		if(a[i]==i)//不满足条件返回false; 
			return false;
	return true;
}
int main()
{
	scanf("%d",&n);
	if(n==2||n==0)
	{
		printf("1\n");
		return 0;
	}
	if(n==1)
	{
		printf("0\n");
		return 0;
	}
	//写两个特判 
	for(int i=1;i<=n;i++)
		a[i]=i;//给数组赋初值 
	while(stop())
	{
		next_permutation(a+1,a+n+1);
		if(judge())
			ans++;
	}//快乐地循环 
	printf("%lld\n",ans);//输出答案 
	return 0;
}

```


---

## 作者：no_proper_name_left (赞：6)

初学者也能看懂（比如我）
就是简单的递归，然后没有了,,ԾㅂԾ,,
第一个信有n-1种可能放错，
第n(n>1)个1°上个信放在了这个信封上，本来就不该放，所以第n封信又是n-1种
          2°除掉上一个放的，有n-2种
然后就写完了。。。
记得n==2的时候加个判断（或者把0改成return 1，不然后面都是0）
```cpp
#include<iostream>
#include<cstdio>//其实删了也OK 
using namespace std;
int f(int n)
{
	if(n==0 || n==1)
		return 0;
	if(n==2)
		return 1;
	return (n-1)*(f(n-1)+f(n-2));
}
int main()//超级短的主函数，内容就不用解释了 。。。 
{
	int n;
	cin>>n;
	cout<<f(n);
	return 0;
}
```

---

## 作者：杨戬大师 (赞：5)

这道题我一上来就开始思考每一组数据之间的关系，如果发现了关系，就可以通过递推的方式求出答案了。

假如现在有 n 个信封和信，那么我把答案记为 Sn。不难发现这个Sn是这样构成的：先是不管每一个信装没装错，那么一共有 n! 种组成方式。但是这 n! 显然多了，那么我就减掉那些多的。

这是求 n! 的代码：

```cpp
long long jc(int x)
{
    long long ans = 1, i;
    for (i = 2; i <= x; i++)
        ans *= i;
    return ans;
}
```

那么多的是如何构成的呢？多的是有一些信封的位置是对的，而剩下的是错的。所以不管那些对的，那些错的有多少种组成方式我们之前已经算出来了！只不过它们有可能再一些不同的位置上，所以我们再在每个 Sn-1 到 S1 前面乘一个系数，这系数便是它有可能在几种位置上，用一个排列组合中的组合就行了。其实就是那个我们所熟知的C。

求组合C的代码：

```cpp
long long C(int x, int y)//组合函数
{
    long long ans = 1, i;
    y = min(y, x - y);
    for (i = x; i > x - y; i--)
        ans *= i;
    for (i = y; i > 0; i--)
        ans /= i;
    return ans;
}
```

按如上方法算完多的以后，就用 n! 减去那些多的，便是每一层的答案了，然后再一路递推，就可以推出答案了。

感觉我说的不太清楚，可以看看代码是如何写的。

AC代码：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

long long jc(int x)
{
    long long ans = 1, i;
    for (i = 2; i <= x; i++)
        ans *= i;
    return ans;
}
long long C(int x, int y)//组合函数
{
    long long ans = 1, i;
    y = min(y, x - y);
    for (i = x; i > x - y; i--)
        ans *= i;
    for (i = y; i > 0; i--)
        ans /= i;
    return ans;
}
long long s[21];
int main()
{
    int n, i, j;
    scanf("%d", &n);
    for (i = 2; i <= n; i++)
    {
        s[i] = jc(i) - 1;
        for (j = i - 1; j > 1; j--)
            s[i] -= s[j] * C(i, j);
    }
    printf("%lld", s[n]);
    return 0;
}
```

---

## 作者：LSTete (赞：3)

讲述了三种做法，第三种和第四种本质都是容斥
PS：自然指数做法会有精度误差过不了最后两个点
```cpp
#include<bits/stdc++.h>
#define For(i, j, k) for(register int i = (j); i <= (k); ++i)
using namespace std;

typedef long long ll;
const int N = 20 + 10;
const double e = 2.71828182845904523536;
int n;
ll D[N], fac[N];

inline void Init(int n){
	fac[0] = fac[1] = 1;
	For(i, 2, n) fac[i] = fac[i - 1] * i;
}

namespace DT{
	inline void Solve(){
		D[0] = 0, D[1] = 0, D[2] = 1;
		For(i, 3, n) D[i] = 1ll * (i - 1) * (D[i - 1] + D[i - 2]);
		printf("%lld\n", D[n]);
	}
}

namespace FAC{
	inline void Solve(){
		ll ans = 0;
		For(i, 2, n){
			if(!(i & 1)) ans += fac[n] / fac[i];
			else ans -= fac[n] / fac[i];
		}
		printf("%lld\n", ans);
	}
}

namespace RC{
	
	ll C(int n, int m) { return fac[n] / fac[n - m] / fac[m];}
	
	inline void Solve(){
		ll ans = fac[n];
		For(i, 1, n){
			if(i & 1) ans -= C(n, i) * fac[n - i];
			else ans += C(n, i) * fac[n - i];
		}
		printf("%lld\n", ans);
	}
}

namespace EEE{
	inline void Solve(){
		ll ans = (ll) (1.0 * fac[n] / e + 0.5);
		printf("%lld\n", ans);
	}
}

int main(){
	scanf("%d", &n), Init(n);
	DT::Solve();	//递推
	FAC::Solve();	//容斥推得
	RC::Solve();	//简单容斥
	EEE::Solve();	//自然指数
	return 0;
}
```


---

## 作者：Bronya18C (赞：3)

# 史上最牛题解，

没错，就是打表。

看到数据是20以内就想到了打表

我用我的计算器一个一个算出来了，花了整整10000001%10分钟。

公式是f[i]=i-1*(f[i-1]*f[i-2]);

---
## 代码：
```
#include<bits/stdc++.h>

using namespace std;
long long n,f[10005]={0,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32071101049,481066515734,7697064251745,130850092279664,2355301661033953,44750731559645106,895014631192902121,};
int main()
{
    cin>>n;
    cout<<f[n]<<endl;
    return 0;
}
```

---

## 作者：牙神幻十郎 (赞：3)

十分暴力的思路，用了vector，其实直接等于一维数组

大概就是生成法生成数组后进行检验，如果通过则计数++

事实证明背不下公式做此题也十分简单

c++代码

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    int n,ans=0;
    cin>>n;
    vector<int> v,b; 
    for (int i=1;i<=n;i++)
        {
            v.push_back(i);
             b.push_back(i);
        }
    do{
        bool zed=true;
        for (int i=0;i<v.size();i++)
            if(v[i]==b[i])
            {
                zed=false;
                break;
            }
        if (zed)
            ans++;
    }while ( next_permutation( v.begin(), v.end() ) ); 
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：LT123456 (赞：2)

之前没接触过错排问题，看了题解后才发现这道题用错排如此简单。我的方法虽然没有错排简单，但是还没有人用这种方法，不知管理大大给不给过呀~~~~~

# **思路如下**
n封信放进n个信封，总的方案数 = n！

令F（n）为n封信放入n个信封全放错的方案数，则n封信中有m个信封放错的方案数为：

C（m,n）×F（m）

其中C（m,n）为从n封信中选出m个放错的信和信封的方案数，F（m）为m个信全部放错信封的方案数。

n封信放进n个信封，总的方案包含以下方案：

0封信放错信封 方案数 = F（0）=1

2封信放错信封 方案数 = C（2，n）×F（2）

3封信放错信封 方案数 = C（3，n）×F（3）

4封信放错信封 方案数 = C（4，n）×F（4）

· · · · · ·

n封信放错信封 方案数 = F（n）

∴F（0）+  C（2，n）×F（2）+ ···+C（n-1，n）×F（n-1）+F（n）=n!

∴F（n）=n! - F（0）-  C（2，n）×F（2）+ ···+C（n-1，n）×F（n-1）

即只要已知 F（0）、F（2）···、F（n-1），即可求得F(n)。推导到这里，这道题就可以用递推了：

由F（0）、F（2）、F（3）求得F（4），再由F（0）、F（2）、F（3）、F（4）求得F（5），再由这些求得F（6）······直到求得F（n）。

### 代码如下：
```cpp
#include<bits/stdc++.h>
#include<math.h>
#include<algorithm>
using namespace std;
long long  fac(int x)
{
    register int i;
    long long f = 1;  

    for (i = 1;i <= x;i++)
        f *= i;

    return f;
}
int f(int m, int n)
{
    int i, j;
    int  ans = 1;
    if (m < n - m) m = n - m;
    for (i = m + 1; i <= n; i++) ans *= i;
    for (j = 1; j <= n - m; j++) ans /= j;
    return ans;
}
int main()
{
    int i, j, n, a[20],b=0,c;
    cin >> n;
    if (n == 1) cout << 0;
    else
    {
        a[0] = 1;a[1] = 2;
        for (i = 3;i <= n - 1;i++)
        {
            b = 0;
            c = 1;
            for (j = i - 1;j >= 1;j--)
            {
                b += f(c, i + 1)*a[j - 1];
                c++;
            }
            a[i - 1] = fac(i + 1) - b - 1;
        }
        cout << a[n - 2];
    }
    return 0;
}

```

我这道题没有AC，因为我求了阶乘，所以当N=13时结果已经溢出了，但是这种方法希望能够分享给大家~~



------------
### 手打不易，求过QAQ~~~





---

## 作者：不会dp退役菜鸡 (赞：2)

众所周知，错拍公式如下： 

$D_n\ =\ [n!*e+0.5]$

而众所周知，

$e ≈ 2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354$

那么就能AC了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; long long ans=1;
#define e 2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354
int main()
{
    scanf("%d",&n);
	if(n==19||n==20) return 0; 
    for(int i=2;i<=n;i++) ans*=i;
    ans=1.0*ans/e+0.5;
    printf("%lld",ans);
    return 0;
}
```

~~（才不会告诉你这个精度还不够呢口亨）~~

---

## 作者：xvhuanlin (赞：2)

这道题的另一个公式f=n!(1-1/1!+1/2!-1/3!+...+(-1)^n\*(1/n!))。


---

## 作者：Catch_22 (赞：2)

话说这个问题有一个通项公式、、、

An=[n!/e+0.5] //“[]”表示取整。

详见具体论文：http://yunpan.cn/QbphFusbFacYL

所以这样问题就主要在于求N！，鉴于数据极小，也不需要过多考虑了、


---

## 作者：⚡GG⚡ (赞：2)

其实递推就OK了

公式：
```cpp
(n-1)*(f(n-1)+f(n-2))
```
但要加几个特判：
```cpp
if(n<=1)	return 0;//0,1都不可能。
else if(n==2)	return 1;//边界
```
所以加起来是这样：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f(int n)	//long long才不爆
{
	if(n<=1)	return 0;//0,1都不可能。之前犯了个错，写成了：cout<<0;
	else if(n==2)	return 1;//边界
	else
	return (n-1)*(f(n-1)+f(n-2));//递推开始
}
int main()//省略......
{
	int n;
	cin>>n;
	cout<<f(n);
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：1)

错排公式：http://baike.baidu.com/link?url=cQVynv2hLB4aCfJXtom-cJcxNk-Pgup-CHFZ5yjOfyWyEAPtEfRowTEyhTSTSZo7Il9aCp6Z8EydoRammE45s\_

```cpp
#include<set>    
#include<map>    
#include<list>    
#include<queue>    
#include<stack>    
#include<string>    
#include<math.h>    
#include<time.h>    
#include<vector>    
#include<bitset>    
#include<memory>    
#include<utility>    
#include<stdio.h>    
#include<sstream>    
#include<iostream>    
#include<stdlib.h>    
#include<string.h>    
#include<algorithm> 
#define LL unsigned long long    
using namespace std;  
int main()  
{  
    int n,m;int sum=0;
    cin>>n;
    if (n==1) //1的情况 （应该没有吧……） 
    {
        cout<<0;
        return 0;
    }
    int f1=0,f2=1;int f3;//初始化 
    for (int i=3;i<=n;i++)
    {
        f3=(i-1)*(f1+f2);// 递推 
        f1=f2;
        f2=f3;
    }
    cout<<f2;//输出结果 
    return 0;  
}
```

---

## 作者：刘心远 (赞：1)

P1595 信封问题 题解

解：伯努利错装信封问题，公式上！

 f(n)=(n-1)\*(f(n-1)+f(n-2))

(n表示信封数）

【算法分析】首先，f(0)=1, f(1)=0, f(2)=1

当n>2时，设第一封信装在第二个信封中    （有n-1种方法）

此时若第二封信装在第一个信封中，则剩下的即为n-2错排问题    （f(n-2)种方法）

若第二封信不装在第一个信封中，把第二封信看作与第一个信封为一套

（与错排意思相同），剩下的即为n-1错排问题    （f(n-1)种方法）

得出公式：f(n)=(n-1)\*(f(n-1)+f(n-2))(n表示信封数）

【华丽标程】

```cpp
#include<iostream>
using namespace std;
int card(int k)
{
    if(k==0)return 1;  //特判
    if(k==1)return 0;
    if(k==2)return 1;
    return (k-1)*(card(k-1)+card(k-2));  //公式
}
int main()
{
    int n; cin>>n;
    cout<<card(n)<<endl;
    return 0;
}
```
温馨提示：没有n的范围，int即可！

请大神们多多指教！

http://blog.sina.com.cn/s/blog\_1754bd7130102wyat.html


---

## 作者：野生蒟蒻 (赞：1)

错排递归（递推）题目，主要是公式：a[i]:=(i-1)\*(a[i-1]+a[i-2]);

```cpp
var
 n:longint;
function cp(n:longint):longint;//错排递归函数
 begin
  if (n=1) then cp:=0//边界判断
           else if (n=2) then cp:=1//边界判断
           else cp:=(n-1)*(cp(n-1)+cp(n-2));//递归的调用自己的公式
 end;
begin
 read(n);
 writeln(cp(n));
end.

```

---

## 作者：xgl0520 (赞：0)

#主要部分：

```cpp
int cp(int n)
{
    if (n==1) return 0;
    else if (n==2) return 1;
    else return (n-1)*(cp(n-1)+cp(n-2));
}
```
当信封数为1时，不会发生错位
当信封数为2时，只有一种情况：

A  B
b  a
当信封数大于2时，举信封数为3的例子：

ABC
bca
1.交换a c

ABC
bac
则与信封数为2时相同

后面的也是一样的思路

##啰嗦半天，公式：f(n)=(n-1)\*(f(n-1)+f(n-2))

代码如下：


```cpp
#include <iostream>
#include <cmath>
using namespace std;
int n;
int cp(int n)
{
    if (n==1) return 0;
    else if (n==2) return 1;
    else return (n-1)*(cp(n-1)+cp(n-2));
}
int main()
{
    cin>>n;
    cout<<cp(n);
    return 0;
}
```

---

## 作者：用户已注销 (赞：0)

数据有一点渣，非记忆化比记忆化还快


这题是错排公式的裸题，不知道为什么没有给数据范围，估计n连20都不到

所以在评测记录里找到一篇0ms的代码居然没有记忆化的暴搜


然后我记忆化搜索，好几百都能瞬间完成（只不过会爆longlong）这道题用了20ms左右（微笑）


错排公式请自行百度，百度百科里很详细

这里摘录递推式：D(N)=(N-1)\*[D(N-1)\*D(N-2)]并且D(1)=0，D(2)=1（据说D（0）= 1 不过一般是没有用的）

然后就可以记忆化搜索了，或者动态规划（类似于斐波那契）

记忆化搜索的代码：

```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
long long n,d[1000005];
long long com(int a)
{
    if(a==1) return 0;
    if(a==2) return 1;//两个特殊值 
    if(d[a]!=0) return d[a];//记忆化 
    d[a]=(a-1)*(com(a-1)+com(a-2));//计算 
    return d[a];
}
int main()
{
    memset(d,0,sizeof(d));
    scanf("%lld",&n);
    return !printf("%lld",com(n));
```
}/\*错排公式的递推式：D(N)=(N-1)\*[D(N-1)\*D(N-2)]，D(1)=0，D(2)=1\*/
不记忆化搜索（50就go die）的代码：

```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
using namespace std;
long long n;
long long com(int a)
{
    if(a==1) return 0;
    if(a==2) return 1;
    return (a-1)*(com(a-1)+com(a-2));
}
int main()
{
    scanf("%lld",&n);
    return !printf("%lld",com(n));
```
}/\*错排公式的递推式：D(N)=(N-1)\*[D(N-1)\*D(N-2)]，D(1)=0，D(2)=1\*/

一定要记忆化！！！！！这一题快没什么用！！！


---

## 作者：CforChan (赞：0)

用错排公式就可AC。具体是D(n)=[n!/e+0.5]（[]为取整数）

代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int fac(int n)
{
    if(n==0||n==1) return 1;
    else return n*fac(n-1);
}
int main()
{
    int num;cin>>num;
    double e=exp(1);
    int Dn;
    Dn=fac(num)/e+0.5;
    cout<<Dn<<endl;
}
```

---

## 作者：『　』 (赞：0)

并不需要写成递归的形式，一个循环就搞定了

公式f[i]=(i-1)\*(f[i-1]+f[i-2])



```cpp
f[0]=0,f[1]=0,f[2]=1;
    #include<bits/stdc++.h>//万能头文件，实测比赛可用
    #define re register//寄存器，据说可加速
    #define f(i,a,b)  for(re int i=a;i<=b;++i)/宏定义，代码简单些
    using namespace std;
    typedef long long ll;
    ll f[30];//记得开long long
    int main()
    {
        ll n;
        scanf("%lld",&n);
        f[2]=1;//f[1],f[0]就不用赋值了，全局变量默认就是0
        f(i,3,n)
        f[i]=(i-1)*(f[i-1]+f[i-2]);//线性递推
        printf("%lld\n",f[n]);
        return 0;
    }
就是这样了
```

---

## 作者：eagadsgbsadfhb (赞：0)

这题……没数据范围啊！不过没事

这题我开始想f(n)=f(n-2)+f(n-1),f(0)=1,f(1)=0什么的简直越想越乱，实在没想出来就用了深搜

```cpp
#include<iostream>
using namespace std;
int n,s,a[10001];
void dfs(int x){
    if(x==n){
        if(a[x]!=0)s++;//如果搜到最后一个都满足条件,计数器加一
        return ;
    }
    for(int i=1;i<=n;i++)//枚举可能情况
        if(a[i]==0&&i!=x){
            a[i]++;
            dfs(x+1);
            a[i]--;
        }
}
int main(){
    cin>>n;//输入输出不想讲
    dfs(1);
    cout<<s;
    return 0;
}
```

---


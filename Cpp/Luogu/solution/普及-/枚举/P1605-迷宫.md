# 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。

## 样例 #1

### 输入

```
2 2 1
1 1 2 2
1 2
```

### 输出

```
1```

# 题解

## 作者：ybb756032937 (赞：597)

#C++题解

##基本思路：搜索 标记 打表 AC

###代码呈上：

```cpp
#include<iostream>//个人建议不使用万能头文件，如果要使用万能头文件，就不能定义数组map；
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
int map[6][6];//地图；
bool temp[6][6];//走过的标记；
int dx[4]={0,0,1,-1};//打表；
int dy[4]={-1,1,0,0};//打表；
int total,fx,fy,sx,sy,T,n,m,l,r;//total计数器，fx，fy是终点坐标，sx，sy是起点坐标，T是障碍总数，n，m是地图的长和宽，l，r是障碍的横坐标和纵坐标；
void walk(int x,int y)//定义walk；
{
    if(x==fx&&y==fy)//fx表示结束x坐标，fy表示结束y坐标；
    {
        total++;//总数增加；
        return;//返回，继续搜索；
    }
    else
    {
        for(int i=0;i<=3;i++)//0——3是左，右，下，上四个方向；
        {
            if(temp[x+dx[i]][y+dy[i]]==0&&map[x+dx[i]][y+dy[i]]==1)//判断没有走过和没有障碍；
            {
                temp[x][y]=1;//走过的地方打上标记；
                walk(x+dx[i],y+dy[i]);
                temp[x][y]=0;//还原状态；
            }    
        } 
    }
}
int main()
{
    cin>>n>>m>>T;//n，m长度宽度，T障碍个数 
    for(int ix=1;ix<=n;ix++)
        for(int iy=1;iy<=m;iy++)
            map[ix][iy]=1;//把地图刷成1；
    cin>>sx>>sy;//起始x，y 
    cin>>fx>>fy;//结束x，y 
    for(int u=1;u<=T;u++)
    {
        cin>>l>>r;//l，r是障碍坐标；
        map[l][r]=0;
    }
    walk(sx,sy);
    cout<<total;//输出总数；
    return 0;
} 
```
题整体来说比较简单，使用深搜一个个查，使用一个数组map记录障碍的地方，再使用一个temp来标记自己所走过的路；


int dx[4]={0,0,1,-1};

int dy[4]={-1,1,0,0};

使用自动选择方向来代替4个if判断（~~使代码更加简洁~~长度变短）；


如果没有障碍并且不是自己走过的，就进一步搜索，把自己走过的路打上标记，返回时，再将标记还原；


###注意：有些同学可能觉得就在地图map数组上打标记（自己走过的路）比较简单，走过的路和障碍可能引起混淆，如果只用map数组的话，可能只的得到80分；~~（贴主的惨痛经历）~~


###这里再给大家一个基本的深搜模板：

```cpp
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```
###整个模板有几个地方需要注意：

1.第一个if是符合输出解的条件，第二个if是符合进一步搜索的条件；

2.下一步搜索时，不是使用return search(t+1)，直接search(t+1);（~~新手可能会注意不到这个关键的地方，以至于每次写完不知道为什么只得到一个答案就返回主程序了~~）

3.for循环之后的if可以是多个;

4.for循环边界，例如：

1>方向是四个，那么边界肯定就是4；（帖主用3，是因为从0开始的）

2>素数环需要尝试1至20，那么边界就是20；



如果想要得到更多知识，请关注我博客：https://www.luogu.org/blog/AHacker/


此博客不定期更新内容！！！感谢大家！！！


---

## 作者：Billy●Herrington (赞：151)

大扎好，我系世界第一蒟蒻czdh。介系我发布的第2篇题解

首先，这一题一看就知道一定要用**dfs回溯**。因为我们要枚举走的步数，以及走错路时抑制住自己的愤怒回来换下一条路。

看到有不少人在讨论版里发只有**40**分（~~我一开始也只有40分~~。），关于这个问题，我会在代码里解释。
## 以下是代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
bool G[15][15],VIS[15][15];//G为总地图，VIS记录是否访问
int n,m,d[5]={-1,0,1,0,-1};//方向不解释 
int nx,ny,ex,ey,CNT;
//nx,ny起点坐标;ex,ey终点坐标,CNT路径条数
void dfs(int x,int y)
{
	if (x ==ex&&y ==ey)//如果到终点
	{
		CNT++;//路径加一
		return;//回去继续查找
	} 
	for (int k=0;k<4;k++)
	{
		int l=x+d[k];int r=y+d[k+1];
		if (l>=1&&r>=1&&l<=n&&r<=m&&!G [l][r]&&!VIS [l][r]) 
		{
			VIS [l][r]=true;//标记为已访问
			dfs (l,r);
			VIS [l][r]=false;//回溯
		}
	}
	return; 
}
int main ()
{
	int t,zx,zy;
	cin>>n>>m>>t>>nx>>ny>>ex>>ey;
	G[nx][ny]=true; //这就是许多人（我）40分的原因
    //因为dfs函数里并没有将起点设为已访问
    //所以在后面的访问里，可能访问起点许多次
    //所以你的答案可能比标准答案多
	while(t--)
	{
		cin>>zx>>zy;
		G[zx][zy]=true;//设为障碍
	} 
	dfs (nx,ny);//从起点开始寻找 
	cout<<CNT;
	return 0; 
} 
```

蒟蒻第二次发布题解，请大家指教qwq

蟹蟹大家qwq

---

## 作者：Sn_Eddy (赞：144)

**首先告诉大家一个好消息：bits/stdc++.h在复赛可以使用了。**

**其次看这道简单的题目，我的策略是不考虑边界，直接初始化，将边界当作障碍。**

**附上程序。**

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[101][101];
int sum=0;
int i,j,n,m,t,sx,sy,x,y,ex,ey;
void dfs(int a,int b)
{
    if (a==ex&&b==ey)//终止条件
    {
        sum++;
        return;
    }
    else
    {
           q[a][b]=0;//保存结果
        if(q[a-1][b]!=0) {dfs(a-1,b);q[a-1][b]=1;}
        if(q[a][b-1]!=0) {dfs(a,b-1);q[a][b-1]=1;}
        if(q[a][b+1]!=0) {dfs(a,b+1);q[a][b+1]=1;}
        if(q[a+1][b]!=0) {dfs(a+1,b);q[a+1][b]=1;}//这四部是穷举所有可行的搜索，并且回溯
    }
}
int main()
{
    memset(q,0,sizeof(q));//边界当作障碍。
    cin>>n>>m>>t;
    cin>>sx>>sy>>ex>>ey;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            q[i][j]=1;//可以走
    for(i=1;i<=t;i++)
    {
        cin>>x>>y;
        q[x][y]=0;//障碍物初始化
    }
    dfs(sx,sy);
    cout<<sum<<endl;
    return 0;
}
完美！
```

---

## 作者：煮酒论英雄 (赞：116)

在下刚刚学完深搜，就做了一题AC，~~都不好意思说~~~~自己是蒟蒻了~~（好吧，我本就是蒟蒻）

反正，这题除了深搜，还是深搜。

深搜，一句话来总结一下，就是：

# 不撞南墙不回头

而在这题里，“南墙”有三个：

### 第一个是真墙：迷宫的围墙 

也就是俗话所说的越界。越界了你还不回头，你是想去哪儿？

### 第二个是山墙:障碍物T（姑且认为是山）

如果一座山横在你面前，你还是绕路吧！

### 第三个是人造墙：题目说了每个方格最多只能走一次

这是真没办法

所以深搜的返回条件就出来了——就是以上那三堵墙

我们每次可以从上下左右四个方向进行深搜，一旦遇上南墙就返回，如果走到了重点，s++。

#### 记住了，题目里说保证起点没有障碍，并没有保证重点也没有啊

好了，上代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[6][6];
int tx,ty,sx,sy,fx,fy,t;
int n,m,s;
void dfs(int x,int y)//用x来表示x坐标，y来表示y坐标 
{
	if(x<1||x>n)//x坐标越界 
		return;
	if(y<1||y>m)//y坐标越界 
		return;
	if(x==fx&&y==fy)
	{
		s++;//终点站到了 
		return;
	}	
	if(a[x][y]==1||a[x][y]==2)//1代表走过了，2代表障碍 
		return;
	a[x][y]=1;
	dfs(x+1,y);//下 
	dfs(x,y+1);//右 
	dfs(x-1,y);//上 
	dfs(x,y-1);//左 
	a[x][y]=0;//清零 
}
int main()
{
	cin>>n>>m>>t;
	cin>>sx>>sy>>fx>>fy;
	for(int i=0;i<t;i++)
	{
		cin>>tx>>ty;
		a[tx][ty]=2;//标记障碍 
	}
	if(a[fx][fy]==2)//如果终点有障碍 
	{
		cout<<"0";//就没必要搜了 
		return 0;//肯定搜不到 
	}
	dfs(sx,sy);//从起点开始 
	cout<<s;
	return 0;
}

```
嗯，我看到标签里有枚举和暴力，这题能用枚举？~~（怀疑智商）~~

还有递推，有谁找到这题的递推关系式了？请评论区留个言，谢谢

---

## 作者：拱垲 (赞：94)

# 萌新题解第二弹！！！
## 声明
**纯属原创，请勿抄袭**
我的码风可能有点和别人不太一样（其实就是有点奇怪），~~大家重在意会即可~~。
## 目录
~~依旧是用来凑字数的目录~~

前言

代码详解

后记

## 前言

~~这道题话说是真的水，不过用来练习深搜还是很好的。~~
这道题十分经典，强烈建议大家自己敲一遍，感受一下这道极其基础的深搜题.
## 代码详解
为避免繁琐的if语句，先来打个表
```cpp
const int nextx[4]={0,0,1,-1};
const int nexty[4]={-1,1,0,0};
```
深搜函数：
```cpp
void dfs(int x,int y)//深搜 
```
判断边界：
```cpp
if(x<1||y<1||x>n||y>m)//如果越界，则返回 
		return;
```
判断是否到达终点：
```cpp
if(x==fx&&y==fy)//如果到达终点，则方案数加一 
	{
		ans++;
		return;
	}
```
搜索与回溯（重点）：
```cpp
b[x][y]=true;//将当前点标记为已访问 
	for(int i=0;i<=3;i++)		
		if(b[x+nextx[i]][y+nexty[i]]==false&&a[x+nextx[i]][y+nexty[i]]==true)//如果未访问且不是障碍物	
			dfs(x+nextx[i],y+nexty[i]);	//则继续深搜 
	b[x][y]=false;//回溯 
```

------------
深搜的完整函数：
```cpp
void dfs(int x,int y)//深搜 
{
	if(x<1||y<1||x>n||y>m)//如果越界，则返回 
		return;
	if(x==fx&&y==fy)//如果到达终点，则方案数加一 
	{
		ans++;
		return;
	}
	b[x][y]=true;//将当前点标记为已访问 
	for(int i=0;i<=3;i++)		
		if(b[x+nextx[i]][y+nexty[i]]==false&&a[x+nextx[i]][y+nexty[i]]==true)//如果未访问且不是障碍物	
			dfs(x+nextx[i],y+nexty[i]);	//则继续深搜 
	b[x][y]=false;//回溯 
}
```


## 完整AC代码
你们最爱的AC代码~~~
```cpp
#include <iostream>
using namespace std;
bool a[10][10];
bool b[10][10]={0};
int n,m,t,sx,sy,fx,fy,ans=0;
const int nextx[4]={0,0,1,-1};
const int nexty[4]={-1,1,0,0};

void dfs(int x,int y)//深搜 
{
	if(x<1||y<1||x>n||y>m)//如果越界，则返回 
		return;
	if(x==fx&&y==fy)//如果到达终点，则方案数加一 
	{
		ans++;
		return;
	}
	b[x][y]=true;//将当前点标记为已访问 
	for(int i=0;i<=3;i++)		
		if(b[x+nextx[i]][y+nexty[i]]==false&&a[x+nextx[i]][y+nexty[i]]==true)//如果未访问且不是障碍物	
			dfs(x+nextx[i],y+nexty[i]);	//则继续深搜 
	b[x][y]=false;//回溯 
}
int main()
{
	int tx,ty;
	cin>>n>>m>>t>>sx>>sy>>fx>>fy;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=true;
	for(int i=1;i<=t;i++)
	{
		cin>>tx>>ty;
		a[tx][ty]=false;
	}
	b[sx][sy]=true;
	dfs(sx,sy);
	cout<<ans;//输出结果 
	return 0;
}
```

## 后记
这道题由于我手残，敲完代码时不小心关了...关了...于是重打一了遍，浪费了不少时间，不过这些都不重要~ ~ ~各位大佬们看到这里，能否给个赞呢？~>_<

---

## 作者：legends·never·die (赞：45)

        虽然迷宫这道题放在dfs的试练场里，但是bfs显然也是可以写出来的。现在大家看一下代码
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
int n,m,k,x,y,a,b,ans;
int dx[4] = {0,0,1,-1},dy[4] = {1,-1,0,0};
bool vis[6][6];
struct oo{
    int x,y,used[6][6];
};


oo sa;


void bfs()
{
    queue<oo> q;      //定义结构体后，可以直接使用结构体名定义变量或者队列。
    sa.x = x;
    sa.y = y;         //横纵坐标替换，这样写起来方便。
    sa.used[x][y] = 1;//标记走过的路径
    q.push(sa);
    while(!q.empty())
    {
        oo now = q.front();     //一起拿出来
        q.pop();
        for(int i = 0;i < 4; i++)
        {
            int sx = now.x + dx[i];
            int sy = now.y + dy[i];
            if( now.used[sx][sy] 
                || vis[sx][sy] 
                || sx == 0 || sy == 0 
                || sx > n || sy > m)
                continue;    //如果这里走过，或者这里是障碍，或者这里是墙壁，那么这里就不能走。
            if(sx == a && sy == b)
            {
                ans++;           如果这里是终点，那么结果数量加一
                continue;
            }
            sa.x = sx;
            sa.y = sy;
            memcpy(sa.used,now.used,sizeof(now.used));
            sa.used[sx][sy] = 1;     //这里的操作都是为了标记路径
            q.push(sa);
        }
    }
}


int main()
{
    scanf("%d%d%d",&n,&m,&k);
    scanf("%d%d%d%d",&x,&y,&a,&b);         //虽然这里可以合并成一个句子，但是由于我是从python转过来的，建议大家以后写代码都设置一个界限，代码不宜太长
    for(int i = 1,aa,bb;i <= k; i++)     //大家注意一下，我现在是直接把变量定义在循环里面。
    {
        scanf("%d%d",&aa,&bb);           //现在我们不能走障碍了。
        vis[aa][bb] = 1;
    }
    bfs();
    printf("%d",ans);
    return 0;
}
```
        输入输出为什么不用标准输入输出流而用格式化输入输出，嗯~..因为这样比较快吧，不这样写可能会T掉，不过大家可以试一试

        现在这个题就解出来了，本人是第一次写题解，如果有什么地方没有解释清楚可以再问我，多提意见，接下来将会改进的更好

---

## 作者：扬皓2006 (赞：34)

在进入正题之前，我们先来看一个题目

迷宫由n行m列的单元格组成（n,m都小于等于100），每个单元格要么是空地（1），要么是障碍物（0）你的任务是帮助小哼找到一条从迷宫的起点通往小哈所在位置的最少步数。

输入:第一行，n,m

第2~n+1行 每行m个数（0或1）

第n+2行:sx（起点横坐标），sy（起点纵坐标），fx（终点横坐标），fy（终点纵坐标）

输出:1个数，为最少步数（保证有解）

代码:
```
#include<bits/stdc++.h>//万能头
using namespace std;
int n,mi=0,m;
int dx[4]={0,0,1,-1};//4方向
int dy[4]={1,-1,0,0};
int nex[101][101];//判断是否走过数组
int tem[101][101];//地图数组
int fx,fy,sx,sy;
void dfs(int x,int y,int ste)
{
	if(x==fx&&y==fy)
	{
		mi=ste;//换成全局变量输出
		return ;
	}
	for(int i=0;i<=3;i++)
	{
		if(nex[x+dx[i]][y+dy[i]]==0&&tem[x+dx[i]][y+dy[i]]==1)//如果没有走过且没障碍
		{
			nex[x][y]=1;//标记过已走过
			dfs(x+dx[i],y+dy[i],ste+1);//继续搜索
			nex[x][y]=0;//回溯一步
		}
	} 
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>tem[i][j];
			nex[i][j]=0;//全标记为没走过
		}
	}
	cin>>sx>>sy>>fx>>fy;
	dfs(sx,sy,0);
	cout<<mi;
	return 0;
}

好 如果你上面这题会写 那么本题（P1605）你也会写了

只需要在代码上做点修改，如下:
#include<bits/stdc++.h>//万能头
using namespace std;
int n,m,coun=0,t;
int sx,sy,fx,fy;
int ma[6][6];
int a[6][6]={0};//全为没走过
int dx[4]={0,0,1,-1};//地图数组
int dy[4]={1,-1,0,0};
int b,c;//障碍坐标
void dfs(int x,int y)
{
	if(x==fx&&y==fy)//如果到达
	{
		coun++;return ;//方案+1并回溯
	}
	else{
		for(int i=0;i<=3;i++)
	{
		if(ma[x+dx[i]][y+dy[i]]==1&&a[x+dx[i]][y+dy[i]]==0)//如果没有障碍且没有走过
		{
			a[x][y]=1;//标记为已走过
			dfs(x+dx[i],y+dy[i]);//继续搜索
			a[x][y]=0;//回溯一步
		 } 
	} 
	} 
}
int main()
{
	cin>>n>>m>>t;
	cin>>sx>>sy>>fx>>fy;
	a[sx][sy]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			ma[i][j]=1;//全标记为空地
		}
	}
	for(int i=1;i<=t;i++)
	{
		cin>>b>>c;
		ma[b][c]=0;//标记障碍
	}
	dfs(sx,sy);//开始搜索
	printf("%d",coun);
	return 0;
}
做完这道题后，大家也可以做一下P1451 P1506 P1596 都是DFS求联通块的题目

最后，希望大家能学会DFS，也希望管理大大能通过此篇题解！

---

## 作者：Error_Eric (赞：24)

## 这是标准的搜索题目，我用的是深度优先，然而bfs似乎也可以用

深搜起点(sx,sy)

深搜拓展——~~举目四望~~上下左右 ~~废话~~

深搜返回条件1：到达终点

深搜返回条件2：越界或进入不该进入的区域

深搜返回条件3：~~四~~三面楚歌（即所有拓展已经return）


然后就可以愉快地码代码咯！

代码：



```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int vis[7][7];//是否允许行人通行
int n,m,t,total=0;
//total==方案总数
//其他如题
int sx,sy,fx,fy;
bool judge(int xxx,int yyy){//判断是否能走
	if(vis[xxx][yyy]>=1) return 0; //这里的地面被踩过了
	if(xxx>n || xxx<1) return 0;//光荣地掉下了悬崖
	if(yyy>m || yyy<1) return 0;//光荣地掉下了悬崖
	return 1; //似乎很安全
}
void dfs(int x,int y){ //我在那，我在(x,y)
	if(x==fx&&y==fy){//到达了终点
	//走上人生巅峰
		total++;//次数++
		return ;
	}
	int xx,yy;//下一步走哪儿？
	xx=x+1;yy=y;//举目四望之1（右方）
	if(judge(xx,yy)){
		vis[x][y]=1;
		dfs(xx,yy);
		vis[x][y]=0;//时光倒流——回溯
	}
	xx=x-1;yy=y;//举目四望之2（左方）
	if(judge(xx,yy)){
		vis[x][y]=1;
		dfs(xx,yy);
		vis[x][y]=0;//时光倒流——回溯
	}
	xx=x;yy=y+1;
	if(judge(xx,yy)){//举目四望之3（上方）
		vis[x][y]=1;
		dfs(xx,yy);
		vis[x][y]=0;//时光倒流——回溯
	}
	xx=x;yy=y-1;
	if(judge(xx,yy)){//举目四望之4（下方）
		vis[x][y]=1;
		dfs(xx,yy);
		vis[x][y]=0;//时光倒流——回溯
	}
	//四面楚歌
	return; 
} 
int main(){
    //输入
	cin>>n>>m>>t;//如题
	cin>>sx>>sy>>fx>>fy;
	   //起点    终点
	int la,lb;
	for(int i=1;i<=t;i++){//输入障碍
		cin>>la>>lb;
		vis[la][lb]=9;//插翅难飞
	}
	dfs(sx,sy);//勇敢的迈出第一步！
	cout<<total;//输出
	return 0;//程序的结束
	         //迷宫的终结
}
```


---

## 作者：GEM_IU_077 (赞：23)

###dfs(大法师）pascal福利

此题是一道典型的深搜题目，将能通过的位置赋值为0，将不能通过的位置赋值为1，然后进行深度优先搜索就ok了。

###千万别忘记原地回溯！！！不要将起点设为1,1！！！（如果一碰到障碍物或重点就返回（exit)）

下附代码：

```pas
  var
  i,j,k,n,m,t,sx,sy,fx,fy,a,b:longint;
  ans:int64;
  z:array[0..10,0..10] of longint;
  flag:array[0..10,0..10] of boolean;

procedure dfs(x,y:longint);   //深搜开始
  begin
    if z[x,y]=1 then exit;   //判断是否遇到障碍物
    if (x=fx) and (y=fy)   //判断是否到达终点
      then
        begin
          inc(ans);   //更新答案
          exit;
        end;
    flag[x,y]:=true;  //将**flag[x,y]**设为已经走过
    if (x-1>0) and (not flag[x-1,y]) then dfs(x-1,y);   //递归开始（如果越出地图或那一个点一走过则不进行深搜）
    if (x+1<=n) and (not flag[x+1,y]) then dfs(x+1,y);
    if (y-1>0) and (not flag[x,y-1])then dfs(x,y-1);
    if (y+1<=m) and (not flag[x,y+1])then dfs(x,y+1);
    flag[x,y]:=false;   //原地回溯
  end;

begin
  readln(n,m,t);
  readln(sx,sy,fx,fy);
  fillchar(z,sizeof(z),0);
  for i:=1 to t do
    begin
      readln(a,b);
      z[a,b]:=1;
    end;
  dfs(sx,sy);   //调用子程序
  writeln(ans);   //输出（大功告成）
end.
```
**z[x,y]**表示此点是否可通行，**flag[x,y]**表示此点是否走过


---

## 作者：JeffWang2019 (赞：16)

### 这道题是一道典型的dfs题目
### 是为初学dfs的人准备的
### 主要就是深搜的应用
#### 不说了，上代码：
```
#include <bits/stdc++.h>//万能头文件，省事用
using namespace std;
int vis[9][9];//记录是否走过，走过记1，没走过记2
int z[9][9];// 记录是否有障碍物，有记1，没有记2
int n,m,t,sx,sy,fx,fy;
int ans=0;//记录满足的路线条数
int b,c;
void dfs(int x,int y)//核心来了，坐稳了——
{
    if(x<1||y<1||x>n||y>m)//超出迷宫边界，返回
    {
        return;
    }
    if(z[x][y]==1)//有障碍物，返回
    {
        return;
    }
    if(vis[x][y]==1)//已经走过了，返回
    {
        return;
    }
    if(x==fx&&y==fy)//走到了终点
    {
        ans++;// 更新变量
        return;//返回
    }
    vis[x][y]=1;
    dfs(x-1,y);
    dfs(x+1,y);
    dfs(x,y-1);
    dfs(x,y+1);// 自己调用自己的过程
    vis[x][y]=0;/*这点非常重要，收回前一步，才能进行下一次尝试*/
}
int main()
{
    memset(z,0,sizeof(z));
    memset(vis,0,sizeof(vis));//初始化
    scanf("%d%d%d",&n,&m,&t);
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    for(int i=1;i<=t;i++)
    {
        scanf("%d%d",&b,&c);
        z[b][c]=1;//设为有障碍物
    }
    dfs(sx,sy);//调用dfs函数
    printf("%d",ans);//打印结果
    return 0;//完美结束程序。yes！
}
```
### 最后，预祝各位早日AC！
### 还有，看在我这么辛苦的份上，求赞~~~
### bye~

---

## 作者：Lngstart (赞：16)

整体来说这道题目比较的简单，是比较基础的搜索题


------------
思路就是从起点开始采用dfs的思想，一直向下搜索，一旦遇到目标点就记为+1次

------------
代码如下：

------------
```cpp
#include<iostream>
using namespace std;

int a[6][6];//用来储存地图和标记作用
int next[4][2]={{1, 0}, {-1, 0},{0, 1},{0, -1}};//方向数组
int sx, sy, fx, fy;//代表了起点和终点的坐标
int m, n, t;//m代表行，n代表列，t代表障碍数
int ans = 0;//总的条数
void dfs(int sx, int sy){
    int nx, ny;
    if(sx == fx && sy == fy){//终点的判定条件
        ans++;
        return;
    }
    a[sx][sy] = 1;//走过的要进行标记
    for(int i = 0; i < 4; ++i){//枚举上下左右四个方向
        nx = sx + next[i][0];
        ny = sy + next[i][1];
        if(nx < 1 || nx > m || ny < 1 || ny > n)//边界的判定条件
            continue;
        if(a[nx][ny] == 0){
            a[nx][ny] = 1;
            dfs(nx,ny);
            a[nx][ny] = 0;
        }
    }
}
int main(){
    cin >> m >> n >> t;
    cin >> sx >> sy >> fx >> fy;
    int x, y;
    for(int i = 0; i < t; ++i){
        cin >> x >> y;
        a[x][y]=1;//标记障碍的位置
    }
    dfs(sx,sy);

    cout << ans << endl;
    return 0;
}

```

~~第一次发题解，望管理员通过^_^~~


---

## 作者：「QQ红包」 (赞：11)

深度搜索。

要注意一个地方：棋盘内每一个点都可以走。只要该点在棋盘内就可以走。

```delphi

var n,m,t,x1,y1,x2,y2,sum,xx,yy,i:longint;
    a,b:array[-10..100,-10..100] of longint;
procedure try(x,y:longint);
begin
    if (x=x2)and(y=y2) then inc(sum) else
    begin
        if (x>=1)and(y>=1)and(x+1<=n)and(y<=m)and(a[x+1,y]=0)
        and(b[x+1,y]=0) then begin b[x+1,y]:=1;try(x+1,y);b[x+1,y]:=0; end;
        if (x>=1)and(y>=1)and(x<=n)and(y+1<=m)and(a[x,y+1]=0)
        and(b[x,y+1]=0) then begin b[x,y+1]:=1;try(x,y+1);b[x,y+1]:=0; end;
        if (x-1>=1)and(y>=1)and(x<=n)and(y<=m)and(a[x-1,y]=0)
        and(b[x-1,y]=0) then begin b[x-1,y]:=1;try(x-1,y);b[x-1,y]:=0; end;
        if (x>=1)and(y-1>=1)and(x<=n)and(y<=m)and(a[x,y-1]=0)
        and(b[x,y-1]=0) then begin b[x,y-1]:=1;try(x,y-1);b[x,y-1]:=0; end;
    end;
end;
begin
    fillchar(a,sizeof(a),0);
    fillchar(b,sizeof(b),0);
    read(n,m,t,x1,y1,x2,y2);//a[x2,y2]:=100;
    for i:=1 to t do
    begin
        read(xx,yy);
        a[xx,yy]:=1;
    end;
    b[x1,y1]:=1;
    try(x1,y1);
    write(sum);
end.

```

---

## 作者：fanhaotian (赞：4)

这道题很简单！！！

回溯算法即可

注意一个数组表示向哪个方向走动，一个数组标记重复点（深搜完记得还原）

以下是代码，部分有注解

```cpp
#include<iostream>
using namespace std;
int go[4][2]={-1,0,0,1,1,0,0,-1};
int n,m,t,x1,y1,x2,y2,f[6][6],q[6][6],ans;
void dfs(int x,int y)
{
    int i,a,b,j;
    if(x==x2&&y==y2)//到达终点，输出
        ans++;
    else
    {
        for(i=0;i<4;i++)//向四个方向枚举
        {
            a=x+go[i][0];
            b=y+go[i][1];
            if(a>0&&a<=n&&b>0&&b<=m&&f[a][b]==0&&q[a][b]==0)//判断可否走
            {
                q[a][b]=1;
                dfs(a,b);
                q[a][b]=0;
            }
        }
    }
}
int main()
{
    int i,z,u;
    cin>>n>>m>>t>>x1>>y1>>x2>>y2;
    for(i=0;i<t;i++)
    {
        cin>>z>>u;
        f[z][u]=1;
    }
    q[x1][y1]=1;
    ans=0;
    dfs(x1,y1);
    cout<<ans;
    return 0;
}


```

---

## 作者：Shiwellyoung (赞：3)

# c++题解
## 实现方式：dfs，模拟
### 附上dfs模板：
```cpp
int(void) dfs(int k)
{
 if(到达目的地)
  {输出}
 else
 {
  根据题意模拟等
  dfs（k+1）；
  回溯（保存当前结果之前的状态）
 }
}
```
#### 下面请看完整代码与讲解：
```cpp
#include<cstdio>
using namespace std;
int n,m,tot,sx,sy,fx,fy,t,t1,t2;//根据题意设好变量，不用过多的解释了哦
int f[10][10];//路线数组
bool b[10][10];//标记数组

void dfs(int a,int b)

{
	if(a==fx&&b==fy)//达到终点的标志

	{
		tot++;
		return ;
	}
	else 
	{
		f[a][b]=0;//起始坐标设为0

		if(f[a-1][b]!=0) { dfs(a-1,b); f[a-1][b]=1;}

		if(f[a][b-1]!=0) { dfs(a,b-1); f[a][b-1]=1; }
		if(f[a+1][b]!=0) { dfs(a+1,b); f[a+1][b]=1;}

		if(f[a][b+1]!=0) { dfs(a,b+1); f[a][b+1]=1;}//向上下左右四个方向模拟（应该很好理解吧）

	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&t);

	scanf("%d%d%d%d",&sx,&sy,&fx,&fy);

	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)

			f[i][j]=1;//首先把所有的位置设为1，意味着都没有障碍

	for(int i=1;i<=t;i++)
	{
		scanf("%d%d",&t1,&t2);

		f[t1][t2]=0;
	}//把有障碍的坐标设为0
	dfs(sx,sy);
    printf("%d",tot);
	return 0;
}

```
个人认为本题解还是非常好理解的，很适合像我这样的新手学习，希望大家可以给予鼓励与支持。谢谢！

### 这是本蒟弱的第三篇题解，求管理员大人通过qwq！

---

## 作者：xwmwr (赞：3)

提供一个不常见的搜索做法（很不常见）：模拟递归。

想法来自lyd的书。

先给出原ac代码

```cpp
#include<iostream>

using namespace std;

int t,m,n,map[10][10],sx,sy,fx,fy,at,bt,ans;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
void dfs(int r,int c){
	if(r==fx && c==fy){
		ans++;
		return;
	}
	
	for(int i=0;i<4;++i)
	{
		int r1=r+dx[i],c1=c+dy[i];
		if(r1>=1 && c1>=1 && r1<=n && c1<=m && !map[r1][c1]){
			map[r1][c1]=1;
			dfs(r1,c1);
			map[r1][c1]=0;
		}
	}
}

int main(){
	cin>>n>>m>>t;
	cin>>sx>>sy>>fx>>fy;
	for(int i=1;i<=t;++i){
		cin>>at>>bt;
		map[at][bt]=1;
	}
	
	map[sx][sy]=1;
	dfs(sx,sy);
	
	cout<<ans;
	
	return 0;
}
```

现在我要把dfs函数搬到主函数里，做法是用栈模拟递归。

正文如下：

首先，看到正文中的参数：r,c,i（循环参数如同r、c对待，因为在循环过程中有下一层函数调用）

其次，都知道递归返回时会返回到原语句，继续执行下一条语句，
为实现这个，这里采用lyd的方法，switch语句模拟语句跳转。

------

代码开始搭建，效仿原代码写下参数：
```cpp
int m,n,t,sx,sy,fx,fy,a[6][6],ans;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
bool vis[6][6];
```
当然还有我们的栈啦
```cpp
int Stack[1000010],Top,Address;
//address表示当前递归层应执行哪一部分语句。
```
每当在当前递归层中调用了下一层递归，各参数以及当前的程序地址都应被栈记录下来，由此写出call和return（这里简写为ret）函数

```cpp
void call(int r,int c,int i,int add)
{
	int old_top=Top;
	// 
	Stack[++Top]=r;
	Stack[++Top]=c;//参数们 
	Stack[++Top]=i;
	// 
	Stack[++Top]=add;//返回时应执行哪一部分语句。 
	Stack[++Top]=old_top;//为便捷记录以前的top值，其实可以自己算的 
}

int ret()
{
	int add=Stack[Top-1];//返回时应执行哪一条语句（aya多嘴了 
	Top=Stack[Top];
	return add;
}
```
----
观察原代码的dfs函数，可以看出语句分3部分：

1.循环代码前的部分

2.循环中调用下一层之前的部分

3.循环中调用下一层之后的部分

----

由上，写出循环部分的框架

```cpp
while(Top)
	{
		int r=Stack[Top-4],c=Stack[Top-3],i=Stack[Top-2];
		int r1=r+dx[i],c1=c+dy[i];
		switch(Address)
		{
			case 0:
				if(r==fx && c==fy){
					ans++;
					Address=ret();
					continue;
				}
				Address=1;
				continue;
			case 1:
				if(i==4) { Address=ret();continue;}
				if(r1>=1&&c1>=1&&r1<=n&&c1<=m&&vis[r1][c1]==0) {
					vis[r1][c1]=1;
					call(r1,c1,0,2);
					Address=0;
					continue;
				}
				else {
					Stack[Top-2]+=1;
					Address=1;
					continue;
				}
			case 2:
				vis[r1][c1]=0;
				Stack[Top-2]+=1;
				if(i==4) { Address=ret();continue;}
				Address=1;
				continue;
		}
	}
```

完整代码及ac记录如下
```cpp
//https://www.luogu.org/recordnew/show/20473914
#include<bits/stdc++.h>
using namespace std;
int m,n,t,sx,sy,fx,fy,ans;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int vis[6][6];

int Stack[1000010],Top=0,Address=0;

void call(int r,int c,int i,int add)
{
    int old_top=Top;
    //
    Stack[++Top]=r;
    Stack[++Top]=c;//参数们
    Stack[++Top]=i;
    //
    Stack[++Top]=add;//返回时应执行哪一部分语句。 
    Stack[++Top]=old_top;//为便捷记录以前的top值，其实可以自己算的
}

int ret()
{
    int add=Stack[Top-1];//返回时应执行哪一条语句
    Top=Stack[Top];
    return add;
}

int main()
{
    scanf("%d%d%d",&n,&m,&t);
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    for(int i=1,x,y;i<=t;++i) scanf("%d%d",&x,&y),vis[x][y]=1;
    vis[sx][sy]=1;
    call(sx,sy,0,0);
    
    while(Top)
    {
        int r=Stack[Top-4],c=Stack[Top-3],i=Stack[Top-2];
        int r1=r+dx[i],c1=c+dy[i];
        switch(Address)
        {
            case 0:
                if(r==fx && c==fy){
                    ans++;
                    Address=ret();
                    continue;
                }
                Address=1;
                continue;
            case 1:
                if(i==4) { Address=ret();continue;}
                if(r1>=1&&c1>=1&&r1<=n&&c1<=m&&vis[r1][c1]==0) {
                    vis[r1][c1]=1;
                    call(r1,c1,0,2);
                    Address=0;
                    continue;
                }
                else {
                    Stack[Top-2]+=1;
                    Address=1;
                    continue;
                }
            case 2:
                vis[r1][c1]=0;
                Stack[Top-2]+=1;
                Address=1;
                continue;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Jyf624761709 (赞：3)

###这道题是一道经典的深搜题（如果你做对了可以去做做P1219）

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;//头文件不解释
bool p[10][10];//用来模拟地图（障碍物和非障碍物）（1为障碍物，0就可以走）
int lx,ly,ans=0;//lx，ly分别为终点坐标
int n,m,t,fx,fy,x,y;//fx、fy为起点坐标，x、y为每个障碍物的坐标（临时变量）
void dfs(int x,int y,int sx,int sy){//深搜（x，y为当前坐标，sx，sy为上一点的坐标，作用是判断有没有又回到原来的地方
    if(x==lx&&y==ly){//如果现在已经到达终点就回溯
        ans++;//ans为总路径数
        return ;
    }
```
/\*有些同学可能会想怎么判重，其实是不需要的。因为每次递归中的四个方向都不一样，不可能有重复\*/
p[x][y]=1;//因为每次走过后就不能走了，所以每次递归都要把当前坐标设为障碍物。

```cpp
    if(x-1>0&&x-1!=sx&&p[x-1][y]<1)//往上走
        dfs(x-1,y,x,y);
    if(y-1>0&&y-1!=sy&&p[x][y-1]<1)//往左走
        dfs(x,y-1,x,y);
    if(y+1<=m&&y+1!=sy&&p[x][y+1]<1)//往右走
        dfs(x,y+1,x,y);
    if(x+1<=n&&x+1!=sx&&p[x+1][y]<1)//往下走
        dfs(x+1,y,x,y);
```
/\*每次递归都要先判断一下要到达的地方是不是障碍物，还有判断一下有没有又走到了原来的地方，如果又回去了。。。。。。。\*/
p[x][y]=0;//注意每次设完障碍物都要还原因为地图是全局的，现在不能走，不代表其他路也不能走


```cpp
}
int main(){
    scanf("%d%d%d",&n,&m,&t);
    scanf("%d%d%d%d",&fx,&fy,&lx,&ly);//读入
    for(int i=1;i<=n;i++)
        memset(p[i],0,sizeof(p[i]));//初始化（总觉得我是不是多虑了。。。。。）
    for(int i=1;i<=t;i++){
        scanf("%d%d",&x,&y);
        p[x][y]=1;//设置障碍物（永久的)
    }
    dfs(fx,fy,fx,fy);开始深搜
    printf("%d",ans);//输出总路径
    return 0;
}

```

---

## 作者：PhantasmDragon (赞：3)

一道适合新手入门dfs的题，经典回溯DFS题

这道题亦可用BFS做，在这里就不多讲了！（一次AC感觉好表脸QAQ）

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
int maze[10][10],book[10][10],n,m,t,sx,sy,ex,ey,ans=0;//book为标记数组
void dfs(int x,int y)
{
    if(x<0||y<0||x>=n||y>=m||maze[x][y]==1||book[x][y]==1)//如果越界，装上障碍或已经路过，便停止搜索。
    {
        return;
    }
    else if(x==ex&&y==ey)//到达终点，答案加1
    {
        ans++;
        return;
    }
    else
    {
        book[x][y]=1;//设置标记
        dfs(x+1,y);//挨个检查>_>
        dfs(x,y+1);
        dfs(x-1,y);
        dfs(x,y-1);
        book[x][y]=0;//回溯，重置标记
    }
}
void solve()
{
    memset(maze,0,sizeof(maze));
    memset(book,0,sizeof(book));
    scanf("%d %d %d",&n,&m,&t);
    scanf("%d %d %d %d",&sx,&sy,&ex,&ey);
    sx--;//我是从零开始，所以要减。
    sy--;
    ex--;
    ey--;
    for(int i=0;i<t;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        maze[x-1][y-1]=1;//在迷宫中标记障碍
    }
    dfs(sx,sy);
    printf("%d",ans);
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：牛寺另刂6 (赞：2)

//超级水题

//建议做完后做P1238走迷宫
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int dx[]={0,-1,0,1};
int dy[]={-1,0,1,0};
int dd[25][25],vis[25][25];
int bx,by,ex,ey;
int total=0;
void dfs(int x,int y)
{
    if(x==ex&&y==ey){
    total++;  
            return;  }//达到就返回
for (int i=0;i<4;i++)
{
    int curx=x+dx[i];
    int cury=y+dy[i];
    if(dd[curx][cury]==1&&vis[curx][cury]==0){
    vis[curx][cury]=1;
     dfs(curx,cury);
   vis[curx][cury]=0;//消除影响
    }
}
}
int main()
{
    int a,b,t;
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) dd[i][j]=1;
    cin>>bx>>by>>ex>>ey;vis[bx][by]=1;
    for(int q=1;q<=t;q++) {cin>>a>>b; vis[a][b]=1;}//比较蠢的标记
    dfs(bx,by);
    cout<<total;
 } 

```

---

## 作者：H尸体 (赞：2)

#无脑深搜

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,a[6][6],sx,sy,fx,fy,o,p,t,ans;
void go(int i,int j)
{
    if (i==fx&&j==fy)
    ans++;//到达终点计数器加一
    if (a[i+1][j]==1)//判断是不是障碍
    {
        a[i+1][j]=0;
        go(i+1,j);//向下方节点寻找可以走的下一步 
        a[i+1][j]=1;
    }
    if (a[i-1][j]==1)//判断是不是障碍
    {
        a[i-1][j]=0;
        go(i-1,j);//向下方节点寻找可以走的下一步 
        a[i-1][j]=1;
    }
    if (a[i][j-1]==1)//判断是不是障碍
    {
        a[i][j-1]=0;
        go(i,j-1);//向下方节点寻找可以走的下一步 
        a[i][j-1]=1;
    }
    if (a[i][j+1]==1)//判断是不是障碍
    {
        a[i][j+1]=0;
        go(i,j+1);//向下方节点寻找可以走的下一步 
        a[i][j+1]=1;
    }
}
int main()
{
    cin>>m>>n>>t;//读入
    for (i=1;i<=m;i++)
    for (j=1;j<=n;j++)
    a[i][j]=1;//把整个迷宫设为1
    cin>>sx>>sy>>fx>>fy;//读入起点终点
    a[sx][sy]=0;//把起点设为0
    for (i=1;i<=t;i++)
    {
        cin>>o>>p;//读入障碍
        a[o][p]=0;//在迷宫上把障碍设为0
    }
    go(sx,sy);//开始深搜
    cout<<ans;//输出答案
    return 0;
}
```

---

## 作者：1v7w (赞：2)

**思路简单，贴一个短小的代码** 我看了题解，大概没有雷同， 大概。。。

```cpp

#include <cstdio>
int n, m, sx, sy, fx, fy, ans;
char map[10][10];        //地图 0为可走 1为不可走
int mx[4] = {0,1,0,-1};    //移动
int my[4] = {1,0,-1,0};

void dfs(int x, int y)
{
    if(x>n || y>n || x<1 || y<1)    //检查越界
        return;
    if(map[x][y])                    //检查是否能走
        return;
    if(x == fx && y==fy)            //是否到达终点
    {//要先检查能走 再检查是否到达终点 终点有可能是墙壁
        ans++;
        return;
    }
    
    map[x][y] = 1;        //标记已经走过 不能走了
    for(int i=0; i<4; i++)    //四种移动方式
        dfs(x+mx[i], y+my[i]);    
    map[x][y] = 0;        //取消标记
}

int main()
{
    int t, tx, ty;
    scanf("%d%d%d", &n, &m, &t);
    scanf("%d%d%d%d", &sx, &sy, &fx, &fy);
    while(t--)
    {
        scanf("%d%d", &tx, &ty);
        map[tx][ty] = 1;
    }
    if(!map[fx][fy])    //如果终点是墙 直接输出0
        dfs(sx, sy);
    printf("%d", ans);
    return 0;
}

```

---

## 作者：ssy666 (赞：2)

noip前刷刷水题积攒人品

```cpp
var
    i,j,m,n,k,ans,x,y,sx,sy,fx,fy,t:longint;
    map:array[1..10000,1..6]of longint;
    use:array[1..10000,1..6]of boolean;
procedure dfs(x,y:longint);
begin
    if map[x,y]=1 then exit;
    if (x=fx)and(y=fy) then
    begin
        inc(ans);
        exit;
    end;
    use[x,y]:=true;
    if (x-1>0)then
        if (not use[x-1,y])then dfs(x-1,y);
    if (x+1<=n)then
        if (not use[x+1,y])then dfs(x+1,y);
    if (y-1>0)then
        if (not use[x,y-1])then dfs(x,y-1);
    if (y+1<=m)then
        if (not use[x,y+1])then dfs(x,y+1);
    use[x,y]:=false;
end;
begin
    read(n,m,t);
    read(sx,sy,fx,fy);
    fillchar(map,sizeof(map),0);
    for i:=1 to t do
    begin
        read(x,y);
        map[x,y]:=1;
    end;
    dfs(sx,sy);
    write(ans);
end.
其实很简单，sx,sy代表出发点，fx,fy代表终点，然后上下左右dfs一遍就行了，注意路要是不能走及时exit掉，否则会WA一个点，因为那个点终点是不能走的。。。
```

---

## 作者：skylee (赞：2)

基本思路就是深搜啦~

将二位压缩为一维以及集合操作是这题解的亮点

注意特判终点是障碍的情况

```pascal
var
    n,m,t,i,x,y,s,f,ans:longint;
    a,path:set of byte;
function getpos(x,y:longint):byte;inline;
    begin
        exit((x-1)*m+y)
    end;
function getup(p:byte):byte;inline;
    begin
        exit(p-m)
    end;
function getdown(p:byte):byte;inline;
    begin
        exit(p+m)
    end;
function getleft(p:byte):byte;inline;
    begin
        exit(p-1)
    end;
function getright(p:byte):byte;inline;
    begin
        exit(p+1)
    end;
function isup(p:byte):boolean;inline;
    begin
        exit(p<=m)
    end;
function isdown(p:byte):boolean;inline;
    begin
        exit(p>m*(n-1))
    end;
function isleft(p:byte):boolean;inline;
    begin
        exit(p mod m=1)
    end;
function isright(p:byte):boolean;inline;
    begin
        exit(p mod m=0)
    end;
procedure dfs(p:longint);
    begin
        if (p=f) and not (p in a) then begin
            inc(ans);
            exit
        end;
        if not (p in path+a) then begin
            path:=path+[p]
        end
        else begin
            exit
        end;
        if not isup(p) then begin
            dfs(getup(p))
        end;
        if not isdown(p) then begin
            dfs(getdown(p))
        end;
        if not isleft(p) then begin
            dfs(getleft(p))
        end;
        if not isright(p) then begin
            dfs(getright(p))
        end;
        path:=path-[p]
    end;
begin
    readln(n,m,t);
    read(x,y);
    s:=getpos(x,y);
    readln(x,y);
    f:=getpos(x,y);
    a:=[];
    for i:=1 to t do begin
        readln(x,y);
        a:=a+[getpos(x,y)]
    end;
    ans:=0;
    dfs(s);
    writeln(ans)
end.
```

---

## 作者：huangkx (赞：2)

### 这是一道深度优先搜索的题，还是比较简单的，那本蒟蒻就来写一篇题解吧
### （我可不会告诉别人我不会BFS的）逃~


------------
#### 先说说我的思路：
初始化：首先全部初始化为障碍(就是0)，再把n行全部初始化为1，最后把障碍点变为0

接着来个大爆搜：先判断a == ex && b == ey，如果是就ans++；return；否则就判断上下左右，然后回溯

输出：输出ans就搞定了

深度优先搜索大家应该都懂吧，那就直接上代码了
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int mp[101][101];//迷宫
int ans = 0;//记录答案数量
int n,m,t,sx,sy,ex,ey,x,y;
void dfs(int a,int b)//搜索
{
    if (a==ex&&b==ey){ans++; return;}//判断是否到达终点
    mp[a][b] = 0;
    if(mp[a-1][b] != 0){dfs(a-1,b); mp[a-1][b] = 1;}
    if(mp[a][b-1] != 0){dfs(a,b-1); mp[a][b-1] = 1;}
    if(mp[a][b+1] != 0){dfs(a,b+1); mp[a][b+1] = 1;}
    if(mp[a+1][b] != 0){dfs(a+1,b); mp[a+1][b] = 1;}//这四句是判断上下左右
}
int main()
{
    memset(mp,0,sizeof(mp));//初始化为0
    cin>>n>>m>>t;
    cin>>sx>>sy>>ex>>ey;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) mp[i][j] = 1;//在初始化为1
    for(int i=1;i<=t;i++){cin>>x>>y; mp[x][y] = 0;}//标出障碍
    dfs(sx,sy);//调用
    cout<<ans<<endl;//输出
    
    return 0;
}
```


---

## 作者：yyy2015c01 (赞：2)

经典搜索题目。其实用递推也行

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
using namespace std;
int n,m,t,sx,sy,fx,fy,t1,t2,tot=0,change[5][3]={{0,0,0},{0,1,0},{0,-1,0},{0,0,1},{0,0,-1}};
bool ditu[6][6]={false};
void dfs(int x,int y)
{
    if (x>=1 && y>=1 && x<=m && y<=n && ditu[x][y]==false)
    {
        if (x==fx && y==fy)
        {
            tot++;
            return ;
        }
        for (int i=1;i<=4;i++)
        {
            ditu[x][y]=true;
            dfs(x+change[i][1],y+change[i][2]);
            ditu[x][y]=false;
        }
    }
}
int main()
{
    scanf("%d%d%d%d%d%d%d",&n,&m,&t,&sx,&sy,&fx,&fy);
    for (int i=1;i<=t;i++)
    {
        scanf("%d%d",&t1,&t2);
        ditu[t1][t2]=true;
    }
    dfs(sx,sy);
    printf("%d",tot);
}

```

---

## 作者：蛟川洋 (赞：2)

```cpp
###DFS新人福利（超短代码）
program P1605;
var
        a:array[1..5,1..5] of boolean;
        n,m,t,sx,sy,fx,fy,tx,ty,ans,i,j:longint;
function judge(x,y:longint):boolean;
begin
if (x<1) or (x>n) or (y<1) or (y>m) then exit(false);//超界
if a[x,y] then exit(false);//有障碍或已经走过
exit(true);
end;
procedure dfs(x,y:longint);
begin
if (x=fx) and (y=fy) then//走到终点
begin
inc(ans);//累加
exit;
end;
a[x,y]:=true;//表示现在的x、y已经走过
if judge(x-1,y) then dfs(x-1,y);//搜索往上走
if judge(x+1,y) then dfs(x+1,y);//搜索往下走
if judge(x,y-1) then dfs(x,y-1);//搜索往左走
if judge(x,y+1) then dfs(x,y+1);//搜索往右走
a[x,y]:=false;//回溯很关键，我第一次忘记加就50
end;
begin
        readln(n,m,t);
        readln(sx,sy,fx,fy);
        for i:=1 to t do
         begin
         readln(tx,ty);
         a[tx,ty]:=true;//标记障碍
         end;
        dfs(sx,sy);//从起点开始
        writeln(ans);
end.
**最好理解最简单的深搜就在这里了**
```

---

## 作者：强力人 (赞：2)

深搜标准样板题；

别忘记置标记，回溯改标记和return就行；

重点和解释都在代码中了；

AC代码如下。


```cpp
#include<cstdio>
#include<cstring> 
using namespace std;
bool m1[10][10];//避免重复走  
int ax[4]={1,-1,0,0},ay[4]={0,0,1,-1};//四个方向 
int sx,sy,fx,fy,ans=0,xx,yy,n,m;//起点x，起点y，终点x，终点y 
void dfs(int x,int y)
{
    if(x==fx&&y==fy)//如果到终点了，答案++，返回 
    {
        ans++;
        return ;
    }
    for(int j=0;j<4;j++)
    {
        int xx=x+ax[j];//这里一定一定注意要int，否则只有四十分 
        int yy=y+ay[j];
        if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&m1[xx][yy]==false)
        {
            m1[xx][yy]=true;
            dfs(xx,yy);
            m1[xx][yy]=false;//回溯置标记 
        }
    }
    return;//如果搜不到答案，返回 
}
int main()
{
    int t,zx,zy;
    memset(m1,false,sizeof(m1));
    scanf("%d%d%d",&n,&m,&t);
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    m1[sx][sy]=true;//起点置标记 
    for(int i=0;i<t;i++)
    {
        scanf("%d%d",&zx,&zy);
        m1[zx][zy]=true;//障碍标记 
        if(zx==fx&&zy==fy)//如果终点处有障碍，直接不可能达到； 
        {
            printf("0");
            return 0;
        }
    } 
    dfs(sx,sy);
    printf("%d",ans); 
    return 0;
}
```

---

## 作者：R浩轩泽Anmicius (赞：1)

## 题旨：标记 深搜 回溯
一道没有背景的水题（~~水题专属言简意赅~~


话不多说，奉上大家最喜欢的AC代码：
```cpp
#include<cstdio>
#include<cstring>//cstdio美滋滋的简洁
using namespace std;
int ans,n,m,t,sx,sy,ex,ey;//ans计数器，n、m、t分别对应题中变量，sx、sy起点坐标，ex、ey终点坐标 
int a[4][2]={{-1,0},{0,-1},{1,0},{0,1}};//常规打表 
bool map[10][10];//判断是否能走(false) 
void s(int x,int y)//深搜，申明当前搜索坐标
{
	if(x==ex&&y==ey)
	{
		ans++;
		return;//中断 
	}//若到达终点，则计数器加一 
	for(int i=0;i<4;i++)//枚举四周情况 
	{
		if(x>0&&x<=n&&y>0&&y<=m&&!map[x+a[i][0]][y+a[i][1]])//若不越界且没走过、无障碍 
		{
			map[x][y]=true;
			s(x+a[i][0],y+a[i][1]);//则标记，进一步搜索
			map[x][y]=false;//标记清零，回溯 
		}
	}
}
int main() 
{
	scanf("%d%d%d",&n,&m,&t);
	scanf("%d%d%d%d",&sx,&sy,&ex,&ey);//读入数据 
	memset(map,false,sizeof(map));//标记清零 
	ans=0;//计数器清零 
	for(int i=1;i<=t;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		map[x][y]=true;//标记障碍点 
	}
	s(sx,sy);//从起点处搜索 
	printf("%d\n",ans);
	return 0;//华丽的结尾 
}

```
本题是一道经典深搜，只要能建立地图标记（bool map[10][10]）,处理好标记（map[x][y]=true）、搜索与回溯的逻辑关系，就能华丽AC了~

蓝名蒟蒻第一次发题解，如果有啥不妥的请指出（当时看到这题简单头脑发热就开博客了

~~管理大大求过~~

---

## 作者：rispect (赞：1)

## ~~又是一道(水)题~~
### 大家好，我是第一次发题解的蒟蒻。
这道题，其实最简单的方法就是用
## _**回溯**_ 
（也就是用dfs，瞎BB这么多）

（其实，我已经想不出能再扯什么东西了）

**下面呈上代码（大家最激动的时刻）**
```cpp
#include <bits/stdc++.h>  //万能的头文件
using namespace std;
int ans=0,wx[4]={-1,1,0,0},wy[4]={0,0,-1,1},vis[6][6],x,y;  //ans为结果 后面两个是移动，vis相当于你玩游戏的一张map，x和y是障碍物坐标
int N,M,T,SX,SY,FX,FY;  //题目中有
bool f[6][6];  //有没有走过这个坐标
int isOK(int x1,int y1){  
	if(x1>N||y1>M||x1<=0||y1<=0)return 0;
	return 1;  //isOK函数用以判断有没有出界
}
void dfs(int x,int y){  //开始dfs
	if(x==FX&&y==FY){  //到达目的地
		ans++;  //方案+1
		return ;  //重新搜索
	}
	else if(!isOK(x,y))return ;  //超出边界重新从零点走一遍
	else{ 
		for(int i=0;i<4;i++){  //四个方向可以走
			if(f[x+wx[i]][y+wy[i]]==0&&vis[x+wx[i]][y+wy[i]]==1){  //判断有没有走过或有没有障碍
                f[x][y]=1;  //在这次深搜中标记为已走过
                dfs(x+wx[i],y+wy[i]);  //继续搜索下一个点
                f[x][y]=0;  //清回标记
            }    	
		}
	}
}
int main() {
	scanf("%d%d%d",&N,&M,&T);  //输入
	scanf("%d%d%d%d",&SX,&SY,&FX,&FY); //输入
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
			vis[i][j]=1;  //将地图全设为可通行
	for(int i=1;i<=T;i++){
		scanf("%d%d",&x,&y);
		vis[x][y]=0;  //在指定的坐标上放下障碍物
	}
	dfs(SX,SY);  //从这个点开始深搜
	printf("%d\n",ans);  //欢快的输出时间
    while(1)printf("1");  //防抄袭
	return 0;  //好习惯
}
```
### 抄袭是不对的（qwq)
这是我第一次发题解，有不对的地方欢淫大佬指出

---

## 作者：空·白 (赞：1)

#### 总体来说这是一道入门的深搜题，一般来说只要会写深搜就应该会写了吧。

------------
整体的思路就是先将迷宫初始化，然后深搜一个点一个点去找（不用担心会超时，只有5X5而已）。

------------
我会不定期在自己的博客上更新题解，感兴趣的可以点击链接[空·白的博客](https://www.luogu.org/blog/c1223074598/)

------------

```cpp
#include<bits/stdc++.h>     //万能头就很舒服
using namespace std;
int n,ans=0,m,t,sx,sy,fx,fy;
int s[10][10];     //记录这个点有没有走过
int z[4][2]={{1,0},{0,1},{-1,0},{0,-1}};     //走的方向
void dfs(int x,int y)
{
	if(x==fx&&y==fy)
	{
		ans++;        //判定到终点了没有
	}
	for(int i=0;i<4;i++)
	{
		int xx,yy;     //不能定全局变量，不然会出事
		xx=x+z[i][0];
		yy=y+z[i][1];
		if(s[xx][yy]==0)    //0代表这个点没有走过
		{
			s[xx][yy]=1;      //搜索，最基础的步骤
			dfs(xx,yy);
			s[xx][yy]=0;      //回溯，这步不能少
		}
	}
}
int main()
{
	int a,b;
	cin>>n>>m>>t;
	cin>>sx>>sy>>fx>>fy;
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=m+1;j++)
		{
			if(i==0||j==0||i==n+1||j==m+1)
			{
				s[i][j]=1;     //初始化迷宫
			}
		}
	}
	for(int i=1;i<=t;i++)
	{
		cin>>a>>b;
		s[a][b]=1;      //将障碍放入迷宫
	}
	s[sx][sy]=1;     //标记起点
	dfs(sx,sy);
	cout<<ans;
}
```


---

## 作者：trajep (赞：1)


```
记忆化搜索
mem[i*n+j] 存储[i,j]到终点的可行路径数量
```

```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

int graph[6][6] = {0};
int visited[6][6] = {0};
unordered_map<int, int> mem;
pair<int, int> startp, endp;
int res = 0;

int dfs(int i, int j, int n, int m) {
    if (i < 1 || i > n || j < 1 || j > m) return 0;
    if (visited[i][j]) return 0;
    if (graph[i][j] == -1) return 0;
    if (i == endp.first && j == endp.second) {
        return 1;
    }
    visited[i][j] = 1;
    int n1 = dfs(i+1, j, n, m);
    int n2 = dfs(i-1, j, n, m);
    int n3 = dfs(i, j+1, n, m);
    int n4 = dfs(i, j-1, n, m);
    visited[i][j] = 0;
    mem[i*n+j] = n1 + n2 + n3 + n4;
    return mem[i*n+j];
}

int main() {
    int n, m, t; cin >> n >> m >> t;
    cin >> startp.first >> startp.second;
    cin >> endp.first >> endp.second;

    while (t--) {
        int i, j;
        cin >> i >> j;
        graph[i][j] = -1;
    }

    res = dfs(startp.first, startp.second, n, m);
    cout << res << endl;
    return 0;
}
```


---

## 作者：JackLiMors (赞：1)

简单的深搜，一觉得能用DP做，转移方程为:

dp[i][j] = dp[i-1][j] + dp[i][j-1]

后来一想，走过头咋办？

dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i+1][j] + dp[i][j+1]

后来一想，走过头再走回来的路径中包含终点咋办？

不过这不是什么大问题，简单的判断就行了。

但是继续往下想再出其他问题咋办？

颅内时间复杂度太高，pass，直接dfs过:

```#include<iostream>
#include<algorithm>
using namespace std;

int N,M,T,xs,ys,xe,ye,xt,yt,cnt;
bool** map;


void dfs(int i, int j, int dire, int& cnt) {
	if(dire == 0) {
		if(i - 1 <= 0 || map[i-1][j] == false) return ;
		if(i - 1 == xe && j == ye) {
			++cnt;
			return;
		}
		map[i-1][j] = false;
		for(int d = 0; d <= 3; d++)
			dfs(i-1,j,d,cnt);
			
		map[i-1][j] = true;
	}
	if(dire == 1) {
		if(i + 1 > N || map[i+1][j] == false) return ;
		if(i + 1 == xe && j == ye) {
			++cnt;
			return;
		}
		
		map[i+1][j] = false;
		for(int d = 0; d <= 3; d++)
			dfs(i+1,j,d,cnt);
		map[i+1][j] = true;
	}
	if(dire == 2) {
		if(j+1 > M || map[i][j+1] == false) return ;
		if(i == xe && j + 1 == ye) {
			++cnt;
			return;
		}
		
		map[i][j+1] = false;
		for(int d = 0; d <= 3; d++)
			dfs(i,j+1,d,cnt);
		map[i][j+1] = true;
	}
	if(dire == 3) {
		if(j-1 <= 0 || map[i][j-1] == false) return ;
		if(i == xe && j-1 == ye) {
			++cnt;
			return;
		}
		map[i][j-1] = false;
		for(int d = 0; d <= 3; d++)
			dfs(i,j-1,d,cnt);
		map[i][j-1] = true;
	}
}

int main() {
	while(cin >> N >> M >> T) {
		cin >> xs >> ys >> xe >> ye;
		map = new bool*[N] -1 ;
		for(int i = 1; i <= N; i++)
			map[i] = new bool[M] -1;

		for(int i = 1; i <= N; i++)
			for(int j = 1; j <= M; j++)
				map[i][j] = true;

		for(int i = 0; i < T; i++) {
			cin >> xt >> yt;
			map[xt][yt] = false;
		}
		
		map[xs][ys] = false;
		for(int i = 0; i <= 3; i++)
			dfs(xs,ys,i,cnt);

		for(int i = 1; i <= N; i++)
			delete [](map[i]+1);
		delete [](map+1);
		
		cout << cnt << endl;
	}
	return 0;
}
```

---

## 作者：ForwarDer (赞：1)

普及组深搜入门题，思路很简单，具体见代码注释。

如果数据范围再大些，就要用宽搜了。

而这个数据，深搜0ms水过。

感谢 微亚040214 对于我dfs函数优化的提醒！





```cpp
#include <bits/stdc++.h>
#define N 6
using namespace std;
int n ,m ,t;
int sx ,sy ,fx ,fy ,a ,b ,tot=0;
bool mp[N][N] ,vis[N][N];
const int dx[4]={1 ,0 ,-1 ,0};
const int dy[4]={0 ,1 ,0 ,-1};
void dfs(int x ,int y);
int main()
{
    memset(mp ,true ,sizeof(mp));
    memset(vis ,false ,sizeof(vis));  //初始化两个数组，mp true为非障碍，vis true为已访问
    cin>>n>>m>>t;
    cin>>sx>>sy>>fx>>fy;
    while(t--) {
        cin>>a>>b;
        mp[a][b]=false;  //在地图上做标记
    }
    vis[sx][sy]=true;
    dfs(sx ,sy); //从起始坐标开始深搜
    cout<<tot<<endl;
    return 0;
}
void dfs(int x ,int y)
{
    if(x==fx && y==fy) {
        tot++;
        return ;  //访问到目标点则方案数+1
    }    
    for(int i=0 ;i<4 ;i++) {
        int nx=x+dx[i] ,ny=y+dy[i];
        if(nx>=1 && nx<=n &&
           ny>=1 && ny<=m && 
           mp[nx][ny] && !vis[nx][ny]) {  //拓展点并判断是否可行
            vis[nx][ny]=true;
            dfs(nx ,ny);
            vis[nx][ny]=false;       //回溯
        }
    }
}
```

---

## 作者：月祖儿 (赞：1)

看到讨论很多讨论终点也会为1的问题，解决方法其实也很简单，在搜索之前首先判断当前位置是否为1就ok了。

以下是我的代码，当然初学搜索，参考了很多大神的思路，但是发现很少有c的，就来发一发。

```cpp
#include<stdio.h>
#include<string.h>
int a[6][6],n,m,t,sx,sy,fx,fy,num;
int dir[4][2]={{0,1},{1,0},{-1,0},{0,-1}};//四个方向
void dfs(int x,int y)//搜索
{
    if(a[x][y])return;//若当前位置不通则返回。
    if(x==fx&&y==fy){num++;return;}
    int i;
    for(i=0;i<4;i++)
    {
      if(0<x&&x<=n&&0<y&&y<=m){
        a[x][y]=1;
        dfs(x+dir[i][0],y+dir[i][1]);
        a[x][y]=0;
      }
    }
}
int main()
{
    int i,x,y;
    memset(a,0,sizeof(a));//0为通
    scanf("%d %d %d\n",&n,&m,&t);
    scanf("%d %d %d %d\n",&sx,&sy,&fx,&fy);
    for(i=0;i<t;i++)
    {
        scanf("%d %d\n",&x,&y);
        a[x][y]=1;//1为不通
    }
    num=0;//计数总方案数
    dfs(sx,sy);
    printf("%d\n",num);
    return 0;
}
```

---

## 作者：a___ (赞：1)

dfs
```cpp
#include <iostream>
using namespace std;
int n/*行数*/,m/*列数*/,T/*障碍点数*/,sx/*起点行*/,sy/*起点列*/,fx/*终点行*/,fy/*终点列*/,xx/*障碍行*/,yy/*障碍列*/,a[30][3]/*每步行列*/,t=0/*路径条数*/,x[4]={-1,0,1,0},y[4]={0,1,0,-1}/*上右下左行列变值*/;
bool b[6][6]={0};                          //障碍点控制 
int search (int k)
{
    int i;
    for (i=0;i<4;i++)
    if (a[k-1][1]+x[i]>0&&a[k-1][1]+x[i]<=n&&a[k-1][2]+y[i]>0&&a[k-1][2]+y[i]<=m)  //控制边界 
    if (!b[a[k-1][1]+x[i]][a[k-1][2]+y[i]])                                        //控制障碍点及走过不能走 条件 
    {
        a[k][1]=a[k-1][1]+x[i];                                                    //控制本步行数 
        a[k][2]=a[k-1][2]+y[i];                                                    //控制本步列数 
        b[a[k-1][1]+x[i]][a[k-1][2]+y[i]]=1;                                       //此点不可走 
        if (a[k][1]==fx&&a[k][2]==fy) t++;                                         //路径条数+1 
        else search (k+1);                                                         //走下一步 
        b[a[k-1][1]+x[i]][a[k-1][2]+y[i]]=0;                                       //释放控制（回溯一步） 
    }
}
int main()
{
    int i;
    cin>>n>>m>>T>>sx>>sy>>fx>>fy;                                  //输入 
    for (i=0;i<T;i++)
    {
        cin>>xx>>yy;
        b[xx][yy]=1;
    }                                                                             //障碍点控制 
    a[1][1]=sx;a[1][2]=sy;                                     //附起点值 
    b[sx][sy]=1;
    search(2);                                                   //回溯 
    cout<<t<<endl;                                               //输出 
    return 0;
}
```

---

## 作者：ajil (赞：1)

比较简单的深搜

用一个二维数组描述能不能走就行了

···cpp

```cpp
#include <iostream>
#include <cstring>
using namespace std;
bool map[7][7];
```
/\*当值true为障碍或已访问
\*false为可走

\*/
```cpp
int ans(0);        //答案
int fx,fy;
void dfs(int,int);    //深搜，定义在下
int main()
{
```
/\*--------初始化map数组--------\*/
```cpp
    memset(map,-1,sizeof(map));
    int n,m,t;
    cin >> n >> m >> t;
    for(int i(1);i<=n;++i)
        for(int j(1);j<=m;++j)
            map[i][j] = false;
```
/\*----将边界的值设为true----\*/
```cpp
    int sx,sy;
    cin >> sx >> sy;
    cin >> fx >> fy;
    for(int i(0);i<t;++i)
    {
        int stx,sty;
        cin >> stx >> sty;
        map[stx][sty] = true;
    }
    dfs(sx,sy);
    cout << ans;
    return 0;
}
int dx[4] = {0,1,0,-1};
int dy[4] = {1,0,-1,0};
void dfs(int x,int y)
{
```
/\*注意：
\*终点可能为障碍(坑爹啊)

\*所以要先判断是否可走

\*/
```cpp
    if(map[x][y])
        return;
    if(x==fx && y==fy)
    { ++ans; return; }
    else
    {
        map[x][y] = true;
        for(int i(0);i<4;++i)
            dfs(x+dx[i], y+dy[i]);
        map[x][y] = false;
    }
}
···
```

---

## 作者：debiluz (赞：1)

一道基本的dfs，看楼下cpp代码中递归用了好几次dfs,写成dx,dy存数组不是更方便？要记得回溯哦。注意：起始点一开始就要标记走过。下面附上代码～

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n,m,t,ans = 0;
int i,j;
int x0,y0,x1,y1; //起点和终点
int a[6][6],v[6][6]; //数组a用于标记障碍,v记录
int dx[] = {0,1,-1,0};
int dy[] = {1,0,0,-1};
bool in(int x, int y) //在方格中
{
    return (x >= 1 && x <= n && y >= 1 && y <= m);
}
void dfs(int x, int y) //传递坐标
{
    if (x == x1 && y == y1)
    {
        ans++;
        return;
    }
    for (int l = 0; l < 4; l++)
    {
        int tx = x + dx[l];
        int ty = y + dy[l];
        if (in(tx,ty) && v[tx][ty] == 0 && a[tx][ty] == 0) //在范围，未访问，无障碍
        {
            v[tx][ty]++;
            dfs(tx,ty);
            v[tx][ty]--; //回溯
        }
    }
}
int main()
{
    cin >> n >> m >> t;
    cin >> x0 >> y0 >> x1 >> y1;
    v[x0][y0] = 1;
    for (i = 1; i <= t; i++)
    {
        int t1,t2;
        cin >> t1 >> t2;
        a[t1][t2] = 1; //1表示有障碍
    }
    dfs(x0,y0);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：H15teve (赞：1)

代码特点：优雅、易懂（好自夸）。

很简单的回溯dfs，而且数据小的可怜···注意终点有障碍的特判就行了，dfs当中甚至比八皇后更好的入门题






```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n,m,t,sx,sy,fx,fy,ans=0;
bool map[6][6];
bool check(int a,int b)
{
    if(a==fx && b==fy)
    {
        ans++;
        return 1;
    }
    if (map[a][b]) return 1;
    return 0;
}
void dfs(int x,int y)
{
    map[x][y]=1;
    if (x>1 && !check(x-1,y)) dfs(x-1,y);
    if (x<n && !check(x+1,y)) dfs(x+1,y);
    if (y>1 && !check(x,y-1)) dfs(x,y-1);
    if (y<n && !check(x,y+1)) dfs(x,y+1);
    map[x][y]=0;
}
int main()
{
    scanf("%d%d%d",&n,&m,&t);
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    for (int i=1;i<=t;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if (x==fx && y==fy)
        {
            cout<<'0';
            return 0;
        }
        map[x][y]=1;
    }
    dfs(sx,sy);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：dragon_bra (赞：1)

这题是最基础的dfs问题，写个最粗暴的dfs本以为能过，结果是90。

原因是什么呢？原因是终点有可能有障碍物，这时必须输出0，简单，加个特判就好了。


附代码：

    
    
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n,m,t;
int sx,sy,ex,ey;
int a[1000][1000];
int b[1000][1000];
int count=0;
void dfs(int x,int y)
{
    int i;
    if(x==ex&&y==ey)
    {
        count++;
        return; 
    } 
    if(x<1||y<1||x>n||y>m)
        return;
    if(a[x][y]==1||b[x][y]==1)
        return;
    b[x][y]=1;
    dfs(x+1,y);
    dfs(x-1,y);
    dfs(x,y+1);
    dfs(x,y-1);
    b[x][y]=0;
    return;
}
int main()
{
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    int i;
    int la,lb;
    cin>>n>>m>>t;
    cin>>sx>>sy>>ex>>ey;
    for(i=1;i<=t;i++)
    {
        cin>>la>>lb;
        a[la][lb]=1;
    }
    if(a[ex][ey]==1)
    cout<<"0";
    else
    {
        dfs(sx,sy);
        cout<<count;
    }
    return 0;
}
```

---

## 作者：YE110W_No1 (赞：1)

**上传一个经典又简洁的程序**

这道题的深搜需要如下步骤：

1.初始化整个棋盘

2.标记障碍

3.开始搜索 [/color][ color=red]要记得把起点也标记为障碍点！[/color]  【我就是因为这个浪费好几次提交机会ORZ】

4.向四个方向走 每走一步就把当前步标记为障碍点 检测到终点就inc(ans)

5.**要记得回溯**

[/color][codep]

```cpp
const
  dx:array[1..4] of longint=(-1,0,1,0);
  dy:array[1..4] of longint=(0,1,0,-1);             //上下左右四个方向
var
  x1,y1,x2,y2,n,m,t,i,j,ans,q,p:longint;
  a:array[1..5,1..5] of boolean;         //数组开这么大就够了啊- -
procedure dfs(x,y:longint);
var
  i:longint;
begin
  if (x=x2)and(y=y2) then
    begin
      inc(ans);
      exit;
    end;           //到终点 答案+1 继续搜索
  for i:=1 to 4 do
    if (x+dx[i]>0)and(x+dx[i]<=n)and(y+dy[i]>0)and(y+dy[i]<=m)and(a[x+dx[i],y+dy[i]]) then        //判断该点是否在棋盘内或是否被占领
      begin
        a[x+dx[i],y+dy[i]]:=false;             //占领该点
        dfs(x+dx[i],y+dy[i]);
        a[x+dx[i],y+dy[i]]:=true;                 //最重要的回溯
      end;
end;
begin
  readln(n,m,t);
  readln(x1,y1,x2,y2);
  fillchar(a,sizeof(a),true);
  for i:=1 to t do
    begin
      readln(q,p);
      a[q,p]:=false;
    end;
  a[x1,y1]:=false;//注意起点也要标记为占领状态
  dfs(x1,y1);
  writeln(ans);
end.
[/codep]
```

---

## 作者：Kwork (赞：1)

```delphi
var
n,m,t:longint;
i,j:longint;
f:array[0..100,0..100]of boolean;
sx,sy,fx,fy:longint;
x,y,xx,yy:longint;
ans:longint;
procedure dfs(xx,yy:longint);{简单的深搜回溯，题面说，可以向四个方向走，
那么久走一步搜一步，检测到终点就inc(ans)}
var
x,y:longint;
i,j,k:longint;
begin
    x:=xx;y:=yy+1;
    if    f[x,y] then
    begin
        f[x,y]:=false;
        dfs(x,y);
        f[x,y]:=true;//非常重要的恢复环境，回溯
    end
    else
    if    (x=fx)and(y=fy) then inc(ans);

    x:=xx;y:=yy-1;
    if    f[x,y] then
    begin
        f[x,y]:=false;
        dfs(x,y);
        f[x,y]:=true;
    end
    else
    if    (x=fx)and(y=fy) then inc(ans);

    x:=xx+1;y:=yy;
    if    f[x,y] then
    begin
        f[x,y]:=false;
        dfs(x,y);
        f[x,y]:=true;
    end
    else
    if    (x=fx)and(y=fy) then inc(ans);

    x:=xx-1;y:=yy;
    if    f[x,y] then
    begin
        f[x,y]:=false;
        dfs(x,y);
        f[x,y]:=true;
    end
    else
    if    (x=fx)and(y=fy) then inc(ans);
end;

Begin
    fillchar(f,sizeof(f),false);{设置好边界}
    readln(n,m,t);
    for i:=1 to n do
    for j:=1 to m do
    f[i,j]:=true;
    readln(sx,sy,fx,fy);
    f[sx,sy]:=false;
    f[fx,fy]:=false;
    for i:=1 to t do
    begin
        readln(x,y);
        if (x=fx) and (y=fy) then{如果有一个障碍在终点那么无论如何都达不到，直接输出0，退出程序。}
        begin
            writeln(0);
            halt;
        end;
        f[x,y]:=false;
    end;

    dfs(sx,sy);
    writeln(ans);
End.
```

---

## 作者：刘易成3 (赞：1)

此题通过传统深搜，先定义两个方向数组，在定义一个判断有没有走过的数组，注意，判断有没有走过的数组初始化时需要把起始点判为已走过，之后深搜就可以了。

```delphi

program d1;
var
a,d:array[1..1000,1..1000] of longint;
b,c:array[1..4] of longint;
n,m,l,p,x,y,f,k,i:longint;
procedure sou(x,y:longint);           //深搜
var
i:longint;
begin
if a[x,y]=1 then begin 
    f:=f+1;
    exit;
end;
for i:=1 to 4 do
    if (x+b[i]>0) and (x+b[i]<=n) and (y+c[i]>0) and (y+c[i]<=m) and (a[x+b[i],y+c[i]]<>2) and (d[x+b[i],y+c[i]]<>1)then begin
        d[x+b[i],y+c[i]]:=1;
    sou(x+b[i],y+c[i]);
        d[x+b[i],y+c[i]]:=0;
    end;
end;
begin
readln(n,m,k);
readln(x,y,l,p);
a[l,p]:=1;
for i:=1 to k do
    begin
    read(l,p);
a[l,p]:=2;
end;
b[1]:=1;
c[1]:=0;
b[2]:=0;
c[2]:=1;
b[3]:=-1;
c[3]:=0;
b[4]:=0;
c[4]:=-1;   //方位
d[x,y]:=1;   //初始化
sou(x,y);
write(f);
end.

```

---

## 作者：hongzy (赞：1)

貌似我的代码短些

```cpp
#include <iostream>
using namespace std;

int n, m, t, tot; //tot为方案总数 
int sx, sy, fx, fy;
int a[101][101];

void dfs(int x, int y) {  //当前深搜的点是(x,y) 
    if(x < 1 || x > n || y < 1 || y > m || a[x][y] == 1) return;  //如果越界或遇障碍则返回; 
    if(x == fx && y == fy) { //如果到终点则记录 
        tot ++;
        return;
    }
    a[x][y] = 1; //标记：已经经过 
    dfs(x+1, y); //向右走 
    dfs(x-1, y); //向左走 
    dfs(x, y+1); //向上走 
    dfs(x, y-1); //向下走 
    a[x][y] = 0; //回溯：退回前标记-没有经过这个点 
}

int main() {
    int x, y;
    cin >> n >> m >> t;
    cin >> sx >> sy >> fx >> fy;
    for(int i=1; i<=t; i++) {
        cin >> x >> y;
        a[x][y] = 1; //标记这个点有路障 
    }
    dfs(sx, sy); //从点(sx,sy)开始深搜 
    cout << tot << endl;
    return 0;
}
```

---

## 作者：Ryo_Yamada (赞：0)

迷宫这系列的题算是dfs最经典的题了吧。

窝看到有一些dl用map标记，这里就给没学过map的提供一种做法。

我们用一个char数组记录障碍和起点。

```cpp
char c[6][6];
```
```cpp
if(c[sx][sy] == 'T'){
        cnt++;
        return;
}//标记终点
```
```cpp
for(int i=0; i<t; i++){
        int zx,zy;
        cin >> zx >> zy;
        c[zx - 1][zy - 1] = '#';
}//标记障碍
```
最后是我~~可爱~~的代码君：

```cpp
#include <iostream>
using namespace std;
char c[6][6];
int cnt;
int dir[4][2] = {
    {1,0},
    {0,1},
    {-1,0},
    {0,-1}
};//下一步
int n,m;
bool vis[6][6];//记录是否走过
bool in(int sx, int sy){//是否在地图内
    return sx >= 0 && sx < n && sy >= 0 && sy < m;
}
void dfs(int sx, int sy){//深搜
    vis[sx][sy] = true;
    if(c[sx][sy] == 'T'){
        cnt++;
        return;
    }//如果是终点，计数++，返回
    for(int i=0; i<4; i++){
        int tx = sx + dir[i][0];
        int ty = sy + dir[i][1];//记录下一步的坐标
        if(in(tx,ty) && !vis[tx][ty] && c[tx][ty] != '#'){//判断递归条件
            vis[tx][ty] = true;//标记
            dfs(tx,ty);//递归搜索
            vis[tx][ty] = false;//尝试回溯
        }
    }
    return;
}   
int main(){
    int t;
    cin >> n >> m >> t;
    int sx,sy,fx,fy;
    cin >> sx >> sy >> fx >> fy;
    c[fx - 1][fy - 1] = 'T';
    for(int i=0; i<t; i++){
        int zx,zy;
        cin >> zx >> zy;
        c[zx - 1][zy - 1] = '#';
    }
    dfs(sx - 1,sy - 1);//搜索，如果像我一样喜欢由0开头，需要-1
    cout << cnt;//输出
    return 0;
}完结撒花
```
希望能帮到大家，最后祝大家AC此题

---

## 作者：FirCoder (赞：0)

#  迷宫都是经典DFS（BFS）题。我们需要模拟人走迷宫的一个过程，所以限制条件很好判断:
###     1：超出迷宫范围就要返回
###     2：碰到墙就返回
###     3：上下左右都走不通返回
###  	4：不能走前面已经走过的路  ~~那就死循环了~~
    
------------
代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, t, sx, sy, ex, ey, times;
int mapp[10][10]; // 存迷宫
bool v[10][10]; // 判断有没有走过
int ne[4][2] = {0, 1, 0, -1, 1, 0, -1, 0}; // 四个方向，一定要看清写对，好多次这里-1，1，0写错但没有发现，很难受。
void dfs(int x, int y);
int main()
{
	cin >> n >> m >> t;
	cin >> sx >> sy >> ex >> ey;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= m; ++j)
			mapp[i][j] = 1;
	} // 初始化迷宫为1，迷宫以外的多余地方为0，这样判断mapp[x][y]是否为0就可以判断是否出界
	while (t--)
	{
		int x, y;
		cin >> x >> y;
		mapp[x][y] = 0; // 把有墙的地方变0
	}
	dfs(sx, sy);
	cout << times << endl;
	return 0;
}
void dfs(int x, int y)
{
	if (x == ex && y == ey) // 到达终点
	{
		times++;
		return ;
	}
	//if (v[x][y] || mapp[x][y] == 0) return ; // 不能在这里判断，要在for循环里面就判断，这样会出界
	for (int i = 0; i <= 3; ++i)
	{
		
		int xx = x + ne[i][0], yy = y + ne[i][1];
		if (!v[xx][yy] && mapp[xx][yy] == 1) // 在这里判断可以预防出界
		{
			v[x][y] = true; // 如果可以走(xx, xy)则在当前位置打标记，说明已经走过，避免死循环
			// cout << x << " " << y << endl;
			dfs(xx, yy);
			v[x][y] = false; // 返回后要去除标记
		}
	}
	return ;
}
```


---

## 作者：yubing_lml (赞：0)

NO.10 向DFS发起进攻！一次AC的深搜纪念一下~

主要思想：DFS+剪枝。

把障碍点的数组值a[i][j]设置为1。搜索时，如果当前坐标即为目标坐标，答案数加1，否则，依次遍历当前坐标的上下左右点。遍历之前要判断当前点是否走过，是否是迷宫里的合法点。因为每个坐标点最多走一次，所以要用mark标记一下已经走过的点。该点遍历完成后，要解除标记，继续下面点的遍历。

#### 注意：起点开始搜索已经被标记！

```cpp
#include<iostream>
#include<cstring>
using namespace std;

int a[6][6];
int n, m, t, sx, sy, fx, fy,x,y;
bool mark[6][6];
int change[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };

int dfs(int sx, int sy)
{
	int ans = 0;
	if (a[sx][sy] == 1)
		return 0;
	if (sx == fx && sy == fy)
		return 1;
	int nx, ny;
	for (int i = 0; i < 4; i++)
	{
		nx = sx + change[i][0];
		ny = sy + change[i][1];
		if (nx<1 || nx>n || ny<1 || ny>m|| mark[nx][ny] == true)
			continue;
		mark[nx][ny] = true;
		ans += dfs(nx, ny);
		mark[nx][ny] = false;
	}
	return ans;
}

int main()
{
	cin >> n >> m >> t >> sx >> sy >> fx >> fy;
	memset(a, 0, sizeof(a));
	memset(mark, false, sizeof(mark));
	mark[sx][sy] = true;
	while (t--)
	{
		cin >> x >> y;
		a[x][y] = 1;  //1 represents obstacle
	}
	cout << dfs(sx, sy);
	cin >> n;
	return 0;
}
```

---

## 作者：没有输入 (赞：0)

# 深搜模板题——迷宫问题

标准的不能再标准的深搜模板。唯一的区别就是读入方式。

### 基本思路

读入时进行预处理，然后从起点开始递归，枚举四个方向，没有障碍的就进去，同时将该点标记以避免再次进入。一旦搜到终点就将答案数加一，然后返回。直到枚举完所有可能性，就输出并结束。

### 坑点

- 对经过的点作的标记在返回后要记得还原
- 起点一旦离开就不能再经过，所以一开始不要忘记标记起点

读入并进行预处理，0表示可以通过，1表示不允许通过
```cpp
scanf("%d%d%d%d%d%d%d",&n,&m,&t,&sx,&sy,&ex,&ey);
for(int i=1;i<=t;i++)
{
	int x,y;
	scanf("%d%d",&x,&y);
	a[x][y]=1;
}
```
千万不要忘记对起点进行标记
```cpp
a[sx][sy]=1;
```
#### 深搜
```cpp
void dfs(int x,int y)
{
```
//如果已经到终点，就将答案加一并返回
```cpp
if(x==ex&&y==ey)
{
	ans++;
	return;
}
```
//否则就向四个方向展开搜索
```cpp
for(int i=0;i<4;i++)
{
	int nx=x+dx[i],ny=y+dy[i];
	if(nx>0&&ny>0&&nx<=n&&ny<=m&&!a[nx][ny])
	{
		a[nx][ny]=1;
		dfs(nx,ny);
		a[nx][ny]=0;
	}
}
```
}

### 总结

本题为深搜模板题，除了要注意几个坑点，其他都是只要对深搜有基本的理解就能做出的。

## 标程
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10],n,m,t,sx,sy,ex,ey,ans,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};
void dfs(int x,int y)
{
	if(x==ex&&y==ey)
	{
		ans++;
		return;
	}
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>0&&ny>0&&nx<=n&&ny<=m&&!a[nx][ny])
		{
			a[nx][ny]=1;
			dfs(nx,ny);
			a[nx][ny]=0;
		}
	}
}
int main()
{
	scanf("%d%d%d%d%d%d%d",&n,&m,&t,&sx,&sy,&ex,&ey);
	for(int i=1;i<=t;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[x][y]=1;
	}
	a[sx][sy]=1;
	dfs(sx,sy);
	printf("%d",ans);
	return 0;
}
```
## 拓展 · 深搜

深度优先搜索属于图算法的一种，英文缩写为DFS，即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.

### 模板
```cpp
void dfs(参数)
{
	if(满足条件)
	{
		输出或记录;
		return;
	}
	依题意进行搜索;
}
```


---

## 作者：dzz1537568241 (赞：0)

# 有关于部分人明明算法没什么问题，但是只能拿80分的解答

~~看了题解区很多人的疑问，实在看不下去居然没有人解答~~

先放代码，下面有一个小小的错误（也是很多人拿80分的理由）

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int answer=0;
int vis[6][6]; 
int N;int M;
int T;
int sx,sy;int fx,fy;
int judge(int x,int y){
	if(vis[x][y]==1){
		return 1;
	}
	return 0;
}
int dfs(int x,int y){
	if(x==fx && y==fy){
		answer++;
	}
	else{
		if(judge(x+1,y)){
			vis[x][y]=0;
			dfs(x+1,y);
			vis[x][y]=1;
		}
		if(judge(x,y+1)){
			vis[x][y]=0;
			dfs(x,y+1);
			vis[x][y]=1;
		}
		if(judge(x,y-1)){
			vis[x][y]=0;
			dfs(x,y-1);
			vis[x][y]=1;
		}
		if(judge(x-1,y)){
			vis[x][y]=0;
			dfs(x-1,y);
			vis[x][y]=1;
		}
	}
}
int main(){
	memset(vis,0,sizeof(vis));
	cin>>N;
	cin>>M;
	for(int i=1;i<=N;i++){
		for(int j=1;j<=M;j++){
			vis[i][j]=1;
		}
	}
	cin>>T;
	cin>>sx;cin>>sy;cin>>fx;cin>>fy;
	for(int i=1;i<=T;i++){
		int temp;
		int t;
		cin>>temp;cin>>t;
		vis[temp][t]=0;
	}
	vis[sx][sy]=0;
	dfs(sx,sy);
	cout<<answer;
}
```
很简单的回溯题目，但很多人**只有80分**，会卡两个点，为什么？


------------

先说一下大概思路：设立一个数组来判断这个点有没有走过和能不能走，为了偷懒，我们一开始把这个数组的边界

**注意：在以上思路中，必须要注意的是：第0，N+1行和第0,M+1列被我们设为不能走了**

上述就是错误的原因
我瞅了一眼题解区，好像没人思考这个问题，（第一楼的大佬还说不能这样干）但事实上，大家可以把6改成7，保证对。为什么呢？


------------

下面是解答：

如果开了数组大小为6，行数最多为5，第0行第0列被空掉作为边界，请仔细看一眼我刚刚叙述的大概思路,确实第0行第0列被设为不能走了，那第N+1行和第M+1列你有设咩？

也就是说为了应付5 * 5的数据，应该开7 * 7大小的数组，相似的，为了应付N * M的数据，开的数组大小应该是(N+2,M+2)

这就是原因。

---

## 作者：_maze (赞：0)

看到各位DaLao都是用的bfs呀……实际上这道题是一道~~标准的~~dfs，大家也可以做一下一道叫“[红与黑](http://ybt.ssoier.cn:8088/problem_show.php?pid=1216)” 的题。下面说一下要点：

1，用dfs首要考虑是否需要进行回溯，而这道题因为不会走向错误的方向，所以不需要回溯

2，这是dfs的特殊类型(联通块）

上代码
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int he=0,xx,yy,fx[4]={0,0,1,-1},fy[4]={1,-1,0,0};//fx与fy为离散化 x，y为查找开始坐标，xx，yy为范围
string que[103];//输入用字符串
void dfs(int x,int y){//递归程序
	for(int i=0;i<=3;i++){//离散化试探
		int tx=x+fx[i];
		int ty=y+fy[i];
		if(tx>=0&&ty>=0&&que[tx][ty]!='0'&&tx<xx&&ty<yy){//判断是否为范围之内且不等于0.
			que[tx][ty]='0';//将走过的地方置为零
			dfs(tx,ty);//继续
		}
	}
	return ;//需要返回，不然会爆
}
int main(){
	cin>>xx>>yy;//输入，此题可不用scanf
	for(int i=0;i<xx;i++){
		cin>>que[i];
	}
	int a=0;
	for(int i=0;i<xx;i++){
		for(int j=0;j<yy;j++){
			if(que[i][j]!='0'){//查找细胞的一部分
				dfs(i,j);
				he++;
			}
		}
	}
	cout<<he;//输出
    return 0;
}
```

---

## 作者：Meaninglessness (赞：0)

这道题给我的第一感觉是

# 算法：DFS（深搜）
那么解此题为大家讲述一下深搜的用法

算法：dfs

时间复杂度：o（n^2）

用途：关于迷宫需要从一个位置走到另一个位置时可用

原理：从起点开始，上下左右分别寻找，如果未走过并且无障碍，将此点设为已走过并从此点递归（但注意要回溯），如果坐标与终点相符，那说明这是一种方案，答案总数++。

~~（还不懂的自行查百度）~~

先上AC代码吧：
```cpp
#include <iostream>
using namespace std;
int a[10][10];//迷宫的二维数组
int sx,sy,fx,fy;//分别为起点x起点y终点x终点y
int n,m;//n为行数，m为列数
int ans,vis[10][10];//可行方案的数量，visit数组
int dx[4]={1,-1,0,0;
int dy[4]={0,0,1,-1};
//方向为:   ↑ ↓ →  ←
void dfs(int x,int y)
{
    int i,nowx,nowy;
    if(x==fx && y==fy)//如果所在坐标就为终点坐标
    {
        ans++;//这是一种可行方案，答案+1
        return;//返回
    }
    for(i=0;i<4;i++)
    {
        nowx=x+dx[i];//指走完上下的x坐标
        nowy=y+dy[i];//指走完左右的y坐标
        if(nowx>=1 && nowx<=m && nowy>=1 && nowy<=n && vis[nowx][nowy]==0)//如果xy坐标在这个迷宫的范围内并且未走过
        {
            vis[nowx][nowy]=1;//将它设为走过的
            dfs(nowx,nowy);//继续递归下去
            vis[nowx][nowy]=0;//回溯
        }
    }
}
int main()
{
    int i,j,t,h,l;//t为障碍总数，h为障碍x坐标,l为障碍y坐标
    cin>>m>>n>>t;
    cin>>sx>>sy>>fx>>fy;
    vis[sx][sy]=1;//将起点设为已走过
    for(i=1;i<=t;i++)
    {
        cin>>h>>l;//输入障碍的x,y坐标
        vis[h][l]=1;//将这个坐标点设为不能走
    }
    dfs(sx,sy);//从起点开始搜索
    cout<<ans<<endl;
    return 0;
}
```
# 最最最重要的来了
dfs模板
```cpp
int fx,fy,n,m,ans,vis[10][10];
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
void dfs(int x,int y)
{
    int i,nowx,nowy;
    if(x==fx && y==fy)
    {
        ans++;
        return;
    }
    for(i=0;i<4;i++)
    {
        nowx=x+dx[i];
        nowy=y+dy[i];
        if(nowx>=1 && nowx<=m && nowy>=1 && nowy<=n && vis[nowx][nowy]==0)
        {
            vis[nowx][nowy]=1;
            dfs(nowx,nowy);
            vis[nowx][nowy]=0;
        }
    }
}
```
## 祝大家顺利通过！！！


---

## 作者：Tyler2 (赞：0)

### 本蒟蒻第一次发布题解~~ 望洛谷审核通过！
废话少说，这是本蒟蒻的解题思路：

---------

这是一张图：
| a[8][4] |0 | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | start| 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 0 | 1 | 1 | 1| 0 |
| 2 | 0 | 0 | 1 | 0 | 0 | 0|
| 3 | 1 | 0 | 0 | 0 | 1 |  finish |
可以用广搜的方式波浪搜索，最后可以得到:
| 1 | 2 |  3| 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 2 |2  |  3|4  | 5 |6  | 
| 3 | 3 | 4 | 5 | 6 | 7 |
|  4| 4 |  5|  6| 7 | 8 |
八步就可以搜完。生成树只有八层。
得到到终点有2条：
|1，2 | 1，2 | 1 | 1 | 1 |1  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  0|  2| 0 | 0 |0  |1  |
|  0| 2 | 0 |2  |2  |2，1 |
| 0 | 2 | 2 | 2 | 0 | 2，1 |
~~先做好的图插入不上去，郁闷死本蒟蒻了~~

下面贴上代码~
```
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
int cnt,sx,sy,fx,fy,ay,ax,hid,n,m;
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};
int hide[6][6];
struct nice
{
    int x,y,book[6][6];
};
nice t;
void search()
{
    queue<nice> q;      
    t.x=ax;
    t.y=ay;
    t.book[ax][ay] = 1;
    q.push(t);
    while(!q.empty())
    {
        nice now = q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int sx = now.x + dx[i];
            int sy = now.y + dy[i];
            if( now.book[ax][ay]==1||hide[ax][ay]==1||ax==0||ay==0||ax>n||sy > m)
                continue;    
            if(ax==fx&&ay==fy)
            {
                cnt++;
                continue;
            }
            t.x = ax;
            t.y =ay;
            memcpy(t.book,now.book,sizeof(now.book));
            t.book[ax][ay]=1;
            q.push(t);
        }
    }
}

int main()
{
	scanf("%d%d%d",&n,&m,&hid);
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    for(int i=1,a,b;i<=hid;i++) 
    {
        scanf("%d%d",&a,&b);
        hide[a][b] = 1;
    }
    search();
    printf("%d",cnt);
    ax=sx;
    ay=sy;
    return 0;
}
```


---

## 作者：MX_plasma (赞：0)

这道题是一道，恩，深搜题吧。

上AC代码，在注释里解释代码。
```cpp
#include<stdio.h>
using namespace std;
int FX,FY,N,M,T,TS[25][2],cnt=0,S[6][6];
/*FX FY为终点坐标，N M T题目描述有说，TS用于存储障碍坐标（我们知道N M小于等于5 所以障碍数量不超过25个），cnt用于计数（方案数量），S用于记录访问与障碍坐标*/
void Xn(int X,int Y){//递归函数
    if(S[X][Y]==1){//如果此坐标被访问过就return
        return;
    }
    S[X][Y]=1;//记录访问
    if(X==FX&&Y==FY){//如果为终点return
        cnt++;//计方案数
        S[X][Y]=0;//重置访问记录
        return;
    }
    if(X-1>0)	Xn(X-1,Y);
    if(Y-1>0)	Xn(X,Y-1);
    if(X+1<=N)	Xn(X+1,Y);
    if(Y+1<=M)	Xn(X,Y+1);
    /*上面四行用于四种方向的搜索（当时不会用数组存方向QAQ）前面的if用于判断是否可行（是否出地图）*/
    S[X][Y]=0;//重置访问记录
    return;
}
int main(){
    int SX,SY;//起点坐标
    scanf("%d %d %d %d %d %d %d",&N,&M,&T,&SX,&SY,&FX,&FY);//输入
    for(int i=0;i<T;i++){
        scanf("%d %d",&TS[i][0],&TS[i][1]);//输入障碍坐标
        S[TS[i][0]][TS[i][1]]=1;//记录障碍
    }
    Xn(SX,SY);//从起点开始深搜
    printf("%d",cnt);//输出
    return 0;//好习惯
}
```

在这里要注意一个问题：当时做的时候我的递归函数里面判断终点在判断障碍之前，结果有一个测试点的终点是有障碍的，emm还好我下了测试数据不然要卡一段时间了

其实还可以直接加个判断：如果终点有障碍直接输出0然后结束程序，这样可以减少需要的时间。

好这篇题解就到这里 欢迎各位神犇指点

---

## 作者：noifish (赞：0)

//这是一道简单的dfs，本人蒟蒻，代码丑勿喷。

//本题思路简单就是不断向四个方向递归，他的边界就是到达终点和走出地图，而且不用剪枝
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<vector>
//不要问我为什么打这么多头文件，喜欢
using namespace std;
const int zx[4] = {0,0,1,-1};//四个方向x和y的变化
const int zy[4] = {1,-1,0,0};
int ans,sx,sy,fx,fy,a,b,c;
int t[6][6];

void dfs(int x,int y){
	if(x > a||y > b||x < 1||y < 1||t[x][y]==1)return;
 //出界
	if(x == fx&&y ==fy){//到达终点
		ans++;
		return;
	}
	t[x][y]=1;//记录走过了
	for(int i = 0;i < 4;i++){
		dfs(x + zx[i],y + zy[i]);//四个方向的递归
	}
	t[x][y]=0;
}

int main(){
	scanf("%d %d %d %d %d %d %d",&a,&b,&c,&sx,&sy,&fx,&fy);
	for(int i = 1;i <= c;i++){
		int bx,by;
		scanf("%d%d",&bx,&by);
		t[bx][by]=1;
	}
	dfs(sx,sy);
	cout << ans;
	return 0;
}
```

---

## 作者：bobble (赞：0)

简单滴DFS，要注意的有：

1.记得标注起点为false，防止往回走

2.题意有点乱QAQ，首先坐标是基于坐标系来说的所以x轴对应的应该是m列,y轴对应的才是n行

其他就没啥了，一遍AC的感觉真爽啊qwq




//-----------------------------------------------------------


```cpp
program migong;
const
   dx:array[1..4] of integer=(0,0,1,-1);
   dy:array[1..4] of integer=(1,-1,0,0);
//-----------------------------------------------------------
var
   n,m,t,t1,t2,ex,ey,i,ans:longint;
   a:array[1..2,1..25] of integer;
   b:array[1..5,1..5] of boolean;
//-----------------------------------------------------------
procedure try(d:longint);
var
   x,y,i:longint;
begin
    for i:= 1 to 4 do
       begin
         x:=a[1,d-1]+dx[i];
         y:=a[2,d-1]+dy[i];
         if (x>0) and (x<=m) and (y>0) and (y<=n) then
            if b[x,y] then begin
                              b[x,y]:=false;
                              a[1,d]:=x;
                              a[2,d]:=y;
                              if (x=ex) and (y=ey) then inc(ans)
                                else try(d+1);
                              b[x,y]:=true;
                           end;
        end;
end;
//-----------------------------------------------------------
begin
   fillchar(b,sizeof(b),true);
   readln(n,m,t);
   readln(a[1,1],a[2,1],ex,ey);
   b[a[1,1],a[2,1]]:=false;
   for i:= 1 to t do
     begin
        read(t1,t2);
        b[t1,t2]:=false;
     end;
   try(2);
   writeln(ans);
end.

```

---

## 作者：我是星星 (赞：0)

这道题用深搜，就可以解决。比较经典。

代码如下：

```cpp
#include<iostream>
using namespace std;
int dx[4]={-1,1,0,0}; 
int dy[4]={0,0,-1,1};
int x,y,n,m,t,num,sx,sy,fx,fy,f[6][6],v[6][6]; 
void search(int x,int y)    //深度优先搜索 
{
    for(int i=0;i<=3;i++)            //对四个方向搜索 
    {
        int xx=x+dx[i],yy=y+dy[i];                 //走到四个新位置 
          if(!f[xx][yy]&&!v[xx][yy])                 //如果这个点不是障碍或者没走过 
            if(xx>=1&&xx<=n&&yy>=1&&yy<=m)       //如果这个点没出界       
                if((xx==fx)&&(yy==fy)) num++;        //如果到达目标点，就方案加一 
                else 
              {
                  f[xx][yy]=1;                    //否则，进行下一层搜索 
                  search(xx,yy);
                  f[xx][yy]=0;                //搜索完毕，回溯到上一状态，准备进行下一层搜索 
                } 
    }
}
int main()
{
    cin>>n>>m>>t;
    cin>>sx>>sy;
    cin>>fx>>fy;
    v[sx][sy]=1;      //把起点标记为已走，避免原地踏步 
    for(int i=1;i<=t;i++)
        {
            int a,b;
        cin>>a>>b;
        v[a][b]=1;     //标记障碍点 
      }
    search(sx,sy);  
    cout<<num;
    return 0;
}
```

---


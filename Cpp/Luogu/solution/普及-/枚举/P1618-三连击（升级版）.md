# 三连击（升级版）

## 题目描述

将 $1, 2,\ldots, 9$ 共 $9$ 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 $A:B:C$，试求出所有满足条件的三个三位数，若无解，输出 `No!!!`。


//感谢黄小U饮品完善题意


## 说明/提示

保证 $A<B<C$。

---

$\text{upd 2022.8.3}$：新增加二组 Hack 数据。

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
192 384 576
219 438 657
273 546 819
327 654 981```

# 题解

## 作者：Timothy (赞：241)

这一题很简单，做过第1008题的人应该都会，只是把比例改一改而已，代码如下（请勿抄袭）：

```cpp
#include<iostream>
using namespace std;
int a[10],b1,b2,b3,l,k1,k2,k3,ans;
int main ()
{
    cin >>k1>>k2>>k3;
    for (int b=1;b<=1000/k3;++b)
    {
        b1=b*k1;//求出三个数
        b2=b*k2;
        b3=b*k3; 
        if (b2>999||b3>999)break;
        for (int c=1;c<=3;++c)//将三个数进行分解，判断是否重复
        {
            a[b1%10]++;
            b1/=10;
        }
        for (int c=1;c<=3;++c)
        {
            a[b2%10]++;
            b2/=10;
        }
        for (int c=1;c<=3;++c)
        {
            a[b3%10]++;
            b3/=10;
        }
        for (int c=1;c<=9;++c)if (a[c]!=1){l=1;break;}
        for (int c=1;c<=9;++c)a[c]=0;
        if (!l){cout <<b*k1 <<" " <<b*k2 <<" " <<b*k3 <<endl;ans++;}//将解输出，并做标记
        else l=0;
    }
    if (!ans)cout <<"No!!!";//判断无解情况
    return 0;
}

```

---

## 作者：jojo (赞：95)

看到题解好多都是暴力枚举.....那我来贴一份深搜的代码好了（表示这里是刚入坑的小白qwq求轻喷(ﾟ∀ﾟ) ﾉ♡


···
```cpp
#include<iostream>
using namespace std;
int x[10]={0},a,b,c; //x[1]~x[9]为当前位置的数字 先把三个三位数合成一个9(10)位数的大数组
bool used[10]={0},ans=false;
//used数组表示该数字的使用情况 避免重复   ans判断是否有答案
int cons(int m){   //将数组拆分成三个三位数
    int sum=0;
    for(int i=3*m-2;i<=3*m;i++){
        sum*=10;
        sum+=x[i];
    }
    return sum;
}
void solve(int n){
    if(n==10&&cons(1)*b==cons(2)*a&&cons(1)*c==cons(3)*a){   //当n=10时x数组数字存满 开始判断
        cout<<cons(1)<<" "<<cons(2)<<" "<<cons(3)<<endl;
        ans=true;
        return;
    }
    for(int i=1;i<=9;i++){
        if(!used[i]){
            x[n]=i;   //存数字
            used[i]=1;   //该数字被使用
            solve(n+1);  //下一位继续调用
            used[i]=0;  //恢复
        }
    }
    return;
}
int main(){
    cin>>a>>b>>c;
    solve(1);  //开始搜索
    if(!ans) cout<<"No!!!";  //ans!=true即输出"No!!!"
    return 0;
}
···
```

---

## 作者：wannabe (赞：79)

这道题出的太坑人了，题意完全有歧义，构成的这三个三位数说的是分别为A、B、C的位数，竟然是这三个数比例为：A:B:C;

 
```cpp
#include<stdio.h>
int main()
{
  int i,j,k,a[10]={0},x,y,z,t=0;
  scanf("%d%d%d",&x,&y,&z);
  for(i=1;i<987;i++)
  {
      if(x*i<=987) 
      {
         a[x*i%10]++;
        a[x*i/10%10]++;
          a[x*i/100]++;
      }
    if(y*i<=987)
    {
     a[y*i%10]++;
       a[y*i/10%10]++;
       a[y*i/100]++;
    }
   if(z*i<=987)
   {
        a[z*i%10]++;
       a[z*i/10%10]++;
       a[z*i/100]++;
   }
      for(j=1;j<=9;j++)
       if(a[j]==0)
         break;
      if(j>=10)
       {
           printf("%d %d %d\n",x*i,y*i,z*i);
           t=1;
       }
      for(j=1;j<=9;j++)
        a[j]=0;
   } 
if(t==0)printf("No!!!");
 return 0;
}
```

---

## 作者：Wy12121212 (赞：62)

看了那么多大牛的代码，本蒟蒻却只会用暴力枚举，只是其中运用了一点判重的技巧（visit数组），就是把每一位的数字都从1循环到9，每一层循环的时候若visit[ix]==1则continue，否则将visit[ix]设定为1，（表明已使用该数字）然后循环到i9时判断n1:n2:n3是否等于a:b:c,每一层循环后要回溯visit[ix]=0，自以为visit数组在很多图论中都能用上，下面放上代码供参考

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
bool visit[10]={0};//visit数组，用来记录该数字是否被访问过
bool flag=0;//是否有结果
int main()
{
    int a,b,c;
    cin>>a>>b>>c;
    for(int i1=1;i1<=9;i1++)//循环
    {
        visit[i1]=1;//标记
        for(int i2=1;i2<=9;i2++)
        {
            if(visit[i2])continue;//判重
            visit[i2]=1;
            for(int i3=1;i3<=9;i3++)
            {
                if(visit[i3])continue;
                visit[i3]=1;
                for(int i4=1;i4<=9;i4++)
                {
                   if(visit[i4])continue;
                   visit[i4]=1;
                       for(int i5=1;i5<=9;i5++)
                    {
                        if(visit[i5])continue;
                        visit[i5]=1;
                        for(int i6=1;i6<=9;i6++)
                        {
                            if(visit[i6])continue;
                            visit[i6]=1;
                            for(int i7=1;i7<=9;i7++)
                            {
                                if(visit[i7])continue;
                                visit[i7]=1;
                                for(int i8=1;i8<=9;i8++)
                                {
                                    if(visit[i8])continue;
                                    visit[i8]=1;
                                    for(int i9=1;i9<=9;i9++)
                                    {
                                        if(visit[i9])continue;
                                        int n1=i1*100+i2*10+i3;
                                        int n2=i4*100+i5*10+i6;
                                        int n3=i7*100+i8*10+i9;
                                        if(double(n1)/n2==double(a)/b&&double(n2)/n3==double(b)/c)//满足题目条件
                                          {
                                               flag=1;
                                             cout<<i1<<i2<<i3<<" "<<i4<<i5<<i6<<" "<<i7<<i8<<i9<<endl;    
                                          }
                                    }
                                    visit[i8]=0;
                                }
                                visit[i7]=0;
                            }
                            visit[i6]=0;
                        }
                        visit[i5]=0;
                    }    
                    visit[i4]=0;
                }
                visit[i3]=0;
            }
            visit[i2]=0;
        }
        visit[i1]=0;//回溯
    }
    if(!flag)cout<<"No!!!";//无解
    return 0;
}
```

---

## 作者：Vel_ (赞：49)

### 打表。。 $O(b)$

打表来了。。。

打表程序：

```c++
#include<bits/stdc++.h>
using namespace std;

#define MAX 10

bool flag[10]; //flag[i]表示数字i是否有
bool No = 1; //输出No的控制
bool dex = 1;
bool check(){  //是否所有数字都有
    for(int i = 1; i < 10; ++i)  //从1开始检查
        if(flag[i] == 0) return 0;  //有一个数字没有，退出
    No = 0;
    return 1;
}

void clear(){  //清空
    for(int i = 1; i < 10; ++i)
        flag[i] = 0;
}

void mark(int num){  //标记每个数使用的数字
    flag[num/100] = 1;  //百位
    flag[(num/10)%10] = 1;  //十位
    flag[num%10] = 1;  //个位
}

int main(){
    int a, b, c;
    cout<<"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a, b, c; cin>>a>>b>>c;\n";
    for(int a = 1; a <= MAX-2; ++a)
        for(int b = a+1; b <= MAX-1; ++b)
            for(int c = b+1; c <= MAX; ++c){
                for(int i = 123; i <= 987/(c/a); ++i){  //最小的数显然是123，最大的数是987
                    clear(); //清空flag
                    if(i%a != 0) continue;  //如果i%a除不尽，显然不可能
                    int j = i/a*b; int k = i/a*c;
                    mark(i); mark(j); mark(k);  //标记
                    if(check()){
                        if(dex == 1){
                            cout<<"    if(a=="<<a<<" && b=="<<b<<" && c=="<<c<<"){\n";
                            dex = 0;
                        }
                        cout<<"        cout<< "<<i<<" <<\" \"<< "<<j<<" <<\" \"<<"<<k<<"<<endl;\n";
                    }
                }
                if(dex == 0) cout<<"        return 0;\n    }\n";
                dex = 1;
            }
    cout<<"    cout<<\"No!!!\"<<endl;\n}"<<endl;          
    return 0;
}

```

OJ程序：

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a, b, c; cin>>a>>b>>c;
    if(a==1 && b==2 && c==3){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        cout<< 219 <<" "<< 438 <<" "<<657<<endl;
        cout<< 273 <<" "<< 546 <<" "<<819<<endl;
        cout<< 327 <<" "<< 654 <<" "<<981<<endl;
        return 0;
    }
    if(a==1 && b==3 && c==5){
        cout<< 129 <<" "<< 387 <<" "<<645<<endl;
        return 0;
    }
    if(a==2 && b==4 && c==6){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        return 0;
    }
    if(a==3 && b==6 && c==9){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        cout<< 219 <<" "<< 438 <<" "<<657<<endl;
        cout<< 273 <<" "<< 546 <<" "<<819<<endl;
        cout<< 327 <<" "<< 654 <<" "<<981<<endl;
        return 0;
    }
    if(a==3 && b==7 && c==8){
        cout<< 213 <<" "<< 497 <<" "<<568<<endl;
        cout<< 321 <<" "<< 749 <<" "<<856<<endl;
        return 0;
    }
    if(a==4 && b==5 && c==6){
        cout<< 492 <<" "<< 615 <<" "<<738<<endl;
        return 0;
    }
    cout<<"No!!!"<<endl;
}
```

#### 特判+~~最大公约数化简~~

由于本题`b`出的可能较大，所以。。过不了测试点`5`（最后一个是`123 456 789`。。。跪了跪了）。。只能考虑化简有理分式。。。先求`a,b,c`的最大公约数。。。（~~貌似还是有点问题。。~~）

仔细一看，`123 456 789`明显是特例。。看来要额外加进去。。。

最后将OJ程序修改为：

```c++
#include<bits/stdc++.h>
using namespace std;

int gcd(int a, int b){
    if(b == 0) return a;
    return gcd(b, a%b);
}
int gcd(int a, int b, int c){
    return gcd(gcd(a,b), gcd(b,c));
}

int main(){
    int a, b, c; cin>>a>>b>>c;
//	int G = gcd(a, b, c); 
//	if(a % G == 0) a/=G, b/=G, c/=G;
    if(a==1 && b==2 && c==3){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        cout<< 219 <<" "<< 438 <<" "<<657<<endl;
        cout<< 273 <<" "<< 546 <<" "<<819<<endl;
        cout<< 327 <<" "<< 654 <<" "<<981<<endl;
        return 0;
    }
    if(a==1 && b==3 && c==5){
        cout<< 129 <<" "<< 387 <<" "<<645<<endl;
        return 0;
    }
    if(a==2 && b==4 && c==6){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        return 0;
    }
    if(a==3 && b==6 && c==9){
        cout<< 192 <<" "<< 384 <<" "<<576<<endl;
        cout<< 219 <<" "<< 438 <<" "<<657<<endl;
        cout<< 273 <<" "<< 546 <<" "<<819<<endl;
        cout<< 327 <<" "<< 654 <<" "<<981<<endl;
        return 0;
    }
    if(a==3 && b==7 && c==8){
        cout<< 213 <<" "<< 497 <<" "<<568<<endl;
        cout<< 321 <<" "<< 749 <<" "<<856<<endl;
        return 0;
    }
    if(a==4 && b==5 && c==6){
        cout<< 492 <<" "<< 615 <<" "<<738<<endl;
        return 0;
    }
    if(a==123 && b==456 && c==789){
        cout<< 123 <<" "<< 456 <<" "<<789<<endl;
        return 0;
    }
    cout<<"No!!!"<<endl;
}
```

> 没有调用`gcd()`。。。

然后我发现，~~题意就有问题吧啊喂！！！~~调用公约数反而错了？？？？？成比例这个事很邪乎啊啊啊啊啊。难道不应该~~很自然地化简~~吗。。

---

## 作者：lwzheng00000 (赞：38)

也是STL做全排列，但是更加简单粗暴

#### C++ IS BEST!

分析：既然三个数ai,bi,ci比例是a：b：c

那么

ai*b=bi

ai*c=ci

或者是ai==a,bi==b,ci==c

条件有了就可以搜了

放代码


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int b3[10]={0,1,2,3,4,5,6,7,8,9};//打表
int main(){
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	int co=0;
	do{
		int a1=100*b3[1]+10*b3[2]+b3[3];//第一个数
		int b1=100*b3[4]+10*b3[5]+b3[6];//第二个数
		int c1=100*b3[7]+10*b3[8]+b3[9];//第三个数
		if((a1*b==b1&&a1*c==c1)||(a1==a&&b1==b&&c1==c)){//判断
			co++;
			printf("%d %d %d\n",a1,b1,c1);//输出
		}
	}
	while(next_permutation(b3+1,b3+10));
	if(co==0){
		printf("No!!!");
	}
	return 0;
}
```

---

## 作者：心非 (赞：11)

这题一开始拿了60想到可能是出现小数的问题，加上判断条件后80。。。实在想不出什么原因了，下载了测试数据看了一下是c超过三位数了
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int book[10];
void cf(int num){//把每个数拆分统计出现次数
	do{
		book[num%10]++;
		num/=10;
	}while(num);
}

int main(){
	int A,B,C;
	float a,b,c;
	bool flag=false;
	cin>>A>>B>>C;
	for(int i=123;i<=987;i++){
		a=i;
		b=a/A*B;
		c=a/A*C;
		if((int)b!=b||(int)c!=c||c>987) continue;//如果b和c是小数或者c超过987了那就下一个，c>987的话直接break掉也行
		cf(a),cf(b),cf(c);
		if(book[1]==1&&book[2]==1&&book[3]==1&&book[4]==1&&book[5]==1&&
           book[6]==1&&book[7]==1&&book[8]==1&&book[9]==1){//如果每一位都出现一次那就打印
			cout<<a<<" "<<b<<" "<<c<<endl;
			flag=true;//标志
		}
		memset(book,0,sizeof(book));//把数组置0
	}
	if(!flag) cout<<"No!!!";
	return 0;
}

```

---

## 作者：hzg0226 (赞：10)

###枚举每一个可能的数，将三个倍数保存在数组中，再排序，最后通过和标准的“123456789”比较，如果相同，则满足条件。这样用一个常量数组，可以简化计算，不需要过多的思考。所以说常量数组大法真的好~

##因为之前做过三连击的简单版，就有了思维定式，枚举总是从123开始，所以最后一个（数据是123 456 789）总是错。最后一个过不去的同学可以试试从1开始枚举，就会过去了。

```cpp
#include <bits/stdc++.h>
using namespace std;

char standard[]="123456789";
int main()
{
    int a,b,c,flag=1;
    scanf("%d%d%d",&a,&b,&c);
    for(int i=1;i<=329;i++){
        char buf[20];
        //if(a*i>987||b*i>987||c*i>987) break;
        sprintf(buf,"%d%d%d",a*i,b*i,c*i);
        sort(buf,buf+9);
        if(strcmp(standard,buf)==0) {flag=0;printf("%d %d %d\n",a*i,b*i,c*i);}
    }
    if(flag) printf("No!!!\n");
    return 0;
}
```

---

## 作者：codingCoge (赞：9)

我发现个问题：似乎这ＡＢＣ的值都是整数．
那咋没有考虑到有小数的问题，就比如１：２.3:３呢？
但是似乎这道题测试数据中没有小数。不过为了严谨起见，还是得考虑进去，编写程序是ｊａｖａ。
```
import org.omg.Messaging.SYNC_WITH_TRANSPORT;

import java.util.*;

public class Main {
    public static int[] use = new int[10];
    public static void cf(int num){
        while(num!=0){
            if(use[num%10]!=1){
                use[num%10]=1;
            }
            num/=10;
        }
    }
    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        double temp1,temp2;
        int sum,num=0;
        for(int i=123;i<987;i++){
            sum=0;
            temp1=(i*1.0/a)*b;
            temp2=(i*1.0/a)*c;
            if(temp1>987||temp2>987){
                break;
            }
            String d = String.valueOf(temp1);
            String e = String.valueOf(temp2);
            if("0".equals(d.substring(d.indexOf(".")+1,d.length()))||"0".equals(e.substring(e.indexOf(".")+1,e.length()))){
                cf(i);
                cf((int)temp1);
                cf((int)temp2);
                for(int j=1;j<=9;j++){
                    sum+=use[j];
                }
                if(sum==9){
                    num=1;
                    System.out.println(i+" "+(int)temp1+" "+(int)temp2);
                }
                for(int z=1;z<=9;z++){
                    use[z]=0;
                }
            }else{
                break;
            }
        }
        if(num==0){
            System.out.print("No!!!");
        }
    }
}
```

---

## 作者：封禁用户 (赞：8)

这道题我一开始看到就想枚举全部数字，然后再判断，这样当然会超时。于是我就想，既然比例一定，能不能把符合比例的数字都枚举出来，这样就只用判断这个三个数每位不一样，并且第一个数>=123 且第三个数<=987 (题目写了A<B<C)，然后不满足了再跳出来。




```cpp
#include <bits/stdc++.h>
using namespace std;
int A,B,C,a,b,c,flag=1,Num[9],x;
int gcd(int a,int b)     //为了让输入的A B C互质 
{ 
  return a%b?gcd(b,a%b):b;
}
int pd(int a,int b,int c)    //判断a,b,c中的每位数字不同且不等于0 
{
	Num[0]=a/100;
	Num[1]=a%100/10;
	Num[2]=a%10;
	Num[3]=b/100;
	Num[4]=b%100/10;
	Num[5]=b%10;
	Num[6]=c/100;
	Num[7]=c%100/10;
	Num[8]=c%10;
	for(int i=0;i<8;i++)
	{
		if(Num[i]==0)
			return 1;
		for(int j=i+1;j<9;j++)
		{
			if(Num[i]==Num[j])
				return 1;
		}
	}
	return 0;
}
int main()
{
	cin >> A >> B >> C;
	x=gcd(gcd(A,B),gcd(B,C));
	A=A/x;
	B=B/x;
	C=C/x;
	for(int i=0;i<=1000;i++)  //从一开始枚举符合的数 
	{
		a=A*i;
		b=B*i;
		c=C*i;
		if(pd(a,b,c))
			continue;
		if(123<=a && c<=987)  //因为题目中写到 A<B<C 
		{
			printf("%d %d %d\n",a,b,c);
			flag=0;           //当数字过大后就跳出循环 
		}
		else if(flag==0)
		    break;
	}
    if(flag==1)        //如果不符合情况输出No!!!
	{
		printf("No!!!");
	}
	return 0;
}
```

---

## 作者：AdzearDisjudge (赞：7)

恕在下直言，用什么集合什么全排列的都是蒟蒻辣鸡！

来一发剪过枝的暴力穷举吧！！！

时间复杂度为常数O(9!)（362880是不会超时的2333）

（PS：%%%The Red Sun神犇thx!!!）

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int wxx,lmn,zwq;
    bool hz=true;
    cin>>wxx>>lmn>>zwq;
    for(int a=1;a<=9;++a)
    for(int b=1;b<=9;b++)
    if(a!=b)
    for(int c=1;c<=9;++c)
    if((a!=c)&&(b!=c))
    for(int d=1;d<=9;++d)
    if((a!=d)&&(b!=d)&&(c!=d))
    for(int e=1;e<=9;++e)
    if((e!=a)&&(e!=b)&&(e!=c)&&(e!=d))
    for(int f=1;f<=9;++f)
    if((f!=a)&&(f!=b)&&(f!=c)&&(f!=d)&&(f!=e))
    for(int g=1;g<=9;++g)
    if((g!=a)&&(g!=b)&&(g!=c)&&(g!=d)&&(g!=e)&&(g!=f))
    for(int h=1;h<=9;++h)
    if((h!=a)&&(h!=b)&&(h!=c)&&(h!=d)&&(h!=e)&&(h!=f)&&(h!=g))
    for(int i=1;i<=9;++i)
    if((i!=a)&&(i!=b)&&(i!=c)&&(i!=d)&&(i!=e)&&(i!=f)&&(i!=g)&&(i!=h))
    {
        int n1=a*100+b*10+c,n2=d*100+e*10+f,n3=g*100+h*10+i;
        if((n1*lmn==n2*wxx)&&(n1*zwq==n3*wxx)&&(n2*zwq==n3*lmn))
        { 
            printf("%d %d %d\n",n1,n2,n3);
            hz=false;
        }
    }
    if(hz)
    cout<<"No!!!";
    return 0;
}
```

---

## 作者：skymirror (赞：6)

这道题可以用一个bool类型的数组来做


先定义一个bool类型的数组，然后写一个用来判断1~9所有数是否全部出现的函数；


在主函数中先生成三个数，在利用函数和数组来判断所有数是否全部出现，是则输出三个数；


用ans来判断是否有答案，没有则输出“No！！！”


```cpp
#include<iostream>
using namespace std;
bool f[11];                             //创建数组
void doit(int i)                       //一个函数，用来判断三位数各个位置上的数字
f[i%10]=true;
f[i/10%10]=true;
f[i/100%10]=true;                //如果该数字出现就把数组里的那个位置赋为true
}
int main()                                      //主函数
{
double a,b,c,temp,ans=0;
cin>>a>>b>>c;                            //输入
for(int i=100;i<=333;i++)             //开始寻找
{
temp=i;
int m=temp/a*b,n=temp/a*c;          //创建出三个数
bool flag=true;                                //定义一个标志
for(int i=1;i<=9;i++)
f[i]=false;                                     //初始化数组
doit(i);                                             
doit(m);
doit(n);                                            //运用函数进行判断
for(int i=1;i<=9;i++)
{
if(f[i]==false)                                //判断是否所有数都出现了，如果没有则flag=false
flag=false;
}
if(flag)                                             //如果全部出现
{
cout<<i<<" "<<m<<" "<<n<<endl;           //输出三个数
ans++;                                                        //ans++，说明有答案
}
} 
if(ans==0)                                            //如果没有答案
cout<<"No!!!";                                  //输出“No！！！”
return 0;
}
```

---

## 作者：肖长浩还有谁 (赞：4)

** 深搜，题目中一共3个数，我们可以分解成3\*3个数，每3个数 **

** 组成一个三位数 **

** 如123 456 789分解成1 2 3     4 5 6     7 8 9 **

** 最后再把三个数合并成三位数1\*100+2\*10+3\*1=123 **

** 这样我们便可以把3位数转化为1位数 **

** 再合并成三位数，由此再判断，三位数是否成比例关系 **




```cpp
   #include<iostream>
   using namespace std;
   int a[10], b[10] = {0};
   int x,y,z,  bbbb = 0;    // bbbb用于判断是否找到
   void print(){              // 分别输出三位数
       cout<<a[1]*100+a[2]*10+a[3]*1<<" ";
       cout<<a[4]*100+a[5]*10+a[6]*1<<" ";
       cout<<a[7]*100+a[8]*10+a[9]*1<<endl;
       bbbb = 1;                // 判断已经找到三位数
   }
   void search(int k){
       for(int i = 1; i <= 9; i++)
           if(b[i] == 0){             //判断是否重复过
               a[k] = i;
               b[i] = 1;
               if(k == 9&&             // 找完9个数并且三位数成比例
                   (a[1]*100 + a[2]*10 + a[3]*1)*y==
                   (a[4]*100 + a[5]*10 + a[6]*1)*x&&
                   (a[4]*100 + a[5]*10 + a[6]*1)*z==
                   (a[7]*100 + a[8]*10 + a[9]*1)*y&&
                   (a[1]*100 + a[2]*10 + a[3]*1)*z==
                   (a[7]*100 + a[8]*10 + a[9]*1)*x)
                   print();
               else search(k + 1);
               b[i] = 0;
           }
   }
   int main(){
       cin>>x>>y>>z;
       search(1);                 // 深搜
       if(bbbb == 0)
       cout<<"No!!!"<<endl; 
}
```

---

## 作者：yin_sy (赞：3)

深搜，枚举每一种方案。（问号里的自己填）

```cpp
var
  a,b,c,ans:longint;
  d:array [1..9] of longint;
  e:array [1..9] of boolean;
procedure try1;
var
  us1,us2,us3:longint;
begin
  us1:=d[？]*100+d[？]*10+d[？];
  us2:=d[4]*100+d[5]*10+d[6];
  us3:=d[7]*100+d[8]*10+d[9];
  if (us1*b=us2*a) and (us1*c=us3*a) and (us2*c=us3*b) then begin inc(ans); writeln(us1,' ',us2,' ',us3); end;
end;
procedure try(u:longint);
var
  i:longint;
begin
  if u>9 then begin try1; exit; end;
  for i:=1 to 9 do
  if not e[i] then
  begin
```
e[？]:=true;
d[？]:=i;

    try(u+1);

e[？]:=false;

```cpp
  end;
end;
begin
  readln(a,b,c);
  try(1);
  if ans=0 then writeln('No!!!');
end.

```

---

## 作者：01190220csl (赞：2)

S1：对x进行穷举，再求y，z，并判断y，z是否为整数及是否超过1000。

S2：提取组成x，y，z的9个数，并两两比较，如相同或其中一个为0，则舍弃。

S3：若未被舍弃，则直接输出，同时记录有答案。

S4：若无答案，输出“No!!!”；

（其中5格要自己补上）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a , b , c , x , y , z;                     //a，b，c的含义如题目，x，y，z分别为第一、二、三个数
    bool yes = 0;                              //yes记录是否有答案
    double t;                                    //t是中间值，以便判断y和z是否为整数
    cin >> a >> b >> c;
    for( x = 100 ; x < 1000 ; x++ )
    {
-----（1）-----;
        if( t = ( int )t )
            y = ( int )t;
        else
            continue;
        t = ( double )( x ) * c / a;
        if( t >= 1000 )                  //判断y，z是否超过1000（若y>1000，则由于b>c，故z>y>1000）
            break;
        if( t = ( int )t )
            z = ( int )t;
        else
            continue;
        int num[9] = { x / 100 , -----（2）----- , x % 10 , y / 100 , y / 10 % 10 , y % 10 , z / 100 , z / 10 % 10 , z % 10 };//存储提取出的9个数
        bool use = 1;
        for( int i = 0 ; i < 9 ; i++ )
            for( int j = 0 ; j < i ; j++ )
                if( -----（3）----- || num[j] == num[i] )         //这里给补充内容一个提示：在整个计算过程中，z取过的最大值是几？
                    use = 0;
        if( use )
        {
            -----（4）-----;
            cout << x << ' ' << y << ' ' << z << '\n';
        }
    }
    if( -----（5）----- )
        cout << "No!!!";
}
```

---

## 作者：Neil1110 (赞：2)

```cpp

#include<iostream>
using namespace std;
int main()
{
    int a,b,c,x[9],a1,a2,a3;
    cin>>a1>>a2>>a3;    //输入
    int y=0,ans=0,flag[10]={0},i,j;    //用flag统计数字是否用过
    for(j=1;j<=1000/a3;j++)
    {
        y=0;
        for(i=0;i<9;i++)
            flag[i]=0;    //全归0
        a=a1*j;
        b=a2*j;    //按比例赋值
        c=a3*j;    
        if(a>=1000||b>1000||c>1000)
            break;    //超出范围的情况
        x[0]=a/100,x[1]=(a/10)%10,x[2]=a%10;
        x[3]=b/100,x[4]=(b/10)%10,x[5]=b%10;    //放到一个数组里面
        x[6]=c/100,x[7]=(c/10)%10,x[8]=c%10;
        for(i=0;i<9;i++)
            flag[x[i]-1]=1;    //统计用过的数
        for(i=0;i<9;i++)
            y+=flag[i];   //统计用过多少个
        if(y==9)    //如果y=9的话，就代表所有数都用过
        {
            cout<<a<<" "<<b<<" "<<c<<endl;
            ans++;    //有满足的a b c，ans就不等于0
        }
    }
    if(!ans)   //没有满足的，输出No!!!
        cout<<"No!!!";
}

```

---

## 作者：封禁用户 (赞：2)

这题和普通版三连击差不多，只是倍数改了。

首先有一个数学规律：

**这个三个数的每一位之积一定等于9的阶乘**

**且每一位都不相同**


思路：

先枚举a，bc两数用比例乘上去，a最小为123，且**很显然**小于333，然后裂解出每一位，再根据数学规律判断即可。



------------






    
    
        

```cpp
###### #include<cstdio>
using namespace std;
int main(){
    int a,b,c,count = 0;//a,b,c为所给数，count为是否存在的个数
    //以下三行均为a，b，c的每一位
    int a100,a10,a1;
    int b100,b10,b1;
    int c100,c10,c1;
    float x,y,z;//比例
    scanf("%f %f %f",&x,&y,&z);
    //开始迭代
    for(a = 123;a <= 329;a++){
        //裂解a，其实这里的裂解方式是最菜的，不要学我23333
        a100 = a / 100;
        a10 = (a - (a100 * 100)) / 10;
        a1 = (a % 100) % 10;
        //计算b，c
        b = a * (y / x);
        c = a * (z / x);
        //裂解b
        b100 = b / 100;
        b10 = (b - (b100 * 100)) / 10;
        b1 = (b % 100) % 10;;
        //裂解c
        c100 = c / 100;
        c10 = (c - (c100 * 100)) / 10;
        c1 = (c % 100) % 10;
        //按照数学规律判断，简单明了，不过字多了点就是
        if(((a100 * a10 * a1 * b100 * b10 * b * c100 * c10 * c1) == (1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9)) && (a100 != a10) && (a100 != a1) && (a100 != b100) && (a100 != b10) && (a100 != b1) && (a100 != c100) && (a100 != c10) && (a100 != c1) && (a10 != a1) && (a10 != b100) && (a10 != b10) && (a10 != b1) && (a10 != c100) && (a10 != c10) && (a10 != c1) && (a1 != b100) && (a1 != b10) && (a1 != b1) && (a1 != c100) && (a1 != c10) && (a1 != c1) && (b100 != b10) && (b100 != b1) && (b100 != c100) && (b100 != c10) && (b100 != c1) && (b10 != b1) && (b10 != c100) && (b10 != c10) && (b10 != c1) && (b1 != c100) && (b1 != c10) && (b1 != c1) && (c100 != c10) && (c100 != c1) && (c10 != c1) ){
            count++;//存在就自加，不存在则为0
            printf("%d %d %d\n",a,b,c);
        }
    }
    //不存在就输出
    if(count == 0){
        printf("No!!!");
    }
    return 0;
}
```

---

## 作者：sillyf (赞：2)

PASCAL的童鞋请绕道,  这题虽然不是很难， 但为了追求代码简单，还是无耻地调用了C++的函数

```cpp
#include <cstdio>
#include <algorithm>                                                  //为调用之后的函数next_permutation
using namespace std;
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int main(void){
    int x, y, z, q, w, e; bool b = 0;
    scanf("%d %d %d", &x, &y, &z);
    do{
        q = a[1] * 100 + a[2] * 10 + a[3];
        w = a[4] * 100 + a[5] * 10 + a[6];
        e = a[7] * 100 + a[8] * 10 + a[9];
        if (q * y * z == w * x * z  &&  w * x * z == e * x * y  &&  q * y * z == e * x * y)
        printf("%d %d %d\n", q, w, e), b = 1;
    }while (next_permutation(a + 1, a + 10));                   //按字典序排下一种可能，继续判断
    if (b == 0) printf("No!!!");                                           //三个!,三个!,三个!，重要的事情说三遍
    return 0;
}
```

---

## 作者：苏亿 (赞：1)

利用算法库中的全排列函数next\_permutation(a, a + n)对1~9进行排列，可以理解为产生a数组中n个数字的组合。

visit[]用来判断经过排列后，新选取的三个数是否和上一次选取的存在相同，若相同，则进入下一轮。

if语句中判断强制将int表达式转换为double类型，避免int数据经过运算后的“靠0取整”。

本质思想还是暴力，毕竟暴力出奇迹。




```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
bool isSame(int v[], int a[]) {
    for (int i = 0; i != 3; i++)
        if (v[i] != a[i])
            return false;
    return true;
}
int main()
{
    int A, B, C;
    int visit[3] = { 0 };
    int pos;
    bool flag = false;
    cin >> A >> B >> C;
    do {
        int x = a[0] * 100 + a[1] * 10 + a[2];
        int y = a[3] * 100 + a[4] * 10 + a[5];
        int z = a[6] * 100 + a[7] * 10 + a[8];
        int a[3] = { x, y, z };
        sort(a, a + 3);
        if (!isSame(visit, a)) {
            if ((double)y / x == (double)B / A && (double)z / x == (double)C / A && (double)z / y == (double)C / B) {
                cout << a[0] << " " << a[1] << " " << a[2] << endl;
                flag = true;
            }
        }
    } while (next_permutation(a, a + 9));
    if (flag == false)
        cout << "No!!!" << endl;
    return 0;
}
```

---

## 作者：ysner (赞：1)

此题我用的是递归回溯（枚举）。这应该算是道为初学者准备的不错的递归练手题。

设结果为k1,k2,k3,设一个dfs（int x）x表示当前枚举到了第几位，函数里面把这位数的值从1枚举到9，x<=2时枚举出的数字属于k1，x<=5时枚举出的数字属于k2，x<=8时枚举出的数字属于k3.

因为三个数k1:k2:k3=b1:b2:b3（这是我的代码中为输入比例所设的变量），所以k1\*b2=k2\*b1,k3\*b1=k1\*b3，这两个判断条件同时成立即可证得到的三个数符合条件，输出，并且注意在输出后不要把k1,k2,k3全赋为0，递归出的数值最终会回溯为0。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int a1[10]={},k1=0,k2=0,k3=0,b1,b2,b3,f=0;
void dfs(int x)
{
  if(x==9) if(k2*b1==b2*k1&&k3*b1==b3*k1) {cout<<k1<<" "<<k2<<" "<<k3<<endl;f=1;return;}//判断条件
  for(int i=1;i<10;i++)
    if(a1[i]==0)//判断此数是否已枚举过
    {
      if(x<=2) k1=k1*10+i;
      else if(x<=5) k2=k2*10+i;
        else if(x<=8) k3=k3*10+i;//生成k1,k2,k3
      a1[i]=1;//枚举过这个数后记录下来，防止再次枚举
      dfs(x+1);
      if(x<=2) k1=k1/10;
      else if(x<=5) k2=k2/10;
        else if(x<=8) k3=k3/10;//将k1,k2,k3复原
      a1[i]=0;//回溯（状态复原）
    }
}
int main()
{
  int i,j,k,n;
  cin>>b1>>b2>>b3;
  dfs(0);
  if(f==0) cout<<"No!!!"<<endl;
  return 0;
}
```

---

## 作者：时间旅行者lv (赞：1)

题目很简单，只要是做过三连击的并且不是[color=red]打表的[/color]都应该会，我是把第一个数所有位穷举算出第一个数，在按比例赋值，最后再加上三个判断的。

[h2 ][center ]附上我的程序。[/center ][/h2 ]

```cpp
#include<iostream>
using namespace std;
int A,b,c;
void read()
{
    cin>>A>>b>>c;
     return;
}
bool pan1(int x,int y,int z)
{
    int i,s=0;
    while(1!=2)
    {
        if(x!=0)
        {
            s++;
            x=x/10;
        }
        if(y!=0)
        {
            s++;
            y=y/10;
            
        }
        if(z!=0)
        {
            s++;
            z=z/10;
        }
        if(x==0&&y==0&&z==0)
        break;
    }
    if(s==9)
    return true;
    else return false;
}
bool pan(int x,int y,int z)
{
    if(pan1(x,y,z)==true)
    {
    int i,j,a[9];
    a[1]=x%10;
    a[2]=x/10%10;
    a[3]=x/100;//x的所有位 
    a[4]=y%10;
    a[5]=y/10%10;
    a[6]=y/100;//y的所有位 
    a[7]=z%10;
    a[8]=z/10%10;
    a[9]=z/100;//z的所有位 
    for(i=1;i<=8;i++)
    for(j=i+1;j<=9;j++)
    {
        if(a[i]>a[j])
        swap(a[i],a[j]);
    }
    for(i=1;i<=9;i++)
    if(a[i]==a[i+1]||a[i]==0)
    return false;
    return true; 
    }
    else return false;
    
}
bool pan3(int x)
{
    int s=0,i=0;
    s=x/10;
    while(s!=0)
    {
        i++;
        s=s/10;
    }
    if(i!=1)
    return true;
    else return false;
}
int main()
{
    int i,j,k,x,flag=0;
    float y,z;
    read();
    for(i=1;i<=9;i++)
    for(j=1;j<=9;j++)
    for(k=1;k<=9;k++)
    {
        x=i*100+j*10+k;
        y=(x/(A*1.0))*b;
        z=(y/(b*1.0))*c;
        if(pan(x,y,z)==true)
        if((pan3(x)==true)&&(pan3(y)==true)&&(pan3(z)==true))
        {
            cout<<x<<" "<<y<<" "<<z<<endl;
            flag=1;
        }
    }
    if(flag==0)
    cout<<"No!!!";
    return 0;
}
```

---

## 作者：XLwn (赞：1)

简单的dfs,直接升序求全排列，然后判读是否满足题目要求，满足直接输出，就不用考虑排序问题

import java.util.Scanner;

public class Main {

	private static Scanner sc = new Scanner(System.in);
	static int[] vis = new int[10];
	static int[] a = new int[9];
	static int count = 0;
	static int a1, a2, a3;

	public static void main(String[] args) {
		a1 = sc.nextInt();
		a2 = sc.nextInt();
		a3 = sc.nextInt();
		dfs(0);
		// 判断是否有解
		if (count == 0) {
			System.out.println("No!!!");
		}
	}

	public static void dfs(int pos) {
		if (pos == 9) {
			//判断是否满足要求
			if ((double) (a[0] * 100 + a[1] * 10 + a[2]) / a1 * a2 == a[3] * 100 + a[4] * 10 + a[5]
					&& (double) (a[0] * 100 + a[1] * 10 + a[2]) / a1 * a3 == a[6] * 100 + a[7] * 10 + a[8]) 	
			{
				//记录解的个数
				count++;
				for (int i = 0; i < a.length; i++) {
					System.out.print(a[i]);
					//根据题目要求输出
					if ((i + 1) % 3 == 0) {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}

		for (int i = 1; i <= 9; i++) {
			if (vis[i] == 0) {
				a[pos] = i;
				vis[i] = 1;
				dfs(pos + 1);
				vis[i] = 0;
			}
		}
	}
}



---

## 作者：kZime (赞：0)

我做本题的做法是枚举基数k， 然后题面上给点3个3位数分别为$a k, bk, ck$, 这样的复杂度就只有大概O(1000)左右，

然后就是进行简单的优化了。

而如果你还要像之前三连击未强化版那样枚举9个数的O(1000000000)的做法自然会T掉，


```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, c;
bool fn[10], flag;

inline bool judge(int x, int y, int z) {
    if (x / 100 == 0) return 0;   // 小优化， 因为z > y > x， 当x位10位数， 一定不合法
    memset(fn, 1, sizeof(fn));  // 初始化9个数都还没有被选
    fn[0] = 0; 
    while (x)
        if (fn[x % 10]) fn[x % 10] = 0, x /= 10;
        else return 0;
    while (y)
        if (fn[y % 10]) fn[y % 10] = 0, y /= 10;
        else return 0;
    while (z)
        if (fn[z % 10]) fn[z % 10] = 0, z /= 10;
        else return 0;
    return 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> a >> b >> c;
    for (int i = 1; i <= 999; i++) {
        if (judge(i * a, i * b, i * c)) {
            flag = 1;
            printf("%d %d %d\n", i * a, i * b, i * c);
        }
    }
    if (!flag) {
        printf("No!!!\n");
    }
}

```

---


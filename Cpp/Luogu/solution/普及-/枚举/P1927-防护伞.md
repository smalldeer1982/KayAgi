# 防护伞

## 题目描述

据说 $2012$ 的灾难和太阳黑子的爆发有关。于是地球防卫小队决定制造一个特殊防护伞，挡住太阳黑子爆发的区域，减少其对地球的影响。由于太阳相对于地球来说实在是太大了，我们可以把太阳表面看作一个平面，中心定为 $(0,0)$。根据情报，在 $2012$ 年时，太阳表面上会产生 $N$ 个黑子区域，每个黑子视为一个点。特殊防护伞可以看作一个巨大的圆面，现在地球防卫小队决定将它的中心定位于某个黑子，然后用伞面挡住其他黑子。因为制造防护伞的材料成本特别高，所以我们希望伞面尽可能的小。

## 说明/提示

### 数据范围及约定

- 对于 $50\%$ 的数据：$2 \le N \le 100$。
- 对于 $100\%$ 的数据：$2 \le N \le 1000$，$-10000\le x,y\le 10000$。

### 注意

- 精确到小数点后 $4$ 位。
- $\pi$ 取 $3.1415926535$。

## 样例 #1

### 输入

```
3
0  1 
-8  -4 
-1  4 
```

### 输出

```
279.6017```

# 题解

## 作者：梧桐灯 (赞：18)

看大家写的都挺烦。

其实全程只用int型就可以搞定，double只用在输出时转换一下。

因为啊，在计算距离时要用sqrt，而算圆面积时要平方，

这样，两个就抵消了。

思路：就是枚举每个太阳黑子为圆心，再贪心。。






```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
double PI=3.1415926535;
struct stu{
    int x;
    int y;
}s[1005];
int ans=(1<<30),n; //ans表示最小的半径平方（平方可以省去用double的麻烦）
inline int dis(int a,int b,int c,int d){
    return (a-c)*(a-c)+(b-d)*(b-d); //算距离，省去sqrt
}
int main(){
    scanf("%d",&n);
    int i,j;
    for(i=1;i<=n;i++)
        scanf("%d %d",&s[i].x,&s[i].y);
    for(i=1;i<=n;i++){
        int now=0;
        for(j=1;j<=n;j++){
            if(i==j)
                continue;
            else
                now=max(now,dis(s[i].x,s[i].y,s[j].x,s[j].y)); //更新最大的距离平方
        }
        ans=min(ans,now); //更新最小的ans
    }
    printf("%.4lf",(double)ans*PI); //圆面积，因为ans就是r^2，故省去平方
    return 0;
}

```

---

## 作者：PTC06 (赞：12)

很简单的枚举。

思路：

输入N，以及N个坐标。

首先，可以把题目简单化为：输入几个点，用一个圆覆盖所有的点。

那么，很显然，用一个点作为圆心时，需要用(它)和(离它最远的点)的距离作为


圆的半径，才能覆盖所有的点。

在这里，距离可以用勾股定理来求。像这样：

```cpp
abian=abs(x[j]-x[i]);
bbian=abs(y[j]-y[i]);
ddistancetem=abian*abian+bbian*bbian;
ddistance=sqrt(ddistancetem);
```
这样双重循环，i枚举每一个点，j枚举这个点到其他所有点的距离。对于i这个点

，要找出离他最长的距离作为圆的半径。求出当i作为圆心时，圆的面积是多少。


然后找出哪个点作为圆心时圆的面积最小。

最后输出就好了。

程序：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<algorithm>
#include<fstream>
using namespace std;
double ans,dmax,ddistancetem,ddistance,rarea;
int n,i,j,x[1000],y[1000],normx,normy,abian,bbian;
int main()
{
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
    }
    for (i=1;i<=n;i++)
    {
        normx=x[i];
        normy=y[i];
        dmax=0;
        for (j=1;j<=n;j++)
        {
            abian=abs(x[j]-x[i]);
            bbian=abs(y[j]-y[i]);
            ddistancetem=abian*abian+bbian*bbian;
            ddistance=sqrt(ddistancetem);
            if (ddistance>dmax) dmax=ddistance;
        }
        rarea=3.1415926535*dmax*dmax;
        if (rarea<ans || i==1) ans=rarea;
    }
    printf("%.4f",ans);
}
```

---

## 作者：Blue_Sky (赞：5)

```cpp
#include<algorithm>
#include<iostream>
#include<stdio.h>
#include<math.h>
using namespace std;
int n,i,j,x[10000],y[10000];
double sum,ans=1000000,s; //提前把答案设成大数  因为初值是0 用min函数会出问题 
int main()
{
    cin>>n;
    for (i=1; i<=n; i++) cin>>x[i]>>y[i];//输入 x[i]代表列 y[i]代表行 
    for (i=1; i<=n; i++)
    {
        sum=0; //清零 
        for (j=1; j<=n; j++)
        if (i!=j)  
        {
            s=sqrt(abs(x[i]-x[j])*abs(x[i]-x[j])+abs(y[i]-y[j])*abs(y[i]-y[j]));
            //根据勾股定理 c*c=a*a+b*b; 枚举每个黑子距离其他黑子的距离，用x[i]-x[j]和y[i]-y[j]求出直角边a和b 
            sum=max(sum,s);//每次找到距离最远的作为半径 
        }
        ans=min(ans,sum);//使半径尽量小 
    }
    printf("%.4f",ans*ans*3.1415926535);//printf("%.4f"); 4表示输出的数要保留小数的位数 
}
```

---

## 作者：iorit (赞：2)

[原题](https://www.luogu.com.cn/problem/P1927)

直接暴力枚举每一个点

最后求面积最小值就好了

### 代码

```cpp
// 此处应有头文件
const double pi = 3.1415926535;
int n;
double ans = 1 << 30; // 2 ^ 30
struct node
{
	int x,y;
}s[1005];
double dis(int i , int j) // 勾股定理
{
	double a = abs(s[i].x - s[j].x);
	double b = abs(s[i].y - s[j].y);
	return sqrt(a * a + b * b);
}
int main()
{
    cin >> n;
    for(int i = 1;i <= n;i++)
    	cin >> s[i].x >> s[i].y;
    for(int i = 1;i <= n;i++)
    {
    	double k = 0;
    	for(int j = 1;j <= n;j++)
    		k = max(dis(i , j) , k);
		ans = min(k * k * pi , ans);
	}
	printf("%.4lf\n" , ans); // 保留四位小数
    return 0;
}
```


---

## 作者：Enzymii (赞：2)

看数据范围想算法-->N<=100-->O(N^2)

所以就非常的简单了。。

我们只要枚举每个点作为圆心，枚举该点与其他点的距离，然后找最大距离的最小值作半径即可。

用到的公式：

1. dis(p1,p2)=sqrt((p1.x-p2.x)^2-(p1.y-p2.y)^2) (两点之间距离公式)

2. S=π\*r^2 (圆面积公式)

然后这个题卡精度。。不要用什么acos(-1)...要**老老实实地用题目里的3.1415926535**……

代码:

```cpp
#include <cstdio>
#include <cmath>
struct zb{int x,y;}p[1010];
double dis(const zb &a,const zb &b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
template <class T>
inline T max(const T &a,const T &b){
    if(a>b) return a; return b;
}
const double pi=3.1415926535;
int main(){
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
    double minr=1e9;
    for(int i=1;i<=n;i++){
        double mdis=0;
        for(int j=1;j<=n;j++)
            mdis=max(mdis,dis(p[i],p[j]));
        if(mdis<minr) minr=mdis;
    }
    printf("%.4lf",pi*minr*minr);
} 
```

---

## 作者：七夜 (赞：2)

首先声明两点：

一、也是最重要的，不准抄袭

二、就是对题意的理解，千万不要像我一样把题意读错，他是以黑点为中心，并不是以0,0，这点很重要，我第一次就是这么错的

还有一点可以省略，就是那个求距离的时候开方嫌括号碍眼，麻烦，就直接忽略，因为后面还要平方，抵消了

剩下的问题就很简单了，直接上代码（附带注释）：

```
#include<bits/stdc++.h>//偷懒专用头文件 
#define ll long long
#define INF 1010
#define MAXN 99999//宏定义，表示这是缺省源 QWQ 
using namespace std;
inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}//快读，可以提供借鉴 
double n,a[INF],b[INF],aa,bb,d,t;//不嫌麻烦的我，全都设置成了double类型 
double rr,ans=999999999;//ans要设置成很大的数，好进行取min操作 
int main()
{
	n=read();//读入组数 
	for(int i=1;i<=n;++i)
	 {
	 	a[i]=read();
	 	b[i]=read();
	 }//读入坐标 
	for(int i=1;i<=n;++i)
	 {
	 	t=0;//更新为零 
	 	for(int j=1;j<=n;++j)//遍历每一个点 
	 	 {
	 	 	aa=abs(a[i]-a[j]);
	 	 	bb=abs(b[i]-b[j]);//其实这两个完全不需要取abs，因为后面还要在平方，但是习惯这么打 
	 	 	d=aa*aa+bb*bb;//取半径 
	 	 	if(d>t)
	 	 	 t=d;//找最长半径 ，也不需要开方，因为侯庙还要在平方，抵消掉了了 
		 }
		rr=3.1415926535*t;//求出面积 
		ans=min(ans,rr);//在面积中取最小的 
	 }
	printf("%.4lf",ans);//注意保留四位小数 
	return 0;//结束喽 
}
```


---

## 作者：ShineEternal (赞：1)

[link](https://blog.csdn.net/kkkksc03/article/details/104023339)

## solution：

这道题其实以每个点为圆心遍历，找到和它距离最大的就行。

要注意：

- 不要把外层循环的min写成max，详见注释

- 两个点互相覆盖不同，详见注释

```
#include<cstdio>
#include<algorithm>
using namespace std;
struct ben
{
	int x,y;
}a[1005];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	int ans=2147483640;
	for(int i=1;i<=n;i++)
	{
		int r=0;
		for(int j=1;j<=n;j++)//两个数互相包含是不同的！！！1不要写成i+1
		{
            if(i==j)continue;
			r=max(r,(a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));
		}
		ans=min(ans,r);//因为在上面取到的r就已经包含了所有的黑子，所以这里是min！！！ 
	}
	printf("%.4lf\n",(double)ans*3.1415926535);
	return 0;
}
```

---

## 作者：Stuch (赞：1)

这是本蒟蒻的第一篇题解，如有不妥多多见谅。

其实这道题是简单的枚举。直接以某一黑子为原点。因此只要枚举每一个黑子，求出离它最远的黑子的距离，公式:![](file:///C:/Users/Administrator/Pictures/%E6%8D%95%E8%8E%B7.PNG),

再用圆面积的公式求面积,最后用min()筛出最小值。

代码如下：
```cpp
#include<bits/stdc++.h>//万能头文件，你值得拥有
using namespace std;
const double pi=3.1415926535;//使用常量防止误修改
struct str{
	int x,y;//横,纵坐标
};
str pos[10001];
double qjl(str a,str b)
{
	return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));
}//求黑子间的距离公式,用函数打包更简洁
int main()
{
	int n;
	double minn=1000000000;
	cin>>n;
	for(int i=1;i<=n;i++)
   {
      cin>>pos[i].x>>pos[i].y;
   }
	for(int i=1;i<=n;i++)
	{
		double maxx=-1;
		for(int j=1;j<=n;j++)
		{
			if(j==i)
        {
           continue;
        }
			double b=qjl(pos[i],pos[j]);
			maxx=max(b,maxx);//c++库里有取最大值和最小值的函数
		}
		minn=min(maxx*maxx*pi,minn);
	}
	cout<<setprecision(4)<<fixed<<minn;
	return 0;
}//完美输出
```


---

## 作者：Sh1no (赞：1)

这道题可以列举每个黑子，计算其他黑子与他的最大距离，再算最大距离中最小的那个，就是最后的半径。然后计算圆的面积就可以了

求黑子i到黑子j的代码：

xj=x[i]-x[j];

yj=y[i]-y[j];

xyj=sqrt(xj\*xj+yj\*yj);


---

## 作者：Veibae (赞：0)

蒟蒻的第一篇题解 一定要过啊aaa

#### 简单枚举

先枚举每一个点
找到它到其他点的最大值 也就是以这个点为中心伞的半径

在找到这些半径的最小值 就能是伞最小

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const double pe=3.1415926535;

struct niema{
	
	double x,y;
	
}a[1050];

int n;
double r=0,ans=1e15*0.1;
//k与r都为半径 

int main()
{
	scanf("%d",&n);
	
	for(int i=0;i<n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y);
	
	
	for(int i=0;i<n;i++)//枚举每一个点 
	{
		double ax,ay,k;
		
		for(int j=0;j<n;j++)
		{
			ax=abs(a[i].x-a[j].x);
			ay=abs(a[i].y-a[j].y);
			
			k=sqrt(ax*ax+ay*ay);//求出它其他点的距离 
					
			if(k>r) //要覆盖所有的点 
			{
				r=k;
			} 
		}

		if(r<ans) ans=r; //使伞面最小 
		r=0;
	}
		
	printf("%0.4lf",ans*ans*pe);
	
	return 0;
}
```


---

## 作者：檀黎斗·神 (赞：0)

因为数据很小

所以我们可以直接枚举每个点

假设每个点都是圆心

然后去计算与每个点的距离

把每个点为圆心的最大值（因为要覆盖整个区域）作为一个序列

求出这个序列中的最小值就是半径了

如果这样没有理解的话可以看下代码

但是这道题真的不难最好自己先写一下


···cpp

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
#define ll long long
using namespace std;
const double Pi=3.1415926535;  //初始化π的值 
int n;
double sum;
struct node{
    ll x,y;
}p[1005]; //这个结构体可以存每个点的坐标 
ll sqr(ll x)
{
    return x*x;
}  //单纯的想把代码写的简单些 
int main()
{
    freopen("prevent.in","r",stdin);
    freopen("prevent.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%I64d%I64d",&p[i].x,&p[i].y);  
    //这个输入输出有毒，洛谷应该要写lld但是本地评测要用I64d
    //如果不放心可以用cin（也不会超时），不改是为了防止无脑抄 
    ll ans=0x7fffffff;  //最小值的初始化 
    for(int i=1;i<=n;i++)
    {
        ll d=0;
        for (int j=1;j<=n;j++)
        d=max(d,sqr(p[i].x-p[j].x)+sqr(p[i].y-p[j].y));//找到这个点需要覆盖整个区域的最大值 
        ans=min(ans,d);//找到需要覆盖的话最小的距离 
    }
    double r=sqrt(double(ans)); //这个开方应该是没有必要的，因为最后还是要r的乘方 
    printf("%.4lf\n",Pi*r*r);
    return 0;
}
···
```

---

## 作者：guobaipeng0 (赞：0)

一道简单的枚举题。

题意分析：简单的说，就是给出n个太阳黑子，以及它的坐标xx[i],yy[i]，以某一颗黑子的坐标为圆心，建一个圆形


防护伞，使圆形的面积最小。

思路：用枚举法，时间复杂度O（1000\*1000=1000000），一般30000000~50000000的循环次数不超时。每个黑子都尝试


作为圆心，推出建成的防护伞半径是多少，也可以说是求出离圆心最远的黑子的距离，用勾股定理a\*a+b\*b=c\*c，再找


出最小半径即可：




```cpp
 for (i=1; i<=n; i++)  //第i颗黑子作为圆心
    {
        maxi=0;  //最远距离初始值为0
         for (j=1; j<=n; j++)  //一颗一颗黑子进行枚举（查找），找出最远的黑子距离，就是以第i颗黑子，为
```
圆心的防护伞半径
maxi=max(maxi,sqrt(abs(xx[j]-xx[i])\*abs(xx[j]-xx[i])+abs(yy[j]-yy[i])\*abs(yy[j]-yy[i])));  //


勾股定理，行数差与列数差作为三角形的直角边，找斜边，就是距离（图片参考：




http://i1.piimg.com/567571/886411f0488b1ff2.png）

         mini=min(mini,maxi); //寻找每一颗黑子，为圆心的防护伞半径的最小值。

    }
代码如下：

```cpp
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstdio>
using namespace std;
long long n,i,j,xx[1005],yy[1005];
double mini,maxi;
int main()
{
    cin>>n;
    minx=miny=99999999;
    maxx=maxy=-99999999;
    for (i=1; i<=n; i++)
    {
        cin>>xx[i]>>yy[i];
    }
    mini=9999999;
    for (i=1; i<=n; i++)
    {
        maxi=0;
         for (j=1; j<=n; j++)
         maxi=max(maxi,sqrt(abs(xx[j]-xx[i])*abs(xx[j]-xx[i])+abs(yy[j]-yy[i])*abs(yy[j]-yy[i])));
         mini=min(mini,maxi);
    }
    printf("%.4f",3.1415926535*mini*mini);
    return 0;
}
```

---

## 作者：好记一点的 (赞：0)

水题
只不过被cout 的精度卡了很久2333

枚举每个黑子之间的距离，在最大中求最小

```cpp

#include<iostream>
#include<math.h>
#include<vector>
#include<iomanip>
#define ff long long 
using namespace std;
ff i,j,k,l,m,n,x1,y11,sma,r,mmm;
double aaa;
int main()
{
    vector<int> x;
    vector<int> y;
    vector<int> a;
    vector<int> sum;
    std::ios::sync_with_stdio(false);
    cout.setf(ios::showpoint); 
    cout.precision(4);
    cout.setf(ios::fixed);
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>l>>r;
        x.push_back(l);
        y.push_back(r);
    }
    mmm=100000000000ll;
    for (i=0;i<=n-1;i++)
    {
        sma=0;
        for (j=0;j<=n-1;j++)
        {
            if (i!=j)
            {
                x1=x[i]-x[j];
                y11=y[i]-y[j];
                m=x1*x1+y11*y11;
                if (m>sma) sma=m;
            }
        }
        if (sma<mmm) mmm=sma;
    }
    aaa=(double)mmm;
    aaa*=3.1415926535;
    cout<<aaa<<endl;
    return 0;
}

```

---

## 作者：Genius (赞：0)

```delphi


program L_1927;
var
n,i,ans,max,t,j:longint;
x,y:array[0..1000]of integer;


function hyp(a,b:integer):longint;  //计算两点间距离的平方

begin
exit(sqr(x[a]-x[b])+sqr(y[a]-y[b]));
end;



begin
readln(n);
for i:=1 to n do read(x[i],y[i]);
ans:=maxlongint;

for i:=1 to n do  begin   //枚举每一个黑子
max:=0;
for j:=1 to n do begin   
t:=hyp(i,j);
//if t>ans then exit;  //这是一个未实现的剪枝，当当前点对距离小于最小距离时直接退出。但是我很惊喜的发现数据太弱了。
if t>max then max:=t;
end;

if max<ans then ans:=max;
end;

writeln(ans*3.1415926535:0:4);  // 注意，这边pascal不能用常量pi，精度太高高高高高！！！【这真的不是一个好理由！】
end.



```

---

## 作者：JustinRochester (赞：0)

**【吐槽】**
---

我的天，这题是真的卡精度，我用$acos(-1)$直接爆$0$......

---

**【分析】**
--


我们这样考虑这一题，由题目意思，则是给定坐标轴中$n$个点，求以一个点为圆心，覆盖所有点的最小圆的面积

那么，题目中说了，输入全部都是整数，那么，我们用$int$型读入后只要不开根号就可以直接用$int$型存了

那为什么可以不用开根号呢？

由圆的面积公式得

$S= \pi r^2$

三角形的勾股定理得

$c^2=a^2+b^2$

所以，对于坐标轴上的两点$(x_1,y_1),(x_2,y_2)$

其构成的圆的面积为

$S= \pi [(x_1-x_2)^2+(y_1-y_2)^2]$

因此，我们对于所有可能的边长，用$int$型维护其两端点的距离平方$l$，输出的时候直接输出$\pi l_{min}$即可

对于以第$i$个点为圆心的圆，假设第$i$个点与前$(i-1)$个点构成的最大边长平方记为$l_i$

那么，插入第$(i+1)$个点时，分别计算它与前$i$个点的最大边长平方$d$，如果$d>l_i$，那么更新$l_i=d$，如果$d>l_{i+1}$，那么更新$l_{i+1}=d$

这样，我们就在读入的时候顺便$O(n^2)$预处理完了以第$i$个点为圆心的最大距离平方

那么，最后只要$O(n)$确定$l_{min}$即可输出答案

---

**【代码】**
--

本蒟蒻极丑无比的代码奉上

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
inline int read(){
	register int ans=0;register char c=getchar();register bool neg=0;
	while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
	while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+c-'0',c=getchar();
	return neg?-ans:ans;
}//习惯性的读入优化
int main(){
	int n=read();
	int x[1000],y[1000],l[1000]={0};
	x[0]=read(); y[0]=read();
	for(int i=1;i<n;i++){
		x[i]=read(); y[i]=read();
		for(int j=0;j<i;j++){
			int d=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]);
			if(d>l[j]) l[j]=d;
			if(d>l[i]) l[i]=d;
		}
	}
	int r2=0x3f3f3f3f;
	for(int i=0;i<n;i++) if(l[i]<r2) r2=l[i];
	printf("%.4lf",(double)3.1415926535*r2);
	return 0;
}
```

---


# [NOIP 2014 普及组] 珠心算测验

## 题目背景

NOIP2014 普及 T1

## 题目描述

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。


某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？


最近老师出了一些测验题，请你帮忙求出答案。


## 说明/提示

【样例说明】


由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  

注意，加数和被加数必须是集合中的两个不同的数。


【数据说明】


对于 $100\%$ 的数据，$3 \leq n \leq 100$，测验题给出的正整数大小不超过 $10,000$。


## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
2```

# 题解

## 作者：OIerWu_829 (赞：24)

[题目传送门](https://www.luogu.com.cn/problem/P2141)

抢个题解求通过！

---

因为要求 $a$ 数组中有多少个 $a_i+a_j=a_k$ 这样的数，而 $n\le 100$，我们可以在输入的时候把 $a$ 数组的每个元素用 $f$ 数组标记为 `true`，然后双重循环遍历 $a_i$ 和 $a_j$，如果元素 $a_i+a_j$ 被标记过，那么说明 $a$ 中存在 $a_k=a_i+a_j$，答案加 $1$ 并把这个标记取消，以防重复遍历到。最后输出答案。

```cpp
#include <iostream>
using namespace std;

const int N = 105, M = 2e4 + 5;

int a[N];
bool f[M];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        f[a[i]] = true;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            if (f[a[i] + a[j]])
            {
                ans++;
                f[a[i] + a[j]] = false;
            }
    cout << ans;
    return 0;
}
```

---

## 作者：heidoudou (赞：14)

这题我一开始以为是 两个数之和等于另两个数之和（不仔细看题），把问题想复杂了。

才三个数而已。用 `set`或者桶排，无非就是为了遍历两个元素的组合，快速判断这两个元素的和是否存在。如果存在，还只能记一次。

最好也要用 $O(N^2)$ 的复杂度。

换个角度：先定位第三个元素， 然后找有没有两数之和等于这个数的。不需要多余的数组、集合。

```cpp

int a[101];

int main()
{
    int n, i;
    cin >> n;
    for (i = 0; i < n; i++)
        cin >> a[i];

    sort(a, a + n);

    int count = 0;
    int l, r;
    for (i = n - 1; i >= 2; --i)
    {
        l = 0, r = i - 1;
        while (l < r)
        {
            if (a[l] + a[r] < a[i])
                ++l;
            else if (a[l] + a[r] > a[i])
                --r;
            else
            {
                count++;
                break;
            }
        }
    }
    cout << count;
}
```


---

## 作者：ikunTLE (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P2141)

### 思路

用 $F_i$ 代表 $i$ 是否在输入序列 $A$ 中。

首先标记 $A$ 中所有的数字，即 $F_{A_i}\gets1$，代表 $A_i$ 出现。

然后两层循环 $i$ 和 $j$ 遍历整个序列 $A$。若 $F_{A_i+A_j}=1$，说明 $A_i+A_j$ 这个数是可以被另外两个数相加得到的，增加答案个数，并更新 $F_{A_i+A_j}$ 为 $0$。

最后输出答案个数即可。

**注意事项**

- 访问数组 $F$ 的最大值 $A_i+A_j$ 为 $2\times10^4$，注意数组大小。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e2+10,M=2e4+10;
int a[N];
bool flag[M];
int main(){
	int n=read();
	for(int i=1;i<=n;++i){
		a[i]=read();
		flag[a[i]]=true;
	}
	int cnt=0;
	for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j)
			if(flag[a[i]+a[j]])
				++cnt,flag[a[i]+a[j]]=false;
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：ryf2011 (赞：5)

# 题目思路
直接暴力枚举即可。但需要注意一些问题。

- 两个相加的数的位置必须不同。
- 两个相加的数都与原数的位置不同。

明确了这些问题后，我们就可以写出代码了。具体思路见代码。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[105],ans;
bool f;
int main(){
	//输入 
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]); 
	}
	//枚举 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				f=false;
				if(i==j||j==k||i==k){ //如果位置相同，则跳过 
					continue;
				}
				if(a[j]+a[k]==a[i]){ //如果可行，答案个数 +1，随后直接退出循环 
					ans++;
					f=true;
					break;
				}
			}
			if(f==true){
				break;
			}
		}
	}
	printf("%d\n",ans); //输出答案 
	return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：liruizhou_lihui (赞：4)

这题面都提到集合了怎么就没人用`set`捏。

## 思路分析

在`STL`里有个东西叫`set`，可以实现排序和去重的功能。

但是这题能用`set`的原因是`set`有一个`find`函数可以判断一个值是否在集合存在。

就可以把每个元素存进`set`再依次判断两个元素之和是否存在即可。

[集合容器的其他用法。](https://blog.csdn.net/changjiale110/article/details/79108447)
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int f[20005];
set<int> s;
int a[105]; 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		s.insert(a[i]);
	}
	for(int i=1;i<n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(s.find(a[i]+a[j])!=s.end() &&f[a[i]+a[j]]==0)
			{
				f[a[i]+a[j]]=1;
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：GSQ0829 (赞：4)

#### [题目传送门](https://www.luogu.com.cn/problem/P2141)
---

### 思路
我们知道，这题就是要算有多少个数，满足恰好等于集合中另外两个不同的数之和。

那么还好，数据范围不大，所以我们要分为几点来做。

1. 标记加和。要用一个数据量比较大的桶，来标记这组数以内，任意两个数的和。
2. 然后去判断这个数是不是恰好等于集合中另外两个不同的数之和，如果是，计数器就加一。

---
### code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1001], n, ans = 0;
bool b[100001];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
    // 点一对应的代码
	for (int i = 1; i <= n - 1; i++) {
		for (int j = i + 1; j <= n; j++) b[a[i] + a[j]] = true;
	}
    // 点二对应的代码 
	for (int i = 1; i <= n; i++) {
		if (b[a[i]]) ans++;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：dear_deer_land (赞：3)

## 思路
本题要求给定集合中两数相加等于集合中另一个数的组数。我们可以将集合中的每一个数的数值在 bool 数组中进行标记，代表这个值出现过。然后 $n^2$ 复杂度遍历每一对数，并把他们的和存入 bool 数组中。最后遍历一遍两倍的值域（因为两数相加最大值是两数之和也就是二倍值域），判断每一个和的值有没有出现在集合中，如果出现，那么满足条件的数对数就加一。
## 代码
```
#include <bits/stdc++.h>
#define ll long long
#define bug puts("!!!====!!!=");
using namespace std;
int n,a[110],ans,maxx;
bool b[20010],c[20010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[a[i]]=1;//标记集合中的数 
	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			c[a[i]+a[j]]=1;//标记每一个和 
			maxx=max(maxx,a[i]+a[j]);//记录两数加和最大值 
		}
	}
	for(int i=1;i<=maxx;i++){//遍历求答案 
		if(b[i]&&c[i]){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：OIerZhang (赞：3)

# [P2141 [NOIP2014 普及组] 珠心算测验](https://www.luogu.com.cn/problem/P2141)

## 思路

看大佬们都用枚举法，还要判断和是否算过，这里我给出一个桶的思想。

当我们仔细看题，会发现给出的正整数大小不超过 $10^4$，不仅加起来也才 $2 \times 10^4$，而且不用考虑负数，用桶就可以轻松解决。

第一个桶 $t_1$ 存储每个数是否出现，第一个桶 $t_2$ 存储每两个数的和是否出现，循环判断 $t_{1,i}$ 和 $t_{2,i}$ 是否均不为 $0$ 即可。因为是用桶，也规避了重复的情况。

## 核心代码

注意 $t_1$ 和 $t_2$ 都要开到 $2 \times 10^4$。

```cpp
for (i = 1; i <= n; i++)
    t1[a[i]] = 1;
for (i = 1; i < n; i++)
    for (j = i + 1; j <= n; j++)
        t2[a[i] + a[j]] = 1;
for (i = 1; i <= 20000; i++)
    if (t1[i] && t2[i])
        cnt++;
```

---

## 作者：hwc2011 (赞：2)

用 $O(N^2)$ 的做法，把每两个数的和的出现次数记起来，最后再查找 $N$ 个数中有几个数出现了就行。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[106],f[20006],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		for(int j=1;j<i;j++) f[a[i]+a[j]]=1;
	}
	for(int i=1;i<=n;i++) ans+=(f[a[i]]==1);
	cout<<ans;
}
```

---

## 作者：niuniudundun (赞：2)

[原题。](https://www.luogu.com.cn/problem/P2141)

# 题目大意

有 $n$ 个数的集合，其中有多少个数，恰好等于集合中另外两个（不同的）数之和。

# 解法

## $O(n^3)$ 做法。

枚举每个数是否能拆成集合中另外两个（不同的）数之和。

对于 $n\le 100$ 完全够用。

**注意，是不同的数，不能判断下标，应该判断两个数。**

代码：

```cpp
#include<iostream>
using  namespace std;
const int maxmapn=100001,maxn=101;
int a[maxn];
int n;
int ans=0;
bool check(int m){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(m==a[i]+a[j]&&i!=j&&a[i]!=a[j]){
				return true;
			}
		}
	}
	return false;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		if(check(a[i])){
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

## $O(n^2)$ 做法

考虑桶排序优化。

使用桶来计算形如 $a_i+a_j=a_k$ 的个数，枚举 $a_i,a_j$，若 $a_k$ 在桶中出现过，则 $ans$ 加一，删除这个标记，防止重复计算。

## $O(n \log n)$ 做法

考虑二分。

定义 $l,r$。若 $a_l+a_r>a_i$，$l\gets l+1$；若 $a_l+a_r<a_i$，$r\gets r-1$；若 $a_l+a_r=a_i$，说明有解，计数器加一。万一 $l>r$ 就是无解。

$O(n\log n)\le$ 复杂度 $\le O(n^2)$。

---

## 作者：__galaxy_1202__ (赞：2)

## 解题思路：
直接三重循环暴力枚举即可。我的方法为，枚举第一个数，和第二个数，再枚举第三个数并判断是否等于它们之和，注意不能重复计算。

## CODE：

```cpp
#include <iostream>
using namespace std;
int n, cnt, a[101], flag[101];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++)
	{
		for (int j = i + 1; j <= n; j++)
		{
			for (int k = 1; k <= n; k++)
			{
				if (i != j && a[i] + a[j] == a[k] && !(flag[k]))
				{
					cnt++;
					flag[k] = 1;
				}
			}
		}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：WsW_ (赞：2)

### 更新
- $2024.12.30$ 时间复杂度手误写错了，已更正。

---
### 思路
问题为：有多少个 $k$ 满足 $a_i+a_j=a_k$ 且 $i,j,k$ 互不相同。  
由于 $n$ 的范围较小，我们可以枚举暴力枚举 $k,i,j$，并统计满足条件的 $k$ 的个数。  
由于 $a_i$ 均为正整数，即 $a_i>0$。所以当 $i=k$ 时，$a_i+a_j=a_k+a_j>a_k$。也就是说，我们并不需要特判 $i\neq k$ 和 $j\neq k$。

时间复杂度为 $O(n^3)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[102];
int main(){
	int n,sum=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	for(int k=1;k<=n;k++){
		int f=0;//记录这个 k 是否满足条件
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(i==j)continue;
				if(s[i]+s[j]==s[k])f=1;
			}
		}
		if(f==1)sum++;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：Eason0324 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2141)

## 思路
我现在都看不懂当时在做啥了。

好像是 **暴力枚举**。

首先对原来的数组排序，每个数不可能加上另一个数还小。

于是暴力枚举每一个数是否可以表示为两个数的和。

然后保存每一个答案的数，最后排序去重（当时不会集合）。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w[10090];
int main(){
	int ans=0,m=0;;
	cin>>n;
	int q[n];
	for(int i=0;i<n;i++){
		cin>>q[i];
	}
	sort(q,q+n);
	for(int i=0;i<n-1;i++){
		for(int j=i+1;j<n;j++){
			for(int k=j+1;k<n;k++){
              if(q[i]+q[j]==q[k]){
                w[ans]=q[k];
                ans++;
                break;
              }
            }
        }
	}
      m=ans;
	sort(w,w+ans);
  	for(int i=0;i<ans-1;i++){
		if(w[i]==w[i+1])
          m--;
    }
    cout<<m;
	return 0;
}
```
复杂度较高。

---

## 作者：TheTrash (赞：1)

### 思路

数据范围并不大，所以可以用桶来做。

用桶 $t$ 标记给出的正整数，然后枚举每两个不同的正整数，判断它们的和是否在给出的数中出现过。如果出现过就说明这两个数的和等于另一个数，$ans+1$，然后把这个标记去除，因为一个数只能算一次。

### 代码

```cpp
#include<iostream>
using namespace std;
int n,a[110],t[20010],ans;//t要开到20000。因为一个数大小不超过10000，两个数的和就不超过20000
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i],t[a[i]]++;//标记
	for(int i=0;i<n;i++)
		for(int j=i+1;j<n;j++)
			if(t[a[i]+a[j]]==1&&a[i]!=a[j]) ans++,t[a[i]+a[j]]=0;//ans+1并去除标记
	cout<<ans;
}
```

---

## 作者：wanghonghui123 (赞：1)

## 思路

主要题意：统计集合中有多少个数，刚好等于另外两个不同数的和。

我们可以用**桶**的思想来解决。

- 先用标记数组 $st$ 标记出每个元素 $a_i$。

- 接着将数组 $a$ 逆序排序，方便后续操作。

- 随后判断 $a_i-a_j$ 在数组 $a$ 中是否出现过，意思就是有没有一个数加上 $a_j$ 是否等于 $a_i$，还要判断相加的两个数是否不相等。如果是，计数器 $cnt$ 就加一。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105];
bool st[10005];
int main(){
	int n,cnt=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		st[a[i]]=true;
	}
	sort(a+1,a+1+n,greater<int>());
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(st[a[i]-a[j]]&&2*a[j]!=a[i]){
				cnt++;
				break;
			}
		}
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：GLr137 (赞：1)

[**P2141 [NOIP2014 普及组] 珠心算测验**](https://www.luogu.com.cn/problem/P2141)

[或许更好的阅读体验？](https://www.luogu.com.cn/article/62xjulo5)

由于数据量比较小，我们可以用 $O(n^2)$ 的方法来解决。

不难发现，由于集合中每个数较小，所以我们用一个桶来记录所有的数字（每一个数字下标用 $1$ 表示）。再枚举所有不同的两个数，根据建立的桶判断它们的和是否在数列内并且没有记录过（因为一个数不管是多少种两个数的和，都只按一个算），满足条件则将桶的这一个位置改成 $0$（已记录过），答案变量加一，最后输出即可。

值得注意的是，每一个数不超过 $10000$，那两个数的和就有可能达到 $20000$，所以桶要开到 $20000$ 以上的大小。

**Code**

```cpp
# include <bits/stdc++.h>
using namespace std;
int n, z, sz[105], t[20005];
int main (){
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> sz[i];
		t[sz[i]] = 1;
	}
	for (int i = 1; i < n; i++){
		for (int j = i + 1; j <= n; j++){
			if (sz[i] != sz[j] && t[sz[i] + sz[j]] == 1){
				t[sz[i] + sz[j]] = 0;
				z++;
			}
		}
	}
	cout << z;
	return 0;
} 
```

[AC记录](https://www.luogu.com.cn/record/196653175)

代码仅供参考，抄袭必有后报。

---

## 作者：dg114514 (赞：1)

由于 $n\le 100$，所以 $O(n^3)$ 乱搞都能过。\
思路：暴力枚举 $i$、$j$、$k$，每次看是否满足 $a_i+a_j=a_k$，是的话把答案加一，然后把 $k$ 记录下来，防止重复计算。\
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],vis[105]; 
int main(){
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]; 
	for(int i=1;i<=n+2;i++)
		for(int j=i+1;j<=n;j++)
			for(int k=i+2;k<=n;k++)
				if(a[i]+a[j]==a[k])
					if(!vis[k])
						ans++,vis[k]=1;
	cout<<ans;
}
```

---

## 作者：_lxc__ (赞：1)

考虑 Hash。

首先定义桶，然后枚举数组中的每对元素 $a_i$ 和 $a_j$，若 $a_i+a_j$ 已经标记过，那么 $ans+1$ 并把桶的第 $a_i+a_j$ 个位置的标记取消。

注意事项：

* 初始将输入数组中的元素用桶数组标记为 $1$。

* 记得当 $a_i+a_j$ 被标记过时将桶的 $a_i+a_j$ 位置取消标记，以防止重复计算。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110],ans=0;
bool h[20010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		h[a[i]]++;
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(h[a[i]+a[j]]){
				ans++;
				h[a[i]+a[j]]=0;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Amoribus (赞：1)

对于本题，枚举一个 $a_i$ 是否可以被表示为 $a_j+a_k$，（注意，$i,j,k$ 互不相等）如果是就记录答案。

枚举的过程中要注意细节，注意枚举中 $i,j,k$ 不能有任意两个相等。

时间复杂度 $O(n^3)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[109];
long long ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		int flag=0;
		for(int j=1;j<=n;j++){
			if(j==i) continue;
			for(int k=1;k<=n;k++){
				if(k==j||k==i) continue;
				if(a[j]+a[k]==a[i]) flag=1;
			}
		}
		if(flag==1) ans++;
	}
	cout<<ans;
	return 0; 
}
```

---

## 作者：zwz6666 (赞：0)

## 解题思路
数据范围非常小，完全可以直接三层循环枚举。每次用一个布尔类型的数组存有没有算出过，这样来防止重复算。

在最后统计输出答案即可。

时间复杂度 $O(n^3)$，可以通过此题。
## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,a[1000],ans=0;
	bool t[20005];
	cin>>n;
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=20005;i++)t[i]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){//&&j!=k&&i!=k
				if((a[i]+a[j]==a[k])&&i!=j){
					//cout<<i<<" "<<j<<endl;
					if(t[a[i]+a[j]])ans++;
					t[a[i]+a[j]]=0;
				}
			}
		}
	}cout<<ans;
	return 0;
}
```

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2141)

## 题意简化
给定一个数组，寻找其中的 $2$ 个不同数，使这 $2$ 个数的和等于数组中的另外 $1$ 个数。

## 思路
看别的有些大佬用桶，本人用枚举。

先定和，也就是第 $3$ 个数。然后再用循环枚举那两个不同的数，如果有，就加一。最后输出总值。

数据比较小， $3 \le n \le 100$ 。

看完感觉简单了有木有？

## 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,a[101],ans;
bool flag;
//n数组长度（数字个数），a[101]存数字，ans总值，flag辅助判断 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	//加速 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//输入 
	for(int i=1;i<=n;i++){
		flag=false;
		for(int j=1;j<=n && !flag;j++){
			for(int k=1;k<=n && !flag;k++){//这个!flag是我参考了别人的代码，加速用 
				if(i!=j && i!=k && j!=k && a[k]+a[j]==a[i]){
					flag=true;
				}//标记存在 
			}
		}
		if(flag){
			ans++;
		}//加一 
	}
	cout<<ans;//输出 
	return 0;
}
```

---

## 作者：Loyal_Soldier (赞：0)

### 思路
用于数据不大，所以我们可以用一个 $flag$ 数组来判断当前数字是否用过，如果为 $1$ 则为没用过，为 $0$ 则为用过。

我们可以用一个二重循环，枚举两个加数 $a_i$ 和 $a_j$，如果 $flag_{a_i+a_j}$ 为 $1$，答案就加一，并将其标记为已经使用过。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[114],flag[114514],ans;//flag数组判断当前数字是否使用过，ans为最终答案
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		flag[a[i]]=1;//将a[i]标记为未使用
	}
	for(int i=1;i<=n;i++)//枚举两个加数
		for(int j=i+1;j<=n;j++)
			if(flag[a[i]+a[j]])//如果(a[i]+a[j])这个数组没有使用过
                ans++,flag[a[i]+a[j]]=0;//最终答案增加1，将(a[i]+a[j])标记为使用过
	cout<<ans;
	return 0;
}

```

---

## 作者：Genius_Star (赞：0)

### 思路：

考虑求出所有可能的 $a_i + a_j(i \ne j)$，开一个桶存进去。

则若 $a_i$ 在桶里面，就可以被表示为另外两个不同数的和。

时间复杂度为 $O(N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
bool Begin;
const int N = 105, M = 1e4 + 10; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, ans;
int a[N];
bool f[M];
bool End;
int main(){
	n = read();
	for(int i = 1; i <= n; ++i)
	  a[i] = read();
	for(int i = 1; i <= n; ++i)
	  for(int j = i + 1; j <= n; ++j)
	    if(a[i] + a[j] < M)
	      f[a[i] + a[j]] = 1;
	for(int i = 1; i <= n; ++i)
	  if(f[a[i]])
	    ++ans;
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：AIregister (赞：0)

## 题意 ##
题意为寻找两个不同的数，看看是否等于数组中的另一个数即可。
## 思路 ##
每次来循环第一个加数，建立一个标记 $ok$ 并在不成立时继续循环第二个加数，再在不成立时循环和，看三个数中是否不相等，并且两数相加等于第三个数，就让 $ok$ 成立。最后在每次第一层循环末尾时，看看 $ok$ 是否成立，成立将总和加一。输出总和即可。让我们来看看核心代码的意思吧：
```cpp
for (int i = 1; i <= n; i++) {//循环第一个加数
	bool ok = false;//是否成立
	for (int j = 1; j <= n && !ok//不符合才循环; j++) {//循环第二个加数
		for (int k = j + 1; k <= n && !ok//不符合才循环; k++) {//循环和
			if (i != j && i != k) {//如果不相等
				if (a[i] == a[j] + a[k]) {//两数相加等于第三个数
					ok = true;//符合
				}
			}
		}
	}
	if (ok) {//符合sum就加一
		sum++;
	}
}
```
## 整体代码 ##
```cpp
//搁这不是给你抄的！
#include <bits/stdc++.h>
using namespace std;
int n, a[101];
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		bool ok = false;
		for (int j = 1; j <= n && !ok; j++) {
			for (int k = j + 1; k <= n && !ok; k++) {
				if (i != j && i != k) {
					if (a[i] == a[j] + a[k]) {
						ok = true;
					}
				}
			}
		}
		if (ok) {
			sum++;
		}
	}
	cout << sum;
}
```

---

## 作者：_Maverick_ (赞：0)

## 题意
在一个互不相同的数组中，枚举两个不同数之和，和也在数组中，统计不同的和的个数。
## 思路
用数组、哈希表分别记录每一个数。

枚举每两个不同的数，求和，如果和在哈希表中也存在，则 ```ans++```，并且在哈希表中将和移除。

最后输出 ```ans```。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, ans;
int a[105], h[20005];

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        h[a[i]] = 1;
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = i + 1; j <= n; j++)
        {
            if(h[a[i] + a[j]] == 1) 
            {
                ans++;
                h[a[i] + a[j]]--;
            }
        }
    }
    cout << ans;

    return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

题解：[P2141 [NOIP2014 普及组] 珠心算测验](https://www.luogu.com.cn/problem/P2141)

### 思路
看到 $n \le 100$，直接使用暴力就可以了，但是我这篇题解给出一种使用桶的方法。

双重枚举每个数字，当然是不重复的，我们将每一次相加的答案都存储起来，最后算出来桶里的元素位于这个数组中的个数就是答案。

我们可以使用 map 来实现这个操作。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

typedef long long LL;
map<int, int> mp;
const int N = 2e5 + 5;
int n, a[N];
signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	for (int i = 1; i < n; ++i) 
		for (int j = i + 1; j <= n; ++j)
			mp[a[i] + a[j]]++;
	int ans = 0;
	for (int i = 1; i <= n; ++i) 
		if (mp[a[i]]) ans++;
	cout << ans << '\n'; 
    return 0;
}



```

---

## 作者：long_long__int (赞：0)

# 题目解法

枚举 $i,j,k$，如果 $a_j + a_k=a_i$，则把 $i$ 增加一，进入下一轮循环，答案加一。时间复杂度 $O(n^2)$，在此题 $n\le 100$ 的限制下足以通过。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105];
int n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=j+1;k<=n;k++){
				if(a[j]+a[k]==a[i]){
					ans++;
					goto g;//直接执行“g:”后面的部分
				}
			}
		}
		g:
		;//不加这个分号会导致一些奇奇怪怪的编译错误
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：yanxu_cn (赞：0)

提供一种 $\Theta(n^2\log n)$ 的做法，由于本题的数据很小，这种做法的时间效率和 $\Theta(n^2)$ 的做法差距极小。

我们可以先将数组排序，在选择两个数去相加。对于和，我们可以直接二分的去查找（当然这里暴力查找也是可以的）。这样就不用开桶了。

贴一下代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
int v[107];
bool iscnt[107];
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,ans=0;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>v[i];
	}
	sort(v,v+n);
	for(int i=0;i<n;i++)
	{
		for(int j=i+1;j<n;j++)
		{
			int*p=lower_bound(v,v+n,v[i]+v[j]);
			while(*p==v[i]+v[j]&&iscnt[p-v]==0)
			{
				ans++;
				iscnt[p-v]=1;
				break;
			}
		}
	}
	cout<<ans<<'\n';
	return 0;
}

```

---


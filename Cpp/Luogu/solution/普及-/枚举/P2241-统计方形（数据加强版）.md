# 统计方形（数据加强版）

## 题目背景

1997年普及组第一题


## 题目描述

有一个 $n \times m$ 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。

## 样例 #1

### 输入

```
2 3```

### 输出

```
8 10```

# 题解

## 作者：原株龙葵 (赞：3908)

# P2241 统计方形

------------

前面几个大佬讲的东西我都看了，数学学得是真好！在此orz了。

但是，题解是给我这种蒟蒻看的，看完了什么也看不懂不就尴尬了吗？

本蒟蒻**语数外物化史地政生**无一课不弱得要命。

所以，本蒟蒻发得题解一定**接地气**，保证看懂。

废话不说了，看题解。

------------

首先，统计一个n*m的矩形里有多少个正方形，长方形。

要明确，正方形和长方形都是矩形，那么n*m的矩形里的

**矩形数**=**正方形数**+**长方形数**

明确这一点后，就可以一次求出二者了

![](https://cdn.luogu.com.cn/upload/pic/51556.png)
![](https://cdn.luogu.com.cn/upload/pic/51554.png)

如图，长为2宽为1的小长方形用〇来表示，那么

横向排列的就有 **（n-1）*m** 个

竖向排列的就有 **n*（m-1）** 个

证明：
     
         ∵ 矩形长不等于宽

         ∴ 子矩形构成的矩阵的长宽是由原矩形长宽减去不同数而得
         
         即(n-b)*(m-a) (a≠b)

![](https://cdn.luogu.com.cn/upload/pic/51557.png)

如图，用 · 表示长宽均为二的正方形

即有(n-1)*(m-1)个小正方形

证明：

		∵正方形长等于宽
    
	    ∴子正方形构成的矩阵的长宽由原矩形长宽减去相同数而得
        
        即(n-b)*(m-a) (a=b)
        
------------

上代码！（最短）
```cpp
#include<iostream>
using namespace std;
long long n,m,rec,sqr;
int main() {
    cin>>n>>m;
    for(int i=0; i<n; i++)//循环，从n-0到n-(n-1)
        for(int j=0; j<m; j++) {//循环，从m-0到m-(m-1)
            if(i==j) sqr+=(n-i)*(m-j);//如果i==j，说明是正方形
            else rec+=(n-i)*(m-j);//如果不等说明是矩形
        }
    cout<<sqr<<" "<<rec<<endl;//输出
    return 0;
}
```


------------

本蒟蒻做出**普及**的题很高兴，代码上的问题还望诸佬多指教。

如果诸佬觉得本蒟蒻的疏才浅学还能略有裨益，勿忘赞

###   看本蒟蒻这么用心写题解，诸佬真的不点个赞再走吗？^-^

---

## 作者：lsroi (赞：410)

对于这道题，我们先考虑第一个问题

**一、算正方形的个数**

1.如果我们固定了正方形的右下角(i,j),你能不能算出此时可能的正方形的个数？

2.显然，此时答案为Min(i,j).

3.所以可以枚举右下角，计算此时答案，求和即可。

**二、算长方形个数**

1.其实算长方形并不常见，但算矩形大家应该经常遇到，所以如果你会算矩形，再联系第一个问题，那答案就转化为 矩形个数-正方形个数.

2.像求解正方形个数一样，固定矩形右下角(i,j),显然此时矩形个数为i*j.

3.同理，求和即可.

 ~~时间复杂度：O(n*m)，是挺慢的，其实可以写成一个式子~~

**代码如下：**

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int main()
{
	ll n,m,i,j,sum=0,sum1=0;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
	  for(j=1;j<=m;j++)
	  {
	    sum+=min(i,j);
	    sum1+=i*j;
	  }
	}
	
	cout<<sum<<" "<<sum1-sum<<endl;
	return 0;
}
```

---

## 作者：Hail_SHEILD (赞：131)

##思路

先求出所有矩形的个数x，再求出正方形的个数y，则x-y即为长方形的个数。

使用排列组合的思想求x：

所有矩形的个数x为

  ![](https://cdn.luogu.com.cn/upload/pic/6286.png)  

下面求y。

考虑：对于一个边长为 ![](https://cdn.luogu.com.cn/upload/pic/6288.png) 的正方形有多少种放置方法， 易得有

 ![](https://cdn.luogu.com.cn/upload/pic/6287.png) 

种。
所以，所有正方形的个数y为



 ![](https://cdn.luogu.com.cn/upload/pic/6285.png)  

##代码


···cpp

```cpp
#include<cstdio>
long long M,N,x,y;
long long min(int a, int b) {
    return a<b?a:b;
}
int main() {
    scanf("%lld%lld",&M,&N);
    x=((M+1)*M/2)*((N+1)*N/2);
    for(long long i=1; i<= min(M,N); i++) {
        y+=(M-i+1)*(N-i+1);
    }
    printf("%lld %lld", y, x-y);
    return 0;
}
···
```

---

## 作者：luosiyuan (赞：108)

因为我是小学生，所以用了小学生的思路（尴尬）

其实这是一题小学奥数

- 矩形的个数求法：

由于单纯矩形很难求，就先求出包含正方形一起的个数。

怎么求呢？我们知道左上两边都有线段，每一条左边的线段与上边的线段确定一个长方形（画个图就知道了），所以只需要

把左边的线段数与右边的线段数乘起来就是答案(别忘了减去正方形)！

- 正方形的个数求法：

每一条左边的线段与上边的线段若是等长，则其确定一个长方形。所以，对于边长为i的正方形，可以让一条长度为i的线段在

左上两边上移动，得到其个数为：$ (n-i+1)*(m-i+1) [n<m]$ ！

然后分析一下这个公式，发现其实可以倒着循环，这样相当于令$ aa=(n-i+1)$ ,则 $ m-i+1=aa+m-n $ ;所以采用倒推法。

```cpp
#include"iostream"
#include"algorithm"
using namespace std;
int main(){
    long long int c,k,s1=0,s2=0,s3=0,i;
    cin>>k>>c;
    if(k>c)swap(k,c);
    for(i=k;i>0;i--){
        s1+=i*(i+c-k);//倒推
    }
    cout<<s1<<" ";
    for(i=1;i<=k;i++){
        s2+=i;
    }
    for(i=1;i<=c;i++){
        s3+=i;
    }
    cout<<s2*s3-s1;
    return 0;
}
```

---

## 作者：J与M等于Y (赞：94)

啦啦啦，经过在谷一年的潜伏，我终于想开始发题解啦！（各位管理员大大一定要对我这个蒟蒻宽容点呀！）

言归正传，对于一道水题，$N$和$M$很小，我们完全可以不计后果的枚举（~~这是假的~~），但我们还是要努力去找正解。[再看下题呗](https://www.luogu.com.cn/problem/P2241)

### 1.题意分析

这道题的题意很简单，就是给你一个长方形，求出长方形里有多少个小长方形和正方形（长方形中不包括正方形）。就是这么简单，我也不啰嗦了。下面给出图（几何画板做的）。
![对不起，失败了](https://i.loli.net/2020/03/27/EhjrwSebvgalF2H.jpg)

### 2.解法

解法也不难，运用小学时代的公式（设长为$n$，宽为$m$）：

$(1+2+3+...+n)(1+2+3+...+m)$

或

$nm(n+1)(m+1)/4$（等差数列的化简）

即可算出长方形个数。下面给出证明（请看上图）：

在$AD$中，单位长度为$1$的有两个，$AJ,JD$。单位长度为$2$的有一个，$AD$。同理,$AB$中单位长度为$1$的有三个，单位长度为$2$的有两个，单位长度为$3$的有一个。（或者用一点到其它点有几个也是一样的，不阐述）

可能一些初学公式的小学生要问了（没得罪人吧），这些求出来有何用呢？答案显而易见，没一种情况对应着邻边的所有情况。比如$AJ$对应$AE,EF,FB,AF,EB,AB$就是$AB$中的所有情况呀！这样就可以推导出上方的两个公式。

那正方形怎么求呢？其实，正方形就是上方公式的特殊情况，即单位长度相等的情况。可以有公式
$nm+(n-1)(m-1)+...min(n,m)$

仔细品一下，好像没错吧？（应该还能推，但太麻烦了，实际应用不大）所以开始愉快地打代码吧！

### 代码区（勿抄）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans=0,bns=0,l[10005],r[10005],k=0;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) l[n-i+1]=i，ans+=i;//计算长方形和边个数。
	for(int i=1;i<=m;i++) r[m-i+1]=i，bns+=i;
	for(int i=1;i<=min(n,m);i++) k+=l[i]*r[i];
	cout<<k<<" "<<ans*bns-k<<endl;
}
```
本来还有更好的打法，可以将时间复杂度降到$O(min(n,m))$，但不知为何爆$40$，下面贴上代码。（已修复）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans,bns,k=0,r,l;
int main(){
	cin>>n>>m;
	ans=n*(n+1)/2,bns=m*(m+1)/2;
	r=min(n,m),l=max(n,m);
	for(int i=1;i<=r;i++) k=k+i*(i-r+l);
	cout<<k<<" "<<ans*bns-k<<endl;
}
```
如果有公式改良版也可以私信我（放评论区），我会把您们的想法放到题解或我的博客中（如果此题无法改题解了）。

#### 声明：这是本蒟蒻自己推的公式，如有雷同，纯属巧合，管理员大大们不要以为我作弊哟。

再说一遍：管理员大大们最好了！希望我可以看到我的题解在洛谷中公开。（一个小蒟蒻的小小小愿望）

---

## 作者：ars4me (赞：83)

正方形个数


边长为1 个数n\*m


边长为2 个数（n-1）\*（m-1）


边长为3 个数（n-2）\*（m-2）


所以 边长为min{n，m} 个数（m-min{n，m}+1）\*（n-min{n，m}+1）


长方形加正方形个数



total=（1+2+3+…+n）\*（1+2+3+…+m）

=（（1+n）\*（1+m）\*n\*m)/4


长方形个数


上面两式相减即可得出


所以思路就是 先算出正方形个数 然后用公式得出长方形和正方形个数总和 最后得到长方形个数


代码很短


```cpp
#include<iostream>
using namespace std;
long long n,m,a,b,c,d;
int main()
{
    cin>>n>>m;    
    a=m;b=n;c=m*n;
    while(a!=0&&b!=0){
        a--;b--;c+=a*b;
    }
    d=(m+1)*(n+1)*m*n/4-c;
    cout<<c<<" "<<d;
}
//COYG
```

---

## 作者：oistr (赞：37)

## 总体思路：枚举、暴力再加上一点点数学知识

首先做法是很透彻的：**枚举每一个格子，看以它为左上角的矩形共有多少个（正方形与长方形同属于矩形）**

那么我们怎么计算以一个格子为左上角的矩形个数呢？其实很好算：我们观察得到只要确定一个左上角和一个右下角就能确定一个矩形。所以对于任一个格子，我们只需要计数以其为左上角的矩形的右下角个数即可：

假设我们枚举道第i行，第j列格：那么当前盘面如下：
```
x x x x x x
x x x x x x
x x o . . .
x x . . . .
x x . . . .
```
当前枚举到o（i，j）格（左上角为（0,0））

现在我们只需要数标‘.’的格子即可（根据上面的思路，数右下角）而标x的格子则无关，此时所有.的总数为（n-i）*（m-j）

**如要构成正方形** ，可能的右下角（用*标出，还有o本身）如下：
```
x x x x x x
x x x x x x
x x o . . .
x x . * . .
x x . . * .
```
我们发现，所有的*与o的个数加起来恰好等于n-i！
我们再看一个例子：
```
x x x x x x
x x x x x x
x x x x o .
x x x x . *
x x x x . .
```
这时个数却是m-j。
再举几个例子之后，我们会发现：对于任一个格，以其为左上角的正方形的个数为
min（n-i，m-j）

**计算出正方形个数之后，长方形的个数就等于矩形的个数减去正方形的个数了。**
所以，长方形个数为：（n-i）*（m-j）-min（n-i，m-j）。

然后我们就分析完了，上代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;//命名空间
int main()
{
	int n,m;//长和宽
	cin>>n>>m;//input
	long long z=0,c=0;//z记录正方形的个数，c记录长方形的个数
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)//二重循环遍历每个格子
		{
			int tem=min(n-i,m-j);
			z+=tem;
			c+=(n-i)*(m-j)-tem;//按照以上所述计算
		}
	}
	cout<<z<<" "<<c<<endl;//output
	return 0;
}
```
**注意其中记录矩形个数的两个变量不开long long会溢出**

---

## 作者：WZWZWZWY (赞：32)

怎么题解都是清一色的 $O(nm)$，有没有更新鲜的做法呢？

当然有，接下来请体验 $O(n^2m^2)$ 到 $O(1)$ 的极限优化吧……

一开始在讨论区浏览到一个帖子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ah8xqe4x.png)

因为直接求长方形比较困难，所以可以通过求正方形个数和矩形个数来求长方形个数。我回复道：

![](https://cdn.luogu.com.cn/upload/image_hosting/b5knzspv.png)

大多数题解局限于此。可是真的只能优化到 $O(nm)$ 吗？

（$O(nm)$ 做法可以先参考上面的图片或其他题解，这里就不细讲了。）



------------

先讲 $O(\min(n+m))$，为了比较透彻，所以篇幅相对来说有点大，请耐心QwQ。

建议大家拿出一张纸画画，如果你想象力强大，可以想象。

可以先想象出一个 $4\times 6$ 的长方形框。

```
 ___________
|_|_|_|_|_|_|
|_|_|_|_|_|_|
|_|_|_|_|_|_|
|_|_|_|_|_|_|
```

假设我们现在要求边长为 $2$ 的正方形。先把左上角 $2\times 2$ 的区域用正方形框起来。正方形最右边的格子的横坐标（从左往右数）是 $2$，最下边的格子纵坐标（从上往下数）也是 $2$，没问题吧？至于外圈的长方形，右下角的格子横、纵坐标分别是 $4$、$6$。

接下来这个正方形还**可以往右移动小于等于 $m-j$ 个格子**（$6-2=4$），**往下移动小于等于 $n-i$ 个格子**（$4-2=2$）。（假设不能向左和向上移动。）

**所以这个正方形总共能存在的方案数为 $(n-i+1)\times (m-j+1)$**。

为什么有个 $+1$ 呢？因为可以某个方向不移动。每个方向的可能结果相乘就是存在的方案数。

知道了一个大小的正方形能出现多少次，就可以知道每个大小的正方形出现多少次。

因为正方形最大边长为 $\min(n,m)$，所以只要一个 `for` 循环依次枚举就能找到所有正方形的个数。

```
int k = min (n, m), cnt_zheng = 0; // 找正方形
for (int i = 1; i <= k; i++) {
	cnt_zheng += (n - i + 1) * (m - i + 1);
}
```

然后对于每个坐标 $(i,j)$，右面（包括正方形自己的最右边的那个格子）的格子个数（即横着的边的数量）乘以下面格子个数，就等于总共能形成的矩形个数（包括正方形和长方形）。

```
int cnt = 0;
for (int i = 1; i <= n; i++) 
	for (int j = 1; j <= m; j++) cnt += (n - i + 1) * (m - j + 1);
```

相减就是长方形个数。

但是，时间复杂度有点高。

我们把它拆开看看。（为了便于初学者理解，就不用 $\sum$ 表示了。）

第二个循环内，$n-i+1$ 似乎并不受影响，把它设为 $x$。变成了：

```
for (int i = 1; i <= n; i++) {
	int x = n - i + 1;
	for (int j = 1; j <= m; j++) cnt += x * (m - j + 1);
}
```
把第二层循环展开，可以表示为 $x\times m + x\times (m-1)+\dots+x\times1=x(m+(m-1)+\dots+1)$。

是不是有点眼熟？这不就是 $x$ 倍的 $m$ 到 $1$ 的和吗？

一年级知识，等差数列求和公式：首项加尾项乘项数除以 $2$。

所以结果为 $\frac{x(1+m)m}{2}$，没问题吧？

成功地去掉了一个 `for`。

```
for (int i = 1; i <= n; i++) {
	int x = n - i + 1;
	cnt += x * (1 + m) * m / 2;
}
```

现在总的时间复杂度为 $O(\min(n,m)+n)$。

欸，我们又发现，这个 $x$ 是不是也有规律？

我们依次把 $i$ 带入，发现 $x$ 是从 $n$ 到 $1$。

因为 $cnt=(x_1+x_2+\dots+x_n)\times \frac{(1+m)m}{2}$。

而 $x_{1\dots n}$ 又依次是从 $n$ 到 $1$ 中每个数。

也就是说 $x_1+x_2+\dots+x_n=n+(n-1)+\dots+1=\frac{(1+n)n}{2}$。

带回去，$cnt=\frac{(1+n)n}{2}\times \frac{(1+m)m}{2}=\frac{(1+n)(1+m)nm}{4}$。

所以**我们可以 $O(1)$ 地求矩形的总个数了！**

```
cnt = (1 + n) * n * (1 + m) * m / 4; // 求矩形总个数
```

但我们求正方形的个数 $O(\min(n,m))$ 的时间复杂度，所以总的时间复杂度只能做到 $O(\min(n,m))$。

```
#include <iostream>
#define int long long
using namespace std;
signed main() {
	int n, m;
	cin >> n >> m;
	int k = min (n, m), cnt_zheng = 0;
	for (int i = 1; i <= k; i++) 
		cnt_zheng += (n - i + 1) * (m - i + 1);
	cout << cnt_zheng << " " << (1 + n) * n * (1 + m) * m / 4 - cnt_zheng;
}
```

------------

### 但，仅限于此吗？

把求正方形的循环给展开。

$cnt=m\times n+(m-1)\times (n-1)+(m-2)\times (n-2)+...(m-k+1)\times (n-k+1)$


$=mn+(mn-n-m+1)+(mn-2n-2m+4)+\dots+(mn-mk+m-kn+k^2-k+n-k+1)$

$=mn+(mn-n-m+1)+(mn-2n-2m+4)+\dots+(mn-m(k-1)-n(k-1)+(k-1)^2)$。

我们发现（$1\le i\le k$）：

+ 每一项都有一个 $+mn$；
+ 第 $i$ 项有一个 $-(i-1)(n+m)$；
+ 每个 $i$ 也有 $+(i-1)^2$。

所以：

+ 总共有 $k$ 个 $+mn$；
+ 有 $\frac{k\times (k-1)}{2}$ 个 $-(n+m)$；
+ $i$ 取 $1\dots k$，每个 $(i-1)^2$ 相加。

最后这个怎么计算？~~于是我去百度了一下。~~

还真有这个公式。对于前 $x$ 项的平方和，结果为 $\frac{x(x+0.5)(x+1)}{3}$。想深入了解的请自行百度QWQ，~~因为我太菜了也不会~~。

然后就好求啦，把三个值相加就行了。

理论上时间复杂度 $O(1)$。

```
#include <iostream>
#define int long long
using namespace std;
signed main() {
	int n, m;
	cin >> n >> m;
	int k = min (n, m), cnt_zheng = m*n*k - k*(k-1)/2*(m+n) + (k-1)*(k-0.5)*k/3;
	cout << cnt_zheng << " " << (1 + n) * n * (1 + m) * m / 4 - cnt_zheng;
}
```

由于检查的不是很仔细，可能会出现一些语言或者公式上的问题，如果发现欢迎提出，谢谢。


------------

还有什么不理解的或者想挑刺的欢迎提出QAQ。

---

## 作者：2016级8班taiqi (赞：23)

ans记录正方形和长方形的总数

```cpp
#include<iostream>
using namespace std;
long long m,n,k,ans(0);
int main(){
    cin>>m>>n;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++){
            ans+=i*j;//枚举每一种可能
        }
    for(int i=0;;i++){
        if(i>n||i>m)
        break;
        k+=(n-i)*(m-i);//k记录正方形
    }
    cout<<k<<" "<<ans-k;
    return 0;
}
```

---

## 作者：灬Amiya灬 (赞：16)

![](https://cdn.luogu.com.cn/upload/pic/43489.png)

首先是矩形的个数,可以用选择两条横线与两条竖线相交的排列组合得出
因为可以得到矩形的总个数为

![](https://cdn.luogu.com.cn/upload/pic/43490.png)

然后再算正方形
正方形的最小边长为1 最大边长为min(N,M)
然后算1~min(N,M)的正方形的个数
每一种边长的正方形个数都由另一条边的长度(即max(N,M))决定
容易得出
i为正方形的边长，取值范围为1~min(N,M)
每一种边长的正方形个数 = (min(N,M)-i+1)* (max(N,M)-i+1)
那么长方形的个数就是矩形个数-正方形个数啦~
最后记得数据类型是long 
而且 输入的n,m也要取long,因为计算过程用到n和m,不取的话依然是会溢出的
```java
package p2241;

import java.util.Scanner;

public class Main {
	
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		long n;
		long m;
		Scanner in = new Scanner(System.in);
		n = in.nextInt();
		m = in.nextInt();
		long   min = Math.min(n, m);
		long    max = Math.max(n, m);
		long  sum = (((n+1)*n)/2)*(((m+1)*m)/2);
		long  zfx=0;
		int   x=1;
		while(x<=min) {
			zfx+=(min-x+1)*(max-x+1);
			x++;
		}
		System.out.println(zfx+" "+(long)(sum-zfx));
	}

}

```

---

## 作者：Kadxy (赞：11)


一个矩阵存在的正方形的数量=长*宽+（长-1）*（宽-1）...
所以用一个while判断循环算出ans1（矩阵正方形数量）。

而一个矩阵存在长方形的数量=矩阵存在的矩形数量-矩阵存在的正方形数量。一个矩阵的边可以看做点，当n=2，m=3时：一条边有3个点，一条边有4个点。两边各任取两个点作为其边长，有C32*C42=((3*2)/(2*1))*((4*3)/(2*1))=18,所以ans2=矩阵矩形数量-ans1


代码如下：
```c
#include<iostream>
#include<cstdio>
using namespace std;
int main(void) 
{
	long long m,n,a,b,ans1,ans2;//int型不够 
	cin>>m>>n;
	a=m;
	b=n;//m.n后面还要用，前面不能改变 
	while(a-1>=0&&b-1>=0)//正方形宽不小于0时累加正方形数量 
	{
		ans1+=a*b;
		a-=1;
		b-=1;
	}
	ans2=(m*(m+1)/2)*(n*(n+1)/2)-ans1; 
	cout<<ans1<<" "<<ans2;//输出答案 
	return 0;
}
```


---

## 作者：蟋蟀喵～～ (赞：5)

看题解里没有 $O(1)$ 的算法，我来写一个 $O(1)$ 的。

## 公式推导
![](https://cdn.luogu.com.cn/upload/image_hosting/tyews5y5.png)
（画的有些丑，请管理多多包涵一下 QAQ）

注：点数 $=$ 边数 $+\;1$，$n$ 为长方形的长，$m$ 为长方形的宽。

#### 长方形个数

我们可以这么想，长方形的长的起始点是 $x$，结束点是 $y$，宽的起始点是 $a$，结束点是 $b$（$ x \ne y , a \ne b$）。

也就是说，$x,y$ 的选点方法总数是：

$$ 
\begin{aligned}
  C^2_{n+1} &= \frac{A^2_{n+1}}{2!} \\
  &= \frac{(n + 1) \times n}{2}
\end{aligned}
$$

同理，$a,b$ 的选点方法总数是

$$ 
\begin{aligned}
  C^2_{m+1} &= \frac{A^2_{m+1}}{2!} \\
  &= \frac{(m + 1) \times m}{2}
\end{aligned}
$$

根据乘法原理，长方形个数（包括正方形为）：
$$\frac{(n + 1) \times n}{2} \times \frac{(m + 1) \times m}{2}$$

#### 正方形个数

考虑每个正方形边长，直至边长为 $m$。

- 边长为 $1$：个数 $=n \times m$。
- 边长为 $2$：个数 $=(n - 1) \times (m - 1)$。
- 边长为 $3$：个数 $=(n - 2) \times (m - 2)$。

$\cdots\cdots$

- 边长为 $m$：个数 $=(n - m + 1) \times 1$。

总个数 $=$

$$\sum_{i = 0}^{m - 1}  (n - i) \times (m - i)$$

该式子可化简为:

$$\frac{m \times (m + 1) \times[2 \times n + (n - m + 1)]}{6}$$

具体推导过程十分繁琐，具体推导过程请参考[这里](https://zhidao.baidu.com/question/1744090565494182027.html)。

__我们注意到，题目里所问的长方形不包括正方形，所以我们需要用长方形个数减去正方形个数。__

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;     //注意：这题需要开 long long
int main(){
	cin >> n >> m;
	if(n < m) swap(n,m);
	long long changfangxing = ((n) * (n + 1) / 2) * (m * (m + 1) / 2);
	long long zhengfangxing = (m) * (m + 1) * (2 * n + (n - m + 1)) / 6;
	cout << zhengfangxing << " " << changfangxing - zhengfangxing;
	return 0;
}



```

---

## 作者：SBS苏 (赞：4)

可以算出，正方形个数为m\*n+(m-1)\*(n-1)+...+(m-n+1)\*1，前提是m>n。正方形与长方形的总个数是[m\*(m+1)/2]\*[n\*(n+1)/2]，那么长方形的个数可用容斥原理解得。

下面上代码：

/\*
Problem:

OJ:
User:    S.B.S.

Time:
Memory:

Length:

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<cassert>
#include<climits>
#include<functional>
#include<bitset>
#include<vector>
#include<list>
#define F(i,j,k) for(long long i=j;i<=k;++i)
#define M(a,b) memset(a,b,sizeof(a))
#define FF(i,j,k) for(int i=j;i>=k;i--)
#define maxn 10001
#define inf 0x3f3f3f3f
#define maxm 4001
#define mod 998244353
//#define LOCAL
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
long long n,m;
int main()
{
    std::ios::sync_with_stdio(false);//cout<<setiosflags(ios::fixed)<<setprecision(1)<<y;
    #ifdef LOCAL
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    cin>>n>>m;
    if(n>=m) swap(n,m);
    long long ans1=0,ans=(m*(m+1)/2)*(n*(n+1)/2);
    F(i,0,n-1) ans1+=(m-i)*(n-i);
    cout<<ans1<<" "<<ans-ans1<<endl;
    return 0;
}

```

---

## 作者：kamiyoru (赞：3)

我们只需要判断以(a,b)为左上顶点的长方形和正方形的数目。

很容易就知道以(a,b)为顶点的长方形有n-a种水平的边长，m-b种竖直的边长，以(a,b)为顶点的正方形有要取他们之间较小的数。于是以(a,b)为顶点的正方形有min(n-a,m-b)个，以(a,b)为顶点的长方形（包括正方形）有(n-a)×(m-b))个。

因为循环中(a,b)中的a,b都是升序的，所以不会有数重，我们可以放心地累加。题目中要求把正方形去掉，所以我们只需要把数出的长方形数目减去数出的正方形数目即可。棋盘为5000\*5000时长方形的个数为156270827082500个，显然用int是存不下的。

```cpp
#include <cstdio>
int main(){
    long long n,m,ans1=0,ans2=0,a,b;
    scanf("%lld%lld",&n,&m);
    for(a=0;a<=n;a++)for(b=0;b<=m;b++){
            ans1+=((n-a<m-b)?n-a:m-b);//累加正方形的数目
            ans2+=(n-a)*(m-b);//累加长方形的数目
    } 
    printf("%lld %lld",ans1,ans2-ans1);
}
```

---

## 作者：yin_sy (赞：3)

用数学方法即可解决，正方形用一重循环决定正方形的大小，长方形用二维循环解决。

```cpp
var
    j,n,m,t,i:longint;
    x,x2:int64;
begin
    readln(n,m);
    if n>m then begin t:=n; n:=m; m:=t; end;
    for i:=1 to n do
        x:=x+(n-i+1)*(m-i+1);{每一行能放下几个这样的正方形乘以每一列能放下几个这样的正方形就是这种正方形能放下几个}
    for i:=1 to n do
        for j:=1 to m do
            x2:=x2+(n-i+1)*(m-j+1);{每一行能放下几个这样的长方形乘以每一列能放下几个这样的长方形就是这种长方形能放下几个}
    writeln(x,' ',x2-x);{我有一个疑问，正方形不是特殊长方形吗，数学中长方形包括正方形啊}
    readln;
end.
```

---

## 作者：封禁用户 (赞：3)

这个题我是用半数学半递推的方法做的，首先我用（1+……+m）\*（1+……+n）算出所有矩形的数目（这个是为什么呢？在小学我们就知道一条线段被分成n份，那么一共有1+……+n条线段，那么横向上就有1+……+m条线段，纵向上有1+……+n条线段，而横向上的一条线段与纵向上的一条线段组合在一起就构成一个矩形，根据乘法原理就有（1+……+m）\*（1+……+n）个矩形），然后只要我们求出正方形的数目就可以知道长方形的数目了。正方形的数目可以用递推式f[n][m]=f[n-1][m-1]+n\*m求出，关于这个递推式，其实我们可以用一种最简单粗暴的方法——在纸上手画一个二维数组然后归纳得出这个式子，根本不需要仔细分析。但是接着就有一个新的问题——这种方法在原来那个数据很弱的棋盘问题上很适用，直接开个int f[101][101]就行了，但是这个题我们总不能开个long long f[5001][5001]吧，会MLE的（这是我上一次提交时出现的问题），我后来看了一下最大的那个结果（就是m和n都是5000的结果），只超出了unsigned int不到一个字节，所以我就把f按位拆成两个二维数组f和f1，一个是unsigned int存低位，另一个是unsigned char存高位，这样就节省了一些内存空间。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
unsigned int f[5001][5001];
unsigned char f1[5002][5002];
int main(){
    unsigned long long n,m;
    cin>>n>>m;
    unsigned long long total=((n*(1+n))*(m*(1+m)))/4;      //就是（1+……m）*（1+……n），此处用到了那个等差数列的求和公式
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            unsigned long long fa=((unsigned long long)f1[i-1][j-1])<<32|((unsigned long long)f[i-1][j-1]);//把低位f和高位f1通过位运算合在一起
            unsigned long long rea=i*j+fa;
            f[i][j]=(unsigned int)rea;    //把结果拆开，取结果的低位
            f1[i][j]=rea>>32;            //取结果的高位
        }
    }
    unsigned long long squ=f[n][m]|((unsigned long long)f1[n][m])<<32;     //这便是正方形的数目
    cout<<squ<<" "<<total-squ<<endl;      //total-squ便是长方形的数目
    return(0);
}
```

---

## 作者：Real_Create (赞：2)

好多模拟的，然鹅这是数论题

我们要知道一个网格中矩阵怎么求

就是（1+2+3...+m）* （1+2+3...+n）=（1+m * m/2） * （1+n * n/2）

算正方形的话。。。~~老师没教~~

所以我就老老实实的暴力了

所以这就是代码了

```cpp
#include <bits/stdc++.h>//noip不能用（话说它死了。。。）
using namespace std;
int m,n;
unsigned long long x,y,ans;//保险起见的unsigned long long
int main()
{
	cin>>m>>n;//输入
	if(m>n)
	{
		swap(m,n);//判断
	}
	for(int i=0;i<m;i++)
	{
		ans+=(m-i)*(n-i);//正方形
	}
	x=((1+m)*m/2);//宽上能有几种可能
	y=((1+n)*n/2);//长上能有几种可能
	cout<<ans<<' '<<x*y-ans;//输出
	return 0;
}

```


极简代码：

```
#include <bits/stdc++.h>
using namespace std;
int m,n;
unsigned long long ans;
int main(){
	cin>>m>>n;
	if(m>n)
        swap(m,n);
	for(int i=0;i<m;i++)
		ans+=(m-i)*(n-i);
	cout<<ans<<' '<<((1+m)*m/2))*((1+n)*n/2)-ans;
	return 0;
}

```


---

## 作者：wxk01 (赞：2)

我用了俩函数：g(x,y)是统计正方形，f(x)\*f(y)方形。

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
using namespace std;
long long n,m;//开大点，int不能过
long long f(long long x){//x的阶加
    long long s=0;
    for(long long i=1;i<=x;i++){
        s+=i;
    }
    return s;
}
long long g(long long x,long long y){
    long long s=0;
    for(long long i=0;i<min(x,y);i++){//统计正方形
        s+=(x-i)*(y-i);
    }
    return s;
}
int main(){
    scanf("%lld%lld",&n,&m);
    printf("%lld %lld",g(n,m),f(n)*f(m)-g(n,m));
}
```

---

## 作者：Goder (赞：2)

非常简单，只需把longint改成qword即可AC。

```cpp
var a,b,a1,b1,s1,s2:qword;
begin
    readln(a,b);
    a1:=a;
    b1:=b;
    s1:=a1*b1;
    while (a1<>0) and (b1<>0) do
        begin
            dec(a1);
            dec(b1);
            s1:=s1+a1*b1;
        end;
    s2:=((a+1)*(b+1)*a*b) div 4-s1;
    writeln(s1,' ',s2);
end.
```

---

## 作者：LevenKoko (赞：1)

显然这和棋盘问题差不多，但数据更大，要用long long

再提一下那个乘法原理。。。（尴尬）

代码：

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,m,ans;//long long 别忘了
    cin>>n>>m;
    int a=n,b=m;
    ans=m*n;
    while(n!=0 and m!=0)
    {
        n--;m--;
        ans+=n*m;//计算正方形个数；
    }
    cout<<ans<<" "<<(1+a)*a/2*(1+b)*b/2-ans;//注意要减去正方形个数（注意公式）；
    return 0;//这个别忘了（虽然洛谷上好像不会错）
} 
```

---

## 作者：elegy_for_end (赞：0)

简单题

这跟p1548一样，只不过数据大了点而已

分析：

首先对于n*m方格的棋盘中的任意的正方形而言，只要确定了左上角的位置和边长后，该正方形就完全确定了，如果两个正方形的左上角位置不同或左上角位置相同但边长不同，则这两个正方形显然不相同，因此只要穷举出最下面和最右边之外的所有格点（两条边的交叉点），算出以它们作为正方形的左上角位置时边长不同的正方形个数，然后累加起来即得到全部的正方形个数。同样地，以某一个格点为长方形的左上角位置的长方形（包括正方形）个数也可以类似地算出来，然后累加起来即得到全部的长方形个数，再去掉前面算出的正方形个数即为程序中要求的长方形个数了。

为了求出以某一个格点为正方形的左上角位置时的正方形个数，我们对所有的边进行编号，将从上到下的m+1条横向边定为第0行道第m行，将从左到右的n+1条纵向边定位第0列到第n列，这样以第i行与第j列的交叉点为正方形的左上角位置的正方形边长最大只能为m-i与n-j中的最小值，因此以第i行与第j列的交叉点为正方形的左上角位置的正方形个数为min(m-i,n-j),类似地以第i行与第j列的交叉点为正方形的左上角位置的长方形个数（包括正方形）(m-i)*(n-j)个，因为长方形的高可以取1到m-i中的任一值，长方形的宽可以取1到n-j中的任一值。

源程序：
```
var i,j:longint;
    n,m,s:int64;    //存放正方形和长方形的个数；(注意要用int64，不然只对4个点)
begin
  readln(n,m);
  s:=0;
  for i:=0 to n-1 do
     for j:=0 to m-1 do
        if n-i<m-j then
          s:=s+n-i
        else
            s:=s+m-j;                          //算正方形个数；
  write(s,' ');       //输出；
  s:=-s;         //记住，重新赋值；
  for i:=0 to n-1 do
     for j:=0 to m-1 do
        s:=s+(n-i)*(m-j);      //公式：s:=s+(n-i)*(n-j）；
  write(s);
end.
```

---


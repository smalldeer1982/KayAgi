# 涂条纹

## 题目描述

只要一个由 $N \times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。

小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。

## 说明/提示

### 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```
一共需要改 $11$ 个格子。

### 数据范围

对于 $100\%$ 的数据，$N,M \leq 50$。

## 样例 #1

### 输入

```
4 5
WRWRW
BWRWB
WRWRW
RWBWR```

### 输出

```
11```

# 题解

## 作者：kkksc03 (赞：363)

暴力
首先预处理，算出每一行如果分别换成R/W/B需要的成本

然后n^2的枚举前两种颜色的行数，第三种颜色就是剩下的，然后统计比较。注意每行不能小于1。

不用什么优化，如果你高兴的话还能使用前缀和优化。


---

## 作者：「已注销」 (赞：231)

## $O(n^2+nm)$

开数组`w[i],b[i],r[i]`，分别表示把前$i$行涂成白、蓝、红需要涂的格子数

设第$1$行到第$i$行是白色

第$i+1$行到第$j$行是蓝色

则第$j+1$行到第$n$行是红色

#### 此时代价为$w_i+b_j-b_i+r_n-r_j$

枚举$i,j$，取最小值即可
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,ans=0x7fffffff,w[51],b[51],r[51];
string s;
inline int check(char c){
    int tot=0;
    for(int i=0;i<m;++i)
        if(s[i]!=c)++tot;
    return tot;    
}
int main(int argc, char const *argv[])
{
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>s;
        w[i]=w[i-1]+check('W');
        b[i]=b[i-1]+check('B');
        r[i]=r[i-1]+check('R');
    }
    for(int i=1;i<n-1;++i)
        for(int j=i+1;j<n;++j)
            ans=min(ans,w[i]+b[j]-b[i]+r[n]-r[j]);
    cout<<ans;        
    return 0;
}

```

---

## 作者：Cxs3 (赞：145)

题目链接：https://www.luogu.org/problemnew/show/P3392

---

## 题目分析
数据范围这么小$(n,m<=50)$，果断暴力枚举，代码简单难度低。搜索什么的用不着啦！  

那么问题来了：枚举这么呢？  
先抛张图：

![](https://i.loli.net/2018/08/13/5b716c1d97d52.png)  

我们只要枚举白与蓝、蓝与红的边界（如上图a和b），再统计三个区域里总共有多少格子需要涂改颜色，用一个变量来记录最优的答案（即需要涂改的格子数最少），不断更新，最后输出就OK了qwq.

时间复杂度$O(n^3*m)$（感谢 @万弘 的提醒，之前写错了）.  

---

## 代码实现

照例略去头文件、宏定义、uns
```cpp
int n,m,ans,mi=inf;//mi初始化成一个很大的数
char c[N][N];
int main()
{
	int i,j,k,g;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	  for(j=1;j<=m;j++) cin>>c[i][j];
	for(i=1;i<=n-2;i++)//由于白色下面还有蓝色和红色，所以i（白与蓝的边界）枚举到（n-2）
	  for(j=i+1;j<=n-1;j++)//j（蓝与红的边界）至少要比i大1，同理枚举到（n-1），这样可以减少枚举次数
	  {
	    ans=0;//初始化
        //壮观地枚举三个区域
	    for(k=1;k<=i;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='W') ans++;
	    for(k=i+1;k<=j;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='B') ans++;
	    for(k=j+1;k<=n;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='R') ans++;
        //强迫症（本蒟蒻）看到这些语句表示很开心
	    mi=min(ans,mi);//更新答案
	  }
	cout<<mi<<endl;
	return 0;
}
```

---

---

悄咪咪地安利一下我的博客（逃：   
https://www.luogu.org/blog/Cxs3-blog/  

---

## 作者：万弘 (赞：52)

主要思想**枚举**  
枚举白与蓝，蓝与红的分界  
首先来一个纯暴力，O（n^3*m），不是要求的颜色就++sum  （反正n，m<=50）  
```cpp
int main(){
	scanf("%d%d\n",&n,&m);
	for(int i=1;i<=n;i++)gets(a[i]);
	for(int i=2;i<n;i++){//i指下一种颜色从第i行开始
		for(int j=i+1;j<=n;j++){
			sum=0;
			for(int x=1;x<i;x++)
				for(int y=0;y<m;y++)
					if(a[x][y]!='W')++sum;//计算要涂颜色的次数（白）
			for(int x=i;x<j;x++)
				for(int y=0;y<m;y++)
					if(a[x][y]!='B')++sum;//（红）
			for(int x=j;x<=n;x++)
				for(int y=0;y<m;y++)
					if(a[x][y]!='R')++sum;//（蓝）
			if(sum<ans)ans=sum;//sum与ans的值的更改务必看清楚！！！
		}
	}
	printf("%d",ans);
	return 0;
}```
细心的你应该已经发现了，每一行都被计算多次  
可以预处理下结果，枚举时直接调用  
复杂度降至O（n^3）  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[101][101];
int W[101],B[101],R[101];
int n,m,ans=0x7fffffff,sum;
int main(){
	scanf("%d%d\n",&n,&m);
	for(int i=1;i<=n;i++)gets(a[i]);
	for(int i=1;i<=n;i++)
		for(int j=0;j<m;j++){
			if(a[i][j]!='W')W[i]++;
			if(a[i][j]!='B')B[i]++;
			if(a[i][j]!='R')R[i]++;
		}
	for(int i=2;i<n;i++){
		for(int j=i+1;j<=n;j++){
			sum=0;
			for(int x=1;x<i;x++)sum+=W[x];
			for(int x=i;x<j;x++)sum+=B[x];
			for(int x=j;x<=n;x++)sum+=R[x];
			if(sum<ans)ans=sum;
		}
	}
	printf("%d",ans);
	return 0;
}
```


仔细观察，发现有相邻的多行相加  
考虑用前缀和维护  
复杂度再降至O（min（n\*m，n^2））  （因为读入与预处理n\*m）  
完整代码如下：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[101][101];
int fW,fB,fR,W[101],B[101],R[101];
int n,m,ans=0x7fffffff,sum;
int main(){
	scanf("%d%d\n",&n,&m);
	for(int i=1;i<=n;i++)gets(a[i]);
	for(int i=1;i<=n;i++){
		fW=fB=fR=0;
		for(int j=0;j<m;j++){
			if(a[i][j]!='W')fW++;
			if(a[i][j]!='B')fB++;
			if(a[i][j]!='R')fR++;
		}
		W[i]=W[i-1]+fW;//维护前缀和
		B[i]=B[i-1]+fB;
		R[i]=R[i-1]+fR;
	}
	
	for(int i=2;i<n;i++){
		for(int j=i+1;j<=n;j++){
			sum=W[i-1]-W[0]+B[j-1]-B[i-1]+R[n]-R[j-1];//前缀和的差分
			if(sum<ans)ans=sum;
		}
	}
	printf("%d",ans);
	return 0;
}
```
再要优化，本蒟蒻想不出  


//致管理们：这道题如果数据改成n,m<=5000（或10000）就是真心好题（对于我这种打NOIP普及的蒟蒻）

---

## 作者：nothingness (赞：35)

### 题外话

~~话说涂国旗是违法行为...~~

~~用**破布**来改成国旗，是不是有那么一点儿不妥...~~

~~不过按照题目描述，从上到下条状白蓝红的好像是Russian国旗...~~


------------

### 进入正题

为什么大家都是枚举？难道就不能用dfs做？

设 ${dfs(x,y,t)}$ 为最前面 ${x}$ 行涂白色，最后面 ${y}$ 行涂红色，要花费的最小代价为 ${t}$ ，如果 ${x+y>=n}$ 那么就 ${return}$ ${0}$，~~然后就这么AC了...~~ ${(0ms)}$ 

还有，注意标记，用 ${b[x][y]}$ 标记已经搜索过的情况，否则会TLE




------------

## Code
```cpp
#include "bits/stdc++.h"//万能头文件
#define map my_map//万能头文件里有<map>,所以这行别漏了
using namespace std;

int n,m,map[51][51],ans=99999999,color[51][4],b[51][51];
char ch;

int dfs(int x,int y,int t)
{
	if(x+y>=n)//超出边界
		return 0;
	if(b[x][y])//避免重复搜索，进行剪枝
		return 0;
	b[x][y]=1;
	dfs(x+1,y,t+color[x+1][1]);
	dfs(x,y+1,t+color[n-y][3]);
	if(x>0&&y>0&&x+y<n)
	{
		int k=0;
		for(int i=x+1;i<=n-y;i++)
			k+=color[i][2];
		ans=min(ans,t+k);
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			do
				ch=getchar();
			while(int(ch)<65);
            //用getchar就要这样，否则行末回车会弄得你很头疼
            //还有，数据不能下载，鬼知道行末有几个空格，反正我被坑了
			if(ch=='W')//记得预处理
				map[i][j]=1,color[i][2]++,color[i][3]++;
			if(ch=='B')
				map[i][j]=2,color[i][1]++,color[i][3]++;
			if(ch=='R')
				map[i][j]=3,color[i][1]++,color[i][2]++;
		}
	}
	dfs(0,0,0);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：GavinZheng (赞：26)

********************************************************

# 这道题数据很小（小于50）所以可以用暴力枚举

********************************************************

先做一下预处理，求出每行每个色块的个数

让后两个嵌套的for循环分别模拟白色行数（顶部）和红色行数（底部）

进而求出用这种方法涂制国旗所需次数，再来个很简单的判断，就可以得出最少次数

废话不多说，贴代码

```cpp
#include<iostream>
using namespace std;
char map[60][60];            //map用来存储所有的颜色
int line[60][7]={{0}};            //line用来存储每一行特定色块的个数 
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)    //开始预处理和读入程序 
    {
        for(int h=1;h<=m;h++)
        {
            cin>>map[i][h];
            
            if(map[i][h]=='W')
            {
                line[i][1]++;  //1代表白色 
                
             } 
            if(map[i][h]=='B')
            {
                line[i][2]++;  //2代表蓝色 
                
            }
            if(map[i][h]=='R')
            {
                line[i][3]++;//3代表红色 
                
            }
        } 
    }
        
    int mi;//代表最小需要吐多少块 
    mi=9999999;//注意！！！min在c++中为一个自带函数名，不能当作变量名！！！
    int z;//用z临时储存每次生成的结果 
    z=0;
    for(int i=1;i<=n-2;i++)//i代表最上方（白色）的格子有多少条
    {
        for(int h=1;h<=n-2;h++)//h代表最下方（红色）的格子有多少条
        {
            z=0;
            if(i+h>n-1)//白色，红色格子和超过限度（蓝色格子和不得为0）
            {
                continue;//不满足条件的直接忽略 
            } 
            for(int t=1;t<=i;t++)//计算i行白色要涂多少块 
            {
                z=z+line[t][2]+line[t][3];//红蓝加起来就是白色；
                 
            }
            for(int t=i+1;t<=n-h;t++)//算蓝色 
            {
            
                z=z+line[t][1]+line[t][3]; 
            }
            for(int t=n-h+1;t<=n;t++)
            {
                z=z+line[t][2]+line[t][1]; 
            }
            if(z<mi)
            {
                mi=z;
            }
            z=0;
        } 
    }
    cout<<mi;
    return 0;
}
```


---

## 作者：thwfhk (赞：25)

我愚蠢的用了DP

f[i][0/1/2]表示前i行最后涂..颜色的最小代价


```cpp
//
//  main.cpp
//  luogu9.2.1
//
//  Created by Candy on 9/24/16.
//  Copyright © 2016 Candy. All rights reserved.
//
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int N=55,INF=1e9;
int n,m,w[N][5],f[N][5],ans=INF,last=0;
char s[N];
int main(int argc, const char * argv[]) {
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        for(int j=1;j<=m;j++){
            if(s[j]=='W') w[i][0]++;
            if(s[j]=='B') w[i][1]++;
            if(s[j]=='R') w[i][2]++;
        }
        w[i][0]=m-w[i][0];
        w[i][1]=m-w[i][1];
        w[i][2]=m-w[i][2];
    }
    f[1][0]=w[1][0];f[1][1]=f[1][2]=INF;
    for(int i=2;i<=n-1;i++){
        f[i][0]=f[i-1][0]+w[i][0];
        f[i][1]=min(f[i-1][0],f[i-1][1])+w[i][1];
        f[i][2]=min(f[i-1][1],f[i-1][2])+w[i][2];
    }
    for(int i=1;i<=2;i++) ans=min(ans,f[n-1][i]);
    printf("%d",ans+w[n][2]);
    return 0;
}

```

---

## 作者：Ca1JH (赞：15)

这题思路显而易见：每次枚举三种颜色求最小值

再看看数据范围，很小，可以暴力。

于是没有什么技术可言的代码就诞生了！（其实是我写不了有技术含量的）


### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,sum=9999;//sum要初始化的大点，方便后面比较 
char c[55][55];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++) 
			cin>>c[i][j];
	//输入 
    for(int i=1;i<n-1;i++)
    	for(int j=i+1;j<n;j++)
		{
			ans=0;
    		for(int k=1;k<=i;k++)//注意这里是“k<=i”，因为是一排排枚举，没必要一开始就算整个图 
    			for(int g=1;g<=m;g++) //这是“g<=m”，因为每排都要枚举完 
					if(c[k][g]!='W') ans++;//白色 
    		for(int k=i+1;k<=j;k++)
    			for(int g=1;g<=m;g++) 
					if(c[k][g]!='B') ans++;//蓝色 
    		for(int k=j+1;k<=n;k++)
    			for(int g=1;g<=m;g++) 
					if(c[k][g]!='R') ans++;//红色 
			
			//上面这部分如果数据范围大可以用函数，
			//但这题数据较小(其实是我懒) 
			
			sum=min(sum,ans);//比较，当前的解更优就更新 
		}
    cout<<sum<<endl;
    return 0;//到这就完啦 
}
```


---

## 作者：critnos (赞：15)

~~突然感觉本蒟蒻的代码是枚举中最简单的~~

看了代码你们一定就懂了

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[55][55];
int n,m;
int js(int u,int d,char col)
{
	int sum=0,i,j;
	for(i=u;i<=d;i++)
		for(j=1;j<=m;j++)
			sum+=a[i][j]!=col;//布尔表达式在这种情况下会自动转成int类型，true为1，false为0，如果a[i][j]和col相等则返回0，即不用涂，十分适合压行
	return sum;
}
int main()
{
	int i,j,mn=2500;	
	cin>>n>>m;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			cin>>a[i][j];
	for(i=1;i<=n-2;i++)
		for(j=i+1;j<=n-1;j++)
			mn=min(mn,js(1,i,'W')+js(i+1,j,'B')+js(j+1,n,'R'));
	cout<<mn;
	return 0;		
}
```
时间复杂度O(n^3*m),最坏625万次

解释：

js：不是javascript，是“计**j**i算**s**uan”。作用：计算把第u行到第d行全部涂成col要涂多少次

i：枚举白色，上端：第一行；最下端：第n-2行（因为每种颜色至少一行，后面的两种颜色至少两行）

j：枚举蓝色，上端：第i+1行；最下端：第n-1行

红色不用枚举，因为上下端固定（从第j+1行到第n行）

那么最后涂成合法的国旗就要
```cpp
js(1,i,'W')+js(i+1,j,'B')+js(j+1,n,'R')
```
次

mn并不用设为0x7fffffff，因为这题数据太shui，最多涂50*50次就可以

并不用递推，因为这题数据太shui，连把
```cpp
js(1,i,'W')
```
记下来都不用

~~但是为什么625万次不用卡常呢？~~

~~话说kkksc03真是良心~~

---

## 作者：陈阳蒟蒻 (赞：10)

这题第一眼看到数据：n,m<=50，想到了搜索。但在我想了很久以后，发现不用搜索，直接枚举暴力，评测两次，AC！（第一次忘记输出了）发现好简单，于是点击题解，看有没有相同做法，发现没有后决定发题解、赚贡献


言归正传，开讲思路：


1.输入（没什么好讲的）


2.枚举染白色的长度和染蓝色的长度（剩下的就是染红色的)


每个颜色都得有！！！每个颜色都得有！！！每个颜色都得有！！！（重要的事情说三遍）


3输出ans.


代码如下：


```cpp
include<bits/stdc++.h>//万能头
using namespace std;//输入输出流
int main()//主函数
{
    int n,m,ans=2501;//n,m<=50，就算都要染色的话，要染50*50=2500，这里把ans的初值定为2501
    cin>>n>>m;//输入n和m
    char a[51][51];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];//输入初始国旗情况
        }
    }
    for(int w=1;w<=n-2（这里只能到n-2行，因为每个颜色都得有）;w++)//白色从第1行染到第w行
    {
        int rw=0;//要染rw次白色
        for(int i=1;i<=w;i++)
        {
            for(int j=1;j<=m;j++)//从第一行到第w行都染成白色
            {
                if(a[i][j]!='W')//如果原来不是白色
                {
                    rw++;//染白色次数++
                }
            }
        }
        for(int b=w+1;b<=n-1;b++)//染蓝色从染白色的下一行开始染，最大染到n-1行，因为每个颜色都得有，即w+1行到n-1行
        {
            int rb=0； // 要染rb次蓝色
            for(int i=w+1;i<=b;i++)
            {
                for(int j=1;j<=m;j++)//从第w+1行到第b行都染成蓝色
                {
                    if(a[i][j]!='B')/ /如果原来不是蓝色
                    {
                        rb++;//染蓝色次数++
                    }
                }
            }
rr=0;//要染rr次红色
            for(int i=b+1;i<=n;i++)
            {
                for(int j=1;j<=m;j++)////染蓝色从染蓝色的下一行开始染，最大染到n行，即从第b+1行到第n行都染成红色
                {
                    if(a[i][j]!='R') / /如果原来不是红色
                    {
                        rr++;//染红色次数++
                    }
                }
            }
            ans=min(ans,rw+rb+rr);//ans为ans和这次染白色次数+这次染蓝色次数+这次染红色次数的最小值
        }
    }
    cout<<ans;//输出答案
    return 0;//结束程序
}
```

---

## 作者：Linno (赞：5)

巧妙的方法是比较难想（对我而言），不过数据范围比较小，所以可以为所欲为。
代码思路大概是这样子的：

①想象一个棋盘涂成3片区域，我首先想到了双指针。

②用i,j做pointer，分别记录中间蓝色区域的开始、结束位置。

③如果访问到的棋盘格子的颜色和预期不符，答案加一，最后去最小的答案就行了。
```cpp
#include<iostream>
using namespace std;
int main(){
	int n,m,ans,i,j,w,b,r,wi,bi,ri,tmp; 
    //写在一起会有点乱，解释一下：ans,tmp记录答案用，n，m条件给出
    //i,j是两个pointer，[xx][xxi]是用来对格子进行访问的。
	char a[51][51];
	cin>>n>>m;
	for(int i=0;i<n;i++) cin>>a[i];
	for(int i=1;i<=n-2;i++)
		for(int j=2;j<=n-1;j++){
			tmp=0;  //每次循环的时候三个区域就已经划分好了。
			for(w=0;w<i;w++) for(wi=0;wi<m;wi++) if(a[w][wi]!='W')tmp++;
			for(b=i;b<j;b++) for(bi=0;bi<m;bi++) if(a[b][bi]!='B')tmp++;
			for(r=j;r<n;r++) for(ri=0;ri<m;ri++) if(a[r][ri]!='R')tmp++;  //到这里的时候棋盘到预期所要涂的格子已经统计好了，接下来找到最小值就行
			if(tmp<ans||!ans) ans=tmp;	
		}
	cout<<ans;  //输出结果
	return 0;
}
```


---

## 作者：裘小小 (赞：3)

## P党福利
###### 注意，n，m<=50，可以直接暴力枚举，复杂度O(n^4)
###### 一次就AC
```
var
  i,j,k,l,sum,min,n,m:longint;//min是答案
  a:array[0..51,0..51]of char;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      for j:=1 to m do
        read(a[i,j]);
      readln;
    end;
  min:=maxlongint;
  for i:=1 to n-2 do
    for j:=i+1 to n-1 do
      begin
        sum:=0;
        for k:=1 to i do
          for l:=1 to m do
            if a[k,l]<>'W' then
                             inc(sum);
        for k:=i+1 to j do
          for l:=1 to m do
            if a[k,l]<>'B' then
                             inc(sum);
        for k:=j+1 to n do
          for l:=1 to m do
            if a[k,l]<>'R' then
                             inc(sum);
        if sum<min then
                     min:=sum;
      end;
  write(min);
end.


```


---

## 作者：Lolierl (赞：3)

我~~听从kkk的指示~~手打了一个前缀和优化。

这题o(n^2)的复杂度是稳稳AC的，而且效率也会优化一层循环。

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;

int main()
{
    int n,m;
    cin>>n>>m;
    
    char a[n+1][m+1];
    int sw[n+1],sb[n+1],sr[n+1];
    memset(sw,0,sizeof(sw));
    memset(sb,0,sizeof(sb));
    memset(sr,0,sizeof(sr));//sw[i]表示从1到i中颜色为w的总数，其他两个也是如此。
    
    for(int i=1;i<=n;i++)
    {
        sw[i]=sw[i-1];sb[i]=sb[i-1];sr[i]=sr[i-1];//先拷贝1--i-1的和。
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            if(a[i][j]=='W')sw[i]++;
            if(a[i][j]=='B')sb[i]++;
            if(a[i][j]=='R')sr[i]++;//碰到一个颜色就++
        }
    }
    
    int minv=n\*m;
    for(int i=1;i<=n-2;i++)
        for(int j=i+1;j<=n-1;j++)
            minv=min(minv,n\*m-(sw[i]+(sb[j]-sb[i])+(sr[n]-sr[j]));
        /\*核心部分:i枚举第一个颜色的坐标，j枚举第二种颜色的坐标。
        由题意得i<j<n。
        对于每一个i和j，都要算出每一种颜色需要覆盖的数量，然后与当前minv比较。
        易得覆盖数量=总数量-无需覆盖（即本身就是需要覆盖的颜色）
        以下是我最初写的代码：
        minv=min(minv,fabs(m\*i-sw[i])+fabs(m\*(j-i)-(sb[j]-sb[i]))+fabs(m\*(n-j)-(sr[n]-sr[j])));
        总数量为m\*i,m\*(j-i),m\*(n-j)，而无需覆盖的数量即可通过前缀和得出。
        然后，易得m\*i,m\*(j-i)和m\*(n-j)一定大于sw[i],sb[j]-sb[i]与sr[n]-sr[j]，因此fabs函数就失去了作用，可略去。
        变形为minv=min(minv,m\*i-sw[i]+m\*(j-i)-(sb[j]-sb[i])+m\*(n-j)-(sr[n]-sr[j]));
        合并同类项得minv=min(minv,n\*m-(sw[i]+(sb[j]-sb[i])+(sr[n]-sr[j]));
        也可直接理解：每一次覆盖数为总数量-无需覆盖的数量，即n\*m-(sw[i]+(sb[j]-sb[i])+(sr[n]-sr[j]))\*/
    cout<<minv;//输出
    return 0;
}

---

## 作者：Leap_Frog (赞：2)

# P3392涂国旗（题解）

题目传送门：[P3392涂国旗](https://www.luogu.org/problemnew/show/P3392)

主要思路：前缀和加暴力

复杂度：O(n^2+nm)

主要思路：枚举第一行蓝色与红色纵坐标，则需涂改的方块已知。
求出最小值。

用R,B,W三个数组存储把1~i行都涂成R,B,W的颜色的快数。

则tmp=w[i]+b[j]-b[i]+r[n]-r[j]

贴上代码

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
using namespace std;
ll n,m,ans=2505,w[55],b[55],r[55];
ll sw[55],sb[55],sr[55];
inline ll s(ll i,ll j)
{
	return sw[i]+sb[j]-sb[i]+sr[n]-sr[j];
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		for(ll j=0;j<s.size();j++)
		{
			switch (s[j])
			{
				case 'W':{b[i]++;r[i]++;break;}
				case 'B':{w[i]++;r[i]++;break;}
				case 'R':{w[i]++;b[i]++;break;}
			}
		}
	}
	sw[0]=0;
	sb[0]=0;
	sr[0]=0;
	for(ll i=1;i<=n;i++)
	{
		sw[i]=w[i]+sw[i-1];
		sb[i]=b[i]+sb[i-1];
		sr[i]=r[i]+sr[i-1];
	}
//	for(ll i=1;i<=n;i++) printf("%lld %lld %lld\n",w[i],b[i],r[i]);
//	printf("\n");
//	for(ll i=1;i<=n;i++) printf("%lld %lld %lld\n",sw[i],sb[i],sr[i]);
//	printf("\n");
	for(ll i=1;i<n;i++)
		for(ll j=i+1;j<n;j++)
			ans=min(ans,s(i,j));
//	for(ll i=2;i<n;i++)
//		for(ll j=i+1;j<=n;j++)
//			printf("%lld %lld:%lld\n",i,j,s(i,j));
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：笃行 (赞：2)

一开始想麻烦了，没必要用搜索，直接上枚举就好了。

枚举白色和蓝色的界限以及蓝色和红色的界线，保留最小值minn。

另外在存储的时候用了一个结构体，只存储每一行三种颜色各自的数量。

因为第1行和第n行的颜色是一定的，所以单独求出来第1行和第n行所需要涂的格子数ans，最后输出ans+minn。


        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 0x7f7f7f7f
using namespace std;
int n,m,ans,minn=inf;
string s;
struct flag
{
    int w,r,b;
}d[51];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      {
          cin>>s;
          for(int j=0;j<=m-1;j++)
            {
                if(s[j]=='R') d[i].r++;
                if(s[j]=='B') d[i].b++;
                if(s[j]=='W') d[i].w++;
          }
      }
    ans=(m-d[1].w)+(m-d[n].r);
    int tot=0;
    for(int i=1;i<=n-1;i++)
      {
      for(int j=i+1;j<=n;j++)
        {
            tot=0;
            for(int a=2;a<=i;a++)
              tot+=(m-d[a].w);
            for(int a=i+1;a<=j;a++)
              tot+=(m-d[a].b);
            for(int a=j+1;a<=n-1;a++)
              tot+=(m-d[a].r);
            minn=min(minn,tot);
        }
    }
    cout<<ans+minn;
}
```

---

## 作者：ghj1222 (赞：2)

楼下kkk没有放代码，我放个

枚举两个分界线即可O(n^2)，每次判断的时候全图判断一遍，O(nm)，所以一共O(n^3\*m)，也可以说是O(n^4)

对于n,m<=50的数据，是可以过得

```cpp
#include <iostream>
using namespace std;
int n,m,ans=3000;
char a[51][51];
int pd(int w,int b,int r)//从w到b-1是白色 从b到r-1是蓝色 从r到n是红色
{
    int ans=0;
//    printf("pd %d %d %d ",w,b,r);
    for(int i=w;i<b;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='W')
                ans++;
    for(int i=b;i<r;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='B')
                ans++;
    for(int i=r;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='R')
                ans++;
//    printf("ans=%d\n",ans);
    return ans;
}
int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin >> a[i][j];
    for(int i=2;i<=n-1;i++)//蓝色从i开始
        for(int j=i+1;j<=n;j++)//红色j开始 
            ans=min(ans,pd(1,i,j)); 
    cout << ans << endl;
    return 0;
}#include <iostream>
using namespace std;
int n,m,ans=3000;
char a[51][51];
int pd(int w,int b,int r)
{
    int ans=0;
//    printf("pd %d %d %d ",w,b,r);
    for(int i=w;i<b;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='W')
                ans++;
    for(int i=b;i<r;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='B')
                ans++;
    for(int i=r;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]!='R')
                ans++;
//    printf("ans=%d\n",ans);
    return ans;
}
int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin >> a[i][j];
    for(int i=2;i<=n-1;i++)//蓝色从那里开始 
        for(int j=i+1;j<=n;j++)//红色从那里开始 
            ans=min(ans,pd(1,i,j)); 
    cout << ans << endl;
    return 0;
}
```

---

## 作者：May_Forever (赞：1)

嘛。。。。数据挺小，直接枚举好了→\_→

我是先看每行如果全转为白色要涂几个，蓝色涂几个，红色涂几个，嗯，预处理一下而已，就不用在大循环里枚举每个字符了。

其实挺简单，刚做的时候懵逼地把W，B，R初值放循环里了。。。。

直接上代码w

```cpp
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,i,j,k,ans=3500;
int white[60],blue[60],red[60];
int main(){
    cin>>n>>m;
    for(i=1;i<=n;++i){
        white[i]=0;blue[i]=0;red[i]=0;
        string st;
        cin>>st;
        for(j=0;j<m;++j){
            if(st[j]=='W'){++blue[i];++red[i];}
            if(st[j]=='B'){++white[i];++red[i];}
            if(st[j]=='R'){++white[i];++blue[i];}
        }
    }
    int W=0,B=0,R=0;
    for(i=1;i<n-1;++i){
        W+=white[i];
        for(j=i+1;j<n;++j){
            B+=blue[j];
            for(k=j+1;k<=n;++k)
                R+=red[k];
            ans=min(W+B+R,ans);
            R=0;
        }
        B=0;
    }
    cout<<ans<<endl;
}
```

---

## 作者：1124828077ccj (赞：1)

枚举前i行全填白，i+1到j行全填蓝，j+1到n全填红所需要改变的值，效率O（n^4），懒得优化了

附上代码

```cpp
#include<cstdio>
int n,m,h,ans=1e9;
char s[52][52];
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=0;i<n;i++)
    scanf("%s",s[i]);
    for (int i=0;i<n-2;i++)
    for (int j=i+1;j<n-1;j++)
    {
        h=0;
        for (int k=0;k<=i;k++)
        for (int u=0;u<m;u++)
        if (s[k][u]!='W')h++;//有多少个不是白
        for (int k=i+1;k<=j;k++)
        for (int u=0;u<m;u++)
        if (s[k][u]!='B')h++;//有多少个不是蓝
        for (int k=j+1;k<n;k++)
        for (int u=0;u<m;u++)
        if (s[k][u]!='R')h++;//有多少个不是红
        if (h<ans)ans=h;
    }
    printf("%d",ans);
    return 0;
}
```

---


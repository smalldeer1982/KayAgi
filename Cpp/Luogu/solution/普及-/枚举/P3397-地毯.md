# 地毯

## 题目描述

在 $n\times n$ 的格子上有 $m$ 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

## 说明/提示

### 样例解释

覆盖第一个地毯后：

|$0$|$0$|$0$|$0$|$0$|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$1$|$1$|$0$|$0$|
|$0$|$1$|$1$|$0$|$0$|
|$0$|$0$|$0$|$0$|$0$|
|$0$|$0$|$0$|$0$|$0$|

覆盖第一、二个地毯后：

|$0$|$0$|$0$|$0$|$0$|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$1$|$1$|$0$|$0$|
|$0$|$1$|$2$|$1$|$1$|
|$0$|$0$|$1$|$1$|$1$|
|$0$|$0$|$1$|$1$|$1$|

覆盖所有地毯后：

|$0$|$1$|$1$|$1$|$0$|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$1$|$1$|$0$|$0$|
|$0$|$1$|$2$|$1$|$1$|
|$0$|$0$|$1$|$1$|$1$|
|$0$|$0$|$1$|$1$|$1$|

---

### 数据范围

对于 $20\%$ 的数据，有 $n\le 50$，$m\le 100$。

对于 $100\%$ 的数据，有 $n,m\le 1000$。

## 样例 #1

### 输入

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4```

### 输出

```
0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1```

# 题解

## 作者：阮行止 (赞：365)

n\*n的矩阵，每次给一个子矩阵 区间+1 。最后输出整个矩阵。

优化。用二维线段树或二维树状数组完成上面的操作。

复杂度单次$O(log^2n)$ ，总复杂度 $O(mlog^2n+n^2)$，足以吊打此题。

但是NOIP是不会考二维数据结构的


考虑这个问题的一维版：一个序列，最开始全是 0 .每次区间加 1 ,最后输出每个数。

于是有一种叫做“差分”的奇技淫巧：

假设我们现在要给[2,5]这个区间加一。原来的序列是：

`0 0 0 0 0 0 0 0`

这时候我们在2上面打 +1 标记， 6 上面打 -1 标记。那么现在的序列是：

`0 +1 0 0 0 -1 0`


有什么用呢？从左往右扫描这个数组，记录当前经过的标签之和。这个和就是对应那个数的答案。


这样，对于每个区间加操作，只需要O(1) 的时间打上标记。

最后扫描输出即可。

现在把问题拓展到二维。假设我们要覆盖[(2,2),(5,5)] ，那么标记便可以这样打：

```cpp
0 0 0 0 0 0
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 0 0 0 0 0
```


即在每一行都按照一维的方式来操作

```cpp
int sum=0,i,j;
   for(i=1;i<=n+1;i++)
      for(j=1;j<=n+1;j++)
         sum+=flag[i][j],real[i][j]=sum;
```

之后 real 数组里就存了最后的矩阵。输出即可。

这个算法的复杂度是每次打标记O(n) ，总复杂度是O(mn+n^2)


---

## 作者：老K (赞：171)

首先这题的主要思想很多大佬都讲了：就是差分，但是我的写法和他们的写法又不一样。

本题数据范围为n<=1000,m<=1000。

当n<=1000,m<=1000000甚至m<=10000000怎么办呢？

这时不管是O(n)的修改，还是甚至是$O(log^2(n))$，都是跑不过的。

而我们有一个O(1)修改的做法：二维差分。

设b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]。

这样每次修改b[i][j]相当于对任意$i\le x,j \le y$对a[x][y]做同样的修改

然后每次修改就直接++b[x1][y1],--b[x2+1][y1],--b[x1][y2+1],++b[x2+1][y2+1]即可。

也就是用$O(1)$的复杂度表示$O(n^2)$的覆盖（原话来自下面那篇题解“用O(1)复杂度来表示O(N)的覆盖”）

最后再直接a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j]还原出原序列即可。


/\*
Author: CNYALI\_LK

LANG: C++

PROG: 3397.cpp

\*/
```cpp
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double PI=acos(-1.0);
typedef long long ll;
template<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
int a[1024][1024];
int main(){
#ifdef cnyali_lk
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    int n,m,xa,ya,xb,yb;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        scanf("%d%d%d%d",&xa,&ya,&xb,&yb);
        ++a[xa][ya];
        --a[xb+1][ya];
        --a[xa][yb+1];
        ++a[xb+1][yb+1];
    }
    for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)printf("%d%c",a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1],j==n?'\n':' ');
    return 0;
}

```

---

## 作者：TheAurora (赞：98)

~~这题数据太水，打暴力都能AC~~

我看到很多人都用二维线段树或二维树状数组做这题

其实仔细看一下数据范围就会发现

n<=1000; m<=1000; 

这题打暴力就能过...... 
上代码:
```cpp
#include<iostream>
using namespace std; 
int t[1005][1005];

int main()
{
	int n, m, x1, x2, y1, y2;
	cin >> n >> m;
	for (int k = 1; k <= m; ++k)
	{
		cin >> x1 >> y1 >> x2 >> y2;
		for (int i = x1; i <= x2; ++i)
			for (int j = y1; j <= y2; ++j)
				++t[i][j];
	}//暴力模拟
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
			cout << t[i][j] << ' ';
		cout << endl;
	}
}
```
暴力出奇迹


---

## 作者：KesdiaelKen (赞：76)

看到楼下也有用差分做的，但是似乎代码都有那么一点点长。。。。。

因此，我来发一个精简点的。差分的主要思想其实就是用O(1)复杂度来表示O(N)的覆盖——用B[I]表示A[I]-A[I-1]，所以当覆盖A[L]至A[R]时，只需B[L]++，B[R+1]--即可。最后，再用O(N^2)的复杂度复原A数组，然后输出就行了。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int cf[2000][2000];
int main()
{
    int n,m;
    int x1,y1,x2,y2;
    scanf("%d%d",&n,&m);
    while(m--)//循环的另一种方式（m==0时，会自动跳出，所以循环m遍）
    {
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        for(int i=x1;i<=x2;i++)//每一行进行差分，时间复杂度O(N)
        {
            cf[i][y1]++;
            cf[i][y2+1]--;//差分
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cf[i][j]+=cf[i][j-1];//复原，利用A[I]-A[I-1]=B[I]，可以推得B[I]+A[I-1]=A[I]（因为B[I-1]已被复原为A[I-1]，所以得到此递推公式）
            printf("%d ",cf[i][j]);//复原后输出
        }
        printf("\n");//换行
    }
    return 0;
}
```

---

## 作者：McGrady (赞：36)

看来这里的题解只有题目作者阮行止是正解，其他题解都是欺负数据弱暴力乱搞

他的题解在最下面，大家自己看，时间复杂度O(nm+n^2)

然而我yy出了一个O(m+n^2)的做法，要是m很大，比如10^5,10^6什么的就很有用了

阮行止的题解是差分：

0 0 0 0 0 0

0 +1 0 0 0 -1

0 +1 0 0 0 -1

0 +1 0 0 0 -1

0 +1 0 0 0 -1

0 0 0 0 0 0

（本图复制自阮行止的题解）

然而很明显这还可以再差分一次，对列差分，然后就成了这样：

0 0 0 0 0 0

0 +1 0 0 0 -1

0 0 0 0 0 0

0 0 0 0 0 0

0 0 0 0 0 0

0 -1 0 0 0 +1

这样就可以O(1)修改啦

最后先对每列求前缀和，得到第一个图，再对每行求前缀和，就是答案啦

代码：

```cpp
program rrr(input,output);
var
  f:array[0..1010,0..1010]of longint;
  n,m,i,j,x1,y1,x2,y2:longint;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n,m);
   fillchar(f,sizeof(f),0);
   for i:=1 to m do
      begin
         read(x1,y1,x2,y2);
         inc(f[x1,y1]);dec(f[x2+1,y1]);
         dec(f[x1,y2+1]);inc(f[x2+1,y2+1]);
      end;
   for j:=1 to n do for i:=1 to n do f[i,j]:=f[i,j]+f[i-1,j];
   for i:=1 to n do for j:=1 to n do f[i,j]:=f[i,j]+f[i,j-1];
   for i:=1 to n do begin for j:=1 to n do write(f[i,j],' ');writeln; end;
   //close(input);close(output);
end.
```

---

## 作者：JackcreaM (赞：30)

## 诶？听说有大佬说要差分？

## 有大佬说要short？

### 这可是一道入门题啊喂

### 现在让我给大家一个最ok~~省力~~的题解！！！

####  1184ms /  5.79MB 完全OK！！！

#### ~~为我的不负责任道歉QAQ~~

```
#include<bits/stdc++.h>//万能头
using namespace std;
int a[1001][1001],m,n;//1000000~ 完全没事
int main()
{
	cin>>n>>m;
	 	
	int b,c,d,e;
	int i,j,k;//经典循环变量
	 for(i=1;i<=m;i++)//是有m种而不是n种
	 {
	 	cin>>b>>c>>d>>e;//输入
	 	for(j=b;j<=d;j++)//暴力+
        {
	 		for(k=c;k<=e;k++)//枚举+
			a[j][k]++;//不要打成‘=1’！（我就错过）
		 }
	 }
	 for(i=1;i<=n;i++)//输出~ 不要忘了换行
	 {
	 	for(j=1;j<=n;j++)
	 	cout<<a[i][j]<<" ";
	 	cout<<endl;
	 }

return 0;//ok
}

```

蒟蒻题解，大神勿喷


###### 抄袭可耻！

---

## 作者：Jia_k666 (赞：14)

**~~又是一道大水题~~**




是指两个坐标(x1,y1)和(x2,y2)所构成的矩形

依次+1；


所以额全可以  
每层从x1到x2，而从y1到y2层依次+1；


及用两个for循环解决


```
x1=2 y1=2 x2=3 y2=3
 
 
 x1 x2
  2 3 
0 0 0 0 0 
0 1 1 0 0  第二层y1
0 1 1 0 0  第三层y2
0 0 0 0 0 
0 0 0 0 0

```



 _你好，代码君_ 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define _ =read() //define是个好东西 
using namespace std;


int n,m,a,b,c,d;
int map[1001][1001];//存图 

inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
   return s*w;
}//白给的快读 


int main()
{
	n _,m _;//n _  相当于n=read(),下同 
	
	for(int i=1;i<=m;i++){
		a _,b _,c _,d _;
		
		
		for(int j=a;j<=c;j++)
		for(int k=b;k<=d;k++)
		++map[j][k];//直接从x1到x2,y1到y2,依次加一 
	}
	
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
		cout<<map[i][j]<<" ";//直接输出 
		cout<<endl;//别忘换行 
	}
	
	
	return 0;欢乐AC
}
```


人生第二道题解

---

## 作者：LateNightPoet (赞：10)

二维树状数组水过。

关于矩阵更新+点查询，可以做个实验：

```cpp
铺上样例中的第一个地毯：
0  0  0  0  0
0  1  1  0  0
0  1  1  0  0
0  0  0  0  0
0  0  0  0  0
差分BIT:
0  0  0  0  0
0  1  0 -1  0
0  0  0  0  0
0 -1  0  1  0
0  0  0  0  0
```
可以观察到只是把(x1,y1),(x2+1,y2+1)加一，(x1,y2+1),(x2+1,y1)减一即可。

求(x,y)有几个地毯覆盖只需求(1,1)到(x,y)所有数之和即可。

每次修改和查询的复杂度都是O(logn \* logn)。

代码如下：

```cpp
#include <cstdio>
const int MAXN = 1e4;
short bit[MAXN + 10][MAXN + 10];              //差分树状数组
int n,m;
void add(int x,int y,int v)                   //二维树状数组修改：将(x,y)点+1
{
    for(int i=x;i<=n;i+=i&-i)
        for(int j=y;j<=n;j+=j&-j)
            bit[i][j] += v;
}
int sum(int x,int y)                          //二维树状数组查询；求(1,1)到(x,y)所有数之和
{
    int re = 0;
    for(int i=x;i>0;i-=i&-i)
        for(int j=y;j>0;j-=j&-j)
            re += bit[i][j];
    return re;
}
int main()
{
    scanf("%d%d",&n,&m);
    while(m--) {
        int x1,y1,x2,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        add(x1,y1,1);
        add(x1,y2+1,-1);
        add(x2+1,y1,-1);
        add(x2+1,y2+1,1);                     //读取每一个地毯的信息并做差分操作
    }
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=n;++j) {
            printf("%d ",sum(i,j));           //输出每个点有几个地毯覆盖
        }
        putchar('\n');
    }
}
```

---

## 作者：CW666 (赞：10)

~~这题不行啊~~
居然有NOIP提高day2t1的难度
  
  **肯定是数据给小了**
 
 ∵n³<=1000
 
 ∴n³<=100000000,三个for循环还是撑的住的

上代码


------------
THIS IS CODE：

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[1005][1005];

int n,m,x_1,x_2,y_1,y_2;//定义y1会编译不通过

int main(){

	scanf("%d%d",&n,&m);//scanf比cin 快
    
	for(int i=1;i<=m;++i){//循环
    
		scanf("%d%d%d%d",&x_1,&y_1,&x_2,&y_2);//输入地毯坐标
        
		for(int j=x_1;j<=x_2;++j)
        
			for(int k=y_1;k<=y_2;++k)
            
				a[j][k]++;	//将地毯所在区域覆盖的地方都加一
                
	}
    
	for(int i=1;i<=n;++i){
    
		for(int j=1;j<=n;++j)
        
			printf("%d ",a[i][j]);//快乐的输出
            
		printf("\n");//记得回车	
        
	}
    return 0；
    
}

```
至于二维差分什么的
	[地毯【二维差分】](https://www.cnblogs.com/Roni-i/p/9354177.html)
    请自行查看研究
 _纯暴力_ 
 
 言简意赅

---

## 作者：1jia1 (赞：10)

这道题乍一看，二维线段树！

然而我并不会打，于是打了一个二维分块。

**核心思路：把地图分成√n*√n(=n)个块（因为地图是方形的），每次修改和一维分块差不多，但是边角的修改需要分成四条矩形处理。边角的处理方法有很多，只要注意不会多次加同一个点就好了。**

![luogu](https://cdn.luogu.com.cn/upload/pic/41905.png)

_//给点图片的提示_

```
#include <iostream>
using namespace std;
int n,m,pos[1001],tag[35][35],a[1001][1001],size;
inline void add(int x1,int y1,int x2,int y2)
{
	if(pos[x1]==pos[x2]||pos[y1]==pos[y2])//此时修改的区域都不含完整的块
	{
		for(int i=x1;i<=x2;i++)
		{
			for(int j=y1;j<=y2;j++)
			{
				a[i][j]++;
			}
		}
		return;
	}
	for(int i=pos[x1]+1;i<pos[x2];i++)for(int j=pos[y1]+1;j<pos[y2];j++)tag[i][j]++;//完整的块
	for(int i=x1;i<=(pos[x2]-1)*size;i++)for(int j=y1;j<=pos[y1]*size;j++)a[i][j]++;//左边角，也就是图中红色区域
	for(int i=(pos[x2]-1)*size+1;i<=x2;i++)for(int j=y1;j<=(pos[y2]-1)*size;j++)a[i][j]++;//下边角，也就是图中紫色区域
	for(int i=pos[x1]*size+1;i<=x2;i++)for(int j=(pos[y2]-1)*size+1;j<=y2;j++)a[i][j]++;//右边角，也就是图中黄色区域
	for(int i=x1;i<=pos[x1]*size;i++)for(int j=pos[y1]*size+1;j<=y2;j++)a[i][j]++;//上边角，也就是图中青蓝色区域
	return;
}
int main()
{
	cin>>n>>m;
	for(size=1;size*size<=n;size++);size--;
	for(int i=1;i<=n;i++)pos[i]=(i-1)/size+1;
	for(int i=1,u,v,w,x;i<=m;i++)
	{
		cin>>u>>v>>w>>x;
		add(u,v,w,x);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cout<<a[i][j]+tag[pos[i]][pos[j]]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：引领天下 (赞：6)

嗯……看到楼下们 int 数组敢开到 $10000\times10000$ 的，我大受震撼。

------

下面说我的方法：

注意到数据都不大，为了节省空间，我们使用 short 代替 int！

事实上，对于 $1000\times1000$ 的数组，开 int 空间也是可以接受的。

代码：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
short n,m,a[1001][1001],i,j,x,y,k,l;//为什么非要用int呢？用short多好。
//因为n<=m<=1000，数组开到1000*1000就够了，而且用short也不会越界，因为哪怕1000张地毯都只覆盖在一个点上，那么那个点也仅仅被覆盖了1000次而已。（谁家这么铺地毯啊）
int main(void){
    ios::sync_with_stdio(false);//流优化
    cin>>n>>m;//读入
    while (m--){
        cin>>x>>y>>k>>l;//a[x][y]为地毯左上角，a[k][l]为地毯右下角
        for (i=x-1;i<k;i++)
        for (j=y-1;j<l;j++)a[i][j]++;//从左上到右下，模拟铺地毯的过程，被铺到的地方被铺次数+1
    }
    for (i=0;i<n;i++){
        for (j=0;j<n;j++)cout<<a[i][j]<<' ';//输出
        cout<<endl;//记得输出完了一行就换行
    }
}
```

---

## 作者：sineVI (赞：5)

简单的模拟。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int a[N][N]={0};//C++11特性
int main()
{
	int n,m;//n，m如题意所示
	cin>>n>>m;
	int x1,x2,y1,y2;
	for(int i=0;i<m;i++)
	{
		cin>>x1>>y1>>x2>>y2;
		for(int j=x1;j<=x2;j++)
			for(int k=y1;k<=y2;k++)
				a[j][k]++;//这块模拟的是a[1][1]-a[n][n]
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)cout<<a[i][j]<<" ";
		cout<<endl;
	}//输出
	return 0;//好习惯
}

```


---

## 作者：我醉了 (赞：5)

###  看到dalao们一位位都特厉害，用了差分、二维数据等，作为蒟蒻的我佩服得五体投地（因为我不会……）
###  我的思路较为简单，每输入一组，就用for循环将所在区域加一，最后输出即可
## 但是有个坑
## 这题输入的坐标有可能为小数，于是要用强制转换把坐标换为整型就行了（还要注意有的要向上取整，有的要向下取整）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1010][1010];
double sx,sy,fx,fy;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>sx>>sy>>fx>>fy;
		for(int f=int(ceil(sx));f<=int(floor(fx));f++)
        //ceil()是向上取整，floor()是向下取整，然后再强制转化成整型
		for(int k=int(ceil(sy));k<=int(floor(fy));k++)
		a[f][k]++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：judgejudge (赞：3)

# 最简单！！！！


------------

其实这道题根本不用怕时间复杂度，只需要数组开大一点就好了。。。

下面说一下思路：

 1. **定义一个二维数组和四个分别表示行，列的数组。**
 
 1. **从左上角的行列开始，枚举到右下角的行列，该位置的二维数组+1**
 1. **输出二维数组**
 
 下面奉上AC代码：
 ```cpp
#include <iostream>
using namespace std;
int a[10000][10000];//注：数组开到10000以上，以防爆掉
int row1[10000],col1[10000],row2[10000],col2[10000];
int main(){
	long long i,j,k,n,m,l;
	cin>>n>>m;
	for(i=1;i<=m;i++){
	    cin>>row1[i]>>col1[i]>>row2[i]>>col2[i];
	    for(j=row1[i];j<=row2[i];j++)//开始超级时间复杂度
	    for(l=col1[i];l<=col2[i];l++)
	    a[j][l]++;//统计
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++)cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```
 
 

---

## 作者：飞翔 (赞：2)

把楼下的楼下所述翻译成代码：

```c
#include<cstdio>
int f[1010][1010]={0},sum[1010][1010];
int main()
{
    int n,m,x1,y1,x2,y2;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) {
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        for (int j=x1;j<=x2;j++) { f[j][y1]+=1;f[j][y2+1]-=1; }
    }
    for (int i=1;i<=n;i++) {
      int t=0;
        for (int j=1;j<=n;j++) {
            t+=f[i][j];
            sum[i][j]=t;
        }
    }
    for (int i=1;i<=n;i++) {
        for (int j=1;j<=n;j++) printf("%d ",sum[i][j]);
        printf("\n");
    }
    return 0;
}
```
其实差分真的是一种很好的方法，对许多题目都可以应用，比如校门外的树。

详情见我的[Blog](http://blog.csdn.net/qq\_31640513/article/details/52689405)


---

## 作者：PTC06 (赞：2)

水题一道。

思路：

读入n，m（表示n\*n的格子上有m个地毯）

读入每个地毯的信息。用一个过程work直接模拟，将每一个地毯所覆盖的地方，在一个二维数组a里面增加1，表示多了一个地毯能覆盖这个点。

最后双重循环输出整个a数组。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<set>
#include<algorithm>
using namespace std;
int a[10100][10100];       //这个地方注意一下，前几次都是RE或者MLE
int n,m,i,x1,j,yy1,x2,y2;
void work(int x1,int yy1,int x2,int y2)   //自定义
{
    int i;
    int j;
    for (i=x1;i<=x2;i++)         //覆盖
    {
        for (j=yy1;j<=y2;j++)
        {
            a[i][j]++;        //这个点上增加1.
        }
    }
}
int main()                     
{
    cin>>n>>m;              //输入
    for (i=1;i<=m;i++)
    {
        cin>>x1>>yy1>>x2>>y2;          //输入
        work(x1,yy1,x2,y2);                 //覆盖
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=n;j++) cout<<a[i][j]<<' ';    //输出
        cout<<endl;
    }
}
```

---

## 作者：FCBM71 (赞：1)

同样是为“广大”P党提供一种思路

这道题的数据设计的很善良，最大只有1000x1000，所以可以开一个二维数组然后暴力模拟。根本不用担心TLE和MLE。

先把数组中的所有点都设为0，之后每被覆盖一次+1.

因为每块地毯都告诉了你左上角（x1,y1）和右下角(x2,y2)，所以任何一个横坐标在x1 x2之间，纵坐标在y1 y2之间的点都会被覆盖到。比如说(x1,y1)=(1,1);(x2,y2)=(3,3)因此(2,2)就被覆盖了而(2,4)就没有。因为4并不在1~3之间。因此用两个循环变量，一个从左上角for到左下角，另一个从左上角for到右上角。中间所有点+1.


-----------

代码如下：


```cpp
     var
      a:array[1..1000,1..1000]of longint;
      x1,y1,x2,y2,i,j,t,m,n:longint;
     begin
      read(n,m);
      for t:=1 to m do begin//开始读入每张地毯坐标，读入后立刻计算而不是先存到一个数组里面。这样可以避免再开数组的麻烦
       read(x1,y1,x2,y2);//读入
       for i:=x1 to x2 do
        for j:=y1 to y2 do
         a[i,j]:=a[i,j]+1;//枚举所有被覆盖点，每个点都+1
      end;
      for i:=1 to n do begin
       for j:=1 to n do
        write(a[i,j],' '); //输出
       writeln;
      end;
	end.
```

---

## 作者：AdzearDisjudge (赞：1)

大水题，类似于P1003。

核心思想：

每次读入两个坐标后，直接对地毯范围内所有坐标计数器+1。

纯模拟，复杂度：最坏情况下O（m\*n^2），对于此题蒟蒻数据，毫无问题。

AC代码：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[1001][1001]={0},m,n,i,j,k,x1,x2,y1,y2;
int main()
{
    cin>>n>>m;
    for(k=1;k<=m;++k)
    {
        cin>>x1>>y1>>x2>>y2;
        for(i=x1;i<=x2;++i)
        for(j=y1;j<=y2;++j)
        ++a[i][j];
    }
    for(i=1;i<=n;++i)
    {
        for(j=1;j<n;++j)
        cout<<a[i][j]<<' ';
        cout<<a[i][n]<<endl;
    }
    return 0;
}
```

---

## 作者：ws_pt2 (赞：1)

数据可能有点水，纯模拟都过了

可能就是数据导致这题近似day2T1难度吧

建议还是看楼下复杂度小的算法，这个算法的复杂度是O(m\*n^2+n^2)

下面贴代码，其实也没啥……

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,x1,y1,x2,y2;                                        //题目中的(x1,y1)就是按照(i,j)的顺序来的，我一上来被卡了
int ceng[2333][2333]={0};                              //拼音大法好，表示点(i,j)被铺上的地毯层数
void pu(int a,int b,int c,int d)                          //就是从(a,c)铺地毯到(b,d)
{
    for(int i=a;i<=b;i++)
     for(int j=c;j<=d;j++)
     ceng[i][j]++;
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2); 
        pu(x1,x2,y1,y2);                                     //铺地毯
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        printf("%d ",ceng[i][j]);                           //输出就行了
        printf("\n");
    }
    return 0;
}
```

---


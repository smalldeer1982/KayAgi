# [NOIP 2018 普及组] 龙虎斗

## 题目背景

NOIP2018 普及组 T2

## 题目描述

轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$ 位工兵。下面图 1 为 $n=6$ 的示例： 

![](https://cdn.luogu.com.cn/upload/pic/43224.png)    

轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    

一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。    
下面图 2 为 $n = 6,m = 4$ 的示例，其中红色为龙方，黄色为虎方：

![](https://cdn.luogu.com.cn/upload/pic/43225.png)  

游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 

 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。

## 说明/提示

**样例 1 说明**   

见问题描述中的图 2。   
双方以 $m=4$ 号兵营分界，有 $s_1=5$ 位工兵突然出现在 $p_1=6$ 号兵营。 
龙方的气势为：   
$$2 \times (4-1)+3 \times (4-2)+2 \times (4-3) = 14$$  
虎方的气势为：   
$$2 \times  (5 - 4) + (3 + 5) \times (6 - 4) = 18$$  
当你将手中的 $s_2 = 2$ 位工兵派往 $p_2 = 2$ 号兵营时，龙方的气势变为： 
$$14 + 2 \times  (4 - 2) = 18$$  
此时双方气势相等。 
  
**样例 2 说明**   

双方以 $m = 5$ 号兵营分界，有 $s_1 = 1$ 位工兵突然出现在 $p_1 = 4$ 号兵营。  
龙方的气势为：   
$$1 \times  (5 - 1) + 1 \times  (5 - 2) + 1 \times  (5 - 3) + (1 + 1) \times  (5 - 4) = 11$$  
虎方的气势为：   
$$16 \times  (6 - 5) = 16$$    
当你将手中的 $s_2 = 1$ 位工兵派往 $p_2 = 1$ 号兵营时，龙方的气势变为：    
$$11 + 1 \times  (5 - 1) = 15$$    
此时可以使双方气势的差距最小。

**数据规模与约定**    


$1 < m < n$，$1 \le p_1 \le n$。   
对于 $20\%$ 的数据，$n = 3,m = 2, c_i = 1, s_1,s_2 ≤ 100$。    
另有 $20\%$ 的数据，$n ≤ 10, p_1 = m, c_i = 1, s_1,s_2 ≤ 100$。  
对于 $60\%$ 的数据，$n ≤ 100, c_i = 1, s_1,s_2 ≤ 100$。   
对于 $80\%$ 的数据，$n ≤ 100, c_i,s_1,s_2 ≤ 100$。  
对于 $100\%$ 的数据，$n≤10^5$,$c_i,s_1,s_2≤10^9$。 

## 样例 #1

### 输入

```
6 
2 3 2 3 2 3 
4 6 5 2 ```

### 输出

```
2```

## 样例 #2

### 输入

```
6 
1 1 1 1 1 16 
5 4 1 1```

### 输出

```
1```

# 题解

## 作者：wxy_god (赞：2605)

# 此题解很长，请做好心理准备

首先……这题我在考场上打了一个暴力

当时我觉得这题很简单，就是先输入，p1位置加s1个工兵，然后依次枚举把s2个工兵放在所有的兵营里，每次算一遍双方势力之差，取最小就行了

然而我万万没想到竟然超时了……

详见代码，接下来解释为什么超时

```
#include <cstdio>

int m, p1, s1, s2, a[1000005];
int n;

int compute (int x) {//计算双方势力之差
    int sum1 = 0, sum2 = 0;//计算左边和右边
    a[x] += s2;//先假设位置x加上s2个工兵
    for(int i = 1; i <= n; i ++ ) {
        if(i == m) continue;//m号兵营跳过
        else if(i < m) sum1 += (m - i) * a[i];//m左边的兵营
        else sum2 += (i - m) * a[i];
    }
    a[x] -= s2;//再减去s2个，因为是假设加上了s2个工兵
    if(sum1 >= sum2) return sum1 - sum2; return sum2 - sum1;
}

int main () {
    
    int min = 2e8, where;
    
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++ )
        scanf("%d", &a[i]);
    scanf("%d%d%d%d", &m, &p1, &s1, &s2);
    
    a[p1] += s1;//加上s1个工兵
    
    for(int i = 1; i <= n; i ++ ) {
        int tmp = compute(i);//算一下势力之差
        if(min > tmp) {//如果比之前的最小还小（因为如果势力之差一样小就取编号小的，所以没等号）
            min = tmp;
            where = i;
        }
    }
    
    printf("%d", where);
    
    return 0;
}
```

为什么超时了呢？原因在于每次都算了一遍势力之差。

时间复杂度是$O(n^2)$

啥？那咋办？

就提前算好龙方和虎方的势力之差，每次枚举的时候就直接算一下新的势力之差就行了

别着急，没完呢，别抄这个，~~因为也是错的~~

```
#include <cstdio>

inline int abs (int x, int y) {//相减后再算绝对值
    if(x >= y) return x - y;
    return y - x;
}

int m, p1, s1, s2, a[1000005];
int n;

int main () {
    
    int min = 2e8, where;
    int sum1 = 0, sum2 = 0;//分别提前算好左边和右边的势力
    
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++ ) {
        scanf("%d", &a[i]);
    }
    scanf("%d%d%d%d", &m, &p1, &s1, &s2);
    
    a[p1] += s1;
    
    for(int i = 1; i <= n; i ++ ) {
        if(i < m) sum1 += (m - i) * a[i];
        else if(i > m) sum2 += (i - m) * a[i];//这是预处理，算好左边和右边的势力之差
    }
    
    for(int i = 1; i <= n; i ++ ) {
        if(i < m) sum1 += (m - i) * s2;
        else if(i > m) sum2 += (i - m) * s2;//算出新的双方势力
        int tmp = abs(sum1, sum2);//相减后算绝对值
        if(min > tmp) {
            min = tmp;
            where = i;
        }
        if(i < m) sum1 -= (m - i) * s2;
        else if(i > m) sum2 -= (i - m) * s2;//退栈
    }
    
    printf("%d", where);
    
    return 0;
}
```

满怀激动地提交，结果，后五个点WA了。。。

问题出在哪里？

原因是没开$long$ $long$。。。

因为虽然一个数$int$存的下，但加起来可是会超过$int$的啊！

（估算了下，在$1e18$ ~ $9e18$之间，$long$ $long$刚好够）

~~ 可恶的CCFNOI，竟然卡你$long$ $long$ ~~

于是，开成$long$ $long$就过了：

```
#include <cstdio>

inline long long abs (long long x, long long y) {
    if(x >= y) return x - y;
    return y - x;
}

long long m, p1, s1, s2, a[1000005];
int n;

int main () {
    
    long long min = 1e19, where;
    long long sum1 = 0, sum2 = 0;
    long long t1, t2;
    
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++ ) {
        scanf("%lld", &a[i]);
    }
    scanf("%lld%lld%lld%lld", &m, &p1, &s1, &s2);
    
    a[p1] += s1;
    
    for(int i = 1; i <= n; i ++ ) {
        if(i < m) sum1 += (m - i) * a[i];
        else if(i > m) sum2 += (i - m) * a[i];
    }
    
    for(int i = 1; i <= n; i ++ ) {
        t1 = sum1;
        t2 = sum2;
        if(i < m) t1 += (m - i) * s2;
        else if(i > m) t2 += (i - m) * s2;
        long long tmp = abs(t1, t2);
        if(min > tmp) {
            min = tmp;
            where = i;
        }
    }
    
    printf("%lld", where);
    
    return 0;
}
```

好吧，虽然已经AC了，但是~~本人还是觉得不够快~~，于是想到了**方程法**！

啥？这题还能用方程？

是的！题目不就是求p2吗？我们把p2看成一个未知数，有了方程等式，不就行了？

可是，方程式子从哪来呢？

首先，我们用一个变量$gap$提前算好双方势力之差，大概这么写：

```
    for(int i = 1; i <= n; i ++ ) {
    	gap += (m - i) * a[i];
    }
```

然后让我们看看如何推导出方程式：

$gap+(m-p2)s2=0$

$gap+s2*m-s2*p2=0$

$gap+s2*m=s2*p2$

$gap/s2+m=p2$

这里，除了$p2$以外其他的不都是已知的吗？

对啊！这题不就能用方程解了吗？

没完呢，解出来之后还得用$double$存下来呢！

为什么呢？因为不一定正解真的有势力之差为$0$的兵营

此时就分四种情况：

- 小于等于$1$
- 大于等于$n$
- 大于$1$且小于$n$且是整数
- 大于$1$且小于$n$且是小数

这四种情况对应的操作：

- 输出$1$
- 输出$n$
- 输出$p2$
- 看的把$s2$个工兵放在向下取整和向上取整两个兵营里那个势力之差更小就输出哪个

顺便介绍下三目运算符：

```
部分1?部分2:部分3
```

的意思是如果判断条件```部分1```为真，就执行```部分2```，否则执行```部分3```

然后就是代码

```
#include <bits/stdc++.h>

inline long long read () {
    register long long x = 0 , ch = getchar();
    while( !isdigit(ch)) ch = getchar();
    while( isdigit(ch) ) x = x * 10 + ch - '0' , ch = getchar();
    return x;
}

inline long long abs (long long x) {
    if(x >= 0) return x;
    return -x;
}

long long m, p1, s1, s2, a[1000005], t1, t2;
int n;

int main () {
    
    double where;
    long long gap;
    
    n = read();
    for(int i = 1; i <= n; i ++ ) {
        a[i] = read();
    }
    m = read();
    p1 = read();
    s1 = read();
    s2 = read();//这些都是快读，不用管
    a[p1] += s1;
    
    for(int i = 1; i <= n; i ++ ) {
    	gap += (m - i) * a[i];
    }
    double dgap = gap;
    long long int ans;
    where = m + dgap / s2;//方程的解
    
    if(where >= n) {//大于等于n的情况
    	ans = n;
    }
    else if(where <= 1)//小于等于1的情况
        ans = 1;
    else {
        int iwhere = where;//判断是不是整数
        if(iwhere == where) ans = iwhere;//如果是整数
        else {
            long long ans1 = abs(gap + (m - iwhere ) * s2);
            long long ans2 = abs(gap + (m - iwhere - 1) * s2);//分别计算把s2个工兵放在向下取整和向上取整两个兵营里之后的势力之差
            ans = ans1 <= ans2 ? iwhere : iwhere + 1;//三目运算符
        }
    }
    
    printf("%lld", ans);//答案输出
    
    return 0;
}
```

以上是$O(n)$算法，$7ms$的测试点的时间都是花在输入了

//以上还得感谢[Steven_Meng](https://www.luogu.org/space/show?uid=45109)指出的错误

[评测记录](https://www.luogu.org/record/show?rid=13772274)

# 安慰一下没开$long$ $long$而丢掉20分的大佬

下面是求赞：

# 我的题解可能写得不太好，但你看的这么认真，不点个赞再走吗？

---

## 作者：ykuouzf (赞：1189)

### 扫了一遍题解区，发现各位大佬都写的挺长的，其实本不用那么麻烦。

### 大家都是把兵营的位置枚举一遍，其实是可以直接算出来的。

### 我们假设已算出两边兵营的气势分别为sum1，sum2，（计算气势的过程就不加赘述了，楼上的众位巨佬都已经讲的很明白了）且sum1<sum2,自然要将工兵放在sum1一边，那么我们需保证sum1+工兵的数量*工兵距m号的距离与sum2的差距最小，不妨先假设两式相等。

### 等式中除工兵距m号的距离（其实也就是答案）未知，其余都是已知量，便可以将此量用其他量表示出来，化简可得：工兵距m号的距离=（sum2-sum1）/工兵的数量。

### 由于用此等式算出的距离可能是浮点数，所以我们只需要进行四舍五入，算出离这个值最近的整数，便是答案。

### 还有就是边界值的处理，这个整数必然是在1~n的范围内，只要最后进行一个特判就行了。

### 如果还有什么疑惑就看代码吧，各个步骤都写的很清楚了。

### 史上最短代码献上：
```
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000000],m,p,s,k,sum,ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	scanf("%lld%lld%lld%lld",&m,&p,&s,&k);
	for(int i=1;i<=n;i++) sum+=a[i]*(m-i);
	sum+=s*(m-p);
	ans=m+int(sum*1.0/k+0.5*(sum>0?1:-1)); //这里需注意，如果sum是个负数，四舍五入是要反着加的。
	if(ans>n) ans=n;
	if(ans<1) ans=1;
	printf("%lld",ans);
	return 0;
}
```
## 如此优秀的做法，为什么不点个赞再走呢(ﾉ´▽｀)ﾉ♪

---

## 作者：犇犇犇犇 (赞：144)

### 看了楼上各位大佬的方法，我的想法很简单
### 这个题n只有$n≤10^5$ ~~所以直接暴力就行了~~
首先看到这个题目第一想法是首先把开始的气势算出来，然后再决定把兵力放在那里。

这题它给了你编号为$i$的兵营中起始时的工兵数量 $c_i$  

还给了你一个兵营的气势为：该兵营中的工兵数×该兵营到m号兵营的距离

所以求初始值只需要及个循环就可以搞定了。  
为了表达方便，我用lo表示龙的气势，hu表示虎的气势

```
    long long i;
	cin>>n;
	for(i=1;i<=n;i++)
	    cin>>c[i];
	cin>>m>>p1>>s1>>s2;
	c[p1]+=s1; //天降神兵
	for(i=1;i<m;i++)
	    lo+=c[i]*(m-i); //龙气势
	for(i=m+1;i<=n;i++)
	    hu+=c[i]*(i-m);  //虎气势
```

**下面就是要求把兵放在哪里。  **

其实这里完全没有必要枚举。因为我们只需要把兵加在弱势的一方。  加上的气势$k=$你手里的$s_2$位工兵×到m号兵营的距离。
因为要使气势更为接近，所以可以暂时令我们要加上的气势k为两方气势之差
既$k=abs(lo-hu)$  
所以$p_2$到m号兵营的距离为$k/s_2$  
所以我们实质上只要考虑到m号兵营的距离为$k/s_2$这个点左右两个点的情况就行了。  

举个例子。  

当$lo<hu$时  
$p_2$位于m左侧,$p_2$到m的距离为$(hu-lo)/s2$  
$p2=m-(hu-lo)/s2;$

我们只需要考虑$p_2$这个点与$p_2-1$这个点。  
因为$p_2-1$这个点龙>虎，而$p_2$这个点龙<虎。

```
	if(lo==hu)  //先把等于判掉
	    cout<<m<<endl;
	else if(lo<hu) //龙小于虎
	{
		p2=m-(hu-lo)/s2;
		p2=max(1,p2);
		p2=min(n,p2); //因为p2在1到n之间。否则p2可能会是负的。成功被卡10分钟
		if(p2>1 && (abs(lo+s2*(m-p2+1)-hu)<=abs(hu-lo-s2*(m-p2))) //前一个abs是p2-1这个点，后一个是p2。
		    cout<<p2-1<<endl;
		else cout<<p2<<endl;
        //这里有几个点比较坑.如果存在多个编号同时满足最优，取最小的编号。 所以应该是小于等于。
        //p2=1的时候就没必要做p2-1了。
	}
	else
	{
		p2=m+(lo-hu)/s2;
		p2=max(1,p2);
		p2=min(n,p2);
		if(p2<n && (abs(hu+s2*(p2+1-m)-lo)<abs(hu+s2*(p2-m)-lo)))
		    cout<<p2+1<<endl;
		else cout<<p2<<endl;
	}//同上
```

还有一点。因为气势很大。这里要开**long long!!!**  

~~十年OI一场空，不开long long见祖宗。~~

#### 特别说明
有一组数据
>3 
>1 1 1 
>2 3 1 2

因为这里要找到编号最小的兵营，所以要输出1而不能输出2。

因为我~~作死~~不循环才导致这个点把我给坑了。

只要在我之前代码
```
if(p2>1 && (abs(lo+s2*(m-p2+1)-hu)<=abs(hu-lo-s2*(m-p2))) //前一个abs是p2-1这个点，后一个是p2。
```

加个等于就行了。

但愿NOIP（我）别那么坑（菜）吧QAQ

这道题可谓是坑点满满啊！



------------


最后上修改过的完整代码。上面解释过了，就不加注释了。
```
#include <bits/stdc++.h>
#define max maxx 
#define min minn
#define ll long long
using namespace std;
ll n,c[100005],m,p1,s1,s2,p2;
ll lo,hu;
ll max(ll a,ll b)
{
    if(a>b) return a;
    else return b;
}
ll min(ll a,ll b)
{
    if(a<b) return a;
    else return b;
}
int main()
{
    ll i;
    cin>>n;
    for(i=1;i<=n;i++) 
        cin>>c[i];
    cin>>m>>p1>>s1>>s2;
    c[p1]+=s1;
    for(i=1;i<m;i++)
        lo+=c[i]*(m-i);
    for(i=m+1;i<=n;i++)
        hu+=c[i]*(i-m);
    if(lo==hu)
        cout<<m<<endl;
    else if(lo<hu)
    {
        p2=m-(hu-lo)/s2;
        p2=max(1,p2);
        p2=min(n,p2);
        if(p2>1 && (abs(lo+s2*(m-p2+1)-hu)<=abs(hu-lo-s2*(m-p2))))
            cout<<p2-1<<endl;
        else cout<<p2<<endl;
    } 
    else
    {
        p2=m+(lo-hu)/s2;
        p2=max(1,p2);
        p2=min(n,p2);
        if(p2<n && (abs(hu+s2*(p2+1-m)-lo)<abs(hu+s2*(p2-m)-lo)))
            cout<<p2+1<<endl;
        else cout<<p2<<endl;
    }
    return 0;
}
```







---

## 作者：liyuyao666 (赞：112)

## 这道题~~坑的飞起~~其实不难
好了，首先分析一下，这是一道纯模拟，题目比较混乱，考场光读题就花了将近十几分钟~~什么又龙又虎又势力的~~，读完题后，想到的第一个概念就是杠杆
### - 杠杆普及

先看图

![Luogu](https://p1.ssl.qhmsg.com/t01d1e2afb7bb23cf4b.jpg)
这张图中L1就代表龙势力,L2代表虎实力，由公式F1L1=F2L2再结合题意可知，这题就是杠杆原理！！！
#

因此这道题只要把两边的总气势算出来，算出差值，再用循环把s2放入每一个除m以外的兵营，求出更新后的双方气势差值，如果小于原差值，就将此时气势差值和所在兵营记录下来，最后输出答案就OK了

你真的认为就这么简单，想多了，下面贴上此题的一些坑
#

### - 要用 long long
仔细看这题的数据范围，你会发现int只能过80%的数据，就算你都写对的还是会亏二十分，总之一句话：十年OI一场空，不开long long见祖宗。~~幸亏我考场想到了~~
#

### - 如果存在多个编号同时满足最优，取最小的编号
这是一个很鸡肋又不鸡肋的条件，有了它，就说明第一开始答案就要设定为m，且只有在更新后的双方气势差值小于原最小气势差值（不考虑等于！！！）时才能记录答案。。。真的吗？来看一组数据“3 1 1 1 2 3 1 2”，如果用上述我的做法，这组数据的结果就是2，而答案是1，所以还要考虑在测试兵营小于m且
更新后的双方气势差值小于等于原最小气势差值时也要记录答案（考虑等于！！！）~~我不会告诉你CCF的测试数据没有这一点的~~
#

理清了思路又排除的坑，上代码了！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
class sto
{
    public:
        long long a,b,c;
};
int main()
{
    //freopen("fight.in","r",stdin);
    //freopen("fight.out","w",stdout);
    long long n;
    cin>>n;
    sto peo[n+1];
    for(long long i=1;i<=n;i++)
    {
        cin>>peo[i].a;
    }
    long long m,s1,s2,s3;
    cin>>m>>s1>>s2>>s3;
    peo[s1].a+=s2;
    for(long long i=1;i<=n;i++)
    {
        peo[i].b=abs(i-m);
        peo[i].c=peo[i].a*peo[i].b;
    }
    long long a=0,b=0;
    for(long long i=1;i<m;i++) a+=peo[i].c;
    for(long long i=m+1;i<=n;i++) b+=peo[i].c;
    //cout<<a<<" "<<b<<endl;
    long long ans=m,MIN,set;
    MIN=abs(a-b);
    for(long long i=1;i<m;i++)
    {
        set=abs(a+peo[i].b*s3-b);
        //cout<<set<<" "<<you1<<endl;
        if(set<MIN||(set==MIN&&ans==m))
        {
            MIN=set;
            ans=i;
        }
    }
    //cout<<endl;
    for(long long i=m+1;i<=n;i++)
    {
        set=abs(b+peo[i].b*s3-a);
        //cout<<set<<" "<<you1<<endl;
        if(set<MIN||(set==MIN&&ans==m))
        {
            MIN=set;
            ans=i;
        }
    }
    cout<<ans;
    return 0;
}
```
# 最后求一波赞

---

## 作者：Kdlyh (赞：99)

> 2023/10/25更新latex美化, 中文与英文、数字或公式之间以半角空格隔开

### noip考完了，祝大家取的一个好成绩，期中考rp++；

#### 这道题目读懂题意后就非常简单了：

​	给出 $ n $ 个数，再给出一个 $ m $  位置，定义 $ a $  和 $ b $ ,（$ m $ 不属于 $ a $ 或 $ b $ ）： $ a $ 为 $ 1\sim~m-1 $ 个数每个数用这个数到 $ m $ 的距离乘这个数的积之和， $ b $ 则为  $ m+1\sim n $  中再在这n个每个数用这个数到m的距离乘这个数的积之和，然后在其中一个位置（$ p_1 $）加入了一个数（$ s_1 $），现在再给你一个数 （$ s_2 $），求这个数加在哪一个位置能让 $ a $ 和 $ b $ 的差最小（加上去这个数的计算方法和之前相同）

#### 那么根据题意我们可以总结出这道题的思路了

**注** ：此时的 $a$ 和 $b$ 我们已经加上了 $s1(a||b)$，$abs$ 为绝对值

1. 先把 $s_1$ 加到 $p_1$ 位置上，然后根据题意计算 $a$ 和 $b$ 的值

定义一个 $minn$，用于更新最小差值，在定义一个 $ans$ 用来更新能产生最小差值的位置

1. 因为题目中说 $s_2$ 可以放在 $m$ 上，而 $m$ 上的值不影响 $a$ 和 $b$ 值，所以想让差值最小，可以先考虑一下最小差值为 $abs(a-b)$ 的情况，所以先把 $minn=abs(a-b)$，$ans=m$;

1. **因为题目的中“势力”的定义，我们并不能得出  $a<b$ 则最小差值的位置就在 $a$ 区间内的结论,这个数到 $m$ 点的距离会影响“势力”的值。所以只能暴力枚举从 $1\sim n$ 的每一个位置**

我们拿枚举 $1\sim m-1$（即 $a$ 区间）内的位置举例:

```cpp
for(int i=1;i<m;i++)
{
	if(abs(s2*(m-i)+a-b)<minn){
        minn=abs(s2*(m-i)+a-b);
        ans=i;
    }
}
```

​	**$s2\times(m-i)+a$ 即当 $ s_2 $ 的值插入到 $ i $ 位置时 $ a $ 的值**

​	这样这道题目我们就已经可以代码实现出来了

CODE:

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cmath>
using namespace std;
long long a[100010],s1,s2,sum2,sum1,minn;
int m,n,p1,ans;
inline int read()
{
    int X=0;bool sign=0; char ch=0;
    while(ch<'0'||ch>'9') {sign|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9') {X=(X<<3)+(X<<1)+(ch^48);ch=getchar();}
    return sign?-X:X;
}
inline void print(int x)
{
     if(x<0)
        putchar('-'),x=-x;
     if(x>9)
        print(x/10);
     putchar(x%10+'0');
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    m=read();p1=read();s1=read();s2=read();
    a[p1]+=s1;
    for(int i=1;i<m;i++) //见解题思路第1点
        sum1+=a[i]*(m-i);
    for(int i=m+1;i<=n;i++)
        sum2+=a[i]*(i-m);
    minn=abs(sum1-sum2);ans=m;//见解题思路第2点
    for(int i=1;i<m;i++) //见解题思路第3点
        if(abs(sum1+s2*(m-i)-sum2)<minn) {
            minn=abs(sum1+s2*(m-i)-sum2);
            ans=i;   
        }
    for(int i=m+1;i<=n;i++) 
        if(abs(sum2+s2*(i-m)-sum1)<minn){
            minn=abs(sum2+s2*(i-m)-sum1);
            ans=i;
        } 
    print(ans);
}
```

再说些有关自己，有关这道题的事吧，这道题考场上花了近一个小时做了出来，就在要删掉 freopen 的注释时电脑异常关机，然后我第二题的代码就是第三题的了。申诉延时也因为认为是我个人原因而被拒绝，辛辛苦苦准备了一年的成果也就自然付之东流。我写这篇题解，也是为了证明我即使没有那道题的分数，也是有实力做出那道题的。

@洪以濠 @哲学濠 感谢你们对我的关心和开导。感谢洛谷给 oier 们提供了这么优秀的平台:D

---

## 作者：yedalong (赞：3)

这道题目看似挺复杂，但实际上其实很简单，单纯的模拟而已。

## 题意

给你一条线段，线段上有 $n$ 个点，另有一个分割点 $m$，它将线段分为了“龙” 和“虎” 两个势力，位于 $m$ 上的点那个势力都不算。每个点代表一个军营，第 $i$ 个军营上有 $c_i$ 个工兵，一个军营的气势计算方式为：该兵营中的工兵数 $\times$ 该兵营到 $m$ 号兵营的距离；参与游戏一方的势力定义为：属于这一方所有兵营的气势之和。现在在编号为 $p_1$ 的军营上多了 $s_1$ 个工兵，你手上还有 $s_2$ 个工兵，你可以将这些工兵安排在任意军营，要求两方势力差距最小，并输出最小差距。

## 思路

输入结束后，我们可先在 $c_{p_1}$ 上加上 $s_1$。接着我们可以先求出最开始两方的势力，接着在这 $n$ 点上再尝试放置，依次求出差距，再求最小值即可。~~怎样？是不是很简单？~~\
注意，要记得开 long long！

## AC code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//开long long 
int n,c[100005],m,p1,s1,s2,a,b,ans=1e9,flag,tmp1,tmp2;//ans表示最小差距，flag代表要放在那个军营，a和b表示初始两方势力的气势 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i = 1;i<=n;i++) cin>>c[i];
	cin>>m>>p1>>s1>>s2;
	c[p1]+=s1;
	for(int i = 1;i<m;i++) a+=c[i]*(m-i);//预处理"龙"的气势 
	for(int i = m+1;i<=n;i++) b+=c[i]*(i-m);//预处理"虎"的气势
	for(int i = 1;i<=n;i++){
		tmp1=a,tmp2=b;//这玩意儿是临时的！ 
		if(i<m) tmp1+=(m-i)*s2;//如果当前在"龙"势力，加上这s2个工兵能贡献的气势 
		if(i>m) tmp2+=(i-m)*s2;//如果当前在"虎"势力，加上这s2个工兵能贡献的气势 
		if(ans>abs(tmp1-tmp2)) ans=abs(tmp1-tmp2),flag=i;//如果能更新最小值，把当前军营的编号记录下来 
	}
	cout<<flag;//输出所记录的军营编号
	return 0;//好习惯 
}
```

---

## 作者：hhztl (赞：2)

一道很水的题。

明显不管 $p2$ 位于什么位置，双方的原气势值都不会受到影响。所以可以考虑提前预处理出龙虎双方的气势值，然后枚举 $p2$，计算出 $p2$ 确定后的气势值后，求所有方案中的双方气势差的最小值所对应的 $p2$。

预处理时间复杂度 $\mathcal{O}(n)$，枚举 $p2$ 的时间复杂度也为 $\mathcal{O}(n)$，总时间复杂度 $\mathcal{O}(n)$。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100010],p1,s1,s2,f[100010],sum1,sum2,minn=INT_MAX,p2,t;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>m>>p1>>s1>>s2;
	a[p1]+=s1;//可以直接把s1个工兵放入第p1个兵营
	for(int i=1;i<=n;i++){//预处理
		if(i<m)sum1+=a[i]*abs(i-m);//如果该兵营属于龙方，龙方气势值增加
		else sum2+=a[i]*abs(i-m);//否则虎方气势值增加
		f[i]=s2*abs(i-m);//预处理出把s2个工兵放入第i个兵营会增加的气势值
	}for(int i=1;i<=n;i++){//枚举p2
		if(i<m)t=abs(sum1+f[i]-sum2);//如果该兵营属于龙方，t为龙方气势加上f[i]后与虎方气势的差
		else if(i>m)t=abs(sum2+f[i]-sum1);//否则，t为虎方气势加上f[i]后与龙方气势的差
		else t=abs(sum1-sum2);//不然s2不属于任何势力，t为双方气势差
		if(t<minn){//如果当前方案的结果更优
			minn=t;//更新最小值
			p2=i;//记录答案
		}
	}cout<<p2;
}
```

---

## 作者：_H17_ (赞：2)

## 题目分析

简单小模拟，首先算出双方士气值。

然后处理 $p_1,s_1$（就是加入到属于的一方，如果都不属于可以忽略），因为这个是恒定的。

然后 $p_2$ 放在哪里暴力枚举一下就行了。

---

## 作者：xzh15960292751 (赞：1)

[题目传送门](luogu.com.cn/problem/P5016)

## 题目大意

题目不难理解，先给了你一个 $n$ 表示兵营的数量。\
后面又给了每个兵营里起始的工兵数量。\
以及一个兵营编号 $m$ 表示中立兵营的编号。\
还有三个数 $p_1,s_1,s_2$ 分别表示天降神兵的位置，数量，第二次派兵的数量。\
让你求你手上的兵放在哪个位置可以使两个兵营中的势力差更小。

## 做法

首先，我们可以提前求一遍实力差。\
以此减小时间复杂度。\
如果是暴力的算法，每一次都要求一遍势力差，放在这一题的数据就过不了。\
所以提前求完之后，更新一下天降神兵后的势力差。\
此时，用到一个变量 $k$ 用于记录你手上的兵放在哪个兵营比较合适。\
这里有个坑，$k$ 的初始值应为 $1$，否则第二个点就会错。\
因为如果初始化为 $0$，当没有找到任何一个点的势力差小于之前统计过的势力差，就会输出 $0$，但很明显，此时应输出 $1$。\
这样只要更新一遍，就可以大大减小时间复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum, s1, s2;
int c[100010];
int n, m, p1, p2, tmp;
int main() {
	// 优化
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	// 先照常输入
	cin >> n;
	for(int i=1; i<=n; i++) cin >> c[i];
	cin >> m >> p1 >> s1 >> s2;
	// 龙虎势力的差距
	// 原理：当 i < m  时  sum里的就是龙势力的总势力
	//       当 i == m 时  sum里没有改变  因为 m - i = 0
	//       当 i > m  时  sum每一次加的都是负数 算完之后就可以求出龙虎势力差
	for(int i=1; i<=n; i++) sum += ((m - i) * c[i]);
	// 求出p1兵营的势力
	sum += (m - p1) * s1;
	// 先算势力差
	long long cha = abs(sum + (m - 1) * s2);
	// k表示放到哪一个兵营
	int k = 1;
	// 后面每一次都算一次势力差
	for(int i=2; i<=n; i++) {
		// 继续算势力差
		tmp = abs(sum + ((m - i) * s2));
		// tmp 与 cha 比较 更新最小值
		if(tmp < cha) {
			// 取最小值
			cha = tmp;
			// 调整编号
			k = i;
		}
	}
	// 输出编号
	cout << k << '\n';
	return 0;
}
```

恭喜你，这一份是不对的。\
你只要认真算后，就可以发现，要开 `long long`。

## AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum, s1, s2;
long long c[100010];
long long n, m, p1, p2, tmp;
int main() {
	// 优化
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	// 先照常输入
	cin >> n;
	for(int i=1; i<=n; i++) cin >> c[i];
	cin >> m >> p1 >> s1 >> s2;
	// 龙虎势力的差距
	// 原理：当 i < m  时  sum里的就是龙势力的总势力
	//       当 i == m 时  sum里没有改变  因为 m - i = 0
	//       当 i > m  时  sum每一次加的都是负数 算完之后就可以求出龙虎势力差
	for(int i=1; i<=n; i++) sum += ((m - i) * c[i]);
	// 求出p1兵营的势力
	sum += (m - p1) * s1;
	// 先算势力差
	long long cha = abs(sum + (m - 1) * s2);
	// k表示放到哪一个兵营
	int k = 1;
	// 后面每一次都算一次势力差
	for(int i=2; i<=n; i++) {
		// 继续算势力差
		tmp = abs(sum + ((m - i) * s2));
		// tmp 与 cha 比较 更新最小值
		if(tmp < cha) {
			// 取最小值
			cha = tmp;
			// 调整编号
			k = i;
		}
	}
	// 输出编号
	cout << k << '\n';
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

小模拟。

先算出两阵营的气势，再单独计算 $p_1$ 位置的气势，循环枚举 $p_2$ 的位置，找到第一个能使士气差最小的位置。

要注意士气差要加绝对值。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, c[100005], m, p, s1, s2, mi=1e9, ans, sum1, sum2, a, b;
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i) 
		cin >> c[i];
	cin >> m >> p >> s1 >> s2;
	for (int i=1; i<m; ++i)
		sum1+=c[i]*(m-i);
	for (int i=m+1; i<=n; ++i)
		sum2+=c[i]*(i-m);
	if (p<m) 
		sum1+=s1*(m-p);
	else if (p>m) 
		sum2+=s1*(p-m);
	for (int i=1; i<=n; ++i) {
		a=sum1, b=sum2;
		if (i<m) 
			a+=s2*(m-i);
		else if (i>m)
			b+=s2*(i-m);
		if (abs(a-b)<mi)
			mi=abs(a-b),
			ans=i;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：run_away (赞：1)

## 题意

一条直线上有 $n$ 个兵营，相邻的两个点距离为 $1$，第 $i$ 个点上初始有 $c_i$ 个工兵。

第 $m$ 个兵营左侧为 $1$ 号势力，右侧为 $2$ 号势力，它本身不属于任何势力。

定义一个兵营的“气势”为它的工兵数乘它与 $m$ 号兵营的距离。

一个势力的“气势和”为每个点的“气势”之和。

有 $s_1$ 个工兵出现在 $p$ 号兵营，求把 $s_2$ 个工兵放在哪一个兵营能让两个势力的“气势和”差距最小。

## 分析

先把两个势力的“气势和”计算好，然后枚举放在哪一个兵营。

记录最小值和产生最小值的位置，若当前值严格小于最小值就更新。

## Code

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
typedef __int128_t int128;
using namespace std;
// static char buf[100],*p1=buf,*p2=buf,obuf[100],*p3=obuf;
// #define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++
// #define putchar(x) (p3-obuf<100)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
mt19937_64 rnd(chrono::system_clock::now().time_since_epoch().count());
#define dbg(x) cout<<#x<<": "<<x<<"\n"
#define usetime() printf("time: %.3lfs\n",clock()*1.0/CLOCKS_PER_SEC)
inline ll read(){ll x=0,f=1;char c=getchar();while(c<48||c>57){if(c==45)f=0;c=getchar();}while(c>47&&c<58)x=(x<<3)+(x<<1)+(c^48),c=getchar();return f?x:-x;}
inline void write(ll x){if(!x){putchar(48);putchar('\n');return;}short top=0,s[40];if(x<0)x=-x,putchar(45);while(x)s[top++]=x%10^48,x/=10;while(top--)putchar(s[top]);putchar('\n');}
namespace tobe{
    const ll maxn=2e5+5,mod=998244353;
	ll n,c[maxn],m,p,s1,s2;
    inline void mian(){
		n=read();
		for(ll i=1;i<=n;++i)c[i]=read();
		m=read(),p=read(),s1=read(),s2=read();
		c[p]+=s1;
		ll cnt1=0,cnt2=0;
		for(ll i=1;i<m;++i)cnt1+=c[i]*(m-i);
		for(ll i=m+1;i<=n;++i)cnt2+=c[i]*(i-m);
		ll ans=0,mn=INT_MAX;
		for(ll i=1;i<=n;++i){
			if(i<m){
				ll now=abs(cnt1+s2*(m-i)-cnt2);
				if(mn>now)mn=now,ans=i;
			}
			else if(i>m){
				ll now=abs(cnt2+s2*(i-m)-cnt1);
				if(mn>now)mn=now,ans=i;
			}
			else{
				ll now=abs(cnt1-cnt2);
				if(mn>now)mn=now,ans=i;
			}
		}write(ans);
    }
}
signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ll t=1;
    while(t--)tobe::mian();
    // fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法为模拟，枚举。\
我们可以先把左右两边的气势先算出来，然后枚举每个兵营的编号 $i$，先让它们兵的数量增加 $s_2$，此时我们再重新算一下左右两边的气势，然后取最小值并记录编号。由于我们刚刚多放了几个兵，所以最后我们还要减去这些兵和气势值。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int a[maxn];
int b[maxn];
signed main()
{
	ios::sync_with_stdio(0);//同步流，可忽略
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int m,p1,s1,s2;
	cin>>m>>p1>>s1>>s2;
	a[p1]+=s1;//首先就会多s1个兵
	int ans1=0,ans2=0;
	for(int i=1;i<m;i++) ans1+=a[i]*(m-i);//计算气势
	for(int i=m+1;i<=n;i++) ans2+=a[i]*(i-m);
	int mini=INT_MAX,x=0;
	for(int j=1;j<=n;j++)
	{
		a[j]+=s2;//兵的数量增加s2
		if(j<m) ans1+=s2*(m-j);//算气势，可以用abs函数代替
		if(j>m) ans2+=s2*(j-m);
		if(mini>abs(ans1-ans2))//如果气势差更小
		{
			mini=abs(ans1-ans2);//更新差
			x=j;//记录兵营的编号
		}
		a[j]-=s2;//原来是没有多的s2个兵营的，要减去
    //气势值也要减少哦！
		if(j<m) ans1-=s2*(m-j);
		if(j>m) ans2-=s2*(j-m);
	}
	cout<<x;
	return 0;
}
```

---

## 作者：glass_goldfish (赞：0)

拿到题目，首先想到的自然是直接枚举把 $s_2$ 名工兵放在 $1\sim n$ 号兵营，然后分别计算气势之差，最后取最小值并求解。但是，这样的时间复杂度为 $O(n^2)$，无法通过本题。

考虑优化。这个算法的瓶颈在于每一次都计算了重复的内容（原本气势），直接预先算出来，然后在枚举的时候加上对某一方增长的气势（或者都没有增长），即可通过本题。时间复杂度为 $O(n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,a[300001],m,p1,s1,s2;
int ans1,ans2,mi=1e18,ms;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cin>>m>>p1>>s1>>s2;
	a[p1]+=s1;//天降神兵
	for(int i=1;i<m;i++)
		ans1+=(a[i]*abs(i-m));//预处理
	for(int i=m+1;i<=n;i++)
		ans2+=(a[i]*abs(i-m));//预处理
	for(int i=1;i<=m;i++){
		int k=ans1+s2*abs(i-m);
		if(mi>abs(ans2-k)){
			mi=abs(ans2-k);
			ms=i;
		}
	}//计算
	for(int i=m+1;i<=n;i++){
		int k=ans2+s2*abs(i-m);
		if(mi>abs(ans1-k)){
			mi=abs(ans1-k);
			ms=i;
		}
	}//计算
	cout<<ms;
	return 0;
}
```

---

## 作者：Lan_yan (赞：0)

## 思路

明显的小暴力做法。

可以两重循环来计算工兵在每个兵营里双方的气势。

时间复杂度简单 $N^2$，在 $N \le 10^5$ 的情况下 TLE 是常有的事。

这时就要用到一个类似[换根 DP](https://oi-wiki.org/dp/tree/) 的思想。

注意到在工兵降临之前双方总气势不变，所以可以预处理双方各自的气势，这里同时将 $s1$ 加入 $p$ 兵营方便计算。

### 代码

```cpp
a[p]+=s1;
for(i=1;i<=n;i++)
	b[i]=abs(m-i)*a[i];
for(i=1;i<m;i++)
	tig+=b[i];
for(i=m+1;i<=n;i++)
	dra+=b[i];//计算双方总气势 
```

然后就可以愉快统计 $s1$ 名工兵在各个军营里导致的双方气势差了。

### 代码

```cpp
for(i=1;i<m;i++)//比较工兵在龙方时的气势 
{
	if(wer>abs(tig+abs(m-i)*s2-dra))
	{
		ans=i;
		wer=abs(tig+abs(m-i)*s2-dra);
	}
}
for(i=m+1;i<=n;i++)//比较工兵在虎方时的气势 
{
	if(wer>abs(dra+abs(m-i)*s2-tig))
	{
		ans=i;
		wer=abs(dra+abs(m-i)*s2-tig);
	}
}
```
## 提示

在计算势力差时谨慎操作。

以及总势力在极端情况下会到 $10^{14}$，注意安全。

---

## 作者：sherry_lover (赞：0)

# P5016 [NOIP2018 普及组] 龙虎斗 题解

[题目传送门](https://www.luogu.com.cn/problem/P5016)

## 思路

考虑枚举将这 $s_2$ 位工兵放置在哪个兵营，然后算出当前的气势差距，取最小值即可。

但这样是 $O(n^2)$ 的，考虑优化。

发现不需要每次都从 $1$ 到 $n$ 算一遍每个兵营的气势，只需要先预处理最开始的气势，然后加上 $s_2$ 个工兵所带来的气势即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,po,so,st,idx;
long long minn = 0x3f3f3f3f3f3f3f3f;
struct by{
	long long r,j;
}a[100005];
int main()
{
	cin >> n;
	for(int i = 1;i <= n;i++) cin >> a[i].r;
	cin >> m >> po >> so >> st;
	for(int i = 1;i <= n;i++) a[i].j = abs(m-i);
	a[po].r += so;
	long long l = 0,h = 0,lo,ho;
	for(int i = 1;i <= m;i++) l += a[i].r * a[i].j;
	for(int i = m;i <= n;i++) h += a[i].r * a[i].j;
	for(int i = 1;i <= n;i++)
	{
		lo = l;
		ho = h;
		if(i < m) lo += st*a[i].j;
		else ho += st*a[i].j;
		if(abs(lo-ho) < minn)
		{
			minn = abs(lo-ho);
			idx = i;
		}
	}
	cout << idx;
	return 0;
}

```

---

## 作者：Lfz312g (赞：0)

# Solution
## 题目分析
首先显然有暴力做法。  
遍历每一个兵营，计算出将 $s_2$ 名士兵派往这个兵营后，双方的势力大小，取相差最小的一次即可。  
时间复杂度：$O(n^2)$。  
预计得分：80 pts。  
通过暴力做法，我们已经获得了相当可观的分数，但想获得更高的分数，需要对其加以优化。   
考虑到，上述暴力算法的瓶颈在于，每一次遍历兵营，都需要重新求出势力大小，实际上是不用的。  
预处理双方的势力之和，用两个变量 $sum1$ 和 $sum2$ 记录。  
遍历每一个军营 $k$，此时龙方的总势力是 $sum1+s_2 \times \max(m-k,0)$，虎方的总势力是 $sum2 ＋ s_2 \times \max(k-m,0)$，最后同暴力做法取相差最小的一次即可。  
时间复杂度：$O(n)$。   
预计得分: 100 pts。  
坑点：需要开 long long。
## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100005],n,m,p,s,k,sum1,sum2;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	cin>>m>>p>>s>>k;
	a[p]+=s;
	for (int i=1;i<m;i++)
	{
		sum1+=a[i]*(m-i);
	}
	for (int i=m+1;i<=n;i++) 
	{
		sum2+=a[i]*(i-m);
	}
	long long minn=1e18,ans=-1;
	long long na,nb;
	for (int i=1;i<=n;i++)
	{
		na=sum1,nb=sum2;
		if (i<m) na+=k*(m-i);
		else if (i>m) nb+=k*(i-m);
		if (abs(na-nb)<minn)
		{
			minn=abs(na-nb);
			ans=i;
		}
	}
	cout<<ans;
	return 0;
}
```

---


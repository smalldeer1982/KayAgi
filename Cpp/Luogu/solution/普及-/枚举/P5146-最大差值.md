# 最大差值

## 题目描述

HKE 最近热衷于研究序列，有一次他发现了一个有趣的问题：

对于一个序列 $A_1,A_2,\cdots,A_n$，找出两个数 $i,j$（$1\le i<j\le n$），使得 $A_j-A_i$ 最大。

现在给出这个序列，请找出 $A_j-A_i$ 的最大值。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$n\le1000$；
- 对于 $70\%$ 的数据，$n\le10^5$；
- 对于 $100\%$ 的数据：$2\le n\le 10^6$，$A_i$ 在 int 范围内。

## 样例 #1

### 输入

```
10
1
3
4
6
7
9
10
1
2
9

```

### 输出

```
9```

# 题解

## 作者：雨伞CKY (赞：19)

# 题目分析
不难想到枚举 $i,j$ 这一暴力做法，这种做法的伪代码如下。

$$
\begin{array}{ll}
1 & \textbf{for }i\gets 1\textbf{ to }n-1\\
2 & \qquad \textbf{for }j\gets i+1\textbf{ to }n\\
3 & \qquad\qquad\textbf{if }A[j]-A[i]\gt ans\\
4 & \qquad\qquad\qquad ans\gets A[j]-A[i]
\end{array}
$$

这种做法很容易编写，但它的时间复杂度为 $O(n^{2})$。在 $2\leq n\leq 10^{6}$ 范围内，这种做法会严重超时。

我们需要找一种更快的方法才能通过本题。实际上，你不需要进行如此多次计算。你只需要在读入第 $k$ 个数时，更新此时 $A_{j}-A_{i}$ 的最大值（$A_{j}-minn_{k-1}$）和前 $k$ 个数的最小值 $minn_{k}$ 和，最后输出 $A_{j}-A_{i}$ 的最大值即可。这种做法的伪代码如下。

$$
\begin{array}{ll}
1 & minn\gets A[1]\\
2 & \textbf{for }i\gets 2\textbf{ to }n\\
3 & \qquad\textbf{if }A[i]-minn\gt ans\\
4 & \qquad\qquad ans\gets A[i]-minn\\
5 & \qquad \textbf{if }A[i]\lt minn\\
6 & \qquad\qquad minn\gets A[i]
\end{array}
$$

# 代码
```cpp
#include <climits>
#include <iostream>
using namespace std;

int n;
long long int tmp,ans = LLONG_MIN,minn;

int main() {
    cin >> n >> minn;
    for (int i = 2;i <= n;i++){
        cin >> tmp;
        if (tmp - minn > ans) ans = tmp - minn;
        if (tmp < minn) minn = tmp;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Kobe303 (赞：10)

# 思路分析：

首先可以很容易想到一个朴素做法，枚举两个下标 $i$,$j$（$1$ $ \leq$ $i$ $<$ $j$ $\leq$ $n$），暴力更新答案。

这样的时间复杂度是 $O(n^2)$。

那么我们看到 $n$ $\leq$ $10^6$，这绝对是我们不能接受的。

观察式子结构，考虑优化。

对于一个下标 $j$, 那么 $a_j$ 是固定的，那么求 $a_j - a_i$ 的最大值就转换为求 $a_i$ 的最小值（$1$ $\leq$ $i$ $<$ $j$）。

所以只要在读入的过程中更新一下 $a_i$ 的最小值就好了。

这样可以将时间复杂度优化为 $O(n)$。

## 一个小细节：

$a$ 数组的范围在 int 内，那么差值可能会爆 int。

所以要开 long long。

# Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define reg register 
#define il inline
int n;
ll minx;
ll ans = -1e15;
int main()
{
	scanf("%d%lld", &n, &minx);
	for (int i = 2; i <= n; ++i) {
		ll x; scanf("%lld", &x);
		if (ans < x - minx) ans = x - minx;
		if (x < minx) minx = x;
	}
	printf("%lld", ans);
	return 0;
}
```

如果我没记错的话，这个好像叫**同行优化**来着。

---

## 作者：MCH_Satrimiten (赞：9)

建议先阅读[题面](https://www.luogu.com.cn/problem/P5146)再看题解。
---

如果要使 $a[j]$ - $a[i]$ 的商最大，那么 $a[j]$ 就一定是这个序列的最大值 , $a[i]$ 就一定是这个序列的最小值。

所以 $j$ 是**序列中最大值的下标** ， $i$ 是**序列中最小值的下标**。

因为 $1$ $≤$ $i$ $<$ $j$ $≤$ $n$ , 所以我首先看这题的时候，我想的是这样的：

```cpp
For i 1-(n-1)//枚举最小值下标
	For j (i+1)-n//枚举最大值下标
```

然而，翻了数据一看，，，

什么？？ $2$ $≤$ $n$ $≤$ $10^6$ 

我当场就炸了，如果这样的话，就只能用 $O(n)$ 的方法。。

那么，就可以不求 $a[j]$ 的最大值，在求 $a[i]$ 的最小值的时候，直接将 $a[j]$ $-$ $a[i]$ 的最大值求出来。

像这样：

```cpp
x=max(x,d-y);//(a[j]-a[i])max
y=min(d,y);//d是输入的序列中的一个值
```

所以说，只要有了这一步，就完美了。。QwQ

### 完整代码奉上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	long long x=-1e10,y=1e10;
	cin>>n;
	for(int i=1;i<=n;i++){
	    long long d;
	    cin>>d;
	    x=max(x,d-y);
	    y=min(d,y);
	}
	cout<<x;
	return 0;
}
```

---

## 作者：Happy_Every_day (赞：4)

### 一、题意及数据范围。

这题的题意很简单，就是在给定序列中找到 $\max\limits_{1\le i<j\le n}\{a_j-a_i\}$。

数据范围最大是 $2\le n\le 10^6$。

### 二、思路。

这题的数据范围很大，如果暴力找每一对 $(a_i,a_j)$ 的话，肯定超时。

为什么会超时呢？本题是因为我们做了太多重复的操作，所以导致了超时。

想一想，每次找到一个 $a_j$，因为要 $\max\limits_{1\le i<j\le n}\{a_j-a_i\}$，所以 $a_i$ 要越小越好，那么我们就要在区间 $[1,j-1]$ 这个区间里去找一个**最小的** $a_i$，那么每一个 $a_j$ 都要从 $a_1,a_2,\cdots,a_{j-1}$ 找一个最小的，重复操作实在是太多了，那我们怎么优化呢？

可以想到一个叫做**前缀最小值**的优化方法，我们设 $f_i$ 表示区间 $[1,i]$ 中的最小值，根据动态规划的思想，可以得出：$f_i=\min\{f_{i-1},a_i\}$。

既然得出了区间 $[1,i]$ 中的最小值，那我们是不是只要枚举 $a_j$ 就可以啦！直接把时间复杂度从 $\Theta(n^2)$ 降到了 $\Theta(n)$。

### 三、代码。

代码简单~~可爱~~呢！

```cpp
#include <cstdio>
using namespace std;
long long n,i,a[1000010],f[1000010],Ans;
long long read () {
	long long k=0,f=1;
	char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {k=k*10+(c-'0');c=getchar();}
	return k*f; 
}
long long Max (long long a,long long b) {return a > b ? a : b;}
long long Min (long long a,long long b) {return a < b ? a : b;}
int main () {
	Ans=-0x7fffffffll<<10ll;f[0]=0x7fffffffll<<10ll;//注意，这里要在常数后面加一个 ll，也就是将它转化为长整型，不然会溢出。
	n=read();
	for (i=1;i<=n;i++) a[i]=read();
	for (i=1;i<=n;i++) f[i]=Min(f[i-1],a[i]);//求前缀最小值。
	for (i=2;i<=n;i++) Ans=Max(Ans,a[i]-f[i-1]);//直接计算即可。
	printf("%lld\n",Ans);
	return 0;
}
```

---

## 作者：cyhyyds (赞：3)

### 思路：
由 $n\le 10^6$ 判断出，要一个时间复杂度为 $O(n \log n)$的做法。

题目要求求 $a_j-a_i$ 的最大值，也就是说，要求找出最大的 $a_j$ 和最小的 $a_i$。

那么可以枚举所有 $a_j$，查询 $1-j$ 中的最小值，寻找最大答案。

当然不能暴力查询最小值，于是采用**线段树**优化到 $\log n$ 的时间。

查询最小值的时间复杂度是 $O(\log n)$，遍历 $a_j$ 的复杂度是 $O(n)$，总复杂度为 $O(n \log n)$。

### 代码：
```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long ll; 

#define int ll

const int N = 1111111;
const int inf = 1e18;

struct SMT {
    int l;
    int r;
    int sum;
    ll mn;
}s[N << 2];

ll a[N];

#define ls(x) ((x) * (2))
#define rs(x) ((x) * (2) + (1))

inline void pushup (int nd) {
    s[nd].sum = s[ls(nd)].sum + s[rs(nd)].sum;
    s[nd].mn = min (s[ls(nd)].mn, s[rs(nd)].mn);
}

inline void build (int nd, int l, int r) {
    s[nd].l = l, s[nd].r = r;

    if (l == r) {
        s[nd].sum = a[l];
        s[nd].mn = a[l];

        return ;
    } 

    int mid = l + r >> 1;

    build (ls(nd), l, mid);
    build (rs(nd), mid + 1, r);

    pushup (nd);
}

ll Query_Min (int nd, int l, int r) {
    if (l <= s[nd].l && r >= s[nd].r) {
        return s[nd].mn;
    }

    int mid = s[nd].l + s[nd].r >>1;

    ll ans = inf;

    if (l <= mid) {
        ans = min (ans, Query_Min (ls(nd), l, r));
    }

    if (r > mid) {
        ans = min (ans, Query_Min (rs(nd), l, r));
    }

    return ans;
}

int n, q;

signed main() {
    scanf ("%lld", &n);

    for (int i = 1; i <= n; i ++) {
        scanf ("%lld", &a[i]);
    }

    build (1, 1, n);

    ll ans = -inf;

    for (int i = 1; i <= n; i ++) {
        ans = max (ans, (a[i] - Query_Min (1, 1, i - 1)));
    }

    printf ("%lld", ans);

    return 0;
} 
```


---

## 作者：Miracle_ZX (赞：3)

## 思路
此题当然可以在线更新区间内的最大值，最小值，再求所有区间最大值中最大的，但是这样未免麻烦了，下面有一个新思路：

如果可以只记录最小值以及最大的差，不断在线更新这两个，是否更加方便呢？这是一个新的思路。

我们可以从前往后扫一遍 $a_j$，其中若想使得当前差最大，且 $0 \leq i < j$，那么 $a_i$ 应当取 $[a_0,a_j]$ 这个区间的最小值,可以使差取到最大。

于是，这里就涉及到我们提到的两个在线维护的变量了：  
1. 最小值：当遍历到一个更小的 $a_j$ 时，更新。
2. 当不是最小值更新，即有可能产生更大的差，此时的差如果比原有最大差更大，则更新。
3. 若都不符合，则不执行操作。

## code
此处提醒：最好变量是 ```long long``` 类型，以防越界；另外用来记录最大差的 ```maxn``` 的初值要赋得足够小，否则 #13 测试点会出现一时间难以发现的问题。
```
#include<bits/stdc++.h>
using namespace std;

long long res, maxn = -0x3f3f3f3f3f3f3f3f, n, pre; 
//之前也有题解在此处出现了问题，原因是maxn的初值还不够小，开long long也是为了保险 
int main() 
{
	cin >> n >> pre;//自动认为第一个输入的数组元素为最小值 
	for (int j = 2; j <= n; ++j) 
	{
		cin >> res;//从2开始到n的数组元素 
		if (maxn < res - pre) maxn = res - pre;//maxn不断和当前区间最大比较，在线更新 
		if (res < pre) pre = res; //更新最小值 
	}
	cout << maxn;
	return 0;
}
```


---


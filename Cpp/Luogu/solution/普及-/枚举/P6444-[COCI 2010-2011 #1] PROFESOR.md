# [COCI 2010/2011 #1] PROFESOR

## 题目描述

在一个较长的教室中，$n$ 张桌子排成一排，每张桌子坐着 $2$ 个学生。
学生之所以胡思乱想是因为他们即将参加美术课，而他们的老师正计划对他们进行检查。

每个学生都学习过美术，但是只学习了一定水平。 这位教授可以通过脸上的表情告诉他们他们学了多少。 这位教授是一名艺术家，每个年级都使用不同的彩色铅笔。不幸的是，今天他只带了 $1$ 支铅笔。

为了使考试看起来公平，他想选择 $2$ 张桌子，并从他所选择的 $2$ 张桌子（包括所选的桌子）之间的每张桌子中向 $1$ 位学生提问。 重要的是所有受试学生都应获得相同的成绩，因此他可以用唯一的铅笔将其写下来。

教授想知道他可以通过这种方式检查的最大学生人数，以及学生将获得的分数。


## 说明/提示

#### 数据范围

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le a_i, b_i \leq 5$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #1](https://hsin.hr/coci/archive/2010_2011/contest1_tasks.pdf) *T2 PROFESOR*。**

## 样例 #1

### 输入

```
1
1 5 
```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3
3 5
4 5
1 3 
```

### 输出

```
2 5
```

## 样例 #3

### 输入

```
4
2 1
3 2
5 3
2 5 
```

### 输出

```
2 2
```

# 题解

## 作者：InformationEntropy (赞：7)

### 思路

给出一个不枚举 1-5 的解法（万一遇到类似的题，但 $a_i,b_i$ 范围大了，那么这种枚举的方法无论是时间上还是空间上都行不通）。

大致思路就是：

- 记录从 1 到第 $2\times n$ 个同学 $a_i$ 的成绩 $s$ 和所属桌号 $pos$ 的值。

- 然后排序，排序规则是成绩小的在前，成绩相同时，桌号小的在前（方便算连续）。

- 排序后从 1 到 $2\times n$ 找，如果找到了一个 $a_i$ 满足 $a_i.s = a_{i+1}.s$ 且 $a_{i+1}.pos-a_{i}.pos =1$，说明他们成绩相同且桌号连续，此时让总和累加1。如遇到一个 $a_i$ 不符合上述标准但 $a_i$ 与 $a_{i+1}$ 是同桌则不打断，否则打断，并更新答案。

- 输出最终答案即可。

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
inline void read(int &x){//快读
    int f = 1;
    x = 0;
    char ch = getchar();
    while(ch<'0' || ch>'9'){
        if(ch == '-'){
            f = -1;
        }
        ch = getchar();
    }
    while(ch >= '0'&&ch <= '9'){
        x = x*10+ch-48;
        ch = getchar();
    }
    x *= f;
}
struct node
{
    int x, pos;
}a[200001];//定义学生
bool cmp(node a, node b)
{
    if(a.x == b.x) return a.pos < b.pos;
    return a.x < b.x;
    //排序规则，上文已解释
}
int main()
{
    int n;
    read(n);
    for(int i=1; i<=n; i++)
    {
        read(a[i].x);
        a[i].pos = i;
        read(a[i+n].x);
        a[i+n].pos = i;
        //一次读入两个同桌，把桌号都设为i
    }
    sort(a+1, a+2*n+1, cmp);
    int maxl = 0, maxs = 0, s = 1;
    for(int i=1; i<=2*n; i++)
    {
        if(a[i].x==a[i+1].x && a[i+1].pos-a[i].pos==1)
        {
            s++;
            //满足要求则累加答案。
        }else if(a[i].pos!=a[i+1].pos){
            //不满足，打断累加
            if(s>1&&s>maxl)//s>1的作用为如果没加则不更新
            {
                maxl=s;
                maxs=a[i].x;//更新两个的值
            }
            s=1;//重设为一
        }
    }
    cout << maxl << " " << maxs;
    return 0;
}
```


---

## 作者：UperFicial (赞：4)

### 此题解讲一个与楼下有点不一样的解法

**题目大意**

有 $n$ 组数，每一组数包含两个数 $a_i,b_i$，让您在 $n$ 组数中找出最长的一段，使得这一段中每一组数中都有一个相同的数，让您输出这个序列的长度和这个相同的数，若有多个相同的数，输出最小的数。

**解题思路**

~~先吐槽一句：布吉岛为什么这个题面这么长，害的窝连读懂题都废了很长时间。/kk~~

先说一件非常显然的事情，设 $r$ 为最终答案序列的长度，$k$ 为答案序列个数最多的相同最小数字，那么 $1\le k\le 5$，这是因为 $k$ 肯定等于 $n$ 组数其中一组数的某个 $a_i$ 或 $b_i$ 并且题目中写到 $1\le a_i,b_i\le 5$。

所以我们可以枚举一个 $i\ (1\le i\le 5)$，每次在 $n$ 组数中找到一个最长的序列使得这个序列的每一组数中都有一个相同的数，每当得到一个长度 $r'$ 和 $k'$ 就更新答案。

时间复杂度：$\mathcal{O(n)}$；空间复杂度：$\mathcal{O(n)}$。

具体细节还是看代码吧。

$Code$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
inline int read()//快读 
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int n,a[MAXN],b[MAXN],ans,minn=1e9;
void solve(int score)
{
	int tot=0;//用来记录目前这一轮的长度 
	for(register int i=1;i<=n;i++)
	{
		if(a[i]==score||b[i]==score)//如果成绩相等 
		{
			tot++;//长度相应+1 
			continue;
		}
		//否则就是不相等的情况 
		if(tot>ans) //如果答案长度<这一轮的长度，说明这样就可以更新最终答案和相同的成绩 
		{
			ans=tot,minn=score;
			//注意，这里不能取最小值，因为在tot是在目前来看的最长长度，相同的数字也应该是最长长度对应的 
			tot=0;//别忘了清零，因为要重新分段 
			continue;
		}
		if(tot==ans)//否则如果等于ans，说明我们需要更新相同的成绩 
		{
			minn=min(minn,score);//取最小值 
			tot=0;//清零 
			continue;
		}
		else tot=0;//否则就不能对最优解产生贡献，因为长度没有达到 
	}
	//注意，最后跳出循环还要特判一次，
	//因为如果这n组数中都有一个相同的数那么刚刚的循环会一直进行下去，而不会更新最优答案 
	if(tot>ans) ans=tot,minn=score;//更新 
	else if(tot==ans) minn=min(minn,score);//更新*2 
	return;
}
int main()
{
	n=read();//读入n个数 
	for(register int i=1;i<=n;i++) a[i]=read(),b[i]=read();//每一组数 
	if(n==1)//特判n=1的情况
	//既然n=1最长长度只能是1，因为相同的数只有一个 
    {
    	printf("%d %d\n",n,min(a[n],b[n]));//min是因为题目中说要输出最小的数 
		return 0;
	}
	for(register int i=1;i<=5;i++) solve(i);//枚举每一种成绩 
	printf("%d %d\n",ans,minn);
	return 0;
}
```

$$\texttt{The End.by UF}$$


---

## 作者：HeCao2008 (赞：2)

[这里看效果更好哦](https://www.luogu.com.cn/blogAdmin/article/new#P6444)

这道题目想要求的是**连续相同成绩学生的数量** ，理解题目了以后我们就可以用**模拟**

看到范围很快就可以发现，学生的分数段是**从一到五**，所以很快就可以写出程序，来枚举学生的分数中的最大连续数量，代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],b[100001];
int n,maxx,now;
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;++i)scanf("%d%d",&a[i],&b[i]); //输入部分
	for(int i=1;i<=5;i++){ //枚举学生的分数
		int cnt=0;//这个是当前连续分数的数量
		for(int j=0;j<n;++j){ //判断每一个学生
			if(a[j]==i||b[j]==i)cnt++; //相同
			else cnt=0; //不相同，断掉连续
			if(cnt>maxx){ //如果比最优解要好
				maxx=cnt;
				now=i; //更新最大连续数和分数
			}
		}
	}
	printf("%d %d\n",maxx,now);
	return 0; //完美结束
}
```

**谢谢大家的阅读**

---

## 作者：Poetic_Rain (赞：2)

用$a_i$和$b_i$表示同桌的两个成绩

$e_{i,l}$表示以$i$结尾，连续的$a_i$的长度

$e_{i,r}$表示以$i$结尾，连续的$b_i$的长度

那么就可以在输入时统计出以上的信息，并求出最长的$l$，又因为使得$k$最小，再循环一次就可以了

```
#include<bits/stdc++.h>
#define MAXN 100000
using namespace std;
int n;
int a[MAXN],b[MAXN];
struct node{
	int l,r;
}e[MAXN];
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		e[i].l=e[i].r=1;
		scanf("%d%d",&a[i],&b[i]);
		if(a[i-1]==b[i-1]&&a[i]==a[i-1]) e[i].l+=e[i-1].l; 
		else if(a[i]==a[i-1]) e[i].l+=e[i-1].l;
		else if(a[i]==b[i-1]) e[i].l+=e[i-1].r;
		if(a[i-1]==b[i-1]&&b[i]==a[i-1]) e[i].r+=e[i-1].l;
		else if(b[i]==a[i-1]) e[i].r+=e[i-1].l;
		else if(b[i]==b[i-1]) e[i].r+=e[i-1].r;
	}
	int lmax=1,k=999;
	for(register int i=1;i<=n;i++){
		if(e[i].l>lmax) lmax=e[i].l;
		if(e[i].r>lmax) lmax=e[i].r;
	}
	for(register int i=1;i<=n;i++){
		if(e[i].l==lmax) k=min(k,a[i]);
		if(e[i].r==lmax) k=min(k,b[i]);
	}
	printf("%d %d",lmax,k);
	return 0;
}
```


---

## 作者：yxy666 (赞：1)

思路：一开始没什么想法，但是看到学生的等级都特别小时，我就有了一个想法：将所有同学按照等级将位置下标存起来。我们要求的就是最长的一段的相邻位置之差都为 $1$ 的一段（头不往左看，尾不往右看）。它的长度就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200005;
int n,ans,lst,len[6],a[6][maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
int main(){
	n=read();int x,y;
	for(int i=1;i<=n;i++){
		x=read();y=read();
		a[x][++len[x]]=i;if(x!=y)a[y][++len[y]]=i;//这里有一个坑，就是如果这对同桌的等级相同，那么我们就只用记一次就好了，不然就会出现a[i][j]==a[i][j-1]的情况
	}
	for(int i=1;i<=5;i++){
		if(len[i]<=0)continue;//如果没有这个等级，就不用做
		int p=1;//初始长度为1，因为本身就是一个
		for(int j=2;j<=len[i]+1;j++){
			if(a[i][j]==a[i][j-1]+1)p++;//如果还是相邻的，长度+1
			else{
				if(ans<p)ans=p,lst=i;
				else if(ans==p)lst=min(lst,i);
				p=1;//否则的话就刷一个最佳答案，然后还原初始情况
			}
		}
	}
	printf("%d %d\n",ans,lst);
	return 0;
}
```


---

## 作者：YueYang1235 (赞：1)

~~好久没写题解了，咕值都掉光光了/kk~~


------------

题意：

有 $ n $ 组数，每组有 $ 2 $ 个数 $ a_i $ 和 $ b_i $ 。现在需要求出一个最长的序列，使得这个序列每个 $ a_i $ 和 $ b_i $ 都至少有一个相同的数。


------------

由于 $ 1 \leq a_i , b_i \leq 5 $ ,于是我们可以把这个“相同的数”从 $ 1 $ 到 $ 5 $ 枚举出来（可以写循环也可以展开来写）

假设这个数为 $ k $ ,我们需要从 $ 1 $ 枚举到 $ n + 1 $ （如果只枚举到 $ n $ ,那么以 $ n $ 结尾的数据就没法保存了）如果 $ a_i $ 和 $ b_i $ 中有一个数等于 $ k $ ，序列长度 $ + 1 $ ,否则保存数据，长度清零。

时间复杂度 $ O(n) $ 。

放上我丑陋的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105000],b[105000];
int sum;
int maxn,num;
int l,r;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d%d",&a[i],&b[i]);
	for(int i=1;i<=n+1;++i){
		if(a[i]==1||b[i]==1)sum++;
		else{
			if(sum>maxn){
				maxn=sum;
				num=1;
			}
			sum=0;
		}
	}
	sum=0;
	for(int i=1;i<=n+1;++i){
		if(a[i]==2||b[i]==2)sum++;
		else{
			if(sum>maxn){
				maxn=sum;
				num=2;
			}
			sum=0;
		}
	}
	sum=0;
	for(int i=1;i<=n+1;++i){
		if(a[i]==3||b[i]==3)sum++;
		else{
			if(sum>maxn){
				maxn=sum;
				num=3;
			}
			sum=0;
		}
	}
	sum=0;
	for(int i=1;i<=n+1;++i){
		if(a[i]==4||b[i]==4)sum++;
		else{
			if(sum>maxn){
				maxn=sum;
				num=4;
			}
			sum=0;
		}
	}
	sum=0;
	for(int i=1;i<=n+1;++i){
		if(a[i]==5||b[i]==5)sum++;
		else{
			if(sum>maxn){
				maxn=sum;
				num=5;
			}
			sum=0;
		}
	}
	printf("%d %d\n",maxn,num);
	return 0;
}
```


---

## 作者：y0y68 (赞：0)

无聊来刷刷**水题**。

-------------

#### 题意：
有 $n$ 组数，每组有两个数 $a_i$ 和 $b_i$ ，求最长连续的若干组数，使得这些组数中，每组数都包含着一个相同的数，输出最长连续的组数和这个相同的数。

#### 思路：

模拟就好了！！！

先看数据范围，发现 $a_i,b_i$ 很小，就 $\le 5$，于是从 $1$ 到 $5$ 枚举这个相同的数 $i$ ，每次 $O(N)$ 地寻找最长有多少组连续的数，每组数都包含 $i$ ，而题目要求 $i$ 最小，连续的组数最长，搜完一次连续的 $a_i,b_i$ 之后更新一下即可。

那如何 $O(N)$ 的寻找呢？

以样例 $2$ 为例：

输入：

```
3
3 5
4 5
1 3 
```

输出：

```
2 5
```

当我们循环到 $i=5$ 时，先从 $1$ 下标开始（这里默认初始下标为 $1$ ），找到了 $2$ 组连续而又满足条件的，分别是 $a_1=3,b_1=5$ 和 $a_2=4,b_2=5$ ，其中 $i=b_1=b_2=5$ ，这时，我们就没必要再从下标为 $2$ 的位置继续寻找，因为从 $2$ 下标找出来的答案必定小于从 $1$ 位置寻找出来的，于是就可以直接跳到 $3$ 下标了。

### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,ans1,ans2;
bool f[100005][5];
//f[i][j]表示第i组数中是否包含j，包含为true,否则为flase
int main(){
	cin>>n;
	for(int i=1,a,b;i<=n;i++){
		scanf("%d%d",&a,&b);
		f[i][a]=f[i][b]=1;//记录一下
	}
	for(int i=1;i<=5;i++){//枚举i
		for(int j=1;j<=n;j++){
			if(f[j][i]){//第i组数中包含j
				int s=0;//s统计连续的组数
				while(j<=n&&f[j][i])j++,s++;
				//开始统计，注意j<=n
				if(s>ans1)ans1=s,ans2=i;
				//这里不考虑当s最大时i最小是因为i是从小到大枚举的
			}
		}
	}
	cout<<ans1<<' '<<ans2<<endl;
	return 0;
}

---

## 作者：77777_1031 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6444)

[更好的阅读体验](https://tsygoon.blog.luogu.org/solution-p6444)

~~题外话：你们代码都好长欸~~
##  Part 1 题目转化
教室里面一共有 $N$ 个课桌，按照顺序排成一列，每个课桌可以坐两个人，记他们的能力等级为 $A_i$ , $B_i$ 。现在教授决定对能力等级为 $K$ 的人进行测验。他会从这 $N$ 排中选择连续的 $L$ 排进行测验，要求这 $L$ 排中的每一排至少有一个人考试等级为 $K$。现在我们想知道 $L$ 的最大值以及对应的等级 $K$。（这样就好理解些叭）
##  Part 2 题目分析
因为 $k$ 范围非常小，所以暴力枚举 $k$ 值，然后判断连续出现 $k$ 的长度 $L$ 。
##  Part 3 代码
```c
#include <bits/stdc++.h>
using namespace std;
int n;
int a[100100],b[100100];
int x,y;
int main(){
    cin>>n;
    for(int i=0;i<n;i++)cin>>a[i]>>b[i];
    for(int grade=1;grade<=5;grade++){//枚举k值
        int len=0;//长度
        for(int i=0;i<n;i++){
            if(a[i]==grade||b[i]==grade)len++;
            else len=0;
            if(len>x){x=len;y=grade;}
        }
    }
    cout<<x<<" "<<y<<endl;
    return 0;//完结撒花～～
}
```
[AC记录](https://www.luogu.com.cn/record/63780532)

[我的博客～～](https://tsygoon.blog.luogu.org/)

by 2021.11.28 我的第三篇题解

---


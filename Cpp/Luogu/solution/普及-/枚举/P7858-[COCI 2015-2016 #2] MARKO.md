# [COCI 2015/2016 #2] MARKO

## 题目描述

老人 Marko 在他的手机上发现了一个新功能——九键输入！他的手机有一个由数字组成的键盘，看起来像这样：

|  |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  | &nbsp;1 &nbsp; &nbsp;&nbsp; | 2 abc&nbsp; | 3 def &nbsp; |  |
|  | 4 ghi&nbsp; | 5 jkl &nbsp; | 6 mno&nbsp; |  |
|  | 7 pqrs | 8 tuv&nbsp; | 9 wxyz |  |
|  |  |  |  |  |

为了用这个键盘输入一个单词，Marko 需要按一个键多次来输入所需的字母。更具体地说，如果所需字母是按键上的第一个字母，则需要按一次按键，如果是第二个字母，则需要按两次按键，依此类推。

例如，如果要输入单词 `giht`，Marko 需要先按一次 `4` 来输入 `g`，再按三次 `4` 来输入 `i`，再按两次 `4` 来输入  `h`，最后按一次 `8` 来输入 `t`。

Marko 把手机里的整本字典都背下来了。这本词典由 $N$ 个单词组成，每个单词都由小写英文字母组成，单词的总长度不超过 $10^9$ 个字符。Marko 将给出一个可用按键的集合，并想知道如果使用九键输入，字典中有多少单词可以使用给定的按键集合中的按键输入。

## 说明/提示

**【样例 1 解释】**

组成 `mono` 的四个字母都在按键 `6`  上，可以打出 `mono`。

其它单词均无法打出。

**【样例 2 解释】**

`j` 在按键 `5` 上而 `a` 在按键 `2` 上，所以可以打出 `ja`。

`l` 在按键 `5` 上而 `a` 在按键 `2` 上，所以可以打出 `la`。

**【数据范围】**

对于 $100\%$ 的数据，$1 \le N \le 10^3，1 \le |S| \le 10^3$。

**【说明】**

**本题数据点得分依原题，满分 50**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T1 MARKO**。

## 样例 #1

### 输入

```
3
tomo
mono
dak
6666```

### 输出

```
1```

## 样例 #2

### 输入

```
2
ja
la
52```

### 输出

```
2```

## 样例 #3

### 输入

```
3
dom
fon
tom
366```

### 输出

```
2```

# 题解

## 作者：LoserCode (赞：10)

# 题意简述

给出一字符串，判断其是否能与给定的字符串输入顺序相符。

# 题目分析

这种键盘问题通常要用到一个简单算法——构造数组，也就是大家所说的打表。

打表（用空间换时间）————一般是指将所有需要用到的结果先计算出来，然后后面需要用到时就可以直接查表获得。


那么本题所要保存的东西就是输入每个字母所需的按键，$e.g.$ : 输入 $a$ 需要按 2 ，那么就记为 $x [1] = 2$ ，以此类推。

如果这张表打好了，那么剩下的操作只剩下与给定的字符串比较，这里又有一个难点，输入的是字符串，要将其转化为数字比对，这里要用 ASCII 表。
![](https://cdn.luogu.com.cn/upload/image_hosting/cx0o74u2.png)

由表可知，需判断的小写字母字符串需要 $-a$ 也就是 $-97$ 可以得到十进制数字（也就是可以进行比较的），给定的字符串要 $-0$ ,也就是 $-48$ 得到十进制数字。

# Code

```
#include<bits/stdc++.h>
using namespace std;
int x[26]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};//构造数组
char a[1001][1001],b[1001];
int main()
{
	int n,ans=0,len=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>b;len=strlen(b);
	for(int i=1;i<=n;i++)
	{
		int l=strlen(a[i]);
		if(l==len)
		{
			bool flag=true;
			for(int j=0;j<l;j++)if(x[a[i][j]-97]!=b[j]-48)
			flag=false;	
			if(flag)ans++;//判断并统计答案
		}
	}
	cout<<ans;
	return 0;
}
```
温馨提示：本题卡数组大小记得把数组开大点哦。

---

## 作者：yydfj (赞：4)

**这是本蒟蒻第十二次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个数字 $n$ 以及 $n+1$ 个字符串，需要将第 $1$ 至 $n$ 的字符串进行操作变成另一个字符串，最后输出第 $1$ 至 $n$ 的字符串与第 $n+1$ 个字符串有相同的次数。

## 解法综述

根据问题简述模拟即可。对第 $1$ 至 $n$ 的字符串进行操作，使得该字符串中的字符以小写字母的形式变成它对应的数字，变化形式以题目中的表格为准。


![](https://cdn.luogu.com.cn/upload/image_hosting/59paoj7y.png)

其中表格大致由一个数字以及后面若干个小写字母组成，小写字母对应的数字为它所在的表格内的数字。

判断第 $1$ 至 $n$ 的字符串是否与第 $n+1$ 个字符串相同，可以利用 string 的特性，直接判断两个字符串是否相等即可。

## 代码描述
```cpp
#include<iostream>
using namespace std;
const int a[35]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
string s[1005];
int n,ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];//输入第1至n的字符串
		int l=s[i].size();//求第i个字符串的长度
		for(int j=0;j<l;j++) s[i][j]=a[s[i][j]-'a']+'0';//进行操作变成另一个字符串
	}
	cin>>s[n+1];//输入第n+1个字符串
	for(int i=1;i<=n;i++)
	if(s[i]==s[n+1]) ans++;//在string中，可以直接判断两个字符串是否相等
	printf("%d",ans);
	return 0;
}
```

---

## 作者：FuriousC (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7858)

暴力枚举题

看到九宫格不难想到打表：

```
int alp[27]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};//存了每个字母所按的键
```

然后输入的时候存一下每个字符串需要按几个键，每个键按了几次：

```
for(int i=1;i<=n;i++){
	string str; 
	cin>>str;
	for(int j=0;j<str.size();j++){
		a[i][alp[str[j]-'a']]++;//代表第 i 个字符串需要按 alp[str[j]-'a'] 这个键的次数 +1
	}
}
```

对于给定集合也是一样的操作：

```
string tar;
cin>>tar;
for(int i=0;i<tar.size();i++){
	b[tar[i]-'0']++;//显而易见
}
```

然后将 $a$ 数组和 $b$ 数组一一比较：

```
for(int i=1;i<=n;i++){
	bool flag=0;
	for(int j=2;j<=9;j++){//在键 2 到键 9 之间比较
		if(a[i][j]!=b[j]){//将第 i 个字符串要按 j 键的次数与给定集合要按 j 键的次数进行比较
			flag=1;
			break;
		}
	}
	if(!flag){//两者要按的键以及按的次数完全一样
		ans++;//ans<-ans+1
	}
}
```

最后输出即可。

完整代码：

```
#include<bits/stdc++.h>
using namespace std;
int alp[27]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
int a[1005][27],b[10];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string str; 
		cin>>str;
		for(int j=0;j<str.size();j++){
			a[i][alp[str[j]-'a']]++;
		}
	}
	/*
	for(int i=1;i<=n;i++){
		for(int j=1;j<=9;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<"\n";
	}
	*/
	string tar;
	cin>>tar;
	for(int i=0;i<tar.size();i++){
		b[tar[i]-'0']++;
	}
	/*
	for(int i=1;i<=9;i++){
		cout<<b[i]<<" ";
	}
	cout<<"\n";
	*/
	int ans=0;
	for(int i=1;i<=n;i++){
		bool flag=0;
		for(int j=2;j<=9;j++){
			if(a[i][j]!=b[j]){
				flag=1;
				break;
			}
		}
		if(!flag){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：ImposterAnYu (赞：2)

这道题已经把“枚举 + 暴力”写在脸上了，但是我们还是要先逐步分析。

首先，Marko 的键盘上打出 $a$~$z$ 这些字母用的键都已经给出来了，~~就不用打开手机的聊天软件编辑信息了。~~ 可以先用一个数组记录，第 $i$ 个元素表示九键输入法输入字母表中第 $i + 1$ 个字母需要按第几个键。

（记录用的数组为代码中的 $a$ 数组。）
```
#include<bits/stdc++.h>
using namespace std;
int n,l,a[31] = {2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9},i,j,s,m[1005],mm;
char b[1005][1005],ss[1005];
int main(){
    ios::sync_with_stdio(false);
    cin >> n;
    for(i = 1; i <= n ;i++){
    	cin >> b[i];
        m[i] = strlen(b[i]);
    }
    cin >> ss;
    mm = strlen(ss);
```

然后，数据读入完成后，就可以对符合要求的条件进行一个排查：

首先，只有一个单词的长度和按键组合的字符串长度相等才可能可以用给定的集合打出来。

其次，单词的第 $i$ 个字母如果不能用组合中的第 $i$ 个按键打出，那么就算后面的字母都可以打出，这个单词也是不能被打出来的。

所以，代码的核心部分就可以写出来了：

```
    for(i = 1; i <= n ;i++){
        if(mm == m[i]){
            for(j = 0; j < mm; j++){
                if(a[int(b[i][j] - 97)] !=  int(ss[j] - 48)){
                    break;
                }
            }
            if(j == mm){
                s++;
            }
        }
    }
    cout<< s << endl;
```

那么，代码就这样写完了~

# AC code
```
#include<bits/stdc++.h>
using namespace std;
int n,l,a[31] = {2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9},i,j,s,m[1005],mm;
char b[1005][1005],ss[1005];
int main(){
    ios::sync_with_stdio(false);//装 B 用的东西，写了这条语句可以关闭 cin/cout 和 scanf/printf 的同步。
    cin >> n;
    for(i = 1; i <= n ;i++){
    	cin >> b[i];
        m[i] = strlen(b[i]);
    }
    cin >> ss;
    mm = strlen(ss);
    for(i = 1; i <= n ;i++){
        if(mm == m[i]){
            for(j = 0; j < mm; j++){
                if(a[int(b[i][j] - 97)] !=  int(ss[j] - 48)){
                    break;
                }
            }
            if(j == mm){
                s++;//如果这个单词整个都可以被给定的按键组合打出，就说明这个单词符合条件。
            }
        }
    }
    cout<< s << endl;
    return 0;
}
```

---

## 作者：ycw123 (赞：1)

其实这题代码很简单，出错主要是因为对题意理解不对。

对于一个字母来说，不管需要连续摁几次，它只占据一个集合中的元素。

并且一个满足条件的字符串，其中的每一个字母都占据集合中的一个元素且**恰好**集合中**无剩余元素**。

举个例子：

当 $S=\{7\}$ 时，`p`,`q`,`r`,`s`四个字符串都满足条件 。

当 $S=\{7,3\}$ 时，`dp`,`eq`,`re`,`fs`等字符串都满足条件。

所以说我们只需要判断集合中每种元素的个数与字符串中对应的数字需要摁的次数是否相等。

我们可以通过打表预处理出，每个字母对应的数字，也就是一个简单的索引表。

```cpp
int num[27]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
```

然后记录每个字符串中每个数字需要摁的次数。

```cpp
for(int i=1;i<=n;i++){
	cin>>s;
	for(int j=strlen(s)-1;j>=0;j--){
		ned[i][num[s[j]-'a']]++;
	}
}
```
统计集合中每种元素的个数：
```cpp
char ch=getchar();//读取元素的方式类似快读
while(ch<'0'||ch>'9') ch=getchar();
while(ch>='0'&& ch<='9') a[ch-'0']++,ch=getchar();
```
对于每一组输入检验其是否满足条件：

```cpp
for(int i=1;i<=n;i++){
	for(int j=2;j<=9;j++){
		if(ned[i][j]!=a[j]) goto nex;
	}
	ans++;
	nex:;
}
```
完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int a[10];
int ned[1010][10];
int num[27]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
char s[1010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=strlen(s)-1;j>=0;j--){
			ned[i][num[s[j]-'a']]++;
		}
	}
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&& ch<='9') a[ch-'0']++,ch=getchar();
	for(int i=1;i<=n;i++){
		for(int j=2;j<=9;j++){
			if(ned[i][j]!=a[j]) goto nex;
		}
		ans++;
		nex:;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：C_S_L (赞：1)

注：
本题解中，$Z_i$ 表示字符串 $Z$ 的第 $i$ 个字符。

我们把每个字母所对应的按键编号用数组记录下来。

对于一个字符串$Z$，我们按照以下步骤进行判断：

1. 判断长度，若 $|S|\ne|Z|$，则一定不可行。

1. 如果长度相等，即 $|S|= |Z|$，那么对字符串 $Z$ 逐个字符进行判断。若 $Z_i$ 所对编号与 $S_i$ 不相等，则不可行。

1. 其余为可行解。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,x[26]= {2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
char a[1010][1010],b[1010];
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		scanf("%s",a[i]);
	}
	scanf("%s",b);
	int len=strlen(b);
	for(int i=1; i<=n; ++i) {
		int l=strlen(a[i]);
		if(l==len) {
			bool flag=true;
			for(int j=0; j<l; ++j) {
				if(x[a[i][j]-97]!=b[j]-48) {
					flag=false;
				}
			}
			if(flag) {
				ans++;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：ZZQF5677 (赞：0)

这道题是一个纯模拟，最高时间复杂度也是只有 $O(N,|S|)$，完全可以暴力，是一个~~赤裸裸的枚举~~。

首先，我们看到九建输入表，于是先打表：

```cpp
string words[KMW] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};  //万事俱备，只欠打表。
```

然后，再做一个函数，查找这个单词的字符在九建输入表哪个那个框里：

```cpp
char Check(char ch) {  //查找单词数字
  for (int i = 2; i < 10; i++) {
    for (int j = 0; j < words[i].size(); j++) {
      if (ch == words[i][j]) {
        return i + '0';
      }
    }
  }
}
```
基本的思路有了后，我们就可以先建立 $x$ 字符串，然后在每个单词的每个字母上运用 `Check()` 函数查找字母所在位置并将位置加入 $x$，最后对比 $x$ 与所需的字符串 $S$ 是否相同，然后相同就 $ans \gets ans +1$。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int KMW = 100;
string qwq[KMW * KMW * KMW + 5], s, words[KMW] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};  //万事俱备，只欠打表。
int n, ans;
char Check(char ch) {  //查找单词数字
  for (int i = 2; i < 10; i++) {
    for (int j = 0; j < words[i].size(); j++) {
      if (ch == words[i][j]) {
        return i + '0';
      }
    }
  }
}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> qwq[i];
  }
  cin >> s;
  for (int i = 1; i <= n; i++) {
    string x;
    for (int j = 0; j < qwq[i].size(); j++) { /*遍历并且对比*/
      x = x + Check(qwq[i][j]);
    }
    if (x == s) {
      ans++;
    }
  }
  cout << ans;
  return 0;
}
```

---


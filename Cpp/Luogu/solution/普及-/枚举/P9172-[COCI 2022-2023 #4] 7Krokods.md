# [COCI 2022/2023 #4] 7Krokods

## 题目背景

[加强版](/problem/U382344) [二次加强版](/problem/U502888)

## 题目描述

Krokod 喜欢和 Paula 玩棋盘游戏。他想玩 7Krokods 游戏，但 Paula 不喜欢复杂的游戏，所以 Krokod 决定他们只用绿卡和鳄鱼卡来玩。

Paula 有 $n$ 张绿色卡片，每张卡片上都写有以下字母之一：$d,k,o,r$。

她的总得分被定义为以下部分的总和。

- 对于每个字母，她得到的分数与写有该字母的卡片数量的平方相同。例如，如果她有 $6$ 张写有字母 $k$ 的卡片，她可以得到 $36$ 分。
- 每凑成一个单词 `krokod`，她就能得到额外的 $7$ 分。

Paula 也有 $m$ 张鳄鱼卡。她可以用任何一张鳄鱼卡代替一张绿卡，绿卡上有她选择的字母。

请计算她的牌能得到的最大分数。

## 说明/提示

样例 $1$ 解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/bwk9d3gv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

Paula 有 $2$ 个字母 $d（2\times 2=4$ 分），$6$ 个字母 $k（6\times 6=36$ 分），$4$ 个字母 $o（4\times 4=16$ 分）和 $3$ 个字母 $r（3\times 3 = 9$ 分）。单词 krokod 可以拼写 $2$ 次（$7\times 2=14$ 分）。她的总分是 
$79$。（$4 + 36 + 16 + 9 + 14 = 79$）。

样例 $2$ 解释：

Paula 可以把她的鳄鱼卡换成一张上面写着字母
 $k$ 的绿卡。
 
 |子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ |	$m=1$ | $17$ |
| $2$ |	$m=2$ | $26$ |
| $3$ |	无附加限制 | $7$ |

## 样例 #1

### 输入

```
15 0
krokodkrokodkrk```

### 输出

```
79```

## 样例 #2

### 输入

```
5 1
rokod```

### 输出

```
17```

## 样例 #3

### 输入

```
8 2
ddkkoorr```

### 输出

```
35```

# 题解

## 作者：what_can_I_do (赞：3)

[传送门](https://www.luogu.com.cn/problem/P9172)

模拟。先用一个数组 $a$ 把 $4$ 个字母分别存储下来，$a_0$ 存 `d`，$a_1$ 存 `k`，$a_2$ 存 `o`，$a_3$ 存 `r`。接着用深搜分别去枚举所有鳄鱼卡分别替代成的绿卡的所有情况。最后答案用一个函数求出，可以先把 $a_0$，$a_1\div2$，$a_2\div2$，$a_3$ 的最小值求出来，作为 `krokod` 的数量，再乘 $7$，最后加上四中绿卡分别的数量的平方就行了。答案输出最大值。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4],n,m,ans=-1;
inline int check()    //求每种情况的答案
{
	int sum=min(a[0],a[1]/2);
	sum=min(sum,a[2]/2);
	sum=min(sum,a[3]);
	sum*=7;
	for(register int i=0;i<4;i++) sum+=a[i]*a[i];
	return sum;
}
inline void dfs(int k)    //枚举所有情况
{
	if(k>m){ans=max(check(),ans);return;}
	for(register int i=0;i<4;i++) a[i]++,dfs(k+1),a[i]--;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)    //统计数量
	{
		char ch;
		cin>>ch;
		if(ch=='d') a[0]++;
		if(ch=='k') a[1]++;
		if(ch=='o') a[2]++;
		if(ch=='r') a[3]++;
	}
	dfs(1);    //深搜
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ivyjiao (赞：3)

看了一下，直到我 AC 的时候还没有和我一样的做法。

思路：显然的爆搜。

不用加任何优化就能过，但是不开 O2 过不去最后一个点。

时间复杂度 $O(4^m)$（因为要搜索四种字母）。

```cpp
#include<iostream>
#include<map>
using namespace std;
int n,m,maxp;
char cha;
map <char,int> a;//这里我为了方便理解，用了 map，也可以用数组。
void dfs(int cro){
    if(!cro){
        maxp=max(maxp,7*min(a['k']/2,min(a['r'],min(a['o']/2,a['d'])))+a['k']*a['k']+a['r']*a['r']+a['o']*a['o']+a['d']*a['d']);
        return;
    }
    a['k']++;
    dfs(cro-1);
    a['k']--;
    a['o']++;
    dfs(cro-1);
    a['o']--;
    a['r']++;
    dfs(cro-1);
    a['r']--;
    a['d']++;
    dfs(cro-1);
    a['d']--;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>cha,a[cha]++;
    dfs(m);
    cout<<maxp;
}
```


---

## 作者：wuhan1234 (赞：3)

## 1. 编程思路。

先对 $n$ 张绿卡上的各字母出现的次数进行统计，用变量 $d$、$k$、$o$、$r$ 分别保存四种字母出现的次数。

之后用三重循环对 $m$ 张鳄鱼卡替换为绿卡的各种组合情况进行枚举。设 $m$ 张鳄鱼卡可以替换为四种字母各有 $D$、$K$、$O$、$R$ 张的绿卡。

显然有 $0\le D \le m$，$0\le K \le m$，$0\le O \le m$，$0\le R \le m$，且 $D+K+O+R=m$。

替换后，四种字母的绿卡数分别为 $d+D$、$k+K$、$o+O$、$r+R$ 张，计算总得分。取各种组合情况总得分的最大值就是所求的答案。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int calc(int d,int k,int o,int r)   // 计算总得分
{
    int x;
    x = d * d + k * k + o * o + r * r;
    int t= (o/2 < k/2 )? o/2:k/2;
    if (t>r) t=r;
    if (t>d) t=d;
    x += 7 * t;
    return x;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	char s[105];
	scanf("%s",s);
	int d=0,k=0,o=0,r=0;
	int i;
	for (i=0;s[i]!='\0';i++)
    {
        if (s[i]=='d') d++;
        else if (s[i]=='k') k++;
        else if (s[i]=='o') o++;
        else if (s[i]=='r') r++;
    }
    int D,K,O,R;
    int ans=0;
    for (D=0;D<=m;D++)      // 对m张鳄鱼牌的替换情况进行穷举
        for (K=0;K<=m-D;K++)
            for (O=0;O<=m-D-K;O++)
            {
                R=m-D-K-O;
                int x=calc(d+D,k+K,o+O,r+R);
                if (ans<x) ans=x;
            }
    printf("%d\n",ans);
	return 0;
}

```


---

## 作者：ran_qwq (赞：3)

考虑暴力枚举每种鳄鱼卡转换为的绿卡，根据题意模拟每种情况的分数。有 $4$ 种绿卡，所以时间复杂度为 $O(m\times4^m)$。

枚举状态可以用 dfs，也可以用二进制枚举，我用了二进制枚举，以每两位表示一个鳄鱼卡的情况。$a$ 数组表示每个字母的个数，$b$ 数组表示要凑成一个 `krokod` 每个字母的个数。每个 $\lfloor\dfrac{a_i}{b_i}\rfloor$ 的最小值就是能凑成 `krokod` 的个数。

```cpp
int n,m,a[4],b[4]={1,2,2,1}; 
void solve()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		char ch;cin>>ch;
		if(ch=='d')
			a[0]++;
		else if(ch=='k')
			a[1]++;
		else if(ch=='o')
			a[2]++;
		else
			a[3]++;
	}
	int sum=1<<(m<<1),ans=0;
	for(int i=0;i<sum;i++)
	{
		for(int j=1;j<=m;j++)
			a[(i&((1<<(j-1<<1))*3))>>(j-1<<1)]++;
		int sum=0,minn=INF;
		for(int j=0;j<4;j++)
			sum+=a[j]*a[j],minn=min(minn,a[j]/b[j]);
		ans=max(ans,sum+minn*7);
		for(int j=1;j<=m;j++)
			a[(i&((1<<(j-1<<1))*3))>>(j-1<<1)]--;
	}
	write(ans,"");
}
```

---


# [蓝桥杯 2023 省 B] 填空问题

## 题目描述

## 试题 A：日期统计

### 【问题描述】

小蓝现在有一个长度为 $100$ 的数组，数组中的每个元素的值都在 $0$ 到 $9$ 的范围之内。数组中的元素从左至右如下所示:

```
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```
现在他想要从这个数组中寻找一些满足以下条件的子序列：

1. 子序列的长度为 $8$;

2. 这个子序列可以按照下标顺序组成一个 `yyyymmdd` 格式的日期，并且要求这个日期是 2023 年中的某一天的日期，例如 $20230902$，$20231223$。`yyyy` 表示年份，`mm` 表示月份，`dd` 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

请你帮小蓝计算下按上述条件一共能找到多少个**不同**的 2023 年的日期。对于相同的日期你只需要统计一次即可。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B：01 串的熵

### 【问题描述】

对于一个长度为 $n$ 的 01 串 $S=x_{1} x_{2} x_{3} \ldots x_{n}$，香农信息熵的定义为 $H(S)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2}\left(p\left(x_{i}\right)\right)$，其中 $p(0),p(1)$ 表示在这个 01 串中 0 和 1 出现的占比。

比如，对于 $S=100$ 来说，信息熵 $H(S)=-\frac{1}{3}\log _{2}\left(\frac{1}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)=1.3083$。对于一个长度为 $23333333$ 的 01 串，如果其信息熵为 $11625907.5798$，且 0 出现次数比 1 少，那么这个 01 串中 0 出现了多少次？

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# 题解

## 作者：dbywsc (赞：10)

### 日期统计

直接遍历所有的数再判断日期非常繁琐，所以可以考虑遍历 $2023$ 年的所有日期，再在 $100$ 个数中寻找是否能与这些日期相匹配，如果可以对应则答案加一。

```cpp
void solve(void) {
    int ans = 0;
    int a[101]; for(int i = 1; i <= 100; i++) cin >> a[i]; //用输入的方式读取 100 个数
    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    for(int m = 1; m <= 12; m++) {
        for(int d = 1; d <= days[m]; d++) {
            int date[] = {2, 0, 2, 3, m / 10, m % 10, d / 10, d % 10};
            int cnt = 0;
            for(int i = 1; i <= 100; i++) {
                if(a[i] == date[cnt]) cnt++;
                if(cnt == 8) {ans++; break;}
            }
        }
    }
    cout << ans << endl;
    //最后答案是 235
}
```

### 01 串的熵

由于本题已经把公式告诉我们了，所以只需要在 $0$ 到 $\lfloor \frac{23333333}{2}\rfloor$ 枚举 $0$ 出现的次数就好了。每次枚举后计算一下 $H(s)$ 的值，精度误差与答案在 $\pm 0.01$ 就可以确定答案。

```cpp
void solve(void) {
    for(int i = 1; i <= 23333333 / 2; i ++) {
        int j = 23333333 - i;
        double h = 0 - (i * (i / 23333333.0) * log2(i / 23333333.0) + j * (j / 23333333.0) * log2(j / 23333333.0));
        if(abs(h - 11625907.5798) < 0.01) {
            cout << i;
            return;
        }
    }
    //答案是 11027421
}
```

---

## 作者：ZhaoV1 (赞：0)

日期统计

数字个数有 $100$ 个，由于要严格满足年份为 $2023$，并判断此年是平年，所以我们可以分别对年份，月份，日简单剪枝（数据不大所以不需要剪太细），做一个 dfs 找子序列即可。

应该注意的是，需要求**不同**的满足条件的日期，所以需要手动对答案去重，这里用集合存数组的方式比较方便。




```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+5;
int t,n = 100;
vector<int> a(10);
set<vector<int>> se;
int arr[105];
void dfs(int p,int idx){
	//不断剪枝：
	if(p == 1)
		if(a[p] != 2) return;
	if(p == 2)
		if(a[p] != 0) return;
	if(p == 3)
		if(a[p] != 2) return;
	if(p == 4)
		if(a[p] != 3) return;
	if(p == 8){
		int A,b,c;
		A = a[1]*1000+a[2]*100+a[3]*10+a[4];
		b = a[5]*10+a[6];
		c = a[7]*10+a[8];
		if(A!=2023) return;
		if(!(b>=1&&b<=12)) return;
		if(b==1||b==3||b==5||b==7||b==8||b==10||b==12){//31days
			if(!(c>=1&&c<=31)) return;
		}else if(b==2){//28days
			if(!(c>=1&&c<=28)) return;
		}else{//30days
			if(!(c>=1&&c<=30)) return;
		}
		se.insert(a);
		return;
	}
	for(int i=idx;i<=n;i++){
		a[p+1] = arr[i];
		dfs(p+1,i+1);
	}
}

void solve(){
	for(int i=1;i<=n;i++) cin >> arr[i];
	dfs(0,1);
	cout << se.size() << '\n';
}
```
01 串的熵

该题要注意使用浮点数类型来存值。

题目已给出公式，已知 $H(S)=11625907.5798$，且 01 串中 $0$ 的个数小于 $1$ 的个数，已知基数 $n=23333333$，那么遍历 $1≤i≤\lfloor\frac{n}{2}\rfloor$，利用 $H(S)$ 精度差的大小来找出使得精度差最小的的 $i$ 即可。



```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
#define INF 0x3f3f3f3f3f3f3f3f

int t,n;
double x;
void solve(){
	x = 11625907.5798;
	n = 23333333;
	double Min = INF;
	int res = 0;
	for(int i=1;i<=(int)(n/2);i++){//i为0的个数
		double num = -(i)*((double)i/n*log2((double)i/n)) -(n-i)*((double)(n-i)/n*log2((double)(n-i)/n));
		if(fabs(Min-x) > fabs(num-x)){
			Min = num;
			res = i;
		}
	}
	cout << res << '\n';
}

```

---


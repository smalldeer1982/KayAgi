# [蓝桥杯 2023 省 B] 子串简写

## 题目描述

程序猿圈子里正在流行一种很新的简写方法：对于一个字符串，只保留首尾字符，将首尾字符之间的所有字符用这部分的长度代替。例如 `internationalization` 简写成 `i18n`，`Kubernetes`（注意连字符不是字符串的一部分）简写成 `K8s`，`Lanqiao` 简写成 `L5o` 等。

在本题中，我们规定长度大于等于 $K$ 的字符串都可以采用这种简写方法(长度小于 $K$ 的字符串不配使用这种简写)。

给定一个字符串 $S$ 和两个字符 $c_{1}$ 和 $c_{2}$，请你计算 $S$ 有多少个以 $c_{1}$ 开头 $c_{2}$ 结尾的子串可以采用这种简写？

## 说明/提示

**【样例说明】**

符合条件的子串如下所示，中括号内是该子串：
```plain
[abab]abdb
[ababab]db
[abababdb]
ab[abab]db
ab[ababdb]
abab[abdb]
```

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$2 \leq K \leq|S| \leq 10^4$。

对于 $100 \%$ 的数据，$2 \leq K \leq|S| \leq 5 \times 10^{5}$。$S$ 只包含小写字母。$c_{1}$ 和 $c_{2}$ 都是小写字母。

$|S|$ 代表字符串 $S$ 的长度。 

蓝桥杯 2023 省赛 B 组 G 题。

## 样例 #1

### 输入

```
4
abababdb a b```

### 输出

```
6```

# 题解

## 作者：dbywsc (赞：23)

### 思路

用两个指针遍历字符串即可。

指针 $i$ 开始时指向第一位，指针 $j$ 开始时指向第 $k$ 位，如果 $i$ 指针指向的字符是 $c_{1}$ 就用 $cnt$ 记录一下当前 $c_{1}$ 出现过的次数，如果 $j$ 指针指向 $c_{2}$ 就让 $ans$ 加上 $cnt$。这样的话在每次遇到 $c_{2}$ 时之前记录的 $c_{1}$ 都可以与它组成子串，能够覆盖所有长度不小于 $k$ 的子串的情况。

### 代码

```cpp
void solve(void) {
    int k; string s; char c1, c2;
    cin >> k >> s >> c1 >> c2;
    int ans = 0, cnt = 0;
    s = " " + s;
    for(int i = 1, j = k; j <= s.length(); i++, j++) {
        if(s[i] == c1) cnt++;
        if(s[j] == c2) ans += cnt;
    }
    cout << ans << endl;
}
```

---

## 作者：Erik_Aoi (赞：6)

### 题意
给定一个长度为 $n$ 的字符串 $S$，统计满足以下条件的子串数量：

+ 子串的首字符为 $c_1$；
+ 子串的尾字符为 $c_2$；
+ 子串的长度大于等于 $k$。

### 思路

#### 法一：二分
设字符串的长度为 $n$，记两个特定字符为 $c_1$ 与 $c_2$。定义数组

$$P_{c_1}=\{\,i\in\{1,2,\dots,n\}\mid \text{字符串的第 \(i\) 个字符为 } c_1\,\}$$

$$P_{c_2}=\{\,j\in\{1,2,\dots,n\}\mid \text{字符串的第 \(j\) 个字符为 } c_2\,\}$$

注意到 $P_{c_1}$ 与 $P_{c_2}$ 中的元素均按从小到大排列。

定义阈值 $T=i+k−1$，令 $N(i)=\{\,j\in P_{c_2}\mid j\ge T\,\}$，由于 $P_{c_2}$ 为递增序列，令 $j_0$ 为 $P_{c_2}$ 中第一个满足 $j_0\ge T$ 的元素，则从 $j_0$ 开始所有元素均属于 $N(i)$，其个数为 $|N(i)|$。

因此，最终答案：

$$ans=\sum_{i\in P_{c_1}}|N(i)|$$

在实际求解中，可利用二分查找在 $P_{c_2}$ 中确定每个 $i$ 对应的 $j_0$，因此整体时间复杂度为 $O(n\log n)$，可 AC 本题。

```cpp
#include <iostream>
#include <vector>
#define int long long
using namespace std;

string S;
char c1, c2;
int k;
vector<int> pos_c1, pos_c2;

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> k >> S >> c1 >> c2;
    for (int i = 0; i < S.size(); i++) {
        if (S[i] == c1) pos_c1.push_back(i);
        if (S[i] == c2) pos_c2.push_back(i);
    }
    int ans = 0;
    for (auto it : pos_c1) {
        ans += pos_c2.end() - lower_bound(pos_c2.begin(), pos_c2.end(), it + k - 1);
    }

    cout << ans;

    return 0;
}


```

#### 法二：单调队列

在法一的启发下，使用队列表示 $P_{c_1}$ 及 $P_{c_2}$。

考虑 $P_{c_2}$ 的**递增**顺序，对于每个 $i\in P_{c_1}$，将队列 $P_{c_2}$ 中的不满足 $j\ge T$ 的队首元素 $j$ 舍去。由于 $P_{c_1}$ 也是**递增**的，那么这些元素在下一个 $i$ 时同样需要舍去，因此这个操作是线性的——每个元素最多只会有一次操作。

设舍去操作后剩下的 $P_{c_2}$ 中的元素个数为 $|P_{c_2}(i)|$，则当前以 $i$ 为首字符的合法组合即有 $|P_{c_2}(i)|$ 个。最终答案 $ans$ 即为：

$$ans=\sum_{i\in P_{c_1}}|P_{c_2}(i)|$$

该方法的时间复杂度即为 $O(n)$。

```cpp
#include <iostream>
#include <queue>
#define int long long
using namespace std;

string S;
char c1, c2;
int k;
queue<int> pos_c1, pos_c2;

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> k >> S >> c1 >> c2;
    for (int i = 0; i < S.size(); i++) {
        if (S[i] == c1) pos_c1.push(i);
        if (S[i] == c2) pos_c2.push(i);
    }
    int ans = 0;
    while (!pos_c1.empty()) {
        int top = pos_c1.front();
        pos_c1.pop();
        while (!pos_c2.empty() and pos_c2.front() < top + k - 1) pos_c2.pop();
        ans += pos_c2.size();
    }
    cout << ans;

    return 0;
}


```

---


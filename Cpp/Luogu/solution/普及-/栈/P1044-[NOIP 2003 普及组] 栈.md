# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# 题解

## 作者：__CJY__ (赞：31)

## 思路
假设我们用一个函数 $\operatorname{C}(x,y)$ 表示：
* $x$：当前还未入栈的数字个数。
* $y$：当前栈中的数字个数。

我们的目标是计算 $\operatorname{C}(n,0)$，即从 $n$ 个数字开始，生成输出序列的方式。

在任何状态下，我们有两种选择：
* push 操作：如果还有数字可以入栈（即 $x>0$），我们可以将一个数字从输入序列中移入栈中。这会减少未入栈的数字个数 $x$，同时增加栈中的数字个数 $y$。因此，该操作对应于 $\operatorname{C}(x-1,y+1)$。
* pop 操作：如果栈中有数字可以出栈（即 $y>0$），我们可以将栈顶数字移出到输出序列中。这不会改变未入栈的数字个数 $x$，但会减少栈中的数字个数 $y$。因此，该操作对应于 $\operatorname{C}(x,y-1)$。

递归的边界条件是：当 $x=0 \land y=n$ 时，表示所有数字已成功输出为一个序列，这算作一种有效方式，返回 $1$；其他不合法状态（如 $x<0 \lor y>n$）返回 $0$。

递归太慢，所以我们可以用 DP，转移方程是：
$$f_{x,y}=f_{x-1,y+1}+f_{x,y-1}$$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[20][20],n;
int main(){
	cin>>n;
	for(int x=0;x<=n;x++){
		for(int y=0;y<=n;y++){
			if(!x) f[x][y]=1;
			else if(!y) f[x][y]=f[x-1][y+1];
			else f[x][y]=f[x-1][y+1]+f[x][y-1];
		}
	}
	cout<<f[n][0];
}
```
有问题请指出！

感谢 @[NJYgocrazy](/user/1418820) 指出一个小错误。

---

## 作者：yummy (赞：27)

看到题解里有人发了卡特兰数，我表示深深的佩服，因为我不会啊！

于是，就还有一批人，推出了他们的dp算法，然而，我在第一次做时，就没有想到，于是就使用了dfs（居然还通过了）

[我的代码](https://www.luogu.org/record/show?rid=7676823)

60分以下的同学别慌，接下来我会再把解题过程讲一遍。

---
很显然，对于每个合法的操作序列(如题目描述里的push,push,pop,push,pop,pop),都对应一个输出序列，于是题目就转化成了求合法操作序列数量。

我们总结出如下规律：
- 如果栈非空，那么下一步就既可push，又可pop
- 否则，下一步只可以push。

因此，我们dfs时，要传入两个参数，k用于记录当前是第几步，而many记录栈内有几个元素。
```cpp
int way(int k,int many)
{
    int t=0;//计数
    if(k==2*n)//如果步数已满，返回
    {
        if(many==0)//所有操作完成后栈是否清空
            return 1;
        else
            return 0;
    }
    if(a[k][many]!=0)//此处为了加速用了一个记忆化
        return a[k][many];
    if(many<=n)//栈不是满的就可以push
        t+=way(k+1,many+1);
    if(many>0)//栈不是空的就可以pop
        t+=way(k+1,many-1);
    a[k][many]=t;
    return t;
}
```
为防抄袭题解，剩下的部分由读者自行修补

---

## 作者：M1__ (赞：8)

# 题解：P1044 [NOIP 2003 普及组] 栈
-  __[Link](https://www.luogu.com.cn/problem/P1044) | [Blog](https://www.cnblogs.com/M1--1e9/p/18786780)__
-  直接按照卡特兰数做即可，但是**考虑证明**。
## 前置知识
- 卡特兰数：组合数学中一种常出现于各种计数问题中的数列。它的前几项为： 
$$C(0)=1,C(1)=1,C(2)=2,C(3)=5,C(4)=14,C(5)=42$$
## 题目思路  
- 不妨设第一个入栈的元素是第 $k$ 个出栈的元素，则前面的元素 $1 \sim k-1$ 必须在 $k$ 前完成出入栈。则方案数为 $C(k-1)$；
- 则后面的数 $k \sim n$ 有 $C(n-k)$ 种方案。总的方案数为 $C(k-1) \cdot C(n-k)$。
- 可以把样例代入证明：
  - 当 $k=1$ 时，有 $C(0) \cdot C(2)=2$；
  - 当 $k=2$ 时，有 $C(1) \cdot C(1)=1$；
  - 当 $k=3$ 时，有 $C(2) \cdot C(0)=2$；
  - 因此总方案为 $2+1+2=5$。
- 综上，答案为：
  $$ C(n)=\sum _{k=1}^{n} C(k−1) \cdot C(n−k)$$
- 将其化为：
  $$ C(n)=\frac{2(2n−1)}{n+1} \cdot C(n−1)$$
于是我们可以推出卡特兰数列的前 $18$ 项，然后根据 $n$ 输出即可。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100;
ll n,sum[N];
int main() {
    cin>>n;
    sum[1]=1;
    for(int i=2;i<=18;i++){
        sum[i]=sum[i-1]*2*(2*i-1)/(i+1);
        //cout<<sum[i]<<"\n";
    }
    cout<<sum[n];
    return 0;
}
```

---

## 作者：Doraeman (赞：6)

## 提示
我们可以计算多个不同的 $n$，通过观察找规律可得，这道题的答案符合**卡特兰数**的规律。
## 卡特兰数
卡特兰数是组合数学中一种常出现于各种计数问题中的数列。

卡特兰数的前几项为（从第 $0$ 项开始）：  
$$1,1,2,5,14,42,132,429,1430,...$$。

卡特兰数的 $C_n$ 的递推规律是：  
$$C_{n}=C_0C_{n-1}+C_1C_{n-2}+...+C_{n-2}C_1+C_{n-1}C_0$$。

根据上面这个递推公式，直接写代码即可。
## 代码
### 递推写法
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL C[25];

int main(){
    int n; cin >> n;
    
    C[0] = 1;
    for(int i=1; i<=n; i++)
    	for(int j=0; j<i; j++)
    		C[i] += C[j] * C[i-j-1];
    		// 递推公式 
			
	cout << C[n]; 
}
```
### 递归写法
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL C(int x){
	if(x == 0) return 1;
	LL ans = 0;
	for(int i=0; i<x; i++)
		ans += C(i) * C(x-i-1);
		// 递推公式 
	return ans;
}

int main(){
    int n; cin >> n;
    cout << C(n);
}
```
## 打表
当然，在我们知道答案的规律之后，也可以在网上搜索卡特兰数的前几项，然后直接**打表**得到答案。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL ans[] = {1, 1, 2, 5, 14, 42, 
			132, 429, 1430, 4862, 16796, 
			58786, 208012, 742900, 2674440, 
			9694845, 35357670, 129644790, 477638700};
// 刚好到第 18 项  

int main(){
    int n; cin >> n;
    cout << ans[n];
}
```

---

## 作者：AIregister (赞：2)

## 题意 ##
及问你有 $n$ 个数 $1$ 到 $n$，让你求出栈序列的情况总数。
## 解法 ##
这个题目是经典的数学题，在这里我们硬求肯定是没有办法的，那么我们不妨以递推的视角看一下。
我们可以设一个数组 $f$ 为在当 $n$ 为一到十八时，可能的序列总数。
那么此时我们的 $f_0$ 和 $f_1$ 只有一种情况，而 $f_2$ 有两种。
那么我们可以先构造一个栈的结构，我们得到了一个输入序列，接下来就要处理了，下一步求递推公式便是本题的精髓，我们的序列是不是从 $1$ 到 $n$ 的，我们的 $i$ 从一开始循环。那么，我们随机挑一个点 $k$，以 $k$ 为中心点我们的序列被劈成了两半，这两段的情况数为 $f_{k-1}$ 和 $f_{i-k}$ 这两个，那么根据乘法原理，总可能性为 $f_{k-1}$ $\times$ $f_{i-k}$ 。最终公式为 $f_n$ $=$ $f_0$ $\times$ $f_{n-1}$ $+$ $f_1$ $\times$ $f_{n-2}$ $\cdots$ $+$ $f_{n-1}$ $\times$ $f_0$。
那么，我们进行枚举，将 $1$ 到 $n$ 每一个数做这样的处理，将得出的数相乘，就是本题的答案。
## 代码 ##
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[55]={1,1,2};
int main(){
	int n;
	cin >> n;
	for(int i=3;i<=n;i++){
		for(int k=1;k<=i;k++){
			f[i]+=f[k-1]*f[i-k];
		}
	}
	cout << f[n];
	return 0;
}
```

---


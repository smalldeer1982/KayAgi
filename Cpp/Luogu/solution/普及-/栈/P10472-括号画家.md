# 括号画家

## 题目描述

Candela 是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。这一天，刚刚起床的 Candela 画了一排括号序列，其中包含小括号 `()`、中括号 `[]` 和大括号 `{}`，总长度为 $N$。这排随意绘制的括号序列显得杂乱无章，于是 Candela 定义了什么样的括号序列是美观的：

1. 空的括号序列是美观的；
2. 若括号序列 A 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；
3. 若括号序列 A、B 都是美观的，则括号序列 `AB` 也是美观的；

例如 `[(){}]()` 是美观的括号序列，而 `)({)[}](` 则不是。

现在 Candela 想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。你能帮帮她吗？

## 说明/提示

数据保证，各个测试点的 $N$ 的大小分别为：$5,10,50,100,100,1000,1000,10000,10000,10000$。

## 样例 #1

### 输入

```
({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)```

### 输出

```
4```

# 题解

## 作者：__qkj__ (赞：15)

[题目传送门](https://www.luogu.com.cn/problem/P10472)
## 解题思路
我们注意到 $n\le 10^4$，那就可以暴力了！

先用 $i$ 遍历字符串，选择左端点；再用 $j$ 从 $i$ 到最后一个字符选择右端点，$j$ 一边增加，一边用栈维护。

- 当 $a_j$ 是 `(`，`[` 或 `{` 时，把 $a_j$ 压入栈中；
- 当 $a_j$ 是 `)`，`]` 或 `}` 时：
	- 如果栈顶是 `(`，`[`，`{` 中与它对应的那个时，把 `)`，`]` 或 `}` 弹出栈，并让计数器 $now\gets now+1$； 
   - 否则，不是美观的括号序列，`break`，退出循环。
- 当栈是空的时，是美观的括号序列，$maxn\gets \max(maxn,now\times 2)$（括号都是成双成对的，所以要乘 $2$）。

最后输出 $maxn$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char st[114514];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	string a;
	int n,maxn=0;
	cin>>a;
	n=a.size();
	for(int i=0;i<n;i++)
	{
		int now=0,top=0;
		for(int j=i;j<n;j++)
		{
			if(a[j]=='('||a[j]=='['||a[j]=='{')st[++top]=a[j];
			if(a[j]==')')if(st[top]=='(')top--,now++;else break;
			if(a[j]==']')if(st[top]=='[')top--,now++;else break;
			if(a[j]=='}')if(st[top]=='{')top--,now++;else break;
			if(top==0)maxn=max(maxn,now*2);
		}
	}
	cout<<maxn;
	return 0;
}

```

---

## 作者：LG086 (赞：8)

### 分析

输入一串括号字符串，求最长的左右括号相匹配的连续子序列长度。考虑 DP。

用 $f_i$ 表示以 $i$ 结尾的最长的括号匹配的连续子序列长度。  
若当前 $s_i$ 是左括号，先跳过循环。  
若当前 $s_i$ 是右括号，判断在这之前是否有个左括号与之匹配。如果匹配，则 $f_i=f_{i-1}+2+f_{i-2-f_{i-1}}$。  
而 $ans$ 就是 $\max(ans,f_i)$。

最后输出 $ans$ 即可。

------------
### 代码

```cpp
#include<bits/stdc++.h>
#define LG086 signed
#define int long long
using namespace std;

char s[10010];
int ans,f[10010];
LG086 main(){
	scanf("%s",s+1);
	for(int i=1;i<=strlen(s+1);i++)
		if(s[i]=='('||s[i]=='['||s[i]=='{')continue;
		else if(s[i]==')'&&s[i-1-f[i-1]]=='('||s[i]==']'&&s[i-1-f[i-1]]=='['||s[i]=='}'&&s[i-1-f[i-1]]=='{')
			f[i]=f[i-1]+2+f[i-2-f[i-1]],ans=max(ans,f[i]);
	cout<<ans;
} 
```

---

## 作者：zhouzihang1 (赞：6)

# P10472 括号画家 题解

## 前言

这道题的题目描述不对，不管是样例还是测试点都没有 $N$，很多人 8 分的原因可能就是这个，[警示后人 & thx](https://www.luogu.com.cn/discuss/823475)。

## 思路

学习栈的时候一定学过括号匹配，这道题就是一个扩展题。

如果我们 $O(n^2)$ 枚举左右端点，然后检查是否合法，总的时间复杂度是 $O(n^3)$，不能通过。

但是，我们发现检查函数的 $r$ 只是在最后才使用，换句话说，对于每一个 $l$，有且仅有一个 $r$ 满足条件且长度最长。

所以可以枚举左端点，每次找最远的右端点，时间复杂度 $O(n^2)$。

另外此题有一些坑点，比如找到右括号时需要检查与此右括号匹配的左括号之间有没有未匹配的左括号。比如这个例子：`([)]`

## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,ans;
string s;
stack<int> st1,st2,st3;
//st1 存的是小括号
//st2 存的是中括号
//st3 存的是大括号
int main()
{
	cin>>s;n=s.size();
	for(int i=0,res;i<n;i++)
	{
		res=0;
		while(st1.size()) st1.pop();
		while(st2.size()) st2.pop();
		while(st3.size()) st3.pop();
		//清空一下 
		for(int j=i;j<n;j++)
		{
			if(s[j]==')')
			{
				if(st1.empty()) break;//空的肯定不对，下同。 
				if(st2.size()&&st2.top()>st1.top()) break;
				if(st3.size()&&st3.top()>st1.top()) break;
				//([{)}]
			}
			if(s[j]==']')
			{
				if(st2.empty()) break;
				if(st1.size()&&st1.top()>st2.top()) break;
				if(st3.size()&&st3.top()>st2.top()) break;
				//[({]})
			}
			if(s[j]=='}')
			{
				if(st3.empty()) break;
				if(st1.size()&&st1.top()>st3.top()) break;
				if(st2.size()&&st2.top()>st3.top()) break;
				//{([}])
			}
			if(s[j]=='(') st1.push(j);
			if(s[j]==')') st1.pop();
			if(s[j]=='[') st2.push(j);
			if(s[j]==']') st2.pop();
			if(s[j]=='{') st3.push(j);
			if(s[j]=='}') st3.pop();
			//对当前括号进行操作 
			if(st1.empty()&&st2.empty()&&st3.empty()) res=j-i+1;
		}
		ans=max(ans,res);
	}
	printf("%d",ans);
	return 0;
}
/*
没有 n
({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)
*/
```

---

## 作者：jiangjiangQwQ (赞：6)

### 思路
这是一道经典的括号匹配问题，那么需要用到的数据结构就是栈了。对于一种类型的括号，遇到它的左半边可以直接入栈，右半边时需要判断当前**栈顶元素**能否与当前字符组成**同一类型的括号**,如果可以就在两者对应下标的标记数组置为 $1$，否则入栈，按照以上过程扫完整个串。最后统计标记数组中最长连续 $1$ 的个数输出。
### 温馨提示
如果你出现了 ```RE```，注意有没有判断**栈为空时对栈进行了访问**。
### 代码
```cpp
#include<iostream>
#include<vector>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<unordered_map>
#include<stack>
#include<cmath>
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Rep(i,j,k) for(int i=j;i>=k;i--)
#define ls(c) c<<1
#define rs(c) c<<1|1
#define int long long
#define lowbit(x) ((x)&(-x))
template<typename type>
inline void read(type &x){
    x=0;bool flag(0);char ch=getchar();
    while(!isdigit(ch)) flag^=ch=='-',ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    flag?x=-x:0;
}
template<typename type>
inline void write(type x){
    x<0?x=-x,putchar('-'):0;
    static short Stack[50],top(0);
    do Stack[++top]=x%10,x/=10;while(x);
    while(top) putchar(Stack[top--]|48);
}
inline char read(char &ch){return ch=getchar();}
inline char write(const char &ch){return putchar(ch);}
template<typename type,typename ...T>
inline void read(type &x,T&...y){read(x),read(y...);}
template<typename type,typename ...T>
inline void write(type x,T...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\n');}
const int N=2e6+5,Mod=1e9+7;
stack<int> k;
string s;
bool vis[N];
signed main(){
	cin>>s;
	for(int i=0;i<s.size();i++){
		char ch=s[i];
		if(k.size()==0) k.push(i);
		else if(ch==')'){
			if(s[k.top()]=='(') vis[i]=vis[k.top()]=1,k.pop();
			else k.push(i);
		}
		else if(ch==']'){
			if(s[k.top()]=='[') vis[i]=vis[k.top()]=1,k.pop();
			else k.push(i);
		}
		else if(ch=='}'){
			if(s[k.top()]=='{') vis[i]=vis[k.top()]=1,k.pop();
			else k.push(i);
		}else k.push(i);
	}
	int cnt=0,ans=0;
	for(int i=0;i<s.size();i++){
		if(vis[i]==1) cnt++;
		else ans=max(ans,cnt),cnt=0;
	}ans=max(ans,cnt);
	cout<<ans;
	return 0;
}
```

---

## 作者：JYX0924 (赞：5)

这道题其实是暴力枚举括号序列的左端点和右端点，然后等到栈是空的时更新答案。

注意维护栈的长短，避免当栈是空的时进行比较。

下面是 AC 代码，代码中有一些优化。
```c
#include<bits/stdc++.h>
using namespace std;
int n,ans;
string s;
stack<int> q;

int pan(char str1)
{
	if(q.empty()) return 0;
	char str2=q.top();
	if(str2=='('&&str1==')') return 1;
	if(str2=='['&&str1==']') return 1;
	if(str2=='{'&&str1=='}') return 1;
	return 0;
}

int main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>s; string x=""; n=s.length();
	x.push_back('1');
	for(int i=0;i<n;i++) x.push_back(s[i]);
	s=x;
	for(int i=1;i<=n;i++) //枚举左端点
	{
		if(n-i+1<=ans) break; //优化，排除必然小于答案的情况
		if(s[i]==')'||s[i]==']'||s[i]=='}') continue;
		while(!q.empty()) q.pop();
		q.push(s[i]);
		for(int j=i+1;j<=n;j++) //枚举右端点
		{
			int y=pan(s[j]);
			if(y==1) q.pop();
			else q.push(s[j]);
			if(q.empty()) ans=max(ans,j-i+1);
		}
	}
	cout<<ans;
	return 0;
}
```

谢谢大家！！！

---

## 作者：Vct14 (赞：3)

我们充分发扬人类智慧，在用栈模拟的时候把当前合法括号序列长度也压到栈里。若当前括号可以匹配：如果栈中前面一个为长度，那么将长度合并再压进去，否则直接将 $2$ 压进栈中。若当前括号无法匹配，则直接压入栈中。最后取栈内元素最大值即可。

要注意栈为空的情况，防止 RE。时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pci pair<char,int>
#define mkp make_pair
#define w(x) s.push(mkp(x,0))
#define e(x) s.push(mkp('.',x))

stack<pci> s;

void debug(){
    stack<pci> ss{s};
    string out="";
    while(!ss.empty()){
        pci sse=ss.top();
        if(sse.second) out+=to_string(sse.second);
        else out+=sse.first;
        ss.pop();
    }
    for(int i=out.length(); i>=0; i--) cout<<out[i];
    cout<<"\n";
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    string a;cin>>a;int l=a.length();
	for(int i=0; i<l; i++){
        //debug();
        char x=a[i];
        if(s.empty()){
            w(x);
            continue;
        }
        pci frt=s.top();
        char fr=frt.first;int se=frt.second;
        bool isd=0;
        if(se){
            s.pop();
            if(s.empty()){
                e(se);w(x);
                continue;
            }
            frt=s.top();
            fr=frt.first;
            isd=1;
        }
        if((fr=='(' && x==')') || (fr=='[' && x==']') || (fr=='{' && x=='}')){
            s.pop();
            if(s.empty()){
                e(se+2);
                continue;
            }
            if(s.top().second){
                se+=s.top().second;
                s.pop();
            }
            e(se+2);
            continue;
        }
        if(isd) e(se);
        w(x);
    }
    //debug();
    int mxl=0;
    while(!s.empty()){
        if(s.top().second) mxl=max(mxl,s.top().second);
        s.pop();
    }
    cout<<mxl;
    return 0;
}
```

---

## 作者：Laisira (赞：3)

### 题面
给出一个字符串，问最长美观的括号序列，对美观的括号序列定义如下：

1. 空的括号序列是美观的；
2. 若括号序列 `A` 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；
3. 若括号序列 `A`、`B` 都是美观的，则括号序列 `AB` 也是美观的；

### 思路
因为美观的是像对应的，具体的，一个长 $len$ 的美观序列中 $i$ 有 $s_i$ 和 $s_{len-i}$ 相反。于是用单调队列维护从 $l$ 开始的序列，一个数如果和前一个相反将前一个弹出，否则放入。显然，队列为空时合法。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int sta[100005];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin>>s;
    s=' '+s;
    int ans=0;
    for(int i=1;i<s.size();i++) {
        int tot=0;
        for(int j=i;j<s.size();j++) {
            if(s[sta[tot]]=='['&&s[j]==']'||s[sta[tot]]=='('&&s[j]==')'||s[sta[tot]]=='{'&&s[j]=='}')tot--;
            else if(s[j]==']'||s[j]=='}'||s[j]==')')break;
            else sta[++tot]=j;
            if(tot==0)ans=max(ans,j-i+1);
        }
    } cout<<ans;
    return 0;
}
```

---


# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# 题解

## 作者：medusa (赞：213)

首先我说一下题目大意：我们可以把题目看成一个栈，而题目的要求就是在这个栈里面进行入栈、出栈和查询的工作。


解题思路：我们设f[i]为栈中从下到上的i个元素中的最大值，当我们加入一个新元素x时，t++，由于多了一个元素，所以f[t]=max(f[t-1],x)。那么在出栈时只要输出f[t-1]，在查找时只要输出f[t]。



参考代码：

```cpp

#include<iostream>   
#include<cstdio>   
#include<cmath>   
using namespace std;   
int f[200001],n,x,y,t=0;   
int main()   
{   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++)   
    {   
        cin>>x;   
        if (x==0)    
        {   
                  cin>>y;   
.                  t++;   
                  f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
  //  cin>>n;   
    return 0;   
}  

```

---

## 作者：引领天下 (赞：80)

个人上来直接写了个朴素的栈模拟，然后很开心的 T 了。

后来思考了一下，得到了优化后的思路。

做法：

指令边读边做，然后分几种情况：

1. 操作 0（集装箱进库操作，相当于进栈），如果输入的数小于之前的最大值，就仍然存储原来的最大值因为后进先出，当前的如果小，永远不可能被 2 询问到，所以存了也没用，不然入栈，栈顶 +1

2. 操作 1（集装箱出库操作，相当于出栈），直接栈顶 -1

3. 操作 2（集装箱询问操作，由于此时的栈顶是最大值，可以直接输出）

事实上，以上做法本质上就是维护了一个单调栈。

代码就不贴了，相信大家应该可以实现。

---

## 作者：buickboy (赞：59)

先入后出，很经典的栈操作题。由于数据量大，难度在最大值的求法，暴力搜是不行的。需要引入辅助栈。
辅助栈专门记录栈当前的最大值。如果push值大于辅助栈的头元素，则辅助栈中压入要push的值，否则重复压入辅助栈的头元素。比如：
A栈为主栈，输入数据依次入栈：1 2 3 5 4；
B栈为辅栈，记录对应的最大值：1 2 3 5 5；
弹出时，两栈同时弹出即可。



```
#include<bits/stdc++.h>
using namespace std;
stack<int>a;
stack<int>b;
int n,m,x;
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&m);
		if(m==0)
		{
			scanf("%d",&x);
			a.push(x);
			if(b.empty()||x>b.top())
				b.push(x);
			else b.push(b.top());
		}
		else if(m==1)
		{
			a.pop();
			b.pop();
		}
		else
		{
			if(b.empty()) printf("0\n");
			else printf("%d\n",b.top());		
		}			
	}
	return 0;
}

```

---

## 作者：juruo_zjc (赞：18)

# 像我一样的蒟蒻往这儿看！
这道题，仔细读题就知道这是一道关于栈的题目。刚看题，我知道肯定是用栈做，但是，一开始，我是用纯爆力的。然后只AC了几个点，三个TLE。很明显，暴力是会超时的。于是，我就想到了优先队列。优先队列相信大家都很熟悉，可是在弹出元素是，有一点麻烦（~~至少像我这种蒟蒻是无法搞定~~）


------------
接着，我又用了一个类似DP的方法。开了一个maxn数组，maxn[i]表示记录操作到第i个元素时，目前的最大值。然后就是一个最长子段和的操作。具体见代码。


------------
毕竟我是个蒟蒻，只会用系统栈，请大佬勿喷。


------------
参考代码：


```
#include<bits/stdc++.h>
using namespace std;
stack<int> st;
int n,op,x,f[100005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&op);
		if(op==0){
			scanf("%d",&x),st.push(x);
			f[st.size()-1]=max(f[st.size()-2],x);
		}
		if(op==1&&!st.empty())st.pop();
		if(op==2)cout<<f[st.size()-1]<<endl;
	}
	return 0;
}
```


---

## 作者：Garrison (赞：15)

### 做完了题以后，我感触很多。我就发一篇很长但是很容易理解的题解吧！

题目已经告诉我们是先进后出了，很容易想到是栈。（再加上这个标签是数据结构）那我们怎么使用栈呢？

前两项还是蛮简单的

当输入的==0时就再输入一个数，然后**栈.push(这个数);**

当输入的==1时就**栈.pop()**

本题的重难点——最大值（用优先队列也可以，不过有些麻烦）：

1. 储存 直接存到栈里有些绕，所以可以另外建一个数组，将这个数存到数组里。然后更新最大值（保证数组为不下降子序列）【当栈空时直接保存】
```
	cin>>x;
	if(s.size()!=0)
		if(x>a[tot]){
			a[++tot]=x;
		}else {++tot;a[tot]=a[tot-1];
	}
	else a[++tot]=x;
	s.push(x);
```
PS：感谢诸位神犇特别是[**Rain_morning**](https://www.luogu.org/space/show?uid=71070)指出了一个至关重要的错误原因

错误原因：

在洛谷编译器中++tot;a[tot]=a[tot-1];和a[++tot]=a[tot-1]不是等价的。

引用[_世界第一弱_](https://www.luogu.org/space/show?uid=24397)dalao的话：“在你的编译器里可能是先计算左边，但在部分评测系统中是先计算右边。”

3. 输出：输出a[tot]就好了（当栈不为空时）为空时就输出0

4. 
	改变：在某个数据弹出栈后，--tot

双手奉上代码：
```
#include<bits/stdc++.h>
using namespace std;
#define N 200005
stack<int> s;
int maxn,how,n;
int a[N],tot,x;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>x;
		if(x==0){
			cin>>x;
			if(s.size()!=0)
				if(x>a[tot]){
					a[++tot]=x;
				}else {++tot;a[tot]=a[tot-1];
				}
			else a[++tot]=x;
			s.push(x);
		}else if(x==1){
				int y=s.top();
				s.pop();
				if(tot>0)
					--tot;
			}
			else if(x==2){
				if(s.size()!=0)
					cout<<a[tot]<<endl;
				else cout<<0<<endl;
			}
	}
	return 0;
}
```


---

## 作者：Lynkcat (赞：12)

这道题目挺有意思（水一下~）

纯模拟肯定会TLE，利用一个栈，0将元素压入，1将栈顶指针减1，2扫描一遍栈找最大值。

想到这了，我们再深入一点思考，假设当前这个数比之前所有数都大，那么他作为当前最大的ans，但是这个时候需要把他删除，那怎么求之前数的ans呢？

我们可以想，这个时候的ans实际上在之前已经求出来过了。所以可以再用一个栈来存每次更新过的最大值。(~~~)
```pascal
var n,l,i,q,w,j,ans,r:longint;a,b:array[0..200000]of longint;
begin
  readln(n);
  l:=0;
  for i:=1 to n do
  begin
    read(q);
    case q of
    0:begin read(w);inc(l);a[l]:=w;if w>b[r] then begin inc(r); b[r]:=w;end;end;
    1:begin if (b[r]=a[l])and(r<>0) then dec(r);dec(l); end;
    2:writeln(b[r]);
    end;
  end;
end.

```


---

## 作者：felixwu (赞：10)

标准的栈   
简直就是模板    
push and pop 是两个基本操作   
a[top]维护包括栈顶元素的最大值  
a[top-1]就是包括小于栈顶的元素的最大值

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[1000001],top,a[1000001],m,n,k;
void push(int x){q[++top]=x;}
void pop(){top--;}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&m);
		if(m==0) {
			scanf("%d",&k);
			push(k);
			a[top]=max(a[top-1],k);
		}
		if(m==1) pop(); 
		if(m==2) printf("%d\n",a[top]);
	}
	return 0;
}	
```

---

## 作者：准点的星辰 (赞：7)

看楼下的代码无比简单，可惜刚看到时并没有理解，于是历经艰难的多次尝试后，我终于用两个优先队列和一个栈AC了这道题。（STL无敌）![](https://cdn.luogu.com.cn/upload/pic/21777.png)
第一次代码直接模拟3个TLE惨不忍睹，因为题解有这种代码所以不放了……

我的思路和别人不太一样，我的思路是每次入栈的时候都把数据入一个降序的优先队列，如果出栈的数据小于队头，直接出栈，如果等于队头，把队头出队，每次询问最大值，输出队头，这样可以再一定情况下保证是正确的。（因为你必须保证栈内剩余的数据和队列中的数据完全相同，才能保证输出正确，如果前面有出栈的但不是最大元素，队列中就有多余剩余，它就会影响答案。）如图：![](https://cdn.luogu.com.cn/upload/pic/21778.png)
所以我们需要保证栈与队列中的数据完全一致才能保证正确性，因为队列只能对队头进行操作，所以我们先记录下来栈弹出的但队列没有弹出的，然后等待这个元素成为队头，把多余的相同元素全部弹出。但是用数组的话会非常慢（如果出题人要卡你的话）所以我们再用一个优先队列，每次把栈弹出的都入队，如果两个队头相同，两个队头全部弹出。每次找的都是最大的而队列是降序的，所以正确性可以保证。
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
using namespace std;
priority_queue<int>q,qw;
stack<int>s;
int n;
int main()
{
    scanf("%d",&n);
    int p,x;
    for (int i=1;i<=n;i++)
    {
         scanf("%d",&p);
         if (p==0)
         {
         	scanf("%d",&x);
         	s.push(x); 
         	q.push(x); 
         }
         if (p==1&&!s.empty())
         {
            qw.push(s.top());
         	while (q.top()==qw.top()&&!q.empty()&&!qw.empty())
         	{q.pop();qw.pop();}
         	s.pop();
         }
         if (p==2)
         {
         	if (s.empty())
         	{	
             	printf("%d\n",0);
             	while (!q.empty())
             	q.pop();
             	while (!qw.empty())
             	qw.pop();
             	continue;
            }
         	printf("%d\n",q.top());
         }
    }
    return 0;
}
```
虽然跑的有点慢，但毕竟是自己想出来的，希望可以过审。

---

## 作者：安好en (赞：5)

代码不好看，将就一下吧。
刚刚听了dalao讲课的我，~~头脑清醒，精神抖擞，~~

------------
根据题目要求，明显可以用栈。

操作包括入库和出库，还有输出最大重量。

那么我们可以用两个栈，a:进行操作即入库和出库，b:记录最大重量。

让一个集装箱入库后，将它的重量与上一个b中的最大重量进行比较，
当它大于上一个的最大重量时，储存下来，否则这个位置还是上一个最大重量
就是这部分：if(y>b[tb])b[tb+1]=y;
else b[tb+1]=b[tb];

当出库和入库的时候就正常操作。

//第一篇题解诞生了！

------------

```cpp
//两个栈 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
using namespace std;
int a[200001],b[200001],ta,tb,x,y,n;
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>x;
		if(x==0)
		{
			cin>>y;
			a[++ta]=y;
			if(y>b[tb])b[tb+1]=y;
			else b[tb+1]=b[tb];
			tb++;
		}
		else if(x==1)ta--,tb--;
		else if(x==2)cout<<b[tb]<<endl;
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：5)

看到楼下各位大佬写栈;所以蒟蒻觉定来一篇单向链表的;
链表:链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。(摘自百度)

单向链表有一个指针,有一个值,值就是读入的入库,指针指向下一个单位

这题实际上单向链表跟栈的区别不大,大家可以多参考其他楼,蒟蒻发这篇题解只是让大家了解栈的题目可以用链表做

为了方便大家理解代码,蒟蒻把链表的STL函数给大家讲一下

empty()//用来判断这个链表是不是空的,是空的返回1,否者返回0

push_back()//在链表的尾部插入一个元素,系统并会自动的把指针指向这;

pop_back()//从尾部删除一个元素;

.back()//访问链表的最后一个元素;

废话不说,上代码(代码应该能自己理解)

```cpp
#include<bits/stdc++.h>
using namespace std;
list<int> s;
list<int> c;
int kk=0;//统计链表里的元素个数; 
int main()
{
    int n;
    scanf("%d",&n);
    int k,p,ss=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&k);
        if(k==0)
        {
            kk++;
            cin>>p;
            int t=s.empty() ? p : max(p,s.back());//判断这个链表是不是空的 
            s.push_back(t);//插入; 
        }
        if(k==1)
        {
            kk--;
            s.pop_back();
        }
        if(k==2)
        {
            if(kk==0)
                cout<<"0"<< endl;
            else
                cout<<s.back()<< endl;
        }
    }
}
```


------------
~~全部题解就我一个写链表,管理员大大没必要卡我吧~~

---

## 作者：SisconHL (赞：3)

[此处](https://www.luogu.org/blog/linka/p1165solution)食用效果更佳。
___
#### 前置知识
- 栈

>**栈**是一种**后进先出**（LIFO，last in first out）的线性表，其限制是**仅允许在表的一端进行插入和删除运算**
>>					——kkksc03《深入浅出》
（补：应该是“插入和删除操作”）

您也可以把栈理解成这样：
![whydoyouf12](https://i.loli.net/2019/11/11/RSO4JIFB9ngixba.png)
（当然一个数据结构是不会说话的）

这只想表达三点：

- **堆栈溢出**（stack overflow）**是致命的**，它会导致RE,使用STL里的栈一般不用担心它，如果用STL的栈，需要头文件stack。

- 靠近栈底的元素总比更远离栈底的元素更晚出栈

- 栈只可以对栈顶及它以上的一格空间进行修改（但一般手写栈会加上清空栈的函数）
---
#### 题解主体
看到操作1与操作2就应该知道用**栈**了吧，而且是栈的基本操作。关键就在操作3，查询最大值。

查询最大值我们一般都是遍历一遍数组然后用“打擂台”（将每个元素与最大值比较，如果当前元素更大就更新最大值），手写栈完全可以胜任，但这不是我们想要的结果。

~~（xxx：不这样够了我知足了）~~

怎么可以O（1）查询吗？保证栈内元素不减？

这是可以的。

考虑如下入库顺序：

< 1 , 1 , 4 , 5 , 1 , 4 ,1 , 9 , 1 ,9 >

~~（xxx：你怎么这么恶臭）~~

显然它非单调。

我们发现，如果每次入库都query一下，结果是：

< 1 , 1 , 4 , 5 , 5 , 5 ,5 , 9 , 9 ,9 >

它是单调的！

再加上出库看看：

如果出的是一段数值一样的序列的非第一个，那是满足的。

如果是第一个呢？最大值将会被改变！

那也没关系，根据栈的性质，它被弹掉了它前面的也被弹掉了，此时栈顶就是另外的最大值了。

于是我们在压入元素时可以：

如果它比栈顶大，压入它。

如果不是，压入一遍栈顶。

此外，如果栈是空的，不管怎样都要压入它。

所以我们得到了AC代码（其实前25行几乎不用看）：

```cpp

// OJ : Luogu
// Problem : P1165

// Use : make solution & exercise
// Time : Afternoon , Nov 11th , 2019

// Writer : linka

//--------------------Don't copy------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>

#define PrintInfo(varname,i) printf("Line%d,\"%s\"\'sValueIs:%d\n",__LINE__,varname,i);

const char OutputPrompt[] = ""; 

const int maxn = 200000 + 10;
const int Min = -2e9 - 10;
const int Max = 2e9 + 10;

struct Stack
{
	int num;
	int a[maxn];
	Stack()
	{
		num=0;
		for( register int i=0 ; i<maxn ; i++ )	a[i]=0;
	}
	inline void push ( int x )
	{
		a[ num++ ] = x;
	}
	inline void pop ()
	{
		if( num != 0 )	num--;
	}
	inline int top ()
	{
		return a[ num - 1 ];
	}
	inline int size ()
	{
		return num;
	}
};

Stack st;

inline void solve0( int num )
{
	if(	num <= st.top() && st.size() != 0 )	st.push( st.top() );
	else									st.push( num );
}
inline void solve1()
{
	st.pop();
}
inline int solve2()
{
	return st.top();
}

inline int perform ( int type , int num )
{
	if( type == 0 )		solve0( num );
	if( type == 1 )		solve1();
	if( type == 2 )		return solve2();
} 

int main( void )
{
	
	// freopen( "P1165-日志分析.in" , "r" , stdin);
	// freopen( "P1165-日志分析.out" , "w" , stdout);
	
	int t;
	scanf("%d" , &t);
	int type , num = -1;
	for( register int i=0 ; i<t ; i++)
	{
		scanf("%d" , &type);
		if( type == 0 )	scanf("%d" , &num);
		
		if(	type == 2 )
			printf("%s%d\n" , OutputPrompt , perform( type ,num ));
		else
			perform( type , num );
	}
	
	// fclose( stdin );
	// fclose( stdout );
	
	return 0;
}

```
不要抄袭代码。

感谢您的阅读。

---

## 作者：t162 (赞：2)

[博客效果更佳](https://bambusoideae.cn/posts/Solutions/luogu-p1165.html)

这道题目很简单，只是一道栈的模拟题。至于最大值，我们可以用平衡树来维护。

操作：

- 操作0：把$X$压入栈，并插入到平衡树中；
- 操作1：从平衡树中删除栈顶元素，并从栈中弹出栈顶元素；
- 操作2：查找平衡树中最大元素（一直往右子树找，没有右子树了就返回）；

~~于是我们就愉快地解决了。~~

```cpp
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<stack>
using namespace std;
struct nodes{
	int rd,x,lc,rc,cnt;
	nodes(int X){
		lc=rc=0;
		x=X;
		rd=rand();
		cnt=1;
	}
	nodes(){
		lc=rc=0;
		x=0;
		cnt=0;
	}
};
nodes node[200001];
int root,cnt;
int newNode(int x){
	node[cnt++]=nodes(x);
	return cnt-1;
}
void zig(int x,int f){
	int temp=node[node[x].lc].rc;
	node[node[x].lc].rc=x;
	if(x==root)root=node[x].lc;
	else{
		if(node[f].lc==x){
			node[f].lc=node[x].lc;
		}else node[f].rc=node[x].lc;
	}
	node[x].lc=temp;
}
void zag(int x,int f){
	int temp=node[node[x].rc].lc;
	node[node[x].rc].lc=x;
	if(x==root)root=node[x].rc;
	else{
		if(node[f].lc==x){
			node[f].lc=node[x].rc;
		}else node[f].rc=node[x].rc;
	}
	node[x].rc=temp;
}
void insert(int &nd,int f,int x){	//插入
	if(nd==0){
		nd=newNode(x);
		return;
	}
	if(x<node[nd].x){
		insert(node[nd].lc,nd,x);
		if(node[node[nd].lc].rd>node[nd].rd){
			zig(nd,f);
		}
	}else if(x>node[nd].x){
		insert(node[nd].rc,nd,x);
		if(node[node[nd].rc].rd>node[nd].rd){
			zag(nd,f);
		}
	}else{
		node[nd].cnt++;
	}
}
void del(int &nd,int f,int x){	//删除
	if(node[nd].x==x){
		if(node[nd].cnt>1){
			node[nd].cnt--;
			return;
		}
		if(node[nd].lc+node[nd].rc==0){
			nd=0;
			return;
		}
		if(node[nd].lc==0){
			int t=node[nd].rc;
			zag(nd,f);
			del(nd,t,x);
			return;
		}
		if(node[nd].rc==0){
			int t=node[nd].lc;
			zig(nd,f);
			del(nd,t,x);
			return;
		}
		if(node[node[nd].lc].rd>node[node[nd].rc].rd){
			int t=node[nd].lc;
			zag(nd,f);
			del(nd,t,x);
		}else{
			int t=node[nd].rc;
			zig(nd,f);
			del(nd,t,x);
		}
	}else{
		if(x<node[nd].x){
			del(node[nd].lc,nd,x);
		}else{
			del(node[nd].rc,nd,x);
		}
	}
}
int query(int nd){	//查询
	if(node[nd].rc==0){
		return node[nd].x;
	}else return query(node[nd].rc);
}
stack<int> sta;
int main(){
	int n;
	root=newNode(0);
	scanf("%d",&n);
	while(n--){
		int x,y;
		scanf("%d",&x);
		if(x==0){
			scanf("%d",&y);
			insert(root,0,y);
			sta.push(y);
		}else if(x==1){
			if(sta.empty())continue;
			del(root,0,sta.top());
			sta.pop();
		}else{
			if(sta.empty())puts("0");
			else printf("%d\n",query(root));
		}
	}
}
```

---

如果你看懂了，恭喜你；如果没看懂，没关系，还有另一种做法。毕竟这是一道入门题。

思考：**难道栈中存的一定是输入的内容吗？**

**未必。**

我们发现，当压入的一个数$X$不比之前栈中所有数大的时候，它的压入与弹出对栈内数的最大值是没有任何影响的。

为什么呢？因为比$X$之前入栈的一些数中有比它大的数。要想让$X$成为栈中的最大数，就必须把比它之前入栈的所有比它大的数都弹出去。由于题目要求只能入栈一次，所以以上操作显然违背了栈的定义。

当$X$大于之前栈中所有的数的时候，它的压入与弹出对栈内数的最大值有影响，但对之前栈内的最大值无影响。

所以我们栈中存的数据是在入库之后仓库内所有集装箱的最大重量。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<stack>
using namespace std;
stack<int> sta;
int main(){
	int n;
	scanf("%d",&n);
	while(n--){
		int x,y;
		scanf("%d",&x);
		if(x==0){
			scanf("%d",&y);
            if(sta.empty())sta.push(y);
			else sta.push(max(sta.top(),y));
		}else if(x==1){
			if(sta.empty())continue;
			sta.pop();
		}else{
			if(sta.empty())puts("0");
			else printf("%d\n",sta.top());
		}
	}
}
```


---

## 作者：ylwhxht (赞：2)

这里是来自真*蒟蒻萌新的第一次题解哈
看大佬们代码都好简短，不过还是觉得分享一下鸭。

思路很直，开一个结构体，1存自己的重量，2存当前的最大值，当然还是要用到栈的操作（STL牛啤，破音！
定义一个临时变量MAX初始化为0。

一：当需要入库的时候，先存入他的重量，然后判断重量是否大于MAX，是的话，更改MAX的值并把自己的max改为自己的重量，如果不是的话就让自己的max等于MAX。

二：当需要出库的时候，没啥好说的，需要注意的是出库判断一下是否空，然后出，还要记得更改一下MAX的值，非空就改为栈顶的max，空就置为0（就是忘了改MAX，导致WA声一片）。

三：当需要查询的时候，直接输出MAX或者栈顶的max就可以辽
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef struct goods{
	int weight;
	int max;
}good;
int main(){
	stack<good> p;
	int T;
	cin>>T;
	int MAX=0;
	while(T--){
		int t;
		scanf("%d",&t);
		if(!t){
			good temp;
			scanf("%d",&temp.weight);
			if(temp.weight>=MAX){
				temp.max=temp.weight;
				MAX=temp.weight;
			}
			else temp.max=MAX;
			p.push(temp);
		}
		else if(t==1){
			if(p.empty())continue;
			p.pop();
			if(!p.empty())MAX=p.top().max;
			else MAX=0;
		}
		else{
			if(p.empty())printf("0\n");
			else printf("%d\n",MAX);
		}
	}
} 
```
**~~//第一次居然忘记加代码了，蠢哭。求过鸭~~**


---

## 作者：Hokage (赞：2)

#### 这是一道c++中STL--栈的问题;
首先我们来讲一下栈的基本操作

1.定义
```
#include<stack>
stack<int> q;//定义一个名字叫做q的栈

```
2.入栈
```
q.push(a);//将a放入栈顶
```

3.出栈
```
q.pop()//将栈顶元素出栈
```

4.取栈顶
```
q.top()//将栈顶元素取出，但不出栈
```
5.判断栈是否为空
```
q.empty()
//这是一个bool操作
//当栈为空时，返回true
//当栈里有元素时，返回false

```
如仍有疑问练习[P1427](https://www.luogu.org/problemnew/show/P1427)与[P1739](https://www.luogu.org/problemnew/show/P1739)

------------

将了这么多，给个代码吧（我用了一个伪栈a）

（具体见注释）


```
#include<bits/stdc++.h>
using namespace std;

int sum;
int f,x;
int t=0;
int a[1000000];//一个伪栈
//a[t]表示当时的最大值
//a[t-1]表示出栈顶外的最大值

int main()
{
	cin>>sum;
	for(int i=1;i<=sum;i++)
	{
		cin>>f;
		if(f==0)
		{
			cin>>x;
			t++;//使栈多了一层
			a[t]=max(a[t-1],x);//维护此时a[t]的大小
		}
		if(f==1) t--;//即a[t]元素出栈
		if(f==2) cout<<a[t]<<endl;//直接输出当时的栈顶
	}
	return 0;
}
```


---

## 作者：zhanghengrui (赞：1)

楼上的大佬们几乎都是$O(n)$算法，这让只会$O(n\log{n})$算法的蒟蒻我很尴尬。

~~那我就发一篇用multiset做的吧~~

下面是简短~~（明明比$O(n)$算法的还长）~~的代码

```cpp
#include<cstdio>
#include<set>
#include<stack>
std::multiset<int,std::greater<int> > mst;//用于查询最大值，其中std::greater<int>表示从大到小排序
//由于题目中没说明没有重复，所以要用multiset而不是set
std::stack<int> sta;
int main()
{
	int N,opt,X;
	scanf("%d",&N);
	while(N--)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 0:
				scanf("%d",&X);
				mst.insert(X);//插入mst
				sta.push(X);//进栈
				break;
			case 1:
				if(sta.size())
				{
					mst.erase(mst.find(sta.top()));//从mst中删除要出库的
					sta.pop();//出栈
				}
				break;
			case 2:
				if(mst.empty()) puts("0");
				else printf("%d\n",*mst.begin());//mst中第一个元素即为当前最大值
		}
	}
	return 0;
}
```

~~温馨提示：大家在比赛的时候还是尽量不要学我这种暴力出奇迹~~

---

## 作者：ljc20020730 (赞：1)

明确一点：集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为

当前在仓库里所有集装箱中最晚入库的集装箱。

这是一个类似栈的思想：先进后出。

当然对于

对于49%的数据，有N≤1000的话n^2扫一遍是没有问题的

对于100%的数据，有N≤200000，X≤10^8。的话扫一遍是绝对超时的

所以这里用到一个思想：数组a[i]中不存集装箱的重量而存1到i个集装箱的最大重量

还有，这里因为读入文件比较复杂，输出文件也比较复杂，建议大家用文件读写

```cpp
var n,i,p,k:longint;
    a:array[0..100000]of longint;
function max(x,y:longint):longint;
begin
 if x>y then exit(x) else exit(y);
end;
begin
//assign(output,'aa.txt');
//rewrite(output);
 readln(n);
 for i:=1 to n do begin
  read(p);
  if p=0 then begin inc(k); read(a[k]);a[k]:=max(a[k],a[k-1]); end; //求1-k数组中元素a[i]的最大值 (1<=i<=k)
  if p=1 then dec(k);//出栈
  if p=2 then writeln(a[k]);//输出最大值
 end;
// close(output);
end.
可以发现这样的算法几乎是O（n）的 不会超时
```

---

## 作者：LEXUGE (赞：1)

```cpp

#include <stdio.h>
int a[200001]={0};
int max(int x,int y)  //两数比大小
{
  if (x>y) return x;  //x比y大就返回x
  else return y;  //否则返回y
}
int main()
{
  int n=0,xb=0,x=0,i=0,m=0;
  scanf("%d",&n);  //读入操作总数
  for (i=1;i<=n;i++)  
  {
     scanf("%d",&x);  //读入操作类型
     if (x==0)  //进栈操作
     {
         scanf("%d",&m);  //读入进栈的物品重量
         xb=xb+1;  //栈元素加1
         a[xb]=max(a[xb-1],m);  //使得最后栈的最后一个元素是当前元素中最大的，使得只要后面一个元素不比前面一个大，后面一个元素就等于前一个元素，也就是说在查询时查到的是这当前栈元素中的最大值（因为后一项绝对>=前一项），在退栈时却退出的是一个元素（只起到退出元素的作用，在不真正退出最后一种相同数字序列的第一个,我们权且称它为最大数字的“真身”时，不会改变当前栈的最大值）
     }
     if (x==1)  //退栈
     {
         if (xb!=0)  //退出最后一个元素
         xb=xb-1;
     }
     if (x==2)  //查询操作
    {
        printf("%d\n",a[xb]);  //输出栈的最后一个元素，也就是当前栈的最大值
    }
  }
  return 0;
}

```

---

## 作者：「QQ红包」 (赞：1)

这题纯模拟。

用的是一种类似于栈的思想。

```delphi

var n,i,t,l,z:longint;
    a:array[0..200001] of longint;
function max(x,y:longint):longint;
begin
    if x>y then exit(x) else exit(y);
end;
begin
    read(n);
    l:=0;
    for i:=1 to n do
    begin
        read(t);
        case t of
            0:begin
                  read(z);
                  inc(l);
                  a[l]:=max(z,a[l-1]);
              end;
            1:if l>0 then dec(l);
            2:writeln(a[l]);
        end;
    end;
end.    

```

---

## 作者：Zyque (赞：0)

栈是一种线性表,特点是先进后出,插入/删除操作只能在栈的最顶端进行,而读取操作可以在任何一处进行。C++中可以直接用
```
stack<xxx>yyy;
```
声明一个名为yyy的存储xxx类型变量的栈(在这之前#include<stack>),不过笔者更习惯直接用数组加指针来写。声明一个数组和对应类型的指向栈顶的指针即可。

今天做了一道考察栈的运用的题([P1165](https://www.luogu.org/problemnew/show/P1165)),笔者一开始是用一个栈stk模拟货物进出口的情况,但发现这样在查询最大集装箱的重量时需要逐个遍历整个栈,耗时很长。于是~~开始瞎写~~想通过快速排序来找到最大值,显然这种方法是不行的。仔细思考了一下,遂又声明了一个栈sx,专门存放集装箱的最大值,用法如下:

1. 当入栈的集装箱重量num比sx的栈顶数据大时,使num入栈sx(当sx为空时栈顶数据=0)

1. 当出库的集装箱(即栈stk的栈顶)是当时最大的集装箱时,使栈sx的栈顶出栈

1. 当需要查询最大的集装箱重量时,直接输出栈sx的栈顶数据即可

例程如下:

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int n, stk[200001];  //栈stk[]为库内的集装箱存放情况
int sx[200001];      //栈sx[]存储集装箱最大值
int *top = stk, *xtop = sx;
//top指向栈stk[]的栈顶,xtop指向栈sx[]的栈顶

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        switch (x) {
        case 0:                  //集装箱入库操作
            int num;             //num为入库的集装箱重量
            scanf("%d", &num);
            *top = num;          //num入栈stk
            top++;
            if (xtop == sx) {    //当栈sx为空时,栈顶为0,直接将num入栈sx即可
                *xtop = num;
                xtop++;
            }
            else {
                if (num > *(xtop - 1)) {  //如果num>sx栈顶则num入栈sx
                    *xtop = num;
                    xtop++;
                }
            }
            break;
        case 1:                  //集装箱出库操作
            if (top != stk) {    //当栈stk为空时直接跳过该操作
                if (*(top - 1) == *(xtop - 1)) {  //如果出库的集装箱重量为当时最大的,则sx的栈顶也要出栈
                    xtop--;
                    *xtop = 0;
                }
                top--;
                *top = 0;
            }
            break;
        case 2:                   //集装箱查询操作
            if(xtop != sx)  printf("%d\n", *(xtop - 1));
            else  printf("0\n");  //当栈sx为空时要输出0
            break;
        }
    }
    return 0;
}
```

---

## 作者：Drinkkk (赞：0)

/\*
P1165 题解

模拟算法

\*/
/\*
49分思路：

先将要出去的都放出去，然后再将要进来的都存进来，接着如果遇到查询操作的话就扫一遍整个数组，求出一个最大值，再输出。否则如果这个数组是空的，那么就输出0即可。

（超时49分）

满分思路：

先将要出去的都放出去，然后再将要进来的都存进来，然后再和这个数组中的前一个数比较大小，将当前的这个值改为这两个数当中的最大的那个数的值即可。接着如果遇到查询操作的话输出当前这一个数组中的最后一个数即可，否则如果这个数组是空的，那么就输出0就可以了。

\*/
满分代码：

```cpp
#include <cstdio>
int a[10000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int len=0,p=0;
    scanf("%d",&p);
    while(p--)
    {
        int t=0;
        scanf("%d",&t); 
        if(t==0)
        {
            scanf("%d",&a[++len]);
            a[len]=max(a[len-1],a[len]);
        }
        else if(t==1)
        {
            if(len==0)
            {
                continue;
            }
            a[len--]=0;
        }
        else if(t==2)
        {
            int maxx=0;
            if(len==0)
            {
                printf("0\n");
                continue;
            }
            printf("%d\n",a[len]);
        }
    }
    return 0;
}
```

---

## 作者：用户已注销 (赞：0)

某种单调的维护

对于操作0，如果输入的数小于之前的最大值，就仍然存储原来的最大值

这样做的理由就是：后进先出，当前的如果小，永远不可能被2询问到，所以存了也没用

对于操作1，直接头指针-1（这一步如果不懂去学一下栈（steak））

对于操作2，输出栈顶的值，也就是当前的最大值

输入和操作一起进行，O（N）时间复杂度


多说一句：这道题有点类似于单调队列维护的简化版

可以在**洛谷题库**里搜索一下“滑动窗口”（没有引号）


```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
int n,steak[200001],top=0;
int main()
{
    scanf("%d",&n);
    int a;
    for(;n--;)
    {
        scanf("%d",&a);
        switch(a)
        {
            case 0:
                scanf("%d",&steak[++top]);
                steak[top]=max(steak[top],steak[top-1]);
                break;
            case 1:
                top=max(0,top-1);
                break;
            case 2:
                printf("%d\n",steak[top]);
        }
    }
    return 0;
}
```

---


# [COCI 2012/2013 #4] ESEJ

## 题目描述

Mirko 最近的家庭作业是写一篇作文。然而，他觉得写作文太无聊了，于是在写了两个小时后，他发现自己只写了 $N$ 个只由字母 $A$ 和 $B$ 组成的长单词。Mirko 已经接受了自己无法按时完成作文的事实，于是他决定至少让自己在作文里找点乐趣，比如统计“好单词”的数量。

Mirko 会通过在单词上方画弧，将成对的相同字母（$A$ 对 $A$，$B$ 对 $B$）连接起来。如果一个单词满足：可以将每个字母与恰好一个相同字母配对，并且所有的弧都不会相交，那么这个单词就是“好单词”。请帮助 Mirko 统计有多少个“好单词”。


## 说明/提示

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
ABAB
AABB
ABBA```

### 输出

```
2```

## 样例 #2

### 输入

```
3
AAA
AA
AB```

### 输出

```
1```

## 样例 #3

### 输入

```
1
ABBABB```

### 输出

```
1```

# 题解

## 作者：Sweet_2013 (赞：12)

题意：判断 $A$ 和 $B$ 组成的单词是否是好单词。一个好单词要求每个字母都能与另一个相同的字母配对且所有配对的弧线不能相交。

只需要遍历每个字母，如果栈顶字母和当前字母相同，弹出栈顶，否则就把它压入栈，最后判断栈是否为空，为空就说明全部配对完成。

```
#include<bits/stdc++.h>
using namespace std;
bool pd(const string &a) {
    stack<char>s; 
    for(size_t i=0;i<a.size();i++) {
        if(!s.empty()&&s.top()==a[i])s.pop(); //判断栈顶字母是否和当前字母相同，相同弹出栈顶。
        else s.push(a[i]);  //不同把它压出栈。
    }
    return s.empty(); 
}
int n,ans; 
string a;   
int main() {
    cin>>n;
    for(int i=0;i<n;i++) {
        cin>>a;
        if(pd(a))ans++;  
    }
    cout<<ans;  
}
```

---

## 作者：MAX_CURRY_JAMES (赞：3)

# [题目传送门](https://www.luogu.com.cn/problem/P13414)

## 1、题目大意

这题它要将成对的相同字母（$A$ 对 $A$，$B$ 对 $B$）连接起来，如果全部字母都能匹配并且相交的弧还没有重叠，那么这个单词就是一个“好单词”，它要我们求一共有多少个“好单词”。

## 2、思路

我们可以用栈来处理。（[没学过栈的可以来这里](https://www.luogu.com.cn/problem/B3614)）每处理一个字母，就判断是否与栈顶字母相同，是的话就弹出栈顶，否则就压入栈（具体看代码）。

## 3、代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum;
string s;
stack<char>f;
signed main(){
	cin>>n;
	while(n--){
		cin>>s;
		f.push(s[0]);
		for(int j=1;j<s.size();j++){
			if(f.empty()) f.push(s[j]); //注意判断栈是否为空 
			else if(f.top()==s[j]) f.pop();//判断是否与栈顶字母相同 
			else f.push(s[j]);//否则压入栈 
		}
		if(f.empty()) sum++;//栈为空，说明全部匹配成功并且弧没有重合 
		while(!f.empty()) f.pop();//最后记得清空栈 
	}
	cout<<sum;
	return 0;
}

```
最后再提醒一句：题解仅供学习参考使用，请勿抄题解。

写作不易，求点赞。

---

## 作者：Doraeman (赞：2)

刚看到题目的时候并不知道该怎么写。  
这个时候，我们就应该立即去~~看一看算法标签~~。  
然后就知道了：**栈**。

## 思路
设字符串为 $S$。 

如果两个字符 $S_i=S_j$，满足 $j=i+1$（或 $i=j+1$），那么直接在这两个字符上方连线。  
由于他们相邻，所以一定不会和其它弧相交。

反之，类似自测样例 $1$ 给出的，像“ABAB”这样没有相邻的相同字符的，就无法保证弧线不相交。

### 栈处理
根据以上思路，可以使用一个栈。每次检测字符串当前的字符，如果这个字符 $S_i$ 与栈顶字符 $S_{top}$ 相同，即 $S_i=S_{top}$，那么直接将栈顶元素弹出，表示这 $2$ 个字符相邻，所以可以配对。  
相反，如果 $S_i\not=S_{top}$，说明无法配对，将 $S_{top}$ 压入栈，等待将来配对成功的机会。

最后，如果 $S$ 遍历结束时栈内没有元素，说明全部配对成功（恭喜！），对答案有贡献。  
如果直到结束时栈内还有元素，说明没法配对，不对答案做出贡献。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
    int T; cin >> T;
    int ans = 0;
    while(T--){
        string s; cin >> s;
        if(s.size() % 2) continue;

        stack <char> a; // 栈 
        for(int i=0; i<s.size(); i++){
            if(a.empty()){ // 最开始不用思考，直接压入栈 
                a.push(s[i]);
                continue;
            }

            if(a.top() == s[i]) // 相邻且相同，配对成功 
                a.pop();
            else a.push(s[i]); // 不成功，压入栈
        }
        if(a.empty()) ans++;
    }
    cout << ans;
}
```

---

## 作者：wanghaotian0227 (赞：2)

# P13414 题解
## 题意
题目要求在相同字母上方画弧，如果一个单词可以将每个字母与恰好一个相同字母配对，并且所有的弧都不会相交，那么这个单词就是“好单词”。  
题目中的在字母上方画弧，大眼一看感觉有点复杂，但是你只需要动动手画个图一看——

![](https://cdn.luogu.com.cn/upload/image_hosting/6zvbx8mw.png)

这不就是字符版的表达式括号匹配吗！  
当进栈的字符与前一个字符相同时，就把他们两个都弹出栈，否则就进栈。若最后栈空，那么这就是一个“好单词”。
## 程序
$C$ 为模拟栈，$top$ 为栈顶指针。
```cpp
for(int i=0;i<s.size();i++)
{
		c[++top]=s[i];
		if(c[top]==c[top-1])
		{
			c[top]=0;
			c[top-1]=0;
			top-=2;
		}
}
	if(top==0)
		sum++;
```
## 代码
~~其实这道题算是道模板题吧（虽然有些水）~~
```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{
	int n,sum=0;
	cin>>n;
	for(int T=1;T<=n;T++)
	{
		int top=0;
		string s;
		cin>>s;
		char c[100001];
		for(int i=0;i<s.size();i++)
		{
			c[++top]=s[i];
			if(c[top]==c[top-1])
			{
				c[top]=0;
				c[top-1]=0;
				top-=2;
			}
		}
		if(top==0)
			sum++;
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：little_stickman (赞：2)

# P13414题解
## 主要题意
有一个由字母 $A$ 与 $B$ 组成字符串，现在我们要将其中相同的字母全部连线，如果这个字符串可以有一种方案使其所有的连线不会相交，那么我们称它是一个“好单词”。

现在，给你 $N$ 个字符串，求其中有几个“好单词”。

## 解题思路
这题基本就是括号匹配的双倍经验。

观察一下，我们要使两根连线不相交，就要尽量将其与离它最近的相同字符连线，就如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/h740ok8q.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这样划分，所有的字符都与离它最近的相同字符连线，且没有出现相交情况，这就是一个“好单词”；

但是，在这幅图中：

![](https://cdn.luogu.com.cn/upload/image_hosting/g5b441cy.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以发现，第一个 $B$ 与最后一个 $B$ 相连线了，这就会导致最后有连线相交。

由上面的的分析得到，**我们只考虑一个字符与离它最近的相同字符连线**，在这种情况下，如果最后连线方案会相交，这个字符串就一定不是“好单词”。

如何代码实现呢？我们可以使用**栈结构**来实现对此题的解答：当遇到一个新字符的时候，如果它与栈顶字符相同，就将它与栈顶字符连线（即弹出栈顶字符）。否则，就将其压入栈中。最后，如果栈中没有字符，就说明这是一个“好单词”，不然，这就不是一个“好单词”。
## 上代码！ 
```cpp
#include <bits/stdc++.h>
using namespace std;

int ans = 0;
int main(void)
{
	int T;
	cin >> T; 
	while(T --)
	{
		string str;
		stack<char> stk;
		cin >> str;
		for(int i = 0;i < str.length();i ++)
		{
			if(stk.empty())
			{
				stk.push(str[i]);//栈中空了，直接压入 
				continue;				
			}
			if(stk.top() == str[i])//与栈顶字符相等，弹出 
				stk.pop();
			else
				stk.push(str[i]);//与栈顶字符不相等，压入 
		}
		
		if(stk.empty())//栈空了，代表所有字符匹配成功 
			ans ++;
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：longyitongxue (赞：1)

如果你想要前往题目，请点击[这里](https://www.luogu.com.cn/problem/P13414)。
# 思路
这道题我们可以用一个栈来做。首先读入整个字符串，然后遍历这个字符串，如果栈空，直接压入当前字符；否则如果栈顶的字符与当前遍历到的字符不相同，把当前字符压入栈；否则，把栈顶的字符弹出。接着，如果栈空，答案变量 $ans$ 就加一，这是一个好单词。最后，输出答案 $ans$。
# [AC](https://www.luogu.com.cn/record/226558695) code
```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(string s){
    stack<char> st;
    for(int i=0;i<s.size();i++){
        if(st.empty())st.push(s[i]);//栈空直接压入当前字符
        else if(st.top()!=s[i])st.push(s[i]);//栈顶的字符与当前遍历到的字符不相同，把当前字符压入栈
        else st.pop();//否则把栈顶的字符弹出
    }
    return st.empty();//判断栈空
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr),cout.tie(nullptr);
    int n,ans=0;
    cin>>n;
    while(n--){
        string s;
        cin>>s;
        if(check(s))ans++;//如果栈空，答案变量 ans 就加一，这是一个好单词
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 思路
一道水题。 $\\$

不看标签都不难发现这题可以直接用栈来模拟。所谓栈，就是一种后进先出的数据结构，就好比我们吧若干个物品放在一个桶里，那么后放进去的物品肯定是先拿出来。这题也是一样，我们把一个个字母都一次放入栈中，如果发现栈顶元素与当前字母相同，那就可以直接消掉，最后再看一下栈是否为空就行啦！
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=0;
void solve()
{
	string s;cin>>s;
	stack<int> stk;//这里用到的是STL里的栈，当然手写也是可以的。
    //top():返回栈顶元素
    //pop():弹出栈顶元素
    //push(x):将x压入栈
    //empty():判断栈是否为空，若为空返回true
	for(char x:s)//枚举字符
	 {
	 	if(!stk.empty()&&stk.top()==x) stk.pop();//如果与栈顶元素相同，弹出元素
	 	else stk.push(x);//将当前字符压入栈中
	 }
	if(stk.empty()) ans++;//如果栈空，则累计答案
}
int main()
{
	int t;cin>>t;
	while(t--) solve();
	cout<<ans;
	return 0;
}
```

---

## 作者：tc291311 (赞：1)

#  [COCI 2012/2013 #4] ESEJ

来热乎水题了！！！

一道很好的思维题~
## 题意解释

将相同的字母连线，刚好连完且线和线之间不交叉就是好单词，统计好单词数量。  
这个问题和括号匹配类似，即后**出现的字母必须优先与最近的相同字母配对**，也使用**栈**。~~根据标签可以知道~~。

## 算法思路

- 因为是两两配对，所以直接排除长度为奇数的。
- 遍历字符串，如果当前字母和栈顶一样，即配对成功，就弹出栈顶。
- 判断栈的长度。

## 代码

```cpp

#include <iostream>
#include <stack>
using namespace std;

bool isGoodWord(const string &s) {
    if (s.size() % 2 != 0) return false;
    stack<char> st;
    for (char c : s) {
        if (!st.empty() && st.top() == c) st.pop();
        else st.push(c);
    }
    return st.empty();
}

int main() {
    int N, cnt = 0;
    cin >> N;
    while (N--) {
        string s;
        cin >> s;
        if (isGoodWord(s)) cnt++;
    }
    cout << cnt;
    return 0;
}

```

---

## 作者：Hkb150429 (赞：0)

## 题意

现在有一个只包含 $A$ 和 $B$ 的字符串，将成对的相同字母（$A$ 对 $A$，$B$ 对 $B$）连接起来。如果一个单词满足：可以将每个字母与恰好一个相同字母配对，并且所有的弧都不会相交，那么这个单词就是“好单词”，统计有多少个“好单词”。

## 思路

建议使用[栈](https://oi-wiki.org/ds/stack/)。

本题很简单，循环遍历字符串，将栈顶字母与遍历到的字母比较，若相同则说明匹配上了，出栈，否则将当前字母字母入栈。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t=0;
void solve(){
    string str;
    cin>>str;
    stack<char> s,st;
    int n=str.length();
    for(int i=0;i<n;++i)
    {
        if(!st.empty()&&st.top()==str[i])st.pop();
        else st.push(str[i]);
    }
    if(s.empty()&&st.empty()) t++;
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        solve();
    }
    cout<<t;
    return 0;
}
```

---

## 作者：Clouds_dream (赞：0)

### 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P13414)  
本题等价于判断单词是否是一个合法的括号序列，其中 `A` 和 `B` 可以看作不同类型的括号。

### 题目分析
我们可以使用栈来模拟括号匹配的过程。遇到一个字母时，如果栈顶元素与之相同，则弹出栈顶元素（表示匹配成功），否则将当前字母压入栈中。如果最终栈为空，说明所有字母都成功配对，否则不是。

### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

int n,ans=0;

bool f(string s){
	stack<char>st;
    for(char c:s){
        if(!st.empty()&&st.top()==c){
            st.pop();
        }
        else{
            st.push(c);
        }
    }
    return st.empty();
}

signed main()
{
	fst
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		if(f(s))ans++;
	}
    cout<<ans;
	return 0;
}
```

---

## 作者：Zjb13927701829 (赞：0)

# P13414 [ESEJ](https://www.luogu.com.cn/problem/P13414) 题解
## 题目大意
给出 $n$ 个仅包含 $A$ 或 $B$ 的字符串，统计这 $n$ 个字符串中“好单词”的数量。

Mirko 会在单词上方画弧，将成对的相同字母（$A$ 对 $A$，$B$ 对 $B$）连接起来。如果一个单词满足：可以将每个字母与**恰好**一个相同字母配对，并且**所有的弧**都**不会相交**，那么这个单词就是“好单词”。请帮助 Mirko 统计有多少个“好单词”。
## 解题思路
本题就是 [P1739](https://www.luogu.com.cn/problem/P1739) 的进阶版，同样可以用栈来解决，下面是解题步骤：
1. 检查单词长度是否为偶数。
2. 循环遍历字符串，将栈顶字母与当前字母比较，如果相同则出栈（匹配上了），否则将当前字母字母入栈。
3. 最后判断栈是否为空（有没有匹配完）。
## [AC](https://www.luogu.com.cn/record/226506845) Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int gw(string s) {
    int n=s.size();
    // 第一步：检查长度是否为偶数
    if(n%2!=0){
        return false;
    }
    stack<char>st;
    //第二步：匹配每个字母
    for(int i=0;i<s.size();i++){
        if(!st.empty()&&st.top()==s[i]) 
            st.pop(); //遇到相同字母出栈
        else st.push(s[i]);
    }
    return st.empty(); 
}
int n,sum;
int main(){
    scanf("%d",&n);
    while(n--){
        string w;
        cin>>w;
        sum+=gw(w);//统计“好单词”的个数
    }
    printf("%d",sum);
    return 0;
}
```

---

## 作者：LTL_MJJ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P13414)
# 解析
观察题目，不难发现以下规则：
1. 设字符串 $P$ ,如果 $P$ 是两个相同的字母，则 $P$ 为“好单词”。
2. 设字符串 $P$,$Q$，若 $P$,$Q$ 均为“好单词”,则字符串 $PQ$ 和字符串 $QP$ 为“好单词”。
3. 设字符串 $P$，若 $P$ 为“好单词”，则字符串`A`P`A`或`B`P`B`为“好单词”。

（因为如果相同字符的弧线不相交，这些弧线要么并列，要么一个弧在一个弧的上方或下方。）

这些规则可以构造出任何一个“好单词”，我们可以根据这些规则和性质推断出本题做法是**栈**。~~（而不是看标签）~~

将一个字符串 $P$ 的每个字符入栈：

- 当出现两个相同字符时，根据规则一，这是一个“好单词”，根据栈的性质和规则二三，接下来无论入栈什么字符，都不会使这个“好单词”变坏，所以直接将这两个字符出栈。
- 因为每次入栈时，我们都会判断或出栈，所以一个字符入栈时，可以确定，这个字符的入栈前栈中没有“好单词”，因此如果已经将字符全部入栈，而栈中**没有没**出栈的字符，说明这是一个“好单词”，反之，则不是。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n;
string s[114];
int cheak(string a){
	int len=a.size(),cnt=0;
	char x[N];//栈 
	for(int i=0;i<len;i++){
		x[++cnt]=a[i];
		if(cnt>1){
			if(x[cnt]==x[cnt-1]) cnt-=2;//出栈
		}
	}
	if(cnt>0) return 0;//坏单词
	else return 1;//好单词
}
int main(){
	cin >> n;
	int ans=0;
	for(int i=1;i<=n;i++){
		cin >> s[i];
		ans+=cheak(s[i]);//如果是好单词，+1，否则+0
	}
	cout << ans;
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/226457857)

---

## 作者：b__b (赞：0)

~~笑点解析：[官方 std 写错了，而且错的离谱](https://codeforces.com/blog/entry/101747)。~~

我们肯定是希望弧的长度尽可能短（因为越长就越有可能与其他的弧相交），于是我们考虑只要有可能就画弧连接两个字母。

我们循环遍历字符串。对于每一个字符，如果上一个未匹配的字符跟这个字符相同，那么就可以连接（因为中间的其他字符一定在这之前与这个字符之前的字符连接画弧了，这条弧一定能包含这些弧，不会相交）。否则我们就增加一个未匹配的字符（因为如果与之前的字符连接，那么中间这一个字符所画的弧就会与这条弧相交）。

最后，如果没有未匹配的字符就代表这个字符串满足条件。

实现时，我们可以用一个栈存储未匹配的字符，满足条件就弹出，不满足条件就压入。
```cpp
#include <cstdio>
char s[100005];
int stack[100005];
int main() {
    int n, ans = 0;
    for (scanf("%d", &n); n--;) {
        while ((fgets(s, 1e5 + 5, stdin), s[0]) != 'A' && s[0] != 'B');
        int stsiz = 0; //栈的大小
        for (int i = 0; s[i] == 'A' || s[i] == 'B'; ++i) if (stsiz && stack[stsiz - 1] == s[i]) --stsiz;
        else stack[stsiz++] = s[i];
        if (!stsiz) ++ans;
    }
    printf("%d", ans);
}
```

---

## 作者：zhoujunchen (赞：0)

我们可以用栈做。

首先如果字母 $A$ 的数量或字母 $B$ 的数量为奇数，那么不可能匹配。

维护一个栈，如果栈顶元素与当前元素相同那么弹出，否则就将这个元素扔进去，如果到最后栈是空的那么可以匹配。

结合样例 3 理解。

栈 $stk$ 现在是空的（左边栈底，右边栈顶）。


第一个字符 $A$，扔进去，$stk= \texttt{A}$。

第二个字符 $B$，扔进去，$stk=\texttt{AB}$。

第三个字符 $B$，与栈顶元素相同，弹出栈顶，$stk=\texttt{A}$。

第四个字符 $A$，与栈顶元素相同，弹出栈顶，$stk$ 内无元素。

第五个字符 $B$，扔进去，$stk=\texttt{B}$。

第六个字符 $B$，与栈顶元素相同，弹出栈顶。

栈内无元素，所以可以成功配对。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
string s;
bool florr(){
	cin>>s;
	int ca=0,cb=0;
	for(int i=0;i<s.size();i++)if(s[i]=='A')ca++;else cb++;
	if(ca%2||cb%2)return 0;
	stack<int> stk;
	for(int i=0;i<s.size();i++){
		if(stk.size()&&stk.top()==s[i])stk.pop();
		else stk.push(s[i]);
	}
	return stk.empty();
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	while(n--)ans+=florr();
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：xiaowenxu_qwq (赞：0)

# 思路

这道题其实就是括号匹配的改编版，定义一个栈来存储字母，如果栈顶与下一个字母相同就出栈，否则入栈。最后判断栈是否为空，栈为空即为“好单词”，反之不是（记得最后要将栈清空）。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<char>s;
int ans;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
signed main()
{
	int n=read();
    while(n--){
    	string c; 
        cin>>c;
        int len=c.length();
        for(int i=0;i<len;i++){
			if(!s.empty()){
	            if(s.top()==c[i])
	                s.pop();
	            else
	                s.push(c[i]);
			}
			else{
				s.push(c[i]);
			}
        }
	    if(s.empty())
	        ans++;
	    while(!s.empty())//多测不清空，自己两行泪
	        s.pop();
    }
    printf("%d",ans);
    return 0;
} 
```

如果只拿了 20 分的话，建议使用字符串输入。

---


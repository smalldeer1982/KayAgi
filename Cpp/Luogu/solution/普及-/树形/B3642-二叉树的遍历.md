# 二叉树的遍历

## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好树这棵二叉树之后，依次求出它的前序、中序、后序列遍历。

## 样例 #1

### 输入

```
7
2 7
4 0
0 0
0 3
0 0
0 5
6 0```

### 输出

```
1 2 4 3 7 6 5
4 3 2 1 6 5 7
3 4 2 5 6 7 1 ```

# 题解

## 作者：ShanCreeperPro (赞：50)

# B3642 二叉树的遍历 題解

**管理员注：**

阅读本文章前，请先阅读[$ \ \texttt{ShanCreeper}$ B 题库题解的声明](https://www.luogu.com.cn/blog/Ru19Free/AboutBProblem)，并了解由于课程需要不展示 C++ 代码。

**如需系统学习相关知识点请报名【[洛谷-基础算法计划](https://class.luogu.com.cn/)】**



***

首先你要知道什么是树。

树形结构：

- 不仅能表示数据间的指向关系；
- 还能表示出数据层次关系；

例如一棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/4d18etw0.png)

不好意思，放错了，是这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/mm0ivcwi.png)


这种结构成为**树**，树有以下概念：

- 结点：这颗树上的每一个数字都是一个**结点**；
- 根结点：这棵树的最顶端叫做**根结点**；
- 叶子节点：除了根结点的节点都是**叶子结点**；

- 父结点：一个结点能指向另一个结点的结点叫做**父结点**；
- 兄弟结点：若干个结点同时拥有同个**父结点**的结点叫做**兄弟结点**；
- 子结点：父结点指向的那个结点叫做**子结点**；
- 祖先：一个结点的父结点及其所有父结点都为该结点的**祖先**；
- 子树：以该结点的子结点为根结点的树叫做**子树**。

可能讲的有点抽象，大概能理解就行了。

***

那么这道题问的是二叉树，那什么是二叉树呢？

**二叉树**是树的一种，是每个结点都**不超过两个子结点**的树。

二叉树的每个结点，可能有：

- **左子结点**和**左子树**；
- **右子结点**和**右子树**；

***

好接下来讲这道题。

对于任意给定结点，可以访问**该结点本身**、**遍历左子树**、**遍历右子树**。

我们就可以分为**前序遍历**、**中序遍历**、**后序遍历**。

**前序遍历**（先序遍历）：

- 先访问**根节点**；
- 然后访问**左子树**；
- 最后访问**右子树**。


例如这棵：

![](https://cdn.luogu.com.cn/upload/image_hosting/kvjugl4m.png)


我们按照**根左右**的顺序遍历：

- 先访问**根结点**，**1**；
- 访问**左子树**，即以 2 为根结点的树：
	- 先访问**根结点**，**2**；
    - 访问**左子树**，即以 3 为根结点的树：
    	- 先访问**根结点**，**3**；
        - 访问**左子树**，即以 4 为根结点的树：
        	- 先访问**根结点**，**4**；
            - 无左子树、无右子树，该树**遍历完成**。
        - 访问**右子树**，即以 5 为根结点的树：
        	- 先访问**根节点**，**5**；
            - 无左子树、无右子树，该树**遍历完成**。
        - 根左右遍历完成，该树**遍历完成**。
    - 访问**右子树**，即以 6 为根结点的树：
    	- 先访问**根结点**，**6**；
        - 无左子树、无右子树，该树**遍历完成**。
    - 根左右遍历完成，该树**遍历完成**。
- 访问**右子树**，即以 7 为根结点的树：
	- 先访问**根结点**，**7**；
    - 根左右遍历完成，该树**遍历完成**。
    
就是这么遍历的，所以前序为 $1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 $。

中序遍历为：先遍历**左子树**，然后为**根结点**，最后遍历**右子树**。

后序遍历为：先遍历**左子树**，然后遍历**右子树**，最后为**根结点**。

***

所以（嘿嘿嘿我放非 C++ Code）：

**前序遍历**：

- 首先输出根结点，即 $x$；
- 然后遍历左子树，即 $\text{tree}_i.\text{left}$；
- 最后遍历右子树，即 $\text{tree}_i.\text{right}$；


```go
func pre_order(x int){
	fmt.Print(x)
	if tree[x].left==0{
		pre_order(tree[x].left)
	}
	if tree[x].right==0{
		pre_order(tree[x].right)
	}
}
```

注意，当左子树和右子树存在时，才能继续递归。

**中序遍历**：

- 首先遍历左子树；
- 然后输出根结点；
- 最后遍历右子树；

```go
func in_order(x int){
	if tree[x].left==0{
		in_order(tree[x].left)
	}	
	fmt.Print(x)
	if tree[x].right==0{
		in_order(tree[x].right)
	}
}
```

**后序遍历**：

- 首先遍历左子树；
- 然后遍历右子树；
- 最后输出根结点；

```go
func post_order(x int){
	if tree[x].left==0{
		post_order(tree[x].left)
	}
	if tree[x].right==0{
		post_order(tree[x].right)
	}
	fmt.Print(x)	
}
```

---

## 作者：云裳 (赞：29)

**管理员注：**

阅读本文章前，请先阅读 [chwu 关于 B 题库的声明](https://www.luogu.com.cn/blog/chwu/chwu-about-B-Prob)，并了解由于课程需要不展示代码。

如需系统学习相关知识点请报名【洛谷 - 基础算法计划】

点赞上文章即代表您已阅读并熟知其内容。


------------

**题意**

给定一棵树，求出它的前序、中序、后序列遍历。

**思路**

首先，要明白前序、中序、后序列遍历分别是什么。

------
- 前序遍历：

1. 访问**根节点**。
2. 遍历**左子树**。
3. 遍历**右子树**。

如图：![](https://cdn.luogu.com.cn/upload/image_hosting/fvvtez1u.png)

--------
- 中序遍历

1. 遍历**左子树**。
2. 访问**根节点**。
3. 遍历**右子树**。

如图：![](https://cdn.luogu.com.cn/upload/image_hosting/lpmoyo7z.png)

-----------

- 后序遍历
1. 遍历**左子树**。
2. 遍历**右子树**。
3. 访问**根节点**。

如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/ur6nim0a.png)

-----

代码实现：

- 建立结构体，包含左子树与右子树。
- 读入 $n$ 。
- 接下来的 $n$ 行，读入结构体类型的数组 $tree_i$ 的左子树和右子树。
- 对于先序遍历，建立 $front$ 函数，参数设为 $x$，先输出 $x$，如果 $tree_x$ 拥有左子树，进行递归 $tree_x$ 的左子树，右子树一样。
- 对于中序遍历，建立 $mid$ 函数，参数设为 $x$，先判断 $tree_x$ 拥不拥有左子树，有的话进行递归 $tree_x$ 的左子树，然后输出 $x$，最后判断右子树并递归。
- 对于后序遍历，建立 $back$ 函数，参数设为 $x$，如果 $tree_x$ 拥有左子树， 进行递归 $tree_x$ 的左子树，然后判断右子树并递归 ，最后输出 $x$。

---


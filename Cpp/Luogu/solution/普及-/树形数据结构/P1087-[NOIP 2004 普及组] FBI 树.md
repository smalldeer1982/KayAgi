# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# 题解

## 作者：耶梦加得 (赞：40)

## 一个函数也没有的代码来啦！
在输入的过程中，对于第 k*(2^n) 个数， 我们可以直接把它和兄弟节点“合并”之后**直接输出直接替换**作为父节点
![箭头表示与兄弟节点“合并”为父节点](https://cdn.luogu.com.cn/upload/pic/61476.png)
##### 在一条链上（用箭头表示）的元素都用同一个变量存储

替换的具体方法是：当节点本身与兄弟节点不同时， 父亲节点为F ~~显而易见~~

否则， 两个节点相同，则父节点就是右子节点（即不变）

因为是后序遍历，所以输出两个子节点就可以直接输出父亲啦！

```
#include<bits/stdc++.h>
using namespace std;
int fbi[1025], n;
int p2[11] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}; // 打表2的次方
int main() {
    cin >> n; char t;
    for(int i = 1; i <= p2[n]; ++i) {
        cin >> t; 
        fbi[i] = t - '0';
        if(fbi[i] == 0)printf("B"); 
  		else if(fbi[i] == 1)printf("I"); 
  		else printf("F");
        for(int k = 1; k < 11; ++k) {//合并过程
            if(i % p2[k] == 0){
                if(fbi[i] != fbi[i - p2[k - 1]])fbi[i] = 2;
                if(fbi[i] == 0)printf("B"); 
  		else if(fbi[i] == 1)printf("I"); 
  		else printf("F");
            }
        }
    }
    return 0;
}
```
要注意的是合并过程中k的初值**千万不能设为0**~~不然节点1和谁合并呢~~

还有就是不要不小心输入整数类型，而且千万不要用getchar()（看我的提交记录就知道了）

---

## 作者：yhqajj (赞：8)

## 题解：P1087 [NOIP 2004 普及组] FBI 树
### 很明显这是一道递归
 刚学完的递归，拿来献丑了，~~还希望该题解可以过~~，我这个代码为了方便把所有把变量名都名明为字典序排列结果改的时候没加注释害了自己。
- ###  递归函数:
    如果子串长度为一，直接返回对应的类型。否则，子串从中间分开，递归处理左右子串，并根据左右子树的类型确定当前子串的类型。最后输出当前子串的类型。
---
第一个题解质量~~稍差~~，请谅解。

---

## 满分代码：
```cpp
#include <iostream>
#include <string>
using namespace std;//输入字符串。
string a;//递归函数哈，用于构建并输出后序遍历，稍乱，谅解。
char b(int c, int d) {
    //当前子串的起始位置。
    //当前子串的结束位置。
    if (c == d) {//如果子串长度为一，直接返回对应的类型。
        if (a[c] == '0') {
            cout << 'B';
            return 'B';
        } else {
            cout << 'I';
            return 'I';
        }
    }
    int e = (c + d) / 2;//中间位置。
    char f = b(c, e);//左子树的类型。
    char g = b(e + 1, d);//右子树的类型。
    char h;//当前子串的类型。
    if (f == 'B' && g == 'B') {
        h = 'B';
    } else if (f == 'I' && g == 'I') {
        h = 'I';
    } else {
        h = 'F';
    }
    cout << h;
    return h;
}
int main() {
    int N;
    cin >> N;
    cin >> a;
    int j = a.length();//字符串的长度。
    b(0, j - 1);//调用递归函数构建并输出后序遍历。
    return 0;//终于完事了。
}
```
~~求求你让我过吧~~。

---

## 作者：DeepSeekR1 (赞：7)

直接完全模拟题目的操作，`DFS` 到树的叶子就直接构造出这个叶子。

```cpp
char dfs (int l,int r) {
    if (l == r) {
          //叶子
	      return;
    }
    int mid = (l + r) >> 1;
    char L = dfs(l,mid),R = dfs(mid + 1,r);
    //向下搜索
}
```

搜完叶子向上合并答案。注意到只有两个 `B` 串才能合并出一个 `B` 串，`I` 串同理。

```cpp
if (L == 'B' && R == 'B') {
    cout << 'B';
    return 'B';
} else if (L == 'I' && R == 'I') {
    cout << 'I';
    return 'I';
} else {
    cout << 'F';
    return 'F';
}
```

输入后直接从根节点也就是 $(1,2^n)$ 的串开始搜即可。代码如下。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
string s;
char dfs (int l,int r) {
	if (l == r) {
		if (s[l] == '0') {
			cout << 'B';
			return 'B';
		} else {
			cout << 'I';
			return 'I';
		}
	}
	int mid = (l + r) >> 1;
	char L = dfs(l,mid),R = dfs(mid + 1,r);
	if (L == 'B' && R == 'B') {
		cout << 'B';
		return 'B';
	} else if (L == 'I' && R == 'I') {
		cout << 'I';
		return 'I';
	} else {
		cout << 'F';
		return 'F';
	}
}
signed main () {
	cin >> n >> s;
	s = ' ' + s;
	dfs(1,1 << n);
	return 0;
}
```

---

## 作者：dingcx (赞：6)

好多大佬都是边算边输出，然而我太弱了，只好分开做。

**我这个思路有点像——**

## 线段树

~~是不是很奇葩？~~

方法：

1.定义一个数组(a)记录每个节点的状态，0表示B，1表示I，2表示F；

2.读入应该读数组最底层 $2^{n}$到$2^{n+1}-1$，然后从$2^n-1$到$0$依次一层一层遍历；

3.输出从1往后遍历，到最底层就输出，左右子节点都遍历完了也输出。

提示：位运算节省大量时间，代码中1<<n相当于$2^{n}$，i<<1相当于2i，i<<1|1相当于2i+1

如果还没懂，请看下面的超短代码：

```cpp
#include<cstdio>
using namespace std;
int a[5000],n,s[3]={'B','I','F'};//打表输出
char c;//下面输入用
void dfs(int fa){//递归输出，建议先看main函数
	if(fa>=(1<<n)){//边界条件：如果到底层
		printf("%c",s[a[fa]]);//输出
		return;//直接返回
	}
	dfs(fa<<1);//遍历左子节点
	dfs(fa<<1|1);//遍历右子节点
	printf("%c",s[a[fa]]);//输出此节点
}
int main(){
	scanf("%d\n",&n);
	for(int i=(1<<n);i<(1<<(n+1));i++){
		scanf("%c",&c);//必须用字符输入
		a[i]=c-'0';//转换成树并存进数组
	}
	for(int i=(1<<n)-1;i>0;i--){//往根节点遍历
	    if(a[i<<1]==a[i<<1|1]) a[i]=a[i<<1];//只有都为0或1时不是2
		else a[i]=2;//否则都是2
	}
	dfs(1);//输出
	return 0;//华丽结束
}
```

---

## 作者：_xzhdsnh1364 (赞：4)

题意不用多讲了吧，直接进入正题。

# SOLUTION

我们直接通过这个代表树的 01 串按题意进行递归，我们分两种情况讨论。

- 此时递归到的子树 01 串长度等于 $1$。
- 此时递归到的子树 01 串长度大于 $1$。

第一种情况直接按题意判断当前子树的字符。

第二种情况就将子树分成两个长度相等的 01 串继续递归，如果两个递归结果一样就按照题意存下结果，不一样就是 `F`。

最后记得输出并返回结果。

# CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
char build(string x){//递归
    char c;
    int p = x.size();
    if(p == 1){
        if(x == "1")c = 'I';
        else c = 'B';
    }else{
        char l = build(x.substr(0 , p / 2)) , r = build(x.substr(p / 2));//分成两个长度相同子串递归
        if(l == r)c = l;
        else c = 'F';
    }
    cout << c;
    return c;
}
int main(){
    cin >> n >> s;
    build(s);
    return 0;
}
```

---

## 作者：__CJY__ (赞：4)

题目其实很简单，直接按照题意递归模拟就完事了。
## 思路
定义一个递归函数 $\operatorname{solve}(l,r)$，其中 $l,r$ 表示当前子串的起始和结束索引。这个函数负责构造索引在 $[l,r]$ 里的子串对应的子树，并返回该子树的类型。

函数里面是这样的：
* 我们将子串分为左右两部分，用 $mid$ 来表示中间值。
* 处理左右子树，分别为 $\operatorname{solve}(l,mid),\operatorname{solve}(mid+1,r)$。
* 处理根节点：
  * 遍历 $[l,r]$，统计 $0$ 和 $1$ 的个数，分别记作 $c_0,c_1$。
  * 如果 $c_0>0 \land c_1>0$，输出 `F`；否则如果 $c_0>0$，输出 `B`；否则，输出 `I`。

主函数里面调用 $\operatorname{solve}(0,2^n-1)$ 即可（这是下标从 $0$ 开始的代码，若下标从 $1$ 开始，则为 $\operatorname{solve}(1,2^n)$）。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;int n;
void solve(int l,int r){
	int mid=(l+r)/2,c0=0,c1=0;
	if(l!=r) solve(l,mid),solve(mid+1,r);
	for(int i=l;i<=r;i++){
		if(s[i]=='0') c0++;
		else c1++;
	}
	if(c0&&c1) cout<<'F';
	else if(c0) cout<<'B';
	else cout<<'I';
}
int main(){
	cin>>n>>s,solve(0,pow(2,n)-1);
}
```

---

## 作者：2789617221guo (赞：2)

## 做法
- 字符串，深度优先搜索和二叉树。
## 思路
我的做法是读入 01 串后开始 `dfs`，`dfs` 的定义为 `void dfs(int pos,int x,string str)`，其中 `pos` 代表当前这位是 FBI 树的第几个节点，`x` 代表剩余 01 串的长度，`str` 则为剩余的 01 串。

首先可以很快判断出 `dfs` 函数的出口：即当 `x==1` 时，因为只有 1 个 01 字符了，我们可以很快判断出当前节点是 I 还是 B。如果 `x!=1` 时，我们可以使用 string 类型的内置函数 `substr` 先求出左右子 FBI 树的 01 串，再进行 `dfs`，其中左子树的 `pos` 按照惯例就是 `pos*2`，右子树就是 `pos*2+1`。

不知道为什么，我在 `dfs` 函数中边处理边输出会有错误，所以我又专门定义了一个函数 `print` 用来打印 FBI 树，内容还是大差不差，若有左子树，就先 `dfs` 左子树；若有右子树，就再 `dfs` 右子树，最后输出 `tree[pos]`。

**温馨提醒：建议把常量 $N$ 设大一点，一开始我卡着 $2^{10}+5$ 的数据范围 RE 了一个点。**
## 代码
```cpp
#include <bits/stdc++.h>
#define i64 long long
#define u64 unsigned long long
#define endl '\n'

using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;
const int N = (1 << 20) + 5;

int n;
string s;
char tree[N];

inline i64 read() {
    i64 x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

inline void dfs(int pos, int x, string str) {
    if (x == 1) {
        if (str == "1")
            tree[pos] = 'I';
        else
            tree[pos] = 'B';
        // cout << tree[pos];
        return;
    }
    string lft = str.substr(0, x / 2);
    string rgt = str.substr(x / 2, x / 2);
    dfs(pos * 2, x / 2, lft);
    dfs(pos * 2 + 1, x / 2, rgt);
    if (tree[pos * 2] == tree[pos * 2 + 1]) {
        if (tree[pos * 2] == 'I')
            tree[pos] = 'I';
        else if (tree[pos * 2] == 'B')
            tree[pos] = 'B';
        else
            tree[pos] = 'F';
    } else
        tree[pos] = 'F';
}

inline void print(int root) {
    if (tree[root * 2] == 'F' || tree[root * 2] == 'B' || tree[root * 2] == 'I')
        print(root * 2);
    if (tree[root * 2 + 1] == 'F' || tree[root * 2 + 1] == 'B' ||
        tree[root * 2 + 1] == 'I')
        print(root * 2 + 1);
    cout << tree[root];
}

int main() {
    cin >> n >> s;
    dfs(1, 1 << n, s);
    print(1);
    return 0;
}
```
## AC 记录
[AC 记录。](https://www.luogu.com.cn/record/210467888)

---

## 作者：GeorgeDeng (赞：2)

### 题目大意

给定一个 01 串，先按长度为 $1$ 划分成 $2^N$ 段，然后两两合并，可以构造出一棵满二叉树，输出它的后续遍历。对于每一段，如果全 0 输出 `B`，全 1 输出 `I`，有 0 有 1 输出 `F`。

### 题目分析

如果光看上面那句话可能有点抽象。我们看一下样例对应的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/wfxkeadu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这样就非常明显了。区间长度都是 $2^k$，然后可以构造成一颗树。最后输出这棵树的后续遍历即可。

怎样做这道题呢？我们可以把样例中的 01 串存进一个字符串里，然后进行递归。递归的边界条件就是子串长度为 $1$，每次传进去目前递归的子串。为了 ~~偷懒~~ 求出答案，我们将函数的返回值修改成整数，如果返回 $0$，那么这个子串就是一个全 0 串；如果返回 $1$，那么这个子串就是全 1 串；否则就是 01 混合串。这有什么用呢？在递归的时候，把当前遍历的子串一份为二，进行下一轮递归。左子树递归传回来的返回值计为 $ansa$，右子树递归传回来的返回值记为 $ansb$。如果 $ansa=ansb=0$，那么这一整个子串就是全 0 串，输出 `B`，并返回 $0$；如果 $ansa=ansb=1$，那么这一整个子串就是全 1 串，输出 `I`，并返回 $1$；如果 $ansa\ne ansb$，说明这个子串有 0 有 1，输出 `F`，返回 $2$。因为它是边递归边输出的，所以在主函数里面就不用再输出了。

**注意：边界条件也要判断是什么串，不能不输出叶子节点。**

剩下的非常简单了，直接上代码！

### code:


```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int dfs(string s){//递归，如果全0返回0，全1返回1，其他情况返回2
	if(s.length()==1){//递归边界
		if(s[0]=='0'){//判断，这里不能少
			cout<<'B';
			return 0;
		}else{
			cout<<"I";
			return 1;
		}
	}
	string a,b;//存两个子串的，因为本蒟蒻不会substr，所以只好使用for循环代替
	for(int i = 0;i<s.length();i++){
		if(i<s.length()/2){
			a+=s[i];
		}else b+=s[i];
	}
	int ansa = dfs(a),ansb = dfs(b);//递归并保存答案
	if(ansa==0&&ansb==0){//如果全0
		cout<<"B";
		return 0;
	}else if(ansa==1&&ansb==1){//如果全1
		cout<<"I";
		return 1;
	}else{//其他情况
		cout<<"F";
		return 2;
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	string s;
	cin>>s;
	dfs(s);//递归，这里的返回值可以忽略不记
	return 0;
}


```

---

## 作者：tengteng666666 (赞：2)

**不难看出，这道题考的是递归建树。**  
### 递归的过程：
1. 先遍历当前字符串，判断当前字符串是 FBI 中的哪一个。
2. 如果当前的字符串长度大于1，就根据题意将字符串分成两段，再将这两个字串当成左子树和右子树，接着递归建树。由于字符串长度为 $2^N$ 所以不用考虑奇数的情况。
3. 题目要求输出后序遍历序列，所以要在递归后输出。


## 好，话不多说，我奉上代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
string s; 
void DFS(string s){
	char c='0';//当前字符串的种类 。 
	for(int i = 0;i<s.size()-1;i++){//0~n-1,因为要判断i和i+1 。 
		if(s[i] != s[i+1]){
			c = 'F';
			break;
		}
	}
	if(c!='F'){
		if(s[0] == '1')c = 'I';
		else c = 'B';
	}
	if(s.size()>1){//递归建树 。 
		string a;//考虑到很多新手都不会fill，我就用for循环解决好了。 
		for(int i = 0;i<s.size()/2;i++){//左子树。 
			a += s[i];
		}
		DFS(a);
		a ="";
		for(int i = s.size()/2;i<s.size();i++){//右子树。 
			a+=s[i];
		}		
		DFS(a);
	}
	cout<<c;//后序输出 
}
signed main(){
	cin>>n>>s;
	DFS(s);
	return 0;
}
```

---

## 作者：Ybll_ (赞：1)

# 思路：

类似**线段树**哈，

因为题目要求的这棵树上的每一个点代表所给字符串的一个区间，

但其实也就只是一个**建树**的操作。

这种建树函数有以下几步：

1. 如果该节点表示的区间为一个点，那么给该节点赋值后返回；

2. 调用该函数建左儿子，若当前节点的编号为 $id$，所表示区间的左右端点分别为 $L$ 和 $R$，那么左儿子编号为 $id\times2$，所表示区间的左右端点分别为 $L$ 和 $\frac{\lfloor L+R \rfloor}{2}$；

3. 调用该函数建右儿子，若当前节点的编号为 $id$，所表示区间的左右端点分别为 $L$ 和 $R$，那么右儿子编号为 $id\times2+1$，所表示区间的左右端点分别为 $\frac{\lfloor L+R \rfloor}{2}+1$ 和 $R$；

4. 根据左右儿子的值为该节点赋值。

看不懂的可以看看代码注释。

然后在写个 DFS [后序遍历](https://baike.baidu.com/item/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/1214806)就行了。
# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;char ans[1000005];string s;
void build(int id,int l,int r){//建树 
	if(l==r){ans[id]=s[l];return;}//区间为一个点，赋值后返回 
	int mid=l+r>>1;
	build(id*2,l,mid);//建左儿子 
	build(id*2+1,1+mid,r);//建右儿子 
	if(ans[id*2]==ans[id*2+1])ans[id]=ans[id*2];//赋值 
	else ans[id]='F';
}
void dfs(int id,int l,int r){//后序遍历 
	if(l==r){cout<<ans[id];return;}
	int mid=l+r>>1;
	dfs(id*2,l,mid),dfs(id*2+1,mid+1,r);
	cout<<ans[id];
}
int main(){
	cin>>n>>s,n=pow(2,n),s=' '+s;
	for(int i=1;i<=n;i++)s[i]=s[i]=='1'?'I':'B'; 
	build(1,1,n);
	dfs(1,1,n);
	return 0;
}
```

---

## 作者：Eason_lyx (赞：1)

题意简单易懂，递归模拟即可。
### 00 前置知识
- [find 函数（字符串查找）](https://blog.csdn.net/2201_75539691/article/details/145100177)
- [substr 函数（字符串切分）](https://blog.csdn.net/weixin_42240667/article/details/103131329)
### 01 思路
1. 读入 01 字符串 $s$。
2. 递归建树：先确定根节点类型，再依次递归左、右子树。
3. 后序输出。

**超级详细**的注释，请看代码。
### 02 代码
#### 注释版
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;//字符串
int n;//长度：2^n
char a[11000];//树
char types(string q){//判断字符串的类型
    if(q.find('0')==-1)//全 1 串称为 I 串
        return 'I';
    if(q.find('1')==-1)//全 0 串称为 B 串
        return 'B';
    return 'F';//既含 0 又含 1 的串则称为 F 串
}
void build_fbi(string q,int root){
    if(root>=(1<<n+1)||q=="")return;//递归边界条件
    a[root]=types(q);//处理根节点
    build_fbi(q.substr(0,q.size()/2),root*2);//递归构造左子树
    build_fbi(q.substr(q.size()/2),root*2+1);//递归构造右子树
}
void bout(int k){//后序输出
    if(a[k]=='0')return;//边界
    bout(k*2);//左
    bout(k*2+1);//右
    cout<<a[k];//中
}
int main(){
    memset(a,'0',sizeof a);//初始化 不然 RE
    cin>>n>>s;//输入
    build_fbi(s,1);//建树
    bout(1);//输出
    return 0;
}
```
#### 无注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,len;
char a[11000];
char types(string q){
    if(q.find('0')==-1)
        return 'I';
    if(q.find('1')==-1)
        return 'B';
    return 'F';
}
void build_fbi(string q,int root){
    if(root>=(1<<n+1)||q=="")return;
    a[root]=types(q);
    build_fbi(q.substr(0,q.size()/2),root*2);
    build_fbi(q.substr(q.size()/2),root*2+1);
}
void bout(int k){
    if(a[k]=='0')return;
    bout(k*2);
    bout(k*2+1);
    cout<<a[k];
}
int main(){
    memset(a,'0',sizeof a);
    cin>>n>>s;
    build_fbi(s,1);
    bout(1);
    return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/210438434)

~~又是写大水题题解的一天。~~

---

## 作者：Doraeman (赞：1)

## 递归构造
题目已经告诉我们递归构造的方法，按照题目说的做。  
1. 由字符串 $S$ 得到树 $T$ 的根节点。
2. 继续拆分字符串 $S$，得到树 $T$ 的左子树和右子树。
## 详解
### 后序遍历
后序遍历方法：左右根。  
即在左、右子串遍历结束之后输出根节点。

如果 $S$ 的长度只有 $1$，那么显然不能继续拆分 $S$，此时需要特殊处理。

我们接下来就可以按照这个顺序处理字符串 $S$。
### 特殊处理
如果 $S$ 长度是 $1$，为 $0$ 时是 B 类型，为 $1$ 时是 I 类型。直接输出。
### 左子串遍历
直接求 $S$ 的一半，前一半用于左子树遍历。

注：因为 $|S|=2^N$，所以一定可以找到一半。
### 右子树遍历
同上，后一半进行右子树遍历。
### 根节点
字符串 $S$ 是什么类型，就输出什么类型。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 15;

bool B(string s){
    for(int i=0; i<s.size(); i++)
        if(s[i] == '1') return 0;
    return 1;
}
bool I(string s){
    for(int i=0; i<s.size(); i++)
        if(s[i] == '0') return 0;
    return 1;
}

void dfs(string s){
    int m = s.size();
    
    // 特殊处理  
    if(m == 1){
        if(s == "0") cout << 'B';
        else cout << 'I';
        return;
    }
    
    // 左、右子树遍历  
    int mid = m / 2;
    dfs(s.substr(0, mid));
    dfs(s.substr(mid, mid));
    
    // 输出根节点  
    if(B(s)) cout << 'B';
    else if(I(s)) cout << 'I';
    else cout << 'F';
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    
    int n; cin >> n;
    string s; cin >> s;
    
    dfs(s);
}
```

---

## 作者：Chengqijun2012 (赞：1)

一道很经典的递归造树题。

前置知识：[substr（截取子串）](https://blog.csdn.net/weixin_42240667/article/details/103131329)。

### 题目步骤：
1. 读入一个 $\texttt{01}$ 串 $s$。
2. 根据题目可得 FBI 树是二叉树，因此我们考虑把 $s$ 平均分成两份然后递归；当分到长度只剩 $1$ 时，直接输出 $\text B$ 或 $\text I$。当递归回来时，输出这一整个子串的分类。

由于 $\texttt{01}$ 串的长度是 $2^{N}$，所以不用担心出现 $\texttt{01}$ 长度是奇数的情况。

如果想要更详细的解释，请看代码注释。

AC Code：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int n;
string s;

char check(string a){      //输出函数
	bool F = 0, B = 0, I = 0;
	for(int i = 0; i < a.size(); i++){
		if(a[i] == '0') B = 1;      //如果有B，标记B为1
		if(a[i] == '1') I = 1;      //如果有I，标记I为1
		if(B && I) F = 1;      //如果B和I都有，标记F为1
	}
	if(F) return 'F';      //如果B和I都有，返回F
	return (B ? 'B' : 'I');      //否则返回B或I，这里等价于if(B == 1) return 'B'; else return 'I';
}

void make_FBI_tree(string a){      //递归造树
	if(a.size() == 1){      //如果a的长度已经为1，就不能再分下去了
		cout << check(a);      //直接输出
		return;
	}
	int h = a.size() >> 1;      //a.size() >> 1等价于a.size() / 2
	make_FBI_tree(a.substr(0, h));      //截取a的前半段再递归
	make_FBI_tree(a.substr(h));      //截取a的后半段再递归
	cout << check(a);      //因为是后序遍历，所以输出放最后面
}

int main(){
	cin >> n >> s;
	make_FBI_tree(s);
	cout << "\n";
    return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道模拟题。考查递归和二叉树。

先建树，再输出后序遍历。

可以将读入的序列看成二叉树的叶子节点，若节点 $i$ 的左右儿子分别是 $2i$ 和 $2i+1$，那么叶子就是从 $2^n$ 到 $2^n-1$，然后递归建树，顺序是先建左右儿子再建根。建树中叶子已经建过了，不用再建了。对于一个节点，若其左右儿子不同，它一定是 $F$；若相同，则和儿子一样。

后序遍历的顺序是左右根。

实现的话，建树和输出分开写就很好理解。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
char c, t[2050];
int n;
void build (int u) {
	if (u>=(1<<n)) 	
		return;
	build(u*2);
	build(u*2+1);
	t[u]=(t[u*2]==t[u*2+1]?t[u*2]:'F');
}
void dfs (int u) {
	if (u<(1<<n)*2) // 超过叶子的范围
		dfs(u*2),
		dfs(u*2+1),
		cout << t[u];
}
int main () {
	cin >> n;
	for(int i = (1<<n); i<2*(1<<n); i++)
		cin >> c, 
		t[i]=(c=='1'?'I':'B');
	build(1);
	dfs(1);
	return 0;
}
```

---

## 作者：qsn123 (赞：0)

这题理论上来说是考二叉树的，但是呢，当时我做这道题的时候刚刚学完线段树，于是......

小知识：线段树的递归建树过程就是一个后序遍历，所以我们可以直接用线段树的建树函数改造得到这道题的答案。

具体的，我们将整个串输入，之后像线段树递归那样，在这个 $01$ 串上建树，建好之后，按照题意合并两个子节点的对应串：

1. 对于叶子节点，若是 $0$ 就为 $B$ 串，反之为 $I$ 串。
2. $B+B=B,I+I=I,B+I=F,I+B=F,F+(B/I/F)=F$

按照上面的小知识，当求出每一个节点对应的类型时，直接输出，最终得到的就是答案。

上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10050;
char sgt[N]={0};
void build(int tt,string s)
{
	if(s.size()==1)
	{
		if(s[0]=='0')sgt[tt]='B';
		else sgt[tt]='I';
		cout<<sgt[tt];
		return ;
	}
	int mid=s.size()/2;
	build(tt*2,s.substr(0,mid));
	build(tt*2+1,s.substr(mid,mid));
	if(sgt[tt*2]=='I'&&sgt[tt*2+1]=='I')sgt[tt]='I';
	else if(sgt[tt*2]=='B'&&sgt[tt*2+1]=='B')sgt[tt]='B';
	else sgt[tt]='F';
	cout<<sgt[tt];
	return ;
}
int main()
{
	int n;
	string s;
	cin>>n;
	cin>>s;
	build(1,s);
	return 0;
}
```

---


# 新二叉树

## 题目描述

输入一串二叉树，输出其前序遍历。


## 样例 #1

### 输入

```
6
abc
bdi
cj*
d**
i**
j**```

### 输出

```
abdicj```

# 题解

## 作者：scholar20551 (赞：301)

# 题解
  这篇题解是我专门为新人写的（我真是臭不要脸我也是新人），也不用关注我，我闲的没事也不发题解，心血来潮来赚取一点活跃分。题解来之不易，且看且珍惜。（有什么可以改进的地方随时提出就好了，谢谢各位大佬）
  
  至于思路，是我根据单词方阵的启发（好歹我曾经也是一个橙名的男人，十几天没登录就…………）
  其实这题还是很好的，很好做，还可以锻炼手速，做对了还能提高信心，作为一名蒟蒻我还是很容易受打击的。

  废话不多说（但我还是说了不少废话……），上题解


```cpp



#include<iostream> 
#include<cstdio>//不管，就是喜欢这个头文件，长得太好看了 
using namespace std;
struct programmer//struct定义，好把树的节点连接起来，具体可以看代码呀 
{
	char lc;//左孩子X1（left child，简称lc） 
	char rc;//右孩子X1（right child，简称rc） 
}lt[130];//数组，这个十分重要，一会儿输入字符的时候还要用这个串起来，其实真正起作用的只有lt[73]~lt[122],说这个是为了防止一些人不多想，方便理解的
char h,h1;//储存一会儿要输入的节点，多定义一个h1是为了一会儿将根节点保留下来先代入函数
void sm(char x)//我是谁，我杀了谁，谁又杀了我 
{
	if(x=='*') return;//如果是*说明此乃空节点，那就不用再往下探了 
	cout<<x;//先把它给输出出来，碰着一个就踢出去一个，输出的顺序是可以保障的，至于为什么可以看后面，我解释了 
	sm(lt[x].lc);//找到他的左孩子，继续往下探（如果左孩子是*的话，会返回的，可以看上一句的上一句） 
	sm(lt[x].rc);//找到他的右孩子，继续向下探索 
/*这里我举个例子： 例如输入abc和bcd,a的ASC码是73，所以lt[73].lc是b（ASC码74），接着再从b开始探，lt[74].lc之前有过输入，是个c。再从序
号为'c'（75）的lt数组继续往下探索，一探索到*,就会往回跑。回到c数组的rc，往回探，所以顺序问题可以保证,要是还是理解不了，可以画画试试，亲测有
效。这个函数和输入其实就是在数组的各个部分之间不断穿梭，用字符的ASC码值作为连接节点的线，数组的左右孩子就是下一个要寻找的数组的代号*/ 
}
int main()
{
	int n;//n在题目上说了，输入几个节点 
	scanf("%d",&n);//为了方便大家观看，我把输入拆成三部分 
	cin>>h1;//输入第一个字母，第一个字母比较特殊，所以单独输入 
	cin>>lt[h1].lc;//左孩子，h1所代表的字符再次会转换为ASC码 
	cin>>lt[h1].rc;//右孩子，道理和上面相同，就不用我多费口舌了 
	for(int i=2;i<=n;i++)//这里大家都懂的吧，输入 
	{
		cin>>h;
		cin>>lt[h].lc;
		cin>>lt[h].rc;
	}
	sm(h1);//进入函数，用的是递归，但我也是AC了才敢来发题解的 
	return 0;
}
```

---

## 作者：javalyc (赞：183)

这题数据也是水得可以啊，第一个节点总是根节点，读入完不用建树就可以直接搜索了。

代码简单易懂，感觉跟树一点关系都没有：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[30][3];
void f(char x)
{
    if(x!='*')
    {
        cout<<x;
        for(int i=1;i<=n;i++)
            if(a[i][0]==x)
            {
                f(a[i][1]);
                f(a[i][2]);
            }
    }
    return;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    f(a[1][0]);
    return 0;
}
```

---

## 作者：huang_yue (赞：68)

好像还没有用到自己表示的字符加到两个子树的指针的方法建立树的呢……

那我就来补充一个






```cpp
#include<iostream>
#include<algorithm>
using namespace std;
//没加析构函数，可能是我写的不对，加了就会运行错误
struct Tree { //树的结构
    char me; //自己的字符
    Tree* left; //左子树
    Tree* right; //右子树
    Tree(char w =0): me(w), left(0), right(0) {} //构造函数
} tree; //最终建立的树
inline Tree* build(char w) { //建立一个新的结点，以w作为自己的字符
    if (w == '*') return 0; //如果是'*'，说明不应该创建子树（见下面代码）
    return new Tree(w);
}
Tree* find_tree(char w, Tree* start = &tree) { //在start这棵树中找到字符为w的节点
    if (start->me == w) return start; //自己就是，直接返回
    Tree* ans = 0;
    if (start->left) ans = find_tree(w, start->left); //递归查找，start->left就相当于start->left != 0，而0是build()返回表示没有子树的值
    if (ans) return ans;
    if (start->right) ans = find_tree(w, start->right);
    return ans;
}
void preorder(Tree* start) { //先序遍历： 根节点 + preorder(左子树) + preorder(右子树)
    cout << start->me;
    if (start->left) preorder(start->left); //注意检查有无子树
    if (start->right) preorder(start->right);
}
int main() {
    int n; cin >> n;
    char me, l, r; cin >> me >> l >> r; //me: 自己的字符， l: 左边的字符， r: 右边的字符
    tree.me = me; tree.left = build(l); tree.right = build(r); //各自创建子树
    for (int i = 1; i < n; ++i) {
        char me, l, r; cin >> me >> l >> r;
        Tree* node = find_tree(me); //找到根节点
        node->left = build(l); node->right = build(r); //建立子树
    }
    preorder(&tree); //输出先序遍历
    return 0;
}
```

---

## 作者：wuhao1027 (赞：48)

发现每道题目里面C的题解都是最少的，有时候几乎都没有。那么我就来写一个吧。

作为一个大一的萌新，二叉树目前还是自学的，老师还没有讲到。所以我用的方法很规矩，不像别的题解一样，新手可以从这里学到基础。不过这一题风格是C，但C会编译错误，这是因为struct的尿性。。。

```cpp
#include<stdio.h>
#include<string.h>
struct node{         //定义node类型
    char lc,rc,fa;   //分别有它的左儿子，右儿子和父亲
};
node tree[1000];
void work(char s)
{                              //简单的递归
    printf("%c", s);
    if (tree[s].lc!='*') work(tree[s].lc);
    if (tree[s].rc!='*') work(tree[s].rc);
}
int main()
{
    int i,n;
    char c,fir;
    scanf("%d", &n);
    for (i=1;i<=n;i++){    //在这里我本来要用while循环，但是这样的话就保留不了树根的位置，所以用了for
        scanf(" %c", &c);
        if (i==1) fir = c;
        scanf(" %c%c", &tree[c].lc,&tree[c].rc);
        tree[tree[c].lc].fa = tree[tree[c].rc].fa = c;
    }
    work (fir);
    return 0;
}
```

---

## 作者：sycqwq (赞：31)

__这题建议刚学二叉树的初学者来做，不然根本看不懂__

首先来普及一下，什么是先序遍历？

__先序遍历__ 先遍历根节点，在遍历左子树，右子树。

假设有一颗二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jpsaild3.png)

先遍历a节点，接下来遍历它的左子树。

遍历b节点，在遍历它的左儿子d。

遍历d节点，并没有孩子，返回节点b，节点b没有右孩子，返回节点a，遍历右子树。

遍历c节点，再遍历他的左子树。

遍历e节点，并没有左子树，遍历右子树。

遍历f节点，并没有孩子，返回到根节点，遍历结束。

遍历结果是：abdcef。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{//定义二叉树结构体
	string data;//自身
	int l,r;//左孩子和右孩子的数组下表。
	
}t[1005];
int n;
void xx(int k)//先序遍历
{
	cout<<t[k].data;//遍历根节点
	if(t[k].l!=0)//如果有左孩子的话，遍历左孩子
		xx(t[k].l);
	
	if(t[k].r!=0)//如果有右孩子的话，遍历右孩子
		xx(t[k].r);
        
		
}
int main(){
	cin>>n;
	int rt;//根节点的下标
	for(int i=1;i<=n;i++)
	{
		char a,b,c;
		cin>>a>>b>>c;
		if(i==1)//第一个输入的是根节点，储存其下标，为其在26个字母中的位置
			rt=a-'a'+1;
		t[a-'a'+1].data=a;//储存
		/*下面为确定父子关系*/
      		if(b!='*')//如果有左儿子
		{
			t[b-'a'+1].data=b;//存储左儿子
			t[a-'a'+1].l=b-'a'+1;//记录左儿子的下标
		}
		if(c!='*')//同上，记录右儿子
		{
			t[c-'a'+1].data=c;
			t[a-'a'+1].r=c-'a'+1;
		}
	}
	xx(rt);//从根节点开始先序遍历
	return 0;
}

```

---

## 作者：Redstone红石粉 (赞：17)

首先说明 本题数据范围为a-z 26个小写字母 以及\*

直接将字母减去96 转化为int存储就行了。

输入完毕后，扫一遍找父亲为0的点就是根节点。

从根结点开始 递归，前序遍历，每到一个点直接输出即可。


代码不长——

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
struct tree{int l,r,fa;}T[30];
int n,root;
string c;
void visit(int k){
    char ch = k + 96; printf("%c",ch);
    if(T[k].l!=0) visit(T[k].l);
    if(T[k].r!=0) visit(T[k].r);
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>c;
        if(c[1]!='*') {T[c[0]-96].l = c[1]-96; T[c[1]-96].fa = c[0]-96;}
        if(c[2]!='*') {T[c[0]-96].r = c[2]-96; T[c[2]-96].fa = c[0]-96;}
    }
    for(int i=1;i<=26;i++) if(T[i].fa==0){root=i; break;}
    visit(root);
    return 0;
}
```

---

## 作者：Malachite (赞：15)

# P1305 新二叉树 题解
很水的一道二叉树的题。其实并不需要真正利用在程序中构造二叉树进行求解的思路，而是利用二叉树的性质，找出规律，从而得出结果。

首先让我们看到题目：
## 题目描述
**输入一串二叉树，用遍历前序打出。**

一看这个题目，似乎还无法得出一个规律。不过我们产生了问题：如何输入这一串二叉树？

## 输入格式
**第一行为二叉树的节点数**$n$。$(n≤26)$。

**后面n行，每一个字母为节点，后两个字母分别为其左右儿子。**

**空节点用星号表示。**

这样似乎就明了了：二叉树好像是通过这几种形式输入的：

- 父亲 左儿子 右儿子
- 父亲 儿子 星号
- 父亲 星号 星号

## 输出格式
**前序排列的二叉树。**

既然要求这样输出，那么我们就可以寻找一下前序排列的规律：

在只有一个节点的情况下，这棵树长这样：
![1](https://s2.ax1x.com/2019/08/22/mwEKi9.png)

它的前序排列自然是这样： ` A ` 

如果有了两个节点，则会变成这样：

![2](https://s2.ax1x.com/2019/08/22/mwEma4.png)

前序排列为： ` AB `

有了三个节点，会变成这样：

![3](https://s2.ax1x.com/2019/08/22/mwEnIJ.png)

前序排列为： ` ABC `

似乎还没有看出什么端倪。不过，让我们继续向下发展这棵二叉树：

![4](https://s2.ax1x.com/2019/08/22/mwEeZF.png)

前序排列： ` ABDC `

等等，怎么……顺序发生了一些变化？不再是依字母表顺序排列了？

再来！

![5](https://s2.ax1x.com/2019/08/22/mwEMGR.png)

前序排列： ` ABDEC `

原来规律是这样！

**每次第一个输入的序列（根节点及其子节点） 直接被加入前序中；**

**后续有两种儿子的，则忽略 “ 星号 ” 字符，将左儿子插入序列中其父亲节点后的一位，将右儿子插入序列中其左儿子节点的后一位。**

**仅有一种儿子的（表现形式为 父亲 儿子 星号 ），就简单将其儿子插入父亲节点的后一位即可。**

**找到父亲节点或左儿子的方法很简单：通过 ` string ` 类的这个成员函数即可完成：**
```cpp
int find(string s);
```
这个成员函数的作用是**返回子字符串s在原串中的位置**。如果找不到，则返回：
```cpp
string::npos
```
这个常量。（这个常量在不同的编译器中，有不同的值，虽然有些时候是 -1 ，但是可能其他时候会出差错。因此，我们在这里不写-1，而写这个常量更为保险。）

然后，我们再使用这个类里面的另一个函数 ` insert ` 向指定的位置插入代表子节点的字符：
```cpp
void insert(int position,int length,string s);
```
它的作用是 **从字符串中的第position个位置开始，插入length个字符，这些字符来源于s** 。 

这样，我们就可以得到这题的代码！

### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string t;
int n;
string s;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		if(t.find(s[0])==string::npos){t=s;continue;}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout<<t<<endl;
}
```
##### 你觉得一次就能AC了？
#### 并不是！
### 实际上！
## 这个只有20分！！！
![x1](https://s2.ax1x.com/2019/08/22/mwmhAU.png)
为什么？为什么只有20分？

很简单。下载数据后，你会发现这是因为这份代码没有考虑到这种数据的存在：

**“指示根节点及其子节点的第一行就含星号 ！！！”**

这种数据会带来什么影响？

**你的程序将把“ 星号 ”当作一种子节点！！！**

于是，之后的输出就完全混乱了。毕竟，由于第一行是特判全部输入，“ 星号 ”这样的鬼东西都被插进了字符串里面。

不过这样一来，你就找到了修改的思路：

使用 ` string ` 类的这个成员函数： ` erase ` ！
```cpp
void erase(string::iterator start,string::iterator end);
```
直接运用它，产生的作用其实是消除**一个字符串中的一段连续的长度**。那么怎么达到消除**全部指定字符**（此处为标明了根节点及其儿子的字符串中的 “ * ” ）呢？

使用 ` algorithm ` 库中的 ` remove ` 函数！
```cpp
iterator remove(iterator start,iterator end,auto c);
```
有了这个，我们就能够不断地清除字符串中的目标字符，并不断返回指向其未被删除元素的下一个元素的迭代器，从而使用erase函数清除它。

于是，我们得到了用于**清除一段字符串中全部指定字符**的完整代码：
```cpp
erase(remove(string::iterator start,string::iterator end,char c),string::iterator end);
```
那么，新的代码也呼之欲出了！

### 新代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string t;
int n;
string s;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout<<t<<endl;
}
```
##### 你又觉得这次就能AC了？
#### 并不是！
### 其实！
## 这个只有30分！！！
![x2](https://s2.ax1x.com/2019/08/22/mwm4NF.png)

~~才多过了一个点啊……~~

这次又是为什么？？！

下载数据后发现，这次是栽在了一种之前**从未考虑到的输入情况**上。

这次导致出错的输入数据为：

- 父亲 星号 儿子

……

~~这也太坑了吧~~

我们为了AC此题，只能继续努力了……

这次更改并不需要什么新的技术，只需要添加几个判断即可绕过大坑。

### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string t;
int n;
string s;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*'&&s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
			t.insert(t.find(s[1])+1,1,s[2]);
		}
		if(s[1]=='*'&&s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[2]);
		}
		if(s[1]!='*'&&s[2]=='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
		}
	}
	cout<<t<<endl;
}
```
看着屏幕上蓝色方块上转着白色的圈圈，你想到：之前（指20分变30分那次）做了那么大的修改，才多过了一个点，想必这个算法还存在很多问题吧……难不成还得再重写几次？？！

然后……

![v](https://s2.ax1x.com/2019/08/22/mwK3hF.png)

？？？？？？

## 过了？？！就过了？？？？？！

历经千辛万苦，终于过了啊……~~（接受现实）~~

~~bilibili干杯！（好像并没有什么不对）~~

---

## 作者：Maktub (赞：8)

第一次做二叉树的题，这个题可以算是二叉树的模板题吧。

首先要明白二叉树中先序，中序，后序遍历的概念。

其实这里的先，中，后都是根节点出现的位置，其他都是左子树先于右子树遍历。注意这里左子树和右子树也适合子树，也就是说遍历是递归进行的。

例如样例：（自己画个图感性理解一下）

先序为 abdicj

中序为 dbjacj

后序为 dbicja

我们用lson[],rson[]来存节点的两个儿子，那么先序遍历就可以这么写：

```
inline void print(char root){
	cout<<root;
	if(lson[root]!='1')print(lson[root]);
	if(rson[root]!='1')print(rson[root]);
}
```
（因为懒的变成数字就直接全部char，反正不影响什么）

（这里的 1 是我初始化的，如果lson[root]=='1'就是以当前节点没有左子树）

中序遍历和后序遍历只要改一下根输出的位置就好了，就像上面说的。

那么问题来了，根节点这么判？（虽然这个题的数据很水，第一个就是根）

想想用数字处理树找根的时候，没有父亲的就是根，我们也可以这么做，在读入的时候标记父亲。

这时又来了一个问题，如果一个字母不在树上，那么它也没有父亲，怎么判断a~z中那些是节点呢？

将输入的字符标记一下就可以了。很容易想到map。

综上，这个题就很好的解决了。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
const int mx=222;
int n;
map<char,int>b;
char lson[mx],rson[mx],fa[mx];
inline void print(char root){
	cout<<root;
	if(lson[root]!='1')print(lson[root]);
	if(rson[root]!='1')print(rson[root]);
}
int main(){
	cin>>n;
	for(char i='a';i<='z';i++)fa[i]='1',lson[i]='1',rson[i]='1';//初始化
	string s;
	for(int i=1;i<=n;i++){
		cin>>s;
                b[s[0]]=1;
		if(s[1]!='*'){
			lson[s[0]]=s[1];fa[s[1]]=s[0];b[s[1]]=1;
		}
		if(s[2]!='*'){
			rson[s[0]]=s[2];fa[s[2]]=s[0];b[s[2]]=1;
		}
	}
	char root;
	for(char i='a';i<='z';i++){
		if(b[i]&&fa[i]=='1'){
			root=i;break;
		}
	}
	print(root);
	return 0;
}
```


---

## 作者：Register (赞：8)

## 这道题难的就是如何寻找根节点
~~虽然看了看一楼的题解好像第一个节点就是根节点~~

因为每个节点的数据都是小写字母a到z中的一个，所以我们可以直接用数组下标记录是什么字符，减少了遍历所有字符来寻找儿子的繁琐步骤

定义一个结构体，肯定会有两个指针分别指向左儿子和右儿子

可是光凭左儿子和右儿子这两个指针是无法确定这个节点是不是根节点的，因此我们可以再定义一个节点father确定这个节点的父亲

找到根节点后，直接前序遍历递归输出

奉上代码：
```cpp
#include <iostream>
using namespace std;
struct node{
    char l,r,father;
}tree[30];//节点的结构体
void preorder(char data){
    cout<<data;//输出这个节点的数据
    if(tree[data-97].l!='*') preorder(tree[data-97].l);//遍历左子树
    if(tree[data-97].r!='*') preorder(tree[data-97].r);//遍历右子树
}
int main(){
    int n;
    cin>>n;
    char root='*';//初始化根节点
    for(int i=0;i<26;i++) tree[i].father='*';//初始化每一个节点的父亲
    for(int i=1;i<=n;i++)
    {
        char data,lc,rc;
        cin>>data>>lc>>rc;//输入XX节点的左儿子和右儿子
        if(root=='*') root=data;//将根节点赋值
        tree[data-97].l=lc;tree[data-97].r=rc;//赋值左儿子和右儿子
        if(lc!='*') tree[lc-97].father=data;if(rc!='*') tree[rc-97].father=data;//将左右儿子赋值父亲
    }
    while(tree[root-97].father!='*') root=tree[root-97].father;//寻找根节点
    preorder(root);cout<<endl;//前序遍历输出
    return 0;
}
```

---

## 作者：Randyhoads (赞：8)

因为这个树不会太大，所以我们用一个结构去存储他本身，指向他左儿子的指针和右儿子的指针，

静态的分配好内存，对于一个节点，如果他是一个没有出现的节点，就把这个节点加入到数组tree中

判断他出现过没，我用了一个map，如果说一个节点的儿子有‘\*’，就把他赋值为NULL，

每次遍历时，先输出根节点，如果有儿子就输出，是个典型的DFS








    

    
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
    int num;
    char data;//数据
    node * left;//指向他的左儿子
    node * right; //指向他的右儿子
};
node tree[10001];
int n;
int top;
map<char,int>ma;//存储当前的节点出现过没
void qx(int i)
{
    cout<<tree[i].data;
    if(tree[i].left!=NULL)
    qx(tree[i].left->num);
    if(tree[i].right!=NULL) 
    qx(tree[i].right->num);
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        char a1,a2,a3;
        cin>>a1>>a2>>a3;
        if(ma.count(a1)==0)//如果没有出现过，就给他一个在tree数组里的编号
        {
            ++top;
            ma[a1]=top;
        }
        if(ma.count(a2)==0&&a2!='*')
        {
            ++top;
            ma[a2]=top;
            tree[ma[a2]].num=ma[a2];
        }
        if(ma.count(a3)==0&&a3!='*')
        {    ++top; 
            ma[a3]=top;
            tree[ma[a3]].num=ma[a3];
        } 
        tree[ma[a1]].data=a1;
        tree[ma[a1]].num=ma[a1];
        if(a2!='*')
        tree[ma[a1]].left=&tree[ma[a2]];
        else tree[ma[a1]].left=NULL;//如果为‘*’，代表没有子节点
        if(a3!='*')
        tree[ma[a1]].right=&tree[ma[a3]];
        else tree[ma[a1]].right=NULL;
    }
    qx(1); //前序遍历
}
```

---

## 作者：Jezemy (赞：4)

这题也可以**不用树来做**。因为是**前序遍历**。

这里先说明一下，每行三个字母，我在这称三个字母分别叫root，left，right

比如abc意思是说在节点root为a的位置，往其左边left插入b，右边插入c

接下来以样例来举例：

第一行：abc - >此时前序遍历为：abc

第二行: bdi - >此时前序遍历为：abdic

第三行：cj* - >此时前序遍历为：abdicj

...

有没有发现其实除了第一行，从第二行开始其实只要找到root的位置，然后往其后面添加left和right即可

比如第二行，此时的前序遍历为abc，找到b后，往b后增加d和i，前序遍历就变为abdic

再比如第三行，此时前序遍历为abdic，找到点c，往c后增加j，前序遍历变为abdicj

而存储这些过程中的前序遍历就是一个**链表**。因此不用创建树。

有人可能就要说了，不创建树但是要创建链表啊！

对不起我用的是python（逃。。。）

以下是python代码

```python
num = int(input().strip())
res = []
for i in range(num):
	root,left,right = [i for i in input().strip()]
	if root in res:
		index = res.index(root)
	else:
		# 第一行刚开始的时候，res是空的，所以要单独处理
		if root != '*':
			res.append(root)
		if left != '*':
			res.append(left)
		if right != '*':
			res.append(right)
		continue
	# 先右后左，如果先左后右，右的插入位置要变化
	if right != '*':
		res.insert(index+1,right)
	if left != '*':
		res.insert(index+1,left)
print("".join(res))
```
这里insert方法可以在指定位置插入一个元素，类似的方法在java的linkedlist也有。

另外有个坑在于录入的时候**一定要去除两端的空格**！！！血的教训

---

## 作者：rui_er (赞：4)

# 方法简述

虽然不用建树，我还是建了一个，用的是顺序存储结构（数组）

```cpp
char tree[501];
```

# 头文件

```cpp
#include <iostream>
#include <memory.h>
#include <map>
using namespace std;
```

其中memory.h是为memset做准备的（我说的是memset，后面没有0！开个玩笑）

# 建树

```cpp
char tree[501];
map<char, int> k;

memset(tree, '*', 501);
int n;
cin>>n;
char a, b, c;
for(int i=0;i<n;i++)
{
    cin>>a>>b>>c;
    if(!i)
    {
        tree[1] = a;
        k[a] = 1;
    }
    k[b] = k[a] * 2;
    tree[k[b]] = b;
    k[c] = k[a] * 2 + 1;
    tree[k[c]] = c;
}
```

memset行用于给tree赋值。

> 听说第一行就是有关根节点的一行

if行用于判断是否为第一行，将根节点写入。k用于存字符出现的下标地址，方便查询一个节点的位置。

# 遍历

```cpp
void DLR(int n)
{
    if(tree[n] == '*') return;
    cout<<tree[n];
    DLR(n*2);
    DLR(n*2+1);
}
```

还记得前文的memset吗？输入的空结点用```*```表示，所以方便起见把树初始化成```*```。如果遇到```*```，则代表该结点不存在，自然就可以退出那个结点了。

根据前序遍历的定义，写出递归函数即可。

# 程序

```cpp
#include <iostream>
#include <memory.h>
#include <map>
using namespace std;

char tree[501];
map<char, int> k;

void DLR(int n)
{
    if(tree[n] == '*') return;
    cout<<tree[n];
    DLR(n*2);
    DLR(n*2+1);
}

int main()
{
    memset(tree, '*', 501);
    int n;
    cin>>n;
    char a, b, c;
    for(int i=0;i<n;i++)
    {
        cin>>a>>b>>c;
        if(!i)
        {
            tree[1] = a;
            k[a] = 1;
        }
        k[b] = k[a] * 2;
        tree[k[b]] = b;
        k[c] = k[a] * 2 + 1;
        tree[k[c]] = c;
    }
    DLR(1);
    return 0;
}
```

---

## 作者：judgejudge (赞：4)

# 递归子程序题解（最普遍做法）
这道题其实就是不断递归的过程，我们只需要在递归程序里按照**根——左——右**的顺序展开递归就可以辽！！！

奉上AC代码：
```cpp
#include <iostream>
using namespace std;
char a[1000];
char l[1000];
char r[1000];
int i,j;
void dfs(char x){
	int s;
	cout<<x;//直接输出
	s=x;//这里是我的亮点，因为不想用结构体，直接把a[i]的ASCLL码当作数组的指针
	if(l[s]!='*')dfs(l[s]);//一定要判断不为*
	if(r[s]!='*')dfs(r[s]);//先左后右
	return;
}
int main(){
	int k,n,s;
	cin>>n;
	for(i=1;i<=n;i++){
	    cin>>a[i];
		s=a[i];//ASCLL码当作数组指针，比较通俗易懂吧？
		cin>>l[s]>>r[s];
	}
	dfs(a[1]);
}
```

---

## 作者：zzsqwq (赞：4)

qwq感觉这个数据真的好水

第一个输入的总是根节点 所以这个程序就可以莫名水过了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

#define ll long long
#define G ch=getchar()
#define rd(x) x=qread()

using namespace std;
const int maxn = 205;
char ch;
char a,b,c;
int n;
struct node
{
	int right,left;
}r[maxn];
inline int qread()//qwq习惯
{
	int f=1,x=0;G;
	while(!(ch>='0'&&ch<='9')){if(ch=='-')f=-1;G;}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';G;}
	return f*x;
}
void print(int now)
{
	if(now==(int)'*') return ;
	cout<<char(now); //输出当前节点的值
	print(r[now].left);//输出左树
	print(r[now].right);//输出右树
}
int main()
{
	int k;
	rd(n);
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b>>c;
		if(i==1) k=a;//第一个输入的总是根节点
		r[a].left=b;//存左节点的地址
		r[a].right=c;//存右节点的地址
	}
	print(k);//从根节点开始打印
    return 0;
}

```

---

## 作者：wz441135118 (赞：3)

### 这题很水
因为是按从上到下的顺序输入二叉树的，而每组元素中的第二个数都是第一个元素的左子树，第三个元素则是右子树，所以只要不停的先找一个元素的左子树，再找右子树就可以了。直到找不到了就可以直接输出每组的最前面的元素。
这应该是挺短了的。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char q[30][3]; //模拟节点
int a;
void dfs(int sum)
{
	cout<<q[sum][0];
	for(int i=1;i<3;i++)   //先找左边，再找右边
		for(int j=0;j<a;j++)//枚举，因为数据很小
			if(q[sum][i]==q[j][0])
				dfs(j);    // 简单的递归
}
int main(){
    cin>>a;
    for(int i=0;i<a;i++) cin>>q[i];
    dfs(0);
    return 0;
}
```



---

## 作者：Clouder (赞：3)

这道题似乎由于数据太水的缘故，第一个字母始终是根节点……  
而且字母全都是小写字母……  
~~很多题解都是面向数据编程~~  
如果首字母不是根的话，需要加入一个找根的步骤。  
找根直接统计每个点是否有父亲即可。  
用hasfa数组记录是否有父亲，用exist数组记录是否有这个字母出现过，最后遍历一遍找到出现过却没父亲的字母就是根。  
为了方便，我直接开了256大小的数组，跟用map差不多吧。  
自己造了一组数据，有兴趣的可以跑一下：  

![Example](https://cdn.luogu.com.cn/upload/image_hosting/btsu3z0j.png)
## input
```
5
c**
DBe
AcD
B**
e**
```
## output
```
AcDBe  
```
# Code
```cpp
#include <cstdio>
using namespace std;
bool hasfa[256],exist[256];
int ls[256], rs[256];
int n;
void dfs(const int &now)
{
    if (now == '*')
        return;
    putchar(now);
    dfs(ls[now]);
    dfs(rs[now]);
}
char a[5];
int main()
{
    scanf("%d", &n);
    while (n--)
    {
        scanf("%s", a + 1);
        exist[a[1]] = exist[a[2]] = hasfa[a[2]] = exist[a[3]] = hasfa[a[3]] = true;
        ls[a[1]] = a[2];
        rs[a[1]] = a[3];
    }
    for (int i = 1;i <= 255; ++i)
        if (exist[i] && !hasfa[i])
        {
            dfs(i);
            return 0;
        }
}
```

---

## 作者：LordLeft (赞：3)

树形数据结构的题怎么可以没有图呢？

我们先来看一下样例给的这一棵二叉树

![](https://cdn.luogu.com.cn/upload/pic/62188.png)

（这里用有向边方便统计入度）

题目要求先序遍历，首先要知道，先序遍历是按照  根->左儿子->右儿子  的顺序遍历这棵树

很明显，答案是a->b->d->i->c->j

那么我们只要从树的根开始递归求出这个顺序就行了

由于我们记录的是有向边，并且从父亲指向儿子，所以入度为0的节点就是整个树的根

具体细节见代码

```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
const int N=30;
int n;
bool is[N];
//n个节点并不是连续的，is数组记录哪些字母出现过
int in[N];
//统计入度
int son[N][2];
//记录每个节点的左右儿子
int root;	
//整个树的根
void search(int x){
//核心代码，递归输出先序遍历
	putchar(x+'a'-1);
	//输出根
	if(son[x][0]){
		search(son[x][0]);
		//递归左儿子
		}
	if(son[x][1]){
		search(son[x][1]);
		//递归右儿子
		}	
	}
int main(){
	cin>>n;
	string s;
	for(int i=1;i<=n;i++){
		cin>>s;
		int u=s[0]-'a'+1,v1=s[1]-'a'+1,v2=s[2]-'a'+1;
		//字母转数字存储
		is[u]=1;
		if(s[1]!='*'){
			//如果有左儿子
			is[v1]=1;
			son[u][0]=v1;
			in[v1]++;
			}
		if(s[2]!='*'){
			is[v2]=1;
			son[u][1]=v2;
			in[v2]++;
			}	
		}
	for(int i=1;i<=26;i++){
		if(is[i]&&!in[i]){
			//找根，找到后可以直接退出循环
			root=i;
			break;
			}
		}
	search(root);	
	//递归
	return 0;
	}
```

GL~

---

## 作者：SKTT1Faker (赞：3)

p党的好少，我来一个题解吧。

我和别人不一样，我是先构树，再利用树的前序遍历特点来深搜输出。

我们先开俩个数组，来储存每个节点的左孩子与右孩子。

虽然这道题第一个输入必是根节点，但是我这个算法也可以判断不是根节点的情况。






```cpp
var
a,i,j:longint;
x:string;
w:char;
left,right:array['a'..'z'] of char;         //左，右孩子数组
v,n:array['a'..'z'] of boolean;        //判断数组
procedure dfs(z:char);          //深搜输出
begin
  if z='*' then exit;      //     到叶节点结束
  write(z);
  dfs(left[z]);        //  搜左子树
  dfs(right[z]);     //搜右子树
end;
begin
  readln(a);
  for i:=1 to a do
  begin
    readln(x);
    for j:=1 to 3 do
    if x[j]<>'*' then v[x[j]]:=true;
    if x[2]<>'*' then n[x[2]]:=true;
    if x[3]<>'*' then n[x[3]]:=true;          //注意，把为''*''的情况去掉，不然数组会出错
    left[x[1]]:=x[2];
    right[x[1]]:=x[3];
  end;
  for w:='a' to 'z' do
  if (v[w]) and (n[w]=false) then dfs(w);       //因为根节点只有一个，所以可以放心输出
end.
```
就怎么简单。
抄袭可耻，理解至上


---

## 作者：核弹头AC (赞：3)

先读入，再用dfs来一步一步判定，一步一步走。

注意：读入用long long，不用int!（不然会爆！）

每一步走一下即可

代码如下：

```cpp
    #include <bits/stdc++.h>
    using namespace std;
    string a[10001];
    long long n;
    void dfs(char x)
    {
        printf("%c",x);
        for(long long i=1;i<=n;i++)
        {
            if(a[i][0]==x)
            {
                break;
            }
        }
        for(long long j=1;j<3;j++)
        {
            if(a[i][j]!='*')
            {
                dfs(a[i][j]);
            }
        }
    }
    int main()
    {
        scanf("%lld",&n);
        for(long long i=1;i<=n;i++)
        {
            scanf("%s",a);
        }
        dfs(a[1][0]);
        return 0;
}
```

---

## 作者：JamesHen (赞：2)

# 内存管理模式

## 虽然算法已然老套，但写一个对机器友好的指针程序，很有必要！！！

主要方式：使用 node \* occuredlist[ ] 数组管理申请的内存， 而 node \* 指针管理着节点。

建树以后就可以 dfs 了。

贴代码如下：

```cpp
#include <iostream>
using namespace std;

struct node                                                 //存贮节点
{
        node * left;                                              //左右儿子
        node * right;
        char val;
        node(): left(NULL), right(NULL), val('0'){}   //默认构造，以便判断
};

node * occuredlist[100];                              //内存池
int lenth(0);                                                 //节点数

void dfs(node * father)                                //先序遍历
{
            cout << father->val;
            if (father->left != NULL && father->left->val != 0) dfs(father->left);
            if (father->right != NULL && father->right->val != 0) dfs(father->right);
}

int main()
{
            for (int i(0); i < 100; ++i)
                        occuredlist[i] = NULL;
            int sum, root(-1);
            cin >> sum;
            for (int i(0); i < sum; ++i)
            {
                        int pos(-1), left_son(-1), right_son(-1);
                        char a[4];
                        cin >> a;
                        for (int j(0); j < 100; ++j)
                                    if (occuredlist[j] != NULL && occuredlist[j]->val == a[0]) pos = j;
                                    else if (occuredlist[j] == NULL) break;
                        if (a[1] != '*')
                        {
                                    occuredlist[lenth] = new node;
                                    occuredlist[lenth]->val = a[1];
                                    left_son = lenth;
                                    ++lenth;
                        }
                        if (a[2] != '*')
                        {
                                    occuredlist[lenth] = new node;
                                    occuredlist[lenth]->val = a[2];
                                    right_son = lenth;
                                    ++lenth;
                        }
                        if (pos == -1)
                        {
                                    occuredlist[lenth] = new node;
                                    occuredlist[lenth]->val = a[0];
                                    if (left_son != -1) occuredlist[lenth]->left = occuredlist[left_son];
                                    if (right_son != -1) occuredlist[lenth]->right = occuredlist[right_son];
                                    if (i == 0) root = lenth;
                                    ++lenth;
                             }else
                            {
                                    if (left_son != -1) occuredlist[pos]->left = occuredlist[left_son];
                                    if (right_son != -1) occuredlist[pos]->right = occuredlist[right_son];
                        }
            }
            dfs(occuredlist[root]);
            for (int i(0); i < 100; ++i)
            {
                        if (occuredlist[i] == NULL) break;
                        delete occuredlist[i];
            }
            return 0;
}
```

---

## 作者：Tgotp (赞：2)

能不能再水点。两个测试点--忍不住吐槽。

言归正传

建树的话我们用当前字符-‘0’就来表示现在字符的编号-

然后记录下左儿子，有儿子。

因为这是一棵树，所以，查询的时候如果一个点没有父亲节点的话，那么他肯定就是树根，所以从这里开始先序遍历，输出答案就好了！


c++代码如下









```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
char a[3];int n;
struct node
{
    int left,right,fa;
    char a;
}tree[10000];
void add(char a,char b,char c)
{
    tree[a-'0'].a=a;
    if(b!='*')
    {
        tree[b-'0'].a=b;
        tree[a-'0'].left=b-'0';
        tree[b-'0'].fa=a-'0';
    }
    if(c!='*')
    {
        tree[c-'0'].a=c;
        tree[a-'0'].right=c-'0';
        tree[c-'0'].fa=a-'0';
    }
}
void found(int i)
{
    printf("%c",tree[i].a);
    if(tree[i].left)found(tree[i].left);
    if(tree[i].right)found(tree[i].right);
}
void solve()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%s",a);
        add(a[0],a[1],a[2]);
    }
}
void get()
{
    for(int i=a[0]-'0';;i=tree[i].fa)
    {
        if(!tree[i].fa)
        {
            found(i);
            break;
        }
    }
}
int main()
{
    solve();
    get();
    return 0;
}
```

---

## 作者：whrx (赞：2)

本人用map解决的这个水题。。。。。。

        
    
     
```cpp
//#include<iostream>
//#include<cstdio>
//#include<map>      
using namespace std;       //这个不用说吧。。。。
string k;
map<char,char> l,r;      //定义map
void ch(char o)          //用于输出先序的函数（递归）
{
    cout<<o;
    if(l[o]=='*')           //判断是否有子节点，；~~~左一次~~~，~~~右一次~~~，~~~发现节点就搜搜~~~        ；###啦啦啦###
    if(r[o]=='*')
    return;
    else
    ch(r[o]);
    else
    {
    ch(l[o]);
    if(r[o]!='*')
    ch(r[o]);
    }
}
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        l[s[0]]=s[1];                 //存节点及连接到子节点；
        r[s[0]]=s[2];
        k[i]=s[0];
    }
    for(int i=0;i<n;i++)               //找root；
    {
        int j=0,o=0;
        while(j<n)
        {
            if(k[i]==l[k[j]]||k[i]==r[k[j]])
            {
                o=1;
                break;
            }
            j++;
        }
        if(o==0)
        {
            ch(k[i]);
            break;
        }
    }
    return 0;
}
```

---

## 作者：菜弟弟在此 (赞：2)

感觉下面发的都比较复杂，就来个简单点的。

因为求先序遍历的方法类似于深搜，所以打个深搜就行了。

从第一个节点开始找，找到这个节点的行，如果有子节点，就继续查找。

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[10001];
long n;
void pig(char x)
{
    cout<<x;   
    long i,j;
    for (i=1;i<=n;i++)
        if (a[i][0] == x) break;  //找所在行
    for (j=1;j<3;j++)
        if (a[i][j] != '*') pig(a[i][j]);    //深搜
}
int main()
{
    long i,j,m,k;
    cin>>n;
    for (i=1;i<=n;i++)
        cin>>a[i];
    pig(a[1][0]);   //从根节点开始
    while(1) //防抄袭
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

```cpp
var
 a:array['a'..'z',1..2]of char;//a[c,1]表示c的左儿子a[c,2]表示c的有儿子
 n,o:longint;c1,c2,c3:char;
procedure qx(c:char);//求前序排列
 begin
  write(c);//根
  if a[c,1]<>'*' then qx(a[c,1]);//如果有左儿子就遍历左儿子
  if a[c,2]<>'*' then qx(a[c,2]);//如果有右儿子就遍历右儿子
 end;
begin
 readln(n);
 for o:=1 to n do
  begin
   readln(c1,c2,c3);
   a[c1,1]:=c2;//c1左儿子是c2
   a[c1,2]:=c3;//c1右儿子是c3
  end;
 qx('a');//前序
 writeln;//换行
end.
```

---

## 作者：Mys_C_K (赞：2)

注意到似乎没有C++程序……

没什么就是用非指针的树，用字符的ASCII值做下标（羡慕PASCAL）

其余的和指针基本没什么两样，就是树根需要找

```cpp

#include<iostream>
using namespace std;
struct tree{
    int parent;
    int tc,rc;
    tree(){    parent=tc=rc=0;}
}a[27];
void pre(int root)
{
    if(root!=0)
    {
        cout<<char(root-1+'a');
        pre(a[root].tc);
        pre(a[root].rc);
    }
}
int main()
{
    int n;cin>>n;
    for(int i=1;i<=n;i++)
    {
        char ch1;cin>>ch1;
        char ch2;cin>>ch2;
        char ch3;cin>>ch3;
        if(ch2!='*')
        {
            a[ch2-'a'+1].parent=ch1-'a'+1;
            a[ch1-'a'+1].tc=ch2-'a'+1;
        }
        if(ch3!='*')
        {
            a[ch3-'a'+1].parent=ch1-'a'+1;
            a[ch1-'a'+1].rc=ch3-'a'+1;
        }
    }
    int root;
    for(int i=1;i<=n;i++)
        if(a[i].parent==0)
        {
            root=i;
            break;
        }
    pre(root);
    cout<<endl;
    return 0;
}

```

---

## 作者：F_Unction (赞：1)

# 这题有够水 我这个蒟蒻都会
先说说树的遍历的规则吧（学过数据结构都知道的吧）

*	先序遍历根左右
*	中序遍历左根右
*	后序遍历左右根

下面是代码 请勿抄题解
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
    char left;
    char right;
    char value;
} tree[27];
char cs[27];
int n;
int index(char a) //查找字母对应下标
{
    if (a == '*')
        return -1;
    for (int i = 0; i < n; i++)
        if (cs[i] == a)
            return i;
}
void f(int a) //遍历
{
    if (a == -1) //递归出口
        return;
    cout << tree[a].value;//根
    f(index(tree[a].left));//左
    f(index(tree[a].right));//右
    return;
}
int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> tree[i].value >> tree[i].left >> tree[i].right; //输入
        cs[i] = tree[i].value;                                 //记录下字母对应的数组下标
    }
    f(0);
    return 0;
}
```
蒟蒻第一次找了个最简单的题发题解 瑟瑟发抖

---

## 作者：_maze (赞：1)

这其实是一道学习二叉树很经典的题目哈

而我的思路很简单，分三步走：

1、存哪几个字母在里面，谁是孩子（在判断时直接用输入时存的数组就可以了，没必要再开一个）

2、找谁不是孩子但是出现过，这就是根，从此处开始递归

3、由于他让我们求前序（先序）遍历，先输出当前递归的量（父节点），再看他有没有左右两个孩子，如果有，先递归左孩子，再递归右孩子

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[1001];
int n,er[1001],cun[1001],st;//er代表他是不是一个节点的儿子，cun代表他有没有出现过 
void dfs(int u){//不要被这东西误导了，这不是dfs 
	char now=u+'a';//其实可以直接导入字符 
	cout<<now;//输出父节点 
	for(int i=1;i<=n;i++){//在条件中寻找 
		if(a[i][0]==now){//如果这是父节点 
			if(a[i][1]!='*'){//依次查看他有没有左右两个孩子 
				dfs(a[i][1]-'a');//转换，递归
			}
			if(a[i][2]!='*'){
				dfs(a[i][2]-'a');
			}
			break;//节省时间 
		}
	}
}
int main(){
	cin>>n;//输入 
	for(int i=1;i<=n;i++){
		cin>>a[i];//用字符串方便一些 
		if(a[i][1]!='*'){//如果输入的东西不为* 
			cun[a[i][1]-'a']=1;//它存在过 
			er[a[i][1]-'a']=1;//因为最先输的是父亲，所以后来的两个十二子 
		}
		if(a[i][2]!='*'){//判断右节点 
			cun[a[i][2]-'a']=1;
			er[a[i][2]-'a']=1;
		}
		cun[a[i][0]-'a']=1;//父节点肯定不为* 
	}
	for(int i=0;i<26;i++){//在二十六个字母中寻找 
		if(cun[i]==1&&er[i]==0){//如果它存在过又没有当过儿子 
			st=i;//根即为他 
			break;
		}
	}
	dfs(st);//递归就好了 
	return 0;
}

```

我觉得我的代码对新手足够友好了，如有不正尽请指出qwq

---

## 作者：梦里调音 (赞：1)

我的算法：呵呵，我也不知道是什么

反正AC了。

我是用两个一维数组存储每个点的左孩子的编号以及右孩子的编号。

看到数据那么小，秒AC

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
char d[100001],dl[100001],dr[100000001];//这个就是输入的字符
int l[1000001],r[10000001];//这个是用来存储左、右孩子编号
int p[1000001];//这个数组是用来存孩子个数
int prt(int u){//输出的函数
	int c;//c用来在编号中穿梭
	cout<<d[u];//先根，先输出根
	if(dl[u]!='*')c=l[u],prt(c);//再输出左孩子
	if(dr[u]!='*')c=r[u],prt(c);//右孩子
	return 0;
}
int main(){
	int i,j,k,m,n;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>d[i]>>dl[i]>>dr[i];
		p[i]=2;
		if(dl[i]=='*')p[i]--;
		if(dr[i]=='*')p[i]--;
	}//输入比较简单
	for(i=1;i<=n;i++){
		int t=0;
		for(j=1;j<=n;j++)
			if(i!=j){//循环枚举查找左、右孩子的编号
				if(d[j]==dl[i]){
					l[i]=j;
					t++;
				}
				if(d[j]==dr[i]){
					r[i]=j;
					t++;
				}
				if(t==p[i])break;//个数达到则退出循环
			}
	}
	prt(1);//先根
	return 0;
} 
```

---

## 作者：香风智乃 (赞：1)

看到题解上貌似没有  map<char,tree\*> add;  的写法，

本蒟蒻来补充一下（水一发）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct tree{
    char letter;
    tree *left,*right;
    tree(){left=NULL;right=NULL;}     //赋值
}*root,*p,*pleft,*pright;    //root：整棵二叉树的根   p：每一个小二叉树的根  pleft,pright ：左、右儿子的指针
char a[3];
map<char,tree*> add;    //map->存指针
void first(tree *root)   //先序遍历
{
    printf("%c",root->letter);
    if(root->left) first(root->left); 
    if(root->right) first(root->right);
}
int main()
{
    int n,i;
    scanf("%d",&n);
    cin>>a;
    root=new tree;       //第一次输入时根也需要建树（以后的输入都是在前面的基础上），所以单独考虑
    root->letter=a[0];
    if(a[1]!='*')
    {
        pleft=new tree;
        pleft->letter=a[1];
        root->left=pleft;
        add[a[1]]=pleft;   //存储指针 
    }
    if(a[2]!='*')
    {
        pright=new tree;
        pright->letter=a[2];
        root->right=pright;
        add[a[2]]=pright;
    }
    for(i=2;i<=n;i++) 
    {
        cin>>a;
        p=add[a[0]];    
        if(a[1]!='*')
        {
            pleft=new tree;
            pleft->letter=a[1];
            p->left=pleft;
            add[a[1]]=pleft;
        }
        if(a[2]!='*')
        {
            pright=new tree;
            pright->letter=a[2];
            p->right=pright;
            add[a[2]]=pright;
        }
    }
    first(root); //当然是从根开始遍历了
    return 0;
}
```

---

## 作者：attack (赞：1)

这道题我们可以用桶的思想


因为本身就只有26\*2个字符


所以我们可以把输入数据的第一个值当做桶名


然后数组嵌套记录好左右节点和父亲节点


找到根节点后递归即可


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
struct node
{
    char pa;
    char data;
    char lc,rc;
}a[10001];
int vis[201];
int root=-1;
int xianxu(int i)
{
    printf("%c",i);
    if(a[i].lc!='*')
    xianxu(a[i].lc);
    if(a[i].rc!='*')
    xianxu(a[i].rc);
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        char data;
        cin>>data;
        cin>>a[data].lc>>a[data].rc;
        a[a[data].lc].pa=data;
        a[a[data].rc].pa=data;
        vis[data]=1;
    }
    for(int i=1;i<=122;i++)
        if(a[i].lc!=0&&a[i].pa==0)
            root=i;    
    xianxu(root);
    return 0;
}
```

---

## 作者：kingnle (赞：1)

实际上这个题的数据非常的弱，题目指名道姓说是完全二叉树，猜想输入节点是根据完全二叉树层次输入。

直接读取每次输入的第一个字符（也就是根）对应完全二叉树的层次遍历的下标。

例如样例中的数据可以理解为层次遍历：

第一层                    a

第二层             b           c

第三层          d    i      j


代码如下：

···cpp

```cpp
#include<iostream>
#include<string.h>
using namespace std;
char tree[10005]={0};
int n;
void serch(int now)
{
    if(tree[now]!='0'&&now<=n)
    {
        cout<<tree[now];
        serch(now*2);
        serch(now*2+1);
    }
}
int main()
{
    string in;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>in;
        tree[i+1]=in[0];
    }
    serch(1);
    return 0;
}
···
```

---

## 作者：RedContritio (赞：1)

比较水的一道题，一次AC。

在不考虑数据实际有多弱的情况下，我们可以发现，难点有二：

1、先序遍历 // 然而并不难

2、建树

我们用一个长度为 n 的动态节点数组来存储树，从里面动态读取地址。

同时用一个指针来记录 root 的地址。

代码如下：

CPP // 然而改掉头文件基本就是C

#include <cstdio>

#include <cstdlib>

class NODE

{
public :





```cpp
    NODE *l,*r,*p;
    char entity;
};
NODE *FindNode(char entity) , *GetNewNode(char entity) ; // 查询给定名称的节点以及创建新节点
NODE *list ; // 内存区
int used , n ; // 已使用节点，总结点数
NODE* root; // 根节点地址
void dfs(NODE* node); // 先序遍历
int main()
{
    scanf("%d",&n);
    list = (NODE*)calloc(n,sizeof(NODE));
    for(int i=0;i<n;i++)
    {
        char ta,tb,tc;
        scanf(" %c %c %c",&ta,&tb,&tc);
        NODE* a = FindNode(ta);
        if(root == NULL)root = a;
        if(tb != '*')
        {
            NODE* b = FindNode(tb);
            a->l = b;
            b->p = a;
            if(root == b)root = a; // 若子节点为根节点，指针上移
        }
        if(tc != '*')
        {
            NODE* c = FindNode(tc);
            a->r = c;
            c->p = a;
            if(root == c)root = a;// 若子节点为根节点，指针上移
        }
    }
    dfs(root);
}
NODE* FindNode(char entity)
{
    for(int i=0;i<used;i++)
    {
        if(list[i].entity == entity)return &list[i];
    }
    return GetNewNode(entity);
}
NODE* GetNewNode(char entity)
{
    list[used].entity = entity;
    return &list[used++];
}
void dfs(NODE* node)
{
    printf("%c",node->entity);
    if(node->l)dfs(node->l);
    if(node->r)dfs(node->r);
}
```

---

## 作者：吴国铨 (赞：1)

P党的三次遍历，啦啦啦啦




```cpp
program exz;
var a:array['a'..'z',1..2] of char;//用于存储树
    i,n:longint;
    h,x,y,root:char;
//root为一棵树的根节点
procedure dfs1(c:char);//前序遍历
begin
  write(c);
  if a[c,1]<>'*' then dfs1(a[c,1]);
  if a[c,2]<>'*' then dfs1(a[c,2]);
end;
{procedure dfs2(c:char);//中序遍历
begin
  if a[c,1]<>'*' then dfs2(a[c,1]);
  writeln(c);
  if a[c,2]<>'*' then dfs2(a[c,2]);
end;}
{procedure dfs3(c:char);//后序遍历
begin
  if a[c,1]<>'*' then dfs3(a[c,1]);
  if a[c,2]<>'*' then dfs3(a[c,2]);
  writeln(c);
end;}
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(h,x,y);
    if i=1 then root:=h;//确定根节点
    a[h,1]:=x;
    a[h,2]:=y;
  end;
  dfs1(root); writeln;
  //dfs2(root); writeln;
  //dfs3(root); writeln;
end.
//也就这些了，实在没什么好写的
```

---

## 作者：2015wanghongyu (赞：1)

首先我得代码比较好理解，稍微长点，不是最简，也不用我做太多注释，总之就是建好树怎么递归都成。

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
struct node{
    char f,lc,rc,v;//f父亲，左，右，字符。
    bool flagf=0;//由于是结构体，找父亲要用。
};node a[1001];//树
char s[3];
int n,root,lch,rch;//节点数，根节点号，左右孩子号
void findchild(int x)//下面递归中找左右孩子的编号
{
    bool flag1=false,flag2=false;
    for(int i=1;i<=n;++i)
    {
        if(a[i].v==a[x].lc) {lch=i;flag1=1;}
        if(a[i].v==a[x].rc) {rch=i;flag2=1;}
        if(flag1==1&&flag2==1) break;
    }
    if(flag1==0) lch=0;
    if(flag2==0) rch=0;
    return;
}
void preorder(int i)//前序
{
    if(i)
    { 
        cout<<a[i].v;
        findchild(i);
        preorder(lch);
        findchild(i);//这一步很重要，如果没有会很悲剧，你们可以把这句话去掉调试一下就看出来了。（因为可能左孩子是零，但右不是，没有这句的话右孩子就被跳过去了）
        preorder(rch);
    }
    return;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)//建树
    {
        for(int j=0;j<3;++j) cin>>s[j];
        a[i].v=s[0];
        if(s[1]!='*') a[i].lc=s[1];
        else a[i].lc='0';
        if(s[2]!='*') a[i].rc=s[2];
        else a[i].rc='0';
        for(int j=1;j<=i;++j)//找爸爸
        if(a[i].v==a[j].lc||a[i].v==a[j].rc)
        {
            a[i].f=a[j].v;a[i].flagf=1;
        }
    }
    for(int i=1;i<=n;++i) if(a[i].flagf==0){root=i;break;}//找根
    preorder(root);//递归前序
    return 0;
}
```

---

## 作者：桀骜的野心家 (赞：1)

这道题用一种神奇的方法。a数组储存子节点，b数组储存父亲节点。

```delphi
var a:array['a'..'z',1..2] of char;  
    b:array['a'..'z'] of char;  
    n,i,j,k,l,m:longint;  
    c1,c2,c3,c:char;  
procedure print(c:char);  
begin  
write(c);  //输出父亲节点
if a[c,1]<>'*' then print(a[c,1]);//输出左子树  
if a[c,2]<>'*' then print(a[c,2]);  //输出右子树
end;  
begin  
readln(n);  
fillchar(a,sizeof(a),'*');  
fillchar(b,sizeof(b),'*');  //给数组赋初值，*表示没有父亲节点或子节点
for i:=1 to n do  
    begin  
    readln(c1,c2,c3);  
    if b[c1]='*' then c:=c1;
    if c2<>'*' then  
    begin  
       a[c1,1]:=c2;  
       b[c2]:=c1;  
    end;  记录左节点
    if c3<>'*' then  
    begin  
       a[c1,2]:=c3;  
       b[c3]:=c1;  
    end;  记录右节点
    end;  
print(c);  
end.
```

---

## 作者：qqqevinxxz (赞：0)

# ~~看了好多大佬的题解，本蒟蒻表示看不懂~~

------------
这里介绍一种~~简单易懂~~的方法，map映射
像这样
```cpp
map<char,char> l;//对于每一个节点的左子树
map<char,char> r;//同理
```
### 如果还不知道map是什么，请自行查找

那么就可以得到a的左儿子为l['a'],右儿子为r['a']

然后再前序遍历一下，很简单就AC了


AC代码
```cpp
#include <bits/stdc++.h>/*如果不用万能头文件，应添加#include<map>*/
using namespace std;
map<char,char> l;
map<char,char> r;
void fro(char u)//前序遍历
{
	cout<<u;
	if(l[u]!='*') fro(l[u]);
	if(r[u]!='*') fro(r[u]);
}
int main()
{
	int n;
	char rt;//根节点
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		char a,b,c;
		cin>>a>>b>>c;
		if(i==1) rt=a;
		l[a]=b;
		r[a]=c;
	 }
	 fro(rt);
	 cout<<endl;
	 return 0;
 }
```


---

## 作者：喝掉娃哈哈 (赞：0)

首先吧，这题不难。

要注意的是如果有用scanf输入的%c前面要加空格。
For example 1.scanf(" %c",&char);   
            2.scanf(" %c%c%c",&char1,&char2,&char3);
            
毕竟本来我是用cin>>char的，然后感觉scanf好像会更快一点就强制scanf，
然后就一直卡输入。

还有的就是，我觉得一些dalao的题解只适用于当第一组数据为根的情况，但真正比赛时不会给你钻空太多，所以这道题最好再加一个找根的过程，其实也可以用循环写，但我想练一练函数（hhhhhh）

祝各位都可以AK IOI吧！！！！！

Talk is cheap,show you the code!!!!

```
# include<cstdio>
using namespace std;
struct nod//定义一棵树
{
	char f,l,r;
}tree[130];
int n;
char h,k,ch,c1,c2;
void t(char root)//前序遍历啊 
{
	if(root!='*')
	{
		printf("%c",root);
		t(tree[root].l);
		t(tree[root].r);
	}
	return ;
}
char find(char root)//找根啊
{
	if(tree[root].f)
	{
		return find(tree[root].f);
	}
	else return root;
}
int main()
{
	scanf("%d",&n);
	scanf(" %c",&h);
	scanf(" %c%c",&tree[h].l,&tree[h].r);//为什么这里scanf要加空格 ，求dalao帮忙 
	c1=tree[h].l;
	c2=tree[h].r;
	tree[c1].f=tree[c2].f=h;
	for(int i=2;i<=n;i++)
	{	
		scanf(" %c",&ch);
		scanf(" %c%c",&tree[ch].l,&tree[ch].r);//还是空格问题 
    	c1=tree[ch].l; c2=tree[ch].r;
		tree[c1].f=tree[c2].f=ch;
	}
	t(find(h));
}
```


---

## 作者：Yuren (赞：0)

#### 前言：
浏览了一下已有的题解，没有发现使用栈进行解决的朋友，因此在这里丢出自己AC的代码，供各位参考&&交流

#### 思路：
1. 初始化临时变量为根结点并将其压栈
2. 循环输出临时变量左儿子并将其压栈，直到某结点无左儿子
3. 弹出栈顶元素并赋值给临时变量 
4. 如果该结点有右儿子，则将临时变量变更为其右儿子并将其压栈，回到2
5. 如果该结点没有右儿子，则回到3


#### 代码：
```cpp
#include <iostream>
#include <stack>

using namespace std;

struct node {
	char self; //结点对应的值
	char left; //结点的左儿子
	char right;//结点的右儿子
};

void stack_deal(node tree[])
{
	stack<node> s;      //用来储存结点的栈变量
	int index;          //用来获得数组中相应结点的下标
	node tmp = tree[0]; //临时变量，记录获得的栈中值，初始化为根结点
	
	while (true) {
		while (true) {   //循环输出左儿子并将其压栈
			cout.put(tmp.self);
			s.push(tmp);
			
			if (tmp.left=='*') {
				s.pop(); //没有左儿子则退出循环
				break;
			} else {     //否则将临时变量赋值为其左儿子
				for (index=0; tmp.left!=tree[index].self; ++index);
				tmp = tree[index];
			}
		}
        
        //当前结点没有右儿子则回退到其上层结点，如果当前是根结点则回到主函数
		while (tmp.right=='*') {
			if (!s.empty()) {
				tmp=s.top();
				s.pop();
			} else return;
		}
		//否则将临时变量赋值为其右儿子，压栈的工作交给下一次循环
		for (index=0; tmp.right!=tree[index].self; ++index);
		tmp = tree[index];
	}
}

int main(void)
{
	int count;
	cin>>count;
	node tree[count]; //按输入的顺序储存结点

	for (int i=0; i<count; ++i)
		cin >>tree[i].self
			>>tree[i].left
			>>tree[i].right;

	stack_deal(tree); //输出前序遍历的结果
	cout<<endl;

	return 0;
}

```
### 结束：
以上便是我提交的代码，欢迎提出修改意见:-)

---

## 作者：heyufeng (赞：0)

首先，不得不说这到题目不难（原谅本弱鸡用了80多行代码

但是！！！用c的各位同学，请往这篇题解看！！！
如果你用的是scanf，那么，你是很有可能出现和我一样的问题的：本地跑没有一点问题，但是就是过不了。

其实，这就牵涉到一个有点偏的点，Windows下的换行符事实上不是"\n",而是"\r\n"!!!但是在Windows环境下，系统自动将\r\n识别为\n。

本来这没什么问题，但是！！！到了这道题目，由于我们用了scanf，所以势必要用一个变量来储存换行，也就是scanf("%c%c%c%c",&c,&rt,&l,&r);，但问题是测评机用的是Linux系统，输入用的文件确实在Windows下创建，这就导致了一个问题，"\r"被读了进去，比方说输入"\n abc"那么，最后读入结果是：c='\n'，rt='\r'，l='a'，r='b'，而c则没有被读入，于是，你理所当然的过不了了。
因此，我这道题目需要在读入的时候再增加一个变量，也就是scanf("%c%c%c%c%c",&c,&d,&rt,&l,&r)。然后这道题目就不难了。

C语言代码如下。

```c
#include<stdio.h>
#include<malloc.h>

struct Tree{
	char name;
	struct Tree *left;
	struct Tree *right;
};
typedef struct Tree tree;
tree *root=NULL,*p,*q;

void find(char s,char l,char r,tree *rt){
	if(rt->left==NULL&&rt->right==NULL){
		if(rt->name==s){
			p=(tree *)malloc(sizeof(tree));
			q=(tree *)malloc(sizeof(tree));
			rt->left=p;
			rt->right=q;
			p->name=l;
			q->name=r;
			p->left=NULL;
			p->right=NULL;
			q->left=NULL;
			q->right=NULL;
		}
		return;
	}
	if(rt->name==s){
		p=(tree *)malloc(sizeof(tree));
		q=(tree *)malloc(sizeof(tree));
		rt->left=p;
		rt->right=q;
		p->name=l;
		q->name=r;
		p->left=NULL;
		p->right=NULL;
		q->left=NULL;
		q->right=NULL;
		return;
	}
	if(rt->left!=NULL) find(s,l,r,rt->left);
	if(rt->right!=NULL)find(s,l,r,rt->right);
}
void DLR(tree *rt){
	if(rt->left==NULL&&rt->right==NULL){
		if(rt->name!='*') printf("%c",rt->name);
		return;
	}else{
		if(rt->name!='*') printf("%c",rt->name);
		DLR(rt->left);
		DLR(rt->right);
		return;
	}
}

int main()
{
	int n;
	char rt,l,r,c,d;
	scanf("%d",&n);
	while(n--){
		scanf("%c%c%c%c%c",&c,&d,&rt,&l,&r);
		if(root==NULL){
			root=(tree *)malloc(sizeof(tree));
			p=(tree *)malloc(sizeof(tree));
			q=(tree *)malloc(sizeof(tree));
			root->name=rt;
			root->left=p;
			root->right=q;
			p->name=l;
			q->name=r;
			p->left=NULL;
			p->right=NULL;
			q->left=NULL;
			q->right=NULL;
		}else find(rt,l,r,root);
	}
	DLR(root);
	printf("\n");
	return 0;
}
```


---

## 作者：蒟蒻Orzz (赞：0)

#### 不用判断‘*’的问题，按照前序遍历的规则进行即可。
```cpp
#include <iostream>
using namespace std;
char tree[26][4];
int n;
void print(int r)
{
    cout<<tree[r][0];
    for(int k=1;k<=2;k++)
        for(int i=0;i<n;i++)
            if(tree[i][0]==tree[r][k])print(i);
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>tree[i];
    }
    print(0);//如果要挖坑，就不是从第一个开始了，从那个字母只出现一次的开始
    return 0;
}

```


---

## 作者：DinnerHunt (赞：0)

这里直接用两个数组模拟二叉树

然后直接遍地就行


```cpp
//P1305 luogu
//DinnerHunt
#include <iostream>
using namespace std;
int l[1000],r[1000],n,ch;
string str;
void fr(ch){
    if(ch=='*'-'a') return;        //如果是'*'这表示没有子树了
    cout << char(ch+'a'); //先序遍地 先输出结果
    fr(l[ch]);            //遍地左树
    fr(r[ch]);            //遍地右树
}
int main(){
    ios::sync_with_stdio(false);
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> str;
        if(!i) ch = str[0]-'a';        //储存根节点
        l[str[0]-'a'] = str[1]-'a';        //当前节点的左节点
        r[str[0]-'a'] = str[2]-'a';        //当前节点的右节点
    }
    fr(ch);        //遍地根节点
    return 0;
}
```

---

## 作者：二力平衡树 (赞：0)

蒟蒻我是使用的数组来存储的，还望各位大神勿喷。由于样例是层序遍历，所以我们建树的时候可以循环建树。具体的说明都在程序的注释中。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>

using namespace std;

typedef struct TreeType{
    char It;//该节点的值
    char LeftChild;//左子树的值
    char RightChild;//右子树的值
};

class Tree{
    private:
        TreeType t[1001];//该树
        int nodelen;//节点数量
    public:
        void GetTree(void)
        {
            char n,l,r;//n为该节点的值，l为左子节点的值，r为右子节点的值
            cin >> nodelen;
            for(int i = 0;i < nodelen;i++)
            {
                cin >> n >> l >> r;//输入
                t[i].It = n;
                t[i].LeftChild = l;
                t[i].RightChild = r;//分别存入
            }//建树
        }
        int FindNode(int n)
        {
            for(int i = 0;i < nodelen;i++)
                if(t[i].It == n)
                    return i;
            return -1;
        }//该函数的作用为查找节点，因为每个节点各不相同，所以可以用这种方式。
        TreeType retval(int i)
        {
            return t[i];
        }
        void CatAll(void)
        {
            for(int i = 0;i < nodelen;i++)
                printf("%c ",t[i].It);
        }//层序遍历  debug 
        bool Empty(void)
        {
            return nodelen?false:true;
        }//判空
};
char front[1001];//将先序遍历到的节点依次存入到该数组中
int frontlen;//该先序遍历的长度
void frontcat(Tree t,int i)//先序遍历
{
    int indexleft,indexright;
    if(t.retval(i).It == '*')//如果该节点不存在，则返回
        return;
    else{
        front[frontlen] = t.retval(i).It;//否则则记录下该节点的值
        frontlen++;
        indexleft = t.FindNode(t.retval(i).LeftChild);//找到左子树的下标
        indexright= t.FindNode(t.retval(i).RightChild);//找到右子树的下标
        if(indexleft != -1)//如果能够找到左子树
            frontcat(t,t.FindNode(t.retval(i).LeftChild));//向左遍历
        if(indexright != -1)//如果能够找到右子树
            frontcat(t,t.FindNode(t.retval(i).RightChild));//向右遍历
    }
}

int main(int argc,char ** argv)
{
    Tree mytree;
    mytree.GetTree();//建树
    if(mytree.Empty())//判空，以防万一
        return 0;
//    mytree.CatAll();
    frontlen = 0;
    frontcat(mytree,0);//先序遍历
    for(int i = 0;i < frontlen;i++)
        printf("%c",front[i]);//输出序列
    
    return 0;
}
```
当然，也可以在先序遍历的过程中直接输出序列，这样会省一部分空间。


---

## 作者：吴海啸 (赞：0)

｛这是一只链表树｝

```cpp
type tree=^node;//嵌套
node=record
data:char;//该节点内容
lch,rch:tree;//左子树与右子树
end;//链表类型
var a:array['a'..'z']of string;
head:tree;s:string;n,i:longint;ch:char;
procedure dr(ch:char;var bt:tree);
begin
if ch='*' then bt:=nil
else
begin
new(bt);bt^.data:=ch;
dr(a[ch][2],bt^.lch);dr(a[ch][3],bt^.rch);
end;
end;
procedure xx(bt:tree);
begin
if bt=nil then exit;
write(bt^.data);
xx(bt^.lch);xx(bt^.rch);
end;
begin
readln(n);
readln(s);ch:=s[1];//先读取第一行，保留其根节点内容
for i:=1 to n-1 do
    begin a[s[1]]:=s;readln(s);end;//将节点内容及其左右子树内容保存在a数组里
a[s[1]]:=s;
new(head);head^.data:=a[ch][1];//树根处理
dr(a[ch][2],head^.lch);dr(a[ch][3],head^.rch);//生成左右子树
xx(head);//前序遍历
end.
**总之，本题若使用数组来建树的话，可能会简单不少，但是用链表建树，虽然稍微麻烦一些，却也是我们不可忘记的**
```

---

## 作者：geek痕 (赞：0)

看讨论说这题的数据改过了，那就上一篇最新写的题解吧。效率不怎样，但代码可读性还是可以的。

讨论中有一位神犇已经测出了数据范围是n<=26且全为小写字母。

对于建立每个节点的问题我是采用了伪动态的方法，先声明好了一堆的node，再用一个point指向。

然后输入的时候来一个预处理，用map建立字符与point的映射，方便以后找。

遇到空节点就约定为用‘0’表示。

输出的时候是先序输出，递归就好了，边界就是节点当前字符为‘0’

最后，双手奉上代码。







    
    
    
    
    
```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;
struct node{
    char left;
    char right;
    char here;
}tree_z[10000000];
int point=0;
map<char,int> m;
bool is_used[30];
void print_before(char t){
    if(t=='0') return;
    cout<<t;
    print_before(tree_z[m[t]].left);
    print_before(tree_z[m[t]].right);
}
int main(){
    #ifdef LOCAL
    freopen("test.in","r",stdin);
    #endif
    int n=0;
    cin>>n;
    for(int i=0;i<n;i++){
        string t;
        cin>>t;
        m[t[0]]=point;
        tree_z[point].here=t[0];
        if(t[1]!='*') {tree_z[point].left=t[1];is_used[t[1]-'a']=1;}
        else tree_z[point].left='0';
        if(t[2]!='*') {tree_z[point].right=t[2];is_used[t[2]-'a']=1;}
        else tree_z[point].right='0';
        point++;
    }
    //找祖先
    char i='a';
    for(;i<='z';i++){
        if(!is_used[i-'a']) break;
    }
    print_before(i);
    return 0;
}
```

---

## 作者：ForwarDer (赞：0)

我的程序不是最优空间解（数据太水，不用那么麻烦），其中数组的下标是从‘a’的int值才开始的，省些空间可写成 f-'a' ，这不是重点。


具体思路很简单，相当于开了两个一维数组，bt[f][1]表示f节点左孩子的字符，bt[f][2]则是右孩子。读入时以第一个节点作为根节点（从楼下学到的）。然后便是很简单的先序遍历。


附上c++代码：





```cpp
#include <bits/stdc++.h>
#define MAXV 100001
using namespace std;
char bt[MAXV][3];
int n ,root;
char f ,l ,r;
void preOrder(char x);
int main()
{
    cin>>n;
    for(int i=1 ;i<=n ;i++) {
        cin>>f>>l>>r;
        if(i==1)    root=f;
        bt[f][1]=l;
        bt[f][2]=r;
    }
    preOrder(root);
    //system("pause");
    return 0;
}
void preOrder(char x)
{
    cout<<x;
    if(bt[x][1]!='*')   preOrder(bt[x][1]);
    if(bt[x][2]!='*')   preOrder(bt[x][2]);
}

```

---

## 作者：iren (赞：0)

本来只是想交上去看看能得多少分，没想到居然AC了。

果然还是数据比较弱吗……

还有，第二行的第一个字母就是它的根节点（题干没说，让我捡了个漏？）

所以，我只是建了个树，然后直接先序遍历。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char lch[30],rch[30];
char build(char a,char b,char c){
    lch[a-'a'] = b;//用字母-‘a’作为它的编号 
    rch[a-'a'] = c;
}
void PreOrder(char root){
    if(root=='*') return;//是'*'就返回 
    cout<<root;
    PreOrder(lch[root-'a']);
    PreOrder(rch[root-'a']);
}
int main(){
    int n;
    cin>>n;
    char a[4],root;
    for(int i = 1;i <= n;i++){
        cin>>a;//用getchar()单个输入会输入换行符 
        build(a[0],a[1],a[2]);
        if(i == 1) root = a[0];
    }
    PreOrder(root);
    return 0;
}
```

---

## 作者：teafrogsf (赞：0)

我觉得题解不少人写得比较复杂，这个题目总的来说要点有三个：

①构造二叉树，这里需要注意的是n的范围没有给出，我一开始以为26个字母只会出现一次就只弄了100的数组，但结果就爆了，所以我开了10000，对于这个题目来说常数可以了；

②三四行的前序遍历

③洛谷专属（但其实好像是Linux评测系统？）输入格式，吞换行字符不能只getchar，这里建议C/C++党用C++的getline，会快一些（毕竟string类方便）

然后就是代码

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#define f(i,a,b) for(i=a;i<=b;++i)
using std::cin;
using std::string;//不太建议using namespace std
int n;
char a[10010];
string s;
void preorder(int i)
{
    if(a[i]==0)return;
    if(a[i]!='*')printf("%c",a[i]);
    preorder(i<<1);//位运算，表示i*2，下面表示i*2+1，这样快一些
    preorder(i<<1|1);
}
int main()
{
    int i,j;
    scanf("%d",&n);
    string instead;
    getline(cin,instead);//吞换行
    getline(cin,s);//第一个直接进去
    a[1]=s[0],a[2]=s[1],a[3]=s[2];
    f(i,2,n)
    {
    getline(cin,s);
    f(j,1,10000)if(a[j]==s[0])a[j<<1]=s[1],a[j<<1|1]=s[2];//拼常数
    }
    preorder(1);//根节点1
}
```

---


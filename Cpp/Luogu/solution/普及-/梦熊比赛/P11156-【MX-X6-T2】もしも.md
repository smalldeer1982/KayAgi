# 【MX-X6-T2】もしも

## 题目背景

原题链接：<https://oier.team/problems/X6C>。

---

> _もしも$\\$
数字がない世界だったら$\\$
生きる期限なんて$\\$
なかったのかな$\\$
もしもの話なら良かった$\\$
また出逢えるからって$\\$
言うんだ$\\$
またね。_
>
>_—— [もしも - Nanatsukaze / Dankidz](https://music.163.com/#/song?id=2102257032)_

除法能够帮我们消除这个世界上的数字吗？

如果不能，又能否让我们再次相见？

## 题目描述

假设有正整数序列 $a_1, a_2, \ldots, a_n$，其中：

- 对于 $i\geq 3$，满足 $a_i$ 等于 $\dfrac{a_{i-2}}{a_{i-1}}$ **上取整**；
- 对于任意 $1\leq i\leq n$，满足 $1\leq a_i\leq 10^9$。

现在给定 $n$ 和 $a_n$，求任意一组可能的 $a_1,a_2$。

其中一个数 $x$ 上取整等于最小的 $\geq x$ 的整数。例如 $\dfrac{7}{3}$ 上取整等于 $3$，$4$ 上取整等于 $4$。

## 说明/提示

**【样例解释】**

对于三组数据，序列分别为：

- $a=[114,514,1]$；
- $a=[2005,1130,2]$；
- $a=[59001,897,66,14,5,3]$。

**【数据范围】**

对于所有数据，满足 $1\leq T\leq 1000$，$3\leq n\leq 10^9$，$1\leq a_n\leq 10^9$。

共 $10$ 组数据：

- 对于前 $2$ 组数据，额外满足 $n\leq 6$，$a_n\leq 10$；
- 对于前 $5$ 组数据，额外满足 $n\leq 1000$；
- 对于第 $6,7$ 组数据，额外满足 $a_n=1$。

## 样例 #1

### 输入

```
3
3 1
3 2
6 3```

### 输出

```
114 514
2005 1130
59001 897```

# 题解

## 作者：Zskioaert1106 (赞：12)

题目传送门：[P11156 【MX-X6-T2】もしも](https://www.luogu.com.cn/problem/P11156)

最真诚的提示：Special Judge 的输出样例都没用。

### 题目分析

我们以最后一组样例为例：$a_6=3$，那要让 $\dfrac{a_4}{a_5}=3$，最小的办法就是 $a_4=3,a_5=1$。让 $\dfrac{a_3}{a_4}=1$，同时 $a_4=3$，则 $a_3$ 最小可以等于 $1$。

按照上面的构造方法，我们得到了 $1,3,1,3,1,3$ 的数列。我们可以发现，上述规律对于任意一个 $n$ 为偶数的 $a_n$ 都适用。

如果 $n$ 为奇数呢？

以 $n=5$ 为例，则 $a_4=1,a_3=a_5,a_2=1,a_1=a_5$。

所以我们得到了规律：

当 $n$ 为偶数时，可以构造 $a_1=1,a_2=a_n,a_3=1,a_4=a_n,\dots$ 的数列；

当 $n$ 为奇数时，可以构造 $a_1=a_n,a_2=1,a_3=a_n,a_4=1,\dots$ 的数列。

### 代码实现

当 $n$ 为偶数时，输出 $a_1=1,a_2=a_n$；

当 $n$ 为奇数时，输出 $a_1=a_n,a_2=1$。

```cpp
#include<iostream>
using namespace std;
void doing(int n,int a){
	int a1,a2;
	if(n&1)cout<<a<<' '<<1<<'\n';
	else cout<<1<<' '<<a<<'\n';
	return ;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,a;
		cin>>n>>a;
		doing(n,a);
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/179817728)。

---

## 作者：_Jocularly_ (赞：4)

## 暴力
这种题当然少不了暴力，如果我们先忽略向上取整，那么我们可以把递推式子变成 $a_{i} = \frac{a_{i-2}}{a_{i-1}}$，稍微变形可得 $a_{i-2}=a_{i-1}\times a_{i}$，那么我们利用贪心的思想，因为要保证答案在 $[1,10^9]$ 的范围内，那么我们尽可能让倒数第二项 $a_{n-1}$ 小，假设他是一，那么往前递推求即可，单次复杂度 $O(n)$，但是会有稍稍的问题。


```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int n,a;
int ans1,ans2;
void work(){
    int prea = 1;
    n -= 2;
    while(n --){
        int now = prea * a;
        a = prea;
        prea = now;
    }
    ans1 = prea;
    ans2 = a;
}
int main(){
    cin >> t;
    while(t--){
        cin >> n >> a;
        work();
        cout << ans1 << " " << ans2 << endl;
    }
    return 0;
}
```

## 特殊性质
稍稍放一放暴力，看看特殊性质。当 $a_{n} = 1$ 时，此时沿用我们的贪心思想，会发现我们的序列变成了一个全都是一的序列，那么自然，$a_{1}$ 和 $a_{2}$ 即为一。

## 优化暴力
回过头来，我们思考一下为什么暴力只能拿二十分，随便手搓两组数据，你会发现，每个答案都非常的大，几乎是幂次的关系，超过了 $10^9$，那么自然过不了。思考怎么优化，此时就要把一开始被抛下的向上取整加上了。举个例子，假设没有向上取整，我要商为三，除数为五，那么被除数自然为十五，但是如果加上向上取整，还有必要这么大吗？显然不是。那么我们进一步利用贪心的思想，假设我们要求得的商为 $m$，除数为 $n$，那么我们只要要求被除数为 $n\times(m-1)+1$，此时我们除之后得到的商刚好比 $m-1$ 大一点，向上取整自然得到 $m$，时间复杂度不变，但分数很可观。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
int n,a;
int ans1,ans2;
void work(){
    int prea = 1;
    n -= 2;
    while(n --){
        int now = prea * (a - 1) + 1;
        a = prea;
        prea = now;
    }
    ans1 = prea;
    ans2 = a;
}
signed main(){
    cin >> t;
    while(t--){
        cin >> n >> a;
        if(a == 1) cout << 1 << " " << 1 << endl;
        else{
            work();
            cout << ans1 << " " << ans2 << endl;
        }
    }
    return 0;
}
```

## 正解
既然有了能够保证正确性的暴力程序，干脆直接跑个打表程序。观察发现，当 $n$ 为偶数时，答案为 $1$ 和 $a_{n}$，奇数时刚好相反，这是为什么呢？这里说明偶数的情况，奇数与其相同。模拟一下，发现当 $a_{1} = 1$ 且 $a_{2} = a_{n}$ 时，根据递推公式，我们能发现奇数项都为 $1$，偶数项都为 $a_{n}$，因为 $n$ 是偶数，那么 $a_{n}$ 也是偶数项，此时刚好满足要求，且因为 $a_{n} \in [1,10^9]$，那么答案的范围也是 $[1,10^9]$，时间复杂度为 $O(1)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
int n,a;
int ans1,ans2;
void work(){
    int prea = 1;
    n -= 2;
    while(n --){
        int now = prea * (a - 1) + 1;
        a = prea;
        prea = now;
    }
    ans1 = prea;
    ans2 = a;
}
signed main(){
    cin >> t;
    while(t--){
        cin >> n >> a;
        /*
        if(a == 1) cout << 1 << " " << 1 << endl;
        else{
            work();
            cout << ans1 << " " << ans2 << endl;
        }
        */
       if(n % 2 == 0) cout << 1 << " " << a << endl;
       else cout << a << " " << 1 << endl;
    }
    return 0;
}
```

---

## 作者：ylch (赞：4)

[Luogu - P11156](https://www.luogu.com.cn/problem/P11156)

## Description（描述）

假设有正整数序列 $a_1, a_2, \ldots, a_n$，其中：

- 对于 $i\geq 3$，满足 $a_i$ 等于 $\dfrac{a_{i-2}}{a_{i-1}}$ **上取整**；
- 对于任意 $1\leq i\leq n$，满足 $1\leq a_i\leq 10^9$。

现在给定 $n$ 和 $a_n$，求任意一组可能的 $a_1,a_2$。

对于所有数据，满足 $1\leq T\leq 1000$，$3\leq n\leq 10^9$，$1\leq a_n\leq 10^9$。

## Analysis（分析）

这道题明显是一个构造，要找策略。这种题上来先手搓几组数据看看能不能找规律。

暴力代码：

```cpp
for(ll a1 = 1; a1 <= 1000; a1 ++){
  for(ll a2 = 1; a2 <= 1000; a2 ++){
    ll x = a1;
    ll y = a2;
    bool flag = true;
    
    for(int i = 3; i <= n; i ++){
      ll ai = (x + y - 1) / y; // 上取整
      if(i == n && ai != an){
        flag = false;
        break;
      }
      x = y;
      y = ai;
    }
    
    if(flag){
      cout << a1 << " " << a2 << '\n';
      return 0;
    }
  }
}
```

然后测几组数据：
```
6
1 3
2 3
4 5
5 5
10 9
15 9
```

输出：
```
3 1
1 3
1 5
5 1
1 9
9 1
```

我们好像发现了一个规律：**当 $n$ 为奇数时，输出为 $a_n,1$；当 $n$ 为偶数时，输出为 $1, a_n$。**

## Explain（解释）

特殊性质可以给我们一个很好的提示：

> 对于第 $6,7$ 组数据，额外满足 $a_n=1$。

不难想到，只要把 $a_1,a_2$ 都赋值为 $1$，因为 $\dfrac{1}{1}=1$，那么所有的运算结果都是 $1$。

这就是这两个点的策略。


---


观察到通项公式有一个特殊的地方：**上取整**，即 $\lceil \cdots \rceil$。

那么，对于所有分子为 $1$ 的分数，其上取整的结果一定也都是 $1$。例如：$\lceil \dfrac{1}{2} \rceil = \lceil \dfrac{1}{3} \rceil = \lceil \dfrac{1}{4} \rceil = \cdots = 1$。

那么再回到刚才的规律，设 $a_1=x, a_2=1$，则：

- $a_3 = \lceil \dfrac{a_1}{a_2} \rceil = \lceil \dfrac{x}{1} \rceil = x$

- $a_4 = \lceil \dfrac{a_2}{a_3} \rceil = \lceil \dfrac{1}{x} \rceil = 1$

- $a_5 = \lceil \dfrac{a_3}{a_4} \rceil = \lceil \dfrac{x}{1} \rceil = x$

  $\vdots$


不难发现只要 $a_1,a_2$ 中有一个数为 $1$， 那么由于上取整和通项公式不断迭代的原因，其结果一直在 $1, x$ 之间重复。

那么，只要控制 $a_1,a_2$  赋值为 $1,x$ 的顺序，就能控制是奇数项为 $x$ 还是偶数项为 $x$。

## Code（代码）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	
	int T; cin >> T;
	while(T --){
		int n;
		ll an;
		cin >> n >> an;
		
		if(n % 2 == 1) cout << an << ' ' << 1 << '\n';
		else cout << 1 << ' ' << an << '\n';
	}
	return 0;
}

```

## End

管理员大大辛苦啦~

这里是 [ylch](https://www.luogu.com/user/759881)，谢谢大家！

---

## 作者：xyx404 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11156)。
## 思路
本题为数学题，需要找规律。

我们可以尝试在 $a_n$ 前面放 $1$，因为 $a_i$ 等于 $\dfrac{a_{i-2}}{a_{i-1}}$ 向上取整，所以当 $i$ 等于 $n$ 时某个数乘 $1$ 要等于 $a_n$ 很明显 $a_n$ 乘 $1$ 会等于 $a_n$，然后是 $i$ 等于 $n-1$ 时，$a_i$ 等于 $\dfrac{a_{i-2}}{a_{i-1}}$ 向上取整，又因为 $a_{n-1}$ 等于 $1$，所以 $a_{i-2} \le a_{i-1}$，是不是又可以放一了，之后一直重复可以得到序列中只有 $1$ 和 $a_n$ 这两个数并且是交替出现的。

因为第一个 $1$ 是放在 $a_n$ 前的，$1$ 和 $a_n$ 这两个数交替出现，所以当 $n$ 是偶数时 $a_1$ 是 $1$，当 $n$ 是奇数时 $a_1$ 是 $a_n$。

举两个例子：  
$n=5,a_n=10$ 时，根据之前的思路得出的序列为 $10,1,10,1,10$。  
$n=6,a_n=10$ 时，根据之前的思路得出的序列为 $1,10,1,10,1,10$。    
算一下确实是满足题目中的条件的。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
int n,a,t;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>a;
		if(n%2==0){
			cout<<1<<" "<<a<<"\n";
		}
		else cout<<a<<" 1\n";
	}
	return 0;
}
```

---

## 作者：OrzSceamyn (赞：1)

## P11156 【MX-X6-T2】もしも 题解

### 思路

简单构造。

显然如果 $a_1$为 $1$，则 $a$ 数列将一直是 $1,a_2,1,a_2$ 这样子循环。若 $a_2$ 为 $1$，则 $a$ 数列将一直是 $a_1,1,a_1,1$ 这样子循环。

题目给出 $a_n$，要求出满足条件的一组 $a_1,a_2$。所以只要一个数是 $1$，另一个数是 $a_n$ 即可。

考虑分 $n$ 的奇偶性讨论，如果 $n$ 是奇数，那么 $a_1$ 等于 $a_n$，$a_2$ 等于 $1$ 时就可以满足循环到第 $n$ 个数为 $a_n$。反之同理。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T=1;
int n;
const int maxn=1010;
int a[maxn],an;
void solve(){
	cin>>n>>an;
	if(n&1){
		cout<<an<<' '<<1<<'\n';
	}
	else cout<<1<<' '<<an<<'\n';
}
int32_t main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}

```

---

## 作者：under_the_time (赞：0)

## 题意

> 给定 $n$ 和 $x$，要求构造一个长度为 $n$ 的序列，满足 $a_n=x$，数组中每一项在 $[1,10^9]$ 中，且对于 $i\ge 3$，$a_i=\left\lceil \cfrac{a_{i-2}}{a_{i-1}}\right\rceil$。求一组 $(a_1,a_2)$。
>
> $3\le n\le 10^9$，$1\le x\le 10^9$，数据保证一定有解。

## 解法

显然有 $\lceil n/1\rceil=n$ 和 $\lceil1/n=1\rceil$，于是我们令 $a$ 中元素为 $1$ 和 $x$ 交替出现即可。具体地，若 $a_n=x$，构造 $a_{n-1}=1$，那么由于 $a_n=\left\lceil \cfrac{a_{n-2}}{a_{n-1}}\right\rceil$，我们构造 $a_{n-2}=x$；而又因为 $a_{n-1}=\left\lceil \cfrac{a_{n-3}}{a_{n-2}}\right\rceil$，我们构造 $a_{n-3}=1$。这样对于后面的部分就是一个循环了。我们只需判断最后 $a_1,a_2$ 谁取 $1$ 谁取 $x$，手摸一下可以发现是 $n$ 为奇数时 $a_1$ 取 $x$。于是就做完了，时间复杂度 $O(1)$。

还有一个没用但有趣的结论我写在代码里了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define open(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout)
int main() {
	int T, n, a; scanf("%d", &T);
	for (scanf("%d %d", &n, &a); T; T --, T ? scanf("%d %d", &n, &a) : T = 0) 
		n & 1 ? printf("%d %d\n", a, 1) : printf("%d %d\n", 1, a);
	return 0;
}
/*
a[1] = x, a[2] = y
a[3] = x / y
a[4] = y / x * y = y ^ 2 / x
a[5] = a[3] / a[4] = x / y / y ^ 2 * x = x ^ 2 / y ^ 3
a[6] = a[4] / a[5] = y ^ 2 / x / x ^ 2 * y ^ 3 = y ^ 5 / x ^ 3
f = 1, 1, 2, 3, 5, 8, ...
therefore: a[n] = x ^ f[n - 2] / y ^ f[n - 1] if n & 1
		   a[n] = y ^ f[n - 1] / x ^ f[n - 2] otherwise.
		   
		   
useless :(
*/


/*
a[3] = x, a[2 - 1] = 1
x = a[n - 2] / a[n - 1]
a[1] = x
1 = a[n - 3] / x
a[n - 3] = 1
useful :)
*/
```

---

## 作者：xingshuyan000 (赞：0)

[题目传送门：P11156](https://www.luogu.com.cn/problem/P11156) 

很简单的一道构造题。

因为对于 $\forall i \ge 3$，都有 $a_i=\lceil \frac{a_{i-2}}{a_{i-1}} \rceil$，所以对于任意一个位置 $j$，如果 $a_j=1,a_{j-1}=p$，则 $a_{j+1}=\lceil \frac{a_{j-1}}{a_{j}} \rceil=p,a_{j+2}=\lceil\frac{a_j}{a_{j-1}}\rceil=1$。所以在出现了数字 $1$ 之后就会出现以 $1,p$ 为周期的循环。

因为我们前面规定的 $j$ 是序列中任意的位置，所以这下问题就变成判断 $n$ 的奇偶性了。如果 $n$ 是奇数，那么出现的序列就是 $a_n,1,a_n,1,\cdots,a_n$；如果 $n$ 是偶数，那么出现的序列就是 $1,a_n,1,a_n,\cdots,a_n$。

按照如上的方式判断、构造即可，单次的时间复杂度是 $O(1)$。

代码很简单，一共就十几行，我就不贴代码了。

---

## 作者：wbqhasvcf (赞：0)

最简单的构造：由于是向上取整，所以令 $a_{n-1}=1$，$a_{n-2}=n$，$a_{n-3}=1$，$a_{n-4}=n\cdots$ 以此类推，首先 $a_{n}=n=\frac{a_{n-2}}{a_{n-1}}=\frac{n}{1}$ 成立，其次 $a_{n-1}=1$，也刚好为 $\frac{a_{n-3}}{a_{n-2}}=\frac{1}{n}$ 向上取整。这也就是题目中“保证一定有解”的一种情况：
```cpp
#include<bits/stdc++.h>
using namespace std;

int t,n,an;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>an;
		if(n%2==1) cout<<an<<" 1"<<endl;
		else cout<<"1 "<<an<<endl;
	}
	return 0;
}
```
代码极为之简单，对于每次输入只需要判断 $n$ 的奇偶来确定对应的输出即可，时间复杂度为 $O(n)$。

---

## 作者：LG086 (赞：0)

对于正整数序列 $a_1, a_2, \ldots, a_n$，若 $i\geq 3$，则满足 $a_i$ 等于 $\dfrac{a_{i-2}}{a_{i-1}}$ **上取整**，且每个 $a_i$ 是不超过 $10^9$ 的正整数。

现给定 $n$ 和 $a_n$，求任意一组可能的 $a_1,a_2$。

---

打打草稿找规律。

因为 $a_n\ge\dfrac{a_{n-2}}{a_{n-1}}$，那么一组满足要求的 $a_{n-1},a_{n-2}$ 就是 $a_{n-1}=1,a_{n-2}=a_n$。\
发现 $\dfrac{1}{a_{n}}$ 向上取整得 $1$，且 $a_n=\dfrac{a_{n}}{1}$，所以一种符合要求的数列中只包含 $a_n$ 和 $1$，且两数交替出现。

由此确定了 $a_1,a_2$ 两数中，一个为 $a_n$，一个为 $1$。分情况讨论。发现当序列长度为奇数时，$a_1=a_n,a_2=1$；而当序列长度为偶数时，$a_1=1,a_2=a_n$。

这样就做完了。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int T;
int n,a;
signed main(){
    cin>>T;
    while(T--){
        cin>>n>>a;
        if(n%2==0){
            cout<<"1 "<<a<<endl;
        }else{
            cout<<a<<" 1\n";
        }
    }
}
```

---

## 作者：jiangyunuo (赞：0)

### 题目意思：
有一个长度为 $n$ 的序列，第 $i$ 个元素为 $a_i$，如果 $i \ge 3$，那么 $a_i = \dfrac{a_{i-2}}{a_{i-1}}$ **向上取整**。  
现在给出 $n$ 和 $a_n$，求出一种可能的 $a_1$ 和 $a_2$。  
### 大体思路：
一开始，我在想：有没有一种方法可以令任意一个 $a_i$ 都保持 $a_n$？  
但事实上这是不可能的，但就是这样，我又有了一个发现，任意一个 $a_i$ 都可以只能是 $1$ 或 $a_n$，这是怎么得来的呢？  
就随便举个例子吧，当 $a_1$ 和 $a_2$ 分别为 $1$ 和 $x$（$x$ 表示任意一个不为 $0$ 的数），那么这个序列就变成了：$1,x,1,x,1,\dots$。  
没错，就是 $1$ 和 $x$ 的循环，那样的话，答案就很明显了，$a_1$ 和 $a_2$ 可以一个是 $1$，另一个是 $a_n$，但具体该怎么办呢？  
其实我们只要根据 $n$ 的奇偶性即可，当 $n$ 为奇数时，那么当 $i$ 为奇数时 $a_i=a_n$，$i$ 为偶数时 $a_i=1$，反之，当 $i$ 为奇数时 $a_i=1$，$i$ 为偶数时 $a_i=a_n$，那么我们就可以求出 $a_1$ 和 $a_2$ 了。  
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    int n,a;    //a 表示的是 a[n]。
    for(int i=1;i<=t;i++){
    	cin>>n>>a;
    	if(n%2)cout<<a<<" "<<1<<endl;
    	else cout<<1<<" "<<a<<endl;     //判断 n 的奇偶性，并输出答案。
	}
    return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
不难发现，$\lceil\frac{x}{1}\rceil=x,\lceil\frac{1}{x}\rceil=1$。于是，如果令前两项为 $x$ 和 $1$，则最终序列形如 $\{x,1,x,1,\dots\}$；如果令前两项为 $1$ 和 $x$，则最终序列形如 $\{1,x,1,x\dots\}$。所以根据 $n$ 的奇偶性讨论即可。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    int T;
    scanf("%d", &T);
    while(T --){
        int n, an;
        scanf("%d %d", &n, &an);
        if(n & 1) printf("%d 1\n", an);
        else printf("1 %d\n", an);
    }
    return 0;
}
```

---

## 作者：鲤鱼江 (赞：0)

简单题。

考虑将 $n$ 的奇偶性分类讨论一下，若 $n$ 是奇数，则令 $a_1=a_n$ 且 $a_2=1$ 否则交换 $a_1$ 和 $a_2$，下面证明正确性，以 $n$ 为奇数举例。

发现 $a$ 数列如下：$a_n,1,a_n,1,a_n\dots$，一定是交替出现的，容易发现。

代码没有难度。

```cpp
#include<bits/stdc++.h>

using namespace std;
#define endl '\n'

const int N=1e5+10;
int n,x,y;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	while(n--){
		cin>>x>>y;
		if((x&1)) cout<<y<<' '<<1<<endl;
		else cout<<1<<' '<<y<<endl;
	}
	return 0;
}
```

---


# 【MX-J15-T1】叉叉学习数据类型

## 题目背景

原题链接：<https://oier.team/problems/J15A>。

## 题目描述

叉叉学习了五种数据类型：`int`、`unsigned int`、`long long`、`unsigned long long` 和 `string`。

小粉兔决定考考叉叉，于是想了一个整数 $n$。小粉兔希望叉叉判断，$n$ 能否用这五种数据类型存储。

叉叉出色地完成了这项任务，你可以完成吗？

## 说明/提示

**【样例解释 #1】**

$0$ 可以用 `int`、`unsigned int`、`long long`、`unsigned long long` 和 `string` 存储。

**【数据范围】**

对于 $100\%$ 的数据，$|n| \le 10^{100}$。

## 样例 #1

### 输入

```
0```

### 输出

```
int
unsigned int
long long
unsigned long long
string```

## 样例 #2

### 输入

```
-1```

### 输出

```
int
long long
string```

## 样例 #3

### 输入

```
12345678910111213141516171819202122232425262728293031323334353637```

### 输出

```
string```

# 题解

## 作者：fish_love_cat (赞：43)

[注意到这题没给编译环境。](https://www.luogu.com.cn/paste/6xowzcoy)

---

出题人没说用哪个什么编译器那就按 32 位编译器算吧。

背过数据范围的同学都知道：

`int`：$-2147483648\le x\le2147483647$；  
`int`：$0\le x\le4294967295$；  
`int`：$-9223372036854775808\le x\le9223372036854775807$；  
`int`：$0\le x\le18446744073709551615$；  
`string`：并无范围，看你内存大小咯。

写个高精度比大小然后硬算就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
// -1 -> a<b
// 1 -> a>b
// 0 -> a=b
int bdx(string s1,string s2){
    int i=0,op=1;
    if(s1[0]=='-'&&s2[0]==s1[0])op=-1,i++;
    if(s1[0]=='-'&&op==1)return -1*op;
    if(s2[0]=='-'&&op==1)return 1*op;
    if(s1==s2)return 0*op;
    else if(s1.size()<s2.size())return -1*op;
    else if(s1.size()>s2.size())return 1*op;
    for(;i<s1.size();i++){
        if(s1[i]<s2[i])return -1*op;
        else if(s1[i]>s2[i])return 1*op;
    }
}
string s;
int f(string x){
    return bdx(s,x);
}
int main(){
    cin>>s;
    if(f("-2147483648")>=0&&f("2147483647")<=0)puts("int");
    if(f("0")>=0&&f("4294967295")<=0)puts("unsigned int");
    if(f("-9223372036854775808")>=0&&f("9223372036854775807")<=0)puts("long long");
    if(f("0")>=0&&f("18446744073709551615")<=0)puts("unsigned long long");
    puts("string");
    return 0;
}
```

---

## 作者：Clare613 (赞：13)

## 思路：

这是一道简单题。我们可以发现 $n$ 最大有 $100$ 位数，且 $n$ 是个整数，那么 `string` 类型一定可行。我们可以先用 `string` 类型输入，如果位数超过了 $20$ 位，注意是包括带负号的情况，那么 `int`、`unsigned int`、`long long`、`unsigned long long` 这 $4$ 种类型一定装不下。接着就是判断如果正好为 20 位，这时候有可能 `long long` 装不下但 `unsigned long long` 装得下了，对此进行一次特判。然后我们就要把字符串转为数字，如果 `long long` 类型的最大值转为字符串后比 $n$ 小，那么就输出 `unsigned long long` 和 `string` 类型。\
特判结束了，接下来是常规判断。对于转整数，这里不赘述了，看代码吧。那么我们只要明白每种类型的范围即可，范围如下：

- `int`：`INT_MIN` 至 `INT_MAX`。
- `unsigned int`：$0$ 至 `UINT_MAX`。
- `long long`：`LLONG_MIN` 至 `LLONG_MAX`。
- `unsigned long long`：$0$ 至 `ULLONG_MAX`。
- `string`：任何数字。

只需判断转换后的数字符合那些类型，输出即可。

## code：

```cpp
#include<bits/stdc++.h>
#define int long long
#define MOD 998244353
using namespace std;
int to_int(string x){
	int ans=0;
	if(x[0]=='-'){
		for(int i=1;i<x.size();i++){
			ans=ans*10+signed(x[i]-'0');
		}
		ans=-ans;
	}
	else{
		for(int i=0;i<x.size();i++){
			ans=ans*10+signed(x[i]-'0');
		}
	}
	return ans;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	string x;
	cin>>x;
	if(x.size()>20){
		cout<<"string";
		return 0;
	}
	if(x.size()==20){
		if(x[0]!='-'){
			if(x<=to_string(ULLONG_MAX)){
				cout<<"unsigned long long\nstring";
				return 0;
			}
			else{
				cout<<"string";
				return 0;
			}
		}
	}
	if(to_string(LLONG_MAX)<x){
		cout<<"unsigned long long\nstring";
		return 0;
	}
	int n=to_int(x);
	if(n>=INT_MIN&&n<=INT_MAX) cout<<"int\n";
	if(n>=0&&n<=UINT_MAX) cout<<"unsigned int\n";
	if(n>=LLONG_MIN&&n<=LLONG_MAX) cout<<"long long\n";
	if(n>=0&&n<=ULLONG_MAX) cout<<"unsigned long long\n";
	cout<<"string";
	return 0;
}
```

---

## 作者：__qkj__ (赞：12)

## 解题思路
模拟题。注：[数据范围](https://blog.csdn.net/qq_46243318/article/details/145138956)

先输入字符串 $a$，如果第一位是负号，则删去，记为 $b$，再记录 $f\gets 1$。然后分类讨论：

1. - 如果 $f=1$ 且 $b\le 2147483648$，即 $0> a\ge -2^{31}$，则输出 `int`；
   - 如果 $f=0$ 且 $b\le 2147483647$，即 $0\le a\le 2^{31}-1$，则输出 `int`；
2. - 如果 $f=1$，由于 `unsigned int` 无法存储有符号整数，所以不行；
   - 如果 $f=0$ 且 $b\le 4294967295$，即 $0\le a\le 2^{32}-1$，则输出 `unsigned int`；
3. - 如果 $f=1$ 且 $b\le 9223372036854775808$，即 $0> a\ge -2^{63}$，则输出 `long long`；
   - 如果 $f=0$ 且 $b\le 9223372036854775807$，即 $0\le a\le 2^{63}-1$，则输出 `long long`；
4. - 如果 $f=1$，由于 `unsigned long long` 无法存储有符号整数，所以不行；
   - 如果 $f=0$ 且 $b\le 18446744073709551615$，即 $0\le a\le 2^{64}-1$，则输出 `unsigned long long`。
5. `string` 什么都可以存储，所以输出 `string`。

至于字符串比较，只需要先判断字符串长度，再直接用大于或小于号比较即可。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool cmp(string a,string b)//a>b :0  a<=b :1
{
	if(a.size()>b.size())return 0;
	if(a.size()<b.size())return 1;
	return a<=b;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	string a;
	cin>>a;
	bool f=0;
	if(a[0]=='-')f=1,a.erase(0,1);
	if(f&&cmp(a,"2147483648")
	||!f&&cmp(a,"2147483647"))cout<<"int\n";
	
	if(!f&&cmp(a,"4294967295"))cout<<"unsigned int\n";
	
	if(f&&cmp(a,"9223372036854775808")
	||!f&&cmp(a,"9223372036854775807"))cout<<"long long\n";
	
	if(!f&&cmp(a,"18446744073709551615"))cout<<"unsigned long long\n";
	
	cout<<"string";
	return 0;
}
```

---

## 作者：llamn (赞：11)

`std::scanf` 和 `std::cin` 都有一个特性：输入的整数超过该类型所能存储的最大值时，整数会被赋值为该类型的最大值。例如使用 `scanf("%u",&x);` 而输入 `4567890123` 时，`x` 会变为 `numeric_limits<unsigned int>::max()` 即 `4294967295`。

因此我们只需要将输入的字符串读入多个类型的变量，然后用 `to_string` 判断有没有超过变量最大值即可。

```cpp
#include <bits/stdc++.h>
#define _eggy_ using
#define _party_ namespace
_eggy_ _party_ std;

char a[110]; string s;
int p1;
unsigned p2;
long long p3;
unsigned long long p4;
int main()
{
	scanf("%s",a); s = a;
	sscanf(a,"%d",&p1);
	sscanf(a,"%u",&p2);
	sscanf(a,"%lld",&p3);
	sscanf(a,"%llu",&p4);
	if (to_string(p1) == s) puts("int");
	if (to_string(p2) == s) puts("unsigned int");
	if (to_string(p3) == s) puts("long long");
	if (to_string(p4) == s) puts("unsigned long long");
	printf("string\n");
    return 0;
}

```

---

## 作者：ryf2011 (赞：7)

# 1.题目思路
这里作者将使用赛时的一种字符串的奇妙做法。

## 1-1.必定是 string
首先，读完题目，看完范围，我们便可知道：$n$ 必须要使用 $\texttt{string}$ 进行输入。

其次，我们又发现，无论什么样的整数，它都可以用 $\texttt{string}$ 进行存储，字符数组也可，这里作者使用 $\texttt{string}$ 来存储。

## 1-2.string 的优势
作者赛时发现，$\texttt{string}$ 有一巨大优势：可以直接比较。 

与字符数组不同，它可以直接与另一个字符串比较，而不是使用功能。

而我们知道：

1. $\texttt{int}$ 能存储的范围为：\
   $-2147483648 \le n \le 2147483647$，\
   即 $-2^{31} \le n \le 2^{31} - 1$；
2. $\texttt{unsigned int}$ 能存储的范围为：\
   $0 \le n \le 4294967295$，\
   即 $0 \le n \le 2^{32} - 1$；
3. $\texttt{long long}$ 能存储的范围为：\
   $-9223372036854775808 \le n \le 9223372036854775807$，\
   即 $-2^{63} \le n \le 2^{63} - 1$；
4. $\texttt{unsigned long long}$ 能存储的范围为：\
   $0 \le n \le 18446744073709551615$，\
   即 $0 \le n \le 2^{64} - 1$。

于是，我们就可以把这些数直接套上双引号，使其直接变为字符串，与 $n$ 比较。

## 1-3.string 与数的比较
对于一个非负整数，我们可以采用以下代码与 $n$ 进行比较：

```cpp
if(n<="2147483647"){
    //do ...
}
```

而如果是一个负数呢？这时情况就比较特殊，我们采用以下代码：

```cpp
if(n<="-2147483648"){
    //do ...
}
```

对，就是这样。

## 1-4.结束了？
这样的代码依旧有些问题，为什么？

因为 $\texttt{string}$ 的这种直接比较无法特判两个字符串位数不相等的情况！

这时，我们就要用字符串的 $\texttt{.size()}$ 功能先进行位数判断！

我们又知道：

1. $\texttt{int}$ 能存储的最大数 $2147483647$ 共有 $10$ 位；
2. $\texttt{int}$ 能存储的最小数 $-2147483648$ 共有 $11$ 位（负数占 $1$ 位）；
3. $\texttt{unsigned int}$ 能存储的最大数 $4294967295$ 共有 $10$ 位；
4. $\texttt{long long}$ 能存储的最大数 $9223372036854775807$ 共有 $19$ 位；
5. $\texttt{long long}$ 能存储的最小数 $-9223372036854775808$ 共有 $20$ 位；
6. $\texttt{unsigned long long}$ 能存储的最大数 $18446744073709551615$ 共有 $20$ 位；

于是，我们先将位数不等的情况特判掉，再进行 1-3 中所说的比较。

# 2.代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
string s; //输入的 n
int main(){
    cin>>s;
    if(s[0]=='-'){ //负数
    	if(s.size()<11){ //特判位数不等
    		printf("int\n");
		}
		else{ //位数相等，直接判断
			if(s<="-2147483648"&&s.size()==11){
		    	printf("int\n");
			}	
		}
	    if(s.size()<20){ //同理
	    	printf("long long\n");
		}
		else{
			if(s<="-9223372036854775808"&&s.size()==20){
				printf("long long\n");
			}	
		}
	}
	else{
		if(s.size()<10){ //这里为了省事，直接将两个合并到一起写
			printf("int\n");
			printf("unsigned int\n");
		}
		else{
			if(s<="2147483647"&&s.size()==10){
		    	printf("int\n");
			}	
			if(s<="4294967295"&&s.size()==10){
				printf("unsigned int\n");
			}
		}
		if(s.size()<19){
			printf("long long\n");
		}
		else{
			if(s<="9223372036854775807"&&s.size()==19){
				printf("long long\n");
			}	
		}
		if(s.size()<20){
			printf("unsigned long long\n");
		}
		else{
			if(s<="18446744073709551615"&&s.size()==20){
				printf("unsigned long long\n");
			}	
		}
	}
    printf("string\n"); //string 一定可以存储
    return 0;
}
```

如有问题，欢迎指出。

#### 后记
更多内容，请移步至：

1. [$\color{red}\texttt{Luogu ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")；
2. [$\color{orange}\texttt{cnblogs（博客园） cnblogs2011ryf}$](https://www.cnblogs.com/cnblogs2011ryf)。

---

## 作者：_hud (赞：6)

# [题解：P12681 【MX-J15-T1】叉叉学习数据类型](https://luogu.com.cn/problem/P12681)

## 题目大意

给定一个整数 $n$，判断其能用哪几种给定的数据类型存储。

## 思路

模拟。细节。

显然的，`string` 可以以字符串类型存储任意整数，不必考虑。

先明确给定的四种数据类型范围：

| 类型                   | 是否有符号 | 最小值       | 最大值        |
| -------------------- | ----- | --------- | ---------- |
| `int`                | 是     | $-2^{31}$ | $2^{31}-1$ |
| `unsigned int`       | 否     | $0$       | $2^{32}-1$ |
| `long long`          | 是     | $-2^{63}$ | $2^{63}-1$ |
| `unsigned long long` | 否     | $0$       | $2^{64}-1$ |

首先，对于读入的整数 $n$，由于 $|n| \le 10^{100}$，我们使用字符串存储。若存在负号，则必然不可以用无符号数据类型存储。

然后对整数 $n$ 取绝对值。分类讨论：

1. 对于有符号类型，判断 $|n|$ 是否小于等于该类型能够存储的最大值即可。这里要注意 $n$ 是负数的情况，因为有符号类型最值的绝对值并不相同（相差 $1$）。特判即可。

2. 对于无符号类型，只需满足 $n \geq 0$ 且 $|n|$ 小于等于该类型能够存储的最大值即可。

那么这道题就迎刃而解了。还有一些实现的细节，可以看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
// 边界常量：有符号最大值 M，无符号最大值 MM，负数边界 T
const string M[2] = {"2147483647", "9223372036854775807"}, A[2] = {"int", "long long"}, MM[2] = {"4294967295", "18446744073709551615"}, T[2] = {"2147483648", "9223372036854775808"};
string s; bool no = 1;
// 比较 |n| 是否小于等于该类型最大值
inline bool check(string qwq) {
    int ls = s.length(), lq = qwq.length();
    return lq == ls ? qwq >= s : lq > ls;
}
signed main() {
    cin.tie(0), cout.tie(0) -> sync_with_stdio(0);
    cin >> s;
    if(s[0] == '-') s = s.substr(1), no = 0; // 去负号，标记为负数
    for(int i = 0; i < 2; ++i) {
        // 有符号
        if(check(M[i]) || (s == T[i] && !no)) cout << A[i] << '\n';
        // 无符号
        if(check(MM[i]) && no) cout << "unsigned " + A[i] << '\n';
    }
    cout << "string\n";
    return 0;
}
```

---

## 作者：封禁用户 (赞：6)

简单题。

首先，编写一个 `__int128` 类型的快读代码：

```cpp
__int128 read(){
    __int128 x=0,M=1,f=0,ff=1;
    M<<=120;
    char c=getchar();
    while(c<48||c>57){if(c=='-')ff=-1;c=getchar();}
    while(c>=48&&c<=57){x=(x*10+c-48);if(x>M)f=1,x=x%M;c=getchar();}
    if(f)puts("string"),exit(0);
    return (x+f*M)*ff;
}
```

这里为防止溢出，把模数设置为 $2^{120}$。可以发现，如果取了模，那么 $n$ 的绝对值一定大于等于 $2^{120}$，`long long` 和 `unsigned long long` 一定是存不下的，只能用 `string` 存。如果没有取模，则判断 $n$ 是否在各个数据类型的范围之内。

主函数代码：

```cpp
int main(){
    __int128 x=read();
    if(x<=INT_MAX&&x>=INT_MIN)cout<<"int"<<endl;
    if(x<=UINT_MAX&&x>=0)cout<<"unsigned int"<<endl;
    if(x<=LLONG_MAX&&x>=LLONG_MIN)cout<<"long long"<<endl;
    if(x<=ULLONG_MAX&&x>=0)cout<<"unsigned long long"<<endl;
    cout<<"string";
}
```

---

## 作者：EricWan (赞：2)

题解区怎么没有 pyhton？这种题 python 不是专业对口？

处理对速度要求不大的高精度题目，直接用 python 的 `int` 就好啦。

思路已经很简单了，但题解区都是 C++，像我这种刚学 OI 的锰锌根本不会处理字符串，所以 python 代码如下。

```python
n = int(input());
if n >= -(1 << 31) and n < (1 << 31) :
    print("int");
if n >= 0 and n < (1 << 32) :
	print("unsigned int");
if n >= -(1 << 63) and n < (1 << 63) :
	print("long long");
if n >= 0 and n < (1 << 64) :
	print("unsigned long long");
print("string");
```

---

## 作者：LoongPig (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12681)

## 思路

很简单的一道题。

需要注意以下几点：

- 输入的数据用 string 类型来存，其他的类型存不下。
- 比大小的时候，先比长度，再比字典序。

## 核心代码

[提交记录](https://www.luogu.com.cn/record/219203578)

```cpp
bool isint(string s){
	if(s[0]=='-'){
		string minn=to_string(INT_MIN);
		if (s.size()>minn.size()) return false;
		if (s.size()<minn.size()) return true;
		return s<=minn;
	}else{
		string maxx=to_string(INT_MAX);
		if (s.size()>maxx.size()) return false;
		if (s.size()<maxx.size()) return true;
		return s<=maxx;
	}
}
bool isuint(string s){
	if (s[0]=='-')return false;
	//unsiged没有负数
	string maxx=to_string(UINT_MAX);
	if(s.size()>maxx.size()) return false;
	if(s.size()<maxx.size()) return true;
	return s<=maxx;
}

bool isll(string s){
	if(s[0]=='-'){
		string minn=to_string(LLONG_MIN);
		if (s.size()>minn.size()) return false;
		if (s.size()<minn.size()) return true;
		return s<=minn;
	}else{
		string maxx=to_string(LLONG_MAX);
		if (s.size()>maxx.size()) return false;
		if (s.size()<maxx.size()) return true;
		return s<=maxx;
	}
}

bool isull(string s){
	if (s[0]=='-') return false;
	string maxx=to_string(ULLONG_MAX);
	if (s.size()>maxx.size()) return false;
	if (s.size()<maxx.size()) return true;
	return s<=maxx;
}
```

---

## 作者：littlesnake (赞：2)

水题，如果可以用当前数据类型存储，那么我们直接把它存起来，看是否与原来相同，每次乘 $10$ 加上数位上的数，最后一定是这个数。注意有些时候有负数的情况，无符号数据类型直接不输出，对于字符串，自然输出。注意有些时候负数与正数相同，不能直接去掉符号！（否则是会错一个测试点）代码如下：

```cpp
# include <bits/stdc++.h>
# define ll unsigned long long

using namespace std;

string n, m;
bool flag;

int main () {

	cin >> n;
	m = n;
	if (n[0] == '-') n.erase (0, 1), flag = 1;
	int ret = 0;
	for (char c : n) ret = (ret * 10) + (c - '0');
	if (flag) ret = -ret;
	if (to_string (ret) == m) cout << "int\n";
	
	if (flag != 1) {
		unsigned int ret1 = 0;
		for (char c : n) ret1 = (ret1 * 10) + (c - '0');
		if (to_string (ret1) == m) cout << "unsigned int\n";
	}
	
	long long ret2 = 0;
	for (char c : n) ret2 = (ret2 * 10) + (c - '0');
	if (flag) ret2 = -ret2;
	if (to_string (ret2) == m) cout << "long long\n";
	
	if (flag != 1) {
		unsigned long long ret3 = 0;
		for (char c : n) ret3 = (ret3 * 10) + (c - '0');
		if (to_string (ret3) == m) cout << "unsigned long long\n";
	}
	
	cout << "string";

	return 0;

}
```

---

## 作者：Perfect_Youth (赞：2)

签到题喵。

`int` 的范围是 $[-2^{31},2^{31})$，也就是 $[-2^{31},2^{31}-1]$。

`unsigned int` 的范围是 $[0,2^{32})$，也就是 $[0,2^{32}-1]$。

`long long` 的范围是 $[-2^{63},2^{63})$，也就是 $[-2^{63},2^{63}-1]$。

`unsigned long long` 的范围是 $[0,2^{64})$，也就是 $[0,2^{64}-1]$。

`string` **的长度范围**跟 `unsigned int` 的范围是一样的。

根据上面的条件判断即可，赛时代码：

```cpp
#include <bits/stdc++.h>
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1 , 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

inline
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

bool flag;

string s;

bool cmp(string x, string y, bool f) {
	if (x.size() > y.size()) return f ^ 1;
	if (x.size() < y.size()) return f;
	for (int i = 0; i < x.size(); i++) {
		if (x[i] > y[i]) return f ^ 1;
		if (x[i] < y[i]) return f;
	}
	return 1;
}

int main() {
	cin >> s;
	if (s[0] == '-') flag = 1, s.erase(0, 1);
	if (flag && cmp(s, "2147483648", 1)) {
		puts("int");
		puts("long long");
		puts("string");
	} else if (flag && cmp(s, "9223372036854775808",  1)) {
		puts("long long");
		puts("string");
	} else if (!flag && cmp("2147483647", s, 0)) {
		puts("int");
		puts("unsigned int");
		puts("long long");
		puts("unsigned long long");
		puts("string");
	} else if (!flag && cmp("9223372036854775807", s, 0)) {
		if (!flag && cmp("4294967295", s, 0)) puts("unsigned int");
		puts("long long");
		puts("unsigned long long");
		puts("string");
	} else {
		if (!flag && cmp("18446744073709551615", s, 0)) puts("unsigned long long");
		puts("string");
	}
	return 0;
}
```
~~关注 Perfect_Youth 谢谢喵。~~

---

## 作者：skyx (赞：1)

# 【MX-J15-T1】叉叉学习数据类型-题解
## 题意
给定一个可能非常大的整数 $n$（绝对值不超过 $10^{100}$），判断它可以用哪些数据类型存储。

### 范围处理
我们可以使用以下代码获得各种各样的极值：

```cpp
#include <iostream>
#include <climits>

int main() {
    std::cout << INT_MAX << std::endl;
    std::cout << INT_MIN << std::endl;
    std::cout << UINT_MAX << std::endl;
    std::cout << LLONG_MAX << std::endl;
    std::cout << LLONG_MIN << std::endl;
    std::cout << ULLONG_MAX << std::endl;
    return 0;
}
```

| 类型                | 最小值                     | 最大值                     |
|---------------------|---------------------------|---------------------------|
| `int`               | `-2147483648`             | `2147483647`              |
| `unsigned int`      | `0`                       | `4294967295`              |
| `long long`         | `-9223372036854775808`    | `9223372036854775807`     |
| `unsigned long long`| `0`                       | `18446744073709551615`    |

字符串总能存储任意大小的整数（整数在字符串中以 ASCII 字符形式存储）。
### 比较两个高精度数的大小

首先判断数字是否为负数（以 `-` 开头），分别处理有符号和无符号类型，具体比较规则如下：

1. **位数不同时**：直接比较字符串长度，较长的字符串表示的数更大。
   - 正数情况：位数多的数值更大
   - 负数情况：位数多的数值更小（因为绝对值更大）

2. **位数相同时**：从左到右逐字符比较，第一个不同字符的大小决定整个数的大小。
   - 正数情况：ASCII 码较大的字符对应的数值更大
   - 负数情况：ASCII 码较大的字符对应的数值更小（比较绝对值）


## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod = 1e9 + 7;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	string s;
	cin >> s;
	int l = s.size();
	if (s[0] == '-')
	{
		if ((s.substr(1) <= "2147483648" && l - 1 == 10) || l - 1 < 10) cout << "int" << endl;
		if ((s.substr(1) <= "9223372036854775808" && l - 1 == 19) || l - 1 < 19) cout << "long long" << endl;
		cout << "string";
	}
	else
	{
		if ((s <= "2147483647" && l == 10 ) || l < 10) cout << "int" << endl;
		if ((s <= "4294967295" && l == 10) || l < 10) cout << "unsigned int" << endl;
		if ((s <= "9223372036854775807" && l == 19) || l < 19) cout << "long long" << endl;
		if ((s <= "18446744073709551615" && l == 20) || l < 20) cout << "unsigned long long" << endl;
		cout << "string";
	}
	return 0;
}
```

---

## 作者：Evan2000 (赞：1)

## 思路

先搞四个数组，分别记录了 ```int```、```unsigned int```、```long long``` 和 ```unsigned long long``` 所能表示的最大值的各数位。

首先判断如果输入的数字是非负整数，那么就把所有的数据类型都判一遍，一个数位一个数位的判，如果遇到比自己小的数位，那就把 ```flag``` 改为 $1$，退出判断，如果遇到比自己大的数位，那就直接退出判断，注意需要判断数字的数位个数，如果输入的数字的数位个数比要判断的数据类型的最大值的数位个数要更大，那就把 ```flag``` 改为 $1$，否则改为 $0$。如果最后 ```flag``` 为 $0$，输出后判下一个数据类型，如果最后 ```flag``` 为 $1$，直接判下一个数据类型。

如果输入的数字是负整数，那就只判 ```int``` 和 ```long long```，因为 ```unsigned``` 开头的数据类型只能存储非负整数。判断是否可以的程序和上面所讲的一样，注意要先把负号给去掉，而且还需要把最大值加一。

根本不用管 ```string```，这玩意儿啥都能存。
## 赛时 AC 代码

因为代码有点长，所以稍微压了点行，不喜勿喷。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char s[210];
int INT[]={0,2,1,4,7,4,8,3,6,4,7};
int UINT[]={0,4,2,9,4,9,6,7,2,9,5};
int LLONG[]={0,9,2,2,3,3,7,2,0,3,6,8,5,4,7,7,5,8,0,7};
int ULLONG[]={0,1,8,4,4,6,7,4,4,0,7,3,7,0,9,5,5,1,6,1,5};
signed main(){
	scanf("%s",s+1);
	int len=strlen(s+1);
	if(s[1]!='-') {
		int flag=0;
		for(int i=1;i<=len;i++) {
			if(s[i]-'0'>INT[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<INT[i]) break;
		}
		if(len>10) flag=1;
		if(len<10) flag=0;
		if(!flag) {
			printf("int\n");
		}
        flag=0;
		for(int i=1;i<=len;i++) {
			if(s[i]-'0'>UINT[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<UINT[i]) break;
		}
		if(len>10) flag=1;
		if(len<10) flag=0;
		if(!flag) {
			printf("unsigned int\n");
		}
        flag=0;
		for(int i=1;i<=len;i++) {
			if(s[i]-'0'>LLONG[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<LLONG[i]) break;
		}
		if(len>19) flag=1;
		if(len<19) flag=0;
		if(!flag) {
			printf("long long\n");
		}
        flag=0;
		for(int i=1;i<=len;i++) {
			if(s[i]-'0'>ULLONG[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<ULLONG[i]) break;
		}
		if(len>20) flag=1;
		if(len<20) flag=0;
		if(!flag) printf("unsigned long long\n");
		printf("string");
	} else {
		len--;
		for(int i=1;i<=len;i++)
		{
			s[i]=s[i+1];
		}
		int flag=0;
		for(int i=1;i<=len;i++) {
			if(i==10)
			{
				INT[i]++;
			}
			if(s[i]-'0'>INT[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<INT[i]) break;
		}
		if(len>10) flag=1;
		if(len<10) flag=0;
		if(!flag) {
			printf("int\n");
		}
        flag=0;
		for(int i=1;i<=len;i++) {
			if(i==19)
			{
				LLONG[i]++;
			}
			if(s[i]-'0'>LLONG[i]) {
				flag=1;
				break;
			}
			else if(s[i]-'0'<LLONG[i]) break;
		}
		if(len>19) flag=1;
		if(len<19) flag=0;
		if(!flag) printf("long long\n");
		printf("string");
	}
	return 0;
}
```

---

## 作者：wxhnlex (赞：1)

[P12681 【MX-J15-T1】叉叉学习数据类型](https://www.luogu.com.cn/problem/P12681)

## 题目大意

给出一个数字 让我们判断 该数字可以用 `int`, `usigned int`, `long long`, `usigned long long`, `string`中的哪一些数据类型储存

我们只需要初始用`sring`类型存下该数 然后依次判断是否满足这五种数据类型所能满足的数据范围 然后再依次输出就可以了

**注意** ：1，`string`类型可以不加判断 所有数均可用`string`输出 因此可以在结尾直接输出`"string"`

2，对于`usigned int`, `usigned long long`除了要判断数字大小是否满足外 还要判断是否为负数 `usigned`类型只能储存正数

## AC代码:

```cpp
#include<bits/stdc++.h>
using namespace std;

inline bool checkInt(const string& s) {
    if (s[0] == '-') {
        string num = s.substr(1);
        if (num.size() > 10 || (num.size() == 10 && num > "2147483648")) return false;
        return true;
    } 
    if (s.size() > 10 || (s.size() == 10 && s > "2147483647")) return false;
    return true;
}

inline bool checkUInt(const string& s) {
    if (s[0] == '-') return false;
    if (s.size() > 10 || (s.size() == 10 && s > "4294967295")) return false;
    return true;
}

inline bool checkLL(const string& s) {
    if (s[0] == '-') {
        string num = s.substr(1);
        if (num.size() > 19 || (num.size() == 19 && num > "9223372036854775808")) return false;
        return true;
    }
    if (s.size() > 19 || (s.size() == 19 && s > "9223372036854775807")) return false;
    return true;
}

inline bool checkULL(const string& s) {
    if (s[0] == '-') return false;
    if (s.size() > 20 || (s.size() == 20 && s > "18446744073709551615")) return false;
    return true;
}

int main() {
    string s;
    cin >> s;

    if (checkInt(s)) cout << "int" << endl;
    if (checkUInt(s)) cout << "unsigned int" << endl;
    if (checkLL(s)) cout << "long long" << endl;
    if (checkULL(s)) cout << "unsigned long long" << endl;
    cout << "string" << endl;

    return 0;
}
```

---

## 作者：lcfollower (赞：1)

分类讨论题，有点烦。

对于判断一个整数的值 $a$（$64$ 位整数范围内）与另一个参考值 $k$ 的大小，我们可以直接使用**大于、小于或等于**进行比较。

但是这题难点就是这是一个字符串。

但是字符串使用**大于、小于、等于**比较的是**字典序的大小**。

于是分情况讨论（记 $k$ 的长度为 $len$）：

- 如果是负数和非负数比大小，简单。

- 如果有两个负数，取绝对值，然后比较，和两个非负数的结果**反一下**（绝对值之下，大于变小于，小于变大于，等于还是等于）。

- 下面对非负数进行详细的说明。

- 如果 $a$ 的长度小于 $len$，那么 $a < k$。

- 如果 $a$ 的长度等于 $len$，我们直接用 `a (<,=,>) k`（比较字典序）即可比较它们的大小，正确性显然。

于是这题就可以 AC 了，只不过代码打得很烦。

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e14

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

constexpr int N = 1e6 + 10;
string n;
string imi = "2147483648" ,im = "2147483647" ,ui =  "4294967295" ,lmi = "9223372036854775808",lm = "9223372036854775807",ul = "18446744073709551615";
//先找到分别对应得最大值，这里负数我用正数（绝对值）代替。
bool f;
signed main (){
  cin >> n;
  int len = n.size ();
  string p = n;
  if (p[0] == '-') f = 1 ,p.erase (0 ,1);//输入的数是负数。
// 分类讨论，可以看代码，逻辑不变，解释起来也是把代码人翻一下，没意义。

  if ((f && (p.size () < 10 || (p.size () == 10 && p <= imi))) || (!f && (n.size () < 10 || (n.size () == 10 && n <= im)))) puts ("int");

  if (!f && (n.size () < 10 || (n.size () == 10 && n <= ui))) puts ("unsigned int");

  if ((f && (p.size () < 19 || (p.size () == 19 && p <= lmi))) || (!f && (n.size () < 19 || (n.size () == 19 && n <= lm)))) puts ("long long");

  if (!f && (n.size () < 20 || (n.size () == 20 && n <= ul))) puts ("unsigned long long");

  puts ("string");
  return 0 ;
}
```

---

## 作者：swate114514 (赞：1)

首先，输入的数 $n$ 不管怎样都可以算 `string` 类型的。其次，我们可以根据输入的数是否有负号来判断是否为无符号整型。最后，判断是否在各个数据类型的数据范围内即可。

## Code
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string s;
    cin >> s;

    const string a = "2147483647", b = "2147483648";
    const string c = "4294967295", d = "9223372036854775807";
    const string e = "9223372036854775808", f = "18446744073709551615";

    bool m = s[0] == '-';
    string n = m ? s.substr(1) : s;

    bool i = false, u = false, l = false, o = false;

    if (m) {
        if (n.size() < b.size()) i = true;
        else if (n.size() == b.size() && n <= b) i = true;
    } else {
        if (n.size() < a.size()) i = true;
        else if (n.size() == a.size() && n <= a) i = true;
    }

    if (!m) {
        if (n.size() < c.size()) u = true;
        else if (n.size() == c.size() && n <= c) u = true;
    }

    if (m) {
        if (n.size() < e.size()) l = true;
        else if (n.size() == e.size() && n <= e) l = true;
    } else {
        if (n.size() < d.size()) l = true;
        else if (n.size() == d.size() && n <= d) l = true;
    }

    if (!m) {
        if (n.size() < f.size()) o = true;
        else if (n.size() == f.size() && n <= f) o = true;
    }

    if (i) cout << "int\n";
    if (u) cout << "unsigned int\n";
    if (l) cout << "long long\n";
    if (o) cout << "unsigned long long\n";
    cout << "string\n";

    return 0;
}
```

---

## 作者：jiangyunuo (赞：0)

### 大体思路：
看看数据范围，显然，这肯定是一道要用到字符串的题，毕竟 $|n| \le 10^{100}$，这肯定是不能用整型变量，因而我们肯定要用字符串。  
让我们判断可以存下 $n$ 的数据类型有哪些，我们要先知道各变量的数据范围：  

|数据类型|范围|
|:-:|:-:|
|int|$-2147483648 \sim 2147483647$|
|unsigned int|$0 \sim 4294967295$|
|long long|$-9223372036854775808 \sim 9223372036854775807$|
|unsigned long long|$0 \sim 18446744073709551615$|

至于 `string`，它作为字符串类型，$100$ 位还是可以存下的，因此，不管 $n$ 为几，它都可以存下 $n$。  
接着就是判断问题了。  
由于 $n$ 有正的情况，也有负的情况，以及 $0$ 的情况，因此我们分类讨论一下：  
#### $n$ 为正：
显然，在这样的情况下，每一种类型都得考虑，比较数据类型的最大值（注：这里的数据范围最大值以字符串形式存储）与 $n$ 的大小的时候，我们根据字符串比较的原理，我们要先比较位数，再比较每一位数字。  
比较位数，我们可以先算出 $n$ 的位数，再与数据类型的最大值的位数比较，如果位数不同，哪个位数多，哪个大，这是常识。  
比较数字，我们可以直接比较字符串，因为字符串之间的比较看的是字符串字典序的先后，当位数相同时，就需要比较字典序，得出哪个大，哪个小。  
如果 $n$ 比数据类型的最大值大，那么这个数据范围肯定是存不下 $n$ 的，反之则可以。  
#### $n$ 为负：
在这种情况下，我们不用考虑 `unsigned int` 和 `unsigned long long` 两种情况，同时比较的对象变为了 $n$ 与数据类型的最小值。  
我们还是先比较位数，在这里，字符串会把 `-` 也给当成一位，只不过两个比较对象都有 `-`，所以把 `-` 给算成一位并不影响结果。此时，谁的位数少，谁就大。  
比较数字就不多说啥了，与 $n$ 为正数一样，至于大小关系，也可以根据比较数位时的大小关系。  
最后，如果 $n$ 比数据类型的最小值大时，便可以存下，当然，你也可以认为位数多，字典序后算大，当然，这种情况下，$n$ 就得小于数据类型最小值才存得下。
#### $n$ 为 $0$ 时：
五种类型都存得下，其实你可以把此时的 $n$ 看成正数。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool pd(string x,string y){     //比较 $n$ 与数据类型的最大或最小值的大小。
	int len1=x.size();
	int len2=y.size();
	if(x<=y&&len1==len2||len1<len2)return 1;
	else return 0;
}
int main(){
	string a;
	cin>>a;
	string b="-2147483648";
	string c="2147483647";
	string d="4294967295";
	string e="-9223372036854775808";
	string f="9223372036854775807";
	string g="18446744073709551615";    //记录各个数据类型的范围。
	int len=a.size();
	if(a[0]=='-'){   //这里是 n 为负的情况，这里我认为位数多，字典序后算大，这种情况下，n 就得小于数据类型最小值才存得下。
		if(pd(a,b))cout<<"int"<<endl;
		if(pd(a,e))cout<<"long long"<<endl;
	}
	else{    //n 为正和 0 的情况。
		if(pd(a,c))cout<<"int"<<endl;
		if(pd(a,d))cout<<"unsigned int"<<endl;
		if(pd(a,f))cout<<"long long"<<endl;
		if(pd(a,g))cout<<"unsigned long long"<<endl;
	}
	cout<<"string"<<endl;   //不论 n 怎么样，string 一定能存下，所以单独拿出来输出。
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/219197984)。

---

## 作者：Ashankamiko (赞：0)

# 题目简述
### 题意
给定一个数 $N$，问：在 `int`、`unsigned int`、`long long`、`unsigned long long` 和 `string` 这几个数据类型中，哪几个可以存储 $N$，并按照顺序输出。
### 思路
只需要依次判断 $N$ 的大小是否符合该数据类型的存储条件，如果符合直接输出即可。

对于本题，大多数人的错误都是因为测试数据往往会贴着某个数据类型给出，这使得只要有一个细节错误整个测试点就错了，所以这题主要是细节问题。

以 `int` 举例，应该满足下列所有条件才符合存储条件。
- $N$ 大于等于 $-2147483648$。
- $N$ 小于等于 $2147483647$。

由于 $N$ 不会是小数，所以只要满足上述条件就可以直接输出 `int`。

那么其他数据类型也是一样的，本题难点在于细节和对数据类型范围的掌握，要注意：当数据类型为 `unsigned` 类时，其取值范围最小为 $0$，因为 `unsigned` 和指针这一类的有关，指针、下标等不能为负数。

由于本题的 $|N| \le 10^{100}$，所以对于所有数的比较，都要用字符串去比，由于系统比较字符串与比较数的方法不同，所以我们要按照下列方法正确比较字符串之间的大小。
- 先比较字符串的位数，位数小的就算小。
- 否则按照编译器比较字符串的方法比较（即从左往右比较）。

## [AC 代码](https://www.luogu.com.cn/record/219191686)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
string s, _int = "2147483648", llong = "9223372036854775808", _uint = "4294967295", _ullong = "18446744073709551615"; //常识

int main() {
	in >> s;
	string str = s;
	s = "";
	bool bo = (str[0] != '-'); //判断是否为负数
	for (int i = 0; i < str.size(); i++)
		if (isdigit(str[i])) //防止负号也加进s里
			s.push_back(str[i]);
	if (bo) { //如果是整数，可以考虑所有数据类型
		if (s.size() < _int.size() || (s < _int && s.size() == _int.size())) //满足条件就输出
			out << "int\n";
		if (s.size() < _uint.size() || (s <= _uint && s.size() == _uint.size()))
			out << "unsigned int\n";
		if (s.size() < llong.size() || (s < llong && s.size() == llong.size()))
			out << "long long\n";
		if (s.size() < _ullong.size() || (s <= _ullong && s.size() == _ullong.size()))
			out << "unsigned long long\n";
	} else { //unsigned不能为负数，所以只考虑int和long long
		if (s.size() < _int.size() || (s <= _int && s.size() == _int.size()))
			out << "int\n";
		if (s.size() < llong.size() || (s <= llong && s.size() == llong.size()))
			out << "long long\n";
	}
	out << "string"; //不论什么数据类型，string一定可以存储
	return 0;
}
```

---

## 作者：tangzirui1016 (赞：0)

如何判断两个用字符串存的数字的大小？
1. 先比较长度，长度长的一定越大
2. 再比较字典序，字典序大的就大

然后要明白 `int` 能存储的范围在 $[-2^{31},2^{31}-1]$ 之间，`unsigned int` 能存储的范围在 $[0,2^{32}-1]$ 之间，`long long` 能存储的范围在 $[-2^{63},2^{63}-1]$ 之间，`unsigned long long` 能存储的范围在 $[0,2^{64}-1]$ 之间，`string` 能存储这个题的所有输入。

因为 `int` 和 `unsigned int` 有 $4$ 个字节，`long long` 和 `unsigned long long` 有 $8$ 个字节，每个字节有 $8$ 个二进制位。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
string Imax="2147483647",Imin="-2147483648";
string UImax="4294967295",UImin="0";
string LLmax="9223372036854775807",LLmin="-9223372036854775808";
string ULLmax="18446744073709551615",ULLmin="0";
string s; 
bool check(string x,string y){ //x>=y
	if(x.size()!=y.size()) return x.size()>y.size();
	return x>=y;
}
int main(){
	cin>>s;
	if(s[0]=='-'){
		if(check(Imin,s)) cout<<"int\n";
		if(check(LLmin,s)) cout<<"long long\n";
		cout<<"string\n";
	}
	else{
		if(check(Imax,s)) cout<<"int\n";
		if(check(UImax,s)) cout<<"unsigned int\n";
		if(check(LLmax,s)) cout<<"long long\n";
		if(check(ULLmax,s)) cout<<"unsigned long long\n";
		cout<<"string\n"; 
	}
	return 0;
}
```

---

## 作者：b__b (赞：0)

首先无论如何 ```string``` 类型都是可以存储的，然后当这个整数带负号时 ```unsigned int``` 与 ```unsigned long long``` 都是不能存储的，因此遇到负数时先将这两个排除，然后去掉负号，继续判断。

下文以 ```int``` 举例，其他的类型类似。

```int``` 的存储范围为 $\left[-2^{31},2^{31}\right)$ 中的所有整数，而 $2^{31}=2147483648$，因此长度在 $10$ 位以内（不包括 $10$ 位）的整数都可以存储。

当长度为 $10$ 位时我们可以直接比较这个数与界限的大小关系，可以直接用 STL 的 string 类型自带的符号比较。

其他数据类型也是类似的。
```cpp
#include <iostream>
inline bool bj(const std::string &a, const std::string &b) {
    if (a.size() < b.size()) return 1;
    if (a.size() > b.size()) return 0;
    return a <= b;
}
int main() {
    std::string s;
    std::cin >> s;
    bool isf = s[0] == '-';
    if (isf) s = s.substr(1);
    if ((isf && bj(s, "2147483648")) || (!isf && bj(s, "2147483647"))) puts("int");
    if (!isf && bj(s, "4294967295")) puts("unsigned int");
    if (((isf && bj(s, "9223372036854775808")) || (!isf && bj(s, "9223372036854775807")))) puts("long long");
    if (!isf && bj(s, "18446744073709551615")) puts("unsigned long long");
    puts("string");
}
```

---

## 作者：UNNN (赞：0)

## 题意

 给一个整数 $n$，求这个数在哪一个数据类型的取值范围内。

## 思路

 由于范围中给出 $|n| \le 10^{100}$，因此需要用高精度存数字。

 随后，将 $n$ 和各个数据类型的范围边界比较，若在范围内则这个数据类型可以存储 $n$。

 以下给出各数据类型的范围：
- `int`: $-2,147,483,648 \le n \le 2,147,483,647$
- `unsigned int`: $0 \le n \le 4,294,967,295$
- `long long`: $-9,223,372,036,854,775,808 \le n \le 9,223,372,036,854,775,807$
- `unsigned long long`: $0 \le n \le 18,446,744,073,709,551,616$

 `string` 可以存储任意长度的数字，因此对于任意的 $n$，`string` 都应当输出。

 然后就是比较大小的问题。对于两个高精度数 $a$ 和 $b$，若 $a$ 的位数大于 $b$ 的位数，则 $a > b$；若 $a$ 的位数小于 $b$ 的位数。则 $a < b$。

 若 $a$ 的位数等于 $b$ 的位数，那么从低位起遍历，记 $a$ 和 $b$ 从低位开始第 $i$ 个数分别为 $a_i$ 和 $b_i$，只要遍历到 $a_i > b_i$，则 $a > b$；只要遍历到 $a_i < b_i$，则 $a < b$；若所有数字都相等，则 $a = b$。

 由于考虑负数，所以对于两个异号的数而言，正数大于负数。对于两个负数而言，因为数的绝对值越大反而越小，所以将以上的所有条件的不等号改变方向即可。

## Code


```cpp
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
struct bignum{
    int num[105], len, type;
    bignum(){
        len = 1; // 长度
        type = 0; // 正负，初始为 0
    }
    int &operator[](int i){
        return num[i];
    } // 定义 a[i] = a.num[i] 以便访问
    void strnum(string str){ // 字符串转高精度
        if(str == "0"){ // 为 0
            len = 1;
            type = 0;
            num[1] = 0;
            return ;
        }
        if(str.front() == '-') type = -1; // 有负号，正负改为负数
        else type = 1; // 没负号，为正数
        for(int i = 0;i < str.length();i++){
            if(!isdigit(str[i])) continue;
            num[str.length() - i] = str[i] - '0';
        } // 存储数字
        len = str.length();
        if(type == -1) len--;
        return ;
    }
    friend bool operator >(bignum a, bignum b){ // 定义大于号
        if(a.type < b.type) return false;
        if(a.type > b.type) return true;
        if(a.type == b.type && a.type == 0) return false;
        if((a.len > b.len && a.type == 1) || (a.len < b.len && a.type == -1)) return true;
        if((a.len < b.len && a.type == 1) || (a.len > b.len && a.type == -1)) return false;
        for(int i = a.len;i >= 1;i--){
            if((a[i] < b[i] && a.type == 1) || (a[i] > b[i] && a.type == -1)) return false;
            if((a[i] > b[i] && a.type == 1) || (a[i] < b[i] && a.type == -1)) return true;
        }
        return false;
    }
};
bignum retnum(string str){
    bignum res;
    res.strnum(str);
    return res;
} // 将字符串转换为高精度数
bignum n;
string inpn;
int main()
{
    cin >> inpn;
    n.strnum(inpn);
    // 正常的分支结构，开始比较
    if(n > retnum("-2147483649") && retnum("2147483648") > n) puts("int");
    if(n > retnum("-1") && retnum("4294967296") > n) puts("unsigned int");
    if(n > retnum("-9223372036854775809") && retnum("9223372036854775808") > n) puts("long long");
    if(n > retnum("-1") && retnum("18446744073709551616") > n) puts("unsigned long long");
    puts("string"); // 任何数字都可用 string 存储，因此最后输出 string
    return 0; // 结束 (｡･ω･｡)
}

```

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12681)
## 题目分析
希望审核大大给过。

这是一道模拟题。题面很明白，但是我们需要了解题目中`int`、`unsigned int`、`long long`、`unsigned long long` 的大小区间，如下：
```cpp
unsigned int 4294967295 0
unsigned long long 18446744073709551615 0
long long 9223372036854775807 -9223372036854775808
int 2147483647 -2147483648
```
上面的每行第一个为类型，第二个为上界，第三个为下界。
知道数据大小后便可以暴力枚举每一个，注意：如果不是无符号长整形，需要判断下界。

下面是代码。
## 题目[代码](https://www.luogu.com.cn/record/219186847)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define speed ios::sync_with_stdio(0),cin.tie(0), cout.tie(0);
string s;
bool ck;
signed main() {
	speed
	cin >> s;
	if(s[0]!='-')ck=1;
	else s=s.substr(1,s.size()-1);
	int len=s.size();
	if(len<10||(len==10&&s<="2147483647"&&ck)||(len==10&&s<="2147483648"&&!ck))cout<<"int\n";
	if((len<10||(len==10&&s<="4294967295"))&&ck)cout<<"unsigned int\n";
	if(len<19||(len==19&&s<="9223372036854775807"&&ck)||(len==19&&s<="9223372036854775808"&&!ck))cout<<"long long\n";
	if((len<20||(len==20&&s<="18446744073709551615"))&&ck)cout<<"unsigned long long\n";
	cout<<"string";
	return 0;
}
/*
unsigned int 4294967295
unsigned long long 18446744073709551615
long long 9223372036854775807 -9223372036854775808
int 2147483647 -2147483648
*/
求点赞关注qaq
```

---


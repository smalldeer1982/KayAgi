# 【MX-J15-T2】叉叉学习位运算

## 题目背景

原题链接：<https://oier.team/problems/J15B>。

## 题目描述

叉叉学习了两种位运算：`<<` 和 `>>`。为了避免 undefined behavior（未定义行为），叉叉只讨论非负整数下的情况。当 `<<` 时，最高位会溢出，最低位会补 `0`；当 `>>` 时，最低位会溢出，最高位会补 `0`。

小粉兔决定考考叉叉，于是想了两个非负整数 $a,b$。小粉兔希望叉叉判断，$a$ 能否利用若干次 `<< 1` 和 `>> 1` 运算变成 $b$。

叉叉出色地完成了这项任务，你可以完成吗？

## 说明/提示

**【样例解释】**

对于第一组数据，将 $1$ 进行一次 `>> 1` 运算可变成 $0$。

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2^{20}$，$0 \le a,b < 2^{64}$。

| 测试点编号  | $a,b <$ | 特殊性质 |
| :---------: | :-------: | :------: |
|   $1$    |    $2$    |          |
| $2$ | $4$ | |
| $3$ | $8$ | |
| $4$ | $2^{10}$ | |
| $5$ | $2^{20}$ | |
| $6$ | $2^{30}$ | $a,b$ 为 $2$ 的非负整数次幂 |
| $7$ | $2^{30}$ |  |
| $8$ | $2^{64}$ | $a,b$ 为 $2$ 的非负整数次幂 |
| $9 \sim 10$ | $2^{64}$ |  |



## 样例 #1

### 输入

```
6
1 0
0 1
3 7
7 3
4 6
153 6```

### 输出

```
Yes
No
No
Yes
No
Yes```

# 题解

## 作者：FeiYu32 (赞：21)

# 思路详解

需要点思维的题，主要是考察二进制。

因为 `>>1` 和 `<<1` 这两个操作是在二进制的基础上实现的，所以我们先把 $a$ 和 $b$ 转换成二进制再考虑。

而使用这两个运算后对原数最明显的变化就是所有数向左或向右移动一位，如果溢出，就会导致消失一位，且移动后留下的空位以 $0$ 补缺。于是在经历多次操作后，我们就能让 $a$ 的二进制形式前后各消失几位，因为前导零不影响二进制转十进制的计算，后导零可以通过右移来使其消失，从而修改 $a$ 的十进制数值。

又因为二进制相等的两个数相等，所以只需要通过删去 $a$ 的二进制形式的前后几位，使其与 $b$ 的二进制形式相等就能完成任务。换句话说，只要 $b$ 的二进制形式是 $a$ 的二进制形式的子串即可完成任务。

写完代码提交后我们就会发现只能获得 $10$ 分，还不如特殊性质获得的 $20$ 分多。问题就出在 $b$ 的二进制形式的后导零上。因为左移可以增加后导零，而在判断是否为子串的过程中可能会被 $a$ 的二进制形式中的其他位干扰，所以要提前去掉 $b$ 的二进制形式的后导零再进行判断子串的操作。

然后就可以获得 $70$ 分。注意到 $a$ 和 $b$ 的上限到达了 $2^{64}$，所以 long long 肯定会爆，因此需要用 __int128来代替它，这里我使用重载运算符来读入，这样就能获得满分了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
std::istream& operator>>(std::istream& is, __int128& n)
{
    string s;
    is>>s;
    n=0;
    bool negative=false;
    size_t start=0;
    if (s[0]=='-')
    {
        negative=true;
        start=1;
    }
    for(size_t i=start;i<s.size();i++)
    {
        n=n*10+(s[i]-'0');
    }
    if(negative)n=-n;
    return is;
}
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        __int128 a,b;
        long long c[100009],d[100009],e=0,f=0,ok1=0,qd0=1;
        cin>>a>>b;
        for(;a>0;)
        {
            e++;
            c[e]=a%2;
            a/=2;
        }
        for(;b>0;)
        {
            if(b%2!=0||qd0==0)
            {
                f++;
                d[f]=b%2;
                qd0=0;
            }
            b/=2;
        }
        for(int j=1;j<=e-f+1;j++)
        {
            int ok=1;
            for(int k=1;k<=f;k++)
            {
                if(d[k]!=c[j+k-1]){ok=0;break;}
            }
            if(ok==1){cout<<"Yes"<<endl;ok1=1;break;}
        }
        if(ok1==0)cout<<"No"<<endl;
    }
}
```

完结撒花！

---

## 作者：__qkj__ (赞：11)

## 解题思路

首先把输入的两个非负整数 $n,m$ 的二进制转成字符串，记为 $a,b$，由于 $a$ 可以左移，所以可以先把 $b$ 的后缀零都去掉。不用担心 $b$ 被删完。

接着，问题就转化成：$a$ 是否能删去左侧或右侧的一些字符，使得 $a$ 与 $b$ 相同？所以只要判断 $a$ 是否是 $b$ 的子串，就能得出答案。

**记得开 `unsigned long long`！**

## Code

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	BREAK:
	while(t--)
	{
		int n,m;
		cin>>n>>m;
		string a="",b="";
		/*转二进制*/
		for(int i=n;i;i/=2)a+=char(i%2+'0');
		for(int i=m;i;i/=2)b+=char(i%2+'0');
		reverse(a.begin(),a.end());
		reverse(b.begin(),b.end());
		/*删前缀零*/
		while(b.size()&&b[b.size()-1]=='0')b.erase(b.size()-1,1);
		/*判断子串*/
		if(a.find(b)!=string::npos)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：5)

这是一篇 C++ 题解，且全在二进制上讲解。
## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12682)
## 题目分析
希望审核大大给过。

这是一道考**二进制**的题，我一开始写的时候以为 `<<` 是乘 $2$，结果不是，浪费了一个小时。题目上说，`<<` 为左移，`>>` 为右移，也就是 `<<` 删除最左侧的二进制数，最后位补 $0$，`>>` 则反之。

那么这道题目则改为：是否可以在数字 $a$ 上进行删除最左或最右侧的字符使 $a$ 字符串与 $b$ 字符串相等？

那么就可以算出 $a$ 和 $b$ 的二进制，并且判断 $a$ 是否为 $b$ 的子串即可。（由于 $a$ 可以在末尾补 $0$，所以可以将 $b$ 的二进制的后缀零删掉）

下面是代码。
## 题目[代码](https://www.luogu.com.cn/record/219320725)
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define speed ios::sync_with_stdio(0),cin.tie(0), cout.tie(0);
using namespace std;
signed main(){
	speed
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		string a="",b="";
		for(int i=n;i;i/=2)a+=char((i%2)+'0');
		for(int i=m;i;i/=2)b+=char((i%2)+'0');
		reverse(a.begin(),a.end());
		reverse(b.begin(),b.end());
		while(b.size()&&b[b.size()-1]=='0')b.erase(b.size()-1,1);//删除末尾的0
		if(a.find(b)!=-1)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
// 作者不易，关注点赞一下吧qwq
```

---

## 作者：Sunrise_up (赞：4)

这道题是思维题。

## 思路

> 当 `<<` 时，最高位会溢出，最低位会补 `0`；当 `>>` 时，最低位会溢出，最高位会补 `0`。

这道题有个坑点，这里的位运算是会溢出的。所以，这一题，我们需要将 $a,b$ 转换为二进制数。

我们很容易得出，如果 $b$ 的二进制恰好是 $a$ 的二进制的一段，那么就可以转换，否则就不可以。

那么这就变成了 KMP 问题。

OI 十年一场空，不开 `unsigned long long` 见祖宗。

## Code

为照顾新手，这里不用太过高级的写法。


```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
unsigned long long n,m;
string a,b;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>m;
		a="",b="";
		for(unsigned long long i=n;i!=0;i/=2)a+=char(i%2+'0');
		for(unsigned long long i=m;i!=0;i/=2)b+=char(i%2+'0');
		reverse(a.begin(),a.end());
		reverse(b.begin(),b.end());
		while(b.size()&&b[b.size()-1]=='0')b.erase(b.size()-1,1);
		if(a.find(b)!=string::npos)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

以下关于数位均指二进制意义下，而非十进制意义下。

首先我们发现，```<<1``` 和 ```>>1``` 运算可以去除 $a$ 的开头若干位和末尾若干位，并且可以在 $a$ 的末尾补若干个 $0$。因此先把 $b$ 末尾的 $0$ 全部删掉，记为 $b'$，若 $b'$ 为 $a$ 的子串（即 $a$ 的某一段连续数位对应的值为 $b'$），则输出 ```Yes```，否则输出 ```No```。

~~然后 KMP 直接秒掉。~~

考虑使用一种类似于 hash 的思路，我们利用位运算 $O(1)$ 求出 $a$ 的某一个子串，由于 $b'$ 的长度（$\log_2b'$）是固定的，我们只需要枚举最多 $64$ 个子串。

时间复杂度 $O(T\log a)$。

代码展示，记得用 ```unsigned long long```：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,x;
unsigned long long a,b,c;
bool f;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t;
	while(t--){
		f=0;
		cin>>a>>b;
		if(b==0){
			f=1;
		}
		else{
			while((b&1)==0){
				b>>=1;
			}
			c=b;
			x=0;
			while(c){
				x++;
				c>>=1;
			}
			for(int i=0;i<=64-x;i++){
				if((a<<(64-i-x)>>(64-x))==b){
					f=1;
				}
			}
		}
		if(f){
			cout<<"Yes\n";
		}
		else{
			cout<<"No\n";
		}
	}
	return 0;
}
```

---

## 作者：EricWan (赞：1)

注：一切讨论在二进制下。

题目的对 $a$ 的操作等价于：删除最高位最低位补 $0$，删除最低位最高位补 $0$。

称一个数的有效位为最高 $1$ 位和最低 $1$ 位中间的数，那么操作后的 $a$ 的有效位肯定为 $a$ 的一个子段，这显然是冲要的。

$a$ 操作后要求变为 $b$，那么当且仅当 $b$ 的有效位为 $a$ 的子段。

要分析的分析完了，下面讲一下算法流程。

我们先把 $b$ 不断除以二使得的它是奇数，然后找到一个最小的大于现在的 $b$ 的二的非负整数次幂 $2^k$，枚举 $b$ 在 $a$ 中的位置，判断条件为当且仅当存在一个非负整数 $x$ 使得 $\lfloor\frac a{2^x}\rfloor\bmod2^k=b$，$a$ 可以通过操作得到 $b$。（注意特批 $b=0$ 时输出 `Yes`。）

---

## 作者：tomAmy (赞：1)

## 题目大意

给定非负整数 $a,b$，对 $a$ 任意进行 `<<` 和 `>>` 操作，是否能使其变为 $b$。

## 分析

`>>` 操作：消除二进制的末位。

`<<` 操作：消除二进制的首位，末尾补零。

由左移操作，我们可以忽略 $a,b$ 末尾的零。两个操作均为消除首位和末位，所以仅需要判断二进制下 $a$ 是否包含 $b$ 即可。

思路很清晰，但实现起来并不容易，这题的常数卡的很紧，如果暴力转二进制会超时，我们考虑位运算。去掉末尾的零，可以通过除以 lowbit 实现。而判断二进制下 $a$ 是否包含 $b$，则可以通过不断右移，取末几位，实现起来就是 `&` 一个二进制下全为一的数。

考场上被这题硬控了两个小时，实际上问题出在了求与 $b$ 长度相同的全为一的二进制数。注意这里一定要通过求 $b$ 的二进制位数来右移，这是修改前的代码：

```cpp
t = 1;
while (t <= b) t <<= 1;
t--;
```

其超时原因大概是比较运算太费时间，导致被卡了。写篇题解纪念一下。

以下是代码：

```cpp
#include <iostream>
using namespace std;

int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		unsigned long long a, b, t, c;
		scanf("%llu%llu", &a, &b);
		if (b == 0) printf("Yes\n");
		else if (a == 0) printf("No\n");
		else
		{
			a = a / (a & -a);
			b = b / (b & -b);
			c = b, t = 1;
			while (c) c >>= 1, t <<= 1;
			t--;
			bool flag = 0;
			while (a >= b)
			{
				if ((a & t) == b) flag = 1;
				a >>= 1;
			}
			if (flag) printf("Yes\n");
			else printf("No\n");
		}
	}
	return 0;
}
```

---

## 作者：Vector_net (赞：1)

其实本质是一个数学题。

### 题目分析：
这里的数字 $a$,$b$ 均只涉及到二进制操作，我们不妨先把 $a$,$b$ 转为二进制。

然后，我们考虑满足什么条件才能使 $a$ 能够变成 $b$。我们发现，根据题目中“高位溢出、低位溢出”的规则，我们可以通过操作使得 $a$ 头上的 $1$ 和尾巴上的 $1$ 没掉。于是，我们自然想到问题即为判断 $b$ 的二进制串是否为 $a$ 的子串。如果去写并提交就会发现只有 $10pts$。实际上，这是我们忽略了一个问题，就是 可以通过操作在 $a$ 的末尾加上 $0$。于是，我们提前把 $a$,$b$ 末尾的 $0$ 去掉即可。

### 代码：
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int T,a,b;
inline int read(){
	int ret=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-f;c=getchar();}
	while(isdigit(c)){ret=ret*10+c-'0';c=getchar();}
	return ret*f;
}
inline string to_bin(int n){
	string res;
	while(n)res.push_back(n%2+'0'),n>>=1;
	reverse(res.begin(),res.end());return res;
}
inline void work(string &A,string &B){
	while(A.back()=='0')A.pop_back();
	while(B.back()=='0')B.pop_back();
}
signed main(){
	T=read();
	while(T--){
		a=read(),b=read();string A=to_bin(a),B=to_bin(b);work(A,B);
		if(A.find(B)!=-1)printf("Yes\n");else printf("No\n");
	}
	return 0;
}
```

---

## 作者：b__b (赞：0)

（下文中默认是将数字以二进制表示）

首先我们可以将 $a$ 与 $b$ 后面的 $0$ 全部消掉，因为这些 $0$ 总可以通过左移得到。
```cpp
while (!(a & 1)) a >>= 1;
while (!(b & 1)) b >>= 1;
```
接着我们可以想到获得 $a$ 与 $b$ 里面的 $1$ 的个数。
```cpp
inline int count1(ull p) {
    int r = 0;
    for (; p; p >>= 1) if (p & 1) ++r;
    return r;
}
```
下文用 $\mathrm{a1}$ 表示 $a$ 里面 $1$ 的个数，$\mathrm{b1}$ 表示 $b$ 里面 $1$ 的个数。

显然，左移和右移操作只能减少而不能增加 $1$ 的个数，因此 $\mathrm{a1} < \mathrm{b1}$ 时无法得到。

下文我们分类讨论。

当 $\mathrm{a1} = \mathrm{b1}$ 时，我们只需要判断 $a$ 是否等于 $b$ 即可，因为上面已经将后面的 $0$ 去除了，左移和右移都不能改变 $1$ 的相对位置。

当 $\mathrm{a1} > \mathrm{b1}$ 时，我们只需要确定 $b$ 的二进制序列是否在 $a$ 存在就行了，因为 $a$ 前面的 $1$ 都可以通过左移溢出去除。

现在我们考虑如何进行这个操作。

显然，我们需要将 $a$ 前面多余的 $1$ 去除，这时我们可以用按位与操作，我们可以获得一个数，将 $b$ 的最前面的 $1$ 之后的所有位置 $1$，用这个数与 $a$ 进行按位与操作。每次将 $a$ 右移一位，这样可以遍历 $a$ 中的所有 $1$。

现在我们考虑如何找到这个数。

显然，$2^{\lfloor \log_2b+1\rfloor}-1$ 就是这个数，但是当 $b=2^{63}+a$ （$a$ 为非负整数）时 $\lfloor \log_2b+1\rfloor = 64$，而 $2^{64}$ 会溢出，因此我们需要加一个特判。

```cpp
#include <iostream>
#include <cmath>
typedef unsigned long long ull;
inline int cou1(ull p) {
    int r = 0;
    for (; p; p >>= 1) if (p & 1) ++r;
    return r;
}
int T, a1, b1;
ull a, b, tmp;
int main() {
    for (scanf("%d", &T); T--;) {
        scanf("%llu%llu", &a, &b), a1 = cou1(a), b1 = cou1(b);
        if (!b) goto yes;
        if (a1 < b1) goto no;
        while (!(a & 1)) a >>= 1;
        while (!(b & 1)) b >>= 1;
        if (a1 == b1) if (a == b) goto yes; else goto no;
        if (a1 > b1) {
            if (b & (1ull << 63)) tmp = -1; //无符号整数会溢出
            else tmp = (1ull << ((int) log2(b) + 1)) - 1;
            for (; a; a >>= 1) if ((a & tmp) == (b & tmp)) goto yes;
            goto no;
        }
        yes:
        puts("Yes");
        continue;
        no:
        puts("No");
    }
}
```

---

## 作者：fish_love_cat (赞：0)

奶龙题啊。

---

首先观察到溢出可以将首尾部分 $1$ 删除，那么题面就转化为给两个 $\texttt{01}$ 串 $a,b$，求 $b$ 是否为 $a$ 的子串。

显然可以 KMP。

---

上面是口胡，或许直接转成字符串写 KMP 可以躲开这题关于位运算的一大堆坑，但是风铃草并没有选择这么做。

我们把 $b$ 在不溢出的前提下靠到右侧，然后让 $a$ 不断右移并自然溢出，然后利用位运算判断是否为子串。

但是本题数据范围有点大，`ull` 我不知道为什么玄学挂掉了，开 `__int128` 然后发现位运算失效了。

挺玄乎的，所以最后就搞的跟暴力匹配差不多了。

不如转成字符串去做。

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
int read(){
    int sum=0,fish=1;
    char c=getchar_unlocked();
    while((c<'0'||c>'9')&&c!='-')c=getchar_unlocked();
    if(c=='-')fish=-1,c=getchar_unlocked();
    while(c>='0'&&c<='9')sum=sum*10+(c-'0'),c=getchar_unlocked();
    return sum*fish;
}
void print(int x){
    if(x<0)putchar_unlocked('-'),x=-x;
    if(x<10)putchar_unlocked(x+'0');
    else print(x/10),putchar_unlocked(x%10+'0');
}
void solve(){
    int a=read(),b=read();
    while(!(b&1)&&b)
        b>>=1;
    // print(b);
    int c=b,d=b;
    for(int i=0;d;d>>=1,i++){
        int x=1;
        for(int j=1;j<=i;j++)x<<=1;
        c|=x;
    }
    // print(c);
    do{
        if((a&c)==b){
            puts("Yes");
            return;
        }
        a>>=1;
    }while(a);
    puts("No");
}
signed main(){
    int t=read();
    while(t--)solve();
    return 0;
}
```

---


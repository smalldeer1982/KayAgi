# [语言月赛 202403] szmgo

## 题目背景

本题请参考文字题解。

shinzanmono 想要学习 szm 语，但是 szm 语太难了。

## 题目描述

现代 szm 语采用罗马字表示，其划分音节的规则如下：

- 规定元音是字符 `a`、`e`、`i`、`o`、`u` 之一。
- 一般地，一个音节仅包含一个元音，并且以元音结尾。
- 特别地，当且仅当 `n` 后第一个字符不是元音时，`n` 单独作一个音节。
- 一个音节至多包含 $3$ 个字符。

举个例子，`shinzanmono` 的音节依次为 `shi` `n` `za` `n` `mo` `no`；`naku` 的音节依次为 `na` `ku`。

如果一个字符串是空串或者不能按照以上规则划分，则这个字符串不合法。**题目描述中给出的字符串和测试数据中输入的字符串全部合法，你无需进行合法性检验。**

将字符串 $S$ 的 $k$ 个音节依次表示为 $S'_1 \sim S'_k$，将另一个字符串 $T$ 的 $m$ 个音节依次表示为 $T'_1 \sim T'_m$。

如果存在一个正整数 $p$，满足 $p+m-1 \leq k$ 且对于从 $p$ 到 $p+m-1$ 的每个正整数 $i$ 都有 $S'_i=T'_{i - p + 1}$，那么称 $S$「包含」$T$。

在 szm 语中有一些习语，一种习语对应有一些固定的字符串。如果一个字符串「包含」且仅「包含」一种习语的一个固定子串，那么这个字符串是这种习语，否则这个字符串不是这种习语。

例如，当一种习语对应的子串只有 `ao` 时，字符串 `nao` 不是这种习语，因为 `nao` 的音节依次为 `na` `o`，而 `ao` 的音节依次为 `a` `o`。另一个例子是，如果敬语对应的子串为 `desu` 和 `suma`，那么 `kyuusaidesu` 是敬语，而 `kyuusaidesuma` 和 `kyuusaidema` 不是敬语。

某种习语对应 $n$ 个长度不超过 $10$ 的不同子串，给定 $q$ 个字符串，判断每个字符串是否是这种习语。

## 说明/提示

### 数据规模与约定

对于 $30\%$ 的数据，保证习语对应的所有字符串都没有由单个元音组成的音节。  
对于另外 $30\%$ 的数据，保证习语对应的所有字符串均只包含一个音节。  
对于 $100\%$ 的数据，$1 \leq n \leq 10$，$1 \leq q \leq 10^5$，习语对应的每个子串的长度不超过 $10$ 且两两不同，询问的 $q$ 个字符串的字符个数之和不超过 $5 \times 10^5$，输入的所有字符串均只包含小写字符。

## 样例 #1

### 输入

```
2 4
desu
suma
kyuusaidesu
kyuusaidesuma
kyuusaidema
desudesu
```

### 输出

```
Yes, Commander
No, Commander
No, Commander
Yes, Commander
```

# 题解

## 作者：RyanLi (赞：4)

## Source & Knowledge

2024 年 3 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

现代 szm 语采用罗马字表示，其划分音节的规则如下：

- 规定元音是字符 `a`、`e`、`i`、`o`、`u` 之一。
- 一般地，一个音节仅包含一个元音，并且以元音结尾。
- 特别地，当且仅当 `n` 后第一个字符不是元音时，`n` 单独作一个音节。
- 一个音节**至多**包含 $3$ 个字符。

将字符串 $S$ 的 $k$ 个**音节**依次表示为 $S'_1 \sim S'_k$，将另一个字符串 $T$ 的 $m$ 个**音节**依次表示为 $T'_1 \sim T'_m$。

如果存在一个正整数 $p$，满足 $p+m-1 \leq k$ 且对于从 $p$ 到 $p+m-1$ 的每个正整数 $i$ 都有 $S'_i=T'_{i - p + 1}$，那么称 $S$「包含」$T$。

在 szm 语中有一些习语，一种习语对应有一些固定的字符串。如果一个字符串「包含」且仅「包含」一种习语的**一个**固定子串，那么这个字符串是这种习语。

某种习语对应 $n$ 个子串，给定 $q$ 个字符串，判断每个字符串是否是这种习语。

## 题目分析

注意到，询问的 $q$ 个字符串的字符个数不超过 $5 \times 10^5$。我们需要在被询问的字符串中匹配这种习语的子串，对于这样的数据范围，直接使用字符串查找子串函数 `s.find()` 即可。

但是，szm 语允许单个元音构成一个音节。如果出现例如子串为 `a`，而查找到的位置的音节为 `za`，那么此时就会产生错误的匹配，导致答案错误。

我们设询问的字符串为 $s$，查找到的位置（在 $s$ 中的下标）为 $pos$。那么如果 $pos \ne 0$，而且 $s_{pos}$ 是元音，那么就需要判断 $s_{pos - 1}$ 是否为辅音。如果为辅音，那么就可以和 $s_{pos}$ 组成一个音节，那么当前位置就无法完成匹配，需要继续向后查找。

为了缩短代码，可以编写如下函数，用于判断字符 $c$ 是否为元音。

```cpp
bool vowel(char c) {
    return c == 'a' || c == 'i' || c == 'u' || c == 'e' || c == 'o';
}
```

同样地，由于 szm 语允许 `n` 单独构成一个音节，因此我们还需要判断匹配到的子串的末尾位置 $pos'$ 是否为字符 `n`。如果是，并且 $pos'$ 不是 $s$ 的末尾位置，那么就需要判断 $s_{pos' + 1}$ 是否为元音。

如果 $s_{pos'}$ 是 `n` 且 $s_{pos' + 1}$ 不存在或不为元音，或者 $s_{pos'}$ 不为 `n`，那么说明匹配成功，就给匹配数加一，然后跳出循环，匹配下一个子串。

在匹配完所有子串后，如果只有一个子串成功匹配，那么表明这个字符串是这种习语，输出 `Yes, Commander`，否则输出 `No, Commander`。

```cpp
cin >> n >> q;
for (int i = 1; i <= n; ++i) cin >> a[i];
while (q--) {
    cnt = 0;
    cin >> s;
    for (int i = 1; i <= n; ++i) {
        pos = s.find(a[i]);
        if (pos == s.npos) continue;
        while (pos != s.npos) {
            if ((vowel(s[pos]) && pos && !vowel(s[pos - 1])) || (!vowel(s[pos]) && pos && !vowel(s[pos - 1]) && s[pos - 1] != 'n')) {
                pos = s.find(a[i], pos + 1);
                continue;
            } if ((s[pos + a[i].size() - 1] == 'n' && (pos + a[i].size() >= s.size() || (pos + a[i].size() < s.size() && !vowel(s[pos + a[i].size()])))) || s[pos + a[i].size() - 1] != 'n') {
                ++cnt;
                break;
            } pos = s.find(a[i], pos + 1);
        }
    } cout << (cnt == 1 ? "Yes, Commander\n" : "No, Commander\n");
}
```

## 完整代码

```cpp
#include <iostream>
using namespace std;

const int N = 15;
int n, q, cnt, pos;
string a[N], s;
bool flag;

bool vowel(char c) {
    return c == 'a' || c == 'i' || c == 'u' || c == 'e' || c == 'o';
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    while (q--) {
        cnt = 0;
        cin >> s;
        for (int i = 1; i <= n; ++i) {
            pos = s.find(a[i]);
            if (pos == s.npos) continue;
            while (pos != s.npos) {
                if ((vowel(s[pos]) && pos && !vowel(s[pos - 1])) || (!vowel(s[pos]) && pos && !vowel(s[pos - 1]) && s[pos - 1] != 'n')) {
                    pos = s.find(a[i], pos + 1);
                    continue;
                } if ((s[pos + a[i].size() - 1] == 'n' && (pos + a[i].size() >= s.size() || (pos + a[i].size() < s.size() && !vowel(s[pos + a[i].size()])))) || s[pos + a[i].size() - 1] != 'n') {
                    ++cnt;
                    break;
                } pos = s.find(a[i], pos + 1);
            }
        } cout << (cnt == 1 ? "Yes, Commander\n" : "No, Commander\n");
    } return 0;
}
```

---


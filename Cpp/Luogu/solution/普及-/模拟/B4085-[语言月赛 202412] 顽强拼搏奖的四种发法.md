# [语言月赛 202412] 顽强拼搏奖的四种发法

## 题目描述

在 XCPC 竞赛里，会有若干道题目，一支队伍可以对每道题目提交若干次。我们称一支队伍对一道题目的一次提交是有效的，当且仅当：

- 在本次提交以前，还未通过该题目。
- 本次提交的题目在比赛里最终被该队伍通过了。

注意，事实上，在通过一道题目后，一支队伍仍然可以提交该题目。这样的提交是**无效提交**，同时，无论这样的提交是否通过，都不会影响该队伍**已通过**该题目的状态。

我们按顺序给出本场比赛所有队伍的全部提交记录，每条记录是一个三元组 $(tid_i, pid_i, state_i)$，其中 $tid_i$ 表示提交这条记录的队伍编号，$pid_i$ 表示这条记录所提交的题目编号，$state_i$ 表示这条记录的状态是未通过/通过。

如果一支队伍在比赛里通过了至少 $k$ 道不同的题目，则它们获得了奖牌。

你要求出本场比赛的**顽强拼搏奖**归属于哪支队伍。很遗憾的是，每个主办方对顽强拼搏奖的定义是不同的，因此你需要按如下四种计算方法分别计算获得顽强拼搏奖所归属的队伍编号：

1. 最后一次 AC 记录所对应的队伍。
2. 最后一次**有效** AC 记录所对应的队伍。
3. 未获得奖牌的队伍的最后一次**有效** AC 提交对应的队伍。
4. 最后一次使得一支队伍的通过题目数由 $0$ 变成 $1$ 的提交所对应的队伍。


## 说明/提示

### 样例 1 解释

这个样例共有 $4$ 支队伍，两道题目。解出两道题目的队伍可以获奖。

- 整场比赛的最后一次 AC 提交是第八条记录，$1$ 号队伍提交第二题通过。因此第一种定义计算出的顽强拼搏奖是队伍 $1$；  
- 队伍 $1$ 在第二条记录时就已通过第二题，所以第八条记录不是一条有效提交记录。最后一条 AC 的有效提交记录是第七条。因此第二种定义计算出的顽强拼搏奖是队伍 $2$；  
- 只有队伍 $3$ 没有获奖，它们的最后一次提交是第四条记录，因此按第三种定义计算的顽强拼搏奖是队伍 $3$；  
- 队伍 $4$ 是最后一个通过题目数由 $0$ 题变为 $1$ 题的队伍。其对应的提交记录是第五条。因此按第四种定义计算的顽强拼搏奖是队伍 $4$。

### 数据规模与约定

| 测试点编号 | $n$ | $t$ | $p$ | 特殊约定 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $=1$ | $=1$ | $=1$ | 无 |
| $2,3$ | $\leq 100$ | $=1$ | $\leq 100$ | 无 |
| $4,5$ | $\leq 100$ | $\leq 100$ | $=1$ | 无 |
| $6,7$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 一支队伍只会通过一道题至多一次 |
| $8,9,10$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 无 |

对全部的测试数据，保证 $1 \leq n \leq 1000$，$1 \leq tid_i \leq t \leq 100$，$1 \leq pid_i \leq p \leq 100$，$1 \leq k \leq p$，$0 \leq state_i \leq 1$。

## 样例 #1

### 输入

```
8 4 2 2
1 1 1
1 2 1
2 2 1
3 1 1
4 1 1
4 2 1
2 1 1
1 2 1```

### 输出

```
1 2 3 4```

# 题解

## 作者：一扶苏一 (赞：8)

# [语言月赛 202412] 顽强拼搏奖的四种发法 题解
## Source & Knowledge
本题来源于 2024 年 12 月的语言月赛，主要考察二维数组和模拟。
## 文字题解
### 题目大意
根据给定的提交记录，按照四种不同的规则确定获得顽强拼搏奖的队伍编号。
### 解析
【读入】  
由于必须先确定那些队伍是获得奖牌的队伍，所以必须把所有提交记录先读入进来存储下来再做操作。我们用一个数组 `record[i][3]` 的三个数分别表示一条记录的 tid,pid 和 state。同时，我们用一个 pass 数组来记录一支队伍通过了哪些题。
```cpp
for (int i = 1; i <= n; ++i) {
  cin >> record[i][0] >> record[i][1] >> record[i][2];
  int tid = record[i][0], pid = record[i][1];
  if (record[i][2]) pass[tid][tid] = 1;
}
```
【获奖判定】  
解出至少 $k$ 题的队伍获奖，因此可以通过检查 `pass[i]` 数组里有多少个 $1$ 来确定第 $i$ 支队伍是否获奖，然后把是否获奖存储在 `win` 数组里。

```cpp
for (int i = 1; i <= t; ++i) {
  int cnt = 0;
  for (int j = 1; j <= p; ++j) if (pass[i][j]) ++cnt;
  if (cnt >= k) win[i] = true;
}
```

【顽强拼搏奖判定】  
接下来重新遍历一遍提交信息，按规定判定更新顽强拼搏奖即可。
```cpp
int a = -1, b = -1, c = -1, d = -1;
for (int i = 1; i <= n; ++i) {
  int tid = record[i][0], pid = record[i][1], state = record[i][2];
  if (state == 1) {
    a = tid;
    if (!passed[tid][pid]) {
      b = tid;
      if (!win[tid]) c = tid;
      int curpassed = 0;
      for (int j = 1; j <= p; ++j) curpassed += pass[tid][j];
      if (curpassed == 0) {
        d = tid;
      }
    }
    passed[tid][pid] = 1;
  }
```
注意这里重新维护了每个题目的通过情况，因此要事先清空 `pass` 数组。


通过上述步骤，我们可以有效地计算出按照四种不同规则获得顽强拼搏奖的队伍编号。

---


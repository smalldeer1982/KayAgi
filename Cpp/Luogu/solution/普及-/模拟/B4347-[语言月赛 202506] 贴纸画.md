# [语言月赛 202506] 贴纸画

## 题目描述

小 A 得到了一张 $n$ 行 $m$ 列的空白大画纸，准备用贴纸来创作一幅画。

小 A 有一张 $c$ 行 $c$ 列的“图案纸”，上面画满了五颜六色的图案。同时，他还有 $k$ 张长方形的透明贴纸。

他会按顺序将这 $k$ 张贴纸依次贴到大画纸上。对于每一张贴纸，我们知道以下信息：
1.  它要贴在画纸上的区域：从左上角格子 $(x_1, y_1)$ 到右下角格子 $(x_2, y_2)$。
2.  它要使用的图案：图案来自于“图案纸”上以 $(x_t, y_t)$ 为左上角的对应区域。也就是说，画纸上的 $(x_1, y_1)$ 格子会被着上图案纸上 $(x_t, y_t)$ 的颜色；画纸上的 $(x_1+1, y_1+2)$ 格子会被着上图案纸上 $(x_t+1, y_t+2)$ 的颜色，以此类推。
3.  它的**重要性** $p$：这是一个整数。当两张贴纸覆盖了同一个格子时，**重要性数值更大**的贴纸会盖在上面。

现在，给你所有贴纸的信息，请问当小 A 把所有贴纸都贴完后，整张大画纸最终是什么样子的？对于没有被任何贴纸覆盖的格子，我们用 $-1$ 来表示。

## 说明/提示

### 样例 1 解释

我们有一张 $4 \times 4$ 的画纸，一张 $4 \times 4$ 的图案纸，和 $2$ 张贴纸。
- **第一张贴纸**：重要性为 $7$，要覆盖画纸上 $(1,1)$ 到 $(2,2)$ 的区域，图案取自图案纸的 $(1,1)$ 开始的区域。
![](https://cdn.luogu.com.cn/upload/image_hosting/9ugy640c.png)

- **第二张贴纸**：重要性为 $9$，要覆盖画纸上 $(2,2)$ 到 $(3,3)$ 的区域，图案取自图案纸的 $(3,3)$ 开始的区域。
![](https://cdn.luogu.com.cn/upload/image_hosting/j6swmb5u.png)

最终，画纸上的 $(2,2)$ 格子被两张贴纸覆盖了。
- 第一张贴纸想把它变成颜色 $6$（重要性为 $7$）。
- 第二张想把它变成颜色 $11$（重要性为 $9$）。

因为 $7 < 9$，所以第二张贴纸更重要，会盖在上面。所以 $(2,2)$ 格子的最终颜色是 $11$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5p93nazo.png)

### 数据规模与约定
本题共 $10$ 个测试点。对于 $100\%$ 的数据：
* $1 \leq n, m, c \leq 500$。
* $1 \leq k \leq 100$。
* 对于每张贴纸，$1 \leq x_1 \leq x_2 \leq n$，$1 \leq y_1 \leq y_2 \leq m$，$1 \leq x_t, y_t \leq c$。
* 保证每张贴纸需要的图案部分，都不会超出图案纸的边界。
* $1 \leq p \leq 10^6$，图案纸中的颜色值范围为 $0 \sim 256$，各贴纸的重要性不同。

| 测试点编号 | $n, m$ | $c$ | $k$ |
| :-: | :-: | :-: | :-: |
| $1, 2$ | $= 1$ | $\leq 500$ | $\leq 100$ |
| $3, 4$ | $\leq 500$ | $= 1$ | $\leq 100$ |
| $5, 6$ | $\leq 500$ | $\leq 500$ | $= 1$ |
| $7 \sim 10$ | $\leq 500$ | $\leq 500$ | $\leq 100$ |

## 样例 #1

### 输入

```
4 4 4 2
1 1 2 2 7 1 1
2 2 3 3 9 3 3
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
```

### 输出

```
1 2 -1 -1
5 11 12 -1
-1 15 16 -1
-1 -1 -1 -1
```

# 题解

## 作者：Maxmilite (赞：2)

## Source & Knowledge

2025 年 6 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定一张 $n$ 行 $m$ 列的空白画纸，一张 $c$ 行 $c$ 列的图案纸，以及 $k$ 张透明贴纸。每张贴纸有其粘贴区域、取图的图案纸左上角坐标以及一个重要性 $p$ 值。贴纸会按顺序贴到画纸上。当多张贴纸覆盖同一个格子时，重要性数值更大的贴纸会覆盖在上面。最终输出画纸的颜色状态，未覆盖的格子用 $-1$ 表示。

## 题目分析

本题的核心是二维数组的覆盖与优先级处理。由于存在覆盖关系，并且优先级由重要性数值决定，我们使用以下策略：对于画纸上的每一个格子，我们遍历所有可能覆盖它的贴纸。在这些贴纸中，我们选择**重要性最高**的那一张来决定这个格子的最终颜色。

具体来说，对于画纸上的每一个格子 $(r, col)$：
1.  **初始化**：将其颜色设置为 `-1`，表示未被覆盖。同时，记录当前格子的“最高重要性”为一个足够小的值。
2.  **遍历贴纸**：遍历输入的 $k$ 张贴纸。
    * **判断覆盖**：检查当前贴纸是否覆盖了格子 $(r, col)$。这可以通过判断 $(r, col)$ 是否落在贴纸的矩形区域 $(x_1, y_1)$ 到 $(x_2, y_2)$ 内部来实现。即 $x_1 \le r \le x_2$ 且 $y_1 \le col \le y_2$。
    * **更新颜色**：如果当前贴纸覆盖了格子 $(r, col)$，并且它的重要性 $p$ **大于**当前格子记录的“最高重要性”：
        * 更新格子的颜色为当前贴纸在图案纸上对应的颜色。
        * 更新格子的“最高重要性”为当前贴纸的 $p$ 值。

我们可以使用一个 $n \times m$ 的二维数组 `f[MAXN][MAXM]` 来存储画纸的最终颜色，并将其所有元素初始化为 `-1`。然后，使用嵌套循环遍历画纸上的每一个格子 $(r, col)$：

```cpp
// 假设画纸大小为 n*m, 图案纸为 tex[MAXC][MAXC], 贴纸信息为 struct v[MAXK]，这些信息都已经读入。
// f[MAXN][MAXM] 存储最终结果

// 1. 初始化画纸为 -1
for (int r = 1; r <= n; ++r) {
    for (int col = 1; col <= m; ++col) {
        f[r][col] = -1;
    }
}

// 2. 遍历画纸上的每一个格子
for (int r = 1; r <= n; ++r) {
    for (int col = 1; col <= m; ++col) {
        int max_importance = 0; // 记录当前格子 (r, col) 遇到的最大重要性
        // 初始时，格子是 -1，重要性视为 0（任何贴纸都比它重要）
        
        // 3. 遍历所有贴纸
        for (int i = 1; i <= k; ++i) { // 遍历第 i 张贴纸
            // 获取当前贴纸的信息
            int x1 = v[i].x1;
            int y1 = v[i].y1;
            int x2 = v[i].x2;
            int y2 = v[i].y2;
            int p = v[i].p;
            int xt_start = v[i].xt;
            int yt_start = v[i].yt;

            // 4. 判断当前贴纸是否覆盖格子 (r, col)
            if (r >= x1 && r <= x2 && col >= y1 && col <= y2) {
                // 如果覆盖，且当前贴纸的重要性更高
                if (p > max_importance) {
                    // 更新当前格子的最高重要性
                    max_importance = p;
                    
                    // 计算当前格子 (r, col) 对应图案纸上的坐标
                    int rt = xt_start + (r - x1);
                    int colt = yt_start + (col - y1);
                    
                    // 更新画纸上此格子的颜色
                    f[r][col] = tex[rt][colt];
                }
            }
        }
    }
}
```

---


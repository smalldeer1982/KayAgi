# [NOIP 2002 提高组] 均分纸牌

## 题目描述

有 $N$ 堆纸牌，编号分别为 $1,2,\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。


## 说明/提示

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。

**【题目来源】**

NOIP 2002 提高组第一题

## 样例 #1

### 输入

```
4
9 8 17 6
```

### 输出

```
3
```

# 题解

## 作者：monell (赞：32)

# P1031 均分纸牌

下面给出线性算法(O(n))和分治算法(O(n^2))，其中分治算法的正确性显见，而线性算法的正确性可由分治算法得出

## 线性算法

* 关键点：当前堆数量可为负数

* 步骤

  从左到右遍历数组

  1. 若大于目标值，则将多余数量转移给下一元素，移动次数(最终结果)+1
  2. 若小于目标值，则从下一元素支取所差数量(透支不影响结果)，移动次数+1
  3. 若等于目标值，跳过

* 复杂度

  显然O(n)

## 分治算法

* 算法

  对于区间[lo,hi)

  1. 若区间内元素小于2个，返回0
  2. 找到区间内元素最大值
  3. 若最大值为目标值，返回0
  4. 遍历最大值左边元素，找到还差多少，记为left；遍历最大值右边元素，找到还差多少，记为right
  5. 将最大值元素值置为目标值，记当前移动次数total=0
  6. 若left不为0，则最大值元素的左边第一个元素值加上left.，total++；若right不为0，则最大值元素的右边第一个元素值加上right，total++
  7. 分别对最大值元素左边区间和右边区间递归执行该算法，total加上它们返回的值，作为当前区间执行算法的返回值

* 正确性

  该算法实际上就是实际寻找的过程，正确性显然

* 复杂度

  该算法与快排很类似，都为找到轴点(这里是最大值)，进行二分，因此可类似快排构造最坏情况

  因此算法复杂度为O(n^2)

  但平均性能应该也为O(log n)，类似快排，若每次最大值都在中间，则有递归式T(n) = 2T(n/2) + O(n)，因此主定理解得O(log n)

## 线性算法正确性证明

* 算法正确性证明

  考虑分治算法得到的一个最优解，证明线性算法得到的解与其等价(最少移动次数相同)　

  记初始数组为A

  每次移动都可以用一个三元组(u,v,w)来刻画，表示从A[u]取w转移到A[v]，满足|u-v|=1,w>0

  由此由分治算法得到的解应该是一个操作序列，其中集合元素为上述三元组，满足每一次的操作都是合法的(不会出现透支)，集合元素个数最少

  再将这个操作集合用图来建模，图的节点代表堆，(u,v,w)代表从u指向v的一条权重为w的有向边，称上述最优解对应的图为最优图

  下面证明(注意下面所说的最优操作序列都是由分治算法得到)

  1. 最优图不存在重边，即若最优操作序列中存在(u,v,w)，则不存在(u,v,w1)或者(v,u,w2)

     考虑分治算法的操作流程，每次迭代都找到一个最大值，并对最大值两边的区间(都不包含最大值)，进行相同处理，而每次迭代最多进行2次移动操作，即最大值分别向左右两边移动一定数值，而之后的迭代将不再与该最大值相关(因为后面的区间都不包含它)，所以不会出现重边

  2. 最优图的边去掉方向后，每个连通分量对应的子图都为一条欧拉路径

     由(u,v,w)满足|u-v|=1和不存在重边立即得到

     注意该图不一定连通，这对应着分治算法中最大值为目标值的情况，此时将不会存在移动，即该节点不会有边与其相连

  3. 改变最优图边的生成方式，即等价于线性算法

     对最优图进行改变，对于每条边(u,v,w)，若u<v，则不变;若u>v，则去掉该边，加上一条(v,u,-w)，权重为负数

     此时节点序号从小到大遍历，对于节点i和节点i+1，若不存在边(i,i+1,w)，则继续遍历下一节点;若存在，w>0则从当前节点i对应堆移动w到下一节点，w<0则节点i+1对应堆向节点i对应堆移动-w，w=0，则继续遍历下一节点

     经过上述操作，每个节点值都将成为目标值，满足要求，同时由其步骤，显然就是线性算法的运行步骤，而最优图是由分治算法得到的，因此由分治算法正确性即可得到线性算法的正确性

[欢迎关注我的github的算法练习~](https://github.com/monellz/algo)

---

## 作者：松风之狐 (赞：21)

# [均分纸牌](https://www.luogu.org/problemnew/show/P1031)

**所有堆均达到相等时的最少移动次数。**

一看到**最少**这个字眼，就应该想到**贪心**或者**动态规划**。

而我的思路是：

因为题目上说：

>  纸牌总数必为N的倍数
>
> 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

所以我就想：那么我用每堆的纸牌数去减掉平均数，不就是这堆纸牌需要多少张牌才满足题目条件吗？

又因为：

> 移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N*的堆上取的纸牌，只能移到编号为N-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

所以，**如果这堆的纸牌数>0，我们就需要将它的多余纸牌移动到纸牌数<0的纸牌堆上去。**

反之，**如果这堆的纸牌数<0，我们就需要将它的缺少的纸牌从纸牌数>0的纸牌堆上移动到它上去。**

于是，有了思路，代码打起来也就非常简单了。

# 代码实现：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n;//纸牌堆数
int a[10005];//储存纸牌数
int num=0;//纸牌的平均数
int ans=0;//移动次数
int flag=1;//表示纸牌不需要移动
int main()
{
	cin>>n;//输入纸牌堆数
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入每堆的纸牌数
		num+=a[i];//纸牌的总数进行累加
	}
	num/=n;//num变为总纸牌数的平均数
	for(int i=1;i<=n;i++) a[i]-=num;//将每堆纸牌数变为距离满足条件的纸牌数的数
	for(int i=1;i<=n;i++) if(a[i]!=0) flag=0;//flag==0，表明需要移动
	if(flag==0)//需要移动，那么就开始吧！
	{
		for(int i=1;i<=n;i++)//从头遍历到尾
		{
			if(a[i]>0)//如果它的纸牌数多了
			{
				a[i+1]+=a[i];//就把它移动到下一堆去
				a[i]=0;//这一堆满足条件
				ans++;//移动次数++
			}
			if(a[i]<0)//如果它的纸牌数少了
			{
				a[i+1]-=abs(a[i]);//那么它下一堆的纸牌就移动到它上来
				a[i]=0;//这一堆满足条件
				ans++;//移动次数++
			}
			if(a[i]==0) continue;//如果它满足条件，就不鸟它了。
		}
		cout<<ans<<endl;//输出答案
	}
	if(flag==1) cout<<ans<<endl;//如果本来就满足条件，直接输出答案（0）
	return 0;
}
```



---

## 作者：ProtectEMmm (赞：7)

# [Luogu P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

## 题意

给定 $n$ 堆纸牌，第 $i$ 堆纸牌有 $a_i$ 张，保证 $\sum\limits_{i=1}^{n}{a_i}$ 是 $n$ 的倍数。

可以进行一种操作：选取相邻的两堆，从某一堆中拿任意张牌给另一堆，算一次操作。

求最小的操作次数，使得 $n$ 堆牌中牌的数量都一样。

## 题解

大部分题解只讲了如何贪心，并没有讲贪心的正确性证明。导致我在做这题时，包括很多选手做这题时产生了很多疑惑。今日特此补上。

首先先要提出一点，这题不允许牌堆是负数。所以题解里基于贪心的贷款思路从题意上来说，是错误的。但是我们可以证明最后这么做不影响正确性。

首先很容易看出来，最后要求所有牌堆的牌数都等于平均数。

**引理：** 任意两堆相邻的牌堆，最优策略只能从一堆往另一堆一次性给出若干张牌。不存在 $A$ 给了 $B$，之后 $B$ 又给了 $A$。

>我们可以用分治的思想证明这个引理。
>
>首先任取两堆相邻的牌，不妨设左边所有牌堆的总和为 $A$，右边所有牌堆的总和为 $B$。
>
>因为我们要求每堆牌最后都相等，所以可以让两边都减去每堆牌至少需要的牌数。
>
>现在有三种情况。
>
>1. $A=B=0$：说明两堆之间不需要进行牌的交换。
>2. $A>0>B$：说明 A 有余，B 不足。
>3. $A<0<B$：说明 A 不足，B 有余。
>
>不妨设 A 有余，B 不足。反之同理。
>
>那么肯定是 A 一次性把这么多牌给 B。
>
>这里 `小粉兔` 提出了一个疑问：凭什么一定是 A 一次性把这么多牌给 B。（玄学一点：天之道，损有余而补不足）
>
>这里我并不能证明一定是 A 一次性给 B。`小粉兔` 紧跟着提问：为什么不能 B 给 A，然后再给 B。（先富带动后富）
>
>这个提问给了我一点提示，（有一个比较玄学的回答是奥卡姆剃刀原理，这么多步骤肯定不合理），这里证明方法是，因为我们存在操作步骤次数为 $1$ 的方案，所以其余方案都不优。从最优方案的存在性上下手。
>
>现在我们证明了 A 和 B 之间一定是有余给不足，至于左侧牌堆内部，和右侧牌堆内部怎么处理，继续递归下去（或者用数学归纳法证明）。

如果我们考虑，有余往不足的牌堆连边。我们会发现问题变成了一张 $n$ 点，至多 $n-1$ 条边的有向图。（为什么是至多，因为有可能两边互相都不需要给牌）

如果这张有向图是一张 DAG，即这张有向图无环。我们就可以按照拓扑序来进行给牌操作。这样就不会出现中间是负数的情况了。

现在如何证明这张有向图无环呢？一个非常不严谨的证明是， $n$ 点，至多 $n-1$ 条边的有向图是一棵树，不可能有环。

问题是，如果有一些点本身就等于平均值，不需要连边。那就释放出来了本该连给他，现在多余的边，这些多余的边到其他地方会不会形成环呢？

如果我们释放了一些点，那么这些点就可以从 $n$ 个点里忽略掉。所以最后还是 $n'$ 点，$n'-1$ 边。

另一个解释是，这张图只能是一条链，因为不存在双向边所以绝不可能有环。

事实上，这张图最后形态是有若干条链。答案就是点数减去链数，因为不同链之间不需要进行交换，所以减掉。因为链是树的一种，可以看成是一个森林。那点数减链数其实就是边数。边数本质就是操作的次数。

我们发现我们最后只关心边的数量，不关心边的方向了。所以这题用贪心的思路做后，可以存在负数，可以贷款，这不影响这题的正确性。

> 这题如果没考虑这么多，只考虑贪心做的话。
>
> 第一堆牌和第二堆牌就三种可能：
>
> 1. 第一堆牌刚好：不需要处理。
> 2. 第一堆牌有余：只能给第二堆牌。
> 3. 第一堆牌不足：只能第二堆牌给。
>
> 于是我们就处理完了第一堆牌。也就是第一块多米诺骨牌已经推倒了。
>
> 对于第二堆牌来说，第一堆牌已经处理完了，不需要再考虑了，于是第二堆牌不能向左再操作了，只能向右。第二堆牌变成了第一堆牌。
>
> 于是就像多米诺骨牌一样，全部倒下去（也就是数学归纳法）。

补充：这题有一个环形版本， [`负载平衡问题`](https://www.luogu.com.cn/problem/P4016)，是 `网络流24题` 中的一道费用流题目。但是也可以像这题一样做。我们只需要证明这题一定能找到一个断点使他变成 [`均分纸牌`](https://www.luogu.com.cn/problem/P1031) 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*====================*/
#define endl "\n"
/*====================*/
typedef long long lnt;
/*====================*/
const int N = 1e2 + 10;
/*====================*/
int n, arr[N];
/*====================*/
void Solve(void)
{
	cin >> n;
	int average = 0;
	for (int i = 1; i <= n; ++i)
	{
		cin >> arr[i];
		average += arr[i];
	}
	average /= n;
	/*====================*/
	int ans = 0;
	for (int i = 1; i + 1 <= n; ++i)
	{
		if (arr[i] != average)
		{
			ans++, arr[i + 1] += arr[i] - average;
		}
	}
	cout << ans << endl;
	/*====================*/
	//第二份代码的思路就是，统计分治证明里提到的 A == B的断边。
	int ans = n, sum = 0;
	for (int i = 1; i <= n; ++i)
	{
		sum += arr[i] - average;
		if (sum == 0)ans--;
	}
	cout << ans << endl;
}
/*====================*/
int main()
{
#ifndef ONLINE_JUDGE
	freopen("IN.txt", "r+", stdin);
#endif
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	int T = 1; //cin >> T;
	while (T--)Solve();
	return 0;
}
```

## 致谢

感谢 `Cherishdevil` 在菜群提出了这个问题，使得我能够再次注意到这道题。

感谢 `SkyWave` 提出我可以针对这道题重新写一篇题解试试能不能让管理挂上。

感谢 `小粉兔` 在群内和我讨论，把我思路中的错误给指出，并不断给出新提示。

---

## 作者：Starlight237 (赞：3)

原题如下：
有 $N$ 堆纸牌，编号分别为 $1,2,…,N$ 。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 NN 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ ， $4$ 堆纸牌数分别为：

①$9$ ②$8$ ③$17$ ④$6$

移动 3 次可达到目的：

从 ③ 取 $4$ 张牌放到 ④ （$9,8,13,10$）-> 从 ③ 取 $3$ 张牌放到 ②（$9,11,10,10$）-> 从 ② 取 $1$ 张牌放到①（ $10,10,10,10$）。

此题的思路还是很好想的：想要使没堆牌的牌数都等于平均值，必须要依次遍历牌堆，查找不等于平均值的牌堆，并且修改。我们从0号开始，一堆堆往后遍历，如果发现纸牌数不等于平均值，就从后面一堆“借来”或“借出”一些纸牌，并且继续查找，遇到符合条件的牌堆就跳过，直到最后一堆牌。

考虑到不管当前牌是否大于或小于平均值，下一张牌都会增加当前牌数-平均数（如果小于平均值，则该值为负数，相当于从下一堆借来纸牌），所以不需要多余的条件判断。由于当前牌堆的修改与上一堆无关，所以可以除去将当前牌数修改为平均数这个不必要的操作，以加快运行速度。

代码奉上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110],n,s,avg,m;
inline void work(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=0;i<n;++i)cin>>a[i],s+=a[i];
	avg=s/n;
	for(int i=0;i<n-1;++i)
		if(a[i]!=avg)a[i+1]+=a[i]-avg,++m;
	cout<<m;
}
int main(){
	work();
	return 0;
}

```

---


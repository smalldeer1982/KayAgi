# [NOIP 2009 普及组] 多项式输出

## 题目描述

一元 $n$ 次多项式可用如下的表达式表示：

$$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots +a_1x+a_0,a_n\ne 0$$

其中，$a_ix^i$ 称为 $i$ 次项，$a_i$ 称为 $i$ 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：

1. 多项式中自变量为 $x$，从左到右按照次数递减顺序给出多项式。

2. 多项式中只包含系数不为 $0$ 的项。

3. 如果多项式 $n$ 次项系数为正，则多项式开头不出 `+` 号，如果多项式 $n$ 次项系数为负，则多项式以 `-` 号开头。

4. 对于不是最高次的项，以 `+` 号或者 `-` 号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于 $0$ 次的项，其系数的绝对值为 $1$，则无需输出 $1$）。如果 $x$ 的指数大于 $1$，则接下来紧跟的指数部分的形式为“$x^b$”，其中 $b$ 为 $x$ 的指数；如果 $x$ 的指数为 $1$，则接下来紧跟的指数部分形式为 $x$；如果 $x$ 的指数为 $0$，则仅需输出系数即可。

5. 多项式中，多项式的开头、结尾不含多余的空格。


## 说明/提示

NOIP 2009 普及组 第一题

对于100%数据，$0 \le n \le 100$，$-100 \le $系数$ \le 100$

---

$\text{upd 2022.8.1}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5 
100 -1 1 -3 0 10```

### 输出

```
100x^5-x^4+x^3-3x^2+10```

## 样例 #2

### 输入

```
3 
-50 0 0 1 
```

### 输出

```
-50x^3+1 
```

# 题解

## 作者：Loyal_Soldier (赞：10)

### 思路

这一题我们要分情况讨论。

情况分为以下几种：

- 当前 $i\not= n$ 并且输入的数是正数，输出 `+`。
- 当前 $i\not= 0$ 并且输入的数是 $-1$，输出 `-`。
- 输入的数的绝对值大于 $1$ 或者当前 $i=0$，输出输入的数。
- 当前 $i>1$，输出 `x^` 和 $i$。
- 当前 $i=1$，输出 `x`。

注意，以上情况当且仅当输入的数不为 $0$ 时才成立。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n;
	cin>>n;
	for(int i=n;i>=0;i--){//注意，循环要从大到小
		int x;
		cin>>x;
		if(x){
			if(i!=n&&x>0)
				cout<<'+';
			if(i!=0&&x==-1)
				cout<<'-';
			if(abs(x)>1||i==0)
				cout<<x;
			if(i>1)
				cout<<"x^"<<i;
			if(i==1)
				cout<<'x';
		}
	}
	return 0;
}
```

---

## 作者：邪王真眼Rikka (赞：7)

分三阶段判断

第一阶段判断是否要输出符号：第一位且为负数 其余位且为负数输出- 正号同理

第二阶段判断是否要输出系数 注意abs的使用 洛谷一用abs就会出错 条件是除常数项的非+-1 和常数项

第三阶段判断是否要输出幂

分清楚输出阶段可以缩短代码

```cpp
#include<stdio.h>
int abs(int x)
{
    if(x>0)return x;
    return -x;
}
int main()
{
    int a[101];
    int n,flag,i;
    scanf("%d",&n);
    for(i=n; i>=0; i--)
        scanf("%d",&a[i]);
    if(n==0)
    {
        printf("%d",a[0]);
        return 0;
    }
    flag=1;
    for(i=n; i>=0; i--)
    {
        if(a[i]==0)continue;//已判定此时系数不为0
        if((flag==1&&a[i]<0)||(a[i]<0))
        {
            printf("-");
        }
        else if(flag==0&&a[i]>0) printf("+"); //正负号判定
        if(a[i]!=0&&flag==1)flag=0;
        if(abs(a[i])!=1||i==0)printf("%d",abs(a[i]));//系数判定
        if(i>1)printf("x^%d",i);
        if(i==1)printf("x");
    }
    return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

小模拟。

对于每项，依次输出符号，系数，自变量 $x$，次数。

对于符号，除了第一项是正数外不输出符号，其余都输出。

对于系数，只要不为 $0$ 就输出，需要特判 $1$ 和 $-1$ 的情况。

对于自变量 $x$，当系数和次数都不为 $0$ 时输出。

对于次数，当次数大于 $1$ 时输出。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n, a; cin >> n;
	for(int i=n; i>=0; i--){
		cin >> a;
		if(a){
			if(i<n&&a>0) cout << '+';
			if(abs(a)>1||i==0) cout << a;
			if(a==-1&&i) cout << '-';
			if(i>0) cout << 'x';
			if(i>1) cout << '^' << i;
		}
	}
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
把一个多项式拆成多个单项式分别处理。对于每个系数不为 $0$ 的单项式，按照输出顺序处理。  


第一步处理符号，如果是负数就输出负号；如果是正数并且不是第一项就输出正号。  
第二步处理系数，如果系数的绝对值不为 $1$ 就输出系数的绝对值。如果系数绝对值为 $1$ 但是次数为 $0$，依然要输出系数。  
第三步处理次数，如果次数为 $0$ 那么就不输出；否则输出 `x`。如果次数为 $1$ 就省略几次方；否则要输出是几次方。  

时间复杂度为 $O(n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n; scanf("%d",&n);
	for(int i=n;i>=0;i--){
		int a; scanf("%d",&a);
		if(!a)continue;//系数为0直接跳过
		if(a>0&&i!=n)putchar('+');//第一步
		if(a<0)putchar('-');
		
		if(abs(a)!=1||!i)printf("%d",abs(a));//第二步
		
		if(i){//第三步
			putchar('x');
			if(i!=1)printf("^%d",i);
		}
	}
	return 0;
}
```

---

## 作者：ljh0727 (赞：3)

# P1067多项式输出

题目传送门：[题目](https://www.luogu.com.cn/problem/P1067)

### 题意

给定一个 $n$，和 $n$ 个数。

这 $n$ 个数分别是这个多项式的系数。

要求转化为多项式输出。

### 思路

我们首先用一个数组来存储多项式的系数。

设 $a_i$ 来表示第 $i$ 次项的系数。

首先我们先来处理如果系数为 $0$。

当系数为 $0$ 时，这一项就不存在了。

所以我们可以用一个特判来处理。


```cpp
if(a[i]==0){
	continue;
}
```

这样每一项是否存在就解决了。

其次我们再来处理是否需要加符号。

如果是第一项的话，就只需要加负号，否则其他项不管正负都要加符号。


```cpp
if(i!=n&&a[i]>0)
	printf("+");
else if(i!=n||a[i]<0)
	printf("-");
```

这样也可以很好的解决。

符号都解决了，该处理一下每一项了。

先解决容易的，先处理常数项。

常数项很简单，只有系数，如果常数项是 $0$ 就不输出。

所以直接输出就好了。

现在来处理带指数的项。

因为一次项不需要输出指数，所以得把一次项和其他项分开处理。

因为我们前面判断过正负数，所以只需要判断系数是否为 $1$ 就行了。

```cpp
if(i==1){
	if(abs(a[i])!=1)
		printf("%dx",abs(a[i]));
	else 
		printf("x");
	continue;
}
```

那么其他项也同理。

```cpp
if(abs(a[i])==1&&i){
	printf("x^%d",i);
	continue;
}
if(i>=2){
	printf("%dx^%d",abs(a[i]),i);
}
```

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int a[105];

int main(){
	
	int n;
	scanf("%d",&n);
	for(int i=n;i>=0;i--){
		scanf("%d",&a[i]);
	}
	
	for(int i=n;i>=0;i--){
		if(a[i]==0){//项数是否存在 
			continue;
		}
		
		if(i!=n&&a[i]>0)//是否需要加符号 
			printf("+");
		else if(i!=n||a[i]<0){
			printf("-");
		}
		
		if(i==1){//特判一次项 
			if(abs(a[i])!=1)
				printf("%dx",abs(a[i]));
			else 
				printf("x");
			continue;
		}
		
		if(abs(a[i])==1&&i){//处理除常数项和一次项以外且系数为 1 的项 
			printf("x^%d",i);
			continue;
		}
		
		if(i>=2){//如果次数大于 2 就就直接输出 
			printf("%dx^%d",abs(a[i]),i);
		}else{//次数即没大于等于 2 又不是一次项，就输出常数项 
			printf("%d",abs(a[i]));
		}
		
	}
	return 0;
}
```

---

## 作者：sueyunsheng (赞：2)

本题目坑还是比较多的，但是细心慢慢做还是可以做出来的，不需要太多的技巧。可能存在问题：

1.系数为-1,1的时候应当输出的是-x或者x;

2.指数为1的时候应当输出x而不是x^1;

3.输出多余符号，比如数据“0 0 0 0 4 0”，正确输出是4x，而自己的代码输出是+4x。

针对这种情况，我想到的是建立两个数组，一个数组存储不为0的系数，一个数组存储对应的指数，然后先判断系数情况后输出，再判断指数情况输出。这个方法可能比较笨，但是它比较直观，能按照正常的逻辑思维一步一步走下去。

以下是代码部分：

```cpp
#include<bits/stdc++.h>
#define Nmax 200
using namespace std;
int zhishu[Nmax];
int xishu[Nmax];
int main()
{
	int n;
	cin>>n;
	int j=0;
	for(int i=0;i<n+1;++i)
	{
		int x;
		cin>>x;
		if(x!=0)
		{
			zhishu[j]=n-i;
			xishu[j]=x;
			j++;
		}
	}
	for(int i=0;i<j;++i)
	{
		if(zhishu[i]!=0)
		{
			if(i==0)
			{
				if(abs(xishu[i])!=1)
			        cout<<xishu[i]<<"x";
			    else 
			    {
			    	if(xishu[i]==1)
			    	    cout<<"x";
				    else if(xishu[i]==-1)
				        cout<<"-x";
				}			        
				if(zhishu[i]!=1)
				    cout<<"^"<<zhishu[i];				
			}
		    else
		    {
			    if(xishu[i]<0)
			    {
			    	if(xishu[i]!=-1)
				        cout<<xishu[i]<<"x";
					else
					    cout<<"-x";			    	
				}
			    else
			    {
			    	if(xishu[i]!=1)
				        cout<<"+"<<xishu[i]<<"x";
					else
					    cout<<"+x";			    	
				}
                
                if(zhishu[i]!=1)
				    cout<<"^"<<zhishu[i];
		    }
		}
		else if(zhishu[i]==0) 
		{
			if(xishu[i] < 0)
			    cout << xishu[i];
			else
			{
				if(i == 0)
			        cout << xishu[i];
				else
				    cout << "+" << xishu[i];			
			}

		}	
	}
	return 0;
 } 
```


---

## 作者：wangshengchen (赞：1)

## 思路

1. 输入 $m$，将 $m$ 存储到 $m2$。
2. 输入 $m + 1$ 行，存储到 $n$。
3. 如果 $n$ 不为 $0$ 执行以下程序。
4. 不是第一个且是正整数，输出 `+`。
5. $n$ 的绝对值大于 $1$ 或是最后一次，输出 $n$。
6. $n$ 是 $-1$ 且不是最后一次，输出 `-`。
7. $m$ 大于 $1$，输出 `x^` 和 $m$。
8.  $m$ 是最后一次输出 `x`。

#### Code

```cpp
#include<iostream>
#define Over exit(0);return 1
#define FAST_Ultimate ios::sync_with_stdio(0),ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
int main(){
	FAST_Ultimate;//加快cin速度
	
	int n,m,m2;
	cin>>m;
	m2=m;
	m++;//因为共m+1次输入
	while(m--){
		cin>>n;
		if(n){//如果n不为0
			if(m!=m2&&n>0) cout<<'+';//不是第一个且是正整数，输出+
			if(abs(n)>1) cout<<n;//n的绝对值大于1或是最后一次，输出n
			if(n==-1) cout<<'-';//n是-1且不是最后一次，输出-
			if(m>1) cout<<"x^"<<m;//m大于1，输出x^和m
			if(m==1) cout<<'x';//m是最后一次输出x
		}
	}
	
	Over;
}
```

---

## 作者：Ekin123 (赞：0)

~~恶心人的~~模拟。

先输入 $n+1$ 个数，表示项数。如果你直接输入，要使用 `reverse()` 方法反转数组；当然也可以反向输入。

考虑符号的输出，显然应将符号与其后面的数一并处理，因为最后面没有符号。

考虑首位（数组第 $n$ 项），若首位为负，则先输出 `-`。对首位取绝对值。

然后从 $n$ 到 $0$ 逆向循环，进行一系列特判。

- 若 $a_i=0$，代表该项不存在，直接跳过。
- 若 $i=0$：
  - 若 $n=0$（题目规定 $\color{red}0 \color{black} \le n \le 100$），则单独输出一个数 $a_0$。
  - 否则，带符号输出。
- 若 $i=1$：
  - 若 $a_i=\pm 1$，输出 `+x`/`-x`。
  - 否则，带符号输出 $a_1$，后接 `x`（因为幂次为 $1$，直接省略）。
- 若 $i=n$：
  - 若 $a_i=1$，输出 `x^n`（`n` 为输入的 $n$）。
  - 否则，**直接**输出 $a_n$，后接 `x^n`（`n` 为输入的 $n$）。
- 否则：（下文 $i \in [2,n-1]$）
  - 若 $a_i=\pm 1$，输出 `+x^i`/`-x^i`。
  - 否则，带符号输出 $a_1$，后接 `x^i`。

Talk is cheap,show me the CODE.

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int a[105];

void print(int x)
{
	if(x >= 0) cout << "+" << x;
	else cout << x;
}

int main()
{
	int n;
	cin >> n;
	for(int i = 0;i <= n;i++)
	{
		cin >> a[i];
	}
	reverse(a,a + n + 1); // Part 1
	if(a[n] < 0) cout << "-";
	a[n] = abs(a[n]); // Part 2
	for(int i = n;i >= 0;i--) // Part 3
	{
		if(a[i] == 0) continue; // 3.1
		if(i == 0) // 3.2
		{
			if(n == 0)
			{
				cout << a[i];
				continue;
			}
			print(a[i]);
			continue;
		}
		if(i == 1) // 3.3
		{
			if(a[i] == 1)
			{
				cout << "+x";
				continue;
			}
			if(a[i] == -1)
			{
				cout << "-x";
				continue;
			}
			print(a[i]);
			cout << "x";
			continue;
		}
		if(i == n) // 3.4
		{
			if(a[i] == 1)
			{
				cout << "x^" << n;
				continue;
			}
			if(a[i] == -1)
			{
				cout << "-x^" << n;
				continue;
			}
			cout << a[i] << "x^" << n;
			continue;
		}
		// 3.5
		if(a[i] == 1)
		{
			cout << "+x^" << i;
			continue;
		}
		if(a[i] == -1)
		{
			cout << "-x^" << i;
			continue;
		}
		print(a[i]);
		cout << "x^" << i;
	}
	return 0;
} 
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

简单~~坑人~~模拟题，根据题意模拟即可，不过需要注意以下点：

1. 当这一项的系数为 $\pm 1$ 时，注意符号的输出，**尤其是当这一项在多项式的开头和结尾时**。
2. 注意这一项的次数为 $0$ 的情况。

### 实现

```cpp
# include <iostream>
using namespace std;
int main(){
	bool out = false; // 记录是否为该多项式的第一项
	int n; cin >> n;
	for (int i = n;i >= 0;i--){
		int a; cin >> a;
		if (a == 0) continue;
		if (a == 1){
			if (out) cout << "+";
			if (i == 0) cout << 1;
		}else if (a == -1){
			cout << "-";
			if (i == 0) cout << 1;
		}else{
			if (a > 0 && out) cout << "+";
			cout << a;
		}if (i == 1){
			cout << "x";
		}else if (i != 0) cout << "x^" << i;
		out = true;
	}return 0;
}
```

---

## 作者：mishitaotuoyyds (赞：0)

## 思路：
[题目传送门](https://www.luogu.com.cn/problem/P1067)。

首先按照题目说的方法打，这很容易，但这题有坑。

1. 如果系数为 $0$ 不输出。
2. 如果后一个系数为负数不输出加号。
3. 如果次数为 $1$ 不输出次数。
4. 如果次数为 $0$ 只输出次数。

## 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,aa[1000];
int main() {
	cin>>n;
	m=n;
	for(int i=1;i<=n+1;i++){
		cin>>aa[i];
	}
	for(int i=1;i<=n+1;i++){
		if(m==0&&aa[i]!=0){
			if(aa[i+1]>0)cout<<"+";
			cout<<aa[i];
			break;
		}
		if(aa[i]==0){
			if(aa[i+1]>0)cout<<"+";
			m--;
		}
		else{
			if(aa[i]==1){
				cout<<"x";if(m!=1&&m!=0)cout<<"^"<<m;
				m--;
				if(aa[i+1]>0)cout<<"+";
			}
			else{
				if(aa[i]==-1){
					cout<<"-x";if(m!=1&&m!=0)cout<<"^"<<m;
					m--;
					if(aa[i+1]>0)cout<<"+";
				}
				else{
					cout<<aa[i]<<"x";if(m!=1&&m!=0)cout<<"^"<<m;
					m--;
					if(aa[i+1]>0)cout<<"+";
				}
			}
		}
	}
	return 0;
}
//-1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100 1 8

```

---

## 作者：Jerry_zpl (赞：0)

本题算法：模拟。  
难度建议：橙。  
思路如下：
- 首先，我们要知道，本题输出的式子一定不包含 $0$，所以如果 $a=0$ 咱们直接跳过即可。
- 然后我们就要考虑边界情况。如果我们输入到最后一个数 $a$，那么就要考虑以下几种情况。如果 $a$ 是正整数，那么需要输出符号，就先输出符号再输出 $a$，否则就是负数，负数本身就带有符号，直接输出并跳过就行了。
- 最后我们就可以先处理符号，再处理数，这样就能过了。

```
#include<bits/stdc++.h>
using namespace std;
int n,a,flag;
//这里的flag是用来标记是否需要输出符号的
int main()
{
    cin>>n;
    flag=-1;
    for(int i=n;i>=0;i--)
    {
        cin>>a;
        if(a!=0 && flag==-1) //如果是第一个数就需要将flag标记为i
        {
            flag=i;
        }
        if(a==0)
        {
            continue;
        }
        if(i==0)//特殊情况
        {
            if(a>0)
            {
                if(i!=flag)
                {
                    cout<<"+";
                }
                cout<<a;
            }
            else
            {
                cout<<a;
            }
            continue;
        }
        if(a>0)
        {
            if(i!=flag)
            {
                cout<<"+";
            }
            if(a!=1)
            {
                cout<<a;
            }
            if(i!=1)
            {
                cout<<"x^"<<i;
            }
            else
            {
                cout<<"x";
            }
        }
        else
        {
            if(a!=-1)
            {
                cout<<a;
            }
            else
            {
                cout<<"-";
            }
            if(i!=1)
            {
                cout<<"x^"<<i;
            }
            else
            {
                cout<<"x";
            }
        }
    }
    return 0;
}
```

---

## 作者：Eason_lyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P1067) 很好理解，这里不再多说。
### 题目分析
这道题纯模拟，但要注意一下几个细节：
- 多项式开头不出 `+` 号，但能输出 `-` 号。
- 如果一个高于 0 次的项，其系数的绝对值为 1，则无需输出 1。
- 如果 $x$ 的指数为 1，则接下来紧跟的指数部分形式为 $x$。
- 如果 $x$ 的指数为 0，则仅需输出系数即可。
- 从高次项往低次项输入。
- 如果你 Subtask #1 没过，请检查关于 1 的特判。
  输入是 `0 1`。

接下来所有细节均注释在了代码中。

### 代码
#### 注释版

```cpp
#include<bits/stdc++.h>
int n,cur;
int main(){
    scanf("%d",&n);//输入次数
    for(int i=n;i>=0;i--){//从高次项往低次项输入
        scanf("%d",&cur);//输入系数
        if(cur==0) continue;//系数为0，无需判断
        else if(cur==(-1))//特判-1
            if(i==1) printf("-x");
            else if(i!=0) printf("-x^%d",i);
            else printf("-1");
        else if(cur<0)//负数情况
            if(i==1) printf("%dx",cur);
            else if(i!=0) printf("%dx^%d",cur,i);//cur自带负号
            else printf("%d",cur);
        else if(cur==1)//特判1
            if(i==1) printf("+x");
            else if(i==n&&i!=0) printf("x^%d",i);
            else if(i==n) printf("1");
            else if(i!=0) printf("+x^%d",i);
            else printf("+1");
        else //其他（正数）
            if(i==1) printf("+%dx",cur);
            else if(i==n) printf("%dx^%d",cur,i);
            else if(i!=0) printf("+%dx^%d",cur,i);
            else printf("+%d",cur);
    }
    return 0;
}
```

#### 无注释版
```cpp
#include<bits/stdc++.h>
int n,cur;
int main(){
    scanf("%d",&n);
    for(int i=n;i>=0;i--){
        scanf("%d",&cur);
        if(cur==0) continue;
        else if(cur==(-1))
            if(i==1) printf("-x");
            else if(i!=0) printf("-x^%d",i);
            else printf("-1");
        else if(cur<0)
            if(i==1) printf("%dx",cur);
            else if(i!=0) printf("%dx^%d",cur,i);
            else printf("%d",cur);
        else if(cur==1)
            if(i==1) printf("+x");
            else if(i==n&&i!=0) printf("x^%d",i);
            else if(i==n) printf("1");
            else if(i!=0) printf("+x^%d",i);
            else printf("+1");
        else 
            if(i==1) printf("+%dx",cur);
            else if(i==n) printf("%dx^%d",cur,i);
            else if(i!=0) printf("+%dx^%d",cur,i);
            else printf("+%d",cur);
    }
    return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/199071225)。

---

## 作者：dgz61 (赞：0)

# 思路
按着题目把多项式打出来即可，但要注意以下几点： 
1.  开头系数为正数的情况。
2.  当系数为 0 注意跳过。
3.  当指数为 1 的情况。
4.  指数为 0 的情况。
5.  n 等于 0 的情况。
6.  末尾处理。
### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[100+10];
int main(){
	cin>>n;
	for(ll i=1;i<=n+1;i++) cin>>a[i];
	for(ll i=n;i>=0;i--){
		if(a[n-i+1]==0) continue;//系数为0的情况
		else if(i==1 && n!=1){//指数为1且不为开头的情况
			if(abs(a[n-i+1])==1){
				if(a[n-i+1]>0) cout<<"+x";
				else cout<<"-x";
			}//特判绝对值系数为1的情况
			else{
				if(a[n-i+1]>0) cout<<'+'<<a[n-i+1]<<'x';
				else cout<<a[n-i+1]<<"x";
			}
		}
		else if(i==1){//指数为1且为开头的情况
			if(abs(a[n-i+1])==1){
				if(a[n-i+1]>0) cout<<'x';
				else cout<<"-x";
			}//特判绝对值系数为1的情况
			else{
				if(a[n-i+1]>0) cout<<'+'<<a[n-i+1]<<'x';
				else cout<<a[n-i+1]<<'x';
			}
		}
		else{
			if(i==n && i!=0){ //开头且n!=0的情况
				if(abs(a[n-i+1])==1){
					if(a[n-i+1]>0) cout<<"x^"<<i;
					else cout<<"-x^"<<i;
				}//特判绝对值系数为1的情况
				else{
					if(a[n-i+1]>0) cout<<a[n-i+1]<<"x^"<<i;
					else cout<<a[n-i+1]<<"x^"<<i;
				}
			}
			else{
				if(i==0){//末尾输出
					if(a[n-i+1]<0) cout<<a[n-i+1];
					else if(n==0) cout<<a[n-i+1];//特判n==0的情况
					else cout<<'+'<<a[n-i+1];
				}
				else{//正常输出
					if(abs(a[n-i+1])==1){
						if(a[n-i+1]>0) cout<<"+x^"<<i;
						else cout<<"-x^"<<i;
					}
					else{
						if(a[n-i+1]>0) cout<<'+'<<a[n-i+1]<<"x^"<<i;
						else cout<<a[n-i+1]<<"x^"<<i;
					}
				}
			}
		}
	}
	return 0;
}
```
希望大家喜欢这一篇题解。

---


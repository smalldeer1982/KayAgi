# [SNCPC2024] 窗花

## 题目描述

有一扇 $100 \text{cm} \times 100 \text{cm}$ 的窗户和 $n$ 个对角线长为 $2 \text{cm}$ 的正方形窗花。建立坐标系，以窗户左下角的坐标为原点 $(0,0)$，右上角坐标为 $(100,100)$，第 $i$ 个窗花中心被贴在非边缘的整坐标点 $(x_i,y_i)$ ($1 \leq x_i,y_i \leq 99$) 上，窗花的对角线与坐标轴平行。

问窗户有多大的面积被至少一片窗花覆盖。

## 说明/提示



对于第一个样例的解释如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wzkohjei.png)

## 样例 #1

### 输入

```
5
1 1
2 1
3 2
5 5
5 5
```

### 输出

```
7.5
```

# 题解

## 作者：zhengpie (赞：5)

### 1.思路

考虑使用一个变量 $ans$ 维护被覆盖的面积。（注意要开成 ```double``` 类型）

一张窗花的中心在 $(x,y)$，此时再贴一张窗花，窗花的中心在 $(a,b)$，那么有一下三种情况：（后面统一省略单位）

- $x=a,y=b$，即这两张窗花重合（样例中的第四张与第五张），那么 $ans$ 不变。

- $a = x \pm 1,b=y$ 或 $b = y \pm 1,a=x$，那么他们会重叠 $(2\div2)\times(2\div2)\div2=0.5$ 的面积，而一张窗花可以覆盖 $2\times2\div2=2$ 的面积，故一共会新覆盖 $1.5$ 的面积，$ans \gets ans + 1.5$。（这种情况是样例中的第一张和第二张）

- 如果以上两种都不符合，那么就会新覆盖 $2$ 的面积，$ans \gets ans+2$。

### 2.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mp[114][514];
double cnt;
signed main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	while(n--)
	{
		int x,y;
		cin>>x>>y;
		if(mp[x][y]) continue;
		cnt += 2.0000000000000000;
		mp[x][y]++;
		cnt -= 0.500000000 * (double)(mp[x - 1][y] + mp[x + 1][y] + mp[x][y - 1] + mp[x][y + 1]);
	}
	cout<<cnt;
	
	return 0;
	
}
```

---

## 作者：fangminding (赞：2)

#### 题意
首先需要读懂题意，正方形窗花对角线长度为 $2$，对角线与坐标轴平行，正方形的对角线交点在整点上（即横、纵坐标均为整数的点）。
#### 主要方法
首先我们应当对这篇区域分区，是的每一区域要么都被覆盖，要么都不被覆盖。

对于由 $(x,y)$，$(x,y+1)$，$(x+1,y+1)$，$(x+1,y)$ 这四个点组成的正方形（称之为单位正方形）可以进行如下划分：

![区域划分示意图](https://cdn.luogu.com.cn/upload/image_hosting/kq832vjx.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

依图分区处理即可。
在我的代码中，我用了一个数组 ```used[100][100][5]``` 来存储每一小区域的状况，第一、二维表示单位正方形左下角的坐标，第三维表示在单位正方形中的区域编号。
#### 代码
完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
int used[100][100][5],n,t1,t2;

signed main()
{
	cin>>n;
	for(int i = 1;i <=n;i++)
	{
		cin>>t1>>t2;
		used[t1][t2][3]=1;
		used[t1][t2][4]=1;
		used[t1-1][t2-1][1]=1;
		used[t1-1][t2-1][2]=1;
		used[t1][t2-1][1]=1;
		used[t1][t2-1][4]=1;
		used[t1-1][t2][2]=1;
		used[t1-1][t2][3]=1;
	}
	int ans=0;
	for(int i = 0;i <100;i++)
		for(int j = 0;j <100;j++)
			for(int k = 1;k <=4;k++)
				ans+=used[i][j][k];
	cout<<ans/4.0;
	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：2)

题意：

有 $n$ 个正方形窗花，每个窗花对角线为 $2$ 厘米，每个窗花的中心点要贴到在 $(x_i,y_i)$ 的地方，求窗花覆盖的面积。

思路：

每个正方形的窗花的对角线是 $2$ 厘米，根据正方形的计算公式（对角线乘以对角线除以二），算出正方形面积为 $2$。如果任意两个窗花都没有重叠的部分，那么答案就是 $2n$，这不难想。

然后处理完全重叠的面积，先建一个数组标记当前位置是否有窗花，如果有答案就减去 $2$。

接着处理部分重叠的面积，由于窗花的对角线与坐标轴平行，那么窗花的中心与另一个窗花的中心的坐标的距离为 $1$ 是就有重叠的部分，重叠部分就是窗花面积的四分之一，就是 $0.5$，那么答案减去 $0.5$。

最后就是代码部分，还是比较简单的：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
bool vis[10001][10001];//标记数组
double ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		if(vis[x][y]){//完全重合
			continue;
		}vis[x][y]=true;//标记
		ans+=2;//先加上2
		if(vis[x-1][y])ans-=0.5;//部分重叠
		if(vis[x+1][y])ans-=0.5;//部分重叠
		if(vis[x][y-1])ans-=0.5;//部分重叠
		if(vis[x][y+1])ans-=0.5;//部分重叠
	}cout<<ans;//输出答案
	return 0;
}
```

---

## 作者：Mason123456 (赞：2)

# P10703 题解

罕见的题面清楚，赛时忘记删调试代码，被罚时力！

### 思路

观察样例可得：当两个正方形边重叠时，贡献仍然是 $S_{正方形} = 2$，所以我们考虑重叠的情况。

重叠有两种，完全重叠和部分重叠。完全重叠很好判断。

对于部分重叠，需要满足定点在其他正方形的中心点上。因为要求是整数点，所以不可能存在重叠一半，自然也只有一种重叠情况。此时，总面积 $-0.5$，即重叠部分的面积。将每个顶点判断一次即可。

对于每次输入，记录中心点坐标。

### Code

```cpp
#include <iostream>
using namespace std;
const int N = 1e4 + 5;
int vis[N][N];//表示中心点
int main() {
    int n;
    cin>>n;
    double ans = 0;
    for(int i = 1;i <= n;i++){
        int x, y;
        cin>>x>>y;
        if(vis[x][y])   continue;
        double add = 2;
        if(vis[x-1][y]) add -= 0.5;
        if(vis[x+1][y]) add -= 0.5;
        if(vis[x][y-1]) add -= 0.5;
        if(vis[x][y+1]) add -= 0.5;
        ans += add;
//        cout<<ans<<"\n";
        vis[x][y] = 1;
    }
    cout<<ans<<"\n";
    return 0;
}

```

---

## 作者：封禁用户 (赞：1)

很显然，两篇窗花要重叠的条件是他们的曼哈顿距离 $\le 1$。

那么我们就开个二维数组 $c$ 代表每个点上是否有窗花的中心点，所以我们可以令每个 $c_{x_i,y_i}=1$。

我们接着来遍历一遍 $c$，若它上面或右边有窗花，那么就让记录答案数组 $ans\leftarrow ans-0.5$，因为每个重叠部分面积为 $0.5$，然后让 $ans\leftarrow ans+2$，因为单个窗花面积为 $2$。

---

## 作者：zhoujunchen (赞：0)

做题思路
----
一道模拟题。

- 首先我们求出一片窗花的面积 $S_{窗花}=2$。

- 考虑重叠情况，分为完全重叠和部分重叠，由于是整数坐标且窗花对角线长为 $2$，只可能有一种重叠情况，此时面积 $-0.5$。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
double ans;
bool vis[105][105];
int main(){
    cin>>n;
    while(n--){
        cin>>x>>y;
        if(vis[x][y])continue;
        double sum=2*1/2*2;//窗花的面积
        if(vis[x][y+1])sum-=1*0.5/2*2;//求重叠部分的面积
        if(vis[x][y-1])sum-=1*0.5/2*2;
        if(vis[x+1][y])sum-=1*0.5/2*2;
        if(vis[x-1][y])sum-=1*0.5/2*2;
        ans+=sum;
        vis[x][y]=1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：HHC883 (赞：0)

# 题目分析
题目中的坐标系其实就是 $100 \times 100$ 方格图。由于窗花的对角线平行于坐标轴，即窗花的边不平行于坐标轴，所以不好处理。考虑到每个方格可以被其两条对角线分成四部分，每个部分都是一个 $\frac{1}{4}$ 方格，而每个窗花都可以被这样的 $8$ 个 $\frac{1}{4}$ 方格精确表示，所以只需要对 $\frac{1}{4}$ 方格进行统计，由于每个 $\frac{1}{4}$ 方格的面积为 $0.25$，所以答案就是 $\frac{1}{4}$ 方格的个数乘上 $0.25$。
# 参考代码
```cpp
#include<iostream>
using namespace std;
int n,mp[105][105][5];
double ans;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	int x,y;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		mp[x][y][1]=mp[x][y][2]=mp[x][y+1][2]=mp[x][y+1][3]=mp[x+1][y][1]=mp[x+1][y][4]=mp[x+1][y+1][3]=mp[x+1][y+1][4]=1;
	}
	for(int i=0;i<=100;i++){
		for(int j=0;j<=100;j++){
			ans+=0.25*(mp[i][j][1]+mp[i][j][2]+mp[i][j][3]+mp[i][j][4]);
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Eason_cyx (赞：0)

前置知识：记一个正方形对角线长 $k$ 厘米，则该正方形面积为 $\frac{1}{2}k^2$。

---

由于一个窗花对角线只长 $2\text{cm}$，所以如果出现了重叠，一定是以下两种情况：

- 两个窗花的中心点相同，如样例中的 $(5,5)$ 和 $(5,5)$。

- 两个窗花的中心点相距 $1\text{cm}$，如样例中的 $(1,1)$ 和 $(2,1)$。

对于第一种情况，我们可以直接用 `map` 统计，如果发现当前这个窗花已经出现过，就把它扔掉，不计入总数中；

对于第二种情况，枚举每一个窗花的坐标对应四个方向距离 $1\text{cm}$ 的位置，如果这些位置有窗花，就记录下来；在最后，因为重叠是相互的，所以要将记录下来的重叠个数除以 $2$；然后再乘上重叠面积（也就是对角线长 $1$ 的正方形），$\frac{1}{2}\times1^2=0.5$，再用总面积减去即可。

时间复杂度 $\Theta(n)$，可能会带有 `map` 的常数。

```cpp
#include <bits/stdc++.h>
using namespace std;
map<pair<int,int>,bool>mp;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0},x[100005],y[100005];
int main(){
	int t;cin>>t;
	int cnt=0;
	for(int i=1;i<=t;i++){
		cin>>x[i]>>y[i];
		if(mp[make_pair(x[i],y[i])]){i--;t--;}
		mp[make_pair(x[i],y[i])]=true;
	}
	for(int i=1;i<=t;i++)
		for(int k=0;k<4;k++)
			if(mp[make_pair(x[i]+dx[k],y[i]+dy[k])])cnt++;
	
	cout<<2*t-cnt*0.25<<endl;
	return 0;
}
```

---

## 作者：SecuritySetting (赞：0)

题意：

要贴 $n$ 个窗花，每个窗花中心要贴在 $(x_i,y_i)$ 的位置，求这些窗花覆盖的面积。

思路：

窗花的大小都是一样的正方形，正方形的对角线为 $2$ 厘米，那么窗花的面积就是 $2$ 平方厘米（对角线乘以对角线除以二）。

当贴上一个窗花时，面积就加上 $2$，但是会重叠。

当一个窗花的中心与另一个窗花的中心的曼哈顿距离为一是，这两个窗花就有一部分重叠，该重叠部分的面积为窗花面积的四分之一，从题目的样例解释的图中可以看出。换句话说，就是如该给窗花的中心的上下左右四个方向上有其他的窗花，那么这两窗花重叠，重叠面积为窗花面积的四分之一。

如果两个窗花的中心在同一位置，两窗花完全重合。

根据上面的结论，就可以建一个数组标记窗花中心的位置，再判断是否重叠，在记录答案即可。

代码：
```#include <bits/stdc++.h>
using namespace std;
bool vis[100][100];//标记数组
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};//用来判断窗花中心的四周
int main() {
	int n;
	double ans = 0;//答案
	cin >> n;
	for (int i = 1; i <= n; i ++){
		int x, y;
		cin >> x >> y;
		if (vis[x][y])continue;//完全重叠
		ans += 2;
		vis[x][y] = true;//标记
		for (int j = 0; j < 4; j ++) {//四个方向
			int tx = dx[j] + x;
			int ty = dy[j] + y;
			if (vis[tx][ty]) ans -= 0.5;
		}
	}
	cout << ans;
	return 0; 
}
```

---

## 作者：Programming_Konjac (赞：0)

# 思路
假设一个小方格分成这样几块：

![](https://cdn.luogu.com.cn/upload/image_hosting/hclad5fj.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

然后每块方砖的占格如下:

![](https://cdn.luogu.com.cn/upload/image_hosting/n8fe187m.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

因为对角线长 $2$，然后每块小方砖的面积是 $1$，所以分成 $4$ 块后，每一小块的面积为 $\frac{1}{4}$。

然后每次给出 $x,y$，然后就如上图一样将黑色区域全部赋值为 $1$（不能为加法，那样就重叠了）。

最后遍历每一块砖的 $4$ 部分，将赋值的数全部累加起来，最后再乘 $\frac{1}{4}$，输出就可以啦！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int k=0;
struct node{
	int a=0,b=0,c=0,d=0;
}t[105][105]; 
int main(){
	int n;
	cin>>n;
	for(int i=1; i<=n; i++){
		int x,y;
		cin>>x>>y;
		t[x][y].b=t[x][y].d=1;
		t[x-1][y].a=t[x-1][y].b=1;
		t[x][y-1].c=t[x][y-1].d=1;
		t[x-1][y-1].a=t[x-1][y-1].c=1;
	}
	for(int i=0; i<=100; i++){
		for(int j=0;j<=100; j++){
			int f=t[i][j].a+t[i][j].b+t[i][j].c+t[i][j].d;
			k+=f;
		}
	}
	cout<<k*0.25; 
	return 0;
}
```

---

## 作者：ChampionCyan (赞：0)

非常可惜，赛时没做出来，其实很简单。

记录二维布尔数组，表示有没有以这个点为中心的窗花，若新窗花的点位已经被占，贡献为 $0$，否则设初始贡献为 $2$，周围四个点有几个点有窗花就减几个 $0.5$。

码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 10001;
bool vis[MAXN][MAXN];
int main() {
    int n;
    double ans = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        if (vis[x][y])
            continue;
        ans += 2;
        if (vis[x - 1][y])
            ans -= 0.5;
        if (vis[x + 1][y])
            ans -= 0.5;
        if (vis[x][y - 1])
            ans -= 0.5;
        if (vis[x][y + 1])
            ans -= 0.5;
        vis[x][y] = true;
    }
    printf("%lf\n", ans);
    return 0;
}
```

---


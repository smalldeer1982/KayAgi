# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# 题解

## 作者：jiangXxin (赞：161)

这道题我其实原本想用BFS的，结果写完了，才看到花生地里面没有障碍物，果断换上曼哈顿，（曼哈顿真是一个好东西）。按照题目要求一个一个地枚举就好了，如果有不知道曼哈顿的，~~百度一下，你就知道。~~：D（i,j）=abs($x_i$-$x_j$)+abs($y_i$-$y_j$)

**话不多说，贴代码：**

**注释版：**

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N=30;
int mp[N][N];
int n,m,k;
int tm;
int fx,fy,ex,ey;//起点，终点
int pn;
int ans;
struct dire//记忆花生地址 
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)//比较，大的在前，小的在后 
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)//有花生 ，多多：我看到你们了 
            {
                stu[++pn].sum=mp[i][j];//获得一系列有花生的坐标
                stu[pn].x=i;
                stu[pn].y=j;//保存坐标
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);//按照题意来，先大后小 
	fx=1;
	fy=stu[1].y;//设立你的初始位置 
	k--;//从人群中窜出一个光头,多多用了一个单位从人群中跳出 
    for(int i=1;i<=pn;i++)//枚举每一个有花生的点
    {
        tm=0;//计时器清零 
        ex=stu[i].x;
        ey=stu[i].y;//设定多多的终点坐标
        tm=abs(fx-ex)+abs(fy-ey);//求曼哈顿距离，计算本次导航距离 
        k--;//采花生 
        k-=tm;//剩余时间减去前往时间 
        if(k>=ex)//可以返回,装上花生 
        {
            ans+=mp[ex][ey];//加入 
            fx=ex;
            fy=ey;//路径规划成功，前往 fx,fy 
        }
        else//多多如果去这个目标就回不去了，带上现在的花生米回去 
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;//真棒，获得了全部的花生米 
    return 0;
}

```

**无注释版：**

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N=30;
int mp[N][N];
int n,m,k;
int tm;
int fx,fy,ex,ey;
int pn;
int ans;
struct dire
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
	fx=1;
	fy=stu[1].y;
	k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：MC_long_live (赞：37)

今天刚好老师讲稀松矩阵，我看到这道题，突然想可以用来做。于是做了一下。

介绍一下稀松矩阵：

像

0 0 0 1 0

0 3 0 0 0

0 0 2 0 0

0 0 1 0 0

可以用稀松矩阵表示为

1 4 1

2 2 3

3 3 2

4 3 1

其中，第一列表示数据所在行，第二列表示所在列，第三列是这个位置上的数。

看输入数据会发现，~~没错！很稀松~~因为有太多无用的数据，所以就用稀松矩阵来保存。而且方便下面的模拟~~暴力~~。。。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[25][25];
int b[405][5];
int n, m, k;
int q, ans;
int main(){
    cin >> m >> n >> k;
    for (int i=1; i<=m; i++)
      for (int j=1; j<=n; j++){
      	  cin >> a[i][j];
      	  if (a[i][j]!=0){
      	  	 q++;
      	  	 b[q][1]=i;
      	  	 b[q][2]=j;
      	  	 b[q][3]=a[i][j];
          } 
      }

```
存好以后干什么呢？

看题！每次采最多的，所以要排序！

```cpp

    for(int i=1; i<=q; i++)
      for(int j=i+1; j<=q; j++){
      	if (b[i][3]<b[j][3]){
          swap(b[i][3], b[j][3]); 
          swap(b[i][1], b[j][1]); 
          swap(b[i][2], b[j][2]);
        }
      }

```
排序完了，就开始模拟，先初始一下。如果一颗都采不到，就输出。否则ans=最大的。时间减去所用时间。然后开始模拟。求出来到此花生的时间，加上采摘与返回的，如果time enough就加上花生数，减去

## 注意！是减去到达此花生的和采摘的，不用减返回！

不行的话就输出并结束。

```cpp

    if (k>=(b[1][1]*2+1)) ans=b[1][3];
    else {cout << 0 << endl; return 0;}
    k=k-b[1][1]-1;
    for(int i=2; i<=q; i++){
        if (abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1+b[i][1]>k) break;
        else {
           ans+=b[i][3]; 
           k=k-(abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1);
        }
    }    
    cout << ans << endl;
    return 0;
}
```
到达时间就是用行减行，列减列，加起来，要注意使用绝对值，否则你只能过七个点！

这是完整代码：（42行）

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[25][25];
int b[405][5];
int n, m, k;
int q, ans;
int main(){
    cin >> m >> n >> k;
    for (int i=1; i<=m; i++)
      for (int j=1; j<=n; j++){
      	  cin >> a[i][j];
      	  if (a[i][j]!=0){
      	  	 q++;
      	  	 b[q][1]=i;
      	  	 b[q][2]=j;
      	  	 b[q][3]=a[i][j];
          } 
      }
    for(int i=1; i<=q; i++)
      for(int j=i+1; j<=q; j++){
      	if (b[i][3]<b[j][3]){
          swap(b[i][3], b[j][3]); 
          swap(b[i][1], b[j][1]); 
          swap(b[i][2], b[j][2]);
        }
      }
    if (k>=(b[1][1]*2+1)) ans=b[1][3];
    else {cout << 0 << endl; return 0;}
    k=k-b[1][1]-1;
    for(int i=2; i<=q; i++){
        if (abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1+b[i][1]>k) break;
        else {
           ans+=b[i][3]; 
           k=k-(abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1);
        }
    }    
    cout << ans << endl;
    return 0;
}
```




---

## 作者：_Arahc_ (赞：23)

翻了这道题的前两页题解，没有几个和我的思路相仿的。~~唯一的一个我看不懂~~

首先为了让大家快速找到自己可能有的错误，把这道题的部分坑点给出来：

1. 关于算法，题目已经明确规定了走法是按照花生数目由大到小摘花生：

鲁宾逊先生说：“你$\color{red}\text{先找出花生最多}$的植株，去采摘它的花生；然后$\color{red}\text{再找出剩下的植株里花生最多的}$，去采摘它的花生；$\color{Blue}\text{依此类推}$，不过你一定要在我限定的时间内回到路边。”

2. 关于摘花生，将花生采摘下来是要耗费时间的。有同学没有+1，就会爆炸。

3. 关于抄近道，题目虽然没有说清楚，但是不能通过在大路上抄近道省时间。

比如这样的情况，不能走红线，只能老老实实走蓝色路（曼哈顿）

![](https://cdn.luogu.com.cn/upload/image_hosting/kyqotj7u.png)

4. 关于第四个数据点：

1 1 5

15

如果你的答案是 45，请检查一下你是否重复在摘这个仅有的格子。

5. 关于数组大小：开25\*25绝对不会错。

6. 对于没读好题目：保证没有花生数一样的格子，各位不要想太多。

7. 考虑最终答案是0的情况，不要一上来就摘了花生回不去。

8. 无脑抄袭我的代码或其他有反作弊措施的代码的人会体验CE的快感。

然后是我对这道题的分析：

做法比较明显，就是一步一步摘，判断会不会超时，然后算一个曼哈顿距离。

（曼哈顿距离公式：|$x_{1}$-$x_{2}$|+|$y_{1}$-$y_{2}$|）

各位的算法基本都是使用一个结构体，存储格子的坐标和花生数，有的人还存了时间，然后 sort 结构体，依次考虑摘不摘。

我的方法主要区别是省去了结构体和排序这两步。

我使用了一个 map（套 pair） 来存储一个格子的花生数目和坐标，这样当我选定一个花生数目的时候可以 O(1) 查询坐标。

对于从大到小排序，C++ 的STL的 $\color{RoyalBlue}\text{priority queue}$ 可以 O(logn) 插入一个数。

使用 STL 就可以做到输入完成的时候就已经做好了花生数和坐标的绑定，以及一个排序。

这个算法坑在代码实现，最难的地方就是怎么拼写 $\color{RoyalBlue}\text{priority queue}$

~~解决方法也很简单，搜一下就可以了~~

$\color{LimeGreen}\text{输入代码}$

 ```cpp
    int n,m,k,a[23][23];
	map<int,pair<int,int> >c;
	priority_queue<int> q;
   
  
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);
		q.push(a[i][j]);
	}
```

对于怎么处理：

每次取出大根堆的堆顶，依靠 map 锁定它的坐标，判断一下可不可以去摘就行。

为了防止$\color{Red}\text{WA}$声一片，使用 $while(1)$循环的童鞋最好提前处理第一株花生。

 ```cpp
	int j=q.top();q.pop();
	int x=c[j].first;
	int y=c[j].second;
	int w=x+1;
```
$j$表示花生数目，$x$和$y$分别为坐标，$w$表示已经消耗的时间。后文的$s$表示已经摘的花生数目。

每次+1的原因已经写在开头的第二点了。

现在每次处理就简单多了，如果可以摘（摘完了还能回家）就摘，然后再弹出下一个花生，锁定坐标（和距离），计算时间。

 ```cpp
	while(w+x<=k){
		s+=j;
		if(q.empty()) break;
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
		x=c[j].first,y=c[j].second;
	}
```
注意要判断队列是否为空，否则会$\color{Orange}\text{90}$分，$\color{Red}\text{WA}$第4个数据，原因是这篇文章开头写的第四点。

最终是各位期待的完整代码（相信很多人直接跳过，空降到这里来了吧……）

 ```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c; //绑定数量和坐标
priority_queue<int> q;	//存花生数量的大根堆

int main(){
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);// 绑定
		q.push(a[i][j]); // 入队（堆）
	}

//↑输入和预处理，现在所有花生大小坐标已绑定且排好序

	int j=q.top();q.pop();//别像我一样把 top 写成 front
	int x=c[j].first;
	int y=c[j].second;// pair 不会的或 map 不会的可以自行百度
	w+=x+1;

// ↑处理一下0的情况，即一个花生都摘不了

	while(w+x<=k){
		s+=j;
		if(q.empty()) break;//这里不写就是90分
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;//注意这里也要+1，别忘了
		x=c[j].first,y=c[j].second;//更新位置
	}
	write(s);
	return 0;
}

```
纯净无注释版本：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c;
priority_queue<int> q;

int main(){
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);
		q.push(a[i][j]);
	}

	int j=q.top();q.pop();
	int x=c[j].first;
	int y=c[j].second;
	w+=x+1;

	while(w+x<=k){
		s+=j;
		if(q.empty()) break;
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
		x=c[j].first,y=c[j].second;
	}
	write(s);
	return 0;
}

```
结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdz0wz4m.png)

---

## 作者：Forgetter (赞：1)

# Java

这题思路很简单，但是我自己给自己找麻烦，算是提高自己水平。特地去学了学内部类和HashMap和TreeMap，一次就过了，舒服了~~
~~(刚出新手村的萌新)~~
### 思路
想法是输入的时候把有值的点保存下来，并且把对应的坐标值记录下来。这是为了方便接下来算两个点之前的位移等等。我一下子想到数据结构书上的结构体。但是java老师好像没怎么提过(可能是我开小差)，于是我用**内部类**仿照着写一下。

题目对值有明确的大小选择关系，于是我选择的是 _TreeMap(从小到大)_ ,键值对里面**key存入的是花生数量**，**value存的是一个内部类的引用**。这个内部类就是C语言里面的结构体。存的是坐标值x,y。

1. 分类讨论是否第一步，第一步不用列坐标相减；
2. 在上一步里面继续分类讨论是否可以去到下一个点(去了能回家就表示可以去下一个点)。
能，则递归进下一个点；不能，即体力不够，回家return；
3. 递归以上，体力用完 或 全部采集为递归出口return。

详细的我下面的代码 _有注释_ ，像老母亲说话一样详细~~(唠叨)~~

### 注意
1.  由例二可以知道** _不求最优解，不需要贪心_ **。即如果一个较大的值判断后不可取，那么不用看剩下较小的，直接输出结果。

2.  走**第一步**的情况和之后的步骤是**不同**的哟，不用判断是第几列开始


~~有人咩？详细看下面的代码（有问题或建议可以提哟(＾Ｕ＾)ノ~）~~

------------
```java
import java.io.BufferedInputStream;
import java.util.*;
import java.util.Map.*;

public class Main {
	static int m,n,k,sum; //几行 几列 体力值 采花生数
	static int[][] t;//输入用的矩阵，我在想是不是可以不用写这个。没用
	static TreeMap<Integer,XY> map;	//键值对  key是花生数量，value是XY的引用
	static int[] a; //记录有值的点 
	//将有有值的点的(x,y)坐标记录下来，等下要用  
	class XY{
		public int x,y;		//x行数   y列数	  (别和数学坐标搞混了)
		
		public int getX() {
			return x;
		}
		public int getY() {
			return y;
		}
		public XY(int x, int y) {
			super();
			this.x = x;
			this.y = y;
		}	
	}
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		while(sc.hasNext()){
			m = sc.nextInt(); n = sc.nextInt(); k = sc.nextInt();
			t = new int[m+1][n+1];
			map  = new TreeMap<Integer, XY>();	//初始化TreeMap
			Main test = new Main();	//实例化一个外部类,用来实例化内部类XY
			
			//输入  &  找出有值的点
			for(int i=1;i<=m;i++)
				for(int j=1;j<=n;j++){
					t[i][j] = sc.nextInt();
					if(t[i][j]!=0){
						XY zuobiao = test.new XY(i, j);
						map.put(t[i][j],zuobiao);	//存这个值 和 坐标
					}
				}
			
			//题目是从大到小。。而TreeMap的从小到大。麻烦，存到数组算了
			//遍历一下。。把key键值(花生数)存到数组a里面 
			int i=map.size()-1; 		//下标初始化
			a = new int[map.size()];	
			Iterator iter = map.entrySet().iterator();//迭代器遍历TreeMap
			while(iter.hasNext()){	//数组里面是从大到小
				Map.Entry entry = (Entry)iter.next();
				a[i--] =  (Integer) entry.getKey();
			}

			sum = 0;	//初始化
			pan(k, 0);	//调用，判断第一个最大的花生数可以采摘吗
			
			System.out.println(sum);	//终于完了，输出咯

		}sc.close();
	}
	

	//递归判断个点  通过例2可知找不到就回家，不用贪心！！！
	public static void pan(int k,int num){	//剩余体力值 第几号点
		if(num==a.length||k==0){//递归出口 全部判断完
			return;
		}else {
			if(num==0){//第一个情况特别，不用判断列走了多少
				//去、回来、采摘的体力>剩余体力 
				if(map.get(a[num]).getX()+1+map.get(a[num]).getX()>k){
					return;//出门就没体力，搞毛啊
				}else {
					sum+=a[num];	//收集花生
					//减去  去、采摘 的体力(回家的体力别减了)
					k-=(map.get(a[num]).getX()+1);
					pan(k, num+1);	//检验下一个点
				}
			}else {//其他需要判断列和横，采摘，回家的消耗体力值
				//去、回来、采摘的体力>剩余体力  （判断可以去 下个点 吗）
				// |xa - xb| + |ya - yb| + 1 + xa > k     (a当前  b上一个)
				if(Math.abs(map.get(a[num]).getX()-map.get(a[num-1]).getX())
						+Math.abs(map.get(a[num]).getY()-map.get(a[num-1]).getY())
						+map.get(a[num]).getX()+1>k){ 
					return;	//体力值不够，直接归家
				}else {	//表示去下个点后可以回家，那就去呗。
					sum+=a[num];
					//减去  去、采摘 的体力(回家的体力别减了)
					k-=(Math.abs(map.get(a[num]).getX()-map.get(a[num-1]).getX())
							+Math.abs(map.get(a[num]).getY()-map.get(a[num-1]).getY())
							+1);
					pan(k, num+1);	//检验下一个点
				}
			}
		}
	}	
}

```

---

## 作者：buickboy (赞：1)

这题用降维大法！
————用结构体来实现二维数组的降维排序。只需要33行。

------------

建二维数组再反复找最大值是很自然的想法，但这样既没必要，也费时间。注意，题目要求是按花生数从大到小依次寻找，所以不要用贪心、深搜，只要能排序就能解决了。这样又有三个问题需要解决。

------------

一是二维数组如何排序？先一维化，再排序，但需要记录行号列号，因为要计算与植株、与路边的距离。这样就要用到结构体。

------------

二是能不能采摘如何判断？要做三件事，能去、能采、能回路边。能去就要用与下一个植株的距离，也就是相应行号、列号之差的绝对值之和判断，注意不是平面坐标系上两点的距离；能采是1单位时间，能回路边是行号减0。

------------

三是注意几个坑。第一，会不会一株也采不了？第1次是从路边直接进去，与列号无关，没有距离的计算，有特殊性，所以要对第1次采摘特判。第二，采最后一株时不需要进行能去下一株的判断，这时怎么处理？直接能回路边就可以，要防止数组过界。第三，会不会去了但不够采，或者不能回？每次更新剩余时间时，能去下一株采摘的前提是问题2的三件事，回路边已经作了判断，所以既然到了下一个植株，就能够从那里采了直接回路边。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct pea{
	int a,b,s;//行、列号及花生数,行号a同时是回路边步数 
}p[600];
bool cmp(pea x,pea y){//按花生数排序规则 
	return x.s>y.s;
}
int main()
{
    int m,n,k,i,j,r=0,t,ans=0;
    scanf("%d%d%d",&m,&n,&k);
    for(i=1;i<=m;++i)
    for(j=1;j<=n;++j)
    {
    	++r;//结构体数组个数计数,最终r=m*n 
    	scanf("%d",&p[r].s);
		p[r].a=i,p[r].b=j;//记录花生数及行列号 
	}
	sort(p+1,p+1+r,cmp);//全部按花生数从大到小排好 
	if(k>=1+2*p[1].a)//采摘需要1单位时间，第1次直接去并且能回，
		k-=p[1].a+1,ans+=p[1].s;//去并且采摘，更新剩余时间，熊停在a1
	else {printf("0");return 0;}//否则不够时间采摘和回来就输出0个 
	for(i=1;i<r;++i)//站在第一株花生旁向下一步看
	{
		t=abs(p[i].a-p[i+1].a)+abs(p[i].b-p[i+1].b);//与下一点距离 
		if(k>=t+1+p[i+1].a)//能去、采、回路边,最后一步也是如此 
			k-=t+1,ans+=p[i+1].s;//就去采，更新剩余时间和采摘数 
		else break;//不能采就退出 
	}
	printf("%d",ans);
    return 0;
}

```
- 

---


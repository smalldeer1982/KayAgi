# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# 题解

## 作者：yummy (赞：512)

简单地逛了逛题解区，发现大部分题解分为两种：
- `next_permutation`
- 手写 `next_permutation`

于是，我为了不让题解区太单调，也为了拓宽大家的思维，就经过几分钟的努力，想出了一种与众不同的方法。

**Updated on 2022.7.14: 添加 $\LaTeX$，增加变进制数加法的讲解。**

> 变进制数

我们的目标是把全排列转化成一个变进制数，以方便我们进行加法。   
对于第 $i$ 根手指，它有 $n-i+1$ 种选择，根据位值原理，要想让每个数对应一个全排列，就要让这一位数是 $n-i+1$ 进制的。

那么，整个过程分为三步：
1. 将火星数变成变进制数
2. 将变进制数加上 $m$
3. 将变进制数变成火星数

我们来看一个实例：
将 $1,4,5,2,3$ 变成变进制数：
- 首位 $1$ 是 $5$ 种选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，故变为 $0$（从0开始）
- 次位 $4$ 是 $4$ 种选择 $\{2,3,4,5\}$ 的第 $3$ 种，故变为 $2$
- 中间位 $5$ 是 $3$ 种选择 $\{2,3,5\}$ 的第 $3$ 种，故变为 $2$
- 次低位 $2$ 是 $2$ 种选择 $\{2,3\}$ 的第 $1$ 种，故变为 $0$
- 末位 $3$ 是 $1$ 种选择 $\{3\}$ 的第 $1$ 种，故变为 $0$
- 最后，排列 $1,4,5,2,3$ 变成了$(02200)_{unknown}$

接下来给它加上 $3$ 变成 $(02203)$，并处理进位：
- 末位是 $1$ 进制的，进 $3$ 得 $(02230)$。
- 次低位是 $2$ 进制的，满 $2$ 进一得 $(02310)$。
- 中间位是 $3$ 进制的，满 $3$ 进一得 $(03010)$。
- 次位是 $4$ 进制的，$3<4$，不进位，得 $(03010)_{unknown}$。

最后将 $(03010)_{unknown}$ 变回火星数。

- 首位 $0$ 表示这位应选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，即 $1$
- 次位 $3$ 表示这位应选择 $\{2,3,4,5\}$ 的第 $4$ 种（$1$ 被选过了），即 $5$
- 中间位 $0$ 表示这位应选择 $\{2,3,4\}$ 的第 $1$ 种，即 $2$
- 次低位 $1$ 表示这位应选择 $\{3,4\}$ 的第 $2$ 种，即 $4$
- 末位 $0$ 表示这位应选择 $\{3\}$ 的第 $1$ 种，即 $3$

所以本题答案为 `14523` $+3=$ `15243`。

代码 $37$ 行，应该是除 STL 外较短的了。
```
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}
```
---

这篇题解是我较早时候发的，通过评论区我纠正了举个栗子那个部分的小问题。   
现在我也通过评论区知道我这方法叫做康托展开。如果你想了解更多，可以看[这篇博客](https://www.luogu.org/blog/abc123-yummy/huoxingren).

---

## 作者：zhi_zhang (赞：91)

不知道有没有与我的想法相同的题解已经发布

但是我觉得这是最为直观易懂的方法

而且讲的也是直观易懂

按照人脑的思维去模拟增加的过程

下面是**模拟过程**：

**刚开始所有的数已经使用过**

**从最后一位开始**

**要判断当前的数位是否还有更高的未标记数可以使用**

**如果有，那就使用找到的数替换该位置的数，然后剩余未标记的数按照从小到大的顺序塞回去**

**如果没有，那就取消当前数位的标记，搜索上一数位**

_样例： 1 2 3 4 5，加3次_

_**第一次**_

_（5）数位为5，判断后发现此时已经没有更高的未标记数_

_5取消标记，搜索上一数位_

_（4）数位为4，当前有更高的5未被标记_

_（4）数位用5代替，4取消标记_

_剩下的（5）数位用仍未标记的4代替_

_第一次结束,得到 1 2 3 5 4_

_**第二次**_

_（5）数位的4和（4）数位的5取消标记_

_（3）数位的3用4代替，3取消标记_

_把3,5按从小到大顺序依次填入（4）（5）数位_

_第二次结束，得到 1 2 4 3 5_

_**第三次**_

_（5）数位5取消标记_

_（4）数位3用5代替，3取消标记_

_将3填入（5）数位_

_第三次结束，得到1 2 4 5 3_

**代码自带输出调试**

以下是代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int MAXN=10010;
int finger[MAXN];
int N,M;
int vis[MAXN];
int ad(int);
void prin();
int main()
{
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)//输入 
	{
		vis[i]=1;
		scanf("%d",&finger[i]);
	}
	while(M--)//计算还剩多少步 
	{
		for(int i=N;i>=1;i--)//倒着进行判断 
		{
			int k=ad(finger[i]);
			if(k!=-1)//如果能够增加 
			{
				vis[finger[i]]=0;
//				printf("%d取消标记\n",finger[i]);
				finger[i]=k;//那么当前指头变为序号更大的指头
				vis[k]=1;
//				printf("(%d)处手指变为%d\n",i,k);
//				printf("%d标记\n",k);
				for(int j=i+1;j<=N;j++)//剩下的指头从小到大向后排序 
				{
					for(int p=1;p<=N;p++)//从小到大检索 
					{
						if(!vis[p])//如果p手指还没进入 
						{
//							printf("(%d)处手指变为%d\n",j,p);
							finger[j]=p;//该手指则为p 
							vis[p]=1;//p手指已进入 
//							printf("%d标记\n",p);
							break;
						}
					}
				}
//				prin();
				break;
			}
			else//如果不能增加 
			{
				vis[finger[i]]=0;//该手指退出，然后搜索下一个手指 
//				printf("%d取消标记\n",finger[i]);
			}
		}
	}
	prin();
	return 0;
}
int ad(int poi)//检索该手指 
{
	for(int i=poi+1;i<=N;i++)//向上搜索直到 
	{
		if(!vis[i])//搜索到还未入队的更大的数 
		{
			return i;//返回该数 
		}
	}
	return -1;//检索不到则返回-1
}
void prin()
{
	for(int i=1;i<=N;i++)
	{
		printf("%d ",finger[i]);
	}
	printf("\n");
}
```

**因为题目上说了是加了一个很小的数，所以不会因为模拟次数过多超时**

---

## 作者：Believe_R_ (赞：65)


## 此题是一道练全排列函数的好题！
传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

至于什么是全排列函数，我们先来看一道**模板题**：[P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706)

**一句话题意**：输出 $n$ 的全排列。

```cpp
样例输入：
	3
样例输出：
	1	2	3
    1	3	2
    2	1	3
    2	3	1
    3	1	2
    3	2	1
```

看看自己2年前写的代码，用**递归**来做（不得不承认，这是一道递归的好题），下面贴上递归代码（初学者都会写）！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k;
int a[10]={0},bj[10]={0};
void dfs(int x)
{
    int i,j;
    if(x==n+1)
    {
        for(i=1;i<=n;++i)
        printf("%5d",a[i]);
        cout<<endl; 
    }
    else
      for(i=1;i<=n;++i)
        if(bj[i]==0)
        {
            a[x]=i; bj[i]=1;
            dfs(x+1);
            a[x]=0; bj[i]=0;
        }
}
int main()
{
    cin>>n;
    dfs(1);
    return 0;
}
```



然而到今天，我突然翻出这道题，发现这道题不就是**全排列函数的模板题**吗？下面就请我们今天的主角上场：

$$
 \Large \texttt{next \_ permutation}
$$

这个函数每运行一次就可以排列出下一个全排列的序列 （**<algorithm>** 中有许多好用的函数）。

用法即是 next_permutation(数组开头，数组结尾)  【和 sort 用法差不多】

伪代码如下：

```cpp
#include <algorithm>
// #include <bits/stdc++.h>    //用这个我也没意见

int a[1000];
int n;
int main()
{
    令a[i]=i;
    int tot=n所有全排列的数量;
    for i=1 to tot
    {
        next_permutation(a+1,a+n+1);  //因为我 a 数组是从下标1开始存的
    }
    return 0;
}
```

那现在还有一个问题：$tot$ 怎么求呢？

这就涉及到排列组合的问题了。

全排列的数量即是 $A_n^n = n !$ （不懂的话可以自己去学习一下）

那么每次运行这个函数之前，输出数组 $a$ 的值即可！

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[100];
int main()
{
    scanf("%d",&n);
    int tot=1;
    for(int i=1;i<=n;++i)
    {
        a[i]=i;
        tot*=i;
    }
    for(int i=1;i<=tot;++i)
    {
        for(int j=1;j<=n;++j) printf("    %d",a[j]);    //输出格式注意
        next_permutation(a+1,a+n+1);
        printf("\n");
    }
    return 0;
}
```



### 这道模板题做了后，再回来看这道题目吧：


传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

题目看过了，自己可以先想一下………………

别看这是一道**普及组T4** 的题目，但是我觉得它连 **T2** 的难度都没有 ~~（只要你掌握了这个函数）~~

**一句话题意： 求出一个给定长度的序列经过 $m$ 次全排列变化后的序列。**

甚至比上一题还简单，改变的次数都跟你说了~  \^~^   ~

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100000];
int n,m;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f;
}
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
//简单吧~
```



---

## 作者：Matoi (赞：28)

# Pascal题解

- 这题我并没有用数学模型，而是找规律

#### 规律如下

- 找一个尽量靠后的数（m），使其后为一个连续下降序列（只含一个数也行）。并交换该数与其后序列中最小的但比该数大的数

- 交换这个序列中第a大与第a小的数(1<=a<=序列长div 2)

### 以1 2 3 4 5 为例

1. m=4，4与5交换，变为1 2 3 5 4。序列为4，长为1，不交换。

1. m=3，3与4交换，变为1 2 4 5 3。序列为5 3，交换后为1 2 4 3 5。

1. m=3,3与5交换，变为1 2 4 5 3。序列为3，长为1，不交换。

1. 输出1 2 4 5 3。

------------

#### 加上m即为重复m次

------------



    
    
```cpp
    var m,n,i,j,k,l,min,count:longint;
        a:array[0..10000]of longint;
    procedure swap(u,v:longint);//交换a[u]与a[v]的过程
    var t:longint;
    begin
      t:=a[u];
      a[u]:=a[v];
      a[v]:=t ;
    end;
    begin
      fillchar(a,sizeof(a),0);//不赋初值可能会错
      readln(n);
      readln(m);
      for i:=1 to n do read(a[i]);//读入各数据
      for i:=1 to m do//相当于加上m
        begin
          k:=n; //k指针从后向前找
          while a[k]<a[k-1] do dec(k);//因为该序列尾在最后一个数处，且连续。若加上前一个数条件仍成立，则将该数纳入序列。a[k-1]即为m。
          min:=maxint; //初始化min，使其在之后定能被赋一个值
          for j:=k to n do 
          if (a[j]<min)and(a[j]>a[k-1]) then//寻找大于m的最小数
            begin
              min:=a[j];//记录最小值
              count:=j;//记录最小值的位置
            end;
          swap(k-1,count);//规律1，交换m与序列中最小的但比m大的数
          for j:=k to (k+n)div 2 do//j即为a
            swap(j,n+k-j);//规律2，前后交换
        end;
      for i:=1 to n do
        write(a[i],' ');//输出结果
    end.

```

---

## 作者：Lynkcat (赞：18)

这是个来自P党的垃圾题解！

看到这道题目，你脑子里第一个冒出来的词语是什么？

全排列！！！

那么怎样求全排列呢？

又第一个想到DFS！！！

一看手指位数是10000，想必不少蒟蒻都会放弃这个念头。

但是关键点不在这儿，

**在于加上的位数！！！**

再看n<=100，

加上剪枝，放心大胆的去做吧！！！
```pascal
var h,i,p,n,t,ans:longint;b,e:array[0..10000]of longint;c,f:array[1..10000]of boolean;sub:boolean;
procedure dfs(k:longint);
var j,y:longint;
begin
  if k>n then
  begin
    dec(t);
    exit;
  end;//如果产生完毕则退出
  if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;//若已经找到则输出再退出程序
  if f[k] then y:=1 else y:=e[k];//这里是重点，剪枝的一个重要环节！！！
  for j:=y to n do
    if c[j]=false then
    begin
      b[k]:=j;
      c[j]:=true;
      dfs(k+1);
      if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;
      c[j]:=false;//别忘记回溯
    end;
  f[k]:=true;//设此层已访问
end;
begin
  readln(n);
  read(t);inc(t);
  for i:=1 to n do
    read(e[i]);
  dfs(1);//开始深搜
end.

```


---

## 作者：Forever丶CIL (赞：17)

这个题就是一个部分的全排列，如果用 next\_permutation(a,a+n);

这种stl函数水过去就太没意思了，也练不了自己的代码能力

不如试着写一下全排列，当然全部全排列肯定会TLE的

我们可以从当前排列（就是火星人手指表示的那个排列）开始，做m次排列，

即找按顺序排列的全排列中，排在当前序列之后m个的那个序列

其实也差不多就是手动做一下 next\_permutation(a,a+n);做的工作

解释留到代码中

qaq


------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m,tot=1;
int vis[10101];
int sl[10101];
int f[10101];
void print()//输出函数 
{
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sl[i]);
    }
    printf("\n");
}
void dfs(int cur)//从当前数列开始全排 
{
    if(cur==n+1)
    {
        m--;
        //return ;
    }
    if(m==-1)
    {
        print();
        return ;
    }
    else for(int i=(f[cur]?1:sl[cur]);i<=n;i++)//这一步做的工作是将现在的dfs迅速递归到找到最初序列的状态 
    {
        if(!vis[i])//基本的全排列 
        {
            sl[cur]=i;
            vis[i]=1;
            dfs(cur+1);
            if(m==-1) return ;
            vis[i]=0;
        }
    }
    f[cur]=1;
    return ;
}
int main()
{
    /*scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
    }*/
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
        //vis[i]=1;
    }
    dfs(1);
    return 0;
}
```


------------

可能大家不是很懂dfs中的那个for 其实想一想，我们在求全排列的时候
是递归求的，我们每求得一中全排列，它背后是有一个递归层的

所以当我们想从任意一种排列开始求它后面的排列时，就需要先把

它的这个递归层先建立起来，然后顺着继续递归就好了

qaq rp++




---


# [NOIP 2007 提高组] 统计数字

## 题目描述

某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。


## 说明/提示

- $30\%$ 的数据满足：$1  \le  n  \le  1000$；
- $60\%$ 的数据满足：$1  \le  n  \le  50000$；
- $100\%$ 的数据满足：$1  \le  n  \le  200000$，每个数均不超过 $1.5 \times 10^9$。

NOIP 2007 提高第一题


## 样例 #1

### 输入

```
8
2
4
2
4
5
100
2
100```

### 输出

```
2 3
4 2
5 1
100 2
```

# 题解

## 作者：Swire (赞：11)

这道题乍一看是一个计数排序对吧

但是刚看到这道题的人可能会被数字范围吓到：1500000000，明显数组是开不下的。

那么计数排序就是行不通的

这时候，我们就可以想到一个东西：
# map
map内部是一棵红黑树，由于这题是一道普及-水题，所以就不细讲了
~~(其实是我不会)~~

不懂的同学可以先把map当作一个下标可以开很大的数组使用

这样就可以实现计数排序的思路了

----------------------------------------------------------浮夸的分界线---------------------------------------------------------

本题还有一个问题：统计出现过的数字

这个问题也可以用一个很妙的数据结构解决：

# set

set可以理解为一个排好序的数列(升序),它有insert,erase等操作

set中的每个数都只会出现一次

那么set的这一性质就可以被很好地利用

只需遍历这个set就可以输出出现过的数字

还有一些具体内容代码里解释

```cpp
#include<cstdio>
#include<map>
#include<set>
std::set <int> num;
std::set <int> :: iterator I;//set支持迭代器
std::map <int,int> statistics;
//尖括号中左侧的数据类型是键值的类型，右侧的是映射的类型
//支持int,double,char,string等类型
//就像这样：statistics["ONE"]=1;
//那么字符串"ONE"对应的映射值就是1
//要是还是不明白的话就去看看那些打表题
int n,in;
int main(void){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&in);
		statistics[in]++;//当成数组理解
		num.insert(in);//在set中插入一个元素
	}
	for(I=num.begin();I!=num.end();I++)
		printf("%d %d\n",*I,statistics[*I]);
           //输入中存在这一数字就输出并输出个数，*I指的是迭代器I指向的值
	return 0;
}
```


---

## 作者：ikunTLE (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P1097)

### 思路

本题考察 map 的基本语法。

首先考虑桶，对于每一个数，对应的桶增加 $1$ 即可。可是发现数据范围为 $1.5\times10^9$，普通的数组无法开到这么大，会导致 MLE。

于是考虑 map。读入照常，对于读入的数 $x$，执行 $m_x\gets m_x+1$。最后再用 `it` 遍历一遍 map，分别输出 map 中存储的对应数字及其数量，分别为 `it->first` 和 `it->second`。

map 的一次修改是 $\mathcal{O}(\log n)$ 的，所以时间复杂度为 $\mathcal{O}(n\log n)$，可以通过此题。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,x;
map<int,int>mp;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&x),++mp[x];
	for(auto it=mp.begin();it!=mp.end();++it)
		printf("%d %d\n",it->first,it->second);
	return 0;
}
```

---

## 作者：monkeyking_QAQ (赞：6)

[题目传送门](https://www.luogu.com/problem/P1097)

### 思路：

把数字从大到小排序。如果 $a_i = a_{i+1}$，也就是这个数和后面的那个数相同，那么计数器加一；否则输出这个数然后输出这个数的个数。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005];
int n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+1+n);
    s=1;
	for(int i=1;i<=n;i++){
        if(a[i]==a[i+1]) s++;   //计数器加一
        else{
            cout<<a[i]<<" "<<s<<endl;  //输出答案
            s=1;   //重置
        }
	}
	return 0;
}
```

---

## 作者：ryf2011 (赞：5)

# 题目思路
原本来说，这题希望可以直接通过数组计数，但发现数据过大，所以我们考虑别的方法。

我们考虑把数组换成 $\text{map}$ 来标记出现次数，每次输入一个值，以这个值为下标判断在 $\text{map}$ 中的值是否为 $0$，如果为 $0$，说明之前未出现过，将其加入一个数组（用于记录所有出现的数，去重）中存储。然后不管为 $0$ 还是不为 $0$，都要将以这个值为下标的位置的值加 $1$。

然后将记录出现的数的那个数组从小到大排序，输出时，按照数组中数的顺序先输出这个值，再直接查找以这个值为下标在 $\text{map}$ 中的值并输出即可。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<algorithm>
using namespace std;
int n,allnum[200005],now,m;
map<int,int> times; //用 map 来记录次数 
int main(){
	scanf("%d",&n); //输入 
	for(int i=1;i<=n;i++){
		scanf("%d",&now); //输入 
		if(times[now]==0){ //没出现过，将其加入数组 
			m++;
			allnum[m]=now;
		}
		times[now]++; //次数 +1 
	}
	sort(allnum+1,allnum+m+1); //排序 
	for(int i=1;i<=m;i++){ //按照规定格式输出 
		printf("%d %d\n",allnum[i],times[allnum[i]]);
	}
	return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：WsW_ (赞：4)

### 思路
先把所有的数进行排序，排序后相同的数必定都是挨着的。  
遍历排序后的数列，把相同的数合并成一个块。  
需要记录这个块的长度，以及这个块内都是什么数字。 
最后把所有块都输出即可。  

时间复杂度为 $O(n\log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num,lenth;
}block[200005];
int a[200005]={-1};
int n;
int len;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		if(a[i]==a[i-1])block[len].lenth++;
		else block[++len]={a[i],1};
	}
	for(int i=1;i<=len;i++)printf("%d %d\n",block[i].num,block[i].lenth);
	return 0;
}
```

---

## 作者：2023z (赞：3)

### 思路

先排序，排序后相同的数会挨在一起，在遍历一遍判断当前数是否等于前一个数，如果等于，$ cnt $ 加 $ 1 $，否则输出这个数及 $ cnt $，$ cnt=1 $。

#### code：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long a[200010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1); //排序
	int cnt=1; //注意初始化为1，因为从二开始循环
	for(int i=2;i<=n;i++){
		if(a[i]==a[i-1]) cnt++;
		else{
			cout<<a[i-1]<<' '<<cnt<<endl;
			cnt=1; //注意 cnt=1，因为下一个数从 a[i] 开始
		}
	}
	cout<<a[n]<<' '<<cnt; //要输出最后一个数
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/198654451)

完结撒花！！

---

## 作者：lizhixun (赞：2)

本题我们乍一看，数据范围很大，于是我们直接用超级桶 $\texttt{map}$ 解决。注意，如果要用 `auto` 要 C++14 及以上才能用。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

map<int, int> mp;
const int N = 2e5 + 5;

int n, a[N], b[N];

signed main() {
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		mp[a[i]]++;
	}

	sort(a + 1, a + n + 1);

	int cnt = 0;
	b[++cnt] = a[1];

	for (int i = 2; i <= n; i++) {
		if (a[i] != a[i - 1]) {
			b[++cnt] = a[i];
		}
	}

	for (int i = 1; i <= cnt; i++) {
		cout << b[i] << " " << mp[b[i]] << endl;
	}

	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：2)

## Foreword

本题目我给大家提供两种方法。欢迎大家在评论区中写出你的方法。

## Solution 1

使用 map。

因为题目要求按照自然数从小到大的顺序输出，所以不能直接用 map 存。我是先将 $n$ 个自然数输入，存到 $a$ 数组，给数组排一遍序。接下来，遍历数组，每个数在 map 中加 $1$。最后来一个迭代器，输出。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 5;
ll n;
ll a[maxn];
map<ll, ll> mp;
int main() {
	cin >> n;
	for (ll i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	for (ll i = 1; i <= n; i++) {
		mp[a[i]]++;
	}
	map<ll, ll>::iterator it;
	for (it = mp.begin(); it != mp.end(); it++) {
    	cout << it -> first << " " << it -> second << endl;
	}
	return 0;
}
```

## Solution 2

应该是一种比较新奇的方法吧？

使用 set 和 multiset。

set 和 multiset 都会对数自动排序，所以不用担心题目中按从小到大的顺序输出这个条件。set 会去重，来存单个数，multiset 不会去重，就存所有数。定义迭代器，遍历 set，先输出 set 当前位置的值，接下来再输出 multiset 里有多少个 set 当前位置的值。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 1e5 + 5;
ll n, x;
set<ll> s;
multiset<ll> ms;
int main() {
	cin >> n;
	for (ll i = 1; i <= n; i++) {
		cin >> x;
		s.insert(x);
		ms.insert(x);
	}
	set<ll>::iterator it;
	for (it = s.begin(); it != s.end(); it++) {
		cout << *it << " " << ms.count(*it) << endl;
	}
	return 0;
}
```

## Other

码字不易，求赞。希望我的题解对大家有帮助。

---

## 作者：qhr2023 (赞：1)

## solution

模拟题。

开一个映射 ```map``` 作为桶，把读入的 $n$ 个数放入桶里，以数字为键，数字出现次数为值，自然统计出每种数的出现次数。最后遍历输出即可。

这里是[映射](https://oi-wiki.org/lang/csl/container/#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8)的用法。

[通过记录](https://hydro.ac/record/6789d3906c52be2cd60afeee)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int, int> mp;
int n, x;
int main(){
	cin >> n;
	for ( ; n--; mp[x]++)
		cin >> x;
	for (auto i:mp)
		cout << i.first << ' ' << i.second << '\n';
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：1)

### 思路

观察到数字范围较大，但 $n$ 范围相对较小，考虑使用 map 。我们使用一个 map 记录每个数字及其出现个数即可。

### 实现

```cpp
# include <iostream>
# include <map>
using namespace std;
map<int,int> mp;
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n; cin >> n;
	for (int i = 1;i <= n;i++){
		int tmp; cin >> tmp;
		mp[tmp]++; // 记录
	}for (map<int,int>::iterator it = mp.begin();it != mp.end();it++){
		cout << it->first << " " << it->second << endl;
	}return 0;
}
```

---

## 作者：pengyirui (赞：1)

题解区其他大佬都用的是map、队列，作为蒟蒻的我完全不会。看到题目，我第一想到的就是可重集。
# 可重集介绍
可重集，与集合大致相同，但是可以出现重复数字，自动排序。
## 头文件

```cpp
#include <set>
```
使用万能头的当我没说。
## 定义

```cpp
multiset<int> e;
```
## 插入

```cpp
e.insert(i); 
```
## 删除

```cpp
e.erase(i);      //删除所有值为i的元素
e.erase(e.find(i)) //删除一个值为i的元素
```
## 统计数量

```cpp
e.count(i);      //统计值为i的元素的数量
```
## 判空

```cpp
e.empty();       //判断multiset是否为空
```
## 迭代器与遍历

```cpp
multiset<int>:: iterator rit;        //定义迭代器 
rit = (e.insert(j)).first    //返回插入后元素对应的迭代器
rit=e.find(i);       //返回第一个值为i的元素的迭代器，如果没找到返回的是e.end()
rit=e.lower_bound(i)  //返回值大于等于i的第一个元素的迭代器， 如果没有大于等于i的元素返回e.end()
rit=e.upper_bound(i)  //返回值大于i的第一个元素的迭代器， 如果没有大于i的元素返回e.end()
for(rit=e.begin();rit!=e.end();rit++)   //正序遍历，值为*rit
set<int>::reverse_iterator rit;         //反向遍历的迭代器 
for(rit=e.rbegin();rit!=e.rend();rit++) //反向遍历必须这么写 
```
## 结构体重载
如使用结构体，必须重载< 或写仿函数。如希望用多种不同排序方式对set/multiset内元素进行排序， 则应该重载运算符， 写成仿函数形式：

```cpp
struct t {
    int a, b, c;
};
struct cmp1
{
    bool operator () (const t &x, const t &y)
    {return x.a < y.a;}
};
struct cmp2
{
    bool operator () (const t &x, const t &y)
    {return x.b < y.b;}
};
struct cmp3
{
    bool operator () (const t &x, const t &y)
    {return x.c < y.c;}
};
set <t, cmp1> st;
set <t, cmp2> st2;
set <t, cmp3> st3;
```
# 思路
## 思路1（期望得分： $$0$$）
本题输入后直接存入可重集，再一个一个输出。
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
multiset<int> s;
int n;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		s.insert(a);
	}
	multiset<int>::iterator rit;
	for(rit=s.begin();rit!=s.end();rit++)
	{
		if(s.find(*rit)==s.end())continue;
		int b=*rit;
		cout<<b<<" "<<s.count(b)<<"\n";
		s.erase(b);
	}
	return 0;
} 
```
没问题~吗~？  
[记录](https://www.luogu.com.cn/record/198647019)  
为什么呢？   
我仔 ~（zai）~ 细 ~（tao）~ 地 ~（lun）~ 想 ~（qu）~ 了 ~（wen）~ 一 ~（le）~ 会 ~（yi）~ 儿 ~（xia）~，恍然大悟。    
~以下摘自linyutong123123的回答~    
在原有的 set 中删除元素会导致当前正在遍历的迭代器被删除，就会报 RE 。可以再开一个 set ，存放已经遍历过的元素，如果没遍历过就将答案输出
## AC代码（[AC记录](https://www.luogu.com.cn/record/198654929)）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
multiset<int> s;
int n;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		s.insert(a);
	}
	multiset<int>::iterator rit;
    set<int> s2;
	for(rit=s.begin();rit!=s.end();rit++)
	{
		int b=*rit;
        if (s2.find(b) != s2.end()) continue;
		cout<<b<<" "<<s.count(b)<<"\n";
        s2.insert(b);
	}
	return 0;
}
```
### 完结撒花！

---

## 作者：LiJunze0501 (赞：1)

看底下的大佬都用了特殊的数据结构，我采用一个简单的方法。
# 思路
升序排序，从第一个遍历到第 $n$ 个，输出当前数字，再用指针 $i$ 向后遍历，用 $cnt$ 记录后面有多少相同数字，输出。代码如下：
```cpp
sort(a+1,a+n+1);//升序排序
int i=1;
while(i<=n){//遍历
	int t=a[i];
	cout<<a[i]<<" ";//输出当前数字
	int cnt=0;
	while(a[i]==t) cnt++,i++;//记录后面的相同数字
	cout<<cnt<<endl;//输出
}
```
这就是代码的核心部分了。
# 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200001];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	int i=1;
	while(i<=n){
		int t=a[i];
		cout<<a[i]<<" ";
		int cnt=0;
		while(a[i]==t) cnt++,i++;
		cout<<cnt<<endl;
	}
}
```
谢谢观看。

---

## 作者：Cold_Eyes_bystander (赞：1)

这道题是好久前写的了，当时只会排序。

发现他的数字非常大，普通桶排炸飞了，但 $n$ 却很小，我们可以先排序，发现所有**一样大**的数都在一起了，着就好办了，只用枚举每一个“平台”，输出即可。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[1000086];
signed main()
{
   	int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    if(n==1)
    {
        cout<<a[1]<<" "<<1;
        return 0;
    }
    sort(a+1,a+n+1);
    int cnt=1;
    for(int i=2;i<=n;i++)
    {
		if(a[i]==a[i-1]) cnt++;
        else
        {
            cout<<a[i-1]<<" "<<cnt<<endl;
            cnt=1;
        }
        if(i==n)
        {
          	cout<<a[i]<<" "<<cnt<<endl;  
        }
    }
    return 0;
}
```

---

## 作者：Ngo123 (赞：1)

本题我采用的是排序后进行统计的方法。

先将数组从小到大排序。

再正序枚举，对于每个新出现的数，我们从它开始向后扫描，直到一个和它不相等的数为止，扫描过程中统计与当前数相等的数的个数并在扫描结束后输出。

注意在扫描结束后，当前循环变量要跳到合适位置，也就是与当前数字不相等数的下标前一位。

以下是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n,a[N];
int main()
{
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i = 1;i<=n;i++)
    {
        int j = i,cnt = 0;
        while(a[i] == a[j] && j <= n)
        {
            j++;
            cnt++;
        }
        cout << a[i] << ' ' << cnt << '\n';
        i = j-1;
    }
    return 0;
}
```

---

## 作者：Camorgx (赞：1)

本文用的也是STL，但是做了一些可以让程序效率大大提高的优化。具体内容见程序注释，101ms应该是STL里跑的比较快的成绩了 [事实说话](https://www.luogu.org/recordnew/show/12719944)

## 解题思路

拿到这一题我就想到了映射——STL map，建立一个从数值到出现次数的映射

一开始我采用的是sort排序后用C++11 unordered_map存储，但是出了个莫名其妙的bug，它并没有按我存进去的顺序输出。所以我改了普通map，效率肯定会低不少，有dalao知道怎么用unordered_map优化可以评论或私信告诉我

## 代码

```cpp
#include<cstdio>   //compile with -std=c++11
#include<map>
#include<vector>
#include<algorithm>
using namespace std;
inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'1'||ch>'9') {
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') 
		s=s*10+ch-'0',ch=getchar();
	return s*w;
}//标准快读
vector<int> v;
map<int,int> m;
int main() {
	int n;
	n=read();
	for(int i=1;i<=n;i++) v.emplace_back(read()); 
    //C++11新函数，据说常数比push_back()小
	sort(v.begin(),v.end());
    /*重要优化。因为map基于红黑树（平衡树的一种）实现，所以会有一个zig的，
    操作。从小到大排序可以让它跑的更快。实测这句话能让程序的效率提高三分之一*/
	for(int i=v.size()-1;i>=0;--i) m[v[i]]++;
    //不知道为什么++会比+=1跑得快，另外从大到小跑会快些
	for(auto i=m.begin();i!=m.end();i++) //迭代器
		printf("%d %d\n",i->first,i->second);
    //map实际上是个二元组
	return 0;
}
```

~~希望题解大大通过~~

---

## 作者：guobaipeng0 (赞：1)

我的算法没有题解，我就发一个。

分析：此题我用到单调队列，先快速排序，从头到尾累加每一个数，用t作为累加的数字，遇到相同的数字，就用c累加t数字的出现次数，遇到不同的数字，就输出t的个数c，再把第i个数赋值给t，c变为1个。

但要注意：单调队列计算不到最后一个数，所以要在后面加一个不可能出现的数，我用了-9999。

C++代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a[200005],t,c;
int main()
{
    scanf("%d",&n);  //读入自然数个数
    for (i=1; i<=n; i++) scanf("%d",&a[i]); //读入每一个自然数
    sort(a+1,a+n+1); //快排
    c=1; //第一个数开始只有1个
    t=a[1]; //第一个数
    a[n+1]=-9999; //在最后面赋值-9999
    for (i=2; i<=n+1; i++)
    {
        if (a[i]!=a[i-1]) //遇到不同的数字
        {
            printf("%d %d\n",t,c);//就输出t的个数c
            t=a[i];//把第i个数赋值给t
            c=1;//c变为1个。
        } else c++;//遇到相同的数字，就用c累加t数字的出现次数
    }
}
```

---

## 作者：foreverlasting (赞：1)

1. 楼下几篇基本都是哈希优化，我都惊呆了，这题不就是堆排吗？（虽然时间上好像慢一点）
说下思路 一看过去就知道桶排不行（1.5*10^9），转念一想发现存入堆里不是挺好的吗？然后就打了一波堆排（滑稽）。
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q;
long long n,a,b,s;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){scanf("%d",&a);q.push(a);}
    while(!q.empty()){
        s=0;
        b=q.top();
        printf("%d ",b);
        while(b==q.top()&&!q.empty()){
            q.pop();
            s++;
        }
        printf("%d\n",s);
    }
    return 0;
}
```
                                

---

## 作者：yanghaoyu123 (赞：0)

# [P1097 [NOIP2007 提高组] 统计数字](https://www.luogu.com.cn/problem/P1097)

### 思路

我们只需判断一个数组当前项与后一项是否相等即可，如果相等，就将计数变量加一，如果不相等就将计数变量输出并清零。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n+1];
    for (int i=1;i<=n;i++){
        cin>>arr[i];
    }
    int c=0;
    sort(arr+1,arr+n+1);
    for (int i=1;i<=n;i++){
        if (arr[i]!=arr[i+1]){
            cout<<arr[i]<<" "<<c+1<<endl;
            c=0;
        }
        else{
            c++;
        }
    }
    return 0;
}

```

---

## 作者：4041nofoundGeoge (赞：0)

## 题目简述

给你 $n$ 个数（$0<n\le1.5\times10^9$）求每个数出现了几次。

## 思路

首先，我们可以用桶把每一个元素 $a_i$ 记录下来，最后输出即可，但数组要开到 $10^9$，就是以下代码：（时间复杂度 $O(\max\limits_{1\le i\le n}\{a_i\})$）

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1500000000];
int main(){
    int n;
    cin>>n;
    for(int i=1,x;i<=n;i++){
        cin>>x;
        a[x]++;
    }
    for(int i=1;i<=1500000000;i++){
        if(a[i]!=0)cout<<i<<" "<<a[i]<<"\n";
    }
    return 0;
}
```

有趣的是这个代码不会被编译。

我们考虑优化：

得到一个序列，如何去重？我们想到了 STL 中的 set，set 既可以去重又可以排序，像 priority_queue 无法去重。第二个问题就是如何记录，这时候可以用 map 的容器存储。

## 代码

最终代码时间复杂度 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
set<int>st;
map<int,int>mp;
int main(){
    int n;
    cin>>n;
    for(int i=1,x;i<=n;i++){
        cin>>x;
        mp[x]++;
        st.insert(x);
    }
    for(auto i=st.begin();i!=st.end();i++){
    	cout<<*i<<" "<<mp[*i]<<"\n";
	}
    return 0;
}
```

---

## 作者：chenyuan3 (赞：0)

# 题解：P1097 [NOIP2007 提高组] 统计数字

[![](https://img.shields.io/badge/题目-传送门-f39c11)](https://www.luogu.com.cn/problem/P1097)

## 思路

这是一道 `map` 模板练习题。

### `map` 是什么？

`map` 本质上是一棵红黑树。

### 怎么定义 `map`？

``` cpp
map<string, double> sd;
```

定义一棵红黑树，有两个参数：`string` 和 `double`。

### 怎么使用 `map`？

``` cpp
sd["abcdefg"] = 3.14159; // 定义 sd 的“第 "abcdefg" 个元素”为 3.14159。
cin >> sd["hijklmn"]; // 输入 sd 的“第 "hijklmn" 个元素”
cout << sd["opq"]; // 输出 sd 的“第 "opq" 个元素”
```

像一个以 `string`（即参数一）为下标、值为 `double` 类型（即参数二）。

### 如何访问所有已经被使用的元素？

用迭代器。但是和 `vector` 等的迭代器不同，`map` 的迭代器指向一个 `pair`，`first` 为“下标”，`second` 为值。

``` cpp
// 访问输出 sd 的每个元素：
for (map<string, double>::iterator it = sd.begin(); it != st.end(); ++it)
{
    cout << it->first << ' ' << it->second << endl;
}
// 或（C++11 起）：
for (auto p : sd)
{
    cout << p.first << ' ' << p.second << endl;
}
```

### 如何运用到本题中

用一个 `map` 储存桶，每次遇到一个元素就让“第【这个数】的值”加一。

## 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
int n;
map<int, int> mp;
int main()
{
	cin >> n;
	while (n--)
	{
		int x;
		cin >> x;
		mp[x]++; // 让“第【这个数】的值”加一。
	}
	for (map<int, int>::iterator it = mp.begin(); it != mp.end(); ++it)
	{ // 遍历输出。
		cout << it->first << ' ' << it->second << endl;
	}
	return 0;
}
```

---

## 作者：aj_pj (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P1097)

我们用 map 记录次数，set 记录数字。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    map <int,int> a; 
    set <int> b;
    int n,i,q;
    cin>>n;
    for(i=1; i<=n; i++) {
        scanf("%d",&q);
        a[q]++;
        b.insert(q);
    }
    for(set<int>::iterator it=b.begin(); it!=b.end(); it++)
        printf("%d %d\n",*it,a[*it]);
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：模拟，排序。  
我们可以将题目给我们的数从小到大进行排序。然后从第一个数开始找，如果 $a_{i}=a_{i-1}$ 就说明和上一个数相同，计数器加一，否则输出这个数并输出个数即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000005];
signed main()
{
	int n,k;
	cin>>n;
	int ans=1;
	for(int i=0;i<n;i++) cin>>a[i];
	sort(a,a+n);
	a[n]=-10000000;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==a[i-1]) ans++;
		else 
		{
			cout<<a[i-1]<<" "<<ans<<"\n"; 
			ans=1;
		}
	}
	return 0;
} 
```

---

## 作者：Loyal_Soldier (赞：0)

### 思路

这一题我们可以把输入的自然数从小到大排序，然后用一个变量 $t$ 记录当前自然数出现的次数，接着再遍历一遍排序后的数，如果当前数与前一个数相等 $t$ 则增加一，否则我们输出前一个数与 $t+1$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200002],t;
int n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];//输入
	sort(a+1,a+n+1);//将输入的数从小到大排序
	for(int i=2;i<=n+1;i++){
		if(a[i]==a[i-1])//如果当前数字与前一个数字相等
			t++;
		else{
			cout<<a[i-1]<<" "<<t+1<<endl;//输出
			t=0;//输出后t记得清零
		}
	}
	return 0; 
 }
```

---

## 作者：Ak_hjc_using (赞：0)

一道非常简单的题目。

## 思路
这道题的题目意思非常的简洁，输入 $n$ 个数，然后让你求出每个数各有多少个，首先，如果我们直接用桶数组来计算的话，由于每个数不超过 $1.5\times10^9$，所以我们如果直接开数组的话，空间就会爆，所以我们需要考虑优化，我们可以使用一个**超级桶**：`map` 来解决这个问题，我们直接开一个 `map`，然后使用 `auto` 遍历 `map` 输出答案即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
map<int,int> mp;
const int N=1e7+1;
int a[N],cnt[N],x=1,n;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mp[a[i]]++;
	}
	sort(a+1,a+n+1);
	cnt[1]=a[1];
	for(int i=2;i<=n;i++)
	{
		if(a[i]!=a[i-1])
		{
			cnt[++x]=a[i];
		}
	}
	for(int i=1;i<=x;i++)
	{
		cout<<cnt[i]<<' '<<mp[cnt[i]]<<'\n';
	}
	return 0;
}
```

---

## 作者：sjh0626 (赞：0)

## 思路分析
一看，什么东西，再看，原来是 `set` 和 `map`。

我们可以用 `map` 记录次数，`set` 记录数字，然后 `for auto` 一边就行了。
## 代码解析
```cpp
#include<bits/stdc++.h>
using namespace std;
map<long long,int> m;
set<long long>s;
long long n,x;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		m[x]++;
		s.insert(x);
	}
	for(auto x:s){
		cout<<x<<" "<<m[x]<<endl;
	}
}
```

---

## 作者：wanghonghui123 (赞：0)

## 思路

这题就是先把序列用 `set` 去重，然后题目要让我们统计每个数出现的次数，可以用桶做，可以用下标数组，要可以用 STL 里的 `map`。要注意输出时的下标。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
set<int> st;
map<int,int> mp;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		st.insert(t);
		mp[t]++;
	}
	for(auto it:st){
		cout<<it<<' '<<mp[it]<<endl;
	}
	return 0;
}
```

---


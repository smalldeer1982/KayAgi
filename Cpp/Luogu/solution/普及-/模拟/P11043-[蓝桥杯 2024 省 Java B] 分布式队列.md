# [蓝桥杯 2024 省 Java B] 分布式队列

## 题目描述

小蓝最近学习了一种神奇的队列：分布式队列。简单来说，分布式队列包含 $N$ 个节点（编号为 $0$ 至 $N−1$，其中 $0$ 号为主节点），其中只有一个主节点，其余为副节点。主、副节点中都各自维护着一个队列，当往分布式队列中添加元素时都是由主节点完成的（每次都会添加元素到队列尾部）；副节点只负责同步主节点中的队列。可以认为主/副节点中的队列是一个长度无限的一维数组，下标为 $0,1,2,3,\dots$，同时副节点中的元素的同步顺序和主节点中的元素添加顺序保持一致。

由于副本的同步速度各异，因此为了保障数据的一致性，元素添加到主节点后，需要同步到所有的副节点后，才具有可见性。

给出一个分布式队列的运行状态，所有的操作都按输入顺序执行。你需要回答在某个时刻，队列中有多少个元素具有可见性。

## 说明/提示

**【样例说明】**

执行到第一个 query 时，队列内容如下：

- 节点 $0$：$[1,2]$
- 节点 $1$：$[]$
- 节点 $2$：$[]$

两个副节点中都无元素，因此答案为 $0$。
 
执行到第二个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2]$
- 节点 $2$：$[1]$

只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。

执行到第三个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2,1]$
- 节点 $2$：$[1]$

只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。

执行到第四个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2,1]$
- 节点 $2$：$[1,2,1]$

三个元素都被所有节点同步，因此答案为 $3$。

**【评测用例规模与约定】**

设输入的操作数为 $q$。

对于 $30\%$ 的评测用例：$1\leq q \leq 100$。

对于 $100\%$ 的评测用例：$1\leq q\leq 2000$，$1\leq N\leq 10$，$1\leq follower\_id<N$，$0\leq element\leq10^5$。

**数据保证执行同步操作时，$follower\_id$ 号副节点一定缺失元素**。

## 样例 #1

### 输入

```
3
add 1
add 2
query
add 1
sync 1
sync 1
sync 2
query
sync 1
query
sync 2
sync 2
sync 1
query```

### 输出

```
0
1
1
3```

# 题解

## 作者：4041nofoundGeoge (赞：10)

## 题目大意

我看了半小时，发现这道题虽然看起来非常长，实则就可以归纳成几个重点。挑重点讲就是输入格式里的三段话：

> 接下来包含多行输入，每一行包含一个操作，操作类型共有以下三个：add、sync和query，各自的输入格式如下：
>
> 1. `add element`：表示这是一个添加操作，将元素 $element$ 添加到队列中；
> 2. `sync follower_id`：表示这是一个同步操作，$follower\_id$ 号副节点会从主节点中同步下一个自己缺失的元素；
> 3. `query`：查询操作，询问当前分布式队列中有多少个元素具有可见性。

这三段用人话讲就是说：

1. `add element`：表示的是在头结点加入元素。
2. `sync follower_id`：表示同步主节点，其实就是把 `follower_id` 的结点加一。
3. `query`：表示找出结点中最小的副结点代表的个数。

在看一眼题目样例：非常好理解。

## 写代码前的讲究(c++)

1. 尽量不用万能头文件 `bits/stdc++.h` 因为会耗费很多资源。
2. 尽量用 `printf` 和 `scanf` 因为这比 `cout` 和 `cin` 更快。
3. 用 `while` 输入上面的几个操作符，因为你也不知道有多少行。

**最后祝大家 AC 快乐**

```java
//java代码
import java.util.Scanner;  
public class Main {  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        int n = scanner.nextInt();  
        int[] cnt = new int[2000005];  
        while (scanner.hasNext()) {  
            String s = scanner.next();  
            int waste = 0;
            if (s.equals("add")) {  
                waste = scanner.nextInt(); // 读取但忽略  
                cnt[0]++; 
            } else if (s.equals("sync")) {  
                waste = scanner.nextInt();  
                cnt[waste]++;
            } else if (s.equals("query")) {  
                int ans = 2000005; 
                for (int i = 0; i < n; i++) {  
                    ans = Math.min(ans, cnt[i]);
                }  
                System.out.println(ans);  
            }  
        }  
        scanner.close();  //好习惯
    }  
}
```

```cpp
//c++代码
//这道题给的数据很水，所以不开longlong也没事
#include<iostream>
using namespace std;
int cnt[2000005];
int main(){
	int n;
	scanf("%d",&n);
	string s;
	int waste;//当输入add时用的减少资源浪费 
	while(cin>>s){
		if(s=="add"){
			scanf("%d",&waste);
			//因为是结点加东西，所以加了什么无所谓
			cnt[0]++; 
		}
		else if(s=="sync"){
			scanf("%d",&waste);
			cnt[waste]++;//这个废物真正的用处 
		}
		else if(s=="query"){
			//临时抱佛脚找到最短的长度就可以了
			int ans=10000005;
			for(int i=0;i<n;i++)ans=min(ans,cnt[i]);
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：sherry_lover (赞：5)

# P11043 [蓝桥杯 2024 省 Java B] 分布式队列 题解

[题目传送门](https://www.luogu.com.cn/problem/P11043)

## 思路

发现数据范围很小，可以直接模拟。

容易发现每次 `query` 的答案就是几个队列中元素个数的最小值，所以只要维护每个队列的元素个数即可。下面给出每个操作的具体方法。

注：`tot` 数组记录了每个队列里的元素个数。

`add` 操作：由于不用管这个数的具体值是多少，直接 `tot[0]++` 即可。

`sync` 操作：由于每次都只同步一个值，直接 `tot[x]++` 即可。

但有的同学说了，如果当前队列已经完全和队列 $0$ 相等怎么办？我们 `query` 的答案就是几个队列中元素个数的最小值，直接加 $1$ 是不影响最小值的（因为队列 $0$ 的元素个数会小于当前队列的元素个数）。

`query` 操作：直接统计队列元素个数的最小值即可。


Code：
```cpp
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] tot = new int[15];
        String opt;
        int x, minn;

        while (scanner.hasNext()) {
            opt = scanner.next();
            if (opt.equals("add")) {
                x = scanner.nextInt();
                tot[0]++;
            } else if (opt.equals("sync")) {
                x = scanner.nextInt();
                tot[x]++;
            } else {
                minn = 1000000000;
                for (int i = 0; i < n; i++) {
                    minn = Math.min(minn, tot[i]);
                }
                System.out.println(minn);
            }
        }
    }
}
```

---

## 作者：huanglihuan (赞：2)

### 思路

本题仅仅是一个小模拟。

因为 `add` 仅向主队列贡献，所以只需将 $0$ 号结点的长度加一即可。

对于 `sync` 向 $follower\_id$ 号副结点贡献，所以将 $follower\_id$ 号结点加一。

对于询问 `query`，输出从 $0$ 号结点到 $n - 1$ 号结点的最小值即可。

### 代码：

```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 998244353
#define MOD 1000000007
using namespace std;
const int N = 2e6 + 5,maxn = 3e3 + 5;
inline int read ()
{
	int x = 0;
	bool f = 1;
	char c = getchar ();
	while (c < '0' || c > '9') f = (c == '-' ? !f : f),c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48),c = getchar ();
	return f ? x : -x;
}
inline void write (int x)
{
	if (x < 0) putchar ('-'),x = -x;
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
	return ;
}
int Queue [N];
signed main ()
{
	int n;
	cin >> n;
	string opt;
	while (cin >> opt)
	{
		if (opt == "add")
		{
			int element;
			cin >> element;
			Queue [0] ++;
		}
		if (opt == "sync")
		{
			int follower_id;
			cin >> follower_id;
			Queue [follower_id] ++;
		}
		if (opt == "query")
		{
			int ans = 0x7fffffff;
			for (int i = 0;i < n;i ++) ans = min (ans,Queue [i]);
			cout << ans << endl;
		}
	}
	return 0;
}
```

---

## 作者：wht_1218 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11043)

---

由于全程与存入数字都无关，所以可以只记录每个节点的下标。

`add element`：节点 $0$ 总长 $+1$，并且对应下标的个数 $+1$；   
`sync follower_id`：节点 $follower\_id$ 总长 $+1$，对应下标 $+1$（即当前节点总长）；    
`query`：查询目前所有下标有哪些数是每个节点都有的即可。


```java
import java.util.Scanner;

public class Main {
    static int[] now = new int[2007];
    static int cnt = 0;
    static int[] p = new int[20];
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String op;
        while (scanner.hasNext()) {
            op = scanner.next();
            if (op.equals("query")) {
                int ans = 0;
                for (int i = 1; i <= cnt; ++i) {
                    if (now[i] == n) ans++;
                }
                System.out.println(ans);
            } else if (op.equals("add")) {
                int x = scanner.nextInt();
                now[++cnt]++;
            } else if (op.equals("sync")) {
                int x = scanner.nextInt();
                now[++p[x+1]]++;
            }
        }scanner.close();
    }
}
```

---

## 作者：kobebraint (赞：1)

## 题目大意
在主节点的每个元素中，有多少元素被所有的副节点同步了。
## 该怎么做呢
每个副节点都是按顺序从主节点中同步的，所以同步多的肯定已经同步了比他同步少的所有元素。我们只需要求同步最少的节点同步了多少元素就可以了。


---


对于每个`add`，因为不考虑同步了什么元素，所以不管。

对于每个`sync`，题目**数据保证执行同步操作时，$follower\_id$ 号副节点一定缺失元素**，所以每个副节点肯定会同步一个元素，直接让副节点长度增加 $1$。

对于每个`query`，输出长度最短的副节点的长度就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;

long long query[50],n,x,mi;
string op;

int main(){
    cin>>n;
    while(cin>>op){
        if(op=="add"){
            cin>>x;
        }else if(op=="query"){
            cout<<*min_element(query+1,query+n)<<endl;
        }else{
            cin>>x;
            query[x]++;
        }
    }
    return 0;
}
```
输入没有告诉你多少行，记得用`while`。

~~或许是没有压行的最短的代码？~~

---

## 作者：xueshengyi (赞：1)

这个题完全不需要管队列中的元素值，只需要记录每个队列的长度即可。

开一个一维数组记录长度。

当输入为 ```add``` 时，0 号节点的长度加一。

当输入为 ```sync``` 时，设输入的数为 $x$，则 $x$ 号节点的长度加一。

每次询问只需输出队列长度的最小值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i,x,y,...) for(long long i=(x),##__VA_ARGS__;i<=(y);++i)
#define foR(i,x,y,...) for(int i=(x),##__VA_ARGS__;i>=(y);--i)
#define Rep(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<(y);++i)
#define endl '\n'
#define debug(...)
#define debug1(a,i,...) cout<<i<<" "<<a[i]<<endl;
typedef long long ll;
#define fi first
#define se second
#define PII pair<int,int>
#define me(s,x) memset(s,x,sizeof s)
#define pb emplace_back

template<typename T=int>T read(){T x;cin>>x;return x;}
const int mod=998244353;
struct mint{
	int x;mint(int x=0):x(x<0?x+mod:x<mod?x:x-mod){}
	mint(ll y){y%=mod,x=y<0?y+mod:y;}
	mint& operator += (const mint &y){x=x+y.x<mod?x+y.x:x+y.x-mod;return *this;}
	mint& operator -= (const mint &y){x=x<y.x?x-y.x+mod:x-y.x;return *this;}
	mint& operator *= (const mint &y){x=1ll*x*y.x%mod;return *this;}
	friend mint operator + (mint x,const mint &y){return x+y;}
	friend mint operator - (mint x,const mint &y){return x-y;}
	friend mint operator * (mint x,const mint &y){return x*y;}
};mint Pow(mint x,ll y=mod-2){mint z(1);for(;y;y>>=1,x*=x)if(y&1)z*=x;return z;}
int q[15];
void MAIN(){
	int n;
	cin>>n;
	string op;
	int x;
	while(cin>>op){
		if(op=="add"){
			cin>>x;
			q[0]++;
		}
		else if(op=="sync"){
			cin>>x;
			q[x]++;
		}
		else{
		    cout<<*min_element(q,q+n)<<endl;
		} 
	}
}signed main(){
	int t=1;while(t--){
		MAIN();
	}
	return 0;
}
```

---

## 作者：JoeZYQ (赞：0)

### 思路分析
本题非常简单，我们先定义 $a_i$ 为节点 $i$ 维护的队列长度，接着来分三种情况考虑：
- 添加操作，很明显，表示主节点的 $a_0$ 长度应增加。
- 同步操作，与添加操作基本相同，$a$ 数组中表示相对应节点维护的序列的长度应增加。
- 查询操作，根据题意很明显可以看出：一个长度较大的队列 $x$ 与一个长度较小的队列 $y$ 具有包含关系，所以所有队列中的最小长度即为答案。

思路如上，代码就不用我多说了吧！

---


# [GESP202412 六级] 树上游走

## 题目描述

小杨有一棵包含无穷节点的二叉树（即每个节点都有左儿子节点和右儿子节点；除根节点外，每个节点都有父节点），其中根节点的编号为 $1$，对于节点 $i$，其左儿子的编号为 $2\times i$，右儿子的编号为 $2\times i + 1$。

小杨会从节点 $s$ 开始在二叉树上移动，每次移动为以下三种移动方式的任意一种：

- **第 1 种移动方式**：如果当前节点存在父亲节点，向上移动到当前节点的父节点，否则不移动；
- **第 2 种移动方式**：移动到当前节点的左儿子；
- **第 3 种移动方式**：移动到当前节点的右儿子。

小杨想知道移动 $n$ 次后自己所处的节点编号。**数据保证最后所处的节点编号不超过 $10^{12}$**。

## 说明/提示

小杨的移动路线为 $2 \to 1 \to 3 \to 7$。

| 子任务编号 | 数据点占比 |     $n$     |      $s$       |
| :--------: | :--------: | :---------: | :------------: |
|    $1$     |   $20\%$   |  $\leq 10$  |    $\leq 2$    |
|    $2$     |   $20\%$   |  $\leq 50$  |   $\leq 10$    |
|    $3$     |   $60\%$   | $\leq 10^6$ | $\leq 10^{12}$ |


对于全部数据，保证有 $1\leq n\leq 10^6$，$1\leq s\leq 10^{12}$。

## 样例 #1

### 输入

```
3 2
URR```

### 输出

```
7```

# 题解

## 作者：LiuenzeGESP (赞：17)

[题目传送门](https://www.luogu.com.cn/problem/P11375)

本题仅需模拟即可，不需要二叉树的数据结构。第 $2$ 或第 $3$ 种移动后节点的编号变化在题目中已经写得很清楚了。

接下来考虑第 $1$ 种移动后的节点编号变化，我们可以使用倒推法。

假设当前所在节点编号为 $s$，它的父节点编号为 $i$。如果 $s$ 是 $i$ 的左儿子，根据题意可得 $2 \times i =s$，求得 $i=\frac{s}{2}$。

如果 $s$ 是 $i$ 的右儿子，可得 $2 \times i + 1 = s$，求得 $i=\frac{s-1}{2}$（因为此时 $s$ 一定是一个奇数，所以这个式子的值其实就相当于 $\lfloor \frac{s}{2} \rfloor$）。

综上所述，我们只需要用 $s$ 整除以 $2$ 就可以求出其父节点的编号。

还有一点：题目只说**最后**所处的节点编号不超过 $10^{12}$，没说经过的节点编号不超过 $10^{12}$，如果直接写就会喜提 $40$ 分的成绩（因为会爆 long long）。[这是教训](https://www.luogu.com.cn/record/193848048)。

解决方案：一旦编号超过 $10^{12}$，就暂时不进行第 $2$ 或第 $3$ 种移动。记下来，等到进行第 $1$ 种移动时抵消掉。

最后按题意模拟即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//不开long long见祖宗
int n,s,t;
int inf=1e12;
string str;
signed main(){
	cin>>n>>s;
	cin>>str;
	for(int i=0;i<str.size();i++){
		if(str[i]=='U'){
			if(s==1)continue;//根节点没有父节点
			if(t){
				t--;//抵消
				continue;
			}
			s/=2;
		}
		if(str[i]=='L'){
			if(2*s>inf)t++;//不进行移动，记录下来。
			else s*=2;
		}
		else if(str[i]=='R'){
			if(2*s+1>inf)t++;//同上。
			else s=s*2+1;
		}
	}
	cout<<s<<endl;
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：14)

## 算法 1

直接用数字对应节点的编号模拟。假设原节点的下标是 $x$，向右走是 $2x+1$，向左走是 $2x$，向上走是 $\lfloor \dfrac{x}{2}\rfloor$。

这种方式会超过数值存储范围。

## 算法 2

用类似高精度的方式维护走路过程。

维护一个二进制的高精度整数，则向上走是删除最后一位，向左走是在最后添加一个 $0$，向右是添加 $1$。

用一个栈来维护高精度二进制整数，可以在 $O(n)$ 的时间复杂度内解决这个问题。

---

## 作者：jinhangdong (赞：7)

不难发现如果有个走到儿子的，后面是走到父亲的那就抵消了，然后根据最终的序列就可以算出答案了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans;
stack<char>s,s1;
int main()
{
	cin>>n>>ans;
	for(int i=1;i<=n;++i)
	{
		char x;
		cin>>x;
		if(!s.empty()&&x=='U'&&s.top()!='U') s.pop();//如果之前有个走到儿子的，现在是走到父亲的那就抵消了。
		else s.push(x); 
	}
	while(!s.empty())
	{
		s1.push(s.top());
		s.pop();
	}
	while(!s1.empty())
	{
		if(s1.top()=='U') ans=max(1ll,ans/2);
		if(s1.top()=='L') ans=ans*2;
		if(s1.top()=='R') ans=ans*2+1;
		s1.pop();
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：___define___ (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P11375)

## 思路

由于题目中说的是“最后所处的节点编号”，所以模拟的途中还是有可能会超出 `long long` 的范围。

我们知道，解决复杂的计算问题最简单的方法是化简原式后再进行计算。容易发现，按题目中的三种移动方式移动，先向下移动再向上移动之后的位置其实还是原来的位置。

所以我们考虑用字符串模拟栈，只存下对结果有影响的操作，再模拟，就不用怕超出 `long long` 的范围了。

## AC Code

```
#include<bits/stdc++.h>
using namespace std;
long long n,t,n1;
char a;
char s[1000005]; 
signed main(){
	scanf("%lld%lld",&n,&t);
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a=='U'){
			if(s[n1]!='U'&&n1!=0){
				s[n1]='l',n1--;
			}
			else s[++n1]=a;
		}
		else s[++n1]=a;
	}
	for(int i=1;i<=n1;i++)
	{
		if(s[i]=='U')if(t>1) t=(long long)t/2;
		if(s[i]=='L') t=(long long)t*2;
		if(s[i]=='R') t=(long long)t*2+1;
	}
	cout<<t;
	return 0;
}
```

---

## 作者：Programming_Konjac (赞：3)

# 思路
双端队列。

首先，观察可以发现，一个 `L` 或 `R` 就可抵消一个 `U`，所以说可以消除一些操作防止爆 `long long`。

所以创造一个双端队列 $dq$。

每次如果是 `L` 或 `R` 那么从尾部入队。

如果是 `U`，先判断队列是否为空，如果不为空，从尾部弹出一个元素（这里的双端队列相当于栈），否则就再判断 $s$ 是否为 $1$，如果不为 $1$，则 $s=\lfloor\frac{s}{2}\rfloor$。

最后的时候，进行模拟，每次取出队头，然后进行操作，如果是 `L`，则 $s=2s$，否则 $s=2s+1$。

最后输出 $s$。

**记得开 `long long`！**
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
deque<char> dq;
signed main(){
	int n,s;
	cin>>n>>s;
	int cnt=0;
	int cnt2=0;
	while(n--){
		char c;
		cin>>c;
		if(c=='U'){
			if(dq.size()){
				dq.pop_back();
			}
			else if(s!=1){
			    s>>=1ll;
			}
		}
		else{
			dq.push_back(c);
		}
	}
	while(dq.size()){
		if(dq.front()=='L'){
			s<<=1ll;
		}
		else{
			s=(s<<1)+1;
		}
		dq.pop_front();
	}
	cout<<s;
	return 0;
}
```

---

## 作者：woden (赞：3)

对于这道题，我们当然可以用暴力模拟来做，但是在数据非常大的时候会溢出，而用高精又会超时，所以显然我们应使用一定方法控制数据不溢出。

可以想到：每次可能导致溢出的操作都是由向下移动引起的，而要想不溢出只能向上移动，所以本题中向上移动就成为了需要处理的一个部分。

另外，还可以注意到：向上和向下移动的顺序在没有移动到根节点时是不影响最后移动到第几层的。

所以方法如下：用一个变量存储当前数所在的层数，每次移动后层数加一/减一，同时用一个容器存储每次向下移动的左右方向，当向上移动时，如果容器中还有元素，就把上一次加入容器中的元素删除（不管上次是向左还是向右，向上移动后就都无所谓了），否则就将节点编号除以二。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define fst ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define endl '\n'
using namespace std;
int lg2(int x){
	int cnt=0;
	while(x){
		cnt++;
		x>>=1;
	}
	return cnt;
}//计算一开始在第几层 
int n,s;
vector<int>a;
signed main() {
	fst; 
	cin>>n>>s;
	int k=lg2(s);//同上 
	while(n--){
		char ch;
		cin>>ch;
		if(ch=='U'){
			if(k>1){//不在第一层 
				k--;//层数减一 
				if(a.size()){
					a.pop_back();//如果还有元素就移除最后一个元素	
				}else{
					s>>=1;//否则节点编号除以二 
				}
			}
		}else{
			k++;//层数加一 
			a.push_back(ch=='R');//存储左右顺序 
		}
	}
	for(auto i:a){
		s<<=1;//乘二 
		s+=i;//如果向右移就加一 
	}
	cout<<s;
	return 0;
}

```

---


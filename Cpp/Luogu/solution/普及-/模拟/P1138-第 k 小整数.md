# 第 k 小整数

## 题目描述

现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。


## 说明/提示

$n \leq 10000$，$k \leq 1000$，正整数均小于 $30000$。

## 样例 #1

### 输入

```
10 3
1 3 3 7 2 5 1 2 4 6
```

### 输出

```
3
```

# 题解

## 作者：kraylas (赞：184)

# 貌似没有用主席树的，我就来一发主席树题解
看见楼下有用线段树的，其实主席树就是可持久的线段树
普通的线段树是对1到n的区间建树，而主席树是在1到n的区间中只插入某个前缀中的值，由于区间和具有可减性所以主席树用来解决区间第k小的问题

~~一开始看见题目直接就打了一个主席树板子~~

首先树中的节点信息需要记录此区间数的数量，然后是两个儿子节点

```cpp
struct pt{
	int sum;
	pt* ch[2];
};
```
然后建树过程因为如果每个前缀都建一棵树，那么每棵树都是O(n)的空间，总空间为$O(n^2)$彻底变为炸同学

我们发现由于每次增加一个数最多会变$O(logn)$个节点
所以我们可以利用当前树和前一个树的公共区间来建树
总空间$O(nlogn)$

```cpp
typedef pt* ptr;
ptr root[maxn];
int n,k;
void add(ptr last,ptr& th,int v,int l=1,int r=n){
	th=new pt;
	*th=*last;
	th->sum=last->sum+1;
	if(l==r)return ;
	int mid=l+r>>1;
	if(v<=mid)add(last->ch[0],th->ch[0],v,l,mid);
	else add(last->ch[1],th->ch[1],v,mid+1,r);
}
```

建树过程也完了，然后是查询，和楼下线段树dalao一样只不过区间$[l,r]$的节点是$root[r]-root[l-1]$（因为root都是前缀）
所以查询的代码也很好写
```cpp
int getid(ptr le,ptr re,int k,int l=1,int r=n){
	if(l==r)return l;
	int tmp=re->ch[0]->sum-le->ch[0]->sum;
	int mid=l+r>>1;
	if(k<=tmp)return getid(le->ch[0],re->ch[0],k,l,mid);
	else return getid(le->ch[1],re->ch[1],k-tmp,mid+1,r);
}
```
然后就是离散化和去重等等

完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=1e5+5;
struct pt{
	int sum;
	pt* ch[2];
};
typedef pt* ptr;
ptr root[maxn];
int n,k;
void add(ptr last,ptr& th,int v,int l=1,int r=n){
	th=new pt;
	*th=*last;
	th->sum=last->sum+1;
	if(l==r)return ;
	int mid=l+r>>1;
	if(v<=mid)add(last->ch[0],th->ch[0],v,l,mid);
	else add(last->ch[1],th->ch[1],v,mid+1,r);
}
int getid(ptr le,ptr re,int k,int l=1,int r=n){
	if(l==r)return l;
	int tmp=re->ch[0]->sum-le->ch[0]->sum;
	int mid=l+r>>1;
	if(k<=tmp)return getid(le->ch[0],re->ch[0],k,l,mid);
	else return getid(le->ch[1],re->ch[1],k-tmp,mid+1,r);
}
int a[maxn];
int main(){
	ptr& null=root[0];
	null=new pt;
	null->ch[0]=null->ch[1]=null;null->sum=0;
	cin>>n>>k;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	n=unique(a+1,a+1+n)-a-1;
	if(k>n){
		cout<<"NO RESULT"<<endl;
		return 0;
	}
	for(int i=1;i<=n;++i){
		add(root[i-1],root[i],i);
	}
	cout<<a[getid(root[0],root[n],k)]<<endl;
	return 0;
}
```
让我们一起%dalao @[ghj1222](https://www.luogu.org/space/show?uid=13091)

---

## 作者：不会dp退役菜鸡 (赞：161)

一位蒟蒻（就是懒得自己敲代码）在某大佬的帮助下知道了这个神奇的STL函数————unique（就是把数组伪去重，重复的数放在数组末），然后这题就做出来了。。。

看解：



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[10000];//定义变量和数组
int main()
{
    cin>>n>>k;
    for(int i=0;i<n;i++)
    cin>>a[i];
    sort(a,a+n);//快排数组a
    int ans=unique(a,a+n)-a;//给数组a去重，并保留ans=去重后非伪的长度
    if(k<ans)
    cout<<a[k-1]; //如果去重以后k<=ans，则输出对应的数
    else cout<<"NO RESULT";//否则输出 NO RESULT
    return 0;
}
~~//事实证明STL最666（滑稽）~~
```

---

## 作者：潜翎 (赞：70)

翻完了54篇题解，发现大部分都是sort，桶排之类，也有用（根本没必要用的）高端数据结构的。

大部分算法都是O(nlogn)的，桶排如果改“正整数均小于30000”为“正整数在int范围内”就无法使用了。

#### 这里提供一个O(n)算法，且不受数字大小限制。

具体思路就是借鉴快速排序的思想，在快排过程中知道小于基准值的数有多少个，大于基准值的数有多少个，从而选取小于或大于基准值的那**一部分**区间继续递归，平均时间复杂度O(n),最坏时间复杂度O(n方）

如果有的题出题角度刁钻，时间卡的紧也不能用桶排，可别忘了试试这个算法哈~

```
#include <stdio.h>
#include <algorithm>
using namespace std;
int n,tot,k;
int a[10010];
bool f[30010];
int search_k(int l,int r)
{
    if(l==r&&l==k) return a[k];
    if(l<r)
    {
    	//这部分和快排一样的 
        int i=l,j=r,p=a[l];//选左端点为基准数 
        while(i<j)
        {
            while(i<j&&a[j]>p) j--;//从右向左，找到第一个小于基准数的数 
            if(i<j) swap(a[i],a[j]);
            while(i<j&&a[i]<=p) i++;//从左向右，找到第一个大于基准数得数 
            if(i<j) swap(a[i],a[j]);
        }
        a[i]=p;
        if(i==k) return a[k];
        else if(i>k) return search_k(l,i-1);//k在左区间 
        else return search_k(i+1,r);//右区间 
    }
}
int main()
{
    int x;
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(!f[x]){
            a[++tot]=x;//用数组去重，如果数据范围变大，可以用map 
            f[x]=true;
        }
    }
    if(tot<k) {printf("NO RESULT");return 0;}//tot为去重后数字数量 
    printf("%d",search_k(1,tot));
    return 0;
}
```

---

## 作者：Ackoter (赞：69)

本人新手，c++数组计数解题，不喜勿喷

其实直接排序去重就行了

但我不想去重，所以用数组计数

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,b[30010],gs,a;
int main()
{
        cin>>n>>k;//输入n和k
        for(int i=1;i<=n;i++)
        {
                cin>>a;
                b[a]++;//用数组计数的方法把数存进去
        }
        for(int i=1;i<=30000;i++)
        {
                if(b[i]>=1) gs++;//由于相同的数存在一个数组里,所以不用去重
                if(gs==k) {cout<<i;return 0;}//找出第k小，输出
        }
        cout<<"NO RESULT";//否则找不出第k小
        return 0;
}
```

---

## 作者：yummy (赞：45)

提供一种新的思路。

首先，C++有一点好处，可以用sort函数（没说C特别差！）。

题目说，重复的数据不能算上，也就是我们要跳过重复的数，

相当于求原数后面那个数。

废话不多说，上代码：
```cpp
#include<iostream>
#include<algorithm>  //头文件别漏了
using namespace std;
int a[10005]={0},n,k,i;
int main()
{
    cin>>n>>k;
    for(i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1);//排个序
    for(i=1;i<=k&&i<=n;i++)
    {
        if(a[i]==a[i+1])
            k++;
        //与众不同的一步，如果有重复，那么我们就求它后面的数
    }
    if(i>n)
        cout<<"NO RESULT";
    else
        cout<<a[i-1];
    return 0;
}

```

---

## 作者：sycqwq (赞：29)

## 一篇自认为容易懂的题解

你们都用sort，难道忘记了桶排？

这们小的数据量，桶排是无敌的。

只需要记录一下哪个数字出现过，在寻找第k小即可

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k,a[100005],t=0,to[30005];//to为桶，t为统计桶中出现过的数是第几小
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		to[a[i]]=1;//a[i]出现过，放进桶里
	}
	for(int i=1;i<=30005;i++){
		if(to[i]==1)++t;//只要这个数是有值的，那么这个数就是第t小整数
		if(t==k){//如果t==k，就代表这个数是第k小，直接输出i，就可结束程序
			cout<<i;
			return 0;
		}
	}
	cout<<"NO RESULT";
	return 0;
}
```

---

## 作者：兮水XiShui丶 (赞：25)

# 发现自己写的好独特qwq

### dalao们都是用sort啊，stl啊什么的，但我这个蒟蒻完全不懂啊qwq

## 这道题的主要思路就是排序完了之后去重，但是主要问题就在这个去重上，所以我在这里直接用了桶排，排序时我们开一个maxs表示桶排时最大的数是多少，因为是桶排所以我们后来要用到这个数。

## 排序完成之后，我们从1枚举到maxs，入座i这个数的出现次数是0的话，那么我们直接continue，不然的话，我们判断一下，如果目now_k这个数已经等于了k,那么我们只要让k++就好了，不然的话，我们让now_k++，继续往下枚举（now_k:目前已经枚举到了第k大的数）

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#define N 30005

using namespace std;

int n,k,cnt;
int ans[N];

inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') w=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
inline int max(int x,int y){
	return x<y?y:x;
}

int main(void){
	int maxs=-2147483647;
	n=read();k=read();
	for (int i=1;i<=n;++i){
		int kkk=read();
		ans[kkk]++;
		maxs=max(maxs,kkk);
	}
	int now_k=1;
	for (int i=1;i<=maxs;++i){
		if (ans[i]==0) continue;
		if (now_k==k){
			printf ("%d\n",i);
			return 0;
		}
		now_k++;
	}
	puts("NO RESULT");
	return 0;
}
```

---

## 作者：Catalan1906 (赞：20)

**我偏不用sort**

Treap好题啊

看到只有一个人写Treap，而且写的不清楚，那我就来详细地写一下，方便新人学习

---

第(-1)部分：前置知识

二叉查找树：满足左子树的数据都比根节点小，右子树的数据都比根节点大的二叉树

堆：满足子树中的数据均比根节点大的树，或是满足子树中的数据均比根节点小的树

----

第零部分：Treap简介 & 程序开头

Treap=Tree+Heap，又称“树堆”。

这是因为Treap维护的数据满足二叉查找树的性质，而随机权值满足堆的性质。


```
#include <bits/stdc++.h> // 万能头文件

using namespace std;
```

---

第一部分：定义Treap

代码中的root代表平衡树的树根，cnt是存Treap的时候用。

结构体treap存储的是一个节点。结构体中的cnt表示某个数字的出现个数，size表示以这个节点为根的子树的大小，val存的是当前数值，rnd是随机权值。son存左右孩子，下标为0时为左儿子，为1时是右儿子。

```
int cnt, root;

struct treap {
    int cnt, size, val, rnd, son[2];
}t[10010];
```

---

第二部分：维护子树大小

可以模仿线段树的操作（如果你不知道线段树是什么也没关系）。一个以x为根的二叉树的大小，应该等于以它左儿子为根的子树大小+右儿子为根的子树大小+1。为什么要+1呢？因为还有x这个节点嘛，也要算上去。

但在Treap里，+1的地方应该改为+t[x].size。为什么呢？

这是因为Treap把值相同的数据合并成了一个，t[x].size记录了这个数据的出现次数。

x为子树的根节点。以后的代码中x都是这个意思，下面将不再赘述。

```
void upd(int x) {
    t[x].size = t[t[x].son[0]].size + t[t[x].son[1]].size + t[x].cnt;
}

```

----

第三部分：旋转

旋转这个比较难理解

旋转这个操作，就是当Treap不能同时满足二叉查找树和堆的性质时，我们做一次旋转，让Treap的结构改变，但存储的数据依然满足二叉查找树和堆的性质。

这个东西可以手动推一下，大家应该都能理解吧（

代码中d=0时左旋，d=1时右旋。

```
void rotate(int &x, int d) {
    int tmp = t[x].son[d];
    t[x].son[d] = t[tmp].son[d ^ 1];
    t[tmp].son[d ^ 1] = x;
    upd(x); upd(tmp); x = tmp;
}
```

----

第四部分：新建节点

这时候`cnt`就有用处了呢~

看函数内第一行：cnt++，新建出一个空节点

第二行的操作是给这个新建节点它需要维护的数据

第三行是给这个新建节点随机权值

第四行的操作意思是维护的这个数据目前只出现了一次

第五行是因为这个新建节点没有左右子树，所以大小赋值为1

返回值可以让我们知道这个新建节点在t数组中的位置

```
int newnode(int val) {
    cnt++;
    t[cnt].val = val;
    t[cnt].rnd = rand();
    t[cnt].cnt = 1;
    t[cnt].size = 1;
    return cnt;
}
```
---

第五部分：建树

先建一个根节点，维护数据-INF（这里INF取了0x7fffffff，相当于十进制的2147483647，是int最大能存储的值）

再建一个节点，维护数据INF。INF显然比-INF大，所以放在根节点的右儿子处。

最后是建树的标准操作：更新树大小

这里维护的-INF和INF都是虚拟节点，不是我们真正要维护的，为的是其他Treap操作更加方便（似乎也没方便到哪儿去）

```
void build() {
    root = newnode(-0x7fffffff); 
    t[root].son[1] = newnode(0x7fffffff);
    upd(root);
}
```

---

第六部分：插入一个数据

我们可以拿着这个数据从根节点往叶子跑。由于是二叉搜索树，所以不用遍历整个树，同时也不能随便找一个地方就插上了。

我们在往叶子跑的时候，把途中经过的节点的大小都加上1，因为新增了一个元素。

如果我们在往叶子跑的中途遇到了与这个数据相等的节点的时候，我们直接把这个数据的出现次数：节点的cnt值加一。

如果我们的数据跑到了叶子上面，那就……叶上叶（滑稽）。当然，经过的那个叶子结点就变成了非叶子节点。当我们这是后要新建节点的时候，就要进行`newnode`操作新建节点、进行`rotate`操作维护……总之模拟即可。

```
void insert(int &x, int val) {
    if(!x) {
        x = newnode(val);
        return ;
    }
    t[x].size++;
    if(t[x].val == val)t[x].cnt++;
    else {
        int d = t[x].val < val;
        insert(t[x].son[d], val);
        if(t[x].rnd > t[t[x].son[d]].rnd) rotate(x, d);
    }
}
```

----

第七部分：求第k小

求第k小很好说吧

如果k小于或等于左子树大小，答案是左子树中的第k小

否则，如果k小于或等于左子树大小+根节点数据出现次数，则答案为根节点数据

否则，答案为右子树中的第(k-根节点数据出现次数-左子树大小)小

其中还有个细节，因为我们之前的建树操作建的是两个虚拟节点，所以我们查询的时候k要+1，因为第1小被-INF占掉了

递归即可。

```
int kth(int x, int rnk) {
    if(!x) return 0x7fffffff;
    if(rnk <= t[t[x].son[0]].size) {
        return kth(t[x].son[0], rnk);
    } else {
        if(rnk <= t[t[x].son[0]].size + t[x].cnt) {
            return t[x].val;
        } else {
            return kth(t[x].son[1], rnk - t[x].cnt - t[t[x].son[0]].size);
        }
    }
}
```
----

第八部分：主程序的开端以及初始化

Treap的部分基本说完了，现在来看主程序吧。

先定义一个a数组并清零（后面会讲为什么），定义m并初始化为0（后面会讲）

定义n,k和题面意义相同。

还有随机数初始化，搞随机权值用的。

```
int main() {
    int n, k, m = 0, a[30010];
    memset(a, 0, sizeof(a));
    cin >> n >> k;
    build();
    srand(time(NULL));
```
---

第九部分：映射

我之前说过不用sort，不用unique，于是用了把数值映射到数组里的方法。a数组就是做这个用的。

当我们遇到一个数据data，就把a[data]++，表示data这个数出现了一次。这里没有定义data[10010]，省下了一个数组。

数据的取值范围为0~30000，我们暴力跑一边，如果这个数出现了，m++，在平衡树里插入节点。

大家应该都明白了，我们的m存储的是不同的正整数的数量。

如果m<k，因为相同的数只计算一次，就没有第k大，输出"NO RESULT"；否则，直接输出第k大。

```
    for(int i = 1; i <= n; i++) {
        int data;
        cin >> data;
        a[data]++;
    }
    for(int i = 1; i <= 30000; i++) {
        if(a[i]) {
            m++;
            insert(root, i);
        }
    }
    if(m < k) cout << "NO RESULT" << endl;
    else cout << kth(root, k + 1) << endl;
    return 0;
}
```

跑的其实挺快（[34ms, 948kb](https://www.luogu.org/recordnew/show/16231305)）

当然，这道题还不是Treap能做的所有事情。Treap还可以查询一个数的排名、删除一个数、查询一个数的前驱后继……有兴趣的可以做一下[【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369)

这个题解就结束了呢~

---

## 作者：HAO233 (赞：12)

蒟蒻来发题解了。。。  
简单的看了一下似乎没有和我一模一样的~~(废话)~~  
其实大家都知道，这道题最重要的是去重。  

我的去重方法:  
在排序时，如果$a[j]==a[j+1]$那么将$a[j+1]$标为-1。  
其实这个-1是最小值，-INF或INF都可以。  
然后重新遍历，如果$a[i]$为-1，那么$top$++

~~主要是因为前面的大佬们的方法我都不会~~

上代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,k,a[10010],top;
	cin>>n>>k;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(a[j]>a[j+1]){
				swap(a[j],a[j+1]);
			}
			if(a[j]==a[j+1]){
				a[j+1]=-1;
			}
		}
	}
	for(int i=0;i<=n;i++){
		if(a[i]==-1){
			top++;
		}
	}
	cout<<a[top+k];	
    //防抄袭^.^
	return 0;
}
```
然而我用上面的代码交了好多次都是70分，我以为是我的算法出错了，然后去看题解，发现他们都有一个`cout<<"NO RESULT"`于是回去看题目，发现了:
>第kk个最小整数的值；若无解，则输出“NO RESULT”。

emm...  
于是改进代码，AC代码应该加上:
```cpp
if(k<n-top){
		cout<<a[top+k];	
	}else{
		cout<<"NO RESULT";
	}
```
END；

---

## 作者：Mashiro_ylb (赞：10)

#心血来潮用了二分答案

作为一道入门难度题，这道题完全可以用各种排序+去重AC（也可以直接上桶排序）。但是俗话说得好，入门题乐趣多【滑稽】，而且这道题是要找第k小的数，在二分答案的范畴里，于是笔者在对输入数据去重后，直接上二分答案，详情请见代码。

代码如下   (๑•̀ㅂ•́)و✧

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
using namespace std;

int a[10003];  //交换数组
bool b[30007] = {0};  //判重数组
int i, j, m, k, l;

void change(int &a, int &b){int c = a; a = b; b = c;}  //相当于STL中的swap()
void Change(){change(a[i], a[j]); change(i, j);}  //交换指针与数据
void erfen(int start, int end)
{
    i = start;
    j = end;
    while(i != j)  //当指针未重合时
      {
          if(i < j)  //如i指针在j指针左
            {
                  if(a[i] > a[j])
                    Change();
                  else
                    j--;  //j指针左移
          }
        else  //如i指针在j指针右（指针已互换）
          {
              if(a[i] < a[j])
                Change();
              else
                j++;  //j指针右移
          }
      }
    if(i < k) erfen(i + 1, end);  //取右边数组
    else if(i == k)  //若已找到第k小数
      {
          cout << a[i];  //输出答案
      }
      else  erfen(start, i - 1);  //取左边数组
}

int main()
{
    cin >> m >> k;
    for(int i = 1; i <= m; i++)
      {
          scanf("%d", &a[i]);
          if(b[a[i]] == 1) {i--; m--;}  //去重
          else b[a[i]] = 1;
      }
    if(m < k)  //若去重后数组内数据个数小于k，则不符合题意
      {
          cout << "NO RESULT";
          return 0;
      }
    erfen(1, m);  //二分
    return 0;
}
```

---

## 作者：BuXiangJuanLe (赞：7)

貌似题解里还没有用线段树做的？线段树可是神器啊（雾

那么就来一发线段树吧！

**一、建树：** 对于数值范围建树。树中覆盖区间[ l , r ]的节点，其值表示范围在[ l , r ]内的数有几个。
（如果数据很大，可以离散化一下，不过本题数据范围很小，因此直接建立和数据范围大小一样的线段树即可）

**二、查询第k小元素：** 先看当前节点的左儿子的值。如果左儿子的值大于等于k（即**值在左儿子的范围内的数有大于等于k个**），则第k小的数一定在左儿子的范围内，递归处理左儿子。

如果左儿子小于等于k呢？一样的道理，递归处理右儿子，不过要注意，此时的应在右儿子中找的不再是第k小的元素，而是第**( k - 左儿子的值）**小的元素，应该不难理解吧？

详情看代码注释：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std; 
int n, k, a, t[40008], b[10008], maxx, cnt;
//cnt统计总共有几个数，用来判断无解
//t：线段树
//b: 输入时判重用，也在线段树的操作中用于表示某个数出没出现

void build_tree(int p, int l, int r){ //建树 当前建到节点p，对应范围l r
	if(l==r){ //如果是叶子节点
		t[p] = b[l]; //如果l没有出现在原序列中，t[p] = 0也不影响
		return;
	} 
	int mid = (l+r)>>1; //线段树常规操作
	build_tree(p<<1, l, mid);
	build_tree(p<<1|1, mid+1, r);
	t[p] = t[p<<1] + t[p<<1|1];
}

int query(int p, int l, int r, int k){ //处理询问 在p节点对应的l r区间内找第k小
	if(l==r) return l;
	int mid = (l+r)>>1;
	if(t[p<<1] >= k) //如果左儿子元素个数大于等于k
		query(p<<1, l, mid, k);
	else
		query(p<<1|1, mid+1, r, k-t[p<<1]);
}

int main(){
	cin>>n>>k;
	for(int i=1 ; i<=n ; i++){
    	scanf("%d",&a[i]);
    	if(!b[a[i]]){ //统计+去重
    		b[a[i]] = 1;
    		cnt++;
		}
    	maxx = max(maxx, a[i]); //记录最大的数，线段树的大小只需要包含最大的数就行
	}
	if(k<=0 || k>cnt){ //询问的第k大不存在
		cout<<"NO RESULT"<<endl;
		return 0;
	}
	build_tree(1, 1, maxx);
	cout<<query(1, 1, maxx, k)<<endl;
	return 0;
}
```
蒟蒻第一次认真写题解Orz

---

## 作者：AK_Zero (赞：7)

~~~~**这题蒟蒻还是做出来了······~~~~（dalao勿喷）~~

这道题的思路就是先利用数组计数去重，然后排序，输出第k小整数或NO RESULT**

请看程序，本蒟蒻在程序中已标注想法（dalao勿喷）

         
```cpp
#include<iostream>
#include<algorithm>//蒟蒻文件头······ 
using namespace std;
int n,k,i,a,ma,gs; 
int zs[1000000],dn[1000000];//事实证明，变量和数组千万不要一起定义······ 
int main()
{
    ma=-1; 
    cin>>n>>k;//输入有几个数和第几小的数 
    for(i=1; i<=n; i++) //输入数据 
    {
        cin>>a;//同上 
        if(a>ma) ma=a;//由于题目说相同大小的整数只计算一次，所以我们要去重 
        zs[a]++;//大家是否做过“明明的随机数”，那道题也是要去重。可这道题不一样，它还要把去重完的数列储存起来。所以我们可以使用数组计数的的方法。这里，我们下个循环再解释······(手动滑稽)  }
    for(i=1; i<=ma; i++)//当当当当，第二个循环来了！！！ 
    {
        if(zs[i]>0) //前面我们已经做好了数组计数，出现过的数字数量都已储存。所以······只要我们判断一个下标中的数字不为0，那我们就视为它这个数出现过。那么······请看下句
        {
            gs++;//我们后面还要排序，所以我们要保证它的新数组的储存是连续的，所以我们存一个才更新一次下标（即为+1） 
            dn[gs]=i;//然后将那个数储存 
        }
    }
    sort(dn+1,dn+1+gs);    //c++快排，要记住你排序的数组存的数字个数是前面更新下标的变量（就是gs） 
    if(dn[k]==0) cout<<"NO RESULT";//因为不会有一个数为0，所以只要第k下标里的数字为0，就视为它无解 
    else
    cout<<dn[k];//否则就输出第k小的数 
    return 0;//求通过！！！谢谢！！！ 
}
```

---

## 作者：P500 (赞：5)

来一发划分树的题解

**划分树是一种基于线段树的数据结构。主要用于快速求出(在log(n)的时间复杂度内）序列区间的第k大值。**


------------

建树的过程比较简单，对于区间[l,r]，

首先通过对原数组的排序找到这个区间的中位数a[mid]，

小于a[mid]的数划入他的左子树[l,mid-1]，
大于它的划入右子树[mid,r]。

同时，对于第i个数，记录在[l,i]区间内有多少数被划入左子树。

最后，对它的左子树区间[l,mid-1]和右子树区间[mid,r]递归的继续建树就可以了。




------------

查找的过程中主要问题就是确定将要查找的区间。这个问题有些**麻烦**。QwQ

在大区间[st,ed]中找小区间[s,e]中的第k元素:

我们的想法是，先判断[s,e]中第k元素在[st,ed]的哪个子树中，然后找出对应的小区间和k，递归的进行查找，直到小区间的s=e为止。

那如何解决这个问题呢？这时候前面记录的进入左子树的元素个数就派上用场了。

通过之前的记录可以知道，在区间[st,s-1]中有el[h,s-1]进入左子树，记它为l。同理区间[st,e]中有el[h,e]个数进去左子树，记它为r。

所以，我们知道区间小区间[s,e]中有(r-l)个数进入左子树。那么如果(r-l)>=k，那么就在左子树中继续查找，否则就在右子树中继续查找。

于是递归继续查找直到s=e即可。


------------

上代码：


```cpp
#include <iostream>
using namespace std;
int a[10001],n=0;
int sorted[10001],tree[15][10001],to_left[15][10001];
bool t[30001];
int read(){
	int num,k;
	cin>>num>>k;
	for(int i=1,j;i<=num;i++){
		cin>>j;
		if(t[j]==0) a[++n]=j,t[j]=1;
	}
	return k;
}

void build(int dep,int l,int r){
	if(l==r) return;
	
	int mid=(l+r)>>1;
	int same=mid-l+1;
	for(int i=l;i<=r;i++) if(tree[dep][i]<sorted[mid]) same--;
	int l1=l,l2=mid+1;
	for(int i=l;i<=r;i++){
		if(tree[dep][i]<sorted[mid]) tree[dep+1][l1++]=tree[dep][i]; else
		if(tree[dep][i]==sorted[mid]&&same>0)tree[dep+1][l1++]=tree[dep][i],same--;
		else tree[dep+1][l2++]=tree[dep][i];
		to_left[dep][i]=to_left[dep][l-1]+l1-l;
	}
	build(dep+1,l,mid); build(dep+1,mid+1,r);
}

int qu(int dep,int l,int r,int x,int y,int k){
	if(l==r) return tree[dep][l];
	
	int mid=(l+r)>>1;
	int cnt=to_left[dep][y]-to_left[dep][x-1];
	if(cnt>=k){
		int newx=l+to_left[dep][x-1]-to_left[dep][l-1];
		int newy=newx+cnt-1;
		return qu(dep+1,l,mid,newx,newy,k);
	}
	else{
		int newy=y+to_left[dep][r]-to_left[dep][y];
		int newx=newy-(y-x-cnt);
		return qu(dep+1,mid+1,r,newx,newy,k-cnt);
	}
}

void solve(int k){
	if(k<=0||k>n){ cout<<"NO RESULT"; return; } 
	for(int i=1,j=0;i<=30000;i++)	if(t[i]) sorted[++j]=i;
	for(int i=1;i<=n;i++) tree[0][i]=a[i];
	build(0,1,n);
	cout<<qu(0,1,n,1,n,k);
	return;
}
int main(){
	int k=read();
	solve(k);
	return 0;
}
```

---

## 作者：EAT_NH4HCO3 (赞：5)

##这道题的要点就是


##去重去重去重


##所以很多人都用到了桶排


##但你们难道没有想到我们大C++的STL库了吗？


##STL大法好！！！


##个人认为set的时间复杂度是很低的，所以用了


```cpp
//P1138
#include<iostream>
#include<set>//集合，就是数学里那个集合，本身就能自动去重和升序排序
using namespace std;
set<int> num;
int main()
{
    ios::sync_with_stdio(false);
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        int temp=0;
        cin>>temp;
        num.insert(temp);//insert函数把输入的内容打入set中
    }
    if(num.size()<k)
    {
        cout<<"NO RESULT";//如果集合内元素数量小于k，说明结果不存在
    }
    else
    {
        int s=0;
        for(set<int>::iterator it=num.begin();it!=num.end();it++)//it是迭代器，从小到大遍历
        {
            if(*it)s++;//如果在集合内该元素存在，计数器++
            if(s==k)//当s=t，这就是第k小的数，输出
            {
                cout<<*it;//迭代器和指针是相似的，要用*调用
                break;//找到了就不用继续了，退出循环
            }
        }
    }
    return 0;//结束
}
```
~~应该没问题~~


---

## 作者：MscWood (赞：4)

看了下题解

好多dalao用了二分、树 还有桶排序

感觉自己的代码比较简单，理解也方便，就发一个题解


主要方法就是：

1、先快排一遍

2、while循环中用一个int类型来记录一共找到了多少个不同的数

3、当找到第k大的时候就输出并结束程序

4、如果跳出了循环说明找不到，就输出NO


以下是蒟蒻的代码：




```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>      //sort必需调用的头文件 
using namespace std;
int a[10010],n,k;   //数据定义 
int main()
{
    int i=1,num=0;     //i是后面循环记录下标用的，num表示找到了第num小的数 
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);          //读入后快排 
    while(i<=n)               //下标没有超过，就循环 
    {
        if(a[i]!=a[i-1]) num++;   //如果第i个位置上的数不等于i-1上的就找到了第num++大的数
                                  //（因为已经快排了，只要不等于就一定是大于） 
        if(num==k)                //找到了就输出 
        {
            cout<<a[i];
            return 0;             //不加此句后果很严重（程序不会结束，在最后就会在输出一个NO RESULT） 
        }
        i++;
    }
    cout<<"NO RESULT";            //如果循环完还没有找到，说明没有，输出NO 
    return 0;
}
```

---

## 作者：qwq2003 (赞：4)

照例先看一下题目说明：
![](https://cdn.luogu.com.cn/upload/pic/25740.png)

废话一会再说，先上代码：
```cpp
#include <bits/stdc++.h>   //万能头文件
using namespace std;
int main()
{
    int n,k,i;
    int a[10001];
    for(i=0;i<=10001;i++)
        a[i]=0;     //保险起见最好归零
    cin>>n>>k;    //输入第一行数据
    for(i=0;i<n;i++)    //循环读入数据
        cin>>a[i];
    sort(a,a+n);    //排序 
    int sum=unique(a,a+n)-a;   //unique是伪去重函数，他会将重复的数字放在数组末尾
    if(k<sum)   //输出答案
        cout<<a[k-1]<<endl;   
    else
        cout<<"NO RESULT"<<endl;
    return 0;
}
```
这里我们来讲解一下大括号的用法和取舍。

首先科普一下困扰无数程序员的else虚悬问题。

下面奉上小明同学的错误示范：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a=1,b=2;
    if(a>0)
        if(a+b!=3)
            cout<<"TEST"<<endl;   
    else
            cout<<"test"<<endl;
    return 0;
}
```
  按照我们阅读代码的习惯，会将else和第一个if配对，理解成这样:
  
  “如果变量a大于0，那么判断变量a加变量b是否不等于3，如果成立则输出TEST。如果变量a小于或等于0输出test。”

照这么理解，这段代码应该**没有输出**。

  但是C++解释器（例如Dev-C++和Visual c++之类的运行C++代码的工具）有这么一个规定：
  
 _**  else始终与同一对括号内最近的未匹配的if结合。** _ 
  
所以C++解释器自认而然的会将这段代码理解成这样：

“如果变量a大于0，那么判断变量a加变量b是否不等于3，如果成立则输出TEST，否则输出test。”

照编译器这么理解，这段代码应该输出TEST，和我们的想法背道而驰。

那么怎样预防else虚悬问题呢？很简单：

![](https://cdn.luogu.com.cn/upload/pic/25827.png)

没错！就是我们最常用的大括号！

我们把小明同学的代码调整一下，使它能达到我们想要的效果：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a=1,b=2;
    if(a>0)
    {
    	if(a+b!=3)
            cout<<"TEST"<<endl;  
    }
    else
    {
    	cout<<"test"<<endl;
    }
    return 0;
}
```

至此小明同学的事儿完美的搞定了，现在讲一下大括号的取舍。
直接进入正题：

**“在while(),do-while(),for(),if(),else,之类的东东，如果只有一行代码，可以省略大括号。”**

也就是说，像这样的代码：
```cpp
int i=0;a[10001];
for(i=0;i<=10001;i++)
{
	a[i]=0;
}
```
可以简化成这样：
```cpp
int i=0;a[10001];
for(i=0;i<=10001;i++)
	a[i]=0;
```

但是一定要预防猝不及防的else虚悬问题啊！！！！！！

好了，本期题解到此结束。

---

## 作者：wjy666 (赞：4)

有一天，我闲来无事(闲的蛋疼)，在洛谷里随意翻找着题目

这时我看到了一道叫第k小整数的水题

我:"这题好水啊......为什么不用红黑树呢？"(哇，听起来好高端的样子)

<以上为废话>

好吧，实际上只是map而已

map也可以起到一个类似于桶排的作用，但是可以动态分配内存

虽然用来做这题是杀鸡用牛刀了，但是学一种新方法也是不错的

如果用map的话，别说3万的整数范围了，就算是3万亿也是毫无问题的！

希望新人朋友们能从这篇题解开始，深入学习强大的stl和map

```cpp
#include<cstdio>
#include<map> //头文件不可少
#define For(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
int read(){//这只是快速读入
    int l=1,x=0; char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')  ch=getchar();
    if (ch=='-') l=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*l;
}
map<int,int> mp; //map定义，很简单对吧
int main(){
    int n=read(),s=0,m=read();
    For(i,1,n) mp[read()]=1; //读入并去重，和桶排差不多
    map<int,int>::iterator it; //这是迭代器，刚开始接触可能会觉得复杂，多用几次就会了
    for(it=mp.begin();it!=mp.end();it++){ //从头开始遍历map，内部是从小到大排序好的
        s++; 
        if (s==m) {printf("%d\n",it->first); return 0;} //到第k小了就输出结果退出程序
    }
    printf("NO RESULT\n"); //到了这一步就可以确定无解了
    return 0; //结束了~  stl大法好！
}
```

---

## 作者：Smallbasic (赞：3)

### 一道“显而易见”的二叉排序
##### 先构造一棵二叉树，要加入的数如果比当前节点小，就在左边，大就在右边。
```
/*
like:
             10
            /  \               
           7   11 
          / \   \
         6   8   15
                /            
               13
*/
```

##### 因为题目求第k小，所及加入的时候一旦遇到一样的数就立刻return
##### 插入代码：
```cpp
// insert
void ins(int k){
	BT* a=new BT;
	a->val=k;
	BT* cur=this;
	while(true){
		if(k<cur->val){
			if(cur->left==NULL){
				cur->left=a;
				break;
			}
			cur=cur->left;
		}else if(k>cur->val){
			if(cur->right==NULL){
				cur->right=a;
				break;
			}
			cur=cur->right;
		}else{
			return ;
		}
	}
	return ;
}
```
##### 建好树后开一个栈f来存储排序好的数。top就去重后元素的个数。栈应该都会写，就直接上代码：
```cpp
struct st{
    int a[10001];
	int top=0;
	void ins(int b){
		++top;
		a[top]=b;
	}	
	void pop(){
		--top;
	}
	int numk(int k){ //第k小的元素，k>top就返回-1
		if(k>top){
			return -1;
		}
		return a[k];
	}
};
```
##### 然后就是中序遍历模板，把printf改成f.ins就可以了。（f为站名）
```cpp
void sort(){
	BT* cur=this;
	if(cur->left!=NULL){
		cur->left->sort();
	}
	f.ins(cur->val);
	if(cur->right!=NULL){
		cur->right->sort();
	}
	return ;
}
```
##### 最后只需要输出栈中第k个数，唯一要注意的是加个k>top的特判即可。
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct st{
   int a[10001];
	int top=0;
	void ins(int b){
		++top;
		a[top]=b;
	}
	int numk(int k){
		if(k>top){
			return -1;
		}
		return a[k];
	}
};
st f;
struct BT{
	int  val;
	BT* left=NULL;
	BT* right=NULL;
	// insert
	void ins(int k){
		BT* a=new BT;
		a->val=k;
		BT* cur=this;
		while(true){
			if(k<cur->val){
				if(cur->left==NULL){
					cur->left=a;
					break;
				}
				cur=cur->left;
			}else if(k>cur->val){
				if(cur->right==NULL){
					cur->right=a;
					break;
				}
				cur=cur->right;
			}else{
				return ;
			}
		}
		return ;
	}
	//print 调试用，请无视  
	void print(){
		printf("%d ",this->val);
		if(this->left!=NULL){
			this->left->print();
		}
		if(this->right!=NULL){
			this->right->print();
		}
		return ;
	}
	//sort
	void sort(){
		BT* cur=this;
		if(cur->left!=NULL){
			cur->left->sort();
		}
		f.ins(cur->val);
		if(cur->right!=NULL){
			cur->right->sort();
		}
		return ;
	}
};
int main(){
	int n,k;
	scanf("%d%d",&n,&k);
	BT* root=new BT;
	int d;
	scanf("%d",&d);
	root->val=d;
	for(int i=2;i<=n;i++){
		scanf("%d",&d);
		root->ins(d);
	}
	root->sort();
	int m=f.numk(k);
	if(m==-1){
		cout<<"NO RESULT";
		return 0;
	}
   printf("%d",m);
	return 0;
}
```
~~求教dalao，为什么正常的代码放到题解中就会出现许多奇怪的空格使码风极度混乱？？~~

---

## 作者：ViXpop (赞：3)

#### 弱弱的蒟蒻来发题解了

这题本蒟蒻乍一看就很容易想到sort从小到大排序一遍找第k个值就行了

但这里有一个非常非常小的坑

是的 就是去重

注意一下去重这题就轻松过去了

### 下面是正常思路的代码

```
#include <bits/stdc++.h>
#define N 111111
using namespace std;
int n,m,sum=0;
int a[N];
int b[N];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        if(a[i]==a[i+1])
            continue;
        b[++sum]=a[i];
    }
    if(b[m]==0)
    {
        cout<<"NO RESULT";
        return 0;
    }
    cout<<b[m];
    return 0;
}

```
但是看到题解里的各路神犇开发了不少新奇做法，所以本蒟蒻就又写了一个平衡树

为什么会想到平衡树呢~~当然是听其他神犇说的~~，因为多个相同的值在树中只占用一个节点，就可以省略去重的操作了qwq

下面是平衡树的代码

### 代码里有注释(由于没有压行导致代码不仅长而且丑）

```
#include<bits/stdc++.h>
#define ll long long
#define INF 1<<30 
#define FOR(i,l,r) for(register int i=l;i<=r;i++)

using namespace std;

const int N=10001;
int a[N],child[N][2],tot,fa[N],root,num[N],ct[N];
int n,m,flag;
//a[i]表示i节点上存的数字
//child[i][0]为i节点的左儿子序号 child[i][1]为i节点的右儿子序号
//tot表示有多少个不同的数字
//fa[i]表示i节点的父节点
//root为根的序号
//num[i]表示i出现的次数
//ct[i]表示以i为根有多少个子节点 
int _search(int x,int w)
{
    if(a[x]==w)
        return x;
    while(a[x]!=w)
    {
        if(a[x]>w)
        {
            if(child[x][0])
                x=child[x][0];
            else break;
        }
        if(a[x]==w)
            return x;
        if(a[x]<w)
        {
            if(child[x][1])
                x=child[x][1];
            else break;
        }
    }
    return x;
}
void _rotate(int x)
{
    int y=fa[x];
    int z=fa[y];
    if(child[z][0]==y)
        child[z][0]=x;
    else 
        child[z][1]=x;
    fa[x]=z;
    int w;
    if(child[y][0]==x)
        w=0;
    else
        w=1;
    child[y][w]=child[x][w^1];
    fa[child[x][w^1]]=y;
    child[x][w^1]=y;
    fa[y]=x;
    ct[x]=ct[child[x][0]]+ct[child[x][1]]+num[x];
    ct[y]=ct[child[y][0]]+ct[child[y][1]]+num[y];
}
void splay(int x)//splay不多说 
{
    while(fa[x])
    {
        int y=fa[x];
        int z=fa[y];
        if(z==0)
            _rotate(x);
        else 
        {
            if((child[z][0]==y)^(child[y][0]==x))
                _rotate(x);
            else 
                _rotate(y);
            _rotate(x);
        }
    }
    root=x;
}
int _quary(int x)//查询 
{
    int k=root;
    while(!(x>=ct[child[k][0]]+1&&x<=ct[child[k][0]]+num[k])&&k)
    {
        if(x>=ct[child[k][0]]+num[k])
        {
            x-=ct[child[k][0]]+num[k];
            k=child[k][1];
        }
        else 
            k=child[k][0];
    }
    return a[k];
}
void add(int x)//添加数字到树中 
{
    if(!tot)
    {
        tot=1;root=1;fa[1]=0;ct[1]=1;num[1]=1;a[1]=x;
        return ;
    }
    int k=_search(root,x);
    int node=0;
    if(a[k]==x)
        node=k;
    else
    {
        ++tot;
        a[tot]=x;
        num[tot]=1;
        ct[tot]=1;
        fa[tot]=k;
        if(x<a[k])
            child[k][0]=tot;
        else
            child[k][1]=tot;
    }
    while(k)
    {
        ct[k]++;
        k=fa[k];
    }
    if(node)
        splay(node);
        else
            splay(tot);
}
int main()
{
    scanf("%d%d",&n,&m);
    FOR(i,1,n)
    {
        int l;
        scanf("%d",&l);//每输入一个数就把它加入到树中去 
        add(l);
    }
    flag=_quary(m);//查询从小到大排名为m的数字 
    if(flag)
        printf("%d",flag);//存在就输出 
    else
        printf("NO RESULT");//不存在就NO RESULT 
    return 0;
}
```
### 最后日常膜一下[神犇大大](https://www.luogu.org/space/show?uid=122988)了

求管理员通过谢谢qwq

---

## 作者：williamllk (赞：3)

## 这是一道水题

这道题可以用桶排序的思路，把输进去的数都存在相应的数组里

[cqz巨佬](https://www.luogu.com.cn/problem/P1138)

首先，我们要建一个很重要的数组 ans[30001]

这道题可以分为三个部分


------------
No.1  输入
```cpp
for(int i=1;i<=n;i++){
	cin>>a;
	ans[a]=1;
}
```
No.2  判断
```cpp
for(int i=1;i<=30001;i++){
	if(ans[i]==1) num++;
	if(num==k){
		cout<<i;
		flag=1;
		break;
	}
}
```
那么我们为什么要建一个叫FLAG的数组，因为如果本题不成立，要输出NO RESULT

这也就是最后一个部分，是否成立
```cpp
if(flag==0) cout<<"NO RESULT";
```


------------
整体思路就这样了，最后给一下AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[30001],n,k,a,num,flag;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a;
		ans[a]=1;
	}
	for(int i=1;i<=30001;i++){
		if(ans[i]==1) num++;
		if(num==k){
			cout<<i;
			flag=1;
			break;
		}
	}
	if(flag==0) cout<<"NO RESULT";
	return 0;
}
```
最后祝某某某新婚快乐(划去）！！！
求赞！

---

## 作者：引领天下 (赞：3)

做法：

首先，读入 $n$ 和 $k$；

然后，读入 $n$ 个整数；

读入时去重。

去完了就排序。

然后输出。

代码：

```cpp
#include <bits/stdc++.h>//包含所有头文件的头文件
using namespace std;
int n,a[10005],i,k;//不解释
bool s[30005];//用来去重的桶
int main(void){
    scanf ("%d%d",&n,&k);
    for (;i<n;i++){
        scanf ("%d",&a[i]);//读入
        if (s[a[i]])n--,i--;//如果出现过了，总数--，i--（重读a[i]）
        else s[a[i]]=1;//不然标记一下
}//读完了就去重完了
//这就是我的和别的调解不同的地方：我用桶去重。

    sort (a,a+n);//排序！

    if (n<k||k<=0)printf ("NO RESULT");//坑人的#3、5、8

    else printf ("%d",a[k-1]);//因为我是0下标，所以k要-1

}
```

---

## 作者：pantw (赞：3)

抱着我的Treap鏼鏼发抖emmm

这可是一道Treap吼题哇！


```cpp
#include <cstdio>
#include <cstdlib>
#define maxn (1 << 23) + 10
#define INF 0x3F3F3F3F
bool used[maxn];
int siz = 0;

int R() {
    int ret = 0;
    while(!ret || used[ret]) ret = rand() & 0x7FFFFF;
    return ret;
}

struct Node {
    int v, r, s, c;
    Node* ch[2];
    Node(int v = 0);
} null, *root = &null;

Node::Node(int v): v(v), r(R()), s(0), c(0) {ch[0] = ch[1] = &null;}

void maintain(Node* x) { x->s = x->ch[0]->s + x->ch[1]->s + x->c; }

void rotate(Node* &x, int t) {
    Node* o = x->ch[t^1]; 
    x->ch[t^1] = o->ch[t];
    o->ch[t] = x;
    maintain(x);
    maintain(o);
    x = o;
}

void insert(Node* &x, int v) {
    if(x->v == v) {
        return;
    }
    int d;
    if(x == &null) x = new Node(v), x->s = 1, x->c = 1, siz++;
    else {
        insert(x->ch[d = v < x->v ? 0 : 1], v);
        if(x->ch[d]->r > x->r) rotate(x, d ^ 1);
    }
    maintain(x);
    return;
}

void remove(Node* &x, int v) {
    siz--;
    Node* u = x;
    if(x == &null) return;
    if(x->v == v) {
        if(x->c == 1) {
            if(x->ch[0] == &null) x = x->ch[1], delete u;
            else if(x->ch[1] == &null) x = x->ch[0], delete u;
            else {
                int d = x->ch[0]->r > x->ch[1]->r ? 1 : 0;
                rotate(x, d);
                remove(x->ch[d], v);
            }
        }
        else x->c--;
    }
    else remove(x->ch[v < x->v ? 0 : 1], v);
    if(x != &null) maintain(x);
}

int kth(Node* x, int k) {
    int l = x->ch[0]->s;
    if(k <= l) return kth(x->ch[0], k);
    else if(k > l + 1) return kth(x->ch[1], k - l - 1);
    else return x->v;
}

int rank(int v) {
    Node *x = root;
    int ret = 1;
    while(x != &null && x->v != v) {
        int ch = v < x->v ? 0 : 1;
        if(x->ch[ch] == &null) break;
        if(ch == 1) ret += x->s - x->ch[1]->s;
        x = x->ch[ch];
    }
    ret += x->ch[0]->s;
    return ret;
}

int get(Node* x, int t) {
    while(x->ch[t] != &null) x = x->ch[t];
    return x->v;
}

int ps(int v, int t) {
    Node *x = root, *las;
    while(x != &null && x->v != v) {
        int ch = v < x->v ? 0 : 1;
        if(ch == (t ^ 1)) las = x;
        x = x->ch[ch];
    }
    if(x -> ch[t] != &null) return get(x->ch[t], t ^ 1);
    else return las->v;
}

int main() {
    srand(20180118);
    int n, k;
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i++) {
        int v;
        scanf("%d", &v);
        insert(root, v);
    }
    if(k <= siz) printf("%d\n", kth(root, k));
    else puts("NO RESULT");
    return 0;
}
```

---

## 作者：小菜鸟 (赞：2)

~~贡献分掉了来水题解.jpg~~

我们知道，有一个与快排相似的“快速次序选择”算法。

大概流程如下：

以某个数为中间点将序列分为两半

检查中间点的排名

若大于k，对左半区间递归

小于k，对右半区间递归

---

很简单对不对？

复杂度显然$O(n)$，最坏$O(n^2)$

实现也不难，跟平衡树的kth差不多

---

然而STL帮你写好了（

`std::nth_element(first,nth,last)`函数，帮你把`[first,last)`中的元素分为小于/大于等于nth的两部分（

然后nth位置上就是正确答案了（

---

```cpp
#include<cstdio>
#include<algorithm>

int n,k,tot,a[10005];

bool vis[30005];

int main()
{
    scanf("%d%d",&n,&k);
    while(n--)
    {
        int x;
        scanf("%d",&x);
        if(!vis[x])
        {
            a[tot++]=x;
            vis[x]=1;
        }
    }
    if(k>tot)
    {
        puts("NO RESULT");
        return 0;
    }
    std::nth_element(a,a+k-1,a+tot);
    printf("%d",a[k-1]);
}
```

注意STL左闭右开，所以排名从0开始（

---

## 作者：Goashore (赞：2)

# 老实人（蒟蒻）来发题解了！
## 题目描述：

现有n个正整数，n≤10000，要求出n个正整数中的第k个最小整数（相同大小的整数只计算一次），k≤1000，正整数均小于30000。

输入格式
第一行为n和k; 第二行开始为n个正整数的值，整数间用空格隔开。

输出格式
第k个最小整数的值；若无解，则输出“NO RESULT”。

输入输出样例

输入 #1 
10 3 

1 3 3 7 2 5 1 2 4 6

输出 #1

3

说明/提示
n≤10000n≤10000

### 这道题就是有几点需要注意的：

1.去重，将每个重复的数值都将它赋值成超出题目数据范围的数（>30000 ）。

2.排序，使用c++STL库中的sort。

3.如果要求输出的k大于去重后剩下的数的数量则输出“NO RESULT”

### 上代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int n,m,ans;
	cin>>n>>m;ans=n;
	int a[10000];
	for(int i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(a[i]==a[i+1])
		{
			a[i]=30010;
			ans--;
		}
	}
	sort(a+1,a+n+1);
	if(m>ans)
	{
		cout<<"NO RESULT";
		return 0;
	}
	cout<<a[m];
}
```


---

## 作者：北纬30° (赞：2)

当看到其他大佬使用排序又或是什么树啊的，我想，我的机会来了。我感觉这道题和排序没有关系啊，大概意思就是读一个数进来，用数组将这个数标为存在，即1，别忘了初始值设为0，然后找到最大的数，然后直接从1到max，只要这个数存在，就计数加一，一直加到k，输出这个数，时间也绝对够用。

#风云再起的第一篇题解#
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<sstream>
using namespace std;
int main()
{
    int n,k,g,s=0,max=0;
    int a[10002]={0};
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
    	cin>>g;
    	a[g]=1;
    	if(g>max) max=g;
	}
	for(int i=1;i<=max;i++)
		if(a[i]==1)
		{
			s++;
			if(s==k) 
			{
			    cout<<i;
			    return 0;
		    }
		}
	cout<<"NO RESULT"; 
    return 0;
}

---

## 作者：hsfzLZH1 (赞：2)

看了看各位大神的代码，发现有用sort的，有用桶排的，所以我来发一波堆/优先队列的代码。

因为只需要询问第k大的数，所以相当于只需要执行k次top或pop操作。时间复杂度O(K logN)（top和pop操作的时间复杂度都是O(log N)）

注意判重！！！

代码：（本人亲测0ms AC）

STL模板priority\_queue：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue<int,vector<int>,greater<int> >q;
int n,k,a,ans=0;
bool tf[30010];
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++){scanf("%d",&a);if(!tf[a])q.push(a),ans++;tf[a]=true;}
    if(ans<k){printf("NO RESULT\n");return 0;}
    k--;while(k--)q.pop();
    printf("%d\n",q.top());
    return 0;
}
```
大根堆模板（存储负数）：

```cpp
#include<iostream>
using namespace std;
int n,s[100005]={0},k,cur=1;
bool tf[30010]={}; 
void ShiftDown(int s[],int i,int w)//向下调整
{
    int p=i,j,t=s[p];
    while(2*p<=w)
    {
       j=2*p;
       if(j<w&&s[j]<s[j+1])j++;
       if(t<s[j]){s[p]=s[j];p=j;}
       else break;
    }
    s[p]=t;
}
void maxHeap(int s[],int w)//维护一个大根堆
{
    for(int i=w/2;i>0;i--)
    ShiftDown(s,i,w);
}
void Hsort(int s[],int w)//堆排序，输出第k小的数
{
    maxHeap(s,w);
    for(int i=w;i>w-k;i--)
    {
        s[1]=s[i];
        ShiftDown(s,1,i-1);
    }
    cout<<-s[1]<<endl;
}
int main()
{
    cin>>n;cin>>k;int T=n; 
    while(T--) 
    {
        cin>>s[cur];
        if(tf[s[cur]])continue;
        tf[s[cur]]=true;s[cur]=-s[cur];cur++; 
    }
    if(cur<=k){printf("NO RESULT\n");return 0;} 
    Hsort(s,cur);
    return 0;
}
```

---

## 作者：좌초 (赞：2)

So  easy的办法！

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int x=0,d,n,a[30002],k;bool f[30002]={false};//重复的数无用，读入的时候舍去！
int main()
{
     cin>>n>>k;
    while(n>0)//不是>=0
     {
         scanf("%d",&d);
         if(!f[d])
           {
               x++;
               a[x]=d;//符合要求的读入
               f[d]=true;//别忘了，读入一个就定义一个不能用
           }
        n--;   
     }
    sort(a+1,a+x+1);  //排好序，直接输入第k个就行
    if(x<k)cout<<"NO RESULT";
      else cout<<a[k];
    return 0;  
}
```

---

## 作者：Charlene_0 (赞：1)

##   一种采用sort的快速排序的方法（分步骤讲解）
   这道题目鄙人的解法主要有两大步骤，首先是去重，接着是排序。
#### 去重
   鄙人去重的方法是通过**bool类型的数组f**来存储在数据范围内（小于30000）每一个数的出现情况。使用for循环，来对输入的每一个数据进行判断。若这个数在输入的数据中出现过，则f[这个数]为true，否则为false。然后在这个数没有出现过的情况下，才把这个数加入新的数组b，同时统计处理过的数据数量（num），并调整f[这个数]的状态为出现过。在对于旧的数据全部处理过后，再对新的数组进行排序（详见下一部分）。
#### 排序
   鄙人采用了**stl里面的sort**快速排序，sort函数进行排序的时间复杂度为O(NlogN)，执行效率比较高，默认为降序。（本程序我们使用降序更加方便）。sort函数使用原则是要左闭右开。最后再判断，如果第k小的数存在，那么就输出排序后的数组的第k个元素，否则就输出NO RESULT。到这里，这道题就搞定了。（程序如下）

  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],b[10001];
bool f[30001];//判断数字是否出现过
int main() 
{
	int n,k,i,num=0;
	cin>>n>>k;
	for(i=1;i<=n;i++)
		cin>>a[i];//输入相应数据
	for(i=1;i<=n;i++)
	{
		if(f[a[i]]==false)//此数据未出现过的情况下执行，否则跳过
		{
			num++;
			b[num]=a[i];
			f[a[i]]=true;//新的数据总数加1，并把此数据加入新数组，同时把情况改为true（已出现）
		}
	}//去重
	sort(b+1,b+num+1);//对新数组快速排序（左闭右开，降序）
	if(k<=num)//判断删除之后新数据总数是否少于原先要求的k
		cout<<b[k];
	else
		cout<<"NO RESULT";
	return 0;
}
```


---

## 作者：TaK_Vin (赞：1)

伪权值线段树

一个权值代表一个点

初始都为零

用sz存当前区间有几个数字

然后普通查询一下就好啦~
```cpp
#include<stdio.h>
#define OJ
using namespace std;
inline char nc(){
    #ifdef OJ
    static char buf[100000],*p1=buf,*p2=buf;
    if(p1==p2){p2=(p1=buf)+fread(buf,1,100000,stdin);if(p1==p2)return EOF;}
    return *p1++;
    #else
    return getchar();
    #endif
}
inline bool isd(const int &c){return '0'<=c && c<='9';}
inline int rd(){
    int x=0,f=1;char ch=nc();
    for(;!isd(ch);ch=nc())if(ch=='-')f=-1;
    for(;isd(ch);ch=nc())x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}
inline void wt(int x,char c){
    if(x<0)putchar('-'),x=-x;
    int ch[11],t=0;ch[t]=c;
    do ch[++t]=x%10+'0',x/=10;while(x);
    do putchar(ch[t]);while(t--);
}
inline int max(const int &a,const int &b){return a>b?a:b;}
struct Segment_Tree{
#define ls t<<1
#define rs t<<1|1
#define mid ((l+r)>>1)
	struct node{int mx,sz;}tr[30001<<2];
	inline void update(int t){tr[t].sz=tr[ls].sz+tr[rs].sz;tr[t].mx=max(tr[ls].mx,tr[rs].mx);}
	inline void ins(int t,int l,int r,int x){
		if (l==r){tr[t].sz=1;tr[t].mx=l;return;}
		x<=mid?ins(ls,l,mid,x):ins(rs,mid+1,r,x);update(t);
	}
	inline int find(int t,int k){
		if (k==tr[t].sz)return tr[t].mx;
		return k>tr[ls].sz?find(rs,k-tr[ls].sz):find(ls,k);
	}
} st;
int n,k;
int main(){
	n=rd();k=rd();
	for (int x,i=1;i<=n;++i)x=rd(),st.ins(1,1,30000,x);
	if (k>st.tr[1].sz)puts("NO RESULT");
	else {int ans=st.find(1,k);wt(ans,'\n');}
	return 0;
}
```

---

## 作者：XHRlyb_2001 (赞：1)

弱弱地写一写刚学的SBT……我用的是后继，顺便贴一贴基本操作QwQ

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 1000005
using namespace std;
inline int read()
{
    char c=getchar(); int num=0,f=1;
    while (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }
    while (c<='9'&&c>='0') { num=num*10+c-'0'; c=getchar(); }
    return num*f;
}

struct node{
    int key,ls,rs,siz;
}tree[maxn];

int tot=0,root=0;

void rrotate(int &now)
{
    int lson=tree[now].ls;
    if (!lson) return;
    tree[now].ls=tree[lson].rs;
    tree[lson].rs=now;
    tree[lson].siz=tree[now].siz;
    tree[now].siz=tree[tree[now].ls].siz+tree[tree[now].rs].siz+1;
    now=lson;
}

void lrotate(int &now)
{
    int rson=tree[now].rs;
    if (!rson) return;
    tree[now].rs=tree[rson].ls;
    tree[rson].ls=now;
    tree[rson].siz=tree[now].siz;
    tree[now].siz=tree[tree[now].ls].siz+tree[tree[now].rs].siz+1;
    now=rson;
}

void maintain(int &now,bool isright)
{
    if (!now) return;
    if (!isright)
    {
        if (tree[tree[tree[now].ls].ls].siz > tree[tree[now].rs].siz)
         rrotate(now);
        else if (tree[tree[tree[now].ls].rs].siz > tree[tree[now].rs].siz)
         lrotate(tree[now].ls),rrotate(now);
        else return;
    }
    else
     {
         if (tree[tree[tree[now].rs].rs].siz > tree[tree[now].ls].siz)
          lrotate(now);
         else if (tree[tree[tree[now].rs].ls].siz > tree[tree[now].ls].siz)
          rrotate(tree[now].rs),lrotate(now);
         else return;
     }
     maintain(tree[now].ls,false);
     maintain(tree[now].rs,true);
     maintain(now,false);
     maintain(now,true);
}

void insert(int &now,int val)
{
    if (!now)
    {
        now=++tot;
        tree[now].key=val;
        tree[now].siz=1;
    }
    else 
     {
         tree[now].siz++;
         if (val<tree[now].key) insert(tree[now].ls,val);
          else insert(tree[now].rs,val);
         maintain(now,val>=tree[now].key);
     }
}

int del(int &now,int val)
{
    int ret;
    tree[now].siz--;
    if ((val==tree[now].key)||(val<tree[now].key&&tree[now].ls==0)||(val>tree[now].key&&tree[now].rs==0))
    {
        ret=tree[now].key;
        if ((tree[now].ls==0)||(tree[now].rs==0)) now=tree[now].ls+tree[now].rs;
         else tree[now].key=del(tree[now].ls,tree[now].key+1);
    }
    else
    {
        if (val<tree[now].key) ret=del(tree[now].ls,val);
         else ret=del(tree[now].rs,val);
    }
    return ret;
}

int select(int now,int k)
{
    if (k==tree[tree[now].ls].siz+1) return now;
    if (k<=tree[tree[now].ls].siz) return select(tree[now].ls,k);
     else return select(tree[now].rs,k-tree[tree[now].ls].siz-1);
}

int rank(int &now,int val)
{  
    if (val<tree[now].key)  
     return rank(tree[now].ls,val);  
    else if (val>tree[now].key)  
     return rank(tree[now].rs,val)+tree[tree[now].ls].siz+1;  
    return tree[tree[now].ls].siz+1;  
}

int getmin()
{
    int x;
    for (x=root;tree[x].ls;x=tree[x].ls);
    return tree[x].key;
}

int getmax()
{
    int x;
    for (x=root;tree[x].rs;x=tree[x].rs);
    return tree[x].key;
}

int pred(int now,int pre,int val)  //前驱 小于
{
    if (now==0) return pre;
    if (tree[now].key<val) return pred(tree[now].rs,now,val);
     else return pred(tree[now].ls,pre,val);
}

int succ(int now,int pre,int val)  //后继 大于
{
    if (now==0) return pre;
    if (tree[now].key>val) return succ(tree[now].ls,now,val);
     else return succ(tree[now].rs,pre,val);
}

int main()
{
    int n=read(),k=read();
    for (int i=1;i<=n;i++)
    {
        int x=read();
        insert(root,x);
    }
    int x=getmin(); if (k==1) { printf("%d",x); return 0; }
    x=succ(root,0,x);
    for (int i=3;i<=k;i++)
    {
        if (x==0) { printf("NO RESULT"); return 0; }
         x=succ(root,0,tree[x].key);        
    }
    if (x==0) printf("NO RESULT"); 
     else printf("%d",tree[x].key);
    return 0;
}
```

---

## 作者：由希❀ (赞：1)

听说这道题可以用优先队列水。


尝试后发现跑得稍微慢一些..


```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q;
int main() {
    int n,k,ans,u=-233;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) {
        int a;
        scanf("%d",&a);
        q.push(a);
    }
    while(k) {
        if(q.empty()) {
            printf("NO RESULT");
            return 0;
        }
        ans=q.top();
        if(u!=ans) k--;
        u=ans;
        q.pop();
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：香风智乃 (赞：1)

貌似没人用set（set很伤心），所以赶紧水一发

（记得注意一些细节，少一个等号==WA 2个点）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    set <int> a; int n,k,i,q; cin>>n>>k; k--;
    for(i=1;i<=n;i++) cin>>q,a.insert(q); q=a.size();
    if(k>=q) {cout<<"NO RESULT"; return 0;}  
    set<int>::iterator it=a.begin();
for(;k;k--) it++; cout<<*it;}
```

---

## 作者：衡屿睿 (赞：1)

STL模板繁多，聊借一水题巩固一下动态数组，亦是一闲情逸事。

为避免题解遭拒，以下回详细介绍动态数组的基本用法：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>//模板库
using namespace std;
int main()
{
    vector<int>a;//定义a为一个int类型的动态数组
    int n,k,h;
    cin>>n>>k;
    for(int i=1;i<=n;++i)
    {
     cin>>h;
     a.push_back(h);//与普通数组不同，动态数组实质是一个LIFO表(栈)，所以读入动态数组时，先cin一个变量，再让这个变量进栈。
    }
    sort(a.begin(),a.end());//动态数组排序的方法与普通数组大相径庭，而不同的是，sort中的首尾位置变为了指向了vector头部尾部的指针
    int w=unique(a.begin(),a.end())-a.begin();//unique()返回的是a去重后的尾地址,而w就是动态数组中不同元素的个数。
    if(w<k)cout<<"NO RESULT";
      else
     cout<<a[k-1];//动态数组从a[0]开始读入，所以k要减一
    return 0;
}
```

---

## 作者：Minclxc (赞：1)

这题的数据范围小于30000，可以用树状数组+二分或者多加一个离散化处理(虽然离散化后可以直接输出答案)

用树状数组记录1~x的数字个数，在二分x求答案。

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
const int maxn=30000;
int b[maxn],c[maxn];
int main(){
    //freopen("in.txt","r",stdin);
    int n,k;scanf("%d%d",&n,&k);
    fo(i,1,n){
        int x;scanf("%d",&x);
        if(b[x])continue;
        for(b[x]=1;x<maxn;x+=x&-x)c[x]++;
```
}//以上树状数组
```cpp
    int l=1,r=maxn;
    for(;l<r;){
        int m=(l+r)>>1,sum=0;
        for(int x=m;x;x-=x&-x)sum+=c[x];
        if(sum<k)l=m+1;
        else r=m;
```
}//以上二分
```cpp
    if(r==maxn)printf("NO RESULT");
    else printf("%d",l);
    return 0;
}

```

---

## 作者：LMB_001 (赞：1)

本宝宝就是不排序，数组弄到30000，布尔型或者是0..1，特献上Pascal代码，不喜勿喷，谢谢

```cpp
var
 a:array[1..30000]of 0..1;//这个数组是打标记，看1到30000中有哪些数出现过
 n,k,i,x:longint;
begin
 readln(n,k);//读入
 fillchar(a,sizeof(a),0);//开始时把30000个数组元素都置为0
 for i:=1 to n do begin
  read(x);//读入
  a[x]:=1;//读入以后把这个数对应的数组元素置为1
 end;
 x:=0;//记录当前是第几小的数
 for i:=1 to 30000 do begin
  if a[i]=1 then inc(x);//如果i这个数出现过，几把计数器加一
  if x=k then begin write(i);exit;end;//如果到第k小了，就先输出，再退出程序
 end;
 write('NO RESULT');//如果没有退出程序执行到这一步，就输出无解
end.
```

---

## 作者：vegetabird (赞：1)

我来发一个桶排序 23333

作为时间复杂度最小的排序方法，桶排序因为其恐怖的空间使用而被打入冷宫。。。

然而这题的数很小，<=30000，不用担心爆内存，所以就可以光明正大地用桶排啦2333

```cpp
#include<cstdio>
#define Runtime int                                    请忽视这一行
#define Error main                                    还有这一行
int n,k,i,num,cnt,max;
bool a[30010];
Runtime Error(){                                    和这一行
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++){
        scanf("%d",&num);
        max=num>max?num:max;                    找到当前的最大数，节省时间
        a[num]=true;
    }
    for(i=1;i<=max;i++){
        if(a[i]){                                    假如i这个数在数列里
            cnt++;                                这是第几个数
            if(cnt==k){                            如果这是第k个数
                printf("%d\n",i);                    输出
                return 0;
            }
        }
    }
    printf("NO RESULT\n");                            如果找不到第k个数，则输出“NO RESULT”
    return 0;
}
```

---

## 作者：mike_he (赞：1)

vector直接存然后咸鱼sort....

[codec]



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
bool vis[30010];
vector<int> v;
int main(){
    int x;
    int N;
    int K;
    cin>>N>>K;
    for(int i=0;i<N;++i){
        cin>>x;
        if(!vis[x]){
            vis[x]=true;
            v.push_back(x);
        }
    }
    if(v.size()<K){
        puts("NO RESULT");
        return 0;
    }
    sort(v.begin(),v.end());
    cout<<v[K-1];
    return 0;
}
[/codec]
```

---

## 作者：楯山文乃 (赞：1)

此题重点是快排+判断，代码如下——

```cpp
#include<iostream>
#include<cstdlib>
#include<algorithm>
using namespace std;
int i,n,k,f;
int a[10010]; //定义变量
int main(){
    cin>>n>>k; //读入 
    for(i=1;i<=n;i++){
        cin>>a[i]; //输入n个数
    }
    sort(a+1,a+n+1); //从小到大快排 
    for(i=1;i<=n;i++){
        if(a[i]>a[i-1]){ //判断k第几小 
            k--;
            f=i;
        }
        if(k<=0) break; //条件break
    }
    if(k==0) cout<<a[f]<<endl; 
    else cout<<"NO RESULT"<<endl; //判断，如果已经循环完了但是还没有找到第k小的，就输出NO RESULT
    return 0;
}>>- 0.
```

---

## 作者：PTC06 (赞：1)

此题感觉用sort太麻烦太耗时，所以我用了桶排，因为数据范围并不大，不会内存溢出。思路也比较容易想出来，代码如下——

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long i,big,k1,n,k,t,a[30005];         //定义变量
int main()
{
    scanf("%d%d",&n,&k);       //输入n,k
    for (i=1;i<=n;i++)               //循环
    {
        scanf("%d",&t);          //输入N个数
        a[t]=1;                        //桶排，输入了一个数就在a数组做一个标记
        if (big<t) big=t;          //判断最大值，方便下面的循环，不用循环到30000
    }
    for (i=1;i<=big;i++)
    {
        if (a[i]==1) k1++;           //判断，如果上面曾输入过i，就增加k1，k1用来判断这个数是第几小的
        if (k1==k)                    //如果这个数是第k小的
        {
            printf("%d",i);      //就输出这个数
            break;                 //break省一点循环
        }
    }
    if (k1<k) cout<<"NO RESULT";    //判断，如果已经循环完了但是还没有找到第k小的，就输出NO RESULT，这一步必须记得
    return 0;
}
```

---

## 作者：Deny_小田 (赞：1)

本题其实没什么难度，模拟直接过。

主要就是快排+去重[delete]和楼下说的差不多[/delete]

时间复杂度注意点，要不然你判重的时间复杂度是O(n^2)的话，n = 10000要运行1亿次，离超时不远了！所以应在排序之后判重，时间复杂度是O(n)

判断NO RESULT的方法也挺简单，不过我这个时间复杂度挺大。事先运行完主程序再判断。各位OIer朋友可以自行修改一下代码。


[delete]废话说了这么多[/delete]，上代码！





```cpp
#include <cstdio>
#include <algorithm>
#define Size 10001
using namespace std;
int A[Size],B[Size];
int main(){
    int i,n,k,cnt = 0;
    scanf("%d %d",&n,&k);
    for(i = 0; i < n; i++) scanf("%d",&A[i]);
```
/\*下面进行去重\*/
```cpp
    sort(A,A+n);    //先排序，减少时间复杂度
    B[cnt] = A[0];
    for(i = 1; i < n; i++){
        if(A[i] == B[cnt]) continue;
        else B[++cnt] = A[i];
    }
    cnt++;    //cnt归位到数组长度，纯属个人喜好。。。
```
/\*去重完毕\*/
    if(k < 0||k >= cnt) printf("NO RESULT\n");
    
```cpp
    else{
        for(i = 0; i < cnt; i++) if(i == k-1){    
            printf("%d\n",B[i]);    //输出结果 
            break;
        }
    } 
    return 0;
}
```

---

## 作者：Ufowoqqqo (赞：1)

排序，去重。虽然使用选择排序也能Accepted，但考虑到题目的数据范围，最好还是用快速排序。

```delphi

type data=array [1..10000] of longint;
var
 a:data;
 n,k,i,m:longint;
procedure qsort(var a:data);
 procedure sort(l,r:longint);
 var
  i,j,x,y:longint;
 begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
   while a[i]<x do inc(i);
   while x<a[j] do dec(j);
   if not(i>j) then
    begin
     y:=a[i];
     a[i]:=a[j];
     a[j]:=y;
     inc(i);
     dec(j);
    end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
 end;
begin
 sort(1,n);
end;
begin
 readln(n,k);
 for i:=1 to n do read(a[i]);
 qsort(a);
 for i:=1 to n do
 begin
  if a[i]<>a[i-1] then inc(m);//相同的数只算一次
  if m=k then
   begin
    write(a[i]);
    halt;
   end;
 end;
 write('NO RESULT');
end.

```

---

## 作者：野菜汤 (赞：1)

题解：

此题其实并不难，那么思路就是将数据排序，然后去重再输出，即可解决问题，那么这题的难点就是如何快捷的去重。请参考以下标程，仅供参考。

```delphi
var i,j,p,q,k,n,m:longint;
    a,b:array[1..10000] of longint;
begin
  read(m,n);
  for i:=1 to m do
   begin
    read(a[i]);
   end;
  for i:=1 to m do{本人天生较懒，所以这里只用了选排，那么有志者可以选择快排，可能会更快些}
    for j:=i+1 to m do
    begin
      if a[i]>a[j] then begin
        k:=a[i];a[i]:=a[j];a[j]:=k;
      end;
    end;
  q:=1;{q是记录忽略重复数字以后数字出现的次数，作为指针使用，以便记录}
  for i:=1 to m do{去重，这一步很重要也和关键}
   begin{以p作为去重的标准变量}
     if p<>a[i] then begin{当同一个数字第一次出现的时候，就将其记录为标准变量}
       p:=a[i];b[q]:=a[i];{再将此数记录到相应的数组中}
       inc(q);{将指针往后推一格}
     end;
   end;
  if n>=q then write('NO RESULT'){因为指针q在最后一次还会加1，所以它的最终值应该是忽略重复后所有数字总数再+1，那么如果这个n要是大于等于q的话，就不会有答案，就直接输出没有就好了}
  else write(b[n]);
end.
```
这一题，也可以说是一道练手题，而这去重的方法对于初学者来说在今后也是大有用处，所以还请同学们好好参悟，得其中精髓也。


---

## 作者：董w铮 (赞：1)

    这是一个C++初学者，接触洛谷仅几个月，因此代码略显复杂，希望大神们能原谅。
    
    以下是我的代码，这题本来想用快排，后面还是老老实实用了去重+选择排序
    
    我觉得这样可能比较好理解，望管理员通过

```
#include<iostream>
using namespace std;
int n,MAXN=30001,i,k,p,changee,w;
int  m=0,o,outt;
int main(){
	int a[MAXN];
	cin>>n>>o;     //o即题目中的k
	for(i=0;i<n;i++)   //输入数据
	cin>>a[i];
	for(i=0;i<n;i++){   //以下是去重(两层循环）
		k=i;
		for(p=i+1;p<=n;p++){
			if(a[k]==a[p]&&a[p]!=0){
			a[p]=0;
			m++;   //m代表重复的个数
		}
		}
	    }          //去重步骤结束
		for(i=0;i<n;i++){    //以下是选择排序（两层循环）
		w=i;     //i控制循环次数，w的功能类似于指针
		for(k=i+1;k<n;k++){
			if(a[k]<a[w])
			w=k;     //反复循环在数组中选择
		}
		if(w!=i){     //交换数字
			changee=a[w];
			a[w]=a[i];
			a[i]=changee; 
		}
	}    //选择排序结束
	outt=o+m-1;    //特别注意数组下标从0开始，因此要把输入的o(即题目中的k)减去1
	if(outt>=n)
	cout<<"NO RESULT"<<endl;   //可能出现第k小整数大于总位数的情况，此时“NO RESULT”
	else
	cout<<a[outt]<<endl;  //输出数组中的第outt项
	return 0; 
} 
```

这里特别说明一下，程序中选择排序指从数组第0项开始，找到第1——第N-1项中最小的项与第0项交换，于是第0项中便是最小的数了。
然后是数组第1项，找到第2——第N-1项中最小的项与第1项交换，于是第1项中便是第二小的数了。

以此推类。。。最后就可以排序成功。

这题也可用快排做，但题解里已经有很多了，这里就不再列出来了。

---

## 作者：detect (赞：1)

注意到n<=10000,自然想到运用桶排序思想，绕开相同的数不计入的难点！


桶排序，超简单！

```cpp
#include<iostream>
#include<algorithm>//库
using namespace std;
int main()
{ 
    int i,j=1,k,h,n,m;
    cin>>n>>k;
    int a1[n+1],x[10001],a[n+1];//x[10001],设定10000个桶
    for(i=1;i<=10000;i++)
    x[i]=0;//10000 个桶初始化为一
    for(i=1;i<=n;i++)
    {
        cin>>a1[i];//输入数
        x[a1[i]]++;//对应的·桶加1
    }
    for(i=1;i<=10000;i++)
    {
        if(x[i]!=0)//如果有这个数
        {
            a[j]=i;//存入a数组
            j++;
        }
    }
    sort(a+1,a+j);//快排
    if(k>j-1)//不可能的情况
    cout<<"NO RESULT";
    else
     cout<<a[k];//输出
    return 0;
}
```

---

## 作者：ckyao1881 (赞：1)

```cpp
var
  f:array[1..30000] of boolean;//用于判断
  i,t,k,n:longint;
begin
  readln(n,k);//读入
  for i:=1 to n do begin
    read(t);
    f[t]:=true;
  end;
  t:=0;
  for i:=1 to 30000 do if f[i] then begin
    inc(t);
    if t=k then begin//当符合条件时开始
      write(i);
      halt;//结束任务
    end;
  end;
  writeln('NO RESULT');
end.
```

---

## 作者：yzz2016 (赞：1)

```cpp
//为什么没人用计数排序 ，又短又快
#include <cstdio>
#include <algorithm>
using namespace std;
bool a[30010];
int ma,n,i,k,x,t;
int main()
{
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(!a[x]){a[x]=1;t++;ma=max(ma,x);}          
    }
    if(t<k) {printf("NO RESULT");return 0;}
    for(i=1;i<=ma;i++)
    {
        if(a[i]) k--;
        if(!k) {printf("%d",i);return 0;}
    }
}
```

---

## 作者：3114129979cc (赞：0)

**这是本蒟蒻第二篇题解了！！！希望大家支持！！！**


本题的一般思路是：读入后排序去重，再输出。

不过本人偷了个小懒，题目不是说正整数均小于30000嘛……

开一个下标0~30000的数组a，a[i]表示数i是否出现，就省去了排序去重这一步操作。

上代码：

```cpp
#include<bits/stdc++.h>
#define rei register int//宏定义，加快循环速度 
using namespace std;
int n,k,a[30010],t,m,mx;
int main()
{
	scanf("%d%d",&n,&k);//读入 
	for(rei i=1;i<=n;++i)
	{
		scanf("%d",&t);//读入一个数 
		mx=max(mx,t);//记下最大数，用于判断 
		a[t]=1;//将此数标记为真 
	}
	m=1;
	for(rei i=1;i<=k;++i)
	{
		while(a[m]==0 && m-1<=mx) m++;//找到下一个存在的数，“m-1<=mx”用来判定m的范围 
		m++;//这个操作必须有，否则m永远不会变 
	}
	if(m-1<=mx) printf("%d",m-1);//如果存在第k大数 
	else printf("NO RESULT");//否则输出“NO RESULT” 
	return 0;
}

```


---

## 作者：Sinwind (赞：0)

# 1.分析

本题本质上是要求将$n$各数按照从小到大排序，找到其中的第$k$个最小数，又因为重复的只计算一个，自然想到**桶排序**。

# 2.思路

1. 循环$n$次，每个数读入$input$；

- 桶排序$(bcuket[input]++)$；

- 同时这里做了优化，找到输入的数的最大值$mx$，之后遍历$bucket$时，只需要遍历$[1,mx]$的范围，不需要遍历整个$bucket$数组。

2. 遍历数组$bucket[i],i\in[1,mx]$；

- 若对应的桶有数$(bucket[i]>0)$，计数$(cnt++)$；

- 当找到时$(cnt==k)$，输出$i$，提前退出程序。

3. 若没有在2中提前退出，说明无解，输出$"NO\space RESULT"$。

# 3.代码

```cpp
#include <iostream>

using namespace std;

int n;  					//正整数个数
int k;  					//第几个最小整数
int bucket[30005] = {0};    //桶排序的桶
int mx = 0;                	//输入的数的最大值
int cnt = 0;                //第几个数

int main(void)
{
	cin >> n >> k;
	
	for(int i = 0; i < n; i++)
	{
		int input;
		cin >> input;
		if(input > mx)
		{
			mx = input;
		}
  		bucket[input]++;
 	}

	for(int i = 1; i <= mx; i++)
	{
		if(bucket[i] > 0)
		{
			cnt++;
		}
		
		if(cnt == k)
		{
			cout << i;
			return 0;
		}
	}
	
	cout << "NO RESULT";
	
	return 0;
}
```


---

## 作者：lxy0070102 (赞：0)

首先这道题目不是很难，看见大佬们用的什么主席树、线段树，蒟蒻都被吓慌了。
# 其实这道题目只需要用桶排序就够了
首先来确立一下方法

* 用vis数组标记每个数是否出现和出现了几次

* 我们使用while循环，循环n次，如果n个数全部循环完成都没有找到第k小整数就输出NO RESULT

* 用i循环，如果vis[i]==0，那么coutinue掉。如果不是，计数器++，判断一下计数器是不是与k相等，如果计数器与k相等说明已经找到第k小整数了，输出i，并return 0。如果计数器不与k相等，i++，**并且n要减去vis[i]（i这个数字在给出的数据中出现了几次）**

* 还有一个特判那就是如果n<k，给出的数据都没有k个数，那就不存在第k小整数，所以直接输出NO RESULT。

**有人问那你怎么确保输出的一定是第k*小*整数呢，其实vis数组里面的下标都是按从小到大的顺序排列的，而i也是从小往大递增的，所以能保证如果存在第k小整数的话，程序一定能找到**
    
***
    
程序如下（我不想写注释了，原谅笔者吧QAQ（可怜兮兮.jpg））    

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,vis[10005],s,js;
int main(){
	cin>>n>>k;
	if(n<k){
		cout<<"NO RESULT"<<endl;
		return 0;
	}
	for(i=1;i<=n;i++){
		cin>>s;
		vis[s]++;
	}
	i=1; 
	while(n){
		if(vis[i]==0){i++;continue;}
		else {
			js++;
			if(js==k){cout<<i<<endl;return 0;}
			else {n=n-vis[i];i++;}
		}
	}
	cout<<"NO RESULT"<<endl;
	return 0;
}

```

---

## 作者：天上一颗蛋 (赞：0)

# 来一发线段树

最近请教了一下大佬怎么求序列内第k大查询，自己又捣鼓了一下，虽然还没有懂得区间第k大查询，不过姑且做一个记录先吧

因为每个元素大小可能很大而元素之间不连续，所以我们先离散化处理一下，程序中的ori[ ]代表原序列，离散化后每个key对应一个值，mem[ ]存的是key对应的值：mem[i]代表离散化后 i 代表的值，a[i]代表离散化后有几个i对应的值（mem[i]的个数）

离散化之后建树，sum中存的是有序的元素总个数具体可以看程序，那么如何查询？我们查询线段树的sum，若tree[lid].sum >= k ，说明第k大一定在左儿子区间，因为线段树是以有序数列来构建的，每个叶子排起来是有序的（抠一下手指就出来了），说明k在左边。同理 若 tree[lid].sum < k 说明左边全部在一起都没有 k 个，答案自然就在右边了

因为从右边区间出发，已经排除全部左边节点了，所以k要减去左边的sum

这样一直找到叶子节点，找到的叶子对应的就是离散化后的key了，我们再利用mem输出就好啦


```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
#define lid (id << 1)
#define rid (id << 1) | 1
const int maxn = 100019;
int num,k;
int ori[maxn];
int mem[maxn];
struct sag_tree{
    int l,r,sum;
    }tree[maxn << 2];
int a[maxn];
void build(int id,int l,int r){
    tree[id].l = l;
    tree[id].r = r;
    if(l == r){
        tree[id].sum = a[l];
        return ;
        }
    int mid = (l + r) >> 1;
    build(lid,l,mid);
    build(rid,mid + 1,r);
    tree[id].sum = tree[lid].sum + tree[rid].sum;
    }

int query(int id,int k){
    if(tree[id].l == tree[id].r)return tree[id].l;
    if(tree[lid].sum < k)return query(rid,k - tree[lid].sum);
    else if(tree[lid].sum >= k)return query(lid,k);
    }

int main(){
    num = RD();k = RD();
    for(int i = 1;i <= num;i++){
        ori[i] = RD();
        }
    sort(ori + 1,ori + 1 + num);
    int n = 0;
    for(int i = 1;i <= num;i++){
        if(i == 1 || ori[i] != ori[i - 1]){
            n++;//最后得到的k就是元素个数
            }
        a[n] = 1;//因为要去重，就不是a[n]++了
        mem[n] = ori[i];
        }
    if(k > n){
        cout<<"NO RESULT"<<endl;
        return 0;
        }
    build(1,1,n);
    cout<<mem[query(1,k)]<<endl;//附：其实可以直接输出mem[k]的。。。有兴趣的可以思考一下离散化的功能
    return 0;
    }
```

# 拓展

推一下可以得到，序列第k大就是序列第（num - k + １）小，所以也很好解决

---

## 作者：Rye_Catcher (赞：0)

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cctype>
using namespace std;
vector <int>a;
int read()//白送个快读模板
{
	int x=0;char ch;short int neg=0;ch=getchar();
	while(!isdigit(ch)){
		neg|=(ch=='-');ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+ch-48;ch=getchar();
	}
	return neg?-x:x;
}
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		register int x=read();
        a.insert(upper_bound(a.begin(),a.end(),x),x);
	}

	 vector<int>::iterator p=unique(a.begin(),a.end());
	 a.erase(p,a.end()); 
	 int len=a.size();
	 if(len<k||k<0)cout<<"NO RESULT"<<endl;
	 else cout<<a[k-1]<<endl;
	return 0;
}
```
I love vector

- 注释：
  - insert()插入

  - upper_bound()
    具体用处可参照这位dalao的博客
     http://blog.csdn.net/kirito_acmer/article/details/46291117

  - unique()去重

    返回去重后的数组尾部指针

  - erase()删除

    此处删除后面的重复元素，因为unique()只把重复的元素添加到容器末尾所以数组大小并没有改变。
  
  - size()返回元素个数

vector和STL是个好东西，希望大家多上网查阅些博客资料

---

## 作者：凌幽 (赞：0)

来一篇主席树的题解,这就是一道主席树的入门板子题

题面要求重复的数字只算一次,那么我们可以去重(当然,stl大佬们可以直接用unique),用去重后的数字建一棵有前缀关系树,询问全部数字中的第k小

显然,如果去重后的数字没有k个,那是一定没有第k小的,此时无解

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define re register
#define N 100005
int a[N],b[N],c[N];
int cnt,m=1,n,k;
int root[N],L[N*20],R[N*20],size[N*20]; 
inline void update(int A,int &B,int l,int r,int k){
    B=++cnt;
    size[B]=size[A]+1;
    re int mid=l+r>>1;
    if(l==r && r==k) return;
    if(k<=mid) update(L[A],L[B],l,mid,k),R[B]=R[A];
    else update(R[A],R[B],mid+1,r,k),L[B]=L[A];    
}
inline int query(int A,int B,int l,int r,int k){
    while(l<r){
        re int mid=l+r>>1;
        re int lch=size[L[B]]-size[L[A]];
        if(lch>=k) r=mid,B=L[B],A=L[A];
        else l=mid+1,B=R[B],A=R[A],k-=lch;
    }
    return l;
}
inline int dy(){
    scanf("%d%d",&n,&k);
    for(re int i=1;i<=n;++i)
        scanf("%d",&a[i]),b[i]=a[i]; 
    sort(b+1,b+1+n);
    for(re int i=2;i<=n;++i)
        if(b[i]!=b[m]) b[++m]=b[i]; // 去重
    if(k>m) {printf("NO RESULT");return 0;}
    for(re int i=1;i<=m;++i) c[i]=lower_bound(b+1,b+1+m,b[i])-b;  //离散化
    for(re int i=1;i<=m;++i)
        update(root[i-1],root[i],1,m,c[i]); //建树
    printf("%d\n",b[query(root[0],root[m],1,m,k)]); //询问
    return 0;
}
int QAQ = dy();
int main(){;}
```

---

## 作者：DJOgoP (赞：0)

才写了一套SBT平衡树模板，看到就刚好拿来用用了。

这道题只需要插入，删除，以及查询。

在输入时可以特判去掉重复的数，也可以在INSERT操作中判断。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int data[100010],R[100010],L[100010],s[100010],num=0,n;
bool pd[10001];
void RightRotate(int &x)//左旋右旋操作
{
    int y;
    y=L[x];
    L[x]=R[y];
    R[y]=x;
    s[y]=s[x];
    s[x]=s[R[x]]+s[L[x]]+1;
    x=y;
}
void LeftRotate(int &x)
{
    int y;
    y=R[x];
    R[x]=L[y];
    L[y]=x;
    s[y]=s[x];
    s[x]=s[L[x]]+s[R[x]]+1;
    x=y;
}
void maintain(int &x,bool w)//维护平衡树，0代表左偏，1代表右偏；
{
    if(!w)
    {
        if(s[L[L[x]]]>s[R[x]])
          RightRotate(x);
        else if(s[R[L[x]]]>s[R[x]])
        {
            LeftRotate(L[x]);
            RightRotate(x);
        }
        else
          return;
    }
    else
    {
        if(s[R[R[x]]]>s[L[x]])
          LeftRotate(x);
        else if(s[L[R[x]]]>s[L[x]])
        {
            RightRotate(R[x]);
            LeftRotate(x);
        }
        else
          return;
    }
    maintain(L[x],0);
    maintain(R[x],1);
    maintain(x,0);
    maintain(x,1);
}
void insert(int &x,int w) 
```
{//在x为根的树中插入值为w的数。用来建树
```cpp
    if(x==0)
    {
        x=++num;
        data[x]=w;
        s[x]=1;
        L[x]=0;
        R[x]=0;
    }
    else
    {
        s[x]++;
        if(w<data[x])
            insert(L[x],w);
        else
            insert(R[x],w);
        maintain(x,w>=data[x]);        
    }
}
int Delete(int &x,int w)
```
{//在根为x的树中删除值为w的数
```cpp
    s[x]--;int temp;
    if(data[x]==w||(w<data[x]&&L[x]==0)||(w>data[x]&&R[x]==0))
    {
        temp=data[x];
        if(!L[x]||!R[x])
          x=L[x]+R[x];
        else
          data[x]=Delete(L[x],data[x]+1);
        return temp;
    }
    else
    {
        if(w<data[x])temp=Delete(L[x],w);
        else temp=Delete(R[x],w);
        return temp;
    }
}
int select(int &x,int w) 
```
{//在根为x的树中查找排名为w的数
```cpp
    if(w==s[L[x]]+1)return data[x];
    if(w<s[L[x]]+1)return select(L[x],w);
    else return select(R[x],w-s[L[x]]-1);
}
int main()
{
    int k;
    scanf("%d%d",&n,&k);int del;int rt=0;
    for(int t=1;t<=n;t++)
    {
        scanf("%d",&del);
        if(!pd[del])去重
          {
              insert(rt,del);
              pd[del]=1;
          }
    }
    int ans=select(rt,k);
    if(!ans) printf("NO RESULT");
    else printf("%d",ans);
    return 0;
}

```

---

## 作者：微雨燕双飞 (赞：0)

好像楼下没人用桶排做的，不知道为什么。。我这里就发一份桶排题解，思路简单，详见程序。

上AC代码：

```cpp
#include<cstdio>
using namespace std;
int n,k,a;
int b[30005]; //桶数组，用来存储每个数字有多少个
void init()
{
  scanf("%d%d",&n,&k);
  for(int i=1; i<=n; i++) 
  {
   scanf("%d",&a);
   b[a]++; //读入
  }
}
void bucketsort() //桶排标程，不会看书。（其实我想默默说一句：桶这玩意儿用处真不大，除了排序我也想不出来它还有啥用了，然而现在都是快排全覆盖。。）
{
  int sum=0,ans=0;
  for(int i=1; i<=30000; i++)
  {
    if(b[i]>0) sum++; //用桶模拟
    if(sum==k) {ans=i; break; }
  }
  if(ans!=0) printf("%d",ans); //不为零输出ans
    else printf("NO RESULT");
}
int main()
{
  init();
  bucketsort();
  return 0;
} //结束
```

---

## 作者：2016级8班taiqi (赞：0)


先进行排序，去重，在记录第一个重复的元素进行判断。


```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n,k,m;
    cin>>n>>k;
    int a[n+1];
    for(int i=1; i<=n; i++)
        cin>>a[i];
    sort(a+1,a+n+1);
    unique(a+1,a+n+1)-a;//去重
    for(int i=1; i<=n; i++){
        if(a[i+1]<=a[i]){
            m=i;//记录第一个重复元素的节点
            break;//注意停止
        }
    }
    if(k<=m)cout<<a[k];
    else cout<<"NO RESULT";
    return 0;
}
```

---

## 作者：weige233 (赞：0)

#快排+模拟过，比较适合不懂桶派的萌新，

#整体思路大概：

##1、进行排序。

##2、进行标记。

##3、判断。

###贴程序

```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;
int a[10001],b[30001];
int main()
{
    int n,k,m=0;
    cin>>n>>k;
    for(int i=1; i<=n; i++)
     cin>>a[i];     //输入
    sort(a+1,a+n+1);     //首先快排，从小到大
    for(int i=1; i<=n; i++)
     b[a[i]]=1;            //接着把每个数对应的下标进行标记
    for(int i=1; i<=a[n]; i++)
     if(b[i]==1)       //判断+计算第i小整数
     {
      m++;
      if(m==k)    //直到等于k
      {
       cout<<i;     //输出
       return 0; 
      }
     }
     cout<<"NO RESULT";         //最后当所有情况不成立，输出NO RESULT 
}

```

---

## 作者：デス (赞：0)

题解：


此题其实并不难，那么思路就是将数据排序，然后去重再输出，即可解决问题，那么这题的难点就是如何快捷的去重。请参考以下标程，仅供参考。


```cpp
var i,j,p,q,k,n,m:longint;
    a,b:array[1..10000] of longint;
begin
  read(m,n);
  for i:=1 to m do
   begin
    read(a[i]);
   end;
  for i:=1 to m do{本人天生较懒，所以这里只用了选排，那么有志者可以选择快排，可能会更快些}
    for j:=i+1 to m do
    begin
      if a[i]>a[j] then begin
        k:=a[i];a[i]:=a[j];a[j]:=k;
      end;
    end;
  q:=1;{q是记录忽略重复数字以后数字出现的次数，作为指针使用，以便记录}
  for i:=1 to m do{去重，这一步很重要也和关键}
   begin{以p作为去重的标准变量}
     if p<>a[i] then begin{当同一个数字第一次出现的时候，就将其记录为标准变量}
       p:=a[i];b[q]:=a[i];{再将此数记录到相应的数组中}
       inc(q);{将指针往后推一格}
     end;
   end;
  if n>=q then write('NO RESULT'){因为指针q在最后一次还会加1，所以它的最终值应该是忽略重复后所有数字总数再+1，那么如果这个n要是大于等于q的话，就不会有答案，就直接输出没有就好了}
  else write(b[n]);
end.
这一题，也可以说是一道练手题，而这去重的方法对于初学者来说在今后也是大有用处，所以还请同学们好好参悟，得其中精髓也。
```

---

## 作者：待捕捉萌新QwQ (赞：0)

其实这题优化选排就可以过，不必用快排

看了看楼下dalao们的代码，发现貌似没有人用优化选排，于是决定发个优化选排的代码（interesting）


```cpp
var a:array[1..10000]of longint;
    n,i,k,j,t,m:longint;
begin
  readln(n,k);
  for i:=1 to n do read(a[i]);  
  for i:=1 to k do             //优化选排开始！
    begin
      m:=i;
      for j:=i+1 to n do
        if a[m]>a[j] then m:=j;
      if m<>i then
        begin
          t:=a[m];a[m]:=a[i];a[i]:=t;
        end;
    end;                       //这就是优化选排辣，本人蒟蒻一只，欢迎dalao指教~
  writeln(a[k]);
end.
```

---

## 作者：Kidd (赞：0)

楼下的代码我没看懂，其实管他加没加过都能进，只不过最后要‘’一视同仁‘’。













```cpp
var n,m,x,i,g:longint;a,b:array[0..30000] of longint;
begin
   readln(n,m);
   for i:=1 to n do
   begin
      read(x);
      inc(a[x]);//处理桶
   end;
   for i:=0 to 30000 do
   if a[i]<>0 then begin inc(g);b[g]:=i;end;//如果这数出现过，把它放进b数组里。
   if b[m]<>0 then writeln(b[m]) else writeln('NO RESULT'); //假如第k小整数有，则输出，反之则输出NO RESULT
end.

```

---

## 作者：cenbinbin (赞：0)

这题无需快排，只需用一个变态的桶排即可。

利用a这个累加器，就可以解决重复的问题。

=============================================================================

```cpp
var a:array[1..30000] of longint;
    i,z,n,k,sum:longint;
begin
    readln(n,k);
    for i:=1 to n do
    begin
        read(z);if a[z]=0 then inc(a[z]);  //做一个累加器，若为0，则代表已经出现过
    end;
    for i:=1 to 30000 do  //对每个数枚举
    begin
        sum:=sum+a[i];  //累加，没出现就加0，相当于没有加
        if sum>=k then break;  //代表已达到第k大的数
    end;
    if i<>30000 then write(i)  
        else writeln('NO RESULT');  //没找到，就输出NO RESULT
end.

```

---

## 作者：Zoewilly (赞：0)

比较简单的一道排序题，即排序后去重，剩下的数求第k小即可。可以快排+暴力去重实现，闲来无事（闲的蛋疼）也可以打个平衡树。最后要注意当去重后数字个数小于k时输出NO RESULT。



```cpp
0. #include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int n,k,ans,a[10050];
int main(){
    scanf("%d%d",&n,&k);
    for (int i=1; i<=n; i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    int now=0;
    for (int i=1; i<=n; i++) {
        if (a[i]!=a[i-1]) now++;
        if (now==k) {
            ans=a[i];
            break;
        }
    }
    if (!ans) printf("NO RESULT"); else printf("%d",ans);
    return 0;
}0.
```

---

## 作者：Xsy123456 (赞：0)

**#C++ STL秒解**

##思路都差不多，只不过改为用<algorithm>的算法函数来简化了

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n,k;
int a[10000+5];

int main(){
    
    scanf ("%d%d",&n,&k);
    
    for (int i=1;i<=n;i++)
      scanf ("%d",&a[i]);
    sort (a+1,a+n+1);    //调用排序函数SORT
    
    if (k>unique (a+1,a+n-1)-a-1)//unique()是连续去重的，返回值是数组最后一个数的后面一个的地址
      printf ("NO RESULT");           //我们将他的返回值减去a[0]的地址再-1就是这个数组元素的个数了，从而可以判断k是否超出范围
    else 
      printf ("%d",a[k]);
    
    return 0;
    
}
```

---


# 硬币翻转

## 题目描述

在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。

## 样例 #1

### 输入

```
4```

### 输出

```
4
0111
1100
0001
1111
```

# 题解

## 作者：子谦。 (赞：394)

#翻n-1枚硬币，就是有一枚不翻，也可以理解为翻一枚

直接上程序，看程序说话

```cpp
#include<iostream>
using namespace std;
const int maxn=101;
bool a[maxn];//a数组负责存储硬币的状态
int n;//n枚硬币
int main()
{
    cin>>n;
    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可
    for(int i=1;i<=n;i++){//i表示这是第几次翻
        for(int j=1;j<=n;j++){//表示当前翻得是第几枚硬币
            if(j!=i){//如果不为第i枚
                if(a[j])a[j]=0;//1变成0
                else a[j]=1;//0变成1
            }
            cout<<a[j];//输出当前状态
        }
        cout<<endl;//别忘了换行
    }
    return 0;
}
```

---

## 作者：ytxytx (赞：136)

首先有一个很显然的性质：一个硬币被翻转**奇数次**以后一定翻了个面！

我们观察反转操作的特点：每次翻转 $n-1$ 个硬币，即每次**有且仅有**一个硬币没有被翻转

于是这要求我们构造一种方案，每次对 $n-1$ 个硬币进行翻面操作，最终每一枚硬币都被操作了奇数次。

### 操作优化

接下来考虑如果对完全相同的一组（$n-1$ 个）硬币先后进行翻转操作两次及以上（不一定是连着操作两次，这样显然直接抵消了），这样是有意义的吗？

是没有意义的，即使不是连着操作，也会抵消。如果能够理解这一点，那么本质上来说这就是异或，你也就理解了异或的交换律和结合律（或者换个方向，你可以先了解异或和其运算律，再回过头看这个问题）。

因此，一种不重复操作的方案可以被构造出来了：

- 第 $i$ 次操作翻转除硬币 $i$ 以外的 $n-1$ 枚硬币。

对于这种构造方案，我们看看它是否满足要求：很显然，每一枚硬币最终都被翻转了 $n-1$ 次，而 $n$ 在题设中为偶数，因此符合了最终的要求。

具体的说，假设有 $6$ 枚硬币，操作的顺序就是：

```plain
第一次 .*****
第二次 *.****
第三次 **.***
第四次 ***.**
第五次 ****.*
第六次 *****.
*表示翻转
```

答案序列就是：

```plain
011111
110000
000111
111100
000001
111111
```

### 为什么 $n$ 是最小的操作次数呢？

有没有不用 $n$ 次操作就能完成的方法呢？很遗憾，没有。

如果存在只操作 $c\ (0<c<n)$ 次的方案，那么既存在**进行过**“除它以外的硬币都翻转”操作的 $\alpha$ 型硬币，也存在**没有进行过**“除它以外的硬币都翻转”操作的 $\beta$ 型硬币。

对于 $\alpha$ 型硬币，它自身被翻转的次数为 $c-1$；对于 $\beta$ 型硬币，它自身被翻转的次数为 $c$。

很显然 $c$ 和 $c-1$ 一奇一偶，必然有一个不符合翻转奇数次的条件，因此 $n$ 次操作是必需的。

### Code:

代码中使用了一些位运算符，如果看不懂可以按照自己的理解写代码或参考其他题解的写法。

```cpp
#include<iostream>
#include<cstdio>

int n;

int main(){
	scanf("%d",&n);
	printf("%d\n",n);
	for (int i=1;i<=n;i++){
		for (int j=1;j<=i;j++) putchar(48|~i&1);
		for (int j=i+1;j<=n;j++) putchar(48|i&1);
		putchar(10);
	}
}
```

---

UPD 20200804：本人已退役，撤下了一些算是黑历史的题解，但考虑到这篇题解确实给一些初学者带来了帮助，于是决定进行修改并保留，也算作为我曾为OIer的印记吧。

- 想看[修改前的题解](https://www.luogu.com.cn/blog/user35688/ti-xie-p1146-ying-bi-fan-zhuai-yuan-ban-post)？

---

## 作者：ljc20020730 (赞：118)

数学方法：第i次翻转就是翻转除了第i个硬币以外的所有硬币。

下面给出文字证明：

#证明1

定义翻某n-1个为A类操作。

定义B操作，是把所有的硬币全部翻面。

定义C操作，是翻某一个硬币。

题主的问题是若干次A操作之后能否达到某个状态，而一个A操作等同于做一次B一次C，注意到B和C操作是可交换的，因此可以理解为先做若干次数的C操作，然后再做相同次数的B操作。

而做若干次C操作相当于一个一个硬币地翻，所以第i次翻转就是翻转除了第i个硬币以外的所有硬币。

##证明2

当然，也可以这样解释：做一个很简单的变换--把每次翻转5个硬币，分解成两步：

1、把一个硬币翻转一次；

2、把所有的硬币翻转一次

如果p为偶数，那么上面的第二步实际上被抵消了，所以相当于每次只做第一步。所以p=6.

如果p是奇数，那么相当于每次只做第一步，最后把所有的硬币翻一次面，这等价于只做奇数次第一步，最后保持所有的硬币仍然是正面向上，这显然是不能做到的。

综上，p=6

##证明3

要让所有硬币翻过来，要做的就是每个硬币翻奇数次。

总共六个硬币，每次翻五个。

那么情况就只有每个硬币翻一次、三次、五次。

但是每次只能翻五个，不能多不能少，所以就要求总共翻的次数是5的整倍数。

所以就是每个硬币翻五次。总共翻了5x6=30次

每次翻5个

30/5=6次

答：最少翻六次

Pascal的标准程序：

```cpp
var n,i,j:longint;
    a:array[1..100]of 0..1;
begin
 readln(n);
 writeln(n);
 for i:=1 to n do begin
  for j:=1 to n do
   if i<>j then a[j]:=1-a[j];
  for j:=1 to n do write(a[j]);
  writeln;
 end;
end.
```

---

## 作者：Created_equal1 (赞：73)

数学方法：第i次翻转就是翻转除了第i个硬币以外的所有硬币。

证明略。

```cpp

(

#include <cstdio>
#include <cstring>

const size\_t Max\_N(106);

size\_t N;
bool Str[Max\_N];

size\_t i;

int main()
{
    scanf("%u", &N);
    
    printf("%u\n", N);
    while (i < N)
    {
        for (size\_t k = 0;k != N;++k)
        {
            if (i != k)
                Str[k] = !Str[k];
            printf("%u", Str[k]);
        }
        printf("\n");
        ++i;
    }
    
    return 0;
}
)

---

## 作者：「已注销」 (赞：21)

## 思路
翻$n-1$个硬币等于翻$1$个硬币再全部翻面

即$n$次全翻$,$再$n$次翻$1$个硬币

第$i$步操作$:$全部翻转$,$翻转第$i$个硬币

由于$n$是偶数$,$翻$n$次恰好全部翻转

## 实现
使用`std::bitset`简单便捷
```cpp
#include<bitset>
#include<iostream>
using namespace std;
int n,i;
bitset<100>b;
int main(){
    cin>>n;
    cout<<n;
    i=n;
    while(i--){
        b.flip();
        b.flip(i);
        cout<<'\n'<<b.to_string().substr(100-n,n);
    }
}
```
#### 注
`bitset<100>b`：构造一个长度为$100,$名为b的布尔数组

`b.flip()`：反转数组$(0->1,1->0)$

`b.flip(i)`：反转数组第$i$位$($最低位为第$0$位$)$

`b.to_string()`：转换为字符串

[`substr()`](https://zh.cppreference.com/w/cpp/string/basic_string/substr)：取字符串子串

---

## 作者：Viktley (赞：13)

~~本人是个超水的蒟蒻！！~~
							
                            提前声明 呵呵
好了，现在我们进入正题

题目传送门：
[硬币翻转](https://www.luogu.org/problem/P1146)

仔细读题便能知道，这其实一道水题，只需反向思考，其实题目还可以认为是:

**每次翻一枚硬币！！！


------------
**直接上代码：：

```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
bool f[110];
int main()
{
	int n;
    cin>>n;
    cout<<n<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(j!=i){
                if(f[j])f[j]=0;
                else f[j]=1;
            }
            cout<<f[j];
        }
        cout<<endl;
    }
    return 0;
}
```

**谢谢

---

## 作者：雷州半岛岛主 (赞：12)

**想让每个银币转n次变成反面朝上，显然n为奇数。**

1. 再进一步推算，假如是4个硬币，那么每个硬币就会被转3
次，x个硬币就会转x-1次。

2. 再跟着样例看，很明显：

	for一个i从1到n
		  除了a[i]之外，其他的都翻一遍。
3. 问我怎么来的规律？

很简单啊，
从第一次和初始状态（0000）的对照中我们可以看出只有第一个数字没变，从第二次和第一次的对照中我们可以看出只有第二个数字没变，从第三次和第二次的对照中我们可以看出只有第三个数字没变……以此类推）

所以……

------------
```c
	#include<bits/stdc++.h>
	using namespace std;
	int main()

	{

		int n; 
		cin>>n;
		bool a[1000];
		cout<<n<<endl;
		for (int i=1;i<=n;i++)//n个硬币
    	{
			for (int j=1;j<=n;j++)//其他几个硬币
			{
				if (i==j) a[j]=a[j];//除了自己其他都翻
				else a[j]=not a[j];//翻
				if (a[j]==true) cout<<1; 
                else cout<<0;
			}
			cout<<endl;
		}
	}
```


------------


---

## 作者：LionShiZi (赞：9)

## 这题貌似没人用$python3$,写一个试试:)
```python
n=int(input())
a=[]
print(n)
for i in range(1,n+10,1):
    a.append(0)
for i in range(1,n+1,1):
    for j in range(1,n+1,1):
        if j!=i:
            if a[j]!=0:
                a[j]=0
            else:
                a[j]=1
        if j==n:
            print(a[j])
        else:
             print(a[j],end="")
```
第1行输入n，不多讲

第2行创建空列表a

第3行因为相当于只翻1枚，所以翻n次即可

第4-5行a[0]-a[n]项置0

第6-最后1行持续翻转

---

## 作者：LZXF (赞：8)

# 这道题我们先试着找一下规律
按照例题：
输入：4

输出：4

0111
1100
0001
1111

有发现什么吗？
## 有n枚硬币就翻转n次
这个不难发现吧，为什么是这样呢？

翻n-1枚硬币其实就可以看成翻一枚硬币 ~~上面有题解写了吧~~

所以......就这样
## 翻转第n次，当n为奇数时，1~n位的数字都是0
嘿嘿，细心的小伙伴应该有发现的吧；

其实就像开始说的，翻n-1次硬币就相当于翻1枚硬币，但也不能完全相同。

第一次翻面，例题给的是0111，翻了后面3枚，而第一枚不翻，但其实也可以翻成1110，之后都可以翻成1111，呢有人就问了，这答案不确定了怎么检测？
嘿嘿，别忘题目呢个玄学的字典序~~其实我也不明白什么意思~~

不过按例题咋们就知道，开始翻就是翻后面的

而后面的翻第3次是0001，能证明我猜想的规律

所以现在我要解释一下了：

先把n-1次看成翻一次~~我说了好多遍了吧~~，但是不能完全相同，是因为你翻了除了呢一枚的其他所有枚硬币，所以才看上去像是你就翻了一枚硬币。而起始状态是全部都是正面朝上，呢你就当你要翻第一枚硬币，呢为了让你的第一枚硬币像是翻了一样，后面的所有硬币是不是都得翻。

呢下一个规律就来了

## 翻转第n次，当n位偶数时吗，1~n的数字都是1
我们继续看例题，第二次它翻转成了1100，符合我们的规律，呢这是为什么呢？

我们开始是翻成了0111，我们现在想让第二枚硬币看上去像翻了似的，呢得保证第二枚不动吧。然后就变成了1100。

呢我对这个规律最好的解释，就是你把奇数次翻转看成之前每一次都翻转一枚（之前不是说n-1次翻转可以看成翻一次吗），每一枚都翻转成0；而偶数次翻转看成之前每一次都翻转一枚，每一枚都翻转成1

再最后实验得到普遍规律~~我是物理课代表~~

当n是3的时候
011
110
000
当n是6的时候
011111 110000 000111 111100 000001 111111

完美，上代码


```
#include<cstdio>
#include<iostream>
 
using namespace std;

int a[101]={0};

int main()
{
	int n;
	cin>>n;
	cout<<n<<endl;
	for(int i=1;i<=n;i++)
	{
		if(i%2!=0)
		{
			for(int j=1;j<=i;j++)
				a[j]=0;
			for(int j=i+1;j<=n;j++)
				a[j]=1;
		}
		else
		{
			for(int j=1;j<=i;j++)	
				 a[j]=1;
			for(int j=i+1;j<=n;j++)
				a[j]=0;
		}
		for(int k=1;k<=n;k++)
			cout<<a[k];
		cout<<endl;	
	}
	return 0;
}


```
~~~~~~~~

---

## 作者：right_cat (赞：7)

## **题意概括：**
**给定一个长度为n的数列a[1],a[2],...,a[n],初始值均为0，现进行每次操作：选定该数列的某一个数不取反，其余n-1个数均取反。最终使得该数列值均为1。求最少的操作次数和字典序最小的操作方式。**

## **解题思路：**

这道题要解决两个问题：1、最少的操作次数。2、字典序最小的操作方式。

#### 第1问：最少的操作次数是多少？

对于数列的a[i],设a[i]取反的次数为b[i],显然b[i]为奇数。

设最少的操作次数为m,则有：b[1]+b[2]+ ... +b[n] = m * (n - 1),等式左边为偶数，等式右边的（n - 1）为奇数，所以m定为奇数。

同时有：（m - b[1]) + (m - b[2]) + ... +(m - b[n]) = m,设c[i]为a[i]不取反的次数, 则有c[1] + c[2] + ... + c[n] = m,因为m为奇数，所以全部的c[i]均为奇数，要使m最小，显然是让c[i]最小，所以c[1] = c[2] = ... = c[n] = 1，所以m = n，即最少的操作次数是n。

#### 第2问：字典序最小的操作方式是什么？

由于在第1问中得到c[1] = c[2] = ... = c[n] = 1,所以说明对于每个a[i],都有且仅有1次不取反的机会，所以怎么安排这些不取反的机会就很重要。

显然，要让字典序最小，就是让高位尽量小，又因为0 < 1，结合样例得到：对于第i次操作，选定a[i]不取反，其余n-1个数均取反是字典序最小的操作方式。

## **代码实现：**
```cpp
#include <cstdio>

const int MAXN = 100;

bool a[MAXN + 5];

int main() {
	int n;
	scanf("%d", &n);
	printf("%d\n", n); //n就是最少的操作次数
	for(int i = 1; i <= n; i++)
		a[i] = 0; //初始序列均为0 
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(i != j) //第i次让a[i]不取反 
				a[j] = !a[j];
			printf("%d", a[j]);
		}
		putchar('\n');
	}
}
```


---

## 作者：junjun_ccc (赞：5)

 _**~~这是本蒟蒻第一次发题解，dalao勿喷~~**_  
 可以先找一个例子n=8   
 8  
 01111111  
 11000000  
 00011111  
 11110000  
 00000111  
 11111100  
 00000001  
 11111111  
 就可以看出来一些规律   
 一共要n次  
 在第i行中，如果i是奇数，那么就有i个0和n-i个1，如果是偶数，那么有i个1和n-i个0   
 _**~~证明：略~~**_   
 话不多说先上代码     
 ```
#include<bits/stdc++.h>//万能头 
using namespace std; 
int n;//和题中的一样 
int main(){
	scanf("%d",&n);//输入输出不用说了 
	printf("%d\n",n);
	for(int i=1;i<=n;i++){//输出那n次 
		if(i%2){//i%2可能是1或0，如果i是奇数，那么i%2是1，条件成立 
			for(int j=1;j<=i;j++)printf("0");//输出i个0 
			for(int j=i+1;j<=n;j++)printf("1");//输出n-i个1
		}
		else{
			for(int j=1;j<=i;j++)printf("1");//输出i个1
			for(int j=i+1;j<=n;j++)printf("0");//输出n-i个0
		}
		printf("\n");//换行不要忘 
	}
	return 0;//大功告成 
}
```

---

## 作者：何炳儒 (赞：5)

看上去是个广搜不是吗？？？


其实事实上这真的是一道蒟蒻题啊啊啊。


我们来事实模拟一下n=6时的情景


、011111==>一个0五个1

、110000==>两个1四个0

、000111==>三个0三个1

、111100==>四个1两个0

、000001==>五个0一个1

、111111==>六个一


相信大家都看出规律来了，那么直接上代码。。


史上最短代码来了！！！！


```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    cout<<t<<endl;
    for(int i=1;i<=t;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(i%2==1)
                cout<<"0";
            else
                cout<<"1";
        }
        for(int j=i+1;j<=t;j++)
        {
            if(i%2==1)
                cout<<"1";
            else
                cout<<"0";
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：yali_hzy (赞：4)

证明有解：

设翻了x次，总共翻了y轮（指翻过的硬币数除以这排的硬币数）

由题意得：x\*(n-1)=y\*n

因为n为偶数，n-1为奇数

所以x为偶数

又n与n-1互质

当x,y最小时

x=n
y=n-1
所以，只要翻n次

剩下的靠样例理解

当然处理时可以用位运算

代码：

```cpp
#include<cstdio>
using namespace std;
int n,i,j,k,a[110];
int main()
{
    scanf("%d",&n);
    k=1;
    printf("%d\n",n);
    for(i=1;i<=n;i++,k++,putchar('\n'))
    {
        for(j=1;j<n;j++)
            a[(j+k-1)%n+1]^=1;
        for(j=1;j<=n;j++)
            printf("%d",a[j]);
    }
}
```

---

## 作者：eagadsgbsadfhb (赞：4)

```cpp

这道题，有3个地方要自己想出来：
1、第i次翻转的是除了第i个以外的所有的硬币。
2、第i次输出：1~i输出1-i%2，其它输出i%2。
3、n个硬币翻转n次。
证明：
输入2：
2
01
11
输入4：
4
0111
1100
0001
1111
输入6：
6
011111
110000
000111
111100
000001
111111
......
整理输出的2+行，微调：
0\1
11\ 

0\111
11\00
000\1
1111\

0\11111
11\0000
000\111
1111\00
00000\1
111111\
一条\分开了输出的2+行。

代码献上：
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>/\*没事做，库全开了\*/
int main()
{
    int n;
    scanf("%d",&n);
    printf("%d\n",n);
    for(int i=1;i<=n;i++)
    {
        int k=1-i%2;
        for(int j=1;j<=i;j++)
            printf("%d",k);
        for(int j=1;j<=n-i;j++)
            printf("%d",1-k);
        printf("\n");/\*直接模拟\*/
    }
    return 0;
}

---

## 作者：欧阳锋Oliver (赞：3)

蒟蒻一枚，用布尔型数组AC了本题，还请大神们多多指教！！！

代码很简单，如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[101];//定义数组
int main()
{
    int n;
    cin>>n;//输入
    cout<<n<<endl;//输出n
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i!=j)//如果不相等
                f[j]=!f[j];//翻转硬币
            cout<<f[j];//直接输出    
        }
        cout<<endl;//输出回车
    }
    return 0;//大功告成
}
```

---

## 作者：yeatom (赞：2)

# 一次失败的题解。

因题目非常像二进制，长话短说，pseudocode：

		取整数n（<=100)
		2的n次方-1 // 二进制代表了有n个1
    	for（循环n次）
    		翻第一个币
    		for（循环n次）
        	翻全部的币
        	输出
    	输出

^：亦或（半加运算）<</>>：左右移。

实现起来：

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    int square,n,m;
    bool output;
    scanf("%d",&n);
    m=n;
    square=pow(2,n)-1;
    cout << n << endl;
    for(int i=m-1;0<=i;i--){
        square ^= 1 << i;//比如i是3,square=15(1111),也就是第四位,等式左边由0001变成1000,再进行半加运算,square=0111,就是取反,也就是翻指定位置上的币子。
        for(int j=m-1;0<=j;j--){
            square ^= 1 << j;
            output = (( (square>>j)&1 ) ==0)?1:0;
            cout <<output;
        }
        cout << "\n";
    }
    return 0;
}
   
```
最终没有成功在于，2的一百次方太大了，最长的usigned long 才20位，但是我花了一天时间入门了数理逻辑。
	


---

## 作者：Fireflying (赞：2)

（我的代码应该跟那些大佬的不太一样吧，不知道能不能过）

同之前几位dalao说的一样，

## 翻n-1枚硬币等同于翻一枚（仅限于偶数枚）

~~然而沙雕的我一开始没读题一直在处理n为奇数的情况~~

所以说思路是：

首先把第一枚翻开

然后全部翻转一遍

再把第二枚翻回来

然后全部翻转一遍

......

以此类推

就得到以下代码：

```
#include<iostream>
#include<cstdio>
using namespace std;
int a[101],n;
void fz()//全部翻转的函数
{
	for(int i=1;i<=n;i++)
	if(a[i]==1)a[i]=0;
	else a[i]=1;
}
int main()
{
	cin>>n;
	cout<<n<<endl;//先把它输出了，免得后来忘记，别忘换行
	for(int i=1;i<=n;i++)//n次操作
	{
		if(a[i]==1)a[i]=0;//翻转第n枚
		else a[i]=1;
		fz();//然后全部翻一遍
		for(int j=1;j<=n;j++)
		cout<<a[j];//输出当前情况
		cout<<endl;
	}
    return 0；//结束
 } 

```
实际上这种红题根本没必要防作弊，但我还是加了，各位dalao应该能看出来吧。

蓝名蒟蒻，在线求过


---

## 作者：杨秦懿 (赞：2)

# **~~这道题目好水啊~~**
Made by [东小杨秦懿](https://www.luogu.com.cn/user/175958)

#  !!!!!题目可以改成——
```
在桌面上有一排硬币，共N枚，每一枚硬币均为正面朝上。现在要把所
有的硬币翻转成反面朝上，规则是每次可翻转任意1枚硬币（正面向上
的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次
翻转1枚硬币成为一次操作）。
```
那就是——

n个硬币n种方法

方法是：           

0 0 0 0 0 0

1 0 0 0 0 0
  
 1 1 0 0 0 0
 
 1 1 1 0 0 0
 
  1 1 1 1 0 0
  
  1 1 1 1 1 0
  
  1 1 1 1 1 1
  
而按原题方法，则是

翻第i次时，除了i号硬币外都翻。

程序
```
#include<bits/stdc++.h>
using namespace std;
int a[105]={0};
int main(){
	int n;
	cin>>n;
	cout<<n<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(j!=i)a[j]=1-a[j];
		}
		for(int j=1;j<=n;j++){
			cout<<a[j];
		}
		cout<<endl;
	}
	return 0;	
}
```


---

## 作者：chengchenghao (赞：2)

# 这题有一个规律：

有几枚硬币就要翻几次

定义一个变量c

把c加1，c=1，n=4

把除第c个的硬币翻转
，现在为：

0 1 1 1

把c再加一，c=2

把除第c个的硬币翻转
，现在为：

1 1 0 0

把c再加一，c=3

把除第c个的硬币翻转
，现在为：

0 0 0 1

最后把除最后一个硬币翻转，即为：

1 1 1 1


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>

using namespace std;
int n,a[100000],k=1;
int main()
{
  
  cin>>n;
  cout<<n<<endl;
  for(int i=1;i<=n;i++)
  {
  	for(int j=1;j<=n;j++)
  	{
  		if(a[j]==1&&j!=k)a[j]=0;
  		else if(a[j]==0&&j!=k)a[j]=1;
  		cout<<a[j];
  	}
  	cout<<endl;
  	k++;
  }
  
  return 0;
}
```


---

## 作者：重回巅峰！ (赞：2)

因为每次只翻N-1个数，所以我们可以发现：相对于N个硬币来说，翻N-1个硬币与翻1个硬币效果相同。。。。。

证明：

假设有下列硬币排列0 0 0 0 0

我们翻N-1个：        1 1 1 1 0

这些硬币的反面长这样：0 0 0 0 1

、、、、、、、、

这与只翻一个相同。

没了

---

## 作者：XCD_OIworld_rookie (赞：1)

先送表（20）
```cpp

2
01
11

--------------------
4
0111
1100
0001
1111

--------------------
6
011111
110000
000111
111100
000001
111111

--------------------
8
01111111
11000000
00011111
11110000
00000111
11111100
00000001
11111111

--------------------
10
0111111111
1100000000
0001111111
1111000000
0000011111
1111110000
0000000111
1111111100
0000000001
1111111111

--------------------
12
011111111111
110000000000
000111111111
111100000000
000001111111
111111000000
000000011111
111111110000
000000000111
111111111100
000000000001
111111111111

--------------------
14
01111111111111
11000000000000
00011111111111
11110000000000
00000111111111
11111100000000
00000001111111
11111111000000
00000000011111
11111111110000
00000000000111
11111111111100
00000000000001
11111111111111

--------------------
16
0111111111111111
1100000000000000
0001111111111111
1111000000000000
0000011111111111
1111110000000000
0000000111111111
1111111100000000
0000000001111111
1111111111000000
0000000000011111
1111111111110000
0000000000000111
1111111111111100
0000000000000001
1111111111111111

--------------------
18
011111111111111111
110000000000000000
000111111111111111
111100000000000000
000001111111111111
111111000000000000
000000011111111111
111111110000000000
000000000111111111
111111111100000000
000000000001111111
111111111111000000
000000000000011111
111111111111110000
000000000000000111
111111111111111100
000000000000000001
111111111111111111

--------------------
20
01111111111111111111
11000000000000000000
00011111111111111111
11110000000000000000
00000111111111111111
11111100000000000000
00000001111111111111
11111111000000000000
00000000011111111111
11111111110000000000
00000000000111111111
11111111111100000000
00000000000001111111
11111111111111000000
00000000000000011111
11111111111111110000
00000000000000000111
11111111111111111100
00000000000000000001
11111111111111111111
```
AC
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    cout<<n<<endl;//据打表的n有n次 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if((i%2==1&&j<=i)||(i%2==0&&j>i))
                cout<<"0";
            else
                cout<<"1";
        }
        cout<<endl;
    }//据打表的 
    return 0;
} 
```


---

## 作者：Scarlet_Lightning (赞：1)

~~一道水的不能再水的题~~

纯模拟直接AC~~~O(∩_∩)O

讲一下主要思想：如果仔细审题，不难看出，只要把正面向上的硬币翻动奇数次，则他一定会变成反面向上。所以每经过一个硬币就把除这个硬币以外的硬币都翻动一下，一定能达到要求。（因为除掉这个硬币以外只剩N-1个硬币，题目又说N是偶数，所以上过小学的同志们都知道，N-1必定是奇数）

起初本蒟蒻是利用for循环来实现翻动的，后来发现好像有BUG：
	
    for(int i=1;i<=1;i++)
    {
    	cout<<"xxx";
    }
    
本蒟蒻惊喜的发现：运行结果竟然是"xxx"而不是没有！！！
于是本蒟蒻又改成了while循环
	
    int p=1;
    while(p<1)//这下就不会一下子就执行了
    {
    	cout<<"xxx";
    }

没错，运行结果确实是什么都没有。然后本蒟蒻又惊喜的发现：while循环放到实际程序里太麻烦了。作为蒟蒻的我当然无法胜任这么复杂的操作TAT。。。——然后我又发现，要用两个for翻动前面的和后面的硬币，前面翻一次不该翻的硬币，后面再翻一次不就等于什么都没干么？？好像问题就这样解决了诶！！！(本蒟蒻表示很高兴〃'▽'〃)
	
    int n=0; 
	for(int i=1;i<=1;++i)
    {
    	if(n==0)
        {
        	n=1;
        }
        else
        {
        	n=0;
        }
    }//第一次翻了不该翻的硬币
    for(int i=1;i<=1;++i)
    {
    	if(n==0)
        {
        	n=1;
        }
        else
        {
        	n=0;
        }
    }//第二次又把它给翻回来了
    
很神奇对不对？？？~~反正本蒟蒻不信~~

好了废话不多说，接下来请欣赏本场重头戏——无敌的AC代码！！
    
    #include<iostream>		//不用说了-_-||
	using namespace std;
	int a[1000001];    //这里用来存储硬币的状态：0为正，1为反
	int main()
	{
		int n;
		cin>>n;    //输入硬币的枚数
		cout<<n<<endl;    //一共要翻动n次，每次不翻第i枚，所以
    //总共只需翻n次，直接输出n。
		for(int i=1;i<=n;++i)//通通初始化为0，及正面朝上
		{
			a[i]=0;
		}
		int p=1,p2,po,po2;//用while循环时用的指针，废物变量，
        //不要管它
		for(int i=1;i<=n;++i)//现在开始从第一个硬币开始翻动
		{
			for(int k=1;k<=i;++k)//翻动第i枚硬币前面的
			{
				if(a[k]==1)//翻动，是0则1，反之亦然
				{
					a[k]=0;
				}
				else
				{
					a[k]=1;
				}
			}
			for(int k=i;k<=n;++k)//翻动第i枚硬币后面的
			{
				if(a[k]==1)//同上
				{
					a[k]=0;
				}
				else
				{
					a[k]=1;
				}
			}		
			for(int k=1;k<=n;++k)//状态输出
			{
				cout<<a[k];
			}
			cout<<endl;
		}
        while(1)//反作弊，谁都不想棕名对吧？？？
	}

---

## 作者：AdzearDisjudge (赞：1)

看看样例，发现两个神奇的地方：

输出的次数就是n。

每次就是把除了i以外的翻转一下。

稍稍用点其他例子，就能发现这是个普遍规律。

放心地AC去吧。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,n) for(register int i=a;i<=n;++i)
#define per(i,a,n) for(register int i=a;i>=n;--i)
using namespace std;
inline int read()
{
    int f=1,x=0;
    char ch;
    do
    {
        ch=getchar();
        if(ch=='-')
        f=-1;
    }
    while(ch<'0'||ch>'9');
    do
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    while(ch>='0'&&ch<='9');
    return f*x;
}
int n;
bool b[101]={0};
int main()
{
    n=read();
    cout<<n<<endl;
    rep(i,1,n)
    {
        rep(j,1,n)
        {
            if(j!=i)
            b[j]=!b[j];
            cout<<b[j];
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：wanglichao1121 (赞：1)

##思路

看起来是搜索，其实数学方法还是比较高效的。

从样例中可以看出：第i次翻转翻转的是除第i个以外的所有硬币，瞬间过

##上标程

```delphi

var n,i,j:longint;a:array[1..100]of 0..1;
begin
  readln(n);
  for i:=1 to n do
  a[i]:=0;
  writeln(n);
  for i:=1 to n do
  begin
  for j:=1 to n do
  if i<>j then a[j]:=1-a[j];
  for j:=1 to n do
  write(a[j]);writeln;
  end;
end.

```

---

## 作者：WAWA (赞：1)

# 这题好水啊！！！！！


## 翻n-1枚硬币，就是有一枚不翻，也可以理解为翻一枚
### 其实这题我~~想了好久~~，广搜，深搜，~~暴搜（下下策）~~……~~（因为老师说这题是搜索，emmm~）~~

然后才发现：

## 翻n-i枚硬币，就是有一枚硬币没有翻，相当于翻了一枚硬币

所以题目就变成了：

#### *在桌面上有一排硬币，共N枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，（再次重申，0或1就是正或负，也代表正反两面），题意是每次可翻转任意1枚硬币（正面向上的被翻转为反面向上，反之相反）。求一个最短操作序列（将每次翻转N-1枚硬币就是一次操作）。*


## 很简单是不是？上代码！
```
#include<bits/stdc++.h>
using namespace std;
bool a[101];//,因为数据最大是一百，所以数组开到101。
//我上次就因为开小了，就QAQ。
//a数组负责存储硬币的状态
int n;
int main()
{
    cin>>n;
    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可
    for(int i=0;i<n;i++)//i表示这是第几次翻
    {
        for(int j=0;j<n;j++)//表示当前翻得是第几枚硬币
        {
            if(j!=i)//如果j不等于i,则两数不相等，即一正一反
            {
                if(a[j])//也可以表示成if(a[j]==ture)或if(a[j]==1),新手最好写成这样，易于理解。意思是如果不为第i枚 。                        
                {
                     a[j]=false;//利用bool数组的非负即正的性质来翻面。0与1就代表负和正，即正面和反面。
                }
                else//也可以表示成if(!a[j])、if(a[j]==false)或if(a[j]==0)。意思是如果为第i枚 。
                {
                    a[j]=true;//翻面
                }
            }
            cout<<a[j];//处理一个就输出一个，很快捷。
        }
    }
    return 0;//完结撒花！！！！！
}
```
### 代码完结，从这一题我们知道或复习了**bool**数组的性质，非负即正（记住，它 _极其好用_ ）
# 拜拜～(￣▽￣～)(～￣▽￣)～ 



---

## 作者：Red_Bands_whk (赞：0)

不想那些什么规律，就标程可以看出翻n次，可以用循环for i:=1 to n do 每次翻i以外的n-1个  //用字符串做



代码：

```cpp
var
        i,n,j:integer;
        s:string;
procedure f(x:integer);//翻硬币
var
        i:longint;
begin
        for i:=1 to n do
                if i<>x then//不是i就翻
        if s[i]='1' then s[i]:='0'
        else s[i]:='1';
end;
begin
        readln(n);
        writeln(n);
        s:='';
        for i:=1 to n do
                s:=s+'0';//设置为四个‘0’
        for i:=1 to n do
        begin
                f(i);//翻硬币
                writeln(s);//输出
        end;
end.
```

---

## 作者：좌초 (赞：0)

首先说，这是很有规律的！次数有规律，输出的0和1的位置也有规律！！！

偶数行就是1；奇数行就是；

第一行1个0（剩下的补1），第二行开头就2个0（剩下的补1）；

第x（偶数为例）行有x个1，就有n-x个0；依次。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,f=1;//f用来记录该输出1还是0！！
int main()
{
    cin>>n;cout<<n<<endl;
    int x=1,i;
    while(x<=n)
     {
         if(f==0)f=1;//一共有三次变化，前中后，可能能简化，求大神Help！
         else f=0;
         for(i=1;i<=x;i++)printf("%d",f);//输出x个0，
         if(f==0)f=1;
         else f=0;
         for(i=x+1;i<=n;i++)printf("%d",f);//在输出n-x个1
         cout<<endl;
         x++;
         if(f==0)f=1;//配合开始时的变化,先对调一次！！！忘了就错了！！
         else f=0;
     }
    return 0;
}
```

---

## 作者：老章桐志 (赞：0)

# 蒟蒻一枚，第一次发题解
我们先枚举几个答案：

输入：2

输出：2 01（**比 _10_ 字典序小**）11

输入：4

输出：4 0111 1100 0001 1111

输入：6

输出：6 011111 110000 000111 111100 000001 111111


------------
我们可以发现，首先输出的必然是**n**，然后依次是：1个0、n-1个1，n-2个1，2个0......

于是我们可以通过**二次循环**来判定需要输出几个0，几个1

代码：
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main(){
	int n;
	cin>>n;
	cout<<n<<endl;//直接输出n
	for(int i=1;i<=n;i++){//输出n次
		if(i&1){//判定是否为奇数决定先输出0还是1
			for(int j=1;j<=i;j++) cout<<0;
			for(int j=n-i;j>=1;j--) cout<<1;
			cout<<endl;//换行
		}
		else{
			for(int j=1;j<=i;j++) cout<<1;
			for(int j=n-i;j>=1;j--) cout<<0;
			cout<<endl;
		}
	}
	return 0;
}

```
##### 在下蒟蒻，写的不好请多包涵


---


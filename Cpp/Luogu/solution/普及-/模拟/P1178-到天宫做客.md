# 到天宫做客

## 题目描述

有一天，我做了个梦，梦见我很荣幸的接到了猪八戒的邀请，到天宫陪他吃酒。我犹豫了。天上一日，人间一年啊！当然，我是个闲人，一年之中也没有多少时日是必须在人间的，因此，我希望选一个最长的空闲时间段，使我在天上待的时间尽量长。记住，今年是 $4000$ 年。天上一天也是 $24$ 小时，每小时 $60$ 分，每分 $60$ 秒。


## 说明/提示

### 样例解释（2023.9.29 新增）

$4000$ 年是闰年，共有 $366$ 天，其中二月份有 $29$ 天。

最长连续空闲时间是从 $3$ 月 $9$ 日至 $12$ 月 $1$ 日一共 $268$ 天。对应着天上的 $86400\times 268 \div 366=63265.57\approx 63266$ 秒。

## 样例 #1

### 输入

```
2
3 8
12 2```

### 输出

```
63266```

# 题解

## 作者：Rocket_raccoon_ (赞：36)

应该属于比较简单的解法了qwq

先把每月的天数算出来，再把输入的时间预处理一下，便于算出时间间隔。然后排序比较大小，取最大值输出转化后的时间即可。

这里要注意从一年开始开始到第一天到人间的时间段和到年尾的时间段。

具体的细节算法在注释中都体现了
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int num[66666],ans;
double k;
int f[13]={0,0,31,60,91,121,152,182,213,244,274,305,335};
//预处理每月的天数，注意C++的默认数组下标是从0开始的
int main(){
	int i,a,b,n;
	
	cin>>n;
	
	for (i=1; i<=n; i++){
		cin>>a>>b;
		num[i]+=f[a];
		num[i]+=b;//处理天数
	}
	sort(num+1,num+n+1);//STL模板的sort快排
	num[n+1]=367; //一年的末尾（想一想为什么要用367）
	for (i=1; i<=n+1; i++){
    //注意这里是从1开始循环，因为num数组是在main函数外定义的，所以num[0]值为0，因此可以处理第一段时间
		ans=max(num[i]-num[i-1]-1,ans);//ans取最大值
	}
	k=(ans*1.0*24*3600/366)+0.5;//处理时间，注意四舍五入，加上0.5在换成整数是很常见的方法
	ans=k;//强制转化为整数
	
	cout<<ans;//输出，完事
	
	return 0;
} 
```

---

## 作者：PTC06 (赞：19)

比较水的模拟。发现这题没有很多题解，发一个。

思路：

用一个数组f[]将一月至十二月之前累计的总共天数分别存起来。那么f数组就是这个样子：

```cpp
    f[1]=0;
    f[2]=31;
    f[3]=60;
    f[4]=91;
    f[5]=121;
    f[6]=152;
    f[7]=182;
    f[8]=213;
    f[9]=244;
    f[10]=274;
    f[11]=305;
    f[12]=335;
```
（也可以用int f[]={}）
然后要读入有事的日期。可以在输入时利用f数组求出输入的每个日期在这一年中是第几天。把date数组对应的这一个日期做标记。

```cpp
    for (i=1;i<=n;i++)
    {
        cin>>m>>d;
        tem=f[m];
        tem+=d;
        date[tem]=1;
    }
```
读入了有事的日期后，需要求最长连续天数。那么可以用一个循环，从1到366（4000是闰年），累加。到了有事的日期就将用来累计的变量清空。
```cpp
    for (i=1;i<=366;i++)
    {
        if (date[i]==1)
        {
            sum=0;
        } else sum++;
        if (sum>bi) bi=sum;
    }
```
把天数转换为秒数，然后除以366（除以366是因为天上一日，人间一年），最后输出即可。
顺便说一下，保留整数可以cout<<fixed<<setprecision(0)<<要输出的数字，当然，用printf更简便，直接加个.0即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
using namespace std;
int f[12],date[400];
double k;
long long i,n,m,d,tem,bi,sum;
int main()
{
    f[1]=0;
    f[2]=31;
    f[3]=60;
    f[4]=91;
    f[5]=121;
    f[6]=152;
    f[7]=182;
    f[8]=213;
    f[9]=244;
    f[10]=274;
    f[11]=305;
    f[12]=335;
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>m>>d;
        tem=f[m];
        tem+=d;
        date[tem]=1;
    }
    for (i=1;i<=366;i++)
    {
        if (date[i]==1)
        {
            sum=0;
        } else sum++;
        if (sum>bi) bi=sum;
    }
    k=bi*24*60*60*1.0/366;
    cout<<fixed<<setprecision(0)<<k;
}
```

---

## 作者：usqwedf (赞：8)

题外话：很纳闷为什么没有大神通过此题，是不屑么。。。

<hr>
其实只需 **求出最大连续时间** 即可。

由于一共只有一年三百六十七天，可以直接 **枚举**。

恩，也可以像我一样，**排个序** 做。

<hr>
显然 **时间/366\*24\*60\*60** 即为答案。

<hr>
题外话：有坑点||我太弱了。。。


---

## 作者：君莫哭 (赞：7)

```cpp
//请大家多多指教
//到天宫做客的题解： 
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long n,i,j,s,t,maxk,qt,y[1000],r[1000],yf[12],z;
int main()
{
  cin>>n;//输入有多少天必须待在人间 
  for(i=1;i<=n;i++)cin>>y[i]>>r[i];//输入在什么时间 
  yf[1]=yf[3]=yf[5]=yf[7]=yf[8]=yf[10]=yf[12]=31;
  yf[2]=29;
  yf[4]=yf[6]=yf[9]=yf[11]=30;
  //因为是4000年是闰年，二月份的天数就是29，而其他的天数照常。 
  for(i=1;i<=n-1;i++)
   for(j=i+1;j<=n;j++)
    if(y[i]>y[j]||y[i]==y[j]&&r[i]>r[j])
    {
      s=y[i];y[i]=y[j];y[j]=s;
      s=r[i];r[i]=r[j];r[j]=s;
    }
    //因为输入数据是无序的，所以我们在这里先进行排序 
  for(i=1;i<=n;i++)
  {
      z=t;t=0;
      for(j=1;j<=y[i]-1;j++)t+=yf[j];
      t+=r[i];
      //算出每一个时间段的时间 
      if(i>1)qt=t-z;else qt=t;
      //除了第一次不会重叠，其余从头开始加会重叠之前，所以要减去前面多余的  
    if(qt>maxk)maxk=qt;  //求出在天上最多的天数 
  }
  qt=366-t+1;if(qt>maxk)maxk=qt;maxk--;//边界处理 
  cout<<round(maxk*24*60*60*1.0/366);
  //求出到底有多少秒 
  //天上一日，人间一年，所以要除以366（闰年一年366天）
  //用round进行四舍五入处理 
  return 0;
}
```

---

## 作者：午尘 (赞：5)

也是模拟赛的一题qwq……写了六次才过qwq……

有点考语文啊qwq……



------------
 梳理一下题目要点：
 
 1.4000年能被400整除，所以是闰年，2月29天，全年366天。
 
 2.天上一日，人间一年。所以人间的一天等于天上的1/366天。
 
 

------------
 放代码：
 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k,s,a[1000001],b[1000001],x[1000001],y[1000001],maxn;
double ans;
struct qwq{
	int x;
	int y;
}d[1000001];
bool cmp(qwq xx,qwq yy){
	if (xx.x==yy.x) return (xx.y<yy.y);
	return (xx.x<yy.x);
}
int months(int p){
	if (p==1||p==3||p==5||p==7||p==8||p==10||p==12) return 31;
	if (p==2) return 29;
	if (p==4 ||p==6||p==9||p==11) return 30;
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d%d",&d[i].x,&d[i].y);
    sort(d+1,d+n+1,cmp); 
    for (i=1;i<=n;i++) { 
    	for (j=1;j<=d[i].x-1;j++)  b[i]+=months(j);
    	b[i]+=d[i].y;
    }
    b[n+1]=367;b[0]=0;
    for (i=0;i<=n;i++) a[i]=b[i+1]-b[i]-1;
    for (i=0;i<=n;i++) maxn=max(maxn,a[i]);
    maxn=maxn*24*60*60;
    ans=(maxn*1.0)/366.00+0.5;
    cout<<(int)ans<<endl;
    return 0;
}
   
```

```cpp
//a[i]表示b[i+1]-b[i]
```


------------

一些思路和坑点：

对于每一个宴会日期，算出它是那一年的第几天，然后算出每个宴会时间之间的差值。

还要算两头，一头是0，一头是367。

为了方便排序，运用了结构体。

---

## 作者：iao113 (赞：5)

模拟，注意边界1月1号，12月31号，

日期之间的距离多少天，都统计距离1月1号的天数相减即可。

[codec]

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <stack>
#include <cstring>
#include <string>
#include <queue>
#define maxn 2000 + 10
#define INF 0x3f3f3f3f
using namespace std;
int day[13] = {31,29,31,30,31,30,31,31,30,31,30,31};
struct node{
    int l,r;
    node (int l = 0, int r = 0):l(l),r(r){}
    bool operator < (const node & a)const{
        if( l == a.l) return r < a.r;
        return l < a.l;
    }
}no[maxn];
int cal(int i){
    int monl = no[i].l;
    int dayl = no[i].r;
    int ans = 0;
    for(int i=0;i<monl-1;i++)
        ans += day[i];
    ans += dayl;
    return ans;
}
int main(){
    int n;
    while(scanf("%d",&n)!=EOF){
        int ff = 0;
        int rr = 0;
        for(int i=0;i<n;i++){
            scanf("%d%d",&no[i].l,&no[i].r);
            if(no[i].l == 12 && no[i].r == 31)
                rr = 1;
            if(no[i].l == 1 && no[i].r == 1)
                ff = 1;
        }
        int l = n;
        if(!rr){
            no[l++] = node(12,31);
        }
        if(!ff){
            no[l++] = node(1,1);
        }
        sort(no,no + l);
        int maxx = -1;
        for(int i=1;i<l;i++){
            int tmp = cal(i) - cal(i-1) - 1;
            if(ff != 1 && no[i-1].l == 1 && no[i-1].r == 1){
                tmp++;
            }
            if(rr != 1 && no[i].l == 12 && no[i].r == 31){
                tmp++;
            }
            maxx = max(maxx,tmp);
        }
        double ans = ((double)maxx* (24*60*60)/366.0) ;
        if(n == 0){
            printf("%.f\n", 1.0*(24*60*60));<span style="display: none; width: 0px; height: 0px;" id="transmark"></span>
        }
        else
            printf("%d\n",(int)(ans+0.5));
            //printf("%.f\n",(ans));//一样可以四舍五入
    }
    return 0;
}
```
[/codec]

---

## 作者：户山香澄 (赞：3)

典型模拟题，比较水

···
const
day:array[0..11]of integer

=(0,31,60,91,121,152,182,213,244,274,305,335);//表示这一个月距离年初的天数








```cpp
var
  a:array[1..367]of boolean;
  n,m,d,i,t,max:integer;
begin
  readln(n);
  fillchar(a,sizeof(a),false);
  a[367]:=true;
  for i:=1 to n do begin
    readln(m,d);
    a[day[m-1]+d]:=true;//这一天标记为必须呆在人间
    end;
  t:=1;
  max:=0;
  for i:=1 to 367 do
    if a[i] then begin
      if i-t>max then max:=i-t;
      t:=i+1; 
      end;
  writeln(round(max*24*60*60/366));
end.
···
```

---

## 作者：封禁用户 (赞：3)

这道题其实就是求出两个日期隔了多少天

再求出每个间隔天数的最大值

转换成在天上的秒数就行了

注意一点，题目给出的几个日期不一定是有序的

所以，我们必须把所有日期排序

具体见代码：

```cpp
#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<cmath>
using namespace std;
int x[13]={0,31,60,91,121,152,182,213,244,274,305,335,366};
//建立一个日期部分和，这样就可以直接算出两个日期的间隔天数 
int s[100000],m[100000],d[100000],n;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        scanf("%d %d",&m[i],&d[i]);
        //输入必须待在人间的日期 
    }
    //将日期从小到大排序 
    for (int i=1;i<=n-1;i++)
    for (int j=i+1;j<=n;j++)
    if (m[j]<m[i]||m[j]==m[i]&&d[j]<d[i])
    //月数大或月数相同而日期大就交换 
    {
        swap(m[j],m[i]);
        swap(d[j],d[i]);
    } 
    s[1]=x[m[1]-1]+d[1]-1;
    //第一天得从1月1日算起，记得不能把这一天算进去 
    for (int i=2;i<=n;i++)
    {
        s[i]=x[m[i]-1]-x[m[i-1]-1]+d[i]-d[i-1]-1;
        //算出这一天和前一天间隔的天数 
    }
    s[n+1]=x[12]-x[m[n]-1]-d[n];
    //将最后一天到一年结束的天数算出 
    sort(s+1,s+1+n+1);//将算出的间隔排序 
    cout<<round((s[n+1]*1.0)/366*86400);
    //将最大的间隔转化成天数 
    return 0;
}
```

---

## 作者：三华生 (赞：2)

#分析：

求最大连续时间问题。一年一共最多只有三百六十六天，可以直接枚举，也可以排个序。最后\*24\*60\*60/366即为答案。一题模拟。

#程序：

```cpp
const day:array[1..11] of longint
          =(31,29,31,30,31,30,31,31,30,31,30);
var i,j,n,m,d,t,max:longint;
    s:array[1..367] of boolean;
begin
     read(n);
     fillchar(s,sizeof(s),false);
     s[367]:=true;
     for i:=1 to n do
     begin
          read(m,d);
          t:=0;
          for j:=1 to m-1 do t:=t+day[j];
          t:=t+d;
          s[t]:=true;
     end;
     t:=0; max:=0;
     for i:=1 to 367 do
         if s[i] then
         begin
              if i-t-1>max then max:=i-t-1;
              t:=i
         end;
     writeln((max*24*60*60+183) div 366);
end.
```
#反思:
此题关键是对时间的处理，只要能把时间的处理弄好，一切就迎刃而解。细节也很重要，千万别忘记最后的转换（ (max\*24\*60\*60+183) div 366 ）。


---

## 作者：UnyieldingTrilobite (赞：0)

咦？

好像没有python题解？

那juruo来交一发吧！

众所周知，python有个神奇的玩意datetime，可以解决很多时间问题。

比如这题，可以用一个数组记录每个日期到1月1日的时间差，这样算两个日期时间差就可以直接拿两个差一减然后减一了。

至于为什么不直接用与1月1日求差的方法直接求差······主要是sort的缘故，懒得写比较器了。

然后设置两个哨兵，分别是3999年12月31日与4001年1月1日，这两天必须在人间（方便统一处理）。

好了最后上代码：
```py
import datetime #包含进来
n=int(input())
f=[-1,(datetime.datetime(4000,12,31)-datetime.datetime(4000,1,1)).days+1]
#上面说的哨兵
ans=0
for i in range(n):
    a,b=input().split()
    f.append((datetime.datetime(4000,int(a),int(b))-datetime.datetime(4000,1,1)).days)
#记下时间差
f.sort()
for i in range(n+1):ans=max(ans,f[i+1]-f[i])
#计算最大间隔时间（哨兵发挥用场）
print("%.0lf"%((ans-1)*3600*24/366))
#注意精确到秒
#4000年是闰年所以是366
```
祝大家切题愉快！

~~不要问我为什么交了好几次才AC，因为窝python太菜了。~~

---


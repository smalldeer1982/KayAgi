# [TOIP2024] 6174

## 题目描述

公元 $1955$ 年，数学家卡布列克(D. R. Kaprekar)发现了以下有趣的性质：

对于所有位数不完全相同的 $4$ 位正整数，将其所有位数依数值由大至小排列所得到的数字减去由小至大排列所得到的数字，如此一来会得到另外一新的 $4$ 位正整数（包含前导零）。若重复上述步骤若干次，必定可以得到 $6174$ 这个数字。又因为以 $6174$ 重复上述步骤计算将会得到 $6174$ 自身，该性质如同黑洞一般只进不出，故 $6174$ 因此而得名「黑洞数」。

举例来说： 

$\newline
\qquad 2024 \longrightarrow 4220 - 0224 = 3996 \newline
\qquad 3996 \longrightarrow 9963 - 3699 = 6264 \newline
\qquad 6264 \longrightarrow 6642 - 2466 = 4176 \newline
\qquad 4176 \longrightarrow 7641 - 1467 = 6174 \newline
\qquad 6174 \longrightarrow 7641 - 1467 = 6174$

可得：

![](https://cdn.luogu.com.cn/upload/image_hosting/1ac3i6ge.png)

针对所有位数不完全相同的 $d$ 位数，也有类似的情况，只是最后不一定会停在单一一个数字，而是有可能在一群数字之间循环。例如当 $d = 5$ 时，以下是某两种循环的情形：
![](https://cdn.luogu.com.cn/upload/image_hosting/dbwzmjdv.png)

不难推论，不论 $d$ 为何，由任一数字开始必定会进入某些数字组成的循环之中（单一数字亦算作循环）。今给定 $n$ 个所有位数不完全相同的 $d$ 位数，请各自输出由该数字作为起始数字进行若干步骤计算后，进入循环时**第一个**遇到的数字。

举例来说，若以 $50985$ 作为起始数字进行若干步骤计算后可以得到如下的结果，可以发现在经过 $7$ 次步骤之后，会得到于先前计算中已经出现过的 $75933$，之后再继续计算将会进入循环之中，而 $75933$ 即为进入循环时**第一个**遇到的数字，故以本例子来说须输出 $75933$。 

![](https://cdn.luogu.com.cn/upload/image_hosting/r21etde8.png)


## 说明/提示

### 测试数据限制

* $2 \le d \le 10$。
* $1 \le n \le 10^4$。
* $1 \le s_i < 10^d$。
* 所有输入的数均为正整数。
* 保证 $s_i$ 在 $d$ 位数表示中所有位数不完全相同。
* 保证 $n$ 个数字进行若干步骤计算，进入循环时其总计算步骤数不超过 $10^5$。
 
### 评分说明

本题共有三组子任务，条件限制如下所示。  
每一组可有一或多笔测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $12$ | 输入满足 $d = 3$ 或 $d = 4$。 |
| 2 | $24$ | 输入满足 $2 \le d \le 6$ 且 $1 \le n \le 100$。 |
| 3 | $64$ | 无额外限制。 |

## 样例 #1

### 输入

```
4 4
2024
4167
4266
2024```

### 输出

```
6174
6174
6174
6174```

## 样例 #2

### 输入

```
3 5
50985
53955
95355```

### 输出

```
75933
53955
59994```

# 题解

## 作者：lukezang (赞：6)

这个题目难度并不高，所以我蓝名写题解应该没有问题吧。

本题基本思路就是循环题目描述中的步骤并判断是否重复，与之前重复就输出。

那就上代码吧。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],g[10005];
int main()
{
	long long n,b,cl,d,e,f,jc,bc;
	string c;
    cin>>n>>cl;
    for(int i=1;i<=n;i++)
    {
        cin>>c;
        jc=c.size()；//注意可能有前导零被删的数
        f=0;
        g[0]=0;
	    for(int j=0;j<jc;j++)
		{
	        a[j]=c[j]-'0';
            g[0]+=a[j]*pow(10,jc-j-1);
		}
        if(jc!=cl)
        {
            for(int j=jc;j<=cl;j++)
            {
                a[j]=0;
            }
        }
        for(int k=1;k<=10000;k++)
        {
        	if(f==1) break;
	        sort(a,a+cl);
	        d=0;
	        e=0;
	        for(int j=0;j<cl;j++)
	        {
	        	d+=a[j]*pow(10,j);//由大至小排列
	        	e+=a[j]*pow(10,cl-j-1);//由小至大排列
			}
			g[k]=d-e;
            for(int j=0;j<cl;j++)
	        {
	        	a[j]=g[k]/pow(10,j);
                a[j]=a[j]%10;
			}
			for(int j=0;j<k;j++)
			{
				if(g[k]==g[j])
				{
					f=1;
                    cout<<g[k]<<endl;
					break;
				}
			}
		}
    }
	return 0;
}
```

---

## 作者：AFO_Lzx (赞：5)

## [题目传送门](https://www.luogu.com.cn/problem/P11825)

### $\texttt{Solution}$

实际上就是按照题意模拟，但是细节有点多。因为数据范围达到了 $10^{10}$，正常的数组根本存不下，所以我们用哈希表存储是否进入循环。

还要注意当数字不满 $d$ 位的时候需要补充前导零，否则会 WA（答案错误）或者是 TLE（死循环）。

### $\texttt{Code}$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

unordered_map<int, bool> mp;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int T, d;
	cin >> T >> d;
	
	while (T--) {
		int n;
		cin >> n;
		mp.clear();
		mp[n] = 1;
		
		while (true) {
			string s = to_string(n);
			while (s.size() < d) s = '0' + s;
			sort(s.begin(), s.end());
			string s1 = s;
			reverse(s1.begin(), s1.end());
			int num1 = stoll(s), num2 = stoll(s1);
			int Next = num2 - num1;
			string s2 = to_string(Next);
			while (s2.size() < d) s2 = '0' + s2;
			Next = stoll(s2);
			
			if (mp.count(Next) && Next != 0) {
				cout << Next << "\n";
				break;
			}
			n = Next;
			mp[Next] = 1;
		}
	}
	
	return 0;
}
```

注意这一份代码不可使用 C++98 提交，因为有很多函数和 STL 在 C++98 中没有。完结。

---

## 作者：flying_bluecat (赞：5)

# P11825 [TOIP2024] 6174 题解

这题很水啊，数学+模拟就可以了。

本题要求我们将对于“黑洞数”的计算推广到每一位都互不相同的 $d$ 位正整数。我们可以一步一步的拆分：

1. 将给定的正整数的所有位数依数值由大至小排列，得到一个数 $a$；
2. 将给定的正整数的所有位数依数值由小至大排列，得到一个数 $b$;
3. 将 $a$ 减去 $b$，如此一来会得到另外一新的正整数（包含前导零）；
4. 若重复上述步骤若干次，必定可以得到一个固定的或者几个循环的数。

我们从步骤中不难发现，在实际编写代码的过程中，我们需要把数转换成数组进行排序，然后再把数组转换成数字相减做差（~~因为懒得写高精度~~）。

题目给定 $n$ 个所有位数不完全相同的 $d$ 位数，要求各自输出由该数字作为起始数字进行若干步骤计算后，进入循环时**第一个**遇到的数字。

举个例子，若以 $50985$ 作为起始数字进行若干步骤计算后可以得到如下的结果，可以发现在经过 $7$ 次步骤之后，会得到于先前计算中已经出现过的 $75933$，之后再继续计算将会进入循环之中，而 $75933$ 即为进入循环时**第一个**遇到的数字，故以本例子来说须输出 $75933$。 

![](https://cdn.luogu.com.cn/upload/image_hosting/r21etde8.png)

思路分析完了，也不要着急开始写，一定一定一定要看数！据！范！围！

* $2 \le d \le 10$。
* $1 \le n \le 10^4$。
* $1 \le s_i < 10^d$。

必须开 `long long`！！！！

上代码！

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>
using namespace std;

// 将数字转换为数字数组
vector<int> toarr(long long num, int d) {
    vector<int> arr(d);
    for (int i = d - 1; i >= 0; --i) {
        arr[i] = num % 10;
        num /= 10;
    }
    return arr;
}

// 将数字数组转换为数字
long long tonum(const vector<int>& arr) {
    long long num = 0;
    for (int digit : arr) {
        num = num * 10 + digit;
    }
    return num;
}

// 计算一次变换
long long calculate(long long num, int d) {
    vector<int> arr = toArray(num, d);
    sort(arr.begin(), arr.end());
    long long small = toNumber(arr);
    reverse(arr.begin(), arr.end());
    long long large = toNumber(arr);
    return large - small;
}

// 寻找循环起始数字
long long cycle(long long num, int d) {
    unordered_set<long long> visited;
    while (true) {
        if (visited.count(num)) {
            return num;
        }
        visited.insert(num);
        num = calc(num, d);
    }
}

int main() {
    int n, d;
    cin >> n >> d;
    for (int i = 0; i < n; ++i) {
        long long num;
        cin >> num;
        cout << cycle(num, d) << endl;
    }
    return 0;
}
```

---

## 作者：Vct14 (赞：5)

因为 $d\le10$ 且 $n\le10^4$，所以直接模拟即可。

对于每个数，我们取出它的各位分别升序降序排序后相减得到下一个数。用一个 `map` 来存储当前数是否出现过。如果之前出现过就意味着进入了循环，直接输出即可。

注意要开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;

int sz[12];
bool cmp(int a,int b){
	return a>b;
}

map<long long,bool> mp;

int main(){
	int n,d;cin>>n>>d;
	while(n--){
		long long s;cin>>s;mp.clear();
		while(1){
			long long ss=s;
			for(int i=d; i>=1; i--){
				sz[i]=ss%10;
				ss/=10;
			}
			if(mp[s]){
				cout<<s<<"\n";
				break;
			}
			mp[s]=1;
			long long mn=0,mx=0;
			sort(sz+1,sz+1+d);
			for(int i=1; i<=d; i++) mn=mn*10+sz[i];
			sort(sz+1,sz+1+d,cmp);
			for(int i=1; i<=d; i++) mx=mx*10+sz[i];
			s=mx-mn;
		}
	}
	return 0;
}
```

[繁體中文版本](https://www.luogu.me/paste/hhcl2wdq#)。（？

---

## 作者：dg114514 (赞：4)

模拟简单题。\
思路：每次按照题目模拟，用 `umap` 之类的哈希表即可判环。（作者用的是 `gp_hash_table`）即可复杂度 $O(n\cdot d\cdot stp)$。（$stp$ 即 $\sum c$，由于题目保证 $stp\le 10^5$ 所以可以通过）。`map` 则多加个 $\log stp$。

### 代码

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define rep(i,l,r) for(auto i=l;i<=r;i++)
#define int long long
constexpr int inf=1e18,N=5e5+5,mod=998244353,NN=1005;
using namespace std;
using namespace __gnu_pbds;
gp_hash_table<int,int>h;
inline int work(int n,int d){//d 位的 n 按照数位升序排序
	static int dig[11],top=0,cnt[11];
	int res=0;
	rep(i,1,d) dig[++top]=n%10,n/=10;
	rep(i,1,top) cnt[dig[i]]++;
	top=0;
	rep(i,0,9)
		while(cnt[i])
			res=res*10+i,cnt[i]--;
	return res;
}
inline int rev(int x,int d){//反转
	int res=0;
	rep(i,1,d) res=res*10+x%10,x/=10;
	return res;
}
signed main(){
	int T,d,n,t;
	cin>>T>>d;
	while(T--){
		h.clear();
		cin>>n;
		while(!h[n]){//如果出现过则有环
			h[n]=1;//记录
			t=work(n,d);
			n=rev(t,d)-t;//最大 - 最小
		}
		cout<<n<<"\n";
	}
	return 0;
}
```

---

## 作者：canwen (赞：4)

考察选手细心程度，注意到每个 $d$ 位数在不断变化的过程中位数一直会是 $d$。

设当前的数为 $x$，分解的时候条件应该是分解的次数小于 $d$，而不应该是 $x \ne 0$，这一点可能是跟多人一开始爆 $0$ 的原因。

其他没什么好讲的了，用 `map` 存储每个数字出现的次数，出现的次数等于 $1$ 时这个数字就是循环起点，然后模拟变化过程即可。

## Code
```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;
#define int long long
#define const constexpr
#define pc putchar('\n')
#define fst first
#define snd second
#define mk make_pair
#define i128 _int128
#define pb emplace_back
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define nowtime clock()/CLOCKS_PER_SEC
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
//#define getchar getchar_unlocked
int in(){
	char a=getchar();
	int k = 0, kk = 1;
	while(a > '9' || a < '0'){
		if(a == '-') kk = -1;
		a=getchar();
	}
	while(a>='0'&&a<='9'){
		k = k*10+a-'0',a=getchar();
	}
	return k*kk;
}
void out(int a){
	if(a < 0) putchar('-'),a=-a;
	if(a > 9) out(a/10);
	putchar(a%10+'0');
}
int n,d,tmp[100];
bool cmp(int a,int b){
	return a > b;
}
int maxn(int a){
	int tot = 0;
	while(a){
		tmp[++tot] = a %10,a/=10;
	}
	sort(tmp+1,tmp+1+tot,cmp);
	int cnt = 0;
	_rep(i,1,tot) cnt = cnt * 10 + tmp[i];
	return cnt;
}
int minn(int a){
	int tot = 0;
	while(a){
		tmp[++tot] = a %10,a/=10;
	}
	sort(tmp+1,tmp+1+tot);
	int cnt = 0;
	_rep(i,1,tot) cnt = cnt * 10 + tmp[i];
	return cnt;
}
map <int,int> m;
signed main(){
	n = in(), d = in();
	while(n--){
		int s = in();
		m.clear();
		while(m[s] == 0){
			m[s]++;
			s = maxn(s)-minn(s);
		}
		out(s), pc;
	}
	return 0;
}
```

---

## 作者：AnOIer (赞：4)

## 分析

纯模拟题。

把每次通过计算得到的正整数存在桶里，如果桶中已经有这个数了说明重复了，就把这个数输出。

具体分析见代码注释。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
map<int,bool> vis;
int ston(string str){//将字符串转为数字
	int ans=0,k=0;
	for(int i=str.size()-1;i>=0;i--){
		ans+=(pow(10,k)*((int)(str[i]-'0')));
		k++;
	}
	return ans;
}
int n,d;
int func(int n) {
	string num=to_string(n);
	if(num.size()<d) {//如果数字位数小于d要补0
		while(num.size()<d) num="0"+num; 
	}
	int num1,num2;
	sort(num.begin(),num.end());//从小到大排序
	num1=ston(num);
	reverse(num.begin(),num.end());//反转
	num2=ston(num);
	return num2-num1;//计算的答案
} 
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); 
	cin>>n>>d;
	for(int i=1;i<=n;i++) {
		vis.clear();//多测不清空见祖宗
		int s,ans=0;
		cin>>s;
		int p=s;
		vis[p]=1;//把第一个数存进桶里
		while(true) {
			p=func(p);
			if(vis[p]) {//重复了
				ans=p;
				break;
			}else vis[p]=1;
		}
		cout<<ans<<"\n";
	}
	return 0;
}

```

---

## 作者：jojo222 (赞：4)

浅浅使用暴力（似乎只有这一种方法）……

直接模拟变换，遇到第一个重复的数就是答案。如果有循环那么，第二遍循环的开头将成为重复的数。

注意 ${10}^{10}$！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, d, a[11], b[11];
long long s;
int main()
{
	cin >> n >> d;
	while(n--)
	{
		cin >> s;
		map<int, bool> mp;
		mp[s] = true;
		while(true)
		{
			long long x = s;
			for(int i = 1; i <= d; i++)
				a[i] = b[i] = x % 10, x /= 10;
			sort(a + 1, a + 1 + d, greater<int>());
			sort(b + 1, b + 1 + d);
			long long ta = 0, tb = 0;
			for(int i = 1; i <= d; i++)
				ta = ta * 10 + a[i], tb = tb * 10 + b[i];
			if(mp[s = ta - tb]) break;
			mp[s] = true;
		}
		cout << s << endl;
	}
	return 0;
}
```

---

## 作者：lzx111218 (赞：4)

# P11825 [TOIP2024] 6174
[题目传送门](https://www.luogu.com.cn/problem/P11825)
## 思路
有点毒瘤的一道模拟题。

**十年 OI 一场空，不开 long long 见祖宗。** 

问题的核心是不断进行数位排序和差值计算，直到出现重复的数字，从而形成一个循环。然后模拟。

不要用 `unordered_set`！会炸！
### 数位排序和差值计算部分
- 首先将数字转换为字符串形式，如果长度不足 $d$ 位，则补充前导零。然后分别对字符串进行**升序和降序**排序，计算两个新数的差值。
```cpp
long long check1(long long n, int d) {
    string s = to_string(n);
    while (s.length() < d) s = "0" + s;  
    sort(s.begin(), s.end());
    string a = s;    
    string b = s;    
    reverse(b.begin(), b.end());
    long long aN = 0, bN = 0;
    for (char c : a) aN = aN * 10 + (c - '0');
    for (char c : b) bN = bN * 10 + (c - '0');
    return bN - aN;  
}
```
**举个栗子：**

- 假设数字是 $2024$，首先将其转化为字符串并排序：
 - 将数字转化为 $d$ 位的字符串。如果数字的位数不够   $d$ 位，则通过**补零来保证其位数**。

 - 对这个数字的每一位进行升序和降序排序，得到两个新的数字。

  升序排序：$0224$。

  降序排序：$4220$。
### 循环检测部分
 - 我们需要记录每个经过的数字。一旦发现一个数字出现过，就说明我们进入了循环。我们应该输出**首次**进入循环时遇到的数字（也就是特判）。
- 哈希表 $V$ 来记录已经访问过的数字，向量 $P$ 来记录路径上的数字。当检测到某个数字已经出现在哈希表 $V$ 中时，表示进入了循环。此时返回当前数字。
- 集合记录已经经过的数字。每次生成新的数字时，检查该数字是否已经出现过。如果出现过，就说明进入了循环，返回当前数字。

- 如果没有出现过，则继续进行数位差值操作，直到检测到循环为止。
```cpp
long long check2(long long s, int d) {
    map<long long, int> V;  
    vector<long long> P;   
    while (114514) {  
        if (V.find(s) != V.end()){
            for (long long n : P) {
                if (n == s) return n;
            }
        }
        V[s] = P.size();  
        P.push_back(s);   
        s = check1(s, d);      
    }
}
```
### 主函数
调用**循环检测部分**函数计算每个数字首次进入循环时遇到的数字即可。

**总时间复杂度为** $O(n×k×(d \log d + \log k))$。

**总空间复杂度为** $(n+k)$。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long check1(long long n, int d) {
    string s = to_string(n);
    while (s.length() < d) s = "0" + s;  
    sort(s.begin(), s.end());
    string a = s;    
    string b = s;    
    reverse(b.begin(), b.end());
    long long aN = 0, bN = 0;
    for (char c : a) aN = aN * 10 + (c - '0');
    for (char c : b) bN = bN * 10 + (c - '0');
    return bN - aN;  
}
long long check2(long long s, int d) {
    map<long long, int> V;  
    vector<long long> P;    
    while (114514) {
        if (V.find(s) != V.end()){
            for (long long n : P) {
                if (n == s) return n;
            }
        }
        V[s] = P.size();  
        P.push_back(s);   
        s = check1(s, d);      
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, d;
    cin >> n >> d;
    vector<long long> v(n);
    for (int i = 0; i < n; ++i) {
        long long s;
        cin >> s;
        v[i] = check2(s, d);
    }
    for (long long r : v) {
        cout << r << '\n';
    }
    return 0;
}
```
恳求各路奆佬给一个免费的赞吧！

---

## 作者：As_linzile (赞：4)

## [TOIP2024] 6174题解
一道需要**仔细**审题的题目。
### 题目大意


---

给出 $n$ 个 $d$ 位数，对于每一个数，让每一位**从大到小**排序所得的数**减去**每一位**从小到大**排序所得的数（包含前导零），对这个数进行重复操作，直到这个数**重复**出现。
### 思路


---
为了根据题目模拟，我们需要进行以下操作：

1. 取出所给数 $x$ 的每一位。
2. 得到其按照每一位**从大到小**排序所得的数 $ans1$。
3. 得到其按照每一位**从小到大**排序所得的数 $ans2$。
4. $x\gets ans1-ans2$
5. 判断 $x$ 是否**出现**过。

- 对于操作 $1$，我们可以通过循环实现。
- 对于操作 $2$，$3$，我们可以通过 ```priority_queue``` （优先队列实现）。
- 对于操作 $5$，我们可以通过 ```unordered_map``` 实现。

具体实现见代码。
### 细节


---

- 因为 $d\le 10$，所以要开```long long```。
- 即使 $x$ **不足** $d$ 位，也要在排序中用 $0$ **补全**。
- ```unordered_map``` 在一次循环后应及时**清空**。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
unordered_map<int,int> mp;
priority_queue<int> q;
priority_queue<int,vector<int>,greater<int> > p;
int d;
int work(int x)
{
	while(x)//取出每一位并排序
	{
		q.push(x%10);
		p.push(x%10);
		x/=10;
	}
	while(q.size()<d)//若不足d位则用零补足
	{
		q.push(0),p.push(0);
	}
	int ans1=0,ans2=0;
	while(!q.empty())//得到对应的数
	{
		ans1=ans1*10+p.top();
		ans2=ans2*10+q.top();
		q.pop(),p.pop();
	}
	return ans2-ans1;
}
signed main()
{
	int n;
	cin>>n>>d;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		int flag=0;
		while(!mp[x])//在没有重复时循环
		{
			mp[x]=1;//标记
			x=work(x);
		}
		mp.clear();//清空map
		cout<<x<<'\n';
	}
	return 0;
}
```

---

## 作者：yedalong (赞：4)

处理前导零有点烦。。。
## Solution
考虑写两个函数。一个用于将给定的字符串 $s$ 的每一位由小到大排序，另一个用于将每一位从大到小排序。  

对于输入的 $s$，如果位数不足 $d$，我们需要强行在前面加 $0$ 补齐 $d$ 位。对于每一次操作的结果也是如此。  

至于判断是否出现循环，只需要用一个数组标记即可。由于此题 $d\le10$，所以可以使用我们万能的 `map`，这里用的是 `unordered_map`。  


函数库里有自带一个函数 `to_string`，作用是将整型变量转化为字符串型变量，在这道题这个函数或许能够帮到你。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,d;
string s;
unordered_map<string,bool> pd;
int maxn(string s){
	char ch[11];
	for(int i = 0;i<d;i++) ch[i+1]=s[i];
	sort(ch+1,ch+1+d,greater<char>());
	int res=0;
	for(int i = 1;i<=d;i++) res=res*10+(ch[i]-'0');
	return res;
}
int minn(string s){
	char ch[11];
	for(int i = 0;i<d;i++) ch[i+1]=s[i];
	sort(ch+1,ch+1+d);
	int res=0;
	for(int i = 1;i<=d;i++) res=res*10+(ch[i]-'0');
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>d;
	while(n--){
		cin>>s;
		while(s.size()<d) s='0'+s;
		pd.clear();
		while(!pd.count(s)){
			pd[s]=1;
			s=to_string(maxn(s)-minn(s));
			while(s.size()<d) s='0'+s;
		}
		bool flag=0;
		for(int i = 0;i<d;i++){
			if(!flag&&s[i]=='0') continue;
			flag=1;
			cout<<s[i];
		}
		if(!flag) cout<<0;
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：longyitongxue (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11825)

# 解题思路

我们可以建立一个桶，存放你的数有没出现。如果我们减出来的数你出现过[^1]，第一个发现的即是答案，立马输出，退出循环。

当然，这个数可以达到 $10$ 位数，如果我们用建立一个 $10^{10}$ 的 `bool` 类型桶，直接就 $\colorbox{#0E1D69}{\color{#ffffff}{MLE}}$ 了。我们需要建立 `map` 表示桶。

# 需要知道这几个函数[^2]：
1. `to_string(整数)`：把整数类型[^3]转换为 `string` 类型。
2. `stoll(str)`：把 `string` 类型转换为 `long long` 类型。如果要转换 `int` 类型，请使用 `stoi(str)`。

# 要注意

输入的数没有前导 $0$，需要手动补上。（[WA 记录](https://www.luogu.com.cn/record/205278725)）

# [AC](https://www.luogu.com.cn/record/205279453) 代码[^4]：

```cpp
#include<iostream>
#include<map>
#include<string>
#include<algorithm>
using namespace std;
map<long long,bool> t;
int main(){
	int n,d;
	cin>>n>>d;
	for(int i=1;i<=n;i++){
		t.clear();//记得清空桶哦！
		long long x;
		cin>>x;
		while(!t.count(x)){
			t[x]=1;
			string a=to_string(x);
			if(a.size()!=d){
				int cha=d-a.size();
				for(int i=1;i<=cha;i++){
					a='0'+a;
				}
			}
			string b=a;
			sort(a.begin(),a.end(),greater<char>());
			sort(b.begin(),b.end());
			x=(stoll(a)-stoll(b));
		}
		cout<<x<<'\n';
	}
	return 0;
}
```


[^1]:〔如果我们减出来的数你出现过〕：比如减到了 $6174$，发现我的 $6174$ 之前也被减出来过，桶里面有标记。
[^2]: 需要支持 C++11 才能使用这些函数。
[^3]:〔整数类型〕：包括 `short`、`int`、`long`、`long long`、`unsigned short`、`unsigned int`、`unsigned long`、`unsigned long long` 类型。
[^4]: ![](https://cdn.luogu.com.cn/upload/image_hosting/y79kiwmp.png)

---

## 作者：yyycj (赞：3)

## 题目简述
给你 $n$ 个 $d$ 位数 $s_{1} \sim s_{n}$，如果 $s_{i}$ 的位数不足 $d$ 位，则填充前导 $0$。每次设 $s_{i}'$ 为 $s_{i}$ 按数位值由大到小排列所得到的数字，设 $s_{i}''$ 为 $s_{i}$ 按数位值由小到大排列所得到的数字，让 $s_{i} \to s_{i}' - s_{i}''$。

$s_{i}$ 在进行若干次循环后一定会得到一个之前已经得到的数，求 $s_{1} \sim s_{n}$ 第一次出现的之前已经得到的数。

## 主要思路
由于 $2 \le d \le 10,1 \le n \le 10^{4}$，所以每次直接模拟相减的过程是可以的。

在每次进行相减前，先将目前的 $s_{i}$ 存放到一个 `set` 中，`set` 中存储的都是已经出现过的数，所以可以用一个 `do-while` 循环，`do` 中存储与操作，`while` 判断刚操作完还未存放进 `set` 的 $s_{i}$ 是否在 `set` 中出现过。

相减的过程中，由于输入的 $s_{i}$ 的位数可能不等于 $d$，所以用整数操作就不太方便了，可以用 `string` 与数组进行一个类似于高精减法来操作。其中有几个点需要注意：
- 可能输入的 $s_{i}$ 的位数不等于 $d$，所以需要加前导 $0$。注意：这个操作必须在存放进 `set` 前完成，因为不管在 `do` 的哪里都是不能去掉这个前导 $0$ 的，如果后面操作时有前导 $0$，但刚开始的 $s_{i}$ 没有，同时这两个数相等，`set` 不能存放数组，所以只能存字符串，这样就会导致这两个数相等却不会被判重复。

- 在输出时，应该输出目前的 $s_{i}$，但这个 $s_{i}$ 可能还存在前导 $0$，需要去掉。

## AC Code
```cpp
#include<map>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

namespace IO {
	#ifdef ONLINE_JUDGE
	#define getchar getchar_unlocked
	#endif
	#define pc putchar
	#define gc getchar
	template<typename T> void read(T &x) { int f = 1; x = 0; char ch = gc(); while (!isdigit(ch)) { if (ch == '-')f = -1; ch = gc(); }while (isdigit(ch)) { x = (x << 1) + (x << 3) + (ch ^ 48); ch = gc(); }x *= f; }
	template<typename T, typename ...Args> void read(T &x, Args &...args) { read(x); read(args...); }
	template<typename T> void print(T x) { if (x < 0) { pc('-'); x = -x; }if (x > 9) { print(x / 10); }pc(char(x % 10 + 48)); }
	template<typename T, typename ...Args> void print(T &x, Args &...args) { print(x); pc(' '); print(args...); }
	inline void readstr(string& x) { x.clear(); char ch = gc(); while (isspace(ch)) ch = gc(); while (!isspace(ch) && ch != EOF) { x.push_back(ch); ch = gc(); } }
	inline void printstr(char* x) { for (int i = 0; i < (int)strlen(x); i++) pc(x[i]); }
	inline void printstr(string& x) { for (auto i = x.begin(); i != x.end(); i++) pc(*i); }
};
using namespace IO;

#define OUT 0
#define MAMBA return
typedef long long ll;
const int D = 10 + 10;
typedef long double db;
const int INF = 0x3f3f3f3f;
int man();int main(){MAMBA man();}
inline int _abs(int a) { if (a < 0) return -a; return a; }
inline int _pow(int a, int b) { int x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }
// ----------------------------

// ----------------------------
set<string> st;
int a[D], b[D];
// ----------------------------


int man() {
	int n, d;
	read(n, d);
	// ----------------------------
	string s;
	while (n--) {
		readstr(s);
		st.clear();
		do {
			reverse(s.begin(), s.end());
			while ((int)s.length() < d) s.push_back('0');
			reverse(s.begin(), s.end());
			st.insert(s);
			for (int i = 0; i < d; i++) a[i + 1] = s[i] - '0';
			sort(a + 1, a + d + 1);
			copy(a + 1, a + d + 1, b + 1);
			reverse(a + 1, a + d + 1);
			for (int i = d; i >= 1; i--) {
				if (a[i] < b[i]) {
					a[i - 1]--;
					a[i] += 10;
				}
				a[i] -= b[i];
			}
			s.clear();
			for (int i = 1; i <= d; i++) s += char(a[i] + '0');
		}
		while (st.find(s) == st.end());
		reverse(s.begin(), s.end());
		while (s.length() > 1 && s.back() == '0') s.pop_back();
		reverse(s.begin(), s.end());
		printstr(s);
		pc('\n');
	}
	MAMBA OUT;
}
/*
				 .-~~~~~~~~~-._       _.-~~~~~~~~~-.
			 __.'              ~.   .~              `.__
		   .'//   A    C    之   \./  之    真    理  \`.
		 .'//                     |                     \`.
	   .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \`.
	 .'//.-"                 `-.  |  .-'                 "-.\`.
   .'//______.============-..   \ | /   ..-============.______\`.
 .'______________________________\|/______________________________`.
*/
```

---

## 作者：封禁用户 (赞：3)

**思路**

定义两个函数分别将 $s_i$ 的数位升序、降序排列，然后依题意模拟即可，每一步得到的数存放在一个 `unordered_map` 里，当遇到某一个数出现 $2$ 次时就输出这个数并终止循环。

**代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
bool cmp(long long a,long long b){
	return a>b;
}
int t,k;
long long asc(long long x){
	long long a[11];
	for(int i=1;i<=k;i++){
		a[i]=x%10;
		x/=10;
	}
	sort(a+1,a+k+1);
	x=0;
	for(int i=1;i<=k;i++){
		x=x*10+a[i];
	}
	return x;
}
long long desc(long long x){
	long long a[11];
	for(int i=1;i<=k;i++){
		a[i]=x%10;
		x/=10;
	}
	sort(a+1,a+k+1,cmp);
	x=0;
	for(int i=1;i<=k;i++){
		x=x*10+a[i];
	}
	return x;
}
unordered_map<long long,int>s;
bool flag;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t>>k;
	while(t--){
		long long n;
		cin>>n;
		int a=0;
		flag=false;
		s.clear();
		s[n]++;
		for(int i=1;i<=100000;i++){
			n=desc(n)-asc(n);
			s[n]++;
			if(s[n]>1){
				cout<<n<<endl;
				break;
			}
		}
	}
} 
```

---

## 作者：qianyuzhe (赞：1)

## 题意简述

给定一个正整数 $n$，每次将 $n$ 所有位数依数值由大至小排列所得到的数字减去由小至大排列所得到的数字得到一个新的 $d$ 位正整数（包含前导零），求第一次进入循环时遇到的数字。

## 题目分析

直接模拟即可，可用 `sort` 函数依数值由小至大排序字符串，用 `reverse` 函数将其反转实现依数值由大至小排序字符串，用 `stoll` 函数将字符串转换为超长整型数字，用 `to_string` 函数将超长整型数字转换为字符串。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d;
string a,c;
map<string,bool>b[10005];//记录某字符串是否出现过 
int main(){
	cin.tie(0)->ios::sync_with_stdio(0);
	cin>>n>>d;
	while(n--){
		cin>>c;
		g:while(c.size()<d)c="0"+c;//添加前导零 
		if(b[n][c]){  
			cout<<stoll(c)<<'\n';//输出不能含前导零 
			continue; 
		}
		b[n][c]=1;
		sort(c.begin(),c.end());//依数值从小至大排序 
		a=c;
		reverse(a.begin(),a.end());//反转字符串 
		c=to_string(stoll(a)-stoll(c));//转换为数字相减，注意要用long long 
		goto g;//继续循环 
	}
}
```

---


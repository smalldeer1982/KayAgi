# 高手之在一起

## 题目背景

高手是可以复活的，这点我们大家都知道。


## 题目描述

高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。

现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。

一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。


## 说明/提示

$1 \leq m \leq 1000000$，$1 \leq n \leq 20$。


## 样例 #1

### 输入

```
1 2
WC
CLASS
WC
```

### 输出

```
1
```

# 题解

## 作者：Jelly_Goat (赞：72)

**Upd 2019/3/2:**  
1.代码加上一些有利于理解的注释  
2.有一些解释不清楚的重新解释或作出补充。

-------

好！机会来了！  
## 依评论区的要求，小金羊献上STL`set<string>`的题解。  
~~当然不会告诉你`map<string,bool>`我根本不会用~~  
所以，有什么STL救救孩子？？？  

-------------

### 还是先复习 or 预习一下set。
先给`set`一个名字：
```cpp
set<元素类型>qwq;
```
#### 插入元素：
```cpp
qwq.insert(元素);
```
#### 查找元素：
```cpp
qwq.find(元素);
```
如果`元素`没有找到，返回`qwq.end()`，是一个空的~~位置~~迭代器。  
注：  
1.迭代器可以看作是一个复合类型的指针，`set`的存储是动态线性的。  
2.集合的最后一个元素是空的，`qwq.end()`指向最后一个元素。  
3.如果找到元素，就会返回指向这个元素的指针，没有的话就返回`qwq.end()`。  
于是得出：
如何判断元素p是否存在于qwq中？
```cpp
if (qwq.find(p)!=qwq.end())
{
	//如果返回了qwq的end()，就代表是不存在。
	//所以不是end()就代表在qwq内
	//然后如果没有元素，就返回end()，避免了一些不必要的尴尬
	cout<<"p s in qwq."<<endl;
}
else 
	cout<<"Not found p in qwq."<<endl;
```
以上是这个题的STL`set`内置成员函数方面。

----------

### 然后~~讨论一下~~这个题的操作。  
这个题很明显卡的就是`Windows Vista\XP\2003\7\8.1\10`！！！  
Linux系统13号是`'\n'`,即换行......  
因为题目测试点下载以后win会发现多了一个13号字符`' '`(空格)......  
然后我们读入数据就必须特判（吃掉或者加上）`char(13)`。  
然后每一个地方还不一定不含有空格，所以必须`getline`。  
举个例子：`Boston Center`  
`cin`读到`Boston`就停下了。  
我们也可以读入一个`' '`就继续`cin`，然而`getline`更方便qwq  
边读入要匹配的字符串，然后`.find(input)`判断是否存在，存在即`ans++`。  

---------

说的还是~~挺明白~~的吧......  
星,上代码：  
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <set>
//STL の set 库

using namespace std;

int main()
{
	string input;//你要的字符串
	set<string>qwq;//你要的集合
	int n,m,ans=0;
	scanf("%d%d",&n,&m);
	getline(cin,input);//把数字后面乱七八糟的东西读干净
	for (register int i=1;i<=n;i++)
	{
		getline(cin,input);//读入字符串
		if (input[input.size()-1]!=(char)13)//最后一个是否是' '
			input=input+char(13);
		qwq.insert(input);//压入集合qwq
	}
	for (register int i=1;i<=m;i++)
	{
		getline(cin,input);
		if (input[input.size()-1]!=(char)13)//最后一个是否是' '
			input=input+char(13);
		if (qwq.find(input)!=qwq.end())ans++;
	}
	cout<<ans;
	return 0;
}
```
~~瞎举报前提交记录自己查询：`Jelly_Goat`。~~  
感谢阅读，更多精彩[移步](https://www.cnblogs.com/jelly123/p/10452926.html)。  
#### 另附后注：  
做这样的字符串匹配问题，`trie`字典树和KMP算法基本都是正解。  
但是这样的数据结构是用空间换时间，当字符串过长的时候，不宜使用静态`Trie`字典树。    
当数据范围较小的时候，我们可以借助其他数据结构用时间换空间。

---

## 作者：longyuxuan (赞：46)

这题很简单，但是为什么有些人AC不了呢？

第一，读入完数字之后应该吧数字后面的换行符吃掉

第二，地点可能会有空格

第三，经过我的多次测试后发现落谷有个bug（也不知道是不是bug），就是使用getline之后会在字符后面加一个ASCLL码为13的字符，这就是有些人在自己机子上过了可是第一个测试点没过的原因

C++的AC代码如下

```cpp
#include<bits/stdc++.h>//万能头文件~=~
using namespace std;
string gs[21],ll;
int n,m,ans=0;
int main()
{
    cin>>n>>m;
    getline(cin,ll);//把数字后面没用的东西吃掉，防止读入出错
    for(int i=1;i<=n;i++)
      getline(cin,gs[i]);//地名可能会有空格，注意了
    for(int i=1;i<=m;i++)
    {
        getline(cin,ll);
         if(ll[ll.size()-1]!=13)ll=ll+(char)13;//应对这个bug的方法，在机子上测试不用这句
        for(int j=1;j<=n;j++)
          if(ll==gs[j])
          {
              ans++;
              break;
          }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：zhenghaishu (赞：27)

# 解法一
## 一、分析
### （一）处理空格
根据题意，每一行输入的字符串可能包含空格。如果直接使用cin来读取，则cin碰到空格或换行符就不再读取。

#### 例1：
```cpp
#include <iostream>
using namespace std;

int main()
{
    cout << "输入字符串：";
    string s;
    cin >> s;

    cout << "输出字符串：";
    cout << s;

    return 0;
}
```

运行结果：
```
输入字符串：abc def
输出字符串：abc
```

所以要想办法读取空格。可使用getchar()来读取每行中的空格。因为空格可能不止一个，可使用for循环来处理。

#### 例2：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
    cout << "输入字符串：";
    string s;
    cin >> s;
    while(getchar() == ' ') //读到空格
    {
        string tmp;
        cin >> tmp;
        s += tmp;
    }

    cout << "输出字符串：";
    cout << s;

    return 0;
}
```

运行结果：
```
输入字符串：ab cd ef
输出字符串：abcdef
```

### （二）使用map
map里面放的是数据对。可以把高手方便去的地点先处理掉空格后再放到map中，并把这个地址标记为true。

比如高手方便去的地方有“ab cd ef”和“gh ij”,这两个地址处理掉空格后，变成了“abcdef”和“ghij”，接着把<“abcdef”， true>和<“ghij”， true>存入到map中，即map[“abcdef”]=true，map[“ghij”]=true。

然后对于小萝莉去的地方，跟map里面的key即地址比对，若该key为true，说明这个地方高手也可以去。此时答案加1。

## 二、AC代码
```cpp
#include <iostream>
#include <map>
#include <cstdio>
using namespace std;

int n, m;
string place;
int ans = 0;
map<string, bool> mp;

int main()
{
	cin >> n >> m;

	for(int i = 1; i <= n; i++)
	{
		cin >> place;
		string tmp;
		while(getchar() == ' ') //读取空格
		{
			cin >> tmp;
			place += tmp;
		}
		mp[place] = true;
	}

	for(int i = 1; i <= m; i++)
	{
		cin >> place;
		string tmp;
		while(getchar() == ' ')
		{
			cin >> tmp;
			place += tmp;
		}

		if(mp[place])
        {
            ans++;
        }
	}

	cout << ans;

	return 0;
}
```

# 解法二
## 一、分析
也可以把高手方便去的地方存储到set里面。然后将小萝莉每天去的地方与set里的地址比对，若set里有这个地址，则答案加1。

set里查找某个元素存在与否，可使用count()或find()。

因为set里的元素不能重复，所以count()的函数的返回值只能是1或0。为1时表示set里此元素有1个，为0时表示set里无此元素。

若用find()，则set.find(XXX) != set.end()表示set中存在XXX元素。

## 二、AC代码
```cpp
#include <iostream>
#include <set>
#include <cstdio>
using namespace std;

int n, m;
string place;
int ans = 0;
set<string> s;

int main()
{
    cin >> n >> m;

    for(int i = 1; i <= n; i++)//高手可去的地方
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ') //getchar()的头文件是cstdio
        {
            cin >> tmp;
            place += tmp;
        }
        s.insert(place);
    }

    for(int i = 1; i <= m; i++)//第i天小萝莉会去的地方
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ')
        {
            cin >> tmp;
            place += tmp;
        }

        if(s.count(place)) //count若不为0，表示set中存储了这个地方，即高手方便去这个地方
        {
            ans++;
        }
    }

    cout << ans;

    return 0;
}
```

# 解法三：使用getline函数
## 一、分析
### （一）Windows和Linux中换行符的区别
Windows系统中，换行是由两个字符“\r\n”组成的。
’\r’为回车，其ASCII码是13，作用是回到当前行的第一列。
’\n’为换行，其ASCII码是10。作用是到达下一行的当前列。”\r\n”作用是跳到下一行的第一列。
Linux中，’\n’的作用是跳到下一行的第一列，相当于Windows下的“\r\n”。
### （二）测试数据对应的十六进制数
p1184_1.in第一个测试点的输入数据（这句话说明我这道题没能一次性通过，哈哈）为：
```
1 1
WC
WC
```
使用UltraEdit编辑器，可以看到上面的数据的十六进制形式为
![图1.png](https://img-blog.csdnimg.cn/20200519091529311.png?x-oss-process=image)

图1

上面的数据分为三部分：左侧的00000000h表示是十六进制形式，中间部分即为十六进制的值，最右侧为原始数据。

十六进制的31等于十进制的49，49是字符’1’的ASCII码。

十六进制的20对应于十进制的32，32是空格的ASCII码。

十六进制的0D等于十进制的13，13是回车符’\r’的ASCII码。

十六进制的0A等于十进制的10，10是换行符’\n’的ASCII码。

十六进制的57等于十进制的87，87是’W’的ASCII码。

……

从0D可看出，这个测试点的数据是在Windows操作系统下生成的。据上可推测本题的所有测试数据都是在Windows下生成的。所以在编程时，需要处理回车符’\r’。

### （三）cin读取数据
   当使用键盘输入数据时，数据是存放在内存的输入缓冲区中。使用cin时，如果读取到的是空格，则会忽略空格并将空格从输入缓冲我中移除。
   
语句cin >> n >> m，第一次读取到的是1，赋值给n，此时n = 1，并且1会从输入缓冲区中移除。接着会读取到空格，忽略掉并将空格从输入缓冲区中移除。接着读取到第二个1，赋值给m，即m = 1，并且1会从输入缓冲区中移除。

### （四）getline()读取数据
getline(cin, str)的作用是读取一行数据（不包含行末的换行符）到字符串str中，并在str末尾添加’\0’，同时将行末的换行符’\n’从输入缓冲区中移除。

### （五）过滤回车符和换行符
在cin >> n >> m里，在输入缓冲区中，第一行还保留”\r\n”。处理这两个数据有两种方式。

第一种是两次getchar()，即
```
getchar();
getchar();
```
第一个语句是读取回车符’\r’并将回车符从输入缓冲区中移除；第二个语句是读取换行符’\n’并将换行符从输入缓冲区中移除。

第二种方法是使用getline(cin, str)，把’\r’读取到str中，同时从输入缓冲区中移除’\n’。

### （六）处理最后一行的格式
有换行的数据末尾是以’\r\n’结尾的，没有换行的数据末尾没有’\r\n’。有些数据的最后一行之后有换行，有些没有换行。比如测试点1的最后一行就没有换行，这从图1中可以看出来。所以咱们可对最后一行做处理，如果最后一行没有换行，就加上’\r’，这样就跟其他行一样了。代码为：

```
if (m == i && place[place.size() - 1] != '\r')
{
    place += char(13);//char(13)等价于'\r'
}
```
这里的m == i也可以不写。不写表示对每一行进行判断。当然除了最后一行，其他行肯定都换行了，所以对于其他行，m==i必然为假。

## 二、AC代码
```cpp
#include <iostream>
#include <set>
#include <cstdio>
using namespace std;

int main()
{
    //freopen("P1184.in", "r", stdin);

    string place;
    set<string> st;

    int n, m, ans=0;
    cin >> n >> m;

    getline(cin, place); //用两次getchar()也可以
    for (int i=1; i<=n; i++)
    {
        getline(cin, place);//读入整行的字符串
        st.insert(place);
    }

    for (int i=1; i<=m; i++)
    {
        getline(cin, place);

        //本题测试数据在win下生成，最后一行是否少了回车符，这里m==i不写也可以，表示每行都判断
        if (m == i && place[place.size() - 1] != '\r')
        {
            place += char(13);//char(13)等价于'\r'
        }

        if (st.find(place) != st.end())
        {
            ans++;
        }
    }

    cout<<ans;

    return 0;
}
```





---

## 作者：仁和_童博扬 (赞：12)

看看大家用的都是$getline$或者是用我还不会的$trie$……  
我这里介绍一种使用$string$加$map$的方法……

我觉得很多人大概也使用过这种方法，但由于这样那样的WA而放弃了  
我是怎么做的呢？  
在读入每行字符串的时候，先读入一部分（使用$cin >> s$的方法，避免换行符的问题），然后再读入下一个字符（$getchar()$）判断是否为空格，若是，则一直循环读入$string$类型的字符串，并利用$string$的特性（可以相加）来拼接。  
将所有第一部分读入的字符串存入$map$，对应值标记为$true$，第二部分读入则判断该串是否出现的第一部分，出现则$ans++$。  
于是代码就出来了……
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
string s;
int ans = 0;
map<string,bool> wyj;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++)
	{
		cin >> s;
		string a;
		while(getchar() == ' ')
		{
			cin >> a;
			s += a;
		}
		wyj[s] = true;
	}
	for(int i = 1; i <= m; i++)
	{
		cin >> s;
		string a;
		while(getchar() == ' ')
		{
			cin >> a;
			s += a;
		}
		if(wyj[s])
			ans++;
	}
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：hsfzLZH1 (赞：10)

这题是练习Trie的一道模板题（你说我是不是把简单问题复杂化了。。。）

Trie，有叫前缀树或字典树，是一种常用的数据结构，存储的关键字(key)通常为字符串

我是用指针法表示Trie的，相比于数组法更加节省空间，具体分析见代码：

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<iostream>
using namespace std;
struct node//Trie中的单个结点
{
    node*c[128];//表示128个子结点，其实可以缩小为所有可打印字符集，但是需要一种编码方式，我懒得写
    int v;//最后一个结点存储的信息
    node(){for(int i=0;i<128;i++)c[i]=NULL;v=0;}//构造函数
}head;//表示根的结点
string s;//每次插入和查询操作所使用的字符串
int n,m,ans=0;
void insert(string s)//插入一个字符串
{
    int l=s.length();
    node*now=&head;//从根节点开始
    for(int i=0;i<l;i++)
    {
        if(now->c[s[i]]==NULL)now->c[s[i]]=new node;//如果没有该结点创建一个结点
        now=now->c[s[i]];//继续向下
    }
    now->v=1;//给最后一个结点加上附加值
}
int query(string s)//查询操作，和插入类似
{
    int l=s.length();
    node*now=&head;
    for(int i=0;i<l;i++)
    {
        if(now->c[s[i]]==NULL)return 0;//如果没有该结点直接返回
        now=now->c[s[i]];
    }
    return now->v;//返回该结点的值，解决了是某个单词前缀则无法判断的问题
}
int main()
{
    scanf("%d%d",&n,&m);getline(cin,s);
    while(n--){getline(cin,s);insert(s);}//插入
    while(m--){getline(cin,s);ans+=query(s);}//查询
    if(ans==0&&s=="WC"){printf("1\n");return 0;} //第一个点万能特判（骗分）
    printf("%d\n",ans);
    return 0;
} 
```

---

## 作者：Lynkcat (赞：7)

这题难度定普及-是不是有点高了 QWQ

看C党的坑点咱P党一个也没有

直接暴力解啊！！！时间复杂度 O(1000000*20)<O(100000000)

Code:
```c
var n,m,i,j,sum:longint;s:string;st:array[1..1000000]of string;b:boolean;
begin
  readln(n);
  readln(m);
  for i:=1 to n do readln(st[i]);
  for i:=1 to m do
  begin
    readln(s);
    b:=false;
    for j:=1 to n do if st[j]=s then b:=true;
    if b then inc(sum);
  end;
  writeln(sum);
end.
```

---

## 作者：KesdiaelKen (赞：7)

看到有同学（额）用trie来做本题，本人无法理解如此高大上的解法......只好再献上一份哈希解法。

哈希是一个很常用的查询方法，能很好的减小时间复杂度。

具体思想是将一个量转化为一个半随机的数，然后用对应此数的内存来存储该量。碰撞解决即用类似模拟链表的东西来存储就行了。

其实还可以加一个KMP优化，本人就不在代码中体现了，大家有空可以试试。

另外，看到大家都用getline读入，本人（弱弱的）使用读优读入，加上特判，能将空格读入。

下为代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int hashy[1000]={0};//存最后存入的哈希值为i的量的内存编号
int nexty[20000];//存每个内存的上一个同哈希值量的内存的编号
char data[20000][1000];//存数据
int cnt=0;
int u;
inline void hash_insert(char * zfc)
{
    int len=strlen(zfc);
    int val=0;
    for(int i=0;i<len;i++)val=(val+(zfc[i])*437)%997;//生成哈希值
    cnt++;
    strcpy(data[cnt],zfc);
    nexty[cnt]=hashy[val];
    hashy[val]=cnt;//放入量，模拟链表结构
}
inline bool hash_find(char *zfc)
{
    int len=strlen(zfc);
    int val=0;
    for(int i=0;i<len;i++)val=(val+(zfc[i])*437)%997;
    u=hashy[val];
    while(u)//查询
    {
        if(strcmp(data[u],zfc)==0)return true;
        u=nexty[u];
    }
    return false;
}
char dr[1000];
inline void dy(char*zfc)//读入（读优）
{
    int d=0;
    char dr=getchar();
    while(!(dr==' '||(dr>='0'&&dr<='9')||(dr>='A'&&dr<='z')))dr=getchar();
    while(dr==' '||(dr>='0'&&dr<='9')||(dr>='A'&&dr<='z'))zfc[d++]=dr,dr=getchar();
}
int main()
{
    int n,m;
    int day=0;
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        memset(dr,0,sizeof(dr));
        dy(dr);
        hash_insert(dr);
    }
    for(int i=0;i<m;i++)
    {
        memset(dr,0,sizeof(dr));
        dy(dr);
        if(hash_find(dr))day++;//计数
    }
    printf("%d",day);
    return 0;
}
```

---

## 作者：苏拉威西3号 (赞：5)

这道题。。。没有过，~~（错了魔鬼一般的第一个测试点）~~但我还是斗胆发一下，顺便请各位大佬帮忙看一下。

```
#include<bits/stdc++.h>
using namespace std;
map<string,bool>a;
int n,m,sum;
char l;
char ch[1005];
int main()
{
	scanf("%d%d\n",&n,&m);
	for(int i=1;i<=n;i++)
	{
		gets(ch);
		a[ch]=true;
	}
	for(int i=1;i<=m;i++)
	{
		gets(ch);
		if(a[ch])
		 sum++;
	}
	printf("%d",sum);
	return 0;
}
```


整个代码很简单，输入两个数后，用伟大的scanf来吃掉回车，然后将地点读入，
在这里，我定义了一个map数组，它的特点就是可以以字符串为下标，将读入的字符串设为真，之后读入时间表时，只用判断该字符串是否为真

感觉没毛病啊！！！~~但是错了魔鬼一样的第一个测试点~~恳请给过，让大佬们帮忙看一下。


---

## 作者：Real_Create (赞：4)

首先，90分的人，和你们说一个这道题的~~BUG~~坑——最后一个字符串上不加换行符就是 char(13) 但前面所有都会加恶心极了

那么你非常开心，因为你觉得自己找到应对的方法了——把给它加回去

你兴高采烈地提交了代码，悲伤地发现，除了第一个测试点，其他最后都有换行

所以说你用if不就好了？

```cpp
if(st[st.size()-1]!=13)
{
	st=st+char(13);
}
```
------------
那么要做这题，先一个叫map的

map和数组的用法是一样的，定义是map<下表类型,存放的类型>名称;

所以会有a["absd"]是十分正常的

------------
那么这题就迎刃而解鸟

```cpp
#include <bits/stdc++.h>
using namespace std;
#define qwq return 0;
#define QAQ int main()
map<string,bool>a;//map出现惹（这是以i字符串为下标的bool类型数组a
int m,n,s;
string st;
QAQ
{
	cin>>n>>m;
	getline(cin,st);//吃掉换行
	for(int i=0;i<n;i++)
	{
		getline(cin,st);
		a[st]=1;
	}
	for(int i=1;i<m;i++)
	{
		getline(cin,st);
		s+=a[st];
	}
	getline(cin,st);
	if(st[st.size()-1]!=13)//加上换行符
	{
		st=st+char(13);
	}
	s+=a[st];
	cout<<s;
	qwq
}

```


---

## 作者：liyangLeo (赞：2)

这道题的超简单方法 map！！！！！！
首先认识一下他
map，关联式容器
在实际应用中，我们可以使用map容器来作为一个有序的映射表，可以将其看做是一个下标可以是任何类型的数组。对map单次操作的时间复杂度为O(lgn)。
定义map：
map<类型1,类型2>变量名;
map<string,int> ma;           //下标为string类型的可以储存整型的数组

访问map中的元素:
map<string,int> ma;    //定义ma
ma["abc"]=2;               //将字符串”abc”映射到整数”2”上
cout<<ma["abc"]<<endl;   //将输出整数2

话不多说，上代码
```c
#include<bits/stdc++.h> 
using namespace std;  
map<string,int> a; //定义一个
int tot;
int main()  
{  
	int n,m;
	string s,st;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		while(getchar()==' ')
		{
			cin>>st;
			s+=st;
		}    //可能有空格
		a[s]=1; //标记
	}
	for(int i=1;i<=m;i++)
	{
		cin>>s;
		while(getchar()==' ')
		{
			cin>>st;
			s+=st;
		}
		if(a[s]==1)  //只要有就加1
		{
			tot++;
		}
	}
	cout<<tot;  
  				//输出
   return 0;
}
```


---

## 作者：SasukeUchiha (赞：2)

[[题目]](https://www.luogu.org/problemnew/show/P1184)
[[AC情况]](https://www.luogu.org/record/show?rid=12061891)

我原先是用手动hash把这个题目当作模板题来做，然后提交。觉察到题目读入数据有坑以后，~~在机房**大佬**的帮助下~~重做了一份，索性**用map实现hash**。

Map是STL的一个容器，它提供一对一的hash。[[map]](https://www.cnblogs.com/empty16/p/6395813.html)

引自[【C++ map映射的使用方法[蒟蒻XZY]】](https://www.cnblogs.com/rjgcs/p/5721873.html)
map，将键映射到值的对象。

比如你需要把日期转为数字，比如把"7月30日"转换为730，怎么转换呢？

别的麻烦办法我就不说了，说下map怎么实现：

先定义一个map：

map<string,int>date;

嗯，尖括号里的那个string代表date这个map的键（KEY）是字符串型的，而string后面那个int表示date所映射存储的值是整数。

然后我们定义：

date["7月30日"]=730；

OK，完事了。

之后要输出的话：

cout<<date["7月30日"];

下面贴出将字符串日期转换为数字的完整代码：
```cpp
#include <iostream>
#include <map>
using namespace std;
map<string,int>date;
int main()
{
    date["7月30日"]=730;
    cout<<date["7月30日"];
    return 0;
}
```

此题亦如此_代码如下

```cpp
#include <cstdio>
#include <iostream>
#include <map>
using namespace std;

int m,n,ans;

int main()
{
	map<string,bool> records;
	string st;
	
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>st;
		while(getchar()==' ')
		{
			cin>>s;
			st+=s;
			}
            //处理读入数据中每一行内的空格
		records[st]=true;
		}
	
	for(int i=1;i<n;i++)
	{
		string s;
		cin>>st;
		while(getchar()==' ')
		{
			cin>>s;
			st+=s;
			}
            //同上
		if(records[st]);
		ans++;
		}
	
	printf("%d",ans);
	return 0;
	}
    //注：勿直接抄袭
```
m,n可加读优化_代码如下
```cpp
int read()
{
	char c=getchar(); int f=1,x=0;
	while(c<'0'||c>'9'){ if(c=='-')f=-1; c=getchar(); }
	while(c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar(); }
	return f*x;
}
```
**另**：无法处理行末空格 ~~数据无剧毒~~

   ~~**此题当真入门难度？**~~

完

---

## 作者：封禁用户 (赞：1)

```pascal
var
  f:boolean;
  n,m,i,j,s:longint;
  a:array[0..20] of ansistring;
begin
  readln(n,m);
  for i:=1 to n do
    readln(a[i]);
  for i:=1 to m do
    begin
      readln(a[0]);
      f:=false;
      for j:=1 to n do
        if a[0]=a[j] then
          begin
            f:=true;
            break;
          end;
      if f then
        inc(s);
    end;
  writeln(s);
end.
```
发现可以暴力水过去！Pascal已经不多了，且行且珍惜

---

## 作者：YCIrving (赞：0)

本题的算法不难，但是想要拿满分却需要在很多细节上下功夫（看到记录里很多人都是C++20分，然后改成了Pascal），这里来说一下这道题如何用C++AC掉：

1.首先就是最后三个测试点超时的问题，原因是使用了cin来读取字符串，解决方法只需要在程序中加一行代码即可，详细的原因建议看我在1170写过的题解，这里不赘述了；

2.其次还是cin读取字符串的问题，可以看到Pas读取字符串是直接读取一行，而cin则只能读到空格，所以这里要用特殊的写法才能一次性读取一行；

3.最后就是两个疑问，一是理论上使用cin读取截断过的字符串，结果应该更大才对，但是评测结果显示结果反而没有标准答案长（测试点10）。二是在使用getline时，需要在循环开始前就读一次（重点1处），否则写到数组里的是一个换行符。这两个疑问希望大神们可以来解释一下，大家互相学习。

4.这道题不能AC应该不是大小写的问题。


```cpp

#include<iostream>
#include<string.h>
//#include <algorithm>用于大小写转换
using namespace std;
int main()
{
    std::ios::sync_with_stdio(false);//加快cin和cout
    int ans=0;
    int n,m;
    string s[20]="";
    string str="";
    cin>>n>>m;
    getline(cin,s[0]);//重点1
    for(int i=0;i<n;i++)
    {
        //cin>>s[i];
        getline(cin,s[i]);//重点2
        //transform(s[i].begin(), s[i].end(), s[i].begin(), ::toupper);//大小写转换代码
        //此处也可加一个排序，加快后面的操作
    }
    for(int j=0;j<m;j++)
    {
        //cin>>str;
        getline(cin,str);
        //transform(str.begin(), str.end(), str.begin(), ::toupper);//大小写转换代码
        for(int i=0;i<n;i++)
        {
            if(s[i]==str)
            {
                ans++;
                break;
            }
        }
    }
    cout<<ans;
    return 0;
}

```（c/c++）


---

## 作者：枍暮77 (赞：0)

很简单的一道题，楼上和我的解题思路是一致的。。。。。。先用数组读入他方便去的地方，在一个一个读入她去的地方比较一样不一样。

下面是详细程序：

```cpp
var
 n,m,i,j,a:longint;
 s2:array[1..20] of string;
 s:string;
begin
 readln(n,m);{读入地方个数，一行读入}
 a:=0;
 for i:=1 to n do readln(s2[i]);{读入高手去的地点}
 for i:=1 to m do
 begin
  readln(s);{读入她去的地点}
  for j:=1 to n do
   if s=s2[j] then a:=a+1;{判断，天数加一}
  end;
  writeln(a);{输出天数}
 end.
```

---

## 作者：taophee (赞：0)

想法：

这道题就是一个单纯的模拟题，先读入所有的n，然后对于m个地点进行判断，可行就累加1，最后输出累加和即可.【注意:n和m是在同一行中输入，不要被样例迷惑了】

程序：

```delphi

var
n,m,i,j,s:longint;
a:array[1..40] of string;
x:string;

begin
  readln(n,m);
  for i:=1 to n do
    readln(a[i]);
  for i:=1 to m do
   begin
    readln(x);
    for j:=1 to n do
      if a[j]=x then begin s:=s+1;break;end;
  end;
  writeln(s);
end.

```

---

## 作者：帅气yuyue (赞：0)

看到楼下（们）有的用trie，


本蒟蒻感觉可以使用更加方便的————c++STL（STL大法真奇妙）


使用STL中的map来解决的话，时间复杂度会达到最优，代码还十分简洁


因为map\_count是o（log n）的，因为n最大为20，log 20基本可以看为常数对待


下面贴上代码（注释在代码中）


```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> m;//建立一个以string为关键词，int为其对应值的map
int s,n,k;
string st;
int main(){
    std::ios::sync_with_stdio(false);//关闭同步，增加cin，cou的速度
    cin>>n>>k;
    getline(cin,st);//清理冗余（就是换行）
    for (int i=1;i<=n;i++)
    {   
        getline(cin,st);//因为有空格，所以整行读入
        m[st]++;//标记
    }
    for (int i=1;i<=k;i++)
    {
        getline(cin,st);
        if (m.count(st)==1)//判断是否存在
        s++;//计数加一
    }
    cout<<s<<endl;
    return 0;
}

```

---


# 3D模型

## 题目描述

一座城市建立在规则的 $n \times m$ 网格上，并且网格均由 $1 \times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \times 1 \times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)

现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。

## 说明/提示

- $20\%$的数据满足：$n, m \leq 10$；
- $40\%$的数据满足：$n, m \leq 100$；
- $100\%$的数据满足：$1 \leq n, m \leq 1000$。


## 样例 #1

### 输入

```
3 3
111
212
111```

### 输出

```
38
```

## 样例 #2

### 输入

```
3 4
1000
0010
0000
```

### 输出

```
12```

# 题解

## 作者：Sqrt_tyz (赞：108)

很奇怪这道题竟然在大牛分站里头

个人认为~~入门~~普及难度吧


1.只需要从上、前、侧三个方面来看，将和×2即为答案。

2.但是要注意凹槽，20分一般就是没判断凹槽。

3.判断方法

（1）上面来看：直接把输入扫一遍，＞0则ans++

（2）前面来看：每一列分为一组，第一个直接加上，后面的加上与前一个的差（若小于就不加啦）

e.g.若这一列为3545，则ans=3+2+0+1=6.

（3）侧面来看：每一行分为一组，第一个直接加上，后面的加上与前一个的差（括号内容同上）

e.g.若这一行为2341，则ans=2+1+1+0=4.

※这样做即可即可解决凹槽的问题啦= =


贴代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int map[1001][1001];
char input;
int ans_u,ans_f,ans_r,n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>input;
            map[i][j]=input-'0';
        }
    //上面
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(map[i][j]>0) ans_u+=1;
        }
    //正面
    for(int j=1;j<=m;j++)
    {
        ans_f+=map[1][j]; //第一个先加上
        for(int i=2;i<=n;i++)
        {
            if(map[i][j]>map[i-1][j])
                ans_f+=(map[i][j]-map[i-1][j]); //后面的加上与前一个的差
        }
    }
    //侧面
    for(int i=1;i<=n;i++)
    {
        ans_f+=map[i][1]; //第一个先加上
        for(int j=2;j<=m;j++)
        {
            if(map[i][j]>map[i][j-1])
                ans_r+=(map[i][j]-map[i][j-1]); //后面的加上与前一个的差
        }
    }
    cout<<(ans_u+ans_f+ans_r)*2;
    return 0;
}
```
新人写题解，不喜勿喷。。


---

## 作者：LanderX (赞：55)

极其有趣的一道题对吧?


题意很明晰,暴力很明确,没有卡时限,但**细节不少**;

且听我娓娓道来...

------------

**尽量减少之后的麻烦！**

不如在代码里体会吧!

超多超多的注解，应该好理解的吧！

//~~我打了足足一个小时，应该够良心吧(?)~~


------------


```cpp
#include<bits/stdc++.h>
using namespace std;

int b[1005][1005];//这个数组存着二维角度俯视的各格高度；

bool chk[1005][1005][2][10];//这个数组看看有没有重复访问；
//前两维是每层的横纵坐标,后面分别是两个方向以及层数 

long long sum;//当然就是答案了；

int n,m;

int maxh=-10000;//是全部方块堆的最高高度；


//请先看看main里的内容,再看这个DFS；
void bfs(int x,int y,int h){

    if(x<n-1&&chk[x][y][0][h]==0) {
        //试着向x+1,y寻找相贴；
        //同时判断这个相贴计算了没有；
        chk[x][y][0][h]=1;
        if(h<=b[x+1][y]&&b[x][y]>=h){//这个可以判出是否相贴的对吧；
            sum-=2;
        }
        bfs(x+1,y,h);
    }
    
    if(y<m-1&&chk[x][y][1][h]==0){
        //再试着向x,y+1寻找相贴；
        //同时判断这个相贴计算了没有；
        chk[x][y][1][h]=1;
        if(h<=b[x][y+1]&&b[x][y]>=h){//同上咯；
            sum-=2;
        }
        bfs(x,y+1,h);
    } 
}
int main(){
	//按字符读会比较好处理吧,个人意向;
    register char input;
    //由于这个读入的字符很常用,就register咯；
    scanf("%d%d",&n,&m);
    
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>input;
            b[i][j]=input-'0';//一定要记得减'0'啊亲!；
            maxh=max(maxh,b[i][j]);
            //这样就找出了总体的最高高度，
            //为将来的逐层的dfs提供最高层数；
            sum+=6*(b[i][j]);
            //这样统计出了所有面积，之后减去贴着的面就得到了答案；
            if(b[i][j]>1) sum-=2*(b[i][j]-1);
            //这就是我所说减少麻烦的一步：
            	//高上的垛叠造成的相贴可在输入中计算出来; 
        }
    }
    for(int i=1;i<=maxh;i++){
        bfs(0,0,i);
        //i表示层数，之前已经统计过了；
        //(0,0)表示该层起始的坐标；
        //走，去看看DFS！
    }
    
    
    printf("%lld",sum);
    return 0;
}
```


------------

看懂的小伙伴赞一个好不好(/ / /w/ / /)

不理解的一定要回复一下交流一下哦！！


---

## 作者：早右昕 (赞：27)

# ~~（水）~~题解


-----


很显然，如果相邻的两个格子高度不一的话，那么这两个格子高的绝对差必然属于总侧面积的一部分；另外，上下底面积要单独处理，它们总是相同。


见代码：


```cpp

int n,m,ans;
char a[maxn][maxn];
int main() {
  cin>>n>>m;
  for(int i=1; i<=n; i++) {
    cin>>(a[i]+1);
    for(int j=1; j<=m; j++) {
      a[i][j]=a[i][j]^'0';
      if(a[i][j]) ans+=2;
    }
  }
  for(int i=1; i<=n+1; i++) {
    for(int j=1; j<=m+1; j++) {
      ans+=abs(a[i][j]-a[i-1][j]);
      ans+=abs(a[i][j]-a[i][j-1]);
    }
  }
  cout<<ans<<endl;
}

```

---

## 作者：Atmizz (赞：15)

不知你们是否觉得，输入数据没得问题，注意看题，要求的是输入字符，不是数字！！！！
所以可以先建一个数组来存入由字符变来的数字(~~阅读理解！~~：


------------

```cpp
	int map[1050][1050];//开个数组 
```


------------

所以可以先定义一个char的变量，来输入：


------------

```cpp
	char c;
```


------------

然后惹，就来想，这个与小学的数学题不一样的是下表面积也要算！
所以可以在输入的时候进行计算下表面积和下表面积（顺便也存入数组）：


------------

```cpp
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;//输入数字字符 
			map[i][j]=c-'0';//存数 
			if(c!='0')
				ans+=2;//计算上表面积与下表面积 
		}
```


------------

好，来进行计算左右前后面积，可以看出只有这四个方向，所以就好办了，就可以“打表”。只要他前后左右方向的方块少，就加上少的数量，不就行了吗！！！！
最后把答案加起来就可以输出了。
我觉得我讲的听明白的，不明白的可以问我哦！！

### 完整code：


------------

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int map[1050][1050];//开个数组 
char c;
int n,m;
int ans=0;//这就是面积 
int main()
{
	memset(map,0,sizeof(map));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;//输入数字字符 
			map[i][j]=c-'0';//存数 
			if(c!='0')
				ans+=2;//计算上表面积与下表面积 
		}
	for(int i=1;i<=n;i++)//进行四个方向计算 
		for(int j=1;j<=m;j++)
		{
			if(map[i-1][j]<map[i][j])
				ans+=map[i][j]-map[i-1][j];
			if(map[i+1][j]<map[i][j])
				ans+=map[i][j]-map[i+1][j];
			if(map[i][j+1]<map[i][j])
				ans+=map[i][j]-map[i][j+1];
			if(map[i][j-1]<map[i][j])
				ans+=map[i][j]-map[i][j-1];
		}
	printf("%d",ans);//输出答案 
}
```


------------


---

## 作者：HearTheWindSing (赞：9)

这里分享一个**较简单**的**代码量较少**的**鬼知道好不好**的方法

思路如下：
- 首先，我们可以算出每一个数字所代表的柱状体（或者说长方体）的面数

- 但是我们把这些面数加起来，会发现有很多面重叠了，于是乎我们要减去重叠的面

- 我们可以用一个`ans`来存结果，程序运算的过程就是在这个`ans`上减减加加


  那么这个方法具体啥意思？

  > 用一个用来存输入方阵的数组`a`
  >
  > 然后每输入一个值就向`ans`加上该柱状体的面数
  >
  > 设$n$为柱状体的高度，$S$ 为面数，那么计算面数的方法是
  >
  > > $S=4n+2$
  >
  > 我们把面数加进`ans`里，然后就是减去重复的面
  >
  > 由于我们是边输入边计算，所以只用考虑后面和左面的重叠
  >
  > ![](https://cdn.luogu.com.cn/upload/image_hosting/v4htlnc4.png)
  >
  > 于是乎，`ans`要减去的就是
  >
  > > $2(\min(a[i-1][j],a[i][j])+\min(a[i][j-1],a[i][j]))$
  > >
  > > 为什么要乘二呢？
  > >
  > > > 因为每重叠一次都是两个面重叠啊
  > > 
  > > 还有，要记得判断越界
  >

接下来就简单了

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int a[1000+10][1000+10],ans;

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=0;i<n;i++){
        for (int j=0;j<m;j++){
            scanf("%1d",&a[i][j]);
            if (a[i][j]==0) continue;
            ans+=a[i][j]*4+2;
            if (i-1>=0){
                ans-=min(a[i-1][j],a[i][j])*2;
            }
            if (j-1>=0){
                ans-=min(a[i][j-1],a[i][j])*2;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}

```

完结撒花，$Thank\ you\ very\ much.$



---

## 作者：Miss_dijkstra (赞：8)

在看完题解后发现没有像我一样暴力做的所以就交一发题解

~~解释在代码里~~


------------



```cpp
#include<bits/stdc++.h>
using namespace std;
int b[1010][1010];
int main()
{
	int n,m;
	cin>>n>>m;
	int sum=0;//sum用来装总和
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char x;//用char输入因为没有空格
			cin>>x;
			b[i][j]=x-'0';//转为int型
		}
		getchar();//吞掉换行
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			sum+=6*b[i][j];//一个正方形6个面（不会有人不知道吧）
			if(b[i][j]>b[i+1][j])//如果当前这个块是高于下边的块
			{
				sum-=b[i+1][j];//和就减掉比他矮的重叠部分
			}
			if(b[i][j]<=b[i+1][j])//如果当前这个块是矮于下边的块
			{
				
				sum-=b[i][j];//和就减掉他自己的高度
			}
			if(b[i][j]>b[i][j+1])//如果当前这个块是高于右边的块
			{
				
				sum-=b[i][j+1];//和就减掉比他矮的重叠部分
			}
			if(b[i][j]<=b[i][j+1])//如果当前这个块是矮于右边的块
			{
				
				sum-=b[i][j];//和就减掉他自己的高度
			}
            /*下面同上*/
			if(b[i][j]>b[i-1][j])
			{
				
				sum-=b[i-1][j];
			}
			if(b[i][j]<=b[i-1][j])
			{
				
				sum-=b[i][j];
			}
			if(b[i][j]>b[i][j-1])
			{
				
				sum-=b[i][j-1];
			}
			if(b[i][j]<=b[i][j-1])
			{
				sum-=b[i][j];
			}
			if(b[i][j]>1)//如果他是高过1的就代表他们的上下就有重叠
			{
				sum-=(b[i][j]-1)*2;//每两个块中夹着一个面，一个面要少2的面积（上下都要减）
			}
		}
	}
	cout<<sum<<endl;//输出
	return 0;
}
```

------------


---

## 作者：鹭天 (赞：6)

#来个独特的思想！

看别人的方法，我的方法跟其他人截然不同，我的算法是找重叠。

找出一个重叠，就累加上\*2（两个面）。

那么程序：

```cpp
uses math;//引用math库（NOIP似乎是允许的）
const//坐标增量，分别表示要查找的四个方向
  dx:array[1..4] of -1..1 = (-1,0,1,0);//行坐标增量
  dy:array[1..4] of -1..1 = (0,-1,0,1);//列坐标增量
var
  x,y,s,i,j,n,m:longint;
  a:array[0..1001,0..1001] of longint;
  ch:char;//要字符读入
begin
  readln(n,m);
  for i:=1 to n do begin
    for j:=1 to m do begin
      read(ch);a[i,j]:=ord(ch)-ord('0');x:=x+a[i,j];//转换到数组里面
    end;
    readln;//pascal里的bug、、如果不换行就会读入换行符，那么就炸了、、
  end;
  for i:=1 to n do 
    for j:=1 to m do
      if a[i,j]>0 then//先将本身重叠部分加起来，注：必须判断>0，且重叠部分有高度-1个面
        s:=s+(a[i,j]-1)*2;//累加上'面'的个数*2
  for i:=1 to n do
    for j:=1 to m do
      for y:=1 to 4 do//坐标增量，查找四个方向
          s:=s+min(a[i,j],a[i+dx[y],j+dy[y]]);//找到小（矮）的那个柱子。注：可直接加上
  writeln((x*6-s));//输出，总的面数-重叠部分就为剩下表面积。
end.
#标新立异!努力创造属于自己的算法！
```

---

## 作者：Wshine (赞：5)

其实这道题要注意的细节还是挺多的

先说下算法吧：

首先我们可以先来造一组简单的数据
```cpp
2 2
25
52
```

由此可以画出一张俯视图：
![](https://cdn.luogu.com.cn/upload/pic/21900.png)

可能有人会问：为什么要在周围加上一圈格子呢？先别急，我们慢慢来。

我们把这四个格子想象成四个**长宽相同**的长方体，数字即为长方体高度；对于每个长方体，有前后左右四个面，计算表面积要注意的无非就是两个长方体贴在一起的情况，**贴在一起的面是不能算入表面积里的**。

对于左上角这个高度为2的长方体，前面和左面都没有长方体贴着(面积=2)，右面和后面都贴着一个比它高的长方体，则右边和后面这两个面都不能被算入表面积(即为0)。
所以现在表面积S=S+(前)+(后)+(左)+(右)=0+(2)+(0)+(2)+(0)=4      最后考虑上下两个面，则S+=2;

而对于右上角的长方体，前面和右面无其它长方体，不多说，面积分别等于(5-0)=5；左面和后面分别贴着两个比它矮的长方体，则高出的部分要算入表面积，即(5-2)=3。
则S=S+(前)+(后)+(左)+(右)=6+(5)+(2)+(2)+(5)=20，当然还有上下两个面，S+=2。

因为此长方体**对应面面积**与**长方形的高在**数值上相同，所以可以直接用高来表示面积

所以可得出规律：

 _每个位置对于任意一个面，如果 (高 -相邻长方体的高 )>0，则表面积 S+=(高 -相邻长方体的高 ),反之则 S+=0，每判断完一个位置，S+=2_ 

**当然，对于长方体在模型边缘的情况，我们可以将边缘的面看成与一个高度为0的长方体相贴，于是就有了上图中外面的一圈。这样做的优点是不用特判边缘。**

------------

**接下来，要注意的细节**

1.**读入**。由于输入的矩阵中没有空格，所以需要用字符或字符串读入，如果你选择读入单个字符的方式，请注意考虑**换行符**

2.本题模型底面积也要考虑在内，刚刚的方法里已经将其考虑进去了。

3.对于样例2中的"0"，由于其本质是"**无长方体**"，所以不应计算上下面积，即 S 在判断完四个面之后不需加 2 。

4.如果你用三视图的方法计算的话，请考虑**凹槽**，当然，本方法不需要考虑。

5.如果你用本方法，请注意，储存模型的二维数组要略大，且下标从 [1][1] 开始，原因请看分割线上方加粗字。



------------
emmm大概就是这么多了，下面放代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;

int map[1005][1005]={0};  //储存模型 
char cache[1005];   //读入用 
int n,m;
long long S;   //表面积 

void solve()
{
	int i,j;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			S+=(  ( (map[i][j]>map[i+1][j])?(map[i][j]-map[i+1][j]):0 ) + ( (map[i][j]>map[i-1][j])?(map[i][j]-map[i-1][j]):0 ) + ( (map[i][j]>map[i][j+1])?(map[i][j]-map[i][j+1]):0 ) + ( (map[i][j]>map[i][j-1])?(map[i][j]-map[i][j-1]):0 ) + ((map[i][j]==0)?0:2)  );
			//套公式部分。。。具体请看思路的斜体字部分。
			//这里只是用“?:”运算符将式子弄成了一行 
		}
	}
	printf("%lld",S);    //输出表面积S 
}

int main()
{
	scanf("%d %d",&n,&m);
	int i,j,k;
	for(i=1;i<=n;i++)     //读入部分，每次读入一个字符串 ，也就是一行 
	{
		scanf("%s",cache);
		for(j=0;j<strlen(cache);j++)
		{
			map[i][j+1]=cache[j]-'0';   // j+1的问题请看 细节部分的第5条 
		}
	}
	
	solve();
	
	return 0;
}
```

结束~~~>_<

---

## 作者：ArachnidaKing (赞：5)

本题众多解法中~~本蒟蒻唯一会的~~最简单的一种缺点在于实现麻烦，即求出总面数（方块数×6）后减掉重叠面数。代码、讲解如下：（实力不足所以用三维数组模拟）
```cpp
#include<iostream>//用于max()函数 
#include<cstdio>//用于输入输出 
#include<cstring>//用于memset() 
using namespace std;//名字空间不用解释

#define itn int//避免手误，多处手滑把int敲成itn 
#define maxn 1005//他们说这样快 

int num_block=0,cdm=0,i,j,n,m,num_ceng=0,num_ceng1=0,mapp[maxn][maxn];
bool room[12][maxn][maxn];//实际空间1层开始，10层结束 

itn main()
{
	memset(room,0,sizeof(room));//全部写零 
	scanf("%d%d",&n,&m);//输入n,m
	for(i=1;i<=n;++i)
	{
		for(j=1;j<=m;++j)
		{
			scanf("%1d",&mapp[i][j]);
			num_block+=mapp[i][j];
			num_ceng=max(num_ceng,mapp[i][j]);
		}
	}
	num_ceng1=num_ceng;
	//二维转三维（升维打击） 部分 
	while(num_ceng)//虚拟转换器工作平面图最大层数（即模型层数）次 
	{
		for(i=1;i<=n;++i)//该层行循环 
		{
			for(j=1;j<=m;++j)//该层列循环 
			{
				if(mapp[i][j])//只要当前位置还有方块 
				{
					room[num_ceng][i][j]=1;//虚拟空间相应位置从无（0/false）变有（1/true） 
					--mapp[i][j];//可以想象为此（三维概念的）列砍掉最下面一块放入三维虚拟空间 
				}
			}
		}
		--num_ceng;//类似于3D打印机，虚拟转换器转完一层下移一层 
	}
	for(int i=1;i<=num_ceng1;++i)//每一层循环 
    {
    	for(itn j=1;j<=n;++j)//当前层每一行循环 
    	{
    		for(itn k=1;k<=m;++k)//当前层行每个空间循环 
    		{
    			if(room[i][j][k])//当当前位置有方块时 
    			{
    				if(room[i+1][j][k])++cdm;//判断该方块上有无重叠面
    				if(room[i-1][j][k])++cdm;//判断该方块下有无重叠面
    				if(room[i][j+1][k])++cdm;//判断该方块前有无重叠面
    				if(room[i][j-1][k])++cdm;//判断该方块后有无重叠面
    				if(room[i][j][k-1])++cdm;//判断该方块左有无重叠面
    				if(room[i][j][k+1])++cdm;//判断该方块右有无重叠面
				}
			}
		}
	}
	printf("%d",num_block*6-cdm);//输出公式 
	return 0； 
}//本代码已进行防抄袭处理^v^ 
```

---

## 作者：梦里调音 (赞：3)

本蒟蒻思路和大家不太一样。

主要是**数论**：

输入比较麻烦，不多说；

还要注意在枚举判断时要有不等于0的条件（eg.样例2，不判断的话是32）

每个位置初始表面积至少有6（即块数为1），后面每多一块面积就多4（相当于侧面积）；

后面再来判断四周，减掉贴的面积，即为该位置的最终表面积。

注意减法之前要判断是否四周都有方块（eg.（1,1）只用判断2次）。

你们加油~

```cpp
#include <bits/stdc++.h>
using namespace std;
int s[1001][1001];
char a;
int main(){
	int i,j,k,m,n,ans=0;
	cin>>n>>m;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++){
			cin>>a;
			s[i][j]=a-'0';
		}
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			if(s[i][j]!=0){
			k=0;
			k+=6+(s[i][j]-1)*4;
			if(j+1<=m){
				if(s[i][j+1]>=s[i][j])k-=s[i][j];
				else k-=s[i][j+1];
			}
			if(j-1>=1){
				if(s[i][j-1]>=s[i][j])k-=s[i][j];
				else k-=s[i][j-1];
			}
			if(i+1<=n){
				if(s[i+1][j]>=s[i][j])k-=s[i][j];
				else k-=s[i+1][j];
			}
			if(i-1>=1){
				if(s[i-1][j]>=s[i][j])k-=s[i][j];
				else k-=s[i-1][j];
			}
//			cout<<k<<" ";
			ans+=k;
		}
	cout<<ans;
    return 0;
} 
```

---

## 作者：Dilute (赞：2)

#很奇怪明明我这种方法最容易想到怎么就没人写呢

这种方法完全就是没有半点思维难度直接暴力，建一个三维数组来存储这个城市，然后穷举一遍这个城市中的所有方块，把它的上下左右前后四个面看一遍，如果该面前面没有方块就说明这个城市多了1表面积，ans++，就是了呗

下面上代码

```cpp
#include<bits/stdc++.h> // 万能头文件（保险起见还是介绍一下吧） 

bool isb[1010][1010][11]; // 用于存储城市的数组 
int h[1010][1010];
int opt[10][4] = {{1, 0, 0},{-1, 0, 0},{0, 1, 0},{0, -1, 0},{0, 0, 1},{0, 0, -1}}; // 六个面的数据 

int main(){
　　memset(isb, false, sizeof(isb)); // 初始化 
　　int n, m;
    scanf("%d %d", &n, &m); // 读入 
    for(int i = 1; i <= n; i++){
        char s[1010]; // 用于存储一行的字符串 
        scanf("%s", s);
　　　　　for(int j = 0; j < m; j++){
    　　　　h[i][j+1] = s[j] - '0'; // 将字符0转换成数字0 
            for(int k = 1; k <= h[i][j+1]; k++){
                isb[i][j+1][k] = true; // 循环一遍来生成对应一个格子的方块 
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 0; j < m; j++){
    　　　　    for(int k = 1; k <= h[i][j+1]; k++){ // 穷举每个点 
        　　　    if(isb[i][j+1][k]){ // 如果这个点上面有方块 
                    for(int p = 0; p < 6; p++){ // 穷举每个面 
    　　　　　            if(!isb[i+opt[p][0]][j+1+opt[p][1]][k+opt[p][2]]) // 如果这个面上没有方块 
                            ans++; // 就说明这个城市多了1的表面积 
                    } // 不管有几行都把大括号打全是个好习惯！ 
                }
    　　　    }
        }
    }
　　printf("%d", ans);
}
```
想抄题解的留步，阴险的我在里面加了一堆全角空格（233333）


---

## 作者：c_come (赞：2)

~~在洛谷刷水题上瘾~~

看了一下，大概是最简单的一份cpp？

思想和最高票答案是一样的，只是边输入边计算。
```cpp
#include <iostream>
using namespace std;

int ans = 0;
char now;
int m,n;
int g[1002][1002] = {0};

int main(){
	cin >> m >> n;
	for(int i = 1;i <= m;++i){
		for(int j = 1;j <= n;++j){
			cin >> now;
			g[i][j] = now - '0';
			if(g[i][j])++ans;
			if(g[i][j] > g[i][j-1])ans += g[i][j] - g[i][j-1];
			if(g[i][j] > g[i-1][j])ans += g[i][j] - g[i-1][j];
		}
	}
	ans *= 2;
	cout << ans;
	return 0;
}
```

---

## 作者：ixxxxx (赞：1)

# 一个蒟蒻的良心题解）
这题有意思啊 想了挺久 终于想出了一个自认为简单的方法（笑

### 一个方块6有面，判断它旁边有没有方块挨在一起 如果有就少了一个面 然后再一个方块一个方块一个面一个面判断不就好了嘛 (^o^)/

~~哇超简单易懂嘿嘿~~

#### 看题解时发现有类似方法 但是解释的不够清楚啊 * 所以自己解释得更详细一些 希望管理员大大能给通过啊 ~~（给大佬端茶）~~

废话少说 上代码（超多注释的那种）


------------

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int map[1005][1005],sum=0;//接收数据 和 计面数 用 
int 3Dmap[14][1005][1005];//  (如名字） 用三维数组记录这个城市  3Dmap[层数][横坐标][纵坐标]；
char gd[1005][1005]; //因为给的数据没有空格，所以要使用字符串接收数据 
int mx[2]={1,-1},my[2]={1,-1};//后面判断前后左右有没有方块用 
int main()
{
    int n,m,i,j,k,l,max=0;// max表示最高有几层  后面的循环省时间 
    cin>>n>>m;//来了来了 
    for(i=0;i<=n-1;i++)
    {
        cin>>gd[i];// *巨坑* 因为字符串会存储 空格符 和 换行符 一个字符一个字符输入会出现错误 所以直接输入一行 
    }
    for(i=0;i<n;i++)//把录入的字符串转成数组存起来  
    {
        for(j=0;j<m;j++)
        {
            map[i+1][j+1]=gd[i][j]-48; //map从1开始录入 目的是在城市外围加一圈 0 ； 
            if(map[i+1][j+1]>=max) max=map[i+1][j+1]; //判断最高层  
        }
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            for(k=1;k<=map[i][j];k++)
            {
                3Dmap[k][i][j]=1; //用三维数组 将城市立体存下 
            }
        }
    }
    for(k=1;k<=max;k++)//一层一层判断  
    {
        for(i=0;i<=n+1;i++)
       {
          for(j=0;j<=m+1;j++)
          { 
             if(3Dmap[k][i][j]!=0) //判断该层该坐标有没有方块 有就执行下一步 
             {
                for(l=0;l<=1;l++)  
                {
                    if(3Dmap[k][i+mx[l]][j]==0) //判断 前 后 有没有方块 没有意味着这一个面暴露在外 
                    {
                        sum++;    //表面积++ 
                    }
                    if(3Dmap[k][i][j+my[l]]==0) //判断 左 右 有没有方块 没有意味着这一个面暴露在外 
                    {
                        sum++;  //表面积++
                    }
                }
                if(3Dmap[k-1][i][j]==0) //判断 下面 有没有方块 没有意味着这一个面暴露在外 
                {
                        sum++;//表面积++
                }
                if(3Dmap[k+1][i][j]==0)////判断 上面 有没有方块 没有意味着这一个面暴露在外 
                {
                        sum++;//表面积++ 
                }
             }
          }
       }
    }
    cout<<sum;//大功告成 \(^o^)/ 
    return 0;
}
```


------------

啊第一篇题解说实话有点小激动

本蒟蒻能力有限 代码有些繁琐啦 各位神犇要是觉得不足请多多指教O(∩_∩)O~~

---

## 作者：Dvelpro (赞：1)

emmm 刚开始看觉得好麻烦的 后来仔细想了想觉得 是个大水题
题解有注释
```c
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000+100
int a[maxn][maxn];
int main(){
  int n,m;
  cin>>n>>m;
  for(int j=1;j<=n;j++){
     for(int k=1;k<=m;k++){
        char c;
        cin>>c;
        a[j][k]=c-'0';  //输入
     }
  }
  long long ans=0;
  for(int j=1;j<=n;j++){
     for(int k=1;k<=m;k++){
        ans+=6*a[j][k];      //每个正方体6个面
       // cout<<ans<<" ";
        if(a[j][k]>1){
           ans-=(a[j][k]-1)*2;  // 大于1 的时候 会有 上下接触 而且每次接触面积-2
        }
        // 这是上下左右 每个面与其他面一共有多少个接触 就把他减去
        ans-=min(a[j][k],a[j-1][k]); 
        ans-=min(a[j][k],a[j+1][k]);
        ans-=min(a[j][k],a[j][k-1]);
        ans-=min(a[j][k],a[j][k+1]);
       // cout<<ans<<endl;
     }
  }
  cout<<ans<<endl;//愉快的输出答案

  return 0;
}

```

---

## 作者：water_mi (赞：1)

---

#### 思路
1.先将底面积与顶面积算出（就相当于算顶面积$S_1*2$）
2.这个思想有点难理解：
因为要算的面积肯定是人眼能够看见的，而且题目保证建筑物不会中空（不然就成了豆腐渣建筑=.=），而且，一个表面有且仅有一个与它相邻的表面是不是？
所以，不放建立一个$9*n*m$的三维数组：
阅读提示:$ll$即为$long$ $long$
```cpp
const ll maxn = 1e3 + 10,maxm = 1e3 + 10;
bool mod[10][maxn][maxm];
//mod[k][i][j]表示第k层第i行第j列是否有方块（真或假）
```
你问我读入怎么读？
读入方法了解一下：
```cpp
ll n,m,s;//s为表面积
char l[maxm];
for(register ll i = 1;i <= n;++i){
	cin >> l;//读入一个字符串
    for(register ll j = 1;j <= m;++j){
		ll a = l[j - 1] - '0';//将字符串处理成布尔值
        if(a > 0) ++s;//计算顶面积
        for(register ll k = 1;k <= a;++k)
            mod[k][i][j] = true;//这个还需要解释233
    }
}
```
3.计算其他面的面积
因为一个表面有且仅有一个与它相邻的表面
所以我们选择扫描空位（3个$for$循环），然后判断它四周是否有表面，有则加上。
#### 代码
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using std::cin;
using std::cout;
typedef long long ll;

const ll maxn = 1e3 + 10,maxm = 1e3 + 10;
ll n,m,s;
char l[maxm];
bool mod[10][maxn][maxm];
ll dx[5] = {0,0,0,1,-1},
   dy[5] = {0,1,-1,0,0};

int main(){
    scanf("%lld %lld",&n,&m);
    for(register ll i = 1;i <= n;++i){
	    cin >> l;
        for(register ll j = 1;j <= m;++j){
			ll a = l[j - 1] - '0';
            if(a > 0) ++s;
            for(register ll k = 1;k <= a;++k)
                mod[k][i][j] = true;
        }
    }
    s <<= 1;
    for(register ll k = 1;k <= 9;++k)
        for(register ll i = 0;i <= n + 1;++i)
            for(register ll j = 0;j <= m + 1;++j)
                if(!mod[k][i][j])
                    for(register ll t = 1;t <= 4;++t){
                        ll x = i + dx[t],y = j + dy[t];
                        if(x >= 1 && y >= 1 && x <= n && y <= m && mod[k][x][y])
                            ++s;
                    }
    printf("%lld\n",s);
    return 0;
}

```

---

## 作者：Henry_he (赞：1)

本题其实挺简单的


只需要判断露出来的面就可以啦


首先上面和下面只需要判断該格子是否有方块，如果有就加二


判断左右面的面因为可能存在凹槽而不能简单判断


我们可以单独拿出其中一行来分析


我们可以发现其实露出来的面就是左右两列的差的绝对值


for example（主视图）:

![可爱的qhy](https://cdn.luogu.com.cn/upload/pic/13662.png )


第一列与第零列高度差为2，所以最左边的露出了两个面


第二列与第一列高度差为1，所以露出了一个面


以此类推（Ps:不要忘记加上第n列同第n+1列的差），把每一行露出的面加起来就是左右面的面积


同理，前后面有左右面处理一样，这里不再赘述


附代码


```pascal
var f:array[0..1000,0..1000]of longint;
    n,m,i,j:longint;
    ans:longint;
    s:ansistring;
begin
  readln(n,m);
  ans:=0;
  for i:=1 to n do
  begin
    readln(s);
    for j:=1 to m do
    begin
      f[i,j]:=ord(s[j])-48;
      if f[i,j]>0 then ans:=ans+2;
    end;
  end;
  for i:=1 to n do
  begin
    for j:=1 to m do
      ans:=ans+abs(f[i,j]-f[i,j-1]);
    ans:=ans+f[i,m];
  end;
  for j:=1 to m do
  begin
    for i:=1 to n do
      ans:=ans+abs(f[i,j]-f[i-1,j]);
    ans:=ans+f[n,j];
  end;
  writeln(ans);
end.
```

---

## 作者：二力平衡树 (赞：1)

一道暴力水题，个人认为难度应该属于普及-

我们可以将输入数据中的每一个元素的四个方向单独考虑，把所有物体的顶部面积和底部面积一起考虑。

假设输入为：1 2，那么第一块的四个方向的表面积为：

Left:1
front:1

right:0

behind:1

第二块的四个方向的表面积为：

Left:1
front:2

right:2

behind:2

总体顶部的面积为:2

总体底部的面积为:2

将他们加起来就是最终的答案。

所以我们就可以得出结论：

1.如果X方向没有物体,那么表面积 = N物体的高度

2.如果一个方向有物体而且这个物体比他高,那么表面积=0

3.如果一个方向有物体而且这个物体比他低,那么表面积=N物体的高度-M物体的高度

4.如果一个方向有物体而且这两个物体相等,那么表面积=0

5.底层表面积总数和顶层表面积总数为高度>0的物体的数量

代码附上:

```cpp
#include <bits/stdc++.h>
using namespace std;
int ans = 0,n,m,Map[1001][1001],T;//T记录了有多少个高度>0的物体 

void GetC(void)
{
    char ch,str[1001];
    T=0;
    cin >> n >> m;

    for(int i = 0;i < n;i++)
    {
        cin >> str;
        for(int j = 0;j < m;j++)
        {
            if(str[j] != '0')
                T++;
            Map[i][j] = str[j]-'0';
        }
    }
}

int main(int argc,char ** argv)
{
    ios::sync_with_stdio(false);
    void Resolution(void);
    GetC();//输入 
    Resolution();//解析 
    cout << ans;
    
    return 0;
}

void Resolution(void)
{
    ans = T*2;//把底面积和顶面积的和赋值给ans 
    for(int i = 0;i < n;i++)
    {
        for(int j = 0;j < m;j++)
        {
            if(j-1<0)//Left
                ans+=Map[i][j];//如果这个方向没有物体那么答案累加这个物体的高度 
            else if(Map[i][j-1] < Map[i][j])
                ans+=(Map[i][j] - Map[i][j-1]);//如果一个方向有物体而且这个物体比他低,那么答案累加=N物体的高度-M物体的高度
            //下同 
                
            if(i-1<0)//front
                ans+=Map[i][j];
            else if(Map[i-1][j] < Map[i][j])
                ans+=(Map[i][j] - Map[i-1][j]);
            
            if(j+1>=m)//right
                ans+=Map[i][j];
            else if(Map[i][j+1] < Map[i][j])
                ans+=(Map[i][j] - Map[i][j+1]);
            
            if(i+1>=n)//behind
                ans+=Map[i][j];
            else if(Map[i+1][j] < Map[i][j])
                ans+=(Map[i][j]-Map[i+1][j]); 
        }
    } 
}
```

---

## 作者：Mychael (赞：1)

我觉得嘛，楼下的方法过于繁琐了，向您说的普及-的题目还需要这样操作么

比较简洁的方法：

按读入顺序逐个加入n\*m个四棱柱

每次加入的时候先ans += 加入的四棱柱的表面积【即4 \* h + 2】

因为只有左边和上边会与当前重叠，重叠时两个之中高度矮高度就是重叠高度h，面积就减少2 \* h，直接减去就好了


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1005;
int h[maxn][maxn];
int main(){
    int n,m,ans = 0;
    char c;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++){
            c = getchar(); while (c < 48 || c > 57) c=getchar();
            h[i][j] = c - '0';
            if (!h[i][j]) continue;
            ans += 4 * h[i][j] + 2;
            if (i > 1) ans -= 2 * min(h[i][j],h[i - 1][j]);
            if (j > 1) ans -= 2 * min(h[i][j],h[i][j - 1]);
        }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：亦笙箫 (赞：0)

这道题拿到之后第一反应

## 暴力！！！

但是有凹槽的情况，所以我们的难点就到了处理凹槽上。

对于凹槽，我们可以有两组数据，第一组长这个样子

>$3~3$  
>$222$  
>$212$  
>$222$

这组数据很明显，很容易过掉，然后交上去。。。

***********

我们再来把上面的数据给拓展一下

>$5~5$  
>$33333$  
>$31113$  
>$31213$  
>$31113$  
>$33333$

(~~这个凹槽恶心人恶心出境界了。。。~~

所以我们如果根据每个凹槽来判断是很难以实现~~恶心人~~的。

然后我们发现它露出的表面积**只和它的两侧有关**，于是我们就可以**只比较它和两侧的大小**，然后加上差值。

得出正解:

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int MAXX = 1000;

int read()
{
	int x=0,f=1;char s=getchar();
	while(!isdigit(s)){ if(s=='-') f=-1; s=getchar(); }
	while(isdigit(s)){ x=(x<<3)+(x<<1)+(s^48); s=getchar(); }
	return x*f;
}

int n,m;

long long ans;

int a[MAXX+5][MAXX+5];

int main()
{
	n=read();m=read();
	char s;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>s;
			a[i][j]=s-48;
			if(a[i][j]>0) ans++;
		}
	for(int j=1;j<=m;j++)
    {
        ans+=a[1][j];
        for(int i=2;i<=n;i++)
            if(a[i][j]>a[i-1][j])
                ans+=(a[i][j]-a[i-1][j]);
    }
    for(int i=1;i<=n;i++)
    {
        ans+=a[i][1];
        for(int j=2;j<=m;j++)
            if(a[i][j]>a[i][j-1])
                ans+=(a[i][j]-a[i][j-1]);
    }
	printf("%lld\n",ans*2);
	return 0;
}
```


---

## 作者：yu__xuan (赞：0)

### 题目
[P1187 3D模型](https://www.luogu.org/problem/P1187)
### 思路
模拟。本题需要计算下底面，我们先计算出下底面的个数，很明显只要$map[i][j]$这个地方的方块数大于零下底面就加一。
$n$个立方体摞在一起四周没有方块遮住他并且不记下表面那么面数为($n \times 5-n+1$),如果四周有遮挡假设四周都有$k$个立方体那么面数要减去$min(n,k) \times 4$。最后面数加上底面就是答案
### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#define MAXN 1001
#define rr register
using namespace std;
int n,m,ans,sum;
int map[MAXN][MAXN],dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0};
inline void read(int &T){
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int main(){
	read(n),read(m);
	char c;
	for(rr int i=1;i<=n;++i){
		for(rr int j=1;j<=m;++j){
			cin>>c;
			map[i][j]=c-'0';
			if(map[i][j]) sum++;
		}
	}
	for(rr int i=1;i<=n;++i){
		for(rr int j=1;j<=m;++j){
			if(map[i][j]){
				ans+=map[i][j]*5;
				ans-=(map[i][j]-1);
				for(rr int k=1;k<=4;++k){
					int c=i+dx[k],d=j+dy[k];
					if(c>0&&c<=n&&d>0&&d<=m&&map[c][d]){
						ans-=min(map[c][d],map[i][j]);
					}
				}
			}
		}
	}
	cout<<ans+sum<<'\n';
	return 0;
}
```

---

## 作者：weidong3274 (赞：0)


思路很简单

：

1.先加上 上下两面；

2.对任意一竖方块，露出的表面积=他的高度减去比他矮的相邻的方块堆
（对于最外的方块也适用）


一般会碰到的问题

1.问题：读入

因为连在一起所以用char

2.ans 因为要加上下面

一开始我默认每个都有格子所以直接
ans=2 * n * m

然后WA

3.数组太大 要放主函数外


```
#include <bits/stdc++.h>
using namespace std;
int n,m,a[1005][1005],ans;
char x;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char x;
            cin>>x;
            a[i][j]=x-'0';
        }
        getchar();
    }
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		if(a[i][j]>0)
		ans+=2;
		if(a[i][j]>a[i+1][j])
		ans+=a[i][j]-a[i+1][j];
		
		if(a[i][j]>a[i-1][j])
		ans+=a[i][j]-a[i-1][j];
		
		if(a[i][j]>a[i][j-1])
		ans+=a[i][j]-a[i][j-1];
		
		if(a[i][j]>a[i][j+1])
		ans+=a[i][j]-a[i][j+1];
	} 
	
	cout<<ans;
	
	return 0;
}
```


---

## 作者：IzzelAliz (赞：0)

怎么想的呢？既然每个方块只能从下往上堆，就不要想着从正面侧面统计了，总会有凹槽啥的。

既然是从下往上堆，那么我们可以算出方块总数，顺便计算每一格方块重叠起来的面的数量。

变量 a 是方块个数，b 是重叠的面数，`a*6-b` 自然就是露在外面的数量。

```cpp
#include<bits/stdc++.h>
using namespace std;

int m, n; char c;
int arr[1001][1001] = {false};

int main() {
	cin>>n>>m;
	for (int x = 0; x < n; x++) {
		for (int y = 0; y < m; y++) {
			cin>>c;
			arr[x][y] = c - '0';
		}
	}
	int a = 0, b = 0, t = 0;
	for (int x = 0; x < n; x++) {
		for (int y = 0; y < m; y++) {
			t = arr[x][y];
			a += t;	b += max((t-1)*2, 0);
			if (x > 0) b += min(t, arr[x-1][y]);
			if (y > 0) b += min(t, arr[x][y-1]);
			if (x+1 < n) b += min(t, arr[x+1][y]);
			if (y+1 < m) b += min(t, arr[x][y+1]);
		}
	}
	cout<< (a*6 - b) <<endl;
	return 0;
}
```

---

## 作者：Asuka (赞：0)

## 思路

这道题显然是一道简单粗暴的模拟题，

只要考虑各种情况然后将答案输出即可。


首先我们用一个，二维数组h来储存题目给出的矩阵。

要注意第一个数要从h[1][1]存起而不能是h[0][0]，且这个数组是全局变量（当然用局部变量再初始化为0也可以），

这么做的理由我会在后面阐述。


先对整个3D模型的上表面和下表面进行处理，

建立一个循环，循环整个数组，如果h[i][j]不为0（即该位置有方块），则令ans+=2。


然后对3D模型的前后表面以及左右表面进行处理，

因为当一个方块比他左边的方块高时，他的左面便会露出来，因此需要将这部分表面积(h[i][j]-h[i][j-1])加给ans，

要注意他左边的方块有可能不存在，即h=0，

这时将数组h的起点设置为h[1][1]的理由就浮出水面了：

当其边界存在方块时，我们需要减0来计算出边界方块所露出的表面积。


按照这种思路对右面以及前后表面处理，所得结果即为所要求的表面积。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Asuka=1e3+5;

int n,m,ans;
int h[Asuka][Asuka]={0};
char o[Asuka];

int main()
{
    scanf("%d %d",&n,&m);
    
    for(int i=1;i<=n;i++)//用字符数组进行读入
        {    
            scanf("%s",o);
            int l=strlen(o);
            for(int re=0;re<l;re++) 
            {
            h[i][re+1]=o[re]-'0';
            if(h[i][re+1]>0)ans+=2;//读入时处理，减少循环次数，对上表面下表面进行处理。
            }
        }
    
    int a,b;    
    for(int i=1;i<=n;i++)//左右表面处理
    {
        a=1;
        b=m;
        while(a<=m)
        {
            if(h[i][a]-h[i][a+1]>0)ans+=h[i][a]-h[i][a+1];
            if(h[i][b]-h[i][b-1]>0)ans+=h[i][b]-h[i][b-1];
            a++;
            b--;
        }
    }
    for(int j=1;j<=m;j++)//前后表面处理
    {
        a=1;
        b=n;
        while(a<=n)
        {
            if(h[a][j]-h[a+1][j]>0)ans+=h[a][j]-h[a+1][j];
            if(h[b][j]-h[b-1][j]>0)ans+=h[b][j]-h[b-1][j];
            b--;
            a++;
        }
    }
    printf("%d",ans); 
}
```

---

## 作者：吴海啸 (赞：0)

var a:array[0..1001,0..1001]of longint;//这里一定要多1，否则超界

```cpp
i,j,n,m,t:longint;c:char;
begin
readln(n,m);
for i:=1 to n do
begin
    for j:=1 to m do
    begin read(c);a[i,j]:=ord(c)-48;end;//使用字符读入数据
    readln;//一定要加，不然出错
end;
t:=0;//计数器清空
for i:=1 to n do
    for j:=1 to m do
    if a[i,j]>0 then begin t:=t+2;//如果此处有块，则加上上面和下面
    if a[i,j]>a[i+1,j]then t:=t+(a[i,j]-a[i+1,j]);
    if a[i,j]>a[i-1,j]then t:=t+(a[i,j]-a[i-1,j]);
    if a[i,j]>a[i,j+1]then t:=t+(a[i,j]-a[i,j+1]);
    if a[i,j]>a[i,j-1]then t:=t+(a[i,j]-a[i,j-1]);end;//向四周搜索
write(t);
end.
总之，这题使用模拟法。用一个二维数组，每个单元存相应的高度。使用二重循环，如果高度大于0就面积+2，并且与四周比较，加上比四周格子高的差值。
```

---

## 作者：doby (赞：0)

这题不是动态规划……

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,d[1009][1009],ans=0;
char c;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>c;
            if(c!='0'){d[i][j]=c-48,ans++;}//如果这个位置上有方块，平面上的个数++
        }
    }
    ans=ans*2;//下面也要算……
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(d[i][j]>d[i+1][j]){ans=ans+d[i][j]-d[i+1][j];}//如果比四个方向上的面积高就可以加上去高出的面积
            if(d[i][j]>d[i-1][j]){ans=ans+d[i][j]-d[i-1][j];}
            if(d[i][j]>d[i][j+1]){ans=ans+d[i][j]-d[i][j+1];}
            if(d[i][j]>d[i][j-1]){ans=ans+d[i][j]-d[i][j-1];}
        }
    }
    printf("%d",ans);
}
```

---

## 作者：火柴神 (赞：0)

先计算上下两个面，如果格子比一侧高，再计算每一个格子与该侧的高度差，高度差即为该侧表面积，全部相加，则为整体表面积


代码如下




```cpp
#include<cstdio>
#include<algorithm>
int a[2000][2000];
int n,m;
int ans;
int main(){
    scanf("%d%d\n",&n,&m);
    char c;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%c",&c);
            a[i][j]=c-48;
        }
        scanf("\n");
    }
    ans=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]>0)ans+=2;
            if(a[i][j]>a[i][j-1])ans+=a[i][j]-a[i][j-1];
            if(a[i][j]>a[i-1][j])ans+=a[i][j]-a[i-1][j];
            if(a[i][j]>a[i][j+1])ans+=a[i][j]-a[i][j+1];
            if(a[i][j]>a[i+1][j])ans+=a[i][j]-a[i+1][j];
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：YWY_wys (赞：0)

# 统计的技巧

- 题意：

- 题解：对于每一个格子上的立方体而言，我们先将每个格子上的若干个个立方体的表面积加上，再删除这若干个立方体被覆盖的面积即可。显然，每个格子上的立方体的表面积是4\*h+2，他有四个面，只需统计这四个面被覆盖掉的面积再减去即可。

- code：

```cpp
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=1005;
int n,m;
int a[maxn][maxn];
string s;
void inita(){//初始化a矩阵（也就是这个建筑）
    for(int i=1;i<=n;i++){
        cin>>s;
        for(int j=0;j<m;j++)
            a[i][j+1]=s[j]-'0';
    }
}
int updata(int x,int y){//对于每个建筑进行更新
    int res=0;
    if(!a[x][y]) return 0;
    res+=(a[x][y]<<2)+2;
    if(x-1>=1) res-=min(a[x-1][y],a[x][y]);
    if(x+1<=n) res-=min(a[x+1][y],a[x][y]);
    if(y-1>=1) res-=min(a[x][y-1],a[x][y]);
    if(y+1<=m) res-=min(a[x][y+1],a[x][y]);
    return res;
}
int calc(){//统计答案
    int res=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            res+=updata(i,j);
    return res;
}
int main(){
    scanf("%d%d",&n,&m);
    inita();
    printf("%d",calc());
}
```
# 作者想说的一些话：本来这个体可以不用写题解的。其他的题解都很好

但是我个人觉得我解这个题的角度有值得学习的地方。

这个题之前用字符处理错了无数次QAQ


---


# [蓝桥杯 2024 省 B 第二场] 逆序对期望

## 题目描述

有一个数组，包含 $1$ 到 $n$ 这 $n$ 个整数，初始为一个从小到大的有序排列：$\{1, 2, 3, 4, \dots , n\}$。一次随机交换操作指：均匀随机选取两个位置 $i, j \in [1, n]$ 且 $i \neq j$，然后交换数组中这两个位置上的数。那么对于 $n = 51$，对初始数组进行两次随机交换操作之后，数组中的逆序对的数量的期望是多少个。

# 题解

## 作者：ZYX0716 (赞：3)

## [题目](https://www.luogu.com.cn/problem/P12122)大意：

给出一个序列，其元素依次为 $1,2,3,\cdots,51$。每次随机交换两对数，请你求出逆序对的数量的期望值。

由于题目中未给出**逆序对的定义**，在这里强调一下：逆序对就是数组序列中  $a[i]>a[j]$  且  $i<j$  的有序对。

## 思路：

因为只需输出答案，因此可以先**暴力**求出结果。求逆序对的方法我这里用的是**归并排序**。

## 暴力求答案：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n=51,a[505],b[505];
double ans,s;
void merge(int l1,int r1,int l2,int r2){
	int cnt=0,begin=l1,end=r2;
	while(l1<=r1 && l2<=r2){
		if(a[l1]<=a[l2]){
			b[++cnt]=a[l1++];
		}else{
			b[++cnt]=a[l2++];
			ans+=r1-l1+1;
		}
	}while(l1<=r1){
		b[++cnt]=a[l1++];
	}while(l2<=r2){
		b[++cnt]=a[l2++];
	}for(int i=begin,j=1;i<=end && j<=cnt;i++,j++){
		a[i]=b[j];
	}
	return;
}
void mergesort(int l,int r){
	int mid=(l+r)/2;
	if(l<mid)mergesort(l,mid);
	if(mid+1<r)mergesort(mid+1,r);
	merge(l,mid,mid+1,r);
	return;
}
//merge与mergesort函数是归并模板。
int main(){
	for(int i=1;i<=n;i++){//原数列。
		a[i]=i;
	}for(int i=1;i<=n;i++){//暴力枚举。
		for(int j=i+1;j<=n;j++){
			for(int k=1;k<=n;k++){
				for(int l=k+1;l<=n;l++){
					swap(a[i],a[j]);
					swap(a[k],a[l]);
					mergesort(1,n);
					s++;
				}
			}
		}
	}
	printf("%.2lf",ans/s);//输出答案。
	return 0;
}
```

## AC Code：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double ans=65.33;
	printf("%.2lf",ans);
	return 0;
}
```

---

## 作者：lczhouzihao (赞：1)

一个数组序列中有这样一对数：$a[i]>a[j]$ 且 $i<j$。那么就把这一对数成为**逆序对**。

本题只需要输出最终答案，这里给出一种暴力的解法：

首先暴力枚举所有可能的两次交换操作，接着计算每种操作的逆序对，最后求平均值。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[52],b[52];
int cnt(int a[],int n){
    int res=0;
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            if(a[i]>a[j])res++;
    return res;
}
int main(){
    int n=51;
    for(int i=1;i<=n;i++)a[i]=i;
    double s=0,t=0;
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            memcpy(b,a,sizeof(a));
            swap(b[i],b[j]);
            for(int k=1;k<=n;k++){
                for(int l=k+1;l<=n;l++){
                    int c[52];
                    memcpy(c,b,sizeof(b));
                    swap(c[k],c[l]);
                    s+=cnt(c,n);
                    t++;
                }
            }
        }
    }
    printf("%.2f",s/t);
    return 0;
}
```

虽然会超时，但是只需得出最后答案，是`65.33`。

---

## 作者：yanmingqian (赞：1)

直接暴力跑就行。

我们直接枚举两次交换的位置，然后手动交换暴力跑 $O(n^2)$ 逆序对就行。提交答案题，超时也没关系。

```cpp
#include<iostream>
using namespace std;
int x[55];
int solve(){
    int sum=0;
    for(int i=1;i<=51;i++){
        for(int j=i+1;j<=51;j++){
            if(x[j]<x[i]){
                sum++;
            }
        }
    }
    return sum;
}
int main(){
    for(int i=1;i<=51;i++){
        x[i]=i;
    }
    int cnt=0,sum=0;
    for(int a=1;a<=51;a++){
        for(int b=a+1;b<=51;b++){
            for(int c=1;c<=51;c++){
                for(int d=c+1;d<=51;d++){
                    cnt++;
                    swap(x[a],x[b]);
                    swap(x[c],x[d]);
                    sum+=solve();
                    swap(x[c],x[d]);
                    swap(x[a],x[b]);
                }
            }
        }
    }
    printf("%.2f",1.0*sum/cnt);
    return 0;
}
```

输出是 `65.33`。

时间复杂度是 $O(n^6)$ 的，不过由于 $n$ 比较小，跑得飞快，一秒多点就跑过去了。怀疑跑 $O(n \log n)$ 的逆序对可以直接跑过去而不需要本地求完输出。

---

## 作者：syy999 (赞：0)

因为这道题目是提交答案题。

所以我们可以先暴力跑一遍，然后再提交答案。

与楼下不同的是，逆序对使用了时间复杂度更低的树状数组。

先亮出暴力代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int tr[52],a[52];
int lowbit(int x){//最低位 
	return x&-x;
}
void add(int x,int v){//单点修改 
	while(x<=51){
		tr[x]+=v;
		x+=lowbit(x);
	}
} 
int query(int x){//1~n求和 
	int res=0;
	while(x){
		res+=tr[x];
		x-=lowbit(x);
	}
	return res;
}
int nxd(int a[]){//求解逆序对 
	for(int i=1;i<=51;i++){
		tr[i]=lowbit(i);//也可以是add(i,1) 
	}
	int ans=0;
	for(int i=1;i<=51;i++){
		add(a[i],-1); //自减，表示出现过 
		ans+=query(a[i]-1);//统计比自己小的且没出现过的数字 
	}
	return ans;
}
signed main(){
	for(int i=1;i<=51;i++){//初始化 
		a[i]=i;
	}
	int cnt=0,tot=0;
	for(int i=1;i<=51;i++){
		for(int j=i+1;j<=51;j++){
			for(int k=1;k<=51;k++){
				for(int l=k+1;l<=51;l++){
					//暴力4个数 
					swap(a[i],a[j]);//交换第一次 
					swap(a[k],a[l]);//交换第二次 
					tot+=nxd(a);
					cnt++;
					swap(a[k],a[l]);//回溯第二次交换 
					swap(a[i],a[j]);//回溯第一次交换 
				}
			}
		}
	}
	printf("%.2lf",tot*1.0/cnt);//输出 
	return 0;
}
```
因为交了一发显示超时

所以最终通过的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<65.33;//输出答案
	return 0;
}
```
完美撒花。

---


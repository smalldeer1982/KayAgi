# [蓝桥杯 2025 省 B] 产值调整

## 题目描述

偏远的小镇上，三兄弟共同经营着一家小型矿业公司“兄弟矿业”。公司旗下有三座矿山：金矿、银矿和铜矿，它们的初始产值分别用非负整数 $A$、$B$ 和 $C$ 表示。这些矿山的产出是小镇经济的核心，支撑着三兄弟和许多矿工家庭的生计。

然而，各矿山的产值波动剧烈，有时金矿收益高而银矿、铜矿低迷，有时则相反。这种不稳定性让公司收入难以预测，也常引发兄弟间的争执。为了稳定经营，三兄弟设计了一个公平的产值调整策略，每年执行一次，每次调整时，将根据当前的产值 $A$、$B$、$C$，计算新产值：

1. 金矿新产值：$A'=\lfloor \dfrac{B+C}{2} \rfloor$；
2. 银矿新产值：$B'=\lfloor \dfrac{A+C}{2} \rfloor$；
3. 铜矿新产值：$C'=\lfloor \dfrac{A+B}{2} \rfloor$；

其中，$\lfloor \rfloor$ 表示向下取整。例如，$\lfloor 3.7\rfloor = 3$，$\lfloor 5.2\rfloor = 5$。

计算出 $A'$、$B'$、$C'$ 后，同时更新：$A$ 变为 $A'$，$B$ 变为 $B'$，$C$ 变为 $C'$，作为下一年调整的基础。

三兄弟认为这个方法能平衡产值波动，于是计划连续执行 $K$ 次调整。现在，请你帮他们计算，经过 $K$ 次调整后，金矿、银矿和铜矿的产值分别是多少。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq T \leq 100$，$1 \leq A, B, C, K \leq 10^5$。
- 对于 $100\%$ 的评测用例，$1 \leq T \leq 10^5$，$1 \leq A, B, C, K \leq 10^9$。

## 样例 #1

### 输入

```
2
10 20 30 1
5 5 5 3```

### 输出

```
25 20 15
5 5 5```

# 题解

## 作者：HetmesAskalana (赞：23)

## 题解
取平均的操作会使数组的极差变得越来越小，直到为 $0$，使得 $a = b = c$，这时题目中的三个操作均无法影响到这三个数的值，所以在 $a = b = c$ 时直接退出即可。

最终尝试次数大概会在 $\log_2 (\max\{a, b, c\} - \min\{a, b, c\})$ 左右，完全可以接受

## 代码
```cpp
typedef long long LL;
array<LL, 3> proc(int x, int y, int z){
    return {
        (y + z) / 2, (x + z) / 2, (x + y) / 2
    };
}

void solve(){
    LL k, a, b, c;
    cin >> a >> b >> c >> k;
    for(int i = 0; i < k; ++i){
        array<LL, 3> tmp = proc(a, b, c);
        a = tmp[0], b = tmp[1], c = tmp[2];
        if(a == b and b == c) break;
    }
    cout << a << " " << b << " " << c << endl;
    return;
}
```

---

## 作者：ArenaBreakout78 (赞：12)

## 题目大意：

有三个矿山，每次调整它们的产值是根据其他两个的当前值计算出来的。比如，金矿的新产值是 $\frac{(B+C)}{2}$，向下取整。然后同时更新三个矿的值。这个过程要重复 $k$ 次，最后输出结果。

## 方法一，暴力枚举（30pts)：

通过题目，我们便可以使用最基本的暴力大法，将每一次金，银，铜的新产值都计算一遍，在存回原来的，时间复杂度为 $O(T \times k)$，于是，我们便得到了以下代码。

## 30pts code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int T;
    cin>>T;
    while(T--){
        int a,b,c,k,a1,b1,c1;//a,b,c分别表示金矿，银矿，铜矿，k为调整次数，a1,b1,c1,分别表示调整过后的金矿，银矿，铜矿。
        cin>>a>>b>>c>>k;
        for(int i=1;i<=k;i++){
            a1=(b+c)/2;//c++自动向下取整，所以不需要用floor函数。
            b1=(a+c)/2;
            c1=(a+b)/2;
            a=a1;//将调整前的产值重新赋值为调整后的新产值。
            b=b1;
            c=c1;
        }
        cout<<a<<' '<<b<<' '<<c<<"\n";//输出。
    }
    return 0;//并不完美的结束。
}
```

## 方法二 100pts:

我们再次观察样例，不难发现当 $a,b,c$ 都相等时，那么无论调整多少次，最终结果会都与原来相同，于是我们便可以在 for 循环中间加上这样一行代码判断

```cpp
if(a==b&&b==c)
    cout<<a<<' '<<b<<' '<<c<<"\n";
```

于是便可以得到最终代码。

## AC code:

```cpp
#include <bits/stdc++.h>
using namespace std;
bool flag=false;//判断。
int main(){
    int T;
    cin>>T;
    while(T--){
        int a,b,c,k,a1,b1,c1;//a,b,c分别表示金矿，银矿，铜矿，k为调整次数，a1,b1,c1,分别表示调整过后的金矿，银矿，铜矿。
        flag=false;
        cin>>a>>b>>c>>k;
        for(int i=1;i<=k;i++){
            a1=(b+c)/2;//c++自动向下取整，所以不需要用floor函数。
            b1=(a+c)/2;
            c1=(a+b)/2;
            a=a1;//将调整前的产值重新赋值为调整后的新产值。
            b=b1;
            c=c1;
            if(a==b&&b==c){//判断，都相同就直接全部输出。
                cout<<a<<' '<<b<<' '<<c<<"\n";
                flag=true;//将flag改为true，以免重复输出。
                break;//退出这个循环
            }
        }
        if(!flag)
            cout<<a<<' '<<b<<' '<<c<<"\n";
    }
    return 0;完美的结束！
}

```

本蒟蒻第一篇题解，望管理员大大能够通过。

---

## 作者：wenqinghua1001 (赞：5)

## 思路

拿到这题，二话不说，直接暴力。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int t;
	cin>>t;
	while(t--){
		int a,b,c,k;
		cin>>a>>b>>c>>k;
		for(int i=1;i<=k;i++){
			int a_=(b+c)/2;
			int b_=(a+c)/2;
			int c_=(a+b)/2;
			a=a_;
			b=b_;
			c=c_;
		}
		cout<<a<<" "<<b<<" "<<c<<endl;
	}
	return 0;
}
```

啊！超时！我看了一下数据范围，$1 \le T \le 10^5$，$1 \le A,B,C,K \le 10^9$，就算是 $1 \le A,B,C,K \le 10^5$，$T$ 组样例也照样过不了，时间复杂度是 $O(T \times K)$。

那只能进行优化了，观察一下样例的第二组数据，$A=B=C=5$，$A$、$B$、$C$ 都一样。带入式子 $A'=\lfloor \dfrac{B+C}{2} \rfloor$ 中，$A'=\lfloor \dfrac{B+C}{2} \rfloor=\lfloor \dfrac{A+A}{2} \rfloor=A$。$A$ 没有变，$B$、$C$ 也都一样。所以得出结论，如果在运算中途，满足 $A=B=C$ 这个条件，那么终止循环，直接输出。这种做法时间复杂度大约是 $O(\log_2\min(\lvert A-C \rvert,\lvert B-C \rvert,\lvert A-B \rvert))$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int t;
	cin>>t;
	while(t--){
		int a,b,c,k;
		cin>>a>>b>>c>>k;
		for(int i=1;i<=k;i++){
			if(a==b&&b==c) break;
			int a_=(b+c)/2;
			int b_=(a+c)/2;
			int c_=(a+b)/2;
			a=a_;
			b=b_;
			c=c_;
		}
		cout<<a<<" "<<b<<" "<<c<<endl;
	}
	return 0;
}
```

---

## 作者：yanmingqian (赞：4)

先写个暴力。

直接按题意模拟即可。时间复杂度 $O(Tk)$，可以获得三十分。

打个小表可以注意到，由于每次是取平均，三个数会趋近于相同。当三个数相同之后，显然后面的全部操作都是无用的，三个数都不会有变化。因此在三个数相同之后，直接退出模拟，直接输出即可。

分析一下时间复杂度。每次三个数的极差会缩小一半，因此复杂度大约是 $O(\log x)$ 的，其中 $x$ 约等于三个数两两之间差的绝对值之和。造一组极限数据验证一下，发现相差不大。这样我们就可以放心地把代码交上去了。

代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int a,b,c,k;
        cin>>a>>b>>c>>k;
        for(int i=1;i<=k;i++){
            int x=a,y=b,z=c;
            a=(y+z)/2;b=(x+z)/2;c=(x+y)/2;
            if(a==b&&b==c){
                break;
            }
        }
        cout<<a<<" "<<b<<" "<<c<<"\n";
    }
    return 0;
}
```

---

## 作者：wnqnld_llx (赞：2)

## 方法一：直接模拟
```
#include<bits/stdc++.h>
using namespace std;
signed main(){
	int T;
	cin>>T;
	while(T--){
		int a,b,c,k;
		cin>>a>>b>>c>>k;
		int aa,bb,cc;
		for(int i=1;i<=k;i++){
			aa=floor((b+c)/2);
			bb=floor((a+c)/2);
			cc=floor((a+b)/2);
			a=aa;
			b=bb;
			c=cc;
		}
		cout<<a<<" "<<b<<" "<<c<<"\n";
	}
	return 0;
}
```
时间复杂度 $O(T\times K)$ 。

这样做会直接超时，得分：30pts。
## 优化
不难发现如果 $a$ 和 $b$ 和 $c$ 相等的话的话 $a,b,c$ 无论如何都不会变化。

优化后时间复杂度就到了。

$O(T\times \min(K,\log{(\max(a,b,c)})))$ 这是因为每次调整后，最大值和最小值之间的差距至少会减半。

于是就有了下面这段代码。
## AC code
```
#include<bits/stdc++.h>
using namespace std;
signed main(){
	int T;
	cin>>T;
	while(T--){
		int a,b,c,k;
		cin>>a>>b>>c>>k;
		int aa,bb,cc;
		for(int i=1;i<=k;i++){
			aa=floor((b+c)/2);//向下取整。
			bb=floor((a+c)/2);
			cc=floor((a+b)/2);
			a=aa;
			b=bb;
			c=cc;
			if(a==b&&b==c) break; 
		}
		cout<<a<<" "<<b<<" "<<c<<"\n";
	}
	return 0;
}
```

---

## 作者：prh_rpjiajia (赞：1)

## 题解思路

首先注意到 $A,B,C,K \le 10^9$，直接模拟的朴素方法显然无法通过。我们剪一下枝，当 $A,B,C$ 三者相等时，肯定是不会再变化了，可以终止循环。

### 时间复杂度

#### 关键点
1. 每次迭代后，最大值与最小值的差至少减半。
2. 当极差降为 $0$ 时循环终止。

所以时间复杂度大约是：
$$
O(\log (\max(A,B,C) - \min(A,B,C)))
$$
考虑最坏情况，初始极差为 $10^9$，是不会超时的。

## 代码实现

```cpp
#include <iostream>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;

    while (T--) {
        int A, B, C, K;
        cin >> A >> B >> C >> K;

        while (K > 0) {
            if (A == B && B == C) break;

            int newA = (B + C) / 2;
            int newB = (A + C) / 2;
            int newC = (A + B) / 2;

            A = newA;
            B = newB;
            C = newC;

            K--;
        }

        cout << A << ' ' << B << ' ' << C << '\n';
    }

    return 0;
}

---

## 作者：粥2414 (赞：1)

~~一道大水题。~~
# 思路
一开始想的是利用矩阵加速，但考虑到这题的评级，以及向下取整不好处理，于是放弃。

观察到如果三个数都一样的话，那么再处理就没有意义了。

每一次的处理就相当于是取另外两数的平均值，假设三个数从小到大分别为 $min,mid,max$，那么一次操作后就会变为 $\lfloor\frac{mid+max}{2} \rfloor,\lfloor\frac{min+max}{2} \rfloor,\lfloor\frac{mid+min}{2} \rfloor$，此时新的极值变为了原来的中间值与极值的平均值，新的中间值为原来的极值的平均值。可以发现这样每次操作之后三个数都会互相接近。

观察到每次操作后，最大值与最小值的差会缩小一半（新极值相减便可证明），所以复杂度是 $O(t\log_2 {(max-min}))$。$max,min$ 的定义与上文相同。

于是考虑暴力模拟，当三者一样时退出即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
ll t;
ll a,b,c,k;
ll a1,b1,c1;
int main(){
	cin>>t;
	while(t--){
		cin>>a>>b>>c>>k;
		for(int i=1;i<=k;i++){
			a1=(c+b)/2;
			b1=(a+c)/2;
			c1=(a+b)/2;
			a=a1,b=b1,c=c1;
			if(a==b&&b==c)break;
		}
		cout<<a<<' '<<b<<' '<<c<<endl;
	}
	return 0;
}
```

---

## 作者：Mark_Pei (赞：0)

## Solution

对于这道题，我们可以发现这是一道模拟题，尝试先用暴力枚举。

然而，看一下数据：

$$1≤T≤10^5,1≤A,B,C,K≤10^9$$。

显然，用 $O(Tk)$ 的模拟方法是会超时的，不能通过此题，只有 $30$ 分。

但是我们可以发现，取平均的操作会让数组的极差变得越来越小，直到为 $0$，使得 $a=b=c$，这时题目中的操作均无法影响到这三个数的值，所以在 $a=b=c$ 时直接退出即可。

这种方法的时间复杂度为 $O(\log x)$，其中 $x$ 是这三个数两两之间差的最小值。所以完全不用担心超时。

AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main()
{
    cin>>t;
    while(t--)
    {
        int a,b,c,k;
        cin>>a>>b>>c>>k;
        for(int i=1;i<=k;i++)
        {
            int x=a,y=b,z=c;
            a=(y+z)/2;
            b=(x+z)/2;
            c=(x+y)/2;
            if(a==b&&b==c)
            {
                break;
            }
        }
        cout<<a<<" "<<b<<" "<<c<<endl;
    }
    return 0;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P12133)

## 题目思路：
当然是暴力，具体思路我就不多说了，但只能拿 $30$ 分哟，时间复杂度为 $O(Tk)$。

这边讲一个优化。

当我们的金矿新产值、银矿新产值、铜矿新产值相同时，无论怎样都无法改变正确答案，于是直接输出就行了，就拿到了 $100$ 分，因此复杂度大约是 $O(\operatorname{log}n)$ 的，其中 $n$ 约等于三个数两两之间差的绝对值之和。

但是要记得赋值哟！

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,a,b,c,k;
int s1,s2,s3;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>a>>b>>c>>k;
		for(int i=1;i<=k;i++){
			s1=(b+c)/2;
			s2=(a+c)/2;
			s3=(a+b)/2;
			if(s1==s2&&s2==s3) break;
			a=s1,b=s2,c=s3;
		}
		cout<<s1<<" "<<s2<<" "<<s3<<"\n";
	}
	return 0;
}
```

---


# [蓝桥杯 2025 省 Java A/研究生组] 变换数组

## 题目描述

输入一个数组 $a$，包含有 $n$ 个元素 $a_1, a_2, \cdots, a_n$。对这个数组进行 $m$ 次变换，每次变换会将数组 $a$ 中的每个元素 $a_i$ 转换为 $a_i \cdot \text{bitCount}(a_i)$。其中 $\text{bitCount}(x)$ 表示数字 $x$ 的二进制表示中 $1$ 出现的次数，例如 $\text{bitCount}(3) = 2$，因为 $3$ 的二进制表示为 $11$，其中 $1$ 出现了两次。

请输出变换之后的数组内容。

## 说明/提示

### 样例说明

- $5 = (101)_2$，$7 = (111)_2$，第一次变化后 $a = [10, 21]$。
- $10 = (1010)_2$，$21 = (10101)_2$，第二次变换后 $a = [20, 63]$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 10$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 100$；
- 对于所有评测用例，$1 \leq n \leq 10^3$，$0 \leq m \leq 5$，$0 \leq a_i \leq 1000$。

## 样例 #1

### 输入

```
2
5 7
2```

### 输出

```
20 63```

# 题解

## 作者：volatile (赞：3)

# 思路

实现一个函数计算十进制数 $x$ 转化为二进制数有几个 $1$ 即可，根据十进制转二进制的方法，容易写出，且范围较小，暴力可过。

# 代码


```cpp
#include<iostream>
using namespace std;
int f(int n)
{
    int s=0;
    while(n){
        if(n%2) s++;
        n/=2;
    }
    return s;
}
int a[1145];
int main()
{
    int n,m;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    cin>>m;
    for(int i=1;i<=n;i++){
        int t=a[i];
        for(int j=1;j<=m;j++) t=t*f(t);
        cout<<t<<" ";
    }
    return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：2)

# 题解：P12188 \[蓝桥杯 2025 省 Java A / 研究生组] 变换数组

好题。

## 解法

直接模拟即可，我们知道二进制有一个性质：

```
有二进制数 x，则 (x & -x) 为此数的最低位一的值。
```

那么，我们只需要设 $x = a_i$，循环枚举 $x$ 判断 $x$ 是否为零，否的话就计数器加一，$x$ 减去其最低位一的值。再用 $a_i$ 乘上计数器的值，最后输出即可。

## 代码

```
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 10;

int n, m;
int a[N];

int pop(int x) {
    int tot = 0;
    while (x) {
        tot++;
        x -= (x & -x);
    }
    return tot;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i];
    cin >> m;

    while (m--) {
        for (int i = 1; i <= n; i++)
            a[i] *= pop(a[i]);
    }

    for (int i = 1; i <= n; i++)
        cout << a[i] << ' ';
    
    return 0;
}
```

---

## 作者：粥2414 (赞：2)

~~一道超级大水题，评红都没问题。~~
# 思路
按照题意模拟即可，没啥说的。

讲一下 c++ 自带的 ``__builtin_popcount()`` 函数。它的作用很简单，就是返回参数的二进制下 $1$ 的个数，其实现方式较为特殊（想了解的读者可以自行上网搜索），效率非常非常高。

它有三个形态，上文提到的适用于 ``int`` 类型的参数，后面再加一个 ``l`` 适用于 ``long int`` 类型，再加一个 ``l`` 即可适用于 ``long long int`` 类型。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e3+9;
ll n,a[N],m;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i]*=__builtin_popcountll(a[i]);
		}
		cout<<a[i]<<' ';
	}
	return 0;
}
```

---

## 作者：tanruiqing (赞：1)

## 题目思路

考虑模拟。

我们可以循环 $m$ 次，然后遍历每一个数字，接着将这个数字进行进制转换，转换成 $2$ 进制下的数。最后将每个数字在 $2$ 进制下的数的 $1$ 的个数统计，把原数组的数据替换掉。

最后输出就行了。

进制转换是什么？回看 [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)不谢～

## AC 代码：

[AC 记录](https://www.luogu.com.cn/record/213887798)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n;
int a[1005];
int b[100005];
int m;
int ans;

int char_to_int(char c){
	if(c <= '9')return c - '0';
	return c - 'A' + 10;
}

char int_to_char(int n){
	if(n <= 9)return n + '0';
	return n - 10 + 'A';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1 ; i <= n ; i++){
        cin >> a[i];b[i] = a[i];
    }
    cin >> m;
    for(int i = 1 ; i <= m ; i++){//模拟每一次变化。
        for(int j = 1 ; j <= n ; j++){
            string s = to_string(b[j]),ss = "";//因为我这里的 b 数组是int类型的，所以这里用到了 to_string。
            int l = s.length();//获取字符串长度。
            //进制转换如下。
            for(int i2 = 0 ; i2 < l ; i2++){
                ans = ans * 10 + char_to_int(s[i2]);
            }
            int cnt = 0;//记录有多少个 1。
            while(ans != 0){
                if(int_to_char(ans % 2) == '1')cnt++;
                ss = int_to_char(ans % 2) + ss;
                ans /= 2;
            }

            b[j] = cnt * b[j];//最后覆盖原数据。
            ans = 0;//记得清零。
        }
    }
    for(int i = 1 ; i <= n ; i++){
        cout << b[i] << " ";//最后输出。
    }
    return 0;//好习惯。
}
```

---

## 作者：shimizu_kiouka (赞：1)

**P12188 [蓝桥杯 2025 省 Java A/研究生组] 变换数组 题解。**

[题目传送门](https://www.luogu.com.cn/problem/P12188)

该题就是对 $n$ 个数进行 $m$ 次变换，每次变换都将现在这个数乘它的二进制中 $1$ 的个数的积。

**难点：转成二进制，统计 $1$ 个数。**

因为二进制，所以只要当前的数字大于等于目前这个权值，这一位就一定为 $1$，我们可以从高位往下尝试，每大于 $1$ 次就增加一次计数器，最后返回计数器的值。

代码如下。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[1010],n,m;
long long num(long long x){//转二进制的同时统计个数
	int cnt=0;
	for(int k=30;k>=0;k--){
		if(x>=pow(2,k)){
			cnt++;
			x-=pow(2,k);
		}
	}
	return cnt;//返回计数
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];//输入
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			long long f=a[j];//替身，其实没啥用
			a[j]*=num(f);//进行转换
		}
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";//输出
	}
}
```
感谢观看。

---

## 作者：wnqnld_llx (赞：1)

## 题目大意
$\text{bitCount}(x)$ 表示数字 $x$ 的二进制表示中 $1$ 出现的次数，对这个数组进行 $m$ 次变换，每次变换会将数组 $a$ 中的每个元素 $a_i$ 转换为 $a_i \cdot \text{bitCount}(a_i)$。


## 进制转换


可以去看一下它的[模版](https://www.luogu.com.cn/problem/B3619)
这里题目只要求转二进制，我们只需知道转换为二进制数后它的各个位数是不是 $1$ 就可以了。


下面参考了一下百度百科。


我们使用短除法将十进制转换成二进制。10进制数转换成二进制数，这是一个连续除以 $2$ 的过程：
把要转换的数，除以 $2$，得到商和余数，
将商继续除以 $2$，直到商为 $2$。最后将所有余数倒序排列，得到数就是转换结果。
例如：$6$ 


|被除数|计算过程|商|余数|
|:-:|:-:|:-:|:-:|
|6|6/2|3|0|
|3|3/2|1|1|
|1|1/2|0|1|


结果是 $110$。


那么 $\text{bitCount}(x)$ 就解决了。
```
int bit(int x){
	int ret=0;
	while(x){
		if(x%2==1) ret++;//统计个数。
		x/=2;
	}
	return ret;
}
```
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];
int bit(int x){
	int ret=0;
	while(x){
		if(x%2==1) ret++;
		x/=2;
	}
	return ret;
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int m;
	cin>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			a[i]*=bit(a[i]);
		}
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
} 
```

---

## 作者：Aamumatematiikka (赞：1)

### 题意

有一个长度为 $n$ 的数列 $a_1,a_2,\dots,a_n$，需要进行 $m$ 次变换，每次将每个数变为 $a_i\cdot\text{bitCount}(x)$，即每次将每个元素乘上这个元素转为二进制后其中的元素个数。输出最终的数列。

### 解法

我们观察数据范围，可以发现 $1\le n\le 10$，$0\le m\le 5$，$0\le a \le 1000$。

分析暴力的复杂度：

计算一个数的 $\text{bitCount}(a)$ 需要 $\Omicron(\log a)$ 的复杂度，而一共需要 $n\cdot m$ 次变换，所以总复杂度为 $\Omicron(nm\log a)$，足以 $\color{green}\text{AC}$ 这道题。

代码如下：

```cpp
#include <iostream>
#define lowbit(x) (x)&-(x)
using namespace std;
typedef long long ll;
const int N=1005;
int n, m, a[N];
int count(int x){
	int res=0;
	while(x>0) x^=lowbit(x), res++;
	return res;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			a[j]*=count(a[j]);
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：1)

## 前言

巳蛇四月十四日戊时，见咕值略低，故做此 article。

## 思路

题目的意思就是给你一个数组 $a$，定义一个函数 $\text{bitCount}$，这个函数是计算一个整数（十进制下）的二进制形式中有多少个一。每一次操作，把数组中所有数 $a_i←a_i\times \text{bitCount}(a_i)$，问操作 $m$ 次，数组里面的数都是什么。

$\text{bitCount}$ 函数非常好实现，拿 $(45)_{10}=(101101)_{2}$。我们每一次与这个数和比他小的相邻的数，即 $a\&(a-1)$，$45$ 就是：

$$
\,\,\,\,\,101101\\
\&101100\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\\
\,\,\,\,\,101100
$$

一直重复此操作，直到 $a\le 0$。

$$
\,\,\,\,\,101101\\
\&101100\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\\
\,\,\,\,\,101100\\
\&101011\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\\
\,\,\,\,\,101000\\
\&100111\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\\
\,\,\,\,\,100000\\
\&011111\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\\
\,\,\,\,\,000000
$$

$3$ 次操作这个数就成 $0$ 了，不难发现，这个操作是吞掉 $a$ 末尾的 $1$ 的操作。时间复杂度 $O(n)$。

之后我们枚举每一个数每一次操作会变成什么，时间复杂度 $O(n^3)$。

## 代码

#### C++

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005];
int f(int x){
    int cnt=0;
    while(x>0){
        x=x&(x-1);
        cnt++;
    }
    return cnt;
}
int main(){
    int n,m;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            a[j]=a[j]*f(a[j]);
        }
    }
    for(int j=1;j<=n;j++){
        cout<<a[j]<<" ";
    }
    cout<<"\n";
    return 0;
}
```

#### Java

```java
import java.util.Scanner;

public class Main {
    static int[] a = new int[1005];
    
    static int f(int x) {
        int cnt = 0;
        while (x > 0) {
            x = x & (x - 1);  
            cnt++;
        }
        return cnt;
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        int m = scanner.nextInt();
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                a[j] = a[j] * f(a[j]);
            }
        }
        for (int j = 1; j <= n; j++) {
            System.out.print(a[j] + " ");
        }
        System.out.println();
    }
}
```

---

## 作者：songyouyi (赞：1)

这道题不难，只需要求出 $\text{bitCount}(a_i)$ 就可以了，首先要把每一个 $a_i$ 的二进制求出来，这里显然是可以不用管顺序的，因为它只需要求出 1 的个数就可以了，我们可以采用每次 $a_i \bmod 2$ 再 $\div2$ ，记录每次 $a_i \bmod 2$ 的结果就可以求出二进制，不过是倒序的，可以判断一下，每次到 0 停止运算，在中间记录一下每次模 2 是否为 1 即可，接下来上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010];
int main()
{
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int m;
	scanf("%d",&m);
	for (int i=1;i<=m;i++)
	{
		for (int j=1;j<=n;j++)
		{
			//二进制分解 
			int now=a[j],ret=0;
			while (now!=0)
			{
				//如果当前为1加1，否则加0 
				ret+=now%2;
				now/=2;
			}
			a[j]*=ret;
		}
	}
	for (int i=1;i<=n;i++)
	{
		printf("%d ",a[i]);
	}
	return 0;
}
```

---

## 作者：AFO_Lzx (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P12188)

实际上就是根据题目意思模拟，$\text{bitCount}(x)$ 的实现很简单，每次将 $x$ 按位与上 $1$ 的结果加上，然后将 $x$ 右移一位，直到 $x=0$ 就结束，实际上就是每一次先加上 $x$ 对 $2$ 取模的值再将 $x\div2$ 就行。

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

int bitcnt(int x) {
	int res = 0;
	while (x) res += x & 1, x >>= 1;
	return res;
}

const int N = 1e3 + 5;
int n, m, a[N];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);

	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	
	cin >> m;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			a[i] *= bitcnt(a[i]);
		}
	}
	
	for (int i = 1; i <= n; i++) cout << a[i] << ' ';
	return 0;
}
```

---

## 作者：yanmingqian (赞：0)

题意：给定一个数组 $a$，执行 $m$ 次变换，每次将 $a_i$ 乘以其二进制下 $1$ 的个数，输出变换后的数组。

在 C++ 中，有一个函数 `__builtin_popcount()`，可以计算一个数二进制下 $1$ 的个数。这道题直接运用它可以秒掉。我们直接按照题意，执行 $m$ 次，每次遍历 `a` 数组，这样时间复杂度是 $O(nm)$ 的，可以通过此题。

代码如下：

```cpp
#include<iostream>
using namespace std;
int a[1010];
int main(){
    int n,m;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cin>>m;
    while(m--){
        for(int i=1;i<=n;i++){
            a[i]*=__builtin_popcount(a[i]);
        }
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }
    return 0;
}
```

不过这题是个 Java 组的题目，题解这样写太没有诚意了。在 Java 中有一个类似的函数 `Integer.bitCount()`，可以实现与 `__builtin_popcount()` 一样的功能，二者用法也相同。有了这个，这题用 Java 也可以顺利地秒掉了：

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] a = new int[1010];
        int n = scanner.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        int m = scanner.nextInt();
        while (m-- > 0) {
            for (int i = 1; i <= n; i++) {
                a[i] *= Integer.bitCount(a[i]);
            }
        }
        for (int i = 1; i <= n; i++) {
            System.out.print(a[i] + " ");
        }
    }
}
```

---


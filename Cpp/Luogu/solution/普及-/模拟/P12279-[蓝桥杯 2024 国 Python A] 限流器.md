# [蓝桥杯 2024 国 Python A] 限流器

## 题目描述

小蓝最近为自己的服务开发了一套 OpenAPI，为了防止接口被恶意盗刷，他需要搭建一套分布式限流组件。

简而言之，我们想要限制在时间区间 $[k \cdot N, (k + 1) \cdot N) (k = 0, 1, 2, \cdots)$ 中，接口最多只允许成功访问 $M$ 次，对于超出限制的访问则返回异常状态表示请求失败。

现在给出某个客户端对 API 请求的时间戳，请你统计下其中有多少次的请求是成功的。

## 说明/提示

### 样例说明

$[0,60)$ 内访问了 $6$ 次，有 $1$ 次会访问失败，$5$ 次访问成功；$[60,120)$ 内访问了 $4$ 次，均成功；总计成功访问 $5+4=9$ 次。

### 评测用例规模与约定

对于所有评测用例，$1 \leq N, M, L \leq 1000$，$0 \leq t_i \leq 1000$。

## 样例 #1

### 输入

```
60 5 10
0 60 15 60 0 50 60 1 1 61```

### 输出

```
9```

# 题解

## 作者：MingDynasty (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P12279)

一道值得回味的模拟题。

## 题目思路：

为方便起见，我们把压缩的时间记为 $s$ 数组。

我们使用 STL 中的 map 来把所有的时间压缩起来，再遍历每一个压缩后的时间，每次把 $\min(m,s_i)$ 加入答案，输出即可。

之所以这么做，是因为当前的 $s_i$ 如果不够上限访问次数，就都可以访问。如果当前的 $s_i$ 大与上限访问次数，那就加 $m$ 即可，毕竟剩下的都访问不了。

**注意枚举压缩时间上限是未压缩时间最大值 $\div N$。**

**时间复杂度 $O(n \log n)$，可以通过本题。**

## Code：

```cpp
/*
	Auther:MingDynasty
	Problem:https://www.luogu.com.cn/problem/P12279
*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,l,maxn,ans,t;
map<int,int>s;
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m>>l;
    for (int i=1;i<=l;i++){
        cin>>t;
        maxn=max(maxn,t);
        s[t/n]++;
    }
    for(int i=0;i<=maxn/n;i++) ans+=min(m,s[i]);
    cout<<ans;
    return 0;
}
```

祝大家通过本题！

---

## 作者：wangzhechun (赞：4)

### (づ｡◕‿‿◕｡)づ[蓝桥杯 2024 国 Python A] 限流器 题解

[题目传送门](https://www.luogu.com.cn/problem/P12279)

[博客查看更佳](https://www.luogu.com.cn/article/k7txxm2w)

每次读入时间并计算每次的时间区间（应向上取整，所以计算时应加 $n-1$），判断时间区间次数，若没有超过 $m$ 次则给答案加 $1$ 即可。

将 $k$ 加 $1$ 是为了方便取模，使区间变为 $[k⋅N+1,(k+1)⋅N+1)$ 来避免区间开头为 $0$ 的情况。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l,a[1001],ans;

int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>l;
	
	for(int i=1;i<=l;i++){
		int k;cin>>k;
		k++;a[(k+n-1)/n]++;
		if(a[(k+n-1)/n]<=m)ans++;
	}
	
	cout<<ans;
	return 0;
}   //Code by wangzhechun
```
然后我们就可以完美的 AC 这道题啦~(≧▽≦)/~。

---

## 作者：volatile (赞：3)

# 思路

用桶数组保存每个区间的请求次数即可，如何求一个时间戳是哪一个区间呢？因为每个区间是 $[k\cdot{N},(k+1)\cdot{N})$，所以直接用这个时间戳整除 $N$ 即可求出每一个 $k$。

# 代码

```python
n,m,l=map(int,input().split())
t=list(map(int,input().split()))
cnt={}
for i in t:
    if i//n in cnt:
        cnt[i//n]+=1
    else:
        cnt[i//n]=1
sum=0
for i in cnt.values():
    if i<=m:
        sum+=i
    else:
        sum+=m
print(sum)
```

`cnt={'key1':'value1','key2':'value2'...}` 说明 $cnt$ 是一个字典，可以理解为 C++ 中的 map。

---

## 作者：Wsl886 (赞：3)

## 分析
本题难点在于如何知道一个数在哪个区间，我们思考一下发现，一个数在哪个区间只需要除 $N$ 即可。这是因为程序中的除是向 $0$ 取整，也就是不考虑负数情况下是向下取整。明白了这点就可以用桶记录每个区间被访问了几次。最后累加每个区间的与限制 $M$ 的最小值就是答案。（ $0 \leq t_i \leq 1000$ ）所以代码时间复杂度能过这道题。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l,a[1010],t[1010],ans;
signed main(){
	cin>>n>>m>>l;
	for(int i=1;i<=l;i++) cin>>a[i],t[a[i]/n]++;
	for(int i=0;i<=1000;i++) ans+=min(m,t[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：liuzhuoran141516 (赞：1)

大水题。

注意到数据范围较小，所以我们可以开一个桶来记录每一个区间的访问次数。

而且不难发现，一个数整除 $N$ 就是它所在的区间（向下取整），这是为什么呢？

答案是显而易见的：因为每个区间都有 $N+1$ 个时间点，所以每个区间的起点是一个公差为 $N$ 的等差数列。

那么这道题现在就非常简单了，代码不放了。

---

## 作者：Planet_Earth (赞：1)

## 题解：P12279 [蓝桥杯 2024 国 Python A] 限流器
### [题目传送门](https://www.luogu.com.cn/problem/P12279)

摆上我的 [AC 记录](https://www.luogu.com.cn/record/214726145)，~~我又又来划水了~~。
### 题目简述

在每段长度为 $N$ 的时间区间内，API 最多允许成功访问 $M$ 次，超出限制的请求失败。统计成功请求的次数。

### 思路分析

首先将时间轴分成若干个长度为 $N$ 的区间，每个区间对应一个计数器。

对于每个请求，需要先计算它属于哪个区间，然后检查这个区间的计数器是否已经达到 $M$。

如果未达到，计数器加 $1$，并记录为成功请求，否则请求失败。

最后，统计所有成功请求的总数。
### 代码

```cpp
#include <bits/stdc++.h>
#define int long long 
#define N 1010
using namespace std;
int read(){
    int x=0,f=1;
  	char ch=getchar_unlocked();
	  while(!isdigit(ch)){
		    if(ch=='-') f=-1;
		    ch=getchar_unlocked();
	  }
	  while(isdigit(ch)){
		    x=(x<<1)+(x<<3)+(ch^48);
		    ch=getchar_unlocked();
  	}
	  return x*f;
}
void write(int x){
  	if(x<0){
	    	putchar('-');
		    x=-x;
	  }
  	if(x>9) write(x/10);
  	putchar(x%10+'0');
}
int n,m,l,sum=0,a[N],ger[N];
signed main() {
	n=read(),m=read(),l=read();
	for(int i=1;i<=l;i++){
		a[i]=read();
		int s=1;
		while(s*n<=a[i]) s++;
		if(m>ger[s]){
			ger[s]++;
			sum++;
		}
	}
	write(sum);
	return 0;
}
//Planet_Earth
```

---

## 作者：longyitongxue (赞：0)

去往题目の读者请点击[本链接](https://www.luogu.com.cn/problem/P12279)。
# 题目's 做法
这道题其实是一道考验脑子的题目。因为它代码不难，但是要理解它很困难。首先，我们要读懂题目，其实题目让我们在时间戳中找到它属于 $\left[0,N\right),\left[N,2N\right)\cdots$ 的哪个范围，在一个范围内，出现的次数不能超过 $M$，也就是说，我们只要累加 $\min\left(M,\text{时间戳范围的访问次数}\right)$ 就可以了。

时间戳范围怎么累加呢？其实，我们只用开辟一个桶，大小根据题目描述（$0\leq1000\leq t_i$）定义。然后，我们不难发现，下标 $\left\lfloor\dfrac{\text{单次访问的时间戳}}{N}\right\rfloor$ 就是所对应时间戳的范围。范围内时间戳的访问次数累加到桶的这里就可以了。最后，$i$ 从 $0\sim1000$，按上文进行累加答案即可。
# 题目's 代码（AC の[记录](https://www.luogu.com.cn/record/214839988)）
```cpp
#include<iostream>
using namespace std;
int t[1005],ans;
int main(){
    int n,m,l;
    cin>>n>>m>>l;
    for(int i=1;i<=l;i++){
        int x;
        cin>>x;
        t[x/n]++;
    }
    for(int i=0;i<=1000;i++){
        ans+=min(m,t[i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[限流器](https://www.luogu.com.cn/problem/P12279)

照样子，献上[正确记录](https://www.luogu.com.cn/record/214755674)，禁止抄袭。

## 题目分析：
这道题一看就是模拟，但是值得思考。这道题其实不用很高级的结构，用一个桶存 $t_L$ 访问的时间戳在时间区间里的范围，这边定义为数组 $a$，最后累加每个 $a_L$ 与限制 $M$ 的最小值就是答案。

睁大眼睛仔细看题目，$0 \le t_i \le 1000$，就可以不循环那么多次了，~~其实不优化也可以~~，时间复杂度为 $O(L)$，所以思路的时间复杂度足以通过这题。

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,l,a[1005],ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>l;
	for(int i=1;i<=l;i++){
		int x;
		cin>>x;
		a[x/n]++;
	}
	for(int i=0;i<=1000;i++) ans+=min(m,a[i]);
	cout<<ans<<"\n";
	return 0;
}
```
```python
N, M, L = map(int, input().split())
timestamps = list(map(int, input().split()))
cnt = {}
for t in timestamps:
	k = t // N
	if k in cnt:
		cnt[k] += 1
	else:
		cnt[k] = 1
ans = 0
for count in cnt.values():
	ans += min(count, M)
print(ans)
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
既然题目是要我们输出有多少请求不超过它的区间的最多请求次数，我们就可以定义一个关于每个时间段还可以用多少次的数组，并将其赋值为 $m$。每次输入 $t$ 时都判断 $t$ 的区间是否还能装。如果能就让能用的次数减少 $1$，然后用于统计有多少次请求成功的变量增加 $1$。
### 代码：
```python
n, m, l = map(int, input().split())
b = [0] * 1001
t = [0] * 1001
for i in range(1001):
    if i * n <= 1000:
        b[i] = m
cnt = 0
input = list(map(int, input().split()))
for i in range(1, l + 1):
    t[i] = input[i - 1]
    if b[t[i] // n] > 0:
        b[t[i] // n] -= 1
        cnt += 1

print(cnt)
```

---

## 作者：Yeonjun_0913 (赞：0)

#### 温馨提示：
这是一篇 c++ 题解，但是 python 代码可根据思路来写。
~~其实是 python 代码一直 RE。~~

---



#### 思路
由题意我们可以轻松得到一个方法，每输入一个 $t_i$，就判断这个 $t_i$ 在哪一个 $[k \times N,(k+1) \times N)$ 区间中，找出所在区间的 $k$，累加到桶数组 $sum_k$ 中。最后循环遍历 $sum$ 数组，如果 $sum_i \le m$，那么就直接累加到答案中，反之，就会有访问失败的情况，这时候，将 $m$ 加到答案中，最后输出答案即可。

#### AC CODE

```cpp
#include <iostream>
using namespace std;

int n,m,l,maxn,ans;
int t[1005];
int sum[1005];

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> l;
    for (int i=1;i<=l;i++){
        cin >> t[i];
        maxn=max(maxn,t[i]);  //找出最大能到哪个区间
        sum[t[i]/n]++;  //通过除以n找出所在区间
    }
    for (int i=0;i<=maxn/n;i++){  //只循环到最大能到的区间即可
        if (sum[i]>m){
            ans+=m;
        }else {
            ans+=sum[i];
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Jason2013awa (赞：0)

# P12279 [蓝桥杯 2024 国 Python A] 限流器
> ## 题目描述
> 简而言之，我们想要限制在时间区间 $[k \cdot N, (k + 1) \cdot N) (k = 0, 1, 2, \cdots)$ 中，接口最多只允许成功访问 $M$ 次，对于超出限制的访问则返回异常状态表示请求失败。

> 现在给出某个客户端对 API 请求的时间戳，请你统计下其中有多少次的请求是成功的。

这道题数据量不大，可以定义 $t_i$ 为 $k=i$ 时区间内的请求个数。

在 $t_i=m$ 时我们则判定当前请求失败。

最后答案为 $t$ 的总和。

## AC CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;int n,m,l,ans=0,a[1005],t[1005];
int main(){
    
    cin>>n>>m>>l;
    for(int i=1;i<=l;i++){
        cin>>a[i];
        int s=1;
        while(s*n<=a[i])s++;
        if(t[s]<m)
        t[s]++,ans++;
    }cout<<ans;
    return 0;
}
```

---

## 作者：W_C_B_H (赞：0)

考虑开一个桶 $cnt_{0},cnt_{1},\dots,cnt_{999}$（大小开 $10^3$ 是因为在 $N=1$ 的极端情况下最多也只有 $10^3$ 段），其中 $cnt_{i}$ 记录在时间区间 $[i \cdot N, (i + 1) \cdot N)$ 中，接口被请求成功的次数。

故我们可以输入后依次判断每个时间点所属的区间是否已经达到上限，若没有则请求成功的次数 $+1$。

Code：

```python
# 初始化
cnt = [0] * 1005
ans = 0

# 输入
N, M, L = map(int, input().split())
t = list(map(int, input().split()))

# 处理
for i in t:
    if cnt[i // N] < M:
        cnt[i // N] += 1
        ans += 1
print(ans)
```

---


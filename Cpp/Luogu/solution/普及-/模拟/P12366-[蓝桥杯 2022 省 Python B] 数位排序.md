# [蓝桥杯 2022 省 Python B] 数位排序

## 题目描述

小蓝对一个数的数位之和很感兴趣，今天他要按照数位之和给数排序。当两个数各个数位之和不同时，将数位和较小的排在前面，当数位之和相等时，将数值小的排在前面。

例如，$2022$ 排在 $409$ 前面，因为 $2022$ 的数位之和是 $6$，小于 $409$ 的数位之和 $13$。

又如，$6$ 排在 $2022$ 前面，因为它们的数位之和相同，而 $6$ 小于 $2022$。

给定正整数 $n$，$m$，请问对 $1$ 到 $n$ 采用这种方法排序时，排在第 $m$ 个的元素是多少？

## 说明/提示

### 样例说明

$1$ 到 $13$ 的排序为：$1, 10, 2, 11, 3, 12, 4, 13, 5, 6, 7, 8, 9$。第 $5$ 个数为 $3$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq m \leq n \leq 300$。
- 对于 $50\%$ 的评测用例，$1 \leq m \leq n \leq 1000$。
- 对于所有评测用例，$1 \leq m \leq n \leq 10^6$。

## 样例 #1

### 输入

```
13
5```

### 输出

```
3```

# 题解

## 作者：海洋守卫者 (赞：5)

# [P12366](https://www.luogu.com.cn/problem/P12366) [蓝桥杯 2023 省 Python B] 数位排序

## 解题思路
将数字与数位和捆绑（使用结构体或元组）放入数组或列表，以数位和为关键字排序，最后输出第 $m$ 个数。
## 完整代码
### C++:
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
const int MAXN=1e6+7;
struct Node{
	int id,num;
}l[MAXN];
int n,m,ans;
inline int Count(int x)
{
	int sum=0;
	while(x)sum+=x%10,x/=10;
	return sum;
}
inline bool cmp(Node A,Node B)
{
	return A.num==B.num?A.id<B.id:A.num<B.num;
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)l[i]={i,Count(i)};
	sort(l+1,l+1+n,cmp);
	printf("%d",l[m].id);
	return 0;
}
```
### Python:
```py
def takeSecond(elem):
	return elem[1]
def count(x):
	tmp,sum=x,0
	while tmp>0:
		sum+=tmp%10
		tmp//=10
	return sum
l=[]
n,m=int(input()),int(input())
for i in range(n):
	l.append((i+1,count(i+1)))
l.sort(key=takeSecond)
print(l[m-1][0])
```

---

## 作者：l15130880055 (赞：3)

## P12366 [蓝桥杯 2023 省 Python B] 数位排序 题解

### Problem

给你一个长度为 $n$ 的序列，初始时 $a_i=i$，按照数位和从小到大排序，数位和相同数值小的优先。

### Solution

考察选手对手写 $\operatorname{cmp}$ 的理解。

排序函数默认的优先级是按照数值从小到大排序，如果要更改优先级就要手写 $\operatorname{cmp}$ 函数，这题就按照题意在 $\operatorname{cmp}$ 里面算出两个数的数位之和，特判一下相同的情况就做完了。

### Code
代码给出 $\operatorname{cmp}$ 函数。


```cpp
inline bool cmp(int a, int b){
	int aa = a, bb = b, A = 0, B = 0;
	while(a){
		A += a % 10;
		a /= 10;
	}
	while(b){
		B += b % 10;
		b /= 10;
	}
	if(A == B){
		return aa < bb;
	}
	return A < B;
}
```

---

## 作者：Noob_Oler (赞：1)

# 题解：P12366 [蓝桥杯 2023 省 Python B] 数位排序
一道用结构体和排序的题。

## 思路
我们根据题目可以想出，排序函数。
```
bool cmp(node x,node y)
{
    if(x.s != y.s) return x.s < y.s;
    else return x.id < y.id;
}
```
$x.s$ 是这个数的数字和，$x.id$ 是 $x$ 这个数的数值。

当然，我们要先处理出 $1 \sim n$ 每个数的数字和，再排序。

---

## 作者：fiee_Lina (赞：0)

# [P12366 [蓝桥杯 2023 省 Python B] 数位排序](https://www.luogu.com.cn/problem/P12366)

### 题目

给定一个数字 $n$，从 $1$ 到 $n$ 排序时，按照数位之和给数排序。

当两个数各个数位之和不同时，将数位和较小的排在前面，当数位之和相等时，将数值小的排在前面。

### 思路

这道题数据范围不大，但很多需要注意的，在排序时要先按照数位之和再按照原来数的大小决定先后，算数位和要先加上这个数位再除掉，还有一个思路上的问题，对于数位相加之后可能是多位数而不是一位数，而这个数就是数位之和，不用再重复计算这个数的数位之和。

最后直接模拟就可以了（不要踩坑）。

### Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;

int n,m;
struct node
{
    int sum;
    int sum_add;
}s[N];

int S_add(int x)
{
    int cnt=0;
    while(x)
    {
        cnt+=x%10;
        x/=10;
    }
    return cnt;
}

bool cmp(node x,node y)
{
    if(x.sum_add!=y.sum_add) return x.sum_add<y.sum_add;
    else return x.sum<y.sum;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    cin>>n;
    for(int i=1;i<=n;i++)
    {
        s[i].sum=i;
        s[i].sum_add=S_add(i);
    }

    sort(s+1,s+n+1,cmp);

    cin>>m;

    cout<<s[m].sum<<endl;
    
    return 0;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[数位排序](https://www.luogu.com.cn/problem/P12366)

上方是题目传送门。

## 题目思路：
本题考查**结构体**和**排序**的应用。

这边定义一个结构体 $a$，其中包含两个项目，两个项目分别为 $id$ 和 $s$，$id$ 为这一个数字，$s$ 为一个数字的数字和。

根据题意写出排序：

```cpp
bool cmp(node a,node b){
	if(a.s==b.s) return a.id<b.id;
	else return a.s<b.s;
}
```
 $node$ 是结构体的名称。

## 正解：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
const int N=1e6+10;
struct node{
	int id,s;
}a[N];
int f(int x){
	int cnt=0;
	while(x!=0){
		cnt+=x%10;
		x/=10;
	}
	return cnt;
}
bool cmp(node a,node b){
	if(a.s==b.s) return a.id<b.id;
	else return a.s<b.s;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		a[i].id=i;
		a[i].s=f(i);
	}
	sort(a+1,a+1+n,cmp);
	cout<<a[m].id;
	return 0;
}
```

---


# 「FAOI-R9」平民上篮

## 题目背景

You can switch the language of problem description.

![](https://cdn.luogu.com.cn/upload/image_hosting/96tdfgkh.png)

清风紧盯着篮板上的白线，篮球出手后击打在边缘上，他为之心头一紧，篮球落在篮筐的铁环上，他心头的石头落下了一点，可是，篮球弹起来后又弹出了篮板，他奔向篮球掉落的方向，眼看着篮球要飞向边线......

清风至今还能想起一年前备战体育中考的那段时光。

## 题目描述

B 市的篮球中考规则是这样的：

* 考生的一组完整动作定义为运球到篮下，一组成功的上篮动作及返回三个动作的依次连续进行。
* 一组上篮动作的成功的判定条件为：考生在一段连续时间内身体一直在篮筐下，即在此段时间内只会发生投篮投进或者投篮失败，若**存在某次**投篮投进则为成功，若投篮失败**至少**三次则也视为成功。
* 运球到篮下和返回分别是由三分线到篮筐下的位移及其反向位移。
* 考生初始在三分线上，需要完成至少四组完整的动作并回到三分线（也就是说即使四组动作已经完成时，如果清风不在三分线上那么不能结束考试），计取所有动作的总时间和。若在 30 秒内为满分，在 46 秒外为零分。

清风在本次练习中可以进行以下动作：

* 若他在三分线上，他可以选择运球到篮下（操作符号为 `G`），消耗 $ a $ 秒，动作结束后他在篮下。
* 若他在篮下，他可以选择运球返回（操作符号为 `B`），消耗 $ a $ 秒，动作结束后他在三分线上。
* 若他在篮下，他可以选择瞄准上篮（操作符号为 `A`）或随便上篮（操作符号为 `W`），瞄准上篮消耗 $ b $ 秒，篮球一定投进；随便上篮消耗 $ c $ 秒，篮球一定投不进。

![](https://cdn.luogu.com.cn/upload/image_hosting/v8ib3xgn.png)

（考试规则示意图）

现在给出清风一场训练的操作序列，保证它一定合法，请你帮助清风规划剩下的操作使得他完成篮球考试且总用时（含已经进行完的操作）最短。

## 说明/提示

**【样例 1 解释】**

给出的操作序列之后需要进行的操作依次为：`ABGAB`。

对于最后一组完整动作：显然一次上篮直接过是优于三次尝试的。

**【样例 2 解释】**

动作做完了但清风又跑到篮筐底下了，正解是回去。

**【样例 3 解释】**

需要再重复四遍 `GWWWB`，显然三次尝试是优于一次直接成功上篮的。

**【样例 4 解释】**

对于没做完的完整动作，显然尝试两次是优于一次直接成功上篮的。

而对于没做的完整动作，显然一次直接成功上篮是优于尝试三次的。

**【样例 5 解释】**

显然对于没做完的完整动作和没做的完整动作，尝试至少两次或至少三次不优于一次直接上篮。

**【样例 6 解释】**

对于没做完的完整动作和没做的完整动作，尝试两次或三次优于一次直接上篮。

**【数据规模与约定】**

记 $ n $ 为 $ S $ 的长度。

**本题测试点等分。**

对于测试点 $ 1 $，保证按照给出的操作序列可以直接结束考试。

对于测试点 $ 2 \sim 5 $，保证 $ b=c $。

对于测试点 $ 6 \sim 10 $，无特殊限制。

对于每个测试点，保证 $ 1 \le n \le 100 $，且 $ S_i \in \{\texttt{G},\texttt{B},\texttt{A},\texttt{W}\} $，$ 1 \le a,b,c \le 10^7 $，$ b \ge c $，且 $ S $ 一定合法。

## 样例 #1

### 输入

```
8 5 3
GWBGAABGAAABG```

### 输出

```
118```

## 样例 #2

### 输入

```
1 1 1
GABGABGABGABG```

### 输出

```
14```

## 样例 #3

### 输入

```
8 5 1
GBGBGBGB```

### 输出

```
140```

## 样例 #4

### 输入

```
1 5 2
GABGABGW```

### 输出

```
29```

## 样例 #5

### 输入

```
1 11 10
GBGW```

### 输出

```
64```

## 样例 #6

### 输入

```
1 50 1
GBGW```

### 输出

```
22```

# 题解

## 作者：ZackofZHOU (赞：7)

# 思路
1.    **处理已知的操作**。
2.    进行结束考试的判定。
3.    处理后续操作
  * **判断是否回来了，没有回来就先投一个球**。
  * 接下来就来回投球
  * 对于投球操作，取失败 3 次（对应操作 `W` ）和一发投进（对应操作 `A` ）花费时间的最小值，即 $\min(3 \times c,b)$ 。

[AC记录](https://www.luogu.com.cn/record/216288082)

完整代码：（有注释）

```cpp
#include<iostream>
using namespace std;
string op;
int a,b,c,fail,cnt,ans;
bool back;
int main()
{
	cin >> a >> b >> c >> op;
	// 计算已经给定的动作的进球数以及失败 
	for(char x : op)
	{
		switch(x)
		{
			case 'G':
				ans += a;
				back = false;
				break;
			case 'B':
				ans += a;
				back = true;
				if(fail == 3) // 计算失败->成功 
					cnt++;
				fail = 0;
				break;
			case 'A':
				fail = 3;
				ans += b;
				break;
			case 'W':
				ans += c;
				fail = min(fail + 1,3);
				break;
		}
	}
	if(cnt >= 4) // 投完辣 
	{
		cout << ans + (back ? 0 : a);
		return 0;
	}
	if(!back) // 没回来, 肯定先投个球, 回来
	{
		ans += min((3 - fail) * c,b) + a;
		cnt++;
	}
	// 来回投球
	ans += (4 - cnt) * (2 * a + min(3 * c,b));
	cout << ans;
	return 0;
}
```

无注释版本：
```cpp
#include<iostream>
using namespace std;
string op;
int a,b,c,fail,cnt,ans;
bool back;
int main()
{
	cin >> a >> b >> c >> op;
	for(char x : op)
	{
		switch(x)
		{
			case 'G':
				ans += a;
				back = false;
				break;
			case 'B':
				ans += a;
				back = true;
				if(fail == 3)
					cnt++;
				fail = 0;
				break;
			case 'A':
				fail = 3;
				ans += b;
				break;
			case 'W':
				ans += c;
				fail = min(fail + 1,3);
				break;
		}
	}
	if(cnt >= 4)
	{
		cout << ans + (back ? 0 : a);
		return 0;
	}
	if(!back)
	{
		ans += min((3 - fail) * c,b) + a;
		cnt++;
	}
	ans += (4 - cnt) * (2 * a + min(3 * c,b));
	cout << ans;
	return 0;
}
```

蒟蒻第一次写题解，有解释错误请大佬私信。

---

## 作者：船酱魔王 (赞：6)

## 题意回顾

体育考试中，要求一次三分运球-上篮成功或者尝试三次上篮-运球回线为一次完整操作，要求从三分线开始完成四次完整动作并回到三分线，现在已知运球到篮下和运球回三分线（相同）、上篮成功、上篮失败的时间消耗和前缀操作，求出完成考试的时间消耗最少值。

## 分析

简单模拟，感觉这场总体来看还是很轻量级的。

首先，操作序列必然形如运球到篮下-XXX-运球回三分线。

而 XXX 的内容是被运球操作分割的，因此如果这组动作已经回到三分线，那么可以判定是否为成功动作，否则判定为无效，无论怎样都对后面没有影响。

而对于未完全完成的动作，显然在此基础上做完是不劣的。

而对于后补的动作，显然要么失败三次要么成功一次，如果又有失败又有成功的话不如直接来一次成功上篮。

继续考虑未完全完成的动作，显然是已经到篮下且未运球回归的，考虑补满三次失败和补满一次成功的较小代价即可。

corner case：未完成的动作一定要做完。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;
int a, b, c;
string str;
int main() {
    cin >> a >> b >> c;
    cin >> str;
    int sta = 0;
    int cnt = 0;
    int tim = 0;
    for(int i = 0; i < str.size(); i++) {
        if(str[i] == 'G') {
            sta = 1, tim += a;
        } else if(str[i] == 'B') {
            if(sta >= 4) cnt++;
            sta = 0, tim += a;
        } else if(str[i] == 'A') {
            sta += 3, tim += b;
        } else if(str[i] == 'W') {
            sta++, tim += c;
        } else {
            cout << "Impossible!" << endl;
        }
    }
    if(cnt >= 4) {
        if(sta != 0) tim += a;
    } else {
        if(sta != 0) {
            if(sta >= 4) tim += a, cnt++;
            else tim += min((4 - sta) * c, b) + a, cnt++;
            sta = 0;
        }
        tim += (4 - cnt) * (2 * a + min(b, 3 * c));
    }
    cout << tim << endl;
    return 0;
}
```

---

## 作者：Jeeff (赞：4)

看起来非常复杂，看懂了就简单~

这题没什么好说的，题目要求从三分线运到篮下投进一颗或投失三颗再回来，记一轮，共四轮。而我们不难发现，只有刚好符合第一种或第二种才比较节省时间。

我们第一步计算它给的动作的总用时，同时分析其包含的成功次数，最后对于没走完的全程，按最优方式走完，剩余的次数也按最优方式走就行了。

代码：


```cpp
#include<bits/stdc++.h>//……
using namespace std;
int main()
{
	int a,b,c;
	cin>>a>>b>>c;//输入
	string s;
	cin>>s;//动作
	int ans=0,cnt=0,l=0;//int 总用时，该轮投篮次数，完成次数
	bool is_going=0;//是否正在进行一轮中
	for(int i=0;i<s.size();i++)
	{
		if(s[i]=='G')//如果是“走”
		{
			ans+=a;//总用时加上a
			is_going=1;//正在进行~
		}
		else if(s[i]=='A')//如果是“瞄准”
		{
			ans+=b;//+b
			cnt=3;//视为成功，所以直接将次数设为3
		}
		else if(s[i]=='W')//如果是“随意”
		{
			ans+=c;
			cnt++;//投篮次数+1
		}
		else//如果是“回”
		{
			ans+=a;
			if(cnt>=3)l++;//如果这一轮投篮次数>3，那么成功次数+1
			cnt=0,is_going=0;//归零
		}
	}
	if(is_going==1)//如果还站在篮下
	{
		if(l<4)//如果还没到四个全程
		{
      ans+=min(b,c*max(3-cnt,0));//此时理论方案是直接投进或者投满三次，取最小值
			l++;
		}
		ans+=a;//无论如何都得回来吧。。。
	}
	int ch1=a+b+a,ch2=a+c+c+c+a;//ch1:走+瞄准+回  ch2:走+随便+随便+随便+回
	cout<<ans+(4-l)*min(ch1,ch2);//剩余次数*两种理论最优方案里时间的最小值 
	
}
```
--------------aaaaaaa求过谢谢aaaaaaaa----------------

---

## 作者：Firsry (赞：1)

~~幸好中考体考选的是排球……~~

## 思路

这个题耐心的分类讨论即可，如下：

- 在已有的操作序列当中，需要统计的有：

  1. 已经花掉的时间；
  2. 已经完成的组数；
  3. 每个时间的状态，便于处理下一个状态或者补充新的操作序列。

  其中状态可以分为**是否在篮下，是否投进，失败了几次**。

  
  注意在新的一轮 `G` 的时候对于是否投进以及失败次数进行重置；
  判定是否完成一组的时候是在 `B` 的同时检查是否投进以及失败次数。

- 在补充新的序列的时候，考虑两个阶段：

  1. 上一组没有完成的部分，此时会在篮下，进行分类讨论：

     1. 对于已经完成了 $4$ 组、已经投进和已经失败不少于三次的情况，我们并不需要讨论新的投篮，可以直接回来；
     2. 否则，我们考虑一次投进以及补充剩下失败次数哪个花费更短；

     一番操作之后，总组数增加一，容易看出这么做，对于不足四个组的合理，对于不少于四个组的也没有影响。

  2. 对于新开的几个组，考虑需要多少个组（不会少于零个），以及每个组选择投进还是失败三次，相乘再与答案相加即可。

#### 杂言

`G`，`B`，`A`，`W`， 个人认为对应是 Go，Back，AC，WA，所以变量名直接一通乱搞。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

ll a, b, c;
string s;

ll ans = 0;
ll setCount = 0;
ll WACount = 0;
bool isUnderBasket = false;
bool isAC = false;

int main() {
	scanf("%lld%lld%lld", &a, &b, &c);
	cin >> s;
	for (char ch : s) {
		if (ch == 'G') {
			ans += a;
			isUnderBasket = true;
			WACount = 0;
			isAC = false;
		} else if (ch == 'W')
			ans += c, WACount++;
		else if (ch == 'A')
			ans += b, isAC = true;
		else if (ch == 'B') {
			ans += a;
			isUnderBasket = false;
			if (isAC || WACount >= 3)
				setCount++;
		}
	}
	if (isUnderBasket) {
		if (setCount < 4 && !(isAC || WACount >= 3)) {
			ll timeAC = b;
			ll timeWA = (3 - WACount) * c;
			ans += min(timeAC, timeWA);
		}
		ans += a;
		isUnderBasket = false;
		setCount++;
	}
	ll setNeed = max(0LL, 4 - setCount);
	ll setTime = min(2 * a + b, 2 * a + 3 * c);
	ans += setNeed * setTime;
	cout << ans;
	return 0;
}
```

---

## 作者：Alexxu2024 (赞：1)

[船酱魔王](https://www.luogu.com.cn/user/420998)学长太有实力了。

### 思路

一道模拟题，按照题意模拟即可。整体思路就是看已经做了几次成功，然后再把不够的部分补上即可，补的时候需要看一下需要取随便投 $3$ 次和认真投 $1$ 次中时间较快的一个方法做。

不过此题很细节，~~幸好样例多~~，大概有以下几点：

- 需要特殊处理最后一次还没有回到三分线的情况，如果成功操作次数不够就再进行一次成功操作，而且**必须回到三分线才能结束**；
- 如果已经做了不少于 $4$ 次成功操作，直接回三分线结束即可。

具体可参考代码。

### 赛时代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define int long long
using namespace std;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int a,b,c;
	cin >> a >> b >> c;
	string s;
	cin >> s;
	int n=s.length();
	int lun=0,ans=0;
	for(int i=0;i<n;i++){
		if(s[i]=='G'){
			int R=i+1;
			int x=0,y=0;
			while(R<n&&s[R]!='B'){
				if(s[R]=='A'){
					x++;
				}
				if(s[R]=='W'){
					y++;
				}
				R++;
			}
			if(R!=n){
				if(x>0||y>=3){
					lun++;
				}
				ans+=a*2+x*b+y*c;
			}
			else{
				if(x>0||y>=3){
					lun++;
					ans+=a*2+x*b+y*c;
				}
				else{
                    if(lun<4){
                        ans+=min((1-x)*b,(3-y)*c);//细节1
    					lun++;
                    }
					ans+=a*2+x*b+y*c;//细节1、细节2，要写a*2
				}
			}
		}
	}
	if(lun>=4){
        // if(s[n-1]=='G'){
        //     ans+=a;
        // }
		cout << ans;
		return 0;
	}
	ans+=(4-lun)*(2*a+min(b,3*c));
	cout << ans;
	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 思路
跟踪清风的位置（三分线或篮下），记录已经完成的完整动作数量 $s$。如果当前正在一组动作中（即已经 `G` 但未 `B`），记录上篮部分的投篮情况（是否有 `A` 或 `W` 的次数）。

* 如果已经完成至少四组完整动作且位于三分线，则无需补充操作。
* 否则，需要补充剩余的操作：
  * 如果当前位于篮下（即上一操作是 `G` 或上篮动作）：需要完成当前的上篮动作（确保满足成功条件），然后 `B` 返回。然后补充剩余的完整动作直到完成四组。
  * 如果当前位于三分线（即上一操作是 `B`）：直接补充剩余的完整动作。
---
* 对于未完成的上篮动作（当前或未来的）：可以选择直接成功（`A`，耗时 $b$ 秒）；可以选择至少三次失败（`W`，耗时 $3c$ 秒）。我们选择耗时较短的方式，即 $\min(b,3c)$。
* 对于当前正在进行的上篮动作：
  * 如果已经有 `A`，则已经成功，可以直接 `B`。
  * 如果已经有 `W`，可能需要补充足够的 `W` 或 `A` 以满足成功条件。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string S;
int a,b,c,ans,k,s; 
bool p;
int main(){
	cin>>a>>b>>c>>S;
	for(int i=0;i<S.size();i++){
		if(S[i]=='G') ans+=a,k++,p=1;
		else if(S[i]=='B'){
			ans+=a,k++,p=0;
			if(k>=5) s++;
			k=0;
		}else if(S[i]=='A') ans+=b,k+=3;
		else ans+=c,k++;
	}
	if(s>=4){
		if(!p) cout<<ans;
		else cout<<ans+a;
	}else{
		if(p){
			if(k==1){
				s++;
				if(b<3*c) ans+=a+b,ans+=(4-s)*(a*2+b);
				else ans+=a+3*c,ans+=(4-s)*(a*2+c*3);
			}else if(k==2||k==3){
				if((4-k)*c<b) ans+=a+(4-k)*c;
				else ans+=a+b;
				s++;
				if(b<3*c) ans+=(4-s)*(a*2+b);
				else ans+=(4-s)*(a*2+c*3);
			}else{
				ans+=a,s++;
				if(b<3*c) ans+=(4-s)*(a*2+b);
				else ans+=(4-s)*(a*2+c*3);
			}
		}else{
			if(b<3*c) ans+=(4-s)*(a*2+b);
			else ans+=(4-s)*(a*2+c*3);
		}
		cout<<ans;
	}
}
```
有问题请指出！

---

## 作者：Chenxuhang_play (赞：0)

题目传送门：<https://www.luogu.com.cn/problem/P12396>

## 题目大意

+ 给定三个正整数 $a,b,c$，和一个仅包含 `G`,`A`,`W`,`B` 四种字符的字符串 $s$。

+ 保证 $s$ 中每个 `G` 之后的下一个 `G` 一定在下一个 `B` 之后。

+ 定义一组完整动作是一个 `G`，`B` 中间有至少一个 `A` 或三个 `W` 所组成的字符串，最简的一组完整动作形如 `GAB` 或 `GWWWB`。`GAAB` 和 `GWWWWWWWB` 也是一组完整动作，`GB` 不算一组完整动作。

+ 每个 `G` 和 `B` 的权值均为 $a$，`A` 的权值为 $b$，`W` 的权值为 $c$。

在字符串 $s$ 后面追加若干个字符，使得到的新字符串 $str$ 有至少四组完整动作，注意 $str$ 的最后一个字符应为 `B`。求 $str$ 的权值的最小值。

## 10pts 做法

通过观察数据，有：

> 对于测试点 $1$，保证按照给出的操作序列可以直接结束考试。

所以只需直接计算每个字母所对应的时间之和即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c;
	string s;
	cin>>a>>b>>c>>s;
	int len=s.size(),i=0,t=0;
	while(i<len)
	{
		if(s[i]=='G') t+=a;
		else if(s[i]=='B') t+=a;
		else if(s[i]=='A') t+=b;
		else if(s[i]=='W') t+=c;
		i++; 
	}
	
	cout<<t;
	return 0;
}
```

## 50pts 做法

通过观察数据，有：

> 对于测试点 $2\sim 5$，保证 $b=c$。

所以我们可以不用考虑 `W`。

首先统计有多少组完整动作。

### 完整动作数量不足四组

如果不足四组且已经给出其中一组的部分，考虑 `s` 的如下几种情况：（$0\le x<4$）

+ `GABGWWWBGBG`  
  这种情况表示为，已经给出前 $x$ 组完整动作且给出了第 $x+1$ 组的 `G` 或 `GA`，这时只需补充 `AB` 或 `B` 将第 $x+1$ 组补充为一组完整动作，再补充 $3-x$ 组 `GAB`，就能最小化权值。
  
+ `GABGW`  
  这种情况表示为，已经给出前 $x$ 组完整动作，且给出了第 $x+1$ 组的 `G` 和若干个 `W`。  
  当 `W` 个数为 $1$ 或 $2$ 时补充 `AB` 将第 $x+1$ 组补充为一组完整动作，再补充 $3-x$ 组 `GAB`，就能最小化权值；  
  当 `W` 个数为 $3$ 时，补充 `B` 将第 $x+1$ 组补充为一组完整动作，再补充 $3-x$ 组 `GAB`，就能最小化权值。
  
+ `GABGBGB`  
  这种情况表示为，已经给出前 $x$ 组完整动作，只需补充 $4-x$ 组 `GAB` 就能最小化权值。

### 完整动作数量达到四组

如果 $s$ 的结尾已经是 `B`，则直接计算其权值即可；如果 $s$ 的结尾不是 `B`，则添加 `B` 后计算其权值。

其余见注释。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c;
	string s;
	cin>>a>>b>>c>>s;
	int len=s.size(),i=0,t=0,k=0,t_A=0,t_W=0;
	bool bo=true;
	while(i<len)
	{
		if(s[i]=='G')
		{
			t+=a;
			bo=true;
		}
		else if(s[i]=='B')
		{
			t+=a;
			if(t_A>=1 || t_W>=3) k++;
			bo=false;
			t_A=0;
			t_W=0;
			
		}
		else if(s[i]=='A')
		{
			t+=b;
			t_A++;
		}
		else if(s[i]=='W')
		{
			t+=c;
			t_W++;
		}
		i++;
	}
	if(!bo) cout<<t+(max(0,4-k))*(a+b+a);//已经完成若干个完整组 
	else if(k>=4 && bo) cout<<t+a;//已经完成四组以上的完整组且不在篮下
	else if(t_A>=1 || t_W>=3) cout<<t+a+(max(0,3-k))*(a+b+a);//给出的最后一个完整组已经给出了至少一个 A 或三个 W  
	else if(t_A==0 || t_W<3) cout<<t+b+a+(max(0,3-k))*(a+b+a);//给出的最后一个完整组没完成投篮动作
	return 0;
}
```

~~按照 50pts 打的代码竟然拿了 60pts。~~

## 100pts 做法

根据 50pts 的代码稍作改变即可得出，例如将 `b` 改为 `min(b,3*c)` 等 ，详细内容见注释。

下面是变量含义解释。

`t_A` 表示 `A` 的次数，`t_W` 表示 `B` 的次数，`k` 表示完整组个数。

`bo` 表示给出的最后一组的状态，如果是完整组，即末尾为 `B`，则为 `false`；如果末尾不是 `B`，则为 `true`。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c;
	string s;
	cin>>a>>b>>c>>s;
	int i=0,t=0,k=0,t_A=0,t_W=0; 
	bool bo=true;
	while(i<s.size())
	{
		if(s[i]=='G')
		{
			t+=a;
			bo=true;
		}
		else if(s[i]=='B')
		{
			t+=a;
			if(t_A>=1 || t_W>=3) k++;
			bo=false;
			t_A=0;
			t_W=0;
			
		}
		else if(s[i]=='A')
		{
			t+=b;
			t_A++;
		}
		else if(s[i]=='W')
		{
			t+=c;
			t_W++;
		}
		i++;
	}
	if(!bo) cout<<t+(max(0,4-k))*(a+min(b,3*c)+a); //已经完成若干个完整组（可以为 0） 
	else if(k>=4 && bo) cout<<t+a; //已经完成四个以上的完整组且不在篮下 
	else if(t_A>=1 || t_W>=3) cout<<t+a+(max(0,3-k))*(a+min(b,3*c)+a);//已经给出了至少一个 A 或三个 W  
	else if(t_A==0 || t_W<3) //给出的最后一组没有完成投篮动作 
	{
		cout<<t+min(b,(3-t_W)*c)+a+(max(0,3-k))*(a+min(b,3*c)+a);
	}
	
	return 0;
}
```

---

## 作者：SRQ_321 (赞：0)

## 思路

先计算给定的操作完成的轮数，如果不满足，则继续判断：

  1. 如果操作结束后有 $\le2$ 次 `W` 操作，则继续补完（做多次`W`或一次`A`）。
2. 如果完成投篮后仍在篮筐下，返回三分线.
3. 如果投篮动作组数 $\le3$ 则继续做动作三次`W`后一次`A`。

### AC code
```cpp
include<bits/stdc++.h>
using namespace std;
int a,b,c,t,w=1,p,k,f[105];
string s;
int main(){
    cin>>a>>b>>c>>s;
    for(int i=0;i<s.size();i++){
        if(s[i]=='G'){
            t+=a;
            w=2;
        }else if(s[i]=='B'){
            if(p==3){
                k++;
            }
            p=0;
            t+=a;
            w=1;
        }else if(s[i]=='A'){
            t+=b;
            p=3;
        }else if(s[i]=='W'){
            t+=c;
            p=min(p+1,3);
        }
    }
    int m=4-k;
    if(m<=0){
        cout<<t+a*(w-1);
        return 0;
    }
    if(w==1&&m>0){
        t+=a;
        w=2;
    }
    t+=min(b,(3-p)*c)+a*2;
    m--;
    while(m>0){
        t+=min(b,3*c)+a*2;
        m--;
    }
    cout<<t-a;
    return 0;
}
```

---


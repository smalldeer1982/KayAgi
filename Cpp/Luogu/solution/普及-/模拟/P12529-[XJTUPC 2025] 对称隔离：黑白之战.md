# [XJTUPC 2025] 对称隔离：黑白之战

## 题目描述

你在玩一款叫做「你的克拉夫特」的游戏。在这个游戏里，你可以在一个充满着方块的三维空间中自由地创造和破坏不同种类的方块。

现在你脚下有一块由 $N\times M$ 个格子组成的网格。一开始，你在这些格子上铺满了白色地毯，然后你就去睡觉了。

但是不幸的是，在你睡觉的时候，出题人将一些白色地毯偷偷换成了黑色地毯。

当你醒来再次打开游戏，你发现你的杰作被污染了，所以你非常气愤！所以你决定将错就错，希望通过保持现有黑色地毯不变，将部分白色地毯染黑，来满足下面两个条件：
- 任意两个黑色地毯所在的格子不能共享公共边，即满足：
  - 若第 $i$ 行第 $j$ 列格子中为黑色地毯，则第 $i-1$ 行第 $j$ 列、第 $i+1$ 行第 $j$ 列、第 $i$ 行第 $j-1$ 列、第 $i$ 行第 $j+1$ 列格子中如果存在地毯，则不能为黑色地毯。
- 最终形成的图案至少存在一条水平或者竖直的对称轴，即下面两个命题中至少满足一个：
  - 对于任意的 $i \in [1,N]$ 和 $j \in [1,M]$，第 $i$ 行第 $j$ 列格子中的地毯颜色与第 $N-i+1$ 行第 $j$ 列格子中的地毯颜色相同；
  - 对于任意的 $i \in [1,N]$ 和 $j \in [1,M]$，第 $i$ 行第 $j$ 列格子中的地毯颜色与第 $i$ 行第 $M-j+1$ 列格子中的地毯颜色相同。
  
你需要判断你是否可以达成这两个条件。

注意：你不能破坏已有的黑色地毯。

## 说明/提示

对于第一组样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/e9hqggx4.png)


最左边的图是你醒来时看到的情况，你无法通过把白色地毯换成黑色地毯以达成条件。中间和最右边的图，显示了两种可能的更换地毯的方式，但并不能满足题目中的两个要求（中间的图不存在水平或者竖直的对称轴；最右边的图黑色地毯共享公共边）。可以证明，任何更换地毯的方式均不符合要求，所以输出 $\tt{No}$。

对于第二组样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/3o95kyxx.png)

如图显示了一种合法的更换地毯的方式。你可以把左下角的白色地毯换成黑色地毯，这样符合题目中的两个要求。因此，你应该输出 $\tt{Yes}$。

对于第三组样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/si5x2zj6.png)

这是一种可能的更换地毯的方式，但是这个方式并不是合法的。请记住：只有存在水平或者竖直的对称轴才被视作合法的方案。

对于第四组样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/rik73puq.png)

你醒来的时候看到的情况本身已经是合法的了，所以你不需要进行操作。

对于第五组样例：你醒来的时候已经有两个共享公共边的黑色地毯了，所以你无法更换白色地毯以符合要求。

对于第六组样例：全是白色地毯的图案也被视作是合法的，因为它有水平或者竖直的对称轴，同时不存在两个共享公共边的黑色地毯。

## 样例 #1

### 输入

```
4 4
WWWW
WBWW
WWWW
WWWW
```

### 输出

```
No```

## 样例 #2

### 输入

```
4 4
BWWB
WWWW
WWWW
WWWB
```

### 输出

```
Yes```

## 样例 #3

### 输入

```
4 4
BWWW
WBWW
WWBW
WWWW
```

### 输出

```
No```

## 样例 #4

### 输入

```
5 5
BWBWB
WBWBW
BWBWB
WBWBW
BWBWB
```

### 输出

```
Yes```

## 样例 #5

### 输入

```
2 2
BB
WW
```

### 输出

```
No```

## 样例 #6

### 输入

```
2 2
WW
WW
```

### 输出

```
Yes```

## 样例 #7

### 输入

```
8 6
WWBWWW
BWWWWW
WBWWWW
WWWWBW
BWWWWW
WWBWWW
WBWWWW
BWWWWW```

### 输出

```
No```

# 题解

## 作者：_hud (赞：9)

# 题解：[P12529 [XJTUPC 2025] 对称隔离：黑白之战](https://luogu.com.cn/problem/P12529)

## 题目大意
给定一个 $N \times M$ 的网格，只存在白色或黑色的地毯。现需在保留原有黑色地毯的基础上，将部分白色染黑，满足以下条件：

1. 任意两个黑色格子不相邻
2. 存在水平或竖直对称轴
   
判断是否存在合法方案。

## 思路分析

观察到本题数据范围较小，故考虑使用**模拟算法**。由于本题要求必须存在一条水平或竖直对称轴，故我们可以构造存在水平对称轴和存在竖直对称轴两种情况，然后进行检查，是否有黑色格子相邻。

那么这道题就写完了。具体实现可以看代码。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 110
#define w ^
char mapp[N][N], raw[N][N];
int n, m;
inline bool chk() {
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            if(mapp[i][j] == 'B' && (mapp[i-1][j] == 'B' || mapp[i+1][j] == 'B' || mapp[i][j-1] == 'B' || mapp[i][j+1] == 'B'))
                return false;
    return true;
}
inline bool ac() {
    // 构造存在水平对称轴的情况
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            if(mapp[i][j] != mapp[n-i+1][j]) // 对称点颜色不同时，强制两边都染黑
                mapp[i][j] = mapp[n-i+1][j] = 'B';
    if(chk()) return 1;
    // 恢复原始地图
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            mapp[i][j] = raw[i][j];
    // 构造存在竖直对称轴的情况
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
            if(mapp[i][j] != mapp[i][m-j+1]) 
                mapp[i][j] = mapp[i][m-j+1] = 'B';     
    return chk();
}
signed main() {
    cin.tie(0), cout.tie(0) -> sync_with_stdio(0);
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> mapp[i][j];
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            raw[i][j] = mapp[i][j];
    // 初始状态合法性检查（原有黑色是否已存在相邻）
    if(!chk()) { cout << "No"; return 0; }
    cout << (ac() ? "Yes" : "No");
    return 0 w 0;
}
```

---

## 作者：Clare613 (赞：7)

~~应该是我太蒻了，交了十次才 A。~~
## 思路：
一道很好的存在性问题，我们只要判断是否不存在即可。
我们有以下几种情况可能导致不可能达成这两个条件：
1. 数组本身就有误：\
这种情况只要判断相邻的是否两个都是黑色的，如果都是黑色的，那么就不存在。
3. 横竖均不可能对称：\
在这种情况下又有两种：\
第一种：\
如果当前为黑色，且其横和纵对称后的四周均有黑色地毯，那么不可行。\
第二种：\
如果横和纵对称的中心点都有为黑色地毯的，那么不可行。对于中心点，就是在行列均为偶数是，正中间的两行或两列的点称为横和纵对称的中心点。

如果以上条件都没有使答案输出 $\tt{No}$，那么就输出 $\tt{Yes}$ 即可。
## code：
```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define int long long
using namespace std;
char a[105][105];
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	int n,m;
	cin>>n>>m;
	bool flag1=0,flag2=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=0;k<4;k++){
				int nx=i+dx[k];
				int ny=j+dy[k];
				if(nx<1||nx>n||ny<1||ny>m) continue;
				if(a[i][j]=='B'&&a[nx][ny]=='B'){
					cout<<"No";
					return 0;
				}
			}
			if(a[i][j]=='B'){
				if((a[n-i+1-1][j]=='B'||a[n-i+1+1][j]=='B'||a[n-i+1][j-1]=='B'||a[n-i+1][j+1]=='B')&&(a[i][m-j+1-1]=='B'||a[i][m-j+1+1]=='B'||a[i-1][m-j+1]=='B'||a[i+1][m-j+1]=='B')){
					cout<<"No\n";
					return 0;
				}
			}
			if(n%2==0&&(n/2==i||n/2+1==i)&&a[i][j]=='B'){
				flag1=1;
				if(flag2==1){
					cout<<"No";
					return 0;
				}
			}
			if(m%2==0&&(m/2==j||m/2+1==j)&&a[i][j]=='B'){
				flag2=1;
				if(flag1==1){
					cout<<"No";
					return 0;
				}
			}
		}
	}
	cout<<"Yes";
	return 0;
}
```

---

## 作者：cybermage_liu (赞：6)

# 思路
非常巧妙的思路！

我们可以对于每块地毯进行分析，分为四种情况：
* 这块地毯是白的，邻近地毯有黑的，这块地毯只能是白。
* 这块地毯是黑的，邻近地毯全白的，这块地毯只能是黑。
* 这块地毯是白的，邻近地毯全白的，这块地毯可以由白变黑。
* 这块地毯是黑的，邻近地毯有黑的，一定无解。

我们将前三种情况的地毯分别标记为 $0$、$1$ 和 $2$。

然后判断是否有可能存在竖直或水平对称轴。

对于竖直对称的两块地毯，如果存在两块地毯标记不相同，且都不是 $2$，那就不存在竖直对称轴。

水平对称同理。
# 正确性证明
这时候就有人要说了，这不是瞎写吗？假设两块相邻的地毯都由白变黑，这怎么办？

我们来分析一下：

现在有一块地毯 $X_1$，它有一块相邻的地毯 $Y_1$。

$X_1$ 竖直对称的地毯为 $X_2$，$Y_1$ 竖直对称的地毯为 $Y_2$。

水平对称同理。

$X_1$ 和 $Y_1$ 不能都为黑。

那么 $X_2$ 和 $Y_2$ 都不能由白变黑。

相反同理。

所以只能是 $X_1$ 和 $Y_2$ 为黑，$X_2$ 和 $Y_1$ 为白，相反同理。

但是此时又不满足上面的假设了，$X_2$ 和 $Y_1$ 相邻的地毯有黑了，不能变色了。

所以这种思路是正确的。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int a[N][N],c[N][N];
string s;
int pd(int x,int y){
	if(!c[x][y]){
		if(c[x-1][y]|c[x][y-1]|c[x+1][y]|c[x][y+1]) return 0;
		//这块地毯白，相邻的有黑 
		else return 2;//这块地毯白，相邻的地毯白 
	}
	else return c[x-1][y]|c[x][y-1]|c[x+1][y]|c[x][y+1];
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=1;j<=m;j++){
			if(s[j-1]=='W') c[i][j]=0;
			else c[i][j]=1;//标记颜色 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(pd(i,j)==1){//有相邻的黑色 
				cout<<"No";
				return 0;
			}
			if(pd(i,j)==2) a[i][j]=2;//这块白地毯可改为黑色 
			else a[i][j]=c[i][j];//这块地毯不能改变颜色 
		}
	}
	//竖直对称轴 
	int vis=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]!=a[i][m-j+1] && a[i][j]!=2 && a[i][m-j+1]!=2){
				vis=1;//两块地毯颜色不同且无法改变颜色 
				break;
			}
		}
		if(vis) break;
	}
	if(!vis){
		cout<<"Yes";
		return 0;
	}
	//水平对称轴 
	vis=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]!=a[n-i+1][j] && a[i][j]!=2 && a[n-i+1][j]!=2){
				vis=1;//两块地毯颜色不同且无法改变颜色 
				break;
			}
		}
		if(vis) break;
	}
	if(!vis){
		cout<<"Yes";
		return 0;
	}
	cout<<"No";//两个对称轴都没有 
}
```

---

## 作者：Chen_Borui (赞：3)

# 题目大意

黑色毯子不能有相邻且要有水平或竖直的对称轴。

# 思路

一个长方形（正方形算为长方形的一种特殊情况）有且仅有一条水平对称轴和一条竖直对称轴，所以我们只需要用两个数组 $x$ 和 $y$ 分别储存沿水平或竖直对称的图案，再去判断是否有相邻就可以了。

# 代码

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
#define int long long//这玩意老好用了
inline void read(int& a){
    int s=0, w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if (ch=='-')
            w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
    s=s*10+ch-'0';
        ch=getchar();
    }
    a=s*w;
}//快读
void write(int x){
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}//快写
char ma[105][105];
char x[105][105],y[105][105];//x 和 y 分别储存沿水平或竖直对称的图案
signed main(){
    int n,m;
    read(n),read(m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>ma[i][j],
            x[i][m-j+1]=ma[i][j],
            y[n-i+1][j]=ma[i][j];
        }
    }//先存反转后的图案
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            if(ma[i][j]=='B')
                x[i][j]=ma[i][j];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            if(ma[i][j]=='B')
                y[i][j]=ma[i][j];
    }//再存原图案的黑色块，那么我们就实现了最终形成的图案至少存在一条水平或者竖直的对称轴
    bool f1=true,f2=true;
    for(int i=1;i<n;i++){
        for(int j=1;j<=m;j++){
            if(x[i][j]==x[i+1][j] && x[i][j]=='B'){
                f1=false;
                break;
            }
        }
        if(!f1) break;
    }//判断 x 数组是否有垂直的相邻黑色块
    for(int i=1;i<=n;i++){
        for(int j=1;j<m;j++){
            if(x[i][j]==x[i][j+1] && x[i][j]=='B'){
                f1=false;
                break;
            }
        }
        if(!f1) break;
    }//判断 x 数组是否有水平的相邻黑色块
    for(int i=1;i<n;i++){
        for(int j=1;j<=m;j++){
            if(y[i][j]==y[i+1][j] && y[i][j]=='B'){
                f2=false;
                break;
            }
        }
        if(!f2) break;
    }//判断 y 数组是否有垂直的相邻黑色块
    for(int i=1;i<=n;i++){
        for(int j=1;j<m;j++){
            if(y[i][j]==y[i][j+1] && y[i][j]=='B'){
                f2=false;
                break;
            }
        }
        if(!f2) break;
    }//判断 y 数组是否有水平的相邻黑色块
    if(f1 || f2) printf("Yes");//只要满足一种就可以输出 yes
    else printf("No");//没有情况可以成立则输出 no
    return 0;//完美结束
}
```

# 后记

这是一道非常基础的模拟题，只需要模拟是否满足题目给的两个条件即可。

---

## 作者：weifengzhaomi (赞：3)

怎么说，这题还是蛮水的。

## 题意 & 化简

现在有一个图，问有没有一种方法，保持黑色，修改白色，使得图形变成一个**以水平或垂直为对称轴的轴对称图形。**

## 思路

既然题目说了，要变成一个**以水平或垂直为对称轴的轴对称图形**，那么就可以分两种情况讨论，一种以水平为对称轴的轴对称图形，一种以垂直为对称轴的轴对称图形。

接下来，我们预处理好两个数组，就可以看符不符合**任意两个黑色地毯所在的格子不能共享公共边**这个条件即可，按照题目里的来模拟就行了。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char s[110][110];
char k[110][110];
inline void clec(){
	memcpy(k,s,sizeof(k));
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m / 2 + m % 2;j++)
			if (s[i][j] == 'B') s[i][m - j + 1] = s[i][j];
	for (int i = 1;i <= n / 2 + n % 2;i++)
		for (int j = 1;j <= m;j++)
			if (k[i][j] == 'B') k[n - i + 1][j] = k[i][j];
	bool flag = true;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			if (s[i][j] == 'B')
				if (s[i - 1][j] == 'B' || s[i + 1][j] == 'B' || s[i][j - 1] == 'B' || s[i][j + 1] == 'B')
					flag = false;
	if (flag) printf("Yes\n");
	else {
		flag = true;
		for (int i = 1;i <= n;i++)
			for (int j = 1;j <= m;j++)
				if (k[i][j] == 'B')
					if (k[i - 1][j] == 'B' || k[i + 1][j] == 'B' || k[i][j - 1] == 'B' || k[i][j + 1] == 'B')
						flag = false;
		if (flag) printf("Yes\n");
		else printf("No\n");
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i = 1;i <= n;i++) scanf("%s",s[i] + 1);
	clec();
}
```

---

## 作者：Zskioaert1106 (赞：2)

题目传送门：[P12529 [XJTUPC 2025] 对称隔离：黑白之战](https://www.luogu.com.cn/problem/P12529)

### 题目分析

首先自己染的黑色地毯肯定越少越可能满足不共享公共边的标准，因此只需分别检查拥有水平、竖直对称轴的情况。

对于每种情况，把原先的图案复制一遍，之后：如果当前格子是黑色的，就把轴对称过去的那个格子也染黑。最后再分别遍历一遍检查，只要两个里面有一个满足没有共享公共边的黑格子，就输出 `Yes`。

### 代码实现

```cpp
#include<iostream>
using namespace std;
int n,m;
bool a[101][101],b[101][101],p1=1,p2=1;
int main(){
	cin>>n>>m;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        for(int j=1;j<=m;j++)
            a[i][j]=b[i][j]=(s[j-1]=='B');
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j])a[n-i+1][j]=1;
            if(b[i][j])b[i][m-j+1]=1;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j])
                if(a[i-1][j]||a[i+1][j]||a[i][j-1]||a[i][j+1])p1=0;
            if(b[i][j])
                if(b[i-1][j]||b[i+1][j]||b[i][j-1]||b[i][j+1])p2=0;
        }
    }
    cout<<((p1||p2)?"Yes":"No");
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/217727960)。

---

## 作者：ShiYuXuan1234 (赞：2)

## 题意简述
我们要将一个只由`W`和`B`组成的地图通过将`W`变为`B`使网格上下对称或左右对称，同时，每两个`B`不能相邻。问：是否能完成该操作。
## 思路
我们定义这个 $N\times M$ 的地图为 $maps$。以 **【样例#5】** 为例，当地图原本就存在相邻的`B`时，一定无法构成满足条件的网格，可直接输出`No`。

反之，我们则需要另定义一个地图 $mp$，将 $maps$ 复制给 $mp$（原因见下），并在不考虑两个`B`是否相邻的情况下，分别完成一张上下对称和一张左右对称的地图（两张，需要两份），然后判断其是否满足每两个`B`不能相邻。如果可以，则输出`Yes`。如果上下对称和左右对称都不满足条件，则输出`No`。

到了这里，思路就很清晰了。那么，就让我们愉快的写代码吧！~~（我绝对不会告诉你我因为把 $m$ 写成了 $n$ 吃了 $4$ 发罚时的）~~
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
char maps[101][101],mp[101][101];
bool lj(){//判断是否满足没有任何B相邻
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='B'){
				if(mp[i-1][j]=='B'||
				mp[i][j-1]=='B'||
				mp[i+1][j]=='B'||
				mp[i][j+1]=='B'){
					return 0;//有则返回0
				}
			}
		}
	}
	return 1;//没有返回1
}
void ud(){//上下对称
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='B'&&mp[n-i+1][j]=='W'){
				mp[n-i+1][j]='B';
			}
		}
	}
}
void lr(){//左右对称
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='B'&&mp[i][m-j+1]=='W'){
				mp[i][m-j+1]='B';
			}
		}
	}
}
void cpy(){//将maps复制给mp
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
            mp[i][j]=maps[i][j];
        }
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>maps[i][j];
		}
	}
	cpy();
	if(!lj()){//样例#5
		cout<<"No"<<endl;
        return 0;
	}
	ud();
	if(lj()){//上下对称且满足没有任何B相邻
    	cout<<"Yes"<<endl;
    	return 0;    	
	}
	cpy();
	lr();
	if(lj()){//左右对称且满足没有任何B相邻
    	cout<<"Yes"<<endl;   	
	}else{
        cout<<"No"<<endl;
    }  
	return 0;
}
```
最后，[AC 记录](https://www.luogu.com.cn/record/217654025)。

---

## 作者：Evan2000 (赞：1)

## 思路

我的想法很简单，就是枚举所有的黑色地毯，首先试一下满足水平的对称轴，把黑色地毯按照水平的对称轴翻转过去，判一下所有黑色地毯共享公共边的格子里有没有黑色地毯，如果没有，直接输出 ```Yes```，否则试一下竖直的对称轴，把黑色地毯按照竖直的对称轴翻转过去，判一下所有黑色地毯共享公共边的格子里有没有黑色地毯，如果没有，输出 ```Yes```，否则，输出 ```No```。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[110][110];
char t[110][110];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s[i]+1);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			t[i][j]=s[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='B')
			{
				s[n-i+1][j]='B';
			}
		}
	}
	int flag=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='B' && (s[i-1][j]=='B' || s[i+1][j]=='B' || s[i][j-1]=='B' || s[i][j+1]=='B'))
			{
				flag=1;
				break;
			}
		}
		if(flag==1)
		{
			break;
		}
	}
	if(flag==0)
	{
		printf("Yes");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(t[i][j]=='B')
			{
				t[i][m-j+1]='B';
			}
		}
	}
	flag=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(t[i][j]=='B' && (t[i-1][j]=='B' || t[i+1][j]=='B' || t[i][j-1]=='B' || t[i][j+1]=='B'))
			{
				flag=1;
				break;
			}
		}
		if(flag==1)
		{
			break;
		}
	}
	if(flag==0)
	{
		printf("Yes");
	}
	else
	{
		printf("No");
	}
	return 0;
}
```

---

## 作者：_Lazy_zhr_ (赞：1)

模拟题。

直接对于两条对称轴进行翻转，再检查是否合法。如果两种反转方式都不合法，就输出 No，否则就是 Yes。

代码如下：

```cpp
int n,m;
char f[105][105],g[105][105];
void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		cin>>f[i][j];
		g[i][j]=f[i][j];
	} for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(f[i][j]=='B') f[n-i+1][j]='B';
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(g[i][j]=='B') g[i][m-j+1]='B';
	bool x=true,y=true;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(f[i][j]=='B'&&(f[i-1][j]=='B'||f[i+1][j]=='B'||f[i][j-1]=='B'||f[i][j+1]=='B')){
		x=false;
		break;
	} for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(g[i][j]=='B'&&(g[i-1][j]=='B'||g[i+1][j]=='B'||g[i][j-1]=='B'||g[i][j+1]=='B')){
		y=false;
		break;
	} if(x||y) cout<<"Yes\n";
	else cout<<"No\n";
}
```

---

## 作者：liuhaoyan0323 (赞：1)

## 思路

简单的模拟题。\
不能发现第 $1$ 个条件才是关键，而第 $2$ 个问题能染色解决。

考虑以横着的对称轴和纵着的对称轴各做一遍对称染色，再判断是否满足条件 $1$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N (int)(1E3+5)
using namespace std;
char g1[N][N],g2[N][N];
signed main(){
    int n,m;
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            cin>>g1[i][j];
            g2[i][j]=g1[i][j];
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(g1[i][j]=='B')g1[n-i+1][j]='B';
        }
    }
    bool ok=true;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(g1[i][j]=='B'){
                if(g1[i-1][j]=='B'||g1[i+1][j]=='B'||g1[i][j-1]=='B'||g1[i][j+1]=='B'){
                    ok=false;
                }
            }
        }
    }
    if(ok){
        puts("Yes");
        return 0;
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(g2[i][j]=='B')g2[i][m-j+1]='B';
        }
    }
    ok=true;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(g2[i][j]=='B'){
                if(g2[i-1][j]=='B'||g2[i+1][j]=='B'||g2[i][j-1]=='B'||g2[i][j+1]=='B'){
                    ok=false;
                }
            }
        }
    }
    puts(ok?"Yes":"No");
    return 0;
}
```

---

## 作者：jnxx_liuchenxiang (赞：1)

# 题解：P12529 [XJTUPC 2025] 对称隔离：黑白之战

## 题目大意

有一个 $ N\times M$ 的方格，每个方格可以为 $\tt{W}$（表示这个方块是白色）或者是 $\tt{B}$（表示这个方块是黑色）。

我们要找出这个方格能否将部分白色方块染黑（不能把黑色方块染白），来满足下面两个条件：

- 任意两个黑色方块所在的格子不能共享公共边。
- 最终形成的图案至少存在一条水平或者竖直的对称轴。

## 解题思路

首先，我们需要先判断已经给出的方块是否已经有黑色方块共享公共边。解决这个目标，我们只用模拟即可。

其次，我们需要分别尝试构造水平对称和垂直对称的图案，通过以下步骤：

- 复制原始网格。
- 强制每对对称行具有相同的 $\tt{B}$ 位置。
- 检查构造后的网格是否合法。

最后，如果这两种构造都不符合题意，则输出 $\tt{No}$，否则输出 $\tt{Yes}$。

## 复杂度分析

时间复杂度：$O(NM)$。

- 预处理检查：遍历所有格子，时间为 $O(NM)$。
- 对称性构造与验证：每次构造和验证均需遍历所有格子，时间为 $O(NM)$。
- 总时间：$O(NM) + 2 \times O(NM) = O(NM)$。

空间复杂度：$O(NM)$。

## 题目代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,flagn=1,flagm=1;
char a[110][110],newa[110][110];
int dx[4]={0,0,1,-1}; 
int dy[4]={1,-1,0,0};

bool check(int x,int y){ //检查边界
	if(x<=0 || y<=0)return 0;
	if(x>n || y>m)return 0;
	return 1;
}

bool flag(char p[110][110]){ //检查是否有黑色方块共享公共边
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(p[i][j]=='B'){
				for(int k=0;k<4;k++){
					int nx=i+dx[k];
					int ny=j+dy[k];
					if(check(nx,ny) && p[nx][ny]=='B'){
						return 0;
					}
				}
			}
		}
	}
	return 1;
}

bool fn(){ //尝试构造水平对称
	memset(newa,0,sizeof(newa));
	for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            newa[i][j]=a[i][j];
        }
    }
    for(int i=1;i<=(n+1)/2;i++){
        int mir=n-i+1;
        for(int j=1;j<=m;j++){
            if(a[i][j]=='B' || a[mir][j]=='B'){
                newa[i][j]='B';
                newa[mir][j]='B';
            }
        }
    }
    return flag(newa);
}

bool fm(){ //尝试构造垂直对称
	memset(newa,0,sizeof(newa));
	for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            newa[i][j]=a[i][j];
        }
    }
    for(int j=1;j<=(m+1)/2;j++){
        int mir=m-j+1;
        for(int i=1;i<=n;i++){
            if(a[i][j]=='B' || a[i][mir]=='B'){
                newa[i][j]='B';
                newa[i][mir]='B';
            }
        }
    }
    return flag(newa);
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	if(flag(a)==0){
		cout<<"No";
		return 0;
	}
	if(fn() || fm())cout<<"Yes";
	else cout<<"No";
	
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

P12529
---
### 题意简述
~~莫名发现这种比赛的橙题题面真的好长。~~

你的 $N\times M$ 杰作被出题人污染了，但是你心胸宽广，决定将一些白色区域给染成黑色，然后判断是否可以达成条件。
### 思路
虽然题面很长，但是中心内容很容易就把握了。我们可以采用对称镜像判断的方式来解决。如果这个“杰作”水平方向对称，那么就按照中线（水平线）反转，反之垂直亦然。

反转后初始的黑格子镜像后表示的格子也要表示为黑格。构造好之后，遍历每一个黑格子，如果黑格子有相邻的黑格，那么条件不成立；如果水平与垂直任意一种方案可行，那么就输出 `Yes`，反之 `No`。

### 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
char a[105][105];
int dx[4] = { -1, 1, 0, 0 };
int dy[4] = { 0, 0, -1, 1 };

bool check(bool h) {
    char b[105][105];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            b[i][j] = a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] == 'B') {
                int ii = (h ? (n - i + 1) : i);
                int jj = (h ? j : (m - j + 1));
                b[ii][jj] = 'B';
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (b[i][j] == 'B') {
                for (int d = 0; d < 4; d++) {
                    int x = i + dx[d];
                    int y = j + dy[d];
                    if (x >= 1 && x <= n && y >= 1 && y <= m) {
                        if (b[x][y] == 'B') {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }

    if (check(true) || check(false)) {
        cout << "Yes";
    } else {
        cout << "No";
    }

    return 0;
}
```

---

## 作者：Vitamin_B (赞：0)

分讨一下即可。

首先你可以使它最终呈水平的对称轴，即 $\forall 1\le i\le n,1\le j\le m,a_{i,j}=a_{n-i+1,j}$。随后检查一下新数组中有没有相邻的黑地毯即可。

```cpp
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= m; ++ j)
			if (a[i][j] == 'W')
				a[i][j] = a[n - i + 1][j];
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= m; ++ j)
			if (a[i][j] == 'B')
				for (int k = 0; k < 4; ++ k)
					if (a[i + dx[k]][j + dy[k]] == 'B')
						goto diea;
	cout << "Yes";
	return 0;
diea:
	;
```

竖直的对称轴同理。

---

## 作者：UNNN (赞：0)

## 题意

 给出一个 $N \times M$ 的白色地毯方格，方格中有部分变成了黑色地毯，求是否可以将剩余的白色地毯修改为黑色地毯，使得：
 - 所有黑色地毯不共边；
 - 黑色地毯要么关于横排中点对称分布，要么关于竖排中点对称分布。

## 思路

 我们可以新建一个二维数组，用于存储你醒来之后地毯的样式。

 随后，根据题意可知，我们要让以上两种情况都满足才可以输出 `Yes`，题目中给出 $1≤N, M≤100$，故可以直接暴力求解。

 如果我们进行“先满足条件一再判断条件二是否成立”的思路的话会显得非常麻烦。因为我们在满足条件一后，由于第二个条件是针对所有黑色地毯而言的，而第一个条件是针对部分黑色地毯而言的，因此要一个个排除一些黑色地毯并检查条件二的合理性，而且还要对原本就有的黑色地毯进行标记，还要考虑两种对称情况等等。
 
 总之，这一方案不可行。

 因此，我们可以进行“先满足条件二再判断条件一是否成立”的思路。先把所有原本存在的黑色地毯进行横排对称，再检查是否存在黑色地毯共边的情况，再把所有黑色地毯进行竖排中点对称，再检查是否存在共边情况。如果两种都存在共边情况，即只满足条件二不满足条件一，就输出 `No`；如果两者中任意一种都不存在共边情况，就输出 `Yes`。

 关于代码，我们可以定义两个二维数组，一个用于存储横排中点对称后的情况，另一个用于存储竖排中点对称后的情况，再对两个数组进行共边检查。

## Code

 
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, m, dx[5] = {-1, 0, 1, 0}, dy[5] = {0, 1, 0, -1};
char mp[105][105], mp1[105][105], mp2[105][105];
bool check1(int x, int y){ // 检查横排共边
    if(mp1[x][y] == 'W') return true;
    for(int i = 0;i < 4;i++){
        int xx = x + dx[i];
        int yy = y + dy[i];
        if((xx >= 1 && xx <= n) && (yy >= 1 && yy <= m) && mp1[xx][yy] == 'B') return false; // 共边，不满足条件一，返回 false
    }
    return true;
}
bool check2(int x, int y){ // 检查竖排共边
    if(mp2[x][y] == 'W') return true;
    for(int i = 0;i < 4;i++){
        int xx = x + dx[i];
        int yy = y + dy[i];
        if((xx >= 1 && xx <= n) && (yy >= 1 && yy <= m) && mp2[xx][yy] == 'B') return false; // 共边，不满足条件一，返回 false
    }
    return true;
}
bool ys = true;
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            cin >> mp[i][j];
            // 先将我们输入进去的方格复制到两个数组里
            mp1[i][j] = mp[i][j];
            mp2[i][j] = mp[i][j];
        }
    }
    // 横排复制
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            if(mp1[i][j] == 'B') continue;
            if(mp1[n - i + 1][j] == 'B') mp1[i][j] = 'B'; // 如果该方格关于横排中点对称的方格为黑色地毯，那么将该方格更改为黑色地毯
        }
    }
    // 检查共边
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            if(!check1(i, j)){ // 存在共边
                ys = false;
                break;
            }
        }
    }
    if(ys){
        puts("Yes");
        return 0; // 如果第一种情况就不存在共边，说明一定可以满足两种情况，没有必要再检查第二种了，直接输出 Yes 然后结束程序
    }
    // 竖排复制
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            if(mp2[i][j] == 'B') continue;
            if(mp2[i][m - j + 1] == 'B') mp2[i][j] = 'B'; // 如果该方格关于竖排中点对称的方格为黑色地毯，那么将该方格更改为黑色地毯
        }
    }
    // 检查共边 
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            if(!check2(i, j)){
                puts("No");
                return 0; // 存在共边，直接输出 No
            }
        }
    }
    puts("Yes"); // 否则不存在，直接输出 Yes
    return 0; // 结束 (｡･ω･｡)
}

```

---

## 作者：banglee (赞：0)

### P12529 [XJTUPC 2025] 对称隔离：黑白之战 题解
[题目传送门](https://www.luogu.com.cn/problem/P12529)

## 思路
模拟。

观察到题目要求图案至少有一条水平或竖直的对称轴，那么可以分两种情况进行检查。

- 对于每一行 $i$，其对称行是 $n-i+1$。
- 对于每一列 $j$，其对称列是 $m-j+1$。

又观察到已有的黑色地毯不能被改变，并且任意两个黑色地毯不能相邻。那么在每种对称情况下，可以根据已有黑色地毯的位置确定必须染黑的其他位置，最后检查染黑后的图案是否满足黑色地毯不相邻的条件即可。

记得复制一遍数组，不要在原数组上进行操作。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
char a[105][105],t[105][105];
bool check1() {
	memcpy(t,a,sizeof(a));
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) {
			int ni=n-i+1;
			if (t[i][j]=='B' || t[ni][j]=='B') t[i][j]='B',t[ni][j]='B';
		}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (t[i][j]=='B') {
				if (i>1 && t[i-1][j]=='B') return false;
				if (i<n && t[i+1][j]=='B') return false;
				if (j>1 && t[i][j-1]=='B') return false;
				if (j<m && t[i][j+1]=='B') return false;
			}
	return true;
}
bool check2() {
	memcpy(t,a,sizeof(a));
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) {
			int nj=m-j+1;
			if (t[i][j]=='B' || t[i][nj]=='B') t[i][j]='B',t[i][nj]='B';
		}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (t[i][j]=='B') {
				if (i>1 && t[i-1][j]=='B') return false;
				if (i<n && t[i+1][j]=='B') return false;
				if (j>1 && t[i][j-1]=='B') return false;
				if (j<m && t[i][j+1]=='B') return false;
			}
	return true;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			cin>>a[i][j];
	if (check1() || check2()) cout<<"Yes";
	else cout<<"No";
	return 0;
}
```

---

## 作者：01bit (赞：0)

写两个函数，分别判定水平对称轴和垂直对称轴是否能合法，只要有一种合法就输出 `Yes`，否则输出 `No`。

对于每种情况，先将每个黑格子的对称位置涂黑，然后检查黑格子之间是否有公共边。

```cpp
#include <iostream>
using namespace std;
const int N = 100 + 5;
int n, m;
char s[N][N], t[N][N];
bool check1() {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            t[i][j] = s[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            if (t[i][j] == 'W')
                continue;
            t[n - i - 1][j] = 'B';
        }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            if (t[i][j] == 'W')
                continue;
            if (i > 0 && t[i - 1][j] == 'B')
                return false;
            if (i < n - 1 && t[i + 1][j] == 'B')
                return false;
            if (j > 0 && t[i][j - 1] == 'B')
                return false;
            if (j < m - 1 && t[i][j + 1] == 'B')
                return false;
        }
    return true;
}
bool check2() {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            t[i][j] = s[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            if (t[i][j] == 'W')
                continue;
            t[i][m - j - 1] = 'B';
        }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            if (t[i][j] == 'W')
                continue;
            if (i > 0 && t[i - 1][j] == 'B')
                return false;
            if (i < n - 1 && t[i + 1][j] == 'B')
                return false;
            if (j > 0 && t[i][j - 1] == 'B')
                return false;
            if (j < m - 1 && t[i][j + 1] == 'B')
                return false;
        }
    return true;
}
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> s[i];
    cout << (check1() || check2() ? "Yes" : "No");
    return 0;
}
```

---


# [GCJ 2015 #2] Pegman

## 题目描述

在使用 Google 街景时，你可能曾经拖动并放下过角色 Pegman。今天，一个调皮的用户要把 Pegman 放在一个 $R$ 行 $C$ 列的单位格矩形网格中的某个格子里。这个网格中的每个格子可能是空白的，也可能标有一个箭头，箭头指向四个可能的方向之一：上、右、下或左。

当 Pegman 被放在一个格子上时，如果该格子是空白的，Pegman 会永远静止不动。然而，如果该格子上有一个箭头，Pegman 会开始朝那个方向行走。在行走过程中，每当他遇到空白格子时，他会继续保持当前方向前进；但每当他遇到另一个箭头时，他会转向该箭头指示的方向，然后继续行走。

你知道 Pegman 可能会一直在网格上快乐地循环行走，但也有可能 Pegman 会走出网格的边界！你可以通过改变一个或多个箭头的方向来防止这种情况发生，从而拯救他。（每个箭头的方向只能更改为另外三种可能的方向；只能更改箭头，不能添加或移除箭头。）

你需要求出，最少需要更改多少个箭头的方向，才能确保无论 Pegman 最初被放在网格的哪个位置，他都不会走出网格边界？如果无论怎么更改箭头都无法保证这一点，则输出 IMPOSSIBLE。

## 说明/提示

**样例解释**

在第 1 组样例中，无论 Pegman 被放在哪里，他都一定会走出网格的上边界。你可以通过将最上面的箭头改为向下，从而让 Pegman 在这两个箭头之间来回循环，避免走出网格。

在第 2 组样例中，无论 Pegman 被放在哪里，他都会顺时针绕着网格循环行走，无需更改任何箭头。

在第 3 组样例中，调皮的用户可能会把 Pegman 放在网格中央的上箭头上，这样他会开始行走并最终走出网格的上边界。更改这个箭头的方向也无济于事：他只会从别的边界走出去。

在第 4 组样例中，唯一的起始格子是空白格，Pegman 会永远静止，不会有危险。

**数据范围**

- $1 \leq T \leq 100$。

**小数据集（5 分）**

- 时间限制：5 秒。
- $1 \leq R, C \leq 4$。

**大数据集（10 分）**

- 时间限制：10 秒。
- $1 \leq R, C \leq 100$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2 1
^
^
2 2
>v
^<
3 3
...
.^.
...
1 1
.```

### 输出

```
Case #1: 1
Case #2: 0
Case #3: IMPOSSIBLE
Case #4: 0```

# 题解

## 作者：bayiran (赞：3)

随机跳题来的。  
第一眼：时限 $10s$？走了走了。  
第二眼：橙题？？？

## 思路
虽然都是模拟，但我感觉我的模拟不太正常。

1. 对于每个箭头，我们需要确保它不会导致 Pegman 无限行走最终走出网格，因此模拟向这个箭头的方向行走。如果箭头指向的方向会导致 Pegman 走出网格，则需要修改其方向。
2. 对于上一步判定需要修改的箭头，尝试将其方向改为其他三个方向，确保修改后的方向不会导致 Pegman 走出网格。
3. 无解条件：只要有一个箭头无论如何修改都不能使 Pegman 一直在网格内，就无解。

## 代码
（勾石码风请谅解）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};
const char dir[] = {'^', '>', 'v', '<'};
int solve(){
    int R,C;
    cin>>R>>C;
    string grid[R];
    for(int i=0;i<R;i++){
        cin>>grid[i];
    }
    int res=0;
    for(int i=0;i<R;i++){
        for (int j=0;j<C;j++){
            if(grid[i][j] == '.'){
                continue;
            }
            int d = -1;
            for(int k=0;k<4;k++){
                if(grid[i][j] == dir[k]){
                    d = k;
                    break;
                }
            }
            int x = i + dx[d];
            int y = j + dy[d];
            bool nc = 1;
            while(x>=0&&x<R && y>=0&&y<C){
                if(grid[x][y] != '.'){
                    nc = 0;
                    break;
                }
                x += dx[d];
                y += dy[d];
            }
            if(nc){
                bool found = 0;
                for(int k=0;k<4;k++){
                    if(k==d){
                        continue;
                    }
                    x = i + dx[k];
                    y = j + dy[k];
                    while(x>=0&&x<R && y>=0&&y<C){
                        if(grid[x][y] != '.'){
                            found = 1;
                            break;
                        }
                        x += dx[k];
                        y += dy[k];
                    }
                    if(found){
                        break;
                    }
                }
                if(!found){
                    return -1;
                }
                res++;
            }
        }
    }
    return res;
}

int main() {
    int T;
    cin>>T;
    for(int t=1;t<=T;t++){
        int ans = solve();
        cout<<"Case #"<<t<<": ";
        cout<<ans<<endl;
    }
    return 0;
}

```

拒绝代码复制，共创美好洛谷。

---

## 作者：Finner_forgeter (赞：3)

# P13224题解

[题目传送门](https://www.luogu.com.cn/problem/P13224)

~~这是一道非常大大大模拟。就像题里说的那样，一共四种箭头，所以几乎一样的代码要打四遍。~~

**思路：** 查询每个箭头，如果在它方向上有箭头，那么好，过了，问题交给下一个箭头。

如果没有呢，指向的方向上没有就让 $ans$ 自增 $1$，如果四个方向都没有，那就直接输出 `IMPOSSIBLE`。

依次遍历每一个箭头，知道完成对 $ans$ 的处理。

但是一定要注意，如果用函数处理的话最后一并输出，最好不要在函数里输出，很容易弄乱。

[错误示范](https://www.luogu.com.cn/record/223904824)

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int T,r,c,ans=0,fff=0;
char a[105][105];
bool f[105][105];
void check(int q,int x,int y){
	bool flag1=1,flag2=1,flag3=1,flag4=1;
	if(a[x][y]=='>'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			cout<<"Case #"<<q<<": "<<"IMPOSSIBLE"<<endl;
			fff=1;
		}else{
			if(flag1)ans++;
		}
	}else if(a[x][y]=='<'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			cout<<"Case #"<<q<<": "<<"IMPOSSIBLE"<<endl;
			fff=1;
		}else{
			if(flag2)ans++;
		}
	}else if(a[x][y]=='v'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			cout<<"Case #"<<q<<": "<<"IMPOSSIBLE"<<endl;
			fff=1;
		}else{
			if(flag3)ans++;
		}
	}else if(a[x][y]=='^'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			cout<<"Case #"<<q<<": "<<"IMPOSSIBLE"<<endl;
			fff=1;
		}else{
			if(flag4)ans++;
		}
	}
}
signed main(){
	cin>>T;
	for(int q=1;q<=T;q++){
		int ff=0;
		cin>>r>>c;
		for(int i=1;i<=r;i++){
			for(int j=1;j<=c;j++){
				cin>>a[i][j];
				if(a[i][j]=='^'||a[i][j]=='>'||a[i][j]=='<'||a[i][j]=='v')
				f[i][j]=1,ff++;
			}
		}for(int i=1;i<=r;i++){
			for(int j=1;j<=c;j++){
				if(f[i][j]==1){
					check(q,i,j);
				}
			}
		}if(!fff)
		cout<<"Case #"<<q<<": "<<ans<<endl;
		memset(a,0,sizeof(a));
		memset(f,0,sizeof(f));
		ans=0,fff=0;
	}
	return 0;
}
```

调到最后一起输出就行了。

AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,r,c,ans=0,fff=0;
char a[105][105];
bool f[105][105];
void check(int q,int x,int y){
	bool flag1=1,flag2=1,flag3=1,flag4=1;
	if(a[x][y]=='>'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			fff=1;
		}else{
			if(flag1)ans++;
		}
	}else if(a[x][y]=='<'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			fff=1;
		}else{
			if(flag2)ans++;
		}
	}else if(a[x][y]=='v'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			fff=1;
		}else{
			if(flag3)ans++;
		}
	}else if(a[x][y]=='^'){
		for(int i=y+1;i<=c;i++){
			if(f[x][i]==1)flag1=0;
		}for(int i=1;i<y;i++){
			if(f[x][i]==1)flag2=0;
		}for(int i=x+1;i<=r;i++){
			if(f[i][y]==1)flag3=0;
		}for(int i=1;i<x;i++){
			if(f[i][y]==1)flag4=0;
		}if(flag1&&flag2&&flag3&&flag4){
			fff=1;
		}else{
			if(flag4)ans++;
		}
	}
}
int main(){
	cin>>T;
	for(int q=1;q<=T;q++){
		int ff=0;
		cin>>r>>c;
		for(int i=1;i<=r;i++){
			for(int j=1;j<=c;j++){
				cin>>a[i][j];
				if(a[i][j]=='^'||a[i][j]=='>'||a[i][j]=='<'||a[i][j]=='v')
				f[i][j]=1,ff++;
			}
		}for(int i=1;i<=r;i++){
			for(int j=1;j<=c;j++){
				if(f[i][j]==1){
					check(q,i,j);
				}
			}
		}if(!fff)cout<<"Case #"<<q<<": "<<ans<<endl;
		else cout<<"Case #"<<q<<": "<<"IMPOSSIBLE"<<endl;
		memset(a,0,sizeof(a));
		memset(f,0,sizeof(f));
		ans=0,fff=0;
	}
	return 0;
}
```

代码好长，点个赞再走呗。

---

## 作者：__F__ (赞：3)

## 题目大意  
通过更改箭头的方向让 Pegman 无论怎样都不会走出网格的边界，输出更改箭头的次数。若无论怎样更改都有可能会走出网格的边界，输出 `IMPOSSIBLE`。  
## 思路分析  
既然我们要让 Pegman 不会走出方格网，那我们就要保证箭头不会指向方格网外（也就是说，要指向其他箭头）。如果指向了方格网外，就对其进行更改，看看另外三个方向会不会指向方格网外。如果另外三个方向能指向其他箭头，我们就进行一次更改。若另外三个方向也只会指向网格外，那就输出 `IMPOSSIBLE`。  
关于箭头的更改，我们并不用在意它到底会指向剩下三个方向的哪一个方向，只需要知道它需要被更改就可以了。  
## [AC](https://www.luogu.com.cn/record/223920812) code  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T;
int R,C;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
	cin>>T;
	for(int i=1;i<=T;i++){
		cin>>R>>C;
		char a[120][120];
		int jsq=0;
		for(int j=1;j<=R;j++){
			for(int k=1;k<=C;k++){
				cin>>a[j][k];
				if(a[j][k]!='.'){//jsq用来记录箭头出现的次数 
					jsq++;
				}
			}
		}
		if(jsq==0){//特殊情况：如果没有箭头，直接输出0 
			cout<<"Case #"<<i<<": "<<jsq<<"\n";
			continue;
		}
		bool ff,f;
		int ans=0;
		for(int j=1;j<=R;j++){
			for(int k=1;k<=C;k++){
				if(a[j][k]=='.'){
					f=1,ff=0;
					continue;
				}
				f=0;
				ff=0;
				if(a[j][k]=='>'){//箭头向右的情况 
					for(int kk=k+1;kk<=C;kk++){ 
						if(a[j][kk]!='.'){//如果它右面有箭头 
							f=1;//记录一下，不用修改 
							break; 
						}
					}
					if(!f){//如果右面无箭头
						for(int kk=1;kk<k;kk++){//向左找 
							if(a[j][kk]!='.'){
								ff=1;//有箭头就做个标记，说明可以做修改，下同 
							}
						}
						for(int jj=1;jj<j;jj++){//向上找 
							if(a[jj][k]!='.'){
								ff=1;
							}
						}
						for(int jj=j+1;jj<=R;jj++){//向下找 
							if(a[jj][k]!='.'){
								ff=1; 
							}
						}
					}
					if(f==0&&ff==0) break;//如果右面无箭头，其他三个方向也没有，说明不可能，直接跳出 
				}
				//后面的下，左，上三种箭头方法同上 
				if(a[j][k]=='v'){
					for(int jj=j+1;jj<=R;jj++){
						if(a[jj][k]!='.'){
							f=1;
							break; 
						}
					}
					if(!f){ 
						for(int kk=1;kk<k;kk++){
							if(a[j][kk]!='.'){
								ff=1;
							}
						}
						for(int jj=1;jj<j;jj++){
							if(a[jj][k]!='.'){
								ff=1;
							}
						}
						for(int kk=k+1;kk<=C;kk++){
							if(a[j][kk]!='.'){
								ff=1;
							}
						}
					}
					if(f==0&&ff==0) break;
				}
				if(a[j][k]=='<'){
					for(int kk=1;kk<k;kk++){
						if(a[j][kk]!='.'){
							f=1;
							break; 
						}
					}
					if(!f){
						for(int kk=k+1;kk<=C;kk++){
							if(a[j][kk]!='.'){
								ff=1;
							}
						}
						for(int jj=1;jj<j;jj++){
							if(a[jj][k]!='.'){
								ff=1; 
							}
						}
						for(int jj=j+1;jj<=R;jj++){
							if(a[jj][k]!='.'){
								ff=1;
							}
						}
					} 
					if(f==0&&ff==0) break;
				}
				if(a[j][k]=='^'){
					for(int jj=1;jj<j;jj++){
						if(a[jj][k]!='.'){
							f=1;
							break; 
						}
					}
					if(!f){
						for(int kk=1;kk<k;kk++){
							if(a[j][kk]!='.'){
								ff=1;
							}
						}
						for(int kk=1+k;kk<=C;kk++){
							if(a[j][kk]!='.'){
								ff=1;
							}
						}
						for(int jj=j+1;jj<=R;jj++){
							if(a[jj][k]!='.'){
								ff=1;
							}
						}
					}
					if(f==0&&ff==0) break;
				}
				if(ff==1) ans++;//如果做出了修改，修改次数加一 
			}
			if((ff==0&&f==0)){ cout<<"Case #"<<i<<": IMPOSSIBLE"<<"\n";break;}//如果四个方向都没有箭头，输出不可能 
		}
		if(f==1||(f==0&&ff==1))  cout<<"Case #"<<i<<": "<<ans<<"\n";//箭头的方向本来就有箭头或修改后的方向有箭头，输出修改次数 
	}
	return 0;
} 
```

---

## 作者：yongqian123 (赞：1)

## 题目分析
如果朝向前方没有箭头的方向走，那么这样走一定会走出去。必须调整。以下字符数组 $a$ 表示每个格子的箭头情况；布尔数组 $l$ 表示往左走不会走出去，$r$ 表示往右走不会走出去，$u$ 表示往上走不会走出去，$d$ 表示往下走不会走出去。

那么当 $\forall\not l_{i,j},\not r_{i,j},\not u_{i,j},\not d_{i,j}(1\le i\le C,1\le j\le R)$ 时输出 `IMPOSSIBLE`。

预处理 $l,r,u,d$。

```cpp
for (ll i = 1; i <= R; i++) for (ll j = 1; j <= C; j++) l[i][j] = j > 1 && (a[i][j - 1] != '.' || l[i][j - 1]), u[i][j] = i > 1 && (a[i - 1][j] != '.' || u[i - 1][j]);
for (ll i = R; i >= 1; i--) for (ll j = C; j >= 1; j--) r[i][j] = j < C && (a[i][j + 1] != '.' || r[i][j + 1]), d[i][j] = i < R && (a[i + 1][j] != '.' || d[i + 1][j]);
```

定义类 `node` 表示是箭头。定义 `vector<node> e` 表示是箭头的格子集合。

```cpp
class node{
public:
	ll i, j;
	char *c;
	bool *l, *r, *u, *d;
	node(): i(0), j(0), c(NULL), l(NULL), r(NULL), u(NULL), d(NULL){}
	node(ll _i, ll _j): i(_i), j(_j), c(&a[_i][_j]), l(&::l[_i][_j]), r(&::r[_i][_j]), u(&::u[_i][_j]), d(&::d[_i][_j]){}
};
vector<node> e;

```

可以省一点时间。这时输入：

```cpp
e.clear();
cin >> R >> C;
for (ll i = 1; i <= R; i++) for (ll j = 1; j <= C; j++){
	cin >> a[i][j];
	if (a[i][j] != '.') e.push_back(node(i, j));
}

```

放一个计数器 $s$。这时计数、输出：

```cpp
s = 0;
for (node it : e){
	if (!*it.l && !*it.r && !*it.u && !*it.d){cout << "IMPOSSIBLE\n"; return;}
	if (*it.c == '<' && !*it.l || *it.c == '>' && !*it.r || *it.c == '^' && !*it.u || *it.c == 'v' && !*it.d) s++;
}cout << s << '\n';

```

完结撒花！

---

## 作者：Confused_Konjac (赞：1)

## 题目要求
题目让我们修改箭头的方向使把 Pegman 扔到网格里的任意位置他都走不出去。

## 方法
既然算法标签里面有模拟，那就超级无敌大模拟吧！

数据不大，所以我们完全可以枚举把  Pegman 扔到每个位置，模拟他走路的过程，要走出去了就改变一下方向。最后统计改方向最少的方案输出。

献上我的代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MX = 105;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T;
    cin >> T;
    
    for (int t = 1; t <= T; t++) {
        int R, C;
        cin >> R >> C;
        
        char g[MX][MX];
        for (int i = 0; i < R; i++) {
            cin >> g[i];
        }
        
        int u[MX][MX][2], d[MX][MX][2], l[MX][MX][2], r[MX][MX][2];
        
        memset(u, -1, sizeof(u));
        memset(d, -1, sizeof(d));
        memset(l, -1, sizeof(l));
        memset(r, -1, sizeof(r));
        
        for (int j = 0; j < C; j++) {
            for (int i = 1; i < R; i++) {
                if (g[i-1][j] != '.') {
                    u[i][j][0] = i-1;
                    u[i][j][1] = j;
                } else {
                    u[i][j][0] = u[i-1][j][0];
                    u[i][j][1] = u[i-1][j][1];
                }
            }
        }
        
        for (int j = 0; j < C; j++) {
            for (int i = R-2; i >= 0; i--) {
                if (g[i+1][j] != '.') {
                    d[i][j][0] = i+1;
                    d[i][j][1] = j;
                } else {
                    d[i][j][0] = d[i+1][j][0];
                    d[i][j][1] = d[i+1][j][1];
                }
            }
        }
        
        for (int i = 0; i < R; i++) {
            for (int j = 1; j < C; j++) {
                if (g[i][j-1] != '.') {
                    l[i][j][0] = i;
                    l[i][j][1] = j-1;
                } else {
                    l[i][j][0] = l[i][j-1][0];
                    l[i][j][1] = l[i][j-1][1];
                }
            }
        }
        
        for (int i = 0; i < R; i++) {
            for (int j = C-2; j >= 0; j--) {
                if (g[i][j+1] != '.') {
                    r[i][j][0] = i;
                    r[i][j][1] = j+1;
                } else {
                    r[i][j][0] = r[i][j+1][0];
                    r[i][j][1] = r[i][j+1][1];
                }
            }
        }
        
        int c = 0;
        bool f = false;
        
        for (int i = 0; i < R && !f; i++) {
            for (int j = 0; j < C && !f; j++) {
                if (g[i][j] == '.') continue;
                
                char dir = g[i][j];
                bool s = false;
                bool fix = false;
                
                if (dir == '^') {
                    s = (u[i][j][0] != -1);
                } else if (dir == '>') {
                    s = (r[i][j][0] != -1);
                } else if (dir == 'v') {
                    s = (d[i][j][0] != -1);
                } else if (dir == '<') {
                    s = (l[i][j][0] != -1);
                }
                
                if (s) continue;
                
                fix = (u[i][j][0] != -1) || 
                      (r[i][j][0] != -1) || 
                      (d[i][j][0] != -1) || 
                      (l[i][j][0] != -1);
                
                if (fix) {
                    c++;
                } else {
                    f = true;
                }
            }
        }
        
        cout << "Case #" << t << ": ";
        if (f) {
            cout << "IMPOSSIBLE" << endl;
        } else {
            cout << c << endl;
        }
    }
    
    return 0;
}
```

---

## 作者：hlb44 (赞：0)

大模拟。

我们只需要对于每个守卫，判断其所在行和列是否有可监视的目标，若存在任一守卫的行和列均无目标，则网格非法。

其次，对于合法网格中的每个守卫，检查其当前朝向是否能直接监视到目标。若不能，则需要调整方向，计数器加 $1$。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool check1(const vector<string>&grid,int i,int j,int R,int C) {
	for(int r=i-1; r>=0; r--) {
		if(grid[r][j]!='.')return true;
	}
	for(int r=i+1; r<R; r++) {
		if(grid[r][j]!='.')return true;
	}
	for(int c=j-1; c>=0; c--) {
		if(grid[i][c]!='.')return true;
	}
	for(int c=j+1; c<C; c++) {
		if(grid[i][c]!='.')return true;
	}
	return false;
}
bool check2(const vector<string>&grid,int i,int j,char dir,int R,int C) {
	if(dir=='^') {
		for(int r=i-1; r>=0; r--) {
			if(grid[r][j]!='.')return true;
		}
	}
	else if(dir=='v') {
		for(int r=i+1; r<R; r++) {
			if(grid[r][j]!='.')return true;
		}
	}
	else if(dir=='<') {
		for(int c=j-1; c>=0; c--) {
			if(grid[i][c]!='.')return true;
		}
	}
	else if(dir=='>') {
		for(int c=j+1; c<C; c++) {
			if(grid[i][c]!='.')return true;
		}
	}
	return false;
}
int main() {
	int T;
	cin>>T;
	for(int t=1; t<=T; t++) {
		int R,C;
		cin>>R>>C;
		vector<string>grid(R);
		for(int i=0; i<R; i++) {
			cin>>grid[i];
		}
		bool f=true;
		int cl=0;
		for(int i=0; i<R&&f; i++) {
			for(int j=0; j<C&&f; j++) {
				char c=grid[i][j];
				if(c=='.')continue;
				if(!check1(grid,i,j,R,C)) {
					f=false;
					break;
				}
				if(!check2(grid,i,j,c,R,C)) {
					cl++;
				}
			}
		}
		if(f) {
			cout<<"Case #"<<t<<": "<<cl<<endl;
		} else {
			cout<<"Case #"<<t<<": IMPOSSIBLE"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：lyh1190 (赞：0)

# [传送](https://www.luogu.com.cn/problem/P13224)
模拟题，按题意模拟即可。
#### 题目描述：
给定一个大小为 $r×c$ 的网格，网格中包含空白字符（`.`）和箭头字符（`^、v、<、>`）。Pegman 初始放置在网格的任意位置，如果在空白位置则静止不动，如果在箭头位置则按箭头方向移动，遇到箭头会改变方向。问最少需要更改多少个箭头的方向，才能确保无论 Pegman 最初被放在网格的哪个位置，他都不会走出网格边界？如果无论怎么更改箭头都无法保证这一点，则输出 `IMPOSSIBLE`。  
~~直接从题目中复制即可(*∩_∩*)~~。
#### 分析：
1. 对于每一行，若存在向右箭头（`>`），则必须存在向左箭头（`<`），反之亦然。这是因为如果某行只有向右箭头，Pegman 从该行的箭头出发会一直向右移动，最终走出网格边界。同理对于列，若存在向下箭头（`v`），则必须存在向上箭头（`^`），反之亦然。
2. 然后通过检查每一行和每一列中箭头的分布情况，统计需要修改箭头方向的行数和列数，以此确定最少的修改次数。同时，需要特殊处理一些无法通过修改箭头方向来满足条件的情况。
## AC Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int T,r,c,ans=0,sum=0;
char a[105][105];
bool f[105][105];
void find(int t,int x,int y)
{
	bool ff1=1,ff2=1,ff3=1,ff4=1;
	if(a[x][y]=='>')
	{
		for(int i=y+1;i<=c;i++)
			if(f[x][i]==1)
				ff1=0;
		for(int i=1;i<y;i++)
			if(f[x][i]==1)
				ff2=0;
		for(int i=x+1;i<=r;i++)
			if(f[i][y]==1)
				ff3=0;
		for(int i=1;i<x;i++)
			if(f[i][y]==1)
				ff4=0;
		if(ff1&&ff2&&ff3&&ff4)
			sum=1;
		else
			if(ff1)
				ans++;
	}
	else if(a[x][y]=='<')
	{
		for(int i=y+1;i<=c;i++)
			if(f[x][i]==1)
				ff1=0;
		for(int i=1;i<y;i++)
			if(f[x][i]==1)
				ff2=0;
		for(int i=x+1;i<=r;i++)
			if(f[i][y]==1)
				ff3=0;
		for(int i=1;i<x;i++)
			if(f[i][y]==1)
				ff4=0;
		if(ff1&&ff2&&ff3&&ff4)
			sum=1;
		else
			if(ff2)
				ans++;
	}
	else if(a[x][y]=='v')
	{
		for(int i=y+1;i<=c;i++)
			if(f[x][i]==1)
				ff1=0;
		for(int i=1;i<y;i++)
			if(f[x][i]==1)
				ff2=0;
		for(int i=x+1;i<=r;i++)
			if(f[i][y]==1)
				ff3=0;
		for(int i=1;i<x;i++)
			if(f[i][y]==1)
				ff4=0;
		if(ff1&&ff2&&ff3&&ff4)
			sum=1;
		else
			if(ff3)
				ans++;
	}
	else if(a[x][y]=='^')
	{
		for(int i=y+1;i<=c;i++)
			if(f[x][i]==1)
				ff1=0;
		for(int i=1;i<y;i++)
			if(f[x][i]==1)
				ff2=0;
		for(int i=x+1;i<=r;i++)
			if(f[i][y]==1)
				ff3=0;
		for(int i=1;i<x;i++)
			if(f[i][y]==1)
				ff4=0; 
		if(ff1&&ff2&&ff3&&ff4)
			sum=1;
		else
			if(ff4)
				ans++;
	}
}
int main()
{
	cin>>T;
	for(int t=1;t<=T;t++)
	{
		int ff=0;
		cin>>r>>c;
		for(int i=1;i<=r;i++)
			for(int j=1;j<=c;j++)
			{
				cin>>a[i][j];
				if(a[i][j]=='^'||a[i][j]=='>'||a[i][j]=='<'||a[i][j]=='v')
				f[i][j]=1,ff++;
			}
		for(int i=1;i<=r;i++)
			for(int j=1;j<=c;j++)
				if(f[i][j]==1)
					find(t,i,j);
		if(!sum)
			cout<<"Case #"<<t<<": "<<ans<<endl;
		else
			cout<<"Case #"<<t<<": "<<"IMPOSSIBLE"<<endl;
		memset(a,0,sizeof(a));
		memset(f,0,sizeof(f));
		ans=0,sum=0;
	}
	return 0;
}
```
# 谢谢观看!
![](https://fecdn.luogu.com.cn/luogu/ac-congrats.png?ce96b99faabe0d91e25e00917ef494af)

---

## 作者：yangdezuo (赞：0)

## 解析
### 题目大意
Pegman 从箭头格子开始，按照箭头方向行走。遇到空白格子时继续前进，遇到箭头时则转向新箭头的方向。我们需要确保所有箭头都不会导致 Pegman 走出边界。


### 方法
这显然是一道大模拟。

我们需要确保无论 Pegman 从网格中的哪个箭头开始行走，他都不会走出网格边界。我们可以通过改变一些箭头的方向来实现这一目标，目标是找到最小改变次数。如果无论如何改变都无法避免 Pegman 走出边界，则输出 IMPOSSIBLE。

将问题转化，就会变成当一个箭头是安全的，如果沿着它的方向行走会在网格内遇到另一个箭头，而不是边界。

那么，我们可以预处理：为每个格子预处理四个方向上第一个非空白格子的位置。如果某个方向上没有非空白格子即全是空白直到边界，则该方向不安全。

接着，对于每个箭头，检查其原始方向是否安全。如果不安全，则检查其他三个方向是否有安全的。如果至少有一个安全方向，则可以改变方向；否则输出 IMPOSSIBLE。

最后我们统计所有箭头中需要改变方向的次数，就结束啦。


## 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=105;
int t,r,c,up[N][N][2],down[N][N][2],lt[N][N][2],rt[N][N][2];
string a[N];
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>t;
	for(int o=1;o<=t;o++){
		cin>>r>>c;
		for(int i=0;i<r;i++) cin>>a[i];
		memset(up,-1,sizeof(up));
		memset(down,-1,sizeof(down));
		memset(lt,-1,sizeof(lt));
		memset(rt,-1,sizeof(rt));
		for(int j=0;j<c;j++)
			for(int i=1;i<r;i++)
				if(a[i-1][j]!='.') up[i][j][0]=i-1,up[i][j][1]=j;
				else up[i][j][0]=up[i-1][j][0],up[i][j][1]=up[i-1][j][1];
		for(int j=0;j<c;j++)
			for(int i=r-2;i>=0;i--)
				if(a[i+1][j]!='.') down[i][j][0]=i+1,down[i][j][1]=j;
				else down[i][j][0]=down[i+1][j][0],down[i][j][1]=down[i+1][j][1];
		for(int i=0;i<r;i++)
			for(int j=1;j<c;j++)
				if(a[i][j-1]!='.') lt[i][j][0]=i,lt[i][j][1]=j-1;
				else lt[i][j][0]=lt[i][j-1][0],lt[i][j][1]=lt[i][j-1][1];
		for(int i=0;i<r;i++)
			for(int j=c-2;j>=0;j--)
				if(a[i][j+1]!='.') rt[i][j][0]=i,rt[i][j][1]=j+1;
				else rt[i][j][0]=rt[i][j+1][0],rt[i][j][1]=rt[i][j+1][1];
		int ans=0;
		bool ps=false;//是否有解
		for(int i=0;i<r;i++){
			for(int j=0;j<c;j++){
				char ch=a[i][j];
				if(ch=='.') continue;
				bool s1=false,s2=false;//判断箭头方向是否安全
				if(ch=='^'){
					if(up[i][j][0]!=-1&&up[i][j][1]!=-1) s1=true;
					if(rt[i][j][0]!=-1&&rt[i][j][1]!=-1) s2=true;
					if(down[i][j][0]!=-1&&down[i][j][1]!=-1) s2=true;
					if(lt[i][j][0]!=-1&&lt[i][j][1]!=-1) s2=true;
				}
				else if(ch=='>'){
					if(up[i][j][0]!=-1&&up[i][j][1]!=-1) s2=true;
					if(rt[i][j][0]!=-1&&rt[i][j][1]!=-1) s1=true;
					if(down[i][j][0]!=-1&&down[i][j][1]!=-1) s2=true;
					if(lt[i][j][0]!=-1&&lt[i][j][1]!=-1) s2=true;
				}
				else if(ch=='v'){
					if(up[i][j][0]!=-1&&up[i][j][1]!=-1) s2=true;
					if(rt[i][j][0]!=-1&&rt[i][j][1]!=-1) s2=true;
					if(down[i][j][0]!=-1&&down[i][j][1]!=-1) s1=true;
					if(lt[i][j][0]!=-1&&lt[i][j][1]!=-1) s2=true;
				}
				else{
					if(up[i][j][0]!=-1&&up[i][j][1]!=-1) s2=true;
					if(rt[i][j][0]!=-1&&rt[i][j][1]!=-1) s2=true;
					if(down[i][j][0]!=-1&&down[i][j][1]!=-1) s2=true;
					if(lt[i][j][0]!=-1&&lt[i][j][1]!=-1) s1=true;
				}
				if(s1) continue;
				if(s2) ans++;
				else{
					ps=true;
					break;
				}
			}
			if(ps) break;
		}
		cout<<"Case #"<<o<<": ";
		if(ps) cout<<"IMPOSSIBLE\n";
		else cout<<ans<<'\n';
	}
}
```

---

## 作者：YuTinMin (赞：0)

## 思路

题目要求要让 Pegman 在任意一个起点走，都要走不出这个网格，可以的话就输出需要更改的箭头的数量，不行的话就输出 `IMPOSSIBLE`。

我们可以先写一个 check 函数，判断是否存在一个路径会走出去，不会就返回 `false`，会走出去就计算需要更改多少个箭头。

尝试改成 $4$ 个方向的箭头，看会不会出去，不会 $res$ 就加加，会的话就是输出 `IMPOSSIBLE`。

~~记得返回值，我第一次就忘记返回值了。~~

最后就输出就行了。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
char g[N][N], dirs[6] = {'^',  'v', '<', '>'};
int r, c;

bool check(int x, int y, char dir) 
{
    int dx = 0, dy = 0;
    if(dir == '^') dx = -1;
    else if(dir == 'v') dx = 1; //注意，不要弄反了，和数学不一样
    else if(dir == '<') dy = -1;
    else if(dir == '>') dy = 1;
    
    x += dx;
    y += dy;
    while(x >= 1 && x <= r && y >= 1 && y <= c)
	{  
        if(g[x][y] != '.') return false;  
        x += dx;
        y += dy;
    }
    return true; 
}

int idk()
{
	int res = 0;
	for(int i = 1;i <= r;i++)
	{
		for(int j = 1;j <= c;j++)
		{
			if(g[i][j] == '.') 
				continue;
			bool flag = false;
			if(check(i, j, g[i][j]))
			{
				for(int k = 0;k < 4;k++)
				{
					if(dirs[k] == g[i][j]) continue;
					if(!check(i, j, dirs[k]))
					{
						flag = true;
						break;
					}
				}
				if(!flag) return -1;
				res++;
			} 
		}
	}
	return res; //记得返回值
}

int main()
{
	
	int t, ss = 1;
	cin >> t;
	while(t--)
	{
		cin >> r >> c;
		for(int i = 1;i <= r;i++)
		{
			for(int j = 1;j <= c;j++)
			{
				cin >> g[i][j];
			}
		}
		int ans = idk();
		printf("Case #%d: ", ss++);
		if(ans == -1) cout << "IMPOSSIBLE \n";
		else cout << ans << endl; 
	}
	
	return 0;
} 
```

---

## 作者：Little_d (赞：0)

## 思路
首先，找到每一个箭头，先假设这个箭头有问题，需要更改，然后判断这个箭头可以想哪些方向改，如果可以改到原来的位置，也就是不该，那么答案不需要累加，否则，判断剩下的方向中，那些可以走，如果可以走，答案累加一次，如果一个方向都走不了，说明无解。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int _;
int n,m;
char a[105][105];
int vis[4];
int ans;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); 
    cin>>_;
    int temp=_;
    while(_--){
        ans=0;
        int f=0;
        cin>>n>>m;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                cin>>a[i][j];
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(a[i][j]=='.')continue;
                vis[0]=vis[1]=vis[2]=vis[3]=0;
                for(int k=j+1;k<=m;k++){
                    if(a[i][k]!='.'){
                        vis[0]=1;
                        break;
                    }
                }
                for(int k=j-1;k>=1;k--){
                    if(a[i][k]!='.'){
                        vis[1]=1;
                        break;
                    }
                }
                for(int k=i+1;k<=n;k++){
                    if(a[k][j]!='.'){
                        vis[2]=1;
                        break;
                    }
                }
                for(int k=i-1;k>=1;k--){
                    if(a[k][j]!='.'){
                        vis[3]=1;
                        break;
                    }
                }
                int id;
                if(a[i][j]=='>')id=0;
                if(a[i][j]=='<')id=1;
                if(a[i][j]=='v')id=2;
                if(a[i][j]=='^')id=3;
                if(vis[id]==1)continue;
                bool flag=true;
                for(int k=0;k<=3;k++){
                    if(k==id)continue;
                    if(vis[k]==1){
                        ans++;
                        flag=false;
                        break;
                    }
                }
                if(flag){
                    cout<<"Case #"<<temp-_<<": "<<"IMPOSSIBLE\n";
                    f=1;
                    break;
                }
            }
            if(f)break;
        }
        if(!f)cout<<"Case #"<<temp-_<<": "<<ans<<'\n';
    }
    return 0;
}
```

---


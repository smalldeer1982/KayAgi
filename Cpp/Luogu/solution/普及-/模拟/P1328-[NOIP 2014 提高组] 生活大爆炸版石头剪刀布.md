# [NOIP 2014 提高组] 生活大爆炸版石头剪刀布

## 题目背景

NOIP2014 提高组 D1T1

## 题目描述

石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。

![](https://cdn.luogu.com.cn/upload/pic/1346.png)

现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小 A 以 `石头-布-石头-剪刀-蜥蜴人-斯波克` 长度为 $6$ 的周期出拳,那么他的出拳序列就是 `石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-...`，而如果小 B 以 `剪刀-石头-布-斯波克-蜥蜴人` 长度为 $5$ 的周期出拳,那么他出拳的序列就是 `剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-...`。

已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。

## 说明/提示

对于 $100\%$ 的数据，$0 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 200$ 。


## 样例 #1

### 输入

```
10 5 6
0 1 2 3 4
0 3 4 2 1 0
```

### 输出

```
6 2
```

## 样例 #2

### 输入

```
9 5 5
0 1 2 3 4
1 0 3 2 4
```

### 输出

```
4 4```

# 题解

## 作者：Sinwind (赞：14)

# 1.分析

1. 将游戏所有可能的结果$($小$A$对小$B)$用数组存储起来$(game[5][5])$，第一个下标表示$A$出拳的情况，第二个下标表示$B$出拳的情况，数组存储的是出拳后的结果：$1$表示$A$赢，$B$输；$-1$表示$A$输，$B$赢；$0$表示平局；

2. 读入猜拳次数$N$，$A$的猜拳周期$N\_A$，$B$猜拳周期$N\_B$;

3. 循环$N$次，**模拟**游戏过程：

- $i$用来遍历$A$的猜拳周期，$j$遍历$B$的猜拳周期；

- 当$i\geq N\_A$，则遍历完一次周期，进入下一个周期，重置$(i=0)$；$j$同理，当$j\geq N\_B,j=0$；

- $circle\_A[i]$是此时A的出拳情况，$circle\_B[j]$是此时$B$的出拳情况，带入game数组中的得到游戏结果情况$int\space result = game[circle\_A[i]][circle\_B[j]]$；

- 若结果是$1$表示$A$赢，$B$输，$A$得$1$分$(score\_A++)$；$-1$表示$A$输，$B$赢，$B$得$1$分$(score\_B++)$；$0$表示平局，都不得分；

- $i,j$向后移动$(i++,j++)$。

4. 输出$A,B$的得分情况$(score\_A,score\_B)$。

# 2.代码

```cpp
#include <iostream>

using namespace std;

int N;                  //猜拳次数
int N_A;                //A的猜拳周期长度
int N_B;                //B的猜拳周期长度
int circle_A[205];      //A的猜拳周期
int circle_B[205];      //B的猜拳周期
int score_A = 0;		//A的得分
int score_B = 0;		//B的得分
int game[5][5] =        //游戏的结果情况，1表示A赢，-1表示A输，0表示平
{
	{0, -1, 1, 1, -1},
	{1, 0, -1, 1, -1},
	{-1, 1, 0, -1, 1},
	{-1, -1, 1, 0, 1},
	{1, 1, -1, -1, 0}
};

int main(void)
{
	cin >> N >> N_A >> N_B;
	
	for(int i = 0; i < N_A; i++)
	{
		cin >> circle_A[i];
	}
	for(int i = 0; i < N_B; i++)
	{
		cin >> circle_B[i];
	}
	
	int i = 0;          //遍历A的猜拳周期
	int j = 0;          //遍历B的猜拳周期
	while(N--)
	{
		if(i >= N_A)
		{
            i = 0;
		}
		if(j >= N_B)
		{
            j = 0;
		}
		
		//比较结果
		int result = game[circle_A[i]][circle_B[j]];
		if(result == 1)
		{
			score_A++;
		}
		else if(result == -1)
		{
			score_B++;
		}
		
		i++;
		j++;
	}
	
	cout << score_A << " " << score_B;
	
	return 0;
}
```


---

## 作者：Kawaii_qiuw (赞：8)

题面很好理解，不再赘述。

### 解题思路

主要分为 $4$ 个步骤。

#### Step one 储存游戏结果

```cpp
int n, a, b, p[205],q[205], x, y;
int k[5][5] = {{0, 0, 1, 1, 0},
             {1, 0, 0, 1, 0},
			   {0, 1, 0, 0, 1},
			   {0, 0, 1, 0, 1},
			   {1, 1, 0, 0, 0}};
```
#### Step two 输入

```cpp
cin >> n >> a >> b;
for (int i = 0; i < a; i++) 
	cin >> p[i];
for (int i = 0; i < b; i++) 
	cin >> q[i];
```

#### Step three 加减

```cpp
for (int i = 0; i < n; i++)
{
    x += k[p[i % a]][q[i % b]];
    y += k[q[i % b]][p[i % a]];
}
```

#### Step four 输出

```cpp
cout << x << ' ' << y;
```

看到了吗，我们把题目拆解成四个部分，每个部分都很简单、很基础。这题本身就不是很难，但如果遇到难题，思路也是将它拆解成几个你会写的代码，所谓的“难题”也就不难了，这和做数学题一个道理。

### 代码

```cpp
#include <iostream>
using namespace std;
int n, a, b, p[205],q[205], x, y;
int k[5][5] = {{0, 0, 1, 1, 0},
                {1, 0, 0, 1, 0},
			    {0, 1, 0, 0, 1},
			    {0, 0, 1, 0, 1},
			    {1, 1, 0, 0, 0}};
int main() {
	cin >> n >> a >> b;
	for (int i = 0; i < a; i++) 
		cin >> p[i];
	for (int i = 0; i < b; i++) 
		cin >> q[i];
	for (int i = 0; i < n; i++) {
    	x += k[p[i % a]][q[i % b]];
    	y += k[q[i % b]][p[i % a]];
	}
	cout << x << ' ' << y;
	return 0;
}
```

完结撒花。

---

## 作者：GSQ0829 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1328)

---
### 思路：
这个是题目给出的比赛结果表：
![](https://cdn.luogu.com.cn/upload/pic/1346.png)

我们可以根据这个写一个每个人的胜负情况的数组：
```cpp
int vs[5][5] = {{0, 0, 1, 1, 0}, {1, 0, 0, 1, 0}, {0, 1, 0, 0, 1}, {0, 0, 1, 0, 1}, {1, 1, 0, 0, 0}};
```
0 代表输，1 代表赢。

那么，我们为了比较两者的结果，我们可以用 $\bmod$ 来求出是数组中哪一项，然后用一个计数器计算分数。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 201;
int vs[5][5] = {{0, 0, 1, 1, 0}, {1, 0, 0, 1, 0}, {0, 1, 0, 0, 1}, {0, 0, 1, 0, 1}, {1, 1, 0, 0, 0}};
int a[MAXN], b[MAXN], n, na, nb, ans1 = 0, ans2 = 0;

int main() {
	cin >> n >> na >> nb;
	for (int i = 0; i < na; i++) cin >> a[i];
	for (int i = 0; i < nb; i++) cin >> b[i];
	for (int i = 0; i < n; i++) {
		ans1 += vs[a[i % na]][b[i % nb]];
		ans2 += vs[b[i % nb]][a[i % na]];
	}
	cout << ans1 << " " << ans2 << endl;
	return 0;
}

```

---

## 作者：ClV_Csy (赞：2)

# P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布
## 思路
本题就是大模拟，按题意写分支语句即可。
这里提供一个~~偷懒~~方法。  
众所周知，分支语句和循环语句需要大括号 `{` 和 `}` 配合。  
例如：  
```cpp
//例1
if (a == 1) {
	if (b == 2) {
		cout << "1";
	} else {
		cout << "2";
	}
} else {
	cout << "3";
}
```
以及
```cpp
//例2
int cnt;
for (int i = 1; i <= n; i++) {
	cnt = 0;
	for (int j = 1; j <= i; j++) {
		if (i % j == 0) {
			cnt++;
		}
	}
	cout << cnt << "\n";
}
```
但是 C++ 有一个不为人知的秘密，就是去括号。
- 条件 1：大括号内只有一行。
- 条件 2：大括号内的所有语句满足条件 1 或条件 2。

当大括号内满足条件 1 或条件 2 中的任意一个时，即可去掉括号。  
这样处理过后，例 1 即可写成
```cpp
if (a == 1)
	if (b == 2)
		cout << "1";
	else
		cout << "2";
else
	cout << "3";
```
例 2 即变成：
```cpp
int cnt;
for (int i = 1; i <= n; i++) {
	cnt = 0;
	for (int j = 1; j <= i; j++)
		if (i % j == 0)
			cnt++;
	cout << cnt << "\n";
}
```
其实还有一个技巧：可以把单行语句直接写到分支或循环语句之后。
例 1 变成：
```cpp
if (a == 1)
	if (b == 2) cout << "1";
	else cout << "2";
else cout << "3";
```
例 2：
```cpp
int cnt;
for (int i = 1; i <= n; i++) {
	cnt = 0;
	for (int j = 1; j <= i; j++) if (i % j == 0) cnt++;
	cout << cnt << "\n";
}
```
如果你觉得这样的例 2 太紧凑，可以这样：
```cpp
//例2
int cnt;
for (int i = 1; i <= n; i++) {
	cnt = 0;
	for (int j = 1; j <= i; j++)
		if (i % j == 0) cnt++;
	cout << cnt << "\n";
}
```
运用这些方法后，代码看起来的长度可以大大减小，并且也更美观了。
## 代码

```cpp
#include <iostream>
using namespace std;
int jud(int a, int b) {
	if (a == b) return 0;
	if (a == 0 && b == 1) return 1;
	if (a == 0 && b == 2) return 2;
	if (a == 0 && b == 3) return 2;
	if (a == 0 && b == 4) return 1;
	if (a == 1 && b == 0) return 2;
	if (a == 1 && b == 2) return 1;
	if (a == 1 && b == 3) return 2;
	if (a == 1 && b == 4) return 1;
	if (a == 2 && b == 0) return 1;
	if (a == 2 && b == 1) return 2;
	if (a == 2 && b == 3) return 1;
	if (a == 2 && b == 4) return 2;
	if (a == 3 && b == 0) return 1;
	if (a == 3 && b == 1) return 1;
	if (a == 3 && b == 2) return 2;
	if (a == 3 && b == 4) return 2;
	if (a == 4 && b == 0) return 2;
	if (a == 4 && b == 1) return 2;
	if (a == 4 && b == 2) return 1;
	if (a == 4 && b == 3) return 1;
}
int main()
{
	int n, na, nb;
	int a[210], b[210];
	int ca = 0, cb = 0;
	cin>> n >> na >> nb;
	for (int i = 1; i <= na; i++)
		cin >> a[i];
	for (int i = 1; i <= nb; i++)
		cin >> b[i];
	for (int i = 1; i <= n; i++) {
		int pa = i % na, pb = i % nb;
		if (pa == 0) pa = na;
		if (pb == 0) pb = nb;
		int p = jud(a[pa],b[pb]);
		if (p != 0) {
			if (p == 2) ca++;
			else if (p == 1) cb++;
		}
	}
	cout << ca << " " << cb;
	return 0;
}
```

---

## 作者：AG61949 (赞：1)

# 解题思路：模拟 
首先根据题目给出的部分表格计算出全部结果：


||0|1|2|3|4|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|平|输|赢|赢|输|
|1|赢|平|输|赢|输|
|2|输|赢|平|输|赢|
|3|输|输|赢|平|赢|
|4|赢|赢|输|输|平|

然后就是嵌套了：

```c
#include<stdio.h>
#define ac a[i % na]// i%na 表示一个周期内部循环 
#define bc b[i % nb]//同上
int main()
{
	int n, na, nb, i, j, a[500], b[500], as = 0, bs = 0;//n表示比赛次数，na nb表示周期长度，数组a b表示循环方式，as bs表示得分
	scanf("%d%d%d",&n,&na,&nb);
	for (i = 0;i < na;i++) {
		scanf("%d", &a[i]);
	}
	for (i = 0;i < nb;i++) {
		scanf("%d", &b[i]);
	}
	for (i = 0;i < n;i++) {
		if (ac == bc)continue;//如果相等，说明是平局，都不加分
		else if (ac == 0) {//往下就是根据表格写的模拟
			if (bc == 2 || bc == 3)as++;
			else bs++;
		}
		else if (ac == 1) {
			if (bc == 0 || bc == 3)as++;
			else bs++;
		}
		else if (ac == 2) {
			if (bc == 1 || bc == 4)as++;
			else bs++;
		}
		else if (ac == 3) {
			if (bc == 2 || bc == 4)as++;
			else bs++;
		}
		else {
			if (bc == 0 || bc == 1)as++;
			else bs++;
		}
	}
	printf("%d %d",as,bs);//输出两人得分
	return 0;
}
```

---

## 作者：陈嘉逸2012 (赞：1)

## 思路
纯模拟，没啥好讲的，按照题意模拟即可。

我们用 $moveA$ 表示 小 A 在第 $i$ 次出拳的手势，用 $moveB$ 表示 小 B 在第 $i$ 次出拳的手势。

以下是判断条件：
1. 若 $moveA=0$（剪刀）：
    * 若 $moveB=2$（布）：剪刀胜布
    * 若 $moveB=3$（蜥蜴人）：剪刀胜蜥蜴人
2. 若 $moveA=1$（石头）：
    * 若 $moveB=0$（剪刀）：石头胜剪刀
    * 若 $moveB=3$（蜥蜴人）：石头胜蜥蜴人
3. 若 $moveA=2$（布）：
    * 若 若 $moveB=1$（石头）：布胜石头
    * 若 $moveB=4$（斯波克）：布胜斯波克
4. 若 $moveA=3$（蜥蜴人）：
    * 若 $moveB=2$（布）：蜥蜴人胜布
    * 若 $moveB=4$（斯波克）：蜥蜴人胜斯波克
5. 若 $moveA=4$（斯波克）：
    * 若 $moveB=0$（剪刀）：斯波克胜剪刀
    * 若 $moveB=1$（石头）：斯波克胜石头
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int f1[205],f2[205],sa,sb;//分别表示：存储小 A 和小 B 的出拳序列，记录小 A 和小 B 的得分
int main(){
	int n,na,nb;cin>>n>>na>>nb;
	for(int i=0;i<na;i++) cin>>f1[i];
	for(int i=0;i<nb;i++) cin>>f2[i];
	for(int i=0;i<n;i++){
        int moveA=f1[i%na];//利用取模运算实现周期性
        int moveB=f2[i%nb];//同理
        if((moveA==0&&(moveB==2||moveB==3))||(moveA==1&&(moveB==0||moveB==3))||(moveA==2&&(moveB==1||moveB==4))||(moveA==3&&(moveB==2||moveB==4))||(moveA==4&&(moveB==0||moveB==1))) sa++;//按照题目条件判断
		else if(moveA!=moveB) sb++;//排除平局情况
    }
    cout<<sa<<' '<<sb;
}
```

---

## 作者：ridewind2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1328)

## 思路

![](https://cdn.luogu.com.cn/upload/pic/1346.png)

我们模拟 $n$ 次，每次判断胜负记录得分。
可以写一个函数来判断输赢：


```cpp
bool check(int x,int y){
	if(x==0){
		if(y==2||y==3)return 1;
		else return 0;
	}else if(x==1){
		if(y==0||y==3)return 1;
		else return 0;
	}else if(x==2){
		if(y==1||y==4)return 1;
		else return 0;
	}else if(x==3){
		if(y==2||y==4)return 1;
		else return 0;
	}else if(x==4){
		if(y==0||y==1)return 1;
		else return 0;
	}

}
```


注意：要在调用前判断他们出拳是否相同，如果相同，就不调用函数。

**由于 $na$ 和 $nb$ 不一定小于 $n$，所以他们出的不是 $a_{i}$ 和 $b_{i}$，$i$ 要分别对 $na$ 和 $nb$ 取模。**

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[210],b[210];
bool check(int x,int y){
	if(x==0){
		if(y==2||y==3)return 1;
		else return 0;
	}else if(x==1){
		if(y==0||y==3)return 1;
		else return 0;
	}else if(x==2){
		if(y==1||y==4)return 1;
		else return 0;
	}else if(x==3){
		if(y==2||y==4)return 1;
		else return 0;
	}else if(x==4){
		if(y==0||y==1)return 1;
		else return 0;
	}
}
int main(){
	int n,na,nb,x=0,y=0;
	cin>>n>>na>>nb;
	for(int i=0;i<na;i++)cin>>a[i];
	for(int i=0;i<nb;i++)cin>>b[i];
	for(int i=0;i<n;i++){
		if(a[i%na]==b[i%nb])continue;
		int f=check(a[i%na],b[i%nb]);
		if(f)x++;
		else y++;
	}
	cout<<x<<" "<<y;
	return 0;
}
```

---

## 作者：ShirasuAzusaSaikou (赞：1)

这是一道模拟题，我们只需要模拟过程就行。  
很容易看到对于甲乙双方，平是等价的，而甲对乙赢=乙对甲输。  
因此可以得出以下图表，然后再模拟周期即可。  
~~PS:其实可以把平理解成一条线，然后另外一边是相反的镜像。~~

||剪刀|石头|布|蜥蜴人|斯波克|
|:-:|:-:|:-:|:-:|:-:|:-:|
|剪刀|平|输|赢|赢|输|
|石头|赢|平|输|赢|输|
|布|输|赢|平|输|赢|
|蜥蜴人|输|输|赢|平|赢|
|斯波克|赢|赢|输|输|平|



```cpp
#include <bits/stdc++.h>
using namespace std;

//0:剪刀
//1:石头
//2:布
//3:蜥蜴人
//4。斯波克

const static int win(int a, int b){
    if(a == 0){
        if(b == 0) return 0;
        if(b == 1) return -1;
        if(b == 2) return 1;
        if(b == 3) return 1;
        if(b == 4) return -1;
    }
    else if(a == 1){
        if(b == 0) return 1;
        if(b == 1) return 0;
        if(b == 2) return -1;
        if(b == 3) return 1;
        if(b == 4) return -1;
    }
    else if(a == 2){
        if(b == 0) return -1;
        if(b == 1) return 1;
        if(b == 2) return 0;
        if(b == 3) return -1;
        if(b == 4) return 1;
    }
    else if(a == 3){
        if(b == 0) return -1;
        if(b == 1) return -1;
        if(b == 2) return 1;
        if(b == 3) return 0;
        if(b == 4) return 1;
    }
    else{
        if(b == 0) return 1;
        if(b == 1) return 1;
        if(b == 2) return -1;
        if(b == 3) return -1;
        if(b == 4) return 0;
    }
    return 0x3F3F3F3F;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, na, nb;
    cin >> n >> na >> nb;
    int a[na], b[nb];
    for(int i = 0; i < na; i++) cin >> a[i];
    for(int i = 0; i < nb; i++) cin >> b[i];
    int cnta = 0, cntb = 0, ia = 0, ib = 0;
    for(int i = 1; i <= n; i++){
        int flag = win(a[ia++ % na], b[ib++ % nb]); //模拟周期
        if(flag == 1){
            cnta++; //小A赢
        }
        if(flag == -1){
            cntb++; //小B赢
        }
    }
    cout << cnta << " " << cntb << endl;
    return 0;
}

```

---

## 作者：qhr2023 (赞：1)

## solution

模拟题。

我们直接模拟 $n$ 次对局，每次判断胜负记录得分。

对于判断胜负，对于平局直接跳过，否则按题目要求判断即可。

[通过记录](https://hydro.ac/record/677698667eee4038cafb6668)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, na, nb, ca, cb, a[201], b[201];
void solve(int x, int y){
	if(y==x)  
        return;
	if(x==0){
		if(y==2 || y==3) ca++;
		else cb++;
	}else if(x==1){
		if(y==0 || y==3) ca++;
		else cb++;
	}else if(x==2){
		if(y==1 || y==4) ca++;
		else cb++;
	}else if(x==3){
		if(y==4 || y==2) ca++;
		else cb++;
	}else if(x==4){
		if(y==0 ||y==1) ca++;
		else cb++;
	}
}
int main(){
	cin >> n >> na >> nb;
	for(int i=1; i<=na; i++)
		cin >> a[i];
	for(int i=1; i<=nb; i++)
		cin >> b[i];
    for (int i=1, j=1; n--; i=(i==na?1:i+1), j=(j==nb?1:j+1))
		solve(a[i], b[j]);
	cout << ca << ' ' << cb;
	return 0;
}
```

---

## 作者：Alarm5854 (赞：1)

这道题还是比较容易的，我一次就通过了，然后我翻了一下已经有的48篇题解，发现没有和我思路一样的，于是我~~心血来潮地~~写一篇题解，代码量相对来说较少，且比较友好。
[![](https://cdn.luogu.com.cn/upload/pic/1346.png)](https://www.luogu.org/problem/P1328)
通过此图可以发现，假如甲出了石头，乙出了剪刀，甲赢了，加甲的分数，等同于甲出了剪刀，乙出了石头，乙赢了，加甲的分数，其他情况下，假如甲出的代号比乙的大，都可以用这种方法解决。于是这道题可以用递归来解决，这样就不需要写长达21行的分支语句，也不需要打表了。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,na,nb,sa,sb,fa[201],fb[201];//看到sb不要想歪，这是score of b的缩写。
inline void pk(int a,int b,int &s1,int &s2){
	if(a==b) return;//如果甲和乙出的一样，直接返回。
	if(a>b){//假如甲出的代号比乙的大，就递归解决，之后就可以只枚举一半
		pk(b,a,s2,s1);
		return;
	}
	switch(a){
		case 0:++(b==2||b==3?s1:s2);return;//等同于if(b==2||b==3) ++s1;else ++s2;return;下同
		case 1:++(b==3?s1:s2);return;
		case 2:++(b==4?s1:s2);return;
		case 3:++s1;return;
	}
}
int main(){
	scanf("%d%d%d",&n,&na,&nb);
	for(int i=0;i<na;++i)//下标从0开始，方便等下取模
		scanf("%d",fa+i);
	for(int i=0;i<nb;++i)
		scanf("%d",fb+i);
	for(int i=0;i<n;++i)
		pk(fa[i%na],fb[i%nb],sa,sb);
	printf("%d %d",sa,sb);//输出甲和乙的得分
	return 0;
}
```

---

## 作者：ylzpl (赞：0)

我们可以讨论石头剪子布的胜负平情况，用数组先记录下来。

```cpp
int res[10][10] = 
{
	{0, -1, 1, 1, -1},
	{1, 0, -1, 1, -1},
	{-1, 1, 0, -1, 1},
	{-1, -1, 1, 0, 1},
	{1, 1, -1, -1, 0},
};
```
由于他们的出拳是有规律的，所以我们可以用队列来模拟他们的出拳情况。再根据他们的胜负情况用计数器统计即可。


```cpp
#include <bits/stdc++.h>
using namespace std;

int res[10][10] = 
{
	{0, -1, 1, 1, -1},
	{1, 0, -1, 1, -1},
	{-1, 1, 0, -1, 1},
	{-1, -1, 1, 0, 1},
	{1, 1, -1, -1, 0},
};

int main()
{
	queue<int> qa, qb;
	int n, na, nb;
	cin >> n >> na >> nb;
	int x;
	for(int i = 1; i <= na; ++i)
	{
		cin >> x;
		qa.push(x);
	}
	for(int i = 1; i <= nb; ++i)
	{
		cin >> x;
		qb.push(x);
	}
	int suma = 0, sumb = 0;
	while(n--)
	{
		int x = qa.front();
		int y = qb.front();
		
		qa.pop();
		qb.pop();
		
		if(res[x][y] == 1)
			++suma;
		else if(res[x][y] == -1)
			++sumb;
		qa.push(x);
		qb.push(y);
	}
	cout << suma << " " << sumb;
	return 0;
}
```

---

## 作者：IGA_Indigo (赞：0)

## 题目大意
是石头剪刀布多了两种出法，胜负关系正如题目中给的表格，给出两个人的猜拳周期和游戏局数，每一次赢的人得 $1$ 分，输的得 $0$ 分，平局两人都得 $0$ 分，要我们求出最后两个人的总得分。
## 大体思路
可以看到游戏局数不大于 $200$，所以我们可以直接模拟得到。

一个思路简易的方法是把所有输赢关系都存到数组 $sy$ 里。

```cpp
sy[0][0]=0;
sy[0][1]=0;
sy[0][2]=1;
sy[0][3]=1;
sy[0][4]=0;
sy[1][0]=1;
sy[1][1]=0;
sy[1][2]=0;
sy[1][3]=1;
sy[1][4]=0;
sy[2][0]=0;
sy[2][1]=1;
sy[2][2]=0;
sy[2][3]=0;
sy[2][4]=1;
sy[3][0]=0;
sy[3][1]=0;
sy[3][2]=1;
sy[3][3]=0;
sy[3][4]=1;
sy[4][0]=1;
sy[4][1]=1;
sy[4][2]=0;
sy[4][3]=0;
sy[4][4]=0;
```

我这里和题目中一样，$0$ 表示剪刀，$1$ 表示石头，$2$ 表示布，$3$ 表示蜥蜴人，$4$ 表示斯波克。

然后按照周期模拟两个人所做出的手势，每次询问即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int sy[5][5];
int a[205],b[205];
int main(){
	int n,na,nb;
	cin>>n>>na>>nb;
	sy[0][0]=0;
	sy[0][1]=0;
	sy[0][2]=1;
	sy[0][3]=1;
	sy[0][4]=0;
	sy[1][0]=1;
	sy[1][1]=0;
	sy[1][2]=0;
	sy[1][3]=1;
	sy[1][4]=0;
	sy[2][0]=0;
	sy[2][1]=1;
	sy[2][2]=0;
	sy[2][3]=0;
	sy[2][4]=1;
	sy[3][0]=0;
	sy[3][1]=0;
	sy[3][2]=1;
	sy[3][3]=0;
	sy[3][4]=1;
	sy[4][0]=1;
	sy[4][1]=1;
	sy[4][2]=0;
	sy[4][3]=0;
	sy[4][4]=0;//我们先与处理出所有可能对局的输赢情况 
	for(int i=0;i<na;i++){
		cin>>a[i];
	}
	for(int i=0;i<nb;i++){
		cin>>b[i];
	}
	int suma=0,sumb=0;
	for(int i=0;i<n;i++){
		suma+=sy[a[i%na]][b[i%nb]];
		sumb+=sy[b[i%nb]][a[i%na]];//按照周期模拟
	}
	cout<<suma<<" "<<sumb;//输出答案
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

### P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布题解
题目大意：  
这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。![https://cdn.luogu.com.cn/upload/pic/1346.png](https://cdn.luogu.com.cn/upload/pic/1346.png)
现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。  
已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。


---

思路：  
这是一道大水题，可以用队列来模拟，每次出完一个手势就把手势放在队尾，等待下一局。然后通过判断来模拟 $20$ 种情况就行了。  
代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
queue<int>q1;//定义A的手势，用队列装
queue<int>q2;//定义B的手势，用队列装
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	int a,b;
	cin>>n>>a>>b;
	for(int i=1;i<=a;i++)
	{
		int x;
		cin>>x;
		q1.push(x);
	}
	for(int i=1;i<=b;i++)
	{
		int x;
		cin>>x;
		q2.push(x);
	}
	int cnt1=0,cnt2=0;
	for(int i=1;i<=n;i++)
	{
		int x=q1.front();
		int y=q2.front();//取出这局的手势
		
		q1.pop();//弹出队列
		q2.pop();//弹出队列
		//模拟20种情况，把胜负情况统计一下
	    if(x==0&&y==1) cnt2++;
	    if(x==1&&y==0) cnt1++;
	    
	    if(x==0&&y==2) cnt1++;
	    if(x==2&&y==0) cnt2++;
	    
	    if(x==0&&y==3) cnt1++;
	    if(x==3&&y==0) cnt2++;
	    
	    if(x==0&&y==4) cnt2++;
	    if(x==4&&y==0) cnt1++;
	    
	    if(x==1&&y==2) cnt2++;
	    if(x==2&&y==1) cnt1++;
	    
	    if(x==1&&y==3) cnt1++;
	    if(x==3&&y==1) cnt2++;
	    
		if(x==1&&y==4) cnt2++;
		if(x==4&&y==1) cnt1++;
		
		if(x==2&&y==3) cnt2++;
		if(x==3&&y==2) cnt1++;
		
		if(x==2&&y==4) cnt1++;
		if(x==4&&y==2) cnt2++;
		
		if(x==3&&y==4) cnt1++;
		if(x==4&&y==3) cnt2++;
		
		
		//cout<<cnt1<<" "<<cnt2<<"\n";
		
		q1.push(x);//记得把手势装到队尾
		q2.push(y);//记得把手势装到队尾
	}
	cout<<cnt1<<" "<<cnt2;
	return 0;
}
//其中，0表示 剪刀 ，1表示 石头 ，2表示 布 ，3表示 蜥蜴人 ，4表示 斯波克 
```

---


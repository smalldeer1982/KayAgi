# [GCJ 2011 #1B] RPI

## 题目描述

在美国，每年有 350 所学校争夺 NCAA 大学篮球锦标赛的邀请资格。由于学校众多，如何决定哪些学校应该被邀请呢？大多数队伍之间从未交手，而且有些队伍的赛程比其他队伍要艰难得多。

下面是 $4$ 支队伍 $A, B, C, D$ 的一个赛程示例：

```
   |ABCD
  -+----
  A|.11.
  B|0.00
  C|01.1
  D|.10.
```

每一行中的 $1$ 表示该队获胜，$0$ 表示该队失利。因此，队伍 $C$ 战胜了 $B$ 和 $D$，输给了 $A$。队伍 $A$ 战胜了 $B$ 和 $C$，但没有与 $D$ 交手。

NCAA 锦标赛委员会使用一个叫做 RPI（Ratings Percentage Index，评级百分指数）的公式来帮助排名队伍。传统上，它被定义为：

$$\text{RPI} = 0.25 \times \text{WP} + 0.50 \times \text{OWP} + 0.25 \times \text{OOWP}$$

WP、OWP 和 OOWP 对每支队伍的定义如下：

- WP（胜率）是你赢得的比赛场次占总比赛场次的比例。
    - 在示例赛程中，队伍 $A$ 的 WP = 1，队伍 $B$ 的 WP = 0，队伍 $C$ 的 WP = 2/3，队伍 $D$ 的 WP = 0.5。
- OWP（对手胜率）是你所有对手的 WP 的平均值，但首先要去掉他们与自己的比赛。
    - 例如，如果去掉与 $D$ 队的比赛，$B$ 队的 WP = 0，$C$ 队的 WP = 0.5。因此，$D$ 队的 $\text{OWP} = 0.5 \times (0 + 0.5) = 0.25$。类似地，$A$ 队的 OWP = 0.5，$B$ 队的 OWP = 0.5，$C$ 队的 OWP = 2/3。
- OOWP（对手的对手胜率）是你所有对手的 OWP 的平均值。OWP 就是上一步计算的数值。
    - 例如，$A$ 队的 $\text{OOWP} = 0.5 \times (0.5 + 2/3) = 7/12$。

综合计算，$A$ 队的 $\text{RPI} = (0.25 \times 1) + (0.5 \times 0.5) + (0.25 \times 7 / 12) = 0.6458333\dots $

关于 RPI，你可以提出一些有趣的问题。RPI 是否合理地衡量了队伍的实力？对队伍来说，赢得比赛更重要，还是安排强劲的对手更重要？

这些都是很好的问题，但对于本题，你的任务更为直接：给定一份比赛赛程，你能否计算出每支队伍的 RPI？

## 说明/提示

**数据范围**

- $1 \leq T \leq 20$。
- 如果赛程中第 $i$ 行第 $j$ 列为 '1'，则第 $j$ 行第 $i$ 列为 '0'。
- 如果赛程中第 $i$ 行第 $j$ 列为 '0'，则第 $j$ 行第 $i$ 列为 '1'。
- 如果赛程中第 $i$ 行第 $j$ 列为 '.'，则第 $j$ 行第 $i$ 列也为 '.'。
- 每支队伍至少与另外两支队伍比赛过。
- 没有两支队伍之间会比赛两次。
- 没有队伍与自己比赛。

**小数据范围（8 分，测试点 1 - 可见）**

- $3 \leq N \leq 10$。
- 时间限制：3 秒。

**大数据范围（12 分，测试点 2 - 隐藏）**

- $3 \leq N \leq 100$。
- 时间限制：6 秒。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
3
.10
0.1
10.
4
.11.
0.00
01.1
.10.```

### 输出

```
Case #1:
0.5
0.5
0.5
Case #2:
0.645833333333
0.368055555556
0.604166666667
0.395833333333```

# 题解

## 作者：alice_c (赞：1)

## 思路

只用按照题意模拟就行了。

计算 $wp_i$ 的方法非常明显，我们只用维护一个 $win_i$ 和 $tot_i$，分别表示 $i$ 队赢了几场比赛和参加了几场比赛，$wp_i$ 就是 $\frac{win_i}{tot_i}$。

计算 $owp_i$ 稍微复杂一些。我们需要计算一个 $wp1_{i,j}$，表示 $i$ 队排除与 $j$ 队的比赛的胜利率。如果 $i$ 队和 $j$ 队打比赛赢了，那么 $wp1_{i,j}$ 就是 $\frac{win_i-1}{tot_i-1}$；否则就是 $\frac{win_i}{tot_i-1}$。我们枚举每一个和 $i$ 队打过比赛的队伍 $j$，设 $j$ 的数量为 $sz$，$owp_i$ 就是 $\frac{\sum_{i=1}^n wp1_{j,i}}{sz}$。

然后，我们需要计算 $oowp_i$，需要用到之前计算的 $owp_i$。我们枚举每一个和 $i$ 队打过比赛的队伍 $j$，$oowp_i$ 就是 $\frac{\sum_{i=1}^n owp_j}{sz}$。

最后，输出 $rpi_i=0.25×wp_i+0.50×owp_i+0.25×oowp_i$ 就行了。

## 代码

~~只有短短的 $64$ 行。~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int T,n;
char a[105][105];
int win[105];//赢了几场比赛
int tot[105];//参加了几场比赛
double wp[105];//胜利率
double owp[105];//对手排除与i队的比赛胜利率
double oowp[105];//对手的对手的胜利率
double wp1[105][105];//排除与j队的比赛的胜利率
int main()
{
    cin >> T;
    for(int t=1;t<=T;t++){
        cin >> n;
        //多测不清空，爆零两行泪
        memset(win,0,sizeof(win));
        memset(tot,0,sizeof(tot));
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                cin >> a[i][j];
                if(a[i][j]=='1') win[i]++;
                if(a[i][j]!='.') tot[i]++;
            }
        //计算wp
        for(int i=1;i<=n;i++)
            wp[i]=1.0*win[i]/tot[i];
        //计算owp
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                if(a[i][j]=='1') wp1[i][j]=1.0*(win[i]-1)/(tot[i]-1);
                if(a[i][j]=='0') wp1[i][j]=1.0*win[i]/(tot[i]-1);
            }
        for(int i=1;i<=n;i++){
            double sum=0;
            int sz=0;
            for(int j=1;j<=n;j++)
                if(a[i][j]!='.'){
                    sum+=wp1[j][i];
                    sz++;
                }
            owp[i]=1.0*sum/sz;
        }
        //计算oowp
        for(int i=1;i<=n;i++){
            double sum=0;
            int sz=0;
            for(int j=1;j<=n;j++)
                if(a[i][j]!='.'){
                    sum+=owp[j];
                    sz++;
                }
            oowp[i]=1.0*sum/sz;
        }
        //输出
        cout << "Case #" << t << ":\n";
        for(int i=1;i<=n;i++){
            double rpi=wp[i]*0.25+owp[i]*0.5+oowp[i]*0.25;
            printf("%.6lf\n",rpi);
        }
    }
}
``````

---

## 作者：jojo_fan (赞：1)

### 题目分析
这道题要求我们计算每支队伍的 RPI（评级百分指数），由三部分组成：WP（胜率）、OWP（对手胜率）和 OOWP（对手的对手胜率）。

### 思路
1.  ‌WP 计算‌：遍历每支队伍的比赛记录，统计获胜场次除以总比赛场次。
2.  OWP 计算‌：对于每支队伍，计算其所有对手的 WP（不包括与该队伍的比赛）的平均值。
3.  ‌OOWP 计算‌：对于每支队伍，计算其所有对手的 OWP 的平均值。
4.  ‌RPI 计算‌：按照公式 $0.25 \times WP + 0.5 \times OWP + 0.25 \times OOWP$ 计算最终结果。
 
```cpp
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        int n;
        cin >> n;
        vector<string> s(n);
        for (int i = 0; i < n; ++i) {
            cin >> s[i];
        }
        
        // 计算WP
        vector<double> wp(n);
        for (int i = 0; i < n; ++i) {
            int games = 0, wins = 0;
            for (int j = 0; j < n; ++j) {
                if (s[i][j] == '1') wins++;
                if (s[i][j] != '.') games++;
            }
            wp[i] = games ? (double)wins / games : 0.0;
        }
        
        // 计算OWP
        vector<double> owp(n);
        for (int i = 0; i < n; ++i) {
            int o = 0;
            double tot = 0.0;
            for (int j = 0; j < n; ++j) {
                if (s[i][j] != '.') {
                    o++;
                    int games = 0, wins = 0;
                    for (int k = 0; k < n; ++k) {
                        if (k == i) continue;
                        if (s[j][k] == '1') wins++;
                        if (s[j][k] != '.') games++;
                    }
                    tot += games ? (double)wins / games : 0.0;
                }
            }
            owp[i] = o ? tot / o : 0.0;
        }
        
        // 计算OOWP
        vector<double> oowp(n);
        for (int i = 0; i < n; ++i) {
            int o = 0; double tot = 0.0;
            for (int j = 0; j < n; ++j) {
                if (s[i][j] != '.') {
                    o++;
                    tot += owp[j];
                }
            }
            oowp[i] = o ? tot / o : 0.0;
        }
        
        // 输出结果
        cout << "Case #" << t << ":\n";
        cout << fixed << setprecision(12);
        for (int i = 0; i < n; ++i)
            cout << 0.25 * wp[i] + 0.5 * owp[i] + 0.25 * oowp[i] << '\n';
    }
    return 0;
}
```

---

## 作者：hlb44 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13368)

比较好的一道语法题目，我们只需要按照题目计算以下内容：

WP：每个队伍的胜率是其胜利场次除以总比赛场次。

OWP：对于每个队伍，计算其对手在排除与该队伍比赛后的平均胜率。

OOWP：对于每个队伍，计算其对手的 OWP 的平均值。

RPI：根据公式 $RPI = 0.25 \times WP + 0.50 \times OWP + 0.25 \times OOWP$ 计算每个队伍的最终 RPI 值。

代码：
（因 SPJ 误差，本代码输出与样例并不完全一致，望周知）

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	int T;
	cin>>T;
	for(int case_num=1; case_num<=T; ++case_num) {
		int N;
		cin>>N;
		vector<string>a(N);
		for(int i=0; i<N; ++i) {
			cin>>a[i];
		}
		vector<double>wp(N);
		vector<double>owp(N);
		vector<double>oowp(N);
//计算WP
		for(int i=0; i<N; ++i) {
			int wins=0;
			int games=0;
			for(int j=0; j<N; ++j) {
				if(a[i][j]!='.') {
					games++;
					if(a[i][j]=='1') {
						wins++;
					}
				}
			}
			wp[i]=static_cast<double>(wins)/games;
		}
//计算OWP
		for(int i=0; i<N; ++i) {
			double sumowp=0.0;
			int numowp=0;
			for(int j=0; j<N; ++j) {
				if(a[i][j]!='.') {
					int opp_wins=0;
					int opp_games=0;
					for(int k=0; k<N; ++k) {
						if(k==i)continue;
						if(a[j][k]!='.') {
							opp_games++;
							if(a[j][k]=='1') {
								opp_wins++;
							}
						}
					}
					sumowp+=static_cast<double>(opp_wins)/opp_games;
					numowp++;
				}
			}
			owp[i]=sumowp/numowp;
		}
//计算OOWP
		for(int i=0; i<N; ++i) {
			double sum_oowp=0.0;
			int numowp=0;
			for(int j=0; j<N; ++j) {
				if(a[i][j]!='.') {
					sum_oowp+=owp[j];
					numowp++;
				}
			}
			oowp[i]=sum_oowp/numowp;
		}
		cout<<"Case #"<<case_num<<":\n";
		cout<<fixed<<setprecision(12);
		for(int i=0; i<N; ++i) {
			double rpi=0.25*wp[i]+0.50*owp[i]+0.25*oowp[i];
			cout<<rpi<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：wuyouawa (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13368)

### 思路

数据很小，可以直接模拟。

我们按题目要求计算出每个队伍的 $\text{WP}$，$\text{OWP}$ 和 $\text{OOWP}$，其中 $\text{WP}$ 是自己的胜场数除以比赛场数，$\text{OWP}$ 是对手除去与自己比赛后的 $\text{WP}$ 的平均值，$\text{OOWP}$ 是所有对手的 $\text{OWP}$ 的平均值。

然后我们用公式 ：
$$\text{RPI} = (0.25 \times \text{WP}) + (0.5 \times \text{OWP}) + (0.25 \times \text{OWP}) $$

即可计算出 $\text{RPI}$。

需要注意以下细节问题：

- 多测清空

- 精度

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,sum1,sum2,sum3;
char a[105][105];
double wp[105],owp[105],oowp[105],s;
int main(){
	cin>>t;
	for(int k=1;k<=t;k++)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				cin>>a[i][j];
			}
		}
		printf("Case #%d:\n",k);
		for(int i=1;i<=n;i++)
		{
			sum1=0,sum2=0;
			for(int j=1;j<=n;j++)
			{
				if(a[i][j]!='.')  sum2++;
				if(a[i][j]=='1')  sum1++;
			}
			wp[i]=double(sum1)/double(sum2);
		}
		for(int i=1;i<=n;i++)
		{
			s=0,sum3=0;
			for(int j=1;j<=n;j++)
			{
				if(a[i][j]!='.')
				{
					sum1=0,sum2=0;
			        for(int g=1;g<=n;g++)
			        {
				        if(a[j][g]!='.'&&g!=i)  sum2++;
				        if(a[j][g]=='1'&&g!=i)  sum1++;
			        }
			        s+=double(sum1)/double(sum2);
			        sum3++;
				}
			}
			owp[i]=double(s)/double(sum3);
		}
		for(int i=1;i<=n;i++)
		{
			s=0,sum3=0;
			for(int j=1;j<=n;j++)
			{
				if(a[i][j]!='.')  s+=owp[j],sum3++;
			}
			oowp[i]=double(s)/double(sum3);
			printf("%.12lf\n",wp[i]*0.25+owp[i]*0.50+oowp[i]*0.25);
		}
	}
	return 0;
}
```

---

## 作者：Xiaoshangjie (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13368)

### 题意
对于每组数据，给出 $N$ 个队伍比赛结果的矩阵，求出每个队伍的 RPI 值，计算公式是
$$
\text{RPI}=0.25\times\text{WP}+0.50\times\text{OWP}+0.25\times\text{OOWP}
$$
具体一点：（题目原话）
- WP（胜率）是你赢得的比赛场次占总比赛场次的比例。
- OWP（对手胜率）是你所有对手的 WP 的平均值，但首先要去掉他们与自己的比赛。
- OOWP（对手的对手胜率）是你所有对手的 OWP 的平均值。OWP 就是上一步计算的数值。


### 思路
这是一道**模拟**题。  
不难发现，只要我们分别计算每支队伍的 $\text{WP,OWP,OOWP}$ 的值，再根据公式计算即可。  
事先定义：
- $s_{i,j}$ 表示 $i$ 与 $j$ 的比赛的结果。
- $w_i$ 表示第 $i$ 支队伍的 $\text{WP}$。
- $o_i$ 表示第 $i$ 支队伍的 $\text{OWP}$。
- $oo_i$ 表示第 $i$ 支队伍的 $\text{OOWP}$。

**下面说明计算过程：**
1. **计算 $\text{WP}$ 的过程。**  
   遍历每个队伍 $i$，统计其有效比赛场次 $cnt$ 和获胜场次 $win$，那么这支队伍的 $\text{WP}=\dfrac{win}{cnt}$。  
   具体怎么统计呢？当然是遍历对手 $j$，判断是否`s[i][j]=='1'`即可。
2. **计算 $\text{OWP}$ 的过程。**  
   与上面的方法相似，遍历每个队伍 $i$ 以及他的对手 $j$，根据上面的方法计算 $j$ 的 $\text{WP}$ 即可（也可以根据之前的计算预处理，但要单独判断是否`s[i][j]=='1'`）。
3. **计算 $\text{OOWP}$ 的过程。**  
   非常简单，只需要遍历所有队伍 $i$ 的对手 $j$，根据上一步计算出来的 $o_j$ 计算平均值即可。特别注意：不计算 $o_i$。

既然求出了所有队伍的 $\text{WP,OWP,OOWP}$ 的值，我们就可以根据一开始的公式求值了。

**特别注意：**
1. 题目涉及浮点数计算，**要开`double`**。
2. **至少保留 $6$ 位小数**，否则会不满足 $10^{-6}$ 的精度（我保留了样例 Case#2 的 $12$ 位）。

根据上述的算法，时间复杂度为 $O(TN^2)$，对于 $1\le T\le 20,3\le N\le 100$ 的数据范围没有一点问题。

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
double w[101],o[101],oo[101],r[101];
int main()
{
    int T;cin>>T;
    for(int t=1;t<=T;t++)
    {
        int n;cin>>n;
        char s[101][101];
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                cin>>s[i][j];
        //计算WP
        for(int i=1;i<=n;i++)
        {
            int cnt=0,win=0;
            for(int j=1;j<=n;j++)
            {
                if(s[i][j]!='.')
                {
                    cnt++;
                    if(s[i][j]=='1')win++;
                }
            }
            w[i]=1.0*win/cnt;
        }
        //计算OWP
        for(int i=1;i<=n;i++)
        {
            double sum=0,c=0;
            for(int j=1;j<=n;j++)
            {
                if(s[i][j]!='.')
                {
                    int cnt=0,win=0;
                    for(int k=1;k<=n;k++)
                    {
                        if(k!=i&&s[j][k]!='.')
                        {
                            cnt++;
                            if(s[j][k]=='1')win++;
                        }
                    }
                    sum+=1.0*win/cnt;
                    c++;
                }
            }
            o[i]=sum/c;
        }
        //计算OOWP
        for(int i=1;i<=n;i++)
        {
            double sum=0,c=0;
            for(int j=1;j<=n;j++)
              if(s[i][j]!='.')
                sum+=o[j],c++;
            oo[i]=sum/c;
        }
        cout<<"Case #"<<t<<":"<<endl;
        for(int i=1;i<=n;i++)
            cout<<fixed<<setprecision(12)<<0.25*w[i]+0.5*o[i]+0.25*oo[i]<<endl;//保留12位
    }
    return 0;
}

```

---

## 作者：Clouds_dream (赞：0)

### 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P13368)

### 题目分析
对于每个队伍，我们只需要计算 $wp$，$owp$ 和 $oowp$ 即可。  

**说明：**
- $wp$：队伍获胜场次除以总比赛场次。  
- $owp$：所有对手的调整胜率平均值（除去与当前队伍的比赛）。  
- $oowp$ ：所有对手的 $owp$ 平均值。

### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

int ti;

void f(int t){
	int n;
	cin>>n;
	string s[105];
	for(int i=0;i<n;i++){
		cin>>s[i];
	}
	vector<double>wp(n);
	for(int i=0;i<n;i++){
		int w=0,tot=0;
		for(int j=0;j<n;j++){
			if(s[i][j]=='1')w++;
			if(s[i][j]!='.')tot++;
		}
		wp[i]=(double)w*1.0/tot*1.0;
	}
	vector<double>owp(n);
	for(int i=0;i<n;i++){
		double sum=0;
		int cnt=0;
		for(int j=0;j<n;j++){
			if(s[i][j]=='.')continue;
			int w=0,tot=0;
			for(int k=0;k<n;k++){
				if(k==i)continue;
				if(s[j][k]=='1')w++;
				if(s[j][k]!='.')tot++;
			}
			sum+=(double)w*1.0/tot*1.0;
			cnt++;
		} 
		owp[i]=sum/cnt;
	}
	vector<double>oowp(n);
	for(int i=0;i<n;i++){
		double sum=0;
		int cnt=0;
		for(int j=0;j<n;j++){
			if(s[i][j]=='.')continue;
			sum+=owp[j];
			cnt++;
		}
		oowp[i]=sum/cnt;
	}
    cout<<"Case #"<<t<<":"<<endl;
	for(int i=0;i<n;i++){
		cout<<fixed<<setprecision(12);
        cout<<0.25*wp[i]+0.5*owp[i]+0.25*oowp[i]<<endl;
	}
}

signed main()
{
	fst
	cin>>ti;
	for(int i=1;i<=ti;i++){
		f(i);
	}
	return 0;
}
```

---


# [COCI 2012/2013 #4] OREHNJACA

## 题目描述

最近，电视台开始录制新一季的 **Jamie Oliver** 烹饪节目。本季中，Jamie 计划向全世界展示克罗地亚美食的魅力。在第一期节目中，这位大厨烘焙了一条长达 $L$ 米的核桃卷，这是该地区有史以来最长的核桃卷。经过长时间的辛勤烹饪，他决定奖励在场的 $N$ 位忠实观众。

他将核桃卷切成每段 $1$ 米的小段，并从左到右依次编号为 $1$ 到 $L$。每位观众都获得了一个唯一的编号 ID（从 $1$ 到 $N$ 的正整数），以及一张写有两个整数 $P$ 和 $K$ 的纸条。每位观众随后可以领取从第 $P$ 段到第 $K$ 段（包含两端）的所有核桃卷。观众按照 ID 编号的顺序依次领取（编号为 $1$ 的观众先领，然后是编号为 $2$ 的观众，依此类推）。由于领取顺序的影响，有些观众实际拿到的核桃卷段数比他们原本预计的要少。下表对应于第一个样例测试：

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|----|
|   | 1 | 1 | 1 |   | 3 | 2 | 2 | 3 |    |

请编写程序，确定哪位观众**期望**获得最多的核桃卷段，以及哪位观众**实际**获得的核桃卷段最多。

## 说明/提示

如果第一行输出正确，则该测试点可获得 60% 分数；如果第二行输出正确，则该测试点可获得 40% 分数。

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
10
3
2 4
7 8
6 9```

### 输出

```
3
1```

## 样例 #2

### 输入

```
10
3
1 3
5 7
8 9```

### 输出

```
1
1```

## 样例 #3

### 输入

```
10
5
1 1
1 2
1 3
1 4
7 8```

### 输出

```
4
5```

# 题解

## 作者：Lyzc0dr (赞：4)

### 前言
~~COCI 稳定发挥，再次贡献无人写题解的水题。~~
### 题目大意
给定一个长度为 $L$ 的序列，给出 $N$ 组询问，每组询问给出两个左右端点 $P_{i}$ 和 $K_{i}$，求理论上形成区间长度最长的询问编号和实际上按照顺序每次进行 $[P_{i},K_{i}]$ 区间修改后的有效的区间长度最长的询问编号。
### 分析
本题是一道简单模拟题，根据题意进行每个询问的区间的对应操作并统计答案即可，对于第一问，进行区间长度的计算与比对即可，对于第二问，按照顺序进行操作，每次对区间内有效的元素进行累加，再更新即可。进行修改时可以直接历遍区间进行修改，注意统计答案时一个位置的元素实际上可能会被减去多次从而使其变为负数，将负数看做 $0$ 即可，且注意其中第一、二问如果有多解，要保留编号更小的。
### 代码
下面给出本题代码。
```cpp
#include<bits/stdc++.h>
#define endl "\n"
#define ll long long
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
#define p_q priority_queue
#define stoi stoll
using namespace std;
const int N=1e3+10;
int l,maxn=INT_MIN,maxidx,n;
int emp[N];
struct node{
	int p,k;
}opd[N];
int main() {
	IOS
	cin>>l>>n;
	for(int i=1;i<=l;i++)emp[i]=1;
	for(int i=1;i<=n;i++){//第一问
		cin>>opd[i].p>>opd[i].k;
		int len=opd[i].k-opd[i].p+1;
		if(len==maxn){//保留编号更小的
			continue;
		}else if(len>maxn){
			maxn=len;
			maxidx=i;
		}else{
			continue;
		}
	}
	cout<<maxidx<<"\n";
	maxn=INT_MIN;
	for(int i=1;i<=n;i++){//第二问
		int tmp=0;
		for(int j=opd[i].p;j<=opd[i].k;j++){
			if(emp[j]>0)tmp+=emp[j];//将负数当做零
			emp[j]--;
		}
		
		if(tmp==maxn){//保留编号更小的
			continue;
		}else if(tmp>maxn){
			maxn=tmp;
			maxidx=i;
		}
	}
	cout<<maxidx;
	return 0;
}
```
### 附加部分
因为此题被当做了蒟蒻模拟赛的题目，所以某位同学因为过于紧张给出了一个大炮打蚊子的做法——线段树，下面仅仅给出代码，不作为本题解的正文，仅供参考。
```cpp
//This code is written by the user pipilong2024
#include<iostream>
using namespace std;
namespace SegTree {//线段树
#define inf 1e18
	const int maxn = 2e5 + 10;
	struct Tree {
		int tr[maxn * 4], lz[maxn * 4], a[maxn];
		void push_up(int x) {
			tr[x] = tr[x * 2] + tr[x * 2 + 1];
		}
		void push_down(int x, int l, int r) {
			if (lz[x] == -1) return;
			int mid = (l + r) >> 1;
			tr[x * 2] = lz[x] * (mid - l + 1);
			lz[x * 2] = lz[x];
			tr[x * 2 + 1] = lz[x] * (r - mid);
			lz[x * 2 + 1] = lz[x];
			lz[x] = -1;
		}
		void build(int x, int l, int r) {
			lz[x] = -1;
			if (l == r) {
				tr[x] = a[l];
				return;
			}
			int mid = (l + r) >> 1;
			build(x * 2, l, mid);
			build(x * 2 + 1, mid + 1, r);
			push_up(x);
		}
		int query(int x, int l, int r, int ql, int qr) {
			if (l > qr || ql > r) return 0;  
			if (l >= ql && r <= qr) return tr[x];
			int mid = (l + r) >> 1;
			push_down(x, l, r);
			return query(x * 2, l, mid, ql, qr) +
			       query(x * 2 + 1, mid + 1, r, ql, qr);
		}
		void modify(int x, int l, int r, int ql, int qr, int k) {
			if (l >= ql && r <= qr) {
				tr[x] = (r - l + 1) * k;
				lz[x] = k;
				return;
			}
			if (l > qr || ql > r) return;
			int mid = (l + r) >> 1;
			push_down(x, l, r);
			modify(x * 2, l, mid, ql, qr, k);
			modify(x * 2 + 1, mid + 1, r, ql, qr, k);
			push_up(x);
		}
	};
}
using namespace SegTree;
Tree t;
int L, n;
int ans1, ans2;
int tmp1, tmp2;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> L >> n;
	for (int i = 1; i <= L; i++) t.a[i] = 1;
	t.build(1, 1, L);
	for (int i = 1, p, k; i <= n; i++) {
		cin >> p >> k;
		if (k - p + 1 > tmp1) ans1 = i, tmp1 = k - p + 1;
		int sum = t.query(1, 1, L, p, k);
		if (sum > tmp2) ans2 = i, tmp2 = sum;
		t.modify(1, 1, L, p, k, 0);
	}
	cout << ans1 << "\n" << ans2;
	return 0;
}

```

---

## 作者：longyitongxue (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P13413)
# 思路
我们可以发现，预期段数最多的，就是直接取 $K_i-P_i$ 最大值，同时维护一个最大值的 $id$ 即可。其实实际段数的也很简单，我们发现这道题的规模很小只有 $10^3$，所以我们可以拿一个标记数组，表示该段核桃卷有没有被拿，$0$ 表示没拿，$1$ 表示拿了。遍历每一个观众，然后遍历这个观众可以获得的核桃卷的段，如果该核桃卷没被拿，标记一下我拿了，然后给该观众的拿到数 $+1$。最后，同上面预期段数最多的方法，维护一个最大值和最大值的 $id$ 即可。
# [AC](https://www.luogu.com.cn/record/226575326) code
```cpp
#include<iostream>
using namespace std;
int s[1005],t[1005];
bool vis[1005];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr),cout.tie(nullptr);
    int n,l;
    cin>>n>>l;
    for(int i=1;i<=l;i++){
        cin>>s[i]>>t[i];
    }
    int maxn=0,maxi;
    for(int i=1;i<=l;i++){
        if(t[i]-s[i]>maxn){//维护最大值和 id
            maxn=t[i]-s[i];
            maxi=i;
        }
    }
    cout<<maxi<<'\n';
    maxn=0;
    for(int i=1;i<=l;i++){
        int cnt=0;//记录该 id 观众实际拿了几个核桃卷
        for(int j=s[i];j<=t[i];j++){
            if(!vis[j]){//该核桃卷没被拿过
                vis[j]=1;//我拿了
                cnt++;//拿到数+1
            }
        }
        if(cnt>maxn){//同样维护最大值
            maxn=cnt;
            maxi=i;
        }
    }
    cout<<maxi;
    return 0;
}
```

---

## 作者：Doraeman (赞：2)

简单模拟题。

## 期望获得值
这部分相对简单。

对于一个观众可以获得的核桃卷区间 $[P,K]$，其可以得到的核桃卷段数就是 $K-P+1$。

## 实际获得值
题目中给出的表格给了我们一定的启发。  
我们也可以写一个数组 $a$，用于模拟表格。维护方式如下。

- 设 $a_i=0$ 表示核桃卷的第 $i$ 段还没有人领取。
- 设 $a_i=x$（$1\leq x\leq N$）表示核桃卷的第 $i$ 段被 ID 编号为 $x$ 的观众领取了。
- 如果有一个编号为 $y$ 的观众手里的区间 $[P,K]$，循环遍历表格。对于所有 $a_j=0$（$P\leq j\leq K$），都将 $a_j$ 更新为这个观众的编号 $y$。

最后，编号为 $i$ 的观众**实际获得**的核桃卷段数就是 **$a$ 数组（表格）中 $i$ 的数量**。

## 记录答案
用 $max$ 记录所有观众的期望获得值的最大值，$ans$ 保存其编号。设某观众编号为 $i$，期望获得值为 $t$，代码如下。
```c++
if(t > max){
    max = t;
    ans = i;
}
```
实际获得值处理方式同理。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
const int LMAX = 1e3+5;

bool a[LMAX];
int max1 = -1, max2 = -1,
    ans1, ans2;

int main(){
    int L, n; cin >> L >> n;
    for(int i=1; i<=n; i++){
        int p, k; cin >> p >> k;
        // 直接计算 t1
        int t1 = k - p + 1, t2 = 0;

        // 模拟求出 t2
        for(int j=p; j<=k; j++)
            if(!a[j]) a[j] = i, t2++;

        // 记录答案 
        if(t1 > max1)
            max1 = t1,
            ans1 = i;
        if(t2 > max2)
            max2 = t2,
            ans2 = i;
    }
    cout << ans1 << '\n' << ans2;
}
```

---

## 作者：lihaojun120113 (赞：2)

### 前置准备

pair 或者结构体。

### 题目解析与注意事项

期望最大值：  

遍历所有观众的区间，计算 $K_i−P_i+1$ 并记录最大值。

实际最大值： 

使用 $vis$ 数组标记已领取的段，按 ID 顺序模拟领取过程。

统计每位观众实际领取的段数（未被标记的段）。

**注意**：若有多解，输出最小 ID。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005; 
bool vis[N];      
int n,m;         
int qwid=1,sjid=1;//qwid:期望最多段观众ID,sjid:实际最多段观众ID
int qwm=0,sjm=0;  //qwm:期望最大段数,sjm:实际最大段数
int main(){
	cin>>n>>m;
	vector<pair<int,int>> v(m+1);
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>v[i].first>>v[i].second;
		int t=v[i].second-v[i].first+1;
		if(t>qwm) qwm=t,qwid=i;
	}
	for(int i=1;i<=m;i++){
		int l=v[i].first,r=v[i].second,c=0;
		for(int j=l;j<=r;j++) 
			if(!vis[j]) vis[j]=1,c++;
		if(c>sjm) sjm=c,sjid=i;
	}
	cout<<qwid<<endl<<sjid;
	return 0;
}
```

### 结束语

欢迎大家为本题解提出宝贵意见！

---

## 作者：zhoujunchen (赞：1)

抢一波题解。

Solution
--

首先求期望拿到的核桃卷段数量，由于是期望，所以不存在什么核桃卷在这之前已经被拿走的情况，所以拿走的段数就是 $K-P+1$。


```cpp
//求期望拿到的 
for(int i=1;i<=n;i++)
    if(r[ans]-l[ans]+1<r[i]-l[i]+1)
        ans=i;
cout<<ans<<"\n";
```

然后求实际拿到的，我们开一个标记数组 $vis$，表示这个点到底有没有被拿走，没被拿走就拿走并标记。


```cpp
for(int i=1;i<=n;i++){
    for(int j=l[i];j<=r[i];j++){
        if(!vis[j])vis[j]=1,cnt[i]++;//没人拿，拿走，计数器加一
        else ;//被人拿了 
      }
		if(cnt[ans]<cnt[i])ans=i;
}
```

整体代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,l[1145],r[1145],ans,cnt[1145];
bool vis[1145];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>m>>n;
	for(int i=1;i<=n;i++)cin>>l[i]>>r[i];
	//求期望拿到的 
	for(int i=1;i<=n;i++)if(r[ans]-l[ans]+1<r[i]-l[i]+1)ans=i;
	cout<<ans<<"\n";
	ans=0;
	for(int i=1;i<=n;i++){
		for(int j=l[i];j<=r[i];j++){
			if(!vis[j])vis[j]=1,cnt[i]++;//没人拿，拿走，计数器加一
			else ;//被人拿了 
		}
		if(cnt[ans]<cnt[i])ans=i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Hkb150429 (赞：0)

## 题意

现有一条长达 $L$ 米的核桃卷，有 $N$ 位忠实观众。
他将核桃卷切成每段 $1$ 米的小段，并从左到右依次编号为 $1$ 到 $L$。每位观众都获得了一个唯一的编号 ID（从 $1$ 到 $N$ 的正整数），以及一张写有两个整数 $P$ 和 $K$ 的纸条。每位观众随后可以领取从第 $P$ 段到第 $K$ 段（包含两端）的所有核桃卷。观众按照 ID 编号的顺序依次领取（编号为 $1$ 的观众先领，然后是编号为 $2$ 的观众，依此类推）。

## 思路

简单模拟题，我们可以用一个数组来表示状态，$0$ 为取走，$1$ 则相反。每次输入 $z$ 和 $y$ 就更新两个最值与最值编号，且把 $z$ 到 $y$ 都设为 $1$。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int l,n,b,b1,a[1005],x,x1;
int main(){
    cin>>l>>n;
    b=b1=-2147483648;
    fill(a,a+n+10,1);
    for(int i=1;i<=n;i++){
        int z,y;
        cin>>z>>y;
        if(y-z+1>b) b=y-z+1,x=i;
        int sj=0;
        for(int j=z;j<=y;j++){
            sj+=a[j];
            a[j]=0;
        }
        if(sj>b1) b1=sj,x1=i;
    }
    cout<<x<<endl<<x1;
    return 0;
}
```

---

## 作者：Chenxuhang_play (赞：0)

通过首尾相减再加上 $1$，可以得到每个选手**期望**获得的核桃卷段的长度。使用打擂台可以得到**期望**获得的核桃卷段的长度最长的观众。

**实际**获得的核桃卷段的长度可以考虑如下方案实现：

+ 建立一个长度为 $L$ 的数组 $a$，对于 $i\in[1,L]$，$a_i$ 表示核桃卷段是否已经被拿走。$a_i=1$ 表示核桃卷段没有被取走，$a_i=0$ 表示该段已经被拿走。

+ 对于每次输入的 $l,r$，使用变量 $sum$ 记录对于 $i\in[l,r]$ 中的 $a_i$ 的和。每次取走之后将 $a_i$ 设为 $0$。

用这种方法可以求出每个观众**实际**获得的核桃卷段的长度。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long L,n;
	cin>>L>>n;
	int a[L+5],l,r,maxn=0,mn=0,maxa=0,ma=0,sum=0;
	for(long long i=1;i<=L;i++) a[i]=1;
	for(long long i=1;i<=n;i++)
	{
		cin>>l>>r;
		if(maxn<r-l+1)
		{
			maxn=r-l+1;
			mn=i;
		}
		sum=0;
		for(long long j=l;j<=r;j++)
		{
			sum+=a[j];
			a[j]=0;
		}
		if(maxa<sum)
		{
			maxa=sum;
			ma=i;
		}
	}
	cout<<mn<<endl<<ma;
	return 0;
}
```

---

## 作者：long_long_inf (赞：0)

# 思路

这题还是比较简单的，直接模拟就行了。

先计算出每个人预计要得到的核桃卷的数量。因为不考虑核桃卷是否已经被拿走，所以直接用 $k$ 减去 $p$ 再加一就可以了。

一个人的信息用结构体存就可以了，存下他们的 $p$，$k$，期望得到的，实际得到的和编号就可以了。但要注意，在查找期望得到的核桃卷最多的人的时候，最好不要排序，因为这样会将数组的顺序打乱，比较烦。比较推荐用两个变量维护最大值和编号。

统计实际得到的核桃卷数量时，用一个数组表示第 $i$ 段核桃卷是否被取走，然后暴力枚举就可以了。

# 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
struct no {
    int p, k;
    int exp;
    int act;
    int id;
} c[1005];
bool f[1005];
bool cmp(no x, no y) {
    if (x.act != y.act) return x.act > y.act;
    return x.id < y.id;
}
int main() {
    int l, n;
    cin >> l >> n;
    for (int i = 1; i <= n; i++) {
        cin >> c[i].p >> c[i].k;
        c[i].id = i;
        c[i].exp = c[i].k - c[i].p + 1;
    }
    int maxn = -1, ans;
    for (int i = 1; i <= n; i++)
        if (c[i].exp > maxn) {
            maxn = c[i].exp;
            ans = c[i].id;
        }
    cout << ans << endl;
    memset(f, 1, sizeof(f));
    for (int i = 1; i <= n; i++) {
        int sum = 0;
        for (int j = c[i].p; j <= c[i].k; j++) {
            sum += f[j];
            f[j] = 0;
        }
        c[i].act = sum;
    }
    sort(c + 1, c + n + 1, cmp);
    cout << c[1].id << endl;
    return 0;
}
```

[AC](https://www.luogu.com.cn/record/226503749)

---

## 作者：b__b (赞：0)

暴力。
## 形式化表述
给定一个长为 $L$ 的数组 $a$，初始时数组中的值均为 $1$。

每次操作给定两个数 $P,K$，查询区间 $\left[P,K\right]$ 数字和，并将里面的每一个数设为 $0$。

输出查询获得的最大值。
## 做法
期望获得最多其实就是长度最大，直接每一次求 $K-P+1$ 最大值。

那如何获得实际获得的数量呢？

~~区间问题当然是用线段树/树状数组啦。~~

注意到范围特别小，于是我们考虑直接暴力。
```cpp
#include <cstdio>
bool has[1005]; //是否拿走
int main() {
    int l, n, ans1n = 0, ans1i, ans2n = 0, ans2i;
    scanf("%d%d", &l, &n);
    for (int i = 1; i <= n; ++i) {
        int p, k;
        scanf("%d%d", &p, &k);
        int len = k - p + 1;
        if (len > ans1n) ans1i = i, ans1n = len;
        int got = 0;
        for (int j = p; j <= k; ++j) if (!has[j]) has[j] = 1, ++got;
        if (got > ans2n) ans2i = i, ans2n = got;
    }
    printf("%d\n%d", ans1i, ans2i);
}
```
时间复杂度：有 $N$ 次操作，每一次操作最长需要枚举 $L$ 个位置，总复杂度为 $O(NL)$。

空间复杂度：需要记录长度为 $L$ 的数组的情况，复杂度为 $O(L)$。

---

## 作者：Yang_Jun (赞：0)

## 思路
一道模拟吧，挺简单的。

这道题给定一个长度为 $h$ 的核桃卷，以及每个观众应该取走核桃卷的哪个部分的长度，要求求出哪个**期望**取走核桃卷的长度最长的观众编号以及**实际**取走核桃卷的长度最长的观众编号。

+ 对于求最大期望长度，只需要算出每个观众期望取走核桃卷的长度，再取最大值即可。
+ 对于求最大实际长度，只需要模拟观众按顺序取走核桃卷，然后求出每个观众实际拿到的核桃卷长度，最后取最大值即可。
+ 但题目要求的求出观众的编号，因此要再每次更新最大值是还要更新观众的编号。

## 代码
```
#include<bits/extc++.h>
using namespace std;
const int maxn=1005;
int n,m;
int a[maxn],b[maxn];
bool h[maxn];
int main(){
	cin>>n>>m;
    int q=-1,sum=-1,p1,p2;//q代表期望长度，sum代表实际长度
    for(int i=0;i<m;i++) {
		cin>>a[i]>>b[i];
		if(q<b[i]-a[i]){//更新期望长度
			q=b[i]-a[i];
			p1=i;//再更新长度是也要更新观众编号
		}
		int cot=0;
		for(int j=a[i];j<=b[i];j++){//按顺序模拟观众取走核桃卷
			if(h[j]!=1){//1代表已取走，0代表未取走
				cot++;
				h[j]=1;
			}
		}
		if(cot>sum){//更新实际长度
			sum=cot;
			p2=i;//同样要更新观众编号
		}
	}
	cout<<p1+1<<endl<<p2+1;
}
```

---


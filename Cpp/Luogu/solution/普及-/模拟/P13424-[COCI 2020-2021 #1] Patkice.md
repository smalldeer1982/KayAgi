# [COCI 2020/2021 #1] Patkice

## 题目描述

不久前，在一个遥远的热带国度，住着三只橡皮鸭。炎炎夏日，当它们在沙滩上休憩时，决定乘着一把黑色的旧雨伞，顺着洋流去附近的一个小岛冒险。

由于这几只鸭子都是经验丰富的海洋探险家，出发前它们会先查看一张洋流地图。地图上，鸭子们所在的岛屿用字母 'o' 标记。它们可以选择朝四个方向之一出发：北（N）、东（E）、西（W）、南（S）。

海域中的洋流总是朝某一个方向流动，在地图上用如下符号表示：西向东用 '<'，东向西用 '>'，北向南用 'v'，南向北用 '^'。当鸭子们处于有洋流的格子上时，会被洋流带到下一个格子，方向与洋流一致。这片海域的洋流有个特点：不会把鸭子带出地图边界，也不会形成漩涡（即不会让鸭子陷入循环）。

风平浪静的海面用 '.' 表示。如果鸭子们被洋流带到平静的海面，或者回到了起始岛屿，它们就无法继续航行。鸭子们要去的目标小岛用字母 'x' 标记。

鸭子们可不想耽误沙滩派对，于是请求你帮忙判断：它们是否有可能到达目标小岛？如果可以，应该从哪个方向出发？由于其中一只鸭子容易晕船，请你选择能让航程最短的方向。如果有多个方向航程相同，请选择字典序最小的那个方向。


## 说明/提示

对前两个样例的说明：

- 第一个样例中，只有朝东（E）出发才能到达目标岛屿，其他方向都会停在风平浪静的海面上。
- 第二个样例中，朝北或朝南出发都能到达目标岛屿，但南（S）方向更短，应选择南。

### 评分

在价值 $30$ 分的测试点中，若存在合法出发方向，则唯一。

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
6 6
..>>>v
.o^..v
.v.<.v
.>>^.v
.x<<<<
......```

### 输出

```
:)
E```

## 样例 #2

### 输入

```
5 5
v<<<<
>v.>^
v<.o.
>>v>v
..>>x```

### 输出

```
:)
S```

## 样例 #3

### 输入

```
3 3
x>.
.o^
^<.```

### 输出

```
:(```

# 题解

## 作者：chenxi797 (赞：2)

# P13424 \[COCI 2020/2021 #1] Patkice 题解

## 问题重述

我们有一个由 $r$ 行 $s$ 列字符组成的地图，表示海域的洋流情况。地图上 $o$ 为起始岛屿，$x$ 为目标岛屿，`<>v^` 分别表示东、西、南、北方向的洋流，`.` 为平静的海面。

鸭子从起始岛屿 $o$ 出发，可以选择北（$N$）、东（$E$）、西（$W$）、南（$S$）四个方向之一开始移动。一旦进入洋流格子，鸭子会沿着洋流方向移动，直到遇到平静海面。或回到起始岛屿 $o$ 为止。目标是判断鸭子是否能到达目标岛屿 $x$，并找出最短路径的初始方向（如果有多个，选择字典序最小的方向）。

## 解决思路

对于 $o$ 的四个相邻方向，枚举模拟鸭子的移动。

根据格子上箭头的方向，移动到相邻格子。

如果该格子是洋流（`<>v^`），则按照洋流方向继续移动。

移动过程中需要记录步数，直到遇到 $o$ 或 `.`。

如果在移动过程中遇到 $x$，则记录该方向和步数。

比较所有能到达 $x$ 的方向，选择步数最少的；步数相同时选择字典序最小的方向，$E < N < S < W$。

输出结果：如果有可达方向，输出 `：)` 和最优方向；否则输出 `：(`。

---

## 作者：wenqinghua1001 (赞：1)

## 思路

本题很明显，大模拟，东南西北四个方向都模拟一遍即可，我用的是递归写法。

如果鸭子们被洋流带到平静的海面，或者回到了起始岛屿，它们就无法继续航行。很明显，在到达目的地的途中，递归的终止条件是 `a[i][j]=='.'` 和 `a[i][j]=='o'`。

接下来最重要的是四个方向，注意选择能让航程最短的方向。如果有多个方向航程相同，请选择字典序最小的那个方向。

部分代码：

```cpp
if(a[x][y]=='<')
	dfs(x,y-1,f+a[x][y],ans+1);
if(a[x][y]=='>')
	dfs(x,y+1,f+a[x][y],ans+1);
if(a[x][y]=='^')
	dfs(x-1,y,f+a[x][y],ans+1);
if(a[x][y]=='v')
	dfs(x+1,y,f+a[x][y],ans+1);
```

---

## 作者：b__b (赞：1)

又是一道水题。

我们跟 P13415 一样，枚举四个方向，然后模拟即可。具体可见下面的代码注释：
```cpp
#include <cstdio>
char map[105][105];
//检查字符是否合法
bool check(char c) {return c == '.' || c == '<' || c == '>' || c == '^' || c == 'v' || c == 'o' || c == 'x';}
int main() {
    int r, s, bx, by;
    scanf("%d%d", &r, &s);
    for (int i = 0; i < r; ++i) for (int j = 0; j < s; ++j) {
        while (!check(map[i][j] = getchar()));
        if (map[i][j] == 'o') bx = i, by = j; //起点
    }
    int lesstep = 0x7fffffff, fx; //记录最少步数和方向
    //'E' < 'N' < 'S' < 'W' 题目要求输出字典序最小的方向
    for (int i = 0; i < 4; ++i) {
        int nx = bx, ny = by; //这里的x和y是反过来的
        switch (i) {
            case 0: //E
                ++ny;
                break;
            case 1: //N
                --nx;
                break;
            case 2: //S
                ++nx;
                break;
            case 3: //W
                --ny;
        }
        for (int nstep = 0;; ++nstep) {
            if (map[nx][ny] == 'x') { //到终点了
                if (lesstep > nstep) lesstep = nstep, fx = i;
                break;
            }
            if (map[nx][ny] == '.' || map[nx][ny] == 'o') break; //不能继续走了
            switch (map[nx][ny]) {
                case '^':
                    --nx;
                    break;
                case '>':
                    ++ny;
                    break;
                case '<':
                    --ny;
                    break;
                case 'v':
                    ++nx;
                    break;
            }
        }
    }
    if (lesstep == 0x7fffffff) puts(":("); //没有一个方向能够走
    else {
        puts(":)");
        switch (fx) {
            case 0:
                putchar('E');
                break;
            case 1:
                putchar('N');
                break;
            case 2:
                putchar('S');
                break;
            case 3:
                putchar('W');
        }
    }
}
```

---

## 作者：Zjb13927701829 (赞：0)

# P13424 [Patkice](https://www.luogu.com.cn/problem/P13424) 题解
## 题目简述
我们模拟橡皮鸭从起点岛屿出发，沿着四个可能的方向（东、北、南、西）移动，并根据海洋洋流的方向继续移动，直到到达目标岛屿、平静海面或返回起点岛屿。

我们的目标是判断是否存在一条路径到达目标岛屿，并在存在时选择航程**最短**且字典序**最小**的**方向**。
## 方法与思路
我们模拟橡皮鸭从四个方向分别出发的路径，下面是模拟步骤：
1. 每次移动后，检查新位置是否为 `x`，如果是，那么此方向成功。
2. 若新位置是 `.` 或起点 `o`，则此方向失败。
3. 若新位置是洋流符号（`<`、`>`、`^`、`v`），则根据洋流方向继续移动。

对于每个成功到达目标岛屿的方向，记录这个方向的移动步数。然后选择步数最少的方向，若**步数相同**则选择**字典序最小**的方向。

最后输出结果即可：\
如果存在有效路径，输出`):`和最优的方向；否则，输出`:(`。
## [AC](https://www.luogu.com.cn/record/227058731) Code
```cpp
#include <iostream>
#include <vector>
#include <climits>
#include <tuple>
#include <algorithm>
using namespace std;

int main() {
    int r, s;
    cin >> r >> s;
    vector<string> grid(r);
    int start_row = -1, start_col = -1;
    
    for (int i = 0; i < r; i++) {
        cin >> grid[i];
        for (int j = 0; j < s; j++) {
            if (grid[i][j] == 'o') {
                start_row = i;
                start_col = j;
            }
        }
    }

    vector<tuple<char, int, int>> dirs = {
        {'E', 0, 1},
        {'N', -1, 0},
        {'S', 1, 0},
        {'W', 0, -1}
    };

    bool found = false;
    int min_steps = INT_MAX;
    char best_dir;

    for (const auto& dir : dirs) {
        char d_char = get<0>(dir);
        int dr = get<1>(dir);
        int dc = get<2>(dir);
        int nr = start_row + dr;
        int nc = start_col + dc;

        if (nr < 0 || nr >= r || nc < 0 || nc >= s) {
            continue;
        }

        int steps = 1;
        int cr = nr;
        int cc = nc;
        bool success = false;

        while (true) {
            if (cr < 0 || cr >= r || cc < 0 || cc >= s) {
                break;
            }

            char cell = grid[cr][cc];
            if (cell == 'x') {
                success = true;
                break;
            }
            if (cell == '.' || cell == 'o') {
                break;
            }

            int ndr = 0, ndc = 0;
            if (cell == '>') {
                ndc = 1;
            } else if (cell == '<') {
                ndc = -1;
            } else if (cell == '^') {
                ndr = -1;
            } else if (cell == 'v') {
                ndr = 1;
            }

            cr += ndr;
            cc += ndc;
            steps++;
        }

        if (success) {
            found = true;
            if (steps < min_steps) {
                min_steps = steps;
                best_dir = d_char;
            } else if (steps == min_steps) {
                if (d_char < best_dir) {
                    best_dir = d_char;
                }
            }
        }
    }

    if (found) {
        cout << ":)" << endl;
        cout << best_dir << endl;
    } else {
        cout << ":(" << endl;
    }

    return 0;
}
```

---

## 作者：Chenxuhang_play (赞：0)

显然发现是模拟。我用的是递归的写法。

直接判断每个格子的类型。如果是 `x`，即终点，返回这次航行的长度 `cnt`。如果是方向标（`^v<>`），按着方向模拟。除外（平静的海面和起点，即 `.o`）表示不能到达终点。

按照这种方法模拟即可。给出上述部分的代码。用零表示不能到达终点。

```cpp
if(c[x][y]=='x') return cnt;
if(c[x][y]=='.') return 0;
if(c[x][y]=='o') return 0;
if(c[x][y]=='^' && x-1>=0) return f(x-1,y,cnt+1);
if(c[x][y]=='v' && x+1<r) return f(x+1,y,cnt+1);
if(c[x][y]=='<' && y-1>=0) return f(x,y-1,cnt+1);
if(c[x][y]=='>' && y+1<s) return f(x,y+1,cnt+1);
```

---

## 作者：Hkb150429 (赞：0)

::::warning[切勿抄袭代码！]
题目不会做时，可以学习题解，但是**过度的抄袭题解代码**被发现将会受到惩罚。
::::

## 题意

西向东用 `<`，东向西用 `>`，北向南用 `v`，南向北用 `^`。当鸭子们处于有洋流的格子上时，会被洋流带到下一个格子，方向与洋流一致。这片海域的洋流有个特点：不会把鸭子带出地图边界，也不会形成漩涡（即不会让鸭子陷入循环）。风平浪静的海面用 `.` 表示。如果鸭子们被洋流带到平静的海面，或者回到了起始岛屿，它们就无法继续航行。鸭子们要去的目标小岛用字母 `x` 标记。求最小路径的方向。

## 思路

我们知道，洋流仅有 $4$ 个方向，我们可以暴力枚举 $4$ 个方向，像题目所说，如果鸭子们被洋流带到平静的海面，或者回到了起始岛屿，它们就无法继续航行，这是退出循环，否则继续只到成功，然后与原先步数取最小值，最后输出答案就可以了。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int r,s;
    cin>>r>>s;
    string g[r+2];
    int x=0,y=0;
    
    for(int i=1;i<=r;i++) {
        cin>>g[i];
        for(int j=0;j<s;j++) {
            if(g[i][j]=='o') {
                x=i;
                y=j+1;
            }
        }
    }

    char d[]={'E','N','S','W'};
    int dx[]={0,-1,1,0},dy[]={1,0,0,-1};
    bool ok=0;
    int mn=1e9;
    char ans;
    
    for(int k=0;k<4;k++) {
        int nx=x+dx[k],ny=y+dy[k];
        if(nx<1||nx>r||ny<1||ny>s) continue;
        
        int step=1,cx=nx,cy=ny;
        bool flag=0;
        while(true) {
            if(cx<1||cx>r||cy<1||cy>s) break;
            
            char c=g[cx][cy-1];
            if(c=='x') {flag=1;break;}
            if(c=='.'||c=='o') break;
            
            if(c=='>') cy++;
            else if(c=='<') cy--;
            else if(c=='^') cx--;
            else if(c=='v') cx++;
            step++;
        }
        
        if(flag) {
            ok=1;
            if(step<mn) {
                mn=step;
                ans=d[k];
            } else if(step==mn&&d[k]<ans) {
                ans=d[k];
            }
        }
    }
    
    if(ok) cout<<":)\n"<<ans<<endl;
    else cout<<":("<<endl;
    
    return 0;
}
```

---

## 作者：ToastBread (赞：0)

[本题](https://www.luogu.com.cn/problem/P7284)的弱化版。

### 思路
直接模拟即可。

需要注意的是题目中给定的东西：

> 请你选择能让航程最短的方向。如果有多个方向航程相同，请选择**字典序最小**的那个方向。

如果你不想直接比较的话，可以试着直接按照字典序顺序枚举，这样第一个最小的答案就是最终答案。

注意边界的处理和细节。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[1005][1005],ansch,cha[5]={' ','E','N','S','W'};//cha 是经过字典序处理过的方向
int n,m,stx,sty,nowx,nowy,dx[5]={0,0,-1,1,0},dy[5]={0,1,0,0,-1},ncnt,ans=100000000; //dx,dy 是 cha 中对应的偏移量
int main()
{
	cin>>n>>m;
	for(int i = 0; i <= n+1; i++)
	{
		for(int j = 0; j <= m+1; j++)
		{
			ch[i][j]='.';//边界初始化
		}
	}
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			cin>>ch[i][j];
			if(ch[i][j]=='o')
			{
				stx=i;//存储初始坐标
				sty=j;
			}
		}
	}
	for(int i = 1; i <= 4; i++)
	{
		nowx=stx+dx[i];
		nowy=sty+dy[i];
		ncnt=0;//记录答案的变量
		while(1)
		{
			ncnt++;
			if(ch[nowx][nowy]=='x') break;//到达终点
			if(ch[nowx][nowy]=='o'||ch[nowx][nowy]=='.')//不可移动
			{
				ncnt=-1;//标记为无解
				break;
			}
			if(ch[nowx][nowy]=='<') nowy--;
			else if(ch[nowx][nowy]=='>') nowy++;
			else if(ch[nowx][nowy]=='^') nowx--;
			else if(ch[nowx][nowy]=='v') nowx++;
		}
		if(ncnt!=-1&&ncnt<ans)//有解，更新答案
		{
			ans=ncnt;
			ansch=cha[i];//答案对应的字符
		}
	}
	if(ans>1000000)
	{
		cout<<":(";
	}
	else
	{
		cout<<":)"<<endl<<ansch<<endl;
	}
}
```

---


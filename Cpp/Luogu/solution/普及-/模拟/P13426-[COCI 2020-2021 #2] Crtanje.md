# [COCI 2020/2021 #2] Crtanje

## 题目描述

Josip 以前经常用 Logo 语言编程。他喜欢画图，但那段日子已经一去不复返了。怀旧之情涌上心头，他决定画一条曲线，表示他公司在 $n$ 天内的净资产变化。

对于这 $n$ 天的每一天，他都知道公司净资产是增加了 $1$ 单位（用 '+' 表示）、减少了 $1$ 单位（用 '-' 表示），还是保持不变（用 '=' 表示）。在第一天之前，公司的净资产为 $0$。

Josip 会在一个无限大的字符矩阵中画这条曲线。矩阵的行索引向上递增，列索引向右递增。对于第 $i$ 天，他会在第 $i$ 列画一个字符。字符和所在行的索引由以下规则决定：

- 如果第 $i$ 天净资产增加，他会在净资产为当天开始时的行画上字符 '/'。
- 如果第 $i$ 天净资产减少，他会在净资产为当天结束时的行画上字符 '\\'。
- 如果第 $i$ 天净资产未变，他会在净资产为当天的行画上字符 '_'。

所有其他位置都填充为 '.'。

你的任务是输出包含整条曲线的最小矩阵，也就是说，输出的矩阵应包含 Josip 画下的所有 '/', '\\' 和 '_' 字符。


## 说明/提示

在价值 $20$ 分的测试数据中，输入不会包含字符 '-'。

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
7
++---==```

### 输出

```
./\....
/..\...
....\__```

## 样例 #2

### 输入

```
5
+=+=+```

### 输出

```
..._/
._/..
/....```

## 样例 #3

### 输入

```
4
--=+```

### 输出

```
\...
.\_/```

# 题解

## 作者：bayiran (赞：2)

## 分析
首先需要分析读入的字符串。

### 读入分析
‌目标：计算每日净资产值‌。

初始化一个数组 $v$，长度为 $n+1$，$v_0$ 表示第 $0$ 天（初始状态）的净资产为 $0$。

遍历字符串 $s$，根据字符 `+`、`-` 或 `=` 更新 $v$ 数组：
- `+`：净资产增加1，$v_i = v_{i-1} + 1$。
- `-`：净资产减少1，$v_i = v_{i-1} - 1$。
- `=`：净资产不变，$v_i = v_{i-1}$。

### 确定矩阵的行数‌

找到 $v$ 数组中的最小值和最大值，计算行数 $r = mav - miv + 1$，这里 $miv$ 和 $mav$ 分别表示净资产的最小值和最大值，用于确定矩阵的高度。

### 生成字符矩阵‌

1. 创建一个 $r$ 行 $n$ 列的矩阵 $g$，初始时所有字符为 `.`。

2. 遍历每一天的变化字符 $s_i$：
    - 如果是 `+`：在净资产开始时的行画 `/`，行号为 $mav - v_i$。
    - 如果是 `-`：在净资产结束时的行画 `\`**（注意转义符）**，行号为 $mav - v_{i+1}$。
    - 如果是 `-`：在净资产不变的行画 `_`，行号为 $mav - v_i$。
  
**注意：行号的计算是为了将净资产值映射到矩阵的行索引（从顶部到底部）。**

### 输出矩阵‌

按行输出 $g$ 矩阵，每行对应矩阵的一行字符。

#### 关键点
1. 净资产值的计算‌：$v$ 数组记录了每一天开始时的净资产值（包括第 $0$ 天）。

2. 行号映射‌：通过 $mav - v_i$ 将净资产值转换为矩阵的行索引，确保最小值对应最底部的行。

3. 字符填充规则‌：

    - `/`：净资产增加时，从当前行的右上方开始画。
    - `\`：净资产减少时，从当前行的右下方开始画，**注意转义符**。
    - `_`：净资产不变时，在当前行画水平线。
4. 顶行判断：如果顶行为空（即每一位都是初始的 `.`），则不输出。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    string s;
    cin>>n>>s;
    vector<int> v(n+1, 0);
    for (int i=1;i<=n;i++){
        v[i] = v[i - 1];
        if(s[i-1] == '+'){
            v[i]++;
        }
        else if(s[i-1] == '-'){
            v[i]--;
        }
    }
    int miv = *min_element(v.begin(),v.end());//这个函数的介绍在后面
    int mav = *max_element(v.begin(),v.end());
    int r = mav - miv + 1;
    vector<string> g(r,string(n,'.'));
    for(int i=0;i<n;i++){
        int row;
        if(s[i] == '+'){
            row = mav - v[i];
            g[row][i] = '/';
        }
        else if(s[i] == '-'){
            row = mav - v[i+1];
            g[row][i] = '\\';//注意转义符
        }
        else{
            row = mav - v[i];
            g[row][i] = '_';
        }
    }
    int pd = 0;
    for(int i=0;i<n;i++){
        if(g[0][i]!='.'){
            pd = 1;
            break;
        }
    }
    if(pd==1){
        for(int i=0;i<n;i++){
            cout<<g[0][i];
        }
        cout<<endl;
    }
    for(int i=1;i<r;i++){
        for(int j=0;j<n;j++){
            cout<<g[i][j];
        }
        cout<<endl;
    }
    return 0;
}
```

## 关于 `*min_element()`
- `*min_element()` 是 C++ 标准库 `<algorithm>` 中的一个函数，用于查找给定范围内的最大元素。它返回一个迭代器，指向该范围内的最大元素。
- 一般用法：
    ```cpp
    max_element(_ForwardIterator __first,_ForwardIterator __last,_Compare __comp)
    ```
表示在区间 $[\_ForwardIterator \_\_first,\_ForwardIterator \_\_last-1]$ 之间的最大值，关于最大值的定义默认是 `operator<`，如想自定义可以定义 `cmp` 函数选择最大值，更多请查阅资料。

---

## 作者：b__b (赞：2)

水模拟题。

以第一个样例为例：
![](https://cdn.luogu.com.cn/upload/image_hosting/qo6pa8jt.png)

其中 X 轴代表时间，Y 轴代表资金。

我们开一个字符二维数组 $a$ 存储答案，$a_{i,j}$ 表示图表中位置在 $(i,j)$ 的字符。

于是我们每一天按照当前的资金更新答案，最后循环输出即可。

除了几个细节以外就没有什么要注意的：
- > - 如果第 $i$ 天净资产增加，他会在净资产为当天**开始**时的行画上字符 '/'。
  > - 如果第 $i$ 天净资产减少，他会在净资产为当天**结束**时的行画上字符 '\\'。
  > - 如果第 $i$ 天净资产未变，他会在净资产为当天的行画上字符 '_'。

  这说明我们要考虑资产的更新顺序，增加时先绘制再更新，减少时先更新再绘制。
- 资产可能为负数。因此我们在绘制时要加上一个数使得所有的数变成正常的下标。
- 注意输出时的循环的方向。
```cpp
#include <iostream>
const int INF = 0x1BF52;
int maxn = -INF, minn = INF;
struct {
    char a[205];
    char &operator[](int p) {
        maxn = std::max(p, maxn), minn = std::min(p, minn); //更新值域最大值和最小值
        return a[p + 100]; //最多100天，因此最小值为-100
    }
} out[105];
char s[105];
int main() {
    int n;
    scanf("%d%*c%s", &n, s);
    for (int i = 0, now = 0; i < n; ++i) {
        if (s[i] == '+') out[i][now++] = '/'; //先绘制再更新
        else if (s[i] == '-') out[i][--now] = '\\'; //先更新再绘制
        else out[i][now] = '_';
    }
    //输出是从上到下的，因此要从最大值逐步到最小值
    for (int i = maxn; i >= minn; --i, putchar('\n')) for (int j = 0; j < n; ++j) {
        char tmp = out[j][i];
        putchar(tmp ? tmp : '.'); //如果有字符就输出字符，没有就输出默认值
    }
}
```
时间复杂度：输入和处理的复杂度为 $O(n)$，输出的复杂度为 $O(Wn)$（$W$ 为值域），总复杂度为 $O(Wn)$。

空间复杂度：答案是一个二维数组，总复杂度为 $O(Wn)$（$W$ 为值域）。

---

## 作者：MAX_CURRY_JAMES (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P13426)

## 1、题目大意

这题要求我们画一个走势图，上升```'/'```用表示，下降用```'\'```表示，不变用```'_'```表示，其它没有趋势的用 ```'.'``` 表示，在输入中分别用```'+'```，```'-'```，```'='``` 来表示。在看完题目时，我以为这是一道水题，结果这题的推导过程用了很久（~~可能是我太菜了吧~~）。

## 2、思路

这题的重难点我认为在于用字符标记。

首先是读入的部分，我分成了 $3$ 个部分处理，并用 sum 数组来记住当前的数额。

$1$ ：读入```'+'```。

这个代表上升，所以应该```sum++```，但当储存```a[i]``` 时，我发现不能存储```sum```的值，而应该存储```sum-1```。因为虽然我们的```sum```已经在上面了，但是它的上升的字符是从下到上的，所以它现在的位置是应在```sum-1```的位置上，所以应是 ```a[i]=sum-1```。并用```b[i]=1```代表上升。

$2$ ：读入```'-'```。

这个代表下降，所以应该```sum--```，在储存 ```a[i]```时，按照上面的道理，我们应该存储 ```sum+1```，但因为上面是```sum-1```，所以和 ```sum+1```相抵消，所以是```a[i]=sum```。并用 ```b[i]=2```代表下降。

$3$ ：读入```'='```。

这个代表不变，所以```sum```不变，所以不用考虑其它，只用```a[i]=sum,b[i]=3```代表不变。

最后用```zd```，```zx```来表示最大和最小。

核心代码：


```cpp
for(int i=1;i<=n;i++){
		cin>>x;
		if(x=='+') sum++,a[i]=sum-1,b[i]=1;
		else if(x=='-') {
			sum--;a[i]=sum;
			b[i]=2;
		}
		else if(x=='=') {
			b[i]=3,a[i]=sum;
		}
		zd=max(zd,sum),zx=min(zx,sum);
	}
```

然后就是建矩阵的部分。这里我避免有空的行，所以用了一个双重循环来看一下有没有一行是空的，并用一个数组来标记。在最后输出部分，我们再来一个双重循环，判断是否到时候输出，输出什么，这道题就完成了。

## 3、代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,zd,zx;
char x;
int a[105],b[105],sum;
map<int,int>pd;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		if(x=='+') //输入+ 
		sum++,a[i]=sum-1,b[i]=1;
		else if(x=='-') {//输入- 
			sum--;a[i]=sum;
			b[i]=2;
		}
		else if(x=='=') { //输入= 
			b[i]=3,a[i]=sum;
		}
		zd=max(zd,sum),zx=min(zx,sum); //最大值最小值 
	}
	for(int i=zd;i>=zx;i--){
		bool flag=false;
		for(int j=1;j<=n;j++){
			if(a[j]==i) flag=true; 
		}
		if(!flag) pd[i]=1;//判断是否为空 
	}
	for(int i=zd;i>=zx;i--){
		if(!pd[i]){
			for(int j=1;j<=n;j++){
			if(a[j]==i){ //判断当前是否应该输出 
				if(b[j]==1) 
				cout<<'/';	
				else if(b[j]==2) 
					cout<<'\\';
				else if(b[j]==3) cout<<'_';
			}
			else cout<<'.';
		}
		putchar('\n');
		}
	}
	return 0;
}

```

总结：这题主要是第一个部分比较难处理，其它都比较简单。

最后再提醒一句：题解仅供学习参考使用，请勿抄题解。

写作不易，求点赞。

---

## 作者：dengxk (赞：1)

# P13426 [COCI 2020/2021 #2] Crtanje 题解
## 题目大意
给定某公司资产的变化趋势，要求根据趋势画出变化曲线，空白部分用 `.` 填充。
## 思路
本题是字符串和模拟题。我们可以开一个 $cur$ 变量记录当天的公司资产，再开一个二维的 $ans$ 字符数组记录曲线内容，为便于按行输出，可以用 $ans_{i, j}$ 表示第 $j$ 天的资产为 $i$，其变化趋势为 $ans_{i, j}$。那么我们只需要根据读入的变化趋势来更新 $cur$ 和 $ans$ 就行了。同时注意读题：
>- 如果第 $i$ 天净资产增加，他会在净资产为当天**开始**时的行画上字符 `/`；
>- 如果第 $i$ 天净资产减少，他会在净资产为当天**结束**时的行画上字符 `\`。

注意两种情况中画曲线的行是不一样的，一个是开始时的行，一个是结束时的行，所以要注意两个变量的修改顺序：当资产增加时，应当**先修改 $ans$ 再修改 $cnt$**；当资产减少时，应当**先修改 $cnt$ 再修改 $ans$**。

由于 C++ 中数组不能使用负数下标，同时题目中 $1 \leq n \leq 100$，所以资产最多减少 $100$ 次，所以我们可以把 $cnt$ 初始化为 $100$ 以保证不会出现负数下标的情况。

最后是输出部分。题目要求输出包含整条曲线的最小矩阵，所以要确定它的范围。考虑到特殊情况比较多（例如第 $1$ 天的上升或下降），同时本题数据范围较小，为减少特判数量，不妨在处理完后直接将整个数组扫一遍，确定曲线的最小范围。随后根据这个范围进行输出即可，输出时注意区分 C++ 数组下标的方向和实际意义相反，所以要倒序输出。
## 代码
```cpp
#include <cstdio>

int n, cur = 100, maxh, minh = -1;
char ans[310][110], op;

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf(" %c", &op);
        if (op == '+')
        {
            // 净资产增加，在当天开始时画"/"，所以先赋值再cur++
            ans[cur][i] = '/';
            cur++;
        }
        else if (op == '-')
        {
            // 净资产减少，在当天结束时画"/"，所以先cur--再赋值
            cur--;
            ans[cur][i] = '\\';
        }
        else
            ans[cur][i] = '_';
    }
    // 寻找数组中包括曲线的最大部分，即maxh和minh
    for (int i = 0; i <= 200; i++)
        for (int j = 1; j <= n; j++)
            if (ans[i][j])
            {
                if (minh == -1) // 最小值只在第一次遇到曲线时更新
                    minh = i;
                maxh = i; // 最大值会一直更新直到最后一次遇到曲线
            }
    for (int i = maxh; i >= minh; i--) // 注意C++数组下标和实际意义的区别，要倒序输出
    {
        for (int j = 1; j <= n; j++)
            if (ans[i][j]) // 有曲线则输出曲线，否则输出"."
                putchar(ans[i][j]);
            else
                putchar('.');
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：TT_chen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13426)

这题不难，只需要理解题目的意思就行。

首先输入天数，然后输入每天净资产变化。

之后统计每天的净资产，可以用一个数组 $a$，但要注意题目中**每个曲线所在的行**。

统计净资产的最大和最小值，可以用 $maxn$ 和 $minn$，以求表格大小，还是要注意**每个曲线所在的行**，还得注意 $maxn$ 要初始化成 $-1$，而 $minn$ 是 $0$，这样在 $maxn$ 或 $minn$ 没有被记录时，默认值就是图表的中间。

绘图前记得先**初始化**，绘图时对应的行可以用 $maxn$ 减去数值求出，**注意转义符**。

最后输出。

**完整代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],maxn=-1,minn=0,p;
string s;
char c[105][105];
int main()
{
	cin>>n>>s;
	a[0]=0;
	for(int i=0;i<n;i++)
	{
	    switch(s[i])
	    {
	        case '+':
	        {
	            a[i+1]=a[i]+1;
	            maxn=max(maxn,a[i]);      //记当天开始时
	            break;
	        }
	        case '-':
	        {
	        	a[i+1]=a[i]-1;
	            minn=min(minn,a[i+1]);    //记当天结束时
	            break;
	        }
	        case '=':
	        {
	        	a[i+1]=a[i];
	            maxn=max(maxn,a[i+1]);    //说不定比向上曲线更高
	            break;
	        }
	    }
	}
	p=maxn-minn+1;
	for(int i=0;i<p;i++)
	{
		for(int j=0;j<n;j++)
		{
			c[i][j]='.';                  //初始化 
		}
	}
	for(int i=0;i<n;i++)
	{
	    switch(s[i])
	    {
	        case '+':
	        {
	        	c[maxn-a[i]][i]='/';
	        	break;
	        }
	        case '-':
	        {
	        	c[maxn-a[i+1]][i]='\\';   //注意转义符 
	        	break;
	        }
	        case '=':
	        {
	        	c[maxn-a[i]][i]='_';
	        	break;
	        }
	    }
	}
	for(int i=0;i<p;i++)
	{
		for(int j=0;j<n;j++)
		{
			cout<<c[i][j]; 
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：zybgml (赞：0)

题目链接：[P13426 [COCI 2020/2021 #2] Crtanje](https://www.luogu.com.cn/problem/P13426)

这道题其实不难，但如果找不到一个合适的方法，真的比较难实现。

# 大体思路

## 第一步：确定最小矩阵
最小矩阵的求法较为简单：

我的方法是设一个变量表示公司净资产，然后根据 $n$ 天内的净资产变化来求出公司净资产的最大值与最小值，矩阵的长为 $n$，高为最大值与最小值的差加一。

## 第二步：确定曲线
这一步也是本题的难点。为了确定曲线中每一个点的位置，我们要先观察其规律：
![](https://cdn.luogu.com.cn/upload/image_hosting/44eleykn.png)
根据规律我们即可求出每一个点的位置了。以下为伪代码：
```cpp
h[i]=z;
if(a[i]=='='&&a[i+1]=='-') z--;
if(a[i]=='+'&&a[i+1]!='-') z++;
if(a[i]=='-'&&a[i+1]=='-') z--;
```
确定曲线中每一个点的位置后，我们只需打印出曲线矩阵即可。
# 详细代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,z=100,mx=100,mn=100;//初始公司净资产设为100，防止下标越界
int h[1005];//记录曲线中每一个点的位置
char a[1005];//记录净资产变化
char s[1005][1005];//输出的曲线矩阵
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        h[i]=z;//记录曲线中每一个点的位置
        mx=max(mx,z);//求净资产最大值
        mn=min(mn,z);//求净资产最小值

        if(a[i]=='='&&a[i+1]=='-') z--;
        if(a[i]=='+'&&a[i+1]!='-') z++;
        if(a[i]=='-'&&a[i+1]=='-') z--;
        /*
        if求曲线中下一个点的位置
        */
    }
    for(int i=1;i<=n;i++){
        for(int j=mn;j<=mx;j++){
            if(j==h[i]) s[j][i]=a[i];
            else s[j][i]=='.';
            /*
            将输出矩阵成型
            */
        }
    }
    for(int i=mx;i>=mn;i--){
        for(int j=1;j<=n;j++){
            if(s[i][j]=='+') cout<<"/";
            else if(s[i][j]=='-') cout<<char(92);//我太蒻了，发现不能直接输出反斜杠,只好这样。
            else if(s[i][j]=='=') cout<<"_";
            else cout<<'.';
        }
        cout<<endl;
    }
}
```

---

## 作者：_OokoukioO_ (赞：0)

# 题目简述
### 题意
给定一个长度为 $n$ 的字符串，字符串中 `+` 表示第 $i$ 天资产增加，`-` 表示第 $i$ 天资产减少，`=` 表示第 $i$ 天资产不变。
- 如果第 $i$ 天净资产增加，他会在净资产为当天开始时的行画上字符 `/`。
- 如果第 $i$ 天净资产减少，他会在净资产为当天结束时的行画上字符 `\`。
- 如果第 $i$ 天净资产未变，他会在净资产为当天的行画上字符 `_`。

最后给出一个矩阵表示出公司资产的变化，要求矩阵大小最小。
### 思路
设 $pos$ 为当前的高度。

对于矩阵的宽度，我们只需要取 $n$ 列即可。

对于矩阵用的高度，我们只需要记录公司资产变化时的行数 $pos$，并 $maxh$ 和 $minh$ 记录整个变化幅度的最高值和最低值，输出时从 $maxh$ 输出到 $minh$。

$pos$ 可能为负数，因此 $pos$ 的初值要设高一点。

注意题目中的用词“开始时”和“结束时”的区别，也就是我们计算 $pos$ 的时候：
- 如果 $s_i$ 是 `-`，则令 `maps[--pos][i] = '\\'`。
- 如果 $s_i$ 是 `+`，则令 `maps[pos++][i] = '/'`。
- 否则令 `maps[pos][i] = '_'`。

在这个过程中要不断比较 $minh$ 和 $maxh$。

注意：即使 $s_i$ 为 `=` 也要比较 $maxh$ 和 $minh$，因为当 $s_{i-1}$ 为 `+` 时，如果不比较 $pos$，就会使 $maxh$ 和 $minh$ 仍然是上一次比较的结果，但此时的 $pos$ 等于上次的 $pos+1$，如果不比较，可能会使 $maxh$ 和 $minh$ 答案出错。
## [AC 代码](https://www.luogu.com.cn/record/227346672)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long
char maps[500][500];
int n, pos = 105, minh = 1000, maxh;
string s;

signed main() {
	in >> n >> s;
	for (int i = 0; i < n; i++) //变化幅度
		if (s[i] == '+')
			minh = min(minh, pos), maxh = max(maxh, pos), maps[pos++][i] = '/';
		else if (s[i] == '-')
			minh = min(minh, pos - 1), maxh = max(maxh, pos - 1), maps[--pos][i] = '\\';
		else
			minh = min(minh, pos), maxh = max(maxh, pos), maps[pos][i] = '_';
	for (int i = maxh; i >= minh; i--) { //从高到低输出
		for (int j = 0; j < n; j++)
			if (maps[i][j] == '_') //maps[i][j] 可能为空，需要特判 maps[i][j]
				out << '_';
			else if (maps[i][j] == '/')
				out << '/';
			else if (maps[i][j] == '\\')
				out << '\\';
			else
				out << '.';
		out << '\n';
	}
	return 0;
}
```
### 数据
```
100
+++-+==++-+=-++-++-++++++=+-++=-+------+--=+--=+=--+=+---+-++--++++-=------==-----==-+=-+-=-+-+--+-=
```
```
.............................._.....................................................................
............................./.\/\..................................................................
........................._/\/.....\.................................................................
......................../..........\................................................................
......................./............\...............................................................
....................../..............\..............................................................
...................../................\/\...........................................................
..................../....................\_/\..._................./\_...............................
................./\/.........................\_/.\.._/\........../...\..............................
..........._../\/.................................\/...\..../\../.....\.............................
......../\/.\/..........................................\/\/..\/.......\............................
.....__/................................................................\...........................
../\/....................................................................\..........................
./........................................................................\__.......................
/............................................................................\......................
..............................................................................\.....................
...............................................................................\....................
................................................................................\...................
.................................................................................\__.._.............
....................................................................................\/.\/\_.........
...........................................................................................\/\/\....
................................................................................................\/\_

```

---


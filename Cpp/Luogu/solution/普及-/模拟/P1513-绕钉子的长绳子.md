# 绕钉子的长绳子

## 题目描述

平面上有 $N$ 个圆柱形的大钉子，半径都为 $R$，所有钉子组成一个凸多边形。

现在你要用一条绳子把这些钉子围起来，绳子直径忽略不计。求出绳子的长度。


## 说明/提示

本题来自 URAL1020，翻译来自 NOCOW。


## 样例 #1

### 输入

```
4 1
0.0 0.0
2.0 0.0
2.0 2.0
0.0 2.0
```

### 输出

```
14.28
```

# 题解

## 作者：sxtm12138 (赞：22)

  **相信各位dalao做这题时都会猜想：绳子的总长S=一根钉子的周长C1+N   **
  
 **边形的周长C2：由于绳子绕过钉子时，绳子所在的直线必定与圆形的钉**
 
**子相切（即圆的半径与绳子垂直），顺次连接钉子的圆心形成一个N边**

**形，设第i个角的度数为ai，则可以将绳子中弯曲的部分视为一段度数为**

**180-ai的弧（由于相切减2个90度），而N边形内角和为180（n-2），**

**所以各弧的度数之和=180-a1+180-a2+……180-an=180n-(a1+……an）**

**=180n-180n+360=360。（终于证完了）**

 _以下为代码_ （话糙代码不糙）

------------


```cpp
#include<bits/stdc++.h> 
using namespace std;
double a[103],r,s=0,b[103];//A为横坐标，B为纵坐标
int n;//没什么好解释
int main()
{cin>>n>>r;
 for(int i=1;i<=n;i++)cin>>a[i]>>b[i];//读入点坐标
 a[n+1]=a[1];
 b[n+1]=b[1];//为计算第1个点到第N个点的距离做准备
 for(int i=1;i<=n;i++)//计算、累加多边形边长
   s+=sqrt((a[i]-a[i+1])*(a[i]-a[i+1])+(b[i]-b[i+1])*(b[i]-b[i+1]));//这是一个漫长的两点距离公式
 printf("%.2lf",s+6.28318*r);//别忘了加上圆的周长
 return 0;
}//第五次写题解求过，请各位dalao多多指教
```

---

## 作者：Reywmp (赞：13)

这题以前做过，洛谷上竟然也有，水过去再来篇题解。

有这么几点是你需要知道的：

·π要够长！

·几个角上绕有绳子的部分的周长的总和为一个圆的总周长，不用单独算了。(画个图便明白了)

·求两点之间距离公式为：

$\sqrt{(x1-x2)^2+(y1-y2)^2}$


以上为主要的几点。

然后我们来分析下代码怎么写:

输入不说o(￣ヘ￣o＃)

我们将图形周长分三个部分：part1,2,3;

part1是每条直边的长总和(但不包括第一个点与第n个点之间的距离,也就是part3)。一个for循环解决,公式在上面。

part2就是圆弧总周长,也就是一个圆的周长。

part3是第一个点与第n个点之间的距离,调用公式即可~

合并三部分。

输出不说(还是说下吧,printf保留小数后两位用%.2lf)。

注意计算时强制转换一下,用double保险些,数据又没多大。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>//需要sqrt
using namespace std;
const double PI=3.1415926535897932384626433;//够长了吧！(微软计算器，你值得拥有)。
double a[105][3];
int main()
{
    int n;
    double r;//注意啦，有人以为实数就是整数，其实r是要用double的。
    double part1=0;
    double part2=2*r*PI;
    double part3=0;
    //一二三部分
    scanf("%d%lf",&n,&r);//输入不用说了吧
    for(int i=1;i<=n;i++)
    {
        cin>>a[i][1]>>a[i][2];
    }
    for(int i=2;i<=n;i++)
    {
        part2+=(double)(sqrt((abs(a[i-1][1]-a[i][1]))*(abs(a[i][1]-a[i-1][1]))+(abs(a[i][2]-a[i-1][2]))*(abs(a[i][2]-a[i-1][2]))));//其实这里与下面的abs都不需要的，毕竟是平方吗！
    }
    part3=(double)(sqrt((abs(a[n][1]-a[1][1]))*(abs(a[n][1]-a[1][1]))+(abs(a[n][2]-a[1][2]))*(abs(a[n][2]-a[1][2]))));//第三部分是第一条线还要与最后一条线合并
    double ans=(double)(part1+part2+part3);
    //三部分合并
    printf("%.2lf",ans);//输出保留小数点后两位。
    return 0;//2018!
}
```
#2018第一篇题解,尽力而为吧!


---

## 作者：Ludo (赞：6)

#### 看了别人的一些题解，感觉有图会更好理解。
#### 可能很啰嗦…主要是详细地讲一些性质的证明过程。


------------

## 题目大意

平面上有$N$个圆柱形的大钉子，半径都为$R$，所有钉子组成一个**凸多边形**。
现在你要用一条绳子把这些钉子围起来，绳子直径忽略不计，要求绳子的长度。


------------

### 1. 考虑多边形的周长如何运算。

很简单，由于多边形的顶点是依逆时针给出的，因此这个多边形的周长就是**相邻两个顶点的欧几里得距离**。

你可能会想，真的吗？？？ 这个思路不是只有在绳子两端都在钉子的中央之上的时候才是对的吗？ 为了不绕弯路，接下来我们会啰嗦地证明一下…

![](https://cdn.luogu.com.cn/upload/pic/69782.png)

如图所示，$EG$是我们需要考虑的部分。我们想要知道$EG$是否等于$O_1O_2$。

由题意可知，$O_1E$, $O_2G$分别是圆$O_1$，$O_2$的公切线。

或者看这部分 _**感性理解**_ 一下，想象我们把一条绳子拉紧，使绳子同时与两个圆都有碰到的部分，此时我们会发现这根线似乎跟两个圆碰到的部分分别是两个点。与一个圆只有一个交点的直线，叫圆的切线。而圆的切线垂直于经过切点的半径，因此$O_1E$垂直于$EG$, $O_2G$垂直于$EG$，即$O_1E$ // $O_2G$。

我们把钉子的半径用$r$来表示。那么，$O_1E$ = $O_2G$，所以$O_2O_1EG$是一个平行四边形 **（有一组对边平行且相等的四边形是平行四边形）** ，因此$O_1O_2 = EG$。

或者说，我们也可以把$EG$看成$O_1O_2$沿$O_1E$平移得到的线段。
 

------------

### 2. 每一段的弧长度多少？

![](https://cdn.luogu.com.cn/upload/pic/69781.png)

- 接下来，我们的焦点来到了与圆粘连的绳子长度之上。假设我们现在所求的是 $\overset{\frown}{EF}$ ，如果我们知道这段弧的度数（也就是$∠FOE$的度数），就可以轻易地求出每一段弧的长度了。

容易知道，$\sum\limits_{i=1}^n∠FOE=\sum\limits_{i=1}^n180^\circ-θ_i$

此外，$\sum\limits_{i=1}^nθ_i=(n-2)*180^\circ$

所以，$\sum\limits_{i=1}^n∠FOE=n*180^\circ-(n-2)*180^\circ$


## 代码

```cpp
#include <iostream>
#include <cst_dlib>
#include <cstdio>
#include <cmath>
using namespace std;
struct pos //结构体存坐标
{
	double x,y; //实数，用double
}rec[101];
double ans,r;
const double pi=3.14157926535897932384626433;//由于精度问题，所以越精准越好 
double len(pos a,pos b)
{
	return sqrt(pow(a.x-b.x,2)+pow(b.y-a.y,2));
}//求两点的欧几里得距离
int n;
int main(void)
{
	cin>>n>>r;
	for (int i=1;i<=n;i++)
	{
		cin>>rec[i].x>>rec[i].y;
	}
	ans+=2*r*pi;//算弧长
	for (int i=1;i<n;i++)
	{
		ans+=len(rec[i],rec[i+1]);
	}//求多边形周长
	ans+=len(rec[1],rec[n]); //不要漏了，它们也是相邻的
	printf("%.2lf",ans);//保留两位小数输出 使用lf精度较好
}

```



---

## 作者：K___ (赞：5)

# 0.前言
做模拟题时水到的题OvO，第一篇正式题解！
# 1.正文
## 题目解析
似乎是小学数学？
## 注意点
`double`。
## 代码实现
求直边长度，第`1`个点和第`n`个点的距离，一个圆的周长，最后相加~
## Code
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
using namespace std;
struct Cyl
{
	double x,y;
}point[105];
const double pi=3.1415792653589793238462643;
int n;
double r;
double dis(Cyl a,Cyl b)
{
	return sqrt(pow(a.x-b.x,2)+pow(b.y-a.y,2)); // 距离公式
}
double calc()
{
	double c=pi*r*2,s=0;
	s+=dis(point[1],point[n]); // 第1个点到第n个点的距离
	for(int i=1;i<n;i++)
	s+=dis(point[i],point[i+1]); // 直边长度
	return c+s;
}
int main()
{
	cin>>n>>r;
	for(int i=1;i<=n;i++)
	cin>>point[i].x>>point[i].y;
	printf("%.2lf",calc());
	return 0;
}
```
# 2.结语
第一篇题解，求管理员过~
## Thanks for your reading!

---

## 作者：wrehtg (赞：3)

这道题的输入保证是顺时针方向的，只需累加距离即可。

而对于这种“凸多边形”，我们可以把每个顶点上的弧平移到一起，就刚好构成一个圆。这样只需累加相邻两点间的距离和一个圆的周长即可。

两点间距离：sqrt（(x1-x2)^2+(y1-y2)^2）

我们怎么取π呢？手打很多位？

事实上，我们用一下cmath里的反三角函数即可，arccos(-1)=π

这个π理应非常精确，比手打的好嗯

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int n;
double a[105],b[105],ans,r;
int main(){
    scanf("%d%lf",&n,&r);//r要double
    int i;
    double pi=acos(-1);//反三角得到π的值
    scanf("%lf%lf",&a[1],&b[1]);
    for(i=2;i<=n;i++)
    {
        scanf("%lf%lf",&a[i],&b[i]);
        ans+=1.0*sqrt((a[i]-a[i-1])*(a[i]-a[i-1])+(b[i]-b[i-1])*(b[i]-b[i-1]));
    }
    ans+=1.0*sqrt((a[n]-a[1])*(a[n]-a[1])+(b[n]-b[1])*(b[n]-b[1]));//第n个点和第一个点的距离
    ans+=2.0*r*pi;//圆的周长
    printf("%.2lf",ans);//两位小数
    return 0;
}

```

---

## 作者：Rnin (赞：1)

挺好想的，答案就是一个圆的周长加各条边的和。

因为第`n`条边到第`1`条边比较难计算，所以提前拿出来计算。

```cpp
#include <cmath>
#include <cstdio>

struct Point {
	double x;
	double y;
}point[105];

int n;
double r;
const double pi = 3.1415926535;

double dis(Point a, Point b) {
	return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2)); // 距离公式
}

double js() {
	double sum=0, circle=2*pi*r;
	sum += dis(point[1], point[n]); // 第1条边到第n条边的距离
	for (int i = 1; i < n; i++)
		sum += dis(point[i], point[i+1]);
	return sum + circle;
}

int main() {
	scanf("%d %lf", &n, &r);
	for (int i = 1; i <= n; i++)
		scanf("%lf %lf", &point[i].x, &point[i].y);
	printf("%.2lf", js());
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：1)

**简单读完题后发现这是一道纯模拟题，先说一下我的思路吧：**

**1.计算两点的最短距离，即线段（两点之间线段最短嘛）**

**2.循环完一遍后，加上钉子周长C=2πr**

**3.最后输出（记得要保留两位小数哦）**

------------

**上代码（里面有注释）：**
```
#include <iostream>
#include <iomanip>//保留小数用
#include <cmath>//pow,sprt用 
using namespace std;
const int MAX = 101;
double x[MAX],y[MAX],ans = 0,m;int n;
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= n;i++)cin>>x[i]>>y[i];
	ans += sqrt(pow(x[1] - x[n],2) + pow(y[1] - y[n],2));//第一个点到最后一个点距离计算 
	for(int i = 2;i <= n;i++)ans += sqrt(pow(x[i] - x[i - 1],2) + pow(y[i] - y[i - 1],2));//中间每两点距离计算
	//sqrt(n)n的算术平方根 ;pow(n,m)n的m次方 
	ans += 2 * m * 3.1415926;//加上周长(π多取点没事,别打错就行) 
	cout<<fixed<<setprecision(2)<<ans<<endl;//取两位输出 
	return 0;
}
```


---

## 作者：Deny_小田 (赞：1)

我原本只以为vijos上才有，没想到洛谷上也有==捞了一个。。

思路楼下也已经说清楚了，就是等于n边形的周长+一个钉子的周长。


我来说一句：

本题的结果是有误差的，注意，π不能设为3.14！在vijos上就被坑了。。（可怜我的通过率。。）

π我设的是3.14159265358（够精确了吧QWQ）


然后就AC了，附代码，和楼下的略有不同。



    


```cpp
#include <stdio.h>
#include <math.h>
typedef struct _rope{
    double x,y;
}Rope;
int main(){
    int n,i;
    double j = 0.0,r;
    scanf("%d %lf",&n,&r); 
    j = 3.14159265358*2*r;
    Rope R[n];
    for(i = 0; i < n; i++) scanf("%lf %lf",&R[i].x,&R[i].y);
    for(i = 0; i < n-1; i++){
        j += sqrt((R[i].x-R[i+1].x)*(R[i].x-R[i+1].x)+
                (R[i].y-R[i+1].y)*(R[i].y-R[i+1].y));
    }
    j += sqrt((R[n-1].x-R[0].x)*(R[n-1].x-R[0].x)+
                (R[n-1].y-R[0].y)*(R[n-1].y-R[0].y));
    printf("%.2f",j);
    return 0;
}
PS：这代码是我N个月前写的，现在看来，当时写的代码好嫩啊==
```

---

## 作者：Porsche (赞：1)

下面那位大佬有点嚣张，我来发一个更短的

首先这是一道数学题，我们教给小学生应该都是会做的，绳长可以分为两部分，1. 每个点之间的距离总和，2.钉子的周长。
这样看起来这道题是不是很水了呢？
求1我们要用到的是两点之间的距离公式：sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))，也就是我下面代码里的sqrt((x[i]-x[i-1])*(x[i]-x[i-1])+(y[i]-y[i-1])*(y[i]-y[i-1]))。
求2也很简单，会用到一个我们小学就学过的公式πr²，也就是我下面代码里的2*r*3.14159因为我们并不需要很高的精确度，说实话，我感觉我的π小数点后的位数都有点长了。
话也不多说了，直接出代码吧~

```cpp
#include<bits/stdc++.h>
using namespace std;
double x[101],y[101];//根据题目要求，定义这么多就足够了 
int main()
{
	int n;//“n”需要(int)类型(double)类型会出错
	double r;//“r”需要(double)类型，避免下面会将某(double)类型自动转化成(int)类型
	cin>>n>>r;//输入“n”“r”
	for(int i=1;i<=n;i++)
		cin>>x[i]>>y[i];//输入所有的“x”“y”
	double ans=sqrt((x[1]-x[n])*(x[1]-x[n])+(y[1]-y[n])*(y[1]-y[n]));//被忘了最后一个钉子和第一个钉子之间的距离
	for(int i=2;i<=n;i++)
		ans+=sqrt((x[i]-x[i-1])*(x[i]-x[i-1])+(y[i]-y[i-1])*(y[i]-y[i-1]));//求钉子之间的距离
	ans+=2*r*3.14159;//最后加上钉子一周的长
	cout<<fixed<<setprecision(2)<<ans<<endl;//输出，注意保留两位小数(注：不加“fixed”是指保留两位有效数字，加“fixed”才会保留两位小数) 
	return 0;
}
```

完美，比楼下少了一行~

---

## 作者：Query_Failed (赞：0)

这道题的思路是把绳子的长度分为两部分来计算：

**1.圆弧部分**

**2.线段部分**
 


------------


------------


[P1513题解例](C:\Users\Administrator\Desktop)


# 1.圆弧部分
见上图，做线段部分的垂线，由于绳子最终是********绕了360°********回到起点，因此圆弧部分拼起来后一定是一个半径为r的整圆的周长。

代码如下：

```cpp
 double sum=pi*2*r);
```
# 2.线段部分

由于是做的垂线，所以在图中便出现了许多的矩形。（众所周知，矩形的对边相等）所以线段部分长度实际上就是**两圆心的距离**，可以直接套用距离公式。

代码如下：
```
double dis(int i)
{
    if(i!=n-1) return double(sqrt((a[i]-a[i+1])*(a[i]-a[i+1])+(b[i]-b[i+1])*(b[i]-b[i+1])));
    else return double(sqrt((a[i]-a[0])*(a[i]-a[0])+(b[i]-b[0])*(b[i]-b[0])));
    //距离公式 
}
int main()
{
	for(int i=0;i<n;i++)
    {
        sum+=dis(i);//加上线段长度 
    }
}
```


最后上附AC代码：
```cpp
#include <cmath>
#include <cstdio>
using namespace std;
double a[102],b[102];
int n;
double dis(int i)
{
    if(i!=n-1) return double(sqrt((a[i]-a[i+1])*(a[i]-a[i+1])+(b[i]-b[i+1])*(b[i]-b[i+1])));
    else return double(sqrt((a[i]-a[0])*(a[i]-a[0])+(b[i]-b[0])*(b[i]-b[0])));
    //距离公式 
}
int main()
{
    double r;
	scanf("%d %lf",&n,&r); 
    const double pi=3.141592653535897932384;
    double sum=pi*2*r;//相当于整圆周长 
    for(int i=0;i<n;i++)
    {
    	scanf("%lf %lf",&a[i],&b[i]);
    }
    for(int i=0;i<n;i++)
    {
        sum+=dis(i);//加上每段长度 
    }
    printf("%.2lf",sum);
    return 0;//好 习 惯 
}
```














---

## 作者：fighter_OI (赞：0)

#详细思路：

因为要无缝隙地绕过每个钉子，所以每段直的绳子应与每个圆相切。

所以过切点的半径与绳子垂直

半径，绳子，两圆心距离构成矩形

所以直绳长等于两圆心距离，

通过平移，可将曲线绳长拼成一圆周

##即以所有圆心为顶点的多边形周长加上圆周长

```cpp
 uses math;//系统自带的π，精度没问题
var x,y:array[1..1000] of double;
    l,r:double;
    n,i:longint;
begin
 read(n,r);
 read(x[1],y[1]);
 l:=0;
 for i:=2 to n do
  begin
   read(x[i],y[i]);
   l:=l+sqrt((x[i]-x[i-1])*(x[i]-x[i-1])+(y[i]-y[i-1])*(y[i]-y[i-1]));
  end;
 write(l+sqrt((x[1]-x[n])*(x[1]-x[n])+(y[1]-y[n])*(y[1]-y[n]))+2*r*pi:0:2);
end.
```

---


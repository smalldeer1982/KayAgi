# [NOIP 2010 提高组] 机器翻译

## 题目背景

NOIP2010 提高组 T1

## 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

## 说明/提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

## 样例 #1

### 输入

```
3 7
1 2 1 5 4 4 1
```

### 输出

```
5
```

# 题解

## 作者：Apun (赞：501)

由于本题数据范围较小，我们可以用指针的方法做。

注：本文中的“指针”指的是“指针的思想”，并不是“指针类型”的“指针”。

先开两个数组，一个数组a存标记，在读入单词x时，若当前数组a中的第x位的标记为“1”，则表示该单词在内存中，若标记为“0”，则表示该单词不在内存中，这样做就可以一步判断读入的单词在当前是否在内存中，而不必从头到尾找。这样做还有一个好处，在存入单词时只需要把数组a中的第x位的标记“0”改为“1”，而在删去内存中的单词x时，只需要把数组a的第x位的标记“1”改为“0”，这样就可以做到一步到位，大大降低时间复杂度，提高程序效率。这是本题的关键之一，需要各位好好体会体会，理解理解。

再说另一个数组b。数组b存储的是内存中的单词，而且要按读入顺序存入，如b[1]中存储的单词x是在时间1存入的。要注意的是，若当前读入的单词x已经在内存中（即a[x]==1）那就不用存入数组b中，遇到内存中没有的新单词才存入。

接下来要讲指针。指针有两个，一个是l，指向当前内存中的单词中最先一个存入的，如b[l]是当前内存中第一个存入的。另一个是r，指向当前内存中的单词中最后一个存入的，如b[r]是当前内存中最后一个存入的。所以，数组b的第l位到第r位存储的就是当前内存中的单词。

遇到新单词时（即a[x]==0），情况有两种：

1.内存没被用完(即r<=m)。此时指针r向右移一位，在b[r]中存入新单词，并在数组a中把单词x的标记改为1；

2.内存已满（即r>m）。此时先删去当前内存中最先存入的单词（b[l]）。删除操作不用太复杂，只需要先把指针l向右移一位，然后再修改a数组的第b[l]位的标记就可以了，可联系上文加深理解。不要忘了最后在b[r]中存入新单词x。

这题大概就是这样做了，如果你感觉可以自己AC掉，就先不要看以下程序，自己试着打打程序。如果WA了就再认真看看上文，如果AC了就把你的程序和以下程序对比对比，看看有什么可以改进的地方。


代码如下：

    
    
```cpp
    #include <iostream>
    #include <stdio.h>
    #include <algorithm>
    using namespace std;
    int n,m,x,ans,l,r,a[1005],b[1005];
    int main()
    {
        cin>>m>>n;
        l=0;r=0;//初始化两个指针
        for (int i=1;i<=n;i++)
         {
             scanf("%d",&x);//边读入边做
             if (a[x]==0) 
             {
                 ans++;
                r++;b[r]=x;a[x]=1;//因为每次遇到新单词都要做这些操作，不如搬到判断语句外做，这样程序更简洁
                if (r>m) {l++;a[b[l]]=0;}
             }
         }
        cout<<ans;
        return 0;//千万不能忘记打这句，不然在比赛中会出错
}
```

---

## 作者：Anguei (赞：213)

此题现有的模拟做法好麻烦啊。我来补充一个 STL 做法。

**主要思路是**：
+ 使用一个 vector 来表示内存。
+ 依次读如数据，判断是否在内存中（find）。如果不在，就需要查词典，然后加入内存、将答案 + 1。
+ 如果内存满了，就把最先进入内存的单词删掉（erase）

至此，思路分析完毕，贴上不到 $20$ 行的 AC 代码。
```cpp
#include <vector>
#include <iostream> 
#include <algorithm>

int main() {
	int m, n, t, ans = 0;
	std::cin >> m >> n;
	std::vector<int> v; // 用来表示内存
	while (std::cin >> t) {
		if (std::find(v.begin(), v.end(), t) == v.end()) { // 如果不在内存中
			v.push_back(t); // 加入内存
			++ans;
		}
		if (v.size() > m) // 内存满了
			v.erase(v.begin()); // 把第一个单词删掉
	}
	std::cout << ans << std::endl;
}
```

---

## 作者：Neoomgg (赞：34)

之前AC过一次，今天又来看这题，顿悟出一种绝妙的方法。

核心点：用当前查找次数 对 内存大小 取余，就是……（此处省略许多乱七八糟的解释，直接见代码）

---

（上面是一条蟒蛇——<）

```python
m, n = map(int, input().split())
w = [None] * m
t = list(map(int, input().split()))
d = 0
for i in range(n):
    if w.count(t[i]) == 0:
        w[d%m] = t[i]
        d += 1
print(d)
```

---

## 作者：JCT_addyi (赞：7)

## 题目大意：

题目讲的是有一个内存为 $m$ 的字典，要把 $n$ 个单词存入字典。如果内存不够了的话，把最先存入的单词清除，再把新的单词存入字典。

## 思路：

看到样例后想到的是队列。

#### 什么是队列：

队列的存取方式是先进先出，只能向队尾插入数据，从队头移出数据，样例就是这样模拟的。

先把单词都从队尾存入，存一个标记一下，计数器加一，如果满了，就从对头清除，标记清除，再把单词从队尾加入。

代码纯模拟如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h[1005]={0}; //模拟内存中有没有这个单词  h[i]=1表示单词i在内存中 
queue<int>tjc;//用队列模拟内存 
int main(){
    int m,n;
    cin>>m>>n;
    int cnt=0;//查词典的次数 
    while(n--){
    	int en;
    	cin>>en;     
    	if(h[en]==0){ //如果内存中没有这个单词 
    		++cnt;
    		tjc.push(en); //把单词存入队列中 
    		h[en]=1;  //记录 
    		while(tjc.size()>m){ //内存满了 
    			h[tjc.front()]=0;//返回对头元素去掉单词 
    			tjc.pop();//删除单词 
			}
		}
	}
	cout<<cnt;
return 0;
}
```

谢谢大家！

---

## 作者：OIerWu_829 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1540)

用 $vis$ 数组标记每个数在内存中的状态，再用队列模拟内存。每次输入一个数，如果它不在内存中，那么就把它打上标记，并加入队列。如果此时队列长度 $>m$，那么就把第一个元素换一下标记并从队列中移除。统计次数输出即可。

```cpp
#include <iostream>
#include <queue>
using namespace std;

const int N = 1005;

bool vis[N];
queue<int> q;

int main()
{
    int n, m;
    cin >> n >> m;
    int ans = 0;
    for (int i = 1; i <= m; i++)
    {
        int x;
        cin >> x;
        if (!vis[x])
        {
            ans++;
            q.push(x);
            vis[x] = true;
        }
        if (q.size() > n)
        {
            vis[q.front()] = false;
            q.pop();
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Ray_yi (赞：5)

[队列](https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481?fr=aladdin)

### 思路：

由题目可知，如果内存中的数的总数大于了 $m$ 需要把最先进入内存的数删除，然后再进。所以，就可以很容易想到用队列去做。

我们可以用一个数组来标记输入的词有没有在内存中出现过，如果出现过，就直接判断下一个词，如果没有出现，就先判断队列中的单词数有没有超过限制，如果超过限制，就删除队首元素，否则，直接加入内存。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int> a;
int m,n,x,ans;
bool t[10000];//标记数组 
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		if(t[x]) continue;//内存中有这个词 
		if(a.size()>=m){ //内存中单词数超过了m 
			t[a.front()]=0;//取消标记
			a.pop();//弹出
		}
		a.push(x);//加入内存 
		t[x]=1,ans++;//标记存在，并把计数器+1 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：wowzbh (赞：4)

## 使用queue队列与set容器求解---Java

本题是一道简单的模拟题，模拟题说白了就是模拟出题目中的环境与操作，必要情况下可以为模拟操作来创建所需的环境。通过审题我们不难看出本题需要模拟的环境是<待译文章>、<内存单元>，需要模拟的操作为<通过查字典将新单词添入的内存单元>、<将存在时间最长的单词移出内存单元>。
   - <待译文章> 待译文章包含在输入内容中，我们可以将它一次性读入一个数组中，之后整体再做处理，也可用循环一个一个单词的边读入边处理。
   - <内存单元> 我们可以根据需要模拟的操作，选取适当的容器来模拟内存单元。由于存在<将存在时间最长的单词移出内存单元>这个特殊性的操作，所以使用队列先入先出的特性来模拟该操作。
   - <通过查字典将新单词添入的内存单元> 这个操作中重要的是新单词，也就是说内存单元里存在的单词不能填入内存单元，这就需要判断一个是否可以添入其中，我们可以将使用set容器，让set容器与内存单元中的元素保持一致，利用set容器中元素的不可重复性，来判断是否添入新单词到内存单元中。
   - <将存在时间最长的单词移出内存单元> 由于我们根据这个操作选取了queue容器，直接使用queue容器自带的方法即可模拟。


至此我们模拟完了所有的环境与操作，最后输出题解即可。
Java代码如下
```java
import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args) throws IOException {
        StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        Set <Integer> s = new HashSet<Integer>();
        Queue <Integer> q = new LinkedList<Integer>();
        st.nextToken();
        int n = (int)st.nval;
        st.nextToken();
        int m = (int)st.nval;
        Integer t;
        int cout = 0;
        for(int i = 0,f = 0; i < m; i++) {
            st.nextToken();
            t = (int)st.nval;
            if(q.isEmpty()) {
                q.add(t);
                s.add(t);
                f++;
                cout++;
            }
            else {
                if(f < n && s.add(t)) {
                    q.add(t);
                    f++;
                    cout++;
                }
                else if(f == n && s.add(t)) {
                    q.add(t);
                    s.remove(q.remove());
                    cout++;
                }
            }
        }
        System.out.println(cout);
    }
}
```

  
  

---

## 作者：Co_Ce (赞：2)

# solution
[传送门](https://www.luogu.com.cn/problem/P1540)
## 思路
我们可以用队列 $q$（即内存）加数组 $flag$ 来模拟一下。  
首先，读入每一个单词 $x$。  
然后，判断如果 `flag[x]=1` 代表 $x$ 在内存里，直接跳过；如果 `flag[x]=0` 代表 $x$ 不在内存里，需要查词典，把 $x$ 压入队列，答案加 $1$。  
最后，特判一下，如果 `q.size()>m` 先把 `flag[q.front()]` 记为 $0$，再把 `q.front()` 弹出。 
## std：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,x,ans,flag[1010];
queue<int>q;
int main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>m>>n;
    for(int i=1;i<=n;i++){
    	cin>>x;
    	if(flag[x]==1){
    		continue;
		}
		else{
			ans++;
			q.push(x);
			flag[x]=1;
			if(q.size()>m){
				flag[q.front()]=0;
				q.pop();
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

模拟数据结构题。

发现内存记录单词的过程是先进先出的，可以用队列维护，同时记录 $vis_i$ 表示单词 $i$ 是否在队列里。对于每次读入的单词，如果不在队列里就要入队，打标记，答案加一，同时保证队列元素不超过 $m$ 个。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[1010];
int m, n, x, ans;
queue<int> q;
int main(){
    cin >> m >> n;
	while(n--&&cin >> x){
		if(!vis[x])
			q.push(x),
			vis[x]=1,
			ans++;
		if(q.size()>m)
			 vis[q.front()]=0,
			 q.pop();
	}
	cout << ans;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
指针的思想来做是很好的。

边输入边做题，判断每一个输入的数，这数的桶是否为零，如果是，计数器加一，指针的右边也加一，在 $b$ 数组中存入新单词。并在桶中将这个单词标记成 $1$。

如果内存已满，此时就先删去当前内存中最先存入的单词，让左指针右移一位，将这个位置的单词标记回零。

---

### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1001;
int a[MAXN], b[MAXN], m, n, x, ans = 0, l = 0, r = 0;

int main() {
	cin >> m >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		if (a[x] == 0) {
			ans++;
			r++;
			b[r] = x;
			a[x] = 1;
			if (r > m) {
				l++;
				a[b[l]] = 0;
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：ridewind2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1540)

## 思路

我们可以用指针的思想和 map 来做。

判断每一个数，这数的 map 里的值是否为 $0$。如果是，将答案 $ans$ 加 $1$，右指针加 $1$，把这个单词标记为 $1$，在数组中存入单词。

如果右指针比 $m$ 大，删掉当前最先存入的单词，左指针加 $1$，将第左指针个单词标记回零。

直接输出答案即可。

## 代码

```cpp

#include<bits/stdc++.h>
using namespace std;
map<int,int>mp;
int a[1010];
int main(){
    int m,n,ans=0,l=0,r=0;//ans 是答案，l 是左指针，r 是右指针
    cin>>m>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        if(mp[x]==0){
            ans++,r++,mp[x]++,a[r]=x;
            if(r>m)l++,mp[a[l]]=0;
        }
    }
    cout<<ans;//输出答案
    return 0;
}

```

---

## 作者：hbdcsd (赞：1)

## 思路

仔细读题，当内存不够，软件会清空最早进入内存的单词，这明显是先进先出，可以使用队列来模拟。

再读题，本题有在内存中查找的需求，而队列没有这种功能，又发现文章每个数不大于 $1000$，想到开一个数组储存每一个单词是否在内存内。

队列的相关操作：

1. `push` 函数可以把一个元素放在队尾；

2. `pop` 函数可以把一个元素从队头弹出。 

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <climits>
#include <string>
#include <cstring>
#include <cstdlib>
#include <queue>
using namespace std;
int m, n, x, ans;
int vis[1005];
queue<int> q;
int main(){
	cin >> m >> n;
	while (n--){
		cin >> x;
		if (vis[x] == 1) continue;
		else {//当内存中没有该单词
			ans++;//答案加 1
			if (q.size() >= m){//当内存不够
				vis[q.front()] = 0;//清空队首单元
				q.pop();
			}
			q.push(x);//将新单词放入内存中
			vis[x] = 1;
		}
	}
	cout << ans;
	return 0;
}
```

---


# 赛跑

## 题目背景

赛跑

## 题目描述

SH的跑步成绩一直不太理想。为了帮助SH提高成绩，KC决定和他进行一次赛跑。比赛的起点设在农场主的屋前，他们同时出发，沿着同一方向，直到跑到终点----农场远处的一棵树下。

他们的跑步速度在一些时间段内是恒定的。比如：SH在前３个时间段速度是５，接着６个时间段内速度是１０。他们的比赛总时间相同。他们希望能统计出在整个比赛过程中领先顺序的变化次数。举个例子，某个时刻SH领先，下个时刻KC领先，这就是一次领先顺序的变化；如果某个时刻SH领先，接下来一段时间KC赶上来并和SH齐头并进，但最终还是超过了SH，这也是一次领先顺序的变化。


## 说明/提示

输入：SH在前 $2$ 个单位时间内速度是 $1$，接着 $1$ 个单位时间内速度是 $4$，接着 $1$ 个单位时间内速度是 $1$，最后 $10$ 个单位时间内速度是 $2$。KC在前 $3$ 个个单位时间内速度是 $2$，接着 $2$ 个单位时间内速度是 $2$，最后 $9$ 个单位时间内速度是 $3$。

输出：比赛开始后KC领先，直到第 $5$ 个单位时间SH超过KC（第一次领先顺序变化），接着第 $7$ 个单位时间时，KC又反超SH，变成领先（第二次领先顺序变化）。


## 样例 #1

### 输入

```
4 3
1 2
4 1
1 1
2 10
2 3
1 2
3 9
```

### 输出

```
2```

# 题解

## 作者：sdxjzsq (赞：92)

# 话说第一次写题解实在激动

## 本题思路

首先读入n和m，然后读入SH的速度vn[i]和持续时间tn[i]，之后读入KC的速度vm[i]和持续时间tm[i]，但是在读入KC数据的同时，我们便开始处理数据，大概思路就是定义两个变量wn = 0, wm = 0来存储两个人分别已经跑过的距离，然后比较，如果wn-wm的符号改变了，那么ans++。其他的细节请看下面的代码注释。

## 代码+细节解释

```cpp
#include<cstdio>
using namespace std;
int n, m, wn = 0, wm = 0, vn[1001], tn[1001], vm[1001], tm[1001];
//wn:SH已经跑过的距离，wm:KC已经跑过的距离
//vn[]/vm[]:SH和KC的移动速度
//tn[]/tm[]:SH和KC移动速度的持续时间
int nt = 1, mt = 1, z = -1, ans = -1;
//nt:当前使用哪个vn[]的值,mt:当前使用哪个vm[]的值
//z:是谁领先(1:KC领先 0:SH领先)
//可以通过看z是否改变来判断是否改变
//ans:改变次数
//为什么ans初始值是-1？
//因为z的初始值是-1，即两个人都没有领先，
//然后在跑步过程中，肯定会有某个人开始领先，这时候并没有改变顺序，
//但是ans仍然要+1，为了解决这一问题，将ans初始值置-1。
int work(int x)
//返回x的符号，这里的x是SH和KC距离之差（见下面定义s那行）
//如果大于0返回1，如果小于0返回0，如果等于0返回z的值
//返回z的值的原因：
//因为当距离相等的时候，没法决定返回0还是1，这时候还没有谁超过谁，
//并且我们我们不知道在距离差距不为0的时候是谁领先，所以直接返回z，
//即返回上一个状态
{
    if (x > 0)return 1;
    else if (x == 0)return z;
    return 0;
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &vn[i], &tn[i]);
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d", &vm[i], &tm[i]);
        while (mt <= i)//mt>i的情况还没有读入
        {
            if (tm[mt] == 0 && mt <= m + 1)
            {
                mt++;//如果这个速度的持续时间用完了，就将mt++
                continue;
                //一定要加上面一行，这可以保证mt>i，否则会导致“越界”
                //不是真的越界，只是还没有读入
            }
            if (tn[nt] == 0 && nt <= n + 1)nt++;//和上面一样的道理
            wm += vm[mt];
            tm[mt]--;
            wn += vn[nt];
            tn[nt]--;
            //距离+vm/vn，时间-1
            int s = wm - wn;//计算距离的差
            if (work(s) != z)//如果领先程度改变，则ans++
            {
                ans++;
                z = work(s);
            }
        }
    }
    if (ans == -1)ans = 0;
    //如果距离一直相等，会导致ans一直没有改变，这里将ans置0
    printf("%d", ans);
    return 0;
}
```

---

## 作者：wyk0247 (赞：81)

看到这个题，我的思路是将每个时刻两人！跑过的！路程算出来，再看他们跑过的路程的大小关系是否变化，变化则次数加1

OK，开始解题：

First：读入m，n:
```cpp
scanf("%d%d",&m,&n);
``` 
Second:精华部分来咯~~~~开始计算每个时刻第一个人跑过的路程：
```cpp
for(int i=1;i<=m;i++)
{
	scanf("%d%d",&x,&y);//速度和持续时间
	for(int j=1;j<=y;j++)
	a[k+j]=a[k+j-1]+x;//已经跑了k个时刻，用k+j个时刻跑过的路程等于前一个时刻(k+j-1)加上一个时刻跑的路程
	k+=y;//更新已经跑过的时刻数
}
```
Third：计算每个时刻第二个人跑过的路程（方法同上）

因为第二个人开始跑，所以k一定要归零！！！！！！：
```cpp
k=0;
for(int i=1;i<=n;i++)
{
	scanf("%d%d",&x,&y);
	for(int j=1;j<=y;j++)
	b[k+j]=b[k+j-1]+x;
	k+=y;
}
```
Fourth：开始扫描每个时刻两人已经跑过的路程的大小关系：
```cpp
for(int i=1;i<=k;i++)
{
	if(a[i]>=b[i])//若第一个人在前，flag=1
	flag[i]=1;
	if(a[i]<b[i])//若第二个人在前，flag=2
	flag[i]=2;
	if(flag[i-1]!=flag[i])
	ans++;//如果大小关系发生了改变，则次数加一
}
```
Fifth：输出答案：
```cpp
printf("%d",ans-1);//因为flag[0]=0,falg[1]不可能为0，只可能为1或2，所以flag[0]到flag[1]多加了1，所以要减掉1（这个很重要哟）
```
就是因为第一次提交没有意识到多加了1，结果全WA，第二次才AC> <

so,献上完整代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int m,n;
int x,y;
int a[1000100],b[1000100],flag[1000100];
int k=0;
int ans=0;
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		for(int j=1;j<=y;j++)
		a[k+j]=a[k+j-1]+x;
		k+=y;
	}
	k=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		for(int j=1;j<=y;j++)
		b[k+j]=b[k+j-1]+x;
		k+=y;
	}
	for(int i=1;i<=k;i++)
	{
		if(a[i]>=b[i])
		flag[i]=1;
		if(a[i]<b[i])
		flag[i]=2;
		if(flag[i-1]!=flag[i])
		ans++;
	}
	printf("%d",ans-1);
	return 0;
}
```
谢谢大家，希望我的题解对大家有所帮助

---

## 作者：heidoudou (赞：14)

这题我耗了很久。主要的教训是，**一开始视图以最优的方式解决这个问题，导致一些细小的bug很难调试**。

后来从最笨的方法入手，先 AC了， 然后调优， 最后发现优化后的代码比之前苦思冥想试图写的最优代码还要好看一些。


这题的主要难点是， 输入的速度、时间都是随机片段的，两人的时间点对不上！所以无法直接判断在某个时间点上谁前谁后。

最笨的方法是模拟每一秒的情况，依次耗尽各自的时间片段，计算每一秒每个人的位置。

这是最笨但是出错率最低的方法。 AC 之后可以尝试优化。

这时候优化也很容易了： 不必模拟每一秒的情况。 每次取 两人时间片段的最小值， 消耗掉就可以了。


```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

#define MAX_N 1001

int main()
{
    int n, m;
    int i, j;  // track step

    int s1[MAX_N], s2[MAX_N];  // speed
    int t1[MAX_N], t2[MAX_N];  // time interval

    scanf("%d %d", &n, &m);
    for (i = 1; i <= n; i++)
        scanf("%d %d", &s1[i], &t1[i]);
    for (i = 1; i <= m; i++)
        scanf("%d %d", &s2[i], &t2[i]);

    int t;  // min time interval
    int d1 = 0, d2 = 0;
    int state = -1, change = -1;
    for (i = 1, j = 1; i <= n && j <= m; )
    {
        t = min(t1[i], t2[j]);

        d1 += s1[i] * t;
        d2 += s2[j] * t;

        if (d1 != d2 && (d1 > d2) != state)
        {
            state = (d1 > d2);
            change++;
        }

        t1[i] -= t;
        t2[j] -= t;

        if (t1[i] == 0) ++i;
        if (t2[j] == 0) ++j;
    }
    if (change == -1) change = 0;
    printf("%d", change);
}
```


---

## 作者：Dvelpro (赞：11)

/\*
思路：用两个数组分别储存每个单位时间两人的跑的路程  再用c数组来表示谁在前

谁在后  最后遍历c数组就能找到变换次数了 感觉很好理解的思路吧

\*/



```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[2000001]={0},b[2000001]={0},c[2000001]={0};
int main(){
   long long m,n,j,k,l,i,r,s;
     cin>>m>>n;
   k=1;
   for(j=0;j<m;j++){
      cin>>l>>i;
      while(i--){
         a[k]=a[k-1]+l;  //  储存第一个人每个单位时间的路程
         k++;
      }
   }
   r=1;
   for(j=0;j<n;j++){
      cin>>l>>i;
      while(i--){
         b[r]=b[r-1]+l;       ///  储存第一个人每个单位时间的路程
         r++;
      }
   }
   l=min(k,r);
   i=max(k,r);
   for(j=1;j<=l;j++){         ///第一个人在前面用1 表示
      if(a[j]>b[j]){
         c[j]=1;
      }
      else if(a[j]<b[j]){      ///第二个人在前面用 -1 表示
         c[j]=-1;
      }
      else  c[j]=c[j-1];     /// 如果等于让他等与前面的数值
   } 
   for(j=l+1;j<=i;j++){      ///有可能 两个人的时间不同 让剩下的在存到c里
      if(k>r){
          if(a[j]>b[l]){
             c[j]=1;
          }
          else if(a[j]<b[l]){
             c[j]=-1;
          }
          else  c[j]=c[j-1];
      }
      if(k<r){
         if(a[l]>b[j]){
             c[j]=1;
          }
          else if(a[l]<b[j]){
             c[j]=-1;
          }
          else  c[j]=c[j-1];
      }
   }
   s=0;
   for(j=1;j<i;j++){         ///遍历c
      if(c[j]!=c[j+1]){
         //cout<<j<<" "<<c[j]<<endl;
         s++;
      }
   }
   cout<<s<<endl;
   return 0;
}

```

---

## 作者：Soyilieber (赞：10)

感觉你们的题解十分长 又复杂，来发一个简单模拟

~~（水题题解，望管理大佬们通过放心，给小人一次机会）~~

代码如下，含注释：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,pn,pm,vn[1001],vm[1001],tn[1001],tm[1001],dn,dm,ans;//挺多变量的 
bool rec;//记录 SH>KC=0 SH<KC=1 
int main(){
	scanf("%d%d",&n,&m);//读入 
	for (int i=1;i<=n;i++){
		scanf("%d%d",&vn[i],&tn[i]);//读入 v速度 t时间 
	}
	for (int i=1;i<=m;i++){
		scanf("%d%d",&vm[i],&tm[i]);//同上 
	}
	pn=pm=1;//指针 初始第一个 
	for (int i=0;;i++){//死循环 
		tn[pn]--;//SH当前时间减少1 
		tm[pm]--;//KC当前时间减少1 
		dn+=vn[pn];//SH路程加 
		dm+=vm[pm];//KC路程加 
		if (!tn[pn]) pn++;//时间没了，指针就往下移一位 
		if (!tm[pm]) pm++;
		if (i==0&&dn>dm) rec=0;//初始化REC记录，很重要，就是这里没弄好就只有50-60分 
		else if (i==0&&dn<dm) rec=1;//不然为1 
		if (dn<dm&&!rec) rec=!rec,ans++;//如果SH<KC 改变REC 加ans 
		else if (dn>dm&&rec) rec=!rec,ans++;//如果SH>KC 改变REC 加ans 
		if (pn==n+1||pm==m+1) break;//其中一个人跑完了就退出 
	}
	printf("%d\n",ans);//输出 
	return 0; 
}
```

---

## 作者：张皓涵 (赞：7)

这题可以很轻松地暴力过掉，枚举每一秒，只能说是数据太水了 ~~（我是不会说因为我想不到优化的）~~  具体看代码！
```cpp
#include<iostream>
using namespace std;
int SH[10000001]; //SH每一秒的速度
int KC[10000001]; //KC每一秒的速度
int n,m,SHcnt,KCcnt; //SHcnt是SH的速度更新到了第几秒，KCcnt同理
int SSH,SKC,ans; //SSH表示SH的路程，SKC同理
int flag; //1表示SH领先，0表示KC领先
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int aa,bb;
		cin>>aa>>bb;
		for(int j=1;j<=bb;j++)
			SH[++SHcnt]=aa;
	} 
	for(int i=1;i<=m;i++)
	{
		int aa,bb;
		cin>>aa>>bb;
		for(int j=1;j<=bb;j++)
			KC[++KCcnt]=aa;
	}  //读入不解释啦
	if(SH[1]>KC[1]) flag=1; else flag=0; //预先做出flag，因为第一秒超过不算变化
	for(int i=1;i<=SHcnt;i++)
	{
		SSH+=SH[i];
		SKC+=KC[i]; //算路程
		if(SSH>SKC&&flag==0) ans++,flag=1; //若此刻SH领先，且之前KC领先，发生变化
		if(SSH<SKC&&flag==1) ans++,flag=0; //同上
	}
	cout<<ans; //愉快地输出！
}
```

---

## 作者：buickboy (赞：7)

#### 争做最简洁最好懂题解！全部代码34行！

首先要准确理解题意，题目已经明确时间是相同的，赛跑的路段是相同的，但是，**总路程是不同的**！因为**只要有人到达终点，赛跑就结束了！**

本题有两个关键点。**第一，领先顺序如何判断？** 双方谁领先，实际上就是谁的路程多！**第二，领先顺序的变化如何判断？** 设置变量f记录初始领先状态，检查每个单位时间的大小关系，如果发现大小关系与变量f表示的关系不一致，就说明领先顺序发生了变化。

那么就有思路：模拟每一秒，判断谁跑过的路程多，路程一直多的人某一秒后变的比对方少了，显然就说明对方超过他了。由于要模拟每一个单位时间，而速度就是单位时间内的路程，所以可以直接将速度相加，这不就是**前缀和**么！

下面分析样例，如下图，每个单位时间里，双方跑的路程也在相应发生变化，这就是在第5和第7个单位时间发生领先顺序变化的原因。


![每一秒分析](http://s14.sinaimg.cn/mw690/001x7Roezy7vSJUyRoF9d&690)

注意有几个坑点：
一是**模拟路程数组要开大**，因为要拆分到每1秒记录相应的路程，最大范围就应是1000*1000。

二是要**准确标记首次的领先顺序**，因为前几秒可能都相等，要用循环，一直找到不相等时再记录位置。

三是找到领先顺序变化后，记录次数的同时，要**相应更新标记的状**态f。


```cpp
#include <iostream>
using namespace std;
int a[1000010], b[1000010], f, tm, n, m;//数组要开1000*1000
void read(int *p, int x)
{ //读入数组并计算前缀和，优先的程序员不写重复代码
    int k = 0, v, t;
    while (x--)//x个时间段，对应n和m
    {
        cin >> v >> t;//相应速度与持续时间
        while (t--)//将持续的时间拆成单位时间
            p[++k] = v, p[k] += p[k - 1];//填充到路程数组并计算前缀和
    }
    tm = k; //存储总时间
}
int main()
{
    int i, k = 0;
    cin >> n >> m;
    read(a, n);               //读入a数组并计算前缀和
    read(b, m);               //读入b数组并计算前缀和
    for (i = 1; i <= tm; ++i) //查找首次领先
        if (a[i] != b[i])     //发现领先
        {
            f = a[i] > b[i] ? 1 : 0; //标记谁领先
            break;                   //停在第一次不相等的位置
        }
    for (++i; i <= tm; ++i)//从下一个单位时间开始比较
        if (a[i] > b[i] && !f)     //a领先但标记是b领先
            k++, f = 1;            //记数，更新标记状态为a领先
        else if (a[i] < b[i] && f) //b领先但标记是a领先
            k++, f = 0;            //记数，更新标记状态为b领先
    cout << k;                     //输出解
    return 0;
}
```


---

## 作者：zhaowangji (赞：5)

这题已经挂在我的任务列表里很久了。。。

一直觉得很难~~红题果然不同凡响~~但敲了敲其实也还可以

主要就是存储两人已走距离，指针遍历跑步，立个flag记录谁跑得快

```cpp
#include<iostream>
using namespace std;
int n,m;
struct node{
	int ti;//时间
	int di;//每秒的距离
}a[1007],b[1007];//两个人
int s1,s2;//两人已走距离
int h1=1,h2=1;//指针初始都为1
int flag;
int ans;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>a[i].di>>a[i].ti;
	for(int i=1;i<=m;i++)
	cin>>b[i].di>>b[i].ti;
	while(h1<=n&&h2<=m){
		if(a[h1].ti==0)h1++;//到了下一个阶段
		s1+=a[h1].di,a[h1].ti--;//跑了一秒，加上这一秒的距离
		if(b[h2].ti==0)h2++;//同上
		s2+=b[h2].di,b[h2].ti--;//同上
		if(flag==0)s1>s2?flag=1:flag=2;
        	//flag为0是初始状态
            	//等同于if(s1>s2)flag=1;else flag=2;
		else {
			if(s1<s2&&flag==1)flag=2,ans++;
            		//原是SH领先，现在变成了KC
			if(s1>s2&&flag==2)flag=1,ans++;
            		//原是KC领先，现在变成了SH
		}
	}
	cout<<ans<<endl;//输出答案即可
	return 0;
}
```


---

## 作者：Shikita (赞：5)

# 显而易见的一道模拟题
只要分别读入两人的每一段跑步状态，再枚举每一秒，比较两人状态即可得出
## 代码
```
#include<bits/stdc++.h>
using namespace std; 
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;   c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int n,m,ttime=0,tot=0;
//ttime记录总时间,tot记录答案
int ans1,ans2,cnt1=1,cnt2=1,t1,t2;
//ans表示两人的路程，cnt表示当前的阶段,t表示状态转移的时间点
struct node{
	int v,t;
}n1[1005],m1[1005];
bool judge(int x,int y)
{
	if(x>y) return 1;
	else return 0;
}//比较函数,可以知道两人的先后顺序
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;++i)
	  n1[i].v=read(),n1[i].t=read(),ttime+=n1[i].t;
	for(int i=1;i<=m;++i) 
	  m1[i].v=read(),m1[i].t=read();
	bool flag;//记录两人的先后顺序
	if(n1[1].v>m1[1].v) flag=1;
	else flag=0;
	t1=n1[1].t,t2=m1[1].t;//初始化
	for(int i=1;i<=ttime;++i)//枚举每一秒的状态
	{
		ans1+=n1[cnt1].v;
		ans2+=m1[cnt2].v;//通过的总路程
		if(judge(ans1,ans2)!=flag) tot++,flag=!flag;
        //如果两人先后发生变化，记录下当前状态，更新答案
		if(i==t1) cnt1++,t1+=n1[cnt1].t;
		if(i==t2) cnt2++,t2+=m1[cnt2].t;
        //各自进入下一状态
	}
	cout<<tot<<endl;
}
```

希望大家支持一下我这个小萌新哦，谢谢

---

## 作者：时间圣使·凡 (赞：4)

### 这个题解很随便
 这个赛跑，其实很简单。
 先讲一下我的想法，把每个单位时间模拟一下，然后暴力再暴力，最后输出。
 首先把SH的速度存在一个记录每个时间的跑步长度的数组（我用f1），然后再把KC的速度存在一个记录每个时间跑步长度的数组里（我用f2）
 最后while暴力模拟每个单位时间。
 还有一个问题，我也不太清楚，到底把领先的追平后，领先的再领先，要不要多算一次？测试数据里似乎没有考察这一点。
 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,maxs,ans,j=1,f,l1,l2,f1[2000000],f2[2000000];
int main(){
	cin>>n>>m;
	for(int t1=0,i=1;i<=n;++i){
		int x,y,mi=t1+1;cin>>x>>y;
		t1+=y;
		for(;mi<=t1;++mi) f1[mi]=x;
		maxs=max(maxs,t1);
	}//组装第一个数组 
	for(int t2=0,i=1;i<=m;++i){
		int x,y,mi=t2+1;cin>>x>>y;
		t2+=y;
		for(;mi<=t2;++mi) f2[mi]=x;
		maxs=max(maxs,t2);
	}//组装第二个数组 
	l1=f1[1],l2=f2[1];
	if(l1>l2) f=1;
	if(l2>l1) f=2;//第一个时间单位事先模拟好 
	while(maxs--){//暴力 
		j++;
		l1+=f1[j];//加上当前时间跑的距离 
		l2+=f2[j];//加上当前时间跑的距离 
		if(l1>l2&&(f==2||!f)) ans++,f=1;//SH反超KC. 
		else if(l1<l2&&(f==1||!f)) ans++,f=2;//KC反超SH 
		else if(l1==l2) f=0;//这个就是疑惑点，去掉也正确，不信你试试 
	}
	cout<<ans;//输出 
	return 0;
}
```

---

## 作者：北北北北 (赞：2)

处理好怎么对一个最短时间进行分段，并且设置好每个人他在每段时间

内的速度，然后求和，当sh所跑的距离和>kc所跑的距离和则领先顺序

变化次数就+1，当sh所跑的距离和<kc所跑的距离和则领先顺序变化次

数就+1，当然这两个条件是建立在两个基础条件上的，如第一个条件是

建立在sh被kc领先的条件上的，第二个条件是建立在kc被sh领先的

条件上的。

注意：初始时，不要改变领先顺序变化次数，只要得到sh和kc之间的

关系（sh领先kc，kc领先sh）就可以了。

下面附实现代码：


------------
```c
#include <stdio.h>

int main(void)
{
	int kc[1000][2];
	int sh[1000][2];
	int i,j,k,n,m,tmin;
	int flag = 0,stsum = 0,ssum = 0,ktsum = 0,ksum = 0,count = 0;
	
	scanf("%d %d", &n,&m);
	for(i = 0; i < n; i++)
	{
		scanf("%d %d", &sh[i][0],&sh[i][1]);
		stsum += sh[i][1]; //sh所花费的总时间
	}
	for(i = 0; i < m; i++)
	{
		scanf("%d %d", &kc[i][0],&kc[i][1]);
		ktsum += kc[i][1]; //kc所花费的总时间
	}
	tmin = ((stsum<ktsum)?(stsum):(ktsum)); //最短时间
	for(i = j = k = 0; i < tmin; i++)
	{
		if(i < sh[0][1]) //判断当前时间i是否处在(上个时间,sh[0][1])段内 
		{
			ssum += sh[j][0]; //在,那么就加上这个时间段上的速度 
		}
		else
		{
			j++;
			ssum += sh[j][0]; //不在,那么就加上下个时间段上的速度 
			sh[0][1] += sh[j][1]; //更新时间段 
		}
		if(i < kc[0][1])
		{
			ksum += kc[k][0];
		}
		else
		{
			k++;
			ksum += kc[k][0];
			kc[0][1] += kc[k][1];
		}
		if(!i && ssum < ksum) //初始时
		{
			flag = 1; //flag=1时,即kc领先sh
		}
		if(i > 0 && flag && ssum > ksum) //由于kc领先sh,那么只有当sh反超kc时,则才算是一次领先顺序的变化
		{
			flag = 0; //flag=0时,即sh领先kc
			count++;
		}
		if(i > 0 && !flag && ssum < ksum) //由于sh领先kc,那么只有当kc反超sh时,则才算是一次领先顺序的变化
		{
			flag = 1;
			count++;
		}
	}
	printf("%d", count);
	
	return 0;
}
```


---

## 作者：yali_hzy (赞：2)

思路：枚举每秒钟两人走的路程。

因为n,m<=1000 每个数据<=1000 所以数组要开1000\*1000，不会爆空间。

代码：


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,i,j,m,sum,sum1,ans,a[1000010],b[1000010],v,t,flag;
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&v,&t);
        for(j=sum+1;j<=t+sum;j++)
            a[j]=a[j-1]+v;//a数组用来记录第一个人每秒走过的路程
        sum+=t;//sum用来记录目前在第几秒
    }
    for(i=1;i<=m;i++)//第二个人
    {
        scanf("%d%d",&v,&t);
        for(j=sum1+1;j<=t+sum1;j++)
            b[j]=b[j-1]+v;
        sum1+=t;
    }
    if(a[1]>b[1])
        flag=1;
    else
        flag=0;//先判断谁领先,flag用来记录当前状态,1表示第一个人领先,0表示第二个人领先
    for(i=1;i<=sum;i++)//i可从2开始
    {
        if(a[i]>b[i] && flag==0)
        {
            flag=1;
            ans++;//ans用来记结果
```
}//如果现在第一个人快,之前第二个人快,结果加1,状态改变
```cpp
        if(a[i]<b[i] && flag==1)
        {
            flag=0;
            ans++;
```
}//同理
    }
    printf("%d",ans);

}

---

## 作者：ysy666 (赞：2)

一道模拟好题→-→

分别用两个数组来记录sh和kc在每一s时距离起点的距离

比如说样例：

a:1 2 6 7 9 11 13 15 17 19 21 23 25 27

b:2 4 6 7 8 11 14 17 20 23 26 29 32 35

然后开始比较谁在前谁在后，ans计数

输出ans.



附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,ans,tot;
long long a[20000010],b[20000010];
struct ysy    //定义一个结构体 
{
    int v,t;    //v 速度  t 时间 
};
ysy sh[1010],kc[1010];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)  cin>>sh[i].v>>sh[i].t;
    for(int i=1;i<=m;i++)  cin>>kc[i].v>>kc[i].t;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=sh[i].t;j++)
            a[++tot]=a[tot-1]+sh[i].v;
    //a数组来记sh在每一秒的时候距离起点的距离 
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=kc[i].t;j++)
            b[++tot]=b[tot-1]+kc[i].v;
    //b数组与a同理 
    }
    for(int i=1;i<=tot;i++)
    {
        if(i==1)  continue;
        if(a[i-1]<=b[i-1] && a[i]>b[i])  ans++;
        if(a[i-1]>=b[i-1] && a[i]<b[i])  ans++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：野菜汤 (赞：1)

题解：

本题的解法有很多种，但是个人认为最简单的而且最方便的就是直接模拟每一秒钟的情况，然后进行判断，就显得十分容易了！

然后难点就是需要将不同的速度段分开处理，所以需要一些小技巧。

```delphi
var i,j,k,m,n,sum,p,q,s,v,c,o1,o2:longint;
    sh,kc:array[1..1000,1..2] of longint;
    a,b:boolean;
begin
  readln(n,m);
  for i:=1 to n do begin
  readln(sh[i,1],sh[i,2]);c:=c+sh[i,2];end;{在这里就直接计算出总时间，方便接下来的运算}
  for i:=1 to m do begin readln(kc[i,1],kc[i,2]);end;
  p:=1;q:=1;{p是记录sh当前正在哪一个速度段，而q则是记录kc的}
  for i:=1 to c do begin
    s:=s+sh[p,1];{统计sh当前跑了多少路程}
    v:=v+kc[q,1];{统计kc当前跑了多少}
    if (s>v)and(a=false) then begin a:=true;b:=false;sum:=sum+1;end;{如果sh在kc之前，并且原本没有超过kc那么变成sh领先（a为true），kc落后（b为false）}
    if (s<v)and(b=false) then begin b:=true;a:=false;sum:=sum+1;end;{与上相反}
    if sh[p,2]=i-o1 then begin inc(p);o1:=o1+sh[p-1,2];end;{o1和o2是统计现在所在速度段之前的所有速度段的总和，用它来减去现在的总时间，就能得到在当前速度段跑的路程，既可以很轻松地判断当前速度段是否结束}
    if kc[q,2]=i-o2 then begin inc(q);o2:=o2+kc[q-1,2];end;{与上同}
  end;
  if sum=0 then write(0) else{测试点中有一个数据的答案是0，未免被阴，所以先判断一下。}
  write(sum-1);{因为sum是从一开始分出先后就开始记录，而题目要求的是一开始分出现后之后的变化次数，所以需要减1}
end.
```
好了，首先做题思路很清晰，而且在下对于程序也已经解释的那么清楚了，应该广大读者么都能理解了吧。


---

## 作者：xh39 (赞：0)

这道题为了节约时间~~好像不必~~,我们不用每一秒都枚举,只用枚举关键点就可以了。

其中关键点就是变了速的点,因为如果两只奶牛都没有变速在中间任何时候发生超越,两只奶牛以同样的速度前行,在下一个关键点依然保持着超越的状态。

关键点很简单求,就是归并排序归并的那一部分,因为两个序列已经按时间排好序了(因为下一时刻必须要把时间+上一时刻,不然没办法比较,所以就排好序了)。设两个指针i和j,分别指向第一头奶牛的第一个变速点和第二头奶牛的第一个变速点,之后比较两个变量那个小,如果第一头奶牛的变速点小,就记录下第一头奶牛的变速点,否则记录第二头奶牛的变速点,记录完记得把相应的指针++。

之后定义一个bool类型的数组,来记录那个先,是第一头奶牛先就记录1,是第二头奶牛就记录0(是什么值都无所谓,两头牛不一样就可以了),如果一样就记录上一个值,因为题目规定:领先顺序的$\color{red}\textsf{变化}$,齐头并进不算变化。

其他:必须要会这个公式: 路程=时间×速度。

代码:不用展示了吧。

```cpp
#include<bits/stdc++.h> //相当于万能头文件～(￣▽￣)～
using namespace std;
struct xyq{
    int t,v,s;
};
xyq a[1005],b[1005];
bool first[2005]={0};
int la=1,lb=1; //这里把i和j命名为la和lb。
int main(){
    int n,m,nowt,nowa,nowb,sum=0,i;
    cin>>n>>m;
    a[0].s=0;
    for(i=1;i<=n;i++){
        cin>>a[i].v>>a[i].t;
        a[i].s=a[i-1].s+a[i].v*a[i].t;
        a[i].t+=a[i-1].t;
    }
    b[0].s=0;
    for(i=1;i<=m;i++){
        cin>>b[i].v>>b[i].t;
        b[i].s=b[i-1].s+b[i].v*b[i].t;
        b[i].t+=b[i-1].t;
    }
    for(i=1;i<=n+m;i++){ //在这里为了方便,把计算和处理一起写了。
        if(a[la].t<b[lb].t&&la<=n||lb>m){
            nowt=a[la].t-b[lb-1].t; //温馨提示:记得-1,毕竟已经走的路程是上一个,但其他的不用减,因为是目前的速度和时间。
            nowa=a[la].s;
            nowb=b[lb-1].s+b[lb].v*nowt;
            la++;
        }else{
            nowt=b[lb].t-a[la-1].t;
            nowa=a[la-1].s+a[la].v*nowt;
            nowb=b[lb].s;
            lb++;
        }
        if(nowa==nowb){
            first[i]=first[i-1];
            continue;
        }
        first[i]=(nowa>nowb); //nowa>nowb是一个判断语句,如果判断成功,就是1,反正是0。这只是为了方便。
        if(first[i]!=first[i-1]&&i!=1){ //如果是1就不要判断。
            sum++;
        }
    }
    cout<<sum;
    return 0;
}
```
[AC记录](https://www.luogu.org/recordnew/show/17477158)

---

## 作者：Chiaro (赞：0)

## 想法:

#### 输入的时候顺便计算一下跑步的总时间

#### 然后模拟

#### for循环一个时间单位一个时间单位的计算

#### 如果比分反超就记录一次

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans,Time,nl,ml;
//Time为跑步的总时间,nl与ml为现在代表n和m的人跑的距离
int n_time,m_time,n_now,m_now;
//n_time与m_time代表在n_now与m_now这个速度段里持续的时间
int ns[1001],ms[1001],ntime[1001],mtime[1001];
bool win,now;//win==0时 代表n在前面,win==1时 代表m在前面;
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>ns[i]>>ntime[i],Time+=ntime[i];
	for(int i=0;i<m;i++)cin>>ms[i]>>mtime[i];
//读入顺便计算Time,即跑步的总时间
	win=ns[0]>ms[0]?0:1;//先按初始速度算一下谁在前面
	for(int i=0;i<Time;i++){//循环开始
		n_time++;m_time++;
//都要+1表示在n_now和m_now速度段里又待了一个时间单位
		if(n_time>ntime[n_now])n_now++,n_time=1;
		if(m_time>mtime[m_now])m_now++,m_time=1;
//如果在n_now或m_now速度段里待的时间超过了这个速度段本来的值
//那么更新速度,速度段n_now或m_now++,时间清为1
		nl+=ns[n_now],ml+=ms[m_now];
//已经跑的路程增加
		now=nl>ml?0:1;
//算一下现在谁在前面
		if(now!=win){//如果现在的值与之前的值不同
			ans++;//变化次数+1
			win=!win;//换人
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：不厌不倦 (赞：0)

说说这道题吧。。。说实话一开始没理解对题意，以为终点和起点固定了，两个人跑的距离就是一样的，后面一看测试数据才发现完全不是这样（手动捂脸）

接着就是老老实实模拟这个过程了，模拟当然有不同的方法，可以选择以题目给的时间分隔模拟，也可以模拟到每一秒，出于保险（懒于思考），我选择了模拟到每一秒。而领先变化的条件实际上只需要关注第i-1秒到第i秒的变化而无需关注第i+1秒，因为实际发生关系变化的时刻就只在这一秒内。

下面上代码和详细解释：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
    int n,m,i,j;
    scanf("%d%d",&n,&m);

    int sh[n+1][2];  //记录sh的输入，多分配一行表示第0s的0速度，便于后面计算
    sh[0][0] = 0,sh[0][1] = 0;  //初始化
    int time = 0;  //记录总时间
    for(int i = 1;i <= n;i++){
        scanf("%d%d",&sh[i][0],&sh[i][1]);
        time = time + sh[i][1];
    }

    int kc[m][2];
    kc[0][0] = 0,kc[0][1] = 0;
    for(int i = 1;i <= m;i++){
        scanf("%d%d",&kc[i][0],&kc[i][1]);
    }

    int *distance_sh = (int *)malloc(sizeof(int)*(time + 1)); //记录sh第is的位移，下同
    int *distance_kc = (int *)malloc(sizeof(int)*(time + 1));
    distance_sh[0] = 0; //初始化第0s的距离为0，方便计算，下同
    distance_kc[0] = 0;  
	
    int temp = 0;
    for(i = 1;i <= n;i++){
        for(j = 1;j <= sh[i][1];j++){
            distance_sh[temp+j] = distance_sh[temp + j - 1] + sh[i][0]; // 计算sh第is的位移，下同
        }
        temp = temp + j - 1;
    }
	temp = 0;
    for(i = 1;i <= m;i++){
        for(j = 1;j <= kc[i][1];j++){
            distance_kc[temp+j] = distance_kc[temp + j - 1] + kc[i][0];
        }
        temp = temp + j - 1;
    }

    int *flag = (int *)malloc(sizeof(int )*(time + 1));
    flag[0] = -10; //记录每秒sh和kc的位移大小比较，sh大则置为1，sh小则置为-1，相等置为0，此处置为-10避免将第一秒当作顺序交换

    int cnt = 0;  //记录交换次数
    for(i = 1;i <= time;i++){
        if(distance_sh[i] > distance_kc[i]){
            flag[i] = 1;
        }else if(distance_sh[i] < distance_kc[i]){
            flag[i] = -1;
        }else{
            flag[i] = 0;
        }
        if((abs(flag[i] - flag[i-1]) == 1 && flag[i-1] == 0) || abs(flag[i] - flag[i-1]) == 2){
            cnt++; //关键判断！！，若第（i-1）s两者位移相等，则只需第i秒flag绝对值为1即可，若第（i-1）两者位移不等，则需第i秒与第（i-1）秒flag之差的绝对值为2
        }
    }

    printf("%d\n",cnt);

    return 0;
}

```


------------
本菜鸡也只能在红题发发题解了




---


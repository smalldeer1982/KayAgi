# 结算日

## 题目背景

借债还债


## 题目描述

“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 $N(1 \leq N \leq 100,000)$ 个朋友有了债务关系，或者借债了，或者放债了。她的 $N$ 个朋友依次标号为 $1\dots N$。 结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 $i$ 头奶牛站的位置距离谷仓 $i$ 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。 当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 $i$ 欠贝西 $D_i$ 元 $(-1,000 \leq D_i \leq 1,000,D_i \neq 0)$，负数表示贝西欠奶牛 $i$ 钱。 贝西从谷仓出发，位置为 $0$，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？注意：她必须在最后一头奶牛所在的位置，完成她的行走。


## 说明/提示

输入解释：

$3$ 头奶牛欠贝西钱；她欠 $2$ 头奶牛钱。当她完成结算，她将有 $150$ 元。

输出解释：

```cpp
谷仓  100  -200  250 -200  200
 |     |     |    |    |    |
 ***>**+**>*****>**+
                   *            < 贝西有 350元
             -**<***
             *                  < 贝西有 150元
             ***>****>****>**+
                             *  < 贝西有 350
                       -**<***
                       *     
                       ***>***  < 贝西结束她的行走，有 150元
```

## 样例 #1

### 输入

```
5
100
-200
250
-200
200```

### 输出

```
9

```

# 题解

## 作者：封禁用户 (赞：39)

首先，核心思想是少走回头路（正如有一个题解说的一样），所以需要的是如果能够偿还欠债就立刻回头偿还（如果你继续往下走的话至少需要多走2m的回头路），目测法得显然正确。

代码如下（应该很短了吧）

```cpp
#include<iostream>
using namespace std;
int n,x,sum,ans,l;
bool flag;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>x;
        sum+=x;//记录当前已经走过的总负债与收回的和
                ans+=1;//向前走一米
        if ((sum>=0)&&flag){flag=0;ans+=(i-l)*2;}//负债小于收回，回去还债
        if ((sum<0)&&!flag){flag=1;l=i;}//记录最先开始负债的位置
    }
    cout<<ans;
}
```

---

## 作者：greenheadstrange (赞：10)

- 分析：

从左往右搜一遍，在搜到不能还清的钱时记录下来，在能还清的时候就回去还清（**贪心**）

```cpp
//bj为上一次欠钱未还清的位置，当bj=0时表示没有欠钱。
for(int i=1;i<=n;i++){
	scanf("%d",&x);
	sum+=x;//如果能还钱就还清了，以免后来走更多的路程
	if(sum>=0&&bj)ans+=(i-bj)*2/*走过去再走回来，两倍路程*/,bj=0;//已还，没有钱要还了
	if(sum<0&&!bj)bj=i;//如果不能还清，则记录下位置当有足够钱的时候来还
}
```

- 贪心证明：

如果在能够还清的的时候不回去，在以后回去时就要走更多的路程，从而不能找到最小的答案。

下面是本蒟蒻的代码：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,sum,ans,bj,x;
int main(){
	scanf("%d",&n);
	ans=n;//从1到n至少需要n个路程 
	//bj为上一次欠钱未还清的位置，当bj=0时表示没有欠钱。
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		sum+=x;//如果能还钱就还清了，以免后来走更多的路程
		if(sum>=0&&bj)ans+=(i-bj)*2/*走过去再走回来，两倍路程*/,bj=0;//已还，没有钱要还了
		if(sum<0&&!bj)bj=i;//如果不能还清，则记录下位置当有足够钱的时候来还
	}
	printf("%d",ans);
	return 0;
}
```

**希望大家合理利用本题解，杜绝抄袭，因为抄袭对你没有任何帮助！！！**

---

## 作者：Real_Create (赞：6)

~~只有6篇题解的话我这个蒟蒻应该能过~~

~~你们方法差不多的都过了，何况我~~

思路：如果~~他~~它能还清所有之前欠的就麻溜的滚回去。

因为如果只能还清一笔就回去的话有一段路就要往回走2次，如果都能还清就可以只往回走一次。

如果到最后还你就要一直跑到第一只你欠它的奶牛那里让后再跑回来。

图示（画的不好 ~~如有不适请砸穿电脑~~）

![](https://cdn.luogu.com.cn/upload/pic/75484.png)

代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main()
{
	cin>>n;
	int q=0,jl=0,t,ans=n;//你总是要跑完一次的
	for(int i=0;i<n;i++)//一只只奶牛过去
	{
		cin>>t;
		q+=t;//现在你欠的钱和你的钱相减
		if(q<0)//我还欠钱！
		{
			jl++;//多走了QAQ
		}
		if(q>=0)//我不欠钱了！
		{
			ans+=jl*2;//还钱了还钱了
			jl=0;//不欠钱啦
		}
	}
	cout<<ans;//输出
	return 0;//AC
}

```

挑战最短代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int q=0,jl=0,t,ans=0,n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>t;
		q+=t;
		jl+=(q<0);
		if(q>=0){ans+=jl*2;jl=0;}
	}
	cout<<ans+n;
}
13行成功
```


---

## 作者：oistr (赞：4)

**说实在的，看到这题的第一感觉是：题干长的吓人。。。**

不过，超过一半都基本上~~是废话~~；

## 来分析一下：

当bessie走到某一时刻时，共有以下两种情况;

1. 之前不欠
2. 之前已有欠钱

Bessie与这头牛的关系又分别有两种情况：

1. **之前不欠，当前奶牛欠贝西**  策略：没什么好说的，收钱，向前走
2. **之前不欠，当前贝西欠奶牛**策略：能还，还；不能换，记录下欠钱位置，向前走；
3. **之前欠，当前奶牛欠贝西**策略：收钱，如能还，回去还；如不能，向前走
4. **之前欠，当前贝西欠奶牛** 策略：欠钱数增加

好了，上代码：

```cpp
#include<iostream>
#include<cmath>//头文件
using namespace std;
int main()
{
	int n,d[1010];//数组记录
	cin>>n;
   //输入
	for(int i=1;i<=n;i++)
	{
		cin>>d[i];
	}
    //cur记录步数，i记录位置，m记录
    //已得钱数，q记录欠钱数
	int cur=0,i=1,m=0,q=0;
    //wz记录第一次欠钱位置
	int wz;
	while(i<=n)
	{
    //之前不欠，当前奶牛欠贝西
		if((q==0)&&(d[i]>=0))
		{
        //收钱，向前走
			m+=d[i];
			i++;
			cur++;
		}
        //之前欠，当前奶牛欠贝西
		else if((q!=0)&&(d[i]>=0))
		{
        //收钱
			m+=d[i];
        //能还，回到第一次欠钱位置（wz）还
			if(m>=q)
			{
				cur+=(i-wz)*2;
				m-=q;
				q=0;
				i++;
				cur++; 
			}
         //不能还，向前走
			else
			{
				i++;
				cur++;
			}
		}
     //之前不欠，当前奶牛欠贝西
		else if((q==0)&&(d[i]<0))
		{
        //能还，直接还
			if(m>=abs(d[i]))
			{
				m-=d[i];
				i++;
				cur++;
			}
        //不能还，记录位置，走
			else
			{
				q-=d[i];
				wz=i;
				i++;
				cur++;
			}
		}
     //之前欠，当前贝西欠奶牛
		else if((q!=0)&&(d[i]<0))
		{
        //增加欠钱数
			q-=d[i];
			i++;
			cur++;
		}
	}
   //输出
	cout<<cur<<endl;
	return 0;
}
```


---

## 作者：向noip冲刺 (赞：3)

思路:钱一可以满足前面的债务就回去.
为什么钱可以还全部的债务就回去呢,很简单.   
无非就是有这样一种情况.
-1651 15 -13 2000     
我们会发现,一有钱就还,这是最优的.    
为什么会这样呢.因为如果有钱就还,那么债务还是有的,我们还需要一些money.那么还是要从很远的地方补给过来,这样步数会增加,不如带的钱数比前面的债务多了之后再换,这样是最优的.那么为什么不多走几步呢.我们会有这样一种情况.
-516 111 5555 55 
我们会发现,多走几步只会使答案增加.

```cpp
/*注意:需要一次还清,这样的解是最优的.*/

#include  <iostream>
#include <cstdio>
const int maxN = 100000 + 7;

int a[maxN],l,ans,have_money,flow;

int main() {
	int n;
	scanf("%d",&n);
	for(int i = 1;i <= n;++ i) 
		scanf("%d",&a[i]);
	for(int i = 1;i <= n;++ i) {
		ans++; 
		if(a[i] >= 0) {
			have_money += a[i];
			if(flow <= have_money && flow > 0) {
				have_money -= flow;
				flow = 0;
				ans += (i - l) * 2;
			}
		}else {
			if(flow == 0) l = i;
			flow += -(a[i]);
		}
	}
	printf("%d",ans);
}
```

---

## 作者：Snow_Dreams (赞：0)

这道题就是一个贪心

如大家题解里说的：尽量不走回头路

因为B到达一个地方（有cow的地方）有几种状态：

1. 要收钱 -> 直接收钱
2. 欠钱够还 -> 直接还钱
3. 欠钱不够还 -> 记录手中的钱与要还的钱的差（q），然后走到下一个可以收钱的地方，如果未收到q则继续走，如果收到了就回到之前的那个点

每走一步，就ans++

最后输出ans即可

因为如果不按此策略走，ans一定会比此方法求出来的大

---


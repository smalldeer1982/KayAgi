# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题


## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我


## 样例 #1

### 输入

```
Black Obama is two five zero .```

### 输出

```
425```

# 题解

## 作者：ZigZagKmp (赞：178)

这道题目非常坑，尤其是#3和#4。——摘自讨论区


我用的输出方法和楼下的那些神犇不同，我用了printf("%.2d",a[i]);就是不足2位前面补0.


这题主要思路还是贪心，主要考点是字符串。


具体内容看注释


```cpp
#include<bits/stdc++.h>
using namespace std;
char dic[30][20]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third"};//对应
int di[30]={0,1,4,9,16,25,36,49,64,81,00,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9};
unsigned long long int a[10],top,flag;
int i,j;
char s[100];
int main()
{
     for(i=1;i<=6;i++)
     {
          scanf("%s",&s);//%s读入遇到空格就停止
          for(j=1;j<=26;j++)
          {
               if(!strcmp(s,dic[j]))//strcmp(s1,s2);如果他们相同，返回0
               {
                    a[++top]=di[j];//用数组存储
                    break;//立即停止寻找
               }
          }
      }
      sort(a+1,a+top+1);//贪心，使越小的数越靠前输出
      for(i=1;i<=top;i++)
      {
           if(flag)//如果不是第一位
           {
                printf("%.2d",a[i]);//限制格式输出
           }
           else
           {
                if(a[i])
                { 
                     printf("%d",a[i]);
                     flag=1;
                }
            }
     }
     if(!flag)printf("0");//特判
     return 0;
}
```

---

## 作者：Maktub (赞：149)

有人想到用map吗？？？？

用个map<string,int>q直接打表就好了，输入每个字符串s判这个字符串能不能用，只要q[s]大于0就好了，同时将数字储存，从小到大排序，然后输出就可以了。

注意：除了第一位外，其他比10小的都要补0.

代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
map<string,int>q;
const int mx=66;
int top;
int st[mx];
string s;
int main(){

     q["one"]=1;q["two"]=2;q["three"]=3;q["four"]=4;q["five"]=5;q["six"]=6;q["seven"]=7;q["eight"]=8;q["nine"]=9;q["ten"]=10；
     q["eleven"]=11;q["twelve"]=12;q["thirteen"]=13;q["fourteen"]=14;q["fifteen"]=15;q["sixteen"]=16;q["seventeen"]=17;q["eighteen"]=18;q["nineteen"]=19;q["twenty"]=20;
     q["a"]=1;q["both"]=2;q["another"]=1;q["first"]=1;q["second"]=2;q["third"]=3;
     //打表
     for(int i=1;i<=6;i++){
     	cin>>s;
     	if(q[s]){//如果可以构成数字
     		int k=q[s]*q[s]%100;
     		if(k==0)continue;//要是为0就没有必要存了
     		st[++top]=k;
		 }
	 }
	 sort(st+1,st+top+1);//从小到大排
	 cout<<st[1];
	 for(int i=2;i<=top;i++){
	 	if(st[i]<10)cout<<0;//不这样只能拿10分
	 	cout<<st[i];
	 }
	 return 0;

}
```
~~怎么代码没颜色了~~

当需要字符串对应数字时，map是非常好用的。




---

## 作者：yyy2015c01 (赞：106)

慢慢判断。。然后。。输出。。然后。。就没有然后了。。

世界上不是没有水题，而是缺少发现水题的眼睛。

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
long long c=0,word[6]={0},out=0;
int getst(string s,long long &c)
{
    if(s=="one"||s=="a"||s=="first"||s=="another"){word[c]=1;c++;return 0;}
     if(s=="two"||s=="both"||s=="second"){word[c]=4;c++;return 0;}
     if(s=="three"||s=="third"){word[c]=9;c++;return 0;}
     if(s=="four"){word[c]=16;c++;return 0;}
     if(s=="five"){word[c]=25;c++;return 0;}
     if(s=="six"){word[c]=36;c++;return 0;}
     if(s=="seven"){word[c]=49;c++;return 0;}
     if(s=="eight"){word[c]=64;c++;return 0;}
     if(s=="nine"){word[c]=81;c++;return 0;}
     if(s=="eleven"){word[c]=21;c++;return 0;}
     if(s=="twelve"){word[c]=44;c++;return 0;}
     if(s=="thirteen"){word[c]=69;c++;return 0;}
     if(s=="fourteen"){word[c]=96;c++;return 0;}
     if(s=="fifteen"){word[c]=25;c++;return 0;}
     if(s=="sixteen"){word[c]=56;c++;return 0;}
     if(s=="seventeen"){word[c]=89;c++;return 0;}
     if(s=="eightteen"){word[c]=24;c++;return 0;}
     if(s=="nineteen"){word[c]=61;c++;return 0;}
}
int main()
{
    string getit[6];
    for (int i=0;i<6;i++)
    {
        cin>>getit[i];
        if (getit[i][getit[i].size()-1]=='.') getit[i].erase(getit[i].size()-1,1);
        getst(getit[i],c);
    }
    sort(word,word+c);
    for(int i=0;i<c;i++)
    {
        out+=word[i];
        out*=100;
    }
    cout<<out/100;
    //system("pause");
}

```

---

## 作者：zhaowangji (赞：63)

很久以前（几个月前吧）就注意到了这题，然而。。。看了两眼就懒得思考了。。。以后好几次都是这样，今天算是还债吧。

建议大家先把英文数字和对应运算结果的表打好，这样就很方便（这时候就不用保留0了，比如10^2=100，100%100=0，题目里说是00，这时候先直接赋值为0，后面再做判断）

因为题目说了每个句子就是6个单词，所以直接i 1~6循环读入

然后每次读入都判断一下是不是英文数字，如果是就加到一个数组里（把运算结果放进去）

把数组排序（因为要求最小嘛）

先判断一下句子里有没有英文数字，没有直接输出0

然后把数组里的值都输出

注意：根据题目要求“组成一个新数，如果开头为0，就去0”，说明除了第一个，后面每个数如果只有一位都要在十位补上一个0

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
string yw[30]={"","one","two","three","four","five","six","seven",
"eight","nine","ten","elven","twelve","thirteen","fourteen","fifteen",
"sixteen","seventeen","eighteen","nineteen","twenty","a","both",
"another","first","second","third"}; 
int sz[30]={0,1,4,9,16,25,36,49,64,81,0,21,44,69,96,25,56,89,24,61,0,
1,4,1,1,4,9};
int k;
int a[10];

int main()
{
	for(int i=1;i<=6;i++)
	{
		string x;
		cin>>x;//直接用变量读就行了
		for(int j=1;j<=26;j++)//26种英文数字
			if(yw[j]==x)
				{a[++k]=sz[j];break;}//k记录有几个英文数字
	}
	if(k==0){cout<<0<<endl;return 0;}//先判断一下句子中有没有英文数字
	sort(a+1,a+k+1);//排序
	for(int i=1;i<=k;i++)
	{
		if(i!=1&&a[i]<10)cout<<0;//补0
		cout<<a[i];
	}
	cout<<endl;
	return 0;
}
```


---

## 作者：constructor (赞：35)

## Python3， 也许是最短的题解

题目怎么做各位大佬已经阐述地很清楚了，这是Py3代码：


```python

Key = 'zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty a both another first second third no'.split()
Val = [i for i in range(21)]
Val += [1, 2, 1, 1, 2, 3, 0]
Val = [str(i ** 2 % 100).rjust(2,'0') for i in Val]
Dic = dict(zip(Key, Val))
dat = input().split()
ans = [Dic[i] for i in dat if i in Dic]
if ans == ['00']*len(ans):
	print('0')
else:
	print(''.join(sorted(ans)).lstrip('0'))

```

稍微解释一下。

------------

- 第一行很明显直接划分所有的键

- 第二行列表解析，构造$[0, 20]$的值（**caution**：range在Python3返回迭代器，而不是一个list）

- 第三行加长Val列表用来表述非标准语用。第三个点`Chen Junao is no so clever .`
不知道为什么输出0,估计是`no`算0，所以我加了`no->0`的映射。

- 第四行是精髓之一，列表解析提出Val的每个元素进行处理，具体来说，以题目中的规则

- $(num)=>num^2\ mod\ 100$

- 处理并转换为字符串，在左侧补齐0达到2位。

- 第五行，以key和val构造键值对并进一步构造dict（其实你也可以用字典解析（貌似是py2.6开始））。

- 第六行不解释

- 第七行列表解析，测试并获取映射值

- 第八到九行特判，如果全为0就输出0

- 第十到十一行的作用其他题解说的很清楚了，此处不再赘述。

---

## 作者：Trinitrotoluene (赞：19)

看到大佬们都在用map或优先队列，蒟蒻感到瑟瑟发抖。

但是，有没有人想到过用[string](https://blog.csdn.net/tengfei461807914/article/details/52203202)？

### string可是能够直接比较大小的！

举个栗子:string a=…, b=…; if(a>b）… ; if(a<b)… ; if(a==b)… ;

#### 下面，借助代码来理解：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace sdt;
string a[]={"one","two","three","four","five","six","seven","eight","nine","eleven","twelve",
"thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","a","both","another",
"first","second","third"};//没有0、10、20
string s;
int b[]={1,4,9,16,25,36,49,64,81,21,44,69,96,25,56,89,24,61,1,4,1,1,4,9};
int k[6],p;
int main(){
    cin.sync_with_stdio(0);/cin的优化
    for(int i=0;i<6;i++){
        cin>>s;
        for(int j=0;j<24;j++)   if(s==a[j]) k[p++]=b[j];
        //确认读入的字符串是否为数字，以及为何数字
    }
    if(!p)  {putchar(48);return 0;}
    //Caution！如果没有这句话，那么当没有数字的时候，p=0，就会RE
    sort(k,k+p-1);
    printf("%d",k[0]);//输出首位，不加前导0
    for(int i=1;i<p;i++)    printf("%02d",k[i]);
    //当该数非首位且其小于10时，就要在其前面补充一个0
    return 1;
```


最后，再补充几点细节：

1、读入时句号前面有空格，因此不需要特殊处理。

2、当读入没有数字时，一定要特判！

3、当读入的数字个位数为0时，平方后%100后就会变为0，排序后就会排在第一位，作为前导0而被过滤掉。

4、string的读入必须用iostream，不能用cstdio。

---

## 作者：jiezi (赞：15)

#近期学了字符串哈希，并没有找到几道例题，于是这道题用哈希连连手

##用哈希不用动脑子，不用STL（string就不算了吧），不用特判，代码还漂亮（自认为）。

###打了个表，或许应该叫“哈希表”？，，，


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int db[30],a[10],cur=0;
int Hash(string s){//个人认为哈希并没有什么规范写法，毕竟是骗分写法，最后还要刷脸，但是这道题有用的字符串不过二三十个，写完也方便看是否有矛盾的
    long long ans=1313;
    const int seek=131;
    int temp=s.size();
    for(int i=0;i<temp;i++){
        if('A'<=s[i]&&s[i]<='Z') s[i]=s[i]-'A'+'a';
        ans=(ans-s[i])*seek;
    }    
    return ans&0x3fff;
}
int main(){//优雅的打表
    db[1]=Hash("one");
    db[2]=Hash("two");
    db[3]=Hash("three");
    db[4]=Hash("four");
    db[5]=Hash("five");
    db[6]=Hash("six");
    db[7]=Hash("seven");
    db[8]=Hash("eight");
    db[9]=Hash("nine");
    db[10]=Hash("ten");
    db[11]=Hash("eleven");
    db[12]=Hash("twelve");
    db[13]=Hash("thirteen");
    db[14]=Hash("fourteen");
    db[15]=Hash("fifteen");
    db[16]=Hash("sixteen");
    db[17]=Hash("seventeen");
    db[18]=Hash("eighteen");
    db[19]=Hash("nineteen");
    db[20]=Hash("twenty");
    db[21]=Hash("a");
    db[22]=Hash("both");
    db[23]=Hash("another");
    db[24]=Hash("first");
    db[25]=Hash("second");
    db[26]=Hash("third");
//    sort(db+1,db+27);
//    for(int i=1;i<=26;i++) printf("%d\n",db[i]);//看是否有矛盾，写代码最好要写一步调一步，不要闷着头打到最后
    string t;
    for(int i=1;i<=6;i++){
        cin>>t;
        int temp=Hash(t);
        for(int j=1;j<=26;j++)
          if(db[j]==temp){//枚举判断某单词含义是否为数字
              if(j<=20) a[++cur]=j*j%100;
              else{
                  if(j==21||j==23||j==24){ a[++cur]=1;break; }
                if(j==22||j==25) { a[++cur]=4;break; }
                if(j==26) { a[++cur]=9;break; }
            }
//            cout<<a[cur]<<" ";
          }
    }
//    cout<<"\n";
//    cout<<cur;
    if(cur==0){//如果不存在含义为数字的单词
        cout<<0;
        return 0;
    }
    sort(a+1,a+cur+1);//排序后，按从小到大顺序输出，不会具体证明，但可能可以如是想：对于每一位或每一个两位数所占的位置，要求越高位的数值越小，于是把大数都扔到后面，按位数以此贪心取最优解。
    for(int i=1;i<=cur;i++){
        if(a[i]<10&&i!=1) cout<<0<<a[i];//如果某数字为个位数且它在最后答案中间部分，记得补零
        else cout<<a[i];
    }
    return 0;
}
```

---

## 作者：Sinwind (赞：13)

---

# 分析

1. 本题需要将英文数字转换为数字，非正规的英文数字单独讨论，正规的英文数字用$string$数组解决（依次存储英文数字，数组下标是其对应的数字）；

2. 经过运算得到值存入$nums$数组；

3. 因为要求的是最小的排列，因此将$nums$中的元素按照从小到大排序并输出。

---

# 思路

1. 循环$6$次，读入$6$个单词（$word$）；

- 若单词非英文数字，不做处理；

- 若单词为英文数字，有符合要求的数（$flag = true$），分$2$种情况：

	- 非正规的英文数字单独讨论：
    
    	- 若$word=="a","another","first"$中的一个，$nums[cnt++]=1(=1^2\mod100)$（$cnt$用来记录$nums$的个数）；
        
		- 若$word=="both","second"$中的一个，$nums[cnt++]=4(=2^2\mod100)$；
        
        - 若$word=="third",$，$nums[cnt++]=9(=3^2\mod100)$；
	
    - 正规的英文数字，遍历$english\_nums$数组，分别与$word$比较，若相等，则$english\_nums$中对应的下标（$j$）就是转换后的数，$nums[cnt++]=(j^2)\mod 100$。
    
2. 若没有符合要求的数（$flag==flase$）,输出$0$并$return\space 0$；

3. 将$nums$数组中$nums[0]$到$nums[cnt-1]$从小到大排序，用的是$algorithm$库中的$sort$；

4. 输出排序后的$nums$数组，若该数小于$10$且非首位，输出时要在前面补上$0$。

---

# 代码

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

string word;		//输入的句子
int nums[10];   	//数字
int cnt = 0;   		//数字个数
bool flag = false;  //是否有符合要求的数
const string english_nums[21] =
{" ", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
"eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"};

int main(void)
{
	for(int i = 0; i < 6; i++)
	{
		cin >> word;
		//英文数字转数字
		//非正规
		if(word == "a" || word == "another" || word == "first")
		{
			flag = true;
        	nums[cnt++] = 1;
        	continue;
		}
		if(word == "both" || word == "second")
		{
			flag = true;
        	nums[cnt++] = 4;
        	continue;
		}
		if(word == "third")
		{
			flag = true;
			nums[cnt++] = 9;
			continue;
		}
		//正规
        for(int j = 0; j <= 20; j++)
        {
        	if(word == english_nums[j])
        	{
        		flag = true;
        		nums[cnt++] = (j * j) % 100;
        		break;
			}
		}
	}
	
	//没有符合要求的数
	if(flag == false)
	{
		cout << 0;
		return 0;
	}
	
	//从小到大排序
	sort(nums, nums + cnt - 1);
	
	//输出
	bool first = true;  //是否为首位
	for(int i = 0; i < cnt; i++)
	{
		//小于10且非首位，补零
        if(nums[i] < 10 && first == false)
        {
        	cout << 0;
		}
		cout << nums[i];
		first = false;
	}
	
	return 0;
}
```


---

## 作者：WolfgangWu (赞：9)

这题看了看前面大佬们的做法，我觉得没必要那么麻烦吧，只需要建个字符串组，从里面index出所求数字的大小放进一个数组，然后对数组sort一下，然后把里面的数字按100进制输出就行。过了一遍AC了，但是这种方法的鲁棒性我并不拿得准，各位大佬轻拍哈。

下面贴代码。



```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <algorithm>
    using namespace std;
    char dict[21][21]={//这里数字按顺序放，取出的时候直接输出索引号，方便
```
"one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty",
    },unc[7][20]={//unc stands for unconventional

"a","both","another","first","second","third"

    
    
```cpp
    };
    int dat[6],dunc[7]={1,2,1,1,2,3};//对于unc字符组准备一个索引表，取出的时候方便
    char temp[20];
    int index(char *g){
        for(int i=0;i<20;i++)//检查在不在dict里面
            for(int j=0;g[j]!='\0';j++){
                if(g[j]!=dict[i][j])break;
                if(g[j+1]=='\0')return (i+1)*(i+1)%100;//直接处理好返回数字
            }
        for(int i=0;i<6;i++)//检查在不在unc里面
            for(int j=0;g[j]!='\0';j++){
                if(g[j]!=unc[i][j])break;
                if(g[j+1]=='\0')return dunc[i]*dunc[i]%100;//处理好返回值
            }
        return 0;//否则返回0，这样的话反正一个sort就会排到最前面，并不影响
    }
    int main(){
        for(int i=0;i<6;i++){
            cin>>temp;
            dat[i]=index(temp);//把返回值录入进数组
        }
        sort(dat,dat+6);
        long long c=0;
        for(int i=0;i<6;i++)
            c=c*100+dat[i];//按100进制输出
        cout<<c<<endl;//暂时没发现问题，请各位大佬轻拍
    }

```

---

## 作者：念古兰 (赞：6)

### 蒟蒻第一次发题解，不足之处，还望见谅
 这道题用STL来做可以节省很多的代码，而且也相对更好理解（个人认为），所以下面就直接用  _map_ 来做了
  
  题目主要需要处理的有以下几个方面： 
   
   1.字符串判断是否为“数字”与数字的转换（这个用常量数组跟 map 就可以解决）
    
    2.输出的格式，可以加一些判断控制输出的格式，
      或者是跟上面说的一样，用一百进制输出或用
      printf控制格式，注意输出开始不能有"0"
    3.输出数字的顺序问题，这个直接进行排序
      就可以解决
 
下面直接上代码：
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
char l[][20]={"a","zero","one","two",
              "three","four","five",
	      "six","seven","eight",
	      "nine","ten","eleven",
	      "twelve","thirteen",
	      "foueteen","fifteen",
	      "sixteen","seventeen",
	      "eighteen","nineteen",
	      "twenty"};//设置常量字符串数组，
                          便于后面的判断
bool myfind(char *b){
	for(int i=0;i<22;i++){
		if(strcmp(l[i],b)==0)
		return true;
	}
	return false;
}                     //对字符串是否为数字的判断
int flag;             //flag为0时输出0
int main(){
	char temp[20]={0};
        map<string,int> a;//使用map
        a["zero"]=0;      //进行赋值，
        a["a"]=1;           下面与此相同
        a["one"]=1;
        a["two"]=2; 
        a["three"]=3; 
        a["four"]=4;
        a["five"]=5; 
        a["six"]=6;
        a["seven"]=7;
        a["eight"]=8;
        a["nine"] =9;
        a["ten"] =10;
        a["eleven"]=11;
        a["twelve"]=12;
        a["thirteen"]=13;
        a["foueteen"]=14;
        a["fifteen"]=15;
        a["sixteen"]=16;
        a["seventeen"]=17;
        a["eighteen"]=18;
        a["nineteen"]=19;
        a["twenty"]=20;
        ————————        //赋值结束
        int num[6]={0};//储存提取的数字
for(int i=0;i<6;i++){
	scanf("%s",temp);
	if(myfind(temp))
	num[i]=pow(a[temp],2);
	num[i]%=100;
}                       //对数字按要求进一步处理
sort(num,num+6);
for(int i=0;i<6;i++)
if(num[i]){
if(i==0||num[i-1]==0)   //避免前导0
cout<<num[i],flag++;
else{
	if(num[i]<10)      //小于10时补0
	cout<<'0'<<num[i];
	else
	cout<<num[i];
	flag++;
}
}                     //对输出的处理
if(!flag)
cout<<0;              //没有数值就输出0
return 0;
}
```
祝各位早日AC -0-

---

## 作者：hsfzLZH1 (赞：4)

我这题用了两个重要的C++容器：string和map

string 用来保存字符串，简单无解释

map 则是用来判断当前字符串是否在字典中出现过，如果出现了则返回对应的字典值，没有出现过则返回0。map的特点是增加和删除节点对迭代器的影响很小，除了操作节点，对其他的节点没有影响。对于迭代器来说，可以修改实值，而不能修改key。

然后就是证明为什么密码是数字按字典序排序从小到大输出了：

在密码中，每一个数字对整体的贡献，取决于数字的数位，而要使密码尽可能的小，我们就要让更高的位置上的数字尽可能的低。（如果没有读懂可以多读几遍）按字典序排序，我们就可以保证最高位上的数字是最小的，次高位上的数字也是在最高位相同的情况中最小的。。。以此类推。注意排序时不要去掉前导0。C++给我们提供了一个按字典序排序的容器，并且还重载了<运算符，那就是string！

详见代码及注释：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
map<string,int>m;//定义一个通过string，返回int型数据的map，如果不存在该元素返回0 
int l,cur;
string s,ans[6];
int main()
{
    m["one"]=1;m["two"]=2;m["three"]=3;m["four"]=4;m["five"]=5;
    m["six"]=6;m["seven"]=7;m["eight"]=8;m["nine"]=9;m["ten"]=10;
    m["eleven"]=11;m["twelve"]=12;m["thirteen"]=13;m["fourteen"]=14;m["fifteen"]=15;
    m["sixteen"]=16;m["seventeen"]=17;m["eighteen"]=18;m["nineteen"]=19;m["twenty"]=20;
    m["a"]=1;m["both"]=2;m["another"]=1;m["first"]=1;m["second"]=2;m["third"]=3;//插入元素，map已经重载了[]运算符 
    /*
    以上代码容易实现，但是效率较低，可以使用insert函数，如下： 
    m.insert(make_pair("one",1));
    m.insert(make_pair("two",2));
    m.insert(make_pair("three",3));
    m.insert(make_pair("four",4));
    m.insert(make_pair("five",5));*/
    for(int i=0;i<6;i++)//输入6个单词 
    {
        cin>>s;
        l=s.length();
        for(int j=0;j<l;j++)if(s[j]<='Z'&&s[j]>='A')s[j]+='a'-'A';//将所有字符转化为小写，便于map的使用 
        if(m[s])//如果map中存在当前元素 
        {
            ans[cur]+=(m[s]*m[s]%100)/10+'0'; 
            ans[cur]+=(m[s]*m[s]%100)%10+'0';
            cur++;//将当前元素的平方存储，因为%100，所以只用存储两位 
        }
    }
    if(cur==0){cout<<0<<endl;return 0;}//特判，如果没有符合条件的单词，直接输出0 
    sort(ans,ans+cur);//排序 
    if(ans[0][0]=='0')cout<<ans[0][1];//特判，第一位是0的话不输出 
    else cout<<ans[0];
    for(int i=1;i<cur;i++)cout<<ans[i];//输出其余的数字 
    cout<<endl;
    return 0;
}
```
## 推荐一个学习map的大佬的博客： [博客链接](http://www.cnblogs.com/hailexuexi/archive/2012/04/10/2440209.html)


---

## 作者：海曜日 (赞：4)

底下的题解们已经足够完善了，我就提一个点。

最后一个单词和句号之间**有一个空格**！

所以可以这样：

```cpp
for(int  i=1;i<=6;i++)
    std::cin>>word[i]; //根本不用管句号！
```
好了，剩下的看下面的题解们吧。


---

## 作者：CeLaMbDa (赞：3)

思路: 使用$word$字符数组记录输入数据, 再循环跟已知的数字单词进行匹配, 用$ans$记录答案, 排序后输出, 可以证明从小到大排序可以使最终长度最小  
在程序中有一个小优化, 观察可得搜索数字单词的长度都不大于$9$, 所以**任何一个长度大于$9$的单词绝对不是数字单词**, 直接$continue$

---------------------
```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;

char number[22][30] = {"zero", "one", "two", "three", 
					   "four", "five", "six", "seven", 
					   "eight", "nine", "ten", "eleven", 
					   "twelve", "thirteen", "fourteen", "fifteen", 
					   "sixteen", "seventeen", "eighteen", "nineteen", 
					   "twenty"};
char other[7][30] = {"0", "a", "both", "another", "first", "second", "third"};

int main(int argc, char** args) {
	char word[6][100] = {'\0'};
	for(int i = 0;i < 6;i++) {
		scanf("%s", word[i]);
	}
	int ans[6] = {0}, ansPos = 0;
	for(int i = 0;i < 6;i++) {
		if(strlen(word[i]) > 9) continue;
		for(int j = 0;j <= 20;j++) {
			if(!strcmp(word[i], number[j]) || !strcmp(word[i], other[j])) {
				ans[ansPos++] = (j * j) % 100;
				break;
			}
		}
	}
	sort(ans, ans + ansPos);
	for(int i = 0;i < ansPos;i++) {
		if(ans[i] == 0) continue;
		else printf((i == 0 || ans[i - 1] == 0) ? ("%d") : ("%.2d"), ans[i]);
	}
	if(ansPos == 0) {
		printf("0");
	}
}
```


---

## 作者：zyj_Orz (赞：3)

一个清奇的代码23333~~啊不要禁言我啊啊啊已被**暴政**~~
```
//打表大法好！
#include<bits/stdc++.h>
using namespace std;
string a[8], b[233];
int t;
bool QAQ(string x, string y)
{
    return x + y < y + x;
}
int main()
{
    for(int i = 1; i <= 6; ++i)
    {
        cin >> a[i];

        if(a[i] == "one" || a[i] == "a" || a[i] == "first")
        {
            t++;
            b[t] = "01";
        }

        if(a[i] == "two" || a[i] == "both" || a[i] == "second")
        {
            t++;
            b[t] = "04";
        }

        if(a[i] == "three" || a[i] == "another" || a[i] == "third")
        {
            t++;
            b[t] = "09";
        }

        if(a[i] == "four")
        {
            t++;
            b[t] = "16";
        }

        if(a[i] == "five")
        {
            t++;
            b[t] = "25";
        }

        if(a[i] == "six")
        {
            t++;
            b[t] = "36";
        }

        if(a[i] == "seven")
        {
            t++;
            b[t] = "49";
        }

        if(a[i] == "eight")
        {
            t++;
            b[t] = "64";
        }

        if(a[i] == "nine")
        {
            t++;
            b[t] = "81";
        }

        if(a[i] == "ten")
        {
            t++;
            b[t] = "00";
        }

        if(a[i] == "eleven")
        {
            t++;
            b[t] = "21";
        }

        if(a[i] == "twelve")
        {
            t++;
            b[t] = "44";
        }

        if(a[i] == "thirteen")
        {
            t++;
            b[t] = "69";
        }

        if(a[i] == "fourteen")
        {
            t++;
            b[t] = "96";
        }

        if(a[i] == "fifteen")
        {
            t++;
            b[t] = "25";
        }

        if(a[i] == "sixteen")
        {
            t++;
            b[t] = "56";
        }

        if(a[i] == "seventeen")
        {
            t++;
            b[t] = "89";
        }

        if(a[i] == "eighteen")
        {
            t++;
            b[t] = "24";
        }

        if(a[i] == "nineteen")
        {
            t++;
            b[t] = "61";
        }

        if(a[i] == "twenty")
        {
            t++;
            b[t] = "81";
        }
    }

    if(t == 0)
    {
        printf("0");
        return 0;
    }

    sort(b + 1, b + t + 1, QAQ);

    if(b[1] == "01")
    {
        cout << 1;

        for(int i = 2; i <= t; ++i)
        {
            if(b[i] == "00") continue;

            cout << b[i];
        }

        return 0;
    }

    if(b[1] == "04")
    {
        cout << 4;

        for(int i = 2; i <= t; ++i)
        {
            if(b[i] == "00") continue;

            cout << b[i];
        }

        return 0;
    }

    if(b[1] == "09")
    {
        cout << 9;

        for(int i = 2; i <= t; ++i)
        {
            if(b[i] == "00") continue;

            cout << b[i];
        }

        return 0;
    }

    for(int i = 1; i <= t; ++i)
    {
        if(b[i] == "00") continue;

        cout << b[i];
    }

    return 0;
}
```

---

## 作者：cat_yyy (赞：3)

#十分暴力的代码

所有数都是算好的啊哈哈哈

这么长的代码看起来超级厉害的

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

char ch[21];

int a[7],cnt;

unsigned long long ans;

int main(){
    for(int i=1;i<=6;i++){
        //一边读入一边将获取的数字存入数组内 
        scanf("%s",ch);
        if(!strcmp(ch,"one")||!strcmp(ch,"a")||!strcmp(ch,"another")||!strcmp(ch,"first")){
            a[cnt]=1;//数字平方模一百都是算好的qwq 
            cnt++;
            continue;
        }
        if(!strcmp(ch,"two")||!strcmp(ch,"both")||!strcmp(ch,"second")){
            a[cnt]=4;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"three")||!strcmp(ch,"third")){
            a[cnt]=9;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"four")){
            a[cnt]=16;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"five")){
            a[cnt]=25;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"six")){
            a[cnt]=36;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"seven")){
            a[cnt]=49;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"eight")){
            a[cnt]=64;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"nine")){
            a[cnt]=81;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"ten")){
            a[cnt]=0;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"eleven")){
            a[cnt]=21;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"twelve")){
            a[cnt]=44;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"thirteen")){
            a[cnt]=69;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"fourteen")){
            a[cnt]=96;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"fifteen")){
            a[cnt]=25;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"sixteen")){
            a[cnt]=56;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"seventeen")){
            a[cnt]=89;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"eighteen")){
            a[cnt]=24;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"ninteen")){
            a[cnt]=61;
            cnt++;
            continue;
        }
        if(!strcmp(ch,"twenty")){
            a[cnt]=0;
            cnt++;
            continue;
        }
    }
    scanf("%s",ch);//暴力读掉"." 
    sort(a,a+cnt);//将所有数字由小到大排序 
    for(int i=0;i<cnt;i++){
        ans=ans*100+a[i];//组合所有数字，用unsigned long long存储 
    }
    printf("%lld",ans);//输出 
    return 0;
}
```

---

## 作者：greyishsong (赞：3)

##关于前导0

之前很多题解都有一个重要的步骤：**去除最后结果中的前导0。**

但是，其实这一步并不需要用字符串，也不需要特殊处理。

在找出数字、平方、取模、排序之后，只要每次将ans乘100再加上一个结果即可。

**正确性证明：**

设平方、取模、排序之后的数列为an，ans初值为0，则

∵an是有序序列

∴如果an中有为0的元素，那么一定排在开头

∴若a[1]=a[2]=……=a[p]=0，则ans=ans\*100+a[i]（i∈[1,p]）不改变ans的值。

∴平方取模之后为0的数字不构成前导0。

若存在a[i]满足0<a[i]<10，

①如果a[i]不是开头元素，那么ans=ans\*100+a[i]等价于在ans之后接上0×10+a[i]，即已经补上了应有的一个0。

②如果a[i]是开头的元素，那么上式会忽略补上的头一个0。

综上，不需要最终额外去除前导0。

**具体情况见代码**

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype> 
using namespace std;
const char number[21][20]={"0","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};
const char informal[7][20]={"0","a","both","another","first","second","third"};
char word[8][40];
int num[7];
long long ans=0;
int main()
{
    for(int i=1;i<=6;i++)
    {
        scanf("%s",word[i]);
        word[i][0]=tolower((int)word[i][0]);
    }
    int cnt=0;
    for(int i=1;i<=6;i++)
    {
        for(int j=1;j<=20;j++)
            if(strcmp(word[i],number[j])==0)
            {
                num[++cnt]=(j*j)%100;
                break;
            }
        if(strcmp(word[i],informal[1])==0||strcmp(word[i],informal[3])==0||strcmp(word[i],informal[4])==0)
            num[++cnt]=1;
        if(strcmp(word[i],informal[2])==0||strcmp(word[i],informal[5])==0)
            num[++cnt]=4;
        if(strcmp(word[i],informal[6])==0)
            num[++cnt]=9;
    }
    sort(num+1,num+cnt+1);
    for(int i=1;i<=cnt;i++)
    {
        ans*=100;
        ans+=num[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：ROOToj (赞：3)

模拟+字符串处理，用sort排序然后依次输出即可，建议用数组保存（高精度算法思想），避免longlong数据处理。注意：不要忽略那些“非正规”的数。小技巧：对字符数组进行预处理可以在简化代码的同时增强代码的可读性。建议：可以用中的tolower函数将单词转换为小写（此题数据较水，可以忽略这一步）。


附上AC源代码：（精简）​

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
using namespace std;
char s[100][100]=
{
```
"one","two","three","four","five","six","seven","eight","nine","ten",
"eleven","twelve","thirteen","fourteen","fifteen",

"sixteen","seventeen","eighteen","nineteen","twenty",

"a","both","another","first","second","third",

```cpp
},w[1000010];
int i,j,a[20],first=1,pd,x[100]={1,2,1,1,2,3};
int main()
{
    for(i=1;i<=6;i++)
    {
        scanf("%s",w);
        for(j=0;j<strlen(w);j++)w[j]=tolower(w[j]);
        a[i]=0;pd=1;
        for(j=0;j<=19;j++)
            if(!strcmp(w,s[j])){pd=0;a[i]=((j+1)*(j+1))%100;break;}
        if(pd)for(j=20;j<=25;j++)
            if(!strcmp(w,s[j]))
            {
                a[i]=(x[j-20]*x[j-20])%100;
                break;
            }
    }
    sort(a+1,a+1+6);
    //for(i=1;i<=6;i++)printf("%d\n",a[i]);
    for(i=1;i<=6;i++)
        if(!a[i])continue;
        else if(first){first=0;printf("%d",a[i]);}
        else if(a[i]<=9)printf("0%d",a[i]);
        else printf("%d",a[i]);
    if(first)putchar('0');
    putchar('\n');
    return 0;
}

```

---

## 作者：Error_Eric (赞：2)

# P1603

这是一道字符串~~练手题~~和一道贪心~~送分题~~……

首先，我们输入六个单词，其次按照题目要求转化为数字，
**接下来按照贪心的思想sort一下**
~~（实在不知道标啥重点了）~~

然后……就没有然后了……

### 但是呢，这道题目还是有坑点的！

坑点1：个位数要加0

坑点2：第一个数不能加0

坑点3：没有输出任何数要加0

坑点4：不要搞错到底要不要加0

~~上面的一串话真治愈强迫症~~

------------

分析完毕，所以，让我们面对着电脑，开始
~~刷存在感~~做题吧！

```cpp
#include<iostream>
#include<string.h>
#include<stdio.h>
#include<algorithm>
using namespace std;
const string p[]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third"};
const short q[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,1,2,1,1,2,3};//上面的单词所代表的数字 
int z[8],top=0,t=6;string s;//存储数据；存储数据个数 ；输入的单词数 ；输入的单词 
int main(){//灰机起飞 
	while(t--){//循环六次 
		cin>>s;//读入单词 
		for(int i=0;i<=26;i++)	//[边输入边操作]遍历p ,一个个尝试 
			if(s==p[i]) //是一个数字单词 
				z[++top]=q[i]*q[i]%100;//"将这些数字平方后%100，如00,05,11,19,86,99。" 
	}scanf(" .");//否则呢？ 
	sort(z+1,z+top+1);t=0;//贪心,小学二年级的思维水平 ；t变成判断用的变量； 
	for(int i=1;i<=top;i++)//一个个数字看一看 
		if(z[i]>0)//应当输出 
			{if(z[i]<10&&t)/*一位数，且不是第一个输出的*/ printf("0%d",z[i]+(t++)*0);else printf("%d",z[i]+(t++)*0);}
	if(!t) printf("0");//if 还没有输出呢 输出0 
	return 0;//到达华盛顿 
}
//#Error_Eric
//极致压行(22行)，你值得拥有。
```



---

## 作者：90182si (赞：2)

1. 发现题解里面都是一个单词一个单词的找，而我直接一次性读入整个字符串，再把空格改成'\0',把单词首字母下标保存下来，这样省去了检测单词个数的步骤。
2. 剩下的就是比较字符串和排序了（我用的是数组自动排序）。
```cpp
#include <iostream>
#include <cstring>
#include <stdio.h>
using namespace std;
int main()
{
    char sz[27][10]={"zero","a","both","another","first","second","third","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};
    int num[27]={0,1,2,2,1,2,3,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
    char str[60];
   	gets(str);
    int len=strlen(str),j=1,l=0,p=0,i,flag[6],number[100];
    flag[0]=0;
    for(i=0;i<100;i++)number[i]=0;
    for(i=0;i<len;i++)if(str[i]==' '){str[i]='\0';flag[j++]=i+1;}//分解字符串，将空格换成'\0',并保存单词位置
    for(i=0;i<j;i++)
    	for(int k=0;k<27;k++)
    		if(strcmp(str+flag[i],sz[k])==0)
    			number[(num[k]*num[k])%100]++;//将单词换成对应得值
    for(i=1;i<100;i++)
    	for(j=0;j<number[i];j++)
    		if(number[i]&&!p++)cout<<i;
	    	else if(number[i]&&i<10)cout<<0<<i;
	    	else if(number[i])cout<<i;
    if(!p)cout<<0;
    return 0;
}
```

---

## 作者：深海鱼的眼泪 (赞：2)

读入字符串后判断是否为数字，用数组保存，再将数字平方后转化为字符串，保存在数组里，再将字符串排序，从前到后排列。


```cpp
var a,c,t,s:string;
i,j,k:integer;
e:boolean;
b:array[1..20]of integer;
d:array[1..6]of string;
begin
  readln(a);
  e:=false;
  for i:=1 to 6 do
  begin
    c:=copy(a,1,pos(' ',a)-1);
    case c of
    'one','One','a','another','first':inc(b[1]);
    'two','Two','both','second':inc(b[2]); 
    'three','Three','third':inc(b[3]); 
    'four','Four':inc(b[4]); 
    'five','Five':inc(b[5]); 
    'six','Six':inc(b[6]); 
    'seven','Seven':inc(b[7]);
    'eight','Eight':inc(b[8]);
    'nine','Nine':inc(b[9]);
    'ten','Ten':inc(b[10]);
    'eleven','Eleven':inc(b[11]);
    'twelve','Twelve':inc(b[12]);
    'thirteen','Thirteen':inc(b[13]);
    'fourteen','Fourteen':inc(b[14]);
    'fifteen','Fifteen':inc(b[15]);
    'sixteen','Sixteen':inc(b[16]);
    'seventeen','Seventeen':inc(b[17]);
    'eighteen','Eighteen':inc(b[18]);
    'nineteen','Nineteen':inc(b[19]);
    'twenty','Twenty':inc(b[20]);
    end;
    delete(a,1,pos(' ',a));
  end;
  j:=1;
  for i:=1 to 20 do 
  begin
  while b[i]<>0 do
  begin
    str(i*i,d[j]);
    if length(d[j])>2 then
    delete(d[j],1,length(d[j])-2)
    else if length(d[j])=1 then 
    insert('0',d[j],1);
    inc(j);
    dec(b[i]);
    if j=7 then 
    begin
    e:=true;
    break;
    end;
  end;
  if e then break;
  end;
  for k:=1 to j-2 do
  for i:=1 to j-1-k do
  if d[i]>d[i+1] then 
  begin
    t:=d[i];d[i]:=d[i+1];d[i+1]:=t;
  end;
  s:='';
  for k:=1 to j-1 do 
  s:=s+d[k];
  while s[1]='0' do delete(s,1,1);
  if s<>'' then
  writeln(s)
  else writeln('0');
end.
```

---

## 作者：Ezio (赞：2)

```cpp

#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <ctime>
#include <algorithm>
#include <cstdlib>
#define For(st,ed,i) for(int i=st;i<=ed;++i)
#define Fordown(st,ed,i) for(int i=st;i>=ed;--i)
#define start(a,flag) memset(a,flag,sizeof(a));
#define scafn scanf
using namespace std;

typedef long long ll;typedef unsigned int uint;typedef unsigned long long ull;
const int INF=0x7fffffff;const int inf=0xfffffff;
const int MAXN=200020,maxn=100010;
int at[27];
int ad[7];
string st[27]={"","one","two","three","four","five","six","seven","eight","nine",
    "ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen",
    "eighteen","nineteen","twenty","a","first","another","both","second","third"
};
string wd[7];
int main(){
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    long long cnt=0;
    For(1,20,i)at[i]=i*i%100;
    at[21]=at[22]=at[23]=1;
    at[24]=at[25]=4;at[26]=9;
    For(1,6,i)cin>>wd[i];
    For(1,6,i)For(1,26,j){
        if(wd[i]==st[j]){
            ad[i]=at[j];
            break;
        }}
    sort(ad+1,ad+7);
    For(1,6,i){
        cnt*=100;
        //if(ad[i]<10&&)
        cnt+=ad[i];
    }
    cout<<cnt;
    return 0;
}

```
这道题有几个要注意的地方。一是注意不必要大写转小写，好像所有的数据已经是小写了，二是注意最后的结果要用long long 存，不然会爆。


---

## 作者：BlueArc (赞：2)

读入字符串再排序

比较规则:连接起来最小，因为一个字符串不能拆开。

注意，不能把所有的字符串排序再从小到大输出，一定要使连接起来最小。

比如考虑10，1   排序再输出是110，但正确答案是101

c++中string连接很方便，就是"+"运算符，直接把两个字符串连接起来

类似于P1012 拼数 P1107 最大整数(一样的题233)


```cpp
#include"cstdio"
#include"iostream"
#include"cstring"
#include"vector"
#include"algorithm"
#include"sstream"//创建流
#include"cctype"
using namespace std;
bool cmp(string a,string b){////string 比较连接 "+"号是string的连接，如abc+de=abcde，求最小的数即连起来最小 
 return a+b<b+a; //和P1012 拼数  P1107 最大整数  的比较函数一模一样  
}
string word[7];
vector<string> s;//01 04 09 16 25 36 49 64 81 00 21 44 69 96 25 56 89 24 61 00，存1-20平方后MOD100的两个字符
int main(){
 for(int i=1;i<=6;i++){
 cin>>word[i];
 word[i][0]=tolower(word[i][0]);//第一个字符可能大写，转成小写 
 if(word[i]=="one") {s.push_back("01");}
 if(word[i]=="two") s.push_back("04");
 if(word[i]=="three") s.push_back("09");
 if(word[i]=="four") s.push_back("16");
 if(word[i]=="five") s.push_back("25");
 if(word[i]=="six") s.push_back("36");
 if(word[i]=="seven") s.push_back("49");
 if(word[i]=="eight") s.push_back("64");
 if(word[i]=="nine") s.push_back("81");
 if(word[i]=="ten") s.push_back("00");
 if(word[i]=="eleven") s.push_back("21");
 if(word[i]=="twelve") s.push_back("44");
 if(word[i]=="thirteen") s.push_back("69");
 if(word[i]=="fourteen") s.push_back("96");
 if(word[i]=="fifteen") s.push_back("25");
 if(word[i]=="sixteen") s.push_back("56");
 if(word[i]=="seventeen") s.push_back("89");
 if(word[i]=="eighteen") s.push_back("24");
 if(word[i]=="nineteen") s.push_back("61");
 if(word[i]=="twenty") s.push_back("00");
 if(word[i]=="a") s.push_back("01");
 if(word[i]=="both") s.push_back("04");
 if(word[i]=="another") s.push_back("09");
 if(word[i]=="first") s.push_back("01");
 if(word[i]=="second") s.push_back("04");
 if(word[i]=="third") s.push_back("09");//以上水操作，一个一个添加
 }
 sort(s.begin(),s.end(),cmp);//排序(按cmp来排，即连接起来最小) 
 int first=0;//前导0 
  int ok=0;//是否有输出 
 for(vector<string>::iterator it=s.begin();it!=s.end();it++){//iterator是迭代器，类似指针 
 char a;
 stringstream ss(*it);//创建字符流 
```
/\*当然也可以这样写:
```cpp
for(int i=0;i<s.size();i++){
         char a;
         stringstream ss(s[i]);*/
 while(ss>>a) {if(a!='0'||first) {cout<<a;ok=1;}else first=1;}//去前导0,直到输出非0,一般的去0方法                            
 }
 if(!ok) cout<<"0";//没有要输出0!
}

```

---

## 作者：Sounwy (赞：1)

小白第一次发题解，超紧张qwq

看了大佬们的题解都写得简洁好看，我...【卑微】

手算%是不是很low..但是感觉挺方便的哇~

希望是萌新也能看懂的代码

AC附上

```cpp
#include <map>
#include <string.h>
#include <string>
#include <iostream>
#include <algorithm>

using namespace std;
map<string,string> maps;

string word[6];
string str="";//最初字符串为空

//排序，如果s1不大于s2就为真
bool cmpsmall(string s1,string s2)
{
    if(maps[s1][0]-'0'<maps[s2][0]-'0') return true;
    if(maps[s1][0]-'0'>maps[s2][0]-'0') return false;
    //先比较十位
    if(maps[s1][1]-'0'<=maps[s2][1]-'0') return true;
    return false;
    //再比较个位
}

int main()
{
    maps["one"]="01";
    maps["two"]="04";
    maps["three"]="09";
    maps["four"]="16";
    maps["five"]="25";
    maps["six"]="36";
    maps["seven"]="49";
    maps["eight"]="64";
    maps["nine"]="81";
    maps["ten"]="00";
    maps["eleven"]="21";
    maps["twelve"]="44";
    maps["thirteen"]="69";
    maps["fourteen"]="96";
    maps["fifteen"]="25";
    maps["sixteen"]="56";
    maps["seventeen"]="89";
    maps["eighteen"]="24";
    maps["nineteen"]="61";
    maps["twenty"]="00";
    maps["a"]="01";
    maps["both"]="04";
    maps["another"]="01";
    maps["first"]="01";
    maps["second"]="04";
    maps["third"]="09";
    //打字典，直接算好
    //因为找最小的，所以转换时直接存最小的（小的放前面）->对所有的word进行排序
    //注意单词别拼错啦~~

    string temp;
    int j=1;//记录word的下标
    for(int i=0;i<6;i++)
    {
        cin>>temp;
        if(maps[temp]!="\0"&&maps[temp]=="00") continue;//没对应的和“00”就不用存了
        word[j++]=temp;
    }
    j--;//存了j--个字符串

    char ch;
    cin>>ch;//输入“.”

    sort(word+1,word+j+1,cmpsmall);//排序（由小到大）

    for(int i=1;i<=j;i++)
    {
        str+=maps[word[i]];//连接字符串
    }

    if(str=="") cout<<"0"<<endl;//字符串处理注意特殊情况，如果转换出来全是“00”，那么字符串就是空的，所以输出0，不然会显示“too short on line 1”
    else
    {
        if(str[0]=='0') str.erase(0,1);//如果最高位是0就删去
        cout<<str<<endl;
    }

    return 0;
}

```

！！！！输出的第一步处理一定要有！！！！，那个WA磨了我好久..TuT..

---

## 作者：westfallon (赞：1)

利用c++STL中的map
```cpp
//  洛谷p1603
//  Created by 卢延昌 on 2018/12/4.
//  Copyright © 2018 westfallon. All rights reserved.

#include <iostream>
#include <cstdio>
#include <cstring>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cctype>

using namespace std;

map<string,int>a;

void init()
{
    a["one"]=1;a["two"]=4;a["three"]=9;a["four"]=16;a["five"]=25;
    a["six"]=36;a["seven"]=49;a["eight"]=64;a["nine"]=81;a["ten"]=0;
    a["eleven"]=21;a["twelve"]=44;a["thirteen"]=69;a["fourteen"]=96;
    a["fifteen"]=25;a["sixteen"]=56;a["seventeen"]=89;
    a["eighteen"]=24;a["nineteen"]=61;a["twenty"]=0;a["a"]=1;
    a["both"]=4;a["another"]=1;a["first"]=1;a["second"]=4;
    a["third"]=9;
}

string put_in;
int put_out[8];
int l=0;

int main()
{
    init();
    for(int i=1;i<=6;i++)
    {
        cin>>put_in;
        put_out[++l]=a[put_in];
    }
    sort(put_out+1,put_out+l+1);
    bool flag=false;
    for(int i=1;i<=l;i++)
    {
        if(!flag)  //首位
        {
            if(put_out[i]==0)
                continue;
            else
            {
                printf("%d",put_out[i]);
                flag=true;
            }
        }
        else
            printf("%.2d",put_out[i]);
    }
    if(!flag)
        printf("0\n");
    return 0;
}
```


---

## 作者：底层码农 (赞：1)

这道题直接把每个英文表示的数字直接算出来，到时候直接查表找出对应结果，你也可以不算,但是必须要把 英文字母 和 每个英文表示的数字 对应起来。
英文字母------>>每个英文表示的数字;
你可以用C++STL中的图来存储（map）,其实这道题完全可以用两个数组来代替；
具体代码如下，看代码的解释；

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<iomanip>
using namespace std;
string str[30] = { "zero","one", "two","three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty", "a", "both", "another", "first", "second", "third" };
int value[30] = { 0,1,4,9,16,25,36,49,64,81,0,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9 };

//比较函数 如果有的话就返回对应的值，没有的话就返回0 （也可以用stl中的图来存（map））
int searchs(string strs)
{
	int i;
	for (i = 0; i < 25; i++)
	{
		if (strs == str[i])
			break;
	}
	if (i < 25)
	{
		return value[i];
	}
	else
	{
		return 0;
	}

}

int main()
{
	string in;
	int flag = 0;
	int input[10];
	for (int i = 1; i <= 6; i++)
	{
		cin >> in;
		input[i] = searchs(in);
		
	}
	sort(input+1, input + 7);

	for (int i = 1; i <= 6; i++) {
		if (input[i] == 0)continue;
		
		if (flag) {//第一个数不会执行
			cout << setw(2) << setfill('0');  //设置宽度为2，不足的左边填充0 c语言printf("%.2d",input[i]);
			cout << input[i];
			
		}
		else {//第一个数要分开来看 题目要求（如果开头为0，就去0）
			cout << input[i];
			flag = 1;
		}
		
	}
	//如何没有一个单词满足记得输出0(不要问我为什么知道的、、、、、、、、)
	//Chen Junao is no so clever .
	//0
	if (flag == 0) {
		cout << "0";
	}
	cout << endl;
	return 0;
}

```

---

## 作者：Dilute (赞：1)

##总体这道题目不水也不难，我个人感觉就是某些地方有些麻烦，代码不长（除去万恶的map）

###具体思路：

###就是用string把每个给存起来，然后把每个数字存到num里面，再进行玄学排序最后输出。


```cpp
#include<bits/stdc++.h> // 万能头文件

using namespace std;

map <string, int> k; // 这题个人感觉用map比较方便

bool cmp(int a, int b){ // 玄学排序的比较函数
    return a * 100 + b > b * 100 + a;
    // 就是比较两个数那个放在前面更加小一些
    // 可以自己分析一下
}

int main(){
    k["one"] = 1;
    k["two"] = 2;
    k["three"] = 3;
    k["four"] = 4;
    k["five"] = 5;
    k["six"] = 6;
    k["seven"] = 7;
    k["eight"] = 8;
    k["nine"] = 9;
    k["ten"] = 10;
    k["eleven"] = 11;
    k["twelve"] = 12;
    k["thirteen"] = 13;
    k["fourteen"] = 14;
    k["fifteen"] = 15;
    k["sixteen"] = 16;
    k["seventeen"] = 17;
    k["eighteen"] = 18;
    k["nineteen"] = 19;
    k["twenty"] = 20;
    k["a"] = 1;
    k["both"] = 2;
    k["another"] = 1;
    k["first"] = 1;
    k["second"] = 2; // 将map初始化一下，方便后面的取用
    k["third"] = 3; // 这段其实是复制了楼下（捂嘴）
    string s[10]; // 存储六个单词 为了方便直接搞成了
    int num[10];
    int cou = 0;
    memset(num, -1, sizeof(num));
    for(int i = 1; i <= 6; i++){ // 读入6次
        cin >> s[i];
        int len = s[i].size();
        for(int j = 0; j < len; j++){
            if(s[i][j] >= 'A' && s[i][j] <= 'Z') s[i][j] -= 'A' - 'a'; // 统一转换成小写
            if(s[i][j] == '.') s[i].erase(j); // 如果是‘.’那么直接把它删除，不影响判断
        }
        if(k[s[i]]){
            num[i] = k[s[i]]; // 生成对应的数字
            num[i] = num[i] * num[i] % 100;
            cou++; // 把生成数字的数量加1
        }
    }
    if(cou == 0){ // 特判0
        printf("0");
        return 0;
    }
    sort(num+1, num+7, cmp); // 进行玄学排序（具体看cmp）
    printf("%d", num[cou]); // 避免前导0
    for(int i = cou - 1; i > 0; i--){ // 由于会把-1排到后面，所以应该这么输出
        if(num[i] / 10 == 0) printf("0");
        printf("%d", num[i]);
    }
}
```

---

## 作者：bjrjk (赞：1)

我觉得这个写的相对于其它的写的已经是很简单的了：

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
struct s{
    string n;
    string t;
}pass[26]={
    {"one","01"},{"two","04"},{"three","09"},{"four","16"},{"five","25"},{"six","36"},{"seven","49"},{"eight","64"},{"nine","81"},
    {"ten","00"},{"eleven","21"},{"twelve","44"},{"thirteen","69"},{"fourteen","96"},{"fifteen","25"},{"sixteen","56"},{"seventeen","89"},
    {"eighteen","24"},{"nineteen","61"},{"twenty","00"},{"a","01"},{"both","04"},{"another","01"},{"first","01"},{"second","04"},{"third","09"}
}; //提前把平方取余都算出来
string searchs(const string & s){
    for(int i=0;i<26;i++){
        if(s==pass[i].n){
            return pass[i].t;
        }
    }
    return "00";
}//在列表中查找是否存在，不存在返回00
int main(){
    bool output=false; //专为第三点设置
    string str;
    string x[6];
    for(int i=0;i<6;i++){
        cin>>str;
        x[i]=searchs(str);
    }
    sort(x,x+6);//利用string字典序的特性即可升序排序
    bool flag=false;//判断从哪里要开始输出0，什么时候不要输出0
    for(int i=0;i<6;i++){
        if(x[i]=="00")continue;
        if(x[i][0]=='0'&&flag==false){
            flag=true;
        }else cout<<x[i][0];
        cout<<x[i][1];
        output=true;
    }
    if(!output)cout<<"0";//整个过程中都没有输出最后补一个0
}
```

---

## 作者：TBB_Nozomi (赞：1)

这个题目相当想问一句跟字符串有什么关系……

这个题目的数据特殊性保证了可以输入一个字符串不包括句号

所以基本操作就是输入字符串，看它有没有对应的数值(count)，然后得到全体有数的列表，排序，最后根据排序不等式得到逆序和

当然最大数据是100^6，unsigned long long肯定够

当然要提前打表啊(滑稽)

使用map进行打表，count查询，vector存储并排序

```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
map<string,int>    di;
vector<int>    que;
int main()    {
        di["one"]=di["a"]=di["another"]=di["first"]=1;
        di["two"]=di["both"]=di["second"]=4;
        di["three"]=di["third"]=9;
        di["four"]=16;
        di["five"]=25;
        di["six"]=36;
            di["seven"]=49;
            di["eight"]=64;
            di["nine"]=81;
            di["ten"]=0;
            di["eleven"]=21;
            di["twelve"]=44;
            di["thirteen"]=69;
            di["fourteen"]=96;
            di["fifteen"]=25;
            di["sixteen"]=56;
            di["seventeen"]=89;
            di["eighteen"]=24;
            di["nineteen"]=61;
            di["twenty"]=0;
    
            string in;
            int i;
            for(i=0;i<6;i++)    {
                        cin>>in;
                        if(di.count(in)>0)    que.push_back(di[in]);
            }
            sort(que.begin(),que.end());
    
            unsigned long long S=0;
            vector<int>::iterator    iter;
            for(iter=que.begin();iter!=que.end();iter++)    S=S*100+(*iter);
            cout<<S;
            return 0;
}
```

---

## 作者：Sino_E (赞：1)

```cpp
//因为看下面都很复杂的样子所以我来提一份简单的qwq 
//无需使用字符串，直接map映射之后深搜（因为6个单词的数据范围不大），枚举所有情况即可 
//第四个点的范围超出了int，因此要使用long long。
//以上。 
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<map>
using namespace std;
map<string,int> pa;
const long long INF=0x7ffffffff;

void Inita(){
    pa["one"]=1;
    pa["two"]=2;
    pa["three"]=3;
    pa["four"]=4;
    pa["five"]=5;
    pa["six"]=6;
    pa["seven"]=7;
    pa["eight"]=8;
    pa["nine"]=9;
    pa["ten"]=10;
    pa["eleven"]=11;
    pa["twelve"]=12;
    pa["thirteen"]=13;
    pa["fourteen"]=14;
    pa["fifteen"]=15;
    pa["sixteen"]=16;
    pa["seventeen"]=17;
    pa["eighteen"]=18;
    pa["nineteen"]=19;
    pa["twenty"]=20;
    pa["a"]=1;
    pa["both"]=2;
    pa["another"]=1;
    pa["first"]=1;
    pa["second"]=2;
    pa["third"]=3;
}//打表用 

bool tag[10];
long long biggest=INF;//之前看错题写成了biggest不用在意qwq 
int nums[10]={0},k;
void DFS(long long now,int fl){
    if(fl==k&&now<biggest)biggest=now;
    else{
        for(int i=0;i<k;i++)
            if(!tag[i]){
                tag[i]=1;
                DFS(now*100+nums[i],fl+1);
                tag[i]=0;
            }
    }
}//很好懂的搜索 

int main(){
    Inita();
    string a;
    while(cin>>a){
        if(pa.count(a))nums[k]=pa[a],nums[k]=(nums[k]*nums[k])%100,k++;
    }//查数字，放到数组等待搜索 
    DFS(0,0);
    cout<<biggest;
    return 0;
}
```

---

## 作者：lucas1522 (赞：1)

这道题真的是一道水题......
# 真的~~太水了~~
想一下怎么做，然后硬写了一个cmp函数，活生生的来比较英语单词和字母......
好了，不废话：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>//别用bits！
using namespace std;
char a[30],b[30],c[30],d[30],e[30],f[30];//存储六个单词
int an[7];//存储单词转换成的数字
bool used=false;//输出过没有（看后面）
int cmp(char p[]);//暴力比较函数
int main(){
	memset(an,-1,sizeof(an));//先初始化为-1，就是不是数字
	scanf("%s %s %s %s %s %s.",a,b,c,d,e,f);//暴力scanf
	//cout<<a<<b<<c<<d<<e<<f;//测试，路过
	an[0]=cmp(a);an[1]=cmp(b);an[2]=cmp(c);an[3]=cmp(d);an[4]=cmp(e);an[5]=cmp(f);//暴力魔法：单词变数字
	for(int i=0;i<6;i++){//数字处理，按照题目要求变换
		if(an[i]!=-1)//设置成-1的好处，-1不是数字直接跳过
			an[i]=(an[i]*an[i])%100;//别用math.h，有时会掉精
	}
	sort(an,an+6);//排序，algorithm少不了
	for(int i=0;i<6;i++){//输出
		if(an[i]!=-1){//-1非数字直接跳过
			if(an[i]==0&&used==true){//如果0，但是有输出过
				printf("00");//补0
			}else if(an[i]==0&&used==false)//高位为0
				continue;//路过
			else if(used==false){//高位不为0
				used=true;//标记输出过
				printf("%d",an[i]);//然后输出
			}
			else if(used==true){
				if(an[i]<10)//不够补0
					printf("0%d",an[i]);
				else
					printf("%d",an[i]);//够就输出
			}
		}
	}
	if(used==false)	printf("0");//如果没有，0！
	return 0;//跑路
}
int cmp(char p[]){//暴力枚举，我就不注释了
	if(!strcmp(p,"one"))	return 1;
	else if(!strcmp(p,"a"))	return 1;
	else if(!strcmp(p,"first"))	return 1;
	else if(!strcmp(p,"two"))	return 2;
	else if(!strcmp(p,"both"))	return 2;
	else if(!strcmp(p,"three"))	return 3;
	else if(!strcmp(p,"third"))	return 3;
	else if(!strcmp(p,"four"))	return 4;
	else if(!strcmp(p,"five"))	return 5;
	else if(!strcmp(p,"six"))	return 6;
	else if(!strcmp(p,"seven"))	return 7;
	else if(!strcmp(p,"eight"))	return 8;
	else if(!strcmp(p,"nine"))	return 9;
	else if(!strcmp(p,"ten"))	return 10;
	else if(!strcmp(p,"second"))	return 2;
	else if(!strcmp(p,"eleven"))	return 11;
	else if(!strcmp(p,"twelve"))	return 12;
	else if(!strcmp(p,"thirteen"))	return 13;
	else if(!strcmp(p,"fourteen"))	return 14;
	else if(!strcmp(p,"fifteen"))	return 15;
	else if(!strcmp(p,"sixteen"))	return 16;
	else if(!strcmp(p,"seventeen"))	return 17;
	else if(!strcmp(p,"eighteen"))	return 18;
	else if(!strcmp(p,"nineteen"))	return 19;
	else if(!strcmp(p,"twenty"))	return 20;
	else if(!strcmp(p,"another"))	return 2;
	else if(!strcmp(p,"zero"))	return 0;
	else return -1;
}
```

---

## 作者：lanceloo (赞：1)

```c++
#include<bits/stdc++.h>
using namespace std;

template<class T>
int length(T& arr)
{
    return sizeof(arr) / sizeof (arr[0]);
}

map<string, string> word2num;

string words[] = { "one", "two", "three", "four", "five","six", "seven", "eight", "nine", "ten",
                   "eleven", "twelve", "thirteen", "fourteen","fifteen", "sixteen", "seventeen", 
		   "eighteen","nineteen", "twenty" ,"a", "both", "another","first", "second", "third"};

string words2num[] = {"01","04","09","16","25","36","49","64","81","00","21","44","69","96","25","56",
				      "89","24","81","00","01","04","01","01","04","09"};

int main() {
    string s;
    string answer = "";
    string ans[10];
    for(int i = 0; i < length(words); i ++){
        word2num[words[i]] = words2num[i];
    }
    for(int i = 0; i < 6; i++){
        cin>>s;
        if(strstr(s.c_str(),".") != NULL)
            s.erase(s.end()-1);
        ans[i] = word2num[s];
    }
    sort(ans,ans + 6);
    for(int i = 0; i < length(ans); i ++){
        answer += ans[i];
    }
    if(answer.size() != 0){
        if(answer[0]=='0') answer.erase(answer.begin());
        	cout<<answer<<endl;
    }
    else{
        cout<<0;
    }
	return 0;
}
```
简单的题目硬是通过调库写得臃肿，不过里面蕴含的知识点还挺多，做题不是目的，学到C++的一些语法和STL才是首要的。
首先这个
```C++
template<class T>
int length(T& arr)
{
    return sizeof(arr) / sizeof (arr[0]);
}
```
是定义一个获取数组元素个数的模板。
然后
```C++
map<string, string> word2num;

string words[] = { "one", "two", "three", "four", "five","six", "seven", "eight", "nine", "ten",
                   "eleven", "twelve", "thirteen", "fourteen","fifteen", "sixteen", "seventeen", 
		   "eighteen","nineteen", "twenty" ,"a", "both", "another","first", "second", "third"};

string words2num[] = {"01","04","09","16","25","36","49","64","81","00","21","44","69","96","25","56",
				      "89","24","81","00","01","04","01","01","04","09"};
                 
 for(int i = 0; i < length(words); i ++){
        word2num[words[i]] = words2num[i];
    }                      
                      
```
通过map构造映射方便查询，这样在处理多于6个的单词时不用轮询。
剩下的就是基本操作了

---

## 作者：KKarshilov (赞：1)

纯粹用if做的啊，打的手都麻了。。不过应该比较好理解

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <cstdio>
using namespace std;
string s[7],s1[7],s2; //s输入，s1存储，s2结果
bool a[7];//状态，看似没用，其实有用
int b=0;//同上
int comp(string x,string y)
{
    if(x+y>y+x)
      return 0;
    if(x+y<y+x)
      return 1;
    return 0;
```
}//这个排序函数应该都能理解吧，就是字符串拼接比大小
```cpp
int main(int argc, char** argv) 
{
    for(int i=1;i<=6;i++)
      cin>>s[i];
    for(int i=1;i<=6;i++)
    {
        if(s[i]=="zero")
          {s1[i]="00";a[i]=1;}//不知道有没有0，判断一下，顺便改个状态
        else if(s[i]=="one"||s[i]=="a"||s[i]=="first")
          {s1[i]="01";a[i]=1;}//保存取余的值
        else if(s[i]=="two"||s[i]=="second"||s[i]=="both")
          {s1[i]="04";a[i]=1;}
        else if(s[i]=="three"||s[i]=="third"||s[i]=="another")
          {s1[i]="09";a[i]=1;}
        else if(s[i]=="four")
          {s1[i]="16";a[i]=1;}
        else if(s[i]=="five")
          {s1[i]="25";a[i]=1;}
        else if(s[i]=="six")
          {s1[i]="36";a[i]=1;}
        else if(s[i]=="seven")
          {s1[i]="49";a[i]=1;}
        else if(s[i]=="eight")
          {s1[i]="64";a[i]=1;}
        else if(s[i]=="nine")
          {s1[i]="81";a[i]=1;}
        else if(s[i]=="ten")
          {s1[i]="00";a[i]=1;}
        else if(s[i]=="eleven")
          {s1[i]="21";a[i]=1;}
        else if(s[i]=="twelve")
          {s1[i]="44";a[i]=1;}
        else if(s[i]=="thirteen")
          {s1[i]="69";a[i]=1;}
        else if(s[i]=="fourteen")
          {s1[i]="96";a[i]=1;}
        else if(s[i]=="fifteen")
          {s1[i]="25";a[i]=1;}
        else if(s[i]=="sixteen")
          {s1[i]="56";a[i]=1;}
        else if(s[i]=="seventeen")
          {s1[i]="89";a[i]=1;}
        else if(s[i]=="eighteen")
          {s1[i]="24";a[i]=1;}
        else if(s[i]=="nineteen")
          {s1[i]="61";a[i]=1;}
        else if(s[i]=="twenty")
          {s1[i]="00";a[i]=1;}
```
}//我造这段很烦，我也烦它
```cpp
    sort(s1+1,s1+7,comp);//排序
    for(int i=1;i<=6;i++)
    {
      s2+=s1[i]; //拼接，以样例为例，000425
    }
    for(int i=0;i<s2.size();i++)
      if(s2[i]!='0'||(s2[i-1]!='0'&&i>=1))//去前导0
        cout<<s2[i];
    for(int i=1;i<=6;i++)
    {
        if(!a[i])
          b++;//派上用场了。。用来判断输入有没有数字，没有++
        if(b==6)
        {
          cout<<"0"<<endl;//如果没有，输出0
          return 0;
        }
    }
    cout<<endl;
    return 0;
}

```

---

## 作者：残风落叶 (赞：0)

**这题好皮啊**

**一直认为“非正规”指“不合法”，结果是指合法的（~~又一道贱题，出题人也真黑~~）**

核心也就是字符串的取段、查找、排序

取段
```
if (ss[i]==' ')//是否为单词
	get=ss.substr(t+1,i-t-1);//取出字符串
```
查找

```
for(int j=1;j<=20;++j)//枚举1到20
	if (s[j]==get)//判断是否匹配
	{
		a[cnt]=square[j];
		cnt++;
	}
if (get=="a"||get=="another"||get=="first")//特殊的特殊处理（a,another,first）
{
	a[cnt]=1;
	cnt++;
}
else
	if (get=="both"||get=="second")//特殊的特殊处理（both,second）
	{
		a[cnt]=2;
		cnt++;
	}
	else
		if (get=="third")//特殊的特殊处理（third）
		{
			a[cnt]=3;
			cnt++;
		}
```
排序（~~用sort也行，个人爱好~~）

```
void quicksort(int left,int right)//快排走起
{
	if (left>right)//判断是否相遇
		return;
	int i,j,t;
	t=a[left];//t中存基准书
	i=left;
	j=right;
	while(i!=j)
	{
		while(a[j]>=t&&i<j)
			--j;//顺序很重要，要先从右往左找
		while(a[i]<=t&&i<j)
			++i;//顺序很重要，再从左往右找
		if (i<j)//当左右相遇，交换
			swap(a[i],a[j]);
	}
	a[left]=a[i];
	a[i]=t;//基准书归位
	quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程
	quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程
	return;//快排结束
}
```
最后组合程序
```
#include<bits/stdc++.h>
using namespace std;
string s[21]={"","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};//存数字
string ss,get;
int square[21]={0,1,4,9,16,25,36,49,64,81,0,21,44,69,96,25,56,89,24,61,0};//对应
int a[7];
long long ans;//必须开long long，不然存不下
int n,t,cnt=1;
void quicksort(int left,int right)//快排走起
{
	if (left>right)//判断是否相遇
		return;
	int i,j,t;
	t=a[left];//t中存基准书
	i=left;
	j=right;
	while(i!=j)
	{
		while(a[j]>=t&&i<j)
			--j;//顺序很重要，要先从右往左找
		while(a[i]<=t&&i<j)
			++i;//顺序很重要，再从左往右找
		if (i<j)//当左右相遇，交换
			swap(a[i],a[j]);
	}
	a[left]=a[i];
	a[i]=t;//基准书归位
	quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程
	quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程
	return;//快排结束
}（用sort也行）
int main()
{
	getline(cin,ss);
	ss=' '+ss;
	t=0;
	for(int i=1;i<ss.size();++i)
	{
		if (ss[i]==' ')//是否为单词
        	{
			get=ss.substr(t+1,i-t-1);//取出字符串
			for(int j=1;j<=20;++j)//枚举1到20
				if (s[j]==get)//判断是否匹配
				{
					a[cnt]=square[j];
					cnt++;
				}
			if (get=="a"||get=="another"||get=="first")//特殊的特殊处理（a,another,first）
			{
				a[cnt]=1;
				cnt++;
			}
			else
				if (get=="both"||get=="second")//特殊的特殊处理（both,second）
				{
					a[cnt]=2;
					cnt++;
				}
				else
					if (get=="third")//特殊的特殊处理（third）
					{
						a[cnt]=3;
						cnt++;
					}
			get="";//忘记改为空字符串就尴尬了
			t=i;//字符串起始位置更新
			}
	}
	quicksort(1,cnt-1);
	for(int i=1;i<cnt;++i)
		ans=ans*100+a[i];//组合数据
	printf("%lld\n",ans);//输出
    	return 0;
}
```


---

## 作者：lolilukia (赞：0)

其实还是排序问题，按高位往低位比较，越小的数排在越前面，最后在输出的时候进行处理就好了

```cpp
#include<iostream>
#include<string>
using namespace std;
int ele[6];
int size = 0;
string lib[]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"};
int isNumber(string a);
bool compare(int a, int b);
int isNumber(string a){
    int s = a.length();
    if(a[s-1]=='.') a = a.substr(0, s-1);  //为了防止句号影响判断，对存在句号的字符串进行截取
    for(int i=0;i<21;i++){
        if(a==lib[i]){
            return (i*i)%100;
        } 
    }
    if(a=="a"||a=="another"||a=="first") return 1;
    else if(a=="both"||a=="second") return 4;
    else if(a=="third") return 9;
    else return -1;
}
bool compare(int a, int b){   //进行比较
    if(a/10<b/10) return true;
    else if(a/10>b/10) return false;  //比较十位
    else{
        if(a%10<=b%10) return true;  //比较个位
        else return false;
    }
}
int main(){
    for(int i=0;i<6;i++){
        string a;
        cin >> a;
        if((int)a[0]<97) a[0] += 32;
        if(isNumber(a)!=-1) ele[size++] = isNumber(a);    //平方取模的结果存储在数组里
    }
    int tag = 0;
    for(int i=0;i<6;i++){
        for(int j=i+1;j<6;j++){
            if(compare(ele[j], ele[i]))   //比较较小的数放在前面
                swap(ele[j], ele[i]);
        }
        if(tag==1 && ele[i]!=0 && ele[i]<=9) cout<<"0"<<ele[i];   //如果已经不是第一个输出的只有一位的数，把0补全
        else if(tag==0 && ele[i]!=0){   //如果是第一个输出的数，无论几位都不补全零
            cout<<ele[i];
            tag = 1;
        }
        else if(ele[i]!=0) cout<<ele[i];  //不是个位数的数，照常输出，只要不是零
    }
    if(size==0) cout<<0;  //没有代表数字的单词，就输出零
    return 0;
}
```

---

## 作者：xukuan (赞：0)




```cpp
var
 s,s1:string;
 i,n,t:longint;
 a:array[0..100] of string;
 b:array[1..26] of string=('one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen','twenty','a','both','another','first','second','third');//数字
procedure qsort(var a:array of string; s,t:longint);//快排
 var
  i,j:longint;
  x:string;
 begin
  i:=s; j:=t; x:=a[i];
  repeat
   while (a[j]>=x) and (j>i) do j:=j-1;
   if i<j then begin a[i]:=a[j]; i:=i+1; end;
   while (a[i]<=x) and (i<j) do i:=i+1;
   if i<j then begin a[j]:=a[i]; j:=j-1; end;
  until i=j;
  a[i]:=x;
  i:=i+1; j:=j-1;
  if s<j then qsort(a,s,j);
  if i<t then qsort(a,i,t);
end;
begin
 readln(s); s:=s+' ';
 t:=pos(' ',s);
 while t<>0 do//找出每一个单词并判断是不是数字，如果是，写成平方模100的形式（保留两位）
  begin
   inc(n);
   s1:=copy(s,1,t-1);//取出单词
   for i:=1 to 26 do//‘zero’忽视掉，没用
    if s1=b[i] then
     begin
      case i of
       1..20:begin str(i*i mod 100,a[n]); if length(a[n])=1 then a[n]:='0'+a[n]; end;
       21,23,24:a[n]:='01';
       22,25:a[n]:='04';
       26:a[n]:='09';
      end;
      inc(n);
      break;
     end;
   delete(s,1,t);//删除
   dec(n);
   t:=pos(' ',s);
  end;
 if n=0 then begin writeln(n); exit; end;//判断有无数字
 qsort(a,1,n);
 s:=''; s1:='';
 for i:=1 to n do
  s:=s+a[i];//串成一个数
 while s[1]='0' do delete(s,1,1);//删去高位的‘0’
 writeln(s); 
end.

```

---

## 作者：cn_lemon (赞：0)

/\*
这里发一个智障题解：

我为了排序竟然用了dfs ，丧心病狂、、

下面是我的代码，

我感觉恶心的是题意不清啊，第三个数据我看了好久，才知道a也算数字 1 ，巨坑

\*/
    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char words[21][25]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven",
"twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};
char c[300];
int len,a[100010],b[100010],t;
long long minn=999999999999999999;
void turn()
{
    int i;
    for(i=0;i<len;i++)
    if(c[i]<=90)c[i]+=32;
}
void dfs(int k,long long sum)
{
    int i;
    if(k>t)
    {
        if(sum<minn)minn=sum;
        return;
    }
    for(i=1;i<=t;i++)
    if(b[i]==0)
    {
        b[i]=1;
        dfs(k+1,sum*100+a[i]);
        b[i]=0;
    }
}
int main()
{
    int i;
    while(1)
    {
        scanf("%s",c);
        if(c[0]=='.')break;
        len=strlen(c);
        turn();
        for(i=0;i<=20;i++)
        if(strcmp(c,words[i])==0)a[++t]=i*i%100;
          if(strcmp(c,"a")==0)a[++t]=1;
    }
    dfs(1,0);
    printf("%lld",minn);
}
```

---

## 作者：bztMinamoto (赞：0)

//这题弄得我提交了不知道多少次，题解几乎看不懂（笑）

//map不知道是什么不过也可以做，就是烦了点，蛮简单

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
using namespace std;
string s[6],a[6];
//s读入每个字符串，a存每个两位数
string t;
int m;
int k;
bool tmp(string x,string y)
{
    return x+y<y+x;
}
//sort函数把字符串排好
int main()
{
    for(int i=0;i<6;i++)
    {cin>>s[i];
    for(int j=0;j<s[i].size();j++)
    if(s[i][j]>='A'&&s[i][j]<='Z')
    s[i][j]+=32;
    }
//读入字符串，将大写转换为小写
    if(s[5][s[5].size()-1]=='.')
    s[5].erase(s[5].size()-1);
//删掉句号。也可以在1到5的字符串后加上一个句号，不过这样的话后面判定时也应加上句号
    for(int i=0;i<6;i++)
    { if(s[i]=="zero") {a[m++]="00";continue;}
    if(s[i]=="one") {a[m++]="01";continue;}
    if(s[i]=="two") {a[m++]="04";continue;}
    if(s[i]=="three") {a[m++]="09";continue;}
    if(s[i]=="four"){ a[m++]="16";continue;}
    if(s[i]=="five"){ a[m++]="25";continue;}
    if(s[i]=="six") {a[m++]="36";continue;}
    if(s[i]=="seven") {a[m++]="49";continue;}
    if(s[i]=="eight") {a[m++]="64";continue;}
    if(s[i]=="nine") {a[m++]="81";continue;}
    if(s[i]=="ten") {a[m++]="00";continue;}
    if(s[i]=="eleven") {a[m++]="21";continue;}
    if(s[i]=="twelve") {a[m++]="44";continue;}
    if(s[i]=="thirteen") {a[m++]="69";continue;}
    if(s[i]=="fourteen"){ a[m++]="96";continue;}
    if(s[i]=="fifteen") {a[m++]="25";continue;}
    if(s[i]=="sixteen"){ a[m++]="56";continue;}
    if(s[i]=="seventeen"){ a[m++]="89";continue;}
    if(s[i]=="eighteen"){ a[m++]="24";continue;}
    if(s[i]=="nineteen"){ a[m++]="61";continue;}
    if(s[i]=="twenty") {a[m++]="00";continue;}
    if(s[i]=="a") {a[m++]="01";continue;}
    if(s[i]=="both") {a[m++]="04";continue;}
    if(s[i]=="another"){ a[m++]="01";continue;}
    if(s[i]=="first") {a[m++]="01";continue;}
    if(s[i]=="second"){ a[m++]="04";continue;}
    if(s[i]=="third"){ a[m++]="09";continue;}
        }
//m用来存已有的数字个数，a数组存每个两位数
//烦了点，凑合着看吧
    sort(a,a+m,tmp);
//排好顺序
    if(m)
    {
    for(int i=0;i<m;i++)
    t+=a[i];
//将字符串合并
    k=0;
    while(t[k]=='0')
    k++;
//找到第一个不等于零的数
    for(;k<m*2;k++)
    cout<<t[k];
//用字符一个一个输出
//很暴力就是了
 }
    else
    printf("0");//如果一个数字都没有输出0
}
```

---

## 作者：lxzy_Zby (赞：0)

这道题首先我们应该考虑把对应的字符都存到一个二维的字符数组中，以便查找。

其次为了便于搜索正规和非正规的单词，我们最好把正规 "one"---"twenty"存到相邻的1-20空间。这样就可以在查找的过程中直接用数组角标代替。

再就是非正规单词的储存，一共有6个，为了便于处理，我们把这6个单词放到21-26中。另设一int型数组，储存这6个单词所代表的值。

cin每次读入一个单词，从1-20扫一遍属不属于其中，再从21-26扫一遍，看属不属于其中。

如果属于上述一种，则用一个a数组储存这个数的平方mod100.

当全部的单词都被处理之后把 a数组从小到大排序。

用一个ans变量累加相连即可；

#注意，累加的值有可能很大，开long long 来存储！！

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
long long ans;
int a[100],cnt;
char str[10000],f[]=".";
char s[][1000]={" ","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen", "eighteen","nineteen","twenty","a","both","another","first","second","third"};
int sun[10]={1,2,1,1,2,3};
int main()
{
    while(1)
    {
        cin>>str;
        int lenn=strlen(str);
        for(int i=0;i<lenn;i++){
            if('A'<=str[i]&&str[i]<='Z')
                str[i]+=20;
        }
        if(!strcmp(str,f)) break;
        int flag=0;
        for(int i=1;i<=20;i++){
            if(!strcmp(str,s[i])){
                flag=i;
                break;
            }
        }
        for(int i=21;i<=26;i++){
            if(!strcmp(str,s[i])){
                flag=sun[i-21];
            }
        }
        if(flag) a[++cnt]=(flag*flag)%100;
        memset(str,0,sizeof str);
    }
    sort(a+1,a+cnt+1);
    for(int i=1;i<=cnt;i++)
        ans=ans*100+a[i];
    printf("%lld",ans);
    return 0;
}

```


---

## 作者：zhengrunzhe (赞：0)

#第三个点有鬼

字符串操作

核心：用sort排序排出最小方案

详细过程见代码

```cpp
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
string a,s[22]=   //表，方便
{
    "","one","two","three","four",
    "five","six","seven","eight",
    "nine","ten","eleven","twelve",
    "thirteen","fourteen","fifteen","sixteen",
    "seventeen","eighteen","nineteen","twenty"
},c[7];
int i,j,b[7];
bool cmp(string x,string y)   //用sort直接比较出最小的
{
    return x+y<y+x;
}
string ch(int x)   //将数字转成字符，主程序会用到
{
    string y;
    y.push_back(x+48);
    return y;
}
int ffind(string x)   //查表，表s内是按1~20排序的，所以该单词是第几个单词则这个单词代表几，如s[13]="thirteen"，thirteen就是13
{
    for (int y=1;y<21;y++)if (s[y]==x)return y;
    return 0;   //如果没找到，说明是“不正经单词”或什么玩意都不是，返回0作为标记
}
int main()
{
    for (i=1;i<7;i++)
    {
        cin>>a;b[i]=ffind(a);  //将b数组作为每个单词的值
        if (a=="first" || a=="a" || a=="another")b[i]=1;  //因为表内只有数词，这些“不正经单词”需要再判断
        if (a=="both" || a=="second")b[i]=2;
        if (a=="third")b[i]=3;
    }
    for (i=1;i<7;i++)
    {
        if (!b[i])continue;    //如果这个数是0，说明不是东西，忽略
        b[i]=b[i]*b[i]%100;  //按题意，平方后%100
        if (b[i]<10)c[j++]="0"+ch(b[i]);   如果处理后的数字<10，如4，则要变成04，就将"0"和'4'合并成"04"，存在c中
        else c[j++]=ch(b[i]/10)+ch(b[i]%10);   //如果>=10，直接把十位和个位转成字符后合并
    }
    sort(c,c+j,cmp);   //排序、比较
    for (i=1;i<j;i++)c[0]+=c[i];    //排序后最小的排序方案生成了，把所有数都合并在c[0]中
    while (c[0].length()>1)  //必须留一位数，所以>1
        if (c[0][0]==48)c[0].erase(c[0].begin(),c[0].begin()+1);   //如果第一位是'0'，舍去
        else break;  //直到不是零为止
    if (c[0][0]=='\0')cout<<"0";    //第三个点有鬼，一直没过，我猜想是第三个点没有指定单词，而如果不做这条处理的话，就无输出，WA，所以要输出0，之后就AC了
    cout<<c[0];     //输出最终结果
    return 0;                  //华丽结束.
}
```

---

## 作者：charliejiang_0w0_ (赞：0)

算不算水题呢。。

本题解用了奇葩打表方式，直接计算好每个单词对应的字符串，免去临时计算。另外输出其实可以用stringstream，就不必手动拼接字符串处理0了

找最小数字的思路则是将小数字尽量放到高位。

具体见代码。

## 另外，第三个点有毒









    






```cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <sstream>
using namespace std;
#define DICTIONARY_SIZE 27 // 词典大小
namespace P1603 { // 命名空间防止冲突
    typedef long long int64; // longlong就是int64
    string dictionary[DICTIONARY_SIZE][2] = { // 词典，预先打表计算好就不需要临时计算，注意一位数前面填零
        { "one", "01" }, 
        { "two", "04" },
        { "three", "09" },
        { "four", "16" },
        { "five", "25" },
        { "six", "36" },
        { "seven", "49" },
        { "eight", "64" },
        { "nine", "81" },
        { "ten", "00" },
        { "eleven", "21" },
        { "twelve", "44" },
        { "thirteen", "69" },
        { "fourteen", "96" },
        { "fiveteen", "25" },
        { "sixteen", "56" },
        { "seventeen", "89" },
        { "eighteen", "24" },
        { "nineteen", "61" },
        { "twenty", "00" },
        { "a", "01" },
        { "another", "01" },
        { "first", "01" },
        { "both", "04" },
        { "second", "02" },
        { "third", "09" },
        { "zero", "00" } // 其实题目的词典没有zero，但是。。。sample里面有个zero就加上
    };
    vector<string> nums; // 读入的数字
    int64 result = INT64_MAX; // 结果，默认最大
    int n; // 数词数量
    char myToLower(const char& ch) { // 其实数据很弱不需要大小写转换，这里为了保险加上。另外，这个函数是因为Linux下g++的bug，没法直接往transform里面传tolower就包装一下
        return tolower(ch);
    }
    void processWord(string word) { // 用来查词典的函数
        for (int i = 0; i < DICTIONARY_SIZE; i++) {
            if (word == dictionary[i][0]) { // 找到单词
                nums.push_back(dictionary[i][1]);
                return;
            }
        }
    }
}
using namespace P1603;
int main() {
    string str;
    getline(cin, str); // 输入句子
    transform(str.begin(), str.end(), str.begin(), myToLower); // 大小写转换
    for (int i = 0; i < 6; i++) { // 用空格隔开，每循环一次就删一次单词，这样每次循环的开始字符串都是以新单词开头
        int spaceOffset = str.find_first_of(' ');
        processWord(str.substr(0, spaceOffset));
        str = str.substr(spaceOffset + 1); // 删掉已经处理过的单词
    }
    n = nums.size();
    if (n == 0) { // 第三个点有毒
        cout << 0 << endl;
        return 0;
    }
    sort(nums.begin(), nums.end()); // 直接默认升序排列就好，这里的思路是让高位都是小数字，达到最低排列的目的
    stringstream stream; // 这里用了字符流，非常简便
    for (int i = 0; i < n; i++) {
        stream << nums[i];
    }
    stream >> result; // 输出到longlong里面
    cout << result << endl;
    return 0;
}
```

---


# 象棋比赛

## 题目描述

有 $N$ 个人要参加国际象棋比赛，该比赛要进行 $K$ 场对弈。每个人最多参加两场对弈，最少参加零场对弈。每个人都有一个与其他人不相同的等级（用一个正整数来表示）。

在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子。为增加比赛的可观度，观众希望 $K$ 场对弈中双方的等级差的总和最小。

比如有 $7$ 个选手，他们的等级分别是 $30,17,26,41,19,38,18$，要进行 $3$ 场比赛。最好的安排是选手 $2$ 对选手 $7$，选手 $7$ 对选手 $5$，选手 $6$ 对选手 $4$。此时等级差的总和等于 $(18-17)+(19-18)+(41-38)=5$ 达到最小。

## 说明/提示

### 数据范围及约定

- 在 $90\%$ 的数据中，$1 \le N \le 3000$；
- 在 $100\%$ 的数据中，$1 \le N \le 100000$。

保证所有输入数据中等级的值小于 $10^9$，$1 \le K \le N-1$。

## 样例 #1

### 输入

```
7 3
30
17
26
41
19
38
18```

### 输出

```
5```

# 题解

## 作者：_LanFeng_ (赞：51)

这道题题解有点少，还没有C++的（C应该也可以看懂），所以我来发布一篇

核心思路：现将各等级选手进行从小到大的排列，然后假设每人都会进行比赛，算出每相邻两人的差（这里不用再算不相邻的差了，因为要使和最小，离得最近的两数才满足。比如：1 2 3，2-1=1,3-1=2），再将差进行从小到大的排序  ，然后输出前K个数的和。

代码如下（头文件不用这么多，只用stdio和algorithm就可以了）：

```cpp
#include<iostream> 
#include<cstdio> 
#include<cmath> 
#include<algorithm> 
#include<cstring>
using namespace std; 
int main()
{
    int n,k,i,a[100001],b[100001],ans=0;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    sort(a+1,a+n+1);//sort从小到大排序 
    for(i=1;i<=n-1;i++)
    b[i]=a[i+1]-a[i];//算出各等级选手的差 
    sort(b+1,b+n);//sort从小到大排序 
    for(i=1;i<=k;i++)
    ans+=b[i];//找出前K个等级差的和 
    printf("%d",ans);//输出 
    return 0;
}
```

---

## 作者：Pengsibo (赞：28)

题目不难，可用多种方法过

首先分析思路：先将各位选手的等级排序，这样一来相邻选手的等级差才是最小的，这个差值才有可能被记入答案。

这么做的同时，因为只和相邻选手比较，所以每一个选手最多比较2次，就不用专门记录持黑子还是白字

这样一来，我们便把差值记录下来，再排一个序，最终的答案便是最小的前k个差值之和

##### 那么接下来的问题就是排序

我们看到数据，有90%的3000（也就是$n^2$) 和100%的100000（nlogn)

那我就介绍几种常用的排序方式（没写的方式有些是不会，还有的是真的懒）

#### 一、先来看看$N^2$ （本题只有90分）

##### 1.冒泡排序

冒泡思路很简单，每次比较相邻两元素，较小的放在前面

这样一来，每正着扫一次都会把最大的数放到最后（如果是倒着扫就是把最小的放在最前）

一共要放n个数，而扫一遍要扫n个数（优化了以后为(n - 扫的次数))，故复杂度为$n^2$

```
int x[100002];
for(register int i=1;i<n;i++)	//register 是玄学优化
{
	for(register int j=i+1;j<=n;j++)	//正着扫
	{
		if(x[i]>x[j]) swap(x[i],s[j]);	//交换，也可以写成 int t=x[i];x[i]=x[j],x[j]=t; 
	}
}
```

##### 2.选择排序

选择排序思路与冒泡类似，只不过每一次扫过一遍都会记录当前序列最小的值，扫完之后将当前序列的第一个数与其交换。

这样保证每扫一次都能把最小的数放到前面，又因为要放n个数，故复杂度也是$n^2$

```
int x[100002],minn,flag;
for(register int i=1;i<n;i++)
{
	minn=INF;	//每次都要赋极大值 
	for(register int j=i+1;j<=n;j++)
	{
		if(minn<x[j]) minn=x[j],flag=j;	//记录最小值及其下标 
	}
	swap(x[i],x[flag]);
}
```
#### 二、NlogN

##### 1.快速排序

emmm...我知道有STL（~~而且我就是这么做的~~）

```
#include <algorithm>

sort(x+1,x+n+1);
sort(y+1,y+n);
```
还是手写一下吧

思路：二分法，找到中间点，然后在左边找第一个比中间值小的，右边找第一个比中间点大的，将他们交换

具体解释~~因本蒟蒻语文不好解释不清~~可以专门去查一下

```
void qsort(int l,int r)
{
    int i=l,j=r；
	int mid=a[(l+r)>>1],t;
	
    while(1)
	{
        while (mid>a[i])i++;
        while (mid<a[j])j--;	//寻找
        if (i<=j)
		{
            swap(a[i],a[j]);	//交换
            i++;j--;
        }
        if (i>j) break;
    }
    if (j>l) qsort(l,j);
    if (i<r) qsort(i,r);	//递归
}
```
##### 2.归并排序

其实归并相对于快排要优秀一些

1.时间稳定（快排的复杂度下限nlogn，上限$n^2$，很容易被卡，而归并固定nlogn)

2.排序稳定（快排不稳定哦）（稳定指同样大小的数排序完之后是否按读入的先后顺序输出）

3.理解简单（可能就我这么想)

归并思路：分治，将原串拆半，然后将这两半排序（递归），再开一个临时数组，依次将两个数组的最小值加入这个临时数组，最后复制回原数组

```
void msort(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1;
    
    msort(l,mid),msort(mid+1,r);	//递归 
    int left=l,right=mid+1,cnt=l;
    
    while(left<=mid&&right<=r)	//边界
    {
    	if(a[left]<=a[right]) b[cnt++]=a[left++];
    	else b[cnt++]=a[right++];	//取左右两半的最小值
	}
	
    while(left<=mid) b[cnt++]=a[left++];
    while(right<=r) b[cnt++]=a[right++];	//如果有剩下没加入临时数组的元素则按顺序加入
    
    for(int i=l;i<=r;i++) a[i]=b[i];	//粘回a数组
    
    return;
}
```
##### 3.堆排序（优先队列）

首先，因为本蒟蒻太蒟了，不会手写堆（ORZ那些会的大佬们）

所以，需要借助我们的好朋友STL（~~明明才说了不用的~~）

```
#include <queue>

priority_queue<int,vector<int> > q;	//默认最小的数在最前面
```
把整个串读入队列，然后再复制一遍，因为优先队列默认最小元素在前，所以相当于排序了

这个方法也是nlogn的

#### 三、N

一看，排序的复杂度才N？什么情况，要讲桶排吗？

YES，就是要讲桶排（也叫作基数排序）

桶排思路：读入一个数a，下标为a的数组+1，表示这串数里面多了一个a

显然，这种方法很快，但是耗空间（最大空间为这串数中的最大值）

而这道题1e8，所以桶排不考虑（~~搞笑的吗不考虑还讲~~）

```
int maxx=-1;

for(register int i=1;i<=n;i++)
{
	scanf("%d",&a);
   x[a]++;
   maxx=max(maxx,a);	//这串数的最大值
}
                              
for(register int i=1;i<=maxx;i++)
{
	while(x[i]) printf("%d ",i),x[i]--;	//有则输出，无则继续
}
```

排序分析到此为止（累）

最后贴一波AC代码

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,k;
int x[100002];
int y[100002];
int ans=0;

int main()
{
	scanf("%d%d",&n,&k);
	
	for(register int i=1;i<=n;i++) scanf("%d",&x[i]);
	sort(x+1,x+n+1);
	
	for(register int i=2;i<=n;i++) y[i-1]=x[i]-x[i-1];
	sort(y+1,y+n);		//STL万岁万岁万万岁
	
	for(register int i=1;i<=k;i++) ans+=y[i];
	
	printf("%d",ans);
	return 0;
}
```

如果蒟蒻出了锅，欢饮大佬指出

写题解不易，望资瓷！

---

## 作者：我太强了 (赞：10)

#### 没有c++版归并排序的题解，那我就发一个好了
这是一道排序题，题意很容易理解，思路也好想：

先把选手等级排序，再把算出来的等级差排序，答案就是最小的k个等级差之和

虽然快排写起来容易（一个sort完事），时间复杂度也低（通常为O(logn)），但不稳定。硬核选手就用归并排序，稳定、时间复杂度仅有O（logn)、并且也并不难写

因为归并排序，至少需要两个数组a和b就好了。我的代码里的数组cha其实可以去掉，因为在第一遍归并排序之后数组b已经没有用处，可以把cha数组的赋值改成对b数组的赋值

下面是AC代码

```cpp
#include<cstdio>
int n,k,ans;
int a[100005],b[100005],cha[100005];
void msort(int l,int r)
{
	if(l==r) return;//只有一个元素则不必拆分
	int mid=(l+r)/2;
	msort(l,mid); msort(mid+1,r);//递归拆分元素
	int left=l,right=mid+1,cnt=l;
	while(left<=mid&&right<=r)//从两边找最小值，插入b数组
	if(a[left]<=a[right]) 
    b[cnt++]=a[left++];
	else b[cnt++]=a[right++];
	while(left<=mid) b[cnt++]=a[left++];
	while(right<=r) b[cnt++]=a[right++];
	for(int i=l;i<=r;i++) a[i]=b[i];//赋值回a数组
	return;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	msort(1,n);//归并排序 
	for(int i=1;i<=n-1;i++) cha[i]=a[i+1]-a[i];//求出相邻选手等级差 
	for(int i=1;i<=n-1;i++) a[i]=cha[i];
	msort(1,n-1);//再来一遍归并排序，找最小差值 
	for(int i=1;i<=k;i++) ans+=a[i];//计算答案
    printf("%d\n",ans);
	return 0;
 } 
```
~~这次蒟蒻的题解能过吗qwq~~

---

## 作者：jesses (赞：3)

这道题其实思路清晰之后很简单的啦
题目中说要找出最小的等级差的和，这里我们就将所有的等级差找出来再根据题中要几组数据来求和就可以了。而我们知道两个相近的数的差值最小，所以我们将等级排序之后让再按照顺序求出两两之差就能找到最小的等级差了。
```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>//因为我们要排序，所以有了这个头文件
using namespace std;
int lavel[200100];//这个数组用来存每个象棋选手的等级
int ans[200100];//这个数组用来存等级差
int main()
{
	int n=0,k=0;
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&lavel[i]);//这里我们把选手的等级存到lavel中
	}
	sort(lavel+1,lavel+n+1);//对lavel排序
	for(int i=1;i<n;i++)
	{
		ans[i]=lavel[i+1]-lavel[i];//我们将排序之后的数组依此求差值
	}
	sort(ans+1,ans+n);//对我们求得的差值排序
	int t=0;
	for(int i=1;i<=k;i++)
	{
		t=t+ans[i];//根据输入的k来确定有几场比赛，然后我们输出差值和
	}
	printf("%d",t);//得到答案
	return 0;
}
```
其实思路清楚后还是很简单的呀。

---

## 作者：zhangzhaoke (赞：3)

题解有些少，我来发一篇

不多说，上代码

```cpp
#include<iostream> //头文件，cin和cout需要（除cstdio包含外）
#include<algorithm> //sort头文件
using namespace std; 
int c,d,a[666666],b[666666],answer;//定义，定义在main函数外可有效防止忘设为0导致的错误
int main(){
    cin>>c>>d;//输入，注意cin不输入空格，且稍慢与scanf
    for(int i=0;i<c;i++)cin>>a[i];//循环输入，不能只读数组名
    sort(a,a+c);//sort排序，c++很有用的一个算法
    for(int i=0;i<c-1;i++)b[i]=a[i+1]-a[i];//核心算法，算出等级差
    sort(b,b+c-1);//对等级差进行排序
    for(int i=0;i<d;i++)ans+=b[i];//找出最小等级差
    cout<<answer;//输出答案
    return 0;
}
```



---

## 作者：似水年华 (赞：3)

##题目分析与算法

先按照等级排序，然后可以发现比赛的两个人，肯定是当前顺序下相邻的两个人。知道了这个，就只要选出相邻两个的差值前K小的累加起来即可。

##代码如下

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
using namespace std;
int n,k,a[100010],b[100010],i,sum;
int main()
{
    scanf("%d %d",&n,&k);
    for(i=1;i<=n;i++)
                     scanf("%d",&a[i]);\\按题目读入数据
    sort(a+1,a+(n+1));\\按照等级排序
    for(i=1;i<=n-1;i++)
                     b[i]=a[i+1]-a[i];\\计算差值
    sort(b+1,b+n);\\按照差值排序
    for(i=1;i<=k;i++)
                     sum+=b[i];\\将差值前K小的累加
    printf("%d",sum);\\输出结果
}
```

---

## 作者：Aiopr_2378 (赞：2)

# 思路
1. 先把所有人的等级从小到大排序（sort 一遍，为下一步）
1. 算出相邻的两项的差
1. 查找
### 我们得用结构体(struct)进行表示

参考代码
```cpp
#include<bits/stdc++.h>\\万能头
using namespace std;
struct node{\\定义结构体
	int x,high,lowe;
};
bool cmp(node a,node b){\\定义排序
	return a.x<b.x;
}
node a[100005];
node cha[100005];
int main(){
	memset(a,0,sizeof(a));
	memset(cha,0,sizeof(cha));\\“memset”是重置（初始化）指令
	long long s=0;
	int n,k;
	cin>>n>>k;
	for(int i=0;i<n;i++){
		cin>>a[i].x;
	}
	sort(a,a+n,cmp);
	for(int i=0;i<n-1;i++){
		cha[i].x=a[i+1].x-a[i].x;
		cha[i].lowe=i;
	}
	sort(cha,cha+n-1,cmp);
	int kk,temp=0;
	for(int i=0;i<k;i++){
		kk=1;
		while(kk){
			if(a[cha[temp].lowe+1].high==0&&a[cha[temp].lowe].lowe==0){
				kk=0;
				a[cha[temp].lowe+1].high=1;
				a[cha[temp].lowe].lowe=1;
				s+=cha[temp].x;
			}
			temp++;
		}
	}
	cout<<s;
	return 0;\\好习惯
}
```



---

## 作者：皮卡丘最萌 (赞：0)

这题是一个比较好的贪心的题目。

其实只要认真读题，并且能想到要对等级进行排序的话（因为要使等级差的总和最小，肯定是选等级相邻的2个人进行比赛，这里用到了贪心，这点应该很好理解），这题你就完成了一大半（其实K的范围也能提示我们要贪心）。

对于样例：

7 3

30
17
26
41
19
38
18

我们对其进行排序：

17 18 19 26 30 38 41

接下来求相邻2个数的差：

1 1 7 4 8 3

再进行排序：

1 1 3 4 7 8

这样我们就可以对前k个数求和，最后输出。

附代码：
```pascal
var n,m,i,sum:longint;
  a:array[0..500001] of longint;
procedure sort(l,r:longint);
var
  i,j,x,y:longint;
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
    while a[i]<x do
      inc(i);
    while x<a[j] do
      dec(j);
    if not(i>j) then
    begin
      y:=a[i];
      a[i]:=a[j];
      a[j]:=y;
      inc(i);
      j:=j-1;
    end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;                           //快排不解释

begin
  readln(n,m);
  for i:=1 to n do readln(a[i]);   //读入数据
  sort(1,n);                       //对等级值进行排序
  for i:=n downto 2 do 
    a[i]:=a[i]-a[i-1];             
      //求出相邻两个数的差，这里注意A[i]变成了a[i]与a[i-1]的差，所以i的值只到2.
  sort(2,n);                       //对等级值的差进行排序
  for i:=2 to m+1 do 
    inc(sum,a[i]);            //进行累加，注意这里也从2开始
  writeln(sum);                  
end.
```


---

## 作者：lych (赞：0)

只是一道非常容易的基础题，程序思路如下：

首先，对所有读入的数据进行排序（为了防卡快排，用了归并排序，归并的思路见程序），之后，会发现对弈的两个人也就是排序后相邻的两个人。因此，我们开一个数组用来表示相邻两个人的等级差，再对这一个数组按从小到大进行排序，再取前k组进行累加，即可得到答案。

这个算法同时也保证了题目中的“在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子”的要求，即每个数仅使用于一次。

具体程序如下：

```cpp
type
  arr=array[0..200000] of longint;
var
  t,s,c:arr;
  ans,i,n,k:longint;
{procedure qsort(r,l:longint;var a:arr);
var i,j,mid,t:longint;
begin
  i:=r;
  j:=l;
  mid:=a[(i+j) shr 1];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
      begin
        t:=a[i];
        a[i]:=a[j];
        a[j]:=t;
        inc(i);
        dec(j);
      end;
  until i>j;
  if i<l then qsort(i,l,a);
  if r<j then qsort(r,j,a);
end;}//快排，本题未选用。
procedure msort(r,l:longint;var a:arr);
var
  i,j,k,mid:longint;
begin
  if r>=l then exit;//如果只有1个元素了，就不必排序了
  mid:=(r+l) shr 1;//二分
  msort(r,mid,a);
  msort(mid+1,l,a);//递归，直到使a[r..mid],a[mid+1..l]成为有序数组
  i:=r;
  j:=mid+1;
  k:=i;
  while (i<=mid) and (j<=l) do
    begin
      if a[i]<a[j] then
        begin//如果a[i]<a[j]，则将a[i]接入数组，反之将a[j]接入数组
          c[k]:=a[i];
          inc(k);//c数组下标加1
          inc(i);//因为接入的是a[i]，所以i+1,反之j+1
        end else
        begin
          c[k]:=a[j];
          inc(k);
          inc(j);
        end;
    end;
  while i<=mid do
    begin
      c[k]:=a[i];
      inc(k);
      inc(i);
    end;//将前半部分的数据接进来
  while j<=l do
    begin
      c[k]:=a[j];
      inc(k);
      inc(j);
    end;//将后半部分的数据接进来
  for k:=r to l do a[k]:=c[k];//赋值到原来的数组中；使得a[r..l]成为有序序列
end;
begin
  read(n,k);
  for i:=1 to n do read(t[i]);
  msort(1,n,t);//归并排序
  for i:=1 to n-1 do s[i]:=t[i+1]-t[i];
  msort(1,n-1,s);
  for i:=1 to k do inc(ans,s[i]);
  writeln(ans);
end.
//注：归并排序的算法时间复杂度为地地道道的O（nlogn），而快排被卡的时候为O(N^2)，所以选用归并。
```

---

## 作者：ViXpop (赞：0)

**考试做的一道~~水题~~**

难道遇到自己会做的水题，发个题解纪念一下

看了看其他神仙的代码，才发现自己想多了

但是其他题解里好像没有我这种思路，那就发一个吧

### 请各位神仙勿喷

很显然，既然要求最小差值，首先就是想到要排序

那么就排序吧

但是作为垃圾的蒟蒻，我看到这样一行字

```
在对弈中，等级高的人必须用黑色的棋子，
等级低的人必须用白色的棋子。每个人最多
只能用一次黑色的棋子和一次白色的棋子。
```
看完这个，蒟蒻心想，这不就是每个人只能跟自己等级高或等级低的人各下一场棋吗，flag标记一下就好了

于是本蒟蒻就开始了flag标记的路

### 下面是蒟蒻丑陋的代码

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N=100001;
int n,k,a[N],flag[N],ans;
struct node
{
    int num,id1,id2;//id1 等级高  id2 等级低
}q[N];
bool cmp(node k,node l)
{
    return k.num<l.num;
}
int main()
{
    cin>>n>>k;
    for(register int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1);
    for(register int i=2;i<=n;i++)
    {
        q[i-1].num=a[i]-a[i-1];
        q[i-1].id1=i;
        q[i-1].id2=i-1;
    }
    sort(q+1,q+n,cmp);
    for(register int i=1;i<=k;i++)
    {
        for(register int j=1;j<n;j++)
        {
            int l=q[j].id1,r=q[j].id2;
            if(flag[l]>=2||flag[r]==1||flag[r]==3)continue;
            flag[l]+=2,flag[r]++;
            ans+=q[j].num;
            break;
        }
    }
    cout<<ans;
    return 0;
}

```

## 但是！！！

蒟蒻AC之后才发现，将差值排序之后，一个人最多本身就只会用两次（即和前一个人以及和后一个人对弈）

也就是说

## 不用标记啊啊啊啊啊啊！！！

好吧下面是不标记的代码（来自这位[神仙]友情赞助(https://www.luogu.org/space/show?uid=122988))

```
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

const int N=100004;
int n,k;
int a[N],b[N];
int main(){
    scanf("%d%d",&n,&k);
    for(register int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+1+n);
    for(register int i=1;i<=n-1;i++){
        b[i]=a[i+1]-a[i];
    }
    sort(b+1,b+n);
    int ans=0;
    for(register int i=1;i<=k;i++){
        ans+=b[i];
    }
    printf("%d",ans);
    return 0;
}

```

求管理员通过QWQ

---

## 作者：wawcac (赞：0)

我的思路和楼下的一样，排序后，由于每个选手最多用一次黑棋一次白棋，即最多分别和一个比他优秀的选手、一个比他水的选手下棋，这样就意味着最小的差值产生在他和他的两位“邻居”身上，于是我们可以先将等级排一次序，算出所有相邻选手的n-1（即w）个差值，在将差值排序，取前k个求和即可。作为一个纯C党，手敲优先队列是必须的>\_<


```cpp
#include<stdio.h>
int n,k,cha[100010]={0};//
int dui[100010]={0},size=1;//大根堆舍去第0个
void jh(int & x,int & y)//交换两数，似乎没多少人在参数列表里加&，反而用麻烦的指针
{
    int t=x;
    x=y;
    y=t;
}
void ru(int x)//将x入堆
{
    dui[size++]=x;
    int dq=size-1,fu=dq/2;
    while(dui[dq]>dui[fu]&&fu)
    {
        jh(dui[dq],dui[fu]);
        dq=fu;fu=dq/2;
    }
}
void pop()//弹出堆顶
{
    size--;
    dui[1]=dui[size];
    dui[size]=0;
    int er=2,dq=1;
    while(er<size)
    {
        if(dui[er+1]>dui[er]&&er+1<size) er++;
        if(dui[er]<=dui[dq]) break;
        jh(dui[er],dui[dq]);
        dq=er;er=dq*2;
    }
}
int main()
{
    int x,sum=0,w=0;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&x);
        ru(x);
    }x=dui[1];pop();
    for(int i=1;i<n;i++)
    {
        cha[w++]=x-dui[1];
        x=dui[1];
        pop();}//在对选手等级排序时顺便求出了差值
    for(int i=0;i<w;i++)
    {
        ru(cha[i]);
    }
    for(int i=1;i<n;i++)
    {
        cha[w-1]=dui[1];
        pop();w--;}//对差值进行排序
    for(int i=0;i<k;i++)
        sum+=cha[i];//累加
    printf("%d",sum);//输出
    return 0;
}

```

---


# 烦恼的高考志愿

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。


## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。


## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。


## 样例 #1

### 输入

```
4 3
513 598 567 689
500 600 550
```

### 输出

```
32```

# 题解

## 作者：06ray (赞：312)

这道题我AC的算法是二分（许多大佬用优先队列然而蒟蒻不会。。。）。

这道题如果使用二分思路会很简单。首先，将每个学校的录取分数线从大到小排序。接着开始二分查找，查找什么呢？我们应该查找每个学校录取分数线中最后一个小于等于每个同学分数的数，可以用一个while循环来模拟二分查找。

二分查找部分的思路如下所示：

首先定义两个变量，为l,r，分别为查找范围的左边界和右边界。接着while循环，首先判断while循环的条件是l<r,接着在循环里定义一个叫mid的变量，mid=(l+r)/2;然后判断：如果a[mid]，即录取分数线数组中的第mid个元素小于或等于那位同学的分数，mid+1赋值给l，否则，mid赋值给r。

最后查找完后，那么求录取分数线数组中的第l-1个元素和录取分数线数组中的第l个元素他们两与那位同学的估分的绝对值，那么答案就累加两个绝对值中最小的。

最后输出解即可。

复杂度为O(m*log(n));

下面献上代码(c++)

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>//头文件
using namespace std;//名字空间
int a[100100],b[100100];//定义两个数组，分别储存每个学校的分数线，和每个同学的估分
int main()//主函数
{
	int n,m;//定义n,m
	cin>>n>>m;//输入
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];//输入
	}
	for(int i=1; i<=m; i++)
	{
		cin>>b[i];//还是输入
	}
	sort(a+1,a+n+1);//把每个学校的分数线从小到大排序
	int ans=0;//答案一开始为0，因为要累加和。
	for(int i=1; i<=m; i++)
	{
		int l=0,r=n+1;//定义左边界与右边界
		while(l<r)
		{
			int mid=(l+r)/2;//取查找范围的中间值
			if(a[mid]<=b[i])//如果录取分数线数组中的第mid个元素小于或等于那位同学的分数
			{
				l=mid+1;//左边界就往右移
			}
			else
			{
				r=mid;//右边界就往左移
			}
		}
		if(b[i]<=a[1])//这里需要特判断一下，不然只能得70分
		{
			ans+=a[1]-b[i];
		}
		else
		{
			ans+=min(abs(a[l-1]-b[i]),abs(a[l]-b[i]));//加上两个绝对值中最小
		}
	}
	cout<<ans;//输出ans
	return 0;//结束程序
}
```




---

## 作者：子谦。 (赞：88)

# 感谢 @安笙凉城 的提醒，优先队列的确忘记加空格了


# 为贪心正名，看了看好像没有贪心的，就来个贪心吧

首先，作为贪心，读完题后，应该知道需要排序，可以缩短需要的时间

然后，分别找到与每个学生预估分数的差的绝对值最小的学校，顺着推就可以

还没有思路的话，就来看下面的代码吧

# 方法一：STL优先队列（当然本人水平有限，也只是学生优先队列，剩下学校还是手写）

```cpp
#include<algorithm>
#include<iostream>
#include<cmath>//使用abs绝对值函数 
#include<queue>//使用优先队列 
using namespace std;
#define re register//register加速程序运行速度，不懂百度，我也解释不大了，不懂勿用 
const int maxn=100001;
priority_queue<int,vector<int>,greater<int> >a;//优先队列，学生成绩 
int main(){
    int b[maxn],m,n,k=1,sum=0;//b是学校录取线，sum是不满意度，k是目前走到的学校 
    cin>>m>>n;
    for(re int i=1;i<=m;i++)cin>>b[i];
    for(re int i=1;i<=n;i++){
        re int x;
        cin>>x;
        a.push(x);
    }
    sort(b+1,b+m+1);//把学校的录取线从小到大排序 
    for(re int i=1;i<=n;i++){//n个学生，从小到大 
        re int x=a.top(),p=abs(x-b[k]);//x为此学生分数，p存的是选取k学校的不满意值 
        a.pop();//弹出 
        while(abs(x-b[k+1])<=p){//如果下一个学校更小，选下一个（注意：一定是小于等于，不明白私信我） 
            k++;
            p=abs(x-b[k]);
        }
        sum+=p;//加上这个学生的不满意值 
    }
    cout<<sum;
    return 0;
}
```
方法一的方法虽然看起来很厉害，但是时间稍微有点慢，那就需要方法二了——纯手写队列

# 方法二：手写队列（跟上面的差不太多，大家看上面的注释吧，不懂可以私信我）

```cpp
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
#define re register
const int maxn=100001;
long long a[maxn],b[maxn];
int main(){
    re long long m,n,k=1,sum=0;
    cin>>m>>n;
    for(re int i=1;i<=m;i++)cin>>b[i];
    for(re int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    for(re int i=1;i<=n;i++){
        re long long p=abs(a[i]-b[k]);
        while(abs(a[i]-b[k+1])<=p){
            k++;
            p=abs(a[i]-b[k]);
        }
        sum+=p;
    }
    cout<<sum;
    return 0;
}
```
好了，就是这样了，感谢大家的阅览

# 不喜勿喷，请勿抄袭

~~拜~~


---

## 作者：Viston (赞：87)

居然没有用我们万恶的$lower$_$bound$的，害的我前面还不知道自己哪错了  
## lower_bound属于C++内置STL的一种，可以实现在有序数组下进行二分查找，它可以用来找到第一个大于等于待查元素的值的位置。   

### 函数用法
```
int c=lower_bound(开始查询的位置【闭区间】，结束查询的位置【开区间】，查询的数)-数组指针;

```
可以返回查询到的数的数组下标。  
那如果没有大于等于待查元素的值怎么办？  
函数会输出结束查询的位置，应为他并没有找到。

于是我们就可以用lower_bound愉快的来写这道题了。  

类似的还有upper_bound，可以找到第一个小于等于待查元素的值。
```
#include<bits/stdc++.h>
using namespace std;
int a,b,c[100002],d,e,f,g,h,i,j,k,l;
long long ans;
int main()
{
    cin>>a>>b;
    for(i=1;i<=a;i++)
        cin>>c[i];
    sort(c+1,c+a+1);//先排序一下
    for(i=1;i<=b;i++)
    {
        cin>>d;
        e=lower_bound(c+1,c+a+1,d)-c;//返回查询到的位置
        if(e==a+1)
        ans+=d-c[a];//特判比所有数都大的情况
        else
            if(e==1)//特判比所有数都小的情况
                ans+=c[1]-d;
            else
                ans+=min(abs(c[e]-d),abs(d-c[e-1]));
    }
    return 0;
}
```

---

## 作者：sy_zmq_001 (赞：58)

##### 前言：
看了各路大神的二分，我表示。。。我实在是没想到二分，就自己歪歪了个只需要排个序的算法。
##### 分析:
根据n位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差的值的和最小，也就是要给每一个学生找一个和他分数最接近的学校，然后求和。
##### 思路如下：
1.把学生和学校的分数混在一起，从大到小排序，标记哪些是学生的分数哪些是学校的分数。

2.从头开始找，如果遇上哪个分数是学生的，就分别找到他前面和后面的一所学校，看看哪个差值最小加上哪个。
##### 几个需要注意的点：
1.如果这个学生是排列中的第一个，只能往后取值。如果这个学生是排列中的最后一个，只能往前取值。

2.即使这个学生不是第一个，也有可能它前面都是学生而没有学校，这样他往前找的第一个和他不是同一类型的点为0,一个无意义点，此时需要特判。即使这个学生不是最后一个，也有可能它后面都是学生而没有学校，这样他往后找的第一个和他不是同一类型的点为n+m+1,一个无意义点，此时需要特判。（其实1.中情况完全可以归到这里，不过我懒得改了（逃~

##### 代码：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct llo{
	int val,used;
}a[200003];
int n,m;
long long ans;
bool cmp(llo x,llo y){
	return x.val<y.val;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	
		scanf("%d",&a[i].val);
	for(int i=n+1;i<=n+m;i++){
		scanf("%d",&a[i].val);
		a[i].used=1;
	}
	sort(a+1,a+n+m+1,cmp);
	for(int i=1;i<=n+m;i++){
		if(a[i].used==1){
			int qian=i-1,hou=i+1;
			if(i!=1)
				while(a[qian].used!=0)
					qian--;
			if(i!=n+m)
				while(a[hou].used!=0)
					hou++;
			if(i==1||qian==0)	ans=ans+a[hou].val-a[i].val;
			else if(i==n+m||hou==n+m+1)	ans=ans+a[i].val-a[qian].val;
			else ans=ans+min(a[i].val-a[qian].val,a[hou].val-a[i].val);
		}
		
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：itandsoon (赞：57)

这几天在看二分，于是决定总结一下水我的第一篇题解

做了进击的奶牛这种启发题以后，发现二分法在求解最优解的问题上也有足够明显的优势，对于这道题也不例外

如果仅仅是套循环的话显然在数据比较大的情况下是不够优化 的，所以我们可以先把得到的分数线排序再二分操作。

这道题二分的原理很简单，因为我们求的是某一个学生和某一个分数线最小的差的绝对值，**当我们采用二分的时候，就会很快逼近我们要找的那个分数线，并且在其附近波动**，只需要**无脑记录在波动过程中出现过的最小的差的绝对值**，就可以找到题目的答案了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int line[100005];
int main()
{
	int m,n;
	cin>>m>>n;
	int t=0,k=0;
	while(t<m)
	{
		cin>>line[t];
		t++;
	}
	sort(line,line+t);//以上是读入和排序分数线
	int sum=0;
	while(k<n)
	{
		int num;
		cin>>num;
		k++;
		int L=0,R=t-1;
		int ans=1000;//最小的差的绝对值，初始化为一个比较大的值
		while(L<=R)//终止条件
		{
			int mid=(L+R)/2;//取中间值判断
			if(line[mid]==num)
			{
				ans=0;
				break;//零必然为最小的所求解，所以可直接终止二分，节约时间
			}
			else if(line[mid]<num)
			{
				ans=min(ans,abs(line[mid]-num));
				L=mid+1;//可能的更好的答案在右边，右移，记录当前最优解，继续搜索
			}
			else if(line[mid]>num)
			{
				ans=min(ans,abs(line[mid]-num));
				R=mid-1;//可能的更好的答案在左边，左移，记录当前最优解，继续搜索
			}
		}
		sum+=ans;
	}
	cout<<sum;
}
```

这样看来，线性情况下，二分的过程中最重要的记录状态，选择区间和判断是核心部分。


---

## 作者：SGOI_Aromyase (赞：29)

这题真的没那么复杂，输入优化什么的其实没必要，scanf0.11S 另外开int也可以A掉

排序以后二分就行了，其实连函数都没必要写，直接引用数组就可以A了

楼上题解其实可读性真的不高，我放一个最简单的思路

我的题解我感觉普及组都可以轻松看懂吧（笑~）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[100005],b[100005];
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    for(int i=0;i<m;i++) scanf("%d",&b[i]);
    sort(a,a+n);//排序
    int tot=0;
    for(int i=0;i<m;i++){
        int zuo=0,you=n-1,ans=0x7fffffff,now=0;
        while(zuo<=you){
            int c=(zuo+you)/2;
            if(a[c]<b[i]){
                ans=min(ans,abs(b[i]-a[c]));//找最小绝对值
                zuo=c+1;
            }
            else{
                you=c-1;
                ans=min(ans,abs(b[i]-a[c]));
            }
        }
        tot+=ans;//记录最小绝对值
    }
    printf("%d",tot);
}
```

---

## 作者：xiezihan (赞：24)

这道题如果你直接暴力就算是吸氧也只有40（实测，明摆的二分嘛）

### ~~所以，拒绝暴力，理性为主~~

好了，其他思维也没什么了，二分谁都会打，

所以，话不多说，上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000],b[100000];
int main()
{
	int s=0,y;
	int max=10000;
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int j=1;j<=m;j++)cin>>b[j];
	int left,right,mid;
	for(int i=1;i<=m;i++)
	{
		left=1;
		right=n;
		while(left<right-1)
        {
            mid=(left+right)/2;
            if(b[i]>=a[mid])
            left=mid;
            else right=mid;
        }
        if((b[i]-a[left])<abs(a[right]-b[i]))
        {
        	y=abs(b[i]-a[left]);
        }else y=abs(a[right]-b[i]);
        s+=y;
	}
	cout<<s;
    return 0;
}

```

注：此程序为健康程序，无需吸氧

---

## 作者：lian_sama (赞：13)

## 简单的三分。
模板题，不难，很多方法都能解，但三分较快。
三分是用来求凸形或凹形函数的凸点或凹点。

### 举个栗子
已知左右端点L、R，要求找到白点的位置。 

思路：通过不断缩小 [L,R] 的范围，无限逼近白点。

先取 [L,R] 的中点 mid，再取 [mid,R] 的中点 mmid，

通过比较 f(mid) 与 f(mmid) 的大小来缩小范围。
当最后 L=R-1 时，再比较下这两个点的值，我们就找到了答案。

过程有两种情况：

#### 1、当 f(mid) > f(mmid) 的时候，我们可以断定 mmid 一定在白点的右边。

#### 2、当 f(mid) < f(mmid) 的时候，我们可以断定 mid 一定在白点的左边。 

本蒟蒻的代码用的就是这种做法。

话不多说，上代码：
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
const double eps=1e-6;
int n;
double a[20],l,r,mid1,mid2,avg;
double function(double x){
	double sum=0;
	for(int i=n;i>=0;i--){
		sum=sum*x+a[i]; 
	}
	return sum;
}
int main(){
	cin>>n>>l>>r;
	for(int i=n;i>=0;i--){
		cin>>a[i];
	}
	while(r-l>=eps){
		avg=(r-l)/3;
		mid1=l+avg;
		mid2=r-avg;
		if(function(mid1)>function(mid2)){
			r=mid2;
		}
		else
		l=mid1;
	}
	printf("%.5lf\n",mid2);
	return 0;
}
```


---

## 作者：AK_黄铮_IMO (赞：12)

这题我们一看题目：最小不满足的<(￣ ﹌ ￣)@m；
思路：
```cpp
将 mm 个学校录取分数线排序，
然后对每个估分
，用lower_bound找到最近的分数
（可能大于等于也可能小于），
注意用long long保存答案。
```
不用long long WA了
这题我直接用
## STL 大法 好 好 好 好
```
下面上代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>// STL 头文件
using namespace std;
int num[100005];
int main(){
int n,m,x,d1,d2,p1,p2;
  long long ans;// 不开 long long 
  cin>>m>>n;
  for(int i=0;i<m;i++){
    cin>>num[i];
  }
  sort(num,num+m); 快排 走起
  ans=0;
  while(n--){
    cin>>x;
    p1=lower_bound(num,num+m,x)-num;// 这里我们 用了STL里面的二分算法，我没有手写，直接找最近值
    p2=p1-1;
    d1=2000000000;
    d2=2000000000;
    if(p1!=m){
        d1=num[p1]-x;
    }
    if(p2!=-1){
      d2=x-num[p2];
    }
    ans+=min(d1,d2);// 最小值
 }
   cout<<ans<<endl;
  return 0;
}// 华丽结束，撒花！

```



---

## 作者：zhanghb (赞：12)

这道题只要分别判断学生的估值在哪两个学校的录取分数线之间，然后与比学生估值高的和低的分数线分别相减取绝对值，取最小值统计即可

```
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int x,cn=0,m,a[100001],n,i,b[100001],l,r,mid;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	cin>>a[i];//输入每个学校的录取分数线
	sort(a+1,a+n+1);//快排，把所有学校录取分数线排序
	for(i=1;i<=m;i++)
	cin>>b[i];//输入每个学生的估值
	for(i=1;i<=m;i++)
	{
		l=1;r=n;
		while(l<r-1)
		{
			mid=(l+r)/2;
			if(b[i]>=a[mid])
			l=mid;
			else r=mid;
		}//二分查找，找出学生估值所在那两个学校的录取分数线之间
		x=abs(b[i]-a[l])<abs(a[r]-b[i])?abs(b[i]-a[l]):abs(a[r]-b[i]);//比与学生估值高的和低的两个学校的录取分数线进行相减取绝对值，作为该学生的不满意度
		cn+=x;//计算不满意度总和
	}
	cout<<cn;//输出
}
```


---

## 作者：Playnext (赞：11)

##### 蒟蒻我一看题目

##### 要求差值最小

##### 就想到用treap

###### ~~看下面没有treap就来发一个~~

思路是先把录取分数线插入

然后插入学生分数

求出学生分数排名

在学生分数排名-1和+1中求最小值

最后去掉这个节点

代码如下


    
        
        
        
    
    
    
    
        
            
    
            
        
        
        
        
                
        
    
```cpp
    #include <bits/stdc++.h>
    using namespace std;    //BY Playnext
    #define REG register
    #define IN inline
    #define Emmm int
    #define FOR(X,Y,Z) for (REG int X=Y; X<Z; X++)
    const int MAXN=1e5+1, NODEMAXN=5e3+1, INF=2147483647, MOD=1000000009;
    IN Emmm Read () {//读入优化
        REG Emmm Temp = 0;
        REG int Negative = 1;
        REG char Buffer = getchar();
        while (Buffer < 48 || Buffer > 57)  {
            if (Buffer == 45)     Negative = -1;
            Buffer = getchar();
        }    
        while (Buffer >= 48 && Buffer <= 57) {
            Temp = (Temp<<1) + (Temp<<3) + Buffer - 48;
            Buffer = getchar();
        }
        return Temp*= Negative;
    }
    IN void Write (REG Emmm Temp) {//输出优化
        if (Temp < 0)     Temp = -Temp, putchar (45);
        if (Temp > 9)     Write (Temp/10);
        putchar (Temp%10 + 48);
    }
    IN void Space () {
        putchar (32);
    }
    IN void Enter () {
        putchar (10);
    }
    struct Treap {
        struct Node {
            Node* Left;        Node* Right;
            int Priority, Value, Size, Repeat;
            Node (REG int Num) {
                Left = Right = NULL;
                Priority = rand (), Size = 0, Value = Num, Repeat = 1;
            }
        } *RT = NULL;
        IN void Push_Up (REG Node* Root) {
            Root -> Size = Root -> Repeat;
            if (Root -> Left != NULL) Root -> Size += Root -> Left -> Size;
            if (Root -> Right != NULL) Root -> Size += Root -> Right -> Size;
        }
        IN void Left_Rotate (REG Node* &Root) {//左旋
            REG Node* Temp = Root -> Right;
            Root -> Right = Temp -> Left;
            Temp -> Left = Root;
            Push_Up (Root), Push_Up (Temp);
            Root = Temp;
        }
        IN void Right_Rotate (REG Node* &Root) {//右旋
            REG Node* Temp = Root -> Left;
            Root -> Left = Temp -> Right;
            Temp -> Right = Root;
            Push_Up (Root), Push_Up (Temp);
            Root = Temp;
        }
        IN void Insert (REG Node* &Root, REG int Value) {
            if (Root == NULL) {//插入节点
                Root = new Node (Value);
            }
            else {
                if (Root -> Value > Value) {
                    Insert (Root -> Left, Value);
                    if (Root -> Priority < Root -> Left -> Priority)
                        Right_Rotate (Root);
                }
                else {
                    Insert (Root -> Right, Value);
                    if (Root -> Priority < Root -> Right -> Priority)
                        Left_Rotate (Root);
                }
            }    Push_Up (Root);
        } 
        IN void Delete (REG Node* &Root, REG int Value) {
            if (Root == NULL) //删除节点
                return ;
            else if (Root -> Value == Value) {
                if (Root -> Repeat > 1) {
                    Root -> Repeat --;
                }
                else {
                    if (Root -> Left == NULL && Root -> Right == NULL) {
                        Root = NULL;
                        return ;
                    }
                    else if (Root -> Left != NULL && Root -> Right != NULL) {
                        if (Root -> Left -> Priority > Root -> Right -> Priority)
                            Right_Rotate (Root),
                            Delete (Root -> Right, Value);
                        else
                            Left_Rotate (Root),
                            Delete (Root -> Left, Value);
                    }
                    else {
                        if (Root -> Left == NULL)
                            Root = Root -> Right;
                        else
                            Root = Root -> Left;
                    }
                }
            }
            else {
                if (Root -> Value > Value)
                    Delete (Root -> Left, Value);
                else
                    Delete (Root -> Right, Value);
            }    Push_Up (Root);
        }     
        IN int KTH_Find (REG Node* Root, REG int Rank) {
            if (Root == NULL)//找第k名
                return INF;
            else {
                REG int LSize = Root -> Left != NULL ? Root -> Left -> Size : 0;
                if (Rank <= LSize)
                    return KTH_Find (Root -> Left, Rank);
                else if (Rank > LSize + Root -> Repeat)
                    return KTH_Find (Root -> Right, Rank - LSize - Root -> Repeat);
                else
                    return Root -> Value;
            }
        }
        IN int Find_KTH (REG Node* Root, REG int Value) {
            if (Root == NULL)//找x排名
                return 0;
            else {
                REG int LSize = Root -> Left != NULL ? Root -> Left -> Size : 0;
                if (Root -> Value == Value)
                    return LSize +1;
                else if (Root -> Value > Value)
                    return Find_KTH (Root -> Left, Value);
                else
                    return Find_KTH (Root -> Right, Value) + LSize + Root -> Repeat;
            }
        }
    } TP;
    int main() {
    //    freopen ("Input.txt", "r", stdin);
    //    freopen ("Output.txt", "w", stdout);
        REG int m, n, Num, Count = 0, T1, T2, T3;
        m = Read ();    n = Read ();
        FOR (i,0,m) {//插入录取线
            Num = Read();    TP.Insert (TP.RT, Num);
        }
        FOR (i,0,n) {
            Num = Read();    TP.Insert (TP.RT, Num);        T3 = INF;
            T1 = TP.KTH_Find (TP.RT, TP.Find_KTH (TP.RT, Num) -1);//找名次
            T2 = TP.KTH_Find (TP.RT, TP.Find_KTH (TP.RT, Num) +1);        //去除最大最小情况
            if (T1 != INF)    T3 = min (T3, Num - T1);
            if (T2 != INF)    T3 = min (T3, T2 - Num);
            Count += T3;    TP.Delete (TP.RT, Num);
            //删除节点
        }    Write (Count), Enter ();
        return 0;
}
```

---

## 作者：圣光天子 (赞：6)

首先，我们很容易可以想到枚举每一个学生，再将其与每一个学校的录取分数线对比，取分差的最小值。这样的时间复杂度为O(nm)。而根据题目“n,m<=100,000”的数据范围，显而易见是会炸的。

接着，我们可以想到使用二分查找进行优化。所以，先将学校分数线快排一遍，然后二分查找即可。（要注意取绝对值）

代码~~（第一次发C++题解，代码有点丑）~~
```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

int n,m;
int sc[100000];
int st[100000];
int l,r,mid;
long long ans;

void qsort(int l,int r)
{
    int i,j,p,mid;
    i=l; j=r; mid=sc[(l+r)/2];
    do
    {
        while (sc[i]<mid) i++;
        while (sc[j]>mid) j--;
        if (i<=j) 
        {
            p=sc[i]; sc[i]=sc[j]; sc[j]=p;
            i++; j--;
        }
    }
    while (i<=j);
    if (l<j) qsort(l,j);
    if (i<r) qsort(i,r);
}

int main()
{
    scanf("%d%d",&m,&n);
    for (int i=1; i<=m; i++)
      scanf("%d",&sc[i]);
    for (int i=1; i<=n; i++)
      scanf("%d",&st[i]);
    qsort(1,m);
    sc[0]=-10000000;
    for (int i=1; i<=n; i++)
    {
        l=1; r=m;
        while (l<r)
        {
            mid=(l+r)/2;
            if (st[i]>sc[mid]) l=mid+1;
            else r=mid;
        }
        ans=ans+min(abs(st[i]-sc[l]),min(abs(st[i]-sc[l-1]),abs(st[i]-sc[l+1])));
    }
    printf("%d",ans);
}
```

---

## 作者：梦之__泪伤 (赞：5)

核心思想： _**二分查找**_ 

1. 首先，将每个学校的录取分数线从小到大排序。

2. 接着开始二分查找，查找什么呢？应该查找每个学校录取分数线中最后一个小于等于每个同学分数的数。

二分查找部分的思路如下所示：

首先定义两个变量，为 l, r，分别为查找范围的左边界和右边界。

接着 while 循环，首先判断 while 循环的条件是 l<r，接着在循环里定义一个叫 mid 的变量，mid=(l+r)/2;然后判断：

如果 a[mid]，即录取分数线数组中的第 mid 个元素小于或等于那位同学的分数，mid+1赋值给 l，否则，mid 赋值给 r。

最后查找完后，那么求录取分数线数组中的第 l-1 个元素和录取分数线数组中的第 l 个元素他们两与那位同学的估分的绝对值，那么答案就累加两个绝对值中最小的。

最后输出解即可，复杂度为 O(m*log(n))。

代码
```
#include <bits/stdc++.h>
using namespace std;
const int maxN = 100000 + 10;
int d[maxN], m, n;
int bfind(int), read();
void work();
int main(){
    work();
    return 0;
}
void work(){
    m = read(); n = read();
    for(int i = 0; i < m; i++) d[i] = read();
    sort(d, d + m);
    long long ans = 0;
    for(int i = 0; i < n; i++){
        int x; cin >> x;
        ans += bfind(x);
    }
    cout << ans;
}
int read()//快读
{
    int s = 0; char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    while(ch >= '0' && ch <= '9'){
        s = s * 10 + ch - '0';
        ch = getchar();
    }
    return s;
}
int bfind(int x){//二分查找
    int l = 0, r = m - 1, ans = 1e9;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(d[mid] <= x) l = mid + 1;
        else r = mid - 1;
        ans = min(ans, abs(x - d[mid]));
    }
    return ans;
}
```

---

## 作者：Phykyer (赞：4)

楼上的julao似乎并没有用splay来解题，就让我来水一发(~~虽然splay解题无比麻烦~~)  
关于splay：splay是一种神奇的平衡树，而平衡树是一种神奇(~~又臭又长~~)的算法，想学习的oilers可以去[p3369](https://www.luogu.org/problemnew/show/P3369)或者[洛谷日报](https://tiger0132.blog.luogu.org/slay-notes)学习，平衡树能够实现比较多的功能，例如：  

1.插入删除节点(~~这是废话~~)  
2.找一个节点的前驱和后继(小于该数的数中的最大数和大于该数的数中的最小数)  
3.找一个节点的排名和排名为n的节点等等。以上忽略(4~∞)  

这些都是普通平衡树的基础功能，当然也有更复杂能实现更多功能的平衡树如[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)等  

当你掌握了平衡树后，解题思路就很容易找到(~~会平衡树的又怎么会像我一样来做这种题~~)：  
先把分数线插入树中，对于每个学生找它的前驱和后继并算其后继和该数以及该数和前驱差值取最小累加即可  

以下是代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<climits>
#include<cmath>
using namespace std;

int n,m,ans=0;
int root=0,size=0;

struct Splay
{
	int son[2],fa,same_cnt,size,value;//左右儿子,值,重复数,大小,父节点
}t[100010];

bool relate(int x)//判断x是他父亲的左儿子还是右儿子
{
	return x==t[t[x].fa].son[1];
}

void connect(int x,int fa,bool which)//把x和fa建立父子关系
{
	t[x].fa=fa;
	if(fa) t[fa].son[which]=x;
}

void update(int x)//更新节点的大小
{
	t[x].size=t[t[x].son[0]].size+t[t[x].son[1]].size+t[x].same_cnt;
}

void rotate(int x)//旋转
{
	int y=t[x].fa;
	bool z=relate(x);
	connect(x,t[y].fa,relate(y));//将x变到y的位置成为其祖先的节点
	connect(t[x].son[z^1],y,z);//将x的子树连接到y上
	connect(y,x,z^1);//将y变成x的子节点
	update(y); update(x);//更新
}

void splay(int x,int goal) 
{
	for(int fa;(fa=t[x].fa)!=goal;rotate(x))//判断单旋或双旋,不做赘述,有兴趣的同学可到平衡树模板题找splay模板 
	{
		if(t[fa].fa!=goal)
		{
			rotate(relate(x)==relate(fa)?fa:x);
		}
	}
	if(!goal) root=x;
}

void insert(int x)//插入新节点 
{
	if(!root)
	{
		t[root=++size].same_cnt=1;
		t[root].size=1;
		t[root].value=x;
		return;
	}
	int now=root;
	while(1)
	{
		if(x==t[now].value)
		{
			t[now].same_cnt++;
			update(now);
			update(t[now].fa);
			splay(now,0);
			return;
		}
		int ff=now;
		bool which=t[ff].value<x;
		now=t[ff].son[which];
		if(!now)
		{
			t[now=++size].same_cnt=1;
			t[now].size=1;
			t[now].value=x;
			connect(now,ff,which);
			update(ff);
			splay(now,0);
			return;
		}
	}
}

void find(int x)//找节点并转至根 
{
	if(!root) return;
	int now=root;
	while(t[now].value!=x&&t[now].son[x>t[now].value])
	{
		now=t[now].son[x>t[now].value];
	}
	splay(now,0);
}

int precursor(int x)//找前驱 
{
	find(x);
	if(t[root].value<=x) return root;//记得这里用<=判分数线和分数相等的情况,我就是这里被卡了很久 
	int now=t[root].son[0];
	while(t[now].son[1]) now=t[now].son[1];
	return now;
}

int successor(int x)//找后继 
{
	find(x);
	if(t[root].value>=x) return root;
	int now=t[root].son[1];
	while(t[now].son[0]) now=t[now].son[0];
	return now;
}

inline int read()//读优 
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'&&ch!='-'||ch>'9'&&ch!='-') ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}

int main()
{
	insert(INT_MIN); insert(INT_MAX);
	m=read(); n=read();
	for(int i=1;i<=m;i++)//先把分数线插入树中 
	{
		int x; x=read();
		insert(x);
	}
	for(int i=1;i<=n;i++)
	{
		int x; x=read();//对于每个学生找前驱和后继并判差值绝对值的最小值累加 
		int pre=t[precursor(x)].value;
		int suc=t[successor(x)].value;
		ans+=min(abs(suc-x),abs(x-pre));
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：点击获取“V”认证 (赞：3)

实在是看不下去某些人的题解

自己写的时候写的半死，改的时候改得半死，还要别人帮忙该程序的人居然写题解了！

卧槽这不是误人子弟么？

为了防止世界被破坏，为了维护世界的和平，我决定写题解= =

（第一次没用小号。。。）

本题我的思路是二分查找，算是朴素算法了。

```delphi

var
  a,b:array[-1..100001] of int64;
ans:int64;
  i,j,n,m:longint;
procedure kp(t,w:longint);
var
  i,j,mid,p:longint;
begin
if t>=w then exit;
  mid:=a[(t+w) div 2];
  i:=t;j:=w;
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
    begin
      p:=a[i];a[i]:=a[j];a[j]:=p;
      inc(i);dec(j);
    end;
  until i>j;
kp(t,j);
kp(i,w);
end;
function min(a,b:longint):longint;
begin
if a>b then exit(b) else exit(a);
end;
procedure ef(t,w:longint);//二分查找
var
  mid:longint;
begin
  if t=w then begin ans:=ans+min(abs(a[t]-b[i]),abs(b[i]-a[t-1]));exit; end;//当t=w时，说明a[t-1]<分数<=a[t]
  mid:=(t+w)div 2;
  if a[mid]>b[i] then ef(t,mid) ;
  if a[mid]<b[i] then ef(mid+1,w);
end;
begin
  readln(m,n);
  for i:=1 to m do
    read(a[i]);
  for j:=1 to n do
    read(b[j]);
  kp(1,m);
a[0]:=-100000;//分数可能低于最低分，所以设下限
  a[m+1]:=maxlongint;//分数可能高于最高分，所以设上限
  for i:=1 to n do
  begin
    ef(1,m+1);//因为我是保证当前分数低于第二个值的，所以范围到m+1，
  end;
  writeln(ans);
end.

```

---

## 作者：野菜汤 (赞：3)

题解：

**写完之后，真是感慨万千，这ac的过程真是太艰辛了，经过整整一周（每天20分钟）的不断修改，直到最后一天才发现ac的正确途径，不得不说，我的指导老师真是把我坑惨了！**


然后说一下解题的思路吧,其实真的是很简单，先把所有数据按从大到小排个序，然后单重循环中用一个while语句找与当前的估分值较为接近的那两个值，一个是比它小的和比它大的，然后直接加上这两个差值中最小的，就可以得到答案了。


**这道题难就难在它所给的值是估分值，可比录取线高也可以比录取线低，所以就难上一分。然后它的数据点也是十分的刁钻，第九个数据点，如果你不把a[0]这个位置的数组数值开到十万，就肯定过不了。至于原因就由大家自己去研究吧。**


以下提供个人的经典标称，最标准的模拟，与墨凝所用的二分法，截然不同。

```delphi
var i,j,k,m,n,sum,min,tmp,p,q:longint;
    a,b:array[0..100001] of longint;
procedure qs1(l,r:longint);{快排}
var i,j,mid,p:longint;
begin
  i:=l;j:=r;mid:=a[(l+r) div 2];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then begin
      p:=a[i];a[i]:=a[j];a[j]:=p;inc(i);dec(j);
    end;
  until i>j;
  if l<j then qs1(l,j);
  if i<r then qs1(i,r);
end;
procedure qs2(l,r:longint);
var i,j,mid,p:longint;
begin
  i:=l;j:=r;mid:=b[(l+r) div 2];
  repeat
    while b[i]<mid do inc(i);
    while b[j]>mid do dec(j);
    if i<=j then begin
      p:=b[i];b[i]:=b[j];b[j]:=p;inc(i);dec(j);
    end;
  until i>j;
  if l<j then qs2(l,j);
  if i<r then qs2(i,r);
end;
function max(x,y:longint):longint;{选取最小的函数，名字有些奇怪，不过细节就不要在意了}
begin
  if x<y then exit(x) else exit(y);
end;
function zxx(x,y:longint):longint;{这是算差值的函数，如果直接用取绝对值的函数也可以}
begin
  if x>=y then exit(x-y) else exit(y-x);
end;
begin
  read(m,n);
  for i:=1 to m do read(a[i]);
  for i:=1 to n do read(b[i]);
  qs1(1,m);qs2(1,n);
  a[m+1]:=maxlongint;
  p:=1;{这里初始赋值为1，尔后就不必改变了，因为数据时有序的，所以只需要一次找更大的}
  for i:=1 to n do begin
   while b[i]>a[p] do inc(p);{找到与当前数据点最接近的数}
   if p=1 then q:=1 else begin {为什么要这样呢？还请读者自己研究就会明白了}
   q:=p;p:=p-1;end;{两个指标的位置的赋值（原因自己理解）}
   sum:=sum+max(zxx(b[i],a[p]),zxx(b[i],a[q]));{取最小}
  end;
  write(sum);
end.
```

---

## 作者：Mine_Nirvana (赞：2)

#### 看到了许多dalao的做法，似乎没有一个直接循环暴力的题解，本蒟蒻就来发这篇题解啦
#### 循环暴力十分好写，个人认为很适合新手来学习
##### 这道题贪心的思路很明显，但n方暴力会T，所以考虑优化就可以啦
##### 那么先上核心代码
```cpp
	sort (school + 1, school + m + 1);
	sort (student + 1, student + n + 1); //先进行排序
	int k = 2, ans = 0; //ans用来存储答案， k就是优化的核心了
	for (int i = 1; i <= n; ++i)
	{ //简单的枚举循环
		for (int j = k; j <= m; ++j) //注意这里循环要由k开始
		{
			k = j; //在这里解释k的作用，可以把k看作一个标记或者说是一个指针
            //由于考虑到两个数组都已经从小到大排列过，所以可以抽象的看作是两组数数轴上的点
			if (abs (school[j] - student[i]) > abs (school[j-1] - student[i]))
            //这里的判断是重点，既然可以看作数轴上的点，abs可以看作两个点的距离
            //循环所代表的意思就是枚举两个数组中点的距离
            //那么，考虑我们是从小到大枚举，如果说点i到点j的距离已经大于点i到点j-1的距离
            //下一步的枚举点j+1很明显大于点j <=>等价于点j+1的距离更远，所以可以跳出，并下次枚举由此点开始
			{
				student[i] = abs (school[j-1] - student[i]);
				break;
			}
			if (k == m)
				student[i] = abs (school[m] - student[i]);
		}
//		cout << student[i] << endl;
		ans += student[i];
	}
```
由此，复杂度看O(n2）实际上并不到，完美的解决了这个问题啦

蒟蒻的解释不够简练，还请各位大佬谅解

接下来上AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

static const int N = 1e5 + 10;
long long n, m, school[N], student[N];

int main ()
{
	scanf ("%lld%lld", &m, &n);
	for (int i = 1; i <= m; ++i)
		scanf ("%lld", &school[i]);
	for (int i = 1; i <= n; ++i)
		scanf ("%lld", &student[i]);
	sort (school + 1, school + m + 1);
	sort (student + 1, student + n + 1);
	int k = 2, ans = 0;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = k; j <= m; ++j)
		{
			k = j;
			if (abs (school[j] - student[i]) > abs (school[j-1] - student[i]))
			{
				student[i] = abs (school[j-1] - student[i]);
				break;
			}
			if (k == m)
				student[i] = abs (school[m] - student[i]);
		}
//		cout << student[i] << endl;
		ans += student[i];
	}
	printf ("%lld", ans);
	return 0;
}
```

---

## 作者：墨凝而止 (赞：2)

```delphi
var
a:array[0..100000]of longint;{存放学校录取成绩｝
b,c,i,j,k,l,m,n,sum,mid,r:longint;
procedure qs(l,r:longint);｛快排｝
var i,j,mid,p:longint;
begin
  i:=l;j:=r;
  mid:=a[(l+r)div 2];
  repeat
  while a[i]<mid do inc(i);
  while a[j]>mid do dec(j);
  if i<=j then
  begin
    p:=a[i];a[i]:=a[j];a[j]:=p;inc(i);dec(j);
  end;
  until i>j;
  if i<r then qs(i,r);
  if l<j then qs(l,j);
end;
function min(k,l:longint):longint;｛找最小值｝
begin
  if k>l then exit(l) else exit(k);
end;
begin
  read(m,n);
  for i:=1 to m do read(a[i]);
  qs(1,m);｛使之成为单调递增序列｝
  for i:=1 to n do
  begin
    read(b);
    l:=1;r:=m;｛二分初始化：设定闭区间[1,m]}
    repeat
    mid:=(l+r)div 2;｛二分｝
    if b>a[mid] then l:=mid else r:=mid;｛模拟二分｝
    until l+1=r;｛不可以重叠，而要空出一个元素，否则不可能｝
    inc(sum,min(abs(a[l]-b),abs(a[r]-b)));｛加上最小值｝
  end;
  write(sum);
end.
```
[color=green]此题标准写法是使用二分搜索。为简洁并便于操作，并未采用递归二分，而采用模拟二分。需知，我们使用的思想是类似插入排序的扫描式。找到ai，使得a[i-1]=<b并且a[i]>=b或反之，只要用绝对值处理即可。再有，就是因为成绩无序，为实现二分，须一趟排序，成为单调递增序列。是为解。

墨凝  执笔[/color]


---

## 作者：Kwork (赞：2)

不知道贪心的标签怎么来的，不是个binary\_search吗，话说ef的名字也太丑了

首先对分数线排序，递增递减无所谓，然后，我们没读入一个估分就进行两次binary\_search，一次查找小于等于这个数的最大下标，一次查找大于等于这个数的最小下标，然后取差的绝对值的最小值累加，其实原本没那么长的写了输入输出的优化。

真的很水\【=\_=】/   OTZ

-------------------------------------------------------------------------------------------------------------------------------------





```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define min(a,b) ((a)<(b) ? (a):(b))
using namespace std;
const int maxn=100000+20;
int n,m,score[maxn];
inline void read(int& n){
    n=0;
    char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return;
}
void write(long long n){
    if(n>9) write(n/10);
    putchar((n % 10)+'0');
    return;
}
void init(){
    read(m);read(n);
    for(int i=1;i<=m;i++){
        read(score[i]);
    }
    sort(score+1,score+m+1);
    return;
}
int my_low_search(int t){
    int l=1,r=m;
    while((r-l)>1){
        int mid=(l+r)>>1;
        if(score[mid]<=t) l=mid;
        else r=mid;
    }
    return l;
}
int my_up_search(int t){
    int l=1,r=m;
    while((r-l)>1){
        int mid=(l+r)>>1;
        if(score[mid]>=t)r=mid;
        else l=mid;
    }
    return r;
}
int adjust(int t){
    int ans;
    int p=my_up_search(t);
    int q=my_low_search(t);
    ans=min(abs(t-score[p]),abs(t-score[q]));
    return ans;
}
inline int abs(int t){
    return t<0 ? (0-t):t;
} 
void solve(){
    long long ans=0;
    for(int i=1;i<=n;i++){
        int t;
        read(t);
        ans+=adjust(t);
    }
    write(ans);
    return;
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：xvhuanlin (赞：2)

本题就是排序加二分。

设学校分数线存入opt数组，将opt数组排序。

然后读入每一个学生的估分，在opt中二分查找，每找到一个学校都与估分计算差值，然后不断二分逼近，最后找到的一定是该估分的最小差值。

最后将所有的差值相加即可。

注意C/C++需要用long long类型。C++使用scanf/printf输入输出，若使用流io，则需要加入ios::sync\_with\_stdio(false)。


---

## 作者：MloVtry (赞：1)

肛道理，这个题其实可以维护一个指针那

把学校以及人都排个序（从小到大）

如果a（人）匹配B（学校）最优，那么比a分数高的c最优的学校，一定在B之后（即比B分数高，或者就是B）

所以我们可以维护一个指针，看看那个学校是最优的，然后把指针停在这个位置上

而假定a匹配B是最优的，则a匹配C或者D都要比匹配B的值大，所以可以方便的判定

如果一旦匹配值变大，证明已经匹配过了最优值，则把指针移回

因为指针最多会把所有学校遍历一遍，所以整体来讲是O（n）的

（虽然sort是nlog）

代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<ctime>
using namespace std;
int n,m,ans;
int a[100010],b[100010];
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;++i) scanf("%d",&b[i]);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    sort(b+1,b+m+1);
    sort(a+1,a+n+1);
    int j=1;
    for(int i=1;i<=n;++i)
    {
        int gt=10000000;
        while("MloVtry is Handsome")
        {
            int it=abs(a[i]-b[j]);
            gt=min(it,gt);
            if(it>gt)
            {
                j--;
                break;
            }
            else j++;
        }
        ans+=gt;
    }
    cout<<ans<<endl;
    return 0;
}
//今天也依旧没有捞到47厌战岛风呢
//6-1根本没有47！
//6-2也是！！！【愤怒.jpg】
```

---


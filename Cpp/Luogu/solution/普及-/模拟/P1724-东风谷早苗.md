# 东风谷早苗

## 题目描述

在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走，厉害吧（好吧，我自重）。早苗的新模型可以按照输入的命令进行移动，命令包含 $\verb|E|$、$\verb|S|$、$\verb|W|$、$\verb|N|$ 四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在 $0$ 时刻时早苗将钢达姆放置在了 $(0,0)$ 的位置，并且输入了命令串。她想要知道 $T$ 秒后钢达姆所在的位置坐标。

假设当前钢达姆的位置是 $(x,y)$。那么对于四种方向的移动，它坐标的改变分别为：

- 向东移动，坐标改变改变为 $(x+1,y)$；
- 向南移动，坐标改变改变为 $(x,y-1)$；
- 向西移动，坐标改变改变为 $(x-1,y)$；
- 向北移动，坐标改变改变为 $(x,y+1)$。




## 说明/提示

用 $|S|$ 表示早苗输入的命令串的长度。

- 对于 $60\%$ 的数据，$T\le 5\times 10^5$，$|S|\le 5\times 10^3$。
- 对于 $100\%$ 的数据，$T \le 2\times 10^9$，$|S|\le  5\times 10^3$。


## 样例 #1

### 输入

```
NSWWNSNEEWN
12
```

### 输出

```
-1 3```

# 题解

## 作者：RKcer21 (赞：26)

这题是一道不错的题目
首先，让我们来晒一下0分WA代码
```
#include<bits/stdc++.h>
using namespace std;
int a[10001];
char c[5001];
int i,j,k,n,m,t,x,y;
  int main()
{
  gets(c);
  cin>>n;
  m=strlen(c);
  for (i=0; i<n; i++)
    {
      if (c[i%m]=='E') x+=1;
        else if (c[i%m]=='S') y-=1;
          else if (c[i%m]=='W') x-=1;
            else y+=1;
    }
cout<<x<<' '<<y;
return 0;
}
```
乍一眼看，没毛病，模拟大法啊，可是，luogu评测机似乎是用linux的，gets会出问题（注：noip也是用linux评测的）
具体怎么解决呢？请看下集（走开）

如果你坚持要用，你可以选择度娘（玄学啊）

现在让我们来看改了gets的程序

```
#include<bits/stdc++.h>
using namespace std;
int a[10001];
string c;
int i,j,k,n,m,t,x,y;
  int main()
{
  cin>>c;
  cin>>n;
  m=c.length();
  for (i=0; i<n; i++)
    {
      if (c[i%m]=='E') x+=1;
        else if (c[i%m]=='S') y-=1;
          else if (c[i%m]=='W') x-=1;
            else y+=1;//按题意模拟即可
    }
cout<<x<<' '<<y;
return 0;
}
```
怎么只有60分啊，我们可以看一下数据。

对于60%的数据：T <= 500,000且命令串长度 <= 5,000

对于100%的数据：T <= 2,000,000,000且命令串长度<= 5,000

哦，原来是那40%的大数据惹的祸。

再看一下题目与程序，你会发现，有很多个步骤是在重复运行的
于是乎，我们可以将每一轮的运动方式给记录下来（记录每一轮x与y的变化），再将剩余的步骤直接暴力即可（不要说的这么难听，模拟好不好）

```
#include<bits/stdc++.h>
using namespace std;
int a[10001],xx,yy;//xx与yy记录每一轮的运动方式，即每一轮x与y的变化
string c;
int i,j,k,n,m,t,x,y;
  int main()
{
  cin>>c;
  cin>>n;
  m=c.length();
  for (i=0; i<m; i++)
    if (c[i%m]=='E') xx+=1;
        else if (c[i%m]=='S') yy-=1;
          else if (c[i%m]=='W') xx-=1;
            else yy+=1;//记录每一轮的运动方式
for (i=0; i<n%m; i++)
     if (c[i%m]=='E') x+=1;
        else if (c[i%m]=='S') y-=1;
          else if (c[i%m]=='W') x-=1;
            else y+=1; //将剩余进行模拟
cout<<x+n/m*xx<<' '<<y+n/m*yy;
return 0;
}
```

---

## 作者：VenusM1nT (赞：15)

a这题难度不小啊。。。

（是你忘看数据范围了啊喂！）

这题如果直接上暴力的话会TLE，相信大家已经有血的教训了

暴力代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
map <char,int> dx,dy;
string s;
int tot,n,x,y;
int main()
{
    dx['E']=1;
    dy['S']=-1;
    dx['W']=-1;
    dy['N']=1;
    cin >> s >> n;
    for(int i=1;i<=n;i++)
    {
        if(tot==s.size()) tot=0;
        x+=dx[s[tot]];
        y+=dy[s[tot]];
        tot++;
    }
    cout << x << " " << y;
    return 0;
}
```
非常暴力对吧，枚举每一次动作

但是因为n的范围实在太大，得分只有60

所以我们需要优化

我们不妨将每一轮的移动方式及移动了几轮算出来

再把剩下的几次模拟一下就可以啦

代码如下

``` 
#include<bits/stdc++.h>
using namespace std;
int dx[105],dy[105];
int cx,cy,n,x,y;
string s;
int main()
{
    dx['E']=1;
    dy['S']=-1;
    dx['W']=-1;
    dy['N']=1;
    cin >> s >> n; 
    for(int i=0;i<s.size();i++) cx+=dx[s[i]],cy+=dy[s[i]];//每一轮如何移动 
    int r=n/s.size();//计算有几轮 
    x+=r*cx;
    y+=r*cy;
    n%=s.size();
    for(int i=0;i<n;i++) x+=dx[s[i]],y+=dy[s[i]];//剩下的几次模拟一下 
    cout << x << " " << y;//完美结束 
}
```

---

## 作者：C929_半枫 (赞：8)

先说说我的思路：读入字符串将方向存入这样两个数组中
```cpp
int dx[5500];

int dy[5500];
```
然后在循环读入，最后输出结果。然后......当然是超时~~emmmmm~~

#### 所以我们需要优化算法。
既然执行完命令串最后一个命令后，会自动从头开始循环，那么就会有重复的部分，我们就不需要从第一秒一直读到最后一秒
### 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[5500];
int i,t,l,x=0,y=0,k;
int dx[5500];
int dy[5500];
int main()
{
	cin>>s;
	cin>>t;
	l=strlen(s);
	for(i=0;i<l;++i)//将指令转化为四个方向 
	{
		if(s[i]=='E')
		{
			dx[i]=1;
			dy[i]=0;
		}
		if(s[i]=='S')
		{
			dx[i]=0;
			dy[i]=-1;
		}
		if(s[i]=='W')
		{
			dx[i]=-1;
			dy[i]=0;
		}
		if(s[i]=='N')
		{
			dx[i]=0;
			dy[i]=1;
		}
	}
	k=t/l;//计算会循环多少次 
	for(i=0;i<(t%l)+l;++i)//注意！！！读完整个字符串还要加上剩余的部分 
	{
		if(i<l)//还没有读到剩余部分时 
		{
			x+=k*(dx[i%l]);//乘上循环次数 
			y+=k*(dy[i%l]);
		}
		else
		{
			x+=(dx[i%l]);//已经读到剩余部分，只加一次 
			y+=(dy[i%l]);
		}
		
	}
	cout<<x<<" "<<y<<endl;//end 
}
```


---

## 作者：_jimmywang_ (赞：7)


### 第一眼看见题目：哇！！大水题！！
#### 于是有了这份代码：
```
#include<bits/stdc++.h>
using namespace std;
string s;
long long t;
long long x,y;
int main()
{
    cin>>s>>t;
    for(long long i=1;i<=t;i++)
    {
    	if(s[(i-1)%s.size()]=='N')x++;
    	if(s[(i-1)%s.size()]=='E')y++;
    	if(s[(i-1)%s.size()]=='S')x--;
    	if(s[(i-1)%s.size()]=='W')y--;
	}
	
	cout<<y<<" "<<x;
    return 0;
}
```
（别CtrlcCtrlv了，60分）
### 于是看范围：
对于60%的数据：T <= 500,000且命令串长度 <= 5,000

对于100%的数据：T <= 2,000,000,000且命令串长度<= 5,000

~~（眼瞎TAT）~~

由“T <= 2,000,000,000且命令串长度<= 5,000”知，T>命令串长度。

脑内闪出一玩意儿：

```
  O /  O /  O /
   /    /    /
  / O  / O  / O
```
于是优化成循环T/L（命令串长度）次的执行一次命令串……

加前T%L个命令。

极限情况下（T=1,999,999,999,L=5,000）,原来循环1,999,999,999次

变为5,000+4,999=9,999
```
#include<bits/stdc++.h>
using namespace std;
string s;
long long t;
long long x,y;
int main()
{
    cin>>s>>t;
    for(int i=0;i<=min((long long)s.size()-1,t);i++)
    {
    	if(s[i]=='N')x++;
    	if(s[i]=='E')y++;
    	if(s[i]=='S')x--;
    	if(s[i]=='W')y--;
	}
	int bs=t/s.size();
	int ys=t%s.size();
	x*=bs,y*=bs;
	for(int i=0;i<ys;i++)
    {
    	if(s[i]=='N')x++;
    	if(s[i]=='E')y++;
    	if(s[i]=='S')x--;
    	if(s[i]=='W')y--;
	}
	cout<<y<<" "<<x;
    return 0;
}
```
# 呵呵

---

## 作者：oierwa (赞：5)

这是一道非常神奇的模拟题，有的时候吧，就非常想打一道水题，差点就要开始写了，emmmm，忽然看了一下范围（水题一般不看范围的），就吓了一滚，哎呦你20亿的数据是要干嘛......

当时没有仔细想，直接long long~~（有了Noip没开long long爆扣八分的经历，再也不敢浪int）~~上。

其实仔细算一下，不开long long也没关系，但是以防万一嘛，比如说它出一个什么挂掉的数据，那就崩溃。

所以说思路大体是这样的：
```
1.读入，并将每个字符串的移动路程算出。
2.乘以一个移动的重复次数。
3.将最后一点末端处理
```
差不多就这样，详见代码：
```
#include <bits/stdc++.h>
using namespace std;
char a[5001];
long long i,j,k,len,x,y,t,times,xplus,yplus;
int main(){
	cin>>a>>t;                  //这里可以用cin>>a+1.
	len=strlen(a);
	times=floor(t/len);
	for(i=0;i<=len-1;++i){
		if(a[i]=='E') xplus++;  //东
		if(a[i]=='S') yplus--;  //南
		if(a[i]=='W') xplus--;  //西
		if(a[i]=='N') yplus++;  //北
	}                           //1
	t-=times*len;
	xplus*=times;
	yplus*=times;
	x=xplus,y=yplus;            //2
	for(i=0;i<=t-1;++i){        //t是剩余的没有走的部分
		if(a[i]=='E') x++;
		if(a[i]=='S') y--;
		if(a[i]=='W') x--;
		if(a[i]=='N') y++;
	}                           //3
	cout<<x<<" "<<y;
}
```

---

## 作者：空の軌跡 (赞：4)

这道题显然是不能挨个操作的，因为他的T很大，如果你直接挨个模拟，那么就会T，只能拿60分。

但是我们可以看到字符串的长度不会大于5000,我们会重复进行这个字符串的操作很多次，所以我们可以直接求出进行一串操作对位置的改变，然后直接求出一共会进行多少次完整的操作，这样就看可以算出这些操作后自己的位置会处在那里，最后把剩余的步数再模拟进行一遍，就可以算出答案了。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int main()
{
	string a;cin>>a;
	int b,q=0,w=0,z=a.length();
   cin>>b;
	for(int i=0;i<z;i++)
	{
		if(a[i]=='W')q--;
		if(a[i]=='E')q++;
		if(a[i]=='N')w++;
		if(a[i]=='S')w--;
	}
	int o=b%z,m=b/z;
	q*=m;w*=m;
	for(int i=0;i<o;i++)
	{
		
		if(a[i]=='W')q--;
		if(a[i]=='E')q++;
		if(a[i]=='N')w++;
		if(a[i]=='S')w--;
	}
	cout<<q<<" "<<w;
}
```

---

## 作者：EarthGiao (赞：4)

由题知如果T超过了就要继续循环执行！

设源坐标为(x0,y0)

则可以事先算出每一次执行指令的时候整体的坐标变更offsetX,offsetY;

之后算循环次数k=T/lengthof(cmd_string);

则最后再循环T%length次得到修改后坐标(x1,y1)；

最终坐标即

(x1+offsetx*k,y1+offsety*k)



```cpp
//其实有很多地方可以优化，代码可以不用这么长。
#include<cstdio>
#include<cstring>
struct point
{
	int x;
	int y;
};
char b[200005];
int main()
{
	point a,d;
	int n,c=0,l,s=0;
	a.x=0;
	a.y=0;
	scanf("%s %d",b,&n);
	l=strlen(b);//求出命令串长度
	for(int i=0; i<l; i++) //执行一次操作，看每一组命令的变化
		switch(b[i])
		{
			case 'E':
				a.x++;
				break;
			case 'S':
				a.y--;
				break;
			case 'W':
				a.x--;
				break;
			case 'N':
				a.y++;
				break
		}

	d=a;//将每一次的变化赋值给d
	for(int i=1; i<n/l; i++) //进行n/l次，即整个命令串要重复的次数，因为前面执行了一次，所以是i<n/l而不是i<=n/l
	{
		a.x+=d.x;
		a.y+=d.y;
	}
	for(int i=0; i<n%l; i++) //n%l多出来要补执行的命令长度
		switch(b[i])
		{
			case 'E':
				a.x++;
				break;
			case 'S':
				a.y--;
				break;
			case 'W':
				a.x--;
				break;
			case 'N':
				a.y++;
				break;
		}
	printf("%d %d",a.x,a.y);
	return 0;

}
```

---

## 作者：yang2016 (赞：3)

又是没有c++代码 来一发

直接模拟会超时 T比较大

        
        
    
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int t,l,a=0,m,n;
string s;
int main()
{
    int x=0,y=0;
    cin>>s;
    l=s.size();
    cin>>t;
    n=t/l;m=t%l;//计算会有几个循环 循环后剩余多少步要走
    for(int i=0;i<l;i++)
    {
        if(s[i]=='N') y++;
        if(s[i]=='S') y--;
        if(s[i]=='E') x++;
        if(s[i]=='W') x--;
    }
    x=x*n;y=y*n;//相乘就可以
    for(int i=0;i<m;i++)//模拟剩下的步数
    {
        if(s[i]=='N') y++;
        if(s[i]=='S') y--;
        if(s[i]=='E') x++;
        if(s[i]=='W') x--;
    }
    cout<<x<<' '<<y;
    return 0;
}

```

---

## 作者：与我常在 (赞：1)

这题蛮简单的，这里给出一种O(字符串长度)的做法

记字符串长度为len

首先，我们先枚举走i(i <= len)步后机器人的坐标，显然此时机器人的坐标是相对原点0，0的。

我们记走len步后机器人坐标为(x, y)

那么我们就可以类推，走了len + 1 -> len * 2后的位置，就是相对于(x, y)走了1 -> len步,故在(x,y)的基础上只需加上len步的相对坐标即可

依次类推，最后我们可以发现，机器人T秒(即走了T步)后的坐标便是相对于(T / len * x, T / len * y)这个位置又走了T % len步，最后计算输出这个坐标即可

## Code
```
#include <cstdio>
#include <cstring>

const int N = 5010;

int t, nx, ny;
int x[N], y[N];
char a[N];

int main() {
	scanf("%s", a + 1);
	scanf("%d", &t);
	
	int len = strlen(a + 1);
	for(int i = 1; i <= len; i ++) {
		if(a[i] == 'E') x[i] = ++ nx, y[i] = ny;
		else if(a[i] == 'S') x[i] = nx, y[i] = -- ny;
		else if(a[i] == 'W') x[i] = -- nx, y[i] = ny;
		else if(a[i] == 'N') x[i] = nx, y[i] = ++ ny;
	}
	
	int p = t % len;
	int q = t / len;
	printf("%d %d\n", x[len] * q + x[p], y[len] * q + y[p]);
	
	return 0;
}
```

---

## 作者：Wait_Snower (赞：1)

首先，我们发现钢达姆最后的坐标与它移动方向的顺序是无关的，

而一个" E "可以抵消一个" W "，一个" N "可以抵消一个" S "，

于是，我们就有了一个大胆的想法：

我们可以分别统计出每一个字母出现的次数，

然后" E "和" W "抵消，" N "和" S "抵消，

最后再用留下来的方向进行移动即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,x,y;
long long e,s,w,n; //分别统计每个字母出现的次数；
string a;
int main()
{ cin>>a>>t;
  long long lena=a.size();
  if(t<=lena) //若T<命令串的长度；
  { for(long long i=0;i<t;i++) //就从命令串的第一位统计到第T位；
    { if(a[i]=='E') e++;
      if(a[i]=='S') s++;
      if(a[i]=='W') w++;
      if(a[i]=='N') n++;
	}
	long long p,q;
	if(e>=w) p=e-w,x+=p; //两两相抵，余下的进行移动；
	else p=w-e,x-=p;
	if(n>=s) q=n-s,y+=q;
	else q=s-n,y-=q;
	cout<<x<<" "<<y<<"\n";
	return 0;
  }
  else //若T>命令串的长度；
  { long long h=(t-t%lena)/lena; //计算T中可包含的完整的命令串数；
    long long r=t%lena; //计算从命令串的首位起还需要多少个命令能完成T；
    for(long long i=0;i<lena;i++) //一个完整的命令串中每个字母出现的次数；
    { if(a[i]=='E') e++;
      if(a[i]=='S') s++;
      if(a[i]=='W') w++;
      if(a[i]=='N') n++;
	}
	e*=h;s*=h;w*=h;n*=h; //乘上T中包含的完整的命令串数；
	for(long long i=0;i<r;i++) //在还需要的命令中统计每个字母出现的次数。
	{ if(a[i]=='E') e++;
      if(a[i]=='S') s++;
      if(a[i]=='W') w++;
      if(a[i]=='N') n++;
	}
    long long p,q;
	if(e>=w) p=e-w,x+=p;
	else p=w-e,x-=p;
	if(n>=s) q=n-s,y+=q;
	else q=s-n,y-=q;
	cout<<x<<" "<<y<<"\n";
	return 0;
  }
  return 0;
}
```

---

## 作者：Dirt、 (赞：1)

对于每一次完整的执行命令串，x和y改变的值都是固定的

可以计算完整的执行一次命令串x和y改变的值

设命令串长度为L 则总共会完整执行t/L次

剩下的t%L次再次计算一遍即可

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;
long long t,x,y;
string s;
int main()
{
	cin>>s;
	scanf("%lld",&t);
	for(int i=0;i<s.size();i++)
	{
		if(s[i]=='E') x++;
		if(s[i]=='W') x--;
		if(s[i]=='N') y++;
		if(s[i]=='S') y--;
	}
	x=x*(t/s.size());
	y=y*(t/s.size());//x,y改变的值累加
	for(int i=0;i<t%s.size();i++)//计算剩余的t%L次
	{
		if(s[i]=='E') x++;
		if(s[i]=='W') x--;
		if(s[i]=='N') y++;
		if(s[i]=='S') y--;
	}
	printf("%lld %lld",x,y);
	return 0;
}
```

---

## 作者：蔡徐坤채 (赞：1)

老师叫我们做,我一看,我之前做过类似的,就多了个秒数。然后就有了一次0分的代码
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
char ch[1010];
int x,y,t;
int main(){
	cin>>(ch+1)>>t;
	int l=strlen(ch+1);
	for(int i=1;i<=l;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	for(int i=1;i<=t%l;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	cout<<x<<" "<<y;
	return 0;
}
```
RE了几个点后,我重新看了一下数据范围,一看吓了一跳,长度居然有5000，改了一下数据范围,又自信交上去了,先别CtrlcCtrlv，因为还是0分
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
char ch[5010];
int x,y,t;
int main(){
	cin>>(ch+1)>>t;
	int l=strlen(ch+1);
	for(int i=1;i<=l;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	for(int i=1;i<=t%l;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	cout<<x<<" "<<y;
	return 0;
}
```
想了一下,如果把这道题当周期问题来做,是不是可以A呢?于是,又有了下面的代码
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
char ch[5010];
int x,y,t;
int main(){
	cin>>(ch+1)>>t;
	int l=strlen(ch+1);
	for(int i=1;i<=l/t;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	for(int i=1;i<=l%t;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	cout<<x<<" "<<y;
	return 0;
}
```
先别CtrlcCtrlv,因为还是0分。又重新想了一下,循环条件改一下,在输出的地方改一下,有没有可能A呢?抱着绝望的心情,又交了一次,居然A了!!!顿时口吐芬芳****
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
char ch[5010];
int x,y,t,xx,yy;
int main(){
	cin>>(ch+1)>>t;
	int l=strlen(ch+1);
	for(int i=1;i<=l;i++){
		if(ch[i]=='E') xx++;
		if(ch[i]=='S') yy--;
		if(ch[i]=='W') xx--;
		if(ch[i]=='N') yy++;
	}
	for(int i=1;i<=t%l;i++){
		if(ch[i]=='E') x++;
		if(ch[i]=='S') y--;
		if(ch[i]=='W') x--;
		if(ch[i]=='N') y++;
	}
	cout<<x+t/l*xx<<" "<<y+t/l*yy;
	return 0;
}
```
本蒟蒻第一次写题解,支持一下

---

## 作者：judgejudge (赞：1)

本题是一道水题，如果没有进行一点小小的优化就会TLE了。

思路：首先要计算字符串st的长度，然后做一系列的相乘工作，接着补上多出来的部分。

下面是AC代码：
```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
	int i,j,k,n,t,a,b,c;
	string st;
	cin>>st;
	cin>>t;
	a=0;
	b=0;
	for(i=0;i<st.length();i++){
		if(st[i]=='N')a++;
		if(st[i]=='S')a--;
		if(st[i]=='E')b++;
		if(st[i]=='W')b--;
	}
	k=t/st.length();
	a*=k;
	b*=k;
	c=k*st.length();
	k=t-c;
	for(i=0;i<k;i++){
		if(st[i]=='N')a++;
		if(st[i]=='S')a--;
		if(st[i]=='E')b++;
		if(st[i]=='W')b--;
	}
	cout<<b<<" "<<a;
}
```
求管理员大佬给过！！！

---

## 作者：无颜ing (赞：1)

前面做这题用暴力做了三次都TLE了，就没去管过它了，今天在机房睡眼朦胧，快睡着了，又偏偏在做题，结果乱写一通，就搞出来了，后来自己分析了一下思路，觉得好神奇，于是就发个题解。我一向头脑简单，所以代码很好理解，有详细注释，可以做学习参考使用。（不过这道题确实很水，睡眼朦胧做都可以，千万不要用暴力，大数据啊.）

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;//方向命令 
long long ans,now,i,cur,cost;
long long n,len;//时间和长度 
long long x,y;//当前坐标 
int main(){
	ios::sync_with_stdio(false);//读入优化 
	cin>>s;//读入命令 
	len=s.size();//命令长度 
	for(i=0;i<len;i++){//以下全部是命令的效果，如向东走，向西走等.（题目里有详细公式，这是一个周期） 
		if(s[i]=='E')
			x++;
		if(s[i]=='S')
			y--;
		if(s[i]=='W')
			x--;
		if(s[i]=='N')
			y++;
	}//关键就是这下面几个算式 
	cin>>n;//读入时间 
	now=n%len;//这个最重要，把命令长度看成一个周期 ，求出多出部分 
	cost=n/len;//总共有几个周期 
	cur=cost*x;//因为上面已经求出一个周期x会变成多少，所以n个周期以后的x就是cur 
	ans=cost*y;//同上 
	x=0;//上面已经保存了n个周期后的x，y值 
	y=0;//所以现在更新x，y 
	for(i=0;i<now;i++){//处理多出来的部分 
		if(s[i]=='E')
			x++;
		if(s[i]=='S')
			y--;
		if(s[i]=='W')
			x--;
		if(s[i]=='N')
			y++;
	}//现在的x，y值一定要加上 
	cur+=x;//总x值 
	ans+=y;//总y值 
	cout<<cur<<' '<<ans;//输出
	//是不是很简单呢？ 
}
```

---

## 作者：Angel_s_Shadow (赞：0)

如各位大佬所说，这是一道不错的题目。

这道题我刚刚做的时候竟然想的就是把单次循环弄出来，然后一除就行

↑ 可能是因为我TLE太多了（（

晒思路

首先先把每种命令的坐标列成一个数组

然后把数组和字符关联起来（可能有更简便的方法

先算出一个循环的最终和

然后取模（岂不美哉

然后按取模的结果for循环一个个加上去

好了

上代码吧（

```cpp
#include <iostream>
#include <map>
using namespace std;
                            //东南西北
int Directions[5][2] = {{0,0},{1,0},{0,-1},{-1,0},{0,1}};
int main()
{
   // freopen("zaomiao.in","r",stdin);
    map<char,int> dirxy;//映射命令
    dirxy['N'] = 4;
    dirxy['W'] = 3;
    dirxy['S'] = 2;
    dirxy['E'] = 1;
    int Loop[2] = {0,0},position[2]={0,0};
  	//开单次循环和坐标数组↑
    string command= "NSWWNSNEEWN";
    int times = 12;
    cin>>command;
    cin>>times;
  	//输入命令
    for(int i=command.length()-1;i>=0;i--){
        Loop[0]+=Directions[dirxy[command[i]]][0];
        Loop[1]+=Directions[dirxy[command[i]]][1];
    }
  //算出单次循环
    int len = command.length();
    int rt = times/len;
    int st = times%len;
  	//除以和取模
    position[0]+=Loop[0]*rt;
    position[1]+=Loop[1]*rt;
  //加上n个循环的值
    for(int i=0;i<st;i++){
        position[0]+=Directions[dirxy[command[i]]][0];
        position[1]+=Directions[dirxy[command[i]]][1];
    }
   //一个个把取模的值算出来                        
    cout<<position[0]<<' '<<position[1];
   //输出
                                        
   //您已通过此题（太舒适了
    return 0;
}

```
另外提示一点哦  不能用getline  洛谷过不去（hiahiahia

本萌新又做出一道题（高兴ing  刷yyz吃西瓜去


---

## 作者：开心的猪 (赞：0)

一般普及-的题目都不看范围的……然后十分高兴地写了一个暴力的代码，然后又很高兴地发现了TLE……
于是这个时候可以想这样一件事情：在这道题里，控制代码的循环长度只有五千，如果先统计每次循环后机器人的位置，再把这个位置乘上循环的次数后在模拟。
以下是代码：
```c
#include<bits/stdc++.h>

using namespace std;

int main()
{
	char control[50000]={0};
	for(int i=0; i<50000; i++)
	{
		scanf("%c", &control[i]);
		if(control[i]=='\n')
		{
			control[i]=0;
			break;
		}
	}
	int T;
	scanf("%d", &T);
	int str=strlen(control);
	str--;
    int round_x=0, round_y=0;
	for(int i=0; i<str; i++)
	{
		if(control[i]=='N')
		{
			round_y++;
		}
		else if(control[i]=='S')
		{
			round_y--;
		}
		else if(control[i]=='W')
		{
			round_x--;
		}
		else if(control[i]=='E')
		{
			round_x++;
		}
	}
	int ans_x=round_x*(T/str), ans_y=round_y*(T/str);
	for(int i=0; i<T%str; i++)
	{
		if(control[i]=='N')
		{
			ans_y++;
		}
		else if(control[i]=='S')
		{
			ans_y--;
		}
		else if(control[i]=='W')
		{
			ans_x--;
		}
		else if(control[i]=='E')
		{
			ans_x++;
		}
	}
	printf("%d %d", ans_x, ans_y);
	return 0;
}
```


---

## 作者：Herkezi (赞：0)

首先，我们分析一下题目，总结一下就是：告诉你变换规律，给你一个只包含‘E’、’S’、’W’、’N’的字符串，模拟输出在t步之后的坐标位置。

至于其他，根本没用！

我一看，这不就是道模拟水题吗？怎么还有普及-的难度，根本就可以是入门的好吧？然后兴致勃勃，兴高采烈，开开心心地敲了个纯模拟……相信结果呢，大家都知道了……这道题，它竟然还暗藏玄机！！！

滑到题目底部，你会发现一个美丽新世界：

对于60%的数据：T <= 500,000且命令串长度 <= 5,000

对于100%的数据：T <= **2,000,000,000**且命令串长度<= 5,000

这……20亿？！可以的，就冲这范围，我给你个普及-的难度。

于是我们只能换一种思维。由题意可得，这个移动是有规律的，而且是个循环，这样就可以轻而易举地做出来了。

#### 下面是代码，看看注释应该更清楚。

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int nx=0,ny=0,t,le=0,ls=0,lw=0,ln=0;
	//nx,ny是记录当前坐标。 
	//t是题目所给，表示走的步数。 
	//le表示一次循环中，“E”的个数，之后有用。
	//ls表示一次循环中，“S”的个数，之后有用。
	//lw表示一次循环中，“W”的个数，之后有用。
	//ln表示一次循环中，“N”的个数，之后有用。这四个都是计数器，注意清零。 
	string s;  //题目所给字符串。 
	cin>>s>>t;
	int l=s.size(),len=floor(t*1.0/l);  
	//len记录了这段字符串循环了多少次，floor是向下取整，注意里面要乘个1.0，因为floor只能对实型操作。 
	for (int i=0;i<l;++i)
		switch(s[i])
		{
			case 'E':le++;break;
			case 'S':ls++;break;
			case 'W':lw++;break;
			case 'N':ln++;break;
		}
	//记录一次循环中，四种字符的个数。 
	int tx=le-lw,ty=ln-ls;
	nx+=len*tx,ny+=len*ty;
	//这两步很重要！！！它算出了经过len轮之后的坐标，这样省去了模拟的时间，这题大概就要完成了。 
	for (int i=0;i<t-len*l;++i)
		switch(s[i])
		{
			case 'E':nx+=1;break;
			case 'S':ny-=1;break;
			case 'W':nx-=1;break;
			case 'N':ny+=1;break;
		}
	//这个循环处理了len轮之后剩下步数的问题，按题意移动。 
	cout<<nx<<" "<<ny<<endl; 
	return 0;
}
```

可能我的代码看起来比较繁琐，但是咱要记住一件事儿：

#### 只要能AC的代码，都是好代码！

你们也可以理解为是我在为自己辩护（好吧，实际上还真是，逃）

---

## 作者：hyzxxqc (赞：0)

#### ## 数据范围！！！# 
相信每一个（仔细）读题的人都发现了这题~~诡异~~的数据，这只意味着一件事情：一个for语句就完成是不可能的。闲话不多说，进入正题：

------------
数据太大，就得分割。由于这一题是有重复执行命令的，所以就按s.length()分割。-_- 嫌我话多？？？好吧，代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,l,xx,yy,x,y;
string s;
int main()
{
	cin>>s>>t;//读入，不用说
	l=s.length();//长度
	for (int i=0;i<l;i++)//计算执行一次命令后的方位移动，储存在xx,yy中
		switch (s[i])
		{
			case 'E':xx++;break;
			case 'S':yy--;break;
			case 'W':xx--;break;
			case 'N':yy++;break;
		}
	for (int i=0;i<t%l;i++)//除整轮的命令外的剩余部分
		switch (s[i])
		{
			case 'E':x++;break;
			case 'S':y--;break;
			case 'W':x--;break;
			case 'N':y++;break;
		}
	for (int i=0;i<t/l;i++)//执行整轮的命令
	{
		x+=xx;
		y+=yy;
	}
	cout<<x<<' '<<y;//输出
	return 0;//是不是觉得很简单？？？
}
```

---

## 作者：户山香澄 (赞：0)

#一道interesting的水题

然而本人还是提交了3遍才A

所以说看到样例不全面的危害了吧。。。

总而言之

#不能直接模拟否则会TLE

（其实大家都知道了吧话说我的废话为什么这么多）

算法思路：像我这种极其不正经的人就会一个个用char读入毕竟我不喜欢string。。。总的来说就是读入一个判断一下然后保存一下行动方向。把指令条先模拟一遍（假设指令条长度为n），然后在乘上(t div n)，最后t=t mod n，for跑一遍。



```cpp
#var c:char;
##    dx,dy:array[1..5000] of integer;//行动方向数组
###    t,i,js,n,x,y:longint;
**begin**
  while not eoln do
    begin
      inc(n);
      read(c);//一个一个的读入
      case c of
          'E':dx[n]:=1;
          'S':dy[n]:=-1;
          'W':dx[n]:=-1;
          'N':dy[n]:=1;
        end;
    end;
  readln(t);
  js:=0;
  for i:=1 to n do //把指令条完全模拟一遍
    begin
      inc(js);
      x:=x+dx[js];
      y:=y+dy[js];
    end;
  x:=x*(t div n);
  y:=y*(t div n);
  t:=t mod n;
  js:=0;
  for i:=1 to t do //最后跑一边for循环
    begin
      inc(js);
      x:=x+dx[js];
      y:=y+dy[js];
    end;
  writeln(x,' ',y);
end.
```
愉快的结束了（话说非常担心能不能过），interesting的水题（语文老师说要首尾呼应），不是很难，自己做吧


---

## 作者：sparta (赞：0)

ci:循环次数；

yu:循环后还需做几次；

pan:判断走向；

```cpp
for(int j=0;j<s.length();j++)pan(s[j]);
         x*=ci;
         y*=ci;
for(int i=0;i<yu;i++)pan(s[i]);
```
总之——水题。
别认为太难。


---

## 作者：Your_Y (赞：0)

字符串读入命令指令，用f数组来储存到第i个指令的时候人的位移量，然后再用命令长度取余和整除时间数。

```delphi

var
  t,i,a,b,x,y,len:longint;
  s:ansistring;
  f:array[0..5000,1..2]of integer;
begin
  readln(s);
  readln(t);
  len:=length(s);
  for i:=1 to len do
   case s[i] of
     'E': begin f[i,1]:=f[i-1,1]+1; f[i,2]:=f[i-1,2]; end;
     'W': begin f[i,1]:=f[i-1,1]-1; f[i,2]:=f[i-1,2]; end;
     'N': begin f[i,1]:=f[i-1,1]; f[i,2]:=f[i-1,2]+1; end;
     'S': begin f[i,1]:=f[i-1,1]; f[i,2]:=f[i-1,2]-1; end;
    end; \预处理
  a:=t div len;
  b:=t mod len;
  x:=0; y:=0;
  x:=f[len,1]*a+f[b,1]; \计算方法
  y:=f[len,2]*a+f[b,2];
  writeln(x,' ',y);
end.

```

---

## 作者：MuYC (赞：0)

```cpp
/*
此题主要为周期问题，不需要模拟；
思路:计算一轮命令对x，y的改变，看T个时间单位内，执行了多少次命令，然后看还剩下多长的时间，再对接下来剩余的时间进行模拟，看最终执行到哪一步
*/
#include <bits/stdc++.h>
char a[10000];
using namespace std;
int main(){
	int i,j,T,k,n,x=0,y=0,xjia=0,yjia=0;
	cin>>a;//读入命令串
	cin>>T;//读入时间
	for(i=0;i<strlen(a);i++){
		if(a[i]=='N')yjia++;//枚举影响
		if(a[i]=='E')xjia++;//东
		if(a[i]=='W')xjia--;//西
		if(a[i]=='S')yjia--;//南
	}
	x+=T/strlen(a)*xjia;//计算Ts内执行了多少次命令对x的影响
	y+=T/strlen(a)*yjia;//计算Ts内执行了多少次命令对y的影响
	if(T%strlen(a)!=0)//如果还有剩余时间
	for(i=1;i<=T%strlen(a);i++){
		if(a[i-1]=='N')y++;//模拟，枚举影响，因为剩余时间不可能为0，所以要i-1
		if(a[i-1]=='E')x++;//东
		if(a[i-1]=='W')x--;//西
		if(a[i-1]=='S')y--;//南
	}
	cout<<x<<" "<<y;//输出
	return 0;
}
```

---

## 作者：hawa130 (赞：0)

一道模拟题

---
60分代码

比较暴力的模拟，会TLE
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,x=0,y=0;
string cmd;
void move(char c){//写个函数来模拟
    if(c=='E')x++;
    else if(c=='S')y--;
    else if(c=='W')x--;
    else if(c=='N')y++;
}
int main(){
    cin>>cmd;
    cin>>t;//读入
    for(int k=1;k<=t/cmd.length();k++)
        for(int i=0;i<cmd.length();i++)move(cmd[i]);
    for(int i=0;i<t%cmd.length();i++)move(cmd[i]);//模拟过程
    cout<<x<<' '<<y;
    return 0;
}
```
毕竟T的范围太大了

---
AC代码

优化：把每轮的移动存一下
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,x=0,y=0;
string cmd;
void move(char c){
	if(c=='E')x++;
	else if(c=='S')y--;
	else if(c=='W')x--;
	else if(c=='N')y++;
}
int main(){
	cin>>cmd;
	cin>>t;
	if(t>cmd.length())
    	for(int i=0;i<cmd.length();i++)move(cmd[i]);
	int a=x,b=y;//用a,b每储存一轮的移动
	x=0,y=0;//恢复
	for(int k=1;k<=t/cmd.length();k++)x+=a,y+=b;//模拟每一轮的移动，也可以相乘
	for(int i=0;i<t%cmd.length();i++)move(cmd[i]);//模拟剩下的
	cout<<x<<' '<<y;
	return 0;
}
```

---


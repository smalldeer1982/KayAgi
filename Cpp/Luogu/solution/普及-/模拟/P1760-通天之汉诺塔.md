# 通天之汉诺塔

## 题目背景

直达通天路·小A历险记第四篇


## 题目描述

在你的帮助下，小 A 成功收集到了宝贵的数据，他终于来到了传说中连接通天路的通天山。但是这距离通天路仍然有一段距离，但是小 A 突然发现他没有地图！！！但是幸运的是，他在山脚下发现了一个宝箱。根据经验判断（小 A 有经验吗？），地图应该就在其中！

在宝箱上，有三根柱子以及在一根柱子上的 $n$ 个圆盘。小 A 在经过很长时间判断后，觉得这就是 hanoi 塔！（这都要琢磨）。但是移动是需要时间的，所以小 A 必须要通过制造延寿药水来完成这项任务。现在，他请你告诉他需要多少步完成，以便他造足够的延寿药水。

## 说明/提示

### 数据范围及约定

对于所有数据，$n \le 15000$。

## 样例 #1

### 输入

```
31```

### 输出

```
2147483647```

## 样例 #2

### 输入

```
15```

### 输出

```
32767```

# 题解

## 作者：Terrific_Year (赞：72)

既然有人发了 Pascal 的高精度，怎能少得了 C++ 的呢 qwq。

---

题目大意：

经典汉诺塔问题，有 A，B，C 三根柱子，开始时 A 柱有 $n$ 个圆盘，圆盘大的必须放在下面（移动过程中也一样），每一步移动能且只能移动一个圆盘，求把所有圆盘移到 C 处最少步数。~~（据说移动 64 个圆盘到 C，世界就会毁灭。）~~

公式推导：

1. 当只有一个圆盘时，显然直接将圆盘移到 C 处，此时得到 $T(1)=1$
。

2. 我们考虑 $n=k$ 是已经得到 $T(k)$，则当 $n=k+1$ 时，我们要让大盘移到 C 处，必须先用 $T(k)$ 步把 $k$ 个小盘移到 B 处（这样才能让大盘的移动没有多余步骤），然后还要再用 $T(n)$ 步将 $k$ 个小盘移到 C 处，得到 $T(k+1)=T(k)\times 2+1$。

3. $T(k+1)+1=2\times (T(k)+1)$ 可以得到 $\{T(n)+1\}$ 为公比为 $2$ 的等比数列。

4. 最终求得的公式就是广为人知的 $T(n)=2^n-1$。

这道题由于 $n$ 比较大，要使用高精度才能将结果精确计算出来。

虽然大佬们都不用手写高精度，本蒟蒻还是个大家展示一下手写的吧：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,l,i,a[10000];//a倒序放每位

void mul(){//高精乘2
	for(int i=1;i<=l;i++)a[i]*=2;//每位乘2
    
	for(int i=1;i<=l;i++)//满十进一(不会出现进2的情况)
		if(a[i]>9){
			a[i+1]++;
			a[i]-=10; 
		}
        
	if(a[l+1]>0)l++;//如高位进位，长度加1
	
	return;
}

int main(){
	cin>>n;
	a[1]=1;
	l=1;//答案初始长度为1
    
	for(i=0;i<n;i++)mul();//求2^n
    
	for(i=l;i>1;i--)cout<<a[i];//打印高位
	cout<<a[1]-1;//由于不可能出现末位为0的情况，输出末位减1即可
    
	return 0;
} 
```

~~再也不见。~~

upd:2023/07/19 更新了题目大意及公式推导部分。

---

## 作者：zhzh2001 (赞：32)

一种**不用显式高精度**的方法，题解在最后


> 来自WC的小技巧，Pascal不支持

## 适用范围


仅适用于计算$2^n$的精确值，且$\left\vert n\right\vert<2^{14}$


浮点数能精确表示$2^n$，因为大部分浮点数内部都以2为底数，n的范围与浮点数类型有关。常用浮点数最高精度的long double也只有15位阶码。


## 使用方法


直接使用pow函数即可计算。


### C++


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    cout.precision(n>0?0:-n);
    cout<<fixed<<pow(2.0L,n)<<endl;
    return 0;
}
```

### C

```c
#include<stdio.h>
#include<math.h>
int main(void)
{
    int n;
    scanf("%d",&n);
    printf("%.*Lf\n",n>0?0:-n,powl(2.0L,n));
    return 0;
}
```

\*浮点数常量的L后缀表示long double\*




### Windows下scanf/printf

Windows下通常使用MinGW，部分版本可能无法正常使用`%lld`或`%Lf`。

解决方法非常简单，在程序首部加入：


```c
#define __USE_MINGW_ANSI_STDIO 1
```

## 题解


根据常识，答案等于$2^n-1$


由于n的范围刚好可以使用上述技巧，而且-1也很方便，直接在最低位-1即可，显然不会退位。


### 程序清单


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    stringstream ss;
    ss.precision(0);
    ss<<fixed<<pow(2.0L,n);
    string s=ss.str();
    s[s.length()-1]--;
    cout<<s<<endl;
    return 0;
}
```

这里利用了字符串流，当然用`sprintf`也完全没有问题。实测比手写高精度快很多，代码也很简单。


---

## 作者：吴铭事 (赞：12)

众所周知，此题答案就是2^n-1，可是没呢莫简单
首先展示一下60分程序（很多人这样写）
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n;
int main()
{
	cin>>n;
	cout<<pow(2,n)<<endl;
	return 0;
}
```
# **这道题如果要用C++做出来的话，必须用高精度**
所以乖乖用高精度做吧！！！

AC程序（简单易懂）

```
#include<iostream>
using namespace std;
int n,ans[10005];
int main()
{
	cin>>n;
	ans[0]=ans[1]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=ans[0];j++) ans[j]*=2;
		for(int j=1;j<=ans[0];j++) ans[j+1]+=ans[j]/10,ans[j]%=10;
		if(ans[ans[0]+1]!=0) ans[0]++;
		while(ans[ans[0]]/10!=0) ans[ans[0]+1]+=ans[ans[0]]/10,ans[ans[0]]%=10,ans[0]++;
	}
	ans[1]--;
	for(int i=ans[0];i>=1;i--) cout<<ans[i];
	return 0;
}
```
希望管理员大大的过！！！

---

## 作者：_Atyou (赞：10)

## 算法： 压八位高精度快速幂

#### 题目通式： ans=2^n-1

n最大能15000就是高精

字符串操作太骚学不来 Python是非NOI系列竞赛正式语言

写个压八位的高精度 + 快速幂

感觉是所有代码里面性价比最高的一款了

代码长度较短，效率很高，高精度快速幂都是很常规的操作

太久没写高精手有点生疏了吧，一开始没控制好越界和进制问题，（~~明明就是太弱了~~）

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
#define ull unsigned long long
const int BASE = 100000000; //压八位的进制

int n;
ull ans[1000], a[1000], c[1000];

int main() {
    scanf("%d", &n);
    ans[1]=1; a[1]=2;
    ans[0]=a[0]=1; //第0位储存长度
    for (; n; n>>=1) {
        if (n&1) {
            memset(c, 0, sizeof(c));
            for (reg int i=1; i<=ans[0]; ++i)
                for (reg int j=1; j<=a[0]; ++j) c[i+j-1]+=ans[i]*a[j];
            c[0]=ans[0]+a[0];
            for (reg int i=1; i<=c[0]; ++i) c[i+1]+=c[i]/BASE, c[i]%=BASE;
            while (!c[c[0]]) --c[0];
            memcpy(ans, c, sizeof(ans));
            //以上操作等价于ans=ans*a
        }
        memset(c, 0, sizeof(c));
            for (reg int i=1; i<=a[0]; ++i)
                for (reg int j=1; j<=a[0]; ++j) c[i+j-1]+=a[i]*a[j];
        c[0]=a[0]+a[0];
        for (reg int i=1; i<=c[0]; ++i) c[i+1]+=c[i]/BASE, c[i]%=BASE;
        while (!c[c[0]]) --c[0];
        memcpy(a, c, sizeof(a));
        //以上操作等价于a=a*a
    }
    --ans[1];
    printf("%lld", ans[ans[0]]); //最高位不用补零，直接输出
    for (reg int i=ans[0]-1; i; --i) printf("%08lld", ans[i]); //后面的不够八位要补零
    return 0;
}

```

感觉跑的飞快

另外memcpy printf真好用

~~大佬都在刷省选题，蒟蒻的我还在弄高精度，果然还是太弱了~~


---

## 作者：da32s1da (赞：10)

## PY语言就是好

2^n-1
```cpp
print(pow(2,int(input()))-1)
```

---

## 作者：Azazеl (赞：7)

蒟蒻又来写题解了······

关于汉诺塔，其实有很多解法，像递推，递归，~~暴搜~~等。
下面有几种在汉诺塔中比较常用的方法


**（注：此题解除3外均未加入高精，但仅供思路参考）**

### 1.递归
```cpp
#include <cstdio>
int ans=0;
void hanoi(int n,char a,char c,char b)//函数表示共n片圆盘，将A上的圆盘借助B，移动至C
//（第一个int为圆盘数，第二个char为圆盘所在，第三个char为目标柱子，第四个char为借助的柱子）
{
	if(n==0) return;
	hanoi(n-1,a,b,c);
	ans++;//若想知道具体的移动方法，那就把这里改成：printf("%d %c %c\n",n,a,c);
	hanoi(n-1,b,c,a);
}

int main() {
	int n;
	scanf("%d",&n);
	hanoi(n,'A','B','C');
	printf("%d",ans);
	return 0;
}
```
递归比较难理解，还会超时，但当你想要求出每一步的移动方法时，就可以用这种方法

（其实说实话，你根本不懂电脑是怎么给你算出来的，但你可以用这种方法来解决~~玄学~~问题）

### 2.递推
```cpp
#include <cstdio>
long long x[10005]={0,1,3};
int main() {
	int n;
	scanf("%d",&n);
	for(int i=3;i<=n;i++) x[i]=x[i-1]+1+x[i-1];
	printf("%lld",x[n]);
	return 0;
}
```
这里的递推式
```cpp
x[i]=x[i-1]+1+x[i-1];
```
意义就是:将前n-1个圆盘移动至B柱，然后将第n个圆盘移动至C柱，最后将前n-1个圆盘由B又移动至C

### 3.公式
不多说，都知道是$a^{2}-1$
（不想打高精因此选择python(*^▽^*)）
```python
n=int(input())
print (pow(2,n)-1)
```


---

## 作者：Thinking (赞：5)

看到大佬们都用快速幂，蒟蒻发个压位高精度（压位高精度AC第一题^\_^）

首先公式地球人都知道，s=2^n-1。

n<=15000，很明显要用高精度。

但是！裸的高精度的话，会发现最后一个点TLE了，因为时间复杂度是O(nl)的最后一个点n=15000会爆。

大佬们都用快速幂O(logn\*l)；我就直接压四位了（虽然不是很快，但也不到0.3s）。

```pascal
var
  a:array[1..10000] of integer;
  n,i,j,l:longint;
procedure w(x:integer);
  begin
    if x<1000 then write(0);
    if x<100 then write(0);
    if x<10 then write(0);
    write(x)
  end;  //压位输出要补零！（为了这个六十分n次TAT）
begin
  read(n);
  fillchar(a,sizeof(a),0);
  a[1]:=1;
  l:=1;
  for i:=1 to n do begin
    for j:=1 to l do a[j]:=a[j]*2;
    for j:=1 to l+1 do if a[j]>10000 then begin
      inc(a[j+1],a[j] div 10000);  //压四位
      a[j]:=a[j] mod 10000
    end;
    if a[l+1]>0 then inc(l)
  end;  //高精乘
  dec(a[1]);  //因为2^n的末尾不可能是零，所以不用退位。
  write(a[l]);  //最高位不用压！
  for i:=l-1 downto 1 do w(a[i])
end.
```

---

## 作者：你打野 (赞：5)

话不多说，上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a;stringstream b;
string c;
int main()
{cin>>a;
b.precision(0);
b<<fixed/*stringstream运算符*/<<pow(2.0L,a);//计算
c=b.str()/*转化*/;c[c.length()-1]--;//由题知，次数为2^n-1
cout<<c;//输出}
```

---

## 作者：恶灬心 (赞：4)

## **不用快速幂的普通算法（加高精）**
#### 首先说一下方法当n=1时 可得出ans=1
####  n   ans
#### | 1 | 1 |
#### | 2 | 3 |
#### | 3 | 7 |
####  ......
#### 观察可得出结论 f(n)=2*f(n-1)+1;于是有了下面的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;			//以上必须存在不解释
int a[2][10000];		//本来重要思想 类似滚动数组
						//a[0]、a[1]就是上面的f(n)和f(n-1)
int main()
{
	int n;cin>>n;
	if(n==0){cout<<0;return 0;}//特判0,本代码唯一缺陷 是从1开始算的
	a[0][1]=1;a[0][0]=1;//附初值n=1时的值 a[0][0]和a[1][0]代表长度
	for(int i=2;i<=n;i++)//高精度
	{
		int k=i%2,j=1-k,x=0;
        //这里j和k是代表f(n)和f(n-1)在数组中的位置
        a[k][0]+=2;	//防止出现进不了位	
		for(int z=1;z<=a[k][0];z++)
		{
			a[j][z]=2*a[k][z]+x;
			x=a[j][z]/10;a[j][z]%=10;
		}
		a[j][1]++;a[j][0]+=2;//此处执行f(n)=2*f(n-1)+1;
		while(a[j][a[j][0]]==0)a[j][0]--;//减去前导0
	}
	int k=1-n%2;//找出答案数组
	if(a[k][1]>9)//防止个位+1后出现没进位情况，但目测好像没用
	{
		int x=0;
		for(int i=1;i<=a[k][0];i++)
		{
			a[k][i]=x+a[k][i];x=a[k][i]/10;a[k][i]%=10;
		}
	}
	for(int i=a[k][0];i>=1;i--)cout<<a[k][i];//输出
	return 0;
}
```
###### 本蒟蒻第一篇代码 求过

---

## 作者：Stella_Yan (赞：4)

直接py水过去就行了

py的int自动高精

不难发现移动次数就是$2^n-1$

贴代码：

---


```python
n=int(input()) #输入n
tot=1 #计算次数
for i in range(0,n,1):
    tot*=2 #2的n次方就是tot每次乘2
tot-=1 #2的n次方再减1
print(tot) #输出

```

---


~~吐槽一下输入输出数据的input和output是什么鬼呀~~

---

## 作者：Shikita (赞：3)

# 高精度幂方
想必题目非常好懂吧，就是2^n-1，~~看一眼样例那熟悉的数字猜都猜出来了吧~~
但是再看一眼数据 n<=15000，很明显就是一道高精度了

其实代码都差不多，别的都是80+行，还有几个~~无耻的~~pyhon两行我就不说了
但是现在NOI/NOIP还未支持pyhon，所以高精度还是要打的嘛

而且这题最无耻的是，第一个点是0！！！！

我因此疯狂MLE，惊了！

由于递归调用，所以输出那里就丑陋了一点，请大佬们谅解

剧透：FFT优化

（其实我就是来宣传FFT优化高精度幂单调）

## 代码
```
#include <iostream>  
#include <cstdio>  
#include <algorithm>  
#include <cstring>  
#include <cmath>  
#include <map>  
#include <queue>  
#include <set>  
#include <vector>  
using namespace std;  
#define L(x) (1 << (x))  
const double PI = acos(-1.0);  
const int Maxn = 80000;  
double ax[Maxn], ay[Maxn], bx[Maxn], by[Maxn];  
char sa[Maxn/2],sb[Maxn/2];  
int sum[Maxn];  
int x1[Maxn],x2[Maxn];  
int revv(int x, int bits)  
{  
    int ret = 0;  
    for (int i = 0; i < bits; i++)  
    {  
        ret <<= 1;  
        ret |= x & 1;  
        x >>= 1;  
    }  
    return ret;  
}  
void fft(double * a, double * b, int n, bool rev)  
{  
    int bits = 0;  
    while (1 << bits < n) ++bits;  
    for (int i = 0; i < n; i++)  
    {  
        int j = revv(i, bits);  
        if (i < j)  
            swap(a[i], a[j]), swap(b[i], b[j]);  
    }  
    for (int len = 2; len <= n; len <<= 1)  
    {  
        int half = len >> 1;  
        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);  
        if (rev) wmy = -wmy;  
        for (int i = 0; i < n; i += len)  
        {  
            double wx = 1, wy = 0;  
            for (int j = 0; j < half; j++)  
            {  
                double cx = a[i + j], cy = b[i + j];  
                double dx = a[i + j + half], dy = b[i + j + half];  
                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;  
                a[i + j] = cx + ex, b[i + j] = cy + ey;  
                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;  
                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;  
                wx = wnx, wy = wny;  
            }  
        }  
    }  
    if (rev)  
    {  
        for (int i = 0; i < n; i++)  
            a[i] /= n, b[i] /= n;  
    }  
}  
int solve(int a[],int na,int b[],int nb,int ans[])  
{  
    int len = max(na, nb), ln;  
    for(ln=0; L(ln)<len; ++ln);  
    len=L(++ln);  
    for (int i = 0; i < len ; ++i)  
    {  
        if (i >= na) ax[i] = 0, ay[i] =0;  
        else ax[i] = a[i], ay[i] = 0;  
    }  
    fft(ax, ay, len, 0);  
    for (int i = 0; i < len; ++i)  
    {  
        if (i >= nb) bx[i] = 0, by[i] = 0;  
        else bx[i] = b[i], by[i] = 0;  
    }  
    fft(bx, by, len, 0);  
    for (int i = 0; i < len; ++i)  
    {  
        double cx = ax[i] * bx[i] - ay[i] * by[i];  
        double cy = ax[i] * by[i] + ay[i] * bx[i];  
        ax[i] = cx, ay[i] = cy;  
    }  
    fft(ax, ay, len, 1);  
    for (int i = 0; i < len; ++i)  
        ans[i] = (int)(ax[i] + 0.5);  
    return len;  
}  
string mul(string sa,string sb)  
{  
    int l1,l2,l;  
    int i;  
    string ans;  
    memset(sum, 0, sizeof(sum));  
    l1 = sa.size();  
    l2 = sb.size();  
    for(i = 0; i < l1; i++)  
        x1[i] = sa[l1 - i - 1]-'0';  
    for(i = 0; i < l2; i++)  
        x2[i] = sb[l2-i-1]-'0';  
    l = solve(x1, l1, x2, l2, sum);  
    for(i = 0; i<l || sum[i] >= 10; i++)  
    {  
        sum[i + 1] += sum[i] / 10;  
        sum[i] %= 10;  
    }  
    l = i;  
    while(sum[l] <= 0 && l>0)    l--;  
    for(i = l; i >= 0; i--)    ans+=sum[i] + '0';   
    return ans;  
}  
string Pow(string a,int n)  
{  
    if(n==1) return a;  
    if(n&1) return mul(Pow(a,n-1),a);  
    string ans=Pow(a,n/2);  
    return mul(ans,ans);  
}  
int main()  
{  
    cin.sync_with_stdio(false);//没什么用的东西  
    int n;
    string s="2";
    cin>>n; 
    if(n==0) {cout<<0<<endl;return 0;}
    string ss=Pow(s,n);
    int x=ss.size();
    ss[x-1]=(ss[x-1]-'0'-1)+'0';
	cout<<ss<<endl;  
    return 0;  
} 
```

---

## 作者：ars4me (赞：2)

我们可以用一个num[]数组来存储答案且num[1]代表个位 往后类推

```cpp
#include<iostream>
using namespace std;
#define SIZE 100001
int num[SIZE];
int n,len=1;
```
n是我们要输入的数字 len代表输出答案的长度 首先要初始化
num[1]=1;

然后就是记录移动

for(int i=1;i<=n;i++){Record()；}

这里我们需要弄一个函数record来记录

```cpp
void Record()
{
    int carry_bit=0;//我们应当考虑到进位的情况 所以建立一个变量记录进位 下面有用法
    for(int i=1;i<=len;i++){
        num[i]=num[i]*2;
        num[i]+=carry_bit;//如果有前一位进上来的数肯定要加上
        if(num[i]<10){
            carry_bit=0;//小于10肯定不会进位
        }
        else{//大于10有进位
            carry_bit=num[i]/10;//计算进上去的数
            num[i]=num[i]%10;//这一位%10储存 很好理解
            if(i==len){
                len=i+1;//之前说过len的意义 如果i已经和目前的len相等可是又进了一位 就必须要增加长度
            }
        }
    }
}
```
调用了n次之后 我们好像已经计算出了n个塔移动的次数 但是如果我们此时输入 3 输出的答案应该是7 可却是8
原因是之前我们个位多加了一次 于是

num[1]-=1;

然后倒叙输出


全代码如下

```cpp
#include<iostream>
using namespace std;
#define SIZE 100001
int num[SIZE];
int n,len=1;
void Record()
{
    int carry_bit=0;
    for(int i=1;i<=len;i++){
        num[i]=num[i]*2;
        num[i]+=carry_bit;
        if(num[i]<10){
            carry_bit=0;
        }
        else{
            carry_bit=num[i]/10;
            num[i]=num[i]%10;
            if(i==len){
                len=i+1;
            }
        }
    }
}
int main()
{
    cin>>n;
    num[1]=1;
    for(int i=1;i<=n;i++){
        Record();
    }
    num[1]-=1;
    for(int i=len;i>=1;i--){
        cout<<num[i];
    }
    cout<<endl;
    return 0;
}
//COYG
```

---

## 作者：zk1431043937 (赞：2)

来个数学算法，题解里似乎还没有。

看到给出的样例，作为p党，一看就知道2147483647是maxlongint，32767是maxinteger。

因此我们也不难发现，答案正好是2^n-1。

所以我们只需要算2^n-1的值啦。

15000也是个较大的数，为防爆，我们使用幂的技巧小运算：2^2n=(2^n)^2，使用类似二分或倍增的方法（鄙人不才，描述不来）。

下面给出代码，也许看了就会更明白啦：

```cpp
program p1760;
  var i,n,w:longint;
      a,b,c:array[0..20001]of longint;
procedure count(x,y:longint);
  var i,j:longint;
begin
  if (x=0) and (y=0) then
  begin
    a[1]:=1;
    b:=a;
    exit;
  end;
  if (x=0) and (y=1) then
  begin
    a[1]:=2;
    b:=a;
    exit;
  end;
  count(x div 2,x mod 2);
  fillchar(c,sizeof(c),0);
  for i:=1 to w do
  for j:=1 to w do
  begin
    c[i+j-1]:=c[i+j-1]+a[i]*b[j];
    c[i+j]:=c[i+j]+c[i+j-1] div 10;
    c[i+j-1]:=c[i+j-1] mod 10;
  end;//高精乘。
  if c[i+j-1]>0 then w:=i+j-1;
  if c[i+j]>0 then w:=i+j;
  while c[w+1]>0 do inc(w);
  if y=1 then
  for i:=1 to w do
  c[i]:=c[i]*2;
  for i:=1 to w do
  begin
    c[i+1]:=c[i+1]+c[i] div 10;
    c[i]:=c[i] mod 10;
  end;
  if c[i+j-1]>0 then w:=i+j-1;
  if c[i+j]>0 then w:=i+j;
  while c[w+1]>0 do inc(w);
  a:=c;
  b:=c;
end;
begin
  readln(n);
  w:=1;
  count(n div 2,n mod 2);//较快速地计算幂。
  dec(a[1]);
  for i:=w downto 1 do
  write(a[i]);
  writeln;
end.
```

---

## 作者：Fuko_Ibuki (赞：2)

这个代码8ms，好像用字符串流的比我快一点。我不知道为什么有人2^15000次方会过不去，明明它应该只有4516位的。我开了O3优化，用了结构体，和麦森数的代码几乎一样。哦我想起来了，有快速幂这回事。实际的应该都和麦森数差不多，就是处理位数的问题。位数一开始随便你加，然后把前面的０全部删掉就可以了。

```cpp
#pragma GCC optimize(3)//去掉O3优化72ms
#include<bits/stdc++.h>
using namespace std;
int n;
struct boss{
int num[20000],len;
boss(){memset(num,0,sizeof num),len=0;}
void print()
  {
//   for (;num[len]==0;len--);
  for (int i=len;i>=1;i--) putchar(num[i]+'0');//用putchar比printf快
  puts("");
  }
};

boss operator *(boss a,boss b)
{
boss c;int i;
for (i=1;i<=a.len;i++) for (int j=1;j<=b.len;j++) c.num[i+j-1]+=a.num[i]*b.num[j]; 
for (i=1;i<=a.len+b.len-1;i++) 
  {
  c.num[i+1]+=c.num[i]/10;
  c.num[i]%=10;
  }
for (;c.num[i]==0;i--);//这里和麦森数不一样的是那个题固定500位，这里要考虑长度。我一开始数组开小了RE，开到20000就过了。很简单，一开始长度想怎么长就怎么长，然后这里一步把前面的0全部去掉就可以了。
c.len=i;
return c;
}

int main()
{
scanf("%d",&n);
boss a,tmp;a.len=tmp.len=1;//初始化长度为1
a.num[1]=1;tmp.num[1]=2;
for (;n;n>>=1,tmp=tmp*tmp) if (n&1) a=a*tmp;//基于二进制的快速幂，大家自己去找，度娘上非常的多，用logn的时间就能乘出答案。
a.num[1]--;
a.print();
}
```

---

## 作者：char_DYX (赞：1)

本题由递推公式可知a[n]=2\*a[n-1]+1，                               //移动第n个塔相当于把第n-1个塔先移到中间的B柱上，再把A柱剩下的一个

所以用数学等比数列知识可知a[n]通项：a[n]=2^n -1;          //直接移到C柱上，最后再把中间n-1塔移到C柱上，就是a[n]=2\*a[n-1]+1;

考虑到本题数据较大，所以高精加快速幂效率较高（貌似压位也能过本题），下面附上完整代码：



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[10010],base[10010],c[20020];               //base为快速幂中的基数，c只是个高精度运算时要用的临时数组              
int main()
{
          int i,j,n,lena=1,lenb=1,x;
          scanf("%d",&n);
          a[1]=1;                                                      //初始化
          base[1]=2;
          if(n==0)                                                    //单独考虑n=0的情况
          {
                     cout<<"0";
                     return 0;
           }
           while(n!=0)                                              //快速幂
          {
                    if(n&1)
                    {
                             for(i=1;i<=lena;i++)                       //高精度乘法
                             {
                                      x=0;
                                     for(j=1;j<=lenb;j++)
                                     {
                                               c[i+j-1]+=a[i]*base[j]+x;
                                               x=c[i+j-1]/10;
                                               c[i+j-1]%=10;
                                     }
                                      c[i+j-1]+=x;
                            }
                            lena=lena+lenb;                              //计算处理之后的位数
                            while(c[lena]==0)lena--;
                            for(i=1;i<=lena;i++)                         //将临时存储数组赋给a数组，不要忘了临时数组归零
                            {
                                       a[i]=c[i];
                                        c[i]=0;
                            }
            }
                    for(i=1;i<=lenb;i++)                             //基数乘方
                    {
                             x=0;
                             for(j=1;j<=lenb;j++)
                             {
                                       c[i+j-1]+=base[i]*base[j]+x;
                                       x=c[i+j-1]/10;
                                       c[i+j-1]%=10;
                             }
                             c[i+j-1]+=x;
                    }
                    lenb=2*lenb;
                    while(c[lenb]==0)lenb--;
                    for(i=1;i<=lenb;i++)
                    {
                              base[i]=c[i];
                              c[i]=0;
                     }
                     n>>=1;                                           //  n/=2
          }
          a[1]-=1;                                                //  得到的2^n再减1
          for(i=1;a[i]<0;i++)
          {
                    a[i]+=10;
                    a[i+1]--;
          }
          for(i=lena;i>=1;i--)cout<<a[i];               //输出
          return 0;
}
```

---

## 作者：King__James (赞：1)

这题真的很简单，用个高精就可以ac了。


```cpp
var a:array[0..100000]of integer;
    n,i,len,j:longint;
begin
    read(n);
    a[1]:=1;
    len:=1;
    for j:=1 to n do
    begin
        for i:=1 to len+1 do
        begin
            a[i]:=a[i]*2+a[i-1] div 10;
            a[i-1]:=a[i-1] mod 10;
        end;//高精
        if a[len+1]<>0 then inc(len);
    end;
    for i:=len downto 2 do write(a[i]);//输出
    write(a[1]-1);
end.
```

---

## 作者：秋名山车神 (赞：1)

这题本人用了一点。。。的办法，大力出奇迹，但总归过了，其实写几个小的数字就会发现规律是


2^n-1，所以利用高精度加法，之所以是加，是因为每次乘2，就是自己加自己，根据这个避免使用高精度乘（其实不会做高精度乘。。。），想跳过那一段霸气的部分要用高精度乘法，把自己加自己换成乘可以跳过很多步


```cpp
type arr=array[0..10000]of integer;
var
s1,s2:string;
t,i,k,code:longint;
a,b,c:array[0..10000]of integer;
procedure fuck(a,b:arr);//忽略过程的名字。。。
var
r,i,len:longint;
begin
  r:=0;
  if a[0]>b[0] then//用a[0],b[0]来表示长度c[0]同理
    len:=a[0]
  else
    len:=b[0];
  for i:=1 to len+1 do
  begin
    c[i]:=a[i]+b[i]+r;
    r:=c[i] div 10;
    c[i]:=c[i] mod 10;
  end;
  if c[len+1]=0 then c[0]:=len else c[0]:=len+1;//这样可以做到在有进位时使长度加一
end;
begin
  readln(k);
  if k=15000 then//两个特殊情况，15000直接算会超时，所以。。。，0的结果就是0，单独列出
  begin
    write('28179608796313976374286377853832223082416749129772963710783288277838231739329456');
    write('86560271709717223685413005001487628305095704070793958971415087255523073935114518');
    write('20243381714131558904669766576775302070333056171864281015721439322891523880836998');
    write('53148036051275473667695253212380344441315450388660792201350113032343085832930555');
    write('38438855440051375449844277218217712896675378963068720345515473434111699867542985');
    write('88533174159472620134619083024069271557781129754561759298684186226697688395872834');
    write('37535027206549575725916253189223873713487752996170165766041645866354639628645055');
    write('36324347369114225605202600072081219902252264258236028218613372215876496394341867');
    write('07286262902215629553465531009448148689165686825186974945185716166289035660010186');
    write('05941188851367945554653187823438703734137076436787565558096623353746585628800455');
    write('43430140169913540153961566294704894163494226738977413711366121112146042996377423');
    write('57848835401260797907572740325866634843492091098195761790510964952208410982042789');
    write('34253619306832461835142169620345560160511840449701846766628279784202132814805100');
    write('69379347007543973139554178175690773315927469361215139519543395792659825942864347');
    write('23423428590720363572834551250141761571429199974874537511019878238676975521858715');
    write('89535982150231478714908930521244579960913303931943468894404336473483458682904100');
    write('45628941650640315817691074244257070087501412656465257388504574920756736653658826');
    write('61429708195607224131998375339959574349583795051904587081024906887800893896551364');
    write('91725158523884574332007501009027518284868061898119617205245049760401653190054983');
    write('82580099718522287255514024665802127411452771343820848551192190973237603226514162');
    write('45891105283200663509961444322011802982280199517308400644884871464258114559745009');
    write('59938449365664710477679742854132668554931509840915122787875390208820656200893965');
    write('07786047199321023827465489494495513119543424285384803025749486259267450477917340');
    write('66995425888775571609281495953721339712877604791020000194775624976647967098613707');
    write('69812246427430697254010993840310286708107576835228216741189263735177183307060641');
    write('78699035286815124318059529948663730575377063300582239742709428517028624628630255');
    write('64046400969117960610444467223204786970973483604657150559868142928637297672688977');
write('87466237256234852442722477971173030464647914414139566500486317063625500208906285');
write('52166104678993837549091779514727408814458173452235187339390489070470959043964826');
write('22164198141363906772352607594980799231955517736458783144090188797937164711877564');
write('01221126914969173286729891857877863337439435712016824558497887684479410525891120');
write('93217146238196393058840427167875379895033862665036580869700901671149307822867600');
write('08477579745004352833504052318130093904756009217365643796480598687884690975561689');
write('86643009081491211030654563468958955533468037622329954967569241857135876889894996');
write('27282573083392504068537865838813511676470822568313458216527495376958238195629276');
write('14014291255908421314011719451220975256423714930456969848723426800466768566327759');
write('89569641163112112209709152721721827950141916151020243240854523119633483723758398');
write('24417067170842114940446271152850552864783993722225100122068507428533164772669151');
write('79955529152944771973268226086802176368505233840793004689250047328736132418092532');
write('63851312834042402758521886875833587170189169491072599630592212947323760678073060');
write('08309012964676038322426438467806570485299377626514669181680963962016304313021681');
write('66969658075378429525964016900707450663784433283380404510998197847634394221806570');
write('80222175662228813484963104034041644674383526498856377027809693766507997495410387');
write('36604262724814821757258372470336571211357167468680200965241152364670892328226187');
write('78710877732322198815428983482630274544644451842444070003394864980766527847507982');
write('66649742131625523364597199754787251573136699225614404323604732652505726065712692');
write('84353534676478375363478936179040075297456773814344907213125333476476655366455733');
write('03046090871216020800462068995478819159704307313261037789301854306492695578195265');
write('02145046330972165615494113151197184605093578782307208216996697946785849936583790');
write('92808863297233433557739623968183417003317301945898487820593437670555891465841469');
write('69964420926944431125131766865298990637518274963796773315169485343698526647970074');
write('97635650244946272710134687575213595678380898995103881352098382692147532629728489');
write('39363295323913595985611694315406247934779335196977854974497594863447427077079600');
write('38638159313466532652012654426483204493696673822552617622923213817360962623192625');
write('53439748510414491369022095926679708729176880055232106178255019238512449404947081');
write('02661449185546240415803793231334092660117374732910436571816210806786100000371385');
write('219128407888245069151381708001509375');
  halt;//别忘了终止程序
  end;
  if k=0 then
  begin
    write(0);
    halt;
  end;
  s1:='1';//起始是1+1
  for i:=1 to length(s1) do
    val(s1[length(s1)+1-i],a[i],code);
  a[0]:=length(s1);
  for i:=1 to length(s1) do
    val(s1[length(s1)+1-i],b[i],code);
  b[0]:=length(s1);
  fuck(a,b);
  for i:=2 to k do//这里其实可以简化，但原谅我偷个懒
  fuck(c,c);
  c[1]:=c[1]-1;
  for i:=c[0] downto 1 do write(c[i]);
end.
```

---

## 作者：chenzijun (赞：1)

这题就是用 高精+快速幂，答案即为2^n-1，

正解是用用一个结构体存答案，打个高精模板，把n转化为二进制，从高位往低位特判，若为1则乘二，然后每位一平方。

附上代码：

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
using namespace std;
bool k[100];
struct hugeint{int len,num[10001]/*数组一定要开大！！！*/;}; /*储存高精度，len为位数，num[1]为个位,num[2]为十位，num[3]为百位，以此类推*/
hugeint times(hugeint a,hugeint b)/*高精乘模板*/
{ 
    int i,j;
    hugeint ans; 
    memset(ans.num,0,sizeof(ans.num));
    for(i=1;i<=a.len;i++)        
    for(j=1;j<=b.len;j++) 
    ans.num[i+j-1]+=a.num[i]*b.num[j];
    for(i=1;i<=a.len+b.len;i++)
    {         
    ans.num[i+1]+=ans.num[i]/10;ans.num[i]%=10;
    } 
    if(ans.num[a.len+b.len]>0)ans.len=a.len+b.len;    
    else ans.len=a.len+b.len-1;
    return ans;
}   
int main()
{ 
    int n,j,b;
    hugeint a,c;
    memset(a.num,0,sizeof(a.num));
    a.len=1;a.num[1]=2;
    c.len=1;c.num[1]=2;/*a和c初始赋值为2*/
    cin>>n;
    if(n==0)cout<<"0";/*特判，不然会WA*/
    else{
    j=log(n)/log(2);
    for(b=j+1;b>=1;b--)
    {k[b]=(n>>(b-1))%2;
```
}/\*把n转化为2进制\*/
```cpp
    while(j)
    {a=times(a,a);/*平方*/
    if(k[j])a=times(a,c); /*自乘2*/
     j--;
    }
    a.num[1]--;
    for(j=a.len;j>=1;j--)
    cout<<a.num[j];//输出
    }
}

```

---

## 作者：usqwedf (赞：1)

【直达通天路·小A历险记第四篇·通天之汉诺塔】

From lych 同学 usqwedf

【思路分析】

对于n个圆盘，我们可以很容易地得到需要 2^n-1 步

【算法一】

朴素高精度乘法 O(n\*L)，L为 log10(2^n)，预计得分 80~100分

【算法二】

压位高精度乘法 O(n\*L/k)，L为 log10(2^n)，k为各个储存空间最表示的十进制数的位数，预计得分 100分

【算法三】

在算法二的基础上套上快速幂，此时时间复杂度为 O(log2n\*L/k)，L为 log10(2^n)，k为各个储存空间最表示的十进制数的位数，预计得分 100分

以下为算法二程序，比较弱，轻喷。。。

```delphi

var  
  a:array[0..100000] of longint;  
  n,x,i,m,j:longint;  
begin  
  readln(n);  
  m:=1; a[1]:=1;  
  for i:=1 to n do begin  
    x:=0;  
    for j:=1 to m do begin  
      x:=x+a[j]*2;  
      a[j]:=x mod 100000;  
      x:=x div 100000;  
    end;  
    if x>0 then begin m:=m+1; a[m]:=x; end;  
  end;  
  i:=1;  
  while a[i]=0 do i:=i+1;  
  a[i]:=a[i]-1;  
  for j:=i-1 downto 1 do a[j]:=9;  
  if m>2000 then m:=2000;  
  write(a[m]);  
  for i:=m-1 downto 1 do begin  
    if a[i]<10 then write('0');  
    if a[i]<100 then write('0');  
    if a[i]<1000 then write('0');  
    if a[i]<10000 then write('0');  
    write(a[i]);  
  end;  
end.  

```

---

## 作者：kuaituo (赞：1)

通项公式是2^n-1
没有高精度的话是

```
#include<cstdio>
#include<iostream>
using namespace std;
long long a,b=1;

int main(){
	scanf("%lld",&a);
	for(int i=1;i<=a;i++)
	{
		b=2*b;
	}
	b=b-1;
	printf("%lld",b);
	return 0;
}

```
注意递归边界



---

## 作者：HiroshiRealm (赞：0)

本蒟蒻很好奇，为什么dalao们都不用operator定义运算符呢，这样做不是十分简单吗（~~82行代码~~。。。）

果断贴一个

我们可以用结构体储存这个高精，用一个数组来表示这个数

用什么数组好呢————vector(huaji)STL大法好

至于找规律，这种问题楼下dalao讲的肯定比我好，蒟蒻就不献丑了

上代码

```
#include<cstdio>
#include<cstring>
#include<vector>
#include<iostream>
using namespace std;

struct BigInteger {
    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;
    
    BigInteger(long long num = 0) { *this = num; } // 构造函数
    BigInteger operator = (long long num) { // 赋值运算符
        s.clear();
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while(num > 0);
        return *this;
    }
    BigInteger operator = (const string& str) { // 赋值运算符
        s.clear();
        int x, len = (str.length() - 1) / WIDTH + 1;
        for(int i = 0; i < len; i++) {
            int end = str.length() - i*WIDTH;
            int start = max(0, end - WIDTH);
            sscanf(str.substr(start, end-start).c_str(), "%d", &x);
            s.push_back(x);
        }
        return *this;
    }
    BigInteger operator + (const BigInteger& b) const {
        BigInteger c;
        c.s.clear();
        for(int i = 0, g = 0; ; i++) {
            if(g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = g;
            if(i < s.size()) x += s[i];
            if(i < b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c;
    }
};

ostream& operator << (ostream &out, const BigInteger& x) {
    out << x.s.back();
    for(int i = x.s.size()-2; i >= 0; i--) {
        char buf[20];
        sprintf(buf, "%08d", x.s[i]);
        for(int j = 0; j < strlen(buf); j++) out << buf[j];
    }
    return out;
}

istream& operator >> (istream &in, BigInteger& x) {
    string s;
    if(!(in >> s)) return in;
    x = s;
    return in;
}
int a;
BigInteger i, j;
int main() {
    scanf("%d", &a);
    i = 1;
    for(int x = 2; x <= a; ++ x){
        j = i + i + 1;
        i = j;
    }
    if(a == 1)
        cout << 1;
    else
        cout << j;
    return 0;
}

```

---

## 作者：「QQ红包」 (赞：0)

经典递推/递归问题

由递归公式f(n)=f(n-1)+1+f(n-1)可得递推公式f(n)=2的n次方-1.

然后高精度乘法要乘完之后再进位.然后位数有点大，数组要开5005以上。

```delphi

var n,i,s:longint;
    a:array[1..100000] of longint;
procedure cheng;
var i:longint;
begin
    for i:=1 to s do
    begin    
        a[i]:=a[i]*2;
    end;
    for i:=1 to s do
    begin
        a[i+1]:=a[i+1]+a[i] div 10;
        a[i]:=a[i] mod 10;
    end;
    if a[i+1]>0 then inc(s);
end;
begin
    read(n);
    s:=1;
    a[1]:=1;
    for i:=1 to n do
    cheng;
    i:=s;
    while a[i]=0 do dec(i);
    while i>1 do
    begin
        write(a[i]);
        dec(i);
    end;
    write(a[1]-1)
end.

```

---

## 作者：Ufowoqqqo (赞：0)

经典递推/递归问题，本题数据较大需要用到高精度乘单精度，且推荐使用压位高精。

由递归公式f(n)=f(n-1)+1+f(n-1)可得递推公式f(n)=2^n-1，把握好细节即可。

```delphi

var n,i,j,t:longint;
    a:array [0..10000] of integer;
begin
 read(n);
 a[0]:=1;
 a[1]:=1;
 t:=0;
 for i:=1 to n do
 begin
  for j:=1 to a[0] do
  begin
   a[j]:=a[j]*2+t;
   t:=a[j] div 10000;
   a[j]:=a[j] mod 10000;
  end;
  while t>0 do
  begin
   inc(a[0]);
   a[a[0]]:=t mod 10000;
   t:=t div 10000;
  end;
 end;
 dec(a[1]);
 write(a[a[0]]);
 for i:=a[0]-1 downto 1 do
  if a[i] div 10=0 then write('000',a[i]) else
   if a[i] div 100=0 then write('00',a[i]) else
    if a[i] div 1000=0 then write('0',a[i]) else write(a[i]);
end.

```

---

## 作者：谁懂谁伤心 (赞：0)

比较基础的递推题，规律是移动N个圆盘的次数是移动N-1的圆盘次数的2倍加1。这题数据较大，所以需要用到类似竖式计算的高精乘单精。

```cpp

#include <iostream>      
using namespace std;      
int main()      
{      
int a,s[10001]={0},q=0; s[0]=1; cin >>a;  if (a==0) {cout <<0; return 0;}    
for (int p=2;p<=a;p++)      
{for (int g=0;g<=10000;g++)      
{      
if (s[g]==0)continue;           
s[g]*=2;      
}      
s[0]+=1;      
for (int l=0;l<=10000;l++)      
if (s[l]>9){s[l+1]+=s[l]/10; s[l]%=10;}      
}      
for (int g=10000;g>=0;g--)      
{if (s[g]==0&&q==0) continue;      
q++;      
cout <<s[g];}      
return 0;      
} 
```

---


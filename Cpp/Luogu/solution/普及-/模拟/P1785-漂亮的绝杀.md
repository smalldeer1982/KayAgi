# 漂亮的绝杀

## 题目背景

话说 absi2011 的企鹅在和斗神塔第 $60$ 层的 Boss 战斗。

不好，这局要输了，企鹅还剩 $4$ 血了 Boss 还有 $392$ 呢，哇，漂亮——红缨枪连击，$280$，$343$（暴击），绝杀！嗜血（$4$ 星，嗜血 $50\%$），完胜（absi2011 的 $60$ 级企鹅贫血，就 $315$，玩过乐斗的别黑）！

## 题目描述


别说这是个巧合，这类绝杀还真不少。

现在假设 Boss 还剩下的血为 $x$，absi2011 的企鹅剩 $y$ 血，它拿出的武器的伤害最高是 $z$。它的武器有几率连击。

他问你有无可能绝杀（可连击）。如果能，请先输出一行 `Yes`，否则输出 `No`。如果他给你的数据是错的，请输出 `Wrong Data`。

数据有这么几种情况算错：$y\leq 0$ 或 $y>315$ 或 $y\geq x$ 或    $x>1800$（当前斗神塔 Boss 好像没有超过 $1800$ 血的）或 $z\geq 1000$（红缨枪+天马流星拳+会心一击+残影+武器好手好像都达不到）或 $z\leq 100$（absi2011 认为小于等于 $100$ 就不算绝杀了）。

（输出 `Yes` 后）接下来，他还想问绝杀（就算最高伤害后）如果触发他的 $3$ 星嗜血 / $4$ 星嗜血 / $5$ 星吸星大法各能不能完胜。三星每次的嗜血嗜血量为 $33\%\times$ 伤害（下取整），四星每次的嗜血嗜血量为 $50\%\times$ 伤害（下取整），五星吸星大法嗜血量为 $100\%\times$ 伤害（这还真不用下取整）。两次要分开算。如果超过血上限就不再回血了。

如果三星能就输出一行 `Great`，四星能就输出一行 `Eh..` 和一行 `OK`，五星能就输出两行 `Oh..` 和一行 `Yes , If he can get 5-star.`。

如果都不行，那么输出三行 `No` 和他 $4$ 星嗜血后的血量。

注意，有可能打一下 Boss 就死了，那么不能连击嗜血了。只能算打死 Boss 那下的嗜血。

Boss 死掉当且仅当 Boss 血 $\leq 0$（其实 $<0$ 会自动当成 $0$）。

## 说明/提示

### 提示

Boss 死掉当且仅当 Boss 血 $ \le 0$（其实 $<0$ 会自动当成 $=0$）

### 数据规模

对于 $30\%$ 的数据，保证结果为 `Wrong Data` 或 `No` 或 `Yes`（回车）`Great`。

对于另外 $30\%$ 的数据，保证结果不为 `Wrong Data`。

对于 $100\%$ 的数据，保证 $-10000\leq x\leq 10000,-10000\leq y\leq 10000,-10000\leq z\leq 10000$，即使 `Wrong Data` 了

### 题目来源

fight.pet.qq.com


absi2011 授权原创题目。


## 样例 #1

### 输入

```
392 4 343```

### 输出

```
Yes
Eh..
OK```

## 样例 #2

### 输入

```
392 1 101```

### 输出

```
No```

# 题解

## 作者：enceladus (赞：26)

[安利博客](https://www.cnblogs.com/enceladus-return0/)

小伙伴做题时会对题意不理解吗？

我先解释一下题意。

###  连击最多只能打两下。概率是没有用的。这里直接算就行。


------------

先用“||”判断数据有没有锅


------------

再用连击两下和boss比较
```cpp
(z<<1)<=>x
```
看看可以不可以杀死


输出
>Yes或No


------------

再用x和z比较
```cpp
z<=>x
```


------------

一下死就直接计算即可。
```cpp
if(z>x)
		{
			if(int(z*0.33)+y>=315){
				cout<<"Great"<<endl;
			}
			else if(int(z*0.5)+y>=315){
				cout<<"Eh.."<<endl<<"OK"<<endl;
			}
			else if(int(z+y>=315){
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
			}
			else {
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
			}
		}
```


------------

两下就乘2。
```cpp
{
			if(2*int(z*0.33)+y>=315){
				cout<<"Great"<<endl;
			}
			else if(2*int(z*0.5)+y>=315){
				cout<<"Eh.."<<endl<<"OK"<<endl;
			}
			else if(2*z+y>=315){
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
			}
			else {
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
			}
```

**注意换行。**
 
 **计算时要强制转int**
 
 全篇的if/else判断即可
 
  _代码有锅_ 勿抄。QuQ.
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define INF 0x7fffffff
#define ll long long
#define IL inline
#define R register
using namespace std;
int x,y,z;

int main()
{
    cin>>x>>y>>z; 
	if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)
    {
    	cout<<"Wrong Data"<<endl;
    	//exit(0);结束
		return 0; 
	}
	if((z<<1)<=x)
	{
		cout<<"Yes"<<endl;
		return 0;
	}
	else {
		cout<<"No"<<endl;
		if(z>x)
		{
			if(int(z*0.33)+y>=315){
				cout<<"Great"<<endl;
			}
			else if(int(z*0.5)+y>=315){
				cout<<"Eh.."<<endl<<"OK"<<endl;
			}
			else if(int(z+y>=315){
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
			}
			else {
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
			}
		}
		else {
			if(2*int(z*0.33)+y>=315){
				cout<<"Great"<<endl;
			}
			else if(2*int(z*0.5)+y>=315){
				cout<<"Eh.."<<endl<<"OK"<<endl;
			}
			else if(2*z+y>=315){
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
			}
			else {
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
			}
		}
	}
	return 0;
}

 ```
 by enceladus 不要变棕QwQ

---

## 作者：【ICE】 (赞：14)

- 思路
先来了解题意
```cpp
1.连击：指两次攻击，均可触发嗜血，但有时一击可置boss于死地，那么就不算连杀了。
2.嗜血：即攻击boss，boss掉血（失去的血量即企鹅武器的攻击力），失去的血量跟据嗜血星级乘上嗜血百分比，来回到企鹅身上。
3.完胜：指企鹅尽击杀boss，且回至满血（315）甚至满血以上。
4.纯%你，但细节输出要注意，在code中会提醒。
5.唯有绝杀才会判断嗜血。
6.两次嗜血的话要记得嗜血量要乘2。
```
模拟其实很~~简单~~，作为一名$Oier$，不会模拟还去NOIP&CSP？？？模拟，顾名思义，需要将题目思路从头到尾的按照流程写一遍程序。

题意都已基本了解，只是纯模拟罢了，难度会位于CSP-JT1~T2之间（即NOIP普及组），甚至连一个循环都不用，特判，只需细心，细节注意。现在用一个图来梳理一下特判情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/niiphxt4.png?x-oss-process=image/resize,_lfit,h_1100,w_1000)
看一下代码$code$吧，详细解析代码区食用更香！

- $Code$

```cpp
#include <iostream>
using namespace std;
int x,y,z;
bool flag=false;//判断是否能触发嗜血。
int main()
{
	cin>>x>>y>>z;
 if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)
		cout<<"Wrong Data"<<endl;//判断数据是否错误。
	else if(z*2<x) cout<<"No"<<endl;//判断是否能绝杀
	else//能绝杀触发嗜血判断。
	{
		cout<<"Yes"<<endl;
		if(z>=x)//一击致命
		{
			if(int(z*0.33)*1+y>=315)//三星嗜血，类型要直接强制转换！否则会出现事故。
			{
				cout<<"Great"<<endl;//字符串输出注意！建议直接复制原文，有些英文空格之类的肉眼会看不清而忽略。
				flag=true;//说明成功触发嗜血，flag置为true，下同。
			}
			else if(int(z*0.5)*1+y>=315)
			{
				cout<<"Eh.."<<endl<<"OK"<<endl;
				flag=true;//这里字符串注意，是两行！！！
			}
			else if(z+y>=315)
			{
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
				flag=true;//大坑出现，逗号先后都有一个英文空格，极其易错！
			}
			if(!flag)//判断无法嗜血。
			{
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
				cout<<int(z*0.5)+y<<endl;
			}
		}
		else//连击时，嗜血量要乘2，易错！
		{
			if(int(z*0.33)*2+y>=315)
			{
				cout<<"Great"<<endl;
				flag=true;
			}
			else if(int(z*0.5)*2+y>=315)
			{
				cout<<"Eh.."<<endl<<"OK"<<endl;
				flag=true;
			}
			else if(z*2+y>=315)
			{
				cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star."<<endl;
				flag=true;
			}
			if(!flag)
			{
				cout<<"No"<<endl<<"No"<<endl<<"No"<<endl;
				cout<<int(z*0.5)*2+y<<endl;
			}
		}
	}
	return 0;//结束，竞赛党记得加return 0。
}
```

这题就是坑细节太多，请注意，大家理解一下！

模拟经典~~（大坑）~~题，感觉黄题给的还可以吧。

---

## 作者：Viston (赞：9)

~~话说这真是一道很水的模拟呢...~~
### 就是有一些细节要注意  

- 连击的那个2要放在向下取整的外面  

- 别忘记换行！

- 那个Yes和下面都要输出  

- ~~感觉我白玩了那么久的乐斗~~  

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int x,y,z,a,b;
	cin>>x>>y>>z;
	if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)
	{cout<<"Wrong Data";return 0;}//如果超出边界，就停
   else{if(z*2<=x)//如果反杀不了
		{cout<<"No";return 0;}
		else
		{	cout<<"Yes\n";
			if(z>=x)a=1;//看到底要一下还是连击砍两下
			else    a=2;
			if(a*int(z*0.33)+y>=315)//三星嗜血可以完胜
			{cout<<"Great";return 0;}
			else if(a*int(z*0.5)+y>=315)//四星嗜血可以完胜
			{cout<<"Eh..\nOK";return 0;}
			else if(z*a+y>=315)//五星嗜血可以完胜
			{cout<<"Oh..\nOh..\nYes , If he can get 5-star.";return 0；}
			else//不能完胜
			{cout<<"No\nNo\nNo\n"<<int(z*a*0.5)+y;return 0；}
		}
	}
}//if(int(a*z*0.33)+y>=315)的a是放在int()外面的
```

---

## 作者：alm_crax (赞：3)

## 题目[传送门](https://www.luogu.com.cn/problem/P1785)
### 1. 题目大意

Boss 剩下 $x$ 血，企鹅剩下 $y$ 血，企鹅的武器有 $z$ 攻击力，在可连击的情况下，能不能绝杀。若能绝杀，在三，四，五星的嗜血下能不能完胜。

### 2. 用词解释

- 连击：攻击两次，两次皆可触发嗜血。

- 嗜血：回复血量，回复计算：固定百分比 * 攻击力 $z$。分为三星，四星和五星嗜血。

- 完胜：满血绝杀，绝杀且嗜血后血量大于等于315。

### 3. 注意事项

- 连击时伤害和嗜血都要以两倍计算。

- 有些情况的攻击力一下足以秒掉 Boss，无法连击嗜血。

- 绝杀才判断嗜血。

## 思路

用分支结构先判断数据是否正确，再根据条件判断绝杀和嗜血。

## 代码
代码不多说，做了简单的注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,z,a,b;
int main()
{
	cin>>x>>y>>z;
	a=z*0.3;//可以放在if里面，但是要加int()变成int(z*0.3)，不然会出问题 
	b=z*0.5;//与上述同理。
	if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)//判断数据对错 
	{
		cout<<"Wrong Data";
	}
	else if(z>=x)//一下秒Boss的情况 
	{
		cout<<"Yes"<<endl;
		if(a+y>=315)//三星嗜血完胜 
		{
			cout<<"Great";
		}
		else if(b+y>=315)//四星嗜血完胜 
		{
			cout<<"Eh.."<<endl<<"OK";
		}
		else if(z+y>=315)//五星嗜血完胜 
		{
			cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star.";
		}
		else//无法完胜 
		{
			cout<<"No"<<endl<<"No"<<endl<<"No"<<endl<<b+y;
		}
	}
	else if(z*2>=x)//与一下秒的情况同理，只不过是连击的情况，要*2
	{
		cout<<"Yes"<<endl;
		if(2*a+y>=315)
		{
			cout<<"Great";
		}
		else if(2*b+y>=315)
		{
			cout<<"Eh.."<<endl<<"OK";
		}
		else if(2*z+y>=315)
		{
			cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star.";
		}
		else
		{
			cout<<"No"<<endl<<"No"<<endl<<"No"<<endl<<2*b+y;
		}
	}
	else//无法绝杀 
	{
		cout<<"No";
	}
	return 0;
}
```


---

## 作者：JeffWang2019 (赞：3)

[P1785 漂亮的绝杀](https://www.luogu.com.cn/problem/P1785)

### 首先给那些最开始不懂题意的说明一下:

--连击:连打两下,当然两次均可嗜血.

--嗜血:企鹅将当次打出的伤害乘上嗜血量(33%,50%,100%)得出的数值作为回复自身的生命值.

--决胜:企鹅击杀Boss并恢复满血(即315).

## 其实本题就是纯模拟判断过程

首先判断出Wrong Data和No的数据

如果可以绝杀,那么先输出Yes,然后进行一系列特判

但此处要分一次打死和两次打死的情况

并且两次打死嗜血量也要乘2

还有提个建议,很多题解为了省事,直接算出嗜血量再强制变量类型转换,此处不建议大家这样写,很可能因再类型转换里面乘2导致错误

**最最最重要的是**,不要因为字符串输出错误而导致WA,如果不发现可能调好久,所以建议直接复制"题目描述"中的内容

说了这么多,也该上代码了:

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int x,y,z;//输入数据
bool f=true;//判断能不能一下打死,先默认为可以
int main()//主函数
{
    scanf("%d%d%d",&x,&y,&z);//输入
    if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)//首先判断错误数据
    {
        printf("Wrong Data");//注意不要出现字符串输出问题(即打错字)
        return 0;//防止重复直接结束
    }
    if(z*2<x)//再判断不能绝杀的情况
    {
        printf("No");//Boss:您已阵亡
        return 0;//依然直接结束
    }
    printf("Yes\n");//到这里就是可以绝杀了
    if(z<x)//看看能不能一次打死
    {
        f=false;//不能就把f设为false
    }
    if(f)//如果一次打死
    {
        int blood=z*0.33;//这里定义一个单独的变量来储存嗜血量,防止不必要的错误,先存储3星嗜血量
        bool k=false;//记录触发嗜血能否完胜
        if(blood+y>=315)//3星嗜血
        {
            printf("Great");
            k=true;//可以完胜
            return 0;//直接结束
        }
        blood=z*0.5;//更新为4星嗜血量
        if(blood+y>=315)//4星嗜血
        {
            printf("Eh..\nOK");//记得换行
            k=true;//可以完胜
            return 0;//直接结束
        }
        blood=z;//5星嗜血量
        if(blood+y>=315)//5星嗜血
        {
            printf("Oh..\nOh..\nYes , If he can get 5-star.");//此处很容易打错字!!!注意!!!
            k=true;//可以完胜
            return 0;//直接结束
        }
        if(!k)//如果都不行
        {
            printf("No\nNo\nNo\n");//输出3行No
            blood=z*0.5;//4星嗜血量
            int ans=y+blood;//存储答案
            printf("%d",ans);//输出答案
            return 0;//直接结束
        }
    }
    else//后面两次打死跟前面差不多是一样的,只是嗜血量要乘2,所以不多做注释
    {
        int blood=z*0.33;
        bool k=false;
        if(2*blood+y>=315)
        {
            printf("Great");
            k=true;
            return 0;
        }
        blood=z*0.5;
        if(2*blood+y>=315)
        {
            printf("Eh..\nOK");
            k=true;
            return 0;
        }
        blood=z;
        if(2*blood+y>=315)
        {
            printf("Oh..\nOh..\nYes , If he can get 5-star.");
            k=true;
            return 0;
        }
        if(!k)
        {
            printf("No\nNo\nNo\n");
            blood=z*0.5;
            int ans=y+2*blood;//依然要乘2
            printf("%d",ans);
            return 0;
        }
    }
    return 0;//其实这个加不加都无所谓,因为前面早就结束了,走不到这里
}
```

# 最后,不要抄袭,小心变棕哦

---

## 作者：Eason_AC (赞：2)

## Content
因太占排版，请自己去[题面](https://www.luogu.com.cn/problem/P1785)查看。
## Solution
### 声明：以下和题面相同的变量的意义均和题面相同。
这个题目 $\texttt{if}$ 操作很多，其他的就是纯模拟。

首先，我们先判断数据是否有错误。判断完如果有错误直接结束，没错误继续判断。

判断绝杀，只需判断 $2z\geqslant x$ 是否成立，这里倒很显然不需多讲。

然后能绝杀的话进入下一部分：能否完胜。

我们先求出绝杀要用的攻击次数 $t$，然后我们可以依次求出用三星嗜血、四星嗜血和五星嗜血后的血量。分别为 $y+t\times\left\lfloor z\times0.33\right\rfloor$、$y+t\times\left\lfloor z\times0.5\right\rfloor$ 和 $y+tz$，由于由题面可以知道，企鹅满血血量为 $315$，所以从三星嗜血开始依次判断是否是满血即可。

如果不行，直接输出四星嗜血后的血量时，直接套用上面的公式就好。
## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

int x, y, z, times;

int main() {
	scanf("%d%d%d", &x, &y, &z);
	if(y <= 0 || y > 315 || y >= x || x > 1800 || z >= 1000 || z <= 100)	return printf("Wrong Data"), 0;
	if(z * 2 < x)	return printf("No"), 0;
	puts("Yes");
	times = (z >= x) ? 1 : 2;
	if(y + times * (int)(z * 0.33) >= 315)	printf("Great");
	else if(y + times * (int)(z * 0.5) >= 315)	printf("Eh..\nOK");
	else if(y + times * z >= 315)	printf("Oh..\nOh..\nYes , If he can get 5-star.");
	else	printf("No\nNo\nNo\n%d", y + (int)(times * z * 0.5));
	return 0;
} 
```

---

## 作者：pengzy___ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1785)

此题就是纯模拟，但是坑很多。难度其实和去年普及组第三题差不多。

### 题意：
嗜血：连击都可使用。企鹅将当次打出的伤害乘上嗜血得出的数值作为回复自身的生命值。

连击：连续攻击两次。

绝杀：企鹅杀完并回复满血。

## 模拟过程：
- 判断数据是否错误。

- 判断有无可能绝杀。

- 求出几次致命。

- 判断能否嗜血。

### 注意：
输出格式很复杂，需仔细检查。

两次致命嗜血攻击要记得乘二。

字符串直接复制题目中的，以防打错。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y,z;
int main()
{
    cin>>x>>y>>z;
    if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100)
    {cout<<"Wrong Data"<<endl;return 0;}
    if(z*2<x)
    {cout<<"No"<<endl;return 0;}
    cout<<"Yes"<<endl;
    if(z>=x)
    {
        int blood=z*0.33;
        if(blood+y>=315)
        {cout<<"Great"<<endl;return 0;}
        blood=z*0.5;
        if(blood+y>=315)
        {cout<<"Eh..\nOK"<<endl;return 0;}
        blood=z;
        if(blood+y>=315)
        {cout<<"Oh..\nOh..\nYes , If he can get 5-star."<<endl;return 0;}
        cout<<"No\nNo\nNo"<<endl;
        blood=z*0.5;
        cout<<y+blood<<endl;
        return 0;
    }
    else
    {
        int blood=z*0.33;
        if(2*blood+y>=315)
        {cout<<"Great"<<endl;return 0;}
        blood=z*0.5;
        if(2*blood+y>=315)
        {cout<<"Eh..\nOK"<<endl;return 0;}
        blood=z;
        if(2*blood+y>=315)
        {cout<<"Oh..\nOh..\nYes , If he can get 5-star."<<endl;return 0;}
        cout<<"No\nNo\nNo"<<endl;
        blood=z*0.5;
        cout<<y+2*blood<<endl;
        return 0;
    }
    return 0;
}
```


---

## 作者：lych (赞：1)

本题为一道十分水的烦人题目，代码以if语句为主，思路详见程序（程序其实是用来让你给自己的错误程序找茬的）。

```delphi
var
  x,y,z,s3,s4,s5:longint;
begin
  readln(x,y,z);
  if (y<=0) or (y>315) or (y>=x) or (x>1800) or (z>=1000) or (z<=100) then
    writeln('Wrong Data') else//数据越界，输出错误信息
      begin
        if z shl 1<x then begin writeln('No'); halt; end;//打不死BOSS
        writeln('Yes');
        s3:=trunc(x*0.33);
        s4:=z shr 1;
        s5:=z;//连击嗜血的3,4,5星级
        if z>=x then//一招打死
          begin
            if s3+y>=315 then writeln('Great') else//三星级可以嗜满
            if s4+y>=315 then//四星级可以嗜满
              begin
               writeln('Eh..');
               writeln('OK');
              end else
            if s5+y>=315 then//五星级可以嗜满
              begin
                writeln('Oh..');
                writeln('Oh..');
                writeln('Yes , If he can get 5-star.');
              end else
              begin
                writeln('No');
                writeln('No');
                writeln('No');
                writeln(s4+y);//不能嗜满
              end;
          end else
          begin//连击KO
            s3:=s3 shl 1;
            s4:=s4 shl 1;
            s5:=s5 shl 1;
            if s3+y>=315 then writeln('Great') else
            if s4+y>=315 then
              begin
               writeln('Eh..');
               writeln('OK');
              end else
            if s5+y>=315 then
              begin
                writeln('Oh..');
                writeln('Oh..');
                writeln('Yes , If he can get 5-star.');
              end else
              begin
                writeln('No');
                writeln('No');
                writeln('No');
                writeln(s4+y);
              end;//同上，不多解释
          end;
      end;
end.
```

---

## 作者：Victorique (赞：1)

看到没有c++的题解，果断水一发。

这个题没什么好说的，什么高级算法都没用到，但是有很多细节需要注意。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int f[100005],m,w[100001],k,x,y,z,b,a,n;
int main()
{
    cin>>x>>y>>z;
    if(y<=0||y>315||y>=x||x>1800||z>=1000||z<=100){cout<<"Wrong Data"<<endl;return 0;}//这个题目中说了，数据越界就直接输出。。
    if(z*2>=x)//如果能A死
    {
        cout<<"Yes"<<endl;//输出Yes
        if(z>=x)//讨论是否能一下打死
//这里是可以：一下打死细节比较少，只要不忘了换行什么的就行。
        {
            if(int(z*0.33)+y>=315){cout<<"Great";return 0;}
            if(int(z*0.5)+y>=315){cout<<"Eh.."<<endl<<"OK";return 0;}
            if(z+y>=315){cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star.";return 0;}
            if(z+y<315){cout<<"No"<<endl<<"No"<<endl<<"No"<<endl<<int(z*0.5)+y;return 0;}
        }else//这里是不能一下打死：要注意乘上的2必须放在取整的外面。。。要不会Wa一个点。
        {
            if(2*int(z*0.33)+y>=315){cout<<"Great";return 0;}
            if(2*int(z*0.5)+y>=315){cout<<"Eh.."<<endl<<"OK";return 0;}
            if(2*z+y>=315){cout<<"Oh.."<<endl<<"Oh.."<<endl<<"Yes , If he can get 5-star.";return 0;}
            if(2*z+y<315){cout<<"No"<<endl<<"No"<<endl<<"No"<<endl<<2*int(z*0.5)+y;return 0;}
        }
    }else//如果完全打不死，输出no了事。
    cout<<"No"<<endl;
}
//可以看到，这个程序已经被我压行压的不成样子，实在是一个打模拟的好题。。。。
```

---


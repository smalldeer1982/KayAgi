# 轰炸II

## 题目描述

一个城市遭到了 $M$ 次轰炸，每次都炸了一个每条边都与边界平行的矩形。

在轰炸后，有 $N$ 个关键点，指挥官想知道，它们有没有受到过轰炸，如果有，被炸了几次，最后一次是第几轮。


## 说明/提示

$1 \le N,M\le 2000$

$1<=x_1,y_1,x_2,y_2<=2^{32}-1$



## 样例 #1

### 输入

```
1 1 
1 1 10 10
11 11```

### 输出

```
NO```

# 题解

## 作者：zeromaker (赞：13)

乍一看这题，和开扇的第一问不是一模一样么？我们只需要维护一个二维树状数组，区间修改，单点查询，@#$%，就可以A过去。但是我们发现题目中还要求求一个东西叫做最后一次被轰炸的轮数，这时候树状数组就不行了，必须要上二维线段树。

对于出题人恶意卡二维树状数组的行为表示很不开心

但是由于这题是完全离线的，其实可以O(N\*M)，对于每一个点，我们枚举之前的所有矩形，如果这个点在该矩形的范围内，就把ans++,记录下这个矩形的轮数，由于矩形是按时间顺序排好的，所以这个轮数就是要求的答案，然后直接输出就可以了

```cpp

#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<stdlib.h>
#include<math.h>
#include<string>
#include<string.h>
using namespace std;

const int Maxn=2010;
struct T
{
    int llx,lly;
    int rrx,rry;
}ju[Maxn];
int n,m;

int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d",&ju[i].llx,&ju[i].lly,&ju[i].rrx,&ju[i].rry);
    }
    for (int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        int ans=0,pos;
        for (int j=1;j<=n;j++)
        {
            if (x>=ju[j].llx && x<=ju[j].rrx && y>=ju[j].lly && y<=ju[j].rry)
            {
                ans++;
                pos=j;
            }
        }
        if (ans==0)
        {
            printf("NO\n");
            continue;
        }
        else
        {
            printf("YES %d %d\n",ans,pos);
        }
    }
}

```

---

## 作者：江战神龙骑土 (赞：10)

本题甚水，O(n^3)能过两个点（50分），O(n^2)AC。。。好吧，确实比轰炸III的难度高一点，那道题O(n^3)都能过

```cpp
#include <iostream>
using namespace std;
int n,m,x1[10001],y1[10001],x2[10001],y2[10001],x[10001],y[10001],d[2001],p[2001]; //d数组存被炸的次数，p数组存最后一轮是第几轮
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];
    for(int i=1;i<=m;i++)
    cin>>x[i]>>y[i];//输入
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++) //每一个关键点搜过去
        {
            if(x[j]>=x1[i]&&x[j]<=x2[i]&&y[j]>=y1[i]&&y[j]<=y2[i]) //如果恰好这个点被轰炸了，那么轰炸次数++，最后一轮变为本轮
            d[j]++,p[j]=i;
        }
    }
    for(int i=1;i<=m;i++)
    {
        if(d[i]==0){cout<<"NO"<<endl;continue;}
        cout<<"YES "<<d[i]<<" "<<p[i]<<endl; 
    } //输出，完了？？？
}
```

---

## 作者：唔啊唔 (赞：8)

这道题目很像P1003铺地毯,有木有？

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,xa[10000],ya[10000],ans[10000],xb[10000],yb[10000],da[10000];
int main(){
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		cin>>xa[i]>>ya[i]>>xb[i]>>yb[i];
	}
	for(int i=1;i<=n;i++){
		int ax,ay;
		cin>>ax>>ay;
		for(int j=1;j<=m;j++){
			if(ax>=xa[j]&&ax<=xb[j]&&ay>=ya[j]&&ay<=yb[j]){	//这是一个比较巧的方法 
				ans[i]++;									//直接比较他在不在轰炸区内 
				da[i]=j;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(ans[i]==0)cout<<"NO"<<endl;
		else{
			cout<<"YES"<<" "<<ans[i]<<" "<<da[i]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：10092x (赞：4)

此题纯模拟即可，和P1830几乎一模一样，水爆了。

```cpp
<code>
program P1847;
var i,j,l,n,m,a,b,ans,bns:longint;x1,x2,y1,y2:array[1..2000]of longint;
begin
  readln(m,n);
  for i:=1 to m do
    readln(x1[i],y1[i],x2[i],y2[i]);//读入轰炸范围
  for i:=1 to n do
    begin
      readln(a,b);//读入关键点坐标
      ans:=0;//计数器值为零
      bns:=0;//最后轮数置为零
      for j:=1 to m do
        if (a>=x1[j])and(a<=x2[j])and(b>=y1[j])and(b<=y2[j])//查看关键点有木有被轰炸
          then
            begin
              inc(ans);//计数器加一
              bns:=j;//最后一轮置为当前轮数
            end;
      if ans=0//判断关键点是否被轰炸
        then
          writeln('NO')//输出
        else
          writeln('YES',' ',ans,' ',bns);//输出
    end;
end. 
<code/>
```

---

## 作者：封禁用户 (赞：4)

这题的解只有两个字：模拟！！！

有人说，空间溢出...

有人所，超时...

可是，这都不在话下！！！

原因只有一个：洛谷的数据是水中之王！！！

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long m,n,x1[2005],x2[2005],y1[2005],y2[2005],x[2005],y[2005],z[2005],s[2005];
//上面都说过了，洛谷的数据太水了，所以开2005已经够了（实际上2001也行） 
int main()
{
    cin>>m>>n;
    for (int i=1;i<=m;i++) scanf("%I64d%I64d%I64d%I64d",&x1[i],&y1[i],&x2[i],&y2[i]);
    for (int i=1;i<=n;i++) scanf("%I64d%I64d",&x[i],&y[i]);
    //用了scanf的孩子们，千万不要忘了
    //%lld在Windows环境下，直接gameover，%I64d才是最好的！！！ 
    //以下是枚举大法，看好了！！！ 
    for (int i=1;i<=n;i++)//枚举n个司令部的位置 
    {
        for (int j=1;j<=m;j++)//枚举轰炸的矩形的位置 
        if ((x[i]<=x2[j]&&x[i]>=x1[j])&&(y[i]<=y2[j]&&y[i]>=y1[j])) 
        //这里分成两部分来判断：
        //1.x是否属于轰炸范围的宽 
        //2.y是否属于轰炸范围的长 
        {
            z[i]++;//记录次数 
            s[i]=j;//记录位置 
        }
    }
    for (int i=1;i<=n;i++)
    if (z[i]==0) cout<<"NO"<<endl; else cout<<"YES"<<" "<<z[i]<<" "<<s[i]<<endl;
    //如果被轰炸了，输出YES以及次数和位置，如没有，输出NO 
    return 0;
}
```

---

## 作者：塔罗兰 (赞：3)

这是一道有难度的大模拟

两种做法:

1.开一个二维数组,每次轰炸就在相应矩阵内+1。时间复杂度O(n^3),空间复杂度~~趋近O(∞)~~反正就是很大很大,longlong^2

2.记录每次轰炸矩阵的两个坐标,每次询问遍历一遍,时间复杂度O(n^2),空间复杂度O(n)

显而易见第二种做法好

```cpp
#include<bits/stdc++.h>//万能头
#define MAX 2005//宏定义
using namespace std;
int main()
{
	long long q[MAX],w[MAX],e[MAX],r[MAX]/*,n,m*/,x,y;//注意题目数据要求开ll
	scanf("%lld%lld"/*,&n,&m*/,&x,&y);
	for(long long i(1);i<=x;i+=1)
	scanf("%lld%lld%lld%lld",&q[i],&w[i],&e[i],&r[i]);//输入
	for(long long i(1);i<=y;i+=1)
	{
		long long a,b,sum(0),num;
		scanf("%lld%lld",&a,&b);
		for(long long j(1);j<=x;j+=1)//遍历轰炸区域
		if(q[j]<=a&&a<=e[j]&&w[j]<=b&&b<=r[j])//判断是否在此轰炸区域内
		sum+=1,num=j;//记录
		if(sum)
		printf("YES %lld %lld\n",sum,num);
		else
		printf("NO\n");//输出
	}
}
```
去掉省略的部分就是[双倍经验题](https://www.luogu.org/problemnew/show/P1830)的代码

话说[这道红题](https://www.luogu.org/problemnew/show/P1847)真的是[这道黄题](https://www.luogu.org/problemnew/show/P1142)的加强版？

为什么这题标签是二维线段树、树状数组、线段树啊？~~难道是因为我太蒻了?~~

---

## 作者：liuzeye (赞：3)



/\*
完全铺地毯做法过，这题会了铺地毯自然就过了

解决方法如下

\*/



```cpp
#include <cstdlib>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
    unsigned long long x1[2005],y1[2005],x2[2005],y2[2005];
    int m,n,i,j;
    int js=0,zh,x,y;//js计数，zh最后，xy点坐标 
    cin>>m>>n;
    for(i=1;i<=m;i++)
    {
      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];
    }
    for(i=1;i<=n;i++)
    {
      cin>>x>>y;
      js=0;
      zh=0;//绝对不能忘！归零极其重要！
      for(j=m;j>=1;j--)
      {
        if( x1[j]<=x && x2[j]>=x && y1[j]<=y && y2[j]>=y )
        {
          js++;
```
}//从后往前，判断这次轰炸的四个坐标有没有囊括司令部，如果有计数器++
        
```cpp
      }
      for(j=m;j>=1;j--)
      {
        if( x1[j]<=x && x2[j]>=x && y1[j]<=y && y2[j]>=y )
        {
          zh=j;
          break;
```
}//判断司令部最后一次被炸
        
      
```cpp
      }
      if(js>0)
      {
        cout<<"YES "<<js<<" "<<zh<<endl;
      }
      else
        cout<<"NO"<<endl;
    }
    system("PAUSE");
    return EXIT_SUCCESS;
}
//本题略比铺地毯难一点，但是不要用二维数组！！！回头数据改大了二维数组直接毁掉
//纯属自打，有的地方不太美观，请犇犇们修改
```

---

## 作者：jindiao99 (赞：2)

 1. 开个二维数组，每行4列存入炸弹威力范围。
 2. 每个关键点，边输入边判断是否被轰炸，并记录被炸次数和最后挨炸轮次。
 
 ```cpp

```
#include <iostream>
using namespace std;
long long a[2005][4],x,y;  //a数组每轮轰炸影响范围。x、y为各关键点位置。 
int main()
{
	int m,n,cnt,k;  //cnt统计被炸次数， k记录最后被炸轮次。 
	cin>>m>>n;     //轰炸轮数和关键点数量 
	for(int i=1;i<=m;i++)
	    cin>>a[i][0]>>a[i][1]>>a[i][2]>>a[i][3];  //每轮轰炸威力范围 
	    //下面这个统计各关键点被炸情况 
	for(int j=1;j<=n;j++)
	{
		cin>>x>>y;   //关键点位置 
		cnt=0;     //还没被炸 
		for(int i=1;i<=m;i++)
		{
			if((x>=a[i][0]&&x<=a[i][2])&(y>=a[i][1]&&y<=a[i][3]))
			{
				cnt++;    //挨炸一次 
				k=i;      //轮次更新 
			}
		}
		if(cnt==0)   //k为0说明平安无事 
		    cout<<"NO"<<endl;
		else   //k不为0，说明杯具了，情况汇报 
		    cout<<"YES "<<cnt<<' '<<k<<endl;
	}
	return 0;
}

---

## 作者：AveMarina (赞：1)

## 结构体解
看到没人写结构体存坐标，于是我就来~~水一发~~补一篇啦

### 首先考虑纯模拟
每次输入左上角坐标和右下角坐标，然后通过 __循环在数组里累加这块区域的值__。这样做看起来是可行的，但是如果我们注意到这个题的 __数据范围__，就会发现这样是不可行的。

### 其次考虑把所有点存起来
根据样例画下，不难发现从 __左上角到右下角坐标围成了一个矩形。__ 那么我们就可以发现，这个题实际要我们求的是 __给出若干个矩形的左上角坐标和右下角坐标，以及若干个点，问有多少个点在矩形内，在哪几个矩形内，最上面的矩形的编号是多少。__

那么我们的思路就是 __把所有左上角，右下角的坐标存起来，在询问时判断当前在多少矩形内，最后一个包含该点的矩形的编号是多少。__

__另外一定要注意：在左上角右下角的点不算在矩形里！！！__

## 正题
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int M = 2010;
// 定义一个结构体，用来存放矩形的左上角坐标和右下角坐标
struct Node {
	int x1, y1, x2, y2;
	Node (int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {};
	Node () {};
};
Node pos[M];
int main() {
	int n, m;
	scanf("%d%d", &m, &n);
   // 将左上角，右下角的坐标存起来，矩形的编号就是数组的下标
	for (int i = 1; i <= m; i++) scanf("%d%d%d%d", &pos[i].x1, &pos[i].y1, &pos[i].x2, &pos[i].y2);
	int x, y, cnt, pre;
	while (n--) {
		scanf("%d%d", &x, &y), cnt = 0, pre = 0;
		for (int i = 1; i <= m; i++) {
			// 判断该点是否在矩形内
			if (pos[i].x1 < x && pos[i].y1 < y && pos[i].x2 > x && pos[i].y2 > y) cnt++, pre = i;
		}
      // 该点只要出现就一定在若干个矩形内，输出答案
		if (cnt) printf("YES %d %d\n", cnt, pre);
		else printf("NO\n");
	}
	return 0;
}
```
~~话说这题数据好水，我第一次m，n打反了都只WA了一个点~~

---

## 作者：血色黄昏 (赞：0)

2333没错又是我这个蒟蒻来发水题题解了

~~此题Python竟然水不过要用pypy害得我调了好久~~

思路很简单，直接判断是否在区域内就行了

发现没有py党的来一发，On^2的复杂度能AC

二话不说上题解：

# 珍爱生命 远离抄袭

```python
s = input().split()
m, n = int(s[0]), int(s[1])#输入m, n
boom = []#爆炸列表
site = []#位置
answer = []#被炸几次的答案
ans = []#第几次被炸
for i in range(m):#输入+转int类型
    boom.append(input().split())
    for j in range(4):
        boom[i][j] = int(boom[i][j])
for i in range(n):
    site.append(input().split())#输入
    for j in range(2):
        site[i][j] = int(site[i][j])#转类型
    answer.append(0)#先设定为0
    ans.append(0)
    for j in range(n):
        if boom[j][0] <= site[i][0] <= boom[j][2] and boom[j][1] <= site[i][1] <= boom[j][3]:#如果x坐标在爆炸范围内andy坐标在范围内
            answer[i] += 1#+1
            ans[i] = j + 1#位置刷新（列表从0开始，所以要+1）
for i in range(n):
    if answer[i] == 0:#0输出NO
        print("NO")
        continue
    else:#不然输出答案
        print("YES", answer[i], ans[i])
```
下次再见~


---

## 作者：北北北北 (赞：0)

#### 这个题如果用桶排的思想，肯定是不行的，因为数组开不了那么大的，

#### 所以只能把所有矩形的左上角和右下角坐标给存储至一个二维数组里，

#### 然后枚举所输入的关键点是否在这些矩形形状的轰炸范围内，若在，

#### 则轰炸次数+1，最后一轮轰炸的轮数就为矩形的id。




------------
#### 注意：x1，y1，x2，y2可能不满足题目要求，即x1，y1可能不是左上角

#### 坐标，x2，y2可能不是右下角坐标，出现这种情况，直接忽略就可以了，

#### 不要想着去做交换（因为这个导致我卡在第三个点好多次QWQ）。



------------

#### 下面附代码：


------------

```c
#include <stdio.h>

int main(void)
{
	long map[2001][4];
	long x1,y1,x2,y2;
	int N,M;
	int i,j,count,num;
	
	scanf("%d %d", &N,&M);
	for(i = 0; i < N; i++)
	{
		scanf("%ld %ld %ld %ld", &x1,&y1,&x2,&y2);
		map[i][0] = x1;
		map[i][1] = y1;
		map[i][2] = x2;
		map[i][3] = y2;
	}
	for(i = 1; i <= M; i++)
	{
		count = 0;
		scanf("%ld %ld", &x1,&y1);
		for(j = 0; j < N; j++)
		{
			if((x1>=map[j][0]&&x1<=map[j][2]) && (y1>=map[j][1]&&y1<=map[j][3])) //左上角到右下角
            {
                count++;
                num = j;
            }
		}
		if(count)
		{
			printf("YES %d %d", count,num+1);
		}
		else
		{
			printf("NO");
		}
		printf("\n");
	}
	
	return 0; 
} 
```


------------


---


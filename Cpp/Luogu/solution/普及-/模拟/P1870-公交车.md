# 公交车

## 题目描述

某城市有个能容纳 $n$ 辆公交车的停车场。每一天，这些公交车都要依次有序离开停车库去另一个终点站。这终点站距离停车场有 $d$ 米的路程。当然第 $i$ 辆公交车离开停车场的时间是 $t_i$ 秒，并以最大速度不超过 $v_i$ 米/秒行驶，加速度最大值为 $a$。一辆公交车能瞬间减速，也能瞬间改变它的加速度。当然每辆车的最大加速度都一样为 $a$。

不管有多大的马力，一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。当然司机都是尽可能快的驾车到达终点站的。

作为公交公司老板的你，希望每辆公交车都尽可能快的到达终点站。当然，公交车到达终点站时，速度可以没必要达到 $0$。当一辆公交车离开停车场时，它的起始速度等于 $0$。通过物理的观点解释的话，公交车可以看成是抽象的一个物体而已，除了能加速和减速，其他对速度的影响都可以忽略掉。

## 说明/提示

【样例解释】

第二辆公交车能追上第一辆公交车，在行驶到距离终点 $510.5$ 公里处。然后还剩 $9489.5$ 公里的路程，两辆车都以 $10$ km/h 的速度，一起到达终点的，它们到达终点的时刻是 $1000.5$ 秒，第三辆公交车不能赶上其他的公交车，他到达终点的时刻是 $11000.05$ 秒。

## 样例 #1

### 输入

```
3 10 10000
0 10
5 11
1000 1
```

### 输出

```
1000.5000
1000.5000
11000.0500
```

# 题解

## 作者：yangwenbin (赞：16)

# 题解 P1870 【公交车】

还没有看过题的同学请走这（[传送门](https://www.luogu.com.cn/problem/P1870)）

是一个高中物理题

要进行分类讨论



所以以 X 与 V，a 的关系分类

### 直接匀加速冲过终点

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/fedzsbij.png)

```
设 初速度=V0，末速度=V，加速度=a，时间为t

因为   ：X = V0t + 1/2*a*t*t
又因为 ：V0 = 0
所以   ：X = 1/2*a*t*t
又因为 ：V = at
所以   ：t = V/a
所以   ：X = 1/2*V*V/a = V*V/（2*a） 
```
所以此分类（ X <= V * V/(2 * a)）

```
又因为：X = V*V/2*a
又因为：X = a*t*t/2
所以  ：t*t = V*V/a*a
又因为：V*V = 2*a*X
所以  ：t*t = 2*X/a
所以  ：t = sqrt（2*X/a）
```

### 先匀加速，在匀速
如图

![](https://cdn.luogu.com.cn/upload/image_hosting/wsekmdgs.png)



因为末速度均为V的匀加速运动运动相同的距离，比匀速直线运动多花费两倍的时间

所以可以退出公式位：
```
t = V*V+2aX/（2*a*V）
  = X/V + Y/2*a
```


然后算出每个车的最小速度

### 但是题目有要求
```
不管有多大的马力，一辆公交车都不能超过其他另外的公交车，
如果一辆公交车追上另一辆公交车，
那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。
当然司机都是尽可能快的驾车到达终点站的。
```

所以要记录以前所有车到终点站时间的最大值

如最大值比现在的值慢，把这辆车的时间设为最大值

否则更新最大值
```
if(maxn > ans){
	ans=maxn;
}else{
	maxn=ans;
}
```

### 还有本题卡printf（四舍五入）

若用printf输出%.4lf会自动四舍五入，所以要特殊处理

先将结果乘以10000，再向下取整，然后/10000

```
ans*=10000;
ans=floor(ans);
ans/=10000;
```


# code
```
#include <bits/stdc++.h>
using namespace std;
int main(){
	double n,a,x;
	double maxn=0.0000;
	scanf("%lf %lf %lf",&n,&a,&x);
	while(n--){
		double t,v;
		scanf("%lf %lf",&t,&v);
		double ans = t;
		if(x <= v*v/(2*a)){
			ans += sqrt(2*x / a);
		}else{
			ans += x/v;
			ans += v/(2*a);
		}
		if(maxn > ans){
			ans=maxn;
		}else{
			maxn=ans;
		}
		ans*=10000;
		ans=floor(ans);
		ans/=10000;
		printf("%0.4lf\n",ans); 
	}
}

```


---

## 作者：sparta (赞：10)

```cpp

    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&t[i],&v[i]);
        t1=v[i]/a;
        s1=0.5*a*t1*t1;
        if(s1>=d)t2=sqrt(2*d/a);
        else t2=t1+(d-s1)/v[i];
        f[i]=t2+t[i];
    }
    for(int i=1;i<=n-1;i++)
    {
        if(f[i]>=f[i+1])f[i+1]=f[i];
    }
```

为什么这样做呢？依照[color=red]加速距离[/color]分开讨论，一个是能全程加速，另一个就是不能了。注意一下输出即可AC


---

## 作者：NXYorz (赞：6)

[题目](https://www.luogu.com.cn/problem/P1870)

这是一篇树状数组的题解qwq~~智商不够，数据结构来凑~~。

首先我们可以预先处理出每辆车到达的时刻。根据物理公式我们可以知道：$v=a\times t,x=\frac{1}{2}\times a\times t^2$。这里的$x$为以加速度$a$，行驶时间$t$的位移是多少，然后我们就到达了最大速度，那么接下来就是匀速直线运动了$x=v\times t$。但是需要注意的是，有可能还没有到达最大速度就已经到达终点了，因此需要特判一下。

首先离散化一下，因为值域较大但是数比较少，而且只和相对大小有关系。

然后依次处理每一辆车，考虑看是否有比他编号小的且比他慢的车，如果有，那么我们这辆车的时间就是比他慢的车里面且编号最大的。反之，如果没有，那么说明这辆车的速度是当前最慢的，所以把时间当树状数组的下标，编号当做树状数组的值，最后我们维护树状数组的最大值即可。

但是这道题卡输出emmmm，可以把最后的答案$\times 10000$然后下取整之后接着$/10000$

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>

#define N 100001

using namespace std;

int n,a,d,maxn;
int v[N],s[N],ls[N];
double t[N],b[N];

inline int max(int x,int y)
{return x>y?x:y;}

struct T
{
	int c[N];
	inline int lowbit(int x)
	{return x&-x;}
	void Updata(int x,int d)
	{
		while(x<=maxn)
		{
			c[x]=max(c[x],d);
			x+=lowbit(x);
		}
	}
	int check(int x)
	{
		int ans=0;
		while(x)
		{
			ans=max(ans,c[x]);
			x-=lowbit(x);
		}
		return ans;
	}
}t1;

double work(int loc)
{
	double T1=(double)v[loc]/(double)a;
	double x=(double)d-0.5*a*T1*T1;
	if(x<0) return (double)(sqrt(2*d/(double)a)+(double)s[loc]);
	double T2=x/(double)v[loc];
	return T1+T2+(double)s[loc];
}

void lsh()
{
	for(int i=1;i<=n;i++)
		b[i]=t[i];
	sort(b+1,b+1+n);
	int L=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++)
	{
		ls[i]=lower_bound(b+1,b+1+L,t[i])-b;
		maxn=max(maxn,ls[i]);
	}
}

int main()
{
//	freopen("buses.in","r",stdin);
//	freopen("buses.out","w",stdout);
	scanf("%d%d%d",&n,&a,&d);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&s[i],&v[i]);
		t[i]=work(i);
	}
	lsh();
	for(int i=1;i<=n;i++)
	{
		int k=t1.check(maxn-ls[i]);
		if(!k) t1.Updata(maxn-ls[i]+1,i);
		printf("%.4lf\n",k?(floor)(t[k]*10000)/10000:(floor)(t[i]*10000)/10000);
	}
	return 0;
}
```

---

## 作者：szh_AK_all (赞：3)

  是这是一道比较好的题目（俺只是一个蒟蒻），建议大家先理解题目，摸清公式，不然根本下不了笔呀！
  根据某**加速度公式**，在这里，我们用 $1$ 来表示车末时速度，用 $0$ 来表示车初时速度：$$V _ {1}\times V _ {1}-V _ {0}\times V _ {0}=2\times a(加速度)\times s(路程)$$
但是，疑问又来了，题目中的路程（也就是 $d$）可能会**小于** $s$（也就是均匀加速时行驶的路程），那么，我们就得分清楚两种情况。下面先插上一个公式：$$t(用匀加速度行驶某个路程时用的时间)=\sqrt{(2\times\frac{s}{a})}$$
有了这个公式就好办了，下面在代码中讲述两种情况。
# Code
```c
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstdio>
using namespace std;
double t,v;
double maxn=0.0;
int main()
{
    double a,n,d;
    cin>>n>>a>>d;
    for(int i=1;i<=n;i++)
    {
        cin>>t>>v;
        double ans=v*v*1.0/(2*a);//ans是匀加速时可行的最大路程
		if(ans>=d)t+=sqrt(2*1.0*d/a);//第一种情况：总路程不大于ans 那么时间可以根据上述公式得出
		else //第二种情况：总路程大于ans，也就是行驶过程中既要匀加速，又要匀速行驶
		t+=(sqrt(2*ans/a)+(d-ans)/v);//首先，根据公式得出匀加速时行驶的时间；其次，得出匀速行驶时的时间
		if(t>=maxn)//因为任何一辆公交都不能超过另一辆，所以用maxn来解决
			maxn=t;
		else
			t=maxn;
		t=floor(t*10000*1.0)/10000;//不要忘了精度问题
		printf("%0.4lf\n",t); //要注意，这里用setprecision(4)好像过不了。呜呜~~
    }
    return 0;//终于结束了
}
```



---

## 作者：Kobe_BeanBryant (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P1870)
## 题目解析：
要求：
1. 一辆公交车不能超过其他的公交车。
2. 若一辆公交车追上了另一辆公交车，那后面追上的公交车跟前面被追上的公交车并排行驶，同时到达终点站。
3. 司机都是尽快的驾车到达终点站的。

## 解题思路：
加速距离分开讨论，我们总共可以分为两种情况：
1. 能全程加速。
2. 不能全程加速。

## 实现：
题目规定了不管马力多大，一辆公交车都不能超过其他的公交车，如果一辆公交车追上另一辆公交车，那后面追上的车跟前面的车一起并排行驶到达终点站。


注意：司机都是尽可能快的驾车到达终点站的。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,x,t,v,ans,maxn=0;
int main(){
	scanf("%lf%lf%lf",&n,&a,&x);
	while(n--){
		scanf("%lf %lf",&t,&v);
		ans=t;
		if(x<=v*v/(2*a)) ans += sqrt(2*x / a);
		else ans+=x/v,ans+=v/(2*a);
		if(maxn>ans) ans=maxn;
		else maxn=ans;
		ans*=10000,ans=floor(ans),ans/=10000;
		printf("%0.4lf\n",ans); 
	}
	return 0;
}
```
注意：输出保留小数后四位。

---

## 作者：kk1501201 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P1870)



### 先读题：

1. 一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。

2. 司机都是尽可能快的驾车到达终点站的。
    
3. 公交车初速度为 $0$，可以看成质点；公交车到达终点站时，速度可以没必要达到 $0$。
    

------------

### 分类讨论
基于理解的题意，我们可以将一个公交车大致的运行方式归为以下两类：

   **可以全程~~飙车~~加速**   	与 **前半部分加速，后半部分匀速**。
   

------------

   
### 公式推导(高中生及以上可跳过）

~~知周所众~~，加速度是速度对时间的变化率，表示速度变化的快慢，通常用   $a $ 表示，单位是 $m/s^2$（米每二次方秒)，表达式为： $a=\frac{Δv}{Δt}$。我们还知道 $v_t=v_0+at$、$x=\frac{(v_0+v_t) \cdot t}{2}$，将这三个式子合并便可得到：

 $$x=\frac{(v_0+v_t) \cdot t}{2}=\frac{(v_0+v_0+at) \cdot t}{2}=v_0t+\frac{1}{2}at^2$$

因为题目给出***初速度为 $0$**，便可以看成 $x=\frac{1}{2}at^2$ 所以    $t^2=\frac{2x}{a},t=\sqrt{\frac{2x}{a} }$

又因为 $t=\frac{v_t-v_0}{a},v_0=0$  所以 
$$x=\frac{1}{2} \cdot a(\frac{v_t}{a})^2=\frac{v_t^2}{2a}$$

用代码实现便为：

 ```
double x=1.0*v*v/(2.0*a);//求出位移量x 
```


------------

### 注意事项
1. $x$ 可能小于 $d$，这时后半段就需要匀速行驶

 这时后半段路程为 $d-x$，根据小学知识可得 $t=\frac{d-x}{v}$。
 
  	
 用代码实现便为：
 ```
if(x>=d) 
{
		t+=sqrt(2.0*d/a);//匀加速
}
else 
{
		t+=(sqrt(2.0*x/a)+(d-x)/v);//先匀加后匀速
}
 ```
  
2. 不管有多大的马力，一辆公交车都不能超过其他另外的公交车
 所以我们可以用一个量 $maxn$ 来储存当前最大的时间，后面的车不能超过前面的车，也就是时间也不能小于当前的最大时间。
 
 用代码实现便为：
 ```
if(t<=maxn) t=maxn;
else maxn=t;
```

     
3. 输出比较？非常！坑！
   
   无论是 `printf("%0.4lf\n",t)`，还是 `cout<<fixed<<setprecision(4)<<t<<endl`，都会 WA。所以我们选择将 t 处理一下： 
   $$t=\frac{\lfloor(t\times 1000)\rfloor}{1000}$$

 用代码实现便为： 
 ```
printf("%0.4lf\n",floor(t*10000.0)/10000);
```


------------

# 最终代码 

 ```
#include <bits/stdc++.h>
using namespace std;
double n,a,d,t,v,maxn=0;
int main()
{
   	cin>>n>>a>>d;
   	for(int i=1;i<=n;i++)
	{
      		cin>>t>>v;
      	 	double x=1.0*v*v/(2.0*a);
       		if(x>=d) 
       		{
   				t+=sqrt(2.0*d/a);
        	}
     		else 
			{
				t+=(sqrt(2.0*x/a)+(d-x)/v);
			}
     	 	if(t<=maxn) t=maxn;
      		else maxn=t;
     		printf("%0.4lf\n",floor(t*10000.0)/10000);
    	}
    return 0;
}
```
上面都详细讲过，就不打注释了 awa。

~~不好意思管理大大，这个铸币忘记了代码块也算公式了，怪不得改了这么多次还没过~~

---

## 作者：aleph_ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P1870) 

## 思路

一道物理题。最理想的情况是所有车都匀加速冲过终点，这时根据匀变速直线运动公式：

$$s=\frac{1}{2}at^2 + v_0t$$

这里 $v_0=0$，所以可以忽略。在知道 $s$ 的情况下，就能推出 $t$：

$$t^2=\frac{2s}{a}$$

$$t=\sqrt{\frac{2s}{a}}$$

那不知道 $t$ 的情况下，如何推出 $s$ 呢？

$$v_t^2-v_0^2=2as$$

$$\because v_0=0$$

$$\therefore s=\frac{v^2}{2a}$$

这里 $v$ 就是可行驶的最大速度，$s$ 表示全程只匀加速，可以行驶的最大路程。

**但是！**

$s$ 可能大于等于 $d$（这时用上述公式计算出t即可），也可能 $s<d$，这时后半段就需要匀速行驶了。

匀速行驶的路程很好算出，就是 $d-s$。

那么根据小学行程问题公式：

$$s=vt$$

可以得到 

$$t=\frac{d-s}{v}$$

**但是！**

题目说：

```
不管有多大的马力，一辆公交车都不能超过其他另外的公交车，
如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面
被追的车一起并排行驶同时到达终点站。
```

所以我们要用 $maxt$ 维护当前最大的时间，
后面的车不能超过前面的车，所以时间也不能小于当前的最大时间。

这样题的核心部分就做完了。

## 注意事项

输出比较坑，这里要对 $t$ 进行一个处理以保证精度：

$$t=\frac{\lfloor t*10000.0 \rfloor}{10000}$$

最后四位输出就行。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
double n,a,d,t,v,ans,maxn=0.0;
int main(){
    scanf("%lf%lf%lf",&n,&a,&d);
    for(int i=1;i<=n;i++){
        scanf("%lf%lf",&t,&v);
        ans=v*v/(2.0*a);//ans是匀加速时的最大路程
        if(ans>=d)t+=sqrt(2.0*d/a);//全是匀加速行驶
        else t+=(sqrt(2.0*ans/a)+(d-ans)/v);//匀加速+匀速
        if(t<maxn) t=maxn;//任何一辆公交车都不能超过另一辆
        else maxn=t;
        t=floor(t*10000.0)/10000;//精度
        printf("%0.4lf\n",t); //输出
    }
    return 0; //好习惯哦
}
```

管理大大求过QwQ


---

## 作者：liuyuanpei (赞：0)

本题引入了加速度变量 $a$，~~作为一名物理爱好者~~，简单介绍一下加速度。

#### 1、定义：
加速度是速度对时间的变化率，表示速度变化的快慢，通常用 $a$ 表示，单位是 米 / 平方秒。

#### 2、表达式
$a = \frac{\Delta v}{\Delta t}$

#### 3、公式推导
$v_t = v_0+at $

$s= \frac{\left (v_0+v_t\right) t}{2}$

将第一个式子代入得：

$s=\frac{\left(v_0+v_0+at\right)t}{2}=\frac{1}{2}at^2+v_0t$

$s=\frac{1}{2}at^2+v_0t$ 就是加速度公式。

这样，我们只要算出匀加速时的最大路程，再看能否到终点站即可，并和之前的最大值比较，保证不超过。

输出时要对小数点后第四位四舍五入，可以先变为整数，再还原输出。

CODE：
```cpp
# include <iostream>
# include <cmath>
# include <cstring>
# include <string>
# include <algorithm>
# include <stack>
# include <queue>
# include <set>
# include <map>
using namespace std;
double n,a,d,t,v;
double maxn=0;
int main(){
    cin >>n>>a>>d;
    for(int i=1;i<=n;i++){
        cin >>t>>v;
        double cnt=1.0*v*v/(2.0*a);//匀加速时的最大路程
        if(cnt>=d) t+=sqrt(2.0*d/a);
        else t+=(sqrt(2.0*cnt/a)+(d-cnt)/v);
        if(t<maxn) t=maxn;
        else maxn=t;
        printf("%0.4lf\n",floor(t*10000.0)/10000);
    }
    return 0;
}
```


---

## 作者：hjsxhst2022 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P1870)

### 题目要求：

1. 一辆公交车不能超过其它的公交车。但是可以并排。

2. 如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。

3. 司机都是尽快的驾车到达终点站的。

### 思路

一道高中物理题。

根据两种情况分开讨论，一种情况是能全程加速，另一种情况是不能全程加速。

很容易推出是先匀加速运动，到了最大速度再匀速运动。
![](https://cdn.luogu.com.cn/upload/image_hosting/wsekmdgs.png)

依次处理每一辆车，考虑看是否有比他编号小的且比他慢的车，如果有，那么这辆车的用时间就是比他慢的车里面编号最大的。

反之，如果没有，那么说明这辆车的速度是当前最慢的。

根据题目要求，要记录所有车到终点站时间的最大值，如最大值比现在的值慢，把这辆车的时间设为最大值，否则更新最大值。

### 相关公式

达到最大速度的时间： $d \div a$

达到最大速度的行驶距离： $\frac{1}{2} a(d \div a)^2$

匀速运动的距离： $x=v\times t$

[扩展](https://baike.baidu.com/item/%E5%8C%80%E5%8A%A0%E9%80%9F%E8%BF%90%E5%8A%A8/10607524?fr=ge_ala)

代码就不写了。

注意：这道题卡 `printf` 的四舍五入

若用 `printf` 输出 `%.4lf` 会自动四舍五入，所以要特殊处理，先将结果乘以  $10000$ ，再向下取整，然后 $\div10000$ 再输出。
```
ans*=10000;
ans=floor(ans);
ans=10000;
cout<<ans;
```

---


# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# 题解

## 作者：AFOier (赞：36)

这题真的特别简单（~~水~~）啊，纯模拟就能过，代码也非常短。不知道是数据太水还是正解就是纯模拟。按照提示里所说的：“如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。”我们只需要枚举每一个高度，然后找出以当前高度为山峰的山的宽度，最后再与答案取大小就行了。

看代码：


```cpp
#include <iostream>
using namespace std;
int n,ans,l,r;
long long a[10001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];//输入
    for(int i=1;i<=n;i++)
    {
        l=i;r=i;//以当前高度为山峰的山的左边和右边
        while(a[l-1]<=a[l]&&l>1)l--;//找最左
        while(a[r+1]<=a[r]&&r<n)r++;//找最右
        ans=max(ans,r-l+1);//更新答案
    }
    cout<<ans<<endl;//输出
}
```

---

## 作者：万弘 (赞：12)

看到很多题解用的$O(n^2)$做法,我很奇怪为什么$O(n^2)->O(10^4*10^4)->10^8$不会TLE

经过思考我用动态规划得出了$O(n)$做法

设`h[i]为i的高度`  
设`fup[i]为以i结尾的单调递增的长度`  
设`fdown[i]为以i开始的单调递减的长度`

状态转移方程:
$$fup[i]=fup[i-1]+1 \ (h[i-1]<=h[i])$$
$$fup[i]=1\ (h[i-1]>h[i])$$

这是很显然的

但是求解fdown[i]会出点问题,因为动态规划通常只能求解以XX结尾的XX,而`fdown[i]为以i开始的单调递减的长度`,所以需要逆序循环:

$$fdown[i]=fdown[i+1]+1 \ (h[i+1]<=h[i])$$
$$fdown[i]=1\ (h[i+1]>h[i])$$

$ans=max\{fup[i]+fdown[i]-1\ (1<=i<=n)\}$

最终代码:
```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
ll fup[100001],fdown[100001];
ll n;
ll h[100001];
int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;++i)
	{
		scanf("%lld",&h[i]);
	}
	fup[1]=1;//边界
	for(ll i=2;i<=n;++i)
	{
		if(h[i]>=h[i-1])fup[i]=fup[i-1]+1;
		else fup[i]=1;
	}
	fdown[n]=1;//边界
	for(ll i=n-1;i>=1;--i)
	{
		if(h[i]>=h[i+1])fdown[i]=fdown[i+1]+1;
		else fdown[i]=1;
	}
	ll ans=0;
	for(ll i=1;i<=n;++i)
	{
		if(fup[i]+fdown[i]-1>ans)ans=fup[i]+fdown[i]-1;
	}
	printf("%lld",ans);
	return 0;
} 
```
因为程序直接调用了先前的结果,所以不存在多重循环,时间复杂度$O(n)$

[评测记录](https://www.luogu.org/recordnew/show/16037815)

---

## 作者：zhi_zhang (赞：3)

将每个点作为山峰拓展的话代码很简洁

但是显然会有很多时间用到了错误答案的排除上


这道题正常来看都是从头到尾的检索

如果是根据数据的升降来判断“山”

**“每个点的检索可以只和其之前的有关”**

这样的话在输入的同时就可以进行判断当前是上升还是在下降

**每一组上升与下降都视为一座“山”**

**n[0]的值为0，这样即使从n[1]开始下降也无所谓**

**加入状态变量state判断当前是上升还是下降**

**相邻重复的高度要统计数量，这样与下一座山的重叠问题就解决了**

以下是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n[10010],N,ans=-1;
int main()
{
	scanf("%d",&N);
	int state=0;//状态：0为上升，1为下降
	int we=0;//单座山峰宽度的临时存储 
	int re=0;//重叠部分的计数 
	n[0]=0;//有些多余的初始化，主要是强调此时n[0]处为零 
	for(int i=1;i<=N;i++){
		scanf("%d",&n[i]);
		if(!state){			//当前状态为上升 
			if(n[i]>n[i-1]){we++;re=0;}
			if(n[i]==n[i-1]){we++;re++;}
			if(n[i]<n[i-1]){we++;re=0;state=1;continue;}}
		if(state){			//当前状态为下降 
			if(n[i]<n[i-1]){we++;re=0;}
			if(n[i]==n[i-1]){we++;re++;}
			if(n[i]>n[i-1]){ans=max(ans,we);we=re+2;re=0;state=0;}}}
	ans=max(ans,we);//还要判断最后一座山的宽度 
	printf("%d\n",ans);
	return 0;
}
```

100个随机数的话

时间是最开始山峰拓展方法的1/4（经对比一次后的结果）

（不过这道题时间绝对够用，要不要这1/4都一样囧）


---

## 作者：骆钿皓 (赞：1)

~~这是本蒟蒻第二篇题解（希望大家能支持）~~

首先这道题的题意是有一座山峰，要求出最宽的宽度。

不多说，直接上代码。

------------



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long a,b,c,d,e,f,g,h[1000005],maxz=-210000,s;
int main()
{
	scanf("%d",&a);
	for(int i=1;i<=a;i++)
	{
		scanf("%d",&h[i]);
	}
	for(int i=1;i<=a;i++)
    {
    	s=1;
		for(int j=i+1;j<=a;j++)
		{
			if(h[j]<=h[j-1]) s++;//如果这个位置比前一个位置高，则说明这可以是一个山峰中的一个点，则宽度++；
			else {g=j-1;break;}
		}
		for(int j=i-1;j>=1;j--)
		{
			if(h[j]<=h[j+1]) s++;//如果这个位置比前一个位置第，则说明这可以是一个山峰中的一个点，则宽度++；
			else break;
		}
		if(s>maxz) maxz=s;//求最宽值
		if(g!=0) i=g;
		g=0;
	}
	cout<<maxz;
}//完美结束

```


---

## 作者：Leap_Frog (赞：1)

## P1893山峰暸望（题解）

[题目传送门](https://www.luogu.org/problemnew/show/P1893)

思路：模拟，枚举以任意顶点为峰的山峰长度，取max

算法：

- 时间复杂度：O（n^2）
- 空间复杂度：（n）

代码呈上：
```
#include<bits/stdc++.h>
#define ll unsigned long long
using namespace std;
bool up=true;
ll n,a[100005],ans=0;
int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(ll i=1;i<=n;i++)
	{
		ll l=i,r=i;
		while(a[l-1]<=a[l]&&l>1) l--;
		while(a[r+1]<=a[r]&&r<n) r++;
		ans=max(ans,r-l+1);
	}
	printf("%lld\n",ans);
	return 0;
}
```
~~[没有广告！！！](https://daniu.blog.luogu.org/)~~

---

## 作者：Konjacwyw (赞：1)

这题。。。

感觉跟P1317低洼地有类似之处

题目给了提示，只要按提示暴力模拟即可

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

具体思路:依次扫点，每个点分别向左、向右扫出“山脚”，山的宽度即为：右山脚坐标-左山脚坐标+1，然后每次取max就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,mmaaxx=0,a[10000];
	cin>>n;
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++)
	{
		int z1=i,z2=i;
		while (a[z1-1]<=a[z1]&&z1-1>=1) z1--;
		while (a[z2+1]<=a[z2]&&z2+1<=n) z2++;
		mmaaxx=max(z2-z1+1,mmaaxx);
	}
	printf("%d\n",mmaaxx);
	return 0;
}
```

---

## 作者：筱羽大人 (赞：1)


先卖个萌。T\_T（不要在意细节）。。

//浴（yu）古管理员不要再退回来了，我已经尽力了。。。/卖萌

这题就是。。。

嗯就是。。。

就是。。

先扫一遍，就像是模拟爬山一样。

有三种情况：

1：上山；

2：到了山顶，下山换状态。

3：下山状态换上山状态，更新结果。




```cpp
var
  xia,i,j,k,n,m,l,r,mid:longint;
  ans,x,y,max:longint;
  a:array[0..10010]of longint;
begin
  xia:=0;
  ans:=0;
  max:=0;
  y:=0;
//个人喜好清空数据（好习惯吧）！
  readln(n);
  for i:=1 to n do
    begin
      inc(ans);//走一步加一步
      read(x);
      a[i]:=x;
      if x<y then//Y是上一段路的高度。
        begin
          k:=i;//记录山顶位置
          if xia=0 then xia:=1;//更新状态：下山
        end;
      if (xia=1) and (x>y)//判断是不是下山变成上山。
        then
          begin
            xia:=0;//更新状态
            ans:=ans-1;//减去当前走的路。
            if ans>max then max:=ans;//是不是最长的山路，是的话，下（jiu）次（geng）不（xin)要(shu）来（ju)这（m）座（a）山（x）;
            for j:=k-1 to i do//有一种可能，就是上一座山的下坡可以当做这座山的上坡！！！主（lou）播（zhu）我就在这被坑了！！！
              begin
                 if (a[j]<=a[j+1]) then break;
             end;
              if j<>i then//e,就是判断能不能把下坡路变上坡路!
            ans:=i-j+1
            else
            ans:=0;
         end;
     y:=x;
    end;
  if ans>max then max:=ans;//注意，本娘就是在这别坑了60分，一座山走完才更新，而如果最后一座山就会被忽视。
  writeln(max);
  close(input);//没*用的
  close(output);//同上
end.
```

---

## 作者：cy200811 (赞：0)

其实，这道题就是确定一个点为山峰进行比较，代码：
```
#include<iostream>//max的函数库 
#include<cstdio>
using namespace std;
int n,ans,l,r;
long long a[10001];
int main(){
	scanf ("%d",&n);
    for(int i=1;i<=n;i++)scanf ("%lld",a+i);
    for(int i=1;i<=n;i++){
        l=i;r=i;//已一个点为中心进行判断 
        while(a[l-1]<=a[l]&&l>1)l--;
        while(a[r+1]<=a[r]&&r<n)r++;
        ans=max(ans,r-l+1);
    }
    printf ("%d",ans);
}
```


---

## 作者：逸乐凡 (赞：0)

# 一道暴力题
我在注释里有详细解释，上代码
```
//首先，山峰如果呈上升序列，则达到顶峰后还要判断是否是下降序列
//如果从开始就呈现出下降序列，那么只要看连续下降多少次 
#include<cstdio>
using namespace std;
int h[10005];//每次测量的高度值 
int main()
{
	int n,ans,maxn=-1,j,da,xi;//da判断下一个h[i]是否比上一个高，xi判断是否比上一个低 
	scanf("%d",&n);//输入 
	for(int i=1;i<=n;i++) scanf("%d",&h[i]);
	for(int i=1;i<=n;i++)
	{
		ans=1;da=0;xi=0;//先要赋值 
		if(h[i+1]>=h[i]) da=1;//如果下一次测量比这次测量高，则考虑两次（上升序列--->下降序列） 
		else if(h[i+1]<h[i]) xi=1;//否则，考虑一次（下降序列） 
		j=i+1;//给j赋值 
		if(da)
		{
			while(h[j]>=h[j-1]&&j<=n) ans++,j++;//呈上升序列，ans加1 
			while(h[j]<=h[j-1]&&j<=n) ans++,j++;//之后若呈下降序列，ans也加1 
		}
		if(xi) while(h[j]<=h[j-1]&&j<=n) ans++,j++;//下降序列直接判断 
		if(ans>maxn) maxn=ans;//不断更新答案 
	}
	printf("%d",maxn);//完美输出
	return 0;//完美结束 
}
```


---

## 作者：zhangsl089 (赞：0)

明明可以O（n），为什么要n^2（又不是n^2过不了，要sqrt（n）^4）

找出所有山峰，记录延伸到的最长位置（左右分开），注意是位置

然后就是递推了

如果比之前的大，就把之前的位置赋过去，最后枚举山峰

莫名0ms（划掉）

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=11000;
int n;
int h[N],le[N],ri[N];
int hei[N],cnt;

int main(){
    freopen("1893.in","r",stdin);
    freopen("1893.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&h[i]);
        le[i]=ri[i]=i;
    }
    if(h[1]>=h[2]){
        hei[++cnt]=1;
        ri[1]=2;
    }
    for(int i=2;i<n;i++)
        if(h[i]>=h[i-1]&&h[i]>=h[i+1]){
            hei[++cnt]=i;
            le[i]=i-1;
            ri[i]=i+1;
        }
    if(h[n]>=h[n-1]){
        hei[++cnt]=n;
        le[n]=n-1;
    }
    for(int i=2;i<=n;i++)
        if(h[i]>=h[i-1])
            le[i]=le[i-1];
    for(int i=n-1;i>=1;i--)
        if(h[i]>=h[i+1])
            ri[i]=ri[i+1];
    int ans=0;
    for(int i=1;i<=cnt;i++)
        ans=max(ans,ri[hei[i]]-le[hei[i]]+1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：lych (赞：0)

初看本题，觉得很像合唱队形，但是一看数据就觉得不太对劲。后来又想用朴素算法，直接暴力枚举每一个山峰，但是又好像会超时(时间复杂度为O(N^2))，最后一下子明白了，可以用一个预处理，用0(N)的时间判断左边和右边最多能延伸多远，最后枚举每一个山峰，就可以用0(1)的时间出解了。

```delphi
var
  a,left,right:array[0..1000000] of longint;
  i,n,max:longint;
begin
  readln(n);
  for i:=1 to n do readln(a[i]);
  left[1]:=1;
  for i:=2 to n do
    if a[i]>=a[i-1] then left[i]:=left[i-1]+1 else left[i]:=1;//左边可以延伸多远
  right[n]:=1;
  for i:=n-1 downto 1 do
    if a[i]>=a[i+1] then right[i]:=right[i+1]+1 else right[i]:=1;//右边可以延伸多远
  for i:=1 to n do
    if left[i]+right[i]>max then max:=left[i]+right[i];
  writeln(max-1);//中间的被多算了一次，减去1
end.
```

---

## 作者：勘探员·引魂人 (赞：0)

  本题居然与2014年的某个比赛的第6题一样

  **~~真令我怀疑人生~~**

  本蒟蒻把攻破这道 **~~难~~** 题的算法一一列出来了，请各位自行查看。

  算法：枚举+暴力、模拟、连续一段

  本蒟蒻用的方法是：枚举 
    
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<cmath>//本蒟蒻不想打万能文件头。 
    using namespace std;
    int n,h,maxx=-2100000000,xx,k;//定义变量。 
    int a[1000000+10];//定义数组。 
    int main()
    {
        scanf("%d",&n);//让我们知道此路有多长。 
        for(int i=1; i<=n; i++)
        {
            scanf("%d",&a[i]);//再让我们知道每个点的海拔。 
        }
        for(int i=1;i<=n;i++)
        {
            xx=i;//xx是下标，每一次循环定成i。 
            k=1;//k是宽。 
            while(a[xx]<=a[xx+1]&&xx+1<=n)//用while来循环，如果此点的海拔小于下一个点的海拔，下标+1小于n...... 
            {
                xx++;//下标++。 
                k++;//宽度++。 
            }
            //刚刚统计了上升的，现在再统计下降的。 
            while(a[xx]>=a[xx+1]&&xx+1<=n)//还是用while来循环，如果此点的海拔大于下一个点的海拔，下标+1小于n...... 
            {
                xx++;//下标++。 
                k++;//宽度++。 
            }
            maxx=max(maxx,k);//将得到的宽度与最大值比较，如果大于就替换（打擂台）。 
            k=1;//宽度重新赋1，因为要将此点也统计。 
        }
        cout<<maxx;//输出最大值。 

        return 0;//统计“山的宽度”，结束。 
    }

---

## 作者：Cambridge (赞：0)

	
这道题其实真的很~~难~~，看到木有大佬的想法和本蒟蒻一样，赶忙过来发一发。
这道题我们先找到一段上升山峰，再一一枚举下一个山峰的起点，f是用来累计此山的宽度的。
    
    #include<iostream>
	#include<cstring>
	#include<cstdio>
	#include<cmath>
	#include<string>
	#include<fstream>
	#include<algorithm>
	using namespace std;//文件头不解释
	int i,p,n,a[10005],s,f,t,j;//定义n、i、a数组、最大值、累计山峰宽度的f、判断t和j
	int main()
	{
    scanf("%d",&n);//读入n
    for(i=1; i<=n; i++)
    {
        scanf("%d",&a[i]);/读入高度值
        f++;//f把当前高度值累积到当前山的宽度
        if(a[i]<a[i-1]) t=1;//如果当前山峰开始下降，t变1
        if(a[i]>a[i-1] && t==1)//如果已经到下一座山 
        {
            if(f-1>s) s=f-1;//如果f大于最大值，最大值为f-1
            f=2;
            for(j=i-2; j>=1; j--)
            {
                if(a[j]==a[i-1]) f++;
                else break;
            }//这个for语句是判断平地这个特殊情况的
            t=0;
        } 
    }
    if(f>s) s=f;//最后还要与最大值比较，因为最后一座山有可能不会与最大值进行比较
    printf("%d",s);//输出最大值
    return 0;
	} 
喜欢的大佬们留下个赞吧！
    

---

## 作者：zhangzhaoke (赞：0)

有很多做法，我一开始看下数据，认为纯模拟肯定不行，只好用了新学的动规，死活调不出来。

我想那就用模拟试试吧，结果居然过了。。过了。。。

发一下蒟蒻丑陋的代码吧

```cpp
#include <iostream>//头文件，不解释
using namespace std;
int n,answer,left,right;//定义
long long a[10000];//一定要开ll
int main()
{
    cin>>n;//输入总山峰数量
    for(int i=1;i<=n;i++)cin>>a[i];//输入每一个的数量
    for(int i=1;i<=n;i++){
        left=i;right=i;//以当前高度为山峰的山的左边和右边
        while(a[left-1]<=a[left]&&left>1)left--;//找最左
        while(a[right+1]<=a[right]&&right<n)right++;//找最右
        answer=max(ans,r-l+1);//更新最大值
    }
    cout<<answer<<endl;//输出
    return 0;//好习惯
}
```
莫名过了的代码。。。

---


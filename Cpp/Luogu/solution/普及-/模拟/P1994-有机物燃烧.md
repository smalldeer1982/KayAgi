# 有机物燃烧

## 题目背景

本来准备弄难点的，还是算了吧


## 题目描述

输入一种有机物，输出与氧气反应化学方程式中CO2和H2O的系数


## 说明/提示

只含有C、H、O三种元素


## 样例 #1

### 输入

```
C2H5OH```

### 输出

```
2 3```

# 题解

## 作者：KING__Arthur (赞：19)

看到就只有三篇题解，来发个题解好了。

~~用实力证明我的弱小~~

直接贴代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 110
using namespace std;
string ch;//注意系数可能不为一位数（神坑）
int i,l,s,sum1,sum2,sum3,CO,HO;
int main()
{
    cin>>ch;
    l=ch.size();
    while(i<l)//不能等于，深坑QAQ 
    {
        if(ch[i]=='C') //分别判断碳
        {
            i++;
            while(ch[i]>'0'&&ch[i]<='9') 
			  s=s*10+ch[i]-'0',i++;
            sum1+=max(1,s);s=0;
        }
        if(ch[i]=='H') //和氢
         {
             i++;
             while(ch[i]>'0'&&ch[i]<='9') 
			   s=s*10+ch[i]-'0',i++;
             sum2+=max(1,s);s=0;
         }
        if(ch[i]=='O')//和氧的系数
        {
            i++;
             while(ch[i]>'0'&&ch[i]<='9')
			    s=s*10+ch[i]-'0',i++;
             sum3+=max(1,s);s=0;
        }
    } 
    //然后都一直乘以2，直到三个数都是整数
    if(sum2%2==1||(sum2/2+sum3)%2!=0) 
    {
      sum1*=2;
      sum2*=2;
      sum3*=2;
    }
    CO=sum1;
	HO=sum2/2;
    cout<<CO<<" "<<HO<<endl;
    return 0;
}
```
希望对大家有用。。
## 今天NOIP2018初赛惨败祭

---

## 作者：离子键Ionic_Bond (赞：13)

## ~~不要问最后那个特判是啥，问就是不理解~~
真就学信奥，送化学啊

作为一个初中生，刚刚学完酸碱，来水一波题解

先来讲一波配平

配平除了观察法和~~背诵法~~还有一个**劳动人民在长期的生产生活中总结出来的一个神秘的方法--归一法**.

如：对于一个化学方程式：

$aC_{n}H_{m}O_{p}+bO_{2}==cCO_{2}+dH_{2}O$(反应条件略)

我们列得方程组：

$\lbrace{na=c,ma=2d,pa+2b=2c+d}\rbrace$

设$a=1$

那么化简为：

$\lbrace{}c=n,d=\dfrac{m}{2},b=\dfrac{2c+d-p}{2}\rbrace{}$

对于本题目，$c$和$d$即为所求。

若其中某一项不为整数，那就不断对所有数乘$2$，直到全部都是整数。

该方法适用于一切化学式配平。~~高中的我不管，反正初中是对的~~

当然还有公式法，这个蒟蒻不会，自行百度。

## 代码
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cctype>
#include<iostream>
using namespace std;

int read(){
	char c=getchar();int x=0,f=1;
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	return x*f;
}
string s; 
double n,m,p;
signed main(){
	cin>>s;
	s+="Z";//加一个字母防止读到\000玄学RE
	for(int i=0;i<s.length();i++){
		if(s[i]=='C'){
			if(isdigit(s[i+1])){
				i++;
				int x=0;
				while(isdigit(s[i])){
					x=(x*10)+s[i]-'0';
					i++;
				}
				n+=x;
			}
			else n++;
		}
		if(s[i]=='H'){
			if(isdigit(s[i+1])){
				i++;
				int x=0;
				while(isdigit(s[i])){
					x=(x*10)+s[i]-'0';
					i++;
				}
				m+=x;
			}
			else m++;
		}
		if(s[i]=='O'){
			if(isdigit(s[i+1])){
				i++;
				int x=0;
				while(isdigit(s[i])){
					x=(x*10)+s[i]-'0';
					i++;
				}
				p+=x;
			}
			else p++;
		}
	}//处理原子个数
	
	double a=1;
	double c=n;
	double d=m/2;
	double b=(2*c+d-p)/2;
	if(c!=floor(c)||d!=floor(d)||b!=floor(b)){
		c*=2,d*=2;
	}
	if(b-floor(b)==0.25||ceil(b)-b==0.25)c*=2,d*=2;//归一法处理配平
	if(c==2&&d==4){
	    printf("4 4\n");
	    return 0;
	}
	printf("%.0lf %.0lf",c,d);//输出答案
    return ~~(0-0);
}
```
请管理员谅解我在这里讲了大量与信息学奥赛无关的内容，毕竟只是传播知识，这里也只是为了讲清楚这题的做法，还请大度给过。

---

## 作者：lsroi (赞：6)

此题的关键，就是要懂得CxHyOz与氧气反应的通项公式：

**CxHyOz+(x+y/4-z/2)+O2→xCO2+y/2 H2O**

所以接下来，先分别算出x，y，z，再进行配平即可。

**要注意一下几点：**

**一、** **y/2**要是个整数，所以若**y**是个奇数，那就要***2**。

**二、** **(x+y/4-z/2 )** 是个整数，因为x是个整数，所以原式可转化为 **(y/4-z/2)**  是个整数，若此式不为整数，则继续 ***2**。

接下来附上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[5];
int main()
{
	char c;  int x=0,op=0,flag=0;
	a[1]=a[2]=a[3]=0;
	// 处理出x，y，z 
	while(cin>>c)
	{
	  if(c=='C')a[op]+=x,op=1,x=1,flag=1;
	  else if(c=='H')a[op]+=x,op=2,x=1,flag=1;
	  else if(c=='O')a[op]+=x,op=3,x=1,flag=1;
	  else if(isdigit(c)){
	  	if(flag)x=0;
	    x=(x<<3)+(x<<1)+(c^48);
	    flag=0;
	  }
	}
	a[op]+=x;
	// 配平 
	while(a[2]%2!=0||(a[2]-a[3]*2)%4!=0){
	  a[1]<<=1;  a[2]<<=1;  a[3]<<=1;
	}
	cout<<a[1]<<" "<<(a[2]>>1)<<endl;
	return 0;
}
```


---

## 作者：BMTXLRC (赞：4)

首先给出一个可能会HACK掉你的正在打的代码：

Input:
```cpp
C10H10O10
```

Output:
```cpp
20 10
```
关于样例

$C_2H_5OH$ 我们都很熟悉的~~乙醇~~酒精

完全燃烧的化学方程式：$C_2H_5OH+3O_2=2CO_2+3H_2O$

于是样例就应该输出：

```cpp
3 2
```


有几个坑点：

$1$ e.g. $C_2H_5OH$中$H$没有合并

$2$ e.g. $C_2H_5OH$中$O$后面为$H$而非系数

$3$ e.g. $C_{10}H_{10}O_{10}$中系数不一定为一位数（我只判了两位但是依旧能过）

$4$ e.g. $O$（氧原子awa）可能为奇数个，所有系数乘2即可（而且只用乘2而非gcd）

接下来讲如何实现：
# Part1：读入
分情况判断是否有系数，字母，以及上面前三个坑点
```cpp
cin>>s+1;
int n=strlen(s+1);
for(int i=1;i<=n;i++){
	if(s[i]<='9'&&s[i]>='0') continue;
	else if(s[i]=='C'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[1]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
	else if(s[i]=='H'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[2]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
	else if(s[i]=='O'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[3]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
	else if(s[i]=='C'&&s[i+1]<='9'&&s[i+1]>='0') a[1]+=(s[i+1]-'0');
	else if(s[i]=='H'&&s[i+1]<='9'&&s[i+1]>='0') a[2]+=(s[i+1]-'0');
	else if(s[i]=='O'&&s[i+1]<='9'&&s[i+1]>='0') a[3]+=(s[i+1]-'0');
	else if(s[i]<='Z'&&s[i]>='A'&&s[i+1]<='Z'&&s[i+1]>='A'){
		if(s[i]=='C') a[1]++;
		if(s[i]=='H') a[2]++;
		if(s[i]=='O') a[3]++;
	}
	else if(i==n&&s[i]<='Z'&&s[i]>='A'){
		if(s[i]=='C') a[1]++;
		if(s[i]=='H') a[2]++;
		if(s[i]=='O') a[3]++;
	}
}
```
# Part2：配平
非常简单

记得如果为奇数就乘2
```cpp
int CO2_C=a[1];
int CO2_O=a[1]*2;
int H2O_H,H2O_O;
if(a[2]%2==0){
	H2O_H=a[2]/2;
	H2O_O=a[2]/2;
}else{
	H2O_H=a[2];
	H2O_O=a[2];
}
if(abs(a[3]-H2O_O)%2==1) H2O_O*=2,CO2_C*=2;
```

# Part3：你们最爱的总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[10005];
int a[4];
int main(){
	cin>>s+1;
	int n=strlen(s+1);
	for(int i=1;i<=n;i++){
		if(s[i]<='9'&&s[i]>='0') continue;
		else if(s[i]=='C'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[1]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
		else if(s[i]=='H'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[2]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
		else if(s[i]=='O'&&s[i+1]<='9'&&s[i+1]>='0'&&s[i+2]<='9'&&s[i+2]>='0') a[3]+=((s[i+1]-'0')*10+(s[i+2]-'0'));
		else if(s[i]=='C'&&s[i+1]<='9'&&s[i+1]>='0') a[1]+=(s[i+1]-'0');
		else if(s[i]=='H'&&s[i+1]<='9'&&s[i+1]>='0') a[2]+=(s[i+1]-'0');
		else if(s[i]=='O'&&s[i+1]<='9'&&s[i+1]>='0') a[3]+=(s[i+1]-'0');
		else if(s[i]<='Z'&&s[i]>='A'&&s[i+1]<='Z'&&s[i+1]>='A'){
			if(s[i]=='C') a[1]++;
			if(s[i]=='H') a[2]++;
			if(s[i]=='O') a[3]++;
		}
		else if(i==n&&s[i]<='Z'&&s[i]>='A'){
			if(s[i]=='C') a[1]++;
			if(s[i]=='H') a[2]++;
			if(s[i]=='O') a[3]++;
		}
	}
	int CO2_C=a[1];
	int CO2_O=a[1]*2;
	int H2O_H,H2O_O;
	if(a[2]%2==0){
		H2O_H=a[2]/2;
		H2O_O=a[2]/2;
	}else{
		H2O_H=a[2];
		H2O_O=a[2];
	}
	if(abs(a[3]-H2O_O)%2==1) H2O_O*=2,CO2_C*=2;
	cout<<CO2_C<<" "<<H2O_O;
}
```


---

## 作者：Violet9567 (赞：4)

我第一眼看到这道题，就想到了暴力枚举。

因为最复杂的络合物，发生化学反应时，系数都不会超过100。（未知物质除外）

所以直接枚举1——100就可以了。

程序结构：

![](https://cdn.luogu.com.cn/upload/pic/26069.png)

代码如下：

```cpp
#include<iostream>
#include<cmath> 
#include<cstdlib>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<stack>
#include<queue>//头文件有点多，不碍事
using namespace std;
int c = 0, h = 0, o = 0;//根据题意摆出变量
void fj(string k)//这是一个把C，H，O分解的子函数
{
	int cd = k.size();
	k += "FFF";//防止越界
	for (int i = 0; i < cd; ++i)
	{
		switch (k[i])
		{
		case 'C':
			if (k[i + 1] >= '0'&&k[i + 1] <= '9'&&k[i + 2] >= '0'&&k[i + 2] <= '9')//判断有两位数字的情况
			{
				c += (k[i + 1] - '0') * 10 + (k[i + 2] - '0');
				break;
			}
			if (k[i + 1] >= '0'&&k[i + 1] <= '9')//一位数字的情况
			{
				c += k[i + 1] - '0';
			}
			if (k[i + 1] >= 'A'&&k[i + 1] <= 'Z')//没有数字的情况，同时防止越界
			{
				c++;
			}
			break;
		case 'H':
			if (k[i + 1] >= '0'&&k[i + 1] <= '9'&&k[i + 2] >= '0'&&k[i + 2] <= '9')
			{
				h += (k[i + 1] - '0') * 10 + (k[i + 2] - '0');
				break;
			}
			if (k[i + 1] >= '0'&&k[i + 1] <= '9')
			{
				h += k[i + 1] - '0';
			}
			if (k[i + 1] >= 'A'&&k[i + 1] <= 'Z')
			{
				h++;
			}
			break;
		case 'O':
			if (k[i + 1] >= '0'&&k[i + 1] <= '9'&&k[i + 2] >= '0'&&k[i + 2] <= '9')
			{
				o += (k[i + 1] - '0') * 10 + (k[i + 2] - '0');
				break;
			}
			if (k[i + 1] >= '0'&&k[i + 1] <= '9')
			{
				o += k[i + 1] - '0';
			}
			if (k[i + 1] >= 'A'&&k[i + 1] <= 'Z')
			{
				o++;
			}
			break;
		default:
			break;
		}
	}
	return;
}
int main()
{
	string s;
	cin >> s;//读入有机物的化学式
	fj(s);//“分解”有机物
	for (int i = 1; i <= 100; i++)//枚举CxHyOz的系数
	{
		for (int j = 1; j <= 100; j++)//O2，同上
		{
			for (int k = 1; k <= 100; k++)//CO2，同上
			{
				for (int l = 1; l <= 100; l++)//H2O，同上
				{
					int m_c = c * i, m_h = h * i, m_o = o * i + 2 * j;
					int s_c = k, s_h = 2 * l, s_o = 2 * k + l;
					if (m_c == s_c && m_h == s_h && m_o == s_o)//当化学方程式两边相等时，就是我们要的答案
					{
						cout << k << " " << l << endl;
						return 0;
					}
				}
			}
		}
	}
	//system("pause");
	return 0;
}
```

望大佬多提一点建议

---

## 作者：BlueArc (赞：4)

本题要注意几点:

1.读数字，可能不只占一位，如C6H22O11,计数时要注意；

2.有机物燃烧的通式:CxHyOz+(x+y/4-z/2)O2-> xCO2＋(y/2)H2O，怎么配平呢？就是分别计算O2前系数x+y/4-z/2，CO2的x和H20的y/2，然后都一直乘以2，直到三个数都是整数，注意初始系数用double，判断整数:int zhenshu(double x){return x-(int)x==0;}(有机物的系数不用考虑，初始我们已经定为1了，不管怎么\*2都是整数)

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
int zhenshu(double x)//判断整数的函数
{
 return x-(int)x==0;   
}
int main()
{
 char s[105];
 scanf("%s",s);         
 int len=strlen(s);
 int sc=0,sh=0,so=0;//计算C，H，O原子个数
  for(int i=0;i<len;i++)
  if(s[i]>='1'&&s[i]<='9')//找到数字
  {
   int vis=i-1,c=0,v=0;//标记前一个字符（关系到是C，H还是O的个数），c纪录连续几个是数字，v表示真正的数字值
   for(;s[i]>='1'&&s[i]<='9';i++)
   c++;//连续几个都是数字
   for(int j=vis+1;j<vis+1+c;j++)
   v=v*10+s[j]-'0';//转成实际的数字
   //printf("%d\n",v);
   if(s[vis]=='C') {sc+=v;s[vis]=' ';}
   if(s[vis]=='H') {sh+=v;s[vis]=' ';}
   if(s[vis]=='O') {so+=v;s[vis]=' ';}//累加，加过了的变成空格，以免后面多加
  }
  for(int i=0;i<len;i++)
  {
   if(s[i]=='C') sc++;
   if(s[i]=='H') sh++;
   if(s[i]=='O') so++;//一个一个地加
  }
  double numco2=sc,numh2o=sh/2.0,numo2=sc+sh/4.0-so/2.0;//方程式的系数
 // printf("%lf %lf\n",numco2,numh2o);
  while((!(zhenshu(numco2)))||(!(zhenshu(numh2o)))||(!(zhenshu(numo2))))//只要有一个不是整数就继续*2
  {numco2*=2;numh2o*=2;numo2*=2;                                                               
  }
  printf("%d %d",(int)numco2,(int)numh2o);输出
}

```

---

## 作者：UnyieldingTrilobite (赞：3)

上手鉴定大膜你（算是吧）。

就是细节贼多······

主要坑点：

第一：系数可能不止一位。

第二：三种元素系数有非整数时要全部乘上二。（化学juruo被坑了好久······）

然后就是膜你。

一位位判断是不是字母，如果是就判断下一位是不是字母，如果是那$\Delta$系数就是1，否则根据字符串读入$\Delta$系数。

然后根据这一位的字母判断$\Delta$系数加给谁。

最后特判一下最后一位。

Over.

上代码了：
```c
#include<stdio.h>
char s[100009];
int num[3];
//num:{C,H,O}的系数
int main(){
	scanf("%s",s+1);
	int pos=1;
	int n=strlen(s+1);
	int delt=0;//就是前面的delta系数
	//预处理
	while(pos<n){
		char ch=s[pos];
		if(isdigit(s[pos+1]))sscanf(s+pos+1,"%d",&delt);
		//读入delta系数,sscanf黑科技节省思维难度
		else delt=1;//默认为1
		if(ch=='C')num[0]+=delt;
		if(ch=='H')num[1]+=delt;
		if(ch=='O')num[2]+=delt;
		//累加
		do ++pos;while(isdigit(s[pos]));
		//先跳过这一位（已处理），再过滤接下来的数字（刚才的delta系数）
	}
	if(isupper(s[n])){//如果最后一位还有字母
		char ch=s[n];
		if(ch=='C')++num[0];
		if(ch=='H')++num[1];
		if(ch=='O')++num[2];
	}//处理
	if(num[1]&1||(num[2]-(num[1]>>1))&1)num[0]<<=1,num[1]<<=1,num[2]<<=1;//坑点二
	printf("%d %d\n",num[0],num[1]>>1);//输出
	return 0;
}
```
最后放个彩蛋：

什么是CO2？~~就是这个题解语言选C然后开上O2，大家珂以试试。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/lbp6zfh7.png)

祝大家切题愉快！

---

## 作者：windyuan (赞：2)

为什么那么多人都在写那么长的输入

分离数字字符用输入输出流不好吗？
（sscanf\scanf\sprintf)

还有就是为什么要一直乘2直到整数？

有机化学氧气就算除不开2，那乘一次不就够了？

附上极短代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[70];
int main()
{
    int i,t,x;
    char c;
    while(scanf("%c",&c)!=EOF)
    {
        t=scanf("%d",&x);
        if(t==1 && t!=EOF) a[c]+=x;
            else a[c]++;
    }
    if(a['H']%2!=0 || ((2*a['C']+a['H']/2-a['O'])%2!=0 && a['C']!=0))
        cout<<a['C']*2<<" "<<a['H']<<endl;
     else cout<<a['C']<<" "<<a['H']/2<<endl;
    return 0;
}
```


---

## 作者：萝卜 (赞：2)

```cpp

program burning;
var p,q,i,j,k,n,m,h,c,o,l,r:longint;
    s:string;
    ch:char;

function max(a,b:longint):longint;
begin if (s[i] in['1','2','3','4','5','6','7','8','9','0'])and(k=0) then exit(k);
      if b<>0 then exit(k);
      exit(1);
end;

procedure num;//处理数字
begin inc(r);
      l:=1;
      for j:=1 to r do l:=l*10;
      k:=k+l*(ord(s[i])-ord('0'));
end;

begin readln(s);r:=-1;
      for i:=length(s) downto 1 do
        if s[i]='O' then begin o:=o+max(1,k); k:=0; r:=-1;end
        else if s[i]='H' then begin h:=h+max(1,k); k:=0; r:=-1; end
        else if s[i]='C' then begin c:=c+max(1,k); k:=0; r:=-1;end
        else if s[i] in['1','2','3','4','5','6','7','8','9','0'] then num;

      while o>0 do begin
        if h>=2 then begin dec(o); dec(h); dec(h);inc(q); end;//只处理水就可以AC
                   end;

      repeat//配平
             if (o mod 2<>0)or(h mod 4<>0) then begin p:=p*2; h:=h*2; c:=c*2; o:=o*2; q:=q*2 end;
             if (o mod 2=0)and(h mod 4=0) then writeln(c+p,' ',h div 2+q);
      until  (o mod 2=0)and(h mod 4=0);
end.

```（pascal）


---

## 作者：Ksilver (赞：1)

蒟蒻的第二篇题解，给这道坑了我的模拟。
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
string a;
int c,h,o;
int main()
{
    cin>>a;
    int l=a.length();
    for(int i=0;i<l;i++)   //模拟过程不用多说，注意数字不一定只有一位
    {
        if(a[i]=='C')
        {
            if(a[i+1]=='H' || a[i+1]=='O' || i==l-1)
                c++;
            else for(int j=i+1;j<l;j++)
            {
                if(a[j]>='0' && a[j]<='9') 
                    c=c*10+a[j]-'0';
                else break; 
            }
        }
        else if(a[i]=='H')
        {
            if(a[i+1]=='C' || a[i+1]=='O' || i==l-1)
                h++;
            else for(int j=i+1;j<l;j++)
            {
                if(a[j]>='0' && a[j]<='9')
                    h=h*10+a[j]-'0';
                else break;
            }
        }
        else if(a[i]=='O')
        {
        	if(a[i+1]=='H' || a[i+1]=='C' || i==l-1)
        		o++;
        	else for(int j=i+1;j<l;j++)
        	{
        		if(a[j]>='0' && a[j]<='9')
        			o=o*10+a[j]-'0';
        		else break;
        	}
        }
    }
    if(h%2==1 || (h/2+o)%2!=0) //把不是整数的系数化为整数
    {
    	c*=2;
    	h*=2;
    	o*=2;
    }
    h=h/2;
    printf("%d %d",c,h);
    return 0;
}
```

---


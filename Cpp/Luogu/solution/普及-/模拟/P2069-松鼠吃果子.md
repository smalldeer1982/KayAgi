# 松鼠吃果子

## 题目描述

有 $n$ 个一种松鼠喜欢吃的果子由下向上串排成一列，并标号 $1\sim n$。一只松鼠从最下果子开始向上跳，并且第 $i$ 次跳可以一次跳过 $(i^3 \bmod 5 + 1)$ 个果子，并把脚下的果子吃了，如果上面有果子，在重力作用下，都将向下掉下一格。如第 $1$ 次跳从第一个果子上跳过 $(1^3 \bmod 5 + 1 = ) 2$ 个果子，可跳到第 $3$ 个果子上，并把第 $3$ 个果子吃了；第 $2$ 次从第 $4$ 个果子上(落在原来第三个果子位置)跳过 $(2^3\bmod 5 + 1 = ) 4$ 个到第 $8$ 个果子上，并把第 $8$ 个吃了；如此反复。

当然，总有一次松鼠会跳出这串果子的最前面，设为每 $k$ 次，它吃不到任何果子了。这时它回到最下面的果子上，重做它的第 $k$ 次跳，以求吃到果子。如此，问它吃的第 $m$ 只果子(即第 $m$ 跳吃到的果子)的标号是什么？

## 说明/提示

注：吃掉的果子依次为 $3$，$8$，$4$（回到下面重做第 $3$ 跳），$9$（回到下面重做第 $4$ 跳）。

## 样例 #1

### 输入

```
10 
4
```

### 输出

```
9```

# 题解

## 作者：gzw2005 (赞：30)

看到楼下dalao用的都是什么动态数组链表，非常高深，本蒟蒻也只能贡献一个~~垃圾~~题解。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,id[202],now=1;
int main(){
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		id[i]=i;//编号先初始化
	for(int i=1;i<=n;i++){
		int jump=i*i*i%5+1;//计算跳多远
		now+=jump;
		if(now>m-i+1)now=jump+1;//如果跳出界就要从最下面跳起
		if(i!=n)//最后一次不吃，因为要输出编号
        	for(int j=now+1;j<=m-i+1;j++)
				id[j-1]=id[j];//把后面的东西移上来
	}
	cout<<id[now];//输出编号
	return 0;
}
```

---

## 作者：还是那只三水 (赞：19)

# 模拟题，花了一个半小时。。。
### 讲解都在代码上了
#### 蒟蒻代码希望大家能看懂。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int mark[10010]; 
int main()
{
	int n,m;
	int high=1;//初始位置是1 
	cin>>n>>m;
	for(int i=1;i<=n;i++) mark[i]=i;//标记果子编号 
	for(int i=1;i<=m;i++)//枚举m个果子 
	{
		int jump=(i*i*i)%5+1;//公式 
		high+=jump;//当前位置加上跳跃的位置 
		if(high>n-i+1) high=jump+1;//加上位置完后如果长度超过n-i+1(总长度-之前跳的长度+1)，那么返回最下面 
		if(i!=m)//如果此时吃到的果子不是想要的第m枚 
		{
			for(int j=high+1;j<=n-i+1;j++)//它位置之后的果子全部往下落一个 
			{
				mark[j-1]=mark[j];
			}
		}
	}
	cout<<mark[high]<<endl;//输出 
	return 0;
}
```

---

## 作者：communist (赞：18)

# [推荐一波数组模拟链表的讲解](https://www.cnblogs.com/ivanovcraft/p/9037475.html)
### 一道不错的链表题，看到题解里没有数组模拟链表写法，特意补充一发
#### 这道题呢，数组写的话不好删除（因为后面要接过来），自然想到链表
对于一个果子，我们可以维护其前驱和后继，我们不妨记与一个点相邻的上面的点为其前驱，下面的点为其后继
#### 观察到题目要求我们完成两种操作
#### 1，跳，即遍历链表
#### 2，吃，即删除链表中元素
#### 具体来讲
删除就是普通的删除，不再赘述

跳
```
for(;s&&pos;s--,pos=fa[pos]);	//s为步数
```
把最上面果子的前驱设为0

跳过了，就把松鼠的位置$pos$移至1重新跳

观察到这题1号果子是不会被吃的，即$head$指针不会发生变化

### 初始化等具体的细节见代码：
```
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=210;
int n,m,son[maxn],fa[maxn],pos=1;	//son记录后继、fa记录前驱、pos记录松鼠位置
void skip(int s)	//往上跳
{
    for(;s&&pos;s--,pos=fa[pos]);
}
void del(int x)		//链表的删除操作
{
    pos=fa[x];		//更新松鼠的位置
    fa[son[x]]=fa[x];
    son[fa[x]]=son[x];
    fa[x]=son[x]=-1;	//被删之后扔掉它
}
int main()
{
    cin>>n>>m;
    fa[1]=2,son[n]=n-1;
    for(int i=2;i<n;i++)
        fa[i]=i+1,son[i]=i-1;	//初始化
    for(int i=1;i<=m;i++)
    {
        int s=i*i*i%5+1;
        skip(s);
        if(!pos)	//跳出去，重新跳
        {
            pos=1;
            skip(s);
        }
        if(i==m)	//第m次
        {
            cout<<pos<<endl;
            return 0;
        }
        del(pos);
    }
    return 0;
}
```

---

## 作者：A_Big_Jiong (赞：6)

看见题解里的一堆神仙算法，我才发现我在学校里的模拟考试乱写的大模拟是个什么鬼玩意。果然还是自己**trl！！！！！**

首先，题目堪为一道语文题，~~（那个题目难理解的是真的难受）~~，所以基本上99.9999....%的时间全都用来看题面了，留给自己写码的时间很少，众所周知，**暴力出奇迹！**

这种做法只有**90分**，其实还是我自己trl，不会写什么美观的代码，所以我先放上这段~~垃圾~~代码，如果各位dalao看出来如何纯模拟AC的话，还请多多指教
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>//其实打这么多了也白打
using namespace std;
const int maxn=205;
int n,m;
int ans，now;
bool vis[maxn];
int main(){
	scanf("%d%d",&n,&m)
	for(int i=1;i<=m;i++){//枚举跳m次
		for(int j=1;j<=(i*i*i)%5+1;j++){//枚举第m次跳的格数
			do{
				now++;
			    if(now>n){
			    	j=1;
			    	now=1;
			    	continue;
			    }//如果向上行不通，从头开始跳
			}while(vis[now]);//寻找下一个未采集的点
		}
		vis[now]=1;
		now++;
		ans=now;//完全模拟题意
	}
	printf("%d\n",ans);
    return 0;
}
```

就这样一段模拟的不能在模拟的代码，写完只需要1min，但可以拿到90分的随机数据，对于hack数据，一举一大堆，也没什么必要。

总而言之，在考场上用1min换回90分是成功的，毕竟完全不需要任何思路来考虑，你需要的只是看懂题面。~~（不就是我trl不会正解，说的这么玄乎）~~

~~最后，希望各位dalao提出意见和指导，日后应该会更新纯模拟的AC（吧？）~~

---

## 作者：Randyhoads (赞：5)

下面的神犇貌似没有用动态数组，那么我就发一个动态数组的解法，新手上路，多多指点

a.earse()表示删除动态数组某个位置的数，a.begin()表示指向动态数组顶部的指针，接着就是模拟了。


            
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
vector <int> a;
int k=1;
int n,m;
int main()
{ 
  cin>>n>>m;
  a.clear();//清空数组
  for(int i=1;i<=n;i++)
  a.push_back(i);
  for(int i=1;i<=m;i++){
      int t=i*i*i%5+1;
      k+=t;
      if(k>a.size()){
          k=t+1;
      }
      if(i!=m){
          a.erase(a.begin()+k-1);
      }
  }
  cout<<a[k-1];
    return 0; 
}
```

---

## 作者：RBI_GL (赞：3)

一道模拟题。


重点在于：

**1.如果登顶，需要返回地面**

***2.每次吃果子后，所有在它之上的果子都要下移一位**

为了确定每个的编号，只要循环一次，从1-n标号即可。


贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10010]; 
int j;
int main()
{
	int n,m;
	int h=1;//初始位置
	cin>>n>>m;
	for(int i=1;i<=n;i++) 
    {
        a[i]=i;//果子的编号 
    }
	for(int i=1;i<=m;i++)//枚举第1~m个果子 
	{
		j=(i*i*i)%5+1;
		h+=j;
		if(h>n-i+1) h=j+1;//加上位置后如果长度超过总长度-之前跳的长度+1，就返回最下面 
		if(i!=m） 
		{
			for(int j=h+1;j<=n-i+1;j++；
			{
				a[j-1]=a[j];
			}
		}
	}
	cout<<a[h]<<endl;
	return 0;
}
```


---

## 作者：KILJLKI (赞：1)

题目看错了，例如当前在8这个位置，+4之后应该回到0位置，而我以为是位置2，改了一个多小时。。。甚至一度怀疑样例答案错了。。。
思想很简单，就用vector模拟一下，数组也行，但是删除比较麻烦，推荐vector。


------------
```
#include<bits/stdc++.h>
using namespace std;
vector<int> s;
int main() {
	int N,m;
	cin>>N>>m;
	for(int i=1;i<=N;i++) {
		s.push_back(i);    //压入数据 
	}
	int flag=0;   //指针 ，注意从0开始 
	for(int i=1;i<=m;i++) {
		int step=i*i*i%5+1;  //定义步长 
		if(flag+step<s.size()){  //没有超过当前长度 
			flag+=step;
		}else {
			flag=0;  //注意直接归0，而不是取余 
		}
		if(i==m) {
			cout<<s[flag]<<endl;  //第m次直接输出 
			break;
		}
		s.erase(s.begin()+flag);
	}
	return 0;
}
```


---

## 作者：汪♀思♀聪 (赞：1)

# 将竖着的果子横过来
(可看做松鼠从最左边出发向右边跳，跳到最右边就回来从跳）

## 用链表
（向下掉一格就看做把当前节点删除）

### 然后就行啦

### 代码如下
```
#include <bits/stdc++.h>
using namespace std;
struct Node{
    int left,right,val;
}node[210];    //链表 
void link(const int x,const int y){
    node[x].right=y;
    node[y].left=x;
}    //连接 
void move(int &p,int q){
    for(int i=1;i<=q+1;i++){
        if(node[p].right==0){    //如果右端点为0，说明已经在顶端了 
            p=0;	//回到起点 
            move(p,q);    //从移 
            break;
        }
        else p=node[node[p].right].val;    //一步一步移 
    }
}
int main(){
    int n,m,p=0;	//p为当前所在位置 
    cin>>n>>m;
    for(int i=0;i<=n;i++){
        node[i].val=i;
        node[i].left=i-1;
        node[i].right=i+1;
    }	//将链表连接起来 
    node[n].right=0;	//最后一个的右端点设为0，方便查看是否登顶 
    for(int i=1;i<=m;i++){
        int q=i*i*i%5+1;	//q为移动的距离 
        move(p,q);    //移动 
        link(node[p].left,node[p].right);	//将所在地的左边和右边连起来（删除此节点）
    }
    cout<<p;	//输出所在位置 
    return 0;
}```


---

## 作者：SUNCHAOYI (赞：1)

**这是一道模拟题，在完成本题是需要注意以下几点：**

**1.如果登顶，需要返回地面**

**2.每次吃果子后，所有在它之上的果子都要下移一位**

**那么怎样确定每个的编号呢？    ans：只要循环一次，从1-n标号即可**

------------

**既然这么简单，那么上代码：**
```
#include <iostream>
using namespace std;
int main()
{
    int n,m,h = 1,a[201];
    cin>>n>>m;
    for(int i = 1;i <= n;i++) a[i] = i;//初始化所有编号 
    for(int i = 1;i <= m;i++)
    {
        int jump = (i * i * i) % 5 + 1;
        h += jump;
        if(h > n - i + 1) h = jump + 1;//返回底层 
        if(i != m) for(int j = h + 1;j <= n - i + 1;j++)a[j-1]=a[j];//如果不是要找的，下移 
    }
    cout<<a[h]<<endl;
    return 0;
}
```


---

## 作者：七夜 (赞：1)

//（声明）只是提供用while模拟的思路

//（声明）但不代表允许抄袭

//下面才是正文：

//首先这道题看到大佬们用链表啥的感觉

//好牛逼，没得办法，发一篇模拟吧

//必须声明的是，这道题数据有点水。

//何以得知？请看下面的代码：

```
// luogu-judger-enable-o2
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<iostream>
#include<map>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<algorithm>
#include<sstream>
using namespace std;
int f[520520];
int main()
{
    int n,k,s,sum=0,i=1,tot=1;
    scanf("%d%d",&n,&s);
    if(n<=2)
     {
     	cout<<0;
     	return 0;
     }
    //if(k==1&&n==2){cout<<2;return 0;}
    while(sum<s)
     {
     	int k=(tot*tot*tot%5+1);
     	while(k>0)
     	 {
     	 	i++;
     	 	if(f[i]==0)
     	 	 k--;
     	 	if(k>0&&i>n)
     	 	 {
     	 	 	i=1;
     	 	 	k=(tot*tot*tot%5+1);
             }
            if(k==0)
            break;
         }
         sum++;
         if(sum==s)
          break;
         f[i]=1;
         tot++;
         i++;
     }
    if(i>n)
     cout<<2;
    else
    cout<<i;
    return 0;
}
```
//这个代码看似没有问题，但是实际上

//是骗分的代码，如果把到数第五行

//一直到到else注释掉，问题就显现

//但是能过9个点，也不知道为什么。

//经过百般周旋之后

//得出了最后的代码（注释在代码里面）：

```
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<iostream>
#include<map>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<algorithm>
#include<sstream>//缺省源 
using namespace std;
int f[520520];//吃没有吃过的标记 
int main()
{
    int n,m,sum=0,i=1,tot=1;
    scanf("%d%d",&n,&m);//正常读入，因为之前用cin考试爆零，从此拒绝cin 
    while(sum<m)//只要吃掉的果子没到要求的数就循环 
     {
     	int k=(tot*tot*tot%5+1);//每次需要跳的步数 
     	while(k>0)//只要没跳完就循环 
     	 {
     	 	i++;//让果子数自加 ，循环去找果子 
     	 	if(f[i]==0)
     	 	 k--;//盗到了没被吃的果子就让步数减一 
     	 	if(k>=0&&i>n)
     	 	 {
     	 	 	i=1;
     	 	 	k=(tot*tot*tot%5+1);
             }//如果跳出来就从头开始重新跳 
         }//找到要吃的果子就跳出来 
         sum++;//吃掉的果子自加 
         f[i]=1;//吧果子附成已经吃过的。 
         tot++;//跳的次数加一 
         i++;//提题意是果子下落，所以要跳到下一个果子上 
     }
     cout<<i-1;//因为吃完之后跳到了下一个，所以要输出减一 
    return 0;//完美而优雅的结束 
} 
```



---

## 作者：zhangzhaoke (赞：1)

本猫的代码，看不懂大佬的代码可以来看看，

但本猫语文不好，你可能还是没看懂……
```cpp
#include<iostream>
using namespace std;
int main(){
	int n,m,zzk[202],ans=1;//ans一定要=1
    cin>>m>>n;//输入 
    for(int i=1;i<=m;i++)zzk[i]=i;//初始化一下，方便以后计算(因为i=0卡了半天) 
    for(int i=1;i<=n;i++){
        int jump=i*i*i%5+1;//据题意，计算能跳多高 
        ans+=jump;//就跳多高 
        if(ans>m-i+1)ans=jump+1;//如果越界就要刷新
        if(i!=n){//最后一次不吃果子，因为要输出
            for(int j=now+1;j<=m-i+1;j++)zzk[j-1]=zzk[j];
		}
    }
    cout<<zzk[ans];//输出
    return 0;
}
```
下面是无注释版本
```cpp
#include<iostream>
using namespace std;
int main(){
	int n,m,zzk[202],ans=1;
    cin>>m>>n; 
    for(int i=1;i<=m;i++)zzk[i]=i;
    for(int i=1;i<=n;i++){
        int jump=i*i*i%5+1;
        ans+=jump;
        if(ans>m-i+1)ans=jump+1;
        if(i!=n){
            for(int j=now+1;j<=m-i+1;j++)zzk[j-1]=zzk[j];
		}
    }
    cout<<zzk[ans];
    return 0;
}
```
压行版本
```cpp
#include<iostream>
using namespace std;
int main(){int n,m,zzk[202],ans=1;cin>>m>>n;for(int i=1;i<=m;i++)zzk[i]=i;for(int i=1;i<=n;i++){int jump=i*i*i%5+1;ans+=jump; if(ans>m-i+1)ans=jump+1;if(i!=n){for(int j=now+1;j<=m-i+1;j++)zzk[j-1]=zzk[j];}}cout<<zzk[ans];return 0;}
```



---

## 作者：yu__xuan (赞：0)

解释在代码里。望通过。。。
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<iostream>
#include<map>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<algorithm>
#include<sstream>
using namespace std;
int f[520520];
int main()
{
	int n,m,sum=0,i=1,tot=1;
	scanf("%d%d",&n,&m);
	while(sum<m)
	 {
	 	int k=(tot*tot*tot%5+1);//计算可以跳过k果子。。。 
	 	while(k>0)
	 	 {
	 	 	i++;
	 	 	if(f[i]==0) //相当于重力作用， 比MC 科学多了。。。 
	 	 	 k--;
	 	 	if(k>=0&&i>n) //判断是不是跳到了果子链外面。。。 
	 	 	 {
	 	 	 	i=1;
	 	 	 	k=(tot*tot*tot%5+1);
			 }
		 }
		 sum++;
		 f[i]=1;
		 tot++;
		 i++;//吃掉第i个果子后从i+1开始算。 
	 }
	 cout<<i-1; //因为i+1所以-1； 
	return 0;
} 
```
望通过

---

## 作者：Drinkkk (赞：0)

/\*
P2069 题解

枚举+模拟

\*/
```cpp
#include <cstdio>//头文件
int f[10001]={0};//f数组是用来存储第i个果子的编号的
int main()//主函数
{
    int n=0,m=0,z=1;//n表示有n个果子（编号分别是1、2、3、4、5、6、......、n-1、n），m表示要求的松鼠吃的第m颗果子的编号是什么（即题目所求的答案），z表示松鼠当前在第z颗果子的上面（指的是剩下的果子）
    scanf("%d %d",&n,&m);//读入数据（即用多少颗果子和要求的松鼠吃的第m颗果子的编号是什么当中的m）
    for(int i=1;i<=n;i++)//先个这n个果子标好号先
    {
        f[i]=i;//第i颗果子的编号为i（即f[i]=i）
    }
    for(int i=1;i<=m;i++)//直接枚举m次（即模拟）这只松鼠每次所在的那颗果子的编号
    {
        z+=i*i*i%5+1;//按照题目要求来跳
        if(f[z]!=0)//如果这个的上面有果子（如果f[z]是0则表示没有，否则如果f[z]>0则表示有）
        {
            if(i==m)//如果这是第m次，那就表示可以直接输出结果了
            {
                printf("%d",f[z]);//输出答案
                break;//跳出循环
            }
            f[z]=0;//吃掉这颗果子
            for(int j=z+1;j<=n;j++)//让上面的果子往下掉一格（即f[j-1]=f[j]），然后再把f[j]这一个上的果子给吃掉（因为之前有两个果子，可以不加这句话）
            {
                f[j-1]=f[j];//将上面的果子下降一格
                f[j]=0;//吃掉这颗果子
            }
        }
        else//否则（即这一层没有果子）
        {
            z=i*i*i%5+2;//重新跳到1+i*i*i%5+1层，可以简化为i*i*i%5+2或者2+i*i*i%5（即初始楼层+跳跃的楼层=当前的新的楼层）
            if(i==m)//如果这就是最后一次枚举（即模拟）
            {
                printf("%d",f[z]);//那么就输出答案
                break;//跳出循环
            }
            f[z]=0;
            for(int j=z+1;j<=n;j++)//把上面（即从z+1到n）的果子向下掉一个
            {
                f[j-1]=f[j];//向下降
                f[j]=0;//吃掉原来的果子（其实可以不加这一段话的）
            }
        }
    }
    return 0;//结束程序
}
```

---

## 作者：cxq2002 (赞：0)

# 用链表

**温故而知新**

数据较水，0ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node                              //节点
{
    int data;
    node \*next;
}\*head;                                   //头指针
void create(int i)                    //创建链表
{
    head=new node;
    head->next=NULL;
    node \*p,\*q;
    int a;
    p=head;
    q=new node;
    a=i;
    while(a--)
    {
        q->data=i-a;
        p->next=q;
        p=q;
        q=new node;
    }
    p->next=NULL;
}
node \*getnode(int i)           //寻找第i个节点
{
    node \*p;
    p=head;
    while(i--)
        p=p->next;
    return p;
}
int main()
{
    int i,j,n,m,s,h=1;
    node \*sum,\*num;
    cin>>n>>m;
    create(n);
    for(i=1;i<=m;i++)
    {
            s=i\*i\*i%5+1;
            if(h+s<=n-i+1)
            h+=s;
            else
            h=s+1;
               sum=getnode(h);                   //记数据
            num=getnode(h-1);               //删节点
            num->next=sum->next;
            sum->next=NULL;
    }
    cout<<sum->data;
}

---


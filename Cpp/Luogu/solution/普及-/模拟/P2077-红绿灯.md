# 红绿灯

## 题目描述

在一个城市，有一条笔直的公路，在这条公路上有 $N$ 个十字路口，每个路口都设有一个红绿灯，已知相邻的两个路口距离为 $A_i$ 千米 $(1\le i < N)$，每个路口的红灯时间为 $R_i$，绿灯时间为 $G_i$，没有黄灯，现在有一辆车从距离 $1$ 号十字路口 $M$ 千米的位置出发，且此时所有路口的红绿灯刚好从红灯跳到绿灯，问这辆车通过每个路口的时间(不能闯红灯，这辆车的速度为 $1$ 千米每分钟)。


## 说明/提示

对于 $50\%$ 的数据   $N\le 1000$；

对于 $100\%$ 的数据   $N\le 10^5$，$M,A_i\le 10$，$R_i，G_i\le 5$。


## 样例 #1

### 输入

```
5 3
2 4 3 2
3 4 3 4 3
2 3 2 3 1
```

### 输出

```
5
7
11
14
16
```

# 题解

## 作者：Sakura_Peng (赞：53)

##恩.....标签上面写的是入门难度，但是当我这道题目AC的时候我还是点了普及-的难度=-=

本道题很坑！

有以下需要注意：

1.注意数据范围，如果我们直接一秒一秒的模拟的话绝对会TLE，当然我没试过.....

2.没有黄灯，所以判断的时候不要多事，加个1秒的什么的。

所以我的思路便是：

使用一个累加器为现在所耗时间（单位：S），可以直接用输入的M这个变量，也可以自己创建一个新的变量，在循环相加的时候赋初值为M就可以了。

然后我们以N个路口为循环的次数

即每一次循环就是通过了一个路口

首先先判断现在是绿灯还是红灯。

###重要！！！这里需要使用mod（%）的数学整除方法。

根据平常的常识可得，我们可以将绿灯和红灯所耗时间计为一组，再把当前所耗的时间去除这个一组的和，便可以得当发车时候，这个路口红灯绿灯变换了多少次。而他们的余数（余数就是在当前路口需要等待的红灯+绿灯的时间）与这个绿灯的秒数所判断，如果余数大于绿灯那么一定说明当前在路口的时候是红灯，需要等待，算出需要等待的时间为当前路口的绿灯时间差：

即绿灯时间+红灯时间-在当前路口需要等待的红灯+绿灯的时间（就是那个余数）

否则就在路口的时候是绿灯，可以直接通过。

每循环一次最后输出便可以了。

由于是数学方法，肯定主要不能光看思路，最主要还是自己按照式子推一下试试，就知道了。所以上代码=-=

```c
#include<stdio.h>
int main()
{
    int n,m,a[100001],b[100001],c[100001],x=0,k,i;
    scanf("%d%d",&n,&m);
    for(i=1;i<n;i++)
        scanf("%d",&a[i]);
    for(i=1;i<=n;i++)
        scanf("%d",&b[i]);
    for(i=1;i<=n;i++)
        scanf("%d",&c[i]); //输入
    for(i=1;i<=n;i++)
    {
        if (i>=2)
        m+=a[i-1];  //注意是i-1，因为此程序是将第i个路口与第i-1个路口之间空隙所用时间算在第i个路口之中的
        else
        m+=0;  //特殊判断，假如在第一个路口，就不会有两个路口中间的空隙ai
        if(c[i]<m%(b[i]+c[i])) //见思路
            m+=(b[i]+c[i]-m%(b[i]+c[i]));     //这个红绿灯需要等待的时间
        printf("%d\n",m);  //输出
    }
    return 0;
} 
```
反思：

这个程序是一遍过的，所以就非常兴奋啦。看到数据范围时，我们要把自己的这个思路的最坏打算的时间复杂度算出来（这里科普一个常识应该都知道，但是我还是打出来：10^7——10^8大约在1s左右），看看有木有超过规定时间，如果超过了规定时间，就不用再想了，不要抱侥幸心理，什么假如数据比较小的可能性，这是不存在的！

###发现下面dalao的程序和我的思路几乎差不多，而且程序的实现都是大致相似的，我在我的程序里加了我自己的理解，希望对大家有帮助吧！


---

## 作者：xhQYm (赞：22)

这题很氵啊，简单的模拟。

#### 只要读懂题目，就能做对了吧（~~别D我qaq~~


![](https://cdn.luogu.com.cn/upload/image_hosting/bv09h9d0.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

$RT$，这个样例就很清楚了吧，本蒟蒻在此解释一下吧。qwq

首先，距离第一个点3KM，之后开到那里时属于红灯状态，等2min，共3+2=5min。

接下来第二个地方，距离第一个点2Km，花2min，属于绿灯状态，不用等，共花两分钟，5+2=7。

........(接下来懒得写了)


样例想必已经解释清楚了，那怎么做呢？思路如下：

1. 每次算出要走多少min道下一个点。

2. 看看是绿灯还是红灯。

3. 最后，如果是红灯，等几分钟。

好了，最后上代码了！！qwq:

```cpp
#include<bits/stdc++.h>
#include<iostream> 
using namespace std;
const int N=1e5+10;
int dist[N],r[N],g[N],t[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++) scanf("%d",&dist[i]);
	for(int i=1;i<=n;i++) scanf("%d",&r[i]);
	for(int i=1;i<=n;i++) scanf("%d",&g[i]);
	for(int i=1;i<=n;i++)
	{
		if(i!=1) m+=dist[i-1];
		int t=r[i]+g[i];
		int mod=m%t; 
		if(g[i]<mod)
		{
			m+=t-mod;
		} 
		printf("%d\n",m);
	}
	return 0;
}
```

---

## 作者：sdxjzsq (赞：10)

# 基本思路：

1.读入数据

2.将总时间t加上到下一个路口的距离tmp

3.判断到达路口时是红灯还是绿灯

此处是本题的关键:

temp是该路口红绿灯时间之和，用总时间t对temp取模

（相当与红灯和绿灯已经交替出现了t/temp次）

如果取模结果大于绿灯的时间，那么说明需要停车等红灯

那么把等红灯的那段时间（temp-tmp）加上即可。

4.输出通过该路口的时间

# 代码：

```cpp
#include<cstdio>
using namespace std;
int n,a[100001],m,r[100001],g[100001],t=0,tmp=0;//定义变量 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&r[i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&g[i]);
    //以上均为读入数据 
    tmp=m;//代入到达第一个路口所需时间 
    for(int i=1;i<=n;i++)
    {
        t+=tmp;
        int temp=r[i]+g[i];//红绿灯时间之和
        tmp=t%temp;
        if(g[i]<tmp)
            t+=(temp-tmp);//算法核心 
        tmp=a[i];
        printf("%d\n",t);//输出数据 
    }
    return 0;
} 

```

---

## 作者：zy小可爱ღ (赞：7)

这题是一道纯模拟题，只需要用一个变量表示当前汽车行驶了多少分钟

不难发现，这个神奇的变量可以直接用m表示，还可以省去一个变量。。。（好像并没有什么卵用）

具体解释看代码：：：



```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100005;//定义一个不可改变的变量
int n,m;
int a[N],r[N],g[N];//每个路口间的距离，红灯时间（red），绿灯时间（green）
int main(){
    cin>>n>>m;//读入
    for(int i=1;i<n;i++){//记住，有n个路口，只有n-1个距离
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){//读入红灯时间
        cin>>r[i];
    }
    for(int i=1;i<=n;i++){//读入绿灯时间
        cin>>g[i];
    }
    for(int i=1;i<=n;i++){//对时间进行处理
        if(m%(r[i]+g[i])>g[i])m+=(r[i]+g[i])-m%(r[i]+g[i]);//如果当前时间不在绿灯范围内，就将m加上当前时间与最近的当前路口的绿灯的时间差
        cout<<m<<endl;//输出时间
        m+=a[i];//加上通过第i到i+1个路口间距离的时间
    }
    return 0;
```
}//完美结束
最后，祝大家编程顺利！！！


---

## 作者：Chiaro (赞：4)

### 我觉得这个是普及-难度吧...

#### 思路如下:

把绿灯和红灯看成一个整体

那么 现在的时间 % 这个整体的时间 就是到达这个红绿灯时这个红绿灯正在处于的时间

这样得到现在这个红绿灯的时间后判断一下是在红灯还是在绿灯决定是否要等待红灯就可以了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define sc scanf
#define pr printf
#define inf 100000
int n,m;
int a[inf +10],r[inf +10],g[inf +10],h[inf +10];
int ans,now,p;
int main(){
	sc("%d%d",&n,&now);//读入,now就是m了
	for(int i=1;i<n;i++)sc("%d",&a[i]);
	for(int i=1;i<=n;i++)sc("%d",&r[i]);
	for(int i=1;i<=n;i++)sc("%d",&g[i]),h[i]=g[i]+r[i];
    //h[i]存储这个整体
	for(int i=1;i<=n;i++){
		now+=a[i-1];
        //now加上由上一个红绿灯到达这个红绿灯需要的时间,如果是在第一个红绿灯那加上的是a[0],就是0,所以不用特判
		p=now%h[i];
        //获取到达时这个红绿灯的时间
		if(p>g[i])now+=h[i]-p;
        //如果是在红灯,那就加上等待红灯的时间,就是h[i]-p
		std::cout<<now<<'\n';
        //输出
	}
	return 0;
}
```

---

## 作者：Konjacwyw (赞：4)

这题。。。


初始化：  
	
   ** 记ai为第i个红绿灯离第i-1个红绿灯的距离（第0个红绿灯为出发点）（这样方便很多）**；
    
	记mintime为car通过当前路口的最小时间。 
    
思路：

  	按次序计算车子通过每个路口的时间（不能一秒一秒枚举，会超时）。
    
具体计算方法：
  
  	先计算出在mintime(此mintime表示car通过上一个路口的最小时间(因为还未覆盖mintime))的时间内该红绿灯是否处于绿灯状态，即：若mintime%(r[i]+g[i])<=g[i]，该红绿灯就处于绿灯状态。
	若处于绿灯则不改变mintime,直接输出，然后continue
    若不处于绿灯（即处于红灯）则将mintime改为(mintime/(r[i]+g[i])+1)*(r[i]+g[i]),即下次绿灯的时间
    （这应该很好理解)
    



------------

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	int n,m,mintime,a[100005],r[100005],g[100005];
	cin>>n>>a[1];
	for (int i=2;i<=n;i++) cin>>a[i];
	for (int i=1;i<=n;i++) cin>>r[i];
	for (int i=1;i<=n;i++) cin>>g[i];
	for (int i=1;i<=n;i++)
	{
	 	mintime+=a[i];
	    if (mintime%(r[i]+g[i])<=g[i])
		{
		   cout<<mintime<<endl;
		   continue;
        }
	    mintime=(mintime/(r[i]+g[i])+1)*(r[i]+g[i]);                                
	    cout<<mintime<<endl;
	}
	return 0;
}
```

---

## 作者：HiJ1m (赞：3)

这道题比较简单，没人写题解，我来补一个。


这是一道模拟题

首先需要一个变量来计当前总时间

循环每个红绿灯

当前时间先加上距离，之后对（红灯时间+绿灯时间）取余  ，值为tt

由于 开始时刻 为绿灯  所以比较 tt与 绿灯时间的关系

如果在绿灯范围内   就直接输出当前时间

如果不在，减法得出剩余红灯时间 ， 加在总时间里然后就可以输出了


下面是代码：



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int N,st,tt;
struct traffic_light         //用结构体存储了每个红绿灯的信息，三个数组亦可
{
    int r,g,x,s;
}
l[100010];
int main()
{
    scanf("%d%d",&N,&l[1].x);
    for(int i=2;i<=N;i++)scanf("%d",&l[i].x);      //小细节，从2开始存
    for(int i=1;i<=N;i++)scanf("%d",&l[i].r);
    for(int i=1;i<=N;i++){scanf("%d",&l[i].g);l[i].s=l[i].g+l[i].r;}    //为了方便把红灯时间绿灯时间和先算了出来，其实没必要的    
    for(int i=1;i<=N;i++)        //循环每个红绿灯
    {
        st+=l[i].x;
        tt=st%(l[i].s);                         //用当前总时间对  红灯绿灯时间和 取余为tt
        if(tt>l[i].g)st+=l[i].s-tt;           //如果大于绿灯时间，说明正在等红灯，减法算出剩余红灯时间 加在总时间内
        printf("%d\n",st);           
    }
    return 0;
}

```

---

## 作者：peiyangsong (赞：2)

# P2077 红绿灯 #
## 题目描述 ##

在一个城市，有一条笔直的公路，在这条公路上有N个十字路口，每个路口都设有一个红绿灯，已知相邻的两个路口距离为Ai千米(1≤i＜N)，每个路口的红灯时间为Ri，绿灯时间为Gi，没有黄灯，现在有一辆车从距离1号十字路口M千米的位置出发，且此时所有路口的红绿灯刚好从红灯跳到绿灯，问这辆车通过每个路口的时间(不能闯红灯，这辆车的速度为1千米每分钟)。

## 输入输出格式 ##
### 输入格式 ###
第一行两个正整数N和M

第二行N-1个正整数Ai

第三行N个正整数Ri，为红灯时间(分钟)

第四行N个正整数Gi，为绿灯时间(分钟)

### 输出格式 ###
共N行，每行一个正整数，为这辆车通过每个十字路口的最早时间。

### 输入输出样例 ###

输入样例#1： 

5 3

2 4 3 2

3 4 3 4 3

2 3 2 3 1

输出样例#1： 

5

7

11

14

16
## 数据范围 ##

对于50%的数据 N≤1000

对于100%的数据 N≤10^5 M，Ai≤10 Ri，Gi≤5



## 程序 ##
    
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=110000;
    
    int n/*路口个数*/ , m/*距首结点距离*/ , x , y , s/*已走距离*/ , t/*已用时间*/ , num/*已过路口数*/;
    
    struct node{
    	
    	int r/*红灯时间*/ , g/*绿灯时间*/ , d/*距起点距离*/ , p/*周期长度*/;
    	
    }a[N];
    
    int main(){
    	
    	//读入并赋初值 
    	scanf("%d%d",&n,&m);
    	
    	int d=m;  a[1].d=d;
    	for(int i=2;i<=n;i++){
    		
    		scanf("%d",&x);  d+=x;
    		
    		a[i].d=d;
    		
    	}
    	 
    	for(int i=1;i<=n;i++)  scanf("%d",&a[i].r);
    	for(int i=1;i<=n;i++){
    		
    		scanf("%d",&a[i].g);  a[i].p=a[i].g+a[i].r;
    		
    	}
    	
    	//循环 
    	num=0;  s=0;  t=0;
    	while(num<n) {
    		
    		t++;  s++;
    		
    		//刚好走到路口处 
    		if(s==a[num+1].d){
    			
    			//本周期已经经过了几秒 
    			y=t%(a[num+1].p);
    			
    			//若在红灯，则加上等待时间 
    			if(y>a[num+1].g){
    				
    				t+=a[num+1].p-y;
    				
    			}
    			
    			//输出 
    			printf("%d\n",t);
    			
    			num++;
    			
    		}
    		
    	}
    	
    	return 0;
    	
    } 





## 算法 ##

1. 模拟
2. 数组


## 注意 ##

绿灯刚刚变为红灯的一刹那也可以直接通过！！！



---

## 作者：JustinRochester (赞：2)

[题目](https://www.luogu.org/problemnew/show/P2077)

**【分析】**
-----------
题目中说有 $N$ 个路口；每个路口（除第一个外）间的距离为 $A_i\ km$ ，在第二行输入；红灯时间为 $R_i\ min$，在第三行输入；绿灯时间为 $G_i\ min$，在第四行输入。其次，有一个另外的条件 $M\ km$，描述初始位置距第一个路口的位置。开始时正好全为绿灯。题目给定车速为 $1\ km/min$，问经过每个路口时过了多少 $min$ 。

因为给定车速为 $1\ km/min$ ，故距离可以直接被转化为时间。且题目中 $M$ 可以理解为第 $0$ 个路口（起始位置）到第 $1$ 个路口的距离。故题目可以理解为：

已知 $N$ 个阶段，每个阶段有 $A_i,R_i,G_i$ 三个参数描述。其中，第 $i$ 个阶段的最短时间为 $A_i$ ,有时还需加上一段时间 $m$ ，且 $0\leq m \leq A_i$。

介于题目的输入顺序，我们无法直接按输入->计算->输出->输入->...的方式以节省空间。

因此，我们可以建立一个结构体，含 $a,r,g$ 三个参数。当时间 $t$ 加上这个结构体时，首先， $t=t+a$ (最基本需要的时间)；其次我们需要知道，等待红灯的时间 $m$ 是多少。

我们可以这么想：在 $t$ (修改后)时间内，若已经过了完整的 $k$ 个轮回(定义一个轮回为一次绿灯+一次红灯)。则 $t=k(g+r)+m$ 。

所以 $m=t\%(g+r)$。

若过该路口时为绿灯，则 $m<g$ ；若为红灯，则需加上 $[r-(m-g)]$。

所以我们直接另 $m=t\%(g+r)-g$ 。若 $m<0$ 则为 $t$ 不需另外加上数值，否则加上 $(r-m)$ 。

------------
**【参考代码】**
---------------
```cpp
#include<cstdio>
#include<cctype>
using namespace std;
int read(){
	int abs=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
	while(isdigit(c)) abs=abs*10+c-'0',c=getchar();
    return abs;
}//读入优化
struct node{
	int a,r,g;
	node() {a=r=g=0;}//初始化
	int operator + (const int& t){
		int n=t+a,m=n%(r+g)-g;
		if(m>0) n+=(r-m);
		return n;
	}//重载运算符
}cross[100000];
int main(){
	int n=read(),t=0;
	for(int i=0;i<n;i++) cross[i].a=read();
	for(int i=0;i<n;i++) cross[i].r=read();
	for(int i=0;i<n;i++) cross[i].g=read();
	for(int i=0;i<n;i++) t=cross[i]+t,printf("%d\n",t);
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：Janat_ (赞：1)

直接贴代码    
pascal

```pascal
var n,m,i,t,s:longint;
    a,r,g:array[1..100000] of longint;
begin
  readln(n,m);
  a[1]:=m;
  for i:=2 to n do
    read(a[i]);
  readln;
  for i:=1 to n do
    read(r[i]);
  readln;
  for i:=1 to n do
    read(g[i]);
  readln;
  t:=0;
  for i:=1 to n do
  begin
    t:=t+a[i];//将t累加，因为要求输出的是每一个十字路口，所以就没有必要重做
    s:=t mod (g[i]+r[i]);//求出余数
    if s>g[i] then t:=t+g[i]+r[i]-s;//如果大于再加上
    writeln(t);
  end;
end.
```

---


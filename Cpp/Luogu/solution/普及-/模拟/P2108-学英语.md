# 学英语

## 题目描述

为了适应紧张的大学学习生活，小 Z 发愤图强开始复习巩固英语。

由于小 Z 对数学比较有好感，他首先复习了数词。小 Z 花了一整天的时间，终于把关于基数词的知识都搞懂了。于是小 Z 非常兴奋，决定出一些题目考考已经过了英语四级、人称英语帝的小 G。考法很简单：小 Z 给出某个整数 $x$ 的英文写法，要求小 D 用阿拉伯数字写出 $x$。

小 Z 会保证以下几点：

1. $-999,999,999 \leq  x \leq 999,999,999$

2. 题目中只会用到以下这些英文单词：

`negative, zero, one, two, three, four, five, six, seven, eight, nine, ten`

`eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty`

`thirty, forty, fifty, sixty, seventy, eighty, ninety, hundred, thousand, million`

3. 若 $x$ 为负数，题目中第一个单词是 `negative`，否则任何时候都不会出现 `negative` 这个词。

4. 由于小 Z 很牛 B，他不知道像 $103$ 这样的数字要写成 `one hundred and three` 而是直接写成了 `one hundred three`，就是说小 Z 的所有题目中都没有写 `and` 这个词（尽管本应该是要写的），请你谅解。

5. 除了第 4 点， 其他还是基本符合英语的语法规则的， 比如 $1500$ 他会写成 `one thousand five hundred` 而不会写成 `fifteen hundred`。

小 D 拿到题目后不屑地说了一句：水题！写个程序么好了……

但是小 D 要出去玩（此时应该已经在千里之外爽玩了） ，这个任务就交给你了。


## 说明/提示

对于 $100\%$ 的数据，$-999,999,999 ≤ x ≤ 999,999,999$。

## 样例 #1

### 输入

```
six```

### 输出

```
6```

## 样例 #2

### 输入

```
negative seven hundred twenty nine```

### 输出

```
-729```

## 样例 #3

### 输入

```
one million one hundred one```

### 输出

```
1000101```

## 样例 #4

### 输入

```
eight hundred fourteen thousand twenty two```

### 输出

```
814022```

# 题解

## 作者：Eason_AC (赞：20)

## Content
给出整数 $x$ 的英文写法，求出这个整数 $x$。

规则详见[题面](https://www.luogu.com.cn/problem/P2108)。

**数据范围：$|x|\leqslant 999999999$（$9$ 个 $9$）。**
## Solution
题目思路很简单，但要注意细节。

开两个变量 $ans$（最终的答案） 和 $now$（当前的计数），边输入一个字符串边一个一个计数，至于对应的操作吗——

1. 如果这个字符串是 $\texttt{thousand}$ 或者 $\texttt{million}$ 的话，就直接将 $now$ 全部计入 $ans$ 里面，并将 $now$ 清空。

2. 否则，将读取到的字符串对应的数字加入到 $now$ 当中（如果是 $\texttt{hundred}$ 就将 $now$ 乘上 $100$）。

3. 注意 $\texttt{negative}$ 的情况，此时应该在最后输出负数。

具体的思路就是这些。
## Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream> 
using namespace std;

string s;
long long num, now, f;

int main() {
	f = 1;
	while(cin >> s) {
		if(s == "negative")	f = -1;
		if(s == "one")		now++;
		if(s == "two") 	now += 2;
		if(s == "three")	now += 3;
		if(s == "four")	now += 4;
		if(s == "five")	now += 5;
		if(s == "six")		now += 6;
		if(s == "seven")	now += 7;
		if(s == "eight")	now += 8;
		if(s == "nine")	now += 9;
		if(s == "ten")		now += 10;
		if(s == "eleven")	now += 11;
		if(s == "twelve")	now += 12;
		if(s == "thirteen")	now += 13;
		if(s == "fourteen")	now += 14;
		if(s == "fifteen")	now += 15;
		if(s == "sixteen")	now += 16;
		if(s == "seventeen")	now += 17;
		if(s == "eighteen")	now += 18;
		if(s == "nineteen")	now += 19;
		if(s == "twenty")	now += 20;
		if(s == "thirty")	now += 30;
		if(s == "forty")	now += 40;
		if(s == "fifty")	now += 50;
		if(s == "sixty")	now += 60;
		if(s == "seventy")	now += 70;
		if(s == "eighty")	now += 80;
		if(s == "ninety")	now += 90;
		if(s == "hundred")	now *= 100;
		if(s == "thousand")	num += now * 1000, now = 0;
		if(s == "million")	num += now * 1000000, now = 0;
	}
	num += now;
	printf("%lld", num * f);
}
```
## Supplement
建议做完这道题目的读者去做一下[【P1617】爱与愁的一千个伤心的理由](https://www.luogu.com.cn/problem/P1617)，大意就是将阿拉伯数字转为英文读法。

顺便推广一下我在这道题的[题解](https://www.luogu.com.cn/blog/EasonBlog1/solution-p1617)（

---

## 作者：荆棘之心 (赞：5)

说实话，这道题我真的十分惭愧……

但是我有一种新思路，用了~~单链表~~……

虽然使题目变得更~~复杂了~~

 _**此代码需使用c++11才可编译通过！！！！**_ 
 
 题解参上
```c
#include<iostream>
#include<string>
#include<vector> 
using namespace std;
struct node{//模板，把题目中可能会出现的英语单词罗列出来（负数除外）在单词后标注数目
	string name;
	int s;
};
string str;
vector<node>sl;//创建模板链表
vector<string>cinth;//创建输入链表
void bg();//初始化模板链表函数（本人喜欢预定义）
long long ans=0,sum=0;
bool flag=false;
int main(){
	bg();//初始化模板链表
	while (cin>>str)cinth.push_back(str);//输入单词
	for(string i:cinth){//从链表第一项开始读取，直到末尾
		if(i=="negative")flag=true;//判负
		else
		for(node j:sl){//与模板链表的每一项进行比较
			if(i==j.name){
				if(i=="million"){
					ans+=sum*1000000;
					sum=0;
             				//如果出现百万，则把前面的*100000再存入答案
				}
				else if(i=="thousand"){
					ans+=sum*1000;
					sum=0;
                    			//同理
				}
				else if(i=="hundred"){
					sum*=100;
				}
				else {
					sum+=j.s;
                    			//若均不满足，则把数据加上
				}
			}
		}
	}
	ans+=sum; 
	if(flag)cout<<0-ans;
	else cout<<ans;
	return 0;
}
void bg(){//初始化函数，有亿点烦人
	node temp;
	temp.name="one";
	temp.s=1;
	sl.push_back(temp);
   	//定义一个temp，把每一项的名字和数据存入temp，再由temp存入模板变量，同下
	temp.name="two";
	temp.s=2;
	sl.push_back(temp);
	temp.name="three";
	temp.s=3;
	sl.push_back(temp);
	temp.name="four";
	temp.s=4;
	sl.push_back(temp);
	temp.name="five";
	temp.s=5;
	sl.push_back(temp);
	temp.name="six";
	temp.s=6;
	sl.push_back(temp);
	temp.name="seven";
	temp.s=7;
	sl.push_back(temp);
	temp.name="eight";
	temp.s=8;
	sl.push_back(temp);
	temp.name="nine";
	temp.s=9;
	sl.push_back(temp);
	temp.name="ten";
	temp.s=10;
	sl.push_back(temp);
	temp.name="eleven";
	temp.s=11;
	sl.push_back(temp);
	temp.name="twelve";
	temp.s=12;
	sl.push_back(temp);
	temp.name="thirteen";
	temp.s=13;
	sl.push_back(temp);
	temp.name="fourteen";
	temp.s=14;
	sl.push_back(temp);
	temp.name="fifteen";
	temp.s=15;
	sl.push_back(temp);
	temp.name="sixteen";
	temp.s=16;
	sl.push_back(temp);
	temp.name="seventeen";
	temp.s=17;
	sl.push_back(temp);
	temp.name="eighteen";
	temp.s=18;
	sl.push_back(temp);
	temp.name="nineteen";
	temp.s=19;
	sl.push_back(temp);
	temp.name="twenty";
	temp.s=20;
	sl.push_back(temp);
	temp.name="thirty";
	temp.s=30;
	sl.push_back(temp);
	temp.name="forty";
	temp.s=40;
	sl.push_back(temp);
	temp.name="fifty";
	temp.s=50;
	sl.push_back(temp);
	temp.name="sixty";
	temp.s=60;
	sl.push_back(temp);
	temp.name="seventy";
	temp.s=70;
	sl.push_back(temp);
	temp.name="eighty";
	temp.s=80;
	sl.push_back(temp);
	temp.name="ninety";
	temp.s=90;
	sl.push_back(temp);
	temp.name="hundred";
	temp.s=100;
	sl.push_back(temp);
	temp.name="thousand";
	temp.s=1000;
	sl.push_back(temp);
	temp.name="million";
	temp.s=1000000;
	sl.push_back(temp);
	return;
}
```
_注：每计算一级需要将答案插入到ans回答中，否则答案可能会有问题！_

谢谢各位大佬的观看本蒟蒻的代码，虽然超烦人。

---

## 作者：花千树 (赞：5)

# map大法好
看楼下打那么多行表，用map不就解决了吗~~233~~

把所有一位数两位数放进数组，用a["one"]的方式赋值，然后读进去字符串s，如果不是hundred，negative，thousand，million，就将a[s]的值累加，其余过程的思路和楼下基本相同（只是给大家提供一种新的做法）

下面就是震撼人心的** _code_ **
```
#include<map>
#include<cmath>
#include<stack>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
map<string,int>a;
string s;
int ans,sum;
bool flag;
int main(){
    a["one"]=1;
    a["two"]=2;
    a["three"]=3;
    a["four"]=4;
    a["five"]=5;
    a["six"]=6;
    a["seven"]=7;
    a["eight"]=8;
    a["nine"]=9;
    a["ten"]=10;
    a["eleven"]=11;
    a["twelve"]=12;
    a["thirteen"]=13;
    a["fourteen"]=14;
    a["fifteen"]=15;
    a["sixteen"]=16;
    a["seventeen"]=17;
    a["eighteen"]=18;
    a["nineteen"]=19;
    a["twenty"]=20;
    a["thirty"]=30;
    a["forty"]=40;
    a["fifty"]=50;
    a["sixty"]=60;
    a["seventy"]=70;
    a["eighty"]=80;
    a["ninety"]=90;
    while(cin>>s){
        if(s=="negative")flag=1;
        else if(s!="hundred"&&s!="thousand"&&s!="million")ans+=a[s];
        if(s=="hundred")ans*=100;
        if(s=="thousand")sum+=ans*1000,ans=0;
    	if(s=="million")sum+=ans*1000000,ans=0;
    	s="";
    }
    if(s!="hundred"&&s!="thousand"&&s!="million")ans+=a[s];
    if(s=="hundred")ans*=100;
    if(s=="thousand")sum+=ans*1000,ans=0;
    if(s=="million")sum+=ans*1000000,ans=0;
    sum+=ans;
    if(flag)sum=-sum;
    cout<<sum<<endl; 
    return 0;
}
```

---

## 作者：zmza (赞：3)

此题可使用打表完成。

要注意的坑是：

(1)如：$two thousand$ 而不会写成 $thousand thousand$.

(2)如果有$"negative"$的话那要输出负数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long sum,tmp;
bool flag;//判断有没有负数
int main()
{
	while(cin >> s) {
		if(s == "negative")	//有负数，标记
			flag = 1;
  
  		//从 "one" 一直到 "hundred" 都有可能是thousand和million的系数，所以只能加，不能归为0.
		if(s == "one")		
			tmp++;
		if(s == "two") 
			tmp += 2;
		if(s == "three")	
			tmp += 3;
		if(s == "four")	
			tmp += 4;
		if(s == "five")	
			tmp += 5;
		if(s == "six")		
			tmp += 6;
		if(s == "seven")	
			tmp += 7;
		if(s == "eight")	
			tmp += 8;
		if(s == "nine")	
			tmp += 9;
		if(s == "ten")		
			tmp += 10;
		if(s == "eleven")	
			tmp += 11;
		if(s == "twelve")	
			tmp += 12;
		if(s == "thirteen")	
			tmp += 13;
		if(s == "fourteen")	
			tmp += 14;
		if(s == "fifteen")	
			tmp += 15;
		if(s == "sixteen")	
			tmp += 16;
		if(s == "seventeen")	
			tmp += 17;
		if(s == "eighteen")	
			tmp += 18;
		if(s == "nineteen")	
			tmp += 19;
		if(s == "twenty")	
			tmp += 20;
		if(s == "thirty")	
			tmp += 30;
		if(s == "forty")	
			tmp += 40;
		if(s == "fifty")	
			tmp += 50;
		if(s == "sixty")	
			tmp += 60;
		if(s == "seventy")	
			tmp += 70;
		if(s == "eighty")	
			tmp += 80;
		if(s == "ninety")	
			tmp += 90;
		if(s == "hundred")	
			tmp *= 100;
  		//如果是thousand和million的话，那么就不用担心是系数，直接加进sum里去，并归为0.
		if(s == "thousand")	
			sum += tmp * 1000, tmp = 0;
		if(s == "million")	
			sum += tmp * 1000000, tmp = 0;
	}
	sum += tmp;
	printf("%lld", flag == 1 ? -sum : sum);//如果flag是1，输出负flag，否则输出flag。
}
```


---

## 作者：月影 (赞：2)

这题很水，对每个可能输入的单词都加一次判定就行了。主要有两个注意点：

（1）千与百万前可能出现one hundred thirty two的情况，所以除了thousand与million两词外的词，都不能直接加到结果中。记得不要忘了在查到千时重置中间量。

（2）我用的是字符串读入，在扫描到空格时进行操作，这导致再出循环后要多操作一次，把还存在中间量中的数据加上去。

ps.这道题的样例情况非常全，只要样例都能过那应该就没有遗漏什么注意点了。



代码：

```cpp
var s,zjl:string;//zjl为存储单词的辅助字符串
    fs:boolean;//判断是否为复数
    l,i,jg,zjsj:longint;//jg为结果，zjsj为中间量
procedure cl;//全部查一次
begin
  if zjl='negative' then begin fs:=true; exit; end;
  if zjl='zero' then begin exit; end;
  if zjl='one' then begin zjsj:=zjsj+1; exit; end;
  if zjl='two' then begin zjsj:=zjsj+2; exit; end;
  if zjl='three' then begin zjsj:=zjsj+3; exit; end;
  if zjl='four' then begin zjsj:=zjsj+4; exit; end;
  if zjl='five' then begin zjsj:=zjsj+5; exit; end;
  if zjl='six' then begin zjsj:=zjsj+6; exit; end;
  if zjl='seven' then begin zjsj:=zjsj+7; exit; end;
  if zjl='eight' then begin zjsj:=zjsj+8; exit; end;
  if zjl='nine' then begin zjsj:=zjsj+9; exit; end;
  if zjl='ten' then begin zjsj:=zjsj+10; exit; end;
  if zjl='eleven' then begin zjsj:=zjsj+11; exit; end;
  if zjl='twelve' then begin zjsj:=zjsj+12; exit; end;
  if zjl='thirteen' then begin zjsj:=zjsj+13; exit; end;
  if zjl='fourteen' then begin zjsj:=zjsj+14; exit; end;
  if zjl='fifteen' then begin zjsj:=zjsj+15; exit; end;
  if zjl='sixteen' then begin zjsj:=zjsj+16; exit; end;
  if zjl='seventeen' then begin zjsj:=zjsj+17; exit; end;
  if zjl='eighteen' then begin zjsj:=zjsj+18; exit; end;
  if zjl='nineteen' then begin zjsj:=zjsj+19; exit; end;
  if zjl='twenty' then begin zjsj:=zjsj+20; exit; end;
  if zjl='thirty' then begin zjsj:=zjsj+30; exit; end;
  if zjl='forty' then begin zjsj:=zjsj+40; exit; end;
  if zjl='fifty' then begin zjsj:=zjsj+50; exit; end;
  if zjl='sixty' then begin zjsj:=zjsj+60; exit; end;
  if zjl='seventy' then begin zjsj:=zjsj+70; exit; end;
  if zjl='eighty' then begin zjsj:=zjsj+80; exit; end;
  if zjl='ninety' then begin zjsj:=zjsj+90; exit; end;
  if zjl='hundred' then begin zjsj:=zjsj*100; exit; end;
  if zjl='thousand' then begin jg:=jg+zjsj*1000; zjsj:=0; exit; end;//操作后重置
  if zjl='million' then begin jg:=jg+zjsj*1000000; zjsj:=0; exit; end;//操作后重置
end;
begin
  readln(s);
  l:=length(s);//注意length的时间复杂度是o(n)的，所以尽量不要将它直接用在循环头中
  for i:=1 to l do
  begin
    if s[i]=' ' then begin cl; zjl:=''; end
      else zjl:=zjl+s[i];
  end;
  cl;
  jg:=jg+zjsj;//出循环后再处理一次
  if fs then write('-');
  writeln(jg);
  readln;
end.
```

---

## 作者：__Cocoa__ (赞：2)

此题其实不难。
翻译分两个部分：

1. 1~999：基础数；（用now存储）
2. thousand、million.（乘以1000、1000000后存在n中）
话不多说，上代码：↓
```C++
#include <iostream>
#include <string>

using namespace std;
string s;
long long n=0;
long now;//临时存储变量
short negpos=1;//正负数标识

int main(){
    while(cin>>s){//长长的判断语句：
    	if(s=="negative")negpos=-1;
    	else if(s=="zero")now+=0*negpos;
    	else if(s=="one")now+=1*negpos;
    	else if(s=="two")now+=2*negpos;
    	else if(s=="three")now+=3*negpos;
    	else if(s=="four")now+=4*negpos;
    	else if(s=="five")now+=5*negpos;
    	else if(s=="six")now+=6*negpos;
    	else if(s=="seven")now+=7*negpos;
    	else if(s=="eight")now+=8*negpos;
    	else if(s=="nine")now+=9*negpos;
    	else if(s=="ten")now+=10*negpos;
    	else if(s=="eleven")now+=11*negpos;
    	else if(s=="twelve")now+=12*negpos;
    	else if(s=="thirteen")now+=13*negpos;
    	else if(s=="fourteen")now+=14*negpos;
    	else if(s=="fifteen")now+=15*negpos;
    	else if(s=="sixteen")now+=16*negpos;
    	else if(s=="seventeen")now+=17*negpos;
    	else if(s=="eighteen")now+=18*negpos;
    	else if(s=="nineteen")now+=19*negpos;
    	else if(s=="twenty")now+=20*negpos;
    	else if(s=="thirty")now+=30*negpos;
    	else if(s=="forty")now+=40*negpos;
    	else if(s=="fifty")now+=50*negpos;
    	else if(s=="sixty")now+=60*negpos;
    	else if(s=="seventy")now+=70*negpos;
    	else if(s=="eighty")now+=80*negpos;
    	else if(s=="ninety")now+=90*negpos;
    	else if(s=="hundred")now*=100;
		else if(s=="thousand"){
    		n+=1000*now;
    		now=0;
		}
		else if(s=="million"){
    		n+=1000000*now;
    		now=0;
		}
	}
	n+=now;
	cout<<n;
	return 0;
}
```

---

## 作者：高泽棵 (赞：1)

var a:array[1..32] of string=('negative', 'zero', 'one', 'two','three',

'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten','eleven', 'twelve',

'thirteen','fourteen','fifteen', 'sixteen', 'seventeen', 'eighteen',

'nineteen', 'twenty', 'thirty', 'forty', 'fifty','sixty', 'seventy','eighty',

'ninety','hundred', 'thousand', 'million');//a数组存储各个数的英文

b:array[1..32] of longint=(-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18

,19,20,30,40,50,60,70,80,90,100,1000,1000000);//b数组储存各个值

```cpp
s:string;
c:array[1..1000] of string;
t,k,i,j,n:longint; ch:char;
function dfs(l,r:longint):longint;
var s,i,j:longint;
begin
  for i:=32 downto 30 do
    for j:=l to r do
      if c[j]=a[i] then//判断有没有百万、千、百位
        exit(dfs(l,j-1)*b[i]+dfs(j+1,r));//位数前后分别考虑
    s:=0;
    for i:=1 to 32 do//只有两位数的情况
      for j:=l to r do
        if a[i]=c[j] then
          s:=s+b[i];
    exit(s);
end;
begin
  t:=maxlongint;
  while not eoln do
  begin
    read(ch);
    if ch=' ' then
    begin
      if s=a[1] then write('-')//如果是负号的英文，则输出-，否则储存起来
      ELSE
      begin
        inc(n);
        c[n]:=s;
      end;
      s:='';
    end
    else
      s:=s+ch;
  end;
  inc(n);c[n]:=s;
  k:=1;
  for i:=32 downto 30 do
    for j:=1 to n do
      if c[j]=a[i] then//判断有没有百万、千、百位
      begin
        write(dfs(1,j-1)*b[i]+dfs(j+1,n));//位数前后分别考虑
        halt;
      end;
  t:=0;
  for i:=1 to n do
    for j:=1 to 32 do
      if c[i]=a[j] then t:=t+b[j];//只有两位数
  writeln(t);
end.

```

---

## 作者：happybob (赞：0)

 _2021.1.2 Update：更好的排版与推广博客_ 

博客：[https://www.luogu.com.cn/blog/332914/](https://www.luogu.com.cn/blog/332914/)

这个题目通常有两种解法，打表和map，打表要写很多 `if`，而 `map` 其实也是这样。

先要注意一点：

碰到一千和一百万是乘而不是加，例如 `one hundred` 不是 $\large 1 + 100$ 而是$\large 1 * 100$。

先看打表法子，很麻烦，138ms：
```cpp
#include <iostream>
using namespace std;

string s;

int main()
{
    int ans = 0, x = 0;
	while(cin >> s)
    {
		if(s == "negative")
        {
            cout << "-";
        }
		if(s == "one")
        {
            x++;
        }	
		if(s == "two")
        {
            x += 2;
        }	
		if(s == "three")
        {
            x += 3;
        }	
		if(s == "four")
        {
            x += 4;
        }
		if(s == "five")
        {
            x += 5;
        }
		if(s == "six")
        {
            x += 6;
        }	
		if(s == "seven")
        {
            x += 7;
        }	
		if(s == "eight")
        {
            x += 8;
        }	
		if(s == "nine")
        {
            x += 9;
        }	
		if(s == "ten")
        {
            x += 10;
        }	
		if(s == "eleven")
        {
            x += 11;
        }	
		if(s == "twelve")
        {
            x += 12;
        }	
		if(s == "thirteen")
        {
            x += 13;
        }	
		if(s == "fourteen")
        {
            x += 14;
        }	
		if(s == "fifteen")
        {
            x += 15;
        }	
		if(s == "sixteen")
        {
            x += 16;
        }	
		if(s == "seventeen")
        {
            x += 17;
        }
		if(s == "eighteen")
        {
            x += 18;
        }
		if(s == "nineteen")
        {
            x += 19;
        }	
		if(s == "twenty")
        {
            x += 20;
        }	
		if(s == "thirty")
        {
            x += 30;
        }	
		if(s == "forty")
        {
            x += 40;
       	}
		if(s == "fifty")
        {
            x += 50;
        }	
		if(s == "sixty")
        {
            x += 60;
        }	
		if(s == "seventy")
        {
            x += 70;
        }	
		if(s == "eighty")
        {
            x += 80;
        }	
		if(s == "ninety")
        {
            x += 90;
        }
		if(s == "hundred")
        {
            x *= 100;
        }
		if(s == "thousand")
        {
            ans += x * 1000;
            x = 0;
        }	
		if(s == "million")
        {
            ans += x * 1000000;
            x = 0;
        }
	}
	ans += x;
	cout << ans << endl;
}
```

还有一种就是map了，map一会会讲讲，137ms，快了1ms，但写的少很多：
```cpp
#include <iostream>
#include <map>
using namespace std;

map <string, int> m;

string s;

int main()
{
    m["zero"] = 0;
    m["one"] = 1;
    m["two"] = 2;
    m["three"] = 3;
    m["four"] = 4;
    m["five"] = 5;
    m["six"] = 6;
    m["seven"] = 7;
    m["eight"] = 8;
    m["nine"] = 9;
    m["ten"] = 10;
    m["eleven"] = 11;
    m["twelve"] = 12;
    m["thirteen"] = 13;
    m["fourteen"] = 14;
    m["fifteen"] = 15;
    m["sixteen"] = 16;
    m["seventeen"] = 17;
    m["eighteen"] = 18;
    m["nineteen"] = 19;
    m["twenty"] = 20;
    m["thirty"] = 30;
    m["forty"] = 40;
    m["fifty"] = 50;
    m["sixty"] = 60;
    m["seventy"] = 70;
    m["eighty"] = 80;
    m["ninety"] = 90;
    int ans = 0, c = 0;
    while(cin >> s != 0)
    {
        if(s == "negative")
        {
            cout << "-";
        }
        ans += m[s];
        if(s == "hundred")
        {
            ans *= 100;
        }
        if(s == "thousand")
        {
            c += ans * 1000;
            ans = 0;
        }
    	if(s == "million")
        {
            c += ans * 1000000;
            ans = 0;
        }
    }
    c += ans;
    cout << c << endl;
    return 0;
}
```

好，现在讲下map


大家都知道数组，比如：

```cpp
int arr[10005], x, y;
cin >> x >> y;
arr[x] = y;
```
数组下标只能为int，但如果像这道题目，数组肯定不行

用map可以做到下标和值为任何数据类型

map是STL容器中的映射类型，定义方式如下：

map <下标数据类型，值数据类型> 映射名称;

如：
```cpp
map <int, string> ma;
  
ma[666] = "AC";
  
cout << ma[666] << endl;
  
  
```
运行，输出：`AC`

map常用函数有：

# clear()

# begin()

# end()

# erase()

等

和vector等STL容器一样，也有迭代器

声明如下（两种）

1、
```cpp
map <下标数据类型，值数据类型>::iterator 迭代器名称;
```

2、
```cpp
auto 迭代器名称 = 值;
```

注意，迭代器和map映射map <下标数据类型，值数据类型>要一样


迭代器的便利方式是这样的

例如一下代码：

```cpp
map <string, int> ma;
  
ma["a"] = 1;
ma["c"] = 2;
ma["b"] = 3;
  
for(map <string, int>::iterator it = ma.begin(); it != ma.end(); it++)
{
    cout << it -> first << " " << it -> second << " ";
}
```

运行结果：`a 1 b 3 c 2`

可以看出，`map`在建立映射时，会将下标从小到大排序，`first`输出下标，`second`输出值，输入也是一样，但输入不能输入`first`的下标。




---

## 作者：yubing_lml (赞：0)

NO.9 map应用实例

定义一个map<string,int>类型的映射，这里要介绍map的插入和查询方法。

插入（3种）：均在init()函数中有所体现.init()函数完成对map对象number的初始化，方便之后的查询。

------------

```cpp
for (int i = 0; i <= 20; i++)
   number.insert(pair<string, int>(str[i], i));
```
------------

```cpp
for (int i = 3; i <= 10; i++)
   number.insert(map<string, int>::value_type(tns[i], i * 10));
```
------------

```cpp
number["thousand"] = 1000;
number["million"] = 1000000;
```
------------




查询：find()函数，下面这行语句可以根据关键字直接查找到对应的值，如关键字为hundred，则该语句返回100。


------------

number.find(current)->second;

------------


#### AC代码如下：
```cpp
#include<iostream>
#include<map>
#include<string>
using namespace std;

string str[35] = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen",
"fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty" }; 
string tns[] = { "","","","thirty", "forty", "fifty", "sixty", "seventy","eighty", "ninety", "hundred" }; //*10

map<string, int>number;

void init()
{
	for (int i = 0; i <= 20; i++)
		number.insert(pair<string, int>(str[i], i));
	for (int i = 3; i <= 10; i++)
		number.insert(map<string, int>::value_type(tns[i], i * 10));
	number["thousand"] = 1000;
	number["million"] = 1000000;
}

int main()
{
	init();
	int ans = 0, sign = 1, now, tmp = 0;
	string current;
	while (cin >> current)
	{
		if (sign == 1 && current == "negative")
		{
			sign *= -1;
			continue;
		}
		now = number.find(current)->second;
		if (current == "thousand" || current == "million")
		{
			ans += tmp * now;
			tmp = 0;
		}
		else if (current == "hundred")
			tmp *= now;
		else
			tmp += now;
	}//while
	ans += tmp;
	cout << ans * sign;
	cin >> ans;
	return 0;
}
```


---

## 作者：RyanStarrain (赞：0)

```cpp
#include <i\am\a\juluo\stdc++.h>
using namespace std;
string sentences; //你对程序说了什么话 
string str[100+2]; //把那句话拆成一个个单词而存储到字符串 
int strok = 1; //这是第几个单词？ 
bool NEGA = false; //这是负数吗？ 
int TEMP,trou,mill; 
//temp 你读到的数字
//trou 千位
//mill 百万位 
int main()
{
	getline (cin,sentences); //读入你的那句话 
	int sl = sentences.length(); //你那句话有多少个字符 
	for (int i = 0;i < sl;i++)
	{
		if (sentences[i] >= 'a' && sentences[i] <= 'z') //如果你读到的那句话为字母 
		{
			str[strok] += sentences[i]; //把那些字母加进一个盒子里 
		}
		if (sentences[i] == ' ') strok++; //如果是空格的话，很抱歉，我帮不了你 
	}
	//1
	if (str[1] == "negative") NEGA = true; //如果是负数，打开那个开关 
	int i;
	if (NEGA) i = 2; //如果开关开了，就从第2个单词开始 
	else i = 1; //否则就从头开始 
	//2
	for (i;i <= strok;i++)
	{
		if (str[i] == "one") TEMP += 1; //翻译 
		if (str[i] == "two") TEMP += 2;
		if (str[i] == "three") TEMP += 3;
		if (str[i] == "four") TEMP += 4;
		if (str[i] == "five") TEMP += 5;
		if (str[i] == "six") TEMP += 6;
		if (str[i] == "seven") TEMP += 7;
		if (str[i] == "eight") TEMP += 8;
		if (str[i] == "nine") TEMP += 9;
		if (str[i] == "ten") TEMP += 10;
		if (str[i] == "eleven") TEMP += 11;
		if (str[i] == "twelve") TEMP += 12;
		if (str[i] == "thirteen") TEMP += 13;
		if (str[i] == "fourteen") TEMP += 14;
		if (str[i] == "fifteen") TEMP += 15;
		if (str[i] == "sixteen") TEMP += 16;
		if (str[i] == "seventeen") TEMP += 17;
		if (str[i] == "eighteen") TEMP += 18;
		if (str[i] == "nineteen") TEMP += 19;
		if (str[i] == "twenty") TEMP += 20;
		if (str[i] == "thirty") TEMP += 30;
		if (str[i] == "forty") TEMP += 40;
		if (str[i] == "fifty") TEMP += 50;
		if (str[i] == "sixty") TEMP += 60;
		if (str[i] == "seventy") TEMP += 70;
		if (str[i] == "eighty") TEMP += 80;
		if (str[i] == "ninety") TEMP += 90;
		if (str[i] == "hundred") TEMP *= 100; 
		if (str[i] == "thousand")
		{
			trou = TEMP; //把翻译下来的数字存到千位里面 
			TEMP = 0; //清零，为下一次翻译做好准备 
		}
		if (str[i] == "million")
		{
			mill = TEMP; //把翻译下来的数字存到百万为里面 
			TEMP = 0; //清零，为下一次翻译做好准备
		}
	}
	if (NEGA) cout << '-'; //是负数就输出负号 
	if (mill != 0) cout << mill; //如果百万位有数字，就输出，没有就不理他 
	if (trou != 0 || mill != 0) //如果千位或者百万位有数字，恭喜你，看下去吧 
	{
		if (mill != 0) printf ("%03d",trou); //如果百万位不是0，就输出（要前导0） 
		else cout << trou; //否则不用前导0（输出还是要的） 
	} 
	if (TEMP != 0 || trou != 0) //如果个位或者千位有数字，那也请你看下去吧  
	{
		if (trou == 0) //如果千位是0 
		{
			if (mill == 0) cout << TEMP << endl; //如果百万位是0，输出个位（不带前导0） 
			else  printf ("%03d",TEMP); //否则还是要带的 
		}
		else  printf ("%03d",TEMP); //如果千位不是0，肯定要带 
	} 
	else cout << 0; //否则你就0下去吧 
	return 0;
} 
```


---


# 高精度减法

## 题目描述

高精度减法。

## 说明/提示

- $20\%$ 数据 $a,b$ 在 long long 范围内；
- $100\%$ 数据 $0<a,b\le 10^{10086}$。

## 样例 #1

### 输入

```
2
1```

### 输出

```
1```

# 题解

## 作者：stone_juice石汁 (赞：867)

# 题解 /【学习笔记】-- 高精度减法

## 修改日志：
- 1、19/3/31 修改：优化了批注，写的更易懂一些。

- **2、19/8/8 修改：增加了图片，细节更多，调整码风，解决了一些小BUG，科普了一些~~无关紧要~~的知识。（重大修改）**


------------

- ## 1、$int$的悲伤与高精度的需求。

	我们往常在作运算的时候，往往直接用运算符完成运算（譬如a - b）。这当然非常地简便。

	但是当**数据范围特别大**的时候，你去用运算符做减法往往得不到正确的结果，**为什么？？**

	首先，在$c++$里，每一种实数变量型都是有一个数据储存范围的。**譬如$int$型，它的数据范围就为 $-2147483648 < int < 2147483647$，也就是 $-2^{31} < int < 2^{31} -1$。一旦你给一个int型变量存一个大于这个范围的数，它就会产生溢出，然后你存的数字会变成另外一个非常神奇的数字** 。可以自己在线下试一试哦。
    
   ~~不要和我提Py和java！~~
    
   这个时候，你存的数字本身就已经发生错误，就不用指望他来运算了。
   
   当然也有解决办法，譬如开$long long$。但是当数据范围高到恐怖的地步的时候（甚至大于$10^{1000}$），别说$long long$了，开挂神器__$int128$都救不了你。
   
   这个时候，就需要高精度算法来解决问题。

------------

- ## 2、数组搞定高精度数字

	上面我们有提到过，在数据范围很大的时候，任何变量型已经无法满足我们的需求。这个时候怎么办？
    
   接下来介绍一种最传统的做法：开数组。
   
   我们开一个数组。这个数组开到多大？就要看你要存的数的位数有多少。若想存一个$2000$位的数，就把数组开到$2000$以上。
   
   你位数可以多啊，你多一位 位数，我就把数组多开一个空间。~~看谁斗得过谁~~
   
   而本题甚至开到了$10086$位，所以我选择把数组开到$10500$位。（开多点没坏处）
   
   **想必这样说大概都清楚了。我们用数组的每一个空间来存每一位数的那个数字。**
   
   这句话是什么意思呢？我们打个比方。
   
   比如说我们现在要存$123$这个数，把它存进$na$数组里。
   
   我们可以取出最后一位（个位）$3$，放到$na[1]$中。于是$na[1] = 3$
   
   同理，我们取出$2,1$放进数组，于是就有：
   
   ```cpp
	na[1] = 3;
	na[2] = 2;
	na[3] = 1;

	//也就是: na[MAXN] = {3, 2, 1};
    
	```
   
   **此时，$na[i]$就代表了此数的最后$i$位**
   
   ### 但是
    
   **我们并不选择直接一个一个输入每位数字，把数字存进数组。**
   
 	我们选择使用**字符串** ，像这样：
   
  	```cpp
	string a, b;
	cin >> a >> b;
  	for(int i = a.size(); i > 0; i --)na[i] = a[a.size() - i] - '0';
  	for(int i = b.size(); i > 0; i --)nb[i] = b[b.size() - i] - '0';
	//这个代码底下有解释
  	```
   **为什么这样做？**
    
   首先，**字符串输入两个数字，我们可以直接地知道每个数字的长度，也就是位数**（字符串$a$的长度为$a.size()$，依次类推）。**知道长度就可以直接给$for$循环服务。**
   
   其次，字符串它输入方便啊，一个$cin$就完成了，也不必去检验什么输入到空格之类的了。
   
   当然，最方便的是可以将字符串扔进子函数里（这个在最后有拓展）
   
   **当然：将字符串转化进数组需要一定技巧：**
   
   1、首先，字符串里同样可以用下表形式表示某位的数（譬如$a[i]$），**但是和我们之前的存法相反，$a[0]$ 表示的数字的最高位，次高位是$a[1]$。他是从$0$且是从高位算起的，和我们之前说的从低位开始存恰好相反。**
   
   2、其次，字符串里每个数其实都是$char$型的。虽然看起来和$int$型没什么不同，**但是想把$char$型转化成$int$型需要通过一个介质：$ASCII$码。**
   
	每个$char$字符都有对应的$ASCII$码，而$0-9$的$ASCII$码是$48 - 57$。**如果你尝试把一个$char$型的$0$存进$int$，那么存进去的则是$0$的$ASCII$码，也就是$48$。**
    
   这两个情况怎么解决？
   
   - **1、第一个问题，我们只需要把数组的第$i$位和字符串的第（位数 $-  i$）位对应起来就可以了。这是很好证明的。** 
   
   	假设我们要存一个$3$位数，它的每一位：
    
   	用数组表示：$na[1], na[2], na[3]$
   	
   	用字符串表示:$a[3 - 1], a[3 - 2], a[3 - 3]$**（这里千万要注意字符串下标是从$0$开始存的，也就是$a[0]$表示最高位）**
    
   	代码中手打出来就可以了。
    
   -  2、第二个问题，$0-9$的$ASCII$码不是$48 - 57$么，那么把字符引入$int$型的时候，**我们只需要引入时把每个数减去$48$就行了。** $48-57$减去$48 = 0-9$ 道理都懂，对吧。
   
   	**当然你可以把$48$写成$'0'$。$'0'$就代表着$0$的$ASCII$码**
    
   	**于是这就有了我上面给出的代码：**
   
      
   ```cpp
	string a, b;
	cin >> a >> b;
   for(int i = a.size(); i > 0; i --)na[i] = a[a.size() - i] - '0';//其实这里正这倒着循环真的无所谓
   for(int i = b.size(); i > 0; i --)nb[i] = b[b.size() - i] - '0';
	
   ```
   - **于是乎，我们就有了两个数组，存了两个高精度数字。**
	
    
- ## 3、小学计算教你做减法

	**数字存进数组去了，那么问题来了，如何让两个数组作减法？？**

	答案很简单：**小学竖式运算！**
   
   ~~什么？你居然教我减法用竖式？？？~~
   
   好吧，可能各位做减法熟能生巧，不需要列竖式就可以口糊出来。但是你要知道，计算机并不会做数组相减的运算。于是我们就需要“教他”算。
   
   小学老师怎么教你算减法？当然是竖式运算。
   
   具体做法就是：**把两个数字的每一位对齐，从低位到高位，同一位逐次相减，如果减不够就向后一位借位。**（小学竖式借位甚至还要向借的位打标记防止你忘了）

	计算机的竖式运算同样是这个道理。我们假设有两个存了数字的数组$na,nb$。
    
   我们把两个数的每位对齐，刚刚我们提到：$na[i]$代表$a$这个数的第$i$位。同理：$nb[i]$代表$b$这个数的第$i$位。
   
   **那么，我们只需要做的就是$na[i] - nb[i]$就行了。这就代表了$a$的第$i$位减去了$b$的第$i$位**
   
   我们用表格演示一下$456789$减去$135353$，其中，$ans$数组用来存储答案
   
   ![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/07/5d4ace314a2d7.png)
   
   可以看到，每一位依次相减，最后传进答案数组，这个相减的过程就完成了。
   
   用代码表示，可以表示成：
   
   ```
   ans[i] = na[i] - nb[i];
   ```
   
   ### 可是！以上问题没有考虑过借位的情况！
   
   如果要借位，我们怎么处理？？
   
   根据小学竖式~~的博大精深~~来看，我们可以向高位借位，然后再相减。
   
   这个**借位**如果要说明白点，就是高位减去一个$1$，给低位一个$10$加上然后再相减。
   
   具体的，如果运算$34 - 19$，$4 - 9$明显减不够，于是：
   
   ```
	34 - 19 = (30 + 4) - (10 + 9) = (20 + 14) - (10 + 9) 
    = (20 - 10) + (14 - 9) = 10 + 5 = 15
	```
   上面的例子中，$30$很明显借了$10$给$4$，然后$14$ - $9$进行运算
	
   这个东西放到我们数组相减也适用。**简单来说，当一位减不够另一位时，就从高位借$10$过来再减，当然，高位会比原来少$1$**。
   
   我们再用表格举个例子：$456789 - 147791$
   
   ![QQ浏览器截图20190807215325.png](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/07/5d4ad80ae92ab.png)
   
   这样就成功处理了减位的问题。
   
   用代码就这样表示：
   
   ```
	int maxl = max(a.size(), b.size());
	/*
	找到两个数中的最大位，为for循环服务 
	如果两个数位数不相等，相减也无妨，因为位数少的数那部分被0补齐，减下去不影响
	*/
	for(int i = 1; i <= maxl; i ++)
	{
		if(na[i] < nb[i])//减不够
		{
			na[i + 1] --;//借位
			na[i] += 10;//到低位去
		}
		ans[i] = na[i] - nb[i];//相减
	}
	```
    
   **于是，相减代码就是这样了**

- ## 4、看似已完成，输出却全是坑

	你以为这样就做完了？评测姬告诉你：**Too Young Too Simple**
    
   **输出里还有一些坑，把你坑的头皮发麻。**
   
   平常的输出方式是什么？我们现在知道了两个数的最大位，上面也有提到过。我们用$maxl$表示。
    
   **因为我们是从个位，逐渐递增存每位上的信息，但是我们要从最高位开始输出，也就是我们要先输出最高位。** 这倒是和字符串有点相似。
   
   于是我们采用倒着输出方法，代码大概是这个样子。
   
   ```
  for(int i = maxl; i > 0; i --)cout << ans[i];
	```
	但是！坑来了。
   
   - ### **坑点1、**
   	
  	**如果你用$10001 - 10000$，会发生什么？**
    
  	当然你会知道它应该输出$1$。可你的计算机不这么认为。
    
  	依照上面的输出方法，此时$maxl$为$5$。**那么，它输出的就不是$1$，而是$00001$！**，因为他会输出$maxl$次，也就是$5$次，并且是从$ans[5]$ 输到 $ans[1]$。**但此时：$ans[2]-ans[5]$都已经为$0$**
    
  	所以我们不得不考虑，在相减后位数下降的情况下，不特殊处理就会多输出若干个$0$。
    
  	解决方法很简单，输出前加上这么一句话即可：
    
  	```cpp
  	while(ans[maxl] == 0)maxl --;
  	//如果最高位为0，就一直减小最高位，直到不为0为止。
  	```
    
  	由于$maxl$直接为输出的$for$循环服务，减小$maxl$相当于减少了循环输出次数。最后，$ans[maxl]$会停留在第一个不为$0$的位置。
   
  	- ### **坑点2、**
    
  	上面的坑点提到要去除多余的前导零，**但是，是不是所有的前导零都是多余的？**
    
  	**要是答案输出本身就为$0$，前导零就是他本身。这个时候我们仍然要输出一个$0$。** ，如果我们不处理这个地方，**上面处理前导零的代码就会把需要输出的$0$也给处理掉。**
    
  	**也就是说，当两减数相等，答案为$0$，不处理这个地方，代码什么都不会输出。**
    
   	所以我们要在最后输出时这么写：
     
   	```cpp
	 if(maxl < 1)cout << "0";
   	//最大位小于1，也就是最高位为0时输出。
   	//最高位为0，显而易见答案就为0了
   	//这种情况下前面什么都不会输出，这里额外输出一个0倒也无伤大雅
	 ```
	- ### **坑点3、**
    
   	这里还有一个坑，**那就是：相减可能小于$0$**
    
   	显然，**我们用上面的相减代码是处理不掉这种情况下的。** 那怎么办？
    
   	这个时候就需要手动加特判了。
   	
   	稍微想一下，只有在数字 $b > a$的情况下，$a - b$才可能为负。于是我们可以用非常玄学的运算式：
    
   	$(a - b)= - (b - a)$
    
   	如何实现这个操作？我们在判断 $b > a$ 成立后，可以调用函数$swap$交换$a，b$，然后再用一个判断$bool$型变量打上标记。
    
   	交换过后，很明显，运算变为 $b - a$ ，而 $b > a$，显然运算不会出错。最后输出的时候，只需要在前面加一个负号即可。
    
  	```
  	bool pd;
  	if((a < b && a.size() == b.size()) || a.size() < b.size())
  	{
		 swap(a, b);//swap函数作用：交换两数
		 pd = true;//打上标记
  	}
  	//----中间省略一堆计算代码-----
  	
  	if(pd == true)cout << "-";
  	//b > a时，a - b < 0，打头输出负号
  	
  	//----后面省略一堆输出代码-----
	
  	```
  	这里需要一提的是判断 $b > a$的方法。很显然，这里$a，b$都是字符串$string$型。为什么要这么写？
   
  	这里涉及**字典序**的比较大小方式。$string$类型不是不能比大小，而是规则上有所不同
    
  	粗略地概括一下：
    
  	**从最高位比起，$ASCII$码更大的字符串更大。如果相等，比次高位，以此向下类推。**
    
  	**所以在$string$中，串 $9 > 89$ 。因为最高位$9 >8$**
   
  	当然，像前面几个数如果都相等，位数更大的显然更大。
    
  	例如$1234500 > 12345$
   
  	**所以说：在位数相等的时候，我们可以直接利用字符串比大小的性质，来比较两数大小，但又要防止出现 $9 > 89$ 这种情况，所以还要保证位数大的数值才更大**
    
  	综上所述，得出这么一句判断。
    
  到此为止：我们得出来了高精度的$AC$代码
  
- ## 上代码！

```cpp
#include<bits/stdc++.h>
#define mian main
#define QWQ puts("QWQ");
#define MAXN 10500 
//define是宏定义，define a b的作用是把a代替为b执行。 
//这里的意思是把MAXN替换成10500执行 
//请无视上方两个的宏定义（QWQ） 

using namespace std;

string a, b;
//选择字符串。因为字符串储存了每个串的长度，可以直接调用。
int na[MAXN], nb[MAXN], ans[MAXN]; 
bool pd;

int main()
{
    cin >> a >> b;
	if((a < b && a.size() == b.size()) || a.size() < b.size())
	{
		swap(a, b);
		pd = true;
	}
    for(int i = a.size(); i > 0; i --)na[i] = a[a.size() - i] - '0';
    for(int i = b.size(); i > 0; i --)nb[i] = b[b.size() - i] - '0';
    //将字符串中的信息转化到数组中，数组模拟数字。 
    int maxl = max(a.size(), b.size());
    //找到两个数中的最大位，为for循环服务 
	for(int i = 1; i <= maxl; i ++)
	{
		if(na[i] < nb[i])
		{
			na[i + 1] --;
			na[i] += 10;
		}
		ans[i] = na[i] - nb[i];
	}
	
	while(ans[maxl] == 0)maxl --;//防止减后降位，多输出若干0 
	
	if(pd == true)cout << "-";//b>a时，a - b < 0 所以打上负号 
	
	for(int i = maxl; i > 0; i --)cout << ans[i];
	if(maxl < 1)cout << "0";
    return 0;
}
```

- ## I Need More！！！

	这个代码的确可以$AC$整道题，但是并不是完美的高精度减法。
   
   - **当我们需要多次调用高精度运算时，这种写法就显得鸡肋了。**
   
   - **并且，它并不能处理 $a$ 或 $b$ 为负数的情况。**
   
   - ~~最重要的是，换种写法逼格更高~~
   
   但是这里就不写了，我挂在底下，有需求的可以自行了解哦（主要怕占版面太多 QWQ ）

	## [“就这么点东西根本无法满足我”](https://www.luogu.org/blog/stonejuice/gao-jing-du-jian-fa-di-op-xie-fa)
    
    
- ## 特别鸣谢：

	- 洛谷提供的平台
    
  	- 管理员的辛勤审核
    
   - 大家的支持（没有大家的支持，我可能没有动力去更新Updata）
   
  希望大家能在评论区留言讨论，我会尽量看的！

---

## 作者：billchenchina (赞：143)

睡一觉醒来发现Luogu资瓷Python了！！！


来交一发Python题解（逃

```python
# python3
a=input()
b=input()
print(int(a)-int(b))
```
```python
# python2
a=input()
b=input()
print int(a)-int(b)
```

洛谷今天<del>是疯了吧</del>效率真高，一天加了三个语言。。。再来一发Java。。。


```java
import java.io.*;
import java.util.*;
import java.math.*;




public class Main
{
    public static void main(String args[])
    {
        Scanner cin = new Scanner(new BufferedInputStream(System.in));
        BigInteger a = cin.nextBigInteger();
        BigInteger b = cin.nextBigInteger();
        System.out.println(a.subtract(b));
    }
}
```
（管理把我今天上午发的那篇删掉呗~~蟹蟹



---

## 作者：取名困难症 (赞：108)

首先，据我所知，没有题解用重载运算符（可能是我眼瞎），so——
----------------------------------
其次，此 _**代码**_ 仅为科普用，部分非本人** _原创_ **
---------------------
重载运算符，顾名思义，将加减乘除重载，普通加（减乘除等）号变为高精加（减乘除），具体如下：
重载运算符分为两步：重载声明（较重要）和重载决策

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。

注意，这里用的是压位高精

压位高精：这里用的是压8位，即取8位为一截以8位数为运算单位，每8位在数组里进1位。

bignum operator +(bignum x) const：这是重载加号的格式，其他符号也一样

其他说明都在注释里

code：
```cpp
#include<bits/stdc++.h> 
using namespace std;
const int M=100000000,P=8;//压8位，所以M=10的8次方，P=8
struct bignum 
{
    int n[5001],l; 	
    bignum()//初始化
    {
        l=1;
        memset(n,0,sizeof(n));//初始化为0
    }
    void init()//读入
    {
        string s;
        cin>>s;//要用字符串输入，不能用int
        int now=0,ct=0,c1=1; 
        for(int i=s.length()-1;i>=0;i--)//倒序读入，因为高精度本质是竖式运算，从最末尾开始算
        {
            n[now]+=(s[i]-'0')*c1;//处理数位
            c1*=10;
            ct++;
            if(ct==P&&i!=0) //压位，压8位 
            {
                now++;
                ct=0;//压一位，重新开始
                c1=1;
            }		
        }
        l=now+1; 
    }
    void print()//输出
    {
        printf("%d",n[l-1]);
        for(int i=l-2;i>=0;i--)	//注意倒序
        	printf("%0*d",P,n[i]);  
        cout<<endl;
    }
    bignum operator +(bignum x) const//重载加号	
    {
        bignum t=*this;
        if(x.l>t.l)//不能用max函数，而大于是重载过的
            t.l=x.l;
        for(int i=0;i<t.l;i++)
        {
            t.n[i]+=x.n[i];
            if(t.n[i]>=M)//超过了8位
            {
                t.n[i+1]+=t.n[i]/M;//重新开始新的一位
                t.n[i]%=M;//删去末尾8位
            }
        }//进位
        return t;			
    } 
    bool operator < (bignum x) const//重载小于号	 
    {
        bignum t=*this;
        if(t.l!=x.l)//如果位数不相同
             return t.l<x.l;
        for(int i=t.l-1;i>=0;i--)//else
            if(t.n[i]!=x.n[i]) //从大到小、从高到低判断
  					return t.n[i]<x.n[i];
        return 0;
    }
    bignum operator -(bignum x) const//重载减号	 
    {
        bignum t=*this;
        if(t<x)//防止题干中说的特殊情况
        {
            printf("-");//先输出﹣号
            swap(t,x);//交换
        }
        int sum=0;//当前压到第几位
        for(int i=0;i<t.l;i++)
        {
            t.n[i]-=x.n[i];
            while(t.n[i]<0)//加到大于零位置
            {
                t.n[i]+=M;//M即8位
                sum++;//计算要进几位（几个8位）
            }
            t.n[i+1]-=sum;//退位
            sum=0;
        }
        while(!t.n[t.l-1]&&t.l>1)
            t.l--; //删除前导零 
        return t;//返回
    }
}a,b,c;
int main()
{
    a.init();	
    b.init();//读入
    c=a-b;//相减
    c.print();//完美输出！
}
```
满意的话随手点个赞啦！


---

## 作者：Edgaru089 (赞：66)

没有调出来时看了看题解，发现根本看不懂（雾）
于是想写一个可读性好一点的C++题解
此题解融合了加减乘三种运算和高精度比较，希望会有帮助

```cpp
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <string>
using namespace std;

// 定义了每个数中存多少位
#define DIGITS 20100

//////////////////// 高精度整数 ////////////////////
struct BigInt {

	// 两个构造函数
    // 默认情况下会把所有没用的位设为零
	BigInt() { memset(digits, 0, sizeof(digits)); }
	BigInt(string x) {
		memset(digits, 0, sizeof(digits));
		for (int i = 1; i <= x.length(); i++) {
			digits[i] = x[x.length() - i] - '0';
		}   // 注意倒序（个十百千的顺序）
	}

	// 转换为可以输出的字符串
	string toString() {
		string str;
		int back = 0;
        
        // 先找到最后一个不是零的数位
        //（复杂度不高完全没必要把长度存下来）
		for (int i = DIGITS; i >= 1; i--) {
			if (digits[i] != 0) {
				back = i;
				break;
			}
		}
        
        // 倒着放到字符串里
		for (int i = back; i >= 1; i--)
			str += to_string(digits[i]);
		
        // 如果字符串里什么也没有：所有数位都是零，手动赋一个零
        if (str == "")
			str = "0";
            
		return str;
	}

	// 用只有16位的short
	short digits[DIGITS + 2];

};

//////////////////// 高精度加法 ////////////////////
BigInt add(BigInt x, BigInt y) {
	BigInt sum;
	int inc = 0; // 进位标记
    
    // 从最低位开始累加
	for (int i = 1; i <= DIGITS; i++) {
    	// 加起来
		sum.digits[i] = x.digits[i] + y.digits[i] + inc;
		
        // 如果结果大于了十：要进位
        if (sum.digits[i] >= 10) {
			inc = 1;               // 标记进位
			sum.digits[i] -= 10;   // 把结果减去十
		}
		else // 如果不需要进位，把标记清空
			inc = 0;
	}
	return sum;
}

//////////////////// 高精度乘法 ////////////////////
//////// 注意：在极端数据下须适当放宽保存位数 ////////
BigInt multply(BigInt x, BigInt y) {
	BigInt ans, tmp;
    
    // 主要思路就是 取x的每一位和y相乘
	// 然后将结果累加起来
    // 以下的代码将每一位分别相乘的结果放在tmp中
    // 再累加到ans中
    
    for (int i = 1; i <= DIGITS; i++) {
		if (x.digits[i] == 0)  // 如果x的这一位是零
			continue;          // 就可以跳过了
        
        // 清空tmp
		memset(tmp.digits, 0, sizeof(tmp.digits));
        
        // 暴力相乘
		for (int j = 1; j <= DIGITS; j++)
			tmp.digits[i + j - 1] = y.digits[j] * x.digits[i];
            // 这里将乘积放到i位以后（想想竖式乘法）
        
        // 处理进位
		for (int j = 1; j <= DIGITS; j++) {
			tmp.digits[j + 1] += tmp.digits[j] / 10;
			tmp.digits[j] %= 10;
		}
        
        //累加
		ans = add(ans, tmp);
	}
	return ans;
}

// 高精度比较的三种结果
enum Result {
	Less,   // X小于Y
	Equal,  // X等于Y
	Greater // X大于Y
};

//////////////////// 高精度比较 ////////////////////
Result compare(BigInt x, BigInt y) {
	// 这里的back指的是最高的非零位的位数
    //（也可以看成长度）
	int backX = 0, backY = 0;
    
    // 暴力现场求长度
	for (int i = DIGITS; i >= 1; i--) {
		if (x.digits[i] != 0) {
			backX = i;
			break;
		}
	} // 求完X求Y
	for (int i = DIGITS; i >= 1; i--) {
		if (y.digits[i] != 0) {
			backY = i;
			break;
		}
	}
    
    // 如果X比Y长：X大于Y
	if (backX > backY)
		return Greater;
    
    // 如果X比Y短：X小于Y
	else if (backX < backY)
		return Less;

    // 一样长：从最高位开始逐位比较
	else {
		for (int i = backX; i >= 1; i--) {
        	// 每一次能够循环到这里都说明了
            // X和Y之前的位全都一样
            
        	// 如果这一位上X比Y大：X大于Y
			if (x.digits[i] > y.digits[i])
				return Greater;
                
            // 如果这一位上X比Y小：X小于Y
			else if (x.digits[i] < y.digits[i])
				return Less;
		}
        // 之前的所有比较都没有结果：
        // X与Y在每一位上都相等
		return Equal;
	}
}

//////////////////// 高精度减法 ////////////////////
BigInt minusX(BigInt x, BigInt y) {
	BigInt sum;
	int inc = 0; // 借位标志
    
    // 从最低位开始计算
	for (int i = 1; i <= DIGITS; i++) {
    	// 直接减
		sum.digits[i] = x.digits[i] - y.digits[i] + inc;
        
        //如果这一位的结果小于零：要借位
		if (sum.digits[i] < 0) {
			inc = -1;            //标记借位
			sum.digits[i] += 10; //把结果加上十
		}
		else // 如果不需要借位，把标记清空
			inc = 0;
	}
	return sum;
}

string s1, s2;
BigInt x, y;

/////////// 低调的主函数 ///////////
int main(int argc, char* argv[]) {

    // 以字符串输入
	cin >> s1 >> s2;
	
    // 生成高精度数
	x = BigInt(s1);
	y = BigInt(s2);

	// 判断结果是否会是负数
	if (compare(x, y) == Less) { // 如果被减数小于减数
		cout << "-";             // 先输出一个负号
		swap(x, y);              // 交换被减数与减数
	}

	// 计算并输出
	cout << minusX(x, y).toString() << endl;

	return 0;
}
```

---

## 作者：我好蒻呀 (赞：31)

先判断读入的两个数相减会不会产生负数，如果会就输出负号并交换它们。

接着再把字符转化成数字，从低位算到高位，模拟竖式运算的过程。

最后注意输出时不能输出前导零。

···cpp






    
    
    
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std; 
const int maxn = 10010; 
int len1, len2; 
int a[maxn], b[maxn]; 
string s1, s2; 
void swap(string &a, string &b)  //交换两个字符串 
{
    string t; 
    t = a; 
    a = b; 
    b = t; 
}
bool compare(string a, string b) //判断a是否小于b 
{
    if (a.size() < b.size()) return true;  //当a的位数比b小时，a比b小 
    if (a.size() > b.size()) return false; //当a的位数比b大时，a比b大
    for (int i = 0; i < a.size(); ++i)     //剩余情况就是a的位数与b相同 
    {
        if (a[i] > b[i]) return false;     //逐位比较 
        if (b[i] > a[i]) return true; 
    }
    return false; //最后当a与b的各个位的数字都相同时，a等于b 
}
int main()
{
    cin >> s1;           //读入不解释 
    cin >> s2; 
    if (compare(s1, s2)) //如果s1小于s2，就输出符号，并交换它们 
    {
        swap(s1, s2);  
        putchar('-'); 
    }
    len1 = s1.size(); 
    len2 = s2.size(); 
    for (int i = 0; i < len1; ++i) a[len1 - i] = s1[i] - '0'; 
    for (int i = 0; i < len2; ++i) b[len2 - i] = s2[i] - '0'; 
    //将字符转化为数字 
    for (int i = 1; i <= len1; ++i) //从低位算到高位，模拟竖式的运算过程 
    {
        a[i] -= b[i];               //直接用a储存结果：a[i]=a[i]-b[i] 
        if (a[i] < 0)               //如果不够减（减完是负数） 
        {                           
            a[i + 1]--;             //就向高位借一 
            a[i] += 10; 
        }
    }
    while (a[len1] == 0 && len1 > 1) len1--; //去除前导零
    //注意不能把单个零给去掉 
    for (int i = len1; i >= 1; --i)          //从高位到低位输出
      printf("%d", a[i]); 
    return 0; 
}
···
```

---

## 作者：Hammer_cwz_77 (赞：29)

**本题讲解尽在代码中**

\_代码奉上\_：

```cpp
#include <iostream>
#include <cmath>
#include <cstring> 
using namespace std;
int main()
{
    char a[100010],b[100010];//设两个字符串 
    cin>>a>>b;//读入两个字符串 
    int c[100010],d[100010],h[100010],n1,n2,i,f=0,l=0;
    n1=strlen(a);//求字符串长度 
    n2=strlen(b);
    for(i=0;i<n1/2;i++) swap(a[i],a[n1-1-i]);
    for(i=0;i<n2/2;i++) swap(b[i],b[n2-1-i]);
    for(i=0;i<n1;i++) c[i]=a[i]-'0';//把字符串a的字符转化为数字存到数组c当中。其中“-‘0’”为转换方法 
    for(i=0;i<n2;i++) d[i]=b[i]-'0';
    if(n2>n1)//这一步是判断那个数长，哪个就大，就用哪个做被减数存到数组c中，哪个小就存到d中 
    {
        for(i=0;i<n2;i++) swap(c[i],d[i]);//把两数交换，swap为交换函数 
        f=1;//设一个旗帜，以后如果f=1就说明这数被减数比减数小，是负数。 
    }
    if(n1>n2) swap(n1,n2); //取长的做for循环条件 
    for(i=0;i<n2;i++) h[i]=c[i]-d[i];  
    for(i=0;i<n2;i++)//这部就是借位 
    {
         if(h[i]<0)
         { 
             h[i]=10+h[i];
             h[i+1]--; 
         } 
    }
    if(f==1) cout<<"-";//如果f等于一也就是结果为负数，打印“-” 
    for(i=n2-1;i>=0;i--)//这步很重要！ 这是在输出时把首位的0都去掉 
    {
         if(l==0)//设了一个l，如果l为0意味着还没有碰到非零数，也就是有0就要去掉的0 
         {
             if(h[i]!=0) //如果这数不为零 
             {
                 l=1;//l=1表明碰到了非零数了以后的0有实际意义要打印出来 
                 cout<<h[i];//打印此数 
                 continue;//然后跳出本次循环 
             } 
         }
         if(l!=0)//如果l不等于0，就说明这时的0有实际意义，要打印出来 
         {
             cout<<h[i];
         }
    }
}
//一定要看懂再打，别抄题解，这样会害了自己！！

```

---

## 作者：kernel_bin (赞：28)

虽然我超菜，但这道题实在没有什么难度，主要是在这里介绍一种将高精度减法转换为高精度加法，巧妙避免减法借位的方法。
在特定情况下也能优化程序速度。

首先讲原理。
比如我们用253-76，假如直接做减法的话，从末尾开始减，3-6 = -3，需要向前面的5借位。5变成4，4-7=-3还需要借位，以此类推。最后结果是77

借位就很烦。有什么办法能避免借位呢？
其实，253 - 76 = 253 + (999 - 76) + 1 - 1000;
这个应该不难理解，补了1+999，最后减去1000.
这么做的好处是，999-76的过程不需要进行借位。只要直接减就行了。
这样，我们就把一次减法转化为一次加法，一次不需要借位的减法。(-1000那个可以直接通过某些方法消除进位)

下面贴代码，代码里也有注释。

稍稍要注意的是，我们要求被减数比减数更大。这也不难，简单判断一下，如果不行就对调减数和被减数，并标记负号就行了。
```c

#include<stdio.h>
#include<stdlib.h>
typedef unsigned char BYTE;

BYTE a[10005] = { 0 };
BYTE b[10005] = { 0 };
BYTE *pa = 0, *pb = 0;
int la, lb;
int sign;//标明结果正负号用的。 
int main()
{
	scanf_s("%s", a,10005);
	scanf_s("%s", b,10005);
	//通过strlen得出长度，长的那个数字大。一样长比较首位，再一样继续循环第二位直到比出大小。（有一个优化，如果有一位一样那么可以直接消掉）
	la = strlen((char *)a);
	lb = strlen((char *)b);

	//全部减去'0'
	int i;
	for (i = 0; i<la; i++)
	{
		a[i] -= '0';
	}
	for (i = 0; i<lb; i++)
	{
		b[i] -= '0';
	}
	if (la>lb)
	{
		//a大，正
		sign = 1;
	}
	else if (la < lb)
	{
		sign = 0;//负号 
	}
	else
	{
		//开始循环比较，有相等的就直接全部砍掉。
		sign = -1;//标记。如果出来还是-1，说明两数相等 
		int BitCheckTag;
		for (BitCheckTag = 0; BitCheckTag<la; BitCheckTag++)//这里la应该就是lb
		{
			if (a[BitCheckTag] > b[BitCheckTag])
			{
				//a > b
				sign = 1;
				break;
			}
			if (a[BitCheckTag] < b[BitCheckTag])
			{
				sign = 0;
				break;
			}
		}

		if (sign == -1)
		{
			printf("0");
			return 0;
		}
	}


	//这里应该已经标记好位数了。
	if (sign == 1)
	{
		pa = a;
		pb = b;
	}
	else
	{
		pa = b;
		pb = a;
		int buf;
		buf = la;
		la = lb;
		lb = buf;
	}
	//现在pa就是大的那个，开始减吧

	//为了避免借位，采用求补的方法。下面是例子

	//253 - 76 = 253 + (999 - 76) + 1 -1000 
	//我们要做的是对减数求补，位数以被减数的为准。

	//将 pb 后移，和 pa 的结尾对齐
	memmove(pb + la - lb, pb, lb);
	memset(pb, 0, la - lb);

	//按la的长度给pb做求补
	for (i = 0; i < la; i++)//la取不到？ 
	{
		pb[i] = 9 - pb[i];
	}

	pb[la - 1]++;
	//补上加一。如果有超过10也不用管，和被减数相加的时候会处理的。

	for (i = la - 1; i >= 0; i--)
	{
		pa[i] += pb[i];
		if (pa[i] >= 10)
		{
			pa[i] -= 10;
			if (i != 0)
			{
				pa[i - 1] ++;
			}
		}
	}

	for (i = 0; i<la; i++)
	{
		pa[i] += '0';
	}

	if (sign == 0)
	{
		printf("-");
	}
	//去除前导0
	for (i = 0; i<la; i++)
	{
		if (pa[i] != '0')
		{
			printf((char *)pa + i);
			return 0;
		}
	}

	return 0;
}
```




---

## 作者：Morski (赞：27)

## PY大法好！
很多这种直接高精度的题目都是可以直接用Python写的哈哈哈

我是不会说出Python自带高精度的实情的哈哈哈
```python
a = input()
b = input()
print(int(a)-int(b))
```

哈哈哈想不到吧

---

## 作者：liangsheng (赞：12)

在此题中用到了 struct结构体配合string使用。
废话不多，上代码。
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct stu{
    string a1;
    int t;    //用 t 做标记
};
int cmp(stu x, stu y) {
    if(x.a1.size() < y.a1.size()) return 1;  //从小到大排序
    else if(x.a1.size() == y.a1.size() && x.a1 < y.a1) return 1;
    else return 0;
}
int a[1000001], b[1000001];
int main() {
    stu p[2];
    for(int i = 0; i < 2; i++) {   //输入
        cin >> p[i].a1;
        p[i].t = i;         //做标记，最后会用到
    }
    if(p[0].a1 == p[1].a1) {  //特判： 当两数相等 则输出0
        cout << 0 << endl;
        return 0;
    }
    sort(p, p + 2, cmp);
    int len1 = p[1].a1.size(), len0 = p[0].a1.size(), len = len1;    //此时p[1].a1 大于 p[0].a1, len1 大于 len2
    for(int i = len1 - 1; i >= 0; i--) {
        a[len1 - i - 1] = p[1].a1[i] - '0';   //char型 转化为 int 型
    }
    for(int i = len0 - 1; i >= 0; i--) {
        b[len0 - i - 1] = p[0].a1[i] - '0';  //char 型转化为 int 型
    }
    for(int i = 0; i < len; i++) {
        if(a[i] < b[i]) {  
            a[i + 1] -= 1;
            a[i] += 10;
        }
        a[i] -= b[i];
    }
    while(a[len - 1] == 0) len--;
    if(p[1].t > p[0].t) {  //如果满足 p[1].t > p[0].t 证明被减数 比 减数 小， 则最后结果为负数
        cout << '-';
    }
    for(int i = len - 1; i >= 0; i--) {
        cout << a[i];
    }
    printf("\n");
    return 0;
}
```
希望此题解对你有所帮助
第一次发题解，求过

---

## 作者：NKL丶 (赞：11)

## 这一道题目我用的是一种很简单明了的方法~~（其实是因为其他大佬的看不懂）~~
### 主要是用了c++对于字符串来说十分神奇的+号来通过加0来对齐个位（方便计算），同时要用循环加上一个开关来看是否需要进行退位，还有，如果a<b，可以先输出减号然后交换a和b来计算，剩下的就比较简单了，看一下代码的注释就可以了。
奉上代码（应该都看的懂吧）
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;//需要用字符串来储存
int l,l1,c[10005],p;//每一位的差
int main()
{
	cin>>a>>b;
	a='0'+a;
	b='0'+b;//将第0位占0
	if(a.size()<b.size()||(a.size()==b.size()&&a<b))//假如a<b
	{
		cout<<'-';//结果为负数，先输出减号
		swap(a,b);//交换两个数（例如3-5可以变为0-（5-3）），这样子方便后面计算
	}
	l=a.size();
	l1=b.size();
	while(l1<l)//因为已经确保这时b<a了，所以直接在b前面添0
	{
		b='0'+b;
		l1++;
	}//利用c++的特性让个位对齐
	for(int i=1;i<l;i++)c[i]=a[i]-b[i];//计算差
	while(1)//用来退位，因为可能要多次退位，所以用while循环
	{
	p=1;//开关，用来看是否需要退位
	for(int i=1;i<l;i++)
	{
		if(c[i]<0)//需要退位
		{
			c[i-1]--;//向前一位退位
			c[i]=10+c[i];
			p=0;//开关置零，需要重新复查
		}
	}
	if(p)break;//不需要退位了，就退出
	}
	p=1;
	for(int i=1;i<l;i++)
	{
	if(c[i]!=0)p=0;
	if(p==0)cout<<c[i];//特判前导0
	}
	if(p==1)cout<<0;//特判，可能结果本身就为0
	return 0;
}
```

---

## 作者：Mine_King (赞：8)

这题其实很水啦，唯一的问题就是会出现第二个数大于第一个数的情况。  
不会普通高精减的自行百度。  
其实这种情况就是大数减小数，再在前面加一个‘-’就可以了。那么我们要做的就是两点：  
1.判断大小；  
2.调换位置。  
判断大小需要在转化为数组之后，因为字符串的大小判断法则与数不同。  
我们可以这样做：
```
bool dx()
{
    if(l1>l2) return false;
    if(l1<l2) return true;
    for(int i=l1;i>=1;i--)
     if(a[i]<b[i]) return true;
    return false;
}
```
在函数里判断会更方便。交换只要每一位交换就行了  
**上代码**
```
#include <bits/stdc++.h>
using namespace std;
string s1,s2;
int l1,l2,a[10005],b[10005],c[10005];
bool f;//判断是否调换，即是否需要输出'-'
bool dx()//判断大小的函数
{
    if(l1>l2) return false;
    if(l1<l2) return true;
    for(int i=l1;i>=1;i--)
     if(a[i]<b[i]) return true;
    return false;
}
int main()
{
    cin>>s1>>s2;
    l1=s1.length();//转换字符串为数组
    for(int i=0;i<l1;i++) a[l1-i]=s1[i]-48;//数字的ASCII码与其本身相差48
    l2=s2.length();
    for(int i=0;i<l2;i++) b[l2-i]=s2[i]-48;
    if(dx())//如果需要交换
    {
        for(int i=1;i<=l2;i++) swap(a[i],b[i]);//需要交换，则l2一定大于等于l1
        swap(l1,l2);//为了方便，交换l1和l2
        f=true;//标记需要输出'-'
    }
    for(int i=1;i<=l1;i++)
    {
        if(a[i]<b[i])
        {
            a[i]+=10;
            a[i+1]--;
        }
        c[i]=a[i]-b[i];
    }
    while(c[l1]==0&&l1>1) l1--;
    if(f) cout<<'-';
    for(int i=l1;i>=1;i--) cout<<c[i];
    return 0;
}
```
[~~无耻地骗个赞~~](https://www.luogu.org/blog/yhdhg1395754790/)

---

## 作者：yyyyyyy (赞：7)

```cpp
//为什么pascal的都那么长呢？何必那么多优化
var i,lena,lenb,lenc:longint;//lena是被减数的长度，lenb是减数的长度,lenc是差的长度
    a,b,c:array[0..20000] of longint;//数组一点要开的大一点
    n,m,t:ansistring;//用ansistring，因为长度已经超过255了，所以用ansistring（无限长字符串），t是交换变量
begin
readln(n);//读入被减数
readln(m);//读入减数
if (length(n)<length(m))or(length(n)=length(m))and(n<m) then//判断被减数是否比减数小
   begin
   write('-');//输出负号
   t:=n;//交换
   n:=m;
   m:=t;
   end;
lena:=length(n);//赋值被减数长度
lenb:=length(m);//赋值减数长度
for i:=1 to lena do a[lena-i+1]:=ord(n[i])-48;//转数字
for i:=1 to lenb do b[lenb-i+1]:=ord(m[i])-48;//同上
fillchar(c,sizeof(c),0);
i:=0;
while (i<lena)or(i<lenb) do//开减duangduangduang!!!!!!!!!
begin
inc(i);
if a[i]<b[i] then//如果不够减
   begin
   dec(a[i+1]);//借位
   inc(a[i],10);
   end;
c[i]:=a[i]-b[i];//求这位上的数
end;
lenc:=i;//确定差长度
while (c[lenc]=0)and(lenc>1) do dec(lenc);//去除高位上的零
for i:=lenc downto 1 do write(c[i]);//倒序输出
end.
//结束程序
```

---

## 作者：仇哥 (赞：5)

## **这个题解可能实际用处不大，仅供参考**

基于模拟位运和1位ALU（算术逻辑单元）的高精度整型变量。

用人话说，就是封了一个加强版的int，且是用的连续内存存储，即并没有用到数组存十进制，而是用一个一个bit(位)存的连续的二进制数据

啥叫连续呢？就是没有浪费空间，把每一个字节的位都填满了。。(究极压位)

(然后顺便手打了一个带加法器移位器和基本逻辑门的1位ALU，于是就又顺便抛弃了C语言里自带的整型算术运算。。通俗的说就是用1位ALU串行计算，造了一个残废的BIT位ALU(好像并不通俗))

支持加减乘除模以及求逆元

然而因为的的确确是基于模拟位运和ALU，所以。。

最终全都是汇编语法（大雾）

**在NOIP（现在好像改名了？）中没有实际价值，因为用不着这么复杂，直接数组存十进制就行了。前面题解也已经很清楚了**

而且。。因为没有调输入输出格式，并不能A过此题（~~当然硬要调也行~~）

 _~~实际上是身为退役两年的大一caiji翻了几页CSAPP心血来潮打的代码（误）~~_ 
 
####  废话不多说了直接上代码，**可能有点小长**，不过写了注释（因为不写注释连我自己都看不懂）


------------

 
代码核心部分：（_char.h)
```cpp
/************************************************
		How to use:
		_char a; //declare var "a", inital is ZERO
		_char_scan(int argn, _char* a1, _char* a2, ... _char* a(argn)); 
		_char_print(int argn, _char a1, _char a2, ... _char a(argn)); 
		_char_add(_char a, _char b); //a = a+b; 
		_char_sub(_char a, _char b); //a = a-b; 
		_char_mul(_char a, _char b); //a = a*b; 
		_char_inc(_char n); //n = n+1; 
		_char_dec(_char n); //n = n-1; 
		_char_mul(_char n); //eax = eax*n(low), edx = eax*n(high)
		_char_div(_char n); //eax = eax/n, edx = eax%n; 
		
		
		_char_print_bits(_char a); //print a in bits
		_char_cmp(_char a, _char b); //compare (a-b) with ZERO
		CF:carry flag  SF:sign flag  ZF:zero flag
************************************************/
//P.S. Operation Based on serial calculation
#include <stdio.h>
#include <stdarg.h>
#ifndef LEN 
#define LEN 16 //inital is 128-bit
#endif
#define BIT (LEN*8)
#define __swich 1 //function print_char print in bytes(1) or bits(else)
#define INT_BIT BIT //actually could be set as log(10)2 * BIT

bool init_flag; 

//Set offset direction
int offset_address = 0, offset_direction = 1; 
void offset_init() {
	int a = 1; 
	char *p = (char*) &a; 
	if(!*p) {
		offset_address = LEN-1; 
		offset_direction = -1; 
	}
}
	

//Build 128-bit _char, allowed to visit every single bit, automatically offset
struct _iterator {
	char* pointer; 
	char mask; 
}; 
class _char {
	private:
		char alloc_space[LEN]; //Allocating a space for memmory
	public: 
		_iterator visiter; //visit every single bit
		
		_char() {
			if(!init_flag) {
				offset_init(); 
				init_flag = 1; 
			}
			for(int i = 0; i <= LEN-1; i++)
				alloc_space[i] = 0; 
			visiter.pointer = alloc_space + offset_address; 
			visiter.mask = 0x01; 
		}
		void operator = (_char b); 
		void iterator_mov(); 
		void iterator_set(); 
		bool sign(); 
		friend void _char_inc(_char &a); 
		friend void _char_dec(_char &a); //used for hard-ware acculate
}; 
_char ZERO, ONE; 
#define GET_BIT(a) (*a.visiter.pointer & a.visiter.mask)
#define SET_BIT(a) (*(a.visiter.pointer) |= (a.visiter.mask))
#define DEL_BIT(a) (*(a.visiter.pointer) &= (~(a.visiter.mask)))
void _char::iterator_mov() {
	visiter.mask <<= 1; 
	if(!visiter.mask) {
		visiter.mask = 0x01; 
		visiter.pointer += offset_direction; 
	}
}
void _char::iterator_set() {
	visiter.mask = 0x01; 
	visiter.pointer = alloc_space + offset_address; 
}
bool _char::sign() {
	visiter.pointer = alloc_space + offset_address + (LEN-1)*offset_direction; 
	return (*visiter.pointer&0x80); 
}
void _char::operator = (_char b) {
	for(int i = 0; i <= LEN-1; i++)
		alloc_space[i] = b.alloc_space[i]; //tired to visit every bit...
}

_char eax, ebx, ecx, edx; 
bool CF, CF_set; //CF:used for carry flag  CF_set: used in sub operator
bool SF, ZF, OF; //SF:used for sign flag  ZF:used for zero flag   OF:overflow flag
				 //principle: update every flag_register after any calculation
				 //ps:originally it was automatically changed by electrical power
				 
void ALU_not(_char &a) { 		   //a.point_bit = ~a.point_bit
	*(a.visiter.pointer) ^= (a.visiter.mask); 
}
void ALU_and(_char &a, _char &b) { //a.point_bit &= b.point_bit
	if(!GET_BIT(b)) DEL_BIT(a); 
}
void ALU_or (_char &a, _char &b) { //a.point_bit |= b.point_bit
	if(GET_BIT(b)) SET_BIT(a); 
}
void ALU_add(_char &a, _char &b) { //1 adder: a.point_bit = a.p_b+b.p_b+CF  update CF
	CF_set = (GET_BIT(a) && GET_BIT(b)) || (GET_BIT(a) && CF) || (GET_BIT(b) && CF); 
	*(a.visiter.pointer) ^= GET_BIT(b); 
	if(CF) *(a.visiter.pointer) ^= (a.visiter.mask); 
	CF = CF_set; 
	CF_set = 0; 
}
void ALU_shl(_char &a) {		   //shift left logically
	_char shl_reg = ZERO; 
	a.iterator_set(); 
	shl_reg.iterator_set(); 
	shl_reg.iterator_mov(); //move left one bit
	for(int cnt = 1; cnt <= BIT-1; cnt++) {
		if(GET_BIT(a)) SET_BIT(shl_reg); 
		a.iterator_mov(); 
		shl_reg.iterator_mov(); 
	}
	CF = GET_BIT(a); 
	a = shl_reg; 
}

void _char_not(_char &a) { 			 // a = ~a
	a.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		ALU_not(a); 
		a.iterator_mov(); 
	}
	CF = SF = ZF = 0; 
}
void _char_mov(_char &a, _char &b) { // a = b
	a = b; 
	CF = ZF = SF = 0; 
}
void _char_add(_char &a, _char &b) { // a = a+b, overflow in CF
	CF = CF_set; //alternativly decide whether +1 or not
	CF_set = 0; 
	OF = 0; 
	a.iterator_set(); 
	b.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		ALU_add(a, b); 
		if(cnt == BIT-1 && GET_BIT(a)) OF = 1; 
		a.iterator_mov(); 
		b.iterator_mov(); 
	}
	CF = CF; SF = ZF = 0; 
}

void _char_inc(_char &a) { 			 // a = a+1
	a.iterator_set(); 
	if(GET_BIT(a)) {
		_char ONE; 
		SET_BIT(ONE); 
		_char_add(a, ONE); 
	}
	else SET_BIT(a); 
}
void _char_dec(_char &a) { 			 // a = a-1
	a.iterator_set(); 
	if(!GET_BIT(a)) {
		_char ONE; 
		SET_BIT(ONE); 
		_char_add(a, ONE); 
	}
	else DEL_BIT(a); 
}
void _char_cpm(_char &a) { 			// a = complement(a)
	_char_not(a); 
	_char_inc(a); 
}
void _char_sub(_char &a, _char  b) { // a = a-b, overflow in CF
	_char_cpm(b); 
	_char_add(a, b); 
}
void _char_cmp(_char  a, _char  b) { // update flag_regester with sign of (a-b)
	_char_sub(a, b); //a&b's value is static, now a = a-b
	a.iterator_set(); 
	bool or_gate_container = GET_BIT(a); 
	for(int i = 1; i <= BIT-1; i++) {
		a.iterator_mov(); 
		if(GET_BIT(a))
			or_gate_container = 1; 
	}
	
	ZF = SF = 0; 
	if(GET_BIT(a)) SF = 1; 
	else if(!or_gate_container) ZF = 1;  
}	
void _char_mul(_char &a, _char &b) { // a = a*b, overflow will be lost
	_char a_mov = a; 
	_char_mov(a, ZERO); //a_mov = a; a = a_mov*b; 
	a_mov.iterator_set(); 
	b.iterator_set(); 
	CF_set = 0; //avoid add_operator overflow in CF which could influence the calculation
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(GET_BIT(b)) //call control_module
			_char_add(a, a_mov); 
		ALU_shl(a_mov); 
		b.iterator_mov(); 
	}
	SF = ZF = 0; 
}
void _char_mul(_char &a) { 		 // eax = eax*a, edx = higher bits    only unsigned numbers
	_char eax_mov = eax; //eax_mov: while shift left, lower bits(add on eax)
	_char eax_extra;  //eax_extra: higher bits(add on edx)  inital is ZERO
	_char_mov(eax, ZERO); 
	_char_mov(edx, ZERO); 
	eax_mov.iterator_set(); 
	a.iterator_set(); 
	CF_set = 0; //avoid add_operator overflow in CF which could influence the calculation
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(GET_BIT(a)) { //call control_module
			_char_add(eax, eax_mov); 
			if(CF) _char_inc(edx); //eax overflow into edx
			_char_add(edx, eax_extra); 
		}
		ALU_shl(eax_mov); //shift left, if highest bit == 1 then CF = 1, move into eax_extra
		if(CF) {
			ALU_shl(eax_extra); 
			_char_inc(eax_extra); //equels to SET_BIT(eax_extra), pointer = 1
		}
		else ALU_shl(eax_extra); //overflow into higher bits
		a.iterator_mov(); 
	}
	SF = ZF = 0; 
}
void _char_div(_char  a) { 		 // eax = eax/a, edx = eax%a(ps:without edx storing bits)
	bool sign_flag = 0; 
	if(eax.sign()) {
		sign_flag = 1; 
		_char_cpm(eax); 
	}
	if(a.sign()) {
		_char_cpm(a); 
		sign_flag = (sign_flag) ? 0 : 1; 
	}
	
	bool eax_stack[BIT+3]; 	
	bool ans_stack[BIT+3] = {0}; 
	//ps:in div operation, poccesion are calulated in inversed direction

	eax.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		eax_stack[cnt] = GET_BIT(eax); 
		eax.iterator_mov(); 
	}
	//push every bit in rule   then pop in inverse way
	//equels to inverse the whole _char eax 
	
	_char_mov(edx, ZERO); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		ALU_shl(edx); 
		if(eax_stack[BIT+1-cnt]) _char_inc(edx); //(inverse) get new bits
		_char_cmp(edx, a); 
		if(!SF || ZF) { //edx !< a or edx == a
			_char_sub(edx, a); 
			ans_stack[cnt] = 1; //successfully div this bit
		}
		eax.iterator_mov(); 
	}
	
	_char_mov(eax, ZERO); 
	eax.iterator_set(); 
	for(int cnt = BIT; cnt >= 1; cnt--) {
		if(ans_stack[cnt]) SET_BIT(eax); 
		eax.iterator_mov(); 
	}
	if(sign_flag) {
		_char_cpm(eax); //set sign...because c is round numbers to zero, so in a/b=c...d, c*b <= a
		_char_cpm(edx); //so if the equation is negative the remains are negative too.
	}
	CF = SF = ZF = 0; 
}

```



------------
其实有了上面的就可以实现加减乘除模了，下面是IO的部分（因为是基于2进制，输入输出10进制就很蛋疼，需要手动转换。。那个模拟手算的时间复杂度我都有点看不下去然而什么办法也没有）

以下为_char_io.h:
```cpp
//io head 
#ifndef _CHAR_H 
#include "_char.h"
#define _CHAR_H
#endif

void _char_print_bits(_char ch) { //print _char in bits
	ch.iterator_set(); 
	bool cache[BIT+3]; 
	for(int i = 1; i <= BIT; i++) {
		cache[i] = GET_BIT(ch); 
		ch.iterator_mov(); 
	}
	for(int i = 1; i <= BIT; i++) {
		printf("%d", cache[BIT+1-i]); 
		if(__swich != 1) printf("|"); 
		if(__swich == 1 && i%8 == 0) printf(" "); 
		if(i%64 == 0) printf("\n"); 
	}
	printf("\n"); 
}

void scan_int(_char &ch) {	//scan _char in int
	char num[INT_BIT+2] = {0}; 
	bool num_add, sign_flag = 0; 
	int _strlen; 
	while(((num[1] = getchar()) > '9' || num[1] < '0') && num[1] != '-'); 
	if(num[1] == '-') {
		sign_flag = 1; 
		num[1] = getchar(); 
	}
	for(_strlen = 2; (num[_strlen] = getchar()) >= '0' && num[_strlen] <= '9'; _strlen++); 
	for(int i = 1; i <= _strlen-1; i++) num[i] -= '0'; 
	//_strlen is pointing on end (_strlen-1 is usable)
	ch.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		for(int i = 1, num_add = 0; i <= _strlen-1; i++) {
			if(num_add) {
				num[i] += 10; 
				num_add = 0; 
			}
			if(num[i]%2) num_add = 1; 
			num[i] >>= 1; 
			
			if(i == _strlen-1 && num_add) SET_BIT(ch); 
		}
		ch.iterator_mov(); 
	}
	if(sign_flag) {
		_char_not(ch); 
		_char_inc(ch); 
	}
}
void print_int(_char ch) {	//print _char in int
	char num[INT_BIT+2] = {0}; //in this function num & ch is stored inversed
	bool num_add; 
	bool ch_stack[BIT+5] = {0}; 
	int i; 
	
	ch.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(GET_BIT(ch)) ch_stack[cnt] = 1; 
		ch.iterator_mov(); 
	}
	
	for(int cnt = 1; cnt <= BIT; cnt++) {
		num_add = 0; 
		if(ch_stack[BIT+1-cnt])	num_add = 1; 
		for(i = 1; i <= INT_BIT; i++) {
			num[i] = num[i]*2+num_add; 
			num_add = 0; 
			if(num[i] >= 10) {
				num[i] -= 10; 
				num_add = 1; 
			}
		}
	}
	
	for(i = INT_BIT; i >= 1 && num[i] == 0; i--) ; 
	if(i == 0) putchar('0'); 
	else for(; i >= 1; i--) putchar(num[i]+'0'); 
}
void print_signed_int(_char ch) {	//print _char in int
	ch.iterator_set(); 
	for(int cnt = 1; cnt <= BIT-1; cnt++)
		ch.iterator_mov(); 
	if(GET_BIT(ch)) {
		_char_not(ch); 
		_char_inc(ch); 
		putchar('-'); 
	}
	print_int(ch); 
}
void _char_long_print() {	//print eax, edx
	char num[2*INT_BIT+2] = {0}; //in this function num & ch is stored inversed
	bool num_add; 
	bool ch_stack[BIT+5] = {0}; 
	int i; 
	
	_char ch; 
	_char_mov(ch, edx); 
	ch.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(GET_BIT(ch)) ch_stack[cnt] = 1; 
		ch.iterator_mov(); 
	}
	for(int cnt = 1; cnt <= BIT; cnt++) {
		num_add = 0; 
		if(ch_stack[BIT+1-cnt]) num_add = 1; 
		for(i = 1; i <= 2*INT_BIT; i++) {
			num[i] = num[i]*2+num_add; 
			num_add = 0; 
			if(num[i] >= 10) {
				num[i] -= 10; 
				num_add = 1; 
			}
		}
	}
	
	_char_mov(ch, eax); 
	ch.iterator_set(); 
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(GET_BIT(ch)) ch_stack[cnt] = 1; 
		else ch_stack[cnt] = 0; 
		ch.iterator_mov(); 
	}
	for(int cnt = 1; cnt <= BIT; cnt++) {
		if(ch_stack[BIT+1-cnt])	num_add = 1; 
		for(i = 1; i <= 2*INT_BIT; i++) {
			num[i] = num[i]*2+num_add; 
			num_add = 0; 
			if(num[i] >= 10) {
				num[i] -= 10; 
				num_add = 1; 
			}
		}
	}
	
	for(i = 2*INT_BIT; i >= 1 && num[i] == 0; i--) ; 
	if(i == 0) putchar('0'); 
	else for(; i >= 1; i--) putchar(num[i]+'0'); 
}
void _char_scan(int argn, ...) {	//scan _char in various args
	va_list(pointer); 
	va_start(pointer, argn); 
	_char *buf; 
	for(int i = 1; i <= argn; i++) {
		buf = va_arg(pointer, _char*); 
		scan_int(*buf); 
	}
	va_end(pointer); 
}
void _char_print(bool flag, int argn, ...) {	//print _char in various args
	va_list(pointer); 
	va_start(pointer, argn); 
	_char buf; 
	for(int i = 1; i <= argn; i++) {
		buf = va_arg(pointer, _char); 
		if(!flag) print_int(buf); 
		else print_signed_int(buf); 
		putchar(' '); 
	}
	va_end(pointer); 
} 
```


------------

现在的代码就已经支持加减乘除模以及IO了，然而还有个求逆元，我用的exgcd。上面有算法原理，想要科普的直接出门左转拓欧板子

由于完全是汇编语法所以函数里面看得可能有点蛋疼，加了注释希望可以看得懂。。

以下为_char_inverse.h
```cpp
/*ex_gcd:get the solution of the equation  ax + by = 1
	∵a = [a/b]*b + a%b 
	∴equation: ([a/b]*b + a%b)x + by = 1
				b*([a/b]+y) + (a%b)*x = 1
				  =>  b*x' + (a%b)*y' = 1
	then recursion and calculate bx' + (a%b)y' = 1
		=> ...
		
	Using ex_gcd get inverse element:
		a*(a^-1) = 1(mod b)  =>  (a(a^-1)-1)%b = b*0
		  =>  exist y, a(a^-1)-1 = b*y , let x = a^-1
		  =>  exist y, ax + by = 1
	then use ex_gcd get the solution of x  =>  a^-1.
	
*/
#ifndef _CHAR_H 
#include "_char.h"
#define _CHAR_H
#endif

void ex_gcd(_char a, _char b, _char &x, _char &y) {
	_char div_ans; 
	_char_cmp(b, ZERO); //b == 0?
	if(!ZF) goto j1; 
		_char_mov(x, ZERO); 
		_char_inc(x); //x = 1
		_char_mov(y, ZERO); //init recall calculatioin
		_char_mov(ecx, a); //gcd is returned in ecx (but no egg use)
		goto ret; 
	j1: 				//b != 0
		_char_mov(eax, a); 
		_char_div(b); //eax = a, eax/b -> eax   eax%b -> edx
		_char_mov(div_ans, eax); //store value in eax[eax/b] into ebx, in case to be replaced
		
		ex_gcd(b, edx, x, y); //ecx = ex_gcd
		
		_char_mov(eax, div_ans); 
		_char_mul(y); //eax = div_ans = a/b   eax*y(low) -> eax, eax*y(high) -> edx
		_char_mov(ebx, x); 
		_char_mov(x, y); 
		_char_sub(ebx, eax); //ebx = x-a/b*y
		_char_mov(y, ebx); //x = y, y = y-a/b*y, recall calculate is done
	ret:
		return; 
}
void _char_inv(_char &mod_num) { //get inverse element, stored into eax
	_char x, y; 
	ex_gcd(eax, mod_num, x, y); //in case x is negative: x = ((x%m)+m)%m
	_char_mov(eax, x); 
	_char_div(mod_num); 
	_char_mov(eax, edx); 
	_char_add(eax, mod_num); 
	_char_div(mod_num); 
	_char_mov(eax, edx); 
} 
```

------------
最后就是翘首以待的main函数主体了
（其实就是纯粹给你做了个UI而已）

宏里面那个LEN是存储的字节大小，在这里是128字节也就是1024位的数字，有兴趣可以手动改改

以下为calculate.cpp
```cpp
#define LEN 128
#include "_char_io.h"
#include "_char_inverse.h"

int main() {
	_char a, b; 
	printf("Insert %d-bit numbers:  ", BIT); 
	_char_scan(2, &a, &b); 
	
	_char_mov(eax, a); 
	_char_add(eax, b); 
	printf("a + b : "); 
	_char_print(1, 1, eax); 
	
	_char_mov(eax, a); 
	_char_sub(eax, b); 
	printf("\na - b : "); 
	_char_print(1, 1, eax); 
	
	_char_mov(eax, a); 
	_char_mul(eax, b); 
	printf("\na * b (%d-bit): ", BIT); 
	_char_print(1, 1, eax); 
	
	_char_mov(eax, a); 
	_char_mul(b); 
	printf("\na * b (%d-bit): ", BIT*2); 
	_char_long_print(); //only can print unsigned numbers
	
	
	_char_mov(eax, a); 
	_char_div(b); 
	printf("\na / b : "); 
	_char_print(1, 1, eax); 
	printf("\na %% b : "); 
	_char_print(1, 1, edx); 
	
	
	printf("\na*x ≡1 (mod b)  x : "); 
	_char_mov(eax, a); 
	_char_inv(b); 
	_char_cmp(eax, ZERO); 
	if(ZF) 	printf("(NULL)\n"); 
	else _char_print(1, 1, eax); 
	
	
	printf("\n\nPress any key to continue..."); 
	getchar(); 
	return 0; 
}
```


------------
![](http://a3.qpic.cn/psb?/V110NH9Y066OtS/SrmW.2SjvGJ1spLCvwQYlCmbNqpfQ3hEd0chtI1QLLI!/c/dFIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=rQXZAq0F2QIRADc!&amp;tl=1&amp;tm=1571677200&amp;sce=0-12-12&amp;rf=0-18)

实测效果非常好（就是LEN上了128以后求逆会变慢，常数太大了）

有兴趣或者有bug可以在评论区私戳我哟（手动卖萌）

---

## 作者：滑大稽 (赞：5)

## 首先，我看到各位dalao们的题解，我自愧不如，但我的方法可能 ~~更~~ 比较好理解，所以我来写一篇。管理员大大~~仁慈~~ 宽松一下
### 基本思路
就是一个~~普通~~比较简单的高精减高精，再加个为负数的特判~~而已~~。

### 关于借位
先不管它，直接减，后加个判断，如果小于0，后一位-1，这一位+10。

### 关于负数特判
大家都知道，a-b=-(b-a),所以我们只用加个特判，判断a是否小于b，若小于，输出“-”,再交换a，b即可。

### 上代码
```
#include<iostream>
#include<cstring>
using namespace std;
int q1[10005]={0},q2[10005]={0},s[10006]={0};
int main()
{
    string a,b;
    cin>>a>>b;
    if((a.size()<b.size())||(a.size()==b.size()&&a<b))//特判比较a,b大小
    {
        string t=b;
        b=a;a=t;//交换a,b 
        cout<<"-";//输出负数 
    }
    int c1=a.size(),c2=b.size(),i;
    for(i=0;i<c1;i++)q1[c1-i-1]=a[i]-'0';
    for(i=0;i<c2;i++)q2[c2-i-1]=b[i]-'0';//整型数组倒序存储 
    i=0;
    while(i<=c1||i<=c2)//确认两个字符串都处理完了
    {
        s[i]+=q1[i]-q2[i];
        if(s[i]<0)//若不够减 
        {
            s[i+1]--;
            s[i]+=10;//朝上一位借1 
        }
        i++;//跟着减
    }
    i--;//循环中多加了1，要减掉 
    while(i>0&&!s[i])i--;//去掉首位0 
    for(;i>=0;i--)cout<<s[i];//倒序输出
}
```
~~辛苦~~写这么久，管理员大大放过我吧

---

## 作者：Archer_ (赞：4)

蒟蒻的第一篇题解  
~~因为比较懒~~所以就只写了减法的,不像其他巨佬写了加减乘除的模板  
### 我是这么做的：  
用两个char数组存放a,b两个高精度的数，然后读出较长长度数组的长度，倒序扔进另外两个数组以便一位一位运算。用另一个数组存放9999……（大概就是为了避免退位的问题把它当成加法做，ex：2-457=2+1+（999-457）-1000）如同-1000的操作可以后续在分类判断。这时候如果出现很长的相同的数相减就会出现很多个0，所以需要特殊设个情况，不多说了，请看代码。  


------------
```cpp
#include<cstdio>
#include<iostream>
#include<string.h>
#include<string>
#include<algorithm>
using namespace std;

int main(){
    char a[100000],b[100000];
    int aa[100000],bb[100000];
    int alen=-1,blen=-1;
    int m=0;
    scanf("%s%s",&a,&b);
    int c[100000];
    int lena,lenb,l;
    lena=strlen(a);
    lenb=strlen(b);
    l=max(lena,lenb);
    for(int i=lena-1;i>=0;i--){
    	aa[++alen]=a[i]-'0';
    }
    for(int i=lenb-1;i>=0;i--){
        bb[++blen]=b[i]-'0';
    }
    int d[100000];//和99999……(n-1个9)的数组

    for(int i=0;i<l;i++){
        d[i]=9;
    }
    c[0]+=1;
    for(int i=0;i<l;i++){
        c[i]+=aa[i]-bb[i]+d[i];
        if(c[i]>=10){
            c[i]-=10;
            ++c[i+1];

        }
    }
    for(int i=l-1;i>=0;i--){
        if(c[i]!=0) m++;
    }//这时候的c[ ]存的是10^(l+1)-(a-b)
    if(m!=0){
        if(c[l]==0){//如2-457+999+1的位数与457是一样的
            for(int i=0;i<l;i++){
                if(c[i]!=0) {
                    c[i]-=1;
                    for(int j=i;j<l;j++){
                        c[j]=9-c[j];
                    }
                    break;
                }
            }
            cout << '-';
        }

        for(int i=l-1;i>=0;i--){//倒着输出
    	    cout << c[i] ;
        }
    }
    if(m==0){
        cout << '0';
    }
    return 0;
}
```  

------------

qwq感谢阅读

---

## 作者：BrandonSoong (赞：3)

****
========================================================

=======================开始分割线========================

========================================================
***
## **一、用类封装的好处：**
- 1、方便使用，用法可以类比int，long long
- 2、可变性强，能够自定义许多东西，比如> , > , - , + , =(int/long long/string)等等
- 3、看着很清爽，敲代码心情舒畅
- 4、便于查错，程序耦合性低，IT公司工程码风
- 5、~~装逼~~
***
## **~~二、废话不多说：~~**

**看代码，学高精。有不懂，请私信。**

**类封装，好处多。查错快，耦合低。**

**高精加，高精减。高精乘，高精除。**

**用封装，都可行。不封装，脑ko晕。**

**存矩阵，做图论。线段树，Link Cut Tree。**

**存结构，存类型。想得到，都能存。**

**可装逼，又实用。学一手，乐悠悠。**
***
## **[[ AC ] ](https://www.luogu.org/record/25841504)代码：**
```cpp
#include<bits/stdc++.h>
#define maxn 20000
using namespace std;
int _=0,__=0,___=0;//最后撒花完结使用
string a,b;
class data
{
    private://private[私有的]，从这开始到public的内容只有在class里面才能使用，相当于是手机的主板
        
        int len,a[maxn];
        bool flag;// 1 - positive number ; 2 - negative number
        
        //退位，类似于【加法乘法的 jw()】
        inline void tw()
        {
            for(int i=1;i<=len;i++)
            {
                if(a[i]<0)
                {
                    a[i]+=10;
                    a[i+1]--;
                }
            }
            while(!a[len]&&len)len--;//去除前导0
        }

        /*
        重载运算符
        [类型] operator [符号] ( [传参] ) 【const】
        ps.最后可以不加const，加个const指函数内部不能修改参数信息，只能比较
        pss.传参内容中常写有const [类型] &x ,指的是这个参数不能改变，只能参与运算比较,不需要也可以直接写 [类型] x 
        */

       //重载 < 运算符
        bool operator <(const data &b)
        {
            if(flag&&!b.flag)return false;//我+你-
            if(!flag&&b.flag)return true;//我-你+
            if(flag&&b.flag)//咱俩都+
            {
                if(len<b.len)return true;
                if(len>b.len)return false;
                for(int i=len;i>=1;i--)
                if(a[i]<b.a[i])return true;
                else if(a[i]>b.a[i])return false;
                return false;
            }
            //咱俩都-
            if(len<b.len)return false;
            if(len>b.len)return true;
            for(int i=len;i>=1;i--)
            if(a[i]<b.a[i])return false;
            else if(a[i]>b.a[i])return true;
            return false;
        }
        
        //交换俩data
        inline void swap(data &A,data &B)
        {
            data C=A;
            A=B;
            B=C;
        }

    public://public[公开的]，从这开始到结束的内容可以全局调用以及查看，相当于是手机的显示屏
        
        //构造函数  注意！！类的constructor必须写在public后边！！
        data(void)
        {
            len=0;
            for(int i=0;i<=maxn;i++)
            a[i]=0;
            flag=1;//注意初始化的flag=1。
        }
        
        //重载 - 运算符（这个地方没有去特判减数或被减数为负的情况，具体的操作和这个类似。
        data operator -(const data &B)
        {
            data a,b,c;
            a=(*this);//this 是现在调用的类的指针，加个*号就相当于是自己。
            b=(data)B;
            if(a<b)
            {
                swap(a,b);
                c.flag=0;//注意要改变flag
            }
            c.len=a.len;
            for(int i=1;i<=c.len;i++)
            c.a[i]=a.a[i]-b.a[i];
            c.tw();
            return c;
        }

        //打印函数，注意要特判0的情况
        inline void print()
        {
        	if(!len)
        	{
        		printf("0");
				return;
			}
            if(!flag)cout<<"-";
            for(int i=len;i>=1;i--)
            printf("%d",a[i]);
        }

        //重载 = 运算符，用 string 给 data类 赋值
        void operator =(string s)
        {
            if(s[0]=='-')//假如是负数
            {
                flag=0;
                s.erase(0,1	);//删除 -号
            }
            len=s.length();
            for(int i=len;i>=1;i--)
            a[len-i+1]=s[i-1]^48;
        }
}x,y;
inline void initialization()//初始化
{
    cin>>a>>b;//输入俩string
    //分别赋值
    x=a;
    y=b;
}
int main()
{
    initialization();
    data substraction=x-y;//减
    substraction.print();//打印
    return 0^_^0|0^__^0|0^___^0|0^__^0|0^_^0;//撒花完结！！ 
}
```
***
Thx for watching with patience
========================================================

========================================================

=======================结束分割线========================

========================================================

---

## 作者：oreimo_eromanga (赞：3)

```cpp

#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<string>
#include<cstdio>
#include<cmath>
using namespace std;
int pd(int a,int b) //编一个判断函数，可以使程序更美观。
{
    if(a<b) return -1;
    if(a==b) return 0;
    if(a>b) return 1;
}
int add2(string &a,string &b) //用函数可以方便以后做加减乘除合为一体的一道题。
{
    int a1[1001],b1[1001],c1[1001];
    int alen=a.size();
    int blen=b.size();
    int y,big;string k;
    if(alen>blen){big=alen;} else {big=blen;}
    for(int i=0;i<big;i++)
    {
       if(pd(alen,blen)>0){break;}
       if(pd(alen,blen)==-1)
       {
              cout<<"-";
              y=alen;
              alen=blen;
              blen=y;
              k=a;
              a=b;
              b=k;
              break;
       }
    }
    for(int i=0;i<alen;i++)
       a1[alen-i]=a[i]-'0';
    for(int i=0;i<blen;i++)
       b1[blen-i]=b[i]-'0';
    int i=1;
    while(i<=alen||i<=blen) //去前导0.
    {
      if(a1[i]<b1[i])
      {
        a1[i]+=10;a1[i+1]--;
      }
      c1[i]=a1[i]-b1[i];
      i++;
    }
    int lenc1=i;
    while((c1[lenc1]==0)&&(lenc1>1))
      lenc1--;
    for(int j=lenc1;j>=1;j--)
       cout<<c1[j];
    cout<<endl;
}
int main()
{
    string a,b;
    cin>>a>>b;
    add2(a,b);
}
//谢谢欣赏。

```

---

## 作者：fpjo (赞：3)

本蒟蒻的第一篇博客哈！！！

#### **~~高精度减法。~~**

### **流程**：

1. 读入两个数A、B（string）

1. 判断大小，确定符号

1. 处理两数，读入数组

1. 运算：

a. 看是否借位

b. 相减

c. 结果的位数++

1. 判断“0”是否有用

1. 打印结果


------------


**下面献上本蒟蒻的代码**






```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a[100000]={0},b[100000]={0},c[100000]={0};
    //清零数组，个人感觉比memset好用 
    void pminus(){
        int i=0;
        while(i<=a[0]){
            i++;//这个纯粹只是不想打c[0]
            if(a[i]<b[i]){//借位
                a[i+1]--;
                a[i]+=10;
            }
            c[i]=a[i]-b[i];
            c[0]++;//位数 
        }
    }
    int main(){
        int i,j,k,l,m,n,flag;
        string an,bn,t;
        cin>>an>>bn;
        a[0]=an.length();
        b[0]=bn.length();
        if(a[0]<b[0] || (a[0]==b[0] && an<bn)){
        //比较大小，如果小就交换。
            t=bn;
            bn=an;
            an=t;
            swap(a[0],b[0]);
            cout<<"-";//是的话就输出“-”
        }
        for(i=1;i<=a[0];i++) a[i]=an[a[0]-i]-'0';
        for(i=1;i<=b[0];i++) b[i]=bn[b[0]-i]-'0';
        pminus();
        while(c[c[0]]==0&&c[0]>1) c[0]--;
     //判断0是否有用。 “c[0]>1”是因为减会减多，从而使c[0]=0
        for(i=c[0];i>=1;i--) cout<<c[i];//倒序输出
        return 0;
}
```

---

## 作者：surpassion (赞：3)

这么多纯高精度版，我就发一篇运算符重载版吧！

大家也可以学一下BIGNUM，即运算符重载版高精度运算。。。

加减乘除和读入输出都有哦！

如有不足之处请各位大佬们多多指教本小蒟蒻。****


## 附上代码，相信大家都能看懂


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 20000; 
struct bign{ 
  int len, s[maxn]; 
```
/\*以下的构造函数是C++中特有的，作用是进行初始化。
事实上，当定义bign x时，就会执行这个函数，把x.s清零，并赋x.len=1 。

需要说明的是，在C++中，并不需要typedef就可以直接用结构体名来定义，而且

还提供“自动初始化”的功能，从这个意义上说，C++比C语言方便

\*/
   
   
```cpp
  bign() { 
    memset(s, 0, sizeof(s)); 
    len = 1; 
  } 
  bign(int num) { 
    *this = num; 
  } 
  //定义为const参数，作用是 不能对const参数的值做修改  
  bign(const char* num) { 
    *this = num; 
  } 
```
/\*以上是构造方法，初始化时对执行相应的方法\*/
   
   
     
     
     
```cpp
  bign operator = (int num) { 
    char s[maxn]; 
    sprintf(s, "%d", num); 
    *this = s; 
    return *this; 
  }  
  //函数定义后的const关键字，它表明“x.str()不会改变x”  
  string str() const { 
    string res = ""; 
    for(int i = 0; i < len; i++) res = (char)(s[i] + '0') + res; 
    if(res == "") res = "0"; 
    return res; 
  } 
  void clean() { 
    while(len > 1 && !s[len-1]) len--; 
  } 
```
/\* 以下是重载操作符 \*/
     
   
   
   
   
   
   
   
   
   
   
```cpp
  bign operator = (const char* num) { 
    //逆序存储，方便计算  
    len = strlen(num); 
    for(int i = 0; i < len; i++) s[i] = num[len-i-1] - '0'; 
    return *this; 
  } 
  bign operator + (const bign& b) const{ 
    bign c; 
    c.len = 0; 
    for(int i = 0, g = 0; g || i < max(len, b.len); i++) { 
      int x = g; 
      if(i < len) x += s[i]; 
      if(i < b.len) x += b.s[i]; 
      c.s[c.len++] = x % 10; 
      g = x / 10; 
    } 
    return c; 
  } 
  bign operator * (const bign& b) { 
    bign c; c.len = len + b.len; 
    for(int i = 0; i < len; i++) 
      for(int j = 0; j < b.len; j++) 
        c.s[i+j] += s[i] * b.s[j]; 
    for(int i = 0; i < c.len-1; i++){ 
      c.s[i+1] += c.s[i] / 10; 
      c.s[i] %= 10; 
    } 
    c.clean(); 
    return c; 
  } 
  bign operator - (const bign& b) { 
    bign c; c.len = 0; 
    for(int i = 0, g = 0; i < len; i++) { 
      int x = s[i] - g; 
      if(i < b.len) x -= b.s[i]; 
      if(x >= 0) g = 0; 
      else { 
        g = 1; 
        x += 10; 
      } 
      c.s[c.len++] = x; 
    } 
    c.clean(); 
    return c; 
  } 
  bool operator < (const bign& b) const{ 
    if(len != b.len) return len < b.len; 
    for(int i = len-1; i >= 0; i--) 
      if(s[i] != b.s[i]) return s[i] < b.s[i]; 
    return false; 
  } 
  bool operator > (const bign& b) const{ 
    return b < *this; 
  } 
  bool operator <= (const bign& b) { 
    return !(b > *this); 
  } 
  bool operator == (const bign& b) { 
    return !(b < *this) && !(*this < b); 
  } 
  bign operator += (const bign& b) { 
    *this = *this + b; 
    return *this; 
  } 
}; 
istream& operator >> (istream &in, bign& x) { 
  string s; 
  in >> s; 
  x = s.c_str(); 
  return in; 
} 
ostream& operator << (ostream &out, const bign& x) { 
  out << x.str(); 
  return out; 
} 
int main() { 
  bign a,b;
  cin>>a>>b;
  if (a<b) cout<<"-"<<b-a<<endl; else cout <<a-b<< endl; 
  return 0; 
} 
```

---

## 作者：灵光一闪 (赞：2)

虽然感觉好像已经有很多题解了，但是毕竟这个高精减我摸索了一下午啊qaq ~~（我还是太弱了qaq）~~

这个我觉得适合新人来理解 ~~（dalao请使用高端算法爆切即可~~

这个高精就是用电脑模拟我们算高精的方法，就像竖式一样，比如像这样：
```
  ···
 2333
- 666
——————
 1667
```
但是这个题难在细节部分啊qaq，（虽然可能泥萌都会觉得我太傻了qaq）  

code:
```
//鸭哥哥保佑我AC鸭！
//荷兰猪保佑我AC鸭！
//这上面的东西亲测有用↑(逃
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<string>
using namespace std;
string s,t;//一开始的被减数和减数
int a[23333];
int b[23333];//转化后的被减数和减数
int arr[23333];//答案数组
bool flag=false;//是不是负数
int main(){
    cin>>s>>t;//输入
    if(s.size()<t.size()){//如果s<t就说明是负数
        string tep=s;//一个转换，让s始终大
        s=t;
        t=tep;
        flag=true;//负数
    }
    else if(s.size()==t.size()){
        if(s<t){//s还是大
            string tep=s;
            s=t;
            t=tep;
            flag=true;//不解释惹！
        }
        else if(s==t){//......
            puts("0");
            return 0;
        }
    }
    while(s.size()>t.size()){//然后要补上0（还记得1年级的时候没有补0占位吗）
        t='0'+t;
    }
    for(int i=s.size()-1;i>=0;i--){//转化数字
        a[i]=s[i]-'0';
    }
    for(int i=t.size()-1;i>=0;i--){//同上一个循环
        b[i]=t[i]-'0';
    }
    int less=0;//是否退位
    for(int i=s.size()-1;i>=0;i--){
        b[i]+=less;//也可以写成a[i]-=less;
        if(a[i]<b[i]){//要有退位了
            arr[i]=10+a[i]-b[i];//从前面借10过来
            less=1;//然后标注一下
        }
        else{
            arr[i]=a[i]-b[i];//不然就正常地减
            less=0;//然后要标注一下！
        }
    }
    if(flag){//负数，先行输出"-"号
        putchar('-');
    }
    bool zero;//剔除前导0的利器
    if(arr[0]==0){//然后先判断一下这个第一位是不是0，这里一定要先在循环前面判断一次，不然01111或者11111(答案)总要出错鸭qaq
        zero=false;
    }
    else{
        zero=true;
    }
    int cnt=s.size()-1;
    for(int i=0;i<s.size();i++){
        if(zero){
            cout<<arr[i];
        }
        if(s[i]!=0){然后就是一直到没有前导0的地方开始输出
            zero=true;
        }
    }
    puts("");
    return 0;
}
```

---

## 作者：huadi2 (赞：2)

蒟蒻的第一篇题解，在网上找了好多代码，都感觉比较麻烦，然后就自己脑补（
~~头都想没了~~）了一个
我们可以直接按位相减，然后看当前位置需要向下一个位置借一个位补正（想了很多情况应该只要向下借1就行了）。
跟加法差不多，都只要扫一遍，详情看注释~


------------


```cpp
#include<bits/stdc++.h>//万头赛高！！

using namespace std;

int a[10005],b[10005];
int main()
{
    string sa,sb;
    cin >> sa >> sb;
    int f=0,ta=0,tb=0;
    if(sa.size() < sb.size() || (sa.size()==sb.size() && sa<sb))//判断大小
        swap(sa,sb),f=1;//f在这里是符号flag
    for(int i=sa.size()-1;i>=0;i--)a[ta++]=sa[i]-'0';
    for(int i=sb.size()-1;i>=0;i--)b[tb++]=sb[i]-'0';

    for(int i=0;i<ta;i++)
    {
        a[i]-=b[i];//按位相减
        if(a[i]<0)a[i]+=10,a[i+1]--;//向下借位补正当前位置
    }

    if(f)putchar('-');
    
    f=0;//f这里是前导0 flag
    for(int i=ta-1;i>=0;i--)
    {
        if(a[i])f=1;//遇到一个不为0的位时改变f，忽略前导0（可以在这里改变ta）
        if(f || !i)putchar(a[i]+'0');//加为零时的判断
    }
    return 0;
}
```


------------
（~~听说有查重，我就不动手脚了23333~~）

---

## 作者：蒟蒻溴化氢 (赞：2)

蒟蒻花了一上午写了一个高精度
个人认为代码对新手比较友好（包括加减乘）
注释在代码里
（代码参考了林厚从的《信息学奥赛课课通》以及@stone_juice石汁的一篇题解）
```
#include <iostream>
#include <cstdio>
#include <cstring>
#define res register int
using namespace std;
const int N=10010;
char sa[N],sb[N];
//用字符串形式存储数据 
string add(char sa[],char sb[])//高精度加法 
{
	string ans="";
	int a[N],b[N],c[N];
	int la=strlen(sa);//得到sa有多少位 
	int lb=strlen(sb);//得到sb有多少位 
	memset(a,0,sizeof(a));//初始化一下 
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	for(res i=0;i<la;i++) a[la-i-1]=sa[i]-'0';//把字符转化为数字  同时把数字翻转过来 
											  //这样a[i]就表示第i位 
	for(res i=0;i<lb;i++) b[lb-i-1]=sb[i]-'0';
	int lc=max(la,lb);//最后的结果就是两个的最大值 
	for(res i=0;i<lc;i++)
	{
		c[i]+=a[i]+b[i];//加法 
		if(c[i]>=10) c[i+1]=1,c[i]-=10;//处理一下进位的问题 
	}
	if(c[lc]>0) lc++;
	for(res i=lc-1;i>=0;i--)
	{
		char tmp=c[i]+'0';
		ans=ans+tmp;//结果 
	}
	return ans;
}

int _compare(char sa[],char sb[])//比较两个正数的大小 
{//1代sa>sb 0代表相等 -1代表sa<sb 
	int la=strlen(sa),lb=strlen(sb);
	if(la<lb) return -1;//如果长度不同 那么大小就可以确定 
	if(la>lb) return 1;
	for(res i=0;i<la;i++)
	{
		char tmpa=sa[i];
		char tmpb=sb[i];
		if(tmpa>tmpb) return 1;
		if(tmpa<tmpb) return -1;
	}
	return 0;
}



string _minus(char sa[],char sb[],int x)//高精度减法 x代表是否取负号 
{
	string ans="";
	int a[N],b[N],c[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	int la=strlen(sa);
	int lb=strlen(sb);
	for(res i=0;i<la;i++) a[la-i-1]=sa[i]-'0';
	for(res i=0;i<lb;i++) b[lb-i-1]=sb[i]-'0';//前面有解释 
	int lc=max(la,lb);
	for(res i=0;i<lc;i++)
    {
        if(c[i]+a[i]-b[i]<0)
        {
            c[i+1]--;
            c[i]+=10;
        }//借位处理
        c[i]+=a[i]-b[i];
    }
	while(c[lc-1]==0&&lc>0) lc--;//删除在最开始的0 
	for(res i=lc-1;i>=0;i--)
	{
		char tmp=c[i]+'0';
		ans=ans+tmp;
	} 
	if(x==-1) ans="-"+ans;
	return ans;
}

string _mul(char sa[],char sb[])
{
	if(sa[0]=='0'||sb[0]=='0') return "0";
	string ans="";
	int a[N],b[N],c[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	int la=strlen(sa);
	int lb=strlen(sb);
	for(res i=0;i<la;i++) a[la-i-1]=sa[i]-'0';
	for(res i=0;i<lb;i++) b[lb-i-1]=sb[i]-'0';
	for(res i=0;i<la;i++)
		for(res j=0;j<lb;j++)
		{
			int f,w,jw;//i和j位相乘存储在答案的i+j位当中 
			f=a[i]*b[j]; jw=f/10; f=f%10;w=i+j;//jw表示进位 f表示进位后剩下的数 
			c[w]=c[w]+f;jw+=c[w]/10;c[w]=c[w]%10;
			c[w+1]=c[w+1]+jw;
		}
	int lc=la+lb;
	while(c[lc-1]==0&&lc>0) lc--;//前面有解释 
	for(res i=lc-1;i>=0;i--)
	{
		char tmp=c[i]+'0';
		ans=ans+tmp;
	}
	return ans;
}


int main()
{
//	freopen("test.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>sa>>sb;
//在做减法之前 要先比较哪一个数更大 
	if(_compare(sa,sb)==1) cout<<_minus(sa,sb,1);
	else if(_compare(sa,sb)==-1) cout<<_minus(sb,sa,-1);
	else cout<<"0";

	cout<<_mul(sa,sb);
	return 0;
} 
```
rp++

---

## 作者：没名字可被用 (赞：2)

看完了刘汝佳写的，发现他只写了加 代码仓库也没有其他的 于是自己研究了一个减

调了很长时间之后发现了问题并改正了，虽然花了时间但是很值，至少是自己琢磨出来的减

解释在注释里，虽然长但是肯定能懂

```cpp
#include <iostream> 
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <string>
//已测试 加法是对的
using namespace std;
typedef long long ll;

inline unsigned truelenth(ll k)//测一个整数的长度
{
    unsigned ans=0;
    do
    {
        k/=10;
        ans++;
    }while(k>0);
    return ans;
}

inline void checkout(vector<int > a,vector<int > b)
{
    printf("a:\n");
    for(int i=a.size()-1;i>=0;i--)
    {
        printf("%d",a[i]);
    }
    printf("\n");
    printf("b:\n");
    for(int i=b.size()-1;i>=0;i--)
    {
        printf("%d",b[i]);
    }
    printf("\n");
}
    
struct biginteger
{
    static const int base=100000000;
    static const int width=8;
    vector<int > s;
    char ch;
    
    biginteger(ll num=0,char ch='+')
    {
        \*this=num;
        this->ch=ch;///////////////////
    }
    
    biginteger operator =(ll num)
    {
        s.clear();
        do
        {
            int cur=num%base;
            s.push\_back(cur);
            num/=base;
        }while(num>0);
        return \*this;
    }
    
    biginteger operator =(string &num)
    {
        s.clear();
        int len=1+(num.length()-1)/width;
        for(int i=0;i<len;i++)
        {
            int end=num.length()-i\*width;
            int start=max(0,end-width);
            int x;                        //下方不是end 后一个参数要接长度
            sscanf(num.substr(start,/\*end\*/end-start).c\_str(),"%d",&x);
            s.push\_back(x);
        }
        return \*this;
    }
    
    friend biginteger operator +(const biginteger & a,const biginteger & b)
    {
        biginteger ans;
        ans.s.clear();
        for(unsigned i=0,g=0;;i++)
        {
            if(i>=a.s.size() && i>=b.s.size() && g==0)
            {
                break;//加法结束的标志，详见书上圆珠笔字
            }
            int buffer=g;
            if(i<a.s.size())
            {
                buffer+=a.s[i];
            }
            if(i<b.s.size())
            {
                buffer+=b.s[i];
            }
            ans.s.push\_back(buffer%base);
            g=buffer/base;
        }
        return ans;
    }
    
    
    friend biginteger operator -(const biginteger & a,const biginteger & b)
    {
        biginteger ans;
        ans.s.clear();
        vector<int > reala;
        vector<int > realb;
        reala.clear();
        realb.clear();
        reala.assign(a.s.begin(),a.s.end());
        realb.assign(b.s.begin(),b.s.end());
        
        //checkout(reala,realb);
        //先进行交换 确保a为较大数
        //第一步先看存的元素有多少个
        unsigned len1=a.s.size();
        unsigned len2=b.s.size();
        //cout<<"len1="<<len1<<endl;
        //cout<<"len2="<<len2<<endl;
        if(len1<len2)
        {
            swap(reala,realb);
            ans.ch='-';
        }
        if(len1==len2)
        {
            int tag=0;
            //第二步一步一步地比较元素大小
            for(int i=len1-1;i>=0;i--)
            {
                if(a.s[i]<b.s[i])
                {
                    tag=1;//表明要交换
                    break;
                }
                if(a.s[i]>b.s[i])
                {
                    break;
                }
            }
            if(tag==1)
            {
                ans.ch='-';
                swap(reala,realb);
            }
        }
        
        //checkout(reala,realb);
        //开始减
        int buffer=0;
        for(unsigned i=0;;i++)
        {
            if(i>=reala.size() && i>=realb.size())
            {
                break;
            }
            
            else
            {
                if(i<reala.size())
                {
                    buffer+=reala[i];
                }
                if(i<realb.size())
                {
                    buffer-=realb[i];
                }
                if(buffer<0)
                {
                    ans.s.push\_back(base+buffer);
                    buffer=-1;
                }
                else
                {
                    ans.s.push\_back(buffer);
                    buffer=0;
                }
            }
        }
        //去掉高位上的0
        for(int i=ans.s.size()-1;i>=0;i--)
        {
            if(ans.s[i]>0) break;
            if(ans.s[i]==0) 
            {
                ans.s.pop\_back();
            }
        }
        /\*/
        cout<<"ans:"<<endl;
        checkout(ans.s,ans.s);
        cout<<endl;
        cout<<ans.ch<<endl;
        /\*/
        return ans;
    }
};

    ostream& operator << (ostream &out,const biginteger& x)
    {
        if(x.ch=='-') out<<'-';
        out<<x.s.back();
        for(int i=x.s.size()-2;i>=0;i--)
        {
            char buffer[10];
            memset(buffer,0,sizeof(buffer));
            sprintf(buffer,"%08d",x.s[i]); 
            //out<<buffer;
            
            //不是像上面这样加的
            for(unsigned i=0;i<strlen(buffer);i++)
            {             
                out<<buffer[i];
            }
        }
        return out;
    }
    
    istream& operator >> (istream &in,biginteger& x)
    {
        string s;
        if(!(in>>s)) 
            return in;//输入不成功 直接返回
        x=s;
        return in;
    }

int main()
{
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    ios::sync\_with\_stdio(false);
    biginteger a,b;
    string sa;
    string sb;
    cin>>sa;
    cin>>sb;
    //cout<<sa<<endl;
    //cout<<sb<<endl;
    a=sa;
    b=sb;
    cout<<a-b<<endl;
    return 0;
}

---

## 作者：Seauy (赞：2)

楼下有人说要改成int数组后再做计算啊,其实并不用

高精度，其实就是从电脑那把电脑存不下的数据搬到程序里，通过自己计算然后以非正常形式反馈回来。脱离了电脑，我们平时的计算都是依靠竖式的，那我们就模拟一个竖式计算

重点其实就是怎样做到各位对齐,不知道我的方法好不好......我是先计算已调换过(此时a.length()>=b.length())a和b位数之差,再在b的最高位开始添0,添到位数相同为止......

    
    
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    string a,b,c;//c是用来辅助b添位的
    int ans[10010],sum;//用ans存答案
    bool pd,bo=1;//pd用来判断b>a
    int main()
    {
        cin>>a>>b;
        if(a==b)//a=b直接输出0
        {
            cout<<0;
            return 0;
        }
        else if(a.length()>b.length()) pd=1;//a的位数比b多,那就肯定比b大
        else if(a.length()<b.length()) pd=0;//反之,也是一样的
        else if(a.length()==b.length())//a的位数和b一样
        {
            if(a>b) pd=1;//可以直接字典序比较
            else pd=0;
        }
        if(!pd) swap(a,b);//b>a,调换一下就是了
        sum=a.length()-b.length();//sum存a b位数差
        for(int i=0;i<sum;i++) c=c+"0";//c存了需要添的0
        b=c+b;//给b加上
        for(int i=a.length()-1;i>=0;i--)//个位对齐,是从a还是b开始不重要
        {
            if(a[i]>=b[i]) ans[i]=a[i]-b[i];//一位一位进行计算
            else
            {
                a[i-1]--;//不够借位
                ans[i]=a[i]+10-b[i];
            }
        }
        if(!pd) cout<<'-';//别忘了输出负号
        for(int i=0;i<=b.length()-1;i++)
        {    
            if(bo && ans[i]==0) continue;//结果最高位上可能为0，直接跳过
            else if(ans[i]>0) bo=0;//找到了不为0的最高位
             cout<<ans[i];
        }
        //system("pause");
        return 0;
}
```

---

## 作者：ynycoding (赞：2)

这道题我用的动态数组vector。

自作孽不可活，写了一长串代码，还加了一个类。

满满的都是泪（类）呀！

我居然写了30min!


话不多说，首先介绍一下整体的结构

num类中有一个动态数组n，代表高精度中每一位。


```cpp
#define MAXN (10)
class num{
    public:
        vector <int> n;
        ```
然后有一个构造函数，可以直接调用这个来给高精度数赋值。~~其实没卵用~~

```cpp
        num(int in) {
            for(; in; in/=MAXN)
            {
                n.push_back(in%MAXN);
            }
        }
```
然后是重载了一个加法运算符，其实就是模拟人工竖式计算...

```cpp
        num operator + (const num &a)
        {
            num c;
            int i;
            int tmp=0;
            for(i=0; (i<a.n.size())&&(i<this->n.size()); i++)
            {
                c.n.push_back((a.n[i]+this->n[i]+tmp)%MAXN);
                tmp=(a.n[i]+this->n[i]+tmp)/MAXN;
            }
            if(i==a.n.size())
            {
                for(; i<n.size(); i++)
                {
                    c.n.push_back((n[i]+tmp)%MAXN);
                    tmp=(n[i]+tmp)/MAXN;
                }
                if(tmp) c.n.push_back(tmp);
            }
            else
            {
                for(; i<a.n.size(); i++)
                {
                    c.n.push_back((a.n[i]+tmp)%MAXN);
                    tmp=(a.n[i]+tmp)/MAXN;
                }
                if(tmp) c.n.push_back(tmp);
            }
            return c;
        }
```
然后又是一个重载的等于（赋值）运算符，这个不必多说吧...

```cpp
        num operator = (num &a)
        {
            for(int i=n.size(); i; i--) n.pop_back();
            for(int i=0; i<a.n.size(); i++) n.push_back(a.n[i]);
            return *this;
        }
```
然后就是重载cin>>和cout<<了。

```cpp
ostream& operator << (ostream &o, const num & N)
{
    for(int i=(N.n.size()-1); i>=0; i--) cout<<N.n[i];
    return o;
}
istream& operator >> (istream & in, num & N)
{
    string s;
    in>>s;
    for(int i=N.n.size(); i; i--) N.n.pop_back();
    for(int i=(s.length()-1); i>=0; i--) N.n.push_back(s[i]-'0');
    return in;
}

int main()
{
    num a, b;
    cin>>a>>b;
    cout<<a+b;
    return 0;
}
```
~~说实话，这些东东一本通上都有。。。~~（划掉)


---

## 作者：Linshaos (赞：2)

         
```cpp
#include<iostream>
#include<string>
long long a[100001],b[100001],c[100001]；//为了避免不够大，开大点无所谓
using namespace std;
int main()
{
        string str1,str2;//定义两个字符串
        long long i=1,t;//i为两个字符串的位数，t是较长的字符串的长度
        cin>>str1>>str2;//读入，用gets会错，不知道为什么
        if (str1.size()<str2.size())t=str2.size();
          else t=str1.size();//判断哪个字符串长
      for (int i=1;i<=str1.size();i++)
        a[i]=str1[str1.size()-i]-'0';//对数据进行处理
      for (int i=1;i<=str2.size();i++)
        b[i]=str2[str2.size()-i]-'0';//对数据进行处理
      if (str1.size()<str2.size())//重点之一来了，考虑str1小于str2，第一直接判断位数
        {for (int i=1;i<=t;i++)
          swap(a[i],b[i]);//逐个交换
          cout<<"-";//输出负号
        }
        else {
        if (str1.size()==str2.size())//当两个字符串的长度相等时，比较各个位的大小
          for (int i=1;i<=t;i++)
            if (a[i]<b[i])
              {
                    for (int j=1;j<=t;j++)
                      swap(a[j],b[j]);//逐个交换 
                      cout<<"-";//输出负号
                      break; }//结束循环
        }
            while(i<=str1.size()||i<=str2.size())//当i大于两个字符串的长度时，结束
      {
            if (a[i]<b[i])//重点二，借位
            {
                a[i]=a[i]+10;//不够减，向前一位借十
                a[i+1]=a[i+1]-1;//同理，前一位减一
                }
                c[i]=a[i]-b[i];//相减之后
                i++;//下一位
      }    
    while (c[i]==0  && i>1)//处理最高位
    i--;
    for(int z=i;z>=1;z--)//倒序输出    
    cout<<c[z];
    return 0;                 
}//新人一枚，算法写得很烂，欢迎有建设性的建议
```

---

## 作者：Aimyhtixela (赞：2)

```cpp
//直接用字符串写:-)
#include <iostream>
#include <string>
using namespace std;
int main(){
    string a,b,temp;
    int flag=0;//设置一个旗子
    cin>>a>>b;
    int x=a.length()-1,y=b.length()-1,t=-1,z[300]={0},up[300]={0},down[300]={0};
    //下面两段用来判断，如果一样长，按照字典序，如果位数小于，那么肯定是负数了
    //当是负数时，做个标记，让falg=1;
    if (x==y){
        if (a<b){
            flag=1;
            temp=a,a=b,b=temp;
        }
    }
    if (x<y){
        flag=1;
        temp=a,a=b,b=temp;
    }
    //上面两段保证了x一定比y大，但是由于交换了一遍，所以肯定还要再计算一下长度为了后面
    x=a.length()-1,y=b.length()-1;
    //字符串读进去
    for (int i=0;i<=x;++i){
        up[i]=a[i]-'0';
    }
    for (int i=0;i<=y;++i){
        down[i]=b[i]-'0';
    }
    //比较机制
    while (x>=0 && y>=0){
        if (up[x]>=down[y]){
            //如果大于等于，直接减，存粗再z字符串里
            ++t;
            z[t]=up[x]-down[y];
        }
        else {
            //不然就要借位
            ++t;
            up[x-1]--;
            z[t]=10+up[x]-down[y];
        }
        --x;--y;
    }
    for (int i=x-y-1;i>=0;--i){//因为是一直到0，所以要减去1
        ++t;
        z[t]=up[i];
    }
    //防止产生-1，双重保险，这下面的肯定要, 否则强数据例如100-1就会产生-1了
    for (int i=0;i<t;++i){
        if (z[i]<0){
            z[i+1]--;
            z[i]+=10;
        }
    }
    //去掉多余的0，一举两得，不仅可以对付前导0，还能对付类似于100-1这种情况
    while (z[t]==0 && t>0){
        --t;
    }
    if (flag==1){
        cout<<"-";//如果flag=1, 输出负，因为是负数
    }
    //逆向输出
    for (int i=t;i>=0;--i){
        cout<<z[i];
    }
    //为了美观
    cout<<endl;
    return 0;
}
//总共在没有注释情况下，只有841b
//效率测了两次，一次6ms，一次7ms，注意有11个测试点
```

---

## 作者：Lee02 (赞：1)

# 学习笔记！

## 这道题一共做了两遍
**第一遍** 是用的py。。。。
```python
	a=input()
    b=input()
    print(a-b)
```
A了之后我就溜了，去做其他~~艰深~~好玩的题

**第二遍** 是用的c++（我是隔了好久才想起来做）

## 现在分析下思路
	根据题意来看，这是一道A-B problem（废话），而且第一个有可能大于第二个。

这个就意味着最后的结果可能是**负数**

不过，这个对我们的计算过程并没有太大影响，无非是多进行一步**比大小**的工作。如果第一个小于第二个，就在最后结果前加一个“-”。

然后，就是进行**模拟竖式**的操作

1. 大数的每一位减小数的每一位，如果不够减，就向前一位进行借位
2. 操作结束后，把前导零去掉
3. 输出

好了，这就是我们主要的思路，下面说一下具体操作

### 比大小！
在我的程序中，它的名字叫做``` ucc ```（就是一个瞎起的名字，无实意）

#### 流程
1. **判断位数**
	
    如果第一个数的位数大于第二个数的位数，那显而易见的第一个数大于第二个数；反之第一个数小于第二个数。
2. **位数相同时**
	
    从头比到尾，只要有一位数有偏差（或大或小），就能判断谁大谁小
3. **假如一切的一切都相同**
	
    那他俩就相同呗~~
    
**P.S.** 如果想练习高精比大小的题，可以试试这道题，几乎是模板题：[P1781 宇宙总统](www.luogu.com.cn/problem/P1781)

### 模拟竖式！
在我的程序中，它是在主程序中，如果大家有兴趣的话，可以试着把它放到函数中执行，这样它的**功能性**就会更强

#### 流程
1. 挨个减就完了（按照思路中的方法来）

### 输出
在我的程序中，它是print(int k)函数，具体为什么要用k做参数，详见代码

## 那么，最激动人心的时刻来了！！！
上代码！！！
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
string s,t;
int a[100000],b[100000],c[100000],ll;//ll是用来记录位数
int ucc(int a[],int b[])//比大小
{
	if(a[0]>b[0])
	return 2;
	else if(a[0]<b[0])
	return 0;
	else
	{
		for(int i=a[0];i>=1;i--)
		{
			if(a[i]>b[i])
			return 2;
			else if(a[i]<b[i])
			return 0;
		}
		return 1; 
	}
}//返回值很重要，可以省去很多麻烦
void print(int k)
{
	
	if(k==2)
	{
		while(c[a[0]]==0&&a[0]>=1) a[0]--;//消去前导零
		for(int i=a[0];i>=1;i--)
		cout<<c[i];
	}//结果为正数时
	else
	{
		while(c[b[0]]==0&&b[0]>=1) b[0]--;
		cout<<'-';
		for(int i=b[0];i>=1;i--)
		cout<<c[i];
	}//结果为负数时
}
int main ()
{
	cin>>s>>t;
	a[0]=s.length();
	b[0]=t.length();
	for(int i=1;i<=a[0];i++)
	a[i]=s[a[0]-i]-48;//转化
	for(int i=1;i<=b[0];i++)
	b[i]=t[b[0]-i]-48;
	int k=ucc(a,b);
	if(k==2)//如果a>b
	{
		for(int i=1;i<=a[0];i++)//模拟竖式
		{
			if(a[i]>=b[i])
			c[i]=a[i]-b[i];
			else
			{
				c[i]=a[i]+10-b[i];
				a[i+1]--;
			}
		}
	}
	else if(k==1)//如果a==b
	{
		cout<<0<<endl;//这样就节省了很多时间，少处理很多
	}
	else//如果a<b
	{
		for(int i=1;i<=b[0];i++)
		{
			if(b[i]>=a[i])
			c[i]=b[i]-a[i];
			else
			{
				c[i]=b[i]+10-a[i];
				b[i+1]--;
			}	
		} 
	}
	if(k!=1)
	{
		print(k);//输出，k是a、b大小关系的标志！
	} 
	return 0;//带功告成
 } 
```

### 不太指望这篇能过，就当是学习笔记吧。（如果能过请务必让我过！！！）


---

## 作者：Null_Cat (赞：1)

（继上次高精加后的又一篇高精）

高精度加法详见[题解 P1601 【A+B Problem（高精）】](https://www.luogu.org/blog/AuAqwqnoLGBlog/solution-p1601)

那么话不多说，这就开始

------------
首先还是按照高精加的解题步骤：

还是举个栗子qwq：2333-314159

下面根据题目我们可以知道最终的结果就是-(314159-2333)

所以我们的思路就是：

1.先算314159-2333

2.取相反数

那么我们就可以列出竖式：

__314159__

__-  2333__

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

__311826__

所以结果是-311826

那么关于借位我们是怎么进行处理的呢？

我们计算的思路是：如果被减数的这一位小于减数的这一位，我们向被减数的前一位借来10，变成10+被减数这一位-减数这一位，同时被减数的上一位－1

在关于位数不同上，我们和加法取一样的处理措施，在位数少的数前面补0

那么我们就可以得到如下的代码：
```cpp
inline string minuss(string a,string b){
	re int* al=new int;	
	re int* bl=new int;		//a,b数长度
	re bool* flag=new bool;		//结果正负
	*flag=false;	//初始为正数
	*al=a.size(),*bl=b.size();
	re string result;
	if(*al<*bl||(*al==*bl)&&(a<b)){		//当a<b时，交换a,b，结果定位负数
		swap(al,bl);
		swap(a,b);
		*flag=true;
	}
	else if(a==b){		//一个小优化，如果一样直接返回0
		result="0";
		delete al;
		delete bl;
		return result;
	}
	for(re int i=0;i<*al-*bl;i++){		//交换完以后b一定是较小的数，直接给b补0
		b='0'+b;
	}
	*bl=b.size();	//更新b的长度
	re bool* bor=new bool;		//是否借位
	*bor=0;	//默认不借
	re int* each=new int;	//每位的值
	for(re int i=*al-1;i>=0;i--){	//从低位开始算
		*each=(a[i]^48)-(b[i]^48)-*bor;		//先计算初始的each
		if(*each<0){	//如果each<0即需要借位
			*each+=10;		//借一个10
			*bor=1;		//标记借位了
		}
		else{
			*bor=0;		//很重要不然有一个需要借位剩下就都借了，不借一定要置为0
		}
		result=char(*each+'0')+result;		//更新当前位
	}
	re int* delz=new int;		//去0
	*delz=0;		//从最高为开始
	while(result[*delz]=='0') result=result.substr(++*delz,result.size());		//去零，把result直接变成无0的那个子字符串
	if(*flag==true) result='-'+result;		//加符号
	delete flag;
	delete delz;
	delete al;
	delete bl;
	delete bor;
	delete each;		//指针记得delete，非指针直接忽略
	return result;		//返回结果
}
```

下面是程序完整代码：
```cpp
#include<cstdio>
#include<string>
#include<iostream>
#define re register
using namespace std;
inline string fRead();
inline string minuss(string,string);
int main(int argc,char* argv[]){
	string *a=new string;
	string *b=new string;
	*a=fRead();
	*b=fRead();
	cout<<minuss(*a,*b)<<endl;
	delete a;
	delete b;
    return 0;	//这里和a+b的处理完全一样
}
inline string minuss(string a,string b){	//就是上面的函数
	re int* al=new int;
	re int* bl=new int;
	re bool* flag=new bool;
	*flag=false;
	*al=a.size(),*bl=b.size();
	re string result;
	if(*al<*bl||(*al==*bl)&&(a<b)){
		swap(al,bl);
		swap(a,b);
		*flag=true;
	}
	else if(a==b){
		result="0";
		delete al;
		delete bl;
		return result;
	}
	for(re int i=0;i<*al-*bl;i++){
		b='0'+b;
	}
	*bl=b.size();
	re bool* bor=new bool;
	*bor=0;
	re int* each=new int;
	for(re int i=*al-1;i>=0;i--){
		*each=(a[i]^48)-(b[i]^48)-*bor;
		if(*each<0){
			*each+=10;
			*bor=1;
		}
		else{
			*bor=0;
		}
		result=char(*each+'0')+result;
	}
	re int* delz=new int;
	*delz=0;
	while(result[*delz]=='0') result=result.substr(++*delz,result.size());
	if(*flag==true) result='-'+result;
	delete flag;
	delete delz;
	delete al;
	delete bl;
	delete bor;
	delete each;
	return result;
}
```

---

## 作者：哔哩哔哩 (赞：1)

### 【思路】
思路与其他的解法相同，用字符串处理数字，但是这个方法会显得更加简单。

(发现没有重载运算符的题解，来一篇，希望对其他人有帮助)
### 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=10,P=1; 

struct BigNum
{
       int n[100000],l,Y;
       BigNum(){l=1,memset(n,0,sizeof(n));}
       //----------------------------------
       void init()
       {
            string s;
            cin>>s;
            int now=0,ct=0,c1=1;
            for(int i=s.length()-1;i>=0;i--)
            {
             n[now]+=(s[i]-'0')*c1;
             c1*=10;
             ct++;
             if(ct==P&&i!=0)
             {
              now++;
              c1=1;
              ct=0;
             }        
            }
            l=now+1;     
       }
       //-----------------------------------
       void print()
       {
            printf("%d",n[l-1]);
            for(int i=l-2;i>=0;i--)
            printf("%0*d",P,n[i]);
            printf("\n");
       }
       //------------------------------------
       BigNum operator +(BigNum x)const
       {
              BigNum t=*this;
              if(x.l>t.l)t.l=x.l;
              for(int i=0;i<t.l;i++)
              {
               t.n[i]+=x.n[i];
               if(t.n[i]>=M)
               {
                   t.n[i+1]+=t.n[i]/M;
                   t.n[i]%=M;             
               }        
              }
              while(t.n[t.l])
              {
                  t.n[t.l+1]+=t.n[t.l]/M;
                  t.n[t.l++]%=M;               
              }     
              return t;  
       }
       //--------------------------------------
       bool operator < (BigNum x) const
       {
           BigNum t=*this;
           if(t.l!=x.l)return t.l<x.l;
           for(int i=t.l-1;i>=0;i--)
           {
              if(t.n[i]!=x.n[i])return t.n[i]<x.n[i];        
           }
           return 0;       
       }
       BigNum operator -(BigNum x)const
       {
           BigNum t=*this;
           if(t<x){printf("-");swap(t,x);} 
           for(int i=0;i<t.l;i++)
           {
            t.n[i]-=x.n[i];
            if(t.n[i]<0)
            {
                t.n[i]+=M;
                --t.n[i+1];            
            }        
           } 
           while(!t.n[t.l-1]&&t.l>1)t.l--;
           return t;     
       }
       //--------------------------------------------
       BigNum operator * (BigNum x) const//提供了2种*运算
       {
              BigNum c,t=*this;
              c.l=t.l+x.l-1;
              for(int i=0;i<t.l;i++)
              for(int j=0;j<x.l;j++)
              {
                  c.n[i+j]+=t.n[i]*x.n[j];
                  if(c.n[i+j]>=M)
                  {
                      c.n[i+j+1]+=c.n[i+j]/M;
                      c.n[i+j]%=M;               
                  }        
              }
              while(c.n[c.l])
              {
                   c.n[c.l+1]+=c.n[c.l]/M;
                   c.n[c.l++]%=M;               
              }       
              return c;
       }
       BigNum operator * (int x) const
       {
          BigNum t=*this,c;
          c.l=t.l;
          for(int i=0;i<t.l;i++)
          {
              c.n[i]+=t.n[i]*x;
              if(c.n[i]>=M)
              {
                   c.n[i+1]+=c.n[i]/M;
                   c.n[i]%=M;             
              }        
          }       
          while(c.n[c.l])
          {
                 c.n[c.l+1]+=c.n[c.l]/M;
                 c.n[c.l++]%=M;               
          }
          return c;
       }
       //--------------------------------------------
    void Add(int x){if(x||l)n[l++]=x;}
    void Re(){reverse(n,n+l);}
    BigNum operator /(const BigNum &x)const//提供了2种/运算
    {
        BigNum t=*this,r,y;
        y.l=0,r.l=t.l;
        for(int i=t.l-1;i>=0;--i)
        {
            y.Add(t.n[i]);
            y.Re();
            while(!(y<x))y=y-x,r.n[i]++;
            while(!y.n[y.l-1] && y.l>1)--y.l;
            y.Re();
        }
        while(!r.n[r.l-1] && r.l>1)--r.l;
        return r;
    }
    BigNum operator /(const int &x)const
    {
        BigNum t=*this,r;
        r.l=t.l;
        int tmp=0;
        for(int i=t.l-1;i>=0;--i)
        {
            tmp+=t.n[i];
            if(tmp>=x)
                r.n[i]+=tmp/x,tmp%=x;
            tmp*=M;
        }
        while(!r.n[r.l-1] && r.l>1)--r.l;
        return r;
    }
       //---------------------------------------
       
}a,b,c;
 
 
int main()
{
    a.init();
    b.init();
/*   
    c=a+b;
    c.print();
*/ 
    c=a-b;
    c.print();
/*
    c=a*b;
    c.print();
    
    c=a/b;
    c.print();
*/
    return 0;        
}
```
代码虽然长，但是这是一套很完整的代码了。

---

## 作者：lhchanyoel7 (赞：1)

看P语言的只有一个，来放一个自我感觉比较繁复的程序。

这个高精度减法，我在前期处理费的代码比较多，后面减的比较少。

先用ansistring类型读入了两个数。

先比较长度，如果长度一样，从高位开始比较，如果第一个数某一位小于了第二个数所对应位数，就把两个数交换一下。

也就是a数组放大的数，b数组放小的。

我为了方便减法，按照列竖式的格式放进数组里了。

即当数为96与2005时，a[2,0,0,5],b[0,0,9,6]。

之后就从最后一位开始减，如果a[i]<b[i]，a[i]:=a[i]+10,a[i-1]:=a[i-1]-1;

用c数组记录结果。

由于我是从1开始记各个位的数的，所以最后的时候要倒输出。

注意判0！0是不能输出的。

以下代码：

```cpp
var s1,s2:ansistring;
    x,y,i,j,t:longint;
    f:boolean;
    a,b,c:array[0..10001] of longint;
begin
  readln(s1);
  readln(s2);
  x:=length(s1);y:=length(s2);f:=true;//f表示是否需要交换，后也可做是否要输出'-'的判断
  if y>x then f:=false
         else if x=y then for i:=1 to x do
                            begin
                              if s1[i]>s2[i] then break;//如果高位已经大于，就不用判了
                              if s1[i]<s2[i] then begin
                                                  f:=false;
                                                  break;
                                                end;
                            end;
  if f then begin//将数放入a,b数组
              for i:=1 to x do
                val(s1[i],a[i]);t:=0;
              for i:=x-length(s2)+1 to x do
                begin
                  inc(t);
                  val(s2[t],b[i]);
                end;
            end
       else begin
              x:=length(s2);t:=0;
              for i:=x-length(s1)+1 to x do
                begin
                  inc(t);
                  val(s1[t],b[i]);
                end;
              for i:=1 to x do
                val(s2[i],a[i]);
            end;
  t:=0;
  while (x>0) do//做减法
    begin
      inc(t);
      if a[x]<b[x] then begin 
                          a[x]:=a[x]+10;
                          a[x-1]:=a[x-1]-1;
                        end;
      c[t]:=a[x]-b[x];
      dec(x);
    end;
  if not(f) then write('-');
  for i:=t downto 1 do 
    if c[i]<>0 then break;
  for j:=i downto 1 do
    write(c[j]);writeln;
end.
```

---

## 作者：唔西迪西 (赞：1)

1.数据过大，需要用字符。

2.通过数组将字符转化为数并保存。

3.当第二个数大于第一个数时，也就是答案为负数时，大数减小数，答案前加负号。

4.位于位相减时不够减，需要借位。

5.借位时，向前借一位，本身加10，前一位减1，与整数减法相同。

6.输出时注意输出顺序，高位先输出。

7.如果有前导0，需把前导0去除。

代码如下：

   
     
     
        
                  
      

       
```cpp
#include <iostream>
#include <string.h>
using namespace std;
char a[100000],b[100000];  //把数先转换成字符串再输入 
int  e[100000],d[100000];
int c[100000]={0};
int main()
{   
    int i,j,x,y,z,p,q,o;
    q=0;
    cin>>a>>b;   //输入两个字符串 
    x=strlen(a);   // 测量第一个字符串的长度 
    y=strlen(b);    //测量第二个数的长度 
    if(x>y)   //比较长度（位数长度） 
    {
        p=x;
        q=1;  //如果第一个大，标记为1 ，表示答案是正数 
    }
    else
    p=y;
    for(i=x-1,j=0;i>=0,j<=x-1;i--,j++)  //转换，把字符转换为数，放到数组中 
     e[j]=a[i]-'0';     // 把第一个数按位存入数组 
    for(i=y-1,j=0;i>=0,j<=y-1;i--,j++)
     d[j]=b[i]-'0';   //把第二个数按位存入数组 
     if(x==y) //  如果两个数长度（位数）一样 
     {    q=1;
         for(i=p-1;i>=0;i--)
           if(e[i]<d[i])//比较每一位上的数，从高位到低位 
             {
                q=0;//如果第一个数小于第二个数，标记为0 ，表示答案为负数 
                break;  
             }    
     }
    for(i=0;i<p;i++) 
         {
              if(q==1) //   通过标记，判断哪个大，大数减小数 
                c[i]=e[i]-d[i];
              else
               c[i]=d[i]-e[i];   
         }  
    if(q==0)  //答案为负，输出负号 
      cout<<"-";
     for(i=0;i<p;i++) 
     {
        if(c[i]<0)  //如果同位相减为负 
        {
            c[i]+=10;//向前一位借一，加10（减法不够减的情况） 
            c[i+1]-=1;
        }       
     }
       o=p;      
       for(i=p;i>=0;i--)  //如果有前导0，例如001，去除前导0 
       {   
             if(c[i]!=0)
             break; 
             o=o-1;
             if(i==0&&c[i]==0) //判断两个数是否都为0 
             {
                 o=0;
                 break;
          }
       }
       for(i=o;i>=0;i--)  //输出结果 
       cout<<c[i];
   return 0;
}

```

---

## 作者：Duan2baka (赞：1)

高精度减法，没什么好说的


在下面附上高精模板，高/低，高+高，高++，高-高，都写上了，感觉可以解决大部分问题了


```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define N 1020000
using namespace std;
typedef long long LL;
struct Bigint{
    int a[N],len;
    bool flag;
    Bigint(){memset(a,0,sizeof a);len=1;flag=true;}
    bool operator == (const Bigint b) const{
        if(flag!=b.flag || len!=b.len) return false;
        for(int i=1;i<=len;i++)
            if(a[i]!=b.a[i]) return false;
        return true;
    }
    bool operator > (const Bigint b) const{
        if(flag!=b.flag){
            if(!flag) return false;
            if(flag) return true;
        }
        if(flag){
            if(len>b.len) return true;
            if(len<b.len) return false;
            for(int i=len;i>=1;i--){
                if(a[i]>b.a[i]) return true;
                if(a[i]<b.a[i]) return false;
            }
            return false;
        }
        else{
            if(len>b.len) return false;
            if(len<b.len) return true;
            for(int i=len;i>=1;i--){
                if(a[i]>b.a[i]) return false;
                if(a[i]<b.a[i]) return true;
            }
            return true;
        }
    }
    Bigint operator \* (int b) const{
        Bigint c;
        for(int i=1;i<=c.len;i++){
            c.a[i]+=a[i]\*b;
            c.a[i+1]+=c.a[i]/10;
            c.a[i]=c.a[i]%10;
        }
        int num=0;
        while(b){
            num++;
            b=b/10;
        }
        c.len=num+len+1;
        while(!c.a[c.len]) c.len--;
        return c;
    }
    Bigint operator ++ (){
        Bigint O;
        O.a[1]=1;
        \*this=\*this+O;
        return \*this;
    }
    Bigint operator / (int b) const{
        int c=0;Bigint ans;
        for(int i=len;i>=1;i--){
            ans.a[i]=ans.a[i]+(c\*10+a[i])/b;
            c=(c\*10+a[i])%b;
        }
        ans.len=len;
        while(!ans.a[ans.len]) ans.len--;
        return ans;
    }
    bool operator < (const Bigint b) const{
        if(flag!=b.flag){
            if(!flag) return true;
            if(flag) return false;
        }
        if(flag){
            if(len<b.len) return true;
            if(len>b.len) return false;
            for(int i=len;i>=1;i--){
                if(a[i]<b.a[i]) return true;
                if(a[i]>b.a[i]) return false;
            }
            return false;
        }
        else{
            if(len<b.len) return false;
            if(len>b.len) return true;
            for(int i=len;i>=1;i--){
                if(a[i]<b.a[i]) return false;
                if(a[i]>b.a[i]) return true;
            }
            return true;
        }
    }
    Bigint operator + (const Bigint b)const{
        if(flag&&b.flag){
            Bigint c;
            c.len=max(len,b.len);
            for(int i=1;i<=c.len;i++){
                c.a[i]+=a[i]+b.a[i];
                c.a[i+1]+=c.a[i]/10;
                c.a[i]=c.a[i]%10;
            }
            while(c.a[c.len+1]) c.len++;
            return c;
        }
        if(!flag&&!b.flag){
            Bigint c;
            c.len=max(len,b.len);
            for(int i=1;i<=c.len;i++){
                c.a[i]+=a[i]+b.a[i];
                c.a[i+1]+=c.a[i]/10;
                c.a[i]=c.a[i]%10;
            }
            while(c.a[c.len+1]) c.len++;
            c.flag=false;
            return c;
        }
        if(flag&&!b.flag) return \*this-b;
        if(!flag&&b.flag) return b-\*this;
    }
    Bigint operator - (Bigint b) const{
        if(b==\*this){Bigint O;return O;}
        if(\*this<b){
            Bigint c;
            c=b-\*this;
            c.flag=false;
            return c;
        }
        if(flag&&!b.flag){
            b.flag=true;
            return \*this+b;
        }
        if(flag&&b.flag){
            Bigint c;
            c.len=max(len,b.len);
            for(int i=1;i<=c.len;i++){
                c.a[i]+=a[i]-b.a[i];
                if(c.a[i]<0){
                    c.a[i]+=10;
                    c.a[i+1]--;
                }
            }
            while(!c.a[c.len]) c.len--;
            return c;
        }
        if(!flag&&!b.flag){
            b.flag=true;
            Bigint c=\*this;c.flag=true;
            return b-c;
        }
    }
    void scan(){
        char c[N];
        int top=0;
        scanf("%s",c);
        len=strlen(c);
        flag=true;
        if(c[0]=='-') {flag=false;top=1;}
        for(int i=len-1;i>=top;i--)
            a[len-i]=c[i]-'0';
    }
    void print(){
        if(!flag) printf("-");
        for(int i=len;i>=1;i--)
            printf("%d",a[i]);
    }
}a,ans,b;
int main(){
    a.scan();b.scan();
    ans=a-b;
    ans.print();
return 0;
}

---

## 作者：yuanchenfei (赞：1)

#基础高精算法

在noi题库中数据很水就一边过掉

在洛谷出现了负数的情况就被卡了一半

进行讨论后ac

1.字符串读入逆序存储

2.比较两数大小，先比较位数比较不出来的话直接比较

3.如果减出来是负数就用大数减小数加负号

#4注意判断开头是不是为0！！！

    
           
    
           
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
int a[10005]={0},b[10005]={0},c[10005]={0};
int main()
{
    string aa,bb;
    cin>>aa>>bb;
    int m,n,mi,mx,mm;
    m=aa.length();
    n=bb.length();
    for(int i=1;i<=m;i++)
       a[i]=aa[m-i]-'0';
    for(int i=1;i<=n;i++)
       b[i]=bb[n-i]-'0';
       if(n>m)
        mx=n;
        else
        mx=m;
    if(m>n||(m==n&&aa>=bb))
     {
     for(int i=1;i<=mx;i++)
        {
            c[i]=a[i]-b[i]+c[i];
            while(c[i]<0)
            {
                a[i+1]--;
                c[i]+=10;
            }
        }
          int j=mx;
          while(c[j]==0)
          {
              j--;
              if(j==0)
              break;
          }
          if(j==0)
          cout<<0;
          for(int i=j;i>=1;i--)
           cout<<c[i];
    }
    else
    {
     for(int i=1;i<=mx;i++)
        {
            c[i]=b[i]-a[i]+c[i];
            while(c[i]<0)
            {
                b[i+1]--;
                c[i]+=10;
            }
        }
          int j=mx;
          while(c[j]==0)
          {
              j--;
              if(j==0)
              break;
          }
          if(j==0)
          cout<<0;
          else
          cout<<'-';
          for(int i=j;i>=1;i--)
           cout<<c[i];
    }
            return 0;
}
```

---

## 作者：iwajef (赞：1)

# 用C++中vector以及string写的，有兴趣可以看看

## 主要思路是把字符串倒序存到vector中，这样就能从左到右计算，在逆序存到vector<int> ans中，得到的就是正确结果，注意比较两个大整数的大小，个人觉得用C++自带的vector会比较好理解



    






```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    string str1, str2;
    cin >> str1 >> str2;
    string big_str, lit_str;  //比较两个字符串的大小，把大的字符串放在big_str，小的放在lit_str中
    if (str1.size() < str2.size()) {
        big_str = str2;
        lit_str = str1;
        cout << "-";
    }
    else if (str1.size() > str2.size()) {
        big_str = str1;
        lit_str = str2;
    }
    else if (str1.size() == str2.size()) {
        string::iterator s_iter1 = str1.begin(), s_iter2 = str2.begin();
        while (*s_iter1 == *s_iter2) {
            s_iter1++;
            s_iter2++;
            if (s_iter1 == str1.end() && s_iter2 == str2.end()) {
                cout << "0" << endl;
                return 0;  //若两个字符串完全相等则直接输出“0”，退出程序
            }
        }
        if (*s_iter1 > *s_iter2) {
            big_str = str1;
            lit_str = str2;
        }
        else if (*s_iter1 < *s_iter2) {
            big_str = str2;
            lit_str = str1;
            cout << "-";
        }
    }
    vector<int> r_ivec1, r_ivec2, r_ans;
    for (int i = big_str.size() - 1; i >= 0; i--) {
        int x = big_str[i] - '0';
        r_ivec1.push_back(x);
    }
    for (int i = lit_str.size() - 1; i >= 0; i--) {
        int x = lit_str[i] - '0';
        r_ivec2.push_back(x);
    }  //以上为逆序储存到vector<int> r_ivec1, r_ivec2中
    if (r_ivec1.size() < r_ivec2.size()) {
        int times = r_ivec2.size() - r_ivec1.size();
        r_ivec1.insert(r_ivec1.end(), times, 0);
    }
    else if (r_ivec1.size() > r_ivec2.size()) {
        int times = r_ivec1.size() - r_ivec2.size();
        r_ivec2.insert(r_ivec2.end(), times, 0);
    }  //位数小的要补零，否则计算时会runtime error
    vector<int>::iterator iter1 = r_ivec1.begin(), iter2 = r_ivec2.begin();
    while (iter1 != r_ivec1.end() && iter2 != r_ivec2.end()) {
        int temp_ans = (*iter1) - (*iter2);
        bool judge = false;
        if (temp_ans < 0) {
            temp_ans += 10;
            judge = true;
        }
        if (judge) {
            iter1++;
            (*iter1)--;
        }
        r_ans.push_back(temp_ans);
        iter1++;
        iter2++;
        if (judge)
            iter1--;
    }
    vector<int> ans;
    for (vector<int>::reverse_iterator r_iter = r_ans.rbegin(); r_iter != r_ans.rend(); r_iter++) {
        ans.push_back(*r_iter);
    }
    vector<int>::iterator iter = ans.begin();
    while (iter != ans.end()) {
        if (*iter != 0) {
            break;
        }  //找到第一个不为 0 的数字，iter返回其位置
        iter++;
    }
    for (iter; iter != ans.end(); iter++) {  //从第一个不为0的数字开始输出
        cout << *iter;
    }
    cout << endl;
    return 0;
}
```

---

## 作者：eagadsgbsadfhb (赞：1)

[c]
```cpp
#include<stdio.h>
#include<string.h>
char a[101],b[101],c[101],d[101],e[101];
int i,la,lb,n,t;
int main()
{
    gets(c);
    gets(d);
    if (strcmp(c,d)==0)
    {
        printf("0");
        return 0;
```
}\相等输出0
```cpp
    la=strlen(c);
    lb=strlen(d);
    if (la>lb||(la==lb&&strcmp(c,d)>0))
    {
        strcpy(a,c);
        strcpy(b,d);
    }
    else
    {
        printf("-");
        strcpy(a,d);
        strcpy(b,c);
```
}\处理负数
```cpp
    la=strlen(a);
    lb=strlen(b);
    t=0;
    for(i=1;i<=la;i++)
    {
        n=a[la-i]-48;
        n=n-t;
        if (lb>=i) n=n-b[lb-i]+48;
        if (n<0)
        {
            n+=10;
            t=1;
        }
        else t=0;
        e[i-1]=n+48;
```
}\相减
```cpp
    while(e[la-1]=='0')
        la--;\处理0
    for(i=la-1;i>=0;i--)
        printf("%c",e[i]);\倒序输出
    return 0;
}
```

---

## 作者：Tony (赞：1)

```cpp
#include<iostream>
#include<string>
#include<cstdlib>
using namespace std;
int gjj(string s1,string s2)//将程序放在一个函数里，方便调用。 
{
    string zzz;
    cin>>s1>>s2;
    int sa[101]={0},sb[101]={0},c[101]={0},l=1;
    sa[0]=s1.length();
    sb[0]=s2.length();
    if(sb[0]>sa[0])//判断是否为负数。 
    {
        cout<<"-";
        zzz=s1;
        s1=s2;
        s2=zzz;
    }
    if(sb[0]==sa[0])
    {
        for(int i=0;i<sa[0];i++)
        {
            if(s2[i]>s1[i])
            {
                cout<<"-";
                zzz=s1;
                s1=s2;
                s2=zzz;
                break;
            }
            if(s1[i]>s2[i])
            {
                break;
            }
        }
    }
    sa[0]=s1.length();
    sb[0]=s2.length();
    for(int i=1;i<=sa[0];i++)
    {
        sa[i]=s1[sa[0]-i]-'0';
    }
    for(int i=1;i<=sb[0];i++)
    {
        sb[i]=s2[sb[0]-i]-'0';
    }
    while(l<=sa[0] || l<=sb[0])//进行运算 。 
    {
        if(sa[l]<sb[l])
        {
            sa[l]+=10;
            sa[l+1]--;
        }
        c[l]=sa[l]-sb[l];
        l++;
    }
    l-=1;
    while(c[l]==0 && l>1)//去零。 
        l--; 
    while(l>0)
    {
        cout<<c[l];
        l--;
    }
}
main()
{
    string a,b;
    gjj(a,b);
    cout<<endl;
    system("pause");
    return 0;
}
```

---

## 作者：Megumi_Cold (赞：1)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
    string d,e,f;
    int a[101]={0},b[101]={0},c[101]={0},g=0,h,k,l;
    cin>>d>>e;//输入
    h=d.size();//求长度
    k=e.size();/求长度
    if (k>h)
    g=1;//标志
    if (k==h)
    for (int i=0;i<h;i++)
    {
    if (d[i]>e[i])
    break;
    if (e[i]>d[i])
    g=1;
    if (e[i]=d[i])
    g=2;
    }
    if (g==2)
    cout<<0<<endl;
    if (g==1)
    {
    cout<<"-";//判断负数
    f=d;
    d=e;
    e=f;
    h=d.size();
    k=e.size();
    }
    for (int i=0;i<h;i++)
    a[h-i]=d[i]-'0';
    for (int i=0;i<k;i++)
    b[k-i]=e[i]-'0';
    for (int i=1;i<=h||i<=k;i++)
    {
    if (a[i]<b[i])
    {
    a[i]=a[i]+10;
    a[i+1]--;
    }
    c[i]=a[i]-b[i];
    l=i;
    }
    while (c[l]==0&&l>=1)//去0
    l--;
    for (int i=l;i>0;i--)//输出
    cout<<c[i];
    return 0;
}

```

---

## 作者：Until_The_Day (赞：1)

从键盘读入两个正整数，求它们的差。

分析：类似加法，可以用竖式求减法。在做减法运算时，需要注意的是：被减数必须比减数大，同时需要处理借位。

因此，可以写出如下关系式

if a[i]<b[i] then begin a[i+1]:=a[i+1]-1;a[i]:=a[i]+10 end

c[i]:=a[i]-b[i]

类似，高精度减法的参考程序：

```cpp
program exam2;
const
max=200;   
var
   a,b,c:array[1..max] of 0..9;
n,n1,n2:string;
   lena,lenb,lenc,i,x:integer;
begin
readln(n1);
readln(n2);
```
{处理被减数和减数}
if (length(n1)<length(n2)) or (length(n1)=length(n2)) and (n1<n2) then

```cpp
        begin
          n:=n1;n1:=n2;n2:=n;
          write('-');{n1<n2,结果为负数}
        end;
     lena:=length(n1); lenb:=length(n2);
     for i:=1 to lena do a[lena-i+1]:=ord(n1[i])-ord('0');
     for i:=1 to lenb do b[lenb-i+1]:=ord(n2[i])-ord('0');
     i:=1;
     while (i<=lena) or(i<=lenb) do begin
         x:=a[i]-b[i]+10+x;{不考虑大小问题，先往高位借10}
         c[i]:= x mod 10;{保存第i位的值}
         x:=x div 10-1;{将高位借掉的1减去}
         i:=i+1;
    end;
    lenc:=i;
  while (c[lenc]=0) and (lenc>1) do dec(lenc);  {最高位的0不输出}
  for i:=lenc downto 1 do write(c[i]);
```
writeln

end.
(满分程序{不可抄袭})

考虑负数


---

## 作者：Ufowoqqqo (赞：1)

**高精减**是非常经典的题目。[u]（当然了，在NOIP中基本是不会单独出来考的）[/u]因此，熟练的掌握是很有必要的。这里给出一个参考，未必是最优，欢迎各位提出意见。

```delphi

var i,l1,l2:longint;
    a,b,c:array [1..502] of longint;
    ch:array [1..502] of char;
    fan:boolean;
begin
 repeat//输入被减数，可以用array of char或ansistring储存
  inc(l1);
  read(ch[l1]);
 until eoln;
 for i:=1 to l1 do a[i]:=ord(ch[l1-i+1])-48;//转化为array of longint
 readln;
 repeat//对减数的处理同上
  inc(l2);
  read(ch[l2]);
 until eoln;
 for i:=1 to l2 do b[i]:=ord(ch[l2-i+1])-48;
 if (l1<l2) or (l1=l2) and (a[1]<b[1]) then//特殊情况：当差为负数时
  begin
   fan:=true;//负数标记为真，供后期判断是否输出负号
   //交换两个数，因为|a-b|=|b-a|，只需判断是否输出负号就行了
   for i:=1 to l1 do c[i]:=a[i];
   for i:=1 to l2 do a[i]:=b[i];
   fillchar(b,sizeof(b),0);
   for i:=1 to l1 do b[i]:=c[i];
   l1:=l2;//减法运算执行Max(Len1,Len2)次，这里用L1储存
  end;
 for i:=1 to l1 do
 begin
  c[i]:=a[i]-b[i];
  if (c[i]<0) and (i<l1) then//不是最高位时借位
   begin
    dec(a[i+1]);//注意这里要累减的不是c数组，应该是a数组
    inc(c[i],10);
   end;
 end;
 while c[l1]=0 do dec(l1);//找到最高的非0位
 if l1<=0 then//当差为0时，直接输出并退出
  begin
   writeln(0);
   halt;
  end;
 //输出差
 if fan then write('-');
 for i:=l1 downto 1 do write(c[i]);
end.

```

---

## 作者：殇祭 (赞：1)

##  高精度减法

和高精度减法在差为负数时处理的细节更多一点：当被减数小于减数时，差为负数，差的绝对值是减数减去被减数；在程序实现上用一个变量来存储符号位，用另一个数组存差的绝对值。

  算法流程：

（1）读入被减数S1，S2（字符串）；

（2）置符号位：判断被减数是否大于减数：大则将符号位置为空；小则将符号位置为“-”，交换减数与被减数；

（3）被减数与减数处理成数值，放在数组中；

（4）运算：

    A、取数；

    B、判断是否需要借位；

   C、减，将运算结果放到差数组相应位中；

   D、判断是否运算完成：是，转5；不是，转A；

（5）打印结果：符号位，第1位，循环处理第2到最后一位；

######下面是源代码：



```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    const int MAXN=1000001;
    using namespace std;
    int main() {
        string a1, b1, t;
        int a[MAXN] = {0}, b[MAXN] = {0}, c[MAXN] = {0};
        int lena, lenb, lenc;
        int i;
        cin >> a1 >> b1;
    while (a[lenc] == 0 && lenc > 0) lenc--; 
        memset(a,0,sizeof(a));  //不知道为什么，不赋0，在洛谷中就过不去
        memset(b,0,sizeof(b));
        memset(c,0,sizeof(c));
        lena = a1.length();
        lenb = b1.length();
        if (lena<lenb || lena==lenb && a1<b1) {    //两个数交换，保证被减数大 
            t = a1;
            a1 = b1;
            b1 = t;
            cout << "-";
        } 
    lena = a1.length();
        lenb = b1.length();
        for(i = 0; i < lena ; i++) a[i]=a1[lena-i-1]-'0';  //被减数倒序存入a数组
        for(i = 0; i < lenb ; i++) b[i]=b1[lenb-i-1]-'0';  //减数倒序存入b数组
        lenc = 0;
        while (lenc <= lena || lenc <= lenb) {             //从个位开始相减 
        if (a[lenc] < b[lenc]) {
            a[lenc] = a[lenc] + 10;                        //借位处理
            a[lenc + 1]--;                                 //借位处理
          }
            a[lenc] = a[lenc] - b[lenc];
        lenc++;
          }
        while (a[lenc] == 0 && lenc > 0) lenc--;           //前端处理掉无用的 0 
        for (i = lenc;i >= 0;i--) cout << a[i];
        return 0; 
    }
```
#### 具体步骤
比较 a 和 b 的大小。从而确定：结果的正负号；谁减谁

两个数按字符串读入之后，先判断它们的大小


     if (lena<lenb||lena==lenb && a1<b1){  
```cpp
    //两个数交换，保证被减数大 
     t = a1;
    a1 = b1;
    b1 = t;
    cout << "-";
     }
```
借位问题

    while (lenc <= lena || lenc <= lenb) {      //从个位开始相减 
if (a[lenc] < b[lenc]) {                //不够减时

a[lenc] = a[lenc] + 10;          //借位处理;

a[lenc + 1]--;                   //借位处理;

```cpp
            }
         a[lenc] = a[lenc] - b[lenc];
         lenc++;
          }
```
去掉结果前面多余的0。

while (a[lenc] == 0 && lenc > 0) lenc--;


---

## 作者：tjq0630 (赞：0)

 ```
#include<bits/stdc++.h>
using namespace std;
const int m=0x3f3f3f;
int main()
{
    //定义两个减数为字符数组n1，n2。并定义一个转换变量。 
	char n[m],n1[m],n2[m];
	//定义三个整型数组a，b,c。 
	long long a[m],b[m],c[m];
	//定义两个减数与结果的长度与借位为整型。
	int lena,lenb,lenc,i;
	//将a，b，c的值清零。
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	//输入减数和被减数。
	scanf("%s%s",n1,n2); //gets(a1),gets(b1);
	//比较减数与被减数大小。 
	if(strlen(n1)<strlen(n2)||(strlen(n1)==strlen(n2)&&strcmp(n1,n2)<0))//if语句后面如果有多条语句，要加大括号。 
	{
	//将 n1 的值完全存放n（过渡）。
	strcpy(n,n1);
    //将n2 的值完全赋给n1.
    strcpy(n1,n2);
    //将n 的值完全赋给n2.
    strcpy(n2,n);
    //交换了减数和被减数，结果为负数。 
	cout<<"-";
	}
	//字符串函数取字符串的长度赋值给 lena与lenb。 
	lena=strlen(n1);
	lenb=strlen(n2);
	//n1减数倒置放入a数组（对齐个位) 
	for(int i=1;i<=lena;i++) a[i]=n1[lena-i]-'0'; 
	//n2被减数倒置放入b数组（对齐个位) 
	for(int i=1;i<=lenb;i++) b[i]=n2[lenb-i]-'0'; 
	//从个位开始相减。 
	
	for(i=1;i<=lena;i++)
	{
		//比较被减数个位上的数与减数个位上的数。 
		if(a[i]<b[i])
		{
			//被减数上个位的数向十位借10。 
			a[i]+=10;
			// 十位上的数减1. 
			a[i+1]--;
		}
		// 相应位数相减
		c[i]=a[i]-b[i];
		//从低位往高位相减。 
		
	}
	//处理最高位为0 
	lenc=i;
	while((c[lenc]==0)&&(lenc>1)) lenc--;
	//输出结果
	for(i=lenc;i>=1;i--)  
	cout<<c[i];
	return 0;
}
```


---

## 作者：opened (赞：0)

 `高精度减法` 和 `高精度加法` 相比，减法在**差为负数**时处理的细节更多一点：当被减数小于减数时，差为负数，差的绝对值是减数减去被减数；在程序实现上用一个变量来存储符号位，用另一个数组存差的绝对值。

**同时注意注意消除前导 $0$**


```

#include<iostream>

#include<cstdio>
  
using namespace std;

const int maxn=10500;

struct SuperNum{

        int flag;
        int s[maxn];
        SuperNum(){
            flag=0;
            for(int i=1;i<maxn;i++)  s[i]=0;
            s[0]=1;
        }
        SuperNum(string x){
            flag=0;
            s[0]=x.length();
            for(int i=1;i<=s[0];i++)
                s[i]=x[s[0]-i]-'0';
            for (int i=s[0]+1;i<maxn;i++)
                s[i]=0;
        }
};

bool operator < (SuperNum a, SuperNum b){

        if(a.s[0]<b.s[0])  return 1;
        if(a.s[0]>b.s[0])  return 0;
        for(int i=a.s[0];i>=1;i--)
            if(a.s[i]>b.s[i])  return 0;
            else if(a.s[i]<b.s[i])  return 1;
        return 0;
}

SuperNum operator - (SuperNum a, SuperNum b){

        SuperNum c;
        for(int i=0;i<maxn;i++)  c.s[i]=0;
        if (a<b){
            c.flag=1;
            SuperNum tmp=a;
            a=b;
            b=tmp;
        }
        else
            c.flag=0;
        int s,jw=0;
        c.s[0]=a.s[0];
        for(int i=1;i<=c.s[0];i++){
            s=a.s[i]-b.s[i]-jw;
            if(s<0){
                jw=1;
                s+=10;
            }
            else jw=0;
            c.s[i]=s%10;
        }
        while(c.s[0]>1&&c.s[c.s[0]]==0)  c.s[0]-=1;
        return c;
}

void print(SuperNum c){

       if(c.flag==1)  cout<<"-";
       for(int i=c.s[0];i>=1;i--)
           cout<<c.s[i];
}

int main(){

        string a,b;
        cin>>a>>b;
        SuperNum x1(a),y1(b);
        SuperNum a2=x1-y1;
        print(a2);cout<<endl;
        return 0;
}
```

---

## 作者：凌云 (赞：0)

基本，要多练。

我就是智商低，n连wa

第六点两数相等，注意调试。


    
    
```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[20000],b[20000];//字符输入较为便捷
int c[20000],d[20000],e[20000];
int main(){
    cin>>a>>b;
    int l1,l2,p;
    l1=strlen(a);
    l2=strlen(b);
    p=l2;
    for(int i=0;i<=l1;i++){c[l1-i]=a[i]-'0';if(c[l1-1]<0)c[l1-1]=0;}//划重点：转字符为int 忘了就尴尬了
    for(int i=0;i<=l2;i++){d[l2-i]=b[i]-'0';if(d[l2-1]<0)d[l2-1]=0;}
    bool k=0,m=0;
    if (l1>=l2){
        p=l1;
        for(int i=1;i<=p;i++)swap(c[i],d[i]);
```
}//比较长度（得益于输入都是正整）
```cpp
    else m=1;
    for(int i=1;i<=p;i++)swap(c[i],d[i]);
    for(int i=p;i>=0;i--){
        if (c[i]>d[i])break;
        if (c[i]<d[i]){
            k=1;
            break;
```
}//逐位比较大小

```cpp
    }
    if(k){m=1;for(int i=0;i<p;i++)swap(c[i],d[i]);}
    for(int i=0;i<=p;i++){
        e[i]+=c[i]-d[i];
        if(e[i]<0)e[i]+=10,e[i+1]-=1;
    }
    k=0;
    if(m)cout<<"-";
    for(int i=0;i<p;i++){
        if(e[p-i]!=0 or i==p-1)k=1;
        if(k)cout<<e[p-i];    
    }
    cout<<endl;
}
```
常见问题
用2345 777777举例

1：775432

2：-224568

3：崩

解释一下：

1要输出负号（不要重复或缺失哦）。

2请对齐个位操作

3交换两个数的位置


---

## 作者：1jia1 (赞：0)

十分简单，除了用减法模板，还要比大小。如果a<b，就交换，减完后再输出负数。

```cpp
-#include<cstdio>-
-#include<string>-
-#include<cstring>-
-#include<iostream>-
-#define size 100001-
-using namespace std;-
-string n,m;-
-string minuses(string a,string b)-
-{-
-    int x[size],y[size],la=a.length(),lb=b.length(),lc,i-;
-    memset(y,0,sizeof(y));lc=max(la,lb);string ans;-
-    for (i=0;i<la;i++)x[la-i-1]=a[i]-48;-
-    for (i=0;i<lb;i++)y[lb-i-1]=b[i]-48;-
-    for (i=0;i<lc;i++)-
-    {-
-        x[i]-=y[i];-
-        if (x[i]<0)x[i+1]--,x[i]+=10;-
-    }-
-    while (!x[lc-1] && lc>1)lc--;-
-    for (i=lc-1;i+1;i--)ans.push_back(x[i]+48);-
-    return ans;-
-}-
-bool cmp(string a,string b)-
-{-
-    int i;-
--    if (a.length()<b.length())return 1;
-    if (a.length()>b.length())return 0;-
-    for (i=0;i<a.length();i++)if (a[i]<b[i])return 1;-
-    return 0;-
-}-
-int main()-
-{-
-    cin>>n>>m;-
-    if (cmp(n,m)){cout<<"-";swap(n,m);}-
-    cout<<minuses(n,m)<<endl;-
-}-
```

---


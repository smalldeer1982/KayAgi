# 冒险岛

## 题目背景

冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……


## 题目描述

棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。

路上有两种特殊符号可以改变棋子的行走。

一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。

还有一种是“\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\*”开始的连续的“\*”的数量。

每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。

如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。

若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？


## 说明/提示

【样例说明】

在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。

【数据范围】

对于50%的数据，1<=s的长度<=255,0<=n<=1000。

对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。


## 样例 #1

### 输入

```
yhfA>>>fhsdfa***>>>foaoad
3
5 6 6```

### 输出

```
20 5```

# 题解

## 作者：Mono_pigsicklie (赞：18)

## 思路：

## 纯模拟（不懂模拟的可以理解为就是你在玩这个游戏，你就是游戏人物，你在执行规则就可以了）

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,a,cishi=-1,tot=0;
int main() {
	getline(cin,s);
	scanf("%d",&n);
	int length=s.length()-1;
	for(int i=1; i<=n; i++) {
		scanf("%d",&a);
		cishi+=a;
		if(cishi>=length) cishi=length-1;
		if(s[cishi]=='>'&&s[cishi+1]=='>'&&s[cishi+2]=='>')
			while(s[cishi]=='>')cishi++;
		else if(s[cishi]=='*'&&s[cishi+1]=='*'&&s[cishi+2]=='*') {
			while(s[cishi+tot]=='*')tot++;
			cishi-=tot;
		}
		if(cishi<0)cishi=0;
		if(cishi>=length)cishi=length-1;
	}
	cout<<cishi+1<<' '<<length-1-cishi;
	return 0;
}
```


### 总结一下：有一些比较坑人的点（对于我这样脑子不大灵光的人）

### 1.刚开始的时候他还没有在棋盘上，一定要注意！！（卡了我一上午）不注意的话，洛谷上只能AC一半数据点。

### 2.样例我没过！！！（我的输出是20 4）代码玄学还是样例有误我不晓得，

### 3.while(s[cishi+tot]=='*')tot++;在判断倒退的时候一定是加上‘*’这个符号的格数，不然还是卡一半数据点。

## 4.读好题目读好题目读好题目（重要的事情来三遍）

---

## 作者：smallC233 (赞：10)

## 1.分析
其他题解已经把思路讲的非常清楚了，本题也只是使用到了 getline 输入的模拟题。**但是**，很多人却发现**本地输出结果与评测机或 IDE 不一样**的情况，那便很有可能是**使用 getline 不当导致的！** 我就特地来说明一下发生这个情况的原因吧。

- 首先， getline 是遇到 \n 停止，而生成的输入数据中，换行是 \r\n 。

- 在 **Windows 系统**下， \r\n 被读取的时候，会被系统**自动**换化成 \n 。也就是说，在输入文件中的 \r\n 被 getline 到 string 之后，其实就只有一个  \n 了。

- 但评测机使用的是 **Linux 系统**，\r\n **不会被处理**，所以 \r 会被读入字符串当中，字符串长度因此会**多一位**，导致出错。


因此我们需要特判一下：

```cpp
getline(cin,s);
int len=s.size()-1;		//len是字符串总长度
if(s[len]=='\r'){len--;}	//如果最后一位是'\r'就把它砍掉
```



## 2.代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

inline int read(void){   //快读
    register int x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9'){ch=getchar();}
    while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48); ch=getchar();}
    return x;
}
string s;
int n,x;
int now=-1;//当前位子，注意是从-1开始的！

int main()
{
    //freopen("data.txt","r",stdin);
    getline(cin,s);//因为有空格，所以用getline读入
    int len=s.size()-1;//前面说过的处理,len是字符串总长度
    if(s[len]==13){len--;}
    n=read();
    for(int i=1; i<=n; i++){
        x=read();//读入点数
        now+=x;//更新位置
        if(now>=len){now=len; continue;}//如果在已经超出右边界就直接continue了
        if(s[now]=='>'){
            int cnt=0;//用于计算需要前进/后退步数
            for(int j=now; j<=len; j++){//统计'>'与'*'的数量
                if(s[j]=='>'){
                    cnt++;
                }
                else{break;}
            }
            if(cnt>2) now+=cnt;//注意一定是当>=3时才会移动！
            if(now>len){now=len;}//注意是否会超出边界！
            continue;//注意奖励只会执行一次！
        }
        if(s[now]=='*'){//同上
            int cnt=0;
            for(int j=now; j<=len; j++){
                if(s[j]=='*'){
                    cnt++;
                }
                else{break;}
            }
            if(cnt>2) now-=cnt;
            if(now<0){now=0;}
            continue;
        }
    }
    printf("%d %d\n",now+1,len-now);
	return 0;
}

```




---

## 作者：fl_334 (赞：6)

本题坑点颇多，这里是给c++党的一些提示

#①后缀和优化，否则会TLE，分别给\*和>开两个后缀数组记录个数

#②移动下标初始赋值为-1，而不是0。因为c+党

#③最好用字符数组，不然**keneng**爆

#④结尾要这样输出cout<<noww+1<<" "<<l-noww-1<<endl;

就这么多了，我无可奉告

(⊙v⊙)嗯，祝大家好运~


---

## 作者：Sinwind (赞：4)

# 1.分析

1. 读入字符串：

- 读取棋纸上的路$(string$类$)$，注意字符串中可能会含有$'\space'($**空格**$)$，不能用$cin$，用$getline$，但用$getline$会将换行符读入，所以$len=way.length()-1$；

- $-1$的原理： 
	- 洛谷的数据有的是在$Windows$造出的$($例如本题$)$，换行符是$"\setminus r\setminus n"$，但洛谷的测试机是$Linux$系统，换行符是$"\setminus n"$；$Windows$的测试数据在$Linux$，$"\setminus n"$读取成换行符，$"\setminus r"$不是换行符，是不可见/空白字符，但是还会占据一个空间；

	- 在$Linux$中，用$cin$时，$"\setminus r","\setminus n"$是空白字符，$cin$读取到空白字符会停止，不影响；但用$getline$时，$"\setminus n","\setminus r"$会原样读入，多出一个$"\setminus r"$的空间，要减去。

2. 处理字符串：$way = "\space" + way$

- 在读取的字符串前面加上$"\space"($空格$)$，使得原字符串的第一位的下标变为$1$，最后一位的下标变为$len$，因为题目中也是从$1$开始算起。

3. 越界问题：

- 若超出右边界$(pos>len)$：停在最后一位$(pos=len)$，游戏结束$(break)$；

- 若超出左边界$(pos<1)$：停在第一位$(pos=1)$。

4. 特殊字符处理：$operation$函数

- 用$while$循环，计算出从$pos$位开始，连续的特殊符号$(op)$的个数$($包括$pos$位$)$；

- 若个数大于等于$3$,可以前进$/$后退，返回格数$(return\space cnt)$，否则返回$0$。

# 2.代码

```cpp
#include <iostream>
#include <string>

using namespace std;

string way;         //棋纸上的路
int len;            //路的长度
int n;              //掷骰子的次数
int point;          //每次掷骰子的点数
int pos = 0;        //棋子的位置

//特殊符号处理，输入当前符号，输入当前位置，
//若可以获得前进奖励/后退惩罚，则返回前进/后退的格数，否则返回0
int operation(char op, int pos)
{
	int cnt = 0;    //大于号的个数
	
	while(way[pos] == op)
	{
		cnt++;
		pos++;
	}
	
	if(cnt >= 3)
	{
		return cnt;
	}
	
	return 0;
}

int main(void)
{
	getline(cin, way);
	//Linux 要 -1
	len = way.length() - 1;
	way = " " + way;
	cin >> n;
	while(n--)
	{
		cin >> point;
		
		pos += point;
		
		//到达右边界
		if(pos > len)
		{
			pos = len;
            break;
		}
		
		if(way[pos] == '>')
		{
            pos += operation('>', pos);
            
		}
		else if(way[pos] == '*')
		{
			pos -= operation('*', pos);
			
		}
		
		//到达右边界
		if(pos > len)
		{
			pos = len;
            break;
		}
		//到达左边界
		if(pos < 1)
		{
			pos = 1;
		}
	}
	
	cout << pos << " " << len - pos << endl;
	
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

此题有2个坑，第一，输入的字串会有空格，因此要用getline(cin, s)，并且这样之后，字串长度计算时要-1，去掉换行符。

另外第五个点的数据有误，没有计算最后一步走完之后的惩罚。 我已经提交问题啦。目前的100分代码如下



        
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<iomanip>
#include<ctime>
#include<set>
#include<vector>
#include<list>
#include<cmath>
#include<cstdlib>
#include<string>
#include<cstring>
#include<fstream>
#include<queue>
#include<stack>
using namespace std;
long long a;
int main ()
{
    string s;
    long long b,c,d,n,k,j,i;
    getline(cin, s);
    d=-1;
    c=s.length() -1;
    cin>>b;
    for(i=0;i<b;++i)
    {
        cin>>a;
        d+=a;
        if(d>=c)
            d=c-1;
        if (d == c-1 || (i == b -1 && c == 185))  ///后面部分针对第五个点的错误数据
            break;
        if (d+2 < c)
        {
            if(s[d]=='>'&&s[d+1]=='>'&&s[d+2]=='>')
            {
                d += 2;
                while(d < c && s[d]=='>')
                {
                    d++;                
                }
            }            
            else if(s[d]=='*'&&s[d+1]=='*'&&s[d+2]=='*')
            {
                n=d;
                while(n < c && d > 0 && s[n]=='*')
                {
                    n++;
                    d--;                
                }
                //while(s[d]=='*'&&s[d+1]=='*'&&s[d+2]=='*')
                //{
                //    n=d;
                //    while(n < c && d > 0 && s[n]=='*')
                //    {
                //        n++;
                //        d--;                
                //    }
                //}
            }   
        }
        if(d<0)
            d=0;
        if(d>=c)
            d=c-1;       
        if (d == c-1)
            break;
    }
    cout<<d + 1 <<" "<<c-d-1;
    //while(true);
    return 0;
}
```

---

## 作者：FLASH_CM (赞：3)

相信大家都能发现这只是一道普通的模拟题，算法思路省略，主要将几个剪枝和注意事项。
### 【注意事项】
##### 1、每次移动后，最多进行一次奖励或惩罚，不会发生连锁反应。
##### 2、所有的数据点的起点都应该是-1，而不是样例中的0。
##### 3、在输入数据中包含空格，所以应该用gets或getline。
##### 4、在准备执行奖励或惩罚时，一定要奖励或惩罚的距离大于等于3（而不是2）。
##### 5、当棋子越过左起点或右终点时，要将其移动至左起点或右终点。
##### 6、如果用gets读入，要把字符串的长度减1.
### 【剪枝】
##### 由于数据非常的大，我们需要在程序之前对每个点奖励或惩罚的距离进行预处理（小贴士：从后往前枚举可以节约时间，因为不然就要先统计'>'或'*'的个数，再将沿途的点标记一遍），用一个数组来记录每一个奖励或惩罚点后面接的'>'或'*'的个数。具体实现见代码。
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

char s[1000010];

int add[1000010],a[1000010];

int main(){
	int len,i,j,k,m,n;
	gets(s);
	len=strlen(s)-1;			//要减去换行符所占的长度 
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(i=len-1;i>=0;i--){		//从后往前预处理奖励或惩罚的点 
		if(s[i]=='>'){
			if(s[i+1]!='>')
				add[i]=1;
			else
				add[i]=add[i+1]+1;
		}
		if(s[i]=='*'){
			if(s[i+1]!='*')
				add[i]=1;
			else
				add[i]=add[i+1]+1;
		}
	}
	a[1]--;						//由于所有测试数据的起点都为-1，所以第一步只能走啊a[1]-1步 
	k=0;
	for(i=1;i<=n;i++){
		k+=a[i];
		if(add[k]>=3){			//注意：题目说的是，一定要三个及以上距离 
			if(s[k]=='>')
				k+=add[k];
			else
			if(s[k]=='*')
				k-=add[k];
		}
		if(k<0)					//如果当前位置越出边界，则让它回到边界 
			k=0;
		if(k>len-1)
			k=len-1;
	}
	k++;						//题目中的第一个字符的位置是一，输入的字符串的第一个字符的位置是零，故需再次加上一 
	printf("%d %d\n",k,len-k);
	return 0;
}
```

---

## 作者：_0x46EDC (赞：3)

[获得更好的阅读体验](https://www.luogu.com.cn/blog/jasonying/luogu-p2628-mao-xian-dao) [题目传送门](https://www.luogu.com.cn/problem/P2628)

---
### 前言
看了看题解区代码都奆长，于是乎我要来写一篇题解

### 题目分析
模拟，掷骰子走路，遇到若干个`*`退后若干个，遇到若干个`>`可以直接前进到最前端，画了一张简陋的图片可以参考一下。（我自己都看不下去了就凑合着看看吧）

![](https://cdn.luogu.com.cn/upload/image_hosting/zkkqd3v2.png)

棕色的符号代表`>`，绿色的符号代表`*`，黑色的四角星代表任意一个非`>`或`*`的字符。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,p=-1;//棋子一开始不在地图上，棋子的位置应该标记为-1
int main(){
    getline(cin,s);
    cin>>n;
    for(int i=0,x,cnt=0;i<n;i++){//压行
        cin>>x;
        p+=x;//向前走
        if(s[p]=='*'&&s[p+1]=='*'&&s[p+2]=='*') while(s[p+cnt]=='*')cnt++;//计算*的个数
        if(s[p]=='>'&&s[p+1]=='>'&&s[p+2]=='>') while(s[p]=='>')p++;
        p=max(0,p);//边界判断
        p-=cnt;//处罚，如果没有走到*上cnt的值就是0，所以不用判断
        p=min(int(s.size()-2),p);//边界判断
    }
    cout<<p+1<<" "<<s.size()-p-2<<endl;
    return 0;
}
```
不要问我为什么这么多次提交，问就是坑太多

1. 一开始棋子并不在地图上，所以应该赋值-1

2. 如果连续的三个`*`或者`>`那么是不能获得处罚或奖励的，这个坑卡了我将近十次提交

3. 地图的末端应该是```s.size()-2```而不是```s.size()-1```，又卡了我十几次提交（其实算不上坑只是我太蒟了）

4. 最后的输出应该是p+1，因为题目中第一个位置是1，但是字符串第一个位置是0 ~~，其实是我懒得手写字符数组~~

### 结语
一奆堆坑，一定要认真读题，认真思考 ~~，否则就会像我一样浪费几十次提交~~

---
### update
2020.4.22 修复了缩进再次爆炸的问题

2020.4.22 修改了前言部分内容

---

## 作者：wisdom_grass (赞：2)

这一题是纯模拟，想水过，然而我提交了N次……

总结了几个坑：

1.每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。本人语文不好，刚读题以为可以落在'>'和'\*'各1次……

2.可能还没有掷骰子的时候自己就在'>'上……

3.棋纸有空格……

然后呢，最好预处理一下，防止TLE。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 
using namespace std;

const int maxs = 1000005;
const int maxn = 1000005;
int len;//字符串长度
char s[maxn];//字符串，最好用char
int n;//掷骰子数
int a[maxn];//每次掷出的数
int sum[maxn];//预处理存储
int weizhi = 0;//位置

void init() { //预处理一下特殊符号数，节省时间，避免不必要的重复
    for(int i=len-1;i>=0;i--) {//倒序预处理更省时间
        if(s[i] == '>') {
            if(s[i+1] != '>')
                sum[i] = 1;
            else
                sum[i] = sum[i+1] + 1;
        }
        if(s[i] == '*') {
            if(s [i+1] != '*')
                sum[i] = 1;
            else
                sum[i] = sum[i+1] + 1;
        }
    }
}
int main() {
    gets(s);//记住要用gets或getline
    len = strlen(s) - 1;
    cin >> n;
    for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
    }
    
    init();//初始化，预处理
    a[1]--;//第一次只能走a[1]-1步
    
    for(int i=0;i<=n;i++) {//从0开始，i=0时看看自己在不在特殊符号上
        weizhi += a[i];
        if(sum[weizhi] >= 3) {//题目要求是>2哦
            if(s[weizhi] == '>') {
                weizhi += sum[weizhi];
                continue;//一次只能做一种特殊操作
            }
            if(s[weizhi] == '*')
                weizhi -= sum[weizhi];    
        }
        
        if(weizhi < 0) weizhi = 0;
        if(weizhi > len - 1) weizhi = len - 1;
    }
    
    weizhi++;//字符串从0计数，答案是从1计数
    cout << weizhi << " " << len - weizhi;
    
    return 0;
}
```

---


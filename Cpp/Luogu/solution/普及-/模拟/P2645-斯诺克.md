# 斯诺克

## 题目背景

镇海中学开设了很多校本选修课程，有体育类、音乐类、美术类、无线电测向、航空航海航天模型制作等，力争使每位学生高中毕业后，能学到一门拿得出手的兴趣爱好，为将来的终身发展打下基础。在体育类的校本选修课程中，有一门课程是斯诺克台球。


## 题目描述

斯诺克台球比赛中有21个球，其中有15个红球，6个彩球（黄、绿、棕、蓝、粉、黑）。甲乙二人轮流打球。打一个红球得1分，打一个彩球的得分如下：

黄球：2分；        绿球：3分；         棕球：4分；

蓝球：5分；        粉球：6分；         黑球：7分；

最后以得分高者为胜。


简化后的打球规则如下：

1．如果有红球，第奇数次必须打红球，打过的红球从桌面上拿走；

2．每打一个红球后，可以任意选一个彩球打，打红球后接着打的彩球不从桌面上拿走；

3. 如果桌面上已经没有红球可打了，那么按照分值从小到大的次序打彩球，这时候每打一个彩球都从桌面上拿走。


打球时犯规的判罚如下：

1. 没有打中球，给对方加4分；

2．没有按照打球规则打该打的球，即打中了错误的球时：

（1）如果这个错误的球的分值大于4，那么给对方加等于这个球的分值；

（2）如果这个错误的球的分值不大于4，那么给对方加4分；

打中的错误球不从桌面上拿走。

请统计某局比赛进行到现在为止的比分。


## 说明/提示

【样例说明】

甲依次打了红球、黑球、红球、粉球，甲得15分（1+7+1+6）。

乙依次打了红球、黑球、红球，乙得9分（1+7+1）。

【数据范围】

80%的数据，每次总是打中球的，并且每次打中的球总是正确的，没有犯规情况。100%的数据，会有未打中或犯规情况。

保证输出不超过2^64-1.


没有什么难的，从头到尾除了判断就是循环，但是要特别细心，注意这道题强大的特判！


## 样例 #1

### 输入

```
4 3
1 7 1 6
1 7 1```

### 输出

```
15 9```

# 题解

## 作者：hmy521 (赞：23)

在说题解之前，我不得不吐槽这个题的数据

## 非  常  水！

我开始手动模拟，把可能都列出来：

```
#include<bits/stdc++.h>
using namespace std;
int red=15;//红球初始值5个 
long long jia=0;//甲初始得分为0 
long long yi=0;//乙初始得分为0 
void add_score(int score,int i,int name){
    if(score==0){//如果分数为0 
        if(name==0)yi+=4;//给 方 分 
        else jia+=4;    //对 加
    }else if(score==1){//分数等于1，即打中红球 
		if(i%2){//如果是第奇数次打的话（按照规则打） 
			red--;//拿走红球 
			if(name==0)jia++;//给 己 分 
			else yi++;      //自 加 
		}else{//如果是第偶数次打的话（打了错误的球） 
			if(name==0)yi+=4;//给 方 分 
			else jia+=4;    // 对 加 
		}
	}else{//分数超过一 ，即打彩球 
		if(i%2&&red){//如果在第奇数次打的，且桌面上还有红球（即打了错误的球） 
			if(score>4){//如果分数大于四 
				if(name==0)yi+=score;//给 方 分
				else jia+=score;    // 对 加 
			}else{//分数不大于四 
				if(name==0)yi+=4;//给 方 分
				else jia+=4;    // 对 加 
			}
		}else{//没犯规 
			if(name==0)jia+=score;//给 己 分
			else yi+=score;      //自 加 
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin>>n>>m;	
	for(int i=1;i<=n;i++){
		int ball;
		cin>>ball;
		add_score(ball,i,0);//计算分数（甲） 
	}	
	for(int i=1;i<=m;i++){
		int ball;
		cin>>ball;
		add_score(ball,i,1);//计算分数（乙） 
	}
	cout<<jia<<" "<<yi<<endl;
	return 0;
}
```
如此详细的代码，竟然只有**40分**！（而且不给数据！）

调了n小时，好像没啥毛病？？？

我开始了深入探究：

### 1.斯诺克
>         ——了解斯诺克台球

了解斯诺克的童鞋一定知道：斯诺克有1个白球，15个红球和6个彩球（黄、绿、咖啡、蓝、粉、黑）共22个球。

在不违反规则的情况下，红球入洞不捡；彩球入洞照样捡；和题目中给的一样。

这里斯诺克的规则不在详述。

### 2.题意
>         ——了解题意

打完一个红球必须打彩球，红球没了直接打彩球，否则按犯规处理（给对方加相应分）。不打也给对方加四分；如果老老实实按规矩打，自己加相应分。

### 3.思路&代码
>		   ——好像，没那么复杂

先给大家看看AC代码：

```
#include<bits/stdc++.h>
using namespace std;
long long jia=0;//甲初始得分为0 
long long yi=0;//乙初始得分为0 
void add_score(int score,int i,int name){
    if(score==0){//如果分数为0 
        if(name==0)yi+=4;//给 方 分 
        else jia+=4;    //对 加
    }else if(score==1){//分数等于1，即打中红球 
		if(name==0)jia++;//给 己 分 
		else yi++;      //自 加 
	}else{//分数超过一 ，即打彩球 
		if(name==0)jia+=score;//给 己 分
		else yi+=score;      //自 加 
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin>>n>>m;	
	for(int i=1;i<=n;i++){
		int ball;
		cin>>ball;
		add_score(ball,i,0);//计算分数（甲） 
	}	
	for(int i=1;i<=m;i++){
		int ball;
		cin>>ball;
		add_score(ball,i,1);//计算分数（乙） 
	}
	cout<<jia<<" "<<yi<<endl;
	return 0;
}
```
比较原来的代码，发现：

## 题目有bug：

1. 无需考虑打中的是什么球，管你怎么打，只要打中球了，直接给自己加分。（可以无视规则）

2. 所谓的“强大的特判”无非就是考虑没打中球的情况，对于这个，打过台球的人都知道。（多次强调却没有实际意义的特判）

3. 老实模拟的人反而错了（比如我，40分）

综上所述，我只能得出题目或数据有问题。（而且这哪是斯诺克啊！明明就是在打那些业余选手都会的普通台球！）希望管理员能重新修改此题的数据。

求通过

---

## 作者：brealid (赞：10)

吐槽一下这道题：

**数据太水了！！！**

$\sf \color{red} \texttt{请注意，这题如果你考虑了犯规的情况，那么你的分数。。。可能会和我一样，只有40分。}$

$\large \sf \color{red} \texttt{也就是说，这是一篇AC不了这道题的题解!!!}$

现在，我来讲一下这道题的正解：

1. 两个变量 ``less`` 和 ``color``: ``less`` 记录剩余颜色为 ``color`` 的球的个数，且场上没有颜色比 ``less`` 小的球。
2. 由题意，当场上没有红球时，第单数个球必须是红球
3. 当场上有红球时，第双数个球必须是彩球，且击打不消耗个数。
4. 当 ``less`` 为 ``0`` 时，``less = 0, color++;``

给出处理某一个人的伪代码：

```false-code
执行 n 次 {
    记录上次球的颜色
    读入这次球的颜色
    如果 (这次球的颜色为 0) {
        直接给对方加 4 分
    } 否则 如果 (这是第单数个球 并且 红球没有打完) {
        如果 (这次球的颜色不是 1) {
            如果 (这次球的颜色对应的分数比 4 大) {
               给对方加上这次球的颜色对应的分数
            } 否则 {
                给对方加 4 分
            }
        } 否则 {
            给自己加 1 分
            红球个数减 1
            如果 (已经没有红球了) {
                颜色加 1
                该颜色个数置为 1
            }
        }
    } else {
        if ((上次打的不是红球 && 这次打的颜色比应该打的颜色大) || 这次打了红球) {
            如果 (这次球的颜色对应的分数比 4 大) {
               给对方加上这次球的颜色对应的分数
            } 否则 {
                给对方加 4 分
            }
        } else {
            给自己加 这次球的颜色对应的分数 分
            如果 (这个不是红球后面紧随的球) 该球个数减 1;
            如果 (已经没有 color 颜色的球了) {
                颜色加 1
                该颜色个数置为 1
            }
        }
    }
}
```

## 最终代码

```cpp
/*
    Name: Z*** Y* (H***Z*** J***L** Middle School, China) 
    Copyright: 航空信奥
    Author: 航空信奥
    Date: 2018-10-19
    Description: the program that can solve snooker  
*/
#include <queue>
#include <vector>
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <algorithm>
using std::max;
using std::min;
using std::cerr;
using std::endl;
using std::sort;
using std::queue;
using std::vector;
using std::priority_queue; 

struct fast_IO {
#define fast_IO_all_DEBUG 0
#define fast_IO_read_DEBUG 0
#define fast_IO_write_DEBUG 0
    
    bool __read_sign_LowThan0; 
    char __read_buf_ch; 
    
    template <typename type> 
    void read(type &res)
    {
        __read_sign_LowThan0 = 0;
        __read_buf_ch = getchar();
        while (__read_buf_ch > '9' || __read_buf_ch < '0') {
            __read_buf_ch = getchar();
            if (__read_buf_ch == '-') {
                __read_sign_LowThan0 = 1;
                __read_buf_ch = getchar();
                break;
            }
        }
        res = (__read_buf_ch & 15); 
        __read_buf_ch = getchar();
        while (__read_buf_ch <= '9' && __read_buf_ch >= '0') {
            res = (res << 3) + (res << 1) + (__read_buf_ch & 15); 
            __read_buf_ch = getchar();
        }
        if (__read_sign_LowThan0) {
            res = ((~res) + 1);
        } 
#if fast_IO_all_DEBUG || fast_IO_read_DEBUG
        printf("[TEST $ read %d $ ]", res);
#endif
    }
} io;

#define read io.read
#define write io.write	

#define passing() fprintf(stderr, "passing line [%d] in function %s.\n", __LINE__, __FUNCTION__)
#define debug(x) cerr << "[debug] " << #x << " = " << x << endl 

#define Max_N (107) 
#define Max_M     
#define Max_K  
#define Max_LogN     
#define Max_LogM      
#define Max_LogK      
  
int n, m, k;
#define P 10007  
int a[Max_N] = {0};
bool used[Max_N] = {false};

#define FILE
int color = 1;
int less = 15;

void doit(int &n, int &mine, int &your)
{
	int t, las;
	for (int i = 1; i <= n; i++) {
		las = t;
		read(t);
		if (!t) {
			your += 4;
		} else if ((i & 1) && color == 1) {
			if (t != 1) {
				if (t > 4) {
					your += t;
				} else {
					your += 4;
				}
			} else {
				mine++;
				less--;
				if (less == 0) {
					color++;
					less = 1;
				}
			}
		} else {
			if ((las != 1 && t > color) || t == 1) {
				if (t > 4) {
					your += t;
				} else {
					your += 4;
				}
			} else {
				mine += t;
				if (las != 1 && color != 1) less--;
				if (less == 0) {
					color++;
					less = 1;
				}
			}
		}
//		printf("ball %d: %d:%d [color = %d eith %d in low]\n", t, mine, your, color, less);
	}
}

int main()
{
#ifdef FILE
	freopen("snooker.in", "r", stdin);
	freopen("snooker.out", "w", stdout);
#endif
    read(n);
    read(m);
    int ansa(0), ansb(0);
    doit(n, ansa, ansb);
    doit(m, ansb, ansa);
    printf("%d %d", ansa, ansb);
    return 0;
}
```

---

## 作者：enceladus (赞：10)

[安利博客](https://www.cnblogs.com/enceladus-return0/)

只有两篇题解，果断水一篇。QAQ

是一道模拟题。


------------

打球规则没有用
>1．如果有红球，第奇数次必须打红球，打过的红球从桌面上拿走；

>2．每打一个红球后，可以任意选一个彩球打，打红球后接着打的彩球不从桌面上拿走；

>3.如果桌面上已经没有红球可打了，那么按照分值从小到大的次序打彩球，这时候每打一个彩球都从桌面上拿走。

因为数据给的就是每次的得分，肯定合法。


------------

在让我们看看判罚规则

>1 没有打中球，给对方加4分；

>2．没有按照打球规则打该打的球，即打中了错误的球时：

>（1）如果这个错误的球的分值大于4，那么给对方加等于这个球的分值；

>（2）如果这个错误的球的分值不大于4，那么给对方加4分；

这是判罚规则。看完之后觉得很麻烦，


------------

但是看看输入样例

>（2）最后一个数字是0,表示没有打中球犯规，0只会出现在这二行的最后一个数字处；

>（3）打了错误球的犯规也只会出现在这二行最后一个数字处；

犯规只会在最后一个出现，只在最后特判就行


------------
让我们看看数据规定的这句话

>80%的数据，每次总是打中球的，并且每次打中的球总是正确的，没有犯规情况。100%的数据，会有未打中或犯规情况。


>没有什么难的，从头到尾除了判断就是循环，但是要特别细心，注意这道题强大的特判！

~~强大的特判~~ 
fake 数据水的要死。
只需判断是不是零即可。是零加4.

两次循环时一次是n，另一次是m。不要写错（不要问我怎么知道的）

 **_有锅的代码_  ** QWQ 不要抄袭 小心变棕
```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>
#include<cctype>
#define INF 0x7fffffff
#define ll long long
#define IL inline
#define R register
using namespace std;
int n;int m;
int jf;int yf;
int ansj=0;
int ansy=0;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>jf;
		ansj+=jf;
        if(jf==0)
        {
        	ansy+=4;
		}
	}
	for(int i=1;i<=m;i++)
	{
		cin>>yf;
		ansy+=yf;
        if(yf==0)
        {
        	ansj+=4;
		}
	}
	cout<<ansj<<' '<<ansy<<endl;
	return 0;
}

```
by enceladus


---

## 作者：Deny_小田 (赞：10)

LX（楼下）的代码有点长，其实没有必要，题目中所谓的“强大的特判”也仅仅是判断是否为0.


代码：





```cpp
#include <cstdio>
int main(int argc, char const *argv[]){
    int n,m,x,sum1 = 0,sum2 = 0;
    scanf("%d %d",&n,&m);
    for(int i = 0; i < n; i++){ scanf("%d",&x); sum1 += x; if(!x) sum2 += 4; }
    for(int i = 0; i < m; i++){ scanf("%d",&x); sum2 += x; if(!x) sum1 += 4; }
    printf("%d %d\n",sum1,sum2);
    return 0;
}
额。。。是不是很短？？？
```

---

## 作者：yibaokuangquanshui (赞：3)

这个题别看他题目这么多废话，实则简单的一批，~~大佬别di~~
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,sumj,sumy;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);//输入 
		sumj+=x;//没事就直接加分值 
		if(x==0)sumy+=4;//特判如果犯规就给对方加4分 
	}
	for(int i=1;i<=m;i++)//同上 
	{
		int x;scanf("%d",&x);
		sumy+=x;
		if(x==0)sumj+=4;
	}
	printf("%d %d\n",sumj,sumy);
}
```


---

## 作者：封禁用户 (赞：3)

没什么难的，除了[colour=red]循环[/colour]就是[colour=red]判断[/colour].要特别的细心，还有就是特判。以下是代码：

```delphi

var  
  n,m,red,cur,x,y:int64;  
  i:longint;  
  a,b:array[0..10000000]of int64;  
begin  
  readln(n,m);  
  for i:=1 to n do read(a[i]);  
  readln;  
  for i:=1 to m do read(b[i]);  
  x:=0;y:=0;cur:=2;red:=15;  
  for i:=1 to n-1 do begin  
    x:=x+a[i];  
    if a[i]=1 then dec(red);  
         if (a[i]>1) and (a[i-1]>1) then cur:=a[i]+1;  
      end;  
  
      if a[n]=0 then y:=y+4  
      else if a[n]=1 then begin  
         if a[n-1]<>1 then begin  
            x:=x+a[n];  
            dec(red);  
         end else begin  
            y:=y+4;  
         end;  
      end else begin  
         if a[n-1]=1 then x:=x+a[n]  
         else begin  
            if (red=0) and (a[n]=cur) then begin  
               x:=x+a[n];  
               inc(cur);  
            end else begin  
               if a[n]>4 then y:=y+a[n]  
                  else y:=y+4;  
            end;  
         end;  
      end;  
  
      for i:=1 to m-1 do begin  
         y:=y+b[i];  
         if b[i]=1 then dec(red);  
         if (b[i]>1) and (b[i-1]>1) then cur:=b[i]+1;  
      end;  
      if b[m]=0 then x:=x+4  
      else if b[m]=1 then begin  
         if b[m-1]<>1 then begin  
            y:=y+b[m];  
            dec(red);  
         end else begin  
            x:=x+4;  
         end;  
      end else begin  
         if b[m-1]=1 then y:=y+b[m]  
         else begin  
            if (red=0) and (b[m]=cur) then begin  
               y:=y+b[m];  
               inc(cur);  
            end else begin  
               if b[m]>4 then x:=x+b[m]  
                  else x:=x+4;  
            end;  
         end;  
      end;  
      write(x,' ',y);  
end.  

```

---

## 作者：PDY08 (赞：3)

#### “注意这道题强大的特判！”
不要被这句话吓到，其实这道题的数据很水的。
### 思路
题目也没告诉你有什么球，所以只用到最后判断是否犯规就可以了。

~~因为题目也没有给出有犯规的样例嘛。~~
#### 上代码 ~~特简单~~
```cpp
#include<iostream>
using namespace std;
int main(){
	int a,n,m,x=0,y=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a;
		x+=a;//先把它们都加上再说
		if((i==n)&&(a==0))y+=4;//甲有犯规就乙加分
	}
	for(int i=1;i<=m;i++){
		cin>>a;
		y+=a;//也是如此
		if((i==m)&&(a==0))x+=4;//乙有犯规就甲加分
	}
	cout<<x<<" "<<y;
}
```
[测评结果](https://www.luogu.com.cn/record/33610283#)

---

## 作者：风之影音 (赞：3)

这是本弱鸡的第8篇题解。

还是那句话，如有雷同，纯属巧合。

这题。。。身为弱鸡的我都觉得很水。。。


看到此题，~~作为普及组二等奖的我~~，当然要尝试一下啦~~ ~~（其他题也是这么想的，但大部分都以失败告终）~~ 试了几次，没想到真的过了。看了几位大佬的题解，啥都没看懂。我觉得还是我的方法~~水题比较好~~。

好啦，不扯了，详细内容看代码。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int main(){
	int n,m,k,l,cnt1=0,cnt2=0;//命名
	cin>>n>>m;//输入两次打的个数
	for(int i=1;i<=n;i++){
		cin>>k;//输入第一次打的
		cnt1+=k;//计数器加相应的分数
		if(k==0)//特判犯规
		cnt2+=4;//给对手加分
	}
	for(int i=1;i<=m;i++){//同上
		cin>>l;
		cnt2+=l;
		if(l==0)
		cnt1+=4;
	}
	cout<<cnt1<<" "<<cnt2;//输出计数器
	return 0;//完美结束
}

```
[来参观一下呗~~~](https://www.luogu.com.cn/blog/fengzhiyy/)

~~我觉得我码风还不错吧，~~ 详细内容代码里都解释过了，我就先溜啦溜啦~~~

PS：管理员大人求过orz


---

## 作者：Aragron_II (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P2645)


------------


#### 这题居然是个橙题，不可思议。

$ 做法：$

1.输入甲的 $ n $ 次连续打球情况和乙的 $ m $ 次连续打球情况

2.如果甲序列中出现 $ 0 $，那么给对手加 $ 4 $ 分，否则就将每次打球情况累加，乙序列同理

3.输出

数据也挺水的

代码真的很短，只有20行，看其他大佬只有9行
Orz%%%

### Code:
```
#include <bits/stdc++.h>
using namespace std;
int n,m,sum1,sum2;
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		int x;
		cin>>x;
		sum1+=x;
		if(!x) sum2+=4;
	}
	for(int i=1;i<=m;i++) {
		int y;
		cin>>y;
		sum2+=y;
		if(!y) sum1+=4;
	}
	cout<<sum1<<' '<<sum2<<endl;
	return 0;
} 
```


---

## 作者：灵光一闪 (赞：2)

~~这题出的差评~~，数据过水，但是没办法，规则把数据限制住惹

因为这个词：**连续**打球情况

对，是：

# 连续

因为连续，所以只可能在最后一次造成犯规，但是这数据是可以优化的！比如这个:
```
30 3
1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
2 3 6
//第二行是15个1 2
这时候很明显，乙在最后一球时犯规了！所以应该甲是51，乙是5，但是这题AC代码并不能处理这种情况，比如下面这个代码:
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;
int ans_first,ans_second;
int n,m;
bool flag=false;
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int a;
        cin>>a;
        if(a==0){
            ans_second+=4;
            break;
        }
        if(!flag&&a==1){
            ans_first+=1;
        }
        else{
            ans_first+=a;
        }
        flag=!flag;
    }
    for(int i=0;i<m;i++){
        int a;
        cin>>a;
        if(a==0){
            ans_first+=4;
            break;
        }
        if(!flag&&a==1){
            ans_second+=1;
        }
        else{
            ans_second+=a;
        }
        flag=!flag;
    }
    cout<<ans_first<<" "<<ans_second<<endl;
    return 0;
}
```

所以这个代码虽然有缺陷，但是因为数据的原因却能AC，请修改

The End.

---

## 作者：血色黄昏 (赞：0)

大大大大大大大水题

水一发python题解~~老没有py的~~QAQ

题目看下去真的烦，结果发现是普及-

代码如下~禁止抄袭！
```python
s = input().split()#输入
sun = 0#第一个分数
sun1 = 0#第二个分数
n, m = int(s[0]), int(s[1])#换成n, m
l = input().split()#输入
l1 = input().split()#输入
for i in range(n):
    x = int(l[i])#分数
    sun += x#加上分数
    if x == 0:#如果犯规
        sun1 += 4#对方加4
for i in range(m):#如上
    x = int(l1[i])
    sun1 += x
    if x == 0:
        sun += 4
print(sun, sun1)#输出
```

求通过~

---


# 众数

## 题目背景

Alice 和 Bob 玩游戏。



## 题目描述

Alice 现在有一个序列 $a_1,a_2,...a_n$。

现在她需要 Bob 支持询问一个区间内的众数,还要支持修改一个位置的 $a_i$。

## 说明/提示

对于 $100\%$ 的数据 $n,m \le 1000$。

对于查询操作满足 $x\le y$。

任意时刻 $0<a_i\le 10^9$。

## 样例 #1

### 输入

```
5 3
1 1 2 2 1
0 1 4
1 2 3
0 1 4```

### 输出

```
1
2```

# 题解

## 作者：mike_he (赞：15)

由于数据规模很小，故可暴力模拟。map<int,int>记录出现次数，如果和当前最大，相等就判断一下哪个更小。

[codec]


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
using namespace std;
int N,Q;
int main(){
    cin>>N>>Q;
    int a[1001];
    for(int i=1;i<=N;++i){
        cin>>a[i];
    }
    int fl;
    int maxn=-100000000;
    int ans;
    while(Q--){
        int l,r;
        map<int,int> idx;
        ans=10000; //初始化
        maxn=-100000000; //初始化
        cin>>fl>>l>>r;
        if(fl){
            a[l]=r;
        }else{
            for(int i=l;i<=r;++i){
                idx[a[i]]+=1; //a[i]出现次数+1
                if(idx[a[i]]>maxn){
                    maxn=idx[a[i]];
                    ans=a[i];
                }else if(idx[a[i]]==maxn){ //判断谁更小
                    ans=(ans>a[i]?a[i]:ans);
                }
            }
            cout<<ans<<endl;
        }
    }
    return 0;
}
[/codec]
```

---

## 作者：zhangzhaoke (赞：10)

思路别人已经说的很清楚了，本猫来说一下题目

众数：出现次数最多的数字

例如：1 2 3 5 6 4 5 3 3 3就是众数，因为出现的次数最多

本猫的代码

```cpp
#include <iostream>
#include <algorithm>//sort头文件 
using namespace std;
int a[2927],b[2927];//定义 
void zhongshu(int i,int j){
    for (int k=i;k<=j;k++)b[k]=a[k];//找范围,保存 
    sort(b+i,b+j+1);//sort排序,不会的请出门右转百度 
    int answer=0,tmp=1,maxx=0;//max是保留字 
    for (int k=i+1;k<=j;k++){
        if (b[k]!=b[k-1]){
        	if (tmp>answer){//找最多的数 
				maxx=b[k-1];
				answer=tmp;
			}
			tmp=1;//重置 
		}
        else tmp++;//别忘了++ 
    }
    if (tmp>answer){//如果比当前最大的大,就替换 
	maxx=b[j];
	answer=tmp;
	}
   cout<<maxx<<endl;//输出最多的 
}
int main(){
    int n,m;
    cin>>n>>m;//输入 
    for (int i=1;i<=n;i++)cin>>a[i];//输入 
    for (int i=1;i<=m;i++){
        int g,h,l;
        cin>>g>>h>>l;//输入 
        if (g==0)zhongshu(h,l);//调用函数 
        else a[h]=l;
    }
    return 0;
}
```
~~华丽的结尾~~

---

## 作者：Camorgx (赞：6)

我看这一题没有用C++11的题解，我就来一篇。

我感觉通篇STL的程序真的是很清爽呢 ~~我才不管他会不会超时~~

楼上已经把思路解释的很清楚了，我就不多说了，具体解释看代码。

~~抄题解的同学别忘了选C++11哦~~
```cpp
#include<cstdio>
#include<unordered_map>
using namespace std;
int a[1005];
unordered_map<int,int> m;//C++11黑科技，比map不知道快到哪里去了
inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		s=s*10+ch-48,ch=getchar();
	return s*w;
}//标准快读
inline int work(int l,int r) {
	int anss=-1,ans[1001],tot=0,res=0x7fffffff;
    m.clear();//千万别忘了
	for(int i=l,j=1;i<=r;++i,++j) m[a[i]]++;
	for(auto i=m.begin();i!=m.end();i++) //懒人就要用auto
		if(anss<i->second) anss=i->second;
	for(auto i=m.begin();i!=m.end();i++) 
	    if(anss==i->second) ans[++tot]=i->first;//因为众数可能不止一个，所以要先存起来再找
	for(int i=1;i<=tot;++i) if(res>ans[i]) res=ans[i];
	return res;
}
int main() {
	int n=read(),m=read();
	for(int i=1;i<=n;++i) a[i]=read();
	while(m--) {
		int flag=read(),x=read(),y=read();//用快读的好处就是可以吧声明和读入放在一起
		if(!flag) printf("%d\n",work(x,y));
		else a[x]=y;//暴力模拟
	}
	return 0;
}
```

---

## 作者：philosopherchang (赞：3)

这道题一共不到1000个数，所以直接暴力模拟。

先设置一个结构体。

```cpp
struct node{
	int s,sum;//s储存输入的数，sum储存数字出现的次数 
}f[1001];

```

然后遇到flag=0,就改值，遇到flag=1就查询，但要在每次查询完以后都要把f[ ].sum清0，否则sum肯定会一遍遍累加。

核心代码如下：

```cpp
for(int i=1;i<=m;i++)
	{
		maxn=0;//maxn记录f[].sum的最大值
		zu=0;//zu是最后的众数
		cin>>x>>y>>z;
		if(x==1)
		{
			f[y].s=z;
			a[y]=f[y].s;
		}//改数，没什么可说
		else//感觉这一段会比较难懂
		{
			for(int j=y;j<=z;j++)
			{
				for(int k=y;k<=j;k++)//我们查找此区间中在这个数之前（包括此数）的那一堆数，如果发现有和这个数相同的数，我们就在之前的那个数的sum上+1，而不管当前位置上的数，这就避免了出现一群相同sum的情况，方便我们接下来的排序查找。
				{
					if(f[j].s==f[k].s)
					{
						f[k].sum++;
						break;//找到就停
					}
				}
			}
			sort(f+y,f+z+1,cmp);//cmp是按s的大小排
			for(int j=y;j<=z;j++)//查找
			{
				if(f[j].sum>maxn)
				{
					maxn=f[j].sum;
					zu=f[j].s;
				}
			}
			cout<<zu<<endl;
			for(int j=y;j<=z;j++)//把所有数的sum清0
			{
				f[j].s=a[j];
				f[j].sum=0;
			}
		}
	}

```
下面贴一下完整代码吧

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
int x,y,z;
int maxn,w,zu,a[1001];
struct node{
	int s,sum;
}f[1001];
int cmp(node a,node b)//排序函数
{
	return a.s<b.s;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>f[i].s;
		a[i]=f[i].s;
	}
	for(int i=1;i<=m;i++)
	{
		maxn=0;
		zu=0;
		cin>>x>>y>>z;
		if(x==1)
		{
			f[y].s=z;
			a[y]=f[y].s;
		}
		else
		{
			for(int j=y;j<=z;j++)
			{
				for(int k=y;k<=j;k++)
				{
					if(f[j].s==f[k].s)
					{
						f[k].sum++;
						break;
					}
				}
			}
			sort(f+y,f+z+1,cmp);
			for(int j=y;j<=z;j++)
			{
				if(f[j].sum>maxn)
				{
					maxn=f[j].sum;
					zu=f[j].s;
				}
			}
			cout<<zu<<endl;
			for(int j=y;j<=z;j++)
			{
				f[j].s=a[j];
				f[j].sum=0;
			}
		}
	}
}
```
求过ヾ(๑╹◡╹)ﾉ"

---

## 作者：ererer (赞：3)

竟然只有这么少的题解，而且还是C++的，来一发Pascal.





```cpp
var i,j,n,m,max,x,y,t,flag:longint;
    a,b,c:array[0..1001]of longint;
procedure sort(l,r:integer);//快排，不解释。
  var i,j,x,y:longint;
  begin
    i:=l;
    j:=r;
    x:=b[(l+r) div 2];
    repeat
      while b[i]<x do i:=i+1;
      while x<b[j] do j:=j-1;
      if i<=j then
      begin
        y:=b[i];
        b[i]:=b[j];
        b[j]:=y;
        i:=i+1;
        j:=j-1;
      end;
    until i>j;
    if l<j then sort(l,j);
    if i<r then sort(i,r);
  end;
function work(x1,y1:integer):longint;
  var i,j,max,maxn:longint;//计算众数.
  begin
    work:=0;
    for i:=x1 to y1 do b[i]:=a[i];//得到区间后赋给另一个数组来快排.
    sort(x1,y1);
    j:=b[x1];
    max:=0;
    maxn:=0;
    for i:=x1 to y1 do//快排后会快很多.
      begin
        if j=b[i] then inc(maxn)
        else
          if maxn>max then//自己理解吧
            begin
              max:=maxn;
              maxn:=1;
              work:=j;
              j:=b[i];
            end
            else
              begin
                maxn:=1;
                j:=b[i];
              end;
      end;
    if maxn>max then
      begin
        max:=maxn;
        maxn:=1;
        work:=j;
        j:=b[i];
      end;
  end;
procedure readit;
  begin
    readln(n,m);
    t:=0;
    for i:=1 to n do read(a[i]);
    for i:=1 to m do
      begin
        readln(flag,x,y);
        if flag=0 then begin inc(t); c[t]:=work(x,y); end;//模拟.
        if flag=1 then a[x]:=y;
      end;
    for i:=1 to t do writeln(c[i]);
  end;
begin
  readit;//......
end.
```

---

## 作者：皮卡丘最萌 (赞：1)

一开始看到这题还以为要用什么玄学算法，一看数据范围。。果断暴力！

首先普及一下众数：

例如有10个数：1 5 8 4 6 7 8 6 1 1。

这里面1的个数最多，是3个，所以1就是众数。

接下来的问题就是如何找出众数。

考虑这样一个序列：5 4 6 8 5，我们先对它进行排序：4 5 5 6 8。

然后我们从第二位开始，判断是否和前一位相同，如果是，则计数器加1；如果不是，判断计数器个数是否大于最大值，并将计数器重新赋值为1.

还有一个注意点：如果数列为6 6 6 6 6做完后依然没有和最大值比较，这个时候需要特判。

贴代码：
```pascal
var n,m,i,j,x,y,z,t,t1,max,max1:longint;
a,b:array[0..100001] of longint;
    procedure sort(l,r: longint);
      var i,j,x,y: longint;
      begin
         i:=l; j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do inc(i);
           while x<a[j] do dec(j);
           if not(i>j) then
             begin
             y:=a[i];a[i]:=a[j];a[j]:=y;
             inc(i); j:=j-1;
             end;
         until i>j;
         if l<j then sort(l,j);
         if i<r then sort(i,r);
      end;                         //快排不解释
begin
readln(n,m);
for i:=1 to n do read(b[i]);
for i:=1 to m do
  begin
  readln(z,x,y);
  if z=0 then
    begin
    a:=b;  sort(x,y);      //先保存在另一个数组，再进行排序
    max:=0; max1:=0; 
    t:=a[x]; t1:=1;               //初始化所有的计数器
    for j:=x+1 to y do
      if a[j]=a[j-1] then inc(t1)   //如果相等，计数器累加
        else
         begin
         if t1>max then begin max:=t1; max1:=t; end;
                 //不相等就与最大值比较，并保存
         t:=a[j]; t1:=1;     //将计数器重新赋值为1
         end;
    if t1>max then max1:=t;           //特判全是一样的情况
    writeln(max1);
    end
  else b[x]:=y;            //更改数值
  end;
end.
```


---


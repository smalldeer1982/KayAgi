# 覆盖

## 题目背景

WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。

## 题目描述

操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。

![](https://cdn.luogu.com.cn/upload/pic/1474.png) 

老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。

## 说明/提示

不会可以自己画图。

### 数据范围与约定

对于 $80\%$ 的数据，$1 \le N,M,B,G \le 10^2$。

对于 $100\%$ 的数据，$ 1 \le N,M,B,G \le 5 \times 10^3$。

## 样例 #1

### 输入

```
4 5 2 2
1 2
4 4
3 4
4 5```

### 输出

```
18```

# 题解

## 作者：翼德天尊 (赞：84)

**我又来~~水~~题解啦！**

不会的道友们跟我来！

## STEP 1 审题

1. 有一张图，知道长宽

2. 竖着填充b列，横着填充g列

3. 问有多少格未填充

是不是看着很简单，想直接动手暴力了呢？但是理智告诉我们，不优化就意味着——TLE

## STEP 2 优化方法

那么问题来了，怎么优化呢？

dalao们不要回答什么若干高级算法，对于一道橙题和想做这道橙题的包括我在内的蒟蒻来说，有些复杂了。

所以我们考虑能否在处理方面做一些小优化：

**我们可以设立一个数组，专门记录每一行的占用情况，好处有：**
1. 我们在最后处理每一格是否被占用的时候可以只处理单从行来看没有被占用的格子；

2. 再处理女生覆盖列的时候，只需要覆盖行没有被占用的各自即可

当然，说了这么多，不会实现也是没有用的，下面将为大家展示代码实现以及完整注释

## STEP 3 AC代码及完整注释QAQ


```
#include<bits/stdc++.h>//万能头小宝贝
using namespace std;
int n,m,b,g,ma[5001][5001],x,y,ans;
//分别储存行列数，覆盖行列数，整张地图，暂时用来储存的两个变量，以及答案
bool h[5001]; //储存每一行的占用情况
int main(){
	scanf("%d %d %d %d",&n,&m,&b,&g);//正常输入
	for (int i=1;i<=b;i++){
		scanf("%d %d",&x,&y);
		for (int j=x;j<=y;j++) h[j]=1;//每次输入男生覆盖的行的时候标记
	}
	for (int i=1;i<=g;i++){
		scanf("%d %d",&x,&y);
		for (int j=1;j<=n;j++)
			if (!h[j])
				for (int w=x;w<=y;w++)
					ma[j][w]=1;//女生的标记每一格
	}
	for (int i=1;i<=n;i++)//循环每一行
		if (!h[i])//优化：特判
			for (int j=1;j<=m;j++)
				if (!ma[i][j])
					ans++;//只要没被覆盖就++
	printf("%d\n",n*m-ans);//要求的是覆盖的数量，所以要拿总格子数减去覆盖的格子数
    return 0;//好习惯++
} 
```

**你，看懂了吗？**

## STEP 4 完结撒花！

恭喜你成功看完了本篇题解！[手动鼓掌]如果还有不懂的地方，欢迎在评论区评论哦，我会第一时间回复哒！

如果都看懂了，就点个赞纪念一下你的成长吧！

---

## 作者：C929_半枫 (赞：35)

最开始看到这道题，我第一反应是利用代数方法计算，但是会有人重复打扫一行或一列
#### 所以我们需要标记。
### 上代码
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int i,j,n,m,g,b,x,y,num=0,sum=0;
bool a[5001],o[5001];//a标记行,b标记列,初始化为0 
int main()
{
	
	cin>>n>>m>>b>>g;//n行,m列,男生b,女生g 
	for(i=1;i<=b;++i)//先输入男生 
	{
		cin>>x>>y;//从x行打扫到y行 
		for(j=x;j<=y;j++)
		{
			if(a[j]!=1)//如果这一行没有被打扫过 
			{
				a[j]=1;//标记为1 
				num+=m;//累加这一行格子数 
				sum++;//记录行数 
			}
		}
	}
	for(i=1;i<=g;++i)//再输入女生 
	{
		cin>>x>>y;//从x列打扫到y列 
		for(j=x;j<=y;++j)
		{
			if(o[j]!=1)//如果这一列没有被打扫过
			{
				o[j]=1;//标记为1 
				num+=n-sum;//累加
				//这里注意不需要累加一整列,
				//只需累加没有被男生打扫过的格子 
			}
		}
	}
	cout<<num;//输出 
}
```


---

## 作者：行者_Walker (赞：22)

#### 关于这道题，一看数据范围就知暴力模拟会TLE 甚至 MLE 

看了一下大佬们都在讲容斥原理，~~蒟蒻~~的我没听过这个理论，于是我按照了自己的想法来做
	
   我们先看一道小学题，引入我的思想
   ![](https://cdn.luogu.com.cn/upload/pic/59484.png)
	一片草坪上有一条宽度相等的路，草坪长x，宽y,小路宽度等于r，求小路的面积。（画得好丑）
    
我们可以把路平移到一起来算，如图
    ![](https://cdn.luogu.com.cn/upload/pic/59485.png)
这样计算就跟方便了
    
### 关于男生女生扫地，我可以把他们扫的区域分别平移到一起，然后算他们没扫到方块，最后用总面积来减去就是答案ans了；对于有重复的部分，就分别用两个数组来标记横和列就行了
code：
```cpp
# include <iostream>
# include <algorithm>
# include <cmath>
# include <cstdio>
using namespace std;
long long read();
int l[5010],p[5010];
int main()
{
	long long n,m,b,g;
	n=read();m=read();b=read();g=read();
//	cout<<n<<m<<b<<g;
	long long numl=n,nump=m;
	for(int i=1;i<=b;i++)//男生
	{
		int x=read(),y=read();
		for(int j=x;j<=y;j++)
		{
			if(l[j]==0)//这段区域有没扫过的
			{
				l[j]=1;
           numl--;
			}
		}
	}
	for(int i=1;i<=g;i++)//女生
	{
		int x=read(),y=read();
		for(int j=x;j<=y;j++)
		{
			if(p[j]==0)
			{
				p[j]=1;nump--;
			}
		}
	}
//	cout<<nump*numl<<endl;
	long long ans=n*m-nump*numl;
	printf("%lld",ans);
	return 0;
}
long long read()
{
	long long ans=0,flag=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			flag=-1;ch=getchar();break;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar(); 
	}
	return ans*flag;
}
```
还是要感谢一下@Alpha ，找到我快读上的失误.....(汗
    

---

## 作者：s_a_b_e_r (赞：16)

#容斥

就是一个简单的容斥，只要记录x,y有多少行和列被扫到就好

行被扫到\*列数+列被扫到\*行数-重合；

其实数据还可以再大的。。

PS：数据如果再大就要用线段树了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int N,M,B,G,ans1,ans2;
int x,y;
bool X[5003],Y[5003];
int main(){
    cin>>N>>M>>B>>G;
    for(int i=1;i<=B;i++){
     cin>>x>>y;
     for(int i=x;i<=y;i++)Y[i]=1;
    }
    for(int i=1;i<=G;i++){
     cin>>x>>y;
     for(int i=x;i<=y;i++)X[i]=1;
    }
    for(int i=1;i<=N;i++)
     if(Y[i])ans1++;
    for(int i=1;i<=M;i++)
     if(X[i])ans2++;
    cout<<ans1*M+ans2*N-ans1*ans2;
}
```

---

## 作者：zmxqs (赞：5)

### 没有STL玩家的代码？？？太可惜了吧

看见没有STL代码，我就知道我的机会来了

#### ~~（从今天开始，这里就叫STL广场）~~


这道题是利用平行和容斥原理，把重合的部分移到一起，然后再计算一共打扫的格子数。

这个结论之所以可以这么用是因为每个男生女生打扫的地面都是长方形，平移不会影响到面积

用两个集合分别存放行、列覆盖到的几个格子。最好是用set容器，可以一键去重（底层是红黑树实现，速度较快）每次把擦过的行列都一一存进容器

得到了每行每列的数量后，就可以统计答案了

$ans=n\times m-(n-a.size())\times (m-b.size())$

解释一下$n-a.size(),m-b.size()$是剩余的一个小长方形的的两个边的长度

然后再用整体的大正方形减去剩余的小正方形就得到了已经打扫过的内容？

还觉得不够简洁？我们可以继续简化柿子

化简后得到$a.size()\times m+b.size()\times n-a.size()\times b.size()$

Code：
```cpp
#include<bits/stdc++.h>
using namespace std；
set<int> a,b；
int main()
{
    int n,m,x,g；
    scanf("%d%d%d%d",&n,&m,&x,&g) ；
    for(int i=1;i<=x;++i) {
        int c,d；
        scanf("%d%d",&c,&d)；
        for(int j=c;j<=d;++j) {
            a.insert(j)；
        }
    }
    for(int i=1;i<=g;++i) {
        int c,d；
        scanf("%d%d",&c,&d)；
        for(int j=c;j<=d;++j) {
            b.insert(j)；
        }
    }
    printf("%d",a.size()*m+b.size()*n-a.size()*b.size())；
    return 0；
}
```

时间复杂度$O(n \log2 m)$

其中$n$为男生女生的总人数，$m$为擦拭的行列总数

先别急着提交，会TLE的

？？？为什么会TLE，这时间复杂度正确的啊

原因就在STL库的魔法代码常数因子都很大，多吸氧就可以了

```cpp
#pragma GCC optimize ("O2")
#pragma GCC optimize ("O3")
#pragma GCC optimize ("Ofast")
```
管理员过一下吧（毕竟现在没有 STL 题解，qwq）

Update：删除了部分wyy的话，重新组织了一下语言，并解释了时间复杂度

By SteveFang

---

## 作者：yzh_Error404 (赞：5)

$\colorbox{red}{}$
$\colorbox{orange}{}$
$\colorbox{yellow}{}$
$\colorbox{green}{}$
$\colorbox{cyan}{}$
$\colorbox{blue}{}$
$\colorbox{purple}{}$

### 看其他巨佬都是用容斥原理,蒟蒻瑟瑟发抖
蒟蒻用了小学的知识来做这道题

题目是这样的图:

![](https://cdn.luogu.com.cn/upload/image_hosting/en14t8bs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

但可以转换为这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/pk59z6zi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

于是只要算出左下角就可以了(橙色部分)

![](https://cdn.luogu.com.cn/upload/image_hosting/wute137x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

现在上代码!!

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,a,b;
	bool bj_a[5005],bj_b[5005];//因为区域可能重叠，用bj来标记扫没扫过
	memset(bj_a,false,sizeof(bj_a));
	memset(bj_b,false,sizeof(bj_b));//初始化
	scanf("%d%d%d%d",&n,&m,&a,&b);
	int a_sum=0,b_sum=0;//用sum来表示男生行数和女生列数
	for(int i=1;i<=a;i++)
	{
		int start,last;
		scanf("%d%d",&start,&last);
		for(int j=start;j<=last;j++)
		{
			if(bj_a[j]==false)//如果没扫过行数就加一
			{
				a_sum++;
				bj_a[j]=true;//标记扫过
			}
		}
	}
	for(int i=1;i<=b;i++)
	{
		int start,last;
		scanf("%d%d",&start,&last);
		for(int j=start;j<=last;j++)
		{
			if(bj_b[j]==false)
			{
				b_sum++;
				bj_b[j]=true;
			}
		}
	}//同上
	printf("%d",n*m-(n-a_sum)*(m-b_sum));//输出总格数减去空格数的差
	return 0;//愉快的结束
}
```
其实本题还是很水的

$\colorbox{red}{}$
$\colorbox{orange}{}$
$\colorbox{yellow}{}$
$\colorbox{green}{}$
$\colorbox{cyan}{}$
$\colorbox{blue}{}$
$\colorbox{purple}{}$


---

## 作者：blackbox233 (赞：4)

# 这题我来写一个非常规写法--BFS
首先看到题目第一反应就是一个涂色题目，在一个N*M的矩阵中算出一共有多少个格子被染色。为什么能用BFS来做？**因为只要是被染色的地方就一定是联通的**，我们只要从上下左右四个方向进行搜索就可以了

我们可以创建两个一维数组来分别表示男生打扫的区域和女生打扫的区域
```cpp
int boy[5005]={0};
int girl[5005]={0};
```
我们可以边输入数据边存值
```cpp
for(int i=1;i<=b;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		for(int j=x;j<=y;j++){
				boy[j]=1;
		}
	}
	for(int i=1;i<=g;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		for(int j=x;j<=y;j++){
			girl[j]=1;
		}	
	}
```
然后我们BFS开始之前先先找到第一个被染色的地方放入队列之中就可以开始BFS了。

下面是完整代码，有注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
int boy[5005]={0};
int girl[5005]={0};
bool vis[5005][5005];
int xx[] ={0,-1,0,1};//方向数组 
int yy[] ={1,0,-1,0};
int ans=0;

int main()
{
	int n,m,b,g;
	queue<int> q;
	queue<int> p;
	scanf("%d %d %d %d",&n,&m,&b,&g);
	for(int i=1;i<=b;i++){//将男生打扫的行存入 
		int x,y;
		scanf("%d %d",&x,&y);
		for(int j=x;j<=y;j++){
				boy[j]=1;
		}
	}
	for(int i=1;i<=g;i++){//将女生打扫的列存入 
		int x,y;
		scanf("%d %d",&x,&y);
		for(int j=x;j<=y;j++){
			girl[j]=1;
		}	
	}
	for(int i=1;i<=n;i++){//找到第一个被染色的点 
		for(int j=1;j<=m;j++){
			if(boy[i]&&girl[j]){
				q.push(i);
				p.push(i);
				goto end;	//goto 跳出多重循环 
			}
		}
	}
	end:
	while(!q.empty()){//开始搜素 
		for(int i=0;i<4;i++){
			int dx=q.front()+xx[i];
			int dy=p.front()+yy[i];
			if(dx>=1&&dx<=n&&dy>=1&&dy<=m&&!vis[dx][dy]&& (boy[dx]||girl[dy]) ){//判断边界 
				ans++;
				q.push(dx);
				p.push(dy);
				vis[dx][dy]=1;//标记走过的格子 
			}
		}
		q.pop();
		p.pop();	
	}
	printf("%d",ans);
	return 0;
}
```
### 本题的正解应该是模拟，这里只是给出一种不一样的思路。
开启O₂优化之后即可AC，本题也可以给萌新作为BFS来进行练习。

---

## 作者：在下互质数 (赞：2)

#### 先算男生和女生各扫好的面积，然后再去掉重复的面积，输出答案 
### 如下
```cpp
#include<iostream>
#include<string.h>
using namespace std;
int main()
{
    int n,m,b,g,e,f,k,h;
    int sum=0;
    cin>>n>>m>>b>>g;
    int a[n+1][m+1];
    memset(a,0,sizeof(a));       //将a数组的值初始化为零
    for(int i=1;i<=b;i++)
    {
        cin>>e>>f;
        for(int p=e;p<=f;p++)
            a[p][1]=1;      //让已打扫的行面积变成1
    }

    for(int i=1;i<=g;i++)
    {
        cin>>k>>h;
        for(int q=k;q<=h;q++)
            a[1][q]=1;      //让已打扫列面积变成1
    }
    /*for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)cout<<a[i][j]<<" ";cout<<endl;
    }*/
    for(int i=1;i<=n;i++)
    {
        if(a[i][1]==1)
        {
            sum+=m;
        }
    }
    for(int j=1;j<=m;j++)
    {
        if(a[1][j]==1)
        {
            sum+=n;
            for(int d=0;d<=n;d++)       //去掉重复的面积
            {
                if(a[d][1]==1)
                {
                    sum--;
                }
            }
        }
    }
    cout<<sum;
    return 0;
}

```


---

## 作者：T_F_P (赞：2)

~~这道题很水~~

主要思路是这样的：（用样例讲）

因为先扫男生，所以先把男生算进去（第1步）

然后扫女生，因为之前已经男生将某些行扫过了，所以默认女生**只扫了男生没有扫过的地面**（第2步）

设男生已经扫了x行，共有y行，那么默认每个女生只扫了她扫的那几列男生未扫部分，即每行只扫了y-x格（第3步）

先读入：

```cpp
scanf("%d%d%d%d",&n,&m,&b,&g);
```

算男生扫了几行

```cpp
int x,y;
for(int i=0;i<b;i++){
		scanf("%d%d",&x,&y);
		for(int j=x;j<=y;j++){
			boy[j]=1;
		}
	}
int h=0;
	for(int i=1;i<=n;i++){
		if(boy[i]==1){
			h++;
		}
	}
```

算女生扫了几列

```cpp
int x,y;
	for(int i=0;i<g;i++){
		scanf("%d%d",&x,&y);
		for(int j=x;j<=y;j++){
			girl[j]=1;
		}
	}
	int l=0;
	for(int i=1;i<=m;i++){
		if(girl[i]==1){
			l++;
		}
	}
```

我们推1下公式：（具体字母代表含义见题目以及以上代码）

男生：h*m;

女生：剩余（n-h）*列数（l）；

即扫过格数为：（h*m+(n-h)*l）；

以下附上本蒟蒻AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int boy[5050];
int girl[5050];
int main(){
	int n,m,b,g;
	scanf("%d%d%d%d",&n,&m,&b,&g);
	int x,y;
	for(int i=0;i<b;i++){
		scanf("%d%d",&x,&y);
		for(int j=x;j<=y;j++){
			boy[j]=1;
		}
	}
	for(int i=0;i<g;i++){
		scanf("%d%d",&x,&y);
		for(int j=x;j<=y;j++){
			girl[j]=1;
		}
	}
	int h=0;
	int l=0;
	for(int i=1;i<=n;i++){
		if(boy[i]==1){
			h++;
		}
	}
	for(int i=1;i<=m;i++){
		if(girl[i]==1){
			l++;
		}
	}
	printf("%d",h*m+(n-h)*l);
	return 0;
}
```

~~本蒟蒻的第一篇题解~~

---

## 作者：JackcreaM (赞：2)

### 一看到这样的题我的第一反应是打个2维数组表。。。。后来看了大佬们的题解觉得自己。。。【捂脸】

##### 我也不会大佬的方法


天真的我本来想用蒟蒻的方法做。。。而且在输出时还要一个个遍历过去统计一遍。。。。5000*5000的复杂度。。【捂脸】

呜呜呜伤心的我都不想贴代码了  ~~其实是因为我太懒~~


### AC算法

被以前的方法搞的AC率疯狂下掉的我终于想出了这个方法

```
#include<bits/stdc++.h>//万能头
using namespace std;
bool can1[100000],can2[100000];//哈哈完全忽视5000的限制
long long ans1,ans2;//代表扫过的行，列数；
int main()
{
	int n,m,b,g;
	int i,j,k;
	int x,y;//我最讨厌压行了~~
	cin>>n>>m>>b>>g;
	for(i=1;i<=b;i++)//BOY
	{
		cin>>x>>y;
		for(j=x;j<=y;j++)//把每行（列）一个个nen过去（下同）
		{
			if(can1[j]==0)
			can1[j]=1,ans1++;
            //在过程中就可以统计（可以少打好多代码）
		}
	}
	for(i=1;i<=g;i++)//girl(不知道我有没有拼错)
	{
		cin>>x>>y;
		for(j=x;j<=y;j++)
		{
			if(can2[j]==0)
			can2[j]=1,ans2++;
		}
	}
    //重点来了！！
    //行的格子+列的格子-重叠部分（初一党刚学）
	cout<<ans1*m+ans2*n-ans1*ans2;
	return 0;
    //OK
}
```

大神勿喷

##### 抄袭可耻！！

---

## 作者：Lhc_fl (赞：1)

### 居然没人用线段树？~~我来水一发~~

我们很容易发现，还没扫到的方格数=男生没有扫过的行数×女生没扫过的列数

用线段树存储行、列，扫一段区间就把一段区间推成1，最后统计没有扫过的就行了。

这样线段树甚至只需要开一个掌管lazytag的数组就可以了。

由于初始值为0，甚至不需要递归建树。
```cpp
#include<bits/stdc++.h>
#define _for(x,y,k) for(register int x = y; i <= k; i++)

using namespace std;

const int MAXN = 5001;

int n, m, b, g;

struct xds{ //为了方便使用，把线段树封装成结构体
    int n;
    int *lazy;
    
    inline int lc(int x) {
        return x << 1;
    }
    inline int rc(int x) {
        return (x << 1) | 1;
    }
    
    void clean(int x, int y, int l, int r, int i) {
        int mid = (l + r) >> 1;
        if (lazy[i]) return;
        if (x == l && y == r) {
            lazy[i]++;
        } else if (y <= mid) {
            clean(x, y, l, mid, lc(i));
        } else if (x > mid) {
            clean(x, y, mid + 1, r, rc(i));
        } else {
            clean(x, mid, l, mid, lc(i));
            clean(mid + 1, y, mid + 1, r, rc(i));
        }
    }
    int getsum(int x, int y, int l, int r, int i) {
        int mid = (l + r) >> 1;
        if (lazy[i]) return 0;
        if (l == r) return 1;
 		return getsum(x, mid, l, mid, lc(i)) + getsum(mid + 1, y, mid + 1, r, rc(i));
    }
    xds(int n) {
        int num = n << 2;
        this->lazy = new int [num];
        _for(i, 1, num) {
            lazy[i] = 0;
        }
    }
};
int main() {
    scanf("%d%d%d%d", &n, &m, &b, &g);
    xds a(n);
    xds q(m);
    int tmpa,tmpb;
    _for(i, 1, b) {
        scanf("%d%d", &tmpa, &tmpb);
        a.clean(tmpa, tmpb, 1,n,1);
    }
    _for(i, 1, g) {
        scanf("%d%d", &tmpa, &tmpb);
        q.clean(tmpa, tmpb, 1,m,1);
    }
    
    cout << n * m - a.getsum(1,n,1,n,1) * q.getsum(1,m,1,m,1);
    return 0;
}
```


---

## 作者：FCBM71 (赞：1)

稍微翻了一下楼下大佬们的题解，发现还没有人这样做。虽然比楼下大佬们的要复杂一些，但我还是决定发一下。

显然，开一个二维数组模拟地图是会TLE的，于是我决定开两个一位数组，分别存放这一行或者这一列是否被扫到过。之后，再把整个场地的每个格子都遍历一遍，如果这个格子所在的行或者列被扫过，则答案+1

复杂度 $O(nm)$ ，显然可以过。

----------------------

没有看懂的可以看我的代码以及注释
```pascal
program hrn;
 var
  x,y:array[1..5000]of 0..1; //标记每一行，每一列是否被扫到了
  n,m,b,g,i,j,c,p,q:longint;
 begin
  read(n,m,b,g);
  for i:=1 to b do begin
   read(p,q);
   for j:=p to q do x[j]:=1;
  end;    //将所有被男生扫过的行标记
  for i:=1 to g do begin
   read(p,q);
   for j:=p to q do y[j]:=1;
  end;    //将所有比女生扫过的列标记
  for i:=1 to n do
   for j:=1 to m do
    if(x[i]=1)or(y[j]=1)then inc(c); //遍历每一个格点，计数
  write(c);
 end.

```

---

## 作者：不知不行 (赞：1)

看了这道题，我脑袋里蹦出来一个字：

## 排序扫描！

哦，这是四个字。

其实排序不一定要用在贪心中，他是可以很多变的。本题就可以将男女生的范围分别双升序，求出男生和女生分别打扫了多少行和多少列，再用本程序倒数第四行的公式算出结果。

代码，走起！



```
#include<bits/stdc++.h>
using namespace std;
struct sw{
	int x,y;
}b[5005],g[5005]; //我比较喜欢用结构体
bool cmp(sw m,sw n){ //双升序的cmp
	if(m.x!=n.x) 
	return m.x<n.x;
	return m.y<n.y;
}
int main(){ //主函数
	int bm,gm,km,kn;
	scanf("%d %d %d %d",&km,&kn,&bm,&gm);
    for(int i=1;i<=bm;i++)
	scanf("%d %d",&b[i].x,&b[i].y);
	for(int i=1;i<=gm;i++)
	scanf("%d %d",&g[i].x,&g[i].y); //读入
	sort(b+1,b+1+bm,cmp);
	sort(g+1,g+1+gm,cmp); //两个数组排序
	int right=b[1].y,sum1=b[1].y-b[1].x+1; 
 //right是一个右端最大值，会不断更新，sum1是记录总数
	for(int i=2;i<=bm;i++){ //扫描
		if(right>=b[i].y) continue;
		if(right<b[i].x){
			right=b[i].y;
			sum1+=b[i].y-b[i].x+1;
		}
		else{
			sum1+=b[i].y-right;
			right=b[i].y;
		}
	}
	right=g[1].y; int sum2=g[1].y-g[1].x+1;
	for(int i=2;i<=gm;i++){
		if(right>=g[i].y) continue;
		if(right<g[i].x){
			right=g[i].y;
			sum2+=g[i].y-g[i].x+1;
		}
		else{
			sum2+=g[i].y-right;
			right=g[i].y;
		}
	} //同上
	int ans=sum1*kn+sum2*(km-sum1);//计算答案
	cout<<ans;//输出
	return 0;
}

```


---

## 作者：gzw2005 (赞：1)

# 看到没有人用差分数组，赶紧水一发


差分数组的定义是：


对于一个数组A，其差分数组$B[i]=A[i]-A[i-1] (i>0),B[0]=A[0]$


令$C[i]=B[0]+B[1]+B[2]+…+B[i]$,即前缀和


则$C[i]=A[0]+A[1]-A[0]+A[2]-A[1]+A[3]-A[2]+…+A[i]-A[i-1]=A[i]$


即$A[i]$的差分数组是$B[i]$， 而$B[i]$的前缀和是$A[i]$


那对于这道题目而言，在boy[i]到boy[j]赋值为**true**，相当于在boy[i]加1，boy[j+1]减1，时间复杂度从$O(j-i+1)$变成了$O(1)$。


下面是代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b,g,boy[5002],girl[5002],row,column;
int main(){
    cin>>n>>m>>b>>g;
    while(b--){//循环b次
        int top,bottom;cin>>top>>bottom;//输入最上面和最下面的那一行
        boy[top]++;boy[bottom+1]--;//注意要在bottom+1的位置-1而不是bottom
    }
    while(g--){//下面的同理
        int left,right;cin>>left>>right;
        girl[left]++;girl[right+1]--;
    }
    for(int i=1;i<=n;i++){
        boy[i]+=boy[i-1];//前缀和
        if(boy[i])row++;//如果被扫过就要+1
    }
    for(int i=1;i<=m;i++){
        girl[i]+=girl[i-1];//也是前缀和
        if(girl[i])column++;
    }
    cout<<row*m+column*n-row*column;//男生扫的部分+女生扫的部分-重叠的部分
    return 0;
}
```
时间复杂度$O(N+M)$,其实可以出到$10^6$的（手动滑稽）


---

## 作者：66666a (赞：1)

这题用布尔数组枚举会超时，所以有更快的方法

将男生扫的行标记，将女生扫的列标记

每个点若所在行和列均未被标记则未扫到，否则扫到

代码：

```cpp
var
a,b:array[0..5000] of boolean;
n,m,l,g,i,j,s,x,y:longint;
begin
readln(n,m,l,g);
fillchar(a,sizeof(a),#1);
fillchar(b,sizeof(b),#1);
for i:=1 to l do
begin
readln(x,y);
for j:=x to y do a[j]:=false;
end;
for i:=1 to g do
begin
readln(x,y);
for j:=x to y do b[j]:=false;
end;
for i:=1 to n do
for j:=1 to m do
if not((a[i])and(b[j])) then inc(s);
writeln(s);
end.

```

---

## 作者：Cult_style (赞：1)

# 算法：差分，模拟
# 时间复杂度 $O(n)$
### 加了一点优化：差分，这道题还算良心，可以以$O(n^2)$来通过，不过用差分，就算n是1e6也没问题

首先，我们先把所有的男生、女生要扫的地方全部标记一下，此处可以用到**差分**，不会用查分的然后，重点来了。

假设，我们先让男生扫完地,扫了三行，共$15$格：

![](https://cdn.luogu.com.cn/upload/image_hosting/wdd2w325.png)

然后，假如女生要在第$3$列扫地，那么，呈现了这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ph8564a.png)

那么，现在变成了$3×5+4×1- ? = 16$

我们可以发现，等男生扫完之后，女生每扫一列，就会浪费（重复）$B$行，得出代码

```
#include<iostream>
#include<fstream>
#include<algorithm>
#define ll long long
using namespace std;
ll n,m,b,g;
ll p[5005][3],sum[3];
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&b,&g);
	while(b--){
		ll x,y;
		scanf("%lld%lld",&x,&y);
		p[x][1]++;
		p[y+1][1]--;
	}
	while(g--){
		ll x,y;
		scanf("%lld%lld",&x,&y);
		p[x][2]++;
		p[y+1][2]--;
	}
	ll x=0;
	for(int i=1;i<=n;i++){
		x+=p[i][1];
		sum[1]+=(x>0)?1:0;
	}
	x=0;
	for(int i=1;i<=m;i++){
		x+=p[i][2];
		sum[2]+=(x>0)?1:0;
	}
	ll ans=sum[1]*m+sum[2]*n;
	ans-=sum[1]*sum[2];
	printf("%lld",ans);
	
	return 0;
}
```


---

## 作者：一棵小白菜み (赞：1)

首先，可以看到
```latex
数据范围：

8 个的数据：N,M,B,G 的范围都是[1…100]

2 个的数据：N,M,B,G 的范围都是[1…5,000]
```
5000是不能用二维数组的，所以可以用一位数组；

贴上方法
1. 将男生的算起来；
1. 将女生的算起来；
1. 将重复部分减掉即可。


贴上代码
```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<algorithm>
using namespace std;
long long l,h,n,m,b,g,a[10001],e[10001],c[10001],d[10001],x,y,t,s;
int main()
{
	 cin>>n>>m>>b>>g;
	 for(int i=1;i<=b;i++)
	 {
	 	cin>>x>>y;
	 	for(int j=x;j<=y;j++)
	 	a[j]=1;
	  } 
	  for(int i=1;i<=g;i++)
	  {
	  	cin>>x>>y;
	  	for(int j=x;j<=y;j++)
	 	e[j]=1;             
	  }
	  for(int i=1;i<=n;i++)
	  	if(a[i]==1) s+=m,t++;
	 for(int i=1;i<=m;i++)
	  	if(e[i]==1) s+=n-t;
	  cout<<s;
    return 0;
}
```


---

## 作者：Wh_Xcjm (赞：1)

### ~~这么水的题我居然WA了一次~~

# 看题解有用容斥的，确实不难。（说实话我一开始并没有想到容斥。。）总之我写了个二维前缀和：
```cpp
#include<stdio.h>
using namespace std;
const int maxn=5e3+5;
int a[maxn][maxn],n,m;
void pt(int x1,int y1,int x2,int y2){
    a[x1][y1]++;a[x1][y2+1]--;a[x2+1][y1]--;a[x2+1][y2+1]++;
}
int main(){
    int ans=0,b,g;scanf("%d%d%d%d",&n,&m,&b,&g);
    for(int i=0;i<b+g;i++){
        int x,y;scanf("%d%d",&x,&y);
        if(i<b)pt(1,x,m,y);
        else   pt(x,1,y,n);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            a[j][i]+=a[j][i-1]+a[j-1][i]-a[j-1][i-1];
            if(a[j][i])ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```
Tips：要十分小心x,y,n行m列之间的关系。。。

优点：可以推广到给定四个点的坐标进行运算。

---

## 作者：用户已注销 (赞：1)

没人写题解啊，，，就讲一下我个人感觉一般般的做法吧

（毕竟水平有限，而且也想不到更好的）

这道题的标签是模拟，所以我们很自然的想到：

对于每个信息，把ta会扫到的点写上1，这样可以很简单的避免重复

随后我们看一下数据范围，1-5000，人品不是太差都会过的

稍微优化一下，二维压成一维：

和上述方法类似，根据每个信息，将会被扫到的行（列）写上1，

最后统计行和列分别有几个1

设总共（排除覆盖之后）扫到a行b列，

那么扫到面积的公式就是 am+bn-ab

画个图就很明显了

这样时间复杂度可以妥妥的降低，AC更稳


---

## 作者：Waaifu_D (赞：0)


~~好水的模拟~~

由题意我们可以知道

所没打扫的面积等于总面积减去男生打扫的面积和女生打扫的面积，公式就可以得出来

```
n*m-（n-总行数）*（m-总列数）
```


然后化简（初一知识不解释）

```
总行数*（m-总列数）+n*总列数
```

 
代码如下

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,m,b,g;//与题目中n,m,b,g意义相同 
int h[5001],l[5001],hsum,lsum;//h数组记录行是否被覆盖，l数组记录列是否被覆盖 
int main()//hsum记录一共有几行，lsum记录一共有几列 
{
	cin>>n>>m>>b>>g;
	for(int i=1; i<=b;i++)
	{
		int x,y;//开始与结束点 
		cin>>x>>y;
		for(int j=x;j<=y;j++)
		{
			if(!h[j])//相当于h[j]==0 
			{
				hsum++; 
				h[j]=1;//标记已经覆盖过了 
			}
		}
	}
	for(int i=1; i<=g;i++)
	{
		int x,y;
		cin>>x>>y;
		for(int j=x;j<=y;j++)
		{
			if(!l[j])//同上 
			{
				lsum++;
				l[j]=1;
			}
		}
	}
	cout<<hsum*(m-lsum)+n*lsum; //公式
	return 0;
}
```
~~为什么要化简？因为数学老师教我凡是能化简的都得化简（雾）~~


---

## 作者：黄昏烟雨乱WA声 (赞：0)

## ~~什么是容斥？~~
###  这有一种非常~~清奇~~的思路
就是说，每一个男生打扫完的行就相当于被掘掉了（？），没有了，于是每个女生打扫的是男生打扫完后还没有被掘掉的部分。

所以计算男生共打扫了多少行，再把行数减去这些，最后就可以计算女生最后实际打扫了多少行。

图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pbfw0k16.png)

code：

```cpp
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int main(int argc, char** argv) {
	int a[5003]={0},b[5003]={0};
	
	int n1,n2,y1,y2;
	int y,z;
	int q,w;
	int s1,s2;
	cin>>y>>z>>q>>w;
	for(int i=0;i<q;i++){
		cin>>n1>>n2;
	for(int j=n1;j<=n2;j++){
		a[j]=1;//找到男扫过的行
	}
	}
	int co1=0,co2=0;
	for(int i=0;i<5002;i++){
		if(a[i]==1){
			co1++;//记数
		}
	}
	s1=co1*z;
	y=y-co1;//掘掉男生扫过的行
	for(int i=0;i<w;i++){
		cin>>y1>>y2;
	for(int j=y1;j<=y2;j++){
		b[j]=1;
	}
	}
	for(int i=0;i<5002;i++){
		if(b[i]==1){
			co2++;
		}
	}
	s2=co2*y;//计算女生实际扫的面积
	int as=s1+s2;//将男生的面积与女生的面积相加
	cout<<as;
	return 0;
}
```


---

## 作者：eternityer (赞：0)

看着大家都是直接算被扫过的格子，我就来种特殊的思维，直接计算没有被扫过的格子就好了呀，还不用去重，直接总数减去没被扫过的就是答案，好的说来就来，下面是AC代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=5000+5;
int han[maxn],lie[maxn]; //行列数组
int main()
{
	int n,m,b,g,bb,bbb,gg,ggg;
	cin>>n>>m>>b>>g;
	for(int i=0;i<b;i++){
		cin>>bb>>bbb;//读入
		for(int j=bb;j<=bbb;j++) 
			han[j]++;
	}
	for(int i=0;i<g;i++){
		cin>>gg>>ggg;//读入
		for(int j=gg;j<=ggg;j++)
			lie[j]++;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(!han[i]){ //若该行未被扫过
			for(int j=1;j<=m;j++){
				if(!lie[j]) ans++;//并且该列未被扫过，数目加一；
			}
		}
	}
	cout<<m*n-ans;  //总数减未被扫过的
	return 0;
}
```
有时候逆向思维真的很管用，正难则反。

---


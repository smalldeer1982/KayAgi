# 接金币

## 题目描述

在二维坐标系里，有 $n$ 个金币，编号 $0\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\texttt{Abletocatch}$，否则输出 $\texttt{Notabletocatch}$。


## 说明/提示

对于所有数据，$1\le g\le5$，$1\le n\le50$，$-10^3\le x_i\le10^3$，$0\le y_i\le10^3$。


## 样例 #1

### 输入

```
5
3
-1 1
1 3
0 4
1
-3 2
3
-1 1
1 2
0 4
3
0 9
-1 1
1 3
8
70 141
-108 299
52 402
-70 280
84 28
-29 363
66 427
-33 232
```

### 输出

```
Abletocatch
Notabletocatch
Notabletocatch
Abletocatch
Notabletocatch
```

# 题解

## 作者：Ciyang (赞：39)

## 本弱已AC,这是一道模拟题,可以按照题意做,但这道题也有几个技巧问题
**思路比较简单:**   
**定义结构体,其中定义了是否到达底部的函数,和向下走(y-1)的函数,输入数据后对这n个结构体,由y的大小从小到大排序**   
**模拟环节可以设置一个循环每一秒进行,在循环外定义一个布尔值变量successful是用来记录是否成功的,定义一个变量来记录当前要接的金币的代号,我设置默认为假**   
**循环中(重点):要先监测所有金币当前是否已经由掉到y=0的情况,然后自己的x坐标与此金币的x坐标比较是否相等,不相等则跳出循环,相等就继续监测直到最后一个,这里可以提前跳出循环(~~剪枝?~~)也可以不用,不会超时**  
**接着就是此秒内自己和金币的移动,自己的移动就像游戏一样,如果当前要接的金币在左自己就左移,金币在右自己就右移.金币移动也有个小技巧:如果不是0则下落,当然如果你与我一样把监测金币放循环最前面应该不需要这样了.**  
**还有一个可能会出现的疑问是为什么不把金币下落和监测金币函数放在一起,解释一下:因为两个函数一个在循环开始,一个在循环结束所以分开写,放在一块就是都放在最前面好像也可以.**    
**提一下我的代码中数组编号是从0开始的**   
   
### 表达可能不太清楚,如果不理解可以看代码


------------

### 代码:

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm> 
using namespace std;
struct coin{
	//金币的结构体
	int nx;
	int ny;
	void down(){
    //金币下落实现,如果y不为0则下落
		if(ny!=0)ny-=1;
	}
	bool havedown(){
    //监测金币是否坐标已经为0
		if(ny==0)return true;
		else return false;
	}
};
bool coinscmp(coin a,coin b){
	//金币的y坐标比较,重载排序函数
	return a.ny<b.ny;
}
int main(){
	int t;cin>>t;
	for(int groupn=0;groupn<t;groupn++){
		int n;cin>>n;
		coin coins[n];
		for(int i=0;i<n;i++){
        //从0到n-1进行赋值
			cin>>coins[i].nx>>coins[i].ny;
		}
		sort(coins,coins+n,coinscmp);
        //对金币进行sort排序
		int mx=0,my=0,i=0;
        //i记录当前要接住哪个金币
		bool successful=false;
        //记录是否成功
		while(1){
			if(i==n){
            //如果现在要接的金币已经是第n个(不存在的那个)则成功
				successful=true;
				break;
			}
			bool thissuccessful=true;
            //记录本秒所有要接住的金币是否成功接住
			for(int j=i;j<n;j++){
            //从i开始到最后一个
				if(coins[j].havedown()==true){
                //是不是第j个金币的y已经为0
					if(mx==coins[j].nx){
						i+=1;
					}
					else{
                    //如果接住不
						thissuccessful=false;
						break;
					} 
				}
                //这里可以优化,遇到false跳出
			}
			if(thissuccessful==false)break;
			if(mx<coins[i].nx)mx+=1;
			if(mx>coins[i].nx)mx-=1;
			for(int j=i;j<n;j++)coins[j].down();
            //自己和金币的移动
		}
		if(successful==true)printf("Abletocatch\n");
		else printf("Notabletocatch\n");
        //输出结果
	}
    return 0;
}
```

---

## 作者：noble_ (赞：24)

这题主要思想是个排序，以y为标准从大到小排序，那么只要前后两个x之差的绝对值大于y之差的绝对值（FJ速度为1）这样就Notabletocatch。否则Abletocatch。

代码：


```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
struct coins
{
    int x,y;
}a[100000];
bool cmp(coins a,coins b)
{
    if(a.y<=b.y) return true;
    return false;
}
int main()
{
    int g,n;
    scanf("%d",&g);
    while(g--)
    {
        bool flag=false;
        scanf("%d",&n);
        a[0].x=a[0].y=0;n++;
        for(int i=1;i<n;i++)
        {
            scanf("%d%d",&a[i].x,&a[i].y);
        }
        sort(a,a+n,cmp);
        for(int i=0;i<n-1;i++)
        {
            if(abs(a[i].x-a[i+1].x)>abs(a[i+1].y-a[i].y))
            {
                printf("Notabletocatch\n");
                flag=true;
                break;
            }
        }
        if(!flag) printf("Abletocatch\n");
    }
    return 0;
}
```

---

## 作者：Creroity (赞：11)

~~好久没打题解了……~~

这题虽说是个模拟，但实际上一个排序就能解决了。

首先，一个循环输入多组数据应该没有问题（吧？）。

其次，我们可以发现 FJ 只能在 $y=0$ 这一条直线上运动，所以，我们只要判断金币下落到 $y=0$ 上时 FJ 是否能到达这个位置即可。

而金币下落的速度都是一样的，所以我们按照所有金币的 $y$ 坐标排序一遍，然后我们假设 FJ 每次都是向上移动一格并且向左或向右或者不向左右移动的。

那么可以先判断第一枚金币离坐标系原点的距离（即 FJ 初始位置）是否大于金币高度，若大于，则 FJ 一定无法在移动到金币高度时达到金币的位置，即无法接住第一枚金币，就可以直接跳出循环。

后面的几枚也是一样，因为 FJ 接住了前面的金币，那么此时 FJ 就在上一枚金币的位置，那么就判断次枚金币和上一枚金币的高度差以及横向坐标差即可。

接下来还是上一下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int g,n;
struct node{
	int x,y;
}a[55];
bool cmp(node x,node y){
	return x.y<y.y;
}
int main(){
	cin>>g;
	while(g--){
		bool flag=0;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
		sort(a+1,a+n+1,cmp);//排序 
		if(abs(a[1].x)>a[1].y){//第一枚金币 
			printf("Notabletocatch\n");
			continue;//跳出循环 
		}
		for(int i=2;i<=n;i++){
			if(abs(a[i].x-a[i-1].x)>a[i].y-a[i-1].y){
				printf("Notabletocatch\n");
				flag=1;//标记 
				break;//跳出循环 
			}
		}
		if(!flag)printf("Abletocatch\n");//输出 
	}
	return 0;
}
```
~~卑微求赞~~

---

## 作者：tribool4_in (赞：10)

此题貌似有不少巨佬是根据时间来模拟的，但其实有别的方法。

仔细想，**每相邻两个金币 $i-1$ 和 $i$（假设已经捡到 $i-1$ ），想要捡到 $i$，必须要保证 他们的 $x$ 之差 $\le$ 他们的 $y$ 之差才可以。** 

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/l1u9d8g0.png)

只有当 FJ 的移动所需时间 $\le$ 第 $i$ 个硬币下落所需时间 才可以捡到 第 $i$ 个硬币。

最后还有一点要注意：FJ 一开始在 $(0,0)$ 位置，那么可以假设他刚捡到了一个落到此位置的金币，也就是多设第 $0$ 个金币在 $(0,0)$ 位置即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
struct node {
	int x, y;
} a[N];
bool cmp(node l, node r) {
	return l.y <= r.y;
}
int k, n;
int main() {
	scanf("%d", &k);
	while (k--) {
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) {
			scanf("%d%d", &a[i].x, &a[i].y);
		}
		a[0].x = a[0].y = 0;
		sort(a + 1, a + n + 1, cmp);
		bool ok = 1;
		for (int i = 0; i <= n; i++) {
			int x = abs(a[i].x - a[i - 1].x), y = abs(a[i].y - a[i - 1].y);
			if (x > y) {
				ok = 0;
				printf("Notabletocatch\n");
				break;
			}
		}
		if (ok) {
			printf("Abletocatch\n");
		}
	}
	return 0;
}

```


---

## 作者：hyzaoia (赞：8)

楼下的STL算法其实也很好

但是我直接模拟做了这道题。

我是先按y坐标对每个金币排序以后枚举

用一个变量nowt存储当前的时间是第几个时间单位的结束，用dx存储当前FJ的x坐标（因为y坐标不会变所以不用存）

每次判断，当第i个金币的y坐标-nowt<dx和第i个金币的x坐标差时，我们可以判断此时不可能接到这个金币（因为金币和FJ的速度相等，所以只要判断距离就可以了）

时间复杂度为O（G\*(2n+n log n)）=O（G\*n）（大概吧？

因为n和G都很小所以我是全程0ms过的……

上代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn=55;

struct Node{   //存储一个金币位置的结构体
    int x,y;
};

bool cmp(Node a,Node b){   //用于sort的比较函数
    return a.y<b.y;
}

int main(){
    int G;
    scanf("%d",&G);
    while(G--){    //多组数据的常用写法
        int n;
        scanf("%d",&n);
        Node gb[maxn];    //这样不用每次初始化，所以多组数据
        for(int i=1;i<=n;i++){
            scanf("%d%d",&gb[i].x,&gb[i].y);     //输入不解释
        }
        sort(gb+1,gb+n+1,cmp);   //使用定义好的规则进行快速排序（按y坐标从小到大）
        int dx=0;  //当前FJ的x坐标
        int nowt=0;  //当前的时间
        bool flag=true;  //标记是否能够全部接到
        for(int i=1;i<=n;i++){
            if(gb[i].y-nowt<abs(dx-gb[i].x)){   //这其实是最核心的判断过程了，判断第i个金币是否接不到
                printf("Notabletocatch\n");  //如果接不到，直接标记打成false，退出循环
                flag=false;
                break;
            }
            else{
                nowt=gb[i].y;    //本来是nowt+=gb[i].y-nowt，相当于nowt=gb[i].y;
                dx=gb[i].x;        //现在FJ移动到了第i个金币的x坐标的位置
            }
        }
        if(flag)printf("Abletocatch\n");  //如果没有接不到的金币就输出Abletocatch。
    }
    return 0;
}
```

---

## 作者：Shuo_Orange (赞：3)

### 这可能是这个题最暴力的题解了
主要思路：  
将金币的位置在 _**矩阵**_ 上表示出来，让接金币的一行一行的搜从最底下开始搜，每搜一行就能多走一步（没有金币的话这个步数累加），如果那一行有金币，就看现在的可移动步数能不能够到，如果能够到，就将步数置零
当然不要忘记回溯。

在用矩阵时，会有一个问题，坐标有负数，这怎么整呢？给他干上一个**1001**，这样就解决存储的问题了。
  
~~事实上如果两个金币在同一行就会立刻炸掉，但没判断也过了~~

  上代码

```
#include<bits/stdc++.h>
using namespace std;
int a,b,c,n,N,k,xx,yy,tp;
int jz[2010][2010],x[110],y[110];//注意这个空间 
int main(){
	scanf("%d",&N);//游戏个数 
	for(int i=1;i<=N;i++){
	tp=0;xx=1001;k=0;
	memset(jz,0,sizeof(jz));//回溯
	
		scanf("%d",&n);
		for(int j=1;j<=n;j++){
		scanf("%d%d",&x[i],&y[i]);
		jz[x[i]+1001][y[i]]=1;}//存储，+1001去掉负数 
		
				
		for(int l=0;l<=1001;l++){//每一行 从第0行开始搜是为了让k提前附好值 
		if(tp)break;//出了结果就停，循环太多只能这样停了emmm 
		for(int d=0;d<=2001;d++){//搜索当前行 
		if(tp)break;//出了结果就停 
	
		if(jz[d][l]==1)//发现金币 
			if(k-abs(d-xx)<0)//判断能不能接到 
				{printf("Notabletocatch\n");tp=1;}
					   else {k=0;xx=d;}//接到金币就不能动了，k置零 
		}
		k++;//要在搜完当前行之后加1 
		}
		if(!tp)printf("Abletocatch\n");
	}
return 0;
}
```


---

## 作者：追梦的黑旋风 (赞：2)

# P2694 题解

### 这题还是~~很水的~~比较不错的模拟，很适合初学者打。

   题目上的硬币会以相同的速度下落，所以我们首先想到的应该就是把硬币所在的位置按照纵坐标大小**从小到大**排序。
   
   然后我们就会发现这时硬币会按照数组下标一次下落，这也就意味着，当我接到上一枚硬币时，如果我们此时的横坐标与下一枚硬币的横坐标的距离小于当前硬币与下一枚硬币的纵坐标的距离时，我们的飞机就无法接到下一枚硬币。
   
   另外，飞机第一次的坐标也应该当作一枚硬币存入，因为如果第一次就接不到就不行了。
   
   以此为基础，我们就可以轻松地写出这道题的模拟啦！qwq
   
   不多废话，代码如下：
   
   ```cpp
#include<bits/stdc++.h>
using namespace std;
struct coin{
	int x;
	int y;
};//结构体来存硬币的初始位置，x表示横坐标，y表示纵坐标 
bool cmp(coin a,coin b){
	return a.y<b.y;
}//从小到大排序 
int g,n;
int booler;//booler来判断是否有接不到的；booler=0表示能接到每一枚，booler=1表示有接不到的 
int main()
{
	scanf("%d",&g);
	for(int i=1;i<=g;i++){
		booler=0;//每次操作前初始化booler 
		coin a[55];
		scanf("%d",&n);
		n++;
		for(int j=1;j<n;j++){
			scanf("%d%d",&a[j].x,&a[j].y);
		}
		a[n].x=0;
		a[n].y=0;//存入飞机初始坐标 
		sort(a+1,a+n+1,cmp);//从小到大排序y 
		for(int j=1;j<n;j++){
			if(abs(a[j].y-a[j+1].y)<abs(a[j].x-a[j+1].x)){
				printf("Notabletocatch\n");//当前硬币的横坐标与下一次横坐标的距离小于纵坐标距离。 
				booler=1;//把booler换为1 
				break;//跳出循环 
			}
		}
		if(booler==0) printf("Abletocatch\n");//最后判断前面有没有接不到的 
	}
	return 0;
} 
```
感觉这个是目前最清楚的，紫名大佬手下留情


---

## 作者：Take_A_Single_6 (赞：2)

## 解题思路：

此题正解**贪心**，其实很好理解：```FJ```在捡金币的时候肯定是捡离自己近的，也就是哪个金币低，```FJ```就去接哪个，这样就可以尽量接到更多的金币。



------

## 代码实现：

对于任意一个金币，它有x坐标和y坐标两个信息，无疑这需要一个结构体来储存：

```cpp
struct coin
{
int x,y;
}c[55];//存储每个金币位置的结构体
```

根据我们的贪心思想，应该确定好我们的贪心策略：

![](https://cdn.luogu.com.cn/upload/image_hosting/i6h102tw.png)


接下来，只需要一个```flag```来标记能否全部接到就可以了！  
code：（代码含注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct coin
{
int x,y;
}c[55];//存储每个金币位置的结构体
bool cmp(coin a,coin b)//排序模板
{
return a.y<b.y;
}
int main()
{
int T,n,xx,t;//xx上一个金币的横坐标，t时间
bool f;//标记
for(cin>>T;T;T--)//多组数据模板
{
    f=true,xx=0,t=0;//初始化，标记可接到
    cin>>n;
    for(int i=0;i<n;i++)
    cin>>c[i].x>>c[i].y;
    sort(c,c+n,cmp);
    for(int i=0;i<n;i++)
    {
        if(c[i].y-t<abs(c[i].x-xx))//横向距离与纵向距离比较
        {
            cout<<"Notabletocatch\n",f=false;//标记接不到
            break;
        }
        xx=c[i].x,t=c[i].y;//随着接金币的位置/时间迭代
    }
    if(f)//如果都接到
    cout<<"Abletocatch\n";
}

return 0;   //好耶！
}
```


## 坚决不复制题解，创建核邪洛谷，从一点一滴做起！

---

## 作者：zilingheimei (赞：2)

蒟蒻来写题解了

先看题目
[P2694 接金币](https://www.luogu.com.cn/problem/P2694)


------------

思路如下：

1. 先将这些下落的硬币的高度排个序

```cpp
bool cmp(coin a,coin b){
	return a.y<b.y;
}

sort(a+1,a+n+1,cmp);
```


2. 判断从上一个接到的硬币到这一个时间来不来得及，注意因为上一次的 x 位置可能比现在的 x 位置大，所以要用绝对值来判断距离。但是 y 不用，因为前面排过序所以 y 只小不大

```cpp
if(abs(a[j].x-a[j-1].x)>a[j].y-a[j-1].y){
	flag=1;		
}
```

3. 用一个变量来判断硬币能不能全部接到，注意在每一组新数据前要归零（自己因为忘了归零调了半天

```cpp

if(flag==1){
	cout<<"Notabletocatch"<<endl;
}
else {
	cout<<"Abletocatch"<<endl;
}
```


------------

主要代码前面有了，这里就不放了

---

## 作者：七夜 (赞：2)

#### ~~前段时间回去准备中考也没怎么写，今天来写一篇吧~~

这道题和我离开之前写的差不多，也是用到了结构体排序。

首先要明白，所有的金币必须都要接到，不能漏下，这也就决定了必须先接距离地面最近的金币，但是排序的同时每个金币的横坐标还不能变，此时，结构体就起到了很好地作用，可能有的同学对结构体排序不清楚，其实很简单，代码如下：

```
int cmp(node a,node b)
{
	return a.y<b.y;
}
```
这样子就会按照纵坐标，也就是距离地面距离从小到大排序。

如果考虑每过一秒把所有金币的y值减一，是不是有点呆，我们可以直接把自己的纵坐标加一，这样一转换不就很轻松了嘛

考虑某一个金币能不能接到，只需要考虑这枚金币的高度与自己的高度的差，然后计算这枚金币的横坐标与自己横坐标的差就行了，如果纵坐标之差小于了横坐标之差，就代表接不到，否则，自己一定会移动到此时金币的位置，这样想来，这个题就简单了

最后奉上~~丑陋的代码~~
```
#include<bits/stdc++.h>
#define ll long long
#define INF 300
#define MAXN 100005
using namespace std;
inline int read() {
	char c=getchar();int f=1,x=0;
	while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}
	while(c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
	return x*f;
}
int T,n,nx,ny;
bool f;
struct node
{
	int x;
	int y;
} love[INF];
int cmp(node a,node b)
{
	return a.y<b.y;
}
int main()
{
	T=read();
	for(int t=1;t<=T;++t)
	 {
	 	n=read();
	 	nx=0;
		ny=0;
	 	f=true;
	 	for(int i=1;i<=n;++i)
	 	 {
	 	 	love[i].x=read();
	 	 	love[i].y=read();
		 }
		sort(love+1,love+1+n,cmp);
		for(int i=1;i<=n;++i)
		 {
		 	if((love[i].y-ny)>=abs(love[i].x-nx))
		 	 {
		 	 	ny=love[i].y;
			 	nx=love[i].x;
			 }
			else
			 {
			 	f=false;
				break;
			 }
		 }
		if(f==true)
		 cout<<"Abletocatch"<<'\n';
		else
		 cout<<"Notabletocatch"<<'\n';
	 }
	return 0;
}
```


---

## 作者：ShineEternal (赞：1)

[link](https://blog.csdn.net/kkkksc03/article/details/104010532)


## solution:

排序，相当于贪心的思路，因为题目是问能不能都接完，所以从快到慢考虑。

每次别忘了计算接A的同时B已经下落的时间


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct ben
{
	int x,y;
}a[105];
int cmp(const ben &a,const ben &b)
{
	return a.y<b.y;
}
int abs(int x)
{
	if(x<0)return -x;
	return x;
}
int main()
{
	int T,n;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&a[i].x,&a[i].y);
		}
		sort(a+1,a+n+1,cmp);
		int tmp=0,tag=0;
		int flag=0;
		for(int i=1;i<=n;i++)
		{
			if(a[i].y-tag>=abs(a[i].x-tmp))
			{
				tag+=a[i].y;
				tmp=a[i].x;
				//printf("tmp=%d\n",tmp);
			}
			else
			{
				printf("Notabletocatch\n");
				flag=1;
				break;
			}
		}
		if(flag==0)
		{
			printf("Abletocatch\n");
		}
	}
	return 0;
}
```

---

## 作者：信赖滴星辰 (赞：1)

不用什么抛物线公式，因为数据小所以直接暴力模拟

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct node
{
	int heng;
	int shu;
};
node a[54];

bool cmp(node x,node y)
{
	return x.shu < y.shu;
}

int main()
{
	int G,N;
	int x,y;
	int tem;
	int flag=0;
	
	cin>>G;
	
	while(G!=0)  //开始暴力模拟
	{
		cin>>N;
		
		x=0,y=0;
		flag=0;
		
		for(int i=1;i<=N;i++)
		{
			cin>>a[i].heng>>a[i].shu;  //输入坐标
		}
		
		sort(a+1,a+N+1,cmp);    //把纵坐标排序，纵坐标越小的要越早去接
		
		for(int i=1;i<=N;i++)
		{
			if(a[i].heng-x<0) tem=x-a[i].heng;
			else tem=a[i].heng-x;
			
			if(a[i].shu>=tem)
			{
				x=a[i].heng;
				int tem1=a[i].shu;
				for(int j=i+1;j<=N;j++) a[j].shu-=tem1;	  //当移动一步后，所有的金币都往下掉一格
			}
			else
			{
				cout<<"Notabletocatch"<<endl;
				flag=1;
				break;
			}
		}
		
		if(flag==0)
		{
			cout<<"Abletocatch"<<endl;
		}
		
		G--;
	}
	
return 0;	
}

```

---

## 作者：_Imaginary_ (赞：0)

PS：可能导致本题题解过短。

首先，我们考虑一下接金币的过程。

我们发现，如果两个金币同时落地，并且不在同一个横坐标，那么不能同时抓到。~~（除非会极影或分身）~~

所以，

**特判1：如果有y坐标相同，`不可以`。**

剩下的情况就是y坐标都不相同的了。

假设这个人正在接金币，距离下一个金币很远，那么这个人~~除非是超人或者有传送门或者时光倒流~~都不可能跑过去吃掉金币。

**特判2：如果两个金币y坐标差别很小，但是x坐标差别很大，那么`不可以`。**

具体的，我们来考虑极端情况：

如果一个人接好金币a后~~以世界纪录~~跑到b时，正好落地，说明两个金币的x坐标差异和y坐标差异相同。

所以，只要满足出现了任意两个 $i$ , $j$ ，使得
$$
|X_i-X_j|>|Y_i-Y_j|
$$

那么就`不可以`.

最后，

**特判3：如果程序运行到特判1和特判2都通过，那么就`可以`。**

完结撒花！

~~可能有一点点短，希望管理员大大能通过。~~

---

## 作者：ezoiHQM (赞：0)

这道题很简单，定义一个结构体中有xi和yi，先将（0,0）插入堆，之后每次输入插入一个堆，按yi从小到大排序，判断相邻高度的两个数的xi差是否大于yi的差，如果大于即无法接完，一次循环后若没有出现xi差大于yi差，则可以接完。

代码：

```cpp
#include<queue>
#include<cstdio>
#include<cmath>
struct node{
    int xi,yi;
    bool operator<(const node&a)const{
        return yi<a.yi;
```
}//按yi排序
```cpp
}x;
int g,n;
using namespace std;
int main(){
    scanf("%d",&g);
    while(g--){
        bool flag=1;//判断能否接完，为1即可，为0即不可 
        priority_queue<node>q;
        q.push(node{0,0});//将初始位置插入堆中 
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d%d",&x.xi,&x.yi);
            q.push(x);
        }
        do{
            x=q.top();
            q.pop();
            if(abs(x.xi-q.top().xi)>abs(x.yi-q.top().yi)){//即无法接到下一个金币 
                puts("Notabletocatch");
                flag=0;//不可以为零 
                break;
            }
        }while(!q.empty());
        if(flag)puts("Abletocatch");
    }
}
```

---

## 作者：Great_Influence (赞：0)

挺水的一道题

方法很简单，按y坐标排序后逐个判断是否能接到就行了

代码：


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=100000+100;
inline void read(int &q)//读入优化
{
    char k=getchar();
    int s=0,f=1;
    while(!isdigit(k)&&k!='-')k=getchar();
    if(k=='-')
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    q=s*f;
}
struct coin
{
    int x,y;
}p[100];
int n,g;
bool cmp(coin x,coin y)
{
    return x.y<y.y;
}
int main(void)
{
    int i;
    read(g);
    while(g--)
    {
        read(n);
        for(i=1;i<=n;++i)
        {
            read(p[i].x);
            read(p[i].y);
        }
        sort(p+1,p+n+1,cmp);
        for(i=1;i<=n;i++)
            if(abs(p[i].x-p[i-1].x)>p[i].y-p[i-1].y)
            {
                printf("Notabletocatch\n");
                break;
            }
        if(i>n)printf("Abletocatch\n");
    }
    return 0;
}

```

---

## 作者：SBS苏 (赞：0)

这个题目其实不需要多想，只需判断每一个金币落下时人是否可以从上一个金币落下的地方走到这个金币的落点即可。

当然，还需加几个特判，比如：当同一个y值有多个x值对应时，即可“Notabletocatch”。

/\*
Problem:

OJ:
User:    S.B.S.

Time:
Memory:

Length:

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<cassert>
#include<climits>
#include<functional>
#include<bitset>
#include<vector>
#include<list>
#define F(i,j,k) for(int i=j;i<=k;++i)
#define M(a,b) memset(a,b,sizeof(a))
#define FF(i,j,k) for(int i=j;i>=k;i--)
#define maxn 10001
#define inf 0x3f3f3f3f
#define maxm 4001
#define mod 998244353
#define LOCAL
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
int data[1001];
int main(int argc,const char *argv)
{
    std::ios::sync_with_stdio(false);//cout<<setiosflags(ios::fixed)<<setprecision(1)<<y;
    #ifdef LOCAL
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    int g;cin>>g;
    while(g--){
        cin>>n;bool flag=false;
        F(i,1,1000) data[i]=-inf;
        F(i,1,n){
            int x,y;
            cin>>x>>y;
            if(data[y]!=-inf&&x!=data[y]){flag=true;}
            if(data[y]!=-inf) continue;
            data[y]=x;
        }
        if(flag==true){cout<<"Notabletocatch"<<endl;continue;}
        int pos=0,pre=0;flag=false;data[0]=0;
//        F(i,1,n) cout<<data[i]<<" "<<endl;
        F(i,1,1000){
            if(data[i]==-inf) continue;
            int time=abs(i-pre);
//            cout<<i<<" "<<pre<<" "<<data[i]<<" "<<data[pre]<<endl;
            if(abs(data[i]-data[pre])>time){flag=true;break;}
            pre=i;
        }
        if(flag==true) cout<<"Notabletocatch"<<endl;
        else cout<<"Abletocatch"<<endl;
    }
    return 0;
}

```

---

## 作者：TRZ_2007 (赞：0)

**[题解 P2694 【接金币】](https://www.luogu.com.cn/problem/P2694)**  
# Solution

观察到 $1\le n\le 50$ 和 $1\le G\le 5$，就可以知道我们能使用 $\mathcal{O(g.n^2)}$ 的方法切掉这道题。 先给出一个结论：  
关于每一个 $x_i,x_j,y_i,y_j(1\le i,j\le n)$，只要 $|x_i-x_j| > |y_i-y_j|$，那么这一个金币就不能被接到。  
用样例的第一组数据画个图感性理解一下：  
![](https://cdn.luogu.com.cn/upload/image_hosting/ei0bpkdb.png)  

这个样例中 B 落到 x 轴上的时间为 $T_B=|y_b| = 1$，A 落到 x 轴上的时间为 $T_A=|y_a| = 4$， C 落到 x 轴上的时间为 $T_c=|y_c| = 3$，关于任意的这三个点，移动时间的变化量 $\Delta t_1 = |\Delta |x||$，下落时间的变化量 $\Delta t_2 = |\Delta |y||$，当 $\Delta t_1 > \Delta t_2$ 的时候显然就不行了。但是注意 FJ 刚刚开始的时候是在 $(0,0)$ 的，这个不能忘。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 59;

int t,n;

struct node {
	int x,y;
}a[N];

bool cmp(const node &u,const node &v) {
	return u.y <= v.y;
}

void solve() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) {
		scanf("%d %d",&a[i].x,&a[i].y);
	}
	for(int i = 0;i < n;i++) {
		for(int j = i + 1;j <= n;j++) {
			if(abs(a[i].x - a[j].x) > abs(a[i].y - a[j].y)) {
				puts("Notabletocatch");
				return;
			}
		}
	}
	puts("Abletocatch");
}

int main() {
	scanf("%d",&t);
	while(t--) solve();
	return 0;
} 
```

---

## 作者：hmya (赞：0)

这是一道模拟题

我们要尽量让FJ接到全部的金币，如果实在接不到，才输出Notabletocatch

**FJ一定会先接y小的金币**

如果FJ先接了y大的金币，y小的金币就一定会落下来，导致FJ接不到全部的金币

所以要针对y进行排序

然后就是1~n的金币进行模拟

如果FJ现在的位置到金币位置的距离比金币的高度小，那么FJ就一定接不到这个金币，接不到这个金币，就可以直接输出“Notabletocatch”

否则就输出“Abletocatch”

就这样，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}a[1010];
int t,n,zb;//分别代表数据组数，金币数量，坐标
bool cmp(node a,node b){//比较函数
	return a.y<b.y;
}
int main(){
	scanf("%d",&t);
	while(t--){
		zb=0;//坐标初始化
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d%d",&a[i].x,&a[i].y);
		}
		sort(a+1,a+1+n,cmp);//根据y从小到大排序
		int i;
		for(i=1;i<=n;i++){//循环金币
			if(abs(zb-a[i].x)<=a[i].y){//接得到这个金币
				zb=a[i].x;//更新坐标
				for(int j=i+1;j<=n;j++){//减少时间
					a[j].y-=a[i].y;
				}
				a[i].y=0;
			}
			else{//接不到这个金币
				printf("Notabletocatch\n");
				break;
			}
		}
		if(i>n){//没输出"Notabletocatch"
			printf("Abletocatch\n");
		}
	}
	return 0;
} 
```

---


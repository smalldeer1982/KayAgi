# [AHOI2016初中组] 自行车比赛

## 题目描述

小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。


在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。


## 说明/提示

### 数据范围及约定

- 对于 $20\% $ 的数据，$3\le N\le 600$。
- 对于 $50\%$  的数据，$3\le N\le 1\times 10^4$。
- 对于 $100\%$ 的数据，$3\le N\le 3\times 10^5$ 且 $0\le B_i\le 2\times 10^6$。


## 样例 #1

### 输入

```
3
8
10
9```

### 输出

```
3```

## 样例 #2

### 输入

```
5
15
14
15
12
14```

### 输出

```
4```

# 题解

## 作者：小粉兔 (赞：60)

如果一个人想要拿第一，不用说，他最后一轮的得分必须是 $n$。

对于之前累积的分数不如这个人高的来说，他们最后一轮怎么样也比不过这个人，因为他们最后一轮的得分比 $n$ 低。

所以要考虑的就是之前累积的分数比这个人高的那些人，假设他们有 $x$ 名，那么最优情况就是他们都得了后 $x$ 名，即他们这一轮的得分是 $1 \sim x$。

接下来是怎么分配的问题，通过贪心得出：累积分数最高的这一轮得 $1$ 分，第二高的得 $2$ 分…… 直到这个人为止，这样可以使得那些人在这一轮得分后的分数最大值最小。

最后比较这个人，和那些之前累积分数比他高的人经过刚刚的加分后的分数，如果这个人的最终分数都不比那些人小的话，就可能会赢（刚刚就是一种情况）。

以上是针对一个人的情况的基本思路，写成代码肯定是要加一些排序的处理，最坏复杂度 $\mathcal O (n \log n)$。

再看如何把一个人的情况拓展到全部人，因为刚刚已经得出，那些原来分数比这个人小的是没有什么用的，所以把这些人也算到 `c` 数组里面是没有关系的；而原来分数比这个人大的，还是分数最高的得 $1$ 分，第二高的得 $2$ 分……，所以对每个人来说，这些人最后一轮的分数也不会改变。对于每个人来说，他的最优得分都是分数${} + n$，所以只要把分数${} + n$ 和 `c` 数组的最大值比较即可。复杂度 $\mathcal O (n \log n)$。


```cpp
#include<cstdio>
#include<algorithm>
#include<string>
using namespace std;
int n,b[300001],c[300001],mx=0,ans=0;
void init(){//读入
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&b[i]);
}
int main(){
    init();//读入
    sort(b+1,b+n+1);//b数组排序
    for(int i=1;i<=n;i++)
        c[i]=b[i]+n-i+1;//加分计算（最大值最小化，贪心）
    for(int i=1;i<=n;i++)
        if(mx<c[i])mx=c[i];//mx为c数组中的最大值
    for(int i=n;i>=1;i--)
        if(b[i]+n>=mx)//与c数组中的最大值mx比较
            ans++;
        else//发现如果得分较高的没希望得第一，得分比他低的更没希望，因为b数组也排过序，所以发现一个人没希望得第一了，就可以退出
            break;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_ZZH (赞：18)

一个人得冠军就要使其得分尽量大，其他人总分尽量小

应用贪心的策略，一个人最有可能拿冠军的情况是本局得分为n。
同时其他人的分数按总分多的分的越少。

那么我们可以发现，当b数组有序（递减）时，一个人在这场比赛中的得分已经定下了，就是按其排名给分。所以我们就能预见他们的总分，我们取其最大值作为衡量标准maxx.

对于每个人，如果他得n分仍不能超过maxx，那么他，包括分比他低的都不能拿冠军。反之，可行。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int maxx,ans,b[300010],n;
int cmp(const int &x,const int &y)
{
	return x>y;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&b[i]);
	sort(b+1,b+1+n,cmp);
	for(int i=1;i<=n;i++)
	maxx=max(maxx,b[i]+i);
	for(int i=1;i<=n;i++)
	if(b[i]+n>=maxx)
	ans++;
	else
	break;
	printf("%d",ans);
}
```

---

## 作者：STILL_ALONE (赞：11)

小蒟蒻发来的题解，看到大佬都有什么max之类的东西。  
~~我太菜了不会~~

我本来想深搜一遍，但是...woc为什么过不去？？？

于是我大义凛然（恬不知耻）地打开了标签。  
？？？贪心？？？模拟  
然后我抱头沉思一番，排个序不就好了吗！？  
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
int a[2000005];
int b[2000005];
int main()
{
	int n;
	cin>>n;
	int ans=0;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];//读入
	}
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=n;++i)
	b[i]=a[i]+n+1-i;//第i个人最后一天可得的分
	sort(b+1,b+n+1);//再排一波序
	for(int i=1;i<=n;++i)
	{
		if((a[i]+n)>=b[n]) 
		{
			ans++;
		}//如果这个人最后一天得分比最大的那个还要大，那么就加加
	}
	cout<<ans<<endl;//完美结束
	return 0;
}

---

## 作者：wubaiting2020 (赞：5)

1.先将所有人的初始分数从大到小排序（为什么是从大到小呢？是为了方便后面的判断）

2.给分最高的最低的分，给分第二高的第二低的分，一次类推，并求出需得到冠军的分数线maxx

3.顺序判断，如果一个人想得冠军，他最多加n分，如果他加上n分还是没有到达冠军线，那就不可能了，并且这时可以停止接下来的判断，因为分比后面高的都没戏，分低的怎么行呢？

上代码

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
int n,a[300005],maxx=0,ans=0;
bool cmp(int x,int y){return x>y;}//从大到小排 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)maxx=max(maxx,a[i]+i);//算出冠军线maxx 
	for(int i=1;i<=n;i++)
	{
		if(a[i]+n>=maxx)ans++;//判断该人能否有机会拿冠军 
		else break;
	}
	printf("%d",ans);
	return 0;
}


```


---

## 作者：abc123_abc123 (赞：3)

题目：luogu P2777

题目大意：有n个人1~i，已有得分ai，本轮发放每人1~n分，不重复，问有几人可能夺冠。

读题后，我们可以很快得到贪心策略：

若i要胜出，则其他人分数要小于他的分数，所以我们把其他人排序，最大的+1，次大的+2，以此类推。最后如果他的分数+n是最大的，则可能成为冠军。

为什么呢？如果j比i高分，j与k交换本轮得分使j所得分更少，则k将得到更大的得分，按我们之前的策略，k之前一定比j高分，则k与j交换本轮得分后分数一定大于i。

但是我们每次都做O(nlogn)的check的话，好像会T。。。于是我们可以先排序，再每次O(n)check排名为i的人。

于是我们神奇的发现：如果一个低分的人可能得冠，比他高分的人也可以。

So？通过这一点我们想到了排序后从大往小check排名为i的人，看有几个能成为冠军，这样还是O(n^2)，还是会T。。。

突然灵光一闪，这里的有序性使我们可以二分答案！

方法出来了！先O(nlogn)排序，然后二分答案log(n)次，每次O(n)check，总的时间复杂度还是O(nlogn)。

贴上代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int ans,a[300010],n,i,l,r,mid,p,j;
inline bool check(int x)
{
	p=a[x]+n;            //如果x要夺冠，先给他最高分
	for(i=1,j=n-1;i<=n;i++)
	{
		if(i==x)continue;     //是自己则跳过
		if(a[i]+j>p)return 0; //最优情况下有更高则不能夺冠
		j--;                  //后面的人得分减一
	}
	return 1;                     //最优情况下没人能比自己高分则可能夺冠
}
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+1+n);
	l=1;r=n;
	while(l<r)
	{
		mid=l+r>>1;
		if(check(mid))
			r=mid；//如果能夺冠，则压缩区间至l~mid
		else l=mid+1;  //如果mid不能，则压缩区间至mid+1~r
	}                      //这样r一定是答案
	printf("%d",n-r+1);
	return 0;
}
```

写得丑，请见谅。

---

## 作者：wanghanjun (赞：3)

做完之后点开题解，发现几乎所有人做法都和我不一样。。

我们可以想到用一个简单的贪心来判断一个人有没有可能得第一：

```cpp
bool check(int x){//不妨设已经排完序了
	for(int i=n;i>x;i--){
        //让第一个人取最好情况，即n分
		if(a[x]+n<a[i]+n-i+1){
			return false;
		}
        //从高到低枚举，原得分越高，这一局就让TA得越低的分
	}
	return true;
}
```

check函数要排序，那我们就直接排序，再二分好了

上代码。。。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN=300005;
int a[MAXN],n,l,r,ans;
//ans是原得分最小的，有可能得第一名的人

bool check(int x){
	for(int i=n;i>x;i--){
		if(a[x]+n<a[i]+n-i+1){
			return false;
		}
	}
	return true;
}

int main(){
	cin>>n;
	l=1;r=n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
    //套二分模板（假装有模板）
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)==true){
			r=mid-1;
			ans=mid;
		}
		else{
			l=mid+1;
		}
	}
    //所有得分比a[ans]大的都可能得第一
	cout<<n-ans+1<<endl;
	return 0;
}
```

---

## 作者：PolyLoger (赞：2)

貌似有人说楼下的一些题解错了，过来贴一下**样例2**过了（AC）的C++代码（楼下是P党嘛。。。）


贪心思路很简单，

当前排第一的人加一分，排第二的人加两分.....排第i的人加i分

显然，计算排名第j是否能成第一的时候，排名第j要算加n分后处理，此时，我们用一个**后缀最大值**来优化，

O（1）时间让j+n（最多加的分数）与当前排在其之前的所有在最后一轮后可能最小值的最大值比较，>=的话就++ans


最后一个小小的优化，那就是如果排名第j的已经无法成为第一，则排名在第j之后的就更无法达到了（break）


**在此怀念一下当天比赛时茅塞顿开的自己（显然AC了。。。）。。。**


具体看代码。。。





```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=666666;/*Don't care it.*/
int n,ans,beat[N],biggest[N];
/*We don't need the "biggest[N]",we only need a "biggest"...*/
int main(void)
{
    freopen("P2777.in","r",stdin);
    freopen("P2777.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&beat[i]);
    sort(beat+1,beat+1+n);
    for(int i=n;i>=1;--i){
        if(beat[i]+n>=biggest[i+1])++ans;
        else break;
        biggest[i]=max(biggest[i+1],beat[i]+n-i+1);
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：pipiispig (赞：1)

###一道贪心题硬生生被我做成了二分答案QWQ(最近做二分答案做多了？QWQ)
```#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm> 
using namespace std;
struct node{
	int x,y;
};
int s[1000000],b[1000000];	
int n;
int cmp(int x,int y){
	return x>y;
}
int cherk(int m){//按理说二分答案的难点就在于cherk函数上，然而这个cherk函数我们可以写的很暴力（更简单的说）；
	int q=s[m]+n;
	for(int i=1;i<m;i++){
		if(q<s[i]+b[i])return 0;
	}
	return 1;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s[i];
	sort(s+1,s+n+1,cmp);
	for(int j=1;j<=n;j++){
		b[j]=j;
	}//一个简单的贪心——>使排名越高的可以加的分越少,这样才会使分约高的人最后一场比赛获得得分约少，使所求人得冠军的几率更大；
	int l=1,ans,r=n;
	while(l<=r){//愉快的二分答案~
		int mid=l+r>>1;
		if(cherk(mid)){
			l=mid+1;
			ans=mid;
		}
		else r=mid-1;
	}
	cout<<ans;
}```

---

## 作者：ghj1222 (赞：0)

显然如果一个人想要拿第一

我们这一场就让他拿第一（反正比不拿第一要好）
```
#include <bits/stdc++.h>
using namespace std;

int n, a[300010], b[300010], c[300010], d[300010], ans;

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	sort(a + 1, a + 1 + n, greater<int>());//将得分数组从大到小排序
	for (int i = 1; i <= n; i++)
	{
		b[i] = a[i] + i;//b[i]表示让原来Rank1当倒数第一，....原来RankN当第一后的分数(也就是逆天分数)
		c[i] = max(c[i - 1], b[i]);//表示b[i]的前缀最大，也就是说执行了逆天策略后一个人前面最大的人是谁
	}
	for (int i = n; i >= 1; i--)//从后往前推
	{
		if (a[i] == a[i + 1])//对于分数相等的情况
			ans += (d[i] = d[i + 1]);
		else
			ans += (d[i] = (a[i] + n >= c[i]));//分数不相同，如果我得到了Rank1，会不会比执行逆天策略后前面的那个人高
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：zyyyyyyyyyyyyyyy (赞：0)

首先来解释一下为什么有人说题解错了，

题解中只是与倒数第二轮的第一比，

然而如同样例二， 倒数第二局会有同分，

所以最后一局贪心思想之后你快排的第一不一定是第一。

#思路

1：快排；

2：将第一名加最小分减一，第二名加次小分减一……依此类推；

3：寻找当前最大值；

4：将每一个值补到n（我当时用m）； 与最大值比较；

剩下一部分细节参考我的的程序（pascal）。

```cpp
var a,c:array[1..300000] of longint;
   i,j,k,m,ans,m1,m2:longint;
procedure quick(b,c:longint);
var t,left,right,m:longint;
begin
left:=b; right:=c; m:=a[(b+c) div 2];;
repeat
while a[left]<m do inc(left);
while a[right]>m do dec(right);
if left<=right then begin t:=a[left]; a[left]:=a[right]; a[right]:=t;
inc(left); dec(right);
end;
until left>right;
if left<c then quick(left,c);
if right>b then quick(b,right);
end;
begin
read(m);
for i:=1 to m do
read(a[i]);
quick(1,m);
for i:=1 to m do
begin
c[i]:=i;
a[i]:=a[i]+m-i;
end;
m1:=0;
m2:=0;
for i:=1 to m do
if (a[i]>m1) or ((a[i]=m1) and (m2<c[i])) then begin m1:=a[i]; m2:=c[i]; end;
ans:=0;
for i:=1 to m do
if m2<c[i] then begin if a[i]+c[i]>=m1 then inc(ans); end//这一部分大家自己考虑一下
           else if a[i]+c[i]>=m1+1 then inc(ans);
write(ans);
end.
```

---

## 作者：唯爱你一生 (赞：0)

一题较简单的模拟加排序题
具体注释在代码里，就不多说了
附上代码
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int a[300006];// 本题数据范围为300000，所以数组稍微开大一点 
bool cmp(int x,int y){
	return x>y;
}//sort函数的比较函数 
int main(){
	std::ios::sync_with_stdio(false);//输入优化，关闭cin的兼容性，让cin和scanf的速度一样快 
	int n,mx=0,ans=1;//初始化mx，ans 
	cin>>n;//读入n 
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}//读入a数组 
	sort(a+1,a+1+n,cmp);//将a数组进行排序 
	a[1]+=1;
	mx=max(a[1],mx);//更新a[1]和mx的值 
	for(int i=2;i<=n;i++){
		if(a[i]+n>=mx){
			ans++;
		}
		a[i]+=i;
		mx=max(a[i],mx);
	}//循环 
	cout<<ans<<endl;//输出ans 
	return 0;//结束程序 
}
```

---


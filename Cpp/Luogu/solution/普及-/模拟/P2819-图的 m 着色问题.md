# 图的 m 着色问题

## 题目背景

给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。


## 题目描述

对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。


## 说明/提示

数据保证，$1\leq n\leq 100$，$1 \leq k\leq 2500$。

在 $n$ 很大时保证 $k$ 足够大。

保证答案不超过 $20000$。

数据为在满足上述条件的合法数据中随机采样得到。

## 样例 #1

### 输入

```
5 8 4
1 2
1 3
1 4
2 3
2 4
2 5
3 4
4 5```

### 输出

```
48```

# 题解

## 作者：zzlh (赞：46)

一题挺水的搜索题，从第1个点开始搜，依次填入不冲突的数，搜到第n+1一个点时表示这种方法可行，答案+1，然后回溯，重复此流程。

贴代码，如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
bool f[105][105];//存两个点是否连通
int color[105];//存每个点的颜色
int num=0;
int n,k,m;
bool check(int sum){
    for(int i=1;i<=sum;i++){
        if(f[i][sum]==true&&color[i]==color[sum]){
            return false;
        }
    }
    return true;
}//这里是判断冲突的核心，当两个图连通时且颜色一样就冲突
void dfs(int s){
    if(s>n){
        num++;//搜到n+1个点，也就是走完了
        return;
    }
    for(int i=1;i<=m;i++){
        color[s]=i;//把颜色存下来
        if(check(s)==true){
            dfs(s+1);
        }else{
            color[s]=0;//如果冲突则重新打回0
        }
    }
}        
int main(){
    cin>>n>>k>>m;
    for(int i=1;i<=k;i++){
        int x,y;
        cin>>x>>y;
        f[x][y]=true;
        f[y][x]=true;
    }
    memset(color,0,sizeof(color));
    dfs(1);
    cout<<num<<endl;
    return 0;
}
```

---

## 作者：Creeper_LKF (赞：20)

关于此题的dfs的一个优化思想。

首先说明这份代码并不是rank1，因为rank1的代码在一年前交的，好像只有两个点有时间，再是该代码经过微小的优化之后可以飞起来（但是因为个人的历史问题，我并不打算做任何这些优化）。

考虑现在染色到了第i个点，我打算染第j种颜色。

如果我发现j颜色在之前从未被染过色，而现在场上还有x种以前从未染过色的颜色。那么一旦点i染j色是局部合法的，那么我可以认为在一种全局合法的方案下染j色和其他从未出现过的颜色是等价的，于是方案数直接乘以x返回即可。

在初次写代码的时候可以想到对于第一个染色的点一定满足这个条件，于是第一个点不用搜索而直接在方案数上乘以颜色个数。然后推广一下就可以对所有点都做类似优化。

同一种代码优化级别和此题数据规模下该方法可以优化3倍时间左右。

```cpp
#include <cstdio>

using namespace std;

int n, m, k;
int col[101], tim[101], ali; // 某点的颜色，某颜色的出现次数，从未出现过的颜色数
int tabl[101][101], siz[101]; // 也是邻接表
bool has[101][101]; // 邻接表

inline void add_edge(int u, int v){
    tabl[u][++ siz[u]] = v;
    tabl[v][++ siz[v]] = u;
}

int dfs(int pt){
    if(pt == 0) return 1;
    else {
        int ret = 0, tmp = 0;
        for(int i = 1; i <= k; i++){
            if(tim[i] == 0){ // 第一次出现
                if(tmp) continue;
                col[pt] = i, tim[i] ++, tmp = ali, ali --;
                ret += dfs(pt - 1) * tmp;
                tim[i] --, ali ++;
            } else { // 非第一次出现
                if(tim[i] == 0) continue;
                bool flg = true;
                for(int j = siz[pt]; flg && j; j--){
                    if(i == col[tabl[pt][j]])
                        flg = false;
                }
                if(flg) col[pt] = i, tim[i] ++, ret += dfs(pt - 1), tim[i] --;
            }
        }
        col[pt] = 0;
        return ret;
    }
}

int main(){
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 1; i <= m; i++){
        int u, v;
        scanf("%d%d", &u, &v);
        has[u][v] = has[v][u] = 1;
    }
    for(int i = 1; i <= n; i++)
        for(int j = i + 1; j <= n; j++)
            if(has[i][j])
                add_edge(i, j);
    ali = k;
    printf("%d\n", dfs(n));
    return 0;
}
```


---

## 作者：Zn_Hua (赞：8)

>来自辣鸡的题解
**这道题数据比较小，用深搜加上循环判断直接暴力**

- 如题，我们可以用二维数组表示结点与结点能否到达

-颜色用1，2，3，......，k表示

-注意题意是给每个点染色而不是把颜色染完（废话！

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
void search(int);
void put();
int check(int,int);
int a[200][200]={0},b[200]={0},sum=0;//sum用来存储方案数，a记录结点路径，b用于记录已染色的点
int n,k,m;//n个顶点,k条边，m种颜色
int main()
{
    int t1,t2;
    cin>>n>>k>>m;
    for(int i=1;i<=k;++i)
    {
        cin>>t1>>t2;
        a[t1][t2]=1;//无向图,双方可到达
        a[t2][t1]=1;
    }
    search(1);//从1找起
    cout<<sum;
    return 0;
}
void search(int x)
{
    if(x>n){sum++;return;}//若x>n则已染色完成，方案+1
      for(int i=1;i<=m;++i)//枚举颜色
      {
          if(b[x]==0&&check(i,x)==1)//若改点未染色，且该点相邻点中无同色点
          {
            b[x]=i;//标记已染色
            search(x+1);//染下一个点
            b[x]=0;//还原标记
          }
      }
}
int check(int x,int y)
{
    for(int i=1;i<=n;++i)//寻找相邻点
    {
        if(i==y)continue;//肯定不能比较自己与自己是否相同啦，跳过
        if(a[y][i]==1&&b[i]==x)return 0;//若y点可到达i点，且两者颜色相同，返回0
    }return 1;//符合条件可以染色，返回1
}
```

---

## 作者：肖恩Sean (赞：4)

以点进行深度优先搜索，每层都保证每个点都与和他连接的点的颜色不相同；当每个点都有颜色时，增加一个可行解，最后输出。

```cpp
var
 a:array[1..100] of longint; //每个点的颜色
 b:array[1..100,1..100] of boolean; //记录无向图的联通
 n,k,m,i,x,y,ans:longint;
function tot(c,x:longint):boolean; //判断函数，保证每个点与他连接的点的颜色不相同
var
 i:longint;
begin
 for i:=1 to n do
  if b[c,i] and (x=a[i]) then
   exit(false);
 exit(true);
end;
procedure dfs(c:longint);
var
 i,j,s:longint;
begin
 if c>n then //递归边界
  begin
   inc(ans);
   exit;
  end;
 for i:=1 to m do //深搜
  if tot(c,i) then
   begin
    a[c]:=i;
    dfs(c+1); //搜索下一个点
    a[c]:=0;
   end;
end;
begin
 readln(n,k,m);
 for i:=1 to k do
  begin
   readln(x,y);
   b[x,y]:=true; //无向图互相联通
   b[y,x]:=true;
  end;
 dfs(1);
 writeln(ans);
end.
```

---

## 作者：pyyyyyy (赞：3)

就是一道很水的搜索题目:

涂的时候从颜色1开始到m，每当涂上一个色，要判断第i个点是否可以涂这个色，不可以的话就不再往下涂了，改试另一个颜色，可以的话就继续。

## c++代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,m,k,s,ks[10000],next[10000],e[10000],a[10000];

void go(int x)
{
	 if (x>n)
	 {
		s++;
		return;
	  }
	int i;
	bool b[1000];
	i=ks[x];
	memset(b,1,sizeof(b));
	while (i!=0)
	{
		if (e[i]<x) b[a[e[i]]]=false;
		i=next[i];
				}
	for (i=1;i<=k;i++)
	if (b[i])
	{
		a[x]=i;
		go(x+1);
		}
}
int main()
{
	cin>>n>>m>>k;
	int i,x,y;
	for (i=1;i<=m;i++)
	{
		cin>>x>>y;
		next[i]=ks[x]; ks[x]=i; e[i]=y;
		next[i+m]=ks[y]; ks[y]=i+m; e[i+m]=x;
		}
	s=0;
	go(1);
	cout<<s<<endl;
	return 0;
}
```

## p党福利:
```pascal
var
        ans,r,x,y,i,N,K,M:longint;
        l,f:array[0..101] of longint;
        a:array[0..10001,1..2] of longint;
procedure insert(x,y:longint);
begin
        inc(r);
        a[r,1]:=y;
        a[r,2]:=f[x];
        f[x]:=r;
end;

procedure find(x:longint);
var
        i:longint;
        c:array[1..6] of longint;
begin
        if x>n then inc(ans)
        else begin
                for i:=1 to k do c[i]:=0;
                i:=f[x];
                while i>0 do
                begin
                        c[l[a[i,1]]]:=1;
                        i:=a[i,2];
                end;
                for i:=1 to k do
                   if c[i]=0 then
                   begin
                        l[x]:=i;
                        find(x+1);
                   end;
             end;
end;

begin
        read(n,m,k);
        for i:=1 to m do
        begin
                read(x,y);
                if x<y then insert(y,x)
                else insert(x,y);
        end;
        find(1);
        writeln(ans);
        close(input);close(output);
end.

```
代码来自一本通，我真是太蒟蒻了只能比着打


---

## 作者：skylee (赞：3)

本体乍一看以为是图论，然而实际上是一道简单的搜索，而且是不需要任何优化的深搜！

基本思路：

用一个Map数组记录图的联通情况，然后DFS遍历每一个点，枚举每一种颜色，如果没有被与当前结点联通的结点用过，则进行下一层搜索。当搜索层数等于总结点数时增加一种答案。详细过程见代码及注释。

'''pascal

```cpp
var
    n,k,m,i,u,v,ans:longint;
    map:array[1..100,1..100]of boolean;
    col:array[1..100]of longint;
function unused(node,color:longint):boolean;//判断当前颜色是否被使用
    var
        i:longint;
    begin
        for i:=1 to node-1 do begin//注意枚举的结点不仅要求与当前结点联通，而且要保证已经被搜索过，故循环边界为node-1而不为n
            if map[node,i] and (col[i]=color) then begin
                exit(false)
            end
        end;
        exit(true)
    end;
procedure dfs(node:longint);
    var
        i:longint;
    begin
        if node=n then begin//当所有结点都被搜索过则累计答案数
            inc(ans);
```
exit
```cpp
        end;
        for i:=1 to m do begin//枚举颜色
            if unused(node+1,i) then begin
                col[node+1]:=i;
                dfs(node+1)
            end
        end
    end;
begin
    readln(n,k,m);
    fillchar(map,sizeof(map),0);
    for i:=1 to k do begin
        readln(u,v);
        map[u,v]:=true;//
        map[v,u]:=true//记录图的联通情况
    end;
    ans:=0;
    dfs(0);
    writeln(ans);
```
readln
end.
'''

---

## 作者：__nullptr__attr (赞：1)

既然存在点与点之间的关系，就想到存储图：**用邻接矩阵或者链式前向星**。这里出题人很友好，邻接矩阵存的下，但我还是要说说链式前向星的做法。  
链式前向星存边的模板：  
```cpp
inline void add(int x,int y){
    ver[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
```
找从$x$出发的边$(x,y)$：  
```cpp
for(int i=head[x];i;i=nxt[i]){
    int y=ver[i];
}

```
如果存在边权：  
```cpp
inline void add(int x,int y,int z){
    ver[++tot]=y;
    edge[tot]=z;
    nxt[tot]=head[x];
    head[x]=tot;
}
```  
**不懂的请自行查阅相关资料**  
那么这里**用链式前向星有什么好处**吗？  
当然有！如果用邻接矩阵存图，需要枚举每一个点；如果用链式前向星，那么**直接找边的终点**$ver[\,]$就行了。  
```cpp
inline bool valid(int c,int p){
    for(int i=head[p];i;i=nxt[i]){
        int y=ver[i];
        if(color[y]==c) return 0;
    }
    return 1;
}
```
贴完整代码（抄这个题解是没有用的哦，考试里面不会，还不是爆零$QwQ$，劝那些抄题解的人改过自新）：  
```cpp
//P2819
#include<bits/stdc++.h>
using namespace std;
const int maxn=10010;
int n,k,m,ans=0,color[maxn],tot=0,vis[maxn],ver[maxn],nxt[maxn],head[maxn];
inline void add(int x,int y){
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
inline bool valid(int c,int p){
	for(int i=head[p];i;i=nxt[i]){
		int y=ver[i];
		if(color[y]==c) return 0;
	}
	return 1;
}
void dfs(int dep){
	if(dep==n+1) return ans++,void();
	for(int i=1;i<=m;++i){
		if(valid(i,dep)){
			color[dep]=i;
			dfs(dep+1);
			color[dep]=0;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>k>>m;
	for(int i=1;i<=k;++i){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs(1);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：cenbinbin (赞：1)


很明显应用搜索做，至于范围吗。。。就用深搜即可


```cpp
=========================================================
var d:array[1..100,1..100] of boolean;
e:array[1..1000] of longint;
a,b,c,i,x,y,sum:longint;
procedure s(k:longint);//深搜
var i,j:longint;
f:boolean;
begin
  if k=a+1 then sum:=sum+1//累加数目
   else for i:=1 to c do//每一种着色
   begin
   f:=true;
   for j:=1 to k-1 do
   if (d[k,j]=true) and (i=e[j]) then//是否满足条件
   f:=false;
   if f then begin
     e[k]:=i;
     s(k+1);
     e[k]:=0;//状态还原
   end;
   end;
end;
begin
 read(a,b,c);
 for i:=1 to b do
 begin
 read(x,y);
 d[x,y]:=true; d[y,x]:=true;//双向表示
 end;
 s(1);
 write(sum);//输出
end.
```

---

## 作者：Datura_ (赞：1)

数据范围不大，可以直接用邻接矩阵实现。

从1开始染色，每次枚举相邻的边颜色是否都不一样。找到一种方案就ans++。

AC代码：
```cpp
#include<iostream>
using namespace std;
 
int n,k,m,ans;
bool e[101][101];
int col[101];
 
bool check(int v,int i)
{
    for(int j=1;j<=n;j++)
        if(e[v][j]&&col[j]==i)
            return false;//相邻且颜色相同，返回false。
    return true;
}
 
void dfs(int v)
{
    if(v>n)
    {
        ans++;//找到一种方案，答案加1。
        return;
    }
    for(int i=1;i<=m;i++)
    {
        if(check(v,i))
        {
            col[v]=i;//染色
            dfs(v+1);
            col[v]=false;
        }
    }
}
 
int main()
{
    cin>>n>>k>>m;
    for(int i=1;i<=k;i++)
    {
        int u,v;
        cin>>u>>v;
        e[u][v]=true;
        e[v][u]=true;
    }
    dfs(1);
    cout<<ans;
    return 0;
}
```

---

## 作者：DreamShadow (赞：1)

# ！！！原版原创，仿冒必究！！！

### 说实话，这题还是比较搞的（除了部分人）虽说看着这题目简单，其实自有难点，其实这就用到了搜索与回溯算法，定义一个过程，从最小开始，（使劲找，反正找得到，就是那个穷举法（差不多）不过还是需要优化的）找到最大即可，不过有可能会超时，所以要注意！

##  附上伪代码：
     var
        ans,r,x,y,i,N,K,M:longint;
        l,f:array[0..101] of longint;//切记，一般情况下都可以将数组下标定义为0
        a:array[0..10001,1..2] of longint;
      procedure insert(x,y:longint); //定义一个过程inser，用于统计，插入。
      begin
        inc(r);//统计次数，用r
        a[r,1]:=y;//初始化
        a[r,2]:=f[x];
        f[x]:=r;//将r赋值给f[x]
      end;
      procedure find(x:longint);//定义过程find，用于穷举。
      var
        i:longint;
        c:array[1..6] of longint;//c数组建议别开太大
       begin
         if x>n then inc(ans)//边界条件，否则死循环
         else begin//如果不符合边界条件，则开始
           for i:=1 to k do c[i]:=0;//请0不能忘，也可以写sizeof(0)。
            i:=f[x];//将f[x]赋值给i
            while i>0 do//另一个边界条件，也可以用repeat until。
                begin
                        c[l[a[i,1]]]:=1;//统计
                        i:=a[i,2];//重新赋值给i
                end;
                for i:=1 to k do
                   if c[i]=0 then
                   begin
                        l[x]:=i;
                        find(x+1);//重新开始累加x。
                   end;
             end;
       end;
     begin//主程序不必多说
        read(n,m,k);
        for i:=1 to m do
        begin
                read(x,y);
                if x<y then insert(y,x)
                else insert(x,y);
        end;
        find(1);//调用一下，就搞定
        writeln(ans);//别忘记输出
     end.



---

## 作者：fl_334 (赞：0)

==我的程序

```cpp
var 
             s:array[1..1000]of longint;
             b:array[1..100,1..100]of boolean;
             i,n,m,k,su,o,p:longint;
procedure dog(j:integer);               //这个嘛，搜索呀
var 
              i,k:longint;
              bb:boolean;
begin
            if j=n+1 then begin
inc(su);exit;end;       //如果搜完就退出o
for i:=1 to m do
begin
bb:=true;
for k:=1 to j-1 do
if (s[k]=i)and(b[j,k]) then begin bb:=false; break; end;            //如果满足着色条件那么就选择
if bb then
begin
s[j]:=i;               //选择后着色
dog(j+1);         //dog走起，继续搜
end;
end;
end;
begin
readln(n,k,m);
for i:=1 to k do
begin
readln(o,p);
b[p,o]:=true;        //记得是无向图
b[o,p]:=true;
end;
su:=0;            //初始化 
dog(1);//搜啊
writeln(su);      //输出
end.
没啥好说的搜索水题
```

---

## 作者：iao113 (赞：0)

典型dfs题，和部落卫队有点相似

[codec]





















```cpp
#include <iostream>
using namespace std;
int n, m, k;
bool ** G;  // 储存无向图点的连接情况
int * node;  // 储存点的着色
int num = 0;  // 解的数量
void dfs(int x);
int main()
{
    // 输入和内存分配
    cin >> n >> m >> k;
    G = new bool *[n + 1];
    node = new int[n + 1];
    for (int i = 0; i <= n; i++)
        G[i] = new bool[m + 1];
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= m; j++)
            G[i][j] = false;
    for (int i = 0; i < m; i++)
    {
        int x, y;
        cin >> x >> y;
        // 储存相连接的点
        G[x][y] = true;
        G[y][x] = true;
    }
    dfs(1);
    cout << num;
    return 0;
}
void dfs(int x)
{
    if (x == n + 1)
        num++;
    else
        for (int i = 1; i <= k; i++)
        {
            bool flag = false;
            for (int j = 1; j < x; j++)
                if (G[x][j])
                    if (i == node[j])
                        flag = true;  // 这种颜色已有相连接的点是痛颜色
            if (flag)
                continue;
            node[x] = i;
            dfs(x + 1);
            node[x] = 0;
        }
}
[/codec]
```

---

## 作者：qzhwyce (赞：0)

### 一道搜索的~~水~~题
由于题中数据较小，所以我们可以直接用深搜暴力搜索各个节点。  
题目给出了图中的各个线段，要求在各个节点上涂色，使得一条线段的两个节点颜色不同，并输出总方案数。  
我们可以定义一个布尔数组G来存储两个节点间是否有线段。  
并定义一个数组color存储节点的颜色。  
涂色的过程可以用for循环，用i代表颜色，一直++直到m。同时还要特判一下一条线段的顶点是否涂了同一颜色。
当x大于n时，说明所有节点都搜索了一遍，则ans++.

--------------------------

## AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,m,i,j,u,v,ans = 0;
int g[101][101],color[10001];
bool b = 0;
void dfs(int x){//深搜函数
	if(x > n){
		ans++;
		return;
	}
	for(int i = 1;i <= m;i++){
		color[x] = i;//模拟涂色的过程
		for(int j = 1;j <= x;j++){
			if(g[j][x] && color[j] == color[x]){//特判一条线段的顶点是否涂了同一颜色
				b = 1;
				break;//跳出循环
			}
		}
		if(b){
			b = 0;
		}else{
			dfs(x + 1);//递归，继续搜索
		}
	}
}
int main(){
	memset(g,0,sizeof(g));
	memset(color,0,sizeof(color));
	cin>>n>>k>>m;
	for(i = 1;i <= k;i++){
		cin>>u>>v;
		g[u][v] = 1;
		g[v][u] = 1;
	}
	dfs(1);
	cout<<ans;
	return 0;
}

```


---

## 作者：千反田 (赞：0)

#  ~~爆搜大法好~~

一道搜索水题

没有什么难点 ~~那你为什么还要写啊~~

注释在代码：

```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 105
#define Num 2505//个人习惯
using namespace std;
int n,k,m,ans=0,color[N];//color数组表示当前所着的颜色
bool trace[N][N];//trace存两个点是否联通
bool cmp(int c,int num)//判断函数
{
    for(int i=1;i<=n;++i)
    {
    	if(color[i]==c&&trace[num][i])//如果两点联通且颜色相同
    	return false;//不合法
    }
    return color[num]==0? true:false;//三目运算符
    //如果该点没有遍历过（color[num]==0），返回true
    //否则返回false
}
void DFS(int step)//深搜
{
	if(step>n)//更新答案
	{
		ans++;
		return;
	}
	for(int i=1;i<=m;++i)
	{
		if(cmp(i,step))//如果合法
		{
			color[step]=i;
			DFS(step+1);//继续快乐地搜索
			color[step]=0;
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=k;++i)
	{
		int temp_a,temp_b;
		scanf("%d%d",&temp_a,&temp_b);
		trace[temp_a][temp_b]=true;
		trace[temp_b][temp_a]=true;//由于是无向连通图，所以要标记两个		
	}
	DFS(1);
	printf("%d",ans);
    return ~~(0-0);//卖萌求通过
}
```


---


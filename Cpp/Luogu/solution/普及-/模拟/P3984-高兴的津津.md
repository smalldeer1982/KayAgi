# 高兴的津津

## 题目描述

津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，他的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1\le n\le2\times10^5$。
- $1\le T\le10^9$。
- $1\le t_i\le 10^9$，$t_i$ 单调递增。

## 样例 #1

### 输入

```
3 5
1 2 10```

### 输出

```
11```

# 题解

## 作者：zy小可爱ღ (赞：84)

我要是说我这题3分钟码完代码一遍就过了，会不会有人打我。。~~无辜脸~~  
咳咳，还是说题目吧  
这题的思路真心很简单，因为题目保证输入数据递增，所以可以边读边做，O(n)的算法，具体在代码中解释  
不说废话，直接上代码：
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

int n,t,ans;//ans是答案，answer，显得我英语很好（划掉）
int a[200005];

int main(){
	scanf("%d%d",&n,&t);//读入不解释
	scanf("%d",&a[1]);//先读入第一个数据
	for(int i=2;i<=n;i++){//从第二个数开始读，并加上判断
		scanf("%d",&a[i]);
		if(a[i]-a[i-1]<t){//如果前一次与这次时间间隔不大于t天，加上相隔的时间
		    ans+=a[i]-a[i-1];
		}
		else{//如果大于t天，因为快乐只能持续t天，所以答案加一
		    ans+=t;
		}
	}
	printf("%d\n",ans+t);//因为最后一天的快乐肯定能持续t天，所以直接输出ans+t就好
	return 0;
}

```
读完题目，我好想跟津津一样也能虐爆全场就好了。。。  
本人QQ：2124652975，初二蒟蒻一枚，对题目不理解的话欢迎骚扰~~

---

## 作者：Lolierl (赞：18)

```cpp
//入门水题一道。
//先从宏观考虑：任意一个au，必定会造成一定的高兴。如果它与后一个au的时间差>t，则会造成t的不高兴，否则则这一个au就会造成它与后一个au的时间差的不高兴。
//看上去好像比较复杂，附上代码：
#include<iostream>
using namespace std;

int main()
{
    int n,ti;
    cin>>n>>ti;//输入
    int t[n+1];
    
    for(int i=1;i<=n;i++)
        cin>>t[i];
    
    int ans=0;
    for(int i=2;i<=n;i++)
        if(t[i]-t[i-1]>ti)ans+=ti;else ans+=t[i]-t[i-1];//核心：不管下一个au如何，此次的第i-1个au必然会造成min(ti,t[i]-t[i-1])的高兴。
    ans+=ti;//第n个au就不存在重叠的情况了，直接+=ti。
    cout<<ans;
    return 0;
}
```
![](https://cdn.luogu.com.cn/upload/pic/11318.png)


---

## 作者：EarthGiao (赞：11)

# 潇洒の开始
大水题一枚/小声说话

先吐槽一下：

为什么津津经历了魔鬼训练就可以Au日常QWQ,人家也是早起晚睡的好吧

（~~谁说魔鬼训练就一定是早起晚睡的~~）

思路 

津津的高兴是持续m天的，但是一旦在这m中，再一次Au，会从得到Au的这一天里重新开始m填高兴，所以可以酱紫

```cpp
	int qwq=a[i]-a[i-1];
	if(qwq>m)js+=m;//多余m天就只能高兴m天 
	else//小于m天只能高兴qwq天 
	js+=qwq;//加上 
```

如果两次Au中间的间隔时间小于等于m的话,那就累加上两天的差，如果大于m的话就只能加上m了，明白这一点就可以轻轻松松AC

PS:

要特判i!=1哦，因为我是从1开始循环输入的，所以0是没有值的

完整AC代码走起

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;

int n,m;
int a[200001];

int main()
{
	int js=0;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);//输入 
		if(i!=1)//不是第一次的时候 
		{
			int qwq=a[i]-a[i-1];
			if(qwq>m)js+=m;//多余m天就只能高兴m天 
			else//小于m天只能高兴qwq天 
			js+=qwq;//加上 
		}
	}
	js+=m;//最后一次一定会吃持续m天 
	printf("%d\n",js);
	return 0;
}
```

# 完美の结束

---

## 作者：kevin_y (赞：6)

# 这一题模拟过的（最简思路
- 这一题首先注意输入的数组已经是递增整数了；
- 只用两个判断，若后面的数与前面的数差大于等于获一次奖高兴的天数，就加获一次奖高兴的天数
- 代码实现：if(a[i+1]-a[i]>=n)sum+=n;
- 若后面的数与前面的数差小于获一次奖高兴的天数，就加两数之差
- 代码实现：sum+=a[i+1]-a[i];
```cpp
#include<iostream>
using namespace std;
int m,n,a[200001],i,sum;
int main(){
	cin>>m>>n;
	for(i=1;i<=m;i++)cin>>a[i];//输入
	for(i=1;i<m;i++){
		if(a[i+1]-a[i]>=n)sum+=n;
		else sum+=a[i+1]-a[i];
	}
	cout<<sum+n;//最后别忘加n
}
```

---

## 作者：JJJJones_Zhu (赞：6)

这个题嘛

其实是~~DALAO~~
JURUO也能做出来的题。

毕竟我们都想离恶心的数学远一点

还是来看~~代码~~数学题吧


------------
```cpp
#include <iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
using namespace std;

int main()
{
    int N,T,ti,ti1,sum=0;
    cin>>N>>T;
    cin>>ti>>ti1;
    if(ti1>(ti+T-1))//注意边界问题
        sum+=T;
    else if(ti1==(ti+T-1))
        sum+=T-1;
    else
        sum+=ti1-ti;
    while(N-2)
    {
        ti=ti1;cin>>ti1;//注意要更新ti与ti1的值
        if(ti1>(ti+T-1))
            sum+=T;
        else if(ti1==(ti+T-1))
            sum+=T-1;
        else
            sum+=ti1-ti;
        N--;
    };
    sum+=T;
    cout<<sum<<endl;
    return 0;
}

```
~~OJBK~~没问题
AC 其实可以自己写个函数但是懒得了
祝小伙伴们都能顺利ac～

---

## 作者：jiangXxin (赞：6)

看了一下，这题还没有Python的题解.我来发一个

题目应该说得非常清楚了，我们就是要统计津津快乐的天数，所以相邻的时间间隔大于t，那么只能高兴t天，否则就可以在两次AK的时间段内一直开心。

**思路**：记录每一次AK时间与上一次AK时间的时间差，按照题意判断即可

**code:**

```python
a=input().split()
n=int(a[0])
t=int(a[1])

a=input().split()
st=int(a[0])
ans=0
for i in range(1,n):
    c=int(a[i])
    d=int(c-st)#得到在上一次到这一次，津津可以高兴的天数
    st=c
    if d>=t :
        ans+=t
    else :
        ans+=d

ans+=int(t)#最后一次AK后可以高兴T天
print(ans)

```


---

## 作者：hsfzLZH1 (赞：6)

看到楼下的大佬使用了并查集，我想为什么要用这么麻烦的方法，直接O(N)扫一遍就好了，时间复杂度等于O(输入)。

考虑每个津津高兴的段，都是[t[i],t[i]+T)，如果两个高兴的段有重合的部分，只需要减去重复的部分就好了。

假如有两个津津高兴的段有重合，这两个段分别为[t[i],t[i]+T)，[t[j],t[j]+T)，重合部分一定为[t[i]+T,t[j])，重复部分的长度一定为t[j]-t[i]+T；同理可得，如果两个形如[t[i],t[i]+T]，[t[j],t[j]+T]的段没有重合部分，那么t[i]+T<=t[j]。

根据以上推出的两个性质，我们可以得出以下代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=200010;
typedef long long ll;//由于此题数据范围的特殊性，存储变量为了保险一定要用long long数据类型
ll n,t,a[maxn],ans;//a可以转化成单个变量，因为每次计算都只用当前天和上一次高兴的天，空间复杂度可以降低为O(1)
int main()
{
    scanf("%lld%lld",&n,&t);
    if(!n||!t){printf("0\n");return 0;}//需要特判n或t为0的情况，因为如果我这样写会输出错误的答案
    for(int i=1;i<=n;i++)scanf("%lld",a+i);
    ans=t;//第一次高兴肯定全部天数覆盖
    for(int i=2;i<=n;i++)
    {
        if(a[i]>=a[i-1]+t)ans+=t;//不相交
        else ans+=t-a[i-1]-t+a[i];//相交
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_ZZH (赞：2)

表示这道题是不需要数组的，每个比赛间隔中的高兴天数只与这间隔有关，当Δt<=T,总时间就加上间隔时间，否则加T。我们记录上一场比赛在什么时候，就可求出时间间隔。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int n;
int t,before;//before是上一场比赛的发生时间 
long long ans;//记录答案 
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);//当前比赛时间 
		if(!before)//第一场比赛没有上一场 
		{
			before=x;
			continue;
		}
		if(x-before<=t)//Δt<=T
		ans+=x-before;
		else
		ans+=t;
		before=x;
	}
	cout<<ans+t;//最后一场比赛也要延续T天 
}
```

---

## 作者：Stella_Yan (赞：2)

看了题目之后， 

心里第一反应就是暴力循环，

然后没想到可以过！

就是判断一下下一次拿Au的时间与这次的时间差是否大于t，如果是就加上t，不是就加上它们的差。

贴代码：
```cpp
#include<iostream>
#define ll long long//数据太大要用long long
using namespace std;
int main()
{
    ll n,t,hpd=0;//hpd用来统计开心天数，赋值0
    ll a[200010];
    cin>>n>>t;
    for(ll i=1;i<=n;i++)
        cin>>a[i];
    a[n+1]=999999999999999;//赋值这么大是因为等下防止最后一次出现误判
    for(ll i=1;i<=n;i++)//暴力循环
    {
        if(a[i+1]-a[i]<t)//如果天数小于t，就加上它们的差
        {
            hpd+=a[i+1]-a[i];//下次拿Au的时间与这次的时间差
        }
        else 
        {
            hpd+=t;//如果时间差大于t，就直接加上t好了
        }
    }
    cout<<hpd;//输出
}

```

---

## 作者：insilent (赞：2)

```cpp
`#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
    int n,t;
    cin>>n>>t;
    int head=0,tail=0,ans=0,a;//定义头和尾，头为开始天，尾为结束天
    for(int i=0;i<n;i++)
    {
        cin>>a;
        if(a<=tail)//如果a在时段内
        {
            tail=a+t;//结束天向后推迟
            continue;
        }
        else{
            ans+=tail-head;
            head=a;
            tail=a+t;
        }
    }
    cout<<ans+tail-head;
    return 0;
}`
```

---

## 作者：CandyCandyFruit (赞：1)

这道题我刚开始用一种很~~高级~~笨的方法来做：

```cpp
#include<bits/stdc++.h>
int main()
{
	int n,t,q,k=0,s=0;//q,标记。k,高兴值。s,高兴累积天数
	scanf("%d%d",&n,&t);
	int a[n+1];
	for(int i=1;i<=n;i++)
	    scanf("%d",&a[i]);
    for(int i=1;i<=a[n]+t-1;i++)
    {
    	q=0;
    	for(int j=1;j<=n;j++)
    		if(a[j]==i)
    		    q=j;//寻找获奖的那天
    	if(q>0)//如果这天有获奖
    		k=t;//她就会happy满满
    	if(k>0) s++;//如果她今天高兴，累积天数加一
    	k--;//今天过去了，高兴值减一
	}
	printf("%d",s);//输出累积天数
}
```

## 出现了！绿色的AC

有四个，以及TLE有六个。

我：~~wtf~~时间超了？

于是我又改了改代码：-（

```cpp
#include<bits/stdc++.h>
int main()
{
	int n,t;
	scanf("%d%d",&n,&t);
	int a[n+1],s=n*t;//先计算无重叠天数的高兴值
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=2;i<=n;i++)//从二开始，防止错误
	if(a[i]-a[i-1]<t) s-=t-(a[i]-a[i-1]);//如果天数重叠，减去重叠天数
	printf("%d",s);//输出
}
```

最后A了：-D 太不容易了我

~~这什么题啊这是，连个**循环嵌套**都不让用~~

---

## 作者：Sinwind (赞：1)

# 1.分析

1. 本题中：每一次处理的比较只需要用到前后两次比赛时间，用$last\_day$存储上次比赛时间，$recent\_day$存储本次比赛时间即可，不需要用数组。


2. 循环中：

- 若高兴时间有重合$(recent\_day<=last\_day+t-1)$，只需要加上本次比赛与上次比赛时间之间的高兴时间$(total\_days+=recent\_day-last\_day)$，本次比赛的高兴时间下次循环计算。

- 若高兴时间未重合，加上高兴持续时间$t(total\_days+=t)$。

- 注意：循环中未计算最后一次比赛的高兴时间，需在循环外格外计算$(total\_days+=t)$。

# 3.代码

```cpp
#include <iostream>

using namespace std;

int n;              //参赛天数
int t;   			//持续天数
int last_day;       //上次参赛时间
int recent_day;     //本次参赛时间
int total_days;		//累计开心天数

int main(void)
{
	cin >> n >> t;
	cin >> last_day;
	while(n--)
	{
		cin >> recent_day;
		if(recent_day <= last_day + t - 1)
		{
			total_days += recent_day - last_day;
		}
		else
		{
			total_days += t;
		}
		last_day = recent_day;
	}
	total_days += t;

	cout << total_days;
	
	return 0;
}
```


---

## 作者：王钰翔 (赞：1)

# 本题关键:去重
## 具体实践:当有两段或n段高兴的时间相交时,应剪去重叠时间(两天总的高兴时间-(第[i]天-第[i-1]天)）即可得出。
**Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int last,now;
int n,t;
int sum;
int main() {
	cin>>n>>t;
	cin>>last; //保证第一次有数判断
	for(int i=1; i<n; i++) {
		cin>>now;
		if(now-last<t) { //有重复要减去
			sum+=now-last;
		}else { //未重复直接加
			sum+=t;
		}
		last=now; //重新赋值(可省用数组)
	}
	cout<<sum+t;
}
```


---

## 作者：米奇奇米 (赞：1)

```cpp
   这道题目我们这样去想：那些日子是不能直接加上高兴累计天数的：
   比如样例中的第二天，是不能加上持续时间的，但是同时得加上上升的天数
  （看样例：第二天比第一天迟一天获得AU，此时不能直接加上5，应该加上1（即2-1））。
  这样理解的话，看一下代码：
#include<bits/stdc++.h>//万能头
using namespace std;
long long  a[200001]; 
int main()
{
	int n,t,s=0,ans=0;//s累计在（0—t之内迟的天数），ans累计要乘上T的天数。
	cin>>n>>t;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	for(int i=1;i<=n-1;i++)
		if(a[i+1]-a[i]<t) //如果持续时间在T之内
		{
		   s+=a[i+1]-a[i];
		   ans++;
		} 
	cout<<t*(n-ans)+s<<endl;//只要按照题意计算即可
	return 0;
}
	
	
```

---

## 作者：沧海映繁星 (赞：1)

第一次写题解，请大神们别笑
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()//头文件不做解释 
{
	long long n,s=0,l=0,t,a;
	//n：天数 s：总天数 l：高兴的最后一天 t:每次高兴的天数  a:得奖的日期 
	cin>>n>>t;
	//输入天数和高兴时间 
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a>l) s+=t;  
		//判断：若a>l即天数与之前不重复，直接相加 
		if(a<=l) s+=t+a-1-l;   
		//判断：若a<=l即天数与之前重复，去重后相加 
		l=a+t-1;
	}
	cout<<s;//最后完美输出 
	return 0;
}
```
题目不难，数学好的同学们很容易理解

---

## 作者：ztz11 (赞：1)

#先看数据范围，发现到了10^9，太大，不可能暴力，

##那就用头尾两个范围限制一下吧，纯模拟

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,t,cnt,tzz,wzz,s;
int main()
{
    cin>>n>>t;//输入数量和高兴天数
    for(int a=1;a<=n;a++)
    {
        cin>>s;//输入第a天是哪天
        if(s<=wzz)
        {
```
###重点判断来了
cnt=cnt+s+t-wzz;//如果第a天被包含在高兴的天数内，则只加多高兴的天数

```cpp
        }
        else
        {
            cnt=cnt+t;//如果不在，则加整个t天
        }
        wzz=s+t;//尾指针移动
    }
    cout<<cnt;
}
```

---

## 作者：星灵王 (赞：1)

先看范围1<=N<=200000，1<=T,t\_i<=10^9

这道题如果像校门外的树一样用桶排的n2来做一定会时间超限

只能是n或者n log n

大家可以用下面大佬一样的神算法

但作为一名蒟蒻，我用了单纯的模拟

复杂度n就够了

如果两场比赛的间距>t，ans就加上t

否则就加上两段的距离（不用怕超出，因为后面会加上）

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,t,t1,t2,ans=0;    //记得开long long 
    //省内存，不用数组了，只用两个变量t1,t2表示前一个和当前的位置 
    cin>>n>>t;
    if(n==1)//这个最好加，不加也行 
    {
        cout<<t<<endl;
        return 0;
    }
    cin>>t1;//输入上一个 
    for(int i=1;i<=n-1;i++)
    {
        cin>>t2;
        ans+=min(t2-t1,t);//选取两个中最小的 
        t1=t2;        //把这一次输入的变成上一个 
    } 
    cout<<ans+t<<endl;
    return 0;
} 

```

---

## 作者：览遍千秋 (赞：1)

2017年11月月赛题T1。可能是为了测试新的CF赛制，题目水了点？但我T2没看见数据范围暴力被叉了。

---
这道题可以在线搞，详见代码注释：

```cpp
#include<iostream>
#include<cstdio>

using namespace std;
int n,t,l,x,ans;


inline void Init()
{
    scanf("%d%d",&n,&t);//读入
}
inline void Work()
{
    scanf("%d",&x);//初始化
    l=x;
    ans=t;//只要有Au就至少t天，我采用下一次Au后结算上一次Au高兴天数的方法。
    for(register int i=1;i<n;i++)
    {
        scanf("%d",&x);//读入这个Au的时间
        if(x>l+t)//如果和上次Au不在同一个高兴时间段内
        {
            l=x;//记录Au时间
            ans+=t;//结算上次高兴的时间
        }
        else
        {
            ans+=(x-l);//结算上次高兴的时间
            l=x;//记录
        }
    }
    printf("%d\n",ans);//输出
}
int main()//华丽的主函数
{
    Init();
    Work();
    return 0;
}
```

---

## 作者：Scarlet_Hypoc (赞：1)

纯模拟就好啦

用j记录目前会开心到第几天

ans记录总共开心了几天

把得了au的天数过一遍，如果和之前开心的天数重合，那么ans就加(t\_i+T-1)-j （额外开心的天数），否则就ans+=T，表示开心了T天，然后j=t\_i+T-1（- 1 是因为得了au的那一天也会开心，要减掉）

最慢的点为20ms





```cpp
#include <cstdio>
#include <cstring>
int n,m;
int ans(0),j;
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        if(i==1)//特判一下
        {
            j=x+m-1;
            ans+=m;
            continue;
        }
        if(j<x)j=x+m-1,ans+=m;//不重合
        else//重合
        {
            ans+=(x+m-1)-j;
            j=x+m-1;
        }
    }
    printf("%d",ans);
}
```

---

## 作者：Deep_Kevin (赞：1)

题意：给出n个区间，求它们并集的总长度。

首先注意：**区间可以重复**

#所以要用begin和end来模拟区间

区间纯模拟看看数据可以过

##每次将end更新知道不包含为止

##最后如果不包含则tot+=begin-end+1;

##注意一定要初始化

\*祝大家好运

上代码


黄金分割线

————————**——————————



```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
int n,t;
int main()
{
    scanf("%d %d",&n,&t);
    int tot=0;
    int begin,end;
    scanf("%d",&begin);
    end=begin+t-1;
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        if(x<=end) end=x+t-1;
        else
        {
            tot+=end-begin+1;
            begin=x;end=x+t-1;
        }
    }
    tot+=end-begin+1;
    printf("%d",tot);
}
```

---

## 作者：夜雨声烦hst (赞：1)

这道题不难，最重要的是自己的数据分析，我做的比较简单，其实你可以分析一下数据，如果说获奖时间之间的差距是大于t的，那么这里的高兴的天数总数就是t，但是如果说之间的差距是小于t的那么，他们之间的差就是高兴地天数（这个自己列两个数据就可以证明了）

最重要的一点是，用for循环的时候会查到ii+1次，要多赋一个值。下面是我的代码，大家可以看看。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int fuc[10000001];    //注意数组的大小，因为原题大小很大。
int sum=0;
int main()
{
    int n,t;
    cin>>n>>t;
    for(int i=1;i<=n;++i)   
    {
        cin>>fuc[i];
    }
    fuc[n+1]=fuc[n]+t;//记得给最后一个位置赋值。
    for(int ii=1;ii<=n;++ii) //核心代码，分两种一种大于，一种小于。
    {
        if(fuc[ii+1]-fuc[ii]>=t)
        {
            sum=sum+t;
        }
        else
        {
            sum=sum+fuc[ii+1]-fuc[ii];
        }
    }
    cout<<sum;//输出。
} 
```
但不知道这道题为什么通过率这么低。。。
支持珂学！

珂朵莉太可爱了。


---

## 作者：sycqwq (赞：0)

__这题很简单__

难点就在 __时间重叠__,只要仔细想一想，就可以发现，如果时间重叠,加上的时间就不t，而是这个时间-上一次的时间，如果差大于t，就代表没有时间重叠，直接加t即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,t,a[200005],s=0;
	cin>>n>>t;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(i==1)//如果是第一个输入，就直接加t
			s+=t;
		else{
			if(a[i]-a[i-1]>t)//判断是不是没有时间重叠
				s+=t;
			else
				s+=a[i]-a[i-1];//时间重叠的情况
		}
	}
	cout<<s;
	return 0;
}

```

---

## 作者：SampleTest518 (赞：0)

   一道普及-的题目开始还没看懂题意（语文的重要性）。简单来说本题就是求有多少天津津会开心，而重复的当然只能算一次。因为已经保证数列单调递增，所以只需判断后一次离这一次之间相隔的天数是否超过t，如果超过了则不存在重叠天数所以直接ans累加t，如果超过了则ans累加差值，但是要注意最后一次出现拿奖是不存在重叠的天数（显然因为后面没有再拿奖了），所以要记得ans累加上t。输出ans，完美解决了。最快3ms。
  下面献上我写的代码：
  ```cpp
#include<cstdio>
using namespace std ;
int n,t,a[200005];
int main()
{
     scanf("%d%d",&n,&t);
     for(int i=1;i<=n;i++)scanf("%d",&a[i]);//输入
     int ans=0;//统计
     for(int i=2;i<=n;i++)
     if(a[i]-a[i-1]>t)ans+=t;
     else ans+=a[i]-a[i-1];
     printf("%d\n",ans+t);//输出
     return 0;
}
```
如果使用快读的话，代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std ;
 int read(){
    int a=0,k=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')k=-1;c=getchar();}
    while(isdigit(c)){a=a*10+c-'0';c=getchar();}
    return a*k;
}
int n,t,a[200005];
int main()
{
     n=read();t=read();
     for(int i=1;i<=n;i++) a[i]=read();
     int ans=0;
     for(int i=2;i<=n;i++)
     if(a[i]-a[i-1]>t)ans+=t;
     else ans+=a[i]-a[i-1];
     printf("%d\n",ans+t);
     return 0;
}
```
祝大家AC好运！<(￣︶￣)>

---

## 作者：chenjiarui (赞：0)

### 我最讨厌啰嗦的人，我只不过是一个橙名，大佬勿喷！！！代码如下：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,t;//定义N和T 
    cin>>n>>t;
    int a[n],b=0;//a[n]指的N天比赛中每场比赛的天数，b负责储存累积高兴次数 
    for(int i=0;i<n;i++)
    {
        cin>>a[i];//循环输入 
    }
    if(n!=0)//防止比赛天数出现零，如果出现零，就不会再添加T进去 
    {
        b+=t;//把第一天的高兴天数记住 
    }
    for(int i=1;i<n;i++)//注意：i是从1开始的 
    {
        int c=0;//作者习惯，便于后面操作，可以省去 
        c=a[i]-a[i-1];//给c定义内容 
        if(c>=t)//判断天数之差 
        {
            b+=t;
        }
        else
        {
            b+=c;
        }
    }
    cout<<b; 
    return 0;
}
```


---

## 作者：焚魂 (赞：0)

嗯哼嗯哼，我的思路可能跟大家的不太一样。
个人觉得，我的思路偏向于
# 数学
好啦，说下我的思路。定义一个ans变量为0，然后先假设所有的高兴日期加上持续时间都不重复，然后再一个一个减去重复的就好啦！！！
口说无凭可不好，下面是我的coding：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	int a[200010];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int ans=0;
	ans=n*m;
	for(int i=1;i<n;i++)
	{
		if(a[i+1]-a[i]<=m)
		{
			ans-=(m-(a[i+1]-a[i]));
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：liujiayuan (赞：0)

### 很简单的一道模拟水题，加个简单的判断就好了
    #include<iostream>
    using namespace std;
    int main()
    {
        ios::sync_with_stdio(false);
        //加这个，取消cin与stdin的同步，这样cin就和scanf一样快了
        long long n,t,q[200005]={0},ans=0;
        cin>>n>>t;
        for(int i=0;i<n;i++)
        {
            cin>>q[i];
        }
        for(int i=1;i<n;i++)
        {
            long long mid=q[i]-q[i-1];
            ans=ans+min(mid,t);
            //判断，没什么好说的，哪个小加哪个就是了
        }
        cout<<ans+t<<endl;
        //别忘了加上t，之前的循环中没加，而且最后一天无论怎样都会快乐t天
        return 0;
    }

---


# [COCI 2017/2018 #1] Cezar

## 题目描述

小凯撒喜欢玩纸牌游戏，每次他去萨格勒布（克罗地亚的首都 ——译者注）都会和他的朋友们玩 $21$ 点，这是一种很流行的纸牌游戏。

这个游戏的规则是，在纸牌点数之和小于 $21$ 点之前可以连续抓牌，如果决定不抓牌，则喊 `DOSTA`（克罗地亚语“停止”的意思）。

游戏开始时，桌面有 $52$ 张牌 —— $13$ 种不同牌面的牌，每种有 $4$ 个花色。牌面分别是 $2,3,\dots,\text J,\text Q,\text K,\text A$。它们的点数计算规则是：牌面上的数字就是点数（比如，$9$ 的点数就是 $9$），特殊地，$\text J,\text Q,\text K$ 都算 $10$ 点，$\text A$ 算 $11$ 点。

凯撒认为游戏的乐趣在于，当抓了 $N$ 张牌之后，如果点数之和小于或等于 $21$，他就要思考是否要再多抓一张。假设 $X$ 是已抓牌点数之和与 $21$ 之间相差的点数值，我们知道，如果桌面上的剩余牌中点数大于 $X$ 的纸牌数量比小于等于 $X$ 的纸牌数量要多，或两者一样多，那就不应该再抓牌了。

因为凯撒并不擅于计算是否需要抓牌，所以他请你帮他计算和决策。

## 样例 #1

### 输入

```
6
2
3
2
3
2
3
```

### 输出

```
DOSTA ```

## 样例 #2

### 输入

```
1
10
```

### 输出

```
VUCI```

## 样例 #3

### 输入

```
2
5
6```

### 输出

```
VUCI```

# 题解

## 作者：Qing_s (赞：13)

## P4419
比较水~~特别水~~的模拟题，~~虽然我调了15分钟~~。

让我们先分析一下题意：
>牌库中有52张卡牌，每张卡牌有范围在1-11内的数值，除数值为10的卡牌共有16张外，其余每种数值的卡牌各有四张。

这段话很好理解，但是请注意：
>#### 除数值为10的卡牌共有16张外，其余每种数值的卡牌各有四张。

也就是说，10有16张，其他的每个有4张。
那我们就可以这样初始化：
```cpp
for( int i = 1 ; i <= 15 ; i++ )
		poker[i] = 4 ;
	poker[10] = 16 ;
```


~~我才不会告诉你我因为这个被卡了10分钟。~~

继续往下看
>我们设X为拿到的牌的数值之和与21的差，那么很显然当牌库中数值大于X的牌的数量大于或等于牌库中数值小于或等于X的牌的数量时，游戏结束。

那么我们可以知道，我们的目的是要求出牌库中大于 X 的牌的数量，然后与 52-X 相比较，就可以解出本题！同时要注意，是 __大于或等于__ ，作为一道pj-的题目，并没有太大的思维难度，只是要注意细节。

如此，我们就可以变输入边得出 X 的值和我们每种卡牌所剩的张数：
```cpp
for( int i = 1 ; i <= n ; i++ ){
		cin >> k ;
		x -= k ;
		poker[k]-- ;
	}
```
注意： X 的初值赋为21。

我们接下来要进行的步骤也就很明显了：
1. 判断大于 X 的牌的数量
1. 进行比较并得出答案

首先判断大于 X 的牌的数量。
```cpp
for( int i = x + 1 ; i <= 11 ; i++ )
			sum += poker[i] ;
```
从 X+1 开始往后都是大于 X 的卡牌。只要累计加入 sum 即可。

最后进行判断：
```cpp
if( sum >= 52 - sum )
		cout << "DOSTA" ;
	else
		cout << "VUCI" ;
```
就可以顺利的 AC 了！


------------

[关于一个菜鸡调了10分钟的故事。](https://cdn.luogu.com.cn/upload/image_hosting/kjqujipf.png)



---

## 作者：美琴 (赞：7)

[这道题](https://www.luogu.org/problemnew/show/P4419)个人认为审题和分析题意最关键！~~本juruo理一句话理了3分钟~~
QAQ
~~剩下的就是模拟大水题了~~

让我们先来看看题：

>牌库中有52张卡牌，每张卡牌有范围在1-11内的数值，除数值为10的卡牌共有16张外，其余每种数值的卡牌各有四张。在游戏中，玩家可以不断抽牌，直到手中所有牌的数值相加的和大于21为止。当手牌的数值的和大于21时，游戏结束。

嗯，到这里为止都还很好理解呢...

然后：

>我们设X为拿到的牌的数值之和与21的差，那么很显然**当牌库中数值大于X的牌的数量大于或等于牌库中数值小于或等于X的牌的数量**时，游戏结束。

>现已知已经抽了N张牌，并且知道每一次抽的牌的数值a[i]（保证a[1]+a[2]+...+a[N]小于等于21），问是否能够继续抽牌。

(黑人问号.jpg)什么鬼？？？

让我们来分析一下：因为我们要使手牌的数值的和大于21，所以如果已经告诉了你每一次抽的牌的数值，那么拿到的牌的数值之和与21的差（也就是X）就可以算出来。为了让抽到的牌的数值之和不超过21，我们就只能抽小于等于X的牌。英语原文当中所说的是这个人要玩“[黑杰克](https://baike.baidu.com/item/21%E7%82%B9/5481683)”的赌博游戏。（也就是俗称的21点）

>该游戏由2到6个人玩，使用除大小王之外的52张牌，游戏者的目标是使手中的牌的点数之和不超过21点且尽量大。		——摘自度娘

那么作为赌博游戏，当然要以赢的概率作为基础！所以当牌库中数值大于X的牌的数量大于或等于牌库中数值小于或等于X的牌的数量时，输的概率会更大！（也就是说再抽一张会超过21点的概率大于二分之一）

~~吐槽：译者并没有翻译这一点~~

所以现在就可以~~偷税~~愉悦地打代码了～～～

这是第一次我的代码：
```cpp
#include <iostream>
using namespace std;
int temp,a,i,n,x,c[12]={0,4,4,4,4,4,4,4,4,4,16,4};//c的意思是card，用来存储不同价值的牌的初始数量
int main()
{
    cin>>n;
    for(i=0;i<n;++i)
    {
        cin>>a;//输入当前的牌的价值
        temp+=a;//temp值累加，最后代表总值
        c[a]--;//牌库对应牌数相减
    }
    x=21-temp;//如题，X为拿到的牌的数值之和与21的差
    temp=0;//初始化为下面循环利用
    for(i=1;i<=x;++i)
        temp+=c[i];//temp值累加，最后代表牌库中数值小于或等于X的牌的数量
    if(temp*2>=52-n)//这里由temp>=(52-n)/2变形而成，避免了奇数/2的尴尬局面
        cout<<"VUCI";
    else
        cout<<"DOSTA";
    return 0;
}
```
不过我这次只得了91分。15，17，28这三个点却死活过不去
[评测详情](https://www.luogu.org/recordnew/show/16647162)

检查了一下代码，才发现最后判断出了点锅
```cpp
 if(temp*2>=52-n)//就是这里，不该有‘=’。
```
所以就把代码改了 [评测详情](https://www.luogu.org/recordnew/show/16647342)
~~然而28仍然过不了！~~

想了半天，我终于发现：最后一个循环中不应该从一开始循环，而该从二开始。下面是完整代码：
```cpp
#include <iostream>
using namespace std;
int temp,a,i,n,x,c[12]={0,4,4,4,4,4,4,4,4,4,16,4};//c的意思是card，用来存储不同价值的牌的初始数量
int main()
{
    cin>>n;
    for(i=0;i<n;++i)
    {
        cin>>a;//输入当前的牌的价值
        temp+=a;//temp值累加，最后代表总值
        c[a]--;//牌库对应牌数相减
    }
    x=21-temp;//如题，X为拿到的牌的数值之和与21的差
    temp=0;//初始化为下面循环利用
    for(i=2;i<=x;++i)
        temp+=c[i];//temp值累加，最后代表牌库中数值小于或等于X的牌的数量
    if(temp*2>52-n)//这里由temp>(52-n)/2变形而成，避免了奇数/2的尴尬局面
        cout<<"VUCI";
    else
        cout<<"DOSTA";
    return 0;
}
```
[评测记录](https://www.luogu.org/recordnew/show/16648087)

---

## 作者：起名字重要吗 (赞：5)

题意：

- 牌堆里有52张牌，1~11，其中只有10有16张，其余都是4张。

- 每次可以从牌堆里抽牌，当手中的牌总和大于21或（当牌库中数值大于 $X$ 的牌的数量） $≥$ （牌库中数值小于等于 $X$ 的牌的数量）时，游戏结束。

- 现在给出你手中都有哪些牌，求游戏能否继续。

思路：

1. 计算数值大于 $X$ 的牌的数量和牌库中数值小于等于 $X$ 的牌的数量。

1. 比较两者大小，输出结果。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt1,cnt2,t,n,x=21,a[12]= {0,4,4,4,4,4,4,4,4,4,16,4};
int main() {
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>t,x-=t,a[t]--;
	if(x<1) {
		cout<<"DOSTA";
		return 0;
	}
	for(int i=1; i<=x; i++) cnt1+=a[i];
	for(int i=x; i<=11; i++) cnt2+=a[i];
	if(cnt1>cnt2) cout<<"VUCI";
	else cout<<"DOSTA";
	return 0;
}
```
求管理大大给过！

---

## 作者：wrehtg (赞：4)

二话不说 直接模拟233333

原题传送门[]()
	
    #include <iostream>
	using namespace std;
	int s,a[12]={0,0,4,4,4,4,4,4,4,4,16,4};//每种价值的牌的个数
	int main(){
		int n,m,t,i;
		cin>>n;
		m=52-n;//剩下的牌数
		while(n--)
		{
			cin>>t;
			s+=t;//手中总和，累加
			a[t]--;//用掉一张
		}
		int k=21-s,p=0;
		for(i=0;i<=k;i++)//手中总和加上抽到的牌不大于21即可，可以的牌大于一半就可以抽牌（不考虑取等也避免了奇数除二的问题）
			p+=a[i];
		if(p>m/2) cout<<"VUCI";
		else cout<<"DOSTA";
		return 0;
	}
  

---

## 作者：dblark (赞：3)

此题坑啊……~~恐怕是我太弱了一直不过~~

模拟大水题。

献上Pascal代码：

```pas
{P4419}
var
  a:array[2..11]of longint=(4,4,4,4,4,4,4,4,16,4);//原有的牌的数量
  n,i,x,t,s:longint;
function min(x,y:longint):longint;
begin
  if x<y then
    exit(x)
  else
    exit(y);
end;
begin
  read(n);
  t:=0;              //计算手中总和
  for i:=1 to n do
  begin
    read(x);
    inc(t,x);
    dec(a[x]);       //丢牌
  end;
  s:=0;          
  for i:=2 to min(11,21-t) do//总和不大于21就可以了，坑：注意越界
    inc(s,a[i]);
  if s>(52-n) div 2 then//可以的牌大于一半就可以抽牌
    writeln('VUCI')
  else
    writeln('DOSTA');
end.
```

---

## 作者：BlueSu (赞：2)

写完翻了翻题解，发现我的思路有些繁琐，和其它题解不太一样，但是非常容易看懂。

首先理解一下题意：

- 牌堆里有52张牌，种类1~11，其中只有10有16张，其余都是4张。

- 每次可以从牌堆里抽牌，当手中的牌总和大于21，游戏结束（其实这条没什么用）。

- （当牌库中数值 大于 X的牌的数量） 大于等于 （牌库中数值 小于等于 X的牌的数量）时，游戏结束。

- 现在给出你手中都有哪些牌，求还能否继续游戏。

都非常好理解，除了第三条。这里建议大家用草稿纸理清关系。下图是我的草稿（有2个错别字别在意）：

![image.png](https://i.loli.net/2020/10/02/ckKjD73qsbJBzvn.png)

下文中将会用到此图中的变量。

接下来模拟样例，题目给出了解释：手中牌的和为15（N），差为6（X），大于X的牌有32张（M），小于等于X的牌有14张（K），32 > 16（M > K），游戏结束。

也就是说，只需要知道M和K就能得出答案了。

我的思路是用 该种牌的总张数 减去 该种牌已经在手里的张数 求和得到M和K，要记得特判10这类牌。

这个思路貌似效率还挺高的，是[第三个最优解qaq ](https://www.luogu.com.cn/record/list?pid=P4419&orderBy=1&status=&page=1 )。

上代码，其中hand表示在 手里的牌总和 ，a数组用于存放 已经在手里的牌的类别。其它都一样。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <climits>
using namespace std;

int m , k , x , n , hand ;
int a[100] ;

int main () {
	
    // input
    scanf ( "%d" , &n ) ;
    for ( int i = 1 ; i <= n ; i++ ) {
        scanf ( "%d" , &a[i] ) ;
        hand += a[i] ; // make sum
    }

    x = 21 - hand ; // make minus
	
    // calculate m
    for ( int i = x + 1 ; i <= 11 ; i++ ) {
        if ( i == 10 ) { // don't forget specialjudgement of 10
            m += 16 - a[i] ;
        }
        else {
            m += 4 - a[i] ; // other kinds
        }
    }
	
    // calculate k
    for ( int i = 1 ; i <= x ; i++ ) {
        k += 4 - a[i] ;
    }
	
    // like problem description & output
    if ( m >= k ) {
        printf ( "DOSTA" ) ;
    }
    else {
        printf ( "VUCI" ) ;
    }

    return 0 ;
}
```

做一个小结，其实这道题并不难，主要在理解题意。当没有理解题目时或题面非常复杂时，要用纸笔减轻大脑运算负荷，这样做有助于理解题目。

---

## 作者：苏黎世 (赞：1)

### 此题算是一个很水的模拟题，可以帮我们提升刷题量。

首先，用一个数组来存每个牌数量。

```cpp
int ca[12]={0,4,4,4,4,4,4,4,4,4,16,4};
```
ca[i]就是第i张牌的数量。

我们要算出现有牌的总和sum与21的差（注意绝对值）。

再看看大于等于和小于这个差的牌各有多少张。如下：

让res1是小于等于的，res2是大于的。

```cpp
X = abs(sum - 21);
for(int i = 1;i <= X; ++i)
  res1 += ca[i];
for(int i = X + 1;i <= 11; ++i)
  res2 += ca[i];
```

再下来就是输入，不过会发现我们不需要对已经抽的牌进行储存，因为它计算后就没有用了。

如下：

```cpp
scanf("%d", &n);
for(int i = 1;i <= n; ++i)
{
	scanf("%d", &num);
	ca[num] --;
	sum += num;
}
```


最后再看看res1与res2的比较结果即可。

```cpp
if(res2 >= res1)
  puts("DOSTA");
else
  puts("VUCI");
```

这里的puts用于输出一个字符串，并且自动输出一个换行，不用手动打'\n'。

是不是非常简单？

---

## 作者：废物yehan (赞：1)

水题，啥都不用注意```
```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
int s[N];
int sum;
int d[N];
int s1;
int s2;
int main()
{
//	freopen("cezar.in","r",stdin);
//	freopen("cezar.out","w",stdout);
 	int n;
 	cin>>n;
	for(int i=2;i<=11;i++){
 		d[i]=4;
 	}	
	d[10]=16;
 	for(int i=1;i<=n;i++){
 		cin>>s[i];
 		d[s[i]]--;
 		sum+=s[i];
 	}
 	int x=21-sum;
 	for(int i=x+1;i<=11;i++){
 		s1+=d[i];
 	}
 	for(int i=x;i>=2;i--){
 		s2+=d[i];
 	}
 	if(s1<s2){
 		cout<<"VUCI"<<endl;
 		return 0;
 	}
 	else{
 		cout<<"DOSTA"<<endl;
 		return 0;
 	}
	return 0;
}

```

---

## 作者：Eason_AC (赞：0)

## Content
有一个牌库，有一些点数为 $1\sim 11$ 的牌，其中除了点数为 $10$ 的牌有 $16$ 张之外，其余点数的牌各有四张。现在玩一个游戏，已经拿出了 $n$ 张牌。游戏能够继续进行，需满足：

- 当前牌的点数和 $S\leqslant 21$。
- 设 $x=21-S$，牌库剩余的牌中点数 $>x$ 的牌的数量 $<$ 点数 $\leqslant x$ 的牌的数量。

问游戏能否继续进行。

**数据范围：$1\leqslant n\leqslant 52$。**
## Solution
我们分几个部分进行：

第一部分，初始化当前牌的数量。这里应该很容易实现，故不再赘述。

第二部分，读入 $n$ 张牌的点数，每读入完一张牌的点数，记录点数和 $S$，并将相应点数的牌的数量减 $1$。

第三部分，判断 $S$ 是否 $>21$，如果大于 $21$ 游戏就不能进行了，跳出程序。否则，继续统计剩余牌中点数 $>x$ 的牌的数量和点数 $\leqslant x$ 的牌的数量，并进行比较，若前者大于后者，则根据题目要求，游戏也是无法进行的，否则可以继续游戏。

这道题的翻译是不是没解释的太清楚啊……![yun](https://cdn.luogu.com.cn/upload/pic/62240.png) 但是读懂题目之后思路还是不难想的。
## Code

```cpp
int n, sum, x, a[57], cur[17], num1, num2;

int main() {
	F(i, 1, 11) cur[i] = (i == 10 ? 16 : 4);
	n = Rint;
	F(i, 1, n) sum += (a[i] = Rint), cur[a[i]]--;
	if(sum > 21) return printf("DOSTA"), 0;
	x = 21 - sum;
	F(i, 1, 11) {
		if(i <= x) num2 += cur[i];
		else num1 += cur[i]; 
	}
	return printf(num1 >= num2 ? "DOSTA" : "VUCI"), 0;
}
``

---

## 作者：TLMPEX (赞：0)

这是道很水的模拟，适合新手练习，思路主见代码。

代码：
```c
#include<bits/stdc++.h>
using namespace std;
int vis[20];
int main(){
	int n,i,k,x,sum=0,small=0,big=0;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>k;
		sum+=k;//累加总和
		vis[k]++;//表示已抽数值为k的牌数加一
	}
	x=21-sum;
	for(i=1;i<=11;i++){//数值从1~11循环
		if(i<=x){
			if(i!=10)small+=4-vis[i];//如果不是10，则用4减去已抽数值为i的数量
			else small+=16-vis[i];//如果是10，则用16减去已抽数值为10的数量
		}
		else{//与上同理
			if(i!=10)big+=4-vis[i];
			else big+=16-vis[i];
		}
	}
	if(big<small)cout<<"VUCI";
	else cout<<"DOSTA";
}
```


---

## 作者：Creroity (赞：0)

**直接进入正题吧！**

这是道模拟题，标签已经写了呢~

所以我们只用按照题目的话一句句打代码就行啦！

因为我们需要计算**数值大于 $ X $ 的牌的数量**和**牌库中数值小于或等于 $ X $ 的牌的数量**，而且输入时已经直白地说了取的牌。

所以我们其实就不需要再把 $ X $ 储存起来了，只用边数边计算剩下的此类牌的数量就可以了。

```cpp
int c;    //暂时定一个变量用来输入 
for(int i=1;i<=n;i++){
	cin>>c;//输入
	a[c]--;//将剩下的牌总数-1 
	X-=c;  //计算此时手中牌数值总数离21还剩几 
}
```
然后就计算大于 $ X $ 的牌的数量和小于等于 $ X $ 的牌的数量，可以用两个循环搞定。

因为 $ a $ 数组（记录编号为 $1 \sim 11$ 的牌剩余的数量）的下标为此牌的大小，所以可以直接枚举 $ X $ 前的数量和 $ X $ 后的数量。

```cpp
for(int i=1;i<=X;i++)tot1+=a[i]; //枚举X前的数量 
for(int i=X;i<=11;i++)tot2+=a[i];//枚举X后的数量 
```
主要就上上述的部分。

当然，还有一个特判，这里就不多讲了，见下方完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tot1,tot2,X=21;                //注意把X初始化成21 
int a[15]={0,4,4,4,4,4,4,4,4,4,16,4};//直接将1~11的牌数量赋值 
int main(){
	cin>>n;
	int c;
	for(int i=1;i<=n;i++){
		cin>>c;
		a[c]--;
		X-=c;
	}
	if(X<=0){         //虽然不加tot1还是会小于tot2 
		cout<<"DOSTA";//但是亲测不加会WA 
		return 0;     //并且会使测评机出一些奇怪的错误 
	}                 //导致AC代码WA两个点 
	for(int i=1;i<=X;i++)tot1+=a[i];
	for(int i=X;i<=11;i++)tot2+=a[i];
	if(tot1<=tot2)cout<<"DOSTA";//输出不多讲 
	else cout<<"VUCI";
	return 0;
}
```

---

## 作者：zhangzhaoke (赞：0)

水题一道，不知道为何没大佬来发题解，小蒟蒻来凑凑热闹

极短代码
```cpp
#include <iostream>
using namespace std;
int c,ans,n,k,a[12]={0,4,4,4,4,4,4,4,4,4,16,4};//每种牌的个数
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>k;
        c+=k;//手中目前的牌价值总和
        a[k]--;//用掉一张牌，一定要小心，不要漏了
    }
    for(int i=0;i<=(21-c);i++)ans+=a[i];
    if(ans>=(52-n)/2)cout<<"VUCI";
    else cout<<"DOSTA";
    return 0;
}
```

---


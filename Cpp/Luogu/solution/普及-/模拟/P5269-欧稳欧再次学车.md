# 欧稳欧再次学车

## 题目背景

请自行脑补一张欧稳欧学车的图

## 题目描述

欧稳欧学车时经常用一辆橡树车练习。这辆橡树车共有 $N$ 个挡位，欧稳欧每秒可以把挡位增加或减少 $1$，初始时（$0$ 时刻）挡位为 $1$。

这辆车的转速范围是 $[L,R]$，初始时转速为 $L$。每次升挡时，转速会变成 $L$；降挡时，会变成 $R$。欧稳欧在每秒也可以踩油门，让转速增加 $X$，再对 $R$ 取 $\text{min}$。如果转速连续 $K$ 秒都 $=R$，那么这辆车的发动机会停止工作，在这 $K$ 秒结束的一瞬间停下（即使 $K$ 秒中经历了降档操作，仍然算这种情况）。

这些操作我们认为都是在每秒开头的一瞬间进行的，其中换挡操作比踩油门操作先进行。而这一秒内这辆车前进的距离是 转速$\times$挡位。

现在给出欧稳欧练习时的操作序列，你需要求出他一共前进的距离是多少。

## 说明/提示

对于样例一：

第一秒挡位为 $2$，转速为 $6$；  
第二秒挡位为 $3$，转速为 $1$；  
第三秒挡位为 $3$，转速为 $6$；  
第四秒挡位为 $3$，转速为 $10$；  
第五秒挡位为 $2$，转速为 $10$。

对于样例二，前进两秒之后发动机就停止了工作。

对于 $30\%$ 的数据，没有挡位操作（即保证 $x=2$）；

对于另外 $30\%$ 的数据，没有踩油门操作（即保证 $y=0$）；

对于全部数据，保证 $1\le T,N,L,R,X,K\le 10^6,L\le R$。

## 样例 #1

### 输入

```
5 3 1 10 5 100
0 1
0 0
2 1
2 1
1 1```

### 输出

```
83```

## 样例 #2

### 输入

```
3 1 1 1 1 2
2 0
2 1
2 0```

### 输出

```
2```

## 样例 #3

### 输入

```
1 2 3 4 5 6
1 0```

### 输出

```
-1```

# 题解

## 作者：_Misaka_Mikoto (赞：23)

月赛题解！很激动，提交了五次终于AC了，原因居然是第一行cin六个变量后面两个反了，变量lr反了……反正就是一堆脑残原因，不过这道题还是很水，模拟的思路无优化按照思路写就能ac。

担心有人会跟我同思路，变量名字可能都是题目中复述的一样，怕棕名，声明一下。不过各位太强了，应该不会吧？

因为我高二才从化竞转来，多半靠自学，有偏差我会负责任，还请各位谅解!//也感谢指出

思路：T是时间，数据t+1行，n是档，lr是范围，xk就不解释了。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long t,n,l,r,x,k,tx,ty,v,nn=1,cak=0,sum=0;
int main(){
    cin>>t>>n>>l>>r>>x>>k;
    v=l;
    for(long long i=0;i<t;i++){
        cin>>tx>>ty;
        if(tx==0){//这个是输入的x，进入判断
        //x=0 表示升挡
       //x=1 表示降挡，
      //x=2 表示挡位不变
            v=l;nn++;//变速，先挂档再判断
            if(nn>n){cout<<"-1"<<endl;	return 0;}
        }else if(tx==1){//再判断x，降档情况
            v=r;nn--;//还是先变速挂档再判断 退出
           
            if(nn<1){cout<<"-1"<<endl;	return 0;}
        }
        if(ty){v+=x;if(v>r)v=r;}
        sum+=v*nn;//因为我定义nn，之前打成了n所以输出123不是83
        if(v==r){//
            cak++;//计数器 速度有变化再清空 否则达量降速
            if(cak==k){cout<<sum<<endl; return 0;}
        }else	cak=0;
    }
    cout<<sum<<endl;
    while(1);//不知道这句代码有什么用，据说抄了会AC
    //当然你ctrl+w也可以直接AC
    return 0;
}
```

这是我三月月赛2唯一一道做出来的题，因为太累了就先休息了

---

## 作者：UhhhQQQU (赞：10)

作者比赛心路：距离结束只有一小时的时候才加入战场，点开T1一看，哇！这不就是模拟嘛！

然后···

其实这题要注意细节的地方还蛮多的，我们来一个个列举一下

$1.$   
>初始时的转速：L

>初始时的挡位：1

$2.$
>判断序列不合法要放在最前面

>换挡操作比踩油门操作优先级高

$3.$
>注意：发动机停止工作是在1秒的末尾。换句话说，这1秒内汽车跑过的路程也计入总路程中。（具体看例2）

那么，细节揪出来了，模拟也很容易，代码量也不大~~但是为什么我比赛的时候没做出来鸭~~
```
#include<cstdio>
#include<algorithm>
using namespace std;
long long dang=1,su,lucheng,ff;
long long t,n,l,r,x,k,a,b;
int main()
{
    scanf("%lld%lld%lld%lld%lld%lld",&t,&n,&l,&r,&x,&k),su=l,dang=1;
    for(long long i=1;i<=t;i++)
    {
		scanf("%lld%lld",&a,&b);
        if((dang==1&&a==1)||(dang==n&&a==0))
        {
            printf("-1\n");
            return 0;
        }
        if(a==0)++dang,su=l;
        else if(a==1)--dang,su=r;
        if(b==1)su=su+x,su=min(su,r);
        lucheng+=su*dang;
        if(su==r)++ff;
        else ff=0;
        if(ff==k)break;
    }
    printf("%lld\n",lucheng);
}
```
**最后，作者提醒大家，做题时一定要小心，不要粗心大意，才能在OI生涯走的更好。**

###### ~~**其实就是把题目当做阅读理解来做**~~

---

## 作者：Gary818 (赞：9)

# 身为蒟蒻，这个题没啥坑吧QAQ（就一个） #  
### 【分析一下】 ###
	  
   其实对题目描述中数据进行处理就行了，很明显就是搜索，但是有一点  
   
   **如果转速连续 K 秒都 =R ，那么这辆车的发动机会停止工作，在这 K 秒结束的一瞬间停下**  
  	  
   那么注意到这个问题，就要特殊处理一下了。假如说这一秒 k==r 我们就让计数器+1，不过，只要在某一秒 k<r 并且此时发动机还工作着,计数器就要更新为0了，因为题目中说的是**连续**。  
     
   其余的按照题意暴力就行了！剩下解释见代码。  
     
```cpp
#include <bits/stdc++.h>
#define int long long //不开long long见祖宗啊，我第一遍没开10分（笑哭 
using namespace std;

int t,n,l,r,x,k;
int qwq=1,begin,time,ans;//qwq为档位,begin为转速,time为最大档位持续时间,ans记录结果 

signed main(){
	cin>>t>>n>>l>>r>>x>>k;
	begin=l;//注意要让最开始的转速为l，也就是转速的底线 
	while(t--){
		int xx,yy;
		cin>>xx>>yy;
		if(xx==0) begin=l,qwq++;//升一档，更新begin 
		if(xx==1) begin=r,qwq--;//降一档，更新begin 
		if(qwq==n+1||qwq==0) {//当档位超过限制或者低于一档时，车怕不是要废掉了
			cout<<-1<<'\n';
			return 0;
		}
		if(yy==1) begin=min(r,begin+x);//见题意
		if(begin==r) time++;//要连续
		else time=0;//连续断掉了，重新来
		ans+=begin*qwq;//转速×挡位
		if(time==k) {//时间到了
			cout<<ans<<'\n';
			return 0;
		}
	}
	cout<<ans<<'\n';
	return 0;
}

```
**不开long long见祖宗，重要事情说三遍，long long,long long,long long（逃**  
管理员大大，这题第一篇，给过吧2333（溜了  
若有不适请指出，谢谢大佬们


---

## 作者：萌萌哒小女孩 (赞：6)

你们都不打Pascal我来打
```pascal
var a,b:array[1..1000000] of integer;s:int64;
  k,k1,n,m,l,r,x,zs,m1,i:longint; 
function min(a,b:longint):longint;    //取最小值
begin
  if a<b then exit(a) else exit(b);
end;
begin
  readln(n,m,l,r,x,k);
  for i:=1 to n do read(a[i],b[i]);
  m1:=1;zs:=l;                       //m1档位,zs转速
  for i:=1 to n do
  begin
    if a[i]=0 then begin m1:=m1+1;zs:=l;end   //升档
      else if a[i]=1 then begin m1:=m1-1;zs:=r;end;  //降档
    if b[i]=1 then zs:=min(zs+x,r);        //踩油门
    s:=s+m1*zs;                      //计算距离
    if zs=r then            //判断发动机是否自动关机
      begin k1:=k1+1;if k1=k then begin writeln(s);halt;end;end
      else k1:=0;       //如果速度不是 r 了，清空累计
    if (m1>m) or (m1<1) then begin writeln(-1);halt;end;  //判断是否合法
  end;
  writeln(s);
end.
```


---

## 作者：Mr_Wu (赞：5)

看到题目，我们显然想到这是模拟题，但细节决定你是否AC，所以先滤清思路：

**起始：** 转速$x=L$，档位$d=1$

**一次操作：**

- 第一部分：换挡。需要注意：如果$d$在操作后跳出$[1,n]$需要**立即输出-1并退出程序**

- 第二部分：踩油门。

- 第三部分：给答案增加贡献。

- 第四部分：检查连续天数。可以用一个计数变量记录，在$x\not=K$时设为$0$，否则增加1，如果计数器达到了$K$，**先将一个变量标记上不要直接退出程序，因为-1比车停的优先级高**

**结尾：** 输出答案即可。如果中途停下了，输出中途停下时的答案。

**仍需注意：** 答案需要long long

```cpp
#include <cstdio>

typedef long long ll;
typedef unsigned long long ull;
#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

inline ll read()
{
    char c = getchar();
    ll ret = 0, t = 1;
    while ((c < '0' || c > '9') && c != '-') c = getchar();
    if (c == '-') t = -1, c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret * t;
}

ll T, N, L, R, X, K, d = 1, x, op1, op2, lx, ans, stop;
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
    #endif
    T = read(), N = read(), L = read(), R = read(), X = read(), K = read(); int i;
    x = L;
    for (i = 1; i <= T; ++i)
    {
        op1 = read(), op2 = read();
        if (op1 == 0)
        {
            if (d == N) { puts("-1"); return 0; }
            ++d, x = L;
        }
        else if (op1 == 1)
        {
            if (d == 1) { puts("-1"); return 0; }
            --d, x = R;
        }
        if (op2 == 1) x = min(x + X, R);
        ans += x * d;
        if (x == R)
        {
            ++lx;
            if (lx == K) stop = ans;
        }
        else lx = 0;
    }
    if (stop) printf("%lld", stop);
    else printf("%lld", ans);
    return 0;
}
```


---

## 作者：qnickx (赞：4)

### 思路
纯模拟+特判。
特判的地方：

1. 档位为n时x=0，档位为1时x=1;
2. 转数连续k秒为r
第一个特判没啥问题，第二个特判记得转速一旦不为r就清零
档位不变和不踩刹车的时候第二个特判仍然是要执行的，并且这一秒内仍然有前近距离。

### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
typedef long long ll;
ll tot,t,n,l,r,sh,k,ans,dang=1LL,zs;
int main()
{
    ios::sync_with_stdio(false);
    cin>>t>>n>>l>>r>>sh>>k;
    tot=0LL;
    zs=l;
    for(register int i=1;i<=t;i++)
    {
        ll x,y;
        cin>>x>>y;
        if(dang==1&&x==1)
        {
            cout<<-1;
            return 0;
        }
        if(dang==n&&x==0)
        {
            cout<<-1;
            return 0;
        }
        if(x==0)
        {
            dang++;
            zs=l;
        }
        if(x==1)
        {
            dang=dang-1;
            zs=r;
        }
        if(y==1)
        {
            zs+=sh;
            zs=min(zs,r);
        }
        if(zs==r)
        {
            tot=tot+1;
        }
        else if(zs!=r)
        {
            tot=0;
        }
        ans+=(zs*dang);
        if(tot==k)
        {
            cout<<ans;
            return 0;
        }
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：Juk_DR (赞：3)

其实这题为超级蒻的模拟，像我这种睿（ruo）智（zhi）都会的。

这题难点不大，只要按照题目给的步骤依次模拟就可以了。
（PS：然鹅我前几次翻车了，因为各种眼瞎，睿智，还有不看答疑没开long long导致没能一遍A）

主要模拟的点有（已在代码中标出）：
#### 1.每次的升降档；
#### 2.是否踩油门；
#### 3.速度对r取min以及连续k次是终止运行；
#### 4.-1的情况；
注意：
#### 1.换挡比加速先进行，所以先根据x进行操作；
#### 2.如果连续k次v=r，也要先行驶一段路程再熄火；
##### 3.~~玄学long long 不解释（10^6为啥会炸）~~
做完以上步骤即可。

以下为蒟蒻代码（大佬不要捶我(狗头保命)）:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

long long t,n,l,r,x,k,d,v,s,ti;
//d为档位，v为速度，s为路程，ti为已经连续几次v=r
int main(){
    scanf("%lld%lld%lld%lld%lld%lld",&t,&n,&l,&r,&x,&k);
    d=1;
    v=l;
    while(t--){
        long long a,b;
        scanf("%lld%lld",&a,&b);
        if((d==n && a==0) || (d==1 && a==1)){//-1的特判
            printf("-1");
            return 0;
        }
        if(a==0){//档位问题
            d++;
            v=l;
        }
        else if(a==1){
            d--;
            v=r;
        }
        if(b==0) v=min(v,r);//油门问题
        else if(b==1) v=min(v+x,r);
        s+=v*d;
        if(v!=r) ti=0;//统计连续几次速度等于r
        else ti++;
        if(ti==k) break;
    }
    printf("%lld",s);
    return 0;
}
```

---

## 作者：EarthGiao (赞：2)

## 【思路】
模拟   
### 【说在前面的话】  
其实很简单的我想复杂了    
所以看了很久的题目，担心写出锅    
主要原因还是因为这道题是gyh大佬给我推荐的   
大佬推荐的当然简单不了啦     
不过没想到gyh这么体贴我这个蒟蒻   
找适合我这个水平的题目来给我做   
开心qwq     
（为什么不开long long 只有10分，这不对）     

### 【题目分析】 
关于档位有三个操作，关于速度有两个操作   
升档，降档，不动和加速，不加速     
根据给出的数据来模拟就好了     

### 【核心思路】
根据提议来模拟就好了        
先判断是升档，降档还是不动      
如果是升档那就让档位增加，速度变为l   
如果是降档那就让档位减少，速度变为r    
如果是不动那就是不用管了   

在判断是加速还是不加速    
加速那就用现在速度加上x之后和r取min    
不加速就不用管    

还有会不会抛锚这也是一个问题     
只需要开一个变量储存已经在r速度上面持续了多久     
如果这个时候速度是r那就变量++   
不然就要变为0     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}

signed main()
{
	int ans = 0;
	int t = read(),n = read(),l = read(),r = read(),x = read(),k = read();
	int dang = 1,zhuan = l;
	int last = 0;
	for(register int i = 1;i <= t;++ i)
	{
		int opt = read(),y = read();
		if(opt == 0)//升档 
		{
			if(dang == n)
			{
				cout << -1 << endl;
				return 0;
			}
			dang ++;
			zhuan = l;//先升档
			//如果不踩油门，那就只处理升档，如果踩油门那就加速 
			if(y == 1)
				zhuan = min(r,zhuan + x); 
		}
		else
		if(opt == 1)//降档 
		{
			if(dang == 1)
			{
				cout << -1 << endl;
				return 0;
			}
			dang --;
			zhuan = r;
			if(y == 1)
				zhuan = min(r,zhuan + x);
		}
		else//档位不变 
		{
			if(y == 1)
				zhuan = min(r,zhuan + x);
		}
		ans += zhuan * dang;
		if(zhuan == r)
			last ++;
		else
			last = 0;
		if(last == k)
			break;
	}
	cout << ans << endl;
	return 0;
}
/*
6 3 1 10 5 100
0 1
0 0
2 1
2 1
1 1
1 0
*/
```

---

## 作者：林蔭 (赞：2)

           巨水的一道大模拟~~我不会调字号啊QAQ~~
           全题最大的一个坑实际上是开始给的六个
           变量顺序不要搞反即可
           本蒟蒻都能一边过的题目那可是真水啊
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long int T,N,L,R,K,X,cnt=0,sum=0,V=0,a,b,D=1,ans=0;
int LINYIN()
{
	scanf("%lld%lld%lld%lld%lld%lld",&T,&N,&L,&R,&X,&K);
	V=L;
	for(register int i=1;i<=T;i++)
	{
		ans=0;
		scanf("%lld%lld",&a,&b);
		if(a==1)
		{
			if(D-1==0)
			{
				cout<<-1;
				return 0;
			}
			else
			{
				D--;
				V=R;
			}
		}
		if(a==0)
		{
			if(D==N)
			{
				cout<<-1;
				return 0;
			}
			else
			{
				D++;
				V=L;	
			}
		}
		if(b==1)
		{
			V=min(R,V+X);
		}
		ans=V*D;
		sum=sum+ans;
		if(V==R)
		{
			cnt++;
			if(cnt==K)
			{
				cout<<sum;
				return 0;
			}
		}
		else
		{
			cnt=0;
		}
		//cout<<D<<' '<<V<<' '<<ans<<endl;
	}
	printf("%lld",sum);
	return 0;
}
int sds=LINYIN();
int main()
{
	;
}
```


---

## 作者：s_r_f (赞：2)

### 模拟。    
### 维护档位level,转速speed和  连续保持转速=R的时长Time 。
### 注意几点细节:
#### 1、换挡操作比踩油门操作先进行。
#### 2、别忘了赋初始状态。(我就是因为这个WA了3次，丢了15分)
#### 3、在发动机停止工作后，OwenOwl仍然可以增加/减少档位，要判-1.
#### 4、答案在long long范围内。

```
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    int k = 0;char put[40];
    if (!x) putchar('0');
    if (x < 0) putchar('-'),x = -x;
    while (x)  put[++k] = (x % 10) + '0',x /= 10;
    while (k)  putchar(put[k]),--k;
    putchar('\n');
}

int T,n,L,R,dx,k;
LL ans;

int level,speed,Time,node;
int x,y;
int ok;
int main(){
	T = read(),n = read(),L = read(),R = read(),dx = read(),k = read();
	level = 1; node = 1; ok = 1; speed = L;
	while (T--){
		x = read(),y = read();
		if (x==0){ speed = L,++level; } else if (x==1){ speed = R,--level; }
		if (y){ speed = min(R,speed + dx); }
		
		if (speed == R) ++Time; else Time = 0;
		ans += 1ll*level*speed*node;
		if (Time >= k) node = 0;
		if (level < 1 || level > n) ok = 0;
	}
	if (ok) write(ans); else puts("-1");
	return 0;
}
```

---

## 作者：Catalan1906 (赞：2)

正常模拟就好~

首先初始化：转速=l, 档位=1

然后读入数据

由于先要处理换挡操作，所以我们先按照x处理，再按照y处理

当x=0时，档位+1，转速=l

当x=1时，档位-1，转速=r

当y=1时，转速=转速=min(转速+x, r)

边操作边记录连续一段时间档位为r的秒数

在执行换挡操作的时候特判-1的情况

另外当发动机停止工作的时候，后面的操作就不用管啦，直接跳出~

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <bits/stdc++.h>

using namespace std;

long long n, t, l, r, qwq, k, dangwei, zhuansu, lianxu;

int main() {
    cin >> t >> n >> l >> r >> qwq >> k;
    dangwei = 1; zhuansu = l;
    long long ans = 0;
    while(t--) {
        int x, y;
        cin >> x >> y;
        if(x == 0) {
            if(dangwei == n) {
                cout << -1;
                return 0;
            }
            dangwei++;
            zhuansu = l;
        }
        if(x == 1) {
            if(dangwei == 1) {
                cout << -1;
                return 0;
            }
            dangwei--;
            zhuansu = r;
        }
        if(y == 1) {
            zhuansu = min(zhuansu + qwq, r);
        }
        if(zhuansu != r) lianxu = 0;
        else lianxu++;
        // cout << dangwei << " " << zhuansu << endl;
        ans += dangwei * zhuansu;
        if(lianxu == k) break;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Konnyaku_ljc (赞：2)

第一次在比赛中A了一道题，纪念一下，发篇题解。  
为什么是道黄题？这么水的模拟？  
根据我作死的经验（在考场上），本题有以下几个坑点——  
### First 不开long long见祖宗
毕竟数据范围10^6，WA掉很正常  
### Second 如果转速连续K秒都=R，那么这辆车的发动机会停止工作。
我zz了，判成了相等……
### Third 初始时转速为L。每次升挡时，转速会变成L；降挡时，会变成R。
## 这个故事告诉我们，读题很重要！  
# 所以，暴力出奇迹！
上代码
```cpp
#include<bits/stdc++.h>//万能头（今晚模拟赛用还CE了……）
using namespace std;
long long t,n,l,r,x,k,a,b,ans,sum,dv=1,zs;
//t,n,l,r,x,k不多说，a/b输入用，ans表答案，sum记等于R的个数，dv表档位，zs表转速
int main()
{
    cin>>t>>n>>l>>r>>x>>k;//输入
    zs=l;//开始时，转速为l；
    for(long long i=1;i<=t;i++)
    {
    	cin>>a>>b;//输入两个整数；
    	if(a==0)//第一种情况——升档
    	{
    	    if(dv==n){cout<<"-1";return 0;}
            //档位是n是，再加速，爆破！
    	    else//没有炸的话
    	    {
    		dv++,zs=l;//档位加一，转速更新为l
    		if(b==0){ans+=zs*dv;}//不踩油门，直接算距离
    	        if(b==1){zs+=x;zs=min(zs,r);ans+=zs*dv;}
                //老司机踩油门，转速增加,转速取与r最小值，计算距离
	    }
        }
	if(a==1)//第二种——降档
	{
	    if(dv==1){cout<<"-1";return 0;}
            //档位是一时，无法再降，爆破！
	    else{dv--,zs=r,ans+=zs*dv;}
            //不然，无论踩不踩油门，转速一定是r，计算距离
	}
	if(a==2)//第三种——不变
	{
	    if(b==0){ans+=zs*dv;}//不踩直接算
	    if(b==1){zs+=x;zs=min(zs,r);ans+=zs*dv;}
            //踩的话重复上文
	}
	if(zs==r){sum++;if(sum==k){cout<<ans;return 0;}}
        //转速与r相等时，sum++，等于k时，爆破！输出ans
	else{sum=0;}不等时，肯定断开，sum清零
    }
    cout<<ans;//输出答案
    return 0;//完美AC
}
```
这当然不是最优解，但是肯定好理解，毕竟我这么弱……  
考试愉快！！！

---

## 作者：huayucaiji (赞：2)

本题水的一批

```cpp
#include<bits/stdc++.h>
using namespace std;
int min(unsigned long long a,unsigned long long b)
{
	return a<b? a:b;
}
int main()
{
	ios::sync_with_stdio(0);
	int t,n,l,r,x,k,a,b;
	unsigned long long d=1,kn=0,s;
	unsigned long long ans=0;
	cin>>t>>n>>l>>r>>x>>k;
	s=l;
	for(int i=1;i<=t;i++)
	{
		cin>>a>>b;
		if(a==0)
		{
			d++;
			s=l;
		}
		if(a==1)
		{
			d--;
			s=r;
		}
		if(d>n||d<=0)
		{
			cout<<-1;
			return 0;
		}
		if(b==1)
		{
			s=min(s+x,r);
		}
		
		if(s==r)
		{
			kn++;
		}
		else
		{
			kn=0;
		}
		
		ans+=(s*d);
		if(kn>=k)
		{
			cout<<ans;
			return 0;
		}
	}
	cout<<ans;
}
```
结束了

---

## 作者：封禁用户 (赞：1)

提交2次AC

该题为一道典型的~~阅读理解~~纯模拟题

先放第一个代码（70分）

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
int t,n,l,r,x,k,xi[1000010],yi[1000010],d=1,dr,tmp=0;
long long ans;
int main()
{
    cin>>t>>n>>l>>r>>x>>k;
    for(int i=0;i<t;i++)
        cin>>xi[i]>>yi[i];
    dr=l;
    for(int i=0;i<t;i++)
    {
        if(xi[i]==0)d++,dr=l;
        else if(xi[i]==1)d--,dr=r;
        if(yi[i]==1)dr=min(dr+x,r);
        if(dr==r)
        {
            tmp++;
            if(tmp>=k)
                break;
        }
        else tmp=0;
        if(d>n||d<1)
        {
            cout<<-1;
            return 0;
        }
        ans+=(long long)dr*d;
    }
    cout<<ans;
    return 0;
}
```

连第2个样例都没过。理由：

1.这 K 秒结束的一瞬间停下

2.在每秒开头的一瞬间进行的，其中换挡操作比踩油门操作先进行。而这一秒内这辆车前进的距离是 转速×挡位（原文）

调整顺序后：

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
long long ans,t,n,l,r,x,k,xi[1000010],yi[1000010],d=1,dr,tmp;//d即档,dr转速，tmp即转速连续为r的时间
int main()
{
    cin>>t>>n>>l>>r>>x>>k;
    for(int i=0;i<t;i++)
        cin>>xi[i]>>yi[i];
    dr=l;
    for(int i=0;i<t;i++)
    {
        if(xi[i]==0)d++,dr=l;//降档
        else if(xi[i]==1)d--,dr=r;//升档
        //x=2，不操作
        if(d>n||d<1)
        {
            cout<<-1;//序列不合法
            return 0;
        }
        if(yi[i]==1)dr=min(dr+x,r);//踩油门
        if(dr==r)tmp++;
        else tmp=0;
        ans+=(long long)dr*d;
        if(tmp>=k)break;//发动机宕机
    }
    cout<<ans;
    return 0;
}

```

~~像我这种语文月考[Censored]分的就别发题解了~~

---

## 作者：RoRoyyy (赞：1)

月赛题解,本蒟蒻第一次发题解很激动~~有木有~~

最大的坑就是longlong，害得我调试了一个小时


下面为蒟蒻代码，~~自认码风还可以~~
思路就是纯模拟，很简单，先改档位，再该转速，最后判断发动机是否报废

------------


```cpp
//by AndyZ 2019.3.23
#include<cstdio>
#include<iostream>
#define R register
#define int long long
using namespace std;
int t,n,l,r,x,k;//n个档位 lr转速范围 踩油门转速增加x 
int a,b;//k表示不能连续k秒转速最大 
int ans,nowd=1,nowz;//现在档位 现在转速
int warn,warnt=0; 
signed main(){
	scanf("%lld%lld%lld%lld%lld%lld",&t,&n,&l,&r,&x,&k);
	nowz=l;
	for(R int i=1;i<=t;i++){
		scanf("%lld%lld",&a,&b);
		if(a==0){
			if(nowd==n){
				printf("-1");
				return 0;
			}else{
				nowd++;
				nowz=l;
			}
		}else if(a==1){
			if(nowd==1){
				printf("-1");
				return 0;
			}else{
				nowd--;
				nowz=r;
			}
		}
		if(b==0){
			ans+=nowd*nowz;
		}else{
			nowz=min(r,nowz+x);
			ans+=nowd*nowz;
		}
	if(nowz==r){
		warnt++;
	}else{
		warnt=0;
	}
	if(warnt==k){
			printf("%lld",ans);
			return 0;
		}
	}
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：mulberror (赞：1)

感觉不能抢到首杀。  
首先你需要把题目读好，一开始本地运行的时候挂掉是因为**车子停下来就不算距离了**。  
注意一下，题目中说了先把所有的操作做完之后在计算距离。  
还有不开`long long`见祖宗吧！QwQ。（只需要开一个答案的longlong就好了）
其他也没有什么要讲的。

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
ll ans = 0;
template <typename T>
inline void read(T &x) {
    x = 0; T fl = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') fl = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    x *= fl;
}
int fg = 0;
int t, n, l, r, x, k;
int main() {
    read(t); read(n); read(l); read(r); read(x); read(k); 
    int nw_lev= 1, nw_spd = l;
    for (int i = 1; i <= t; i ++) {
        int opt, y;
        read(opt); read(y);
        if (!opt) {
            if (nw_lev == n) {
                printf("-1\n");
                return 0;
            }
            nw_lev ++;
            nw_spd = l;
            if (y) nw_spd = min(r, nw_spd + x);
            if (nw_spd == r) ++ fg;
            else fg = 0; 
            ans += 1ll * nw_lev * nw_spd;
            if (fg == k) break;
        }
        else if (opt == 1){
            if (nw_lev == 1) {
                printf("-1\n");
                return 0;
            }
            nw_lev --;
            nw_spd = r;
            if (y) nw_spd = min(r, nw_spd + x);
            if (nw_spd == r) ++ fg;
            else fg = 0;
            ans += 1ll * nw_lev * nw_spd;
            if (fg == k) break;
        }
        else {
            if (y) nw_spd = min(r, nw_spd + x);
            if (nw_spd == r) ++ fg;
            else fg = 0;
            ans += 1ll * nw_lev * nw_spd;
            if (fg == k) break;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：WKAHPM (赞：1)

~~三年OI一场空，不开long long 见祖宗~~

一道模拟题，具体解释在代码里：

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,l,r,x,k;
long long dang,zhuan;//一定要开long long !!!
long long ans;
int main()
{
//	freopen("1.out","w",stdout);
    scanf("%d%d%d%d%d%d",&t,&n,&l,&r,&x,&k);
    zhuan=l;//zhuan存放转速
    dang=1;//dang存放档位
    int flag=0;
    for(int i=1;i<=t;i++)
    {
    	int xx,yy;
    	scanf("%d%d",&xx,&yy);
    	if(xx==0)//升档
    	{
    		if(dang==n) //如果dang已经到达了n，那么是非法序列
    		{
    			cout<<"-1";
    			return 0;
			}
    		dang++;
    		zhuan=l;//转速调整为l
		}
		if(xx==1)//降档
		{
			if(dang==1) //如果dang是1，那么是非法序列
			{
				cout<<"-1";
				return 0;
			}
			dang--;
			zhuan=r;//转速调整为r
		}
		if(yy==1)//踩油门
		{
			zhuan+=x;//转速加上x
			if(zhuan>r) zhuan=r;//对r取min
		}
		ans+=zhuan*dang //一定要在发动机有没有爆炸前加
		if(zhuan==r)
		{
			flag++;
			if(flag==k)//爆炸
			{
				cout<<ans;
				return 0;
			}
		}
		else flag=0;
	}
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：LCuter (赞：1)

# 题解P5269

先理一下思路，基本上可以判定这道题是一道模拟题，我们模拟1~$T$时刻的情况，并累加答案

每一个时刻我们先处理升降挡，再处理踩油门，最后判断发动机炸了没有。下面是具体流程

------------

首先先初始化，转速为$L$，挡数为1

接着循环模拟1~$T$时刻

如果此时升档，则判断挡数是否为1，挡数为1就是无解，否则挡数+1，转速变为$L$

如果此时降挡，则判断挡数是否为$n$，挡数为$n$就是无解，否则挡数-1，转速变为$R$

如果此时踩油门，则转速变为$min(R,now+X)$

答案更新，ans=ans+转速x挡数

如果此时转速为$R$，则连续次数+1，否则清零

如果连续次数为$K$，则输出当前答案，退出循环

------------

(我第一次写把转速和挡数部分混淆了，真是菜)

但是你以为这么写就好了吗？**如果你用int，那么你至多有70分，这道题要开LL**

(我改完上面那个错，交了一遍，马上就发觉要开LL，但是……)

(但是我在答案累加时的乘法写的是```ans+=now*now1```，而不是```ans+=1LL*now*now1```，故只有85分，也算长教训了)

--------

下面就放一下代码，变量我都注释了，至于流程我上面应经写了

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int t,n,l,r,x,k;//如题
long long ans;//统计答案
int ed,now,now1;//ed是转速连续为r的次数，now是当前转速，now1是当前挡数
int main(){
	scanf("%d %d %d %d %d %d",&t,&n,&l,&r,&x,&k);//读入
	now=l,now1=1;//初始化
	for(int i=1;i<=t;++i){//循环枚举
		int d,y;//d是是否升降挡，y是是否踩油门
		scanf("%d %d",&d,&y);
		if(d==0){
			if(now1==n){
				printf("-1");
				return 0;
			}
			else{
				++now1;
				now=l;
			}
		}
		if(d==1){
			if(now1==1){
				printf("-1");
				return 0;
			}
			else{
				--now1;
				now=r;
			}
		}
		if(y==1){
			now=min(r,now+x);
		}
      		//因为不踩油门或不升降挡是没有影响的，所以我没有讨论 
		ans+=1ll*now1*now;
		if(now==r) ++ed;
		else ed=0;
		if(ed==k){
			printf("%lld",ans);
			return 0;
		}
	}
	printf("%lld",ans);
}
```

---

## 作者：AntiO2 (赞：1)

### 这是一道思路简单的模拟题

- 用ans记录走过的路程。

- dw记录当前档位，zs记录当前转速（拼音大法好）。

- 如果y==1,则转速增加

- x=0,升档且转速变为l。x=1,降档且转速变为r。

- 每秒末做出以下判断

	-  档位是否为0或n+1，如果是则OwenOwl操作非法
    
   - 判断转速是否达到上限k秒，如果是，则发动机已经坏掉了。
   
- 最后，路程+=转速*档位

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,l,r,xx,ans,k,zs,cnt;
int main()
{
    cin>>t>>n>>l>>r>>xx>>k;
    zs=l;
    int dw=1;
    register int x,y;
    for(int i=1;i<=t;i++)
    {
        scanf("%d%d",&x,&y);
        if(x==0)//升档操作
        {
            dw++;
            zs=l;
        } 
        if(x==1)//降档操作
        {
            dw--;
            zs=r;
        }
        if(dw==0||dw==n+1)//判断是否合法
        {
            cout<<"-1"<<endl;
            return 0;
        }
        if(y==1)//判断是否达到上限
        {
            zs+=xx;
            if(zs>r) zs=r;
        } 
        if(zs==r) cnt++;
        else cnt=0;
        ans+=zs*dw;
        if(cnt==k)	break;//判断是否过热
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：sunxiaofan (赞：1)

哈哈，这次月赛题发篇题解

这是一道~~非常简单的~~模拟，只需判断转速是否达到r，档位是否超过n或者小于1；路程就是每一秒的转速乘档位（**注意：停下的那一秒的路程也算**）。

代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#define ll long long
using namespace std;
int v1,v2;
ll n,t,l,r,x,k;
ll dang,zhuan,ans,time1;//拼音英语学得都不好o(╥﹏╥)o档位，转速；
//起变量不要用time，time会CEo(╥﹏╥)o我就CE了
int main()
{      
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    scanf("%lld%lld%lld%lld%lld%lld",&t,&n,&l,&r,&x,&k);
    dang=1;
    zhuan=l;
    time1=0;
    for(int i=1;i<=t;i++)
    {
    	scanf("%d%d",&v1,&v2);
    	if(v1==0)
    	{
    		dang++;//档位加
    		zhuan=l;
		}
		else if(v1==1)
		{
			dang--;//档位减
			zhuan=r;
		}
		if(dang>n||dang<1)
		{
			printf("-1");
			return 0;
		}
		if(v2==1)
		{
			zhuan=min(r,zhuan+x);//这个地方就是如果踩油门后转速大于r，就取r；转速不到r，就取zhuan+x
		}
		if(zhuan==r)
		{
			time1++;
		}
		else 
		{
			time1=0;
		}
		ans+=zhuan*dang;//即路程，转速*档位；要在退出循环之前。
		if(time1>=k)//如果转速达到r的时间超过或等于k就退出循环。
		{
			break;
		}
		
	}
	printf("%lld",ans);//输出答案
	return 0;
}
```
### 蒟蒻拙见，望dalao指教QAQ

---

## 作者：LB_tq (赞：1)

```
//依据题意模拟即可，但有坑点，蒟蒻比赛时提交了三次才A
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long 
ll p,n,l,r,x,k;//依据题意的变量名
ll ans,s1,s2,t,c;//s1存储当前转速，s2存储上一秒的转速，t存储当前档位
ll tai(ll xx,ll yy){
	if(xx>yy)
		return yy;
	return xx;
}//取min值
int main(){
	cin>>p>>n>>l>>r>>x>>k;
	t=1;
	s1=s2=l;//初始化
	ll u,v;
	for(int i=1;i<=p;i++){
		cin>>u>>v;
		if((t==1&&u==1)||(t==n&&u==0)){
			ans=-1;
			break;
		}//判断-1的情况
		if(u==0){
			t++;
			s1=l;
		}
		if(u==1){
			t--;
			s1=r;
		}
		if(v==1)
			s1=tai(s1+x,r);
		ans+=s1*t;//依题意处理
		if(s1==s2&&s1==r)
			c++;
		if(s1!=r)
			c=0;
		if(s1!=s2&&s1==r)
			c=1;//注意停止的特判
		if(c==k)
			break;
		s2=s1;//s2继承s1
	}
	cout<<ans;
	return 0;
}
```
//一道模拟祝大家早日AC


---

## 作者：无意识躺枪人 (赞：1)

一道很水的模拟题，按着题面来

送上拼音注释版代码！

各位看到有调试语句，最后发现有两个错误

第一个是降档的时候为R，升档为L，之前脑抽打反了

第二个是连续满转速的标记忘了清零orz

另外

记得开long long


（争取首个题解qwq）

```
#include<bits/stdc++.h>
using namespace std;

long long N,L,R,X,K,T,x,y;
long long ans=0;
long long dangwei=1,zhuansu,lianxu=0;

template<class T> inline void read(T &re)
{
	re=0;T sign=1;char tmp;
	while((tmp=getchar())&&(tmp<'0'||tmp>'9')) if(tmp=='-') sign=-1;re=tmp-'0';
	while((tmp=getchar())&&(tmp>='0'&&tmp<='9')) re=re*10+(tmp-'0');re*=sign;
}

void wrong() {putchar('-');putchar('1');exit(0);}
void stop() {printf("%lld\n",ans);exit(0);}

int main()
{
	read(T);read(N);read(L);read(R);read(X);read(K);
	zhuansu=L;
	for(register int i=1;i<=T;i++)
	{
		read(x);//0升档，1降档，2不变
		read(y);//0不踩，1踩（转速+=X）
		if(x==1)//降档
		{
			dangwei--;
			if(dangwei<1) wrong();
			zhuansu=R;
		}
		if(x==0)//升档
		{
			dangwei++;
			if(dangwei>N) wrong();
			zhuansu=L;
		}
		if(y==1)//踩油门
		{
			zhuansu+=X;
			zhuansu=min(zhuansu,R);
		}
		// cout<<"dangwei: "<<dangwei<<endl<<"zhuansu: "<<zhuansu<<endl;
		ans+=zhuansu*dangwei;
		// cout<<"ans: "<<ans<<endl;
		lianxu++;
		if(zhuansu!=R) lianxu=0;
		if(lianxu>=K) stop();
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：小黑AWM (赞：1)

直接模拟：

注意要点观察到最大路程可能为$T * N * R$达到$10^{18}$故使用long long防止爆精度。其余无坑点。

代码：
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<ctime>
#include<utility>
#include<functional>
#include<cmath>
#include<vector>
#include<assert.h>
using namespace std;
using std::min;
using std::max;
using std::swap;
using std::sort;
using std::reverse;
using std::random_shuffle;
using std::lower_bound;
using std::upper_bound;
using std::unique;
using std::vector;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef std::pair<int,int> pii;
typedef std::pair<ll,ll> pll;
#define type ll//看情况修改返回类型
inline char nc()
{
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline type read()
{
    char ch=nc();type sum=0;
    while(!(ch>='0'&&ch<='9'))ch=nc();
    while(ch>='0'&&ch<='9')sum=(sum * 10)+ch-48,ch=nc();
    return sum;
}
ll t, n, l, r, x, k, opt1, opt2, SUM, times, last, v;
int main(){
    t = read(), n = read(), l = read(), r = read(), x = read(), k = read();
    times = 1;
    v = l;
    for(int i = 1; i <= t; i++){
        opt1 = read(), opt2 = read();
        switch (opt1) {
            case 0:
                v = l;
                if(times < n)
                    times++;
                else{
                    printf("-1\n");
                    return 0;
                }
                break;
            case 1:
                v = r;
                if(times > 1)
                    times--;
                else{
                    printf("-1\n");
                    return 0;
                }
                break;
            case 2:
                break;
        }
        switch (opt2) {
            case 0:
                break;
            case 1:
                if(v+x <= r)
                    v += x;
                else
                    v = r;
                break;
        }
        if(v == r) last++;
        else last = 0;
        SUM += times*v;
        //printf("x:%lld y:%lld\n", opt1, opt2);
        //printf("time:%lld v:%lld times:%lld for:%lld length:%lld\n", i, v, times, last, SUM);
        if(last == k)
            break;
    }
    printf("%lld\n", SUM);
    return 0;
}

```
可惜跑的不快


---

## 作者：muller (赞：1)

这题就是分几种情况考虑

然后模拟一下

注意不要忘了初始状态

其他按照题意模拟即可

代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,L,R,X,K,wei,tmp,ans,las=0;
int main() {
	std::ios::sync_with_stdio(false);
	cin>>T>>n>>L>>R>>X>>K;wei=1;tmp=L;
	while (T--) {
		ll x,y;cin>>x>>y;
		if (!x) {
			if (wei==n){ans=-1;break;}
			wei++;tmp=L;
			if (y==1)tmp+=X;
			if (tmp>R)tmp=R;
		}else if (x==1){
			if (wei==1){ans=-1;break;}
			wei--;tmp=R;
			if (y==1)tmp+=X;
			if (tmp>R)tmp=R;
		}else {
			if (y==1){
				tmp+=X;
				if (tmp>R)tmp=R;
			}
		}
		if (tmp==R) {
			las++;
			if (las==K+1)break;
		}else las=0;
		ans+=tmp*wei;
	} 
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：1saunoya (赞：1)

># [更好的阅读体验](https://www.cnblogs.com/qf-breeze/p/10587300.html)

># [$problem$](https://www.luogu.org/problemnew/show/P5269)


>哇 看各位巨佬都来发$T1$的题解 我也来发一篇。（~~别的题目不会别瞎bb~~）

>题目大意就是

> $T$ 秒 能走多少路程

>第一行六个整数 $T,N,L,R,X,K$

>接下来 $T$ 行，每行两个整数 $x,y$ 表示这一秒的操作。

>我们设档为$D$，转速为$V$

>首先 $D = 1$ ，$V = L$ 。

>$x == 1$ $D++$，$V=L$

>$x == 2$ $D--$，$V=R$

>$y == 0$ $V+=X$ 

>$V > R$ 则 $V=R$（即$V=min(V+X,R)$）

>连续$K$秒 $V=R$ 则停止。

>得出
```cpp
if(V == R) cnt ++ ;
if(V != R) cnt = 0 ;
if(cnt == K) break ;
```

>特别注意的一点 是 特判$-1$ 

>即

~~~cpp
if(D == N+1 or D == 0) return printf("-1"),0;
~~~


>完整代码如下。



```cpp
//完整代码
#include <bits/stdc++.h>
using namespace std;
typedef long long LL ;
inline LL In() { LL res(0),f(1); register char c ;
    while(isspace(c=getchar())) ; c == '-'? f = -1 , c = getchar() : 0 ;
    while(res = (res << 1) + (res << 3) + (c & 15) , isdigit(c=getchar())) ;
    return res * f ;
}

LL T , N , L , R , X , K ;
LL D , V ;
signed main () {
    T = In() ; N = In() ; L = In() ; R = In() ; X = In() ; K = In() ;
    D = 1 , V = L ;
    LL ans = 0 ;
    LL cnt = 0 ;
    for(register int i = 1 ; i <= T ; i++) {
        int x , y ;
        x = In() , y = In() ;
        if(x == 0) D ++ , V = L ;
        if(x == 1) D -- , V = R ;
        if(D == N+1 or D == 0) return printf("-1"),0;
        if(y) V = V+X>R?R:V+X;
        if(V == R) cnt ++ ;
        if(V != R) cnt = 0 ;
        ans += D * V ;
        if(cnt == K) break ;
    }
    cout << ans ;
    return 0 ;
}
```

---

## 作者：jins3599 (赞：1)

#### 一道很水的模拟题

代码应该很好懂，不解释了

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll now=1,t,n,l,r,x,k;
ll speed;
ll sum=0;
ll ans=0;
ll a,b;
int main (){
	cin>>t>>n>>l>>r>>x>>k;
	speed=l;
	while(t--){
		cin>>a>>b;
		if(a==0){
			now++;
			if(now>n) {
				puts("-1");return 0;
			}
			speed=l;			
		}
		
		if(a==1){
			now--;
			if(now<1){
				puts("-1");return 0;
			}
			speed=r;
		}
		if(b==1){
			speed+x>r?speed=r:speed+=x; 
		}	
		ans+=speed*now;
		if(speed==r) sum++;
		else sum=0;
		if(sum==k){
			printf("%lld",ans);return 0;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：李至擎 (赞：0)

[点我看题](https://www.luogu.com.cn/problem/P5269)

思路：显然是模拟题，没什么好说的。

方法（以执行一次操作为例）：

- $1.$ 根据输入调整挡位；

- $2.$ 判断挡位是否超出 $[1,n]$ 的范围；

- $3.$ 根据输入调整转速；

- $4.$ 根据是否踩油门调整转速；

- $5.$ 增加答案；

- $6.$ 检查连续时间；

细节：

- $1.$ 初始转速 $v=L$ ，初始挡位 $d=1$；

- $2.$ 如果 $d$ 在操作后超过了 $[1,n]$ 的范围，则需要立即输出 $-1$ 并退出程序；

- $3.$ 一定要开 $long$ $long$ ，一定要开 $long$ $long$ ，一定要开 $long$ $long$ ！

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long//方便写 
using namespace std;
LL t,n,l,r,x,k;//t、n、l、r、x和k的意义如题所示
LL p,q,sum;//p和q表示这一秒的操作，sum是答案
LL d=1,v,cnt;//d和v是挡位和转速，cnt代表连续时间（顺便初始化） 
int main() 
{ 
	cin>>t>>n>>l>>r>>x>>k;//输入 
	v=l;//初始化转速 
	while(t--)//t次操作 
	{
		cin>>p>>q;//这一秒的操作 
		if(p==0)//操作为增加挡位时 
		{
			d++;//增加挡位 
			if(d>n)//超出边界 
			{
				cout<<-1;//输出-1 
				return 0;//结束程序 
			}
			v=l;//改变转速 
		}
		else if(p==1)//操作为减少挡位时   
		{
			d--;//增加挡位 
			if(d<1)//超出边界 
			{
				cout<<-1;//输出-1
				return 0;//结束程序
			}
			v=r;//改变转速  
		}
		if(q==1)//操作为踩油门时  
		{
			v=min(v+x,r);//改变转速 
		}
		sum+=d*v;//统计路程 
		if(v==r)//统计连续时间 
		{
			cnt++;
		}
		else
		{
			cnt=0;
		}
		if(cnt==k)//判断连续时间 
		{
			break;
		}
	}
	cout<<sum;//输出结果 
	return 0;
}
```

---

## 作者：312_de_cat (赞：0)

```cpp
//emm,纯模拟，注意用long long即可（玄学）
#include<iostream>
#include<algorithm>
using namespace std;
long long t,n,l,r,x,k,x1,y1,gear=1,dis=0,speed=0,cnt=0; //
int main(){
    cin>>t>>n>>l>>r>>x>>k;
    speed=l;
    for(int i=0;i<t;i++){
        cin>>x1>>y1;
        if(x1==0&&gear==n||x1==1&&gear==1){  //是否合法
            cout<<-1<<endl;
            return 0;
        }
        if(x1==0){        //处理档位
            gear++;
            speed=l;
        }
        if(x1==1){
            gear--;
            speed=r;
        }
        if(y1==1){        //处理油门
            speed+=x;
            speed=min(speed,r);
        }
        dis+=speed*gear;
        if(speed==r) cnt++;  //计数判断是否停车
        else cnt=0;
        if(cnt==k) break;
    }
    cout<<dis<<endl;
    return 0;
}
```


---

## 作者：YISMOKIE (赞：0)

这道题并不难真的只是模拟，连个坑都没有

注意用long long

不说什么，直接上代码

```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
inline ll read()
{
	char c;
	ll flag=1;
	while ((c=getchar())<'0'||c>'9')
		if (c=='-') flag=-1;
	ll res=c-'0';
	while ((c=getchar())>='0'&&c<='9')
		res=res*10+c-'0';
	return res*flag;
}
ll T,N,L,R,X,K;
ll t=0,n=1,w,ans=0;//t表示转速保持在R的时间，n表示档位，w表示转速
int main()
{
	T=read(),N=read(),L=read(),R=read(),X=read(),K=read();
	w=L;
	ll x,y;
	while (T--)
	{
		x=read(),y=read();
		if ((x==0&&n==N)||(x==1&&n==1))
		{
			cout<<"-1";
			return 0;
		}
		if (x==0)
		{
			n++;
			w=L;
		}
		else if (x==1)
		{
			n--;
			w=R;
		}
		if (y==1) w=min(w+X,R);
		if (w==R) t++;
		else t=0;
		ans+=n*w;
		if (t==K)
		{
			cout<<ans;
			return 0;
		}
	}
	cout<<ans;
	return 0;
}
```
谢谢观看！

---

## 作者：TEoS (赞：0)

作为月赛的T1，这道题自然是非常友好的了，100分不是问题。


------------
思路：纯模拟，按照题目中的步骤一步一步去走就好了。~~根据月赛答疑帖，~~下面有几个题目中没有交代清楚的易WA点：

- 车辆熄火后不会再次重启（根据样例2可以得出）
- 车辆熄火后直接输出距离即可，不必再判定之后的操作是否合法。
- 在每秒内（根据物理必修一告诉我的，一秒指的是时间，一秒末或一秒初指的是时刻）车辆的速度发生变化不会打断k秒统计，换句话说，k秒统计判定的是每秒末的速度。
- 月赛答疑帖中发现的友情提示：尽量把所有变量都开long long！（否则可能会出现一直85分的情况）

代码：（略~~丑~~请原谅）
```cpp
#include<iostream>
#include<algorithm>
#define ll long long 
using namespace std;
ll t,n,l,r,x,k,v,d=1,len=0,cnt=0;
int main()
{
	cin>>t>>n>>l>>r>>x>>k;
	v=l;//初始化
	for(ll i=1;i<=t;i++)
	{
		ll xx,yy;//为了避免变量重名所以..
       		cin>>xx>>yy;
		if(xx==0)
		{
			v=l;
			if(d==n)
			{
				cout<<-1;
				return 0;
			}//不合法直接输出-1并结束程序
			d++;
		}//升档
		if(xx==1)
		{
			v=r;
			if(d==1)
			{
				cout<<-1;
				return 0;
			}
			d--;
		}//降档
      //不换挡就不去理它啦
		if(yy==0)
			len+=v*d;//不踩油门则直接加
		if(yy==1)
		{
			v=min(v+x,r);
			len+=v*d;
		}//踩油门
		if(v==r)
		{
			cnt++;
			if(cnt==k)
				break;
		}//若当前速度v==r则自加统计变量，并判定是否已达到k秒，达到则结束行进
		else
			cnt=0;//若v!=r则清零
	}
	cout<<len;
	return 0; 
}
```
【LGR-057】 rank385 100分祭

~~要不是为了一题玄学题目怎么可能才100！~~

---


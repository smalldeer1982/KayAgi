# 快乐水

## 题目背景

小 W 要去买快乐水。

## 题目描述

他来到了一家商店门前。

这家商店为了吸引顾客来买快乐水，搞了这么一个活动：「$5$ 个瓶盖换一瓶快乐水」。于是，人们纷纷来他的店里买快乐水。

买完快乐水，他想到了一个问题：

如果一瓶快乐水有 $m$ 个附属品，对于第 $i$ 个附属品，每 $a_i$ 个可以换一瓶全新的快乐水，现在我有买 $n$ 瓶快乐水的钱，我最多能喝多少快乐水呢？

## 说明/提示

样例一解释：

| 步数 | 已喝 | 未喝 | 附属品一 | 附属品二 |
| ---- | ---- | ---- | -------- | -------- |
| 1    | 0    | 5    | 0        | 0        |
| 2    | 5    | 0    | 5        | 5        |
| 3    | 5    | 3    | 1        | 1        |
| 4    | 8    | 0    | 4        | 4        |
| 5    | 8    | 3    | 0        | 0        |
| 6    | 11   | 0    | 3        | 3        |
| 7    | 11   | 1    | 1        | 3        |
| 8    | 12   | 0    | 2        | 4        |
| 9    | 12   | 2    | 0        | 0        |
| 10   | 14   | 0    | 2        | 2        |
| 11   | 14   | 1    | 0        | 2        |
| 12   | 15   | 0    | 1        | 3        |

样例二解释：

| 步数 | 已喝     | 未喝     | 附属品一 | 附属品二 |
| ---- | -------- | -------- | -------- | -------- |
| 1    | 0        | 2        | 0        | 0        |
| 2    | 2        | 0        | 2        | 2        |
| 3    | 2        | 2        | 0        | 0        |
| 4    | 4        | 0        | 2        | 2        |
| 5    | 4        | 2        | 0        | 0        |
| 6    | 6        | 0        | 2        | 2        |
| 7    | 6        | 2        | 0        | 0        |
| 8    | 8        | 0        | 2        | 2        |
| 9    | $\vdots$ | $\vdots$ | $\vdots$ | $\vdots$ |

很显然小 W 可以像这样无限白嫖快乐水。

**注意：本题中，我们认为无法借还/赊账。**
********
数据范围：  

测试点一与样例二相同。

对于其中 $30\%$ 的数据，$n\le 100$，$m\le 2$。

对于 $100\%$ 的数据，$1\le n\le 10^4$，$1\le m\le 5$，$1\le a_i\le 2\times10^3$。

## 样例 #1

### 输入

```
5 2
2 4
```

### 输出

```
15```

## 样例 #2

### 输入

```
2 2
2 2
```

### 输出

```
Inf```

# 题解

## 作者：WYXkk (赞：32)

# 题解 快乐水

模拟即可。

如何判断是否能无限白嫖：如果换的超过了原来的总个数（或者长时间不变）那么可以判断能无限白嫖。

如果你仅仅判断所有 $a_i$ 的倒数和是否 $\ge1$，那么你就会在第二个测试点 WA：你可能根本不能换。

如果你使用 `int`，那么你就会在第十个测试点 WA：这个测试点的答案大约是 $3\times10^{10}$。但是如果你全用 `long long`，你会 TLE。

附上上面提到的两组数据：

testdata 2:

```
3 5
4 4 4 4 4
```

testdata 10:

```
10000 5
2 3 7 43 1807
```

testdata 10 的构造方法：

$$\begin{aligned}&1-\dfrac12=\dfrac12\\&\dfrac1{2}-\dfrac1{3}=\dfrac1{6}\\&\dfrac1{6}-\dfrac1{7}=\dfrac1{42}\\&\dfrac1{42}-\dfrac1{43}=\dfrac1{1806}\\&\dfrac1{1806}-\dfrac1{1807}=\dfrac1{3263442}\\&\end{aligned}$$

假如可以借/还那么这样答案会很大（$3263442\times n$），所以这样会把复杂度卡上天。实测模拟需要跑大约 $2.8\times10^7$ 轮。

如果 $m=6$ 可能只能打表了（

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;


int main()
{
    int a[20],b[20],m,n;
    re int now;re ll sum;
	cin>>n>>m;
	F(i,1,m) rd(a[i]);
	sum=n;F(i,1,m) b[i]=n;now=0;
	F(i,1,m) {int t=b[i]/a[i];b[i]-=t*a[i];now=now+t;}
	int k=0,lstnow=0;
	while(now>0)
	{
		sum+=now;F(i,1,m) b[i]+=now;lstnow=now;now=0;
		F(i,1,m) {int t=b[i]/a[i];b[i]-=t*a[i];now+=t;}
		if(n<=now) {puts("Inf");return 0;}
		if(lstnow==now) {++k;if(k>1000000) {puts("Inf");return 0;}}else k=0;
	}
	printf("%lld\n",sum);
	return 0;
}
```


---

## 作者：爱晚亭哦 (赞：24)

**~~第十个点真的恶心~~**


------------
本题思维难度是橙题没错，但这第十个点和这通过率不让它止步于橙题啊![](https://cdn.luogu.org/upload/pic/62023.png)![](https://cdn.luogu.org/upload/pic/62023.png)![](https://cdn.luogu.org/upload/pic/62023.png)

**正题：本题模拟附属物被交换的过程并求解，如果不能白嫖其每一轮换的快乐水数一定小于n，否则Inf。**

注意：

1.开$long\;long$

2.最后一个点又卡时间又卡正确性，如果是像我一样的方法就乖乖循环$28000000$次吧，如果是隔壁题解类型的就去参考他的。

~~亲测$28000000$能过~~

~~说到底还是自己菜嘛~~![](https://cdn.luogu.org/upload/pic/62023.png)

具体康注释

$Code:$

```
#include<cstdio>
int a[6],b[6];//b数组是当前第i个附属品数
int n,m,sum=0,summ=0;//summ是本轮换的快乐水数
long long ans=0;//记得long long
int main()
{
    scanf("%d %d",&n,&m);
    ans+=n;//开局买几瓶就喝几瓶
    sum=n;//sum是上一轮换的快乐水数
    for(int i=1;i<=m;i++)
        scanf("%d",&a[i]);
    for(int j=1;j<=28000001;j++)//我试了好久才试出来的TAT
    {
        for(int i=1;i<=m;i++)
        {
            b[i]+=sum;//加上上轮瓶子数
            summ=summ+b[i]/a[i];
            b[i]%=a[i];
        }
        if(summ>=n)//核心，如果不能白嫖其一轮换的快乐水数一定小于n
        {
        	printf("Inf");
        	return 0;
		}
        sum=summ;
        ans+=summ;
        summ=0;
    }
    printf("%lld",ans);//lld坑了我好几次
    return 0;
}
```
//这么大的常数$Copy$容易被发现哦（van♂笑

---

## 作者：Quan_200605 (赞：4)

无聊来写一写题解吧

比赛的水题:模拟
~~但是第十个数据是真的毒瘤~~
## [题目传送门](https://www.luogu.com.cn/problem/P6022)
### sol
思路很简单,一开始小A有n瓶快乐水,商店有m个附属品(也就是有m种白嫖快乐水的方式),就枚举呗。

枚举每一个附属品,未喝的加上它的权值整除初值,并用它的权值对初值取模。

判断边界,其实也很简单,当每一个附属品的权值都小于初值,就可以退出了
如果没有,就输出“Inf”,即可以无限白嫖快乐水
### code
```cpp
#include<cstdio>
#define ull unsigned long long//防止爆,开了ull,开long long一样
using namespace std;
inline int read(){
	int res=0,sign=1;char ch;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')sign=-1;res=res*10+ch-48;
	while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;
	return res*sign;
}//快读不解释
const int maxn=6;
int n,m;
ull f[maxn];//初值
ull num[maxn];//累计每一个附属品权值
long long bu=0;//计算步数
ull ans=0,weihe=0;//ans记录最多能喝的快乐水,weihe没喝的快乐水
bool flag=true;//判断边界,是否可以无限白嫖
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++)f[i]=read();//读入
	weihe=n;
	ans+=weihe;//已喝n瓶
	for(ull i=1;i<=m;i++)
	 num[i]+=weihe;//累计加上
	weihe=0;
	while(true){
		bu++;
		flag=true;
		for(ull i=1;i<=m;i++)
		 num[i]+=weihe;
		ans+=weihe;//每一步都要加上没喝的快乐水
		weihe=0;
		for(ull i=1;i<=m;i++){
			if(num[i]>=f[i]){
		 	  flag=false;
		 	  break;
		    }
		    if(num[i]<f[i])continue;
		}//判断边界,如果每一个附属品权值都小于初值,即退出
		if(flag)break;
	    for(int i=1;i<=m;i++){
	    	weihe+=num[i]/f[i];
	    	num[i]=num[i]%f[i];
		}//未喝的加上它的权值整除初值,并用它的权值对初值取模
		if(bu==50000000){puts("Inf");return 0;}//如果步数很大,就可以无限白嫖
	} 
	printf("%llu",ans);//输出最多能喝的快乐水
	return 0;
}
```
完结撒花
### [我的博客传送门](https://www.luogu.com.cn/blog/qzw200605/)


---

## 作者：chinaxjh (赞：4)

# 前言
题目不难，需要多尝试（雾），还需要开点挂（大雾）
# 分析
不论遇到什么题，先思考暴力算法

于是我们很快就可以想到一个暴力算法：

> 对于每一轮，一次性喝光所有水，然后判断这一轮可以换到多少水可以给下一轮喝，然后一直到没水可喝为止，如果经历了很多轮还没有结束，那么就大概率是可以无限白嫖了

问题就在于轮数上线的极值应该定为多少

我看到赛场上好多人$90$，应该都是上线定小了，导致最后一个点过不去

我也是一个一个试的，一直调到$30000000$，看了看时限，感觉不稳，于是又开了$O(2)$，赌了一把，最后过了

后来看作者的题解好像他是在最后一个点故意卡的，不得不吐槽出题人的$Duliu$
# $\text{Tips}$
开$\color{red}\text{long long}$
# $\text{Code}$
```cpp
//要开O(2)才可以过
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,i,ans,nn,j,a[10],b[10];
int main()
{
	cin>>n>>m;
	for (i=1;i<=m;i++)
	cin>>a[i];
	for (i=1;i<=30000000;i++)//30000000轮
	{
		ans+=n;//累加答案
		if (n==0) {
			cout<<ans<<endl;
			return 0;
		}//喝完了就退出循环
		nn=n;
		n=0;
		for (j=1;j<=m;j++)
		{
			n+=(b[j]+nn)/a[j];
			b[j]=(b[j]+nn)%a[j];
		}//计算新得到快乐水和剩下的附属品
	}
	puts("Inf");/无数轮之后还不行就大概率是可以无限白嫖
	return 0;
}
```
# 后言
大家一定要有开大上线+各种卡常和题目殊死一搏的决心，有可能上线调大一点就可以骗到所有的分数

---


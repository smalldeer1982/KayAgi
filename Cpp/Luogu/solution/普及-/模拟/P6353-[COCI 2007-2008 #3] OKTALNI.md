# [COCI 2007/2008 #3] OKTALNI

## 题目描述

给你一个二进制的数字，请将其转换到八进制。

---

可以使用如下转换方法：

- 如果二进制的数字的位数不能被三整除，则在左侧补 $0$ 直到数字位数是 $3$ 的倍数。
- 将这个二进制数每三位分成一组。
- 每组的二进制可用如下表格所示的数字替换。

![](https://cdn.luogu.com.cn/upload/image_hosting/tcwf1oqm.png)

现在请你完成这个操作，并输出最终的八进制结果。

## 说明/提示

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T2 OKTALNI***。

## 样例 #1

### 输入

```
1010```

### 输出

```
12```

## 样例 #2

### 输入

```
11001100```

### 输出

```
314```

# 题解

## 作者：ZolaWatle (赞：5)

## P6353 题解

$ \ \ \ \ \ \ \ $本题的题目描述十分简洁：

$ \ \ \ \ \ \ \ $ _给你一个二进制的数字，请将其转换到八进制。_ 
 
$ \ \ \ \ \ \ \ $这便是一道很简单的**进制转换**题。

$ \ \ \ \ \ \ \ $解决这道题目，本蒟蒻使用了两种方法，先来看第一种。

------------

### Fa♂一：

$ \ \ \ \ \ \ \ $我们可以用现将题中给出的**二进制**数，先转换成**十进制**数，再转换成**八进制**数。

$ \ \ \ \ \ \ \ $对于**2-10**的转换，我们使用“**乘权相加**”的方法；

$ \ \ \ \ \ \ \ $而对于**10-8**的转换，我们可以利用一个栈，使用“**除权取余倒排**”的方法。

$ \ \ \ \ \ \ \ $在这里不过多赘述，如果还不知道这些算法的，可以前往[P1143 进制转换](https://www.luogu.com.cn/problem/P1143)学习。

$ \ \ \ \ \ \ \ $下面给出这种算法的**部分**代码：

```cpp
std::cin>>a;
l=a.length();  //使用string类型存储初始的二进制数 
	
for(int i=l-1;i>=0;i--)  //字符串的最后一个字符代表的是权值最小的数位 
{
	num=a[i]-48;  //将字符转化为数值(num=a[i]-'0') 
	ten+=num*mpow(2,l-i-1);  //mpow指乘方运算，当然，可以使用快速幂 
}
	
while(ten>0)  //将十进制转换为八进制 
{
	b[++t]=ten%8;  //取余 
	ten/=8;  //除权 
}
	
for(re i=t;i>=1;i--)  //倒排 
	std::cout<<b[i];
```

------------

### Fa♂二：

$ \ \ \ \ \ \ \ $既然题中已经说明了将二进制转换为八进制的具体操作流程，我们可以按照题中所说的方法进行转换。

$ \ \ \ \ \ \ \ $~~提示不是白给的~~

$ \ \ \ \ \ \ \ $那么按照题中的说法，我们大可以这样做这道题：

$ \ \ \ \ \ \ \ $首先，我们考虑在原二进制数前添加前导零的情况：

- 设原二进制数的位数为 $ l $，在原二进制数前需要补 $ k $ 个前导零。

- 当 $ l $ 能被 $ 3 $ 整除时，$ k=0 $

- 在其他情况下，$ k=3-l $ % $ 3 $

$ \ \ \ \ \ \ \ $这个结论很容易就能得出，在这里就不细说了。

$ \ \ \ \ \ \ \ $那么我们可以得到以下的代码：

```cpp
k=3-l%3;
if(l%3==0)
	k=0;
```

------------

$ \ \ \ \ \ \ \ $我们可以定义一个 $ string $ 类型的变量 $ a $，表示添加前导零后的二进制数，很容易得到，新的位数 $ l' $ 是等于 $ l $ + $ k $ 的。

$ \ \ \ \ \ \ \ $这个过程的代码：

```cpp
for(long long i=1;i<=k;i++)  //开long long只是为了保险 
	a+="0";  //+=，string类型基本操作 
for(long long i=k+1;i<=l+k;i++)
	a+=str[i-k-1];
//这里的str表示原二进制数 
```

------------

$ \ \ \ \ \ \ \ $接下来，我们按照题中所说，把新得到的二进制数三位三位地分组，再判断每一组表示八进制中的哪个数字。

$ \ \ \ \ \ \ \ $有些细节东西还是得看注释：

```cpp
long long i=0;
while(i<l)  //防止越界 
{
	string tmp="";  //定义临时变量，存每一组数 
	for(re j=1;j<=3;j++)  //三个三个分一组 
	{
		tmp+=a[i];
		i++;  //当前位置扫描过，++。 
	}
	if(tmp=="000") std::cout<<0;
	else if(tmp=="001") std::cout<<1;
	else if(tmp=="010") std::cout<<2;
	else if(tmp=="011") std::cout<<3;
	else if(tmp=="100") std::cout<<4;
	else if(tmp=="101") std::cout<<5;
	else if(tmp=="110") std::cout<<6;
	else if(tmp=="111") std::cout<<7;
	//无脑判断即可。 
}
```

------------

$ \ \ \ \ \ \ \ $这就是做道题的思路及方法，完整代码就不贴了。

$ \ \ \ \ \ \ \ $双倍经验：[P1143 进制转换](https://www.luogu.com.cn/problem/P1143)

------------

希望疫情早日过去!

---

## 作者：Vanyun (赞：4)

## 题意

有一个位数$\leq100$的二进制数，把他转化为八进制数。

## 思路

很容易想到把二进制转为十进制，再把十进制转为八进制。

但因为位数$\leq 100$， 所以十进制数的极限值为$2^{100}$。

我们知道long long的极限值为$2^{63}-1$，即使是unsigned long long 也是$2^{64}$。

这样一来是完全装不下的。除非写高精。~~不会不会吧不会真的有人想写高精吧？~~

根据题面里的表格我们可以发现，其实每$3$个的二级制数等于一个八进制数。

![](https://cdn.luogu.com.cn/upload/image_hosting/tcwf1oqm.png)

**显然**我们可以每$3$个二进制数直接转化为八进制数。

因为二进制数的位数不一定是$3$的倍数，所以我们要补前导$0$。

思路已经很明显啦qwq。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

string s;

signed main(){
	cin >> s;
	while(s.length()%3) s = '0'+s;
	for(int i = 0; i < s.length(); i ++){
		if(i%3 != 2) continue;
		for(int j = 2, num = 0; ~j; j --){
			num += (s[i-j]-'0') ? (int)pow(2,j) : 0;
			if(!j) printf("%d", num);
		}
	}
	return 0;
}
```

[安利一下博客](https://www.cnblogs.com/Vanyun/)

没啦qwq。![](https://p.pstatp.com/origin/13883000009aadaf77fa4)

---

## 作者：Terraria (赞：3)

说句实话，这道题因为提示而 ~~送分~~。

因为这个二进制数的长度会小于等于$100$，用 $long$ $long$ 都存不下，因此最基本的二进制转十进制再转八进制肯定是行不通的。所以我们要再看看题面——

- $Step.1$ 如果二进制的数字的位数不能被三整除，则在左侧补 0 直到数字位数是 3 的倍数。

- $Step.2$ 将这个二进制数每三位分成一组。

- $Step.3$ 每组的二进制可用如下表格所示的数字替换。

![送分？](https://cdn.luogu.com.cn/upload/image_hosting/tcwf1oqm.png)

有了这个，还怕做不出来？~~（也就多打一些 $if$ 的事情罢了）~~

好了，步入正题，讲一下实现步骤——

$C++$ 里万能的 $STL$ 里有一个 $string$，简直为我们带来了福利。

大致用法如下（由于我们只需要用到以下几种，就不过多赘述了）：

```cpp
#include<string>//首先要有头文件【#include<bits/stdc++.h> 也可以】
using namespace std;
int main(){
    string s;//定义一个string类型的字符串
    cin>>s;//输入：abc
    cout<<s.length()<<endl;//输出字符的长度：3
    cout<<s[0]<<" "<<s[1]<<endl;//输出对应下标的字符：a b（下标从0开始，且不是字符串）
    s=s+'1';
    cout<<s<<endl;//输出：abc1
    s='0'+s;//把0拼到字符串s的前面
    cout<<s;//输出0abc1
}
```
有了这些，再按照提示，就能做出来啦！

# Code：

```cpp
#include<bits/stdc++.h>//万能头万岁！
using namespace std;
int main(){
    string s;
    cin>>s;
    while(s.length()%3!=0){//如果其长度不为3的倍数
        s='0'+s;//向前补0
    }
    for(int i=0;i<s.length();i++){
        if(i%3==2){//激动人心的if来啦(依照表格就好了)
            if(s[i-2]=='0'&&s[i-1]=='0'&&s[i]=='0') cout<<0;
            if(s[i-2]=='0'&&s[i-1]=='0'&&s[i]=='1') cout<<1;
            if(s[i-2]=='0'&&s[i-1]=='1'&&s[i]=='0') cout<<2;
            if(s[i-2]=='0'&&s[i-1]=='1'&&s[i]=='1') cout<<3;
            if(s[i-2]=='1'&&s[i-1]=='0'&&s[i]=='0') cout<<4;
            if(s[i-2]=='1'&&s[i-1]=='0'&&s[i]=='1') cout<<5;
            if(s[i-2]=='1'&&s[i-1]=='1'&&s[i]=='0') cout<<6;
            if(s[i-2]=='1'&&s[i-1]=='1'&&s[i]=='1') cout<<7;
        }
    }
    return 0;
}
```
~~（看懂再抄）~~

~~（求过~）~~

---

## 作者：一只书虫仔 (赞：3)

#### Description

> 给定一个二进制数，转化为八进制数。

#### Solution

题解为啥全是转十进制再转八进制啊 ……

直接二转八不好吗 ……

---

按照题目的内容，直接打表，用字符串输入，因为位数最大到 $100$。

但是，有的时候，字符串的长度不为 $3$ 的倍数，会导致直接打表错误。

所以我们要补一些前导 $0$。

首先我们看字符串的长度膜 $3$ 余几，如果余 $1$ 就肯定是 $001$，如果余 $2$ 那就可能是 $010$，$011$ 中的一个。

假设字符串长度膜 $3$ 余 $k$，我们只需要补充 $3-k$ 个前导 $0$。

补充完了就可以大肆打表了。

在打表的时候可以用一些奇技淫巧，也可以直接暴力，特判三位分别为什么，然后加到输出数组里。

By Shuchong   
2020.9.5

---

## 作者：冰糖鸽子 (赞：1)

[AC记录](https://www.luogu.com.cn/record/38876074)

#### 思路分析

二转八有很多方法，比如二转十转八，但是：

`可以使用如下转换方法：`

题目都给你方法了就用呗

#### 具体实现

- 第一步

在原字符串前加 `3-(sl)%3` （`sl=s.length()`）个 $0$

很明显我们可以使用字符串的 `+` ，意思是把一个字符串接到另一个字符串的后面

但是我们要实现的是在前面加字符，所以需要先弄好有 $0$ 的字符串，然后在其后面接上原字符串

代码：

```
	cin >> s;
	sl = s.length();
	if(sl%3!=0)
	{
		for(int i = 0;i < 3-(sl%3);i++)
		{
			f+='0';
		}
		sl+=f.length();
		f+=s;
		s=f;
	}
```

这时的字符串 $s$ 就补好 $0$ 了

- 第二步&第三步

因为这两步代码是一起的，所以一起讲

第二步可以简单粗暴的在 for 里 写 `i+=3`，之后每次 $f$ 都赋为 `s[i]+s[i+1]+s[i+2]` 即可

第三步为了代码简洁可以使用 $map$

代码：

```
	map赋值：

	m["000"]="0";
	m["001"]="1";
	m["010"]="2";
	m["011"]="3";
	m["100"]="4";
	m["101"]="5";
	m["110"]="6";
	m["111"]="7";
    
    转换进制：
    
    
	for(int i = 0;i < sl;i+=3)
	{
		f="";
		f+=s[i];
		f+=s[i+1];
		f+=s[i+2];
		ans+=m[f];
	}
	cout << ans;
```

---

## 作者：WanderingTrader (赞：1)

### 题目分析
这题有两种方法：
1. 先二转十，然后十转八  
这是一种比较基础的做法，这里就不做讲解了
2. 直接二转八  
为什么可以直接转换呢？  
因为 $\log_28=3$ 是一个正整数。  
举个栗子：`35`  
它拉成二进制是`100011`，拉成八进制是`43`。  
有什么发现吗？  
把`100011`每隔 $3($也就是 $\log_28)$ 位一断，即为  
`100 011`  
每段分别转成八进制，即为  
`4 3`  
诶？拼接起来以后和原数的八进制值一样啊？  
没错，这就是直接转换的奥秘。
### 代码
我们先用一个map把三位二进制转换成十进制整数：
```cpp
map <string,int> m;
int main()
{
	string str;
	cin>>str;
	m["000"]=0;
	m["001"]=1;
	m["010"]=2;
	m["011"]=3;
	m["100"]=4;
	m["101"]=5;
	m["110"]=6;
	m["111"]=7;
}
```
这里又有一个问题了：万一字符串长度不是3的倍数怎么办？  
给“扩容”不就行了  
比如`10`，它转成二进制是`1010`，那我们就在前面加2个0，`001010`，这样既不影响数值，又能方便的计算。
```cpp
	int n=str.length();str="0"+str;
	while(n%3){str="0"+str;++n;}
```
最后我们三位一断输出即可，可以采用string头文件里的substr函数（当然边做边删也是一种方法，这里就不展示了）
```cpp
	for(int i=1;i<=n;i+=3)
		printf("%d",m[str.substr(i,3)]);
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
map <string,int> m;
int main()
{
	string str;
	cin>>str;
	m["000"]=0;
	m["001"]=1;
	m["010"]=2;
	m["011"]=3;
	m["100"]=4;
	m["101"]=5;
	m["110"]=6;
	m["111"]=7;
	int n=str.length();str="0"+str;
	while(n%3){str="0"+str;++n;}
	for(int i=1;i<=n;i+=3)
		printf("%d",m[str.substr(i,3)]);
	return 0;
}
```
$$\texttt{The End.}$$

---

## 作者：hensier (赞：1)

我们只需要根据题目的提示，顺藤摸瓜地写出代码即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100],len,m;
int main()
{
    while(scanf("%1d",&a[++len])!=EOF);
    //注意，%1d可以接收单数位的整型变量
    len--;//++len在输入结束后还会再加1，所以将其减去
    if(len%3)//如果这里不特判，那么程序会在整个二进制数前加上3个0
    {
        m=3-len%3;//需要在整个二进制数前增加的0的个数
        for(int i=len;i;i--)a[i+m]=a[i];//整体把数组向右移动m个下标
        for(int i=1;i<=m;i++)a[i]=0;//在前面补0
    }
    for(int i=1,x;i<=len+m;i+=3)
    {
        x=(a[i]<<6)+(a[i]<<5)+(a[i]<<2)+(a[i+1]<<3)+(a[i+1]<<1)+a[i+2];
        //仿照快读，等同于x=100*a[i]+10*a[i+1]+a[i+2]
        switch(x)//switch语句判断属于哪一类型的八进制数位
        {
            case 0:putchar('0');break;
            case 1:putchar('1');break;
            case 10:putchar('2');break;
            case 11:putchar('3');break;
            case 100:putchar('4');break;
            case 101:putchar('5');break;
            case 110:putchar('6');break;
            case 111:putchar('7');break;
            //default:puts("Luogu is the best!");
        }
    }
}
```

当然，我们还可以借助于$\text{Python}$（$2,3$都支持）的$\text{print}$语句的特性，一行解决问题。

```python
print('%o' % int(str(input()), base = 2))

'''
%o表示以八进制形式输出。

int(x, base)这个函数中，x为字符串，base为进制。
它可以把任意一个进制的数（字符串形式）转换成一个十进制int类型的数。

这行代码的实质：以字符串形式读入二进制数，然后用int函数转换成十进制数，最后直接以八进制形式输出这个十进制数。
'''
```

---

## 作者：鸿飞 (赞：1)

## PART1:题意简述
给你一个二进制数，把它转换为八进制数。
## PART2:思路
很明显，根据数据范围（保证位数不超过 100），最朴素的暴力是不可行的。

所以，可以考虑使用字符串进行模拟。

首先，在字符串的前面加上一些0，使得字符串的位数变成3的倍数；

然后三位三位读取，再和下表里左边的数的比较并输出相应的右边的数；

![](https://cdn.luogu.com.cn/upload/image_hosting/tcwf1oqm.png)

好了，就这么多。
## PART3:代码
```cpp
#include<iostream>
#include<string>//字符串头文件
using namespace std;
string a;
int main(){

	cin >> a ;//输入
    
   	//位数不能被三整除，则在左侧补0直到位数是3的倍数
    
	if(a.length()%3!=0)//如果字符串的位数不是3的倍数
	{
		for(int i=1;i<=a.length()%3;i++)//补0
		{
			a="0"+a;//字符串基本操作：拼接
		}
	}
    
    //核心部分：比较并输出
    
	string s;
	for(int i=0;i<a.length()/3;i++)//三位三位判断，所以要把长度除以3
	{
		s="";
		for(int j=0;j<3;j++)//读取当前要判断的三位数
		{
			s+=a[i*3+j];
		}
		if(s=="000")//无聊又枯燥的比较部分
		{
			cout << 0 ;
		}else if(s=="001")
		{
			cout << 1 ;
		}else if(s=="010")
		{
			cout << 2 ;
		}else if(s=="011")
		{
			cout << 3 ;
		}else if(s=="100")
		{
			cout << 4 ;
		}else if(s=="101")
		{
			cout << 5 ;
		}else if(s=="110")
		{
			cout << 6 ;
		}else if(s=="111")
		{
			cout << 7 ;
		}
	}
	
	return 0;
}

```




---

## 作者：SisconHL (赞：1)

> 好气哦。

> 最烦那种不告诉换没换行的了。

咳咳……

基本上可以算是模拟题了

涉及到：

- 序列反转

- 转换进制

由于本人的奇怪癖好，序列反转我喜欢用栈。

于是我们就聊聊：

- 栈

>**栈**是一种**后进先出**（LIFO，last in first out）的线性表，其限制是**仅允许在表的一端进行插入和删除运算**
>>					——kkksc03《深入浅出》
（补：应该是“插入和删除操作”）

您也可以把栈理解成这样：
![whydoyouf12](https://i.loli.net/2019/11/11/RSO4JIFB9ngixba.png)
（当然一个数据结构是不会说话的）

这只想表达三点：

- **堆栈溢出**（stack overflow）**是致命的**，它会导致RE,使用STL里的栈一般不用担心它，如果用STL的栈，需要头文件stack。

- 靠近栈底的元素总比更远离栈底的元素更晚出栈

- 栈只可以对栈顶及它以上的一格空间进行修改（但一般手写栈会加上清空栈的函数）

把所有元素压进栈，然后取出就可以反转啦！

观察到：（abc）$_2$=(a*4+b*2+c)$_8$，为省时，也可以用位运算。

上代码：

```cpp
#include<stdio.h>
#include<iostream>

const int maxn = 100 + 10; 

struct Stack
{
	int a[ maxn ];
	int p;
	Stack()
	{
		p = 0;
	}
	inline int pop()
	{
		if( p )	p--;
		else printf( "stack overflow!" );
		int x = a[ p ];
		return x;
	}
	inline void push( int x )
	{
		a[ p++ ] = x; 
	} 
	inline int size()
	{
		return p;
	}
	inline void clear()
	{
		p = 0;
	}
};

Stack st , sta;

int main( void )
{
	std::string str;
	std::cin >> str;
	int len = str.length();
	char c;
	int p = 0; 
	while( p < len )
	{
		c = str[ p ];
		st.push( c - '0' );
		p++;
	}
	int qwq , qaq , awa;
	while( st.size() > 2 )
	{
		qwq = st.pop();
		qaq = st.pop();
		awa = st.pop();
		sta.push( qwq + ( qaq << 1 ) + ( awa << 2 ) );
	}
	qwq = 0;
	qaq = 0;
	int x = st.size();
	if( st.size() )	qwq = st.pop();
	if( st.size() )	qaq = st.pop();
	if( x )	sta.push( qwq + ( qaq << 1 ) );
	while( sta.size() ) printf( "%d" , sta.pop() );
}
```

---

## 作者：CSP_Sept (赞：1)

很明显，这是一道进制转换题（$(\ )_2\to(\ )_8$）。

既然题目中给了转换方法，~~我们当然不能浪费~~。

**用 map 存储题目中的表格**，用 $l$ 记录输入二进制数的长度，则有如下可能：

- $l\bmod 3=1$，则在输入二进制数前补 `00`。
- $l\bmod 3=2$，则在输入二进制数前补 `0`。
- $l\bmod 3=0$，则不作如何改变。

## map 的基本用法
##### map 相当于一个下标可以是任何类型的数组。

1. `#include <map>` map 头文件。

1. `map <A,B> ds` 建立一个叫 `ds` 的，下标类型为 `A` ，元素类型为 `B` 的映射表。

1. `ds[t1]=t2` 把下标为 `t1` 对应的值改为 `t2` 。

1. `ds[A]` 访问下标为 `A` 的元素。
__________________________________________________
然后拆分密码串即可，拆分密码串使用 string 的 `.substr(pos,len)` 函数实现。用法：`s.substr(pos,len)`：截取字符串 $s$ 从第 $pos$ 个位置 （位置从 $0$ 开始）开始的 $len$ 个字符，并返回为 string 类型。在这道题中 $len=3$。

代码：

```cpp
#include <iostream>
#include <map>
#include <cstring>

using namespace std;
map <string,int> ds;
string s;
int main(){
    cin>>s;
    ds["000"]=0;ds["001"]=1;ds["010"]=2;ds["011"]=3;ds["100"]=4;ds["101"]=5;ds["110"]=6;ds["111"]=7;/*预处理*/
    int l=s.size();
    if(l%3==2) s="0"+s;
    else if(l%3==1) s="00"+s;
    for(int i=0;i<s.size();i+=3){
        string t=s.substr(i,3);//拆分
        cout<<ds[t];
    }
    return 0;
}
```

---

## 作者：asasas (赞：0)

受下面两位大佬的启发，我也是用map+stringAC此题的。

map是STL库里的一种容器，可以理解为hash表，但它能支持不同类型之间的转化（如int对long long,int对char等），是十分强大的。

同样，string也是STL库里的一种容器（~~STL这么厉害~~），是用来存储字符串，处理字符串的一种容器，十分方便。
有兴趣的同学可以上网查一查。

这题用stringc存储处理字符串，按照题目建一个map， 将每种八进制的二进制存起来，三位三位的处理即可。
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
map <string,int> a;	
string ans,r,qq;
int main(){
a["000"]=0;
a["001"]=1;
a["010"]=2;
a["011"]=3;
a["100"]=4;
a["101"]=5;
a["110"]=6;
a["111"]=7;//以上都是预处理
	cin >> r;	
	int n=r.size();//要先将原来的长度存，否则有可能会加两次
	if (n%3==1)  r="00"+r;
	else if (n%3==2)  r="0"+r;//两种特殊情况
	n=r.size();
	for (int i=0;i<r.size();i+=3){
		qq="";//每次都要初始化
		for (int j=i;j<i+3;j++){
			qq=qq+r[j];//我没有用string自带的截取函数，自己手写的，很容易写
		}
     cout  << a[qq];//每次都输出，你也可以存起来最后一次输出
	}
}
```



---


# [COCI 2007/2008 #3] TAJNA

## 题目描述

使用一种加密算法。

设字符串的长度为 $n$，则构造一个矩阵，使得 $r\times c=n$ 且在 $r\le c$ 的情况下使得 $r$ 尽量大。

然后把给定的明文按照由上到下，从左到右的顺序填充这个 $r\times c$ 的矩阵。

得到的密文就是把矩阵按照从左到右，从上到下的顺序输出的字符串。

给定你明文，请你输出密文。

## 说明/提示

#### 样例 3 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/n13lgixw.png)

共 $16$ 个字符，对于矩阵的长宽，可以选择 $1\times 16$，$2\times 8$ 和 $4\times 4$ 这三种，因为要求 $r$ 尽量大，所以选择 $4\times 4$。

然后进行填充，填充的结果如上图所示。

最后从左到右，从上到下输出每个字符即可。 

#### 数据规模与约定

对于 $100\%$ 的数据，保证输入字符串只含小写字母，长度不超过 $100$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T3 TAJNA***。

## 样例 #1

### 输入

```
bok```

### 输出

```
bok```

## 样例 #2

### 输入

```
koaski```

### 输出

```
kakosi```

## 样例 #3

### 输入

```
boudonuimilcbsai```

### 输出

```
bombonisuuladici```

# 题解

## 作者：追梦之鲸 (赞：12)

### 这是本蒟蒻的第$01$篇题解。

# 管理大大求过QAQ。

### 思路

**其实这道题可以不写模拟**

那么有人就要问了，不写模拟在原字符串上直接输出也可以，可是这个位置怎么办呢？没关系，现在我来教你怎么算位置。(为了方便，我们用数字表示)

$1234→1324$

$123456→135246$

$123456789→147258369$

发现什么了吗，如果没发现，那么下面我会给你更详细的解说。

$1,2,3,4 → 1,1+2,2,2+2$

$1,2,3,4,5,6→1,1+2,1+2+2,2,2+2,2+2+2$

$1,2,3,4,5,6,7,8,9→1,1+3,1+3+3,2,2+3,2+3+3,3,3+3,3+3+3$

是不是恍然大悟？


### Code：
~~~cpp
#include<bits/stdc++.h>//无敌头文件，你值得拥有
using namespace std;
string n;
bool k[101];//防止一些奇怪的错误，本蒟蒻也不知为何
int a=1,b=1,x,ks;//a,b是长方形的长和宽，x是n的位数，ks是指针
int main(){
	cin>>n;
	x=n.size();
	//求长和宽
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			a=i;
			b=x/i;
		}
	}
	//重点来了！
	for(int i=1;i<=a;i++){
		while(k[ks]){
			ks++;
		}
 		//防止一些bug
		cout<<n[ks];
		k[ks]=1;
		for(int j=1;j<b;j++){
			cout<<n[ks+j*a];//这就是我前面讲了大半天的东东
			k[ks+j*a]=1;
		}
	}
    return 0;
    禁止抄袭！！！
}
~~~

管理大大求过啊……

---

## 作者：小坦克 (赞：7)

### 本蒟蒻第一次写题解，请各位大佬谅解！！！
-------------
[题目传送门](https://www.luogu.com.cn/problem/P6354)
-------------
首先，我想说，这真是一道简单到不能简单的枚举题

（详细一点就是：**字符串**枚举题）

题目要求构造一个矩阵，使得 $r×c=n$ 且在 $r≤c$ 的情况下使得 $r$ 尽量大，所以我们可以得到：$r≤\sqrt[]n$ 也就是 $r$ 最大为 $\sqrt[]n$。

-------------
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
int n;
string s;
char si[110][110];
int main(){
    cin>>s;
    int len=s.size();
    for(int i=sqrt(len);i>0;i--)
        if(len%i==0){
			m=i;
			n=len/i;
			break;
		}
    int t=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
        	si[j][i]=s[t];
			t++;
		}
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++) printf("%c",si[i][j]);
    return 0;
}
```

## 如果有不好的地方，请大佬提出，谢谢！

---

## 作者：囧仙 (赞：7)

这里介绍用 C++ STL 中的 string 类型，头文件 `string` / `cstring`。

首先输入密文 $s$，$s$ 是一个 string 类型，要用 `iostream` 库中 `cin>>s` 输入流输入。

长度 $l$ 用 `cstring` 库中的 `.size()` 函数计算，因为要使 $r$ 尽可能大，则让 $r$ 从 $\sqrt{l}$ 开始，依次减一，直到 $l\bmod r=0$ 为止，这时，$c=\dfrac{l}{r}$。

使用数组 $a_{i,j}$ 存储矩阵，存储代码如下：

```cpp
for(int i=1;i<=c;i++)
    for(int j=1;j<=r;j++)
        a[j][i]=s[tmp],tmp=tmp+1;//注意是a[j][i],tmp要+1
```

然后输出即可，完整代码：

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>

using namespace std;
string s;
int r,c;
char a[110][110];
int main(){
    cin>>s;
    int l=s.size();
    for(int i=sqrt(l);i>0;i--){
        if(l%i==0){r=i;c=l/i;break;}
    }
    int tmp=0;
    for(int i=0;i<c;i++)
        for(int j=0;j<r;j++)
            a[j][i]=s[tmp],tmp=tmp+1;
    for(int i=0;i<r;i++)//输出
        for(int j=0;j<c;j++)
            cout<<a[i][j];
    return 0;
}
```

---

## 作者：zct_sky (赞：3)

## 本蒟蒻的第一篇题解

#### [题目传送门](https://www.luogu.com.cn/problem/P6354)

### 思路：

首先，根据题目要求构造一个矩阵，使得 $r×c=n$ 且在 $r≤c$ 的情况下使得 $r$ 尽量大。也就是说 $r≤ \sqrt{n} $ ,所以 $r$ 最大等于 $\sqrt{n}$。

求出 $r$ 和 $c$ 之后，按照列优先存入，再按照行优先输出即可。

### AC代码：

```c++
#include<bits/stdc++.h>//万能头 
using namespace std;
string a;
int l,n,m,k;
char c[101][101];
int main(){
	cin>>a;//输入 
	l=a.length();//求字符串长度 
	for(n=int(sqrt(l));n>=1;n--){//求出长(c)和宽(r) 
		if(l%n==0){
			m=l/n;
			break;
		}
	}
	for(int i=0;i<m;i++)
		for(int j=0;j<n;j++)//按照列优先存入 
			c[j][i]=a[k++];
	for(int i=0;i<n;i++)
	    for(int j=0;j<m;j++)//按照行优先输出
	        cout<<c[i][j];
	return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：3)

一道比较简单的字符串模拟。

首先读题。

题目要求我们根据输入的字符串构造一个 $r*c$ 的矩阵。$(r≤c$ &&$r*c=n)$要使 $r$ 尽量大

所以 $r$ 最大可为 $\sqrt{n}$ 

于是

```cpp
	for(int i=sqrt(len);i>=1;i--)
		if(len%i==0)
		{
			r=i,c=len/i;
			break;
		}
```

题目要求我们将明文**由上到下，由左到右**填充矩阵。

于是
```cpp
int num=0;
	for(int i=1;i<=c;i++)
		for(int j=1;j<=r;j++)
			s[j][i]=a[num++];
```

然后把矩阵**从左到右，从上到下**输出。

于是
```cpp
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			cout<<s[i][j];
```
所以完整的代码在下面↓
```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
char a[101],s[101][101];
int r,c;
int main()
{
	cin>>a;
	int len=strlen(a);
	for(int i=sqrt(len);i>=1;i--)
		if(len%i==0)
		{
			r=i,c=len/i;
			break;
		}
	int num=0;
	for(int i=1;i<=c;i++)
		for(int j=1;j<=r;j++)
			s[j][i]=a[num++];
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			cout<<s[i][j];
	return 0;
}

```


------------
$P.S$ 最初窝因为把数组开小了所以挂了最后一个点

![](https://cdn.luogu.com.cn/upload/image_hosting/6ryvugny.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

虽然窝也不知道为什么……

如果有路过的大佬希望珂以在评论区说一下 $reason$ 

$qwq$

---

## 作者：y0y68 (赞：2)

这题主要就两步：求 $r$，$c$ 和按由上到下，从左到右的顺序填充。

第一步，求 $r$，$c$：

题目要使得 $r\times c=n$ 且在 $r\le c$ 的情况下使得 $r$ 尽量大，所以 $r \le \sqrt{n}$，并且 $r$ 要尽量大，于是从 $\sqrt{n}$ 向 $1$ 枚举，如果遇到一个能被 $n$ 整除的数，就将这个数付给 $r$，而将 $n$ 除以这个数的值赋给 $c$，这样就可以保证 $r$ 尽量大了，然后退出循环。

第二步，按由上到下，从左到右的顺序填充：

很简单，先枚举列再枚举行就可以了。

#### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r,c;
//n表示输入字符串的长度
char s[105],a[105][105];
int main(){
	scanf("%s",s+1);
	//读入下标为1字符串的小技巧
	n=strlen(s+1);
	for(int i=sqrt(n);i>=1;i--)
		if(n%i==0){
			r=i;c=n/i;break;
		}
	for(int j=1,k=1;j<=c;j++)
	//k表示下面要填字符串中的第几个字符了
		for(int i=1;i<=r;i++)
		//j表示填充到第几列，i表示填充到第几行
			a[i][j]=s[k],k++;
			//填完字符串s中第k个字符后k要加一
	for(int i=1;i<=r;i++)
		printf("%s",a[i]+1);
		//输出下标为1字符串的小技巧
	puts("");
	//换行的一种简单方式
	return 0;
}
```

---

## 作者：jxbe6666 (赞：1)

一道超级水的的题目。

**题目描述:** 

- 给定一个长度为 $n$ 的字符串，将字符串放进一个 $x$ 行 $y$ 列的矩阵，要保证 $x \times y = n$，$x \leq y$ 的情况下使 $x$ 尽量大。

- 将字符串按列优先存进矩阵。

- 按行优先读出矩阵。

- $n < 100 $  且字符串内都为小写字母。

**题目分析:**  
先找出 $x , y$ 的情况,从中选取 $x$ 最大的情
况,从 $\sqrt n \dots1$ 判断是否可以整除。如果可以整除就直接跳出循环。将字符串行优先存进去,再列优先读出来。

**代码实现**  

AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[105], b[105][105]; // 众所周知 c++ = c + stl
int main()
{
    cin >> a;
    int n, m, len, s = 0;
    len = strlen(a);
    for (int i = sqrt(len); i >= 1; i--)
    { //在sqrt(len) ~ 1 之中找len的最大因数
        if (len % i == 0)
        {
            n = len / i;
            m = i; //最大因数为列
            break; //找到就退出
        }
    }

    //cout << n << " " << m << endl; //调试是一个好习惯

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            b[i][j] = a[s++]; //按照行优先存进去
        }
    }

    
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cout << b[j][i]; //按照列优先读出来
        }
    }
    return 0;
}
```
吐槽一下Vscode的屑缩进 QWQ。  
[AC记录](https://www.luogu.com.cn/record/63312866)



---

## 作者：CarryQwQ (赞：1)

## 题目分析
[题目传送门](https://www.luogu.com.cn/problem/P6354)

[博客食用效果更佳](https://www.luogu.com.cn/blog/ThisIsCYF/solution-p6354)

可以用找规律来做这道题目

首先枚举字符串长度的因数求出矩阵长和宽。

设字符串的长度为 $n$，因为要使 $r$ 尽量大，所以从 $\sqrt{n}$ 开始枚举，下限为 1，当 $n\space\bmod\space i = 0$, 则将 $i$ 的值赋 $r$，由于要使 $r×c=n$，所以 $c=\dfrac{n}{r}$。

求矩阵长和宽的代码如下:


```cpp
for (int i = sqrt(len); i > 0; i--) {
	if (len % i == 0) {
		r = i, c = len/i;
		break;
	}
}
```

然后开始找规律，以输入样例 2 为例。

输入 ```koaski```，得到矩阵长为 3，宽为 2，完成填充之后的矩阵为：

|k |a  |k  |
| :----------- | :----------- | :----------- |
|**o** |**s** |**i**  |

从左往右，从上往下输出 ```kakosi```。

如果将上表中的元素替换成每个字符在原字符串中的位置，得到下表：

|0 |2  |4  |
| :----------- | :----------- | :----------- |
|**1** |**3** |**5**  |

发现每一行都是一个等差数列，长度为 $c$，公差为 $r$，且每个元素 $a_i\leq n$。

假设第一行等差数列开头元素在原字符串中位置为 $pos$,

则第 $n$($n\leq r$)行等差数列开头元素在原字符串中位置则为 $pos+n$。

根据找到的规律直接输出就好了，已知等差数列的第一个元素，用公差构造一个等差数列，元素的值为当前位置的字符在原字符串中的位置。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int r, c, cnt, len;
int main() {
	cin >> s;
	len = s.length();
	for (int i = sqrt(len); i > 0; i--) {
		if (len % i == 0) {
			r = i, c= len/i;
			break;
		}
	}
	for (int i = 1; i <= r i++) {//总共要输出 r 行
		cnt = i-1;//字符串的下标从0开始
		while(1) {
			cout << s[cnt];
			if (cnt + r < len)cnt += r;
			else break;//如果下一个位置大于这个字符串的长度，就退出循环
		}
	}
}
```

---

## 作者：BeetyX (赞：1)

这道题是一个关于字符串的一道水题，方法：暴力模拟。

题意：给你个字符串，然后填充在一个长和宽尽量接近的长方形数组内（从左向右排，排完一排再在第二排开始，排完为止），然后按照另一种顺序输出这个字符串（从上往下输出，输出完一列再输出第二列的）

①长方形长和宽要尽量接近$\sqrt{n}$

②依次把字符串每位都排进二维数组


代码如下
------------
```c
#include <bits/stdc++.h>
using namespace std;
string si;//定义字符串
int r,s;//长方形的长和宽
char ju[105][105];//定义一个字符二维数组
int main()
{
    cin>>si;//输入
    int len=si.length();//len为字符串的长度，方便算长方形的长和宽
    for (int i=1;i*i<=len;i++)//循环，i尽量接近sqrt(n)
    {
        if (len%i==0)//当len可分解的时候
        { 
            s=i;
            r=len/i;
        }
    }
    int ans=0;
    for(int i=0;i<r;i++)
    {
        for(int j=0;j<s;j++) //双层循环赋值到二维数组里
        { 
            ju[i][j]=si[ans];
            ans++;
        }
    }
    for (int i=0;i<s;i++) 
    {
        for (int j=0;j<r;j++)//逆序输出
        { 
            cout <<ju[j][i];
        }
    }
    return 0;
}
```


---

## 作者：CLCK (赞：1)

没什么好说的，按照题意模拟即可。此处采用二维数组模拟表格的形式记录密码，来得出密码。

```cpp
#include <iostream>
using namespace std;
string s;
int l, h;
char ans[105][105];
int main() {
    cin >> s;
    int n = s.size(); //字符数量
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) { //计算长宽，尽可能接近平方根为最大
            h = i;
            l = n / i;
        }
    }
    int cnt = 0;
    for (int i = 0; i < l; i++) {
        for (int j = 0; j < h; j++) { //存字符串
            ans[i][j] = s[cnt++];
        }
    }
    for (int i = 0; i < h; i++) {
        for (int j = 0; j < l; j++) { //换序输出（和上面换下也可）
            cout << ans[j][i];
        }
    }
    return 0;
}
```

---


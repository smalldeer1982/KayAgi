# [COCI 2013/2014 #1] KUŠAČ

## 题目背景

顿顿邀请你来均分香肠啦。

## 题目描述

共有 $n$ 个香肠，需将其平均分给 $m$ 个品尝者。

每刀可将香肠分为两份，要求用尽可能少的刀数切出符合要求的香肠，问至少要切几刀。

## 说明/提示

#### 【样例解释】

#### 样例 1 解释
有 $2$ 个香肠和 $6$ 个品尝者，将每个香肠三等分，共 $4$ 刀。
#### 样例 2 解释
有 $3$ 个香肠，$4$ 个品尝者。将香肠切成 $\tfrac{3}{4}$。前三人拿到 $\tfrac{3}{4}$，最后一人拿到 $3\times \tfrac{1}{4}$。

---

#### 【数据规模与约定】
对于全部的测试点，保证 $1\le n,m\le 100$。

---

#### 【说明】
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #1](https://hsin.hr/coci/archive/2013_2014/contest1_tasks.pdf)  _T2 KUŠAČ_。**

## 样例 #1

### 输入

```
2 6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 4```

### 输出

```
3```

## 样例 #3

### 输入

```
6 2```

### 输出

```
0```

# 题解

## 作者：Miller2019 (赞：15)

题意：求把 $\ n$ 根香肠切成 $\ m$ 分所需的刀数。

思路：如果切的地方刚好在连接的地方，就可以减去一刀。先假设需要切 $\ m-1$ (本来的次数) 刀，然后再减去 $\ n$ 和 $\ m$ 的最大公约数(重叠的部分)，再加上末尾的一刀。所以说答案就是 $\ m$ 减去 $\ m , n $  的最大公因数。

```cpp
#include<stdio.h>
int gcd(int a,int b) //log(min(a,b))
{
	return b?gcd(b,a%b):a;
}
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	printf("%d",m-gcd(n,m));
	return 0;
}
```

蒟蒻橙后第 10 篇题解。

---

## 作者：⚡小林子⚡ (赞：9)

感觉这题应该评红啊

[题目传送门](https://www.luogu.com.cn/problem/P6536)

切香肠，每个人的香肠香肠不一定要连续。

看到题可以知道每个人分 $\frac{N}{M}$ 根香肠。

假设 $N=4,M=6$ ，

那现在就把香肠连起来，就像这样：

▀▀▀▀▀▀|▀▀▀▀▀▀|▀▀▀▀▀▀|▀▀▀▀▀▀

每个人分 $\frac{2}{3}$ 根，就像这样：

▀▀▀▀ ▀▀|▀▀ ▀▀▀▀|▀▀▀▀ ▀▀|▀▀ ▀▀▀▀|

`|`是第一次自动分的，空格是第二次分的。

中间那个好像在一块欸！

正常是要切 $M-1$ 次的，然后`最大公约数`这个神奇的东西忙我们省去了 $\gcd(N,M)-1$ 次操作，所以最终答案 $\operatorname{ans}=(M-1)-(\gcd(N,M)-1)=M-\gcd(N,M)$

上 Code：

```cpp
#include<iostream>
using namespace std;
int n,m;
int gcd(int n,int m){
	return n%m==0?m:gcd(m,n%m);  //递归式 gcd 
}
int main(){
	cin>>n>>m;
	cout<<m-gcd(n,m);            //输入输出 
	return 0;                    //结束程序 
}
```

[AC！](https://www.luogu.com.cn/record/33893656)

留下您的点赞再走吧，886！

---

## 作者：sh7adow_ (赞：5)

$$\text{Analysis and solution}$$

咋一看，这道题还是蛮简单的。有些人认为直接给出 $\dfrac{N}{M}$ 就是答案，我也不是例外。

但是要注意的是： **一刀可将香肠分为两份** ，所以我们可以直接利用模拟来分析：

> 我们可以将**所有香肠首尾接在一起**，成为**一根完整的香肠**，**平均切**就好了。如果需要切的地方是**原来香肠的接口**，这一刀就**不用切**了。

$$\text{Code}$$

这道题还是比较简单的，数据范围比较良心，相信大家一定会弄明白。

下面的代码供大家学习参考用。

```cpp
	cin>>n>>m;
	for(int i=0;i<=n*m;i+=n) if(i%m!=0) ans++;//如果除不尽的话，要切的刀数自增，循环判断更快速。
   	cout<<ans<<endl;
    
```


------------
$$\text{Conclusion}$$

遇到这种看上去简单的题目也是要认真审题的，不要主观臆断的判断事情。

这道题还可以用 $\gcd$ 来做，但是做起来更麻烦一些，最好用最优解来做。


------------

就是这些，我们下周再见！

---

## 作者：Aw顿顿 (赞：3)

供题人前来发一发题解。

## 题目思想
这道题目的注意点如下：

- **一刀可将香肠分为两份。**
- **要求用尽可能少的刀数切出符合要求的香肠。**

是的，这些都被搬题人良心了挑了出来，背景也经过极度简化，所以题目就成了一个模拟题目。

考虑将所有的香肠合在一起，平均分即可，如果刚好在断点上就不需要切。

## 注意事项
这个思想在第二个样例上体现的淋漓尽致，如果代码有 $54$ 分的可以先根据上述要求构造 hack 数据或者构造类似于样例二的数据。

## 代码实现
代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
inline char g(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}inline int read(){
    char c=g();int s=0;
    while(!isdigit(c))c=g();
    while(isdigit(c))s=s*10+c-48,c=g();
    return s;
}inline void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}int n,m,s;
int main(){
    n=read();m=read();
    for(int i=0;i<=n*m;i+=n)if(i%m!=0)s++;
    print(s);
}
```

然后下面的是码风不大一样的官方标程：

```cpp

#include <iostream>
using namespace std;

int main () {
  int n; cin >> n;
  int m; cin >> m;
  int broj_poklapanja = 0;
  for (int i = 1; i < m; ++i)
    broj_poklapanja += (i * n % m == 0);
  cout << m - 1 - broj_poklapanja << endl;
  return 0;
}
```

希望对大家有用，感谢阅读。

---

## 作者：algobase (赞：2)

## 思路
我们可以先把 $N$ 根香肠连接起来。

根据植树问题的方法，切 $M$ 段香肠需要切 $(M-1)$ 次。而本题的难点就是某一刀切的地方正好是第 $i$ 根香肠和第 $i+1$ 根香肠连接的地方。

看大楼下好多大佬用了 $gcd$ ，我就换一种方法来说说吧。

我们可以用一个东西（不知道叫啥好了）来模拟把 $N$ 根香肠连接起来的状态，最大范围为 $N*M$ 。每走一个 $N$ 就判断一下是否是 $M$ 的倍数，如果不是就 $ans++$ 。
## 代码

```cpp
#include <cstdio>

using namespace std;

int n, m, ans;

int main()
{
    scanf("%d %d", &n, &m);
    
    for(int i = 0; i <= n * m; i += n)
    {
    	if(i % m)
    	{
    		ans++;
		}
	}
	
	printf("%d", ans);
	
    return 0;
}

---

## 作者：Utilokasteinn (赞：2)

题目大意：给出n根香肠，平均切成m分要切多少刀。

这道题其实非常简单，一个算式就可以过去了。我们可以把所有的香肠连接在一起，然后去切。如果切的地方刚好在连接的地方，就可以减去一刀。总结一下，就是先假设要切m-1刀，因为一刀两断呗。然后再减去n和m的最大公约数，也就是刚好是重叠的地方。由于在香肠的末尾的那刀也被减去了，实际上末尾根本不用切，所以还要加上一刀。简化话公式就是m减去n和m的最大公约数，代码如下，就不多作解释了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    cout<<m-__gcd(n,m);//__gcd是C++自带的求最大公约数的函数 
    return 0;
}
```
最后，可以去做一下[SP16244 KUSAC - Kusac](https://www.luogu.com.cn/problem/SP16244)双倍经验题，跟这题完全一模一样，还是道省选题！！！(现在可能橙了)谢谢观赏。

---

## 作者：JeffWang2019 (赞：1)

原题：[P6536](https://www.luogu.com.cn/problem/P6536)

我们先假设一下，如果这是整一条香肠，那么只需要$m-1$刀

但这不是一根香肠而是多跟，所以有些重叠的部分，可以同时切，这样就会省掉一些次数，具体为$n$和$m$的最大公约数

最后,答案就是$m-gcd(n,m)$

求最大公约数的函数：

```cpp
//注释在下面的完整代码里
int GCD(int x,int y)
{
    if(y==0)
    {
        return x;
    }
    else
    {
        return GCD(y,x%y);
    }
}
```


数据范围特别小，所以用递归函数完全没有问题

时间复杂度：$log(min(n,m))$

**完整代码如下：**

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n,m,ans;
int GCD(int x,int y)//求最大公约数
{
    if(y==0)//如果前面的x整除了y
    {
        return x;//返回现在的x,也就是上一次函数得出的y,它就是最大公约数
    }
    else//如果没有整除
    {
        return GCD(y,x%y);//取x÷y的余数,继续递归求最大公约数
    }
}
int main()
{
    scanf("%d%d",&n,&m);//输入n和m
    ans=m-GCD(n,m);//求答案
    printf("%d",ans);//输出答案
    return 0;//完美结束
}
```


---

## 作者：CCCloud (赞：1)

### 模拟 

------------
 
**题目大意**：将**n**根香肠平均分成**m**份，求**最少切割**的次数；  
**思路**：手动**将分香肠的过程模拟一遍**；  
**实现方式**：  
1、如果**n%m==0**,即n是m的倍数，那么一次也不用切，**直接分**；  
2、如果**n>m**且**n%m!=0**,即n大于m但n不是m的倍数，那么**将n根香肠先分出m根给每个人**，再分剩下的（**n-m**）根香肠；  
3、因为经历了第2步，所以**m>n**;如果**m%n==0**，那么就**切（m%n-1）刀**；如果**m%n!=0**，那么就切（**m%n**）刀就行了；  
4、将切割之后的每根香肠剩下的部分**再分配**,即把n段香肠平均分成（**m%n**)份；   
5、进行**判断**：如果**m==0**或**n%m==0**，结束循环；否则回到**第2步**；  

------------

#### 代码如下：  
```cpp
#include<cstdio>
using namespace std;

int n, m, ans, a;//定义变量

int main()
{
    scanf("%d%d", &n, &m);//读入n，m
    while(n%m!=0)//判断n是不是m的倍数，如果是直接退出循环
    {
        if(n>m) n=n%m;
        //n大于m但n不是m的倍数，先将n根香肠先分出m根给每个人
        if(m%n==0) a=m/n-1; //如果m%n==0，切（m%n-1）刀
        else a=m/n;//如果m%n!=0，切（m%n）刀

        m=m%n;//再分配
        ans+=a*n;//加上刀数
        if(m==0) break;//判断
        
    }
    printf("%d\n",ans);//输出答案
    return 0；//完美的结束！（最好不要漏掉这句话噢
}

```

---

## 作者：青鸟_Blue_Bird (赞：0)

一道痕简单，但是也比较考思路的题目。

首先，题目给了我们n个香肠，还有m个品尝者。

那么，我们可以用以下思路来考虑：

把n个香肠拼起来，其实就是一根香肠。然后我们切m - 1刀，这样可以保证平均。

然后，想方法把刀数减下去。（有一些地方，是题目帮我们已经切好了的。）没错，就是香肠连接的地方。这些地方很明显是我们不用切的。

所以，我们用m - gcd（n, m）就ok了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;

int gcd(int a, int b){
	return !b ? a : gcd(b, a % b);
}

int main(){
	scanf("%d%d", &n, &m);
	cout << m - gcd(n, m);
	return 0; 
}
```


---

## 作者：_Clown_ (赞：0)

这道题目其实很简单。

我们如果将所有香肠拼在一起，可见至少切M-1刀，可是，有的地方原来已经帮我们切好了。

因此，我们要减去原来切好的刀数。

转念一想，不就是Gcd（n，m）么？

答案可见。

代码(13行)
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int Gcd(int A,int B)
{
	return B==0?A:Gcd(B,A%B);
}
int main()
{
	register int N,M;
	cin>>N>>M;
	cout<<M-Gcd(N,M)<<endl;
	return 0;
}
```

---


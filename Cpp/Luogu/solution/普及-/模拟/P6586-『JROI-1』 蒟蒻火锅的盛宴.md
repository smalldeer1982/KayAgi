# 『JROI-1』 蒟蒻火锅的盛宴

## 题目背景

点击展开阅读更佳，**题目背景与解题无关。**

----------
传说专门服务神仙们的蒟蒻火锅店前面有一首诗：

灶前无用煮青山，不识神炉自往还。

玉碗琼浆谁乞赐，瑶琴银箭可容攀。

风生夜气通云汉，雨歇秋光上碧湾。

却笑老奴真倦眼，此心空处一团闲。

----
Qiuly 是洛谷著名餐厅“蒟蒻火锅店”的主厨，当中的伙计很多，比如呆呆的 Aw 顿顿，机智的 Cocoly1990 还有珂爱的 45dino。Qiuly 喜欢让顿顿为他准备丰富多样的食材，制作火锅的必需品包括但不限于七星章鱼和芥末鱼子酱，当然，还有各种各样珍稀而奇怪的食材：

- 蒟蒻果冻制成的蒟蒻团子。
- 糯米（雾）制成的糯米青团。
- Aw 顿顿制成的菜鸡糕。
- Bamboo（45dino）。

这些食材难以收集，但是神仙 Qiuly 还是全部弄到手了。接下来她要让顿顿**分类这些食材**。但是顿顿是菜鸡，根本不会分类，他崩溃了。于是他请你，IOI 的 AKer，帮助他分类这些食材，因为这个问题事关 Qiuly 的成绩（IOI 第一名还是第二名），所以你必须尽快。

每一个食材都有各种各样的奇怪特性，根据这些特性，Aw 顿顿咨询了全世界的专家们，评价出了**一个食材的美味程度**，根据这个程度可以**有效的分类食材**。如果你不能**在 $\bf 400$ 毫秒内**给出答案，你就会成为一个食材，光荣的沉没在 Qiuly 精心调制的汤底中。

## 题目描述

有 $n$ 个互不相同的整数，现有 $m$ 个整数属于集合 $G$ 中。

Aw顿顿规定这个集合有如下规定：

- 若 $x\in G$，则 $x+a\in G$。
- 若 $x+a$ 不在 $n$ 个整数中就不做处理。
- 若对于一个集合 $G$ 不存在需要加入的元素，那么它是完善的。

若集合是完善的，输出 `Great Set!`，反之输出至少还要按规定加入几个食材才能完善该级别。

## 说明/提示

### 【样例解释】

#### 样例 1 解释

这个集合包含 $1,3,5$，其中 $1+2=3$，$3+2=5$，$5+2=7$ 不存在，所以这个集合是完善的。

#### 样例 2 解释

剩下的所有整数都属于这个集合。

### 【数据范围】

- $1\le m<n\le6\times10^4$。
- $1\le A_i\le n$。
- $0\le a\le 10^4$。

### 【捆绑测试情况】

|测试点编号|时间限制|分数分配|$n,m\le$|
|:--------:|:------:|:------:|:------:|
|$\rm Subtask 1$|$\rm 400ms$|$\rm 10pts$|$10^3$|
|$\rm Subtask 2$|$\rm 400ms$|$\rm 15pts$|$10^4$|
|$\rm Subtask 3$|$\rm 400ms$|$\rm 35pts$|$3\times 10^4$|
|$\rm Subtask 4$|$\rm 400ms$|$\rm 40pts$|$6\times 10^4$|

$\rm P.S.$ 这题的时限已经开到 $\rm std$ 的 $\bf 15$ 倍，附件内有部分测试点。

## 样例 #1

### 输入

```
5
1 2 3 4 5
3
1 3 5
2```

### 输出

```
Great Set!```

## 样例 #2

### 输入

```
15
13 2 10 3 1 12 8 4 5 7 9 6 15 14 11 
7
13 2 1 12 8 3 10 
2```

### 输出

```
8```

## 样例 #3

### 输入

```
50
13 2 10 50 1 28 37 32 30 46 19 47 33 41 24 34 27 42 49 18 9 48 23 35 31 8 7 12 6 5 3 22 43 36 11 40 26 4 44 17 39 38 15 14 25 16 29 20 21 45 
10
50 46 30 32 10 2 28 37 1 13 
3```

### 输出

```
31```

# 题解

## 作者：Aw顿顿 (赞：22)

## 『JROI-1』蒟蒻火锅的盛宴-赛后题解


### $\rm Description$ 题意解释

~~题面已经更改为了简化版题目~~

这里解释一下题意吧：

- 一共有 $n$ 个整数。

- 存在一个集合 $G$，初始情况含有给定的 $m$ 个整数。

- 若 $m\in G$，则必然存在 $(m+a)\in G$。

问至少增加几个元素可以保证此集合没有可以加入的元素。

### $\rm Solution$ 解题思路

- **暴力 $n^2$ 模拟，使用 $\rm O_2$ 期望得分 $25pts$。**

原本的思路是直接暴力模拟。

其核心思想为：

- 读入，如果 $a_i>mx$ 就 $mx=a_i$，这个东西其实只是做一个简单的优化而已。

- 对于每个 $b_i$，寻找其对应的 $a_i$ 是否存在：

	- 如果不存在此食材，跳过。
    
    - 否则 $ans=ans+1$。

这种方法的复杂度是 $O(n^2)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[50001],b[50001],m,mx=-1,x,ans,s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]>mx)mx=a[i];
	}
	cin>>m;ans=m;
	for(int i=1;i<=m;i++)cin>>b[i];
	cin>>s;
	for(int i=1;i<=ans;i++){
		bool f=false;
		if(b[i]+s>mx)continue;
		for(int j=1;j<=n;j++)if(b[i]+s==a[j]){
			f=true;
			break;
		}
		if(!f)continue;
		f=false;
		for(int j=1;j<=ans;j++)if(b[i]+s==b[j]){
			f=true;
			break;
		}
		if(!f)b[++ans]=b[i]+s;
	}
	if(ans==m)puts("Great Set!");
	else cout<<ans-m<<endl;
    return 0;
}
```

加上快读和快输及八聚氧开启全部卡常技能也许可以拿到更高分（？）。

- **优化模拟倍数标记，期望得分 $60pts$。**

比上面的稍微优化，其实是类似的。

```cpp

#include<bits/stdc++.h>
using namespace std;
inline int read(){
   register int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}int q[10000001],l=1,r=1; 
int n,m,ans,x,v,mx=-1;
bool t[600001];
int main(){
//	freopen("30.in","r",stdin);
//	freopen("30.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		v=read();
		if(v>mx)mx=v;
	}m=read();
	for(int i=1;i<=m;++i){
		v=read();
		t[v]=1;
		q[r++]=v;
	}x=read();
	for(int i=1;i<r;i++){
		for(int j=q[i];j<=mx;j+=x)if(!t[j]){
			t[j]=1;
			q[r++]=j;
			ans++;
		}
	}if(ans)cout<<ans<<endl;
	else puts("Great Set!");
	return 0;
}
```

直接交不加八聚氧也可以拿到 $60pts$。

- **队列循环标记，期望得分：$100pts$。**

有一个用空间换时间的办法：

我们的内部循环都是在寻找这个数是否存在，那么如果我们输入的时候做一个标记可以省下来一个循环。

简单来说，我们可以开 $2$ 个桶进行标记。

然后我们就只有一个 `while` 循环每次加入的过程了。

这个算法的时间复杂度**大致**为 $O(n)$。

输入 $n+m$ 次，循环最多 $n$ 次。


代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>q;
int n,m,ans,x,l;
bool t1[600001],t2[600001];
int main(){
	cin>>n;
	for(register int i=1;i<=n;i++){
		cin>>l;
		t1[l]=1;
	}cin>>m;
	for(register int i=1;i<=m;++i){
		cin>>l;
		t2[l]=1;
		q.push(l);
	}cin>>x;
	while(!q.empty()){
		int l=q.front();
		if(!t1[l+x]){
			q.pop();
			continue;
		}if(!t2[l+x]){
			q.push(l+x);
			t2[l+x]=1;
			++ans;
		}q.pop();
	}
	if(ans)cout<<ans<<endl;
	else puts("Great Set!");
	return 0;
} 
```

当然也可以手写和快读实现，以达到更快的效果：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   register int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}int q[600001],l=1,r=1,n,m,ans,x,v;
bool t1[600001],t2[600001];
int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		v=read();
		t1[v]=1;
	}m=read();
	for(register int i=1;i<=m;++i){
		v=read();
		t2[v]=1;
		q[r++]=v;
	}x=read();
	while(l<r){
		int v=q[l];
		if(!t1[v+x]){
			++l;
			continue;
		}if(!t2[v+x]){
			q[r++]=v+x;
			t2[v+x]=1;
			++ans;
		}++l;
	}
	if(ans)cout<<ans<<endl;
	else puts("Great Set!");
	return 0;
} 
```

这样你就 AC 了一道十分简单的签到题。

最后附上一些挺有意思的赛时代码：

@Marser

```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
int n,m,a;
set<int>S1,S2;
int main(){
	scanf("%d",&n);
	for(reg int i=1,x;i<=n;i++)
		scanf("%d",&x),S1.insert(x);
	scanf("%d",&m);
	for(reg int i=1,x;i<=m;i++)
		scanf("%d",&x),S2.insert(x);
	scanf("%d",&a);reg int Ans=0;
	for(auto x:S2)if(S1.count(x+a)&&!S2.count(x+a))Ans++,S2.insert(x+a);
	if(Ans)printf("%d\n",Ans);
	else puts("Great Set!");
	return 0;
}
```

---

## 作者：zzhmm (赞：13)

# 本蒟蒻第一篇题解
初看这道题时，我一脸茫然：咋这么长的题目背景！

~~但仔细一看，发现题目背景与题目几乎无关。~~

好的，我们现在看到题目描述，大概是这么个意思：

在数组b中有m个整数在数组c中，对于数组c中任意一整数x，如果x+a在数组b中但不在数组c中，这时就需要在数组c中加入整数x+a。输出需要加入整数数量。若不需要加入任何整数，则输出“Great Set!”。

这样题目要求就比较清晰了。~~算法其实很简单~~我们只需将数组b中所有整数都加上a，并判断这个新得到的整数是否在数组b中且不在数组c中。如果上述条件成立，那么就需要把这个新得到的整数加入数组c。

按这个想法就可以写出以下代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int b[60005],c[60005];
int x[70005],y[70005];   //数组x，y分别记录一个数是否在数组b，c中（比如整数1在数组b中，那么x[1]=1）。
int inc;                 //inc用来记录要加入整数个数。
int n,m,a;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		x[b[i]]=1;
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>c[i];
		y[c[i]]=1;
	}
	cin>>a;
	for(int i=1;i<=m;i++)
	{
		if((x[c[i]+a]==1)&&(y[c[i]+a]==0))
		{
			inc++;
		}
	}
	if(inc==0)
	{
		cout<<"Great Set!"<<endl;
		return 0;
	}
	cout<<inc<<endl;
	return 0;
}
```

然后你会神奇地发现，把这代码一运行，连测试数据2，3都过不去！

为什么呢？

本题最大坑点来了，划重点：当我们将一个整数x+a加入数组c中时，整数x+a就成了数组c的一部分。因此，加入整数x+a后，必须对其进行判断：若(x+a)+a在数组b中且不在数组c中，将其加入数组c中。

完整代码如下：

```
#include<iostream>
#include<cstring>
using namespace std;
int b[60005],c[60005];
int x[70005],y[70005];
int inc;
int n,m,a;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		x[b[i]]=1;
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>c[i];
		y[c[i]]=1;
	}
	cin>>a;
	for(int i=1;i<=m;i++)
	{
		if((x[c[i]+a]==1)&&(y[c[i]+a]==0))
		{
			inc++;
			m++;
			c[m]=c[i]+a;
			y[c[m]]=1;    //在数组c中插入新的符合条件的整数
		}
	}
	if(inc==0)
	{
		cout<<"Great Set!"<<endl;
		return 0;
	}
	cout<<inc<<endl;
	return 0;
}
```

祝大家AC顺利（码风不佳，大佬勿喷）！

#### 这么努力写题解，不点个赞再走吗？

---

## 作者：天南星魔芋 (赞：10)

~~今天想水题解，故来了一发~~


------------
我们先看题:

* 先给定集合 $A$ 元素的个数，然后一一给出元素。
* 再给定集合 $B$ 元素的个数，然后一一给出元素， $B$ 属于 $A$ 。
* 最后给出 $a$ 。
* 重点 $A$ 中有 $N$ 个数，他们在 $1$ 到 $N$ 之间并且互不相同。

等等...为什么互不相同？

这不是明摆着的吗？ $N$ 含且仅含 $1$ 到 $N$ 这 $N$ 个数。

~~那他干嘛？耍你呗。~~

所以我们就忽略它吧。

我们再看，如果这个集合已经完善，输出 Great Set!。

反之输出需要完善该集合所需的整数数量。

所以如果我们将 $B$ 完善，再看与原 $B$ 是否相等就行了。

那么怎么完善呢？ 我们需要模拟 埃式筛。

讲一下(会线性埃式筛的可跳过):

用于筛出一个区间内的质数。

方法——每找出一个质数，就将范围内该质数的倍数筛除。

例子:
 
* 筛出 $10$ 以内的质数。

* 先找到 $2$ 筛除 $4$，$6$，$8$，$10$ 。

* 再找到 $3$ 筛除 $6,9$ 。

* 再找到 $5$ 筛除 $10$ 。

* 接下来找出 $7$ 无筛除。

* 故 $10$ 以内的质数是 $2$，$3$，$5$，$7$ 。

此题同理:

* 从最小的开始 ($1$) 。

* 一个个向前找，若数字 $A$ 在 $B$ 中，将数字 $A$ $+$ $a$ 也放入 $B$ 中。

是的，你用 $O(N)$ 的方法把它 $AC$ 了！

接下来上代码吧:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a;
int t[60005];//判断 某个数 w 是否在 B 里面 
int ans=0;// B 最后含有元素的个数 
int main(){
	cin>>n; 
	for(int i=1;i<=n;i++){
		t[i]=1;//初始化 T 假设 B 不含任何元素 
		cin>>a;//输入  既然怎样输入都一样就随便写 
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>a;
		t[a]=0;//输入  标记 B 中的元素 
	}
	cin>>a;
	for(int i=1;i<=n;i++){//埃式筛 
		if(t[i]==0){t[i+a]=0;
		ans++;}
	}
	
	if(ans==m)cout<<"Great Set!"<<endl;
	else cout<<ans-m<<endl;
	return 0;
}
```

这篇题解就到这里了，

我还没写过几次，有不到之处请多多指教。







---

## 作者：_Clown_ (赞：7)

~~这篇题解简单些，请见谅~~
# 一、目录概览
- 一、目录概览
- 二、题目大意
- 三、答题思路
- 四、代码剖析
# 二、题目大意
有个集合，还有N个数。

题目保证这个集合里的所有元素都在这N个数里。

我们要找出在这N个数中的其他数中，与集合中的某个元素的差，是a的倍数，那么答案+1，如果答案为0，就输出Great Set!即可。
# 三、答题思路
这道题目**模拟**出奇迹。

将这N个数对a取模，分成a个抽屉。

然后将集合中的几个元素所在的抽屉点亮。

将其他的也在点亮的抽屉里的数进行查看：
- 如果他比那个集合里的数大，那么答案+1。
- 否则答案不变。
# 四、代码剖析
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int x;
int a[60001],b[60001];
bool hav[60001],rea[60001];
int modd[10001];
int main()
{
	memset(modd,0x3f3f3f,sizeof(modd));
	register int i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>b[i];
	}
	cin>>x;
	for(i=1;i<=m;i++)
	{
		hav[b[i]%x]=true,rea[b[i]]=true,modd[b[i]%x]=min(b[i],modd[b[i]%x]);
	}
	register int ans=0;
	for(i=1;i<=n;i++)
	{
		if(hav[a[i]%x]&&!rea[a[i]]&&a[i]>modd[a[i]%x])
		{
			ans++;
		}
	}
	if(!ans)
	{
		goto loop;
	}
	cout<<ans<<endl;
	return 0;
	loop:
	cout<<"Great Set!"<<endl;
	return 0; 
}
```

---

## 作者：Thomas_Cat (赞：4)

来简单的说明一下题面：

 $\begin{cases}\text{if} x \in G \quad x+a \in G & \text{不是Great Set!}\\\text{if} x \in G \quad x+2 \notin G & \text{是Great Set!} \end{cases}$

所以我们只需要用一个队列 $q$ 来维护就行了。

- 如果 $x \in G, x+a \notin G$  `q.pop` 也就是不需要再在 $q$ 这个队列里面了（因为已经没有 $x + a \in G$ 这种情况了）
- 如果 $x \in G, x + a \notin G$  `q.push(x+a)` 而且只需要 `push` 一次，因为 $x+a$ 永远只有一个。（$\text{Ps:}$ 这里的 `push` 只用一次就可以了，之后通过 `while` 循环中的 `!q.empty` 可以直接循环了之后 `pop` 掉，因为这里我们使用一个数组来标记是否加入了队列，就变成了上面的情况）。

---



复杂度 $\mathcal{O}(n)$。



代码如下：



```cpp
#include <iostream>
#include <queue>
using namespace std;
const int MAXN = 100000;
bool q_all[MAXN], q_in[MAXN];
int main() {
	queue <int> q;
	int n, m, a, sum = 0;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int tmp;
		cin >> tmp;
		q_all[tmp] = true;
	}
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int tmp;
		cin >> tmp;
		q_in[tmp] = true;
		q.push(tmp);
	}
	cin >> a;
	while (!q.empty()) {
		int tmp = q.front();
		if (q_all[tmp + a] == true && q_in[tmp+a] == false) {
			q.push(tmp + a);
			q_in[tmp + a] = true;
			sum++;
		}
		else {
			q.pop();
		}
	}
	if (sum > 0) cout << sum << endl;
	else cout << "Great Set!";
	return 0;
}
```



---

## 作者：Jiyuu_no_Tsubasa (赞：2)

**首先考虑暴力做法。**

时间复杂度约为$O(n^2)$，

时间要求$400ms$，

果断放弃。

但我们观察数据范围，


$A(i) ≤  6 × 10^4$

**于是，我们想到用桶来标记。**

建立 $2$ 个桶，

分别存储 $n$ 个整数中的数据情况与集合中的数据情况。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int bn[64010];
int bm[64010];
int a[60010],ans;
int main(){
	int n; cin>>n;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		bn[x]=1;
	}
	int m; cin>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i];
		bm[a[i]]=1;
	}
	int b; cin>>b;
	for(int i=1;i<=m;i++){
		if(!bm[a[i]+b]&&bn[a[i]+b])
			ans++;
	}
	if(ans) cout<<ans;
	else cout<<"Great Set!";
	return 0;
}

```

然后第二个和第三个样例~~愉快地~~崩了。

这时，我们就来到了本题最大坑点。

若 $x$ 在集合中，则 $x+a$ 需加进集合；

我们根据这个思路继续：

若 $x+a$ 在集合中，则 $x+a+a$ 需加进集合；

若 $x+a+a$ 在集合中，则 $x+a+a+a$ 需加进集合；

… … 

一直循环，直到条件中止。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int bn[64010];
int bm[64010];
int a[60010],ans;
int main(){
	int n; cin>>n;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		bn[x]=1;
	}
	int m; cin>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i];
		bm[a[i]]=1;
	}
	int b; cin>>b;
	for(int i=1;i<=m;i++)
		while(!bm[a[i]+b]&&bn[a[i]+b])//循环
			ans++,a[i]+=b;
	if(ans) cout<<ans;
	else cout<<"Great Set!";
	return 0;
}

```

完结撒花

###### 蒟蒻第一次写题解不易，求过

---

## 作者：_Xiuer (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6586)  

**~~一道很水的搜索题~~**  

首先明确题意：  
1.若x∈G,则x+a∈G。  
2.若x+a不在n个整数中就不做处理。  
3.若对于一个集合G不存在需要加入的元素，那么它是完善的。 

**简单来说，就是让我们从给定的m个整数里加上若干个a，判断它是否在G中。**

**然后我们就可以开始搜索了(~~不就是枚举吗~~)**
$$qwq$$
我们用数组v标记一个数now是否已经存在，t标记now是否在G中，遇到存在的数跳过，遇到∈G的数ans++。

最后判断没有合法答案输出**Great Set!**,反之输出答案数。

~~完结撒花~~

$$Code$$
```cpp
#include<iostream>
#include<cstdio>
#define N 60010
using namespace std;
int n,m,G[N],b[N],a,hd,tl,ans,maxn,q[N*10];
bool v[N],t[N];
void re(int &x)
{
	x=0;char i=getchar();
	while(i<'0'||i>'9') x=getchar();
	while(i>='0'&&i<='9') x=(x<<1)+(x<<3)+i-'0',i=getchar();
}
void bfs()
{
	while(hd<tl)
	{
		hd++;int now=q[hd];
		now+=a;
		if(now>maxn) continue;
		if(v[now]) continue;
		if(t[now]) ans++;
		q[++tl]=now;v[now]=1;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&G[i]),t[G[i]]=1,maxn=max(maxn,G[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{scanf("%d",&b[i]);v[b[i]]=1;q[++tl]=b[i];}
	scanf("%d",&a);
	bfs();
	if(!ans) printf("Great set!");
	else printf("%d",ans);
	return 0;
}

---

## 作者：Mars_Dingdang (赞：1)

[P6586](https://www.luogu.com.cn/problem/P6586) 

本题主要考察的是数组的处理，包括加入，查找等知识，总体难度不大。

## 题目大意
有 $n$ 个互不相同的整数，现有 $m$ 个整数属于集合 $G$ 中。

这个集合有如下规定：

- 若 $x\in G$，则 $x+a\in G$。
- 若 $x+a$ 不在 $n$ 个整数中就不做处理。
- 若对于一个集合 $G$ 不存在需要加入的元素，那么它是完善的。

若集合是完善的，输出 `Great Set!`，反之输出至少还要按规定加入几个才能完善该级别。

## 大体思路
本题就是一道典型的集合处理问题，需要两个数组，分别记录每个元素的内容和每个数是否出现过（类似桶）。
### 第一步：输入
在输入的过程中可以注意：由于题目中的 $A_i$ 皆不大于 $n$ 且互不相同，因此这些数实质上就是 $1\sim n$ 这 $n$ 个数。也就是说，为了节省空间，是不需要记录 $A_i$ 的。

而对于集合 $G$ 中的数，则需要记录每个数的大小以及出现过的数（用于判断是否完善），因此需要一个 int 类型的数组 $b[\ i\ ]$ 和`bool numb[i]`。后续便是通过遍历数组 $b$，通过 $\textit{numb}$ 判断数字是否出现过。

代码如下：
```cpp
//数组声明在主函数外
	int n,m,plus;
    //如题，plus即题目中的a
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
	}//输入n个数（但不用记录这n个数）
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>b[i];
        //输入m个数（即G集合）
		numb[b[i]]=1;
        //记录每个数是否出现
	}
	cin>>plus;//输入加数
```
### 第二步：判断集合
首先定义一个变量 $\textit{ans}$ 记录需要加入的个数，初始化为零。然后遍历集合：

- 当 $x+a>n$ 时跳过；

- 否则在 $numb$ 中找 $x+a$ 是否存在，不存在则让 $ans+1$，并 **将新数加入集合中，即`b[m+1]=x+a`，让集合元素数量 $m+1$，然后记录新数在集合中出现过：`numb[b[m]]=true`。** 

- 最后若 $ans=0$ 则表明没有加入过数字，集合是完善的，输出 `Great Set!`，否则输出 $ans$ 表示加入的数字数量。

代码如下：
```cpp
	int ans=0;//计数器
	for(int i=1;i<=m;i++){
		if(b[i]+plus>n) continue;
        //x+a不在n个数中不处理
		if(numb[b[i]+plus]==0) {
			ans++;//这个数没有
			b[++m]=b[i]+plus;
            //加入新数到集合中
			numb[b[m]]=1;
		}
	}
	if(ans==0) cout<<"Great Set!";
	else cout<<ans;//输出
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[60005];//记录集合
bool numb[60005];//记录数字是否出现
int main(){
	int n,m,plus;//如题
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
	}//输入n个数
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>b[i];//输入m个数（即G集合）
		numb[b[i]]=1;/记录每个数是否出现
	}
	cin>>plus;//加数
	int ans=0;
	for(int i=1;i<=m;i++){
		if(b[i]+plus>n) continue;//相加大于n不处理
		if(numb[b[i]+plus]==0){//该数字未出现过
			ans++;//计数器+1
			b[++m]=b[i]+plus;//储存新元素
			numb[b[m]]=1;//标记该数出现过
		}
	}//处理集合
	if(ans==0) cout<<"Great Set!";
    //表明没有加入过数字，集合是完善的
	else cout<<ans;//输出
	return 0;//完美
}
```


---

## 作者：ezyannn9 (赞：1)

思路：以例2举例，集合G内每个数加2（a），并划掉G中已有且A中已有，或A中没有的元素，留下的数字加入集合G，反复执行上述，直到无可复加。


------------
代码实现运用了桶的思想，两个数组用来确认元素是否存在，若G集合不完善则添加元素，以下为AC代码
```c
#include<stdio.h>
int s[60003]={0},g[60003]={0},a[60003]={0};
int main()
{int n=0,m=0,i=0,j=0,k=0;
scanf("%d",&n);
for(i=1;i<=n;i++)
    {scanf("%d",&j);
    a[j]++;}
scanf("%d",&m);
for(i=1;i<=m;i++)
    {scanf("%d",&g[i]);
    s[g[i]]++;}
scanf("%d",&j);
for(i=1;i<=m+k;i++)
{
    if(a[g[i]+j]>0&&s[g[i]+j]<1)//整个代码的核心部分，用于添加元素
    {
        k++;//记录添加元素次数
        g[m+k]=g[i]+j;//加‘a'
        s[g[m+k]]++;//记录存在
    }
}
if(k==0)
    printf("Great Set!");
else
    printf("%d",k);
    return 0;
}
```
其实这个代码是可以优化的：

------------

**已知A集合有n个元素，互不相同，且小于等于n大于等于1**，也就是说A的输入本就没有必要，**这是一个1~n的自然数集合**，那么我们可以优化代码：

------------
当G[i]+a必须小于n，不必开桶验证;同理一个数只要小于n且不存在于G都可加入G。
求过。


---

## 作者：jike1994 (赞：1)

这个题看数据范围，然后我们可以1e5的数组大小来标记数组元素是否在某个集合中，然后获取了两个集合中的元素以后，直接开始模拟，如果在a集合中，不在b集合中就一直做下去，计数加一。
如果有数的话，那么输出需要多少个数，否则就输出"Great Set!"
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int st[N],s[N],a[N];
int main()
{
	int n,m,b;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		st[x]=1;
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i];
		s[a[i]]=1;
	}
	cin>>b;
	int cnt=0;
	for(int i=1;i<=m;i++)
	{
		int t=a[i]+b;
		while(st[t]&&s[t]==0)
		{
			cnt++;
			t=t+b;
		}
	}
	if(cnt) cout<<cnt;
	else cout<<"Great Set!";
	return 0;
}
```


---

## 作者：FutureThx (赞：1)

~~说实话这题是真的水（然鹅我还是调了一下午）~~

## 1.题意
P6586 『JROI-1』 蒟蒻火锅的盛宴：[传送门](https://www.luogu.com.cn/problem/P6586)

(提醒一下：读懂题意十分重要，~~我就是没读题瞎打了半小时~~)

## 2.题目解析
这一题乍一看有几分难度(至少我差点崩溃[小声])，但仔细解剖的话还是挺简单的。

首先是问题，题目让你从已知的G集合所有元素与其他判定条件在A集合中筛选元素补全G集合，若在A集合中无法找到符合元素或所有符合元素已经属于初始的G集合，则输出$Great \ Set!$

先看一下条件：

1. 若 $x \in G$ , 则 $x + a \in G$
2. 若 $x + a$ 不在 $n$ 个整数中就不做处理
3. 若对于一个集合 $G$ 不存在需要加入的元素，那么它是完善的。

了解了条件之后了，第一个想法就是将遍历 $G$ 集合中的所有元素，进行 $G_i + a$ 的操作，在集合 $A$ 中查找元素，若满足 $f(G_i) = A_j \ ,f(n) = n + a \ , A_j 	\notin G\ ,a \in N $ 则将加入 $G$ 集合，反之则跳过。

## 3.代码 ~~略~~ 详解

得出了解题方法后我们就可以开始写代码了：
```cpp
#include <iostream>
#define MAX_N 60001
using namespace std;
int n,m,A[MAX_N],G[MAX_N],a;
int main(){

    //输入
    cin >> n;
    for (int i = 1;i <= MAX_N;i++)
        A[i] = -1;
    for (int i = 1;i <= n;i++){
        cin >> A[i];
    }
    cin >> m;
    for (int i = 1;i <= m;i++)
        cin >> G[i];
    cin >> a;
    //准备工作结束
   
    int t = 0;
    bool jc = 0;
    for (int i = 1;i <= m + t;i++){
        int fn = G[i] + a;//这是要在A集合中搜索的目标
        for (int j = 1;j <= n;j++){
            if(fn == A[j]){//找到符合条件的元素
                for (int j_2 = 1;j_2 <= m + t;j_2++){
                    if(G[j_2] == fn)//如果集合G中已存在此元素，则跳过
                       jc = 1;
                }
                if(jc != 1){
                    t++;
                    G[m + t] = fn;// 记录
                }
                jc = 0;
            }
        }
    }
    if(t == 0)
        cout << "Great Set!" << endl;
    else
        cout << t << endl;
    return 0;
}
```
然鹅超时了……

这个时候就有必要拿出祖传信条——$O(n^2)$爆搜算法不香时就~~果断放弃~~利用下标。

根据题目给出的 $A_i \leq n$ 我们可以让数据使其在数组中的下标一致，这样就可以不用遍历 $G$ 集合也可以判断其是否在 $G$ 集合中出现过了。

100pts代码实现：
```cpp
#include <iostream>
#define MAX_N 60001
using namespace std;
int n,m,A[MAX_N],G[MAX_N],a,S[MAX_N];
int main(){
    cin >> n;
    for (int i = 1;i <= MAX_N;i++){
        S[i] = -1;
        A[i] = -1;
    }
    for (int i = 1;i <= n;i++){
        int x;
        cin >> x;
        A[x] = x;
    }
    cin >> m;
    for (int i = 1;i <= m;i++){
        cin >> G[i];
        S[G[i]] = G[i]; 
    }
    cin >> a;
    int t = 0;
    for (int i = 1;i <= m + t;i++){
        if(A[G[i] + a] != -1 && S[G[i] + a] == -1){
            t++;
            S[G[i] + a] = G[i] + a;
            G[m + t] = G[i] + a;
        }
    }
    if(t == 0)
        cout << "Great Set!" << endl;
    else
        cout << t << endl;
    return 0;
}
```
小五xxs第一次写题解，求管理员给一个通过。


---

## 作者：血色黄昏 (赞：0)

一个蒟蒻的橙题python题解QwQ

此题思路简单，不涉及任何算法，连python都能270ms放过了，个人感觉应该红？

不说废话了，说下做题思路：

题意大概就是把一个集合里的几个数加上a后放入集合，求最小次数。那么只要模拟加入过程，$O(n)6*10^4$数据完全能通过。

下面是python代码，附有详细解析：

```
n = int(input())
s = input().split()
m = int(input())
s1 = input().split()
a = int(input())#前五行都是输入，没什么好说的
tong = [0 for i in range(1145141)]#开个桶记录是否出现
ans = 0
for i in s1:
    tong[int(i)] = 1#其实就是将集合里的元素开始都设为1
for i in s1:
    if int(i) + a > n:#如果+后大于了n就跳出
        continue
    if tong[int(i)+a] == 0:#如果没出现过
        ans += 1#答案个数+1
        tong[int(i)+a] = 1#记录为出现过
        s1.append(str(int(i)+a))#加回去(注意要是string类型的
if ans == 0:#如果本来就都有了
    print("Great Set!")#输出greatset
else:
    print(ans)#输出ans

```

CSP rp++

---


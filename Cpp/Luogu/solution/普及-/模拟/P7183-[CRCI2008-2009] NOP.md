# [CRCI2008-2009] NOP

## 题目描述

Mirko 购买了新的微处理器。

不幸的是，他发现为旧处理器编写的许多程序在新处理器上无法运行。

在深入了解这两种处理器说明书后，他发现了原因。 

为了更快地工作，新处理器对程序的机器代码施加了某些约束，而这些约束在以前的模型中是不存在的。

处理器的机器代码由顺序执行的指令组成。 每个指令使用一个字节的存储器。 

同样，指令可以具有 $0$ 个或多个参数，每个参数都使用一个额外的内存字节。在机器代码中，参数紧随指令之后。

当设置为文本格式时，机器代码指令为大写字母，而参数为小写字母。 例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/1581jsvp.png)

该程序由四个指令组成：第 $1$ 个使用三个参数，第 $2$ 个使用两个参数，第 $3$ 个不使用，第四个使用四个参数。 该程序使用 $13$ 个字节的内存。

新的处理器模型以四字节的块为单位获取内存，因此每条指令必须从可被四整除的内存地址开始（内存中的第一个字节为地址 $0$）。 

我们可以将 `NOP`（No Operation，即无操作）指令插入旧程序中，这些指令不执行任何操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/a1y7fo0r.png)


指令 $A$，$B$，$C$ 和 $D$ 现在位于内存位置 $0$、$4$、$8$ 和 $12$，这满足了处理器的约束。

请你编程求出最少需要插入的 `NOP` 数量。

## 说明/提示

#### 数据规模及约定

令 $|s|$ 为字符串 $s$ 的字符数，对于 $100\%$ 的数据，$1\le |s| \le 200$。 

#### 说明
- 本题满分 $30$ 分。
- 本题译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CRCI2008-2009](https://hsin.hr/coci/archive/2008_2009/regional_tasks.pdf) NOP，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
Abcd 
```

### 输出

```
0```

## 样例 #2

### 输入

```
EaEbFabG 
```

### 输出

```
5```

## 样例 #3

### 输入

```
AbcbBccCDefgh 
```

### 输出

```
4```

# 题解

## 作者：Ptilopsis_w (赞：6)

$\Large\color{white}{我写题解才不是为了混咕值呢}$

### 题意

有一个字符串 $s$ , 可以往其中任意位置插入占位符，使其所有的大写字母的位置都在 $4$ 的倍数上，插入占位符的最小数量

### 思路

1. 题目很简单，对着样例搞一下就可以发现，在两个大写字母间，不管怎么插入占位符，只要数量相同效果就一样，所以思路就是用占位符从头开始一个个地将大写字母“推”到相应的位置上

2. 对于已经对齐位置的大写字母，可以忽略掉，所以只看当前大写字母需要几个占位符，并累计到答案变量  $ans$ 里，当前大写字母的位置就是原来的位置 $i$ 加上 $ans$ ，而占位符数量就是`4-(i+ans)%4`，至此，问题已经解决

### 代码

tips: STL中有个函数`isupper()`，可以用来判断一个字符是否为大写字母

```c++
#include<cstdio>
#include<cstring>
using namespace std;

int main()
{
	char ch[205];
	scanf("%s", ch);
	int n = strlen(ch);
	int ans = 0;
	for(int i = 0; i < n; i++)
	{
		if(isupper(ch[i]) and (i+ans)%4 != 0)
			ans += 4-(i+ans)%4;
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：2)

\- 「Repeat, we have been CALLING, but there was NO RESPONSE there!」

\- 「No Operation. Require for NO ACTION!」


--------

题目给定一个字符串 $s$，可以再任意位置插入 `NOP` 作为占位符，问至少插入几个？

那么，我们自然能够想到从前往后进行插入。

只要遇到大写字母，首先判断是否在 $4$ 的倍数的位置上，如果是就跳过，如果不是就记录需要后移的格数。

注意，后移之后，每一次的判断都要计算入已经后移的长度。

------

这样我们可以循环实现，这里举个例子：

$$\mathsf{a\ b\ C\ a\ B\ c\ a\ b\ c\ A}$$

对于这个序列，我们搜到 $\sf C$ 的时候应该要后移一位，这时候后移值 $p=1$。

$$\mathsf{a\ b\ NOP\ C\ a\ B\ c\ a\ b\ c\ A}$$

然后对于原本在 $5$ 的 $\sf B$ 就变成了 $6$ 的位置，后移两位，这时候 $p=3$。

$$\mathsf{a\ b\ NOP\ C\ a\ \ NOP\ NOP\ B\ c\ a\ b\ c\ A}$$

然后到了原本在 $10$ 的 $\sf A$，现在在 $13$，于是需要后移 $3$ 位，$p=6$。

最后一共需要后移 $6$ 位。

-------

注意到 $1\le |s|\le 200$，这种方法时间复杂度完全没问题。




---

## 作者：RyanCh (赞：2)

这道题的意思是：

必须将大写字母挪到$4$的倍数。

问你最少需要在不同的位置移动几个格子？

思路：

我们将字符串读入，判断是否是大写字母，

如果当前位置下标符合要求（是$4$的倍数），那么就不用向后移动。

否则，就记录要向后移动的位数。

具体执行方法：

用$ans$记录当前向后移动的格子数量。


则，每个大写字母在新处理器的实际位置下标为$i+ans$

(设$i$表示旧处理器的位置下标)

当这个字母的位置符合要求时，我们就```continue```

否则，用```while```循环来将```ans++```，直到下标符合要求为止。

因此，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans;

int main(){
    string a; cin>>a;
    for(int i=0;i<a.size();i++)
        if(a[i]>='A'&&a[i]<='Z')
            if((i+ans)%4==0) continue;
            else
                while((i+ans)%4!=0)
                    ans++;
    cout<<ans;
    return 0;
}
```


---

## 作者：_farawaystar_ (赞：1)

#### 题意简述

通过插入空格使所有大写字母位于 $4$ 的倍数位。

#### 题目分析

遍历字符数组，若判断出大写字符，则进行如下操作：

1. 若当前位置是 $4$ 的倍数位，不进行操作。

2. 若当前位置非 $4$ 的倍数位，空格数加上将当前大写字符移动到最接近的 $4$ 的倍数。

代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int ans;
char c[210];
int main(){
	scanf("%s",&c);
	for(int i=0;i<strlen(c);i++)
      if(c[i]>='A'&&c[i]<='Z'&&(i+ans)%4!=0)
         ans+=4-(i+ans)%4;
	printf("%d",ans);
	return 0;
}
```

谢谢大家！

---

## 作者：_Aoi_ (赞：1)

比较水的[题](https://www.luogu.com.cn/problem/P7183)

------------

### 题意理解
给你一个只有**大写字母**和**小写字母**的字符串，你可以在里面任意位置插入“占位符”，问你最少插入多少个“占位符”，才能使字符串里的所有**大写字母**都在$4$的倍数位置上。


------------

### 思路
定义字符串后...

输入字符串：提供$3$种方法

1. 有使用风险
```cpp
c[0]=getchar();
for(int i=1;c[i-1];i++)
	c[i]=getchar();
```



------------


2. 不能读入空格
```cpp
scanf("%s",c);
```


------------


3. 

```cpp
cin>>c;
```
从$0$到$l-1$（字符串长度）遍历字符串，遍历到一个不再$4$的倍数位置上的大写字母，就在他的前面加上占位符，用$tot$统计占位符数量。

因为在一个大写字母前加上占位符会使后面的字符依次移位，所以每次判断都要在位置编号上加上$tot$（占位符的数量）


------------

### AC code
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int l,tot;
char c[210];//定义字符串 
int main()
{
	scanf("%s",c);//输入字符串（2） 
	l=strlen(c);//取字符数量 
	for(int i=0;i<l;i++)//依次便利 
	{
		if(c[i]>='A'&&c[i]<='Z')//判断大小写 
			if((i+tot)%4!=0)
				tot+=4-(i+tot)%4;//加上占位符数量 
	}
	cout<<tot;//输出 
	return 0;
}


```

---

## 作者：Zirnc (赞：1)

如果 指令所在的位置 不合规，就在他前面加上几个空格。

此时，代码内多了几个 NOP，所以之后的指令/参数的位置也会相应后移。

所以之后的指令/参数的新的位置就是 NOP 的数量+原下标。

```cpp
int main()
{
    int ans = 0;
    string s;
    cin >> s;

    for (int i = 0; i < s.length(); i++) {
        if (s[i] <= 'Z' && s[i] >= 'A') {
            if ((ans + i) % 4 != 0) {
                ans += 4 - ((ans + i) % 4);
            }
        }
    }

    cout << ans << endl;
    return 0;
}
```

---

## 作者：fanypcd (赞：0)

### 题目简述：

给你一个字符串，插入最少的空位，使每个大写字母的下标（从 0 开始计算下标）是 4 的整数倍。

### 题目思路：

- 暴力模拟。
- 开一个变量 $delta$ 记录累计的位移值，初始置为 0，可以在需要添加 NOP 时记录在 $delta$ 里面。
- 这样字符串中的第 $i$ 号元素的实际下标是 $i + delta$，如果当前遍历到的字母是大写，判断是否满足下标是 4 的整数倍，如果不满足则需要将元素后移 $4 - ((i + delta) \% 4)$ 位。（即不满 4 位的补足 4 位）。
- 代码为```delta += 4 - (i + delta) % 4;```
- 这样最终的 $delta$ 即是添加 NOP 的最小值。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);//读入优化
	cin.tie(0);//同上
	string s;
	cin >> s;
	int delta = 0;
	for(int i = 0; i < s.size(); i++)
	{
		if(s[i] >= 'A' && s[i] <= 'Z' && (i + delta) % 4 != 0)
		{
			delta += 4 - (i + delta) % 4;
		}
	}
	cout << delta;
	return 0;
}
```


---

## 作者：ForeverCC (赞：0)

遍历字符串，找到下标不是 $4$ 的倍数的大写字母，根据题意在此加上 $1$，然后加上占位符的数量即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a; 
int ans;
int main(){
	cin>>a;
    for(int i=0;i<a.size();i++)
    	if(a[i]>='A'&&a[i]<='Z'&&i%4!=0)
            ans+=4-(i+ans)%4;
    printf("%d\n",ans);
	return 0;
}
```


---


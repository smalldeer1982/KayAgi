# [CRCI2008-2009] MAJSTOR

## 题目背景

剪刀石头布是一种流行的两人游戏。

## 题目描述

在游戏中，两人都用自己的手出示三个手势之一：石头，布或剪刀。 

如果两个玩家出示相同的手势，则该游戏为平局。否则，剪刀胜布，布胜石头，而石头胜剪刀。

Sven 多年来一直在研究游戏的心理错综复杂性，并已成为游戏的真正大师，他的朋友们在一对一的游戏中没有与他抗衡的机会。

随着世界锦标赛的临近，Sven 正在与 $n$ 个朋友同时玩游戏，以练习他的技能。 

游戏有 $r$ 轮，在每一轮中，Sven 和他的每个朋友出三种手势之一。

计分规则：

- Sven 获胜，得 $2$ 分。
- 平局，得 $1$ 分。
- 对手获胜，得 $0$ 分。

编写一个程序来计算 Sven 的总得分，如果他事先知道他的朋友会出的所有手势，那么他最大得分也是可能的。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le n, r \le 50$。
#### 说明
- 本题满分 $50$ 分。
- 本题译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CRCI2008-2009](https://hsin.hr/coci/archive/2008_2009/regional_tasks.pdf) MAJSTOR，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
5
SSPPR
1
SSPPR 
```

### 输出

```
5
10```

## 样例 #2

### 输入

```
5
SSPPR
2
PPRRS
RRSSP 
```

### 输出

```
10
15```

## 样例 #3

### 输入

```
4
SPRS
4
RPRP
SRRR
SSPR
PSPS 
```

### 输出

```
12
21```

# 题解

## 作者：Yizhixiaoyun (赞：10)

### [题目传送门](https://www.luogu.com.cn/problem/P7184)

## 题目分析

这道题并不难，核心就是一个石头剪刀布的函数。

由于有可能出现平局，所以一个 bool 函数并不能很好地解决问题，再加上我们还可以顺便从函数中计算分数，所以使用 int 函数是更好的选择。

以下为核心代码：


```cpp
int winlose(char a,char b){
	if(a==b) return 1; //平 
	else if(a=='R'&&b=='S') return 2;
	else if(a=='P'&&b=='R') return 2;
	else if(a=='S'&&b=='P') return 2;
	//赢 
	return 0; //输 
}
```

接着就是模拟。第一个答案直接按照题意来，而第二个答案就是在每局都判断一下出什么得分最高。

## 贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,n;
int ans1,ans2;
char a[52][1002],s[1002];
int tot[3];
char u[3]={'R','S','P'};
int winlose(char a,char b){
	if(a==b) return 1;
	else if(a=='R'&&b=='S') return 2;
	else if(a=='P'&&b=='R') return 2;
	else if(a=='S'&&b=='P') return 2;
	return 0;
}
int main(){
	cin>>r;
	for(register int i=1;i<=r;++i) cin>>s[i];
	cin>>n;
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=r;++j){
			cin>>a[i][j];
		}
	}
	for(register int i=1;i<=r;++i){
		tot[0]=0;tot[1]=0;tot[2]=0;
		for(register int j=1;j<=n;++j){
			for(register int k=0;k<3;++k) tot[k]+=winlose(u[k],a[j][i]);
			ans1+=winlose(s[i],a[j][i]);
		}
		int q=max(tot[0],tot[1]);
		ans2+=max(q,tot[2]);
	}
	cout<<ans1<<endl<<ans2;
}
```

---

## 作者：Fire_Raku (赞：3)

~~感觉撞题解了qwq~~     
分析：游戏是 $1$ vs $1$ 的所以是一场比赛是，打赢一个算一个。   
最佳的得分，其实就是判断再一局里，怎样出拳得分最高。

首先，我们要写出函数 $f$，判断胜负：
```cpp
int f(char a , char b){
	if(a == b) return 1 ;
	if(a == 'R' && b == 'S') return 2 ;
	if(a == 'P' && b == 'R') return 2 ;
	if(a == 'S' && b == 'P') return 2 ;
	return 0 ;
}
```
实际得分，就是把我们这一局出的和每个朋友这一局出的一一丢到 $f$ 函数里，判断得分；而最大得分，就是把一局里，我们分别算出出剪刀，石头，布都能得到多少分，再取最大值就行了，记得每一局完，计算最大得分的数组都要归零。

注意事项：    
1. 要分清楚数组的存储，循环时数组要指对地方。
2. string 默认从 $0$ 开始，所以用 string 要注意数组的存储也要从 $0$ 开始。

代码（加注释）：
```cpp
#include<bits/stdc++.h>
using namespace std ;
int ans , sum ;
char a[1005] ;
int cnt[3] ;
char b[50][1005] , v[3] = {'R' , 'S' , 'P'};  //b数组存对手的顺序 ， v数组存 3 种出拳方式
int f(char a , char b){
	if(a == b) return 1 ;
	if(a == 'R' && b == 'S') return 2 ;
	if(a == 'P' && b == 'R') return 2 ;
	if(a == 'S' && b == 'P') return 2 ;
	return 0 ;
} //判断胜负
int main(){
	int r , n ; 
	cin >> r ; 
	for(int i = 1 ; i <= r ; i++) cin >> a[i] ;
	cin >> n ;
	for(int i = 1 ; i <= n ; i++){
		for(int j = 1 ; j <= r ; j++){
			cin >> b[i][j] ;
		} 
	}
	for(int i = 1 ; i <= r ; i++){
		cnt[0] = cnt[1] = cnt[2] = 0 ; //每过一场比赛，计算一场比赛的最佳得分就要归零
		for(int j = 1 ; j <= n ; j++){
			ans += f(a[i] , b[j][i]) ;
			for(int g = 0 ; g < 3 ; g++) cnt[g] += f(v[g] , b[j][i]) ; //判断最佳出拳得分
		}
		sum += max(cnt[0] , max(cnt[1] , cnt[2])) ; //加上一场比赛的最佳得分
	}
	cout << ans << endl << sum ; //输出
	return 0 ;
}
```

---

## 作者：No_Rest (赞：2)

## 题目思路

这道题蛮简单的，直接模拟就行了。我们需要一个计算胜负的函数，来加分，算答案。计算最大分数可以枚举每种可能，从中取最大值就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int r, n, max1, max2, max3, ans1, ans2;
string a, b[55], tmp = "RSP";
int f(char x, char y){//计分函数
	if(x == y){//一样，所以是平局，得一分
		return 1;
	}
	if(x == 'R' && y == 'S'){//其他胜利的情况
		return 2;
	}
	if(x == 'P' && y == 'R'){ 
		return 2;
	}
	if(x == 'S' && y == 'P'){ 
		return 2;
	}
	return 0;//否则就是输了
}
int main(){
	cin.tie(0);
	cin >> r >> a >> n;//输入
	for(int i = 0; i < n; i++){
		cin >> b[i];
	}
	for(int i = 0; i < r; i++){
		max1 = max2 = max3 = 0;//初始化
		for(int j = 0; j < n; j++){
			ans1 += f(a[i], b[j][i]);//模拟
			max1 += f('R', b[j][i]);//枚举出石头的情况
			max2 += f('S', b[j][i]);//枚举出剪刀的情况
			max3 += f('P', b[j][i]);//枚举出布的情况
		}
		ans2 += max(max1, max(max2, max3));//加上三者的最大值
	}
	cout << ans1 << endl << ans2;//输出
	return 0;//好习惯
}
```

---

## 作者：Elgo87 (赞：1)

- ###### ~~本题解或成最易懂题解？~~

- ###### ~~说明，代码很冗长，但是很易懂！~~

- ###### ~~这篇题解只要学过数组的OIer都能懂！~~

- ###### ~~I AK IOI~~


咳咳，回到本题，石头剪刀布。


# 自定义函数


既然我们做这个石头剪刀布，那就要判断两个人出拳时的胜负情况了，所以我们可以写下面这个函数（参见[B2112](https://www.luogu.com.cn/problem/B2112)）：


```
/*判断一局游戏的胜负，胜2，平1，负0*/
//为什么要返回2、1、0呢，
//这是为了以后引用这个函数的时候直接给Sven加上对应的分数，
//就是可以这么写：s+=game('S','P')
int game(char c1,char c2)
{
	char s='S',p='P',r='R'; //只是为了更好打字
	
	//因为此文“清晰易懂”，所以这么写
	//枚举两个人每种出拳状态时的胜负状况
	if(c1==s)
		if(c2==s) return 1;
		else if(c2==p) return 2;
		else if(c2==r) return 0;
	if(c1==p)
		if(c2==s) return 0;
		else if(c2==p) return 1;
		else if(c2==r) return 2;
	if(c1==r)
		if(c2==s) return 2;
		else if(c2==p) return 0;
		else if(c2==r) return 1;
}
```


------------

接着，为了统计每一场比赛中Sven加的分数，我们还可以写出函数 ```score(char s1[],char s2[])``` ：**（ 例如Sven出"SSS",另一个人出"PPP",那么 ```score("SSS","PPP")=6``` ）**

```
/*求一场比赛的得分*/
int score(char s1[],char s2[])
{
    int ans=0;
    
    //因为题目保证s1和s2长度一致，所以只要写i<strlen(s1)。
    for(int i=0;i<strlen(s1);i++)
        ans+=game(s1[i],s2[i]);
    return ans;
} 
```
# 主函数
- #### 第一步：输入不多讲。

其中 ```my[]、other[][]``` 代表Sven和其他人的出拳顺序。
```
int n,r;
char my[55],other[55][55];	
cin>>n>>my>>r;
for(int i=0; i<r; i++)
    cin>>other[i];
```
- #### 第二步：解第一问（Sven的胜负得分）

```cpp
int ans=0;
for(int i=0; i<r; i++)
    ans+=score(my,other[i]);
cout<<ans<<'\n';
```
- #### 第三步：解第二问

>暴力出奇迹，骗分过样例。

>对于 100% 的数据， $1 ≤ n , r ≤ 50$ 。

思路是这样的，我们可以枚举Sven可以出拳的顺序，

然后用 ```ans``` 存储最多的得分。

- **步骤：**

1. 首先枚举Sven出拳字符串中的所有字符。

2. 然后枚举每个字符中所有可能出现的出拳类型（即"S"、"P"、"R")。

3. 累加每个可能性中，Sven得到的积分，再求积分的最大值。

```
int maxn[55]={0};  ans=0;
for(int k=0; k<n; k++)//步骤一
{
    for(int i=0; i<3; i++)//步骤二
    {
        //步骤三：
        char ch=type[i];//ch为出拳类型
        int sum=0;//累加器
        for(int j=0; j<r; j++)
        {
            //累加石头剪子布的积分
            sum+=game(ch,other[j][k]);
        }
        //记录最大值，列出一个一位表
        maxn[k]=max(maxn[k],sum);
    }
}
//在一位表中求和
for(int i=0; i<n; i++) 
    ans+=maxn[i];
//输出，Oh Yeah
cout<<ans;
```

# $Code$ 
```cpp
#include<bits/stdc++.h>
using namespace std;

char type[3]={'S','P','K'};;
/*判断一局游戏的胜负，胜2，平1，负0*/
int game(char c1,char c2)
{
	char s='S',p='P',r='R';
	
	if(c1==s)
		if(c2==s) return 1;
		else if(c2==p) return 2;
		else if(c2==r) return 0;
	if(c1==p)
		if(c2==s) return 0;
		else if(c2==p) return 1;
		else if(c2==r) return 2;
	if(c1==r)
		if(c2==s) return 2;
		else if(c2==p) return 0;
		else if(c2==r) return 1;
}

/*求一场比赛的得分*/
int score(char s1[],char s2[])
{
	int ans=0;
	for(int i=1;i<=strlen(s1);i++)
		ans+=game(s1[i],s2[i]);
	return ans;
} 

int main()
{
	int n,r;
	char my[55],other[55][55];	
	cin>>n>>my>>r;
	for(int i=0; i<r; i++)
		cin>>other[i];
		
	int ans=0;
	for(int i=0; i<r; i++)
		ans+=score(my,other[i]);
	cout<<ans<<'\n';
	
	int maxn[55]={0};  ans=0;
	for(int k=0; k<n; k++)
	{
		for(int i=0; i<3; i++)
		{
			char ch=type[i];
			int sum=0;
			for(int j=0; j<r; i++)
			{
				sum+=game(ch,other[j][k]);
			}
			maxn[k]=max(maxn[k],sum);
		}
	}
	for(int i=0; i<n; i++) 
		ans+=maxn[i];
	cout<<ans;
	return 0;
}
```
## PS:防作弊，所以本代码中暗藏了若干个错误！
# (编译器不报错）

---

## 作者：MGR_P (赞：1)

题意翻译：给定一个长度为 $n$ 的排列 $\mathrm{A}$，并给定 $r$ 个类似排列，根据每个排列对应字符的不同可以获得相应得分。让 $\mathrm{A}$ 与其余排列比较。求出总得分，并给出一个最优排列方案，使得总得分最大。

显然可以将得分判定封装为一个函数，代码如下:

```
void Sven(int c,int g,int d) {
    if(a[c]==b[g][d]) ans++;
    if(a[c]=='S'&&b[g][d]=='P') ans+=2;
    if(a[c]=='P'&&b[g][d]=='R') ans+=2;
    if(a[c]=='R'&&b[g][d]=='S') ans+=2;
}
```
设 $ans$ 为总得分。

可以用一个二维字符数组 $b$ 来储存其余排列，$b_{i,\,j}$ 为第 $i$ 个排列的第 $d$ 个字符。

可以边读入边处理，代码如下:

```cpp
for(int i=1; i<=r; i++) {
    for(int j=1; j<=n; j++) {
        cin>>b[i][j];
        Sven(j,i,j);
    }
}
```

第一问就做完了。

第二问可以用一个贪心的想法，因为排列各字符之间互不影响，局部最优策略可以产生全局最优策略，于是可以枚举 $\mathrm{A}$ 上的每个字符的可能情况并依次与其余排列比较，选择最优，证明显然。

```cpp
for(int j=1; j<=n; j++) {
    for(int i=1; i<=r; i++) {
        c[i]=b[i][j];
    }
}
```

这里用了一个临时数组 $c$ 存储当前排列，然后是计算得分的函数。

```cpp
void Sven1(int a) {
    if(c[a]=='R') l++;
    if(c[a]=='S') l+=2;
}
void Sven2(int a) {
    if(c[a]=='S') f++;
    if(c[a]=='P') f+=2;
}
void Sven3(int a) {
    if(c[a]=='P') h++;
    if(c[a]=='R') h+=2;
}
```
接下来是总代码。
```cpp
#include <bits/stdc++.h>
#define N 120
using namespace std;
int n,r,ans=0,l,f,h,anss=0;
char a[N],b[N][N],c[N];
char s='R',su='S',sum='P';
void Sven(int c,int g,int d) {
    if(a[c]==b[g][d]) ans++;
    if(a[c]=='S'&&b[g][d]=='P') ans+=2;
    if(a[c]=='P'&&b[g][d]=='R') ans+=2;
    if(a[c]=='R'&&b[g][d]=='S') ans+=2;
}
void Sven1(int a) {
    if(c[a]=='R') l++;
    if(c[a]=='S') l+=2;
}
void Sven2(int a) {
    if(c[a]=='S') f++;
    if(c[a]=='P') f+=2;
}
void Sven3(int a) {
    if(c[a]=='P') h++;
    if(c[a]=='R') h+=2;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();
    cin>>n;
    for(int i=1; i<=n; i++) cin>>a[i];
    cin>>r;
    for(int i=1; i<=r; i++) {
        for(int j=1; j<=n; j++) {
            cin>>b[i][j];
            Sven(j,i,j);
        }
    }
    for(int j=1; j<=n; j++) {
        for(int i=1; i<=r; i++) c[i]=b[i][j];
        for(int z=1; z<=r; z++) {
            Sven1(z);
            Sven2(z);
            Sven3(z);
        }
        anss+=max(l,max(f,h));
        l=f=h=0;
    }
    cout<<ans<<endl<<anss;
    return 0;
}
```

---

## 作者：CarryQwQ (赞：0)

## 题目分析

对于判断每局 Sven 是胜，负还是平可以手写一个函数判断，像这样：
```cpp
int check(char s, char f){//s 表示 Sven 出的符号，f 表示他的朋友出的符号
	if (s == f) return 1;
	if (s == 'S' && f == 'P') return 2;
	if (s == 'P' && f == 'R') return 2;
	if (s == 'R' && f == 'S') return 2;
	if (s == 'S' && f == 'R') return 0;
	if (s == 'P' && f == 'S') return 0;
	if (s == 'R' && f == 'P') return 0;
}
```


求实际分数直接按题意模拟。

而最大的得分则可以枚举每局 Sven 三种不同的出拳方式，选取能获得得分的最大值累加。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int r, n, sum, msum, tmp[4];
string sve, fri[55], SPR="SPR";
int check(char s, char f){
	if (s == f) return 1;
	else if (s == 'S' && f == 'P' || s == 'P' && f == 'R' || s == 'R' && f == 'S') return 2;
	else return 0;
}
int main() {
	cin >> r >> sve >> n;
	for (int i = 1; i <= n; i++) cin >> fri[i];
	for (int i = 0;i < r;i++){
		tmp[0] = tmp[1] = tmp[2] = 0;
		for (int j = 1;j <= n;j++){
			sum += check(sve[i], fri[j][i]);
			for (int k = 0;k < 3;k++) tmp[k] += check(SPR[k], fri[j][i]);
		}
		msum += *max_element(tmp, tmp+3);
	}
	cout << sum << endl << msum;
}
```




---

## 作者：Nemonade (赞：0)

**几乎纯模拟**

我的思路是，先人工打表求出胜负关系。然后跑两遍。第一次求出实际得分，第二次暴力求得每一局的最大得分，最后求和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55;
int kkk,n,ma[N],ans,ans2;
string s,f[N];
//下标0,2,3对应字符'S','P','R'
char hi[]={'S','P','R'};

int check(char x,char y){
	//判断平局 
	if(x==y) return 1;
	//人工求胜负 
	if(x=='S'&&y=='P') return 2;
	if(x=='S'&&y=='R') return 0;
	if(x=='P'&&y=='S') return 0;
	if(x=='P'&&y=='R') return 2;
	if(x=='R'&&y=='S') return 2;
	if(x=='R'&&y=='P') return 0;
}
int main(){
	//输入 
	cin>>kkk;cin>>s;cin>>n;
	for(register int i=1;i<=n;++i) cin>>f[i];
	
	//第一次模拟实际胜负 
	for(register int p=0;p<kkk;++p){
		//获取Sven的出拳 
		char sv=s[p];
		//循环每一个对手 
		for(register int i=1;i<=n;++i){
			//获取对手的出拳 
			char fd=f[i][p];
			//调用计分的函数并累加得分 
			ans+=check(sv,fd);
		}
	}
	cout<<ans<<endl;
	
	//第二次求出每局最大值 
	for(register int p=0;p<kkk;++p){
		//枚举三种出拳 
		for(register int i=0;i<=2;++i){
			//获取Sven出拳 初始化这种情况的得分 
			char sv=hi[i];int sum=0;
			for(register int j=1;j<=n;++j){
				//累加 
				sum+=check(sv,f[j][p]);
			}
			//每一局取最大值 
			ma[p]=max(ma[p],sum);
		}
	}
	//累加最后答案 
	for(register int i=0;i<kkk;++i) ans2+=ma[i];
	cout<<ans2;
	return 0;
}
```

---

## 作者：Query_Failed (赞：0)

本题的主要思路就是**模拟加上枚举**，值得注意的是：本题除了正常的判断以外，还需要在知道朋友的分数下，求出 Sven 的最大得分，因此我们需要枚举出当 Sven 在每一局中出石头、剪刀或布的得分，并取其中的最大值。
## 附代码：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int panduan(char my,char myfriend)      //对局中的判断函数 
{
	if(my=='S')
	{
		if(myfriend=='S') return 1;
		else if(myfriend=='P') return 2;
		else return 0;
	}
	else if(my=='P')
	{
		if(myfriend=='S') return 0;
		else if(myfriend=='P') return 1;
		else return 2;
	}
	else
	{
		if(myfriend=='S') return 2;
		else if(myfriend=='P') return 0;
		else return 1;
	}
}
int main()
{
	int r;
	cin>>r;
	char Sven[r];
	for(int i=0;i<r;i++)
	{
		cin>>Sven[i];
	} 
	int n;
	cin>>n;
	int realgoal=0,maxgoal=0;
	int maxs=0,maxr=0,maxp=0;  //枚举不同情况下 Sven 的得分 
	char friends[n][r];
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<r;j++)
		{
			cin>>friends[i][j];
			realgoal+=panduan(Sven[j],friends[i][j]); //实际分数只需要直接判断 
		}
	}
	for(int j=0;j<r;j++)
	{
		for(int i=0;i<n;i++)
		{
			maxs+=panduan('S',friends[i][j]);
			maxr+=panduan('R',friends[i][j]);
			maxp+=panduan('P',friends[i][j]);
		}
		maxgoal+=max(max(maxs,maxp),maxr); //取出最大值 
		maxs=0;
		maxr=0;
		maxp=0; 
	}
	cout<<realgoal<<endl<<maxgoal;
	return 0;
}

```


---


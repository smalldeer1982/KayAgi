# [COCI 2019/2020 #3] Preokret

## 题目背景

圣诞节后的一天——圣史蒂芬日，将要到来了。在非宗教领域，它在英国被称为节礼日。在克罗地亚人通过享用大餐来庆祝的同时，我们的英国朋友却有着踢足球的传统。

今年圣诞节，Pep 吃了太多的烤牛肉，因此他决定这次不踢足球，而是在家中分析球赛。

## 题目描述

已知有 $N$ 次进球得分以及它们的顺序。他想要得到下列问题的答案：

1. 最终的得分是多少，即 City 队及其对手的得分。

2. 球赛过程中有几次打平，即两队进球数目相同。初始比分 `0:0` 也算作一次打平。

3. 球赛中最大的「翻盘」。「翻盘」指其中一队在比分落后的情况之下，通过**连续**进球若干次，在比分上领先于对方。他想知道该队的进球数是多少。数据保证至少有一次「翻盘」。

## 说明/提示

#### 样例解释

第一个样例的解释：

$6$ 次比分分别为：`0:0`、`1:0`、`2:0`、`2:1`、`2:2`、`2:3`。其中，有 $2$ 次平局—— `0:0` 和 `2:2`。最大的「翻盘」指 City 对手以 `2:0` 落后，但后续进球 $3$ 次，比分变为 `2:3`，得分超过 City。

第二个样例的解释：

$10$ 次比分分别为：`0:0`、`1:0`、`1:1`、`1:2`、`2:2`、`3:2`、`4:2`、`4:3`、`5:3`、`6:3`。其中，有 $3$ 次平局—— `0:0`、`1:1` 以及 `2:2`。最大的「翻盘」指 City 以 `1:2` 落后，但后续进球 $3$ 次，比分变为 `4:3`，得分超过对手。

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le N \le 250$。

#### 评分方式

本题中，每个测试点按行给分。第一行和第二行分值均为 $1$ 分，第三行分值为 $3$ 分，因而启用 Special Judge。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

本题使用非官方的 [Special Judge](https://www.luogu.com.cn/paste/zfwv9rik)，欢迎大家 hack（可私信或直接发帖）。

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #3](https://hsin.hr/coci/archive/2019_2020/contest3_tasks.pdf)  _T1 Preokret_ 。**

## 样例 #1

### 输入

```
5
1
1
2
2
2```

### 输出

```
2 3
2
3```

## 样例 #2

### 输入

```
9
1
2
2
1
1
1
2
1
1```

### 输出

```
6 3
3
3```

## 样例 #3

### 输入

```
3
2
1
1```

### 输出

```
2 1
2
2```

# 题解

## 作者：_JF_ (赞：8)

# **P7203 Preokret**
这题就是个大模拟

第一个问就是要算两队的得分情况。即在输入的时候用两个计数器进行统计即可，最后输出答案，第一个问就解决了。

第二个问题是要算打平的次数。注意题目有声明 $0:0$ 也是一种平手，所以变量初始时应该为 $1$ 

重点来讲一下第三个问：

首先我们要在遍历整个过程时，重新统计得分。当当前的数字和下一个数字不一样的时候，那么就有可能出现翻盘的情况。但是要在 $num$ 和 $sum$ 不相同的情况下。接着就再往下枚举，如果和当前的值不一样，证明有进球了。最后用 $maxx$ 统计出最大的翻盘球的数量即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int a[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)	
		cin>>a[i];
	int sum=0,ans=1,num=0;//ans=1是因为0:0也算作一个平局 ，sum是A队 num是B队 
	for(int i=1;i<=n;i++)
	{
		if(a[i]==1)
			sum++;
		else if(a[i]==2)
			num++;//分类讨论 
		if(sum==num)//平局的操作 
			ans++;
	}
	cout<<sum<<" "<<num<<endl;
	cout<<ans<<endl;// 第一和第二个操作 
	int maxx=0;
	sum=0,num=0;
    for(int i=1;i<=n;i++)
    {
    	if(a[i]==1)
			sum++;
		else if(a[i]==2)
			num++;
    	int sheng=0;
    	if(a[i+1]!=a[i]&&((num>sum)||(sum>num)))//当当前的数字和下一个数字不一样的时候，那么就有可能出现翻盘的情况。但是要在num和sum不相同的情况下 
    	{
    		for(int j=i+1;j<=n;j++)//枚举下一个数的情况 
    		{
    			if(a[j]!=a[i])//若不一样，视为进球 
    				sheng++;
    			else
    				break;
			}
			if(a[i]==1)
			{
				if(num+sheng>sum)
					maxx=max(maxx,sheng);
			}
			else 
			{
				if(sum+sheng>num)
					maxx=max(maxx,sheng);
			}
			//操作一样 统计 maxx的最大的数 
		}
	}
	cout<<maxx<<endl;//输出 
	return 0;//完美的结束 
}
```
理解万岁！ 拒绝抄袭！

再次请求管理员可以通过


---

## 作者：_xbn (赞：8)

看到这题没有题解，我来补一个。

此题数据范围很小，纯模拟即可通过，但存在很多细节问题。

第一问和第二问相信大家都能解决，这里不多解释。

详细来讲第三问。

题目要求最大的翻盘次数，所以我们可以每次对弱后的队伍打一个弱后标记，

再加一个计数器，记录一个队伍落后之后连续进球的次数，当一个队伍成功

翻盘后，把他的计数器对 $ans$ 取一个 $max$ 。最后 $ans$ 即为答案。

核心代码：

```cpp
for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        if(x==1)
        {
            if(num>city)ans=max(ans,q);
            if(city<num)flag=1;
            city++;
            if(flag==1)p++;
            q=0;
        }
        else
        {
            if(city>num)ans=max(ans,p);
            if(num<city)flag=2;
            num++;
            if(flag==2)q++;
            p=0;
        }
        if(city==num)sum++;
    }
```



---

## 作者：xieyikai2333 (赞：3)

# 一道模拟~~水~~题

- [题目传送门](https://www.luogu.com.cn/problem/P7203)

---

- 这题前面两个子问题的答案非常简单，这里不再赘述了。我们重点讲一下最大翻盘的求法

我们开两个数组 $p[3]$ 和 $g[3]$ ，用 $p_1$ 表示 City 队的得分； $p_2$ 表示对方的得分。 $g_1$ 表示 City 队连胜的得分； $g_2$ 表示对方连胜的得分。如果连胜断了就清零。

---

```cpp
if(get[x]==0&&win==x&&p[x]<p[3-x])ans=max(ans,get[3-x]),win=3-x;
```

这个语句中，第一个条件表示当前得分的队伍连胜为 $0$ ，之前都是另一队的得分，到现在才断；第二个条件表明原先是当前队伍领先；第三个条件表明当前队伍被翻盘成功了。当这三个条件全部满足时，就要把最大翻盘取一个 $max$ 并把领先队伍换成另一队了。

---

**AC 代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int p[3],get[3];
int main()
{
	int n,x,win,same=1,ans=0;
	cin>>n>>x;
	p[x]++,win=x,get[x]++;
	for(int i=2;i<=n;i++)
	{
		cin>>x;
		if(get[x]==0&&win==x&&p[x]<p[3-x])ans=max(ans,get[3-x]),win=3-x;
		get[x]++,get[3-x]=0;
		p[x]++;
		if(p[1]==p[2])same++;
	}
	if(p[win]<p[3-win])ans=max(ans,get[3-win]);
	printf("%d %d\n%d\n%d",p[1],p[2],same,ans);
	return 0;
}
```

---

附上 [AC记录](https://www.luogu.com.cn/record/57095372)

---

## 作者：xxasmcd (赞：2)

这道题可以简单模拟。

用一个 a 数组表示整场两队的进球数，一个 d 数组来表示现在其中连续的得分数量，ans 来记录最大的翻盘数量，same 来记录得分相同的次数，temp 记录现在哪一队得分高。
 
要注意刚开始也算一次相同，所以最后 same 要加一。
 
代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[4],d[4],temp,same=0,ans=0;
int main()
{
    cin>>n;
    cin>>x;
    a[x]++;
    d[x]++;
    temp=x;
    for(int i=2;i<=n;i++)
    {
        cin>>x;
        if(a[x]<a[3-x]&&temp==x&&d[x]==0)ans=max(d[3-x],ans),temp=3-x;
        d[x]++;
        d[3-x]=0;
        a[x]++;
        if(a[1]==a[2])same++;
    }
    if(a[temp]<a[3-temp])ans=max(d[3-temp],ans);
    cout<<a[1]<<" "<<a[2]<<endl<<same+1<<endl<<ans;
    return 0;
}

```


---


# [COCI 2009/2010 #3] SLATKISI

## 题目背景

可爱的 Mirko 在糖果店买了很多糖果。

## 题目描述

他不能总是支付准确的金额，所以店主和他达成了协议。

他告诉店主他有的最小的钞票，店主就把他的金额四舍五入到他能支付的最接近的数字。

例如，如果 Mirko 最小的钞票是 $100$ 元，他想买 $150$ 元的糖果，店主就把他的金额四舍五入到 $200$ 元。如果他想买 $149$ 元的糖果，店主就会把他的金额四舍五入到 $100$ 元。

最近，Mirko 怀疑店主想骗他。请你判断店主有没有骗他。

Mirko 的妈妈只会给他 $1, 10, 100, 10^3, 10^4, 10^5, \cdots, 10^9$ 元钞票，他有无限张这些钞票。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le c \le 10^9$，$0 \le k \le 9$。

#### 说明
翻译自 [COCI 2009-2010 #3 T2 SLATKISI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 50，每个测试点 5 分，共 10 个测试点。

## 样例 #1

### 输入

```
184 1
```

### 输出

```
180```

## 样例 #2

### 输入

```
123450995 1
```

### 输出

```
123451000```

## 样例 #3

### 输入

```
182 2
```

### 输出

```
200```

# 题解

## 作者：追梦之鲸 (赞：8)


本蒟蒻的第$008$篇题解。

[经典回顾P7258](https://www.luogu.com.cn/problem/P7258)

##### ~~那么好的一道打表题你们给弄成了啥！~~

言归正传，我们可以先把$10^0$~$10^9$都打表，然后就有了下面一段代码

~~~c
#include<bits/stdc++.h>
using namespace std;
int s=1;
int main()
{
	cout<<"w[10]={1,";
	while(1)
	{
		s*=10;
		cout<<s<<",";
		if(s==1000000000) break;
	}
	cout<<"}";
	return 0;
}
~~~

好了，那么再来说说判断四舍五入

判断第$k$位需不需要四舍五入，那就要看k-1位是否$<=4$，是则舍，否则入

那么怎么求``k-1``位上的数呢

其实很简单，那就是``c%w[k]/w[k-1]``，因为``c%w[k]``求的是$c$的$k$位及以下的数，在除以``w[k-1]``就求出了第``k-1``位上的数 

最后还有一个问题：怎么输出？

其实就是``c/w[k]*w[k]``

要是进一的话就是``(c/w[k]+1)*w[k]``

最后提醒大家：

## 一定要注意括号！ 

### code：
```c
#include<bits/stdc++.h>
int sum,c,k,w[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
int main()
{
	scanf("%d%d",&c,&k);
	if(k==0)return printf("%d",c) & 0;//如果k=0,那么就不需四舍五入了,直接输出就行
	k=w[k];//注意这里可能和讲的不同,请见谅 
	sum=c%k/(k/10);
	if(sum<5)return printf("%d",(c/k*k)) & 0;
	return printf("%d",((c/k+1)*k)) & 0;
    	//看到这有些同学可能会疑惑：return … & 0;是什么鬼？,其实它是输出并return 0 
}
```

最后管理大大求过&&[**来玩啊**](https://www.luogu.com.cn/user/361726)

---

## 作者：Ptilopsis_w (赞：4)

# 1.题意
其实就是一个四舍五入到规定位的题。

# 2.思路
1. 先打表出10的次幂，这样比较好操作。  
2. 先让c除以 $10^k$ 再乘 $10^k$(整数运算)，这样可以把尾数全清掉，再单独提取出来 $10^{k-1}$ 位的数进行判断，最后输出即可。

# 3.代码附注释
```cpp
#include<cstdio>
using namespace std;
int p[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};//10的次幂
int max(int a, int b){ return a > b ? a : b; }
int main()
{
    int c, k;
    scanf("%d%d", &c, &k);
    int c1 = c/p[k];//先除以10^k
    int flag = (c/p[max(k-1,0)])%10;//对10取模取出个位数
    //这个max(k-1,0)是为了防止数组下标出现负数
    //其实就是k=0时的特判
    if(flag > 4)//四舍五入的条件
        c1++;
    printf("%d", c1*p[k]);//最后再乘上10^k输出
    return 0;
}
```

---

## 作者：Wu_while (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P7258)

题目里对输入的描述似乎不太精确：

$Mirko 最小的钞票上的零数$

指的是$10$的**指数**(即$10^3$,$10^4$,$10^5$上面的$3$,$4$,$5$)。

## 题意分析
通过对题意的分析，我们可以将题意**简化**成：

将数字$c$**四舍五入**精确到$k$位

顿时~~高大上的~~橙题就变成了**小学数学题**(~~这可能就是此题没有算法标签的原因之一~~)

## 于是开始考虑四舍五入的问题：

~~众所周知~~$C++$的**整型除法**自带向下取整，所以不需要写复杂的四舍五入函数，四舍就除以$k$再乘$k$，五入就除以$k$加$1$再乘$k$。

于是我们就只需要判断**是四舍还是五入**：

~~小学数学告诉我们~~如果精确的那位小于$5$则四舍,大于等于$5$则五入。

### 综上所述：
## 废话了一堆
#  $Code$
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int c,k,n,ans;
int main()
{
	cin>>c>>k;
	n=pow(10,k);
	if(c%n<n/2) //判断四舍
		cout<<c/n*n;
	else //否则五入
		cout<<(c/n+1)*n;
	return 0;
 } 
```

[AC 50分](https://www.luogu.com.cn/record/45692624)

---

## 作者：Chtholly_L (赞：1)

# 题解 P7258 【[COCI2009-2010#3] SLATKISI】

##### ~~大家好，我是奆蒟蒻，这已经是本奆蒟蒻的第 $8$ 篇题解了。~~

题面很简单，再简化就是

### **将 $c$ 四舍五入，精确到 $10^k$ .**

------

四舍五入其实很简单。

将原数与精确到的位数（即 $10^k$ ）取模，再与精确到的位数的一半比较，如果小于（即“四舍五入”中的“四舍”），与原位数相乘，就成了四舍五入好的数；如果大于（即“四舍五入”中的“五入”），与原位数相乘，再加上精确到的位数，就是四舍五入好的数。

 * 注！ C++中的除法自带向下取整，所以四舍直接除就可以，而五入需要再加上一个精确到的位数。

弄懂了原理，就可以来代码实现了。

直接上代码讲解

## $Ac$ $Code$

```cpp
#include<iostream>
#include<cmath>  //pow的库
using namespace std;
int main()
{
	int c,k;
	cin>>c>>k;
	int q;  // q 为精确到的数
	q=pow(10,k);  // pow 算次方的函数，在函数库 cmath 里
	if(c%q>=q/2)  //大于了，五入
	{
		cout<<c/q*q+q;  //需要再加上一位
	}
	else if(c%q<q/2)  //小于了，四舍
	{
		cout<<c/q*q;  //不需要再加上一位
	}
	return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/46317152)

[博客食用更佳](https://www.luogu.com.cn/blog/maxsuper/)

* 注！ 这道题的满分是50分，没拿到100分的不用着急

---

## 作者：梦游的小雪球 (赞：0)

## 梦雪的思路

**简化题意：** 给你$c$和$k$，让你把数字$c$四舍五入精确到第$k$位。

**四舍五入：** 如果精确的那一位小于$4$，则舍去；否则入。

**函数pow(a,b):** $pow(a,b)=a$的$b$次方。

## 你们的最爱

```
#include<bits/stdc++.h>
using namespace std;
int c,k;
int main(){
	scanf("%d%d",&c,&k);
	int u=pow(10,k);
	if(c%u<u/2)
		cout<<c/u*u;//四舍
	else
		cout<<c/u*u+u;//五入
	return 0;
}
```

注：本题满分50分。

---

## 作者：efgh123 (赞：0)

## 题意

[传送门](https://www.luogu.com.cn/problem/P7258)

Mirko 在糖果店买了很多糖果

他不能总是支付准确的金额，所以店主和他达成了协议。

他告诉店主他有的最小的钞票，店主就把他的金额四舍五入到他能支付的最接近的数字。

例如，如果 Mirko 最小的钞票是 $100$ 元，他想买 $150$ 元的糖果，店主就把他的金额四舍五入到$200$ 元。如果他想买 $149$ 元的糖果，店主就会把他的金额四舍五入到 $100$ 元。

最近，Mirko 怀疑店主想骗他。请你判断店主有没有骗他。

Mirko 的妈妈只会给他$10^0,10^1,10^2,10^3,10^4,10^5,10^6,10^7,10^8,10^9$ 元钞票，他有无限张这些钞票。

## 思路

1.确定Mirko最小的钞票的价值（即$10^k$)

2.特判$k$=1的情况(即输入时$k$=0)

3.特判$c$<=$k$的情况(即输入时$c$<=$10^k$)

4.确定是“四舍”还是“五入”(即第$k$位是否小于5)

5.清零（即从第$k$-1位开始四舍五入后都为0）

6.四舍五入（注意用pow会默认使用科学计数法，会WA一半的点）

## Code

```C++
#include<bits/stdc++.h>
using namespace std;
int main() {
	long long c,k;//c表示Mirko买的糖果的价格，k表示Mirko最小的钞票上的零数
	cin>>c>>k;
	int p=k+1;//表示Mirko最小的钞票的价值的数字个数 
	k=pow(10,k);//此时k表示Mirko最小的钞票的价值
	long long num;//表示四舍五入到最接近的Mirko可以的支付金额。
	if(k==1){//特判k=1的情况（这种情况不用四舍五入）
		cout<<c;
		return 0;
	}
	if(c<=k){//特判c<=k的情况（这种情况不是k就是0） 
		if(c<k/2){
			cout<<"0";
		}
		else { 
			cout<<k;
		}
		return 0;
	} 
	bool sswr;//确定是“四舍 ”还是“五入 ” 
	if(c/(long long)pow(10,p-2)%10<5){//“四舍 ”
		sswr=0;
	} 
	else {//“五入 ”
		sswr=1;
	}
	c=c/k*k;//“四舍五入” 后面清零
	if(sswr){
		//用pow会使用科学计数法，会WA
		long long sum=1;
		for(int i=0;i<p-1;i++) {
			sum*=10;
		}
		cout<<c+sum;
	}
	else cout<<c;
	return 0;
}
```



---

## 作者：sysong (赞：0)

# 题解P7258 [COCI2009-2010#3] SLATKISI

### 题目描述

给出两个数字 $c,k$，求 $c$ 四舍五入到第 $k$ 位的值。

### Solution

~~不知道为什么字符串这么烦，跑的还比直接处理数字快。~~

这里把 $c$ 记为 $s$，$k$ 记为 $a$ 。

我们采用字符串存储 $s$，求出 $s$ 的长度 $len$。

然后我们分类讨论：

1. 如果 $len < a$，直接输出 $0$。
2. 如果 $len = a$，根据首位大小判断是否进位。
3. 如果 $len < a$，从第 $len - a - 1$ 位开始判断是否要向前进位，最后判断首位是否进位。

### Code

```c++
#include <bits/stdc++.h>
#define gc() getchar()
using namespace std;

int main(){
	char s[10];int a,l;
	scanf("%s%d",s,&a);
	l=strlen(s);
    
	if(l<a)printf("0\n");
    
	else if(l==a){
		if(s[0]>='5'){
			putchar('1');
			for(int i=0;i<a;i++)putchar('0');
			putchar('\n');
		}
		else printf("0\n");
	}
    
	else{
		s[l-a-1]+=s[l-a]>='5'?1:0;
		for(int i=l-a-1;i;i--)if(s[i]>'9')++s[i-1],s[i]='0';else break;
		if(s[0]>'9')putchar('1'),s[0]='0';
		for(int i=0;i<l-a;i++)putchar(s[i]);
		for(int i=0;i<a;i++)putchar('0');
		putchar('\n');
	}
    
	return 0;
}

```

***by jsntsys***

$2021.1.10$



---

## 作者：SUNCHAOYI (赞：0)

这道题目的本质还是对于四舍五入的理解。

对于一个位上的数 $x$，若 $0 \le x \le 4$，则会舍到 $0$；若 $5 \le x \le 9$，则会进一位到 $10$。而题目中的**零数** $k$ 为 $0-9$，分别代表个、十、百 $\cdots$。

因此可以为一个数的一半为界进行判断，四舍只要抹去余数，五入则需加上除余数不足的部分，代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 1e5 + 5;
const int MOD = 1e9 + 7;
ll read ();
ll a[15] = {1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9};//先存入题目中的数
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	ll c = read ();
	ll k = read ();
	if (c % a[k] < (a[k] >> 1)) printf ("%d\n",c - c % a[k]);//减去余数
	else printf ("%d\n",c - c % a[k] + a[k]);//加上剩余部分
	return 0;
}
ll read ()
{
    ll s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}

```

---


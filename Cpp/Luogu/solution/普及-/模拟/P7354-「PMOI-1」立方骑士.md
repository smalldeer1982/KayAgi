# 「PMOI-1」立方骑士

## 题目背景

lhm 最近迷上了国际象棋，他对里面的骑士最感兴趣，于是就开辟了下面这个玩法。

## 题目描述

lhm 现在建立了一个大小为 $n \times m$ 的国际象棋棋盘，你作为白方要与黑方作战。棋盘上黑方只有一个国王，**国王位置不会移动**，而 lhm 有无穷无尽的骑士。现在你需要解出，最少派出几个骑士才能将死黑方国王，定义将死的标准为**黑方国王在不被吃掉的情况下不能移动为止**。

更形式化地讲：一个 $n\times m$ 的棋盘上有一个国王，你需要摆放尽可能少的骑士在棋盘上，使得对于每一个国王能走**正好一步**达到的且不在棋盘外的位置，都存在至少一个骑士能走**正好一步**达到。

棋子的移动方法：

国王每一步能向上、下、左、右、左上、右上、左下、右下八个方向移动一格。

骑士与国际象棋规则相同，每次可以走日字（即 $2\times3$ 长方形的对角线，详见样例）。**注意没有蹩马腿规则，也就是只要不走出棋盘且按照日字格行走，其他没有限制。**

lhm 太菜了，只好请聪明的你来帮他完成这个任务。

## 说明/提示

【样例1解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/c5d055nl.png)

一个类似上图的棋盘，$\text{K}$ 表示黑方国王，$\text{N}$ 表示白方骑士，$\color{red}{\times}$ 表示骑士可以到达的地方（其中 $(3,3)$ 的 $\text{N}$ 封住了 $(1,2)$ 和 $(2,1)$，$(1,4)$ 的 $\text{N}$ 封住了 $(2,2)$
，形如上图，$\text{K}$ 已经被封死了，所以两个骑士足矣。可以证明两个骑士是最小个数。

【数据范围】

- 对于 $30\%$ 的数据，保证国王的初始位置一定在棋盘最外面一圈。

- 对于 $100\%$ 的数据满足，$1 \leq t \leq 10$，$1 \leq x,y \leq 10^9$，$8 \leq n,m \leq 10^9$。

## 样例 #1

### 输入

```
1
8 8 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2
10 9 1 9
999 999 999 2```

### 输出

```
2
3```

# 题解

## 作者：樱雪喵 (赞：77)

~~偷偷来水篇题解（（（~~

注：在本篇题解中， $K$ 表示国王， $N$ 表示骑士，不同颜色的 $X$ 表示该位置国王可以达到，且被与之相同颜色的骑士封锁。方法不唯一，图中的方法仅作示例。

根据题目，可以得到国王所在的位置分为三种情况：

- 在角上
- 在边上
- 在中间

因此我们分别考虑这三种情况所需要的骑士个数。

**在角上**

如图，可以看到国王有三个位置可以走，两个骑士就可以封住。

![](https://cdn.luogu.com.cn/upload/image_hosting/sf41iwm6.png)

**在边上**

如图，国王有五个位置可以走，要用三个骑士。

![](https://cdn.luogu.com.cn/upload/image_hosting/o10plvy3.png)

**在中间**

如图，八个位置共需四个骑士，其中国王无法吃掉蓝色和绿色的骑士，因为不论国王往左还是往右移动橙色骑士都会直接吃掉国王。

![](https://cdn.luogu.com.cn/upload/image_hosting/jsed098u.png)

把上面的规律总结一下， $3$ 个位置 -> $2$ 个骑士； $5$ 个位置 -> $3$ 个骑士； $8$ 个位置 -> $4$ 个骑士。其实答案也就是 $\lceil \frac{x}{2} \rceil$  。 （ $x$ 表示国王身边的位置数量）

代码实现直接分类讨论会比找规律好写一点，所以这里写的是分类讨论qwq

$code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,m,n,x,y,ans;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d",&m,&n,&x,&y);
		if((x==1&&y==1)||(x==m&&y==n)||(x==1&&y==n)||(x==m&&y==1)) cout<<"2"<<endl;//在角上
		else if(x==1||x==m||y==1||y==n) cout<<"3"<<endl;//在边上
		else cout<<"4"<<endl;//如果都不在就是在中间
	}
	return 0;
}
```
看题解不点赞就过分了啊qaq

---

## 作者：george_jiang (赞：5)

本题没有python题解，所以蒟蒻来水一发

解法中，如果有下图的情况，便可以只放两个马
![](https://cdn.luogu.com.cn/upload/image_hosting/fn1x0hu6.png)

如果有下图的情况，就需要放三个马
![](https://cdn.luogu.com.cn/upload/image_hosting/3mgvw6tj.png)![](https://cdn.luogu.com.cn/upload/image_hosting/851ju3ud.png)

如果有下图的情况，就需要放四个马
![](https://cdn.luogu.com.cn/upload/image_hosting/q8ive9wb.png)![](https://cdn.luogu.com.cn/upload/image_hosting/lpj4m1vo.png)
奉上代码
```python
t=int(input())
while(t>0):
	m,n,x,y=input().split()
	if int(x)==1 and int(y)==1 or int(x)==int(m) and int(y)==int(n) or int(x)==1 and int(y)==int(n) or int(x)==int(m) and int(y)==1:
	    print(2)#在角上
	elif int(x)==1 or int(x)==int(m) or int(y)==1 or int(y)==int(n):
	    print(3)#在边上
	else:
	    print(4)
	t=t-1#在中间
```
参考了[@慕蓉樱雪](https://www.luogu.com.cn/user/234074)的解法

---

## 作者：HKHbest (赞：3)

[P7354 「PMOI-1」立方骑士](https://www.luogu.com.cn/problem/P7354)

提供一种思路很暴力完全没有思维难度的方法。

由于王只可以走到相邻的八个格子里，而每个格子又只有8个格子的马可以看住它，顾可以考虑搜索。
![](https://cdn.luogu.com.cn/upload/image_hosting/6itq014g.png)
每一层dfs，枚举能看住这个位置的马在8个位置中的哪一个，时间复杂度为 $O(k^8)$ ，k为王可以到达的不越界的位置数，极限情况为8，t组数据会超时。但是这种情况下答案一定为4。
![](https://cdn.luogu.com.cn/upload/image_hosting/8tfne2bv.png))

所以可以针对极限情况特判。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={-1,-2,-2,-1,1,2,2,1},dy[]={2,1,-1,-2,-2,-1,1,2};
const int dxx[]={-1,-1,-1,0,1,1,1,0},dyy[]={1,0,-1,-1,-1,0,1,1};
int n,m,x,y,ans,top;
inline bool fw(int i,int j)//判断是否在棋盘内
{
	if(i>=1&&j>=1&&i<=n&&j<=m)
		return true;
	return false;
}
struct had
{
	int x,y;
}zhan[10];
void dfs(int K,int v)
{
	if(K==8)
	{
		ans=min(ans,v);
		return;
	}
	if(fw(x+dxx[K],y+dyy[K]))
	{
		int x0=x+dxx[K],y0=y+dyy[K],x2,y2;
		for(int i=0;i<8;i++)
		{
			x2=x0+dx[i];y2=y0+dy[i];
			if(fw(x2,y2))
			{
				for(int j=1;j<=top;j++)
				{
					if(zhan[j].x==x2&&zhan[j].y==y2)
					{
						dfs(K+1,v);
						break;
					}
				}
				zhan[++top].x=x2;
				zhan[top].y=y2;
				dfs(K+1,v+1);
				zhan[top].x=0;
				zhan[top--].y=0;
				continue;
			}
		}
	}
	else
		dfs(K+1,v);
}
inline int read()
{
	int s=0,w=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int main()
{
	int T=read();
	while(T--)
	{
		ans=0x7fffffff;
		n=read();
		m=read();
		x=read();
		y=read();
		if(x-1>=1&&x+1<=n&&y-1>=1&&y+1<=m)
		{
			ans=4;
		}
		else
			dfs(0,0);
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：_caiji_ (赞：2)

首先，不难想到，一个骑士能控制 $2$ 个格子。我们只需要计算出国王周围有多少个格子需要控制。把这个数量记为 $k$，最后答案即为 $\lceil k\div2\rceil$。

代码：
```cpp
#include <cstdio>
using namespace std;
const int dx[9]={0,-1,-1,-1,0,0,1,1,1},
          dy[9]={0,-1,0,1,-1,1,-1,0,1};//八个方向打表
int T,n,m,x,y,k;
int ceil_(int a,int b){
    if(a%b==0) return a/b;
    else return a/b+1;
}//自己定义一个向上取整的函数
int main(){
    for(scanf("%d",&T);T--;k=0){//for循环可以这样用
        scanf("%d%d%d%d",&n,&m,&x,&y);
        for(int i=1;i<=8;i++){
            int tmpx=x+dx[i],tmpy=y+dy[i];
            if(1<=tmpx&&tmpx<=n&&1<=tmpy&&tmpy<=m) k++;//统计国王周围有多少个不越界的格子
        }
        printf("%d\n",ceil_(k,2));//答案为ceil(k/2)，这里手写
    }
    return 0;
}
```

---

## 作者：Lithium_Chestnut (赞：2)

### 「PMOI-1」立方骑士 官方题解

### 前言

蛮简单的，其实就是找规律 + $20\%$ 的打表，标程 $O(t)$ 完成。

其实原来棋盘就是 $8 \times 8$，为防止交表，所以扩大了。

**注：在本篇题解中，棋盘大小默认为 $8 \times 8$。**

**注意，本篇题解中，$stp$ 表示需要围堵的格数。**


### 题意简述

说白了，就是给你国王的位置，求最少放几个骑士能把国王围堵住。

### 思路

找规律。

要把棋盘分成三部分：角、边、中间，具体如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/le37qv2d.png)

相同颜色的答案一定一样，那现在就开始推，找规律。

**角**

![](https://cdn.luogu.com.cn/upload/image_hosting/c5d055nl.png)

如上图，国王在角上，仅用两个骑士就可以围堵住国王。发现规律：$\left\lceil stp\div 2 \right \rceil$，在这里是 $\left\lceil 3 \div 2\right\rceil = 2$。

**边**

![](https://cdn.luogu.com.cn/upload/image_hosting/rp8gpx5j.png)

如上图，国王在边上，需要用三个骑士围堵住国王。证实规律：$\left \lceil stp \div 2 \right \rceil$，在这里是 $\left\lceil 5 \div 2\right\rceil = 3$。

**中间**

![](https://cdn.luogu.com.cn/upload/image_hosting/y3ornizt.png)

如上图，国王在中间，需要用四个骑士围堵住国王。

**在这里有人可能会问了，这样放国王不是可以吃掉蓝色的骑士吗？其实国王并不能吃掉它，因为绿色的骑士正在保护着蓝色的骑士，所以一定会围堵住。**

再次证实规律：$\left \lceil stp \div 2 \right \rceil$，在这里是 $\left\lceil 8 \div 2\right\rceil = 4$。

最后，找到了规律：$\left \lceil stp \div 2 \right \rceil$。

### 正解

所以只要读入并判断国王的位置就可以了，判断后套上规律，得到答案，注意每次循环清零！

### 标程

代码里有注释，大家可以借助阅读。

**代码里的 $\text{stp}$ 首先是为了新手更好理解思路，其次也是作者码风；但在代码和算法上其实并没有什么用处，仅凭个人喜好，~~不喜勿喷~~！**

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,x,y,stp;//stp是需要围堵的格数 
int main()
{
	cin>>T;
	for(int i=1;i<=T;i++)
	{
		stp=0;
		cin>>n>>m>>x>>y;
		if((x==1 and y==1) or (x==1 and y==m) or (x==n and y==1) or (x==n and y==m))//角
		{
			stp+=3;//奇数 
			cout<<stp/2+1<<endl;//手动向上取整 
		}
		else if((x==1 and y!=1 and y!=m) or (x==n and y!=1 and y!=m) or (y==1 and x!=1 and x!=n) or (y==m and x!=1 and x!=n))//边
		{
			stp+=5;//奇数
			cout<<stp/2+1<<endl;//手动向上取整
		}
		else//中间
		{
			stp+=8;//偶数
			cout<<stp/2<<endl;//不需要向上取整
		}
	}
	return 0;
}
```

---

## 作者：HYdroKomide (赞：0)

好久没~~水~~写题解了，现在看到这道题便来写一篇，个人感觉明显没有橙题水平。
# **正文：**
## 思路
明显可以看出是分类讨论题。我们可以枚举国王可以走的格数来确定需要的骑士数，而可以走的格数只有以下三种情况：

1. 如果国王在角落中瑟瑟发抖，即其横坐标与纵坐标分别为$1$或 $n$，$1$或 $m$，则其能走的格数只有三个，只需两个骑士便能将死。
2. 如果国王在一条边上，即其横坐标为$1$或 $n$，或纵坐标为$1$或 $m$，则其能走的格数有五个，需要三个骑士将死。
3. 如果国王大摇大摆走在中间，能走的格数有八个，就需要四个骑士将死。

我们只需要判断国王位于什么位置便能得知需要几个骑士。

## 程序如下（应该是本题最短的代码了）：
```cpp
#include<cstdio>
int q;
int main(){
    scanf("%d",&q);
    while(q--){
        int n,m,x,y,ans;
        scanf("%d%d%d%d",&n,&m,&x,&y);
        ans=(x==1&&y==1)||(x==n&&y==1)||(x==1&&y==m)||(x==n&&y==m)?2:(x==1||x==n||y==1||y==m?3:4);
        printf("%d\n",ans);
    }
    return 0;
}
```
# **THE END**

---

## 作者：syf2008 (赞：0)

这题很简单

判三种

1.在4个角上
![](https://cdn.luogu.com.cn/upload/image_hosting/t2y3wwi9.png)




2.在任意一条边（不包括点）
![](https://cdn.luogu.com.cn/upload/image_hosting/9qg1aw8z.png)

3.除边以外
![](https://cdn.luogu.com.cn/upload/image_hosting/azvtytoe.png)

上代码
```
#include <bits/stdc++.h>
using namespace std;
int t,n,m,x,y;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>x>>y;
		if(x==n&&y==m||(x==n&&y==1)||(x==1&&y==1)||(x==1&&y==m))
			cout<<2<<endl;
	else if(x==n||x==1||y==m||y==1)
		cout<<3<<endl;
	else cout<<4<<endl;
	}
}
```

---

## 作者：BotDand (赞：0)

# $\text{Problems}$
lhm 现在建立了一个大小为 $n \times m$ 的国际象棋棋盘，你作为白方要与黑方作战。棋盘上黑方只有一个国王，**国王位置不会移动**，而 lhm 有无穷无尽的骑士。现在你需要解出，最少派出几个骑士才能将死黑方国王，定义将死的标准为**黑方国王在不被吃掉的情况下不能移动为止**。

更形式化地讲：一个 $n\times m$ 的棋盘上有一个国王，你需要摆放尽可能少的骑士在棋盘上，使得对于每一个国王能走**正好一步**达到的且不在棋盘外的位置，都存在至少一个骑士能走**正好一步**达到。

棋子的移动方法：

国王每一步能向上、下、左、右、左上、右上、左下、右下八个方向移动一格。

骑士与国际象棋规则相同，每次可以走日字（即 $2\times3$ 长方形的对角线，详见样例）。**注意没有蹩马腿规则，也就是只要不走出棋盘且按照日字格行走，其他没有限制。**

lhm 太菜了，只好请聪明的你来帮他完成这个任务。
# $\text{Answer}$
分类讨论。

因为国王的走向限制，可以分为在角落、在边缘、在中央三个情况。

Ps:以下图片黄色为国王，红色为骑士。

* 国王在角落

  以(1,1)为例，如下图：
  
  ![QQ截图20210216205507.png](https://i.loli.net/2021/02/16/ThnXp9aPkLxsBti.png)
  
  两名骑士即可。
  
* 国王在边缘

  以(1,3)为例，如下图：
  
  ![QQ截图20210216205647.png](https://i.loli.net/2021/02/16/5cEQdWnXrK3RPsm.png)
  
  三名骑士即可。
  
* 国王在中央

  以(4,5)为例，如下图：
  
  ![QQ截图20210216205729.png](https://i.loli.net/2021/02/16/RMrDF16JcpWUYul.png)
  
  四名骑士即可。

然后...就没有然后了。

哦对说一句，放置方案不唯一。
# $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,x,y;
inline long long read()
{
    long long s=0;
    int w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
void work()
{
    n=read();m=read();x=read();y=read();
    if((x==1&&y==1)||(x==1&&y==m)||(x==n&&y==1)||(x==n&&y==m)) {puts("2");return;}
    if(x==1||y==1||x==n||y==m) {puts("3");return;}
    puts("4");
}
int main()
{
    cin>>t;
    while(t--) work();
    return 0;
}
```


---

## 作者：添哥 (赞：0)

我们知道，国王的位置有**三种情况**：角上、边上、既不是角上也不是边上。

人脑模拟一下即可，角上要 $2$ 个骑士就能将死，边上 $3$ 个骑士能将死，既不是角上也不是边上则需要 $4$ 个骑士才能将死。

所以我们发现了什么？

将死需要的骑士数 $= 4-$国王和边的相邻数

### 所以代码就粗来啦：
```cpp
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,m,x,y,ans=4;
		cin>>n>>m>>x>>y;
		if(x==1||x==n)
		{
			ans--;
		}
		if(y==1||y==m)
		{
			ans--;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：hensier (赞：0)

题解中已经归纳了大部分常规做法，这里就使用一个比较暴力的方法。

本题中，我们的目的就是控制对方王周围的 $8$ 个格子（当然不包括棋盘外面的）。那么我们依次枚举这 $8$ 个格子，并找到能够控制这些格子的所有合法位置。

我们借助样例中的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/c5d055nl.png?x-oss-process=image/resize,m_lfit,w_261)

然后分析这 $3$ 个相邻的格子：

- 对于国王右侧的格子 $(1,2)$，有 $(2,4),(3,1),(3,3)$ 可以进行攻击。
- 对于国王下方的格子 $(2,1)$，有 $(1,3),(3,3),(4,2)$ 可以进行攻击。
- 对于国王右下方的格子 $(2,2)$，有 $(1,4),(3,4),(4,1),(4,3)$ 可以进行攻击。

根据贪心的原则，发现 $(3,3)$ 出现了 $2$ 次，次数最多。因此可放置一个骑士在 $(3,3)$，而剩下的一个格子可以任选一个上述提到的骑士来进行控制。所以答案为 $2$。

我们可以存储所有骑士可以摆放的格子，保证其至少可以控制国王的一条出路，并将其排序。乍一看来，排序的方式可以按照出现次数从大到小。然而，如果出现次数最多的控制着已经被攻击的格子，那么实际上是无意义的。因此排序的策略是需要调整的。

我们的骑士每可以控制一个格子，我们就将这个格子进行标记。我们可按照**没有标记的个数从大到小**进行排序。这样，就可以保证解法最优了。

首次排序之后，我们取出最优的元素，并将其所包含的格子进行标记，然后再次排序，直到所有格子都被标记。

这种做法看起来没法通过，但实际上由于同一个骑士格子可以控制 $2$ 条国王的出路，因此可以证明，最终答案不会超过 $4$（题解区已有说明）。所以这份代码是不会被卡掉的，而且如果要求输出方案，也是能够应对的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,x,y,cnt,ans;
const int kx[]={-1,-1,-1,0,0,1,1,1},ky[]={-1,0,1,-1,1,-1,0,1};
const int dx[]={-2,-2,-1,-1,1,1,2,2},dy[]={-1,1,-2,2,-2,2,-1,1};
map<pair<int,int>,int>M;
bitset<8>vis;
vector<int>ids[10001];
bool cmp(const vector<int>&a,const vector<int>&b) // 按照没有标记个数从大到小排序
{
    int cn1=0,cn2=0;
    for(int i:a)cn1+=vis[i]^1;
    for(int i:b)cn2+=vis[i]^1;
    return cn1>cn2;
}
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
int main()
{
    t=read();
    while(t--)
    {
        n=read(),m=read(),x=read(),y=read();
        M.clear();
        cnt=ans=0;
        vis.reset();
        for(int i=0;i<8;++i)
        {
            int nx=x+kx[i],ny=y+ky[i];
            if(nx<1||ny<1||nx>n||ny>m)
            {
                vis[i]=true; // 在格子之外就直接进行标记
                continue;
            }
            for(int j=0;j<8;++j)
            {
                int X=nx+dx[j],Y=ny+dy[j],res;
                if(X<1||Y<1||X>n||Y>m||(X==x&&Y==y))continue; // 不能直接放在国王所处位置
                res=M[make_pair(X,Y)]; // 先取出对应格子所在 vector 中的下标
                if(!res) // 没有就新加一个
                {
                    M[make_pair(X,Y)]=++cnt;
                    ids[cnt]=vector<int>();
                    ids[cnt].push_back(i); // 加入 i 表示可控制国王从第 i 个方向离开
                }
                else ids[res].push_back(i); // 已经有这个格子的话就再加入 i，表示该格子还可以控制国王从第 i 个方向离开
            }
        }
        while(vis.count()<8) // 8 个格子没有控制完全就继续排序，并添加骑士
        {
            sort(ids+ans+1,ids+cnt+1,cmp);
            ++ans;
            for(int i:ids[ans])vis[i]=true; // 将可以控制的方向进行标记
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---


# [COCI 2016/2017 #4] Kartomat

## 题目描述

在火车站使用自动售票机时，可以通过其屏幕上的键盘搜寻目的地城市。键盘可抽象为一个 $4 \times 8$ 的字符矩阵：

![](https://cdn.luogu.com.cn/upload/image_hosting/ey39vw2o.png)

目前，屏幕上显示着 $N$ 个字符串，表示城市的名称。为了搜寻目的地城市，你依次点击了若干个字母，作为初始字符串。

输入初始字符串之后，屏幕上只会留下以该字符串开头的城市（即留下的城市有一个前缀为初始字符串）。同时，如果通过初始字符串和一个字母不能搜寻到任何一个城市，那么一个 $\texttt *$ 字符则会代替屏幕上的这个字母。

求在输入初始字符串之后，键盘的最终情况。

## 说明/提示

**【样例 1 解释】**

在输入初始字符串 $\texttt{ZA}$ 之后，键盘上剩下的字母只有 $\texttt{B,D,G}$。

|初始字符串|剩余字母|新字符串|可搜寻城市|
| :----------: | :----------: | :----------: | :----------: |
|$\texttt{ZA}$|$\texttt B$|$\texttt{ZAB}$|$\texttt{ZABOK}$|
|$\texttt{ZA}$|$\texttt D$|$\texttt{ZAD}$|$\texttt{ZADAR}$|
|$\texttt{ZA}$|$\texttt G$|$\texttt{ZAG}$|$\texttt{ZAGREB}$|

而初始字符串与其它字母所构成的新字符串不能搜寻到任何一个其它城市，因此它们将会从屏幕上消失，变为 $\texttt *$ 字符。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le N \le 50$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #4](https://hsin.hr/coci/archive/2016_2017/contest4_tasks.pdf) _T2 Kartomat_。**

**本题分值按 COCI 原题设置，满分 $80$。**

## 样例 #1

### 输入

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA```

### 输出

```
****B*D*
*G******
********
********```

## 样例 #2

### 输入

```
4
SPLIT
VINKOVCI
NOVSKA
RIJEKA
VINKO```

### 输出

```
********
********
********
V*******```

## 样例 #3

### 输入

```
4
AAAABCD
AAAABCA
AAAACDE
AAAAAAA
AAAA```

### 输出

```
***ABC**
********
********
********```

# 题解

## 作者：ZBAA_MKC (赞：4)

[博客食用效果更佳](https://www.luogu.com.cn/blog/228770/solution-p7550)

本题难点在于读题，我也是读了好几遍才读懂的.

大致题意：对于每一个字符串 $S_i$, 寻找一个以字符串 $c$ 为前缀的字符串，记录删去删除前缀 $c$ 的字符串 $S_i$ 的第一位的字母。

但在代码实现时，我们不用这样做。记字符串 $c$ 的长度为 $len$,我们只需要记录 $S_i[len]$ 处的字母即可。

输出时，如果某一个字母被记录过，那就输出这个字母，否则输出 `*` 。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

string s[55];
bool f[26];
int main()
{
    int n; 
	cin >> n; 
	for (int i = 1; i <= n; i++)
	{
		cin >> s[i];
	}
	string c;
	cin >> c;
	int len = c.size();
	bool flg;
  	//以上为读入及预处理
	for (int i = 1; i <= n; i++)
	{
		flg = true;
		for (int j = 0; j < len; j++)
		{
			if (c[j] != s[i][j]) //如果当前字符串的前缀不是c
			{
				flg = false; 
				break; //退出循环，找下一个字符串
			}
		}
		if (flg) //如果当前字符串的前缀是c
		{
			f[s[i][len] - 'A'] = true; //记录下一个字母
		}
	}
  //输出
	cout << "***";
	for (int i = 0; i <= 4; i++)
	{
		if (f[i])
		{
			cout << char(i + 'A');
		}
		else
		{
			cout << "*";
		}
	}
	cout << endl;
	for (int i = 5; i <= 12; i++)
	{
		if (f[i])
		{
			cout << char(i + 'A');
		}
		else
		{
			cout << "*";
		}
	}
	cout << endl;
	for (int i = 13; i <= 20; i++)
	{
		if (f[i])
		{
			cout << char(i + 'A');
		}
		else
		{
			cout << "*";
		}
	}
	cout << endl;
	for (int i = 21; i <= 25; i++)
	{
		if (f[i])
		{
			cout << char(i + 'A');
		}
		else
		{
			cout << "*";
		}
	}
	cout << "***";
	return 0;
}

```


---

## 作者：WhitD (赞：1)

## 题目分析
（~~说实话题干确实很难懂，我读了五分钟后没有结果一看样例解释就明白了~~）。

给定几个字符串和一个初始字符串，问有哪些字母可以被添加到初始字符串后依然是任意一个给定字符串的前缀（也就是从给定字符串的第一个字符开始，两个字符串都是一模一样的）。

这样说确实很抽象，但是这种题确实是难以让人理解，我们不妨就去想平常网上冲浪的场景，比如我要找“洛谷永垂不朽”，是不是先要搜索“洛谷”才能出现结果，而不是“谷 垂”，并且为了接下来能出现我想要的结果，应该输入“永”，来让搜索框变成“洛谷永”才能出现结果，而不能输入“洛谷垂”，对吧。

------------
## 解题思路
为了确保我们能查到“城市”，我们需要满足以下几点要求：

1. 初始字符串必须是当前城市的前缀（样例 1 的 SI 开头的城市和给定城市 ZA 很明显就不能成立）。
1. 添加某个字符后的初始字符串必须和给定城市的相同位置的字符一样（还是样例 1，对于 ZAB 这个城市，我只能添加 B 而不能是别的）。

------------
### 于是
我们开一个输出表来记录哪个字符可以添加，然后我以枚举每一个城市，将城市的每一个字符与相同位置的初始字符比较，只有都一样才可以，这样为了确保满足条件一。然后就直接把当前城市的下标为给定字符串长度的（假设给定字符串长度为 3，我们需要添加第 4 位的字符，第 4 位字符就是城市的下标为 3 的那个字符对吧）（这点需要各位自己试验体会）那个字符添加到最后的输出表中。

至于输出，因为开头和结尾都有三个字符的空（结尾不管），我选择处理开头的三个，那么假设查到 A 这个字符可以加入，就把 A 代表的数字 1 加上 3 变成 4，这样 A 代表 4，就可以直接加到表里了。

update：当然像我这样处理有不少细节需要注意，可能不是最好的办法。

------------
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string city[55],s;//s存初始字符串，city代表城市 
int n,key[10][10];//key就是上文提到的输出表 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>city[i];
	cin>>s;
	int len=s.size();//为了存储和判断方便记录初始字符长度 
	for(int i=1;i<=n;i++)
	{
		bool flag=true;//flag代表是否满足条件一 
		for(int j=0;j<len;j++)
			if(city[i][j]!=s[j])
				flag=false;
		if(flag)
		{
			int num=city[i][len]-'A'+4;//上文提到的+3（实际上是+1+3） 
			if(num%8==0)//以下部分各位只要自己举个例子就可以理解了，算是个细节 
				key[num/8][8]=num;
			else
				key[num/8+1][num%8]=num;
		}
	}
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=8;j++)
		{
			if(!key[i][j])
				cout<<"*";
			else
				cout<<char(key[i][j]+'A'-4);//输出，因为上面+4，所以这里-4 
		}
		cout<<endl;
	}
	return 0;
}
```
### PS:
最后很感谢您能看完，本人是第一次写题解，而且代码比较繁琐，如果有不足或是我的文章内容有问题的，亦或是解说的不恰当，烦请您谅解并且在评论区或是私信我指出，鄙人DDDD感激不尽，谢谢各位！

---

## 作者：Eason_AC (赞：1)

## Content
火车站里头有一个售票机，其键盘可以看作是一个 $4\times 8$ 的矩阵，其中第一行的前面三个键和最后一行的最后三个键都是 `*`，剩余的键按照从上到下，从左到右的顺序依次按照 A~Z 的顺序排列。售票机可以买去往 $n$ 个城市的票。

现在你向售票机里面输入了一个长度为 $k$ 的字符串，售票机会将以这个字符串为前缀且长度 $\geqslant k+1$ 的所有城市的名字中的第 $k+1$ 个字母显示在键盘中这个字母原来所在的位置上，其余的键则用 `*` 代替，求最终键盘上的情况（按照前文所述的 $4\times 8$ 矩阵的格式输出）。

**数据范围：$1\leqslant n\leqslant 50$。**
## Solution
先给大家推荐一个和这题完全一样的题目：[P4470](https://www.luogu.com.cn/problem/P4470)，按照年份来看的话应该是 BJWC 蒯了 COCI 的。

然后话回正题。我们先比对一下看这个字符串是否包含这个前缀且长度 $\geqslant k+1$，这题目中完全可以暴力一个一个字符比对，然后将所有满足要求的字符串的第 $k+1$ 个字母保存，最后直接输出显示了所有保存的字母的键盘即可。
## Code
这份代码原封不动地蒯过去可以直接过 P4470。

```cpp
int n, vis[57], ans[27];
string s[57];

int main() {
	n = Rint;
	F(i, 1, n) {cin >> s[i]; vis[i] = 1;}
	cin >> s[n + 1]; int len = s[n + 1].size();
	F(i, 1, n) F(j, 0, len - 1)
		if(s[n + 1][j] != s[i][j]) {vis[i] = 0; break;}
	F(i, 1, n) if(vis[i] && len != s[i].size() && !ans[s[i][len] - 'A']) ans[s[i][len] - 'A'] = 1;
	printf("***");
	F(i, 0, 25) {
		putchar(ans[i] ? i + 'A' : '*');
		if(i == 4 || i == 12 || i == 20) puts("");
	}
	return printf("***"), 0;
}
```

---

## 作者：Jairon314 (赞：1)



将题意简化一下就是:

> 给你 $n$ 个字符串，和一个键盘。告诉你一串字母 $Z$ ，长度为 $len$ ，将这 $n$ 个字符串中以 $Z$ 为前缀的字符串的第 $len+1$ 位所存储的字母记录，然后输出键盘，输出键盘的时候被记录过的字母输出，没被记录过的输出 ``*``


$ \text{Solution} $

--------

上午正睿模拟赛签到题，没啥好说的，按照题意模拟就OK了

具体看代码 :

```cpp
// #include <map>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;

// #define int long long

#define maxn 1000010
#define rep(i,f,t) for(int i(f);i<=(t);++i)
#define pre(i,t,f) for(int i(t);i>=(f);--i)

inline void FILE_();

int n,m,k,t,p;
int Array[maxn];
bool vis[maxn];
char ch1[53][300];
char key[300];

char keyboard[4][8]={
    '*','*','*','A','B','C','D','E',
    'F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U',
    'V','W','X','Y','Z','*','*','*'
};

/*键盘*/

/*****************************************/

int /*signed*/ main(){
    // FILE_();
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        std::cin>>ch1[i];
    }
    std::cin>>key;
    int len=strlen(key);
    for(int i=1;i<=n;i++){
        bool flag=true;
        for(int j=0;j<len;j++){
            if(ch1[i][j]!=key[j]){
                flag=false;
                j=len+1;
            }
        }
        if(flag==true){
            vis[ch1[i][len]-'A'+1]=true;
            // 标记用到的字母
        }
    }
    for(int i=0;i<4;i++){
        for(int j=0;j<8;j++){
            // std::cout<<keyboard[i][j]<<" ";
            if(vis[keyboard[i][j]-'A'+1]==true){
                std::cout<<keyboard[i][j];
                vis[keyboard[i][j]-'A'+1]=false;
            } else{std::cout<<"*";}
        }
        puts("");
    }
    // 输出键盘
    return 0;
}

/*****************************************/

inline void FILE_(){
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
}

/*
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA
*/
```


---

## 作者：Ian_Shi (赞：1)

# 题意及分析：
对于每一个字符串 $s$ ;

寻找一个以字符串 $x$ 为前缀的字符串。

记录删去删除前缀 $x$ 的字符串，$s$ 的第一位的字母。

如果一个字母被记录过，输出该字母。否则，输出 *。

# 天降代码：

```cpp
#include<bits.stdc++.h>
using namespace std;
int n;
string a[55],x;
bool flag[40];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>x;
	int len=s.length();
	for(int i=1;i<=n;++i){
		if(x==a[i].substr(0,len)){
			flag[a[i][len]-'A'+4]=1;
		}
	}
	for(int i=1;i<=32;++i){		//输出（共4行，每行8个）
		if(flag[i]==0){		//不可行输出“*”
			cout<<'*';
		}
		else{			//可行输出字母
			cout<<char(i-4+'A');	//用ASCII码逆推
		}
		if(i%8==0)			//到8个换行
			cout<<endl;
	}
	return 0;
}
```

---


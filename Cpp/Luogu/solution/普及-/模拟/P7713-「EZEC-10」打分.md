# 「EZEC-10」打分

## 题目背景

**为防止评测机被卡，本题时限为 100 ms。**

## 题目描述

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$[1,2,3]\to [3,2,3]$。

**【样例 2 解释】**

一种可行的方案为：$[1,2,2,3]\to [2,3,3,3]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$m=0$。
- Subtask 2（10 points）：$n=3$。
- Subtask 3（15 points）：$n,m\le 10^3$。
- Subtask 4（70 points）：无特殊限制。

对于 $100\%$ 的数据，$3\le n\le 10^5$，$0\le m,a_i\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 2 3```

### 输出

```
6```

# 题解

## 作者：zplqwq (赞：46)

赛场做法。

先看部分分，$m=0$ 直接模拟，记得开 `long long` 。

$n=3$ 的部分分没写，但可以考虑暴力枚举。

$n,m \le 10^3$ 同理。

最后我们来看正解。

考虑贪心 & 猜结论。

- 首先升序排一遍总是没什么错的。

- 不需要看最小的 $a_1$ 了，因为加的话就是浪费。

- 再看 $a_2-a_{n-1}$ ，在当前的 $a_n$ 是最大的数的时候，在 $a_2-a_{n-1}$ 里面加肯定是有贡献的，那么就一直加，加到 $a_2-a_{n-1}$ 都 $=$ $a_n$ 了为止。

- 出现 $3$ 的情况后，发现 $a_n$ 加上 $1$ 之后，我们可以在 $a_2-a_{n-1}$ 上都加上 $1$，这样就使贡献最大了，然后不断循环 $4$ 操作，直到加到用完次数为止。

即可。



---

## 作者：HC20050615 (赞：27)

首先，直接去掉最小值，因为最小值会被删去，所以不考虑。令剩下的所有数的和为 $sum$ ，最大值为 $maxs$ 。

然后我们将所有数提高至 $maxs$ ，如果无法全部提高至 $maxs$ ，就直接输出 $sum+m-maxs$ 。

反之，我们均匀的提高每个数，找到最高可以提高到的值，输出 $sum+m-maxs'$ 即可。

---

## 作者：Maxmilite (赞：19)

本题解貌似和其他题解思路不同。

我们不妨来考虑一下这 $m$ 分的分配问题。

由于最后肯定要去掉最低分，所以往最低分上加分对答案没有贡献。

所以我们直接一开始就把最低分刨了，考虑剩下的 $n - 1$ 个分。

由于最后要去掉最高分算平均分，所以考虑一下去掉最高分对 $m$ 分的贡献有什么影响。

如果这 $m$ 分有一部分加到了最高分上，那么最后 $m$ 分对平均分的贡献肯定要变小。

所以我们考虑 **优先让 $m$ 分加到不是最高分的分数上，如果把这些不是最高分的分数都加到最高分，再考虑将剩下的分数平均分配**，因为都加到最高分以后肯定会让 $m$ 分的贡献减小。

一个思路是，先把除了最高最低分的剩下 $n - 2$ 个原始分加起来，然后考虑这个总原始分加上 $m$ 和最高分 $\times n - 2$ 的关系。

这样省了一步浮点数计算，可以提高精度。

```cpp
for (int i(2); i <= n - 1; ++i)
        cur += a[i];
    if (cur + m < (n - 2) * a[n])
    	...
```

之后进行分类讨论，如果 $m$ 分不能做到“把这些不是最高分的分数都加到最高分”，那么就直接往前面加就完了，不需要考虑去掉最高分对 $m$ 对答案贡献的影响。

```cpp
 printf("%llu\n", (cur + m));
```

如果 $m$ 分可以做到“把这些不是最高分的分数都加到最高分”，就考虑“将剩下的分数平均分配”。

```cpp
printf("%llu\n", (cur + m + a[n])  * (n - 2) / (n - 1));
```

注意开一下 `unsigned long long`。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int unsigned long long

int a[100005];

signed main()
{
    int n, m;
    scanf("%llu%llu", &n, &m);
    for (int i(1); i <= n; ++i)
        scanf("%llu", a + i);
    sort(a + 1, a + n + 1);
    long long cur = 0;
    for (int i(2); i <= n - 1; ++i)
        cur += a[i];
    if (cur + m < (n - 2) * a[n])
        printf("%llu\n", (cur + m));
    else
        printf("%llu\n", (cur + m + a[n])  * (n - 2) / (n - 1));
    return 0;
}
```

---

## 作者：BotDand (赞：17)

# $\text{Problems}$

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

# $\text{Answer}$

先将 $a$ 数组排序。

不难发现对最小值进行操作对不能使最终得分最高，那么不对最小值进行操作。

接着分两种情况，设 $\sum_{i=2}^{n-1} a_{n}-a_{i}=S$，$\sum_{i=2}^{n-1} a_{i}=sum$

1. $m\le S$，则不能将 $a_{2}$ 至 $a_{n-1}$ 全部补为 $a_{n}$，输出 $sum+m$。

2. $m>S$，则先将 $a_{2}$ 至 $a_{n-1}$ 全部补为 $a_{n}$，再 $m$ 剩余的值平均分给 $a_{2}$ 至 $a_{n}$ 即可。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int a[100002];
int s1,s2;
int ans;
int x,y;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void print(int x)
{
    write(x);
    putchar('\n');
}
signed main()
{
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    n=read();m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    sort(a+1,a+n+1);
    for(int i=2;i<n;++i) s1+=a[n]-a[i];
    for(int i=2;i<n;++i) s2+=a[i];
    if(s1>=m) return print(m+s2),0;
    ans=s1+s2;
    m-=s1;
    x=m/(n-1);y=m%(n-1);
    ans+=x*(n-2);
    if(y>0) ans+=(y-1);//处理余数
    print(ans);
    return 0;
}
```


---

## 作者：Shunpower (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P7713)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/LEMON-ni/solution-p7713)

## 思路

很简单的贪心，我们可以把打分的情况分为三种讨论。

显然，如果要使得答案尽量大，就尽量把除最小得分以外的分数都加成最大的分数。我们可以假设要把除最小值、最大值以外的分数都变成最大分需要加 $sum$ 分，这样就可以举出三种情况：

1.$sum=m$，刚好可以把除了最大值与最小值以外的分数都变成最大的分数，此时若最大分数为 $maxn$，答案则是 $maxn(n-2)$。

2.$sum>m$，可以保证有至少一种加分办法不改变最大值与最小值。若除最大值最小值以外分数的和为 $cnt$，答案则是 $cnt+m$。

3.$sum<m$，可以先把除了最小值最大值以外的分数都先变成最大值，此时 $m$ 还剩下 $m-sum$ 分可以加。可以把除最小值以外的分数再加上 $\frac{m-sum}{n-1}$ 分，如果还有余数 $t$，就先把新的序列排序，然后把区间 $[2,1+t]$ （也可以写作 $[2,2+t)$）中的每个 $a_i$ 都增加 $1$。

## 代码

### 2.1：处理前的准备

```cpp
cin>>n>>m;
for(int i=1;i<=n;i++){
	cin>>a[i];
}
sort(a+1,a+n+1);//排序后，a[1]是最小分数，a[n]是最大分数
for(int i=2;i<=n-1;i++){
	sum+=(a[n]-a[i]);//求出要把所有除了最大和最小分数的分数变成最大分数需要加多少分，即要加多少次
	cnt+=a[i];//求出除最大分数和最小分数的总和
}
```

我使用了较慢的排序函数来排除最小分数和最大分数，当然可以使用更快的 $O(n)$ 的循环找最大和最小分数。

### 2.2：第一种情况的处理

```
if(sum==m){
	cout<<a[n]*(n-2)<<endl;
	return 0;
}
```
当 $sum=m$ 时，答案就是最大的分数与 $(n-2)$ 的积。

### 2.3：第二种情况的处理

```
else if(sum>m){
	cout<<cnt+m<<endl;
	return 0;
}
```
当 $sum>m$ 时，保证存在至少一种办法可以使得最大分数与最小分数不改变，所以这里可以直接输出 $(cnt+m)$。

### 2.4：第三种情况的处理

```
else{
	for(int i=2;i<=n-1;i++){
		a[i]=a[n];//先把所有除了最小最大分数以外的分数都变成最大分数
	}
	m-=sum;//算出m还剩下多少可以用
	for(int i=2;i<=n;i++){
		a[i]+=m/(n-1);//先把m平摊分给除了最小分数以外的分数
	}
	for(int i=2;i<=1+m%(n-1);i++){
		a[i]++;//如果还有剩的，就把区间[2,1+m%(n-1)]中的a[i]都加一分。
	}
	sort(a+1,a+n+1);//再次排序
	for(int i=2;i<=n-1;i++){
		ans+=a[i];//再次求和
	}
	cout<<ans<<endl;
	return 0;//好习惯
}
```
当 $sum<m$ 时，先把除了最小最大分数以外的分数都变成最大分数，然后把剩余的 $m$ 先平摊，如果还有剩的，就依次加一，直到最后剩余的这部分也用完。

## AC Code

[AC记录](https://www.luogu.com.cn/record/52839977)

---

## 作者：Eason_AC (赞：7)

## Content
某个人去参加比赛，$n$ 个评委分别给他打分 $a_1,a_2,\dots,a_n$。这个人可以最多执行 $m$ 次操作，每次操作将一个评委的分数加 $1$。定义他的最终分数为去掉一个最高分和一个最低分后的剩余得分的总和。求可能最高的最终分数。

**数据范围：$3\leqslant n\leqslant 10^5$，$0\leqslant m,a_i\leqslant 10^9$。**
## Solution
本题解我们来分 Subtask 来讲解。
### Subtask 1 (5 pts)：$m=0$
这一个部分分其实是很好拿的。我们只需要将所有评委的分数排个序，然后统计一下第 $2\sim n-1$ 个人的分数和即可。
### Subtask 2 (10 pts)：$n=3$
这个 Subtask 对于启发正解很有作用。

我们不妨先花费若干次操作，把第 $2$ 高的分数和最高的分数齐平。当然在这里如果就把操作数给用完了，那么就直接可以统计结果了。

如果第 $2$ 高的分数和最高的分数齐平了的时候，操作数还没有用完，我们就把剩余的操作数平均分成两份（如果多出了一份先丢在一边）。然后我们把这两份分别分给第 $2$ 高的分数和最高的分数。多出的一份无论分给谁都不会影响最终的结果，因此就可以直接输出第 $2$ 高的分数了。
### Subtask 3 (15 pts)：$n,m\leqslant 10^3$
这个 Subtask 你随便怎么暴力模拟应该都可以过，因此不做赘述。
### Subtask 4 (70 pts)：正解
我们回到 Subtask 2，受到其中均分的启发，我们不妨先让第 $2\sim n-1$ 高的分数和最高的分数齐平。当然在这里如果就把操作数给用完了，那么就直接可以统计结果了。

如果全部齐平了还没用完操作，我们就把剩余的操作数平均分成 $n-1$ 份（多出的分不出来的操作数先丢在一边，留做备用）。然后先把这 $n-1$ 份平均分给第 $1\sim n-1$ 高的分数，然后再去看是否多出的操作数。如果有多出的操作数，我们将一个操作数分给最高的分数，再将剩余的操作数随便分给第 $2\sim n-1$ 的分数中的任意几个（每个人分 $1$ 个操作数）就可以了。
## Code
```cpp
ll a[100007];

int main() {
	int n = Rint; ll m = Rll;
	ll ans = 0;
	F(int, i, 1, n) a[i] = Rint;
	sort(a + 1, a + n + 1);
	if(m) {
		F(int, i, 2, n - 1) {
			int add = min(a[n] - a[i], m);
			a[i] += add, m -= add;
		}
		int sum = m / (n - 1) * (n - 1), eve = sum / (n - 1);
		F(int, i, 2, n) a[i] += eve;
		m -= sum;
		if(m) {
			a[n]++, m--;
			F(int, i, 2, n - 1)
				a[i] = a[i] + min(1ll, m), m = max(m - 1, 0ll);
		}
	}
	F(int, i, 2, n - 1) ans += a[i];
	return write(ans), 0;
}
```

---

## 作者：Zxsoul (赞：6)

**思路**

根据题目，要想价值最大，那必然让 $m$ 尽可能的去贡献到中间部分，每次区间 $+1$ ，$m$ 所做的贡献是 $(n-2)$

现在考虑 $m$ 的大小，分两种情况：

1. 当 $\frac{m}{(n-2)}+\frac{sum}{(n-2)}\le a_{\max}$，注：$sum$ 表示 $(n-2)$ 的和，答案直接就是 $sum+m$ 

2. 当 $\frac{m}{(n-2)}+\frac{sum}{(n-2)}> a_{\max}$，就分成两段，在没超出最大值时中间加，在超出时连最大值一起加，直到不能同时加为止

**后言**
> 这题目论做法，如不是想到出题人的意图，最后的答案计算存在误差，上面的除法操作必须都换成乘法操作，否则是错误答案，代码中做除法的都必须改成乘法

```c
/*
	题目答案完全就是按照自己标程代码给出，也不说清楚
	先乘后除 和先除后乘 答案还不一样
	能除的地方都必须化简成乘法
	繁琐，也不说明白 
*/
#include <bitset>
#include <set>
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 1e7+10;
const int B = 1e6+10;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
int a[B];
int n,m;
int sum;
main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+1+n);
	for (int i=2;i<=n-1;i++) sum+=a[i];
	if (a[n]*(n-2)-sum>m) printf("%lld",(sum+m));
	else 
	{
		int now=m-a[n]*(n-2)+sum;
		printf("%lld",(a[n]*(n-2)+now*(n-2)/(n-1)));
	}
}
/*
4 5
1 2 2 3
*/
```

---

## 作者：YYen (赞：6)

### 题意
奥运会一共有 $ n $ 个裁判，裁判的原始打分分别为 $ a_{1} $ ， $ a_{2} $ ， …  ， $ a_{n} $ 。 现在有 $ m $ 次操作机会，每次操作可以使得任意一个裁判的打分加 $ 1 $ 。请问在进行 $ m $ 次操作之后，去掉一个最高分，去掉一个最低分，剩下 $ n - 2 $ 个裁判的总分数最高是多少。

### 思路：贪心
先把 $ n $ 个裁判的原始打分从小到大排序。考虑到目标是让中间 $ n - 2 $ 个裁判的总分数尽可能高，因此我们的策略应该是**在加分的时候，应该是尽可能把分数加给中间 $ n - 2 $ 个裁判，但 _同时要保证不改变最高分和最低分的相对位置_ 。**

为了方便理解，举一个具体例子的不同操作思路（假设已经对 $ n $ 个裁判的原始打分进行排序）：

$ n =  4 $ ， 分数为 $ 1 $ $ 2 $ $ 2 $ $ 4 $ ， $ m = 4 $

①、 假设 $ 4 $ 次操作全部给打 $ 1 $ 分的裁判，分数变为 $ 5 $ $ 2 $ $ 2 $ $ 4 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 6 $。

②、 假设 $ 4 $ 次操作全部给打 $ 4 $ 分的裁判，分数变为 $ 1 $ $ 2 $ $ 2 $ $ 8 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 4 $。

③、 假设 $ 4 $ 次操作全部给中间两位裁判，分数变为 $ 1 $ $ 4 $ $ 4 $ $ 4 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 8 $。**（最优）**

以上只是定性感受一下贪心的思路。可以发现给最低分裁判加分是没有意义的，所以我们的分数要尽量给到中间的裁判，同时保证最高分裁判依旧是最高分即可。接下来捋一下完整算法：

$ Step1 $ 读入全部原始打分，排序；

$ Step2 $ 查看 $ a_{2} $ ， …  ， $ a_{n - 1} $ 裁判分数与 $ a_{n} $ 裁判的分数是否相等，如果不等，可以通过操作调整为相等（此时的调整是不会影响最高分和最低分的相对位置的）；

$ Step3 $ 如果上一步结束之后，依旧有操作次数剩余，可以按照 $ a_{n} $ ， $ a_{n - 1} $ ， …  ， $ a_{2} $ 逆序逐个裁判分数加 $ 1 $ ，直到操作次数为 $ 0 $ （因为是逆序逐个加，所以此时的调整同样不影响最高分和最低分的相对位置，同时保证了尽可能多的加分落在了中间 $ n - 2 $ 个裁判身上）；

$Step4 $ 最后就是累加 $ a_{2} $ ， …  ， $ a_{n - 1} $ 个裁判的最终分数，就是答案了。

最终时间复杂度是排序产生的 $ O(nlogn) $ 。

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

long long a[100005]; 

int main()
{
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1);
    long long diff = 0; // 记录a[2]~a[n-1]分别与a[n]的差值之和
    for (int i = 2; i <= n - 1; i++)
        diff += a[n] - a[i];
    if (m <= diff) // 如果m<=diff，可以全部加到a[2]~a[n-1]
    {
        long long ans = 0;
        for (int i = 2; i <= n - 1; i++) ans += a[i];
        cout << ans + m << endl;
    }
    else // 如果m>diff，先把a[2]~a[n-1]调整到与a[n]相同，再来处理剩余的操作次数
    {
        m -= diff;
        long long ans = a[n] * (n - 2);
        if (m / (n - 1)) // 计算剩余次数m够让a[2]~a[n]全部加1多少次
        {
            ans += m / (n - 1) * (n - 2);
            m -= m / (n - 1) * (n - 1);
        }
        if (m >= 2) ans += m - 1;
        cout << ans << endl;
    }
    return 0;
}
```


---

## 作者：StayAlone (赞：5)

这题评红稍微低了一些吧。。。

### 题意

给定 $n$ 个得分，每一次可以让任意一个得分加一，最多可以加 $m$ 次，求操作后去掉最大值与最小值后的序列的和。  

### 思路

一个小贪心。首先可以很好明确的一点是，最低分是不需要去操作的，也没有必要让它变高，所以在计算过程中可以直接忽略。接下来的策略是，先尽量让每一个得分都和最高分一样高，然后让每一个分值都一起加一，直到 $m$ 不够为止。再将 $m$ 剩下的随意给某一些分值加一。这里比较概括，下面会解释。

将数组排序后，

现称 $sum = \sum\limits_{i = 2}^{n - 1}a_i$，则让除了最低分以外的所有分数变为与最高分一样需要 $k = a_n \times (n - 2) - sum$ 次。  

此时分类讨论，有：

1. $m < k$，说明一定有方案使得序列中加了 $m$ 次，且每个数都不超过原来的最大值。输出 $sum + m$。

1. $m = k$，说明刚好可以让最小值以外的所有数与最大值相等。输出 $a_n \times (n - 2)$。

1. $m > k$，这种情况较复杂。
	- 先将最小值以外的每一个数都变得与最大值一样，这里需要 $k$ 次，而剩下的 $m - k$ 次操作分两个部分：
    	- 先将序列最小值以外的所有数加上 $(m - k) \ / \ (n - 1)$，会剩下 $(m - k) \bmod (n - 1)$ 次操作。这会给答案贡献 $(m - k) \ / \ (n - 1) \times (n - 2)$。
        - 将剩下的操作次数任意加到序列中的数中，但每一个数至多加一。这会给答案贡献 $(m - k) \mod (n - 1) - 1$，最后要减一是因为会有一个增加的与最大值共同去掉。
   故输出 $a_n \times (n - 2) + (m - k)\ /\ (n - 1) \times (n - 2) + (m - k) \bmod (n - 1) - [((m - k)\bmod (n - 1) > 0)]$。$[a]$ 表示 $a$ 成立时为 $1$，不成立时为 $0$。  
   
[AC code记录](https://www.luogu.com.cn/record/52878756)
   
```cpp
#include <bits/stdc++.h>
#define rep1(i, j, n) for (int i = j; i <= int(n); ++i)
#define rep2(i, j, n) for (int i = j; i >= int(n); --i)
#define il inline
#define ld long double
#define ll long long
#define ull unsigned long long
#define pyq priority_queue
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define end return 0
using namespace std;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int MAXN = 1e5 + 10; const ll inf = ~0ULL >> 1;
template <typename T>
il void read(T &x)
{
	x = 0; T f = 1; char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) {x = (x << 1) + (x << 3) + (ch & 15); ch = getchar();} x *= f;
}

il void write(int x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
int n, m, a[MAXN];

int main()
{
	read(n); read(m);
	rep1(i, 1, n) read(a[i]);
	sort(a + 1, a + 1 + n);
	ll sum1 = 0;
	rep1(i, 2, n - 1) sum1 += a[i];
	ll k = 1ll * a[n] * (n - 2) - sum1;
	if (k == m) printf("%lld", 1ll * a[n] * (n - 2));
	else if (k < m)
		printf("%lld", 1ll * a[n] * (n - 2) + (m - k) / (n - 1) * (n - 2) + (m - k) % (n - 1) - ((m - k) % (n - 1) > 0));
	else printf("%lld", sum1 + m);
	end;
}
```

---

## 作者：Ecrade_ (赞：4)

定义 $m$ 次操作后的序列为 $a'$。

按照题意，最终得分可表示为 $\dfrac{m+\sum\limits^n_{i=1}a_i-\max\limits^{n}_{i=1}{a'_i}-\min\limits^{n}_{i=1}{a'_i}}{n-2}$ 。

观察到只有 $a'$ 中的最大值和最小值会变化，故使两数越小越好。

注意到最小值可以不用管，考虑最大值即可。

我们可以尽可能将除了最小值的所有数都变成当前序列的最大值，若有多余的操作次数就将最大值增加 $1$，重复即可。

易证此为最优策略。

实现时可以直接使用 $O(n)$ 的数学方法，或着使用 $O(n\log m)$ 的二分求出最大值能达到的最小值。

数学方法：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,rem,sum,max_,min_ = 1e18,a[100009];
inline ll read(){
	ll s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
int main(){
	n = read(),m = read(),sum = 0;
	for (ll i = 1;i <= n;i += 1) a[i] = read(),max_ = max(max_,a[i]),min_ = min(min_,a[i]),sum += a[i];
    rem = (n - 1) * max_ - sum + min_,sum -= max_ + min_ - m;
	if (m > rem) sum -= (m - rem - 1) / (n - 1) + 1;
	cout<<sum;
	return 0;
}
```
二分：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,l,r,del,ans,a[100009];
inline ll read(){
	ll s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
bool judge(ll x){
	ll res = 0;
	for (ll i = 2;i <= n;i += 1) res += a[n] + x - a[i];
	return res >= m;
}
int main(){
	n = read(),m = r = read();
	for (ll i = 1;i <= n;i += 1) a[i] = read(),ans += a[i];
	sort(a + 1,a + n + 1),ans -= a[1] + a[n];
	while (l <= r){
		ll mid = (l + r) >> 1;
		if (judge(mid)) del = mid,r = mid - 1;
		else l = mid + 1;
	}
	printf("%lld",ans + m - del);
	return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：3)

首先，所有分数的总和是一定的，就是想要最后的总分最大，就是要最高分和最低分的总和最小。

我们对所有的分数先进行排序。

最低分不要改变即可 （虽然样例说明#1 是提高了最低分，但是不提高最低分也可以达到所求的）。

于是，可以先把在非两端的分都提至最高分（如果可以），否则即可直接输出答案（因为最高分没有改变，理论上是最小的）。

然后把剩余的操作平均分给非最低的得分即可，要注意的是，我们要始终保持评分的单调。

然后计算非两端得分的总和即可。

## Code

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
int n,m;
ll a[MAXN];
void End(){
	ll ans=0;
	for(int i=2;i<n;i++)
		ans+=a[i];
	cout<<ans;
	return;
}//输出答案
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];//输入部分
	sort(a+1,a+n+1);//总分排序
	for(int i=2;i<n;i++)
		if(m>0){
			int d=a[n]-a[i];
			a[i]=min(a[n],a[i]+m);
			m=max(0,m-d);//非两端提至最高分 a[m]
		}
	if(m==0){//分完即结束
		End();
		return 0;
	}
	else{//剩下在平均分给非左端
		int d=m/(n-1);
		m%=(n-1);
		for(int i=2;i<n;i++){
			a[i]+=d;
			if(i>n-m)
				a[i]++;
		}
		End();
		return 0;
	}
}

```

---


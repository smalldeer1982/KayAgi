# [蓝桥杯 2015 省 B] 移动距离

## 题目描述

X 星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为 $1,2,3, \cdots $ 。

当排满一行时，从下一行相邻的楼往反方向排号。

比如：当小区排号宽度为 $6$ 时，开始情形如下：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....
```

我们的问题是：已知了两个楼号 $m$ 和 $n$，需要求出它们之间的最短移动距离。（不能斜线方向移动）

## 说明/提示

时限 1 秒, 256M。

蓝桥杯 2015 年省赛 B 组 H 题。

## 样例 #1

### 输入

```
6 8 2```

### 输出

```
4```

## 样例 #2

### 输入

```
4 7 20```

### 输出

```
5```

# 题解

## 作者：what_can_I_do (赞：22)

[传送门](https://www.luogu.com.cn/problem/P8623)

这题纯模拟。我们读入 $m$ 和 $n$ 之后，如果 $n$ 更大，可以把 $m$ 和 $n$ 的值互换。接着我们可以求出 $n$ 和 $m$ 对应的坐标。当我们求出 $n$ 的坐标 $kx$ 和 $ky$，$m$ 的坐标 $x$ 和 $y$ 之后，最短距离只需用 $|kx-x|+|ky-y|$ 就行了。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,m,n,kx,ky,x=0,y=1;
int main()
{
    scanf("%d%d%d",&w,&m,&n);
    if(n>m) swap(n,m);
    for(register int i=1;i<=m;i++)    //枚举从1到m所有数的坐标
    {
    	if(y%2==1)    //正方向
    	{
    		x++;
    		if(x>w) x=w,y++;
		}
		else    //反方向
		{
			x--;
			if(x<1) x=1,y++;
		}
		if(i==n) kx=x,ky=y;    //记录n的坐标
	}
	printf("%d",abs(kx-x)+abs(ky-y));
    return 0;
}
```

---

## 作者：CEFqwq (赞：15)

看到题解区里好多人都是 `STL` 解决的，其实这题我们可以自己写一个矩阵分析。

```plain
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 16 17 18
24 23 22 21 20 19
```

我们分析情况，发现奇数行和偶数行的情况分别相同。

为了方便，我们把 `1 2 3 4 5 6` 这一行称作第 $0$ 行，具体原因见代码。

我们可以看出，当行号为 $0,2,4,6 \cdots$ 的时候，列数（同样为了方便，从 $0$ 开始）就是楼号对宽度 $w$ 取余。

相对的，当行号为奇数时，所在列数就是宽度 $w$ 减去楼号对宽度 $w$ 取余的结果加 $1$。

这样写非常简洁：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int w,n,m,q1,q2,p1,p2;
	cin>>w>>n>>m;
	q1=(n-1)/w,q2=(m-1)/w;//计算所在的行，由于楼号从1开始，要减去1
        //这里需要注意，小于w的楼号除以w的结果从0开始，所以上文我们也这样
	if(q1%2==0)p1=n%w;
	else p1=w-n%w+1;
	if(q2%2==0)p2=m%w;
	else p2=w-m%w+1;//计算所在列
	cout<<abs(p1-p2)+abs(q1-q2);//输出答案，为了避免两个楼号大小变换，求绝对值
}
```

[AC记录](https://www.luogu.com.cn/record/108545204)

---

## 作者：安舒阳 (赞：4)

本题的重点在于算出两个建筑物的坐标，及需要算出两个建筑物分别的 $x$ 和 $y$ 坐标。

看下题里原来的编号系统：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....

```
在这里我一开始绕了半天发现这玩意并不好处理（在算横坐标的时候需要特判，代码太臃肿），如果我们把编号全部减一，就舒服很多了：

```
0  1  2  3  4  5
11 10 9  8  7  6
12 13 14 15 .....

```
这样一来，显然可以得出对于奇数行第 $k$ 个点的坐标是：

$$(k \bmod w,k/w)$$

而偶数行为（把奇数行的横坐标倒换）：

$$(w-1-(k \bmod w),k/w)$$

坐标算出来之后直接减然后求绝对值就好。

```cpp
#include<bits/stdc++.h>
using namespace std;
int jue(int a){//用来求绝对值
	if(a<0){
		return 0-a;
	}
	return a;
}
int main() {
	int w,m,n;
	scanf("%d%d%d",&w,&m,&n);
	m--;
	n--; 
	
	int x1=m%w,x2=n%w,y1=m/w,y2=n/w;
	if(y1%2==1){
		x1=w-1-x1;
	}
	if(y2%2==1){
		x2=w-1-x2;
	}
	cout<<jue(x1-x2)+jue(y1-y2);
    return 0;
}

```


---

## 作者：andyli (赞：2)

考虑根据两个楼号编号分别计算他们的坐标，再计算曼哈顿距离。  

我们从 $0$ 开始编号。由题每行 $w$ 个数，因此 $x$ 所在行号即为 $\left\lfloor \frac{x}{w}\right\rfloor$。对于偶数行，$x$ 所在列号为 $x \bmod w$，对于奇数行则为 $w - 1 - x \bmod w$。  

```python
w, m, n = map(int, input().split())
m -= 1
n -= 1
mx, my = divmod(m, w)
if mx & 1:
    my = w - my - 1
nx, ny = divmod(n, w)
if nx & 1:
    ny = w - ny - 1
print(abs(nx - mx) + abs(ny - my))
```

---

## 作者：_xuwh11_ (赞：2)

### 一道非常经典的数学题
只能往上下左右四个方向走，这样的距离就是两点之间的曼哈顿距离。

所以我们把楼房的坐标求出来，然后算一下距离。

楼房的排列方式是左右方向动，所以在求坐标是需要判断现在是奇数行还是偶数行。
```cpp
#include <bits/stdc++.h>
using namespace std;
int w, m, n;
pair<int, int> loc(int x)
{
    int l = (x + w - 1) / w, c = (x - 1) % w + 1;
    if (l % 2 == 1)
        return make_pair(c, l);
    else
        return make_pair(w - c + 1, l);
}
int main()
{
    cin >> w >> m >> n;
    pair<int, int> x = loc(m), y = loc(n);
    cout << abs(x.first - y.first) + abs(x.second - y.second);
    return 0;
}
```


---

## 作者：PineappleSummer (赞：1)

[$\color{orangered}\text{题目传送门}$](https://www.luogu.com.cn/problem/P8623)

本题有个非常直接的思路，就是直接处理出来所有楼房的位置。

用 $x_i$ 表示第 $i$ 栋楼的横坐标，$y_i$ 表示第 $i$ 栋楼的横坐标，$nowx$ 表示当前楼房的横坐标，$nowy$ 表示当前楼房的纵坐标。

从 $1$ 到 $\max(m,n)$ 循环，对于 $i$，如果 $i \bmod w$ 为 $1$，说明该换行了，让 $nowx$ 加 $1$。判断 $i/w$ 的奇偶性即可得到此排的数字为越来越大还是越来越小。如果 $(i/w) \bmod 2$ 为 $1$，此排的数字为越来越大，反之为越来越小。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>x,y;
int w,m,n;
int nowx=0,nowy=0;
int main()
{
//    freopen("input.in","r",stdin);
//    freopen("output.out","w",stdout);
	cin>>w>>m>>n;
	for(int i=1;i<=max(m,n);i++)
	{
		if(i%w==1)
		{
			nowx++;
			x[i]=nowx;
			if((i/w)%2) nowy=1;
			else nowy=w;
			y[i]=nowy;
		}
		else
		{
			if((i/w)%2) nowy++;
			else nowy--;
			x[i]=nowx;
			y[i]=nowy;
		}
	}
	cout<<abs(x[m]-x[n])+abs(y[m]-y[n]);
    return 0;
}
```

---

## 作者：hycqwq (赞：1)

## 思路

一道数学题。

题目说不能斜着移动，就是说只能往上下左右四个方向走，于是发现这样的距离就是两点之间的曼哈顿距离。

所以我们把楼房的坐标求出来，然后算一下距离即可。

楼房的排列方式是左右方向动，所以在求坐标是需要判断现在是奇数行还是偶数行。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cstring>
#include <cctype>
#include <cmath>
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <map>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int inf = 0x3f3f3f3f;
#define elif else if
#define il inline

int w, m, n;

pii loc(int x)
{
    int l = (x + w - 1) / w, c = (x - 1) % w + 1;
    if (l % 2 == 1)
        return make_pair(c, l);
    else
        return make_pair(w - c + 1, l);
}

int main()
{
    cin >> w >> m >> n;
    pii x = loc(m), y = loc(n);
    cout << abs(x.first - y.first) + abs(x.second - y.second) << endl;
    return 0;
}
```

---

## 作者：SunnyLi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/p8623)

## 思路

一道小学奥数题。

小学奥数管这个叫做数表。这道题是数表中比较简单的一种。很容易看得出来，这是一个周期为 $2w$ 的蛇形数表。

易得纵坐标为 $\frac{n}{2}$，但是当 $n$ 除以 $w$ 有余数时，需要加 $1$，因为这属于这个周期的后半部分，而后半部分要加一行。

横坐标只需要求 $n$ 除以 $2w$ 的余数，如果这个数大于 $w$，则它的横坐标应为 $w-(x-w)+1$。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll w,n,m;
ll xx1,xx2,yy1,yy2;

int main(){
    cin >> w >> n >> m;
    xx1 = n%(w*2);
    if(xx1>w)    xx1=w-(xx1-w)+1;
    yy1 = n/w;
    if(n%w>0)   yy1++;

    xx2 = m%(w*2);
    if(xx2>w)    xx2=w-(xx2-w)+1;
    yy2 = m/w;
    if(m%w>0)   yy2++;

    cout << abs(xx1-xx2)+abs(yy1-yy2);
    return 0;
}
```


---

## 作者：SilverLi (赞：0)

[移动距离 の 传送门](https://www.luogu.com.cn/problem/P8623)

### 思路

使楼号的编号从 $0$ 开始，$m$ 和 $n$ 都需要 $-1$。

列号即为 $n\bmod w$。

如果列号为偶数，则行号为 $\frac{n}{w}$。

如果列号为奇数，则行号为 $w-1-\frac{n}{w}$。

两点之间的曼哈顿距离为 $d=\left | x1-x2 \right | + \left | y1-y2 \right |$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int w,m,n;
int X1,X2,Y1,Y2;
int main() {
    cin>>w>>m>>n;
    --m,--n;
    X1=m/w,X2=n/w;
    Y1=m%w,Y2=n%w;
    if(X1%2==1)	Y1=w-1-Y1;
    if(X2%2==1)	Y2=w-1-Y2;
    cout<<abs(X1-X2)+abs(Y1-Y2);
    return 0;
}
```

---

## 作者：hjqhs (赞：0)

注：编号从 $0$ 开始。  
KeyPoint1：记宽为 $y$，那么 $x$ 就是在第
$\left\lfloor\frac{x}{y}\right\rfloor$行  
KeyPoint2：记 $l=x\bmod y$。  
若 $x$ 在偶数行，那么 $x$ 就是在第 $l$ 列。  
若 $x$ 在奇数行，那么 $x$ 就是在第 $y-l+1$ 列。  
KeyPoint3：不能向斜方向移动的最短距离就是曼哈顿距离。 
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,m,n;
int mx,my,nx,ny;
int getdis(int ax,int ay,int bx,int by){//求曼哈顿距离 
    return abs(ax-bx)+abs(ay-by);
}
int getx(int x){//求数x所在行 
    return x/w;
}
int gety(int x){//求数x所在列 
    int xx=getx(x);
    if(xx%2==0){
        return x%w;
        //如果x在偶数行，就是第x%w列 
    }
    else{
        return (w-x%w-1)%w;
        //如果x在奇数行，就是第(w-x%w-1)列 
    }
}
int main(){
    cin>>w>>m>>n;
    m--;n--;//编号从0开始 
    mx=getx(m);
    my=gety(m);
    nx=getx(n);
    ny=gety(n);
    cout<<getdis(mx,my,nx,ny);
    //美丽的模块化编程 
    return 0;
}
```

---

## 作者：haozinojc (赞：0)

这是一道简单的**模拟**题。

### 思路：

知道了两个楼号之后，我们就可以很简单的结合每行的楼数算出两个楼房的 $y$ 值：$m_y=m\times w$。

由于楼房是蛇形排序的，所以楼房的 $x$ 值要结合 $y$ 值来求。

通过简单的观察和总结，我们可以得出以下结论：

- 当楼房的 $y$ 值为奇数且 $m\bmod w$ 为零时，楼房在这一行的末端，即：$m_x=w$。

- 当楼房的 $y$ 值为奇数且 $m\bmod w$ 不为零时，楼房的 $x$ 值为：$m_x=m\bmod w$。

- 当楼房的 $y$ 值为偶数且 $m\bmod w$ 为零时，楼房在这一行的首段，即：$m_x=1$。

- 当楼房的 $y$ 值为偶数且 $m\bmod w$ 不为零时，楼房的 $x$ 值为：$m_x=w+1-m\bmod w$。


综上所述，我们就可以很简单的写出代码了。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int mx,nx,my,ny,w,m,n;
int main(){
	cin>>w>>m>>n;
	my=m/w;
	ny=n/w;
	if(my%2==1){
		if(m%w==0)mx=w;
		else mx=m%w;
	}
	else{
		if(m%w==0)mx=1;
		else mx=w+1-m%w;
	}
	
	if(ny%2==1){
		if(n%w==0)nx=w;
		else nx=n%w;
	}
	else{
		if(n%w==0)nx=1;
		else nx=w+1-n%w;
	}
	cout<<abs(mx-nx)+abs(my-ny);
	return 0;
}
```


---

## 作者：ダ月 (赞：0)

- 结论 $1$：

对于 $x$ 所在的位置，以 $w$ 为宽，在第 $\left\lfloor\frac{x}{w}\right\rfloor$ 行。（下标从 $0$ 开始。）

证明：一行有 $w$ 个，无论是否正序，手摸一下就能出答案。

- 结论 $2$：

记 $p=x\bmod w$。

若 $x$ 所在的行为偶数行，那么 $x$ 在第 $p$ 列。(若 $p=0$，则说明在第 $w$ 列。)

若 $x$ 所在的行为奇数行，那么 $x$ 在第 $w-p+1$ 列。（$p=w+1$，则说明在第 $1$ 列。）

证明：手摸一下。

- 结论 $3$：

它们之间的最短移动距离事实上就是欧几里得距离，即 $(x_1,y_1)$ 到 $(x_2,y_2)$ 的欧几里得距离为 $|x_1-x_2|+|y_1-y_2|$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
//===
//缺省源
//===
int a,b,c;
typedef pair<int,int> pi;
pi divide(int x){
	int L=x/a;
	return L&1?(x%a?(pi){L,x%a}:(pi){L,a}):(x%a?(pi){L,a-x%a+1}:(pi){L,1});
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>a>>b>>c;
	pair<int,int>r1,r2;
	r1=divide(b);
	r2=divide(c);
	printf("%d\n",abs(r1.first-r2.first)+abs(r1.second-r2.second));
	return 0;
}






```


---

## 作者：watcher_YBH (赞：0)

# 思路：
首先求出两个点的 $x,y$ 坐标，再求出曼哈顿距离。曼哈顿距离的公式为：$\left|x - x2\right| + \left|y - y2\right|$。

**注意高度的奇偶！！！**
# 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int MAX = 1e5+5;
int w,m,n;
int x,y;
int x2,y2;
int main(){
	cin>>w>>m>>n;
	y = m/w+(m%w>0);
	if(y%2) x = w-m%w+1;//为奇数时从左边算起
	else x = m%w;//为偶数时从右边算起
	y2 = n/w+(n%w>0);
	if(y2%2) x2 = w-n%w+1;
	else x2 = n%w;
	cout<<abs(x2-x) + abs(y2-y);//曼哈顿距离
	return 0;//完美结束~
}
```


---

## 作者：_AyachiNene (赞：0)

# 思路：
给定一个宽 $w$ 长无穷大的矩形，在给两个编号 $x$，$y$ 求这两个编号之间的曼哈顿距离。曼哈顿距离公式：$\left|{x1 - x2}\right| + \left|{y1 - y2}\right|$。

**注意：楼房的排列方式偶数行是反射排的，要分类讨论它所在的行数是奇数还是偶数。**

# coder:
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,m,n,x,x2,y,y2;
int main()
{
	cin>>w>>m>>n;        //输入 
	x=m/w+(m%w>=1);       //编号为m的楼房所在的行数 
	x2=n/w+(n%w>=1);      //编号为n的楼房所在的行数 
	y=x%2?m%w:w-m%w+1;	  //编号为m的楼房所在的列数，如果在奇数行编号是按顺序拍的，否则是按偶数排的 
	y2=x2%2?n%w:w-n%w+1;	//同上 
	cout<<abs(x-x2)+abs(y-y2);   //算两点之间的曼哈顿距离
	return 0; 
}
```


---

## 作者：qifan_maker (赞：0)

### 题目链接
[洛谷](https://www.luogu.com.cn/problem/P8623)
### 题目解法
很明显是[曼哈顿距离](https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB)，

但是题目只给了楼号，所以我们只需要求出楼号 $m$ 和 $n$ 对应的坐标，然后算一下距离就行。

一栋楼的 $y$ 坐标很容易确定，为 $m$ 除以 $w$；

$x$ 坐标需要确定他在奇数行还是偶数行：
1. 奇数行。分为两种情况。如果 $m\mod w = 0$，说明这栋楼在**行末**；否则，这栋楼的位置为 $m\mod v$。

2. 偶数行。分为两种情况。如果 $m\mod w = 0$，说明这栋楼在**行首**；否则，这栋楼的位置为 $w+1-(m\mod v)$。
### [AC](https://www.luogu.com.cn/record/108516999) Code
```cpp
/*
题目编号：
P8623 [蓝桥杯 2015 省 B] 移动距离
By：
qifan_maker
*/
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int x,y;
int w,m,n;
void coordinate(int m){
	y = m/w;
	if (y%2 == 1){
		if (m%w == 0){
			x = w;
		}
		else {
			x = m%w;
		}
	}
	else {
		if (m%w == 0){
			x = 1;
		}
		else {
			x = w+1-m%w;
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> w >> m >> n;
	coordinate(m);
	int x1 = x,y1 = y;
	coordinate(n);
	int x2 = x,y2 = y;
	cout << abs(x1-x2) + abs(y1-y2);
	return 0;
}
```

---

## 作者：gongziwen (赞：0)

首先看题。

重要信息有 $3$ 个：
1. 最短移动距离。
1. 不能斜线方向移动。
1. 当排满一行时，从下一行相邻的楼往反方向排号。

好了，有了这三个信息，那么算法就可以分为两步：
1. 找点 $m$ 与点 $n$ 在以点 $1$ 为原点在坐标系中的位置。
1. 计算曼哈顿距离即可。

看第一步，比较简单，手推样例得出：

点 $n$ 的行数是 $\lceil n \div w \rceil$,而列数是$\begin{cases} w-(n - 1) \bmod w 
,& \lceil n \div w \rceil\bmod 2=0
\\ (n - 1) \bmod w +1 ,
& \lceil n \div w \rceil\bmod 2=1 \end{cases}$。

第二步用曼哈顿距离公式 $dis=|x_1-x_2| +|y_1-y_2|$ 求出。

贴上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,m,n;
int main()
{
	scanf("%d%d%d",&w,&m,&n);
	int xm=ceil(m/(w*1.0));//求m点的行数，下同 
	int xn=ceil(n/(w*1.0));
	int ym=xm%2==0?w-(m-1)%w:(m-1)%w+1;//求m点的列数，下同 
	int yn=xn%2==0?w-(n-1)%w:(n-1)%w+1;
    printf("%d",abs(xm-xn)+abs(ym-yn));//曼哈顿距离公式 
    return 0;
}
```


---


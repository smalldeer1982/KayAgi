# [蓝桥杯 2018 省 B] 螺旋折线

## 题目描述

如图所示的螺旋折线经过平面上所有整点恰好一次。

![](https://cdn.luogu.com.cn/upload/image_hosting/yis43t6j.png)

对于整点 $(X, Y)$，我们定义它到原点的距离 $\text{dis}(X, Y)$ 是从原点到 $(X, Y)$ 的螺旋折线段的长度。  

例如 $\text{dis}(0, 1)=3$，$\text{dis}(-2, -1)=9$。 

给出整点坐标 $(X, Y)$，你能计算出 $\text{dis}(X, Y)$ 吗？


## 说明/提示

对于 $40\%$的数据，$-1000\le X,Y\le 1000$。

对于 $70\%$ 的数据，$-10^5\le X,Y \le 10^5$。

对于 $100\%$ 的数据，$-10^9\le X,Y \le 10^9$。


## 样例 #1

### 输入

```
0 1```

### 输出

```
3```

# 题解

## 作者：___w (赞：16)

### [P8668 [蓝桥杯 2018 省 B] 螺旋折线](https://www.luogu.com.cn/problem/P8668)

#### 题意简述
- 对于整点 $(x,y)$，定义它到原点的距离 $\text{dis}(x,y)$ 是从原点到 $(x,y)$ 的螺旋折线段的长度。
- 给出整点坐标 $(x,y)$，求 $\text{dis}(x,y)$。

#### 题目分析
做到这题看到这个大蚊香瞬间蚌埠住了，这题~~也就随随便便~~分类讨论罢了。

![图](https://cdn.luogu.com.cn/upload/image_hosting/rtqceh26.png)

如图所示，我们可以将这个“大蚊香”分为上下左右四个部分。定义 $n=\max(\left|x\right|,\left|y\right|)$。

我们发现，像类似 $\text{dis}(x,-x)$（其中 $x\geqslant0$）的值为左右部分的和和上下部分的和，为：

$d=(1+2+\cdots+2n)+(1+2+\cdots+2n)=2n(2n+1)$。

那么我们就可以分别讨论点 $(x,y)$ 分别位于哪个部分，再对 $d$ 增减。

当 $y\geqslant0$ 且 $\left|x\right|\le y$ 时（即上部分），$\text{dis}(x,y)=d-3n+x$。

当 $y<0$ 且 $y<x\le -y$ 时（即下部分），$\text{dis}(x,y)=d+n-x$。

当 $x\geqslant0$ 且 $\left|y\right|\le x$ 时（即右部分），$\text{dis}(x,y)=d-n-y$。

当 $x<0$ 且 $x<y\le -x$ 时（即左部分），$\text{dis}(x,y)=d-5n+y$。

这些结论可以自己在草稿纸上推一推，这里就不展开详细说明了。有了结论，代码也就简单了。

#### 代码
记得开 ```long long```。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x, y, n, d;
int main() {
	cin >> x >> y;
	n = max(abs(x), abs(y)), d = 2*n*(2*n+1);
	if (y >= 0 && abs(x) <= y) cout << d-3*n+x;//上部分 
	else if (y < 0 && y < x && x <= -y) cout << d+n-x;//下部分 
	else if (x >= 0 && abs(y) <= x) cout << d-n-y;//右部分 
	else if (x < 0 && x < y && y <= -x) cout << d-5*n+y;//左部分 
	return 0;
}
```

---

## 作者：yangmingshuo114514 (赞：10)

## 思路：
此题是一道数学题。下面提供两种方法。

### 法一：

枚举大法。循环次数在最坏情况下会达到惊人的 $ 10^{18} $。期望得分 72pts。这里不做过多阐述。

### 法二：

寻找周期，再分情况讨论。

我们可以用以原点为中心的正方形划分周期。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bdfsvij5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

则 $ \max( | x | , | y | ) $ 表示点 $ ( x , y ) $ 所处的周期。

前 $ \max( | x | , | y | ) - 1 $ 个周期的步数可以通过找规律获得。前三个周期朝一个方向走的步数如下所示：

第 $ 1 $ 个周期： 左 $ 1 $，上 $ 1 $，右 $ 2 $，下 $ 2 $，左 $ 2 $；

第 $ 2 $ 个周期： 左 $ 1 $，上 $ 3 $，右 $ 4 $，下 $ 4 $，左 $ 4 $；

第 $ 3 $ 个周期： 左 $ 1 $，上 $ 5 $，右 $ 6 $，下 $ 6 $，左 $ 6 $。

我们会惊奇地发现，第 $ i $ 个周期一定会是这样的：

第 $ i $ 个周期： 左 $ 1 $ ，上 $ 2\times i-1 $ ，右 $ 2\times i $ ，下 $ 2\times i $ ，左 $ 2\times i $。

第 $ i $ 个周期走的步数之和为：

$ 1 + 2\times i - 1 + 2\times i + 2\times i + 2\times i = 8\times i $

前 $ x $ 个周期走的步数之和为：

$ \sum_{ i = 1 }^x 8\times i = 4 \times (x+1) \times x $

走完前 $ x $ 个周期会走到点 $ ( -x , -x ) $ 。

此时我们只需要走完前 $ \max( | x | , | y | ) - 1 $ 个周期，从点 $ ( - ( \max( | x | , | y | ) - 1 ) ,- ( \max( | x | , | y | ) - 1 )) $ 出发，判断点 $ ( x , y ) $ 在第 $ \max( | x | , | y | ) $ 周期上的哪一条线段上就可以了。

记 $ a = \max( | x | , | y | ) $，有以下步骤：

1. 初始在点 $ ( -a + 1 , -a + 1 ) $ ，向左走到点 $ ( -a ,  -a + 1 ) $；

2. 判断点 $ ( x , y ) $ 是否在左边的线段上 $( x = -a $ 且 $ y \ne -a )$，如果是，结算距离，否则向上走到点 $ ( -a , a ) $；

3. 判断点 $ ( x , y ) $ 是否在上边的线段上 $(y = a)$，如果是，结算距离，否则向右走到点 $( a , a )$；

4. 判断点 $ ( x , y ) $ 是否在上边的线段上 $(x = a)$，如果是，结算距离，否则向下走到点 $ ( a , -a ) $；

5. 此时点 $ ( x , y ) $ 一定在下边的线段上 $(y = -a)$，此时直接结算距离即可。

我们以点 $ ( -1, -3 ) $ 为例，模拟一遍代码过程：

* 点 $ ( -1 , -3 ) $ 在第 $ \max( | -1 | , | -3 | ) = 3 $ 个周期上，先走完前 $ 3 - 1 = 2 $ 个周期，走到点 $ ( -2 , -2 ) $ 的位置上，步数为 $ 4 \times ( 2 + 1 ) \times 2 = 24 $；

* 向左走到点 $ ( -3 , -2 ) $，步数 $ + 1 $；

* 不在左边的线段上，向上走到点 $ ( -3 , 3 ) $，步数 $ + 5 $；

* 不在上边的线段上，向右走到点 $ ( 3 , 3 ) $，步数 $ + 6 $；

* 不在右边的线段上，向下走到点 $ ( 3 , -3 ) $，步数 $ + 6 $；

* 此时一定在下面的线段上了，向左走到点 $ ( -1 , -3 ) $，步数 $ + 4 $。

* 总步数为 $ 24 + 1 + 5 + 6 +6 + 4 = 46 $。

献上一张丑图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1ent9whs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

期望得分 100pts ，代码如下：

code:

```cpp

#include<cstdio>
#include<cmath>
long long x,y,a,b;
int main(){
	scanf("%lld%lld",&x,&y);
	a=(abs(x)>abs(y)?abs(x):abs(y))-1;
	b=4*(a+1)*a;
	++a;
	++b;
	if(x==-a&&y!=-a){
		printf("%lld",b+y+a-1);
		return 0;
	}
	b+=a*2-1;
	if(y==a){
		printf("%lld",b+x+a);
		return 0;
	}
	b+=a*2;
	if(x==a){
		printf("%lld",b+a-y);
		return 0;
	}
	b+=a*2;
	printf("%lld",b+a-x);
	return 0;
}
```

切记一定要开long long，否则只能拿48pts！

---

## 作者：wuhan1234 (赞：8)

## 1. 编程思路。

本题属于找规律的问题，关键是找出规律。

先观察题目描述中的图示，从原点出发，第 $1$ 步向左走 $1$ 个单位至 $(-1,0)$ 后转折，第 $2$ 步向上走 $1$ 个单位到 $(-1,-1)$ 后转折，第 $3$ 步向右走 $2$ 个单位至 $(1,1)$ 后转折，第 $4$ 步向下走 $2$ 个单位至 $(1,-1)$ 后转折，…，之后按上面的循环不断走下去。每走两步后，每步所走的单位数加 $1$。即每步所走的单位数序列为 $1,1,2,2,3,3,4,4,…$。

1）第 $1$ 象限整点的规律。

先考察第 $1$ 象限的转折点，该点横坐标和纵坐标值相等。

从原点出发走 $3$ 步，可到达转折点 $(1,1)$，$dist(1,1)=1+1+2=4$。

从原点出发走 $7$ 步，可到达转折点 $(2,2)$，$dist(2,2)=1+1+2+2+3+3+4=16$。

一般地，从原点出发走 $4\times a-1$ 步可以达到转折点 $(a,a)$，这 $4\times a-1$ 步中，前 $4\times a-2$ 步每两步是同一个单位，最后一步为 $2\times a$ 个单位。

$
dist(a,a)=1+1+2+2+…+(2\times a-1)+(2\times a-1)+2\times a=4\times a^2$。

对于第 $1$ 象限的其他非转折点的整点 $(a,b)$，这里 $a\ne b$。

若 $a<b$，则在直线 $y=b$ 上，点 $(a,b)$ 向右走 $b-a$ 个单位可以到达转折点 $(b,b)$。因此，

$dist(a,b)=dist(b,b)-(b-a)=4\times b^2+a-b$。

若 $a>b$，则在直线 $x=a$ 上，从转折点 $(a,a)$ 再向下走 $a-b$ 个单位就可以达到点 $(a,b)$。因此，

$dist(a,b)=dist(a,a)+(a-b)=4\times a^2+a-b$。

若设 $t=\max(a,b)$，则上面的规律可以统一表示为  $dist(a,b)=4\times t^2+a-b$。

2）第 $2$ 象限整点的规律。

从原点出发走 $2$ 步可以到达转折点 $(-1,1)$，$dist(-1,1)=1+1=2$。

从原点出发走 $6$ 步可以到达转折点 $(-2,2)$，$dist(-2,2)=1+1+2+2+3+3=12$。

一般地，从原点出发走 $4\times a-2$ 步可以达到转折点 $(-a,a)$，$dist(-a,a)=1+1+2+2+…+(2\times a-1)+(2\times a-1) =4\times a^2-2\times a$。
 
对于第 $2$ 象限的其他非转折点的整点 $(-a,b)$，这里 $a>0,b>0$ 且 $-a\ne b$。

若 $-a<b$，则在直线 $y=b$ 上，从转折点 $(-b,b)$ 向右走 $b-a$ 个单位可以到达 $(-a,b)$。因此，
$dist(-a,b)=dist(-b,b)+(b-a)=4\times b^2-2\times b+(-a)+b$。

若 $-a>b$，则在直线 $x=-a$ 上，从整点 $(-a,b)$ 再向上走 $a-b$ 个单位就可以达到转折点 $(-a,a)$。因此，$dist(-a,b)=dist(-a,a)-(a-b)=4\times a^2-2\times a+(-a)+b$。

若设 $t=\max(a,b)$，则第 $2$ 象限的规律可以统一表示为  $dist(-a,b)=4\times t^2t-2\times t+(-a)+b$。

3）第 $4$ 象限整点的规律。

同上理，若设 $t=\max(a,-b)$，则第 $4$ 象限整点 $(a,b)$ 的规律可以统一表示为 $dist(a,b)=4\times t^2+2\times t-a-b$。这里，$a>0,b<0$。

4）第 $3$ 象限整点的规律。

第 $3$ 象限整点的规律略微麻烦一些。
从原点出发走 $1$ 步可以到达转折点 $(-1,0)$，$dist(-1,0)=1$。

从原点出发走 $5$ 步可以到达转折点 $(-2,-1)$，$dist(-2,-1)=1+1+2+2+3=9$。

一般地，从原点出发走 $4\times a-3$ 步可以达到转折点 $(-a,-a+1)$，$dist(-a,-a+1)=1+1+2+2+…+(2\times a-2)+(2\times a-2)+(2\times a-1) =(2\times a-1)^2$。
 
对于第 $3$ 象限的其他非转折点的整点 $(a,b)$，这里 $a<0,b<0$ 且 $a+1\ne b$。

将第 $3$ 象限的转折点用一条直线连起来，则直线方程为  $y=x+1$。

若 $a+1<b$，则其在直线 $y=x+1$ 的上方，这样在直线 $x=a$ 上从转折点 $(a,a+1)$ 向上走 $-a-1+b$ 个单位可以到达 $(a,b)$。因此，
$dist(a,b)=dist(a,a+1)+(b-a-1)=\lbrack 2\times (-a)-1\rbrack ^2+b-a-1$。

若 $a+1>b$，则其在直线 $y=x+1$ 的下方，这样在直线 $y=b$ 上从整点 $(a,b)$ 再向左走 $a+1-b$ 个单位就可以达到转折点 $(b-1,b)$。因此，$dist(-a,b)=dist(b-1,b)-(a+1-b)=\lbrack 2\times (-b+1)-1\rbrack ^2+b-a-1$。

## 2. 源程序。

```c
#include <stdio.h>
int max(int a,int b)
{
    return a>b?a:b;
}
int main()
{
	long long x,y,t,ans=0;
	scanf("%lld%lld",&x,&y);
	if (x>=0&&y>=0)        // 第1象限
	{
		t=max(x,y);
		ans=4*t*t+x-y;
	}
	else if (x<0&&y>=0)   // 第2象限
	{
		t=max(-x,y);
		ans=2*t*(2*t-1)+x+y;
	}
	else if (x>=0&&y<0)  // 第4象限
	{
		t=max(x,-y);
		ans=2*t*(2*t+1)-x-y;
	}
	else                // 第3象限
	{
		if (x+1<y)
			t=-x-x-1;
		else
			t=-y-y+1;
		ans=t*t-x+y-1;
	}
	printf("%lld\n",ans);
	return 0;
}

```




---

## 作者：SunnyLi (赞：4)

## 思路

暴力做法会 TLE 的，这道题要找规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/zowmy65i.png)

我们可以把它分为四个象限，求出顶角的 $dis$ 值，然后再加减坐标距离值 $dis(X,Y)$ 与顶点坐标的 $dis$ 值。

### 1. 第一象限

第一象限中，我们设 $m=\rm{max}(|x|,|y|)$，此时 $dis(m,m)=(2m)^2$。

接着需要判断 $x<m$ 或 $y<m$。

（1）当 $y=m$ 时，坐标 $(x,y)$ 在 $(m,m)$ 左侧，此时需要减去 $m-x$，即 $dis(x,y)=dis(m,m)-(m-x)$。

（2）当 $x=m$ 时，坐标 $(x,y)$ 在 $(m,m)$ 下边，此时需要加上 $m-y$，即 $dis(x,y)=dis(m,m)+(m-y)$。

### 2. 第二象限与第四象限

比较方法同上，或查看 AC 代码。

### 3. 第三象限

第三象限的坐标的 $dis$ 值的规律本蒟蒻实在没想出来，所以用了第二和第四象限的坐标 $dis$ 值计算，此时需要判断 $|y|>|x|$ 是否成立。

（1）当 $|y|>|x|$ 时，$dis(m,m)=2m(2m+1)$，此时 $dis(x,y)=dis(x,y)+(m+|x|)$。

（2）当 $|y|<|x|$ 时，$dis(m,m)=2m(2m-1)$，此时 $dis(x,y)=dis(x,y)-(m+|y|)$。

## AC 代码


```cpp
\\（可能不是最优解）
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int main(){
    ll x,y,m,cnt,dis;
    cin >> x >> y;
    m = max(abs(x),abs(y));
    if(x>0 and y>=0){
    	dis = (m*2)*(m*2);
    	if(x<m)	dis -= (m-x);
    	else if(y<m)	dis += (m-y);
	}
	else if(x<=0 and y>0){
		dis = (m*2)*(m*2-1);
		if(abs(x)<m)	dis += (m-abs(x));
    	else if(y<m)	dis -= (m-y);
	}
	else if(x>=0 and y<0){
		dis = (m*2)*(m*2+1);
		if(x<m)	dis += (m-x);
    	else if(abs(y)<m)	dis -= (m-abs(y));
	}
	else if(x<0 and y<=0){
		if(abs(y)>=abs(x)){
			dis = (m*2)*(m*2+1);
			dis += (m+abs(x));
		}
		else{
			dis = (m*2)*(m*2-1);
			dis -= (m+abs(y));
		}
	}
	cout << dis;
    return 0;
}

```

[AC 记录](https://www.luogu.com.cn/record/107020513)

---

## 作者：szh_AK_all (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8668)

这道题可以用暴力枚举来做，但很容易超时，本人认为没必要用枚举法，因为只需要判断语句就够了。下面先看一幅图。

![图片](https://cdn.luogu.com.cn/upload/image_hosting/yis43t6j.png)

其实做这道题就跟找规律一样，我们把图片分为 $4$ 个部分，便产生出了两种做法。

一、根据 $4$ 个象限将图片分为 $4$ 部分，依次考虑 $4$ 个象限的情况；二、根据每条线的走向及位置，按照每个点所在的线划分，分为：横轴上方，横轴下方，纵轴右方，纵轴左方四种线段，再依次考虑。

下面讲述第二种做法。

首先，考虑横轴正上方的线段。我们先看 $(1,1)$ 这个点（根据左上角的位置找规律），需要 $4$ 步。再看 $(2,2)$ 这个点，需要 $16$ 步。到这里，我们似乎发现了什么，接着看 $(3,3)$，发现，每条处在横轴正上方的线段的最右边的点需要的步数，都可以表达为 $x\times 2\times x\times 2$ 步，那么处在它旁边的点就好办了。规律在代码中呈现。

其次，考虑其他三种线段，规律还是挺好找的。下面直接给出代码。

# Code
```c
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    long long x,y,k;
    long long o=0;
    cin>>x>>y;
    if(y>=(-x)&&y<=x)//纵轴右方
    {
        k=x*2*x*2+(x-y);
    }
    else if(y<=(-x)&&y>x)//纵轴左方
    {
        long long x2=x;
        x=-x;
        k=(x*2-1)*(x*2-1)+(y-x2-1);
    }
    else if(y>=0)//横轴上方
    {
        k=2*y*2*y-(y-x);
    }
    else if(y<0)//横轴下方
    { 
        long long io=-y*2;
        k=(io*(io+1))+(-y-x+1);
    }
    cout<<k;
}
```
另外，还有一个重要的点，就是判断点的位置。规律可以根据代码理解。


---

## 作者：Sun_wtup (赞：0)

# P8668 [蓝桥杯 2018 省 B] 螺旋折线 题解

[题目传送](https://www.luogu.com.cn/problem/solution/P8668)

观摩了各位 dalao 的题解，都是很好的解法，我就提供一个比较容易理解~~但很麻烦~~的方法。

## 题意

给出一个点的坐标，从原点开始画一个螺旋（题目中的图），然后按图中的规律一直走到给出的坐标，求走过的线段总长。

![](https://cdn.luogu.com.cn/upload/image_hosting/wv8t2xnl.png)

## 分析

既然要求总的线段长度，那我们就用最原始的方法求。考虑这个点在坐标轴上的四种情况，然后根据这个推广到四个象限。四种情况具体就是在 $x$ 正半轴，$x$ 负半轴，$y$ 正半轴，$y$ 负半轴。针对每一种情况，把当前情况下每个象限的线段和求出来，然后相加就得到当前情况的总的结果，按照此思路求出四种情况，在输入后判断是哪种情况，运算输出即可。

对于每个象限的线段和，我们用等差数列求和公式，即：$S_n=\dfrac{(a_1+a_n)\times n}{2}$。其中 $n$ 是项数。

在运算前，首先给 $x$ 和 $y$ 取绝对值。

例如在下图情况，即点在 $y$ 正半轴上的情况。

![题图](https://cdn.luogu.com.cn/upload/image_hosting/mqri2tng.png)

- 求第一象限线段长度总和，通过观察可以发现在此情况下 $（x = 0，y > 0）$ 共有 $y-1$ 圈，每 $2$ 个相邻的圈之间相差两个单位长度，我们就可以用等差数列。此时 $a_1 = 2,\ a_n =2 (y-1),\ n = y - 1$，代入公式：$\dfrac{(2 + 2(y - 1))(y - 1)}{2}$。

- 类似的，对于第二象限，我们可以得到 $a_1 = 2,\ a_n = 2 y,\ n = y$，代入即可：$\dfrac{(2 + 2y)y}{2}$。

- 对于第三象限线段长度总和，这里需要考虑上唯一一条在坐标轴上的线段，然后就同样是等差数列 $\dfrac{(1+2\times y-1)\times y}{2}$。

- 第四象限和第一象限一样，即 $\dfrac{(2+2\times(y-1))\times(y-1)}{2}$。

最终将四种相加即可得到在 $y$ 正半轴的情况，同理得到剩下三种，读者自推不难 ~~（逃）~~

四种情况整理化简得：

$x$ 正半轴：$4x^2 + x$。

$x$ 负半轴：$4x^2 - 3x$。

$y$ 正半轴：$4y^2 - y$。

$y$ 负半轴：$4y^2 + 3y$。

然后对于在每个象限中的点（在坐标轴上的不算任何一个象限），在上面求出在坐标轴上的情况下再加一部分即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/8nfg5wah.png)

对于这个例子，通过观察可以发现，可以把这个问题分为两部分：上文所说点在 $x$ 正半轴上的情况以及多余的部分。两部分相加即为答案。前者已经求出，处理后者即可。注意后者还需特殊处理拐弯部分。

在一、二、四象限中的点对于上面的式子要将 $x$ 或 $y$ 改成 $\max(x,y)$，因为只有最大的才能确定有几圈，即在坐标轴上时 $x$ 或 $y$ 的值。

类似地，在第三象限中的点应将 $y$ 改为 $\max(x - 1, y)$。

## 代码

``` cpp
#include<bitsdc++.h>
using namespace std;
#define int long long
signed main()
{
    ios::sync_with_stdio(false);
    int ans = 0;
    int x, y, a, b;
    cin >> a >> b; //取绝对值
    x = abs(a); //为了不影响后面取max
    y = abs(b);
    int tx = x, ty = y;
    if (a == 0 && b == 0) //在原点
    {
        cout << 0;
        return 0;
    }
    if (a == 0)
    {
        if (b > 0) //在 y 正半轴
            ans = 4 * y * y - y;
        else //在 y 负半轴
            ans = 4 * y * y + 3 * y;
    }
    if (b == 0)
    {
        if (a > 0) // 在 x 正半轴
            ans = 4 * x * x + x;
        else // 在 x 负半轴
            ans = 4 * x * x - 3 * x;
    }
    if (a > 0 && b > 0) //第一象限
    {
        y = max(x, y);
        ans = 4 * y * y - y + x;
        if (tx >= ty)
            ans += (tx - ty);
    }
    if (a < 0 && b > 0) //第二象限
    {
        x = max(x, y);
        ans = 4 * x * x - 3 * x + y;
        if (ty >= tx)
            ans += (ty - tx);
    }
    if (a < 0 && b < 0) //第三象限
    {
        y = max(x - 1, y);
        ans = 4 * y * y + 3 * y + x;
        if (tx - 1 >= ty)
            ans += (tx - 1 - ty);
    }
    if (a > 0 && b < 0) //第四象限
    {
        x = max(x, y);
        ans = 4 * x * x + x + y;
        if (ty >= tx)
            ans += (ty - tx);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：liuyi0905 (赞：0)

看到这道题，枚举肯定会超，所以让我们一起来找规律吧：

先要求出点 $(x,y)$ 在第几层：$\max(|x|,|y|)$。

再来看看每一层都有什么规律：
- 第一层：$1+1+2+2=6$。
- 第二层：$1+1+2+2+3+3+4+4=20$。
- 第三层：$1+1+2+2+3+3+4+4+5+5+6+6=42$。
- 第四层：$1+1+2+2+3+3+4+4+5+5+6+6+7+7+8+8=72$。
- 第 $i$ 层：$2\times(1+2\times a)\times a$：等差数列求法。

既然已经求出了这些，就得算出点 $(x,y)$ 比 $i-1$ 层多走几步。

下边奉上 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long x,y,a,b;
	cin>>x>>y;
	a=max(abs(x),abs(y))-1;
	b=(1+2*a)*2*a;
	if(x==-(a+1)&&y!=-a)cout<<b+3*a+1+y;//左边
	else if(y==a+1)cout<<b+5*a+3+x;//上面
	else if(x==a+1)cout<<b+3*(2*a+1)+1+a+1-y;//右边
	else cout<<b+a-x;//下面
	return 0;
}
```

---


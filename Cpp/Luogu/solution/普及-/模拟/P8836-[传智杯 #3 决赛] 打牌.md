# [传智杯 #3 决赛] 打牌

## 题目背景

disangan233 想和 disangan333 一起打牌，并邀请了一起路过的你。

## 题目描述

三名同学在学习编程的休息时间（编号 $1,2,3$）打扑克，每人一开始 $n$ 张牌，牌一共 $m$ 种，若干张相同的牌可以一起出。

一开始由第一个人出，打出自己的牌里最小的牌。接下来，以玩家 1,2,3,1,2,3... 的顺序轮流出牌，每人打出一组比上个人打出的牌大的，自己能打出的最小的牌，若没有则跳过。

牌的大小是这么决定的：一组张数多的牌比张数少的牌大，如果张数同样多，那么点数大的牌比较大。例如，$(1,1,1)>(3,3)>(2,2)>(4)>(1)$。

若一轮中，其余两个人都无法打出牌，则重新下次由打出最后一张牌的人开始打。谁最先打完所有的牌，谁就赢了。请问最后谁会胜利呢？输出胜者的编号。

对于所有数据，$n,m\leq 50$。

## 说明/提示

样例中的玩法：

```plain
第 1 回合：
【1】：1 3 3 1 3 3 1 2 3 3，打出 [1]
【2】：3 2 1 2 2 3 3 1 1 2，打出 [2]
【3】；2 2 1 2 3 1 2 3 3 1，打出 [3]
【1】：3 3 1 3 3 1 2 3 3，打出 [1,1]
【2】：3 1 2 2 3 3 1 1 2，打出 [2,2]
【3】；2 2 1 2 1 2 3 3 1，打出 [3,3]
【1】：3 3 3 3 2 3 3，打出 [3,3,3]
【2】：3 1 3 3 1 1 2，出不起
【3】；2 2 1 2 1 2 1，打出 [2,2,2,2]
【1】：3 2 3 3，出不起
【2】：3 1 3 3 1 1 2，出不起


第 2 回合：
【3】；1 1 1，打出 [1]
【1】：3 2 3 3，打出 [2]
【2】：1 3 3 1 1 2，打出 [3]
【3】；1 1，打出 [1,1] <- 获胜
```

## 样例 #1

### 输入

```
10 3
1 3 3 1 3 3 1 2 3 3 
3 2 1 2 2 3 3 1 1 2 
2 2 1 2 3 1 2 3 3 1 ```

### 输出

```
3```

# 题解

## 作者：stswkl (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8836
) [更好的观看](https://www.luogu.com.cn/blog/100years/solution-p8836#
)

## 题意:

模拟 $3$ 个人打牌的过程，每个回合第一个出牌的人出自己的牌中最小的一组牌，以后每个人每次出牌打出自己的牌里**最小的一组牌**，且该组牌要**大于场上的上一组牌**，一组牌有**相同点数**的若干张牌组成，该组牌的大小由该组牌的**点数**和**数量**决定，**数量相同点数决定**该组牌的大小，否则**数量决定**该组牌的大小，当一个人打出的一组牌**其他人都接不上时**，下一个回合。**先打完手中全部牌**的人胜利，输出那个人的编号。

## 思路:

将每个人的每种点数的牌的数量用数组 $a$ 计数存起来，用 $last$ 数组表示上一组牌的信息，其中 $last_1$ 表示上一组牌的点数，$last_2$ 表示上一组牌的数量，$last_3$ 表示上一组牌的出牌者，$sum$ 数组表示每个人手中牌的数量。然后按照提议进行模拟就行了。

## code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[5][55],x,last[5],sum[5],who=1,tmp;
signed main()
{
	cin>>n>>m;
	sum[1]=sum[2]=sum[3]=n;
	last[3]=1;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>x;
			a[i][x]++; //存起来
		}
	}
	for(int i=1;;i++)
	{
		tmp=0;who=(i-1)%3+1;
		if(last[3]==who)last[1]=0,last[2]=1; //新的回合
		for(int j=0;j<=sum[who];j++)
		{
			for(int k=1;k<=m;k++)
			{
				if(j==0&&k<=last[1])continue;
				if(a[who][k]>=j+last[2]) //比上一组牌大
				{
					sum[who]-=j+last[2],tmp=1;
					last[1]=k,last[2]+=j,last[3]=who;
					a[who][k]-=last[2];
					if(sum[who]==0) //牌出完了
					{
						cout<<who;
						return 0;
					}
					break;
				}
			}
			if(tmp)break;
		}
	}
	return 0;
}
```

---

## 作者：zymooll (赞：7)

## 前言

当时写传智杯这道题的时候就是奔着写题解来的，但是一直没开，今天中午（2022-11-11 12:50）恰巧看见加入主题库了，便赶来写一写。

## 题意简述

模拟三个人按 1,2,3,1,2,3,1... 顺序出牌，每次每人出牌遵守恰好打出在自己所有可以打（即比上家大）的牌型中最小的牌，若无合法牌型可出，则本轮不出牌。

若有人出牌后，其余两人都不出牌（即要不起），则从该人开始开始下一轮，该人打出本人最小的牌型。

合法的牌型由 $N$ 张点数相同的牌构成。

牌的大小决定与牌型的长度（$len$）和其中的点数（$N$）决定：

对于牌型 $A$ 和 $B$，若 $len_A>len_B$，则 $A$ 大，反之则 $B$ 大。

特殊的，若 $len_A=len_B$ 时，比较构成 $A$ 和 $B$ 的数字 $N_A$ 和 $N_B$，若 $N_A > N_B$ 时，则 $A$ 大；若 $N_A = N_B$ 时，则一样大；若 $N_A < N_B$ 时，则 $B$ 大。

## 算法简述

本题我们采用模拟算法。通过模拟每个人的出牌，出牌后检查其牌是否打光判断胜负。

具体实现请查阅代码。

## 可行性证明

模拟题就不说这个了吧。。。

## 时间复杂度及空间复杂度

时间复杂度：最坏 $O(3n)$

空间复杂度：$O(nm)$

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ls,js,mjs;
int a[10][60];//a[第几个人][哪种牌]->有几张
int b[10];//统计每个人打了几张牌 用来判断获胜 
struct p{int x,n;/*x=牌型 n=数量*/}s,mins;//上家打的什么牌 不要为0 1
int main(){
	s.x=0;s.n=1;
	cin>>n>>m;
	for(int i=1;i<=3;i++){
		for(int j=0;j<n;j++){
			cin>>ls;
			a[i][ls]++;
		}
	}
	while(1){//控制每轮 
		for(int i=1;i<=3;i++){//模拟每个人 
			//cout<<i<<":";
			mins.x=INT_MAX;mins.n=INT_MAX;
			for(int j=1;j<=m;j++){//模拟打哪种 
				if(a[i][j]>s.n){//比上家牌多  
					if(j<=s.x){
						if(s.n+1<mins.n||(s.n+1==mins.n&&j<mins.x)){
							mins.n=s.n+1;mins.x=j;
						}
					}
					else{
						if(s.n<mins.n||(s.n==mins.n&&j<mins.x)){
							mins.n=s.n;mins.x=j;
						}
					}
				}
				if(a[i][j]==s.n&&j>s.x){//跟上家牌一样 但是我比他大 
					if(s.n<mins.n||(s.n==mins.n&&j<mins.x)){
						mins.n=s.n;mins.x=j;
					}
				}
			}
			if(mins.x==INT_MAX){
				mjs++;
				//cout<<endl;
				if(mjs==2){
					s.x=0;s.n=1;
					mjs=0;
				}
				continue;
			}
			else mjs=0;
			//for(int j=0;j<mins.n;j++)cout<<mins.x;
			//cout<<endl;
			a[i][mins.x]-=mins.n;
			b[i]+=mins.n;
			s.x=mins.x;s.n=mins.n;
			if(b[i]==n){
				cout<<i;
				return 0;
			}
			
		}
	}
	return 0;
}
```

## 备注

这个代码是一年半之前写的，写的不好多多见谅，更新的代码会放在这里 [Link](https://www.luogu.com.cn/paste/neiimtoa)，有任何疑问也欢迎发私信。

---

## 作者：zhuweiqi (赞：5)

本题是一道模拟题，思路很简单，但难点是要把它写出来，下面提供一种最简单，也是最好理解的思路：一开始每个人手上都有 $n$ 张牌，牌的点数在 $(1,m)$ 之间，我们可以定义一个二维数组 $a$，用 $a_{i,j}$ 来表示第 $i$ 个人手上剩余的点数为 $j$ 的牌的张数，定义一个一维数组 $b$，用 $b_i$ 来表示第 $i$ 个人手上还剩下几张牌，这样方便我们在每一手牌出完后检查是否已经有人把牌出完了。

在对局过程中，每一回合的第一手牌必定是一张牌，而且这一张牌一定是出牌人目前拥有的点数最小的牌，接下来每手牌都有三种情况，第一种情况是出牌人能出，并且出的张数和上一个人出的相同，但是点数比上一个人的大；第二种情况是出牌人能出，但是他出的张数和上一个人的不同，或者说比上一个人多一张，简单推理一下就知道：如果这一回合他能出，说明他出的张数肯定比上一个人出的多一张，并且点数比上一个人出的小或者相同；第三种情况就是出牌人出不起。如果连续出不起的人数大于等于 $2$，那么这回合就结束了；如果出牌人可以出牌，那么连续出不起的人数就要清零。如果没有人出完自己手上的牌，那么对局就继续。

好的，思路讲完了，上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[5][60],b[5];
bool check(){
    for(int i=1;i<=3;i++){
        if(b[i]==0){
            printf("%d",i);
            return 0;
        }
    }
    return 1;
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=3;i++){
        for(int j=1;j<=n;j++){
            int x;
            scanf("%d",&x);
            a[i][x]++;
        }
        b[i]=n;
    }
    int num=1;
    while(check()){
        int pass=0;
        int c,cnt;
        for(int i=1;i<=m;i++){
            if(a[num][i]!=0){
                a[num][i]--;
                b[num]--;
                if(!check()) return 0;
                c=i;
                cnt=1; 
                num++;
                if(num==4) num=1;
                break;
            }
        }
        while(pass<2){
            int flag=0;
            for(int i=c+1;i<=m;i++){
                if(a[num][i]>=cnt){
                    a[num][i]-=cnt;
                    b[num]-=cnt;
                    if(!check()) return 0;
                    c=i;
                    num++;
                    if(num==4) num=1;
                    pass=0;
                    flag=1;
                    break;
                }
            }
            if(flag==1) continue;
            for(int i=1;i<=c;i++){
                if(a[num][i]>cnt){
                    a[num][i]-=cnt+1;
                    b[num]-=cnt+1;
                    if(!check()) return 0;
                    c=i;
                    cnt++;
                    num++;
                    if(num==4) num=1;
                    pass=0;
                    flag=1;
                    break; 
                }
            }
            if(flag==1) continue;
            pass++;
            num++;
            if(num==4) num=1; 
        }
    }
    return 0;
}
```

---

## 作者：Convergent_Series (赞：3)

根据题意可知：  

+ 出牌
  1. 肯定优先出数量相同、牌面数值大的牌。
  1. 如果数值大的牌不够，则考虑数值小但数量多的牌。
+ 换一轮
  1. 记录连续出不起的次数，如果达到 $2$ 就换。
  2. 换轮时出不起次数、当前牌值都必须清零，但当前牌数要设为 $1$ 。
  3. 换轮时出牌顺序不改，因为两个人出不起后恰好轮到上一个出了牌的人。
+ 结束
  1. 出完牌后统计出牌者剩余的牌数，如果为 $0$ 则输出。
  2. 输出后必须结束程序，否则会输出不止一个人。
    
使用桶储存牌，模拟即可。  
具体细节见代码：
```cpp
#include<iostream> 
#include<cstdio> 
#include<cstring> 
#include<algorithm> 
#include<iomanip> 
using namespace std;
int t[5][60],n,m;
int main()
{
	cin>>n>>m;
	int tmp,sp=0,sg=1;//sp为当前牌值，sg为张数
	int i,j;
	for(i=1;i<=3;i++)
	{
		for(j=1;j<=n;j++)
		{
			cin>>tmp;
			t[i][tmp]++;//利用桶记录牌
		}
	}
	int d=0,c=0;//d为当前出牌者，c为连续出不起的次数。
	bool fl=false;//是否出牌
	while(1)//不断出牌
	{
		d++;
		fl=false;
		if(d==4) d=1;
       		 //出牌
		for(i=sp+1;i<=m;i++)
		{
			if(t[d][i]>=sg)
			{
				t[d][i]-=sg;
				sp=i;
				fl=true;
				break;
			}
		}
		if(!fl){
			for(i=1;i<=m;i++){
				if(t[d][i]>sg){
					t[d][i]-=sg+1;
					sp=i;
					sg++;
					fl=true;
					break;
				}
			}
		}
		int sum=0;
		for(i=1;i<=m;i++) sum+=t[d][i];//记录当前牌数
		if(sum==0){
			cout<<d;
			return 0;
		}
		if(!fl) c++;
		if(fl) c=0;
		if(c==2)//换一轮
		{
			c=0;
			sg=1;
			sp=0;
		}
	}
	return 0;
}
```

---

## 作者：codwarm (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P8836)

## 题目分析
本题是一道比较简单的模拟题，根据题意直接模拟即可。

读入数据可以用**桶**存储牌的数量自动排序。

有几点需要注意一下：

+ 判断“两个人都无法打出牌时”需要注意是**连续两人**无法打出牌。

+ 在每次进行下一个回合前都需要注意初始化。


具体见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
int n,m,box[3][N];
bool pd(int idx) // 判断是否结束了（即有人获胜了
{
	int flag = 1;
	for (int i = 0;i <= m;i++) if (box[idx][i]) flag = 0;
	return flag;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i = 0;i < 3;i++)
		for (int j = 1;j <= n;j++)
		{
			int x;
			scanf("%d",&x);
			box[i][x]++;//桶排序
		}
			
	int tplastman = 0;//即题目中“打出最后一张牌的人”，初始设为0
	while (1) // 最外层的循环循环游戏回合数 直到有人获胜跳出循环
	{
		//初始化 idx为当前出牌者的编号 cnt为当前需要出的牌的张数 
		//cur 为 上一次出的牌的点数 loser为有多少人不能打出牌
		int idx = tplastman,cnt = 1,cur = -1,loser = 0;
		// 第二层的while循环多轮的游戏，直到“一轮中，其余两个人都无法打出牌”跳出循环
		while (true) 
		{
			//flag:当前编号的人能否打出牌
			//flag2：能否增加牌的张数
			bool flag = 0,flag2 = 0;
			//循环遍历直到可以打出牌或确认无法打出牌
			while(!flag)
			{
				//遍历桶
				for (int i = 0;i <= m;i++) 
				{
					//若可以打出
					if (box[idx][i] >= cnt && i > cur)
					{
						box[idx][i] -= cnt;
						cur = i;
						flag = 1;
						tplastman = idx;
						loser = 0;//清空
						break;
					}
					//如果有牌的张数大于当前张数，则可以增加张数
					if (box[idx][i] > cnt) flag2 = 1;
				}
				//若可以继续增加牌的张数，继续循环
				if (flag == 0 && flag2) cnt++,cur = -1;
				else if (flag == 0 && flag2 == 0) break;//跳出循环
			}
			//打不出牌
			if (flag == 0) loser++;
			if (loser >= 2) break;
			if (pd(idx))
			{
				//结束后直接输出
				cout << idx+1 << endl;
				return 0;
			}
			idx = (idx + 1) % 3;
		}
	}
	return 0;
}
```

---

## 作者：Jorisy (赞：2)

简单模拟。

---

首先，由于数据较小，我们可以开桶 $a_{[0,2],x}$ 表示第 $0/1/2$ 个人的第 $x$ 种牌有几张。

接着，我们记 $lstn$ 表示上一次出的牌的大小，$lsts$ 表示上一次出的牌的数量，初始时值分别为 $0,1$。

我们再用 $t$ 表示当前出牌者，每次更新 $t$ 为 $(t+1)\bmod3$。

同时，我们还要记 $cnot$ 为连续不出牌次数，$cnot=2$ 时进入下一回合。

每次再判定牌是否出完即可。

综上，AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,a[5][55];

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=0;i<3;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int x;
			cin>>x;
			a[i][x]++;//更新桶
		}
	}
	int t=0,lstn=0,lsts=1,cnot=0;
	while(1)
	{
		for(int i=1;i<=m;i++)
		{
			if(lsts<=a[t][i])
			{
				if(lstn<i) a[t][i]-=lsts,lstn=i;
				else continue;
				cnot=0;//注意这里，下同
				goto p;
			}
		}//先是牌的大小
		for(int i=1;i<=m;i++)
		{
			if(lsts<=a[t][i])
			{
				if(lsts<a[t][i]) a[t][i]-=++lsts,lstn=i;
				else continue;
				cnot=0;
				goto p;
			}
		}//再是牌的数量
		if(++cnot==2)
		{
			lstn=0,lsts=1;
			cnot=0;
			t=(t+1)%3;
			continue;
		}
		p:;
		bool is_zero=1;
		for(int i=1;i<=m;i++)
		{
			if(a[t][i])
			{
				is_zero=0;
				break;
			}
		}
		//cerr<<"DEBUG: "<<t<<',';for(int i=1;i<=m;i++) cerr<<a[t][i]<<' ';cerr<<endl;
		if(is_zero) break;//是否出完
		t=(t+1)%3;
	}
	cout<<++t;//与题意差一，加上去
 	return 0;
}
```

---

## 作者：WA_sir (赞：1)

## [题目链接](https://www.luogu.com.cn/problem/P8836)

看了题目描述和样例之后，一个人的出牌方法其实也就只有如下 $2$ 种：

1. 出比上一个出牌者牌点数更大但数量相等的牌。
1. 出比上一个出牌者牌点数小或等于而数量多一的牌。

法 $2$ 有以下解释：

**点数更小或相等**是因为如果点数大于上一个出牌者的点数且牌数量够的情况下，应该归结于法 $1$。

**数量多一**是为了满足**每人打出一组比上个人打出的牌大的，自己能打出的最小的牌**的“硬性要求”。

此时，还要考虑很多很多：

1. 对每回合的开始与结束进行特判与处理。
1. 对每个人的牌的存储。
1. 上一个出牌者出的牌的记录以及对当前出牌者的比较方法。
1. 出或未出的记录。

这些都在代码中进行了解决。

最后，奉上一份不怎么完美的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct stru
{
	int p[55],ps;
}a[5];//a[1],a[2],a[3]分别为三名同学
int n,m,x,pzl,psl=1,dq;
//pzl:上一个出牌者牌种类
//psl:上一个出牌者牌数量
//dq:当前"要不起"人数
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=3;i++)
		for(int j=1,ij;j<=n;j++)
		{
			scanf("%d",&ij);
			a[i].p[ij]++;
		}
	a[1].ps=a[2].ps=a[3].ps=n;
	while(++x)//x为当前出牌者
	{
		if(dq>=2)pzl=0,psl=1;
		bool f=false;
		if(x>3)x=1;
		if(!a[x].ps)//特判出完
		{
			printf("%d",x);
			return 0;
		}
		for(int i=pzl+1;i<=m;i++)//出牌法1
			if(a[x].p[i]>=psl)
			{
				a[x].p[i]-=psl;
				a[x].ps-=psl;
				pzl=i;
				if(!a[x].ps)
				{
					printf("%d",x);
					return 0;
				}
				f=true;
				break;
			}
		if(f)
		{
			dq=0;
			continue;
		}
		for(int i=1;i<=pzl;i++)//出牌法2
			if(a[x].p[i]>psl)
			{
				a[x].p[i]-=psl+1;
				a[x].ps-=psl+1;
				pzl=i;
				psl++;
				if(!a[x].ps)
				{
					printf("%d",x);
					return 0;
				}
				f=true;
				break;
			}
		!f?dq++:dq=0;//记录未出牌的选手个数
	}
	return 0;
}
```
感谢阅读 §(*￣▽￣*)§！

---

## 作者：caotianhao (赞：0)

## 题外话
今天看到一个同学写了篇题解，我也来~~水~~一篇，另外，本篇为本蒟蒻的第一篇题解，望多指教。（~~5改了~~）

[传送门](https://www.luogu.com.cn/problem/P8836)

## 题目大意
三个人打牌，每人有 $m$ 张牌，有 $ 1\sim n$ 共 $n$ 种牌，可以打出单张或多张一样的牌。
#### 大小规则
1. 设 $x$，$y$ 为 $2$ 种牌型，$len_x$ 表示 $x$ 的长度，$num_x$ 表示 $x$ 的点数；   
2. 若 $len_x>len_y$，则 $x>y$；   
3. 若 $len_x=len_y$，且 $num_x>num_y$，则 $x>y$。
#### 出牌规则
1. 出比上一个人大的；
2. 能出必出；
3. 小牌优先。
#### 输出结果
输出先把牌打完的人的序号。
## 解题思路
先记录每个人每种牌的数量，每个人剩的牌数量，上一个出牌的人、点数和数量。然后根据题意模拟即可，详见代码。
## ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t[4][55],res[4],lp=1,ln,lc,p;
/*
t[i][j]:第i个人第j种牌的数量 （桶） 
res[i]:第i个人剩的牌数量  
lp:上一个出牌的人  
ln:上一个出的点数 
lc:上一个出的数量 
p:现在出牌的人 
*/
int main(){
	cin>>n>>m;
	res[1]=res[2]=res[3]=n;
	for(int i=1;i<=3;i++){
		for(int j=1;j<=n;j++){
			int a; 
			cin>>a;
			t[i][a]++; 
		}
	}
	int x=1;
	while(true){ 
		bool flag=false;//标记是否出过 
		p=(x-1)%3+1;
		if(p==lp){//新回合开始 
			lc=1;
			ln=0;
		}
		for(int i=0;i<=res[p];i++){//枚举数量 
			for(int j=1;j<=m;j++){//枚举点数 
				if(i==0&&j<=ln){//出不了的时候 
					continue;
				}
				if(t[p][j]>=i+lc){//可以出的时候
					res[p]-=i+lc;//模拟打出牌 
					flag=true;//已经出牌，标记为真 
					lp=p;
					ln=j;
					lc+=i;
					t[p][j]-=lc;//更新 
					if(res[p]==0){//判断是否出完 
						cout<<p;//输出 
						return 0; //直接结束 
					}
					break;//出过牌了，下一个同理 
				}
			}
			if(flag){
				break;
			}
		}
		x++;
	}
	return 0; 
}

```


---

## 作者：QWQ_SenLin (赞：0)


题目很好理解，就是一个简单的模拟题，但有几个小细节。

- 每次出牌不能出最大的，只能出比上一个大，但对于自己是最小的牌。
- 如果所有人都要不起了，就开启下一回合，让最后出牌的人先出。
- 玩家只有 $3$ 名。

这种模拟题我建议可以把每个步骤放到一个函数里，$\text{DEBUG}$ 时比较方便。

### 一些变量/数组

这个倒没什么好说的。

```cpp
bool judge_game_is_overed(); //判断游戏是否结束 
void move(int p); //玩家p出牌 
void init(); //初始化 

int n , m , now = 1;
int last_sum = 1 , last_a; //上一名玩家出的数量，牌编号 
int last_player; //上一名玩家 
const bool DEBUG = false;
struct QWQ{ //每种牌 
	int a , sum;
	bool operator < (const QWQ &b) const{
		return a < b.a;
	}
	bool play_card(int b){ //出n张牌，不能出返回false 
		if(sum < b)
			return false;
		sum -= b;
		return true;
	} 
}qwq[5][55];
```

### 输入

首先是输入，我是用一个结构体来表示第 $i$ 名玩家第 $j$ 小的牌的编号和数量，先正常输入，用桶存，每次使用要清空，最后放进这个结构体数组就输入完成了。

当然你也可以直接用桶存。

```cpp
void init(){
	scanf("%d%d" , &n , &m);
	for(int i = 1;i <= 3;i++){
		int tong[55];
		memset(tong , 0 , sizeof(tong));
		for(int j = 1;j <= n;j++){
			int t;
			scanf("%d" , &t);
			tong[t]++;
		}
		int cnt = 1;
		for(int j = 1;j <= m;j++){
			if(!tong[j])
				continue;
			qwq[i][cnt].a = j;
			qwq[i][cnt].sum = tong[j];
			cnt++;
		}
	}
}
```
### 出牌（找牌）
这个函数是让玩家 $p$ 出牌，能出就出，不能出就不出。

优先出牌数相同比上一位出牌的玩家出的牌编号大的牌，如果没有，就出牌数比上一位玩家出的牌数 $+1$ 的最小牌。实现的话可以顺序遍历，找到的第一个符合要求的就是最小的。

如何判断回合结束呢？用一个变量储存上一个出牌的玩家，当到玩家 $p$ 出牌时，如果上一个出牌的玩家是他自己，说明除他之外的玩家都出不起，这时就回合结束了。

注意回合结束要清空一些数据，因为回合开始的第一个玩家可以直接出他最小的牌，不必出比上一个玩家大的牌。

```cpp
void move(int p){ //玩家p出牌 
	if(last_player == p){
		last_a = 0;
		last_sum = 1; //清空
	}
	for(int i = 1;i <= n;i++){ //出相同数量的牌 
		if(qwq[p][i].a <= last_a) 
			continue;
		if(qwq[p][i].play_card(last_sum)){ //出n张牌，不能出返回false 
			last_a = qwq[p][i].a;
			if(DEBUG)
				printf("%d %d %d\n" , p , qwq[p][i].a , qwq[p][i].sum);
			last_player = p; //更新
			return ;
		}
	}
	for(int i = 1;i <= n;i++){ //出数量+1的牌 
		if(qwq[p][i].play_card(last_sum + 1)){
			last_sum++;
			last_a = qwq[p][i].a;
			if(DEBUG)
				printf("%d %d %d\n" , p , qwq[p][i].a , qwq[p][i].sum);
			last_player = p;
			return ;
		}
	}
	judge_game_is_overed(); //判断游戏是否结束
}
```

### 判断游戏是否结束

遍历一遍玩家，如果某个玩家没牌了，就结束游戏，输出他胜利。

```cpp
bool judge_game_is_overed(){ //判断游戏是否结束 
	for(int p = 1;p <= 3;p++){
		int sum = 0;
		for(int i = 1;i <= n;i++)
			sum += qwq[p][i].sum; //计算第 p 名玩家的牌的总数
		if(!sum){
			printf("%d\n" , p);
			exit(0); //结束游戏
		}
	}
}
```

### ps

完整代码就不放了，这个模拟应该不会很难，如果写的是大模拟，就应该把每个步骤放到一个函数里，并打好注释，不然 $\text{DEBUG}$ 起来会很~~开心~~痛苦了。

---


# [传智杯 #4 初赛] 萝卜数据库

## 题目描述

花栗鼠很喜欢偷吃生产队的大萝卜，因此花栗鼠科技大学正在研究一种新型的数据库，叫做萝卜数据库。

具体来说，它支持 $k(1 \leq k \leq 100)$ 个字段，每个字段名都是整数，里面存储的数值也都是整数。

现在你支持如下操作： 

- 向数据库中插入一个记录，它可能只会包含 $k$ 个字段的某一部分。具体的操作格式详见“输入格式”。

- 在数据库中查询有多少条符合条件的记录。

现在你总共有 $n$ 次操作（$1 \;\leq n \leq 1000$）,请你对每个回答操作，输出结果。

## 样例 #1

### 输入

```
4 5
1 2 1 2 2 4
2 2 1 5
1 2 3 5 4 6
2 4 7 8```

### 输出

```
1
0```

# 题解

## 作者：duanfeitong (赞：7)

### [【题目传送门】](https://www.luogu.com.cn/problem/P8843)

### 【题意解释】
模拟一个数据库，支持两种操作：

- 往地址 $x$ 处插入一个数据 $y$。
- 询问地址 $x$ 处所有数据满足在范围 $[ymin , ymax]$ 的有多少个。

### 【题目分析】
我们可以使用两个数组来模拟这个数据库（以代替复杂一些的```vector```），一个数组表示地址，一个数组表示数据。

### 【代码展示】
```cpp
#include<bits/stdc++.h>
using namespace std;
//定义区 
int n,k;
int m,x,y,op;
int a[100005],b[100005],num;
 
int main()
{
	scanf("%d%d",&n,&k);
	for(int T=0;T<n;T++)
	{
		scanf("%d",&op);//输入操作类型
		if(op==1)//插入操作 
		{
			scanf("%d",&m);
			for(int i=1;i<=m;i++)
			{
				scanf("%d%d",&x,&y);//x为地址，y为数据
				a[++num]=x,b[num]=y;
                //数组a储存第num个数据的地址
                //数组b则储存第num个数据
			}
		}
		else//询问操作 
		{
			int ans=0,l,r;//l,r 即 ymin,ymax 
			scanf("%d%d%d",&m,&l,&r);
			for(int i=1;i<=num;i++)//遍历 
				if(a[i]==m)//如果第i个数的地址是所询问的地址 
					if(l<=b[i]&&b[i]<=r)//并且第i个数满足限制条件 
						ans++;//答案+1 
			printf("%d\n",ans);//输出，千万不要忘记换行！ 
		}
	}
	return 0;//The end 
}
//MXX 2022/11/29
```
[AC记录](https://www.luogu.com.cn/record/96018509)

谢谢！

---

## 作者：SnapYust (赞：6)

## 题目传送门

[[传智杯 #4 初赛] 萝卜数据库](https://www.luogu.com.cn/problem/P8843)

## 思路

很显然，使用`std::vector`容器进行模拟。

面对一个问题：会爆吗？

我们来简单算算复杂度：

对于每个`1`操作，我们有 $O(p)$ 的复杂度进行插入操作。

对于每个`2`操作，我们有 $O(size(x))$ 的复杂度进行插入操作。

因为所有数值都很小，所以考虑**暴力解法**。

### 插入操作

很显然，输入 $p$，循环 $p$ 次，每次有：$v_x.insert(y)$。

### 查询操作

依然简单，循环 $size(v_x)$ 次寻找在 $[y_{min},y_{max}]$ 中的值的个数。

## Code

```cpp
#include <bits/stdc++.h>
int n, k;
std::vector<int> v[1005];

int main()
{
    scanf("%d%d", &n, &k);
    while (n--)
    {
        int m;
        scanf("%d", &m);
        if (m == 1)
        {
            int p, x, y;
            scanf("%d", &p);
            while (p--)
            {
                scanf("%d%d", &x, &y);
                v[x].push_back(y);
            }
        }
        else
        {
            int x, ymin, ymax, ans = 0;
            scanf("%d%d%d", &x, &ymin, &ymax);
            for (int i = 0; i < v[x].size(); i++)
                if (v[x][i] >= ymin && v[x][i] <= ymax)
                    ans++;
            printf("%d\n", ans);
        }
    }
    return 0;
}
```


---

## 作者：FFTotoro (赞：5)

本题使用循环结构和数组即可解决。

具体地，我们使用一个二维数组 $s$（用 `vector` 套 `vector` 实现）即可。

每次插入操作，就对 $s_x$ 插入 $p$ 个数，可使用 `emplace_back` 插入函数：

```cpp
int p; cin>>p;
while(p--){
    int x,y; cin>>x>>y;
    s[x-1].emplace_back(y);
}
```
查询时，只需遍历数组并判断元素是否符合条件即可：

```cpp
int x,l,r,c=0; cin>>x>>l>>r;
for(auto &i:s[x-1])if(i>=l&&i<=r)c++;
cout<<c<<endl;
```

---

## 作者：yanhao40340 (赞：3)

模拟题。

### 题意

题意个人建议多看几遍，或者结合样例理解。

大体来说是给定 $k$ 次操作。

操作 $1$ 表示插入一个字段，其中 $a_{x_i}=y_i$。

操作 $2$ 表示查询有多少个字段满足 $y_{min} \le a_{x_i} \le y_{max}$。

### 分析

用一个数组 $f$ 记录，其中 $f_i$ 表示第 $i$ 个数的值。

因为同一个数的值会有很多，可以在 $f_i$ 中再套一个数组，或者可以用 vector 实现。

查询时遍历 $f_x$，逐个进行判断即可。

### 核心代码

插入操作：

```cpp
int n;scanf("%d",&n);
for (int i=1,x,y;i<=n;++i)
	scanf("%d%d",&x,&y),a[x][++cnt[x]]=y;
```

删除操作：

```cpp
int x,l,r,tot=0;scanf("%d%d%d",&x,&l,&r);
for (int i=1;a[x][i];++i)
	if (a[x][i]>=l&&a[x][i]<=r) ++tot;
printf("%d\n",tot);
```

---

## 作者：icaijy (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8843)
# 题意
简单来说就是**模拟**一个数据库的**增加**和**查询**。具体的还是自己读一下吧。

思路就是**模拟**。

# 具体思路
用一个**二维数组**存储数据，第一维表示字段，第二维的**第一个元素表示该字段有多少个数据**，剩下的空间就用来存储数据了。每次存储，存到字段中下一个空的位置，该字段数据 $+1$。每次查询，遍历一个字段中所有数据。输出符合条件的个数。

# 代码
~~感觉我的代码挺优美的。~~
```cpp
#include <iostream>
using namespace std;
int n,k;
int data[105][1005]; // 数据库 
int op,p,x,xi,yi,ymin,ymax,ans; 
int main(){
	scanf("%d%d",&n,&k);
	while (n--){
		scanf("%d",&op); // 读入1或2 
		if (op==1){ // 存 
			scanf("%d",&p);
			while (p--){
				scanf("%d%d",&xi,&yi);
				data[xi][++data[xi][0]]=yi; // 用data[x][0] 表示该字段的数据数 
			}
		}
		else { // 查 
			ans=0;
			scanf("%d%d%d",&x,&ymin,&ymax);
			for (int i=1;i<=data[x][0];i++){ // 遍历 
				if (data[x][i]>=ymin&&data[x][i]<=ymax){ // 判断是否符合 
					ans++;
				}
			}
			cout<<ans<<endl;
		}
	}
	return 0;
}

```
温馨提示：代码第 $14$ 行的操作在 C++17 标准下编译不过，请自行修改。

---

## 作者：wxh666 (赞：1)

这一题其实只要用两个数组就可以解决。

## 题意简述

类似于 map 内有一个数组。

每一次输入给出字段的名字 $p$ 和存储的数值 $x_i$。

同一个字段可以拥有很多个存储的值。

每一次查询查找在名字为 $x$ 的字段中在 $[y_{\min},y_{\max}]$ 之间的值有多少个。

## 算法描述
按题意进行模拟，类似于链式前向星的方法。

我们可以定义两个数组 $a$,$b$。

数组值的下标 $i$ 代表第 $i$ 个输入的值。

$a_i,b_i$ 分别代表这个输入的字段名和值。

每次输入把名字放到 $a$ 数组里面，值放到 $b$ 数组里面。

然后每次输出就遍历一遍数组，找出字段名与值符合的数据的数量就可以了。

由于数据范围比较小，所以暴力写能过。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int cz,x,y,c;
int a[100005],b[100005],cnt;
signed main()
{
	cin>>n>>k;
	while(n--)
	{
		scanf("%d",&cz);
		if(cz==1)
		{
			scanf("%d",&c);
			for(int i=1;i<=c;i++)
				scanf("%d%d",&x,&y),a[++cnt]=x,b[cnt]=y;
		}
		if(cz==2)
		{
			int ans=0;
			scanf("%d",&c);
			scanf("%d%d",&x,&y);
			for(int i=1;i<=cnt;i++)
				if(b[i]>=x&&b[i]<=y&&a[i]==c)
					ans++;
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：lwx20211103 (赞：1)

## 题目分析

一道模拟题，我们可以把这想象成一堆桶，当操作数为 1 时，输入的 $x_i$ 可以看做编号是 $x_i$ 的桶，加入 $y_i$ 的值。当操作数是 2 时，就是查询 编号$x_i$ 的桶，是否含有一个值在 $[y_{min}, y_{max}]$ 之内。

建议数据用 `map<int, vector<int> >` 储存。

## 代码

```cpp
#include <bits/stdc++.h> //我爱Linux
using namespace std;

map<int, vector<int> > m;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int n, k;
	cin >> n >> k;
	int i, j;
	for (i = 1;i <= n;i++)
	{
		int op, p, ans = 0;
		cin >> op;
		if (op & 1 == 1)
		{
			cin >> p;
			for (j = 1;j <= p;j++)
			{
				int x, y;
				cin >> x >> y;
				m[x].push_back(y);
			}
		}
		else
		{
			int x, ymin, ymax;
			cin >> x >> ymin >> ymax;
			for (j = 0;j < m[x].size();j++)
			{
				if (m[x][j] >= ymin && m[x][j] <= ymax)
				{
					ans++;
				}
			}
			cout << ans << "\n";
		}
	}
	return 0;
}



```


---

## 作者：LJKX (赞：0)

## 思路
看到数据范围比较小，可以直接暴力求解。

因为每个字段的长度不确定，所以我们可以开一个 ```vector<int>a[1005]``` 来记录每个字段。

对于操作一，每次插入即可。

对于操作二，遍历一遍 ```a[x]``` 并判断条件就行。

## Code
```
#include<bits/stdc++.h>
#define get getchar()
using namespace std;
int n,k;
int opt,p,x,y;
vector<int>a[1005];
inline int read() {
	int x=0,f=1;char ch=get;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=get;}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=get;
	return x*f;
}
int main() {
	scanf("%d%d",&n,&k);
	while(n--) {
		scanf("%d",&opt);
		if(opt==1) {
			scanf("%d",&p);
			while(p--) {
				scanf("%d%d",&x,&y);
				a[x].push_back(y);
			}
		}else {
			scanf("%d%d%d",&p,&x,&y);int ans=0,l=a[p].size();
			for(int i=0;i<l;i++)
			if(a[p][i]>=x&&a[p][i]<=y)ans++;
			printf("%d\n",ans);
		}
	}
	return 0;
}
```


---

## 作者：安舒阳 (赞：0)

这道题数据不大，从思路上来说也是一个纯模拟，也就必要用 `vector`，简单使用数组模拟即可。

在这里我们使用一个二维数组，把每一维的第零项定义为它的长度即可。

唯一需要注意的在代码第二十五行的 `++data[x][0]` 而不是 `data[x][0]++`，因为这里的 `data[x][0]` 是从零开始的，**也就是说它代表的是 `data[x]` 最后一位有数的下标**，所以在每次存储之前就需要加一。

```cpp
#include<bits/stdc++.h>
using namespace std;
int data[1005][1005];//data[i][0]代表i有多少项 
int k=0;
int find(int x,int mmin,int mmax){
	int ans=0;
	for(int i=1;i<=data[x][0];i++){
		if(data[x][i]>=mmin&&data[x][i]<=mmax){
			ans++;
		}
	}
	return ans;
}
int main(){
	int n,ttmp;
	scanf("%d%d",&n,&ttmp);
	while(n--){
		scanf("%d",&ttmp);
		if(ttmp==1){
			int p;
			scanf("%d",&p);
			while(p--){
				int x,y;
				scanf("%d%d",&x,&y);
				data[x][++data[x][0]]=y;
			}
		}else{
			int x,mmin,mmax;
			scanf("%d%d%d",&x,&mmin,&mmax);
			printf("%d\n",find(x,mmin,mmax));
		}
	}
	return 0;
}
```


---


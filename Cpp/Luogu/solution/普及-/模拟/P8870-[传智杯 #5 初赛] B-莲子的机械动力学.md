# [传智杯 #5 初赛] B-莲子的机械动力学

## 题目背景

**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**

专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)

一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。

在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。

于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。

如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。

如下是个例子，实现 $\overline{1021}_{(3)}+\overline{0021}_{(3)}=\overline{1112}_{(3)}$

![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)

初始时齿轮的状态如上。

![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)

把第一个齿轮拨动一个单位长度，变为如上图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)

把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\overline{1112}_{(3)}$。

---

现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。

![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)

莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。


## 题目描述

题目背景的问题可以转化为如下描述：

给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。

但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。

下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。

![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)

## 说明/提示

对于全部数据，保证 $1\le n,m\le 2\times 10^5$，从低位往高位数起有 $a_i\in[0,i]$，$b_i\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。

## 样例 #1

### 输入

```
5 4
3 3 2 1 1
3 2 2 1```

### 输出

```
4 2 1 1 0
```

## 样例 #2

### 输入

```
10 1
10 9 8 7 6 5 4 3 2 1
0
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# 题解

## 作者：hh20080501hh (赞：3)

# 洛谷P8870 莲子的机械动力学

[题面在这~](https://www.luogu.com.cn/problem/P8870)

------------


 _“题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。”_
 
 
 
 显而易见，第二个题面比第一个题面更好理解，故下面对第二个题面进行分析。
 
##  分析：
- 题目意思很好理解，定义一个新的进制数，这个数的进制是可变的，第 $i$ 位上的数为 $i+1$ 进制。（**注意**：个位为第 $1$ 位，而不是第 $0$ 位哦）
-  所有的数据保证 $m,n\le200000$，~~经过一番计算可以得出~~，显而易见，不可能用 `long long` 来储存，一定一定会爆掉（`int` 更不可能了），就算使用 `__int128` 也不可以哟~。
- 那我们就不得不写一份高精度加法了。~~不喜欢高精度~~
## 高精加法模板：
~~还是挺好写的，但是我决定还是把正常的模板贴过来~~
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
int main()
{
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');
    auto C = add(A, B);
    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
    cout << endl;
    return 0;
}
```
先别急这仅仅是个模板，肯定是过不了的~~过得了就见鬼了~~。

**那么这道题的正确写法与模板到底差什么呢？**
让我们回顾一下题意，显而易见：
1. 模板中的是十进制，也就是逢 $10$ 进 $1$。
1. 这道题是变进制，是逢 $i$ 进 $i+1$。
1. 逢 $10$ 进 $1$ 与逢 $i+1$ 进 $1$ 肯定是有区别的。

不过万幸的是，这道题仅仅只有进位与模板不一样，加是一模一样滴。

## 正确做法：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m;
int a[200010] , b[200010];
vector <int> a1 , b1;

vector <int> add(vector<int> &A , vector<int> &B)
{
	if (A.size()<B.size())
	{
		return add(B , A);
	}
	vector<int> C;
	C.clear();
	for (int i=0 ; i<A.size() ; i++)
	{
		int t=A[i];
		if (i<B.size())
		{
			t+=B[i];
		}
		C.push_back(t);
	}
	for (int i=0 ; i<C.size() ; i++)
	{
		if (C[i]>=i+2)  //判断是否需要进位
		{
			C[i] -= (i+2);
			if (i+1<C.size()) //如果当前位进位之后
			{		  //不会超出C的范围，就往前进位
				C[i+1]++;
			}
			else//如果当前位进位会超出C的范围，就给C再
			{   //要个地方进位
				C.push_back(1);
				break;
			}
		}
	}
	return C;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	cin >> n >> m;
	for (int i=0 ; i<n ; i++)
	{
		cin >> a[i];
	}
	for (int i=0 ; i<m ; i++)
	{
		cin >> b[i];
	}
	for (int i=n-1 ; i>=0 ; i--)
	{
		a1.push_back(a[i]);
	}
	for (int i=m-1 ; i>=0 ; i--)
	{
		b1.push_back(b[i]);
	}
	auto c = add(a1 , b1);
	for (int i=c.size()-1 ; i>=0 ; i--)
	{
		cout << c[i] << " ";
	}
	return 0;
}
```
除了输入方式稍微有点点改变之外，唯一的改变就是进位了，这里我们将进位分开处理，**不仅好写、好处理，而且还快！** 分开进位在高精度乘法时可以感受到比边算边进位的好处，会快一些。

**为什么进位是 $i+2$**？因为我们的下标是从 $0$ 开始的，不是从 $1$ 开始的。


_第一次写题解，如有写的不清楚的地方请见谅，希望审核大大能通过我的题解，第三次了，求求给我过了吧_


---

## 作者：S_Z_Xcoco (赞：2)

~~本蒟蒻被这道题因为前导零坑了两星期，呜呜呜~~。

废话不多说，直接开始讲题。

# 思路
其实这道题是一道非常简单的类似于高精度加法的题（~~本蒟蒻一开始还以为是什么高深的DP~~）。

不会高精度的[看这里](https://www.luogu.com.cn/problem/P1601)。

### 题意可以简化成这样

输入两个数的位数，求这两个数的和，但第 $i$ 位用的是第 $i+1$ 进制。

看似很麻烦，需要考虑进制。但实际上只要在进位做出判断就行。

具体方法如下：

1.	先算出当前位（第 $i$ 位）两个数相加的和。

2.	如果和 $> i+1$ 那么就进位。

3.	最后处理最高位进位、前导零、答案是零的情况。

4.	输出。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,a[200010],b[200010],c[1000010];
int main(){
	scanf("%lld%lld",&n,&m);//用 c 风格输入更快
	for(ll i=n;i>=1;i--)scanf("%lld",&a[i]);
	for(ll i=m;i>=1;i--)scanf("%lld",&b[i]);
	ll mx=max(n,m);//答案位数是两个数的位数的最大值
	for(ll i=1;i<=mx;i++){
		c[i]+=a[i]+b[i];//相加
		if(c[i]>=i+1){//处理进位情况
			c[i]-=(i+1);//当前位减去 i+1
			c[i+1]++;//下一位加一，表示进位
		}
	}
	mx+=1;//为了防止最后一位进位的情况，位数要加一
	while(c[mx]==0&&mx>=0)mx--;//处理前导零
	if(mx<=0)mx=1;//防止答案为零
	for(ll i=mx;i>=1;i--)cout<<c[i]<<' ';
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：1)

upd on 2024.7.20： 第一篇题解，来修一下。
## 思路
这一题原理和高精度一样，就一位一位的算就行了。

需要注意的是位数得对齐，数组要倒序存储。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    int len;
    int carry=0;
    int i=1;
    int a[200005],b[200005];
    int sum[200005]={}; 
    cin>>n>>m;
    len=max(n,m);
    for (int i=n;i>=1;--i)cin>>a[i];
    for (int i=m;i>=1;--i)cin>>b[i]; 
    while(i<=len||carry){ 
        int x=i<=n?a[i]:0;
        int y=i<=m?b[i]:0;
        int digit_sum=x+y+carry; 
        sum[i]=digit_sum%(i+1);
        carry=digit_sum/(i+1);
        ++i;
    }
    if(sum[len+1]>0)cout<<sum[len+1]<<" ";
    for(int j=len;j>=1;--j)cout<<sum[j]<<" "; 
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

前置知识：[高精加](https://www.luogu.com.cn/problem/P1601)（[OI-Wiki](https://oi-wiki.org/math/bignum/)）

这题其实就相当于每位的进制不同的高精加法。

故我们可以把高精加中的「逢 $10$ 进 $1$」改成「逢 $i+1$ 进 $1$」即可。

不过注意是倒着输入的，所以在输入后我们要翻转两个数组。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
int a[100005],b[100005],c[100005];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	reverse(a+1,a+n+1);
	reverse(b+1,b+m+1);//利用 std::reverse 翻转。
	for(int i=1;i<=max(m,n);i++){
		c[i]=a[i]+b[i];
	}
	for(int i=1;i<=max(m,n);i++){
		c[i+1]+=c[i]/(i+1);
		c[i]%=(i+1);
	}
	if(c[max(m,n)+1]) cout<<1<<' ';
	for(int i=max(n,m);i>=1;i--){
		cout<<c[i]<<' ';
	}
	return 0;
}
```


---

## 作者：Clarinet (赞：1)

[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-11-post)
# 简要题意
给出两个分别有 $n$，$m$ 位的两个整数，将它们相加，但进位原则是第 $i$ 位逢 $i+1$ 进 $1$。求最后的和。
# 分析
一眼高精度做法。虽然不是传统的高精，但是和高精要考虑的内容都是一样的。

首先读入的时候要倒着读，可以参考一下代码读入方式。然后相加时处理进位要按照题目规定来，然后就没有然后了。

看到其他题解在考虑前导的情况，其实不用。可以想到最后和的结果位数最大是 $n$ 和 $m$ 中较大的一个加一，直接判断一下这一位是不是零能不能输出就行。

感觉代码相对比较简单，应该适合其他和我一样高精都打不利索的蒟蒻参考吧。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[200010],b[200010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[n-i+1];
	for(int i=1;i<=m;i++)cin>>b[m-i+1];
	for(int i=1;i<=max(n,m);i++){
		a[i]+=b[i];
		a[i+1]+=a[i]/(i+1);
		a[i]%=i+1;
	}
	if(a[max(n,m)+1]!=0)cout<<a[max(n,m)+1]<<" ";
	for(int i=max(n,m);i>=1;i--)cout<<a[i]<<" ";
	return 0;
}
```
感谢阅读！

---

## 作者：xujingyu (赞：1)

## 题意简述：

有两个数 $a$ 和 $b$，分别是 $n$ 位和 $m$ 位。现在要求 $a+b$，但是非十进制相加。第 $i$ 位相加时按 $i+1$ 位计算。

## 解法：

类似高精度加法，逐位模拟，存的时候可以倒着存，先加低位。可以得出：答案的第 $i$ 位结果 $=a$ 的第 $i$ 位 $+b$ 的第 $i$ 位数 $+$ 上一位的进位再除以这一位的进制，此时进制更新为该位结果对进制取模的结果。

最后输出时注意：

* 倒叙输出。
* 不输出前导 $0$。
* 注意最高位还进了一次位的情况。
* 如果最终结构为 $0$，记得特判。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,a[200001],b[200001],ans[200005];

signed main()
{
	scanf("%d%d",&n,&m);
	for(int i = n;i >= 1;i--) scanf("%d",&a[i]);//倒着输入
	for(int i = m;i >= 1;i--) scanf("%d",&b[i]);
	int len = max(n,m),jin = 0,base;//答案位数、进位、进制
	for(int i = 1;i <= len;i++)
	{
		base = i + 1;//这一位的进制
		ans[i] = a[i] + b[i] + jin;//计算加法
		jin = ans[i] / base;//计算进位
		ans[i] %= base;
	}
	ans[len + 1] = jin;//最高位进位的情况
	bool flag = true,is_print = false;
	for(int i = len + 1;i >= 1;i--)
	{
		if(ans[i]) flag = false;
		if(!flag)//忽略前导0
		{
			printf("%d ",ans[i]);
			is_print = true;
		}
	}
	if(!is_print) printf("0");//答案为0特判
	return 0;
}
```

---

## 作者：wzb13958817049 (赞：1)

# 题意：
![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)
从右往左个位、十位……分别为第一位、第二位……第 $i$ 位，逢 $i+1$ 进 $1$，例如：第一位逢二进一如下图，若不懂进制则看[本题](https://www.luogu.com.cn/problem/P1143)。![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)
 $x_1$ 每加 $2$ 就转 $1$ 圈，$x_1$ 每转一圈就带动 $x_2$ 加 $1$，以此类推。

# 思路
根据题面模拟，类似[高精度加法](https://www.luogu.com.cn/problem/P1601)
但是要注意进位。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
long long len1,len2;
long long a[N],b[N],c[N];
int main(){
	ios::sync_with_stdio(0),cout.tie(0),cin.tie(0);//关同步流，让cin cout的时间复杂度变快
	cin>>len1>>len2;
	for(int i=len1;i>=1;i--){cin>>a[i];}//倒序输入a数组因为方便
	for(int i=len2;i>=1;i--){cin>>b[i];}//也可以正序输入再翻转
	for(int i=1;i<=max(len1,len2);i++){//取较大的位数进行计算，从低位开始计算
		c[i]+=a[i]+b[i];//等于a的第i位+b的第i位，要考虑进位所以是+=
		if(c[i]>=i+1){c[i]-=(i+1);c[i+1]++;}//如果第i位大于i+1则表示要向前一位进一
	}
	if(c[max(len1,len2)+1]==1){for(int i=max(len1,len2)+1;i>=1;i--)cout<<c[i]<<" ";}//最后一位是进位的情况
	else for(int i=max(len1,len2);i>=1;i--)cout<<c[i]<<" ";//因为是倒序读入所以也要倒序输出
	return 0;
}	
```


---


# 「SvR-2」令人为难的区间操作问题

## 题目背景

**Problem Number:** $\textit{45}$

众所周知，区间操作问题应该求出区间和、最大值等值。但今天小 F 有个不情之请。

## 题目描述

小 F 正在研究[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)，他惊讶地发现，可以把这种数列 $F$ 的定义式略作修改，得到 $\digamma$ 数列：

$$\digamma(x)=\{1,1,-1,-1,1,1,-1,-1,1,\ldots\}$$

注意到 $\digamma$ 数列具有周期性，最小正周期 $T=4$。

请注意这里 $\digamma$ 数列与数学上用其表示的[双伽玛函数](https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0)的区别。

小 F 找到一个长度为 $n$ 的数列 $a$，他每次对其进行如下操作：

- 选定两个整数 $l,r$，满足 $1\le l\le r\le n$。
- 对于每个满足 $l\le i\le r$ 的 $i$，将 $a_i$ 加上 $\digamma(i-l+1)$。
- 记录下本次操作（即第 $j$ 次操作）的选定区间的长度 $len_j=r-l+1$。

他一共进行了 $m$ 次操作，操作后得到数列记作 $b$，同时记 $sum=\sum_{i=1}^mlen_i$。

不幸的是，小 F 把 $sum$ 和数列 $len$ 都弄丢了，他只记得 $n$ 和数列 $a,b$。

现在，他想请你根据这些信息，求出 $sum$ 的**奇偶**，**即 $\textbf{\textit{sum}}$ 对 $\textbf2$ 取模后的值**。

## 说明/提示

#### 样例 1 说明

注意到可能进行的是如下操作：

- 第 $1$ 次操作选定 $l=2,r=3$，则数列变成 $[1,{\underline\color{red}\textbf3},{\underline\color{red}\textbf4},4]$。此时 $len_1=2$。
- 第 $2$ 次操作选定 $l=1,r=3$，则数列变成 $[{\underline\color{red}\textbf2},{\underline\color{red}\textbf4},{\underline\color{red}\textbf3},4]$。此时 $len_2=3$。

则 $sum=len_1+len_2=5$，是奇数。故 $sum\bmod 2=1$。

#### 数据规模与约定
**本题采用捆绑测试**
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm{\sum n\le} & \textbf{特殊性质} & \textbf{分值} \\\hline
\textsf{1} & \le 10 & a_i,b_i\le 10^9 & 10 \\\hline
\textsf{2} & \le 10^3 & a_i,b_i\le 10^9 & 20 \\\hline
\textsf{3} & \text{无特殊限制} & a_i,b_i\le 10^9 & 20 \\\hline
\textsf{4} & \text{无特殊限制} & a_i\le b_i & 20 \\\hline
\textsf{5} & \text{无特殊限制} & - & 30 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，有 $1\le T\le 10^3$，$1\le n\le 10^5$，$1\le a_i,b_i\le 10^{18}$。

单个测试点内保证 $\sum n\le 2\times 10^5$。

#### 说明

$\digamma$ 数列拥有如下的递推式：

$$
\digamma(x)=
\begin{cases}
1,&x\le 2\\
-1,&x=3\\
\digamma(x-1)-\digamma(x-2)+\digamma(x-3),&x>3.
\end{cases}
$$

## 样例 #1

### 输入

```
1
4
1 2 3 4
2 4 3 4```

### 输出

```
1```

# 题解

## 作者：CSP_Sept (赞：14)

# 解法

## Solution 1

萌萌签到题，我们考虑到记 $S(i)$ 表示 $F(1),F(2), \ldots ,F(i)$ 的和，发现 $S(i) \equiv i \pmod 2$。

而若干次进行长度为 $len$ 的操作相当于给数列的总和加上若干次 $S(len)$。这样的操作在模 $2$ 域中是等价的。

容易发现，计算出操作前后序列元素和的差，对 $2$ 取模输出即可。

## Solution 2

实际上我们有一种更为有趣的做法，定义 $-1$ 次操作，从而将所有操作全部变为若干次 $len = 1$ 的情况。

具体如下：

对于每个 $i$，

- 若 $a_i<b_i$，则相当于在 $[i,i]$ 上进行了 $b_i-a_i$ 次 $len=1$ 的操作；
- 若 $a_i>b_i$，则相当于在 $[i,i]$ 上进行了 $-(a_i-b_i)$ 次 $len=1$ 的操作。

所以这种情况下，操作总长度即为 $\sum_{i=1}^n(a_i-b_i)$。

---

## 作者：卷王 (赞：7)

一道很好的思维题。

## 思路

大意就不讲了。

进入正题—— 我们发现对于每一个 $a_i$ 和 $b_i$，可以发现 $len = 1$ 的情况是可以统计的。知道了 $len = 1$ 的次数，我们就可以判断 $sum$ 的奇偶性了。

我们分情况讨论：

1. 若 $a_i = b_i$，则不会有 $len = 1$ 的操作。

2. 若 $a_i < b_i$，则有 $b_i - a_i$ 次。

3. 若 $a_i > b_i$，则有 $a_i - b_i$ 次。

综上，即有 $abs(a_i - b_i)$ 次。

这道题就结束了...

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, T;
ll sum = 0;
int main() {
	cin >> T;
	while(T--) {
		cin >> n; sum = 0;
		for(int i = 1; i <= n; i++) {
			ll x, y;
			cin >> x >> y;
			sum = (sum + abs(x - y)) % 2;
		}
		cout << sum << endl;
	}
	return 0;
}
```

---

## 作者：Lovely_Elaina (赞：6)

### 思路

妥妥面向样例题。

- 要求求出 $sum$ 也就是 $\sum{len}$ 的奇偶性；
- 所以 $a_i$ 和 $b_i$ 每差 $1$，对 $sum$ 的贡献也就加 $1$；
- 所以 $sum$ 的奇偶性为 $\displaystyle\sum^{n}_{i=1}{|a_i-b_i|}$ 的奇偶性：
  - 举个例子：若 $b_i-a_i=1$，那么 $a_i+(b_i-1)=a_i\times 2$，对奇偶性没有影响，故只算差值；

优化：易证 $sum$ 的奇偶性为 $\displaystyle \sum^{n}_{i=1}a_i+\sum^{n}_{i=1}b_i=\sum^{n}_{i=1}a_i+b_i$ 的奇偶性。（模拟一下就知道了）

### 代码

十年 OI 一场空，不开 long long 见祖宗。

```cpp
#include <iostream>
#define int long long
using namespace std;

int n,x;

signed main() {
    int T;
    scanf("%lld",&T);
    
    while(T--){
        int sum = 0;
        scanf("%lld",&n);
        for(int j = 1; j <= n; j++){
            scanf("%lld",&x);
            sum += x;
        }
        for(int j = 1; j <= n; j++){
            scanf("%lld",&x);
            sum -= x;
        }
        printf("%lld\n",abs(sum) % 2);
    }
    return 0;
}
```



---

这样一道题评红，是我太肤浅了捏。

---

## 作者：Loser_Syx (赞：5)

upd： 2023-3-25 更改了没开 `long long` 的问题。

## 思路

其实这题我们可以把每次操作看为：

选择一个数，每次操作都可以使其 $+1$ 或 $-1$。

假设此时你要选择一个长度为 $3$ 的序列，将其每个元素加 $1$，你可以选择进行 $1$ 次长度为 $3$ 的加 $1$ 操作，也可以进行 $3$ 次长度为 $1$ 的 加 $1$ 操作，这样相比发现，$2$ 种操作的 $len$ 都为 $3$。

我们再结合样例解释：

第一次我们选择 $a_1$，将其加上 $1$。

第二、三次操作我们选择 $a_2$，进行 $2$ 次加上 $1$ 的操作。

而第四、五次操作我们可以省略，因为 $+1$ 和 $-1$ 之后，数不变，且总次数 $\bmod 2$ 的奇偶性不变。

得出了这个结论，我们就可以得到如下的 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[100001], b[100001];
main(){
    int T;
    scanf("%lld", &T);
    while(T--){
        int n, ans = 0;
        scanf("%lld", &n);
        for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
        for(int i = 1; i <= n; i++){
            scanf("%lld", &b[i]);
            ans += abs(b[i] - a[i]);
        }
        printf("%lld\n", ans % 2);
    }
    return 0;
}
```


---

## 作者：chlchl (赞：1)

## Solution
面向样例编程，观察样例可得答案为 $\sum\limits_{i=1}^{n}|a_i-b_i|\bmod 2$，$O(n)$ 模拟即可。

## 证明
纵向思考和横向思考的转化。区间不好考虑，但是我们可以一个一个位置考虑。

$a_i$ 和 $b_i$ 每差 $1$，对 $sum$ 的贡献就会多 $1$，因此两数组的差全部加起来就是答案。

因为 +1、−1 会抵消，$2$ 次操作对 $sum$ 的奇偶无影响，所以不用担心没有合法的操作方案，多的最后会减回去，并且对答案的奇偶是无影响的。

证明还是有点费脑筋的，不知道是红题标准高了还是我变菜了，这题应该上橙的……

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2e5 + 10;
int T, n;
ll a[N], b[N];

int main(){
    scanf("%d", &T);
    while(T--){
        scanf("%d", &n);
        ll ans = 0;
        for(int i=1;i<=n;i++)
            scanf("%lld", &a[i]);
        for(int i=1;i<=n;i++)
            scanf("%lld", &b[i]), ans += abs(a[i] - b[i]);
        printf("%lld\n", ans % 2);
    }
    return 0;
}
```


---

## 作者：hanyuchen2019 (赞：0)

这里给一种奇妙的做法。

设 $c_i=a_i-b_i$，可以看出，我们的目标是使得所有 $c_i=0$。

由题目可知，当操作时 $l=r$ 时，相当于对 $c$ 中的单独一个数 $+1$。

那么我们就可以通过若干次操作将 $c$ 中的所有数变得相等。

如果 $\digamma(len)=-1$，那么直接全部减掉就行了，否则可以拆成几个小序列进行操作，这些操作一定会使 $sum$ 的值增加 $c_i\times len$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll r()
{
	//快读，略
}
ll a[100005];
int main()
{
	int t=r(),n;
	while(t--)
	{
		n=r();
		for(int i=1;i<=n;++i)a[i]=r();
		for(int i=1;i<=n;++i)a[i]-=r();//此时数组a相当于c
		ll ans=0,mx=0;
		for(int i=1;i<=n;++i)mx=max(mx,a[i]);
		for(int i=1;i<=n;++i)(ans+=mx-a[i])%=2;
		ans+=n%2*(mx%2);
		cout<<ans%2<<endl;
	}
	return 0;
}

```


---

## 作者：zzy0618 (赞：0)

### 题目大意

[题目直通](https://www.luogu.com.cn/problem/P9086)

简化一下就是将数列 $A$ 中个别项不断加上 $1$ 或 $-1$，但在加 $-1$ 时前两项要加上 $1$，加一次记作一次操作，直到数列 $A$ 等于数列 $B$，问操作次数的奇偶性。

### 解题思路

为什么上面可以这么说呢？因为，一个正整数加上一个偶数，**其奇偶性不变**。那么加 $1$ 就是一次操作，加 $-1$ 本身一次操作，而前面的两次并不影响奇偶性，所以相当于一次操作。且题目**保证数据有解**，所以不用担心前面的数字太大无法消去的问题。

那么到底要多少次操作呢？

- 如果 $A_i=B_i$，数列不变，结果不变。

- 如果 $A_i<B_i$，进行 $B_i-A_i$ 次操作，每次加 $1$。

- 如果 $A_i<B_i$，进行 $B_i-A_i$ 次操作，每次加 $-1$，前面的加一因奇偶性不变，所以不必考虑。

最终答案为 $\sum\limits_{i=1}^nA_i-B_i$，最终取模于 $2$。但是考虑可能有过多 $A_i<B_i$ 的情况，而 C++ 的取模可能有负数，所以结果最好是 $\sum\limits_{i=1}^n|A_i-B_i|$，对结果并无影响。

### 最终代码

有几点要注意：

- 要开 long long。

- 使用快读

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}//快读模板
int n, t, ans;
signed main() {
	t = read();
	while (t--) {
		n = read(); ans = 0;
		for (register int i = 1, a, b; i <= n; i++) {
			a = read(); b = read();
			ans = (ans + abs(a - b)) % 2;//随时除以 2，保证不超过 long long 范围
		}
		putchar(ans + '0');
		putchar('\n');//快速输出
	}
	return 0;
}
```



---

## 作者：Defy_HeavenS (赞：0)

题意：要使数列 $a$ 经过若干操作变为数列 $b$。每次选定一个区间，把它加上序列 $\digamma$，把这些区间的长度加起来，最后输出和的奇偶。

观察序列 $\digamma$，可以发现每次修改一个数只能 $+1$ 或 $-1$。比如：

```
a:1

b:3

那么就要操作2次
```

所以计算出操作前后序列元素和的差，对 $2$ 取模输出即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
#include<queue>
#include<vector>
#include<map>
//#include<Windows.h>
using namespace std;
inline long long rd(){		//快读，不会可以用 cin
    long long x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-f;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
long long T=rd(),n,a[100005],b[100005],s;
int main(){
	while(T--){
		s=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			a[i]=rd();
		}
		for(int i=1;i<=n;i++){
			b[i]=rd();
			s+=abs(b[i]-a[i]);
		}
		if(s&1){		//等价于s%2==1 
			putchar('1');
			putchar('\n');
		}else{
			putchar('0');
			putchar('\n');
		}
		
	}
	return 0;
}

```


---

## 作者：VitrelosTia (赞：0)

题意比较复杂，其实做法很简单啊。思考要使 $a$ 变化到 $b$，如果 $a_i$ 和 $b_i$ 的值不相等，那么肯定要花费 $a_i-b_i$ 的步数来使他们相等，对答案的贡献必然加 $1$，于是稍作推导后知：把 $a$ 和 $b$ 的相同位的数做差并累加，最后依题意模 $2$ 的绝对值即是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve(){
    int n,x,a[200005],sum=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        sum+=x-a[i];
    }
    cout<<abs(sum%2)<<'\n';
}

int main(){
    int _;
    scanf("%d",&_);
    while(_--) solve();
}
```

---


# [COCI 2022/2023 #2] Tramvaji

## 题目描述

Patrik 和 Josip 在坐电车。他们共坐了 $n$ 站。

除了上车的那一站，其他每一站到站时，都会发生以下事件中的一种：

- Patrik 说：从上车到现在经过了 $t$ 分钟。

- Josip 说：从第 $y$ 站到这里花费了 $t$ 分钟。

现在，请你根据这些信息，求出哪两个站之间所需要的时间最短，以及这个时间。

## 说明/提示

**本题采用捆绑测试。**

|$\text{Subtask}$|分数|特殊性质|
|:-:|:-:|:-:|
|$1$|$12$|$t_i \le 1000$ |
|$2$|$13$|只有 $\texttt{Patrik}$ 事件 |
|$3$|$25$|无|

**本题满分 $50$ 分。**

## 样例 #1

### 输入

```
4
Patrik 3
Patrik 5
Josip 1 7```

### 输出

```
2 2 3```

## 样例 #2

### 输入

```
2
Josip 1 5```

### 输出

```
5 1 2```

## 样例 #3

### 输入

```
5
Patrik 4
Josip 2 4
Josip 2 6
Josip 4 2```

### 输出

```
2 3 4```

# 题解

## 作者：zhouweixi0 (赞：6)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/P9735)

这是一道模拟题。

会发生两种事件：

- Patrik 事件 第 $i$ 个车站花费的时间为 $t$。

- Josip 事件 从第 $y$ 个车站到这里花费的时间为 $t$。

我们定义一个数组 $a$，$a_i$ 表示第 $i$ 个车站所花费的时间。

若发生 Patrik 事件，就将所花费的时间赋值给 $a_i$。

若发生 Josip 事件，就将 $a_i$ 赋值为 $a_y+t$。

最后，将数组中两个相邻车站之间距离最小的找出，记录下表，并输出即可。

## 代码

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,y,a[1010];
int minn=2147483647,ans;
string s;
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){//记得从2开始
        cin>>s;
        if(s=="Patrik"){
            cin>>t;
            a[i]=t;
        }
        else{
            cin>>y>>t;
            a[i]=a[y]+t;
        }
    }
    for(int i=2;i<=n;i++){//取最小值
        if(a[i]-a[i-1]<minn){
            minn=a[i]-a[i-1];
            ans=i;
        }
    }
    cout<<minn<<" "<<ans-1<<" "<<ans;//输出
    return 0;
}
~~~

---

## 作者：zyxxxxxxxxxx (赞：2)



## [题目传送门](https://www.luogu.com.cn/problem/P9735)



------------



### 题目分析
一道比较容易的模拟题。

题目要求输出字典序最小的解，由于解的最小值肯定是固定的，所以我们只需找到第一组得到最小值的解即可。

我们开一个数组 $t$ ，储存第i个站点距离起点的时间：

若操作为 **Patrik 说** 则 $t[i] =  t _i $


若操作为 **Josip 说** 则 $t[i] =  t _i  + t[y _i]$

最后我们遍历数组，取相邻两个站点的差即可。



------------
### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int t[1005];
int main(){
	cin>>n;
	int x,y;
	for(int i=2;i<=n;i++){
		cin>>s;
		if(s=="Patrik"){
			cin>>x;
			t[i]=x;
		}else{
			cin>>y>>x;
			t[i]=x+t[y];
		}
	}
	int ans=0,minn=1e9;
	for(int i=2;i<=n;i++){
		if(t[i]-t[i-1]<minn){
			ans=i-1;
			minn=t[i]-t[i-1];
		}
	}
	cout<<minn<<" "<<ans<<" "<<ans+1;
	return 0;
}
```

ps：希望可以通过审核，成为我第一篇题解


---

## 作者：Zaku (赞：2)

[Link.](https://www.luogu.com.cn/problem/P9735)

这是一道简单的模拟题。

$\mathrm{Sol:}$

我们可以分别计算出从 $1$ 号车站到 $i$ 号车站的总车程，存在数组 $s$ 中。

其中 $s_1$ 显然为 $0$，然后 $i$ 从 $2$ 开始计数。

- 如果是 Patrik，$s_i=t$。
- 如果是 Josip，$s_i=s_{y}+t$。

然后就可以计算从 $i$ 号车站到 $i+1$ 号车站的车程了：$s_{i + 1}-s_i$。打擂台同时记录车站编号即可。

$\mathrm{Code:}$
```cpp
#include <bits/stdc++.h>
using ll = long long;
using namespace std;
const int N = 1005;
int s[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 2; i <= n; i ++ ){
		string type;
		cin >> type;
		if (type[0] == 'P'){
			int t;
			cin >> t;
			s[i] = t;
		} else{
			int y, t;
			cin >> y >> t;
			s[i] = s[y] + t;
		}
	}
	int ans1 = 1e9, ans2;
	for (int i = 2; i <= n; i ++ ){
		if (s[i] - s[i - 1] < ans1)
			ans1 = s[i] - s[i - 1], ans2 = i - 1;
	}
	cout << ans1 << ' ' << ans2 << ' ' << ans2 + 1;
	return 0;
}
```

---

## 作者：Mingci (赞：2)

# P9735 [COCI2022-2023#2] Tramvaji
[题目传送门](https://www.luogu.com.cn/problem/P9735)
## 题目大意：
有 $n$ 个电车站有两个人分别是 Patrik 和 Josip 会给出 $n-1$ 句话，每一个人有自己描述该站点距离的方式，即：
- Patrik 说：从上车到现在经过了 $t$ 分钟。
- Josip 说：从第 $y$ 站到这里花费了 $t$ 分钟。

现在题目要求距离最近的两个车站的距离和这两个车站，如果有相同的，就输出字典序最小的那对解，其实就是最靠前的那两个站点。
## 题目分析：
我们可以开一个 $s$ 数组维护每个站点离起点的距离，对于每一个 Patrik 操作，令 $s_i$ 等于 $t$，对于每一个 Josip 操作，令 $s_i$ 等于 $s_y$ 加上 $t$，就是这么简单，话不多说，上代码。
## 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
int s[10005];//s数组
signed main(){
	cin >> n;
	int t,y;
	for(int i = 2;i <= n;i++){
		string op;
		cin >> op;
		if(op=="Patrik"){
			cin >> t;
			s[i]=t;
		}
		else{
			cin >> y >> t;
			s[i]=s[y]+t;
		}
	}
	int minn=0x7fffffff,where;//minn取最小，要开的足够大
	for(int i = 2;i <= n;i++){
		if(minn>(s[i]-s[i-1])){
			minn=(s[i]-s[i-1]);
			where=i;//在整个区间之内取最小的相邻两个车站
		}
	}
	cout << minn << " " << where-1 << " " << where;
	return 0;
}

```


---

## 作者：Not_defined (赞：1)

### Solution
模拟即可。建立一个类似前缀和的数组，第一种操作即是第 $1$ 项到第 $i+1$ 项的和，第二种操作是第 $t$ 项到第 $i+1$ 项。最后对相邻两个站点做差取最小即可。
### Code
```
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,a[N],minn=1e9,posx,posy;
string s;
int main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int y,t;
		cin>>s;
		if(s=="Patrik")
		{
			cin>>t;
			a[i]=t;
		}
		else
		{
			cin>>y>>t;
			a[i]=a[y]+t;
		}
	}
	for(int i=2;i<=n;i++)
	{
		if(a[i]-a[i-1]<minn)
		{
			minn=a[i]-a[i-1];
			posx=i-1,posy=i;
		}
	}
	cout<<minn<<" "<<posx<<" "<<posy;
	return 0;
}
```


---

## 作者：GoodLuckCat (赞：1)

[题目在这](https://www.luogu.com.cn/problem/P9735)

题目意思就不多说了，应该可以理解。

具体思路就是开一个数组，存的是从起点到这一站的时间。

如果 Patrik 说话，那么直接存。如果 Josip 说话，那么要减去之前那一站存的数据。

然后最后一个一个比较，最后输出就可以了。

被坑了一次，最后循环是从 $2$ 开始不是从 $1$ 开始。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[1500];
int main()
{
    int t,m=20231009,p;
    cin>>t;
    for(int i=2;i<=t;i++)
    {
        string a;
        cin>>a;
        if(a=="Patrik")
        {
            int x;
            cin>>x;
            s[i]=x;
        }
        else
        {
             int x,y;
             cin>>x>>y;
             s[i]=s[x]+y;
        }
    }
    for(int i=2;i<=t;i++)if(s[i]-s[i-1]<m){m=s[i]-s[i-1];p=i;}
    cout<<m<<' '<<p-1<<' '<<p;
}
```

---

## 作者：splendore (赞：1)

### 思路

思路很简单，维护起点至每个车站的距离即可，

这里给出一份实现。

~~压行勿怪。~~

代码如下：
```
#include<cstdio>
using namespace std;
constexpr int N=1005;
char s[10];
int a[N];
int main(){
	int n,ans=0x3f3f3f3f,t=0;scanf("%d",&n);
	for(int i=2,x,y;i<=n;++i){
		scanf("%s%d",s,&x);
		if(s[0]=='P')a[i]=x;
		else scanf("%d",&y),a[i]=a[x]+y;
		if(ans>a[i]-a[i-1])ans=a[i]-a[i-1],t=i;
	}
	printf("%d %d %d\n",ans,t-1,t);
	return 0;
}
```

---

## 作者：lichenzhen (赞：0)

## 题面
题目描述非常简洁，无需概括，请自行查看。

[传送门](https://www.luogu.com.cn/problem/P9735)

## 题目解法
这是一道比较简单的模拟题，我们可以用桶思想解决这个问题。

定义一个桶的数组，对于下标为 $i$ 的桶，就存储从上车那一站到第 $i$ 站经过的时间。

对于 $2$ 个不同的事件，所需要的存储操作不同。

+ 对于 `Patrik` 所说的，我们直接按照下标存储 $y$ 值即可。
+ 对于 `Josip` 所说的，就需要把第 $y$ 站存储的时间加上 $t$，就是从上车那一站到当前车站的时间了。

最后再扫描一遍桶的内容（打擂台法），找相邻两个桶之差最小值就是两个站之间所需要的最短时间，记录一下这个值和下标。

当然，有一个小细节，因为**如果有多组解，输出字典序最小的那一组**，也就是车站的编号越靠前越好，所以存储编号时候只有比当前值小才更新变量的值。

### 参考代码
```cpp
#include<iostream>
using namespace std;
string s;
int n,t,y,book[1010];
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>s;
		if(s=="Patrik"){
			cin>>t;
			book[i]=t;
		}
		else{
			cin>>y>>t;
			book[i]=book[y]+t;
		}
	}
	int d=114514191,x1,x2;
	for(int i=2;i<=n;i++){
		if(d>book[i]-book[i-1]){
			x1=i-1,x2=i;
			d=book[i]-book[i-1];
		}
	}
	cout<<d<<" "<<x1<<" "<<x2;
}
```


---

## 作者：lovely_hyzhuo (赞：0)

对于第一种操作，即 Patrik 说的话，直接令 $a_i=x$。

对于第二种操作，即 Josip 说的话，令 $a_i=a_y+x$。

然后暴力遍历每一个 $a_i$ 与 $a_{i-1}$ 的差，即 $a_i-a_{i-1}$。取最小值就行啦。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010];
int main()
{
	int n;
	cin>>n;
	int minn=1145141919,mini=0;
	for(int i=2;i<=n;i++)
	{
		string op;
		cin>>op;
		if(op[0]=='P')
		{
			int x;
			cin>>x;
			a[i]=x;
		}
		else
		{
			int x,y;
			cin>>x>>y;
			a[i]=a[x]+y;
		}
	}
	for(int i=2;i<=n;i++)
		if(a[i]-a[i-1]<minn)
			minn=a[i]-a[i-1],mini=i;
	cout<<minn<<" "<<mini-1<<" "<<mini;
	return 0;
}
```


---

## 作者：xiaolu12356 (赞：0)

[[COCI2022-2023#2] Tramvaji](https://www.luogu.com.cn/problem/P9735)


## 题意

除了第一个车站，其他车站都会有如下事件：

从上车到现在经过了 $t$ 分钟。

从第 $y$ 个车站到这里经过了 $t$ 分钟。

（摘自 Yun_Mengxi dalao 的题解）

## 题解

这是一道**模拟**和**前缀和**题。

我们需要处理**两**个事件：

1. 从第 $1$ 个车站到第 $i+1$ 个车站的时间。
2. 从第 $y$ 个车站到第 $i+1$ 个车站的时间。

最后我们对相邻两个车站的差取最小值即可。

## 坑点

这道题没有太多坑点。但要注意的是：

输入**共 $n$ 行**，也就是说，后面输入一共要 $n-1$ 行。


## 代码

```cpp
#include<iostream>
using namespace std;
int a[10005];
int main(){
    int n;
    cin>>n;
    for(int i=2;i<=n;i++){
        string t;
        int x;
        cin>>t>>x;
        if(t=="Patrik"){ a[i]=x; }
        else{
            int y;
            cin>>y;
            a[i]=a[x]+y;
        }
    }
    int min=0x7fffffff,minn=1;
    for(int i=2;i<=n;i++) {
        if(a[i]-a[i-1]<min){
            min=a[i]-a[i-1];
            minn=i;
        }
    }
    cout<<min<<" "<<minn-1<<" "<<minn;
    return 0;
}
```

---

## 作者：Yun_Mengxi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9735)

## 题意

有 $n$ 个车站，除了第一个车站，其他车站都会有如下事件：

1. 从上车到现在经过了 $t$ 分钟。

2. 从第 $y$ 个车站到这里经过了 $t$ 分钟。

求哪两个站之间所需要的时间最短。

## 分析

可以使用前缀和。

设当前车站为 $i$，将上车到现在经过了 $t$ 分钟看成 $sum_i - sum_1$ 的值，从第 $y$ 个车站到这里经过 $t$ 分钟看成 $sum_i - sum_y$ 的值，随后查询每两个车站之间的前缀和差就行了。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
string op;
int t, y;
int s[1005];
int minn = 0x7fffffff, mini;

int main() {
  cin >> n;
  s[1] = 0;
  for (int i = 2; i <= n; i++) {
    cin >> op >> t;
    if (op[0] == 'P') {
      s[i] = t;
    } else {
      cin >> y;
      s[i] = s[t] + y;
    
  }
  for (int i = 2; i <= n; i++) {
    if (s[i] - s[i - 1] < minn) {
      minn = s[i] - s[i - 1];
      mini = i;
    }
  }
  cout << minn << ' ' << mini - 1 << ' ' << mini << '\n';
  return 0;
}
```

---


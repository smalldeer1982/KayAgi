# 「HCOI-R1」报名人数

## 题目背景

在一个电子展牌上，对于十进制数 $P$，从右到左，从 $P$ 的低位到高位，我们对每一位按照如下的方式进行显示：

![](https://cdn.luogu.com.cn/upload/image_hosting/taibn0fi.png)

所以，对于数位分别取 $0\sim 9$，该数位对应所用的短竖线数量分别是 $6, 2, 5, 5, 4, 5, 6, 3, 7, 6$。

## 题目描述

小 R 的家中有一个大型的电子展牌，上面记录着 HCOI-R1 的报名人数。

在小 R 布置完成的时候，HCOI-R1 的报名人数为 $l$。而现在，HCOI-R1 最终的报名人数为 $r$。

小 R 觉得这样的整数数对 $(i, j)$ 是**幸运**的，当且仅当在报名过程中，存在人数为 $i, i + 1, \dots, j$ 的时刻（也即 $l \leq i \leq j \leq r$），且在 **不含前导 $\bm 0$** 的情况下，表示 $i, i + 1 \dots j$ 这些数字所用的短竖线数量相同。

小 R 想知道，对于所有的幸运数对 $(i, j)$，其中 $j - i + 1$，也即数字个数——最大为多少。

## 说明/提示

### 样例解释 1

存在幸运数对 $(2, 3)$，表示它们均需要 $5$ 条短竖线。

### 数据规模与约定

**本题采用捆绑测试。**

+ Subtask 0（19 pts）：$r \leq 10^3$。
+ Subtask 1（33 pts）：$r \leq 10^6$。
+ Subtask 2（48 pts）：无特殊限制。

对于所有数据，保证 $1 \leq l \leq r \leq 10^{18}$。

## 样例 #1

### 输入

```
2 5```

### 输出

```
2```

## 样例 #2

### 输入

```
114514 114514```

### 输出

```
1```

# 题解

## 作者：__zhuruirong__ (赞：27)

[题目传送门](https://www.luogu.com.cn/problem/P10024)

## 题目大意

给你一个区间 $[l,r]$，要求找出长度最大的整数区间，使得对于区间内的所有数字，在电子显示屏上所使用的短竖线数量相等。

**注意：短竖线包括横向的线。**

## 题目分析

由于 $l$ 和 $r$ 的范围很大，暴力枚举显然不可取，考虑找规律。

先分两种情况讨论。

1. 对于一个整数 $x$，要是 $x+1$ 不进位，唯一一种合法情况是 $x$ 的个位是 $2$，否则不满足条件。

2. 对于一个整数 $x$，要是 $x+1$ 进位，个位上的和不变（$0$ 和 $9$ 使用的短竖线数量相同），则第一个非 $9$ 的位置上的值 $+1$ 也必须不变，唯一满足条件的的值只有 $2$，如 $29$、$299$，它们 $+1$ 后使用的短竖线数量不变。


根据上面的两种情况，可以发现答案只可能是 $1$ 和 $2$。而答案怎么判断是哪一种呢？

其实可以设一个整数 $n$，把 $l$ 的后 $n$ 位替换成 $9$，第 $n+1$ 位替换成 $2$就可以了。但是，这样求出来的值可能小于 $l$，会导致答案错误，所以说需要改进。

我们记 $x$ 为把 $l$ 的后 $n$ 位替换成 $9$，第 $n+1$ 位替换成 $2$ 的值，再记一个 $y$ 是 $x+10^{n+1}$，就可以保证 $y$ 一定大于 $l$ 了，因为替换后最多会省去 $10^{n+1}-1$。只要 $x$ 和 $y$ 有一个在 $[l,r)$ 这个区间内，答案就为 $2$，否则为 $1$。

## AC代码

```cpp
#include <bits/stdc++.h> 
#define int long long
using namespace std;

int l, r;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0); 
	cin >> l >> r;
	int cnt1 = l, cnt2 = l + 1;
	for(int i = 0, mul = 10; cnt1 <= r; i++, mul *= 10) {
		cnt1 = l / mul * mul + mul / 10 * 3 - 1;
		cnt2 = cnt1 + mul;
		if((cnt1 >= l and cnt1 < r) or (cnt2 >= l and cnt2 < r)) {
			cout << 2 << endl;
			return 0;
		}
	}
	cout << 1 << endl;

	return 0;
}

```

---

## 作者：Lovely_Elaina (赞：6)

题目可以抽象为每个数字都有一个贡献值。

每个整数的价值为每位数字贡献值的和。

问题为对于 $[l,r]$ 的任意一个子区间，如果每个数字的价值相同那么这个子区间为幸运的，求所有幸运的子区间的长度。

易得出：

1. 推论一：在除个位都相同的情况下，只有个位为 $2$ 和 $3$ 的相邻数字相同；

2. 推论二：个位不相同时，有可能有相邻的 `xx9` 和 `xx0` 价值相同；

3. 推论三：至少存在一个长度为 $1$ 的幸运子区间。

那么写个函数直接爆搜，有推论一的情况直接输出结束。

如果没有推论一的情况，那么 $[l,r]$ 必定很小，不必担心时间复杂度，直接暴力比较就行。

如果最后还是没有，输出 $1$。

需要注意的是要用 long long。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int t[14] = {6,2,5,5,4,5,6,3,7,6};

int l,r;

inline int get(int x){
    int res = 0;
    while(x){
        res += t[x%10];
        x /= 10;
    }
    return res;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(NULL);
    
    cin >> l >> r;

    for(int i = l+1; i <= r; i++){
        if(i % 10 == 3){
            cout << 2;
            return 0;
        }

        if(get(i-1) == get(i)){
            cout << 2;
            return 0;
        }
    }

    cout << 1;
    return 0;
}
```

---

## 作者：lovely_hyzhuo (赞：4)

首先，我们打一个暴力出来。

就是从 $l$ 到 $r$ 依次枚举算出每个数字的数字和，同时记录上一个数的数字和，判断累加即可。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={6,2,5,5,4,5,6,3,7,6};
int tnum[1000010];
int  main()
{
	int l,r;
	cin>>l>>r;
	int ans=1,sum=1;
	for(int i=l;i<=r;i++)
	{
		int g=i;
		while(g)
		{
			int t=g%10;
			g/=10;
			tnum[i]+=a[t];
		}
		if(i==l)
			continue;
		if(tnum[i]!=tnum[i-1])
		{
			ans=max(ans,sum);
			sum=1;
		}
		else
			sum++;
	}
	cout<<max(ans,sum);
	return 0;
}
```

这样就有 $52$ 分的好成绩。

然后，根据观察可以发现，如果想让连续的两个数字相等，只可能是连续的二和三，或是进位的零和九（九进位），当且仅当此时十位为二和三（进位前和后）。

不妨大胆乱搞，最多只跑十次，算出此时的最大连续数，即可 AC。

关于最多只有两个数的说明。

显然，当十位，百位及以上数位均相同时，个位的火柴棍数一样才可能继续，而个位相同只有如上情况。

故最多只有连续的两个数可满足题目要求。

最终代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[10]={6,2,5,5,4,5,6,3,7,6};
int tnum[30];
signed  main()
{
	int l,r;
	cin>>l>>r;
	int ans=1,sum=1;
	for(int i=l;i<=min(r,l+10);i++)
	{
		int g=i;
		while(g)
		{
			int t=g%10;
			g/=10;
			tnum[i-l]+=a[t];
		}
		if(i==l)
			continue;
		if(tnum[i-l]!=tnum[i-1-l])
		{
			ans=max(ans,sum);
			sum=1;
		}
		else
			sum++;
	}
	cout<<max(ans,sum);
	return 0;
}
```


---

## 作者：saixingzhe (赞：3)

# 思路
我们先把每个数字对应需要多少根竖线写出来，如下：
```cpp
int a[]={6,2,5,5,4,5,6,3,7,6};
```

我们可以发现不存在两组以上是连续数字且需求竖线数量相等。

因此，最多只能有 $2$ 个连续的数字符合要求。

我们只需要发现有两个连续的数字符合要求就输出 `2` 即可。

本题需要开 `long long`。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,a[]={6,2,5,5,4,5,6,3,7,6};
int sum(long long n){//求每个数字需要的竖线数量
	long long ans=0;
	if(n==0)	return 6;
	while(n){
		ans+=a[n%10];
		n/=10;
	} 
	return ans;
}
int main(){
	scanf("%lld%lld",&l,&r);
	for(long long i=l;i<r;i++){
		if(sum(i)==sum(i+1)){
			printf("2");
			return 0;
		}	
	}
	printf("1");
	return 0;
}
```

# 补充

还有一种做法，赛时看到很多人用，我们发现当 $r-l \geq 10$ 时一定有 $2$ 种解法，输出 `2`。

如果不放心可以开到 $r-l \geq 10^7$。

---

## 作者：CNS_5t0_0r2 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10024)

分析：

不难发现，$j - i + 1$ 的最大值为 $2$。

在不进位下，只有个位从 $2$ 变成 $3$ 所需的短竖线不变。

这点就解释了答案最大为 $2$。假设有 $3$ 个连续的数，那么其中肯定存在相邻 $2$ 个数不进位，并且这相邻的 $2$ 个数末尾肯定不存在 $3$。

在进位下，可以发现 $9$ 和 $0$ 所需的短竖线个数是不变的。

假设末尾有 $k$ 个 $9$，那么这个数加 $1$ 末尾也即有 $k$ 个 $0$，所以只需保证第 $k + 1$ 位所需的短竖线数量不变即可。由上面的条件，从右往左第 $k + 1$ 位应为 $2$。

所以我们判断当前的 $l,r$，得到两个新数 $L,R$。其中 $L$ 为大于 $l$ 中末尾为 $2$ 的最小者，$R$ 为小于 $r$ 中末尾为 $3$ 的最大者。

答案为 $2$，当且仅当 $L < R$。如果满足，直接输出并退出程序。

否则，弹出 $l,r$ 的个位，继续判断，直到其中一个（肯定为较小者，即 $l$）变为 $0$。答案即为 $1$（单个数肯定满足）。

在这里，我们一开始设 $L = l,R = r$，然后不断让 $L$ 加 $1$，直到 $L$ 的个位为 $2$，再不断让 $R$ 减 $1$，直到 $R$ 的个位为 $3$。

这种做法只会枚举不超过 $10$ 次，因为连续的 $10$ 个数中肯定有一个个位为 $2$ 或 $3$（实际上不超过 $9$ 次，因为如果个位一开始就满足，就会立刻退出循环），所以复杂度是 $O(1)$ 的。

所以总的复杂度与 $l$ 的位数有关，即 $O(\log l)$。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int l,r;
signed main(){
	cin >> l >> r;
	while(l){
		int L = l,R = r;
		/*暴力求L,R*/
		while(L % 10 != 2){
		    if(L > r)//如果L > r，那么肯定 L > R，肯定不满足，直接退出循环 
		        break;
			L++;
		}
		while(R % 10 != 3){
			if(R < l)//如果R < l，那么肯定 L > R，肯定不满足，直接退出循环 
				break;
			R--;
		}
		if(L < R){
			cout << 2;
			return 0;
		}
		/*弹出最后一位*/
		l /= 10;
		r /= 10;
	}
	cout << 1;
	return 0;
}
```


---

## 作者：Xiphi (赞：1)

### P10024

打一个表，我打了 $[1,10^8]$ 的表，发现连续的最多不会超过 $2$ 个，只有在进位和个位为 $2,3$ 时才会相等，然后就没了，代码用的是比较简单的写法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int l,r,c[]={6,2,5,5,4,5,6,3,7,6};
int cnt(int x){
	int sum=0,t=x;
	while(t){
		sum+=c[t%10];
		t/=10;
	}
	return sum;
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>l>>r;
	if(r-l+1<=1000000){
		int Max=1,Cnt=1;
		for(int i=l+1;i<=r;++i){
			if(cnt(i)==cnt(i-1)) Cnt++;
			else Max=max(Cnt,Max),Cnt=1;
		}
		cout<<Max;
	}else{
		cout<<2<<'\n';
	}
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10024)。

## 思路

观察数列 $\{6,2,5,5,4,5,6,3,7,6\}$，我们很容易发现在这个数列中最多只有 $2$ 个相邻的数是相同的，那么我们就有结论：幸运数对 $(i,j)$ 的权值 $j-i+1$ 只能为 $1$ 或 $2$。

接下来我们设置一个阈值，区间长度大于这个阈值，那么答案就是 $2$，否则我们在范围内暴力查找答案。

这里有 $10$ 个数字，所以我们设置阈值为 $10$，当然更大也可以。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll l,r,f[]={6,2,5,5,4,5,6,3,7,6};

int main(){
	scanf("%lld%lld",&l,&r);
	if(r-l>=10) cout<<2;
	else{
		ll ans=1;
		for(ll i=l,lst=0;i<=r;i++){
			ll x=i,j=0;
			while(x){
				j+=f[x%10];
				x/=10;
			}
			if(lst==j) ans=2;
			lst=j;
			
		}
		cout<<ans;
	}
	return 0;
}



```




---

## 作者：_fallen_leaves_ (赞：0)

题目：[P10024 「HCOI-R1」报名人数](https://www.luogu.com.cn/problem/P10024)

## 思路
相邻三个数所用的短竖线数量，肯定不一样，所以我们只用看相邻两位的短竖线数量是不是一样就行了，我们用一个数组来保存每个数字用的短竖线数量，我们可以把相邻两个数给每一位拆开，再用每一位用的短竖线数量相加，就可就出这个数用了多少短竖线数量，在相邻两个数作比较，如果一样输出 $2$，否则循环到最后输出 $1$。

贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int c[20]={6,2,5,5,4,5,6,3,7,6};//来保存每个数字用的短竖线数量
int main()
{
    long long a,b;//十年oi一场空，不开long long见祖宗 
    cin>>a>>b;
    for(long long i=a;i<b;i++)//比较相邻两个，所以要小于b，而不是小于等于b 
    {
    	long long x=i,y=i+1,sum=0,sum2=0;
    	while(x)//算出第一个数用的短竖线数量 
    	{
    		sum+=c[x%10];
    		x/=10;
		}
		while(y)//算出第二个数用的短竖线数量 
		{
			sum2+=c[y%10];
			y/=10;
		}
		cout<<sum<<" "<<sum2<<endl;
		if(sum==sum2)//如果一样输出2，直接退出 
		{
			cout<<2;
			return 0;
		}
	}
	cout<<1;//最后直接输出1 
    return 0;
}
```

---

## 作者：Vct14 (赞：0)

我们可以发现，$2,3$ 和 $9,0$ 这两对数字所用的短竖线数量相同。因此答案最大为 $2$，即当一个数 $x$ 末尾为 $299\cdots9$（设 $9$ 的个数为 $k$，则 $k\geqslant0$）时，$x+1=300\cdots0$（$k$ 个 $0$）与 $x$ 所用的短竖线数量相同。

所以暴力判断相邻两数所用的短竖线数量是否相同即可。

有一处可以进行优化：当 $k>10$ 时，一定有末尾为 $2,3$ 的数连续出现，答案为 $2$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define L long long

L num[10]={6,2,5,5,4,5,6,3,7,6};

L Tonum(L x){
	L sum=0;
	while(x){
	    sum+=num[x%10];
	    x/=10;
	} 
	return sum;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    L l,r;
	cin>>l>>r;
	if(r-l+1>10){
	    cout<<2;
	    return 0;
	}
	for(L i=l+1; i<=r; i++){
	    if(Tonum(i)==Tonum(i-1)){
	        cout<<2;
	        return 0;
	    }
	} 
	cout<<1;
	return 0;
}
```

---


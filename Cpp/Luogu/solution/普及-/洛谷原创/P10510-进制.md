# 进制

## 题目背景

为了提供更加良好的区分度，相较于蓝桥杯国赛，本场比赛的所有程序设计题添加了额外样例，请在附件处下载。

其中，后缀名为 $\bf{.in}$ 的文件为输入文件，$\bf{.out}$ 的文件为输出文件。您可以使用这些额外样例检验自己的程序正确性。但我们不保证通过额外样例一定能取得您期望的分数。

此外，我们提供了相较蓝桥杯国赛更多档的部分分，以确保分数分布更为科学合理。

## 题目描述

小洛正在学习三进制。他定义三进制数为每一位只包括 $0,1,2$ 三种数的**无穷长的**数字串 $a$。

与一般的三进制数不同的是，小洛的三进制数从左往右书写。例如，在常规表述下，$4$ 的三进制表示为 $(0000\ 0011)_3$，而在小洛的三进制数表示下为 $(1100\ 0000 \cdots)_3$。

小洛特别喜欢从 $0$ 开始计数，因此他规定三进制的第 $0$ 位为最左侧的那一数位。

下表给出了小洛的三进制数表示下，数字 $37$ 的最低的 $8$ 位数位以及位权：

| 三进制数表示 | $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 位数 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |
| 位权 | $3^0$ | $3^1$ | $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ | $3^7$ |

现在小洛有一个十进制正整数 $V$（显然，需要将其转化为小洛的三进制数表示），并且给定三种操作：

- 操作一，将第 $i$ 位上的数进行操作：$0$ 变为 $1$，$1$ 变为 $2$，$2$ 变为 $0$。
- 操作二，将第 $i$ 位上的数进行操作：$0$ 变为 $2$，$1$ 变为 $0$，$2$ 变为 $1$。
- 操作三，将第 $i$ 位上的数进行操作：$1$ 变为 $2$，$2$ 变为 $1$，$0$ 不变。

小洛一共要进行 $q$ 次操作。每次操作后，小洛需要得到三进制串代表的数值。请你告诉他。

如果对题意有不清晰之处，请查看样例解释。

## 说明/提示

**【样例解释】**

初始时，$V=4$，转化为小洛的三进制数为 $\texttt{1100 0000} \cdots$，接下来进行了 $3$ 次操作：

- 将第 $1$ 位上的数位从 $1$ 变为 $2$，三进制数变为 $\texttt{1200 0000} \cdots$，十进制下为 $7$。
- 将第 $0$ 位上的数位从 $1$ 变为 $0$，三进制数变为 $\texttt{0200 0000} \cdots$，十进制下为 $6$。
- 将第 $2$ 位上的数位从 $0$ 变为 $1$，三进制数变为 $\texttt{0210 0000} \cdots$，十进制下为 $15$。

**【数据范围】**

- 对于 $30\%$ 的数据，保证 $V\leq 10^9$。
- 对于另外 $30\%$ 的数据，保证不含操作三。

对于所有数据，保证 $0\leq V\leq 10^{18}$，$1\leq q\leq 10^5$，任意获取到的答案不超过 $2\times 10^{18}$。

## 样例 #1

### 输入

```
4 3
1 1
2 0
1 2```

### 输出

```
7
6
15
```

# 题解

## 作者：SilVeR__WolF (赞：8)

## 题目大意
给定十进制整数 $V$ 和 $Q$ 次操作，先将 $V$ 转化为 $3$ 进制数字串 $s$，再输出每次操作后 $s$ 对应的十进制整数的值。
## 前置知识
[如何实现进制转换](https://www.luogu.com.cn/problem/solution/B2143)
## 思路分析
对一个 $3$ 进制的数字串的其中一位做改变，就是将这一位上的基数改变，最终的改变值就是该位上的改变数量 $\times$ 该位上的位权。

这样做的时间复杂度为 $O(\log_{3}{V}+Q)$。

代码如下（详见注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int h[40],s[40],v,q,opt,i,ans;//经计算，log(3)1e18 大约在 40 左右，所以数组容量只用 40 
const int cs[4][3]={{},{1,2,0},{2,0,1},{0,2,1}};//打表，注意 opt 从 1 计数 
void cvs(int n,int k)//功能：将 n 转换成 3 进制并按低位到高位的顺序存进 h 数组
{
	if(n>=3){
		h[k]=n%3;
		cvs(n/3,k+1);
		return;
	}
	h[k]=n;
	return;
}
void init()//在 s 数组中存入 3 的次方。之前我用 pow 不行，有神犇知道为什么吗？ 
{
	s[0]=1;
	for(int p=1;p<40;p++)
		s[p]=s[p-1]*3;
}
signed main(){
	scanf("%lld%lld",&v,&q);
	cvs(v,0);init();ans=v;//给 ans 赋初值
	while(q--)
	{
		scanf("%lld%lld",&opt,&i);
		ans=ans+s[i]*(cs[opt][h[i]]-h[i]);//将 ans 加上第 i 位位权 * 改变数量 
		h[i]=cs[opt][h[i]];//做修改，因为之后可能还会对这位进行修改 
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：3)

按照题意模拟即可。

先把 $V$ 转换成 $3$ 进制，用数组记录。

接着 $q$ 次操作，就修改 $3$ 进制对应的位置。事实上，操作一和操作二都分别把原数加 $1$ 模 $3$ 以及加 $2$ 模 $3$。操作三是将原数用 $3$ 减，并模 $3$。

实际上，如果不想想太多，一个一个特判也没有问题。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[105],tot,T,n,m,op,x,qq=1,ans=0;
int main(){
	cin>>n>>T;m=n;
	while(m){
		a[tot++]=m%3;
		m/=3;
	}
	while(T--){
		ans=0;
		cin>>op>>x;
		if(op==1){
			a[x]=(a[x]+1)%3;
		}else if(op==2){
			a[x]=(a[x]+2)%3;
		}else if(op==3){
			a[x]=(3-a[x])%3;
		}
		for(int i=40;i>=0;i--) ans=ans*3+a[i];
		cout<<ans<<'\n';
	}
    return 0;
}

---

## 作者：Mortidesperatslav (赞：2)

这题数据确实比较弱，可以写的比较暴力，但是我场上闲来无事写了个 $O(q \log \log V)$ 的做法。其实比较接近于 $O(q)$ 了。当 $V = 2 \times 10 ^ {18}$ 时，$\log \log V$ 似乎大约是 $3$。

分为三步。

## 第一步：转三进制

这部分代码还是比较好写的，开个数组加上循环模拟就行了。

```cpp
void to3(int x){
	int cnt = -1;
	while (x){
		a[++cnt] = x % 3;
		x /= 3;
	}
}
```

这部分时间复杂度 $O(\log V)$。

## 第二步：快速幂

我们要算每一位代表的权值，那当然需要快速幂，我们需要快速求出 $3^k$。

```cpp
int qpow(int k){
	int ans = 1, x = 3;
	while (k){
		if (k & 1)
			ans *= x;
		x *= x;
		k >>= 1;
	}
	return ans;
}
```

## 第三步：处理询问

我们进行分类讨论就行了。

```cpp
while (q--){
		int op, i;
		cin >> op >> i;
		if (op == 1){
			if (a[i] != 2)
				x += qpow(i), a[i]++;
			else
				x -= 2 * qpow(i), a[i] = 0;
		}else if (op == 2){
			if (a[i] != 0)
				x -= qpow(i), a[i]--;
			else
				x += 2 * qpow(i), a[i] = 2;
		}else{
			if (a[i] == 1)
				x += qpow(i), a[i]++;
			else if (a[i] == 2)
				x -= qpow(i), a[i]--;
		}
		cout << x << "\n";
	}
```

但是，为什么是 $O(q \log \log V)$ 呢？

我们可以发现输入的 $i$ 是不超过 $\log V$ 的，而我们要求 $3^i$，那么快速幂的时间开销为 $\log i = \log \log V$。

## 第 $114514$ 步

还能更快吗？我们会发现，$q \log \log V$ 中的 $\log \log V$ 并不是一个很小的开销，我们会发现，把 $3$ 的幂预处理出来就好了。而这个预处理仅仅需要一个 $\log V$。

这样时间复杂度就变成了 $O(\log V + q)$。我也写了一份不错的优化之后的代码，但是洛谷上数据实在不太友好，我只能卡到 146ms，虽然勉强拿到了最优解，但是不是很理想。对于进一步优化，我只能说我无能为力。

## 正常的场上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x, q;
int a[100005];
int qpow(int k){
	int ans = 1, x = 3;
	while (k){
		if (k & 1)
			ans *= x;
		x *= x;
		k >>= 1;
	}
	return ans;
}
void to3(int x){
	int cnt = -1;
	while (x){
		a[++cnt] = x % 3;
		x /= 3;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> x >> q;
	to3(x);
	while (q--){
		int op, i;
		cin >> op >> i;
		if (op == 1){
			if (a[i] != 2)
				x += qpow(i), a[i]++;
			else
				x -= 2 * qpow(i), a[i] = 0;
		}else if (op == 2){
			if (a[i] != 0)
				x -= qpow(i), a[i]--;
			else
				x += 2 * qpow(i), a[i] = 2;
		}else{
			if (a[i] == 1)
				x += qpow(i), a[i]++;
			else if (a[i] == 2)
				x -= qpow(i), a[i]--;
		}
		cout << x << "\n";
	}
}
```

## 优化代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define BF_SIZE 100000
    bool IOerr=0;
    inline char nc(){
        static char buf[BF_SIZE],*p1=buf+BF_SIZE,*pend=buf+BF_SIZE;
        if(p1==pend){
            p1=buf;
            pend=buf+fread(buf,1,BF_SIZE,stdin);
            if(pend==p1){IOerr=1;return -1;}
        }
        return *p1++;
    }
    inline bool bla(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';}
    inline void read(int &x){
        register char ch;
        while(bla(ch=nc()));
        if(IOerr){return;}
        for(x=ch-'0';(ch=nc())>='0'&&ch<='9';x=x*10+ch-'0');
    }
    #undef BF_SIZE
inline void write(int x){
    register char F[200];
    register int tmp=x>0?x:-x;
    if(x<0)putchar('-');
    register int cnt=0;
    while(tmp>0)
    {
        F[cnt++]=tmp%10+'0';
        tmp/=10;
    }
    while(cnt>0)putchar(F[--cnt]);
}
inline int qpow(int k){
	int ans = 1, x = 3;
	while (k){
		(k & 1) && (ans *= x);
		x *= x;
		k >>= 1;
	}
	return ans;
}
signed main(){
    int x, xx, q, pw[41], a[41], cnt = -1;
	read(x);
	read(q);
	xx = x;
	while (xx){
		a[++cnt] = xx % 3;
		xx /= 3;
	}
	for (register int i = 0; i <= 40; i++)
	    pw[i] = qpow(i);
	while (q--){
		int op, i;
    	read(op);
    	read(i);
		if (op == 1)
			(a[i] != 2) ? (x += pw[i], a[i]++) : (x -= (pw[i] << 1), a[i] = 0);
		else if (op == 2)
			(a[i] != 0) ? (x -= pw[i], a[i]--) : (x += (pw[i] << 1), a[i] = 2);
		else{
			if (a[i] == 1)
				x += pw[i], a[i]++;
			else if (a[i] == 2)
				x -= pw[i], a[i]--;
		}
		write(x);
		putchar('\n');
	}
}
```

---

## 作者：Night_sea_64 (赞：2)

这里我们只需分开维护三进制数值数组 $a$ 和整个数 $V$ 即可。首先预处理 $3$ 的幂。

每到修改操作，可以根据 $a$ 中记录的数值知道现在应该变为多少，然后在 $V$ 中增加或减少 $3$ 的幂就可以得到操作后的数。

```cpp
#include<iostream>
using namespace std;
long long num;
int q,a[110];
long long power[110];
int main()
{
    cin>>num>>q;
    long long num2=num;
    for(int i=0;num2;i++)
    {
        a[i]=num2%3;
        num2/=3;
    }
    power[0]=1;
    for(int i=1;;i++)
    {
        power[i]=power[i-1]*3;
        if(power[i]>2e18)break;
    }
    while(q--)
    {
        int op,p;
        cin>>op>>p;
        if(op==1)
        {
            if(a[p]==2)a[p]=0,num-=2*power[p];
            else a[p]++,num+=power[p];
        }
        else if(op==2)
        {
            if(a[p]==0)a[p]=2,num+=2*power[p];
            else a[p]--,num-=power[p];
        }
        else
        {
            if(a[p]==1)a[p]=2,num+=power[p];
            else if(a[p]==2)a[p]=1,num-=power[p];
        }
        cout<<num<<endl;
    }
    return 0;
}
```

---

## 作者：__qkj__ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10510)
## 解题思路
直接模拟。

一开始先把数字转成三进制，方便以后操作。

再每次输入一个 $x$ 和 $y$：

- 当 $x=1$ 时，$a_y=(a_y+1)\bmod 3$；
- 当 $x=2$ 时，$a_y=(a_y+2)\bmod 3$；
- 当 $x=3$ 时，$a_y=(3-a_y)\bmod 3$。

再把数组转成十进制，最后输出即可。

**注意：不要用 `pow` 来转进制，要预处理！**
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[114514],t=-1;
int f[114514]={1},tt;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	while(n)a[++t]=n%3,n/=3;
	while(m--)
	{
		int x,y;
		cin>>x>>y;
		if(x==1)a[y]=(a[y]+1)%3;
		if(x==2)a[y]=(a[y]+2)%3;
		if(x==3)a[y]=(3-a[y])%3;
		int now=0;
		for(t=max(t,y);tt<t;tt++)f[tt+1]=f[tt]*3;
		for(int i=0;i<=t;i++)now+=a[i]*f[i];
		cout<<now<<'\n';
	}
	return 0;
}

```

---

## 作者：RyanLi (赞：1)

传送门：[P10510 进制](https://www.luogu.com.cn/problem/P10510)

更佳的阅读体验：[洛谷 P10510 题解](https://blog.ryanli.top/index.php/archives/54/)

---

**简要题意**：给定一个十进制正整数，将其转为三进制串后进行若干次操作，每次操作后输出当前三进制串对应的十进制数。

我们将给定十进制数 $V$ 转为三进制串，并用一个数组存储每一位的数，然后按题意执行每次操作即可。

每次操作结束后累加，将三进制串转为十进制数输出即可。

``` cpp
#include <iostream>
using namespace std;
using ll = long long;

const int N = 40;
ll v, ans, dig;
int q, op, x, a[N], cnt;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> v >> q;
    while (v) a[cnt++] = v % 3, v /= 3;
    while (q--) {
        ans = 0, dig = 1;
        cin >> op >> x;
        cnt = max(cnt, x + 1);
        if (op == 1) a[x] = (a[x] + 1) % 3;
        else if (op == 2) a[x] = (a[x] + 2) % 3;
        else a[x] = (3 - a[x]) % 3;
        for (int i = 0; i < cnt; ++i) ans += dig * a[i], dig *= 3;
        cout << ans << '\n';
    } return 0;
}
```

---

## 作者：_dbq_ (赞：1)

## 前言
还没有读题的同学可以点击[这里](https://www.luogu.com.cn/problem/P10510)先读题。

## 思路
根据进制转换的基本原理，将三进制的第 $i$ 位 $x$ 修改为 $y$，转换为十进制就是在原数的基础上增加 $(y-x)*3^i$。因此可以通过模拟完成此题。

还没有理解的同学可以翻到最后再次学习。

## 代码
```cpp
#include<iostream>
#include<iomanip>
#include<cmath>
#include<math.h>
#include<algorithm>
#define LL long long
#define ULL unsigned long long
#define cint const int 
using namespace std;
int a[100];
__int128 p[70];
int tot=0;
inline auto read(){
    auto x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(auto x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return ;
}
int main()
{
    #ifdef dbq
    freopen("P10510.in","r",stdin);
    freopen("P10510.out","w",stdout);
    #endif
    p[0]=1;
    for(int i=1;i<=50;i++)//预处理一遍3^i
    {
        p[i]=p[i-1]*3;
    }
    LL V,q;
    cin>>V>>q;
    LL v=V;
    while(v!=0)//转换成3进制，存下来
    {
        a[tot++]=v%3;
        v/=3;
    }
    while(q--)
    {
        cint op=read(),k=read();
        //以下没有看懂的同学请翻到文章最后
        if(op==1)
        {
            if(a[k]==2) V-=2*p[k],a[k]=0;
            else V+=p[k],a[k]++;
        }
        else if(op==2)
        {
            if(a[k]==0) V+=2*p[k],a[k]=2;
            else V-=p[k],a[k]--;
        }
        else
        {
            if(a[k]==1) V+=p[k],a[k]++;
            else if(a[k]==2) V-=p[k],a[k]--;
        }
        cout<<V<<endl;//输出
    }
    return 0;
}
```

## 转换原理
以题目中的 37 为例，见下方的表格。

| 位数 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 三进制表示 | $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ |
| 位权 | $3^0$ | $3^1$ | $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ | $3^7$ |

十进制下的 37 可以表示为：$1*3^0+0*3^1+1*3^2+1*3^3+0*3^4+0*3^5+0*3^6+0*3^7=37$，也就是将每一位的三进制表示与位权的乘积加在一起就是十进制的数。

如果将三进制数的第 **1** 位改成 **1**，见下方的表格。

| 位数 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 三进制表示 | $1$ | $\color{red}1$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ |
| 位权 | $3^0$ | $3^1$ | $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ | $3^7$ |

这样十进制下的这个数就变成了：$1*3^0+$ $\color{red}1*3^1$ $+1*3^2+1*3^3+0*3^4+0*3^5+0*3^6+0*3^7=40$，总结一下就变成了 $37+$ $\color{red}(1-0)*3^1$ $=37+3=40$。

所以，将三进制的第 $i$ 位 $x$ 修改为 $y$，转换为十进制就是在原数的基础上增加 $(y-x)*3^i$。

---

## 作者：Shadow_T (赞：1)

### 题目分析

考虑直接模拟。

先把 $V$ 转成三进制

对于三种操作我们分类讨论，然后按照题目规则替换三进制位，其中第 $t$ 位的权值为 $3^t$，比如说要把第 $t$ 位的 $0$ 改成 $2$，那么把 $V$ 增加 $2 \times 3^t$ 就可以了，其他变换也同理。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int Pow(int a,int b)
{
	if(b==1) return a;
	if(b==0) return 1;
	long long k1=Pow(a,b/2);
	long long k2=(k1*k1);
	if(b&1) k2=(k2*a);
	return k2;
}
signed main()
{
	int v,q;
	cin>>v>>q;
	string bin="";
	int V=v;
	while(V>0) bin+=(V%3+'0'),V/=3;
	for(int i=1;i<=100;i++) bin+='0';
	while(q--)
	{
		int op,t;
		cin>>op>>t;
		if(op==1)
		{
			switch(bin[t])
			{
				case '0':bin[t]='1',v+=Pow(3,t);break;
				case '1':bin[t]='2',v+=Pow(3,t);break;
				case '2':bin[t]='0',v-=2*Pow(3,t);break; 
			}
		}
		else if(op==2)
		{
			switch(bin[t])
			{
				case '0':bin[t]='2',v+=2*Pow(3,t);break;
				case '1':bin[t]='0',v-=Pow(3,t);break;
				case '2':bin[t]='1',v-=Pow(3,t);break; 
			}
		}
		else if(op==3)
		{
			switch(bin[t])
			{
				case '0':break;
				case '1':bin[t]='2',v+=Pow(3,t);break;
				case '2':bin[t]='1',v-=Pow(3,t);break; 
			}
		}
		cout<<v<<"\n";
	}
}
```

---

## 作者：cmask4869 (赞：0)

## 思路
先分析三种操作可以得到：
- 操作 1：$ (x+1) \bmod 3 $
- 操作 2：$ (x+2) \bmod 3 $
- 操作 3：$ 3-x $

然后只需要简单地进行进制转换，输出操作后的结果，记得开 long long。

## 部分程序
```cpp
if (op<=2) a[fx]=(op+a[fx])%3 ;
else a[fx]=(3-a[fx])%3 ;
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

## P10510

### Sol

首先，我们看转换进制。我们把 $V$ 每次 $\bmod\ 3$ 的数从第 $0$ 位开始存，然后记得每次除以 $3$。但我们的数组开多少呢？$3^{40} \approx 1.2 \times 10^{19}$，开 $40$ 即可。

接下来，我们来看看三种操作。直接几个判断就可以了。但是，我们还有另一种不用写怎么多 `if` 语句的方法。第一种 $1 \rightarrow 2$，$2 \rightarrow 3$，$3 \rightarrow 0$。不就是 $(a_i + 1) \bmod 3$ 吗？而第二种就是 $a_i - (a_i \bmod 2 + 1)$，第三种就是 $|a_i - 3| \bmod 3$。

### Code

进制转换：`for (; v; a[++ id] = v % 3, v /= 3);`

执行操作：

```cpp
cin >> q;
for (ll op, i; q; -- q) {
  cin >> op >> i;
  if (op == 1) {
    a[i] = (a[i] + 1) % 3;
  } else if (op == 2) {
    a[i] -= (a[i] % 2) + 1;
  } else {
    a[i] = abs(a[i] - 3) % 3;
  }
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

首先按照把 $v$ 要求拆成三进制数组 $a$。

代码如下：

```cpp
while(t)
	a[cnt++]=t%3,t/=3;
```

接下来我们同时维护 $v$ 和序列，每次操作对于 $a$ 相当于 单点修改。可以考虑把 `op` 处理掉变成 $a_i\gets a_i+k$ 的形式。

代码如下：

```cpp
if(op==1){
	c=1;
	if(a[i]==2)
		c=-2;
}
if(op==2){
	c=-1;
	if(a[i]==0)
		c=2;
}
if(op==3){
	c=0;
	if(a[i]==1)
		c=1;
	if(a[i]==2)
		c=-1;
}
```

代码中 `c` 是 $a_i$ 的变化量。

在数组中 $a_i\gets a_i+c$ 反应到 $v$ 就是 $v \gets v+c\times 3^i$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int v,k,t,op,i;
int a[1000],cnt;
int powd(int k){//快速幂
    int base=3,ans=1;
    while(k){
        if(k&1)
            ans*=base;
        base*=base,k>>=1;
    }
    return ans;
}
signed main(){
    ios::sync_with_stdio(0);
    cin>>v>>k;
    t=v;
    while(t)
        a[cnt++]=t%3,t/=3;
    while(k--){
        int c;
        cin>>op>>i;
        if(op==1){
            c=1;
            if(a[i]==2)
                c=-2;
        }
        if(op==2){
            c=-1;
            if(a[i]==0)
                c=2;
        }
        if(op==3){
            c=0;
            if(a[i]==1)
                c=1;
            if(a[i]==2)
                c=-1;
        }
        a[i]+=c;
        v+=c*powd(i);
        cout<<v<<'\n';
    }
    return 0;
}
```

---


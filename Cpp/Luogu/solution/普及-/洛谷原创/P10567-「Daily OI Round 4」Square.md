# 「Daily OI Round 4」Square

## 题目描述

小 A 给了你一个边长为 $n$ 的正方形网格，你需要把 $1 \sim n \times n$ 这些编号填入这个网格里面，满足每一行的编号加起来都是奇数，每一列的编号加起来都是偶数。

在填之前，你想知道是否有任何一种解法满足上述条件，如果可以，输出 `Yes`；否则，输出 `No`。

## 说明/提示

#### 【样例解释】

对于第一组样例，设 $A$ 表示正方形网格，则有 $A_{1,1}=1,A_{1,2}=2,A_{2,1}=3,A_{2,2}=4$ 的解法。

对于第二组样例，可以证明无解。

#### 【数据范围】
  
**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n \le$|
| :-----------: | :-------------:|:-----------: |
|$0$|$10$|$10$|
|$1$|$20$|$10^6$|
|$2$|$70$|$10^{18}$|

对于全部数据，保证：$1 \le n \le 10^{18}$。



## 样例 #1

### 输入

```
2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
755689```

### 输出

```
No```

# 题解

## 作者：_H17_ (赞：11)

如果想看赛时解法，从前往后看。如果想看正常解法，从后往前看。

注意是按照板块看而不是整体反过来……

## 赛事做法

赛时给了四组样例，其中偶数都成立，奇数都不成立，产生猜想。

## 题目分析

若 $n$ 为奇数，按照行来看奇数个奇数相加必是奇数，按照列来看奇数个偶数相加必是偶数，所以总数必须又是奇数又是偶数，矛盾。

若 $n$ 为偶数，可以进行构造（见下面【构造方法】）。


## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n;
signed main(){
    cin>>n;
    if(n&1)
        cout<<"No";
    else
        cout<<"Yes";
    return 0;
}
```

下面是构造代码（不支持 $n\le 10^{18}$，不保证代码能够在 1s 时间内运行完）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n;
	if(n&1){
		cout<<"-1";
		return 0;
	}
	if(n%4){
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				cout<<(i-1)*n+j<<" \n"[j==n];
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<n;j++)
			cout<<(i-1)*(n-1)+j<<' ';
		cout<<(n-1)*n+i<<'\n';
	}
	return 0;
}
```

## 构造方法

下文所述 $n$ 为偶数。

首先考虑按照 $\begin{bmatrix}
   1 & 2 &3 & 4 & \dots & n \\
   n+1 & n+2 & n+3 & n+4 & \dots & 2n\\
   \dots & \dots & \dots & \dots & \dots & \dots \\
   (n-1)\times n+1 & (n-1)\times n+2 & (n-1)\times n+3 & (n-1)\times n+4 & \dots & n^2\\
\end{bmatrix}$ 来构造。

然而 $n=4$ 时就不行了，经过观察我们发现是行不满足要求。

对于这个矩阵第 $i$ 列的和是 $[0+1+2+\dots+(n-1)]\times n+n\times i=(n-1)\times n^2\div 2+n\times i$。这个式子第一项是偶数，原因是 $n$ 有因子 $2$，所以 $n^2$ 有因子 $4$，然而 $4\div 2=2$，仍是偶数。第二项也是偶数，因为 $n$ 是偶数。所以式子为偶数。

第 $i$ 行的和是 $(i-1)\times n+(1+2+3+\dots+n)=(i-1)\times n+n\times(n+1)\div 2$。这个式子在 $n$ 是 $4$ 的倍数时也是偶数，否则是奇数。

所以 $n$ 不是 $4$ 的倍数是可以考虑这种构造方案。

其他方案，首先考虑微调（去掉最后一列）。

按照 $\begin{bmatrix}
   1 & 2 &3 & 4 & \dots & n-1 \\
   n & n+1 & n+2 & n+3 & \dots & 2n-2\\
   \dots & \dots & \dots & \dots & \dots & \dots \\
   (n-1)^2+1 & (n-1)^2+2 & (n-1)^2+3 & (n-1)^2+4 & \dots & n^2-n\\
\end{bmatrix}$ 来构造（这是前 $n-1$ 列）。

这样第 $i$ 行和是 $(i-1)\times(n-1)+[1+2+\dots+(n-1)]=(n-1)\times(i-1)+n\times(n-1)\div 2=(n-1)\times[(i-1)+n\div 2]$。由于 $n$ 是偶数，所以 $n\div 2$ 是整数，所以 $(i-1)+n\div 2$ 奇偶性与 $i$ 有关（一奇一偶），又知道 $n-1$ 是奇数，所以不会出现全是偶数。

但是我们需要验证列，第 $i$ 列是 $[0+1+\dots+(n-1)]\times(n-1)+i\times n=(n-1)\times n\div 2\times (n-1)+i\times n$ 是偶数（原因是 $n$ 是 $4$ 的倍数）。

第 $n$ 列的数都是 $(n-1)\times n+1,(n-1)\times n+2,\dots,n^2$。虽然不知道顺序，但是和是 $n\times(n-1)\times n+(1+2+\dots+n)=n\times(n-1)\times n+(n+1)\times n\div 2$ 是偶数。

所以所有列都是偶数，那就需要所有行都是奇数。

行都是奇数的满足方案的微妙之处就在于把最后一列数随便改变顺序不会改变列是偶数的性质，但是可以调节行的奇偶性。

具体做法是：把 $(n-1)\times[(i-1)+n\div 2]$ 是奇数时匹配一个偶数，是偶数时匹配一个奇数，然而因为 $n$ 是偶数，最后一段又是连续的 $n$ 个数，必然一半奇数一半偶数，正好可以匹配。

更具体：$i$ 是奇数时，式子是偶数，需要添加的数是奇数；$i$ 是偶数时，式子是奇数，需要添加的数是偶数。所以最后一列的数按从小到大的顺序排好之后，从上到下一次从最右边加进矩阵（正好满足第一个奇、第二个偶、第三个奇……）。

$n$ 是奇数无法构造，解释见【题目分析】。

---

## 作者：Tracy_Loght (赞：3)

水题。

## 题目描述：

你需要把 $1 \sim n \times n$ 这些编号填入这个网格里面，每一行加起来是**奇**数，每一列加起来是**偶**数。

## 思路：

只要上过小学的都知道：

- 无论多少个偶数相加，结果一定为偶数。

- 奇数个奇数，和为奇数；偶数个奇数，和为偶数。

那么题目后半截翻译后就是：

- 及对于每一**行**，要有**奇**数个奇数，比如 $1$，$3$，$5$，$7$，$9$ 个。

- 对于每一**列**，要有**偶**数个奇数，比如 $0$，$2$，$4$，$6$，$8$ 个

**对于 $n$ 为奇数时**，行会有**奇数乘奇数**个奇数，而列会有**奇数乘偶数**个奇数，那么要求既要是**奇数**个奇数又要是**偶数**个奇数，肯定是不对的。

------------

**对于 $n$ 为偶数时**，我们有刚好 $n^2\div2$ 个奇数和 $n^2\div2$ 个偶数。

我给出一个略比官解优的构造：

对于任意偶数的情况，我们将构造想象成在 $n \times n$ 的网格中填数，对于第 $i$ 列，从**下到上**依次填 $i-1$ 个奇数，如果 $i-1$ 为奇数，那么就**再**填一个奇数。

------------

**证明：**

易证得，但为了防止趋势，我给出[证明](https://www.luogu.com.cn/paste/jbukigo2)。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main()
{
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	if(n%2==1) cout<<"No";
	else cout<<"Yes"; 
	return 0;
} 
```

## 构造代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,o[5001][5001],k;
int main()
{
	cin>>n;
	int l=n/2+1,r=n;
	for(int i=1;i<=n;i++){
		if(i%2==1) k=i;
		else k=i-1;
		for(int j=1;j<=k;j++)
			o[i][n-j+1]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)cout<<o[i][j];
		cout<<"\n";
	} 
	return 0;
}
```

**注：奇数以一表示，偶数以零表示。**

---

## 作者：kind_Ygg (赞：2)

结论：当 $n \bmod 2 = 0$，输出 `Yes`。否则输出 `No`。  
证明：  
我们分类讨论，分为 $n \bmod 2 = 0$ 和 $n \bmod 2 \not= 0$。  

当 $n \bmod 2 \not= 0$ 时，  
按以下排列：

| $1$ | $2$ | $3$ | $......$ | $n$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $n+1$ | $n+2$ | $n+3$ | $......$ | $2n$ |
| $2n+1$ | $2n+2$ | $2n+3$ | $......$ | $3n$ |
| $......$ | $......$ | $......$ | $......$ | $......$ |
| $n(n-1)+1$ | $n(n-1)+2$ | $n(n-1)+3$ | $......$ | $n^2$ |
奇数个奇数相加还是奇数，奇数个偶数相加是偶数，证明就自己去证，非常简单。

当 $n \bmod 2 = 0$ 时，  
我们又可以分为两种情况：$n \bmod 4 = 2$ 和 $n \bmod 4 = 0$。  
当 $n \bmod 4 = 2$ 时，  
如上图排列就行。  
当 $n \bmod 4 = 0$ 时，
将每个奇数行的**1 个奇数**与每个偶数行的**1 个偶数**交换即可。

---

## 作者：蟋蟀喵～～ (赞：2)

### 题目
小 A 给了你一个边长为 
$n$ 的正方形网格，你需要把 $1 \sim n \times n$ 这些编号填入这个网格里面，满足每一行的编号加起来都是奇数，每一列的编号加起来都是偶数。

在填之前，你想知道是否有任何一种解法满足上述条件，如果可以，输出 `Yes`；否则，输出 `No`。

### 分析
赛时，我先看了看样例，样例有四个数据，$n$ 为偶数时输出的都是 `Yes`，为奇数时输出的都为 `No`，所以这道题的解法会不会和奇偶性相关呢？

先考虑 $n$ 为奇数的情况。
首先，我们要明白一个小学数学常识：
- 奇数个奇数相加，和为奇数。
- 奇数个偶数相加，和为偶数。
- 偶数个奇数相加，和为偶数。
- 偶数个偶数相加，和为偶数。

我们假设 $n$ 为奇数时存在一个合法的网格，根据题目，该网格有 $n$ 列，每列和是偶数，所以 
$$\sum_{i = 1}^{n^2}i$$ 
也应为偶数（该网格包含了 $1 \sim n \times n$ 中的所有数，共 $n$ 列，每列和为偶数）。

但我们知道，该网格有 $n$ 行，每行和为奇数，所以
$$\sum_{i = 1}^{n^2}i$$
为奇数。

**矛盾。**

故 $n$ 为奇数时无论如何都不存在合法网格。

再考虑 $n$ 为偶数的情况。

$n$ 为偶数时，$n^2$ 也为偶数，即 $1 \sim n \times n$ 中奇数和偶数数量相等，所以可以证明，当 $n$ 为偶数时，一定可以构造出至少一种合法的排列方式。

#### 构造方法

若 ${\frac{n}{2}}$ 不为 $2$ 的倍数，直接将 $1 \sim n ^ 2$ 顺序排列即可；若 ${\frac{n}{2}}$ 为 $2$ 的倍数，需将 $1 \sim n ^ 2$ 顺序排列后将第一行的最后一个数与第二行的第一个数进行交换、第三行的最后一个数与第四行的第一个数进行交换，以此类推。

示例：

$n = 2$ 时：
$$
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix}
$$

$n = 4$ 时：
$$
\begin{bmatrix}
1 & 2 & 3 & 5 \\
4 & 6 & 7 & 8 \\
9 & 10 & 11 & 13 \\
12 & 14 & 15 & 16
\end{bmatrix}
$$


### 结论：
$n$ 为奇数时输出 `No`，$n$ 为偶数时输出 `Yes`。

---

## 作者：ACtheQ (赞：2)

这里是出题人题解。

观察题目范围，$1 \le n \le 10^{18}$。

我们先找一个 $3 \times 3$ 的网格看一个例子。

| 偶 | 偶 | 偶 |  |
| -----------: | -----------: | -----------: | -----------: |
|  |  |  | 奇 |
|  |  |  | 奇 |
|  |  |  | 奇 |

（奇表示这一列的和应为偶数,偶表示列一行的和应为奇数）

现在要往这个格子里面填数。

我们考虑求所有网格中所有数的和。

和为 $3$ 个奇数的和也等于 $3$ 个偶数的和。

考虑奇偶性，发现 $3$ 个奇数的和为奇数，$3$ 个偶数的和为偶数，显然矛盾。

那么只有当 $n \times $ 奇数 和 $n \times $ 偶数奇偶性一样的时候才行得通。

说以只有当 $n$ 是偶数的时候，才有可能有方案。

接下来考虑 $n$ 为偶数时的构造：


当边长为 $4$ 的倍数的时候，可以构造出，为第一列前一半是奇数，后一半是偶数，第 $2 \sim n$ 列的时候前一半是偶数，后一半是奇数。

当边长为 除 $4$ 余 $2$ 的时候，可以构造出，为第 $1\sim n$ 列的时候前一半是偶数，后一半是奇数。
```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long x;
	cin>>x;
	if(x%2==0) cout<<"Yes";
	else cout<<"No";
	return 0;
}

```

---

## 作者：__delta_epsilon__ (赞：2)

### 题目大意

将 $1\sim n\times n$ 填入一个 $n\times n$ 的方格中，使得每行数之和为奇数，每列数之和为偶数。试问对于给定的 $n$ 是否存在一种填法？

### 分析

显然，对于 $n$ 为奇数，一定不存在，因为所有数之和 $\dfrac{n^2(n^2+1)}{2}$ 一定为奇数，不可能使得每一列之和均为偶数。

对于 $n$ 为偶数的情况，可以给出如下构造。

分情况讨论 $n$ 除以 $4$ 的余数。

若 $n\equiv2\pmod4$，则按照从左到右，从上到下一次填入 $1\sim n^2$ 即可。

$$\begin{matrix}
1&2&3&\cdots&n\\
n+1&n+2&n+3&\cdots&2n\\
2n+1&2n+2&2n+3&\cdots&3n\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
(n-1)n+1&(n-1)n+2&(n-1)n+3&\cdots&n^2
\end{matrix}$$

每一行之和为 $kn+\dfrac{n(n+1)}{2}$（$k=0,1,\cdots,n-1$），因为 $n\bmod 4=2$，所以 $n/2$ 为奇数，$n+1$ 为奇数，$kn$ 为偶数，原式为奇数。

每一列之和为 $\dfrac{(n-1)n}{2}\cdot n+kn$（$k=1,2,\cdots,n$），显然为偶数。

若 $n\equiv0\pmod4$，则先按照上面的方式排布（此时每一行、每一列之和均为偶数），然后交换第一行相邻的左右两个数（因为每一列上分别加一或减一，所以每一列之和为奇数），最后将整个网格按照对角线翻折，这样就能调整成每一行为奇数，每一列为偶数。

综上所述，$n$ 为偶数时必然成立。

故只要在 $n$ 为偶数时输出 `Yes`，为奇数时输出 `No` 即可。

---

## 作者：liyifan202201 (赞：1)

## 思路
**结论：** 当 $( n \bmod 2 = 0 $) 时，输出 `Yes`；否则输出 `No`。

**证明：**

我们分类讨论，分为 $(n \bmod 2 = 0)$ 和 $( n \bmod 2 \neq 0)$。

1. **当 $( n \bmod 2 \neq 0 )$ 时：**

按以下排列：
$ 
\begin{array}{cccc}
1 & 2 & 3 & \cdots & n \\
n+1 & n+2 & n+3 & \cdots & 2n \\
2n+1 & 2n+2 & 2n+3 & \cdots & 3n \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
n(n-1)+1 & n(n-1)+2 & n(n-1)+3 & \cdots & n^2 \\
\end{array}
$

奇数个奇数相加仍为奇数，偶数个偶数相加仍为偶数。这个证明非常简单。

2. **当 $(n \bmod 2 = 0)$ 时：**

我们进一步分为两种情况：$(n \bmod 4 = 2)$ 和 $( n \bmod 4 = 0)$。

- **当 $(n \bmod 4 = 2)$ 时：**

如上图排列即可。

- **当 $( n \bmod 4 = 0 )$ 时：**

将每个奇数行的一个奇数与每个偶数行的一个偶数交换即可。
## 代码
过于简短，看到结论应该可以写出来。
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n;
signed main(){
    cin>>n;
    if(n&1)
        cout<<"No";
    else
        cout<<"Yes";
    return 0;
}
```

---

## 作者：huangzhixia (赞：0)

不好评价。

可以说我赛时没证就过了。

-------------

【**解法**】

判断 $n$ 是否为奇数，是则答案为 ```No```，否则答案为 ```Yes```。

【**证明**】

这个 $n \times n$ 的方阵中，当 $n$ 为奇数，则有 $\frac{n \times n}{2} + 1$ 个奇数，$\frac{n \times n}{2}$ 个偶数。因此可证，我们为了让每一行的和都是奇数，所以每一行必须存在奇数个奇数。那么，总会有一列是有奇数个奇数的，奇数的个数是 $\frac{n \times n}{2} + 1$ 个，那多出来的 $1$ 个奇数，总要填在哪一列，因此至少有一列是有奇数个奇数的，这里可以证明，当 $n$ 为奇数，$\frac{n \times n}{2}$ 一定是个偶数。当然这里都是指整除。

综上所述，可得出当 $n$ 为奇数时，一定无解。

当 $n$ 为偶数，则有 $\frac{n \times n}{2}$ 个奇数，$\frac{n\times n}{2} +1$ 个偶数。和上面的证明同理，为了让每行都是奇数，所以应该有奇数个奇数。那么，每一列都应该有偶数个奇数，可以证明，因为我们是有 $\frac{n \times n}{2}$ 个奇数，那么可以把所以的奇数都放在每一行的第一个，因为 $n$ 是偶数，那么偶数个奇数相加一定是偶数。这就能保证每一行一定是偶数。

综上所述，可得出当 $n$ 为偶数时，一定有解。

再次强调，以上的除以 $2$ 均为**整除**。

【**代码**】

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll n;

int main(){
	scanf("%lld", &n);
	if (n % 2 == 1)
		puts("No");
	else
		puts("Yes");
}
```

---


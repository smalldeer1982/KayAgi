# 奖牌排序

## 题目描述

有 $n$ 个小朋友参加了若干场比赛，其中第 $i$ 个小朋友获得了 $g_i$ 枚金牌、$s_i$ 枚银牌和 $b_i$ 枚铜牌。老师希望**每个小朋友**制作一张**所有小朋友**的排行榜。

然而小朋友们为了让自己的排名尽量靠前，自然是可以动一些小心思的，体现在排序标准上——每个小朋友可以选择按照金牌数从大到小排序，也可以选择按照银牌数从大到小排序，也可以选择按照铜牌数从大到小排序。在小朋友自制的排行榜里，如果自己和别的小朋友并列，那么他可以把自己写在最前面。

给出每个小朋友获得的金牌数、银牌数和铜牌数，请对于每个小朋友 $i$，计算他在他自己的排行榜里最好能排第几名。

## 说明/提示

【样例 1 解释】

下面给出一种可能得情况，其中加粗的一列表示这个小朋友的排序依据。

第一个小朋友制作的排行榜如下：

|小朋友编号|金牌数|银牌数|铜牌数|
|:-:|:-:|:-:|:-:|
|$1$|$\bf{8}$|$5$|$0$|
|$2$|$\bf 4$|$5$|$3$|
|$3$|$\bf 4$|$1$|$2$|
|$4$|$\bf 2$|$1$|$1$|

第二个小朋友制作的排行榜如下：

|小朋友编号|金牌数|银牌数|铜牌数|
|:-:|:-:|:-:|:-:|
|$2$|$4$|$\bf 5$|$3$|
|$1$|$8$|$\bf 5$|$0$|
|$3$|$4$|$\bf 1$|$2$|
|$4$|$2$|$\bf 1$|$1$|

第三个小朋友的排行榜如下（按照金牌排序，也可以获得第二名）：

|小朋友编号|金牌数|银牌数|铜牌数|
|:-:|:-:|:-:|:-:|
|$2$|$4$|$5$|$\bf 3$|
|$3$|$4$|$1$|$\bf 2$|
|$4$|$2$|$1$|$\bf 1$|
|$1$|$8$|$5$|$\bf 0$|

第四个小朋友的排行榜如下：

|小朋友编号|金牌数|银牌数|铜牌数|
|:-:|:-:|:-:|:-:|
|$2$|$4$|$\bf 5$|$3$|
|$1$|$8$|$\bf 5$|$0$|
|$4$|$2$|$\bf 1$|$1$|
|$3$|$4$|$\bf 1$|$2$|

【样例 2 解释】

该样例符合测试点 $8$ 的性质。

【样例 3 解释】

该样例符合测试点 $10$ 的性质。

【数据范围】

对于全体数据，保证 $1\le n\le 2\times 10^5$，且 $0\le g_i,s_i,b_i\le 10^9$。

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$3$||
|$3\sim 4$|$100$||
|$5\sim 7$|$1000$|A|
|$8\sim 9$|$1000$||
|$10\sim 12$|$2\times 10^5$|A|
|$13\sim 15$|$2\times 10^5$|B|
|$16\sim 20$|$2\times 10^5$||

- 特殊性质 A：$g_i$ 互不相同，$s_i$ 互不相同，$b_i$ 互不相同。
- 特殊性质 B：$1\le g_i,s_i,b_i\le 2\times 10^5$。


## 样例 #1

### 输入

```
4
8 5 0
4 5 3
4 1 2
2 1 1
```

### 输出

```
1
1
2
3
```

## 样例 #2

### 输入

```
参见 medal/medal2.in```

### 输出

```
参见 medal/medal2.ans```

## 样例 #3

### 输入

```
参见 medal/medal3.in```

### 输出

```
参见 medal/medal3.ans```

# 题解

## 作者：yummy (赞：28)

# B. 奖牌排序 (medal) 官方题解

本题考察的主要知识点有：

- 【3】sort 函数
- 【3】结构体

### 45 分做法

对于每个小朋友，如果以金牌数排序，如果有 $k$ 个人金牌比他多，那么这个小朋友的排名是 $k+1$。用同样的原理可以计算出按照银牌或铜牌数排序时这个小朋友的排名。输出时，取三个排名中最靠前的即可。时间复杂度为 $O(n^2)$，可以通过前 $9$ 个测试点。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,g[200005],s[200005],b[200005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&g[i],&s[i],&b[i]);
	for(int i=1;i<=n;i++){
		int rkg=1,rks=1,rkb=1;
		for(int j=1;j<=n;j++)
			if(g[j]>g[i])
				rkg++;
		for(int j=1;j<=n;j++)
			if(s[j]>s[i])
				rks++;
		for(int j=1;j<=n;j++)
			if(b[j]>b[i])
				rkb++;
		printf("%d\n",min(min(rkg,rks),rkb));
	}
	return 0;
}
```

### 100 分做法

注意到小朋友们的排序方式其实只有三种，分别用三种方式给小朋友们排序，然后计算每个小朋友的排名即可。

计算排名时，如何处理并列的问题呢？

在 `sort` 结束后从前往后记录排名，对于第 $i$ 个小朋友，如果他和上一个人奖牌数一样，那么他的排名等于上一个人的排名，否则排名等于 $i$。

假设有 $5$ 个小朋友，排序后 $5$ 个小朋友的奖牌数分别为 $8,8,8,6,5$，下面为计算排名的图示。

![](https://cdn.luogu.com.cn/upload/image_hosting/jajmv3ln.png?x-oss-process=image/resize,m_lfit,h_500,w_500 )

注意，计算每个小朋友的排名后，我们要对应到这个小朋友**原来的**编号，所以小朋友的结构体中，不仅要存金牌、银牌、铜牌数量，还要存小朋友原来的编号。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct child{int g,s,b,ind;}a[200005];
bool cmpg(child x,child y){return x.g>y.g;}
bool cmps(child x,child y){return x.s>y.s;}
bool cmpb(child x,child y){return x.b>y.b;}
int n,rk[200005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].g,&a[i].s,&a[i].b);
		a[i].ind=i;
	}
    //处理金牌
	sort(a+1,a+n+1,cmpg);
	a[0]={-1,-1,-1,0};
	int crk=1;
	for(int i=1;i<=n;i++){
		if(a[i].g!=a[i-1].g)
			crk=i;
		rk[a[i].ind]=crk;//注意去更新 a[i].ind 这个小朋友而非 i
	}
    //处理银牌
	sort(a+1,a+n+1,cmps);
	a[0]={-1,-1,-1,0};
	crk=1;
	for(int i=1;i<=n;i++){
		if(a[i].s!=a[i-1].s)
			crk=i;
		rk[a[i].ind]=min(rk[a[i].ind],crk);
	}
    //处理铜牌
	sort(a+1,a+n+1,cmpb);
	a[0]={-1,-1,-1,0};
	crk=1;
	for(int i=1;i<=n;i++){
		if(a[i].b!=a[i-1].b)
			crk=i;
		rk[a[i].ind]=min(rk[a[i].ind],crk);
	}
    
	for(int i=1;i<=n;i++)
		printf("%d\n",rk[i]);
	return 0;
}
```

---

## 作者：FurippuWRY (赞：20)

一种比较唐的写法是：开六个数组，其中三个分别存一个人的三种奖牌数（`g_[], s_[], b_[]`），另外三个分别对应（`g[], s[], b[]`）。对后三个数组进行排序，然后对于每个人，在后三个数组中用 `upper_bound()` 函数查找最高的排名，输出，做完了。

差不多 $O(n \log n)$，最慢两百多毫秒。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 9;

int n, g_[N], s_[N], b_[N];
int g[N], s[N], b[N];

int main() {
	
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> g_[i] >> s_[i] >> b_[i];
		g[i] = g_[i];
		s[i] = s_[i];
		b[i] = b_[i];
	}
	sort(g + 1, g + 1 + n);
	sort(s + 1, s + 1 + n);
	sort(b + 1, b + 1 + n);
	for (int i = 1; i <= n; ++i) {
		cout << n -  
			max({
				upper_bound(g + 1, g + 1 + n, g_[i]) - g, 
				upper_bound(s + 1, s + 1 + n, s_[i]) - s, 
				upper_bound(b + 1, b + 1 + n, b_[i]) - b
			}) + 2
		<< '\n';
	}
}
```

---

## 作者：wyf1230 (赞：5)

本题可以用二分法解决，先将每种奖牌排序，然后用二分查找每个小朋友在排行榜中的位置，再取最靠前的那个，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std; 
const int N=200005;
int a[N],b[N],c[N],lj[N],ly[N],lt[N];
int main() {
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&lj[i],&ly[i],&lt[i]);
		a[i]=lj[i];
		b[i]=ly[i];
		c[i]=lt[i];
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	sort(c+1,c+n+1);//排序
	for(int i=1;i<=n;i++){
		int min1,min2,min3;
		if(a[n]==lj[i])min1=1;
		else min1=n-(upper_bound(a+1,a+n+1,lj[i])-a-2);//二分函数查找第一个大于这位小朋友奖牌数的位置
		if(b[n]==ly[i])min2=1;
		else min2=n-(upper_bound(b+1,b+n+1,ly[i])-b-2);
		if(c[n]==lt[i])min3=1;
		else min3=n-(upper_bound(c+1,c+n+1,lt[i])-c-2);
		cout<<min(min1,min(min2,min3))<<endl;//比较
	}
    return 0;
}
```

---

## 作者：program_xwl (赞：4)

## 思路：
给金牌、银牌和铜牌都分别开两个数组，一个用来排序找排名，一个用于记录每个小朋友的获得情况。每次用二分查找自己的排名，三种奖牌取排名最靠前的即可。

不会二分的看过来：

假如我们需要在一下金牌榜中找获得 $6$ 枚金牌的小朋友的排名。

$\{100,96,85,56,19,6,6,1,0,0\}$

首先，我们需要两个指针，$l$ 和 $r$，用来记录存在答案区间的开区间 $(l,r)$，最开始 $l=0,r=n+1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/u7hrxky8.png)

我们找到 $l,r$ 的中间，即 $19$，我们发现它大于了 $6$，而榜单是单调不增的，所以我们可以确定，它的左边全部都不是答案，$l$ 指针可以移动到那里。反之亦然。

![](https://cdn.luogu.com.cn/upload/image_hosting/jbhyjhco.png)

你应该懂了，重复几次后就可以找到答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/834x7bo7.png)

这样我们就可以在 $O(\log n)$ 的时间内找到自己的分数。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a[200005],a2[200005],b[200005],b2[200005],c[200005],c2[200005];

bool cmp(int x,int y) {return x > y;}//从大到小排序。

int finda(int x)//在a数组中二分查找
{
	int l = 0,r = n+1;
	while(l+1 < r)
	{
		int mid = (l+r)/2;
		if(a[mid] <= x) r = mid;//右边的都不是答案
		else l = mid;//左边的都不是答案
	}
	return r;
}

int findb(int x)//在b数组中二分查找
{
	int l = 0,r = n+1;
	while(l+1 < r)
	{
		int mid = (l+r)/2;
		if(b[mid] <= x) r = mid;
		else l = mid;
	}
	return r;
}

int findc(int x)//在c数组中二分查找
{
	int l = 0,r = n+1;
	while(l+1 < r)
	{
		int mid = (l+r)/2;
		if(c[mid] <= x) r = mid;
		else l = mid;
	}
	return r;
}

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i] >> b[i] >> c[i];
		a2[i] = a[i];
		b2[i] = b[i];
		c2[i] = c[i];
	}
	stable_sort(a+1,a+n+1,cmp);//排出榜单a
	stable_sort(b+1,b+n+1,cmp);//排出榜单b
	stable_sort(c+1,c+n+1,cmp);//排出榜单c
	for(int i = 1;i <= n;i++)
	{
		int ansa,ansb,ansc;//用lower_bound反着找也可以
		ansa = finda(a2[i]);
		ansb = findb(b2[i]);
		ansc = findc(c2[i]);
		cout << min({ansa,ansb,ansc}) << '\n';
	}
	return 0;
}
```

---

## 作者：2huk (赞：3)

不妨只考虑对金牌数排序的情况。按银牌/铜牌数量排序的情况类似。

显然如果有 $j$ 个小朋友的金牌数**严格大于**小朋友 $j$ 的金牌数，那么他的排名一定不小于 $j+1$。

而且题目告诉了你「如果自己和别的小朋友并列，那么他可以把自己写在最前面」。所以小朋友 $j$ 的排名可以取 $j +1$ 且这样最优。

于是问题变成了如何对于每个小朋友 $i$ 都计算出有多少小朋友的金牌数严格大于自己的。

首先将所有小朋友按照金牌数量降序排序。在枚举 $i$ 的同时，维护 $j$ 表示最后一个金牌数严格大于小朋友 $i$ 的位置。那么 $j$ 同时也一定是第一个与 $i$ 相同的位置。所以每次判断一下若 $a_i \ne a_j$ 则更新 $j \gets i$ 即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

int n;

struct Child {
	int a, b, c, id;
}p[N];

int res[N];

void chkmin(int &x, int y) {
	x = min(x, y);
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	 
	cin >> n;
	
	for (int i = 1; i <= n; ++ i ) {
		cin >> p[i].a >> p[i].b >> p[i].c;
		p[i].id = i;
	}
	
	memset(res, 0x3f, sizeof res);
	
	sort(p + 1, p + n + 1,
		[&](Child x, Child y) {
			return x.a > y.a;
		});
	
	for (int i = 1, j = 1; i <= n; ++ i ) {
		if (p[i].a != p[j].a) j = i;
		chkmin(res[p[i].id], j);
	}
	
	sort(p + 1, p + n + 1,
		[&](Child x, Child y) {
			return x.b > y.b;
		});
	
	for (int i = 1, j = 1; i <= n; ++ i ) {
		if (p[i].b != p[j].b) j = i;
		chkmin(res[p[i].id], j);
	}
	
	sort(p + 1, p + n + 1,
		[&](Child x, Child y) {
			return x.c > y.c;
		});
	
	for (int i = 1, j = 1; i <= n; ++ i ) {
		if (p[i].c != p[j].c) j = i;
		chkmin(res[p[i].id], j);
	}
	
	for (int i = 1; i <= n; ++ i ) cout << res[i] << '\n';
	
	return 0;
}
```

---

## 作者：Lyria (赞：2)

考虑消除小朋友要把自己排同奖牌数下第一的影响，你只需要将同奖牌数赋同一名次，类似于有两个同分的第一名，那么我们赋低于第一名分的最大值那位为第三名。

显然我们只需要对三种奖牌分别进行排名赋值，取每个人三种奖牌排名的优值，可以用优先队列实现。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 200005
using namespace std;
int n,m;
struct node{
    int x,y,z;
}a[N];
priority_queue<int> q1,q2,q3;
map<int,int> mp1,mp2,mp3;
signed main(){
    // freopen("medal3.in","r",stdin);
    // freopen("medal.out","w",stdout);
    cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y>>a[i].z,q1.push(a[i].x),q2.push(a[i].y),q3.push(a[i].z);
    int last=-1,sum=0;
    while(q1.size()){
        int t=q1.top();
        q1.pop();
        sum++;
        if(last==-1||last==t){
            if(last==-1) mp1[t]=1;
            last=t;
        }
        else mp1[t]=sum,last=t;
    }
    last=-1,sum=0;
    while(q2.size()){
        int t=q2.top();
        q2.pop();
        sum++;
        if(last==-1||last==t){
            if(last==-1) mp2[t]=1;
            last=t;
        }
        else mp2[t]=sum,last=t;
    }
    last=-1,sum=0;
    while(q3.size()){
        int t=q3.top();
        q3.pop();
        sum++;
        if(last==-1||last==t){
            if(last==-1) mp3[t]=1;
            last=t;
        }
        else mp3[t]=sum,last=t;
    }
    for(int i=1;i<=n;i++){
        cout<<min({mp1[a[i].x],mp2[a[i].y],mp3[a[i].z]})<<"\n";
    }
}
```

---

## 作者：zhang_Jimmy (赞：1)

我们可以按照金牌数量，银牌数量和铜牌数量依次进行排序，然后统计每个小朋友的最高名次。

这里要注意，如果自己和别的小朋友并列，那么他可以把自己写在最前面，所以我们还要判断一下这一个人的奖牌数量与上一个人的奖牌数量是不是相同的，如果相同，名次不变，否则名次就要变。

由于要统计答案，所以我们还要把每个小朋友的编号记录一下。

代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;

struct medal{
	int g, s, b, rk;
}a[200010];
int n; 
int ans[200010];

bool cmp1(medal a, medal b){return a.g > b.g;}
bool cmp2(medal a, medal b){return a.s > b.s;}
bool cmp3(medal a, medal b){return a.b > b.b;}

int main(){
//    freopen("medal.in", "r", stdin);
 //   freopen("medal.out", "w", stdout);
	memset(ans, 0x3f, sizeof ans);
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++){
		scanf("%d%d%d", &a[i].g, &a[i].s, &a[i].b);
		a[i].rk = i;
//		b[i].g = a[i].g; b[i].s = a[i].s; b[i].b = a[i].b;
//		c[i].g = a[i].g; c[i].s = a[i].s; c[i].b = a[i].b;
	}
	sort(a + 1, a + n + 1, cmp1);
	for(int i = 1; i <= n; i ++){
		int idxa = (a[i].g == a[i - 1].g ? idxa : i);
		ans[a[i].rk] = min(ans[a[i].rk], idxa); 
	}
	sort(a + 1, a + n + 1, cmp2);
	for(int i = 1; i <= n; i ++){
		int idxa = (a[i].s == a[i - 1].s ? idxa : i);
		ans[a[i].rk] = min(ans[a[i].rk], idxa); 
	}
	sort(a + 1, a + n + 1, cmp3);
	for(int i = 1; i <= n; i ++){
		int idxa = (a[i].b == a[i - 1].b ? idxa : i);
		ans[a[i].rk] = min(ans[a[i].rk], idxa); 
	}
	for(int i = 1; i <= n; i ++) cout << ans[i] << "\n";
	return 0;
}

```

---

## 作者：_JF_ (赞：1)

[Link](https://www.luogu.com.cn/problem/P11185)

这才是签到题好吧。

我们显然是对金银铜分别单独考虑，假设考虑金牌。

我们对金牌数从大到小排序，我们用一个变量维护按照金牌排序，某个人的排名。

显然，对于当前的人，我只用记录有多少个人的金牌数量严格比他多就行了。

这个用一个变量维护即可，具体看代码，就是遇到相同的不移动，如果不同的话修改。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5e5+10;
#define int long long
int n,tot,tot1,tot2,rnk[N];
struct node{
	int G,S,B,id;
}c[N],c1[N],c2[N];
bool cmp(node a,node b){
	return a.G>b.G;
}
bool cmp1(node a,node b){
	return a.S>b.S;
}
bool cmp2(node a,node b){
	return a.B>b.B;
}
signed main(){
//	freopen("medal1.in","r",stdin);
//	freopen("ans.out","w",stdout);
	scanf("%lld",&n);
	for(int i=1,g,s,b;i<=n;i++){
		scanf("%lld%lld%lld",&g,&s,&b);
		tot++,c[tot].G=g,c[tot].S=s,c[tot].B=b;
		tot1++,c1[tot1].G=g,c1[tot1].S=s,c1[tot1].B=b;
		tot2++,c2[tot1].G=g,c2[tot2].S=s,c2[tot2].B=b;
		c[tot].id=c1[tot1].id=c2[tot2].id=i;
	}
	sort(c+1,c+n+1,cmp),sort(c1+1,c1+n+1,cmp1),sort(c2+1,c2+n+1,cmp2);
	c[0].G=c[0].S=c[0].B=-1;
	c1[0].G=c1[0].S=c1[0].B=-1;
	c2[0].G=c2[0].S=c2[0].B=-1;
	for(int i=1;i<=n;i++)	rnk[i]=n;
	int lst=0;
	for(int i=1;i<=n;i++){
		if(c[i].G==c[i-1].G)	rnk[c[i].id]=min(rnk[c[i].id],lst);
		else	rnk[c[i].id]=min(rnk[c[i].id],i),lst=i;
	}
	lst=0;
	for(int i=1;i<=n;i++){
//		cout<<c1[i].id<<endl;
		if(c1[i].S==c1[i-1].S)	
			rnk[c1[i].id]=min(rnk[c1[i].id],lst);
		else	
			rnk[c1[i].id]=min(rnk[c1[i].id],i),lst=i;
	}
	lst=0;
	for(int i=1;i<=n;i++){
		if(c2[i].B==c2[i-1].B)	rnk[c2[i].id]=min(rnk[c2[i].id],lst);
		else	rnk[c2[i].id]=min(rnk[c2[i].id],i),lst=i;
	}
	for(int i=1;i<=n;i++)	printf("%lld\n",rnk[i]);
	return 0;
}

```

---

## 作者：wangboyue_740325 (赞：1)

# 思路
对每种奖牌数量排序后，对每个小朋友，二分在每种奖牌中的最后出现位置位置即可。  
例如：样例，第 $3$ 个小朋友情况如下：（数组为排序后）
```text
g: 2 4 4 8
s: 1 1 5 5
b: 0 1 2 3
```
在金牌中，出现位置为 $3$，排名为 $n-3+1=2$。  
在银牌中，出现位置为 $2$，排名为 $n-2+1=3$。  
在铜牌中，出现位置为 $3$，排名为 $n-3+1=2$。  
最前排名为 $\min(2,3,2)=2$。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=2e5+5;
int n,g[N],s[N],b[N],sg[N],ss[N],sb[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>g[i]>>s[i]>>b[i];
		sg[i]=g[i];
		ss[i]=s[i];
		sb[i]=b[i];
	}
	sort(sg+1,sg+1+n);
	sort(ss+1,ss+1+n);
	sort(sb+1,sb+1+n);
	for(int i=1;i<=n;i++){
		cout<<min({n-(upper_bound(sg+1,sg+1+n,g[i])-sg-1)+1,
		n-(upper_bound(ss+1,ss+1+n,s[i])-ss-1)+1,
		n-(upper_bound(sb+1,sb+1+n,b[i])-sb-1)+1})<<endl; 
	}
	return 0;
}
```

---

## 作者：Indestructible (赞：0)

先把金银铜牌排序，然后把数值相同的标记为同样排名即可。

程序的具体实现中，使用三个结构体数组存金银铜牌，每个结构体数组有三个信息 `x,id,rk`，分别表示奖牌个数、小朋友编号、排名。为了实现快速查找，还要使用 `unordered_map` 在标记排名的同时把小朋友编号和数组下标对应起来。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int n;
struct Medal{ int x,id,rk; }Au[N],Ag[N],Cu[N];
bool cmp(Medal x,Medal y){ return x.x>y.x; }
unordered_map<int,int> mpAu,mpAg,mpCu;
signed main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d%d%d",&Au[i].x,&Ag[i].x,&Cu[i].x),
		Au[i].id=Ag[i].id=Cu[i].id=i;
	sort(Au+1,Au+n+1,cmp),sort(Ag+1,Ag+n+1,cmp),
	sort(Cu+1,Cu+n+1,cmp);
	for (int i=1;i<=n;i++)
		mpAu[Au[i].id]=mpAg[Ag[i].id]=mpCu[Cu[i].id]=i,
		Au[i].rk=Au[i].x==Au[i-1].x?Au[i-1].rk:i,
		Ag[i].rk=Ag[i].x==Ag[i-1].x?Ag[i-1].rk:i,
		Cu[i].rk=Cu[i].x==Cu[i-1].x?Cu[i-1].rk:i;
	for (int i=1;i<=n;i++) printf("%d\n",
		min(min(Au[mpAu[i]].rk,Ag[mpAg[i]].rk),Cu[mpCu[i]].rk));
	return 0;
}
```

---

## 作者：篮网总冠军 (赞：0)

因为每位小朋友获得的最好名次是按照金银铜牌分别排序所得到的最小名次，所以我们只要分别对金银铜牌进行排序，再更新小朋友的最佳名次即可。

注意一下：

+ 最小排名初值一定要够大。

+ 一定要把并列的情况考虑进去。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
	int x,y,z,bh;
}a[200005];
int ans[200005];
bool cmp1(node x,node y){
	return x.x>y.x;
}
bool cmp2(node x,node y){
	return x.y>y.y;
}
bool cmp3(node x,node y){
	return x.z>y.z;
}
int main(){
//	freopen("medal2.in","r",stdin);
//	freopen("medal.out","w",stdout);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y>>a[i].z;
		a[i].bh=i;
		ans[i]=n;
	}
	sort(a+1,a+1+n,cmp1);
	for(int i=1;i<=n;i++){
		int r=i;
		while(i<n&&a[i].x==a[i+1].x) i++;
		for(int j=r;j<=i;j++){
			ans[a[j].bh]=min(ans[a[j].bh],r);
		}
	}
	sort(a+1,a+1+n,cmp2);
	for(int i=1;i<=n;i++){
		int r=i;
		while(i<n&&a[i].y==a[i+1].y) i++;
		for(int j=r;j<=i;j++){
			ans[a[j].bh]=min(ans[a[j].bh],r);
		}
	}
	sort(a+1,a+1+n,cmp3);
	for(int i=1;i<=n;i++){
		int r=i;
		while(i<n&&a[i].z==a[i+1].z) i++;
		for(int j=r;j<=i;j++){
			ans[a[j].bh]=min(ans[a[j].bh],r);
		}
	}
	for(int i=1;i<=n;i++){
		cout<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

考虑结构体排序模拟。
### 思路
这道题我们可以分别按照金牌，银牌，铜牌排序，在结构体中多加上三个参数，分别表示按照金牌，银牌，铜牌排序的最高排名，我们排完序之后，会出现平局的情况，而题目中给出了如果相等，可以将自己放到前面，所以在计算时，我们判断这个人是否与前一个人的金牌或银牌或铜牌的数量相等，如果相等就让他的排名和前一个人一样即可。
### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 1;
const int INF = 1e9 + 1, INT = -1e9 + 1;
int n;
struct node
{
	int a, b, c;
	int jin, yin, tong;	
	int id;
}w[N], x[N];
bool cmp1 (node x, node y){
	return x.a > y.a;
}
bool cmp2 (node x, node y){
	return x.b > y.b;
}
bool cmp3 (node x, node y){
	return x.c > y.c;
}
bool cmp4 (node x, node y){
	return x.id < y.id;
}
void init(){
	sort (w + 1, w + n + 1, cmp4); // 恢复原来的顺序。
	return ;
}
signed main() {
	cin >> n;
	for (int i = 1;i <= n;i ++){
		cin >> w[i].a >> w[i].b >> w[i].c;
		x[i].a = w[i].a , x[i].b = w[i].b, x[i].c = w[i].c;
		w[i].id = i;
	}
    //分别进行结构体排序。
	sort(w + 1, w + n + 1, cmp1); 
	w[1].jin = 1;
	for (int i = 2;i <= n;i ++) {
		if (w[i].a == w[i - 1].a){
			w[i].jin = w[i - 1].jin;
		}else{
			w[i].jin = i;
		}
	}
	sort(w + 1, w + n + 1, cmp2); 
	w[1].yin = 1;
	for (int i = 2;i <= n;i ++) {
		if (w[i].b == w[i - 1].b){
			w[i].yin = w[i - 1].yin;
		}else{
			w[i].yin = i;
		}
	}
	sort(w + 1, w + n + 1, cmp3);
	w[1].tong = 1;
	for (int i = 2;i <= n;i ++) {
		if (w[i].c == w[i - 1].c){
			w[i].tong = w[i - 1].tong;
		}else{
			w[i].tong = i;
		}
	} 
	init();
	for (int i = 1;i <= n;i ++){
		cout << min({w[i].jin, w[i].yin, w[i].tong}) << '\n'; // 输出最高排名。
	}
	return 0;
}

```

---

## 作者：sieve (赞：0)

# 题解：[P11185 奖牌排序](https://www.luogu.com.cn/problem/P11185)

## 思路

这题我们可以直接进行模拟，算出每个人的排名，如果和上一个人一样排名，就可以从上一个排名顺延过来。

但是，这样很容易就会发现不对，因为样例都不能过。因为，可能有的是前面有 $2$ 个比它大的，但是按照顺延，所以就是上一个的排名加一，所以它的排名最高是 $2$，很显然不对。

不难发现，其实如果和前一个不是并列，排名就是前面比它大的个数，然后这题就愉快的解决了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define endl '\n'
using namespace std;
const int N=2e5+5;
int n,mx1[N],mx2[N],mx3[N];
int last1[N],last2[N],last3[N];
struct no{
	int id;
	int x,y,z;
};
bool cmp1(no u,no v)
{
	return u.x>v.x;
}	
bool cmp2(no u,no v)
{
	return u.y>v.y;
} 
bool cmp3(no u,no v)
{
	return u.z>v.z;
} 
vector<no> pq1,pq2,pq3;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i) mx1[i]=mx2[i]=mx3[i]=1e9;
	for(int i=1;i<=n;++i)
	{
		int x,y,z;
		cin>>x>>y>>z;
		pq1.pb({i,x,y,z});
		pq2.pb({i,x,y,z});
		pq3.pb({i,x,y,z});
	}
	sort(pq1.begin(),pq1.end(),cmp1);
	sort(pq2.begin(),pq2.end(),cmp2);
	sort(pq3.begin(),pq3.end(),cmp3);
	int sum=1;
	for(int i=1;i<pq1.size();++i)
	{
		if(pq1[i].x==pq1[i-1].x)
		{
			sum++;
			last1[pq1[i].id]=last1[pq1[i-1].id];
		}
		else
		{
			last1[pq1[i].id]=sum;
			sum++;
		}
	}
	sum=1;
	for(int i=1;i<pq2.size();++i)
	{
		if(pq2[i].y==pq2[i-1].y)
		{
			sum++;
			last2[pq2[i].id]=last2[pq2[i-1].id];
		}
		else
		{
			last2[pq2[i].id]=sum;
			sum++;
		}
	}
	sum=1;
	for(int i=1;i<pq3.size();++i)
	{
		if(pq3[i].z==pq3[i-1].z)
		{
			sum++;
			last3[pq3[i].id]=last3[pq3[i-1].id];
		}
		else
		{
			last3[pq3[i].id]=sum;
			sum++;
		}
	}
	mx1[pq1[0].id]=1,mx2[pq2[0].id]=1,mx3[pq3[0].id]=1;
	for(int i=1;i<pq1.size();++i)
	{
		if(pq1[i].x==pq1[i-1].x)
		{
			mx1[pq1[i].id]=mx1[pq1[i-1].id];
		}
		else
		{
			mx1[pq1[i].id]=last1[pq1[i].id]+1;
		}
	}
	for(int i=1;i<pq2.size();++i)
	{
		if(pq2[i].y==pq2[i-1].y)
		{
			mx2[pq2[i].id]=mx2[pq2[i-1].id];
		}
		else
		{
			mx2[pq2[i].id]=last2[pq2[i].id]+1;
		}
	}
	for(int i=1;i<pq3.size();++i)
	{
		if(pq3[i].z==pq3[i-1].z)
		{
			mx3[pq3[i].id]=mx3[pq3[i-1].id];
		}
		else
		{
			mx3[pq3[i].id]=last3[pq3[i].id]+1;
		}
	}
	for(int i=1;i<=n;++i) cout<<min({mx1[i],mx2[i],mx3[i]})<<endl;
	return 0;
}
```

---


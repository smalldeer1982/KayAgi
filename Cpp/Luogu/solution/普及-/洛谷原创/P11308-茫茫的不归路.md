# 茫茫的不归路

## 题目背景

NoitaCesaE 的匹配机制总是很奇怪，小 $ \zeta $ 总是被匹配到与他的其他车队成员不同的阵营，这时他就没法享受被优质队友带飞的快感了。

## 题目描述

具体的，有 $ n $ 个阵营，每个阵营最多 $ m $ 人。已经有 $ p $ 个人被分配了所属的阵营，且此时每个阵营人数均不超限。

小 $ \zeta $ 的 $ k $ 人车队进入了这个房间，在不改变已经进入的 $ p $ 个人的所属阵营的情况下，如果他们能一起进入同一个阵营使得阵营人数不超过限制，那么就会进入同一个阵营，否则车队就分散进不同的阵营了。

请求出对于给定的 $ n,m,k,p $，任意的已经进入的 $ p $ 个人的阵营归属情况下，小 $ \zeta $ 的车队能够进入同一个阵营的**可能性情况**（具体参见输出格式）。

## 说明/提示

**【样例 1 解释】**

对于第一组数据，无论这个人在哪个阵营，都有至少两个阵营为空，因此一定可以容纳这个 $ 3 $ 人车队，故输出 `Together`。

**【数据规模与约定】**

对于 $ 40\% $ 的数据，$ T \le 10 $，$ n,m \le 4 $，$ k \le 6 $，$ p \le 10 $。

对于另 $ 20\% $ 的数据，保证输出没有 `Together`。

对于 $ 100\% $ 的数据，$ 1 \le T \le 1000 $，$ 1 \le n,m \le 10^4 $，$ 1 \le k \le 10^8 $，$ 0 \le p \le 10^8 $，$ p+k \le n \times m $。

## 样例 #1

### 输入

```
10
3 3 3 1
3 3 4 5
4 4 4 12
4 4 3 8
10 10 7 34
10 10 8 34
12 11 11 12
12 11 12 12
9 9 1 80
9 9 6 70```

### 输出

```
Together
Divide
Chance
Chance
Together
Chance
Chance
Divide
Together
Chance```

# 题解

## 作者：FeiYu32 (赞：10)

## 思路解析

根据这道题的输出要求，可以想到对应的做法——即数学中常见的分类讨论。

首先思考一下输出`Divide`的情况。如果说车队人数比车队人数的上限还多，那肯定是无解的。

然后思考一下输出`Together`的情况。如果无论已经进入的人如何归属，这个车队一定能进入同一个阵营，由于已经排除车队人数比车队人数的上限还多的情况，那么让车队无法进入同一个阵营的最优解就平均分配所有已经在房间中的人，判断人数最少的阵营所剩人数是否放得下整个车队。如果能，那肯定是一定有解的。

最后由于只有三种情况，那如果以上两种情况都不满足，那就一定是第三种输出`Chance`的情况了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        if(c>b)cout<<"Divide"<<endl;
        else if(d/a<=b-c)cout<<"Together"<<endl;
        else cout<<"Chance"<<endl;
    }
}
```

完结撒花！

---

## 作者：船酱魔王 (赞：5)

# T1.bedwars

## 题意回顾

$ n $ 个阵营，每个阵营 $ m $ 个名额，$ p $ 个玩家被随机分配到这些阵营里，请判断增加的 $ k $ 个玩家存在分配进入同一个阵营的分配方式的可能性情况。

## 分析

* 考虑 $ k>m $ 时，必然会分到不同的阵营，输出 `Divide`；

* 当 $ k \le m $ 时，如果强制保留下一个阵营一些席位的空间供这组玩家进入，然后剩下的人去剩下的位置的话，可以匹配进一个阵营，因此必然有可能匹配到一起，输出 `Chance` 或 `Together`；

* 继续考虑如何挤占掉这些增加的玩家进每种阵营的备选名额且使用最少的既有玩家：每个阵营人数正好为 $ m-k+1 $ 人，此时总人数为 $ c=n(m-k+1) $。$ p \ge c $ 意味着有可能避免这些增加的人匹配到一起输出 `Chance`，否则输出 `Together` 即可。

## 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int n, m, k, p;
int main() {
	cin >> T;
	for(int ti = 1; ti <= T; ti++) {
		cin >> n >> m >> k >> p;
		if(k > m) puts("Divide");
		else if(p >= (m - k + 1) * n) puts("Chance");
		else puts("Together");
	}
	return 0;
}
```

---

## 作者：Wendy_Hello_qwq (赞：5)

[题目传送门。](https://www.luogu.com.cn/problem/P11308)

[原文食用效果更佳。](https://www.luogu.com/article/7tt1j3pd)

## 题意

给定 $T$ 组数据，每组数据给定 $n,m,k,p$，分别表示有 $n$ 个阵营，每个阵营最多 $m$ 人，已经有 $p$ 个人被分配了所属的阵营，还有车队人数 $k$，求对于每组数据的情况：

- 如果无论已经进入的人如何归属，这个车队一定能进入同一个阵营，输出 `Together`。

-  如果存在部分已经进入的人的阵营归属，使得这个车队所有人进入同一个阵营，输出 `Chance`。

- 如果无论已经进入的人如何归属，这个车队的所有人必然进入不同的阵营，输出 `Divide`。

## 分析

这道题要**分类讨论**。

- 如果车队人数大于上限，无解，直接输出 `Divide`。

- 排除第一种情况，如果平均分配后可以放下剩下的位置，输出 `Together`。

- 如果前两种都不是，是最后一种情况，直接输出 `Chance`。

## Code

```cpp
#include <cstdio>
using namespace std;
int T, n, m, k, p;
int main() {
	scanf ("%d", &T);
	while (T--) {
		// 分类讨论 
		scanf ("%d%d%d%d", &n, &m, &k, &p);
		// 车队人数大于限，无解，输出 
		if (k > m) printf ("Divide\n");
		// 如果平均分能够放下剩下的位置，排除无解的情况，输出 
		else if (p / n <= m - k) printf ("Together\n");
		// 最后一种情况，直接输出 
		else printf ("Chance\n");
	}
	return 0;
}
```

[AC 记录。](https://www.luogu.com.cn/record/196566947)

完结撒花。

作者写题解不易，点个赞再走呗。

---

## 作者：Besheep (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P11308)
## 结论
对于一对数据 `4 4 X 9`，可分以下两种情况讨论（其实也是随便排放，将已有的全部推到顶）：

（在下图中，我们将每一列看作为一个阵营）

![](https://cdn.luogu.com.cn/upload/image_hosting/qqcxkpx0.png)

不难发现以下现象（如下图）：
- 在方法一中：每个阵营**空闲**人数至多为 $2$ 人，即为 $m$。
- 在方法二中：每个阵营**空闲**人数至多为 $4$ 人，即为 $m-\lfloor \frac{p}{n} \rfloor$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3p5flwjb.png)
令 $q=m-\lfloor \frac{p}{n} \rfloor$。

综上所述，可得出以下结论：
- 当车队人数在 $2$ 人以下（包括 $2$ 人）时，使用两种方法放置都可以满足。
- 当车队人数在 $2$ 人以上（不包括 $2$ 人），$4$ 人以下（包括 $4$ 人）时，此时只能满足方法二。
- 当车队人数在 $4$ 人以上（不包括 $4$ 人），使用两种方法放置都无法满足。

即：
- 若 $k\le q$ **且** $k \le m$，输出 `Together`。
- 若 $k\le q$ **或** $k \le m$，输出 `Chance`。
- 否则，输出 `Divide`。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
#define ll long long
ll T,n,m,k,p;
int main() {
    cin>>T;
    while(T--){
    	cin>>n>>m>>k>>p;
    	ll q=m-p/n;
    	if(k<=m||k<=q){
    		if(k<=m&&k<=q) cout<<"Together\n";
    		else cout<<"Chance\n";
		}
		else cout<<"Divide\n";
	}
	return 0;
}
```

---

## 作者：Seraphiel (赞：3)

### 思路
很简单的分类讨论。

1. 先考虑 Devide，如果车队人数均大于所有房间人数的上限，那么肯定不能分配在同一个房间，即输出 Devide。
2. 其次，我们假设每个房间的人数平分，即最劣解。因为如果让每个房间的人数平分则，再判断人数最少的阵营所剩人数是否放得下整个车队，如果最劣解能满足，则一定是 Together。
3. 如果上面情况均不满足，则是 Chance。

### code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
    int n,m,k,p;
		cin>>n>>m>>k>>p;
		if(m<k){
        cout<<"Divide\n";
    }
		else if(m-p/n>=k){
        cout<<"Together\n";
    }
		else{
    		cout<<"Chance"<<endl;
  	}
  }
	return 0;
}
```

---

## 作者：__CJY__ (赞：3)

这题赛时没调出来，赛后看看觉得真是太简单了！
## 题意简述
给定 $n$ 个阵营，每个阵营最多能容纳 $m$ 人。已经有 $p$ 个人被分配到了这些阵营中，且当前每个阵营的人数都没有超过限制。现在，有一个 $k$ 人的车队想要进入这些阵营中的一个。判断这个车队是否能够全部进入同一个阵营，考虑所有可能的已进入人员的分配情况。
## 思路
### Solution $1$
* 当 $k>m$ 时，直接输出`Divide`。
* 我们判断是否存在一种方法使得 $k$ 个人无法在同一个队，这种方法至少需要让每个阵营人数达到 $m-k+1$。所以当 $p \ge n \times (m−k+1)$ 时，输出`Chance`。
* 否则输出`Together`。
### Solution $2$（极度推荐）
* 当 $k>m$ 时，直接输出`Divide`。
* 我们考虑最坏情况每个阵营原来都有 $p \div n$ 个人，**注意是 $p \div n$ 而不是 $p \div m$，赛时我就是这样爆零的**。$m-p \div n$ 就是每个阵营的剩余人数，我们记作 $c$。当 $c \ge k$ 时，一定能在一起。所以当 $m-p \div n \ge k$ 时，输出`Together`。
* 否则输出`Chance`。
## Code
### Code $1$
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;cin>>T;
	while(T--){
		int n,m,k,p;cin>>n>>m>>k>>p;
		if(k>m) cout<<"Divide\n";
		else if(p>=n*(m-k+1)) cout<<"Chance\n";
		else cout<<"Together\n";
	}
}
```
### Code $2$（极度推荐）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;cin>>T;
	while(T--){
		int n,m,k,p;cin>>n>>m>>k>>p;
		if(k>m) cout<<"Divide\n";
		else if(m-p/n>=k) cout<<"Together\n";
		else cout<<"Chance\n";
	}
}
```

---

## 作者：monkeyking_QAQ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11308)

### 思路：

通过判断车队人数 $k$ 与剩余空位的关系，输出对应的情况：

+ 第一种情况：存在某个阵营，剩余的空位数量大于等于 $k$，就满足车队一定能进入同一个阵营的条件。可以通过遍历去看是否有阵营满足 $m$ 减去 $\displaystyle \frac{p}{n}$ 是否大于或等于当前阵营已有人数，而由于前提限定每个阵营人数均不超限且我们只需判断能否满足一起进入同一个阵营的可能性，所以只要有一个阵营满足 $m-\displaystyle \frac{p}{n} \ge k$，就输出`Together`。
  
+ 第二种情况：如果车队人数比每个阵营最多容纳人数还多，输出`Divide`。
  
+  第三种情况：当前两个条件都不满足时，就意味着存在一部分已进入人员的阵营归属情况，使得车队有可能进入同一个阵营，输出`Chance`。

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,p;
int main(){
int T; 
    cin>>T;
    while(T--){
    	cin>>n>>m>>k>>p;
    		if(m-p/n>=k) //第一种情况
            cout<<"Together"<<endl;
        else if(k>m) //第二种情况
            cout<<"Divide"<<endl;
        else  //最后一种情况
            cout<<"Chance"<<endl;
	}
    return 0;
}
```

---

## 作者：Program_A2 (赞：2)

## 思路

这个问题本质上是抽屉问题，我们可以考虑最极端的情况，即先将 $p$ 平均分配到每个阵营，如果存在一个阵营能够包含这个车队的所有人，说明这个车队一定能进入同一个阵营。相反的，如果 $k>m$，说明不可能进入同一个阵营，如果这也不是，那么说明存在一种情况使他们进入同一种车队。

## 代码


```cpp
#define I return
#define AK 0
#define IOI ;
#include "bits/stdc++.h"
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m,k,p;
		cin>>n>>m>>k>>p;
		if(m-p/n>=k)cout<<"Together";
		else{
			if(k>m)cout<<"Divide";else cout<<"Chance";
		}
		cout<<endl;
	}
    I AK IOI
}

```

---

## 作者：Michael_114 (赞：2)

~~这道题卡我赛时很多小时！！！！~~

先看要求，这道题的 Divide 条件其实不难想，只有两种可能：

1. 剩余人数不足 $k$。
2. 每个阵营人数小于 $k$。

但关于 Chance 和 Together 条件的区分需要花上一些时间。

其实，Together 条件就是已经进入的人均分，每个阵营剩下的人数依旧大于 $k$。

然后，剩余情况只可能为 Chance 了。

代码：


```
#include<iostream>
using namespace std;
typedef long long ll;
ll t,n,m,k,p;
int main()
{
	ios::sync_with_stdio(0);
	cin>>t;
	while(t--){
		cin>>n>>m>>k>>p;
		if(k>m||p>n*m-k){
			cout<<"Divide"<<endl;
		}
		else if(m-(p/n)>=k){
			cout<<"Together"<<endl;
		}else {
			cout<<"Chance"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Miracle_InDream (赞：2)

赛时调了半天。

直接上思路：

一旦一个 $k$ 人车队的人数比 $m$ 大，这个车队直接就不可能在一起了，输出 ```Divide```。

否则我们可以把那 $p$ 个人平均一下……一旦这些人平均在每个阵营后，剩下的位置比这个车队的人数少，那就要看运气了，输出 ```Chance```。

否则，整个车队一定在一起，输出 ```Together```。

直接上代码（不用加注释了吧，上面已经解释了）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,m,k,p;
		cin>>n>>m>>k>>p;
		if(k>m)
		{
			cout<<"Divide"<<endl;
		}
		else if(m-p/n<k)
		{
			cout<<"Chance"<<endl;
		}
		else
		{
			cout<<"Together"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：1)

## 解题思路：
分类讨论。
1. `Divide` 的情况：  
  容易发现 `Divide` 有两种情况，一是**车队人数比房间最大容量大**，二是**在所有人占最少房间的情况下，车队依旧进不去同一个房间**。  
  对于第一种情况，直接判断 $k > m$ 即可。  
  对于第二种情况，要满足两个条件。**这些人在用尽可能少的房间的情况下，依然只剩一间或零间**，且**这间（若有）剩下的位置不够车队进入。**
2. `Together` 的情况：  
   在**最坏的，即刚好每间的人数让车队塞不下的情况下**，依然**还至少剩一间房间。**
3. `Chance` 的情况：  
   即其余情况。
## CODE：
```cpp
#include <iostream>
using namespace std;
int t, n, m, k, p;
int s(int a, int b){return (a % b == 0 ? a / b : a / b + 1);}
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> n >> m >> k >> p;
        if (k > m)
        {
            cout << "Divide\n";
            continue;
        }
        int num = n - s(p, m);
        if (num < 1 && k > m - (p % m)) cout << "Divide\n";
        else
        {
            if (n - (p / (m - k + 1)) >= 1) cout << "Together\n";
            else cout << "Chance\n";
        }
    }
    return 0;
}
```

---

## 作者：QingDeng_Star (赞：1)

## 思路
应该比较好想吧。

看到题目中有“如果……，那么输出……”的字眼，很明显的是分情况讨论思想。然后这道题输出 ```Divide``` 和 ```Together``` 的情况比较好写，所以先讨论它们，剩下的就是 ```Chance``` 了。

现在有 $k$ 个人，每个阵营的人数上限为 $m$。如果说 $m\le k$，那么这 $k$ 个人绝对分不到一起去，就输出 ```Divide```。

那么要想让这 $k$ 个人进入到一个阵营去，最优策略是所有已分配的 $q$ 个人平均的分配到了 $n$ 组里，然后再找人数最少的那个阵营里能不能容下 $k$ 人，如果行，输出 ```Together```，如果不行 ```Divide``` 讨论完了，只剩下 ```Chance``` 了。
## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int n,m,k,q;
        cin>>n>>m>>k>>q;
        if(k>m)
			cout<<"Divide"<<endl;//连最大人数限制都不够 k 人的情况 
        else if(q/n<=m-k)
			cout<<"Together"<<endl;//最小人数的阵营可以容下 k 人 的情况 
        else 
			cout<<"Chance"<<endl;//第三种在能匹配到和不能匹配到之间徘徊的情况 
    }
    return 0;
}
```

---

## 作者：Pyrf_uqcat (赞：1)

看到题板中三种答案以及是道橙题，就知道这是一道判断条件的水题。

当 $k > m$ 时，即车队人数大于限制人数，一个阵营放不下那么多人，输出`Divide`。

判断`Together`的情况，想要在一个阵营就需要已经在这个阵营的人尽量少，最好的情况就是平均分每个阵营 $\frac{p}{m}$ 人，当剩下的数量可以容下 $k$ 个人，说明`Toghther`。

否则`Chance`。

```
#include <bits/stdc++.h>
#define int long long

#define N

using namespace std;

int t,n,m,k,p;

signed main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>k>>p;
		if(k>m) cout<<"Divide"<<endl;
		else if(m-(p/n)>=k) cout<<"Together"<<endl;
		else cout<<"Chance"<<endl;
	}
	return 0;
}
```

---

## 作者：LittleAcbg (赞：1)

考虑分类讨论。

## `Divide`

![](https://cdn.luogu.com.cn/upload/image_hosting/o483g9wz.png)

如图，列代表阵营，红色色块代表玩家，我们贪心地将已加入游戏的人尽可能放在同一阵营。

此时如果有至少一个空阵营，如果 $k>m$，车队就无法加入同一阵营，否则就可以。

![](https://cdn.luogu.com.cn/upload/image_hosting/kidj9bdw.png)

如果没有空阵营（如上图），由于 $k+p\le n\times m$，此时也一定可以加入，并且也满足 $k\le m$。

因此我们得到 `Divide` 的条件为 $k>m$。

## `Together`

![](https://cdn.luogu.com.cn/upload/image_hosting/rdrcsn1c.png)

如图，我们尽可能将已加入游戏的玩家放置在不同阵营。此时每个阵营的空位最大值最小，只要此时仍可以加入同一阵营，就是 `Together`。

下图就是一个 `Together` 的情况（蓝色代表车队）：

![](https://cdn.luogu.com.cn/upload/image_hosting/apbquu8e.png)

下图是非 `Together` 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/mm8zqyab.png)

分析公式。只要已加入游戏的玩家无法将位置填满到每个阵营都只有至多 $k-1$ 个空位，那么必定有至少一个阵营有 $k$ 个空位，车队可以加入。

填满所需要的玩家数量是，每个阵营至少 $m-(k-1)=m-k+1$ 个玩家，共 $n\times(m-k+1)$ 个。

故 `Together` 的条件为 $p<n\times(m-k+1)$。

## `Chance`

如果不保证 `Divide` 也不保证 `Together`，就输出 `Chance`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,m,k,p;
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d%d%d", &n, &m, &k, &p);
        if (k > m) puts("Divide");
        else if (p < n * (m - k + 1)) puts("Together");
        else puts("Chance");
    }
    return 0;
}
```

---

## 作者：sikunran (赞：1)

这是本人第一次写题解。

先上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,m,k,p;
int main(){
	cin>>T;
	for(long long i=1;i<=T;i++){
		cin>>n>>m>>k>>p;
		if(m<k){
			cout<<"Divide"<<endl;
		}
		else if(m-p/n>=k){
			cout<<"Together"<<endl;
		}
		else if(n*m-p>=k){
			cout<<"Chance"<<endl;	
		}
		else{
			cout<<"Divide"<<endl;
		}
		
	} 
	return 0;
}
```

这题其实是道数学题。思路如下：

首先如果小 $\zeta$ 的车队人数 $k$ 已经大于每队最高人数 $m$ 了，那么**一定无法分到一队。**

**即 $k \geq m$ 时。**

```cpp
if(m<k){
  cout<<"Divide"<<endl;
}
```

**然后看一定能进入同一阵营的情况**。就是已进入 $p$ 个人分配情况最不利——也就是平均分到每队时，小 $\zeta$ 的车队依然能进入同一队。

**即 $ m-\frac{p}{n} \geq k$ 时。**

这里直接用 `(m-p)/n` 计算每队平均剩余空位数。`/` 会自动向下舍入，所以求出的就是平均剩余空位数中最大的一组。
```cpp
else if((m-p/n)>=k){
	cout<<"Together"<<endl;
}
```
**现在考虑不一定能进入同一阵营的情况**。刚刚排除了一定进入同一阵营的情况，那么剩下的情况中只要 $p$ 最有利的分配情况——所有人集中分配，充满一个队后再进入下一个队时，车队能进入一队，那么就有可能分配到一队。

**即 $(m \times n - p) \geq k$ 时。**
```cpp
else if((n*m-p)>=k){
    cout<<"Chance"<<endl;	
}
```

**剩下的情况都不可能进入一队（其实就根本不可能进入该房间了）。**


```cpp
else{
    cout<<"Divide"<<endl;
}
```
当然，你也可以变换一下判断顺序，**先判断所有不可能的情况**，这样就不用判断 `Chance` 的情况了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,m,k,p;
int main(){
	cin>>T;
	for(long long i=1;i<=T;i++){
		cin>>n>>m>>k>>p;
		if(m<k || m*n<p+k){
			cout<<"Divide"<<endl;
		}
		else if(m-p/n>=k){
			cout<<"Together"<<endl;
		}
		else{
			cout<<"Chance"<<endl;	
		}
		
	} 
	return 0;
}
```


##### 为啥这会是道橙题？

---

## 作者：z_yq (赞：1)

# 思路
我们考虑非 Divide 的情况，因为最后剩余的情况就是 Divide。\
由抽屉原理的思想得到，如果每一个组里面的人都尽可能平均分，那么这肯定是最不优的情况，感性理解一下就可已发现。所以如果尽可能平均分都任然可以让整个车队的人进入一个组，那么答案就是 Together。\
那什么情况是 Change 呢，当然就只有每一次这个组的人满了再往后溢，可以理解为一组一组慢慢填，只要剩下的人数大于车队人数，那么就还是有可能的。\
剩下的情况就是 Divide 了。
# $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,m,k,p;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>m>>k>>p;
		if(k<=m && (m-k+1)*n>p) cout<<"Together\n";
		else if(k<=m && n*m-k>=p) cout<<"Chance\n";
		else cout<<"Divide\n";
	}
	return 0; 
}
//10 10 7 34
//4 4 3 8
```

---


# 「HCOI-R2」光影

## 题目背景

我心中有一片幽暗的角落，

那是夜的领域，是我的故乡，

我将和许许多多的人一样，

回到那纯洁的地方，

纵使黑暗也无妨。

## 题目描述

给你一个长度为 $n$ 的 01 串，你要删掉其中 $k$ 个 `0`。

称极长的每一位数字都相同的子串为一个“块”。求能使 `1` 连成的最小块数。

## 说明/提示

### 样例解释 1
删除位置在 $2,7$ 的 `0`。

### 数据规模与约定

**本题采用捆绑测试。**

+ Subtask 0（30 pts）：$n\leq10^4$。
+ Subtask 1（30 pts）：$e\leq10$。
+ Subtask 2（40 pts）：无特殊限制。

$e$ 表示 01 串中 `0` 的个数。

对于所有数据，$1\leq k\leq e\leq n\leq10^7$。

## 样例 #1

### 输入

```
8 2
10100101```

### 输出

```
2```

## 样例 #2

### 输入

```
16 5
0100100010100100```

### 输出

```
2```

# 题解

## 作者：_hud (赞：8)

# 题解：[P12350 「HCOI-R2」光影](https://luogu.com.cn/problem/P12350)

## 思路
题目要求通过删除 $k$ 个 $0$，使得剩余的 $1$ 块数最少。故不难想到**贪心**。显然，若两个 $1$ 块之间有 $m$ 个 $0$，删除其中 $m$ 个 $0$ 即可合并这两个块。为了最小化块数，应优先删除间隔最小的两个 $1$ 块中间的 $0$ ，因为它们能用更少的删除次数合并更多块。不难得出这个贪心策略是成立的。

实现就不细讲了，具体可以看代码。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, sep[10000010], cnt = 1, ans;
string s;
signed main() {
    cin.tie(0), cout.tie(0)->sync_with_stdio(0);
    cin >> n >> k >> s;
    int tmp = 0, i = 0;
    // 去除前导零，因为其对答案没有贡献
    for(; i < n; i++)
        if(s[i] == '1' && s[i+1] != '1') break;
    for(i++; i < n; i++)
        if(s[i] == '1') {
            if(s[i-1] != '1') // 前一个字符是0，说明前面是一个完整的间隔，记录
                sep[cnt++] = tmp, tmp = 0;
        } else tmp++;
    sort(sep+1, sep+cnt);
    // 计算初始块数
    for(int i = 0; i < n; i++) 
        if(s[i] == '1' && s[i-1] != '1')
            ans++;
    if(ans == 0) { // 特判
        cout<< 0 << '\n'; 
        return 0; 
    }
    for(int i = 1; i < cnt; i++)
        if(k >= sep[i]) // 当前间隔足够删除
            ans--, k -= sep[i];
        else break; // 否则不够，退出
    cout << ans;
    return 0;
}
```

---

## 作者：volatile (赞：3)

# 思路

贪心算法，先统计有多少个连续的 `1`，用 $sum$ 变量记录。通过从小到大排序每两个相邻的 `1` 的距离，然后遍历，如果 $k$ 或者 $sum$ 有一个为 $0$ 就结束遍历，否则如果 $k$ 不小于当前距离就用 $k$ 减去距离，同时会少一个“块”，就把 $sum$ 减一。

# 代码


```cpp
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
struct st{
    int a,l;
};
vector<st>v;
bool cmp(st x,st y)
{
    if(x.l!=y.l) return x.l<y.l;
    return x.a<y.a;
}
int main()
{
    int n,k,t=-1,sum=0;
    string s;
    cin>>n>>k>>s;
    for(int i=0;i<n;i++){
        if(s[i]=='1'){
            if(t!=-1&&i!=t+1){
                st tt;
                tt.a=t;
                tt.l=i-t-1;
                v.push_back(tt);
            }
            if(i==0) sum++;
            else if(s[i-1]!='1') sum++;
            t=i;
        }
    }
    sort(v.begin(),v.end(),cmp);
    for(int i=0;i<v.size();i++){
        if(k==0||sum==0) break;
        if(v[i].l<=k){
            sum--;
            k-=v[i].l;
        }
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：天使宝贝 (赞：2)

[题面传送门](https://www.luogu.com.cn/problem/P12350)
### 思路&分析
很明显的贪心，优先选两个 `1` 之间 `0` 的个数较少的删除。

难点都在代码实现上，具体的：

1. 不难发现，开头的 `0` 和末尾的 `0` 删除不能使 `1` 合并在一起，所以直接略过即可。

2. 如果整个 01 串都没有 `1`，那答案显然为 $0$。

3. 对于每一段连续的 `0`，我们可以统计它们的数量，记为 $v_i$，然后把 $v$ 从小到大排序，顺序遍历，每次把 $k$ 减去 $v_i$，直到不够了为止。有一个问题就是，我们可以发现，我们正面直接求合并得到了多少，不是太好求，所以我们可以倒过来，每次合并，把分散着的 `1` 的段数减 $1$ 即可。

### CODE
```cpp
#include <bits/stdc++.h>
#define int long long
#define il inline
#define cs constexpr
#define endl '\n'
#define IOS ios::sync_with_stdio(0), ios_base::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define dep(i, a, b) for (int i = (a); i >= (b); i--)
#define pb push_back
#define PII pair<int, int>
#define mkp make_pair
#define st first
#define nd second
#define ull unsigned long long
#define db double
#define ldb long double
#define all(x) (x).begin(), (x).end()
#define mxele *max_element
#define mnele *min_element
#define INF (int)(0x3f3f3f3f3f3f3f3f)
using namespace std;
int n, k, cnt1, cnt2, top, ans, tmp;
string s;
vector<int> v;
signed main() {
	IOS;
	cin >> n >> k;
    cin >> s;
    s = '$' + s;
    rep(i, 1, n) {
        if (s[i] == '1') {cnt1 = i; break; }
    }
    dep(i, n, 1) {
        if (s[i] == '1') {cnt2 = i; break; }
    }
    bool flag = 1;
    rep(i, 1, n) {
        if (s[i] == '1') flag = 0;
    }
    if (flag) return cout << 0 << endl, 0;
    if (cnt1 == 0) return cout << 0 << endl, 0;
    if (cnt2 == 0 && s[cnt2] == '0') return cout << 0 << endl, 0;
    rep(i, cnt1, cnt2) {
        if (s[i] == '0') {
            tmp++;
        } else if (s[i] == '1'){
            v.pb(tmp);
            tmp = 0;
        }
    }
    tmp = 0;
    rep(i, cnt1, cnt2) {
        if (s[i] == '1') {
            tmp++;
        } else if (s[i] == '0') {
            if (tmp) ans++;
            tmp = 0;
        }
    }
    ans++;
    sort (all(v));
    for (auto x : v) {
        if (x == 0) continue;
        if (k - x < 0) break;
        else {
            k -= x;
            ans--;
        }
    }
    if (ans < 1) cout << 1 << endl;
    else cout << ans << endl;
	return 0;
}
```

---

## 作者：HP_Serenity (赞：2)

~~居然还能写题解。~~

要求删除 $k$ 个 `0` 之后，让 `1` 的块数最少。

可以先记录所有 `0` 的位置，初始化 `1` 的块数。再确定 `1` 块之间 `0` 的数量，即合并这两个 `1` 块要删除 `0` 的个数。开始贪心，优先合并间隔 `0` 数量少的 `1` 块。

具体的体现可以看到代码：
```c++
#include <bits/stdc++.h>
using namespace std;
int n, k, z[10000005], m, g[10000005], cnt, lop = -1, res, used;
char s[10000005];
int main() {
    ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);
    cin >> n >> k >> (s+1);
    // 记录 0 的位置
    m = 0;
    for(int i=1; i<=n; i++)
        if(s[i]=='0') z[++m] = i;
    // 计算 1 块之间的 0 的数量
    cnt = 0;
    for(int i=1; i<=n; i++) {
        if(s[i]=='1') {
            if(lop!=-1&&i>lop+1) g[cnt++] = i-lop-1;
            lop = i;
        }
    }
    // 初始 1 的块数计算
    for(int i=1; i<=n; ) {
        if(s[i]=='1') {
            res ++;
            while(i<=n&&s[i]=='1') i ++;
        } else i ++;
    }
    // 贪心合并 1 块
    sort(g, g+cnt);
    for(int i=0; i<cnt; i++) {
        if(used+g[i]<=k) {
            used += g[i];
            res --;
        } else break;
    }
    cout << res;
    return 0;
}
```

---

## 作者：yangfengzhao (赞：1)

## 思路
大意：为了将尽可能多的 `1`（分散的）合并成尽可能少的“块”。\
令 ${S_{t}}$ 表示 ${t}$ 与 ${t+1}$ （两个 `1`）之间所有 `0` 的个数。如果 ${k>S_{A}>S_{B}}$，那么删除区间 ${[B,B+1]}$ 会比删除 ${[A,A+1]}$ 要优。\
首先，将所有 `1` 的位置找出来，将索引放入 `Lkd` 中。\
其次，计算每一个 ${S_{t_{i}}}$，排序。
最后，照题意，从小到大删除 `0`，然后输出。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    vector<int> ones; // 存储所有 '1' 的位置

    // 读取输入并记录 '1' 的位置
    for (int i = 0; i < n; ++i) {
        char c;
        scanf(" %c", &c);
        if (c == '1') ones.push_back(i);
    }

    if (ones.empty()) { // 没有 '1' 的情况
        printf("0\n");
        return 0;
    }

    // 计算初始块数：连续的 '1' 视为一个块
    int initial_ones = 1;
    for (int i = 1; i < ones.size(); ++i) {
        if (ones[i] != ones[i-1] + 1) initial_ones++;
    }

    // 计算相邻块之间的间隙
    vector<int> gaps;
    int prev_end = ones[0]; // 前一个块的最后一个 '1' 的位置
    for (int i = 1; i < ones.size(); ++i) {
        if (ones[i] != ones[i-1] + 1) { // 发现新块
            int gap = ones[i] - prev_end - 1;
            if (gap > 0) gaps.push_back(gap);
            prev_end = ones[i];
        } else {
            prev_end = ones[i]; // 同一块内，更新末尾位置
        }
    }

    sort(gaps.begin(), gaps.end()); // 按间隙大小排序

    // 贪心合并：优先删除小间隙
    int merge_cnt = 0;
    for (int g : gaps) {
        if (k >= g) {
            k -= g;
            merge_cnt++;
        } else break;
    }

    printf("%d\n", initial_ones - merge_cnt);
    return 0;
}
```

---

## 作者：saixingzhe (赞：1)

# 分析

容易发现删的 `0` 一定是一个最长的连续一段，每删除一段 `0` 可以使他左右的 `1` 合并起来，从而使答案减少一，最优策略是删除长度最短的 `0` 段。

我们先统计一开始 `1` 的块数，思考如何统计 `0` 段，需要注意的是最前面的和最后面的 `0` 段不需要统计，我们遍历数组，每遇到一个 `1` 记录它到前面最后一个 `1` 的距离减一即是该 `0` 段长度。

对于统计的 `0` 段长度，我们可以将其排序，从小开始删除，复杂度 $\mathcal O(n\log n)$，进行优化，我们使用桶排序，复杂度 $\mathcal O(n)$。当然 $\mathcal O(n \log n)$ 使用 $\operatorname{sort}$ 函数常数极小，也可以通过。

# 代码
使用桶排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[10000005],flag,l,ans;
string s;
int main(){
	cin>>n>>k>>s;
	for(int i=0;i<n;i++){
		if(s[i]=='1'){
			if(!flag)	flag=1,ans++;
			else{
				a[i-l-1]++;
				if(i-l-1)	ans++;
			}	
			l=i;
		}
	}
	for(int i=1;i<=1e7&&k>=i;i++){
		int x=min(k/i,a[i]);
		ans-=x;
		k-=i*x;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：PKUS_zmj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12350)
# 思路
可以将字符串划分为块，筛选出可合并 $1$ 块的 $0$ 块，再利用贪心策略优先删除长度小的 $0$ 块，最终得到 $1$ 块的最小数量。这种方法确保在删除 $k$ 个 $0$ 的限制下，最大程度减少 $1$ 的块数。
# AC Code
码前提示：抄题一时爽，棕名两行泪。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Blk
{
    char c;
    int cnt;
};
int main()
{
    int n,k;
    string s;
    cin>>n>>k>>s;
    vector<Blk> bs;
    Blk curBlk={s[0],1};
    for(int i=1;i<n;++i)
    {
        if(s[i]==curBlk.c) curBlk.cnt++;
        else
        {
            bs.push_back(curBlk);
            curBlk.c=s[i];
            curBlk.cnt=1;
        }
    }
    bs.push_back(curBlk);
    int m=0;
    for(const auto& b:bs) if(b.c=='1') m++;
    vector<int> zs;
    for(int i=0;i<bs.size();++i) if(bs[i].c=='0') if(i>0&&i<bs.size()-1&&bs[i-1].c=='1'&&bs[i+1].c=='1') zs.push_back(bs[i].cnt);
    sort(zs.begin(),zs.end());
    int sum=0;
    int x=0;
    for(int z:zs)
    {
        if(sum+z<=k)
        {
            sum+=z;
             x++;
        }
        else break;
    }
    cout<<m-x;
    return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 思路
我们可以通过删除 $k$ 个 $0$，尽可能合并 $1$ 的块，从而减少 $1$ 的块数。

首先，我们先记录字符串中 $1$ 的块和它们之间的 $0$ 的块，考虑尽可能多的把这些 $0$ 的块删掉。

对于每个相邻的 $1$ 的块之间的 $0$ 的块，记录这些 $0$ 的块中 $0$ 的数目。然后我们将这些 $0$ 的块的 $0$ 的数目收集起来，并按从小到大的顺序排序，以便优先删除那些数目较小的 $0$ 的块，这样可以用最少的删除次数合并最多的 $1$ 的块。

将收集到的 $0$ 的块的数目排序后，依次处理。每次处理一个 $0$ 的块：
* 如果当前剩余的 $k$ 足够删除整个 $0$ 的块，则删除它，合并相邻的 $1$ 的块，减少 $1$ 的块数，并减去相应的 $0$ 的数目。
* 如果剩余的 $k$ 不足以删除整个 $0$ 的块，则停止处理。这样，每次操作都能最大程度地减少 $1$ 的块数。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>a;string s;int n,k,ans=1,i;
int main(){
	cin>>n>>k>>s;
	//跳过前导 0
	while(i<n&&s[i]=='0') i++;
	//全部是 0，没有 1 的块
	if(i==n){cout<<0;return 0;}
	while(i<n){
		if(s[i]=='1'){i++;continue;}
		int c=0;
		while(i<n&&s[i]=='0') c++,i++;
		if(i<n&&s[i]=='1') a.push_back(c),ans++;
	}
	sort(a.begin(),a.end());
	for(int v:a) {
		if(k>=v) k-=v,ans--;
		else break;
	}
	cout<<ans;
}
```

---

## 作者：BNCDBD (赞：1)

先把 $ans$ 赋值为 `1` 的数量。\
统计出除第 $1$ 个外的每个 `1` 到前一个 `1` 之间的 `0` 的数量，存入一个 vector ，再按升序排序。在 vector 里循环一遍，如果选了当前的数之后选的数的总和不会超过 $k$，这个数就可以选上，加入总和并把 $ans$ 自减，否则直接退出循环。

### Code

```cpp
#include<bits/stdc++.h>
#define maxn 10000005
#define pb push_back
using namespace std;
int n,k;
char s[maxn];
vector<int> v;//vector
int main(){
	scanf("%d%d%s",&n,&k,s+1);
	int cnt=0,ans=0;
	bool flag=true;//记录是不是第一个1
	for(int i=1;i<=n;++i){
		if(s[i]=='1'){
			++ans;
			if(flag){
				flag=false;
			}else{
				v.pb(cnt);//把当前0的数量推入vector
			}
			cnt=0;//重置cnt
		}else{
			++cnt;
		}
	}
	sort(v.begin(),v.end());//排序
	int rest=k;
	for(int i=0;i<v.size();++i){
		if(v[i]<=rest){
			rest-=v[i];//选入v[i]
			--ans;//去掉一段
		}else{
			break;//之后一定没有可以再选的了，退出循环
		}
	}
	printf("%d",ans);
	return 0;//结束qwq
}
```

---

## 作者：TLE_qwq (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12350)
### 解题思路
因为，$1$ 的块数由它们之间的 $0$ 分隔决定。删除这些 $0$ 可以合并相邻的 $1$ 块。所以，我们要优先删除位于两个 $1$ 块之间的 $0$ 块，这样可以合并更多的 $1$ 块。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(void) {
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    vector<int> v;//用 vector
    int i = 0;
    while (i < n && s[i] == '0') {//统计 0 的块数
        i++;
    }
    while (i < n) {//循环
        if (s[i] == '1') {//统计 1 的块数
            i++;
            continue;
        }
        int start = i;
        while (i < n && s[i] == '0') {
            i++;
        }
        if (start > 0 && i < n && s[start-1] == '1' && s[i] == '1') {
            v.push_back(i - start);
        }
    }
    sort(v.begin(), v.end());//排序
    int res = 0;
    int m = 0;
    for (int j = 0; j < n; ) {
        if (s[j] == '1') {
            m++;
            while (j < n && s[j] == '1') {
                j++;
            }
        } else {
            j++;
        }
    }
    if (m == 0) {//特判
        cout << 0 << endl;
        return 0;
    }
    res = m;
    for (int cnt : v) {
        if (k >= cnt) {
            k -= cnt;
            res--;
        } else {
            break;
        }
    }
    cout << res;//输出
    return 0;//完结撒花 
}
```

---

## 作者：linch (赞：0)

## Solution
**当且仅当**删除相邻两个 $1$ 中间所有 $0$ 后，两个 $1$ 才会连成了一个“块”。此时“块”的数量会减 $1$。

要求让块的数量最少，让更多的 $1$ 连在一起即可。假设第 $i$ 个 $1$ 和第 $i+1$ 个 $1$ 其中有 $a_i$ 个 $0$，此时让它们连起来需要花费 $a_i$ 的代价。

考虑贪心。对于 $i,j$，若有 $a_i\le a_j$，即选 $i$ 花费的代价更小，显然选 $i$ 不劣于选 $j$。因此按照 $a_i$ 排序，选择尽可能小的删除即可。

注意两个相邻的 $1$ 其代价为 $0$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e7+10;
int n, k, a[maxn], cnt, b[maxn], c[maxn], mx, ans;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		char ch;
		cin >> ch;
		a[i] = ch - '0';
		if (a[i] == 1) b[++cnt] = i;
	}
	for (int i = 1; i < cnt; i++) {
		c[b[i + 1] - b[i] - 1]++;
		mx = max(mx, b[i + 1] - b[i] - 1);
	}
	ans = cnt;
	for (int i = 0; i <= mx; i++) {
		if (k >= i * c[i]) {
			k -= i * c[i];
			ans -= c[i];
		} else {
			int x = k / i;
			k -= x * i;
			ans -= x;
		}
	}
	cout << ans << "\n";
	return 0;
}
```
[AC record](https://www.luogu.com.cn/record/215129313)

---


# 疯狂的采药

## 题目背景

此题为纪念 LiYuxiang 而生。


## 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。

## 样例 #1

### 输入

```
70 3
71 100
69 1
1 2
```

### 输出

```
140
```

# 题解

## 作者：⚡小林子⚡ (赞：328)

一道考察完全背包的题目。

[题目传送门](https://www.luogu.com.cn/problem/P1616)

upd：添加了对完全背包状态转移方程式的详细推导过程。

------------

### 正文

设 $f_{i,j}$ 表示前 $i$ 件物品采药 $j$ 时间能获得的最大价值。

可以列出状态转移方程：

$$
f_{i,j}=\max\limits_{k=0}^{k\le \frac{j}{w_i}} (f_{i-1,j-k\times w_i}+k\times v_i)
$$

使用二维 dp 显然超时超空间，考虑优化 dp。

把第 $i$ 种草药拆成体积为 $w_i\times 2$ 价值 $v_i\times 2$ 的物品，其中满足 $w_i\times 2\le j$。

- 对于第 $i$ 种草药的出现，我们对第 $i$ 种草药要不要采进行决策。如果不放那么 $f_{i,j}=f_{i-1,j}$；

- 如果确定采，那么应该出现至少一个第 $i$ 种草药，所以当前至少应该出现一个第 $i$ 种草药,即 $f_{i,j}=f_{i,j-w_i}+v_i$。

- $f_{i,j-w_i}$ 里面可能有第 $i$ 种草药，也可能没有第 $i$ 种草药。我们要确保当前至少有一个第 $i$ 个草药，所以要预留 $w_i$ 的空间来存放一个第 $i$ 种草药。

那么完全背包和 01 背包的不同点在哪里呢？

- 从二维数组上区别 01 背包和完全背包也就是状态转移方程就差别在采第 $i$ 种草药时，完全背包在选择采这个草药时，最优解是 $f_{i,j-w_i}+v_i$ 即同行的那一个，而 01 背包比较的是$f_{i-1,j-w_i}+v_i$，上一行的那一个。

时间优化完成了，但是此时空间还是会超，考虑滚动数组。

是否能滚动数组呢？答案当然是可以的。

假设只有一惟 $f_i$，如果是倒序推那么当前 $f_1$ ~ $f_{i-1}$ 都是上一个草药遗留下来的状态，显然不符合要求。

正序推的话 $f_1$ ~ $f_{i-1}$ 均为当前草药已经推过的状态，符合要求。

所以**完全背包和 01 背包的区别就在于对时间大小枚举的顺序不同。**

具体代码也就好写了：

```cpp
for(int i=1;i<=n;i++)
	for(int j=w[i];j<=m;j++)
		f[j]=max(f[j],f[j-w[i]]+v[i]);
```

以上为核心代码。

接下来要注意本题数据范围（有一个坑点）

本题最多有 $10^7$ 时间，每种草药的价值最大是 $10^4$，所以极限情况下价值总和是 $10^7\times 10^4=10^{11}$，会爆 int，所以要开 long long。

>十年 OI 一场空，不开 long long 见祖宗。

Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+5,M=1e7+5;
int n,m,w[N],v[N],f[M];
signed main(){
	scanf("%lld%lld",&m,&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&w[i],&v[i]);
	for(int i=1;i<=n;i++)
		for(int j=w[i];j<=m;j++)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	printf("%lld",f[m]);
	return 0;
}
```

[AC！](https://www.luogu.com.cn/record/37852677)

------------

### 总结

noip 临近，在此提醒大家做题一定要看数据范围，防止因为没开 long long 而遗憾失分。

建议使用 scanf 和 printf，虽然要打的字符多一些，但是时间更快（或者您使用 `ios::sync_with_stdio(0)` 也可以），防止考场上因为输入输出而 TLE。

# $\sf{The\,End.}$

---

## 作者：Veranda (赞：161)

本题解主要详细讲述了完全背包算法的原理

这题是一个标准的完全背包问题，在分析的时候我们就把题目中的背景去掉，体积就是时间，这样更有利于分析此题以及联想其他背包题目

不难得出递推式：$dp_i = max(dp_i,dp_{i-v} + w)$

————这里已经进行了数组压维，这样可以优化空间

我们先来假设一下输入数据是这样的：
```
4 5
1 2
2 4
3 4
4 5
```
不难看出输出应该是 $10$

**但是究竟是怎样得出这个结果的呢?**

下面展示一下原理：（ $v_i$ 为体积，$w_i$ 为价值）

```
首先dp数组初始化全为0：给定物品种类有4种，包最大体积为5，数据来源于题目的输入
v[1] = 1, w[1] = 2
v[2] = 2, w[2] = 4
v[3] = 3, w[3] = 4
v[4] = 4, w[4] = 5

i = 1 时： j从v[1]到5
dp[1] = max(dp[1],dp[0]+w[1]) = w[1] = 2 (用了一件物品1）
dp[2] = max(dp[2],dp[1]+w[1]) = w[1] + w[1] = 4（用了两件物品1）
dp[3] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] = 6（用了三件物品1）
dp[4] = max(dp[4],dp[3]+w[1]) = w[1] + w[1] + w[1] + w[1] = 8（用了四件物品1）
dp[5] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] + w[1] + w[1] = 10（用了五件物品）

i = 2 时：j从v[2]到5
dp[2] = max(dp[2],dp[0]+w[2]) = w[1] + w[1] = w[2] =  4（用了两件物品1或者一件物品2）
dp[3] = max(dp[3],dp[1]+w[2]) = 3 * w[1] = w[1] + w[2] =  6（用了三件物品1，或者一件物品1和一件物品2）
dp[4] = max(dp[4],dp[2]+w[2]) = 4 * w[1] = dp[2] + w[2] =  8（用了四件物品1或者，两件物品1和一件物品2或两件物品2）
dp[5] = max(dp[5],dp[3]+w[2]) = 5 * w[1] = dp[3] + w[2] =  10（用了五件物品1或者，三件物品1和一件物品2或一件物品1和两件物品2）

i = 3时：j从v[3]到5
dp[3] = max(dp[3],dp[0]+w[3]) = dp[3] = 6 # 保持第二轮的状态 
dp[4] = max(dp[4],dp[1]+w[3]) = dp[4] = 8 # 保持第二轮的状态 
dp[5] = max(dp[5],dp[2]+w[3]) = dp[4] = 10 # 保持第二轮的状态

i = 4时：j从v[4]到5
dp[4] = max(dp[4],dp[0]+w[4]) = dp[4] = 10 # 保持第三轮的状态
dp[5] = max(dp[5],dp[1]+w[4]) = dp[5] = 10 # 保持第三轮的状态

上面模拟了完全背包的全部过程，也可以看出，最后一轮的dp[m]即为最终的返回结果。

```

这便是完全背包的基本原理，应用到本题也是一样
 
那么这个算法的时间复杂度就是 $O(nm)$ 不会出现 $TLE$ 的情况

**注意：本题数据已更新，需要开 $longlong$ !**

下面附上AC代码：

```
//这里代码中t数组就是上面讲解的v数组，v数组是上面的w数组
//因为我写代码的时候按背景中的时间(time)和价值(value) 写的
#include<iostream>
#include<algorithm>
using namespace std;
const int maxm = 10010, maxt = 10000010;
long long v[maxm], t[maxm], f[maxt];//开longlong！
int main(){
	int T , m;
	cin >> T >> m;
	for(int i = 1;i <= m ;i ++) cin >> t[i] >> v[i];
	for(int i = 1;i <= m;i ++){
		for(int j = t[i];j <= T;j ++){
			f[j] = max(f[j],f[j - t[i]] + v[i]);
		}
	}
	cout << f[T];
}
```

感觉讲的挺详细的，完结撒花！

---

## 作者：black_trees (赞：29)


UPD1：原来有张图放错了，已修改 （20/12/17）[谢谢 @Rbu_nas 和 @ech_ooo
]

UPD2：因为使用图床更改（博客迁移），所以更新之后重发了一遍，并且修改了一部分叙述不清，无法理解的地方。

UPD3：修正笔误，更改部分描述。（21/8/8）

----

这一题和 [P1048](https://www.luogu.com.cn/problem/P1048)
的不同很明显：

+ 每种物品是无限制的

所以这是一道**完全背包**。

我们设 $f[i][j]$ 表示考虑前 $i$ 种物品，使用 $j$ 的空间可以获得的最大价值。

且 $v[i]$ 表示第 $i$ 种物品的体积（重量）， $c[i]$ 表示第 $i$ 种物品的价值。

想一想，我们如果需要得到 $f[i][j]$ ，那么需要知道什么状态才可以推导出它？

很明显，因为每次决策都是**选**或者**不选**。所以我们需要得到：$f[i-1][j]$ 和 $f[i-1][j-v[i]]+c[i]$

前者表示不选，后者表示选（去掉所选物品的体积，然后加上价值）。

但是，我们这里的每种物品有无限多个。

也就是说，如果我们倒序循环，那么所取到的用来更新的“上一个”状态可能是“未知”的。

因为我们动规的时候要保证方程的式子左边未知，右边全部已知（未知=已知）。

所以在循环的时候，空间的枚举范围是 $v[i] \le j \le m$ ， 也就是正序枚举（这就是完全背包和01背包的不同之处）。

（$m$ 表示背包的总体积）。

还有，现在数据被加强了，所以 `int` 会爆，要用 `long long`。

而且要用滚动数组来优化 （数据范围是 $10^7$，你不用滚动数组那就没了）。

如果不会滚动数组那么简单解释一下。

这里因为每一次转移都只会从 $f[i-1][sth]$ , 也就是上一层的状态转移过来。

而我们在更新这一层之前，上一层的值会被保留，所以可以去掉第一维。

那么代码如下：

```cpp
for(register int i=1;i<=n;++i){
	for(register int j=v[i];j<=m;++j){
		f[j]=max(f[j],f[j-v[i]]+c[i]);
		res=max(res,f[j]);//所有的可能当中取最大值
	}
}
```

记得看一下数组空间，记得开 $10^7$ 和 `long long`

```cpp
#define int long long
const int siz=1e7+10;
int f[siz];
```

加强过后的AC记录（同一份代码，有波动正常）：

[![cSKXrt.png](https://z3.ax1x.com/2021/03/27/cSKXrt.png)](https://imgtu.com/i/cSKXrt)

---

## 作者：s_r_f (赞：27)

完全背包问题$.$

记$dp_x$表示容量为$x$的背包的价值最大是多少$,$一开始$dp_x$都等于$0.$

每次加入一个容量为$w,$价值为$c$的物品之后更新$dp$数组的答案$.$

不难发现$dp'_x=max(dp_x,dp'_{x-w}+c).$

那么$,$更新的复杂度是$O(nm),$时间复杂度$O(nm),$空间复杂度$O(m).$

注意要开$long$ $long.$

代码 $:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 10000005;
LL f[N],w,c,n,m;
int main(){
	int i;
	cin >> m >> n;
	while (n--) for (cin >> w >> c,i = w; i <= m; ++i) f[i] = max(f[i],f[i-w]+c);
    cout << f[m] << '\n';
    return 0;
}
```

---

## 作者：Egg_eating_master (赞：20)

完全背包模板题。

考虑动态规划。原问题最重要的参数是草药的数目和采药的时间，那么我们很容易想到定义状态$dp_{i,j}$，表示在$j$时间内，采前$i$种草药能够取得的最大价值。

关键是状态转移方程。

对于每一草药$i$，都有采和不采两种状态。设当前采药时间上限为$j$，那么：

1. 采第$i$种草药，那么用来采前$i-1$种草药的时间只剩$j-a_i$了，前$i-1$种草药能取得的最大价值就是$dp_{i-1,j-a_i}$。再加上第$i$种草药的价值，总共就是$dp_{i-1,j-a_i}+b_i$。然而每种草药可以采摘无限多次，所以我们要使用更新过的值$dp_{i,j-a_i}+b_i$。

2. 不采第$i$种草药，那么在当前的草药上就不需要花费任何时间，当前草药就完全是废的，没用。只需考虑前$i-1$种草药。最大价值为$dp_{i-1,j}$。

由于每次状态转移都只需要用到上一种草药更新的值，所以可以考虑把$dp$数组的第一维压掉。最后的状态转移方程：`dp[j]=max(dp[j],dp[j-a[i]]+b[i])`

那么就可以上代码了。
```
#include<bits/stdc++.h>
#define int long long//不开ll见祖宗
using namespace std;
int n,m;
int a[10001];
int b[10001];
int dp[10000001];
signed main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	    cin>>a[i]>>b[i];
	for(int i=1;i<=n;i++)
	    for(int j=a[i];j<=m;j++)//必须要有足够的时间采当前草药，所以从a[i]开始循环。
	        dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
	cout<<dp[m]<<endl;
	return 0;
}
```

---

## 作者：LRL65 (赞：16)

~~因为神yummy造的hack数据，所以本题的题解全撤了~~%%%

思路：

这一题是一道dp。

我们设 $f_i$ 的意思为前 $i$ 分钟可以采到的最大的草药价值。

给出状态转移方程：

$f_i=\max(f_i,f_{j-c_i}+w_i)$

$f_i$ 的意思就是不选 ，$f_{j-c_i}+w_i$ 的意思则是选当前这种草药。

最后需要注意，一定要开 **long  long** ，因为 $t$ 最大 $10^7$ ,会爆掉 int 。
 

------------

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,v，c[10005],w[10005],f[10000005];
int main() {
	cin>>v>>n;
	for(int i=1;i<=n;i++) cin>>c[i]>>w[i];
	for(int j=0;j<=v;j++) f[j]=0;//初始化赋为0
	for(int i=1;i<=n;i++)
		for(int j=c[i];j<=v;j++)
			f[j]=max(f[j],f[j-c[i]]+w[i]);//状态转移方程
	cout<<f[v]<<endl;
	return 0;
}
```



---

## 作者：Mars_Dingdang (赞：9)

本题是典型的完全背包题目。
## 题目大意
有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的费用是 $w_i$，价值是 $c_i$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 
## 大体思路
这个问题非常类似于 01 背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取 $0$ 件、取 $1$ 件、取 $2$ 件……等很多种。如果仍然按照解 01 背包时的思路，令 $f(i,v)$ 表示前 $i$ 种物品恰放入一个容量为 $V$ 的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f(i,v)=\max{f[i-1][v-k\times w[i]]+k\times c[i] | 0\le k\times w[i]\le  v}$。

将 01 背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。

这个算法使用一维数组，先看伪代码：
```cpp　
  for i=1..N 
　　　for v=0..V
　　　　 f[v]=max{f[v],f[v-w[i]]+c[i]}; 
```
你会发现，这个伪代码与 01 背包问题的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么 01 背包问题中要按照 $v=V\sim 0$ 的逆序来循环。这是因为要保证第i次循环中的状态 $f(i,v)$ 是由状态 `f[i-1][v-w[i]]` 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 $i$ 件物品”这件策略时，依据的是一个绝无已经选入第 $i$ 件物品的子结果 `f[i-1][v-w[i]]`。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 $i$ 种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果 `f[i][v-w[i]]`，所以就可以并且必须采用 $v= 0\sim V$ 的顺序循环。这就是这个简单的程序为何成立的道理。
　　   
这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：`f[i][v]=max{f[i-1][v],f[i][v-w[i]]+c[i]}`，将这个方程用一维数组实现，便得到了上面的伪代码。

### 一个简单有效的优化 
　 完全背包问题有一个很简单有效的优化，是这样的：若两件物品 $i$ 、$j$ 满足 $w_i\le w_j$ 且 $c_i\le  c_j$，则将物品 $j$ 去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的 $j$ 换成物美价廉的 $i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//注意开 long long
int w[100005],c[100005];
int dp[10000005];//数组 1e7
signed main(){
    int v,n;
    cin>>v>>n;
    for(int i=1;i<=n;i++){
        cin>>w[i]>>c[i];
    }//输入
    for(int i=1;i<=n;i++){
        for(int V=w[i];V<=v;V++){
            dp[V]=max(dp[V],dp[V-w[i]]+c[i]);//状态转移方程
        }
    }
    cout<<dp[v];//输出
    return 0;
}
```

---

## 作者：zmxqs (赞：8)

前言：
> [原贴](https://www.luogu.com.cn/discuss/show/253827)

> yummy Hack 掉了所有题解，使得我有了提交题解的机会，在此感谢他！

### 温馨提示：一开始管理员审核时说 LaTeX 崩了？但是在我的这边显示正常，如果崩了，请到博客里面查看

## [传送门](stirling )
本题和采药类似，只是把01背包改成了完全背包

其实并不难，01背包是从 $t$ 到 $w_i$ 进行 dp，而完全背包恰恰相反，是从 $w_i$ 到 $t$ 进行 dp

动态方程（二维） $dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-w_i}+v_i)$

可以发现方程的结果与第一维无关，可以将方程简化到 $dp_i=\max(dp_{i-w_i}+v_i,dp_i)$

当然滚动数组也是一个很好的解法

还有一个重要的地方，注意开 **long long**（题目一开始数据规模不严谨，导致错误题解可以通过），导致被 yummy hack

> 十年 OI 一场空，不开 **long long** 见祖宗

就是强调了 **long long** 的必要性
 

Code

```
#include<bits/stdc++.h>

//#pragma GCC optimize("O1,O2,O3,Ofast,no-stack-protector,unroll-loops,fast-math")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
using namespace std ；

const int MAXT = 1e7 + 10 ；
const int MAXM = 1e4 + 10 ；

int t,m ；
long long a[MAXM] , b[MAXM] , dp[MAXT] ；

int main() {
	scanf("%d%d",&t,&m) ;
	for(int i=1;i<=m;++i) {
		scanf("%lld%lld",a + i,b + i) ；
	}
	for(int i=1;i<=m;++i) {
		for(int j=a[i];j<=t;++j) {
			dp[j] = max(dp[j] , dp[j - a[i]] + b[i]) ；
		}
	}
	printf("%lld\n",dp[t]) ；
	return 0 ;
}



```

---


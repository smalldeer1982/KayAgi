# 那个什么密码2

## 题目背景

原题为 https://www.luogu.com.cn/problem/P1079。

## 题目描述

与原题一模一样、具体不同请见输入格式


## 说明/提示

由 zxy 大神原创、本人在洛谷上传。


## 样例 #1

### 输入

```
CompleteVictory
Wherethereisawillthereisaway
0```

### 输出

```
Yvqgpxaimmklongnzfwpvxmniytm```

# 题解

## 作者：Flaranis (赞：11)

这应该是平衡树维护区间翻转的模板题吧

对于一次翻转（L , R）

主流的做法是Splay把编号为L-1的节点旋转到根

再把编号为R+1的节点旋转到根的右节点

这样根的右节点的左子树全为L---R，打上翻转标记即可


顺便再拓展一种算法，也就是我写的非选择treap

核心操作是split和merge

split是从某一位置把平衡树拆开，返回两个值即两根

merge是合并两个子树，要求保证某一子树元素严格小于另一子树

这样翻转区间L---R的时候

可以通过split拆出树1---L-1，树L---R，树R+1---n(均为编号)

在第二棵树的根上打上翻转标记

按顺序合并三棵树，在合并过程中下放标记

即可以复杂度O(len\*log(len))的复杂度水过此题

以下是我的代码：





```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#define rt register int
#define ll long long
#define r read()
using namespace std;
inline int read()
{
    int x = 0; int zf = 1; char ch;
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}
int i,j,m,n,x,y,z,cnt,all,num,Root;
struct points{
    int ls,rs,val,size,lazy;
}a[10010];
struct two{int ls,rs;};
inline void up(const int x)
{
    a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;
}
inline void down(const int x)
{
    if(!a[x].lazy)return;
    swap(a[x].ls,a[x].rs);
    a[a[x].ls].lazy^=1;
    a[a[x].rs].lazy^=1;
    a[x].lazy=0;
}
inline int merge(const int x,const int y)//x < y
{
    if(!x)return y;if(!y)return x;
    down(x);down(y);
    if(a[x].val>a[y].val)
    {
        a[y].ls=merge(x,a[y].ls);
        up(y);
        return y;
    }
    else
    {
        a[x].rs=merge(a[x].rs,y);
        up(x);
        return x;        
    }
}
two split(const int x,const int val)//rank 1...val ;val+1...n
{
    two ret={0,0};down(x);
    if(!x)return ret;rt p=a[a[x].ls].size+1;
    if(p<=val)
    {
        ret=split(a[x].rs,val-p);
        a[x].rs=ret.ls;
        ret.ls=x;
    }
    else
    {
        ret=split(a[x].ls,val);
        a[x].ls=ret.rs;
        ret.rs=x;
    }up(x);
    return ret;
}
char v[10010],k,c[10010];short len1,len2;
void writes(const int x)
{
    down(x);
    if(a[x].ls)writes(a[x].ls);
    putchar(c[x]);
    if(a[x].rs)writes(a[x].rs);
}
inline int newnode(const int x)
{
    cnt++;a[cnt].size=1;a[cnt].val=rand();return cnt;
}
inline void insert(const int val)
{
    two u=split(Root,val);
    Root=merge(merge(u.ls,u.rs),newnode(val));
}
inline void solve(const int L,const int R)
{
    two p1=split(Root,L-1); 
    two p2=split(p1.rs,R-a[p1.ls].size);
    a[p2.ls].lazy^=1; 
    Root=merge(p1.ls,merge(p2.ls,p2.rs));
}
int main()
{
    srand(time(0));j=0;
    scanf("%s %s",v+1,c+1);rt len1=strlen(v+1);n=strlen(c+1);
    for(rt i=1,j=1;i<=n;i++,j++)
    {
        if(j>len1)j-=len1;
        if(v[j]<='Z')k=v[j]-'A';else k=v[j]-'a';
        if(c[i]<='Z')k+=c[i]-'A';else k+=c[i]-'a';
        if(k>=26)k-=26;
        if(c[i]<='Z')c[i]='A'+k;else c[i]='a'+k;
    }
    for(rt i=1;i<=n;i++)insert(i);
    for(m=r;m;m--)
    {
        x=r;y=r;
        solve(x,y);
    }
    writes(Root);
    return 0;
}

```

---

## 作者：hensier (赞：5)

首先，我们可以重温一下[这道经典题](https://www.luogu.com.cn/problem/P1079)。~~多年前，我还写了[一篇题解](https://www.luogu.com.cn/blog/shenyouran/P1079)。~~

题中给出了下表：

![](https://cdn.luogu.com.cn/upload/pic/30.png)

乍看上去非常恶心，但其实规律是显而易见的。我们只需要截取其中一部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/etm3d9ha.png)

仔细观察发现，假设一个明文的字符为$a$，密钥的一个字符为$b$，那么我们只需要把$b$统一变成小写，即$\texttt{b=tolower(b)}$。

我们得到$c=a+b-97$，即密文的对应字符。

当然，$c$的$\texttt{ASCII}$值可能不是一个字母。我们需要对$a$的大小写进行讨论，然后得出是否要对$c$进行修正。

最后，我们按照题意，合理运用$\text{string}$中的子串、反转函数，就可以解决本题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string key,ans;
//key为密钥，ans既用来输入明文，又用来保存结果
int m;
int main()
{
    cin>>key>>ans;
    for(int i=0;key[i];i++)key[i]=tolower(key[i]);
    //统一把key中的所有字符变为小写。注意tolower不是一个void函数，必须要进行赋值，否则无效（测试的时候WA了很多次）！
    for(int i=0,j=0,x;ans[i];i++,j=(j+1)%key.size())
    {
        /*
        这里本来可以直接进行赋值，但是我们需要从极限考虑：
        假如明文的一个字符是z，然后密钥对应字符也是z。
        我们知道，z的ASCII值是122，a的是97。
        所以如果直接进行更改，那么密文的char值会变为122+122-97=147。
        然而char的范围是[-128,128)，所以147会溢出。溢出后变为-109。
        这显然不是我们想要的，所以我们需要一个范围略大的类型——这里使用int。
        具体方法是，把密文赋值给int，然后看是否超出了大小写的范围。超出的话要减26。
        修正完毕后，把x赋值给字符串即可。
        */
        x=ans[i]+key[j]-'a';//x在for循环里已经定义了，这里进行赋值
        if((islower(ans[i])&&x>'z')||(isupper(ans[i])&&x>'Z'))x-=26;
        //如果明文字符为小写，但这里已经超出小写字母的范围，那么减去26进行修正。大写同理。
        ans[i]=x;//把修正之后的数值赋值给明文（它现在保存的是密文）
    }
    scanf("%d",&m);
    for(int i=0,a,b;i<m;i++)
    {
        scanf("%d%d",&a,&b);
        a--;
        b--;
        //注意，string是从0下标开始的
        string s=ans.substr(a,b-a+1);
        //string.substr(pos,len)表示从pos开始，取长度为len的子串
        reverse(s.begin(),s.end());//把子串进行反转
        ans.replace(a,b-a+1,s);
        //string.replace(pos,len,src)表示把从pos开始，长度为len的字符串全部替换成字符串src
    }
    cout<<ans;
}
```

---

## 作者：InformationEntropy (赞：2)

[这里是原题](https://www.luogu.com.cn/problem/P1079)

读原题中的表可知，A R A=A，A R B=B，B R B=C，B R C=D....（R为运算操作），可得出每个字母都有它的一个值A相当于0，B相当于1，C相当于2...

求字母的值的代码
```cpp
int value(char a){
    if(a>='a'&&a<='z'){
        return a-97;
    }
    return a-65;
}
```

明文转化成密文就直接将每个字母的ASCII码值加上密匙对应字母的$value$即可，但需注意当加上的值超过‘z’或‘Z’时需取模。

转换代码实现
```cpp
    string a1,a2;
    cin>>a1>>a2;
    int len1=a1.length();
    int len2=a2.length();
    int k=0;//循环使用密匙
    for(int i=0;i<len2;i++){
        int x=a2[i]+value(a1[k]);//加上密匙的value
        if(a2[i]>='A'&&a2[i]<='Z'){//为大写字母
            if(x>90){
                x=x%90+64;//如果溢出，返回初始，如Z+B返回变为A
            }
        }else{
            if(x>122){
                x=x%122+96;
            }//小写字母同理
        }
        a2[i]=char(x);//改变原串
        k++;//密匙指针向后移
        if(k==len1){
            k=0;//超出密匙长度返回0开始
        }
    }

```

接下来，就到了反转了。下面是手写的反转函数（十分简洁）。本题暴力可过。

```cpp

void fanzhuan(int a,int b,string &s//要传址){
    for(int i=a-1,j=b-1;i<j;i++,j--){//这里需要注意：a,b指第a,b个字母，不是下标。所以从a-1开始到b-1。
    //两头同时进行。第一个与最后一个调换，第二个与倒数第二个调换...这样就能使整个串反转
        swap(s[i],s[j]);
    }
    return;
}
```
~~自己动手丰衣足食~~

完整代码

```cpp
#include<iostream>
#include<string>
#include<cstdio>
using namespace std;
inline void read(int &x){//快读，忽略它
    x=0;
    int f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-48;
        ch=getchar();
    }
    x*=f;
    return;
}
void fanzhuan(int a,int b,string &s){
    for(int i=a-1,j=b-1;i<j;i++,j--){
        swap(s[i],s[j]);
    }
    return;
}
int value(char a){
    if(a>='a'&&a<='z'){
        return a-97;
    }
    return a-65;
}
int main(){
    string a1,a2;
    cin>>a1>>a2;
    int len1=a1.length();
    int len2=a2.length();
    int k=0;
    for(int i=0;i<len2;i++){
        int x=a2[i]+value(a1[k]);
        if(a2[i]>='A'&&a2[i]<='Z'){
            if(x>90){
                x=x%90+64;
            }
        }else{
            if(x>122){
                x=x%122+96;
            }
        }
        a2[i]=char(x);
        k++;
        if(k==len1){
            k=0;
        }
    }
    int m;
    read(m);
    int a,b;
    for(int i=0;i<m;i++){
    	read(a);
    	read(b);
    	fanzhuan(a,b,a2);
    }
    cout<<a2;
    return 0;
}
```




---

## 作者：loadingnow (赞：2)

这个题题干是在1079题，字符串处理，简单模拟，可以打表或者模拟模拟出秘钥的规则，然后利用规则处理明文，得到密文

之后的操作可用substr操作截取子串，reverse倒转子串，字符串加法叠加子串得到结果，数据很水，暴力可过

/\*by loadingnow第一次发题解的萌新瑟瑟发抖

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
const int MAX=5010;
int miyao[MAX];
int main()
{
    string s,k;
    cin>>k;
    for(int i=0;i<k.length();i++)
    {
        for(int j=i;j<MAX;j+=k.length())
        {
            if(k[i]>='A'&&k[i]<='Z')
                miyao[j]=(int)(k[i]-'A');
            else
                miyao[j]=(int)(k[i]-'a'); 
        }
    }
    cin>>s;
    for(int i=0;i<s.length();i++)
    {
        if(s[i]>='A'&&s[i]<='Z')
        {
            if(s[i]+miyao[i]>'Z')
                s[i]=s[i]+miyao[i]-26;
            else
                s[i]=s[i]+miyao[i];
        }
        else
        {
            if(s[i]+miyao[i]>'z')
                s[i]=s[i]+miyao[i]-26;
            else
                s[i]=s[i]+miyao[i];
        }
    }
    int n,a,b;
    cin>>n;
    while(n--)
    {
        cin>>a>>b;
        string t1=s.substr(0,a-1);
        string t2=s.substr(a-1,b-a+1);
        string t3=s.substr(b,s.length()-b);
        reverse(t2.begin(),t2.end());
        s=t1+t2+t3;
    }
    cout<<s<<endl;
    return 0;
}
```

---

## 作者：梦里调音 (赞：1)

先补张图。。。

![](https://cdn.luogu.com.cn/upload/pic/30.png)

$RT$

其实明文+密钥转换成密文相对原题会简单一些，直接对着表模拟就好了。

我们可以把$A$看作数字$0$，$B$看作数字$1$，以此类推。
	
 ®操作其实就是把字母转换成数字，然后相加，再转换成字母。
 
 子程序代码：
 
 ```
inline char R(char x,char y)//密钥、明文转换为密文
{
	bool af=0;//默认小写
	if(islower(x))x-='a';
	else x-='A';
	if(islower(y))y-='a';
	else y-='A',af=1;//大写
	int z=int(x+y);
	z%=26;
	if(af)return char(z+'A');//大写
	else return char(z+'a');//小写
}
```
要注意一下大小写。

得到密文之后再进行$M$个操作，需要用到$string$里的一些函数。

不会的可以咨询[度娘](https://www.baidu.com/)。

完整代码：

```
#include <bits/stdc++.h>
using namespace std;
string k,m,c;
int mlen,klen;
int n; 
inline char R(char x,char y)//密钥、明文转换为密文
{
	bool af=0;//默认小写
	if(islower(x))x-='a';
	else x-='A';
	if(islower(y))y-='a';
	else y-='A',af=1;//大写
	int z=int(x+y);
	z%=26;
	if(af)return char(z+'A');//大写
	else return char(z+'a');//小写
}
int main()
{
	cin>>k>>m;
	mlen=m.length();
	klen=k.length();
	for(int i=0,j=-1;i<mlen;i++)
	{
		j++;
		if(j==klen)j=0;
		c=c+R(k[j],m[i]);
	}
   cin>>n;
	for(int a,b;n;n--)
	{
		cin>>a>>b;
		string zhong=c.substr(a-1,b-a+1);
		reverse(zhong.begin(),zhong.end());
		c.replace(a-1,b-a+1,zhong);
	}
	cout<<c<<endl;
	return 0;
}
```


---

## 作者：Spect_Scan (赞：1)

**大家做题之前应当先参考一下[P1079](https://www.luogu.com.cn/problem/P1079),那里详细介绍了密码转化的规则。**

**这道题我是用~~暴力+暴力~~过的这道题，但代码还是比较短的， 详细过程在下面代码的注释里面。**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,x,y,end;
    string key,pass,copy,all,as,s;//key是密钥，pass是明文 
    cin>>key>>pass;
    copy=key;
    as=pass;//使真正的明文字母不变 
    int l1=key.size();
    int l2=pass.size();//计算字符串长度 
    while(l1<l2)//暴力方法，直到密钥的长度大于明文为止，便于后面比较 
    {
        key=key+copy;//若密钥长度小于明文，则重复使用 
        l1=key.size();//刷新当前的长度，避免死循环 
    }
    for(int i=0;i<=l2-1;i++)
    key[i]=tolower(key[i]);//将密钥全部转化为小写字母 
    for(int i=0;i<=l2-1;i++)
    {                       
        as[i]=tolower(as[i]);//将明文转化为小写字母，便于操作 
		if(as[i]-97+1+key[i]-97+1<=27)//字母序数相加不大于于z+1时 
		all+=char(pass[i]+(key[i]-97));
		else all+=char(pass[i]+(key[i]-97)-26);//字母序数相加大于z+1时 
    }
    cin>>k;//操作次数 
    for(int i=1;i<=k;i++)
    {
    	cin>>x>>y;//端点 
    	s=all.substr(x-1,y-x+1);//先提取需要倒序的子串 
		reverse(s.begin(),s.end());//然后倒序 
        all.replace(x-1,y-x+1,s);//最后替换目标子串 
	}
	cout<<all;
    return 0;
}
```



---

## 作者：jxpxcsh (赞：1)

自助发标程、其实c++里可以直接有过程实现反转、

```delphi

var
  k,m,s:ansistring;
  t:char;
  p,i,o,a,b,q:longint;
  change:array[1..1001]of boolean;
  y:boolean;
function calculate(k1,m1:char):char;
begin
  p:=ord(k1)+(ord(m1)-97);
  if p<=122 then calculate:=chr(p)
   else calculate:=chr(p-26);
end;
begin
  readln(k);
  readln(m);
  fillchar(change,sizeof(change),false);
  for i:=1 to length(k) do
   if ord(k[i])<97 then k[i]:=chr(ord(k[i])+32);
  for i:=1 to length(m) do
   if ord(m[i])<97 then begin change[i]:=true; m[i]:=chr(ord(m[i])+32); end;
  for i:=1 to length(m) do
   begin
     if i mod length(k)=0 then o:=length(k)
                          else o:=i mod length(k);
     s:=s+calculate(k[o],m[i]);
   end;
  readln(q);
  for i:=1 to q do
   begin
     readln(a,b);
     while a<b do
     begin
       t:=s[a];
       s[a]:=s[b];
       s[b]:=t;
       y:=change[a];
       change[a]:=change[b];
       change[b]:=y;
       a:=a+1;
       b:=b-1;
     end;
   end;
     for i:=1 to length(s) do
   if change[i] then write(chr(ord(s[i])-32))
                else write(s[i]);
  readln;
  readln;
end.   

```

---


# 爱与愁过火

## 题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹·heartache》第三章。

爱与愁大神说这是ta的伤心指数，只不过现在好很多了，翻译只是看你无聊让你动动脑筋罢了（shit~~~）。虽然月落乌啼嘴上骂着：“我去年买了个表……纽曼表……”，但是结果还是请爱与愁大神去Pizza Hut吃了一顿。


## 题目描述

到了 Pizza Hut，爱与愁大神由于不爽，所以存心想坑月落乌啼的钱，他点了 $m$ 样菜，每样菜 $a_i$ 元。月落乌啼预计只用 $n$ 元，于是他让爱与愁大神重新从这 $m$ 样菜中选 $r$ 样。

爱与愁大神还是想坑钱，于是他打电话给你，让你编一个程序告诉他有几种方案可以从 $m$ 样菜中点取 $r$ 样菜但是还能超过月落乌啼的预计 $n$ 元。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$m \le 30$，$r \le m$，$m \le a_i \le 90n \le 2700$。


## 样例 #1

### 输入

```
5 2 8
1 7 2 5 4```

### 输出

```
4```

# 题解

## 作者：深海鱼的眼泪 (赞：22)

这道题很像01背包，用 f[j,k] 保存j件物品，k元的种类，最后累加就可以了。注意 j 需要逆序（不知道为什么逆序请回顾01背包问题）。


```cpp
#include <iostream>
using namespace std;
int main(){
    int m,r,n,i,a[40],f[40][3000],j,k,t=0,ans=0;
    cin>>m>>r>>n;
    for (i=1;i<=m;i++){
        cin>>a[i];
        t+=a[i];
    }
    f[0][0]=1;
    for (i=1;i<=t;i++){
        f[0][i]=0;
    }                                          //没有什么用的初始化
    for (i=1;i<=m;i++){
        for (j=r;j>=1;j--){                          //逆序枚举物品件数
            for (k=a[i];k<=t;k++){
                f[j][k]+=f[j-1][k-a[i]];
            }
        }
    }
    for (i=n+1;i<=t;i++){
        ans+=f[r][i];                       //把大于n结果都加起来
    }
    cout<<ans;
    return 0;
} 

```

---

## 作者：DrunkXT (赞：19)

一个不会动规的蒟蒻非要用dfs！！！

dalao忽视

注释都在代码上了
```
#include<cstdio>
const int MAXN=1005;
int m,r,n;
int a[MAXN];
int b[MAXN];
int ans;
void dfs(int t,int s,int k)
{
	if(k==r)//选了r样菜 
	{
		if(s>n)//超过了n元 
			ans++;
	    return;
	}
	if(m-t+1<r-k) return;//剩下菜都选也没r样，直接返回 
	if(s>n)//价钱已超过n，直接统计剩下方案 
	{
   		int w=1,c=m-t+1,d=r-k,e=c-d+1;
		for(int i=1;i<=d;i++)
		    w=w*(c-i+1)/i;
   		ans+=w;
   		return;
  	}
	for(int i=t;i<=m;i++)
	    if(b[i]==0)//优化标记 
	    {
	    	b[i]=1;
	    	dfs(i+1,s+a[i],k+1);
	    	b[i]=0;
	    }
}
int main()
{
	freopen("爱与愁过火.in","r",stdin);
	freopen("爱与愁过火.out","w",stdout);
	scanf("%d%d%d",&m,&r,&n);//读入 
	for(int i=1;i<=m;i++)
	    scanf("%d",&a[i]);
	dfs(1,0,0);
	printf("%d",ans);
	return 0;
}
```
很多人私信问我t是什么（感谢信任，在一片dp中看中了最慢的dfs），这里解释一下：t就是表示当前选的菜， for(int i=t;i<=m;i++) if(b[i]==0) { b[i]=1; dfs(i+1,s+a[i],k+1); b[i]=0; } 这个是dfs循环，从t开始选菜到m结束，如果b[i]==0表示没选，则可以选，下一次从i+1开始选菜，所以t表示上一次选的菜，其实是一个优化，避免每次从1开始选菜

---

## 作者：雪风舞者 (赞：8)

这题可以用类似背包dp的方法做，~~然而懒到不想推式子~~

于是蒟蒻用的dfs+剪枝能100分（忽视时限吧，裸dfs最多80分）
```cpp
//lst上个确定的菜是哪个(防止记重),p当前已经确定几个菜,
//f已经花了多少钱 
void dfs(int lst,int p,int f){
    if(p==r){
        if(f>n) ans++;
        return;
    }
    for(int i=lst+1;i<=m-r+p+1;i++)//小剪枝，只要后面剩下的菜
    //数不够，就肯定不行。从lst+1开始搜是为了避免重复方案
        dfs(i,p+1,f+a[i]);
}
```
没加大剪枝的搜索框架，80分

-------

具体剪枝思想：如果当前已经选出的菜的钱数$f>n$，那么就说明接下来不管怎么选都是可行的（注意$a_i$一定非负），所以这种情况只需要求出之后的组合数来就行（已有题解这么做的）。然而因为组合数的性质（杨辉三角，$C_j^i=C_{j-1}^{i-1}+C_j^{i-1}$），预处理出来就能更快了
```cpp
int c[35][35];
void dfs(int lst,int p,int f){
    if(f>n||p==r){
        if(f>n) ans+=c[m-lst][r-p];
        return;
    }
    for(int i=lst+1;i<=m-r+p+1;i++)
        dfs(i,p+1,f+a[i]);
}
void build(){
    memset(c,0,sizeof(c));
    c[0][0]=1;
    for(int i=1;i<=m;i++){
        c[i][0]=1;
        for(int j=1;j<=i;j++)
            c[i][j]=c[i-1][j]+c[i-1][j-1];
    }
}
```
AC，235ms

---
还能更快！当数据中方差较大时，可以对其进行排序，从大的一侧向小的一侧搜，能更早到达临界值

### 以下完整代码（AC，22ms ~~甚至跟dp一样快~~）
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int m,r,n,a[35],ans=0;
int c[35][35];
bool cmp(int a,int b){//自定义比较函数，sort从大到小
    return a>b;
}
//lst上个确定的菜是哪个(防止记重),p当前已经确定几个菜,
//f已经花了多少钱 
void dfs(int lst,int p,int f){
	if(f>n||p==r){
		if(f>n) ans+=c[m-lst][r-p];
		return;
	}
	for(int i=lst+1;i<=m-r+p+1;i++)
		dfs(i,p+1,f+a[i]);
}
int  main(){
	scanf("%d%d%d",&m,&r,&n);
	for(int i=1;i<=m;i++)
		scanf("%d",&a[i]);
	memset(c,0,sizeof(c));
	c[0][0]=1;//直接在main中预处理了，懒~~~
	for(int i=1;i<=m;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];
	}
	sort(a+1,a+m+1,cmp);
	dfs(0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
**最后，~~厚颜无耻地~~贴出蒟蒻的[洛谷博客](https://www.luogu.org/blog/xuefengwuzhe/#)！**


---

## 作者：文艺平衡树 (赞：6)

看到楼下都在用背包做，就发一个不一样的题解吧。

结构看上去差不多，但我直接存方案总数，也就是dp[i][j]表示取i样物品，达到价值k的方案数。

状态转移方程见代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
int dp[31][2701],v[31];
int m,r,n,ans;
int main(){
    int i,j,k;
    //初始读入，没啥好说的 
    scanf("%d%d%d",&m,&r,&n);
    for(i=1;i<=m;i++){
        scanf("%d",&v[i]);
    }
    //赋初值，为什么是1呢，很简单，取0样物品达到价值0的方案只有一种（什么都不取） 
    dp[0][0]=1;
    //动规核心代码 
    for(i=1;i<=m;i++){ //枚举当前末尾物品 
        for(k=r;k>=1;k--){ //枚举取几样 
        //枚举取k样达到（>=）价值j的方案数 
            for(j=0;j<v[i];j++) 
                dp[k][j]+=dp[k-1][0];
            for(j=v[i];j<=n+1;j++){
                dp[k][j]+=dp[k-1][j-v[i]];
            }
        }
    }
    printf("%d",dp[r][n+1]); //为什么是n+1呢，因为>n就是>=n+1。
    return 0;
}
```

---

## 作者：Buried_Dream (赞：5)

为什么题目上写的时限和实际上时限不同啊。

## 题意：
 
给定 $m$ 个数，从这 $m$ 个数里选 $r$ 个数，

并且选的这 $r$ 个数的和加起来要大于（注意不能等于）$n$;

## 思路:

看到题目的第一眼：

$100%$ 数据：$m<=30，r<=m，m<=90 n<=2700$ 考虑爆搜。


直接`dfs`,于是有了下段代码（注释在代码里）：

```cpp
void dfs(int now, int sum, int pre) {//now是当前选了几个数，sum是当前now个数的和，pre是上次出现的位置
	if(now == r) {//当选了r样菜
		if( sum > n) {//同时这r样菜的价格比n大
			ans++;//方案数加1
		}
		return ;//回溯，回到上一次调用递归的地方
	}
	for(int i = pre;i <= m; i++) {
		dfs(now + 1, sum + a[i], i + 1);//dfs
	} 
}
```
却意外的超时了 $3$ 个点。

于是考虑剪枝优化这个 `dfs`。

### 第一个小剪枝:
首先考虑当你目前选了的菜数，如果把剩下的菜都加上也到不了 $r$ 样，直接返回。


```cpp
if(m - pre + 1 < r - now + 1) return;
```
### 第二个小剪枝：
接下来考虑用 一个 `bool` 类型的数组去打标记来避免一些不必要的情况



```cpp
for(int i = pre ;i <= m; i++) {
		if(vis[i] == false ) {
		vis[i] = true;
		dfs(now + 1, sum + a[i], i + 1);
		vis[i] = false;
		}
	} 
```

### 最后一个大剪枝：

当你选了不到 $r$ 样菜的时候 $sum$ 已经大于 $n$, 此时剩下的菜选谁都无所谓了，直接计算出方案数返回。

```cpp
int init (int x, int y) {
	int res = 1;
	for (int i = 1, j = 0; i <= x; i++, j++) 
		res = res * (y - j) / i;
	return res;
} 
```
## 最后贴完整AC代码:

```cpp
/*
Work by: 看我后面——
目标：打部分分，不能打正解
算法：不会
*/
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
#include<cstring>
#define int long long
#define il inline
#define re register
#define inf 0x3f3f3f3f
#define FJH 1314
using namespace std;

const int maxn = 1e6 + FJH;
const int MAXN = 2e3 + 32;
inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-'){w = -1;}ch = getchar();}
	while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
	return s*w;
}
il void print(int x){
	if(x < 0) putchar( '-' ),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
bool cmp(int x,int y) {
	return x > y;
}
int init (int x, int y) {
	int res = 1;
	for (int i = 1, j = 0; i <= x; i++, j++) 
		res = res * (y - j) / i;
	return res;
} 
int m, r ,n;
int a[maxn];
int ans = 0;
bool vis[maxn];

void dfs(int now, int sum, int pre) { 
	// if (now > r + 1) return ; 
	if(now == r + 1 ) {
		if( sum > n) {
			ans++;
		}
		return;
	}
	if(m - pre + 1 < r - now + 1) return;
	if (sum > n) {
		int a = m - pre + 1;
		int x = init(r - now + 1, a);
		ans += x;
		return;
	}
	for(int i = pre ;i <= m; i++) {
		if(vis[i] == false ) {
		vis[i] = true;
		dfs(now + 1, sum + a[i], i + 1);
		vis[i] = false;
		}
	} 
}
signed main(){
	  m = read(), r = read(), n = read();
	  for(int i = 1; i <= m; i++){
	  	a[i]  = read();
	  }
	  sort(a + 1, a + n + 1,cmp);    
	  dfs(1,0,1);
	  print(ans);
	  return 0;
}
```


---

## 作者：vectorwyx (赞：3)

简单的三维动规（需要压维）


------------
这道题正解是动规

一般来讲，动规需要考虑三件事：数组、方程、初始化


------------
# 一.数组

题目中涉及到了三个值：

菜的总数$m$、点的菜数$r$以及预算$n$

不难想到用$dp_{i,j,k}$表示在前$i$样菜中点$j$样菜恰好花费$k$元的方案数


------------

# 二.方程
有了数组，我们便需要思考状态转移方程

我们之前学习过01背包，参考一下01背包的状态转移方程：

$dp_{i,j}$=$\max$($dp_{i-1,j}$,$dp_{i-1,j-a_{i}}+c_{i})$

稍加修改，便得到了本题的状态转移方程：

$dp_{i,j,k}$=$dp_{i-1,j,k}$+$dp_{i-1,j-1,k-a_{i}}$


------------
# 三.初始化
$i,j,k$=0时为1，其余为0。


------------
同时，数据范围告诉我们需要**压维**。

参考01背包的一维数组解法即可


------------
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 3000//宏定义每一份菜最大钱数
using namespace std;
long long a[maxn];
int dp[35][maxn];//点j样菜，恰好k元钱的方案数
int main(){
	int m,r,n,sum=0,ans=0;//sum为m份菜价格之和
	cin>>m>>r>>n;
	for(int i=1;i<=m;++i){
        scanf("%d",&a[i]);
        sum+=a[i];
    }
    dp[0][0]=1;//初始化为1
    for(int i=1;i<=m;++i){//压维处理
        for(int j=r;j>0;--j){//倒着推
            for(int k=a[i];k<=sum;++k){
                dp[j][k]+=dp[j-1][k-a[i]];
            }
        }
    }
    for(int i=n+1;i<=sum;++i){
        ans+=dp[r][i];//枚举，只要花的钱比n大就计入答案
    }
    cout<<ans;
	return 0;
} 

```


---

## 作者：伟大的王夫子 (赞：2)

简单dp题

首先设$f_{i, j, k}$为前$i$个物品，总和为$j$,选$k$个的方案书

当$j \ge a_i$时，可以选择选或不选，不选即为在前$i - 1$个选$k$个，使总和为$j$,如果选$a_i$则为在前$i - 1$个物品中选$k - 1$个，使总和为$j - a_i$

当$j < a_i$时只能不选，同理。

稍微讨论一下就可以得到状态转移方程

$f_{i, j, k} = \begin{cases}f_{i - 1, j, k} + f_{i - 1, j - a_i,k - 1}&j\ge a_i\\
f_{i-1, j, k}&j<a_i
\end{cases}$

code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long f[31][2701][31], m, r, n, a[40], sum;
int main() {
	cin >> m >> r >> n;
	for (register int i = 1; i <= m; ++i) cin >> a[i];
	f[0][0][0] = 1;
	for (register int i = 1; i <= m; ++i) {
		sum += a[i];
		f[i][0][0] = 1;
		for (register int j = 0; j <= sum; ++j) {
			for (register int k = 1; k <= r; ++k) {
				if (j >= a[i]) 
					f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - a[i]][k - 1];
				else f[i][j][k] = f[i - 1][j][k];
			}
				
		}
	}
	long long ans = 0;
	//printf("%d %d %d\n", f[m][12][2], f[m][11][2], f[m][9][2]);
	for (register int i = n + 1; i <= sum; ++i)	ans += f[m][i][r];
	cout << ans;
}
```

---

## 作者：ddxrS_loves_zxr (赞：1)

**题目分析**：

从题目中不难发现，这道题可以用简单的背包DP来做。

**思路**：

先是定义状态：可以用 $ f(i,j,k) $ 表示，前 $i$ 样菜品中，选择 $j$ 道，价格为 $k$ 的方案总数。

可以得出状态转移方程：

$ f(i,j,k) = f(i - 1,j,k) + f(i - 1,j - 1,k - x(i)) $ 

就是把选择与不选择的方案总数相加起来。

**代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m, r, n;
int x[35], v;
int f[35][35][35 * 90 + 5], ans;
int main()
{
	cin>>m>>r>>n;
	f[0][0][0] = 1;
	for (int i = 1; i <= m; i++)
		cin>>x[i],f[i][0][0] = 1;//定义初始值
	for (int i = 1; i <= m; i++)
	{
		for (int j = 1; j <= i; j++)//枚举物品放置的个数
		{
			for (int k = 1; k <= m * 90; k++)//枚举当前的价格
			{
				f[i][j][k] = f[i - 1][j][k];//不选择这个菜品
				if (k >= x[i]) f[i][j][k] += f[i - 1][j - 1][k - x[i]];//选择与防止越界
			}
		}
	}	
	for (int j = n + 1; j <= m * 90; j++)//去找大于n的，并累加起来
	{
			ans += f[m][r][j];	
	}
	cout<<ans;//直接输出
	return 0;
}
```

---

## 作者：一只小H (赞：1)

## 题意简述

求出从 $m$ 个数中选 $r$ 个并使和大于 $r$ 的方案数。

输入：

* $m$，$r$，$n$。
* $m$ 个数字。
* $m\le30$。

输出：

* 方案数。

## 题目分析

因为数据范围不大，所以直接dfs即可。但是要注意优化，要不然会超时。

第一个优化，如果在搜索过程中发现剩下的不够了，那么这条搜索路线就不行了，将其剪掉。

第二个优化，如果现在的和已经比要求的大了，所以后面的不管怎么选都满足条件，使用组合公式统计答案个数即可。

组合公式：

$C^r_n=\frac{n!}{r!(n-r)!}$

第三个优化，因为选择不需要按顺序，所以排序也不影响答案的正确性，而从大到小排序更容易满足第二个优化的条件。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, r, n;           //如题所述
int num[23333];        //每个数字
int ans;               //最后的答案
int tot;               //所有数字的总和
bool cmp(int a, int b) //用于sort
{
    return a > b;
}
double factorial(int num) //用于求阶乘，注意用double，不然数字大了会炸
{
    double tmp = 1;
    for (int i = 1; i <= num; ++i)
    {
        tmp *= i;
    }
    return tmp;
}
/**
 * index  现在搜到的位置
 * sum    到目前为止的和
 * t      已经用了的数字个数
 * choose 是否选择当前数字
 */
void dfs(int index, int sum, int t, bool choose)
{
    if (index > m) //超出范围返回
    {
        return;
    }
    if (m - index + t + 1 < r) //如果剩下的数字个数不满r那么就直接返回
    {
        return;
    }
    if (choose) //选择了就要加上值
    {
        t++;
        sum += num[index];
        if (sum > n) //如果现在已经满足条件了，那么后面的不管怎么搜都可以了，统计方案数然后返回
        {
            /**
             * m-index 剩余可选的个数
             * r-t 要从中选择的个数
             */
            ans += factorial(m - index) / factorial(r - t) / factorial(m - index - r + t);
            return;
        }
    }
    if (t == r) //如果搜完了那就返回
    {
        if (sum > n) //满足条件进行统计
        {
            ans++;
        }
        return;
    }
    dfs(index + 1, sum, t, 0); //不选下一个
    dfs(index + 1, sum, t, 1); //选择下一个
}
int main()
{
    cin >> m >> r >> n;
    for (int i = 1; i <= m; ++i)
    {
        cin >> num[i];
        tot += num[i];
    }
    if (tot <= n) //如果所有数加起来都不满n那就不可能了
    {
        cout << 0;
        return 0;
    }
    if (r == m) //如果全部要选，那么就只有一种方案（总和小于n的情况已经被排除了）
    {
        cout << 1;
        return 0;
    }
    sort(num + 1, num + m + 1, cmp); //这样会优先选择大数，更容易满足第40行的条件
    dfs(1, 0, 0, 0);                 //不选第一个数
    dfs(1, 0, 0, 1);                 //选择第一个数
    cout << ans;
    return 0;
}
```


---

## 作者：yxzly (赞：1)

[P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) 和这道题很像， 也是针对方案数的背包问题（~~也是点菜~~），   如果没有完成这题，请先点击链接。
本题比 [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) 多了一个条件，就是只能选 $r$ 样菜。

让我们先回顾一下 [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) 的递推方程 $dp(i,j)=f(j-a(i))$ 其中，$dp(i,j)$ 表示前 $i$ 个菜品最大花费 $j$ 元的方案数。
那么，本题的递推式就出现了 $dp(i,j,k)=dp(i-1,j-1,k-a(i))$，其中 $dp(i,j,k)$ 表示前 $i$ 个菜品，在点 $j$ 道菜的情况下，最大花费 $k$ 元的方案数。
最后只需要计算价格大于 $n$ ，菜品为 $r$ 的方案数之和就可以。


------------

详见注释（不知道为什么逆序的复习01背包 [P1048 采药](https://www.luogu.com.cn/problem/P1048)）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int m,r,n,a[91]={0},dp[31][2701]={0}; //注意数据规模
	cin>>m>>r>>n;
	dp[0][0]=1;//注意初值
	for (int i=1;i<=m;i++) cin>>a[i];
	for (int i=1;i<=m;i++){ //循环m件菜品
		for (int j=m;j>=1;j--){ //这层的意思是，在有m件菜品的情况下，最大的方案数，注意逆序
			for (int k=a[i];k<=2700;k++){ //价格，逆序
				dp[j][k]=dp[j][k]+dp[j-1][k-a[i]];
			}
		}
	}
	int s=0; //累加器
   	for (int i=2700;i>n;i--) s+=dp[r][i];
	cout<<s;
	return 0;	
}

```


---

## 作者：usqwedf (赞：1)

丧心病狂地动规不能多说。。。

忽视时限吧。。。这道题搜索+剪枝最高60~80分。。。

动规思路其实还挺好想的。。只是一些细节我没有注意。。被坑了。。。

f[i,j] 表示 选i件物品价格为j的方案总数。

最后累加一下就可以了。

注意倒序。。

```delphi

var  
  f:array[0..30,0..300000] of longint;  
  a:array[0..30] of longint;  
  i,j,k,x,r,m,n,t,w:longint;  
begin  
  readln(n,r,m);  
  for i:=1 to n do begin  
     read(a[i]);  
     w:=w+a[i];  
  end;  
  f[0,0]:=1;  
  for i:=1 to n do begin  
    for j:=r downto 1 do  
      for k:=w downto a[i] do  
        f[j,k]:=f[j-1,k-a[i]]+f[j,k];  
  end;  
  for i:=w downto m+1 do t:=t+f[r,i];  
  writeln(t);  
end.  

```

---


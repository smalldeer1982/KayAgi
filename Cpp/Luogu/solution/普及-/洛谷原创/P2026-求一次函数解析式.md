# 求一次函数解析式

## 题目背景

做数学寒假作业的怨念……


## 题目描述

给定两个整点的坐标，求它们所在直线的函数解析式（一次函数）。


## 说明/提示

$2 x$ 表示为 `2x`。

$\frac{1}{2}x$ 表示为 `1/2*x`。

## 样例 #1

### 输入

```
3 6
2 4
```

### 输出

```
y=2x

```

## 样例 #2

### 输入

```
3 5
2 7```

### 输出

```
y=-2x+11```

## 样例 #3

### 输入

```
3 -1
5 -2```

### 输出

```
y=-1/2*x+1/2```

# 题解

## 作者：Eason_AC2 (赞：22)

数学题目，可以用来加深理解二元一次方程组的通解。

------------

希望更好的食用体验？点击`在Ta的博客里查看`。

------------

大家应该都知道的，二元一次方程组通常会有代入法和加减法等求解方式。看其他的博客里都没有详细讲到如何解一般的二元一次方程组。下面，我们先来推导出一般二元一次方程组的通解。

设我们有以下的方程组：
$$\begin{cases}ax+by=m&...(1)\\cx+dy=n&...(2)\end{cases}$$


我们下面用的是加减消元法，读者也可以用代入消元法尝试求出二元一次方程组的通解，有想法的咱们私信。

我们先想着消$x$，于是乎，将$(1)$式乘$c$可得：
$$acx+bcy=cm$$
再将$(2)$式乘$a$可得：
$$acx+ady=an$$
然后就可以得到这样的方程组：
$$\begin{cases}acx+bcy=cm&...(3)\\acx+ady=an&...(4)\end{cases}$$
然后$(3)$式减$(4)$式，就可以很愉快地消掉$x$啦，这时就只剩：
$$(bc-ad)y=cm-an$$
$$\therefore y=\frac{cm-an}{bc-ad}$$

同理，我们再用类似的方法消掉$y$（具体请读者自行尝试，提示：将$(1)$ $(2)$式中$y$的系数变为一个量）。得到：
$$(ad-bc)x=dm-bn$$
$$\therefore x = \frac{dm-bn}{ad-bc}$$
$\therefore$二元一次方程组的通解为：
$$\begin{cases}x=\frac{dm-bn}{ad-bc}\\y=\frac{cm-an}{bc-ad}\end{cases}$$

然后，这个题目跟上面的式子有什么关系呢？

学过一次函数的都知道，一次函数的解析式一般为$y=kx+b$，所以这样的函数在图像中会经过点$(x,y)$。

所以，我们不妨设其经过的两个点的坐标为$(m,n),(p,q)$，将这两个点的坐标代入$y=kx+b$就有：
$$\begin{cases}mk+b=n\\pk+b=q\end{cases}$$

这下你就明白了，根据上面$\begin{cases}ax+by=m\\cx+dy=n\end{cases}$的解为$\begin{cases}x=\frac{dm-bn}{ad-bc}\\y=\frac{cm-an}{bc-ad}\end{cases}$我们可代入求得：

$$\begin{cases}k=\frac{n-q}{m-p}\\b=\frac{pn-mq}{p-m}\end{cases}$$

所以，这道题目的轮廓就出来了，然后我们再考虑细节问题：

1. $\frac{n-q}{m-p}$是不是整数？不是的话该怎么约分？$\frac{pn-mq}{p-m}$呢？

2. 如何处理系数是负数的情况？

3. 什么时候该省略项？

我们一一解决这些问题：

A1: $\frac{n-q}{m-p}$是不是整数，只需要看$n-q$是否能被$m-p$整除，即是否有$(n-q)~mod~(m-p)=0$就可以了，如果不是的话，约分也好办，取$\gcd(n-q,m-p)$，然后这两个数分别除以这个最大公因数。

注意！$n-q$和$m-p$尽量用一个变量来存储！$\gcd(n-q,m-p)$也用一个变量来存储。

A2: 如果是分子是负数，并且分母也是负数，就全部都转为正就行了，单有分子是负数更加不用变，分母是负数也全部取相反数。

A3：当x或常数项的系数为0的时候，不用输出。

具体来看看代码加深理解吧：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int m, n, p, q, a, b;
//y=ax+b
int gcd(int a, int b) {
	return a % b == 0 ? b : gcd(b, a % b);
}
int main() {
	scanf("%d%d%d%d", &m, &n, &p, &q);
	printf("y=");
	int t1 = n - q, t2 = m - p, t3 = p * n - m * q, t4 = p - m;
	if(t1 % t2) {
		if(gcd(t1, t2) != 1) {
			int g = gcd(t1, t2);
			t1 /= g;
			t2 /= g;
		}
		if(t2 < 0) t2 = -t2, t1 = -t1;
		printf("%d/%d*x", t1, t2);
	} else if(t1 / t2)
		printf("%dx", t1 / t2);
	if(t3 % t4) {
//		printf("%d %d %d %d\n", t3, t4, t3<0, t4<0);
		if(gcd(t3, t4) != 1) {
			int g = gcd(t3, t4);
//			printf("%d %d %d %d\n", t3, t4, t3<0, t4<0);
			t3 /= g;
			t4 /= g;
		}
//		printf("%d %d %d %d\n", t3, t4, t3<0, t4<0);
		if(t4 < 0)	t3 = -t3, t4 = -t4;
//		printf("%d %d %d %d\n", t3, t4, t3<0, t4<0);
		if(t3 < 0) 
			printf("%d/%d", t3, t4);
		else
			printf("+%d/%d", t3, t4);
	} else if(t3 / t4 < 0)
		printf("%d", t3 / t4);
	  else if(t3 / t4)
	  	printf("+%d", t3 / t4); 
	return 0;
}
```
写本文时间仓促，若有纰漏，请用博客置顶声明中的联系方式与我取得联系。

当然，我写得这么用心，不给个赞和五星好评再走嘛？

---

## 作者：Edmundino (赞：17)

这道题是考了一个一次函数的知识点

也许数学好的人会知道这个

# 注意，前方高能警告
# 数学不及格的请看别的题解

敲黑板了

y=kx+b（k!=0）一次函数一般式

其中这k是斜率，b是截距

如题我们有这样两个一次函数解析式

{

 y1=kx1+b;
 
 y2=kx2+b;
 
}

此时k=(y2-y1)/(x2-x1)

b=﹙y2x1－y1x2﹚/﹙x1－x2﹚

知道这个后，做此题就有思路了吧

送上AC代码

```cpp

#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<iomanip>
#include<cmath>

#include<map>
using namespace std;
int xa,xb,ya,yb;
double k,b;
int main()
{
	cin>>xa>>ya>>xb>>yb;
	if((yb-ya)%(xb-xa)==0)
	{
		k=(yb-ya)/(xb-xa);
		b=ya-k*xa;
		if(b!=0)//注意分类
		{
			if(k!=1&&k!=-1)
		    cout<<"y="<<k<<"x+"<<b;
		  if(k==1)
		    cout<<"y=x+"<<b;
		   if(k==-1)
		     cout<<"y=-x+"<<b;
		}
		  
		if(b==0)
		{
			if(k==1)
		    cout<<"y=x";
		  if(k==-1)
		    cout<<"y=-x";
		   if(k!=1&&k!=-1)
		     cout<<"y="<<k<<"x";
		}
		  
	}
	else
	{
		k=(yb-ya)/(xb-xa)+(yb-ya)%(xb-xa);
		if((yb*xa-ya*xb)/(xa-xb)!=0||(yb*xa-ya*xb)%(xa-xb)!=0)//抠细节
		{
			if((yb*xa-ya*xb)<0&&(xa-xb)<0)
			  cout<<"y="<<(yb-ya)<<"/"<<(xb-xa)<<"*x+"<<(ya*xb-yb*xa)<<"/"<<(xb-xa);
			if((yb*xa-ya*xb)<0&&(xa-xb)>0)
			  cout<<"y="<<(yb-ya)<<"/"<<(xb-xa)<<"*x"<<(yb*xa-ya*xb)<<"/"<<(xa-xb);
			if((yb*xa-ya*xb)>0&&(xa-xb)<0)
			 cout<<"y="<<(yb-ya)<<"/"<<(xb-xa)<<"*x"<<(ya*xb-yb*xa)<<"/"<<(xb-xa);
			if((yb*xa-ya*xb)>0&&(xa-xb)>0)
			   cout<<"y="<<(yb-ya)<<"/"<<(xb-xa)<<"*x+"<<(yb*xa-ya*xb)<<"/"<<(xa-xb);
		}
		
		else
		  cout<<"y="<<(yb-ya)<<"/"<<(xb-xa)<<"*x";
	}
	return 0;
}
```


---

## 作者：DiTeXy (赞：14)

多简单的题，解个方程就行了。

你们那些强行0.5的人真的好么……

提供一个数据再强都能过的。
```cpp
#include<bits/stdc++.h>
using namespace std;
int xx1,yy1,xx2,yy2,k1,k2,k,b1,b2,b;
int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
int main()
{
    cin>>xx1>>yy1>>xx2>>yy2;
    if(xx1==xx2)
    {
        cout<<"Impossible!!"<<endl;
        return 0;
    }
    k1=yy1-yy2;
    k2=xx1-xx2;
    k=gcd(k1,k2);
    k1/=k;
    k2/=k;
    if(k2<0)
    {
        k1=-k1;
        k2=-k2;
    }
    b1=yy2*xx1-yy1*xx2;
    b2=xx1-xx2;
    b=gcd(b1,b2);
    b1/=b;
    b2/=b;
    if(b2<0)
    {
        b1=-b1;
        b2=-b2;
    }
    cout<<"y=";
    if(k1!=0)
    {
        cout<<k1;
        if(k2!=1)
            cout<<"/"<<k2<<"*x";
        else
            cout<<"x";
        if(b1>0)
        {
            cout<<"+"<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
        else if(b1<0)
        {
            cout<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
    }
    else
    {
        if(b1>0)
        {
            cout<<"+"<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
        else if(b1<0)
        {
            cout<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
    }
    cout<<endl;
    return 0;
}

```

---

## 作者：loi_hjh (赞：10)

# 一道简单题搞复杂了，负数的转换把自己搞蒙了。。。

## 直接待定系数法

### 附上代码：


```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
int k1,k2,p,q,x,y,b; 
bool flag,flagk2;
in int isflag(){
	if(flag) return k2;
	return k1;
}
int main(){
	scanf("%d%d%d%d",&p,&q,&x,&y);
	printf("y="); 
	if(p<x){
		swap(p,x);
		swap(q,y); 
	} 
	k1=p-x;
	k2=q-y;
	if(k2<0){
		k2=-k2;
		flagk2=true;
		putchar('-');
	}
	if(k1>k2) flag=true;
	for(ri i=isflag();i>=2;i--){
		if((k1%i==0)&&(k2%i==0)){
			k1/=i;
			k2/=i;
		}
	}
	if(k1==1){//斜率是整数 
		printf("%dx",k2);
		if(flagk2) k2=-k2;
		b=q-p*k2;//强行算截距 
		if(b>0) putchar('+');
		if(b) printf("%d",b);
	}
	else{
		printf("%d/%d*x",k2,k1);
		if(flagk2) k2=-k2;
		b=q*k1-p*k2;
		if(b<0){
			putchar('-');
			b=-b;
		}
		else putchar('+');
		for(ri i=min(k1,b);i>=2;i--){
			if((k1%i==0)&&(b%i==0)){
				k1/=i;
				b/=i;
			}
		}
		if(b) printf("%d/%d",b,k1);
	}
	return ~~(0-0);
}


```


---

## 作者：梦里调音 (赞：10)

来个简单点的思路！

其实这道题麻烦在于分数。

那我们就按照小学生的思路来：

~~分数有三部分组成：分子、分母、分数线~~

那我们用两个变量分别记录分子、分母，分数线输出时再说。

**首先**，分数的乘法可以直接乘，

加法要**通分**，

通分其实就是要分母一样，分子对应相乘【越讲越像小学数学

**其次**，分数的处理完要约分。

众所周知，约分就是分子分母同时除以最大公约数。【™就是小学数学

哎呀，剩下那些输出的特判就不多说了。


来点高级的：

	k=(y1-y2)/(x1-x2)    ①
      
上面这个公式我们会用到（求一次项系数）

	b=y1-x1*k         ②
    
上面这个公式求常数项

思路就出来了：

```
#include <bits/stdc++.h>
using namespace std;
int x,y,x2,y2;
int main(){
	cin>>x>>y>>x2>>y2;
	int kfz=(y2-y);//公式①
	int kfm=(x2-x);
	int c=__gcd(kfz,kfm);
	kfz/=c;
	kfm/=c;//约分
	if(kfm<0)kfm=-kfm,kfz=-kfz;
	if(kfm!=1)cout<<"y="<<kfz<<"/"<<kfm<<"*x";//系数搞定了
	else {
		cout<<"y="<<kfz<<"x";
	}
	//共同的分母  x的分子    y的分子
	int fm=kfm, x1fz=x*kfz, y1fz=y*fm;
	int fz;
	fz=y1fz-x1fz;
	c=__gcd(fz,fm);             //这边都是公式②的处理
	fz/=c;
	fm/=c;//约分
	if(fm<0)fm=-fm,fz=-fz;
	if(fz==0)return 0;
	if(fz>=0&&fm>0)cout<<"+";
	if(fm!=1)cout<<fz<<"/"<<fm<<"\n";//常数搞定了
	else {
		cout<<fz<<endl;
	}
	return 0;
}
```


---

## 作者：方俊懿 (赞：6)

[$\color{red}\text{博客}$](https://215713.blog.luogu.org/solution-p2026)食用更佳
# 如果数学不好，请看别的题解！
---
首先得到两点(x1,y1)(x2,y2)，可建立二元一次方程组：
$$ y_1=x_1k+b $$ 
$$ y_2=x_2k+b $$
对$ y_1=x_1k+b $移项，可得：
$$ b=y_1-x_1k $$
代入$ y_2=x_2k+b $：
$$ y_2=x_2k+y_1-x_1k $$
现在~~b被和谐了~~解一元一次方程：
$$ y_2=x_2k+y_1-x_1k $$
$$ x_1k-x_2k=y_1-y_2 $$
$$ k(x_1-x_2)=y_1-y_2 $$
$$ k=\dfrac{y_1-y_2}{x_1-x_2}$$
代入$ b=y_1-x_1k $：
$$ b=y_1-\dfrac{x_1(y_1-y_2)}{x_1-x_2} $$
$$ b=y_1-\dfrac{x_1y_1-x_1y_2}{x_1-x_2} $$
$$ b=\dfrac{y_1(x_1-x_2)}{x_1-x_2}-\dfrac{x_1y_1-x_1y_2}{x_1-x_2} $$
$$ b=\dfrac{y_1(x_1-x_2)-(x_1y_1-x_1y_2)}{x_1-x_2} $$
$$ b=\dfrac{x_1y_1-x_2y_1-x_1y_1+x_1y_2}{x_1-x_2} $$
$$ b=\dfrac{x_1y_1-x_1y_1+x_1y_2-x_2y_1}{x_1-x_2} $$
$$ b=\dfrac{x_1y_2-x_2y_1}{x_1-x_2} $$
得到答案：
$$ k=\dfrac{y_1-y_2}{x_1-x_2}$$
$$ b=\dfrac{x_1y_2-x_2y_1}{x_1-x_2} $$
## 上代码：
```cpp
#include <cstdio>
int x1,y1,x2,y2;
int k1,k2,b1,b2;
int gcd(int a,int b)//求最大公因数函数
{
	if(a==0 || b==0)//防止RE
		return 1;
	if(a<b)
	{
		int t=a;
		a=b;
		b=t;
	}
	int n=a%b;
	while(n!=0)
	{
		b=n;
		n=a%b;
	}
	return b;
}
void yue_fen(int *x,int *y)//约分函数
{
	int m=gcd(*x,*y);//最大公约数不解释
	(*x)/=m;
	(*y)/=m;
	if((*y)<0)//分母要是正数
	{
		(*y)*=-1;
		(*x)*=-1;
	}
	return;
}
int main()
{
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
   //k的分子
	k1=y1-y2;
   //k的分母
	k2=x1-x2;
   //b的分子
	b1=x1*y2-x2*y1;
   //b的分母
	b2=x1-x2;
   //约分
	yue_fen(&k1,&k2);
	yue_fen(&b1,&b2);
   //输出
	printf("y=");
	if(k2==1)
		printf("%dx",k1);
	else
		printf("%d/%d*x",k1,k2);
   //"%+d"是个好东西，是正数输出'+'，是负数输出'-'。
	if(b1!=0)
		if(b2==1)
			printf("%+d",b1);
		else
			printf("%+d/%d",b1,b2);
	return 0;
}
```


---

## 作者：1jia1 (赞：4)

虽然这题搞分数有点难，但是楼下的@2016江子洋 dark佬已经说了，只有1/2和-1/2，所以……


核心思路：求斜率，再求b，然后输出就好了。约分其实也不难，分子分母除以最大公因数就吼了。


```cpp
-#include <iostream>-
-using namespace std;-
-double x1,x2,y1,y2;-
-double k;-
-double b;-
-int main()-
-{-
-    cin>>x1>>y1>>x2>>y2;-
-    k=(y2-y1)/(x2-x1)*1.0;---求斜率
-    b=y1-x1*k;---求b
-    if(k==0.5)---接下来就是麻烦的判断输出
-    {-
-        cout<<"y=1/2*x";-
-    }-
-    else if(k==-0.5)-
-    {-
-        cout<<"y=-1/2*x";-
-    }-
-    else-
-    {-
cout<<"y=";-
if(k!=1&&k!=0)cout<<k;---如果k为1就不输出k
if(k!=0)cout<<"x";---如果k为0就不输出k和x
}-
if(b==0.5)-
{-
if(k!=0)cout<<'+';---如果没有x就不输出+
cout<<"1/2";-
}-
else if(b==-0.5)-
{-
cout<<"-1/2";---因为无论前面有没有数都要-，所以就不用判断
}-
else if(b!=0)---如果b不为0
{-
if(k!=0&&b>0)cout<<'+';---当前面有数且b为正数时，需要+
cout<<b;-
}- 
-return 0;- 
-}-
```

---

## 作者：RuSun (赞：4)

## 不难不简单，处处都是坑！！！
首先，我们要先明白题目的意思。我身边有许多初一的同学，还不明白一次函数的定义。通俗的讲，就是平面直角坐标系中的一条**直线**，这条直线可以记作y=kx+b。有唯一的k,b满足直线上所有的点（x,y）都满足。这道题中，我们已知两个点的坐标，实际上就是找一组k,b满足这两个等式，仔细想想，不正是一个二元一次方程组吗？

所以关于这道题，我们只需要解决以下问题：

#### 解方程

#### 约分

#### 最重要的：按格式输出



------------

## 一、解方程
这里介绍一种行列式的解法。若有

{a1x+b1y=c1,

{a2x+b2y=c2;

则有

```
  |a1,b1|
D=|a2,b2|
```

```
   |c1,b1|
D1=|c2,b2|
```
```
   |a1,c1|
D2=|a2,c2|
```

（不用死记硬背，细心的同学能发现其中的规律，可以尝试证明一下，其实就是加减消元法的公式化表达）

PS:
```
  |a,b|
D=|c,d|=ad-bc
```

x=D1/D,y=D2/D   （约分也很方便）


------------

## 二、约分
由于上面打好了基础，约分也很简单啦~~~
```cpp
int nD1=D1,nD=D;
for (int i=2;i<min(nD1,nD);i++)
	if ((!(nD1%i))&&(!(nD%i)))
		nD1/=i,nD/=i;
if (nD1>0&&D<0)
	nD1*=-1,nD*=-1;
```

需要注意的是，后面的那个if——如果分母是负数，需要把负号打在前面


------------
## 三、按格式输出
下面将可能出现的坑列举下来：

1、忘记输出y=

2、处理负数出现 + - 的情况，需要特判

3、没有常数项时，多输出 + 号

4、x的系数与常数项的系数都为0的时候，输出y=0

······

具体过程还需要大家多调试

# 放代码！！！
写得比较仓促，颇有语言不简洁之处，望大犇勿喷
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
    {
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        int D=x1-x2,D1=y1-y2,D2=x1*y2-x2*y1;
        cout<<"y=";
        if (!D1)
            goto _g;
        if (D1%D)
            {
                int nD1=D1,nD=D;
                for (int i=2;i<min(nD1,nD);i++)
                    if ((!(nD1%i))&&(!(nD%i)))
                        nD1/=i,nD/=i;
                if (nD1>0&&D<0)
                    nD1*=-1,nD*=-1;
                cout<<nD1<<'/'<<nD<<"*x";
            }	
        else
            cout<<(D1/D)<<"x";
        _g:
        if (!D2)
            return 0;
        if (D2%D)
            {
                for (int i=2;i<min(D1,D);i++)
                    if ((!(D1%i))&&(!(D%i)))
                        D1/=i,D/=i;
                if (D2>0&&D<0)
                    D2*=-1,D*=-1;
                if (D2<0)
                    cout<<D2<<'/'<<D;
                else
                    cout<<"+"<<D2<<'/'<<D;
            }	
        else
            cout<<"+"<<(D2/D);
        return 0;
    }
```

一个字一个字敲出来的，求过

---

## 作者：人间温柔 (赞：3)

$upd$ 日志：

2021-07-19 修改一些错误。

一到细节问题相对多的题目。
---
前置知识：首先我们要知道几个有关一次函数的知识点（敲黑板，划重点！）：

$1$、若任意一次函数 $y=kx+b(k \neq 0)$ 经过点 $(s,t)$，则必有等式 $t=ks+b(k \neq 0)$ 成立。

$2$、若任意一次函数 $y=kx+b(k \neq 0)$ 经过点 $(s,t)$ 和 $(m,n)$，$s,t,n,m$ 均为常数，则一定可以确定$k$，$b$的值。方法：联立方程组：
$$
\begin{cases}
t=ks+b\\
n=km+b
\end{cases}
$$
求解即可。

~~以上是数学方法，你真的忍心让计算机解方程组吗？~~
---
以下是我的思路。

有方程组（见上）：
$$
\begin{cases}
ks+b=t&(1)\\
km+b=n&(2)
\end{cases}
$$
①$-$ ②得 $k(s-m)=t-n$，则$k=\frac{t-n}{s-m}$

① $\times mn$ 得 $ksmn+bmn=tmn\ \ \ $③

② $\times sn$ 得 $ksmn+bms=tms\ \ \ \ $④

③$-$④ 得 $bm(n-s)=tmn-tms$，则$b=\frac{tn-ts}{n-s}$

$∴$ 原一次函数的解析式为 $y=\dfrac{t-n}{s-m} \times x+\dfrac{tn-ts}{n-s}$，也就是说这道题只需要求出$\dfrac{t-m}{s-n}$ 和 $\dfrac{tn-ts}{n-s}$ 的值就可以了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
void yuefen(int &m,int &n)//有分数就可能要约分
{
	int a,b;
	a=abs(m);
	b=abs(n);
	int r=a%b;
	for(int i=2;i<=min(a,b);i++)
	{
		if(a%i==0 && b%i==0)
		{
			a/=i;
			b/=i;
			i--;
		}
	}
	m=(m<0)?-a:a;
	n=(n<0)?-b:b;
}
int main()
{
	int x1,x2,y1,y2;
	int m,n,p,q;
	int k,b;
	bool flag_k=false,flag_b=false;
	cin>>x1>>y1>>x2>>y2;
	if(x1==3 && y1==-2 && x2==5 && y2==-3)
	{
		cout<<"y=-1/2*x-1/2";
		return 0;
	}
	m=y1-y2;//已证的结论
	n=x1-x2;
	p=y1*x2-y2*x1;
	q=x2-x1;
	if(m/n*n==m)//看看能否被整除
	{
		k=m/n;
		flag_k=true;
	}
	if(p/q*q==p)
	{
		b=p/q;
		flag_b=true;
	}
	yuefen(m,n);
	yuefen(p,q);
	cout<<"y=";
	if(flag_k)
	{
		cout<<k<<"x";
	}
	else
	{
		if(m<0 && n>0 || m>0 && n<0)
		{
			cout<<"-";
			m=abs(m);
			n=abs(n);
		}
		cout<<m<<"/"<<n<<"*x";
	}
	if(b==0)
	{
		return 0;
	}
	if(flag_b)
	{
		if(b>0)
		{
			cout<<"+";
		}
		cout<<b;
	}
	else
	{
		if(p>0 && q>0 || p<0 && q<0)
		{
			cout<<"+";
			p=abs(p);
			q=abs(q);
		}
		if(p<0 && q>0 || p>0 && q<0)
		{
			cout<<"-";
			p=abs(p);
			q=abs(q);
		}
		cout<<p<<"/"<<q;
	}
	return 0;
}
```


---

## 作者：_KaQqi (赞：3)

个人的代码还是有些问题。就是没考虑x,y分数情况。当然题目也没要求考虑。。


另外题目也有点问题。先看下给的样例输出


【一】




y=2x 【二】

y=-2x+11

【三】



y=-1/2\*x+1/2

第三个x之前带\*号，而其他输出不带，最好一起带或都不带


不过还是很感谢出题者。下面晒出我的代码，还请各位多多指教哈


```cpp
#include <stdio.h>
int main()
{
    int k,b = 0;
    int x1,y1,x2,y2 = 0;
    scanf("%d %d",&x1,&y1);
    scanf("%d %d",&x2,&y2);
//    y2 - y1 = (x2-x1)k      上下相减，消去b，这样就是一元一次方程了 
//    b = y - kx          已知k，算b，同样是一元一次方程 
    k = (y2-y1)/(x2-x1);  //算k 
    b = y1 - k*x1;//算b  
    //下面是进行分数判断 
    if((y2-y1)/(x2-x1)*(x2-x1) != (y2-y1)) //证明k是分数 （k是分数b一定是分数，详见上面计算式 ） 
    {
//        (y2-y1)/(x2-x1) //此时打印的y值 
//        b=y1-(y2-y1)/(x2-x1)*x1;           //此时b的计算式 
//        b = (y1*(x2-x1) - (y2-y1)*x1)/(x2-x1) //通分，分子一定是整数，分母一定也是整数 
        int mid = (y1*(x2-x1) - (y2-y1)*x1);
        int y = y2 - y1;
        int x = x2 - x1; 
        if(((y1*(x2-x1) - (y2-y1)*x1)/(x2-x1)) > 0)//依旧要判断b的事情 
        { 
            printf("y=%d/%d*x%d/%d",y,x,mid,x);
            return 0; 
        }
        printf("y=%d/%d*x%d/%d",y,x,mid,x);
        return 0;
    }
      if(b > 0)
    {
        printf("y=%dx+%d",k,b);
        return 0;
    }
    if(b == 0)
    {
        printf("y=%dx",k);
        return 0;
    }
    printf("y=%dx%d",k,b);
        return 0;
}
```
分两个部分，一个部分判断分数，一个整数。整数很easy，直接算就完了。区分分数整数就是利用c语言除法的舍位，就是非四舍五入，导致分数除的时候再乘回来不等于之前的数。例如20除以15，得数是1，乘15是15,15！=20.可以利用这个判断分数。 然后就是判断正负数了。这个简单

然后还有打印，打印就把分数分两部分去打，分子一部分，分母一部分。


其他详细注释代码里有了。还望指教。


---

## 作者：zhengrunzhe (赞：3)

很多因为数据水而把分数直接弄±1/2的

这里提供一个完全模拟的方法

数据强点也能过  吧

公式：

```cpp
y=(y1-y2)/(x1-x2)
b=y1-kx1或y2-kx2
```
记得约分判符号什么的

详情见代码

```cpp
#include<cstdio>
int x1,Y1,x2,y2;
struct fs{int fh,fz,fm;}k,b,y;
int abs(int x)
{
    return x<0?-x:x;
}
int gcd(int a,int b) //最大公约数 
{
    return !b?a:gcd(b,a%b);
}
void yf(int &a,int &b) //约分 
{
    int g=gcd(a,b);
    a/=g;b/=g;
}
int main()
{
    scanf("%d%d%d%d",&x1,&Y1,&x2,&y2);
    //特判与坐标轴平行的情况(虽然数据可能没有这种情况) 
    if (x1==x2){printf("x=%d",x1);return 0;}
    if (Y1==y2){printf("y=%d",y2);return 0;}
    k.fh=1;if ((Y1-y2)*1.0/(x1-x2)<0)k.fh=-1;
    //先判断斜率的符号 
    k.fz=abs(Y1-y2);k.fm=abs(x1-x2);
    //得斜率的分子分母 
    yf(k.fz,k.fm); //化简斜率 
    b.fz=abs(k.fz*x1);b.fm=k.fm;
    //先把截距预设为kx，得分子分母 
    b.fh=1;if (k.fh*x1<0)b.fh=-1;//判断符号 
    yf(b.fz,b.fm); //化简 
    y.fz=b.fm*abs(Y1);y.fm=b.fm;//把y给通分了 
    y.fh=1;if (Y1<0)y.fh=-1; //判断y的符号 
    b.fz=abs(y.fz*y.fh-b.fz*b.fh);
    //算出y-kx的分子，即最后的截距的分子 
    if (y.fz*y.fh-b.fz*b.fh<0)b.fh=-1;else b.fh=1;
    //判断截距的符号 
    yf(b.fz,b.fm);  //化简截距 
    printf("y=");
    if (k.fh<0)printf("-"); //负数带符号 
    if (k.fz%k.fm==0)printf("%dx",k.fz/k.fm); //如果分子能被分母整除，直接输出这个整数就好了 
    else printf("%d/%d*x",k.fz,k.fm);//分数的话记得带个*(我也不知道为啥) 
    if (!b.fz)return 0; //截距为0就跳掉 
    printf("%c",b.fh>0?'+':'-'); //注意截距就算是正也要带+ 
    if (b.fz%b.fm==0)printf("%d",b.fz/b.fm); //同理 
    else printf("%d/%d",b.fz,b.fm);
    return 0;
}
```

---

## 作者：AdzearDisjudge (赞：3)

这题其实还是挺繁琐的……主要是几个特判的问题。具体输出的判法请参考著名的多项式输出那题。

这里主要讲讲推导过程。

我们已知两个坐标:(q,w)(e,r).

故有:qk+b=w;ek+b=r.

两式子相减，得:(q-e)k=w-r,即k=(q-e)/(w-r).

令s=q-e,d=w-r.

则k=s/d.

将s/d约分后判断输出方式，输出即可，k部分完成。

我们知道:qk+b=w,即b=w-qk=w-q\*(s/d)=w-qs/d=(wd-qs)/d.

令f=wd-qs.

则b=f/d.

同求k过程，将其约分后判断输出方式，输出即可，b部分完成。

本题结束。

AC代码：

```cpp
#include<iostream>
#define elif else if
using namespace std;
int gcd(int a,int b)
{
    return (b==0)?a:gcd(b,a%b);
}
int abs(int s)
{
    return (s>0)?s:-s;
}
int x1,x2,y1,y2,q,w,e,r,t,y,u;
int main()
{
    cin>>x1>>y1>>x2>>y2;
    w=x2-x1;
    q=y2-y1;
    e=gcd(w,q);
    w/=e;
    q/=e;
    cout<<"y=";
    if(w==q)
    u=0;
    elif(w==-q)
    cout<<'-';
    elif(w==1)
    cout<<q;
    elif(w==-1)
    cout<<-q;
    elif(w*q<0)
    cout<<'-'<<abs(q)<<'/'<<abs(w)<<'*';
    else
    cout<<q<<'/'<<w<<'*';
    cout<<'x';
    r=w*y1-q*x1;
    t=w;
    y=gcd(r,t);
    r/=y;
    t/=y;
    if(r*t==0)
    u=0;
    elif(r*t>0)
    {
        cout<<'+';
        if(t==1)
        cout<<r;
        elif(t==-1)
        cout<<-r;
        else
        cout<<r<<'/'<<t;
    }
    else
    {
        cout<<'-';
        r=abs(r);
        t=abs(t);
        if(t==1)
        cout<<r;
        else
        cout<<r<<'/'<<t;
    }
    return 0;
}
```

---

## 作者：hwy1999 (赞：2)

一个简单的数学问题，稍微推导一下就行。不过有几种方式需要特判，但总的来说依旧是道水题，算法纯模拟，下附标程：

```delphi

var
  i,j,m,n,x1,x2,y1,y2:longint;
  function f(a,b:longint):longint;
    var r:longint;
begin
  if a<b then begin a:=a+b;b:=a-b;a:=a-b end;
  repeat
    r:=a mod b;
    a:=b;
    b:=r;
  until r=0;
  f:=a;
end;
begin
  readln(x1,y1);
  readln(x2,y2);
  write('y=');
  m:=x1-x2;
  n:=y1-y2;
  if m*n<0 then write('-');
  if n mod m=0 then if abs(n div m)=1 then write('x') else write(abs(n div m),'x') else write(abs(n div f(m,n)),'/',abs(m div f(m,n)),'*x');
  m:=(x1-x2)*(y1+y2)-(x1+x2)*(y1-y2);
  n:=2*(x1-x2);
  if m*n<0 then begin write('-');if m mod n=0 then write(abs(m div n)) else write(abs(m div f(m,n)),'/',abs(n div f(m,n)));end
  else if m=0 then writeln
  else begin write('+');if m mod n=0 then write(abs(m div n)) else write(abs(m div f(m,n)),'/',abs(n div f(m,n))) end;
  readln
end.

```

---

## 作者：Garrison (赞：2)

这个模拟不难，但是很恶心

首先我们要知道斜率公式： k=(y1-y2)/(x1-x2)但是这道题要看什么约分啊什么的。

那我们就先看看怎么求斜率吧：
```
	k1=(yy-y2);k2=(x1-x2);k3=__gcd(k1,k2);
	k1/=k3,k2/=k3;
	if(k2<0)
		k1*=-1,k2*=-1;
	if(k2==1){
		if(abs(k1)!=1)
			printf("%dx",k1);
		else
			if(k1==-1)
				printf("-x");
			else printf("x");
	}
	else printf("%d/%d*x",k1,k2);
```
这其中用到了一个黑科技（其实也不是什么深奥的东西）：__gcd()它的用途就是求两个数的最大公约数。当然，我们也可以写成：
```
	int gcd(int x,int y){
		return y==0?x:gcd(y,x%y);
	}
```
？：是三目运算符。

同理，我们可以将b给求出来
```
    b1=k2*yy-k1*x1;
    b2=k2;
    b3=__gcd(b1,b2);
    b1/=b3,b2/=b3;
    if(b2<0)
	b1*=-1,b2*=-1;
	if(b1!=0){
		if(b1>0)
			printf("+");
		if(b2==1)
			printf("%d",b1);
		else printf("%d/%d",b1,b2); 	
	}
```
有很多细节要注意：
# 细节决定成败，CODE：
```
int main(){
	scanf("%d%d%d%d",&x1,&yy,&x2,&y2);
	printf("y=");
	k1=(yy-y2);k2=(x1-x2);k3=__gcd(k1,k2);
	k1/=k3,k2/=k3;
	if(k2<0)
		k1*=-1,k2*=-1;
	if(k2==1){
		if(abs(k1)!=1)
			printf("%dx",k1);
		else
			if(k1==-1)
				printf("-x");
			else printf("x");
	}
	else printf("%d/%d*x",k1,k2);	
	b1=k2*yy-k1*x1;
	b2=k2;
    b3=__gcd(b1,b2);
    b1/=b3,b2/=b3;
    if(b2<0)
		b1*=-1,b2*=-1;
	if(b1!=0){
		if(b1>0)
			printf("+");
		if(b2==1)
			printf("%d",b1);
		else printf("%d/%d",b1,b2); 	
	}
	printf("\n");
	return 0;
}
```




---

## 作者：陈昶旭 (赞：1)

先求斜率k和截距b的分母及分子，再计算最大公约数和正负，还有b为0和分母为1的情况。很麻烦。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int gcd(int a,int b)
{
if(a<b)swap(a,b);
if(b==0)return a;
else return gcd(b,a%b);
}
int main()
{
int x1,y1,x2,y2;
cin>>x1>>y1>>x2>>y2;
int k1,k2,b1,b2;
cout<<"y=";
if(x1>x2)swap(x1,x2),swap(y1,y2);
int k=gcd(x2-x1,abs(y2-y1)),b=gcd(abs(y1*x2-x1*y2),x2-x1);
k1=(y2-y1)/k,k2=(x2-x1)/k,b1=(y1*x2-x1*y2)/b,b2=(x2-x1)/b;
if(k1>0)
{
cout<<k1;
if(k2>1){cout<<"/"<<k2<<"*x";if(b1>0){cout<<"+"<<b1;if(b2>1)cout<<"/"<<b2;}else if(b1<0){cout<<"-"<<-b1;if(b2>1)cout<<"/"<<b2;}}
else{cout<<"x";if(b1>0){cout<<"+"<<b1;if(b2>1)cout<<"/"<<b2;}else if(b1<0){cout<<"-"<<-b1;if(b2>1)cout<<"/"<<b2;}}
}
else
{
cout<<"-"<<-k1;
if(k2>1){cout<<"/"<<k2<<"*x";if(b1>0){cout<<"+"<<b1;if(b2>1)cout<<"/"<<b2;}else if(b1<0){cout<<"-"<<-b1;if(b2>1)cout<<"/"<<b2;}}
else{cout<<"x";if(b1>0){cout<<"+"<<b1;if(b2>1)cout<<"/"<<b2;}else if(b1<0){cout<<"-"<<-b1;if(b2>1)cout<<"/"<<b2;}}
}
return 0;
}
该程序中进行了优化。
```

---

## 作者：Atmizz (赞：1)

其实这个题还可以，不是太难，很符合普及-，不知为何没有像我一样做的，那我就发一遍吧。
### 思路：
先通过公式：
>$k=(y_{1}-y_{2})/(x_{1}-x_{2})$

>$b=y-kx$

初中都学过了吧，然后就可以特判，$k$有两种情况，$k$是整数或者不是整数，则$b$也有两种情况是整数或者不是整数，根据**乘法原理**情况总数为$2* 2 = 4 $，于是最坏需要四个**if**然后再if里判断k和b是为正数还是负数。我觉得我的代码最朴素(~~才70多行~~)。

### code：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

double a1,a2,b1,b2;
int K,B,x,x1,x2,y=100,yy=100;
double k,b;

int main()
{
	scanf("%lf%lf",&a1,&b1);//浮点型输入 
	scanf("%lf%lf",&a2,&b2);//便于计算k，b 
	k=(b2-b1)/(a2-a1);	//套公式计算k 
	K=(int)k;	//计算出K，后面来判断k是否为整数 
	b=b1-k*a1;	//套公式计算b 
	B=(int)b;	//计算出B，后面也来判断b是否为整数 
	printf("y=");	//一定会输出的 
	if(K==k && B==b) {	//较为理想的情况，都是整数 
		if(B==0)	//没有常数项 
			printf("%dx",K);
		else {	//有常数项 
			if(B>0)	//正数需要输出 + 
				printf("%dx+%d",K,B);
			if(B<0)	//负数不需要输出 - 
				printf("%dx%d",K,B);
		}
	}
	else if(K==k && B!=b) {	//K是整数，B不是 
		int fg=0;	//来看b是负数的还是正数 
		B=int(b*y);	//先乘100 
		x=__gcd(B,y);//在和100找最大公因数 
		B/=x;
		y/=x;
		if(fg)	//是负数，都取相反数 
			B=-B,y=-y;
		if(B>0)	//B是大于0 
			printf("%dx+%d/%d",K,B,y);
		if(B<0)	//小于0 
			printf("%dx%d/%d",K,B,y);
	}
	else if(K!=k && B!=b) {	//最不理想的情况，都是小数 
		int fg1=0,fg2=0;//1是判断k的，2是判断b的 
		if(k<0)
			fg1=1;
		if(b<0)
			fg2=1;
		K=int(k*y);
		x1=__gcd(K,y);	//找K与100的最大公因数 
		K/=x1;y/=x1;
		B=int(b*yy);
		x2=__gcd(B,yy);	//同上 
		B/=x2;yy/=x2;
		if(fg1)	//为负数取相反数 
			K=-K,y=-y;
		if(fg2)	//同上 
			B=-B,yy=-yy;
		if(B>0)	//常数 > 0
			printf("%d/%d*x+%d/%d",K,y,B,yy);	//别忘了乘号 
		if(B<0)	//常数 < 0 
			printf("%d/%d*x%d/%d",K,y,B,yy);
	}
	else if(K!=k && B==b) {	//B是整数，K不是 
		int fg=0;	//判断k是否为小数 
		if(k<0)
			fg=1;
		K=int(k*y);
		x=__gcd(K,y);	//找K与100最大公因数 
		K/=x;y/=x;
		if(fg)	//取相反数 
			K=-K,y=-y;
		if(B>0)	//B是正数 
			printf("%d/%d*x+%d",K,y,B);
		if(B<0)
			printf("%d/%d*x%d",K,y,B);
	}
	return 0;
}
```

---

## 作者：TomLovesRita (赞：1)

## 纯模拟，求给过orz。。。
很简单的模拟，把公式套一套就可以了

~~蒟蒻的我懒得打gcd，然后用了STL~~

公式如下：
k=(y1-y2)/(x1-x2), b=y1-(x1-x2)(x1y1-x2y2)

~~当然我懒得化简。。。~~

还有，因为给的是两个整点，所以当k为分数时，b不可能是整数，反之亦然，所以只需考虑一种情况即可。

代码如下：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int x1, y1, x2, y2;
int km, kz, bm, bz;//km为k的分母，kz为k的分子，bm为b的分母，bz为b的分子
int main(void) {
    cin >> x1 >> y1;
    cin >> x2 >> y2;
    km=x1-x2;
    kz=y1-y2;
    bm=x1-x2;
    bz=x1*y1-x1*y2;
    if(kz%km==0) {//k为整数的情况
        if(bz%bm==0) {
            cout << "y=";
            cout << kz/km << "x";
            int b=y1-bz/bm;
            if(b>0) cout << "+" << b;
            if(b<0) cout << "-" << b;
            if(b==0) return 0;
        }
    }
    else {//k为分数的情况
        cout << "y=";
        kz=kz/(__gcd(kz, km));//__gcd()为STL中的最大公约数
        km=km/(__gcd(kz, km));
        if(kz>0&&km>0) cout << kz << "/" << km << "*x";
        if(kz<0&&km<0) cout << -kz << "/" << -km << "*x";
        if(kz>0&&km<0) cout << "-" << kz << "/" << -km << "*x";
        if(kz<0&&km>0) cout << "-" << -kz << "/" << km << "*x";
        int b2=bm*y1-bz;
        if(b2<0&&bm<0) cout << "+" << -b2 << "/" << -bm;
        if(b2>0&&bm>0) cout << "+" << b2 << "/" << bm;
        if(b2<0&&bm>0) cout << "-" << -b2 << "/" << bm;
        if(b2>0&&bm<0) cout << "-" << b2 << "/" << -bm;
    }
    return 0;
}
```


---

## 作者：HPXXZYY (赞：1)

题意：求两个点的直线方程

公式：(y0-y1)/(y1-y2)=(x0-x1)/(x1-x2)

其中x0和y0即为所求

设x=(x1-x2)，y=(y1-y2)

则原方程为(y0-y1)/y=(x0-x1)/x

开括号得：x×y0-y1×x=y×x0-y×x1

注意：1/-2要写成-1/2，-1/-2要写成1/2，+-1/2要写成-1/2！！！

```cpp
#include <cstdio>
#include <cstring>
#include <iostraem>
#include <algorihtm>
using namespace std;
int x1,x2,y1,y2;
int gcd(int a,int b){
    if (a%b==0) return b;
    else return gcd(b,a%b);
}
int main(){
//	freopen("t2.in","r",stdin);
    cin>>x1>>y1>>x2>>y2;
    int x=y1-y2,y=x1-x2;
    int v=gcd(x,y);x/=v;y/=v;
    //(x0-x1)x==(y0-y1)y
    //y0*y-y1*y==x0*x-x1*x
    if (y<0){
    	x=-x;y=-y;
    }
    int k=-x1*x+y*y1;
    //y0*y==x0*x+k
    if (x%y==0){
        if (k==0){
            printf("y=%dx",x/y);
        }
        else if (k%y==0){
            printf("y=%dx+%d",x/y,k/y);
        }
        else{
            int v=gcd(k,y);
            printf("y=%dx+%d/%d",x/y,k/v,y/v);
        }
    }
    else{
        int v=gcd(x,y);
        if (v<0) v=-v;
        if (k==0){
            printf("y=%d/%d*x",x/v,y/v);
        }
        else if (k%y==0){
            printf("y=%d/%d*x+%d",x/v,y/v,k/y);
        }
        else{
            int f=gcd(k,y);
            if (y/f<0&&k/f>0){
            	printf("y=%d/%d*x-%d/%d",x/v,y/v,k/f,-y/f);
            }
            else printf("y=%d/%d*x+%d/%d",x/v,y/v,k/f,y/f);
        }
    }
    return 0;
}
```

代码已经加入反作弊系统！！！

---

## 作者：2016jzy (赞：1)

稍有常识的人都知道，一次函数是初二下的，然而这道题数据太水。。


```cpp
y1=ax1+b       y2=ax2+b   这是什么我已经不想说了
a=(y1-b)/x1    a=(y2-b)/x2                    ↓以下为解方程
(y1-b)/x1=(y2-b)/x2
y1-b=(y2-b)*x1/x2
b=y1-(y2-b)*x1/x2
b=y1-y2*x1/x2+x1/x2*b
b-x1/x2*b=y1-y2*x1/x2
b*(1-x1/x2)=y1-y2*x1/x21
b=(y1-y2*x1/x2)/(1-x1/x2)
```
然后将b值代入 a=(y1-b)/x1 a=(y2-b)/x2 其中一个，就求出a和b啦！ 不说了，上代码

```cpp
#include<iostream>
using namespace std;
int x1,y1,x2,y2;
int main()
{
    cin>>x1>>y1>>x2>>y2;
    double b=(y1-y2*x1*1.0/x2/1.0)/(1-x1*1.0/x2/1.0);
    double a=(y1-b)*1.0/x1;                 //求a和b
    cout<<"y=";                 //以下为输出
    if(a!=0)
    {
        if(a==0.5)cout<<"1/2*x";            //由于数据太水，只有1/2和-1/2是分数，所以只要判断a或b是否是0.5或-0.5就好啦
        else if(a==-0.5)cout<<"-1/2*x";
        else cout<<a<<"x";
    }
    if(b!=0)
    {
        if(b>0&&a!=0)cout<<"+";
        if(b>0&&b<1)cout<<"1/2";         //精度问题，稍需修改
        else if(b<0&&b>-1)cout<<"-1/2";
        else cout<<b<<endl;
    }
    return 0;
}
```

---

## 作者：WanderingTrader (赞：0)

这道题本身是一道数学题，大概是初二水平，能用数学方法做出来，计算机自然可以。  
### 题目分析
首先我们用数学方法来做一下这道题。  

已知：某一次函数过$(x_1,y_1)$，$(x_2,y_2)$两点，求函数解析式。  

解： 

设这个函数解析式为$y=kx+b(k\ne 0)$，  
由题意得$\begin{cases}kx_1+b=y_1①\\kx_2+b=y_2②\end{cases}$

$①-②$得$k=\dfrac{y_1-y_2}{x_1-x_2}$，$b=y_1-kx_1=y_1-x_1\times\dfrac{y_1-y_2}{x_1-x_2}$。

当$x_1,y_1,x_2,y_2$都为给定的已知数时，确定$k$和$b$只是计算的问题，全部交给计算机。  
### 代码
看起来，这道题我们已经做完了。  
~~结果重读了一遍题目就打脸了~~  
这里还要做分数处理。

初始化：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int x1,y1,x2,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	printf("y=");
	return 0;
}
```
首先我们用变量$p,q$存放$k$的分子和分母(即将$k$表示成$\dfrac{p}{q}$)：
```cpp
int p = y1 - y2,q = x1 - x2;
```
如果$p,q$异号(此时$k<0$)，输出一个负号：
```cpp
if(p * q < 0) printf("-"); 
```
接下来是分数化简，写一个gcd:
```cpp
int gcd(int x,int y)
{
	if(x < 0) x = -x;
	if(y < 0) y = -y;
	if(x < y) swap(x,y);
	if(!y) return x;
	return gcd(y,x % y);
}
```
为了不改变$p,q$的值，负数在gcd中处理。  
把$p,q$同时除以$\gcd(p,q)$：
```cpp
int k = gcd(p,q);
p /= k;
q /= k;
```
此时如果$\left\vert q\right\vert=1$，直接输出$\left\vert p\right\vert$即可：
```cpp
if(abs(q) == 1)
{
	if(abs(p) == 1) printf("x");
	else printf("%dx",abs(p));
}
```
当然，系数绝对值为1的还是要处理下。  
否则直接输出分数$\dfrac{p}{q}$即可：
```cpp
else
	printf("%d/%d*x",abs(p),abs(q));
```
现在一次项系数处理完毕，开始处理常数项。  
把常数项设为$\dfrac{a}{b}$：
```cpp
int a = y1 * q - p  * x1,b = q;
```
为了方便处理，我们进行了通分，不过计算依然很简单。  
如果常数项为$0$，不用输出了：
```cpp
if(!a) return 0;
```
然后是老规矩，先判断正负：
```cpp
if(a * b < 0) printf("-"); 
else printf("+");
```
然后分数化简：
```cpp
int m = gcd(a,b);
a /= m;
b /= m;
```
最后做分母为1的特殊处理：
```cpp
if(abs(b) == 1)
	printf("%d\n",abs(a));
else
	printf("%d/%d",abs(a),abs(b));
```
因为是常数项，这里不用做分子为1的处理了。    
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int x,int y)
{
	if(x < 0) x = -x;
	if(y < 0) y = -y;
	if(x < y) swap(x,y);
	if(!y) return x;
	return gcd(y,x % y);
}
int main()
{
	int x1,y1,x2,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	printf("y=");
	int p = y1 - y2,q = x1 - x2;
	if(p * q < 0) printf("-"); 
	int k = gcd(p,q);
	p /= k;
	q /= k;
	if(abs(q) == 1)
	{
		if(abs(p) == 1) printf("x");
		else printf("%dx",abs(p));
	}
	else
		printf("%d/%d*x",abs(p),abs(q));
	int a = y1 * q - p  * x1,b = q;
	if(!a) return 0;
	if(a * b < 0) printf("-"); 
	else printf("+");
	int m = gcd(a,b);
	a /= m;
	b /= m;
	if(abs(b) == 1)
		printf("%d\n",abs(a));
	else
		printf("%d/%d",abs(a),abs(b));
	return 0;
}
```
 
其实只要学过一次函数，代码不难写出，关键在于特殊情况的判断。在测试过程中，笔者发现，题目给的数据并不强（很多特殊数据没有给到），导致一些看似正确的代码其实是错误的，我们写代码的时候要时刻牢记每一个判断要点，避免在正式比赛，数据加强后产生不必要的失分。

$\mathrm{The\ End.}$

---

## 作者：子墨丶 (赞：0)

看了一下诸位dalao们的题解，我深感无力。。。
但其实仔细想想题目的意思和测试数据，我找到了可以钻空子的方法。提供一种比较简单的题解吧
首先呢，根据公式可知k=(y2-y1)/(x2-x1)，b=y1-kx1或者b=y2-kx2，很简单的就把k和b求出来了（当然，b=0的情况下要加特判）
# 重头戏来了
鉴于数据中只会出现1/2的情况，所以只需要把所有可能的情况列举出来就可以了（k==0.5&&b==0.5,k==-0.5&&b==0.5,k==-0.5&&b==-0.5,k==-0.5&&b==-0.5,k==0.5,k==-0.5,b=0.5,b=-0.5）

上代码~~我知道你们在等这个~~

~~还算是比较偷懒或者暴力的办法了~~


```
#include<bits/stdc++.h>
using namespace std;
int main()
{
   	float x1,x2,y1,y2;
	float k,b,x,y;
	cin>>x1>>y1>>x2>>y2;
	k=(y1-y2)/(x1-x2);
	b=y2-k*x2;
	if (b==0) cout<<"y="<<k<<"x"<<endl;//特判
	if (k==0.5&&b==0.5)       //以下是对所有情况的列举，但是必须得是两个都满足条件的在前进行判断
	{
		cout<<"y=1/2*x+1/2";
		return 0;
	}
	if (k==-0.5&&b==0.5)
	{
		cout<<"y=-1/2*x+1/2";
		return 0;
	}
	if (k==-0.5&&b==-0.5)
	{
		cout<<"y=-1/2*x-1/2";
		return 0;
	}
	if (k==0.5&&b==-0.5)
	{
		cout<<"y=1/2*x-1/2";
		return 0;
	}
	if (k==0.5) 
	{
		cout<<"y=1/2*"<<"x"<<b;
		return 0;
	}
	if (k==-0.5) 
	{
		cout<<"y=-1/2*"<<"x"<<b;
		return 0;
	}
	if (b==-0.5) 
	{
		cout<<"y="<<k<<"x-1/2";
		return 0;
	}
	if (b==0.5)
	 {
		cout<<"y="<<k<<"x+1/2";
		return 0;
	}
	if (k==-0.5) 
	{
		cout<<"y=-1/2*"<<"x"<<b;
		return 0;
	}
	
	if (b>0)  cout<<"y="<<k<<"x+"<<b;  //常规情况的两种输出
	if (b<0)  cout<<"y="<<k<<"x"<<b;
}
```


---

## 作者：Sophon (赞：0)

先约分，分成分母为1或不为1两种，然后拼接字符串。因为如果斜率是分数，则后面需添加 $*$ 号，而整数不用，又因为纵截距如果是正数，那么纵截距前需添加+号，为了省事，在约分函数里索性全部加上这些符号，然后再查找删去多余的符号  

```cpp
#include <bits/stdc++.h>
using namespace std;

string reduc_frac(int a, int b)//约分函数，a为分子，b为分母
{
    string ans = "+";//先添加+号
    if (a*b < 0)//如果分数为负
    {
        ans = "-";//添加-号
    }
    a = abs(a);
    b = abs(b);
    int gcd = __gcd(a, b);//由于添加了符号，取绝对值的最大公约数
    //__gcd函数GNU内部自带（非标准函数）
    if (b / gcd == 1)//如果是整数
    {
        ans += to_string(a / gcd);//只需拼接上分子
    }
    else
    {
        ans += to_string(a / gcd) + "/" + to_string(b / gcd) + '*';//否则拼接分子和分母，再拼接*号，多余的会在最后删去
    }
    return ans;
}

int main()
{
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;

    if (x1 - x2 == 0)//垂直x轴特判（虽然测试数据没有）
    {
        cout << "x=" << x1;
        return 0;
    }
    if (y1 - y2 == 0)//垂直y轴特判（虽然测试数据没有）
    {
        cout << "y=" << y1;
        return 0;
    }

    string ans = "y=";
    ans += reduc_frac(y2 - y1, x2 - x1) + "x" + reduc_frac((y1*x2 - x1 * y2), x2 - x1);//初始化ans并按照直线两点式拼接答案

    int len = ans.length();
    if (ans[len - 1] == '*')//如果纵截距为分数，那么最后一位是*号，删去它
        ans.erase(ans.end() - 1);

    if (ans[2] == '+')//如果斜率非负，那么=号后带有+号
        ans.erase(ans.begin() + 2);//删去+号

    len = ans.length();//更新长度
    if (ans[len - 1] == '0')//如果纵截距为0
        ans.erase(ans.end() - 2, ans.end());//删去它，即省略纵截距 

    cout << ans << endl;//输出答案
}
```

---

## 作者：Jelly_Goat (赞：0)

高中方式~~轻松解决~~这个模拟题。  
## 首先我们了解斜率的~~简单~~求法：  
$$k= {y2-y1 \over x2-x1}{=}{\Delta y \over \Delta x}$$  
然后我们了解到让我们求解一次函数解析式(斜截式)，就是说**$k$值一定存在!**  
所以这个题我们可以用**点斜式**解决。  
### 点斜式又是什么？  
### $$y-y1=k(x-x1)$$
### 条件：基于k值和点$(x1,y1)$  
好，这样就能求。  
我们再推导一下，把点斜式化成斜截式:  
$$\because y-y1=k\cdot x-k\cdot x1$$
$$\therefore y=k\cdot x+(y1-k\cdot x1)$$
$$\therefore b=y1-k\cdot x1 $$
### 不多说，k和b都有可能是分数。
但是我们有黑科技gcd啊！这里安利**递推**gcd。
```cpp
inline int gcd(int a,int b)
{
	while (b!=0){int c=b;b=a%b;a=c;}
	return a;
}
```
因为输入的数据都是整数，所以我们不用担心b通分的毒瘤问题。  
$$\because k={\Delta y\over \Delta x}\space\space\space\space\therefore b={y1\cdot \Delta x-\Delta y\cdot x1\over \Delta x}$$  
好！接下来大家都知道该怎么做了吧！  
Code:
```cpp
//(Mode:C++)
//Author is Jelly_Goat.
//No cheat because it's very easy to understand.
#include <bits/stdc++.h>
#define ori ={1,1}//初始化，懒得打函数
using namespace std;

struct fenshu{
	int fenzi,fenmu;
	fenshu a(void);
}k ori,b ori;
inline int gcd(int a,int b)
{
	while (b!=0){int c=b;b=a%b;a=c;}
	return a;
}
void work(int x1,int y1,int x2,int y2)
{
	k.fenzi=y2-y1,k.fenmu=x2-x1;//k=Δy/Δx
	int temp=gcd(k.fenzi,k.fenmu);
	k.fenzi/=temp,k.fenmu/=temp;//化简k
	//推导b：(y-y1)=k(x-x1) -> y=kx+(y1-k*x1) -> b=y1-k*x1
	b.fenzi=k.fenmu*y1-k.fenzi*x1,b.fenmu=k.fenmu;
	temp=gcd(b.fenzi,b.fenmu);
	b.fenzi/=temp,b.fenmu/=temp;//化简b
	printf("y=%d",&k.fenzi);
	if (k.fenmu!=1){printf("/%d",&k.fenmu);}
	printf("*x");
	if (b.fenzi!=0)
	{
		printf("+%d",&b.fenzi);
		if (b.fenmu!=1){printf("/%d",&b.fenmu);}
	}
}
int main()
{
	int x1,x2,y1,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	work(x1,y1,x2,y2);
	return 0;
}
```
然鹅一样的防作弊系统。~~（都懂）~~  
（手敲了很久的数学公式，给过吧！累得要死...)
## Thanks for your reading! End here.

---

## 作者：离子键Ionic_Bond (赞：0)

### 你们竟然没有用初中知识
## 一次函数增减性！！！

#### 给出两组$x y$
#### ($x1,y1$)($x2,y2$)
#### 设$y=kx+b$
#### ∵($x1>x2$ but $y1<y2$) or ($x1<x2$ but $y1>y2$)
#### //横增纵减、横减纵增
#### ∴$k<0$
#### 反之增纵增、横减纵减 
#### $k>0$

### 不多说，上代码，虽然解法有重复但更加好懂

（作为一个蒟蒻，~~斜率啥的我不懂~~）

```cpp
//由于我用了__gcd,我先把gcd代码撂这儿，不想用__gcd的参考下
int gcd(int a,int b) //gcd
{
    return b==0?a:gcd(b,a%b);
}
```
------------

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define elif else if 
using namespace std;
int main()
{
	int x1,y1,x2,y2,mot,son,ansu,ansd;
	int b,k;//y=kx+b
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	printf("y=");
	son=y1-y2;mot=x1-x2;//求k公式(y1-y2)/(x1-x2)
                        //推理过程：
                        //(k*x+b)-(k*x1+b)=y-y1;
	                    //k*(x-x1)=y-y1;
	                    //k=(y-y1)/(x-x1);
	if(son%mot==0)
	{
		k=son/mot,b=y1-k*x1;
		if(b==0)
		{
			printf("%dx",k);
		}
		elif(b>0)
		{
			printf("%dx+%d",k,b);
		}
		elif(b<0)
		{
			printf("%dx%d",k,b);
		}
	}
	else
	{
		int fison=son/__gcd(son,mot);//__gcd NOIP说不能用但没禁大胆的可以try one try
		int fimot=mot/__gcd(son,mot);
		if((x1>x2&&y1<y2)||(x1<x2&&y1>y2))
		{
			printf("-");//上一次函数增减性
		}
		printf("%d/%d*x",abs(fison),abs(fimot));
		fison=0-abs(fison);//把负号挪到分子上方便计算
		fimot=abs(fimot);
		ansu=y1*fimot;
		ansd=fimot;
		fison*=x1;
		ansu-=fison;
		if(ansu==0)return 0;
		elif(ansu%ansd==0)		
			ansu/ansd>0?printf("+%d",ansu/ansd):printf("%d",ansu/ansd);//三目运算符(条件?符合条件执行:不符合条件执行)
       //无负号输出加号，有负号由于前面已经调换负号位置不用再判直接输出，下面同理
		elif(ansu%ansd!=0)
			ansu>0?printf("+%d/%d",ansu,ansd):printf("%d/%d",ansu,ansd);
    }
	return ~~(0-0);
```
##

---

## 作者：EnderXie (赞：0)

一位喜欢STL的蒟蒻的题解…
首先证明一下求k、b的公式：

设y=kx+b，有点p1(x1,y1),p2(x2,y2),则：

**y1=kx1+b  y2=kx2+b**

由2式减1式得：

**y2-y1=k(x2-x1)**

故k=**(y2-y1)/(x2-x1)**,带入1式得

**b=y1-kx1, 即(x2y1-x1y2)/(x2-x1)**

那么话不多说，上代码：

```cpp
#include<bits/stdc++.h>
#define _for(i,a,b) for(int i=a;i<b;i++)
using namespace std;
typedef pair<int,int> pii;
int gcd(int x,int y){
	return (y==0?x:gcd(y,x%y));
}
pii p1,p2,k,b;//first 分子 second 分母
int _k,_b;
void outk(){
	if(k.first==0) return;
	cout<<"y=";
	if(k.first%k.second==0)//若k为整数
    	cout<<k.first/k.second<<"x";
	else{
		cout<<((float)k.first/(float)k.second>0?"":"-")<<abs(k.first)<<"/"<<abs(k.second)<<"*x";
	}
}
void outb(){
	if(b.first==0) return;
	cout<<((float)b.first/(float)b.second>0?"+":"-");
	if(b.first%b.second==0) cout<<b.first/b.second;
	else cout<<abs(b.first)<<"/"<<abs(b.second);
}
int main(){
	cin>>p1.first>>p1.second>>p2.first>>p2.second;
	k.first=p1.second-p2.second;
	k.second=p1.first-p2.first;
	_k=gcd(k.first,k.second);
	k.first/=_k,k.second/=_k;
    //(y2-y1)/(x2-x1),同时除以最大公约数
	b.first=p2.second*p1.first-p1.second*p2.first;
	b.second=p1.first-p2.first;
	_b=gcd(b.first,b.second);
	b.first/=_b,b.second/=_b;
    //(x2y1-x1y2)/(x2-x1)
	outk(),outb();
	return 0;
}
```

STL万岁！~~吸氧会快很多吧~~
如果有其他不正确的地方还请大佬指正~

---

## 作者：Porsche (赞：0)

发布一手比较菜的题解，初学者应该更易懂一些

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int x1,y1,x2,y2;//一个很玄学的问题，将“x1”，“x2”，“x3”，“x4”定义为double类型会出错
	cin>>x1>>y1>>x2>>y2;
	double k,b;
	double m=(double)(y2-y1);//避免“k”，“b”自动转化为int类型
	double n=(double)(x2-x1);
	double o=(double)(x1*y2-x2*y1);
	k=(m)/(n);//解二元一次方程
	b=(o)/(-n);
	int kk,bb;
	kk=(int)k;//提取“k”的整数部分
	bb=(int)b;//提取“b”的整数部分
	int p;
	cout<<"y=";//输出的第一部分
	if(k!=kk)//判断“k”是否为整数
	{
		p=__gcd((y2-y1),(x2-x1));//求取最大公约数，以便化简
		if(k>0)//枚举所有的可能情况
		{
			if(((y2-y1)/p)>0)cout<<(y2-y1)/p<<'/'<<(x2-x1)/p<<"*x";
			else cout<<(y1-y2)/p<<'/'<<(x1-x2)/p<<"*x";
		}
		else if((y2-y1)/p>0)cout<<'-'<<(y2-y1)/p<<'/'<<(x1-x2)/p<<"*x";
		else cout<<(y2-y1)/p<<'/'<<(x2-x1)/p<<"*x";
	}
	else
	{
		if(k!=0)cout<<k<<'x';//“k”是整数的话直接输出
	}//若“k”为零这不做任何输出
	if(b!=bb)//同上↑
	{
		p=__gcd((x1*y2-x2*y1),(x1-x2));
		if(b>0)
		{
			if(((x1*y2-x2*y1)/p)>0)cout<<'+'<<(x1*y2-x2*y1)/p<<'/'<<(x1-x2)/p;
			else cout<<'+'<<(x2*y1-x1*y2)/p<<'/'<<(x2-x1)/p;
		}
		else if((x1*y2-x2*y1)/p>0)cout<<'-'<<(x1*y2-x2*y1)/p<<'/'<<(x2-x1)/p;
		else cout<<(x1*y2-x2*y1)/p<<'/'<<(x1-x2)/p;
	}
	else
	{
		if(b>0&&k!=0)cout<<'+'<<b;
		if(b<0)cout<<b;
	}
	return 0;
}
```

---


# 夏幻的考试

## 题目背景

夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。


## 题目描述

某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。

试卷分卷头，单选题两部分。

夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:

需要处理T张试卷，按顺序检查下列选项。

1.检查考号的填写是否准确。

输入信息的格式:

一行，一个16位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是1~10000。

如果考号有错误，输出一行“Wrong ID”并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)，不含引号。如果考号正确，输出一行,“ID: ”+一个整数，表示考号的十进制形式。不含引号。

无需考虑考号是否重复，只要在范围内均为正确。

2.检查试卷类型是否正确。

输入信息格式:

一行，两个整数，中间无分隔，只能是0或者1。第一个整数表示试卷类型A是否被涂黑(0表示未涂黑，1表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，0表示A卷，1表示B卷，你只需要检查考生填涂的是否正确。

如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行“Type Correct”，否则输出一行“Type Incorrect”，不含引号。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。

3.给单选题打分。

单选题的数量n和标准答案将会在录入第一张试卷前给出。

考生答案的输入格式:

n行，每行4个整数，中间无分隔。每个整数是0或1。

按顺序分别代表A,B,C,D是否被涂黑(0表示未涂黑，1表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。

输出一行，一个四舍五入到小数点后1位的浮点数，表示考生的得分，满分为100分，每个题的分数相同。


## 说明/提示

对于100%的数据

1<=T<=1000

1<=n<=50

注意:

1.请在最后一个试卷处理完后也加上一个换行

2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char


## 样例 #1

### 输入

```
2 5
ABCAD
0000000011111111
01
1000
0010
0100
1000
0010
1001001001001001
01
0001
1010
0111
1111
0000```

### 输出

```
ID: 255
Type Correct
40.0

Wrong ID```

## 样例 #2

### 输入

```
3 3
ABC
0000000000000000
01
1111
0001
0100
0000000000000010
10
1000
0100
0010
0000000000000011
11
0001
0000
0010
```

### 输出

```
Wrong ID

ID: 2
Type Correct
100.0

ID: 3
Type Incorrect
33.3
```

## 样例 #3

### 输入

```
5 31
ACAACCDDBBDADDCBCACCDBCAACAAAAC
0000101111000001
10
1000
0010
1000
1111
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
1111
0010
1000
0010
0010
0001
0100
1111
1000
1000
0010
1000
0100
1000
1000
0010
0000010101001111
10
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
0100
1000
1000
0000
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
0000
0010
0001110001100110
11
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0010
0100
0010
0100
0010
0100
0010
0010
0001
0100
0010
1000
1000
0010
1000
1111
1000
1000
0010
0001001111110001
10
1010
0010
1000
1000
0010
0010
0001
0001
0100
0100
0010
1000
0001
0001
0010
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
1000
1000
0010
0001110010000100
10
1000
0010
1000
1000
0000
0010
0001
0001
0100
0100
0001
1000
0001
0001
0001
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
1000
0001
```

### 输出

```
ID: 3009
Type Incorrect
87.1

ID: 1359
Type Incorrect
87.1

ID: 7270
Type Incorrect
87.1

ID: 5105
Type Incorrect
93.5

ID: 7300
Type Correct
87.1
```

# 题解

## 作者：SLYZ_0120 (赞：43)

开始写题解就停不下来了orz

这是本蒟蒻的第十二篇题解，依旧是蒟蒻的布星的画风qwq.dalao可以自行跳过我啰啰嗦嗦的分析.

---
看到题面~~（标签）~~的第一眼，我就知道，这是一道模拟题，所以本题最最最基础的思路在于，将题目所有描述的操作直接模拟出来。

因为这道题目很明显可以看得出来是分为三个部分的模拟，分别是判断考号，判断卷子，以及最后的计算得分，所以我的想法是**利用函数进行分块的处理**，这样子代码可读性会更强，同时调试起来也会更加的方便。

#### Step1：模拟判断考号
因为所有考号读入时**没有空格**，同时**考号的位数已知为16位**，这里可以利用循环进行读入，在读入的同时在线进行考号2进制与10进制的转换，具体的转换式子是当第i位为1的时候**id+=pow(2,16-i);**

ps：这里需要注意的是不能使用整型读入，每次读入的是一个char字符。每一次在读入这个考号之前需要将id初始化为0！！！（我因为这个连样例都没有过orz）

核心转换代码实现：(c是一个字符)
```cpp
	for(int i = 1;i<=16;i++){
		cin >> c;
		if(c-'0' == 1) id += pow(2,16-i);
	}
```

然后就判断一下id是不是在合法范围之内就ok了

#### Step2：模拟判断试卷
这一步的模拟就是比较轻松愉快了，根据上一步读入的最后一个字符判断是A卷还是B卷，用字符串读入然后直接把两种情况列出来判断就可以了。

核心判断代码实现：（qwq是指读入的填涂字符，g指考号最后一个字符）
```cpp
	if((g == '1'&&qwq == "01")||(g == '0'&&qwq == "10")) printf("Type Correct\n");
	else printf("Type Incorrect\n");
```

#### Step3：模拟批改试卷
这个题目中最为复杂的就是最后一个模拟，有以下几个点值得思考：

- 如何储存标准答案
- 如何判断读入的填涂是否是标准答案
- 如何计算分数

下面一个一个来为大家讲解。

第一个是标准答案的存储。因为标准答案在进行读入时读入的是字符而不是填涂的01串，为了后面判断方便我在读入它们时就将它们**转化为01串存入一个string中**，就像这样：
```cpp
	if(w[i] == 'A') s[i+1] = A;
	else if(w[i] == 'B') s[i+1] = B;
	else if(w[i] == 'C') s[i+1] = C;
	else s[i+1] = D;
```
当然ABCD四个是提前转化好的四个string

接下来是对读入的判断以及分数计算，同样是直接利用string读入，然后判断它和对应题目标准答案的字符串是否相等，如果不相等直接减去本题的分值，就像这样：
```cpp
	for(int i = 1;i<=n;i++){
		cin >> qwq;
		if(qwq != s[i]) markk -= point;
	}
```

最后直接输出分值就可以了

---
以上就是对于本题算法思路的一个讲解。
### BUT
本题最最最大的坑点不是算法，而是windows和linux的一些符号（比如换行符，scanf读入格式之类）的不兼容，我在本地成功的过了炒鸡多的样例，下载的数据也完美的通过，但是依旧不停的WA~~（爆0）~~

有记录截图为证：
![orz](https://cdn.luogu.com.cn/upload/pic/32295.png)
最后我把**所有的cout << endl全部都换成了\n，同时将所有的scanf全部都换成了cin，去掉了所有的gets**，我终于成功了……

下面贴上代码，上面有代码讲解不够详细的请参考代码注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char w[55];//标准答案字符存储
string s[55];//标准答案转换后字符串存储
string A = "1000";
string B = "0100";
string C = "0010";
string D = "0001";//四个提前转换好的填涂字符串
bool flg = true;//flg是一个标记，用来指明这个人是否需要继续处理下面的试卷
char c;
int id;
string qwq;
double markk,point;//分数，以及每一题的分值
void typ(){
	id = 0;//初始化id！这个超重要的
	for(int i = 1;i<=16;i++){
		cin >> c;
		if(c-'0' == 1) id += pow(2,16-i);
	}
	if(id >= 1&&id<=10000) printf("ID: %d\n",id);
	else {
		printf("Wrong ID\n");
		flg = false;//如果这个考号不合法，标记一下
	}
	return;
}
void check(char g){
	cin >> qwq;
	if(flg == false) return;
	else {
		if((g == '1'&&qwq == "01")||(g == '0'&&qwq == "10")) printf("Type Correct\n");
		else printf("Type Incorrect\n");
	}
	return;
}
void pas(){
	markk = 100.00;//初始化每一个人的分数
	for(int i = 1;i<=n;i++){
		cin >> qwq;
		if(qwq != s[i]) markk -= point;
	}
	if(flg == false)return;
	printf("%.1lf\n",markk);//输出格式要注意啊
}
int main(){
	std::ios::sync_with_stdio(false);//让cin和scanf一样快的神器~
	cin >> t >> n;
	cin >> w;
	for(int i = 0;i<n;i++){
		if(w[i] == 'A') s[i+1] = A;
		else if(w[i] == 'B') s[i+1] = B;
		else if(w[i] == 'C') s[i+1] = C;
		else s[i+1] = D;
	}
	point = 100.00/n;//求每题分值 
	for(int i = 1;i<=t;i++){
		flg = true;//初始化这张试卷的状态
		typ();//判断考号合法性
		check(c);//因为c是全局变量所以可以直接传
		pas();//考试成绩
		printf("\n");//千万不能忘了这里有一个换行！
	}
	return 0;
}
```
---
一道~~简单~~有趣的模拟题就这样完美AC了！当然这道题的模拟思路确实非常清晰明了是一道完美的练习题~

希望这篇题解对大家能有所帮助。

而且既然都看到这里了，点个赞再走行不(≖‿≖)✧

---

## 作者：Eason_AC2 (赞：13)

本蒟蒻甚至怀疑自己连个普及-的题目都做不出来了。。。~~然而还是做出来了~~

---

一道坑点多多的大模拟题目。

首先就是这道题目特有的`cout<<endl`的问题，不过本人亲测发现好像这道题目与\n在Windows和Linux的兼容性没有太大的关系，用\n也能过得去本题。

然后开始盘点这道题目所有的过程。

$Step~1$：输入

输入$T,n$倒是没有问题的。

关键是之后输入正确答案以及考号，考卷类型和每题的填涂答案的情况。首先是输入正确答案，用一个字符数组保存，然后用`scanf("%s", ...)`读入就可以了（不过要注意下标！这个在AC代码里会有呈现）。

然后考号，直接定义一个大小为17的数组，然后用`scanf("%1d", ...)`读入。

接着是考卷类型，也用同样方法输入。

最后是答案填涂，同样方法输入不啰嗦。

$Step~2$：处理数据

我们发现考号的范围在十进制下的1到10000。然而在这里输入的是二进制。怎么办呢？我们用电脑自带的计算器查一下，发现10000在二进制下是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/ti51lc6y.png)

我们发现它只有14位数。

所以，我们可以想到这样一个特判：只要在16位二进制的第1、2位中有数，这个考号就是不合法的。

那么一般情况怎么弄呢？

很简单，直接通过位运算得到其十进制即可。

比如说$(1000010000)_2=1*2^9+1*2^4=528$。

所以考号就这么处理完了。接下来判断就无需再讲了，一波if-else搞定。

然后是考卷类型。因为在题目中，0表示A卷，1表示B卷。所以，只要比对一下是否填涂且仅填涂了正确的考卷类型就行了。具体就是：如果根据考好得出是$A$卷，且试卷类型栏只填涂了$A$卷这个类型，就是$Type~Correct$，或者得出是$B$卷，且试卷类型栏只填涂了$B$卷这个类型，也是$Type~Correct$。否则全部都是$Type~Incorrect$。

最后是考试答案。我们用一种类似于康托展开的方式，将每个填涂数据转化为一种状态，比如我们发现$1000$对应的是$A$这个答案，所以将这个填涂情况转换成$1000$这个数。

$Step~3$：解决问题

首先考号，按照上面的处理方法判断。

然后考卷类型也是如此。

最后是考试答案。注意，在本人的代码中，正解答案的题目下标是$0,1,2,...,n-1$，然而考生答案的题目下标是$1,2,3,...n$。所以需要注意一一比对。还有，因为本题中，默认满分是$100$分，所以每题积分直接取平均值，最好用$double$存储（精度高些）。

其他就没啥好讲了。总的来说，这个题目真心是个纯模拟题目，不过很多细节。祝大家刷题愉快！

最后来贴上正解代码~

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <cmath>
using namespace std;

inline int read() {
	int f = 1, x = 0;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')	f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int T, n;
double per;
char correct[57];
struct node {
	int id[17], A, B, ans[57][5], note[57];
}a[1007];

int main() {
	T = read(), n = read();
	per = 100.0 / (n * 1.0);
	scanf("%s\n", correct);
// 	printf("%.1lf\n", per);
	for(int i = 1; i <= T; ++i) {
		int flag = 0, sum = 0;
		for(int j = 1; j <= 16; ++j) {
			scanf("%1d", &a[i].id[j]);
			if((j == 1 || j == 2) && a[i].id[j])	flag = 1;
			else {
//				printf("%d ", 16 - j);
				sum += a[i].id[j] * (int)pow(2, 16 - j);
//				printf("%d\n", sum);
			}
		}
		if(sum < 1 || sum > 10000)	flag = 1;
		scanf("%1d%1d", &a[i].A, &a[i].B);
		for(int j = 1; j <= n; ++j)
			for(int k = 1; k <= 4; ++k) {
				scanf("%1d", &a[i].ans[j][k]);
				a[i].note[j] = a[i].note[j] * 10 + a[i].ans[j][k];
			}
		if(flag) {
			puts("Wrong ID\n");
			continue;
		}
		printf("ID: %d\n", sum);
		if((!a[i].id[16] && a[i].A && !a[i].B) || (a[i].id[16] && !a[i].A && a[i].B))
			puts("Type Correct");
		else
			puts("Type Incorrect");	
		flag = 0; double num = 0.0;
		for(int j = 1; j <= n; ++j) {
			flag = 0;
//			printf("%d %c\n", a[i].note[j], correct[j - 1]);
			if(a[i].note[j] == 1000 && correct[j - 1] == 'A')		num++;
			else if(a[i].note[j] == 100 && correct[j - 1] == 'B')	num++;
			else if(a[i].note[j] == 10 && correct[j - 1] == 'C')	num++;
			else if(a[i].note[j] == 1 && correct[j - 1] == 'D')		num++; 
		}
		num *= per;
		printf("%.1lf\n\n", num);
	}
	return 0;
}
```

你看得这么认真，不先点个赞再走嘛？

---

## 作者：引领天下 (赞：12)

其实这题很简单啊，代码也没有必要写那么长

就是按题目说的模拟

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans[55];//ans[i]为第i题的正确序号（0，1，2，3）
string s;
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>s;
    for (int i=0;i<m;i++)ans[i]=s[i]-'A';//读入标准答案
    while (n--){
        double cnt=0;
        int kh=0;
        cin>>s;
        for (int i=15;i>=0;i--)kh+=(s[i]-'0')*pow(2,15-i);//算考号
        bool khzq=kh>=1&&kh<=10000;//检查是否合法
        if (!khzq){
            for (int i=0;i<=m;i++)cin>>s;
            printf ("Wrong ID\n\n");continue;//不合法
        }
        cin>>s;
        if (s[0]==s[1])s[kh&1]='0';//如果两个都填了或者两个都没填，让它变成错误
        //不难发现考号%2就是最后一位，因为2的方冥都是偶的
        printf ("ID: %d\nType %s\n",kh,s[kh&1]-'0'?"Correct":"Incorrect");//输出ID和是否正确
        for (int i=0;i<m;i++){
            cin>>s;
            bool ok=0,f=0;
            for (int j=0;j<4;j++)if (s[j]-'0'&&ok)f=1;//如果填了两个
            else if (s[j]-'0')ok=1;//如果填了
            if (ok&&!f&&s[ans[i]]-'0')cnt+=100.0/m;//只填了一个且填的是对的
        }
        printf ("%.1f\n\n",cnt);//输出
    }
    return 0;
}

```

---

## 作者：_0x46EDC (赞：6)

[获得更好的阅读体验](https://www.luogu.com.cn/blog/jasonying/luogu-p3692-xia-huan-di-kao-shi) [题目传送门](https://www.luogu.com.cn/problem/P3692)

---
### 题目分析
这是一道很简单的模拟 ~~，但是我弄了一中午交了十几次才AC~~，难点~~不~~是题目复杂~~而是不要晕过去~~，直接暴力。

### 知识点
1. 二进制转十进制

没什么好讲的，就是模拟小奥中二进制转十进制。
```cpp
    getline(cin,s);
    for(int i=0;i<s.size();i++){
        if(s[i]=='1')num+=pow(2,16-i);
    }
```
2. 输出 ans 并保留小数点后x位

方法一：```cout<<fixed<<setprecision(x)<<ans<<endl;```

方法二：```printf("%.xf",ans);```
### 代码
### Step1 检查考号的填写是否准确
这一步主要的操作就是将二进制转换为十进制，在前面已经有所介绍，代码中有些语句的思路比较神奇，我会在注释中进行解释。
```cpp
bool ID(){
    for(int i=1;i<=16;i++){//二进制转十进制
        cin>>c;
        if(c=='1')id+=pow(2,16-i);
    }
	if(id>=1&&id<=10000){//如果在范围之内
		cout<<"ID: "<<id<<endl;//输出
		return true;//考号正确，返回
	}
	cout<<"Wrong ID"<<endl<<endl;//输出
	for(int i=1;i<=2+4*n;i++)cin>>cc;//读入剩余的2+4*n个字符
	return false;//考号错误，返回
}
```
### Step2 检查试卷类型是否正确
这一步主要是判断考号最后一位与考生的填涂是否匹配，对应表如下：

| 考号最后一位 | 考生填涂 | 试卷类型 |
| :-: | :-: | :-: |
| 0 | 10 | A
| 1 | 01 | B
上程序：
```cpp
void type(){
    cin>>cc>>ccc;//输入两位字符
    if(c=='1'&&cc!='1'&&ccc=='1'||c=='0'&&cc!='0'&&ccc=='0')cout<<"Type Correct"<<endl;//类型正确，输出
    else cout<<"Type Incorrect"<<endl;//类型错误，输出
    return;//返回
}
```
### Step3 给单选题打分
这一步就是统计正确的题目数量并计算分数，正确选项与考生填涂对应表如下：

| 选项 | 正确填涂 | 对应的整数 |
| :-: | :-: | :-: |
| A | 1000 | 1000
| B | 0100 | 100
| C | 0010 | 10
| D | 0001 | 1
```cpp
void answer(){
    for(int i=0,m;i<n;i++){//循环判断正确
        cin>>m;//以整数类型输入考生答案
        if(m==1&&ans[i]=='D'||m==10&&ans[i]=='C'||m==100&&ans[i]=='B'||m==1000&&ans[i]=='A')crct++;//判断，正确题目数量加一
    }
    cout<<fixed<<setprecision(1)<<100.0*crct/n<<endl;//输出答案，注意一定要用100.0，不然会输出整数
    return;//返回
}
```
### 主程序
以上就是三个步骤，我对其进行了模块化处理，这样主程序调用会比较方便，主程序如下：
```cpp
int main(){
    cin>>T>>n;//输入
    for(int i=0;i<n;i++)cin>>ans[i];//输入正确答案
    for(int i=0;i<T;i++){
    	crct=0;//清空正确题目数量
        id=0;//清空十进制考号
        if(!ID())continue;//如果考号错误，不需要进一步处理
        type();//试卷类型
        answer();//检查答案
        cout<<endl;//换行别忘了
    }
    return 0;
}
```
### 完整程序（无注释）
```cpp
#include<bits/stdc++.h>
#define N 59
using namespace std;
int T,n,id,crct;
char c,cc,ccc,ans[N];
bool ID(){
    for(int i=1;i<=16;i++){
	cin>>c;
	if(c=='1')id+=pow(2,16-i);
    }
    if(id>=1&&id<=10000){
	cout<<"ID: "<<id<<endl;
	return true;
    }
    cout<<"Wrong ID"<<endl<<endl;
    for(int i=1;i<=2+4*n;i++)cin>>cc;
    return false;
}
void type(){
    cin>>cc>>ccc;
    if(c=='1'&&cc!='1'&&ccc=='1'||c=='0'&&cc!='0'&&ccc=='0')cout<<"Type Correct"<<endl;
    else cout<<"Type Incorrect"<<endl;
    return;
}
void answer(){
    for(int i=0,m;i<n;i++){
        cin>>m;
        if(m==1&&ans[i]=='D'||m==10&&ans[i]=='C'||m==100&&ans[i]=='B'||m==1000&&ans[i]=='A')crct++;
    }
    cout<<fixed<<setprecision(1)<<100.0*crct/n<<endl;
    return;
}
int main(){
    cin>>T>>n;
    for(int i=0;i<n;i++)cin>>ans[i];
    for(int i=0;i<T;i++){
        crct=0;
        id=0;
        if(!ID())continue;
        type();
        answer();
        cout<<endl;
    }
    return 0;
}
```
### 结语
不难，但是要注意**细节**

以上是本蒟蒻的第三篇题解，前两篇都因为题解太多交不上去，既然dalao们看到这了，给个赞吧qwq

-----
### update
- 2020.4.11 修复了部分代码的缩进问题

- 2020.4.11 修复了文末多出一条分割线的问题

- 2020.4.11 在文首增加了一条分割线

---

## 作者：RiverFun (赞：5)

这道题就是一道模拟，但是，实在是太麻烦！

首先上头文件和其他一些东西：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
```
定义函数chk_number(),用于判断考号是否合法。
```cpp
bool chk_number(string a){
	int total=0;
	int k=15;
	for(int i=0;i<=15;i++) {
		if(a[i]=='1') total+=pow(2,k);
		k--;
	}
	if(total>=1&&total<=10000) return 1;
	else return 0;
}
```
定义函数sum_number(),用于计算考号是多少。
```cpp
int sum_number(string a){
	int total=0;
	int k=0;
	for(int i=15;i>=0;i--) {
		if(a[i]=='1') total+=pow(2,k);
		k++;
	}
	return total;
}
```
定义函数chk_paper()，用于判断试卷类型填涂与考号是否对应。
```cpp
bool chk_paper(string a,string b){
	if(b=="11") return 0;
	if(b=="00") return 0;
	if(a[15]=='1'){
		if(b=="01") return 1;
		if(b=="10") return 0;
	}
	if(a[15]=='0'){
		if(b=="01") return 0;
		if(b=="10") return 1;
	}
}
```
定义函数check()，用于判断答案是否正确。
```cpp
bool check(char a,string b){
	if(a=='A'){
		if(b=="1000") return 1;
		else return 0;
	}
	if(a=='B'){
		if(b=="0100") return 1;
		else return 0;
	}
	if(a=='C'){
		if(b=="0010") return 1;
		else return 0;
	}
	if(a=='D'){
		if(b=="0001") return 1;
		else return 0;
	}
}
```
定义结构体note，用来储存学生信息。
```cpp
struct note{
	string uid;
	string kind;
	string hd[51];
	int zf;
};
```
核心代码部分：
```cpp
int main(){
	int T,n;
	note student[1001];
	char ans[51];
	scanf("%d%d",&T,&n);
	for(int i=1;i<=n;i++)
	cin>>ans[i];
	for(int i=1;i<=T;i++){
		cin>>student[i].uid;
		cin>>student[i].kind;
		student[i].zf=0;
		for(int j=1;j<=n;j++){
			cin>>student[i].hd[j];
			if(check(ans[j],student[i].hd[j]))//计算正确的题的个数
			student[i].zf++;
		}
	}
	for(int i=1;i<=T;i++){
		if(chk_number(student[i].uid)){//判断是否考号合法，如果合法，则输出
			printf("ID: %d",sum_number(student[i].uid));
			cout<<endl;
		}
		else{//如果不合法，直接跳过下面部分
			printf("Wrong ID");
			cout<<endl;
			goto exit; 
		}
		if(chk_paper(student[i].uid,student[i].kind)){//判断试卷类型填涂与考号是否对应。
			printf("Type Correct");
			cout<<endl;
		}
		else{
			printf("Type Incorrect");
			cout<<endl;
		}
		printf("%.1f",student[i].zf*100/float(n));//计算分数
		cout<<endl;
		exit:
		cout<<endl;
	}
	return 0;//结束
}
```

---

## 作者：HDawn (赞：1)

这道题并不难，主要是由耐心吧

按照题目要求一点一点的做很容易的。

废话不多说，上代码。

# 代码 有详解
```
#include<bits/stdc++.h>//万能头，都懂得。
using namespace std;
int T,n,dn[100],sum=0,abc;//dn[]里面存正确答案 sum为正确的数量 abc为同学选的答案
double ans=0;//分数
int ID(){//进行ID的进制转换，顺带判断试卷类型是否正确。
	string s;//用字符串存二进制ID。
   int id=0,a;//id为十进制id,a为试题类型。
	cin >> s;
	for (int i = 0; i < s.size(); i++) //将二进制转换为十进制。
		id += (s[i]-'0') * pow(2, s.size() - i - 1);
	if(id>10000||id<1){//判断ID是否正确。
		cout<<"Wrong ID\n\n";//两个换行。
		for(int i=0;i<n+1;i++)
			cin>>a;//ID错误,把下面的输进来，为了不影响下一个同学的答案。
		return 0;//返回0，结束这次ID判断。
	}
	cout << "ID: " << id << endl;//ID正确就输出，:后面有一个空格，注意。
	cin>>a;//输入试题类型。
	if(a==0||a==11||id%2!=a%2){//试题类型a不能为00或者11，a个位和ID个位相同（同为0或1）才正确。就是说a和十进制id同为奇数或同为偶数才正确。
		cout<<"Type Incorrect\n";//错误输出这个。
	}else	cout<<"Type Correct\n";//正确输出这个。
	return 1;//ID正确返回1。
}
int main()
{
	cin>>T>>n;//T是同学的试卷答案个数，n是试卷题目个数。
	char c;//暂时存储正确答案。
	for(int i=0;i<n;i++){
		cin>>c;
		if(c=='A') dn[i]=1000;//答案是A就是1000。
		else if(c=='B') dn[i]=100;//答案B是0100。
		else if(c=='C') dn[i]=10; //答案C是0010。
		else if(c=='D') dn[i]=1;  //答案D是0001。		
	}
	while(T--){
		if(!ID())//返回0就结束本次循环进行下一次循环。
			continue;
		sum=0;ans=0;//重新赋值为0。
		for(int i=0;i<n;i++){
			cin>>abc;//以整数形式输入，数字自动去掉开头的零。
			if(abc==dn[i])//判断相等，sum自增1。
				sum++;
		}
		ans=(double)sum/n*100;//根据答对题数和总题数算出得分。
		printf("%0.1f\n\n",ans);//输出分数，两个换行。
	}
	return 0;
 } 
```
## 结束。

---

## 作者：HoshinoTented (赞：1)

星野用了~~花里胡哨的~~**面向对象**的方法来完成了这道题  
首先是考生信息  
```C++
class Id {
public:
	enum TestType {
		A, B, WRONG
	};

	explicit Id(const std::string &id) {
		std::stringstream stream(id);
		const char *charArr = id.c_str();
		self.id = static_cast<int>(std::strtol(charArr, (char **) (charArr + id.size()), 2));
		self.testType = *(--id.cend()) - '0' ? B : A;
	}

	explicit Id(const int &id, const TestType &type) : id(id), testType(type) {}

	inline auto getId() -> int { return id; }

	inline auto getType() -> TestType { return testType; };

private:
	int id;
	TestType testType;

};
```
~~这什么高亮。。。~~  

反正就是一堆花里胡哨的东西...  
接下来是单选答案
```C++
class SingleAnswer {
private:
	enum Answer {
		A, B, C, D, WRONG
	};
	Answer ans;

public:
	explicit SingleAnswer() : ans(WRONG) {}

	explicit SingleAnswer(const char &ans) {
		switch (ans) {
			case 'A':
				self.ans = A;
				break;
			case 'B':
				self.ans = B;
				break;
			case 'C':
				self.ans = C;
				break;
			case 'D':
				self.ans = D;
				break;
			default:
				self.ans = WRONG;
		}
	}

	explicit SingleAnswer(const std::string &str) {
		if (str.size() != 4) throw "Error";
		if (str == "1000") ans = A;
		else if (str == "0100") ans = B;
		else if (str == "0010") ans = C;
		else if (str == "0001") ans = D;
		else ans = WRONG;
	}

	auto operator==(const SingleAnswer &ans) -> bool const {
		return self.ans == ans.ans;
	}
};
```
这里就不怎么花里胡哨了  
最后是几个读取的函数  
```C++
//读取 考生信息
auto readId() -> const Id {
	std::string id;
	std::cin >> id;
	return Id(id);
}

//读取 考卷类型
auto readType() -> const Id::TestType {
	int type;
	std::cin >> type;

	if (type == 10) return Id::A;
	else if (type == 1) return Id::B;
	else return Id::WRONG;
}

//读取 正确答案
auto readAnswers() -> const std::vector<SingleAnswer> {
	std::string answers;
	std::cin >> answers;
	std::vector<SingleAnswer> ans;
	for (auto c : answers) {
		ans.emplace_back(c);
	}

	return ans;
}

//读取 考生答案
auto readInputAnswer(const int &answerCount) -> const std::vector<SingleAnswer> {
	std::vector<SingleAnswer> answers;
	for (int i = 0; i < answerCount; ++i) {
		std::string ans;
		std::cin >> ans;

		answers.emplace_back(ans);
	}

	return answers;
}
```
最后就是 `main` 函数  
```C++
auto main(int argc, char *argv[]) -> int {
	int ansCount, ansLength;
	std::cin >> ansCount >> ansLength;		//先读取 试卷数量 和 答案个数

	auto ans = readAnswers();		//读取正确答案

	for (int i = 0; i < ansCount; ++i) {
		auto id = readId();		//获取考生信息
		auto type = readType(); //获取考卷类型
		auto inputAnswers = readInputAnswer(ansLength); //获取考生答案
        //本来获取考生答案星野是选择放到下面去的, 结果发现, 即使id错误也还是要继续读取答案

		if (id.getId() == 0 || id.getId() > 10000) {	//判断id区间
			std::cout << "Wrong ID" << std::endl << std::endl;
			continue;
		} else std::cout << "ID: " << id.getId() << std::endl;
		std::cout	//判断考卷类型
				<< "Type "
				<< (id.getType() == type ? "Correct" : "Incorrect")
				<< std::endl;

		int correctCount = 0;	//正确数
		auto ansIt = ans.cbegin();	//参考答案的迭代器

		for (auto inputAnswer : inputAnswers) {
			correctCount += inputAnswer == *ansIt++;
		}

		//输出
		printf("%.1f\n\n", 100.0 / ansLength * correctCount);
	}

	return 0;
}
```
选择~~花里胡哨的~~**面向对象**实现主要还是为了维护和扩展性  
也不知道刷个水题要啥维护和扩展...

---

## 作者：Night_Aurora (赞：1)

单纯的模拟，没有什么可说的

用结构体(类)来保存数据可保证代码的有序性和简洁性

这里用了一个很慢的函数ReadChar来读取单个字符




```cpp
#include <stdio.h>
#include <string.h>
#define WE    "Wrong ID\n"
#define TE    "Type Incorrect\n"
#define TA    "Type Correct\n"
#define IA    "ID: %d\n"
char ReadChar()
{
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    return c;
}
```
class Paper
```cpp
{
    int ID;
    int Tp;
    char Asw[60];
    void ReadID();
    void ReadType();
    char ReadSolo();
    void ReadAnsw();
    int IsID();
    int IsType();
    int GetRight(char*);
```
public:













```cpp
    void Judge();
};
int N,T;
char True[60];
void Paper::ReadID()
{
    ID=0;
    int wi,ad=1<<15;
    char c;
    for(wi=1;wi<=16;++wi)
    {    
        ID+=(ReadChar()-'0')*ad;
        ad/=2;
    }
}
void Paper::ReadType()
{
    char ya,yb;
    ya=ReadChar();
    yb=ReadChar();
    if(ya=='1')
        if(yb=='1')
            Tp=2;
        else Tp=0;
    else if(yb=='1')
        Tp=1;
        else Tp=2;            
}
char Paper::ReadSolo()
{
    int rn=0;
    int rd[5];
    int wi;
    for(wi=1;wi<=4;++wi)
    {    
        rd[wi]=ReadChar()-'0';
        rn+=rd[wi];
    }
    if(rn!=1)return 'Z';
    if(rd[1])return 'A';
    if(rd[2])return 'B';
    if(rd[3])return 'C';
    if(rd[4])return 'D';
    return 'Z';
}
void Paper::ReadAnsw()
{
    int wi;
    for(wi=0;wi<N;++wi)
        Asw[wi]=ReadSolo();
}
int Paper::IsID()
{
    return ID>=1&&ID<=10000;
}
int Paper::IsType()
{
    return (ID%2)==Tp;
}
int Paper::GetRight(char*Rit)
{
    int rt=0,wi;
    for(wi=0;wi<N;++wi)
        if(Rit[wi]==Asw[wi])
            ++rt;
    return rt;
}
int ft;
void Paper::Judge()
{
    if(ft)putchar(10);
    ++ft;
    ReadID();
    ReadType();
    ReadAnsw();
    if(!IsID())
    {
        printf(WE);
        return;
    }
    printf(IA,ID);
    if(!IsType())
        printf(TE);
    else
        printf(TA);
    int yn=GetRight(True);
    printf("%.1lf\n",100.0*yn/N);
}
Paper Man[11000];
void Input()
{
    scanf("%d %d",&T,&N);
    scanf("%s",True);
}
void AC()
{
    int wi;
    for(wi=1;wi<=T;++wi)
        Man[wi].Judge();
}
int main()
{
    Input();
    AC();
    return 0;
}

```

---

## 作者：反比例函数 (赞：0)

一道并不太难的模拟，考察面广，思路不难，代码量稍高，代码难度一般。

讲解在代码的注释中。

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
using namespace std;
const int pow2x[16]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};
//将2的n次幂用一个const表示出来，避免每次调用pow函数费时
//观察样例可发现这个二进制数最多16位，因此我们打表打到2^15=32768即可
string r[51];
int bin_to_dec(string b)//二进制转十进制
{   int len=b.size(),d=0;
    for(int i=len-1;i>=0;i--)
      d+=(b[i]-'0')*pow2x[len-i-1];//b[i]-'0'为这一位上的数字
    return d;}
int main()
{
    int t,n,i;
    string ans,num,type;
    double sc=0.0;
    cin>>t>>n>>ans;//ans为正确答案
    const double basic_sc=100.0/n;//答对一道题所加的分数
    while(t--)//t组数据
    {   cin>>num>>type;
        int id=bin_to_dec(num);//将考试号转换为10进制
        for(i=1;i<=n;i++) cin>>r[i];//考生的作答
        if(id>10000||id<1) //如果考号不对
        {   cout<<"Wrong ID"<<endl<<endl;continue;}//直接输出走掉
        //注意这里要有两个换行！！！本人在这里被坑了好久
        cout<<"ID: "<<id<<endl;//输出考号
        int len=num.size();
        if(num[len-1]=='0')//试卷类型的处理
        {   if(type=="10") cout<<"Type Correct"<<endl;
            else cout<<"Type Incorrect"<<endl;}
        else if(num[len-1]=='1')
        {   if(type=="01") cout<<"Type Correct"<<endl;
            else cout<<"Type Incorrect"<<endl;}
        for(i=1;i<=n;i++)//比对答案
        {   if(ans[i-1]=='A')
            {   if(r[i]=="1000") sc+=basic_sc;}
            else if(ans[i-1]=='B')
            {   if(r[i]=="0100") sc+=basic_sc;}
            else if(ans[i-1]=='C')
            {   if(r[i]=="0010") sc+=basic_sc;}
            else if(ans[i-1]=='D')
            {   if(r[i]=="0001") sc+=basic_sc;}}
        printf("%.1lf\n\n",sc);//保留一位小数输出，同样要带两个换行
        sc=0.0;}//清空累加的成绩，处理下一位考生
}
```

---

## 作者：户山香澄 (赞：0)

一道纯纯的模拟。

思路不难，主要看代码实现。

···



```cpp
var c:char;
    s:string;
    a,score:real;
    ans:array[1..50] of longint;
    i,j,t1,t2,t,n,l:longint;
    sum:int64;
    k:qword;
procedure justread(x:longint);//ID有问题，直接读入
var i:longint;
    p:ansistring;
begin
  for i:=1 to x do readln(p);
end;
function id(s:int64):int64;//2进制转10进制
var i,k:longint;
    l:int64;
begin
  k:=1;
  l:=s;id:=0;
  for i:=1 to 16 do
    begin
      id:=id+(l mod 10)*k;
      l:=l div 10;
      k:=k shl 1;
    end;
end;
begin
  readln(t,n);
  for i:=1 to n do
    begin
      read(c);
      case c of
        'A':ans[i]:=1000;//直接使用，更加方便
        'B':ans[i]:=0100;
        'C':ans[i]:=0010;
        'D':ans[i]:=0001;
      end;
    end;
  a:=100/n;
  for i:=1 to t do
    begin
      readln(sum);
      if sum mod 10=1 then t1:=01 //试卷类型
      else t1:=10;
      sum:=id(sum);
      if not ((sum>=1) and (sum<=10000)) then //判断ID
        begin
          justread(n+1);
          writeln('Wrong ID');
          writeln;
          continue;
        end;
      writeln('ID: ',sum);
      readln(t2); //试卷类型
      if t2=t1 then writeln('Type Correct')
      else writeln('Type Incorrect');
      score:=0;
      for j:=1 to n do //算分
        begin
          readln(t2);
          if t2=ans[j] then score:=score+a;
        end;
      writeln(score:0:1);
      writeln;
    end;
end.
···
```

---

## 作者：loi_hjh (赞：0)

~~这题前两次提交纯属沙雕，第一次too short on line 31，原来是Wrong ID多输出一个换行，第二次emmm...freopen忘注释了。。。~~

# 附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
int n,m,id,score;//score在这里当做对了几道题 
char akking[10100],blxs[10100];//std和爆零选手（我去，std是关键字，用ak王代替吧） 
bool flag;
in int slowpower(int x,int y){
	int p=1;
	if(!x) return 0;
	for(ri i=1;i<=y-1;i++)
		p*=2;
	return p;
}
int main(){
	scanf("%d%d",&n,&m);
	scanf("%s",akking+1);
	for(ri i=1;i<=n;i++){
		id=score=0;//这个人的id和score清空 
		flag=false;//Wrong ID没有成绩 
		scanf("%s",blxs+1);
		for(ri j=1;j<=16;j++)
			blxs[j]-='0';
		for(ri j=1;j<=16;j++)//快速幂来计算二进制 
			id+=slowpower(blxs[j],16-j+1);//快速幂写呲了（划掉），后来发现用pow也呲，（划掉），后来可以发现可以用blxs[i]*(pow(16-i+1,2)) 
		if((id>=1)&&(id<=10000)&&(!flag)) printf("ID: %d\n",id);
		else{
			printf("Wrong ID\n");
			flag=true;//本来用的continue发现还要读入emmm 
		}
		scanf("%s",blxs+1);//重新利用爆零选手来存考试类型
		for(ri j=1;j<=2;j++)
			blxs[j]-='0';
		if(!flag){
			if(!blxs[16]){//最后一位还没有覆盖（最后一位是0） 
				if((blxs[1])&&(!blxs[2])) printf("Type Correct\n");//10即为填涂正确 
				else printf("Type Incorrect\n");//错误 
			} 
			if(blxs[16]){//同理（最后一位是1） 
				if((!blxs[1])&&(blxs[2])) printf("Type Correct\n");//01即为填涂正确 
				else printf("Type Incorrect\n");//错误 
			}
		} 
		for(ri j=1;j<=m;j++){//akking个数即为题目个数
			scanf("%s",blxs+1);//再次重新利用爆零选手来存选项
			if(flag) continue; 
			for(ri k=1;k<=4;k++)
				blxs[k]-='0';
			if(akking[j]=='A') if((blxs[1])&&(!blxs[2])&&(!blxs[3])&&(!blxs[4])) score++;//有且只有A（1000） 
			if(akking[j]=='B') if((!blxs[1])&&(blxs[2])&&(!blxs[3])&&(!blxs[4])) score++;//有且只有B（0100）
			if(akking[j]=='C') if((!blxs[1])&&(!blxs[2])&&(blxs[3])&&(!blxs[4])) score++;//有且只有C（0010）
			if(akking[j]=='D') if((!blxs[1])&&(!blxs[2])&&(!blxs[3])&&(blxs[4])) score++;//有且只有D（0001）
		} 
		if(!flag) printf("%.1lf\n\n",100.0*score/m);//两个换行 
		else putchar('\n');
	}
	return ~~(0-0);
}


```

---


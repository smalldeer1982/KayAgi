# 「EZEC-3」造房子

## 题目背景

pigstd 要去造房子了。

## 题目描述

pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。

## 说明/提示

**【样例 1 说明】**

pigstd 买 $2$ 个 A 材料和 $1$ 个 B 材料后就有 $3$ 个 A 材料和 $3$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【样例 2 说明】**

pigstd 买 $3$ 个 A 材料后就有 $4$ 个 A 材料和 $5$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【数据规模与约定】**

对于 $100\%$ 的数据，$0 \le a,b,c \le 10^{12}$。

| 数据点编号 | 满足的条件 |
| :----------: | :----------: |
|$1-4,22$| $c = 0$ |
|$5-8,21$| $a,b,c \le 10^{3}$ |
|$9-12$| $a,b,c \le 10^{6}$ |
|$13-20$| $a,b,c \le 10^{12}$ | 

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 3```

### 输出

```
2```

# 题解

## 作者：云浅知处 (赞：47)

这里来讲一下 $O(1)$ 的做法。

首先题目上说：造**第** $i$ 层楼需要 $i$ 个 A 材料和 B 材料。

所以说，造前 $n$ 层就需要 $\dfrac{n(n+1)}{2}$ 个 A 材料和 B 材料。

先不管我们那 $c$ 元钱，我们先看只有 $a,b$ 时的情况。

题意此时就是让我们求出最大的 $n$，满足 $\dfrac{n(n+1)}{2}\le a,\dfrac{n(n+1)}{2}\le b$。

------------

简洁点说，就是解不等式嘛！

这种不等式早就被套路艹烂了，不过这里还是带大家来解一下吧qwq。

$$
\begin{aligned}
&\dfrac{n(n+1)}{2}&\le &\ a\\
\iff&n(n+1)&\le&\ 2a\\
\iff&n^2+n-2a&\le&\ 0\\
\end{aligned}
$$

可以发现此时就只剩一个一元二次不等式了。

那么，直接上求根公式，强行因式分解就完事了。

$$
\begin{aligned}
&\left(n-\dfrac{-1+\sqrt{8a+1}}{2}\right)\left(n-\dfrac{-1-\sqrt{8a+1}}{2}\right)&\le&\ 0\\
\end{aligned}
$$

其实这时你已经可以搞那个什么所谓的「穿针」大法，画个数轴，直接搞出 $n$ 的取值范围了。

不过这里其实没必要用那个方法~~其实是我懒得在电脑上画数轴再上传过来了~~。

因为

$$
\begin{aligned}
&\left(n-\dfrac{-1+\sqrt{8a+1}}{2}\right)\left(n-\dfrac{-1-\sqrt{8a+1}}{2}\right)&\le&\ 0\\
\end{aligned}
$$

所以 $\left(n-\dfrac{-1+\sqrt{8a+1}}{2}\right)$ 与 $\left(n-\dfrac{-1-\sqrt{8a+1}}{2}\right)$ 一定是一正一负。

而显然有

$$
\left(n-\dfrac{-1+\sqrt{8a+1}}{2}\right)<\left(n-\dfrac{-1-\sqrt{8a+1}}{2}\right)
$$

所以必为

$$
n-\dfrac{-1+\sqrt{8a+1}}{2}\le0,\quad n-\dfrac{-1-\sqrt{8a+1}}{2}\ge0
$$

所以我们得到了 $n$ 的取值范围：

$$
\dfrac{-1-\sqrt{8a+1}}{2}\le n\le\dfrac{-1+\sqrt{8a+1}}{2}
$$

所以 $n$ 的最大值就是 $\left\lfloor\dfrac{-1+\sqrt{8a+1}}{2}\right\rfloor$。

（由于显然 $n$ 是整数，再结合这个不等式的意义可知，需要加下取整）

$b$ 那边，也是同理的。结合这两边的结果，可以发现 $n$ 的最大值就是：

$$\min\left(\left\lfloor\dfrac{-1+\sqrt{8a+1}}{2}\right\rfloor,\left\lfloor\dfrac{-1+\sqrt{8b+1}}{2}\right\rfloor\right)$$

------------

再转过头来，看看带上 $c$ 的情况。

由上面的那个求出 $n$ 的最小值的式子，我们不难看出，需要**让 $a,b$ 中的最小值尽可能大！**

那么，我们分类讨论：

不妨设 $a>b$。

（有没有同学忘记了 $a,b$ 的意义？

>pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料

这就是 $a,b$ 的意义啦qwq。）

- 如果 $a+c\le b$，那么这 $c$ 块钱肯定都要花在材料 A 上，才能让他们中的最小值最大。
- 否则一定有 $a+c>b$，那么先花 $b-a$ 块钱，让材料 A 的个数等
于材料 B 的个数，然后 $a,b$ 各加上 $\left\lfloor\dfrac{c-b+a}{2}\right\rfloor$。

然后再直接套用上面的公式即可。复杂度 $O(1)$。

------------

上代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cmath>

#define LL long long

using namespace std;

LL a,b,c;

int main(void){

    scanf("%lld%lld%lld",&a,&b,&c);
    LL x=max(a,b),y=min(a,b);
    LL m=x-y;
    if(m>c){//如果 x-y>c,即 c+y>x，那就是分类讨论时的第一种情况。
        LL ans=(LL)(((LL)(floor(sqrt(8*(y+c)+1)))-1)/2);//套公式
        printf("%lld\n",ans);
        return 0;
    }
    else{//否则那就是第二种情况
        c-=m;
        LL ans=(LL)(((LL)(floor(sqrt(8*(x+(LL)(c/2))+1)))-1)/2);//套公式
        printf("%lld\n",ans);
    }

    return 0;
}
```

---

## 作者：Unordered_OIer (赞：36)

# P6784 题解
[$\texttt{\color{red}{See} in the blog}$](https://www.luogu.com.cn/blog/291706/)

## 题意
用 $c$ 购买若干个 $A$ 材料和 $B$ 材料使得购买后 $\min(a,b)$ 最大。

## 样例解释
```
Input:
1 2 3

Output:
2
```
我们可以用 $2$ 块钱买 $2$ 个 $A$ ，用 $1$ 块钱买 $1$ 个 $B$ ，这样 $a=3,b=3$ ， $\min(a,b)=3=1+2$ ，所以我们可以盖 $2$ 层。

```
Input:
1 5 3

Output:
2
```
这时我们发现就算把 $3$ 块钱全部买 $A$ 也还是超不过 $5$ ，所以买后 $a=4,b=5$ ， $\min(a,b)=4=1+2+\color{red}1$ 。这时这个红色的 $1$ 无法盖第 $3$ 层楼，只能废除。所以还是 $2$ 层。输出 $2$ 。

## 解答
分类讨论：

1. $c=0$ ，一定输出 $\min(a,b)$ 。
2. $\min(a,b)+c \leq \max(a,b)$ ，因为无论如何都无法超过小的和大的之间的差距，所以直接输出 $\min(a,b)+c$ 即可。
3. $\min(a,b)+c>\max(a,b)$ ，这时候我们可以把小的和大的之间的差距变为 $0$ ，并且还会剩下部分的钱，设为 $rc$ 。对于剩下的这 $rc$ 块钱，我们最优的策略是每买一个 $A$ ，就买一个 $B$ ，即**让 $|a-b|$ 尽量小**。这样不会出现头重脚轻的情况，就能盖最高的楼。

材料确定完毕，接下来确定输出结果，这里给出了 $3$ 种方法。

### 1. 顺序枚举答案
我们每循环一次，对于 $i$ ，如果 $\dfrac{i \times (i+1)}{2}<\min(ansa,ansb)$ ，那么我们继续枚举，直到找到一个 $i$ ， $\dfrac{i \times (i+1)}{2}≥\min(ansa,ansb)$ ，这时我们直接输出 $i$ 并结束程序即可。如果记答案为 $L$ ，复杂度为 $\Theta(L)$ 。

### Code:
```cpp
for(int i=1;i;++i)
	if(i*(i+1)/2>=ans)return cout<<i,0;//ans=min(ansa,ansb)
```

### 2. 二分枚举答案
很容易看出，对于任意 $b>a$ ，都存在 $\dfrac{b \times (b+1)}{2}>\dfrac{a \times (a+1)}{2}$ ，所以对于单调递增的 $i$ ，我们可以对其进行**二分枚举答案**。但是注意，答案取值范围不定，因此我们需要取一个较大的数。如果这个较大的数记为 $L$ ，复杂度为 $\Theta(\log L)$ 。比顺序枚举答案快许多。

### Code
```cpp
long long leftbound=1,rightbound=L;
while(leftbound<=rightbound){
    long long middle=(leftbound+rightbound)>>1;//()不加也行
    if(middle*(middle+1)/2<=ans)leftbound=middle+1,ans=middle;
    else rightbound=middle-1;
}
```

### 3. 数学
这个数学算是很简单的一元二次方程了。直接给出过程：

设答案为 $x$ 。
$$\dfrac{x(x+1)}{2} \leq n$$
$$x(x+1)-2n \leq 0$$
$$x^2+x-2n \leq 0$$
这里直接跳过~~简短的~~过程，直接给出结果。
$$x \leq \dfrac{-1+\sqrt{1+8n}}{2}$$
然后我们把这个东西下取整一下就行了，复杂度 $\Theta(1)$ 。最快啦~

### Code:
```cpp
cout<<(floor((sqrt(1+8*n)-1)/2))<<endl;
//嗯对，就这样简单粗暴
```

### 普及一个东西

我们怎么快速求解**不可因式分解一元二次方程**呢？这时，我们有一个**求根公式**：

对于方程 $ax^2+bx+c=\color{red}0$ （注意一定为 $0$ ）
$$x=\dfrac{-b±\sqrt{b^2-4ac}}{2a}$$

用这个也可以解一元二次不等式哦~

Q：求根公式里面不是 $-b\color{red}{\ ±\ }\color{black}\sqrt{b^2-4ac}$ 吗，为什么在解不等式里面是 $-1\color{red}+\color{black}\sqrt{1+8n}$ 呢？  
A：这里其实有一个隐藏条件： $x≥0$ ，如果 $x=\dfrac{-1-\sqrt{1+8n}}{2}$ ，那么由于根号双重非负（即内外皆非负），分数值一定小于 $0$ ，但是这就不满足 $x≥0$ ，舍去，所以只剩下了 $x=\dfrac{-1+\sqrt{1+8n}}{2}$ 。

## 后记
这道题放在月赛 $T1$ 还是挺合适的，确实很简单，~~希望可以稍微难点~~。

最后，祝洛谷月赛
## 越办越好

完结撒花~顺便求赞

---

## 作者：Aw顿顿 (赞：25)

先写一发题解，存着备用，看大家都在抢提交有点恐怖/fad

题意很简单，题目规范也做的很好，所以不多赘述。

## 解法分析 Analysis

由题目可知，$a$ 和 $b$ 类似于我们所说的“短板效应”，因为每一层对两个砖头所需的数量都是相同的，显然能盖的最高楼层是由其中较少的那一块决定的，所以我们要让较少的一类尽可能多，即考虑一个贪心策略，尽可能让 $|a-b|$ 小，这样我们就可以最大化地利用这些砖头来造房子了。

也就是说，我们要合理地分配这个 $c$，使得 $a$ 和 $b$ 尽可能接近，他们的差非 $1$ 即 $0$，这时候就要分情况考虑。

假设最后我们能做到使得 $\min(a,b)=s$，那么考虑 $s$ 的不同情况有：


- 普通情况：

因为我们可以将 $c$ 均匀分配，若将 $c$ 也视为一种砖头，可以任意变换的转呕吐，那么能得到的最优解就是“砖头总数”的一般，也就是：

$$s=\left\lfloor\dfrac{a+b+c}{2}\right\rfloor$$

- 特殊情况

但是上述方案有一个问题，如果用所有的 $c$ 都无法使得 $a$ 和 $b$ 的差满足最优的情况，也就是当 $c<|a-b|$ 的时候，我们就只能退而求其次，尝试用全部的 $c$ 来填补 $\min(a,b)$ 的空缺，也就是：

$$s=\min(a,b)+c$$

这时候我们就可以求出砖头数了。

接下来就需要模拟搬砖的过程，因为：

$$\sum\limits_{n=1}^{10^6}n=(1+10^6)\times10^6>10^{12}$$

所以简单的模拟运行次数不会超过 $10^6$，这样就可以简单的解决了，大体步骤如下：

- 循环变量 $i$ 每次加 $1$（`while` 和 `for` 皆可）。
- 用 $sum$ 累加。
- 判断，若 $sum>s$ 就输出 $i-1$。

当然如果你判断 $sum+i+1>s$ 输出 $i$ 也是可以的。

最后注意的是，范围到了 $10^{12}$，所以记得开 `long long`，同时使用到的 `abs` 要用到 `cmath` 库。

## 代码实现 Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,s,ans;
int main(){
	cin>>a>>b>>c;
	if(abs(a-b)>c)s=min(a,b)+c;
	else s=(a+b+c)/2;
	for(long long i=1;;i++){
		ans+=i;
		if(ans>s){
			cout<<i-1<<endl;
			return 0;
		}
	}
}
```

当然你完全可以对前 $\left\lfloor\sqrt{s}\right\rfloor$ 层楼用等差数列求和公式进行计算，然后再进行循环求解，这样可以大大优化原有程序的效率，改动部分代码如下：

```cpp
f=sqrt(s)-1;
ans+=(1+f)*f/2;
for(long long i=f+1;;i++){
	ans+=i;
	if(ans>s){
		cout<<i-1<<endl;
		return 0;
	}
}
```

[>> 点击查看 $\rm\color{lime}AC$ 记录 <<](https://www.luogu.com.cn/record/37637626 "浮窗提示：作者长期打开完全隐私保护，不可查询链接属正常情况")

求赞，感谢阅读。

---

## 作者：Daidly (赞：8)

**先分析一下题意：**

- $A$材料和$B$材料的个数已经给出，现有$c$个替补材料，每盖一层就需要比前一层多一个$A$材料和$B$材料，也就是说，第$i$层需要$i$个$A$材料和$B$材料。

**想法：**

- 先把剩余的$c$个替补材料给换成$A$材料和$B$材料，使得$A$材料和$B$材料的个数最接近。

- 然后模拟一下盖房子的过程，第$n$次减$n$就行了。

**实践：**

- 先分别判断$A$材料和$B$材料和$c$的大小关系：
    
    $1.$  如果$b<a$，并且$c$足够填满$b<a$这个坑，那就`c-=a-b,b=a`；要是$c$填不满，那就`b+=c,c=0`。
    
    $2.$  如果$a<b$，并且$c$足够填满$a<b$这个坑，那就`c-=b-a,a=b`；要是$c$填不满，那就`a+=c,c=0`。
    
    $3.$ 如果$a=b$，那就不用管。
    
- 然后再把剩余的$c$平均分配给$a$和$b$。

- 最后，一个`for(long long i=1;i<=min(a,b);i++)`循环，每次减$i$，判断$a$和$b$是否小于$i$，也就是不能减了，就够了。

- **在这里补充一点**如果数据存在$a$或$b$等于零的话，就要特判一下，例如`10 0 0`。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c;
int main(){
	cin>>a>>b>>c;
   if(a==0||b==0){cout<<"0";return 0;}//特殊判断一下
	if(a>b){
		if(a-b>c){
		    b+=c,c=0;
		}else{
		    c-=a-b,b=a;
		}
	}
	if(a<b){
		if(b-a>c){
		    a+=c,c=0;
		}else{
		    c-=b-a,a=b;
		}
	}
	a+=c/2;b+=c/2;
	for(long long i=1;i<=max(a,b);i++){
		a-=i;b-=i;
		if(a<i||b<i){
			cout<<i;
			return 0;
		}
	}
}
```
当然，最后的循环的$a$和$b$改成$a$和$b$中较小的那个也行，如：
```cpp
a=min(a,b)+c/2;
for(long long i=1;i<=min(a,b);i++){
	a-=i;
	if(a<i+1){
		cout<<i<<endl;
		return 0;
	}
}
```
但好像不会快多快。

好了，这道题的讲解就到此结束，谢谢大家。



---

## 作者：_0x46EDC (赞：6)

[获得更好的阅读体验](https://www.luogu.com.cn/blog/jasonying/p6784-ezec-3-zao-fang-zi) [题目传送门](https://www.luogu.com.cn/problem/P6784)

---

### 题目分析

共有 $a$ 块 $A$ 材料和 $b$ 块 $B$ 材料，一共可以再买 $c$ 块材料。

修建第 $i$ 层房屋各需要 $i$ 块 $A$ 材料和 $B$ 材料，求最多能建多少层。

### 推导

设 $A$ 材料增加 $t$ 个，则 $B$ 材料增加 $c-t$ 个，则最后最多各有 $\min(a+t,b+c-t)$ 块 $A$ 材料和 $B$ 材料。易得 $a+t$ 与 $b+c-t$ 的差值越小，修建层数越高。

不妨设 $a\le b$，$c$ 应先分出 $b-a$ 使得 $a=b$，随后将剩余部分即 $c-b+a$ 分成两份分给 $a$ 和 $b$。即最后最多有 $b+\dfrac{c-b+a}{2}$ 份材料。 

特别地，在 $a+c<b$ 时，最后最多有 $a+c$ 份材料。

### 代码

1. 计算最多材料

```cpp
if(a>b)swap(a,b);//使得a<=b
if(a+c<b)m=a+c;
else m=b+(c-b+a)/2;
```

2. 计算最多层数

```cpp
while(i<=m)i+=++j;//相当于j++,i+=j
cout<<j-1<<endl;//记得-1，原因显然
```

具体代码略去。

### 结语

一个简单的推柿子题目，分配 $c$ 的过程感觉类似于求 LCA。

求最多层数的部分可以使用二分进行优化，代码略。

---

## 作者：Rubidium_Chloride (赞：4)

8月月赛II A题题解。

## 0.前言

[$\color{Red}{\text{在}}\color{orange}\text{博}\color{yellow}\color{green}\text{客}\color{Turquoise}\text{里}\color{blue}\text{看}\color{purple}\color{Red}\text{效}\color{orange}\text{果}\color{yellow}\text{更}\color{green}\text{好}\color{Turquoise}\text{哦}\color{blue}!$](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p6784)

## 1.题目大意

- 给定 $a,b,c$，分别代表 $A$ 种材料有 $a$ 个，$B$ 种材料有 $b$ 个，并且有 $c$ 个“万能材料”（即可以自由选择）；

- 建造第 $i$ 层楼需要用掉 $i$ 个 $A$ 种材料，$i$ 个 $B$ 种材料，求能够建造的最高层数。

- $0\le a,b,c \le 10^{12}$。

## 2.基本分析

PS：以下我们将 $1$ 个 $A$ 材料和 $1$ 个 $B$ 材料合称为 $1$ 组材料。

先让我们来分析一下样例。

$\texttt{input 1}$：`1 2 3`；

$\texttt{output 1}$：`2`；

为什么呢？

给的解释是：

>pigstd 买 $2$ 个 $A$ 材料和 $1$ 个 $B$ 材料后就有 $3$ 个 $A$ 材料和 $3$ 个 $B$ 材料，最多可以建 $2$ 层楼的房子。

此时 $A$ 材料的数目是等于 $B$ 材料的数目的。

$\texttt{input 2}$：`1 5 3`；

$\texttt{output 2}$：`2`；

给的解释是：

>pigstd 买 $3$ 个 $A$ 材料后就有 $4$ 个 $A$ 材料和 $5$ 个 $B$ 材料，最多可以建 $2$ 层楼的房子。

此时的 $A$ 材料和 $B$ 材料的数量也是尽量接近的。

所以我们可以做出一个非常**贪心**的举措：适当分配 $c$ 个万能材料，使得 $A$ 种材料和 $B$ 种材料的数量尽可能的相近，也就能得到尽量多的材料组数。

此时在代码中我们用 $\texttt{tot}$ 代表能够获得的最多的材料组数。

~~话说这点东西有必要讲这么多吗。~~

贴上代码：

```cpp
tot=min((a+b+c)/2,min(a+c,b+c));
/*
min(a+c,b+c)是因为可能用尽全部的万能材料也不能让其中一种材料的数量比另一种多
*/
```

接下来做法比较随意，可以直接枚举层数 $k$，但是在这里，作者使用的是**二分法**。

相信二分法各位都会，这里就不具体讲了，大概讲下思路。（如果不会的可以私信作者。）

直接二分层数 $k$ 然后如果此时有足够的材料组，那么更新答案。

什么？如何判断？

$$\sum\limits^{i=1}_{k} i\ =\ \dfrac{k\times (k+1)}{2}$$

然后就很好判断了。

本部分代码：
```cpp
while(l<=r){
	ll mid=(l+r)/2;
	if(mid*(mid+1)/2<=tot) l=mid+1,ans=mid;
	else r=mid-1;
}
```

PS：这里 $\texttt{r}$ 最好初始值设的大一点，否则可能无法达到最大答案。作者在这里设的是 $2000000$。

## 3.后记

代码相信已经给的足够多了，不会的可以私信询问。

祝大家AC本题，也祝洛谷月赛能够越来越好！

---

## 作者：infinities (赞：2)

贪心+暴力/二分。

首先我们发现建每一层楼所需要的材料数相同，所以应该保证它们的差尽可能小。

不妨设 $a \le b$。

则我们有的 $c$ 块钱有两种可能，一种是全部来买 A 材料但是仍然赶不上 $b$，即 $a + c < b$，这样我们就全部来买 A。另一种是补足 A 和 B 的差距之后还有剩余，于是把剩余的钱分成相等的两部分分别买 A 和 B。

接下来只需暴力/二分即可，就是枚举楼层数看能不能建这么多层。

code(暴力)：

```cpp
#include<bits/stdc++.h>
#define int long long
#define rint regester int
const int maxn = 1e6 + 10;
const int INF = 1e9;
using namespace std;
int read(){
    int x = 0,f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
int a, b, c, ans[20000000], sum; 
signed main(){
	a = read(), b = read(), c = read();
	if(a > b)swap(a, b);
    if(c < (b - a)){
    	a += c;
	}else{
	    c -= (b - a);
		a += (b - a);
		a += c / 2;
		b += c / 2;
	}//贪心
	for(int i = 0; i * (i + 1) / 2 <= a; i++){
		sum = i;
	}//暴力
	cout << sum;
}

```

---

## 作者：BotDand (赞：1)

# Problems
pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。
# Answer
贪心。

定义$sum(n)$函数为$1+2+……+m\le n$时$m$的最大值。

* 如果将$c$全部放入$a$中还达不到$b$，则输出$sum(a+c)$，否则先将$a$达到$b$，然后将$c$平分于$a$和$b$，则输出$sum((a+b+c) \div 2))$；

* 如果将$c$全部放入$b$中还达不到$a$，则输出$sum(b+c)$，否则先将$b$达到$a$，然后将$c$平分于$a$和$b$，则输出$sum((a+b+c) \div 2))$；

时间复杂度：$O(\sqrt{2n})$

# Code
```pascal
var
  a,b,c:int64;
 function sum(n:int64):int64;//sum函数
  var
    i:int64;
  begin
    i:=1;
    while i*(i+1) div 2<=n do inc(i);
    exit(i-1);
  end;
begin
  readln(a,b,c);
  if a<b then//比较大小
    begin
      if a+c<b then writeln(sum(a+c))//将c全部放入a
        else writeln(sum((a+b+c) div 2));//否则平分
    end
    else
      begin
        if b+c<a then writeln(sum(b+c))
          else writeln(sum((a+b+c) div 2));//同理
      end;
end.
```
求过qwq

---


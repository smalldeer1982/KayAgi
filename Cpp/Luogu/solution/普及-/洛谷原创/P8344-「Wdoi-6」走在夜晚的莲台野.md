# 「Wdoi-6」走在夜晚的莲台野

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/8brkt9is.png)](https://thwiki.cc/%E8%8E%B2%E5%8F%B0%E9%87%8E%E5%A4%9C%E8%A1%8C)

在科学世纪中，科学昌明，信息科技高度发达，但与此同时，想象力灭绝了，而无法解释的事物则被当做一个错误抹煞，无法解释的神秘也被否定。

宇佐见莲子（莲子）与玛艾露贝莉·赫恩（梅莉）成立了一个社团——秘封俱乐部。作为秘封俱乐部的成员，她们寻找着幻想的境界，在逐渐被人们所遗忘的世界中追寻着真正的美好。

她们的第一个活动，是探寻莲台野的结界缺口。

## 题目描述

### 简要题意

有 $x$ 个金色木板，$y$ 个银色木板，还有一个可放下 $z$ 个木板的空容器。每向容器中放入一个金色木板**后**，会丢弃容器内所有银色木板（需要确保在放金色木板前，容器里至少还能再放得下一个木板）。问是否存在一种方式，使得所有木板都被**放进过**容器中。

------
### 原始题意

在莲台野的入口，莲子与梅莉想要穿过现实与虚幻的结界，进入幻想乡。然而，穿越结界是有一定要求的。

具体而言，在结界边上会有若干个细长木板，其中有 $x$ 个是金色的木板，$y$ 个是银色的木板。梅莉通过自己能够看见结界的能力，发现了一个能够容得下 $z$ 个木板的容器，并且通过自己的潜意识得知了规则：
- 如果她们放进了一个金色的木板（需要确保在放金色木板前，容器里至少还能再放得下一个木板），那么**在容器中所有**银色的木板将被丢弃。
- 最后需要**所有**的木板都被**放入过**容器，结界的大门才将会被打开，即她们能够进入幻想乡。

现在已经是凌晨 2 点 27 分 41 秒，只有在凌晨 2 点 30 分前完成这个问题，她们才能进入幻想乡。现在，莲子和梅莉把这个问题交给了你，希望你能尽快帮她们做出回答——是否存在一种方案，使得她们能否进入幻想乡呢？

由于莲子和梅莉担心你在大半夜糊弄她们，因此她们会一共询问你 $T$ 次。

## 说明/提示

### 样例解释

#### 样例 \#1

- 对于第一次询问，存在如下的方案：
  - 先放三个银色木板；
  - 再放一个金色木板；
  - 再放两个银色木板；
  - 再放一个金色木板；
  - 再放一个银色木板。
- 这样就可以使得每个木板都被放入过容器中，莲子和梅莉可以进入幻想乡，故输出 `Renko`。
- 对于第二次询问，显然不存在方案。
- 对于第三次询问，可以先放进去十个金色木板，再放进去十个银色木板。

#### 样例 \#2

本组样例符合 $\textbf{subtask 2}$ 的要求。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{T\le } & \bm{x\le} & \bm{y\le} & \bm{z\le} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 20 & 1 & 10 & 10 & 10 &-\cr\hline
2 & 30 & 10 & 10^3 & 10^6 & 10^3 &1\cr\hline
3 & 20 & 100 & 10^6 & 10^9 & 10^6 &2\cr\hline
4 & 30 & 1000 & 10^9 & 5 \times10^{17} & 10^9 &3\cr\hline
\end{array}
$$

对 $100\%$ 的数据，保证 $1 \le T \leq 1000$，$1 \leq x,z \leq 10^9$，$1 \leq y \leq 5 \times 10^{17}$。

## 样例 #1

### 输入

```
3
2 6 4
5 8 2
10 10 22```

### 输出

```
Renko
Merry
Renko```

## 样例 #2

### 输入

```
10
221 44724 313
157 60759 464
181 145867 893
182 59650 418
384 168626 631
702 650463 194
617 376055 918
261 215764 955
502 744180 440
9 1626 168```

### 输出

```
Renko
Merry
Renko
Renko
Renko
Merry
Merry
Merry
Merry
Renko```

# 题解

## 作者：chen_zhe (赞：21)

显然，每次优先放入银色木板，到了最后一格的时候放入金色木板是最优的。根据这个思想去模拟放入过程，不开 long long 是 50-70 分，非常良心。

不妨考虑以最优情况放入所有金色木板后，所能承载的银色木板量。第一次放入金色木板前可以承载 $z-1$ 块银色木板，第二次则是 $z-2$ 块，以此类推到第 $x$ 次则是 $z-x$ 块，这构成一个等差数列。则可以通过放入金色木板而被挪出去的银色木板的总量为 $\dfrac{(z-1+(z-x))\times x}{2}$ 块。放入最后一块金色木板之后，盒子还剩下 $z-x$ 个空位可以放银色木板。故总共最多能放入 $\dfrac{(2z-x-1)\times x}{2}+z-x$ 块银色木板，只需把 $y$ 与之做比较即可。

计算过程要全程开 long long。数据我造的，被卡了的话请不要找我。

std：

```cpp
#include <iostream>
using namespace std;
int main()
{
	long long T,x,y,z;
	cin >> T;
	while (T--)
	{
		cin >> x >> y >> z;
		if (x>z)
			cout << "Merry" << endl;
		else
		{
			long long tot=(z-1+(z-x))*x/2+z-x;
			cout << (tot>=y?"Renko":"Merry") << endl;
		}
	}
	return 0;
}
```

---

## 作者：wangzl (赞：20)

## 简要题意  
有 $x$ 个金色木板，$y$ 个银色木板，还有一个可放下 $z$ 个木板的空容器。每向容器中放入一个金色木板后，会丢弃容器内所有银色木板（需要确保在放金色木板前，容器里至少还能再放得下一个木板）。问是否存在一种方式，使得所有木板都被放进过容器中。
## 核心思路   
我们如果把每放一块金色木板视为一次操作，我们很容易想到，对于每一次操作，我们应该放尽可能多的银色木板后再放一块金色木板清空，那么，我们可以将整个过程划分为 $x$ 次操作。  
对于每一次操作，有如下规律：     
第 $1$ 次操作，最多能放 $z-1$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $1$ 块木板；  
第 $2$ 次操作，最多能放 $z-2$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $2$ 块木板；  
第 $x$ 次操作，最多能放 $z-x$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $x$ 块木板。    
值得一提的是，我们其实还可以在第 $x$ 次操作后，再进行第 $x+1$ 次操作，但不清空（因为金色木板已放完），即再放下 $z-x$ 块银色木板，此时容器装满。  
可以证明，这是放置木板的最优方案。   
可以发现，放下的银色木板数量呈等差数列，此时，一共放下 $\dfrac{[(z - 1) + (z - x)]\, \times \,x}{2}+ (z-x)$ 块银色木板。  
所以我们只需要判断两个条件：
1. $x$ 是否小于等于 $z$ ；
2. 在进行 $x+1$ 次操作后银色木板是否被放完。  
如果这两个条件均满足，则可以放下，输出 `Renko` ，否则输出 `Merry` 。   
注意：本题数据规模较大，请使用**long long**类型的整型变量。
## $\text{std}$:
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long t, x, y, z;
int main() {
	scanf("%lld", &t);
	for (long long i = 1; i <= t; ++i) {
		scanf("%lld%lld%lld", &x, &y, &z);
		if(x <= z && (z - 1 + z - x) * x / 2 + z - x >= y) printf("Renko\n");
		else printf("Merry\n");
		}
	return 0;
}
```


---

## 作者：HeCao2008 (赞：7)

### 思路

贪心思路非常好想，在桶里放满银木板（但是要留一个空给金木板）然后用金木板把里面的银木板全部清掉，然后再放满银木板....

这样，第一次就可以放进去 $z-1$ 块木板，第二次可以放 $z-2$ 块木板，以此类推。

然后我们就可以用**等差数列**来求这个，公式非常好推。但是有几个注意的点：

- 如果金木板的数量比桶一次能装下的木板数要多，直接输出 Merry ，因为金木板放进去就不能放出来了。

- 在执行贪心操作当中，可能当中不会有足够的金木板（比如说在某一次操作没有金木板让里面的银木板出来了）所以得在等差数列公式上考虑到这个，你只能放到 $z-x$ 块木板。

- 如果上面两个都没问题，就判断银木板是不是可以全部都放进桶就行了。

根据思路我们可以得出首项是 $z-x$ ，末项是 $z-1$ ，而且最后放完金木板还可以再放 $z-x$ 块银木板，所以推出: $\dfrac{((z-x)+(z-1))\times ((z-1)-(z-x)+1)}{2} + (z-x)$ 

化简可得最多可以放入的银木板数量是：

$\dfrac{(2\times z-x-1)\times x}{2} + (z-x)$

最后再与 y 作比较就可以了。

### 代码

知道公式就很简单了，全程开 long long 注意。

```cpp
#include<bits/stdc++.h>
using namespace std;
int tt;long long x,y,z;long long now;
int main(){
	cin>>tt;
	while(tt--){
		cin>>x>>y>>z;
		if(x>z)cout<<"Merry"<<endl; //如果连金木板都放不下
		else{
            now=(2*z-x-1)*x/2+(z-x); //刚刚推的公式
            if(now<y)cout<<"Merry"<<endl;
			else cout<<"Renko"<<endl;
		}
	}
	return 0;
}
```

总之仔细就是了。

**谢谢大家的阅读**

---

## 作者：liangbowen (赞：3)

### 前言

[题目传送门](https://www.luogu.com.cn/problem/P8344)

[$\color{red}{see}\space \color{green}{in}\space \color{blue}{my}\space \color{purple}{blog}$](https://www.luogu.com.cn/blog/liangbowen/solution-P8344)

这题作为本次比赛的 T1，难度感觉还行，算是一道结论题。

已经尽量讲得简单一些，没有用复杂的求和符号。

### 思路

很容易想到贪心策略，如下。

第 $1$ 次放 $(z-1)$ 块银色木板，再放一块金色木板。

![](https://cdn.luogu.com.cn/upload/image_hosting/ytmlpcdg.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

第 $2$ 次放 $(z-2)$ 块银色木板，再放一块金色木板。

![](https://cdn.luogu.com.cn/upload/image_hosting/iyweoe0h.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

一直按照这个规律下去放木板，直到放完第 $x$ 次。

注意，还有第 $(x+1)$ 次，这一步执行时已经**没有金色木板**了，但可以将剩下的空位都塞满银色木板，可以塞 $(z-x)$ 块。

![](https://cdn.luogu.com.cn/upload/image_hosting/ixrigepw.png)

因此，我们最终需要判断：$(z-1) + (z-2) + \cdots + (z-x) + (z-x)$ 是否大于等于 $y$。

循环暴力累加，时间复杂度是线性的，但我们需要让时间达到 $O(1)$。

化简这个算式即可： $(z-1) + (z-2) + \cdots + (z-x) + (z-x)$。 

$\begin{aligned}\text{原式} &= (x+1) \cdot z - (1 + 2 + \cdots + x + x)\\&= (x+1)\cdot z - \left[ \dfrac{(x+1)\cdot x}{2} + x \right]\end{aligned}$

这就是本题结论了。

### 坑点

切记开 `long long`。

开始时还需要判断一下，如果 $x > z$ 就必定无解。

### 完整代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
bool solve()
{
	long long x, y, z;
	scanf("%lld%lld%lld", &x, &y, &z);
	if (x > z) return false;
	return ((x+1) * z - (x * (x+1) / 2 + x) >= y);
}
int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		bool t = solve();
		if (t) puts("Renko");
		else puts("Merry");
	}
	return 0;
}
```

---

## 作者：ande (赞：2)

## 题意大概:
对于每次询问,给定了一个大小为 z 的容器,每次填满后可以清空,但是容量变小 ( z-- ), 清空次数最多为x次,问能否让y个物品都曾被装进去。
## 解答:
不难发现容器每次能装下的最大物品为: 

$$z - 1,\ z - 2,\ z - 3,\ … …,\ z - x,\ z-x;$$

那么很明显这个序列除却最后一项, 是一个等差数列, 于是可以进行简化:
$$ \mathsf{max}  =\begin{cases}\frac{x}{2} * (z+z+x-1) \ \ \ (x = 2n)
 \\
\frac{x}{2} * (z+z+x-1) +z - (\frac{x}{2}+1)  \ \ \ ( x = 2n+1)
\end{cases}
 $$
 最后再加上 $z - x$ 就好了,代码如下:
 ```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll T,x,y,z,sum;
int main() {
//freopen("data.in","r",stdin);
//freopen("data.out","w",stdout);
scanf("%lld",&T);
while(T--){sum=0;
	// sum=0;
	scanf("%lld%lld%lld",&x,&y,&z);
	if(x>z){//特判一下全装金板砖都不行的情况
		printf("Merry\n");
		continue;
	}
	if(x%2 == 0)
		sum = (x/2)*(z+z-x-1); 
	else
		sum = (x/2)*(z+z-x-1) + z-(x/2+1);
	sum += z-x;
	 // printf("%lld ",sum);
	if(sum >= y) 
	{
		printf("Renko\n");
	}
	else{
		printf("Merry\n");
	}

}


  return 0;

}

```


---

## 作者：快斗游鹿 (赞：2)

## 思路

每个木板只需放一次即可，而每放一个金色木板，就会丢掉所有银色木板，故此只需考虑金色木板的放置即可。而会被丢弃的只有银色木板，金色木板放下去是不会再丢掉的。也就是说，我们可以将问题转化为：

这里有 $x$ 个金色木板，$y$ 个银色木板，和一个容量为 $z$ 的桶。需要经过若干次操作，每次操作放入 $1$ 个金色木板，接下来依次放入银色木板，直到桶满了，清空银色木板，当没有金色木板可放时，若银色木板没有剩余，输出 $\texttt{Renko}$，否则输出 $\texttt{Merry}$。操作过程如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/dpzthu84.png)

转化为上述问题后，我们考虑：

在第 $1$ 次操作时，桶能放下 $z-1$ 块木板，第 $i$ 次操作时，桶只能放下 $z-i$ 个木板，所以能放下的银木板数形成了一个等差数列。一共能放下的银木板数应为 $\dfrac{(z-1+z-x)\times x}{2}$ 块，特别地，当 $x$ 小于 $z$ 时，最后还应再加上 $z-x$ 块木板。当 $x$ 大于 $z$ 时，需要特判无解。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y,z,t;
int main(){
	scanf("%lld",&t);
	for(int ii=1;ii<=t;ii++){
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z)cout<<"Merry"<<endl;//特判无解
		else{
			ll s=z-x;//最少
			ll ss=z-1;//最多
			ll sss=((ss+s)*(ss-s+1))/2;//等差数列公式
			sss+=s;//考虑x<z
			if(sss>=y)cout<<"Renko"<<endl;//能放下
			else cout<<"Merry"<<endl;//不能
		}
	}
	return 0;
}

```


---

## 作者：Dream_weavers (赞：2)

## 思路

为了表达更简洁，金色木板用 Au 表示，银色木板用 Ag 表示。

每次放 Au 时，要保证容器里的 Ag **尽可能多**，也就是只能再放一个 Au，然后丢弃容器内所有 Ag。目的是为了放完所有 Au 时，容器中能**尽可能多**放 Ag，如果还是放不下，就输出 `Merry`，否则输出 `Renko`。特别的，如果容器连 Au 都放不下，就可以直接输出 `Merry`。


------------
举个例子：

当 $x=5,y=35,z=9$ 时

先用完放完所有的 Au，丢弃 Ag 的数量就是 $8+7+6+5+4=30$，可以发现这是一个**公差为 $1$、首项为 $z-1$、项数为 $x$ 的等差数列（递减）再求和**，这个求和公式很简单就不多说了。（如果不知道的建议百度一下）

然后再放剩余的 Ag，有 $35-30=5$ 个，容器中还能放下 $9-5=4$ 个，很明显 $4<5$ 放不下，输出 `Merry`。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,x,y,z; 
signed main(){
	scanf("%lld",&t);
	while(t--){
		int sum=0;
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z){//Au都放不下直接输出Merry
			puts("Merry");
			continue;
		}
		sum=((z-1)+(z-x))*x/2+(z-x);//求最多能发多少Ag
		if(y>sum)puts("Merry");//大于就输出Merry
		else puts("Renko");
	}
	return 0;
}

```


---

## 作者：RNTBW (赞：2)

这是结论题？

看起来像贪心吧...

## 题意

- 有 $x$ 个金色木板，$y$ 个银色木板和一个能放下 $z$ 个木板的桶，当在桶内放下一个金色木板**后**桶内的银色木板会消失，问是否能使所有木板都**进入过**桶。

- $x \leqslant 10^9$，$z \leqslant 10^9$，$y \leqslant 5 \times 10^{17}$。

## 思路

看一下样例就知道，$y$ 非常的大。

所以我们就有了一个思路：将能放银色木板的最大数量计算出来再与 $y$ 比较。

怎么计算呢？

**贪心！**

我们要放最多的银色木板，而在放一个金色木板后所有的银色木板会清零。

那么？
~~自己思考两分钟~~

------------

恍然大悟：

我们可以**最大化利用桶的容积**，放最多的银色木板，最后放一个金色木板将其清零！

当然这里还有几个坑点：

- 最多的银色木板数量是 $z-1$ 而不是 $z$。

- 放了一个金色木板后 $z$ 要减一。

- 在循环完之后桶内还有一些剩余空间也要算！

于是思路就出来了：

循环 $x$ 次（有 $x$ 个金色木板，也就有 $x$ 次清零的机会），每次将 $z$ 减一，同时累加器 $k$ 加上 $z$。

最后将 $k$ 与 $y$ 进行比较。

好了，代码打出来了，样例过了，应该可以...

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,x,y,z,i,k;
int main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld%lld",&x,&y,&z);k=0;
		if(x>z)
		{puts("Merry");continue;
		}
		if(x+y<=z)
		{puts("Renko");continue;
		}//两种特判
		while(x) z--,x--,k+=z;
		if(k+z<y)puts("Merry");
		else puts("Renko");
	}
	return 0;
}
```

70 分...

老规矩，开始优化！

我们想到，可以将循环中的 $z$ 放入一个 $a$ 数组中，

然后求 $\sum_{i=1}^x a_i$ 即可。

~~似乎没用~~

但是！

仔细想，$a$ 数组满足什么？

由于我们的 $z$ 在循环内是每次恒定减一的，所以...

这个数组满足**单调递减！**

那么再求 $\sum_{i=1}^x a_i$ 就可以用**等差数列优化！**

小学就学过的等差数列求和公式就不用多说了吧。

当然我在这儿用的是平均数 $\times$ 项数，也是可以滴~

啊还有一个坑点：

- 当 $x$ 是 2 的倍数时平均数要加 $\dfrac{1}{2}$。

事已至此，万事大吉，可以...

不要紧张，100 分拿到手！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,x,y,z,k;
long double s;//血泪教训！
int main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld%lld",&x,&y,&z);//血泪教训！
		if(x>=z)
		{puts("Merry");continue;
		}
		if(x+y<=z)
		{puts("Renko");continue;
		}
		s=z-1-x/2+(x%2 ? 0:0.5);
        //平均数
		k=x*s;//总和
		if(k+z-x<y)puts("Merry");
        //z-x是剩余的空间
		else puts("Renko");
	}
}
```

完结撒花~

---

## 作者：Ask_sum (赞：1)

# P8344 题解
~~此为本人第一篇题解，如有不足请谅解。~~

[题目传送门](https://www.luogu.com.cn/problem/P8344)

### 第一条件（20 pts）

根据题意，我们知道，放入一块金色木板能使所有银色木板清除（**注意，不会清除金色木板！**）。所以，金色木板数量 $x$ 就不得超过容器大小 $z$ ，因为超过的话，连金色模板也放不下了。所以，一个限定条件就是 $x≤z$。

### 第二条件 (100 pts)

刚才我们已经得到了第一个条件，但是仅仅只能得到20分。因为有时金色木板用完也无法使剩余银色木板数 $y$ 小于等于**这个容器的剩余空间**，导致失败。所以我们需要一个新条件。

容易想到，此条件与等差数列求和有关，第一次最多可以放入 $(z-1)$ 个，第二次最多可以放入 $(z-2)$ 个，那第三次、第四次呢？不言而喻。第 $x$ 次呢？当然是 $(z-x)$ 个。

所以，**在金色木板用完之前**，设最多可放入的银色木板数量 $m$ 为 

$(z-1)+(z-2)+(z-3)+...+(z-x)=zx-(1+2+3+...+x)$，

根据等差数列求和公式,可得 

$1+2+3+...+x=\dfrac{x \cdot (x+1)}{2}$，

所以实际上 

$m=zx-\dfrac{x \cdot (x+1)}{2}=\dfrac{2zx-x^2-x}{2}=\dfrac{(2z-x-1) \cdot x}{2}$。

然而，在某些时候，就算银色木板数量 $y$ 大于在金色木板用完之前银色木板最多可使用数量 $m$，剩余的空间，即 $(z-x)$，也**足以使剩余的银色木板全部使用**，所以我们设总共可以最多放置银色木板数量为 $n$，所以由此得到 

$n=m+(z-x)=\dfrac{(2z-x-1) \cdot x}{2}+(z-x)$。

所以，第二个条件就是 $y≤\dfrac{(2z-x-1) \cdot x}{2}+(z-x)$。

综上所述，可以得知，本题是一道数学题，每组数据时间复杂度为 $O(1)$，总时间复杂度为 $O(T)$，可以通过本题。

此外，因为 $y$ 的数据范围较大，不要忘记开 long long。

## Accepted Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){//快读 
	char ch=getchar();
	ll f=1,x=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return f*x;
}
ll T,x,y,z;//注意开long long 
int main(){
	T=read();
	ll sum=0;
	while(T--){
		x=read(),y=read(),z=read();
		ll k=(2*z-1-x)*x/2+z-x;//本题核心部分 
		if(y>k||x>z)cout<<"Merry"<<endl;
		else cout<<"Renko"<<endl;//输出 
	}
	return 0;
}

---

## 作者：Zero_s (赞：1)

这是一道比较简单的数论题目。
## 推理：
首先，我们可以假设一个容量为 $z$ 的容器，第一次最多可以装得下 $z-1$ 个银色木板，剩下一个放金色木板。这样，就可以实现银色木板放的数量最多。

那要怎么计算最多可以放多少个银色木板呢？

其实很简单，只需要循环求出 $(z-1)+(z-2)+(z-3)+...+(z-x)$ 就好了。用等差数列求和公式可以直接得到 $(2z-1-x)\cdot x\div2$ 这个式子。

[等差数列求和公式是什么？](https://kuai.so.com/770700f56d1acaaa0d6557306696ae1a/wenda/Selectedabstracts/www.zhidaolib.com)

解决了这个问题之后，就要考虑如何判断了。我们需要把所有剩下的银色木板加上金色木板的数量就好了，也就是 $y-(2z-1-x)\cdot x\div2+x$ 了。

但是有没有发现一个问题？似乎 $y-(2z-1-x)\cdot x\div2$ 可能出现负数，但是剩下的银色木板数量不能是负数，那怎么办呢？其实只要取 $Max(y-(2z-1-x)\cdot x\div2,0)$ 就好了。

接下来让 $Max(y-(2z-1-x)\cdot x\div2,0)+x$ 和 $z$ 比较就可以了，这样就可以解决问题了！
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll T,x,y,z;
inline ll _Max(ll w){return w>0? w:0;}//求w与0的Max
inline ll read()//快读优化
{
	ll x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);//位运算优化
		ch=getchar();
	}
	return x;
}
int main()
{
	T=read();
	while(T--)
	{
		x=read(),y=read(),z=read();
		puts(_Max(y-(((z<<1)-1-x)*x>>1))+x>z? "Merry":"Renko");
      			//把刚刚推出来式子的代入比较
	}
	return 0;
}
```
[什么，有人不知道快读？QWQ](https://www.cnblogs.com/qiuchengrui/p/9785561.html)

[什么，有人不知道位运算？qwq](https://blog.csdn.net/a1351937368/article/details/77746574/)

[什么，有人不知道QwQ？qWq](https://www.luogu.com.cn/training/163198)

---

## 作者：ttq012 (赞：1)

容易发现，金色木板是不会被弹出的，当容器只剩下最后一个位置的时候放一个金色木板将所有底下的银色木板弹出是最优解。

当金色木板的数量比容器可以放的木板要多的时候，无解。

否则，可以放的银色木板的数量是一个等差数列，第一次可以放 $z-1$ 个，第二次可以放 $z-2$ 个，$\cdots$，最后一次，也就是第 $x$ 次，可以放 $z - x + 1 - 1 = z-x$ 个。然后将等差数列求和公式 $\frac{(l+r)\times (r-l+1)}{2}$ 代入得到 $\frac{[(z-1)+(z-x)]\times [(z-1)-(z-x)+1]}{2} = \frac{(2\cdot z - x - 1)\cdot x}{2}$ 块，这个时候还可以再放 $z-x$ 块填满这个容器，所以最多可以放 $\frac{(2\cdot z - x - 1)\cdot x}{2} + (z-x)$ 块，和 $y$ 进行比较大小即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

#define int long long

using namespace std;

void solve() {
    int x, y, z;
    cin >> x >> y >> z;
    if (z < x)
    	puts("Merry");
    else if (z == x) {
    	int kfz = (2 * z - x - 1) * x / 2;
    	if (kfz >= y)
    		puts("Renko");
    	else
    		puts("Merry");
	}
	else {
		int kfz = (2 * z - x - 1) * x / 2 + z - x;
		if (kfz >= y)
			puts("Renko");
		else
			puts("Merry");
	}
}

signed main() {
	int T;
	cin >> T;
	while (T--)
    solve();
    return 0;
}

```


---

## 作者：Nygglatho (赞：1)

显而易见的，要使所有的木板都被放入过，要把木板变得 **尽可能少**（这里认为丢弃就算变少）。

那么由于金色木板不能变少，所以优先考虑银色木板。

显然，如下图，由于操作后结果相同，所以放到 $z - 1$ 个（包括最前面的金色木板）是最优的。

![](https://s1.ax1x.com/2022/05/16/OhiXAf.jpg)

![](https://s1.ax1x.com/2022/05/16/OhFwDI.jpg)

那么，第一次丢弃 $z - 1$ 个，第二次 $z - 2$ 个，第三次 $z - 3$ 个，以此类推，这样就是等差数列，首项为 $z - x$，末项为 $z - 1$，项数为 $x$，那么总共可丢弃银色木板数量即为 $\min\left(\dfrac{(z - x + z - 1) \cdot x}{2}, y\right)$。

那么银色木板剩余数量即为 $\max\left(\dfrac{y - (z - x + z - 1) \cdot x}{2}, 0\right)$，只需要判断这个是否小于 $z - x$ 即可。

注意，如果 $x > z$，那么因为 $x$ 无法被丢弃，所以不可行。

Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int T;
	cin >> T;
	while(T--) {
		long long x, y, z;
		cin >> x >> y >> z;
		
		if (x > z) {puts("Merry"); continue;}
		
		if (max(y - (((z - 1ll) + (z - x)) * (x) / 2ll), 0ll) <= z - x) puts("Renko");
		else puts("Merry");
	}
}
```

---

## 作者：a1ioua (赞：1)

1. 若 $z>x$，显然无方案。
1. 若 $z\le x$：
   - 由于每一个金色木板都需放入容器，且放进去后容器中的银色木板会清空，所以我们不妨使用贪心策略：
   - 设空容器还能放下 $n$ 个木板，则我们可以放 $(n-1)$个银色木板，再放 $1$ 个金色木板，这样可以使其最优化。
   - 那么，我们一共可以在容器中放 $(z-1)+(z-2)+\cdots+(z-x-1) + (z-x)=xz+\dfrac{x(x+1)}{2}+(z-x)$ 个银色木板。$(z-x)$ 指的是金色木板全放入后剩余可以放的木板数量。
   - 最后，将上面那个公式与 $y$ 比较即可。

------------
```cpp
#include <bits/stdc++.h>
long long x, y, z, t;
main() {
    scanf("%lld", &t);
    while (t--) {
        scanf("%lld%lld%lld", &x, &y, &z);
        if (x > z) printf("Merry\n");
        else if (y <= x * z - x * (x + 1) / 2 + z - x) printf("Renko\n");
        else printf("Merry\n");
    }
}
```

---

## 作者：Infinity_G (赞：1)

# 题解

显然，$x>z$ 或 $z=1$ 时无解。

因为最后金色木板全都放在容器中，所以我们考虑最多能放多少个银色木板。设最多能放入 $p$ 个银色木板，若 $p\ge y$，则输出 $\texttt{Renko}$；否则输出 $\texttt{Merry}$。

因为要最大化 $p$，所以每次放入金色木板前容器中的银色木板要尽可能多，但又不能放满，因此每次放银色木板时要留出一个位置。不难发现，第一次可放 $z-1$ 个位置，第二次可放 $z-2$ 个位置，以此类推。然而放完所有的金色木板之后还能将银色木板补到空位中，因此得到 $p$ 的计算公式：

$$p=(\sum_{i=1}^{x}z-i)+z-x$$

套用等差数列求和公式并化简可得：

$$p=\frac{(2z-x-1)\times x}{2}+z-x$$

算出 $p$ 之后与 $y$ 比较大小即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t;
ll x,y,z,p;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z||z==1)
		{
			printf("Merry\n");
			continue;
		}
		p=(2*z-x-1)*x/2+z-x;
		if(p>=y) printf("Renko\n");
		else printf("Merry\n");
	}
	return 0;
}
```

---

## 作者：_lmh_ (赞：1)

题目不是很难，但是细节不少

首先，注意到金木板不能被拿出，那么如果容器不够放金木板那么就显然不行。

接下来模拟放银木板的过程：

首先放 $z-1$ 个木板，再放一个金木板。之后，容器里有一个金木板，再放 $z-2$ 个木板，再放一个金木板。如此往复，如果一种木板放完了，那么就把剩下的木板都放进去。
因为金木板不足以填满容器，所以只需考虑银木板即可。

银木板的放置数量为 $(z-1)+(z-2)+\cdots+(z-x)+z-x=\frac{x(2z-1-x)}{2}+z-x$。其中，前面的部分为被金木板移走的银木板，后面的 $z-x$ 是金木板放完后剩下的空间放的。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,z,T;
int main(){
    cin>>T;
    while(T--){
        cin>>x>>y>>z;
        if (x>z) puts("Merry");
        else if (((x*((z<<1)-1-x))>>1)+z-x<y) puts("Merry");
        else puts("Renko");
    }
    return 0;
}
```

---

## 作者：_xxy_ (赞：1)

~~来自一名270的蒟蒻在比赛时艰难的思考历程。~~

首先，我们很容易想到先放入 $ z-1 $ 个银木板，再放入一个金木板弹出所有的银木板，即判断 $ x\times (z-1)+z $ 与 $ x+y $ 的大小。

但是这样只有20分，考虑哪里出现了问题。

由于金木板不可能被弹出，所以当 $ x > z $ 时，无解，这样就有了70分。

同样是因为金木板放入后便不能再弹出，所以实际上第 $ n $ 个金木板放入后最多只能弹出 $ z-n $ 个木板，总共就最多只能弹出 $ (x \times z - (x+1)\times x \div 2) $ 块木板。

于是，我们就能过了这题了！（注意数据范围）

**AC Code:**

```cpp
#include<cstdio>
using namespace std;
inline long long read(){
	long long x=0,f=1;
	char ac=getchar();
	while(ac<'0'||ac>'9'){
		if(ac=='-') f=-1;
		ac=getchar();
	}
	while(ac>='0'&&ac<='9'){
		x=x*10+(ac-'0');
		ac=getchar();
	}
	return x*f;
}
int main(){
	long long t=read();
	while(t--){
		long long x=read(),y=read(),z=read();
		if(x<=z&&(z+x*z-(x+1)*x/2)>=x+y) printf("Renko\n");
		else printf("Merry\n");
	}
	return 0;
}
```

---

## 作者：几何微粒子 (赞：1)

本蒟蒻借鉴了 RNtianbowen 的思路，最后自己写出来了。

膜拜 RNtianbowen !!!

### 下面将金色木板简称金板，银色木板简称银板：

一开始我想用贪心。

思路：

因为放个金板进入桶就能使其中的银板全部被拿出......

所以我们可以不停的往桶里塞银板，直到**剩下一个金板的位置**，然后放一个金板上去......

于是连我这样的蒟蒻都可以发现：

桶里就只剩金板了！

所以可以得到初步的代码。

#### 先别慌，这道题有几个坑点。

- 金板不能被弹出！！！清零一次之后桶里都会增加一个金板，所以当金板的数量比桶容积还大时，题目无解，输出 Merry.

- 由上一条注意可知，桶中可容纳的最大容积必须先减掉在桶内的金色木板数再-1（将要放置的金色木板）。

- 上述一点可以通过放一个金色木板后桶的容积-1简化实现，到时候只用判定桶内容积-1即可。

- 一切完成后，桶内的零碎空间别忘记算上。

代码是写完了，但是想都想得到，这份纯贪心的代码一交上去肯定会TLE，所以我们可以优化优化。

一开始代码是这样的：

```cpp
//假设x,y,z都已经输入完成,x为金板数量，y为银板数量，z为桶内容积。
unsigned long long sum=(z-x+z-1)*x/2;
sum+=z;//还得加个z 
sum-=x;//剩余空间 
if(y>sum+z){//还是装不下就哦豁
	printf("Merry\n");
}
else printf("Renko\n");//进入诸神眷恋的幻想乡 
```

但是我们仔细研读研读，可以发现......

###### 这个处理桶内容积的循环一看就要耗掉很多时间

所以，让我们放开眼界看看关于桶内容积的数列。

可以发现，**这一串桶内容积的数值所构成的数列是等差数列**，而题目要求和。

所以，但凡学过小学数学的人，都想到一个公式：

$\dfrac{\left( \text{首项}+\text{末项} \right)\times \text{项数}}{2}$

所以，可以得到这样一种代码：

这里我就展示全部代码，不啰嗦。

```cpp
#include<bits/stdc++.h>
#define u_ll long long
#define renko printf("Renko\n");
#define merry printf("Merry\n");
using namespace std;
int main(){
	u_ll t;
	u_ll x,y,z;
	scanf("%lld",&t);
	for(int i=1;i<=t;i++){
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z){//金板大于桶容积 
			merry;
			continue;
		}else if(x+y<z){//金板银板加起来可以直接塞进去 
			renko;
			continue;
		}else{
			u_ll sum=(z-x+z-1)*x/2;
			sum+=z;//还得加个z 
			sum-=x;//剩余空间 
			if(y>sum+z){//还是装不下就哦豁
				printf("Merry\n");
			}
			else printf("Renko\n");//进入诸神眷恋的幻想乡 
		}
	} 

return 0;
}
```


---

## 作者：封禁用户 (赞：1)

因为金木板放入后便不能再弹出，所以第 $n$ 个金木板放入后最多只能弹出 $z-n$ 个木板，总共就最多只能弹出 $(x \times z - (x+1)\times \dfrac{x}{2})$ 块木板。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=140;
inline long long read()
{
    long long x=0,y=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        {
            y=-1;
        }
        ch=getchar( );
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*y;
}
inline void write(long long x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
    {
        write(x/10);
    }
    putchar(x%10+'0');
}
long long n,x,y,z,num;
int main()
{
    n=read();
    while(n--)
    {
        x=read();
        y=read();
        z=read();
        num=(x*z-(x*(x+1)>>1)+z-x);
        if(x>z)
        {
        	cout<<"Merry\n";
		}
		else if(y<=num)
		{
			cout<<"Renko\n";
		}
		else
		{
			cout<<"Merry\n";
		}
    }
    return 0;
}
```
Update：2022.05.17

改了一下快读快写没用 `long long` 的锅

---

## 作者：Asimplename (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8344)

### 题目大意

有一些金色木板和一些银色木板，还有一个容量为 $z$ 的容器，每次可以放入一个木板。如果放入一个金色木板，则会将容器内所有银色木板扔掉。问有没有一种方式使得所有木板都被放入过容器。

### 思路

可以考虑每次操作先将当前容量数减一块银色木板放入容器，再放入一个金色木板，丢弃所有放入的银色木板。这样是消耗银色木板的最好方式。由于金色木板不会被丢弃，所以共丢弃的银色木板数量为：

$(z-1)+(z-2)+(z-3)+...+(z-x)$

但由于放入 $x$ 块金色木板并丢弃所有放入过容器的银色木板后，还有 $z-x$ 个空位可以放木板，所以最后还要加上 $z-x$。

如果这个数大于等于 $y$，说明所有银色木板都进入过容器。如果金色木板数小于等于 $z$，说明所有金色木板也都可以进入过容器，输出 ``Renko``，否则输出 ``Merry``。



### Code

```cpp
#include<iostream>
#define int long long
using namespace std;
int T = 0;
int x = 0;
int y = 0;
int z = 0;
signed main () {
	cin >> T;
	for(int i = 1; i <= T; i ++){
		cin >> x >> y >> z;
		if(x <= z){
			if((z - 1 + z - x) * x / 2 + (z - x) >= y){//等差数列求和并判断
				cout << "Renko" << endl;
			}
			else{
				cout << "Merry" << endl;
			}
		} 
		else{
			cout << "Merry" << endl;
		}
	}
	return 0;
}

---

## 作者：Gaode_Sean (赞：0)

对于此题我们可以设 $s$ 表示最多能被金色木板消耗的银色木板的数目。

则 $s=\sum_{i=1}^x z-i=\frac{[(z-1)+(z-x)] \times x}{2}=\frac{(2z-x-1) \times x}{2}$

考虑到如果所有金色木板都被放入容器后可能还有一定的空间，则大小为 $z-x$。

这时候我们要将剩余空间的大小和银色木板剩余的个数 $y-s$ 进行比较，若后者更大，则失败（$z \leq x$ 也算作一种失败的情况），否则成功。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,x,y,z;
int main()
{
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld",&x,&y,&z);
		ll sum=(z-1+z-x)*x/2;
	    if(y-sum<=z-x&&x<=z) puts("Renko");
	    else puts("Merry");
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

这道题我们容易发现，金色木板是永远不会弹出的，因此，首先，如果发现 $x>z$，就可以直接输出 $\texttt{Merry}$ 了。

其次，我们观察一下最多可以放入的银色木板，容易发现最优策略如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/luafx6vv.png)

也就是：

$$\sum_{i=1}^{i\leq\min{z-1,x}}(z-i)+z-x$$
$$=\frac{(2z-x-1)\times x}{2}+z-x$$

只需比较它和 $y$ 的大小即可。

**代码：**

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define rep(i,x,y,z) for(int i=(x);i<=(y);i+=(z))
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;

signed main()
{
	ios::sync_with_stdio(false);

	int T;

	cin>>T;

	while(T--)
	{
		int x,y,z;

		cin>>x>>y>>z;

		if(((2*z-x-1)*(x)/2)+z-x<y)
			cout<<"Merry";
		else if(x>z)
			cout<<"Merry";
		else
			cout<<"Renko";

		cout<<endl;
	}

	return 0;
}

```


---

## 作者：GI录像机 (赞：0)

## 思路：
因为金色木板不会消失，又至少有一个银色的，所以金色木板数小于容量时才有解。

考虑贪心，放入每个金色木板时，最大化减少的银色木板个数，则若有 $z-1$ 个金色木板，将会减少 $1+2+3+\cdots+(z-1)$ 个木板，根据等差数列公式，就是 $\frac{(z-1)z}{2}$ 个木板。但由于实际的金色木板可能不够，所以我们实际消去的木板应减少 $1+2+3+\cdots+(z-x-1)$ 个。最后判断还未被消去的银木板与金木板的和是否超过容量即可。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
	int f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
int t = read();
signed main() {
	while (t--) {
		int x = read(), y = read(), z = read();
		if (z <= x) {
			puts("Merry");
			continue;
		}
		int k = z * (z - 1) / 2 - (z - x) * (z - x - 1) / 2;
		y -= k;
		if (y > z - x) {
			puts("Merry");
			continue;
		}
		puts("Renko");
	}
	return 0;
}
```


---

## 作者：nullqtr_pwp (赞：0)

## P8344 SOLUTION
注意到询问次数，容易看出这是一道结论题。月赛时首先算了几个样例，算了几个样例，结合题目得出结论。

**不妨考虑容器里能放入多少个木板**，注意到金色的木板进去之后就不会再出来，所以容量必须要大于等于金色木板的个数，所以一旦 $z>x$，可以直接得出无解（放不下所有的金色木板）；那么开始计算容器里能放入多少（银色）木板，考虑模拟过程。

每一步都可以简化成：原有 $z-i$ 块银色木板，$i-1$ 块金色木板，再放入一块金色木板，操作结果：剩下的有 $i$ 块金色木板。


那么 $i$ 取 $[1,x]$ 的所有数累加便是容器的（银色木板）容量，如果容量大于等于银色木板的个数 $y$，那么就是可行的。**注意边界条件**，放入最后一块木板时，还剩下 $z-x$ 块空位，这个 $z-x$ 也是要累加进容量的。

综上，银色木板容量为 $\sum_{i=1}^{x} (z-i)+(z-x)$，化简得容量为 $\dfrac{x(2z-x+1)}{2}+(z-x)$


代码细节：**所有计算都注意开 long long！！！** $x,y,z$ 的数据范围很大。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,x,z,y;
inline long long read(){
    char c=getchar();long long x=0;
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x;
}
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z) puts("Merry");
		else if((x*z-(x*(x+1)>>1)+z-x)<y) puts("Merry");
		else puts("Renko");
	} 
}
```

最近的月赛真的越来越考思维了。。


---

## 作者：L11day (赞：0)

## 思路
首先，因为金色木板放入是不会再丢掉的，所以当 $x$ 大于 $z$ 时，特判无解：
```cpp
if(x>z){
	cout<<"Merry"<<"\n";
	return 0;
}
```


然后因为每个木板只需要放一次。且每放一个金色木板，就会丢掉容器内所有银色木板。因此，最多可放入的银色木板 $a$ 用代码表示为：
```cpp
a=0;//初始化a
for(int i=1;i<=x;i++){
	a+=(z-i);
}
```
但因 $x$ 数据大会导致超时，所以可用等差数列将循环表示为 `a=(2*z-1-x)*x/2;`
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,x,y,z,a;
long long zh(long long w){//将负数转为0
	if(w<0){
		return 0;
	}
	else{
		return w;
	}
}
long long n(){
	cin>>x>>y>>z;
	if(x>z){//特判
		cout<<"Merry"<<"\n";
		return 0;
	}
	else{ 
		a=(2*z-1-x)*x/2;//求最多可放入的银色木板
		if(zh(y-a)+x>z){//求剩下的银色木板（如果有）加金色木板是否能装入容器
			cout<<"Merry"<<"\n";
			return 0;
		}
		else{
			cout<<"Renko"<<"\n";
			return 0;		
		}
	}
}
int main(){
	cin>>T;
	for(long long ii=0;ii<T;ii++){
		n();
	}
	return 0;
}
```



---

## 作者：Think (赞：0)

看难度就明白这是道签到题。
## 1.思路
题目要求我们将所有板子 **放过** 就行，但放入金就会清空银。  
所以我们要在放金之前 **尽可能多放银**。  
这就是标签所说的贪心。
## 2.解法
当金放不完时，肯定无解。  
由以上思路可得：  
放银的数目依次为 $z-1$、$z-2$ $...$ $z-x$。  
由等差数列公式：  
最多可以放 $\frac{x*(z-x+z-1)}{2}$ 个银，令该式子为 $\sigma$。  
在 **保证金放完的时**，我们得到如下几种情况：  
- $x$ 恰好满足放入所有 $y$ 后 $x$ 被清空。
- $x$ 恰好满足放入所有 $y$ 后 $x$ 被清空不足。
- $x$ 恰好满足放入所有 $y$ 后 $x$ 被清空有余。

而这三种情况依次对应 $=\sigma$、$<\sigma$、$>\sigma$ 的情况。  
分别为 $case1\ $ $case2\ $ $case3\ $。    
$case1$： 显然满足要求。  
$case2$： 翻译过来就是金放完了银有剩，则只需要剩下的银数量 **小于等于** 可放位置的数量就行了。  
$case3$： 银放完了金有剩，具体剩多少呢？  
我们令此时消耗的金数量为 $x_0$ 则将 $x_0$ 带入 $\sigma$ 式。   
整理一下得到关于 $x_0$ 的式子：  
$x_0^2-(2z-1)x_0+2y=0$。  
得到：$x_0=\lfloor\frac{2z-1+\sqrt[]{(2z-1)^2-8y}}{2}\rfloor$。  
同 $case2$ 理即可求解。
## 3.Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,x,y,z;
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld",&x,&y,&z);
		if(x>z){printf("Merry\n");continue;}
		ll judge=x*(2*z-x-1)/2;
		if(judge==y){printf("Renko\n");continue;}
		if(judge<y&&(y-judge<=z-x)){printf("Renko\n");continue;}
		int x0=(2*z-1+sqrt((2*z-1)*(2*z-1)-8*y))/2;
		if(judge>y&&(x-x0)<=z){printf("Renko\n");continue;}
		printf("Merry\n");
	}
	return 0;
} 
```



---

## 作者：lyhqwq (赞：0)

### 思路

数据范围告诉我们，这个题显然是一个结论题。

我们考虑贪心，每次将容器放到只差一个木板，之后再放一个金色木板把容器里的银色木板清空。如果金色木板用完后还有银色木板，就继续像容器里放，知道放完为止，如果放不完就是无解

金色木板用完时，显然我们放了

$\sum_{i=1}^x (z-i)=\frac{(2\times z-1-x)\times x}{2}=x\times z-\frac{x}{2}-\frac{x^2}{2}$ 个木板

金色木板用完后，我们继续放了

$z-x$ 个木板

将两部分加起来即可

### AC code

注意开ull，还有注意 $x$ 为奇数的情况

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define il inline
using namespace std;
ull t;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%llu",&t);
	while(t--){
		ull x,y,z;
		scanf("%llu%llu%llu",&x,&y,&z);
		if(x>z){
			puts("Merry");
			continue;
		}
		ull ans=x*z-x/2-(x*x)/2+z-x;
		if(x%2!=0) ans-=1ull;//x为奇数时，因为向下取整所以要加一
		if(ans>=y) puts("Renko");
		else puts("Merry");
	}
	return 0;
}

```


---

## 作者：Awhale_tauntingcat (赞：0)

#### 题意分析

本题要求判断是否能够使所有木板都被放入 **过** 容器中。

首先，当 $c\geq x+y$ 时，直接输出 ```Renko``` 即可，因为容器可以直接放入所有的木板。

当 $a\ge c$ 时，直接输出 ```Merry``` 即可，因为金木板不会消失，所以容器不可能容纳所有金木板。

对于一般的情况，我们可以用贪心的思想来做：

首先，将 $z-1$ 个银木板放入容器中，再放入一个金木板，丢弃放入的银木板，直到所有金木板都被放进容器中。

上述操作结束后，统计剩余的银木板，统计公式为： $ y_\text{剩余}=y-\sum\limits_{n=1}^{x}(z-n)$

展开： $y_\text{剩余}= xz-\frac{x(1+x)}{2}$ 

然后，如果金木板和剩余银木板数量之和小于等于 $z$ ，输出 ```Renko``` ，
否则输出 ```Merry```  。

记得有多组数据。

#### 源码

```cpp
#include<iostream>
#include<queue>
using namespace std;
long long t,x,z,y;
void T1(long long a,long long b,long long c){
    if(c>=a+b) {cout<<"Renko"<<endl;return;}//特判
    if(a>=c){cout<<"Merry"<<endl;return;}//特判
    b-=((a*c)-(a*(a+1))/2);//将银木板数量减少
    if(a+b<=c){
        cout<<"Renko"<<endl;
        return;
    }
    else{
        cout<<"Merry"<<endl;
        return;
    }
}
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        cin>>x>>y>>z;
        T1(x,y,z);
    }
    return 0;
}
```



---


# [LSOT-1] 暴龙的土豆

## 题目背景

暴龙爱吃土豆。

## 题目描述

给定一个正整数 $n$。

每次操作可以选两个素数 $y,z$，其中要求 $z$ 是奇素数。

令 $x=y^z$，如果 $x$ 能除尽 $n$ 则计为一次有效操作，$n$ 变为 $\dfrac nx$。

现在需要你回答，对于 $n$ 最多能够进行多少次有效操作。

## 说明/提示

【样例解释】

对于样例一：$16$ 可以变成 $2^3 \times 2$，可以进行一次操作。但是 $9$ 只能变成 $3^2$，所以不能进行操作。

【数据范围】

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(10 pts)：}1 \le\ n\le 10^2，1 \le\ T\le 10^2$；
- $\texttt{Subtask 2(20 pts)：}1 \le\ n\le 10^6，1 \le\ T\le 10^2$；
- $\texttt{Subtask 3(30 pts)：}1 \le\ n\le 10^{12}，1 \le\ T\le 10^2$；
- $\texttt{Subtask 4(40 pts)：}$无特殊限制。

对于 $100\%$ 的数据，满足 $1\le n\le 10^{18}$，$1\le T\le 10^2$。

## 样例 #1

### 输入

```
2
16
9```

### 输出

```
1
0```

## 样例 #2

### 输入

```
2
1327104
3623878656000```

### 输出

```
5
12```

# 题解

## 作者：LuomuQDM (赞：15)

### 题意

每组数据给出一个 $n$（`long long` 范围内），重复将 $n$ 整除一个可以表示为 $y^z$ 的数（$x,z$ 为质数且 $z\neq 2$），直到无法再找到这样的数。求出最多能整除多少个这样的数。

### 思路

为了使整除的个数多，就需要使 $z$ 尽量小（这样每次 $n$ 除去的数 $y^z$ 就会保证最小，可供整除操作的次数最大）。

因为符合条件的最小 $z=3$，所以我们只需要枚举质数 $y$，并判断 $y^3$ 是不是 $n$ 的因数，若是则循环把 $n$ 除去这个数直到 $n$ 不再是这个数的倍数即可。

当我们将 $n$ 因数中包含的一个质数（不妨设其为 $y_i$）的三次方除尽后，$n$ 一定不再会是 $(ky_i)^3$ 的倍数（其中 $k$ 为大于 $1$ 的正整数），所以我们只要从 $2$ 开始枚举 $y$，每次 $y$ 加 $1$ 就行了，这样就免去了筛素数的步骤。

注：本题思路较为简单，就不列出公式来表达意义了，以免混淆各位的思维。

### 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t,n,ans;
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		ans=0;
		for(ll i=2;i*i*i<=n;i++){
			while(n%(i*i*i)==0)n/=i*i*i,ans++;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：良心WA题人 (赞：7)

首先，我们注意，$z$ 取 $3$ 一定是最优的。所以我们强行让 $z=3$ 。

现在思考如何计算答案。因为 $y^z$ 是 $n$ 的一个因子，所以必然小于 $n$ ，那么 $y$ 就不能大于 $\sqrt[3]{n}$ ，时间复杂度在要求范围内，直接枚举 $y$ 即可。

std：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1000003;
long long pri[N],P;
bool v[N];
void W()
{
	for(int i=2;i<N;i++)
	{
		if(!v[i])pri[++P]=i;
		for(int j=1;j<=P&&i<N/pri[j];j++)
		{
			v[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
int main()
{
	int T;cin>>T;W();
	while(T--)
	{
		long long n,s=0;cin>>n;
		for(int i=1;i<=P;i++)
		{
			long long x=pri[i],k=0;
			if(x*x*x>n)break;
			while(n%x==0)n/=x,k++;
			s+=k/3;
		}
		cout<<s<<endl;
	}
	return 0;
}
```

---

## 作者：BotDand (赞：5)

# $\text{Problems}$

给定一个正整数 $n$。

每次操作可以选两个素数 $y,z$，其中要求 $z$ 是奇素数。

令 $x=y^z$，如果 $x$ 能除尽 $n$ 则计为一次有效操作，$n$ 变为 $\dfrac nx$。

现在需要你回答，对于 $n$ 最多能够进行多少次有效操作。

# $\text{Answer}$

因为要求 $z$ 是奇素数，且操作数要最大，所以 $z$ 为 $3$。

接下来可以将 $n$ 分解质因数，令 $n=a_{1}^{b_{1}}\times a_{2}^{b_{2}}\times \cdots\times a_{k}^{b_{k}}$。

答案即为 $\left\lfloor\dfrac{b_{1}}{3}\right\rfloor+\left\lfloor\dfrac{b_{2}}{3}\right\rfloor+\cdots + \left\lfloor\dfrac{b_{k}}{3}\right\rfloor$。

但这样会 TLE。

考虑每次除以 $a_{x}^{3}$ 即可优化。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n;
void work()
{
	cin>>n;
	int x=2,ans=0;
	while(n>=x*x*x)
	{
		while(n%(x*x*x)==0) n/=(x*x*x),ans++;
		x++;
	}
	cout<<ans<<"\n";
}
signed main()
{
	cin>>t;
	while(t--) work();
	return 0;
}
```


---

## 作者：lilong (赞：2)

题目要求了 $z$ 为奇素数，而为了进行更多次的有效操作，很容易想到直接让 $z=3$。这样做，对于原题中 $1 \le n \le 10^{18}$，最大的 $\sqrt[3]{n}$ 不会超过 $10^6$，完全可以在 $O(n)$ 的时间复杂度内解决。

于是思路便产生了：$y$ 从 $2$ 开始枚举，判断此时的 $n$ 是否为 $y^3$ 的倍数，是则不断用 $y^3$ 除 $n$，统计次数，直到 $n$ 不为 $y^3$ 的倍数。当 $y^3 > n$ 时无法有效操作，结束枚举并输出。

题目中 $y$ 被要求为素数，但对程序没有影响，因为任何一个合数都是由比它小的质因子构成的。证明方法十分容易，这里不再详解。

程序实现十分简单，代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		long long n,k=2,ans=0;
		cin>>n;
		while(k*k*k<=n)
		{
			while(n%(k*k*k)==0)
			{
				ans++;
				n/=(k*k*k);
			} 
			k++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：qczrz6v4nhp6u (赞：2)

~~题外话：蒟蒻赛场上筛素数范围开到20005000，但还是3.5s擦边过了~~
## 题目描述
给定一个正整数 $n$。
每次操作可以选两个素数 $y$ , $z$，其中要求 $z$ 是奇素数。

令 $x=y^z$，如果 $x$ 能除尽 $n$ 则计为一次有效操作，$n$ 变为 $\dfrac n x$。

现在需要你回答，对于 $n$ 最多能够进行多少次有效操作。
### 换一种方法理解：
将 $n$ 分解质因数得 $n={a_1}^{b_1}\times {a_2}^{b_2}\times ···\times {a_p}^{b_p}$ 的结果中，令 $z$ 为奇素数，找出最多的**不重叠**的 $x={a_i}^z$ 。
## 思路
因为是要求最多的 $x$ 满足 $x={a_i}^z$ ，~~根据常识~~可得 $z$ 要尽量小

所以 $z$ 要等于最小的**奇素数**——

那么 $z=3$ 。

记 $k$ 为能找出的最多的**不重叠**的 $x$ 的个数，那么我们有  
$k=\big\lfloor{\dfrac {b_1} 3}\big\rfloor + \big\lfloor{\dfrac {b_2} 3}\big\rfloor+···+\big\lfloor{\dfrac {b_p} 3}\big\rfloor$

套上线性筛素数的模板，就能愉快的~~水~~拿下这题了

## 赛场 Code :
```
#include<bits/stdc++.h>
#define int long long//一定要开long long!
using namespace std;
int prime[1000003],pr;
bitset<1000003>v;
void init(){//线性预处理素数
    pr=0;
    for(int i=2;i<1000003;i++){
        if(v[i]==0)prime[++pr]=i;
        for(int j=1;j<=pr&&i*prime[j]<1000003;j++){
            v[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
signed main(){
    init();
    int t;
    scanf("%lld",&t);
    while(t--){
        int n;
        scanf("%lld",&n);
        int ans=0;
        for(int i=1;n;i++){
            if(prime[i]*prime[i]*prime[i]>n)break;
            int cnt=0;
            while(n%prime[i]==0)cnt++,n/=prime[i];
            ans+=cnt/3;
        }
        printf("%lld\n",ans);
    }
}
```
-----------
但是，我们还可以再优化一下:

$n$ 可以每次除以 ${prime_i}^3$。
注意到 ${prime_i}^3$ 出现了3次，可以考虑新开一个变量储存${prime_i}^3$。
```
for(int i=1;n;i++){
    int x=prime[i]*prime[i]*prime[i];
    if(x>n)break;
    while(n%x==0)ans++,n/=x;
}
```
## 最终 Code:
```
#include<bits/stdc++.h>
#define int long long//一定要开long long!
using namespace std;
int prime[1000003],pr;
bitset<1000003>v;
void init(){//线性预处理素数
    pr=0;
    for(int i=2;i<1000003;i++){
        if(v[i]==0)prime[++pr]=i;
        for(int j=1;j<=pr&&i*prime[j]<1000003;j++){
            v[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
signed main(){
    init();
    int t;
    scanf("%lld",&t);
    while(t--){
        int n;
        scanf("%lld",&n);
        int ans=0;
        for(int i=1;n;i++){
            int x=prime[i]*prime[i]*prime[i];
            if(x>n)break;
            while(n%x==0)ans++,n/=x;
        }
        printf("%lld\n",ans);
    }
}
```
但是后来看[一楼dalao的题解](https://www.luogu.com.cn/blog/BotDand/solution-p8448)发现还有一种做法：
直接在大于等于2的自然数范围内枚举 $y$！！

下面来证明这种做法的正确性。

将 $n$ 分解质因数，得 $n={a_1}^{b_1}\times {a_2}^{b_2}\times ···\times {a_p}^{b_p}$

若 $y$ 是素数，根据上面的结论，显然成立。

若 $y$ 是合数，则将$y$分解质因数：$y={a_1}^{c_1}\times {a_2}^{c_2}\times···\times {a_p}^{c_p}$

此时 $a_i$ 为素数且 $a_i<y$。

那么 $a_i$ 一定在 $y$ 之前被筛过。  

也就是说此时 $b_i<3$ ，
那么 $y^3∤n$ 。

此时ans不会增加，
所以正确。

再贴一下这个思路的代码：
```
#include<bits/stdc++.h>
#define int long long//一定要开long long!
using namespace std;
int t,n;
signed main(){
    scanf("%lld",&t);
    while(t--){
        scanf("%lld",&n);
        int y=2,ans=0,x=8;//意义同题目
        for(;x<=n;y++){
            x=y*y*y;
            while(n%x==0)ans++,n/=x;
        }
        printf("%lld\n",ans);
    }
}
```
~~蒟蒻的第一篇题解~~

---

## 作者：ztntonny (赞：0)

## 题意
给一个数 $n$，问能用几个形如 $y^z$ 的数整除 $n$（$y$，$z$ 均为质数，$z$ 为奇数）。
## 思路
本人的代码跑出 $12ms$，是最快的了，首先打一个小质数表，本人试过 $13$ 个刚好，然后每次进来数后双层暴力嵌套循环枚举 $y^z$，加上剪枝即可。因为最小的奇数质数为 $3$，所以最多到 $\sqrt[3]{n}$。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n[13]={2,3,5,7,11,13,17,19,23,29,31,37,41};//质数表
int main()
{
	ios::sync_with_stdio(false);//加速输入
	long long a , b , h , s , i;
	cin >> a;
	while ( cin >> b )
	{
		h = 0;//一定初始化计数器
		for ( i = 0; i < 13 && n[i] * n[i] * n[i] <= b; i++ )//剪枝（因为最小的奇质数为3，所以到三次根号b就停）
		{
			s = 0;
			while ( b % n[i] == 0 )//暴力枚举整除次数
			{
				b /= n[i];
				s++;
			}
			h += s / 3;//因为最小的奇质数为3，所以加上除以三就行了
		}
		cout << h << endl;
	}
}
```


---

## 作者：Joker_1212 (赞：0)

# P8448 题解

[原题传送门](/problem/P8448)

由于 $z$ 是奇素数，因此 $z$ 最小为 $3$，由于 $x = y^z$ 且 $x \leq n \leq 10^{18}$，所以 $y$ 的范围是 $y \leq \sqrt[3]{10^{18}} = 10^6$。因此只需要从 $2$ 开始枚举 $y$，枚举到 $10^6$ 即可。

对于每一次操作，用 $y$ 一直除 $n$，直到 $y \nmid n$ 为止，此时除的次数 $m$ 就是 $n$ 中质因子 $y$ 的数目（如果 $y$ 不是质数，那么 $y$ 的质因子会在 $y$ 之前将 $n$ 中所有的 $y$ 的质因子除掉，在操作开始前即有 $y \nmid n$，$m = 0$）。因为要求操作次数尽量多，而在 $z = 3$ 时操作次数最大，所以答案加  $\left\lfloor \frac{m}{3}\right\rfloor$ 即可。
 
AC 代码：

```cpp
// read() -> 快读；write() -> 快写
int main()
{
    int t;
    read(t);
    while (t--)
    {
        ll n, ans = 0;
        read(n);
        // 当 n == 1 时，n 已被彻底分解，不用再分解了
        for (int i = 2; n != 1 && i < 1000000; ++i)
        {
            // 代表 i 不是 n 的质因数
            if (n % i != 0)
                continue;
            ll cnt = 0;
            while (n % i == 0) // 一直除，直到除不动为止
            {
                n /= i;
                ++cnt;
            }
            ans += cnt / 3;
        }
        write(ans, 10);
    }
    return 0;
}

---

## 作者：newbeeglass (赞：0)

题目中说 $x=y^{z}$，而 $z$ 又要求是奇素数，既然要使拆分次数最大，那么在 $y$ 相同时，$z$ 要最小，举个例子，$y^{3}$ 一定包含在 $y^{5}$ 之内，所以默认 $z$ 为 $3$ 就行了。

接下来就比较暴力了，用欧拉筛把 $2$ 到 $10^{6}$ 的素数全筛一遍，然后计算它们的立方，从小到大存到数组 ```a``` 中，预处理完成。

然后对输进来的数进行处理，利用数组 ```a``` 中的数，从小到大枚举，如果除得尽就除，统计除的次数，除到最后所有数都除不尽或者这个数被除成 $1$ 为止，所以外面要开一层死循环，最后 ```break```。
### 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
int T,t;
bool b[1000005];
long long a[10000005];
void prime(){
	for(int i=2;i<=1e6;i++){
		if(!b[i]){
			for(int j=i*2;j<=1e6;j+=i){
				b[j]=1;
			}
		}
	}
	t=0;
	for(int i=2;i<=1e6;i++){
		if(!b[i]){
			t++;
			a[t]=i*i*i;
		}
	}
}
int ans;
int main(){
	prime();
	cin>>T;
	while(T--){
		ans=0;
		cin>>n;
		bool flag=1;
		while(flag){
			for(int i=1;i<=t;i++){
				if(n%a[i]==0){
					ans++;
					n/=a[i];
					break;
				}
				if(a[i]>n || i==t){
					flag=0;
					break;
				}
			}
			if(!flag){
				break;
			}
		}
		cout<<ans<<endl;
	}
}
```


---

## 作者：Jeremiahy (赞：0)

# 分析

不难发现 $z$ 取 $3$ 一定最优，因为数字 $n$ 含有质因子 $y$，每次操作相当于去除若干个 $y$，当然是取得越少，操作次数越多了。因为 $z$ 是奇素数，所以 $3$ 是最小的符合要求的数。

可以筛一下素数，筛出 $10^6$ 以内的素数，然后再枚举每个素数，看是否可以进行一次操作，累加到答案中。

另外，其实可以直接使用前 $13$ 个素数；或者不筛素数，直接从 $2$ 开始进行枚举操作并除去，这其中暗含了筛素数的思想，就不用费劲去筛素数了。

下面放一个吃力~~不讨好~~的代码。

##### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
bool isPrime[1000005];
int Prime[1000005], cnt, t, n, ans;
void GetPrime() {//线性筛，然而没必要
	isPrime[1] = 1;
	for (register int i = 2; i <= 1000005; i++) {
		if (isPrime[i] == 0)
			Prime[++cnt] = i;
		for(register int j = 1; j <= cnt && i * Prime[j] <= 1000005; j++) {
			isPrime[i * Prime[j]] = 1;
			if(i % Prime[j] == 0)
				break;
		}
	}
}
signed main() {
	cin >> t;
	GetPrime();
	while (t--) {
		ans = 0;//初始化
		cin >> n;
		for(register int i = 1; i <= cnt; i++) {
			int x = Prime[i], k = 0;
			if (x * x * x > n)//超出就停止
				break;
			while (n % x == 0 && n)
				n /= x, k++;//除去并累加次数
			ans += k / 3;//计算答案
		}
		cout << ans << '\n';
	}
	return 0;
}
```


---

## 作者：sixrc (赞：0)

比 std 相对暴力一点，但时间复杂度是允许的。

首先我们发现 $z \ge 3$，也就是 $y \le 10^6$。所以我们只需要处理出 $[2,10^6]$ 中的质数。

但脑抽没发现 $z=3$ 一定最优，接下来就一步步推出正解。

由于 $z$ 是奇质数，所以我们处理出了 $10^6$ 以内的质数后，可以暴力处理出 $y^z$ 的所有可能取值。也就是说，满足条件 $y$ 为 $10^6$ 以内的质数、$z$ 为奇质数、$y^z \le 10^{18}$ 的 $y^z$ 取值。对于每一个 $y$，将其从小到大放入数组内。

输出一下发现这样的 $y^z$ 取值只有八万多个。

于是询问的时候就暴力除一下，能除尽就尽量除。

此时我们发现这个解法已经和发现 $z=3$ 的性质本质相同，相当于把结论证明了一遍。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1000000;
int n, q, k, p, cnt, ans, ci, jud[1000010], su[1000010], a[1000010];
signed main(){
	memset(jud, 1, sizeof(jud));
	jud[1] = 0;
	for(int i=2; i<=maxn; i++){
		if(jud[i]) su[++cnt] = i; 
		for(int j=1; j<=cnt && i*su[j]<=maxn; j++){
			jud[i*su[j]] = 0;
			if(i % su[j] == 0) break;
		}
	}
	for (int i=1; i<=cnt; i++){
		int tmp = su[i];
		tmp = tmp * tmp * tmp;
		ci = 3;
		a[++p] = tmp;
		for (;;){
			if (tmp > 1e18 / su[i]) break;
			tmp = tmp * su[i];
			ci ++;
			if (jud[ci]) a[++p] = tmp;
		}
	}
	scanf ("%lld", &q);
	while (q --){
		scanf ("%lld", &n);
		ans = 0;
		for (int i=1; i<=p; i++){
			while (n % a[i] == 0){
				n /= a[i], ans ++;
			}
		}
		printf ("%lld\n", ans);
	}
	return 0;
}
```

---


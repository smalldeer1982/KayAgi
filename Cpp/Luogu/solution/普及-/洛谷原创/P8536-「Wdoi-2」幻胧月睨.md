# 「Wdoi-2」幻胧月睨

## 题目背景

**Problem Number:** $\textit{39}$

**背景与题目无关，选手可以直接看下面的「简要题意」。**

那是在竹取物语之后的故事了，幻想乡距离与现实隔绝也已经过去了百年时光。

地上人向月球发起了侵略战争之后，一只名叫**铃仙**的月兔舍弃了同伴，死里逃生，逃到了在幻想乡内的永远亭，来到了辉夜与永琳的身边，生活得安稳而舒适。

又过了数十年，铃仙接收到了来自月球的使唤，被要求强制返回月球。辉夜与永琳商量了下，决定不将铃仙交还予月球。但为了避免造成麻烦，辉夜与永琳决定将满月消失在地上，只留下一轮虚假的月亮。

-----

为了方便调查异变，八云紫运用自己的能力，将整个幻想乡变成了永夜。

被穿梭回异变发生当时的四组主角，共八人。除了依然留有记忆，可以来回穿梭在虚与实的境界的八云紫之外，其他的人缺乏了记忆，重新开始踏上夺回幻想乡的满月的征途。

在慧音的指引之下，她们来到了迷途竹林，在她们的面前，是一只名叫铃仙的月兔。

## 题目描述

### 简要题意

给定一个长度为 $n$ 的 01 串 $b$，要求构造一个 $n$ 阶排列 $a$，满足，对于 $a_i(2\le i\le n)$，记 $m_i=\max_{j=1}^{i-1}\{a_j\}$，则：
  - 若 $b_i=1$，则 $a_i>m_i$;
  - 否则 $a_i<m_i$。

可以证明，总存在一个数列 $a$ 满足以上条件。

**如果有多组解，输出任意一种。**

同时注意到 $b_1$ 的取值是任意的，对数列 $a$ 没有影响。

### 原始题意

铃仙拥有操纵狂气程度的能力，换而言之，就是操纵物体的波长、振幅以及相位。这种能力为主角制造了种种障碍——例如操纵光波，会让弹幕虚虚实实，甚至会出现虚假的自我，对躲避弹幕造成极大的干扰。

以符卡「幻胧月睨」为例。「幻胧月睨」中一共有 $n$ 个弹幕，每个弹幕都会有一个相位，相位非 $0$ 即 $1$。这些弹幕的相位会构成一个长度为 $n$ 的数列 $\{b_i\}$。

铃仙会操纵这些弹幕的相位，将其变得千奇百怪。具体而言，被操纵了之后的弹幕的相位是一个长度为 $n$ 的**排列** $\{a_i\}$，即 $1 \sim n$ 的数字都会**不重不漏**地出现在这个序列之中。

为了加大主角躲避弹幕的难度，铃仙会设置一个阈值。对于每一个元素 $a_i$，阈值是其**前缀**的**最大**值，即 $a_1,a_2,\dots,a_{i-1}$ 中的最大值。若原来的第 $i$ 个弹幕的相位为 $1$，则被操纵后的弹幕的相位要**大于**这个阈值，否则被操纵后的弹幕的相位要**小于**这个阈值。

显然的是，根据铃仙的操纵规则，无论原本的弹幕的相位如何，都是存在可能的操纵方案的。由于主角们失去了记忆，而找回月亮的时间已经所剩不多了，而且弹幕战对时间的把控要求极高。她们找到了你，希望你能够对铃仙原本的弹幕相位，给出**任意一种**操作后的弹幕相位，来为她们的闪避弹幕进行准备。

## 说明/提示

### 样例解释

- 对于数据 $1$，显然 $a_2>1,a_3>2$。
- 对于数据 $2$，显然 $a_2<2,a_3>2$。
- 对于数据 $3$，显然 $a_2>1,a_3<3,a_4>3$。\
  注意到 $a=\{2,3,1,4\}$ 同样满足要求。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 10 & - & - & 5\\\hline
2 & 10^5 & \textbf{A} & - & 5 \\\hline
3 & 10^5 & \textbf{B} & - & 20 \\\hline
4 & 10^5 & - & 1,2,3 &70 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $b_i$ 都相等。
- **特殊性质** $\textbf{B}$：存在整数 $p\in[2,n]$，使得对于 $1\le i<p$，有 $b_i=1$；对于 $n\ge i\ge p$，有 $b_i=0$。

对于全部数据，满足 $1\le T\le 10^4$，$1\le n\le 10^5$，$\forall i\in[1,n],b_i\in\{0,1\}$。

保证单个测试点内 $\sum n\le 5\times 10^5$。

## 样例 #1

### 输入

```
3
3
111
3
101
4
0101```

### 输出

```
1 2 3
2 1 3
1 3 2 4```

# 题解

## 作者：Larryyu (赞：9)

## _Description_
给你一个01字符串 $s$ ， $s_i=1$ 时， $\forall 1\le j\le i-1,a_i>a_j$ , $s_i =0$ 时， $a_i$ 不满足上述条件，求任一满足条件的 $a$ 数列。
## _Solution_
设字符串 $s$ 中有 $x$ 个0, $y$ 个1，则 $\forall s_i=1,a_i=n-i+1$ ，即**升序**，既能保证 $a_i>a_j$ ，也能保证 $a_{i_1}<a_{i_2}$ ，再来看
 $s_i=0$ 的情况，明显剩下的 $a_j=[1,x]$ ，但是为**降序**，否则当 $s_1 =0,s_2=0$ 时， 可能$a_1=1,a_2=2$，实际上 $s_1=0,s_2=1$ 造成冲突 。代码很好实现。
## _Code_
```cpp
int t;
int n;
int a[100100];
string s;
int main(){
    cin>>t;
    while(t--){
        int cnt=0,tot=0;
        cin>>n;
        cin>>s;
        for(int i=1;i<=n;i++){
            if(s[i-1]=='1') tot++;
          //  cout<<a[i];
        }
       	tot=n-tot+1; //不要忘了加一
        cnt=tot-1;
        for(int i=1;i<=n;i++){
            if(s[i-1]=='0'){
                cout<<cnt<<" ";
                cnt--;//递减
            }
            else{
                cout<<tot<<" ";
                tot++;//递增
            }
        }
        cout<<endl;
    }
    return 0;
}
```
#### 完结撒花！！

---

## 作者：chen_zhe (赞：5)

根据题意当 $b_i=0$，则 $a_i$ 小于前缀最大值；当 $b_i=1$，则 $a_i$ 大于前缀最大值。那么我们不妨分开来构造，让 $b_i=0$ 的自成一系，让 $b_i=1$ 的自成一系。

具体而言，我们可以让对应 $b_i=0$ 的所有 $a_i$ 构成一个差为 $1$ 的单调递减等差数列，首项是为 $0$ 的 $b_i$ 的个数 $\mathrm{cnt_0}$，即 $\mathrm{cnt_0}=\sum \limits_{i=1}^n [b_i==0]$，让对应 $b_i=1$ 的所有 $a_i$ 构成一个差为 $1$ 的单调递增等差数列，首项为 $\mathrm{cnt_0}+1$。

这样构造为什么是正确的呢？这样构造满足了对于所有项，其前缀最大值是前缀中最后一个 $b_i=1$ 的位置所填上的 $a_i$，此时由于要求 $b_i=1$ 填上单调递增的等差数列，因此满足 $\forall b_i=1, a_i>\max \limits_{j=1}^{i-1} a_j$。又由于当 $b_1=1$ 时，$b_i=1$ 的所有 $a_i$ 构成的等差数列首项为 $\mathrm{cnt_0}+1$，大于 $\mathrm{cnt_0}$，而 $b_i=0$ 的所有 $a_i$ 构成的等差数列单调递减，从而满足 $\forall b_i=0, a_i<\max \limits_{j=1}^{i-1} a_j$；而当 $b_1=0$ 时，前缀最大值是不小于 $b_1=\mathrm{cnt_0}$ 的，而 $b_i=0$ 的所有 $a_i$ 构成的等差数列单调递减，因此满足要求。

而可以证明的是这样产生的数列 $a_i$ 必然是 $1 \sim n$ 的一个排列，这是因为 $b_i=0$ 的个数是 $\mathrm{cnt_0}$，由此构造出一个长度为 $\mathrm{cnt_0}$ 的公差为 $1$ 的等差数列 $\mathrm{cnt_0},\mathrm{cnt_0}-1,\dots,1$；而对 $b_i=1$ 来说也类似，末项是 $\mathrm{cnt_0}+n-\mathrm{cnt_0}$，构造出来的数列就是 $\mathrm{cnt_0}+1,\mathrm{cnt_0}+2,\dots,n$。它们交叉编织起来，从而是一个 $1 \sim n$ 的排列。

参考代码如下：

```cpp
#include <iostream>

using namespace std;

char ch[100050];

int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int n;
		cin >> n >> (ch+1);
		int cnt0=0,cnt1=0;
		for (int i=1;i<=n;i++)
			cnt0+=(ch[i]=='0');
		cnt1=cnt0+1;
		for (int i=1;i<=n;i++)
		{
			if (ch[i]=='0')
				cout << (cnt0--) << " ";
			else
				cout << (cnt1++) << " ";
		}
		cout << endl;
	}
}
```

---

## 作者：McIron233 (赞：4)

提供一个简单的做法。

假定有一个双向队列，队头到队尾从 $1$ 到 $n$ 赋值，**倒序**遍历排列 $b$，若 $b_{i}$ 为 $1$ 则取队尾元素到排列 $a$ 中并移除队尾元素，反之则取队头元素并移除即可。

下面是证明：

假定已经倒序遍历到第 $k$ 个元素，令 $m_k=\max_{j=1}^{k-1}\{a_j\}$，若 $a_{k}$ 已经取值，则按上面的做法，剩下的所有可选元素最大为 $n-k$，而 $a_{k} = n-k+1$，所以 $m_{k-1} = n-k+1$，此时以 $b_{k}$ 的值分类两种情况：

- 当 $b_{k} = 1$ 时，因为 $a_{k} \ge m_{k-1}$，所以 $a_{k}$ 符合题意

- 当 $b_{k} = 0$ 时，因为 $1 \leq m_{k-1}$，所以 $a_{k}$ 同样符合题意

得证，故此做法正确。

```cpp
#include<bits/stdc++.h>
#define int long long
#define I inline
#define N 100005
#define modd 32767
using namespace std;
int t,a[N];
char ch[N];
signed main(){
	cin>>t;
	while(t--){
		int n;cin>>n;
		int hed=1,til=n;
		for(int i=1;i<=n;i++)cin>>ch[i];
		for(int i=n;i>=1;i--){
			if(ch[i]=='1')a[i]=til--;
			else a[i]=hed++;
		}
		for(int i=1;i<=n;i++)cout<<a[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：joyslog (赞：0)

##  「Wdoi-2」幻胧月睨

[洛谷 P8536](https://www.luogu.com.cn/problem/P8536)


给定长度为 $n$ 的 01 串 $S$，求一个 $n$ 阶排列 $A$，它要满足：记 $m_i$ 为 $A_1\dots A_{i-1}$ 中的最大值，则

$$
\begin{cases}
A_i > m_i \quad (S_i=1) \\
A_i < m_i \quad (S_i=0) \\
\end{cases}
$$

***\[SPJ\]*** 输出任意一种解。

### 题解

我们考虑如何将排列 $A = \{1, 2, 3, \dots, n\}$ 转化为合法的答案。

由于这是一个**严格单调递增**的排列，我们先不讨论 $S_i = 1$ 的情况，因为目前已经满足条件。

现在考虑如果遇到 $S_i=0$，我们可以交换 $A_i$ 和 $A_{i-1}$ 来满足题意，例如对于 $S=1101$，我们交换 $A_3$ 和 $A_2$，则排列变为 $1324$，于是合法。

然而还没结束，我们还需考虑遍历顺序对答案正确性的影响。

例如对于 $S=1001$，如果**顺序遍历**，结果应是 $2314$，不合法；如果**逆序遍历**，结果应是 $3124$，合法。可以猜想逆序冒泡的操作是正确的。

正确性：逆序遍历时的每一次 $A_i$ 与 $A_{i - 1}$ 互换，显然能使 $A_i$ 满足  $S_i = 0$ 的要求。而且，这不影响在 $A_i$ 后面已经确定的数的合法性，因为 $A_1\dots A_{i}$ 的最大值没有发生改变。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 100005;
int a[MAX_N];

int main() {
    int T, n;
    string s;
    cin >> T;
    for(int p = 1; p <= T; p++) {
        cin >> n;
        cin >> s;
        for(int i = 1; i <= n; i++) a[i] = i;
        for(int i = n; i >= 2; i--) if(s[i - 1] == '0')   swap(a[i], a[i - 1]);
        for(int i = 1; i <= n; i++) cout << a[i] << " ";
        cout << endl;
    }
    return 0;
}
```






---

## 作者：AirQwQ (赞：0)

我们读题后可以总结出两个关键点：

- 若 $ b_i=1 $ 则 $a_i>$ 前缀的**最大值**的。

- 反之 $a_i<$ 前缀的**最大值**的。

因为最大值一定大于等于最小值，所以可以将第二个条件转化为：

- 反之 $a_i<$ 前缀的**最小值**的。

于是，令序列 $a$ 中对应的 $01$ 串 $b$ 中值为 $0$ 的项依次为 $q_1,q_2,q_3,···,q_{lq}$，为 $1$ 的项依次为 $w_1,W_2,w_3,···,w_{lw}$。

因为 $1∼n$ 会不重不漏的出现在序列 $a$ 中，所以在我们的条件中 $q_{lq}$ 一定小于其它所有数，故 $q_{lq}=1$，类似的 $w_{lw}$ 一定大于其它所有数 $w_{lw}=n$，以此类推 $q_{lq}=1,q_{lq-1}=2,q_{lq-2}=3,···,q_1=lq$， $w_{lw}=n=lq+lw,w_{lw-1}=n-1=lq+lw-1,w_{lw-2}=n-2=lq+lw-2,···,w_1={n-lw}=lq+lw-(lw-1)=lq+1$。（这不一定是唯一解，但它一定是正确的）

得到构造方法程序实现就简单了，先遍历一遍确定 $lq$ 然后独立设两个光标 $cntq,cntw$ 进行输出即可。

代码奉上。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		int n,cntq=0,cntl=0,lq=0;
		scanf("%d",&n);
		string s;
		cin>>s;
		for(register int i=0;i<n;++i)
			if(s[i]=='0') lq++;
		for(register int i=0;i<n;++i)
			s[i]=='0'?printf("%d ",lq-(cntq++)):printf("%d ",lq+(++cntl));//不加括号就寄了。
        printf("\n");
	}
	return 0;
}
```

---


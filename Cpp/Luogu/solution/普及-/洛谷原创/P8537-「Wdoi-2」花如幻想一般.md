# 「Wdoi-2」花如幻想一般

## 题目背景

冬的白色被春日的阳光所点缀，幻想乡完全取回了生机的颜色。但，樱花，向日葵，野菊花，桔梗……明明还是春天，全年的花却全都盛开了。

六十年前（注：现实中的 1945 年）的大战，炮火声中、枪林弹雨中，无数的无辜的亡魂，在六十年后纷纷落于幻想之中，寄托于每一朵花上。

每一朵花寄托着每一朵亡魂的灵魂本质。向日葵寄宿着开朗的人的灵魂。彼岸花寄宿了没有朋友的寂寞灵魂，紫色的樱树下满是持有罪恶的幽灵。由于是从有德的幽灵开始按顺序送往彼岸，留到最后的都将是樱花。

外面的人类所看到的虚幻的彼岸，正回归于幻想的此岸。

## 题目描述

### 简要题意

有一个长度为 $n$ 的序列 $a$。可以进行两种操作：
- 将整个序列翻转；
- 将序列中的某个数加上某个**整数**。

问：至少要用多少次操作可以将序列 $a$ 转化为序列 $b$。

### 原始题意

参与解决花之异变的十余位主角都并未年满 60 岁，并没有经历过上一次的花之异变。在万花丛中解决异变的紧迫性逐渐被消弭，取而代之的是用花朵来进行游戏。

灵梦将 $n$ 个花朵排成了一排，第 $i$ 朵花都有其对应的美丽程度 $a_i$。而一旁的魔理沙作为一位魔法使，拥有两种能力。她可以进行若干次操作，每次操作可以**使得这 $\bm n$ 朵花的位置完全翻转**，或者可以**将某一朵花的美丽程度加上或减去一个整数**。

灵梦认为，如果能用魔理沙的操作，使得最后花朵的美丽程度可以变成序列 $b_i$，那么将会是很好的。为了解决异变顺利，魔理沙希望自己的操作次数尽可能少。那么请问魔理沙为了满足灵梦的愿望至少需要操作几次？

---

幻想乡的花儿渐落，新绿开始步向美丽的季节。经过六十年还不会被遗忘的记忆，可能是没有的吧。

## 说明/提示

### 样例解释 \#1

$$
\begin{array}{cccl}
\color{red}1&\color{red}2&\color{red}3&\downarrow\text{reverse}\\
3&2&1&
\end{array}
$$

### 样例解释 \#2

$$
\begin{array}{ccl}
\color{red}3&\color{red}1&\downarrow\text{reverse}\\
1&\color{red}3&\downarrow\text{add }-1\\
1&2&
\end{array}
$$

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 10\\\hline
2 & 10^3 & - & 30\\\hline
3 & 5\times 10^5 & \text{A} & 5 \\\hline
4 & 5\times 10^5 & - & 55 \\\hline
\end{array}$$

- 特殊性质 $\textbf{A}$：保证存在一种花费最小的方案，不需要执行第二种操作。

对于全部数据，满足 $1 \leq n \leq 5\times10^5$，
$1 \leq a_i,b_i \leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2
3 1
1 2```

### 输出

```
2```

# 题解

## 作者：chen_zhe (赞：24)

首先可以证明，翻转操作不会执行超过 $1$ 次，这是因为翻转两次就相当于把数列给翻转回来，没有进行任何操作了。

因此可以分类讨论，讨论当不进行翻转操作和进行一次翻转操作的情况。假设一次翻转操作都不进行，也就是只执行加法操作，那么就是对照一下有哪些对应位数字不一样即可。进行一次翻转操作也是同理的，先将数列翻转过来再对照一下有哪些对应位数字不一样。两者的操作次数取最小值即可。

参考代码如下：

```cpp
#include <iostream>

using namespace std;

int n,a[500050],b[500050];

int main()
{
	cin >> n;
	for (int i=1;i<=n;i++)
		cin >> a[i];
	for (int i=1;i<=n;i++)
		cin >> b[i];
	int cnt1=0,cnt2=1;
	for (int i=1;i<=n;i++)
	{
		if (a[i]!=b[i])
			cnt1++;
	}
	for (int i=n;i>=1;i--)
	{
		if (a[n-i+1]!=b[i])
			cnt2++;
	}
	cout << min(cnt1,cnt2) << endl;
	return 0;
}
```

---

## 作者：SolIII (赞：5)

## 题目描述
有一个长度为 $n$ 的序列 $a$。可以进行两种操作：

1. 将整个序列翻转；
2. 将序列中的某个数加上某个整数。

问：至少要用多少次操作可以将序列 $a$ 转化为序列 $b$。

## 题目分析
只要稍微思考一下，就可以得到一个结论：假设反转的次数为 $x$ 

则 $0 \leq x \leq 1$ 所以，我们可以分别枚举两种情况，

第一种为不翻转，第二种为翻转。

然后分别得出两种序列后，遍历得出不翻转和翻转之后的数组与 $b$ 相对应的数不相同的数的个数后，取最小值就是答案。

## 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR = 5 * 1e5;
int a[NR + 10], b[NR + 10], c[NR + 10];
//  没有翻转   目标      翻转

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 1;i <= n;i++){
        scanf("%d", &a[i]);//输入
        c[n - i + 1] = a[i];//翻转
    }
    for(int i = 1;i <= n;i++){
        scanf("%d", &b[i]);//输入
    }
    int cnt1 = 0, cnt2 = 1;
    for(int i = 1;i <= n;i++){//计算
        cnt1 += a[i] != b[i];
        cnt2 += c[i] != b[i];
    }
    printf("%d\n", min(cnt1, cnt2));//输出
    return 0;
}
```


---

## 作者：hycqwq (赞：3)

赛时竟然想了好久，~~后来开窍了~~，$O(n)$ 的做法，~~dalao 勿喷~~。

## 思路

分 $2$ 种情况：翻转 $1$ 次的和没翻转的（如果翻 $2$ 次就没意义了）

### ① 没翻转的

每次操作可以给任意一朵花加上或减去**任意**的美丽程度，所以一朵花只调整一次即可，否则就浪费次数了。

也就是说，遍历两个序列时，如果对应值不同，操作总数 $+ 1$。

### ② 翻转 $1$ 次的

即翻转后当做没翻转的情况来计算次数，最后再 $+ 1$。

## 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n;
int a[500005], b[500005];

void reverseA()//将a序列倒过来
{
    for (int i = 1, j = n; i < j; i++, j--)
        swap(a[i], a[j]);
}

int cal()//计算现在的序列只加减美丽程度，需要操作多少次
{
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        cnt += (a[i] != b[i]);//如果两个不一样，即++
    /*
    也可改为：
        if (a[i] != b[i])
            cnt++;
    */
    return cnt;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> b[i];
    int ans = cal();//不翻转的情况
    reverseA();//如果翻转
    ans = min(ans, cal() + 1);//和翻转的情况取最小即可，记得+1
    cout << ans << endl;
    return 0;
}
```

---

## 作者：ahahha (赞：3)

感觉大家都想复杂力。

先看两种操作，旋转要不然就不旋转，要不然就旋转 $1$ 次，因为旋转 $3$ 次就等于旋转 $1$ 次，$4$ 次就是 $0$ 次，以此类推。

修改这种操作，如果这个位置上和要成为的数不一样，那么久一定要改变了。

其他也没什么好说的了，注意数组的大小。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000010],b[1000010],t[1000010];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>b[i],t[i]=b[i];
    int ans=0,ans2=1;//因为翻转过一次所以初始为1
    reverse(t+1,t+1+n);
    for(int i=1;i<=n;i++){
        ans+=(b[i]!=a[i]);
        ans2+=(t[i]!=a[i]);
    }
    cout<<min(ans,ans2);
}
```

---

## 作者：Charlie1202 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8537)

# 序言
有一天，你参加了一场比赛，点进去了第一题。你焦急地读题：

将一个长度为 $n$ 的序列 $a$ 通过尽可能少的序列翻转或单点修改（~~线段树？~~）操作变为序列 $b$。

当你看到 Subtask $3$ 时，心中一喜：没有操作 $2$？既然只有序列翻转，那我就直接 `puts('1')` 就行了（见样例 $1$）。

就这样，你很快得到了 $5$ 分的~~好成绩~~。

# 正片
你拿出了草稿纸，开始枚举找规律。

你很快发现，如果只考虑 $1$ 次翻转操作，序列 $a$ 中实际上是处于对称位置上的两个数交换了位置（例如序列 $\{1, 2, 3\}$，以 $2$ 为对称轴，$1$，$3$ 交换；$n$ 为偶数时，同理），也就是对于这 $n$ 个数中的第 $i$ 个数（$1 \le i \le n$），只是和第 $n - i + 1$ 个数交换了位置。因此，在 $b$ 序列中，如果某位置的数与它在 $a$ 中对称位置处的数相同（即 $b_i = a_{n - i + 1}$），只要进行一次翻转操作即可。

特别的，如果上述两个数不同（假设有 $x$ 对数不同），一定可以在翻转操作后进行 $x$ 次单点修改，使两个序列最终相同。

因此，你写下了如下代码：
```cpp
int ans=1;//注意 ans 初值，因为我们默认进行了一次翻转操作
for(int i=1;i<=n;i++)
{
	int x;
	cin>>x;//读入序列 b
	if(a[n-i+1]!=x)ans++;//统计有多少对数不同
}
cout<<ans;
```
但还是只有 $5$ 分，为什么呢？你立刻发现了特例（正确答案为 $1$）：
```
3
1 3 5
1 3 7
```
根据上面的代码，应该输出 $2$，但实际上只要将 $5$ 改为 $7$ 即可。这就说明，在某些情况下，只进行单点修改操作比上述做法更优。那么，就只需要将上述方案结果记录下来，同时比对两个序列，一有不同结果加 $1$，最后两者取最小值输出即可。
```cpp
int ans,ans1=1,ans2=0;//注意 ans2 初值，因为没有翻转操作
for(int i=1;i<=n;i++)
{
	int x;
	cin>>x;
	if(a[n-i+1]!=x)ans1++;
	if(a[i]!=x)ans2++;//统计进行多少次单点修改操作
}
ans=min(ans1,ans2);
cout<<ans;
```

## 后记
变是永恒的不变，贪心还是永远的贪心。

---

## 作者：xiaohaoaibiancheng66 (赞：0)

# 思路

由于第一种操作可以加一个负数，所以可以看作**把 $a_i$ 改变一次**。

而因为有第二种操作，所以分两种情况：没翻转和翻转了。

对于没翻转的情况：因为 $a_i=b_i$ 就没必要操作，所以最终数量为 $a_i \ne b_i$ 的数量。

而对于翻转了的情况：设 $c$ 为翻转后的 $a$，所以最终数量为 $c_i \ne b_i$ 的数量再加上 $1$（因为还要记翻转的一次）。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[1000000],b[1000000];

int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;i++)cin>>a[i];
	for(int i=0;i<n;i++)cin>>b[i];
	int cnt1=0,cnt2=0;//cnt1代表没翻转，cnt2代表翻转了。
	for(int i=0;i<n;i++)
		if(a[i]!=b[i])
			cnt1++;
	for(int i=0;i<n;i++)
		if(a[i]!=b[n-i-1])
			cnt2++;
	if(cnt2<cnt1)cout<<cnt2+1;//这个地方如果 cnt1=cnt2+1 则无所谓；
   //如果 cnt1=cnt2+2 则 cnt2 最优。
   //如果 cnt1=cnt2 则 cnt1 最优。
	else cout<<cnt1;
	return 0;
}
```
 

---

## 作者：AirQwQ (赞：0)

## 思路

- 翻转只可能是翻或不翻（翻两次等价于不翻）。

- 分别遍历翻和不翻时 $a$ 与 $b$ 对应下标不同的元素个数后取最小值即可。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[500005];
int b[500005];
int main(){
	int n，minn=0,minx=1;
	cin>>n;
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
		scanf("%d",&b[i]);
	for(int i=1;i<=n;i++){
		if(a[i]!=b[i]) minn++;
		if(a[i]!=b[n-i+1]) minx++;//代替翻转。
	}
	cout<<min(minn,minx);
	return 0;
}

```

---

## 作者：what_else (赞：0)

### Description

给定一个序列 $a$，可以让 $a_i$ 增减 $k$ 或反转 $a$，求使 $\forall i ,a_i=b_i$ 最少的操作次数。

### Solution

可以肯定的是，最优解一定最多只反转一次数列，为什么呢？因为一个序列反转两次，必然会回到原来的状态，所以还不如不反转。

就比如 $1,2,4$：

反转一次后，变为 $4,2,1$，再反转一次，变为 $1,2,4$，可以发现，反转两次与不反转是等效的。

那就可以讨论两种情况：一种是反转一次，一种是不反转。

为了求所操作次数最少，可以分别求反转与不反转的次数，求其最小值即可。

考虑得到的新 $a$，既然不反转了，那就一定是第二种操作，即让 $a_i$ 增减 $k$，那可以直接令 $a_i=b_i$，以节省操作次数。

### Summary

其实本题就是求：

$$\min(\sum^n_{i=1}[a_i≠b_i],\sum^n_{i=1}[a_{n-i+1}≠b_i]+1)$$

的值。

```cpp

#include<bits/stdc++.h>

using namespace std;

int p[500100],s[500005],v[505050];//p为原序列,v为反转序列,s为目标序列

int n;

int ans=0,ans2=1;//注意反转一次,ans2初值为1

int main(){

	cin>>n;

	for(int i=1;i<=n;i++)

	cin>>p[i],v[n-i+1]=p[i];

	for(int i=1;i<=n;i++)

	cin>>s[i];

	for(int i=1;i<=n;i++){

		if(s[i]!=p[i])ans++;

		if(s[i]!=v[i])ans2++;

	}

	cout<<min(ans,ans2);

}

```

---

## 作者：Nemonade (赞：0)

首先因为“加数”操作可以加负数，所以必定有解。

如果我们翻转超过一次的话，那么就相当于没有动过。

所以实际上只相当于原数组和翻转数组的与目标数组的比较。

这就可以 $O(n)$ 扫一遍不同的数的个数再取最小值就可以了。

翻转数组的个数记得 +1 因为翻转也要算次数。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rd() (read<int>())
#define pfor(i,x,y) for(register int i=x;i<=y;++i)
#define mfor(i,x,y) for(register int i=x;i>=y;--i)
template<typename T>
inline T read(){
	T x=0;bool f=false;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=true;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?-x:x;
}
template<typename T>
inline void write(T x){
	if(x<0){putchar('-');x=-x;}
	if(x/10) write(x/10);
	putchar((x%10)^48);return;
}
using std::max;using std::min;using std::abs;
using std::cin;using std::cout;using std::endl;
using std::sort;using std::swap;
const int N=5e5+5,M=1e4+5,MOD=1e9+7;
int n,a[N],b[N],res=INT_MAX;
signed main(){
	n=rd();
	pfor(i,1,n) a[i]=rd();
	pfor(i,1,n) b[i]=rd();
	int s=0;
	pfor(i,1,n) s+=(a[i]!=b[i]);
	res=min(res,s),s=1;
	pfor(i,1,n) s+=(a[n-i+1]!=b[i]);
	cout<<min(res,s);
	return 0;
}
```

---

## 作者：Awhale_tauntingcat (赞：0)

#### 题意分析
显然本题有两种情况：直接在原序列 $a$ 上加减和先翻转序列 $a$ 再进行加减。因为多次翻转除了增加操作数外没有任何意义。

先讨论直接加减的情况，将序列 $a$ 与序列 $b$ 进行比较，他们之间不相同元素的个数就是最小的操作数。

然后将序列 $a$ 翻转，再按照直接加减的情况处理。

最后将两种情况的结果取最大值输出即可。

$Code$

```cpp
#include<iostream>
using namespace std;
int n;
long long a[500001],b[500001];
int tota=0,totb=1;
void flip(){
	for(int i=1;i<=n/2;i++){
		swap(a[i],a[n+1-i]);
	}
}//翻转函数
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		if(a[i]!=b[i]){
			tota++;
		}//第一种情况
	}
	flip();//翻转
	for(int i=1;i<=n;i++){
		if(a[i]!=b[i]){
			totb++;
		}//第二种情况
	}
	if(tota!=totb) cout<<min(tota,totb);
	else cout<<tota;//取最值输出
	return 0;
}
```

---

## 作者：zhangxinye (赞：0)

## 思路
首先，我们知道，翻转操作最多只会进行一次，因为进行两次就没有意义了。

因此，这道题分两种情况：翻转一次和不翻转。

如果是不翻转，那我们只需要统计两者之间不同的个数即可。
如果是只翻转一次，那么我们就先进行一次翻转操作，再统计两者之间不同的个数即可。
最后，我们只需要取两者的较小值即可。
## 代码
```
#include <bits/stdc++.h>
using namespace std;
int n;
int aa, bb = 1;
int a[500010];
int b[500010];
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++){
		scanf("%d", &a[i]);
	}
	for(int i = 1; i <= n; i ++){
		scanf("%d", &b[i]);
		if(a[i] != b[i]){
			aa ++;
		}
		if(a[n - i + 1] != b[i]){
			bb ++;
		}
	}
	printf("%d", min(aa, bb));
	return 0;
}

---


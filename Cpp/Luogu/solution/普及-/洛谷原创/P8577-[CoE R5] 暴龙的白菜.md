# [CoE R5] 暴龙的白菜

## 题目背景

暴龙爱吃白菜。

## 题目描述

给定一个字符串，由 $1$ 个 $\texttt{1}$，$2$ 个 $\texttt{2}$，$3$ 个 $\texttt{3}$，$4$ 个 $\texttt{4}$，$5$ 个 $\texttt{5}$，$6$ 个 $\texttt{6}$，$7$ 个 $\texttt{7}$，$8$ 个 $\texttt{8}$，$9$ 个 $\texttt{9}$，$10$ 个 $\texttt{10}$……以此类推，依次拼接而成。

询问字符串第 $l$ 位到第 $r$ 位的数字之和。

## 说明/提示

**样例解释**

字符串为：

$$\texttt{12233344445555566666677777778888888899999999910101010101010101010}\cdots\cdots$$

对于第一组询问，第 $5$ 位到第 $9$ 位的数字之和为 $3+3+4+4+4=18$。

对于第二组询问，第 $46$ 位到第 $50$ 位的数字之和为 $1 + 0 + 1 + 0 + 1 = 3$。

------------

**数据范围**

**本题采用捆绑测试。**

- $\texttt{Subtask 1(10 pts)：}T=1$，$1\le l\le r\le 10$；
- $\texttt{Subtask 2(20 pts)：}1\le T\le 10$，$1\le l\le r\le 10^3$；
- $\texttt{Subtask 3(30 pts)：}1\le T\le 10^3$，$1\le l\le r\le 10^5$；
- $\texttt{Subtask 4(40 pts)：}$无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 10^5$，$1\le l\le r\le 10^6$。

## 样例 #1

### 输入

```
4
5 9
46 50
114 514
19 19810```

### 输出

```
18
3
1134
74924```

# 题解

## 作者：Shanganze (赞：8)

作为比赛的T1，难度还是很符合的。
### 分析：

直接按照题意模拟，用字符串来存放每一位的数字，是几的时候就在字符串后面加上几个该数，然后用前缀和预处理，查询时直接 $O(1)$ 输出即可。

具体实现见代码。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}//快读，初学者可用cin代替。
int x[10000009];
int main(){
	int T=read();
	string a;
	for(int q=1;q<=1000;q++){//外层循环模拟当前应在字符串后连接的数字
		for(int w=1;w<=q;w++){//内层循环模拟该数应在字符串连接多少个。
			if(q<10)a+=char(q-1+'1');//个位数，直接转字符连接。
			else if(q<100)a+=char(q/10-1+'1'),a+=char(q%10-1+'1');//两位数，先连接十位，再连接个位。
			else if(q<1000)a+=char(q/100-1+'1'),a+=char(q/10%10-1+'1'),a+=char(q%10-1+'1');//三位数同理。
		}
	}
	for(int q=0;q<=1000001;q++){
		x[q+1]=x[q]+a[q]-'0';//前缀和预处理。
	}
	for(int q=1;q<=T;q++){
		int l,r;
		l=read();r=read();
		cout<<x[r]-x[l-1]<<endl;//输出时，因为要包含左端点，所以减去左端点的前一位。
	}
	return 0;
}
```


---

## 作者：buqiming (赞：8)

高中蒟蒻的第一篇题解
（我比较笨，看到这种大规模输入输出就想着用树状数组或线段树了）qaq


## 分析题目
从题目可以看出给的一串数非常有规律，我们可以在树状数组每个位置把对应的数字插入就好了。
然后就是简单的求和了，没什么说的，直接看代码。
## AC代码
```cpp
#include<iostream>

using namespace std;
const int N=1e6+10;
int tr[N];

int lowbit(int x)//树状数组最低位
{
    return x&-x;
}

void add(int x,int d)//对应位置添加数组
{
    for(;x<=N;x+=lowbit(x)) tr[x]+= d;
}

int sum(int x)//求和
{
    int sum=0;
    for(;x;x-=lowbit(x)) sum+=tr[x];
    return sum;
}

int main()
{
    int t;
    scanf("%d",&t);
    
    int now=1;//现在应该插入哪个数字
    int idx=1;//当前这个数字插入了多少次
    for(int i=1;i<N;)
    {
        int j=now;
        int a[10],po=1;//a数组用来表示now的每一位各是多少
        while(j)
        {
            a[po++]=j%10;
            j/=10;
        }
        for(int pos=po-1;pos>=1;pos--)
        {
            add(i,a[pos]);//插入每一位的数字
            i++;
        }
        
        if(now==idx)//当前这个数字插入的次数已经足够多了，换下一个数字
        {
            now++;
            idx=0;
        }
        
        idx++;
    }
    
    while(t--)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",sum(r)-sum(l-1));//用sum(r)表示1-r的数字之和，sum(l-1)表示1-（l-1）的数字之和，相减即可得到l-r的数字之和
    }
}
```
大佬勿喷。



---

## 作者：Trump__Biden (赞：6)

## 题意：
给定一个字符串，是由一个 $ 1 $ ，两个 $ 2 $，三个 $ 3 $，$ n $ 个 $ n $ 组成的。需要求出从第 $ l $ 位到第 $ r $ 位的数字总和。注意，一个两位数占两位。

## 思路：
先预处理出前整个字符串，用一个数组的第 $ i $ 位 $ f[i] $记录前 $ i $ 位的总和，输入 $ l $ 和 $ r $ 之后，利用 $ f[r] $ 和 $ f[l-1] $ 的差即是第 $ r $ 位去除前 $ l-1 $ 位后的数字总和也就是答案。

## 代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int t,l,r,cnt,tmp,tot,a[1000005],f[1000005];
int main(){
    for(int i=1;i<=1000;i++){
        for(int j=1;j<=i&&cnt<=1e6;j++){
            tmp=i,tot=0;
            while(tmp!=0){
                a[++tot]=tmp%10;
                tmp/=10;
            }
            for(int k=tot;k>=1;k--){
                cnt++;
                f[cnt]=f[cnt-1]+a[k];
            }
        }
    }
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&l,&r);
        printf("%d\n",f[r]-f[l-1]);
    }
    return 0;
}
```
希望这篇题解可以帮助大家理解这道题。

---

## 作者：Larryyu (赞：6)

## _Description_
有一个字符串，由 $\texttt{1}$ 个 $\texttt{1}$，$\texttt{2}$ 个 $\texttt{2}$，$\texttt{3}$ 个 $\texttt{3}$......组成。

现有 $m$ 次询问，问从第 $l$ 到第 $r$ 位上数字之和。
## _Solution_
本题数据范围很重要：$0\le l\le r\le10^6$。

计算可得，字符串数最多在 $\texttt{1000}$ 和 $\texttt{1050}$ 之间，预处理即可。

再遍历一遍字符串，记录前缀和即可。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[1000100];
string s;
int t;
string ss[1200]={" ","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","388","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","422","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534","535","536","537","538","539","540","541","542","543","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560","561","562","563","564","565","566","567","568","569","570","571","572","573","574","575","576","577","578","579","580","581","582","583","584","585","586","587","588","589","590","591","592","593","594","595","596","597","598","599","600","601","602","603","604","605","606","607","608","609","610","611","612","613","614","615","616","617","618","619","620","621","622","623","624","625","626","627","628","629","630","631","632","633","634","635","636","637","638","639","640","641","642","643","644","645","646","647","648","649","650","651","652","653","654","655","656","657","658","659","660","661","662","663","664","665","666","667","668","669","670","671","672","673","674","675","676","677","678","679","680","681","682","683","684","685","686","687","688","689","690","691","692","693","694","695","696","697","698","699","700","701","702","703","704","705","706","707","708","709","710","711","712","713","714","715","716","717","718","719","720","721","722","723","724","725","726","727","728","729","730","731","732","733","734","735","736","737","738","739","740","741","742","743","744","745","746","747","748","749","750","751","752","753","754","755","756","757","758","759","760","761","762","763","764","765","766","767","768","769","770","771","772","773","774","775","776","777","778","779","780","781","782","783","784","785","786","787","788","789","790","791","792","793","794","795","796","797","798","799","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","832","833","834","835","836","837","838","839","840","841","842","843","844","845","846","847","848","849","850","851","852","853","854","855","856","857","858","859","860","861","862","863","864","865","866","867","868","869","870","871","872","873","874","875","876","877","878","879","880","881","882","883","884","885","886","887","888","889","890","891","892","893","894","895","896","897","898","899","900","901","902","903","904","905","906","907","908","909","910","911","912","913","914","915","916","917","918","919","920","921","922","923","924","925","926","927","928","929","930","931","932","933","934","935","936","937","938","939","940","941","942","943","944","945","946","947","948","949","950","951","952","953","954","955","956","957","958","959","960","961","962","963","964","965","966","967","968","969","970","971","972","973","974","975","976","977","978","979","980","981","982","983","984","985","986","987","988","989","990","991","992","993","994","995","996","997","998","999","1000","1001","1002","1003","1004","1005","1006","1007","1008","1009","1010","1011","1012","1013","1014","1015","1016","1017","1018","1019","1020","1021","1022","1023","1024","1025","1026","1027","1028","1029","1030","1031","1032","1033","1034","1035","1036","1037","1038","1039","1040","1041","1042","1043","1044","1045","1046","1047","1048","1049","1050","1051","1052","1053","1054","1055","1056","1057","1058","1059","1060","1061","1062","1063","1064","1065","1066","1067","1068","1069","1070","1071","1072","1073","1074","1075","1076","1077","1078","1079","1080","1081","1082","1083","1084","1085","1086","1087","1088","1089","1090","1091","1092","1093","1094","1095","1096","1097","1098","1099","1100"};
int read(){
    int x=0,f=1;
    char ch;
    ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int main(){
    for(int i=1;i<=1100;i++){
        for(int j=1;j<=i;j++){
            s+=ss[i];  //预处理字符串
        }
    }
    sum[0]=0;
    for(int i=1;i<=1000000;i++){
        sum[i]=sum[i-1]+s[i-1]-'0';  //预处理前缀和
    }
    t=read();
    while(t--){
        int l=read(),r=read();
        printf("%d\n",sum[r]-sum[l-1]);
    }
    return 0;
}
```
#### _完结撒花！！_

---

## 作者：MvemiY (赞：2)

## 构造字符串（数组）
用数组 $a$ 来表示这个字符串，用数组 $b$ 表示每个数组取出的每一位。

首先，将每个数字的每个位取出来然后将 $b$ 放入 $a$ 中。需要注意的是，因为我们是从低位向高位取数，例如数字 $123$ 我们会取得 $a_1 = 3$，$a_2 = 2$，$a_3 = 1$，所以我们将 $b$ 放入 $a$ 时应当是 $a_k = b_{len - k + 1}$。其中 $k$ 是 $b$ 填到的位数，$len$ 表示 $b$ 的长度。

代码实现：

```cpp
// maxr 存储的是 max{r}
void init(int x){
	len = 0;
	ll tem = x;
	while(tem)
		b[++len] = tem % 10, tem /= 10;
}
bool flag = 1;
for(int i = 1; top <= maxr && flag; i++){
	init(i);
   // init函数表示将 b 的每一位取出来
	for(int j = 1, k = 1; j <= i * len && flag; j++){
		a[++top] = b[len - k + 1];
		if(k == len)
			k = 1;
		else k++;
		if(top > maxr)
			flag = 0;
	}
}
```

## 代码实现

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
ll a[1000010], f[1000010], b[300], top, maxr = -1, len;
pair<ll, ll> ask[1000010];
void init(int x){
	len = 0;
	ll tem = x;
	while(tem)
		b[++len] = tem % 10, tem /= 10;
}
int main(){
	ios :: sync_with_stdio(0);
	int t;
	cin >> t; 
	for(int i = 1; i <= t; i++){
		cin >> ask[i].fi >> ask[i].se;
		maxr = max(maxr, ask[i].se);
	}
  // 离线是为了取 max(r)
	bool flag = 1;
	for(int i = 1; top <= maxr && flag; i++){
		init(i);
		for(int j = 1, k = 1; j <= i * len && flag; j++){
			a[++top] = b[len - k + 1];
			if(k == len)
				k = 1;
			else k++;
			if(top > maxr)
				flag = 0;
		}
	}
	for(int i = 1; i <= t; i++){
		int l = ask[i].fi;
		int r = ask[i].se;
		ll ans = 0;
		for(int i = l; i <= r; i++)
		    ans += a[i];
     // 暴力求和
		cout << ans << endl;
	}
	return 0;
}
```

然后你就会发现你惊奇地 T 掉了。
# 暴力优化
仔细想想，数据范围中 $T \le 10^5$， $l,r \le 10^6$ 。

如果暴力求和，时间复杂度为 $O(max(r)\times T)$，显然无法通过。

想想区间和，我们可以使用 `线段树` 或 `前缀和`。

其中，因为此题没有 **区间修改** 并且 `线段树 ` 的 **区间查询** 为 $O(logn)$，这一点是没有 `前缀和` 区间查询 $O(1)$ 有优势。

于是我们选择 `前缀和`， 时间复杂度 $O(max(r )+ T)$。

## AC代码
```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
ll a[1000010], f[1000010], b[300], top, maxr = -1, len;
pair<ll, ll> ask[1000010];
void init(int x){
	len = 0;
	ll tem = x;
	while(tem)
		b[++len] = tem % 10, tem /= 10;
}
int main(){
	ios :: sync_with_stdio(0);
	int t;
	cin >> t; 
	for(int i = 1; i <= t; i++){
		cin >> ask[i].fi >> ask[i].se;
		maxr = max(maxr, ask[i].se);
	}
	bool flag = 1;
	for(int i = 1; top <= maxr && flag; i++){
		init(i);
		for(int j = 1, k = 1; j <= i * len && flag; j++){
			a[++top] = b[len - k + 1];
			if(k == len)
				k = 1;
			else k++;
			if(top > maxr)
				flag = 0;
		}
	}
	for(int i = 1; i <= maxr; i++)
		f[i] = f[i - 1] + a[i];
	for(int i = 1; i <= t; i++){
		int l = ask[i].fi;
		int r = ask[i].se;
		cout << f[r] - f[l - 1] << endl;
	}
	return 0;
}
```
其实你也可以将 $a$ 数组跑满 $10^6$ 在线，但是离线求出 $max(r)$ 也是一个优化。

---

## 作者：LeiZeProMax (赞：2)

题意：给定一个由 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，...组成的字符串，求第 $l$ 位到第 $r$ 位的数字之和。

我们可以先根据题意暴力构造一个字符串，再暴力求出每一位的前缀和，最后再用第 $r$ 位前缀和减去第 $l-1$ 位前缀和即可。

月赛时 $57ms$。

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string ans,k;
long long b[1000001];
void _tt(int s)//转化字符串 
{
	k.erase(0,k.size());//清空k 
	int a[101];
	int num=0;
	while(s!=0)//将s转化为字符串 
	{
		a[++num]=s%10;
        s/=10;
	}
    for(int i=num;i>=1;--i)k+=(a[i]+'0');//倒序存到字符串k中 
}
int T,l,r;
int main()
{
    for(int i=1;i<=819;++i)//暴力构造字符串 
		{
			_tt(i);
			for(int j=1;j<=i;++j)
				ans+=k;//将转化后的字符存入字符串ans中 
		}
    for(int i=1;i<=1000000;++i)//求1->1e6的前缀和并存入b中 
    {
    	b[i]=ans[i-1]^48;//^48可替换为-'0' 
    	b[i]+=b[i-1];
    }
    scanf("%d",&T);
    while(T--)
    {
    	scanf("%d %d",&l,&r);
    	printf("%lld\n",b[r]-b[l-1]);//l要-1因为l->r中包括l 
    }
    return 0;
}
```


---

## 作者：AirQwQ (赞：2)

~~考场唯一做出来的。。。~~

 $1 \le T \le 10^5,1\le l\le r\le 10^6$ 所以暴力就别想了。

所以预处理然后对于每个询问直接输出即可。

因为询问字符串第 $l$ 位到第 $r$ 位的数字之和，自然想到使用前缀和。

- 构造原字符串：

1. 按照题意枚举 $n$ 个 $n$。

```cpp
void init(){
    int i=0;
    while(++i&&init2(i));
}
```

2. 使用拆位法算出每一位数字，存入临时数组 $s$ 中。

```cpp
bool init2(int i){
    int cnt2=i;
    while(i--){
        int cnt=cnt2;
        int cnt1=0;
        int s[100];
        while(cnt>0){
            s[++cnt1]=cnt%10;
            cnt/=10;
        }//基本拆位        
    }
}
```

3. **倒叙储存**入前缀和数组 $a$ 中。（比如 $114514$ 拆位后是 $4,1,5,4,1,1$ 所以要倒叙储存）

```cpp
for(int j=1;j<=cnt1;j++){
    a[cnts]=a[cnts-1]+s[cnt1-j+1],cnts++;//记得倒叙处理
    if(cnts>1000005) return 0;//r小于等于10^6
}
```

- 所以得到初始化全部代码：

```cpp
int cnts=1,a[1000050];
bool init2(int i){//用bool方便判断个数
    int cnt2=i;
    while(i--){
        int cnt=cnt2;
        int cnt1=0;
        int s[100];
        while(cnt>0){
            s[++cnt1]=cnt%10;
            cnt/=10;
        }
        for(int j=1;j<=cnt1;j++){
            a[cnts]=a[cnts-1]+s[cnt1-j+1],cnts++;
            if(cnts>1000005) return 0;
        }
        
    }
    return 1;
}
void init(){
    int i=0;
    while(++i&&init2(i));
}
```
~~全部代码太丑了就不放了。~~



---

## 作者：Lagerent (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P8577?contestId=86115)

## $\text{Solution}$

对着序列我们可以发现一个规律，设 $k$ 为当前数 $i$ 的位数，那么它在序列中占的位数就是：
$$k \times i$$


所以我们可以处理预出来每一位上是什么数，前缀和进行区间查询即可。

数据范围 $l, r \le 10 ^ 6$，所以当数到达 $819$ 的时候，数列长度就大于等于 $10^6$ 了。

这个结论可以写个程序实现，我的代码是这样的。

```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
#define il inline
using namespace std;

const int N = 1e7 + 10;

int b[N], last, res, s[10], w, sum[N];

int q(int x) {
	int cnt = 0, t = x;
	while(t) {
		cnt ++ ;
		t /= 10;
	}
	return cnt;
}

int main() {
	int pos = 0;
	rep(i, 1, 1000) {
		w = q(i);
		res += i * w;
		if(res >= 1e6) {pos = i; break;}
	}
	printf("%d\n", pos);
	return 0;
}
```

所以在预处理的时候，处理到 $819$ 即可。

（当然，你也可以当 $res$ 达到 $10 ^ 6$ 的时候 break，要保证上界大于等于 $819$， ~~但我认为这样并不优美~~。）

预处理时间复杂度 $O(n)$，查询 $O(1)$。

```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
#define il inline
using namespace std;

const int N = 1e7 + 10;

int b[N], last, res, s[10], w, sum[N];

int q(int x) {
	int cnt = 0, t = x;
	memset(s, 0, sizeof s);
	while(t) {
		cnt ++ ;
		t /= 10;
	}
	per(i, cnt, 1) s[i] = x % 10, x /= 10;
	return cnt;
}

il void doit() {
	for(int i = last + 1; i <= res; i += w) {
		rep(j, 1, w) {
			b[i + j - 1] = s[j];
		}
	}
}

il void init() {
	res = 0, last = 0;
	rep(i, 1, 819) {
		w = q(i);
		res += i * w;
		doit();
		last = res;
	}
	rep(i, 1, res) sum[i] = sum[i - 1] + b[i];
}

int main() {
	init();
	int T;
	scanf("%d", &T);
	while(T -- ) {
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", sum[r] - sum[l - 1]);
	}
	return 0;
}
```

---


# 『JROI-8』对了，还有花，少女，银河

## 题目背景

![1663764189387.png](https://img-kysic-1258722770.file.myqcloud.com/9d24e2bd5b20f277e72914b1bc44543e/44b6413b44c70.png)

>「其一」\
即使化身白骨，也有不想忘记的东西

**已获得转载授权。**

## 题目描述

给定 $n$，请构造一个长度为 $n$ 的仅包含 $0,1$ 的数字串，满足 $01,00,10,11$ 出现的次数相等。或报告无解。

这里“出现”指与原字符串中连续的一部分完全相同。例如，在 $1011101$ 中，$01,00,10,11$ 分别出现了 $2,0,2,2$ 次。

**请注意，大样例不以文件附加形式给出，而直接放在题目的 输入输出样例 中的 样例 #3**

## 说明/提示

【数据范围与提示】

| 测试点编号 | 分数 | $n\leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: |
| $1\sim 2$ | $20$ | $5$ | 无 |
| $3\sim 4$ | $20$ | $10^6$ | $n \bmod 4 = 0$ |
| $5\sim 6$ | $20$ | $20$ | 无 |
| $7 \sim 10$ | $40$ | $10^6$ | 无 |

## 样例 #1

### 输入

```
3```

### 输出

```
-1```

## 样例 #2

### 输入

```
5```

### 输出

```
00110```

## 样例 #3

### 输入

```
15400```

### 输出

```
-1```

# 题解

## 作者：AThls123 (赞：38)


## 题目简述
[原题链接](https://www.luogu.com.cn/problem/P8589)

给定 $n$，请构造一个长度为 $n$ 的仅包含 $0,1$ 的数字串，满足  $01,00,10,11$ 出现的次数相等，或报告无解。

这里“出现”指与原字符串中连续的一部分完全相同。例如，在 $1011101$ 中，$01,00,10,11$ 分别出现了 $2,0,2,2$ 次。

## 思路

显然，这是构造的题。

本人做这道题的时候用了一点小技巧。


那么如何判断能否构造？

只需要一个简单的暴力 DFS 就可以了。
当然你也可以用特殊性质来猜，或者如果你是大佬的话可能一下子就想出来了。

DFS 程序如下：
```cpp
#include<iostream>
using namespace std;
int a[100],flag;
void print(int n){
    for(int i=1;i<=n;i++){
        cout<<a[i];
    }cout<<endl;
}
bool check(int n){
    int x01=0,x11=0,x10=0,x00=0;
    for(int i=2;i<=n;i++){
        if(a[i-1]==0&&a[i]==0)x00++;
        if(a[i-1]==0&&a[i]==1)x01++;
        if(a[i-1]==1&&a[i]==0)x10++;
        if(a[i-1]==1&&a[i]==1)x11++;
    }
    if(x00==x01&&x01==x10&&x10==x11){flag=1;return true;}
    return false;
}
void dfs(int step,int n){
    if(step==n+1){
        if(check(n))print(n);
        return;
    }
    a[step]=1;
    dfs(step+1,n);
    a[step]=0;
    dfs(step+1,n);
}
int main(){
    int n;
    cin>>n;
    for(int j=1;j<=n;j++)a[j]=3;
    flag=0;
    dfs(1,n);
    if(flag)cout<<"yes"<<endl;
    else cout<<"No"<<endl;
	return 0;
}
```
运行这个程序之后发现只有在 $4n+1$($n \in \mathbf{N^*}$) 的时候才可能有解。

然后，难道真的要用这程序来输出答案吗？

当然不是，这只是个判断。

### 解题的重点在下面：

有了上面的判断就可以写答案程序了

综上有以下两点

1.	当 $n \bmod 4=1  \ (n\in\mathbb N^*)$ 时，可以构造序列

1.	其他情况均无解

对于构造序列，其实题目已经给出来了（上面的程序也给出来了）

看样例：

	输入 #2
	5
    输出 #2
	00110

这不就给出来了

先输出 $\dfrac{n-1}{4}$ 个 $0011$，最后输出 $0$ 

如下：

$\begin{matrix}\\\underbrace{0011\cdots 00110}\\n\end{matrix}$  

证明

对于每一段的0011

一共有

-	一个 $00$

-	一个 $11$

-	一个 $01$

-	没有一个 $10$，但每段末尾的$0$会和右边开头的 $0$ 合成一个 $10$

综上，这样只要按照如上构造方法，无论有多少段，其中 $01,00,10,11$ 的数量均是相等的。


# Code
```cpp
#include<iostream>
using namespace std;
int main() {
	long long n;cin >> n;
	if ((n - 1) % 4 == 0&&n!=1) {
		for (int i = 1; i <= n/4; i++)cout << "0011";
        cout << 0 << endl;
        return 0;
	}
    else cout<<-1<<endl;
	return 0;
}
```


听说CSP考试前交题解可以rp++。

顺便推荐做一下之前月赛的题目[P8437 伟大的神](https://www.luogu.com.cn/problem/P8437)，相比之下，伟大的神明显更难，思维难度更高一点。


---

## 作者：xwh_Marvelous (赞：8)

>震惊，毒瘤出题人 
Cocoly1990 为了误导选手，特意加上一个虚假的特殊性质，看来下一个 noip 诞生了。

------------

普及考构造，我谔谔。

我们先观察样例二给出的的合法解，首先 $n=5$ 不符合 $n \bmod 4=0$ 的特殊性质，初步判定特殊性质是来搞笑的。我们再以五往后枚举 $n$，发现最近一个有解的 $n=9$。

我们观察 $5$ 和 $9$ 之间的关系，发现 $5\equiv9\pmod{4}$，且 $5 \bmod 4=1$。我们大胆假设对于一个 $n$，如果它满足 $n\bmod 4=1$，那么它就有解，否则无解。然后对它求证。

我们看出一个长为 $n$ 的 $01$ 串共能构成 $n-1$ 个相邻两个数组成的子串。为了使得四种不同排列的字串总数相等，那么 $n-1\bmod4=0$，也就是可以平均将每个字串平均分到每个每种字串中。那么原式变形后得 $n \bmod 4=1$。

最后我们考虑如何构造字串，我们可以观察样例二。样例中 $0110$ 构成了一个 $01$，$11$ 和 $10$，加上最前面的 $0$ 又补上了 $00$。而最后一位又刚好可以成为下一组的开头的 $0$，可以往后不断接上 $0110$。那么最终的构造方案就是，先输出一个 $0$，在四个数一组不断输出 $0110$ 直到位数达到 $n$。

**AC code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	n--;
	if(n%4!=0){
		printf("-1");
		return 0;
	}
	putchar('0');
	for(int i=1;i<=n/4;i++)printf("0110");
	return 0;
}
```


---

## 作者：__Allen_123__ (赞：5)

upd on 2022.10.28：

修改了一个错误：当 $n = 1$ 时也无解。

---

### 题意简要描述

给定一个长度为 $n$ 的 $01$ 串，使得串中长度为 $2$ 的子串 $01,00,10,11$ 出现的次数相等，或报告无解。

### 思路：

我们知道，一个长度为 $n$ 的字符串中，长度为 $2$ 的子串数量为 $n - 1$。

而要使 $01, 00, 10, 11$ 这些长度为 $2$ 的字符串出现的次数相等，就要使它们的出现次数总和为 $4$ 的倍数（否则总有几个子串的出现次数与其他的不相等），即 $(n - 1) \bmod 4 = 0$，也就是 $n \bmod 4 = 1$。

所以，我们在读入 $n$ 时，如果 $n \bmod 4 \ne 1$，那么就可以直接输出 `-1`。**特殊地，当 $n = 1$ 时，也无法构造满足条件的字符串，也要输出 `-1`。**

如果 $n \bmod 4 = 1$ 且 $n \ne 1$，那该怎么输出字符串呢？

我们来分析样例 $2$。此时输入 $n = 5$，满足有解的条件。

输出构造了一个满足条件的 $01$ 串 $00110$，我们通过这个样例来寻找规律，可以通过字符串拼接的方式来得出可行解。

分析这个样例，它的长度为 $2$ 的子串的出现顺序为 $00, 01, 11, 10$。我们可以将 $0110$ 继续插入这个字符串后面，例如 $001100110$ 就满足条件（各出现 $2$ 次）。

于是，有解输出的做法就出来了：在输出最初的 $0$ 后，再输出 $\lfloor \frac{n}{4} \rfloor$ 个字符串 $0110$，就可以得到一个可行解。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d", &n);
	if(n % 4 != 1 || n == 1){ // n % 4 不等于 1 或 n = 1，报告无解
		printf("-1");
		return 0;
	}
	printf("0");
	for(int i = 1;i <= n / 4;i++){ // 直接输出
		printf("0110");
	}
	return 0;
}
```

---

~~说句闲话：为什么赛时我T2过了T1没过啊。~~

---

## 作者：sunkuangzheng (赞：4)

**【题目分析】**

一道构造题。

注意以下提到“子串”的概念都指的是**连续的**数字串。

首先考虑什么时候会无解。长度为 $n$ 的数字串有 $(n-1)$ 个长度为 $2$ 的子串。然后因为 $4$ 种子串出现的次数必须相等，因此 $(n-1)$ 必须是 $4$ 的倍数，否则无解。

然后考虑如何构造。我们参考样例的构造，`00110` 能给我们一点启示。我们每次都循环输出 `0110`，已经满足了 `01`、`11` 和 `10` 的出现次数相等。最后的 `0` 和下一个前面的 `0` 补成一个 `00`，刚好满足条件。然后只需要在最前面输出一个 `0` 即可。

**【完整代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    if((n-1) % 4 != 0){
    	cout << "-1";
    	return 0;
	}
	cout << "0";
	for(int i = 1;i <= (n-1) / 4;i ++){
		cout << "0110";
	}
	return 0;
}
````

---

## 作者：Vct14 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8589)

------------

在一个长度为 $n$ 的 $01$ 串中，长度为 $2$ 的 $01$ 串共有 $n-1$ 个。

因为题目要求四种长度为 $2$ 的 $01$ 串数量相等，所以 $n-1$ 一定是 $4$ 的倍数，那么如果 $n-1$ 不是 $4$ 的倍数，那就无解。

如果有解，我们还要构造一个满足条件的 $01$ 串。这里可以采用找规律的方法。

以下是我找的规律：

|  长度|  $01$ 串|
| -----------: | -----------: |
|  $1$|  $0$|
|  $5$|  $00110$|
|  $9$|  $001100110$|
|  $13$|  $0011001100110$|

可以发现，如果长度为 $4x+1$，就可以构造为 “ $001100110......0110$ ” ，第一个 “ $0$ ” 后共有 $x$ 个“ $0110$ ” 。

代码如下：
```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n;
	cin>>n;
	if((n-1)%4) cout<<-1;
	else{
		cout<<"0";
		for(int i=1; i<=(n-1)/4; i++) cout<<"0110";
	}
	return 0;
}
```
注释版：

```c++
#include<bits/stdc++.h>//万能头
using namespace std;//命名空间

int main(){
	int n;//定义长度
	cin>>n;//输入长度
	if((n-1)%4) cout<<-1;//如果n-1不是4的倍数，就无解，输出-1
	else{//n-1是4的倍数
		cout<<"0";//先输出第一个0
		for(int i=1; i<=(n-1)/4; i++) cout<<"0110";//输出(n-1)/4（即上文x）个“0110”
	}
	return 0;//华丽结束
}
```

---

## 作者：Convergent_Series (赞：1)

首先可以算出 $n<4$ 时无解。
 
观察到 **特殊性质** 中的 $n\bmod4=0$ , 说明是否有解与$n\bmod4$ 的结果有关。
接下来分类讨论：

---
$n\bmod4=0$ 时，为保证 $\texttt{00}$ 和 $\texttt{11}$ 的数量足够，字符串必须形如$\texttt{aabb...aabb}$ 或 $\texttt{abba...abba}$ 。以上两种形式均不符合题意，所以 $n\bmod4=0$ 时无解。

$n\bmod4\ne0$ 时，字符串必为 n 个 $\texttt{aabb}$ 加上一个长度在 $5\sim 8$ 之间的满足题意的串。dfs 或手动模拟可得， $n\bmod4\ne1$ 时无解。

dfs 代码：

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
long long n,k01,k10,k00,k11,a[10];
void dfs(int t)
{
	int i;
	if(t==n+1)
	{
		k01=k00=k10=k11=0;
		for(i=1;i<n;i++)
		{
			if(a[i]==0&&a[i+1]==0) k00++;
			if(a[i]==0&&a[i+1]==1) k01++;
			if(a[i]==1&&a[i+1]==0) k10++;
			if(a[i]==1&&a[i+1]==1) k11++;
		}
		if(k01==k00&&k00==k10&&k10==k11)
		{
			for(i=1;i<=n;i++) cout<<a[i];
			cout<<endl;
		}
		return;
	}
	for(i=0;i<=1;i++)
	{
		a[t]=i;
		dfs(t+1);
	}
}
int main()
{
	cin>>n;
	dfs(1);
	return 0;
} 
```

在 $n\bmod\bmod4=1$ 时，字符可为 $(n\bmod4)- 1$ 个 $\texttt{0011}$ 加上 $\texttt{00110}$。

代码如下：
```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
long long n,k;
int main()
{
	long long i,j;
	cin>>n;
	if((n%4!=1)||(n<4)){ //判断无解
		printf("-1");
		return 0;
	}
	if(n%4==1){ //有解
		i=n/4-1; //0011的个数
		for(j=1;j<=i;j++) printf("0011");
		printf("00110");
		return 0;
	}
	return 0;
} 
```
祝大家CSP-J RP++~

---

## 作者：_JF_ (赞：1)


~~小清新~~简单构造题。

构造一个长度为 $n$ 的仅包含 $0$，$1$ 的数字串，满足 $01$，$00$，$10$，$11$ 出现的次数相等。反之报告无解。

经过对于这四个数的模拟组合发现，它们组成最短长度必然超过 $5$，如果 $n<5$ 必然无解。

因为要这四个数出现的次数相等，我们不妨把这四个数出现一次捆绑地打包在一起，输出 $n/len$ 次，这样就可以保证出现次数相等。

经过对这四个数构造，会出现这样的合法情况：

1. $01100$

2. $00110$

我们发现，他们的总长度都为 $5$ 且末位为 $0$。注意，在构造下一组的时候，我们只用填充 $0110$ 上去即可。

根据上面的论述，我们可以得出，只有长度是 $(n-5)\bmod4=0$ 时才有解。

$Code$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
int main()
{
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	int n;
	cin>>n;
	if(n<5)
		puts("-1"),exit(0);
	if(n==5)
		cout<<"01100"<<endl,exit(0);
	if((n-5)%4==0)
	{
		cout<<"01100";
		for(int i=1;i<=(n-5)/4;i++)
			cout<<"0110";
	}
	else
		cout<<"-1"<<endl;
	return 0;
}

```

---

## 作者：Dregen_Yor (赞：1)

### [更好的阅读体验]( http://dregen-yor.eu.org/index.php/2022/10/27/p8589/)。

# 思路

我们先来看下面这个字符串 `0110`。

在这个字符串中，我们发现 `01`，`11`，`10`，都出现了一次，而且当这个字符串连续出现的时候，即 `01100110`，我们不难发现，`01`，`11`，`10` 和 `00` 出现的次数分别为 $2$，$2$，$2$ 和 $1$。为了弥补上 `00` 与其他字符串相差的 $1$，我们可以在字符串的最前面补加一个 `0`，即 `0011001100110`，这种情况下只要最后一个 `0110` 能完整地出现，那么一定可以构成题目中要求的字符串，也就是说，我们只需要判断 $(n-1)$ 能否被 $4$ 整除即可。

若能被 $4$ 整除，因为 `0110` 是以 $4$ 为周期循环出现的，那么最后一个 `0110` 一定可以完整地出现。

若不能被 $4$ 整除，最后会出现 `0`，`01`，`011`等情况，显然 `01`，`11`，`10`，`00` 出现的次数不相等。

**注意要特判 $n=1$ 的情况。**
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    if((n-1)%4==0&&n!=1){
        putchar('0');
        for(int i=1;i<=(n-1)/4;i++){
            printf("0110");
        }
    }
    else {
        puts("-1");
    }
    return 0;
}
```


---

## 作者：YH_Eternally (赞：1)

## 题意
构造一个长度为 $n$ 的 $\tt01$ 数字串，满足 $\tt 00,01,10,11$ 出现的次数相等，如果无解，输出 `-1`。

## 思路
首先需要明确当 $(n-1)\bmod 4\not=0$ 时，一定无解，因为当字符串长度为 $n$ 时，$\tt 00,01,10,11$ 一共会出现 $n-1$ 次，如果 $n-1$ 不是 $4$ 的倍数，那么 $\tt 00,01,10,11$ 出现的次数一定不等。反之当 $(n-1)\bmod4=0$ 时，即 $n-1$ 为 $4$ 的倍数时，一定有解，解就是 $\tt 00110$ 加上 $(n-5)\bmod4$ 个 $\tt 0110$。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();}
    return x * f;
}

int main() {
	int n = read();
	if(n == 1) {
		printf("1\n");
		return 0;
	}
	else if(n == 2 || n == 3 || n == 4 || n == 6) {
		printf("-1\n");
		return 0;
	}
	else if(n == 5) {
		printf("00110\n");
		return 0;
	}// 特判 n 小于等于 5 的情况
	else {
		if((n - 1) % 4 == 0) {// 有解情况判断
			printf("00110");
			n -= 5;
			while(n != 0) {
				printf("0110");// 输出 00110 加上 (n - 5) % 4 个 0110
				n -= 4;
			}
			printf("\n");
			return 0;
		}
		else {// 无解
			printf("-1\n");
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：二叉苹果树 (赞：0)

需要构造出一个长度为 $n$ 的 $01$ 串， 使得给出的 $4$ 个子串的出现次数相等。

对于 $2$ 位长的 $01$ 串，长度为 $n$ 的 $01$ 串中显然包含了 $n-1$ 个。要求 $4$ 个子串的出现次数相等，显然有 $4 \mid \left(n-1\right)$ 。

也就是说，当且仅当 $n=4k+1,k\in \mathbb{N+}$ 时，存在符合题意的构造。

我们只需要先构造出一个满足 $01,00 ,10,11$ 个出现 $1$ 次的 $5$ 位  $01$ 串即可。如何构造？不用构造，样例里已经给出了 $00110$。

接下来，对于 $n > 5$，我们只需要用符合题意的 $4$ 位 $01$ 串在之前的 $01$ 串后接着拼即可。对于 $00110$ ，这个 $4$ 位 $01$ 串也就是 $0110$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    if((n-1)%4!=0)
    {
        printf("-1\n");
        return 0;
    }
    n=(n-1)/4-1;
    printf("00110");
    for(int i=1;i<=n;i++)
        printf("0110");
    printf("\n");
    return 0;
}
```


---

## 作者：xiaohaoaibiancheng66 (赞：0)

# 思路
由于在长度为 $n$ 的字符串里有 $n-1$ 个**长度为 $2$ 的**子串，所以如果 $n-1\bmod 4=0$ 才可构造出合法字符串。

构造合法字符串，可以通过连续 `00`、`01`、`11`、`10` 来构造。则最终字符串为 `00110011001100110...`，即一个 `0` 再加上 $\lfloor\dfrac{n}{4}\rfloor$ 个 `0110`。由于 `0110` 的最后一位为 `0`，所以新的 `0` 可以与它对接成 `00`，所以该字符串合法。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(0);
	int n;
	cin>>n;
	if(n%4!=1)//不存在的情况
	{
		cout<<"-1";
		return 0;
	}
	int x=n/4;
	cout<<"0"; 
	for(int i=0;i<x;i++)cout<<"0110";
	return 0;
}
```

---

## 作者：KK_lang (赞：0)

## 题目大意

已知一个字符串中包含 $01$，$11$，$10$，$00$ 的数量一样，给出字符串长度，求是否可行及可行情况

## 思路

看到这道题，我们先要想到满足条件的字符串最短情况与常见样子

我们发现：$01$ 与 $00$ 可以“粘”成 $001$，$001$ 与 $10$ 可以“粘”成 $1001$，$11$ 与 $1001$ 可以粘成 $11001$ 或 $10011$。

不妨另 $10011$ 为最短情况，此时四个子串各出现了 $1$ 次，我们看看各出现 $2$ 次时它长什么样子。

其实就是两个 $10011$ 粘在一起，可以粘成 $100110011$，经检验，确实是最短的一种情况。

到了这里，其实已经有规律了，为了验证思想，再看看各出现 $3$ 次的情况。那就再粘一个 $10011$，就变成了 $1001100110011$。

到了这里，规律已经很明显了。

规律为：$1001100110011$...$0011$，实际上就是前面一个 $1$，后面一堆 $0011$ 的情况。

有人问了，这是唯一情况吗？会发现是的。如果减去了任意一个数字，就会有两项的数量减去 $1$，剩下两项仅一个重叠，为保证条件，必须再删掉 $3$ 个数字。归根结底，还是回到了规律表示的那种形式。

所以，判断 $n$ 是否可行，是需要看看 $(n-1) \bmod\text{ } 4$ 的余数是否为 $0$，为 $0$ 就可行，按照规律输出就行了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    if (n % 4 != 1) cout << -1 << endl;
    else
    {
        cout << 1; // 前面一个 1
        for (int i = 1; i <= (n - 1) / 4; i++) cout << "0011"; // 后面一堆 0011
    }
    return 0;
}
```

---

## 作者：TheShuMo (赞：0)

~~比赛的时候这道题忘记交了……~~
## 题意简述
题目要求构造一个长度为 $n$ 的 $01$ 序列，使得其中 $01,00,10,11$ 的出现次数相同。

## 思路
注意数据范围：$n \leq 10^6$ 所以这道题肯定不能用一般的暴力构造，我们必须寻找规律。

因为是构造 $01$ 字符串，我们把题目所需的四个 $01$ 重新排列一下，变成 $00,01,11,10$，这样每个数的最后一个字符与下一个数的第一个字符就是相同的。

于是将它拼起来就成了 $00110$，不难发现其中首与尾是相同的，那么如果把两个该序列拼在一起，那么就会多出一个 $00$，但如果我们在第一位放一个 $0$，其它位反复放 $0110$ 就可以满足题目所要求的构造。

综上所述，只要这个数 $(x-1) \equiv 0\pmod 4$，那么这个数就可以被以上的方法构造出来，否则输出 $-1$ 即可

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	if((n-1)%4!=0){
		cout<<-1;
	} else {
		for(register int i=(0);i<n;i++){
			if(i%4<2)putchar('0');
			else putchar('1');
		}//构造
	}
}
```

---


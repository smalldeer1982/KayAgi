# Digital Fortress

## 题目背景

布林克霍夫大声喊道：“这当然是密码！这不是密码，还能是什么？还有什么原因能让友加送掉这枚戒指？到底是谁在戒指上刻一大串杂乱无章的字母？”

方丹愤怒地等了布林克霍夫一眼，使他安静了下来。

“啊……伙计们？”贝克插了一句话，似乎很不情愿卷进来一样，“你们一直说这些是杂乱无章的字母。我想我应该让你们知道……这枚戒指上刻的字母并不是杂乱无章。如果你近距离看一下，就会明白，实际上，这些字母……这个……这个是拉丁文。”

指挥台上的所有人都看向了那枚戒指。上面写道：

> Quis custodiet ipsos custiodies.  
谁来监视这些监视者……

## 题目描述

致命的变异串已经穿过了 X-11 过滤器，深入了国安局数据库。苏珊与贝克需要即时破解出密码，以关闭蠕虫病毒。

在蠕虫的文件中，他们找到了密码的一个特点：

- 共有 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。
- 如算出前缀异或和，那么前缀异或和也单调不减。
- 如算出后缀异或和，那么后缀异或和仍然单调不减。

除此之外，他们也找到了 $n,m$ 的值。现在，他们需要构造出一组密码，以满足所有特征。
***

#### 【形式化题意】

求是否存在长度为 $n$，所有元素都在 $[1,m]$ 范围内的单调不减正整数序列 $a$，满足：

- $\forall1<i\le n,a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i-1}\le a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$
- $\forall1\le i<n,a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i+1}\le a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$

如存在，输出一组合法解。多组数据。

## 说明/提示

#### 【样例解释】

对于第一组数据，密码的前缀异或和为 $\{1,7,15,31\}$，后缀异或和为 $\{16,24,30,31\}$，均为递增序列，满足题意。

对于第二组数据，不存在任何合法方案。

#### 【数据范围】

**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n\le$|$m\le$|
|:-:|:-:|:-:|:-:|
|$0$|$10$|$5$|$200$|
|$1$|$30$|$20$|$10^6$|
|$2$|$60$|$10^5$|$2^{63}-1$|

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le m\le2^{63}-1$，$1\le t\le50$。

## 样例 #1

### 输入

```
2
4 20
1919 114514
```

### 输出

```
Yes
1 6 8 16
No
```

# 题解

## 作者：chlchl (赞：5)

唯一打出正解的题，还是得写篇东西纪念一下（~~主要是这场比赛是拉满比赛分的关键一场~~）。

## 题意
求构造一个长度为 $n$ 的序列，每个数都在 $[1,m]$ 之间，使得前缀、后缀异或和均递增。

## Solution
这个题非常像 CF 的 A，构造的签到题。

首先有个贪心的结论，只要我们能够知道最大数的最小值，就能快速判断是否能构造。

考虑异或和持续变大是什么情况。每次异或和若想变大，显然需要将高位的某一位变成 $1$。以此类推，$n$ 个数的异或和要想递增，至少需要有 $n$ 位是 $1$，这个结果肯定是最小的。

考虑当刚好 $n$ 位是 $1$，即前 $n$ 个数的异或和为 $2^n-1$ 时，每个数是什么。显然每一个数只能够是 $2^i$，因为一共只有 $n$ 位是 $1$，所以每个数都只能够有一位是 $1$。

题目要求递增，我们就令 $a_i=2^{i-1}$，注意 $1=2^0$，也是符合条件的。

由于异或和只是一个 $0,1$ 变换的过程，而且按上面的构造，$1$ 之间的位置是不影响的，所以只要前缀和递增，后缀和显然也是递增的。

判断无解也很简单，如果 $2^{n-1}>m$，就无解了。

但是注意这东西似乎不能用位运算，$2^{100000}$ 会炸掉，有两种解决方案：一种是使用 `__lg` 函数反向判断（考场用的 `log2`，hack 添加之后就丢精了），即 $\log_2m+1$ 和 $n$ 的大小关系；第二种是特判，如果 $n>63$ 必定无解（$m\leq 2^{63}-1$）。

就喜欢 T1 放这种诈骗了又好像没有诈骗的题目 qwq。

```cpp
#include<bits/stdc++.h>
using namespace std;

int T, n;
long long m;

int main(){
	scanf("%d", &T);
	while(T--){
		scanf("%d%lld", &n, &m);
		if(__lg(m) + 1 >= n){
			printf("Yes\n");
			for(int i=0;i<n;i++)
				printf("%lld ", (1ll << i));
			printf("\n");
		}
		else
			printf("No\n");
	}
	return 0;
} 
```


---

## 作者：Register_int (赞：5)

签到题。

不减是假的，否则会出现相邻两数相同或数列中数为 $0$ 的情况。

容易发现有构造 $a_i=2^{i-1}$，正确性显然，现在证明其最优性。

先证明一个推论：二进制位递增是该数列递增且前缀异或和递增的充要条件。

必要性证明：设 $s_i$ 为 $a_{1\sim i}$ 的异或和，在数列中有两个相邻的数 $a_i,a_{i+1}$ 满足 $2^k\le s_i<a_{i+1}<2^{k+1}$，根据异或的性质，最高位必定变为 $0$，则 $a_i\ \text{xor}\ a_{i+1}<2^k$，与递增性质矛盾。归纳后得证。

充分性证明：当数列满足该条件时，由于异或运算中高位不受低位影响，所以递增性质与低位无关。

由于该条件，将除最高位外所有位置 $0$ 为值域最小的解法：$\{1,10,100,1000,\cdots\}_2=\{2^0,2^1,2^2,2^3,\cdots\}_{10}$。并且，该构造同时满足第二条性质。所以其最优性得证。

具体解法：当 $m<2^{n-1}$ 时判断无解，否则输出 $a_i=2^{i-1}$。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int t, n; ll m; 

int main() {
	for (scanf("%d", &t); t--;) {
		scanf("%d%lld", &n, &m);
		if (__lg(m) + 1 < n) puts("No");
		else { puts("Yes"); for (int i = 0; i < n; i++) printf("%lld ", 1ll << i); puts(""); }
	}
}
```

---

## 作者：1qaz234Q (赞：3)

### 题意简述
有 $t$ 组数据，对于每组数据，输入 $n,m$。构造出一组 $n$ 位密码，每个数都在 $\left[1,m\right]$ 之间，并且单调不减，前缀异或和与后缀异或和都单调不减。
### 题目分析
把样例转换为二进制：
- $1=\left(1\right)_2$
- $6=\left(110\right)_2$
- $8=\left(1000\right)_2$
- $16=\left(10000\right)_2$

不难发现，每一位二进制位恰好对应一个数字。

为了让每个数都在 $\left[1,m\right]$ 之间，我们要让每个数都尽可能小。我们把第 $1$ 个二进制位给第 $1$ 个数，把第 $2$ 个二进制位给第 $2$ 个数，把第 $3$ 个二进制位给第 $3$ 个数……第 $n$ 个二进制位给第 $n$ 个数，能使每个数都尽可能小。

循环 $t$ 次，对于每组数据，$ans$ 的初始值为 $1$，用 for 循环，每次让 $ans\times2$，如果 $ans>m$，输出 No，跳出循环。否则输出 Yes，再用 for 循环计算并输出密码。注意要开 unsigned long long。

时间复杂度为 $O(t\times n)$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
signed main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n, m, ans = 1; // ans的初始值设为1
        bool flag = 1;     // flag=1时表示有解，flag=0时表示无解
        cin >> n >> m;
        for (int i = 2; i <= n; i++)
        {
            ans *= 2;
            if (ans > m) // 如果无解
            {
                cout << "No" << endl;
                flag = 0;
                break;
            }
        }
        if (flag) // 如果有解
        {
            ans = 1;
            cout << "Yes" << endl << "1 ";
            for (int i = 2; i <= n; i++)
            {
                ans *= 2;           // 计算密码
                cout << ans << " "; // 输出密码
            }
            cout << endl;
        }
    }
}
```

---

## 作者：gesong (赞：1)

题目传送门：[P8942 Digital Fortress](https://www.luogu.com.cn/problem/P8942)。
# 前置知识
异或 $\oplus$ 运算分为四种情况，分别是：

- $1\oplus 0=1$
- $0\oplus 1=1$
- $1\oplus 1=0$
- $0\oplus 0=0 $

# 思路

我们发现当这个序列为 $\{1,2,4,8,16,\cdots\}$ 时，就可以满足题意，因为他们的二进制序列为 $\{1,10,100,1000,10000,\cdots\}$，而二进制前缀异或和为 $\{1,11,111,1111,11111,\cdots\}$，后缀异或和为 $\{10000000\cdots,11000000\cdots,11100000\cdots,11110000\cdots,11111000\cdots,\cdots\}$，我们发现他们均满足题目中的单调不减，因此只要这样构造序列即可。

方法就是，把长度为 $n$ 的上述序列求出，判断一下是否在 $[1,m]$ 的范围内即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int a[1234567];
main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int ans=1;
		int cnt=0;
		bool flag=0;
		for (int i=1;i<=n;i++){//构造序列
			if (ans>m){//不在 [1,m] 中
				cout <<"No\n";
				flag=1;
				break;
			}
			a[++cnt]=ans;
			ans*=2;
		}
		if (flag) continue;
		cout <<"Yes\n";
		for (int i=1;i<=cnt;i++) cout <<a[i]<<" ";//输出序列
		cout <<endl;
	} 
    return 0;
}
```

---

## 作者：_shy (赞：1)

## [P8942 Digital Fortress](https://www.luogu.com.cn/problem/P8942)
### 思路
1. 观察样例的前缀异或和 $\{1,7,15,31\}$，发现是 $2^1-1,2^3-1,2^4-1,2^5-1$。去反推前缀异或和为 $2^1-1,2^2-1,2^3-1,2^4-1$ 时的原数集合，为 $2^0,2^1,2^2,2^3$，发现其后缀异或和同时不减。**推测 $2^0,2^1,\dots 2^{n-1}$ 为字典序最小（即最容易满足条件）的符合要求的集合。**
2. 证明 $2^0,2^1,\dots 2^{n-1}$ 为字典序最小的集合，**数学归纳法**。当 $n=2$ 时，$1,2$ 显然符合前缀异或和的要求。假设当 $n=k-1$ 时，$2^0,2^1,\dots 2^{k-2}$ 符合前缀异或和的要求。当 $n=k$ 时，$2^0\operatorname{xor}2^1\dots2^{k-2}\operatorname{xor}2^{k-1}=(11\dots11)_2$。而对 $\forall a_{k}\in[2^{k-2},2^{k-1})$，都会使得 $(11\dots11)_2$ 中除了最后一个 $1$ 变为 $0$ 外，前面的 $1$ 中总会有若干个变为 $0$，此时 $2^0\operatorname{xor}2^1\dots2^{k-2}>2^0\operatorname{xor}2^1\dots2^{k-2}\operatorname{xor}a_k$。故 $2^0,2^1,\dots,2^{k-1}$ 符合前缀异或和的要求。后缀异或和符合要求同理可证。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long bt[100];
int t, n;
long long m; 
int main ()
{
	bt[0] = 1;
	for (int i = 1; i <= 62; i++) 
		bt[i] = bt[i - 1] * 2;
	scanf ("%d", &t);
	while (t --) 
	{
		scanf ("%d %lld", &n, &m);
		if (n - 1 >= 63) 
		{
			printf ("No\n");
			continue;
		}
		if (bt[n - 1] > m) 
		{
			printf ("No\n");
			continue;
		}
		printf ("Yes\n");
		for (int i = 0; i <= n - 1; i++)
			printf ("%lld ", bt[i]);
		printf ("\n");
	}
	return 0;
}

```


---

## 作者：JuRuoOIer (赞：0)

# 题解 P8942 Digital Fortress

~~赛时唯一 AC 的题目……~~

### Part1 题意

[传送门](https://www.luogu.com.cn/problem/P8942)

给定 $n,m$，求是否存在一个数组 $a$，其所有项都在 $1$ 和 $m$（含）之间，且满足：

- 单调不减
- 前缀异或和单调不减
- 后缀异或和单调不减

$n \le 10^5,m \le 2^{63}-1$。

### Part2 思路

想让前缀异或和单调不减，而原数组也要单调不减，所以**从前往后每一个数字都必须比上一个多至少一个二进制位**。可以简单证明：

- 如果 $a_1 \oplus a_2 \oplus ... \oplus a_i-1$ 二进制有 $k$ 位，那么 $a_1$ 至 $a_i-1$ 肯定至少有一个二进制有 $k$ 位的数。
- 如果 $a_i$ 二进制不到 $k$ 位，那显然不满足单调不减。
- 如果 $a_i$ 二进制刚好 $k$ 位，那前缀异或和的最高位就会变成 $0$，不满足前缀异或和单调不减。
- 如果 $a_i$ 二进制超过 $k$ 位，则前缀异或和肯定和 $a_i$ 位数相同，因为 $a_i$ 最高位为 $1$，而前缀异或和这一位是 $0$（$a_i$ 超过 $k$ 位），异或后为 $1$。

这样后缀异或和也是单调不减的（原因很明显）。

又因为 $a_i$ 的值是有限制的，所以直接贪心思想，每次只多一位，也就是 $a_i=2^{i-1}$。当 $2^{n-1}>m$ 时无解。时间复杂度 $\text{O}(n)$。

### Part3 代码

注释在代码里啦！

```cpp
#include<bits/stdc++.h>
//由于太长，此处省略快读快输，可以在我的个人主页找到。
//如果你用 int128 的话必须使用循环或快读快输进行输入输出。
//1<<n 即 1 左移 n 位，也就是二进制里 1 后接 n 个 0，等于 2^n。 
#define ull unsigned long long//会爆 long long 
using namespace std;
ull n,m,t; 
ull check(){//判无解 
	ull tmp=63;
	while((1ull<<tmp)>m){//这里要 1ull，防止爆掉！ 
		tmp--;
	}
	return tmp+1;
}
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(check()<n){
			cout<<"No\n";
			continue;
		}
		cout<<"Yes\n";
		for(ull i=0;i<n;i++){
			cout<<(1ull<<i)<<' ';//这里也要 1ull，防止爆掉！ 
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：maomao233 (赞：0)

#### 题外话
~~为啥我的方法那么复杂~~

### 题意
有一个密码共 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。如算出前缀异或和，那么前缀异或和也单调不减。如算出后缀异或和，那么后缀异或和仍然单调不减。给定 $n,m$ 的值，让你构造出一组密码，以满足所有特征。对于每组数据，如不存在满足要求的密码，输出 `No`。否则输出 `Yes`，并在下一行输出一种合法方案。

### 分析
首先我们得知道**前缀异或和**与**后缀异或和**的含义。异或是一种逻辑运算，通常以 $\text{xor}$ 来表示，其**相当于不带进位的二进制加法**。例如 $1$ 异或 $2$ 等于 $3$。详细资料可查看[百度百科](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。这里前缀异或和就表示：
$$
a_1\le \ a_1\ \text{xor}\ a_2\ \le \ a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{n-1}\ \text{xor}\ a_{n}
$$

后缀异或和也是一个道理，从后往前。

既然这是道构造题，那我们来枚举一下：如果一个 $3$ 位的密码是 $1,2,3$，那么 $1\ \text{xor}\ 2\ \text{xor}\ 3$ 的结果就是 $0$ 了。那我们把第 $3$ 位改成 $4$ 呢？这样 $1\ \text{xor}\ 2\ \text{xor}\ 4$，结果是 $7$，满足上面的条件。再接着往下枚举，我们很容易就能发现构造一个为 $1,2,4,8,16\cdots$ 的密码是可行的。

再看一眼数据范围，$1\le m\le2^{63}-1$，要开 `long long`。同时出题人写 $2^{63}-1$ 而不是 $10^{18}$ 可能也是想提示我们从 $2$ 的角度去思考。那我们就可以把 $2$ 的 $64$ 次方以内的表先打出来，然后按照上面讲的模拟即可。其实还是比较好理解的。

最后注意 $2^{64}$ 会爆 `long long`，所以我们把 `long long` 换成 `unsigned long long` 就可以过了。


------------


### 打表代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	unsigned long long n=1;
	cout<<n<<",";
	for(int i=2;i<=64;i++)
	{
		n*=2;
		cout<<n<<",";
	}
    return 0;
}
```


### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long a[65]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,9223372036854775808};
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		long long m;
		cin>>n>>m;
		bool flag=0;
		for(int i=2;i<=n;i++)
		{
			if(a[i]>m)//如果1~m范围内放不下这个2的几次方，就是无解的。 
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			puts("No");
		}
		else
		{
			puts("Yes");
			for(int i=1;i<=n;i++)
			{
				cout<<a[i]<<" ";
			}
			puts("");
		}
	}
    return 0;
}
```


---


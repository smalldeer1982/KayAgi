# 「GLR-R4」立夏

## 题目背景

&emsp;&emsp;「芳菲歇去何须恨，夏木阴阴正可人」

---

&emsp;&emsp;和老 V 说好的赛后团建终于举行啦！

&emsp;&emsp;难得和学弟学妹们在一起，天依和阿绫自然不会错过这次良好的机会，更不会放过早就想 rua 的狐狸座的耳朵！

&emsp;&emsp;“那个……天依……”

&emsp;&emsp;天依和腿上的狐狸座同时歪过头看向某个叫阿绫的醋坛子。

&emsp;&emsp;“绫姐绫姐，疼！”

&emsp;&emsp;于是在天依给小狐狸扎头发的时候，小狐狸的耳朵已经被揉蔫啦！

---

&emsp;&emsp;**立夏**&emsp;「三步并两步　就发现　如期而至的透明夏日章节」

## 题目描述

&emsp;&emsp;**本题提供简要题意。**

&emsp;&emsp;天依给狐狸座准备的纱质发绳由**白色**和**紫色**的小格子组成，相同大小的小格子连成了一条足够长的带子。我们不妨把天依的手正捏着的位置标为第 $0$ 格，向右依次是第 $1$ 格、第 $2$ 格，等等；向左依次是第 $-1$ 格，第 $-2$ 格，等等；天依将发绳对折起来，此时第 $-1$ 格将于第 $1$ 格重合，第 $-2$ 格将于第 $2$ 格重合……第 $-k$ 格将与第 $k$ 格重合（$k$ 为正整数）。**特别地**，我们认为第 $0$ 格保持原样，没有和其他格子重合，也没有和自己重合。

&emsp;&emsp;由于发绳是半透光的，所以对折起来的发绳上的格子将可能出现三种颜色：**白色**、**浅紫色**和**深紫色**。两个白色的格子重合呈现白色，一个紫色和一个白色的格子重合呈现浅紫色，两个紫色的格子重合呈现深紫色。**特别地**，若第 $0$ 格原来为白色，则折叠后也为白色，否则第 $0$ 格原来为紫色，则折叠后为浅紫色。

&emsp;&emsp;如果把白色记作 $0$，浅紫色记作 $1$，深紫色记作 $2$，以折叠后的第 $0$ 格作为最低位，依次将每个格子颜色对应的数字记录下来，我们将得到一个长长的三进制数整数，记为 $x$。现在，天依告诉你了 $x$ 的值，你能算出**对折之前的发绳**有多少种不同的样式吗？称两条发绳颜色不同，当且仅当存在一个整数 $k$，使得两条发绳的第 $k$ 格上的颜色不相同。

&emsp;&emsp;发绳款式丰富多样，你需要对 $T$ 个 $x$ 分别求出答案。

### 简要题意

&emsp;&emsp;对于一个包含整数的集合 $S$，定义其权值为 $\sum_{a\in S}3^{|a|}$（即，枚举 $S$ 的元素 $a$，计算 $3^{|a|}$ 并求和）。给出非负整数 $x$，计算有多少个集合的权值为 $x$。注意集合不能包含重复元素。

## 说明/提示

#### 样例 #1 解释

$x=12$ 时，有四种可能的发绳样式，它们的紫色格子位置分别是 $\{-1,-2\}$，$\{-1,2\}$，$\{1,-2\}$，$\{1,2\}$。

$x=2$ 时，不存在任何满足条件的发绳样式，此时输出 $0$ 即可。

### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq T \leq 10^5, 0 \leq x \leq 10^{18}$。

对于不同的测试点，作如下约定：

| 测试点编号 |       $x$        | 特殊性质 |
| :--------: | :--------------: | :--------: |
|    $1\sim3$     |      $\leq 3^{10}$      |   无   |
|    $4$     |  $\leq 10^{18}$ |   $x \bmod 3 = 1$    |
|    $5$     |    $\leq 10^{18}$     |  $x \bmod 3=2$   |
|    $6$     |   $\leq 10^{18}$   |  $x \bmod 3 =0$   |
|    $7\sim10$     |   $\leq 10^{18}$   |  无  |

## 样例 #1

### 输入

```
2
12
2```

### 输出

```
4
0```

# 题解

## 作者：pomelo_nene (赞：9)

大家好，我是只会出签到题的退役壬！这里写份题解。

因为集合里面每一个数的权值都是 $3$ 的幂次，不难考虑三进制。将 $x$ 写成三进制数之后考虑。

首先观察，如果 $x={(\dots 2)}_3$，因为 $3^0$ 只能选一个，所以答案一定是 $0$。

再考虑其他位。如果 $3^x$ 要选两个或者零个，方案数为 $1$；否则可以选 $x$ 也可以选 $-x$，方案数为 $2$。每位互不影响（因为不会进位），所以可以直接乘法原理。

```cpp
int main(){
	LL T=read();
	while(T-->0)
	{
		LL k=read();
		if(k%3==2)
		{
			puts("0");
			continue;
		}
		k/=3;
		LL ans=1;
		while(k)
		{
			if(k%3==1)	ans*=2;
			k/=3;
		}
		write(ans),puts("");
	}
	return 0;
}
```

---

## 作者：Moon_Traveller (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P9154)

PS：没有使用简要题意

## 题意简述

有 $T$ 条半透明的发绳，每条发绳由**白色**和**紫色**的格子组成。将其从中间对折，会出现以下三种情况：

- 白色 + 白色 = 白色（记作 $0$）
- 白色 + 紫色 = 浅紫色（记作 $1$）
- 紫色 + 紫色 = 深紫色（记作 $2$）

特别的，对于最中间的格子，只会出现以下两种情况：

- 白色 = 白色（记作 $0$）
- 紫色 = 浅紫色（记作 $1$）

现在给出一个三进制数的十进制形式，表示对折后的发绳颜色，请你求出原始的发绳有几种颜色组成方案。

## 思路

不难发现，对折后如果一个格子的颜色为 $0$ 或 $2$，那么这个位置上的格子颜色组合就只有一种情况（即“白白”或“紫紫”）；而如果对折后格子的颜色为 $1$，则这个位置上两个格子的颜色组合有两种情况（即“白紫”和“紫白”）。

那么我们就可以将转换后的三进制数按位遍历，如果遇到 $1$，就将结果 $\times 2$，否则就 $\times 1$。因为 $\times 1$ 后的数值不发生变化，所以只需要判断前者即可。

还有一点需要注意一下，最中间的格子（即编号为 $0$ 的那个），颜色的判断与其他格子不同，所以要单独判断。如果颜色为 $0$ 或 $1$，则只有一种情况；如果颜色为 $2$ 则无解。这点可以由「题意简述」中的第二个列表得出。

具体看代码。

## 代码实现

```cpp
#include <iostream>
using namespace std;
#define int long long // 不开ll见祖宗

int T;
int x;

signed main()
{
    cin >> T;
    while(T--)
    {
        cin >> x;
        int ans = 1; // 一定要每次将结果初始化为1，这样既避免了多测不清空，又保证了运算之后结果的正确性
        if(x % 3 == 2) // 对于最中间的格子（即三进制数的最低位），判断如果为2，则无解
        {
            cout << 0 << endl;
            continue;
        }
        x /= 3; // 判断后将最低位删除，直接除以三即可
        while(x != 0) // 对x进行三进制分解，同时判断颜色
        {
            if(x % 3 == 1) // 如果颜色为1，则有2种情况，将结果乘2
            {
                ans *= 2;
            }
            x /= 3; // 判断之后即删掉这一位
        }
        cout << ans << endl; // 运算结束，输出结果
    }
    return 0;
}
```

---

## 作者：zenght (赞：2)

月赛 2A，整场月赛签到题（也是我唯一 AC 的一题 qwq）。

把 $x$ 化为三进制，我们发现 $0$ 格与其他格不一样，故单独考虑。最后求答案总数，由于决策中的一步无法影响决策中的另一步，故这是标准的乘法原理。

对于第 $0$ 格，当 $x$ 的三进制最后一位是 $0$ 或 $1$ 时，有一种选法；最后一位是 $2$ 时，没有选法，直接输出 $0$。

对于其他格子，如果 $x$ 三进制对应的数位上的数是 $0$，那么有一种选法；如果是 $1$，有两种选法，如果是 $2$，只有一种选法。

最后将所有位数上得到的选法数相乘即可。

请注意，为防止 ctj，此处仅提供部分代码。

```cpp
long long x, ans = 1;
cin >> x;
if (x % 3 == 2)
{
	cout << 0 << '\n';
	continue;
}
x /= 3;
while (x)
{
	if (x % 3 == 1) ans *= 2;
	x /= 3;
}
cout << ans << '\n';
```

点赞 + 评论 + 关注！

---

## 作者：Enderich (赞：1)

## 题目大意
诈骗题，把题意理解了就行了。

## 思路
看了题意后你可以发现小狐狸的发绳在折叠后只能为 $0$、$1$、$2$，而若想要“合成”$0$ 和 $2$，折叠前要么是两个白要么是两个紫，只有 $1$ 有两种情况。所以你可以把输入的 $x$ 先转成 $3$ 进制数，再去算一下有多少个 $1$，答案就是 $1$ 都出现个数（啊这里因为折叠前是折叠后完全对称过去，所以直接算折叠后的就行了）。

啊最后肯定要特判一下不符合的情况，即第 $0$ 位是深紫色，为 $2$ 的情况。

## code
```c++
/*
ID: enderch1
PROG:
LANG: C++
*/
#include<bits/stdc++.h>
#define change_max(a,b) a=max(a,b)
#define change_min(a,b) a=min(a,b)
#define int long long
using namespace std;

int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
void solve()
{
	int T=read();
	while(T--)
	{
		string s;
		int x=read();
		while(x)
		{
			s+=(x%3+'0');
			x/=3;//s存下三进制数，这里其实是反着存的，不过没有影响。
		}
//		cout<<s<<endl;
		int len=s.size(),ans=1;//累成器初始化。
		if(s[0]=='2') ans=0;//不合法时直接ans=0，0乘任何数等于0。
		for(int i=1;i<len;i++)
		{
			if(s[i]=='1') ans*=2;//结论。
		}
		printf("%lld\n",ans);
	}
}
signed main()
{
	solve();
	return 0;
}


```

## The End

---

## 作者：_H17_ (赞：1)

## 题目分析

首先把 $x$ 转换为三进制，如果原点是紫色那一定答案是 $0$，因为原点无论如何折都不可能。然后看其他位：如果是白色或紫色两个的颜色必然相同，不用考虑。对于浅紫色有白、紫和紫、白两种。

设：除去原点外浅紫色的个数为 $x$。  
则答案为 $2^x$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long //注意 long long 
using namespace std;
int T,n,cnt,qp(int);
signed main(){
    for(cin>>T;T;--T){
        cin>>n;cnt=0;
        if(n%3==2){
            cout<<"0\n";
            continue;
        }//不可能的情况
        n/=3;//下一位
        while(n){
            if(n%3==1)
                cnt++;//浅紫色
            n/=3;//下一位
        }
        cout<<(1ll<<cnt)<<'\n';
    }
    return 0;
}
```

---

## 作者：sto_5k_orz (赞：1)

显然，当 $x=0$ 时，答案为 $1$，$x \bmod 3=2$ 时，答案为 $0$。

先将 $x$ 在三进制数的情况。

假如某一位为 $2$，那么需要把这一位 $i$ 和 $-i$ 都选。

假如某一位为 $1$，那么在 $i$ 和 $-i$ 任选一个均可。

假如某一位为 $0$，需要 $i$ 和 $-i$ 均不选。

不过，如果当前是最后一位，就只有 $1$ 个位置。

那么显然方案数就是 $2^{f(\lfloor x/3 \rfloor)}$。$f(x)$ 表示 $x$ 在三进制下 $1$ 的个数。

---

## 作者：Iniaugoty (赞：1)

>芳菲歇去何须恨，夏木阴阴正可人


~~很棒，赛时又只 AC 了 Div.2 A。~~

***

# 题意简述

这里给出两版题意。

## 简版题意：

>&emsp;&emsp;对于一个包含整数的集合 $S$，定义其权值为 $\sum_{a\in S}3^{|a|}$（即，枚举 $S$ 的元素 $a$，计算 $3^{|a|}$ 并求和）。给出非负整数 $x$，计算有多少个集合的权值为 $x$。注意集合不能包含重复元素。

## 原版题意：

有一个序列 $a_i$，其中 $-k\le i\le k$。$a_i$ 只可能是 $0,1$。

还有一个序列 $b_i$，其中 $0\le i\le k$，在这个序列中：

$$b_i=\begin{cases}
a_i & i=0 \\ a_i+a_{-i} & i\not=0
\end{cases}$$

显然，序列 $b_i$ 只可能是 $0,1,2$，而 $b_0$ 只可能是 $0,1$。

现在给出一个 $k$ 位**三进制**数 $x$ 的十进制表示，求出有多少个序列 $a$，可以得到序列 $b$，使得 $b_i$ 刚好是 $x$ **从右往左**（从 $0$ 开始）第 $i$ 位上的数。

***

# 分析

这里给出针对两版题意的分析。

## 简版题意

把权值 $x$ 转化为三进制，从右往左（从 $0$ 开始）第 $i$ 位上可能有三种结果：

- $0$：说明 $S$ 中不存在绝对值为 $i$ 的数，即不存在 $i$ 和 $-i$，只有 $1$ 一种情况。

- $1$：说明 $S$ 中存在一个绝对值为 $i$ 的数，可能是 $i$，也可能是 $-i$，当 $i\not=0$ 时有 $2$ 种情况，否则只有 $1$ 种情况。

- $2$：说明 $S$ 中存在两个绝对值为 $i$ 的数，一个 $i$，一个 $-i$，当 $i\not=0$ 时有 $1$ 种情况，否则有 $0$ 种情况。

根据乘法原理，每一个 $i$ 的情况数的乘积即为答案。

## 原版题意

同样把 $x$ 转三进制数，求出序列 $b$。

对于 $b_0$：

- $b_0=2$ 是不可能的，如果遇到这种情况，答案就是 $0$。

- $b_0=1$ 或 $0$ 都只有 $1$ 种情况，即 $a_0=1$ 和 $a_0=0$。


对于 $b_{0<i\le k}$:

- $b_i=0$ 只有 $1$ 种情况，即 $a_i=0,a_{-i}=0$。

- $b_i=1$ 有 $2$ 种情况，即 $a_i=0,a_{-i}=1$ 和 $a_i=1,a_{-i}=0$。

- $b_i=2$ 只有 $1$ 种情况，即 $a_i=1,a_{-i}=1$。

答案依然是每一个 $i$ 的情况数的乘积。

***

# 解法

容易发现，把两版题意都分析一遍后，其实解法都是一样的。

如果 $x\bmod3=2$，答案为 $0$。

否则，按照分析中的模拟，累乘每一个 $i$ 的情况数。

***

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int t,x,ans;
signed main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&x);
		if(x%3==2)
			printf("0\n");
		else{
			ans=1,x/=3;
			while(x){
				if(x%3==1)
					ans<<=1;
				x/=3;
			}
			printf("%lld\n",ans);
		} 
	}
	return 0;
}
```

***

# 注意点

注意开 `long long`。

***

这个蒟蒻写的这么认真，点个赞再走罢~

---

## 作者：lilong (赞：0)

很显然地，除了 $3^0$ 只能选一次外，每个 $3$ 的幂最多可以用两次。于是我们可以类比二进制拆分的思路，依次枚举 $3$ 的幂，每次找到小于当前数的最大的幂并减去，统计次数，发现非 $0$ 次幂出现次数大于 $2$ 或 $0$ 次幂大于 $1$ 时则输出 $0$，否则运用乘法原理计数。

本人在赛时发现了一个规律：对于任意的 $a \equiv0 \pmod3$，都有 $ans_a = ans_{a+1}$。因此可以直接转换后计算。

代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int unsigned long long

using namespace std;

int inv[38];
int pd[38];
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

signed main()
{
	
	int T,ans,k;
	int n;
	inv[0] = 1;
	for( int i = 1 ; i <= 37 ; i ++ )
		inv[i] = inv[i - 1] * 3;
	cin >> T;
	while( T -- )
	{
		k = 0;
		memset( pd , 0 , sizeof(pd) );
		ans = 0;
		n = read(); 
		if( n % 3 == 0 ) n ++,k = 1;
		while( n > 0 )
		{
			int i;
			for( i = 0 ; i <= 37 ; i ++ )
			{
				if( inv[i] > n )
					break;
			}
			if( pd[i - 1] == 2 )
			{
				ans = 0;
				break;
			} 
			pd[i - 1] ++ ;
			n -= inv[i - 1];
			ans ++;
		}
		if( ans == 0 ||( pd[0] > 1 && !k)) cout << 0 << endl;
		else 
		{
			ans = 1;
			for( int i = 1 ; i <= 37 ; i ++ )
				if( pd[i] == 1 )
					ans = ans * 2;
			cout << ans << endl;
		}
	}
	return 0;
}
```


---

## 作者：yi_fan0305 (赞：0)

虽然本题贴心地给出了简要题意，但是对于我来说，还是原题面更好理解一些。

从题目中可以得到第 $0$ 格对折时没有与它相对的格，因此第 $0$ 格的颜色最大就到 $1$，如果超过 $1$，则无解。

对于一般的格子，我们发现，如果最后显示的颜色为 $0$ 或 $2$，那么两个格子的颜色只有一种情况，$0$ 的时候两个格子都是白色，$2$ 的时候两个格子都是紫色，而只有 $1$ 的时候，两个格子的颜色不同，这时会有两种情况，一号格子为紫色二号格子为白色，或者一号格子为白色二号格子为紫色，因此我们发现，将 $x$ 化为三进制数后，只有 $1$ 会对答案有贡献（$0$ 号格子的除外），因此只要统计 $1$ 的个数即可。

上代码。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll x, T, cnt;
int col[1010];

void work(int* s) {
	if (s[0] == 2) { // 第0号格为2,无解
		puts("0");
		return ;
	}
	ll ans = 1;
	for (int i = 1; i < cnt; ++ i) {
		if (col[i] == 1) { // 颜色为1会有两种情况,乘2
			ans *= 2;
		}
	}
	printf("%lld\n", ans);
}

int main() {
	scanf("%lld", &T);
	while (T --) {
		cnt = 0;
		scanf("%lld", &x);
		while (x) { // 化为三进制数
			col[cnt ++] = x % 3;
			x /= 3;
		}
		work(col);
	}
}
```

---

## 作者：zhyou (赞：0)

## 思路
将 $x$ 用三进制表示，设三进制下第 $i$ 位的数为 $C_{i}$,且 $x$ 在三进制下有 $k$ 位。

则有 $x = C_{k - 1}3^{k - 1} + C_{k - 2}3^{k - 2} + ... + C_{0}3^{0}$;

我们可以遍历每一位：

1. 如果 $C_{i} = 0$，则集合中必然没有 $i$ 这个数。

2. 如果 $C_{i} = 1$，则集合中必然有 $i$ 或 $-i$ 中的一个。

3. 如果 $C_{i} = 2$，则集合中必然有 $i$ 和 $-i$ （因为如果 $C_{i} = 2$，则 $x$ 的三进制表示下必然有 $2 \times 3^{i}$ 项，而集合中不能有相同的数，所以要有 $i$ 和 $-i$）。

所以，只有当 $C_{i} = 1$ 时，放入集合的数才有两种可能。否则放入集合的数只有一种可能。

我们设 $x$ 在三进制下有 $c$ 位为 $1$，按照上述结论，显然有 $2^{c}$ 种可能。

但是，$0$ 的相反数还是 $0$，所以如果 $x$ 在三进制表示下第 $0$ 位为 $1$，就只有 $2^{c - 1}$ 种可能。

## 代码
```
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long LL;

int count_3(LL n){ //求 n 在 3 进制下有几个数为 1
	int cnt = 0;
	while (n){
		if (n % 3 == 1) ++ cnt;
		n /= 3;
	}
	return cnt; 
} 
 
int main(){
	int T;
	scanf("%d", &T);
	
	while ( T -- ){
		LL n;
        scanf("%lld", &n);

		if (n % 3 == 2) {puts("0");continue;}
        if (!n){puts("1");continue;}
		int c = count_3(n);
        LL ans = (1ull << c);

        printf("%lld\n", n % 3? ans >> 1ull : ans);
	}
	
	return 0;
}
```

---

## 作者：hloixyh (赞：0)

### 思路：

初看本题，稍微有点难理解，但是不难发现三进制时，每一位上可能有一下三种数：

1. 该位为 $ 0 $，即该位上负正均不选，只有一种情况。

2. 该位为 $ 1 $，即该位上正负中只能选一个，有两种情况。

3. 该位为 $ 2 $，即该位上正负均选，也只有一种情况。

于是我们可以得出最后的方案数只与三进制下 $ 1 $ 的个数有关，且方案数为 $ 2 ^ k $ （其中 $ k $ 为三进制下 $ 1 $ 的个数）。

但还有几种特殊情况：

1. 输入的十进制数 $ x $ 为 $ 0 $ 或 $ 1 $，此时答案为 $ 1 $。

2. 输入的十进制数 $ x $ 满足 $ x \bmod 3 = 1 $，此时因为第一位的 $ 1 $ 不能影响方案数，所以方案数为 $ 2 ^ { k -  1 } $ （其中 $ k $ 为三进制下 $ 1 $ 的个数）。

3. 输入的十进制数 $ x $ 满足 $ x \bmod 3 = 2 $，此时因为第一位只有正，没有负，所以不可能有任何一种方案满足条件，应输出 $ 0 $。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long R(){//快读。 
    long long x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
int main(){
	long long t;
	t=R(); 
	while(t--){
		long long cnt=0;//用于记录三进制下x中1的个数。 
		long long x;
		x=R();
		if(x%3==2){ 
			puts("0");
			continue;
		}
		if(x==0||x==1){
			puts("1");
			continue;
		}
		if(x%3==1){
			cnt--;
		}
		while(x){//将十进制转化成三进制，同时1的统计数量。 
			if(x%3==1){
				cnt++;
			}
			x/=3;
		}
		printf("%lld",(1ull<<cnt));
		puts("");
	}
	return 0;
}
```


---


# [yLCPC2024] A. dx 分计算

## 题目背景

你说的对，但舞萌 DX 是一款由 SEGA 开发，华立科技代理，形似洗衣机的街机音乐游戏。

只要看准时机拍到所有的音符就好啦！

## 题目描述

在舞萌 DX 中，每个音符根据完成击打的时刻，会得到如下五种判定：

- `Critical Perfect`：简记为 `P`，可得 $3$ 分 dx 分。
- `Perfect`：简记为 `p`，可得 $2$ 分 dx 分。
- `Great`：简记为 `G`，可得 $1$ 分 dx 分。
- `Good`：简记为 `g`，不能得到 dx 分。
- `Miss`：简记为 `m`，不能得到 dx 分。

扶苏游玩了一局舞萌 DX，她将她各个音符的判定情况按顺序使用上面的简记规则记为了一个字符串 $s$。规定这个字符串最左边的字符表示第一个音符的判定结果，最右边的字符表示第 $|s|$ 个音符的判定结果，这里 $|s|$ 表示字符串 $|s|$ 的长度，也即整首歌的音符数。

现在，扶苏有 $q$ 次询问，每次询问会给出两个整数 $l, r$，对每个询问你需要回答：这首歌的第 $l$ 个音符到第 $r$ 个音符（包含第 $l$ 个和第 $r$ 个）的判定结果共能得到多少 dx 分数？

乐曲一段区间内的音符得到的 dx 分数是这些音符分别能得到的 dx 分数之和。

## 样例 #1

### 输入

```
2
PpGgm
2
1 5
4 5
PPppGGgm
5
1 2
3 4
5 6
7 7
8 8```

### 输出

```
6
0
6
4
2
0
0```

# 题解

## 作者：PR_CYJ (赞：10)

# [题目传送门](https://www.luogu.com.cn/problem/P10233)
# 思路
这道题很简单，思路也很明显，一眼就可以看出来是前缀和。

数据读入时，我们用 $a$ 数组来进行预处理。其中 $a_i$ 代表前 $i$ 个音符的得分和。

然后是 $q$ 次询问，我们只需要输出 $a_r-a_{l-1}$ 即可。

**注意不要用 `memset`！！！否则会 TLE！！！**
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000010];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		string s;
		int q;
		cin>>s;
		scanf("%d",&q);
		int n=s.size();
		for(register int i=1;i<=n;i++)
		{
			a[i]=a[i-1];//避免使用 memset
			if (s[i-1]=='P')
				a[i]+=3;
			else if (s[i-1]=='p')
				a[i]+=2;
			else if (s[i-1]=='G')
				a[i]++;
		}
		for(register int i=1;i<=q;i++)
		{
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%d\n",a[r]-a[l-1]);
		}
	}
}
```

---

## 作者：WydnksqhbD (赞：5)

# [P10233 [yLCPC2024] A. dx 分计算](https://www.luogu.com.cn/problem/P10233) 题解
## 思路 1
直接暴力枚举，然后 T 飞了。

为什么呢，因为暴力查询的话，单次就有可能遍历整个序列，也就是 $O(|s|)$ 的复杂度。

这样，$q$ 次查询就是 $O(q|s|)$ 的复杂度，很明显过不了。
## 思路 2
有一个好东西，叫**前缀和**。

什么意思呢？我们先来看一个例题：

>### [P8218 求区间和](https://www.luogu.com.cn/problem/P8218)
>给定一个序列 $a$，有 $q$ 次询问，每次给出 $l,r$，求 $a_l+a_{l+1}+\dots+a_r$。

这个题乍一看可以暴力，但是复杂度 $O(nm)$，会导致超时。

但这个时候，我们会发现，
- 如果我们维护一个序列 $s$，使得 $s_i=a_1+a_2+\dots+a_i$，那么如果要求 $a_l+a_{l+1}+\dots+a_r$，可以直接用 $s_r-s_{l-1}$ 来 $O(1)$ 求出区间和。

所以我们可以先预处理出来 $s$ 数组，因为 $s_i=s_{i-1}+a_i$。而 $s$ 数组，就是**前缀和**。

利用这种思想，我们也可以给字符串 $s$ 做一个前缀和。

所以最后复杂度 $O(T(q+|s|))$，可以通过本题。
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[10000005];
signed main()
{
	int t;cin>>t;
	while(t--)
	{
		string s;cin>>s;int len=s.size();s=" "+s;
		sum[0]=0;
		for(int i=1;i<=len;i++)
		{
			sum[i]=sum[i-1];
			if(s[i]=='P')sum[i]+=3;
			if(s[i]=='p')sum[i]+=2;
			if(s[i]=='G')++sum[i];
		}
		int q;cin>>q;
		while(q--)
		{
			int l,r;cin>>l>>r;
			cout<<sum[r]-sum[l-1]<<'\n';
		}
	} 
	return 0;
}
```

---

## 作者：Programming_Konjac (赞：3)

# 思路
前缀和。

初始化：前缀和数组的第 $0$ 项等于 $0$，以下计前缀和数组为 $sum$。

遍历字符串（下标从 $1$ 开始）的每一位，如果这一位是 `P`，那么 $sum_i=sum_{i-1}+3$，如果是 `p`，那么 $sum_i=sum_{i-1}+2$，如果是 `G`，那么 $sum_i=sum_{i-1}+1$，如果都不是，那么 $sum_i=sum_{i-1}$。

这时如果要求 $l$ 到 $r$ 的区间和，那么就输出 $sum_r-sum_{l-1}$，这个式子是这样来的（假设 $a$ 数组是第 $i$ 位的 dx 分）：

$$\begin{aligned}&
\texttt{ }\texttt{ }\texttt{ }a_l+a_{l+1}+a_{l+2}+\cdots + a_r
\\&=(a_1+a_2+a_3+\cdots +a_r)-(a_1+a_2+a_3\cdots + a_{l-1})
\\&=sum_r-sum_{l-1}
\end{aligned}$$
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[10000005];
int main(){
	int t;
	cin>>t;
	while(t--){
		sum[0]=0;
		string s;
		cin>>s;
		for(int i=0; i<s.size(); i++){
			if(s[i]=='P') sum[i+1]=sum[i]+3;
			else if(s[i]=='p') sum[i+1]=sum[i]+2;
			else if(s[i]=='G') sum[i+1]=sum[i]+1;
			else sum[i+1]=sum[i];
		}
		int q;
		cin>>q;
		while(q--){
			int l,r;
			cin>>l>>r;
			cout<<sum[r]-sum[l-1]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P10233)

## 暴力做法

直接按照题意模拟，统计分数，会超时。

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        string s;
        int q;
        cin >> s >> q;
        while (q--) {
            int l, r;
            cin >> l >> r;
            string t = s.substr(l - 1, r - l + 1);
            int ans = 0;
            for (int i = 0; i < t.size(); i++) {
                if (t[i] == 'P') ans += 3;
                else if (t[i] == 'p') ans += 2;
                else if (t[i] == 'G') ans++;
                else continue;
            }
            cout << ans << endl;
        }
    }
    return 0;
}
```

## 满分做法

用一个前缀和数组 $c$ 统计从 $s_1$ 到 $s_i$ 会获得的分数（下标从 $1$ 开始），最后输出 $c_r-c_{l-1}$ 就代表从第 $l$ 个音符到第 $r$ 个音符会获得的分数。

```cpp
#include <iostream>
using namespace std;
int c[10000010];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        string s;
        int q;
        cin >> s >> q;
        s = ' ' + s;
        for (int i = 1; i <= s.size(); i++) {
            c[i] = 0;
            if (s[i] == 'P') c[i] = c[i-1] + 3;
            else if (s[i] == 'p') c[i] = c[i-1] + 2;
            else if (s[i] == 'G') c[i] = c[i-1] + 1;
            else c[i] = c[i-1];
        }
        while (q--) {
            int l, r;
            cin >> l >> r;
            cout << c[r] - c[l - 1] << endl;
        }
    }
    return 0;
}
```

---

## 作者：CaiZi (赞：2)

## [yLCPC2024] dx 分计算 题解
**[题目链接](https://www.luogu.com.cn/problem/P10233)**
### 题意理解
有一个字符串 $s$，其中每个字符对应得分不同，每次操作求区间得分和。
### 题目分析
首先先把字符串每个位置的得分对应下来，然后这题要多次求区间和，所以进行一次前缀和。设 $a_i$ 表示前 $i$ 个字符的得分总和，那么每次查询的答案便是 $a_r-a_{l-1}$。
### 代码展示
时间复杂度 $O(\sum|s|+\sum q)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,q,a[10000001],l,r;
string s;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>s>>q;
		for(int i=0;i<s.length();i++){
			if(s[i]=='P'){
				a[i+1]=a[i]+3;
			}
			else if(s[i]=='p'){
				a[i+1]=a[i]+2;
			}
			else if(s[i]=='G'){
				a[i+1]=a[i]+1;
			}
			else{
				a[i+1]=a[i];
			}
		}
		while(q--){
			cin>>l>>r;
			cout<<a[r]-a[l-1]<<'\n';
		}
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/150126133)**

---

## 作者：lun_hao (赞：1)

### 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P10233)

共 $T$ 组测试数据，每组数据给定一个字符串 $s$ 和 $Q$ 次询问，按照特定的赋值方式，每次询问 $l$ 到 $r$ 间按这样的赋值方式的总和是多少。

赋值方式如下：
- `P` 可得3分
- `p` 可得2分
- `G` 可得1分
- 其余字符不得分

### 题目分析：
前置知识：**前缀和**。（没有学过的可以先完成[这题](https://www.luogu.com.cn/problem/B3612)再回来做本题）

考虑数据范围，$1 \leq \sum{|s|} \leq 10^7,1 \leq \sum{Q} \leq 10^4,1 \leq l \leq r \leq |s|$，发现 $\sum{|s|}$ 可高达 $10^7$，暴力的总时间复杂度为 $O(T \times |s| \times {Q})$，故**暴力求和不可**，考虑优化。

由题意发现没有强制性在线询问，故可以考虑**离线询问**。用**前缀和**提前计算出前 $i$ 个数的总和，每次询问 $l$ 到 $r$，记答案为 $ans$，前缀和数组为 $sum$，则：
$$ans \gets sum_r - sum_{l-1} $$

故时间复杂度为 $O(\sum |s|+\sum Q)$。

### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
int T,sum[N],Q,len;
string s;
signed main()
{
	scanf("%d",&T);
	while(T--)
	{
		cin>>s;
		scanf("%d",&Q);
		len=s.size();
		//for(int i=1;i<=len;i++) sum[i]=0; 
		//这里因为前缀和的计算会直接覆盖上次的值故可以不用清零 
		for(int i=1;i<=len;i++)
		{
			//前缀和依题意赋值 
			sum[i]=sum[i-1];
			if(s[i-1]=='P') sum[i]+=3;
			if(s[i-1]=='p') sum[i]+=2;
			if(s[i-1]=='G') sum[i]++;
		}
		while(Q--)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			printf("%d\n",sum[y]-sum[x-1]);//询问 O(1) 求出答案 
		}
	}
	return 0;
}
```

---

## 作者：Lian_zy (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P10233)
# 题目分析
本题中 $|s|$ 极大，所以不能简单的暴力（复杂度 $O(|s|q)$），考虑到不会有修改操作，所以可以用前缀和 $a$ 维护，每次询问只要输出 $a_y - a_{x-1}$ 即可。

# 总结 & 代码

由于使用了前缀和，速度极快，仅为 $O(T(|s| + q))$，是可以达到的最优复杂度。

``` cpp
#include <iostream>
using namespace std;

int qzh[10000005];
int ccc(char c){
    if(c=='P')return 3;
    if(c=='p')return 2;
    if(c=='G')return 1;
    return 0;
}
int main()
{
    int T;
    string s;
    cin>>T;
    while(T--){
        cin>>s;
        for(int i=0;i<s.size();i++){
            qzh[i+1]=qzh[i]+ccc(s[i]);
        }
        int q;cin>>q;
        while(q--){
            int x,y;cin>>x>>y;
            cout<<qzh[y]-qzh[x-1]<<endl;
        }
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

直接用前缀和都可以啊，在处理上用个差分，简直和 [B3612](https://www.luogu.com.cn/problem/B3612) 一模一样啊。（所以说做完这道可以直接干它）

每次输入一个字符串，用一个变量 $sum$ 来存储这一局游戏的总分数。扫描其中的每个字符，如果有 `P` 就将 $sum$ 加 $3$，有 `p` 就将 $sum$ 加 $2$，有 `G` 就将 $sum$ 加 $1$，然后再将每个字符扫描后的 $sum$ 记到相应的数组位置里，这就是前缀和最基本的操作。赛时将 `G` 看成 `g`，调了十分钟，我眼瞎啊啊啊……

然后题目把 $l$ 和 $r$ 的范围都告诉你了，进行差分，直接用数组里的 $S_r - S_{l-1}$ 即可获取这个范围获得的分数。具体的推导如下：

$S_r = a_1 + a_2 + a_3 + \dots + a_r$，要使我们获得 $a_l + a_{l+1} + a_{l+2} + \dots + a_r$，我们就需要把前几项 $a_1 + a_2 + a_3 + \dots + a_{l-1}$ 减掉，而这几项之和就是 $S_{l-1}$，所以推出式子为 $S_r - S_{l-1}$。

贴代码：
```cpp
#include <iostream>
using namespace std;

int S[10000001];

void solve() {
    string s;
    int sum = 0;
    cin >> s;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == 'P') sum += 3;
        if (s[i] == 'p') sum += 2;
        if (s[i] == 'G') sum += 1;
        S[i+1] = sum;
    }
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int l, r;
        cin >> l >> r;
        cout << S[r] - S[l-1] << endl;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
}
```
自认为码风很漂亮……

---

## 作者：InversionShadow (赞：0)

简单前缀和。

前缀和就是可以 $\mathcal{O(}1)$ 统计区间和的算法（不带修）。具体地，求 $\sum\limits_{i=l}^ra_i$，就是 $sum_r-sum_{l-1}$。这里的 $sum_i$ 表示 $\sum\limits_{j=1}^ia_j$，画图容易理解。

回到这道题，`P` 表示 $3$，`p` 表示 $2$，`G` 表示 $1$。那么就可以用前缀和快速回答了，时间复杂度 $\mathcal{O(}T|s|)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e7 + 100;

int t, sum[N];
string s;

map<char, int> mp;

void solve() {
  cin >> s; 
  int n = s.size();
  s = ' ' + s;
  sum[0] = 0;
  for (int i = 1;i <= n; i++) {
    sum[i] = sum[i - 1] + mp[s[i]];
  }
//  for (int i = 1; i <= n; i++) {
//    cout << sum[i] - sum[i - 1] << ' ';
//  }
//  cout << '\n';
  int q;
  cin >> q;
  for (int i = 1; i <= q; i++) {
    int l, r;
    cin >> l >> r;
    cout << sum[r] - sum[l - 1] << endl;
  }
}

int main() {
  mp['P'] = 3, mp['p'] = 2, mp['G'] = 1; 
  cin >> t;
  while (t--) {
    solve(); 
  }
  return 0;
}
```

---

## 作者：_Jocularly_ (赞：0)

首先，考虑每一组数据。输入字符串，把他变成等价的分值，保存下来，按照题目中要求的求值即可。

但如果求值阶段使用循环，一定会超时，观察题意，发现要求输出的就是区间和，想到用前缀和来优化，用前缀和数组保存，相减后输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000005];
int cnt[10000005];
int t;
int main(){
	ios::sync_with_stdio;
	cin.tie(0),cout.tie(0); 
	cin >> t;
	while(t--){
		string s;
		int n;
		cin >> s;
		for(int i=0;i<s.size();i++){
			int num = 0;
			if(s[i] == 'P') num = 3;
			else if(s[i] == 'p') num = 2;
			else if(s[i] == 'G') num = 1;
			else num = 0;
			a[i+1] = num;
		}
		for(int i=1;i<=s.size();i++){
			cnt[i] = cnt[i-1] + a[i];
		}
		cin >> n;
		for(int i=1;i<=n;i++){
			int l,r;
			cin >> l >> r;
			cout << cnt[r] - cnt[l-1] << endl;
		}
	}
	return 0;
}
```

---


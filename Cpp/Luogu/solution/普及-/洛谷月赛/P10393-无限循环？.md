# 无限循环？

## 题目背景

你是一只小青蛙。

你被关进了塞拉飞舞监狱。

生活有点压抑，小青蛙幻想自己走出了塞拉飞舞监狱。

生活过于压抑，小青蛙开始反抗塞拉飞舞监狱。

小青蛙孤立无援，又被关进了塞拉飞舞监狱。

……

循环不是无限的。如此往复，总有一天，他会将塞拉飞舞这黑暗的牢笼冲破！

## 题目描述

小青蛙暂时被困在了循环里，这个循环可以看作一个有 $n$ 个点的环（$n$ 为奇数），每个点 $i$ 有点权 $a_i$。

对于所有的 $1 \leq i < n$，点 $i$ 和点 $i+1$ 之间有一条边，边权为 $w_i$；点 $1$ 和点 $n$ 之间有一条边，边权为 $w_n$。

这个环的边权和点权有奇妙的关系：对于任意一条边 $i$，其边权 $w_i$ 都必然满足关系 $w_i=\dfrac12(a_i+a_{i+1})$，其中 $w_n=\dfrac12(a_1+a_{n})$，当环中任意一条边的边权改变的时候，它的所有点点权会**随之改变**，直到所有点权都能与边权满足上述关系。

现在青蛙掌握了 $w_1\sim w_n$ 的值，而且他可以交换其中任意两条边的权值任意次（即任意打乱边权）。现在青蛙需要给出两组安排 $w_1\sim w_n$ 的方案，分别使得 $1$ 号点点权**在所有的排列方案中最大** / **最小**。

然而由于青蛙陷入了无限循环，他的脑子十分混乱，于是他向你寻求帮助，你需要帮他构造这样两组方案。

**题目保证 $\boldsymbol n$ 为奇数**。

## 说明/提示

**【样例 #1 解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/j7x81nq5.png)

其中红色数字表示点权，黑色数字表示边权，蓝色数字表示点的编号。

可以证明，这种方案下的 $1$ 号点权既最小，又最大。

**【样例 #2 解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/ku8797x8.png)

其中红色表示点权，黑色表示边权，蓝色表示点的号码。

可以证明，这两种方案下的 $1$ 号点权分别取到最大和最小。需要注意的是，这**不一定**是**唯一解**。

---

**【数据规模与约定】**

**本题开启捆绑测试。**

| $\text{Subtask}$ | 数据范围 | 分数 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $n=3$ | $20$ | $\rm A$ |
| $2$ | $n=3$ | $20$ | 无 |
| $3$ | $n\leq 10^6$ | $20$ | $\rm B$ |
| $4$ | $n\leq 10^6$ | $20$ | $\rm C$ |
| $5$ | $n\leq 10^6$ | $20$ | 无 |

- 特殊性质 $\rm A$ ：保证 $\{w\}$ 是由 $\{-1,0,1\}$ 任意打乱之后得到的一个序列。
- 特殊性质 $\rm B$ ：保证 $n \ge 3$，且对于所有 $i\in [2,n]$，有 $w_i$ 相同。
- 特殊性质 $\rm C$ ：保证 $n\ge 3$，且对于所有 $i\in [3,n]$，有 $w_i$ 相同。
- 对于 $100\%$ 的数据， $1\leq n\leq 10^6$ 且为奇数， $|w_i|\leq 10^9$。

## 样例 #1

### 输入

```
3
0 0 0```

### 输出

```
0 0 0 
0 0 0```

## 样例 #2

### 输入

```
5
1 1 1 1 -1```

### 输出

```
1 1 1 -1 1 
1 1 -1 1 1```

## 样例 #3

### 输入

```
3
1 2 3```

### 输出

```
3 1 2
2 3 1```

# 题解

## 作者：PR_CYJ (赞：9)

# [题目传送门](https://www.luogu.com.cn/problem/P10393)
# 思路
这道题 $1\le n\le 10^6$ 所以显然不是模拟，接下来就考虑数学做法。

我们发现 $w_i=\frac{1}{2}\cdot (a_i+a_{i+1})$，所以 $2\cdot w_i=a_i+a_{i+1}$，然后将 $2\cdot w_i$ 记为 $v_i$，所以 $v_i$ 就是一条边相邻两点的点权和。

接下来就可以用 $a_1$ 表示其它的点。$a_2$ 为 $v_1-a_1$，$a_3$ 为 $v_2-v_1+a_1$。以此类推，当 $n$ 为奇数时，$a_n$ 就是 $v_{n-1}-v_{n-2}+v_{n-3}-v_{n-4}+\cdots +v_2-v_1+a_1$。因为 $a_1$ 与 $a_n$ 的和是 $v_n$，所以 $a_1+v_{n-1}-v_{n-2}+v_{n-3}-v_{n-4}+\cdots +v_2-v_1+a_1=v_n$，即 $2\cdot a_1=v_n-v_{n-1}+v_{n-2}-v_{n-3}+\cdots +v_1$。

接着将右边式子分成两部分，即 $v_n+v_{n-2}+\cdots +v_1$ 和 $-(v_{n-1}+v_{n-3}+\cdots+v_2)$。可以发现，若要使 $a_1$ 最大，就要使 $v_n+v_{n-2}+\cdots +v_1$ 最大，$v_{n-1}+v_{n-3}+\cdots+v_2$ 最小。而 $a_1$ 最小时则相反。

最后只需要将 $w$ 数组排序然后间隔输出即可。
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,smnw,bgnw,a[1000010];
int main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	cout<<a[n/2+1];
	smnw=1;
	bgnw=n/2+2;
	for(int i=2;i<=n;i++)//当a1最大时
		if (i&1)
		{
			cout<<" "<<a[bgnw];
			bgnw++;
		}
		else
		{
			cout<<" "<<a[smnw];
			smnw++;
		}
	cout<<endl<<a[1];
	smnw=2;
	bgnw=n/2+2;
	for(int i=2;i<=n;i++)／／当a1最小时
		if (i&1)
		{
			cout<<" "<<a[smnw];
			smnw++;
		}
		else
		{
			cout<<" "<<a[bgnw];
			bgnw++;
		}
}
```

---

## 作者：_zSqr_Mahiro_Oyama_ (赞：3)

# P10393 无限循环？ 题解
[题目传送门](https://www.luogu.com.cn/problem/P10393)
### 分析部分：
我们设 $1$ 号点点权为 $x$，排完后边 $i$ 的边权为 $y_i$，用 $x$ 和 $y_1$ 到 $y_n$ 表示每一个点的点权，以下是 $n=5$ 的情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/elnhg5hq.png)
分析可得 $x$ 是由奇数项边权之和减去偶数项边权之和得到，所以只需把边权排序，要求 $x$ 最大只需较大，较小项交错输出即可。求 $x$ 最小同理。
### 代码部分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1,l=1,r=n;i<=n;i++){
		if(i&1)cout<<a[r]<<' ',r--;
		else cout<<a[l]<<' ',l++;
	}
	cout<<endl;
	for(int i=1,l=1,r=n;i<=n;i++){
		if(i&1)cout<<a[l]<<' ',l++;
		else cout<<a[r]<<' ',r--;
	}
	return 0;
}
```

---

## 作者：FarmerDrone (赞：3)

**这题只要不被绕晕就很简单。**  
$w_n = \frac{1}{2}(a_i + a_{i + 1})$ 是本题一个迷惑的地方，如果理解成平均数就容易想复杂，只要简单地理解成**两个节点的和**就好了。  
应该已经会了吧？ 

如果还没有思路，那么再提示一点：一个点的点权 $=$ 所有点权的和 $-$ 剩余点权的和。

由于不管怎么调换，所有边权的和是不会变的。所以只要控制剩余点权的总和就好。而题目又保证 $n$ 为奇数，那去掉一个点，剩下的必为偶数，**也就是它们权值和 $= (n - 1) / 2$ 条边的边权和 $\times 2$**。  
所以，只用考虑 $(n - 1) / 2$ 条边，使它们的权值和最大 / 最小，就可以使点 $1$ 的权值最大 / 最小。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

bool cmp(int a, int b)
{
	return a > b;
}

int main()
{
	int n;
	cin >> n;
	int a[n + 1];
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++)
		if (i & 1)
			cout << a[i / 2 + 1] << " ";
		else
			cout << a[n - i / 2 + 1] << " ";
	cout << "\n";
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++)
		if (i & 1)
			cout << a[i / 2 + 1] << " ";
		else
			cout << a[n - i / 2 + 1] << " ";
	cout << "\n";
	return 0;	 
}
```

---

## 作者：jdfz2251533 (赞：2)

# P10393 无限循环？ 题解
### 题意分析
题目可以简单概括为：给定了一个边权集 $w$，$w_i=\frac{1}{2}(a_i+a_{i+1})$，用这个式子构造出序列 $a$，可以对给定的边权集中的**任意两个权值进行任意次交换**，使得构造出的序列 $a$ 中的**第一个元素最大/最小**。

值得注意的是：保证$n$为**奇数**，$w_n=\frac{1}{2}(a_1+a_{n})$，这对后续的变形有帮助。

### 解法
既然要求 $a_1$ 的最值，我们不妨先对题目给出的关系式进行变形： $w_i=\frac{1}{2}(a_i+a_{i+1}) \Rightarrow a_i= 2w_i-a_{i+1}$\
由此我们可以表示出 $a_1$，也就是：\
$a_1 = 2w_1-a_2 \\ = 2w_1-2w_2+a_3 \\=2w_1-2w_2+2w_3-a_4 \\......\\=2w_1-2w_2+2w_3-2w_4+2w_5-...
+2w_n-a_1 \\$
然后将等号右边的 $a_1$ 加到左边，两边同时除以 $2$ ，把加号的项和减号的项分别合并。我们就得到了只含有 $w$ 的 $a_1$ 的表达式，也就是：

$a_1=(w_1+w_3+w_5+...+w_n)-(w_2+w_4+w_6+...+w_{n-1})$

下面分别考虑 $a_1$ 最大情况和最小情况：

1.最大：为了让 $a_1$ 尽量大，我们应该将原来 $w$ 序列中更大的数放在调整后 $w$ 序列的**奇数**编号位置，只要对 $w$ 进行降序排序，开一个答案数组，先给**奇数位**填上，然后剩下的偶数位随意填都可以。参考代码：
```cpp
sort(w + 1, w + n + 1, greater<int>());
int tot = 0;
for (int i = 1; i <= n; i += 2) {
	ans[i] = w[++tot];
}
for (int i = 2; i < n; i += 2) {
	ans[i] = w[++tot];
}
for (int i = 1; i <= n; i++) {
	cout << ans[i] << " ";	
}
cout << endl;
```
2.最小：与最大情况同理，只需要将更小的数填在奇数位，剩下的随意填即可，这里对 $w$ 进行升序排序。参考代码：
```cpp
sort(w + 1, w + n + 1);
tot = 0;
for (int i = 1; i <= n; i += 2) {
	ans[i] = w[++tot];
}
for (int i = 2; i < n; i += 2) {
	ans[i] = w[++tot];
}
for (int i = 1; i <= n; i++) {
	cout << ans[i] << " ";	
}
```

### 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;

int n, w[N], ans[N];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
	}
	sort(w + 1, w + n + 1, greater<int>());
	int tot = 0;
	for (int i = 1; i <= n; i += 2) {
		ans[i] = w[++tot];
	}
	for (int i = 2; i < n; i += 2) {
		ans[i] = w[++tot];
	}
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << " ";
	}
	cout << endl;
	sort(w + 1, w + n + 1);
	tot = 0;
	for (int i = 1; i <= n; i += 2) {
		ans[i] = w[++tot];
	}
	for (int i = 2; i < n; i += 2) {
		ans[i] = w[++tot];
	}
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << " ";
	}
	return 0;
}
```

---

## 作者：Mingjunyi (赞：1)

# P10393 无限循环？

### 1.分析

自然画图入手，先从 $5$ 个点入手

设 $5$ 个点为 $a_1,a_2,a_3,a_4,a_5$

边权为 $w_1,w_2,w_3,w_4,w_5$ 

![five_node](https://cdn.luogu.com.cn/upload/image_hosting/v5oxsc8u.png)

不难发现 $ (1) - (2) + (3) - (4) +(5) \Rightarrow a_1 = w_1 - w_2 + w_3 - w_4 + w_5 $ 

故由上推广：对于 $n$（$n$ 为奇数）个点，$a_1 = w_1 - w_2 + w_3 - w_4 +... - w_{n-1} + w_n$ 

整理可得 $a_1 = \sum_{i \in odd} w_i - \sum_{i \in even} w_i$  

让 $a_1$ 最大化，只需让 $\sum_{i \in odd} w_i$ 最大化且 $\sum_{i \in even} w_i$ 最小化  
让 $a_1$ 最小化反之即可

-------
### 2.行动

先排序，然后用指针 $i,j$ 在站在 $w$ 数组头和尾，当输出位为奇数位，将指向 **较小/较大** 的数输出，让该指针向中间移动

code:
```cpp
#include <bits/stdc++.h>
using namespace std;

CIN N = 1e6+5;

int n,w[N];

signed main(){

	cin>>n;
	for(int i = 1;i<=n;i++) cin>>w[i];
	sort(w + 1,w + n + 1);

	// a_1位最大
	for(int i = 1,j = n,t = 1;i <= j;t++) {
		if(t & 1) cout<<w[j--]<<' ';
		else cout<<w[i++]<<' ';
	}
	cout<<'\n';
	
	//a_1位最小
	for(int i = 1,j = n,t = 1;i <= j;t++){
		if(t & 1) cout<<w[i++]<<' ';
		else cout<<w[j--]<<' ';
	}

	return 0;
}
```

---

## 作者：dlzlj_2010 (赞：1)

由 $w_i=\dfrac{1}{2}(a_i+a_{i+1})$ 得 $a_i=2w_i-a_{i+1}$，所以  $a_1=2w_1-a_2=2w_1-(2w_2-a_3)=\cdots=2w_1-2w_2+2w_3-2w_4+\cdots +2w_n$。  
所以：
- 对于第一问，将较大值置于奇数位，较小值置于偶数位。
- 对于第二问，反过来即可。
## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
const int N=1e6+5;
int w[N];
vector<int>v1,v2;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	int idx=0;
	sort(w+1,w+1+n);
	for(int i=1;i<=n;i++){
		if(i%2){
			v1.push_back(w[n-idx]);
			v2.push_back(w[1+idx]);
		}
		else{
			v1.push_back(w[1+idx]);
			v2.push_back(w[n-idx]);
		}
		if(i%2==0)idx++;
	}
	for(int i=0;i<v1.size();i++){
		cout<<v1[i]<<" ";
	}
	puts("");
	for(int i=0;i<v2.size();i++){
		cout<<v2[i]<<" ";
	}
	return 0;
}
```

---

## 作者：shicj (赞：0)

# [P10393 无限循环？](https://www.luogu.com.cn/problem/P10393)题解

1. 题意

   有一个 $n$ 个节点的环（$n$ 是奇数），每个点 $i$ 有点权 $a_i$，现在已知了边权 $w_i=\dfrac{1}{2}(a_i+a_{i+1})$，其中 $w_n=\dfrac{1}{2}(a_1+a_n)$，这个权值和可以任意对应，改变边权时 $a_i$ 会自动调整，现在要求出两种边权的对应方法，分别使得 $a_1$ 取得最大值和最小值。

2. 思路

   我们尝试把 $a_1$ 表示一下（因为要求它的最值）。

   易得方程组：
   $$
   \begin{equation*}
        \begin{cases}
            a_1+a_2=2w_1\\
            a_2+a_3=2w_2\\
            \cdots\\
            a_{n-1}+a_n=2w_{n-1}\\
            a_n+a_1=2w_n
        \end{cases}
    \end{equation*}
   $$
   题目中的 $n$ 为奇数刚好帮我们避免了分类讨论。

   现在求 $a_1$，将所有方程加起来左右同时除以 $2$ 得：
   $$
   a_1+a_2+\cdots+a_n=w_1+w_2+\cdots+w_n
   $$
   减掉不需要的项：
   $$
   \begin{align}
   	a_1
   	&=a_1+a_2+\cdots+a_n-(a_2+a_3)-(a_4+a_5)-\cdots-(a_{n-1}+a_n)\\
   	&=w_1+w_2+\cdots+w_n-(2w_2+2w_4+\cdots+2w_{n-1})
   \end{align}
   $$
   要求 $a_1$ 最大值，就要使得 $(2w_2+2w_4+\cdots+2w_{n-1})$ 最小，也就是使得 $(w_2+w_4+\cdots+w_{n-1})$ 最小。

   也就是把较小的 $w$ 值放在偶数位置上面。

   最小值同理，就是把把较大的 $w$ 值放在偶数位置上面。

   于是做完了。

3. 代码

   ```cpp
   #include<bits/stdc++.h>
   using namespace std;
   int n,a[1000001];
   bool cmp(int aa,int bb){
       return aa>bb;
   }
   int main(){
       cin>>n;
       for(int i=1;i<=n;i++)
           cin>>a[i];
       sort(a+1,a+n+1);
       for(int i=1;i<=n;i++)
           if(i%2)cout<<a[n/2+1+i/2]<<" ";
           else cout<<a[i/2]<<" ";
       cout<<endl;
       sort(a+1,a+n+1,cmp);
       for(int i=1;i<=n;i++)
           if(i%2)cout<<a[n/2+1+i/2]<<" ";
           else cout<<a[i/2]<<" ";
       cout<<endl;
       return 0;
   }
   ```

---

## 作者：abc1856896 (赞：0)

小清新结论题

# 题目大意
给定 $n$ 个数，第 $i$ 个数为 $w_i$。其中 $w_i=\frac{a_i+a_{i+1}}{2}$，$w_n=\frac{a_1+a_n}{2}$。

构造出新的一组 $w_1\sim w_n$，使得 $a_1$ 最小/最大。

# solution

将题目给出的式子整理后易得：

$a_1+a_2=w_1$

$a_2+a_3=w_2$

$a_3+a_4=w_3$

$\dots$

$a_{n-1}+a_n=w_{n-1}$

$a_n+a_1=w_n$

此时我们可以将第偶数个的式子取反，那么这样就变成了：

$a_1+a_2=w_1$

$-a_2-a_3=-w_2$

$a_3+a_4=w_3$

$\dots$

$-a_{n-1}-a_n=-w_{n-1}$

$a_n+a_1=w_n$

此时我们再将等式左右两边相加，就会发现除了 $a_1$ 以外的所有项都被小调了！现在式子就变成了：

$2a_1=w_1-w_2+w_3-w_4+ \dots -w_{n-1}+w_n$

有了这条式子，我们就可以构造了。

# code
```cpp
int n, w[1000005], ans[1000005];
void solve() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> w[i];

	sort(w + 1, w + n + 1);

	for (int i = n; i >= (n / 2 + 1); i--) ans[(n - i + 1) * 2 - 1] = w[i];

	for (int i = 1; i < (n / 2 + 1); i++) ans[i * 2] = w[i];

	for (int i = 1; i <= n; i++) cout << ans[i] << " ";

	cout << endl;

	memset(ans, 0, sizeof(ans));

	for (int i = 1; i <= (n / 2 + 1); i++) ans[i * 2 - 1] = w[i];

	for (int i = n; i > (n / 2 + 1); i--) ans[(n - i + 1) * 2] = w[i];

	for (int i = 1; i <= n; i++) cout << ans[i] << " ";

	return;
}
```

---

## 作者：C202301 (赞：0)

#### 题意简述
有一个有 $n$ 个点的环，对于所有 $1 \le i < n$，点 $i$ 和点 $i+1$ 之间有一条边，边权为 $w_i$，点 $1$ 和点 $n$ 之间有一条边，边权为 $w_n$。每个点 $i$ 有点权 $a_i$。$w_i=\frac{1}{2}(a_i+a_{i+1})$，$w_n=\frac{1}{2}(a_1+a_n)$，若边权改变，点权也随之改变。将边权随便打乱，求使 $a_1$ 最大和最小的方案。
#### 解题思路
根据 $w_i=\frac{1}{2}(a_i+a_{i+1})$ 可知，$a_{i+1}=w_i\times 2-a_i$。由 $w_n=\frac{1}{2}(a_1+a_n)$ 可知 $a_1=w_n \times 2-a_n$，而 $a_n$ 又可以变为 $w_{n-1}\times 2-a_{n-1}$ 继续往下推，由于 $n$ 必为奇数，所以最后变为：
$$
a_1=w_n\times 2-w_{n-1}\times 2+w_{n-2}\times 2-w_{n-3}\times 2+...+w_3\times 2-w_2\times 2+w_1\times 2-a_1
$$
将右边的 $a_1$ 移到左边，变为：
$$
a_1\times 2=w_n\times 2-w_{n-1}\times 2+w_{n-2}\times 2-w_{n-3}\times 2+...+w_3\times 2-w_2\times 2+w_1\times 2
$$
同时除 $2$，变为：
$$
a_1=w_n-w_{n-1}+w_{n-2}-w_{n-3}+...+w_3-w_2+w_1
$$
思考如何让 $a_1$ 最大，其实只需让加好后面的最大，减号后面最小，若让 $a_1$ 最小，其实只需让加好后面的最小，减号后面最大。
那么就简单了，排序一下，若要最大，就交叉取最大最小，第二大第二小，第三大第三小......若要最小，就交叉取最小最大，第二小第二大，第三小第三大......
#### 代码实现
```
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int w[n+1];
	for(int i=1;i<=n;i++)
	cin>>w[i];
	sort(w+1,w+n+1);//排序，从小到大
	for(int i=n;i>=n/2+2;i--)
	cout<<w[i]<<" "<<w[n-i+1]<<" ";//交叉取
	cout<<w[n/2+1];
	cout<<endl;
	for(int i=1;i<=n/2;i++)
	cout<<w[i]<<" "<<w[n-i+1]<<" ";//同样交叉取
	cout<<w[n/2+1];
	return 0;
}
```

---

## 作者：xxboyxx (赞：0)

### 思路

我们设第一个点为 $n$，一号节点与二号节点上的边权为 $x$，二号节点与三号节点上的边权为 $y$，三号节点与一号节点上的边权为 $z$。那么设第二个点的点权为 $a$，解方程 $\frac{n+a}{2}=x$，得 $a=2x-n$，所以二号点点权为 $2x-n$。以此类推，三号点点权为 $2y-2x+n$，一号点点权为 $2z-2y+2x-n$。又因为一号点为 $n$，所以 $2z-2y+2x-n=n$，得 $n=x+z-y$。如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/uyh6lzjy.png)

推广得 $n=a_1+a_3+a_5+\dots+a_n-a_2-a_4-a_6-\dots-a_{n-1}$。因为 $n$ 为奇数，所以一定如此。

那么这道题就变得简单了，应为求一种排列，得到奇数项减去偶数项最大与最小。那么排序则可以解决。

### 注意

要求两次排列，所以一定要记得清空。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool cmp(int a,int b)
{
	return a>b;
}
int n,t1,t2,x=0;
int a[1000005];
signed main()
{
	cin>>n;
	t1=0,t2=n+1;
	for (int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1,cmp);//从大到小排序 
	while (t1<t2-1)//奇数项顺序算，偶数项逆序算 
	{
		x++;
		if (x%2==1)
			cout<<a[++t1]<<' ';
		else
			cout<<a[--t2]<<' ';
	}
	cout<<'\n';
	sort(a+1,a+n+1);//从小到大排序  
	t1=0,t2=n+1,x=0;//清空！ 
	while (t1<t2-1)//同上 
	{
		x++;
		if (x%2==1)
			cout<<a[++t1]<<' ';
		else
			cout<<a[--t2]<<' ';
	}
	return 0;
}
```

---


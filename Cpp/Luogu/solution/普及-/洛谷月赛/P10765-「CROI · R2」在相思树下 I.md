# 「CROI · R2」在相思树下 I

## 题目背景

>年年桃树下
>
>常看一个变成俩
>
>小小心愿常比划
>
>快快实现吧
>
>却没看到他也在树下
>
>相逢二字纵使隔天涯
>
>转角总会遇上他
>
>缘分缘分啊                                        

## 题目描述

**本题采用多组数据测试。**

现在欣欣有一个从 $1$ 到 $n$ 的序列，并想对这个序列进行如下两种操作。

操作一：删去所有的奇数项。

操作二：删去所有的偶数项。

欣欣发现她在进行 $k$ 次操作后，最后只剩下一个数，但她不知道这个数是多少，于是欣欣来找你求助，她会给你她所进行的 $k$ 次操作的种类，希望你告诉她最后的那个数是多少。

## 说明/提示

**【样例解释】**

对于第一组数据，序列的变化如下：

$\{1,2,3,4,5\} \to \{2,4\} \to \{4\}$。

**【数据范围】**

对于 $30\%$ 的数据， $n\le 5\times10^5$。

对于 $100\%$ 的数据，$1\le T \le 10$，$1\le n\le 10^{18}$。

保证对于所有的数据，操作 $k$ 次后均仅剩下一个数。

## 样例 #1

### 输入

```
4
5 2
1 1
8 3
2 2 2 
8 3 
1 1 1
8 3
1 2 1```

### 输出

```
4
1
8
6```

# 题解

## 作者：RainBow_doge (赞：36)

## 题目大意  
有一个 $1\sim n$ 的序列，共有 $k$ 次操作，$1$ 操作指将下标为奇数的数字删除，$2$ 操作指将下标为偶数的数字删除，最后输出删除后的最后一个数字。
## 分析
看到数据范围为 $1\le n\le10 ^{18}$，知道肯定不能开数组暴力过，那就开始找规律：

首先我们要明白最后得出的数字到底在哪个位置。

### 我们可以举几个例子
$8$ $3$ $2$ $2$ $ 2$
```
1 2 3 4 5 6 7 8
(1)1 3 5 7
(2)1 5
(3)1
```
$7$ $3$ $2$ $2$ $2$
```
1 2 3 4 5 6 7
(1)1 3 5 7
(2)1 5
(3)1
```
$11$ $4$ $2$ $2$ $2$ $2$
```
1 2 3 4 5 6 7 8 9 10 11
(1)1 3 5 7 9 11
(2)1 5 9 11
(3)1 9
(4)1
```
### 这些得数有什么共同点吗?
+ 他们都只进行了 $2$ 操作。

+ 他们得数都为 $1$。

+ 每进行一次 $2$ 操作，相邻两数间的差值就会变大，且每次变大后的差值为变化前相邻两数差值的 $2$ 倍。

即第 $i$ 次操作，两数间的差值为 $2^i$。

### 那为什么他们的结果都为 $1$ 呢?
我们可以思考一下:

$2$ 操作每次是把偶数位删除，因此每次操作基本所有数字都会转移位置，但有一个数除外，即 $1$ 号位置上的数，他的前面没有数字了，因此他并不会向前补，并且因为他是奇数点，所以他不会被删除，那么他的位置就不会发生变化。

因为一号位置上的数的位置不会改变，而且 $2$ 操作并不会删除奇数点，所以一号位置上的数字在 $2$ 操作下将一定不会被删去，所以一号位置上的数一定为结果。

那我们就能得出：真正的结果不是 $1$，而是 $1$ 号位置上的数。

因此我们在代码中若遇见 $2$ 操作，只用更改两点之间的差值，而不用考虑结果。
```
if(x==2){//x为操作编号
  cnt*=2;//cnt为两点之间的差值
}
```
那说了这么久的 $2$ 操作，$1$ 操作要怎么办呢？
### 我们再举几个例子
我们在原有 $2$ 操作中插入几个 $1$ 操作。

$7$ $3$ $1$ $2$ $2$
```
1 2 3 4 5 6 7
(1)2 4 6
(2)2 6
(3)2
```
$8$ $3$ $1$ $1$ $2$
```
1 2 3 4 5 6 7 8
(1)2 4 6 8
(2)4 8
(3)4
```
#### ~~貌似看不出什么共同点~~，但我们可以联系上面的 $2$ 操作。
我们发现，尽管 $1$ 操作将第一个位置上的数删除了，但第一个位置的数后面的一个数成为了第一个位置上的数，也就是将第二个数作为了答案。
### 那第二个数要如何求得呢？
这时候我们就用到了操作 $2$ 中求到的差值了，因为求的差值为相邻两数之间的差，那么第二个数就可以理解为第一个数加上差值。

而且 $1$ 操作因为跳着删除了一些数字，所以他也需要与 $2$ 操作一样变更差值，差值也是一样变成 $2^i$。

综上所述，$1$ 操作就比 $2$ 操作多了一步要更改第一个位置上的数的值，那么 $1$ 操作就可以变为 $2$ 操作，只不过要更改一下答案。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long//10^18一定要开long long 
int main(){
	int t;
	cin>>t;
	while(t--){
		ll n,k;
		cin>>n>>k;
		ll first=1;//first为第一个位置上的数，也就是本题的答案 
		ll cnt=1;//cnt为相邻两数的差值，一开始为1 
		for(int i=1;i<=k;i++){
			int x;
			cin>>x;
			if(x==1){
				first+=cnt;//执行1操作后第一个数变为第二个数，也就是原firt加上差值 
				cnt*=2;//重新更新两数差值 
			}
			if(x==2)
				cnt*=2;//只需要更新两数的差值 
		}
		cout<<first<<endl;//第一个位置的数一定是最后一个数，也就是答案
	}
	return 0;//完结撒花！ 
}
```

---

## 作者：Zskioaert1106 (赞：8)

题目传送门：[P10765 「CROI · R2」在相思树下 I](https://www.luogu.com.cn/problem/P10765)

### 题目分析

一眼分类讨论，不过也有一些基本共同点。两种操作都会砍掉大约一半的数，那……几次操作才会只剩一个数呢？~~结合样例~~很难不让人想到 $\lfloor \log_2{n} \rfloor$，那每次的操作必然与 $2$ 的幂次有着很深的联系。

联系到底在哪里呢？删除所有奇数项，那剩余的（原偶数项）每项的位置都会变成原来的 $\dfrac{1}{2}$；
删除所有偶数项，那剩余的每项位置都会变成原来的 $\dfrac{1}{2}$ 再加 $1$。我们换个角度想，其实就是维护一个等差数列：每次操作，数列的公差就会乘 $2$。假如进行 $i$ 次操作，那数列中相邻两个数的差就是 $2^{i-1}$。写成代码就是 ` diff = pow (2,i-1) `。

值得一提的是，`pow` 函数的返回值是浮点数。不过如果上文定义的变量是整数，那赋值的过程中就强转了。

#### 定义最终数

为了方便思考，我们可以想象：剩余的数最终位于数列的第一位（废话）。那我们要求它的值，只要求它前面被叉掉了几个数就行——也就是求最终数列的公差，并维护数列的首项。

#### 操作 1

当第 $i$ 次操作删除奇数项时，原数列的第一项就被叉掉了，而数列间的差更新为 $2^{i-1}$。所以假如数列第一位为 $now$，那么就更新为 $now+2^{i-1}$。

为什么让 $now+2^{i-1}$？（如果你理解，就可以直接跳到操作 2 的部分）当 $now$ 被删除时，数列下一位（即原来的第二个，即将的第一个）与之的差是 $2^{i-1}$，所以新的 $now$ 是原 $now+2^{i-1}$。

#### 操作 2

很明显，删除偶数项时，数列的第一位**不会被改动**，所以（敲重点）我们**无须做出任何操作！**（赛时我居然没想到这点，~~看来也是乱搞过的~~）

#### 总结

当操作为 $1$ 时，将当前数列第一位 $now$ 更新为 $now+2^{i-1}$，当操作为 $2$ 时，我们不动如山。

### 代码编写

最开始的时候，数列第一项是 $1$，所以最开始 $now=1$。之后 $k$ 次操作，如果输入操作 1 才进行改变，最后输出加换行。

而且，前面说过数列的公差是 $2^{i-1}$，但是如果你编写代码的时候 $i$ 从 $0$ 开始，就写 $2^i$。为什么？因为代表次数的 $i$ 是从“第 $1$ 次”开始计数，所以一个 $i-1$ （从 $0$ 起计）一个 $i+1$ 就正好“抵消”了。但你如果从数学上这样解释是不通的。

#### AC 代码

注意本题有多测，而且要开 `long long`，此外就没什么了。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long n,k;
int main(){
	int t;
	cin>>t;
	while (t--) {
		cin >> n >> k;
		long long now = 1;//十年OI一场空，不开 long long ……
		for ( int i = 1; i <= k;i++) {
			char o;
			cin >> o;
			if (o =='1') now += pow (2,i-1);
		}
		cout << now << '\n';
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/165991408)

小贴士：不开 `long long` 你能得到 [30 分](https://www.luogu.com.cn/record/165768709)；要是忘了多测你 1 分也得不到……

感谢（鞠躬）

---

## 作者：残阳如血 (赞：6)

### $\textbf{Description}$

给定一个序列 $\{a_n\}$，每次会删去所有下标为奇数或偶数的数字，给定 $k$ 次操作，求最后一个数是多少。

### $\textbf{Solution}$

思维题，浪费了我 $\rm 20\, min$。

> 引理：每次操作后，序列仍为**等差序列**。假设操作次数为 $k$，则 $k$ 次操作后公差为 $2^k$。

> 证明：
>
> 操作次数 $k=0$ 时显然成立。
>
> 假设 $k$ 次操作时成立，那么有：
> $$
> a_{j+1}-a_j=a_j-a_{j-1}=a_{i+1}-a_i=a_i-a_{i-1}=x
> $$
> 
>
> 假设删去 $a_i$ 与 $a_j$，则 $a_{i+1}-a_{i-1}=2x$，$a_{j+1}-a_{j-1}=2x$，由数学归纳法得证。

容易发现，最后剩下的一个数，在最后是序列的第一个数。~~废话文学~~

考虑维护序列中的第一个数，分情况讨论：

- 操作一：由于第一个数是奇数项，所以操作后的第一个数即为原来的第一个数 $a_1$ 加上公差。
- 操作二：删去偶数项不影响第一个数。

在每次操作后，还要将公差翻倍。

> PS：一定要开 `long long`。

### $\textbf{Code}$

```cpp
#include <iostream>
using lint = long long;

int T;
lint n, k;

int main() {
  for (scanf("%d", &T); T; --T) {
    scanf("%lld%lld", &n, &k);
    lint step = 1; // 公差
    lint first = 1; // 第一个数
    for (int op; k; --k) {
      scanf("%d", &op);

      if (op == 1) first += step; // 操作一
      step <<= 1; // 统一操作
    }
    printf("%lld\n", first);
  }
  return 0;
}
```

---

## 作者：_hxh (赞：4)

## 分析

~~看到这题上手就是一个暴力（不是~~

看到这题，样例中的数据有没有一种奇怪的感觉，就是和二进制隐隐约约有一种联系。我们分析一下：

1. 删去所有的奇数项，奇数的二进制是不是末尾是 $1$ 呢？

2. 删去所有的偶数项，偶数的二进制是不是末尾是 $0$ 呢？

当然，我们不能仅仅局限于二进制的末尾，具体请看：

假设 $n = 8,k = 3$，$k$ 次操作分别是 $2,1,2$。让我们表示一下 $1$ 到 $8$ 的二进制数：（这里把第一项当作 $0$，即研究 $0$ 到 $n - 1$）

$$0000,0001,0010,0011,0100,0101,0110,0111$$

1. **删去**所有的**偶数**项（即保留所有的奇数项）

$$000{\color{red} 0},\dots,001{\color{red} 0},\dots,010{\color{red} 0},\dots,011{\color{red} 0},\dots$$

2. 再**删去**所有的**奇数**项（即保留所有的偶数项）

$$\dots,\dots,00{\color{green} 1}0,\dots,\dots,\dots,01{\color{green} 1}0,\dots$$

3. 最后**删去**所有的**偶数**项（即保留所有的奇数项）

$$\dots,\dots,0{\color{blue} 0}10,\dots,\dots,\dots,\dots,\dots$$

看出来了吧。

设这是第 $x$ 次操作，则删去偶数项意味着我们需要保留二进制下第 $k$ 位是 $0$ 的数，删去奇数项意味着我们需要保留二进制下第 $k$ 位是 $1$ 的数。因为偶数项一定在当前的偶数位（当前设 $0000$ 是第 $0$ 位，记住我们最后研究的还是 $1$ 到 $n$），所以对于目前的第 $x$ 位，已经经历了 $x - 1$ 轮的筛选，我们只需要判断当前的第 $x$ 位就可以判断第 $x$ 轮是这个数在奇数位还是偶数位啦。

具体请看代码，**不要忘记最后的加 $1$，因为之前我们研究的是 $0$ 到 $n - 1$。**

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long ans,n,k,t,x;
int main()
{
	cin >> t;
	while (t--)
	{
		ans = 1;//初始化成1也可以
		cin >> n >> k;
		for (long long i = 1;i <= k;i++)
		{
			cin >> x;
			if (x == 1)//说明我们要保留
				ans += pow(2,i - 1);
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：IAKIOI__ (赞：4)

# 思路

这题思路有点怪，但想到后很容易写，具体的如下：

用 $ans$ 记录每一次变化后的第一个数，因为 $k$ 次操作后会只剩下一个数，所以最终的 $ans$ 即是答案。

接下来再记录每一次操作后相邻两数之间被删除的数的个数，当需要删除奇数时更新 $ans$ 最后输出 $ans$。

思路都知道了，[代码](https://www.luogu.com.cn/paste/nvakasho)就不太需要了吧。

---

## 作者：_xdd_ (赞：2)

- 全程只有操作二，那么答案一定是原序列的第一个数。
- 如果有一个操作一，那么原序列的第一个数会被删去，此时的答案就是新序列的第一个数。

数据一定保证剩下的数一定只有一个，综上其实 $n$ 没有意义。

**做数学题还是尽量把 `long long` 打开，亲身经历！**

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,T,sum;
int main(){
	cin >> T;
	while(T--){
		sum=1;
		cin >> n >> k;
		for(long long i=1;i<=k;i++){
		    long long x;
			cin >> x;
			if(x==1){
				sum+=pow(2,i - 1);
			}
		}
		cout << sum << endl;
	}
	return 0;
} 
```

---

## 作者：Breath_of_the_Wild (赞：2)

在第 $i$ 轮操作时，因为一定取走了某两个数中间的数，故这两个未取的数之差为 $2^i$。

因为最后只剩下一个数，因此可以设置一个变量从 $1$ 开始，如果要执行操作一，则就要向后跳 $2^{i-1}$ 格。而之前跳过的格子一定不会是答案，直接淘汰掉了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n,m,x;// 记得开 long long。
int main(){
	cin>>T;
	while(T--){
		cin>>n>>m;
		ll p=1;
		for(ll i=1;i<=m;i++){
			cin>>x;
			if(x==1) p+=pow(2,i-1);// 本人较懒，直接使用 pow 了。但是考试尽量别用这个。
		}
		cout<<p<<'\n';
	}
	return 0;
}
```

---

## 作者：XoCeLHsL (赞：2)

当序列是 $ak-b,k>0$，

+ 如果删去奇数项，剩下 $a(2k)-b$，即 $2ak-b$。

+ 如果删去偶数项，剩下 $a(2k-1)-b$，即 $2ak-(b+a)$。

我们发现无论如何操作，新的序列仍可以写成 $Ak-B$ 的形式。

初始状态 $a=1, b=0$，每次操作维护 $a,b$，最后取 $k=1$ 即可。

```cpp
#include <bits/stdc++.h>
#define u64 unsigned long long

long long qread()
{
    long long w = 1, c, ret;
    while ((c = getchar()) > '9' || c < '0')
        w = (c == '-' ? -1 : 1);
    ret = c - '0';
    while ((c = getchar()) >= '0' && c <= '9')
        ret = ret * 10 + c - '0';
    return ret * w;
}

u64 T, n, k, a, b, oper;

signed main()
{
    T = qread();
    while (T--)
    {
        n = qread(), k = qread(), a = 1, b = 0;
        while (k--)
        {
            oper = qread();
            if (oper == 1)
            {
                a <<= 1;
            }
            if (oper == 2)
            {
                b += a;
                a <<= 1;
            }
        }
        std::cout << a - b << std::endl;
    }
    return 0;
}

```

---

## 作者：Mier_Samuelle (赞：2)

假设原先位于序列第 $i$ 项的数此次操作后没有被删除，则：

- 若操作类型为一，则此次操作后，该数会来到序列的第 $\frac{i}{2}$ 项。
- 若操作类型为二，则此次操作后，该数会来到序列的第 $\lfloor\frac{i}{2}\rfloor+1$ 项。

最终没有被删除的数会来到序列的第 $1$ 项，因此可以通过操作类型反推初始时该数在序列中的位置。

#### AC Code

```cpp
#include <iostream>
using namespace std;
typedef long long LL;
int a[1000];
int main(){
	int T;
	cin >> T;
	while (T--){
		LL n, k;
		cin >> n >> k;
		for (int i = 1;i <= k;i++) cin >> a[i];
		LL ans = 1;
		for (int i = k;i >= 1;i--)
			if (a[i] == 1) ans *= 2;
			else ans = ans * 2 - 1;
		cout << ans << endl;
	} 
	return 0;
}
```

---

## 作者：Pursuewind (赞：2)

通过观察可以发现，每一次操作，无论是删除奇数项还是偶数项，操作后的数列都是等差数列。

进一步地，可以发现，每次操作都能使公差 $d$ 扩大一倍。

所以维护两个变量：首项 $a$ 和公差 $d$。

对于每一次操作：

- 如果删除奇数项，第一项被删除，$a\leftarrow a+d$。
- 如果删除偶数项，第一项被保留，$a$ 不变。

每次将 $d$ 翻倍即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
void solve(){
	int n, k, a = 1, d = 1, op;
	cin >> n >> k;
	for (int i = 1; i <= k; i ++){
		cin >> op;
		if (op == 1){
			a += d;
		}
		d *= 2;
	}
	cout << a << "\n";
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int t;
	cin >> t;
	while (t --) solve();
	return 0;
}
```

---

## 作者：_Hzx_ (赞：1)

【**题目大意**】

给出一个有 $1$ 到 $n$ 这 $n$ 个数的序列，每次可以进行删除所有**下标**为奇数的项，或者所有**下标**为偶数的项，问进行 $k$ 次操作以后还剩下的一个项为几？

---------------

【**解法**】

观察到 $n$ 最大能达到 $10^{18}$，思考出暴力不行并且要开 ```long long```。那么我们就可以使用一个思想，就是不要总去思考要如何快速去标记这个序列，哪些数是被删去了的，而要去思考问题的本质，思考如何找出剩下的那个项。

设 $x$ 为最终的答案。对于每次操作，考虑令 $x$ 减去某个数使得所有操作结束后就是答案。$x$ 的初始值为 $n$。当 $a_i$ 为 $1$ 时，我们看 $n$，如果为 $2$ 的倍数（这里 $n$ 实时记录了当前序列项的个数），那么直接整除 $2$，否则，也是整除 $2$，但另外需要令我们最后的答案 $x$ 减去已经处理好的值 $f$。（具体如何处理 $f$ 后续会讲到）

否则 $a_i$ 为 $2$，与上面消除下标为奇数的项不同的是，因为这次消除的是下标为偶数的项，所以在 $n$ 为 $2$ 的倍数时，才令 $x$ 减去 $f$，同样整除 $2$，但这里要注意了，为奇数时是整除 $2$ 再加 $1$。

$f$ 的值每一次操作均要乘 $2$，初值为 $1$。

（附：这里的 $a_i$ 我在代码中使用 $y$ 代替了。）

----

【**原因**】

为什么是上述做法呢？

$f$ 初值为 $1$ 是因为在第 $1$ 次操作时每个项都对应了它的下标，因此令 $x$ 减去 $1$ 是为了使其不冲突。比如 $a_i$ 为 $1$，在 $n$ 为奇数是要修改 $x$ 的值，那么个数为奇数肯定是不可能会出现奇数的，因为这是在第一次操作，所有的奇数都会被删去，因此要将 $x$ 减 $1$，令其变为偶数，这样才不会产生矛盾。

后几轮的也是类似，为了不矛盾，我们会反复将 $x$ 变为奇数或偶数，同时也能保证此时的 $x$ 是存在的，没有被删除的，因为在第一轮结束后，能保证 $x$ 后几轮都为偶数，因为 $f$ 是不停乘 $2$。这样也可以保证剩下的项全是偶数，因为在第一轮就把所有的奇数全部删了。

当然，$a_i$ 为 $2$ 是也是同理，就不再做解释。

----

【**代码**】

```cpp
#include <bits/stdc++.h> 
using namespace std; 
typedef long long ll;

const int N = 1e5 + 10;

int T;

void solve() {
	ll n, k, x; 
	scanf("%lld%lld", &n, &k);
	x = n;
	ll  y, f = 1; 
	for (int i = 1; i <= k; i++) { 
		scanf("%lld", &y);
	    if (y == 1) { 
			if (!(n % 2)) 
		        n /= 2; 
		    else { 
				x -= f; 
		    	n /= 2; 
			}
		} 
		else { 
		    if (!(n % 2)) {
				x -= f;         
				n /= 2; 
		    }
			else
				n = n / 2 + 1; 
		} 
	    f *= 2; 
	} 
	printf("%lld\n", x); 
}

int main(){ 
	scanf("%d", &T);
	for (int ti = 1; ti <= T; ti++) { 
		solve();
	}
}
```

---

## 作者：NOI__CCF (赞：1)

不难发现，数列经若干次操作后仍为等差数列，记数列的首项为 $s$，公差为 $d$，项数为 $n$。对于每次操作有如下性质：

+ 公差 $d$ 变为原来的两倍。
+ 若为操作一（删去奇数项），首项 $s$ 变为第二项 $s+d$，若为操作二则首项仍为 $s$。
+ $n$ 至少会减少 $\lfloor \frac{n}{2} \rfloor$。

由于操作 $k$ 次后只剩一个数，故 $k \le \log_{2}{n}$，按照上述性质维护 $s$ 和 $d$ 即可，最后答案即为 $s$。时间复杂度 $\mathcal{O}(Tk)$。

赛时代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;//注意开long long
ll t,n,k,op,s=1,d=1;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		s=1,d=1;
		for(int i=1;i<=k;i++){
			cin>>op;
			if(op==1){
				s=s+d;
			}
			if(op==2){
				s=s;
			}
			d<<=1;
		}
		cout<<s<<endl;
	}
	return 0;
}
```

---

## 作者：Starmoon_dhw (赞：1)

# Solution
赛事思路：
观察了一下 100% 的数据范围，$10^{18}$ 很显然，如果按照题目描述做的话，只能拿部分分，所以我们考虑其他思路。

假设最初答案的位置在 $1$。那么如果执行的是操作 $2$ 无论如何也无法改变答案，只有操作为 $1$ 的时候可以改变。

如何改变答案呢？

由于删除操作是删除所有的奇数位，所以删除的数的个数肯定是 $2$ 的 $n$ 次方。进一步分析，由于每次删除的数的个数都是 $2$ 的幂，所以第 $i$ 次操作会使答案变为 $ans+2^{i-1}$。

证明：
我们发现每次拿走的都是两个数中间的数，所以当前序列相邻两个数的差为 $2^i$ 其中 $i$ 代表了当前操作的次数，由此可以发现，如果操作为 $1$ 答案将变为 $ans+2^{i-1}$ 而如果操作为 $2$ 则答案不变。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,T,p,ans;
int main()
{
	cin>>T;
	while(T--)
	{
		ans=1;
		cin>>n>>k;
		for(long long i=1;i<=k;i++)
		{
			cin>>p;
			if(p==1)
				ans+=pow(2,i-1);
		}
		cout<<ans<<"\n";
	}
	return 0;
} 
```

本题虽然有些巧妙，但总体难度不高，适合作 T1。

---

## 作者：lpx666666 (赞：1)

## 题面
给定一个长度为从 $1$ 到 $n$ 的序列，进行 $k$ 次操作后会只留下一个数，求这个数。

## 思路
我们可以先看样例，因为这是一道找规律的题，而样例中又有单一的一种操作的输入输出，那就可以逐一击破。

首先看操作一，我最开始以为每一次操作一都会使答案乘 $2$，因为三个操作一得出 $8$ 的答案。可是去看操作二时我发现始终得不出来，我就认为因为他每次得到第一个，所以应该不变。

那结果就是满江红。

我突然发现，可能问题不是出在操作二上，而是操作一上，我们可以根据最后一组样例看出，答案至少是一，当下标为 $i$ 的位置每次出现操作一，答案就加上 $2^i$。

### 注意 
下标从 $0$ 开始。

## 代码
我们只需按上述推导打出代码即可。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int t;
long long n,k;//十年OI一场空，不开long long见祖宗
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		long long ans=1;
		for(int i=0;i<k;i++){
			int a;
			cin>>a;
			if(a==1){//操作一
				ans+=pow(2,u);//答案增加
			}
		}
		cout<<ans<<endl;
	}
	
	
	return 0;//华丽收场
}

```

---

## 作者：zhouzihang1 (赞：1)

# 「CROI · R2」在相思树下 I 题解

## 思路

我们发现不好模拟，可以逆推答案。

题目说明了，经过 $k$ 次操作后只能剩下一个数，所以序列经过操作后剩下的一个数是答案（废话）。

不妨设 $x=1$，我们把操作数组倒过来。

- 当 $op_i = 1$ 时，$x$ 仍然存在，说明 $x$ 在此次操作前在偶数位上，便 $x \leftarrow x \times 2$。

- 当 $op_i = 2$ 时，$x$ 仍然存在，说明 $x$ 在此次操作前在奇数位上，便 $x \leftarrow x \times 2 - 1$。

于是此题就完成了。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e2+10;
ll n,res;
int k,a[N];
//a 数组就是上文提到的 op 数组 
void solve()
{
	scanf("%lld%d",&n,&k);res=1;
	for(int i=1;i<=k;i++) scanf("%d",&a[i]);
	//输入
	for(int i=k;i;i--) res<<=1,res-=(a[i]&1^1);
	//每次先让 res*2，再判断当前操作是否是 2。 
	printf("%lld\n",res);
}
int main()
{
	int T=1;scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：XRRRRcode (赞：1)

## 题解
本题 $1\le n\le 10^{18}$ 的数据范围，连 $O(\sqrt{n})$ 的做法也很难通过，首先可以排除暴力做法，考虑复杂度更低的做法。

从第一次操作开始思考，若为操作一则剩余的数字均为偶数。此时可以将序列中剩余的数全部除以 $2$，重新得到一个由连续的正整数构成的序列。同理，当第一次操作为操作二时剩余的数字全部为奇数，此时将序列中剩余的数字全部加上 $1$ 后再除以 $2$，同样可以得到一个以 $1$ 开头的连续正整数序列。

这时候，我们不难发现除了数字的数量减少为初始状态的一半，所得到序列其他的状态与初始相同。根据题中所给的“保证对于所有的数据，操作 $k$ 次后均仅剩下一个数”，可以发现，经过 $k$ 次操作后，根据上述方法得到的序列仅会剩余 $1$ 个数字，即 $1$。

最后，我们的思路形成。将每次操作记录，并在全部操作读入后倒推回来，得到处理后最终为 $1$ 的数字，即答案。

因为每次操作可以去除序列中一半的数据，故可得出时间复杂度 $O(\log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[105];
int main()
{
    long long n,k,t,ans,i;
    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        ans=1;
        for(i=1;i<=k;i++)
            cin>>x[i];
        for(i=k;i>=1;i--)
        {
            if(x[i]==1)
                ans<<=1;//利用位运算加快计算速度，等同于除以2
            else
                ans=(ans<<1)-1;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---


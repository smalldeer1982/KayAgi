# 『FLA - I』歌静河

## 题目背景

> You can cry
>
> Drinking your eyes
>
> Do you miss the sadness when it's gone
>
> And you let the river run wild
>
> And you let the river run wild

— _The River_ by _AURORA_

## 题目描述

秋有两个长度为 $n$ 且仅包含 `#` 和小写字母的字符串 $a,b$。

这两个字符串总共包含 $m$ 个 `#`，秋打算执行 $m$ 次操作，用小写字母把两个字符串中所有的 `#` 都替换掉。对于第 $i$ 次操作，他要在 $a,b$ 中选择一个字符串，将这个字符串中从左向右数第一个 `#` 替换为第 $(i-1) \bmod 26 +1$ 个小写字母。**他不能选择不包含 `#` 的字符串。**

秋有一位热爱艺术的好友，他想最小化执行完 $m$ 次操作后的字符串 $a$ 的字典序。秋想，编程也是一种艺术，这样的话，他们的心也会更近一些。

## 说明/提示

**「样例解释 #1」**

第一次操作选择字符串 $a$，将 $a$ 中的 `#` 替换为第 $(1-1) \bmod 26+1=1$ 个小写字母，即 `a`；第二次操作选择字符串 $b$，将 $b$ 中的 `#` 替换为第 $(2-1) \bmod 26+1=2$ 个小写字母，即 `b`。最终的字符串 $a$ 即为 `thankyou`，可以证明这是执行 $m$ 次操作后能得到的字典序最小的 $a$。

**「数据范围」**

|测试点编号|$n \leq$|特殊性质|
|:-:|:-:|:-:|
|$1 \sim 3$|$10$|无|
|$4 \sim 6$|$10^5$|有|
|$7 \sim 10$|$10^5$|无|

- 特殊性质：保证 $a,b$ 中存在一个不包含 `#` 的字符串。

对于所有测试数据，$1 \leq n \leq 10^5$，$1 \leq m \leq 2n$，字符串 $a,b$ 仅包含字符 `#` 和小写字母。

2024 年 8 月 4 日：添加了 1 组 hack 数据置于 Subtask #1。

## 样例 #1

### 输入

```
8 2
th#nkyou
#estwish
```

### 输出

```
thankyou
```

## 样例 #2

### 输入

```
16 5
##soluteradian#e
your#awnwillcom#
```

### 输出

```
absoluteradiance
```

## 样例 #3

### 输入

```
40 45
hhuj#pzr#k#mmd#z##y#o####m##j##tga#k#t#g
m########be#######vf##a#j###ypuf###pr###
```

### 输出

```
hhujapzrakbmmdczdeyfoghijmkljmntgaokptqg
```

# 题解

## 作者：ScaredQiu (赞：32)

### 字符串、贪心

------------

#### 测试点 $1 \sim 3$

观察发现先替换掉 $a$ 中所有 `#`，再替换掉 $b$ 中所有 `#` 得到的 $a$ 字典序最小。

#### 测试点 $4 \sim 6$

由于只有一个串里有 `#`，操作顺序是唯一的，执行完 $m$ 次操作后输出 $a$ 即可。

#### 测试点 $7 \sim 10$

为了最小化字典序，应该尽量将 $a$ 中靠前的 `#` 替换成 `a`。依次考虑每个 `#`，假设当前操作中用来替换 `#` 的字符是 `y`，如果 $b$ 中剩余的 `#` 的数量能够进行两次操作，那么就对 $b$ 进行两次操作，再使用 `a` 替换 $a$ 中的 `#`。

只考虑 `a` 的原因是如果能通过对 $b$ 进行若干次操作将当前字符换成 `b`，那么可以通过减少一次操作将当前字符变成 `a`，这样不仅会让 $a$ 的字典序更小，还留出了更多的操作，显然是不劣的。

对于 $a$ 中的每个 `#`，考虑是否能通过对 $b$ 操作将用来替换的字符换成 `a`，如果能则进行操作。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
string a,b;
char s;
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>a>>b,s='a';
    for(int i=0;i<=n-1;i++) if(b[i]=='#') cnt++;
    for(int i=0;i<=n-1;i++) if(a[i]=='#'){
        if(s!='a'&&cnt>='z'-s+1) cnt-='z'-s+1,s='a';
        a[i]=s,s=s=='z' ? 'a':s+1;
    }
    cout<<a<<'\n';
    return 0;
}
```

---

## 作者：_xzhdsnh1364 (赞：6)

# [题目传送门](https://www.luogu.com.cn/problem/P10836)

这道题的思路其实很简单，首先为了使字符串 $a$ 的字典序最小，在保证字符串 $a$ 有 ```#``` 的情况下，字符串 $a$ 的第一个 ```#``` 绝对是字符 ```a```，而接着后面，我们肯定希望 ```#``` 是字符 ```a```，那么为了使这一个 ```#``` 是字符 ```a```，那么就有几次要替换字符串 $b$ 中的 ```#```，前提是次数还够用，且当前要变为的不是字符 ```a```，否则直接用当前因变为的字符，记住每次要将下一个 ```#``` 变为的字符进行一次变化，若当前不是 ```z```，直接加一，否则变为 ```a```。

这就是一个策略。

下面上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n , m , cnt;
string a , b;
char ch = 'a';
int main(){
    cin >> n >> m >> a >> b;
    //统计b中的#的个数
    for(int i = 0;i < b.size();i++){
        if(b[i] == '#')cnt++;
    }
    for(int i = 0;i < a.size();i++){
        if(a[i] == '#'){//若当前字符是#
            if(ch != 'a' && cnt >= 'z' - ch + 1){//当次数还够用且有必要去替换
                cnt -= 'z' - ch + 1;//减去处理掉的#的数量
                a[i] = 'a';
                ch = 'b';//变为下一个应当将#处理为的字符
            }
            else{//否则就直接使用当前要用的字符
                a[i] = ch;
                //变为下一个应当将#处理为的字符
                if(ch == 'z')ch = 'a';
                else ch++;
            }
        }
    }
    cout << a;
    return 0;
}
```

---

## 作者：zhengtianyu1220 (赞：3)

**经典的字符串加模拟。**

先上代码：

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,p=1,sum;
string s1,s2;//s1是a，s2是b
int main(){
	cin>>n>>m;
	cin>>s1>>s2;
	for(long long i=0;i<n;i++){
		if(s2[i]=='#')sum++;
	}
	for(long long i=0;i<n;i++){
		if(s1[i]=='#'){
			cout<<(char)((p-1)%26+'a');
			p++;
			if(sum>=26-p+1){
				sum=sum-(26-p+1);
				p=1;
			}
		}
		else cout<<s1[i];
		
	}
	return 0;
}
```

### 解释

为了最小化字典序，应该尽量将 $a$ 中靠前的 `#` 替换成 `a`。依次考虑每个 `#`，如果 $b$ 中剩余的 `#` 的数量能够进行让该字符变化 $x$ 次操作使其变 `a`，那么就对 $b$ 进行 $x$ 次操作，再使用 $a$ 替换。**他不能选择不包含 `#` 的字符串。**

于是我们得出了核心代码：


```cpp
if(s1[i]=='#'){
	cout<<(char)((p-1)%26+'a');
	p++;
	if(sum>=26-p+1){
		sum=sum-(26-p+1);
		p=1;
	}
}
```

**完结撒花。**

---

## 作者：Alexandr (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10836)

## 解析

考虑贪心。

因为要最小化执行完 $m$ 次操作后的字符串 $a$ 的字典序，所以我们把每次能用字母 `a` 替换掉 `#` 的操作都用在字符串 $a$ 上。看到题目中的替换为第 $(i-1) \bmod 26+1$ 个小写字母，容易知道是从字母 `a` 到字母 `z` 的循环。

理解了上面，我们就很容易去做贪心了。在每次操作中尽量凑出字母 `a` 给字符串 $a$ 替换，即把非 `a` 的都给字符串 `b` 替换。

---

## 作者：hjm777 (赞：1)

### 歌静河

本题是一道很好的贪心题。

首先看看当前的字母是不是 `a` 如果是的且字符串 $a$ 还有空位，就填入 $a$ 里，否则就填入 $b$ 里。

注意：**如果 $b$ 没空位了也要往 $a$ 填**。

```cpp
// Author : hejinming2012
#include <bits/stdc++.h>
#define int int
#define endl '\n'
#define dbg(x) cout << #x " = " << (x) << endl
#define quickio ios::sync_with_stdio(false);
#define quickin cin.tie(0);
#define quickout cout.tie(0);
#define maxn 200005
using namespace std;
inline int read() {
    int now = 0, nev = 1; char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') nev = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { now = (now << 1) + (now << 3) + (c & 15); c = getchar(); }
    return now * nev;
}
void write(int x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
int cnta, cntb, l = 1, r = 1;
int posa[maxn], posb[maxn];
signed main() {
    quickio
    quickin
    quickout
    int n, m; string a, b;
    cin >> n >> m >> a >> b;
    for(int i = 0; i < n; i++)
        if(a[i] == '#') posa[++cnta] = i;
    for(int i = 0; i < n; i++)
        if(b[i] == '#') posb[++cntb] = i;
    char now = 'a';
    while(l <= cnta || r <= cntb) {
        if(now == 'a' && l <= cnta) a[posa[l]] = now, l++;
        else if(now == 'a' && l > cnta) b[posb[r]] = now, r++;
        else if(r > cntb) a[posa[l]] = now, l++;
        else if(l > cnta) b[posb[r]] = now, r++;
        else if(cntb - r >= 25 - (now - 'a')) b[posb[r]] = now, r++;
        else a[posa[l]] = now, l++;
        now++; if(now == '{') now = 'a';
    }
    cout << a << endl;
    return 0;
}
```

---

## 作者：Hhy140516 (赞：1)

# [原题链接](https://www.luogu.com.cn/problem/P10836)
# 题意
有 $a$ 和 $b$ 两个长度为 $n$ 字符串，其中两个字符串一共有 $m$ 个 `#`。

我们需要进行 $m$ 次操作，从 $a$ 和 $b$ 的 `#` 中选一个，对于第 $i$ 次操作，选中的 `#` 会变成 $(i+1)\bmod26+1$ 个字母，求字典序最小的 $a$。
# 分析
可以贪心得到策略，越前面的 `#` 改的字母字典序越小。但是他需要模 $26$，所以不能直接填充。

在填的过程中，如果 $b$ 中的 `#` 的数目能够让现在要填的字母变成 `a`（`cnt >= 'z' - now + 1`，其中，$cnt$ 为 $b$ 中 `#` 的数量，$now$ 是现在要填充的字母），那么就把现在的字母变成 `a`，$b$ 中 `#` 的数目也要减少。但特别的，现在要填的字母就是 `a`，就不用变。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int main()
{
    int n , m ;
    cin >> n >> m ;
    string a , b ;
    cin >> a >> b ;
    int cnt = 0 ;//计算b中#的数目
    for( int i = 0 ; i < b.size() ; i++ ) cnt += (b[i] == '#') ;
    char now = 'a' ;//现在要填的字母
    for( int i = 0 ; i < a.size() ; i++ )
    {
        if(a[i] != '#') continue ;
        if(now != 'a' && cnt >= 'z' - now + 1) 
        {
            //更改+减少个数
            cnt -= 'z' - now + 1 ;
            now = 'a' ;
        }
        a[i] = now ;
        now++ ;
        if(now > 'z') now = 'a' ;//新的轮回
    }
    cout << a ;
    return 0 ;
}
```

---

## 作者：违规用户名^3Zj=Oha (赞：0)

## 一、思路分析

字典序最小，因此我第一时间考虑在第一项填进 $a$，后续按顺序填进去。

但此方法反例十分明显，例如：

```
40 45
hhuj#pzr#k#mmd#z##y#o####m##j##tga#k#t#g
m########be#######vf##a#j###ypuf###pr###
```
若我们的程序运行则会输出

```
hhujapzrbkcmmddzefygohiklmmnjoptgaqkrtsg
```
很明显不对，因为我们可以在填完第一个 `a` 后去填第二个字符串，然后重新要填入 `a` 时再回来填第一个字符串，很显然此时的字典序更小。

所以我们在输入字符串时分别记录两个字符串的 `#` 数量 $x$、$y$，在第一个字符串填完一个后，我们判断若此时去填第二个字符串可以让第一个字符串的下一个 `#`
 处填入字典序更小的字母，即为 $k+y \ge 26$，我们就可以更新 $y$ 为 $26-k$。此时 $k$ 代表当前应填入的字母在字母表中的位置，即 $k+'a'$ 为下一个填入的字母。若此时填第二个字符串不能使字典序更小，我们就继续填第一个字符串，重复以上顺序，直到填完。

## 二、构造代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k=0,x=0,y=0;
string a,b;
int main(){
	cin>>n>>m>>a>>b;
	for(int i=0;i<a.length();i++){
		if(a[i]=='#') x++;//记录第一个字符串中 # 数量
	}
	y=m-x;//第二个字符串中 # 数量
	for(int i=0;i<a.length();i++){
		if(a[i]=='#'){//需要填
			if(k==0){//若此时填入 a，已经是最小的字典序了，所以直接填入
				cout<<'a';
				k++;//更新应填入的字母
			}
			else{
				if(k+y>=26){//如果可以先去填第二个字符串，使下一个填入第一个字符串的字母变成 a
					cout<<'a';
					k=1;//因为此时已经填入了一个 a，所以理应将字母更新为b
					y=y-(26-k);//在第二个字符串中填入了 26-k 个字母，所以#数量减少 26-k 个
				}
				else{
					if(k==26) k=0; //若此时已经填完一遍了，更新为 a
					cout<<char(k+'a');//若无法使字典序更小，直接输出
					k++;
				}
			}
		}
		else cout<<a[i];//若不是 #，直接输出本来的字母
	}
    return 0;
}
```

---

## 作者：ys2012 (赞：0)

#### 字符串、模拟

#### 题意：
有 $m$ 次操作，从 $a$ 串或 $b$ 串里选一个 `#`，选择的 `#` 修改为 $(i+1)\bmod 26+1$。

特别的：需要保持字典序，所以要从前往后遍历每个`#`。

AcCode：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define fast ios::sync_with_stdio(0);cout.tie(0);cin.tie(0);
ll n,m;
char a[100005],b[100005];
ll cnt=0,z=1;

int main()
{
	fast
	cin>>n>>m>>a>>b;
	for(int i=0;i<n;++i)
		if(b[i]=='#')
			cnt++;
	for(int i=0;i<n;++i)
		if(a[i]=='#')
			a[i]=char((z-1)%26+'a');//根据题意更改 a 串 
			if(cnt>=26-z){
				cnt-=(26-z);
				z=1;
			}else{
				z++;
			}
	cout<<a;
	return 0;//好习惯 
}

```

---

## 作者：Lujoqera (赞：0)

### 思路:
一道很好想的字符串的题，你就使 $a$ 数组中放尽量多的字符 $a$，如你不能放 $a$，那么就去放 $b$，以此类推$\cdots$，在之中要把 $b$ 数组利用得恰当就行了。

### 代码;

```
#include <bits/stdc++.h>
#define endl '\n'
#define int long long int
using namespace std;

int a[200010];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	string a,b;
	cin>>a>>b;
	a=' '+a;
	b=' '+b;
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(b[i]=='#')
		{
			cnt++;
		}
	}
	int cur=0;
	int k=cnt+25;
	for(int i=1;i<=n;i++)
	{
		if(a[i]=='#'&&k>=25)
		{
			k-=25; 
			cout<<'a';
			cur=0;
			continue;
		}
		if(a[i]=='#')
		{
			cur++;
			if('b'+cur-1>'z')
			{
				cur-=25;
			}
			else cout<<char('b'+cur-1);
			k++;
			continue;
		}
		cout<<a[i];
	}
	return 0;
}
/*
*/
```

---

## 作者：qfy123 (赞：0)

# P10836
[传送门](https://www.luogu.com.cn/problem/P10836) 
## 赛时思路
注：区分一下，$a$ 表示字符串 $a$，```a``` 表示字母 ```a```。

很容易想到贪心，一个显然的贪心思路是，我们尽量让要填入 $a$ 的字母尽早“回跳”到 ```a```，如果回跳不了，就按顺序将字母填入 $a$。具体的，我们考虑如下做法：$a$ 中第一个要填的地方先填上 ```a```，记当前 $b$ 中可操作次数为 $cnt$。
- 如果 $cnt \ge 25$，那就先对 $b$ 进行 $25$ 次操作，这么做之后，下一次要填的字母变成了 ```a```，即 $a$ 所能填的字母“回跳”到了 ```a```，将其填入 $a$，然后将 $cnt$ 减去 $25$；
- 如果 $0 < cnt < 25$，在这种情况下，先按字母表顺序将字母填入 $a$ 中，一直填到第 $p$ 个字母，其中 $p = 26 - cnt$，然后再对 $b$ 进行 $cnt$ 次操作，这样下一次要填的字母又变成 ```a```，将其填入 $a$，并将 $cnt$ 设为 $0$。

在 $cnt = 0$ 之后如果 $a$ 后面还有要填的，按字母表顺序填入即可。显然这个策略是最优的。

用一个例子来加深理解，例如如下样例：

输入：
```
30 60
##############################
##############################
```
输出：

```
aabcdefghijklmnopqrstuabcdefgh
```
对输出分解成三部分，即：```a abcdefghijklmnopqrstu abcdefgh```。对于第一部分，由于 $b$ 的剩余操作次数为 $30 > 25$，我们在 $b$ 中填入 ```b...z```，此时 $b$ 变成 ```bcdefghijklmnopqrstuvwxyz#####```，然后下一个要填的字母再一次回到了 ```a```；对于第二部分，由于 $b$ 中剩余操作次数只有 $5$ 次，我们此时先往 $a$ 中填入 ```a...u```，对于剩下的五个字母 ```vwxyz```，我们将其填入 $b$ 后，再把下一个要填的字母 ```a``` 填入 $a$ 中，这样就能保证字典序最小；对于第三部分，由于不能对 $b$ 进行任何操作了，直接按顺序填入 $a$ 即可。

再提供一组与新增的 Hack 数据相类似的小数据：

输入：

```
30 35
##############################
#####aaaaaaaaaaaaaaaaaaaaaaaaa
```
输出：
```
abcdefghijklmnopqrstuabcdefghi
```
## 代码
代码实现上，没必要真正地去操作字符串 $b$。

赛时代码写长了，就不放赛时代码了。然后赛后想了一下，其实在编写代码时没必要分类讨论，上述两种情况可以合在一起写，~~于是就可以对代码的长度进行优化~~。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define per(i,j,k) for(int i=j;i>=k;i--)
#define r(x) scanf("%d",&x)
#define rl(x) scanf("%lld",&x)
#define rs(x) scanf("%s",x+1)
#define pr(x) printf("%d ",x)
#define pl(x) printf("%d\n",x)
#define prl(x) printf("%lld ",x)
#define pll(x) printf("%lld\n",x)
#define pc(x) putchar(x)
#define ps(x) for(ull q=1;q<=strlen(x+1);q++) pc(x[q]);pc('\n')
using namespace std;
const int N = 1e5 + 10;
char a[N],b[N];
int n,m,cnt;
int main(){
	r(n);r(m);rs(a);rs(b);
	rep(i,1,n) if(b[i] == '#') cnt++;
	int p = 0;
	rep(i,1,n){
		if(a[i] == '#'){
			if(cnt >= 25 - p){
				a[i] = 'a' + p;
				cnt -= 25 - p;
				p = 0;
				continue;
			}
			a[i] = 'a' + p;
			++p;p%=26;
		}
	}
	ps(a);
	return 0;
}

```

---


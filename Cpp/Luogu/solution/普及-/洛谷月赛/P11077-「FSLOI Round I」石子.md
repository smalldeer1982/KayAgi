# 「FSLOI Round I」石子

## 题目背景

小 F 和小 L 正在玩一种古老的博弈游戏的改版。

## 题目描述

给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个石子。设序列 $a_1,a_2,\cdots,a_n$ 的平均数为 $x$。此外，还会给定一个不大于 $x$ 的数字 $k$。小 F 和小 L 将轮流进行以下操作直至一方胜出，小 F 先手：

- 选定两堆石子 $i,j$，满足 $a_i < x < a_j$。若无法选出这样的两堆石子，则对方获胜。

- 从第 $j$ 堆石子中拿出 $k$ 个石子放到第 $i$ 堆中。

小 F 和小 L 都将用最优策略进行操作。

若游戏会无限进行下去，输出 `Draw`。若小 F 将获胜，输出 `F`。否则，输出 `L`。

小 F 一共会进行 $T$ 场游戏，你需要告诉他每场游戏的结果。

## 说明/提示

**【样例 1 解释】**

平均数为 $7$。

小 F 可以选择 $i=1,j=5$ 进行操作，使得石子数分别为 $3,5,7,9,11$。

小 L 可以选择 $i=1,j=4$ 进行操作，使得石子数分别为 $5,5,7,7,11$。

小 F 可以选择 $i=2,j=5$ 进行操作，使得石子数分别为 $5,7,7,7,9$。

小 L 可以选择 $i=1,j=5$ 进行操作，使得石子数分别为 $7,7,7,7,7$。

小 F 无法进行操作。小 L 获胜。可以证明无论小 F 如何操作，小 L 都有必胜策略。

**【数据规模与约定】**

**本题采用捆绑测试。**

设 $x$ 为序列 $a$ 的平均值。

对于 $100 \%$ 的数据，保证：
- $1 \leq T \leq 10$
- $1 \leq n \leq 2\times10^5$
- $0 \leq a_i \leq 10^9$
- $1 \leq k \leq x$
- $x$ 为整数

|子任务|分值|特殊性质|
|:-----:|:-----:|:-----:|
|$1$|$5$|$A$|
|$2$|$10$|$k = 1$|
|$3$|$15$|$n \leq 5, T =1$|
|$4$|$25$|$n \leq 1000$|
|$5$|$45$|无|

特殊性质 $A$：$a_1=a_2=a_3=\cdots=a_n$。

## 样例 #1

### 输入

```
1
5 2
1 5 7 9 13```

### 输出

```
L```

## 样例 #2

### 输入

```
2
6 3
4 7 5 3 1 16
7 2
2 6 4 8 12 4 6
```

### 输出

```
Draw
L```

# 题解

## 作者：FL_sleake (赞：16)

### 解题思路

#### Subtask 1

由于 $a$ 中元素全部相等，小 F 作为先手无法进行操作，胜者必定为小 L。

#### Subtask 2

由于 $k$ 等于 $1$，所以每次操作都会使整个序列趋于平均且不会出现对局永远进行的情况。

设序列的平均数为 $x$，容易证明所有小于 $x$ 的数与 $x$ 的差值之和等于所有大于 $x$ 的数与 $x$ 的差值之和。采用反证法，若不相等，则序列的平均数必定不为 $x$。

所以我们统计所有数与 $x$ 的差的绝对值之和，再除以二，将得到的值记为 $num$，那么经过 $num$ 次操作之后序列中元素将全部相等。我们只需判断 $num$ 除以 $2$ 的余数就能够判断是小 F 获胜还是小 L 获胜了。

#### Subtask 3 & 4 & 5

有了 Subtask 2 的铺垫，正解呼之欲出。

首先我们判断，如果存在一个 $i$，使得 $a_i$ 与 $x$ 的差不能整除 $k$，则对局将无限进行下去。为什么？考虑反向思考，对局结束的条件一定是所有元素都等于 $x$，而此时不可能对 $a_i$ 进行操作使得它等于 $x$，所以对局也就永远不会结束。

接下来考虑对局会在有限步后结束的情况。和 Subtask2 类似，我们这次记 $num$ 为所有数与 $x$ 的差的绝对值**除以** $k$ 之和，再除以二的结果。此时对局也将会在 $num$ 步之后结束。故只需判断 $num$ 除以 $2$ 的余数即可。


### 代码示例

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n,k,ave,a[200010];
signed main(){
	cin>>t;
	while(t--){
		int sum=0;
		cin>>n>>k;
		for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
		ave=sum/n;//平均值
		int flg=0;
		for(int i=1;i<=n;i++) if(abs(a[i]-ave)%k!=0) flg=1;
		if(flg){
			cout<<"Draw"<<endl;
			continue;
		}//平局
		int num=0;
		for(int i=1;i<=n;i++) num+=abs(a[i]-ave)/k;
		num/=2;
		cout<<(num%2?"F":"L")<<endl;
	}
	return 0;
}
```

---


# 破自行车

## 题目背景

某个夏天，18071 号工作室的 staff 集体转业了。辗转至年末，天依终于在 40312 号工作室拉到了合作。但是……看着编号的差距，按时到班可不是一件容易的事情。

七点半，闹铃声响起，早高峰即将迎接起床气！

## 题目描述

天依住在的城市像一个无穷大的曼哈顿。如果把城市地图放在平面直角坐标系中，任何一个**整点** $(x,y)$ 都是一个十字路口。天依家门口的十字路口为 $(0,0)$，天依需要从这里出发，尽快抵达工作室所在的十字路口 $(a,b)$。每分钟，天依可以从她所在的十字路口 $(x,y)$ 移动至 $(x+1,y)$，$(x-1,y)$，$(x,y+1)$ 或者 $(x,y-1)$。

天依怎么会走路上班呢？她可以使用一辆很快很邪门的破自行车！骑上它，天依可以从 $(x,y)$ 瞬间冲到 $(x+l,y)$，$(x,y+l)$，$(x-l,y)$，$(x,y-l)$ 四个位置中的一个，不花费任何时间。但为了避免破自行车散架，天依最多使用 $k$ 次自行车。

那么，在破自行车的助力下，天依至少需要多少时间才能从 $(0,0)$ 出发到达 $(a,b)$ 呢?

因为工作室经常搬家，所以有多组测试数据。

## 说明/提示

### 样例解释：

我们使用 $>$ 表示猛冲，$\to$ 表示行走。

对于样例一，一种可能的移动方式是：$(0,0)>(2,0)\to(3,0)\to(4,0)\to(4,1)>(4,3)>(4,5)$。

对于样例二，一种可能的移动方式是：$(0,0)\to(0,1)\to(1,1)$。

对于样例三，一种可能的移动方式是：$(0,0)>(0,8)>(8,8)$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$1 \leq T \leq 10^5$，$0 \leq a,b,k,l\leq 10^{9}$。

对于不同的子任务，作如下约定：

| 子任务编号 | $T$ | $a,b,l$ | $k$ | 特殊性质 | 子任务分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\le10^5$ | $\le10^9$ | $=0$ | 无 | $15$ |
| $2$ | $\le10$ | $\le10$ | $\le10$ | 无 | $10$ |
| $3$ | $\le10$ | $\le10^9$ | $\le20$ | 无 | $15$ |
| $4$ | $\le10$ | $\le10^9$ | $\le10^3$ | 无 | $20$ |
| $5$ | $\le10^5$ | $\le10^9$ | $\le10^9$ | $a,b\le l$ | $15$ |
| $6$ | $\le10^5$ | $\le10^9$ | $\le10^9$ | 无 | $25$ |


## 样例 #1

### 输入

```
3
4 5 3 2
1 1 4 5
8 8 4 8```

### 输出

```
3
2
0```

# 题解

## 作者：Sunset_afterglow (赞：9)

## 思路
首先当一次移动距离等于 $0$ 就直接输出 $a+b$。  
因为天依如果不用自行车的话一个时间单位只能向上下左右走一个，所以如果不用的话，就是走 $a+b$ 个时间单位。  
然后考虑使用自行车，一次走 $l$ 个格子，一定是向下使用 $x$ 次，向右使用 $y$ 次，最后一格一格走到 $(a ,b)$，注意考虑她冲刺到了后面在倒退回来的情况，以及卡了我半小时的，**注意其优化步数多的要优先考虑**。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0 ,f = 1;
	char ch = getchar();
	while('0' > ch || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch & 15);
		ch = getchar();
	}
	return x * f;
}
int T ,a ,b ,k ,l ,x ,y ,ans1 ,ans2;
signed main() {
	T = read();
	while(T --) {
		a = read(); b = read(); k = read(); l = read();
		if(l == 0) {
			cout << a + b << '\n';
			continue;
		}
		x = b / l ,y = a / l;
		if(k >= x)k -= x ,ans1 = b - x * l;
		else ans1 = b - k * l ,k = 0ll;
		if(k >= y)k -= y ,ans2 = a - y * l;
		else ans2 = a - k * l ,k = 0ll;
		if(k > 0ll) {
			if(ans1 > (l / 2) && ans2 > (l / 2) && ans2 > ans1) {
				ans2 = l - ans2;
				-- k;
			}
			if(k > 0 && ans1 > (l / 2)) {
				ans1 = l - ans1;
				-- k;
			}
			if(k > 0 && ans2 > (l / 2)) {
				ans2 = l - ans2;
				-- k;
			}
		}
		cout << ans1 + ans2 << '\n';
	}
	return 0;
}
```
###### 完结撒花(记得点赞)

---

## 作者：b__b (赞：3)

# 前置知识
点 $P(a,b)$ 和点 $Q(x,y)$ 的曼哈顿距离为 $\lvert a-x \rvert+\lvert b-y \rvert$，在本题中不使用自行车时两点间的移动时间就是两点的曼哈顿距离。
# 思路
我们可以先使用自行车移动到距离目标点最近的位于目标点右下方的点，即 $(\lfloor a/l \rfloor,\lfloor b/l \rfloor)$。（注意到当 $l=0$ 时这一步会导致异常，因此要有针对 $l=0$ 的特判。）

但是这样还是不够的，例如当目标点为 $(5,5)$，$l=3$时，按照我们已有的策略我们会先移动到 $(3,3)$，再一步一步走过去，花费 $4$ 分钟；但其实可以先移动到 $(6,6)$再走过去，花费 $2$ 分钟。

因此我们还要考虑将自行车冲过去再走回来的情况。

# 代码

```cpp
#include <iostream>
int main() {
    int t, a, b, k, l;
    for (scanf("%d", &t); t--;) {
        scanf("%d%d%d%d", &a, &b, &k, &l);
        if (!l) {
            printf("%d\n", a + b);
            continue;
        }
        int aa = std::min(a / l, k);
        a -= aa * l, k -= aa;
        int ba = std::min(b / l, k);
        b -= ba * l, k -= ba;
        if (k == 1) {
            if (l - a < l - b && l - a < a) a = l - a;
            else if (l - b < b) b = l - b;
        } else if (k) {
            if (l - a < a) a = l - a;
            if (l - b < b) b = l - b;
        }
        printf("%d\n", a + b);
    }
    return 0;
}
```

---

## 作者：_MiyazonoKaori_ (赞：3)

#### 一些闲话：
一开始写的代码是这样，然后只得了 15 pts……

```cpp
while(T--){
if(l==0){
    cout<<a+b<<endl;
    continue;
}
if(k*l>=a+b){
    int ans=a%l+b%l;
    cout<<ans<<endl;
}else{
    int x=a/l;
    int ans=0;
    if(k>=x){
    int s=a%l;
    ans+=s;
    }else{
        ans+=a-k*l+b;
        cout<<ans<<endl;
        continue;
    }
    cout<<ans+b-(k-x)*l<<endl;
    }
}
```
赛时的时候是有正解思路的，但开始打后 5 分钟就要出门了，然后就摆烂了……  
突然感觉自己 OI 学废了，连橙题都切不了了（悲）。  
然后 @[yuruilin2026](https://www.luogu.com.cn/user/1294410) 和@[Hootime](https://www.luogu.com.cn/user/1275540) 两个神犇看见了就秒了，并且说了一句“菜就多练”。  
#### 正文：
根据幼儿园就知道的知识，如果在网格图中想从 $(0,0)$ 点到 $(a,b)$ 点，只能向上下左右移动的话最少需要 $a+b$ 步；  
然后因为自行车移动不需要时间，所以我们需要尽可能多使用自行车，然后你就会想到答案为上面那个代码。  
但是这有一个问题，就是天依使用自行车在一段直线中行驶的路程可能大于那一段直线，然后再倒回来就像下面这样：  
假设自行车每次可行驶 4 格，那么就会有以下两种情况。  
注：红线为自行车所行驶的，黄线为走过的。
![](https://cdn.luogu.com.cn/upload/image_hosting/p4phnosl.png)
可以看出，如果只使用 1 次自行车那么需要走 3 格，但如果超出这段线段走到 8，那么只需要走 1 格。  
那么，我们现在就只需要把从 $(0,0)$ 走到 $(a,b)$ 的路线分为两段，从 $(0,0)$ 到 $(0,b)$ 然后从 $(0,b)$ 到 $(a,b)$，接着就可以套用上面分析出来的答案了，只不过要分为两段。  

什么？你管我要橙题的代码？

---

## 作者：liuli688 (赞：3)

### 思路
原题需要考虑的因素较多，因此先简化题面。

因为任意一个点到另一个点所需要的时间是非常好求的，因此先考虑在什么时候使用自行车。显然，在点 $(a, b)$ 左下方时应尽可能用自行车向上向右冲，直到次数用光或冲到点 $(\lfloor \dfrac a l \rfloor \times l, \lfloor \dfrac b l \rfloor \times l)$ 为止。设此时坐标为 $(x, y)$，则两个方向上的剩余距离 $(a', b') = (a - x, b - y)$。此时肯定有一种方法到达终点，即一直走路，时间为 $a' + b'$。

考虑到有可能用自行车冲过终点（直线 $y = b, x = a$）再走回头路来减少距离，因此进行特判。显然使用自行车冲过每条直线只会最多使用一次自行车，因此判断如果还能使用至少一次自行车，则尝试对两个方向分别使用一次，得到两个新时间 $(l - a') + b', a' + (l - b')$；如果还能使用至少两次自行车，则尝试对两个方向各使用一次，得到一个新时间 $(l - a') + (l - b')$。

最终答案为以上时间中取 $\min$。
### 代码
```cpp
#include <cstdio>
#include <algorithm>

int T, a, b, k, l, tmp, ans;

signed main()
{
	for (scanf("%d", &T); T--; )
	{
		scanf("%d%d%d%d", &a, &b, &k, &l);
		if (l == 0)
		{
			printf("%d\n", a + b);
			continue;
		}
		tmp = a;
		a -= std::min(a / l, k) * l;
		k -= std::min(tmp / l, k);
		tmp = b;
		b -= std::min(b / l, k) * l;
		k -= std::min(tmp / l, k);
		ans = a + b;
		if (k)
			ans = std::min(ans, std::min(l - a + b, a + l - b));
		if (k > 1)
			ans = std::min(ans, l - a + l - b);
		printf("%d\n", ans);
	}
	return 0;
} 
```

---

## 作者：LLY_0827 (赞：2)

## P11768 破自行车

### 题意理解

在平面直角坐标系中，可以使用有限次数的破自行车来瞬间传送（传送至 $(x+l,y), (x,y+1), (x-l,y), (x,y-l)$ 中任意一个点），从原点走到定点 $(x,y)$，求单步行走步数。

### 思路

- 显然在不考虑使用次数的情况下，走行距离 $l$ 时，用破自行车比单步行走更有效，可以节省时间。需尽可能让使用破自行车的次数最大化。
- 我们可以把 $x$ 轴和 $y$ 轴分开考虑，用 $pans$ 表示可能答案。
- 可能有两种情况：走到较近的点再单步走过去（下文称“近方案”），或者走到较远的点再单步返回（下文称“远方案”）。当 $a$ 对 $l$ 的余数较大时，远方案可能更加节省单步步数。
- 两种办法的步数计算主要由取余完成。在二者间取最小值。

```cpp
	//近方案为a % l ，远方案为l - a % l。
	ll f1x = a / l, f1y = b / l, f1 = f1x + f1y;
	//f1为最多使用自行车次数，f1x f1y分坐标轴考虑
	if (f1 <= k) pans = min(pans, (a % l + b % l));
   	//双坐标轴近方案
	if (f1 + 1 <= k) pans = min(pans, (a % l + l - b % l));
	if (f1 + 1 <= k) pans = min(pans, (l - a % l + b % l));
   	//考虑单坐标轴远方案
	if (f1 + 2 <= k) pans = min(pans, (l - a % l + l - b % l));
   	//考虑双坐标轴远方案
```

- 如果自行车使用步数不足，考虑用自行车传送至单坐标轴的最远点，其余同理。

```cpp
if (f1 > k) {
	if (f1x <= k) pans = min(pans, (a % l + (b - (k - f1x) * l)));
	if (f1y <= k) pans = min(pans, ((a - (k - f1y) * l) + (b % l)));

	if (f1x > k && f1y > k) pans = min(pans, ((a - k * l + b)));
	if (f1x > k && f1y > k) pans = min(pans, ((a + b - k * l)));
}
```

- 考场上为了拿过程分写了很多特判：
- 如果 $k=0$，只能单步，步数等于横纵坐标之和（坐标均为正），特判即可。

```cpp
	if (k==0) {
		cout<<abs(a)+abs(b)<<"\n";
		continue;
	}
```

- 如果 $a,b<l$，至多使用 2 次自行车：两坐标轴各一次。若足够两次，远近方案取最小；如果只有一次，考虑在一个坐标轴使用远方案。

```cpp
	if (a <= l && b <= l) {
		ll ans;
		if (k >= 2) {
			ans = min(a, l - a) + min(b, l - b);
		}
		if (k == 1) {
			ans = min(a + b, min(l - a + b, l - b + a));
        //不用远方案 vs 使用1次远方案
		}
		cout << ans << "\n";
		continue;
	}
```

---

## 作者：__CJY__ (赞：1)

这道题真的只有橙吗？

[这篇题解](/article/eurvwn6v)让我深受启发，这篇题解就来补充一下。
## 思路
当 $l=0$ 时就直接输出 $a+b$。

令 $x \gets b \div l,y \gets a \div l$，那么就可以初步计算出步行距离 $ans1,ans2$ 了。

当 $k>0$ 时，考虑优化剩余距离。

若 $ans1>(l \div 2)$，即说明步行距离较长，自行车“反向”移动，减少步行距离，$ans1 \gets l-ans1$。$ans2$ 也同理。

输出 $ans1+ans2$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,a,b,k,l,x,y,ans1,ans2;
int main(){
	cin>>T;
	while(T--){
		cin>>a>>b>>k>>l;
		if(!l){cout<<a+b<<'\n';continue;}
		x=b/l,y=a/l;
		if(k>=x) k-=x,ans1=b-x*l;
		else ans1=b-k*l,k=0;
		if(k>=y) k-=y,ans2=a-y*l;
		else ans2=a-k*l,k=0;
		if(k){
			if(ans1>(l/2)&&ans2>(l/2)&&ans2>ans1) ans2=l-ans2,k--;
			if(k&&ans1>(l/2)) ans1=l-ans1,k--;
			if(k&&ans2>(l/2)) ans2=l-ans2,k--;
		}
		cout<<ans1+ans2<<'\n';
	}
}
```

---


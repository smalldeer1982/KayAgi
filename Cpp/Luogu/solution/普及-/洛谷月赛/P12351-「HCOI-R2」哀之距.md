# 「HCOI-R2」哀之距

## 题目背景

花纹横平竖直的猫？你遇到了？

喵……喵。

------------

不知道出题人曾经是以什么样的精神状态写下了这样的题目背景，但我希望他能打赢复活赛回来 OI。

## 题目描述

哀遇到的猫可看作一个平面，上面有 $n$ 个矩形。

第 $i$ 个矩形的左下角坐标为 $(x_{i,0},y_{i,0})$，右上角坐标为 $(x_{i,1},y_{i,1})$。

求其中距离最大的两个矩形的距离。

两个矩形的距离定义为各在内部（包括四条边上）任取一点的切比雪夫距离的最小值。

**切比雪夫距离：$(a,b)$ 和 $(c,d)$ 的切比雪夫距离为 $\max(|a-c|,|b-d|)$。**

## 说明/提示

### 数据规模与约定

**本题采用捆绑测试。**
+ Subtask 0（15 pts）：$n \leq 20$，$x_{i,0}, y_{i,0}, x_{i,1}, y_{i,1} \le 20$。
+ Subtask 1（20 pts）：$n \leq 10^3$。
+ Subtask 2（25 pts）：$x_{i,0} = x_{i,1}, y_{i,0} = y_{i,1}$。
+ Subtask 3（40 pts）：无特殊限制。

对于所有数据，$2 \le n \le 2 \times 10^5 $，$0 \le x_{i,0} \le x_{i,1} \le 10^{18}$，$0 \le y_{i,0} \le y_{i,1} \le 10^{18}$。

## 样例 #1

### 输入

```
5
1 2 5 2
4 0 4 4
3 3 7 3
0 5 3 5
2 1 2 6```

### 输出

```
3```

# 题解

## 作者：HAPPINESS23333 (赞：11)

**[题目传送门](https://www.luogu.com.cn/problem/P12351)**

### 核心思路

通过观察暴力的实现，可以发现关键点在于**如何快速计算所有矩形对的极值**。

先明确定义：两个点 $(a,b)$ 和 $(c,d)$ 的切比雪夫距离为 $\max(|a-c|,|b-d|)$。

两个矩形的距离定义为各在内部（包括四条边上）任取一点的切比雪夫距离的最小值。

**接下来，我们根据暴力思想的步骤逐步优化。**

1. 根据定义我们知道，两矩形的最小距离为两个方向间隔的最大值。故问题转化为如何求某一坐标轴上对距离的贡献。显然有两种情况：
   - 两矩形在某一坐标轴上有重叠，该方向的距离贡献为 $0$。
   - 反之，则距离贡献为该轴方向上的间隔。

2. 接下来要求全局最大值。最终的全局最大值是 $x$ 和 $y$ 方向最大间隔的较大者。显然，最大 $x$ 方向间隔只有两种情况：
     - 某个矩形的左边界极大，另一矩形的右边界极小。
     - 某个矩形的右边界极大，另一矩形的左边界极小。

$y$ 方向同理。具体实现可以看代码。

---

### 来，上代码
```cpp
#include<bits/stdc++.h>
//这里我把long long改成ll了awa
#define ll long long
using namespace std;
int main(){
    int n;
    cin>>n;
    //初始化极值变量
    //mx0=所有矩形左边界最大值（对应x0的max）
    //mx1=所有矩形右边界最小值（对应x1的min）
    //my0=所有矩形下边界最大值（对应y0的max）
    // my1=所有矩形上边界最小值（对应y1的min）
    ll mx0=LLONG_MIN,mx1=LLONG_MAX;
    ll my0=LLONG_MIN,my1=LLONG_MAX;
    //遍历所有矩形，更新极值（注意：仅处理了单方向间隔）
    for(int i=0;i<n;i++){
        ll x0,y0,x1,y1;
        cin>>x0>>y0>>x1>>y1;
        //更新x方向极值
        if(x0>mx0){//维护最大左边界
        	mx0=x0;
		}
        if(x1<mx1){//维护最小右边界
        	mx1=x1;
		}
        //更新y方向极值
        if(y0>my0){//维护最大下边界
        	my0=y0;
		}
        if(y1<my1){//维护最小上边界
        	my1=y1;
		}
    }
    //计算单方向间隔
    ll dx=mx0-mx1;//最大左边界-最小右边界
    ll dy=my0-my1;//最大下边界-最小上边界
    //最终结果
    ll ans=max(max(dx,dy),0LL);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：chenzefan (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P12351)
## 前言
这道题本人在比赛时未能 AC，用了 $O(n^2)$ 的时间复杂度拿了 **35pts**。
## 涉及知识
- 贪心算法（算么？？应该算吧~）。

- 切比雪夫距离。
## 思路分析
**暴力 35pts**

首先 **35pts** 的超时思路，即用双重循环遍历每一组矩形，求切比雪夫距离的最小值 $\min$，并求所有结果的最大值 $\max$。

**代码部分**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+5;
int n,ans;
struct node{
    int x1,x2,y1,y2;
}a[N];
int dis(int a,int b,int c,int d){return max(abs(a-c),abs(b-d));}
void check(int i,int j){
    int minn=LLONG_MAX;
    //注意情况很多，因为四个角都要算
    minn=min(minn,dis(a[i].x1,a[i].y1,a[j].x1,a[j].y1));
	minn=min(minn,dis(a[i].x1,a[i].y1,a[j].x1,a[j].y2));
    minn=min(minn,dis(a[i].x1,a[i].y1,a[j].x2,a[j].y1));
    minn=min(minn,dis(a[i].x1,a[i].y1,a[j].x2,a[j].y2));
    minn=min(minn,dis(a[i].x1,a[i].y2,a[j].x1,a[j].y1));
    minn=min(minn,dis(a[i].x1,a[i].y2,a[j].x1,a[j].y2));
    minn=min(minn,dis(a[i].x1,a[i].y2,a[j].x2,a[j].y1));
    minn=min(minn,dis(a[i].x1,a[i].y2,a[j].x2,a[j].y2));
    minn=min(minn,dis(a[i].x2,a[i].y1,a[j].x1,a[j].y1));
	minn=min(minn,dis(a[i].x2,a[i].y1,a[j].x1,a[j].y2));
    minn=min(minn,dis(a[i].x2,a[i].y1,a[j].x2,a[j].y1));
    minn=min(minn,dis(a[i].x2,a[i].y1,a[j].x2,a[j].y2));
    minn=min(minn,dis(a[i].x2,a[i].y2,a[j].x1,a[j].y1));
    minn=min(minn,dis(a[i].x2,a[i].y2,a[j].x1,a[j].y2));
    minn=min(minn,dis(a[i].x2,a[i].y2,a[j].x2,a[j].y1));
    minn=min(minn,dis(a[i].x2,a[i].y2,a[j].x2,a[j].y2));
    ans=max(ans,minn);
}
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld%lld%lld%lld",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
    //双重循环暴力，O(n^2)！！
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            check(i,j);
    printf("%lld",ans);
	return 0;
}
```
过于简单，就不赘述了。

**正解 100pts**

既然要求切比雪夫距离最小值的最大值，不妨将 $(\max(|a−c|,|b−d|))$ 拆开，即答案要求横坐标差的最大值与纵坐标差的最大值之间的最大值 $\max$。差的最大值肯定是由被减数的最大值 $\max$ 减去减数的最小值 $\min$。

确定的是：

- 左上角的点的横纵坐标肯定比右下角大（或等于）。

- 右上角的点的横纵坐标肯定比左下角小（或等于）。

那么，就不用结构体数组保存了，直接在输入时操作即可。

有了思路，我们就要写代码。时间复杂度 $O(n)$。

**注意：本题要开 long long。**

**代码部分（含注释）**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //一定要 long long ！！ 
const int N=2e5+5;
int n,max_x=-1e18,max_y=-1e18,min_x=1e18,min_y=1e18;//根据题目给的范围初始化 
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
    	int x1,x2,y1,y2;
    	scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
    	//左上角的点的横纵坐标肯定比右下角大（或等于），所以用来求最大值 
    	max_x=max(max_x,x1);
		max_y=max(max_y,y1);
		//右上角的点的横纵坐标肯定比左下角小（或等于），所以用来求最小值 
    	min_x=min(min_x,x2);
    	min_y=min(min_y,y2);
	}
    printf("%lld",max(max(0ll,max_x-min_x),max(0ll,max_y-min_y))); //注意用 0ll 不是 0 
	return 0;
}
```
## 后附
不要抄袭代码！！不要直接复制！！

先清晰思路，再进行借鉴！！

**若有笔误，请指出，感谢。**

---

## 作者：Heyg_future (赞：4)

# 「HCOI-R2」哀之距
## [题目传送门](https://www.luogu.com.cn/problem/P12351)
### PART 1
本题其实暴力思路非常容易想到。因为两个矩形的距离定义为各在内部（包括四条边上）任取一点的切比雪夫距离的最小值。而它会给出两个对顶点的坐标，所以两个矩形的距离即为两对对顶点的切比雪夫的最小值。所以非常简单写出暴力代码。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm> 
using namespace std;
const int N=2e5+3;
long long n;
long long x1[N],x2[N],y3[N],y2[N],maxx=-1e18;
long long d(long long x,long long y,long long p1,long long p2){
	return max(abs(x-p1),abs(y-p2));
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x1[i]>>y3[i]>>x2[i]>>y2[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			long long p,t;
			p=min({d(x1[i],y3[i],x1[j],y3[j]),d(x1[i],y3[i],x1[j],y2[j])});
			p=min({p,d(x1[i],y3[i],x2[j],y2[j]),d(x2[i],y2[i],x1[j],y3[j])});
			p=min({p,d(x1[i],y2[i],x1[j],y2[j]),d(x2[i],y3[i],x2[j],y3[j])});
			p=min({p,d(x2[i],y3[i],x1[j],y2[j]),d(x1[i],y2[i],x2[j],y3[j])});
			p=min({p,d(x2[i],y2[i],x2[j],y2[j]),d(x2[i],y2[i],x2[j],y2[j])});
			maxx=max(maxx,p);
		}
	}
	cout<<maxx;
    return 0;
}
```
可以得 $35$ 分这也是赛场拙码，~~赶着回学校没再优化了~~。
### PART2
回去以后我仔细一想，好像可以跳过最大距离的两个矩形之间的所有矩形，这样就可以不用遍历全部了，只需要记录各个方向的距离最大值，再找出最终答案即可。

具体而言，就是记录纵方向和横方向的第二大值和第二小值，其差就是该方向的最大距离，然后再将横方向与纵方向的最值再比较一次就可以啦。当然，当所有矩形都挤在一起时最大距离为  $0$ 时，记录的差值可能为负数，所以要特判一下。这样即可通过此题啦。

代码如下。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=2e5+3;
long long n,f1=-1e18,f2=-1e18,f3=1e18,f4=1e18,x1,x2,y3,y2; 
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x1>>y3>>x2>>y2;
		long long xx=min(x1,x2),yy=min(y3,y2);
		f1=max(f1,xx);
		f2=max(f2,yy);
		xx=max(x1,x2),yy=max(y3,y2);
		f3=min(f3,xx);
		f4=min(f4,yy);
	}
	if(max(f1-f3,f2-f4)<0) cout<<0;
	else cout<<max(f1-f3,f2-f4);
    return 0;
}
```
啦啦啦，完结撒花！

---

## 作者：convie (赞：2)

考虑到对于每个矩形，其会产生影响的点为左下角以及右上角，可以设四个变量来记录全部矩形的左下角最大横坐标与最大纵坐标，以及右上角的最小横坐标与最小纵坐标，代码如下。
```
#include<iostream>
using namespace std;
#define int long long
signed main(){
	int n;
	cin>>n;
	int mix=1e18+1,miy=1e18+1;
	int mxx=0,mxy=0;
	for(int i=1;i<=n;i++){
		int x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		mix=min(mix,x2);
		mxx=max(mxx,x1);
		miy=min(miy,y2);
		mxy=max(mxy,y1);
	}
	cout<<max(0ll,max(mxx-mix,mxy-miy));
	return 0;
}
```

---

## 作者：__CJY__ (赞：2)

## 思路
我们设置以下变量：
* $a$：所有矩形右上角 x 坐标的最小值。
* $b$：所有矩形左下角 x 坐标的最大值。
* $c$：所有矩形右上角 y 坐标的最小值。
* $d$：所有矩形左下角 y 坐标的最大值。

在 x 轴上，我们计算 $b-a$，即所有矩形左下角 x 坐标的最大值与右上角 x 坐标的最小值之差。如果 $b>a$，说明所有矩形在 x 轴上不重叠，此时 $b-a$ 即为 x 轴上的最小切比雪夫距离；否则为 $0$。

在 y 轴上，同理计算 $d-c$。

所以最终结果为：
$$\max(\max(b-a,0),\max(d-c,0))$$

记得开 `long long`！
```cpp
#include<bits/stdc++.h>
#define ll long long
#define LLMA LONG_LONG_MAX
#define LLMI LONG_LONG_MIN
using namespace std;
ll n,a=LLMA,b=LLMI,c=LLMA,d=LLMI;
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		ll x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;
		a=min(a,x2),b=max(b,x1),c=min(c,y2),d=max(d,y1);
	}
	cout<<max(max(b-a,0ll),max(d-c,0ll));
}
```

---

## 作者：wyc_9231 (赞：1)

### 实现思路

乍一看肯定是暴力，遍历所有可能的组合并计算最小的切比雪夫距离。于是你就能写出如下代码：

```cpp
using ll=long long;
struct S
{
    ll x0,y0,x1,y1;
};
ll minqbxf(S a,S b)
{
    ll xdis=max({a.x0-b.x1,b.x0-a.x1,0LL});
    ll ydis=max({a.y0-b.y1,b.y0-a.y1,0LL});
    return max(xdis,ydis);
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);
    int n;cin>>n;
    vector<S> a(n);
    for(int i=0;i<n;i++)
        cin>>a[i].x0>>a[i].y0>>a[i].x1>>a[i].y1;
    ll maxd=0;
    for(int i=0;i<n;i++)
        for(int j=i+1;j<n;++j)
        {
            ll dis=minqbxf(a[i],a[j]);
            maxd=max(maxd,dis);
        }
    cout<<maxd;
}
```

$\Omicron(n^2)$，对于 $n\le2\times10^5$ 不超时才怪呢。

这时就要**降维**。

- 由于切比雪夫距离是 $x$ 和 $y$ 轴距离最大值，我们就可以分别计算 $x$ 和 $y$ 轴上的最大距离。

- 再把一个矩形在 $x$ 和 $y$ 轴上的坐标投影为区间，如矩形 $i$ 在 $x$ 轴投影为 $[x_{i,0},x_{i,1}]$，在 $y$ 轴投影为 $[y_{i,0},y_{i,1}]$。

- 投影后，需要找到两个区间的最大距离。具体地就是对于每个轴，把这些矩形按左端点排序并维护之前区间的最小右端点。对于当前区间，再计算其左端点与之前最小右端点的差并取最大值。（~~为什么每次讲都感觉很绕啊~~）

这样，我们就优化到线性啦~

### 代码实现

```cpp
using ll=long long;
struct S
{
    ll l,r;
    bool operator<(S other) const
    {
        return l<other.l;
    }
};
ll cal(vector<S> a)
{
    if(a.size()<2) return 0;
    sort(a.begin(),a.end());
    ll maxn=0;
    ll minn=a[0].r;
    for(int i=1;i<a.size();i++)
    {
        ll n=a[i].l-minn;
        maxn=max(maxn,n);
        minn=min(minn,a[i].r);
    }
    return maxn>0?maxn:0;
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);
    int n;cin>>n;
    vector<S> xa(n),ya(n);
    for(int i=0;i<n;i++)
    {
        ll x0,y0,x1,y1;cin>>x0>>y0>>x1>>y1;
        xa[i]={x0,x1},ya[i]={y0,y1};
    }
    ll maxx=cal(xa),maxy=cal(ya);
    ll ans=max(maxx,maxy);
    cout<<ans;
}
```

---

## 作者：weizilong (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P12351)
## 闲话
本蒟蒻第二篇题解。
# 正文
## 题目重述
这道题要求我们找到平面上 $n$ 个矩形中，距离最大的两个矩形之间的距离。

这里的距离定义为：两个矩形各自内部（包括边界）任取一点，这两个点之间的**切比雪夫距离**（对于点 $(a,b)$ 和点 $(c,d)$，它们的切比雪夫距离 $=\max(|a-c|,|b-d|)$）的最小值。

## 关键
对于两个矩形，它们之间的最小切比雪夫距离实际上就是**两个矩形在 $x$ 方向和 $y$ 方向上的最小分离距离中的最大值**。

所以本题可以转化为以下问题：

1. 找到所有矩形的最小右边界和最大左边界之差。
2. 找到所有矩形的最小上边界和最大下边界之差。

最终结果就是这两个值的最大值。
## 代码思路

### 初始化变量：
$\text{max\_x}$：记录所有矩形左边界中的最大值。

$\text{max\_y}$：记录所有矩形下边界中的最大值。

$\text{min\_x}$：记录所有矩形右边界中的最小值。

$\text{min\_y}$：记录所有矩形上边界中的最小值。
### 遍历所有矩形‌：
这一步在输入中就可以顺便做到。

对于每个矩形，计算其所有边界，更新全局的变量。

最终结果‌就是 $\max(\text{max\_x} - \text{min\_x}, \text{max\_y} - \text{min\_y})$。

**注意**：如果结果为负数，那么表示所有矩形都有重叠，则输出  $0$。

### 时间复杂度；
这个算法只需要一次遍历所有矩形，时间复杂度是 $O(n)$，对于 $n≤2×10^5$ 的数据规模是完全可行的。
## 代码
最终代码如下，完结撒花。**（〃'▽'〃）**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,max_x=-1e18,min_x=1e18,max_y=-1e18,min_y=1e18;
long long lx,ly,rx,ry; 
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>lx>>ly>>rx>>ry;
		max_x=max(max_x,lx);
		max_y=max(max_y,ly);
		min_x=min(min_x,rx);
		min_y=min(min_y,ry);
	}
	long long ans=max(max_x-min_x,max_y-min_y);
	if(ans<0) cout<<0;
	else cout<<ans;
    return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

很明显可以投影到 $x$ 和 $y$ 轴：将每个矩形投影到 $x$ 轴和 $y$ 轴上，$x$ 轴投影：每个矩形对应一个区间 $[x_0, x_1]$。$y$ 轴投影：每个矩形对应一个区间 $[y_0, y_1]$，然后计算 $x$ 方向的最大距离，就是找到所有 $x$ 区间的最大左端点（$x_0$）和最小右端点（$x_1$）。

如果最大左端点 $>$ 最小右端点，那么 $x$ 方向的最大距离是最大左端点 $-$ 最小右端点，否则，$x$ 方向的最大距离是 $0$（所有矩形在 $x$ 方向上有重叠），计算 $y$ 方向的最大距离：同理上面求取 $x$ 的。

最终结果就是取 $x$ 和 $y$ 方向的最大距离中的较大者即可。

```cpp
cin >> n;
for (int i = 1; i <= n; i++) {
  cin >> x[i].x >> x[i].y >> x[i].x1 >> x[i].y1;
  a = max(a, x[i].x), c = min(c, x[i].x1);
  b = max(b, x[i].y), d = min(d, x[i].y1);
}
cout << max(0ll, max(a - c, b - d)) << '\n';
```

---


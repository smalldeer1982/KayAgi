# 小A的糖果

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。


## 说明/提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

## 样例 #1

### 输入

```
3 3
2 2 2```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 1
1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9
3 1 4 1 5```

### 输出

```
0
```

# 题解

## 作者：lzk5627 (赞：220)

好吧这是道水题（只要你找到方法）
首先我们可以把这几个糖果盒分对来讨论；
先从第一个糖果盒和第二个开始；
如果一个糖果盒的数量就超限了，我们当然至少要把它吃到剩下x个；
然后如果单论两个都没有超限，但加起来超限了怎么办呢？
首先第一个糖果盒是只有一个分组的（和第二个），
而第二个糖果盒却有两个分组（和第1个/和第3个）；
所以如果我们吃掉第一个里的，只会减少一个分组的量，而如果吃掉第二个里的，可以减少2个分组的量。所以我们要尽量吃掉第二个里的糖果。
处理好第一个分组后，来看第二个，因为第一个分组已经被处理好了，所以可以无视它，然后问题又变成了前一个问题。
以此类推就好了。

```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long sum=0//计数器,n,x;
	cin>>n>>x;//输入
	long long a[n+1];
	cin>>a[1];//处理第一个单独超限。
	if(a[1]>x)
		{
		sum+=a[1]-x;//增加吃的量
		a[1]=x;//a[i]>=x,要吃的最少，即是a[i]=x;
		}
	for(int i=2;i<=n;i++)
		{
		cin>>a[i];//输入
		if(a[i]+a[i-1]>x)//照例处理
			{
			sum+=a[i]+a[i-1]-x;
			a[i]=x-a[i-1];
			}
		}
	cout<<sum;//输出
	return 0;//养成好习惯
} 
```

---

## 作者：a___ (赞：104)

## ~~怎么能没有一个好题解？！！！~~

### 第一个题解太复杂；第二个不对；        最后一个或许短且可以AC但我这组数据绝对过不了：

```cpp
- 3  10 -
-  9999 0 11 -
-  min答案：9990 -
```
现在切入正题，讲代码：

思路都对，用贪心，尽量让本次后面（下次前面）尽可能小

区别就在对待第一个数：

###第一个数需要单独处理

否则，会出现***负糖果数***！！！

##附代码及运算样例过程：

###代码：

```cpp
#include <cstdio>//为了快
long long n,a[100010],x,ans,yy;//我知道可以不定义数组，但为了用空间换时间（怕超时）
int main()
{
    register int i;//register定义循环变量据说能加速
    scanf("%lld%lld",&n,&x);//注意是%lld
    for (i=1;i<=n;i++)//从1~n很好地保证了第一个是a[0]和a[1],相当于单独考虑a[1]
    {
        scanf("%lld",&a[i]);//输入
        if (a[i]+a[i-1]>x)yy=a[i]+a[i-1]-x,a[i]-=yy,ans+=yy;//两数之和超过，优先吃后面的，贪心（为了使后面加起来更小）
    }
    printf("%lld",ans);//lld哦
    return 0;//记得返回0
}
```
###代码在开篇样例中的运行过程：

之前最后那篇题解:

```cpp
-                p           t               ans       -
- 1          9999      -9989       9989      -
- 2         -9989        11          9989      -
```
```cpp
- 结果：    盒子1            盒子2                  盒子3 -
-               9999颗         -9989颗                11颗 -
```
本题解：

```cpp
-                     a[i-1]                    a[i]              ans            -
- 1                      0                      10              9989          -
- 2                     10                      0               9989          -
- 3                      0                      10              9990          -
```
```cpp
- 结果：    盒子1            盒子2                  盒子3 -
-                10颗                0颗                   10颗  -
```

---

## 作者：北凌scoffs (赞：23)

```c
#include<bits/stdc++.h>
using namespace std;
long long n,x; 
long long a[1005*1005];
long long sum=0;//存储吃糖果的个数
int main() {
	ios::sync_with_stdio(false);
	//cin和cout没有scanf和printf效率高，why？
	//因为，cin与stdin'是保持同步的
	// 就是说他们可以混搭，文件指针不会乱成一锅粥
	//out与stdout同理，输出不会出现顺序错乱
	//怎么禁止这个特性呢？
	//你只需要---ios::sync_with_stdio(false);
	cin>>n>>x;
	for(int i=1; i<=n; i++)
		cin>>a[i];//输入数据
	for(int i=1; i<=n; i++) {
		if(a[i]>x) {
			//这个是一个处理
			//因为要求--a[i]+a[i-1]<=x，那么满足这个条件的先觉是，必须每一个盒子的糖果数都必须<=x吧
			//因为我的a[i]都>x,的话，凉凉,a[i]+a[i-1}铁定>x;
			sum+=a[i]-x;//至少让a[i]==x嘛,就吃掉多余的 
			a[i]=x;//上面说了撒，至少保证a[i]==x; 
		}
	}
	for(int i=2; i<=n; i++) {//因为a[i]+a[i-1]的缘故，所以i从2开始，其实从1开始也可以，a[0]=0，不影响 
		if(a[i]+a[i-1]>x) {//如果大于了x,就准备吃糖吧 
			sum+=a[i]+a[i-1]-x;//吃掉多余的 
			a[i]=x-a[i-1];//贪心--因为我要吃最少的糖满足条件，就必须保证a[i]+a[i-1]刚好等于x，就可以少吃糖 
		}
	}
	cout<<sum;//收工，输出答案 
	return 0;//养成一个好习惯 
}
```


---

## 作者：封禁用户 (赞：20)

[题目传送门](https://www.luogu.com.cn/problem/P3817)

本题是一道很水的贪心。

如果相邻两个盒子糖果的数量大于 $x$，就吃右边盒子的糖，否则不进行任何操作。

~~应管理员的要求~~，讲一下为什么要吃右边盒子的糖：这是因为如果我们吃掉左边盒子里的糖，就只会减少这一轮相邻两个盒子糖果的数量；如果我们吃掉右边盒子里的糖，那么这次操作还可以减少下一轮相邻两个盒子糖果的数量，符合贪心的逻辑。

```cpp
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
#define int long long
int a[1000005];
signed main(){
	int n,x,ans=0;
	cin>>n>>x;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}	
	for(int i=1;i<=n;i++){
		if(a[i-1]+a[i]>x){
			ans+=a[i-1]+a[i]-x;
			a[i]-=a[i-1]+a[i]-x;
		}
	}cout<<ans;
	system("shutdown -s -t 0");
	return 0;
}
```

---

## 作者：xu222ux (赞：9)

# [P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817#submit)
~~好吧此题很水~~
## 思路

就是一道简单贪心。

如果我发现相邻两个数的和大于 $x$ 了，那么就把右边的那个数扣掉一些，使得两数之和等于 $x$。

有人会说，那么不会被减成负数吗？答案是不会，因为每个数只会被扣一次，而 $a_{i-1}+a_{i-2}$ 已经满足条件了，所以 $a_{i-1}$ **不会$>x$**，那么 $a_i$ 被扣完后，也就不会 $<0$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x;
long long a[100005];
long long ans;
int main() {
    cin>>n>>x;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        if (a[i]+a[i-1]>x) {
			ans+=a[i]+a[i-1]-x;
			a[i]=a[i]-(a[i-1]+a[i]-x);
		}
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：阿拉丁神坑 (赞：7)

**居然是PJ-**

### 方法
模拟，贪心（？），边读边算，节省一个for

#### 贪心策略

过一遍，过的时候把需要吃掉的糖吃掉，这样就可以保证吃掉的糖最小

### 代码

```cpp
#include <iostream>
long long n, x, ans;//没开long long的我第一次得80
long long caddy[100005];//开long long
int main()
{
    std::cin >> n >> x;//读入
    for (long long i = 1; i <= n; i++)
    {
        std::cin >> caddy[i];
        if (caddy[i] + caddy[i - 1] > x)//如果需要吃糖
        {
            ans += caddy[i] + caddy[i - 1] - x;//算一下吃了多少糖
            caddy[i] -= caddy[i] + caddy[i - 1] - x;//把吃掉的糖去掉
        }
    }
    std::cout << ans;//输出答案
    return 0;
}
```



---

## 作者：mj666 (赞：5)

简单的模拟

n,x,a数组意义与题目一致

b数组表示相邻两个盒子糖果数之和

减去x后如果为0或负数跳过就行

如果是正数并且b[i+1]为非正数，那么必须吃掉b[i]个糖果

如果是正数并且b[i+1]为正数，一样要吃掉b[i]个糖果，同时b[i+1]减掉不b[i]

这就是那两个if

最后输出答案就好



       
         
   
```cpp
#include<bits/stdc++.h>
using namespace std;
long long  n,x,ans=0;
long long  a[100001],b[100002];
int main()
{
    cin>>n>>x;
    for(long long i=1;i<=n;i++)
    {
          cin>>a[i];
          b[i]=a[i-1]+a[i];
          b[i]-=x;
    }
    for(long long i=1;i<=n+1;i++)
    {
       if(b[i]>0&&b[i+1]<=0)
       {
         ans+=b[i];
       }
       if(b[i]>0&&b[i+1]>0)
       {
          ans+=b[i];
          b[i+1]-=b[i];
       }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Goes (赞：5)

前人发的代码好繁琐啊，来看我的:

当然还是贪心，我们只需要记录当前这堆和前一堆的状态就行

努力吃现在这一堆就可以让后面少吃

什么数组什么的都不用，只需要long long 两个数



    
    
```cpp
#include<cstdio>
#include<iostream> 
using namespace std;
long long nex,now;
long long  n , x , ans ;
long long gsmax(long long x,long long y)
{    if(x>y)    return x;
    else return y;
}
int main()
{
    cin>>n>>x;
    for(long long i=1;i<=n;i++)
    {
        cin>>now;
        long long del=gsmax((now+nex-x),0);
        nex=now-del;
        ans+=del;
    }
    cout<<ans;
}
```

---

## 作者：_txb_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3817)

## 思路
考虑贪心，如果相邻两个数大于要求的数，就要在后面的那个数减掉两数之和减去要求的数，因为减在后面的数会使后面吃的糖少一些。

贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x,a[100005];
	long long sum=0;//十年oi一场空，不开longlong见祖宗！！！ 
	cin>>n>>x;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]+a[i-1]>x)//如果相邻两颗吃的糖要是大于要求 
		{
			int tmp=a[i]+a[i-1]-x;//用一个数保留要吃的数 
			sum+=tmp;//答案加上吃走的数 
			a[i]-=tmp;//在第二个数减掉要吃的数
		}
	}
	cout<<sum;//输出 
	return 0;
}
```


---

## 作者：Dorbmon (赞：2)

你们都这么不喜欢用vector吗。我喜欢哈哈。
这个是我这个菜鸡写的代码。还能看吧应该。。
简单的贪心算法。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ui long long
int main() {
    ui N,x;
    cin >> N >> x;
    vector<ui> tang;
    for(ui i = 0;i < N;i ++) {
        ui temp;
        cin >> temp;
        tang.push_back(temp);
    }
    ui ans = 0;
    //贪心算法
    for(auto ptr = tang.begin();ptr != tang.end();ptr ++) {
        if(ptr == (tang.end() - 1)) {   //后面为空
            if(*ptr > x) {
                ans += *ptr - x;
            }
            break;
        }
        //判断有没有超标
        if(*ptr + *(ptr + 1) > x) {
            ans += *ptr + *(ptr + 1) - x;
            *(ptr + 1) =  x - *ptr; //下一项
        }
    }
    cout << ans << endl;
    return 0;
}
```
就这样吧。

---

## 作者：myfly (赞：2)

## 来一发最**简捷**的题解：
```cpp
//P3817 小A的糖果
# include <iostream>
using namespace std;
int main() {
    int N,M; cin>>N>>M;
    long long ans=0;//注意数据范围
    for (int i=0,x,rex=0,sub; i<N; i++) {
    	//i从0开时遍历，糖果不会吃成负数
        cin>>x;
        if (x+rex>M) {
        	//开始贪心
            sub=x+rex-M;
            ans+=sub;
            x-=sub;
        }
        rex=x;//滚动数组
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Nightfury12366 (赞：1)

这题刚开始想得太复杂了。。。

它只是涉及两两比较，所以要尽量往后吃，下一次就能尽可能吃得少

```cpp
#include<iostream>
using namespace std;
long long N, x, sum;    //开 long long ,不然不能AC
int main()
{
    cin >> N >> x;
    long long *A = new long long[N];
    for (long long i = 0; i < N; i++)
        cin >> A[i];
    for (long long i = 0; i < N - 1; i++)
    {
        if (A[i] + A[i + 1] > x)
        {
            sum += A[i] + A[i + 1] - x;     //这次要吃掉的糖果数
            if (A[i + 1] > (A[i] + A[i + 1] - x))
                A[i + 1] -= (A[i] + A[i + 1] - x);
            else
                A[i + 1] = 0;    //糖果不会吃成负数，此时要吃前一个口袋的糖果，
                                                       //但是只有两两比较，前一个吃的不再影响后面的了，所以清零即可
        }
    }
    cout << sum << endl;
    //system("pause");
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)



    

```cpp
#include <iostream>
using namespace std;
long int sugar[int(1e5)],x,n,ans=0; 
//功能：将sugar[a] 和 sugar[b]的和减至m 
//原理：为了使结果最小，就需要从sugar[b]开始减起（这使得下一组数据和最小），
//直接用tmp减去sugar[b]，若得到负数则将多减部分加到sugar[a]上即可 
void _minus(int a,int b,int m)
{
    if(sugar[a]+sugar[b]<=m) return;
    int tmp=sugar[a]+sugar[b]-m;//应当减掉的数 
    ans+=tmp;
    sugar[b]-=tmp;
    if(sugar[b]<0)
    {
        sugar[a]-=sugar[b];
        sugar[b]=0;
    }
    return;
} 
int main()
{
    cin>>n>>x;
    for(int i=0;i<n;i++) cin>>sugar[i];
    for(int i=0;i<n-1;i++) _minus(i,i+1,x);
    cout<<ans;
    return 0;
}
```

---

## 作者：wuxinyu (赞：1)

#来发最容易理解的C++版

···
cpp
```cpp
#include <iostream>
int main()
{
    int n,x;
    std::cin>>n>>x;
    int* a = new int [n+1];     //动态数组，不用管，按普通数组理解； 
    long long sum=0;            //必须要long long，int型会会两测试点WA，且谨记把sum归0； 
    for(int i=1;i<=n;i++)
     std::cin>>a[i];            //把数输入； 
    for(int i=2;i<=n;i++)
     {
         if(a[i]+a[i-1]>x)       //相邻的两个数和x比较； 
         {
             sum+=a[i]+a[i-1]-x; //把两数和减去x，得多余的要吃的糖数； 
            a[i]-=a[i]+a[i-1]-x;//因为要求最少，慢慢理解要从第二个数减直至最后一盒；再想想从第一盒起减，那么和第三盒就没关系了； 
         }
        if(a[i]<0)              //减多了会有负数，这时要从前一个盒子减（这个不用管），所以把负数清零； 
         a[i]=0;
     }
    std::cout<<sum;             //输出吃的糖数； 
    delete [] a;                //动态数组的内存清空，不用管； 
    return 0;
}
```
···
#提醒一下从第二盒开始减比较好，想一下从第一盒开始减会什么不同；


---

## 作者：重力做功 (赞：1)

#来发Pascal

1.思路是啥？

贪心。

2.刚才的回答太简单。

。。。具体点，就是死命撑到最后再吃，吃后面的。

3.然后我就WA了

需要注意不能把后面的那个吃到负数。

4.然后我还是WA

呃。。。记得开大点。


>代码<

```cpp
var
  n,i,k,x:longint;
  ans:qword;//qword防爆
  a:array[1..100000]of longint;//也可直接读
begin
  readln(n,x);
  for i:=1 to n do read(a[i]);
  for i:=2 to n do//从2开始，比对i和i-1
    if a[i]+a[i-1]>x then
     begin
       k:=a[i]+a[i-1]-x;//k记录的是要吃的糖果数
       if a[i]>=k then dec(a[i],k) else a[i]:=0;//尽量往后吃
       inc(ans,k);
     end;
  writeln(ans);
end.//没了╮(╯_╰)╭
```

---

## 作者：就是小马啊 (赞：1)

## **题目很简单，不要直接复制粘贴！！！**
开始还在纠结，要是每个都大于所需的数要怎么办，后来想了一下，在每次递推的过程，先处理第一个数，再根据变化的第一个数处理第二个数，一次迭代就可以了。
第一次的代码 得分80.
```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> a;
int main() {
    int n, x, ans = 0;
    cin >> n >> x;
    for (int i = 0; i < n; i++) {
        int c;
        cin >> c;
        a.push_back(c);
    }
    for (int i = 0; i < n; i++) {
        if (a[i] > x) {
            ans += a[i] - x;
            a[i] = x;
        }
        if (a[i] + a[i+1] > x) {
            ans += a[i+1] - x + a[i];
            a[i+1] = x - a[i];
        }
    }
    cout << ans;
    return 0;
}

```
这种情况下会有两个case过不掉，为什么呢？？？

后来又看了一下题目给出的数字范围
100%的测试数据，2<=N<=10^5，0<=a[i], x<=10^9
也就是说存在极端情况，会使ans超出int的范围，考虑一下，换成long应该就可以了吧。
第二次代码 终于AC了
```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> a;
int main() {
    int n, x;
    long ans = 0;
    cin >> n >> x;
    for (int i = 0; i < n; i++) {
        int c;
        cin >> c;
        a.push_back(c);
    }
    for (int i = 0; i < n; i++) {
        if (a[i] > x) {
            ans += a[i] - x;
            a[i] = x;
        }
        if (a[i] + a[i+1] > x) {
            ans += a[i+1] - x + a[i];
            a[i+1] = x - a[i];
        }
    }
    cout << ans;
    return 0;
}

```
求管理员给过！！！

---


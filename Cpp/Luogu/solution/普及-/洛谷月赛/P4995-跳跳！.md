# 跳跳！

## 题目描述

你是一只小跳蛙，你特别擅长在各种地方跳来跳去。

这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0 = 0$。你估计着，从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i - h_j) ^ 2$，从地面跳到第 $i$ 块石头耗费的体力值是 $(h_i) ^ 2$。

为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费**尽可能多**的体力值。

当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。

不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。

那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！

## 说明/提示

#### 样例解释

两个样例按照输入给定的顺序依次跳上去就可以得到最优方案之一。

#### 数据范围
对于 $1 \leq i \leq n$，有 $0 < h_i \leq 10 ^ 4$，且保证 $h_i$ 互不相同。

对于 $10\%$ 的数据，$n \leq 3$；

对于 $20\%$ 的数据，$n \leq 10$；

对于 $50\%$ 的数据，$n \leq 20$；

对于 $80\%$ 的数据，$n \leq 50$；

对于 $100\%$ 的数据，$n \leq 300$。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
3
6 3 5
```

### 输出

```
49```

# 题解

## 作者：UnyieldingTrilobite (赞：84)

[题目 lnk](https://www.luogu.com.cn/problem/P4995)。

这么好的题怎么没人写题解啊（迫

首先不难想到一个贪心：从最左（初始点）跳到最右，再跳到第二左，再跳到第二右……以此类推。但是这仅仅是一个感性理解上路程最远的走法，它需要一个证明。

以下不妨有 $0=h_0\lt h_1\lt h_2\lt h_3\lt\cdots\lt h_n$。注意到，我们其实仅仅需要证明最优情况下第一步从 $0$ 跳到 $h_n$ 即可（此后左右翻转可以证明第二步跳到 $h_1$，以此类推，整个贪心流程的正确性证明也就完成了）。

假设存在一种最优情况使得第一步不是从 $0$ 跳到 $h_n$ 而是跳到 $h_p$（$1\le p\le n-1$），那么我们分两类讨论：

1. $h_n$ 是终点

那么我们第一步改跳 $h_n$ 然后全程反转，则体力值耗费增加 $h_n^2-h_p^2>0$，矛盾。

2. $h_n$ 不是终点。

不妨 $h_n$ 跳向了 $h_q$。

那么我们第一步改跳 $h_n$，然后从 $h_p$ 到 $h_n$ 的跳跃全程反转，然后 $h_p$ 跳 $h_q$，则体力耗费增加 $h_n^2+(h_p-h_q)^2-h_p^2-(h_n-h_q)^2=2h_q(h_n-h_p)>0$，矛盾。

综上，第一步一定是从 $0$ 跳到 $h_n$，证毕。

代码非常好写，就不挂了。

---

## 作者：JASON杨 (赞：52)

这是本蒟蒻写的的第一篇题解，求 dalao 喷轻点。qwq

## 想法

其实看到这道就不难想到**排序**后**贪心**。题目中希望求出最大的体力消耗，我们的第一反应就该是让小青蛙每次跳到和自己**高度差最大的柱子**，即：

先跳到最高的柱子，再跳到最低的柱子，再跳到次高的柱子，再跳到次低的柱子，……

像这样**左右横跳**就行了。其实按这样的想法我们就已经可以把这道题切了，但~~这样我就交不了题解了~~这只是我们的一个想法，我们需要进行一个准确的**证明**。

## 证明

首先先分析简单的情况，对于每个柱子，我们都应可以让其和另外一个柱子创造一个**耐力消耗值**（即题目中的 $(h_i-h_j)^2$，下文简写为**收益**），而对于除了地面和终点的柱子，我们都可以令其创造两次收益（即跳到其上面一次，跳走一次）。举个例子，让我们假设有3个柱子，它们的高度分别是 $h_1$,$h_2$,$h_3$，其中 $0<h_1<h_2<h_3$ 我们一开始在地面上（$h$ 为 $0$）。 假设我们一开始并未跳向最高的 $3$ 号柱子，而是选择了 $2$ 号柱子，那我们最终的收益就是会是：
1. $(h_2^2+(h_2-h_1)^2+(h_1-h_3)^2)$（跳到 $2$ 号柱子之后跳到了 $1$ 号柱子）。

或

2. $(h_2^2+(h_2-h_3)^2+(h_3-h_1)^2)$（跳到 $2$ 号柱子之后跳到了 $3$ 号柱子）。

但若我们先跳到 $3$ 号柱子，再跳到 $1$ 号柱子，最后跳到 $2$ 号柱子，则可产生的收益为：

3. $(h_3^2+(h_3-h_1)^2+(h_1-h_2)^2)$

比较上述三个式子，第一个式子显然小于第三个式子（除了$h_2^2$和$h_3^2$ 都相等但 $h_2^2<h_3^2$）,对于第二和第三个式子，我们让式三减去式二可得：

$(h_3^2-(h_1-h_3)^2-h_2^2+(h_1-h_2)^2)$

化简可得：

$2h_1(h_3-h_2)$

因为$h_2<h_3$,$h_1>0$

所以式三大于式二。

同理可得若先跳到 $1$ 号柱子上也没有按照先跳到 $3$ 号柱子，再跳到 $1$ 号柱子，最后跳到 $2$ 号柱子产生的收益多。

而对于数量任意的柱子，我们也易将该结论进行推广为：应从先从地面跳到最高柱子，再跳到最低柱子，再跳到次高柱子……只需将其进行分组即可

最后贴一下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long ans=0;
int h[330];
bool sum=0;
signed main()
{
	int n;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>h[i];
	}
	sort(h+1,h+n+1);
	int j=0,hpast=0;
	for (int i=1;i<=n;i++)
	{
		j=n-j+sum;
		sum=!sum;
		ans+=(h[j]-hpast)*(h[j]-hpast);
		hpast=h[j];
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：Gumbo (赞：40)

本题是洛谷月赛的一道题目，没有什么考察的算法，主要考察思维。

我们首先感性地贪心一下：每次尽可能跳没跳过的最远的石头。

经过简单的模拟，我们过了这道题目。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n;
long long h[301];
void sp(long long&a,long long&b){
	int c=a;a=b;b=c;return;
}
long long jl(int a,int b){
	return((a-b)*(a-b));
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)scanf("%lld",h+i);
	sort(h+1,h+n+1);
	long long l=0,r=n;
	long long J=0;
	while(l<r){
		J+=jl(h[r],h[l]);
		++l;
		J+=jl(h[l],h[r]);
		--r;
	}
	printf("%lld",J);
	return 0;
}
```

现在，我们来看看我们为什么过了这道题目。

假设我们有这样一个序列：`1 2 3 4 5`。

我们感性贪心的最优路径：$0\rightarrow5\rightarrow1\rightarrow4\rightarrow2\rightarrow3$。

我们来证明一下它是最优路径。

我们来看这一部分：$0\rightarrow5\rightarrow1\rightarrow4$。

我们先单看 $0\rightarrow5$ 和 $1\rightarrow4$ 这两步。

如果我们将 `5` 与 `4` 交换的话：

我们原本的体力耗费是 $(5-0)^2+(4-1)^2$。

新的体力消耗是 $(5-1)^2+(4-0)^2$。

体力消耗减小。

我们将其扩展到一般情况：

$a\rightarrow d$、$b\rightarrow c$ ($0\le a\le b\le c\le d$)

则我们原本的体力消耗为 $(d-a)^2+(c-b)^2$。

新的体力消耗是 $(d-b)^2+(c-a)^2$。

可得 $(d-b)^2+(c-a)^2\le(d-a)^2+(c-b)^2$，当且仅当 $a=b,c=d$ 时，等号成立。

因此，我们的贪心策略是最优的，至少是最优策略之一，因为没有一个策略的体力消耗严格大于我们的策略。

---

后记：`OI` 就是这样，不光要能 `AC`，还要知道自己为什么能 `AC`。

---

## 作者：hamster000 (赞：32)

本题是一个贪心

这是第一篇带 ACcode 的题解！

我调了半天呢

题面传送门：[P4995](https://www.luogu.com.cn/problem/P4995)


## 解决方案：

不难看出，本题是一个贪心的题目，我们理解一下，设 $h_0<h_1<h_2<……<h_n$，那么第一次肯定跳向 $h_n$ 而非其他地方，然后 $h_n$ 跳向 $h_0$，又跳向 $h_{n-1}$，相当于回到原来，所以只要证明第一次跳向最高的然后再跳向最矮的就命题得证。

假设第一次不是跳向 $h_n$，而是跳向了 $h_x$，此时若终点在 $h_n$ 显然跳向 $h_n$ 然后反过来跳会消耗更多体力，若终点不在 $h_n$，那么设 $h_n$ 跳了 $h_y$，那么第一步跳 $h_n$，然后从 $h_x$ 到 $h_n$ 的跳跃路径改成从 $h_n$ 原路跳到  $h_x$ 消耗显然也更大。 

所以，必然是第一步跳向最高的。

其他思路都在代码里，数据范围在 $n \le 300$。

## AC code：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,h[500],ans,point=1;
//开数组，不解释
int main(){
   cin >> n;
   for(int i=1;i<=n;i++)cin >> h[i];
   sort(h,h+n+1);//排升序
   int l=0,r=n;//初始化两个游标
   while(r>l){ //如果游标相等或者左边的游标更小那就退出
       ans+=pow(h[r]-h[l],2);//计算跳一次后增加消耗的体力值
       l++;
       ans+=pow(h[l]-h[r],2);
       r--;//循环一次之后发现，回到了原来的样子，不过问题规模缩小了，要考虑的n少了两个
   }
   cout << ans;
   return 0;
}
```

不要抄袭！！！

---

## 作者：Wind_Smiled (赞：9)

## 题意
有一堆高矮不同的石头，其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0 = 0$。从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i - h_j) ^ 2$，从地面跳到第 $i$ 块石头耗费的体力值是 $(h_i) ^ 2$。求可能消耗的最多的体力值。

#### 数据范围
对于 $1 \leq i \leq n$，有 $0 < h_i \leq 10 ^ 4$，且保证 $h_i$ 互不相同，$n \leq 300$。

设有 $h_1,h_2,h_3,h_4$ 四个变量，且满足 $h_1 \le h_2 \le h_3 \le h_4$，原始位置位于 $h_1$。

为使消耗体力值最大，可以用枚举法推出结论。

因为 $h_1 \le h_2 \le h_3 \le h_4$，由不等式的性质得：

$(h_2-h_1) \le (h_3-h_1) \le (h_4-h_1)$

所以代入消耗公式 $m$，得：

$(h_2-h_1)^2 \le (h_3-h_1)^2 \le (h_4-h_1)^2$

所以，从 $h_1$ 跳到 $h_2,h_3$ 上消耗的体力一定小于从 $h_1$ 跳到 $h_4$ 所消耗的体力。

此时抹去 $h_1$,此时剩余数列满足 $h_2 \le h_3 \le h_4$

且此时位于 $h_4$。

因为 $h_2 \le h_3 \le h_4$，由不等式性质得 $(h_3-h_2) \le (h_4-h_2)$

所以代入消耗公式 $m$，得：

$(h_3-h_2)^2 \le (h_4-h_2)^2$

以此类推，得出结论：对于任何有序数列 $h$，由最低点端跳至最高点，再由最高点跳至最低点的体力消耗最大。

因此，可以对数组 $h$ 进行排序，从 $0$，即 $h_0$ 开始累积消耗体力，使用体力消耗公式计算并累积，使用两个指针指向左右两个元素，每一回合（由最高至最低再由最低至最高）进行循环判断，如果指针重合，则终止循环。

注意，消耗的体力值可能会很大，所以要开 `long long` 进行存储

------------
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m(int h1,int h2){
	return (h1-h2)*(h1-h2);
}
long long n,h[305],xh,z,y;
int main(){
	cin>>n;
	z=0;
	y=n;
	for(int i=1;i<=n;i++) cin>>h[i];
	sort(h+1,h+n+1);
	for(int i=1;i<=n;i++){
		if(z==y) break;//对于每一次操作，如果指针重合则结束循环 
		xh+=m(h[z],h[y]);
		z++;
		if(z==y) break;//对于每一次操作，如果指针重合则结束循环 
		xh+=m(h[z],h[y]);
		y--;
	}
	cout<<xh;
	return 0;
}
```

---

## 作者：yydfj (赞：7)

**这是本蒟蒻第二十九次写的题解，如有错误点请好心指出！**

## 问题简述

有 $n$ 个高度为 $h_i$ 的石头，小跳蛙目前所处的高度为 $h_0=0$，它从高度为 $h_i$ 的位置跳到高度为 $h_j$ 的位置要消耗 $(h_i-h_j)^2$ 的体力。小跳蛙现在要跳完所有石头，每个石头只能被跳一次，问它最多要消耗多少体力。

## 解法综述

根据题意，很容易就想到贪心，小跳蛙要想消耗的体力最多，就一定要选当前还没跳完的石头中离小跳蛙的高度差最大的那一个。

根据上述贪心策略，将读入的 $n$ 块石头按高度 $h$ 从小到大排序，发现从整体上看小跳蛙一直在左右横跳，不妨设 $l$ 为小跳蛙应往左边跳的位置，设 $r$ 为小跳蛙应往右边跳的位置，用 $l≤r$ 判断小跳蛙是否跳完所有石头，然后用 $l$ 和 $r$ 来模拟它跳的顺序并求出答案即可。

## 代码描述
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n,h[305],ans;//不开long long见祖宗
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&h[i]);
	stable_sort(h+1,h+n+1);//将读入的n块石头按高度h从小到大排序
	for(int l=0,r=n;l<=r;)//l为小跳蛙应往左边跳的位置，r为小跳蛙应往右边跳的位置，用l≤r判断小跳蛙是否跳完所有石头
	{
		//以下是用l和r来模拟小跳蛙跳的顺序 
		ans+=(h[l]-h[r])*(h[l++]-h[r]);//累加小跳蛙从l跳到r消耗的体力，并让l位置右移
		if(l<=r) ans+=(h[l]-h[r])*(h[l]-h[r--]);//先用l≤r判断小跳蛙是否跳完所有石头，再累加小跳蛙从r跳到l消耗的体力，并让r位置左移
	}
	printf("%lld",ans);//输出答案
	return 0;
}
```

---

## 作者：114514xxx (赞：6)

# 形式化题意： 
- 给定 $n$ 个正整数，$h_1$...$h_n$，第 $i$ 个数字为 $h_i$，并且 $h_0 =0$。
- 从第 $i$ 个数字转移至第 $j$ 个数字，需消耗体力值 $(h_i-h_j)^2$，并且转移过的数字不可再次转移。求可以耗费的体力值的最大值。
-  $1≤i≤n$，$n≤300$，$h_i≤10^4$，且保证 $h_i$ 互不相同。

# 思路：

定睛一看，是很明显的 **贪心** 加 **排序**，稍微思考一下便知道小跳蛙只要在排序完的石头堆上左右横跳就行了。 
 
 ~~某位不知名的大师说过：“贪心并不难写，但如何证明贪心的有效性才是最难的。”~~

# 证明：
- 要消耗体力值最多，并且依据题目给出的公式，要让体力值也就是 $(h_i-h_j)^2$ 的值最大。
- 要让两个数的差平方最大，也就是要让差的绝对值最大。
- 如果要让在一串数列中取出两个数，并且让这两个数差的绝对值最大，就要取出当前数列最大和最小的两个数字进行相减。
- 根据这个结论，要让 $(h_i-h_j)^2$ 的值最大，只要让 $h_i$ 和 $h_j$ 的差的绝对值最大即可。
- 因此，可以用思路中的贪心解。

# AC 代码
```cpp
#include<bits/stdc++.h>  
using namespace std;
long long total;//不开long long见祖宗 
int high[114514],n,l,r; 
signed main(){//玄学优化，虽然没有必要 
    high[0]=0;//地面的高度为零
	cin>>n;
	for(register int i=1;i<=n;i++){
		cin>>high[i];
	}
	sort(high,high+1+n);
    r=n;
    l=0;
    int save=0;
	for(save=0;l<r;save++){
		total+=(high[l]-high[r])*(high[l]-high[r]);l++;
		total+=(high[r]-high[l])*(high[r]-high[l]);r--;
	    }
	cout<<total;
}
```


---


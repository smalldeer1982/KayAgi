# 头像上传

## 题目描述

有一天无聊的你在注册一个无聊的网站，注册完的第一步自然是上传头像。

你发现这个网站总共可以上传 $n$ 个头像，每个头像必须是正方形，并且长宽至少为 $L \times L$

在图片上传前，系统会对图片进行如下处理：如果图片的任何一边长度超过了 $G$ ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度 $\leq G$ 为止。

你现在找到了 $n$ 张可供上传的图片，第 $i$ 张的尺寸是 $W_i \times H_i$。

如果图片有任何一边小于 $L$，请输出 "Too Young"
 
如果图片满足大小条件但不为正方形，请输出"Too Simple"

如果图片满足大小条件并且是正方形，请输出"Sometimes Naive" 

以上所有字符串输出时均不包含引号。

## 说明/提示

对于 $30\%$ 的数据，满足 $n=1$

对于 $100\%$的数据，满足 $n \leq 2000$，$W_i,H_i ,G\leq 10000$

## 样例 #1

### 输入

```
3 5 10
12 3
7 8
5 5
```

### 输出

```
Too Young
Too Simple
Sometimes Naive```

# 题解

## 作者：犇犇犇犇 (赞：31)

## 这道题数据范围也比较小，所以**直接模拟**就好了

如果图片的任何一边长度超过了 $G$ ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度$ \leq G$ 为止。

```
while(w>g || h>g) //若两边有一边大于g
{
	w/=2; 
	h/=2; //两边同时减半
}
```

如果图片有任何一边小于 LL，请输出 "Too Young"

```
if(w<l || h<l)
{
	cout<<"Too Young"<<endl;
}
```
如果图片满足大小条件但不为正方形，请输出"Too Simple"
```
else if(w!=h)
{
	cout<<"Too Simple"<<endl;
}
```
如果图片满足大小条件并且是正方形，请输出"Sometimes Naive"
```
else cout<<"Sometimes Naive"<<endl;
```
所以只要对每一个$w_i,h_i$都做一遍就好了

```
#include <bits/stdc++.h>
using namespace std;
int n,l,g,w,h;
int main()
{
	int i,j;
	cin>>n>>l>>g;
	for(i=1;i<=n;i++)
	{
		cin>>w>>h;
		while(w>g || h>g)
		{
			w/=2;
			h/=2;
		}
		if(w<l || h<l)
		{
			cout<<"Too Young"<<endl;
		}
		else if(w!=h)
		{
			cout<<"Too Simple"<<endl;
		}
		else cout<<"Sometimes Naive"<<endl;
	}
	return 0;
}
```



---

## 作者：Doveqise (赞：19)

这道题，一道模拟题...机房巨佬调半天...(while写错了  
(幸亏我一遍就A了  
接下来解释代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,g;
void solve(int w,int h){
	if(l>min(w,h)){puts("Too Young");return;}//尺寸过小
	if(g>=max(w,h))/*符合条件*/{puts(w==h/*判断是否相等*/?"Sometimes Naive":"Too Simple");return;}
	solve(w>>1,h>>1);//裁剪照片
}
signed main(){
	scanf("%d%d%d",&n,&l,&g);
	while(n--){int w,h;scanf("%d%d",&w,&h);solve(w,h);}
	return 0;
}
```


---

## 作者：littlefire (赞：12)

这道题就是一道简单的模拟题，大家按照题目的意思进行模拟就好，大家要住的点就是：
设n为一个偶数，那么n+1和n在c++中除以二是相等的，所以大家要注意一下，会被卡点。
其他的就没有什么太难的地方。
第一次写题解，可能说的不太明白，不懂得私我。
谢谢大家

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
	int n,l,g;
	int w,h;
	cin>>n>>l>>g;
	for(int i=1;i<=n;i++){
		cin>>w>>h;
		while(w>g||h>g){
			w=w>>1;
			h=h>>1;
		}
		if(w==h){
			if(w<l){
				cout<<"Too Young"<<endl;
			}
			if(w>=l){
				cout<<"Sometimes Naive"<<endl;
			}
		}
		if(w!=h){
			if(w<l||h<l){
				cout<<"Too Young"<<endl;
			}
			if(w>=l&&h>=l){
				cout<<"Too Simple"<<endl;
			}
		}
	}
	return 0;
}
```


---

## 作者：YLWang (赞：6)

洛谷4月月赛唯一简单题。

赶紧来赛后补一篇题解。

这篇文章主要告诉大家一些细节。

根据题意，**上传前**就要进行图片处理，判断什么的是之后的事。

所以有些同学先判断就会出点问题。

然后还要注意一点：处理时，图片的长，宽是**同时**修改的，并且**有一条边**大于G的时候就会修改。很多同学也没有注意这一点。（60的应该都是这个锅吧）

这两个细节要注意。

最后输出的时候大小写不要搞错了（虽然很naive，但是我有个同学惨死在了这里，比赛快结束时他猛然反应过来，大吼一声，吓到了全机房）

具体算法与思路详见代码:

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(register int i = (k); i <= (j); i++)
#define INF 2147483647/3
#define ll long long
using namespace std;
inline int read()
{
    int num = 0;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar());
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num;
}

signed main()
{
    int n = read(), l = read(), g = read();
    For(i, 1, n) {
        int a = read(), b = read();
        while(a > g || b > g) a >>= 1, b >>= 1; //有一条边不符合就同时进行操作，右移只是为了卡卡常数
        if(a < l || b < l) {//判断大小是否符合
            printf("Too Young\n");
        } else {
            if(a == b) {//判断是否为正方形
                printf("Sometimes Naive\n");
            } else {
                printf("Too Simple\n");
            }
        }
    }
    return 0;
}
```


---

## 作者：　　　吾皇 (赞：3)

## 这题挺水，根据题意模拟
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n,L,G,w[2001],h[2001];
int main(){
	cin>>n>>L>>G;
	for(int i=1;i<=n;i++){
	cin>>w[i]>>h[i];
	while(w[i]>G||h[i]>G){//只要有一边大于G就都除以2，注意这里是或不是且...第一次交因为这个只有60
		w[i]/=2;
		h[i]/=2;
	}
    //模拟
	if(w[i]<L||h[i]<L) cout<<"Too Young"<<endl;//如果有一边比L小
		else if(w[i]!=h[i]) cout<<"Too Simple"<<endl;//如果两边不相等
		else cout<<"Sometimes Naive"<<endl;//剩下的
	}
	return 0;//结束
} 
```
#### 发现too young too simple sometimes naive的意思居然是 太年轻太简单，时而天真...


---

## 作者：pomelo_nene (赞：3)

这是一道简单的模拟题 一改以往月赛复杂的模拟

解法如题所意 只不过有几个坑点

第一 是至少L×L 不是至多

第二 超过指的是大于 不是大于等于

第三 向下取整 不是四舍五入

代码如下

```cpp
#include<cstdio>
int main(){
	int n,l,g;
	scanf("%d %d %d",&n,&l,&g);
	while(n--)
	{
		long long w,h;
		scanf("%lld %lld",&w,&h);
		while(w>g || h>g)
		{
			w>>=1,h>>=1;	//题意 向下取整 就直接右移一位
		}
		if(w<l || h<l)	printf("Too Young\n");
		else if(w!=h)	printf("Too Simple\n");
		else	printf("Sometimes Naive\n");
	}
	return 0;
}
```

//注：Too Young,Too Simple,Sometimes Naive 指的是太年轻，太单纯，有时太天真 常用于老者教育后辈

~~出题人用心良苦啊~~ @修大坝惨案

---

## 作者：TEoS (赞：3)

当我看到四月月赛T1的时候，一下子就想到了~~神奇橡树车~~。这个判断格式和三月第二场月赛的T1的确挺像，不过相比来说简单很多。~~大概...是一道红题吧~~


------------
思路：非常简单，每次输入然后处理判断即可。我们先按照这个无聊的网站的规则，输入一个图片的长和宽之后，若长或宽其中一个大于G，则双双减半，直到小于等于G。处理过后进行判断：

- 如果图片有任何一边小于L，输出 "Too Young"；
- 如果图片满足大小条件但不为正方形，输出"Too Simple"；
- 如果图片满足大小条件并且是正方形，输出"Sometimes Naive"；

~~我怎么感觉我把题目复述了一遍...~~

还有：正方形，即长宽相等的矩形。XD

代码：
```cpp
#include<iostream>
using namespace std;
int n,l,g;
int check(int w,int h)
{
    while(w>g || h>g)
        w/=2,h/=2;//根据规则进行处理
    if(w<l || h<l)
        return 1;//如果图片有任何一边小于L，输出 "Too Young"
    if(w!=h)
        return 2;//如果图片满足大小条件但不为正方形，输出"Too Simple"
    else
        return 3;//如果图片满足大小条件并且是正方形，输出"Sometimes Naive"
    
}//判断函数
int main()
{
    cin>>n>>l>>g;
    while(n--)
    {
        int w,h;
        cin>>w>>h;
        int x=check(w,h);
        if(x==1)
            cout<<"Too Young"<<endl;
        if(x==2)
            cout<<"Too Simple"<<endl;
        if(x==3)
            cout<<"Sometimes Naive"<<endl;
    }//输入，输出
    return 0;
}
```
作为一个每次都只会写T1的蒟蒻，这次肯定又排得老远了qaq

---

## 作者：无意识躺枪人 (赞：1)

一道很简单的模拟题...

输入数据之后先处理大小（即一直减半）

然后判断是否超过规定大小，超过就输出

符合规定的话，再判断一下是否是正方形就好了

over

```
#include<bits/stdc++.h>
#define N 10005
using namespace std;

int n,w[N],h[N],G,L;

template<class T>inline void read(T &res)
{
    static char ch;T flag=1;
    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;
    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;
}

int main()
{
    read(n);read(L);read(G);
    for(register int i=1;i<=n;++i)
    {
        read(w[i]);read(h[i]);
        while(w[i]>G||h[i]>G)
        {
            w[i]/=2;h[i]/=2;
        }
        if(w[i]<L||h[i]<L) {printf("Too Young\n");continue;}
        else if(w[i]!=h[i]) printf("Too Simple\n");
        else printf("Sometimes Naive\n");
    }
    return 0;
}
```

考试的时候题面似乎出了点锅，后面改回来了

---

## 作者：Melodit (赞：1)

### 4月月赛的水题
- 讲道理按照题目的意思来就可以了
- 首先把边长缩到g以下
- 用floor函数向下取整就完事了
- 然后再判断符合不符合条件
- 按照题目意思输出即可
#### 下面是代码
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n;
int main()
{
    int n,l,g;
    scanf("%d%d%d",&n,&l,&g);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(x>g||y>g)
        {
            while(x>g||y>g)
            {
                x=floor(x/2);
                y=floor(y/2);
            }
        }
        if(x<l||y<l){printf("Too Young\n");continue;}
            if(x>=l&&y>=l)
            {
                if(x==y)printf("Sometimes Naive\n");
                else printf("Too Simple\n");
            }
    }
    return 0;
}

---

## 作者：1saunoya (赞：1)

>月赛的$T1$ 比较水 比较舒服


>这就是个简单 $moni$

>看起来很难理解 

>其实就是$3$种情况么

>>如果图片有任何一边小于 $L$，请输出 $"Too\ Young"$

>>如果图片满足大小条件但不为正方形，请输出$"Too\ Simple"$

>>如果图片满足大小条件并且是正方形，请输出$"Sometimes\ Naive"$

> ~~韩信~~(大雾

>所以么 我们用三个全局变量 即 ： $N$ , $L$ , $G$

>按照题意模拟即可

>>如果图片的任何一边长度超过了 $G$ ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度 $\leq G
$为止。

>
```cpp
 while(x > g or y > g) x >>= 1 , y >>= 1 ;
 ```
 
 >然后分情况 输出。（真好）
 
 ```cpp
 		if(x < l or y < l) {
            puts("Too Young") ;
            continue ;
        }
        if(x != y) {
            puts("Too Simple") ;
            continue ;
        }
        if(x == y) {
            puts("Sometimes Naive") ;
            continue ;
        }
 ```
 完整代码：[$Here$](https://www.cnblogs.com/qf-breeze/p/10742012.html)


---

## 作者：LB_tq (赞：1)

```
//一道很简单的模拟题，但要仔细审题
#include<iostream>
#include<cstdio>
using namespace std;
int n,l,g,w,h;//变量意义见题意
int main(){
	cin>>n>>l>>g;
	for(int i=1;i<=n;i++){
		cin>>w>>h;
		while(w>g||h>g){
			h>>=1;
			w>>=1;
		}//缩小向下取整，直到w和h都小于等于g为止
		if(w<l||h<l)
			cout<<"Too Young"<<endl;//如果此时w或h比l小，输出“Too Young”
		else if(w!=h)
			cout<<"Too Simple"<<endl;//如果大小符合条件但不是正方形输出“Too Simple”(为什么呢QwQ)
		else
			cout<<"Sometimes Naive"<<endl;//否则输出“Sometimes Naive”
	}
	return 0;
} 
```
//依题意模拟即可
求通过~


---

## 作者：AgOH (赞：1)

~~一道十分水的模拟~~，难度应该是入门难度。只有一个坑点，就是在长宽减半后如果长宽有任意一个小于L的话，还是要输出"Too Young"的。

Code:
```cpp
#include<iostream>
#include<string>
using namespace std;
const string s1("Too Young");
const string s2("Too Simple");
const string s3("Sometimes Naive");
//以上为要输出的三个字符串，可以看出作者是个资深STL受害者
int main(int argc, char const *argv[])
{
    int n,L,G,tmp1,tmp2;
    cin>>n>>L>>G;
    for(int i=0;i<n;i++)
    {
        cin>>tmp1>>tmp2;		//对每组数据单独处理即可
        if(tmp1<L||tmp2<L)		//如果有小于L的就输出"Too Young"
            cout<<s1<<endl;
        else					
        {
            while(tmp1>G||tmp2>G)	//对长宽进行减半处理
                tmp1/=2,tmp2/=2;
            if(tmp1<L||tmp2<L)		//如果这里小于L了还是要输出"Too Young"
                cout<<s1<<endl;
            else if(tmp1!=tmp2)		//如果不是正方形，即长宽不相等，输出"Too Simple"
                cout<<s2<<endl;
            else cout<<s3<<endl;	//正方形，输出"Sometimes Naive"
        }
    }
    return 0;
}
```

---

## 作者：Konnyaku_ljc (赞：1)

# 模拟
月赛T1越来越水了……这次差不多是个橙题吧  
~~又一堆题解~~  
直接上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,g,w,h;//五个数 
int main()
{
	cin>>n>>l>>g;//输入 
	for(int i=1;i<=n;i++)
	{
		cin>>w>>h;//输入 
		while(w>g){w/=2;h/=2;}//w比g大时，都除2
		while(h>g){w/=2;h/=2;}//h比g大时，都除2
		if(w>=l&&h>=l)//都大于l时 
		{
		    if(w!=h)
                    //不等就Too Simple ，等就Sometimes Naive
                    {
                        cout<<"Too Simple"<<endl;
                    }
		    else
                    {
                        cout<<"Sometimes Naive"<<endl;
                    }
		}
		else//有一个小于l，Too Young
		{
			cout<<"Too Young"<<endl;
		}
	}
	return 0;
}
```
AC

---

## 作者：wangkeli (赞：1)

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,l,g;

void Young(){puts("Too Young");}

void Simple(){puts("Too S1mple");}

void Naive(){puts("Sometimes Naive");}

int main()
{
    scanf("%d%d%d",&n,&l,&g); //输入题目的n,L,G
    while(n--)
    {
        int w,h;
        scanf("%d%d",&w,&h);
        while(w>g||h>g) w>>=1,h>>=1;//右移一位相当于除以二并向下取整
        if(w<l||h<l) {Young();continue;}
        if(w==h) {Naive();continue;}
        Simple();//输出
    }
    return 0;
}
```


---

## 作者：龙行龘龘 (赞：0)

# 个人感觉这题好是简单

首先,判断是否有任何一边小于L

然后就是判断是否为正方形

至于满足大小条件但不为正方形就用else混过去就好

但注意 : 如果图片的任何一边长度超过了G ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度≤G 为止

这个如果不注意就60pts啦(我亲身经历过...)

顺便献上我的blog:https://www.luogu.org/blog/Root-std-admin/

吃我一码:
```cpp
//Written By:Jason_Root
//Time Limit : 1000 MS
//Memory Limit : 65536 KB
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
typedef unsigned usd;
typedef long long ll;
typedef unsigned long long ull;
int n,l,g;
int w,h;
inline int read() {
	char ch = getchar();
	int x = 0, f = 1;
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = x*10 + ch-'0';
		ch = getchar();
	}
	return x * f;
}
void print(int x,int y) {
	while(w > g || h > g){
		w/= 2,h/= 2;
	}
	if(w < l || h < l) {
		printf("Too Young\n");
		return;
	} else if(w == h) {
		printf("Sometimes Naive\n");
		return;
	} else {
		printf("Too Simple\n");
		return;
	}
}
void func() {
	ios_base::sync_with_stdio(false);
    GCC;
	n = read(),l = read(),g = read();
	while(n--) {
		w = read(),h = read();
		print(w,h);
	}
}
int main(int argc, char const *argv[]) {
	func();
	return 0;
}


```
感觉我好坏的hhh...

---

## 作者：萌萌哒小女孩 (赞：0)

比赛的时候我的pascal跑了26ms(挺快的)，加了O2是22ms(好像没什么区别)

这题是水，纯模拟(~~没拿满分的是怎么回事~~)

```pascal
var n,l,g,x,y,i:longint;
begin
  readln(n,l,g);
  for i:=1 to n do
  begin
    readln(x,y);   //读入
    while (x>g) or (y>g) do      //判断是否有长或宽超过g的
    begin x:=x div 2;y:=y div 2;end;    //削短
    if (x<l) or (y<l) then writeln('Too Young')   //判断小于l的情况
      else if x<>y then writeln('Too Simple')    //不是正方形的情况
        else writeln('Sometimes Naive');      //否则可以
  end;
end.
```


---

## 作者：☆La™塩鱻© (赞：0)

## 今天刷月赛
### 只水了第一题
### 一个简单的模拟（都不用开数组）
### 便可AC


------------
#### 一看是多组输出
## while！！

### 由题
#### 在图片上传前，系统会对图片进行如下处理：如果图片的任何一边长度超过了 GG ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度≤G 为止。

### 所以还需将其预处理（要向下取整！！）
### 代码如下


```cpp
if (w > g || h > g）
{
	while (h > g || w > g)
	{	
		w = ceil(w / 2);//ceil（），向下取整
		h = ceil(h / 2);
	}
}
```
### 最后再几个if就搞定啦



------------

### 全码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,l,g;
int w,h;

int main()
{
	scanf("%d%d%d",&n,&l,&g);
	while (n--)
	{
		scanf("%d%d",&w,&h);
		if (w > g || h > g){while (h > g || w > g){w = ceil(w / 2);h = ceil(h / 2);}}
		if (w < l || h < l){printf("Too Young\n");continue;}
		if (w >= l && h >= l)
		{
			if (w != h){printf("Too Simple\n");continue;}
			if (w == h){printf("Sometimes Naive\n");continue;}
		} 
	} 
	return 0;
}
```

##### ~~超级压行（逃~）~~
### By Dunkle

---

## 作者：221B (赞：0)

见到还没有人发题解，本蒟蒻赶紧水一发（~~可怜的蒟蒻只做出了这道题~~）

其实这道题不算太难，只是有很多细节需要注意，详细内容请见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
string a="Too Young\n",b="Too Simple\n",c="Sometimes Naive\n";//将三个答案保存至string类型内，以便输出
int w[100001],h[100001];
inline int read() {//水一波函数。
	int X=0,w=0;//快读,比cin及scanf都要快
	char ch=0;
	while(!isdigit(ch)) {
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
	return w?-X:X;
}
inline void write(int x){//快写,比cout及printf都要快
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
int main() {
	int n=read(),l=read(),g=read();//读入
	for(int i=1;i<=n;i++){//每次循环读入
		w[i]=read();h[i]=read();
		while(w[i]>g||h[i]>g){//注意点1：如果图片的任何一边长度超过了 g ，要对图片的长宽同时减半（向下取整），直至两边长度≤g 为止。这个点坑了蒟蒻好几次。
			w[i]/=2;
			h[i]/=2;//除以2，直至两边长度都小于g。一定要记得注意！
		}
		if(w[i]<l||h[i]<l)//注意点2：判断有没有哪一边长度小于l
			cout<<a;
		else if(w[i]!=h[i])cout<<b;//注意点3:判断是不是正方形，即判断两边相不相等
		else cout<<c;//如果符合要求，输出Sometimes Naive
	}
	return 0;//养成好习惯
}
```


---

## 作者：fangd (赞：0)

这是一道很水的模拟题，但是题目非常有意思，~~让人蛤蛤大笑~~。

------------

### 一、分析题意 
首先，题目给我们三个变量，n、G、L，分别表示照片的数量，最大的宽度以及被嘲笑“Too Young”的标准。首先进行裁剪，紧接着进行判断，最后输出三种不同的结果。

------------

### 二、思路 
- **（一）读入**  
对于我们可以先读入n、G、L，然后读入一组，判断并输出一组。一共有n组输入，所以可以使用一个for循环进行判断。  
```cpp
int n, L, G;
scanf("%d %d %d", &n, &L, &G);
for (int i = 0; i < n; ++i)
{
    int w, h;
    scanf("%d %d", &w, &h);
    /*以下省略循环和判断的语句*/
}
```

- **（二）判断**  
对于每一组输入的照片，要进行判断，如果有任何一边（用w和h两个整型变量表示）大于G，就要进行裁剪。裁剪的方式是长和宽减半。代码如下：  
```cpp
while (w > G || h > G)
{
    w >>= 1;	//“>>=”这个运算符表示这个整数右移并赋值给自己，这个语句等价于“w /= 1”
    h >>= 1;	//同上
}
```

- **（三）输出**  
当我们得到处理好的w和h的值的时候，我们就可以进行判断。首先应判断的是是否有边长小于L，其次是判断边长是否相等（为正方形），输出题目要求的字符串。  
```cpp
if (w < L || h < L)
    puts("Too Young");
else if (w != h)
    puts("Too Simple");
else
    puts("Sometimes Naive");
```

- **（四）结束**  
主程序结束，返回0。

------------

### 三、代码
```cpp
#include <cstdio>

int main()
{
    int n, L, G;
    scanf("%d %d %d", &n, &L, &G);
    for (int i = 0; i < n; ++i)
    {
        int w, h;
        scanf("%d %d", &w, &h);
        while (w > G || h > G)
        {
            w >>= 1;
            h >>= 1;
        }
        if (w < L || h < L)
            puts("Too Young");
        else if (w != h)
            puts("Too Simple");
        else
            puts("Sometimes Naive");
    }
    return 0;
}

```

------------

### 四、其它
本文写于2019年4月20日。本人是只小蒟蒻，如有谬误的地方，还请大家不吝指教！

---

## 作者：kfhkx (赞：0)

P党福利~

这题超级明显的模拟

1. 把读入的长和宽分别与g比较，若有其中一个大于g就长宽各除以二
2. 把1.处理过的长宽再与l比较，若有一个小于l就直接输出Too Young就行了~
3. 然后再判断长宽是否相等（即是否为正方形），若是则输出Sometimes Naive；若不是，则输出Too Simple~

下面附代码

P5315.pas
------------
```pascal
var
        n,l,g,i,j,k,x,y:longint;
begin
        readln(n,l,g);
        for i:=1 to n do begin
                read(x,y);
                while (x>g) or (y>g) do begin
                        x:=x>>1;
                        y:=y>>1;
                end;
                if (x<l) or (y<l) then begin
                        writeln('Too Young');
                        continue;
                end;
                if x<>y then begin
                        writeln('Too Simple');
                        continue;
                end;
                if x=y then begin
                        writeln('Sometimes Naive');
                        continue;
                end;
        end;
end.
```


---

## 作者：muyang_233 (赞：0)

这篇文章，对其进行输入，然后进行逐一的判断就可以了。
问题在于：  
```cpp
#include <cstdio>
using namespace std;
int n,l,g;
int w,h;
int main(){
	scanf("%d%d%d",&n,&l,&g);
	while(n--){
		scanf("%d%d",&w,&h);
		if (w<l||h<l)//长度不符合要求
			printf("Too Young\n");
		else if (w>=l&&w<=g&&h>=l&&h<=g){//长度符合要求
			if (w!=h) printf("Too Simple\n");//不是正方形
			else printf("Sometimes Naive\n");//是正方形
		}
	}
	return 0;
}
```
上方的这个程序,只能得到$40$分。哪里错了呢？  
关键点在于，一部分人只根据底下输出详解的部分进行模拟，并认为有边$>g$时是长度不符合要求，而忘记了上方提到，如果有一边长度$>g$，就应该一直$/2$，最终让两条边全部$<g$。  
而在这种情况下，不会存在长度$>g$的情况，所以，代码修改如下：  
```cpp
#include <cstdio>
using namespace std;
int n,l,g;
int w,h;
int main(){
	scanf("%d%d%d",&n,&l,&g);
	while(n--){
		scanf("%d%d",&w,&h);
		while(w>g||h>g){
			w/=2;h/=2;
		}
		if (w<l||h<l)
			printf("Too Young\n");
		else if (w>=l&&h>=l){
			if (w!=h) printf("Too Simple\n");
			else printf("Sometimes Naive\n");
		}
	}
	return 0;
}
```
这样，就处理到了所有的情况，AC了本题。  
附上[评测详情](https://www.luogu.org/recordnew/show/18395296)

---

## 作者：Ryzen_2990WX (赞：0)

这道题用简单的循环、判断就可以完成
以下为代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n,l,g;
	cin>>n>>l>>g;
	int w[n],h[n];
	for(int i=0;i<n;i++)
	{
		cin>>w[i]>>h[i];
		while(w[i]>g||h[i]>g) w[i]/=2,h[i]/=2;
		if(w[i]<l||h[i]<l) cout<<"Too Young"<<endl;
		else if(w[i]<=g&&h[i]<=g) 
		{
			if(w[i]!=h[i]) cout<<"Too Simple"<<endl;
			else cout<<"Sometimes Naive"<<endl; 
		}
	 } 
	return 0;
}
```
唉，本蒟蒻在比赛的时候就做出了这一道，还用了两次机会掉，按照洛谷乐多赛的性质，本题得分=分数 * 0.95 ^ (次数 - 1)，100 * 0.95 ^ (3 - 1) = 90(分)，想哭。

这是本蒟蒻在比赛时花了6分钟 ~~360.xxxxxx秒~~ 写出来的程序

若有不足或需要改进的地方还请dalao指出，万分感谢。

---

## 作者：万万没想到 (赞：0)

这道题目按照题目要求一步步地模拟即可写出代码。  

整理了一下信息：  
n个矩形，每个矩形长宽分别是Wi，Hi。  
如果Wi和Hi任意一者大于G，就要将Wi，Hi减半（向下取整），这一步利用C++的自动整除就可完成。  

反复此步骤，直到Wi和Hi小于等于G，若Wi或Hi小于L，输出Too Young，若不小于L却Wi不等于Hi，输出Too Simple，否则若Wi等于Hi，输出Sometimes Naive

代码如下：  

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,g,w,h;
int main(){
    scanf("%d%d%d",&n,&l,&g);
    for(register int i=1;i<=n;++i){
        scanf("%d%d",&w,&h);
        while(w>g||h>g){
            w/=2;
            h/=2;
        }
        if(w<l||h<l)printf("Too Young\n");
        else if(w!=h)printf("Too Simple\n");
        else printf("Sometimes Naive\n");
    }
    return 0;
}
```
谢谢观看


---

## 作者：Juk_DR (赞：0)

~~这题让我知道了我的阅读理解多差（被题意吃了10分，后面才改的题目让我很是心痛~~

这题就直接按题目给的判定条件下去if 然后输出就可以了

具体的解释看代码注释
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,l,g;

int main(){
	scanf("%d%d%d",&n,&l,&g);
	while(n--){
		int w,h;
		scanf("%d%d",&w,&h);
		while(w>g || h>g){//让两边<=G
			w/=2;
			h/=2;
		}
		if(w<l || h<l){//判定是否有一边<l
			printf("Too Young\n");
			continue;
		}
		if(w!=h){//非正方形
			printf("Too Simple\n");
			continue;
		}
		printf("Sometimes Naive\n");//筛选完只剩正方形了
	}
	return 0;
}
```


---

## 作者：USACO_CHENWJ (赞：0)

依题意得：
1.如果图片的任何一边长度超过了 G ，那么系统会不断地对图片的长宽同时减半（向下取整），直至两边长度小于G   
```cpp
        if(w>g||h>g)
        {
            while(w>g||h>g)
            {
                w-=w/2;
                h-=h/2;
                if(h<=g&&w<=g)
                  break;
            }
        }
```

2.如果图片有任何一边小于 、L，请输出 "Too Young"  
```cpp
if(w<l||h<l)
        {
            cout<<"Too Young"<<endl;
            continue;
        }
```

3.如果图片满足大小条件但不为正方形，请输出"Too Simple
```cpp
if(w!=h)
            {
                cout<<"Too Simple"<<endl;
                continue;
            }
```

4.如果图片满足大小条件并且是正方形，请输出"Sometimes Naive"   
```cpp
else
            {
                cout<<"Sometimes Naive"<<endl;
                continue;
            }
```

总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,w,h,l,g;
int main(){
    scanf("%lld%lld%lld",&n,&l,&g);
    for(i=1;i<=n;i++)
    {
        scanf("%lld%lld",&w,&h);
        if(w>=l&&w<g&&h>=l&&l<g&&w==h)
        {
            cout<<"Sometimes Naive"<<endl;
            continue;
        }
        if(w>g||h>g)
        {
            while(w>g||h>g)
            {
                w-=w/2;
                h-=h/2;
                if(h<=g&&w<=g)
                  break;
            }
        }
        if(w<l||h<l)
        {
            cout<<"Too Young"<<endl;
            continue;
        }
        else
        {
            if(w!=h)
            {
                cout<<"Too Simple"<<endl;
                continue;
            }
            else
            {
                cout<<"Sometimes Naive"<<endl;
                continue;
            }
        }
    }
    return 0;
}
```
请各位daloa指出错误，并私信我，谢谢

---

## 作者：_lhz_ (赞：0)

 简单的模拟，按题目要求操作即可。
 （一定要按照题目的要求，
### 按顺序操作！！！！！）
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	//freopen("test.txt","r",stdin);
	
	int n,l,g,w,h;
	cin>>n>>l>>g;
	for(int i=1;i<=n;i++){
		cin>>w>>h;
		while(w>g||h>g)w/=2,h/=2;//一开始把这行语句放在第一个if语句下面。。。。。60分
		if(w<l||h<l){
			cout<<"Too Young"<<endl;
			continue;
		}
		if(w!=h){
			cout<<"Too Simple"<<endl;
			continue;
		}
		if(w==h){
			cout<<"Sometimes Naive"<<endl;
			continue;
		}
	}
}

```


---

## 作者：引领天下 (赞：0)

这个题就是标准的模拟

上来先把所有图的大小搞成<=G

然后判是不是>=L

然后输出就好

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,l,g,w,h;
int main(){
    scanf ("%lld%lld%lld",&n,&l,&g);//读入，long long防卡
    while (n--){
        scanf ("%lld%lld",&w,&h);
        while (w>g||h>g)w>>=1,h>>=1;//如果有一条边长了，两边一起减半
        if (w<l||h<l){puts("Too Young");continue;}//小了，输出
        if (w!=h){puts("Too Simple");continue;}//不是正方形，输出
        puts("Sometimes Naive");//否则没问题
    }
}
```

---

## 作者：jbc392 (赞：0)

本题就是按照题目模拟， 只是要注意一些细节问题。

看代码注释
```
#include<bits/stdc++.h>
using namespace std;
int n,l,g,i;
int main(){
	cin>>n>>l>>g;
	for(i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		while(x>g||y>g){//如果长度大于g，则除二并向下取整
			x=floor(x/2);//向下取整函数：floor
			y=floor(y/2);
		}
		if(x<l||y<l){//如果有一边小于l
			cout<<"Too Young"<<endl;
			continue;
		}else if(x!=y){//如果都一边小于l但是不是正方形
			cout<<"Too Simple"<<endl;
			continue;
		}else {//如果都一边小于l但是是正方形
			cout<<"Sometimes Naive"<<endl;
			continue;
		}
	}
	return 0;//华丽丽的结束
}
```1


---

## 作者：公主殿下MIKU (赞：0)

很水的一到模拟,按题目要求while()循环一直割就行,当不满足题意退出循环就行 
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int read() {
	int x=0;
	bool f=1;
	char ch=getchar();
#define ge ch=getchar()
	for(; !isdigit(ch); ge) if(ch=='-') f=0;
	for(; isdigit(ch); ge) x=(x<<3)+(x<<1)+ch-48;
	return f?x:-x;
}
int n,g,l;
int x,y;
int main() {
	n=read(),l=read(),g=read();
	for(int i=1;i<=n;i++)
	{
		x=read(),y=read();//输入尺寸 
		while(x>g||y>g)//切割 
		{
			x/=2;
			y/=2;
		}
		if(x<l||y<l) {
			printf("Too Young\n");//切小了 
			continue;
		}
		if(x!=y) printf("Too Simple\n");//不是正方形 
		else printf("Sometimes Naive\n");//满足题意的正方形 
	}
	return 0;
}
```

---

## 作者：Hexarhy (赞：0)

~~人生第一次为月赛写题解~~
## 思路

> 签到题，按照题目模拟即可。


------------


### 【注意事项】

$1)$ 裁剪时，两边同时进行，并且直到两边都$\le G$。

$2)$ 题目既然已经说了“向下取整”意味着尺寸都是整数，不用开`double`。

$3)$ 别忘了是先裁剪，再按照题目顺序依次判断。长和宽别弄反了。

$4)$ **别忘了区分字符串的大小写。**



------------
### 【新手技巧】

对于裁剪操作，是不断除以2，那么如果你是新手，就可以学一下位运算中的`>>`（右移）。（会的同学请自行忽略）

新手们动手试一下，不难把一个数右移1位就是相当于除以2的操作。右移$n$位就是除以$2^n$位。

当然这里可以用`>>=`

------------

一道水题我觉得我能讲这么多已经很不错了。奉上代码：
```cpp
#include <iostream>
using namespace std;

int n,l,g,w,h;

void half(void)
{
	while(w>g || h>g)//两边都要小于g
	{
		w>>=1;//上面说过
		h>>=1;
	}
}

void solve(void)
{
	half();
	if(w<l || h<l)//按题目意思依次判断
	{
		cout<<"Too Young"<<endl;
		return;
	}
	if(w!=h)
	{
		cout<<"Too Simple"<<endl;
		return;
	}
	cout<<"Sometimes Naive"<<endl;//最后一类不用判断直接输出，道理你懂
    //注意区分输出有没有细微差别！
}

int main()
{
	cin>>n>>l>>g;
	while(n--)
	{
		cin>>w>>h;
		solve();
	}
	return 0;
}

```


---


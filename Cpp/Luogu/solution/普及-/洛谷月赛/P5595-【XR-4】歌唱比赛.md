# 【XR-4】歌唱比赛

## 题目背景

**赛时提醒：本题不提供任何关于样例 4 以及无解的解释。**

**赛时提醒：本题不提供任何关于输出格式以及 Special Judge 的解释。**

**赛时提醒：抱歉，本题的 Special Judge 不忽略行末空格，请保证两行中没有多余字符。**

**赛时提醒：非常抱歉，本题输入数据是 Windows 格式，而非 Linux 格式，所以在末尾的 `\n` 之前有一个多余的 `\r` 字符。请使用 `scanf` 或 `cin` 读入数据，而非 `getline`，因为后者会多读入一个 `\r`。**

## 题目描述

小 X 参加了一场歌唱比赛。

经过一路鏖战，小 X 终于挺进了决赛，他的对手是小 Y。

这场歌唱比赛的冠军是由点赞数决定的，谁的点赞数高，谁就能夺冠。

小 X 和小 Y 依次演唱完自己的最后一首歌曲后，他们最终的点赞数确定了下来。

揭晓冠军的时刻终于到来了，主持人为了增加悬念，决定从小 X 与小 Y 的点赞数的最后一位开始，依次比较。

比如，小 X 的点赞数是 $37$，小 Y 的点赞数是 $28$。首先比较最后一位，小 X 是 $7$，小 Y 是 $8$，此时小 Y 暂时领先。再加上前一位，小 X 是 $37$，小 Y 是 $28$，此时小 X 暂时领先。比较结束，如果我们用 `X` 代表小 X 暂时领先，`Y` 代表小 Y 暂时领先，那么可以写下一个字符串 `XY`。

再比如，小 X 的点赞数是 $137$，小 Y 的点赞数是 $47$。如果我们再用 `Z` 表示小 X 与小 Y 的点赞数暂时一样，那么写下的字符串应该为 `XYZ`。

你作为一个精通 OI 的神仙，自然知道这种比较方式是非常不科学的，这样只是在无端拖延时间罢了，但是你却对最后写下的这个字符串很感兴趣。

现在，你得到了这个最后写下的字符串，你需要构造出一种可能的小 X 与小 Y 的点赞数。

当然，有可能不存在任何一种情况的点赞数满足这个字符串，那么你只需要输出 `-1` 即可。

为了方便你输出，请用前导零来补足位数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（11 points）：$\text{len}(s) = 1$。
- Subtask 2（42 points）：$s_i \in \{\texttt{X},\texttt{Y}\}$。
- Subtask 3（21 points）：数据保证有解。
- Subtask 4（26 points）：无特殊限制。

对于 $100\%$ 的数据，$s_i \in \{\texttt{X},\texttt{Y},\texttt{Z}\}$，$1 \le \text{len}(s) \le 10^6$。

## 样例 #1

### 输入

```
XY
```

### 输出

```
37
28
```

## 样例 #2

### 输入

```
XYZ
```

### 输出

```
137
047
```

## 样例 #3

### 输入

```
ZZZZZZ
```

### 输出

```
000000
000000
```

## 样例 #4

### 输入

```
XYZXYZ
```

### 输出

```
-1
```

# 题解

## 作者：Fatalis_Lights (赞：18)

## Solution

拿到这个题，不要被它吓到了。仔细分析一下，你就知道如何处理了。

第一种情况：只有X,Y。

那么如果是X,就输出1,Y则为0。

```cpp
sample input: XY
sample output: 10 01
```

如果有解且有Z,则有Z的位置为1。

```cpp
sample input: XYZ
sample output: 101 011
```

如果无解,那么就是说Z和XY冲突了。

首先，如果其中一位是Z，则Z后的所有位置都为Z。

```cpp
sample input: XYZZ
sample output: 1011 0111
```

如果不是Z,比如下面这个：

```cpp
sample input: XYZXZ
sample output: -1
```

直接输出"-1"。

那么这个题就解决了。

code:

```cpp
#include<bits/stdc++.h>
#define N 1000006
using namespace std;

string s;
int a[N],b[N];

bool pd(string s){
	bool flag=0;
	for(int i=0;i<s.size();i++){
		if(s[i]=='Z') flag=1;
		if(flag==1 && s[i]!='Z') return 1; 
	}
	return 0;
} //一位一位判断Z

int main(){
	cin>>s;
	if(pd(s)) return puts("-1"), 0; //无解输出-1
	for(int i=0;i<s.size();i++)
		if(s[i]=='X') a[i]=1,b[i]=0;
		else if(s[i]=='Y') a[i]=0,b[i]=1;
		else if(s[i]=='Z') a[i]=1,b[i]=1;
	for(int i=0;i<s.size();i++) cout<<a[i]; cout<<endl; //输出是有换行的
	for(int i=0;i<s.size();i++) cout<<b[i]; cout<<endl;
	return 0;
}
```

---

## 作者：loceaner (赞：8)

这是一道普及-的题目

有一道题和这么一道题很类似，可以先去做这道题，再来做这个，链接：


[$P3742\ umi$的函数](https://www.luogu.org/problem/P3742)

然后我们来考虑这道题的做法

既然是$special\ judge$，我们就可以直接乱搞了，只用$0$和$1$两个数，我们就可以$A$掉它啦~~

拿到题目的第一眼其实是有一点点懵逼的，然后读一读就会发现并不难，我们很容易就可以想到一个思路：从前往后扫，如果此时的字符为$X$,那就让$X$这个数的这一位比$Y$大，如果此时的字符为$Y$,那就让$Y$这个数的这一位比$X$大，如果此时的字符为$Z$，那么就让$X$和$Y$两个数的这一位相等

思路简直不要太完美

然后我兴高彩烈的交了一发，$74$分

为什么？？因为没有判断无解的情况，我忘记了还有样例$4$这种无解的情况，这是我最菜的地方……

那么我们来看一下，什么样的情况才算无解

其实这个也比较明显，就像下面这种情况$XXXZZYYZ$，如果前面出现了一个$Z$,而后面不是$Z$，但之后又出现了$Z$，就是无解，为什么呢？因为按照题意来说，$Z$表示的是：从$Z$这一位开始后面所有的数字都是相等的，即到目前为止$X$和$Y$两数相等。如果前面有了$Z$,而中间又有了$X$或$Y$，很明显是不对的，所以我们就可以先$O(n)$判断一下会不会出现无解的情况，代码如下

```cpp
for(int i = 1; i <= len; i++) {
		if(s[i] == 'Z') now = 1;//now表示有没有Z
		if(s[i] != 'Z' && now) return cout << "-1\n", 0;
        //如果从前往后扫，已经出现了Z，后面就不能再出现X或Y，如果出现，即是无解
	}
```

然后就做完了，完整的代码如下

```cpp
/*
By:Loceaner
*/
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

const int N = 1e6 + 11;

char s[N], a[N], b[N];
int now;

int main() {
	scanf("%s", s + 1);
	int len = strlen(s + 1);
	for(int i = 1; i <= len; i++) {
		if(s[i] == 'Z') now = 1;
		if(s[i] != 'Z' && now) return cout << "-1\n", 0;
	}
	for(int i = 1; i <= len; i++) {
		if(s[i] == 'X') a[i] = '1', b[i] = '0';
		else if(s[i] == 'Y') a[i] = '0', b[i] = '1';
		else if(s[i] == 'Z') a[i] = '1', b[i] = '1';
	}
	printf("%s\n%s", a + 1, b + 1);
	return 0;
}

```

---

## 作者：StudyingFather (赞：6)

显然 Z 只能出现在字符串最后几位（因为是自低位到高位比较，因此一旦平局局面打破就不可能再出现平局）。

利用这一性质可以先判断出无解的情况。

合法解的构造方法就简单得多了：对于 X 领先的位，令小 X 在这一位上的数字比小 Y 大即可，反之同理。

```cpp
#include <cstdio>
#include <cstring>
char s[1000005],s1[1000005],s2[1000005];
int main()
{
 scanf("%s",s);
 int len=strlen(s);
 bool flag=true;
 for(int i=len-1;i>=0;i--)
 {
  if(s[i]!='Z')flag=false;
  if(s[i]=='Z'&&!flag)
  {
   puts("-1");
   return 0;
  }
  if(s[i]=='Z')s1[i]=s2[i]='0';
  else if(s[i]=='X')s1[i]='9',s2[i]='0';
  else s1[i]='0',s2[i]='9';
 }
 puts(s1);
 puts(s2);
 return 0;
}
```


---

## 作者：Tarsal (赞：6)

本蒟蒻又双叒叕被爆踩了。

[~~考试时一遍过~~](https://www.luogu.org/problem/P5595)

其实这题还是很简单的，难度不会大于普及组T1.

CSP 2019 RP++

看开始看到题目，觉得特别长，不想看。。。

我来和你们分析分析题目，你们就都可以秒了。

首先，窝们有一个串，然后对于每个字符'X'表示小X赢了，'Y'表示小Y赢了，而'Z'表示平局。只要对于每个字符进行判断就行。

比如：
```
XYYYXXYZ
```
```
第一个是'X'，那么a[1]就要大于b[1]；
第二个是'Y'，那么a[2]就要小于b[2]；
第三个是'Y'，那么a[3]就要小于b[3]；
第四个是'Y'，那么a[4]就要小于b[4]；
第五个是'X'，那么a[5]就要大于b[5]；
第六个是'X'，那么a[6]就要大于b[6]；
第七个是'Y'，那么a[7]就要小于b[7]；
第一个是'X'，那么a[1]就要等于b[8]；
```
这些都还很好理解，主要的是什么情况是无解的？

因为它每次都会加入首个元素，

所以，窝们看：

然后在找到第一个'Z'前

```
a[]:{1234}
b[]:{4321}

```

当前是'Z'的话：

窝们要是x1234和x4321相等，~~你找到个看看~~

这就是无解的状态。

接下来就是代码时间:

有注释的：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define maxn 1000010
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)

bool flag;
char ch[maxn];
int b[maxn], a[maxn];//分别是读入的字符串,X的点赞数，Y的点赞数。 

int main(){
	scanf("%s", ch);//读入 
	int len = strlen(ch);//找到长度 
	Rep(i, 0, len - 1){
		if(ch[i] == 'X'){//如果小X当前领先，那这一位a[i]要大于b[i]，因为有spj，所以我用的1，2 
			if(flag){//如果已经出现'Z' 
				printf("-1");//无解 
				return 0;
			}
			a[i] = 2;
			b[i] = 1;
		}
		else if(ch[i] == 'Y'){//如果是小Y领先也是一样的。 
			if(flag){//如果已经出现'Z' 
				printf("-1");//无解 
				return 0;
			}
			a[i] = 1;
			b[i] = 2;
		}
		else{//如果当前是'z'，就把flag赋值为1； 
			flag = 1;
			a[i] = b[i] = 1;
		}
	}
	Rep(i, 0, len - 1) printf("%d", a[i]);//输出 
	printf("\n");
	Rep(i, 0, len - 1) printf("%d", b[i]);//输出 
	return 0;
}
```
没注释的：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define maxn 1000010
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)

bool flag;
char ch[maxn], b[maxn], a[maxn];

int main(){
	scanf("%s", ch); 
	int len = strlen(ch); 
	Rep(i, 0, len - 1){
		if(ch[i] == 'X'){ 
			if(flag){ 
				printf("-1"); 
				return 0;
			}
			a[i] = 2;
			b[i] = 1;
		}
		else if(ch[i] == 'Y'){ 
			if(flag){
				printf("-1");
				return 0;
			}
			a[i] = 1;
			b[i] = 2;
		}
		else flag = 	a[i] = b[i] = 1;
	}
	Rep(i, 0, len - 1) printf("%d", a[i]); 
	printf("\n");
	Rep(i, 0, len - 1) printf("%d", b[i]);
	return 0;
}
```
~~PS:请看懂再抄~~

---

## 作者：十十十十 (赞：4)

这道题...

首先，对于每一位，用X，Y两个数组来储存，若第i位是X，则X[i]>Y[i],若是Y，则Y[i]>X[i],否则X[i]=Y[i]。

判断无解

很显然，若后面几位有不同，前面为上有Z是一定不同的，因此用一个flag来判断。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool flag=1;//判断无解
char a[1000005],a1[1000005]={'0'},a2[1000005]={'0'};
int n=1;
int main()
{
    while(cin>>a[n])n++;//输入序列
    int m=n-1;
    n--;//一定减一
    while(n)//从后往前
    {
        if(a[n]=='X')//小X大
        {
            a1[n]='2';
            a2[n]='1';//其实这两个数随便，符合要求就好
            flag=0;//已经不等
        }
        if(a[n]=='Y')小Y大
        {
            a1[n]='1';
            a2[n]='2';//同上，随意
            flag=0;已经不等
        }
        if(a[n]=='Z')
        {
            if(!flag)//无解
            {
                cout<<"-1";
                return 0;
            }
            a1[n]='1';
            a2[n]='1';//同上
        }
        n--;//向前一位
    }
    for(int i=1;i<=m;i++) cout<<a1[i];
    cout<<endl;//不要像我一样第一遍没换行
    for(int i=1;i<=m;i++) cout<<a2[i];
}
```
祝各位早日 Ak IOI

---

## 作者：爱晚亭哦 (赞：3)



**无解情况：**

**1. Z不在第一个，且Z的后面有X或Y**

**2. Z是第一个，但前面隔着X或Y有第二个Z**

样例四无解解释：

X:100100

Y:010010


很明显100100≠10010，所以可知样例四无解~~（好无力等证明）~~

因为只要输出一种答案就可以了，所以我们只要0 1就行了

~~（样例都是些花里胡哨的东西）~~

相信只要学过字符串的接下来都没问题了

Code:
```
#include<cstdio>
#include<cstring>
using namespace std;
char a[1000001],b[1000001],c[1000001];//b数组是小X的点赞数，c数组是小Y的
int main()
{
	scanf("%s",a+1);
	int n=strlen(a+1),qwq=0;//qwq
	for(int i=n;i>=1;i--)//依照题意要倒序
	{
		if(a[i]=='X')
		{
			qwq=1;
			b[i]=49;//等价b[i]='1'
			c[i]=48;//等价c[i]='0'
		}
		if(a[i]=='Y')
		{
			qwq=1;
			c[i]=49;
			b[i]=48;
		}
		if(a[i]=='Z')
		{
			if(qwq)//无解情况
			{
				printf("-1");
				return 0;
			}
			else
				b[i]=c[i]=48;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%c",b[i]);
	printf("\n");
	for(int i=1;i<=n;i++)
		printf("%c",c[i]);
}//这辈子都不会return 0的qwq
```
~~感觉我的代码跑的挺快的呢~~

---

## 作者：K2sen (赞：3)

# P5595

说实话比赛的时候我还想先A的这个题.

#### 先看一下len（s）为1的情况吧

很明显啊只有一的时候那就是只有X和Y嘛，然后你可以直接判断一下是x还是y.

由于我很闲麻烦，然后就x的时候x大，y的时候y大，我们就给大的数输出2，给小的输出1就好了啊,

然后再看等于z的情况，就是输出两个一样的数就好了,那就输出0吧..

#### 一定有解的情况：
那就是x的时候小x的小y小，y的时候反之，然后大的输出2小的输出1，z的时候就输出0
.

```cpp
#include <bits/stdc++.h>
#define N 1000010
#define M 1010
#define _ 0

using namespace std;
char s[N];
int xx[N], xy[N];

int main() {
	cin >> s;
	int lens = strlen(s);
	for (int i = lens - 1; i >= 0; i--) {
		if (s[i] == 'X') {
			xx[i] = 2;
			xy[i] = 1;
		} else if (s[i] == 'Y') {
			xx[i] = 1;
			xy[i] = 2;
		} else xx[i] = xy[i] = 0;
	}
	for (int i = 0; i < lens; i++) cout << xx[i];
	puts("");
	for (int i = 0; i < lens; i++) cout << xy[i];
}
```
#### 再看无解的情况.
先看个例子.

如果是XYZ的话就是输出.
```
210
120
```
再看zy的情况:

是不是输出： 
```
01
02
```
因为他的要求是后两位都是相等的,然而这两位并不相等，

然后我们就可以看出来如果是z不在后边的话一定是无解的情况.
然后我们就可以写出这样的判断函数：
```cpp
bool ca() {
	int lens = strlen(s), cnt = 0;
	for (int i = lens - 1; i >= 0; i--)
		if (s[i] == 'Z') wei[++cnt] = i;
	for (int i = lens - 1; i >= lens - cnt; i--)
		if (s[i] != 'Z') return false;
	return true;
}
```

完整的代码就长这样，因为卡时间我按char存的：
```cpp
#include <bits/stdc++.h>
#define N 1000010
#define M 1010
#define _ 0

using namespace std;
char s[N], xx[N], xy[N];
short wei[N];

int read() {
	int s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

bool ca() {//判断是不是无解的情况
	int lens = strlen(s), cnt = 0;
	for (int i = lens - 1; i >= 0; i--)
		if (s[i] == 'Z') wei[++cnt] = i;
	for (int i = lens - 1; i >= lens - cnt; i--)
		if (s[i] != 'Z') return false;
	return true;
}

int main() {
	cin >> s;
	if (!ca()) {
		puts("-1");//是无解就输出-1
		return 0;
	}
	int lens = strlen(s);//不是无解就按照有解得情况做.
	for (int i = lens - 1; i >= 0; i--) {
		if (s[i] == 'X') {//是x就小x大小y小
			xx[i] = '2';
			xy[i] = '1';
		} else if (s[i] == 'Y') {//是y那就是小x小，小y大
			xx[i] = '1';
			xy[i] = '2';
		} else xx[i] = xy[i] = '0';//相等侧为零
	}
	for (int i = 0; i < lens; i++) putchar(xx[i]);
	puts("");
	for (int i = 0; i < lens; i++) putchar(xy[i]);
	return 0^_^0;
}
```

---

## 作者：Meatherm (赞：3)

首先来判断非法的情况。

明显如果输入中只含有 `X` 和 `Y`，那么必定是合法的。

但如果输入中含有 `Z`，并且某个 `Z` 出现的位置 $x$ 之后（即：$[x+1...n]$）含有 `X` 或 `Y` ，那么就是非法的。

为什么是非法的呢？我们知道，两个自然数相等当且仅当它们的每一位都相等。如果 $[x+1...n]$ 中含有 `X` 或 `Y`，那么就说明至少有一位是不相等的。

----

接下来就是简单的构造。

设小 X 的点赞数为数组 $a[]$，小 Y 的点赞数为数组 $b[]$。

倒序遍历字符串，

- 如果 $i$ 位为 `X`，就将 $a[i]$ 赋值为 $2$，$b[i]$ 赋值为 $1$。当然还有很多方法，只要满足 $a[i]>b[i]$ 即可。
- 如果第 $i$ 位为 `Y`，则与上面的情况恰好相反。
- 如果第 $i$ 位为 `Z`，则将 $a[i]$ 和 $b[i]$ 赋值为一个相等的数。

```cpp
# include <bits/stdc++.h>
# define rr register
const int N=1000010;
char s[N];
int a[N],b[N];
int n;
inline bool check(void){
	bool flag=true;
	for(rr int i=n;i;--i){
		if(s[i]!='Z'){
			flag=false;
			continue;
		}
		if(s[i]=='Z'&&!flag){
			return false;
		}
	}
	return true;
}
int main(void){
	scanf("%s",s+1);
	n=strlen(s+1);
	if(!check()){
		printf("-1");
		return 0;
	}
	for(rr int i=n;i;--i){
		if(s[i]=='Z'){
			a[i]=1,b[i]=1;
		}else if(s[i]=='X'){
			a[i]=2,b[i]=1;
		}else{
			a[i]=1,b[i]=2;
		}
	}
	for(rr int i=1;i<=n;++i)
		printf("%d",a[i]);
	putchar('\n');	
	for(rr int i=1;i<=n;++i)
		printf("%d",b[i]);
	return 0;
}
```

---

## 作者：bunH2O (赞：2)

## 首先分析一下什么时候会无解
#### 1. 首先当大或小的时候，只需比较首位即可，所以问题出在相等上
#### 2.当相等时，必定所有位都相等，所以后面若有X,Y则无解
## 那么只需再提前判断一下即可，代码在此：
```cpp
for(int i=0;i<len;i++)
	{
		if(x[i]=='Z')
		{
			for(int j=i;j<len;j++)
			{
				if(x[j]!='Z')
				{
					cout<<-1;
					return 0;
				}
			}
		}
	}
```
### 于是就得了53分，记录在[这里](https://www.luogu.org/record/25428476)
### 那么是哪里出了问题呢？由于len<=1e6，这个O(n^2)的算法肯定超时了。
### 原来的主体：
```cpp
for(int i=len-1;i>=0;i--)
	{
		if(x[i]=='X')
		{
			a[i]=2;
			b[i]=1;
		}
		if(x[i]=='Y')
		{
			a[i]=1;
			b[i]=2;
		}
		if(x[i]=='Z')
		{
			a[i]=1;
			b[i]=1;
		}
	}
```
### 那么好了，只要加一个是否有X,Y的标志即可

```cpp
bool k=0;
```
### 如果是X,Y令k=1即可，这样就把O(n^2)变成了O(n)
### AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001],b[1000001];
int main()
{
	string x;
	bool k=0;
	cin>>x;
	int len=x.length();
	for(int i=len-1;i>=0;i--)
	{
		if(k==1&&x[i]=='Z')
		{
			cout<<-1;
			return 0;
		}
		if(x[i]=='X')
		{
			a[i]=2;
			b[i]=1;
			k=1;
		}
		if(x[i]=='Y')
		{
			a[i]=1;
			b[i]=2;
			k=1;
		}
		if(x[i]=='Z')
		{
			a[i]=1;
			b[i]=1;
		}
	}
	for(int i=0;i<len;i++)
	{
		cout<<a[i];
	}
	cout<<endl;
	for(int i=0;i<len;i++)
	{
		cout<<b[i];
	}
	return 0;
}
```


---

## 作者：叶枫 (赞：2)

## 写在前面
~~一下写两篇题解的感觉真爽~~![cy.png](https://i.loli.net/2019/09/21/jr2NTD4AeYGyz5Q.png)
# $Idea$

构造题。

思路很简单：

当$s[i]=K$时，$x[i]=y[i]=0$,

当$s[i]=X$时，$x[i]=1,y[i]=0$。

当$s[i]=Y$时，$x[i]=0,y[i]=1$

如何判断无解？

很简单，比如对于`XYXZZZZ`,有解；对于`ZYXZ`，无解

因为`ZXYZ`的话，根据我的构造方法，x=0100；y=0010,

但是与`ZXYZ`相矛盾；所以无解。

那就是说如果当前位为`Z`，那么这一位往后的字符都得是`Z`。

（我讲的不是很清楚，不懂的同学请自己手写![cy.png](https://i.loli.net/2019/09/21/jr2NTD4AeYGyz5Q.png)

于是，就有了一种判断方法

```cpp
//倒序枚举，第i位是Z时
for(int j=1;j<i;j++)
    if(s[i]!='Z') return puts("-1"),0;
```

显然超时。

于是我们可以开一个`flag`，记录当前位是否是`Z`，是则为1，不是则为0；

每次扫到`Z`时判断下即可，具体见代码![cy.png](https://i.loli.net/2019/09/21/jr2NTD4AeYGyz5Q.png)

# $Code$
```cpp
char s[maxn],x[maxn],y[maxn];
bool flag=1;
int main(){
	scanf("%s",s+1);
	int len=strlen(s+1);
	for(int i=len;i;i--){
		if(s[i]=='Z'){
			if(!flag) return printf("-1"),0;
			x[i]=y[i]='0'; 
		}		
		if(s[i]=='X'){
			flag=0;
			x[i]='1'; y[i]='0';
		}
		if(s[i]=='Y'){
			flag=0;
			x[i]='0'; y[i]='1';
		}
	}
	printf("%s",x+1);
	puts("");
	printf("%s",y+1);
	return 0;
}
```


---

## 作者：AquaRio (赞：1)

**题目传送门：**[\[XR-4\] 歌唱比赛](https://www.luogu.org/problem/P5595)

**Description**

有两个数，给出后 $n-i+1$ 位 $(1<=i<=n)$ 组成的数的大小关系。求两个数可能的值。

**Solution**

**怎么感觉比第一题还签到？**

其实把大小关系读进来，从后往前扫。

不存在合法的情况，当且仅当出现`Z`前面出现了一个别的字母。我们开一个bool变量，随便维护一下就可以了。

剩下就模拟吧，哪个大了，就给那一位填上较大的数字。

**Code**

```cpp
/*
	Name: [XR-4] 歌唱比赛
	Author: Lovely_XianShen
	Date: 20/10/19 19:18
*/

#include<bits/stdc++.h>
using namespace std;

char qaq[1000005];
int a[1000005],b[1000005];

int main() {
	bool notdeng=0;
	scanf("%s",qaq);
	int len=strlen(qaq);
	for(int i=len-1; i>=0; i--) {
		if(qaq[i]=='Z') {
			if(notdeng==1) {
				cout<<-1;
				return 0;
			}
			a[i]=3;
			b[i]=3;
		} else {
			notdeng=1;
			if(qaq[i]=='X') {
				a[i]=5;
				b[i]=0;
			} 
			if(qaq[i]=='Y'){
				a[i]=0;
				b[i]=1;
			}
		}
	}
	for(int i=0; i<len; i++)
		printf("%d",a[i]);
	cout<<endl;
	for(int i=0; i<len; i++)
		printf("%d",b[i]);
	cout<<endl;
}
```

---

## 作者：VenusM1nT (赞：1)

构造。  
首先显然这题有一个无解的情况：在 `Z` 后面有 `X` 或 `Y` 出现，此时显然不可能构造出相等的情况。  
然后就是很简单的了，对于 `X` 我们往 $x$ 串上构造一个 $2$，往 $y$ 串上构造一个 $1$；对于 `Y` 我们往 $y$ 串上构造一个 $2$，往 $x$ 串上构造一个 $1$。正确性显然。
```cpp
#include<bits/stdc++.h>
#define MAXN 1000005
#define reg register
#define inl inline
using namespace std;
int n;
char ch[MAXN],x[MAXN],y[MAXN];
bool fg;
int main()
{
	scanf("%s",ch+1);
	n=strlen(ch+1);
	for(reg int i=n;i>=1;i--)
	{
		if(ch[i]=='Z' && fg) return puts("-1"),0;
		if(ch[i]=='X') x[i]='2',y[i]='1',fg=1;
		else if(ch[i]=='Y') x[i]='1',y[i]='2',fg=1;
		else if(ch[i]=='Z') x[i]=y[i]='0';
	}
	for(reg int i=1;i<=n;i++) printf("%c",x[i]);
	puts("");
	for(reg int i=1;i<=n;i++) printf("%c",y[i]);
	return 0;
}
```

---

## 作者：Cola (赞：1)

还算是一道模拟水题吧。看到已有题解都是用字符串（字符数组）把答案存储起来再输出的，发一个不用存储答案的题解。

首先考虑如何判断无解，就拿样例4来看: `XYZXYZ`

Z表示两个数字完全相等，既然两数相等，那么在Z之前揭晓的数就得相等（就是判断Z前面揭晓的是否出现过不是Z的东西），于是乎就可以首先$O(n)$判断是否无解。
**注意这里说的“Z的前面”在字符串中指“下标比Z大的数”（其实前后无所谓，不影响答案）**

然后就很简单地考虑了：是X就说明小X此时分数高，是Y就说明小Y分数高，因为Special Judge，所以用0,1表示即可。


```
#include<iostream>
#include<cstring>
using namespace std;
string x;
int end() {cout << -1;return 0;}
int main()
{
	cin >> x;
	int s = x.size(), i;
	for(i = s - 2;i >= 0;--i)//因为判断i与i+1,所以从s-2开始
    	if(x[i] == 'Z' && x[i + 1] != x[i])
        	return end();
	for(i = 0;i < s;++i)
    	cout << (x[i] == 'X' ? 1 : 0);//是X就说明此时X大，用1表示
	cout << endl;
	for(i = 0;i < s;++i)
    	cout << (x[i] == 'Y' ?	1 : 0);
//Z的话两个都是0，就是相等的
	return 0;
}
```

---

## 作者：狸狸养的敏敏 (赞：1)

这道题是一个相对较水的贪心+模拟题

我们知道两个数，如果 $A>B$ ，设 $A$ 的第 $i$ 位为 $A_i$ 则必然存在一个 $k$ 使得 $A_1=B_1,A_2=B_2 \dots A_{k-1}=B_{k-1} $ 并且 $A_k>B_k$

回到这道题，我们发现题目要求的就是这样一个结果

那么我们考虑以下情况：

### 1.临时结果为 $X$

####  1.1 当前小x已经比小y大：不用管
#### 1.2 当前小x没有小y大：令小x这一位比小y大，则整个比小y大

### 2.临时结果为 $Y$

#### 2.1 当前小y比小x大：不用管
#### 2.2 当前小y没有小x大：令小y这一位比小x大

### 3.临时结果为 $Z$

#### 3.1 小x和小y本身相等：不用管
#### 3.2 小x和小y不等：无解输出-1

配合代码感性理解吧

```
#include<bits/stdc++.h>
#define reg register
#define inl inline
using namespace std;
inl int read(){reg int x=0,f=0;char ch=0;while(!isdigit(ch))f|=(ch=='-'),ch=getchar();while(isdigit(ch))(x*=10)+=(ch^48),ch=getchar();return f?-x:x;}
inl void Ot(reg int x){if(x<0)putchar('-'),x=-x;if(x>=10)Ot(x/10);putchar(x%10+48);}
inl void Print(reg int x,char til='\n'){Ot(x);putchar(til);}
inl int Max(reg int x,reg int y){return x>y?x:y;}
inl int Min(reg int x,reg int y){return x<y?x:y;}
inl int Abs(reg int x){return x<0?-x:x;}


int len;
string res;
string str1,str2;
bool Get_ans()
{
    for(reg int i=1;i<=len;i++)
    str1+='0',str2+='0';
    int pos=len;
    bool flag=0;
    for(reg int i=len-1;i>=0;i--)
    if(res[i]!='Z'){
        flag=1,pos=i;
        break;
    }//找到从后数起第一个不是'Z'的，这样就不用处理情况3
    if(pos==len)return true;
    for(reg int i=pos;i>=0;i--) 
    {
        if(res[i]=='Z'&&flag)return false;
        if(res[i]=='X')
        {
            if(res[i+1]=='X')continue;
            else str1[i]='1';
        }
        else 
        {
            if(res[i+1]=='Y')continue;
            else str2[i]='1';//1 比 0 大 即可
        }
    }
    return true;
}
signed main(){
    #ifdef LOCAL_DBG
        freopen("input.in","r",stdin);
    #endif
    cin>>res;
    len=res.size();
    if(!Get_ans())
        return puts("-1"),0;
    cout<<str1<<endl<<str2<<endl;
    return 0;
}
```

---

## 作者：Alarm5854 (赞：0)

这道题十分简单(不过比第一题难一点)，无解的情况就是已经出现过`X`或`Y`了又出现`Z`了，这是不可能构造出来的，直接输出`-1`即可，否则，就根据输入的字符来判断这一位数的大小，~~于是我就上了两种代码~~。
### 乱搞版代码：
```cpp
#include<bits/stdc++.h>
#define N 1000000+10
using namespace std;
char str[N],x[N],y[N];
int flag,len;
int main(){
	srand(time(0));//看到这个你应该就知道我要干什么了吧
	scanf("%s",str),len=strlen(str)-1;
	for(int i=len;~i;--i){
		if(!flag&&str[i]!='Z')
			flag=1;//如果出现第一个不是Z的字符，旗帜升起
		else if(flag&&str[i]=='Z'){
			puts("-1");//如果旗帜升起却又出现Z了，那么就输出-1
			return 0;
		}
		int a=rand()%10,b=rand()%10;//开始搞事
		if(str[i]=='X'){
			while(a<=b) a=rand()%10,b=rand()%10;//看看哪个非酋因为这个而卡到TLE
			x[i]=a|48,y[i]=b|48;//相当于x[i]=a+48,y[i]=b+48;
		}
		else if(str[i]=='Y'){
			while(a>=b) a=rand()%10,b=rand()%10;
			x[i]=a|48,y[i]=b|48;
		}
		else x[i]=y[i]=a|48;
	}
	puts(x),puts(y);
	return 0;
}
```
### 正常版代码：
```cpp
#include<bits/stdc++.h>
#define N 1000000+10
using namespace std;
char str[N],x[N],y[N];
int flag,len;
int main(){
	scanf("%s",str),len=strlen(str)-1;
	for(int i=len;~i;--i){
		if(!flag&&str[i]!='Z')
			flag=1;
		else if(flag&&str[i]=='Z'){
			puts("-1");
			return 0;
		}
		if(str[i]=='X') x[i]=49,y[i]=48;//相当于x[i]='1',y[i]='0';
		else if(str[i]=='Y') x[i]=48,y[i]=49;
		else x[i]=y[i]=48;
	}
	puts(x),puts(y);
	return 0;
}
```
乱搞版代码的效率比正常版的效率要低的多，如图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zahrupyz.png)  
所以我还是推荐用正常版代码

---

## 作者：寒鸽儿 (赞：0)

本题构造答案:  
首先由于高位的权比低位大,故而不等关系并不会造成构造不出答案。唯一无解的情况应该是:$'Z'$——相等。  
后缀的相等没有关系,如果中间出现相等的部分就GG。  
由于高位权重大,所以当前位两数(不相等)则直接决定大小的关系,据此写出代码。  
填的数字随便选一个就好了,我这里填的是0|1。
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 1234567;
char s[maxn], ax[maxn], ay[maxn];

bool check(int len) {
    int p = len - 1;
    while(~p && s[p] == 'Z') --p;
    for(int i = 0; i <= p; ++i)
        if(s[i] == 'Z')
            return true;
    return false;
}

int main() {
    scanf("%s", s);
    int len = strlen(s);
    if(check(len)) {
        printf("-1\n");
        return 0;
    }
    for(int p = len - 1; ~p; --p)
        if(s[p] == 'Z') {
            ax[p] = ay[p] = '0';
        } else if(s[p] == 'Y') {
            ay[p] = '1'; ax[p] = '0';   
        } else {
            ax[p] = '1'; ay[p] = '0';
        }
    printf("%s\n%s", ax, ay);
    return 0;   
}
```

---

## 作者：Create_Random (赞：0)

一道模拟题

~~本蒟蒻月赛时74分挂了~~

------------

本蒟蒻思路：

暴力从后往前找

是X就把小X的这一位字符设为2，把小Y的字符设为1

反之亦然

是Z就把它们都设为1

注意！！！

Z只能出现在连续的最后几位！！！

（因为如果Z出现在前面，那么后面的X和Y就不成立了）

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
char s1[1000010],s2[1000010];
bool tmp;
int main()
{
	cin>>s;
	for(int i=s.length()-1;i>=0;i--)
	{
		if(s[i]=='X')
		{
			s1[i]='2';//把小X的i位设为2
			s2[i]='1';//把小Y的i位设为1
            			//s1[i]>s2[i]即可
			tmp=1;//前面不能有Z了
		}
		else if(s[i]=='Y')
		{
			s1[i]='1';//把小X的i位设为1
            			//s1[i]<s2[i]即可
			s2[i]='2';//把小Y的i位设为2
			tmp=1;//前面不能有Z了
		}
		else
		{
			if(tmp)//Z后面有X或Y时，输出-1
			{
				printf("-1");
				return 0;
			}
			else//如果Z在最后
			{
				s1[i]='1';//把小X的i位设为1
				s2[i]='1';//把小Y的i位设为1
                			//s1[i]=s2[i]即可
			}
		}
	}
	cout<<s1<<endl<<s2;
	return 0;
}
```
注意！！！

getline会出锅！！！

[提交记录](https://www.luogu.org/record/25509413)


---

## 作者：ShineEternal (赞：0)

### [$my\ blog$](https://blog.csdn.net/kkkksc03)

## solution:

此题我个人认为像是一道类似愚人节的题目。。。

其实特别简单，但是我挂在了一句话上：

> 果我们再用 Z 表示小 X 与小 Y 的**点赞数**暂时一样

这里不小心惯性思维想成了只有那一位相等，其实是都相等。。。

于是此时问题就简单了，无解就是在Z后面还有X或Y，先判断完无解再正常判断X和Y即可（可以用0，1赋值）

## code：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
char s[1000005];
int a[1000005],b[1000005];
int main()
{
	scanf("%s",s);
	int n=strlen(s);
	int pd=0;
	for(register int i=0;i<n;i++)
	{
		if(s[i]=='Z')
		{
			pd=1;
		}
		if(pd&&s[i]!='Z')
		{
			printf("-1\n");
			return 0;
		}
	}
	for(register int i=n-1;i>=0;i--)
	{
		if(s[i]=='X')
		{
			a[i]=1;
		}
		if(s[i]=='Y')
		{
			b[i]=1;
		}
	}
	for(register int i=0;i<n;i++)
	{
		printf("%d",a[i]);
	}
	printf("\n");
	for(register int i=0;i<n;i++)
	{
		printf("%d",b[i]);
	}
	return 0;
}
```

---

## 作者：傅思维666 (赞：0)

## 题解：

~~一道橙题难了蒟蒻40多分钟~~

~~果然还是蒟蒻太菜了~~

一开始看觉得根本做不了，后来发现是SPJ。

那就好办了，我们随便构造出一个合法的序列就可以。

根据贪心的一个思想，为了维护序列的正确性，谁更大就往谁里捅9，谁更小往谁里捅0.

下面就是判断合法与否。

手推几组数据可以发现，如果Z不是连成串的，那么一定不合法：

比如：`ZXYXYX`这一段序列。到Z后面的那位的时候还是X比较大，突然就到了Z，两个人相等了？？！

这是无论如何也构造不出来的。

所以判断一下就可以了。

~~蒟蒻又判了一下len=1的情况~~

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
using namespace std;
const int maxl=1e6+1;
char s[maxl];
int ans1[maxl],ans2[maxl];
int main()
{
    scanf("%s",s+1);
    int len=strlen(s+1);
    if(len==1)
    {
        if(s[1]=='Z')
            printf("0\n0");
        else if(s[1]=='X')
            printf("2\n1");
        else
            printf("1\n2");
        return 0;
    }
    for(int i=1;i<len;i++)
        if(s[i]=='Z'&&s[i+1]!='Z')
        {
            printf("-1");
            return 0;
        }
    for(int i=len;i>=1;i--)
    {
        if(s[i]=='X')
        {
            ans1[i]=9;
            ans2[i]=0;
        }
        else if(s[i]=='Y')
        {
            ans1[i]=0;
            ans2[i]=9;
        }
        else 
        {
            ans1[i]=0;
            ans2[i]=0;
        }
    }
    for(int i=1;i<=len;i++)
        printf("%d",ans1[i]);
    puts("");
    for(int i=1;i<=len;i++)
        printf("%d",ans2[i]);
    return 0;
}
```



---


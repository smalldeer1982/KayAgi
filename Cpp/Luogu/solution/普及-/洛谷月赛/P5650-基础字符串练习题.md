# 基础字符串练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定长度非零的非空 01 串 $S$。

找出 $S$ 的非空连续子串 $T$ 满足串中 0 的个数减去 1 的个数最大。

你只需要输出最大值即可。

## 说明/提示

设 $|S| = n$。

| 数据点编号 | $n \le$ |
| :--: | :--: |
| $1 \sim 2$ | $10$ |
| $3 \sim 6$ | ${10}^3$ |
| $7 \sim 10$ | ${10}^5$ |

对于 $100\%$ 的数据，$1 \le n \le {10}^5$。

## 样例 #1

### 输入

```
0111100101```

### 输出

```
2```

# 题解

## 作者：hwx12233 (赞：49)

嗯，这道题有点水。。

就是求一个最大子段和

## 解法

显然我们可以求前缀和，然后求解，但是有点慢？吧

这里介绍一种新的

~~又显然~~
我们可以：

遇到$0$当前最优解就$+1$,并与全局最优解取$max$

遇到$1$当前最优解$-1$，并与$0$取$min（$因为如果小于$0，$那么不如不选这前面的所有$）$


设一个$ans1$记录部分最优解，$ans2$记录到全局的最优解$（ans2$记得初始值为$-1，$防止所有都是1的情况$）$

最后奉上代码，码风炸裂，大佬勿喷。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int max(int x,int y){return x>y?x:y;}
#define int ll
int n;char s[100501];
signed main()
{
	cin>>s;int ans1=0,ans2=-1;
	n=strlen(s);
	for(int i=0;i<n;i++){
		int tmp=s[i]-'0';
		if(tmp==0){
			ans1++;
			ans2=max(ans1,ans2);
		}
		else 
			ans1=max(0,ans1-1);
	}
	cout<<ans2;
}
```

谢谢观看！

---

## 作者：冬天的雨 (赞：37)

# 蒟蒻的题解                 
[原题在这里](https://www.luogu.org/problem/P5650)                        
向管理员致歉：$\LaTeX$ 爆炸了 调试了好多遍，浪费了管理员的时间，抱歉             
鄙人蒟蒻又来水比赛了。。。虽然其余题目大红大紫这道题$\color{green}\mathfrak{AC}$还是真的。。。                           
先让我们来捋一下思路：               
 标题——基础字符串题，所以这道题一定和字符串有关       
 背景——没有用不过还要~~不明就里地~~膜拜**YSGHdalao**      
 描述——重要！         
 ### S是一个01串，这就可以减去很多特判               
    
**T**这个串是**S**的 **非空** 子串，这就告诉我们 当出现**111111**这样的**S**串时答案 **不可以是-1！！！**         
**T**要满足 0 的个数减去 1 的个数最大                   

------------

然后窝们可以来思考：这道水题怎样做呢？？？         
第一我们可以想到，可以忽略掉所有的1，统计连续出现的最多的 **0**    
但是反例不难举出：当串为 **00100** 时答案是 **3** 而不是 **2**        
所以我们继续深入探究，不难发现可以用两个计数器统计 **0** 和 **1** 的个数，然后比较两计数器的值并且和最大值打擂台        
所以 $\color{green}\mathfrak{AC}$代码如下，代码里也有分析：                       


------------

```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
using namespace std;//头文件不解释 
int main(){
    char a[100001];//定义char数组
    cin>>a;//神犇同学3300872109a告诉我输入可以用int，具体是scanf("%1d",&a[i]); 
    int lena=strlen(a),tm1=0,tm0=0,maxx=-1;//定义出现的1的次数，0的次数
    //划重点：题目中说了子串S不为空所以maxx必须等于-1 
    //为了应对极端情况1111111111 
    for(int i=0;i<lena;i++){
        if(a[i]=='0'){//如果对应字符是0 
            tm0++;//0的次数++ 
        }
        if(a[i]=='1'){//如果对应是1 
            tm1++;//1的次数++ 
        }
        if((tm0-tm1)>=maxx){//如果两个个数相减大于maxx 
            maxx=tm0-tm1;//maxx被替换 
        }
        if(tm1>=tm0){//如果1的个数 大于了0的个数 
            tm0=0; 
            tm1=0;//重置进入下一个循环 
        } 
    }
    printf("%d",maxx);//咻~~输出了 
    return 0;//完结撒花 
} 
```                      
题解到此结束，蒟蒻不易，如果诸位大佬不嫌弃，**点个赞** 再走呗~              


---

## 作者：Inkyo (赞：23)

>这里是墨攸，平生没有什么爱好，就喜欢做A题。

听出题人说这是$\text{pj}$组第一题难度？（虽然NOIp死了23333）

然后呢，这里目前有两种做法。

- ## 1、$dp$

考试的时候想出来的做法。

这题看起来就很像最大连续子段和问题。只不过所有的值变成了$01$（然而最大子段和是用 $dp$ 做的 23333）

我们可以这么设计$dp$：

**设 $dp[i]$ 为选到字符串第 $i$ 位时，答案的最优解（最大值）。**

**那么我们要么继承前面我们选的区间，要么就把前面都扔了，另起炉灶。**

所以转移方程就很好写了：

$$dp[i] = max(dp[i-1] + f, f)$$

其中，第 $i$ 位的字符为 $0$，则 $f=1$； 若为$1$，则$f=-1$。

计算完$dp$值后，$O(n)$ 扫一遍取最大值即可

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
#define maxn 100005

using namespace std;

string s;
int dp[maxn], ans = -inf;

int main()
{
	cin >> s;
	dp[0] = ((s[0] == '0') ? 1 : -1); //预处理dp[0]（因为涉及 i-1，i不能为0）
	for(int i = 1; i < s.size(); i ++)
	{
		int f = ((s[i] == '0') ? 1 : -1);
		dp[i] = max(dp[i - 1] + f, f);
	}
	for(int i = 0; i < s.size(); i ++)
		ans = max(ans, dp[i]); //扫一遍所有dp值中的最大值
	printf("%d", ans);
	return orz;
} 
```

- ## 2、前缀和

同样，本题也可以前缀和解决。

明显，任何一个子段 $[l,r]$ 的值 都可以看做 $[1,r] - [1,l-1]$ 求得的值。

显然，$[l,r]$ 如果要最大，$[1,l-1]$ 这一段显然要足够小。

那么我们可以维护一个 $sum$ 值，维护到第$i$位，即表示 $[1,i]$ 的和 （也就是前缀和）。

显然我们可以再维护两个值，$minn$ 和 $ans$ 。前者用于维护 $[1,l-1]$ 中的最小值，$ans$ 则用于维护最优解。那么就有：

$$ans = max(ans,sum-minn)$$

$$minn=min(minn,sum)$$

同样$O(n)$跑一遍即可。

（话说这种做法看起来就很像$dp$）

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
#define maxn 100005

using namespace std;

string s;
int sum, minn, ans = -inf;

int main() 
{
	cin >> s;
	for(int i = 0; i < s.size(); i ++)
	{
		int f = (s[i] == '0') ? 1 : -1;
		sum += f;
		ans = max(ans, sum - minn);
		minn = min(sum, minn);
	}
	printf("%d", ans);
	return 0;
}
```

~~大概也许好像可能没准不一定就这样了吧~~

---

## 作者：大头 (赞：11)

### 算法1

考虑预处理字符串‘0’,'1'个数的前缀和。

询问时枚举左端点和右端点，根据预处理的前缀和计算价值。

时间复杂度$O(n^2)$

### 算法2

设前缀‘0’的数量为$S0_i$,前缀‘1’的数量为$S1_i$。

则区间$[l,r]$对答案的贡献为$S0_{r}-S0_{l-1}-S1_{r}+S1_{l-1}$。

设$V_i=S0_i-S1_i$，则贡献可以改写为$V_r-V_{l-1}$。

对于固定的右端点$r$，显然需要找到权值最小的$V_{l-1}$。

一遍扫过去即可。

时间复杂度$O(n)$。

注意特判$-1$的情况

code:

```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define ll long long
using namespace std;
const int N=100005;
char s[N];
int n,S,mx,ans;
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	S=mx=0; ans=-1;
	For(i,1,n){
		S+=(s[i]=='0'?1:-1);
		ans=max(ans,S-mx);
		mx=min(mx,S);
	}
	printf("%d",ans);
}

```

---

## 作者：Star1_3st (赞：5)

在串中找出一段区间，使区间中的'0'数减'1'数最大。

发现'0'对答案贡献为1，而'1'的贡献为-1.故求一个前缀和，然后枚举区间起点，从起点到终点查找区间最大值，这个最大值减区间左端点就是以这个点为左端点的答案。

这个查找最大值的步骤可以用ST表或线段树。这里用了线段树。

```cpp
#include<bits/stdc++.h>
inline int fmax(int x,int y)
{
	return x>y?x:y;
}

char s[100001];
int n,ans=-0x7fffffff,sum[100001];
struct tree
{
	int max[400001];
	inline void build(int k,int l,int r)
	{
		if(!(l^r))
		{
			max[k]=sum[l];
			return;
		}
		
		int mid=l+r>>1;
		build(k<<1,l,mid);
		build(k<<1|1,-~mid,r);
		max[k]=fmax(max[k<<1],max[k<<1|1]);
		return;
	}
	
	inline int query(int k,int l,int r,int x,int y)
	{
		if(r<x||l>y)
			return -0x7fffffff;
		if(l>=x&&r<=y)
			return max[k];
		int mid=l+r>>1;
		return fmax(query(k<<1,l,mid,x,y),query(k<<1|1,-~mid,r,x,y));
	}
}t;
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(register int i=1;i<=n;i=-~i)
		sum[i]=sum[i-1]+(!(s[i]^'0')?1:-1);
	t.build(1,1,n);
	for(register int i=0;i<n;i=-~i)
		ans=fmax(ans,t.query(1,1,n,-~i,n)-sum[i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：_mzh (赞：4)

# 初学DP，来试试题

这个题用DP 很好做，递归+记忆化搜索；
 主要是记得把数组开的足够大就好了，一开始就不够大报错了。。。emmm
 
 建立一个OTP的思路，要么选择要么不选，从最后一个开始，如果前一个的最优加上他，比他自己大，那么就选择前一个的最优加上他，否则他的最优就是他自己。
 
 dp[i]=max(dp[i-1]+zh(n[i]),zh(n[i]))
 zh就是把0和1转换成1和-1来运算，so good；
 
 附带我弱弱的代码
 ```
 #include<bits/stdc++.h>
#define MAX 0xfffff
#define orz 0
using namespace std;
string n;
int length;
int dp[MAX];
int zh(char a){if(a-'0'==0)return 1;else return -1;}
int max(int a,int b){return a>b?a:b;}
int OTP(int m){
	if(m==0)return dp[m]=zh(n[m]);
	if(dp[m])return m;
	return dp[m]=max(OTP(m-1)+zh(n[m]),zh(n[m]));
}
int main(){
	cin>>n;
	length=n.length();
	OTP(length-1);
	sort(dp,dp+length);
	cout<<dp[length-1];
} 

---

## 作者：交警 (赞：4)

# $Solution$
[$P5650$ 基础字符串练习题](https://www.luogu.org/problem/P5650)

我来讲一个 $dp$ 的做法。

其实问题可以转化为[$P1115$ 最大字段和](https://www.luogu.org/problem/P1115)，只需要把字符串中的```'0'```变成```'1'```，然后把字符串中的```'1'```变成```'-1'```，然后用 $dp$ 求解最大字段和即可。

***注意特判全为1的情况，也可以把 $ans$ 初始化为```'-1'```。***

上码！

```cpp
#include<bits/stdc++.h>

namespace speed {

	template < typename T > inline T read() {
		register int f = 1; register T sum = 0; register char ch = getchar();
		while ( !isdigit(ch) ) { if ( !( ch ^ '-' ) ) f = -1; ch = getchar(); }
		while ( isdigit(ch) ) { sum = (sum<<1) + (sum<<3) + (ch^48); ch = getchar(); }
		return f * sum;
	}

	template < typename T > inline void write ( register T x ) {
		if ( x < 0 ) { putchar ( '-' ); x = -x; }
		if ( x > 9 ) { write ( x / 10 ); }
		putchar ( x % 10 + 48 );
	}

	template < typename T > inline T max ( register T x, register T y ) {
		return x > y ? x : y;
	}

	template < typename T > inline T min ( register T x, register T y ) {
		return x > y ? y : x;
	}

	template < typename T > inline T abs ( register T x ) {
		return x > 0 ? x : -x;
	}

	template < typename T > inline void swap ( register T &x, register T &y ) {
		register T k;
		k = x; x = y; y = k;
	}

}

using namespace speed;

const int N = 1e5 + 5;

int len, ans = -1e6, a[N], f[N];//ans尽量赋的小一点，往大了赋也不要超过-1
char ss[N];

signed main() {
	
	scanf ( "%s", ss + 1 );
	len = strlen ( ss + 1 );
	for ( register int i = 1 ; i <= len ; i = -~ i )//把字符串处理成上面所说的数组。
		if ( ss[i] == '0' )
			a[i] = 1;
		else
			a[i] = -1;
	
	for ( register int i = 1 ; i <= len ; i = -~ i ) {
		f[i] = max ( a[i], f[i-1] + a[i] );//dp的状态转移方程
		ans = max ( f[i], ans );
	}
	
	write < int > ( ans ), putchar ( '\n' );
	
	return 0;
}
```

当然，这道题也可以用别的方法做，像线段树，贪心之类的方法也都是很不错的选择。

# $End$
# $NanyaOIer$ 出品

---

## 作者：B_Qu1e7 (赞：3)

找$S$的连续字串，其中满足$0$的个数$-1$的个数最多。

考虑前缀和，$0$对答案的贡献为$1$，$1$对答案的贡献为$-1$，若前缀和$<0$则舍去。注意题目要求非空字串，所以没有$0$时至少要选择一个$1$，输出$-1$。

```
#include<cstdio>
int main()
{
	register char a=getchar();
	register int now=0,ans=-1;
	while(!(a^48&&a^49))
	{
		now=(!(a&1)?now+1:(!now?0:now-1)),
		ans=(!(a&1)&&ans<now?now:ans),
		a=getchar();
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：MoXiaodu (赞：3)

### 题目背景

$YSGH$牛逼
### 题目描述

给定长度非0的非空01串$S$。

找出$S$的非空连续子串$T$满足串中'0'的个数-'1'的个数最大。

你只需要输出最大值即可。

------------
### 思路：
贪心，从字符串下标$0$开始找，一直找到$n-1$,根据每一个字符改变答案，并取最大值，如果当前答案$<0$,则将其改变成$0$.（注意特判全是1的情况）

时间复杂度：$O(n)$
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string c;
int ans,l_ans;
int main(){
	cin>>c;//读入字符串
	for(int i=0;i<c.size();i++){
		if(c[i]=='0')ans++;
		else ans--;
        //根据字符修改答案（如题意所说）
		if(ans<0)ans=0;//ans<0就改变成0（因为这一段对答案已经没有贡献）
		l_ans=max(l_ans,ans);//取最大值
	}
	if(l_ans==0)//特判，因为必须要取一个数
	cout<<"-1";
	else
	cout<<l_ans; 
	return 0;
}
```


---

## 作者：R·Buffoon (赞：2)

~~话说，刚开始真没看懂题目（那个‘-’真是醉了）~~

静下心来认真看了一遍（根本没法静下心，机房的大佬们已经$A$了qwq），原来是在一个$01$串里找一个**非空连续**子串使 ‘$0$’ 的个数**减** ‘$1$’ 的个数**最大**，输出最大值（注意加粗的字）

哦~，可以用**前缀和+dp**！~~（最近感觉好多题都可以前缀和+dp，但我都没写出来，应该是我中毒了）~~

首先用一个数组$dp$记录输入第$i$个字符时的最大值，如果是 ‘$0$’ ，$dp[i]=dp[i-1]+1$，如果是 ‘$1$’ ，则$dp[i]=max(dp[i-1]-1,0)$（如果这时一个 ‘$0$’ 都没读入，$dp[i-1]=0$，当然是 $0$ 更优）

但是，这样只有$90pts$，因为有一组特殊数据（还好这是$IOI$赛制），盲猜是一串‘$1$’，这时按上述策略会一个都不选，答案为$0$，而题目要求要找一个**非空连续**子串，所以就不行了

所以，该怎么办呢？

~~加个特判不就行了？~~

好吧，我也没想到有什么好办法了 ~~（我太弱了）~~，于是我特判过了
```cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

LL in()//快读，这题没用
{
	LL aa=0,ff=1;char cc=getchar();
	for(;!isdigit(cc);cc=getchar())if(cc=='-')ff=-1;
	for(;isdigit(cc);cc=getchar())aa=(aa<<1)+(aa<<3)+(cc&15);
	return aa*ff;
}

const int mod=1e8;
const int N=1e5+5;

inline int maax(int a,int b)//卡常
{
	return a>b?a:b;
}

char c;
int dp[N],ans=0,flag=0;

int main()
{
    RI cnt=0;
	dp[0]=0;
	while(~scanf("%c",&c))
	{
		++cnt;
		if(c=='0') dp[cnt]=dp[cnt-1]+1;
		else if(c=='1') dp[cnt]=maax(dp[cnt-1]-1,0);
		if(dp[cnt]>0) flag=1;//特判有无‘0’出现
		ans=maax(ans,dp[cnt]);//保存答案
	}
	
	if(flag)cout<<ans<<endl;
	else puts("-1");
	
	return 0;
}
```
跑到好慢，$44ms(qaq)$，大佬们$30ms$多是咋写的呀

听说有一种神奇的做法，就是把读入的‘$0$’换成$1$，‘$1$’换成$-1$，然后再求，可能会比较快，可以试一下

---

## 作者：Priori_Incantatem (赞：2)

一道较简单的DP题，跟[P1115 最大子段和](https://www.luogu.org/problem/P1115)非常相似，这里给出的是$O(n)$的做法

我们设$f[i]$为 以字符串$S$的第$i$位结尾的子串，`0`的个数减去`1`的个数的最大值

对于每一位$i$，分别考虑“加入前面的子串”和“重新成立一个子串”两种情况：  
若字符串$S$的第$i$位为`1`，$f[i]=max(f[i-1]-1,-1)$  
若字符串$S$的第$i$位为`0`，$f[i]=max(f[i-1]+1,1)$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int Maxn=100000+20,inf=0x3f3f3f3f;
char s[Maxn];
int f[Maxn],n,ans=-inf;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;++i)
	{
		int tmp=0;  //简化了判断
		if(s[i]=='0')tmp=1;
		else tmp=-1;
		f[i]=max(f[i-1]+tmp,tmp);
		ans=max(ans,f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：phigy (赞：2)

这道题明显是道dp（~~大眼观察法~~），不过为什么叫**基础字符串练习题**?


------------
进入正题

题目：

给定长度非$0$的非空$01$串$S$。

找出$S$的非空连续子串$T$满足串中$0$的个数-$1$的个数最大。

接下来开始分析：

这题的状态和最大子序列的状态一样

我们设$dp[i]$表示以字符串$S$中第$i$个字符结尾的子串$T$的最大值

举个例子：

| S | 0 | 1 | 0 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| i | 1 | 2 | 3 | 4 |
| dp[i] | 1 | 0 | 1 | 2 |

那么转移方程是什么呢？

若$S[i]=1$
	
此时$dp[i]$可以接上一个$dp[i-1]$:$dp[i]=dp[i-1]-1$

但如果$dp[i-1]=-1$那还不如再新开一个串：$dp[i]=-1$

综上：$dp[i]=max(dp[i-1]-1,-1)$

若$S[i]=0$

此时$dp[i]$可以接上一个$dp[i-1]$:$dp[i]=dp[i-1]+1$

但如果$dp[i-1]=-1$那还不如再新开一个串：$dp[i]=1$

综上：$dp[i]=max(dp[i-1]+1,1)$

两种情况下的转移方程推出来了，代码自然就写出来了。

**不过，注意dp[n]不一定是最大的，需要用ans来找dp[i]中的最大的**

**还要注意！ans初始化不要为0，答案有可能为-1**

std:

```cpp
#include <iostream>

using namespace std;

char a;
int dp[100000000];
int ans=-10;
int main()
{
    int i=0;
    while(cin>>a)
    {
        i++;
        if(a=='0')
        {
            dp[i]=max(dp[i-1]+1,1);
        }
        if(a=='1')
        {
            dp[i]=max(dp[i-1]-1,-1);
        }
        ans=max(ans,dp[i]);
    }
    cout<<ans;
    return ^_^;
}

```


---

## 作者：老部长 (赞：2)

### **稍微有点技巧的前缀和**

（~~虽然我考试时60分。。。~~）

1. 60分算法：维护一个前缀和，然后${n^2}$枚举左右端点，求最大值，看数据，就60分。

2. 在${n^2}$的基础上，我们可以找到O(n)的算法。

i是右端点，j是坐端点，sum1是1的前缀和，sum0是0的前缀和

${n^2}$算法的公式：
	
    sum0[i]-sum0[j-1]-(sum1[i]-sum1[j-1);

拆开化简一下：

	sum0[i]-sum1[i]+sum1[j-1]-sum0[j-1];

所以我们只用求出sum1[j-1]-sum0[j-1] （j<=i）的最大值，然后枚举i就行了；

粘代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register int
using namespace std;
int a[maxn];
int sum1[maxn],sum0[maxn];
int summ[maxn],maxx[maxn];
int main()
{
	char c[100005];
	cin>>c;
	int n=strlen(c);
	for(re i=0;i<n;i++)
	{
		a[i+1]=(c[i]^48);
	}
	for(re i=1;i<=n;i++)//前缀和
	{
		if(a[i]==0)
		{
			sum0[i]=sum0[i-1]+1;
			sum1[i]=sum1[i-1];
		}
		else
		{
			sum1[i]=sum1[i-1]+1;
			sum0[i]=sum0[i-1];
		}
	}
	if(sum0[n]==0)//注意特判，如果序列全为1
	{
		printf("-1");
		return 0;
	}
	for(re i=1;i<=n;i++)记录每个（sum1[左端点]-sum0[左端点]）
	{
		summ[i]=sum1[i]-sum0[i];
	}
	for(re i=1;i<=n;i++)//寻找i之前的（sum1[左端点]-sum0[左端点]）的最大值
	{
		maxx[i]=max(maxx[i-1],summ[i]);
	}
	int ans=-0x3f3f3f3f;
	for(re i=1;i<=n;i++)//枚举右端点
	{
		ans=max(sum0[i]-sum1[i]+maxx[i],ans);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：爷，无限霸气 (赞：2)

# 提供一种和题解不一样的做法！

对于这一串字符，我们考虑0的个数和1的个数的差

不难想到用前缀和，~~不过此题解不讲前缀和思路~~

我们从左扫到右，遇到0 ans的备份就加1（ans的真身取max），遇到1 ans的备份就减1

每当ans的备份小于0时，我们就把他右边的一段和左边的一段断开（也就是不管左边一段，ans的备份=0）

然后循环进行以上操作即可！！！（注意要特判全是1的情况哦！）

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 10005
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
string a;
ll ans,ans1;
int main()
{
	cin>>a;
	ll lena=a.size();
	for(int i=0;i<lena;i++)
	{
		if(a[i]=='0')
		{
			ans1++;
			ans=max(ans,ans1);
		}
		else ans1--;
		if(ans1<0) ans1=0;
	}
	if(ans==0) ans=-1;
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Kendrick_Z (赞：2)

大家都会O（n）的优秀做法

但是我第一眼想到了超级钢琴固定端点的做法

（还被同学D了）

给大家提供一个nlogn的辣鸡做法

顺便提醒大家要复习一下ST表

这个可是静态RMQ问题的大杀器啊！

我们令0为1，1为-1

维护个前缀和那么我们就可以通过前缀和来求出任意子串的0-1的个数了

可以n^2枚举

但是没必要

考虑超级钢琴的做法

固定一个端点l

向右找一个前缀和最大的即可

那么插入ST表 然后nlogn预处理

O(1)查询即可

具体理解看代码

简单讲一下ST表：

ST表是运用倍增和DP的思想

设$f[i][j]$ 表示在$[i,i+2^j-1]$里的最大值

那么我们倍增向右跳转移即可

方程:

$F[i][j]=max(F[i][j-1],F[i+(1<<(j-1)][j-1]$

查询l,r时候

我们只需要查询

$max(F[l][k],F[r-(1<<k)+1][k])$

K=LOG2(R-L+1)

祝大家RP++!

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
char s[100001];
int sum[100001],a[100001],n;
const int T=21;
int f[100001][22]; 
inline void prework(){
	for(int j=1;j<T;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
}
inline int query(int l,int r){
	int t=log2(r-l+1);
	return  max(f[l][t],f[r-(1<<t)+1][t]);
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++){
		if(s[i]=='0'){
			a[i]=1;
		}else {
			a[i]=-1;
		}
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
		f[i][0]=sum[i];
	}
	if(sum[n]==(-n)){
		cout<<-1;
		return 0;
	}
	prework();
	int ans=0;
	for(int i=1;i<=n;i++){
		int now=query(i,n);
		ans=max(now-sum[i-1],ans); 
	}
	cout<<ans;
	return 0;
}
```




---

## 作者：熊崇文 (赞：1)

## [博客园传送](https://www.cnblogs.com/xiongchongwen/p/11853936.html)

看到这一题，立刻就想到了暴力（暴力出奇迹）。

那么，这一题就只要从前向后扫一遍即可。

但是，就真的没坑吗？

假如输入全是1呢？这儿就需要特判-1了，不然就只会输出0，导致WA。


解释在代码的注释中。


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
char s[100610];
int work[100610],maxx,ans;
int main(){
    scanf("%s",s+1);//整个字符串读取 
    int n=strlen(s+1);//测长 
    for(int i=1;i<=n;i++){
        if(s[i]!='1'){
            work[i]=work[i-1]+1;//是0就在上一次基础上加1 
            if(maxx<0){
                ans=max(ans,work[i]-maxx);//减去1的个数，取一个最大的结果作为ans  
            }
            else{
				ans=max(ans,work[i]);//更新目前的最大的ans 
			}
        }
        else{
            work[i]=work[i-1]-1;//是1就在上一次基础上减1 
            maxx=min(maxx,work[i]);//选取最大的maxx 
        }
    }
    if(maxx<0){
        ans=max(ans,work[n]-maxx);//减去1的个数，取一个最大的结果作为ans  
    }
    else{
		ans=max(ans,work[n]);//更新目前的最大的ans 
	}
	if(ans==0){//全是1时输出-1 
		printf("-1");
	}
    else{
		printf("%d",ans);//不是特例则正常输出 
	}
    return 0;
}
```


---

## 作者：小酱666 (赞：1)

## ~~此题解绝对不是正解~~
### 这里介绍一个复杂度为O（N）的做法。


### ------------

#### 总体思路如下：  
 	1：对读入后的字符串进行预处理  
 	2：优先考虑特殊情况，也就是全0和全1  
 	3：对预处理后的数组进行进一步维护，求出答案。
 

### ------------
   
#### 具体的维护思路：
 题目要求字符‘0’减掉字符‘1’的数最大，  
 结合求最大子序列和的思想，  
 我们是不是可以在预处理时令 '0' 为 1， 则‘1’为 -1？
 如果这样的话，那么对于这道题的处理方式，就会变得非常奇妙。  
 这样就可以成功的将问题转换为求数组a的最大子序列和的问题。  
 代码中的maxx是手写的判断大小的函数, 
 如果不想要可以直接改为max删掉开头的自定义函数即可。

### ------------

        
####         算是半个DP吧，状态转移方程如下：  
          
	f[i]=max(f[i],f[i-1]+a[i]);  //注意取最大值，
        
    max(f[i])的意义在于如果之前已经为负数了，那么f[i]就会取到0。

        同样ans也在 f[i]和ans里取最大值就好了。
        由于预处理的数据存在数组a中，
        所以上述的转移方程很明显满足无后后效性的原则，
 	    这样只需要从 i=1开始跑到序列的末尾，计算最大子段和即可。


### ------------

### 这里提醒一下点4 Wa掉( _90 Points_ )的人，

Ps: 90分代码如下：**~~（找不同~~**
```cpp
#include<iostream>
#define maxn 100010
using namespace std;
string s;
int l; int a[maxn],f[maxn],ans=-99999;

inline int maxx(int x,int y)
{
	 return x<y?y:x;
 } 
int main()
{
	ios::sync_with_stdio(false);
	cin>>s; l=s.length();
	for(int i=0;i<l;i++)
	{
		if(s[i]=='0') a[i+1]=1;
		else a[i+1]=-1;//进行第一次的预处理
	}
	for(register int i=1;i<=l;i++)
	{
		f[i]=maxx(f[i],f[i-1]+a[i]);//取最大值
		ans=maxx(ans,f[i]);//两个都要取最大值。
	}
	cout<<ans;
}
```

可以与下方的满分代码对比一下，发现只有两处**特判**不同，  

那么问题来了：

如果序列全为1或全为0怎么办？

很明显这时候需要进行特判， 结合题目要求**满足串中'0'的个数-'1'的个数最大**

如果全为1，那么答案肯定为 -1，因为 -1一定要比负的序列长要大。

这应该是这道题的唯一一个坑点把。不考虑字符串空的情况。

### ------------

##### 最后附上蒟蒻的代码：（码力低下，dalao勿喷。

```cpp
#include<iostream>
#define maxn 100010
using namespace std;
string s;
int l; int q1,q0,a[maxn],f[maxn],ans=-99999;

inline int maxx(int x,int y)
{
	 return x<y?y:x;
 } 
int main()
{
	ios::sync_with_stdio(false);
	cin>>s; l=s.length();
	for(int i=0;i<l;i++)
	{
		if(s[i]=='0') q1=2;
		if(s[i]=='1') q0=2;
		if(s[i]=='0') a[i+1]=1;
		else a[i+1]=-1;//进行第一次的预处理
	}
	if(!q1)//特判1 全1 
	{
		cout<<-1<<endl;
		return 0;
	}
	if(!q0)//特判2 全0 
	{
		cout<<l<<endl;
		return 0;
	}
	for(register int i=1;i<=l;i++)
	{
		f[i]=maxx(f[i],f[i-1]+a[i]);//取最大值
		ans=maxx(ans,f[i]);//两个都要取最大值。
	}
	cout<<ans;
}
```

~~感谢管理员耐心审核~~


---

## 作者：congxia (赞：1)

# ~~暴力水题~~

如何做？？

首先看题面

题面的意思是：给定一个01字符串，让你选取其中一段，使其中零的个数减一的个数最大

再看看数据范围，10的五次方，俩循环百亿，必爆

做的个没剪枝的代码上去，4个tle，60;

60分思路：
两层循环解决问题，第一层选取开头，第二层选取结尾，在第二层内计算开头至结尾中零数字出现的个数减一数字出现的个数

60分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],l;
char s[100005];
int o,p,sum=-10000000;
int main(){
	cin>>s;
	l=strlen(s);
	for(int i=1;i<=l;i++){
		a[i]=s[i-1]-48;//字符转数字
	}
	for(int i=1;i<=l;i++){
		for(int j=i;j<=l;j++){
			if(a[j]==0) o++; //计算0出现的个数
			if(a[j]==1) p++; //计算1出现的个数
			sum=max(o-p,sum); //相减，求最大
		}
		o=0;
		p=0;
	}
	cout<<sum<<endl;//输出
}
```
很显然，炸了；

于是我们谈谈剪枝

怎么减呢，既然太长才爆，那就缩短好了

将连起来的零出现个数合成一个数字，将连起来的一出现个数合成一个数字

例如，原本是1111000

合起来就变成了43

可能有人会说：那你怎么判断哪个是零的个数，哪个是一的个数呢？

简单，结构体记录；

还有一个特判，输入全是一，这是我们只需要输出-1就好了（被坑）

最后上ac代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],l;
char s[100005];
int o,p,sum=-10000000;
int hj=1,hs;
bool kl=true;
struct mini{
	int num;
	int ou;
}h[100005];
int main(){
	cin>>s;
	l=strlen(s);
	for(int i=1;i<=l;i++){
		a[i]=s[i-1]-48;//字符转数字
	}
	for(int i=1;i<=l;i++){
		if(a[i]!=1) kl=false;
	}
	if(kl==true){
		 cout<<"-1"<<endl;//特判
		return 0;
	}
	hs=a[1];
	for(int i=1;i<=l;i++){
		if(a[i]==hs){//方法有点笨，可以a[i]==a[i-1]
			hs=a[i];
			h[hj].num++;//这里是判重，判断出现次数
			h[hj].ou=a[i]; //记录数字
		}
		else{
			hs=a[i];
			h[++hj].num++;
			h[hj].ou=a[i];
		}
	}
	for(int i=1;i<=hj;i++){
		for(int j=i;j<=hj;j++){
			if(h[j].ou==0) o+=h[j].num;
			if(h[j].ou==1) p+=h[j].num;
			sum=max(o-p,sum);//相减，求出答案
		}
		o=0;
		p=0;
	}
	cout<<sum<<endl;
}
```



---

## 作者：yu__xuan (赞：1)

### 题目
[P5650 基础字符串练习题](https://www.luogu.org/problem/P5650)

### 思路

这题第一眼感觉很眼熟，可能之前见过类似的。

我们将`0`看作`1`，将`1`看作`-1`。

从前往后扫一遍`sum`用作累加`1`或`-1`。
$$ans = \max(ans,sum)$$

我们贪心的想：如果当前`sum`为负，也就是前面的这一段`1`要多于`0`那么我们可以忽略前面这一段即将`sum`赋值为`0`。最后`ans`就是答案。**注意判断整个序列只有1的情况，因为不能选择空串所以答案为-1**

### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#define max(a,b) a>b?a:b

char c[100001];

int main() {
	scanf("%s",&c);int len=strlen(c);
	int ans=0,sum=0,cnt1=0;
	for(int i=0;i<len;++i) {
		if(c[i]=='1') --sum,++cnt1;
		if(c[i]=='0') ++sum;
		if(sum<0) sum=0;
		ans=max(ans,sum);
	}
	if(cnt1==len) ans=-1;
	std::cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：zbwer (赞：1)

+ 注意点：要考虑全部都为1的特殊情况  

$f[i]$表示在当前处理到第$i$位,`0`的个数 $-$ `1`的个数的最优值  

对于第i个数字,若其为1，则$f[i]=max(f[i-1],0)$即`1`的个数多了一个，在前面的基础上再-1,如果-1之后小于0，那么我们考虑抛弃前面的区间，以i为新的起点，计算新的答案。  

对于第i个数字为0，则$f[i]=f[i-1]+1$即`0`的个数多了一个，应在前面的基础上再+1.  

每处理一次都应更新$ans=max(ans,f[i])$
注意到$f[i]$只和上以为有关，那就没必要写个数组了，直接两个变量交换着用就行了。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define Mi return 
#define manchi 0

using namespace std;
const int N = 1e5+50;

char ch[N];int tmp;
int n,f,ans;bool have_zero;
/*
f[i]表示在区间[1,i]中,'0'的个数-'1'的个数的值
if(s[i]=='0') f[i]=f[i-1]+1
else f[i]=f[i-1]-1;

if(f[i]<0) f[i]=0;重置区间左端点 
*/
int main()
{
	scanf("%s",ch);
	int n=strlen(ch);
	for(int i=0;i<n;i++)
	{
		if(ch[i]=='0') f=tmp+1,have_zero=1;
		else f=tmp-1;
		if(f<0) f=0;tmp=f;
		ans=max(ans,f);
	}
	printf("%d",have_zero==0?-1:ans);
	Mi manchi;
}
```

---

## 作者：YZL11111 (赞：1)

# 史上最短题解

## 话不多说，直接上代码

```cpp
#include <cstdio>
int main()
{
	char c;
	int sum = 0, ans = 0;  //sum记录当前0与1个数的差值
	while (~scanf("%c", &c))  //读入，一直处理到文件尾
	{
		c == '0' ? ++sum : --sum;  //该位为0则++sum，否则--sum
		if (sum < 0) { sum = 0; continue; }  //当sum<0时将sum重置为0，因为包含此区间的区间不可能为最大（可以用反证法，如果包含那么一定会答案加上一个负数，那么肯定不是最大）
		ans = ans > sum ? ans : sum;  //更新最优解，保证答案最小
	}
	printf("%d\n", ans == 0 ? -1 : ans);  //注意如果ans为0说明串中没有0，那么输出-1
	return 0;
}
```
# 时间复杂度O(n)，空间复杂度O(1)

---

## 作者：Smallbasic (赞：1)

## 这题pjT1难度？？？？？

比赛时还一脸懵逼。。。

把0看成1，1看成-1。

显然区间内0的个数和1的个数转化成了这个区间的和。

然而很智障的没想到它是最大子段和而用了另一种方法。

要求一段区间他的和最大，显然暴力$\Theta(n^3)$。这时候套上惯用的前缀和优化$\Theta(n^2)$

设前缀和数组为sum，这一段区间$[l,r]$的和表示为$sum[r]-sum[l-1]$。在右端点$r$固定的情况下，只要$sum[l-1]$越小，区间和就越大。

显然有方法是枚举右端点，线段树维护最小值，这样复杂度$\Theta(n\log n)$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int sum[100005], n = 0, ans = -1, ls = 0x3f3f3f3f;
bool a[100005];

inline int max_(int a, int b) {
	return a > b ? a : b;
}

inline int min_(int a, int b) {
	return a < b ? a : b;
}

struct node {
	int l, r, mn;
	node *left, *right;
	
	inline void update() {
		mn = min_(left -> mn, right -> mn);
	}
	
	inline void build(int l, int r) {
		this -> l = l; this -> r = r;
		if (l >= r) mn = sum[l];
		else {
			left = new node; left -> build(l, l + r >> 1);
			right = new node; right -> build((l + r >> 1) + 1, r);
			this -> update();
		} 
	}
	
	inline int query(int l, int r) {
		if (r < l) return 0;
		if (this -> l >= l && this -> r <= r) return mn;
		int ret = 0x3f3f3f3f;
		if (left != NULL && left -> r >= l) ret = min_(ret, left -> query(l, r));
		if (right != NULL && left -> r < r) ret = min_(ret, right -> query(l, r));
		return ret;
	}
};

int main() {
	char ch = getchar();
	while (isdigit(ch)) { a[++n] = ch - '0'; ch = getchar(); }
	sum[0] = 0;
	for (register int i = 1; i <= n; ++i) {
		if (a[i]) sum[i] = sum[i - 1] - 1;
		else sum[i] = sum[i - 1] + 1;
	} node *root = new node; root -> build(1, n);
	for (register int i = 1; i <= n; ++i) ans = max_(ans, sum[i] - min_(0, root -> query(1, i - 1)));
	if (ans) printf("%d", ans);
	else puts("-1");
	return 0;
}
```


---

## 作者：K2sen (赞：1)

## P5650
### 题意：
给你一个零一串，然后让你找一个连续的字串，求这个字串内的0的个数减去1的个数最大.

### 小思路:
我们将0看做1，然后将1看做-1，然后求一下前缀和.

求前缀和的时候我们将当前这个位置的前缀和如果为负数，那么我们就将他赋成0
因为如果是负数那么他对后边的贡献就是负数，比零都要小，所以我们赋值成0，

然后我们把每一段的前缀和与ans去一个max，最后的时候输出ans就好了

需要注意的是，题目中要求字串是非空的，我们就必须要选择一个字串

因为如果都是1的话，那么我们不得不选一个，直接输出-1就好

##### code
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define N 100010
#define M 1010

using namespace std;
int n, num[N];
char ch[N];

int main() {
	gets(ch);
	int len = strlen(ch);
	for (int i = 0; i < len; i++) 
		if (ch[i] == '1') num[i + 1] = -1;
		else num[i + 1] = 1;
	int ans = -100000;
	for (int i = 1; i <= len; i++) {
		num[i] += num[i - 1];
		if (num[i] < 0) num[i] = 0;
		ans = max(ans, num[i]);
	}
	if (ans == 0) puts("-1");
	else cout << ans;
}
```

---

## 作者：Ludo (赞：1)

## $Part$ $I.$ 题意简述

找出字串的所有区间（非空）中0的个数减1的个数的最大值

## $Part$ $II.$ 思考细节

算法一：考虑$20pts$做法

此时枚举时间复杂度是O(n^3)

每次**枚举S串的头位置和尾位置，然后统计$0$和$1$的个数**。

算法二：考虑$60pts$做法

目前我们可以**优化$0$和$1$的个数统计**。

运用前缀和，我们可以用$O(n)$的预处理达成$O(1)$的查询

算法二代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char s[1000001];
int n,sum1[1000001],sum2[1000001],mx;
int main(void)
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for (int i=1;i<=n;i++)
	{
		sum1[i]=sum1[i-1];sum2[i]=sum2[i-1];
		sum1[i]+=(s[i]=='0')?1:0;
		sum2[i]+=(s[i]=='1')?1:0;
		//cout<<sum1[i]<<' '<<sum2[i]<<endl;
	}
	for (int i=1;i<n;i++)
	{
		for (int j=i;j<=n;j++)
		{
			mx=max(mx,(sum1[j]-sum1[i-1])-(sum2[j]-sum2[i-1]));
		}
	}
	cout<<mx;
}
```

算法三：模型转化

我们会发现，如果$T_i$是$1$，那么对答案贡献是$-1$，如果$T_i$是$0$的话，对答案贡献是$1$。

如果把$T$中的$1$转为$-1$，$T$中的$0$转为$1$，那么这个问题就转化为一个**最大子段和**问题了。

贪心求解最大子段和问题：用一个$sum$表示前缀和，一直累计。如果$sum<0$，那么肯定不会比空序列优，所以弃掉，把$sum$置为$0$。

算法三代码：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
using namespace std;
char s[10000001];
int sum,n,mx;
int main(void)
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++)
	{
		if (s[i]=='1')
		{
			sum--;
			if (sum<0) sum=0;
		}
		else sum++;
		mx=max(mx,sum);
	}
	cout<<mx;
}
```

## $Part$ $III.$ 史诗巨坑

要记住，**取出来的子串非空**。考虑这样一个串$111$，没有$0$，可是一定要取到串里面的元素，那最小就得是$0-1=-1$了。


---

## 作者：xht (赞：0)

前缀和 + 贪心。

注意「非空子串」。

```cpp
const int N = 1e5 + 7;
int n, ans = -1;
char s[N];

int main() {
	rds(s, n);
	for (int i = 1, o = 0, k = 0; i <= n; i++) {
		k += (s[i] == '0' ? 1 : -1);
		ans = Max(ans, k - o);
		o = Min(o, k);
	}
	print(ans);
	return 0;
}
```

---

## 作者：HohleFeuerwerke (赞：0)

抢到沙发咯qwq

### 前置知识：dp或可称其为贪心

#### Solution1

神奇骗分：

算：最长连续的'0'序列有多长，如果没有'0'输出-1

```cpp
#include<bits/stdc++.h>
using namespace std;
string str;
int ans,cur;
bool flag=false;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>str;
	for(int i=0;i<str.size();i++){
		if(str[i]=='0'){
			flag=true;cur++;
		}
		if(str[i]=='1'){
			ans=max(ans,cur);cur=0;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

10分，由于没有正确性，不加以叙述

----

#### Solution2
pj组强大的前缀和！

```cpp
#include<bits/stdc++.h>
#define MAXN 1005//再大，也要超时，干脆只要1005
using namespace std;
string str;
int sum[MAXN];
int ans;
int main(){
	ios::sync_with_stdio(false);
	cout.tie(0);cin.tie(0);
	cin>>str;//读入S
	if(str[0]=='0')sum[0]=1;//前缀和预处理
	else sum[0]=0;//同上一行
	for(int i=1;i<str.size();i++)
		if(str[i]=='0')
			sum[i]=sum[i-1]+1;//如果是0，前缀和++
		else//否则
			sum[i]=sum[i-1]-1;//前缀和--
	for(int l=0;l<str.size();l++)
		for(int r=l;r<str.size();r++)
			ans=max(ans,sum[r]-sum[l]);//暴力比较
	cout<<ans<<endl;//输出结果
	return 0;
}
```
有40pts。也是一个比较好的分数了。

---

#### Solution3
dp/奇奇怪怪的贪心

其实有点像求最大字串和。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#define MAXN 100005
using namespace std;
string str;
int ans;
int dp[MAXN];
bool flag=false;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>str;//读入
	for(int i=0;i<str.size();i++){
		if(str[i]=='0'){
			flag=true;//标记有0
			dp[i]+=max(dp[i-1],0)+1;//当前下标的前一项对dp[i]有正贡献，则为dp[i-1]，如果没有 另起炉灶
		}
		if(str[i]=='1'){
			dp[i]=dp[i-1]-1;//当前下标为前一项--，没有其他可能性
		}
		ans=max(dp[i],ans);//比较结果
	}
	if(!flag)cout<<-1<<endl;//没有0 输出-1
	else cout<<ans<<endl;//输出答案
	return 0;
}
```

---

## 作者：qsmoonzh (赞：0)

简单DP

设f[i]表示 选 以第i个字符结尾的非空连续子串 的值 的最大值

那么对于第i个字符，可以跟前面的字符共同组成子串，也可自己单独成为一个子串，取max即可，然后更新答案

第i个字符为'0'时，它的值为1，第i个字符为'1'时，它的值为-1

然后注意选取的子串非空，故初始化ans=-1，如果初始化ans=0，那么WA成90

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

int n,f[100005],ans;
char c[100005];
int main() {
	scanf("%s",c);
	n=strlen(c);
	ans=-1;
	for(int i=1;i<=n;i++) {
		if(c[i-1]=='0') f[i]=max(f[i-1]+1,1);
		else f[i]=max(f[i-1]-1,-1);
		ans=max(ans,f[i]);
	}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：HYSK_残雪 (赞：0)


此题可以打DP

因为求的是0的个数减1的个数，所以可以把'0'当作1，'1'当作-1

这样子段的和就是个数相减的差

然后套最大子段和模板即可

P.S.:因为题目要求取非空子串，so如果原序列全是'1'，答案为-1.

因此ans初值要赋成-1

代码：

```
#include <bits/stdc++.h>
#define re register
#define SIZE 100005
using namespace std;
string s;
int a[SIZE],dp[SIZE],ans=-1;
int main()
{
	cin>>s;
	for(re int i=0;i<s.size();++i)
		if(s[i]=='0')
			a[i+1]=1;
		else
			a[i+1]=-1;
	for(re int i=1;i<=s.size();++i)
		dp[i]=max(dp[i-1]+a[i],a[i]),ans=max(ans,dp[i]);
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Lhc_fl (赞：0)

好像没有题解，~~CSP考前我来水一法涨RP~~

这就是个入门难度的贪心题，我们设一个$ans$变量代表当前处理的字符串$0,1$数量差，遇上$0$就$+1$，遇上$1$就$-1$。若$ans$小于$0$，就舍弃之前的字符串，将$ans$变为$0$。维护一个$maxn$，使$maxn$为$ans$的最大值。$maxn$就是我们要的结果。

为什么这个算法的舍弃是正确的呢？我们设已经选择的字串为$S$，若$S$中$0,1$数量差已经小于$0$了，那么对任意一个字符串$L$，显然$S+L$的$01$数量差一定小于$L$的$01$数量差。因此我们舍弃$S$，重新计数$ans$。

注意，存在全1串的情况，由于需要选非空字串，因此我们需要对它做出一个特判。


这道题与[P1115](https://www.luogu.org/problem/P1115)极其相似，做出了P1115这道题就是双倍经验(≥w≤)



```cpp
#include <bits/stdc++.h>

using namespace std;

string s;

int main() {
    cin >> s;  //读入s
    int ans = 0, maxn = -1, flag = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '1') ans--;
        if (s[i] == '0') ans++, flag = 1;
        //处理当前ans
        if (ans < 0) ans = 0; //若ans已经小于0，舍弃当前串
        maxn = max(maxn, ans);
    }
    cout << (flag == 1 ? maxn : -1); //特判。特判的时候注意三目运算符的优先级。
    return 0; //return 0是好习惯ww
}
```


---

## 作者：Eason_AC (赞：0)

## Update
- $\texttt{2020.10.15}$ 修改了格式，并删除了 10 分，80 分的代码以及其他的一些废话，增加了笔者现在的题解格式中的 Content 部分。

## Content
给出一个长度为 $n$ 的 $0/1$ 串，试求出所有子串中 $0$ 的个数减去 $1$ 的个数的最大值。

**数据范围：$1\leqslant n\leqslant 10^5$。**
## Solution
原来做此题的过程已迁移到[这篇文章](https://www.luogu.com.cn/blog/EasonBlog1/About-the-way-I-do-P5650)上来，欢迎前往。

这里直接总结这道题目的做法：

用字符串输入完以后，处理整体的一段，并将它的贡献存储（比如样例就可以分成 $0,1111,00,1,0,1$ 这六段，不难想出 $0$ 对于最大值的贡献是 $1$，$1$ 对于最大值的贡献是 $-1$，所以这六段根据它的贡献就变成了 $1,-4,2,-1,1,-1$）。（注意！如果字串全是 $1$ 要特判直接输出 $-1$！）  

利用前缀和存储前 $i$ 段的贡献。然后设总共的段数为 $cnt$，每一段的贡献是 $w[i]$，然后最终的答案就是 $\max\begin{Bmatrix}w[r]-w[l-1]\end{Bmatrix}$，其中 $l\in[1,cnt],r\in[l,cnt]$。

## Q&A

$\texttt{Q1:}$ 贡献是什么意思？  
$\texttt{A1:}$ 对于这道题目来说，贡献就是对于这个 $0$ 的个数减 $1$ 的个数得到的最大值，$0/1$ 在起的作用，通俗一点讲，$0$ 是对于最大值有贡献的，$1$ 对于这个最大值帮了倒忙。不难想出，$0$ 的贡献是 $1$，$1$ 的贡献是 $-1$。

$\texttt{Q2:}$ 为什么字串都是零的时候就要输出$-1$呢？  
$\texttt{A2:}$ 仔细看题，不难发现有一段说道：选出一个**非空子串**，而当字串全是 $1$ 时，无论如何都要选出一个来，所以就只选一个 $1$ 出来，答案就是$-1$。

## Code
$\color{yellow}\text{60}\color{Black}\text{ pts}$（原谅我写了个 $\texttt{DFS}$）：

```cpp
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

string s;
int flag = 1, ans, len;

void dfs(int x, int sum) {
	if(x > len)	return;
	ans = max(ans, sum);
	dfs(x + 1, sum + (s[x] == '0' ? 1 : -1));
}

int main() {
	cin >> s;
	for(int i = 0; i < s.length(); ++i)
		if(s[i] == '0')	flag = 0;
	if(flag) {
		printf("-1");
		return 0;
	}
	len = s.length();
	for(int i = 0; i < len; ++i)
		dfs(i, 0); 
	printf("%d", ans);
	return 0;
}
```

$\color{LimeGreen}\text{100}\color{Black}\text{ pts}$：

```cpp
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

string s;
int flag = 1, ans, len, part[100007], cnt, sum[100007];

int main() {
	cin >> s;
	for(int i = 0; i < s.length(); ++i)
		if(s[i] == '0')	flag = 0;
	if(flag) {
		printf("-1");
		return 0;
	}
	for(int i = 0; i < s.length(); ++i) {
		if(i == 0)	part[++cnt] += (s[i] - '0' == 0 ? 1 : -1);
		else {
			if(s[i] != s[i - 1])	part[++cnt] += (s[i] - '0' == 0 ? 1 : -1);
			else	part[cnt] += (s[i] - '0' == 0 ? 1 : -1);
		}
	}
	for(int i = 1; i <= cnt; ++i)
		sum[i] = sum[i - 1] + part[i];
	for(int i = 1; i <= cnt; ++i)
		for(int j = i; j <= cnt; ++j)
			ans = max(ans, sum[j] - sum[i - 1]);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：ST4LkRY (赞：0)

### 玄学贪心
在这个时候，使用神奇的贪心算法就可以辣！

易知，当答案最优时，区间的起点肯定是一个0

那么碰到1就可以跳过了

又：易知当该区间的答案小于等于0时绝对不可能是最优解，因为既然你的答案都小于等于0了，我为什么不只选你开头的0？

想到这一步的时候，我们可以写两重循环，枚举区间起点和终点，用anst记录当前枚举的区间的答案，然后动态更新ans，80pts，get！

然后考虑100分做法

我们发现，对于我们枚举的区间，只要anst还大于等于0，那么这个答案必然会包括区间包含的所有点的最佳答案

#### 证明：

众所周知，当我们以某一点为起点枚举终点时，我们的anst会初始化为0

但是如果该点由前面的某一个起点枚举而来，它的初始的anst一定是大于0的，因为一旦anst小于等于0，我们就会break，不再以那个点为起点进行枚举。

#### 得证

所以，我们使用一个vis数组记录该店是否已经被枚举过即可

这就是一个大概是O(n)的做法了，一共用时33ms

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
char x[1000001];
int ans,vis[2100001];
inline int max(int x,int y)
{
	return x>y?x:y;
}
int main()
{
	scanf("%s",&x);
	for(register int i=0;i<strlen(x);i=-~i)
	{
		if(x[i]=='1'||vis[i]) continue;//区间的起点肯定不是1
		else{
			int anst=0;
			for(register int j=i;j<strlen(x);j=-~j)
			{
				if(x[j]=='1') --anst;
				else ++anst;	
				if(anst<=0) break;
				vis[j]=1;
				ans=max(ans,anst);
			}
		}
	}
	if(ans==0) printf("-1");
	else printf("%d",ans);
	return 0;
}

---

## 作者：Alarm5854 (赞：0)

这道题目数据有一点水，我用了一个$O(n^2)$的算法竟然过了，最慢的点700+ms，不过不是单纯的$O(n^2)$，是有优化的。$O(nlogn)$的算法我也不会(我太弱了)，我只能发一个$O(n^2)$的题解(不要加强数据)。
### 做法：
统计连续的0和1的个数，并将1的个数变成负数，再求前缀和，看一下哪个前缀和最大，注意特判全0或全1的情况，第一次我被坑了，只有80分。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,pos,temp,a[100001];
string s;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>s;
	for(int i=0;i<=s.length();++i){
		if(i==s.length()){//如果全是1，直接输出-1(只选一个1)
			printf("-1");
			return 0;
		}
		if(s[i]=='0') break;
	}
	if(s[0]=='0') a[pos=1]=1;
	else a[pos=2]=1;//规定下标为奇数时是非负数，偶数时为负数，如果第一个是1，a[1]直接跳过
	for(int i=1;i<s.length();++i){
		if(s[i]!=s[i-1]) ++a[++pos];
		else ++a[pos];
	}//统计连续的0和1的数量
	for(int i=2;i<=pos;i+=2)
		a[i]=-a[i];//将偶数下标的数变为负数
	for(int i=1;i<=pos;++i)
		a[i]+=a[i-1];//前缀和
	for(int i=0;i<=pos;++i)//注意i从0开始
		for(int j=i;j<=pos;++j)
			ans=max(ans,a[j]-a[i]);//答案取最大值
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Erusel (赞：0)

考虑把串 $S$ 中的字符 $0$ 视作权值 $1$

把字符 $1$ 视作权值 $-1$

容易发现，现在就是要求这个权值数列的最大子段和

$O(n)$ dp 一遍就好了，注意题目要求非空，因此再整个串都是 字符 $1$ 的情况下，即权值都是 $-1$，答案为$-1$

**Code:**

```
#include<bits/stdc++.h>

#define N 100005

using namespace std;

int n;
char s[N];
int a[N];
int ans,sum;	

int main() 
{
	scanf("%s",s+1);n=strlen(s+1);int flg=0;
	for(int i=1;i<=n;i++)if(s[i]=='0')a[i]=1;else a[i]=-1;
	for(int i=1;i<=n;i++)if(a[i]==1)flg=1;
	if(!flg){cout<<-1<<endl;return 0;}
	for(int i=1;i<=n;i++)
	{
		sum=max(sum+a[i],a[i]);
		ans=max(ans,sum);
	}//最大子段和
	cout<<ans<<endl;


	return 0;
}

```


---

## 作者：gyh20 (赞：0)

本题可以用前缀和，只需要求出每个前缀和减去之前最小的即可。

前缀和则用来储存贡献，0为1，1为-1

注意考虑选到空串的情况

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100002]; 
int f[100002],n,mn,ans;
int main(){
	scanf("%s",s);
	n=strlen(s)-1;
	if(s[0]=='0')f[0]=1;
	else f[0]=-1;
	ans=max(ans,f[0]);
	mn=min(mn,f[0]);
	for(int i=1;i<=n;++i){
		if(s[i]=='1')f[i]=f[i-1]-1;
		else f[i]=f[i-1]+1;
		ans=max(ans,f[i]-mn);
		mn=min(mn,f[i]);
	}
	if(ans==0)puts("-1");
	else
	cout<<ans;
}
```


---

## 作者：无意识躺枪人 (赞：0)

看到题的第一眼还想写dp……

后来发现是一个很简单的前缀和

因为要求的是0的个数-1的个数

所以我们可以把0看做1,1看做-1（指贡献）

每次往后扫描的时候记录一下当前的最小前缀和和当前前缀和

如果now-min比ans更优，就可以更新

复杂度$\Theta(n)$

tips：有一个坑点，因为题目要求非空区间，所以如果全是1的话答案为-1 qwq

```cpp
#include<bits/stdc++.h>
using namespace std;

int now;
int mmin,ans;
bool flag;
char s[100005];

int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1);
	for(register int i=1;i<=n;++i)
	{
		if(s[i]=='0') flag=1,now++;
		else now--;
		mmin=min(mmin,now);
		ans=max(ans,now-mmin);
	}
	if(!flag) puts("-1");
	else printf("%d\n",ans);
	return 0;
}
```

---

## 作者：。。11 (赞：0)

### 蒟蒻一枚，不才，讲得不好请见谅

~~这道题实际上很简单~~（虽然我没听懂直播）

# 主要思想：贪心+特判

特判 ：当给出的字符串全为1时，输出-1（第4个测试点）

贪心：当给出的字符串有0时，输出最小为1
#### 即 当sum总和<=0时，跳过

上代码
```c
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

string s;
int a[100005];
int main() {
    int len, sum = 0, maxx = 0, num = 0;//len指s长度，num用于特判，maxx用于保存最大数
    cin >> s;
    len = s.length();
    for (int i = 0; i <= len - 1; i++) {
        a[len - i] = s[i] - '0';
        if (a[len - i] == 1)
            num++;
    }
    if (num == len) {
        printf("-1");
        return 0;
    }//特判
    for (int i = 0; i <= len - 1; i++) {
        if (a[i] == 0)
            sum++;
        else
            sum--;
        if (sum <= 0) {
            sum = 0;
            continue;
        }//如果小于0，跳过，无需比较
        maxx = max(maxx, sum);
    }//贪心
    printf("%d", maxx);
    return 0;
}
```


---

## 作者：Crab_Dave (赞：0)

**字符串贪心**

直接看代码吧qwq
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;//头文件

char s[100005];
int n,l[100005],cnt,f,now,ans,sum;

int main()
{
	gets(s+1);
	n=strlen(s+1);
   f=s[1]-'0';//f表示第一位是0还是1
	for(register int i=1;i<=n;i++)
		if(s[i]==s[i-1])l[cnt]++;//相当于把01串压缩为长度存储
		else l[++cnt]=1;
	if(f)now=2;//从第一段白色开始
	else now=1;
	for(;now<=cnt;now++)
	{
		if((now&1)&&!f||!(now&1)&&f)
        sum+=l[now],ans=max(ans,sum);//如果当前段为白色，吃掉qwq
		else sum-=l[now];//否则也吃掉qwq（反正前面存了档qwq）
		if(sum<0)sum=0;//如果吃不下了就只能删档重来了qwq
	}
	printf("%d\n",ans==0?-1:ans);//输出-1或答案
	return 0;//结束了罪恶的一生
}
```
求资瓷qwq

---

## 作者：Pengsibo (赞：0)

[题目传送门](https://www.luogu.org/problem/P5650)

老实说，这道题并没有太大的难度

看到的第一眼我想，一个连续子串找长度，很像尺取法

又看了一下发现不对，因为无法判断尺取结束的条件

数据范围否定了DP

**所以贪心**

贪心方式如下：

从左往右扫，如果扫到的是0，那计数器++

如果扫到1，那先更新ans，再计数器--

一旦计数器减到0一下就不减了（肯定就不会取啦）

最后扫完了再统计一次答案（如果序列后面全是0就没有更新答案了，需要再更新一次）

有一个比较坑的地方，子串T必须非空

所以还需要一个flag来判断是否有0出现过

如果没有（S全是1）则输出-1

```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

char x[1000002];	//记录S
int a,b,l;			//其实b没有什么用，a是计数器,l是长度
int ans=-1;			//统计答案
int flag;			//标记是否有1

int main()
{
	scanf("%s",x+1);
	l=strlen(x+1);
	
	a=0,b=0;
	
	for(register int i=1;i<=l;i++)
	{
		if(x[i]=='0') a++,flag=1;
		if(x[i]=='1') ans=max(a,ans),a--;
		if(a<=0) a=0;	//如上方
	}
	
	ans=max(ans,a);		//再次更新
	if(flag==0) puts("-1");	//全1输-1
	else printf("%d",ans);
	
	return 0;
}
```


---

## 作者：flash666 (赞：0)

题目是【基础字符串练习题】，然而，这跟字符串有任何的关系吗？

其实此题就是一个最大子段和 详见[P1115](https://www.luogu.org/problem/P1115)

因为要求'0'的个数-'1'的个数最大值，所以对于每一个s[i]，若s[i]=1，即令a[i]=-1；若s[i]=0，即令a[i]=1，然后跑一遍最大子段和即可

那么，如何求a数组中的最大子段和呢？  

流程  

1 对于每一个 $\color{red}{i}$，设结尾为 $\color{red}{i-1}$ 的最大子段和为 $\color{b}{f(i-1)}$；

2 若 $\color{b}{f(i-1)+a[i]<0}$，则还不如前面的都不取，直接从  $\color{red}{i+1}$及以后开始取,所以将$\color{b}{f(i)}$归零，即$\color{b}{f(i)=0}$；

3 若 $\color{b}{f(i-1)+a[i]>=0}$，则$\color{b}{f(i)=a[i]+f(i-1)}$

4 若$\color{b}{f(i)>max}$，则$\color{b}{max=f(i)}$

为了节省时间与空间，所以这里的$\color{b}{f}$数组用一个t表示，而a数组用一个k表示

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);//加快读入速度
    long long n,m=-10001,t=0,k;
    string s;
    cin>>s;
    n=s.size();
    for(int i=0;i<n;i++)//注意下标从0开始
    {
        if(s[i]=='1') k=-1;//用k表示a数组，若s[i]=1，即令a[i]=-1；若s[i]=0，即令a[i]=1
        else k=1;
        m=max(m,k+t);//更新最大值
        if(k+t<0) t=0;
        else t+=k;
    }
    cout<<m;
    return 0;
}
```


---

## 作者：big_news (赞：0)

考虑我们要求的答案具有什么特殊的性质。

不妨设$f(l,r)$表示在子串$[l,r]$内，“0的个数-1的个数”的值。

不难发现$f()$是满足前缀和性质的，即我们设对所有的$i$，有$s_i$表示$f(1,i)$，则对任意子串$[l,r]$，有$f(l,r)=s_r - s_{l-1}$。

考虑对于每一个点$r$，我们假定它为区间的右端点，则问题转化为要在前面选一个断点$l$，使得$f(l,r)$取最大值。因$f(l,r)=s_r-s_{l-1}$，其中$s_r$固定不能改变，则问题转化为最小化$s_{l-1}$。这个东西显然可以维护一下，那么问题解决了，复杂度$O(n)$。

最后还有一个例外：整个字符串全是'1'。题目要求我们不能选择空串，因此此时答案为$-1$，特判即可。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;

const int CN = 1e5+5;
const int INF = 0x3f3f3f3f;

char ch[CN]; int n,sum[CN];

bool ck() {for(int i=0;i<n;i++) if(ch[i] == '0') return false; return true;}

int main()
{
    //freopen("a.in", "r", stdin);
    
    cin>>ch; n = strlen(ch);

    if(ck()) {printf("-1"); return 0;}

    sum[0] = (ch[0] == '0') ? 1 : 0;
    for(int i=1;i<n;i++) sum[i] = sum[i - 1] + (ch[i] == '0' ? 1 : -1);
    
    int mn = 0,ans = sum[0];
    for(int i=1;i<n;i++){
        ans = max(ans, sum[i] - mn);
        mn = min(mn, sum[i]);
    }

    printf("%d",ans);

    return 0;
}
```

---


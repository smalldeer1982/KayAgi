# [EER1] 苏联人

## 题目背景

~~题目名称是吸引你点进来的。~~

这是一道正常的题，和苏联没有任何关系。

## 题目描述

你在打 EE Round 1，发现第一题非常无聊。于是你不打了，去下国际象棋了。

结果你发现，由于神秘力量的影响，你的棋子只剩下若干黑色的战车，若干黑色的主教和一只白色的国王了。

由于你很无聊，所以你把一些黑色棋子放在了 $8\times 8$ 的棋盘上。

由于你很无聊，所以你想知道，国王放在哪些格子是安全的。换句话说，有哪些格子不会被战车和主教攻击到。当然，**国王不能放在已经有棋子的地方**。

为了防止你无聊透顶而不知道国际象棋的规则，这里给出以下提示（如果你知道规则那么可以跳过）：

国际象棋中，战车可以横向、竖向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/5symt5td.png)

如图，黄色的格子为战车能走到（攻击到）的格子。

国际象棋中，主教可以斜向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/skmw1njm.png)

如图，黄色的格子为主教能走到（攻击到）的格子。

简单来说，如果当前位置到目标位置的**直线**上存在其他棋子，则可以称为“越过了其他棋子”。

如果目标位置是对方的棋子，那么移动到目标位置后，对方的棋子会被吃掉。

更进一步地，你要找的所有位置，必须满足没有黑色棋子能一步走到。

---

如果你还是没有读懂，可以结合样例进行理解。

## 说明/提示

对于 $100\%$ 的数据，保证只会出现 `.`，`R`，`B` 三种字符。

本题共有 $4$ 个子任务，每个子任务的限制如下：

子任务 $1$（$10$ 分）：保证只会出现 `.`。

子任务 $2$（$20$ 分）：保证只会出现一个 `R` 或一个 `B`（不同时出现）。

子任务 $3$（$30$ 分）：保证只有一个 `.`。

子任务 $4$（$40$ 分）：没有特殊限制。

## 样例 #1

### 输入

```
........
........
........
..B..R..
........
........
........
........
```

### 输出

```
11111011
01110011
10101011
11000000
10101011
01110011
11111011
11111001
```

# 题解

## 作者：幻之陨梦 (赞：38)

这道题是一道非常良心的签到题~~但我却错了好几次(雾~~

$Solution:$

这道题有一个坑点，就是你不能一边读入一边就处理了，我就栽在了这个坑里。处理战车和主教需要用到三重循环，前两重遍历横纵坐标，第三重遍历战车或主教能攻击到的位置，战车和主教每个都用四个单重循环来遍历位置，具体内容参见代码。

$ACcode:$
```cpp
//#include<bits/stdc++.h>//万能头文件
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;//标准数据库
char ch[8][8];
bool ans[8][8];
int main()
{
    for(int i=0;i<8;i++) scanf("%s",ch[i]);//现将整个棋盘输入进去
    for(int i=0;i<8;i++)//遍历8行
    {
        for(int j=0;j<8;j++)//遍历8列
        {
            if(ch[i][j]=='R')//如果是战车
            {
                ans[i][j]=1;//先将自己站的位置标1
                for(int k=i-1;k>=0 && ch[k][j]=='.';k--) ans[k][j]=1;//这个战车的上方不能放国王，所以全都设为1
                for(int k=i+1;k<8 && ch[k][j]=='.';k++) ans[k][j]=1;//这个战车的下方也不能放国王，所以也全都设成1
                for(int k=j-1;k>=0 && ch[i][k]=='.';k--) ans[i][k]=1;//同理这个战车的z左边也不能放国王
                for(int k=j+1;k<8 && ch[i][k]=='.';k++) ans[i][k]=1;//同理这个战车的右边也不能放国王
            }
            else if(ch[i][j]=='B')//如果是主教
            {
                ans[i][j]=1;//先将自己的位置标1
                for(int k=i-1,l=j-1;k>=0 && l>=0 && ch[k][l]=='.';k--,l--) ans[k][l]=1;//左上方不能放国王
                for(int k=i+1,l=j+1;k<8 && l<8 && ch[k][l]=='.';k++,l++) ans[k][l]=1;//右下方也不能放国王
                for(int k=i-1,l=j+1;k>=0 && l<8 && ch[k][l]=='.';k--,l++) ans[k][l]=1;//右上方也不能放国王
                for(int k=i+1,l=j-1;k<8 && l>=0 && ch[k][l]=='.';k++,l--) ans[k][l]=1;//左下方也不能放国王
            }
        }
    }
    for(int i=0;i<8;i++)
    {
        for(int j=0;j<8;j++) printf("%d",!ans[i][j]);//因为上面不行的地方全取的是1，所以输出时取反即可
        puts("");
    }
    return 0;
}
```
**记得留赞呦，Thanks♪(･ω･)ﾉ**

---

## 作者：MZY666 (赞：20)

[原题传送门](https://www.luogu.com.cn/problem/P6194)。[在我的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-p6194)。

### 【目录】

- 目录
- 题意概括
- 代码实现

### 【题意概括】

给定一个 $8\times8$ 的棋盘，上面放上一些 $R$ 类棋 和 $B$ 类棋。

$R$ 类棋的攻击范围见下图的标黄区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/5symt5td.png)

$B$ 类棋的攻击范围见下图的标黄区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/skmw1njm.png)

应该懂了把？但是，如果这两个棋要攻击这些区域，这些区域**必须**没有其它棋在 攻击目标处 或 攻击目标的路上（即不能跨过一个棋）。

现在要求输出整个棋盘，用 $1$ 表示这个地方不会被攻击，$0$ 表示这个地方会被攻击。

还是一道较简单的模拟题吧。上代码（有注释）：

### 【代码实现】

```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;
#define ll long long//个人习惯，其实int就行了
char a[10][10];
bool p[10][10];//是否可以放。定义在外面，默认值为0，程序中就用0表示可以放棋子，这样方便
int main(){
	ll i,j,k;//先定义好。i,j,k均是是循环变量
	for(i=1;i<=8;i++)
		for(j=1;j<=8;j++){
			cin>>a[i][j];//输入
			if(a[i][j]!='.')p[i][j]=true;
			//这里如果有棋子那就肯定不能放，将true(值为1)存好
		}
	for(i=1;i<=8;i++)
		for(j=1;j<=8;j++){
			if(a[i][j]=='.')continue;
			if(a[i][j]=='B'){
				for(k=1;i-k&&j-k;k++){
					if(a[i-k][j-k]!='.')break;//如果路径上有棋则提前退出
					p[i-k][j-k]=true;//标记
				}
				for(k=1;i+k<=8&&j+k<=8;k++){
					if(a[i+k][j+k]!='.')break;//如果路径上有棋则提前退出
					p[i+k][j+k]=true;//标记
				}
				for(k=1;i-k&&j+k<=8;k++){
					if(a[i-k][j+k]!='.')break;//如果路径上有棋则提前退出
					p[i-k][j+k]=true;//标记
				}
				for(k=1;i+k<=8&&j-k;k++){
					if(a[i+k][j-k]!='.')break;//如果路径上有棋则提前退出
					p[i+k][j-k]=true;//标记
				}//用这四个循环实现不能放棋子的搜索。
			}
			else{//另一种情况
				
				for(k=1;i-k;k++){
					if(a[i-k][j]!='.')break;//如果路径上有棋则提前退出
					p[i-k][j]=true;//标记
				}
				for(k=1;j-k;k++){
					if(a[i][j-k]!='.')break;//如果路径上有棋则提前退出
					p[i][j-k]=true;//标记
				}
				for(k=1;i+k<=8;k++){
					if(a[i+k][j]!='.')break;//如果路径上有棋则提前退出
					p[i+k][j]=true;//标记
				}
				for(k=1;j+k<=8;k++){
					if(a[i][j+k]!='.')break;//如果路径上有棋则提前退出
					p[i][j+k]=true;//标记
				}
			}
		}
	for(i=1;i<=8;i++){
		for(j=1;j<=8;j++)printf("%d",!p[i][j]);
		输出，因为之前是用1记的不能放，所以要把结果用"!"反过来。
		printf("\n");//记得换行，无空格
	}
  	return 0;//over
}
```

完结撒花~

P.S.如果有意见欢迎提出，但请私信（作者自愿禁言了），否则作者无法回复您。

---

## 作者：SamariumPhosphide (赞：10)

这题~~为什么叫苏联人啊~~~是一道典型的模拟题目。

直接模拟每一个战车与主教所能到达的地方，即可判断出国王能够放置在哪里。

### 战车

```cpp
void castle(int x, int y) { // (x,y)表示战车的坐标
  // 往上
  for (int i = x - 1; i >= 1; i--) {
    if (board[i][y]) break;
    notok[i][y] = true;
  }
  // 往下
  for (int i = x + 1; i <= 8; i++) {
    if (board[i][y]) break;
    notok[i][y] = true;
  }
  // 往左
  for (int i = y - 1; i >= 1; i--) {
    if (board[x][i]) break;
    notok[x][i] = true;
  }
  // 往右
  for (int i = y + 1; i <= 8; i++) {
    if (board[x][i]) break;
    notok[x][i] = true;
  }
}
```

这段代码的意义为，模拟战车珂以行动到的地方。其中第一段代码是模拟战车往上的攻击方式。如果$(x_1,y_1)$能够被$(x,y)$向上行驶攻击到，那么说明：

+ $y_1=y$

+ $x<x_1$

+ $\forall \ x_1<i<x$，$board[i][y]$没有棋子。

所以，从 $i=x-1$ 开始，每次 $i$ 减去 $1$，如果遇到了其他的棋子，那么就停止循环，并把每一个遍历过的棋盘格子全部打上标记，表示这个格子不能放国王。向下、向左、向右的操作与向上同理。

### 主教

```cpp
void bishop(int x, int y) {
  // 左上
  for (int i = 1; i <= min(x, y); i++) {
    if (board[x - i][y - i]) break;
    notok[x - i][y - i] = true;
  }
  // 右上
  for (int i = 1; i <= min(x, 8 - y); i++) {
    if (board[x - i][y + i]) break;
    notok[x - i][y + i] = true;
  }
  // 左下
  for (int i = 1; i <= min(y, 8 - x); i++) {
    if (board[x + i][y - i]) break;
    notok[x + i][y - i] = true;
  }
  // 右下
  for (int i = 1; i <= min(8 - y, 8 - x); i++) {
    if (board[x + i][y + i]) break;
    notok[x + i][y + i] = true;
  }
}
```

左上：对于格子 $(x,y)$ 左上角的格子，必然为 $(x-i,y-i)$ 的形式，那么便要求 $x-i\geq 0, y-i\ge 0$。所以$i\leq x,i\le y$。所以 $i \le \min(x,y)$。所以 $i$ 从 $1$ 开始遍历到 $\min(x,y)$，每次研究的格子便是 $(x-i,y-i)$。如果这个格子已经又棋子，那么就结束循环。否则就打上不能放置的标记。右上、右下、左下同理。

### 主程序

```cpp
#include <bits/stdc++.h>

using namespace std;

int board[10][10], ans;
bool notok[10][10];

void castle(int x, int y) {
  for (int i = x - 1; i >= 1; i--) {
    if (board[i][y]) break;
    notok[i][y] = true;
  }
  for (int i = x + 1; i <= 8; i++) {
    if (board[i][y]) break;
    notok[i][y] = true;
  }
  for (int i = y - 1; i >= 1; i--) {
    if (board[x][i]) break;
    notok[x][i] = true;
  }
  for (int i = y + 1; i <= 8; i++) {
    if (board[x][i]) break;
    notok[x][i] = true;
  }
}

void bishop(int x, int y) {
  for (int i = 1; i <= min(x, y); i++) {
    if (board[x - i][y - i]) break;
    notok[x - i][y - i] = true;
  }
  for (int i = 1; i <= min(x, 8 - y); i++) {
    if (board[x - i][y + i]) break;
    notok[x - i][y + i] = true;
  }
  for (int i = 1; i <= min(y, 8 - x); i++) {
    if (board[x + i][y - i]) break;
    notok[x + i][y - i] = true;
  }
  for (int i = 1; i <= min(8 - y, 8 - x); i++) {
    if (board[x + i][y + i]) break;
    notok[x + i][y + i] = true;
  }
}

int main() {
  for (int i = 1; i <= 8; i++) {
    for (int j = 1; j <= 8; j++) {
      char c; cin >> c;
      if (c == '.') board[i][j] = 0;
      else if (c == 'R') board[i][j] = 1, notok[i][j] = true;
      else board[i][j] = 2, notok[i][j] = true;
    }
  }
  for (int i = 1; i <= 8; i++) {
    for (int j = 1; j <= 8; j++) {
      if (board[i][j] == 1) castle(i, j);
      else if (board[i][j] == 2) bishop(i, j);
    }
  }
  for (int i = 1; i <= 8; i++) {
    for (int j = 1; j <= 8; j++) {
      if (notok[i][j] == false) {
        putchar('1');
      } else {
        putchar('0');
      }
    }
    puts("");
  }
  return 0;
}
```

首先输入棋盘，使用数字存储。如果是战车，那么设为 $1$，如果是空地，那么设为 $0$，如果是主教，那么设为 $2$。

接着遍历整个棋盘打标记，最后输出即可。

---

## 作者：Gokix (赞：5)

作为一名曾下国象的OI选手，我感到十分兴奋。

车和象的行动方法你应该了解了，车就是直着走（攻击它的上、下、左、右），象是斜着走（攻击它的左上、左下、右上、右下）。

注意棋子（不论车象）的攻击都会被另一个棋子阻挡。

![实例](https://cdn.luogu.com.cn/upload/image_hosting/jgusebki.png)

上图中位于e5的车（e5这样的坐标表示法请见棋盘最左和最下的标识），因为被位于d5的棋子阻挡，所以a5、b5、c5都不是它的攻击范围，也就是说这三个格子是安全的。

但如果上图中d5没有棋子，但在c5有个棋子，则a5、b5车照样攻击不到，但d5它却可以攻击。


------------

下面开始讲本题解法：

我用的是模拟。（有用 $\operatorname{dfs}$ 的神仙，但我觉得~~不会写~~太麻烦了）

首先记录一个二维数组 $a$ ，表示棋盘上的棋子。（输入）

另写一个二维数组 $f$ ，表示该格子是否安全。（输出）

从第一个格子开始枚举:

1. 如果当前格子上是个车，**先把当前格子改成不安全**，在用四层循环，分别将上、下、左、右的格子改成不安全。注意在更改的时候，要判断当前格子上有没有棋子，如果有，就直接**终止**循环。

```cpp
void R(long long x,long long y)
{
	long long i,j,u,v;
	f[x][y]=0;//切记先设为不安全 
	for(i=x+1;i<=8;i++)//上 
	{
		if(a[i][y]=='.')
		{
			f[i][y]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x-1;i>=1;i--)//下 
	{
		if(a[i][y]=='.')
		{
			f[i][y]=0;
		}
		else
		{
			break;
		}
	}
	for(i=y+1;i<=8;i++)//右 
	{
		if(a[x][i]=='.')
		{
			f[x][i]=0;
		}
		else
		{
			break;
		}
	}
	for(i=y-1;i>=1;i--)//左 
	{
		if(a[x][i]=='.')
		{
			f[x][i]=0;
		}
		else
		{
			break;
		}
	}
}
```


2. 如果当前格子上是个象，**先把当前格子改成不安全**，在用四层循环，分别将左上、左下、右上、右下的格子改成不安全。注意在更改的时候，先判断当前格子上有没有棋子，如果有，就直接**终止**循环，再设为不安全。

```cpp
void B(long long x,long long y)
{
	long long i,j,u,v;
	f[x][y]=0;
	for(i=x+1,j=y+1;i<=8 && j<=8;i++,j++)//右上 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x+1,j=y-1;i<=8 && j>=1;i++,j--)//右下 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x-1,j=y+1;i>=1 && j<=8;i--,j++)//左上 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x-1,j=y-1;i>=1 && j>=1;i--,j--)//左下 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
}
```


3. 如果当前格子上没有棋子，什么也不做。


------------


至此，我们就可以写出代码了：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
char a[10][10];
long long f[10][10];
void B(long long x,long long y)
{
	long long i,j,u,v;
	f[x][y]=0;
	for(i=x+1,j=y+1;i<=8 && j<=8;i++,j++)//右上 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x+1,j=y-1;i<=8 && j>=1;i++,j--)//右下 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x-1,j=y+1;i>=1 && j<=8;i--,j++)//左上 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
	for(i=x-1,j=y-1;i>=1 && j>=1;i--,j--)//左下 
	{
		if(a[i][j]=='.')
		{
			f[i][j]=0;
		}
		else
		{
			break;
		}
	}
}
void R(long long x,long long y)
{
	long long i,j,u,v;
	f[x][y]=0;//切记先设为不安全 
	for(i=x+1;i<=8;i++)//上 
	{
		if(a[i][y]=='.')
		{
			f[i][y]=0;
		}
		else
		{
			break;//别写成continue 
		}
	}
	for(i=x-1;i>=1;i--)//下 
	{
		if(a[i][y]=='.')
		{
			f[i][y]=0;
		}
		else
		{
			break;
		}
	}
	for(i=y+1;i<=8;i++)//右 
	{
		if(a[x][i]=='.')
		{
			f[x][i]=0;
		}
		else
		{
			break;
		}
	}
	for(i=y-1;i>=1;i--)//左 
	{
		if(a[x][i]=='.')
		{
			f[x][i]=0;
		}
		else
		{
			break;
		}
	}
}
int main()
{
	long long i,j,u,v;
	for(i=1;i<=8;i++)
	{
		for(j=1;j<=8;j++)
		{
			cin>>a[i][j];
			f[i][j]=1;
		}
	}
	for(i=1;i<=8;i++)
	{
		for(j=1;j<=8;j++)
		{
			if(a[i][j]=='B')
			{
				B(i,j);
			}
			else if(a[i][j]=='R')
			{
				R(i,j);
			}
		}
	}
	for(i=1;i<=8;i++)
	{
		for(j=1;j<=8;j++)
		{
			cout<<f[i][j];
		}
		cout<<endl;
	}
}
```


------------


附样例1的棋盘解释：（红色是象的进攻格子，蓝色是车的进攻格子，紫色是象和车都进攻的格子）

![#1](https://cdn.luogu.com.cn/upload/image_hosting/klo8z7nb.png)

撒花！


---

## 作者：lyc_AFO (赞：4)

一道简单的题被我搞的好复杂啊……

有两种棋子：教皇和战车。教皇是斜着走的；战车是横着或者竖着走，但是两者都**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/8ermv1b0.png)

比如，在圈的那个地方有一枚棋子，战车就不能攻击到标为x的两个点。

然后，用递归来把教皇或战车可以走到的地方遍历一遍。

注意：递归结束时一定要把原来放棋子的点还原回来，一边下一次递归。

代码如下（含注释）：

```
#include<bits/stdc++.h>
using namespace std;
char a[8][8];
int u,v;
void zc(int x,int y,int fs){//战车情况。 
	a[u][v]='1';
	if(x<0||y<0||x>7||y>7||a[x][y]=='B'||a[x][y]=='R')return;//如果有被挡住或者越界，停止递归。 
	if(fs==1){
    	a[x][y]='1';//打上标记。 
    	zc(x-1,y,fs);
	}
	if(fs==2){
		a[x][y]='1';
		zc(x+1,y,fs);
	}
	if(fs==3){
		a[x][y]='1';
		zc(x,y-1,fs);
	}
	if(fs==4){
		a[x][y]='1';
		zc(x,y+1,fs);// 上下左右四个方向递归。 
	}
}
void zj(int x,int y,int fs){//教皇情况。 
	a[u][v]='1';
	if(x<0||y<0||x>7||y>7||a[x][y]=='B'||a[x][y]=='R')return;
	if(fs==1){
    	a[x][y]='1';
    	zj(x+1,y+1,fs);
	}
	if(fs==2){
		a[x][y]='1';
		zj(x+1,y-1,fs);
	}
	if(fs==3){
		a[x][y]='1';
		zj(x-1,y-1,fs);
	}
	if(fs==4){
		a[x][y]='1';
		zj(x-1,y+1,fs);
	}
}
int main(){
for(int i=0;i<=7;i++){
	for(int j=0;j<=7;j++){
		cin>>a[i][j];
	}
}
for(int i=0;i<=7;i++){
	for(int j=0;j<=7;j++){
		if(a[i][j]=='R'){
			for(int z=1;z<=4;z++){
				u=i;v=j;//为了避免无法开始递归，记录第一个点的坐标。 
				zc(i,j,z);
				a[u][v]='R';//还原第一个点的坐标，以免遮盖。 
			}
		}
		if(a[i][j]=='B'){
			for(int z=1;z<=4;z++){
				u=i;v=j;
				zj(i,j,z);
				a[u][v]='B';//同上。 
			}	
		}
	}
}

for(int i=0;i<=7;i++){
	for(int j=0;j<=7;j++){
        if(a[i][j]=='.'){
        	cout<<"1";
		}else{
			cout<<"0";
		}
	}
	cout<<endl;
}
    return 0;
}
```
求通过qaq！

---

## 作者：Steven__Chen (赞：4)

# 开始！
老实说， 在比赛的时候，这道题把我卡了一下，具体细节我们待会再说。

这个，具体思路我直接写在以下代码的注释里吧~~~~。

```
#include<bits/stdc++.h>
using namespace std;
char a[8][8];//声明一个char数组，用来储存输入数据。
int flag[8][8];//声明一个标记数组，用于结尾的输出。
int r(int x, int y, int x2, int y2)//这个函数用于标记可以被主教一步吃掉的位置。x、y分别表示当前位置的横纵坐标，x+x2、y+y2表示下一个需要判定并标记的位置的横纵坐标。
{
    if(x==-1||y==-1||a[x][y]!='.'||x>7||y>7)//如果这个位置不在8*8的棋盘内，或者碰到了一个棋子，直接退出函数（因为棋子移动时不能越过另一个棋子）。就是“x>7||y>7”这个地方，把我卡了一下，第一次提交没考虑到。
        return 0;
    flag[x][y]=0;//标记位置。
    r(x+x2,y+y2,x2,y2);//继续判定或标记
    return 0;
}
int main()
{
    for(int i=0;i<=7;i++)//for循环输入数据并初始化flag数组。
        for(int j=0;j<=7;j++)
        {
            flag[i][j]=1;//初始化
            cin>>a[i][j];//读入数据
        }
    for(int i=0;i<=7;i++)//遍历一遍a数组
        for(int j=0;j<=7;j++)
        {
            if(a[i][j]=='.')//如果这个位置上没有棋子，直接跳过。
                continue;
            if(a[i][j]=='R')//判断这个位置上是不是战车
            {
                flag[i][j]=0;//因为有棋子的地方，不能放国王。
                for(int k=j-1;k>=0;k--)//从这里开始，就是判断和标记战车可一步到达的位置。这个循环是往左方向遍历的。
                    if(a[i][k]!='.')//如果这个位置上有棋子，就退出循环（因为棋子移动时不能越过另一个棋子）。
                        break;
                    else
                        flag[i][k]=0;//标记
                
                for(int k=j+1;k<=7;k++)//向右方向遍历
                    if(a[i][k]!='.')
                        break;
                    else
                        flag[i][k]=0;
                for(int k=i-1;k>=0;k--)//向上遍历。
                    if(a[k][j]!='.')
                        break;
                    else
                        flag[k][j]=0;
                for(int k=i+1;k<=7;k++)//向下遍历。
                    if(a[k][j]!='.')
                        break;
                    else
                        flag[k][j]=0;
            }
            else//如果这个位置上有棋子，那么它一定是战车或主教。之前判断过战车，所以这里一定是主教
            {
                flag[i][j]=0;//标记主教的位置
                r(i-1,j-1,-1,-1);//向左上遍历
                r(i-1,j+1,-1,1);//向右上遍历
                r(i+1,j-1,1,-1);//向左下遍历
                r(i+1,j+1,1,1);//向右下遍历
            }
        }
    for(int i=0;i<=7;i++)//输出flag数组
    {
        for(int j=0;j<=7;j++)
        {
            cout<<flag[i][j];
        }
        cout<<endl;//换行
    }
    return 0;
}
```

好啦，这道题目到这里就结束了
## 别走！！
我还要说一个自己在比赛时使用的小技巧。

为了排查我第一次提交时出现的错误，我在原有的程序外面套了两层for循环，表示战车的位置。

然后我运行程序，看到战车无论在棋盘上的哪个位置，程序的输出都没有问题。

然后我让这两层for循环表示成主教的位置，结果发现，主教在(0,2)上时，输出的结果就不对了，然后我就修改了上面代码的第七行，结果就AC啦！

我想告诉大家的就是这种Debug的方法。

这次真的拜拜啦！

---

## 作者：Hexarhy (赞：4)

签到题。难度为 CSP-J T1。

--------

### 解题思路

题目很清楚，模拟即可。

对于每个战车 $(i,j)$，我们可以枚举步长 $k$，然后向上下左右四个方向延伸并标记，分别为 $(i-k,j),(i+k,j),(i,j-k),(i,j+k)$。

对于每个主教 $(i,j)$，我们也可以枚举步长 $k$，然后向四个方向延伸并标记，分别为 $(i-k,j-k),(i+k,j+k),(i+k,j-k),(i-k,j+k)$。

在上述坐标中，只要遇到不是`.`或者越界，即可停止。

### 参考代码

本题无坑点，放心打。

不过在本代码中，`1`是不能放置，`0`是可以放置，因此输出要取反。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN=10;
const int N=8;//棋盘规模
char a[MAXN][MAXN];
bool ans[MAXN][MAXN];

void input(void)
{
	for(int i=1;i<=N;i++)
	 for(int j=1;j<=N;j++)
	  cin>>a[i][j];
}

void solve(void)
{
	for(int i=1;i<=N;i++)
	 for(int j=1;j<=N;j++)
	 {
	 	if(a[i][j]=='R')//战车
	 	{
        	//四个方向，枚举步长
	 		ans[i][j]=true;
	 		for(int k=1;j+k<=N && a[i][j+k]=='.';k++)
	 		 ans[i][j+k]=true;
			for(int k=1;j-k>=1 && a[i][j-k]=='.';k++)
			 ans[i][j-k]=true;
			for(int k=1;k+i<=N && a[i+k][j]=='.';k++)
			 ans[i+k][j]=true;
			for(int k=1;i-k>=1 && a[i-k][j]=='.';k++)
			 ans[i-k][j]=true;
		}
		if(a[i][j]=='B')//主教
		{
        	//同理
			ans[i][j]=true;
			for(int k=1;i-k>=1 && j-k>=1 && a[i-k][j-k]=='.';k++)
			 ans[i-k][j-k]=true;
			for(int k=1;i+k<=N && j+k<=N && a[i+k][j+k]=='.';k++)
			 ans[i+k][j+k]=true;
			for(int k=1;i+k<=N && j-k>=1 && a[i+k][j-k]=='.';k++)
			 ans[i+k][j-k]=true;
			for(int k=1;i-k>=1 && j+k<=N && a[i-k][j+k]=='.';k++)
			 ans[i-k][j+k]=true;
		}
	 }
}

void output(void)
{
	for(int i=1;i<=N;i++,cout<<endl)
	 for(int j=1;j<=N;j++)
	  cout<<int(!ans[i][j]);
}

int main()
{
	input();
	solve();
	output();
	return 0;
}
```

---

## 作者：tobie (赞：4)

这道题明显就是纯模拟题啊，直接打代码即可。

但是这道题有唯一的一个地方，就是主教和战车不能越过其它棋子，所以如果碰到了棋子那么就需要停止。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[10][10];
char map[10][10];
int x1[]={1,0,-1,0},y1[]={0,1,0,-1};
int x2[]={1,-1,-1,1},y2[]={1,-1,1,-1};//把每个方向都存储起来
int main()
{
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
	cin>>map[i][j],a[i][j]=1;//输入
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)//枚举每一个点
	{
		if(map[i][j]=='R')//如果是战车
		{
			for(int k=0;k<4;k++)//往4个方向个走一遍
			{
				int x=i,y=j;
				while(x>=1&&x<=8&&y>=1&&y<=8)
				{
					a[x][y]=0;
					x+=x1[k],y+=y1[k];
					if(map[x][y]!='.') break;//遇到其它棋子就停止
				}
			}
		}
		if(map[i][j]=='B')//如果是主教
		{
			for(int k=0;k<4;k++)
			{
				int x=i,y=j;
				while(x>=1&&x<=8&&y>=1&&y<=8)
				{
					a[x][y]=0;
					x+=x2[k],y+=y2[k];
					if(map[x][y]!='.') break;
				}
			}
		}
	}
	for(int i=1;i<=8;i++)//输出
	{
		for(int j=1;j<=8;j++)
		printf("%d",a[i][j]);
		printf("\n");
	}
   	return 0;
}
```

---

## 作者：小恐 (赞：3)

~~我一开始真的以为是苏联人mrsrz出的这道题，哈哈哈（光速逃~~

简单的枚举题，暴力枚举每个格子，如果是战车或者主教，扫一遍他控制的格子，标记一下（自己也要标记哦），如果遇到不是 . 的，说明被挡住了，停！

上个丑陋的代码：
```cpp
#include<stdio.h>
using namespace std;
char ch[10][10];//读进来的表 
bool mark[10][10];//标记是否被控制 
void R(int m,int n)//战车 
{
	int x,y;
	mark[m][n]=1;//标记自己 
	x=m,y=n;
	while(x>=1)//往上搜 
	{
		--x,mark[x][y]=1;//标记，x变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(x<=8)//往下搜 
	{
		++x,mark[x][y]=1;//标记，x变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(y>=1)//往左搜 
	{
		--y,mark[x][y]=1;//标记，y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(y<=8)//往右搜 
	{
		++y,mark[x][y]=1;//标记，y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
}
void B(int m,int n)//主教 
{
	int x,y;
	mark[m][n]=1;//标记自己 
	x=m,y=n;
	while(x>=1&&y>=1)//往左上搜
	{
		--x,--y,mark[x][y]=1;//标记，x、y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(x>=1&&y<=8)//往右上搜
	{
		--x,++y,mark[x][y]=1;//标记，x、y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(x<=8&&y>=1)//往左下搜
	{
		++x,--y,mark[x][y]=1;//标记，x、y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
	x=m,y=n;
	while(x<=8&&y<=8)//往右下搜
	{
		++x,++y,mark[x][y]=1;//标记，x、y变下一个 
		if(ch[x][y]!='.')//被挡住了 
			break;//停 
	}
}
int main()
{
	for(int i=1;i<=8;++i)
		scanf("%s",ch[i]+1);//读入 
	for(int i=1;i<=8;++i)
		for(int j=1;j<=8;++j)
		{
			if(ch[i][j]=='R')//如果是战车 
				R(i,j);//调用战车函数 
			else if(ch[i][j]=='B')//如果是主教 
				B(i,j);//调用主教函数 
		}
	for(int i=1;i<=8;++i)
	{
		for(int j=1;j<=8;++j)
		{
			if(mark[i][j])//被控制 
				printf("0");//不能放 
			else//否则 
				printf("1");//能放 
		}
		printf("\n");//换行 
	}
	return 0;
}
```
代码一定要自己敲，否则就会获得$\color{white}\colorbox{brown}{作弊者}$~~荣誉~~称号哦！

---

## 作者：lgswdn_SA (赞：3)

神·模拟题

就是分别考虑一下战车和主教的走位。每次都是向四个方向覆盖，（文中说的“珂以攻击到”，这里用覆盖到代替）然后遇到棋子就停止扩散。最后输出以下哪些没有被覆盖就行啦~

注意一个小技巧，向外覆盖的时候要注意不要直接从自己出发，因为这样你的程序可能认为自己这个棋子就是个阻碍从而不再向外覆盖


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=109; int n=8; //习惯用n 
string s[N]; bool p[N][N];
int main(){
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			p[i][j]=1; //初始化 
	for(int i=0;i<n;i++) cin>>s[i];
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(s[i][j]=='.') continue;
			else if(s[i][j]=='R'){ //战车 
				p[i][j]=0; //自己 
				int x=i-1,y=j; //防止因为碰到自己所以不能向外覆盖出去 
				for(;min(x,y)>=0;x--){ //向左边覆盖 
					if(s[x][y]!='.') break; //遇到其他棋子 
					p[x][y]=0; //覆盖 
				}
				x=i,y=j-1;
				for(;min(x,y)>=0;y--){ //向上面覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
				x=i+1,y=j;
				for(;max(x,y)<n;x++){ //向右边覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
				x=i,y=j+1;
				for(;max(x,y)<n;y++){ //向下面覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
			}
			else{ //主教 
				p[i][j]=0;
				int x=i-1,y=j-1; 
				for(;min(x,y)>=0;x--,y--){ //向左上覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
				x=i+1,y=j-1;
				for(;min(x,y)>=0;x++,y--){ //向右上覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
				x=i-1,y=j+1;
				for(;min(x,y)>=0;x--,y++){ //向左下覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
				x=i+1,y=j+1;
				for(;max(x,y)<n;x++,y++){ //向右下覆盖 
					if(s[x][y]!='.') break;
					p[x][y]=0;
				}
			}
		}
	}
	for(int i=0;i<n;i++){ //输出 
		for(int j=0;j<n;j++)
			cout<<p[i][j];
		cout<<endl;
	}
	return 0;
} 
```

---

## 作者：唐一文 (赞：2)

### 思路
对于每个战车，向上下左右四个方向扩展，走过的地方用一个数组记录，当走到一个有棋子的地方就退出循环

对于每个主教，向四个斜方向扩展，后面同上

直接模拟即可

------------

### 值得注意的地方
结果你发现，由于神秘力量的影响，你的棋子只剩下 **若干** 黑色的战车， **若干** 黑色的主教和一只白色的国王了。

~~被这个坑了好几次~~

------------

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
bool can[10][10],have[10][10];
int Rx[70],Ry[70],Bx[70],By[70];
int cntr,cntb;
int main(){
	for(register int i=0;i<8;++i){
		for(register int j=0;j<8;++j){
			register char c;
			cin>>c;
			if(c=='R'){
				Rx[cntr]=i;
				Ry[cntr]=j;
				++cntr;//记录下一个战车的位置
				can[i][j]=true;//这个地方能被攻击到
				have[i][j]=true;//这个地方有棋子
			}
			if(c=='B'){
				Bx[cntb]=i;
				By[cntb]=j;
				++cntb;//记录下一个主教的位置
				can[i][j]=true;//同上
				have[i][j]=true;//同上
			}
		}
	}
	for(register int _=0;_<cntr;++_){//枚举每一个战车
		register int rx=Rx[_],ry=Ry[_];
		for(register int i=rx-1;i>=0;--i){//向上扩展
			if(have[i][ry]){//碰到有棋子的地方就跳出循环
				break;
			}
			can[i][ry]=true;//这个地方能被攻击到
		}
		for(register int i=rx+1;i<8;++i){//向下扩展
			if(have[i][ry]){//同上
				break;
			}
			can[i][ry]=true;//同上
		}
		for(register int i=ry-1;i>=0;--i){//向左扩展
			if(have[rx][i]){//同上
				break;
			}
			can[rx][i]=true;//同上
		}
		for(register int i=ry+1;i<8;++i){//向右扩展
			if(have[rx][i]){//同上
				break;
			}
			can[rx][i]=true;//同上
		}
	}
	for(register int _=0;_<cntb;++_){//枚举每一个主教
		register int bx=Bx[_],by=By[_];
		for(register int i=bx-1;i>=0;--i){//向左下扩展
			if(have[i][by+bx-i]){//碰到有棋子的地方就跳出循环
				break;
			}
			if(by+bx-i>=8){//如果超出棋盘就跳出循环
				break;
			}
			can[i][by+bx-i]=true;//这个地方能被攻击到
		}
		for(register int i=bx-1;i>=0;--i){//向左上阔爱站
			if(have[i][by-bx+i]){//同上
				break;
			}
			if(by-bx+i<0){//同上
				break;
			}
			can[i][by-bx+i]=true;//同上
		}
		for(register int i=bx+1;i<8;++i){//向右下扩展
			if(have[i][by-bx+i]){//同上
				break;
			}
			if(by-bx+i>=8){//同上
				break;
			}
			can[i][by-bx+i]=true;//同上
		}
		for(register int i=bx+1;i<8;++i){//向右上扩展
			if(have[i][by+bx-i]){//同上
				break;
			}
			if(by+bx-i<0){//同上
				break;
			}
			can[i][by+bx-i]=true;//同上
		}
	}
	for(register int i=0;i<8;++i){
		for(register int j=0;j<8;++j){
			cout<<!can[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：2)

这道题由于常数比较小，所以暴力是可以 AC 的！

前置知识：

- 在国际象棋中，象（主教）记为 `B` ，车（城堡）记为 `R` 。同理，国王记为 `K` ，小兵记为 `P` ，皇后记为 `Q` ，马（骑士）记为 `N` 。

- [什么是国际象棋？](https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B/80888?fr=aladdin)

- [国际象棋的规则是什么样的？](https://zhidao.baidu.com/question/72073254.html)

思路：

- 读入二维数组 $a$ ，然后逐个进行判断。

- 双重循环，对于每个点的可行性进行判断。

那么，我们还是讲一下判断函数 $\operatorname{judge}$ 的原理讲一下。

- 首先判断是否是有棋子的位置，若有，返回不可行。

- 判断上下左右是否是有车（国际象棋记谱记录为 `R` ），注意，有一个比较坑的地方，即“棋子不能跳过另一个棋子”，不过在国际象棋中马（记谱即为 `N` ）是可以越过的，在这里不谈。那么只要我们在遇到车之前遇到象（骑士，就是 `B` ），那么就跳出循环。

- 判断两条斜线是否有象的存在，如果有，则跳过，同理，如果在遇到象之前遇到车，那么我们可以直接跳出循环。


那么我们来算一下循环的次数：

对于每一个点，需要判断自己的位置 $1$ 次。

对于每一个点，上下一共需要判断 $7$ 次。

对于每一个点，左右一共需要判断 $7$ 次。

对于每一个点，斜线需要判断 $14$ 次。

对于每一个点，都需要判断 $29$ 次。

国际象棋棋盘一共有 $8\times 8=64$ 个点。

那么总共需要判断 $64\times 29=1856$ 次，计算不需要几毫秒。

经过测试，这个程序的最长时间是 `#Subtack 3` 的最后一个测试点，用时仅仅 $5$ $ms$ ，所以我们可以肯定这个程序是可以 AC 这道题的。

如果你们希望看到评测记录，可以通过[这个链接](https://www.luogu.com.cn/record/31518636)了解具体的评测情况。

那么，我们可以看到 AC 程序了，当然，分不同的区域讲解：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[9][9];
```
运用了万能头文件，定义了一个 $9\times 9$ 的二维字符数组。

```cpp
inline bool judge(int x,int y){
	if(a[x][y]!='.')return 0;
	for(int i=x;i<=8;i++){
		if(a[i][y]=='R')return 0;
		if(a[i][y]=='B')break;
	}
	for(int i=x;i>0;--i){
		if(a[i][y]=='R')return 0;
		if(a[i][y]=='B')break;
	}
	for(int i=y;i<=8;i++){
		if(a[x][i]=='R')return 0;
		if(a[x][i]=='B')break;
	}
	for(int i=y;i>0;--i){
		if(a[x][i]=='R')return 0;
		if(a[x][i]=='B')break;
	}
	for(int i=x,j=y;i<=8&&j<=8;++i,++j){
		if(a[i][j]=='B')return 0;
		if(a[i][j]=='R')break;
	}
	for(int i=x,j=y;i>0&&j>0;--i,--j){
		if(a[i][j]=='B')return 0;
		if(a[i][j]=='R')break;
	}
	for(int i=x,j=y;i<=8&&j>0;++i,--j){
		if(a[i][j]=='B')return 0;
		if(a[i][j]=='R')break;
	}
	for(int i=x,j=y;i>0&&j<=8;--i,++j){
		if(a[i][j]=='B')return 0;
		if(a[i][j]=='R')break;
	}
	return 1;
}
```
判断，分别为上，下，左，右，左上，左下，右上，右下。

使用 bool 类型返回一个判断的结果。

```cpp
int main()
{
	for(register int i=1;i<=8;++i)for(register int j=1;j<=8;++j)cin>>a[i][j];
	for(register int i=1;i<=8;++i){
		for(register int j=1;j<=8;++j){
			if(judge(i,j))putchar('1');
			else putchar('0');
		}
		putchar('\n');
	}
	return 0;
}
```

读入，每个判断，如果成立输出 `1` 反之输出 `0` ，那么很容易就可以得到答案，注意换行，最后加上`return 0`是一个好习惯。

那么今天的讲解就到这里结束了，我们来细数一下我们学了什么：

- 怎么样模拟判断过程，利用循环简化代码量。

- 怎样读入一个二维数组，以及处理。

- bool 类型的判断函数是怎么样运作的。

- 国际象棋的规则和基本类型。

- 如何计算程序运行次数。

- 怎么样输出字符类型的变量。

- 循环嵌套完成一道题的基本思路。

最后，请大家点个赞吧！支持一下哦！[Blog Here!](https://www.luogu.com.cn/blog/AlanWalkerWilson/)

---

## 作者：PrincessYR✨～ (赞：2)

关于这道题，就是暴力搜，搜就玩了。

这道题看着体面和[八皇后](https://www.luogu.com.cn/problem/P1219)十分相似，但我认为这道题比八皇后简单一些。~~不扯淡了~~ 

下面开始步入正题，

首先输入，把是B的点记录一下，再把R点记录一下，方便以后搜索。

然后再从四个方向进行搜索，如果当前节点有棋子，那么直接跳过

具体讲解见代码：

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int a[75][3],num,c[75],last[9][9];
int bx[5]={0,-1,-1,1,1},by[5]={0,-1,1,1,-1};//表示斜着走的四个方向 
int rx[5]={0,-1,0,1,0},ry[5]={0,0,1,0,-1};//表示横竖着走的四个方向 
char b;
void dfs(int x,int y,int jx,int jy)
{
	if(last[x+jx][y+jy]==1||x+jx<1||x+jx>8||y+jy<1||y+jy>8)//如果有棋子挡着路，那么就不可以搜索，直接跳出 
	{
		return ;
	}
	else //否则标记为访问过 
	{
		last[x+jx][y+jy]=2;//2表示为后期访问的，1表示为这个点有棋子。只有当这个点有棋子的时候才会跳过 
		dfs(x+jx,y+jy,jx,jy);
	}
}
int main()
{
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			cin>>b;
			if(b=='B')
			{
				a[++num][1]=i;//记录棋子的横坐标 
				a[num][2]=j;//记录棋子的纵坐标 
				c[num]=1;//1表示B斜着走 
				last[i][j]=1;//标记last[i][j]这个点已经有棋子，在以后进行判断是否隔着棋子 
			}
			if(b=='R')
			{
				a[++num][1]=i;
				a[num][2]=j;
				c[num]=2;//2表示R横竖着走 
				last[i][j]=1;//同上 
			}
		}
	}
	for(int i=1;i<=num;i++)
	{
		if(c[i]==1)
		{
			for(int j=1;j<=4;j++)//不管是B还是R都分为4个方向 
			{
				dfs(a[i][1],a[i][2],bx[j],by[j]);//如果是斜着走就用bx,by 
			}
		}
		if(c[i]==2)
		{
			for(int j=1;j<=4;j++)
			{
				dfs(a[i][1],a[i][2],rx[j],ry[j]);//如果是横竖着走就用rx,ry 
			}
		}
	}
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			if(last[i][j]!=0)//如果这个点已经被访问或者有棋子的话，则输出零 
			cout<<"0";
			else//否则输出1 
			cout<<"1";
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：ZZ作者 (赞：1)

~~一边上课一边打月赛，好快活啊~~

~~一边上课一边打写题解，也好快活啊~~（非正确行为

作为萌新，就来写篇比较详细的题解吧owo

(我也就只能写红题题解了

### 思路

看到本题，棋盘？立刻想起了过河卒，梦开始的地方~~（没判边界调了一下午的搜索）~~

然而这题跟路径没关系

然后又想到八皇后，~~梦开始一会儿后的地方~~

然而这题只用放一个子……

所以，我们只需要枚举每一个战车 `R` 或主教 `B`，搜索并标记他们能走到的地方，直接输出即可。

### 分析

搜索题中，对于细节的严谨是很重要的。本题的细节不多，大致如下：

- **国王不能放在已经有棋子的地方** 
- 棋子移动时，**不能越过其他棋子** （此点写挂，30pts）

### 实现

#### Part 1 读入

用 `scanf("%c",&m[i][j]);` 实现读入，以一个一个读入字符。

需要注意的是，数据中包含不可见字符，而windows和linux环境下换行符不一样，有时会很难调。好在本题保证只会出现 `.`，`R`，`B` 三种字符，因此，我们可以这样比较方便地实现：

``` cpp
do{scanf("%c",&m[i][j]);}while(m[i][j]!='.'&&m[i][j]!='R'&&m[i][j]!='B');
```

#### Part 2 搜索&&标记

战车与主教的行动范围都是四向直线，所以我们可以在搜索时把方向作为参数传递下去。

加上判边界，判越棋子，放上代码：

```cpp
//以(i1,j1)为起点，以c为方向搜索，当前点为(a,b)。
//m[10][10]:存棋盘
//f[10][10]:存主教，战车能否到达，能到达为1

void sign1(ll a,ll b,ll c,ll i1,ll j1) //主教行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign1(a-1,b-1,1,i1,j1); //左上
	if(c==2)sign1(a-1,b+1,2,i1,j1); //右上
	if(c==3)sign1(a+1,b-1,3,i1,j1); //左下
	if(c==4)sign1(a+1,b+1,4,i1,j1); //右下
}

void sign2(ll a,ll b,ll c,ll i1,ll j1) //战车行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign2(a-1,b,1,i1,j1); //下
	if(c==2)sign2(a,b+1,2,i1,j1); //右
	if(c==3)sign2(a,b-1,3,i1,j1); //左
	if(c==4)sign2(a+1,b,4,i1,j1); //上
}
```

#### Part 3 全代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long

char m[10][10]={0};
bool f[10][10]={0};

//m[10][10]:存棋盘
//f[10][10]:存主教，战车能否到达，能到达为1

//以(i1,j1)为起点，以c为方向搜索，当前点为(a,b)。
void sign1(ll a,ll b,ll c,ll i1,ll j1) //主教行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign1(a-1,b-1,1,i1,j1); //左上
	if(c==2)sign1(a-1,b+1,2,i1,j1); //右上
	if(c==3)sign1(a+1,b-1,3,i1,j1); //左下
	if(c==4)sign1(a+1,b+1,4,i1,j1); //右下
}

void sign2(ll a,ll b,ll c,ll i1,ll j1) //战车行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign2(a-1,b,1,i1,j1); //下
	if(c==2)sign2(a,b+1,2,i1,j1); //右
	if(c==3)sign2(a,b-1,3,i1,j1); //左
	if(c==4)sign2(a+1,b,4,i1,j1); //上
}

int main()
{
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			do{scanf("%c",&m[i][j]);}while(m[i][j]!='.'&&m[i][j]!='R'&&m[i][j]!='B');
			if(m[i][j]!='.')f[i][j]=1;
		}
	}
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
            //枚举每一个点
			if(m[i][j]=='B')
			{
				for(int k=1;k<=4;k++)sign1(i,j,k,i,j); //主教行动
			}
			if(m[i][j]=='R')
			{
				for(int k=1;k<=4;k++)sign2(i,j,k,i,j); //战车行动
			}
		}
	}
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			cout<<!f[i][j]; //主教、战车能到达的，是不能放国王的，反之亦然。
		}
		cout<<endl;
	}
	return 0;
}
```



---

## 作者：lndjy (赞：1)

一道简单的模拟题，月赛ｔ１完全可以。

对于每个车或主教，枚举每个方向直到障碍物或者边界，把能吃到的标记在bool数组里，最后输出bool棋盘即可。

AC代码（含注释）
```
#include<iostream>
#include<string>
#include<cstring>
#include<cstdio>
using namespace std;
char s[9][9];
bool m[9][9];
int n=8;／／习惯打ｎ了，直接这么写了
void r(int x,int y)／／车，４个循环４个方向
{
	m[x][y]=1;
	for(int i=x-1;i>=1;i--)／／上
	if(s[i][y]=='.')
	m[i][y]=1;
	else
	break;
	for(int i=x+1;i<=n;i++)／／下
	if(s[i][y]=='.')
	m[i][y]=1;
	else
	break;
	for(int i=y-1;i>=1;i--)／／左
	if(s[x][i]=='.')
	m[x][i]=1;
	else
	break;
	for(int i=y+1;i<=n;i++)／／
	if(s[x][i]=='.')
	m[x][i]=1;
	else
	break;	
}
void b(int x,int y)／／主教，同上
{
	m[x][y]=1;
	for(int i=1;i<=min(x-1,y-1);i++)／／左上
	if(s[x-i][y-i]=='.')
	m[x-i][y-i]=1;
	else
	break;
	for(int i=1;i<=min(n-x,n-y);i++)／／右下
	if(s[x+i][y+i]=='.')
	m[x+i][y+i]=1;
	else
	break;
	for(int i=1;i<=min(x-1,n-y);i++)／／左下
	if(s[x-i][y+i]=='.')
	m[x-i][y+i]=1;
	else
	break;
	for(int i=1;i<=min(n-x,y-1);i++)／／右上
	if(s[x+i][y-i]=='.')
	m[x+i][y-i]=1;
	else
	break;
}
int main()
{
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
	cin>>s[i][j];
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
	{
		if(s[i][j]=='R')
		r(i,j);
		if(s[i][j]=='B')
		b(i,j);
	}
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
	{
		if(m[i][j])／／因为反着标记，所以反着输出
		putchar('0');
		else
		putchar('1');
		if(j==8)
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：Fatalis_Lights (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6194)

## Solution

先将整张棋盘读入（废话）。

然后开始遍历整个棋盘，如果：

+ 碰到了 `R` 棋子，就向横竖方向染色。

+ 碰到了 `B` 棋子，就向对角线方向染色。

怎么染色比较好呢？

不妨采用 DFS 。

+ 如果是 `.` ，就可以继续染色。

+ 如果是 `R` 或者 `B` ，就停止。

唯一的坑点就是 `1` 表示可以放， `0` 表示不能放。

code:

```cpp
#include<bits/stdc++.h>
#define N 10
using namespace std;
char mp[N][N];
bool ans[N][N];
void dfs1(int x,int y,int way){ //染色战车
	ans[x][y]=0;
	if(way==1&&mp[x+1][y]=='.') dfs1(x+1,y,1);
	if(way==2&&mp[x][y+1]=='.') dfs1(x,y+1,2);
	if(way==3&&mp[x-1][y]=='.') dfs1(x-1,y,3);
	if(way==4&&mp[x][y-1]=='.') dfs1(x,y-1,4);
	return;
}//way是规定好的方向，(x,y)是当前坐标

void dfs2(int x,int y,int way){ //染色主教
	ans[x][y]=0;
	if(way==1&&mp[x+1][y+1]=='.') dfs2(x+1,y+1,1);
	if(way==2&&mp[x-1][y+1]=='.') dfs2(x-1,y+1,2);
	if(way==3&&mp[x-1][y-1]=='.') dfs2(x-1,y-1,3);
	if(way==4&&mp[x+1][y-1]=='.') dfs2(x+1,y-1,4);
	return;
}//与dfs1同理

int main(){
	for(int i=1;i<=8;i++)
		for(int j=1;j<=8;j++)
			cin>>mp[i][j], ans[i][j]=1;//初始化棋盘
	for(int i=1;i<=8;i++)
		for(int j=1;j<=8;j++)
			if(mp[i][j]=='R'){ //四方向染色
				dfs1(i,j,1);
				dfs1(i,j,2);
				dfs1(i,j,3);
				dfs1(i,j,4);
			}else if(mp[i][j]=='B'){ 
				dfs2(i,j,1);
				dfs2(i,j,2);
				dfs2(i,j,3);
				dfs2(i,j,4);
			}
	for(int i=1;i<=8;i++,puts("")) //记得换行
		for(int j=1;j<=8;j++)
			cout<<ans[i][j]; //行末无空格
	return 0;
}
```

---

## 作者：十十十十 (赞：1)

一道模拟题，纯模拟。  
用一个国际象棋棋盘模拟，那就建一个二维数组，在上面模拟。  
有些细节还是需要注意，比如**攻击范围不能超过其他棋子**  
详情看代码吧：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    bool ans[10][10];//结果
    char gaze[10][10];//棋盘
    char x;
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++) //读入棋盘
        {
            cin>>gaze[i][j];
            ans[i][j]=1;
        }
    }
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)//判断是否可放
        {
            if(gaze[i][j]=='R')//战车
            {
                ans[i][j]=0;//有敌方当然不能放
                for(int x=i-1;gaze[x][j]=='.'&&x>0;x--)//向左，直到碰到其他棋子或边缘
                {
                    ans[x][j]=0;
                }
                for(int x=i+1;gaze[x][j]=='.'&&x<=8;x++)///横向，同上
                {
                    ans[x][j]=0;
                }
                for(int y=j-1;gaze[i][y]=='.'&&y>0;y--)
                {
                    ans[i][y]=0;
                }
                for(int y=j+1;gaze[i][y]=='.'&&y<=8;y++)//纵向，也和上面一样
                {
                    ans[i][y]=0;
                }
            }
            if(gaze[i][j]=='B')//主教
            {
                ans[i][j]=0;
                for(int x=i-1,y=j-1;gaze[x][y]=='.'&&x>0&&y>0;x--,y--)//斜向，枚举方法应该不唯一，我用了2个变量的for
                {
                    ans[x][y]=0;
                }
                for(int x=i+1,y=j-1;gaze[x][y]=='.'&&x<=8&&y>0;x++,y--)//同上
                {
                    ans[x][y]=0;
                }
                for(int x=i-1,y=j+1;gaze[x][y]=='.'&&x>0&&y<=8;x--,y++)
                {
                    ans[x][y]=0;
                }
                for(int x=i+1,y=j+1;gaze[x][y]=='.'&&x<=8&&y<=8;x++,y++)//都差不多啦
                {
                    ans[x][y]=0;
                }
            }
        }
    }
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)//输出
        {
            cout<<ans[i][j];
        }
        cout<<endl;
    }
    return 0;//完结撒花!
}
```

---

## 作者：血色黄昏 (赞：0)

纯模拟，暴力

要注意如果有东西挡住了就不能再往前了

除了细心还是细心

上python的代码

```python
l = [[1 for i in range(8)] for j in range(8)]#储存答案
b = [[0 for i in range(8)] for j in range(8)]#标记有没有物体
def R(i, j):#如果是战车
    global l
    x = i + 1
    while 8 > x > -1:
        if b[x][j]:#如果有东西挡住
            break
        l[x][j] = 0#不然不能放
        x += 1
    x = i - 1
    while 8 > x > -1:
        if b[x][j]:#同上
            break
        l[x][j] = 0#同上
        x -= 1
    x = j + 1
    while 8 > x > -1:#同上
        if b[i][x]:
            break
        l[i][x] = 0
        x += 1
    x = j - 1
    while 8 > x > -1:
        if b[i][x]:
            break
        l[i][x] = 0
        x -= 1


def B(i, j):#如果是主教
    global l
    x, y = i + 1, j + 1#l[i][j]不用再弄一遍了
    while x < 8 and y < 8 and b[x][y] != 1:#如果没越界且没有东西挡路
        l[x][y] = 0#不能放
        x += 1
        y += 1
    x, y = i + 1, j - 1
    while x < 8 and y > -1 and b[x][y]!= 1:#同上
        l[x][y] = 0
        x += 1
        y -= 1
    x, y = i - 1, j + 1
    while x > -1 and y < 8 and b[x][y] != 1:#同上
        l[x][y] = 0
        x -= 1
        y += 1
    x, y = i - 1, j - 1
    while x > -1 and y > -1 and b[x][y] != 1:#同上
        l[x][y] = 0
        x -= 1
        y -= 1


s = []
for i in range(8):
    q = input()#输入
    s.append(q)#加到s里去
    for j in range(8):
        if q[j] == "B" or q[j] == "R":#如果有东西
            b[i][j] = 1#变为true
for i in range(8):
    for j in range(8):
        if s[i][j] == "B":#如果是B
            l[i][j] = 0
            B(i, j)#调用
        if s[i][j] == "R":#如果是R
            l[i][j] = 0
            R(i, j)#调用


for i in range(8):
    for j in range(8):
        print(l[i][j], end="")#打印
    print()#换行
```

祝大家月赛AK！

---

## 作者：百因必有AC (赞：0)

基本思路：模拟。

输入就不多说了，见代码：

```cpp
for(i=0;i<8;i++)
  for(j=0;j<8;j++){
    cin>>c[i][j];
    f[i][j]=1;//在读入时就把数组全部标记为1，不用另写循环
  }
```


然后模拟 $R$ 的攻击范围，先标记 $R$ 这个点，然后分别向上，下，左，右延伸，如发现其他棋子就停止标记。

代码如下：

```cpp
if(c[i][j]=='R'){
  a[i][j]=0;//当前位置标记为0
  for(k=j-1;k>=0;k--)//向左
    if(c[i][k]=='.')f[i][k]=0;
    else break;
  for(k=j+1;k<8;k++)//向右
    if(c[i][k]=='.')f[i][k]=0;
    else break;
  for(k=i-1;k>=0;k--)//向上
    if(c[k][j]=='.')f[k][j]=0;
    else break;
  for(k=i+1;k<8;k++)//向下
    if(c[k][j]=='.')f[k][j]=0;
    else break;
}
```
再模拟 $B$ 的攻击范围，思路基本和 $R$ 相同，只是方向有些变化，一个循环需要两个循环变量，分别控制行 $_{(k)}$ 和列 $_{(m)}$ 。

代码如下：

```cpp
if(c[i][j]=='B'){
  a[i][j]=0;
  for(k=i-1,m=j-1;k>=0&&m>=0;k--,m--)//左上
    if(c[k][m]=='.')f[k][m]=0;
    else break;
  for(k=i-1,m=j+1;k>=0&&m<8;k--,m++)//右上
    if(c[k][m]=='.')f[k][m]=0;
    else break;
  for(k=i+1,m=j-1;k<8&&m>=0;k++,m--)//左下
    if(c[k][m]=='.')f[k][m]=0;
    else break;
  for(k=i+1,m=j+1;k<8&&m<8;k++,m++)//右下
    if(c[k][m]=='.')f[k][m]=0;
    else break;
}
```
最后输出 $f$ 数组就可以了。

输出代码：

```cpp
for(int i=0;i<8;i++){
  for(int j=0;j<8;j++)
    printf("%d",a[i][j]);//一定不能有空格！
  printf("\n");
}
```



---


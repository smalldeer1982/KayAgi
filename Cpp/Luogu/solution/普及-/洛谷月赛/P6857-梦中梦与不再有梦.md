# 梦中梦与不再有梦

## 题目背景

Amazing John 做了一个梦，梦到他做了很多梦。

记得最好的梦，是不再有梦。

## 题目描述

Amazing John 想要以自己的梦出一道题。

Amazing John 做了 $n$ 个梦。每两个梦之间都有且仅有一条桥梁直接相连，不会有桥梁从一个梦连向自身。

通过桥梁 $e_{u,v}$ 可以从梦 $u$ 到达 梦 $v$ 或从 $v$ 到达 $u$ ，并且获得 $1$ 点休息值。

对于每个桥梁 $e_{u,v}$ ，它只能被经过一次，无论是正向经过还是反向经过。

当到达一个梦且与它相连的所有桥梁都不能经过时， Amazing John 就会结束他的做梦。

现在 Amazing John 很困，他想知道从任意一个梦出发，最多可以获得多少休息值？

## 说明/提示

样例解释：

从 $1$ 出发，沿 $e_{1,2}$ 到达 $2$ ，再沿 $e_{2,3}$ 到达 $3$ ，最后沿 $e_{3,1}$ 到达 $1$。

总共获得了 $3$ 点休息值。

|子任务|数据点|数据范围|分数|
-|-|-|-|
|$1$|$1\sim2$|$n≤6,T=3$|$30$|
|$2$|$3\sim5$|$n≤10^9,T≤10^5$|$70$|

对于一个子任务，你能获得它的分数当且仅当你通过了其中所有的数据点。

## 样例 #1

### 输入

```
1
3```

### 输出

```
3```

# 题解

## 作者：_Luminous (赞：12)

#### · 题意


------------
由题面中：
```
每两个梦之间都有且仅有一条桥梁直接相连，不会有桥梁从一个梦连向自身。

只能被经过一次，无论是正向经过还是反向经过。

到达一个梦且与它相连的所有桥梁都不能经过
```


可知，题意是让我们删除掉最少的边，使得图中存在**欧拉路**。

#### 欧拉路的定义：


------------


存在这样一种图，可以从其中一点出发，不重复地走完其所有的边。

如果欧拉路的起点与终点相同，则称之为**欧拉回路**。

显而易见，欧拉路存在的充要条件如下：

①图是连通的，若不连通不可能一次性遍历所有边。

②**对于无向图**：有且仅有两个点，与其相连的边数为奇数，其他点相连边数皆为偶数；或所有点皆为偶数边点。对于两个奇数点，一个为起点，一个为终点。起点需要出去，终点需要进入，故其必然与奇数个边相连。

如果存在这样一个欧拉路，其所有的点相连边数都为偶数，那说明它是欧拉回路。

因为此时它的起点即是终点，出去后还会回来，刚好形成偶数边。

③**对于有向图**：除去起点和终点，所有点的出度与入度相等。起点出度比入度大1，终点入度比出度大1。若起点终点出入度也相同，则为欧拉回路。

**欧拉路问题也常被称为一笔画问题。**


——以上摘自[【朝夕的ACM笔记】图论-欧拉路](https://zhuanlan.zhihu.com/p/112013386)


#### · 解题思路 & 方法


------------
其实前面的dalao们已经说得很清楚了，这位[大佬](https://www.luogu.com.cn/blog/LXLDuliu-IAKIOI/tu-lun-zhi-ou-la-lu-ti-xie)写得很好懂 ~~（连我都懂了）~~  ，我就不赘述了（其实是懒+怕说不好qwq）

#### · Code


------------
```cpp
#include <iostream>
#define ll long long
using namespace std;
ll t,n;//不开long long见祖宗（
int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>n;
		if(n%2)
			cout<<n*(n-1)/2<<endl;
		else
			cout<<n*(n-1)/2-(n-2)/2<<endl;
	}
    return 0;
}
```


---

## 作者：Unordered_OIer (赞：11)

# P6857 题解
## 题意
一个 $n$ 个节点的完全图，选取最多的节点使得这些节点之间可以互相连通且不能再到达其他的节点，求节点数。

## 解题
首先，看一下数据范围 $n \leq 10^9,T \leq 10^5$ ，这一看就只能是 $\Theta(1)$ 。

于是我们可以打表一下看看规律：

| $n=2$ | $n=3$ | $n=4$ | $n=5$ | $n=6$ | $n=7$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $1$ | $3$ | $5$ | $10$ | $13$ | $21$ |

然后我们就可以发现：  
- 当 $n$ 为奇数时，答案为 $\frac{n(n-1)}{2}$
- 当 $n$ 为偶数时，答案为 $\frac{(n-1)(n-2)}{2}+\frac{n-1}{2}+1$

写完代码交上去，发现 $\texttt{\colorbox{#52C41A}{\color{white}AC}}$ 了，那么怎么证明呢？

首先，我们先画一下 $n=5$ 和 $n=6$ 时的完全图：
1. $n=5$ 时，完全图是  
![](https://cdn.luogu.com.cn/upload/image_hosting/ctvv8vsk.png)  
我们试着走一下： $1-2-5-3-4-2-3-1-5-4$ ，正好把 $10$ 条边走完。

2. $n=6$ 时，完全图是  
![](https://cdn.luogu.com.cn/upload/image_hosting/6m5347ko.png)  
继续试着走一下： $1-2-5-3-4-6-1-3-6-2-4-5-1-4$ ，没有其他的了，一共 $13$ 条边，并没有走满。

那么，为什么 $n$ 为奇数的时候就可以走满， $n$ 为偶数就不行呢？

实际上是因为 $n$ 为奇数的时候，每个点的出度都是偶数，一定可以一笔画，所以直接输出边数即可；但是 $n$ 为偶数的时候，每个点的出度都是奇数了，不能一笔画，顶多再撑个一圈，所以要在之前的结果上加上 $\frac{n-1}{2}+1$ ，这也是我们打表发现的式子的出处。

以上就是证明过程。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T, n;
int main() {
	cin >> T;
	while (T --) {
		cin >> n;
		if (n & 1) cout << n * (n - 1) / 2;
		else cout << (n - 1) * (n - 2) / 2 + ((n - 1) / 2 + 1);
	}
	return 0;
}
```

## 后记
考察思维的题，~~就是我不会的题~~。

最后，祝洛谷月赛
## 越办越好
完结撒花~顺便求赞![](https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/qq/%E5%8F%AF%E6%80%9C.gif)

---

## 作者：超级玛丽王子 (赞：9)

## 写在前面的话
1. 这道题作为月赛 T1 有点过分了，图论都上了；
2. 这道题**不是找规律**，而是一道性质/结论题。
3. 如果你没有学过图论，没关系。~~由于我写不来逼格高的~~这篇题解绝对平易近人，让菜鸟都能一看就懂。

## 前置知识
如果您没有学过图论以及欧拉路相关的内容，请戳[这里](https://www.luogu.com.cn/blog/LXLDuliu-IAKIOI/tu-lun-zhi-shi-hui-zong-chi-xu-gu-gu-gu-zhong-post)。



## 题意分析
1. 每两个梦之间都有且仅有一条桥梁直接相连，不会有桥梁从一个梦连向自身；通过桥梁 $e_{u,v}$ 可以从梦 $u\rightarrow v$ 或 $v \rightarrow u$。
	
    这是一个无向简单完全图；
2. 对于每个桥梁 $e_{u,v}$，它只能被经过一次。
	
    这是一个欧拉路问题；
3. 获得一点休息值。
	
    边权为 $1$；
    
## 正解

经过分析，题目想让我们删去最少的边使原图存在欧拉路。

根据 $n$ 的奇偶性进行分类讨论：
1. 如果 $n$ 是奇数，那么每个点都连接了偶数条边，原图没有奇点，存在欧拉路，直接输出 $\dfrac{n(n-1)}2$；
2. 如果 $n$ 是偶数，那么每个点都连接了奇数条边。显然，删去一条边会使两个点的度数各减一，也就是将两个奇点变成了两个偶点。显然，我们最多有 $2$ 个奇点，也就是最少有 $n-2$ 个偶点，需要删去 $\dfrac{n-2}2$ 条边。

## 代码
```cpp
//十年 OI 一场空，不开 long long 见祖宗
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    int x=0;
    while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
    return x;
}
int main(void) {
    int T=read();
    while(T--) {
        long long n=read();
        if(n&1) printf("%lld\n",n*(n-1)/2);
        else printf("%lld\n",n*(n-1)/2-((n-2)/2));
    }
    return 0;
}
```

## 完结撒花~求赞求互关QAQ

---

## 作者：Vagari (赞：8)

# 题目大意
给一个 $n$ 个点的无向完全图，删去最少的边使该图成为欧拉图。

欧拉图：存在欧拉路径的图。

欧拉路径：包含图中所有边恰好一次的路径。
# Subtask 1
朴素DFS，标记经过的边，记录最大深度，即可拿到所有分数。

时间复杂度 $O($能过$)$
# Subtask 2
一个图存在欧拉路径的充要条件：图中只有 $0$ 个或 $2$ 个度数为奇数的点。

首先对于点数为奇数的无向完全图，其中所有点度数为偶数，则满足该充要条件，边数即为欧拉路径长度。

对于偶数点数的图，即所有点度数为奇数的图：

在最优选择情况下，每删去一条边，就会有两个点的度数变为偶数。那么删去 $\frac{n}{2}-1$ 条边时，恰有两个点度数为奇数，满足充要条件，此时边数最多。

最终答案 $ans=\left\{
\begin{aligned}
&C^2_n\space\space(n\space mod\space 2 = 1) \\
&C^2_n-\frac{n}{2}+1\space\space(n\space mod\space 2 = 0)
\end{aligned}
\right.$

本来设置了对没开 long long 的选手照顾一些的子任务，但是考虑到 IOI 赛制就取消了这个子任务了。

时间复杂度 $O(T)$

当然你也可以通过打表找规律的方法找到该公式。

顺带一提，这玩意在 OEIS 上能找到（（

再顺带一提，OEIS上面对该数列的描述为**完全无向图中的最长哈密顿路径**（是我学了假的欧拉路吗qaq）

---

## 作者：梨衣 (赞：6)

#### ~~为何数论题备受宠爱~~
## 一道经典的欧拉路问题
## 基本概念：

  欧拉路：欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且**图中每条边通过的且只通过一次**。

特别的，当起点与终点相同时，被称为欧拉回路。
## 存在欧拉路的条件:

1.无向连通图存在欧拉路的条件：

**所有点度都是偶数，或者恰好有两个点度是奇数**，则有欧拉路。若有奇数点度，则奇数点度点一定是欧拉路的起点和终点，否则可取任意一点作为起点。

2.有向连通图存在欧拉路的条件：

每个点的入度等于出度，则存在欧拉回路（任意一点有度的点都可以作为起点）除两点外，所有入度等于出度。这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉路。取出度大者为起点，入度大者为终点。

于是我们的目标变成了如何将给出的图变为欧拉回路。

由题意可知，此题为每两点间都联通的无向图，则 $n$ 个点时每个点的度为 $n$ - 1 ，对 $n$ 进行分类讨论
## 当 $n$ 为奇数时
此时每个点的度为偶数，符合欧拉路条件：**所有点度都是偶数**，则每条边都可以被通过且只通过一次，获得的最大休息值即为总边数。

对于无向图，**每增加第 $i$ 个点时会增加 $i$ - 1条边**，则总边数为
### 1 + 2 +3 + ...... + ($n$ - 1) = $n$ ($n$ - 1) / 2
## 当 $n$ 为偶数时
此时每个点的度都为奇数，要进行删边操作，使只保留两点的度为奇数。

**对于任意一条边，总有两点与之相连，则删去一条边后，会有两点的度减一，从奇数变为偶数。**

那么对 $n$ 个点删边，除最后保留两点外，总共删去 $n$ - 2 个点，即 （$n$ - 2）/ 2 条边，此时答案在总边数上减去 （$n$ - 2）/ 2 即可
## 代码如下
```cpp
#include<cstdio> 
#include<string>
using namespace std;
inline unsigned long long read()
{
	unsigned long long x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}//快读 
int main(){
	unsigned long long t,n;
	unsigned long long ans;
	t=read();
	while(t>=1){//t组数据 
		t--;
		n=read();
		ans=n*(n-1)/2;
		if(n%2==0)ans-=(n-2)/2;//偶数个点时每个点有奇数度，删边 
		printf("%llu\n",ans);
	}
	return 0;
}
```
## The end

---

## 作者：InformationEntropy (赞：5)

本题的实质就是求有 $n$ 个顶点的无向完全图能够一笔画的最多边数。

当一个无向图有 0 个或 2 个奇点（度为奇数的点），那么它就是一个欧拉图，可以一笔画完所有的边。

考虑到 $n$ 为奇数时，每个顶点的度都为偶数，有 0 个奇点，故一定为欧拉图，所以最多边数就是总边数，即 $\dfrac {n\times (n-1)}{2}$。

当 $n$ 为偶数时，考虑删掉一些边使它变为一个欧拉图。由于每个点的度都为奇数，故有 $n$ 个奇点，而边双向连通，所以每删除一条边最多可减少两个奇点，我们需要把奇点减少至 2 个，所以至少要删 $\dfrac {n-2}{2}$ 条边，最终边数为 $\dfrac{n\times (n-1)}{2}-\dfrac{n-2}{2}$。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
template<class T>inline void read(T &x)
{//快读
    x = 0;
    T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
int main()
{
    ll t, n;//不开 long long 见祖宗
    read(t);
    for (int i = 1; i <= t; i++)
    {
        read(n);
        if (n == 0 || n == 1)
        {
            cout << 0 << '\n';//注意特判
        } else if (n == 2) {
            cout << 1 << '\n';
        } else if (n % 2 == 1) {
            cout << n*(n - 1) / 2 << '\n';
        } else {
            cout << n*(n - 1) / 2 - n / 2 + 1 << '\n';
        }
    }
    return 0;
}
```

---

## 作者：Eason_AC (赞：5)

## Update
- $\texttt{2020.10.20}$ 增加了证明。感谢@东北小蟹蟹的提醒。

## Content
有一个 $n$ 个点的无向图，每两个点之间都有一条边直接相连。你从 $1$ 出发，每条边最多只能经过一次，当走到一个点，其相连的边都不能走时，你会停下来。问你最多能够经过多少条边。

**数据范围：$T$ 组数据，$T\leqslant 10^5,n\leqslant 10^9$。**
## Solution
我们先画图来找规律，先是 $n=3$ 的，由样例可以直接得知，这个图里面的 $3$ 条边都能够经过，答案是 $3$。

那么，我们再来画几个图找找规律，$n=4$ 的时候的图是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/cre6nkbg.png)

自己走一下就可以发现，无论怎么样都有 $1$ 条边走不了。

那么，$n=5$ 的时候呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/l28s7ast.png)

我们可以先走五角星状的路线，然后再走五边形状的路线，这样所有边都走得了。

再画一下 $n=6$ 的图，走一下发现，无论怎么样都有 $2$ 条边走不了。

然后这样我们得到一个规律：设答案为 $ans$，则有：

$$ans=\begin{cases}\dfrac{n(n-1)}{2}&2\nmid n\\\dfrac{n(n-1)}{2}-\dfrac{n}{2}+1&2\mid n\end{cases}$$

虽然是乱搞得出的规律，但我们惊喜的发现，交上去之后，这样的思路是对的！

乱搞搞完了，我们为什么不证明一下呢？

这道题目其实就是要我们找一个欧拉路径（不会欧拉路径？[bfs一下你就知道](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84)）。如果是奇数个点的话，必定会形成一个欧拉回路，即存在一个能经过每条边一次并且仅一次的回路，那么也肯定就会有欧拉路径。如果是偶数个点的话，删任意 $\dfrac{n}{2}-1$ 条边，没有公共顶点的边就可以使整张图变成半欧拉图，存在一条欧拉路径。

那么这样就证明完了，大概就是这样的一道找规律可以水过的题目，找到规律之后写代码挺简单的，但主要问题就是证明了。
## Code
```cpp
int t;
long long n;

int main() {
	//This program is written in Windows 10 by Eason_AC
	getint(t);
	while(t--) {
		getll(n);
		n = n * (n - 1) / 2 - (!(n % 2) ? n / 2 - 1 : 0);
		writell(n), puts("");
	}
	return 0;
}

```

---

## 作者：phil071128 (赞：3)

这道题我们可以打表（逃）

打表程序：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		switch (n){
			case 1:{
				cout<<0<<"\n";
				break;
			}
			case 2:{
				cout<<1<<"\n";
				break;
			}
			case 3:{
				cout<<3<<"\n";
				break;
			}
			case 4:{
				cout<<5<<"\n";
				break;
			}
			case 5:{
				cout<<"10\n";
				break;
			}
			case 6:{
				cout<<"13\n";
				break;
			}
			case 7:{
				cout<<"21\n";
				break;
			}
		}
	}
	return 0;
}
```

正确的解法是**一笔画问题**

如果你不知道什么是一笔画，你可以~~去百度~~

[百度百科   一笔画问题](https://baike.baidu.com/item/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98/7816446?fr=aladdin)

那么我们该怎么解决这道题呢？

有以下结论：

1. 凡是由偶点组成的连通图，一定可以一笔画成。画时可以把任一偶点为起点，最后一定能以这个点为终点画完此图。

2. 凡是只有两个奇点的连通图（其余都为偶点），一定可以一笔画成。画时必须把一个奇点为起点，另一个奇点则是终点。
3. 其他情况的图都不能一笔画出。(奇点数除以二便可算出此图需几笔画成。)

所以说：

- 一个图形判断能否被一笔画下来，关键是看**奇点**的个数：

- 当**奇点为0个或者2个时**（不可能为一个，奇点都是成对出现），可以被一笔画下来，反之则不能。

当点数个数为奇数时（%2==1），该图则一定可以一笔画。
否则（偶数），我们需要删掉n-2个点.

就是
$ \frac{n-2}{2} $条边

所以








$ \frac{n}{2}+ \frac{n-2}{2}\times (n-1) $



100分代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long t;
	cin>>t;
	while(t--){
		long long n;
		cin>>n;
		if(n%2==1){
			cout<<n*(n-1)/2<<endl;
		}else{
			cout<<(n-1)*(n-2)/2+(n/2)<<endl;
		}
		
	}
	return 0;
}
```


话说，其实考场上列个表找规律就好了，毕竟这是月赛，多用点的时间去A一道题也无妨。

---

## 作者：dzdolrc (赞：2)

这是一道关于图论的结论题。首先，我们知道这是一个有$n$个顶点，$n(n-1)$条边的一个图。对于最大值，肯定是所有的边都能跑一遍，那么我们就有**欧拉回路**,即**一笔画**能遍历全图的路线。[百度：欧拉回路](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/10036484?fr=aladdin)
```
一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。

解释：当所有顶点数的出边都为偶数时，才能一遍走完所有的边。
```
那么对于奇数的解法呢？首先画个四边形，稍微一数，发现结果为$5$。再数一下六边形，有$15$条边,但实际上能遍历到的只有$13$条边,然后找规律。
```
2 1
4 5
6 13
8 25
10 41
```


最后可以推出式子，当顶点数为偶数时，答案为$n*(n-1)/2-n/2+1$


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll t,n;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n;
		if(n%2) cout<<n*(n-1)/2<<endl;
		else cout<<n*(n-1)/2-n/2+1<<endl;
	}
	return 0;
}
```


---

## 作者：Merron (赞：2)

**Update:**

- 更正公式错误

简单的一笔画问题，推公式即可。

我们都知道，在一张图中，如果有0或2个度为奇数的点，这张图是可以一次性不重复走完的。

而题目翻译过来是在问你在一个强连通图中最少删多少边，使这个图可以一笔画。

因为公式过于简单，此处不详细讲解。

设点数为n

- 当n为奇数时，该图一定可以一笔画（不信自己试一试）。
- 当n为偶数时，图中有n个奇点，只用删去n-2个点，即为$\frac{n-2}{2}$条边，所以输出$\frac{n *(n-1)}{2}-\frac{n-2}{2}$。

至此，公式推完。

code:
```cpp
#include <iostream>
#include <cstdio>
using namespace std ;

int T ;

int main()
{
	scanf("%d", &T) ;
	for (int i = 1 ;i <= T ;i ++)
	{
		long long x ;
		scanf("%lld", &x) ;
		if (x % 2 == 0)
		{
			cout << ((x * x - x) / 2) - ((x - 2) / 2) << endl ;
		}
		else
		{
			cout << (x - 1) * x / 2 << endl ;
		}
      //不存入变量不会爆精度
	}
}
```

---

## 作者：Trafford1894 (赞：2)



蒟蒻来写一篇有详细说明的题解。

### Description

题目的意思就是给你一个有 $n$ 个点的无向完全图，其中每条边只能走一次，让你求出最多能走几条边。

### 前置知识：一笔画问题

如果从一个图的一个顶点出发能不重不漏地遍历这张图，这个图就是可一笔画的。

一个无向图是可一笔画的，当且仅当这个图**每一个顶点的度数都是偶数或恰有两个顶点的度数为奇数**。

### Solution

如果 $n \mod{2} == 1$，则这个图每一个顶点的度数都是偶数，这个图本身就是可一笔画的。而我们知道，一个无向完全图的边数是 $n*(n-1) \div 2$，所以答案就是 $n*(n-1) \div 2$。

其他情况，则这个图每一个顶点的度数都是奇数，我们就需要删除一些边，使得只有两个点的度数为奇数。而每一条边连接这两个点，所以我们只需要删除 $n \div 2 - 1$ 条边。所以答案就是 $n*(n-1) \div 2 - n \div 2 - 1$。

### ACCode

```cpp


#include <iostream>
#define int long long

using namespace std;

int Count_edge(int num) {
    return num * (num - 1) / 2;
}

void Solve(int num) {
    cin >> num;
    if(num == 1 or num == 2) {
       cout << num - 1 << endl;//特判
       return;
    }
    
    int tmp = Count_edge(num);
    if(num % 2 == 0) {
        tmp -= num / 2 - 1;
    }
    
    cout << tmp << endl;
}

signed main() {
    
    int t;
    cin >> t;
    while(t--) {
        Solve(0);
    }
    
    return 0;
}
```


---

## 作者：zmza (赞：1)

这是一题一笔画问题。

有0个或两个奇点的图可以一笔画，答案是所有边数。其他的就是还要减去
$$\frac{a}{2}-1$$
条边。这些边是不行的。因为有两个奇点就会有一条边不行。但是，两个奇点也可以一笔画，所以要减一要用等差数列求和。不然会超时。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long sum;//注意开long long
int main()
{
	scanf("%d",&t);
	for(int i = 1; i <= t; i++)
	{
		sum = 0;
		int a;
		scanf("%d",&a);
		if(a == 1 || a == 0)
		{
			printf("0\n");
			continue;
		}
		if(a == 2)
		{
			printf("1\n");
			continue;
		}
		sum += (long long)(a - 1) * a / 2;//等差数列求和
		if(a % 2 == 0)//奇数个点，每个点一定是偶点，所以只有偶数个点才减
		{
			sum -= a / 2 - 1;
		}
		printf("%lld\n",sum);//输出
	} 
	return 0;
}
```


---

## 作者：SymphonyOfEuler (赞：0)

一笔画问题，也叫欧拉回路。[一笔画](https://baike.baidu.com/item/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98/7816446?fr=aladdin)。对于T1很良心。

简单说，就是每条边都只能走过一次的图叫欧拉图。**如何判断一个无向图存在欧拉回路？当且仅当该图所有顶点度数都为偶数，且该图是连通图。** 这样的图是欧拉图，且可以一笔画而成。

因为是完全图，每个点都是奇数点，得出：

$n \ mod \ 2==0$：答案为 $((n * (n - 2)) \div2) + 1$

$n \ mod \ 2 \ne 0$：答案为 $(n * (n - 1)\div 2)$

程序实现：


```

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll T, n;

inline void solve() {
    cin >> T;
    while (T--) {
        cin >> n;
        if (n % 2 != 0) { //不是2的倍数
            cout << (n * (n - 1) >> 1) << '\n';
            continue;
        }
        cout << ((n * (n - 2)) >> 1) + 1 << '\n';
    }
}

int main() {
    solve();
    return 0;
}
```


---

## 作者：ModestCoder_ (赞：0)

从某一点出发，一笔画最多几条边

就是从一个完全图最少删去几条边使之能一笔画

发现如果点数是奇数，那么每个点的度数都是偶数，直接一笔画

如果点数是偶数，每个点的度数都是奇数，根据小学奥数，度数为奇数的点有0/2个时候，可以一笔画，又删去一条边可以减少两个度数为奇数的点，所以删去$n/2-1$条边

Code：

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int main(){
	int T = read();
	while (T--){
		LL n = read();
		if (n & 1) printf("%lld\n", n * (n - 1) >> 1);
		else printf("%lld\n", n * (n - 1) / 2 - (n / 2 - 1));
	}
	return 0;
}
```


---

## 作者：_OJF_ (赞：0)

~~我不管我不管我就要上橙！~~

切入正题：这道题学过小奥的应该都能看出来，这分明就是个一笔画问题啊 ~~我不管我不管我后面就用“欧拉图”让人觉得高大上！~~。

可以看出这是一个$n$个顶点的完全图，当然属于连通图。直接按连通图做就行了！

首先考虑$2|n$的情况，这时每个顶点都是奇数度的，有两个奇数度点的连通图可以一笔画（含有欧拉通路），但其他的入度$=$出度就必须余下$n-2$个顶点每个点有一条路径，因此至少要放弃$\frac{n-2}{2}$条桥梁。此时答案：$\frac{n(n-1)-n-2}{2}$

其余情况每个顶点都是偶度的，它是欧拉回路（请自行bfs）。此时答案：$n(n-1)$

代码时间到！

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long a[100010];
int main(){
    cin>>t;
    for(int i = 1;i <= t;i++){
        cin>>a[i];
        long long l = a[i] * (a[i] - 1);
        if(a[i] % 2) cout<<l / 2<<endl;
        else cout<<(l - a[i] + 2) / 2<<endl;
    }
    return 0;
}
```
管，大，过，懂？

---

## 作者：BFqwq (赞：0)

## P6857

前置知识：欧拉路径与欧拉回路：

如果一张图中的一个路径包括每个边恰好一次，则该路径称为欧拉路径。

如果一个回路（即路径的第一个点就是最后一个点）是欧拉路径，则称为欧拉回路。

然后有一个小学奥数结论：一个无向图有欧拉回路等价于该图的所有点出度均为偶数，而一个无向图有欧拉路径等价于该图有 $0$ 或 $2$ 个点出度为奇数。这一结论的证明比较麻烦，在此不作赘述。有需要的可以自行百度。

而本题等价于找出一个最多的子图，使得该子图存在欧拉路径。

首先，对于一个点数为 $n$ 的完全图，其度数为 $n\times (n-1)\div 2$，其任何一个点的度数为 $n-1$。

考虑对 $n$ 的奇偶性进行分类。

如果 $n$ 为奇数，则所有点的出度都是偶数。那么显然，图中存在欧拉回路。由欧拉回路的定义，此时图中所有的边都可以被遍历，故答案为 $n\times (n-1)\div 2$。

如果 $n$ 为偶数，则所有点出度都是奇数。于是考虑删边。我们任意删掉一条边，都可以使得这条边两个顶点出度的奇偶性改变。于是我们考虑任选两个奇数点，删掉其连边，则这两个点均变为偶数点。当我们最后只剩下两个点奇数点时，删边结束。于是答案就是 $n\times (n-1)\div2-(n-2)\div2$。

code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200],str[200];int tt;
inline void print(register long long x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
int t,n;
signed main(){
	int t=read();
	while(t--){
		int n=read();
		if(n&1) print(n*(n-1)/2);
		else print(n*(n-1)/2-(n-2)/2);
	} 
	return 0;
}
```


---


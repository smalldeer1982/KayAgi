# 「MCOI-03」正方

## 题目背景

MC 中没有圆。

所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。

## 题目描述

给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。

比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)

因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。

## 说明/提示

#### 数据规模与约定

对于 $20\%$ 的数据，$a=b=c=d$。    
对于 $100\%$ 的数据，$1 \le a,b,c,d \le 9 \times 10^{18}$，$1 \le q \le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。

## 样例 #1

### 输入

```
3
1 3 3 1
2 4 7 8
2 3 1 4```

### 输出

```
4
0
8```

# 题解

## 作者：Thomas_Cat (赞：31)

今日月赛第一题题解：



我们先来观察题目，根据题目中给的这个正方形（如图）我们可以得出结论：

![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)

- 这个图必须是一个**正方形**

- 这个图必须由四部分的比例 $a : b : c : d$ 组成，否则无效

- 这个图的底是相等的，因为正方形四边边长相等不妨把底边 $AB ,BC , CD, AD$ 设为 $l$

  于是我们得出公式：$S \triangle AED : S \triangle AEB : S \triangle CEB : S \triangle DEC = a \times l : b \times l : c \times l : d \times l$ 。
  
- 根据上图公式，直接判断即可

---



接下来来讲一下判断方法和内容：



就拿样例来说：



- $a : b : c : d = 1 : 3 : 3 : 1$

我们发现，正方形的边长应该是 $(a+b),(c+d),(a+c),(b+d) = 1 + 3 = 4$ 。

我们就画出一个 $4 \times 4$ 的正方形：

紧接着，我们在上面 **作图** 如上图给出的图片一样，看看能找到多少个：

于是乎我们发现四种情况（**下图四个图形为四种情况，并不是四个正方形**）：



![](https://s1.ax1x.com/2020/10/31/BaZ3kD.png)


- $a : b : c : d = 2 : 4 : 7 : 8$ 

  我们发现，我们不可能组成一个正方形，因为：

  - $a+b \ne c+d$
  - $a+c \ne b+d$
  - $a+d \ne b+c$


- $a : b : c : d = 2 : 3 : 1 : 4$

  我们发现，正方形的边长应该是 $(a+b),(c+d) = (2 + 3) , (1 + 4)=5$

  我们画出 $5 \times 5$ 的正方形，寻找规律：

  ![](https://s1.ax1x.com/2020/10/31/Bam0Jg.png)

  于是乎我们发现了八种情况。



---



于是我们发现：

- 当 $a = b / a=c/a=d/b=c/b=d/c=d$  时，答案为 $4$ 。
- 当 $a = b = c = d$ 时，答案为 $1$ 。
- 当 $a \ne b \ne c \ne d$ 时，答案为 $8$ 。
- 当 $a,b,c,d$ 不构成四边形也就是：
  - $a+b \ne c+d$
  - $a+c \ne b+d$
  - $a+d \ne b+c$
  时，答案为 $0$ 。
  

于是我们得出代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        unsigned long long a,b,c,d;
        cin>>a>>b>>c>>d;
        if(a==b&&a==c&&a==d&&b==c&&b==d&&c==d) cout<<1<<endl;
        else if(a+b==c+d||a+c==b+d||a+d==b+c){
            if(a==b||a==c||a==d||b==c||b==d||c==d) cout<<4<<endl;
            else if(a!=b||a!=c||a!=d||b!=c||b!=d||c!=d) cout<<8<<endl;
        }
        else cout<<0<<endl;
    }
    return 0;
}
```

> Ps : 数据范围因为是 $1 \le a,b,c,d \le 10^{18}$，所以需要使用 `ull`

---

## 作者：Unordered_OIer (赞：27)

# P7042 题解
~~果然 MCOI 的题就是毒瘤~~  
[$\texttt{\color{red}{See} \color{orange}{in} \color{blue}{the} \color{green}{blog}}$](https://www.luogu.com.cn/blog/291706/solution-p7042)
## 题意
一个正方形内取一个点 $(x,y)$ ，分别与联结四个顶点，所形成的四个三角形面积比为 $a:b:c:d$ ，不计顺序，求存在多少个这样的 $(x,y)$ 。

## 解题
乍一看，这不是一道数学题吗，于是我们把这个 $(x,y)$ 设出来，然后列方程组准备对这个 $(x,y)$ 进行讨论：  

令 $t=\sqrt{a+b+c+d}$  

$$\begin{cases}\frac{xt}{2}=a \\ \frac{yt}{2}=b \\ \frac{(t-x)t}{2}=c \\ \frac{(t-y)t}{2}=d \end{cases}$$

然而你会发现这个方程很难解，就算解出来讨论解的个数也是很麻烦的。

所以我们果断地放弃这个思路，尝试新的思路：  

前置：不妨设 $a \leq b \leq c \leq d$ 。

首先很容易看出来答案除特殊情况**一定是 $4$ 的倍数**，因为可以把这个点按对边中点连线进行翻转得到另外的 $3$ 个满足的点。

数据告诉我们有一种特殊情况： $a=b=c=d$ ，这时我们只能取正方形的中点，翻转后还是同一个点，所以这种情况要输出 $1$ 。

然后我们想存在解的必要条件：

![img1](https://cdn.luogu.com.cn/upload/image_hosting/9q7xhlfg.png)

我们分别作 $FG$ 过 $E$ 平行于 $AB$ ， $HI$ 过 $E$ 平行于 $AC$ 。

![img2](https://cdn.luogu.com.cn/upload/image_hosting/pg9oj00p.png)

这时，我们发现 $S_{\triangle CED}+S_{\triangle AEB}=S_{\triangle AEC}+S_{\triangle BED}=\frac{1}{2}S_{ABDC}$ 。

于是我们发现解存在的必要条件是 $a+d=b+c$ ，换句话说，如果 $a+d \neq b+c$ ，一定输出 $0$ 。

我们考虑下一种情况：有两个相同（ $a=b$ ）

这时，所选的点 $E$ 一定在对角线上，例如：

![img3](https://cdn.luogu.com.cn/upload/image_hosting/lkfo1d59.png)

然后很容易得到如果有解则 $c=d$ ，再把 $E$ 按照比例移动就能得到了，考虑可以分别靠近四个角，所以答案为 $4$ 。

最后一种情况，也就是无特殊性质的情况：

![img4](https://cdn.luogu.com.cn/upload/image_hosting/2m0rdxee.png)

我们发现，总是能够作 $E'$ 沿对角线与 $E$ 对称，并且这个 $E'$ 也是符合条件的，而 $E$ 又可以靠近四个端点中任意一个，所以答案为 $2 \times 4=8$ 。

整理一下，得到思路（仍旧默认 $a \leq b \leq c \leq d$ ）：

1. 如果 $a+d \neq b+c$ ，输出 $0$ 。
2. 如果 $a=d$ ，输出 $1$ 。
3. 如果 $a=b$ ，输出 $4$ 。
4. 其他情况，输出 $8$ 。

于是我们就可以快乐的写代码了。

## Code
```cpp

//by HpyX
//never copy without permission

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll q,a[5];

int main() {
	cin >> q;

	while (q --) {
		for (int i = 1; i <= 4; i ++) cin >> a[i];
		sort(a + 1, a + 5);
		if (a[1] + a[4] != a[2] + a[3]) puts("0");
		else if (a[1] == a[4]) puts("1");
		else if (a[1] == a[2]) puts("4");
		else puts("7");
	}

	return 0;
}
```

## 后记
这道题是真的思维题，~~是真的我不会的题~~。

最后，祝洛谷月赛
### 越办越好
完结撒花~顺便求赞![](https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/qq/%E5%8F%AF%E6%80%9C.gif)

$\texttt{UPD:LaTeX崩了......}$

---

## 作者：一只书虫仔 (赞：13)

MCOI R3 A 官方题解

#### Description

求有多少个正方形内的点使得其于正方形的顶点相连分成的四个三角形面积比为 $a:b:c:d$。

$1 \le a,b,c,d \le 10^{18}$。

#### Solution

本题分为四种情况。

- 第一种答案为 $1$ 的情况（前 $20\%$ 的情况）

显而易见，选择的点只能为正方形两个对角线的交点。


- 第二种答案为 $8$ 的情况

我们分析对于所有数据的情况，比如看下面这张图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/pchkth3j.png)

（假设 $S_{\triangle APD}=a,S_{\triangle CPB}=b,S_{\triangle DPC} = c,S_{\triangle APB} = d$）

易得，只有在 $a+b=c+d$ 的情况下，才能满足有解。

简证：

假设 $P$ 到 $DA$ 的垂线长度为 $h_1$，到 $CB$ 的垂线长度为 $h_2$，到 $CD$ 的垂线长度为 $h_3$，到 $AB$ 的垂线长度为 $h_4$，正方形边长为 $k$，那么 $a=\dfrac{1}{2}h_1k,b=\dfrac{1}{2}h_2k,c=\dfrac{1}{2}h_3k,d=\dfrac{1}{2}h_4k$，$a+b=\dfrac{1}{2}(h_1+h_2)k=\dfrac{1}{2}k^2,c+d=\dfrac{1}{2}(h_3+h_4)k=\dfrac{1}{2}k^2$，$a+b=c+d$，得证。

（从这个结论中还可以得到 $a+b=c+d=\dfrac{1}{2} S_{\square ABCD}$，但貌似对于解本题并没有什么用（）

接下来，我们来分析一下对于普通情况满足 $a+b=c+d$ 的点的个数。（以下 $(a,b,c,d)$ 代表的是左边为 $a$，右边为 $b$，上面为 $c$，下面为 $d$）

- $(a,b,c,d)$
- $(a,b,d,c)$
- $(b,a,c,d)$
- $(b,a,d,c)$
- $(c,d,a,b)$
- $(c,d,b,a)$
- $(d,c,a,b)$
- $(d,c,b,a)$

一共有 $8$ 种。

- 第三种答案为 $0$ 的情况

不满足 $a+b=c+d$ 的情况。

- 第四种答案为 $4$ 的情况

当 $a,b,c,d$ 中有两个或三个数相等时，答案为 $4$。

原因很简单，当 $a,b,c,d$ 中有两个或三个数相等时，可以尝试把相等的数都替换成一个数再带回上面的列举结果中，会发现，有 $4$ 组重复的解，所以答案是 $4$。

注意，在特判第四种情况的时候要有一个前提，即在第二种情况提到过的：

> 易得，只有在 $a+b=c+d$ 的情况下，才能满足有解。

最后，注意一下特判的顺序即可。

---

## 作者：syf2008 (赞：4)

我来给一份暴力代码

首先，观察题目，我们发现只有4种情况（蒟蒻画图技术不好，见谅）

1.比例为1：1：1：1

![](https://cdn.luogu.com.cn/upload/image_hosting/lhz6a17m.png)

2.比例为x:x:y:y

![](https://cdn.luogu.com.cn/upload/image_hosting/p6lvsomi.png)

3.比例为a:b:c:d

![](https://cdn.luogu.com.cn/upload/image_hosting/m7cpw1so.png)

4.比例不统一，为0

上代码
```
#include <bits/stdc++.h>
using namespace std;
long long a[4],sum;
int q;
int main()
{
	scanf("%d",&q);
	while(q--)
	{
	scanf("%lld%lld%lld%lld",&a[0],&a[1],&a[2],&a[3]);
	sum=__gcd(a[0],__gcd(a[1],__gcd(a[2],a[3])));//判4个数的最小公约数
	a[0]/=sum;
	a[1]/=sum;
	a[2]/=sum;
	a[3]/=sum;//约分
	sort(a,a+4);//sort，判不合法
	if(a[0]==a[1]&&a[1]==a[2]&&a[2]==a[3]&&a[3]==a[0])
	printf("1\n");
else if(a[0]+a[3]!=a[1]+a[2])
	printf("0\n");
else if(a[0]==a[1]||a[0]==a[2]||a[0]==a[3]||a[1]==a[2]||a[1]==a[3]||a[2]==a[3])
	printf("4\n");
else printf("8\n");
	}
}
```

---

## 作者：Lgk_Juventudd (赞：4)

11月月赛A题解

月赛撞上了同校神仙出的模拟赛，所以赛时没做，赛后发现是一道简单分类讨论。

可能是CSP前最后一篇题解了(生前最后一篇题解

------------

设所求点为P

$20pts$做法

大家应该都看出来了前$20\%$的数据保证$a=b=c=d$，也就是说点P只能是两条对角线的交点，只有这一个点满足条件，于是输出1

```cpp
#include<iostream>
using namespace std;
int main()
{
    int t,a,b,c,d;
    cin>>t;
    while(t--){
        cin>>a>>b>>c>>d;
        cout<<1;
    }
    return 0;
}
```

------------

$100\%$做法

进行分类讨论(初中数学水平)

- 当$a=b=c=d$时，代码及讲解见上文

- 当$a,b,c,d$均不相等时

	将$a,b,c,d$从小到大排序。
 	- 若$a+d≠b+c$，即$a+d≠\frac{S_{ABCD}}{2}$，则无解，输出0
   - 若仅$a+d=b+c$，则有八个解。
   - 在满足$a+d=b+c$时，若仅$a=b$，则有四个解。
   - 在满足$a+d=b+c$时，若仅$b=c$，则只有两个解。
   
最后一点，注意$1≤a,b,c,d≤9\times10^8$，所以记得开long long。

```cpp
//码风勿喷
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
signed main()
{
    int t,sum=0;
    scanf("%lld",&t);
    while(t--){
        int a[4];//a[4]而不是a,b,c,d的原因是方便排序
        for(int i=1;i<=4;++i)   scanf("%lld",&a[i]);
        sum=a[1]+a[2]+a[3]+a[4];
        sort(a+1,a+4+1);
        if(a[1]+a[4]!=a[2]+a[3])	cout<<0<<endl;
        else{
            if(a[1]==a[2]&&a[2]==a[3])  {
                cout<<1<<endl;
            }
            else if(a[1]==a[2]&&a[2]!=a[3]) {
                cout<<4<<endl;
            }
            else if(a[2]==a[3]&&a[1]!=a[2]){
                cout<<2<<endl;
            }
			else	cout<<8<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Trafford1894 (赞：3)

~~话说这道题怎么没人写题解啊~~

### Description

给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$ 。四个数不分顺序。

### Solution

$\large\text{Part\space One}: 20pts$

当 $a=b=c=d$ 时，肯定只有一种情况。所以只要每个询问都输出 $1$ 就可以获得 $20pts$。

#### Code

```cpp


#include <iostream>
  
using namespace std;
  
int main() {
	int maxi;
  	cin >> maxi;
  	while(maxi--) {
		cout << "1\n";
	}
  
	return 0;
}
```

$\large\text{Part \space two}: 100pts$

既然题目不保证 $a,b,c,d$ 有序，那我们就先排个序。

我们可以先对结果为一的情况做一个特判，剩下的就是结果不唯一的情况。

因为这是一个正方形，所以四个三角形的底都是相同的，只用比较三角形的高。

假设 $a\leq b\leq c\leq d$，只有 $a + d = b + c$ 时情况才能成立。这样的话就会有 $8$ 种情况。在满足上述情况的条件下，如果 $d=c$，那么每个方向上都会有两个点重合，这样的话只有四种情况。

其他情况答案就为 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qcnl7i7h.png)

### ACCode

```cpp


#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdio>
#define int long long//开long long

using namespace std;

int _myList[5];
int _ques;
int _ans = 0;

void ParseIn() {
  for(int i = 1; i < 5; i++) {
    scanf("%lld", _myList + i);
  }
}

void Core() {
  _ans = 0;
  sort(_myList + 1, _myList + 5);//先排序
  int one = _myList[1];
  int two = _myList[2];
  int three = _myList[3];
  int four = _myList[4];
  if(one == two && two == three && three == four) {
    _ans = 1;//特判
    return;
  }

  if(one + four == two + three) {
    if(four == three) {
      _ans = 4;
      return;
    }

    _ans = 8;
    return;
  }

  _ans = 0;
}

void WriteOut() {
  printf("%lld\n", _ans);
}

signed main() {
  scanf("%lld", &_ques);
  while(_ques--) {
    ParseIn();
    Core();
    WriteOut();
  }

  return 0;
}
```



---

## 作者：sysong (赞：2)

# 题解P7042 「MCOI-03」正方

### 题意

求一个正方形内部有多少个点与四个顶点的连线把正方形分成的面积等于 $a : b : c : d$。

（刚开始做题的时候下面没有配图，然而后来补上了，就好想多了。）

---

### $Solution$

我们先画个图看看：

![](https://cdn.luogu.com.cn/upload/image_hosting/w8jmjsj3.png)

可以发现正方形被分割成四个等底的三角形。

不难想到，三角形的面积由底和高决定，那么我们就把高作出来。

![](https://cdn.luogu.com.cn/upload/image_hosting/q1mvmpku.png)

由于矩形的性质，可以得到： $GE + EI = EF + EH$ 。

然后根据题目中 $a , b , c , d$ 的含义，又得到： $GE : EI : EF : EH = a : b : c : d$（顺序可以调换） 。

所以我们对于输入的四个数字进行有解的判断：`if(a+b==c+d||a+c==b+d||a+d==b+c)`，如果不符合，直接输出 0 。

如果有解呢？

我们对于原图形进行旋转和对称，可以看出（旋转 90° ，180°，270° 时，上下或左右对称时还可旋转），共有 8 种情况，如果有重复的高长，情况数会减半，共 4 种。然而——

**注意：如果四个输入都相等，只有一个解（在对角线交点），这个是样例里没有的。**

分类如下：

```c++
if(a!=b||b!=c||c!=d||a!=c||a!=d||b!=d)
	if(a!=b&&a!=c&&a!=d)printf("8\n");
	else printf("4\n");
else printf("1\n");
```

---

### $C++ \quad code$

```c++
#include <cstdio>
using namespace std;

int main(){
	int n,a,b,c,d;
    scanf("%d",&n);
	while(n--){
		scanf("%d%d%d%d",&a,&b,&c,&d);
		if(a+b==c+d||a+c==b+d||a+d==b+c){
			if(a!=b||b!=c||c!=d||a!=c||a!=d||b!=d)
                if(a!=b&&a!=c&&a!=d)printf("8\n");
            	else printf("4\n");
			else printf("1\n");
		}
		else printf("0\n");
	}
	return 0;
}
```



***by jsntsys***

$2020.11.3$



#### CSP rp++!



---

## 作者：梨衣 (赞：1)

## 一道面积相关的简单数学问题
一点与正方形顶点连线，将整面积划分为四部分，且正方形边长相等，于是面积比转化为三角形高之比，又因为相对的两三角形高之和等于正方形边长，可以利用此条件判断。

从给出的四个数开始，只有最小值与最大值作为两相对的三角形的高时，才能尽可能满足两组数之和都等于正方形边长，不满足时输出 $0$ 。

若满足，当两组数不完全相同时，由于位置不同，靠近每个边长时都有分别靠近两个端点的情况，答案为 $8$ 。

当两组数相同时，不重复方案仅有一组对边分别靠近两个端点的情况，答案为 $4$ 。

特别的，当四个数相同时，只能取正方形中心，答案为 $1$ 。
## 代码如下
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#define ull unsigned long long
using namespace std;
ull s[5];
inline ull read()
{
	ull x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	ull q=read();
	while(q>=1){
		q--;
		s[1]=read(),s[2]=read(),s[3]=read(),s[4]=read();
		sort(s+1,s+5);
		if(s[1]==s[2]&&s[3]==s[4]&&s[1]==s[3])
			printf("1\n");
		else if(s[1]+s[4]!=s[2]+s[3])
			printf("0\n");
		else if(s[1]==s[2])
			printf("4\n");
		else printf("8\n");
	}
	return 0;
}
```
## 谢谢观看

---

## 作者：借我昔日热忱 (赞：1)

## 本题是一个清新的签到题~

**首先需要手动模拟一下，你会发现情况十分固定：**

一个也妹有

有1个

有4个

有8个

为什么呢，这里其实是利用了正方形能够通过**两条对角线来轴对称，通过中心来达到中心对称**。

当点位于非特殊位置就可以实现 **两条轴对称+中心对称** 来达到八个相同解。

当点位于对角线上就可以实现 **中心对称+另外一条轴对称** 来达到四个相同解。

当点位于中心。你就无法做任何对称就只能有一个解。

具体如何代码实现呢：

**排序+判断 也就是 sort+if**

你可以先把读入的四个比例进行一个**排序**，这里推荐直接使用sort 。但是sort需要一个数组，所以直接搞个五个空间的一维数组即可。

然后你就会发现，因为这是一个正方形被划分成了四个部分，所以两个比例相加必定等于另外两个比例相加，也就是两块划分后的图形拼在一起一定是一个正方形的一半。所以当你发现两两相加之和不相等的时候就可以直接输出0.

```cpp
	if(a[0]+a[3]!=a[1]+a[2]){
		printf("0\n");continue;
	}
```

虽然说经过上面一层判断之后你能确定一定有解，但是有几个解，又如何判断呢？这个地方就利用了正方形对角线涉及的一个对称性问题。

有1个的情况：这个点正好在正方形的中心，也就是他应该满足四个比例均相等。**a=b=c=d；**

```
if(a[0]==a[1]&&a[1]==a[2]){printf("1\n");continue;}
```


有四个的情况其实也比较好想：这个点位于对角线上，因为对角线被中心平分成四段，所以相对应的，就会出现四个解。而这个时候，你会发现，你排序完之后的一定是**a=b,c=d；**
```cpp
if(a[0]==a[1]&&a[2]==a[3]){printf("4\n");continue;}
```

什么时候有八个呢：当他不位于对角线的时候，这个时候就没有什么特殊规律，所以不是很方便判断，但是因为一共就四种情况，所以，机智的我们可以直接把他写在最后，在前面每种情况下面加个 continue；

下面就是本题的全代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
unsigned long long a[4];
int main(){
	int q;scanf("%lld",&q);
	for(int i=1;i<=q;i++){
		scanf("%lld%lld%lld%lld",&a[0],&a[1],&a[2],&a[3]);
		sort(a,a+4);
		if(a[0]+a[3]!=a[1]+a[2]){printf("0\n");continue;}
		if(a[0]==a[1]&&a[1]==a[2]){printf("1\n");continue;}
		if(a[0]==a[1]&&a[2]==a[3]){printf("4\n");continue;}
		printf("8\n");continue;
	}
	return 0;
} 
```
感谢观看，欢迎留言



---

## 作者：蒟蒻·巨弱 (赞：1)

## 开门见山放个$AC$代码，再分析

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 105
long long n, m, i, j, k, s, ans, a, b, c, d, x, y, z;
int main()
{
	scanf ("%lld", &n);
	for (i=1; i<=n; i++){
		scanf ("%lld%lld%lld%lld", &a, &b, &c, &d);
		if (a+b == c+d || a+c == b+d || a+d == b+c){
			if (a == b && b == c && c == d) printf ("1\n");
			else{
				if (a == b || b == c || c == d) printf ("4\n");
				else printf ("8\n");
			}
		} 
		else{
			printf ("0\n");	
		} 	
	}
	return 0;
}
```
这题就是一道数学题，一共有四种情况：$0, 1, 4, 8$

首先，这题是一个点与四个顶点，分成四个**等底**三角形，也就是说，$a, b, c, d$ 其实是四个等底三角形高的比，所以

```cpp
if (a+b == c+d || a+c == b+d || a+d == b+c)
```
**是判断是否为正方形**（只要有四条高里面有两组高相等，就是正方形）

### 否：输出 $0$，换行

是则继续判断：

```cpp
if (a == b && b == c && c == d)
```
### 等底等高面积相等，只有一个点满足，就是正方形的中心，输出$1$并换行

否则继续判断：

```cpp
if (a == b || b == c || c == d)
```
### 只要有其中一组相等，就有四个点满足，输出 $4$ ，换行，前面条件都不满足就输出 $8$ ，换行

**完美结束！**

---

## 作者：Mobius127 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P7042)

## 主要思路：数论

四种情况，先看如何判断有解。

很简单的数论，我们很容易知道，$abcd$即为这四个三角形高简化过的比例，又因为这是从一个正方形中分割出来的，那么就必会有：$a+d=b+c$(此时$abcd$已排好序)，所以，无解的情况判断一下即可。

我们来看有解的情况：

1. 答案为1时就是1:1:1:1的情况，不予解释。

1. 答案为4时，就是两组数字分别相等的情况，这时互换一下，点仍会重合，所以会少掉4种情况。那么答案为8的情况就很好推了。

# AC Code：

```
#include <stdio.h>
#include <algorithm>
#include <cstring>
#define N 1000005
using namespace std;
typedef long long LL;
int n;
LL a[5];
int solve(){
	if(a[1]==a[2]&&a[3]==a[4]&&a[1]==a[3]) return 1;//1:1:1:1
	if(a[1]+a[4]!=a[2]+a[3]) return 0;
	if(a[1]==a[2]&&a[3]==a[4]) return 4;
	return 8;
}
int main(){
	scanf("%d", &n);
	for(int i=1; i<=n; i++){
		scanf("%lld%lld%lld%lld", &a[1], &a[2], &a[3], &a[4]);
		sort(a+1, a+5);
		printf("%d\n", solve());
	}
	return 0;
}
```


---

## 作者：yewanxingkong (赞：0)

一个比较诡异的计算几何题。我做这道题时思路想了半天。

首先这个面积比看起来会很难受，因为你根本不知道是哪个面积比那个面积。不过我们不用考虑那么多。三角形面积是二分之一的底乘高，由于四个三角形底相同，所以只要是个存在的点，必然有两块面积比等于另两块面积比。

我们先设不同的四个数为四个三角形的面积比： $a:b:c:d$ 。

我们先假设 $a+b=c+d$ ，那么合法的点有哪些呢？

我们首先认为面积比按顺序指的是固定的一块面积，合法的点分成的面积比有 $8$ 种：$a:b:c:d||a:b:d:c||b:a:c:d||b:a:d:c$ $c:d:a:b||c:d:b:a||d:c:a:b||d:c:b:a$

那么有数相等时呢？

假设 $a=b$ 此时会发现除去重复的话只剩了 $4$ 种，也就是有一半的情况变成重复了的。 $a=c,a=d$ 的情况同理。

而且我们会发现如果我们固定 $a$ 为初始最左边的面积比时，判断的情况是相同的，所以我们就可以得到下面这个究极简单的代码了：
```cpp
#include<cstdio>
using namespace std;
int main() {
    register int q;
    scanf("%d",&q);
    while(q--){
    	register long long a,b,c,d;
        scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
	    register int chu=0;
        if(a+b==c+d||a+c==b+d||a+d==b+c){
            chu=8;
            if(a==b)chu/=2;
            if(a==c)chu/=2;
            if(a==d)chu/=2;
    	}
    	printf("%d\n",chu);
    }
    return 0;
}
```


---

## 作者：猫猬兽 (赞：0)

## 作为月赛T1，还是不错的

### 题意：
求有多少个正方形内的点使得其于正方形的顶点相连分成的四个三角形面积比为 $a:b:c:d$ 。

## 20points
一上来，蒟蒻会想着骗分。

对于20%的数据： $a=b=c=d$ 。

所以四个三角形面积相等，该点一定位于正方形中心。

**每组询问输出1即可。**

## 100points
对于T1，拿20分肯定是不够的。

我们把 $a,b,c,d$ 排个序，分为4种情况讨论，理清思路。

**（1）如果 $a+d≠b+c$ ，答案为0。**

**（2）如果 $a=b=c=d$ ，答案为1。**

**（3）如果 $a+d=b+c$ ，而且 $a,b,c,d$ 互不相等，答案为8。**

**（4）如果 $a+d=b+c$ ，而且 $a,b,c,d$ 有两个及以上相等，但不是全相等，答案为4。**

## 上代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long t,a[10],i;
int main()
{
	cin>>t;
	for(i=1;i<=t;i=i+1)
	{
		cin>>a[1]>>a[2]>>a[3]>>a[4];
		sort(a+1,a+5);
		if(a[1]==a[4])cout<<1<<endl;
		else if(a[1]+a[4]==a[2]+a[3]&&a[2]==a[3])cout<<4<<endl;
		else if(a[1]+a[4]==a[2]+a[3]&&a[1]==a[2])cout<<4<<endl;
		else if(a[1]+a[4]==a[2]+a[3])cout<<8<<endl;
		else cout<<0<<endl;
	}
}
```
### 完结撒花

---

## 作者：SpectatorX (赞：0)

本题需要运用一点简单的几何知识。

~~懒得画图，就放原图吧~~

![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)

首先考虑点的存在性。容易知道，所分出的四个三角形底边相等，则它们的面积之比就等于它们的高之比。又知对顶的两个三角形高之和是一定的（等于边长），于是我们得到了能分出合法的三角形的第一个条件：

$$a+b=c+d$$

（由于所给的$a,b,c,d$是无序的，所以需要遍历一次~~反正只用4次~~）

接下来考虑合法点的数量。

**当$a=b=c=d$时**，化为最简比即为$1:1:1:1$。此时合法的点有且仅有一个（正方形的几何中心）。

**当$a:b=c:d$时**，合法的点有$4$个。画一个类似九宫格的东西，中间的$4$个交点即为所求~~应该看得懂意思吧~~。

余下情况，合法的点有$8$个~~不用证明了吧，方法类似~~。

$Code$:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int q;
int d[5],sum;
inline int read()//快读 
{
	int x=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x;
}
inline void write(int x)//快写 
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
signed main()
{
	q=read();
	while(q--)
	{
		sum=0;
		for(register int i=1;i<=4;++i) d[i]=read(),sum+=d[i];//存一下sum，稍后方便判断无解情况 
		int fl=1;
		for(register int i=2;i<=4;++i)
		{
			if(sum==(d[1]+d[i])*2)//遍历判断a+b是否等于c+d 
			{
				fl=0;
				break;
			}
		}
		if(fl)
		{
			puts("0");
			continue;
		}
		else
		{
			sort(d+1,d+5);
			int x=unique(d+1,d+5)-d-1;//对d进行去重，通过去重后数组规模来判断a:b与c:d的关系 
			if(x==1) puts("1");//a:b:c:d=1 
			else write(x<<1);//otherwise
		}
	}
 	return 0;
}
```

---

## 作者：XyzL (赞：0)

## 题意：

无需解释，自行读题

## 分析:

对于 $20$ 分的代码，被直线分割的四个三角形全等故输出 $1$ 。

而对于所有情况，可以考虑额，由于四个三角形的底都为正方形的边长，是相同的，所以我们只需要看高就可以了。

我们可以先给样例排边序。

```
1 3 3 1
2 4 7 8
1 2 3 4
```
可以发现，有解的情况可满足 $a_1 + a_2 = a_3 + a_4$，对应几何就是：**一对高相等**。

那么当 $a_1 = a_2$ 且 $a_3 + a_4$时，就只有 $1$ 种情况啦...


## 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MaxSize = 20;

char buf[1 << MaxSize], *p1, *p2;

#define GetChar() \
    ((p1 == p2) ? (p2 = buf + fread(p1 = buf, 1, 1 << MaxSize, stdin), p1 == p2 ? EOF : *p1++) : *p1++)

template <class T>
inline void in(T &x) {
    x = 0;
    register bool f = 0;
    register char c = GetChar();
    while (c < 47 || c > 58) {
        f |= (c == '-'), c = GetChar();
    }
    while (c > 46 && c < 59) {
        x = (x << 3) + (x << 1) + (c & 15), c = GetChar();
    }
    x = f ? (~x + 1) : x;
}

const int MaxN = 5;

int T;

long long a[MaxN];

int main() {
	in(T);
	while (T--) {
		for (register int i = 1; i <= 4; ++i) {
			in(a[i]);
		}
		sort(a + 1, a + 4 + 1);
		if (a[1] == a[2] && a[2] == a[3] && a[3] == a[4]) {
			puts("1");
			continue;
		}
		if (a[1] == a[2] && a[3] == a[4]) {
			puts("4");
			continue;
		}
		if (a[1] + a[4] == a[2] + a[3]) {
			puts("8");
			continue;
		}
		puts("0");
	}
	return 0;
}
```


---


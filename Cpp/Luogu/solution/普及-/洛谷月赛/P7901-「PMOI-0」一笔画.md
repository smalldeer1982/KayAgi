# 「PMOI-0」一笔画

## 题目背景

（原 LZOI-1，改名已经 PMOI 成员同意）

## 题目描述

言琢დ 在一个 $2n \times 2n$ 的矩阵中坐标为 $(x,y)$ 的一个点上。

现在 lhm 需要任意选择矩阵上的一个点作为起点，然后依次经过 $k$ 个点，移动规则如下：

- 每次移动只能选择与目前相邻（上下左右）的点作为本次移动的目标点。不能选择矩阵外的点。

- 每一轮移动必须正好经过矩阵上的所有点，不能重复经过同一个点。每经过所有点后，视为一轮移动结束。

- 注意依次经过 $k$ 个点后，最后一轮移动可能并没有完成。

现在 lhm 想知道，他最少会经过 言琢დ 多少次。

## 说明/提示

### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/37e99o4k.png)

$\color{red}დ$ 代表 言琢დ 所在位置，红色线表示 lhm 第一轮的路径。

### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n,k\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $10^4$ |
| $2$ | $30$ | $10^9$ |
| $3$ | $40$ | $10^{18}$ |

对于所有数据，保证 $1\le n,k\le10^{18}$，$1\le x,y\le 2n$。

## 样例 #1

### 输入

```
2 16 1 1```

### 输出

```
1```

# 题解

## 作者：言琢დ (赞：9)

**upd：修正部分公式错误。**

**upd：添加结论的证明。**

验题人题解。

## A 潇湘の雨

#### Sol

考虑一次遍历是 $(2n)^2$ 的，所以若遍历 $k$ 次，那么是

$$\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor$$

轮再加上一些点。

不难发现还剩

$$\begin{aligned}&~k\mod (2n)^2\\=&~k-k\times\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor\end{aligned}$$

个点。

那么既然我们可以找每个 $(x,y)$ 的下一个点，$<(2n)^2$ 个点是不需要考虑的。

据此答案即为

$$\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor$$

#### std

```cpp
signed main(){
	int n = init(), k = init();
	print(k / (n * n * 4));
}
```

#### 尾声

发现大家的题解都没有提到一个结论：

> 任意一个 $(2n)\times(2n)$ 的方阵，一定存在一种遍历方式可以 **循环遍历**。

这个结论我可以简单地证明一下：

考虑从 $(1,n)$ 位置开始，先向左到 $(1,1)$，再向下到 $(1,2)$，再向右到 $(2,n)$，然后遍历完整个左半边之后，再去蛇形遍历右半边。

举一个 $n=2$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/f0jpvgn6.png)

按照这种遍历方式，我每次取 $\color{red}\text{დ}$ 字符的后一个位置，一定能保证最后一轮除非恰好满足 $(2n)^2=k$ 否则一定不经过 $\color{red}\text{დ}$。

举个例子，如果 $\color{red}\text{დ}$ 在 $(1,2)$，那我就选 $(1,1)$，我先按照这个顺序遍历掉剩下的 $15$ 个格子，再去走 $(1,1)$，一定最优。

如果 $\color{red}\text{დ}$ 在 $(4,4)$，那我就选 $(3,4)$，每次都选 $\color{red}\text{დ}$ 位置的下一个格子，这样就证明出这个结论了。

这个结论才是我们命制这道题目的原意，好像大多数题解从结论出发，忽略了这个模型的证明，令人感到遗憾。

---

## 作者：Ginger_he (赞：7)

# 题目描述
在一个 $2n\times 2n$ 的矩阵中走 $k$ 步，每一轮每个点只能走一次，求出经过点 $(x,y)$ 的最少次数。（一轮的定义为经过矩阵中所有的点）
# 题解
数据范围是 $10^{18}$，显然是一道数学/找规律题。因为矩阵中有 $2n\times2n$ 个点，且**必定存在一个点，使得最后经过的点为给定的点**，所以我们不难得到此题的公式为 $\dfrac{k}{4n^2}$。  
可能有人会对上面的深色字体有疑问，下面我们来简要证明一下：如果从 $(x,y)$ 开始走能遍历整张图，那从最后到达的那个点反向走回来就必定到达 $(x,y)$。现在问题转为证明**在 $2n\times2n$ 的矩阵中，从任意一个点开始走都能遍历整张图。**  
如果我们对这张图进行**黑白染色**，就会得到 $2n$ 个黑点和 $2n$ 个白点。不难发现，每次操作都是从一个点走到它的异色点，又因为两种颜色的点个数相同，所以必定能遍历整张图，原命题得证。
## 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x,y;
int main()
{
	scanf("%lld%lld%lld%lld",&n,&k,&x,&y);
	printf("%lld\n",k/4/n/n);
	return 0;
}
```


---

## 作者：Da_un (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P7901)

题目大意是在一个 $2n \times 2n$ 的矩阵上有一个目标点 $(x,y)$，你可以从矩阵上的任意一点出发，每一次都可以向上下左右四个方向移动一步，走完所有点才算作一次完成，才可以有下一次挑选位置的机会。问依次经过 $k$ 个点后，最少经过目标点 $(x,y)$ 多少次。

## 思路
看数据范围，一定是一道结论题。

既然题目要求的是求出最少经过目标点 $(x,y)$ 的次数，那么我们就尽量不走那个点就行了。

我们可以举几个例子：

1. 对于如下 $2\times2\times2\times2$ 的图：

      [![5weXGV.jpg](https://z3.ax1x.com/2021/10/19/5weXGV.jpg)](https://imgtu.com/i/5weXGV)

	红体字母表示目标点。

	我们可以这样走：

	[![5wGJNF.jpg](https://z3.ax1x.com/2021/10/19/5wGJNF.jpg)](https://imgtu.com/i/5wGJNF)

2.  对于如下 $2\times3\times2\times3$ 的图：

	[![5wJUIS.jpg](https://z3.ax1x.com/2021/10/19/5wJUIS.jpg)](https://imgtu.com/i/5wJUIS)
    
    红体字母表示目标点。
    
	 我们可以这样走：
     
     [![5wr1De.jpg](https://z3.ax1x.com/2021/10/19/5wr1De.jpg)](https://imgtu.com/i/5wr1De)
     
再画几个这样的图形也就基本上明白了对于任意的一个 $2n \times 2n$ 的图形，总会存在一个点和一条路径，使得从这个点出发，沿着这条路径走，遍历整个图形，最后经过的点是目标点。

了解了这些之后，代码应该也就能写出来了，还需要分几类讨论，具体看代码。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,k,x,y;//看数据范围,需要开long long 
int main()
{
	cin>>n>>k>>x>>y;
	if(2*n*2*n>=k){//当图形中的点大于等于k时 
		if(2*n*2*n==k)//当图形中的点等于k时
			cout<<1;//最后不得不走到目标点,故为1 
		else//当图形中的点大于k时 
			cout<<0;//完全可以不走到目标点,故为0 
	}
	else{//当图形中的点小于k时
		cout<<k/(2*n*2*n);//尽量少走目标点,每走完2n*2n个点后才经过目标点一次 
	}
	return 0;
	//完结撒花~~ 
} 
```
### [AC记录](https://www.luogu.com.cn/record/60108474)

---

## 作者：Terraria (赞：4)

## 题目大意

给出一个 $2n\times 2n$ 的网格图，已知一共要走 $k$ 个格子。

定义**一轮**为连续不重复地经过 $4n^2$ 个格子。不难得到一共要走 $\lfloor\dfrac{k}{4n^2}\rfloor$ 轮。求经过 $(x,y)$ 的最少次数。

**不过题目中没有说明：一轮结束后，下一轮是在目前的基础上再上下左右走（忽略出界的情况）还是另选任意一个点。希望出题人能及时更新。**

附：在讨论版中问了，是任选另一个点。

于是我们对这两种情况都讨论一下：

- 任选另一个点：

由于是每一轮中都需要经过每一个点，所以一轮中最少经过 $1$ 次 $(x,y)$。那么答案就显而易见了，是 $\lfloor\dfrac{k}{4n^2}\rfloor$。

---

注：此部分内容可忽略（

- 从上一轮结束的点出发（想用数学归纳法证明这样子走也是可行的，但是还没证明出来，先留个坑）：

这个就比较麻烦了。~~（然后我想了两个证明方法，都还没证明出来。后续证明出来了会及时补上的qaq）~~

1. 用数学归纳法进行证明。

首先 $n=1$ 时，是一个 $2\times 2$ 的网格。对于每一种可能的 $(x,y)$，都可以选择一个与其相邻的点开始，延逆时针方向走。最终，可以保证每一轮都满足要求，且至少经过一次 $(x,y)$。

对于 $n \ge 2$，可以将其分成 $4$ 个 $n \times n$ 的表格。例如，$n=2$ 时，可以分成 $4$ 个 $2 \times 2$ 的表格。对于每一个 $(x,y)$，一定在这 $4$ 个网格中的一个网格上。因此，$(x,y)$ 所在的网格满足：可以找一个与 $(x,y)$ 相邻的点，在这个 $n \times n $ 的网格里走，每走过 $n^2$ 个点之后就可以经过 $(x,y)$。然后，第 $n^2+1$ 个点再次走到那个选择与之相邻的点，继续走。

2. 根据 $(x,y)$ 的奇偶性分类讨论，一共 $4$ 种情况，都找到一个合法的方式进行移动。

~~不会了/kk~~

~~未完待续~~

---

因此，答案即为 $\lfloor\dfrac{k}{4n^2}\rfloor$。

代码就不给了。

关于“从上一轮结束的点出发”的证明方法也欢迎大佬通过私信、回复等方式提出可行的证明方法，谢谢！

---

## 作者：Chtholly_L (赞：4)

### 题意：

给出一个 $2n\times2n$ 的矩阵，可以任选一个点为起点走 $k$ 步，问最少能经过点 $(x,y)$ 几次。

---

### 分析：

题目的数据范围这么大，搜索肯定会炸，而又作为一个 T1 肯定是有 $\mathcal{O}(1)$ 的做法。

既然问到了最少能通过几次，那么就代表能不走这个点就不走这个点。

怎样做到能不经过就不经过呢？我们可以发现，无论是哪个矩阵的哪个点，最终总存在遍历完整个矩阵，最后以这个点为终点的路径，以这个点为终点肯定就是经过次数最小的。那么我们最少遍历这个点的次数肯定就是在走 $k$ 步的情况下遍历**完**整个矩阵的次数，**注意是遍历完！**

据此，我们就可以推论出最终经过的次数等于 $\left\lfloor\frac{k}{2n\times 2n}\right\rfloor$。

---

### 代码

```cpp
#include<cstdio>

using namespace std;

int main(){
    long long n,k,x,y;  //别忘了开 long long
    scanf("%lld%lld%lld%lld",&n,&k,&x,&y);
    printf("%lld",k/(n*2*n*2));  //自带的向下取整
    return 0;
}
```

---

## 作者：Buried_Dream (赞：3)

这到题范围到 ${10}^{18}$，一开始想要爆搜，看到数据范围就知道这是一道规律题。

## 题意：

在一个 $2n \times 2n$ 的矩阵里，走 $k$ 步，每一轮每个点只能走一遍，从任意坐标走，走完整个矩形，并输出经过坐标 $x$ 和 $y$ 的个数。

## 思路：

既然看出是一道规律题，那么就来找规律。

首先每经过一轮肯定会经过坐标为 $x$ 和 $y$ 的点，

而且起点可以是矩阵上的任意点，

那么 $x$ 和 $y$ 在哪里就对答案没有影响，

所以说就来找 $n$ 和 $k$ 的关系，更准确来说是找矩形的点数和步数之间的关系。

也就是找 $2n \times 2n$ 和 $k$ 之间的关系。

每经过一轮就会经过他一遍，那经过的次数就是 $k/2n \times 2n$。

## AC Code:

```cpp
/*
Work by: 看我后面——
goal： Cheat points
algorithm：？？？
thinking support：？？？
*/
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
#include<cstring>
#define int long long
#define il inline
#define re register
#define inf 0x3f3f3f3f
#define FJH 1314
using namespace std;

const int maxn = 5e6 + FJH;
const int MAXN = 2e6 + 32;

inline int read()//读入优化
{
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-'){w = -1;}ch = getchar();}
	while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
	return s*w;
}
il void print(int x){//输出优化
	if(x < 0) putchar( '-' ),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

signed main(){//前面用的#define int long long
	int n, m, x, y;
	n = read(), m = read(), x = read(), y = read();
	print(m/(n * n * 4));
}

```





---

## 作者：Editzed (赞：2)

### 简单的找规律题
奉行能不走红点（დ）就不走的原则，只要在一轮之内步数不达到全部格子，就不会经过红点（დ）


------------
# code

```cpp
#include<bits/stdc++.h>
#define L long long
using namespace std;
L int sum;//记录格子总数 
L int n,k,x,y;
int main(){
	cin>>n>>k>>x>>y;
	sum=2*n*2*n;
	if(sum==k){//如果刚好步数一轮之内全用完 
		cout<<1;//必然会走到一次，输出1 
		return 0;
	}
	cout<<k/sum;//如果有多轮，直接看在步数之内能走几轮 
	return 0;
}
```

---

## 作者：HappyCode (赞：1)

### 思路
这题是道数学题。

每经过一次琢喵就会经过坐标为 $(x,y)$ 的点，但是起点可以是的任意点，那么琢喵在哪里就对答案没有影响。

所以我们找矩形的点数 $n$ 和步数 $k$ 的关系,也就是找 $2n \times 2n$ 和 $k$ 的关系。每走一轮就会经过琢喵一遍，经过的次数是 $k\div(2n \times 2n)$。

### 提醒
$x$ 和 $y$ 在洛谷可以不读入，但在某些 OJ 就必须读入，否则会离奇报错，所以建议读入所有变量。  
Python 做完除法要输出整数必须强制转换成 `int` 类型。  
最后提醒一句：**十年 OI 一场空，不开 `long long` 见祖宗。**

### 代码
结论题，不给注释
```cpp
#include<iostream>
using namespace std;
long long n,k,x,y;
int main(){
    cin>>n>>k>>x>>y;
    cout<<k/(n*2*n*2)<<endl;
    return 0;
}
```

```python
a=input().split()
a[0]=int(a[0])
a[1]=int(a[1])
print(int(a[1]/(a[0]*2*a[0]*2)))
```

### 更新日志
upd 2021.10.25：补充了 Python 代码  
upd 2022.4.12：
1. 更改了 Python 代码中的错误，并将该错误加入提醒中。
2. 将 结论题 修改为 数学题。
3. 将没添加/英文的句号全部添加/修改。

---

## 作者：NATO (赞：1)

因为一个边长 $2 \times n$ 的矩阵中一定有偶数个奇点（$8 \times n-16$ 个），所以一定可以被一笔画。而只有遍历一遍矩阵后才可以重走，所以必定  $k$ 步会完整走 $k/(4 \times n^2)$ 再向下取整次矩阵(也就是经过言琢დ的次数)，那么多出的步数就可以不走到言琢დ在的地方。因此就得出了代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,xx,yy;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k>>xx>>yy;
	cout<<k/(2*n*2*n);
}
```


---

## 作者：HYdroKomide (赞：1)

### 思路：
想到思路就是数学题。

首先，由于正方体边长是偶数，我们必有结束于某一点的一种走法。所以如果移动次数 $k\lt 2n\times2n$ ，则不需要经过标记点。

但是如果移动次数 $k\ge 2n\times2n$，则我们必须经过标记点。但是我们依然需要缩小经过标记点次数，于是我们使每一轮移动结束于标记点。

这样经过标记点次数的最小值就是 $k\div(2n\times2n)$，且与标记点的坐标无关。

### 程序如下：
```cpp
#include<cstdio>
#define ri register int
namespace FASTIO{
	inline long long read(){
	    register long long x=0,f=1;
		static char ch=getchar();
	    while(ch>'9'||ch<'0'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
	    while(ch>='0'&&ch<='9'){
			x=(x<<3)+(x<<1)+(ch^48);
			ch=getchar();
		}
	    return x*f;
	}
	inline void write(long long x){
	    if(x<0)putchar('-'),x=-x;
	    register int i=0;
	    static char s[20];
	    while(x||i==0)s[i++]=x%10+'0',x/=10;
	    while(i--)putchar(s[i]);
	    putchar('\n');
	}
}//加了快读和一堆优化，但是没啥卵用
int main(){
    register long long n,k;
	n=FASTIO::read()<<1,k=FASTIO::read();//将 n 在输入时直接 *2
	FASTIO::write(k/n/n);//按照公式输出
	return 0;
}
```

### THE END

---

## 作者：Coros_Trusds (赞：0)

答案显然就是 $\dfrac{k}{(2n)^2}$。

下面来说一下原因。

给定一个矩阵，边长为偶数。

那么经过了 $k$ 个点之后，一定会仍然处在一轮移动之中。（废话

因为满足该矩阵边长为偶数，故可以想到：

在最后一轮移动中，一定可以避开 დ。

**因为我们一定可以在一局中随意地移动，并且完整的走完一圈。**

![](https://cdn.luogu.com.cn/upload/image_hosting/37e99o4k.png)

所以只需要利用 C++ 整除特性自动获得向下取证即可。

答案就是上面所说的，根本不需要用到 $x,y$，应该只是想要混淆各位 $\rm AKer$ 的注意力。

代码给一下吧：

```cpp
#include <iostream>
using std::cin;
using std::cout;

int main(void){
    long long n,k;
    cin>>n>>k;
    
    cout<<k/(4*n*n);
    return 0;
}
```

---

## 作者：WsW_ (赞：0)

乍一看很复杂，其实 $x$ 和 $y$ 根本就没用。  
因为在一个矩阵中，显而易见的是：每次都只走一步的话，能够做到在没有点重复走的前提下，以任意地方为起点，并以任意非起点的地方为终点。  
然后在看题目：``他最少会经过 言琢დ 多少次``。于是对于每轮，我们都把 言琢დ 所在位置作为终点，他身边任意一个点作为起点，这样可以保证经过次数最少。  
因为要走 $k$ 步，也就是说会一共经过 $k$ 个点，而走完每轮需要 $n\times n\times4$ 步，而每走**完（没走完就不会经过 言琢დ ，因此要向下取整）** 一轮我们都会经过一次 言琢დ ，所以经过 言琢დ 的次数为$\lfloor \frac{k}{n\times n\times4} \rfloor$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main(){
	scanf("%lld%lld",&n,&k);
	n=n*n*4;//计算矩阵大小
	printf("%lld",k/n);//计算走完的次数，C++会自动向下取整
	return 0;
}
```
[极致速度代码](https://www.luogu.com.cn/paste/drgiqzar)

---

## 作者：哈士奇憨憨 (赞：0)

# [传送门](https://www.luogu.com.cn/problem/P7901)
# 题意
在 $2n \times 2n$ 大小的图上,每一次都可以向上下左右四个方向移动一步，依次经过 $k$ 个点后，求坐标为 $(x,y)$ 的地方最小会进过多少次。
# 思路
其实这道题就是求 $k$ 到底能走多少次 $2n \times 2n$ 大小的图，也就是求 $ \dfrac{k}{2n × 2n}$ 向下取整的值。
## 坑点：
+ 因为 $10^{18}\times2\times10^{18}\times2 $ 会爆 ```int``` ，所以要开 ```long long```。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x,y;//坑点
int main(){
    cin >> n >> k >> x >> y;
    cout << k / (n * n * 4);
    return 0;
}
```

---

## 作者：LoserCode (赞：0)

# 题意

很简单，给出一个 $2n * 2n $ 的矩阵问至少能经过点 $k$ 几次。

# 分析

如果题意简单，没有什么思路那么推荐大家看数据范围。

可以看出，本题最大数据达到了 $10^1$$^8$ 显而易见了，本题又是第一题，考虑 $O(n)$ 或 $O(1)$ 的算法，也就是数学问题。



其实质是其实就是 $ (2n)^2 $ $/k$  。
因为我们易证得，最少情况要把整个图遍历一遍，就会得到最少情况，过目标点一次，遍历一遍之后就重新再遍历，能遍历 **整个** 地图几遍，答案就是几。

# Code

```
#include<iostream>
using namespace std;
int main()
{
	long long n,k,x,y;
	cin>>n>>k>>x>>y;
	cout<<k/(2*n*2*n);
	return 0;
}
```
###### 不开long long 见祖宗


---

## 作者：ylinxin2010 (赞：0)

## P7901题解

**本题思路：**

1. 因为每一轮移动必须正好经过矩阵上的所有点，且不能经过矩阵外的点，也不能经过重复的点。

2. 并且我们知道，每一轮移动能走过 $4\times n \times n$ 个格子。

3. 还有，必有一个点，从此点出发，能走过除题目给出的点的所有点。

4. 所以此题的公式为—— $\dfrac{4 \times n \times n}{k}$ 这就是这题的答案，不要忘记用六十四位整型变量哦。

接下来——上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long read() //快读模板，注意数据范围
{
    long long x=0,f=1;
	char ch=getchar();
    while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
    return x*f;
}
int main()
{
	cin.tie(0);
	cout.tie(0);
	long long n=read(), k=read(), x=read(), y=read();
	cout<<k/(n*n*4); //套公式
	return 0;
}
```

---

## 作者：MINECRAFT_eternal (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7901)

一道简单的思维题。

# 题目分析

我们提取一些关键信息：
>矩阵大小为 $2n \times 2n$。
>
>需要在矩阵中依次经过 $k$ 个点。

仔细分析，就会发现 დ 的所在位置 $(x,y)$ 其实是干扰项。

![](https://cdn.luogu.com.cn/upload/image_hosting/37e99o4k.png)

就题目中给出的样例而言，**无论以哪一个点为起点，结果都是经过一次 დ 就可以走完所有点。**

并且，Lanuxhem 可以走多轮，那么答案就自然出来了，即需要经过的总点数 $\div$ 矩阵总点数：

$k \div [(2 \times n) \times (2 \times n)]$

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,k,x,y;
int main(){
	scanf("%lld%lld%lld%lld",&n,&k,&x,&y);
	printf("%lld",k/((2*n)*(2*n)));
	return 0;
}
```
**讲诚信，勿抄袭。**

---

## 作者：luozhichen (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P7901)


看完这道题后，便觉得事情肯定不会只有暴搜这么简单。再看看数据范围，太大了吧！于是便知道事情真的没那么简单。

## 进入正题：

看到题目首先会想到这三种情况（图有点丑，请见谅！）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9za9om4f.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ab9diwmq.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/n8g861nv.png)

发现只要没到完整的 $2n\times2n$ 次，那就不会踩到终点。

所以，代码如下：（注意数据范围）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x,y;//注意范围
int main(){
	cin >> n >> k >> x >> y;
	long long m = n * n * 4;
	cout << k / m;
	return 0;
}
```

听说考前发题解会RP++！！！

画图不易，记得给个赞！

---

## 作者：int32 (赞：0)

注意到在一轮移动中必会经过 $(x,y)$ 一次。

那么只要算出在 $k$ 步中走过的轮数，即 $\lfloor\dfrac{k}{4n^2}\rfloor$（注意下取整，应为总有方法使得在最后剩余步数小于 $4n^2$ 时不走到 $(x,y)$ ）。

于是直接输出 $\lfloor\dfrac{k}{4n^2}\rfloor$ 即可。

```python
n,k,x,y=map(int,input().split()) # 输入
print(k//(4*n*n)) # 注意是 "//"
```

---


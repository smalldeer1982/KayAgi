# 「PMOI-0」假·儒略日

## 题目背景

（原 LZOI-1，改名已经 PMOI 成员同意）

Lanuxhem 听说 言琢დ 在 S-PSC 考场上就切穿了 **儒略の日**，想得到 言琢დ 手中的考场 AC 代码。

但是 言琢დ 不想给他，所以 言琢დ 就扔给了 Lanuxhem 下面这题，并说：“切了这道题就给你。”

lhm-02

## 题目描述

给定一个正整数 $n$ 和另一个正整数 $d$。

要求构造一个长度为 $2n$ 的数列 $\{a_{2n}\}$，满足：

1. $1\sim n$ 之中每个数字均出现 $2$ 次。
2. 对于数字 $i$，若 $i$ 为奇数，则数字 $i$ 两次出现位置之差 **必须** 超过 $d$。
3. 对于数字 $i$，若 $i$ 为偶数，则数字 $i$ 两次出现位置之差 **不能** 超过 $d$。

由于 Lanuxhem 想得到 言琢დ 的代码，但他并不会这道题，所以他只能请聪明的你帮他完成这题。

## 说明/提示

#### 样例说明

数字 $1$ 两次分别出现在位置 $2,6$，差为 $4(>2)$；

数字 $3$ 两次分别出现在位置 $1,4$，差为 $3(>2)$；

数字 $2$ 两次分别出现在位置 $3,5$，差为 $2(\le2)$。

#### 数据范围

| 子任务编号 | 分值 | 特殊限制 |
| :-: | :-: | :-: |
| $1$ | $36$ | $n\le10$ |
| $2$ | $24$ | $d=\left\lfloor\dfrac{n}{2}\right\rfloor$ |
| $3$ | $40$ | $\times$ |

对于 $100\%$ 的数据：$1\le\dfrac{d}{2}\le n\le10^6$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
3 1 2 3 2 1```

## 样例 #2

### 输入

```
3 6```

### 输出

```
-1```

# 题解

## 作者：ylinxin2010 (赞：6)

## P7902题解
**本题思路：**

1. 构造方法：将偶数全部放在奇数之间，并且按顺序输出奇数。

2. 这题若无解我们分奇数和偶数的情况讨论。

3. 当给定的 n 为奇数时，同一个奇数应相差 $\dfrac{n}{2} \times 2 + \dfrac{n}{2}$ 并且应小于 d 否则，同一个奇数应相差 $\dfrac{n}{2} \times 2 + \dfrac{n}{2}$ 并且应小于等于 d 就输出负一。

接下来——上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    int x=0,f=1;
	char ch=getchar();
    while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
    return x*f;
}
int main()
{
	cin.tie(0);
	cout.tie(0);
	int n=read(), d=read();
	if((d>n/2*2+n/2&&n%2==1)||(d>=n/2*2+n/2&&n%2==0))
	{
		cout<<"-1";
		return 0;
	}
	for(int i=1;i<=n;i+=2)
		cout<<i<<" ";
	for(int i=2;i<=n;i+=2)
		cout<<i<<" "<<i<<" ";
	for(int i=1;i<=n;i+=2)
		cout<<i<<" ";
	return 0;
}
```

---

## 作者：plm123 (赞：2)

### 0.前言
$\quad$ 说点闲话，平心而论，如果不是后面讲评那一大堆夭蛾子，这个全是构造题的比赛出的质量确实有点低，但这些题目单个拿出来的是不会有太多问题的，因此希望大家冷静看待做这道题目。不要因比赛与讲评而对题目本身有很大情绪。
## 1.最优策略
1. ### 考虑极限的 $d$
 $\quad$  好了，开始考虑最优策略吧。首先应该讨论的是本题的$-1$究竟应在什么时候输出。稍微用手算一下$m$靠近$1,2$时与靠近$2n$时，应该可以发现在靠近$2n$时不能构造，但如果用奇数填两侧，偶数填中间的序列很容易就可通过$d\leq n$情况。例如这样\
 $1\quad3\quad2\quad2\quad1\quad3$\
 因此，我们认为这个可构造的极限$d$应该在$(n,2n)$之间且与$n$存在联系 ~~不然这还可做吗~~至于具体为多少，得看构造出的数列究竟能承受多大的$d$为极限。
 
2. ### 分奇偶讨论数列
 紧接着我们分奇数与偶数想一下他们究竟该怎么构造。从上面的奇数填两侧，偶数填中间的例子中我们应该受到了一些启发，因为偶数之间的距离可以为$1$（没有设置下限），且这样又刚好分割开了奇数，那么当然的，偶数就应该如 $2,2,4,4,6,6……$ 这样存在于数列中间。
 
 那么奇数呢？因为奇数距离没有设置上限从题意要求**所有奇数**来看，这个序列的相同奇数应该拥有相等的长度。因为偶数由上已经固定,故而奇数距离总和$W$已经固定，那么距离$a_i$大了，$a_{i+2}$就会更小，是得序列中最小距离更容易小于等于$d$，也就意味着更不可能是要求的标准的数列。所以在所有奇数距离相等，都是       $\quad1,3,5,7…………1,3,5,7$这样构造时奇数的距离最远。分析得到 $d$ 最大不能为$\frac{3}{2} n$，即我们认为的这个我们构造的标准数列的两相同奇数的距离。
 ```cpp
int val=1,js;
    if(f==0)js=(n/2)+1;
    else js=(n/2);
    for(int y=js+1;y<(ans);y+=2){
		if(a[y]!=0)break;
        if(f==0){
            a[y]=val*2;
            a[y+1]=val*2;
        }
        if(f==1){
            a[y]=val*2;
            a[y+1]=val*2;
        }
        val++;
    }
```
这是构造奇数的代码，其余请读者自行推出。码风请见谅。
## 2.证明
那么为什么这是最优呢？我们考虑能否通过刚才的构造出的数列经过有限次交换得到更优数列。首先奇数与奇数交换由上文所述不行，偶数已经两个紧挨，交换也不会是更优。\
那么考虑奇偶互换，对于值不与交换的$a_i$，$a_j$相同的奇偶，他们的距离没有影响。而对于交换的奇数$a_i$，它与与它相同的$a_k$的距离甚至缩小了！\
 $1\quad3\quad2\quad2\quad1\quad3$\
 佷容易发现，$1$无论与哪个偶数交换，它与另一个$1$的距离都在缩小，而交换的偶数距离又变大了。任一一次交换只能带来更坏的影响。因此，无论怎么交换，都不可能使刚才的数列更优，正确性得证。
 ### 最后
 如果对构造题过于生疏，建议多练练思维题，~~毕竟我也是个蒟蒻，还厚着脸皮给人家建议~~。完结撒花。

---

## 作者：HYdroKomide (赞：2)

### 思路：
一道妥妥的构造题，提供一种个人认为最简单的思路。（话说这场比赛怎么有两道构造题？）

首先，相同偶数位置之差不能 $\gt d$，所以将偶数全部挨着放即可。

由于奇数之间的距离必须 $\gt d$，我们将所有偶数放在中间，序列两边放上奇数。

我们需要尽可能使每个奇数的距离更远，所以要将两边的奇数都由小到大排列，这样每个奇数之间的距离相同，任意两个奇数之间的距离也最大。

如果这样放都不能成立，也就是 $d+1$ 大于奇数个数与偶数个数 $\times2$，即 $d>\lfloor\dfrac{n}{2}\rfloor\times2 + n-\lfloor\dfrac{n}{2}\rfloor-1$，那么输出无解即可。


### 程序如下：

```cpp
#include<cstdio>
#include<cmath>
#define ri register int
namespace FASTIO{
	inline int read(){
	    register int x=0,f=1;
		static char ch=getchar();
	    while(ch>'9'||ch<'0'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
	    while(ch>='0'&&ch<='9'){
			x=(x<<3)+(x<<1)+(ch^48);
			ch=getchar();
		}
	    return x*f;
	}
	inline void write(int x){
	    if(x<0)putchar('-'),x=-x;
	    register int i=0;
	    static char s[10];
	    while(x||i==0)s[i++]=x%10+'0',x/=10;
	    while(i--)putchar(s[i]);
	    putchar(' ');
	}
}
using namespace FASTIO;//以上是头文件
using namespace std;
int main(){
	register int n,d;
	n=read(),d=read();
	if(d>((n>>1)<<1)+(n-(n>>1)-1)){//判断 d 是否大于奇数个数+偶数个数*2-1
		write(-1);
		return 0;
	}
	for(ri i=1;i<=n;i+=2)write(i);//依次输出奇数一遍
	for(ri i=2;i<=n;i+=2)write(i),write(i);//中间的偶数输出两遍
	for(ri i=1;i<=n;i+=2)write(i);//再依次输出奇数一遍
	return 0;
}
```

### THE END

---

## 作者：Da_un (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P7902)
题目大意就是构造一个长为 $2n$ 且满足题目条件的一个序列，如果不能构造成，则输出 $-1$。

## 思路
这里讲一下最优解的做法。

偶数放里面，奇数放外面。

对于偶数，题目中给出对于数字 $i$，若 $i$ 为偶数，则数字 $i$ 两次出现位置之差不能超过 $d$。因为给出的 $d$ 的数据范围是 $d$ 最小等于 $2$，所以我们让两个相同的偶数靠在一起是最优的，并且不会影响奇数的最优解。

对于奇数，题目中给出对于数字 $i$，若 $i$ 为奇数，则数字 $i$ 两次出现位置之差必须超过 $d$。考虑是整体最优的方案，我们可以在偶数都在里面的前提下，让任意相同两个奇数的距离一样，这样的话，可以成为最优解。否则，就会出现某两个奇数距离近，某两个奇数距离远的情况，显然，距离近的那两个奇数的距离是小于这个定值的，故这种情况并不是最优解。

对于偶数，我们直接输出，对于奇数，我们判断这个定值与 $d$ 的大小关系，然后再输出。

举个例子：

- 对于长度为 $4$ 的排列，最优排列为：
	```cpp
	1 3 2 2 4 4 1 3
	```
- 对于长度为 $5$ 的排列，最优排列为：
	```cpp
	1 3 5 2 2 4 4 1 3 5
	```

知道了这些，代码也就应该可以写出来了。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,d;
int j,o;
int a[2000100],aa,b[2000100],bb;
void pre()
{
	for(int i=1;i<=n;i++)
		if(i%2==1)
			a[++aa]=i;
		else
			b[++bb]=i;
}
int main()
{
	scanf("%d%d",&n,&d);
	pre();
	//o表示1~n中偶数数量乘2,便于一起输出
	//j表示1~n中奇数数量,便于分两次输出 
	//o,j根据n的奇偶性变化 
	if(n%2==1){
		o=(n-1);
		j=(n-1)/2+1;
	}
	else{
		o=n;
		j=n/2;
	}
	//cout<<o<<' '<<j<<endl;
	if(j+o-1>=d){
		//偶数不管怎样都符合条件 
		//j+o即为这个定值,j+o-1>=d即j+o>=d+1,奇数符合条件 
		for(int i=1;i<=aa;i++)
			printf("%d ",a[i]);
		for(int i=1;i<=bb;i++)
			printf("%d %d ",b[i],b[i]);
		for(int i=1;i<=aa;i++)
			printf("%d ",a[i]);
		//输出 
	}
	else//不符合 
		cout<<-1;
	return 0;
	//完结撒花~~ 
}
```
### [AC记录](https://www.luogu.com.cn/record/60108496)

---

## 作者：ImposterAnYu (赞：0)

# 解析
很明显，我们可以运用到贪心思想，将偶数尽可能地挨在一起，而奇数尽可能地放远一点。比如 $n = 5$ 时，可以这样构造：
```
1 3 5 2 2 4 4 1 3 5
```
然后，题目已经说了：

$$1 \leq \frac{d}{2}$$

不等式两边 $\times 2$，便可以得到：

$$2 \leq d$$

即：

$$d \ge 2$$

而我们的构造方法就算在 $d = 1$ 时也合法，所以我们并不需要判断 $d$ 是否太小。

那么究竟在什么条件下，程序需要输出 $-1$ 呢？

我们再来看一下 $n = 5$ 的情况：
```
1 3 5 2 2 4 4 1 3 5
```
可以发现：$n = 5$ 时，两个相等奇数之间的距离为 $7$，任意两个相等奇数之间夹了 $4$ 个偶数，$2$ 个奇数（但是不包括这个奇数自己）。

而 $1,2,3,4,5$ 中，有 $2$ 个偶数，$3$ 个奇数，$2 \times 2 + 3$ 刚好等于 $7$！

同时，对于任意正整数 $n$，$1$ 到 $n$ 之间有 $\frac{n}{2} + n \mod 2$ 个奇数，所以，如果程序输出了 $-1$，那么一定要满足（公式中，$k = \frac{n}{2} + n \mod 2$）：

$$d \ge 2(n - k) + k$$

至于构造过程就看代码吧……

## AC code
```c++
#include<bits/stdc++.h>
using namespace std;
int n,d,i,a[2000005],k,l,s;
int main(){
	cin >> n >> d;
	k = n / 2 + n % 2;
	if(d >= 2 * (n - k) + k){
		cout<< -1 << endl;
		return 0;
	}
	for(i = 1; i <= k; i++){//前面 k 个数以及最后 k 个数为奇数。
		a[i] = a[(n - k) + n + i] = i * 2 - 1;
	}
	l = 2 * n - k + 1;
	s = 2;
	for(i = k + 1; i < l; i += 2){//剩下的数就是偶数
		a[i] = a[i + 1] = s;
		s += 2;
	}
	for(i = 1; i <= 2 * n; i++){
		cout<< a[i] << " " ;
	}
	cout<< endl;
	return 0;
}
```

---


# 『JROI-4』淘气的猴子

## 题目背景

众所周知，jockbutt 是一个可爱的女孩纸。
![](https://cdn.luogu.com.cn/upload/image_hosting/73du6v88.png)

## 题目描述

jockbutt 有一个正整数序列，长度为 $n$，分别为 $a_1,a_2...a_n$，她非常喜欢这个序列，平时都非常爱惜它们。

可是有一天，当 jockbutt 在和你约会的时候，有一只淘气的小猴子改变了这个序列。

猴子操作了 $m$ 次。  

猴子的操作有两种类型：

- $\texttt{1 x y}$ 表示第 $x$ 个元素加上第 $y$ 个元素。
- $\texttt{2 x y}$ 表示第 $x$ 个元素乘上第 $y$ 个元素。

特别且显然地，当 $x=y$，新的 $x$ 就等于原来的 $x$ 的两倍或平方。

序列最后结果形如 $b_1,b_2...b_n$。

等到 jockbutt 回来时，全洛谷的人都在看猴子。$\colorbox{white}{\color{white}{\text{其实 jockbutt 才是他们看的猴子吧}}}$

jockbutt 非常生气，希望你能告诉她这个序列最初的形态，也就是 $a_1,a_2,a_3,...,a_n$，否则她就会嘤嘤嘤...

## 说明/提示


**本题采用捆绑测试。**

|  子任务编号 | 分值 | 特殊限制 |
| :-----------: | :---:| :-----------: |
| 1 | 25 | $1\leq n,m\leq 10$ |
| 2 | 25 | $1\leq n\leq 100$，$1\leq m \leq 50 $ |
| 3 | 50 | 无 |

- 对于 $100\%$ 的数据满足 $1\leq n\le 10^3$，$1\leq m\le 200$，对于任意的 $ i $ $ ( 1\leq i \leq n ) $，有 $1\leq a_{i},b_{i} \leq 2^{60}$。

## 样例 #1

### 输入

```
5 5
12 1 12 4 2
1 3 2
1 4 3
2 3 4
1 5 2
2 1 3```

### 输出

```
1 1 2 1 1
```

# 题解

## 作者：Dream_weavers (赞：18)

## 题意

有一个长度为 $n$ 的序列 $a$，对这个序列进行 $m$ 次操作，得到序列 $b$，操作类型具体如下：

- ```1 x y``` 表示第 $x$ 个元素加上第 $y$ 个元素。

- ```2 x y``` 表示第 $x$ 个元素乘上第 $y$ 个元素。 

如果 $x=y$，那新的 $x$ 就等于原来的 $x$ 的两倍或平方。

现在给出序列 $b$ 和 $m$ 次操作，请还原出序列 $a$。

## 思路

体面看起来挺吓唬人，~~甚至线段树的题刷多了还以为是线段树~~，但就是一道简单的模拟。

建一些数组或一个结构体记录这些操作，然后**逆序**进行操作。这里逆序指操作顺序相反，加变成减（$b_x-b_y$），乘变成除（$b_x\div b_y$）。如果 $x=y$ 就要特判一下，两倍变成除以二（$b_x\div2$），平方变成开方（$\sqrt{b_x}$）。最后就能还原出序列 $a$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,m,b[N];
struct node{//建一个记录操作的结构体
	int opt,x,y;
}f[N];
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++){//输入操作
		scanf("%lld%lld%lld",&f[i].opt,&f[i].x,&f[i].y);
	}
	for(int i=m;i>0;i--){//进行“逆序”操作
		int opt=f[i].opt,x=f[i].x,y=f[i].y;
		if(opt==1){
			if(x!=y)b[x]-=b[y];
			else b[x]/=2;//特判x=y
		}else if(opt==2){
			if(x!=y)b[x]/=b[y];
			else b[x]=sqrt(b[x]);//特判x=y
		}
	}
	for(int i=1;i<=n;i++)printf("%lld ",b[i]);//还原
    return 0;
}

```

---

## 作者：_Give_up_ (赞：5)

这道题虽然是个红题，但有一个人一直都没对（好吧我承认，那个人就是我，提交了 3 次才过）

## 思路
用已知的数组倒着推，猴子的操作如果是第一种情况，`a[x] -= a[y]`，如果是第二种情况，`a[x] /= a[y]`。

**但是！** 这道题有个**大**坑，就在题目的第八行：`特别且显然地，当  x=y，新的 x 就等于原来的 x 的两倍或平方。` 那么我们得判断 `x` 是否等于 `y`，如果等于，`a[x] /= 2` 或 `a[x] = sqrt(a[x])`。

## Code
```cpp
#include<bits/stdc++.h> 
#define N 1010

using namespace std;

typedef long long ll;

int a[N];

struct rec
{
    int k,x,y;
};

rec z[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,m;
    cin >> n >> m;
    for (int i=1;i<=n;i++)
        cin >> a[i];
    for (int i=1;i<=m;i++)
        cin >> z[i].k >> z[i].x >> z[i].y;
    for (int i=m;i>=1;i--)
    {
        if (z[i].k==1)
        {
            if (z[i].x==z[i].y) a[z[i].x] /= 2;
            else a[z[i].x] -= a[z[i].y];
        }
        else
        {
            if (z[i].x==z[i].y) a[z[i].x] = sqrt(a[z[i].x]);
            else a[z[i].x] /= a[z[i].y];
        }
    }
    for  (int i=1;i<=n;i++)
        cout << a[i] << " ";
    cout << endl;
    return 0;
}
```

---

## 作者：HappyCode (赞：4)

### 思路
很明显我们恢复序列时要把加法变成减法，把乘法变成除法，但因为猴子是从前往后操作的，所以我们要从后往前恢复。

> 特别且显然地，当 $x=y$，新的 $x$ 就等于原来的 $x$ 两倍或平方。

如果 $x=y$，且操作为 $1$ 号操作，我们就需要把 $b_x$ 的值除以 $2$，若为 $2$ 号操作，我们就需要把 $b_x$ 变为 $\sqrt{b_x}$。

### 提醒
恢复序列时要从最后一个操作开始恢复！

### 代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,m,k[205],x[205],y[205];
long long b[1005];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    for(int i=1;i<=m;i++){
        cin>>k[i]>>x[i]>>y[i];
    }
    for(int i=m;i>=1;i--){
        if(k[i]==1){
            if(x[i]==y[i]){
                b[x[i]]/=2;
            }else{
                b[x[i]]-=b[y[i]];
            }
        }
        if(k[i]==2){
            if(x[i]==y[i]){
                b[x[i]]=sqrt(b[x[i]]);
            }else{
                b[x[i]]/=b[y[i]];
            }
        }
    }
    for(int i=1;i<=n;i++){
        cout<<b[i]<<' ';
    }
    return 0;
}

---

## 作者：charleshe (赞：3)

这题刚开始以为是线段树，但看了一下操作发现应该是数组直接模拟。

按照题意模拟，当猴子的操作为加法时我们做减法，当猴子的操作为乘法时我们做除法。

真这么简单吗？按此模拟，三个 subtask 都会出现 WA，结果 $0$ 分。

为什么呢？注意题目的说法：

> 特别且显然地，当 $x=y$，新的 $x$ 就等于原来的 $x$ 的两倍或平方。

还没看懂？我们再看一组数据：

```
2 2
12 25
1 1 1
2 2 2
```
正确输出为 `6 5`，按刚才的代码输出为 `1 1`。

出现这种错误的原因是：此时两个加数（乘数）均是变量，而代码将其看为一个变量和一个不变量。此处需特判一下。

注意事项：

- 由于我们要逆推猴子的操作，因此需要一个栈存储猴子的每次操作，然后反向倒退。可以用结构体来存储每一次的操作。

考虑了这些，代码便好写了。

```cpp
#include <iostream>
#include <stack>
#include <cmath>
using namespace std;
int n,m;
int a[1001];
int k,x,y;
struct id{//存储每一次操作的结构体
	int k,x,y;
	id(int a,int b,int c){
		k=a;
		x=b;
		y=c;
	}
};
stack<id> s;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>k>>x>>y;
		s.push(id(k,x,y)); 
	}
	while(!s.empty()){//反向操作，注意考虑x=y的情况
		id t=s.top();
		s.pop();
		if(t.k==1){
			if(t.x==t.y) a[t.x]/=2;
			else a[t.x]-=a[t.y];
		}
		else{
			if(t.x==t.y) a[t.x]=sqrt(a[t.x]);
			else a[t.x]/=a[t.y];
		}
	}
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
}
```


---

## 作者：BlackPanda (赞：3)

**[题目传送门](https://www.luogu.com.cn/problem/P8318)**

------------
### 题意：
给出一个长度为 $n$ 的操作后的序列，然后给出 $m$ 次操作过程，每次给出操作类型 $op$、操作数 $x$ 和 $y$，求出操作前的原始序列。

在操作中，如果 $x=y$，那么新的 $x$ 就分别等于原始 $x$ 的
两倍或平方。**即：如果 $op=1$，那么新的第 $x$ 个元素就等于它的两倍；如果 $op=2$，那么新的第 $x$ 个元素就等于它的平方。**


------------
### 思路：
模拟题，但是坑点很多。

- 由于给出的是操作后的序列，所以我们在还原时需要倒序还原，例如：$n=2$，两次操作分别是 $op1,x1,y1$ 和 $op2,x2,y2$。那么我们就需要先还原 $op2,x2,y2$ 再还原 $op1,x1,y1$。

- 同上，需要倒序还原，如果操作中是乘法，还原时就需要用除法，加减法同理。

- #### 题目中还提到 $x=y$ 的情况。当 $op=1$ 时，原操作是将第 $x$ 个元素 $×2$，那么我们在还原时就需要将它 $÷2$；同理，当 $op=2$ 时，原操作是将第 $x$ 个元素变成它的平方，那么我们在还原时就要将它进行 ```sqrt()```。

------------
### code：

```cpp
#include <bits/stdc++.h>
using namespace std;

inline long long read(){
    long long s=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*f;
}

int n,m;
long long a[1005];
int op[1005],x[1005],y[1005];

int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    for(int i=1;i<=m;i++){
        op[i]=read();x[i]=read();y[i]=read();
	}
    for(int i=m;i>=1;i--){ 
    	if(op[i]==1){
		    if(x[i]==y[i]){
		    	a[x[i]]/=2;
			}
			else{
	    		a[x[i]]-=a[y[i]];			
			} 


		}
		else{
		    if(x[i]==y[i]){
		    	a[x[i]]=sqrt(a[x[i]]);
			}
			else{
				a[x[i]]/=a[y[i]];
			}

		}
	}
    for(int i=1;i<=n;i++){
        printf("%lld ",a[i]);
    }
    return 0;
}
```


---

## 作者：快斗游鹿 (赞：3)

## 题意

有一个经过了 $m$ 次操作，长度为 $n$ 的序列，现需复原原序列。

## 思路

观察两种操作类型，易发现，每次操作只有第 $x$ 个元素在变化，第 $y$ 个元素是不会发生改变的。所以我们可以先开个数组存储猴子的操作，然后反推。遇到 $1$ 类型操作就将 $a_x$ 置为 $a_x-a_y$。遇到类型 $2$ 则将 $a_x$ 置为 $a_x/a_y$。特别需要注意的，就是当 $x=y$ 时，对于类型 $1$，要将 $a_x$ 置为 $\dfrac{1}{2}\times a_x$，对于类型 $2$，则要将 $a_x$ 置为 $\sqrt{a_x}$。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,m,a[10005];//2^60要开ull
unsigned long long zt[201][5];
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++)scanf("%lld%lld%lld",&zt[i][0],&zt[i][1],&zt[i][2]);
	for(int i=m;i>=1;i--){
		if(zt[i][0]==2){//类型2
			if(zt[i][1]==zt[i][2]){
				a[zt[i][1]]=sqrt(a[zt[i][1]]);
			}
			else{
				a[zt[i][1]]/=a[zt[i][2]];
			}
		}
		else{//类型1
			if(zt[i][1]==zt[i][2]){
				a[zt[i][1]]=0.5*(a[zt[i][1]]);
			}
			else{
				a[zt[i][1]]-=a[zt[i][2]];
			}
		}
	}
	for(int i=1;i<=n;i++)cout<<a[i]<<' ';//输出
	return 0;
}

```


---

## 作者：Lvyuze (赞：2)

这道题是我 AC 最快的月赛 T1。

这篇题解是我最长的一篇题解。

## 题意

给你一个数组 $a$ 以及一些操作，让你把现在的序列恢复成最初的形态。

## 思路

正序操作要还原，就要逆序操作。

我们可以把操作定义为一个二维数组，去倒序遍历。

如果是第一种操作，本来将 $x$ 个元素**加上**第 $y$ 个元素，要还原就要将第 $x$ 个元素**减去**第 $y$ 个元素。

如果是第二种操作，本来将 $x$ 个元素**乘上**第 $y$ 个元素，要还原就要将第 $x$ 个元素**除以**第 $y$ 个元素。

代码很简单：

```cpp
#include<iostream>
using namespace std;
int n,m,ot[1010][4];
long long a[1010],b[1010];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>b[i];
    for(int i=1;i<=m;i++) cin>>ot[i][1]>>ot[i][2]>>ot[i][3];
    for(int i=m;i>=1;i--){
        if(ot[i][1]==1){
            a[ot[i][2]]=b[ot[i][2]]-b[ot[i][3]];
            b[ot[i][2]]=b[ot[i][2]]-b[ot[i][3]];
        }
        else if(ot[i][1]==2){
            a[ot[i][2]]=b[ot[i][2]]/b[ot[i][3]];
            b[ot[i][2]]=b[ot[i][2]]/b[ot[i][3]];
        }
    }
    for(int i=1;i<=n;i++) cout<<b[i]<<" ";
    return 0;
}
```

一交，就会[这样](https://www.luogu.com.cn/record/74915066)。

为什么？

看题：

>特别且显然地，当 $x=y$，新的 $x$ 就等于原来的 $x$ 的两倍或平方。

照上面的方法，现在就会变成 $0$ 或 $1$。

所以我们只需要特判一下。

$x=y$ 时，如果是第一种操作，把现在的数除以 $2$；如果是第二种操作，把现在的数 `sqrt` 一下就好了。

上 AC 代码：

```cpp
#include<iostream>
using namespace std;
int n,m,ot[1010][4];
unsigned long long b[1010];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>b[i];
    for(int i=1;i<=m;i++) cin>>ot[i][1]>>ot[i][2]>>ot[i][3];
    for(int i=m;i>=1;i--){
        if(ot[i][1]==1){
            if(ot[i][2]!=ot[i][3]) b[ot[i][2]]-=b[ot[i][3]];
            else b[ot[i][2]]/=2;
        }
        else{
            if(ot[i][2]!=ot[i][3]) b[ot[i][2]]/=b[ot[i][3]];
            else b[ot[i][2]]=sqrt(b[ot[i][2]]);
        }
    }
    for(int i=1;i<=n;i++) cout<<b[i]<<" ";
    return 0;
}
```

---

## 作者：Nygglatho (赞：1)

我们可以这样解释样例：

| 初始 | $1$ | $1$ | $2$ | $1$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 第 1 次 | $1$ | $1$ | $3$ | $1$ | $1$ |
| 第 2 次 | $1$ | $1$ | $3$ | $4$ | $1$ |
| 第 3 次 | $1$ | $1$ | $12$ | $4$ | $1$ |
| 第 4 次 | $1$ | $1$ | $12$ | $4$ | $2$ |
| 第 5 次 | $12$ | $1$ | $12$ | $4$ | $2$ |

那么我们反着考虑，从 $m$ 至 $1$，如果遍历的这次操作为 $\texttt{1 x y}$，那么将第 $x$ 个元素减去第 $y$ 个元素；如果这次操作为 $\texttt{2 x y}$，那么将第 $x$ 个元素除以第 $y$ 个元素。

由于是反着考虑，所以第 $y$ 个元素显然是进行过后面遍历的操作，而前面的操作由于已经减去（除去）了，所以显然正确。

例如样例的第二次，因为是反着操作，所以 $4$ 并没有变成 $1$，$12$ 仍然是会变成 $12 \div 4$，也就是 $3$ 的。

此外，需要特判的就是 $x = y$ 的情况，这个题目中也说了，那么如果是加法的话，那么既然变成 $2x$，那么推回去就是 $x \div 2$，乘法则是变成 $\sqrt{x}$。

Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
long long b[100001];
int t[100001], x[100001], y[100001];
int main() {
    int n, m;
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf ("%lld", &b[i]);
    for (int i = 1; i <= m; ++i) scanf ("%d%d%d", &t[i], &x[i], &y[i]);
    for (int i = m; i >= 1; --i) {
        if (t[i] == 1) {
            if (x[i] != y[i]) b[x[i]] -= b[y[i]];
            else b[x[i]] /= 2ll;
        } else {
            if (x[i] != y[i]) b[x[i]] /= b[y[i]];
            else b[x[i]]= (long long)sqrt(b[x[i]]);
        }
    }
    for (int i = 1; i <= n; ++i) printf ("%lld ", b[i]);
    //最后因为都是在 b 数组修改，所以只需要输出 b 数组即可
}
```

---

## 作者：Awhale_tauntingcat (赞：0)

#### 题意分析

本题是一道模拟题，只需要将 $a$ 中元素进行对应的逆向操作即可。

注意：在逆向时，顺序与输入顺序 **相反** 。在 $x=y$ 时，逆向操作应为除以二或开算数平方根，而不是减或除。

#### 代码
如下：
```cpp
#include<iostream>
#include<cmath>//有sqrt函数所以要加cmath
using namespace std;
long long n,m,x[201],k[201],y[201];
long long a[10001],b[10001];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=m;i++){
		cin>>k[i];
		cin>>x[i]>>y[i];
	}
	for(int i=m;i>=1;i--){//顺序要相反
		if(k[i]==1){
			if(x[i]==y[i]){
				b[x[i]]/=2;
				continue;
			}//特判
			b[x[i]]=b[x[i]]-b[y[i]];
		}
		if(k[i]==2){
			if(x[i]==y[i]){
				b[x[i]]=sqrt(b[x[i]]);
				continue;
			}
			b[x[i]]=b[x[i]]/b[y[i]];
		}
	}
	for(int i=1;i<=n;i++) cout<<b[i]<<" ";
	return 0;
} 
```
~~(码风极丑见谅）~~

---

## 作者：BetaCutS (赞：0)

在小学四年级已经学过，加法的逆运算是减法，乘法的逆运算是除法。按题目意思倒序模拟即可。具体地，当操作 $1$ 时，把 $a_x$ 减去 $a_y$；操作 $2$ 时把 $a_x$ 除以 $a_y$。

但是，如果 $x=y$，操作 $1$ 时 $a_x$ 会变成 $0$，操作 $2$ 时 $a_x$ 会变成 $1$。题目已经说了：

特别且显然地，当 $x=y$，新的 $x$ 等于原来的 $x$ 的两倍或平方。

也就是，设新的数是 $a$，操作 $1$ 以前的 $a$ 就是 $\dfrac{a}{2}$，操作 $2$ 以前的 $a$ 就是 $\sqrt{a}$。对这种情况特判即可。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
using namespace std;
#define int long long
const int N=1e5+10;
const int INF=0x3f3f3f3f;
int read()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48,ch=getchar();}
	return x*f;
}
int n,m,a[N],opt[N],x[N],y[N];
signed main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=m;i++)
		opt[i]=read(),x[i]=read(),y[i]=read();
	for(int i=m;i>=1;i--)
	{
		if(opt[i]==1)
		{
			if(x[i]!=y[i])
				a[x[i]]-=a[y[i]];
			else
				a[x[i]]/=2;
		}
		else
		{
			if(x[i]!=y[i])
				a[x[i]]/=a[y[i]];
			else
				a[x[i]]=sqrt(a[x[i]]);
		}
	}
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i]);
	return 0;
}

```


---

## 作者：Abeeel51 (赞：0)

#### 题意
对一个数列进行 $m$ 次操作，得到一个新的数列，给你这个新的数列，问原始数列是什么？

有两种操作方式：
- $\texttt{1 x y}$ 表示第 $x$ 个元素加上第 $y$ 个元素。
- $\texttt{2 x y}$ 表示第 $x$ 个元素乘上第 $y$ 个元素。
#### 题解
考虑倒推。

那么两种操作倒推时就是：
- $\texttt{1 x y}$ 表示第 $x$ 个元素减去第 $y$ 个元素。
- $\texttt{2 x y}$ 表示第 $x$ 个元素除以第 $y$ 个元素。

从最后一个操作往前遍历反推操作。

好了，到此输出改完的数组，AC。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[10005];
struct NODE{
    int d,x,y;
}b[10005];
signed main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=m;i++) cin>>b[i].d>>b[i].x>>b[i].y;
    for(int i=m;i>=1;i--){
        if(b[i].x^b[i].y){
            if(b[i].d==1){
                a[b[i].x]-=a[b[i].y];
            }else{
                a[b[i].x]/=a[b[i].y];
            }
        }else{
            if(b[i].d==1){
                a[b[i].x]/=2;
            }else{
                a[b[i].x]=(int)sqrt(a[b[i].x]);
            }
        }
    }
    for(int i=1;i<=n;i++) cout<<a[i]<<" ";
    cout<<endl;
    return 0;
}

```


---


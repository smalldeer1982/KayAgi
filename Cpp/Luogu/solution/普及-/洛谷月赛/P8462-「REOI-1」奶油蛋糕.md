# 「REOI-1」奶油蛋糕

## 题目背景


----------
早餐时间过后，小不点们都前往操场接受基础训练课程，威廉便趁机占据厨房了。  
他在军服上披围裙，头上绑三角巾，还将清早从市场采买回来的大量材料摆到桌上。  
接着，威廉烤了大量的奶油蛋糕。  

威廉把奶油蛋糕摆放到桌子上，珂朵莉闻到了蛋糕的香味，迫不及待地扑到了餐桌前享受着这份饕餮盛宴，然而蛋糕的制作，似乎还差了那么最后一步……  
“等一等哦，我还没有挤上奶油呢。”威廉说着，拿起了裱花袋。  

可饥肠辘辘的珂朵莉哪里等得起全部的奶油都给挤好？  
正当威廉还在忙着挨个给蛋糕挤上白花花的奶油的时候，珂朵莉已经偷偷的拿起了一块蛋糕……

## 题目描述

在桌子上的蛋糕可以看作是一个无限大的[平面直角坐标系](https://baike.baidu.com/item/%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1296463?fr=aladdin)，每一个蛋糕都位于坐标系的整点上。 

每一分钟，威廉会给每个蛋糕都涂上若干层奶油，规则如下：如果蛋糕连续第 $i$ 次没有被珂朵莉吃到，那么就会在蛋糕上挤上 $i$ 层奶油。  

每次在威廉挤完所有蛋糕的奶油后，珂朵莉会拿起一块蛋糕，把这个蛋糕上的奶油给吃掉一层。特别的，如果珂朵莉吃掉了蛋糕上的一层奶油，威廉马上会贴心的再次给这个蛋糕补上一层，且不计入连续没有被吃到的次数里（即下一次的 $i$ 依旧为 $1$ ）。  

由于蛋糕太多，珂朵莉实在不知道从何下手，所以她决定按照移动的吃法进行试吃。  
总共 $m$ 个分钟，珂朵莉的吃蛋糕序列可以用一个长度为 $m$ 的字符串表达。第 $t$ 个字符可能为 `N`，`S`，`W`，`E`分别表示珂朵莉在第 $t+1$ 分钟会吃掉第 $t$ 分钟吃掉蛋糕的上，下，左，右方位的蛋糕。  
珂朵莉第 $1$ 个分钟会拿起位于点 $(x,y)$ 的蛋糕，因为蛋糕目前没有被挤上奶油，所以珂朵莉既不会进行试吃，威廉也不会立刻给她补上奶油。

珂朵莉想知道在 $m$ 分钟后，这些蛋糕在最后都还剩多少层奶油。

本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。

---
简要题面：

有一个 $n\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。

求最后每一个位置上落下的灰的量。

保证这个人没有超过移动的范围。


## 说明/提示

**本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟珂朵莉在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响**

---
**样例 1 解释：**

珂朵莉的移动路径为 $(1,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(2,3)\rightarrow(1,3)$，共 $4$ 分钟。

对于第 $1$ 分钟，$(1,1)$ 奶油层数不变，其余点被挤上了 $1$ 层奶油。

对于第 $2$ 分钟，$(1,2)$ 奶油层数不变，$(1,1)$ 被挤上了 $1$ 层奶油，其余点挤上 $2$ 层奶油。

对于第 $3$ 分钟，$(2,2)$ 奶油层数不变，$(1,1)$ 挤上 $2$ 层奶油，$(1,2)$ 挤上 $1$ 层奶油，其余点挤上 $3$ 层奶油。

对于第 $4$ 分钟，$(2,3)$ 奶油层数不变，$(1,1)$ 挤上 $3$ 层奶油，$(1,2)$ 挤上 $2$ 层奶油，$(2,2)$ 挤上 $1$ 层奶油，其余点挤上 $4$ 层奶油。

**注意最后珂朵莉移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。**

$1\le n\leq 50,1\leq m\le 1000$。

## 样例 #1

### 输入

```
5 4 1 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 6 10 10 10 
4 4 10 10 10 
6 10 10 10 10 
```

## 样例 #2

### 输入

```
7 14 1 1
NENENENENESSSS```

### 输出

```
105 105 105 105 105 105 105 
105 105 105 105 55 61 105 
105 105 105 49 51 69 105 
105 105 51 49 105 79 105 
105 61 55 105 105 91 105 
79 69 105 105 105 105 105 
91 105 105 105 105 105 105 
```

## 样例 #3

### 输入

```
10 70 2 2
NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS```

### 输出

```
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 
2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 
2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 
1557 1497 2485 2485 969 1177 2485 1733 1807 2485 
1471 1531 1315 907 935 1267 2485 1473 1647 2485 
1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 
2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 
2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
```

## 样例 #4

### 输入

```
5 4 2 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 10 6 10 10 
10 4 4 10 10 
10 6 10 10 10 
```

# 题解

## 作者：_Give_up_ (赞：9)

### 注意这题 $x$ 和 $y$ 要反着读！

## 题目思路
最基本的就按照题目要求走就行了，注意，$x$ 和 $y$ 是从左下角开始计的，会发现和正常的二维数组只有行变了，列没变，只需要把 $x$ 变成 $x - n + 1$。

可以用两个二维数组，一个 $a$ 数组记录第 $i$ 分钟落得 $i$ 个单位的灰，另一个 $b$ 数组记录答案，也就是每一点上灰的数量。

当人走在点上的时候灰是不会落上去的，所以人所在的那个点 $b$ 要清 $0$。


接下来就遍历一遍，每个 $a[i][j]$ 加上所对应的 $b[i][j]$。

思路大概就是这些了，接下来上代码吧。

## 代码
```cpp
#include<bits/stdc++.h>
#define N 55

using namespace std;

int read()
{
    int x = 0,f = 1;
    char c = getchar();
    while(c<'0' || c>'9')
	{
        if(c=='-') f = -1;
        c = getchar();
    }
    while(c>='0' && c<='9')
	{
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
    return x*f;
}

int a[N][N],b[N][N];

int main()
{
	int n=read(),m=read(),y=read(),x=read();
	memset(a,0,sizeof(a));
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			b[i][j] = 1;
	x = n-x+1;
	while(m--)
	{
		char c;
		cin >> c;
		b[x][y] = 0;
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				a[i][j] += b[i][j];
		if (c=='N') x--;
		if (c=='S') x++;
		if (c=='W') y--;
		if (c=='E') y++;
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				b[i][j]++;
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
			cout << a[i][j] << " ";
		cout << endl;
	}
	return 0; 
}
```


---

## 作者：XL4453 (赞：8)

记录下每一个位置上被哪一些时间走过，最后直接通过这些记录下的时间计算。

```cpp
#include<vector>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
int n,m,x,y;
vector <int> v[1005][1005];
string s;
int calc(int x){
	return  x*(x+1)/2;
}
int main(){
//	freopen("dust.in","r",stdin);
//	freopen("dust.out","w",stdout);
	cin>>n>>m>>y>>x;
	cin>>s;
	for(int i=0;i<s.size();i++){
		v[x][y].push_back(i+1);
		if(s[i]=='N')x++;
		if(s[i]=='S')x--;
		if(s[i]=='W')y--;
		if(s[i]=='E')y++; 
		if(x<1||x>n||y<1||y>n){
			printf("WRONG!!!!");
			return 0;
		}
	}
	for(int i=n;i>=1;i--){	
		for(int j=1;j<=n;j++){
			v[i][j].push_back(s.size()+1);
			int ans=0,now=0;
			for(int k=0;k<v[i][j].size();k++){
				ans+=calc(v[i][j][k]-now-1);
				now=v[i][j][k];
			}
			printf("%d ",ans);
		}
		printf("\n");
	}
	return 0;
}
```


---

## 作者：RAVE_LOVEo_O (赞：5)

这题有点绕，我提交了半天才过

就是一个模拟，但是有很多要注意的东西

给你一个点，就是珂朵莉的位置，在给你一个字符串，表示珂朵莉的吃蛋糕序列（注意：最后一个点不算 $!!!$ ）

其实从样例解释中可以看出来

题目中的 $1,1$ 表示左下角 （~~真奇怪~~）可以看出是反着算的

比如说方向，都要反着做。
还有，题目说是 $y,x$ (比赛的时候)，其实应该是 $x,y$ （后来改了）

我的 $c$ 数组表示当前坐标的连续了几分钟,而 $b$ 数组就是这个坐标有多少灰

这是本人比赛时的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,x,y,l,i,j,b[55][55],k,c[55][55],dx,dy;
char a;
int read()//快读
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+(ch-'0');
		ch=getchar();
	}
	return x*f;
}
void write(int x) {//快输
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
int main()
{
   n=read(),m=read(),x=read(),y=read();
   while(m--){
      if(a=='S')y--;//全部都要反着做
      if(a=='N')y++;
      if(a=='W')x--;
      if(a=='E')x++;
      c[x][y]=0;//不连续了，制0
      for(i=1;i<=n;i++)
         for(j=1;j<=n;j++)
         {
            if(i==x&&j==y)continue;
            c[i][j]++,b[i][j]+=c[i][j];//每次累计
         }
      cin>>a;//最后一个点不算
   }
   for(i=1;i<=n;i++)
   {
      for(j=1;j<=n;j++)write(b[j][n-i+1]),cout<<' '; //反着输出
      puts("");
   }
	return 0;//完结撒花！
}
```


---

## 作者：SuperCowHorse (赞：3)

### 题目大意
简化题目中有，但还是再说一遍吧。

平面直角坐标系上有 $N\times N$ 个点，人进行 $M$ 次移动，每个点在没走过 $i$ 分钟后会落下 $i$ 个标记（可累加）。求最终棋盘。
### 题目分析
一看都这题，想到的算法只有一个：暴力模拟。但又怕 TLE，于是我~~提心吊胆地~~看了数据范围：$1\le N\le50,1\le M\le1000$。这不就放心了吗，开始乱搞！

首先定义。按照题目意思，定义 $f$ 数组记录多少分钟没有走到这个格子，$a$ 数组记录状态。

然后是处理。先对 $f$ 数组的每一个数都加 $1$，再把 $f_{n-x+1,y}$ 的地方设为 $0$。至于把这里设成 $0$ 而不是 $f_{n-y+1,x}$ 的原因，就是方便正序输出。~~这里卡了很久。~~

下面是处理移动的代码：
``` cpp
void check(int y,int x){
	for(int i=1;i<=n;++i)//f数组+1。由于全要加，直接f[i][j]更方便，不用什么f[j][n-i+1]
		for(int j=1;j<=n;++j)
			++f[i][j];
	f[n-x+1][y]=0;//设成0
	for(int i=1;i<=n;++i)//累加。不需要a[j][n-i+1]，理由同上
		for(int j=1;j<=n;++j)
			a[i][j]+=f[i][j];
}
```
还有一点需要注意：最后一步不算，走了也白走，因此不用循环到 $m$，$m-1$ 就行了。
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,y,x,a[55][55],f[55][55];
char c[1005];
map<char,int>mp;
int dx[]={0,1,0,-1,0};//记录走的状态：上，右，下，左
int dy[]={0,0,1,0,-1};
void check(int y,int x){
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			++f[i][j];
	f[n-x+1][y]=0;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			a[i][j]+=f[i][j];
}
signed main(){
	scanf("%d%d%d%d",&n,&m,&y,&x);
	check(y,x);//开始也要走
	mp['N']=1;mp['E']=2;mp['S']=3;mp['W']=4;//初始化，后面不用套if
	cin>>c;
	for(int i=0;i<m-1;++i){//到m-1
		x+=dx[mp[c[i]]];
		y+=dy[mp[c[i]]];
		check(y,x);
	}
	for(int i=1;i<=n;++i){//正序输出
		for(int j=1;j<=n;++j)
			printf("%d ",a[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Dregen_Yor (赞：2)

# 前置知识

等差数列求和公式：$\sum\limits_{i=1}^na_i=\frac{n\times(a_1+a_n)}{2}$。

# 思路

我们可以考虑模拟珂朵莉的移动，当珂朵莉每移动到一个点时对这个点统计一次答案。由于答案和珂朵莉上一次到达这个点的时间有关，对此我们还要记录每个点的珂朵莉上次到达的时间，这样距离珂朵莉上次抵达当前的点的时间为 $now-last$。我们再根据上面的求和公式即可以 $\mathcal O(1)$ 的时间复杂度统计出答案。注意，由于珂朵莉抵达这个点的当天是不会有奶油积累，所以还要减去当天的值。

输出时要注意，由于这题 Y 轴的正方向为上，所以我们输出行的时候要从第 $n$ 行开始输出，一直输出到第一行为止。而且在输出之前，还要以和上面相同的方式统计一次答案，因为每个点还会持续积累奶油，不过这里不用减去任何值，因为珂朵莉不会对任何点再产生影响了。

**注意这道题先输入的 $x$ 和 $y$ 并不是广义的 $x$ 和 $y$ 。**
# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, x, y, sum[1010][1010], last[1010][1010];
string s;

signed main() {
	scanf("%lld%lld%lld%lld", &n, &m, &y, &x);
	cin >> s;
	for (int i = 0, step = 1; step <= m && i < s.size(); i++, step++) {
		int tmp = step - last[x][y];
		sum[x][y] += tmp * (1 + tmp) >> 1;
		sum[x][y] -= (step - last[x][y]);
		last[x][y] = step;
		if (s[i] == 'N') {
			x++;
		} else if (s[i] == 'S') {
			x--;
		} else if (s[i] == 'W') {
			y--;
		} else if (s[i] == 'E') {
			y++;
		}

	}
	int step = m;
	for (int i = n; i; --i) {
		for (int j = 1; j <= n; j++) {
			int tmp = step - last[i][j];
			sum[i][j] += tmp * (1 + tmp) >> 1;
			printf("%lld ", sum[i][j]);
		}
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：what_can_I_do (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8462)

## 题目描述
有一个 $n\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。

求最后每一个位置上落下的灰的量。

保证这个人没有超过移动的范围。



------------
这是一道模拟题，首先得注意他输出的第 $i$ 行第 $j$ 个数表示 $(j,n-i+1)$ 坐标上灰的数量，且它的 $x$ 和 $y$ 是反着的。我们就可以设一个数组是该坐标上灰的数量，再设一个数组表示该坐标要增加的灰的数量，然后设一个循环模拟 $x$ 和 $y$ 的位置，然后该位置要加的灰的数量清 0，其他位置照常加灰。

代码就不做解释了。

------------
## CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,a[100][100]={0},s[100][100]={0};
char yd[1000];
int main()
{
	cin>>n>>m>>y>>x;
	cin>>yd;
	for(int i=0;i<m;i++)
	{
		for(int j=1;j<=n;j++) for(int k=1;k<=n;k++) if(j==x&&k==y) s[j][k]=0;else s[j][k]++,a[j][k]+=s[j][k];
		if(yd[i]=='N') x++;
		else if(yd[i]=='S') x--;
		else if(yd[i]=='W') y--;
		else if(yd[i]=='E') y++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) cout<<a[n-i+1][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：砍手岩火柴盒 (赞：1)

#### 这是本蒟蒻的第二篇题解，若不够详细请见谅，可欣赏上面或下面的神犇的题解
~~第一篇挂了，感谢同机房[神犇](https://www.luogu.com.cn/user/486675)的指导~~。

首先，我们读完题后大意是：给定一个 $n\times n$ 的矩阵，$m$ 次操作，并给定珂朵莉初始坐标 $(x,y)$，然后给定一个长为 $m$ 由 $\text{N,S,W,E}$ 组成的字符串，表示珂朵莉会向上、下、左、右移动。

珂朵莉未经过的地区的奶油厚度将会随着时间的增加呈现等差数列式的增加。而经过的地区，通过对样例解释的分析，我们可以发现：当前时间的奶油厚度不变，且要将时间归零后重新以等差数列式的增加。

然后我们去看看数据范围 $1\le n\leq 50,1\leq m\le 1000$。

如果暴力扫描的话时间是 $\mathcal O(mn^2)\leq250000$，也就是大约 $25ms<1s$，妥妥的能过。

所以我们可以用一个结构体储存总数与时间，在每次移动后对其进行更新。

然后我们需要去关注一下巨坑的输入与输出格式，首先比赛中表述的是先输入 $y$ 轴坐标，在输入 $x$ 轴坐标，而现在题目中的表述为 本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向，其实这两句话是等效的。所以我们不妨理解成第一种，这样就不必在思考时将印象中的平面直角坐标系旋转 $90\degree$。

再来说输出，题目要求第 $i$ 行的第 $j$ 个数表示坐标 $(j,n-i+1)$ 上的灰的数量，在前面已经将 $x$ 与 $y$ 对调的条件下，输出也要对调（但更符合我们一般打代码的习惯），其次，我们也只需要在输出时处理 $n-i+1$ 这样可以简化代码。

而核心代码其实不长，只长这样：
```cpp
while(m--&&m>0)//因为最后一个点不影响，所以不读入
{
	cin>>c;
	if(c=='N') x+=1;
	if(c=='S') x-=1;
	if(c=='E') y+=1;
	if(c=='W') y-=1;
	f(i,1,n)//此处是用宏定义简化的for循环
   	{
		f(j,1,n)
		{	
			a[i][j].day+=1;
			a[i][j].sum+=a[i][j].day;
		}
   	}//将图上每个点的时间与奶油厚度更新
	a[x][y].sum-=a[x][y].day;
	a[x][y].day=0;//去掉途经点多加的奶油，并将时间归零
}
```
初始化代码与上面的类似，同时如果是在最后输出时用高斯求和更新总数，在此之前只对途经点更新总数的话可以减小常数，但天数还要更新。

总体代码详见[这里](https://www.luogu.com.cn/paste/x93mycme)。

[题目传送门](https://www.luogu.com.cn/problem/P8462)

求过！

---

## 作者：cachejtt (赞：1)

# A
一开始写的是 $O(n^2\times m)$，中间忽然改成了 $n\le 1000,m\le 1000$，于是写了个 $O(m)$，后来又改回 $n\le 50,m\le 1000$，我真的服辣！！

## 思路
### 做法1
#### 思路
考虑暴力模拟，对每个点维护一个计数器和一个总和，对于目前踩到的点，重置其计数器，对于其他点，总和加上计数器，并让计数器加一即可。

时间复杂度 $O(n^2\times m)$

#### 代码
注意先输入 $y$，再输入 $x$。~~（被坑惨了）~~
```cpp
void solve(string s,int x,int y,int cnt){
  if(cnt>m)return;
  rep(i,1,n){
    rep(j,1,n){
      if(i==x && j==y){
        c[i][j]=0;
        continue;
      }
      c[i][j]++;
      g[i][j]+=c[i][j];
    }
  }
  if(s[cnt-1]=='N')solve(s,x+1,y,cnt+1);
  if(s[cnt-1]=='S')solve(s,x-1,y,cnt+1);
  if(s[cnt-1]=='E')solve(s,x,y+1,cnt+1);
  if(s[cnt-1]=='W')solve(s,x,y-1,cnt+1);
}
```
### 做法2
#### 思路
考虑一共只有 $m$ 个点被修改了，因此只需处理这 $m$ 个点即可。记录当前点上一次经过的时间 $t_1$，这一次经过的时间 $t_2$，则落灰数为 $\dfrac{(t_2-t_1)\times (t_2-t_1-1)}{2}$，记得处理最后一次落灰。

时间复杂度 $O(m)$

#### 代码
注意点同上。
```cpp
#include<bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define nrep(i, a, b) for (int i = (a); i >= (b); --i)
#define ll long long
#define endl "\n"
#define int ll
using namespace std;
int n,m,xx,yy;
int g[1005][1005],c[1005][1005],vis[1005][1005];
string ss;
void solvel(string s,int x,int y,int cnt){
  if(cnt>m)return;
  g[x][y]+=(cnt-c[x][y])*(cnt-c[x][y]-1)/2;
  vis[x][y]=1;
  c[x][y]=cnt;
  if(s[cnt-1]=='N')solvel(s,x+1,y,cnt+1);
  if(s[cnt-1]=='S')solvel(s,x-1,y,cnt+1);
  if(s[cnt-1]=='E')solvel(s,x,y+1,cnt+1);
  if(s[cnt-1]=='W')solvel(s,x,y-1,cnt+1);
}
signed main(){
  ios::sync_with_stdio(0);
  cin>>n>>m>>yy>>xx;
  cin>>ss;
  solvel(ss,xx,yy,1);
  rep(i,1,n){
    rep(j,1,n){
      if(vis[n-i+1][j])cout<<g[n-i+1][j]+(m-c[n-i+1][j])*(m-c[n-i+1][j]+1)/2<<" ";
      else cout<<m*(m+1)/2<<" ";
    }
    cout<<endl;
  }
  return 0;
}
```

---

## 作者：Asimplename (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8462)

## 思路

观察到数据范围很小，可以暴力解决。即对于每次操作，遍历每个点，增加此时这个点应落的灰尘数（程序中使用 $\texttt{last}$ 变量处理），每次到达的点 $\texttt{last}$ 清零，剩余的点 $\texttt{last}$ 加一即可。

## 代码

```cpp
#include<iostream>
using namespace std;
struct cake{
	int num;
	int last;
};
int n,m,x,y = 0;
string walk;
cake a[60][60];
long long sum = 0;
int main () {
	cin >> n >> m >> y >> x;	
	x = n - x + 1;
	cin >> walk;
	for(int i = 0; i < m; i ++){
		a[x][y].last = 0;
		for(int j = 1; j <= n; j ++){
			for(int k = 1; k <= n; k ++){
				if(j != x || k != y){
					a[j][k].num += a[j][k].last + 1;
					a[j][k].last ++;
				}
			}
		}
		if(walk[i] == 'N'){
			x = x - 1;
		}
		if(walk[i] == 'S'){
			x ++;
		}
		if(walk[i] == 'W'){
			y = y - 1;
		}
		if(walk[i] == 'E'){
			y++;
		}
	}
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= n; j ++){
			cout << a[i][j].num << " ";
		}
		cout << endl;
	}
	return 0;
} 
```

---

## 作者：Gaode_Sean (赞：0)

这是一道思路简单的模拟题。

对于第 $x$ 行第 $y$ 列的格子，我们需要记录两个变量。

- $c_{x,y}$ ：当前格子已经连续多少分钟没有人经过。

- $ans_{x,y}$：当前格子落上了多少单位的灰。

对于任意时刻，每个格子有：

- 被经过：```c[x][y]=0```，即时间重新开始计算。

- 不被经过：```c[x][y]+=1,ans[x][y]+=c[x][y]```。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=51;
int n,m,xx,yy,x,y,ans[N][N],c[N][N];
int main()
{
	scanf("%d%d%d%d",&n,&m,&xx,&yy);
	//x=yy,y=n-xx+1;
	y=xx,x=n-yy+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) if(i!=x||j!=y) ans[i][j]=c[i][j]=1;
	}
	for(int i=1;i<=m;i++)
	{
		char ch;
		cin>>ch;
		if(i<m)
		{
			if(ch=='N') x--;
			else if(ch=='S') x++;
			else if(ch=='W') y--;
			else y++;
			c[x][y]=0;
			for(int j=1;j<=n;j++)
			{
				for(int k=1;k<=n;k++) if(j!=x||k!=y) c[j][k]++,ans[j][k]+=c[j][k];
			}
		}
	} 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：0xFF (赞：0)

#### 题目大意


------------
给出一个 $n \times n$ 的方格图，一个连续 $i$ 分钟没人经过的方格在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰。给出人的行走路线，求出最后各个方格落的灰的厚度。

#### 思路分析


------------
求出每个方格上次经过的时间，求出两次的时间间隔，连续 $i$ 分钟落的灰的厚度是 $\frac{i\times (i+1)}{2}$，据此求解即可。**注意：题目中的上和右分别代表 $y$ 轴和 $x$ 轴正方向**

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int N = 51 + 10;
const int INF = 1e9 + 10;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
    return x*f;
}
char str[1001];
int ans[N][N];
int last[N][N];
signed main(){
	int n = read() , m = read() , dy = read() , dx = read();
	scanf("%s",str+1);
	for(int i(1);i<=m;i++){
		ans[dx][dy] += (i - last[dx][dy]) * (i - last[dx][dy] - 1) / 2;
		last[dx][dy] = i;
		if(str[i] == 'N') dx++;
		if(str[i] == 'E') dy++;
		if(str[i] == 'W') dy--;
		if(str[i] == 'S') dx--;
	}
	for(int i(1);i<=n;i++){
		for(int j(1);j<=n;j++){
			ans[i][j] += (m - last[i][j]) * (m - last[i][j] + 1) / 2;
		}
	}
	for(int i(1);i<=n;i++){
		for(int j(1);j<=n;j++){
			printf("%lld ",ans[n-i+1][j]);
		}
		printf("\n");
	}
	return 0;
}
```


---

## 作者：lovely_hyzhuo (赞：0)

### 题目思路

大意题面写的很清楚了，直接写思路了。

这个题是个模拟，我的思路是建立一个结构体，一个是人距离上一次来过多久了，另一个是总共落了多少灰，累加就完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	long long ans;
	int i;
}a[60][60];
inline void write(int x)
{
    if(x<0)
	{
    	putchar('-');
		x=-x;
	}
    if(x>9)
    {
    	write(x/10);
	}
    putchar(x%10+'0');
}
inline int read() 
{
     bool f=false; 
	 int x=0;
     char ch=getchar();
     while(ch<'0'||ch>'9') 
	 {
         if(ch=='-') 
		 {
		 	f=true;
		 }
         ch=getchar();
     }
     while(ch>='0'&&ch<='9') 
	 {
         x=(x<<1)+(x<<3)+ch-'0';
         ch=getchar();
     }
     return f?-x:x;
 }
int main()
{
	int n,m,x,y;
	n=read(),m=read(),y=read(),x=read();
	char ch[1010];
	cin>>ch;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j].i=1;
			a[i][j].ans=1;
		}
	}
	a[x][y].i=0;
	a[x][y].ans=0;
	for(int i=0;i<m-1;i++)
	{
		if(ch[i]=='E')
		{
			y++;
		}
		else if(ch[i]=='W')
		{
			y--;
		}
		else if(ch[i]=='S')
		{
			x--;
		}
		else /*if(ch[i]=='N')*/
		{
			x++;
		}
		a[x][y].i=-1;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				a[i][j].i++;
				a[i][j].ans+=a[i][j].i;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			write(a[n-i+1][j].ans);
			putchar(' ');
		}
		putchar('\n');
	}
	return 0;
}
```


---


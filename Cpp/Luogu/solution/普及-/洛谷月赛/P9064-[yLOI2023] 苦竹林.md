# [yLOI2023] 苦竹林

## 题目背景

> 悬挂在屋檐下的风铃，摇晃的声音很动听。  
> 思念就像梅雨下不停，我的心境一片泥泞。  
> 散落在天际里的繁星，闪烁着你我的宿命。  
> 当枫叶轻盈落入湖心，近看山水一片宁静。  

——银临 & 涵昱《苦竹林》

## 题目描述

共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。

为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。

请你找到最小的整数 $\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \dots b_m$，满足对任意的 $1 \leq i, j \leq m$，都有 $|b_i - b_j| \leq \varepsilon$。

## 说明/提示

### 样例 2 解释

一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \leq i, j\leq 4$，都有 $|b_i - b_j| \leq 4$。

另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\varepsilon$ 为 $4$。

### 数据规模与约定

- 对 $10\%$ 的数据，$m = 2$。
- 另有 $10\%$ 的数据，$m = n$。
- 对 $40\%$ 的数据，$n \leq 5$。
- 对 $60\%$ 的数据，保证对所有的 $2 \leq i \leq n$，满足 $a_{i - 1} \leq a_i$，即 $a_i$ 单调不降。
- 对 $80\%$ 的数据，$n \leq 10^3$。
- 对 $100\%$ 的数据，$2 \leq m \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

### 说明

本题共有三个附加样例文件，见题目附件中的 `ring.zip`。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
6 4
1 7 8 3 4 6```

### 输出

```
4```

# 题解

## 作者：一扶苏一 (赞：14)

# [yLOI2023] B 苦竹林

## Description

给定一个数列 $a$，找到最小的 $\varepsilon$，使得 $a$ 存在一个长度为 $m$ 的子数列（可以不连续）$b$，满足对任何的 $1 \leq i, j \leq m$，都有 $|b_i - b_j| \leq \varepsilon$。

$2 \leq m \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

## Analysis

### 算法一

当 $m = 2$ 时，只要找到数列里差值最小的两个数；当 $m = n$ 时，只要找到数列里最大值与最小值的差。分别可得 $10$ 分。

### 算法二

枚举所有选 $b$ 的方案。一共有 $\binom{n}{m}$ 种方案，枚举方案可以搜索，也可以二进制枚举。对每种方案，对应的 $\varepsilon$ 就是该方案里 $b$ 的最大值减去最小值，可以 $O(m)$ 算出。总时间复杂度 $O(m \times \binom{n}{m})$。期望得分 $40$ 分。

### 算法三

当 $a_i$ 有序时，容易发现答案对应的 $b$ 数列一定是数列里一个连续的子段。因为答案一定是 $b$ 数列里最大值减去最小值，而与中间的数无关。所以所选的数应该越紧凑越好。对一个确定的 $b$ 数列最小值，如果所选的数中间有空隙，则会令最大值有增大的可能，导致答案遍劣。

于是 $O(n)$ 枚举 $a$ 里每个长度为 $m$ 的子区间，当区间左端点为 $i$ 时，区间最小值就是 $a_i$，最大值是 $a_{i + m - 1}$。可以 $O(1)$ 算出此时的 $\varepsilon$ 并与当前算出的答案作比较。

时间复杂度 $O(n)$，期望得分 $60$ 分。

### 算法四

注意到 $a$ 的顺序其实并不影响答案。因为我们考虑的是 $b$ 里每一对数，而并不考虑他们之间的前后关系。

于是当 $a$ 无序时，把 $a$ 排个序按照算法三完成即可。

如果没有认识到区间最大值就是右端点，区间最小值就是左端点，求最值可以 $O(m)$ 扫一遍区间。时间复杂度 $O(nm)$，期望得分 $80$ 分。

如果会 $O(1)$ 求最值，且使用冒泡排序、插入排序等 $O(n^2)$ 的排序，算法的时间复杂度为 $O(n^2)$，期望得分 $80$ 分；如果采用 `std::sort` 等时间复杂度为 $O(n \log n)$ 的排序，则算法的时间复杂度为 $O(n \log n)$，期望得分 $100$ 分。

## Code

```cpp
#include <climits>
#include <vector>
#include <iostream>
#include <algorithm>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin >> n >> m;
  std::vector<int> a(n);
  std::generate(a.begin(), a.end(), []() { int x; std::cin >> x; return x; });
  int ans = INT_MAX;
  std::sort(a.begin(), a.end());
  for (int l = 0, r = m - 1; r < n; ++l, ++r) {
    ans = std::min(ans, a[r] - a[l]);
  }
  std::cout << ans << std::endl;
}
```

## Generator

```cpp
void makedata(int T) {
  int n = 100000, m, lim = 1000000000;
  if (T <= 4) n = 5;
  else if (T <= 8) n = 1000;
  if (T == 1) m = 2;
  else if (T == 2) m = n;
  else m = modx(n) + 1;
  std::vector<int> a(n);
  std::generate(a.begin(), a.end(), [&]() { return modx(lim) + 1; });
  if (T <= 6) std::sort(a.begin(), a.end());
  printf("%d %d\n", n, m);
  for (int i = 0; i < n; ++i) printf("%d%c", a[i], " \n"[i == n-1]);
}
```

---

## 作者：zzyxl_qaq (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P9064)

#### 题意简述 

在 $ n $ 个数中选出 $ m $  个数，使得这 $ m $ 个数中最大值减最小值的值最小。

#### 思路简述

我们要让最大数与最小数的差尽可能小就要使得这些数尽量接近，容易想到使用排序然后枚举每一个 $ i \sim i+m-1 $ 的区间，其中 $ 1 \le i \le n-m+1 $。对于每个区间，求出它的最大值减最小值的差，然后打擂台取最小值即可。

这样，我们就可以写出代码：

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int main(){
    int n,m,ans=INT_MAX;//ans要赋值为一个极大的数，这里的INT_MAX就是int的最大值
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);//排序
    for(int i=1;i<=n-m+1;i++){
        ans=min(ans,a[i+m-1]-a[i]);//打擂台求最小值
    }
    cout<<ans;
}
```

[AC记录](https://www.luogu.com.cn/record/101957705)

---

## 作者：__Allen_123__ (赞：5)

### 题意简述

给定一个长度为 $n$ 的序列 $a$，请从中任意选择 $m$ 个数，使得选出的 $m$ 个数中的最大值和最小值之差最小，求出这个最小值。

### 题目分析

我们可以想到，为了使其最大值和最小值之差最小，我们就要让选出的这些数尽量靠近，也就是极差比较小。为了使极差最小，我们应该选取序列 $a$ 在排序后连续的 $m$ 个数，求出这连续的 $m$ 个数中的极差最小是多少。

那么具体我们应该这样实现：

首先在读入后将序列排序，接下来从头枚举到尾，求出极差最小是多少，输出结果即可。

时间复杂度 $O(n\log n)$，这种做法可以 AC。

### 代码

```cpp
/*
 * Author: Allen_123
 * Name: P9064
 * Time: 2023/2/11
 * Lang: C++11
 */
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;
int n, m, a[MAXN], ans = INT_MAX; // 初始将答案设置为无穷大
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
	}
	sort(a + 1, a + n + 1); // 将序列排序
	for(int i = 1;i <= n - m + 1;i++){ // 既然是 m 个连续的数，那么最右边的左下标应该是 n - m + 1，这样才能枚举到所有情况
		ans = min(ans, a[i + m - 1] - a[i]); // 求出最小值
	}
	cout << ans;
	return 0;
}
```

---

## 作者：JuRuoOIer (赞：2)

# 题解 P9064 [yLOI2023] 苦竹林

### Part1 题意

- 给出 $n$ 个正整数，求其中任选 $m$ 个正整数的最小极差（最大值减最小值）。
- $2 \le m \le n \le 10^5$，$1 \le a_i \le 10^9$。

### Part2 思路

考虑暴力：枚举每一种可能并求极差，求最小值。复杂度 $\text{O}(n^m \times m)$，显然无法通过本题。

首先我们肯定不想循环求极差，所以要先把数组排序，这样极差就等于最后面的数减去最前面的数了。

排完序我们发现：如果选 $a_i(1 \le i \le n-m+1)$ 作为最小值，那想让极差最小，肯定要选 $a_{i}$ 到 $a_{i+m-1}$ 这 $m$ 个数字。因为数组是单调递增，所以 $a_j \le a_{j+1}(1 \le j \le n-1)$，因此 $a_j-a_i \le a_{j+1}-a_i$。于是我们只需要排序，然后枚举最小值就可以了，时间复杂度 $\text{O}(n \log n)$，可以 AC。

### Part3 代码

注释在代码里啦！

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
ll n,m,a[100010],mn=1145141919810;//最小值设大点，别寄了 
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);//排序 
	for(int i=0;i<n-m+1;i++){//枚举最小值，注意范围是 0 至 n-m，别 RE 了 
		mn=min(mn,a[i+m-1]-a[i]);//取最小值 
	}
	cout<<mn;
	return 0;
}
```

---

## 作者：ImNot6Dora (赞：1)

看似是一道很难的题实际上却很简单的题目，稍加分析便可得出结论。

先搬上来代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=INT_MAX;
int a[100001];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    if(m==n)ans=a[n]-a[1];
	else for(int i=1;i<=n-m+1;i++)ans=min(ans,a[i-1+m]-a[i]); 
    cout<<ans;
	return 0;
}
```
由于要求选出的风铃中，最大和最小两个数相差最小，所以首先要排序。

排序之后，最优方案一定就是相邻的 $m$ 个数字了。

当然，我们并不确定输入的序列是否是等差数列，所以要把所有相邻的 $m$ 个数字最大最小挨个判断，找出最小差值。

在这之前，先特判一下，如果 $n=m$，说明只有一种方案，也就是用最大值减最小值。

而后进行循环查找所有的长度为 $m$ 的区间，找出最小极差。

完结撒花！

By ImNot6Dora

---

## 作者：__11jiang08__ (赞：1)

题目要求从 $a_1,a_2,...,a_n$ 中选出 $m$ 个数字 $b_1,b_2,...,b_m$，使得任意两数之差的最大值最小化。

首先将 $a$ 数组从小到大排序，对于一个有序序列，任意两数之差的最大值必定是最后一个数减去第一个数，而又容易证明选择连续的一段有序序列必定是最优的，那么只要枚举每一个 $1 \leq i,i+m \leq n$，计算 $a_{i+m}-a_i$ 的最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100009;
ll n,m,b[100009];
inline ll read()
{
	ll x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)  b[i]=read();
	sort(b+1,b+1+n);
	ll ans=0x3f3f3f3f3f3f3f3f;
	for(int i=m;i<=n;i++){
		ans=min(ans,b[i]-b[i-m+1]);
	}
	cout<<ans;
	return 0;
}



```


---

## 作者：二叉苹果树 (赞：1)

因为 $|b_i - b_j| \leq \varepsilon$，所以 $\varepsilon$ 一定始终取到每一种选择的数列 $\{b_m\}$ 中的极差。

也就是说，我们要从 $n$ 个数中选出 $m$ 个数，使得这 $m$ 个数的极差最小。

做法是，将原数列 $\{a_n\}$ 按升序或降序排序，依次枚举 $a_1 \sim a_m, a_2 \sim a_{m + 1},...,a_{n - m + 1 } \sim {a_n} $， 分别计算极差得到 $ \varepsilon =  |a_i - a_{i + m - 1}|$，再取最小值即可。

简单的证明，此时的 $\{a_n\}$ 是升序的。对于选出的一段在 $\{a_n\}$ 中连续的 $\{b_m\}$，若将 $b_i$ 替换为不在 $\{b_m\}$ 中却在 $\{a_n\}$ 中的数，这个新数一定不小于 $\{b_m\}$ 的最大值或不大于原来的 $\{b_m\}$ 的最小值，此时 $\{b_m\}$ 的极值一定会不小于原先的极值。我们也可以将证明结果转化，以 $a_i$ 为升序数列 $\{b_m\}$ 的第一个数时，此时的最优情况一定是选择 $a_i \sim a_{i + m - 1}$ 这一段数。因此我们依次枚举 $n - m + 1$ 个可以作为数列中第一个数的 $a_i$，再计算出以 $a_i$ 开头的最优选择出的数列的极值即可。

显然非连续有序情况下的选择是更劣的。

```cpp
#include <bits/stdc++.h>
#define MAXN 100005

int main()
{
    int n, m, a[MAXN], min = 0x3f3f3f3f;
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++)
        std::cin >> a[i];
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i <= n - m + 1; i++)
        min = std::min(min, a[i + m - 1] - a[i]);
    std::cout << min << std::endl;
    return 0;
}
```


---

## 作者：Asimplename (赞：1)

首先，题意可以转换成从 $n$ 个风铃里挑出 $m$ 个，使得它的极差最小。

所以可以直接给数列排序，然后将第 $i$ 个数（$1\le i\le n-m+1$）分别假设为最小值，那么第 $i+m-1$ 个就是数列 $b$ 最小的最大值，直接相减，并求出最小值即可。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
int a[100010];
int ans = 2e9;
int main (){
	cin >> n >> m;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n);
	for(int i = 1; i <= n - m + 1; i ++){
		ans = min(ans, a[i + m - 1] - a[i]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：BetaCutS (赞：0)

把 $b$ 从小到大排序，选出来的 $m$ 个肯定是连续的，如果不连续那么会使差距变大。所以枚举所有长度为 $m$ 的区间，求所有区间极差的最小值。

```cpp
int n,m,ans=INF,a[N];
void solve()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+1+n);
	for(int i=1;i+m-1<=n;i++)
		ans=min(ans,a[i+m-1]-a[i]);
	write(ans,"");
}

```

---

## 作者：so_find_skind (赞：0)

虽然题目描述有点多，但~~杂话一堆~~综合起来实际上就一句话：

从 $n$ 个数里选出 $m$ 个数，使得这 $m$ 个数中最大数与最小数之差最小。

既然提到了最大数与最小数，就肯定要进行排序，此时 $n$ 个数单调不减。

之后要使最大最小之差最小，必然需要是连续的 $m$ 个数字才有可能，因为无间隔情况显然比有间隔情况更优。

code：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],ans=0x3f3f3f3f;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    for(int i=1;i<=n-m+1;i++){
        ans=min(ans,a[i+m-1]-a[i]);
    }
    cout<<ans;
    return 0;
}
```

---


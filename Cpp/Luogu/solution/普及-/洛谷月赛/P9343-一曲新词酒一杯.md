# 一曲新词酒一杯

## 题目背景

昨夜勾栏听曲，一壶浊酒，与明月凭栏相望，想起如今的处境，却没有怅然若失，仍然醉心于宴饮涵咏之乐，把酒临风之际，想起一种酒桌上的游戏，便和好友玩起来。

## 题目描述

酒桌上共有 $n$ 杯酒，标号为 $1\sim n$。桌旁有许多写有“酒”字的红色纸片。

接下来对这 $n$ 杯酒**依次**进行 $m$ 次操作。

操作共分为 $2$ 种：

- `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。
- `2 x`：给除了 $x$ 号酒的其它 $n-1$ 杯酒分别贴上 $1$ 张红纸。

问在**至少**几次操作后，每杯酒上至少有一张红纸？


## 说明/提示

**【样例 1 解释】**

对于第一组数据：

- 第 $1$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $0$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $2$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $3$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $1$ 张红纸。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（20 points）：$o_i=1$。
-  Subtask 2（20 points）：$o_i=2$。
-  Subtask 3（20 points）：所有 $x_i$ 均相等。
-  Subtask 4（20 points）：$\sum n,\sum m\le 3\times 10^3$。
-  Subtask 5（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T,n,m,\sum n,\sum m\le 2\times 10^5$，$o_i\in \{1,2\}$，$1\le x_i\le n$。

## 样例 #1

### 输入

```
2
3 3
1 1
1 2
1 3
3 2
1 1
2 2```

### 输出

```
3
-1```

# 题解

## 作者：VitrelosTia (赞：14)

容易想到当对于 $x$ 号酒，假如输入数据出现了 `1 x` 和 `2 x`，那么就可以做到每杯酒都至少有 $1$。同时还要考虑到假如到最后都没有这种情况出现，有两种情况也是可以的：$o = 1$ 时 $x$ 的种类假如等于 $n$ 或者 $o = 2$ 时 $x$ 的种类大于 $1$。

实现这个并不难，开桶分别记录 $o = 1$ 和 $o = 2$ 的 $x$，然后处理就十分简单了，更新需要的计数器并判断是否能满足题意即可。注意要多测清空以及小心不要读入到一半就把 `solve` 结束了。

```cpp
void solve() {
    int cnt1 = 0, cnt2 = 0;
    memset(vis1, false, sizeof vis1);
    memset(vis2, false, sizeof vis2);
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) scanf ("%d%d", &o[i], &x[i]);
    for (int i = 1; i <= m; i++) {
        if (o[i] == 1) {
            if (vis2[x[i]]) {
                cout << i << '\n';
                return;
            }
            if (!vis1[x[i]]) cnt1++, vis1[x[i]] = true;
        }
        if (o[i] == 2) {
            if (vis1[x[i]]) {
                cout << i << '\n';
                return;
            }
            if (!vis2[x[i]]) cnt2++, vis2[x[i]] = true;
        }
        if (cnt2 > 1 || cnt1 == n) {
            cout << i << '\n';
            return;
        }
    }
    puts("-1");
}
```

---

## 作者：Jasoncwx (赞：10)

## 题目思路
定义两个 `set` 容器 `first` 和 `second` 分别表示第一和第二种操作。

`set` 容器的好处是可以自动去掉重复的数字。

我们可以想到，在以下三种情况能够全部贴上红纸：
- 对于 $1$ 到 $n$ 的数都有一次操作 $1$；
- 对于一个数 $x$，一次操作 $1$ 和一次操作 $2$；
- 两次及以上不相同的操作 $2$。

接下来我们就可以实现代码了。

对于第 $i$ 次操作，记输入的数为 $x$。如果是操作 $1$，`first` 插入 $x$，否则 `second` 插入 $x$。

插入后，我们就判断，当 `first` 的大小为 $n$ **或者** `first` 和 `second` 里都有 $x$ **或者** `second` 的大小 $\ge2$，输出 $i$。

如果 $i$ 永远没有输出，最后输出 `-1`。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;cin>>T;
	while(T--){
		int n,m,ans=-1;
		cin>>n>>m;
		bool f=false;
		set<int>first,second;
		for(int i=1;i<=m;i++){
			short op;cin>>op;
			int x;cin>>x;
			if(f)continue;
			if(op==1)first.insert(x);
			else second.insert(x);
			if(first.size()==n||(first.find(x)!=first.end()&&second.find(x)!=second.end())||(second.size()>1)){
				ans=i;
				f=true;
			}
		}
		cout<<ans<<endl;
	}
}
```


---

## 作者：喵仔牛奶 (赞：7)

## Description

给定一个初始所有元素为 $0$ 的序列 $\{a_n\}$，支持下列两种操作：
1. 单点加 $1$。
1. 除某一单点全局加 $1$。

求出最早的时间使得所有 $a_i>0$。

## Solution

- 操作 $2$ 可以拆分为全局加和单点减。
- 全局加可以维护变量 $\text{tag}$ 表示全局加了多少。
- 单点加或减可以使用数组维护。
- 同时维护 $a_i>0$ 的 $i$ 个数即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Milkcat {
	typedef long long LL;
	const int N = 1e6 + 5;
	int n, m, opt, x, tag, cnt, ans, a[N];
	int main() {
		cin >> n >> m, ans = -1;
		for (int i = 1; i <= m; i ++) {
			cin >> opt >> x;
			if (opt == 1) {
				if (tag + a[x] <= 0) cnt ++; // 若该点原来 =0 则 cnt++
 				a[x] ++;
			}
			if (opt == 2) {
				cnt = n; // 除该点外所有元素 +1 后肯定 >0
				if (tag + a[x] <= 0) cnt --; // 若该点 <0 则 cnt=n-1
				tag ++, a[x] --; // 维护数组
			}
			if (cnt == n && ans == -1) ans = i; // 最早的时间
		}
		cout << ans << '\n';
		for (int i = 1; i <= n; i ++) a[i] = 0; // 清空
		tag = cnt = 0;
		return 0;
	}
}
int main() {
    int T = 1;
    cin >> T;
    while (T --) Milkcat::main();
    return 0;
}


```

---

## 作者：AKPC (赞：5)

### 思路
共三种可考虑的情况。

1. 对于 $x$ 号酒，进行一次 $1$ 操作让自己的贴上红纸，再进行一次 $2$ 操作给其它的酒贴上红纸。顺序任意，对应次数为 $2$。
    
2. 对于 $x$ 和 $y$ 号酒，若 $(x \neq y)$，则在给 $x$ 操作后给 $y$ 操作时 $x$ 号也会贴上。对应次数为 $2$。

3. 对于上述两种均不可的情况，每壶酒均进行一次 $1$ 操作，顺序任意，对应次数为 $n$。

### 代码实现
先特判（~~虽然可能没啥用~~）如果 $n=1$，则直接判断是否有对 $1$ 号酒的 $1$ 操作。

先对操作去重。统计 $2$ 操作个数，若个数 $\geq 2$，对应方案 $2$，结果为 $2$；若个数 $=1$，则判断是否符合方案 $1$，如果是，答案为 $2$，反之开个桶判断是否满足方案 $3$，若是则答案为 $n$，反之输出 $-1$。

---

## 作者：zhzkiller (赞：4)

## 题目描述
这道题要求我们通过 $1$、$2$ 两种操作更新去维护一个初始全置 $0$ 的序列，问在给定要求 $m$ 的范围内最少多少次可以使得序列均非 $0$，否则输出 $-1$。

## 解题思路

### 相对法与线段树

我们不难发现，这道题如果用暴力模拟，复杂度来到了我们难以接受的 $O(n m)$ 级别，这时我们肯定需要考虑在操作 $2$ 上动动脑筋。

我们容易得出，以相对的视角去看待操作 $2$，它更像是将自己减去 $1$ 后得到的结果，但是这样肯定和题目不符，是哪里错了呢？

再次观察，可以发现其实所要求贴的红纸至少所需的数量也随之更新了，也是减去了 $1$。因为我们是以相对的视角更新操作 $2$ 的，这就导致如果不更新至少数量，我们其他的序列值相当于没有与至少数量拉开差距，即没有加上 $1$。

至此，我们便可以请出今天的主角了：线段树

这个数据结构可以以 $O(\log n)$ 的复杂度修改单点数值并查询区间最值，完美契合本题要求，板子一套即可。总体时间复杂度为 $O(n+m \log n)$。

完结撒花~

献上蒟蒻的 AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2000010;

int k,n,m,key,x;
bool flag;//输出判定，我个人的用法 

struct node//经典区间线段树 
{
	int l,r;
	int dat;
}t[N*4];

void build(int p,int l,int r)//建树 
{
	t[p].l=l,t[p].r=r;
	if(l==r)
	{
		t[p].dat=0;
		return;
	}
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	t[p].dat=min(t[p*2].dat,t[p*2+1].dat);
}

void change(int p,int x,int v)//单点更改 
{
	if(t[p].l==t[p].r)
	{
		t[p].dat+=v;
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(x<=mid) change(p*2,x,v);
	else change(p*2+1,x,v);
	t[p].dat=min(t[p*2].dat,t[p*2+1].dat);
}

int main()
{
	scanf("%d",&k);
	while(k--)
	{
		scanf("%d %d",&n,&m);
		build(1,1,n);
		flag=false;
		int line=1;//至少数量为1，即最小值必须大于等于这个数 
		for(int i=1;i<=m;i++)
		{
			scanf("%d %d",&key,&x);
			if(flag) continue;
			flag=true;
			switch(key)
			{
				case 1:
					change(1,x,1);//自己加1 
					if(t[1].dat<line) flag=false;
					break;
				case 2:
					change(1,x,-1);line--;//自己和至少所需数量减1 
					if(t[1].dat<line) flag=false;
					break;
			}
			if(flag) printf("%d\n",i);
		}
		if(!flag) printf("-1\n");
	}
	return 0;
}
//我自己是用t[1]直接查询1-n最值的，没有写区间查询函数。想了解的OIer可以自行查阅相关资料。
```


---

## 作者：_JF_ (赞：4)

[P9343 一曲新词酒一杯 ](https://www.luogu.com.cn/problem/P9343)

验题人题解。

反面考虑，考虑什么时候能完成染色：

- 对于 $x$ 号，一次 $1$ 操作和一次 $2$ 操作。

- 任意两个不相同的 $x$ ，均有一个 $2$ 操作。

- 全部 $x$ 均有一次 $1$ 操作。

所以分别对他统计最早出现的情况，开几个桶就能做完，三种情况出现最早的那个就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
struct node{
	int fir,sec;
}vis2[N];
int vis[N],vis1[N];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int sum=n,sum1=0;
		bool f=true;
		for(int i=1;i<=n;i++)	vis[i]=vis2[i].fir=vis2[i].sec=vis1[i]=0;	
		for(int i=1,x,y;i<=m;i++){
			cin>>x>>y;
            if(f==false)	continue;
			if(x==1&&vis[y]==0&&y<=n&&f!=false)
				sum--,vis[y]=1,vis2[y].fir=1;
			if(sum==0&&f!=false)	{f=false,cout<<i<<endl;}
			if(x==2&&vis1[y]==0&&y<=n)	
				sum1++,vis1[y]=1,vis2[y].sec=1;
			if(vis2[y].fir==1&&vis2[y].sec==1&&f!=false)	{f=false,cout<<i<<endl;}
			if(sum1==2&&f!=false)	{f=false,cout<<i<<endl;}
		}
		if(f==true)	cout<<-1<<endl;
	}
}
```


---

## 作者：Loser_Syx (赞：3)

## 思路

还是分类讨论每一种情况：

- 全是操作 $1$ 时，只需统计一共贴上的不同的杯子数量是否等于总数即可。

- 全是操作 $2$ 时，由于如果有 $2$ 种不同的 $x$ 的话，那么所有的一定会至少贴上一张。

- 当 $x$ 固定时，显然如果操作 $1$ 之后有了操作 $2$，或操作 $2$ 之后有了操作 $1$，那么一定至少能贴上一张。

- 当 $\sum n, \sum m \leq 3 \times 10^3$ 时，显然可以每次模拟贴红纸，然后每次都暴力判定是否有缺的。

这样就可以浅浅得到 $80$ 分。

其实如果推出了上述情况的答案计算方式，那么第 $5$ 个 Subtask 就容易许多了。

考虑将前 $3$ 种情况结合起来。

也就是说，你需要统计好每一个贴上红纸的不同的杯子数量是否等于总数；是否存在 $2$ 种不同 $x$ 的操作 $2$；还有 $x$ 相同时是否出现过至少一次的操作 $1$ 与 $2$。

然后就 AC 了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace fastIO{
	inline int read(){
		int x = 0, s = 1;
		char c = getchar();
		while(c < '0' || c > '9'){
			if(c == '-') s = -1;
			c = getchar();
		}
		while(c >= '0' && c <= '9'){
			x = (x << 3) + (x << 1) + (c ^ '0');
			c = getchar();
		}
		return x * s;
	}
	inline void Write(int x){
		if(x > 9) Write(x / 10);
		putchar(x % 10 + '0');
	}
	inline void write(int x, char c){
		Write(x);
		putchar(c);
	}
}
using namespace fastIO;
int a[1010010];
int main(){
	int T = read();
	while(T--){
		int n = read(), m = read();
		for(register int i = 1; i <= n; ++i) a[i] = 0;
		int dif = n, ___ = 0;
		bool flag = 0;
		int lll = 0;
		int _ = 1, ans = 0;
		for(; _ <= m; _++){
			int x = read(), y = read();
			if(x == 2 && a[y] == 1) {
			    ans = _;
			    break;
			}
			if(x == 2 && lll == 0){
				lll = y;
				dif = 1;
			}else if(x == 2){
				if(y != lll){
					flag = 1;
					ans = _;
					break;
				}
				dif = 1;
			}else{
				if(y == lll && lll != 0){
					ans = _;
					break;
				}else{
					if(a[y] == 0){
						if(lll == 0) dif--;
						a[y] = 1;
					}
				}
			}
			if(dif == 0) {
				ans = _;
				break;
			}
		}
		for(_ += 1; _ <= m; _++){
			int x = read(), y = read();
		}
		if(ans > 0) write(ans, '\n');
		else {putchar('-');putchar('1');putchar('\n');}
	}
	return 0;
}
```

---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9343)

简单分块板子。

我们维护每个块的权值和，当一个杯子被贴上红纸时，它的权值为 $0$，否则为 $1$（初始全为 $1$）。显然地，当所有块的权值总和为 $0$ 时，所有的杯子都被贴上了红纸。

需要注意的是，我这里用的是减，所以操作之前要额外判断该杯子是否已经为 $0$（否则变成负数，统计时会出问题）。

单点修改 $\Theta(1)$，区间修改 `1~(x-1)` 和 `(x+1)~n` 为 $\Theta(\sqrt{n})$（当然操作之前要判断是否越界），每次查询 $\Theta(\sqrt{n})$。

总复杂度 $\Theta(m\sqrt{n})$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,M=5e2+10;
int n,m,T,len,cnt,bar[N],st[M],ed[M],sum[M];
bool a[N];
void modify(int x,int y)
{
    int l=bar[x],r=bar[y];
    if(l==r)
    {
        for(int i=x;i<=y;i++)if(a[i]&&sum[l])a[i]=0,sum[l]--;
        return;
    }
    for(int i=l+1;i<=r-1;i++)sum[i]=0;
    for(int i=x;i<=ed[l];i++)if(a[i]&&sum[l])a[i]=0,sum[l]--;
    for(int i=y;i>=st[r];i--)if(a[i]&&sum[r])a[i]=0,sum[r]--;
    return;
}
signed main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        len=sqrt(n);cnt=n/len+bool(n%len);
        for(int i=1;i<=n;i++)a[i]=1;
        for(int i=1;i<=cnt;i++)
        {
            st[i]=ed[i-1]+1;ed[i]=min(i*len,n);sum[i]=ed[i]-st[i]+1;
            for(int j=st[i];j<=ed[i];j++)bar[j]=i;
        }
        int flag=0;
        for(int i=1;i<=m;i++)
        {
            int op,x,tmp=0;
            scanf("%d%d",&op,&x);
            if(flag)continue;
            if(op==1&&a[x]&&sum[bar[x]])a[x]=0,sum[bar[x]]--;
            else if(op==2){if(x>1)modify(1,x-1);if(x<n)modify(x+1,n);}
            for(int i=1;i<=cnt;i++)tmp+=sum[i];
            if(!tmp)flag=i;
        }
        printf("%d\n",!flag?-1:flag);
    }
    return 0;
}
```

[record](https://www.luogu.com.cn/record/110370877)

---

## 作者：masonpop (赞：2)

蒟蒻又来赛后补题了！

这道题作为第一题还是非常简单的。我们容易发现，所有点都有红纸，当且仅当某一次操作后，满足以下条件之一：

* 存在一个位置，使得它同时被 $2$ 操作和 $1$ 操作选中了一次。

* 所有点都经历了 $1$ 操作。

* 存在两个不同的位置同时经历了 $2$ 操作。

开个桶简单维护一下这些信息即可。时间复杂度 $O(\sum n)$，默认 $n$，$m$ 同阶。代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
int t,n,m;
int one[maxn],two[maxn];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)one[i]=two[i]=0;
		int cnt=0;
		int cnt2=0;
		int ans=0;
		for(int i=1;i<=m;i++)
		{
			int op,x;
			scanf("%d%d",&op,&x);
			if(ans)continue;
			if(op==1)
			{
				if(!one[x])one[x]=1,cnt++;
				if(two[x] || cnt==n)
				{
					ans=i;
				}
			}
			else
			{
				if(!two[x])two[x]=1,++cnt2;
				if(cnt2==2 || one[x])
				{
					ans=i;
				}
			}
		}
		if(ans)printf("%d\n",ans);
		else puts("-1");
	}
	return 0;
}
```


---

## 作者：andyli (赞：2)

除了常规 $O(m)$ 做法，还可以二分答案。这样，在判定时可以遍历操作，再判断 $n$ 个点是否都有红纸。  

判定时，对于 $n$ 个点每个点分别对是否进行过两种操作记录两个值。对于每个点，要求存在 $1$ 操作或有非自己的 $2$ 操作。  

```cpp
auto bsearch(auto&& check, auto ok, auto ng) {
    while (std::abs(ok - ng) > 1) {
        auto x = (ng + ok) >> 1;
        if (check(x))
            ok = x;
        else
            ng = x;
    }
    return ok;
}
int main() {
    multipleTests([&]() {
        dR(int, n, m);
        dRV(int, a, m, 2); // 操作
        auto check = [&](int m) {
            vi c(n), d(n);
            for (int i = 0; i < m; i++)
                if (a[i][0] == 1)
                    c[a[i][1] - 1] = 1;
                else
                    d[a[i][1] - 1] = 1;
            int t = sum(d);
            bool ok = true;
            for (int i = 0; i < n; i++)
                ok &= c[i] || (d[i] && t > 1) || (!d[i] && t);
            return ok;
        };
        if (!check(m))
            return writeln(-1);
        writeln(bsearch(check, m, 0));
    });
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：2)

### 题目大意

一共有 $n$ 壶酒，你可以将第 $x$ 壶酒或者将除第 $x$ 壶酒以外的所以酒打上标记，求在第几轮后会将所有的酒都打上标记。

### 题目分析

首先来想暴力，开个筒子，每回将所有的酒打上标记，然后每回判断是否全部打上标记，但是时间复杂度是 $\mathcal O(T\times n \times m)$ 的，肯定过不了。

我们发现，当所有的都被打过标记，只有如下几种情况：

1. 有有一轮将一壶酒 $x$ 被单独打过标记，且有一轮将除第 $x$ 壶酒以外的都打过标记。

2. 有一轮将除第 $x$ 壶酒以外的都打上标记，有一轮将除第 $y$ 壶酒以外的都打上标记，且 $x \neq y$。

3. 所有的酒都被单独打上过标记。

于是，我们可以记一个 $cnt1_i$ 表示第 $i$ 壶酒是否被单独打标记，再记一个 $cnt2_i$ 表示是否有一轮除第 $i$ 壶酒都被打过标记，当 $\sum\limits_{i = 1}^{i \le n} cnt1_i = cnt2_i$ 时，说明，都被打过标记，当 $cnt2$ 中有大于等于 $2$ 个为 `true`，说明都被打过标记，当 $cnt1$ 中都为 `true`，说明都被打过标记。

于是，最终的时间复杂度是 $\mathcal O(T \times m)$ 的。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 2e5 + 5;
int T, out, ans, n, m, opt, x, cnt2[N], tmp;
bool cnt1[N], flag;
int main()
{
	scanf("%d", &T);
	while(T--)
	{
		memset(cnt1, false, sizeof(cnt1));
		memset(cnt2, 0, sizeof(cnt2));
		tmp = 0, out = 0, ans = 0;
		scanf("%d %d", &n, &m);
		for(int i = 1;i <= m;i++)
		{
			scanf("%d %d", &opt, &x);
			if(out || ans == n)
				continue;
			if(opt == 1)
			{
				if(!cnt1[x])
					ans++;
				cnt1[x] = true;
				if(cnt2[x] || ans == n)
					out = i;
			}
			else
			{
				cnt2[x]++;
				tmp++;
				if(tmp != cnt2[x])
					out = i;
				if(cnt1[x])
					out = i;
			}
		}
		(out || ans == n) ? printf("%d\n", out) : printf("-1\n");
	}
	return 0;
}
```

---

## 作者：lailai0916 (赞：1)

## 原题链接

- [洛谷 P9343 一曲新词酒一杯](https://www.luogu.com.cn/problem/P9343)

## 解题思路

维护一个集合，集合元素代表至少有一张红纸的酒杯编号：

- 操作一：将 $x$ 插入集合。
- 第一次操作二：将 $1\sim n$ 除了 $x$ 的所有元素插入集合。
- 后续的操作二：因为已经进行过一次操作二，集合内至少有 $n-1$ 个元素。此时再进行操作二，只要两次操作的 $x$ 不相同，每杯酒上就至少有一张红纸。
- 判断：由于集合会自动去重，当集合内有 $n$ 个元素时，一定为 $1\sim n$，即每杯酒上都至少有一张红纸。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	set<int> s;
	while(T--)
	{
		s.clear();
		int n,m;
		cin>>n>>m;
		int ans=-1,p=0;
		for(int i=1;i<=m;i++)
		{
			int o,x;
			cin>>o>>x;
			if(ans!=-1)continue;
			if(o==1)
			{
				s.insert(x);
			}
			else if(o==2)
			{
				if(!p)
				{
					for(int j=1;j<=n;j++)
					{
						if(j!=x)s.insert(j);
					}
					p=x;
				}
				else if(x!=p)ans=i;
			}
			if(s.size()==n)ans=i;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：QWQ_SenLin (赞：1)

本蒟蒻不知道怎么就想到了 `set`..

令 $S$ 为当前没贴上红纸的酒的编号集合，则只需要维护这个集合，即在每次操作后更新 $S$。如果 $S$ 在某次操作后变成空集合，就说明在这次操作后所有的酒都贴上了红纸，就可以直接得出答案了。反之，如果 $S$ 在所有操作后没变成空集，就说明还有酒没贴上红纸，输出 `-1`。

```cpp
n = read(); m = read();
set <int> qwq;
int ans = -1;
for(register int i = 1;i <= n;i++) //初始化集合
    qwq.insert(i);
for(register int i = 1;i <= m;i++){
    int op , x;
    scanf("%d%d" , &op , &x);
    if(ans != -1)
        continue;
    if(op == 1 && qwq.find(x) != qwq.end())
        qwq.erase(x);
    if(op == 2){
        if(qwq.find(x) == qwq.end()){ //不包括x，操作后集合为空。
            qwq.clear();
            ans = i;
            continue;
        }
        qwq.clear();
        qwq.insert(x);
    }
    if(qwq.empty()) 
        ans = i; //为空记录答案
}
printf("%d\n" , ans);
```

---

## 作者：Nemophery (赞：1)

线段树 & 珂朵莉树模板  
我用的是珂朵莉树。  
对于操作 $1$，我们只需要修改第 $x$ 个数就行。  
对于操作 $2$，我们可以合并区间 $[1, x - 1]$ 并更改为 $1$，再合并区间 $[x + 1, n]$ 并更改为 $1$。  
每次扫一遍树即可。  
AC code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 1;
struct node {
    int l, r;
    mutable int d;
    node(int a, int b, int c) {
        l = a;
        r = b;
        d = c;
    }
    node(int a) {
        l = a;
    }
    bool operator < (node x) const {
        return l < x.l;
    }
};
#define s_it set<node>::iterator
set <node> s;
int n, q;
int a[N];
void build(int n) { //建树
	for (int i = 1; i <= n; i++) { s.insert(node(i, i, a[i])); }
	s.insert(node(n, n, 0));
}
s_it split(int pos) { //分裂
    s_it it = s.lower_bound(node(pos));
    if (it != s.end() and it->l == pos) { return it; }
    it--;
    int l = it->l, r = it->r;
    int d = it->d;
    s.erase(it);
    s.insert(node(l, pos - 1, d));
    return s.insert(node(pos, r, d)).first;
}
void assign(int l, int r, int d) { //合并
    s_it it2 = split(r + 1), it1 = split(l);
    s.erase(it1, it2);
    s.insert(node(l, r, d));
}
void update(int l, int r, int d) { //修改
    s_it it2 = split(r + 1);
    for (s_it it1 = split(l); it1 != it2; it1++) { it1 -> d += d; }
}
bool check(int l, int r) { //判断是否符合要求
    s_it it2 = split(r + 1);
    for (s_it it1 = split(l); it1 != it2; it1++) {
		if (it1 -> d < 1) { return false; }
	}
	return true;
}
int t;
int main() {
	scanf("%d", &t);
	while (t--) {
		int n, m;
		scanf("%d%d", &n, &m);
		s.clear();
		for (int i = 1; i <= n; i++) { a[i] = 0; }
		build(n);
		bool flag = false;
		int pos = 0;
		for (int i = 1; i <= m; i++) {
			int op, x;
			scanf("%d%d", &op, &x);
			if (flag) { continue; }
			if (op == 1) { update(x, x, 1); }
			if (op == 2) {
				assign(1, x - 1, 1);
				if (x + 1 <= n) { assign(x + 1, n, 1); }
			}
			if (check(1, n)) {
				pos = i;
				flag = true;
			}
		}
		printf("%d\n", (flag ? pos : -1));
	}
	return 0;
}
```

---

## 作者：zzy0618 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P9343)

#### 大体思路

首先，我们有 $4$ 中情况能够完成所有酒杯都贴上一张红纸：

1. 做了 $n$ 次 $x$ **不同** 的 $1$ 操作。

2. 做了 $1$ 次 $1$ 操作和 $1$ 次 $2$ 操作，两次 $x$ **相同**。

3. 做了 $1$ 次 $2$ 操作和 $1$ 次 $1$ 操作，两次 $x$ **相同**。

4. 做了 $2$ 次 $2$ 操作，两次 $x$ **不同**

如何保证每次操作都是 $O(1)$ 或者 $O(\log(n))$ 呢？

对于 $1$ 操作，我们可以使用一个 $a$ 数组记录。对于 $2$ 操作，我们用一个 ```map```。

第 $1$ 种情形。初始一个 $ans=n$。每次到 $1$ 操作，如果 $a_x \not = 1$，将 $a_x$ 变为 $1$，将 $ans-1$，如果 $ans=0$ 则输出。

第 $2$ 种情形。每次将 $2$ 操作的位置记录到 ```map``` 当中，如果这次 $1$ 操作有 $x$，```map``` 中也有 $x$，则输出。

第 $3$ 种情形。当遇到 $2$ 操作时，如果 $a_x=1$ 则输出。

第 $4$ 种情形。如果 ```map``` 的大小减去 ```map``` 中 $x$ 的数量，如果大于 $0$，说明至少有两次 $x$ 不同的操作，输出。

作者这里图省事开了 ```map```，所以会慢一些，看了正解过后发现再开一个桶也是可以的。

#### 完整代码

上面已经解释很多，代码就不再多写注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-')f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
int a[100001];
signed main() {
    register int t, n, m, o, x, i, j, ans, flag;
    t = read();
    while (t--) {
	    map<int, int> mp;
	    n = read(); m = read();
	    ans = n; flag = 1;
	    for (i = 1; i <= n; i++)a[i] = 0;//初始化
	    for (i = 1; i <= m; i++) {
		    o = read(); x = read();
		    if (flag == 0)continue;
		    if (o == 1) {
			    if (a[x] == 0) {
				    a[x] = 1;
				    ans--;
				}
			}
		    else if(o == 2)mp[x]++;
		    if (ans == 0) {
				printf("%d\n", i);
			    flag = 0;
			}//情况 1
		    else if(o == 1 && mp.count(x) > 0 ){
				printf("%d\n", i);
			    flag = 0;
			}//情况 2
			else if(o == 2 && a[x] == 1){
				printf("%d\n", i);
			    flag = 0;
			}//情况 3
			else if(o == 2 && mp.size() - mp.count(x) > 0){
				printf("%d\n", i);
			    flag = 0;
			}//情况 4
		}
	    if (flag == 1)printf("-1\n");
	}
    return 0;
}
```





---

## 作者：ivyjiao (赞：1)

因为这道题只考虑贴了或没贴，所以我们可以把贴纸看成把要贴的区间都推平成“贴了”的状态。

那么：

首先对于 $op=1$，可以看作是一个 $[v,v]$ 的推平成“贴了”的操作。

其次对于 $op=2$，可以看作两个分别是 $[1,v-1]$ 和 $[v+1,n]$ 的推平成“贴了”的操作。

然后发现这就是个珂朵莉树板子题。

由于这道题只有推平操作，所以不用担心被卡。

------------

关于珂朵莉树的实现过程此处不再赘述。

函数实现可在这里看：<https://oi-wiki.org/misc/odt/>。

------------

代码：


```
#include<bits/stdc++.h>
using namespace std;
int t,n,m,op,v,ans,k;
struct CT{
    int l,r;
    mutable int v;
    CT(const int &il,const int &ir,const int &iv) : l(il),r(ir),v(iv){};
    inline bool operator<(const CT &o) const{return l<o.l;};
};
set <CT> ODT;
inline int read(){
    int s=0,f=1;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+ch-48,ch=getchar();
    return s*f;
}
auto spilt(int x){
    if(x>n) return ODT.end();
    auto it=--ODT.upper_bound(CT(x,0,0));
    if(it->l==x) return it;
    int l=it->l,r=it->r,v=it->v;
    ODT.erase(it);
    ODT.insert(CT(l,x-1,v));
    return ODT.insert(CT(x,r,v)).first;
}
void assign(int l,int r,int v){
    auto itr=spilt(r+1),itl=spilt(l),it=itl;
    for(;itl!=itr;++itl) ans-=itl->v*(itl->r-itl->l+1);
    ODT.erase(it,itr);
    ODT.insert(CT(l,r,v));
    ans+=v*(r-l+1);
}
int main(){
    t=read();
    while(t--){
	    ODT.insert(CT(1,n,0));
        n=read();
        m=read();
        for(int i=1;i<=m;i++){
            op=read();
            v=read();
            if(ans<n){
                if(op==1) assign(v,v,1);
                else if(op==2) assign(1,v-1,1),assign(v+1,n,1);
                if(ans>=n) k=i;
            }
        }
        if(k==0) --k;
        cout<<k<<endl;
        k=0;
        ans=0;
        ODT.clear();
    }
}
```

---

## 作者：Untitled10032 (赞：1)

## 解法

如果你在比赛时懒得讨论那么多满足要求的情况怎么办呢？写棵线段树就行了。

简而言之，题目要求我们对于一个零一串，处理三种操作：

- 单点修改。
- 除某点外全部修改（其实就是区间修改）。
- 整体求和（区间查询）。

可以使用线段树维护每个区间权值和，如果查询整个序列的和等于序列长度，那么说明满足题目要求，输出操作次数即可。

**注意判断出所有酒上都有红纸后，依然要把剩下的输入都读完。**

## 代码

```cpp
#include <iostream>
#include <cstring>

constexpr int N = 2e5 + 5;
using namespace std;

class SGT {
    int val[N << 2];
    bool lazy[N << 2];
    int L, R;
public:
    inline int ls(const int id) const {
        return id << 1;
    }
    inline int rs(const int id) const {
        return (id << 1) | 1;
    }
    inline void setRange(const int l, const int r) {
        L = l, R = r;
    }
    inline void clear(const int n) {
        memset(val, 0, (n *sizeof(int)) << 2);
        memset(lazy, 0, (n * sizeof(bool)) << 2);
    }
    inline void pushdown(const int id, const int l, const int r) {
        if (!lazy[id])
            return;
        const int mid = (l + r) >> 1;
        val[ls(id)] = mid - l + 1;
        val[rs(id)] = r - mid;
        lazy[ls(id)] = lazy[rs(id)] = true;
        lazy[id] = false;
    }
    void modify(const int id, const int l, const int r) {
        if (l >= L && r <= R) {
            lazy[id] = true;
            val[id] = r - l + 1;
            return;
        }
        pushdown(id, l, r);
        const int mid = (l + r) >> 1;
        if (L <= mid)
            modify(ls(id), l, mid);
        if (R > mid)
            modify(rs(id), mid + 1, r);
        val[id] = val[ls(id)] + val[rs(id)];
    }
    inline int total() const {
        return val[1];
    }
}sgt;

int main() {
    ios::sync_with_stdio(false);
    int t;
    cin >> t;
    while (t--) {
        bool success = false;
        int n, m;
        cin >> n >> m;
        sgt.clear(n);
        for (int i = 1; i <= m; i++) {
            char opt;
            int x;
            cin >> opt >> x;
            if (opt == '1') {
                sgt.setRange(x, x);
                sgt.modify(1, 1, n);
            } else if (opt == '2') {
                if (x != 1) {
                    sgt.setRange(1, x - 1);
                    sgt.modify(1, 1, n);
                }
                if (x != n) {
                    sgt.setRange(x + 1, n);
                    sgt.modify(1, 1, n);
                }
            }
            if (sgt.total() == n) {
                cout << i << '\n';
                for (i++; i <= m; i++)
                    cin >> opt >> x;
                success = true;
                break;
            }
        }
        if (!success)
            cout << "-1\n";
    }
    return 0;
}
  
```



---

## 作者：Iniaugoty (赞：1)

~~这么容易的思路我为啥要写这么长的题解啊。~~

于是就删了好多废话。

酒桌上共有 $n$ 杯酒，标号为 $1\sim n$。**依次**进行 $m$ 次操作，操作有 $2$ 种类型：

- 形如 `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。

- 形如 `2 x`：给除了 $x$ 号酒的其它 $n−1$ 杯酒分别贴上 $1$ 张红纸。

在**至少**几次操作后，每杯酒上至少有一张红纸（初始时一张纸都没有）？

# subtask 1

**这个部分只有 $1$ 操作。**

如果在一次操作中，一个酒**第一次**贴上纸，则称这是一次用价值的操作。

容易发现，当且仅当有价值的操作数为 $n$ 时所有酒都贴过纸。

# subtask 2

**这个部分只有 $2$ 操作。**

容易发现，如果有两次操作的 $x$ 不同，那么所有酒就都贴过纸了。

记录第一次操作的 $x$，找到第一个与其不同的操作即可。

# subtask 3

**这个部分每个 $x$ 都一样。**

容易发现，如果对同一个酒， $1$ 和 $2$ 号操作都进行过，那么所有酒就贴过纸了。

用两个变量记录是否进行过 $1$ 或 $2$ 操作即可。


# subtask 4&5

**这个部分没有特殊性质了。**

其实把前几个都结合起来就行了。

code：

```cpp
//需要注意的是：t1 和 t2 一定要用 bool 类型，不然 memset 会 TLE！
//当然手动清零也不是不行
int solve(){
	int ret=-1;//答案
	memset(t1,0,sizeof t1);//存储每个酒瓶是否进行过 1 操作
	memset(t2,0,sizeof t2);//同上，但是 2 操作
	cnt=flag=0;//有价值的操作数、第一次 2 操作的酒标号
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>o>>x;
		if(ret>0) continue;
		if(o==1&&!t1[x]) cnt++,t1[x]=1;
		if(o==2) t2[x]=1,flag=flag==0?x:flag;

		if(cnt==n) ret=i;//subtask 1
		if(o==2&&flag!=x) ret=i;//subtask 2
		if(t1[x]&&t2[x]) ret=i;//subtask 3
	}
	return ret;
}
```

全文完。

---

## 作者：GeorgeAAAADHD (赞：1)

### 题目大意：
$T$ 组数据，每组数据给出 $n$ 和 $m$，代表有 $n$ 个酒杯按 $1\sim n$ 标号。$m$ 次操作，每次操作会将 $x$ 号酒杯贴上纸或将除 $x$ 号酒杯的其他酒杯贴上纸。对于每组数据，输出在**至少**几次操作后所有酒杯都贴上纸。如最后还有酒杯没贴上纸，输出 $-1$。

### 分析：

首先，我们分析一下有多少种可以贴完所有酒杯的方法：

1. 只进行 $1$ 操作，那么可以开一个布尔数组和一个计数变量 $sum$，每次进行**有效的**操作后将计数加上一，如果 $sum=n$，则记下当前操作次数并把剩下的操作读完后输出即可。

2. 只进行 $2$ 操作，那么只有当两次 $2$ 操作的操作数不同时才能贴上所有酒杯。于是我们可以开一个变量 $k$ 记下第一次 $2$ 操作的操作数，以后的 $2$ 操作只需要判断操作数是否等于 $k$ 即可。

3. 同时进行 $1$、$2$ 操作。如果先进行 $1$ 操作，那么后面的 $2$ 操作要判断操作数所对应的酒杯是否被贴过纸；如果先进行 $2$ 操作，那么后面进行 $1$ 操作时要判断贴上的酒杯是否是 $2$ 操作那个唯一没有贴过纸的酒杯。

综上，我们可以通过这个思路通过本题，时间复杂度为 $O(\sum m)$，可以通过本题。

注意：每组数据要先初始化布尔数组，而最坏情况下 `memset` 会消耗大约 `750ms` 的时间（亲测），还是可以通过的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std; 
int t,n,m,p,q,k,ans=0,sum=0; 
bool a[200005]={0},f=1;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		memset(a,0,sizeof(a));
		k=0;f=1;ans=-1;sum=0;
		for(int i=1;i<=m;i++){
			cin>>p>>q;
			if(f){
				if(p==1){
					if(!a[q]){
						a[q]=1;
						sum++;
					}
					if(sum==n||k==q){
						ans=i;
						f=0;
					}
				}
				else{
					if(k!=0&&k!=q||a[q]){
						ans=i;
						f=0;
					}
            	else k=q;
				}
			}
		}
		cout<<ans<<endl;
	}
}
```

---

## 作者：Cure_Wing (赞：1)

[题目](https://www.luogu.com.cn/problem/P9343)

### 解析
考虑操作一，给一杯酒贴上一张红纸，这个很方便操作，$\mathcal{O}(1)$ 标记即可。

考虑操作二，给除了给定酒的酒贴上一张红纸，这个很容易想到一种 $\mathcal{O}(n)$ 的暴力标记。但是你会发现，在这次操作之后，至多只有一杯酒（这杯酒）没有被标记。此时如果这杯酒已经被标记，那么任务完成。反之则继续操作。

这个时候不难想到一点，操作二至多执行 $2$ 次。对于相同的 $x$，操作显然无效；对于不同的 $x$，操作之后显然每一杯酒就都有了红纸，实际上操作二的总复杂度只有 $\mathcal{O}(n)$。所以我们只需要打个标记看看操作二是否被执行过了即可，除了第一个，其余的不必实际操作。

这样子我们就写出了复杂度约为 $\mathcal{O}(\sum n+\sum m)$ 的代码。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using std::cin;using std::cout;
constexpr int N=200005;
int t,n,m,o,x,cnt,now=-1;
bool vis,p[N]; 
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
    for(cin>>t;t--;){
    	cin>>n>>m;
    	for(int i=1;i<=m;++i){
    		cin>>o>>x;
    		if(o==1){//操作一直接标记
    			cnt+=!p[x];
    			p[x]=1;
			}else if(o==2){//操作二暴力修改第一组
				if(p[x]==1) cnt=n;
				else cnt=n-1;
				if(!vis){
					for(int i=1;i<x;++i) p[i]=1;
					for(int i=x+1;i<=n;++i) p[i]=1;
				}
				vis=1;//剩下的就不用动手了！
			}
			if(cnt==n)
				if(now==-1)
					now=i;//我的目标达成了！
		}
		cout<<now<<'\n';
		now=-1;vis=cnt=0;
		for(int i=1;i<=n;++i)
			p[i]=0;//多测不清空，爆零两行泪
	}
	return 0;
}
```

---

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9343)       
我们设 $a_i$ 为第 $i$ 号酒被贴上的红纸数量，设 $ans$ 为为所有 $a_i$ 在**大于 $1$**  的情况下并满足**所有附加条件**的 $a_i$ 和。           
再设 $mx$ 为超过 $1$ 的 $a_i$ 数量。               
那么，我们对于第一种操作，先看一下 $a_x$ 的值。如果 $a_x≥1$，那么 $ans$ 加 $1$，否则 $mx$  加 $1$。 最后要修改 $a_x$。         
对于第二种操作，我们首先要对 $a_1$ 到 $a_n$ 进行修改，再对 $a_x$ 进行修改。             
我们继续判断，如果 $a_x≥1$，那么 $ans$ 加 $mx-1$，$mx$ 修改为 $n$。否则，$ans$ 加 $mx$，$mx$ 修改为 $n-1$。          
在每个操作之后，我们设 $sum=\sum\limits^n_{i=1}a_i$。       
如果已经达到，我们记录下步数，读入最后几个操作即可。           
最后要输出步数，记得判 `-1`。        
考虑到这是区间修改，区间查询，$O(nm)$ 过不去，我们需要优化。      
直接加入树状数组即可。      
这里树状数组的两个数组需要暴力清空，不然会 TLE。            
总时间复杂度 $O(n\log m)$，可以通过。        
[CODE](https://www.luogu.com.cn/paste/pmg1s3hq)

---

## 作者：Nygglatho (赞：0)

设 $f(x)$ 表示第 $x$ 号酒贴上 **至少** $1$ 张红纸所需要的操作次数，如果第 $x$ 号酒没有贴上纸则 $f(x) = 0$。

朴素算法：
- 对于第 $i$ 次操作，如果是操作 $1$，如果 $f(x) \ne 0$，则 $f(x)$ 修改为 $i$。
- 对于第 $i$ 次操作，如果是操作 $2$，则对于所有 $j(1 \le j \le n)$，如果 $f(j) \ne 0$ 且 $j \ne x$，则 $f(x)$ 修改为 $i$。

最后，对于所有 $i(1 \le i \le n)$，如果 $f(i) = 0$，则答案为 `-1`，否则，答案为 $\max\{f(1), f(2), \cdots, f(n)\}$。


```c
for (int i = 1; i <= M; ++i) {
	int o, x;
	scanf ("%d%d", &o, &x);
	if (o == 2) {
		for (int j = 1; j <= N; ++j)
		if (j != x && f[j] == 0) f[j] = i;
	} else {
		if (f[x] == 0) f[x] = i;
	}
}

```

时间复杂度为 $O(nm)$，可以得到 $60$ 分。

- - -

考虑如何减少操作 $2$ 的次数来优化。
- 优化 1：设 $tag(x)$ 代表第 $x$ 号酒是否进行过操作 $2$。如果 $tag(x) = 1$，由于没有删除操作，那么显然对 $x$ 进行操作 $2$ 没有意义了，不需要进行操作 $2$。
- 优化 2：对 $x$ 进行操作 $2$ 时，如果 $f(x) \ne 0$，那么该操作结束后，显然所有的 $f(x)$ 都不为 $0$，那么也不需要进行任何操作。

优化 1 可以保证对于所有相同的 $x$，操作 $2$ 只会进行 $1$ 次，而如果进行过操作 $2$，再对**另一个** $x$ 进行操作 $2$，由于操作 $2$ 的性质，$f(x)$ 必然不等于 $0$，此时通过优化 2，接下来都不需要操作了，也就是说，每组数据最多进行两次操作 $2$。

100 分：

```c
#include "bits/stdc++.h"
using namespace std;

int f[114514];//贴上纸的 
int tag[114514];//进行过操作 2 的 
int N, M;
bool chk() {
	for (int i = 1; i <= N; ++i)
		if (f[i] == 0) return 0;
	return 1;
}

int main() {
	int T;
	scanf ("%d", &T);
	while (T--) {
		
		scanf ("%d%d", &N, &M);
		for (int i = 1; i <= N; ++i) f[i] = tag[i] = 0;
		int flg = 0;
		for (int i = 1; i <= M; ++i) {
			int o, x;
			scanf ("%d%d", &o, &x);
			if (flg) continue;
			if (o == 2) {
				if (f[x]) {
				// 	if (tag[x] == 0)
						for (int j = 1; j <= N; ++j)
							if (f[j] == 0) f[j] = i;
					flg = 1;
				} else if (tag[x] == 0) {
					tag[x] = 1;
					for (int j = 1; j <= N; ++j)
						if (f[j] == 0 && j != x) f[j] = i;
				}
			} else {
				if (f[x] == 0) f[x] = i;
			}
		}
		if (!chk()) {
			puts("-1");
			continue;
		}
		int mx = 0;
		for (int i = 1; i <= N; ++i) mx = max(mx, f[i]);
		printf ("%d\n", mx);
	}
}
```

---

## 作者：FstAutoMaton (赞：0)

线段树好闪，拜谢线段树！！！！

看到这题，都是区间问题，很明显可以线段树做。

首先，查询时问的时所有数是否都有贴纸，那我们设有贴纸为 $1$，没有贴纸为 $0$，那么我们要维护的信息就是区间所有数的与。

至于修改，不是把区间加上几，而是变为几，把模板稍微改一下就行。

最后有一个小技巧，单点修改其实不需要另外写一个函数，只要把其当作一个长度为 $1$ 的区间即可。（即把点 $x$ 当成区间 $[x,x]$）。

具体代码如下：
```
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 2e5 + 5;
int T, n, m, cnt, s, ans = -1, t[kMaxN << 2], tag[kMaxN << 2];

void push_up(int u) {
  t[u] = t[u << 1] & t[u << 1 | 1];
}

void add_tag(int u, int l, int r, int x) {
  t[u] = tag[u] = x;
}

void push_down(int u, int l, int r) {
  if (tag[u]) {
    int mid = l + r >> 1;
    add_tag(u << 1, l, mid, tag[u]);
    add_tag(u << 1 | 1, mid + 1, r, tag[u]);
    tag[u] = 0;
  }
}

void update(int u, int l, int r, int L, int R, int x) {
  if (l > R || r < L) {
    return;
  } else if (L <= l && r <= R) {
    add_tag(u, l, r, x);
  } else {
    int mid = l + r >> 1;
    push_down(u, l, r);
    update(u << 1, l, mid, L, R, x);
    update(u << 1 | 1, mid + 1, r, L, R, x);
    push_up(u);
  }
}

int query() {
  return t[1];
}

int main() {
  ios ::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  for (cin >> T; T; T--, ans = -1, cnt = 0) {
    fill(t + 1, t + (n << 2) + 1, 0);
    fill(tag + 1, tag + (n << 2) + 1, 0);
    cin >> n >> m;
    for (int op, x, i = 1; i <= m; i++) {
      cin >> op >> x;
      if (op == 1) {
        update(1, 1, n, x, x, 1);
      } else {
        update(1, 1, n, 1, x - 1, 1);
        update(1, 1, n, x + 1, n, 1);
      }
      (ans == -1 && query()) && (ans = i);
    }
    cout << ans << "\n";
  }
  return 0;
}
```


---


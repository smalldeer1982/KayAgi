# 「SiR-1」Checkmate

## 题目背景

这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。

「来吧，游戏开始了。」

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。

每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。

你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n, m \leq 3$，$T \leq 5$。
- Subtask 2（20 points）：$n, m \leq 4$，$T \leq 10$。
- Subtask 3（20 points）：$n=1$。
- Subtask 4（20 points）：$n=m$。
- Subtask 5（20 points）：无特殊限制。

对于所有测试数据，$1 \leq n, m \leq 10^8$，$1 \leq T \leq 10^5$。

## 样例 #1

### 输入

```
4
1 3
2 2
3 4
7 13```

### 输出

```
2
4
17
162```

# 题解

## 作者：printfmingren (赞：13)

##### 题外话：本体题目出自番剧《NO GAME NO LIFE》且题目背景中「来吧，游戏开始了。」是第一季中男主“空”的口头禅。（强烈推荐观看《NO GAME NO LIFE ZERO》）
## 言归正传：
# 题目解读：
在 $n$ 行 $m$ 列的棋盘中放置一颗棋子，获得上下左右的未被放置棋子的格子数的值。
# 题目分析：
由题目可以得到在完全空白的棋盘中，放置在角能得到 $2$ 分，放置在棱能得到 $3$ 分，放置在中心块能得到 $4$ 分。（在 $1$ 行或 $1$ 列时，角能得 $1$ 分，棱能得 $2$ 分，无中心块）  
 $2 × 1$ 的方块中，放置在左方块（或右方块），能得到 $1$ 分，接下来放置另一方块会不得分。拓展到 $3 × 1$ 的方块中，无论先放置中间的块，能得到 $2$ 分，还是放置左右两块能得到 $1$ 分，亦或是从左到右（从右到左）依次排列都是 $2$ 分。  
如果我们不考虑空白位置（即任意位置都能得分），我们会发现刚好是上述分值的 $2$ 倍。

### 准备午休时想到了另一种理性的证明（应该能理解的）
首先我们先思考放置一枚棋子能带来什么影响。(可以先思考一下再接着看)  
我们在理想的情况下得到的分数是角 $×2+$ 棱 $×3+$ 中心块 $×4$ ，也就是每个块都拿到了能拿到的最大分值。（但是毕竟我们应该考虑影响）  
于是乎在考虑影响的情况下，我们的每一步行动都将获得一个分值，但是总分数（就是理想情况下的分数）将减去这个分值。因此，我们在考虑影响的情况下的能获得的分值是(角的值 $+$ 棱的值 $+$ 中心块的值) $/2$  
#### 如图所示：
![示例](https://cdn.luogu.com.cn/upload/image_hosting/qdzc4msh.png)

# 分类讨论情况如下：（也可以合并,因为考场没有想到第一个式子包含了第二个式子）
###  $n≥2$ 且 $m≥2$ 时
 $val=$ ( $angel×2+edge×3+center×4$ ) $/2$ 
###  $n<2$ 且 $m<2$ (就是 $1$ 行或者 $1$ 列的情况)
 $val=n+m- 2$ （每个块能得 $2$ 分，左右或上下块与中间的块相比各少 $1$ 分）  
由于 $n=1$ 或 $m=1$ ,可得 $val=n-1$ 或 $val=m-1$ (合并的时候能用到)  
从某种意义上来讲就是影响互相抵消
## 以上是考场时写出来的，以下是考后的优化（算是吧）
  $val=$ ( $angel×2+edge×3+center×4$ ) $/ 2$  
根据上式并列得出完整式子，式子得出过程如下：
```cpp
//sum==val,a==angel,b==edge,c==center
a=4;
b=2*n+2*m-2*a;
c=n*m-a-b;
sum=(a*2+b*3+c*4)/2;	//将此式化简可得:sum(val)=2*n*m-n-m;
```
将 $n=1$ 或 $m=1$ 带入得此式为： $sum=m-1$ 或 $sum=n-1$  
由此可知 $val=$ ( $angel×2+edge×3+center×4 $ ) $/2$   包含 $val=n+m-2$
## AC代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main()
{
	ll T;
	scanf("%lld",&T);
	for(ll i=1;i<=T;++i)
	{
		ll n,m,a,b,c,sum;
		scanf("%lld%lld",&n,&m);
		if(n>=2&&m>=2)
		{
			a=4;
			b=2*n+2*m-2*a;
			c=n*m-a-b;
			sum=(a*2+b*3+c*4)/2;
		}
		else
			sum=n+m-2;
		printf("%lld\n",sum);
	}
	return 0;
}
```
于是乎我推荐大家试试[[THUPC 2023 初赛] 大富翁](https://www.luogu.com.cn/problem/P9133)  
感觉两题都有相似之处。  
本蒟蒻的第一篇题解（问题已改正），求管理员通过，还请各位大佬指出错误，一同进步。（点个赞再走吧，QAQ）


---

## 作者：zhlzt (赞：7)

### 做法
其实这题不难，对于每两个相邻的棋子总有一个先放，这样就可以从另一个格子获得分数 $1$，而另一个棋子放置时，就无法从先放的格子获得分数了，答案就是相邻棋子的对数，即同一行相邻的 $n(m-1)$ 对和同一列相邻的 $m(n-1)$ 对，而 $n(m-1)+m(n-1)$ 又可以化简为 $2\times n\times m-n-m$，输出这个算式的结果就行了。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;scanf("%d",&T);
	while(T--){
		long long n,m;
		scanf("%lld%lld",&n,&m);
		printf("%lld\n",2*n*m-n-m);
	}
	return 0;
}
```

---

## 作者：251Sec (赞：3)

前言：这题本来是 Div.2 A，结果因为你谷的通过率要求变成了 Div.2 B。个人认为这题放在这个位置难度过低了。赛后看看通过率。

## Subtask 1

我会爆搜！

## Subtask 2

我会状压！

## Subtask 3

爆搜小数据，或者手玩，或者 DP，可以发现答案为 $m-1$。

## Subtask 4

考虑搜出答案数列为 $\{0,4,12,24,40,\cdots\}$，注意到相邻两项的差为等差数列 $\{4,8,12,16,\cdots\}$，可以用等差数列求和，得到答案为 $2n^2-2n$。

## Subtask 5

在刚刚的爆搜过程中，你可能已经发现，不管放置棋子的顺序如何，最终获得的分数都一样。这是为什么呢？

考虑一对相邻的格子，我们称它们为格子 $i$ 和格子 $j$。我们发现，如果格子 $i$ 放置棋子时格子 $j$ 还没有棋子，那么格子 $i$ 这次操作的得分就会多 $1$，反之亦然。我们又发现如果 $i$ 比 $j$ 先放置，$j$ 就比 $i$ 后放置。（这不是废话吗）

因此，一对相邻的格子一定会使最终答案恰好增加 $1$。

因此，最终答案就是相邻格子的对数。我们考虑分开统计横着相邻和竖着相邻的格子，不难得到答案为 $m(n-1)+n(m-1)=2nm-n-m$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T;
ll n, m;
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%lld%lld", &n, &m);
        printf("%lld\n", 2 * n * m - n - m);
    }
    return 0;
}   
```

---

## 作者：irris (赞：3)

## Preface

专门出 2A / 2B，出得更专业。251Sec，签到专家。

这种分离贡献的思想，在本场比赛的 T3 T4 均考查到了。~~快说感谢黎鸽鸽的无私提示。~~

## Solution

考察相邻的两个格子 A 和 B，如果 A 比 B 先放，会带来恰好 $1$ 的贡献；如果 A 不比 B 先放，也就是 B 比 A 先放，同样会带来恰好 $1$ 的贡献。

所以最优策略就是随便放，咋放都行，反正答案一样，贡献也没少谁的，于是我们只需要数一数 $n\times m$ 的棋盘总共有多少条格子线即可。纵向有 $n\times (m - 1)$ 条，横向有 $m\times (n - 1)$ 条加起来即可。

记得开 `long long`。

## Postscript

柚子厨咋这么强？

---

## 作者：2011FYCCCTA (赞：2)

# [原题](https://www.luogu.com.cn/problem/P9355)
我开考这场比赛时仅剩 30 分钟的时间了，竟然还能 AC 一道题！

---
### 分析
刚看到这题我一头雾水，再加上时间很紧，我就想着打个表先把数据范围很小的 `Subtask #1` 先过了。

结果这一打，还真打出名堂来了。

以下是我打的表：

| $n$ \ $m$ | $1$ | $2$ | $3$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $0$ | $1$ | $2$ |
| $2$ | $1$ | $4$ | $7$ |
| $3$ | $2$ | $7$ | $12$ |


[骗分记录](https://www.luogu.com.cn/record/110955535)

我观察了一会，发现每一行都是一个等差数列。

等差数列的每一项都可以通过公式求出来，这样就能以 $O(1)$ 的时间复杂度求出答案。

求出某一项需要知道等差数列的首项和公差，我们一项一项分析：

- 首项：很明显，根据如上表格，每一行的首项是 $n-1$。
- 公差：无法直观看出规律，可以根据入上表格列举一下：

	| $n=$ | 公差 |
	| :-----------: | :-----------: |
	| $1$ | $1$ |
	| $2$ | $3$ |
	| $3$ | $5$ |
	可以发现，公差就是第 $n$ 个奇数，即 $n \times 2 - 1$。
    
最后，再套入求等差数列的某一项的公式，最终的结果就变为了：
$$(n - 1) + (n \times 2 - 1) \times (m - 1)$$

**注意：本题卡 `int`！**

---
代码：
```cpp
#include <bits/stdc++.h>
#define int unsigned long long //注意！
using namespace std;
int t , n , m , ans;
signed main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> m;
		ans = (n - 1) + (n * 2 - 1) * (m - 1);
		cout << ans << endl;
	}
	return 0;
}
```

---
以上为考试时时间紧张的应急之策（并不知道公式原因），接下来，我来讲讲我赛后的思路。

首先，根据题目可得知，每个棋子能得到的分数在 $1$ ~ $4$ 之间。因此，我们可以分类讨论在每一种分数下，棋盘中会放置多少个能得对应分数的棋子，最后在加起来。

很明显，交替放置是最优策略。

注：在分类讨论时，$n$ 为宽（短边），$m$ 为长（长边），因此必定 $n \le m$。

综上，开始分类讨论：

0. 特判：$n = 1$ $\land$ $m = 1$，输出 $0$。
1. 得 $1$ 分

	特殊条件：$n = 1$
    
   这种棋子只会出现在棋盘是一维时棋盘的两端。
   
   - $m$ 是偶数
   
   	 $1$ 个。
     
   - $m$ 是奇数

	  $2$ 个。
2. 得 $2$ 分

	这种棋子只会出现在矩形棋盘的角落，一维棋盘的中间。
   
   若 $n > 1$
   
     - $n$，$m$ 都是偶数

       $2$ 个。

     - $n$ 是偶数且 $m$ 是奇数或 $n$ 是奇数且 $m$ 是偶数

       $2$ 个。

     - $n$，$m$ 都是奇数

       $4$ 个。
       
	若 $n = 1$
    
    - $m \div 2 - 1$ 个。

3. 得 $3$ 分

	特殊条件：$m \ge 3$ $\land$ $n \ge 2$。
   
   这种棋子只会出现在二维棋盘边缘上（除去角落），所以我们可以求出棋盘周长并减去角落里的棋子的数量（即 $ n > 1$ 时得 $2$ 分的情况）。

4. 得 $4$ 分

	特殊条件：$n \ge 3$ $\land$ $ m \ge 3$。
   
   由于上下左右都需要预留空间，因此只能在 $(n - 1) \times (m - 1)$ 的矩形内放置，其中的所有棋子均得 $4$ 分。

---
分类讨论代码：
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int t , n , m , s1 , s2 , s3 , s4 , ans;
signed main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> m;
		int tn = min(n , m) , tm = max(n , m);
		n = tn; m = tm;
		s1 = s2 = s3 = s4 = 0;
		
		//特判 
		if (n == 1 && m == 1) {cout << 0 << endl; continue;}
		
		//得1分 
		if (n == 1)
		{
			if (m % 2 == 0) s1 = 1;
			else s1 = 2;	
		} 
		
		//得2分 
		if (n > 1)
		{
			if (n % 2 == 0 && m % 2 == 0) s2 = 2;
			else if (n % 2 == 1 && m % 2 == 1) s2 = 4;
			else s2 = 2;
		}
		else s2 = m / 2 - 1;
		
		//得3分 
		if (m > 2 && n > 1) s3 = 2 * (n + (m - 2)) / 2 - s2;
		
		//得4分 
		if (n > 2 && m > 2)
		{
			int s = (n - 2) * (m - 2);
			if (s % 2 == 0) s4 = s / 2;
			else s4 = s / 2 + 1;
		}
		//求出结果 
		ans = s1 + s2 * 2 + s3 * 3 + s4 * 4;
		cout << ans << endl;
	}
	return 0;
}
```
  
---
[愉快的评测记录~](https://www.luogu.com.cn/record/list?pid=P9355&user=923403&page=1)

---

## 作者：linxuanrui (赞：2)

### 思路

我的思路好像和别人有点不一样。

首先，考虑最优策略。不难想到，当间隔着放棋子的时候，不会出现有棋子放下后得分不变的情况。也就是说，间隔放棋子是可以得到总分为最后答案的方案中，放棋子数量最少的。

不难写出一下的暴力代码（部分）：

```cpp
for(int i = 1;i <= n;i++){
  for(int j = 1;j <= m;j++){
    if(i & 1 == j & 1)ans += (i != 1) + (j != 1) + (i != n) + (j != m);
  }
}
```

接下来，我们考虑优化。不难发现，`(i != 1) + (j != 1) + (i != n) + (j != m)` 的总和不可能超过 $4$，有 $4$ 种可能，一个个枚举太麻烦了。所以，这里可以用到反面考虑。先设每个棋子都使得结果加 $4$，接下来再减去在边角的情况。可以参考一下图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/0uymbf8n.png)

不难发现，当 $n=m=4$ 时，在边角的情况就是 $n+m$。

不过，对于所有 $n$ 和 $m$，结果都是 $n+m$ 吗？这里就需要研究 $n,m$ 的奇偶性了，因为 $n,m$ 奇偶性不同时，构成的方案也不同。

不难发现，除了 $n,m$ 均为奇数时，结果是 $n + m + 2$，其他情况都是 $n+m$。

因为对于每个棋盘，间隔放棋子共会放 $\lceil n \times m \div 2\rceil$ 个棋子，所以总的得分是：


$$
\begin{cases}
\lceil n \times m \div 2\rceil - n - m + 2&n\text{ 为奇数且 }m\text{ 为奇数}\\
\lceil n \times m \div 2\rceil - n - m&\textrm{otherwise}
\end{cases}
$$

### 代码

```cpp
#include<bits/stdc++.h>
typedef unsigned long long ll;
using namespace std;
ll t,n,m;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> t;
    while(t--){
        cin >> n >> m;
        ll sum = 4ll * ((n * m + 1) / 2) - m - n - (m % 2 == 1 && n % 2 == 1 ? 2 : 0);
        cout << sum << endl;
    }
}
```

---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P9355 「SiR-1」Checkmate](https://www.luogu.com.cn/problem/P9355)

## 解题思路

对于每一对相邻格子，先放置的棋子得分加 $1$，后放置的棋子不加分。

因此得分总和等于相邻格子的对数，具体计算如下：

- 横向：有 $n$ 行，每行包含 $m-1$ 对，共有 $n(m-1)$ 对。
- 竖向：有 $m$ 列，每列包含 $n-1$ 对，共有 $m(n-1)$ 对。

所以相邻格子的总对数为 $n(m-1)+m(n-1)=2nm-n-m$ 对。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	while(T--)
	{
		ll n,m;
		cin>>n>>m;
		cout<<n*m*2-n-m<<'\n';
	}
	return 0;
}
```

---

## 作者：zhuletian (赞：1)

## 题意概括
有一个 $n$ 行 $m$ 列的棋盘。要在这个棋盘上的所有格子依次放置一个棋子。每放置一个棋子，获得的分数为放置的这个棋子上、下、左、右相邻格子中没放置棋子的格子个数。求得分~~的最大值~~。
## 思路
因为无论怎么放置棋子，所得的分数都一样。所以在 $n > 1$ 且 $m > 1$ 的情况下可以按从上到下，从左到右的顺序枚举每个格子的分数拿到40分，时间复杂度为 $O(nm)$。

但按照这个顺序枚举，可以发现每个格子的得分是有规律的，我们就先拿 $n = 5, m = 4$ 的情况举例，每格得分如下：

| 2 | 2 | 2 | 2 | 1 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | 2 | 2 | 2 | 1 |
| 2 | 2 | 2 | 2 | 1 |
| 1 | 1 | 1 | 1 | 0 |

多画几个图，不难发现最终得分为 $2(n - 1)(m - 1) + n + m - 2$。简化后可得：最终得分为 $2nm - n - m$。
## AC代码
```cpp
#include <iostream>
using namespace std;

int main()
{
    int t;
    cin >> t;
    for (int i = 1; i <= t; i++) // 一共t组数据
    {
        long long n, m; // 注意开long long，否则会爆
        cin >> n >> m;
        cout << 2 * n * m - n - m << endl; // 注意最后要换行
    }
    return 0; // 完结撒花
}
```
本蒟蒻的第一篇题解，求管理员通过，还请各位大佬指出错误，一同进步。

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

给定一个 $n \times m$ 的棋盘，依次将其放上棋子，每个棋子的贡献为其上下左右没有棋子的格子个数。求最大贡献。

### 题目分析

我们可以反过来想，对于一个点，我们要使它周围的点的贡献尽可能大，我们可以让它周围的点都放完后它再放，因此，我们可以隔一个棋子放一个（如下图所示），这样我们空过去的棋子所做出的贡献最大。

![](https://s1.ax1x.com/2023/05/25/p9HzY9I.jpg)

然后我们来计算答案

首先我们可以分成两种情况：

1. $n = 1$ 或 $m = 1$，也就是说该棋盘呈条状。

具体的，我们可以分成两种方法，就是从第一个格开始，第奇数 / 偶数个格子放，我们可以发现它们的答案是一样的。我们设 $n = 1$，答案如下（$m = 1$ 同理）：

$$ans = \begin{cases}m - 1 & m \equiv 1 (\bmod 2) \\ \lfloor\dfrac{m}{2}\rfloor \times 2 & m \equiv 0 (\bmod 2)\end{cases}$$

2. 当 $m \neq 1$ 且 $n \neq 1$，这种情况我们可以分为两部分的答案和：中间的地方（四周都是格子）和边上的地方（周围有些是棋盘外）如下图。

![](https://s1.ax1x.com/2023/05/25/p9HzG4A.jpg)

当然，在这种情况中也需要分类讨论。

2.1 对于中间的地方：

$$ans = \begin{cases}\dfrac{(n - 2) \times (m - 2) + 1}{2} \times 4 & (n - 2) \times (m - 2) \equiv 0 (\bmod 2) \\ \dfrac{(n - 2) \times (m - 2) + 1}{2} \times 4 & (n - 2) \times (m - 2) \equiv 1 (\bmod 2)\end{cases}$$

2.2 对于四周的地方（解释如下图）：

$$ans = \begin{cases} 2 \times 2 + ((n + m - 2) - 2) \times 3 & n \times m \equiv 0 (\bmod 2) \\ 4 \times 2 + ((n + m - 2) - 4) \times 3 & n \times m \equiv 1 (\bmod 2) \end{cases}$$

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int T, ans, n, m;
signed main()
{
	cin >> T;
	for(int t = 1;t <= T;t++)
	{
		cin >> n >> m;
		if(n == 1)
		{
			ans = (m % 2 == 0) ? m - 1 : m / 2 * 2;
			cout << ans << endl;
			continue;
		}
		if(m == 1)
		{
			ans = (n % 2 == 0) ? n - 1 : n / 2 * 2;
			cout << ans << endl;
			continue;
		}
		if(n % 2 != 0 && m % 2 != 0)
			ans = max(((n - 2) * (m - 2) + 1) / 2, 0ll) * 4 + 8 + ((n + m - 2) - 4) * 3;
        else
			ans = max(((n - 2) * (m - 2)) / 2, 0ll) * 4 + 4 + ((n + m - 2) - 2) * 3;
		cout << ans << endl;
	}
	return 0; 
}
```

---

## 作者：SXZM_1 (赞：0)

思路：

给定两个相邻的格子 $i$ 和 $j$，我们会发现无论那个先放，都会有 $1$ 的得分值。

所以手动模拟棋盘，我们会发现其实所有策略都是一样的，所以我们找规律就行。

但是这题貌似有点容易被卡，我们用 Python。

```
n=int(input())
for i in range(n):
    [n,m]=list(map(int, input().split()))#输入
    ans=(n-1)+(n*2-1)*(m-1)#模拟
    print(ans)#python自动换行，不太适应
```

---

## 作者：Steve_xh (赞：0)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P9355)

**题目大意：**

有一个 $n$ 行 $m$ 列的棋盘，每次放一个棋子，分数就加上它相邻四周没有放棋子的个数，问怎么在每一步都最优的情况下使分数最大。

# 思路

首先捏一组样例，设 $n=m=3$，我们先来看看我们脑海中第一个想到的最优解：先填中间，然后填四个顶点，最后把剩下的填了，因为这样似乎每一步都走到了最多分数的点，也就是贪心思想，总和为 $4+2+2+2+2+0+0+0+0=12$，我们再来看看直接一个一个从左上到右下填又会是怎样的：$2+2+1+2+2+1+1+1+0=12$。

等等，这咋一样的叻？

我们在填的过程中可以发现：第一个方法是把互不相干的点都填上，可最后其他的点被迫放在四个点之间，没分；第二个方法是只一个一个地填，虽然加的分少，但点多。好像这两个方法刚好对立但又似乎一样。再从式子里面看：第二个方法单独加的只有一口气的点刚好可以组成一个四口气的点，其它两口气的点又是一模一样的。假如我们只考虑两个相邻的点，我们发现无论先填哪个点最后的分数都是一样的，也就是说填的方法和最终的结果是互不影响的！也就是说，只要把所有的点都填一遍便能得出最终答案了。

利用第二种方法，我们知道除了最后一行及最后一列，其它所有的格子加的分都是 $2$，而最后一行除了最后一个及最后一列除了最后一个加的分都是 $1$，最右下角的 $0$ 不用管，得出 $n$ 行 $m$ 列的棋盘的答案为：
$$2(n-1)(m-1)+(n-1)+(m-1)$$

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long//10^8需要相乘记得开long long
using namespace std;
int t,n,m;
signed main(){
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",2*(n-1)*(m-1)+(n-1)+(m-1));//套公式
    }
    return 0;
}
```

---

## 作者：XBaiC (赞：0)

## 思路

我们发现，每相邻的两个棋子中，先放的分数会加 $1$，后放不加分。可以发现同一行横向相邻的有 $n(m-1)$ 对，同一行横向相邻的有 $m(n-1)$ 对，之后可以得到式子：$n(m-1)+m(n-1)$。

## 注意事项

变量开 `long long`。

## CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long T;
	cin >> T;
	while( T-- )
	{
	    long long n , m;
		cin >> n >> m;
		cout << n * ( m - 1 ) + m * ( n - 1 ) << endl;
	}
	return 0;
}
```


---

## 作者：liuchang09 (赞：0)

[题目](https://www.luogu.com.cn/problem/P9355)
### 解法：
每相邻的两个棋子中，会先放一个，再放另一个。先放的那个会加一分，而后放的则不加分。

因此答案就是相邻的棋子的对数。在同一行横向相邻的有 $n(m-1)$ 对，
在同一列纵向相邻的有 $m(n-1)$ 对。所以答案为 $n(m-1)+m(n-1)$，即 $2nm-n-m$。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
long long n,m;
int main() {
    scanf("%d",&t);
    while(t--){
        scanf("%lld%lld",&n,&m);
		printf("%lld\n",2*n*m-n-m);
    }
    return 0;
}   
```


---

## 作者：zsh_haha (赞：0)

### 解题思路

又是一道思维性较强的题目。

本题的关键点就是求出怎样放才能达到最好的效果。

现在让我来告诉你，一排一排的或一列一列的按顺序放是最优解。

我们先模拟一下 $n=4,m=5$ 的解题过程：

第一种，一排一排的放，每次放置的得分如下：

| $0$ | $1$ | $1$ | $1$ | $1$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $2$ | $2$ | $2$ | $2$ |
| $1$ | $2$ | $2$ | $2$ | $2$ |
| $1$ | $2$ | $2$ | $2$ | $3$ |

通过分析表格，我们得知：一排一排的放最大的得分为：$(n-1)\times(m-1)\times2+(n-1+m-1)+1=2mn-n-m+1$。

第二种，一列一列的放，每次放置的得分如下：

| $0$ | $1$ | $1$ | $1$ | $1$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $2$ | $2$ | $2$ | $2$ |
| $1$ | $2$ | $2$ | $2$ | $2$ |
| $1$ | $2$ | $2$ | $2$ | $3$ |

通过分析表格，我们得知：一列一列的放最大的得分为：$(n-1)\times(m-1)\times2+(n-1+m-1)+1=2mn-n-m+1$。

然后，一细看，耶？这不是一样的吗？所以最终只要输出 $2mn-n-m+1$ 即可。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		long long n,m;
		cin>>n>>m;
		long long ans=2*n*m-n-m;
		cout<<ans<<endl;
	}
    return 0;
}

```

---


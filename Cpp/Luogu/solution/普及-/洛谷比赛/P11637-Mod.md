# Mod

## 题目描述

给定三个数 $a,b,p$，你要对 $a$ 做若干次操作。

对于一次操作，你可以令 $a\leftarrow (a+1)\bmod p$，并且使 $b\leftarrow b-1$，注意操作后你必须保证 $b$ 为自然数。

问做完若干次操作后 $a$ 最小是多少，以及在满足 $a$ 最小的前提下，$b$ 最小是多少？ 

注：$a\leftarrow b$ 的意思是把 $a$ 赋值为 $b$。

## 说明/提示

| 捆绑 |$b \leq$ | $p \leq$ |  分数|
| :----------: | :------: | :------: | :-----: |
| Subtask #1 | $10^5$ | $10^{5}$ | $20\text{pts}$ |
| Subtask #2 |  $10^9$ | $10^9$ | $40\text{pts}$ |
| Subtask #3 | $10^{18}$ | $10^{18}$ | $40\text{pts}$ |

对于所有数据，$2\le p\le 10^{18}$，$0\le a< p$，$1\le b\le 10^{18}$。

## 样例 #1

### 输入

```
1 3 2```

### 输出

```
0 0```

## 样例 #2

### 输入

```
1 1 4```

### 输出

```
1 1```

# 题解

## 作者：M1__ (赞：4)

# 题解：P11637 Mod
[题目传送门](https://www.luogu.com.cn/problem/P11637?contestId=224170)                    
## 思路
一种比较简单的方法。                 

根据题意，我们可以发现在若干次操作后 $a$ 能变成 $0$ 的情况下，操作次数为 $p-a$。因为 $b$ 的操作次数与 $a$ 相同，所以 $b$ 的值为 $b-(p-a)$。因为题面中要求 $b$ 为一个自然数，所以自然就分成了 $b-(p-a) \ge 0$ 和 $b-(p-a) < 0$ 两种情况。在第二种情况下，如果进行操作，就与题面中的 $b \ge 0$ 相悖，所以无需进行任何操作，$a$ 和 $b$ 本身即为他们的最小值。对应地，在第一种情况下，$a$ 的最小值即为 $0$。当经过 $p-a$ 次操作下后，再每进行 $p$ 次操作后 $a$ 会再次等于 $0$。所以可以求出此时 $b$ 的最小值。

综上所述：
- 当 $b-(p-a) \ge 0$ 时，$a_{min}=0$，$b_{min}=b-(p-a)\bmod p$。
- 当 $b-(p-a) < 0$ 时，$a_{min}=a$，$b_{min}=b$。

对于一种情况 $b-(p-a) \ge 0$ 和第二种情况 $b-(p-a) < 0$ 的样例模拟：

  ![](https://cdn.luogu.com.cn/upload/image_hosting/q0ipfrzk.png)

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a,b,p;
int main(){
	cin>>a>>b>>p;
	if((b-(p-a))>0||(b-(p-a))==0) cout<<"0"<<" "<<(b-(p-a))%p;
	else cout<<a<<" "<<b;
	return 0;
}

```

---

## 作者：_O_v_O_ (赞：4)

出题人题解。

我们注意到这个 $a$ 操作一次后：

- $a=p-1$，那么 $a$ 就会变成 $0$。
- 否则，$a$ 变为 $a+1$。

那么 $a$ 通过 $p-a$ 次操作就是可以变为 $0$ 的。

所以若 $b\ge p-a$，那么第一问的最小值就是 $0$，否则只能什么都不做，即 $a$，此时第二小问为 $b$。

那么当 $b\ge p-a$ 的第二小问呢？

我们发现，$a$ 在 $p-a$ 次操作后变为了 $0$，那么此时 $b$ 为 $b-(p-a)$。

然后我们又发现在接下来的操作中每 $p$ 次 $a$ 会变为 $0$，那么答案就为 $(b-(p-a))\bmod p$，那么就做完了。

---

## 作者：syx_2014 (赞：3)

难度应该是低/中位橙吧。

> 让 $a$ 最小的前提下 $b$ 最小。

既然要 $a$ 最小，那不妨让 $a$ 最后的值设为 $0$，而对于 $b$ 来说，操作次数越多越好（但不能超过 $b$ 次），所以我们就是要求：

> 定义一次操作为 $x\leftarrow (x+1)\bmod p$，有两个数个数 $a$ 和 $p$，要进行最多多少次多少次操作使得 $a$ 为 $0$ 且操作数不超过 $b$？

显而易见，最多操作次数是：

$$((p-a)\bmod p)+\Big\lfloor\dfrac{b-((p-a)\bmod p)}{p} \Big\rfloor\times p$$

第一项输出 $0$，第二项输出 $b$ 减去上面的公式就行。

但是，第二个样例的第一个数不是 $0$ 啊！

我们观察一下发现，$a$ 还没有变成 $0$，$b$ 就已经变成负数了！

对于这种情况，$a$ 永远也不可能变小，所以我们不如不加。

对于第二种情况，输出 $a$ 和 $b$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,p; 
int main(){
	cin>>a>>b>>p;
	long long l=(p-a)%p;
	if(l>b){
		cout<<a<<' '<<b<<'\n';
		return 0;
	}
	long long q=(b-l)/p*p;
	cout<<0<<' '<<b-q-l<<'\n';
	return 0;
}
```

---

## 作者：Wish_kazdel (赞：2)

## 思路
想通了以后代码很好写。因为题目要求 $b$ 为自然数，那么操作的次数就不能大于 $b$ 次，即需要保证 $b$ 始终大于或等于 $0$。

那么题目的意思就是在操作次数小于 $b$ 的情况下，使得 $a$ 尽可能小。

如果我们仅仅根据此条件进行循环遍历的话，看了一眼数据范围，显然会发现会超时。

那么我们就来找规律，显然会发现 $a$ 在一般情况下的最小值为 $0$。而 $b$ 的值就显而易见是 $b-p+a$ 的值再取模 $p$。

但是观察样例二，我们注意到 $a$ 最小值不是 $0$。因为此时 $a$ 还没有到达 $0$，$b$ 就已经是负数了。所以我们直接输出 $a$ 与 $b$ 本身即可。

最后提一嘴，记得看数据范围。

---

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,b,p;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>a>>b>>p;
	if(b<p-a)cout<<a<<" "<<b;
	else cout<<0<<" "<<((b-p+a)%p) ;
	return 0;
}
```

---

## 作者：11514zbs (赞：2)

### 题意概述：

最多进行 $b$ 次操作，使得 $a \bmod p$ 的值最小，并在这个前提下找到最大操作数。具体的操作方式是将 $a \leftarrow {(a + 1) \bmod p}$ ，这里的 $x \leftarrow y$ 代表将 $x$ 赋值为 $y$ 。

### 思路：

这里将最小的 $a$ 记作 $a'$ 、最小的 $b$ 记作 $b'$ 。

首先，很好观察到，$a'$ 应该能够满足 $a' \equiv p \pmod{p}$ ，这时 $a' = 0$ 。

但是进行几次操作才能够满足这个前提呢？我们可以观察到 对 $a$ 进行 $p - a$ 次操作后， $a$ 的值就会变成 $0$ ，接下来每进行 $p$ 次操作后， $a$ 的值都不会发生改变。所以我们就满足了“ $a$ 最小”的前提。

如 $a = 2, p = 5, b = 14$ 时，首先当进行了 $p - a$ 次操作后（也就是进行了 $5 - 2 = 3$ 次操作后）， $a$ 的值变成了 $0$ ，然后再进行 $p$ 次操作后（也就是进行了 $5$ 次操作后）， $a$ 的值仍然是零，因为 $0 + p \equiv 0 \pmod{p}$ ，即 $5 \equiv 0 \pmod{5}$ 。以此类推，当操作次数为 $2, 7, 12$ 时满足“ $a$ 最小”的前提，所以 $a' = 0, b' = 12$ 。

再仔细思考，所能进行的最大操作次数就是先将 $a$ 变成 $0$ ，再进行以 $p$ 次为一个周期的操作，即 $b - b' = \lfloor {\frac {b - (p - a)}{p}} \rfloor$ ， $b' = b - \lfloor {\frac {b - (p - a)}{p}} \rfloor$ ，最后得到 $b' = [b - (p - a)] \bmod p$ 。

自信交一发：

```cpp
#include <cstdio>
int main()
{
    long long a, b, p;
    scanf("%lld %lld %lld", &a, &b, &p);
    printf("0 %lld", (b - (p - a)) % p);
    return 0;
}

```

提交，漂亮！没一个 Subtask 是全对的，喜提 $\color{E74C3C}{0\ \text{Unaccepted}}$ 。

那么问题出在哪儿了呢？自测一下样例 $2$ ，输出竟然是负数！这是为什么，其实很简单，因为样例 $2$ 的数据中 $b < p - a$ ！

所以在这种情况下， $a$ 只会越来越大，所以不进行操作的情况下 $a$ 的值才最小，所以当 $b < (p - a)$ 时， $a' = a$ 。既然不进行操作， $b$ 的值自然也没有发生改变，即 $b' = b$ 。

代码如下：

```cpp
#include <cstdio>
int main()
{
    long long a, b, p;
    scanf("%lld %lld %lld", &a, &b, &p);
    if (b < p - a)
    {
        printf("%lld %lld", a, b);
    }
    else
    {
        printf("0 %lld", (b - (p - a)) % p);
    }
    return 0;
}

```

> 我讲的这么详细你们应该听得懂吧。

 ~~本蒟蒻的第五篇题解awa~~

---

## 作者：C_0_a4S (赞：1)

### 题意
保证 $b \ge 0$ 的情况下进行若干次操作，每次操作使 $a$ 增加 $1$ 并对 $p$ 取模，同时使 $b$ 减小 $1$。

不难发现操作数必须不超过 $b$。
### 解法
#### 第一问（50pts）
要使 $a$ 最小，最好就是使得 $a\mid p$，需要进行至少 $p-a$ 次操作，此时 $a=0$。

如果 $b<p-a$，那么无法在进行若干次操作后使得 $a\mid p(a\ne0)$，这时候只要输出给定的 $a$ 即可。
#### 第二问（50pts）
如果 $b<p-a$，那么使 $a$ 最小的方法是不进行任何操作，此时直接输出给定的 $b$ 即可。

否则，一定要保证操作次数尽可能多，且保证 $a\mid p$。我们先进行 $p-a$ 次操作使得 $a\mid p$，接下来进行 $kp(k\in N)$ 次操作可以保证 $a\mid p$。我们要让 $k$ 尽可能大使得 $b$ 尽可能小，所以我们用 $b-(p-a)$ 对 $p$ 取模即可得到答案。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a,b,p;

signed main(){
	cin>>a>>b>>p;
	if((p-a<=b))	cout<<0<<' '<<(b-(p-a))%p<<'\n';
	else{
		cout<<a<<' '<<b<<'\n';
	}	
	return 0;
} 
```

---

## 作者：Vct14 (赞：1)

前置知识：$x\bmod y=x-(x-x\bmod y)=x-\left\lfloor\frac{x}{y}\right\rfloor\times y$。

我们把输入时的 $a,b$ 称为 $a_0,b_0$。

注意到 $a$ 只有在 $a=p$ 时才会因为取模而变成 $0$，否则会一直增大。那么如果进行了 $b$ 次操作后仍有 $a<p$，即 $a_0+b_0<p$，则最小的 $a$ 就是 $a_0$，此时最小的 $b$ 就是 $b_0$。

当 $a_0+b_0\geqslant p$ 时，一定有某次操作后 $a=0$。这一定是最小的。为了使 $b$ 最小，我们就需要尽量多地操作。我们知道，操作 $p-a_0,2p-a_0,3p-a_0,\dots,kp-a_0$ 次都可以使 $a$ 变为 $0$。那么问题就转化为求最大的 $k$ 使得 $kp-a_0\leqslant b_0$。移项可得 $k\leqslant \frac{a_0+b_0}{p}$，那么 $k$ 的最大值为 $\left\lfloor\frac{a_0+b_0}{p}\right\rfloor$。$b$ 最小值为 $b_0-(kp-a_0)=(a_0+b_0)-\left\lfloor\frac{a_0+b_0}{p}\right\rfloor\times p=(a_0+b_0)\bmod p$。

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long a,b,p;cin>>a>>b>>p;
	cout<<((a+b>=p)?0:a)<<" "<<((a+b>=p)?(a+b)%p:b);
	return 0;
}
```

---


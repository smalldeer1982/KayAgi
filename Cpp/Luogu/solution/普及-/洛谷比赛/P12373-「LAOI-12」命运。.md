# 「LAOI-12」命运。

## 题目背景

![](bilibili:BV1W4411z7JE)

## 题目描述

给定正整数 $n$，请你构造一个长度为 $n$ 的**排列**使得其所有区间极差之和为 $\sum\limits_{i=1}^{n-1}i^2$。

一个区间的极差定义为这个区间的最大值减最小值。

## 说明/提示

### 样例解释

对于样例一中构造的序列，共有 $6$ 个区间：

1. $[1,1]$，极差为 $0$。
2. $[2,2]$，极差为 $0$。
3. $[3,3]$，极差为 $0$。
4. $[1,2]$，极差为 $2$。
5. $[2,3]$，极差为 $1$。
6. $[1,3]$，极差为 $2$。

由于 $2+1+2=5=\sum\limits_{i=1}^{3-1}i^2$，故构造合法。
### 数据范围 
**本题采用捆绑测试。**

|子任务编号|$\sum n$|分值|
|:-:|:-:|:-:|
|$1$|$\le10$|$5$|
|$2$|$\le10^3$|$35$|
|$3$|$\le10^6$|$60$|

对于 $100\%$ 的数据，满足 $1\le T\le 10^3$，$2\le n,\sum n \le10^6$。

## 样例 #1

### 输入

```
1
3```

### 输出

```
3 1 2```

# 题解

## 作者：Clare613 (赞：3)

## 思路
第一步，分解 $\sum\limits_{i=1}^{n-1}i^2$，可以得到 $\sum\limits_{i=1}^{n-1}i^2 = 1 + 2 + 2 + 3 + 3 + 3 + ...... + (n-1) + (n-1) + (n-1)$。\
第二步，构造数组，我们可以构造以下数组：
> $1 ,n ,2 ,n - 2 ,3......$

为什么呢？我们可以发现，相差为 $1$ 的区间只有末尾那一个，相差为 $2$ 的区间也只可以从末尾找到两个，因为相差为 $2$ 的两个数后只剩下一个数了，以此类推。这样我们就可以得到代码了。
## code:

```
#include<iostream>
#include<queue>
#define MOD 1000000007
using namespace std;

int main(){
    cin.tie(0)->sync_with_stdio(0);
    int T;
    cin>>T;
    while(T--){
		int n;
		cin>>n;
		if(n%2==1){
			for(int i=1;i<=n/2;i++){
				cout<<i<<" "<<n-i+1<<" ";
			}
			cout<<n/2+1<<"\n";
		}
		else{
			for(int i=1;i<=n/2;i++){
				cout<<i<<" "<<n-i+1<<" ";
			}
			cout<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：JIN_LONG (赞：2)

## 思路：
看到这题我们首先把式子拆了，于是原式变为 $1+2+2+3+3+3+......+(n−1)+(n−1)+(n−1)$。

因为要让 $i$ 个区间极差为 $i$，可以发现这种区间符合题意 $1,n,2,n−1,3,n−2…$，于是这样输出即可。

```
for(int i=1;i<=n/2;i++){
    cout<<i<<" "<<n-i+1<<" ";
}
```
不过要注意，因为如果 $n$ 为基数时，会少输出一个数字，所以要特判一下。
## 代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
		int n;
		cin>>n;
		for(int i=1;i<=n/2;i++){
			cout<<i<<" "<<n-i+1<<" ";
		}
		if(n%2==1){
			cout<<n/2+1<<endl;
		}
	}
	return 0;
}
```

---

## 作者：swate114514 (赞：2)

## 题意
给定正整数 $n$，请你构造一个长度为 $n$ 的**排列**使得其所有区间极差之和为 $\sum\limits_{i=1}^{n-1}i^2$。

## 思路
这个蒟蒻不能一眼发现规律，于是在考试的时候举了几个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/dgrjet70.png)

## 证明
我们来证明一下我们的结论：

对于构造的排列 $a = n, 1, n-1, 2, n-3, 3, \dots$，其所有连续子数组的极差之和等于 $1^2 + 2^2 + \dots + (n-1)^2$。

对于任意子数组，其极差为：

$$\text{极差} = \max(\text{子数组}) - \min(\text{子数组})$$

所有子数组的极差之和可拆分为：

$$\sum_{\text{子数组}} (\max - \min) = \sum_{\text{子数组}} \max - \sum_{\text{子数组}} \min$$

排列 $a$ 的构造规则为交替放置最大值和最小值：
- 第 $2k$ 个位置为 $n - k + 1$（递减的大数）。
- 第 $2k+1$ 个位置为 $k + 1$（递增的小数）。

例如，$n=4$ 时，排列为 $4,1,3,2$。

每个大数 $n, n-1, \dots, 2$ 作为最大值时，其影响范围覆盖左侧和右侧的连续小数。对于大数 $n-k+1$（位于位置 $2k$），其左侧最近的更小值为 $k$，右侧最近的更小值为 $k+1$。

贡献子数组数量为：
$$(2k - (2k-1)) \times ((2k+1) - 2k) = 1 \times 1 = 1$$

即每个大数仅在其所在位置贡献一次最大值。

每个小数 $1, 2, \dots, n-1$ 作为最小值时，其影响范围覆盖左侧和右侧的连续大数。对于小数 $k+1$（位于位置 $2k+1$），其左侧最近的更大值为 $n-k$，右侧最近的更大值为 $n-k-1$。  
贡献子数组数量为：
$$((2k+1) - 2k) \times (2k+2 - (2k+1)) = 1 \times 1 = 1$$
即每个小数仅在其所在位置贡献一次最小值。

所有大数 $n, n-1, \dots, 2$ 各贡献一次，总和为：
$$\sum_{k=1}^{n-1} (n - k + 1) = \sum_{i=2}^n i = \frac{n(n+1)}{2} - 1$$

所有小数 $1, 2, \dots, n-1$ 各贡献一次，总和为：
$$\sum_{k=1}^{n-1} (k+1) = \sum_{i=2}^n i = \frac{n(n+1)}{2} - 1$$

极差总和 $ans$ 为：
$$ans = \left( \frac{n(n+1)}{2} - 1 \right) - \left( \frac{n(n+1)}{2} - 1 \right) = 0$$
  显然存在矛盾，需修正贡献范围分析。

实际贡献范围应覆盖所有包含该元素的子数组：
- 大数 $n-k+1$ 的贡献范围为：
$$(2k) \times (n - 2k + 1)$$
- 小数 $k+1$ 的贡献范围为：
$$(2k+1) \times (n - (2k+1) + 1)$$

总极差之和最终化简为：
$$\sum_{i=1}^{n-1} i^2 = \frac{(n-1)n(2n-1)}{6}$$

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
	int t;
	cin >> t;
	
	while (t--) {
		int n;
		cin >> n;

        if (n == 1) {
            cout << "1\n";
            continue;
        }

        int m = n, k = 1;
		
		for (int i = 1; i <= n; i++) {
			if (i % 2 == 1) cout << m << ' ', m--;
            else cout << k << ' ', k++;
		}
				
		cout << '\n';
	}
	
	return 0;
}
```

---

## 作者：Nahida_Official (赞：1)

## [P12373 「LAOI-12」命运。](https://www.luogu.com.cn/problem/P12373)

构造题，同时也是很好的找规律题。

观察题目中的公式：
$$ans=\sum_{i=1}^{n-1} i^2$$
我们令构造出的数组为 $a$，区间左端点为 $l$，右端点为 $r$，那么区间极差的公式为：
$$\max_{i=l}^r a_i-\min_{i=l}^r a_i$$

那么我们怎么得到所有区间极差为 $\sum_{i=1}^{n-1} i^2$ 呢？

假设我们已经求出了构造数组，令左指针 $l=1$，右指针 $r=2$，每次将 $r$ 由 $2$ 遍历到 $n$，计算所有极差，再将 $l$ 右移一位再次计算，要求总和为 $\sum_{i=1}^{n-1} i^2$。

不难发现，如果我们第一次遍历区间的所有极差都为 $n-1$，第二次遍历区间所有极差为 $n-2$，第三次为 $n-3$......那么我们遍历完所有区间之后得到的期望答案为：

$$(n-1)^2+(n-2)^2+(n-3)^2+…+1^2=\sum_{i=1}^{n-1} i^2$$

做完了。

如何做到每一次遍历的极差保持为上述状态？

把最大的元素 $n$ 放在第一个，把 $1$ 放在第二个，从 $1$ 开始的这次遍历要求极差为 $n-2$，那么就把 $n-1$ 放在第三个位置上，第四个位置放 $2$，也就是构造的数组为：

$$n,1,n-1,2,n-2,3…$$

依照这种方式构造即可。

## P12373 Code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define Sangonomiya signed
#define Kokomi main()
#define Love return
#define Nahida 0
#define Forever ;
#define IOS cin.tie(nullptr)->sync_with_stdio(false)
#define cin std::cin
#define cout std::cout
const int N=1e6;
int T,n,l,r;
int a[N+5];
Sangonomiya Kokomi{
	IOS;
    cin>>T;
    while(T--){
        cin>>n;
        l=n;
        r=1;
        for(int i=1;i<=n;i++){
            if(i%2==1){
                a[i]=l;
                l--;
            }else{
                a[i]=r;
                r++;
            }
        }
        for(int i=1;i<=n;i++) cout<<a[i]<<' ';
        cout<<'\n';
    }
	Love Nahida Forever;
}
```

---

## 作者：modfish_ (赞：1)

## 思路
注意到只有 $\frac{n(n-1)}{2}$ 个区间的极差非零。

又可以发现：$1+2+\dots+(n-1)=\frac{n(n-1)}{2}$。

只要让 $i$ 个区间极差为 $i$ 即可。其中 $1\le i\le n-1$。

可以发现如下区间合法：

```
1 n 2 n-1 3 n-2 ...
```

即 $a_i=\begin{cases}\displaystyle\frac{i+1}{2},& 2\nmid i\\n-\displaystyle\frac{i}{2}+1,& 2\mid i\end{cases}$。直接输出即可。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    int T;
    scanf("%d", &T);
    while(T --){
        int n;
        scanf("%d", &n);
        for(int i = 1; i <= n / 2; i ++) printf("%d %d ", i, n - i + 1);
        if(n & 1) printf("%d\n", n / 2 + 1);
    }
    return 0;
}
```

---

## 作者：Anemones (赞：1)

由于 $\sum\limits_{i=1}^{n-1}i^2$ 可以拆成 $1+2+2+3+3+3+\dots+(n-1)+(n-1)$，其中 $1$ 的个数对应了长度为 $n$ 的区间个数，而 $2$ 的个数对应了长度为 $n-1$ 的区间个数。因此我们便可以构造出如下排列：

> $1,n,2,n-1,3,n-2\dots$

这显然符合要求。

```cpp
for(int i=1,j=n;i<=j;i++,j--){
    if(i==j) write(i),sp;
    else{
        write(i),sp,write(j),sp;
    }
}
```

---

## 作者：可爱大黄兔 (赞：0)

## 思路
先拆式子：
$$\begin{aligned} \sum\limits_{i=1}^{n-1}i^2 = 1^2+2^2+\cdots+n^2 \\ = n^2+\cdots+2^2+1^1 \end{aligned}$$
再依据题意构造，使第 $i$ 个数与第 $i+1$ 个数的方差为 $(n-i)^2$ 即可。

因此我们可以构造这样一个序列：

- 当 $n$ 为偶数：
$$n,1,n-1,2,n-2,3,\cdots,\frac{n}2+1,\frac{n}2-1$$
- 当 $n$ 为奇数：
$$n,1,n-1,2,n-2,3,\cdots,\frac{n}2-1,\frac{n}2+1$$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
vector<int> ans;
int n;

int main() {
	scanf("%d", &T);
	while (T--) {
		ans.clear();
		cin >> n;
		ans.push_back(n);
		int l = 1, r = n - 1;
		bool flag = true;
		while (l <= r) {
			if (flag) {
				ans.push_back(l);
				l++;
			} else {
				ans.push_back(r);
				r--;
			}
			flag = !flag;
		}
		for (int x : ans) {
			printf("%d ", x);
		}
		puts("");
	}

	return 0;
}
```

---


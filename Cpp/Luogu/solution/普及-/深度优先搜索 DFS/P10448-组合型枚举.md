# 组合型枚举

## 题目描述

从 $1 \sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。

## 说明/提示

对于所有测试数据满足 $0 \le m \le n$ ,  $ n+(n-m) \le 25 $。

## 样例 #1

### 输入

```
5 3```

### 输出

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 ```

# 题解

## 作者：gavinliu266 (赞：11)

fix：只有 dfs，没有回溯。

update：增加亿点内容。
# 思路 1
可以想到 dfs，搜到一个完整的序列就输出。

这里只要每个循环都从上一次的地方继续，就可以保证序列为升序；每个循环从小到大枚举，就保证了序列间是升序排列的。

时间复杂度：应该是 $O((n-m)^m)$。

这个时间复杂度也不是很确定，所以欢迎来喷。

## 代码实现
```cpp
#include <cstdio>
using namespace std;
int n, r;
int f[25];
void dfs(int h, int l) {
	if(h == r + 1) {  // 搜到了，输出
		for(int i = 1; i <= r; ++i)
			printf("%d ", f[i]);
		putchar('\n');
		return;
	}
	for(int i = l; i <= n - r + h; ++i) {
		f[h] = i;
		dfs(h + 1, i + 1);  // 保证升序
	}
}
int main() {
	scanf("%d%d", &n, &r);
	dfs(1, 1);
}
```

# 思路 2
hgckythgcfhk 的题解给了我另一种思路。本题可以转化为求有 $m$ 个 $0$，$n-m$ 个 $1$ 的序列的全排列。

如果当前位是 $1$ 就输出，否则不输出。

实现只需要用 `prev_permutation` 即可。

时间复杂度：$O(nC^m_n)$。
## 代码实现
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, r;
int f[25];
int main() {
	scanf("%d%d", &n, &r);
	for(int i = 1; i <= r; ++i)
		f[i] = 1;
	do {
		for(int i = 1; i <= n; ++i)
			if(f[i]) printf("%d ", i);
		putchar('\n');
	} while(prev_permutation(f + 1, f + n + 1));  // 注意是 prev，因为初始排列的编号是最大的。
}
```

---

## 作者：hgckythgcfhk (赞：7)

## 算法 $1$

观察到 $2^{25}$ 在 $10^7$ 的数量级，所以 $O(2^n)$ 的时间复杂度能过，可以暴力枚举二进制下 $1$ 的个数为 $m$ 的数，这个正确性很好理解，定义 $1$ 表示选 $0$ 表示不选，所以 $m$ 个 $1$ 正好表示选 $m$ 个。

核心程序如下：
```cpp
for(int i=(1<<n);i;--i)if(__builtin_popcount(i)==m){
	for(int j=n-1,k=1;~j;--j,++k)if(i&(1<<j))cout<<k<<' ';cout<<'\n';
}
```

注意从大到小枚举，这样可以保证字典序。

## 算法 $2$

有一个专门用于这个问题的算法，这个算法的时间复杂度更加优秀，可以看到，上面的算法有过多无意义的枚举，比如 $m=1$ 时，如果 $n$ 很大那大部分枚举都是浪费的。

具体过程如下：

1. 先开一个 $1$ 到 $m$ 都是 $1$ 的数组。

2. 把最低的可以向高位移动一位且没有障碍的非最高位向高位移动一位，并把比它低的位置于最低位。

3. 如果不存在这样的位，即只有最高位可以移动，则最高位向高位移动一位，其他位置于最低位。

具体演示一下这个过程：

```cpp
00111
01011
01101
01110
10011
10101
10110
11001
11010
11100
```

着相当于从小到大枚举二进制，但比起上面的算法 $1$，这个算法可以保证枚举到的都是有用的，时间复杂度从 $O(2^n+n(^n_m))$ 优化到了 $O(n(^n_m))$。

对于本题，要求按字典序，两个好办法，一种是可以枚举二进制下 $1$ 的个数为 $n-m$ 的数，然后取反输出，这种比较好实现，另一种是将这个过程倒过来实现一遍，但这个相对难写，这里我放出实现这个算法的模板，稍微修改就可以切掉本题。

```cpp
bitset<6>a;
void solve(int n,int m,int k){//枚举前 k 个 popcount=m 的数
    for(int i=1;i<=m;++i)a[i]=1;cout<<a<<'\n';
    while(--k){int cnt=0;
        for(int i=1;i<=n;++i)if(a[i])if(a[i+1])++cnt;
        else{a[i+1]=1;for(int j=1;j<=cnt;++j)a[j]=1;
        for(int j=cnt+1;j<=i;++j)a[j]=0;break;}
        cout<<a<<'\n';
    }
}
```

注意：这是 ```solve(5,3,10)``` 的结果。

```cpp
001110
010110
011010
011100
100110
101010
101100
110010
110100
111000
```

由于 ```bitset``` 的下标从 $0$ 开始，所以后面会多个 $0$，忽略掉就可以。

---

## 作者：__qkj__ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10448)
## 解题思路
直接搜索。

- 当当前的 $t=m+1$ 时，输出当前方案；
- 否则，从上一个方案加一开始到 $n$，选择当前的 $i$ 存入数组里，并搜索下一层。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[30];
void dfs(int t,int l)
{
	if(t==m+1)
	{
		for(int i=1;i<=m;i++)
			cout<<a[i]<<' ';
		cout<<'\n';
	}
	for(int i=l+1;i<=n;i++)
	{
		a[t]=i;
		dfs(t+1,i);
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	dfs(1,0);
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：3)

### 很裸的深搜练习题！
先看一眼数据范围：$n + (n - m) \le 25$。  
看到数据范围这么小，直接**深搜，启动!**   
注意不用管花里胡哨的 $n + (n - m)$，只需要知道一定 $n \le 25$ 就好啦（占位数组就开这么大，保准没错）。  
这里我还用了 $beg$ 作为上一个搜到的数字，可以适当的**剪枝 & 去重**，剩下就是正常搜即可，见代码：
```cpp
#include <iostream>
using namespace std;
int n, m, a[26];
void print()
{
    for (int i = 1; i <= n; i++)
        if (a[i])
            cout << i << ' ';
    puts("");
}
void dfs(int x, int beg)
{
    if (x == m)
        print();
    else 
        for (int i = beg; i <= n; i++)
        {
            if (!(a[i]))
            {
                a[i] = 1;
                dfs(x + 1, i);
                a[i] = 0;
            }
        }
}
int main()
{
    cin >> n >> m;
    dfs(0, 1);
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

双倍经验：[P1157](https://www.luogu.com.cn/problem/P1157)

同组合的输出，我们只需用 dfs 选择 $m$ 个数并输出即可，时间复杂度 $O(C_{n}^{m})$。

代码如下：
```cpp
#include <iostream>
#include <queue>
#include <string>
using namespace std;
int a[45];
void dfs(int n, int m, int step, int lst) {
	if (step > m) {
		for (int i = 1; i <= m; i++) {
			cout << a[i] << " ";
		}
		cout << endl;
		return;
	}
	for (int i = lst + 1; i <= n; i++) {
		a[step] = i;
		dfs(n, m, step + 1, i);
	}
}
int main() {
	int n, m;
	cin >> n >> m;
	dfs(n, m, 1, 0);
}
```

---

## 作者：UnfortunatelyDead (赞：2)

简单爆搜。

题目要求给出的每个方案从小到大排序，那么可以从小的开始枚举方案，而要求字典序最小也可从这样的方式解决掉。

我们定义搜索函数 $\text{dfs}(u,s)$ 表示搜到第 $u$ 个数，上一个数取的是 $s$，不难发现 $u \in [1,m]$，$s \in [1,n]$，超过这个范围就剪枝剪掉，$u=m+1$ 表示搜完了这个时候要输出。

由于是从小到大枚举的，那么我们这个时候枚举的数 $i$ 一定得是比 $s$ 大的吧，所以 $i \in [s+1,n]$，可以这么枚举。

其实这样是一个强有力的剪枝，剪完就过了。

```cpp 
int n, m, a[30];
void out() {
	for (int i = 1; i <= m; ++i) write(a[i], " \n"[i == m]);
}
void dfs(int u, int s) {
	if (u == m+1) return out(), void();
	if (s == n) return ;
	for (int i = s+1; i <= n; ++i) {
		a[u] = i;
		dfs(u+1, i);
	}
}
signed main() {
	read(n, m); dfs(1, 0);
	return 0;
}
```

---

## 作者：xyx404 (赞：2)

## 思路：
使用 dfs 算法，创建一个数组存当前已经找到的数字。

深度优先搜索代码实现：传入的量为现在找的是第几个数，第一次传入的是一，表示现在找的是第一个数，当传入的数减一等于 $m$ 时输出。

输出函数实现：循环定义的 $i$ 表示当前已经找到的数字的数组的下标，如果你下标是从零开始存的就从零历遍到 $m-1$，如果是从一开始存的就从 $1$ 历遍到 $m$，注意不要忘了最后换行。

因为题目中要求字典序较小的排在前面，所以我们就不定义标记数组了，下一次搜索就直接从上一个数加一开始。

## 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
ull n,m;
ull sc[30];// 存现在找到的数字
void print(){// 输出
	for(int i=1;i<=m;i++)cout<<sc[i]<<" ";
	cout<<"\n";
}
void dfs(int x){// 搜索
	if(x-1==m){
		print();return ;
	}
	for(int i=sc[x-1]+1;i<=n;i++){
		sc[x]=i;
		dfs(x+1);
	}
}
int main(){
	cin>>n>>m;// 输入
	dfs(1);
	return 0;
}

```

---

## 作者：we_are_the_chuibing (赞：1)

dfs 搜过去就行，对于每一项判断选不选，选的总数达到 $m$ 个时直接输出。时间复杂度 $O(n2^n)$，但是由于剪枝很多，所以跑得飞快。

```cpp
#include<iostream>
using namespace std;
bool bo[26];
int n,m,k;
void print(){
    for(int i=1;i<=n;i++){
        if(bo[i])cout<<i<<" ";
    }
    cout<<endl;
}
void dfs(int now){
    if(k==m){
        print();
        return;
    }
    if(now==(n+1))return;
    k++,bo[now]=1;
    dfs(now+1);
    k--,bo[now]=0;
    dfs(now+1);
}
int main(){
    cin>>n>>m;
    dfs(1);
    return 0;
}
```

---

## 作者：_ayaka_ (赞：0)

### 思路
全排列板子，写一个深搜进行枚举，并且保存前一个数保证升序排列就可以了。

并不用保存一个数是否访问过，因为枚举是从前一个数 $+1$ 开始，所以是绝对不会重复的。

也不用考虑提前到达上限导致无法形成序列的情况，因为这种情况会无法继续往下枚举的。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, b[2005];
void queen(int k, int c) {
	if (k > n) {
		for (int i = 1; i <= n; i++) {
			printf("%d ", b[i]);
		}
		printf("\n");
		return;
	}
	for (int i = c + 1; i <= m; i++) {
		b[k] = i;
		queen(k + 1, i);
	}
}
int main() {
	cin >> m >> n;
	queen(1, 0);
	return 0;
}
```

---

## 作者：_Jocularly_ (赞：0)

深度优先搜索。在函数中定义三个参数，用 $now$ 表示现在选了多少个数，用 $tot$ 表示总共需要多少个数，用 $last$ 表示上次选的数，防止选择重复的数。如果现在的数足够了，直接输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m; 
int a[105];
void dfs(int now,int tot,int last){
	if(now == tot){
		for(int i=0;i<tot;i++){
			cout << a[i] << " "; 
		}
		cout << endl;
	}
	for(int i=last+1;i<=n;i++){
		a[now] = i;
		dfs(now+1,tot,i);
	}
}
int main(){
	cin >> n >> m;
	dfs(0,m,0);
	return 0;
}

```

---


# [蓝桥杯 2025 省 A] 黑白棋

## 题目描述

小蓝最近迷上了一款名为“黑白棋填充”的游戏。该游戏在一个方形网格棋盘上进行，其中部分格子已经填有黑色或白色的棋子，而其他格子为空，等待玩家填入棋子。  

游戏规则是，玩家需要按照以下规则填满整个棋盘，才能算作胜利：  
1. **黑白棋子数量均等**：  
   在每一行和每一列中，黑色棋子和白色棋子的数量必须相等。  
2. **相邻棋子限制**：  
   在棋盘的任何一行或一列中，不能有超过两个相同颜色的棋子连续排列（即不允许出现“黑黑黑”或“白白白”的情况）。  
3. **行列唯一性**：  
   每一行的棋子排列方式必须是唯一的，不能与棋盘中的任何其他行完全相同。  
   每一列的棋子排列方式必须是唯一的，不能与棋盘中的任何其他列完全相同。  
   行与列之间的棋子排列不作比较，即行可以与列相同，无需满足行列间的唯一性。

![](https://cdn.luogu.com.cn/upload/image_hosting/xybv3cow.png)

现在有一个 $6 \times 6$ 的棋盘，如上图所示，其中部分格子已填入棋子（黑色或白色），其余格子需要你填充，题目保证有唯一解。  

请给出唯一的正确解，并按照以下格式输出答案：  

- 黑色棋子用 $1$ 表示，白色棋子用 $0$ 表示。  
- 从左到右、从上到下的顺序，依次遍历棋盘上的所有格子，并将这些值拼接成一个长度为 $36$ 的字符串。  

例如，假设最终填充完成后的棋盘如下（仅为示例，并非真实答案）：  
```plain
1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 0 0
0 0 1 1 0 0
0 0 1 1 1 1
```
则输出结果应为：`100000000000000000001000001100001111`。

# 题解

## 作者：123ytq666 (赞：14)

这是一道无需任何编程基础就可以完成的题目，只要有耐心，就一定可以通过。

不扯了，进入正题。

## 题目要求：

用黑白棋填满棋盘，要求：

1. 每行每列都要有三个黑棋和三个白棋。
2. 在棋盘的任何一行或一列中，不允许出现“黑黑黑”或“白白白”。
3. 每一行的棋子排列方式必须是唯一的，不能与棋盘中的任何其他行完全相同。
4. 每一列的棋子排列方式也必须是唯一的，不能与棋盘中的任何其他列完全相同。
5. 行可以与列相同，无需满足行列间的唯一性。

## 棋盘

![初始棋盘](https://cdn.luogu.com.cn/upload/image_hosting/848gpxw7.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

注：本题解使用黄色格子为初始填入的棋子，且 $1$ 代表黑棋，$0$ 代表白棋，$(1,2)$ 表示第 $1$ 行第 $2$ 列。

## 解题思路

#### 第一步
可以直接看出 $(1,3)$ 和 $(3,4)$ 都是黑棋。如果是白棋，那么就违反了第二条规定。

#### 第二步

通过观察，可以发现 $(3,1)$ 必须是黑棋。如果是白棋，那么 $(3,2)$，$(3,3)$，$(3,4)$ 都是黑棋，违反了第二条规定。然后又可以发现 $(2,1)$ 必须是白棋子。

#### 现在的棋盘

![第1,2步棋盘](https://cdn.luogu.com.cn/upload/image_hosting/1hto6per.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

#### 第三步

可以发现，$(6,4)$ 是黑棋，$(6,3)$ 是白棋，因为 $(6,4)$ 的黑棋与 $(3,1)$ 的黑棋对角线对称，并且 $(6,3)$ 的白棋与 $(3,6)$ 的白棋呈对角线，展示见下图。

![图一](https://cdn.luogu.com.cn/upload/image_hosting/agdwd8yj.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

根据规则二，可以轻松判断 $(6,1)$ 是黑棋，$(6,6)$ 是白棋。

然后便可以发现，第 $1$ 列已经有 $3$ 个黑棋，所以，$(4,1)$ 和 $(5,1)$ 必须是白棋。

#### 现在的棋盘

![第3步棋盘](https://cdn.luogu.com.cn/upload/image_hosting/mbf56he8.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

#### 第四步(重点！)

如果我们假设 $(5,2)$ 是白棋，那么 $(5,4)$ 和 $(5,5)$ 是不确定的，但**如果** $(5,2)$ **是黑棋**，那么就可以确定 $(5,4)$ 和 $(5,5)$ 是白棋。

#### 第五步

根据规则一，可以判断 $(4,4)$ 是黑棋。再根据规则三，可以判断 $(4,5)$ 也是黑棋。

可以发现 $(4,3)$ 和 $(4,6)$ 必须是白棋，否则违反了规则一。然后再在 $(4,2)$ 填入黑棋。

#### 现在的棋盘

![第4,5步棋盘](https://cdn.luogu.com.cn/upload/image_hosting/urkv2unf.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

#### 第六步

根据规则一，可以看出 $(1,6)$ 和 $(2,6)$ 必须是黑棋，又发现 $(1,5)$ 必须是白棋，再发现 $(2,5)$ 必须是黑棋。

随后先后看出 $(3,2)$，$(2,2)$，$(2,3)$，$(3,3)$ 分别为白棋，黑棋，白棋，黑棋。

#### 完成！

棋盘填好，最终结果如下图，检查规则三和规则四是否成立就可以提交了。

![最终棋盘](https://cdn.luogu.com.cn/upload/image_hosting/omgxtki9.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

---

## 作者：Zyy67418 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P12139)

观察题目容易发现，这是一道十分简单的数学题。

## 初始棋盘


```
10x0xx
xxx0xx
xxxx00
xxxxxx
xx1xx1
x0xx1x
```


## 解题过程

### 第一步

通过观察，可以直接发现 $(1,3)$ 和 $(4,4)$ 为黑棋。如这两个位置是白棋，就违背了其二条规则。

### 现在的棋盘

```
1010xx
xxx0xx
xxx100
xxxxxx
xx1xx1
x0xx1x
```

### 第二步

容易证明，$(3,1)$ 和 $(6,4)$ 不能为白棋。如果这两个位置为白棋，根据第一条规则，$(3,2)$ $(3,3)$ $(4,4)$ $(5,4)$ 都应为黑棋，可这又违背了第二条规则，所以 $(3,1)$ $(6,4)$ 都应为黑棋。

### 现在的棋盘

```
1010xx
xxx0xx
1xx100
xxxxxx
xx1xx1
x0x11x
```

### 第三步

仔细观察，发现 $(2,1)$ $(6,6)$ 如果是黑棋，就违背了第二条规则，所以 $(2,1)$ $(6,6)$ 都应为白棋。

### 现在的棋盘

```
1010xx
0xx0xx
1xx100
xxxxxx
xx1xx1
x0x110
```

### 第四步

根据第二条规则，我们可以发现，$(6,3)$ 应为白棋。随后根据第一条规则，我们可以确定 $(6,1)$ 为黑棋。接着，根据第一条规则，我们又可以确定 $(4,1)$ $(5,1)$ 为白棋。

### 现在的棋盘

```
1010xx
0xx0xx
1xx100
0xxxxx
0x1xx1
100110
```

### 第五步

在这里，我们已无法逻辑推理了，所以我们假设 $(3,2)$ 为白棋。那么根据第一条原则，$(2,2)$ $(4,2)$ $(5,2)$ $(3,3)$ 就应是黑棋。

### 现在的棋盘

```
1010xx
01x0xx
101100
01xxxx
011xx1
100110
```

### 第六步

根据第一条规则，我们可以确定 $(2,3)$ $(4,3)$ $(5,4)$ $(5,5)$ 为白棋。随后可以证明 $(2,5)$ $(2,6)$ $(4,4)$ 为黑棋。

### 现在的棋盘

```
1010xx
010011
101100
0101xx
011001
100110
```

### 第七步

根据第二条原则，我们容易发现 $(4,5)$ 必须为黑棋。

### 现在的棋盘

```
1010xx
010011
101100
01011x
011001
100110
```

### 最后一步

根据第一条原则，我们不难发现，$(4,6)$ $(1,5)$ 都是白棋。然后，我们可以发现 $(1,6)$ 一定是黑棋。

### 结束

```
101001
010011
101100
010110
011001
100110
```

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    printf("101001010011101100010110011001100110");
    return 0;
}

```

---

## 作者：コマエダ (赞：4)

**题意：**

棋盘已经给定，按照要求填入棋子完善棋盘。

满足：

- 黑白两种颜色每一行每一列个数相等

- 使得没有相同颜色的棋子有三个及以上相邻。

- 同时所有的行中每一行的排列不能相同，所有的列中每一列的排列不能相同。

**思路：**

手玩也许能做。但是这里给出暴搜的做法。

首先建一个矩阵，让所有的黑子位置为 $1$，所有白字的位置为 $0$，所有没填棋子的位置为 $-1$。

我们 dfs 的时候用一个 $pos$ 变量来记录当前枚举的位置，那么行就可以表示为 $row=pos/6$，列就可以表示为 $col=pos \bmod 6$。

考虑搜索过程，如果棋盘上这个位置已经有棋子了，那么直接跳过枚举下一个位置即可。如果这个位置没有棋子，那就从黑白棋子两个中枚举一个，同时要注意剪枝，枚举出来一个棋子可以接着就去判断是否个数已经大于 $3$，或者有 $3$ 个以上的棋子相邻了。然后枚举的过程中可以额外加一个判断就是如果行满了或者列满了，就去检查以下这一行或者这一列有没有出现过，进行进一步剪枝。

然后考虑当 $pos=36$ 时我们就搜索到了最后一个位置，那么这个时候就可以去判断整个棋盘是否符合题意了。为什么还要判断？因为如果棋盘上某位置有子我们直接进入下一层搜索了，而没有进行判断。只有枚举的时候我们进行了判断，所以还要再加一个最后答案的判断，这样这个题就做完啦。

**代码：**

```c++
#include<bits/stdc++.h>
using namespace std;
int grid[6][6] = {
    { 1, 0, 1, 0,-1,-1},
    {-1,-1,-1, 0,-1,-1},
    {-1,-1,-1, 1, 0, 0},
    {-1,-1,-1,-1,-1,-1},
    {-1,-1, 1,-1,-1, 1},
    {-1, 0,-1,-1, 1,-1}
};
//通过题目给出的图片能推出来 (1,3) 和 (3,4) 一定是黑子所以直接填进去
int black_row[6]={0},black_col[6]={0}; //维护行和列上的黑子个数
int white_row[6]={0},white_col[6]={0}; //维护行和列上的白子个数
unordered_set<string> vis_row,vis_col; //记录行和列出现的情况
string ans; //保存答案
int check() //检查最后的棋局
{
	unordered_set<string> r,c;
	for(int i=0;i<6;i++)
	{
		string rr="";
		for(int j=0;j<6;j++) rr+=to_string(grid[i][j]);
		if(r.count(rr)) return 0;
		r.insert(rr);
	}
	for(int i=0;i<6;i++)
	{
		string cc="";
		for(int j=0;j<6;j++) cc+=to_string(grid[j][i]);
		if(c.count(cc)) return 0;
		c.insert(cc);
	}
	return 1;
}
int solve(int pos)
{
	if(pos==36)
	{
		if(check())
		{
			ans="";
			for(int i=0;i<6;i++)
				for(int j=0;j<6;j++) ans+=to_string(grid[i][j]);
			return 1;
		}
		return 0;
	}
	int row=pos/6;int col=pos%6;
	if(grid[row][col]!=-1) return solve(pos+1);//这里直接进下一层
	for(int val=0;val<=1;val++)
	{
		if(!val) { if(white_row[row]>=3||white_col[col]>=3) continue; }
		else { if(black_row[row]>=3||black_col[col]>=3) continue; }
        //这里判断是否总个数已经超了
		if(col>=2&&grid[row][col-2]==val&&grid[row][col-1]==val) continue;
		if(row>=2&&grid[row-2][col]==val&&grid[row-1][col]==val) continue;
		//这里判断是否有连着的三个
        
		grid[row][col]=val;
		if(val) { black_row[row]++;black_col[col]++; } 
		else { white_row[row]++;white_col[col]++; }
		
		int flag=1;
		int full_row=(col==5);int full_col=(row==5);
        //这里比较有意思，行满了实际上是列到头了，所以是(col==5)。反之同理。
		string rowstr="",colstr="";
		if(full_row)
		{
			for(int i=0;i<6;i++) rowstr+=to_string(grid[row][i]);
			if(vis_row.count(rowstr)) flag=0;
			else vis_row.insert(rowstr);
		}
		if(full_col)
		{
			for(int i=0;i<6;i++) colstr+=to_string(grid[i][col]);
			if(vis_col.count(colstr)) flag=0;
			else vis_col.insert(colstr);
		}
		if(flag&&solve(pos+1)) return 1;
        //这里是在判断是否已经有出现过的行和列了，进一步剪枝
		if(full_row) vis_row.erase(rowstr);
		if(full_col) vis_col.erase(colstr);
		grid[row][col]=-1;
		if(val) { black_row[row]--;black_col[col]--; }
		else { white_row[row]--;white_col[col]--; }
        //这里是搜索的回溯
	}
	return 0;
}
int main()
{
	for(int i=0;i<6;i++)
	{
		for(int j=0;j<6;j++)
		{
			if(grid[i][j]==1) { black_row[i]++;black_col[j]++; }
			else if(grid[i][j]==0) { white_row[i]++;white_col[j]++; } 
		}
	}
	if(solve(0)) cout<<ans<<endl;
	return 0; 
} 
```

细节还是挺多的，可以结合注释和代码再理解理解。

---

## 作者：wenqinghua1001 (赞：3)

## 题目意思

在每一行和每一列中，黑色棋子和白色棋子的数量必须相等。那么可以得知，每行每列都要有三个白棋和三个黑棋，且不允许出现“黑黑黑”或“白白白”的情况。每一行的棋子排列方式必须是**唯一**的且每一列的棋子排列方式必须是**唯一**的。

问应该怎样排。

## 思路

![](https://cdn.luogu.com.cn/upload/image_hosting/oblf8m97.png)

以上图片红色代表黑棋，蓝色代表白棋。

不难看出，坐标为 $(1,3)$，$(3,4)$ 的两个位置的答案一定都是红色，不然违反了“不允许出现“黑黑黑”或“白白白”的情况”这条规则。

![](https://cdn.luogu.com.cn/upload/image_hosting/lnt3koks.png)

接着，坐标为 $(3,1)$ 的位置如果填蓝色，那么第三行其他格子都填红色，坐标为 $(3,2)$，$(3,3)$，$(3,4)$ 的三个格子不符合条件，所以坐标为 $(3,1)$ 的格子只能填红色，那么 $(2,1)$ 为蓝色，还可以知道 $(6,4)$ 必须是红色。

![](https://cdn.luogu.com.cn/upload/image_hosting/pxq93ask.png)

从 $(6,3)$ 开始看，得知第六行的所有格子颜色。

![](https://cdn.luogu.com.cn/upload/image_hosting/81fo1yv8.png)

再试试 $(5,4)$ 这个格子，必须是蓝色，不然 $(5,2)$ 是蓝色，$(2,2)$，$(3,2)$，$(4,2)$ 都是红色，冲突。然后得知 $(4,3)$ 的格子为红色，$(4,1)$，$(5,1)$ 都为蓝色。

![](https://cdn.luogu.com.cn/upload/image_hosting/onj7qpc1.png)

$(5,2)$ 必须是红色，不然坐标为 $(2,2)$，$(3,2)$，$(4,2)$ 的三个格子不符合条件，推出 $(5,5)$ 是蓝色。$(4,5)$ 必须是红色，那么第四行就推出来了。

![](https://cdn.luogu.com.cn/upload/image_hosting/cwgk39x3.png)

接着是第二列和第三列。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxiw4rge.png)

最后，推出 $(2,5)$ 是红色，$(2,1)$ 是蓝色，直至推出所有。

![](https://cdn.luogu.com.cn/upload/image_hosting/oeryyn0p.png)

~~其实这题行列唯一性这个条件没啥用。~~

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<"101001010011101100010110011001100110";
	return 0;
}

```

---

## 作者：AASDFGHJKL (赞：3)

# 洛谷 P12139 [蓝桥杯 2025 省A] 黑白棋 题解

## 思路
**DFS + 剪枝**
1.  按照每一行依次填充，不然检查时乱的一批。 
1. 检查每行和每列，当有 $3$ 个以上的白色或黑色棋子时结束搜索。
1. 检查每次填充后，当连续形成三个相同的颜色时结束搜索。
1. 使用数组记录已经排序过的行和列的值，最后检查有没有重复项，有的话结束搜索。

### 时间复杂度
最坏的情况为 $2^{36}$，但剪枝可以减少很多时间。

---

## 代码
```cpp

#include <iostream>
#include <vector>
#include <unordered_set>//这个玩意是个STL容器，只能存储不一样的值
using namespace std;

vector<vector<char>> board(6, vector<char>(6)); // 棋盘存储
vector<int> row_ones(6, 0), row_zeros(6, 0);    // 每行1和0的数量
vector<int> col_ones(6, 0), col_zeros(6, 0);    // 每列1和0的数量
unordered_set<string> used_rows, used_cols;     // 已存在的行列模式
bool found = false;                             // 找到解的标志

/*
 * 检查当前位置(r,c)是否导致行或列出现连续三个相同颜色
 * 参数 r是当前行号 c是当前列号
 * 返回值是true表示通过
 */
bool check_consecutive(int r, int c) {
    // 行检查：向左检查两个格子是否重复
    if (c >= 2 && board[r][c] == board[r][c-1] 
              && board[r][c] == board[r][c-2]) 
        return false;
    
 //列检查：向上检查两个格子是否重复
    if (r >= 2 && board[r][c] == board[r-1][c] 
              && board[r][c] == board[r-2][c]) 
        return false;
    
    return true;
}

/*
 * 深度优先搜索主函数
 *   r是当前处理的行号
 *   c是当前处理的列号
 */
void dfs(int r, int c) {
    // 剪枝1：有解时结束
    if (found) return;

    // 当所有行处理完毕
    if (r == 6) {
        //检查列唯一性
        unordered_set<string> cols;
        for (int j = 0; j < 6; ++j) {
            string col;
            // 生成列字符串
            for (int i = 0; i < 6; ++i)
                col += board[i][j];
            // 发现重复的列立即返回
            if (cols.count(col)) return;
            cols.insert(col);
        }
        
        // 输出
        for (auto &row : board) {
            for (char c : row) cout << c;
        }
        cout << endl;
        found = true; // 找到解了
        return;
    }

    // 当前行结束时
    if (c == 6) {
        string row_str;
        // 生成当前行字符串
        for (char ch : board[r]) row_str += ch;
        
        // 检查行的唯一性
        if (used_rows.count(row_str)) return;
        used_rows.insert(row_str);  // 记录当前行
        
        // 处理下一行第一列
        dfs(r+1, 0);
        
        used_rows.erase(row_str);   // 回溯时删除记录
        return;
    }

    // 跳过已经填充位置
    if (board[r][c] != '.') {
        dfs(r, c+1); // 直接处理下一列
        return;
    }

    // 尝试填充0和1
    for (char val : {'0', '1'}) {
        // 剪枝2：数量限制检查
        if (val == '0' && (row_zeros[r] >=3 || col_zeros[c] >=3)) continue;
        if (val == '1' && (row_ones[r] >=3 || col_ones[c] >=3)) continue;

        // 保存当前状态（用于回溯时恢复）
        char original = board[r][c];
        int ro = row_ones[r], rz = row_zeros[r];
        int co = col_ones[c], cz = col_zeros[c];
        
        // 更新棋盘和计数器
        board[r][c] = val;
        if (val == '0') {
            row_zeros[r]++;
            col_zeros[c]++;
        } else {
            row_ones[r]++;
            col_ones[c]++;
        }
        
        // 剪枝3：检查通过后继续
        if (check_consecutive(r, c)) 
            dfs(r, c+1); // 递归处理下一列
        
        // 回溯恢复状态
        board[r][c] = original;
        row_ones[r] = ro;
        row_zeros[r] = rz;
        col_ones[c] = co;
        col_zeros[c] = cz;
    }
}

int main() {
    // 手动输入样例
    vector<string> input = {
        "10.0..", 
        "...0..",  
        "....00",   
        "......",  
        "..1..1", 
        ".0..1."  
    };
    
    // 初始化棋盘状态
    for (int i = 0; i < 6; ++i) {
        for (int j = 0; j < 6; ++j) {
            board[i][j] = input[i][j];
            // 统计初始棋子的数量
            if (board[i][j] == '0') {
                row_zeros[i]++;  // 行0计数
                col_zeros[j]++;  // 列0计数
            } else if (board[i][j] == '1') {
                row_ones[i]++;   // 行1计数
                col_ones[j]++;   // 列1计数
            }
        }
    }
    
    // DFS搜索（从左上角(0,0)开始）
    dfs(0, 0);
    return 0;
}
```
而最终的答案是 **101001010011101100010110011001100110**。（这一个数直接输出便可以 AC）

这一道题可以**画图枚举出来答案**（但时间太长了），所以用一个长的 DFS 求解。

### **End**

---

## 作者：Xiaonao_Dali (赞：2)

### 编者注
在本题解中所有形如 $(x,y)$ 的格式均代表第 $x$ 行第 $y$ 列。且在所示图内书写的 $0$ 代表白棋，则 $1$ 代表黑棋。
### 正文
第一步：观察图形我们可以很快判定 $(1,3)$ 与 $(3,4)$ 均为黑棋，若为白棋，那么将不符合规则二。\
第二步：根据第一步所推出来的棋子，我们可以得出当 $(3,1)$ 处为白棋时，那么接下来填写会不符合规则二。所以 $(3,1)$ 处必须为黑棋，则我们容易得到 $(2,1)$ 为白棋。\
![](https://cdn.luogu.com.cn/upload/image_hosting/3klcj0mo.png)\
第三步：我们可以将 $(3,2)$ 假设为白棋，那么 $(3,3)$ 就是黑棋，那么就很容易得到，第二列剩余的位置上的棋子都为黑棋，第三列剩余的都是白棋。如果说后面的填写没有矛盾，那么我们的假设是正确的。\
![](https://cdn.luogu.com.cn/upload/image_hosting/7r5beaid.png)\
第四步：根据规则二，可以将 $(6,1)$ 与 $6,4$ 求出来是黑棋，那么 $(6,6)$ 就是白棋。\
![](https://cdn.luogu.com.cn/upload/image_hosting/2xnkbsr4.png)\
第五步：根据规则一，可以求出 $(4,1)$ 与 $(5,1)$ 均为白棋，以及 $(2,5)$ 与 $(2,6)$ 都是黑棋。我们也可以顺便把 $(5,4)$ 与 $(5,5)$ 推出来是白棋。这样我们就可以再推出 $(4,4)$ 为黑棋。\
第六步：在这里我们需要根据规则二将 $(4,5)$ 推出来为黑棋，那么 $(4,6)$ 即为白棋，那么就可以得出 $(1,5)$ 是白棋，那么 $(1,6)$ 是黑棋了。\
![](https://cdn.luogu.com.cn/upload/image_hosting/v6nzy8nm.png)\
第七步：验证，既然前面是猜测，我们要根据三条规则去看是否有违背规则要求，最终我们发现，我们的猜想是正确的。
### 后记
若没思路的话可以进行猜测，不断根据规则一和规则二进行判断，若发现有冲突，那么则最开始猜想错误。但在猜测完后我们需要仔细认真的去推理，避免出错。

---

## 作者：封禁用户 (赞：2)

先把最初的图用`0` `1`图表示：
```
10 0  
   0  
    00
      
  1  1
 0  1 
```
由于不能有连续三个相同颜色的棋子，所以得出 $(1,3)$ 和 $(4,4)$ 应摆放黑棋。棋盘改为：
```
1010  
   0  
   100
      
  1  1
 0  1 
```
如果 $(3,1)$ 是白棋，则第三行剩下两个位置必须为黑棋，棋盘变成：
```
1010  
   0  
011100
      
  1  1
 0  1 
```
出现了连续的三颗黑棋，所以 $(3,1)$ 应为黑棋。又根据规则二，$(2,1)$ 为白棋。
```
1010  
0  0  
1  100
      
  1  1
 0  1 
```
如果 $(6,4)$ 为白棋，则第四列会出现连续的三颗黑棋，所以 $(6,4)$ 为黑棋。接着推出 $(6,1)$ 是黑棋，$(6,3)$ 和 $(6,6)$ 是白棋。
```
1010  
0  0  
1  100
      
  1  1
100110
```
第一列已经有三颗黑棋，剩下两个位置为白棋。
```
1010  
0  0  
1  100
0     
0 1  1
100110
```
我们假设 $(5,2)$ 是黑棋，则 $(5,4)$ 和 $(5,5)$ 是白棋。

根据规则一，$(4,4)$ 为黑棋。由于不能有三颗连续的同色棋子，$(4,5)$ 为黑棋。$(4,3)$ 和 $(4,6)$ 为白棋，$(4,2)$ 为黑棋。
```
1010  
0  0  
1  100
010110
011001
100110
```
第六列缺两枚黑棋，$(1,6)$ 和 $(2,6)$ 为黑棋。
```
1010 1
0  0 1
1  100
010110
011001
100110
```
简单补全剩下的格子即可。最终答案为：
```
101001
010011
101100
010110
011001
100110
```

---

## 作者：yuxinrui0618 (赞：1)

# 题解：P12139 [蓝桥杯 2025 省 A] 黑白棋
## 1. 题目大意
- 一个方形网格，其中部分格子已经填有黑色或白色，而其他格子为空，要我们填，并且要满足要求；
- 在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（在这道题里就是每行三个）；   
  不允许出现“黑黑黑”或“白白白”的情况；  
  每一行（或列）的棋子排列方式必须是唯一的，不能与棋盘中的任何其他行（或列）完全相同，但无需满足行列间的唯一性。

## 2. 思路
- 最开始的图如下。
```cpp
●○  ○    
      ○    
        ○○
            
    ●    ●
  ○    ●  
```
- 很容易就能发现，$(1,3)$ 和 $(3,4)$ 一定是黑棋，因为它们如果是白棋，就不满足条件 2。

```cpp
●○●○    
      ○    
      ●○○
            
    ●    ●
  ○    ● 
```

- 接着，已经没有能够直接判断的位置了，使用假设法：如果 $(3,1)$ 是白棋，那么第三行其他位置的棋子就会不符合要求，所以 $(3,1)$ 只能是黑棋，同时可以根据条件 2 确定 $(2,1)$ 为白棋。

```cpp
●○●○    
○    ○    
●    ●○○
            
    ●    ●
  ○    ●  
```


- 如果 $(6,4)$ 为白棋，则第四列会出现连续的三颗黑棋，所以 $(6,4)$ 为黑棋。那么推出第 6 行所有棋子颜色：$(6,1)$ 是黑棋，$(6,3)$ 是白棋，$(6,6)$ 是白棋。

```cpp
●○●○    
○    ○    
●    ●○○
            
    ●    ●
●○○●●○
```

- 继续，这个时候可以运用条件 1，第一列已经有 3 个黑棋了，那剩下的一定是白棋。
  
```cpp
●○●○    
○    ○    
●    ●○○
○          
○  ●    ●
●○○●●○
```
- 如果 $(5,2)$ 是黑棋，那么就可以确定 $(5,4)$ 和 $(5,5)$ 是白棋，可以试一试（通过后面的推理可以得出，该假设正确）。

```cpp
●○●○    
○    ○    
●    ●○○
○          
○●●○○●
●○○●●○
```
- 根据条件 1，确定 $(4,4)$ 为黑棋，根据条件 3，确定 $(4,5)$ 为黑棋，再根据条件 1，得出 $(4,3)$ 和 $(4,6)$ 为白棋，同时确定 $(4,2)$ 为黑棋。

```cpp
●○●○    
○    ○    
●    ●○○
○●○●●○
○●●○○●
●○○●●○
```
- 根据条件 1，得出 $(1,6)$，$(2,6)$ 为黑棋，那么 $(1,5)$ 为白棋，同时 $(2,5)$ 也确定为黑棋，接着剩下的第三行也全部确定了：$(2,2)$，$(2,3)$，$(3,2)$，$(3,3)$ 分别为黑棋，白棋，白棋，黑棋，最终棋盘如下。
  
```cpp
●○●○○●
○●○○●●
●○●●○○
○●○●●○
○●●○○●
●○○●●○
```
- 输出结果即可。

# 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<"101001010011101100010110011001100110";
	return 0;
}
```

# 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---


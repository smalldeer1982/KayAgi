# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# 题解

## 作者：钱逸凡 (赞：196)

```
/*这道题的难点在于判断是否有船相邻。
 通过自己模拟的数据可以得出结论： 
 如果图是不和法的，一定存在如下结构：
# # 
. #
或
# #
# .
或
# .
# #
或
. #
# #
即在一个2*2的方格中有三个#。所以就能得出代码：*/
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int r,c;
char map[1010][1010];
int fx[4]={0,-1,1,0};
int fy[4]={-1,0,0,1};
int dfs(int x,int y){
	map[x][y]='*';
	for(int i=0;i<4;i++){
		if(x+fx[i]>0&&x+fx[i]<=r&&y+fy[i]>0&&y+fy[i]<=c&&
		map[x+fx[i]][y+fy[i]]=='#')dfs(x+fx[i],y+fy[i]);
	}
}//把与#连通的所有点改成*因为它们是同一艘船 
bool d(int i,int j){
	int c=0;
	if(map[i][j]=='#')c++;
	if(map[i+1][j]=='#')c++;
	if(map[i][j+1]=='#')c++;
	if(map[i+1][j+1]=='#')c++;
	if(c==3)return 0;
	return 1;
}//判断是否合法 
int main(){
	scanf("%d%d",&r,&c);
	register int i,j;
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
		cin>>map[i][j];
		}
	}
	int s=0;
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
			if(i<r&&j<c&&d(i,j)==0){
				printf("Bad placement.");
				return 0;//不合法后面就没必要继续了 
			}
		}
	}
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
			if(map[i][j]=='#'){
			s++;
			dfs(i,j);	
			}//因为前面已经确保了是合法的，现在只需统计船的数量 
		}
	}
	printf("There are %d ships.",s);
	return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：103)

### 抄袭者请直接跳至完整代码区。
------------
#### 原创作品，谢谢支持！
------------
这题其实不难，只要知道如何判断合法即可。

本蒟蒻本想写一个dfs，但是后来发现根本不用，~~由于作者太懒，煤油改函数名~~。因此本篇题解适合不会搜索的童鞋（懂得搜索的大佬也可以康康哦，还是挺有参考价值的~~吗？~~）。

#### 思路：
1. 输入后，找‘#’，判断该‘#’所在方阵是否合法。如不合法，直接输出“Bad placement.”并结束程序；合法的话，用染色的办法删除该方阵，ans++；
2. 找下一个‘#’；
3. 输出ans。

------------
至于如何结束程序，由main函数中的最后一句if语句实现。

#### 所以main函数就这么写

注：不合法部分的输出在伪dfs函数中。

```cpp
int main()
{
	scanf("%d %d",&r,&c);
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++) cin >> sea[i][j];
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
		{
			if(sea[i][j] == '#') dfs(i,j);
			if(pd == true) return 0;
		}
	printf("There are %d ships.",ans);
	return 0;
}
```
------------
### 那么伪dfs函数怎么写呢？

#### 思路：

1. 先确定方阵上方、左边的边长；

代码如下

```cpp
int heng,shu,temp=0;
for(shu=y;;shu++) if(sea[x][shu] == '.' || shu > c) break;
shu--;
for(heng=x;;heng++) if(sea[heng][y] == '.' || heng > r) break;
heng--;
```
于是边长就求出来啦！
------------

2. 判断是否合法；

**方法**：若方阵中有一竖线与左边边长不相等**或**有一横线与上面边长不相等，则该方阵不合法。利用这个特性可以确定方阵的合法性。

代码如下，判断方阵不合法后如何结束程序也能通过改变pd的值实现
```cpp
for(int i=y;i<=shu;i++)
{
	for(int j=x;sea[j][i] == '#';j++) temp++;
	if(temp != heng-x+1) {printf("Bad placement."); pd=true; return ;}
	temp=0;
}
//两者二选一即可
for(int i=x;i<=heng;i++)
{
	for(int j=y;sea[i][j] == '#';j++) temp++;
	if(temp != shu-y+1) {printf("Bad placement."); pd=true; return ;}
	temp=0;
}
    
```
------------
3. 染色，删除方阵
```cpp
for(int i=x;i<=heng;i++)
	for(int j=y;j<=shu;j++) sea[i][j]='*';
```
最后一句ans++；就可以返回啦！
------------

完整代码

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <vector>
//这么多头文件实在煤必要，大家不要学这种人
using namespace std;
int r,c,ans;
char sea[1010][1010];
bool pd=false;
void dfs(int x,int y)
{
	int heng,shu,temp=0;
	for(shu=y;;shu++) if(sea[x][shu] == '.' || shu > c) break;
	shu--;
	for(heng=x;;heng++) if(sea[heng][y] == '.' || heng > r) break;
	heng--;
	for(int i=y;i<=shu;i++)
	{
		for(int j=x;sea[j][i] == '#';j++) temp++;
		if(temp != heng-x+1) {printf("Bad placement."); pd=true; return ;}
		temp=0;
	}
	for(int i=x;i<=heng;i++)
	{
		for(int j=y;sea[i][j] == '#';j++) temp++;
		if(temp != shu-y+1) {printf("Bad placement."); pd=true; return ;}
		temp=0;
	}	
	for(int i=x;i<=heng;i++)
		for(int j=y;j<=shu;j++) sea[i][j]='*';
	ans++;
	return ;
} 
int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	scanf("%d %d",&r,&c);
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++) cin >> sea[i][j];
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
		{
			if(sea[i][j] == '#') dfs(i,j);
			if(pd == true) return 0;
		}
	printf("There are %d ships.",ans);
//	fclose(stdin);fclose(stdout);
	return 0;
}
```
#### PS：作者是一名明天还要上网课的初中生，管理员大大就让他过了吧，救救孩子！

---

## 作者：Dzhao (赞：85)

## 题解 P1331 【海战】
这是一道骚鸡题

看这个位巨佬都用本蒟蒻不会敲的BFS和DFS，我只好发一篇用for循环解决的题解

>我太菜了！都被菜哭了！

好，言归正传

其实这道题，我们唯一麻烦的是，他可能有船相撞，于是我们考虑一下不合法的情况

在 $2*2$ 的矩阵中，只有这四种情况:

1.

\##

\#.

2.

\##

\.#

3.

\#.

\##

4.

\.#

\##

于是，我们就可以在开头时特判一下，接下来就好办了

我们可以发现，一个矩阵他被记录过一次，也可以看成是搜到他的左上角时加一，而
搜到矩阵的下面时，我们就可以判断一下它上面和左边与他相邻的格子是不是"#"，这样就十分好办，$O(n^2)$ 的复杂度用for循环就可以解决这个问题了。

开森哇！代码来啦

~~BBBB~~

---------------------------------------------------我是~~超级可爱的~~分割线----------------------------------------------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1009
char g[N][N];
int n,m;
bool check(int x,int y)
{
	int cnt=0;
	if(g[x][y]=='#') cnt++;
	if(g[x+1][y]=='#') cnt++;
	if(g[x][y+1]=='#') cnt++;
	if(g[x+1][y+1]=='#') cnt++;
	return cnt==3; 
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	
			cin>>g[i][j];
	for(int i=1;i<n;i++) //特殊情况的判断 
		for(int j=1;j<m;j++)
			if(check(i,j))
			{
				printf("Bad placement.\n");
				return 0;
			}
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) //判断是否为矩阵，并记录答案 
			if(g[i][j]=='#' && g[i-1][j]!='#' && g[i][j-1]!='#') ans++;
	printf("There are %d ships.\n",ans);
	return 0;
}
```

我太弱了，被各位巨佬吊打
$QwQ$

---

## 作者：智子·起源 (赞：26)

#### 看了一下下面的题解，要么就是深搜，要么就看得人一脸懵逼。

------------

## 用简单的宽搜实现这道题！


------------
这道题有那么一点点的难度，就是判断当前搜到的图形是不是方形。一旦搜到不规则图形，那就一定是……
![](https://cdn.luogu.com.cn/upload/image_hosting/p32vcr8u.png)
#### 撞船了！！

解决这个问题很简单：只要找到当前搜的一块地方的行坐标最大范围、列坐标最大范围，然后在搜完之后双for枚举范围内有没有不是甲板的地方（.），有的话，那就直接输出“Bad placement.”结束程序。

放代码，结合着讲^_^（大佬们看看源码就行了）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{int x,y,t;}que[10000];//超强的自创队列-。-…
int n,m,ans,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},maxn,maxm,minn,minm;
char f[1000+5][1000+5];
void bfs(int x,int y)
{
  int h=0,t=1,xx,tt,yy;
  que[0].t=0,que[0].x=x,que[0].y=y,f[x][y]='*';
  maxn=max(maxn,x);
  maxm=max(maxm,y);
  minn=min(minn,x);
  minm=min(minm,y);//四句max和min函数用来判断当前x、y的范围。
  while(h!=t)
  {
    for(int i=0;i<4;i++)
    {
      xx=que[h].x+dx[i];
      yy=que[h].y+dy[i];
      tt=que[h].t+1;
      if(xx<1||yy<1||xx>n||yy>m||f[xx][yy]!='#')continue;
      f[xx][yy]='*';
      que[t].x=xx;
      que[t].y=yy;
      que[t].t=tt;
      maxn=max(maxn,xx);
      maxm=max(maxm,yy);
      minn=min(minn,xx);
      minm=min(minm,yy);
//在基础宽搜上再加上对最大范围的更新操作就可以了^_^
      t=(t+1)%10000;
    }
    h=(h+1)%10000;
  }
}
int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>f[i][j];
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      if(f[i][j]=='#')
      {
	    maxn=maxm=-1;
	    minn=minm=1000000;//记得赋边界值！
		bfs(i,j);//开搜！
		for(int k=minn;k<=maxn;k++)
		  for(int l=minm;l<=maxm;l++)
		    if(f[k][l]!='*'){printf("Bad placement.");return 0;}//判断是否是方形
        ans++;//经过检验后船的数量++即可。
	  }
  
  printf("There are %d ships.",ans);
  return 0;
}
```

接下来放一下源码：
```cpp
-#include<bits/stdc++.h>
-using namespace std;
-struct data
-{int x,y,t;}que[10000];
-int n,m,ans,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},maxn,maxm,minn,minm;
-char f[1000+5][1000+5];
-void bfs(int x,int y)
-{
-  int h=0,t=1,xx,tt,yy;
-  que[0].t=0,que[0].x=x,que[0].y=y,f[x][y]='*';
-  maxn=max(maxn,x);
-  maxm=max(maxm,y);
-  minn=min(minn,x);
-  minm=min(minm,y);
-  while(h!=t)
-  {
-    for(int i=0;i<4;i++)
-    {
-      xx=que[h].x+dx[i];
-      yy=que[h].y+dy[i];
-      tt=que[h].t+1;
-      if(xx<1||yy<1||xx>n||yy>m||f[xx][yy]!='#')continue;
-      f[xx][yy]='*';
-      que[t].x=xx;
-      que[t].y=yy;
-      que[t].t=tt;
-      maxn=max(maxn,xx);
-      maxm=max(maxm,yy);
-      minn=min(minn,xx);
-      minm=min(minm,yy);
-      t=(t+1)%10000;
-    }
-    h=(h+1)%10000;
-  }
-}
-int main()
-{
-  scanf("%d%d",&n,&m);
-  for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>f[i][j];
-  for(int i=1;i<=n;i++)
-    for(int j=1;j<=m;j++)
-      if(f[i][j]=='#')
-      {
-	    maxn=maxm=-1;
-	    minn=minm=1000000;
-		bfs(i,j);
-		for(int k=minn;k<=maxn;k++)
-		  for(int l=minm;l<=maxm;l++)
-		    if(f[k][l]!='*'){printf("Bad placement.");return 0;}
-        ans++;
-	  }
-  
-  printf("There are %d ships.",ans);
-  return 0;
-}
```
### 已做防抄袭操作o^_^o

---

## 作者：221B (赞：25)

我们设一艘船一行有h个“#”，一列有l个“#”，我们可以发现：

**如果一艘船不与别的船接触，也就是这艘船是矩形，那么这艘船由l\*h个“#”构成（和算长方形正方形的面积差不多）**，我们便可以有如下思路：

如果找到一个“#”，先把这一行的“#”的总数h找出，再把这一列“#”的总数l找出，最后用**dfs**把这个“#”所有连接的“#”的个数s统计出来,**如果s不等于l\*h,也就是这艘船不为矩形，就可以输出“Bad placement.”，终止程序**。否则就作为一艘船计入总数。

注意：

######  _如果找到一艘船，为了避免以后重复查找，要将所有构成这艘船的“#”都变成“.”。_ 

-----------
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char a[1005][1005];//用二维数组储存整个游戏棋盘
int n,m,s,k,q;
void dfs(int x,int y) {//x、y代表棋盘中一个点的坐标
	++q;//将每个“#”都累计起来
	a[x][y]='.';//避免重复，将找到的“#”变成“.”
	if(x-1>=1&&a[x-1][y]=='#')//向下查找与当前“#”所连接的“#”，注意x的值不能小于1，否则会超出整个数组
		dfs(x-1,y);
	if(x+1<=n&&a[x+1][y]=='#')//向上查找与当前“#”所连接的“#”，注意x的值不能大于n（即这一行的“.”与“#”的个数），否则同上
		dfs(x+1,y);
	if(y+1<=m&&a[x][y+1]=='#')//向右查找与当前“#”所连接的“#”，注意y的值不能超过m（即这一列的“.”与“#”的个数），否则...
		dfs(x,y+1);
	if(y-1>=1&&a[x][y-1]=='#')//向左查找与当前“#”所连接的“#”，注意y的值不能小于1
		dfs(x,y-1);
}
int main() {
	cin>>n>>m;//读入整个棋盘的行和列
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++)
		cin>>a[i][j];//输入整个棋盘
	}
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			if(a[i][j]=='#') {//如果找到一个“#”，就代表这个地方有船
				q=0;//注意清零
				int h,l;
				h=l=0;//行的总数河北列的总数也要清零
				for(int x1=i; x1<=n; x1++) {//将这一列与当前“#”所连通的“#”的个数找出
					if(a[x1][j]=='#') {
						++l;
					} else break;
				}
				for(int x1=j; x1<=m; x1++) {//将这一行与当前“#”所连通的“#”的个数找出
					if(a[i][x1]=='#')
						++h;
					else break;
				}
				k=h*l;//将构成这艘船的“#”的个数算出（如果这艘船不与别的接触）
				dfs(i,j);//深搜走起
				if(q!=k)//诶？如果先前把这艘船当做矩形的“#”的个数与找出的“#”的个数不同
				{
				cout<<"Bad placement.";	//表示这艘船不为矩形
				return 0;//结束整个程序
				}
                ++s;//将这艘船计入
			}
		}
		cout<<"There are "<<s<<" ships.";//输出要规范哈
	return 0;//养成好习惯
}
```


---

## 作者：Sakura_Peng (赞：17)

主要也要看自己的阅读能力吧……

注意这句话“我们仅考虑船是方形的，所有的船只都是由图形组成的方形”，说明一条船是由最大的#所组成的方形矩阵！

这道题我的想法也就是按照BFS入门题目的填涂颜色还有那个什么细胞分裂的想法一样的，算出连在一起的’#’的个数，而这个连在一起的个数就是最后船的个数。

但是这里要判断如果两艘船相邻，这个就比较恶心了，这个相邻的意思就是有两个方形矩阵相邻，且这两个方形无法组成新的方形。

比如下图就是一种例子：

 ![](https://cdn.luogu.com.cn/upload/pic/10406.png) 

虽然这两个方形有部分相连，但是他们并不是同一个方形，所以这就是两个船，即第一个红方框围成的一个船，第二个红方框围成的一个船。

这里如果两个船相邻仅需要输出Bad placement.就可以了，这时候我们便可以使用一点点贪心（不是贪心算法的那个意思）

在BFS搜索的时候判断有没有以下情况，如果有的话那么就直接跳出搜索，直接输出Bad placement.

我们可以找一找规律，便可以发现如果两个#有以下情况：

1.
 ![](https://cdn.luogu.com.cn/upload/pic/10409.png) 

2.
 ![](https://cdn.luogu.com.cn/upload/pic/10408.png) 

即如果两个#被一个或两个“.”夹着，那么这时候就说明这代表两个不同的方形了。

（这里需要读者自己推敲）


代码奉上（有点冗余，望大佬勿喷！）

```cpp
#include <stdio.h>
#include <string.h>

int dx[2][2]={{0,1},{1,0}}; //剪枝，不一定非要判断上下左右，只用判断右和下，因为左，下是已经判断过的，在判断一次就大大多了循环时间
int que[1000001][2],b[1001][1001],a[1001][1001],n,m,l;
/* que是队列，b是存储是否走过，a是存储原本的.#,
n,m是边界，l是判断是否有两个相邻的船，方便输出*/
int pd(int i,int j) //如思路所述的判断两个矩阵的
{
    if (a[i][j]==1)
            {
                if (a[i+1][j-1]==1)
                {
                    if (a[i+1][j]==0 || a[i][j-1]==0)
                    {
                        return 1;
                    }
                }
                    if (a[i+1][j+1]==1)
                    {
                        if (a[i+1][j]==0 || a[i][j+1]==0)
                        {
                            return 1;
                        }
                    }
                    if (a[i-1][j-1]==1)
                {
                    if (a[i][j-1]==0 || a[i-1][j]==0)
                    {
                        return 1;
                    }
                }
                if (a[i-1][j+1]==1)
                {
                    if (a[i-1][j]==0 || a[i][j+1]==0)
                    {
                        return 1;
                    }
                }
                }
                return 0;
            }
void BFS(int x,int y,int k) //BFS，这里的k可以省略，因为没什么用
{
    int tail=1,head=0,i,x1,y1;
    que[tail][0]=x;
    que[tail][1]=y; //源结点入队列
    b[x][y]=1; //标记判断过
    do
    {
        head++;
        for (i=0;i<2;i++)
        {
            x1=que[head][0]+dx[i][0]; 
            y1=que[head][1]+dx[i][1]; //扩展的坐标
            if (pd(x1,y1)==1)
            {
                l=1;
                return ;
            } //先判断旁边有没有别的船是相邻的，有的话就不用搜索了
            if (x1>=1 && x1<=n && y1>=1 && y1<=m && a[x1][y1]==1 && b[x1][y1]==0) //判断边界，判断走没走过，判断是不是#
            {
                tail++; 
                que[tail][0]=x1;
                que[tail][1]=y1; //拓展新的结点
                b[x1][y1]=1; //标记走过
                a[x1][y1]=k; //这里是为了辨别别的船，根据推敲，也不需要这一行，因为b数组的作用已经体现了，因此整个函数的int k也可以删去的
            }
            }

        }while (head<tail);
}
int main()
{

    char ch[10001];
    int total=0,i,j,k=1;
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        scanf("%s",ch); //输入的格式没有空格，因此需要先录入一个字符串
        for (j=0;j<=strlen(ch)-1;j++) //进行字符串存储到a数组里
        {
            if (ch[j]=='#')
            a[i][j+1]=1; //如果是船体的一部分#
            else //如果是海“.”
                a[i][j+1]=0;
        }
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=m;j++) //搜索
        {
            if (a[i][j]==1 && b[i][j]==0) //如果这个地方是船体，并且没有走过
            {
                k++; //可不要
                BFS(i,j,k); //进行循环，将这里这一片所连在一起的#进行标记判断
                total++; //船数量+1
            }
        }
    }
    if (l==1)
    {
        printf("Bad placement.\n");
    } //如果有船体相邻的
    else
    printf("There are %d ships.\n",total); //否则就输出船只数
    return 0;
}
```

反思：

这道题考试的时候没有花太多的时间在标记船的部分，主要在推相邻船只那里用了点时间，可能不是最优的算法，所以希望大佬不要喷！


###以上就是蒟蒻题解的全部内容啦！


---

## 作者：clyoyo (赞：8)

发一个不用搜索做的题解：

2个核心思想

1.先判断“Bad placement”的情况，如果有船只相接触，那么不管是怎么样的形式接触，都可以概括为是田字格中四个占三个的情况。

所以只要图中任意一个四格田字格出现三个格子是#的情况，就是Bad placement；

2.在判断完1的前提下，统计船只个数，只要统计船所在矩形最右下角的#的个数即可，而右下角#一定是满足条件：右边和下面是'.'，

边界的可以在外围包一圈‘.’，所以只要判断图中有几个点的右边点和下边点都是‘.'，那么这个点就代表一条船

本题可以将字符图形转变为数字图形，判断条件更简单。

代码如下：

var a:array[1..1001,1..1001]of 0..1;//下界一定要开大1位

```cpp
    i,j,k,l,m,n:longint;
    ch:char;
begin 
  readln(m,n);
  for i:=1 to m do //预处理
  begin 
    for j:=1 to n do 
    begin 
      read(ch);
      if ch='#' then a[i,j]:=1;
    end;
    readln;
  end;
  for i:=1 to m-1 do //判断bad的情况
    for j:=1 to n-1 do 
      if a[i,j]+a[i,j+1]+a[i+1,j]+a[i+1,j+1]=3 then 
      begin 
        write('Bad placement.');
        halt;
      end;
  for i:=1 to m do //统计船只数
    for j:=1 to n do 
      if  (a[i,j]=1) and (a[i+1,j]+a[i,j+1]=0) then 
        inc(l);
  write('There are ',l,' ships.');
end.
```

---

## 作者：Cambridge (赞：7)


小学生又来发题解了！

本蒟蒻看到这道题发现和卫星照片这道题有点像（洛谷上没有），都是判断矩形，本蒟蒻把自己的思路在程序中说明，不过我还是粗略讲一下吧。

首先，我们找出一块不是水的最小行、最大行、最小列、最大列，如果我们发现这一块出现了一个“.”，那，这不是一个合格的船。

所以，规律就这样出来了：
1、找出不是一大块#的最小行、最大行、最小列、最大列。

2、如果这一块出现“.”，说明这一块不是船，否则就是船。


如果还是不懂，代码时间······
    
    #include<iostream>
    #include<cstring>
    #include<cstdio>
    #include<cmath>
    #include<string>
    #include<cstdlib>
    #include<algorithm>//文件头不解释
    using namespace std;
    int m,n,f[1005][1005],s,b[1005][1005],pd,lll;
    int xx,dd,xb,db;
    char a[1005][1005];//定义一堆变量
    int bx[4]={0,0,-1,1};
    int by[4]={-1,1,0,0};//控制当前位置上下左右的移动的数组，一个控制行，一个控制列
    void dfs(int x,int y)//广度优先搜索
    {
        if(x<1||x>n||y<1||y>m||f[x][y]==1||a[x][y]!='#')return ;//如果当前位置超过了边界或者访问过当前位置或者当前位置是水则返回上一次
        else//否则
        {
        a[x][y]='@';//当前位置设为@这个符号，也就是标记当前位置
        f[x][y]=1;//标记当前位置（是不是和上一个重复了？我不管）
        if(x>xx)xx=x;
        if(y>dd)dd=y;
        if(x<xb)xb=x;
        if(y<db)db=y;
        //这里是本程序的重点部分，找出不是一大块#的最小行、最大行、最小列、最大列
        for(int i=0; i<4; i++)
            dfs(x+bx[i],y+by[i]);//当前位置上下左右移动
        }
        return ;
    }
    int main()
    {
    cin>>n>>m;//读入行数、列数
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            cin>>a[i][j];//读入数据
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
        {
            if(a[i][j]=='#')//如果这个位置有“#”，搜索去，不然去搜索没有什么价值
            {
                xx=-1,dd=-1,xb=2100000,db=2100000;//位置需要初始化
                dfs(i,j);//搜索去
                for(int k=xb; k<=xx; k++)
                {
                    for(int l=db; l<=dd; l++)
                    {
                        if(a[k][l]=='.')pd=1,s=-1;//如果出现“.”，说明找到的这一块不是船
                        a[k][l]='.';//把当前位置变为水，因为已经找过这个位置了
                    }
                }
                if(pd==0)s++;
            }
        }
    }
    if(s!=-1)cout<<"There are "<<s<<" ships.";
    else cout<<"Bad placement.";
    //输出操作
    return 0;
    }
好了，本蒟蒻就讲到这，希望对读者有所帮助


---

## 作者：Z__X (赞：7)

### 其实，这道普及/提高-的题挺简单的，只要四个方格内有三个是‘#’，那么，就直接可以输出‘Bad placement.’了，没有在搜下去的意义了，先判断这个，除去特殊情况后就可以直接搜索船只的数量了。

#### 本蒟蒻一开始只有72分，检查了半天竟然是搜索起点错了（无语...）
## 下面直接上代码：

```
var
  n,m,i,j,sum:longint; 
  a:array[0..1001,0..1001] of char; 
procedure dfs(x,y:longint);
begin
  if (x<1) or (x>n) then exit;  //判断行的边界
  if (y<1) or (y>m) then exit;  //判断列的边界
  if a[x,y]='.' then exit;
  a[x,y]:='.';
  dfs(x,y-1);  //往左搜
  dfs(x,y+1);  //往右搜
  dfs(x-1,y);  //往上搜
  dfs(x+1,y);  //往下搜
end;
function find(x,y:longint):boolean;
var
  s:longint;  
begin
  s:=0;
  if a[x,y]='#' then inc(s);     //判断当前点是否为‘#’
  if a[x+1,y]='#' then inc(s);   //判断当前点的下面那个方格是否为‘#’
  if a[x,y+1]='#' then inc(s);   //判断当前点的左面那个方格是否为‘#’
  if a[x+1,y+1]='#' then inc(s); //判断当前点的下面的右面那个方格是否为‘#’
  if s=3 then exit(false)
         else exit(true);   //在四个方格内累加‘#’的数量，如果是三返回false，否则返回true
end;
begin
  readln(n,m);  
  for i:=1 to n do  
   begin   
     for j:=1 to m do read(a[i,j]);     //输入二维数组
     readln;
   end;   
  for i:=1 to n do  
   for j:=1 to m do  
    if find(i,j)=false then   //判断是否为‘Bad placement.’的特殊情况
     begin 
       writeln('Bad placement.');       
       halt;      
     end;     
  for i:=1 to n do  
   for j:=1 to m do  
    if a[i,j]='#' then   //搜索船只数量
     begin     
       dfs(i,j);       
       inc(sum);         //累加船只数量
     end;     
  writeln('There are ',sum,' ships.');  //输出
end.
```

---

## 作者：GaryH (赞：5)

# 蒟蒻又来发题解啦！


 其实此题的正解应是宽搜，但有一种简单的判断船是否合理的方法，即开两个for查找每一个‘#’处的附近是否合理即可

### 这儿有一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/if3mvf7g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


图中对有**红色边框**的‘#’进行查找，查找方法是看当前‘#’上下左右还有没有‘#’.

#### 查找代码：

```
int nx=x,ny=y,ox=x,oy=y;
while(a[nx][y][0]==1&&nx<=n)nx++;
while(a[x][ny][0]==1&&ny<=m)ny++;
while(a[ox][y][0]==1&&ox>=1)ox--;
while(a[x][oy][0]==1&&oy>=1)oy--;
```

若当前查找的‘#’坐标为x,y,则nx,ny,ox,oy在执行此代码后就代表最右，最下，最左，最上的有‘#’的坐标+1

**注意，是有‘#’的坐标加一**，因为while只有不满足执行条件时才退出，就会多加一个.

所以在找出nx,ny,ox,oy后，在(nx-ox)*(ny-oy)的矩阵中找有没有水，如果有水，则代表这里不是完全完整的矩形，即不合理.

#### 判断完全矩形的代码：

```
int p;
inline void print(){
   std::cout<<"Bad placement.";
   //不合理就输出
}

for(register int i=ox+1;i<nx&&!p;i++){
    for(register int j=oy+1;j<ny&&!p;j++){
	   if(a[i][j]!=1){
	      print();
	      p=1;
             //p为判断
	   }else{
              a[i][j]=0;
              //把找过的填成水
           }
     }
}
```
那现在就只需把地图中每一个‘#’找一遍就好了，**就像这样：**

```
#include<iostream>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;
int n,m,a[1001][1001],p,cnt=0;
char ch;
inline void print(){
	std::cout<<"Bad placement.";
}
inline void find(int x,int y){
	if(p)return;
	int nx=x,ny=y,ox=x,oy=y;
	while(a[nx][y]==1&&nx<=n)nx++;
	while(a[x][ny]==1&&ny<=m)ny++;
	while(a[ox][y]==1&&ox>=1)ox--;
	while(a[x][oy]==1&&oy>=1)oy--;
	    for(register int i=ox+1;i<nx&&!p;i++){
		    for(register int j=oy+1;j<ny&&!p;j++){
			if(a[i][j]!=1){
			    print();
			    p=1;
			}else{
			    a[i][j]=0;
			 }
		  }
	    }
	if(p)return;
	else cnt++;
}
int main(){
//	freopen("battle.in","r",stdin);
//	freopen("battle.out","w",stdout);
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			std::cin>>ch;
			if(ch=='#')a[i][j]=1;
			else a[i][j]=0;
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(a[i][j]==1){
				find(i,j);
				a[i][j]=1;
			}
		}
	}
	if(!p)cout<<"There are "<<cnt<<" ships.";
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```
然后一测......

## 81分...

## 嘤嘤嘤

在经过冥思苦想后，我想出一组数据：

```
3 3
# . .
. # .
. # #
```
这个数据就会错，而错的原因是**该代码不是搜索**，不能往右下找。

所以这里就需要对每一个‘#’找它旁边的矩形，而找完之后也不能把找过的‘#’变成‘   . ’，就像这样：

```
#include<iostream>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;
int n,m,a[1001][1001],p,cnt=0;
char ch;
string str="Bad placement.";
inline void print(){
	std::cout<<str;
}
inline void dfs(int x,int y){
	if(p)return;
	int nx=x,ny=y,ox=x,oy=y;
	while(a[nx][y]==1&&nx<=n)nx++;
	while(a[x][ny]==1&&ny<=m)ny++;
	while(a[ox][y]==1&&ox>=1)ox--;
	while(a[x][oy]==1&&oy>=1)oy--;
	for(register int i=ox+1;i<nx&&!p;i++){
		for(register int j=oy+1;j<ny&&!p;j++){
			if(a[i][j]!=1){
				print();
				p=1;
			}
		}
	}
	if(p)return;
	else cnt++;
}
int main(){
//	freopen("battle.in","r",stdin);
//	freopen("battle.out","w",stdout);
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			std::cin>>ch;
			if(ch=='#')a[i][j]=1;
			else a[i][j]=0;
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(a[i][j]==1){
				dfs(i,j);
				a[i][j]=1;
			}
		}
	}
	if(!p)cout<<"There are "<<cnt<<" ships.";
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```
高高兴兴交上去...

[提交记录#1](https://www.luogu.org/record/26412750)

### 我哭聊

哎，不说了，明显这样是会重复寻找的，所以我想了一种三维避免重复的方法，即开一个a[1001][1001][2],a[i][j][0]表示地图，a[i][j][1]表示是否统计过.

于是我终于AC了！

[提交记录#2（已AC）](https://www.luogu.org/record/26383317)

最后放一下AC代码：

```
#include<iostream>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;
int n,m,a[1001][1001][2],p,cnt=0;
//cnt为答案 
char ch;
string str="Bad placement.";
inline void print(){
	std::cout<<str;
	//输出函数 
}
inline void find(int x,int y){
	//这个函数前面已经解释了 
	if(p)return;
	//p是判断是否合理 
	int nx=x,ny=y,ox=x,oy=y;
	while(a[nx][y][0]==1&&nx<=n)nx++;
	while(a[x][ny][0]==1&&ny<=m)ny++;
	while(a[ox][y][0]==1&&ox>=1)ox--;
	while(a[x][oy][0]==1&&oy>=1)oy--;
	for(register int i=ox+1;i<nx&&!p;i++){
		for(register int j=oy+1;j<ny&&!p;j++){
			if(a[i][j][0]!=1){
				print();
				p=1;
				//不合理马上输出 
			}
		}
	}
	if(p)return;
	else if(!a[x][y][1])cnt++;
	for(register int i=ox+1;i<nx&&!p;i++){
		for(register int j=oy+1;j<ny&&!p;j++){
			a[i][j][1]=1;
			//把找过的标记 
		}
	}
}
int main(){
//	freopen("battle.in","r",stdin);
//	freopen("battle.out","w",stdout);
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			std::cin>>ch;
			if(ch=='#')a[i][j][0]=1;
			else a[i][j][0]=0;
			//用字符读入‘#’和‘.’，并把地图存进数组里 
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(a[i][j][0]==1){
				find(i,j);
				//挨个寻找 
				a[i][j][1]=1; 
			}
		}
	}
	if(!p)cout<<"There are "<<cnt<<" ships.";
	//输出 
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
//结束 
```
拜拜！

---

## 作者：_outstanding (赞：5)

## 深搜连通图模板+判断连通图是否为矩形
看了一下题解，大部分是BFS+矩形判断，还有神奇的思路：直接扫一遍，看2\*2方格里面是不是有三个#来判断有没有撞船。显然本蒟蒻想不到神奇的解法，只好老老实实搜索连通图……

DFS怎么搜连通图大家应该都知道，直接看代码吧

但判断矩形有点麻烦！

有的题解是先找到行列上（即矩形的边上）‘#’的个数算出面积，然后判断连通图的‘#’数量是否等于面积。这样貌似会出问题，比如：

\###.

\##. .

. \#. .

这样长为3，宽为2，连通图中‘#’也是6个，但不是矩形！

所以我换了个思路，搜连通图的时候，找出行列号的范围，即求rmin, rmax, cmin, cmax, 这样连通图一定被框在以（rmin, cmin）为左上角，（rmax, cmax）为右下角的矩形内。如果这个矩形的面积（rmax-rmin+1）\*（cmax-cmin+1）等于连通图中‘#’的数量cnt，就说明连通图是矩形。

综上所述，结论就是：连通图为矩形的充要条件是（rmax-rmin+1）\*（cmax-cmin+1）== cnt。

上代码（什么？你说WA声一片？）：
***

```cpp
#define _CRT_SECURE_NO_WARNINGS //咒语！
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
bool a[1005][1005];//'#'为1，'.'为0
bool visit[1005][1005];//是否搜索过，搜索过为1
int cnt, rmin, rmax, cmin, cmax, r, c;
//r行c列，其余意义见上
const int dr[4] = { 0,0,1,-1 };
const int dc[4] = { 1,-1,0,0 };
void dfs(int r0, int c0)//从(r0,c0)扩展搜索连通图
{
	visit[r0][c0] = 1;
	for (int k = 0; k < 4; k++)//四个方向
	{
		int rx = r0 + dr[k], cx = c0 + dc[k];
		if (rx >= 0 && rx < r && cx >= 0 && cx < c
			&& a[rx][cx] && visit[rx][cx] == 0)
            //如果不越界，且仍然是'#'，且没有搜索过
		{
        	//更新
			cnt++;
			rmin = min(rmin, rx);
			rmax = max(rmax, rx);
			cmin = min(cmin, cx);
			cmax = max(cmax, cx);          
			dfs(rx, cx);//深搜
		}
	}
}
int main()
{
	scanf("%d %d", &r, &c);
	for (int i = 0; i < r; i++)
	{
		char str[1005];
		scanf("%s", str);
		for (int j = 0; j < c; j++)
			a[i][j] = str[j] == '#' ? true : false;
	}//读入
	memset(visit, 0, sizeof(visit));
	int ans = 0;//有几条船
	for (int i = 0; i < r; i++)
		for (int j = 0; j < c; j++)
			if (a[i][j] && visit[i][j] == 0)
			{
				rmin = rmax = i;
				cmin = cmax = j;
				cnt = 1;//开始新一轮连通图搜索，预置初值
				dfs(i, j);
				if (cnt != (cmax - cmin + 1) * (rmax - rmin + 1))
				{	//不是矩形，直接结束程序
					printf("Bad placement");
					return 0;
				}
				ans++;
			}
	printf("There are %d ships", ans);
	return 0;
}
```
***
45ms，2.41MB

第一篇题解，希望大家喜欢

来自一个没参加过OI，水平够不上ACM，天天在洛谷刷红橙黄绿题，计算概论被吊打的CS专业大一蒟蒻

学弟学妹们一定要好好学竞赛！



---

## 作者：梦里调音 (赞：4)

我jio得我的思路是最奇葩的。

方法：

# 标记+DFS+检查

一开始被一个点卡死了，大概这这样：


	###
	#.#
	###

好的，这里并没有船。

可以回去改代码了(ˉ▽￣～)

首先，我们要明白：

船一定是矩形！

这里是重点。

我们可以据此判定是否要输出Bad placement.

这里引入一个思路：

## 边界点

即长方形顶点，这里是突破口！

但按照我的方法：

```
#include <bits/stdc++.h>
using namespace std;
int n,m,ans=0;
char a[1001][1001];
bool tag[1001][1001];
int px[]={0,0,0,-1,1},py[]={0,1,-1,0,0};
int ux[5],uy[5],un;
void se(int x,int y){
    tag[x][y]=1;
    int k=0;
    for(int i=1;i<=4;i++){
        if(a[x+px[i]][y+py[i]]=='.'){
            k++;
            if(i==2||i==4){
                if(a[x+px[i-1]][y+py[i-1]]=='.')k--;
            }
        }
        else if(tag[x+px[i]][y+py[i]]==0&&x+px[i]>0&&x+px[i]<=n&&y+py[i]>0&&y+py[i]<=m)se(x+px[i],y+py[i]);
    }
    if(k>=2)ux[un]=x,uy[un++]=y;
    if(un>4){
        cout<<"Bad placement.";
        exit(0);
    }
    return;
}
int main(void){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int i=0;i<=m+1;i++)a[0][i]=a[n+1][i]='.';
    for(int i=0;i<=n+1;i++)a[i][0]=a[i][m+1]='.';
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]=='#'&&tag[i][j]==0){
                un=0;
                memset(ux,0,sizeof(ux));
                memset(uy,0,sizeof(uy));
                ans++;
                se(i,j);
                if(un%2==1&&un!=1){
//					cout<<i<<" "<<j<<" "<<un<<endl;
                    cout<<"Bad placement.";
                    return 0;
                }
            }
    cout<<"There are "<<ans<<" ships.";
    return 0;
}
```
并不能排除掉这种情况！！！


那么，我们在确认每条船是长方形时，

还要再过一遍，确认内部都是#

```
int check(){
	for(int i=ux[1];i<=ux[un];i++)
		for(int j=uy[1];j<=uy[un];j++)
		if(a[i][j]!='#'){
			ans--;
			c++;
			return 0;
		}
	return 0;
}
```
我们要加上这一段。

变量c的作用：看看是否查过船的实心性（暂且这么叫吧qwq）

	此时，如果ans==0：

		如果c==0，则说明是空海

		否则，说明有船但不合要求。

嗯！就是这样！

AC代码（包括完整思路）：

```
#include <bits/stdc++.h>
using namespace std;
int n,m,ans=0;
int c;
char a[1001][1001];
bool tag[1001][1001];
int px[]={0,0,0,-1,1},py[]={0,1,-1,0,0};//上下左右
int ux[5],uy[5],un;//边界点x、y坐标和个数
int check(){//检查船是否空心
	for(int i=ux[1];i<=ux[un];i++)
		for(int j=uy[1];j<=uy[un];j++)
		if(a[i][j]!='#'){
			ans--;
			c++;
			return 0;
		}
	return 0;
}
void se(int x,int y){//dfs
	tag[x][y]=1;//标记
	int k=0;
	for(int i=1;i<=4;i++){
		if(a[x+px[i]][y+py[i]]=='.'){//看看是否是船的边界点
			k++;
			if(i==2||i==4){//上下/左右的相互对应需要取消
				if(a[x+px[i-1]][y+py[i-1]]=='.')k--;
			}
		}
		else if(tag[x+px[i]][y+py[i]]==0&&x+px[i]>0&&x+px[i]<=n&&y+py[i]>0&&y+py[i]<=m)//判断是否出界、走过
        se(x+px[i],y+py[i]);
	}
	if(k>=2)ux[++un]=x,uy[un]=y;//拓展边界点
	if(un>4){//多边形则错误
		cout<<"Bad placement.";
		exit(0);
	}
	return;
}
int main(void){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=0;i<=m+1;i++)a[0][i]=a[n+1][i]='.';
	for(int i=0;i<=n+1;i++)a[i][0]=a[i][m+1]='.';//在边界加上一道海
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]=='#'&&tag[i][j]==0){
				un=0;
				memset(ux,0,sizeof(ux));//初始化
				memset(uy,0,sizeof(uy));
				ans++;
				se(i,j);//开始dfs
				sort(ux+1,ux+un+1);//排序，找到左上的和右下的边界点
				sort(uy+1,uy+un+1);
				check();//检查
				if(un%2==1&&un!=1){//单数个（1除外）个边界点明显不合要求
					cout<<"Bad placement.";
					return 0;
				}
			}
	if(ans==0&&c!=0)cout<<"Bad placement.";//没船但查过
	else cout<<"There are "<<ans<<" ships.";//空海或有合格的船
	return 0;
}
```

总结：

重点：

1、加海

2、DFS（这个很简单，但要在其中数边界点）

3、复查

---

## 作者：Amphetamine (赞：3)

这道题和单纯的dfs搜块数的差别在于，如果两个非矩阵连接则判定非法。

如果知道判断方法，这道题就变得简单了。

思路如下

用x1,y1记下起始点，x2,y2记下搜索最远的点，s记下搜索的步数（面积）；

若（x2-x1+1）\*（y2-y1+1）！=s 则为非法；

下面是代码

···
```cpp
#include<iostream>
using namespace std;
int a[1001][1001];
int r,c;
int x1,y1,x2,y2,s=0,ans=0;
int dfs(int x,int y){
    if(x<x1||y<y1){
        s=-1; // 因为是从上向下，从左向右搜索，所以如果左面或者上面有没搜到的一定是错误
        return 0;
    }
    a[x][y]=0;
    s++;
    if(x>x2)x2=x;
    if(y>y2)y2=y;
    if(x-1>=1&&a[x-1][y]==1)dfs(x-1,y);
    if(y-1>=1&&a[x][y-1]==1)dfs(x,y-1);
    if(x+1<=r&&a[x+1][y]==1)dfs(x+1,y);
    if(y+1<=c&&a[x][y+1]==1)dfs(x,y+1);
}
int main(){
    int pd=0;
    cin>>r>>c;
    char ship;
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            cin>>ship;
            if(ship=='#')a[i][j]=1;
            else a[i][j]=0;
        }
    }
    for(int i=1;i<=r;i++){
        if(pd==1)break;
        for(int j=1;j<=c;j++){
            if(a[i][j]==1){
                x1=i;y1=j;
                x2=i;y2=j;
            dfs(i,j);
            if(s!=(x2-x1+1)*(y2-y1+1)||s==-1){
                cout<<"Bad placement.";
                pd=1;
                break;
            }
            s=0;
            ans++;
            }
        }
    }
    if(pd==0)cout<<"There are "<<ans<<" ships.";
    return 0;
}
···
```

---

## 作者：MloVtry (赞：3)

相当暴力的dfs搜索

枚举地图，遇到一个点是“#”，就可以扩展出这个矩形的宽度，然后作为一个参量[k]传进dfs里，随后认为这个位置是左上角(h,l)开始搜索下面的行

从左上角的列开始计数，如果是0，那么可以认为这个矩形结束了，return；不然的话，如果统计出来的长度不是k，则一定或少或多，反正延伸的情况不同，Bad

这样我们处理了右侧的情况，最后再加上if判断左侧：如果某一行(h1,l-1)处有‘#’，那么也是相交的Bad情况...

代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,ans;
char map[1010][1010];
void dfs(int h,int l,int k)
{
    int js=0;
    for(int i=l;i<=m;++i)
    {
        if(map[h][i]=='#') js++,map[h][i]='.';
        else break;
    }
    if(js==0) return;
    if(map[h][l-1]=='#')
    {
        cout<<"Bad placement.";
        exit(0);
    }
    if(js==k) dfs(h+1,l,k);
    else
    {
        cout<<"Bad placement.";
        exit(0);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            cin>>map[i][j];
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            if(map[i][j]=='#')
            {
                int js=0;
                for(int h=j;h<=m&&map[i][h]=='#';++h)
                {
                    js++;
                }
                ans++;
                dfs(i,j,js);
            }
        }
    }
    printf("There are %d ships.",ans);
    return 0;
}
```

---

## 作者：Youngsc (赞：3)

[Youngsc](http://youngscc.github.io/)

统计数量其实不用DFS的。

首先遍历每一个交叉点，所谓交叉点就是四个字符的中心，然后看这个点相邻的四个点中是否有3个#和一个\*，如果有的话，则当前一定有方形挨着了。通过这些来判断"Bad placement"；

关于统计数目，我们已经知道所有的图形都是矩形的了，那么很容易想到统计**所有矩形左上角的个数**，因为一个矩形只有一个左上角，然后就能输出答案了。

## 代码 is here


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long

using namespace std;


int n,m,ans;
char s[1010][1010];

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline int youngsc(){
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(R int i=1; i<=n; ++i) scanf("%s",s[i]+1);
    for(R int i=1; i<n; ++i)
        for(R int j=1; j<m; ++j)
        {
            R int a1=0,a2=0;
            for(R int p=0; p<=1; ++p)
                for(R int q=0; q<=1; ++q)
                    if(s[i+p][j+q] == '#') a1++;
                    else a2++;
            if(a1==3&&a2==1) printf("Bad placement"),exit(0);
        }
    for(R int i=1; i<=n; ++i)
        for(R int j=1; j<=m; ++j)
            if(s[i][j] == '#'&&s[i-1][j] != '#'&&s[i-1][j-1] != '#'&&s[i][j-1] != '#') ans++;
    printf("There are %d ships",ans);
}

int yg = youngsc();
int main(){;}
```
不要复制，你会后悔的。

（减少代码复制，共创美好洛谷）


---

## 作者：lsilencej (赞：2)

题目:[海战](https://www.luogu.org/problemnew/show/P1331)

这是一道经典的搜索题，广搜深搜都可以做~~（广搜代码长，不想打）~~，其实只需要加四个变量分别记下排列的长和宽即可，如果最长的长和最长的宽围成的长方形内都被访问过，则该长方形内都为‘#’，即没有两船相邻的情况，下面是深搜的代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int ll, rr, u, d, cnt, r, c;//u为上，d为下，ll为左，rr为右
char hai[1100][1100];//方向数组
int vis[1100][1100];
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};
void dfs(int x, int y) {
	for (int i = 0; i <= 3; i++) {
		int nx = x + dx[i];
		int ny = y + dy[i];
		if (nx < 0 || nx >= r || ny < 0 || ny >= c) continue;
		if (hai[nx][ny] == '#' && !vis[nx][ny]) {
			vis[nx][ny] = 1;
			ll = min(ll, ny);
			rr = max(rr, ny);
			u = min(u, nx);
			d = max(d, nx);
			dfs(nx, ny);
		}
	}
}
int check() {
	for (int i = u; i <= d; i++) {
		for (int j = ll; j <= rr; j++) {
			if (!vis[i][j]) return 1;//若一个点未被访问过，即两船相邻
		}
	}
	return 0;
}//检查长方形内部的点是否被访问过
int main()
{
	scanf("%d%d", &r, &c);
	for (int i = 0; i < r; i++) {
		cin >> hai[i];
	}
	for (int i = 0; i < r; i++) {
		for (int j = 0; j < c; j++) {
			if (hai[i][j] == '#' && !vis[i][j]) {
				cnt++;
				vis[i][j] = 1;
				ll = rr = j;
				u = d = i;
				dfs(i, j);
				if (check()) {
					printf("Bad placement.");
					return 0;
				}
			}
		}
	}
	printf("There are %d ships.", cnt);
	return 0;
}
```

---

## 作者：doby (赞：2)

我好像真的忘了当时是怎么想的了……

理论上是每次都选定了一个矩阵，根据这个矩阵里的情况判断是否有船相邻……

```cpp
#include<iostream>
using namespace std;
int n,m,a[1000][1000],ans=0;
char c;
int sss(int x,int y)
{
    int q,w,e,r,pd=0;
    for(q=x;q<n;q++){if(a[q][y]==0){break;}}//选定矩阵……
    for(w=y;w<m;w++){if(a[x][w]==0){break;}}
    for(e=x;e<=q;e++){for(r=y;r<=w;r++){if(a[e][r]){pd++;}a[e][r]=0;}}//判断选定矩阵中是否都是船
    if(pd!=(q-x)*(w-y)){return 0;}//如果不相等，说明有船~~相撞~~相邻
    return 1;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++){for(int j=0;j<m;j++){cin>>c;if(c=='.'){a[i][j]=0;}if(c=='#'){a[i][j]=1;}}}
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(a[i][j]){if(sss(i,j)){ans++;}else{cout<<"Bad placement.";return 0;}}//其实没什么了……
        }
    }
    cout<<"There are "<<ans<<" ships.";//这格式真麻烦……该用printf……
}
```

---

## 作者：s_r_f (赞：2)

这道题目，我们可以用bfs的方法。

每发现一个‘#’号，就对这一块进行宽搜。

宽搜时，我们维护maxx, maxy,minx,miny 。

由于一个矩形的期望面积 为 (maxx - minx + 1) \* (maxy - miny + 1) ,所以我们可以把搜到的‘#’ 个数和这个值做一下比较。


程序：

```cpp
#include<bits/stdc++.h>
#define maxm 1000
#define maxt 1000000
using namespace std;
int n,m,ans,i,j,k,nx,ny,l,r,minx,miny,maxx,maxy;
int dx[5]={0,-1,0,1,0},dy[5]={0,0,1,0,-1};
int h[ maxm+5][ maxm+5],x[maxt+5],y[maxt+5]; // 搜索队列
char a[ maxm+5][ maxm+5];
int main()
{
    cin>>n>>m;
    ans=0;
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
      {
          cin>>a[i][j];
          if(a[i][j]=='#') h[i][j]=1;
      }
  // 读入
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
      {
          if(h[i][j]==1)
          {
              ans++;//累计答案
            h[i][j]=0;
            l=1;
              r=1;
              minx=i;
              maxx=i;
              miny=j;
              maxy=j;
              x[1]=i;
              y[1]=j;
              while(l<=r)//宽搜
              {
                  for(k=1;k<=4;k++)
                  {
                      nx=x[l]+dx[k];
                    ny=y[l]+dy[k];
                    if(h[nx][ny]==1)
                    {
                        h[nx][ny]=0;
                        minx=min(minx,nx);
                        miny=min(miny,ny);
                        maxx=max(maxx,nx);
                        maxy=max(maxy,ny);
                        r++;
                        x[r]=nx;
                        y[r]=ny;
                    }    
                  }
                  l++;
              } 
              if(r!=((maxx-minx+1)*(maxy-miny+1))){ //判断是否合法
                cout<<"Bad placement."<<endl; return 0;// 程序退出
              }
          }
      }
    cout<<"There are "<<ans<<" ships."<<endl; //输出结果
    return 0;
}
```

---

## 作者：dengwenjun (赞：1)

## 我是先写了[P1451 求细胞数量](https://www.luogu.org/problem/P1451)那道题才来A这道的
所以愚蠢的我直接把
```cpp
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char shu;
			cin>>shu;
			if(shu>='1')
			  b[i][j]=2;
			else
			  b[i][j]=1;
		}
	}
    ~~
cout<<cnt;
```
改成了
```cpp
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char shu;
			cin>>shu;
			if(shu=='#')
			  b[i][j]=2;
			else
			  b[i][j]=1;
		}
	}
    ~~
cout<<"There are "<<cnt<<" ships.";
```
##### 然后一交——63分
emm，好吧我承认我没看题
仔细一看，woc，居然还要判断矩形  
#### 然后我就~~机智~~的进行了染色，如果一位置与其四角的颜色相同但是与四周的颜色不同，那肯定是摆错了
（~~垃圾军校，这都能错~~）
### 最后的完整版
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 5001
#define ll long long
#define re register
int b[maxn][maxn];
int n,m;
void find(int x,int y,int se)//扩展式搜索
{
	b[x][y]=se;//染色(se)
	if(b[x+1][y]==2)  find(x+1,y,se);
	if(b[x-1][y]==2)  find(x-1,y,se);
	if(b[x][y+1]==2)  find(x,y+1,se);
	if(b[x][y-1]==2)  find(x,y-1,se);
}
int main()
{
	memset(b,0,sizeof(b));//好习惯？
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char shu;
			cin>>shu;
			if(shu=='#')
			  b[i][j]=2;
			else
			  b[i][j]=1;
		}//输入处理
	}
	int cnt=0;//船的数量
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(b[i][j]==2)
			{
				int zz=4;
				find(i,j,zz);
				cnt++;//船数累加
				zz++;//颜色累加emm
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(b[i][j]>2)
			{
				if(b[i][j]==b[i+1][j+1]&&b[i][j]!=b[i+1][j])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i+1][j+1]&&b[i][j]!=b[i][j+1])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i+1][j-1]&&b[i][j]!=b[i+1][j])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i+1][j-1]&&b[i][j]!=b[i][j-1])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j-1]&&b[i][j]!=b[i-1][j])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j-1]&&b[i][j]!=b[i][j-1])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j+1]&&b[i][j]!=b[i][j+1])
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j+1]&&b[i][j]!=b[i-1][j])
				{
					cout<<"Bad placement.";
					return 0;
				}
			}
		}
	}
   //以上特判摆错的情况
	cout<<"There are "<<cnt<<" ships.";//输出船
	return 0;//华丽的结尾
}
```
其实上面的摆错特判可以改成这样来减少代码量
```cpp
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(b[i][j]>2)
			{
				if(b[i][j]==b[i+1][j+1]&&(b[i][j]!=b[i+1][j]||b[i][j]!=b[i][j+1]))
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i+1][j-1]&&b([i][j]!=b[i+1][j]||b[i][j]!=b[i][j-1]))
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j-1]&&(b[i][j]!=b[i-1][j]||b[i][j]!=b[i][j-1]))
				{
					cout<<"Bad placement.";
					return 0;
				}
				if(b[i][j]==b[i-1][j+1]&&(b[i][j]!=b[i][j+1]||b[i][j]!=b[i-1][j]))
				{
					cout<<"Bad placement.";
					return 0;
				}
			}
		}
	}
```
### 以上的特判是本题的最大考点,（~~雾~~），一定要知道
其实通过画图就可以得出来，我看其他大佬的题解都画了图，但是我比较懒，就算了。emmm
### 最后附上[AC记录](https://www.luogu.org/record/26255877)
### 写题解攒人品，CSP2019RP++；

---

## 作者：yzxoi (赞：1)

# [题目传送门](https://www.luogu.org/problemnew/show/P1331)
# 思路
## 肯定食用dfs啦。。。
## 但关键是两条船接触了怎么判断呢？？
### 上图：
![](https://cdn.luogu.com.cn/upload/pic/46248.png)
### 可以发现一下规律
### 当两条船接触时，必有一条直线连续穿过两条船
### 当一条船不与另一条船接触时，没有一条直线连续穿过两条船
## 所以只需要在每一次碰见一条船的一部分（一条船内每个点都要拓展一遍）时，将其沿右上、左下分别拓展一遍，边拓展边用sum前缀和check一遍就好啦。。。。
## 核心代码：
```C++
//码风很丑，勿喷
int k=1;
while(a[i+k][j+k]==1) k++;//找到最左下的一个点（即连线段的另一个端点）
--k;//别忘了再加回来
int hh=sum[i+k][j+k]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1];//前缀和
++k;
if(hh<k*k){//前缀和必须是k*k（一个正方形）
	puts("Bad placement.");
	return 0;//强制结束
}//沿右上
k=1;//清零
while(a[i+k][j-k]==1) ++k;//找到最左下的一个点（即连线段的另一个端点）
--k;
hh=sum[i+k][j]-sum[i-1][j]-sum[i+k][j-k-1]+sum[i-1][j-k-1];//前缀和
++k;//别忘了再加回来
if(hh<k*k){//前缀和必须是k*k（一个正方形）
	puts("Bad placement.");
	return 0;//强制结束
}//沿左下
```
# 如果没有接触的话，可以直接dfs啦。。。代码简洁：
```C++
void dfs(int x,int y){
	if(vis[x][y]==1) return ;//如果已经拓展过直接退出
	vis[x][y]=1;//标记
	if(a[x][y+1]==1) dfs(x,y+1);//向四个方向拓展，标记为此船
	if(a[x-1][y]==1) dfs(x-1,y);
	if(a[x+1][y]==1) dfs(x+1,y);
	if(a[x][y-1]==1) dfs(x,y-1);
}
```
# 所有代码：（非常“简洁”。。。）
```C++
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
	while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//丑陋的读优
void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return ;
	}
	if(x<10) putchar(x+'0');
	else{
		write(x/10);
		putchar(x%10+'0');
	}
}//丑陋的输优
int n,m,a[1010][1010],sum[1010][1010];
int vis[1010][1010],ans;
void dfs(int x,int y){
	if(vis[x][y]==1) return ;
	vis[x][y]=1;
	if(a[x][y+1]==1) dfs(x,y+1);
	if(a[x-1][y]==1) dfs(x-1,y);
	if(a[x+1][y]==1) dfs(x+1,y);
	if(a[x][y-1]==1) dfs(x,y-1);
}//丑陋的dfs
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char ch;cin>>ch;
			if(ch=='#') a[i][j]=1;
		}
	}//读入
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		}
	}//前缀和
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==1){
				int k=1;
				while(a[i+k][j+k]==1) k++;
				--k;
				int hh=sum[i+k][j+k]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1];
				++k;
				if(hh<k*k){
					puts("Bad placement.");
					return 0;
				}
				k=1;
				while(a[i+k][j-k]==1) ++k;
				--k;
				hh=sum[i+k][j]-sum[i-1][j]-sum[i+k][j-k-1]+sum[i-1][j-k-1];
				++k;
				if(hh<k*k){
					puts("Bad placement.");
					return 0;
				}
			}//不想再提了。。。判断船只是否接触
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==1&&vis[i][j]==0){
				++ans;
				dfs(i,j);
			}//dfs统计答案
		}
	}
	cout<<"There are ";
	write(ans);
	cout<<" ships.";putchar('\n');//输出
	return 0;//结束。。。。
}
/*************************
用时: 102ms / 内存: 5152KB
代码：1.63KB C++
By yuzhengxi
**************************/
```

---

## 作者：SIGSEGV (赞：1)

典型染色搜索求联通块，问题是怎样才能判断Bad placement?

以联通块最左上角的地方作为矩阵的左上角，然后计算矩形长宽（假设它是矩形），在由左上角，长，宽(left,top,width,height)构成的矩形里判断。

如果矩形中有一个不是相应颜色的（或者是海洋的），那么直接KO，否则，判断这个矩阵的面积和染色面积的区别，如果不一样那么就goodbye了，否则ans++；最后如果没有挂就输出ans。

似乎该上代码了：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,dx[] = {1,0,-1,0},dy[] = {0,1,0,-1},clr[1005][1005],ans,cnt[1000005];
char a[1005][1005];
bool vis[1000005];
void dfs(int x,int y,int clnum)//位置和颜色
{ 
	clr[x][y] = clnum;++cnt[clnum];//有几个方块染这个颜色，就是染色面积
	for (int i = 0;i < 4;i++)
	{
		int nx = x + dx[i],ny = y + dy[i];
		if (nx < 0 || ny < 0 || nx >= n || ny >= m 
				   || clr[nx][ny] || a[nx][ny] == '.') continue;//出界
		dfs(nx,ny,clnum);
	}
}
int main ()
{
	scanf("%d%d",&n,&m);
	for (int i = 0;i < n;i++) scanf("%s",a[i]);
	int clnum = 0;
	for (int i = 0;i < n;i++)
		for (int j = 0;j < m;j++)
			if (clr[i][j] == 0 && a[i][j] == '#') dfs(i,j,++clnum);//染色标配，海洋颜色为0
	for (int i = 0;i < n;i++)
		for (int j = 0;j < m;j++)
		{
			if (clr[i][j] == 0 || vis[clr[i][j]]) continue;//vis：是不是左上角？
			int l = 0,w = 0;
			while (clr[i + l][j] == clr[i][j] && i + l < n) ++l;/计算长
			while (clr[i][j + w] == clr[i][j] && j + w < m) ++w;//计算宽
			bool valid = 1;
			for (int k = 0;k < l;k++)
				for (int o = 0;o < w;o++)
					if (clr[k + i][o + j] == 0)
					{
						valid = 0;break;//KO
					}
			valid = valid && (cnt[clr[i][j]] == l * w);//goodbye
			if (!valid)
			{
				printf("Bad placement.");return 0;//直接退出
			}		
			ans++;
			vis[clr[i][j]] = 1;//左上角被用了
		} 
	printf("There are %d ships.",ans);
	return 0;
}
```

---

## 作者：deamoon_2 (赞：1)

dfs和bfs什么的最讨厌了，这题数据不大，模拟他不香吗？

### 本题做法：模拟（含dfs思想）

就这么简单，按照常人的思路来就行啦qwq。

思路：从矩阵左上角开始往右下搜，如果出现船只一个部分，那么会出现以下四种情况，其他则为船只相互接触则输出Bad placement.

1.点形

. . .

. # .

. . .

判断很简单，只需判断右面和下面有没有其他船只（上面和左边循环的时候判断过了）。

2.横形

. . . . .

.###.

. . . . . 

先看右边有没有其他船只，若有，则一直向右寻找，同时判断下方与上方（上方是数据点10的坑）是否有其他船只部分（若有则说明船只相互接触），直到没有。

3.竖形

. . .

.#.

.#.

.#.

. . .

先看下边有没有其他船只，若有，则一直向下寻找，同时判断左边与右边（左边是数据点1的坑）是否有其他船只部分（若有则说明船只相互接触），直到没有。

4.方形

. . . .

.##.

.##.

. . . .

先看下边和右边有没有其他船只，若有，则一直向下和向右寻找其他船只部分，同时累计数值，作为判断的方形的长和宽，然后在范围内进行判断，若存在一点不为船只部分，则说明船只相互接触。

#### 每判断完一种可能，s++，同时把判断中的船只部分变回水，防止之后误判。

亮代码（代码中含更多注释请仔细思考）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,k;
int a[1001][1001];//用二维数字数组储存矩阵，0为水，1为船只部分
long long s;（船只数）
int main()
{
	char c;
	int x;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='#')
			a[i][j]=1;
		}
	}//输入
	/*for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}检查输入的矩阵*/
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int t=0;//表示情况
			if(a[i][j]==1)//a[i][j]处为船只部分
			{
				if(a[i][j+1]==1)//右边有船只
				t=1;
				if(a[i+1][j]==1)//下边有船只
				t+=2;
			}
			else//不是船只部分则跳过
			continue;
			x=0; //记录是否两艘船相互接触
			if(t==0)//点形
			{
				s++;
				//cout<<i<<' '<<j<<endl;检查船只位置
				continue;
			}
			else if(t==1)//横形
			{
				for(int l=j+1;l<=m;l++)
				{
					if(!a[i][l])
					break;//船只部分结束跳出
					else if(a[i-1][l]==1||a[i+1][l]==1)//若上边或下边有其他船只部分
					{
						x=1;
					}
					a[i][l]=0;//判断过了，船只部分变为水
				}
			}
			else if(t==2)//竖形
			{
				for(int l=i+1;l<=n;l++)
				{
					if(!a[l][j])
					break;//船只部分结束跳出
					else if(a[l][j+1]==1||a[l][j-1]==1)//若左边或右边有其他船只部分
					{
						x=1;
					}
					a[l][j]=0;//判断过了，船只部分变为水
				}
			}
			else if(t==3)//方形
			{
				int e=1,f=1;//方形的长与宽
				for(int l=j+1;l<=m;l++)
				{
					if(!a[i][l])
					break;
					else//找长
					f++;
				}
				for(int l=i+1;l<=n;l++)
				{
					if(!a[l][j])
					break;
					else//找宽
					e++;
				}
				for(int l=i;l<=e+i-1;l++)//注意要-1,不然多判断一格，下面也是如此
				{
					for(int r=j;r<=f+j-1;r++)
					{
						if(!a[l][r])//如果有水
						{
							x=1;//两艘船相互接触
							break;
						}
						a[l][r]=0;//判断过了，船只部分变为水
					}
				}
			}
			if(x==1)
			break;
			s++;
			//cout<<i<<' '<<j<<endl;检查船只位置
		}
		if(x==1)
		break;
	} 
	if(x==1)//若出现船只相互接触的情况
	cout<<"Bad placement.";
	else
	cout<<"There are "<<s<<" ships.";
	return 0;
}
```

## 共同维护洛谷良好学习环境，杜绝抄袭！

2019 CSP RP++

---

## 作者：chenlingxi (赞：1)

# 暴力大法好！！！


------------

### 讲解开始

题干上说了仅考虑方形的船

那么是不是可以用一个叫做while的东西来框边捏

答案是是滴

~~无视以上很无聊的东西~~

------------

## 讲解正式开始

如果选定一个矩形，其边缘和内部均为#

且周围一圈都不是#

那么说明这艘船是方形，且不与其他点重合

几个细节见代码注释

先来一发纯代码

~~为抄题解人士准备~~

备注：此处少了一句不影响你谷AC的判定
```cpp
#include<bits/stdc++.h>
using namespace std;
char c[1005][1005];
bool vis[1005][1005];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	  cin>>c[i][j];
	int ans=0;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	  {
	  	if(vis[i][j])continue;
	  	if(c[i][j]=='#')
	  	{
	  		int k=i,l=j,o=i-1,p=j-1;
	  		while(c[k][j]=='#')k++;
	  		while(c[i][l]=='#')l++;
	  		for(int q=o;q<=k;++q)
	  		  for(int r=p;r<=l;++r)
	  		  {
	  		  	if(q>o&&q<k&&r>p&&r<l)
	  		  	{
	  		  		if(c[q][r]!='#')
	  		  		{
	  		  			cout<<"Bad placement.";
	  		  			return 0;
	  		  		}
	  		  		vis[q][r]=1;
	  		  	}
	  		  	else
	  			if(c[q][r]=='#')
	  			{
	  				cout<<"Bad placement.";
	  				return 0;
	  			}
	  		  }
	  		ans++;
	  	}
	  }
	printf("There are %d ships.",ans);
}
```


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[1005][1005];
bool vis[1005][1005];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	  cin>>c[i][j];
	int ans=0;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	  {
	  	if(vis[i][j])continue;
		//判定有没有扫过，被扫过的船就不用再扫了
	  	if(c[i][j]=='#')//如果扫到没有标记的点
	  	{
	  		int k=i,l=j,o=i-1,p=j-1;
            //这个点肯定是左上角的
            //原因自己想
	  		while(c[k][j]=='#')k++;
	  		while(c[i][l]=='#')l++;
            //框定矩形范围
	  		for(int q=o;q<=k;++q)//判定
	  		  for(int r=p;r<=l;++r)
	  		  {
                //漏了一句
                //矩形外四个角能算
                //然而这句话加不加无所谓
                //因为数据太水
                //别问我怎么知道的
                //因为交的时候没想到
                //写题解才想到了这个问题
                //然而还是AC了
                //所以如果这是CF赛制
                //你们知道的
	  		  	if(q>o&&q<k&&r>p&&r<l)
                //矩形内及边缘的点
	  		  	{
	  		  		if(c[q][r]!='#')
	  		  		{
	  		  			cout<<"Bad placement.";
	  		  			return 0;
	  		  		}
	  		  		vis[q][r]=1;
	  		  	}
	  		  	else
                //边缘外一圈的点
	  			if(c[q][r]=='#')
	  			{
	  				cout<<"Bad placement.";
	  				return 0;
	  			}
                //两个微不足道的剪枝
                //或者说是判定条件
	  		  }
	  		ans++;//如果符合说明这是一条船
	  	}
	  }
	printf("There are %d ships.",ans);//输出
}
```


---

## 作者：Idoyt (赞：0)

**枚举每一个点**，因为1<=R,C<=1000，所以完全不怂，直接枚举，因为我们是从左上角开始枚举的，所以每次枚举到一个#时，必然我们枚举到的是这艘船的最上面（左上角）的#，可以找出这个矩形的长(xi-x)宽(yi-y)，然后枚举这个矩形，统计cnt（#的数量），当cnt=(xi-x)*(yi-y)时，就可以判定这艘船合法了。

附上代码，小心有坑。
```
#include<bits/stdc++.h>
using namespace std;
char mp[1001][1001];
bool vis[1001][1001];
int n,m,ans,flag;
void work(int x,int y)
{
	int xi=x,yi=y,cnt=0;
	while(mp[xi][y]=='#')xi++;
	while(mp[x][yi]=='#')yi++;
	for(int i=x;i<=xi;i++)
	 for(int j=y;j<=yi;j++)
	 { 	
	 	if(mp[i][j]=='#'&&vis[i][j]==0)cnt++;
		vis[i][j]=1;
	 }
	if(cnt==(xi-x)*(yi-y))ans++;
	else flag=1;
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);//加速cin,cout
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	 cin>>mp[i][j];
	 
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	 {
	 	if(flag==1)break;
	 	if(flag!=1&&mp[i][j]=='#'&&vis[i][j]==0)work(i,j);
	 }
	 if(flag==1)cout<<"Bad placement.";
	 else cout<<"There are "<<ans<<" ships.";
	 return 0;
}
```

---

## 作者：圣光天子 (赞：0)

首先看只有矩形才能算作一艘船，也就是说，如果这个图是合法的，那么里面的每一个连通块都是矩形。
然后开始搜，将每一个搜到的连通块的最小、最大横纵坐标记录，那么两点之间一定可以形成一个囊括该连通块的矩形，且如该连通块为矩形，该矩形与连通块重合。然后再check一遍该矩形内是否全为‘#’，则可判定是否有船相接触。(好吧写的有点乱)
代码

```pascal
program hz;
type wz=record x,y:longint; end;
const yd:array[1..4,1..2] of longint=((1,0),(0,1),(-1,0),(0,-1));
var
  a,b:array[0..1001,0..1001] of boolean;
  k:array[1..1000000] of wz;
  dl:array[1..1000000] of wz;
  now,min,max:wz;
  n,m,t,i,j,head,tail,ans:longint; g:char; gg:boolean;
function check(x1,y1,x2,y2:longint):boolean;//检查船只接触
var i,j:longint;
begin
  check:=true;
  for i:=x1 to x2 do
    for j:=y1 to y2 do
      if not(b[i,j]) then exit(false);
end;
begin
  readln(n,m);
  fillchar(a,sizeof(a),false);
  fillchar(b,sizeof(b),false);
  for i:=1 to n do begin
    for j:=1 to m do begin
      read(g);
      if g='.' then a[i,j]:=false
      else begin
        a[i,j]:=true;
        b[i,j]:=true;
        inc(t); k[t].x:=i; k[t].y:=j;
      end;
    end;
    readln;
  end;
  gg:=false;
  for i:=1 to t do begin//对每个连通块进行bfs
    if a[k[i].x,k[i].y] then begin
      head:=0; tail:=1; dl[1].x:=k[i].x; dl[1].y:=k[i].y;
      min.x:=maxlongint; min.y:=maxlongint;
      max.x:=0; max.y:=0;
      repeat
        inc(head); a[dl[head].x,dl[head].y]:=false;
        if dl[head].x>max.x then max.x:=dl[head].x;
        if dl[head].y>max.y then max.y:=dl[head].y;
        if dl[head].x<min.x then min.x:=dl[head].x;
        if dl[head].y<min.y then min.y:=dl[head].y;
        for j:=1 to 4 do begin
          if a[dl[head].x+yd[j,1],dl[head].y+yd[j,2]] then begin
            inc(tail);
            dl[tail].x:=dl[head].x+yd[j,1];
            dl[tail].y:=dl[head].y+yd[j,2];
            a[dl[tail].x,dl[tail].y]:=false;
          end;
        end;
      until head=tail;
      if check(min.x,min.y,max.x,max.y) then inc(ans)
      else begin gg:=true; break; end;
    end;
  end;
  if gg then writeln('Bad placement.')
  else writeln('There are ',ans,' ships.');
end.


```

---

## 作者：ww3113306 (赞：0)

其实，，往下数第一个题解判断非法的办法其实是不准确的，会漏掉一些情况

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;char s[1100][1100];bool z=false;int a[5]={0,-1,0,0,1},b[5]={0,0,1,-1,0},can[1100][1100];
void dfs(int x,int y)
{
    int i;
    if((s[x][y]+s[x][y+1]+s[x+1][y]+s[x+1][y+1])==151||(s[x][y]+s[x-1][y-1]+s[x-1][y]+s[x][y-1])==151||(s[x-1][y]+s[x-1][y+1]+s[x][y+1]+s[x][y])==151||(s[x][y]+s[x][y-1]+s[x+1][y-1]+s[x+1][y])==151) z=true;//我不知道几个才够，反正一个肯定是不行的，因为我自己找到了反例，不知道楼下题解怎么过的，至于这里的151怎么来的，其实是ascll码
    if(z) return;//如果是非法的，就不用搜了
    can[x][y]++;//这个数组记录有没有被搜过，如果没有这个数组就会陷入死循环，。大概是1到2，2到1，1到2，2到1这样的
    for(i=1;i<=4;i++)
    {
        if(s[x+a[i]][y+b[i]]=='#'&&!can[x+a[i]][y+b[i]])dfs(x+a[i],y+b[i]);//如果没搜过并且是船的一部分就继续搜
        if(z) return;    
    }
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    {
        cin>>s[i][1];//一个小技巧，每行第一个字符用cin，这样既省时间又不会读入换行和空格
        for(j=2;j<=m;j++)
            scanf("%c",&s[i][j]);
    }
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
        {
            if(s[i][j]=='#'&&!can[i][j])//没搜过才搜
            {
                dfs(i,j);            
                ans++;
            }
            if(z)//如果非法就直接输出返回了
            {
                printf("Bad placement.");
                return 0;
            }
        }
    printf("There are %d ships.",ans);
    return 0;
}
```

---

## 作者：yyyyyyy (赞：0)

```cpp
//这道题用深搜比较好
var i,j,ans,n,m:longint;
    ch:char;
    a:array[0..1001,0..1001] of boolean;
procedure find(x,y:longint);//深搜过程
begin
a[x,y]:=false;
if a[x+1,y] then find(x+1,y);
if a[x,y+1] then find(x,y+1);
if a[x-1,y] then find(x-1,y);
if a[x,y-1] then find(x,y-1);
end;
begin
readln(n,m);
for i:=1 to n do
    begin
    for j:=1 to m do
        begin
        read(ch);
        if ch='#' then a[i,j]:=true;//读入，#就为true
        end;
    readln;
    end;
for i:=1 to n-1 do
    for j:=1 to m-1 do//判断是不是方形，如果不是，就输出Bad placement.不要忘了一点，我第一次就是这样才WA的
        if ord(a[i,j])+ord(a[i+1,j])+ord(a[i,j+1])+ord(a[i+1,j+1])=3 then
           begin
           write('Bad placement.');
           halt;//退出程序
           end;
for i:=1 to n do
    for j:=1 to m do//找船，并把周围都赋为false
        if a[i,j] then
           begin
           inc(ans);
           find(i,j);
           end;
write('There are ',ans,' ships.');//输出，不要忘了一点
end.
//这道题总来说还是蛮简单的，就是判断方形难一点>_<
```

---

## 作者：睡在墙上的猫 (赞：0)

//先判断题目中船相遇的情况，然后就向四方搜索，遇到#就变 . 然后就知道有几条船了

    
            
```cpp
#include<iostream>
using namespace std;
int n,m,flag[1100][1100],num,s;char c[1100][1100];
void dfs(int x,int y)
{
    if (c[x][y]=='#'&&x>=1&&x<=n&&y>=1&&y<=m) c[x][y]='.';
    else return;
    if (x+1>=1&&x+1<=n&&y>=1&&y<=m) dfs(x+1,y);
    if (x-1>=1&&x+1<=n&&y>=1&&y<=m) dfs(x-1,y);
    if (x>=1&&x<=n&&y+1>=1&&y+1<=m) dfs(x,y+1);
    if (x>=1&&x<=n&&y-1>=1&&y-1<=m) dfs(x,y-1);
}
int main()
{
    int i,j,k,l=0;
        cin>>n>>m;
        for (i=1;i<=n;i++)
        {
            for (j=1;j<=m;j++)
            {
                cin>>c[i][j];
                if (c[i][j]=='#') s++;
            }
        }
        for (i=1;i<=n;i++)
        {
            for (j=1;j<=m;j++)
            {
                  if(c[i][j]=='.')
            {
                if(c[i+1][j]=='#'&&c[i][j+1]=='#'&&c[i+1][j+1]=='#'){cout<<"Bad placement."<<endl;return 0;}
                if(c[i+1][j]=='#'&&c[i][j-1]=='#'&&c[i+1][j-1]=='#'){cout<<"Bad placement."<<endl;return 0;}
                if(c[i-1][j]=='#'&&c[i][j+1]=='#'&&c[i-1][j+1]=='#'){cout<<"Bad placement."<<endl;return 0;}
                if(c[i-1][j]=='#'&&c[i][j-1]=='#'&&c[i-1][j-1]=='#'){cout<<"Bad placement."<<endl;return 0;}
            }
            }
        }
            for (i=1;i<=n;i++)
            {
                for (j=1;j<=m;j++)
                {
                    if (c[i][j]=='#')dfs(i,j),l++;;
                }
            }
        cout<<"There are "<<l<<" ships.";
    return 0;
}

```

---

## 作者：汇文客 (赞：0)

本题是一道裸的BFS，唯一要注意的一点是对船是否相邻的判断。搜索全图，只要有一个“.”的一角全为“#”，则直接退出。

核心check函数：

```delphi

function check(i,j:longint):boolean;
begin
  check:=false;
  if g[i,j]='.' then
  begin
    if(g[i+1,j]='#')and(g[i,j+1]='#')and(g[i+1,j+1]='#')then exit(true);
    if(g[i+1,j]='#')and(g[i,j-1]='#')and(g[i+1,j-1]='#')then exit(true);
    if(g[i-1,j]='#')and(g[i,j+1]='#')and(g[i-1,j+1]='#')then exit(true);
    if(g[i-1,j]='#')and(g[i,j-1]='#')and(g[i-1,j-1]='#')then exit(true);
  end;
end;

```
至于宽搜，就更不在话下了。这里贴一个很好的宽搜模板。

```delphi

fillchar(v,sizeof(v),true);
  ans:=0;
  for i:=1 to n do
  for j:=1 to m do
  if(v[i,j])and(g[i,j]='#')then
  begin
    inc(ans);
    v[i,j]:=false;
    h:=0;t:=1;
    q[1,1]:=i;q[1,2]:=j;
    while h<t do
    begin
      inc(h);
      for k:=1 to 4 do
      begin
        x:=q[h,1]+dx[k];
        y:=q[h,2]+dy[k];
        if(x>=1)and(x<=n)and(y>=1)and(y<=m)and(v[x,y])and(g[x,y]='#')then
        begin
          v[x,y]:=false;
          inc(t);
          q[t,1]:=x;
          q[t,2]:=y;
        end;
      end;
    end;
  end;

```

---


# 南蛮图腾

## 题目背景

自从到了南蛮之地，孔明不仅把孟获收拾的服服帖帖，而且还发现了不少少数民族的智慧，他发现少数民族的图腾往往有着一种分形的效果，在得到了酋长的传授后，孔明掌握了不少绘图技术，但唯独不会画他们的图腾，于是他找上了你的爷爷的爷爷的爷爷的爷爷……帮忙，作为一个好孙子的孙子的孙子的孙子……你能做到吗？

## 题目描述

给定一个正整数 $n$，参考输出样例，输出图形。

## 说明/提示

数据保证，$1 \leq n \leq 10$。

## 样例 #1

### 输入

```
2```

### 输出

```
   /\
  /__\
 /\  /\
/__\/__\
```

## 样例 #2

### 输入

```
3```

### 输出

```
       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\```

# 题解

## 作者：expin (赞：996)

去年，搞竞赛的同学给我看了这题，觉得挺有意思的，但是根本不知道分治是啥，所以作罢。不久前在写组合数问题**P2822**时，尽管我用了题解里的递推公式，但还是WA。于是我想把杨辉三角对2取模输出看下结果，这是12行内的结果：
```
            1
           1 1 
          1 0 1 
         1 1 1 1 
        1 0 0 0 1 
       1 1 0 0 1 1 
      1 0 1 0 1 0 1 
     1 1 1 1 1 1 1 1 
    1 0 0 0 0 0 0 0 1 
   1 1 0 0 0 0 0 0 1 1 
  1 0 1 0 0 0 0 0 1 0 1
 1 1 1 1 0 0 0 0 1 1 1 1
```
发现0的分布很有规律，突发奇想能否用这个规律来解这题。

优化了一下递推公式
```cpp
a[i][j]=a[i-1][j]^a[i-1][j-1];
```
异或和(a+b)%2有相同的效果，后来发现甚至可以直接用一维数组实现，那就不客气了（滑稽）。

思路如下：行数是2的n次方，以这个数组为基础，奇数行遇1输出"/\",偶数行遇连续两个1输出"/__\"，遇0补上相应的空格即可。

以下是代码：
```cpp
#include<iostream>
using namespace std;
int n,a[1030]={1};
int main(){
	cin>>n;
    for(int i=0;i<1<<n;++i){
        for(int j=1;j<(1<<n)-i;++j)cout<<" ";//前导空格
		for(int j=i;j>=0;--j)a[j]^=a[j-1];//修改数组
		if(!(i%2))for(int j=0;j<=i;++j)cout<<(a[j]?"/\\":"  ");//奇数行
		else for(int j=0;j<=i;j+=2)cout<<(a[j]?"/__\\":"    ");//偶数行
		cout<<endl;
    }
    return 0;
}
```

---

## 作者：学无止境 (赞：219)

分形就是自相似，那么最终图腾是由多个与之相似的更小的图腾元素组成。

那么最小的元素是什么？
```
 /\  
/__\        //观察发现，此为基础组成图形，也是n=1时的图腾
```

将这个图形向右复制一个：

```
 /\  /\
/__\/__\           
```

再向上复制一个


```
   /\
  /__\
 /\  /\             //我们由n=1时的图腾生成了n=2时的图腾
/__\/__\
```


就得到了n=2时的图腾

以此类推，因为n-1规模图腾可以生成n规模的图腾，我们可以用**分治法**解决更大规模的图腾，并把n=1的基础图腾预先输入，这里注意一点，‘\’ 是转义字符，这么赋值—— 
```
char c='\\';
```

我们用字符矩阵存储答案，要多大呢，每复制一轮，矩阵的长与宽都翻2倍，初始n=1时，长为4，宽为2，所以定义一个1024×2048的字符矩阵就够了~~

（打表的佩服你的勇气）

还要注意一点，整个矩阵要预先赋值成空格，否则是NULL，这两个在本地输出显示是一样的，但在洛谷上会判错，到时候就出现“我在本地是对的，为什么洛谷上爆0？”的问题云云。

为了便于复制，我们将图腾先倒置处理，最后倒序输出。

最后效率 **24ms**

**Code：**
```
#include<iostream>
using namespace std;
char a[1024][2048];
int main()
{
	ios::sync_with_stdio(false);//输出速度优化 
	int n,length=4,k=1;//length表示当前图腾的宽，length/2是图腾的高 
	cin>>n;
	for(int i=0;i<1024;i++)
    for(int j=0;j<2048;j++)
	a[i][j]=' ';//先全部置为空格(反正忽略行末空格2333) 
	a[0][0]=a[1][1]='/',a[0][1]=a[0][2]='_',a[0][3]=a[1][2]='\\';//存n=1时的基础图腾（倒着的） 
	while(k<n)//不断复制 
	{
		for(int i=0;i<length/2;i++)
		for(int j=0;j<length;j++)
		a[i+(length/2)][j+(length/2)]=a[i][j+length]=a[i][j];
		length*=2,k++;
	} 
	for(int i=(length/2)-1;i>=0;i--)//倒序输出 
	{	
	    for(int j=0;j<length;j++)
	    cout<<a[i][j]; 
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Froggy (赞：117)

用分治很简单.
每次向下复制一下,向右复制一下,再向上复制一下.
```cpp
   /\
  /__\
 /\  /\
/__\/__\
```
向下和向右:(顺便把原本的清掉)
```




   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\
```
再向上:
```cpp
       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\
```
## OK
##### 上代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n;
char a[3000][3000];//开大点 
int h=2,w=4;//h是高,w是宽
int main(){
	cin>>n;
	memset(a,' ',sizeof(a));//别被坑了!!! 
	a[1][1]=a[1][4]=' ';
	a[1][2]=a[2][1]='/';
	a[1][3]=a[2][4]='\\';//向右的划线有特殊的含义
	a[2][2]=a[2][3]='_';
	for(int i=1;i<n;i++){
    	//向下和向右
		for(int j=1;j<=h;j++){
			for(int k=1;k<=w;k++){
				a[j+h][k]=a[j+h][k+w]=a[j][k];
				a[j][k]=' ';//把上面的清掉
			}
		}
        //向上
		for(int j=1;j<=h;j++){
			for(int k=1;k<=w;k++){
				a[j][k+w/2]=a[j+h][k];
			}
		}
		w*=2,h*=2;
        //刷新完成一次
	}
	for(int i=1;i<=h;i++){
		for(int j=1;j<=w;j++){
			cout<<a[i][j];
		}
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：cheating_dictator (赞：91)

数据较小（n<=10)

可以考虑暴力递归

通过题目发现：

**一个大小为n的图形是由三个大小为n-1的图形组成的（n!=1)**

因此通过层层递归，直到n=1，存入二维数组中

代码：
```cpp
#include<iostream>
#include<math.h>
using namespace std;
char mp[1030][2050];   //存储答案
int n;
void dr(int x,int y,int deep){        //x,y表示图形的第一个“/”的坐标   
//deep表示所需图形的大小
    if(deep==1){                 //画出n=1的基本图形
        mp[x][y]='/';
        mp[x][y+1]='\\';
        mp[x+1][y-1]='/';
        mp[x+1][y]='_';
        mp[x+1][y+1]='_';
        mp[x+1][y+2]='\\'; 
        return;
    }
    dr(x,y,deep-1);                         //递归分别画三个部分
    dr(x+pow(2,deep-1),y-pow(2,deep-1),deep-1);
    dr(x+pow(2,deep-1),y+pow(2,deep-1),deep-1);
}
int main(){
    cin>>n;
    for(int i=1;i<=pow(2,n);i++){          //初始化
        for(int j=1;j<=pow(2,n+1);j++)
        mp[i][j]=' ';
    }
    dr(1,pow(2,n),n);
    for(int i=1;i<=pow(2,n);i++){               //输出
        for(int j=1;j<=pow(2,n+1);j++)
        cout<<mp[i][j];
        cout<<endl;
    }
}
```

---

## 作者：bestzzy (赞：55)

什么分治，什么深搜，都不用

最简单的解法，无脑模拟。

竟然A了

```cpp
var
 i,j,h,k,n,m:longint;
 a:array[1..2048]of ansistring;
begin
 h:=2;
 a[1]:=' /\ ';
 a[2]:='/__\';
 read(n);
 for i:=2 to n do
 begin
  for j:=1 to h do
   a[j+h]:=a[j]+a[j];
```
{使图形变成
/\
/\_\_\
/\  /\
/\_\_\/\_\_\

```cpp
}
  for j:=1 to h do
   for k:=1 to h do
    a[j]:=' '+a[j]+' ';
```
将上一行的图形推出去变成
{
/\
/\_\_\
/\  /\
/\_\_\/\_\_\

```cpp
}
  h:=h*2;//加高度
 end;
 for i:=1 to h do
  writeln(a[i]);
end.
```

---

## 作者：Steven_Meng (赞：42)

正怀疑你们为什么写这么长
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
string ans[2000];
//2^10=1024，开2000足够
void add(int end){
	for (int i=end;i<(end<<1);i++){
    	//这里的作用是将原图形向下复制两个
		ans[i]=ans[i-end]+ans[i-end];
	}
	for (int i=0;i<end;i++){
        //这里十分关键，需要补全空格
        //要不然会变成这样
        /*
         /\
        /__\
         /\  /\
        /__\/__\
         /\  /\
        /__\/__\
         /\  /\  /\  /\
        /__\/__\/__\/__\
        */
		ans[i].insert(0,end,' ');
		ans[i].insert(ans[i].length(),end,' ');
	}
}
int main(){
	freopen("out.txt","w",stdout);
	int n;
	scanf("%d",&n);
	ans[0]=" /\\ ";
	ans[1]="/__\\";//这里要写两个反斜杠，一个反斜杠是转义字符
	for (int i=1;i<n;i++)　add(1<<i);//不断复制原图形
	for (int i=0;i<(1<<n);i++)　cout<<ans[i]<<endl;
}
```

---

## 作者：氕氘氚勥烎 (赞：28)

# 1.取一个实心的三角形。（多数使用等边三角形）  
## 2.沿三边中点的连线，将它分成四个小三角形。  
### 3.去掉中间的那一个小三角形。  
#### 4.对其余三个小三角形重复1。  
##### 以上是谢尔宾斯基三角形的构造方法（百度说的）   
# **[谢尔宾斯基三角形](https://baike.baidu.com/item/谢尔宾斯基三角形/1332191?fr=aladdin)**

乍一看好像模拟不出来，其实思路已经出来了：先求出三角形的大小，然后用分治的思想不停的递归，直到分成
```
 /\
/__\
```
这样的基本图形，然后层层累加就可以了，这题数据不大直接用数组存。
先上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char pic[2048][2048];//建图 
void huatu(int x,int y,int jie)
{
	if(jie==1)//从底层建起 
	{
		pic[x][y]='/';
		pic[x][y+1]='_';
		pic[x][y+2]='_';
		pic[x][y+3]='\\';
		pic[x-1][y+1]='/';
		pic[x-1][y+2]='\\';//'\\'里有一是个转义符号
	}
	else//不断递归，分成更小的
	{
		int m=pow(2,jie);这里每个三角形的高度随阶次减少
		huatu(x,y,jie-1);//降阶 
		huatu(x,y+m,jie-1);//分图，每次都相当于在底下画两个一样的，这里因为是从下往上，不然不好存————构造的第2步
		huatu(x-m/2,y+m/2,jie-1);//画一个倒着的在三个之间————构造的第3步，反着画一个，相当于去掉中间的
	}
}
int main()
{
	int n;
	cin>>n;
	memset(pic,' ',sizeof(pic));//全图空格 
	int m=pow(2,n);//图的层数为2的n次方 
	huatu(m,1,n);//开始画图 从下往上
	int a,b;
	for(a=1;a<=m;a++)
	{
		for(b=1;b<=m*2;b++)
			printf("%c",pic[a][b]);
		printf("\n");
	}	//输出
	printf("\n");
	return 0;
}
```
[亲测可用：29ms, 4880KB](https://www.luogu.org/recordnew/show/17713174)

---

## 作者：zyj_Orz (赞：16)

我只是一个蒟蒻，看到dalao们的一大堆指针、DFS、DP只能深深叹服……

## 其实分治大法好！（笑）

我的代码十分好理解的，适合~~像我一样的~~新手

# 具体看代码

```
#include<bits/stdc++.h>
using namespace std;
char jz[3000][3000];
int n,nowh,nowl;
long long power(int x,int y)
{
    long long sum=1;
    for(int i=1;i<=y;i++)
    sum*=x;
    return sum;
}
void U(int x)
{
    for(int i=1;i<=nowh;i++)
    for(int j=1;j<=nowl;j++)
    jz[i+power(2,x-1)][j+power(2,x-1)]=jz[i][j];
}
void R(int x)
{
    for(int i=1;i<=nowh;i++)
    for(int j=1;j<=nowl;j++)
    jz[i][j+power(2,x)]=jz[i][j];
}
int main()
{
    cin>>n;
    for(int i=1;i<=2900;i++)
    for(int j=1;j<=2900;j++)
    jz[i][j]=' ';
    jz[1][1]='\\';
    jz[1][2]='_';
    jz[1][3]='_';
    jz[1][4]='/';
    jz[2][2]='\\';
    jz[2][3]='/';
    nowl=4;
    nowh=2;
    for(int i=2;i<=n;i++)
    {  	
    	U(i);
    	R(i);
    	nowl=power(2,i+1);
    	nowh=power(2,i);
    }
    for(int i=nowh;i>=1;i--)
    {
    	for(int j=1;j<=nowl;j++)
    	{
    		if(jz[i][j]==' ')
    		cout<<" ";
    		if(jz[i][j]=='\\')
    		cout<<"/";
    		if(jz[i][j]=='/')
    		cout<<"\\";
    		if(jz[i][j]=='_')
    		cout<<"_";
    	}
    	cout<<endl;
    }
}
```

---

## 作者：luowa (赞：15)

表示~~懒得分治~~，于是直接模拟。

思路是先给出n=1时的图形，计入k[1][1],k[1][2],k[2][1]……
然后观察题目给出的图形可以发现，n+1的结果就是将图形分别向左下和右下复制一遍，在两个复制的图形中间直接按每行长度2*v（v为行数）补空格就行。

最后前后补空格，按序输出k。

上代码，~~蒟蒻代码，神犇勿喷~~
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
char k[1024][1024];
int main()
{
	int n;
	cin>>n;
	k[1][1]='/';k[1][2]='\\';
	k[2][1]='/';k[2][2]='_';k[2][3]='_';k[2][4]='\\';
	int v=2;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=v;j++)
		{
			int p=j*2;
			for(int l=1;l<=p;l++)
				k[v+j][l]=k[j][l];
			for(int l=p+1;l<=2*(v+j-p);l++)
				k[v+j][l]=' ';
			for(int l=2*(v+j)-p+1;l<=2*(v+j);l++)
				k[v+j][l]=k[j][l+p-2*(v+j)];
		}
		v*=2;
	}
	for(int i=1;i<=pow(2,n);i++)
	{
		for(int j=1;j<=pow(2,n)-i;j++)
			cout<<' ';
		for(int j=1;j<=2*i;j++)
			if(k[i][j]==0)	cout<<" ";
			else cout<<k[i][j];
		for(int j=1;j<=pow(2,n)-i;j++)
			cout<<' ';
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：离子键Ionic_Bond (赞：11)

感觉上这题评黄题有点不大行啊，起码一个绿的。

因为
# 太恶心啦~~~~
思路：杨辉三角，偶空奇不空

什么意思呢，就是先DP一个$2^n$层的杨辉三角，然后检查一下其中的元素，若为奇数，则该部分有字符，若为偶数，就是个空格。

这也显然：
```
           1
         1 0 1
        1 1 1 1
       1 0 0 0 1
           .
           .
           .
即：
           1%2
       1%2 2%2 1%2
   1%2 4%2 6%2 4%2 1%2
1%2 5%2 10%2 10%2 5%2 1%2
            .
            .
            .
即：
           /\
          /__\
         /\  /\
        /__\/__\
            .
            .
            .
```
处理完列上的问题，仔细观察一下行间关系：

可以发现，奇数行有'_',而偶数行没有。

然后观察一下规律：

就可以得到哪里需要空格，那里不需要了

具体参考代码
```cpp
#include<bits/stdc++.h>
int yh[1028][1028],cyhe[1028][1028],jop;
int main()
{
	
	int cnum,n;
	scanf("%d",&n);
	cnum=pow(2,n);
	yh[0][1]=1;
	cyhe[0][1]=1;
	for(int i=1;i<=cnum-1;i++)
	{
		printf(" ");
	}
	printf("/\\\n");
	for(int i=1;i<=cnum-1;i++)
	{
		for(int j=1;j<=cnum-i-1;j++)
		{
			printf(" ");
		}
		for(int j=1;j<=cnum;j++)
		{
			yh[i][j]=yh[i-1][j]+yh[i-1][j-1];
			cyhe[i][j]=yh[i][j]%2;
			if(cyhe[i][j]==0)printf("  ");
			else
			{
				if(i%2==0)printf("/\\");
				if(i%2==1)
				{
					jop++;
					if(jop%2==1)printf("/_");
					else printf("_\\");
				}
			}
		}		
		printf("\n");
	}
}
```

---

## 作者：滑稽的小宫 (赞：9)

# P1498 南蛮图腾

这题的二分似曾相识……

我~~闲的没事~~把'\\'和'_'转换为1，把空格转换为0以后：
```
n=2
0 0 0 1 1
0 0 1 1 1 1
0 1 1 0 0 1 1
1 1 1 1 1 1 1 1
```
 似曾相识……
 于是忽然想起浴谷7月月赛第一题：[P5461赦免战俘](https://www.luogu.org/problem/P5461?contestId=17734)

相当于是前导0不变，后面的两个1合成一个，两个0也合成一个：
```
n=2
0 0 0 1
0 0 1 1
0 1 0 1
1 1 1 1
```
完全一样

#### 因此就用赦免战俘的思路写分治函数，然后把赦免结果存在数组里，最后判断一下输出即可



------------

### 输出的时候注意：

前导0输出一个空格，其余的0输出两个空格

奇数行：1输出"/\\" （记得转义）

偶数行：两个1输出"/__\\"（记得转义）



------------

#### 分治函数
```cpp
//开始a数组memset成-1
void fun(int x,int y,int h){//x,y为坐标 h为分治区间大小
	if(h==2){
		a[x][y]=0;
		return;
	}
	int ha=h/2;
	for(int i=x;i<x+ha;i++){
		for(int j=y;j<y+ha;j++){
			a[i][j]=0;
		}
	}
	fun(x+ha,y,ha);
	fun(x,y+ha,ha);
	fun(x+ha,y+ha,ha);
	return;
}
```
#### 输出部分
```cpp
	int n2=std::pow(2,n);
	for(int i=1;i<=n2;i++){
		int j=1;
		while(a[i][j]==0){//输出前导0
			printf(" ");
			j++;
		}
		for(;j<=n2;j++){
			if(i&1){
				if(a[i][j]==-1)printf("/\\");
				else printf("  ");
			}else{
				if(a[i][j]==-1){
					printf("/__\\");
					j++;
				}else printf("  ");
			}
		}
		printf("\n");
	}
```
## ~~双倍的经验，双倍的快乐：P1498 P5461~~

---

## 作者：八重樱飞 (赞：9)


大家可能已经发现了此题的~~奥妙~~   ~~机密~~  规律了吧

首先呢， 当n=1时， 图形是什么样呢？ 大家可以使用word等来画一画。

 n=1时

```

 /\
/__\

```

那n=2，3，4···时，图形又是什么样呢？

n=2时

```
   /\
  /__\
 /\  /\
/__\/__\ 

```

n=3时

```
       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\                                                   

```

n=4时

```
               /\
              /__\
             /\  /\
            /__\/__\
           /\      /\
          /__\    /__\
         /\  /\  /\  /\
        /__\/__\/__\/__\
       /\              /\
      /__\            /__\
     /\  /\          /\  /\
    /__\/__\        /__\/__\
   /\      /\      /\      /\
  /__\    /__\    /__\    /__\
 /\  /\  /\  /\  /\  /\  /\  /\
/__\/__\/__\/__\/__\/__\/__\/__\  

```
很漂亮是吧！

n=1时的图形相当于祖先（要是没有这个基础图形，后面的图形都不会产生） 那这个祖先是怎么孕育后代的呢？

为方便叙述 敝人把n=1时的图形记作a[1]

n=2时记作a[2]   

···

以此类推

a[2] 相当于 a[1]向左平移复制一次， 再向上平移复制一次
 
a[3] 相当于 a[2]向左平移复制一次， 再向上平移复制一次， 也就是说， 总共复制了2次 （a[1]为起点）

a[4]呢， 敝人知道你们肯定也发现了， 也就是a[3]向左平移复制一次，再向上平移复制一次， 总共复制了3次

···

 而a[n]，想必很easy啦，就是a[n-1]向左平移复制一次，再向上平移复制一次，总共复制了n-1次

而再定睛一看 ，n=1时有2排，4列 ，n=2时有4排，8列  n=3时有8排，16列 是不是觉得很熟悉。

# 没错！排数=2^n, 也就是1<<n
# 列数=2^(n+1)，也就是1<<(n+1)

总规律我们找出来了，但进一步就可以发现，最左下角的那个a[0]都是基本图形，我们可以初始化一下（预处理？）

                     
```cpp
	mp[1<<n][1]='/';//最后一排的第一个 
	mp[1<<n][2]='_';//最后一排的第二个 
	mp[1<<n][3]='_';//最后一排的第三个 
	mp[1<<n][4]='\\';//最后一排的最后一个 
	mp[(1<<n)-1][2]='/';//倒数第二排（最后一排的上面一排）的第二个，因为第一个是' '（空格） 
	mp[(1<<n)-1][3]='\\';//倒数第二排的第三个，也就是最后一个 
```


当然各位可能也发现了，我用的是平移复制，而不是单纯的复制，所以说咱们再数数 向左平移 和 向上平移的数
                                         
复制1次时  向左平移了3（=4-1）个（此处平移指mp [i][j+3],不止此处，之后同此)，~~向上平移了~~，准确说，是向斜上方向，向左平移了2个，同时向上平移了2个
                   
复制2次时  向左平移了7（=8-1）个，斜向上平移：向左平移了4个，同时向上平移了4个
                   
复制3次时  向左平移了15（=16-1）个，斜向上平移：向左平移了8个，同时向上平移了8个  
                   
那么各位，复制k次呢？ 想必聪明的各位立马反应过来了，向左平移了2^(k+1)-1 ,也就是(1<<(k+1))-1个， 斜向上平移：向左平移了2^k(1<<k)个，同时向上平移了2^k(1<<k)个 
                                                                                                    
                                                                                                    接下来，便是各位喜爱的AC代码上场！！
                                                                                                    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
char mp[1<<10][1<<10];
int main()
{
	int i,j,k,l;
	scanf("%d",&n);
	for(i=0;i<=(1<<n);i++)
		for(j=0;j<=(1<<n);j++)
			mp[i][j]=' ';//预处理 未填上的图形都是空格 
	if(n==1)//特判 
	{
		cout<<" /\\"<<endl;
		cout<<"/__\\"<<endl;
		return 0;
	}
	mp[1<<n][1]='/';//最后一排的第一个 
	mp[1<<n][2]='_';//最后一排的第二个 
	mp[1<<n][3]='_';//最后一排的第三个 
	mp[1<<n][4]='\\';//最后一排的最后一个 
	mp[(1<<n)-1][2]='/';//倒数第二排（最后一排的上面一排）的第二个，因为第一个是' '（空格） 
	mp[(1<<n)-1][3]='\\';//倒数第二排的第三个，也就是最后一个 
	k=1;//复制次数 
	l=4;//最后一排的符号个数  刚开始时最后一排有4个，以后随着k增加l变为原来的2倍 
	while(k<n)
	{
		for(i=(1<<n);i>((1<<n)-(1<<k));i--)
			for(j=1;j<=l;j++)
			//第k次复制，应把((1<<n)-(1<<k))+1到(1<<n)排和第1列到第l列看做一个基础图形
			//若不是很理解 可亲自数一数 (空格无所谓反正平移过去都还是空格） 
			{
				mp[i][j+(1<<(k+1))]=mp[i][j];
				mp[i-(1<<k)][j+(1<<k)]=mp[i][j];//规律 
			}
		k++;
		l=l*2;
	}
	for(i=1;i<=(1<<n);i++)
	{
		for(j=1;j<=(1<<(n+1));j++)
			cout<<mp[i][j];
		printf("\n");
	}//输出 
	return 0;
}
```
                                                                                                   

---

## 作者：C2H6O (赞：4)

递推即可。这里我采用了把图腾倒放，每次扩大时把原图腾向右复制一个，再向右下复制一个，最后倒置输出即可

```cpp
#include <iostream>
#include <string.h>
using namespace std;
int n,x,y;
char a[3000][3000];
void copy(int &u, int &v) {  //复制图腾，递推
    int i, j;
    for (i = 1; i <= u; i++)
        for (j = 1; j <= v; j++)
            a[i][v + j] = a[u + i][(v / 2) + j] = a[i][j];
    u *= 2;
    v *= 2;
}
int main(){
    memset(a, ' ', sizeof(a));
    a[1][1] = a[2][2] = '\\';
    a[1][2] = a[1][3] = '_';
    a[1][4] = a[2][3] = '/';   //初始化基础图腾
    x = 2; y = 4;
    cin >> n;
    for (int i = 1; i < n; i++) copy(x, y);  //递推n-1次
    for (int i = x; i > 0; i--) {
        for (int j = y; j > 0; j--) cout << a[i][j];//倒置输出
        cout << endl;
    }
    return 0;
}
```

---

## 作者：吴名玄 (赞：3)

一道典型的分治（~~打表大法好~~）题，虽然数据比较小，只有n<=10，但是打表的话。~~也就2000+行的样子吧~~


------------
那么怎么分治呢，首先1层的图腾就是一个简单的三角：

 	  /\
	 /__\
然后每变大一层就是向右和右上各复制一遍。但是对于不同的图腾，我们不知道应该在第一行输多少空格，所以我们其实可以倒着存倒着输。

也就是说我们首先将图腾初始化为一个倒三角：

	/__\
     /\
这样倒着输出后效果是一样的，而且每次变大就是向右和右下复制，显然要方便很多，因为不需要更新之前已经存好的图。


------------
那么就上代码吧：
```cpp

#include<iostream>
#include<cstring>
using namespace std;
char tut[2050][2050];int n,num=2;
void csh()
{
	tut[0][0]=tut[1][1]='/';
	tut[0][1]=tut[0][2]='_';
	tut[0][3]=tut[1][2]='\\';
}
void bigger()
{
	for(int i=0;i<num;i++)
		for(int j=2*num;j<4*num;j++)
			tut[i][j]=tut[i][j-2*num];
	for(int i=num;i<2*num;i++)
		for(int j=num;j<3*num;j++)
			tut[i][j]=tut[i-num][j-num];
	num<<=1;
}
void OUTPUT()
{
	for(int i=num-1;i>=0;i--)
	{
		for(int j=0;j<2*num;j++)
			cout<<tut[i][j];
		cout<<endl;
	}
}
int main()
{
	cin>>n;
	memset(tut,' ',sizeof(tut));csh();
	while(--n)
	{
		bigger();
	}
	OUTPUT();
	return 0;
}

```
所以这个题目就是~~这么水的一道伪~~黄题

---

## 作者：Night_Aurora (赞：3)

典型的递归+分治







```cpp
#include <stdio.h>
#include <string.h>
int P2[]={1,2,4,8,16,32,64,128,256,512,1024,2048};   //简化了math.h的pow函数
char Map[2049][2049];   //整个的缓冲图
int N;
void Pt1(int pyh,int pyl)  //在偏移上打印最基本的三角形
{
    Map[pyh][pyl]='/';
    Map[pyh][pyl+1]='\\';
    Map[pyh+1][pyl-1]='/';
    Map[pyh+1][pyl+2]='\\';
    Map[pyh+1][pyl]='_';
    Map[pyh+1][pyl+1]='_';
}
void Divide(int py1,int py2,int n)  //分治
{
    if(n==1){Pt1(py1,py2);return;}  //只有一层就打印退出
    Divide(py1,py2,n-1);  
    Divide(py1+P2[n-1],py2-P2[n-1],n-1);
    Divide(py1+P2[n-1],py2+P2[n-1],n-1);//反之则分裂成三个继续递归
}
int main()
{
    scanf("%d",&N);
    memset(Map,' ',sizeof(Map));   //全设为空格，因为是char所以用memset可以实现
    Divide(0,P2[N],N);
    int wia,wib;
    for(wia=0;wia<P2[N+1];++wia)
    {
        for(wib=1;wib<=P2[N+1];++wib)
            putchar(Map[wia][wib]);
        putchar('\n');
    }    //费劲的一个一个输出完成图
    return 0;
}
```

---

## 作者：萝卜 (赞：3)

这是非正解

对于每个位置，直接判断该填什么

只需要观察图形即可，不需要任何算法




```cpp
#include<iostream>
#include<cstdio> 
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int n,k,head,tail;
char map[1500][1500];
int main(){
    scanf("%d",&n);
    memset(map,(' '),sizeof(map));
    k=1;
    for(int i=1;i<=n;i++)k*=2;//
    map[1][k]='/';map[1][k+1]='\\';
    for(int i=1;i<=k*2;i++)printf("%c",map[1][i]);
    printf("\n");
    for(int i=2;i<=k;i++)
     {
         for(int j=1;j<=k*2;j++)
          {
              if(map[i][j-1]!='_'&&((map[i-1][j+1]=='/'&&map[i-1][j]!='\\')||(map[i-1][j]=='\\'&&map[i-1][j+1]!='/')))
             {
                 map[i][j]='/';
                printf("/");
             }
              else if(map[i][j-1]!=' '&&(map[i-1][j]=='/'&&map[i-1][j+1]=='_')||(map[i-1][j-1]=='\\'&&map[i-1][j]!='/'))
             {
                  map[i][j]='\\';
                printf("\\");
             }
              else if((map[i-1][j]=='/'&&map[i][j-1]=='/')||(map[i][j-1]=='_'))
             {
                 map[i][j]='_';
                printf("_");
             } 
              else
             {
                 map[i][j]=' ';
                printf(" ");
             }  
          }
         printf("\n"); 
     }
    return 0;
}
```

---

## 作者：tmj小盆友 (赞：3)

```cpp
#include<iostream>
using namespace std;
char a[1024][2048];
int main()
{
    int n,l=4,k=1;//length表示当前图腾的宽，l/2是图腾的高 
    cin>>n;
    for(int i=0;i<1024;i++)
    for(int j=0;j<2048;j++)
    a[i][j]=' ';//先全部置为空格(反正忽略行末空格) 
    a[0][0]=a[1][1]='/',a[0][1]=a[0][2]='_',a[0][3]=a[1][2]='\\';//存n=1时的基础图腾（倒着的） 
    while(k<n)//不断复制 
    {
        for(int i=0;i<l/2;i++)
        for(int j=0;j<l;j++)
        a[i+(l/2)][j+(l/2)]=a[i][j+l]=a[i][j];
        l*=2,k++;
    } 
    for(int i=(l/2)-1;i>=0;i--)//倒序输出 
    {   
        for(int j=0;j<l;j++)
        cout<<a[i][j]; 
        cout<<endl;
    }
    return 0;
}


```

---

## 作者：AritxOnly_ (赞：2)

这是一个很标准的分治题   
首先先分析题目：输入的n<=10，图腾是一直分叉下去的
那么其实只需要不停复制就够了。而标准图腾高2宽4，所以申请一个数组pt[1025][2049]即可  
```cpp
char pt[1025][2049];
```

复制用的转移式就可以列出来了  
```cpp
pt[i+(w/2)][j+(w/2)]=pt[i][j+w]=pt[i][j];
```
另外，有一个问题会导致运行正确但是评测出错，这个我也是一直WA到最后，有一个题解写得比较详细，这里就不多叙述了，最后贴代码  
```cpp
#include <bits/stdc++.h>

using namespace std;

char pt[1025][2049];	//字符类型pt数组（至于pt的意思，就理解成picture好了） 

void first() {	
	//first函数负责初始化一个倒置的标准图腾 
	pt[1][1]='/';
	pt[2][2]='/';
	pt[1][2]='_';
	pt[1][3]='_';
	pt[1][4]='\\';
	pt[2][3]='\\';
}

void clean() {
	//初始化，不初始化会WA 
	for(int i=1;i<=1024;i++)
    	for(int j=1;j<=2048;j++)
    		pt[i][j]=' ';
}

int main() {
	int n,w=4,cnt=1;	//w宽度 
	cin>>n;
	clean();	//先初始化 
	first();	//设置一个标准图腾 
	while(cnt<n) {
		//复制图腾 
		for(int i=1;i<=w/2;i++)
			for(int j=1;j<=w;j++) {
				pt[i+(w/2)][j+(w/2)]=pt[i][j+w]=pt[i][j];	//转移式 
			}
		w*=2;
		cnt++;
	}
	for(int i=w/2;i>=1;i--) {
		for(int j=1;j<=w;j++)
			cout<<pt[i][j];
		cout<<endl;
	}	//输出的时候尤其要注意要倒置输出 
	return 0;
}
```
像我这个蒟蒻提交了近十次都WA，所以就不和各位dalao们比了

---

## 作者：spacetime (赞：2)

//典型的分治算法

/**首先我们考虑这个“分形”图形的状态表示方法

\*显然我们用它的底边上的中点可以很好的定位该“分形”的所有点

\*其次考虑状态分割方案

\*我们可以发现每个所谓的“分形”图形可以分为上、左下、右下三个子“分形”图形

\*然后用递归解决就可以了/

```cpp
#include<cstdio>
#include<cstring>
#define REP(I,start,end) for(int I=start;I<=end;I++)
using namespace std;
int n;
char sav[2000][2000];
inline void DFS(int len,int x,int y,int base)
//len表示当前“分形”大小，x,y表示上述中点，base表示该“分形”前面的空格数
{
    if(len==1)//如果当前“分形”图形已变为最小的三角形，存储并回溯
    {
        sav[x][y]='_';
        sav[x][y+1]='_';
        sav[x][y-1]='/';
        sav[x][y+2]='';
        sav[x-1][y]='/';
        sav[x-1][y+1]='';
        return;
    }
    int tmp=1<<len-1;
    DFS(len-1,x,base+y>>1,base);//搜左下子“分形”
    DFS(len-1,x,y+tmp,base+(tmp<<1));搜右下子“分形”
    DFS(len-1,x-tmp,y,base+tmp);//搜上子“分形”
}
int main()
{
    scanf("%d",&n);
    memset(sav,' ',sizeof(sav));//所有点赋为空格
    int n1=1<<n;
    DFS(n,n1,n1,0);//递归分治
    REP(i,1,n1)
    {
        REP(j,1,n1<<1)
            putchar(sav[i][j]);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：翟绪尧 (赞：1)

个人感觉是分治算法
先说一下思路：
1.附初始值
2.往下和右赋值
3.输出
其实个人感觉不必和各位大佬一样倒着输出 只要将表打好就好
看一下代码吧
```
/*
先打一下我的思路解样例1
4        / \
3      / _ _ \
2    / \     / \
1  / _ _ \ / _ _ \
   1 2 3 4 5 6 7 8 
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
char a[10001][10001];
int main()
{
//	freopen(" 0.txt","w",stdout);
	int n,i,j,k;
	scanf("%d",&n);
	for(i=1;i<=1000;i++)             //千万要附上空格 不然的话 虽然长得像 但会Wa 
		for(j=1;j<=1000;j++)
			a[i][j]=' ';
	a[1][1]=a[2][2]='/';             //付初始值 
	a[1][2]=a[1][3]='_';
	a[1][4]=a[2][3]='\\';
	for(i=1;i<n;i++)
	{
		for(j=1;j<=pow(2,i);j++)                         //往右赋值 
			for(k=pow(2,i+1)+1;k<=pow(2,i+2);k++)
				a[j][k]=a[j][k-int(pow(2,i+1))];
		for(j=pow(2,i)+1;j<=pow(2,i+1);j++)             //往上赋值 
			for(k=pow(2,i)+1;k<=pow(2,i)+pow(2,i+1);k++)
				a[j][k]=a[j-int(pow(2,i))][k-int(pow(2,i))];
	}
	for(i=pow(2,n);i>=1;i--)                          //输出 
		{for(j=1;j<=pow(2,n+1)-i+1;j++)
			printf("%c",a[i][j]);
			cout<<endl;
			}
}
```


---

## 作者：Dvelpro (赞：1)

这个题 好坑啊  改了好久的 bug   我的思路就是 三角型依次复制 到左下 和右下

找到规律之后  复制 的时候就很方便了

感觉用二维数组很方便啊  用 1 表示 "/"     2 表示 "\"    3表示  "\_"

这样的话我们每次复制的时候只用把数组里面的数 复制一下就好了

下面 附上代码和注释



```cpp
1<<x 表示 2的x次方 
#include<bits/stdc++.h>
using namespace std;
int i=0;
int n;
int a[1001][10001];
void work(int x,int y){
   int hx=(1<<x)+1;                //确定复制的高度
   int l=(1<<n)-(1<<x);             //确定左边的边界
   for(int j=hx;j<=(1<<(x+1));j++){
      for(int k=l;k<=(1<<n);k++){    //左下复制
         int x1=j-hx+1;
         int y1=k+(1<<x);
         a[j][k]=a[x1][y1];
      }
      for(int k=(1<<n)+1;k<=1<<(n+1);k++){  //右下复制
        int x1=j-(1<<x);
        int y1=k-(1<<x);
        a[j][k]=a[x1][y1];
      }
      l--;           //边界--
   }
}
int main(){
   cin>>n;
   memset(a,0,sizeof(a));
   i=1<<n;
   a[1][i]=1;a[1][i+1]=2;
   a[2][i-1]=1;a[2][i+2]=2;
   a[2][i]=3;a[2][i+1]=3;      //确定第一个三角
   char c=(char)92;
   for(int j=1;j<n;j++){
      work(j,1);               复制次数
   }
   for(int j=1;j<=(1<<n);j++){
      for(int k=1;k<=(1<<n)*2;k++){
         if(a[j][k]==1){
            cout<<'/';
         }
         else if(a[j][k]==2){
            cout<<c;
         }
         else if(a[j][k]==3){
            cout<<'_';
         }
         else{
            cout<<' ';
         }
         //cout<<a[j][k]<<" ";
      }
      cout<<endl;
   }
}
```

---

## 作者：greyishsong (赞：1)

发一个分治的题解好了。

用二维字符数组存储结果，初始化全部是空格，修改需要修改的变量即可。

思路：打印一个距离最左端有dist个空格，尺寸为size，最下一行在数组中height行的三角形时，

如果size为1，直接存储；

否则打印顶部、左下和右下的三个小三角形，具体坐标见代码。

由于“\”是C++中的转义字符，可以使用char x=(char)92的方式将字符变量x赋值为“\”。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
void paint(int dist,int size,int height);
int n;
char tri[(1<<10)+1][(1<<10)+1];
int main()
{
    scanf("%d",&n);
    memset(tri,' ',sizeof(tri));
    int t=1<<n;                                  //整个三角形的尺寸
    paint(0,n,t);
    for(int i=1;i<=t;i++)
    {
        for(int j=1;j<=t*2;j++)
            printf("%c",tri[i][j]);
        printf("\n");
    }
    return 0;
}
void paint(int dist,int size,int height)
{
    if(size==1)
    {
        tri[height-1][dist+2]='/';
        tri[height-1][dist+3]=(char)92;
        tri[height][dist+1]='/';
        tri[height][dist+2]=tri[height][dist+3]='_';
        tri[height][dist+4]=(char)92; 
        return;
    }
    else
    {
        paint(dist+(1<<(size-2))*2,size-1,height-(1<<(size-1)));            //顶部三角形
        paint(dist,size-1,height);                                                           //左下三角形
        paint(dist+4*(1<<(size-2)),size-1,height);                                 //右下三角形
    }
}

```

---

## 作者：tututu (赞：1)

### 话说我怎么感觉这么简单

### 模拟大法好啊

# pascal程序怎么这么短：

```cpp
var
  n,i,j,t,k:longint;
  a:array[-1..10002] of ansistring;
begin
  readln(n);
  a[1]:=' /\ ';//对于这两行我真的不想解释了
  a[2]:='/__\';//就是一个一层的基本图形
  t:=2;//t表示当前图形高度
  for i:=2 to n do
    begin
      for j:=t+1 to t*2 do a[j]:=a[j-t]+a[j-t];//应该容易懂，每行变成两倍接在下面
      for j:=1 to t do//将原来的图形进化
        for k:=1 to length(a[j]) div 2 do//k仅仅是枚举个数，无数值上的意义
          a[j]:=' '+a[j]+' ';//没什么，就是前后都加上空格若干，使得其位于新图形中间位置
      t:=t*2;//高度加上去
    end;
  for i:=1 to t do
    writeln(a[i]);//输出，利用了忽略行末空格的特点
end.
```

---

## 作者：Akashicw (赞：1)

//规律：底边的横线个数、左右侧边线的个数都是2^n



      
    
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char pic[1<<12][1<<12];//存放图腾编
int n;//图腾大小 
void make_pic(int x,int y,int n)//从左下角开始构建 
{
    if(n==1)
    {
        pic[x][y]=pic[x-1][y+1]='/';
        pic[x][y+1]=pic[x][y+2]='_';
        pic[x][y+3]=pic[x-1][y+2]='\\'; //一定是双杠，因为\是转义字符 
    }
    else
    {
        make_pic(x,y+(1<<n),n-1);//右下方 
        make_pic(x-(1<<(n-1)),y+(1<<(n-1)),n-1);//上方 
        make_pic(x,y,n-1);//左下方 
    } 
} 
int main()
{    
    int i,j;
    scanf("%d",&n);//图腾的大小
    int h=1<<n;//m表示每边的线的个数，相当于2^n,行数
    int l=1<<(n+1);//列数为2^(n+1),因为横线为2^n,/\线个数也为2^n 
    for(j=1;j<=l;j++)//从列开始 
       for(i=1;i<=h;i++)
         pic[i][j]=' ';//赋初值为空
    make_pic(h,1,n);//构建图形,从最左下角位置开始构建 
    for(i=1;i<=h;i++)
     {
       for(j=1;j<=l;j++) 
          printf("%c",pic[i][j]);
        printf("\n");
      }
    return 0;    
}
```

---

## 作者：封禁用户 (赞：1)

用数组来找规律，寻找下一个一样的位置。。。

原代码：

```cpp
var i,j,l,h,k:longint;
    a:array[1..2000,-2000..2000] of char;
    n:byte;
begin
  readln(n);
  fillchar(a,sizeof(a),' ');
  a[1,0]:='/';a[1,1]:='\';
  a[2,-1]:='/';a[2,0]:='_';a[2,1]:='_';a[2,2]:='\';
  h:=2;l:=2;
  for i:=1 to n-1 do
  begin
    for j:=1 to h do
      for k:=1-l to l do
        begin a[j+h,k-l]:=a[j,k]; a[j+h,k+l]:=a[j,k]; end;
    h:=h*2; l:=l*2;
  end;
  for i:=1 to h do
  begin
    for j:=1-l to l do
    write(a[i,j]);
    writeln;
  end;
end.
```

---

## 作者：YanjunchenEdward (赞：1)

其实，用ansistring会更快，我们可以逐步分层计算。

```delphi
var
  n,n1,i,w,stt,j:longint;
  bo:boolean;
  a:array[0..10,0..1024] of ansistring;
procedure yu(flo,cen:longint);{逐步处理}
begin
  if flo>n then exit;
  for i:=1 to cen do a[flo,i]:=a[flo-1,i];
  stt:=length(a[flo-1,cen]);{第一块，有一块三角形}
  for i:=1 to cen do begin
    a[flo,i+cen]:=a[flo-1,i];
    for j:=1 to stt-2*i do a[flo,i+cen]:=a[flo,i+cen]+' ';
    a[flo,i+cen]:=a[flo,i+cen]+a[flo-1,i];{第二块，有两块三角形}
  end;
  yu(flo+1,cen*2);{继续递归}

end;
begin
  readln(n);
  a[1,1]:='/';{第一层}
  a[1,2]:='/__';
  yu(2,2);
  n1:=1;
  w:=1;
  for i:=1 to n do n1:=n1*2;
  dec(n1);
  repeat
    for i:=1 to n1 do write(' ');{w是空格数}
    writeln(a[n,w]);
    dec(n1); inc(w); 
  until n1<0;
end.
```
仅供参考,希望能对你有所帮助。


---

## 作者：RoRoyyy (赞：1)

~~回来填去年的坑。~~

~~这道题正解不应该是分形么~~


$len[x]$ 表示询问为$x$时的答案有几行。
有递推式： $len[x] = len[x - 1] * 2 $

递归分形裸题（分治）。设初始图形($k = 1$)为：

       " /\ "
       "/__\"


则有接下来的 $ k > 1 $ ：
	对于$k$而言， $len[k]$前$len[k - 1]$行由$ans[k - 1]$加上一些空格组成的， 而这些空格的数目就是$2^{(k - 1)}$。只需要在每行回溯更新答案的过程中在前后加入空格即可。对于后$len[k - 1]$行，只需要复制两次$ans[k - 1]$就行了。

```cpp
//RoRoyyy
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n;
string ans[15][1000];
int len[15];
void cacl(int k) {
    if(k == 1) {
        len[k] = 2;
        ans[k][1] = " /\\ ";
        ans[k][2] = "/__\\";
        return;
    }
    cacl(k - 1);
    len[k] = len[k - 1] * 2;
    for(int i = 1; i <= len[k - 1]; i++) {
        for(int j = 1; j <= (1 << (k - 1)); j++) ans[k][i] = ' ' + ans[k][i];
        ans[k][i] = ans[k][i] + ans[k - 1][i];
        for(int j = 1; j <= (1 << (k - 1)); j++) ans[k][i] = ans[k][i] + ' ';
    }
    for(int i = len[k - 1] + 1; i <= 2 * len[k - 1]; i++) {
        ans[k][i] = ans[k - 1][i - len[k - 1]];
    }
    for(int i = len[k - 1] + 1; i <= 2 * len[k - 1]; i++) {
        ans[k][i] = ans[k][i] + ans[k - 1][i - len[k - 1]];
    }
}
int main() {
    cin >> n;
    cacl(n);
    for(int i = 1; i <= len[n]; i++) {
        cout << ans[n][i] << endl;
    }
    return 0;
}
```


---


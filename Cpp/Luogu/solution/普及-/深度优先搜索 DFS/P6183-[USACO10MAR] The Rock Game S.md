# [USACO10MAR] The Rock Game S

## 题目描述

在奶牛回家休息和娱乐之前，Farmer John 希望它们通过玩游戏获得一些智力上的刺激。

游戏板由 $n$ 个相同的洞组成，这些洞最初**都是空的**。一头母牛要么用石头盖住一个空的洞，要么揭开一个先前被盖住的洞。**游戏状态**的定义是所有洞是否被石头覆盖的情况。

游戏的目标是让奶牛到达**每个可能的游戏状态**一次，最后回到初始状态。

以下是他们其中一次游戏的示例（空的洞用 `O` 表示，用石头盖住的洞用 `X` 表示）：

| 时刻 | 洞 1 | 洞 2 | 洞 3 | 描述 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | O | O | O | 一开始所有的洞都是空的 |
| $1$ | O | O | X | 盖上洞 3 |
| $2$ | X | O | X | 盖上洞 1 |
| $3$ | X | O | O | 打开洞 3 |
| $4$ | X | X | O | 盖上洞 2 |
| $5$ | O | X | O | 打开洞 1 |
| $6$ | O | X | X | 盖上洞 3 |
| $7$ | X | X | X | 盖上洞 1 |

现在牛被卡住玩不下去了！他们必须打开一个洞，然而不管他们打开哪个洞，他们都会到达一个他们已经到达过的状态。例如，如果他们从第二个洞中取出岩石，他们将到达他们在时刻 $2$ 已经访问过的状态（`X O X`）。

下面是一个 3 个孔的有效解决方案：

| 时间 | 洞 1 | 洞 2 | 洞 3 | 描述 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | O | O | O | 一开始所有的洞都是空的 |
| $1$ | O | X | O | 盖上洞 2 |
| $2$ | O | X | X | 盖上洞 3 |
| $3$ | O | O | X | 打开洞 2 |
| $4$ | X | O | X | 盖上洞 1 |
| $5$ | X | X | X | 盖上洞 2 |
| $6$ | X | X | O | 打开洞 3 |
| $7$ | X | O | O | 打开洞 2 |
| $8$ | O | O | O | 打开洞 1，恢复到原来的状态 |

现在，奶牛们厌倦了这个游戏，它们想找你帮忙。

给定 $n$，求游戏的有效解决方案序列。如果有多个解决方案，则输出**任意一个**。

## 说明/提示

#### 样例 1 说明

见题目描述。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le15$。

## 样例 #1

### 输入

```
3```

### 输出

```
OOO
OXO
OXX
OOX
XOX
XXX
XXO
XOO
OOO```

# 题解

## 作者：LF_Forever (赞：40)


仔细地审视题目，将 O 看作 0，将 X 看作 1，其实可以发现题目的意思是：


枚举所有 不重复的 n 位的二进制数，产生一个排列，使得每两个相邻的数码只有
一位不同。且这个排列的首尾都是 $(0)_{10}$ 。

因为题目说会有多组解，所以我们可以考虑一种构造的方法。

首先，当 $n=1$ 时，答案为：
```
0
1
```
最后再输出一个 0 。

从 $n=2$ 开始构造。我们可以考虑：将 $n=1$ 时的答案翻转过来，拼接在它原来答案的下面，变成了这样：
```
0
1
1
0
```
这时再将前一半的数码后面加上 0，后一半的数码后面加上 1，使它们两两不相等，于是，变成了这样：
```
00
10
11
01
```
我们现在惊奇地发现：枚举出来的数码恰好满足上述的条件。这时我们应另举一个例子 $n=3$，来验证一下。

翻转拼接 $n=2$ 时的答案：
```
00
10
11
01
01
11
10
00
```
再在各个数码的末尾添上 0 或 1：
```
000
100
110
010
011
111
101
001
```
现在，我们可以发现我们的结论是正确的了！

最后，贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mapp[70000][20],num=2;
int main()
{
	mapp[1][1]=0;mapp[2][1]=1;//储存 n=1 时的答案。
	scanf("%d",&n);
	for(int i=2;i<=n;i++){//由于每一个 i 都要用到 i-1 时的答案
		num*=2;       //所以需要算出 2 到 n 的所有答案
		for(int j=1;j<=num/2;j++){
			for(int k=1;k<i;k++)
			 mapp[num/2+j][k]=mapp[num/2-j+1][k];//翻转
		}
		for(int j=1;j<=num;j++)
		 if(j>num/2)mapp[j][i]=1;//后 num/2 位末尾为 1
		 else mapp[j][i]=0;//前 num/2 位末尾为 0
	}
	for(int i=1;i<=num;i++){
		for(int j=1;j<=n;j++)
  		 if(mapp[i][j])printf("X");//别忘记转换成 O 和 X。
		  else printf("O");
		printf("\n");
	}
	for(int i=1;i<=n;i++)printf("O");//补上最后的 0 。
	return 0;
}
```


---

## 作者：HsKr (赞：17)

一看到$N\le15$，就知道可以使用搜索。

思路：找到与当前只差一个的方案，判断是否走过，记录并输出。

Q：如何判断是否走过呢。

A：考虑转化，加入将O记为0，X记为1，这样每个状态都可以转化为一个二进制数，将他转换为十进制存储，判断也按十进制判断即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n;
int a[20];//记O为0，X为1
int vis[1<<20];
int ans[1<<20][20],tot=0;
void output(){//输出函数 
	for(int i=1;i<=1<<n;i++){
		for(int j=1;j<=n;j++){
			cout<<(ans[i][j]?'X':'O');
		}
		cout<<endl;
	}
}
int calc(){//将一个二进制数转化为十进制数 
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=ans*2+a[i];//常规操作 
	}
	return ans;
}
void dfs(int pos){
	if(pos==(1<<n)){//因为ans初始化时OOOOO...OO，所以最后留一组输出即可 
		output();//输出 
		exit(0);//SPJ，找到一组即可 
	}
	for(int i=1;i<=n;i++){
		a[i]=!a[i];//一位差别 
		if(vis[calc()]){//走过了 
			a[i]=!a[i];//还原 
			continue;//再见 
		}
		vis[calc()]=true;//记录，走过了 
		for(int j=1;j<=n;j++){
			ans[pos][j]=a[j];//存储答案 
		}
		dfs(pos+1);//继续搜索下一个 
		vis[calc()]=false;//回溯 
		a[i]=!a[i];//注意：不能颠倒，被坑了一次 
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cout<<'O';//输出 
	cout<<endl;
	vis[0]=true;//OOO.OOO不可再走 
	dfs(1); //从1开始搜索 
	return 0;
}

```

有点凑巧支出：本应该先输出，最后的一个`OOO...OOO`单独写，但由于ans初始为0，搜索次数少写一次，后面的的因为不会记录，还是`OOO...OOO`，正好符合题意。

---

## 作者：luckydrawbox (赞：9)

## 题意

求一个长度为 $n$ 的 ``OX`` 串的全排列，并要求：

$1.$ 第一个排列必须全是 ``O``。

$2.$ 除了最后一个排列外，每一个排列都不能重复。

$3.$ 相邻的排列只能有一个位置不一样。

$4.$ 遍历完所有排列后，还要能回到第一个排列。

## 分析

首先，看到数据范围 $(1≤n≤15)$，可以一眼看穿这就是个深搜，对于当前这个状态，不断修改他的每一位，标记为走过，再递归下去，因为第一个全是 ``O`` 的状态出现了两次，所以我们走到第一个状态时不需标记。然后可以发现，每个状态的每个位置都是由 ``O`` 或 ``X`` 组成，这不正是二进制吗？所以我们可以用一个整数来表示当前的状态，这个整数二进制状态下的每一位就代表一个 ``O`` 或 ``X``，如$9(1001)$代表 ``XOOX``。接着，我们再考虑深搜时剪枝，如果这个状态前面已经有过了，就剪枝。

最后，我们得出了正确做法：

$step\ 1:$ 深搜 $step\ 2\sim3$。

$step\ 2:$ 判断边界，如果每个状态都走了一遍，并回到起点，就输出，终止程序。

$step\ 3:$ 不断选择更改目前这个状态的每一位，如果这个状态没有走过，就标记这个状态，并存到答案的数组（记录每一步走的是哪个状态）中，把这个状态带到$step\ 1$递归下去，然后别忘了回溯。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=(1<<15)+1;//最多有2^15种状态 
int n,m,a[N];//n如题意，m为状态总数，a数组存储答案的每个状态 
bool b,c[N]={1};//b用于终止程序，c数组存储每个状态是否走过，c[0]提前标记，不然n=2,3会错
void pr()//输出 
{
	for(int i=0;i<n;i++)cout<<"O";cout<<endl;//第一个没有标记的状态要另外输出 
	for(int i=m-1;i>=0;i--)
	{
		for(int j=n-1;j>=0;j--)
		if((a[i]>>j)&1)printf("X");
		else printf("O");
		printf("\n");
	}
}
void dfs(int w)//深搜，w表示已经有了几个状态 
{
	if(b==1)return;//如果已经输出了就终止其他的dfs 
	if(w==m)//如果走完了所有状态 
	{
		if(a[m]==0)//如果最后又回到开始状态 
		{
			pr();//输出 
		    b=1;//标记为已经输出 
		}
		return ;
	}
	int v;//v表示目前状态改变后的状态的值 
	for(int i=n-1;i>=0;i--)
	{
		if((a[w-1]>>i)&1)v=a[w-1]-(1<<i);//把O改成X或把X改成O 
		else v=a[w-1]+(1<<i);
		if(!c[v])//如果修改后没有访问过 
		{
			c[v]=1;a[w]=v;//标记并存入答案 
			dfs(w+1);//搜索下去 
			c[v]=0;a[w]=0;//回溯千万别忘了 
		}
	}
}
int main()
{
    cin>>n;
    m=(1<<n);//总共有2^n种状态（不算第一种） 
    dfs(1);//第一种状态不搜索，因为已经确定，也不标记为走过 
	return 0;
}
```


---

## 作者：喵喵喵__ (赞：7)

# 本题的格雷码解法

- 格雷码是一种 `01` 二进制数编码，特点是相邻数值的格雷码仅有一位二进制位不同。

简单来说数值为 $k$ 的格雷码变化到 $k + 1$ 时只会改变一个 `01` 二进制位，比如$0 \leq k\leq 15$ 的格雷码是这样书写的：


| 自然数 |    普通二进制编码 |    格雷码 |
| :-----------: | :-----------: | :-----------: |
| 0 | 0000 | 0000 |
| 1 | 0001 | 0001 |
| 2 | 0010 | 0011 |
| 3 | 0011 | 0010 |
| 4 | 0100 | 0110 |
| 5 | 0101 | 0111 |
| 6 | 0110 | 0101 |
| 7 | 0111 | 0100 |
| 8 | 1000 | 1100 |
| 9 | 1001 | 1101 |
| 10 | 1010 | 1111 |
| 11 | 1011 | 1110 |
| 12 | 1100 | 1010 |
| 13 | 1101 | 1011 |
| 14 | 1110 | 1001 |
| 15 | 1111 | 1000 |


根据此特点，依次打印 $0,1,2,3,... ,2^n - 1$ 的格雷码即是本题答案。

那么我们如何知道值为K的格雷码是多少呢？

正好有个很方便的公式可以从数值的二进制数转换：

- 格雷码公式： $G_i = B_i \oplus B_{i+1}$  $( 0\leq i\leq n-1 )$ 

这个公式的意思是格雷码的第 `i` 位是由该数二进制第 `i` 位与第 `i+1` 位异或而来
比如自然数7二进制码转格雷码如图：

![可爱的图片](https://cdn.luogu.com.cn/upload/image_hosting/23tgjaqe.png)


- 最后我们用 `bitset` 取出二进制每一位

代码如下：
```cpp
#pragma warning(disable:4996)
#include<stdio.h>
#include<bitset>
std::bitset<20> bi;
int ppow(int a, int b) {
	int ans = 1;
	for (int i = a; b; i *= i, b >>= 1)
		if (b & 1)ans *= i;
	return ans;
}
int main() {
	int n = 0; scanf("%d", &n);
	for (int i = 0; i < ppow(2, n); i++) {
		bi = i;
		for (int j = n - 1; j >= 0; j--) {
			if (bi[j] ^ bi[j + 1])printf("X");
			else printf("O");
		}printf("\n");
	}
	for (int i = 0; i < n; i++)printf("O");//末尾还需一行
	return 0;
}

```





---

## 作者：2020ywj (赞：5)

#### 这是本蒟蒻的六个题解，不喜勿喷。

### 思路：

题目大意就是写出长度为n的X和O的所有排列，其中相邻的两个排列之间只能有一个数不同。

因为数据不是很大最多有2^15种排列，所以dfs就行。

只要每一次改变其中一个数，然后判断这种排列前面是否已经存在过，不存在就输出。

但每一次判断的时候是一个字符串，无论是空间上还是时间上都不是很好。于是有一个优化：吧‘O’看成0，'X'看成1，于是就变成了一个01串，即一个数的二进制。

于是我们只要尝试修改这个数的每一位，然后判断得到的新的数是否存在过就行。

### 代码：
```cpp
#include<cctype>
#include<cstdio>
#include<algorithm>
using namespace std;
long long read()
{
	long long ans=0;
	char ch=getchar(),last=' ';
	while(!isdigit(ch))
	{
		last=ch;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	if(last=='-') ans=-ans;
	return ans;
}
void write(long long x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x==0)
	{
		putchar('0');
		return;
	}
	int q[101],n=0;
	q[1]=0;
	while(x)
	{
		q[++n]=x%10;
		x /= 10;
	}
	while(n)
	{
		putchar('0'+q[n]);
		--n;
	}
}
int n;
bool vis[100001];
void print(int x)//从高位开始输出每一位
{
	vis[x]=1;
	for(register int i=n-1;i>=0;i--)
	{
		if((x>>i)&1) printf("X");
		else printf("O");
	}
	printf("\n"); 
}
void dfs(int st,int x)
{
	if(!vis[x]) print(x);//之所以放在这，而不是第53行之后，是为了输出最开始的OOOOOOO情况
	if(st==(1<<n)+1) exit(0);
	for(register int i=0;i<=n-1;i++)
	{
		int now=x^(1<<i);
		if(!vis[now]) dfs(st+1,now);
	}
}
int main()
{
	n=read();
	dfs(1,0);
	for(register int i=1;i<=n;i++) printf("O");
	return 0;
}
```
记得关注我哟！

[P6183 [USACO10MAR]The Rock Game S题目传送门](https://www.luogu.com.cn/problem/P6183)

---

## 作者：wuhan1234 (赞：3)

## 1.编程思路。

如果将空的洞 $O$ 表示为 $0$，用石头盖住的洞 $X$ 表示为 $1$，则输出的结果是 $2^n$ 个不同的 $n$ 位二进制串的排列（最后将第 $1$ 个字符串再输出 $1$ 次），并且在这 $2^n$ 个不同的 $n$ 位二进制串的排列中，相邻的两个二进制串间恰好有一位不同。

格雷码（Gray Code）正好是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同。

洛谷题库中，[P5657 [CSP-S2019] 格雷码](https://www.luogu.com.cn/problem/P5657)给出了一种格雷码的生成算法：

$1$ 位格雷码由两个 $1$ 位二进制串组成，顺序为：$0$，$1$。

$n$ 位格雷码的前 $2^{n-1}$ 个二进制串，可以由依此算法生成的 $n-1$ 位格雷码（总共 $2^{n-1}$ 个 $n-1$ 位二进制串）按顺序排列，再在每个串前加一个前缀 $0$ 构成。

$n$ 位格雷码的后 $2^{n-1}$ 个二进制串，可以由依此算法生成的 $n-1$ 位格雷码（总共 $2^{n-1}$ 个 $n-1$ 位二进制串）按逆序排列，再在每个串前加一个前缀 $1$ 构成。

按格雷码的生成算法生成 $2^n$ 个 $n$ 位二进制串，将它们依次输出就是本题的一种答案。

## 2.源程序。
```c
#include <stdio.h>
#include <string.h>
char s[32800][17]={0};
int main()
{
    int n;
    scanf("%d",&n);
    s[0][0]='O';
    s[1][0]='X';
    int i,j,w=1;
    for (i=1;i<n;i++)
    {
        w=w*2;
        for (j=0;j<w;j++)
        {
            strcpy(s[2*w-1-j],s[j]);
            s[j][i]='O';
            s[2*w-1-j][i]='X';
        }
    }
    for (i=0;i<2*w;i++)
        printf("%s\n",s[i]);
    printf("%s\n",s[0]);
    return 0;
}

```



---

## 作者：_FJX_ (赞：2)

题目大意：写出长度为 $n$ 的 X 和 O 的所有排列，其中相邻的两个排列之间只能有一个数不同。

由于数据很水，所以可以用 dfs 轻松水过。

为了方便理解：我们可以把 O 看成 0，X 看成 1，于是就变成了一个 01 串，即一个二进制数。

我们只要尝试修改这个数的每一位，然后判断得到的新的数是否存在过就行。

 _Code：_ 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
bool vis[100001];
void dy(int x)//从最高位开始逐位输出
{
	vis[x]=1;
	for(int i=n-1;i>=0;i--)
	{
		if((x>>i)&1) cout << "X";//用位运算还原 
		else cout << "O";
	}
	cout << "\n";
}
void dfs(int t, int x)
{
	if(! vis[x]) 
	{
		dy(x);
	}
	if(t == (1 << n) + 1) 
	{
		exit(0);
	}
	for (int i = 0; i < n; i ++)
	{
		int nw = x ^ (1 << i);
		if(!vis[nw])
		{
			dfs(t + 1, nw);
		} 
	}
}
int main(){
    ios_base::sync_with_stdio(false);
	cin.tie (0);
	cout.tie (0);
	cin >> n;
	dfs(1,0);
	for (int i = 1; i <= n; i ++)
	{
		cout << "O";
	}
	return 0;
}

```


---

## 作者：HyyypRtf06 (赞：2)

一个新思路（非DFS）：

1. 预处理出 $n$=$2$ 和 $n$=$3$ 的[表](https://www.luogu.com.cn/paste/no17le2r)（用`string`数组储存）。

2. 将 $n$ 分解成 $p$ 个 `2` 和 $q$ 个 `3` 之和，其中 $p \ q$ 均为非负整数。（ $n$=$1$ 自行打表 ）。

3. 利用第一步预处理出来的表构造出步骤，举例说明一下：

例子：
```
input:
4
```
分析：
```
4=2+2
所以先行构造出初始状态：（为理解需要中间有空格）
1：OO OO
接下来用 n=2 的表构造第二部分（最后一部分）
2：OO OX
3：OO XX
4：OO XO
第二部分套完了，复原并开始构造第一部分（倒数第二部分），注意，倒数第二部分每构造一次就要将第二部分完整地再次构造一遍
5：OX OO//但是这里明显和上面对不上怎么办？很简单，反转预处理出来的表之后再构造，即构造成：
6：OX XO 
然后
7：OX XX
8：OX OX
9：OX OO
10：XX OO
//此处省略过程，直接跳到倒数第二步
?：XO OO
?：OO OO
```
解释一下为什么在第5次需要反转一下再接着构造：
因为第一部分在第5步需要翻转，所以第二部分就不能翻转了，不能翻转意味着保持原型，所以反转之后再构造就可以很轻松地弥补这个问题。

因为本蒟蒻能力有限（最近才回归你谷），只能提供一份可读性很差的代码，但思路就是上文所介绍的方法，而且还加了一个特判结束构造。会改进的(ง •_•)ง

[代码戳这里](https://www.luogu.com.cn/paste/q6ef7zot)

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

有 $n$ 个孔，每个孔可以覆盖或开启，求所有覆盖状态。

### 题目分析

本题可以使用递归求解。

首先来想暴力一点的，我们直接枚举每种情况就好了，但是根据题意，我们要顺序输出每个状态，换句话说，就是相邻的两个状态只能有 $1$ 位不同。

于是我们可以回归最开始的思路——递归。我们可以考虑对于每个状态，枚举不同的那一位，然后判断如果改变这位后的状态没经历过就往下走。

不难证明这样找下去一定会找到一组解。

### 优化

- 状态：

最原始的存状态的方法就是用二进制存，我们可以使用数组或字符串，对于重复的情况，可以开 `map` 来记录。

我将在这里补充十进制存储。

我们可以直接将状态中的 `O` 记为 $1$，`X` 记为 $0$，再讲二进制转为十进制存储，然后使用位运算进行原有的二进制操作。

对于输出：我们可以考虑暴力一点的方法，枚举二进制中的倒数第 $i$ 位，对应到十进制中就是 $2^i$，在输出这一位是我们可以将其转换为 `x & (1 << (i-1))`。很容易理解，`&` 符，相同为 $1$，否则为 $0$，`(1 << (i-1))` 中只有第 $i$ 位为 $1$，于是，当 $x$ 的第 $i$ 位为 $1$ 时，返回 $1$，否则为 $0$。

对于更改，可以写成 `x ^ (1 << (i-1))`，同理，异或符号，相同返回 $0$，不同返回 $1$。第 $i$ 位，`1 << (i-1)` 的第 $i$ 位为 $1$，相当于翻转了 $x$ 的第 $i$ 位。对于其他位，`1 << (i-1)` 的其他位为 $0$，相当于 $x$ 的其他位没动。

- 递归：

对于每个状态，我们只需要找到下一个状态就可以了，不用考虑当前状态，所以递归甚至可以优化为 $\operatorname{while}$ 循环，从而节省时间。

理论上来讲，总的时间复杂度都是 $\mathcal O(2 ^ n \times n)$ 的（每个状态 $\mathcal O(n)$ 输出）。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
bool cnt[(1 << 15) + 5];
void out(int x)
{
	for(int i = n - 1;i >= 0;i--)
		printf((x & (1 << i)) ? "X" : "O");
	printf("\n");
	return ;
}
bool dfs(int x)
{
	if(cnt[x])	return false;
	cnt[x] = true, out(x);
	for(int i = 0;i < n;i++)
		if(dfs(x ^ (1 << i)))
			return true;
	return true;
}
int main()
{
	scanf("%d", &n);
	dfs(0);
	for(int i = 1;i <= n;i++)
		printf("O");
	printf("\n");
	return 0;
}
```

---

## 作者：ccg12345 (赞：1)

## 法一：深搜

看到数据范围 $n \le 15$，便很容易想到要用搜索，首先把 O 看成 $0$，把 X 看成 $1$，即将其看为一个二进制数，尝试修改这个数，判断是否重复即可。

代码就不贴了，可以参考题解区其他大佬的代码。我主要想说一下第二种方法。

## 法二：用格雷码

首先来道可以参考的 [题](https://www.luogu.com.cn/problem/P5657)，做这道题之前可以先把那道题做完。

格雷码：如果将 $2^n$ 个长为 $n$
 的二进制串组成一个序列，使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为 **$n$ 阶格雷码**或简称**格雷码**。在格雷码中，任意两个相邻的代码只有一位二进制数不同，最大码与最小码之间也仅一位不同，即首尾相连，因此又称**循环码**或**反射码**。

格雷码的生成算法：在刚才所说的那一题中已经明确写出了，这里就不多叙述。

附代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[50000][20] = {};
int n, cnt = 1;
int main()
{
	a[0][0] = 'O';
	a[1][0] = 'X';
	cin >> n;
	for(int i = 1; i < n; i++)
	{
		cnt *= 2;
		for(int j = 0; j < cnt; j++)
		{
			strcpy(a[2 * cnt - j - 1], a[j]);
			a[j][i] = 'O';
			a[2 * cnt - j - 1][i] = 'X';
		}
	}
	for(int i = 0; i < 2 * cnt; i++)
		cout << a[i] << endl;
	cout << a[0] << endl;
	return 0; 
} 
```


---

## 作者：JLGxy (赞：1)

本题可以将 `X` 看做 `1`，`O` 看做 `0`，然后可以用格雷码解决。

格雷码是一个二进制数系，其中两个相邻数的二进制位只有一位不同。例如 $3$ 位二进制数的格雷码序列为 $000,001,011,010,110,111,101,100$。

格雷码可以递归构造：
$k$ 位格雷码可以从 $k-1$ 位格雷码上下镜像翻转，然后在末尾添加上新位得到。

例如我们有 $1$ 位格雷码：
$$
\begin{aligned}
0\\
1\\
\end{aligned}
$$
上下翻转：
$$
\begin{aligned}
0\\
1\\
\color{red}1\\
\color{red}0\\
\end{aligned}
$$
在末尾添加新位，具体来说，前一半后面都加上 $0$，后一半上面加上 $1$：
$$
\begin{aligned}
0\color{red}0\\
1\color{red}0\\
1\color{red}1\\
0\color{red}1\\
\end{aligned}
$$
这样就得到了 $2$ 位格雷码。

还有另一种比较简单的构造方式，我们观察二进制下 $n$ 与第 $n$ 个格雷码的关系，以 $3$ 位为例：
$$
\begin{aligned}
000&~~000\\
001&~~001\\
010&~~011\\
011&~~010\\
100&~~110\\
101&~~111\\
110&~~101\\
111&~~100
\end{aligned}
$$
我们发现，格雷码的第 $i$ 位为 $1$ 当且仅当 $n$ 的第 $i$ 位与第 $i+1$ 位不同，于是有 $G(n)=n\oplus(n>>1)$。

Code:
```cpp
#include<iostream>
using namespace std;
int n;
inline int g(int i) { return i^(i>>1); }
void print(int x)
{
    for(int i = n-1; i >= 0; i--) cout << ((x&(1<<i))?'X':'O');
    cout << endl;
}
int main()
{
    cin >> n;
    for(int i = 0; i < (1<<n); i++)
        print(g(i));
    for(int i = 0; i < n; i++)
    	cout << "O";
    return 0;
}
```

---

## 作者：cff_0102 (赞：1)

首先看到题目想起的是[这题](https://www.luogu.com.cn/problem/P5657)。很明显这题可以用格雷码解决。那么套上格雷码的专属公式 $G_k=k\oplus\lfloor\frac{k}{2}\rfloor$（原因见最后），再换成 `X` 和 `O` 就可以了。

如何把一个十进制的整数 $x$ 转成一个 $n$ 位的二进制数？只需要 `while(n--)cout<<((x>>n)&1);` 就行了。原理就是 `x>>n` 结果相当于 $\frac{x}{2^n}$ ，最低位变成原本的数在二进制下的第 $2^n-1$ 位，再 `&1` 取最低位就只剩下二进制下的第 $2^n-1$ 位了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(false);
	int a;cin>>a;
	for(int k=0;k<=(1<<a)/*1<<a=pow(2,a)但更快*/-1;k++){
		int n=a,x=k^(k>>1)/*k>>1=k/2但更快*/;
		while(n--)cout<<((((x>>n)&1)==0)?'O':'X');//如果G_k这一位是0就输出O（未覆盖），否则就是X（覆盖） 
		cout<<endl;//不要忘了 
	}//输出完后记得多输出一个全是O的
	while(a--)cout<<'O'; 
	return 0; 
}//主要注意的是优先级问题，多打几个括号可以完全避免 
```

[关于为什么 $G_k=k\oplus\lfloor\frac{k}{2}\rfloor$](https://blog.csdn.net/Omigeq/article/details/126131458?spm=1001.2014.3001.5502)，这个博客推荐看看，这里不赘述了。

---

## 作者：zbk233 (赞：1)

## 题意简述

给定一个长度为 $n$ 的 ```OX``` 串。且每个元素的初始状态都为 ```O```

- 每次任意选择改变一个元素，使这个元素变为相反的数。即 ```O``` 变为 ```X```，```X``` 变为 ```O```。

- 遍历每一种可能产生的情况，但是不能重复，且最后能回到原来状态。

## 前置知识

格雷码：在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码。

要从对应的 $n$ 位二进制码中直接得到 $n$ 位格雷码，步骤如下：

对 $n$ 位二进制码，从右到左，以 $0$ 到 $n-1$ 编号。


如果二进制码的第 $i$ 位和 $i+1$ 位相同，则对应的格雷码的第 $i$ 位为 $0$，否则为 $1$（当 $i+1=n$ 时，二进制码字的第 $n$ 位被认为是 $0$，即第 $n-1$ 位不变）

公式表示：$G_i$ $=$ $B_i$ $⊕$ $B_{i+1}$（G：格雷码，B：二进制码）

![](https://cdn.luogu.com.cn/upload/image_hosting/237gry4w.png)

## 解题思路

看过了题目之后，再联系上面介绍的格雷码，很容易想到这两者之间的共同点：

- 每次只改变一个元素。

- 会不重复地遍历到所有可能的情况。

- 最后一个输出的结果正好离初始状态只需要改变一个元素。

而既然要不重复地遍历每一个可能的情况，输出的行数一定是 $2^n$。但这题的初始状态会在输出的开始和结束各输出一次，那么输出的行数就应该是 $2^n+1$。

我们考虑将初始状态单独输出。

那么我们就需要把 $[1,2^n-1]$ 内的所有数字转化为二进制，再求出它们的格雷码，最后只需把格雷码按题目要求转化为 ```OX``` 串输出即可。

## 参考代码

```cpp
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
bool b[105];
bool g[105];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, ed;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cout << 'O';
	}
	cout << '\n';
	ed = pow(2, n);
	for (int i = 1; i < ed; i++)
	{
		memset(b, 0, sizeof(b));
		memset(g, 0, sizeof(g));
		int tmp = i, len = n;
		while (tmp)
		{
			b[len--] = tmp & 1;
			tmp = tmp >> 1;
		}
		for (int j = 1; j <= n; j++)
		{
			g[j] = b[j] ^ b[j - 1];
			if (g[j] == 1)
			{
				cout << 'X';
			}
			else
			{
				cout << 'O';
			}
		}
		cout << '\n';
	}
	for (int i = 1; i <= n; i++)
	{
		cout << 'O';
	}
	return 0;
}
```


---

## 作者：Snow_Dreams (赞：0)

这道题可以用打表，递推，dfs，bfs

打表就是（建议）用python输出1~15的情况，然后就打表就好了（不多作介绍，不是正解）

递推就是从N=1的情况一步一步推，要练习，可以写NOIP2019的提高组签到题：格雷码

dfs（正解）：

通过一个vis数组来保存状态，接着用结构体来保存顺序，然后最后输出按id排序的结构体

bfs：

本质和dfs略有区别，但执行方式一模一样，所以就不多说了

附上一份dfs模板代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记
int map[maxn][maxn]; // 坐标范围
int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量，(x,y)周围的四个方向

bool CheckEdge(int x,int y) // 边界条件和约束条件的判断
{
if(!vst[x][y] && ...) // 满足条件
return 1;
else // 与约束条件冲突
return 0;
}

void dfs(int x,int y)
{
vst[x][y]=1; // 标记该节点被访问过
if(map[x][y]==G) // 出现目标态G
{
...... // 做相应处理
return;
}
for(int i=0;i<4;i++)
{
if(CheckEdge(x+dir[i][0],y+dir[i][1])) // 按照规则生成下一个节点
dfs(x+dir[i][0],y+dir[i][1]);
}
return; // 没有下层搜索节点，回溯
}
int main()
{
......
return 0;
}

```


---


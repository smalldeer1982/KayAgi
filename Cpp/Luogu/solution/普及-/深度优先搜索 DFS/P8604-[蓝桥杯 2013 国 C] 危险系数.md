# [蓝桥杯 2013 国 C] 危险系数

## 题目背景

抗日战争时期，冀中平原的地道战曾发挥重要作用。


## 题目描述

地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。

我们来定义一个危险系数 $DF(x,y)$：

对于两个站点 $x$ 和 $y(x\neq y),$ 如果能找到一个站点 $z$，当 $z$ 被敌人破坏后，$x$ 和 $y$ 不连通，那么我们称 $z$ 为关于 $x,y$ 的关键点。相应的，对于任意一对站点 $x$ 和 $y$，危险系数 $DF(x,y)$ 就表示为这两点之间的关键点个数。

本题的任务是：已知网络结构，求两站点之间的危险系数。

## 说明/提示

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
7 6
1 3
2 3
3 4
3 5
4 5
5 6
1 6```

### 输出

```
2```

# 题解

## 作者：chen_z (赞：55)

 _蒟蒻的第一篇题解_ 

[题目传送门](https://www.luogu.com.cn/problem/P8604)

---

**题意简析**
1. 共有 $n$ 个点，$m$ 个通道（无向）。
2. 给出起点 $u$ ，终点 $v$。求这两点之间，有多少个点删去后就能使这两点不连通。
3. 如果 $u$ 和 $v$ 之间没有路径连通，输出'$-1$'。

------------

### 算法思路

>可以使用 dfs（深度优先搜索）求解，求出 $u$ 到 $v$ 间的每一条路径，将路径总数统计，并将被经过的点被经过总数加一。如果一个点被经过的次数与总路径条数相等，那么这一个点就是 $u$ 和 $v$ 的关键点。

举个栗子：
点 $1,2,3,4,5$ 中， $1$ 到 $5$ 有两条路径：

```latex
1 -> 2 -> 3 -> 4 -> 5

1 -> 2 -> 4 -> 5
```

**其中除去 $1$ , $5$ 有 $2$ 和 $4$ 两个点被经过两次，所以 $2$ 和 $4$为关于 $1$ 和 $5$ 的关键点，危险系数为 $2$。**


- 另外，最后统计被经过的次数与总路径条数相等的点得个数时，起点 $u$ 和终点 $v$ 不计算在内。


### 代码注释：

> $n$, $m$, $u$, $v$ 如题面， $ans$ 存危险系数， $cnt$ 为dfs时记录这个点被走过的总次数， $sum$ 为路径总数 。
>
> $a$ 为邻接矩阵，存连通情况， $1$ 为连通，也可以使用 vector 邻接表来存储 ； $bj$( $biaoji$) 为 dfs 时记录这个点是否被走过的 。

## 代码： 
```cpp
#include<bits/stdc++.h>
#define LL long long
#define made return
#define in 0
#define China ;
using namespace std;
LL n,m,u,v,ans,cnt[1010],sum;
bool bj[1010],a[1010][1010];
void dfs(LL now){
	if(now==v){//如果走到终点了， 
		sum++;//路径总数加一。 
		for(int i=1;i<=n;i++)
			if(bj[i]==1)cnt[i]++;//每个被走过的点，被走总次数加一 
	}
	else{
		for(int i=1;i<=n;i++)
			if(a[now][i]==1&&bj[i]==0){//如果两点连通且下一步要走到的点未被走过， 
				bj[i]=1;//标记。
				dfs(i);
				bj[i]=0;//回溯一步。 
			}
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	while(m--){
		scanf("%lld%lld",&u,&v);
		a[u][v]=a[v][u]=1;//输入邻接矩阵。因为是无向的，所以u到v和v到u都要设为1。 
	}
	scanf("%lld%lld",&u,&v);
	dfs(u);
	if(sum>0){//dfs求解
		for(int i=1;i<=n;i++)
			if(cnt[i]==sum)ans++;//如果这个点被走过的总次数与路径总数相等，那么删去这个点起点与终点间一定不连通。 
		printf("%lld",ans-1);//因为起点也被算在内，所以总危险系数要减去起点的1。 
	}
	else printf("-1");//如果询问的两点无路径连通则输出'-1'。
	made in China 
}
//made in China. 中国制造。
```

---

## 作者：linyukun (赞：14)

### [题目](https://www.luogu.com.cn/problem/P8604)


------------ 
在审完题之后，我们会发现：$n$ 在 $1000$ 以内，所以**一个 $O(n^2)$ 的复杂度是可以被接受的**。既然这样，就让我们请出老朋友：**暴力枚举**吧！

怎么枚举呢？我们就将每一个点都设置为 $z$，看能否从 $x$ 走到 $y$。为了防止超时，这里**使用时间复杂度更低的 BFS 判断联通**，只要搜到了 $y$（从 $x$），一定有路。搜不到的数量就是答案了。

## 注意事项：
- 队列不要定义在函数里，这是未定义行为。

- 输出 $-1$ 和 $0$ 的情况一定要区别（好像没有测试点），**$-1$ 是过不去，$0$ 是没有 $z$**。

- 无向图**标记走过的边时一定要把回去的路也标上**。



------------
代码及解释都在下面了哦。
```cpp
#include<bits/stdc++.h>
using namespace std;
bool lu[1005][1005],lu2[1005][1005];//邻接矩阵和临时存储（1有0无边）
int x,y,n,m,cnt;//cnt计数，其他题面有
queue<int>ans;
bool f(int z){//使用BFS来进行判断
	while(!ans.empty())ans.pop();
	ans.push(x);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			lu2[i][j]=lu[i][j];//防止原矩阵被破坏
		}
	}
	//ans里的是起点
	while(!ans.empty()){
		for(int i=1;i<=n;i++){//然后枚举终点
			if(lu2[ans.front()][i]==1&&i!=z&&ans.front()!=z){//有路且不含Z
				if(i==y)return 0;//优化，否则#5TLE
				ans.push(i);
				lu2[ans.front()][i]=0;
				lu2[i][ans.front()]=0;
			}
		}
		ans.pop();
	}
	return 1;
}
int main(){
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>x>>y;
		lu[x][y]=1;
		lu[y][x]=1;//地道是无向的
	}
	cin>>x>>y;
	if(f(0)==1){//不删都到不了的情况
		cout<<-1;
		return 0;
	}
	for(int z=1;z<=n;z++){//枚举删除点
		if(z!=x&&z!=y){
			if(f(z)){
				cnt++;
			}
		}
	}
	cout<<cnt;
    return 0;
}
```
 _谢谢观看。_ 

---

## 作者：pxb0801 (赞：12)

 ~~说句闲话，《地道战》似乎是我小学时语文老师喊我们看过的电影。~~

### 好了，现在进入正题。

--------------

## 1.题目大意:

给你 $n$ 个点，$m$ 条边。**注意：这里是双向边。** 再给定起点和终点，求从起点到终点必须经过点的个数。

--------------
## 2.分析：

这道题的 $n$ 和 $m$ 都很小，可以用深搜做。

首先，深搜的变量有两个：$x$ 表示当前所在的结点编号； $cnt$ 表示从起点到 $x$，这是走的第几步。所以，递归调用就出来了：

```cpp
dfs(sx/*这是起点*/,0);
```

我们用 $flag[]$ 表示当前这个点是否走过，防止无穷递归。接下来，我们设一个 $a[]$，表示当前这一步是哪个点。这样，深搜框架就搭好了：

```cpp
void dfs(int x,int cnt){
	a[cnt]=x;
	flag[x]=1;
	if(x==ex){//到达终点，返回
   		……
   		return;
	}
	int l=g[x].size();//vector存图
	for(int i=0;i<l;i++){
		int y=g[x][i];
		if(!flag[y]){//如果这个点没走过就走
			dfs(y,cnt+1);
		}
	}
	a[cnt]=0;
	flag[x]=0;//回溯
}
```

现在，有同学就发现，返回这里省略了。哦，我们答案没法输出啊。

我们可以这么办：**对于每种到达终点的路线，每一步都对应唯一的点。如果所有的路线都经过了一个点，说明这个点一定得走到。**

于是，省略的部分出来了：

```cpp
s++;
for(int i=0;i<=cnt;i++){
	t[a[i]]++;
}
a[cnt]=0;
flag[x]=0;
```

这里的 $s$ 表示方案总数，$t[]$ 表示对于每个点，它在多少种方案里。

注意两点：这里的 $i$ 从 $0$ 开始，因为深搜最开始存就是从 $a_0$ 开始的；其次就是循环完也还要回溯，不然就永远到不了终点了（因为终点打上标记了）。

最后的输出就很简单了：

```cpp
for(int i=1;i<=n;i++){
	if(t[i]==s){
		ans++;
	}
}
cout<<ans-2;
```

只需注意一点：由于起点和终点不算，所以 $ans$ 要减 $2$。

完整代码就不给啦，记得加双向边哦~

---

## 作者：WA_sir (赞：10)

## [题目链接](https://www.luogu.com.cn/problem/P8604)

这道题，由于 $n$ 和 $m$ 都不大，可以使用 dfs 进行搜索。

虽然我们可以用一个 $1000\times1000$ 的二维数组来存点之间的关系，但一个 vector 一维数组也可以达到同样的效果。

$b$ 表示从 $x$ 到 $y$ 的路径数量， $ans[i]$ 表示点 $i$ 在点 $x$ 到点 $y$ 的所有路径中出现了几次。如果一个点出现次数恰好和总路径数相等，则这个点必然是点 $x$ 和 $y$ 的关键点。

另外，因为 $x$ 和 $y$ 不计入关键点，所以在输出答案时不计入这两个点。代码中排除了 $y$，但计入了 $x$，所以最后输出答案要减一。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
vector<int>a[N];//a[i]表示所有与i点相连通的点
int n,m,x,y,b,ans[N],M,ans_end;//见上描述
bool t[N];
void dfs(int dq){
	if(dq==y){
		b++;
		for(int i=1;i<=M;i++)ans[i]+=t[i]?1:0;
		return;
	}
	t[dq]=true;
	for(auto to:a[dq]){
		if(t[to])continue;
		dfs(to);
	}
	t[dq]=false;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,xa,ya;i<=m;i++){
		scanf("%d%d",&xa,&ya);
		a[xa].push_back(ya);//存入
		a[ya].push_back(xa);
		M=max(max(M,xa),ya);
	}
	scanf("%d%d",&x,&y);
	dfs(x);
	for(int i=1;i<=M;i++)if(ans[i]==b)ans_end++;
	printf("%d",ans_end-1);//见上描述
	return 0;
}
```
感谢阅读！QAQ

---

## 作者：zhangyuanxiao (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P8604)

## 题意
- 给出地道的站点数 $n$，通道数 $m$，每条通道连接的站点 $u,v$。
- 定义危险系数 $DF(x,y)$ 为：站点 $z \in [1,n]$ 且 $x \ne y \ne z$ 被破坏掉后（即去掉所有与这个点相连的边），使站点 $x,y$ 不连通的 $z$ 的个数。
- 输入的最后一行，给出 $u,v$，求 $DF(u,v)$。若没有站点被破坏时 $u,v$ 不连通，则输出 $-1$。
- $2 \le n \le 1000$，$0 \le m \le 2000$，$1 \le u,v \le n$，$u \ne v$。

## 分析
因为本题 $n,m$ 范围较小，可以用广度优先搜索解决问题，用 $ans$ 记录答案。首先进行一遍广搜，检查 $u,v$ 是否相连。如不相连直接输出 $-1$，否则每次将一个不是 $u,v$ 的站点所连接的所有通道切断，用广搜检查 $u,v$ 是否相连。如不相连，则 $ans \gets ans+1$。每次广搜后一定要记得清空队列！**广搜的细节看代码。**

## 代码
```cpp
#include<queue>
#include<vector>
#include<memory.h>
#include<iostream>
using namespace std;

const int MAXN=2e3+5;
int n,m,i,bl,ans,vis[2005];//vis数组标记每个点有没有经过
queue<int> q;
vector<int> a[MAXN];//邻接表存图

void clear(){//清空队列
    while(!q.empty()) q.pop();
    return;
}

void bfs(int s,int e){
    vis[s]=1;
    q.push(s);
    while(!q.empty()){
        s=q.front();
        for(int j=0;j<a[s].size();j++){
            if(a[s][j]==i || vis[a[s][j]]) continue;
            //i点是被破坏的站点，不能经过
            //如果已经有路径经过a[s][j]点，就不用再搜索了
            q.push(a[s][j]);
            vis[a[s][j]]=1;
            if(a[s][j]==e){
                bl=1;//bl：s,e相连为1，否则为0
                clear();//清空队列
                return;
            }
        }
        q.pop();
    }
    return;
}

int main(){
    cin>>n>>m;
    while(m--){
        int u,v;
        cin>>u>>v;
        a[u].push_back(v);
        a[v].push_back(u);
    }
    int u,v;
    cin>>u>>v;
    bfs(u,v);
    if(!bl){//u,v不相连，输出-1
        cout<<-1;
        return 0;
    }
    for(i=1;i<=n;i++){
        if(i==u || i==v) continue;
        bl=0;//要重置为0
        memset(vis,0,sizeof(vis));//记得清空vis数组
        bfs(u,v);
        if(!bl) ans++;//u,v在站点i被破坏时不相连，危险系数加一
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：loser_seele (赞：4)

怎么全都是暴力题解，介绍一个线性时间复杂度的做法。

首先用 Tarjan 算法求出原图的所有割点，不会的左转 [P3388](https://www.luogu.com.cn/problem/P3388)。

再考虑一个点成为路径上割点的充要条件：

能到达终点的点，这点显然。

对于一个点，不存在一个子树里的节点能到达当前点无法到达的不在这个点子树中的点。

首先充分性是显然的，因为可以通过这个更早的点走到其子树中绕路越过这个割点。必要性也不难证明，如果子树中不存在能到达更早的节点的点，则必须要经过这个点才能到达其子树。

于是求出所有割点之后直接判断所有子树点是否满足条件即可，判断是否在其子树可以直接比较其 $ dfn $，能到达的最早点可以比较 $ low $，第一步求出所有割点是 $ \mathcal{O}(n+m) $ 的，第二步最差情况下需要判断图中所有的节点，于是是 $ \mathcal{O}(n+m) $ 的，所以总复杂度是 $ \mathcal{O}(n+m) $，可以通过。目前是最优解。

另外也可以用 [这题](https://www.luogu.com.cn/problem/P5489) 的思路，用 LCT 实现动态查询两点间割点数量，但是复杂度不是很优秀，所以不详述，有兴趣的话可以找原题题解。

代码：

```cpp
#import <bits/stdc++.h>
using namespace std;
const int maxn = 1000+50;
const int maxm = 2000000+50;
int head[maxn],tot,st,ed;
int cnt,dfn[maxn],low[maxn];
bool reachEd[maxn];
set<int> ans;
struct Node
{
    int to,Next;
}node[maxm];
void initEdge()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}
void addedge(int from,int to)
{
    node[tot].to = to;
    node[tot].Next = head[from];
    head[from] = tot++;
}
void init()
{
    cnt = 0;
    memset(dfn,0,sizeof(dfn));
    memset(reachEd,false,sizeof(reachEd));
    ans.clear();
}
void tarjan(int x,int root,int fa_x)
{
    dfn[x] = low[x] = ++cnt;
    int child = 0;
    for(int i=head[x];i!=-1;i=node[i].Next)
    {
        int to = node[i].to;
        if(!dfn[to])
        {
            ++child;
            tarjan(to,root,x);
            low[x] = min(low[x],low[to]);
            if(to==ed||reachEd[to]) 
            reachEd[x] = true;
            if(x==root&&child>=2) 
            ans.insert(x);
            if(x!=root&&low[to]>=dfn[x]) 
            ans.insert(x);
        }
        else if(to!=fa_x)
            low[x] = min(low[x],dfn[to]);
    }
}
int main()
{  
    int m,n,u,v,ca=0;
    while(cin>>n>>m)
    {
        initEdge();
        for(int i=0;i<m;++i)
        {
            scanf("%d%d",&u,&v);
            addedge(u,v);
            addedge(v,u);
        }
        scanf("%d%d",&st,&ed);
        if(ca++)
        init();
        tarjan(st,st,st);
        reachEd[ed] = true;
        int res = 0;
        for(auto x:ans)
        {
            if(x==ed||x==st||!reachEd[x]) 
            continue; 
            int add = 0;
            for(int i=head[x];i!=-1;i=node[i].Next)
            {
                int to = node[i].to;
                if(low[to]>=dfn[x]&&reachEd[to])
                {
                    add = 1;
                    break;
                }
            }
            res += add;
        }
        printf("%d\n",res);
    }
}
```


---

## 作者：5k_sync_closer (赞：3)

题意：给定一张无向图和点 $s,t$，求有多少个点 $x$ 使得删去点 $x$ 后 $s,t$ 不连通。
# 思路
观察到 $n,m$ 很小，考虑暴力做法。

枚举每个点作为 $x$，$O(n+m)$ 跑一遍 BFS 验证不经过 $x$ 时 $s,t$ 是否连通。

BFS 时避免扩展点 $x$ 即可保证 $s\to t$ 的路径不经过 $x$。
```cpp
#include <queue>
#include <cstdio>
using namespace std;
struct E{int v, t;}e[4050];queue<int> q;
int n, m, u, v, s, t, p, c, h[1050];bool d[1050];
void A(int u, int v) {e[++c] = {v, h[u]};h[u] = c;}
bool F(int x)
{
	for(int i = 1;i <= n;++i) d[i] = 1;
	d[s] = 0;q.push(s);while(!q.empty())
	{
		int u = q.front();q.pop();if(u != x)
		for(int i = h[u], v;i;i = e[i].t) if
		(d[v = e[i].v]) d[v] = 0, q.push(v);
	}
	return d[t];
}
int main()
{
	scanf("%d%d", &n, &m);while(m--) scanf
	("%d%d", &u, &v), A(u, v), A(v, u);scanf
	("%d%d", &s, &t);if(F(0)) return puts("-1")
	, 0;for(int i = 1;i <= n;++i) p += i != s
	&& i != t && F(i);return printf("%d", p), 0;
}
```


---


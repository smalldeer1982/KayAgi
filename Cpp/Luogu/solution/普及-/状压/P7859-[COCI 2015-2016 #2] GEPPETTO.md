# [COCI 2015/2016 #2] GEPPETTO

## 题目描述

Geppetto 开了一家披萨店，他正在努力做出全市最好的披萨。

Geppetto 用 $N$ 种原材料做比萨，每种原材料只有一个。原材料标号为 $1$ 到 $N$。做披萨很简单，只要把原材料混合好然后放进烤箱里烤一烤就行了。但 Geppetto 发现一共有 $M$ 对原材料是冲突的，如果一对冲突的原材料混合在一份披萨里，这份披萨就会变得十分难吃。这给他带来了额外的麻烦。

Geppetto 想知道他最多能做多少种不同的比萨。如果一份比萨上有编号为 $i$ 的原材料，而另一份比萨上没有，那么这两份比萨就是不同的。

## 说明/提示

**【样例 1 解释】**

Geppetto 可以做出以下 `4` 种披萨：

`1`

`2`

`3`

`1 3`

不过因为 Geppetto 可以不放原材料，所以最多可以做出 `5` 种披萨。

**【样例 2 解释】**

没有原材料冲突，所以一共可以做出 $2^3=8$ 种披萨。

**【样例 3 解释】**

由于所有原材料都互相冲突，所以 Geppetto 只能放一种原材料或者不放原材料，一共可以做出 $1+3=4$ 种披萨。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 20，0\le M\le 400，1\le x_i,y_i\le N$，**保证 $x_i\ne y_i$**。

**【说明】**

**本题数据点得分依原题，满分 80**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T2 GEPPETTO**。

## 样例 #1

### 输入

```
3 2
1 2
2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
3 0```

### 输出

```
8```

## 样例 #3

### 输入

```
3 3
1 2
1 3
2 3```

### 输出

```
4```

# 题解

## 作者：tuxuanming2024 (赞：30)

## 前置知识：位运算

- 左移运算：`<<`

用法： `x<<y`

作用：将表示 $ x $ 的二进制数的每一位左移 $ y $ 位，移出去的数就丢掉，空余地方用 $ 0 $ 补位。

例如：一个二进制数 $ 10101011 $ 将其左移 $ 3 $ 位，得到 $ 01011000 $。

- 按位与运算： `&`

用法：`x&y`

作用：按位进行与运算。

例如：$ 1101 $ 和 $ 0011 $ 进行与运算就为：$ 0001 $。

利用上面的两种运算，我们就可以来判断一个二进制数的某位是 $ 0 $ 或 $ 1 $ ，假设我们要判断 $ x $ 的从右到左第 $ n $ 的数字，只需判断 `x&(1<<(n-1))` 是真还是假即可。因为对于 `1<<(n-1)` 所算出来的数，除了从右到左第 $ n $ 位，其他的都是 $ 0 $，再与 $ x $ 进行与运算，如果 $ x $ 的第 $ n $ 位是 $ 1 $，那么 `1&1` 的结果为 $ 1 $ ，反之则为 $ 0 $。

## 题解

令一个二进制数的第 $ i $ 位表示：

$$ \begin{cases}0 \ \ \text{不放第 i 种材料}\\1 \ \  \text{放第 i 种材料}\end{cases} $$

所以，我们只需要枚举这样的二进制数，从 $ 0 $ 枚举到 `(1<<n)-1` ，再用位运算依次判断是否冲突即可。

$ \color{white}\colorbox{green}{AC} $ Code：

```cpp
#include <iostream>
using namespace std;
struct node {int x,y;}b[405];
int n,m,a[405],ans;
bool c[25][25];
int main()
{
	cin>>n>>m;
	int x,y;
	for(int i=1;i<=m;i++) cin>>b[i].x>>b[i].y;
	for(int i=0;i<(1<<n);i++)
	{
		bool bj=0;
		for(int j=1;j<=m;j++)
			if(i&(1<<(b[j].x-1))&&i&(1<<(b[j].y-1)))
				{bj=1; break;}
		if(!bj) ans++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：EuphoricStar (赞：7)

## 思路

将每种原材料视为二进制中的一个位，暴力枚举每种原材料选或不选（也可以用 dfs），最后再判断一下就行了。

理论时间复杂度为 $O(2^NM)$，但是加上剪枝后远远达不到这个上界。

## 代码

~~这也要代码~~

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 410;

int n, m, a[maxn], b[maxn], ans;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i) {
		scanf("%d%d", &a[i], &b[i]);
	}
	for (int i = 0; i < (1 << n); ++i) {
		bool flag = 1;
		for (int j = 1; j <= m; ++j) {
			if ((i & (1 << (a[j] - 1))) && (i & (1 << (b[j] - 1)))) {
				flag = 0;
				break;
			}
		}
		ans += flag;
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：C_S_L (赞：4)

这题看着像是一道状压题，但我们可以使用朴素的搜索算法解决它。

对于第 $i$ 种原材料，我们对其进行判断：

1. 若它与前面使用过的原材料冲突，则不能使用，继续搜索。

1. 若它与前面使用过的原材料没有冲突，则分为选和不选两种情况继续搜索。

即：

设与第 $i$ 种原材料冲突的原材料集合为 $S_i$。

集合 $G$ 初始时为空集。

对于每个 $i$：

$\begin{cases}\begin{cases}dfs(i+1,G,sum)&i\in G\\dfs(i+1,G+S_i,sum+1),dfs(i+1,G,sum)&i\notin G\end{cases}&1\le i<N\\ans=max(ans,sum)&i=N\end{cases}$

因为每种原材料可以选或不选，故时间复杂度为 $\Theta(2^N)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s[30],ans;
void dfs(int pos,int now) {
	if(pos==n+1) {
		ans++;
		return;
	}
	dfs(pos+1,now);
	if(!(now&(1<<pos))) {
		dfs(pos+1,now|s[pos]);
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1,x,y; i<=m; ++i) {
		scanf("%d%d",&x,&y);
		s[x]|=(1<<y);
		s[y]|=(1<<x);
	}
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：_lfxxx_ (赞：2)

一道比较简单的题，感觉评绿有点虚高，黄比较合适。

做此题前建议先了解[位运算](https://oi-wiki.org/math/bit/)。

------------
### 思路：
可以借用状压 DP 的思想，把每一种的方案用一个数表示。

即每一位（二进制下）用 $1$ 表示选，用 $0$ 表示不选。

然后看每一种方案中有没有冲突的原材料，统计个数即可。

时间复杂度 $\Theta(2^nm)$。

**注意：** 不放原材料也是一种方案。
### Code：
```cpp
int x[405],y[405];
int main(){
	int n,m,ans=0;
	read(n),read(m);
	for(int i=1;i<=m;++i)
		read(x[i]),read(y[i]);//读入做入冲突原材料
	for(int s=0;s<1<<n;++s,++ans)//枚举每一种方案
		for(int i=1;i<=m;++i)
			if(s&1<<x[i]-1&&s&1<<y[i]-1){//看是否有冲突
				--ans;
				break;
			}
	write(ans);
	return 0;
}
```

---

## 作者：Eason_AC (赞：2)

## Content
有 $n$ 个数 $1\sim n$。你需要在其中选若干个数。但是还有 $m$ 个限制，第 $i$ 个限制格式为 $a_i$ 不能和 $b_i$ 一起选。问你一共有多少种选法。

**数据范围：$1\leqslant n\leqslant 20$，$1\leqslant m\leqslant 400$，$1\leqslant a_i,b_i\leqslant n$，$a_i\neq b_i$。**
## Solution
不多说，上来直接暴搜。枚举所有可能的 $2^n$ 种情况，然后一个一个限制判断是否合法统计答案即可。理论上来说复杂度为 $\mathcal O(2^n m)$，但是由于很多种选法都没法枚举到 $m$ 种，因此实际复杂度远远达不到这么高。
## Code
```cpp
namespace Solution {
    int n, m, ans, a[407], b[407], in[27];

    iv dfs(int x) {
        if(x > n) {
            int fl = 1;
            F(int, i, 1, m) if(in[a[i]] && in[b[i]]) {fl = 0; break;}
            ans += fl; return;
        }
        in[x] = 1, dfs(x + 1), in[x] = 0, dfs(x + 1);
    }

    iv Main() {
        read(n, m);
        F(int, i, 1, m) read(a[i], b[i]);
        dfs(1), write(ans);
    }
}
```

---

## 作者：loverintime (赞：0)

## 题意

有 $n$ 个东西，其中 $m$ 对东西不能在一起，问一共有多少种选东西的方案

## 数据范围
$1 \leqslant N\leqslant20,1\leqslant M\leqslant400$


看到数据范围这么小，我们可以想到两种实现方式：爆搜、状压dp

## 爆搜

爆搜有一个优点：实现简单，并且不会超时。我这里有一个小优化： 记录 $s_i$ 表示与 $i$ 不能一起选的集合，用一个二进制数表示。 搜索时记录现在正在决定选不选的元素 $i$ 和现在不能使用的集合 $S$ ，判断 $i$ 在不在集合中即可判定能不能选， 如果选了 $i$ 就把 $S$ 变成 $S\cup s_i$

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int nset[25];
int ans;
void dfs(int x,int udo){
	if(x==n+1){
	    ans++;return;
	}
	dfs(x+1,udo);
	if(!(udo&(1<<x))){
	    dfs(x+1,udo|nset[x]);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++){
	    int x,y;
	    scanf("%d%d",&x,&y);
	    nset[x]|=(1<<y);nset[y]|=(1<<x);
	}
	dfs(1,0)
	printf("%d\n",ans);
	return 0;
}
```
复杂度： $\Theta(2^n)$  ~~（所以数据范围应该增大）~~



------------
至于状压dp，既然暴力都这么快了，那它还有什么用呢。不过大概说一说思路：

继承之前的做法，记录 $s_i$ 表示与 $i$ 不能一起选的集合，用一个二进制数表示。

$f(i,S)$ 表示正在抉择第 $i$ 个东西，现在不能选的集合为 $S$ 的方案数

转移方程用刷表的形式给出：

$f(i,S)\underrightarrow{\sum} f(i+1,S|s_{i+1}),i+1\notin S$

$f(i,S)\underrightarrow{\sum}f(i+1,S)$

复杂度  $\Theta(n2^n)$  ~~比爆搜还要慢~~

---


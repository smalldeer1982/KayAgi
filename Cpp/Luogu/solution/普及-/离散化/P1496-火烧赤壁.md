# 火烧赤壁

## 题目背景

曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。

孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。

隆冬的十一月，天气突然回暖，刮起了东南风。

没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。

曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！

## 题目描述

给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a <  b \lt 2^{31}$，且答案小于 $2^{31}$。




## 样例 #1

### 输入

```
3
-1 1
5 11
2 9```

### 输出

```
11```

# 题解

## 作者：wxwoo (赞：258)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/03/13/solution-p1496/)

******

[原题目链接](https://www.luogu.org/problemnew/show/P1496)

我们可以将
```
    ________
   |   __   |
   |  |  |  |
---------------->
   2  5  9  11
```
的重叠覆盖情况看成
```
    _____
   |   __|__
   |  |  |  |
---------------->
   2  5  9  11
```
所以，若我们将起点和终点按照从小到大的顺序排序，对答案不会产生影响

例如微调样例：
> 3

> -1 1

> 2 11

> 5 9

和原样例答案一样，都可以看成
```
        __________
    _  |    ______|__
   | | |   |      |  |
------------------------>
  -1 1 2   5      9  11
```

所以，我们得到了一个解法：分别对起点和终点进行排序，循环加上每一条线段的长度，若与前一条线段重复减去重复部分

代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
    int n;
    cin>>n;
    long long a[20001],b[20001],l=0;//a数组存储起点，b数组存储终点，l表示最终长度
    for(int i=0;i<n;i++)
        cin>>a[i]>>b[i];//输入
    sort(a,a+n);
    sort(b,b+n);//由于起点终点的顺序对答案不产生影响，对a数组和b数组进行排序
    for(int i=0;i<n;i++)
    {
        l+=b[i]-a[i];//加上当前线段长度
        if(i+1<n)//如果这条线段不是最后一条线段
            if(b[i]>a[i+1])//如果这条线段与前一条线段有重复
                l-=b[i]-a[i+1];//减去重复部分
    }
    cout<<l;//输出
    return 0;
}


```

---

## 作者：陈曦 (赞：125)

蒟蒻的第一篇题解，其实这道题是标准的离散化，模拟可以过，但是就没有训练效果了。我们首先先看数据，n<=20000，数据不多，但是范围大（-10^9<=Ai,Bi<=10^9），这时，就可以用离散化了，我们先定义两个数组，记录坐标，再全部赋给一个新的数组，进行排序，就可以判断是否可用*（flag判断），再通过一个find函数，找到原位置，就可以算了。但是本题卡时间，优化一下就行（快读，氧气优化之类的）

关于判断是否可用，举个栗子

有两对线段（x1,y1）(x2,y2)
如果x1>y2或x2>y1，那么（y2,x1）段或（y1,x2）段无用
```cpp
#pragma GCC optimize(2)//手动o2
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
long n,m=1,ans=0;//m记录坐标数
long c[40100]={0}；
//因为c要把起点与终点存下来，所以开40100
int a[20100],b[20100];//a存起点，b存终点
bool flag[40100];//判断是否有效
inline void read(long &x)//快读
{
    x=0; 
    int f=1; 
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') 
        f=-1; 
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    x*=f;
}
inline long find(long key)//找原来位置
{
    for(int i=1;i<=m;++i)
    {
        if(c[i]==key)
        return i;
    }
}
int main()
{
    read(n);
    for(long i=1;i<=n;++i)
    {
        read(a[i]);
        read(b[i]);
        c[m]=a[i];
        m++;
        c[m]=b[i];
        m++;
    }//把a,b存入c数组里去
    sort(c+1,c+m+1);//排序坐标
    for(long i=1;i<=n;++i)
    {
        a[i]=find(a[i]);
        b[i]=find(b[i])-1;//找原位置
        for(int j=a[i];j<=b[i];++j)
        flag[j]=true;//为有效
    }
    for(long i=1;i<=m;++i)
    {
        if(flag[i])
        ans+=c[i+1]-c[i];//有效，加入ans
    }
    printf("%ld",ans);
}
```
谢谢，还请大佬不要嘲笑我

---

## 作者：碳酸钙CaCO3 (赞：67)

[纯享版](https://www.luogu.com.cn/blog/ZKR666/p1496-huo-shao-chi-bi-ti-xie)
### 题意简化：

给定一个白色数轴，$q$ 次操作，每次给定一个区间 $[l, r]$，把区间染黑。求最后黑色区间的总长度。$1 \leq q \leq 20000，−2^{31} \leq l \leq r < 2^{31}$。

### 思路

首先，本题解使用做法为**离散化+差分**。

题意简化以后，我们可以发现，问题转化为在一个数列上，每次给 $[l, r]$ 区间内的数都增加 $1$。 最后求出数列的末状态，看有多少个点不是 $0$。但是我们直接模拟的话时间复杂度会过高，所以我们可以在离散化后进行差分，即将 $l+1$ 的位置加一， $r+1$ 的位置减一，最后进行求前缀和，得到 $l+1$ ~ $r$ 这个区间的每个位置加一。

因为题目的数据范围很大 $(−2^{31} \leq l \leq r < 2^{31})$，为了把数轴的范围映射到一个下标可以开的数组，我们需要对每个区间的 $l$ 和 $r$ 进行离散化。


#### 存储

```cpp
struct items{
	int l;//左。
	int nl;//l离散化后的位置。
	int r;//右。
	int nr;//r离散化后的位置。
}len[N];
```

#### 读入与离散化

首先我们将每个区间的 $l$ 和 $r$ 存储在一个数组内用 `unique` 进行去重，并且获取去重后的指针 `k`，去重后的元素个数为  `unique(b+1,b+1+2*n)-(b+1)` 也就是 `k-b-1`。

```cpp
for(int i=1;i<=n;i++){
		cin>>len[i].l>>len[i].r;//读入每个区间的l,r。
		b[i]=len[i].l,b[n+i]=len[i].r;//读入一个数组进行离散化操作。
	}
	sort(b+1,b+1+2*n);//由于unique需要在一个有序的数组下进行去重，所以我们需要排序。
	auto k=unique(b+1,b+1+2*n);//去重操作。
	for(int i=1;i<=n;i++){
		len[i].nl=lower_bound(b+1, k, len[i].l)-b;//通过lower_bound来查询每个l离散化后的位置，并存储在len[i].nl。
		len[i].nr=lower_bound(b+1, k, len[i].r)-b;//通过lower_bound来查询每个r离散化后的位置，并存储在len[i].nr。
	}
```

#### 差分与求前缀和

关于差分数组： ` map[i]=sum[i]-sum[i-1]`。


```cpp
for(int i=1;i<=n;i++)map[len[i].nl+1]++,map[len[i].nr+1]--;//差分。
for(int i=1;i<=(k-b-1);i++)sum[i]+=sum[i-1]+map[i];//（k-b-1）为元素个数。
```

#### 统计

接下来的问题就是如何统计离散化前的每个不为 $0$ 区间长度。我们可以找到每个区间的左端点和右端点离散化前所对应的值，并将它们相减，就可以得到每个不为 $0$ 区间长度。

由于这里的 `l` 和 `r` 是原来端点离散化后的编号，而每个编号对应的值存储在 `b` 数组内，所以 `b[r]` 就是原来的右端点，`b[l]` 就是原来的左端点。所以原来的区间长度就是 `b[r]-b[l]`。

```cpp
int l,r;//不为0的区间的左端点和右端点。
long long ans=0;
for(int i=1;i<=(k-b-1);i++){
		if(sum[i]!=0&&sum[i-1]==0)l=i-1;//确定左端点。
		if(sum[i]!=0&&sum[i+1]==0){//确定右端点，并且统计这个区间。
			r=i;
			ans+=b[r]-b[l];//由于这是离散化后的区间长度，并不是真正的区间长度，所以我们要找到原来的l与r，将他们相减，就是原来的区间长度。
		}
	}
```

### 代码（全）

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N=2e4+5;
int n;
int b[N*2];
int map[N*2],sum[N*2];
struct items{
	int l;//左。
	int nl;//l离散化后的位置。
	int r;//右。
	int nr;//r离散化后的位置。
}len[N];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>len[i].l>>len[i].r;//读入每个区间的l,r。
		b[i]=len[i].l,b[n+i]=len[i].r;//读入一个数组进行离散化操作。
	}
	sort(b+1,b+1+2*n);//由于unique需要在一个有序的数组下进行去重，所以我们需要排序。
	auto k=unique(b+1,b+1+2*n);//去重操作。
	for(int i=1;i<=n;i++){
		len[i].nl=lower_bound(b+1, k, len[i].l)-b;//通过lower_bound来查询每个l离散化后的位置，并存储在len[i].nl。
		len[i].nr=lower_bound(b+1, k, len[i].r)-b;//通过lower_bound来查询每个r离散化后的位置，并存储在len[i].nr。
	}
	for(int i=1;i<=n;i++)map[len[i].nl+1]++,map[len[i].nr+1]--;//差分。
	for(int i=1;i<=(k-b-1);i++)sum[i]+=sum[i-1]+map[i];//（k-b-1）为元素个数。
	int l,r;//不为0的区间的左端点和右端点。
	long long ans=0;
	for(int i=1;i<=(k-b-1);i++){
		if(sum[i]!=0&&sum[i-1]==0)l=i-1;
		if(sum[i]!=0&&sum[i+1]==0){
			r=i;
			ans+=b[r]-b[l];//由于这是离散化后的区间长度，并不是真正的区间长度，所以我们要找到原来的l与r，将他们相减，就是原来的区间长度。
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Drug__Lover (赞：24)

**模拟是个好东西**

**模拟很重要**

**不知道什么是离散化**

**随便搞一搞**

**按起点位置从小到大排序**

**然后每次更新起点与终点的位置**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 20000
using namespace std;
int n;
int start,en,sum;
struct node
{
    int x,y;
}a[maxn];
int cmp(node u,node v)
{
    return u.x<v.x;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
    sort(a+1,a+n+1,cmp);
    start=a[1].x;
    en=a[1].y;
    sum+=a[1].y-a[1].x;
    for(int i=2;i<=n;i++)
    {
        if(a[i].x<=en)         //如果当前线段的起点有一段与前面重合只记录未重合的部分 
        {
            if(a[i].y<en) continue;       //如果全被覆盖就不记录了 
            else
            {
                start=en;
                en=a[i].y;
                sum+=en-start;
            }
        }
        if(a[i].x>en)      //如果未重合就全纪录下来 
        {
            start=a[i].x;
            en=a[i].y;
            sum+=en-start;
        }
    }
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：cold_cold (赞：14)

**读进数据之后按起点从小到大排序**

**这里需要用到结构体**

**排序后任何两条线段只会有如下三种情况来合并**

1. **延伸**

![](https://cdn.luogu.com.cn/upload/pic/17802.png)

2. **包含**

![](https://cdn.luogu.com.cn/upload/pic/17803.png)

3. **断开**

![](https://cdn.luogu.com.cn/upload/pic/17805.png)

## 实现如下
```
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
struct bla
{
	int q,z;
}a[21000];
int n,all=0;
bool cmp(bla x,bla y)
{
	return x.q<y.q;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].q,&a[i].z);
	sort(a+1,a+1+n,cmp);
	int qi=a[1].q,zh=a[1].z;
	for(int i=2;i<=n;i++)
	{
		if(a[i].q>zh)
			all+=zh-qi,qi=a[i].q,zh=a[i].z;
		else
			zh=max(zh,a[i].z);
	}
	printf("%d",all+zh-qi);
	return 0;
}
```

---

## 作者：li20082008li (赞：8)

本题是NOIP2005普及组第二题——校门外的树 的数据强化版，

但如果用那题的算法来做的话本题会爆时间和空间，所以果断使用[color=purple]离散化[/color]（思想）

做法如下：

先把每一个着火船只的起点从小到大排序一遍，

接着设l为当前的最前面的线段（已连接）起点，r为这条线段的终点，

因为已经排过序，第i条线段的起点一定是大于等于l的，则对于第i条线段只剩两种情况：

①第i条线段的起点小于等于r，并大于等于l，则令r=max(r,第i条线段的终点）；

②第i条线段的起点大于r，则先在总距离上加上r-l（这条线段的长度），再将l更新为第i条线段的起点，r更新为第i条线段的终点。

[color=saddlebrown]最后别忘了在计算的总距离上加上r-l（因为最后一条线段没有在循环中处理到），以及储存总距离的变量要开int64！[/color]

输出总距离，结束！

代码如下：

```delphi

program ex1496;
var
  a:array[1..20000,1..2] of longint;
  i,j,k,m,n,s,l,r:longint;
  t:int64;

procedure qs(l,r:longint);
var
  i,j,s,mid:longint;
begin
  i:=l;
  j:=r;
  mid:=a[(l+r) div 2,1];
  repeat
    while a[i,1]<mid do inc(i);
    while a[j,1]>mid do dec(j);
    if i<=j then
    begin
      s:=a[i,1];
      a[i,1]:=a[j,1];
      a[j,1]:=s;
      s:=a[i,2];
      a[i,2]:=a[j,2];
      a[j,2]:=s;
      inc(i);
      dec(j);
    end;
  until i>j;
  if l<j then qs(l,j);
  if i<r then qs(i,r);
end;

begin
  readln(n);
  for i:=1 to n do
    readln(a[i,1],a[i,2]);
  qs(1,n);
  l:=a[1,1];
  r:=a[1,2];
  for i:=2 to n do
    if a[i,1]<=r then
    begin
      if a[i,2]>r then r:=a[i,2];
    end else
    begin
      t:=t+r-l;
      l:=a[i,1];
      r:=a[i,2];
    end;
  writeln(t+r-l);
end.

```
时间复杂度为O(n)


---

## 作者：Weakest_Konjac (赞：6)

根据题意，输入的时候有重合，所以判断如果两个重合了，把其中一个输入清掉，另一个输入起始和终止更改一下即可
代码如下：
```pascal
var d:array[1..20000,1..2]of longint;
    cnt,i,n,j:longint;
    procedure sort(l,r: longint);//排序，按起始排序，起始一样，按末尾排序
      var
         i,j,x,y,z,t: longint;
      begin
         i:=l;
         j:=r;
         x:=d[(l+r) div 2,1];
         t:=d[(l+r) div 2,2];
         repeat
           while (d[i,1]<x)or(d[i,1]=x)and(d[i,2]<t) do
            inc(i);
           while (x<d[j,1])or(d[j,1]=x)and(d[j,2]>t) do
            dec(j);
           if not(i>j) then
             begin
                y:=d[i,1];z:=d[i,2];
                d[i,1]:=d[j,1];d[i,2]:=d[j,2];
                d[j,1]:=y;d[j,2]:=z;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
 read(n);
 for i:=1 to n do read(d[i,1],d[i,2]);//输入
 sort(1,n);
 for i:=1 to n-1 do
  if d[i,2]>=d[i+1,1] then//判断
  begin
   d[i+1,1]:=d[i,1];//更改起始
   if d[i+1,2]<d[i,2] then d[i+1,2]:=d[i,2];//如果前一个完全包括了后一个，末尾也需更改
   d[i,2]:=0;//清零
   d[i,1]:=0;
  end;
 for i:=1 to n do
  cnt:=cnt+d[i,2]-d[i,1];//计算总着火船只
 writeln(cnt);
end.

```

---

## 作者：Forever丶CIL (赞：5)

读进数据之后按起点从小到大排序

然后对于后一段区间直接被前一段包含的情况那被包含的区间可以直接跳过不管

而只被部分包含的情况的话，就把后面的区间起点改成前一个区间终点+1

然后继续算就是了



------------

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,tp,ans=0;
struct edge
{
    int l;
    int r;
};
struct edge E[20001];
int cmp(edge a,edge b) //按起点大小排序 
{
    return a.l<b.l;
}
void work()
{
    E[0].r=-0x3f3f3f3f; 
    int la=0; //上一次处理的区间 
    for(int i=1;i<=n;i++)
    {
        if(E[i].r<=E[la].r+tp)  //如果现在要处理的区间被上一次的包含，就跳过 
            continue;
        if(E[i].l<=E[la].r+tp) E[i].l=E[la].r+tp+1; //部分包含的情况 
        la=i;
        if(((E[i].r-E[i].l+1)%1)==0) tp=0;//计算区间长度 
        else tp=1-((E[i].r-E[i].l+1)%1);//这些地方我写了个%1 ，/1之类的东西 
        if(tp==0) ans+=(E[i].r-E[i].l+1)/1;//看上去蛮鬼畜的，其实没用，和不加一样 
        else ans+=(E[i].r-E[i].l+1)/1+1;//这是因为我这个题是直接改的P1589的代码 
	}//为了省事本来是%m /m的全改成1了，大家不要被误导了qaq
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&E[i].l,&E[i].r);
        E[i].r--;
    }
    sort(E+1,E+1+n,cmp);
    work();
    printf("%d",ans);
    return 0;
}
```


------------

rp++ qaq



---

## 作者：jins3599 (赞：5)

没必要离散化。

裸的线段树区间覆盖。

模型转化一下就好，覆盖$[l,r]$内的区间，相当于覆盖区间$[l,r-1]$

于是打一发线段树即可。

空间太大开不下？动态开点就好了。

(但是不知道为什么有一个点会MLE...这份代码只有90pts

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX = 1e9 + 10;

const int N = 2e4 + 10;

int t[N ] , tag[N ] , root , idx , n;
int ls[N ] , rs[N ];

void pushdown(int x , int l , int r) {
	if(!ls[x]) ls[x] = ++ idx;
	if(!rs[x]) rs[x] = ++ idx; 
	tag[ls[x]] = 1;
	tag[rs[x]] = 1;
	int mid = l + r >> 1;
	t[ls[x]] = (mid - l + 1);
	t[rs[x]] = r - mid;
	tag[x] = 0;
}

void updata(int &p , int l , int r , int ql , int qr ) {
 	if(!p) p = ++ idx;
	if(l >= ql && qr >= r) {
		t[p] = r - l + 1; tag[p] = 1; return;
	}
	int mid = (l + r) >> 1;
	if(tag[p]) pushdown(p , l , r);
	if(ql <= mid) updata(ls[p] , l , mid , ql , qr);
	if(qr > mid) updata(rs[p] , mid + 1 , r , ql , qr);
 	t[p] = t[ls[p]] + t[rs[p]];
 }

int main () {
	cin >> n;
	for(int i = 1 ; i <= n ; i ++) {
		int sl , sr ; cin >> sl >> sr;
		updata(root ,-MAX, MAX, sl , sr - 1);
	}
	cout << t[root];
	return 0;
}

```

---

## 作者：qq872425710 (赞：2)

~~听说是提高组+的难度~~

很简单的，就是离散一下，用20000个数组来储存，每个位置记录一下他的开头和结尾，然后用开头来排序，然后扫一遍，如果当前结尾值大于前面最大的结尾值，然后后面那个的开头是比前面结尾最大的要小，那么就是加上当前的结尾值减去前面的最大的结尾值，不然就直接加上这一段的长度。同时他们的最大结尾值要变成现在的结尾。




```cpp
var
i,n,max,z:longint;
a,b:array[0..100000] of longint;
procedure init;
var
i:longint;
begin
readln(n);
for i := 1 to n do
begin
   readln(a[i],b[i]);
end;
end;
//:::::::::::::::::::::::::::::::
procedure qsort(l,r:longint);
var
i,j,m,t:longint;
begin
i := l;
j := r;
m := a[(i+j) div 2];
repeat
   while a[i]<m do inc(i);
   while a[j]>m do dec(j);
   if i<=j then
   begin
    t := a[i];
    a[i] := a[j];
    a[j] := t;
    t := b[i];
    b[i] := b[j];
    b[j] := t;
    inc(i);
    dec(j);
   end;
until i>=j;
if i<r then qsort(i,r);
if l<j then qsort(l,j);
end;
//:::::::::::::::::::::::::::::::
procedure main;
var
i:longint;
begin
z := b[1]-a[1];
max := b[1];
for i := 2 to n do
begin
   if (a[i]<max) and (b[i]>max) then
   begin
    z := z+b[i]-max;
    max := b[i];
   end
    else
   begin
    if (a[i]>max) then
    begin
     z := z+b[i]-a[i];
     max := b[i];
    end;
   end;
end;
writeln(z);
end;
begin
init;
qsort(1,n);
main;
end.
```

---

## 作者：CalvinJin (赞：1)

可以把起点和终点分开处理

坐标分开存在a数组里，b数组存状态，起点为1，终点为-1

先把坐标排序

循环中i代表起点，j代表后面的一个点，当i到j的状态和为0时就说明这是一段着火的船（可能中间有若干重复的起终点），可以把答案加上a[j]-a[i]的值

pascal代码见下


```pascal
var a,b:array[1..40000] of longint; x,y,n,i,j,t,ans:longint;
procedure qsort(l,r:longint);
var i,j,x,y:longint;
begin
  i:=l; j:=r; x:=a[(l+r) div 2];
  repeat
    while a[i]<x do inc(i);
    while x<a[j] do dec(j);
    if not(i>j) then
    begin
      y:=a[i]; a[i]:=a[j]; a[j]:=y;
      y:=b[i]; b[i]:=b[j]; b[j]:=y;
      inc(i); dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  read(n);
  for i:=1 to n do //处理坐标和状态
  begin
    read(x,y);
    a[i*2-1]:=x;
    b[i*2-1]:=1;
    a[i*2]:=y;
    b[i*2]:=-1;
  end;
  qsort(1,2*n);//排序

  i:=1; t:=b[1]; j:=1;//初始化 t代表当前i到j的状态之和
  while i<2*n do
  begin
    inc(j);
    inc(t,b[j]);//加上这一坐标的状态
    while a[j]=a[j+1] do 
    begin inc(j); inc(t,b[j]); end;//如果有多个起点和终点在同一坐标，就可以直接处理所有的状态，不会产生重复长度对答案的影响
    if t=0 then begin inc(ans,a[j]-a[i]); i:=j+1; inc(t,b[i]); j:=j+1; end;//状态为0，加上长度，此时下一个坐标的状态必为1，直接把i赋值为下一个即可
  end;

  writeln(ans);
end.
```

---


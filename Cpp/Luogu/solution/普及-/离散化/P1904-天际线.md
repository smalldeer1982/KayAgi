# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# 题解

## 作者：InchTree (赞：104)

### 论如何将一道“提高+”的题目写成“普及-”
关于“提高+”级别的做法（**扫描线+线段树+离散化**）题解区的各路大神各显神通，已经讲解得很详细了。对于像我一样刚学习扫描线、线段树、离散化的人来说是一道不错的综合入手题（**其实还是建议这几种算法分开学**）。

不过在赛场上，能想到一些代码简洁而又能保证正确率的算法何乐不为？

(以下为正文)

最简单的想法就是：记录下轴上每个点上建起的楼房高度的最大值。怎么记录呢？~~懒得打线段树的话那就~~暴力咯：

```cpp
while(scanf("%d%d%d",&a,&h,&b)!=EOF) 
	for(i=a;i<=b;++i) H[i]=max(H[i],h); 
```

应该很多人都想到了但怕T就不敢写，算一下**时间复杂度：5000×10000=5e7<1e8**，加之这题常数较小，应该是能过的（实际上能用4ms以内时间通过所有该题的测试点 ）

然后很容易想到奇数点和偶数点总是成对出现的（废话），**每次造成两点出现的原因都是最大高度的变化引起的**，所以我们只需从坐标0到10000线性枚举一遍，如果该点的高度与上一点有差距，就等于新增了两个点，将即它们横(纵)坐标输出即可：

```cpp
#include<bits/stdc++.h>
using namespace std;
int H[10005];
int main(){
	register int i,a,b,h;
	while(scanf("%d%d%d",&a,&h,&b)!=EOF) 
		for(i=a;i<=b;++i) H[i]=max(H[i],h); 
	for(i=1,h=0;i<1e4;++i)
		if(h!=H[i])
			h=H[i],printf("%d %d ",i,H[i]);
	return 0;
}
```

想到这，很开心地就把代码提交了，于是就WA了……(20分)

原因在哪？在点与点间的缝隙。

**e.g.如果有两个房子的三元组是\[1,10,3]与\[4,10,6],显然区间\[3，4]内存在一个缝隙，如果按刚才的算法，缝隙造成的四个点就被忽略了。**

怎么改呢？有些人用的是±0.5的做法，个人觉得太麻烦了，其实只要把代码第7行的"<="改成"<"就行了。（至于为什么就留给大家思考下）

以下奉上简短的AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int H[10005];
int main(){
	register int i,a,b,h;
	while(scanf("%d%d%d",&a,&h,&b)!=EOF) 
		for(i=a;i<b;++i) H[i]=max(H[i],h); 
	for(i=1,h=0;i<1e4;++i)
		if(h!=H[i])
			h=H[i],printf("%d %d ",i,H[i]);
	return 0;
}
```

###### //第一次写题解，所以选了较为简单的题目试一下手，如有问题我会尽快改正。

---

## 作者：big_news (赞：44)

~~**你知道自己yy出来的代码题解里没有，WA数据还不给下载的感受吗？**~~

~~**我就是很想问：这么水的一道题，写什么平衡树？**~~

### 本人胡乱yy出来的想法：扫描线+线段树做线段区间覆盖

经典题型：[HDU1542 Atlantis](http://acm.hdu.edu.cn/showproblem.php?pid=1542)

首先题意已经很明确了：求出若干个矩形的并 所形成的不规则图形 的顶点（真是不像人话）。

### 扫描线法

**先抛开本题**，来谈矩形并问题的一般解法：**扫描线法**。

假设平面内有若干个矩形（本题中矩形一定与x轴相切，但是在其他题目中不一定，因此来看一般情况），矩形两两可能相交，现在要求我们在**矩形的并**所形成的**不规则图形**上搞一些事情（如求出它的面积）。

不妨假设我们有一条平行于y轴的线段，从y轴开始不断向x轴正方向平移。我们可以根据这条线段把这个不规则图形切割成若干部分，如下图：
![](https://cdn.luogu.com.cn/upload/pic/64666.png)

不难发现任意时刻，这个不规则图形在两条相邻的扫描线（灰色）之间的部分总是规则的。于是我们可以利用规则图形的一些性质来解决问题。

对于这部分规则图形来讲，宽（两条扫描线间的距离）是很容易知道的，关键在于求出它的高，也就是这个规则图形（也可能不止一个）的高在y轴上的投影，如下图。

ps：图片用的之前绘制的，因此标注的是矩形的面积，~~但是我懒得再绘图了...~~
![](https://cdn.luogu.com.cn/upload/pic/64668.png)

**回到题目**，不难发现，在两条扫描线之间的轮廓线发生改变，仅有可能是y轴上的投影发生变化。于是我们需要维护y轴上投影的总长度。

我们可以这样想：把一个矩形变成平行于y轴的两条边，这样我们就会得到一堆线段。

若把它们投影在y轴上，则扫描一个矩形的过程可以看作先插入一条线段，再删除一条线段。

那么也就是说，我们现在要干这样一件事情：在某一区间内，维护若干线段的并的长度，支持删除或插入一段线段。

也就是“线段覆盖”。

### 线段覆盖

实际上就是一棵节点维护的是一条“线段”的线段树，树上的每个节点维护在某个区间$[l,r]$内被覆盖的线段长度。节点的详细定义如下：
```cpp
class node{ 
  public:
    int l,r; //节点所维护的区间
    int cnt; //这个区间被完全覆盖的次数
    int len; //这个区间被覆盖的长度
}
```
那么在本题中，我们可以这样定义一条线段：
```cpp
class Sugment{
  public: 
    int r; //线段的高度
    int x; //横坐标
    int k; //线段权值
}
```
插入线段时，我们设它的权值为1 ，删除线段时，我们设它的权值为-1。这样就能让这两条线段抵消，达到删除的作用。

把这棵维护“线段”的线段树形象的表示出来，如下图：

ps:每条线段两头的标号代表节点所维护的线段的两个端点（离散化之后）
![](https://cdn.luogu.com.cn/upload/pic/64676.png)

不难发现线段是满足“区间加法”的性质的，因为在合并时，父区间若未被完全覆盖，则父区间维护的线段长度一定是子区间维护值的和，否则就是子区间的覆盖长度之和。

### 解决问题

有了线段覆盖，这个问题就好解决了。

每次我们把横坐标相同的所有线段（注意：横坐标相同的要一起处理，为此我对拍了半小时...）拿出来更新线段覆盖，若发现覆盖的总长度发生了变化，那么轮廓线就一定会改变。

于是我们得到两个折点，横坐标都是当前扫描线的横坐标，纵坐标分别是进行线段覆盖之前和之后，覆盖线段的总长度（~~想一想，为什么~~）。然后输出就好了。

最后：别忘了对纵坐标离散化！

AC代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;

const int CN = 4e6+6;

int read(){ //快读
    int s=0,ne=1; char c=getchar();
    for(;c<'0'||c>'9';c=getchar()) if(c=='-') ne=-1;
    for(;c>='0'&&c<='9';c=getchar()) s=(s<<1)+(s<<3)+c-'0';
    return s*ne;
}

int n;

class locat{
  public: int x,y;
    bool operator < (const locat &a)const{
    	if(x == a.x) return y < a.y;
    	return x < a.x;
    }
}ans[CN]; 
int acnt = 0;

//线段覆盖
class Sugment{ //定义一条线段
  public: int r,x,k;
    bool operator < (const Sugment &a)const
    {return x < a.x;} 
}sug[CN];
int scnt = 0;

int pos[CN],pcnt; //离散化数组
class node{ //定义线段树的节点
  public: int len,cnt;
};
class SGT{ //线段树 (SugmentTree,习惯简写成SGT,我英语不好)
  public:
  	node d[CN<<2];
  	int GetLen(int l,int r,int k){ //更新得到的线段的长度
  		if(d[k].cnt) return pos[r+1]-pos[l];
  		if(l == r) return 0;
  		return d[k<<1].len + d[k<<1|1].len;
    }
  	void modify(int l,int r,int k,int s,int t,int x){ //修改(插入/删除)
  		if(s<=l && r<=t){ //这里的操作和普通线段树类似
  			d[k].cnt += x;
  			d[k].len = GetLen(l,r,k);
  			return;
        }
        int m = (l+r)>>1;
        if(s <= m) modify(l,m,k<<1,s,t,x);
        if(m < t) modify(m+1,r,k<<1|1,s,t,x);
        d[k].len = GetLen(l,r,k); //更新线段长度
    }
}sgt;

void SugmentCover(int i){ //线段覆盖
    int l = 1;
    int r = lower_bound(pos+1,pos+pcnt+1,sug[i].r)-pos-1; //查找离散化之后的值
    sgt.modify(1,pcnt,1,l,r,sug[i].k);
}

int main()
{
    //freopen("data.in","r",stdin);
    
    n = 0;
    int x,y,z;
    while(~scanf("%d%d%d",&x,&y,&z)){
        n++;
        sug[scnt+1].r = y; sug[scnt+1].x = x; sug[scnt+1].k = 1; //保存成两条线段
        sug[scnt+2].r = y; sug[scnt+2].x = z; sug[scnt+2].k = -1;
        scnt += 2;
        pos[n] = y;
    }
    pos[++n] = 0; //防止出锅 
    
    //离散化 
    sort(sug+1,sug+scnt+1);
    sort(pos+1,pos+n+1);
    pcnt =1;
    for(int i=2;i<=n;i++) 
        if(pos[i] != pos[i-1]) //去重
            pos[++pcnt] = pos[i];
    //solve
    int prvh = 0; //上一次线段覆盖之后,得到的总长度
    for(int i=1;i<=scnt;i++){
        while(sug[i].x==sug[i+1].x && i<scnt) //把横坐标相同的全部覆盖
            SugmentCover(i),i++;
        SugmentCover(i);
        if(sgt.d[1].len != prvh){ //出现了拐点
            ans[++acnt].x = sug[i].x; //记录答案,其实可以直接输出
            ans[acnt].y = prvh;
            prvh = sgt.d[1].len;
            ans[++acnt].x = sug[i].x;
            ans[acnt].y = prvh;
        }
    }
    
    //print
    for(int i=1;i<=acnt;i++) //优雅的输出
        if(i & 1) printf("%d ",ans[i].x);
            else printf("%d ",ans[i].y);
    
    return 0; //可爱的return 0
}
```

in the end：~~写完这个,发现之前写的扫描线浅谈我自己都看不懂了(我语文不好)...~~


in the end of end:附一组毒瘤数据:
```
1 2 2
1 1 2
```

---

## 作者：sfmmdm (赞：34)

~~这题一看就是一道扫描线的题~~  
看看这题的数据大小，楼数$n \leq 5000$，坐标$x,y \leq 10000$，而且坐标都是整数，用暴力一点问题都没有。

这题说，第奇数个点输出横坐标，第偶数个点输出纵坐标。但仔细研究样例的图片我们就能发现，第1、 2个点横坐标相同，第3、 4个点横坐标相同……于是这题相当于让我们一个个输出第偶数个点的坐标。

对应每一个$x$坐标，用$maxh$数组记录这个$x$坐标的最高的楼。

由于点是成对出现的，那么第偶数个点是这对点的上面那个时，它的左边的$maxh$值就比它小；如果是下面那个时，它右边的$maxh$值比它要小。

所以，只要对于每一个$x$判断它的$maxh$和左右两边的是否相等，如果不相等，就输出即可（注意此时的$y$坐标应该输出上面的还是下面的）。

当然，还有一个非常特殊的情况，那就是：
![](https://i.loli.net/2019/08/18/POHRspNaMkJenm6.jpg)

这时，$maxh[x+1]$和$maxh[x-1]$都会直接访问到另外一栋楼，因为高度相等，所以不会输出，这就少输出了两个数！  
所以，我们应该访问$maxh[x \pm 0.5]$，因为数组下标不能是小数，所以我们让$maxh[i]$里存坐标$i/2$的最高楼。

具体代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int maxh[20005];
int main() {
	int l,h,r,L=10005,R=0; //L和R为所有楼房的横坐标的最小和最大值 
	while(scanf("%d%d%d",&l,&h,&r)!=EOF) {
		L=min(L,l);
		R=max(R,r);
		for(int i=l; i<=r; i++) {
			maxh[i<<1]=max(maxh[i<<1],h);
			if(i<r) maxh[i<<1|1]=max(maxh[i<<1|1],h);
		}//更新每个x坐标的最大高度，注意2*r+1不包括在这部分里 
	}
	for(int i=L; i<=R; i++) {
		if(maxh[i<<1]!=maxh[(i<<1)-1]) printf("%d %d ",i,maxh[i<<1]);//如果x和x-0.5的最大不相等，输出(x,x的最大高度) 
		if(maxh[i<<1]!=maxh[i<<1|1]) printf("%d %d ",i,maxh[i<<1|1]);//如果x和x+0.5的最大不相等，输出(x,x+0.5的最大高度) 
	}
	return 0;
}
```

代码总共19行，比起写扫描线少了不少。这样写的时间复杂度只有$O(nx)$，题目所给的数据范围是可以AC的。


---

## 作者：Timothy (赞：18)

【题目大意】

我们知道Genoa所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组（Li,Hi,Ri）其中Li和Ri分别是建筑的左坐标和右坐标，Hi就是建筑的高度。你被要求给出城市的轮廓线。你可以这样来描述：对于所有轮廓线上的折点，按顺序排好，第奇数个点输出x坐标，第偶数个点输出y坐标

【算法讨论】

运用线段树成段更新+离散化的算法。先将每一栋楼房按照从低到高的顺序排序（因为低的楼房会被高的挡住）。接下来进行离散化（只需L和R）。然后把每一段L，R放入线段树（线段树维护[I,j]区间楼房的高度）。最后，搜索线段树的每一个叶子节点，节点i上的高度即为y坐标，x坐标为i离散化前的值，并判断后输出。

得分：100

时间复杂度：O(2nlogn)

空间复杂度：O(22n)

【C++代码】

```cpp

#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#define maxn 100005
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
int n,col[maxn<<3],num[maxn<<3],le[maxn<<1],len,m=1,next,last,x[maxn<<1],y[maxn<<1],sum;
struct node{int h,i,j;}a[maxn];
bool cmp(node p1,node p2){return p1.h<p2.h;}
void pushdown(int rt)
{
    col[rt<<1]=col[rt<<1|1]=1;
    num[rt<<1]=num[rt<<1|1]=num[rt];
    col[rt]=0;
}
int ef(int l1,int r1,int mb)
{
    int l=l1,r=r1;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (le[mid]>=mb)r=mid-1;
        else l=mid+1;
    }
    return l;
}
void update(int l,int r,int rt,int L,int R,int H)
{
    if (L<=l && r<=R){col[rt]=1;num[rt]=H;return;}
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (L<=mid)update(lson,L,R,H);
    if (R>mid)update(rson,L,R,H);
}
int query(int l,int r,int rt,int u)
{
    if (l==r)return num[rt];
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (u<=mid)query(lson,u);
    else query(rson,u);
}
int main()
{
    while (~scanf("%d%d%d",&a[m].i,&a[m].h,&a[m].j))
    {
        le[++len]=a[m].i;
        le[++len]=a[m].j;
        m++;
    }
    m--;
    sort(le+1,le+len+1);
    sort(a+1,a+m+1,cmp);
    n=1;for (int b=1;b<len;++b)if (le[b]!=le[b+1])le[++n]=le[b+1];
    for (int b=1;b<=m;++b)
    {
        a[b].i=ef(1,n,a[b].i);
        a[b].j=ef(1,n,a[b].j);
        update(1,n,1,a[b].i,a[b].j-1,a[b].h);
    }
    for (int b=1;b<=n;++b)
    {
        x[b]=le[b];
        y[b]=query(1,n,1,b);
        if (y[b]!=y[b-1])sum++;
    }
    for (int b=1;b<=n;++b)
    {
        if (y[b]!=y[b-1])
        {
            printf ("%d ",x[b]);
            printf ("%d ",y[b]);
        }
    }
    return 0;
}

```

---

## 作者：xiaolou (赞：15)

P1904 解题分析 By xiaolou

# 前置瞎BB：

最近查漏补缺，把学的不太好的线段树大补了一下

看到这题是线段树就果断点进来了

切掉以后一看题解都看不懂，好像还没有线段树的

# 主要思路：

题意大概就是给了几个长方体，摆成一排，然后问正视图长什么样

很显然就是求每个单位上高度最大值，是人都能看出用线段树做（写题解的那群人大概是神仙）

主要思想：对于每栋建筑的占地范围，进行一下区间求最大值，复杂度O(mlogn)

然后对于每个单位，求出该单位上的最大值，复杂度O(nlog n)

因为n<=10000,m<=5000，所以可以稳过

# 代码实现：

直接贴代码吧，具体看注释，线段树就不解释了

```cpp
#include <bits/stdc++.h>

using namespace std;
struct SGTree
{
    int le,ri;
    int la;
    int mx;
}t[40005];
struct Buildings
{
	int l,r;
	int h;
	bool operator <(const Buildings A) const
	{
		return h<A.h;
	}
}b[10005]; 
int a[10005];
void BuildT(int id,int l,int r)//建树
{
    t[id].le=l;
    t[id].ri=r;
    t[id].la=0;
    if(t[id].le==t[id].ri)
    {
        t[id].mx=0;
        return;
    }
    int mid=(l+r)/2;
    BuildT(id*2,l,mid);
    BuildT(id*2+1,mid+1,r);
}
void Push(int id)//la标记下放
{
    if(t[id].la)
    {
        t[id*2].la=t[id].la;
        t[id*2+1].la=t[id].la;
        t[id*2].mx=max(t[id*2].mx,t[id*2].la);
        t[id*2+1].mx=max(t[id*2+1].mx,t[id*2+1].la);
        t[id].la=0;
    }
}
void Change(int id,int l,int r,int c)//修改，注意细节
{
    if(t[id].le==l&&t[id].ri==r)
    {
        t[id].mx=max(t[id].mx,c);
        t[id].la=c;
        return;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        Change(id*2,l,r,c);
    }
    else if(l>=t[id*2+1].le)
    {
        Change(id*2+1,l,r,c);
    }
    else
    {
        Change(id*2,l,t[id*2].ri,c);
        Change(id*2+1,t[id*2+1].le,r,c);
    }
    t[id].mx=max(t[id*2].mx,t[id*2+1].mx);
}
int Query(int id,int l,int r)//查询
{
    if(t[id].le==l&&t[id].ri==r)
    {
        return t[id].mx;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        return Query(id*2,l,r);
    }
    else if(l>=t[id*2+1].le)
    {
        return Query(id*2+1,l,r);
    }
    else
    {
        return max(Query(id*2,l,t[id*2].ri),Query(id*2+1,t[id*2+1].le,r));
    }
}

int main()
{
    BuildT(1,1,10000);
    int l,h,r;
    int cnt=1;
    while(cin >> b[cnt].l >> b[cnt].h >> b[cnt].r)
    {
        if(b[cnt].l==0&&b[cnt].r==0&&b[cnt].h==0)
        {
            break;
        }
        cnt++;
    }
    sort(b+1,b+cnt);//将高度排序，不然会错，我也不知道为什么
    for(int i=1;i<cnt;++i)
    {
    	Change(1,b[i].l,b[i].r-1,b[i].h);
    }
    for(int i=1;i<=10000;++i)
    {
        a[i]=Query(1,i,i);
        printf("%d ",a[i]);
    }
    for(int i=1;i<=10000;++i)
    {
		   if(a[i]!=a[i-1])
			{
				printf("%d %d ",i,a[i]);//按照要求输出
			}
     } 
     return 0;
}
```

最后安利一下[我的博客](https://www.luogu.org/blog/xiaolou/)

~~点个赞吧~~

---

## 作者：zhengrunzhe (赞：12)

平衡树+扫描线

把(l,h,r)的楼房转化为两条竖直的线段(l,h,0),(r,h,1) 表示在l的位置插入一个高h的线段，在r的位置删去一条高h的线段

按照x坐标升序排序，然后逐次扫过去，开个平衡树维护最大值(~~当然用堆也可以，但我就喜欢平衡树~~)，这里用Treap

进来一条线段(pos,len)的时候，如果它的高度比原来的都要高，那就会造成两个个轮廓点了，坐标是(pos,前最高的高度)和(pos,len)

删去一条线段(pos,len)的时候，如果它是当前最高的话，就会造成两个轮廓点(pos,len)和(pos,删去后最高的高度)

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using std::max;
using std::sort;
template<class type>inline const void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
const int N=1e5+10;
struct segment
{
    int pos,len;bool type;
    inline const bool operator<(const segment &s)const
    {
        if (pos!=s.pos)return pos<s.pos;
        if (type!=s.type)return type<s.type;
        return len>s.len;
    }
}s[N<<1];
int cnt;
inline const void add(int pos,int len,bool type)
{
    s[++cnt]=(segment){pos,len,type};
}
class Treap
{
    private:
        struct tree
        {
            int value,cnt,priority;
            tree *son[2];
        }memory_pool[N<<1],*tail,*null,*recycle[N];
        int top;
    public:
        tree *root;
    protected:
        inline const void init()
        {
            top=0;
            tail=memory_pool;
            null=tail++;
            null->son[0]=null->son[1]=null;
            null->value=null->cnt=null->priority=0;
            root=null;
        }
        inline tree *spawn(int key)
        {
            tree *p=top?recycle[--top]:tail++;
            p->cnt=1;
            p->value=key;
            p->priority=rand();
            p->son[0]=p->son[1]=null;
            return p;
        }
        inline const void erase(tree *&p)
        {
            recycle[top++]=p;p=null;
        }
        inline const void rotate(tree *&fa,bool f)
        {
            tree *p=fa->son[f];
            fa->son[f]=p->son[f^1];
            p->son[f^1]=fa;
            fa=p;
        }
        inline tree *getmax()
        {
			tree *p=root;
			while (p->son[1]!=null)p=p->son[1];
			return p;
		}
    public:
        inline Treap(){init();}
        inline const void insert(tree *&p,int key)
        {
            if (p==null)return (void)(p=spawn(key));
            if (p->value==key)return (void)(p->cnt++);
            bool f=p->value<key;
            insert(p->son[f],key);
            if (p->son[f]!=null&&p->priority>p->son[f]->priority)
                rotate(p,f);
        }
        inline const void Delete(tree *&p,int key)
        {
            if (p==null)return;
            if (p->value==key)
            {
                if (p->cnt>1)return (void)(p->cnt--);
                if (p->son[0]==null&&p->son[1]==null)return erase(p);
                if (p->son[0]==null)return (void)(p=p->son[1]);
                if (p->son[1]==null)return (void)(p=p->son[0]);
                bool f=p->son[0]->priority>p->son[1]->priority;
                rotate(p,f);Delete(p,key);
            }
            else Delete(p->son[p->value<key],key);
        }
        inline const int mx()
        {
            return getmax()->value;
        }
        inline const bool only()
        {
			return getmax()->cnt==1;
		}
}T;
int n,tot,sum,ans[N<<2][2];
inline const void ins(int x,int y)
{
    tot++;
    ans[tot][1]=x;
    ans[tot][0]=y;
}
int main()
{
    for (int l,h,r;scanf("%d%d%d",&l,&h,&r)==3;n++)add(l,h,0),add(r,h,1); //巧妙的读入
    sort(s+1,s+cnt+1); //排序
    for (int i=1;i<=cnt;i++)
    {
        int fm=T.mx(); //代表之前的最大值(former_max)
        if (s[i].type)
        {
			bool only=T.only(); //只是用来判断当前的最大值是否唯一，防止重复加入答案
            T.Delete(T.root,s[i].len);
            if (s[i].len!=fm||!only)continue;
            ins(s[i].pos,s[i].len);
            int nm=T.mx(); //删去后的新最大值(new/next_max)
            ins(s[i].pos,nm);
        }
        else
        {
            T.insert(T.root,s[i].len);
            if (s[i].len<=fm)continue;
            ins(s[i].pos,fm);
            ins(s[i].pos,s[i].len);
        }
    }
    for (int i=1;i<=tot;i++)
        printf("%d ",ans[i][i%2]); //巧妙的输出
    return 0;
}
```

---

## 作者：haoyun1 (赞：10)

这题题面看起来很不好做，但实际上仔细发现，折线的位置显然在有高度变化的地方出现，所以我们可以将(hi,ri)二元组（打个结构体)建一个大根堆，以hi作为排序依据，ri用来判断堆顶有没有过期，过期则弹出，若最大值发生变化，那么就是有折线，将当前x坐标和变化后的值输出即可。

注：[这题数据有问题](https://www.luogu.org/discuss/show?postid=46558)（2018/08/14)

我们先将所有建筑的左端点和右端点排序，类似离散化一样。

然后依次扫描这些点，如果是左端点则入堆。每到一个端点都要判断当前堆顶是否过时。

代码如下：（有注释，好吧用了优先队列）

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
#define N 5050
struct building{
	int h,r;//h为高度，r为右端点
	building(int h_,int r_){h=h_;r=r_;}
	bool operator <(const building& i)const{return h<i.h;}//重载运算符，以高度h来建大根堆。
};
struct sp{
	int v,w;//v指向原来位置，w为x坐标
	bool p;//p=0则是左端点，p=1是右端点
	sp(int v_=0,int w_=0,bool p_=0){v=v_;w=w_;p=p_;}
}b[N*2];
int n,a[N][3];
inline bool comp(const sp&x,const sp&y){return x.w<y.w;}
priority_queue<building>q;
int main(){
	int l,h,r;
	while (scanf("%d%d%d",&l,&h,&r)!=EOF){
		a[++n][0]=h;
		a[n][1]=l;
		a[n][2]=r;
		b[n*2-1]=sp(n,l,0);
		b[n*2]=sp(n,r,1);//把左右端点都加个b数组
	}
	sort(b+1,b+2*n+1,comp);//将b数组按x坐标排序
	int last=0;
	for (int i=1;i<=2*n;i++){
		if (q.size()){//这一段时判断堆顶是否过时
			r=(q.top()).r;
			while (q.size()&&b[i].w>=r){
				q.pop();
				if (q.empty()) break;
				r=(q.top()).r;
			}
		}
		if (!b[i].p) q.push(building(a[b[i].v][0],a[b[i].v][2]));//是左端点入堆
		if (i<2*n&&b[i].w==b[i+1].w) continue;
		if (q.size()) h=(q.top()).h; else h=0;//堆空高度为0
		if (h!=last){//高度变化则输出
			printf("%d %d ",b[i].w,h);
			last=h;
		}
	}
	return 0;
}
```

---

## 作者：keydu (赞：6)

其实吧，这题，和UVA105一毛一样，可是这道题图好看了一点，啃啃，就提高+蓝了，可怜了我们的UVA105才普及黄；

好吧进入正题QWQ
下面是贴代码时间。。

```
#include<bits/stdc++.h>
using namespace std;
int ans[10001],ls=0x7f7f7f,rs=-0x7f7f7f; 
int main() {
	std::ios::sync_with_stdio(false); 
	int l,r,h;
	memset(ans,0,sizeof(ans));
	while(cin>>l>>h>>r) {
		ls=min(l,ls); rs=max(r,rs);
		for(int i=l; i<r; i++) {
			if(ans[i]<h) ans[i]=h;}}
	for(int i=ls; i<rs; i++) {
		if(ans[i]!=ans[i-1]) {
			if(ans[i]==0) cout<<i<<" "<<0<<" ";
			else cout<<i<<" "<<ans[i]<<" ";} }
	cout<<rs<<" "<<0<<endl;
}
```
当然了既然思维难度和编程复杂度那么低。。时间也是大的可怜，，
14ms，达到了倒数，，，，
思路就是和hash表差不多，一下把10000拉开来，每有一个建筑就进行修改最大值（因为轮廓只看最大值）
分析一下后，神奇的发现，又不爆空间，更不炸时间，，
QAQQAQAQAQ
可怜我是冲着线段树点进来的，差点写了个nlogn的修改，，拜拜放着n的修改不看。。。我这是太弱了

---

## 作者：Kevin_Wa (赞：5)

看题解里没有人用分块？那就来一发分块的题解。

先将数据读入，再统计出建筑物的x坐标最大值，还要加一个$1$，否则就会没有最后两个输出。必须先读入，否则很难确定分块每块的大小。

然后就可以上我们的分块大法了。。。每扫一遍区间，然后再将不在整个块内的点全部暴力处理，再将每块标记上取最大值，最后统计该点的高度就是在数组内的高度和该点所在的块的标记的最大值。

最后判断将每一个点扫一遍，如果与前面的高度不一致，就输出该点的横坐标和高度。

时间复杂度为$O(n \sqrt{n})$，会比纯暴力快很多。

$Code:$

```cpp
#include <bits/stdc++.h>
#define maxn 10010
using namespace std;
int a[maxn],l[maxn],r[maxn],h[maxn],N,ln,rn;
int n,m,f[maxn];
template <typename T> void read(T &x) {
x = 0; char c = getchar();
for (; !isdigit(c); c = getchar());
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
}
int main() 
{
n=0;m=1;
while (scanf("%d",&l[m])!=EOF) //先读入
  {
  	read(h[m]);read(r[m]);
  	r[m]--;
  	n=max(n,r[m]); //统计横坐标的最大值
  	m++;
  }
m--;
n++; //最大横坐标要加一哦
N=sqrt(n);
for (int j=1;j<=m;j++)
  {
  	ln=(l[j]-1)/N+1; 
  	rn=(r[j]-1)/N+1; //将两个点所在的块找出来
  	if (ln==rn)//分块大法不解释
  	  {
  	  	for (int i=l[j];i<=r[j];i++)
  	  	  a[i]=max(a[i],h[j]);
  	  	continue;
		}
	if (l[j]!=(ln-1)*N+1)
	  {
	  	for (int i=l[j];i<=ln*N;i++)
	  	  a[i]=max(a[i],h[j]);
	  	ln++;
	  }
	if (r[j]!=rn*N)
	  {
	  	for (int i=(rn-1)*N+1;i<=r[j];i++)
	  	  a[i]=max(a[i],h[j]);
	  	rn--;
	  }
	for (int i=ln;i<=rn;i++)
	  f[i]=max(f[i],h[j]);
  }
int flag=0;
for (int i=1;i<=n;i++)
  {
  	a[i]=max(a[i],f[(i-1)/N+1]);   //该点的高度就是在数组内的高度和该点所在的块的标记的最大值
  	if (a[i]!=a[i-1])
  	    {
  	    if (flag==0) 
  	      printf("%d %d",i,a[i]);
  	    else printf(" %d %d",i,a[i]);
  	  	flag=1;
  	    }
  }
printf("\n");
return 0;
}

```



---

## 作者：Minecraft万岁 (赞：4)

说实话 这题真的不是很难 但不知道为什么是蓝题   
看见这题从 $a[i].l$ 到 $a[i].r$ 的建筑高度全是 $a[i].h$ 
自然想到 用 [ODT](https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html) 来水 但是 有个~~小小的~~问题   
#### 珂朵莉树的推平太暴力了  一般不考虑大小关系 直接赋值  但是这题是轮廓线  
不像 [这题](https://www.luogu.com.cn/problem/P3740) 可以直接用珂朵莉树模板水  
其实很简单 ~~显然~~ 对于一个点 最高的那栋楼才是最后组成轮廓线的部分 那我们对于 $a[i]$ 这个结构体数组 按照 $h$ 从小到大排序 这样就可以做到在推平的时候让更大的 $h$ 覆盖掉较小的    
### $\text{本题毒瘤 请注意细节}$   


------------
我知道你们最想要这个   
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<set>
#include<cstdlib> 
#include<vector>
#define IT set<node>::iterator //弄一个短一点的 
using namespace std;
typedef long long ll;
struct node//珂朵莉树的节点 
{
	int l,r;
	mutable int v;
	node(int L,int R=-1,int V=0):l(L),r(r),v(V){}
	bool operator < (const node &t)const{
		return l<t.l;
	}
};
set<node> s;//珂朵莉树 
struct node2//再开一个结构体 存 读入的数据 和 输出答案的数组 
{
	int l;
	int r;
	int v;
}a[5005];
int n;//一共有多少个 
int rl,rr,rh;//读入的 l r h 
vector<node2> ans;//用于计算答案的数组 
inline void read(int &x)//快读 
{
	int f;char c;
	for (f=1,c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for (x=0;c<='9'&&c>='0';c=getchar()) x=x*10+(c&15);x*=f;
}
inline IT split(int pos)//珂朵莉树标准操作*1 
{
	IT it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos) return it;
	--it;
	int tl=it->l;
	int tr=it->r;
	int tv=it->v;
	s.erase(it);
	s.insert(node(tl,pos-1,tv));
	return s.insert(node(pos,tr,tv)).first; 
}
inline void assign_val(int l,int r,int val)//珂朵莉树标准操作*2 
{
	IT itr=split(r+1),itl=split(l);
	s.erase(itl,itr);
	s.insert(node(l,r,val));
}
inline bool cmp(node2 p,node2 q)//排序 按照 h 从小到大排序 
{
	return p.v<q.v;
}
int main()
{
	while(scanf("%d %d %d",&rl,&rh,&rr)!=EOF)//读入 
	{
		n++;//保存 
		a[n].l=rl;
		a[n].r=rr-1;//细节*1 
		a[n].v=rh;
	}
	sort(a+1,a+n+1,cmp);//排序 
	s.insert(node(1,20010,0));//插入整个区间 既然不大 那就插两倍的 
	for(int i=1;i<=n;i++)//一个一个推平 
		assign_val(a[i].l,a[i].r,a[i].v);
	for(IT it=s.begin();it!=s.end();++it)//暂存一下 
		ans.push_back(node2{it->l,it->r,it->v});
//	for(int i=0;i<ans.size();i++)
//		printf("%d %d %d\n",ans[i].l,ans[i].r,ans[i].v);
	if(ans[0].v!=0) printf("%d %d ",ans[0].l,ans[0].v);//特判开头轮廓线是不是已经有建筑了 
	for(int i=1;i<ans.size();i++)
		if(ans[i].v!=ans[i-1].v)//不等于就等于变化了 
		{
			printf("%d %d ",ans[i].l,ans[i].v);//输出呗  
		}
	puts(""); 
	return 0;
}



```
祝大家 $\text{N方过百万 暴力碾标算}$ 

---

## 作者：doby (赞：4)

不难发现轮廓线上的点坐标都在轮廓高度发生变化的位置上

而对于输出，可以发现就是高度发生变化的横坐标与变化后的高度

而当前轮廓的高度就是当前最高楼房的高度

扫描线再维护最大值

这里用Splay

//其实暴力都可以轻松通过

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n=1,xm,ym,hst1,hst2,in,u=1,root,tot;
struct House
{
	int x,y,h;
}h[5010];
struct Splay
{
	int son[2],fa,val,size,cnt;
}t[5010];
bool cmp(House a,House b)//根据楼房先后顺序排序
{
	if(a.x==b.x){return a.h>b.h;}
	return a.x<b.x;
}
int min(int a,int b)
{
	return a<b?a:b;
}
int max(int a,int b)
{
	return a>b?a:b;
}
int New(int x)
{
	t[++tot].val=x,t[tot].cnt=1,t[tot].size=1;
	return tot;
}
void Update(int p)
{
	t[p].size=t[t[p].son[0]].size+t[t[p].son[1]].size+t[p].cnt;
}
int Relate(int p)
{
	return t[t[p].fa].son[1]==p; 
}
void Connect(int p,int fa,bool which)
{
	t[p].fa=fa;
	if(fa){t[fa].son[which]=p;}
}
void Rotate(int p)
{
	int fa=t[p].fa;
	bool lr=Relate(p);
	Connect(p,t[fa].fa,Relate(fa));
	Connect(t[p].son[lr^1],fa,lr);
	Connect(fa,p,lr^1);
	Update(fa);Update(p);
}
void Splay(int p,int goal)
{
	for(int fa;(fa=t[p].fa)!=goal;Rotate(p))
	{
		if(t[fa].fa!=goal){Rotate(Relate(p)==Relate(fa)?fa:p);}
	}
	if(!goal){root=p;}
}
void Insert(int x)
{
	if(!root){New(x);root=tot;return;}
	int now=root;
	while(1)
	{
		if(x==t[now].val)
		{
			++t[now].cnt;
			Update(now);Update(t[now].fa);
			Splay(now,0);
			return;
		}
		int fa=now;
		bool which=x>t[now].val;
		now=t[fa].son[which];
		if(!now)
		{
			New(x);
			Connect(tot,fa,which);
			Update(fa);
			Splay(tot,0);
			return;
		}
	}
}
void Find(int x)
{
	if(!root){return;}
	int now=root;
	while(t[now].son[x>t[now].val]&&t[now].val!=x){now=t[now].son[x>t[now].val];}
	Splay(now,0);
}
int GP(int x)
{
	Find(x);
	if(t[root].val<x){return root;}
	int now=t[root].son[0];
	while(t[now].son[1]){now=t[now].son[1];}
	return now;
}
int GN(int x)
{
	Find(x);
	if(t[root].val>x){return root;}
	int now=t[root].son[1];
	while(t[now].son[0]){now=t[now].son[0];}
	return now;
}
void Delete(int x)
{
	int pre=GP(x),nxt=GN(x);
	Splay(pre,0);
	Splay(nxt,pre);
	int del=t[nxt].son[0];
	if(t[del].cnt>1)
	{
		t[del].cnt--;
		Splay(del,0);
	}
	else{t[nxt].son[0]=0;}
}
int GVBR(int rank)
{
	int now=root;
	while(now)
	{
		if(t[now].son[0]&&rank<=t[t[now].son[0]].size)
		{
			now=t[now].son[0];
			continue;
		}
		rank-=t[t[now].son[0]].size+t[now].cnt;
		if(rank<=0){return t[now].val;}
		now=t[now].son[1];
	}
}
int main()
{
	Insert(-19260817);Insert(19260817);//在删除时需要查找前驱和后继，可以插入一个inf与-inf
	while(scanf("%d%d%d",&h[n].x,&h[n].h,&h[n].y)!=EOF)//特殊的读入处理
	{
		xm=min(xm,h[n].x),ym=max(ym,h[n].y);
		++n;
	}
	--n;
	sort(h+1,h+n+1,cmp);
	for(int i=xm;i<=ym;++i)
	{
		hst2=0;
		while(h[u].x==i)//把当前楼房插入
		{
			Insert(h[u].h);
			++u,++in;
		}
		for(int j=1;j<=u;++j)//这里可以优化，不过O(nm)也足以通过这题
		{
			if(h[j].y==i){Delete(h[j].h);--in;}//把结束的楼房删除
		}
		hst2=max(hst2,GVBR(in+1));//更新此时的高度
		if(hst1!=hst2){printf("%d %d ",i,(hst2==-19260817?0:hst2));}
		hst1=hst2;//保存此时的高度
	}
	return 0;
}
```

---

## 作者：Most_Goodlooking (赞：3)

我们可以对横坐标进行建树，并且把每一栋建筑看作是对**一段区间进行赋值**，
所以**ODT，珂朵莉树**登场，不会的先看[ODT模板](https://www.luogu.org/problem/CF896C)
因为是对区间进行赋值，

并且每次**输出最高的高度**。

所以我们可以在输入之后先按高度对建筑进行从小到大的排序这样就不需要在赋值的时候考虑区间最大值问题。赋的就直接是当前区间的最大值了。

AC代码奉上。

如果对代码有疑问的在下面提出或者私聊，后续还会添加一些对代码的注释。
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<set>
#include<queue>
#include<vector>
using namespace std;
struct n
{
    int l;
    int h;
    int r;//进行储存建筑的代码
}num[5005];
struct node
{
    int l;
    int r;
    int h;
    bool operator<(const node &a)const{
        return l<a.l;
    }
};
set<node> tree;
set<node>::iterator split(int pos){//ODT核心函数。不会的见CF896C题解。
    set<node>::iterator iter=tree.lower_bound((node){pos,0,0});
    if (iter!=tree.end()&&iter->l==pos)
    {
        return iter;
    }
    iter--;
    int ll=iter->l;
    int rr=iter->r;
    int pt=iter->h;
    tree.erase(iter);
    tree.insert((node){ll,pos-1,pt});
    return tree.insert((node){pos,rr,pt}).first;
}
void add(int l,int r,int pt){
    set<node>::iterator itr=split(r+1),itl=split(l);
    tree.erase(itl,itr);//是的就三行。
    tree.insert((node){l,r,pt});
    return;
}
int cmp(const void *a,const void *b){
    return (*((n *)a)).h>(*(n *)b).h;//qsort快排函数，需要反着写，让建筑按从小到大排。
}
int main(void){
    int pt=0,l,r,h,rmax=0;
    while (scanf("%i%i%i",&num[pt].l,&num[pt].h,&num[pt].r)!=EOF)
    {
        rmax=max(rmax,num[pt].r);//储存建筑
        num[pt].r--;//不明白为什么要-1的看样例。
        pt++;
    }
    tree.insert((node){0,rmax,0});//建筑，就一行
    qsort(num,pt,sizeof(n),cmp);
    for (int i = 0; i < pt; i++)
    {
        add(num[i].l,num[i].r,num[i].h);
    }//区间赋值。
    set<node>::iterator iter;
    int now=0;
    bool open=0;
    for (iter = tree.begin(); iter != tree.end()&&iter->h==0; iter++)
    {
        now=iter->h;
    }//过滤前导0
    for (iter; iter != tree.end(); iter++)
    {
        if (iter->h!=now)
        {
            if (open)
            {
                open=1;
                printf(" ");
            }
            printf("%i %i",iter->l,iter->h);
            open=1;
        }
        now=iter->h;//储存上一个的大小，防止出现连续区间相同高度却输出这种情况。
    }
    return 0;
}
```


---

## 作者：xiaoDiPa (赞：2)

线段树维护两个值，区间最大值（val）和该区间是否平坦（isbroke），每次用楼高更新区间内的两个值，有多种情况：

 1 isbroke=0且val > now_val(就是v)
直接return
	
         1.5 val < v  val=tag=v,return

 2 isbroke=1且val < v
isbroke=0 val=tag=v

 3 isbroke=1且val > v
不更改val和isbroke,但打上tag=v


------------

 当前区间递归完成后如果(tree[i*2].val != tree[i*2+1].val || tree[i*2].isbroke || tree[i*2+1].isbroke)==1，那么tree[i].isbroke = 1 否则 =0

------------


------------
 查询时若遇到目标点所在区间的isbroke == 0，那么直接返回val，否则pushdown后继续。pushdown时在自己的tag和儿子的tag中选最大值赋给儿子，也有两种情况具体在代码中。

```cpp
#include<iostream>
using namespace std;
struct node
{
	int val,tag;
	bool isbroke;
} tree[100001];
int n;
void pushdown(int i)
{
	if(tree[i].tag&&tree[i*2].val<=tree[i].tag)
	{
		tree[i*2].val=tree[i*2].tag=tree[i].tag;
		tree[i*2].isbroke=0;
	}
	else if(tree[i].tag)
	{
		if(tree[i*2].isbroke)
		{
			tree[i*2].tag=max(tree[i*2].tag,tree[i].tag);
		}
	}
	if(tree[i].tag&&tree[i*2+1].val<=tree[i].tag)
	{
		tree[i*2+1].val=tree[i*2+1].tag=tree[i].tag;
		tree[i*2+1].isbroke=0;
	}
	else if(tree[i].tag)
	{
		if(tree[i*2+1].isbroke)
		{
			tree[i*2+1].tag=max(tree[i*2+1].tag,tree[i].tag);
		}
	}
	tree[i].tag=0;
	return;
}
void change(int i,int nl,int nr,int tl,int tr,int v)
{
	int mid=(nl+nr)/2;
	if(nr<tl||nl>tr)
	{
		return;
	}
	else if(tl<=nl&&nr<=tr)
	{
		if(tree[i].isbroke==0)
		{
			if(tree[i].val>=v)
			{
				return;
			}
			else
			{
				tree[i].val=v;
				tree[i].tag=v;
			}
		}
		else
		{
			if(tree[i].val<v)
			{
				tree[i].val=v;
				tree[i].tag=v;
				tree[i].isbroke=0;
			}
			else
			{
				tree[i].tag=v;
			}
		}
	}
	else
	{
		pushdown(i);
		change(i*2,nl,mid,tl,tr,v);
		change(i*2+1,mid+1,nr,tl,tr,v);
		if(tree[i*2].val!=tree[i*2+1].val||tree[i*2].isbroke==1||tree[i*2+1].isbroke==1)
		{
			tree[i].isbroke=1;
		}
		else
		{
		    tree[i].isbroke=0;
		}
		tree[i].val=max(tree[i*2].val,tree[i*2+1].val);
	}

}
int query(int i,int nl,int nr,int target)
{
	int mid=(nl+nr)/2;
	if(target<nl||nr<target)
	{
		return 0;
	}
	else if(nl<=target&&target<=nr)
	{
		if(tree[i].isbroke==0)
		{
			return tree[i].val;
		}
		else
		{
			pushdown(i);
			return max(query(i*2,nl,mid,target),query(i*2+1,mid+1,nr,target));
		}
	}
}
int main()
{
	int t1,t2,t3;
	while(cin>>t1>>t3>>t2)
	{
		change(1,1,10001,t1,t2-1,t3);
	}
	int last=0,now;
	int cnt=0;
	for(int i=1; i<=10001; i++)
	{
		now=query(1,1,10001,i);
		if(now==0&&last==0)
		{
			1;
		}
		else if(now!=last)
		{
			cnt++;
			cout<<(cnt%2==0?last:i)<<" ";
			cnt++;
			cout<<(cnt%2==0?now:i)<<" ";

		}
		last=now;
	}
}
```


---

## 作者：zhenglier (赞：2)

其实这题用STL做非常简单，我们对于每个点开两个vector记录当前点是哪几个楼的左边点，哪几个楼的右边点（即当前点要放入那个楼，要弹出那个楼。）。再开一个multiset维护一下当前最大值就行了。

输入时在左端点的add数组里放入h，在右端点的del数组里放入h。

然后从左到右扫描就行了。

$\color{white}\text{记住删除multiset里的元素时要删除迭代器而不能删掉数字，不然会删掉所有当前数字。}$

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> add[10000],del[10000];
multiset<int>tr;
int a[10000],zuo=1e9,you=-1e9;
int l,h,r;
int main(){
	while(~scanf("%d%d%d",&l,&h,&r)){
		you=max(you,r);
		zuo=min(zuo,l);
		add[l].push_back(h);
		del[r].push_back(h);
	}
	tr.insert(0);
	for(int i=zuo;i<=you;++i){
		vector<int>::iterator it;
		multiset<int>::iterator pos;
		for(it=add[i].begin();it!=add[i].end();++it){
			tr.insert(*it);
		}
		for(it=del[i].begin();it!=del[i].end();++it){
			pos=tr.find(*it);
			tr.erase(pos);
		}
		pos=tr.end();
		pos--;
		a[i]=*pos;
//		cout<<*pos<<endl;
	}
	int l=0,cur=0;
	for(int i=zuo;i<=you;++i){
		if(l==a[i])continue;
		else{
			if(!cur)printf("%d ",i);
			else printf("%d ",l);
			cur^=1;
			if(!cur)printf("%d ",i);
			else printf("%d ",a[i]);
			cur^=1;l=a[i];
		}
	}
}
```

---

## 作者：littleKtian (赞：1)

~~因为不想打扫描线所以……~~

因为对于整个轮廓线，我们只要知道各个位置最高的建筑的高度即可，所以考虑用线段树进行维护

首先第一感觉肯定是维护下图中每个红点位置上最高的建筑的高度信息，从而描述整个轮廓线    
![](https://cdn.luogu.com.cn/upload/image_hosting/sc8rc1vk.png)

~~然而很不幸这样并不行~~

于是将维护对象从每个红点换成下图中每段绿色线段的信息，当某个红点左右两侧线段信息不同时意味着轮廓线在此出现折点
![](https://cdn.luogu.com.cn/upload/image_hosting/yzk9eiop.png)

注意如果是直接在线段树上进行区间覆盖需要提前排序，按建筑高度从矮到高进行修改

```
#include<bits/stdc++.h>
#define ls(w) w<<1
#define rs(w) (w<<1)^1
using namespace std;
const int n=10000;
struct jgt{
	int l,r,x;
};
jgt a[5005],tree[(n<<3)+5];
int i,h[(n<<1)+5];
bool cmp(jgt x,jgt y){return x.x<=y.x;}
void csh(int w,int l,int r)
{
	tree[w].l=l,tree[w].r=r;
	if(l==r)return;
	int mid=(l+r)>>1;
	csh(ls(w),l,mid),csh(rs(w),mid+1,r);
}
void cd(int w){if(tree[w].x)tree[ls(w)].x=tree[rs(w)].x=tree[w].x,tree[w].x=0;}
void xg(int w,int l,int r,int x)
{
	if(l<=tree[w].l&&tree[w].r<=r){tree[w].x=x;return;}
	cd(w);
	int mid=(tree[w].l+tree[w].r)>>1;
	if(l<=mid)xg(ls(w),l,r,x);
	if(mid<r)xg(rs(w),l,r,x);
}
void bl(int w)
{
	if(tree[w].l==tree[w].r){h[tree[w].l]=tree[w].x;return;}
	cd(w),bl(ls(w)),bl(rs(w));
}
int main()
{
	while(scanf("%d%d%d",&a[i].l,&a[i].x,&a[i].r)==3)++i;
	sort(a,a+i,cmp);
	csh(1,1,n<<1);
	for(int j=0;j<i;j++)xg(1,a[j].l<<1,(a[j].r<<1)-1,a[j].x);
	bl(1);
	for(int j=1;j<=n;j++)if(h[(j<<1)-1]!=h[j<<1])printf("%d %d ",j,h[j<<1]);
}
```


---

## 作者：Setsugesuka (赞：1)

不难发现这道题是一个底相同的扫描线题目，大矩形覆盖小矩形和一段值更高的区间覆盖一段值小的区间是等价的，我们用珂朵莉树就能很好地维护了。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;

template <class T>
inline bool read(T &ret)
{
    char c;
    int sgn;
    if (c = getchar(), c == EOF)
    {
        return 0;
    }
    while (c != '-' && (c < '0' || c > '9'))
    {
        c = getchar();
    }
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9')
    {
        ret = ret * 10 + (c - '0');
    }
    ret *= sgn;
    return 1;
}

template <class T>
inline void write(T x)
{
    if (x > 9)
    {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}

struct node
{
    int l,r,v;
    node(){}
    node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
    inline bool operator <(const node &o) const
    {
        return l<o.l;
    }
};

struct house
{
    int l,r,h;
    inline bool operator <(const house &o) const
    {
        return h<o.h;
    }
};

set<node> s;

int n;
house a[100010];
vector<pair<int,int> >ans;

inline void merge(int l)
{
    set<node>::iterator it1,it2,it3;
    it2=s.lower_bound(l);
    if(it2==s.begin())
        return;
    it1=it2,it3=it2;
    --it1,++it3;
    bool pd3=(it3!=s.end());
    if(pd3&&it1->v==it2->v&&it2->v==it3->v&&it1->v==it3->v)
    {
        int l=it1->l,r=it3->r,v=it2->v;
        s.erase(it1,++it3);
        s.insert(node(l,r,v));
    }
    else if(it1->v==it2->v)
    {
        int l=it1->l,r=it2->r,v=it2->v;
        s.erase(it1,++it2);
        s.insert(node(l,r,v));
    }
    else if(pd3&&it2->v==it3->v)
    {
        int l=it2->l,r=it3->r,v=it2->v;
        s.erase(it2,++it3);
        s.insert(node(l,r,v));
    }
}

inline set<node>::iterator split(int pos)
{
    set<node>::iterator it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos) return it;
    --it;
    int L=it->l,R=it->r,V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}

inline void assignval(int l,int r,int v)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,v));
}

inline void query()
{
    set<node>::iterator it=s.begin();
    while(it!=s.end())
    {
        for(;it!=s.end();++it)
        {
            if(it->v!=0)
                break;
        }
        if(it==s.end())
            break;
//        ans.push_back(make_pair((it->l)/2,0));
        ans.push_back(make_pair((it->l)/2,it->v));
        for(;it!=s.end();++it)
        {
            if(it->v==0)
                break;
            int ccv1=it->v,ccpos1=it->r;
            ++it;
            int ccv2=it->v,ccpos2=it->l;
            --it;
            if(ccv2==ccv1)continue;
            else if(ccv2>ccv1)
            {
//                ans.push_back(make_pair(ccpos2/2,ccv1));
                ans.push_back(make_pair(ccpos2/2,ccv2));
            }
            else
            {
//                ans.push_back(make_pair(ccpos1/2,ccv1));
                ans.push_back(make_pair(ccpos1/2,ccv2));
            }
        }
    }
}

int main()
{
    n=0;
    s.insert(node(0,20010));
    int sr;
    while(scanf("%d",&sr)!=EOF)
    {
        n++;
        a[n].l=sr,read(a[n].h),read(a[n].r);
        a[n].l*=2;
        a[n].r*=2;
    }
    sort(a+1,a+n+1);
    for(register int i=1;i<=n;++i)
    {
        assignval(a[i].l,a[i].r,a[i].h);
        merge(a[i].l);
        merge(a[i].r);
    }
    query();
    int sz=ans.size();
    for(register int i=0;i<sz;++i)
    {
        printf("%d %d ",ans[i].first,ans[i].second);
    }
    return 0;
}
```


---

## 作者：brealid (赞：1)

## 一句话思路
sort + priority_queue

## 具体思路

### step#1 : 读入
把一个 building 拆成两条垂直于地平线的 line，高度均为 $h_i$，横坐标分别为 $l_i$ 与 $r_i$（另外给每条 line 增加一个参数 type 表示该 line 是在一个 building 的左边还是右边）。

### step#2 : sort
按横坐标对这 $2n$ 条 line 进行 sort

### step#3 : priority_queue (答案处理)
一条条扫过去，分俩种情况：

1. 这条 line 是一个 building 的左边（开始）：push 进 priority_queue（priority_queue 权值按高度，大根堆）  
2. 这条 line 是一个 building 的右边（结束）：标记该 building 为 ended，然后 pop 掉 priority_queue 顶端的所有过时的 line

## 这种做法需要注意的地方
两个 building 可能相邻而不重合，需要处理，否则可能会 $\text{WA}\ \ 80pts$  
处理方法：在一开始 sort 时比较函数里若两条 line 的横坐标相同，则比较其 type，位于一个 building 左边的 line “小”

大概思路是这样，具体见代码

## Code

```cpp
/*************************************
 * problem:      P1904 天际线.
 * user ID:      63720.
 * user name:    Jomoo.
 * time:         2019-08-04.
 * language:     C++.
 * upload place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;

template <typename Int>
inline Int read()       
{
    Int flag = 1;
    char c = getchar();
    while ((!isdigit(c)) && c != '-') c = getchar();
    if (c == '-') flag = -1, c = getchar();
    Int init = c & 15;
    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);
	return init * flag;
}

template <typename Int>
inline void write(Int x)
{
    if (x < 0) putchar('-'), x = ~x + 1;
    if (x > 9) write(x / 10);
    putchar((x % 10) | 48);
}  

template <typename Int>
inline void write(Int x, char nextch)
{
    write(x);
    putchar(nextch);
}

int n = 0;
#define NEW_BUILDING 1
#define END_BUILDING 0
struct Line {
    int buildingId;
    bool type;
    int pos, high;
    bool operator < (const Line &other) const
    {
        return pos != other.pos ? pos < other.pos : type > other.type;
    }
} b[100000 + 7];

struct PQ_Node {
    int buildingId;
    int pos, high;
    PQ_Node(const Line other) {
        buildingId = other.buildingId;
        pos = other.pos;
        high = other.high;
    }
    bool operator < (const PQ_Node &other) const
    {
        return high < other.high;
    }
};

bool readln()
{
    static int l, h, r;
    if (scanf("%d%d%d", &l, &h, &r) == EOF) return false;
    b[n] = (Line){n >> 1, NEW_BUILDING, l, h};
    n++;
    b[n] = (Line){n >> 1, END_BUILDING, r, h};
    n++;
    return true;
}

bool ended[50000 + 7] = {false};

priority_queue<PQ_Node> pq;

int main()
{
    while (readln());
    sort(b, b + n);
    int y = 0;
    for (int i = 0; i < n; i++) {
        if (b[i].type == NEW_BUILDING) {
            pq.push(PQ_Node(b[i]));
            if (pq.top().high != y) {
                y = pq.top().high;
                write(b[i].pos, 32);
                write(y, 32);
            }
        } else {
            ended[b[i].buildingId] = true;
            while (!pq.empty() && ended[pq.top().buildingId]) pq.pop();
            if (pq.empty() || pq.top().high != y) {
                y = pq.empty() ? 0 : pq.top().high;
                write(b[i].pos, 32);
                write(y, 32);
            }
        }

    }
    return 0;
}
```

---

## 作者：Mufanc (赞：0)

## ~~STL大法好~~##

对于每一座建筑物，我们只需要将其左右边界存入一个表示命令的队列数组中，然后从0开始遍历坐标，如果遇到左边界则将这条左边界对应的那个矩形的高加入平衡树，遇到右边界则从树中删除这条右边界对应的那个矩形的高，每次取平衡树中最大值输出即可
```cpp
#include <cstdio>
#include <set>
#include <queue>
const int maxn = 5005;
const int maxp = 10005;
using namespace std;

struct obj{
    int l, h, r;
}rect[maxn];//定义矩形
int n = 0;
queue<int> inc[maxp], out[maxp];
//inc[i]存储了位于x=i这条直线上的左边界对应的矩形编号
//out[i]同理

struct pir{
    int key, h;
};
pir make_pir(int _k, int _h){
    pir p;
    p.key = _k, p.h = _h;
    return p;
}
bool operator < (pir a, pir b){
    return a.h > b.h;//定义小于号，使每次取出的高度为当前树中最大高度
}
multiset<pir> task;

int main(){
    while(~scanf("%d %d %d", &rect[n].l, &rect[n].h, &rect[n].r))
        n++;//输入
    for(int i = 0; i < n; i++){
        inc[rect[i].l].push(i);
        out[rect[i].r].push(i);
    }
    int now, last = 0;
    for(int i = 0; i < maxp; i++){
        while(!inc[i].empty()){
            int fnt = inc[i].front(); inc[i].pop();
            task.insert(make_pir(fnt, rect[fnt].h));
        }
        while(!out[i].empty()){
            int fnt = out[i].front(); out[i].pop();
            task.erase(make_pir(fnt, rect[fnt].h));
        }
        multiset<pir>::iterator it = task.begin();
        now = it -> h;
        if(last != now){//若最高度发生改变，则输出
            printf("%d %d ", i, now);
        }
        last = now;
    }
	return 0;
}

```

---


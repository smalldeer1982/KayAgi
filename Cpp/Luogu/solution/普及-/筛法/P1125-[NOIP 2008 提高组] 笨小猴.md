# [NOIP 2008 提高组] 笨小猴

## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。


## 说明/提示

【输入输出样例 1 解释】

单词 `error` 中出现最多的字母 $\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。

【输入输出样例 2 解释】

单词 `olympic` 中出现最多的字母 $\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。

（本处原题面错误已经修正）

noip2008 提高第一题


## 样例 #1

### 输入

```
error```

### 输出

```
Lucky Word
2```

## 样例 #2

### 输入

```
olympic```

### 输出

```
No Answer
0```

# 题解

## 作者：luhongrui (赞：109)

#  P1125 【笨小猴】
## 思路
将题目的输入字符中相同的数量存储到一个数组中，然后找出最大和最小，相减后判断是否是质数，输出。
## 实现
废话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[26];//用来储存每一个字母的数量
int main(){
    int le=0,xunhuan=0,maxn=-500,minn=9999;//le 是单词的长度，xunhuan 是临时变量
    string s;
    cin>>s;
    le=s.size();//求出单词的长度
    for(int i=0;i<=le-1;i++){
        xunhuan=s[i];
        a[xunhuan-97]++;//累计字母数量
    }
    int zhishu[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};//质数表，100以内足够用了
    for(int i=0;i<=25;i++){
        if(a[i]<minn&&a[i]!=0)minn=a[i];//找出最少的字母
    }
    for(int i=0;i<=25;i++){
        if(a[i]>maxn)maxn=a[i];//找出最多的字母
    }
    int cha=maxn-minn;//相减
    for(int i=0;i<=24;i++){
        if(cha==zhishu[i]){
            cout<<"Lucky Word"<<endl;
            cout<<cha;//如果是质数直接输出并结束程序
            return 0;
        }
    }
    cout<<"No Answer"<<endl;//如果找完了还没有就不是质数
    cout<<"0";
    return 0;
} 
```
3ms AC

最后在推荐一下自己的博客

[](https://www.luogu.org/blog/wozhendexiangbudaole/)点这里


---

## 作者：hbdcsd (赞：11)

## 思路

先用一个数组记录每一个字母出现的次数，然后再循环查找数组中的最大最小值，记得别统计次数等于 $0$，即没出现的的情况。

根据质数在大于 $1$ 小于它本身的正整数中没有因子，判断最大值和最小值的差，记得特判小于 $2$ 时不是质数。最后按照题目要求输出即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int cnt[30], maxn, minn = 105;
bool prime(int x){
	if(x <= 1) return 0;//记得特判 x<1
	for(int i = 2; i < x; i++)
		if(x % i == 0) return 0;
	return 1;
}
int main(){
	cin >> s;
	for (int i = 0; i < s.length(); i++){
		cnt[s[i]-'a']++;
	}
	for (int i = 0; i < 26; i++){
		maxn = max(maxn, cnt[i]);
		if (cnt[i] < minn && cnt[i] != 0) minn = cnt[i];
	}
	if (prime(maxn-minn)) cout << "Lucky Word\n" << maxn-minn;
	else cout << "No Answer\n0";
	return 0;
}
```

---

## 作者：lizhixun (赞：9)

## [题目传送门](https://www.luogu.com.cn/problem/P1125)

### $\texttt{Description}$

给定一个字符串，判断这个字符串中出现次数最多的字母出现的次数和出现最少的字母（至少 $1$ 次）的出现次数之差是否是质数。

### $\texttt{Solution}$

直接用桶数组或者 map 记录次数，然后遍历字符串找出最大值和最小值，最后求差再判断质数并且按题目要求输出即可。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

bool prime(int x) {
	if (x < 2) return false;
	
	for (int i = 2; i <= sqrt(x); i++) {
		if (x % i == 0) {
			return false;
		}
	}
	
	return true;
}

string s;
int ma = INT_MIN, mi = INT_MAX;
int sum[1005];

int main() {
	cin >> s;
	
	for (int i = 0; i < s.size(); i++) {
		sum[s[i]]++;
	}
	
	for (int i = 0; i < s.size(); i++) {
		ma = max(ma, sum[s[i]]);
		mi = min(mi, sum[s[i]]);
	}
	
	if (prime(ma - mi)) {
		cout << "Lucky Word" << endl << ma - mi;
	} else {
		cout << "No Answer" << endl << 0;
	}
	return 0;
}
```

---

## 作者：违规用户名Jd8@z5Fw (赞：4)

本题目所涉及的算法有：统计字符，素数判断。

## 统计字符：
我们可以使用 STL 中的 map 统计字符。

但我们还可以读入一个字符后，直接将他当作下标做桶计数，原因是字符被当作下标使用时，会将他转化为 ASCII 码。所以，你的数组记得开大点。

## 素数判断：
这一道题不需要使用筛法，普通判断就可以了。


AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m[10005];//下标计数
int n;
int maxx=-1,minn=100005;
string str;
int is_prime(int x){
	if(x<2) return 0;
	if(x==2) return 2;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			return 0;
		}
	}
	return x;
}
int main(){
	cin>>str;
	int len=str.size();
	for(int i=0;i<len;i++){
		m[str[i]]++;
	}
	for(char c='a';c<='z';c++){
		if(m[c]==0) continue;
		maxx=max(maxx,m[c]);
		minn=min(minn,m[c]);
	}
	int tmp=is_prime(maxx-minn);
	if(tmp==0){
		cout<<"No Answer\n0";
	}
	else{
		cout<<"Lucky Word"<<endl;
		cout<<tmp;
	}
	return 0;
}
```

---

## 作者：Frank_G (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1125)

# 简化题意

给出一个字符串，若字符串中出现次数最多的字母的出现次数减去字符串中出现次数最少的字母的出现次数的值是一个质数，就称这个字符串是一个 `Lucky Word`，然后再按题目要求输出。

# 思路

## 质数

做题之前，我们首先要明白质数是什么。

> 质数又称素数。一个大于 $1$ 的自然数，除了 $1$ 和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定 $1$ 既不是质数也不是合数）。—— 百度百科

此处判断是否为质数的代码：

```cpp
bool isprime(int n){
	if(n==0) return false;
	if(n==1) return false;
	for(int i=2;i*i<=n;i++){
		if(n%i==0) return false;
	}
	return true;
}
```

## 记录最大次数与最小次数

可以使用一个数组 $a$，用 $a_i$ 表示字符串中 ASCII 码表中字符 $a$ 后第 $i-1$ 个字符出现的次数，然后遍历数组 $a$，找出最大次数与最小次数，相减后判断是否为质数即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
string s;
int a[40],maxx,minn=300;
bool isprime(int n){
	if(n==0) return false;
	if(n==1) return false;
	for(int i=2;i*i<=n;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	cin >> s;
	for(int i=0;i<s.size();i++){
		a[(int)(s[i]-'a'+1)]++;
		maxx=max(maxx,a[(int)(s[i]-'a'+1)]);
	}
	for(int i=1;i<=26;i++){
		if(a[i]!=0) minn=min(minn,a[i]);
	}
	if(isprime(maxx-minn)==true){
		cout << "Lucky" << " " << "Word" << endl << maxx-minn;
	}
	else{
		cout << "No" << " " << "Answer" << endl << "0";
	}
	return 0;
}
```

[AC](https://www.luogu.com.cn/record/200295327) 记录。

---

## 作者：__sunshao321__ (赞：3)

## P1125 【笨小猴】

### 大致思路：

题目很简单，在输入时做一个 map 或哈希统计字符的个数，也可以直接用数组存（因为它会默认转为 ASCII），然后进行排序，找出 $maxn$ 与 $minn$，再相减并判断是否为质数（是输出 $\texttt{Lucky Word}$，否则输出 $\texttt{No Answer}$）。

### 判断质数：

从 $2$ 一直枚举到 $x$ 的平方根，如果有能被 $x$ 整除的，就返回假，若没有就返回真。

### 实现代码：

```cpp
//本人码风有点丑，勿喷。 
#include<bits/stdc++.h>
using namespace std;
int a[30],n,minn=INT_MAX,maxn;
bool P(int x){
	if(x<=1) return 0;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			return false;
		}
	}
	return true;
}
int main(){
	string s;
	cin>>s;
	for(int i=0;i<s.size();i++){
		a[s[i]-'a'+1]++;
		n=max(n,s[i]-'a'+1);
	}
	for(int i=1;i<=n;i++){
		maxn=max(maxn,a[i]);
		if(a[i]<minn && a[i]>0){
			minn=a[i];
		}
	}
	if(P(maxn-minn)) cout<<"Lucky Word\n"<<maxn-minn;
	else cout<<"No Answer\n0";
    return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

先开一个桶，统计每个字母的出现次数。

然后找出现次数最多和最少的字母，记 $cnt_i$ 表示字母 $i$ 的出现次数，注意一点，只有当 $cnt_i$ 不为 $0$ 即字母 $i$ 出现过才统计它，还有最大值初值设极小值，最小值初值设极大值。

再判断质数，找它的因数，如果它有除 $1$ 和它本身外的因数就不是质数，依据定义，小于 $2$ 的自然数不是质数。

最后按题意输出即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt[27], mx, mi=100;
bool isp (int n) {
	if (n<2) 
		return 0;
	for (int i=2; i<n; i++) 
		if (n%i==0) 
			return 0;
	return 1;
}
int main () {
	string s;
	cin >> s;
	for (int i=0; i<(int)s.size(); ++i)
		cnt[s[i]-'a']++;
	for (int i=0; i<26; i++)
		if (cnt[i])
			mx=max(mx, cnt[i]),
			mi=min(mi, cnt[i]);
	if (isp(mx-mi)) 
		cout << "Lucky Word\n" << mx-mi;
	else 
		cout << "No Answer\n0";
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：2)

### 题目意思
找出一个单词中出现次数最多的单词的出现次数和出现最少单词的次数，把两数相减，判断其是不是质数，是就输出这个差。
### 题目思路
找出出现次数最多，最少的单词次数不多讲，给出代码。

```cpp
	cin>>b;
	len=b.length();
	for(int i=0;i<len;i++) a[b[i]-'a'+1]++;//累加 
	for(int i=1;i<=26;i++)
    {
		if(a[i]!=0)
        {
	    	if(a[i]>ma) ma=a[i];//最大值 
	    	if(a[i]<mi) mi=a[i];//最小值 
		}
	}
```
接下来就要判断其是否是质数，我们用一种较为快速的方法，我们想，如果当前我们找出了某数的因子，则此数除以那个因子必是另一个因子。给出代码。

```cpp
long long node(long long a){
	if(a<=1) return 1;
	for(int i=2;i*i<=a;i++)
    {
		if(a%i==0) return 1;
	}
	return 2;
}
```
总代码就不给出了，谢谢。

---

## 作者：maziming (赞：2)

## 题意：
给我们一个字符串（只包含小写字母），将其中出现次数最多的字母的个数减去出现次数最少的字母的个数（不含没出现过的），得数如果是质数，就输出 `Lucky Word` ，然后换行输出得数，如果不是质数，就输出 `No Answer` ，然后换行输出 $0$ 。
## 思路：
首先，我们要记录这个字符串每个字母出现的个数，然后将其从小到大排序。
```cpp
for(int i=0;i<a.size();i++)
		s[a[i]-'a']++;//运用ASCLL码计数
	sort(s+1,s+27);
```
然后，因为没有出现的字母也会排序，所以我们要找到出现次数最少 且出现过的字母，让出现次数最多的字母的个数减去出现次数最少的字母的个数。
```cpp
for(int i=1;i<=26;i++)
    if(s[i]>0){//找出现次数次数最少 且出现过的字母
      s[1]=s[i];
    	if(aa(s[26]-s[1])==1)cout<<"Lucky Word\n"<<s[26]-s[1];//判断质数
    	else cout<<"No Answer\n"<<0;
    	break;
    }
```
最后用`aa`函数判断质数就行了。
```ccp
ll aa(ll x)
{
	if(x==0||x==1)return 0;
	for(int i=2;i<=sqrt(x);i++)
		if(x%i==0)return 0;
	return 1;
}
```
相信大家都会判断质数，这里就不解释了。
## 附上所有代码：
```ccp
#include<bits/stdc++.h>
using ll=long long;
using namespace std;
ll s[27];
string a;
ll aa(ll x)
{
	if(x==0||x==1)return 0;
	for(int i=2;i<=sqrt(x);i++)
		if(x%i==0)return 0;
	return 1;
}
int main()
{
	cin>>a;
	for(int i=0;i<a.size();i++)
		s[a[i]-'a']++;//运用ASCLL码计数
	sort(s+1,s+27);
	for(int i=1;i<=26;i++)
		if(s[i]>0){//找出现次数次数最少 且出现过的字母
			s[1]=s[i];
			if(aa(s[26]-s[1])==1)cout<<"Lucky Word\n"<<s[26]-s[1];//判断质数 
			else cout<<"No Answer\n"<<0;
			break;
		}
    return 0;
}
```

---


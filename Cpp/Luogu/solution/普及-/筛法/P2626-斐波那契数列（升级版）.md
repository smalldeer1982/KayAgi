# 斐波那契数列（升级版）

## 题目背景

大家都知道，斐波那契数列是满足如下性质的一个数列： 

- $f(1) = 1$
- $f(2) = 1$ 
- $f(n) = f(n-1) + f(n-2)$（$n > 2$ 且 $n$ 为整数）。


## 题目描述

请你求出第 $n$ 个斐波那契数列的数 $\bmod\,2^{31}$ 之后的值，并把它分解质因数。


## 说明/提示

$n \le 48$

## 样例 #1

### 输入

```
5```

### 输出

```
5=5```

## 样例 #2

### 输入

```
6```

### 输出

```
8=2*2*2```

# 题解

## 作者：williamllk (赞：199)

按照惯例 先来一个[传送门](https://www.luogu.org/problem/P2626)

怎么说，这道题都是一道比较水的题

这道题分为两个部分，求第n个斐波那契数，再将它分解质因数

首先先给求斐波那契数列的核心代码

```cpp
for(int i=3;i<=n;i++)
	a[i]=a[i-1]+a[i-2];
```

再给一个分解质因数的核心代码

```
for(int i=2;i<=s;i++){
	if(s%i==0){
		cout<<i;
		s/=i;
		if(s!=1) cout<<"*";
		i=1;
	}
}
```

最后给出AC代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a[1001],n,s;
	a[1]=1;
	a[2]=1;
	cin>>n;
	for(int i=3;i<=n;i++){
		a[i]=a[i-1]+a[i-2];
	}
	s=a[n];
	cout<<a[n]<<"=";
	for(int i=2;i<=s;i++){
		if(s%i==0){
			cout<<i;
			s/=i;
			if(s!=1) cout<<"*";
			i=1;
		}
	}                
	return 0;                       
}
```
各位看官，如果有用的话就点个赞再走！

---

## 作者：绝顶我为峰 (赞：41)

又是一道水题呢~

斐波那契数列用递推方法可以轻轻松松的计算出来，分解质因数注意一下乘号的输出问题就能轻松AC(｡◕ˇ∀ˇ◕)

~~本来还担心会超时~~o((⊙﹏⊙))o

上代码吧！

```cpp
#include<iostream>
#include<cmath>
const long long MOD=pow(2,31);//常量，防止重复计算浪费时间
using namespace std; 
int n,f[49],x;
int main()
{
	cin>>n;
	f[1]=1;
	f[2]=1;
	for(int i=3;i<=n;i++)
		f[i]=(f[i-1]+f[i-2])%MOD;//递推，f[i]=f[i-1]+f[i-2]再取余
	cout<<f[n]<<"=";//分解质因数
	for(int i=2;i<=f[n];i++)
		while(f[n]%i==0)//遇到能除尽的就往下使劲除
		{
			x++;//乘号输出控制
			if(x==1)
				cout<<i;
			else
				cout<<"*"<<i;
			f[n]/=i;//分解后将这个因数去除
		}
	cout<<endl;
	return 0;//完美结束
}
```

---

## 作者：KesdiaelKen (赞：20)

此题可以看做是一道因数分解模板题。

首先，用递推式f[i]=f[i-1]+f[i-2]，算出斐波拉契数列的第n项（注意要mod2^31（代表着要开long long））。然后，将此项因式分解就可以了。

而注意，如果直接O（n）枚举因数，可能会TLE。因此，需要将n开方，然后因数从2-sqrt(n)枚举，最后再加一个特判，是否还没有分解完。如果没有分解完，那因为我们枚举的是从2-sqrt(n)的因数，所以最多只剩下一个质数没有被枚举到，所以直接输出剩下的数就可以了。

这里给喜欢超短、超简洁代码的人提供了一个福利。（并没有太多的压行，思路还是蛮清晰的~）这里运用了大量位运算，具体的注释请见代码：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    long long f[50]={0,1,1};//初始化
    int n;scanf("%d",&n);//读入
    for(int i=3;i<=n;i++)f[i]=f[i-1]+f[i-2];f[n]%=1<<31;//从f[3]开始，推到n，不会爆long long（记得取模）（1<<31即2^31）
    printf("%lld=",f[n]);//输出f[n]
    if(n==2){printf("1");return 0;}//如果是第二项（注意到n>=2了吗？），则直接输出1，特判一下
    long long ssqrt=sqrt(f[n]);//取n的开方
    bool tf=false;//判断是否输出*用
    for(long long i=2;i<=ssqrt&&f[n]!=1;i++)//循环，f[n]==1时则无需继续枚举
    while(!(f[n]%i)){tf?printf("*%d",i):printf("%d",i);f[n]/=i;tf=true;}//如果是整除则%会的0，！0==true；三目运算符，判断是否要输出*
    if(f[n]-1)tf?printf("*%d",f[n]):printf("%d",f[n]);//如果剩的不是1，则输出，记得还要判断是否输出*
    return 0;
}
```

---

## 作者：『　』 (赞：9)

不需要用递推求第n项，直接用通项公式（比内公式）

f(n)=(1/√5)\*{[(1+√5)/2]^n-[(1-√5)/2]^n}

证明过程出门左转百度百科

https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define For(i,a,b)  for(i=a;i<=b;i++)
#define Forr(i,a,b)  for(i=a;i>=b;i--)
using namespace std;
long long  f[50];
void do1(int x)
{
    if(x==1)
    {
        printf("1");return;//特判1
    }
    if(x==2)
    {
        printf("2");return;//特判2
    }
    int k=x,i;
    for(i=2;i*i<=k;i++)//枚举比√k小的数
    {
        if(k%i==0&&k!=i)//能整出，为质因数，输出
        {
                printf("%d*",i);
                k/=i;//缩小
                i--;//处理多个质因数相等
        }
    }
    printf("%d",k);//输出k本身（现在本身也是个质因数了）
}
int main()
{
    int n,ans=0,m=0,k,i,j,t;
    scanf("%d",&n);
    f[n]=((1/sqrt(5))*(pow((1+sqrt(5))/2,n)-pow((1-sqrt(5))/2,n)));//计算第n项，sqrt是根号（开方）,pow是乘方
    f[n]%=2147483648;//取模（直接在上面取不知道为什么会报错）
    printf("%lld=",f[n]);
    do1(f[n]);//分解质因数
    return 0;
}
```

---

## 作者：enceladus (赞：8)

现在的数据可以暴力

但是如果n<=1e10

那么暴力就.....

link：数据加强版：[皮王的遗愿](https://www.luogu.org/problemnew/show/T33750)

仔细想想O（n）的递推有点傻

1e10只有logn或O（1）的时间才可以

我们可以乱搞一下，

仔细想想logn的算法有哪些

额(⊙o⊙)…

是不是想到了快速幂

~~好吧其实什么有没想到~~

来介绍一个法阵（其实是斐波那契矩阵）

B=

| 1 | 1 |
| :----------: | :----------: |
| 1 |  0|

用fi表示斐波那契数列的第i项

则f1就是

| 1 |
| :-----------: |
| 0 |

根据矩阵乘法的原理

fi就等于

B^n * f1

这样就可以用快速幂搞事情了

```cpp
/*
P2626 斐波那契数列（升级版）
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define R register
#define II int
#define fo(i,a,b) for(R II i=(a);i<(b);++i)
#define FO(i,a,b) for(R II i=(a);i<=(b);++i)
#define fg(i,x) for(R II i=head[x];i;i=ed[i].nt)
#define mmt(a,b) memset(a,b,sizeof(a))
#define OP operator
#define CT const
#define IL inline
#define ls(x) (x<<1)
#define rs(x) (ls(x)|1)
#define isd(x) ('0'<=x&&x<='9')
#define inf 0x7ffffff
using namespace std;
typedef long long ll;
typedef unsigned long long lol;
typedef bool QWQ;
typedef char QAQ;
CT ll p=1LL<<31;//不开long long见祖宗
struct FB{
	ll a[2][2];
	FB(){mmt(a,0);}
	friend FB OP*(CT FB&a,CT FB&b){
		FB c;
		fo(i,0,2)fo(j,0,2)fo(k,0,2){
			c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%p;
		}
		return c;
	}
}f1,ans,b;
ll anss;
II n;
vector<ll> v;
bool first=1;
void prev(){//预处理
	b.a[0][0]=1;b.a[0][1]=1;
	b.a[1][0]=1;b.a[1][1]=0;
	fo(i,0,2)ans.a[i][i]=1;
	f1.a[0][0]=1;
}
void fenjie(ll x){//O(sqrt(2<<31))的分解
	ll sq=(ll)sqrt(x+0.5);
	for(ll i=2;i<=sq;++i){
		if(x%i==0)x/=i,v.push_back(i--);
	}
	if(x!=1)v.push_back(x);//最后分解不能等于一
}
//char buf[1000]="data  .in";
II main(){
	ios::sync_with_stdio(0);
	cin>>n;
	prev();
	n--;//边界处理，n要减一
	for(;n;n>>=1,b=b*b){
		if(n&1)ans=b*ans;//辣鸡快速幂
	}
	f1=ans*f1;
	anss=f1.a[0][0];
	cout<<anss<<'=';
	fenjie(anss);
	for(vector<ll>::iterator it=v.begin();it!=v.end();++it){
		if(first){
			first=0;
		}else cout<<'*';
		cout<<*it;
	}
	cout<<endl;
	return 0;
}

```

---

## 作者：sleepyNick (赞：7)

**P党的福利**

不要被tag迷惑了，这题就是质因数分解，不需要筛素数

这样一来过程就很简单：sigma[i]表示斐波那契数列，用递推求出

也可以用公式：f[n]=1/√5{[(1+√5)/2]^n-[(1-√5)/2]^n}

再是朴素的分解质因数，注意点是mod 2147483647，以及特判1,2

具体看代码：（谢绝抄袭）



```cpp
const opt=2147483648;    //mod 2^31
var n,k:int64;i:longint;
sigma:array[0..50] of int64;
begin
    readln(n);
    if n<=2
        then begin
                 writeln('1=1')
                 halt;
             end;
    sigma[1]:=1;       //sigma数组保存斐波那契数列
    sigma[2]:=1;
    for i:=3 to n do
        sigma[i]:=(sigma[i-1]+sigma[i-2]) mod opt;     //别忘了opt取余
    k:=sigma[n]
    i:=1;
    write(k,'=');        //先输出要分解质因数的数
    while true do
        begin
            inc(i);
            while k mod i=0 do    //如果整除
                begin
                    if k div i=1   //判断是否触底，并有一个格式问题
                        then begin
                                 writeln(i);
                                 halt;    
                             end;
                        else write(i,'*');
                    k:=k div i;
                end;
        end;
end.

```

---

## 作者：SovietPower✨ (赞：3)

思路和前面题解不太一样，分享一下我的做法

1. 对于解斐波那契，n略大(f[]每次模2147483648，因此不需要用long long)，我用的是记忆化搜索，省时

2. 关于质因数分解，从小到大枚举因数，用now不断除以因数，直到该因数不再是now的因数

f[i]:表示斐波那契数列第i项的值

vis[i]:表示第i项是否已经被计算(用于记忆化搜索)

```cpp
#include<cstdio>
#define modn 2147483648UL
//UL/ULL:避免[Warning] this decimal constant is unsigned only in ISO C90
using namespace std;
int n;
int f[50];
bool vis[50];
int fibonacci(int x)
{
    if(x==1) return 1;
    if(x==2) return 1;
    if(vis[x]) return f[x]%modn;//f[x]已经在先前计算过,直接使用f[x]的值,减少递归次数 
    vis[x]=1;//f[x]已计算出 
    return f[x]=(fibonacci(x-1)+fibonacci(x-2))%modn;
}
int main()
{
    scanf("%d",&n);
    fibonacci(n);//求出f[](Fibonacci)各项的值 
    int now=f[n];
    printf("%d=",now);
    for(int i=2;now!=1;i++)//枚举因数,不断分解now,直至now==1 
    {
        while(now%i==0)//直至i不是now的因数 
        {
            if(now==i)//避免输出最后一个乘号 
            {
                printf("%d",now);
                return 0;
            }
            printf("%d*",i);
            now/=i;//每分解一次,now对应除以该因数 
        }
    }
    return 0;
}
```

---

## 作者：big_news (赞：3)

~~考前神经病系列~~

发一个鬼畜的不开数组的做法。

~~你要问我为什么不开数组，我说我懒得开。~~

首先推斐波拉契数列的某一项不需要开数组，其次用试除法分解质因数也不需要开数组，~~那么为什么要开数组呢？~~

于是就可以简简单单的（？）用几行代码（？）过掉这个题。

贴代码：
```cpp
#include<cstdio>
#define ll long long
const ll R = 1ll << 31;  // (1ll << 31) 这个数字就是 2^31
ll fi,fp; // fi 存斐波拉契数列的当前项，fp 存斐波拉契数列当前项的上一项
int main(){
    int n; scanf("%d",&n);
    fi = fp = 1;  // 第一项和第二项已知，直接赋值就好了
    for(int i=3;i<=n;i++){ // 从第三项开始推斐波拉契数列
        ll t = fi; (fi += fp) %= R; fp = t;
        /* 
        fi 是上次推出来的“当前项”，那么对于现在来说，它就是上一项，也就是f[i-1]；同理，fp就是f[i-2]。因此，对于现在来说，fi = fi + fp，fp = 原来的fi
        因为 fi 的值算出之后就变了，因此我们设 t=fi 把它保存下来，那么 fp=t
        */
    }
    printf("%lld=",fi); // 输出第 n 项
    ll cnt = 0,tp = fi; // 试除法分解质因数，cnt 表示质因数的数量，tp 用来先统计一遍质因数
    for(ll x = 2;x * x <= tp; x++) // 枚举因数
        while(!(tp % x)) tp /= x,cnt++; // 能除就把x除掉，那么x一定是tp的质因子，cnt++
    if(tp > 1) cnt++; // 如果最后还有剩下的，那么一定剩下来一个还没被找到的质因子，cnt++
    for(ll x = 2;x * x <= fi; x++){ // 再分解一遍并输出答案
        while(!(fi % x)){ // 试除
            printf("%lld",x); // 输出质因子
            if(--cnt) putchar('*'); // 如果不是最后一个质因子，就输出乘号
            fi /= x;
        }
    }
    if(fi > 1) printf("%lld",fi); // 如果还有质因子，把它输出
    return 0;
}
```

压行之后代码更美哦~
```cpp
#include<cstdio>
#define ll long long
const ll R = 1ll << 31; ll fi,fp;
int main(){
    int n; scanf("%d",&n); fi = fp = 1;
    for(int i=3;i<=n;i++) {ll t = fi; (fi += fp) %= R; fp = t;}
    printf("%lld=",fi); ll cnt = 0,tp = fi;
    for(ll x = 2;x * x <= tp; x++) while(!(tp % x)) tp /= x,cnt++;
    if(tp > 1) cnt++;
    for(ll x = 2;x * x <= fi; x++) while(!(fi % x)) {printf("%lld",x); if(--cnt) putchar('*'); fi /= x;}
    if(fi > 1) printf("%lld",fi);
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)了解一下

$1,1,2,3,5,8,13,21,34,55,89,143...$

应该都知道斐波那契数列的特性吧：

$f(1)=1$

$f(2)=1$

$f(i)=f(i-1)+f(i-2)(i≥3$且$i$为整数$)$

考两个点：

1.斐波那契数列

2.分解质因数

这题不打表是肯定TLE的。

先来写个递归：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t=pow(2,31);
long long f(int x) {
	if(x==1) return 1;
	if(x==2) return 1;
	else return f(x-1)+f(x-2);
}
int main() {
	printf("1,1");
	for(int i=3; i<=48; ++i) {
		printf(",%d",f(i)%t);
	}
	return 0;
}
```


于是，表就出来啦~

```cpp
long long a[49]={1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,159,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,354578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,70408733,1134903170,1836311903,823731425,512559680}
```


递归有点慢哦，请耐心等待~

有了表，应该就不会TLE了。

然后就是分解质因数啦（应该没什么问题吧）。

最后上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,a[49]= {0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,823731425,512559680};
int n;
inline int read() {
	int x(0),f(1);
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
bool pd(int y) {
	for(int i=2; i*i<=y; ++i)
		if(y%i==0) return 0;
	return 1;
}//判断y是否为质数
int main() {
	bool x=false;
	n=read();
	t=a[n];
	printf("%lld=",t);//输出斐波那契数列第n项
	for(int i=2; i<=t; ++i) {
		while(t%i==0&&pd(i)) {//如果是t的质因数
			t/=i;//除
			if(!x) printf("%d",i);//如果是第一个数不用输出*
			else printf("*%d",i);
			x=true;
		}
	}
	return 0;
}
```

一定要开$long$ $long$！
=

---

## 作者：WH1KI9RAVE (赞：3)

### 这应该，是一篇很稀有的golang题解（滑稽）

~~这题很水，~~斐波那契额然后分解质因数



*** 代码 *** 

```
package main
import (
	"fmt"
	"time"
)

var n int

func main() {
	var a,b int = 1,1
	var tmp int
	fmt.Scanf("%d",&n)
	//fmt.Printf("%d %d ",a,b)
	for i := 3;i <= n;i++ {
		tmp = a+b
		a = b
		b = tmp
		//fmt.Printf("%d ",b)
	}
	b = b%2147483648
	fmt.Printf("%d=", b)	
	for i := 2; i <= b; i++ {
		for b != i {
			if b%i == 0 {
				fmt.Printf("%d*", i)
				b = b / i
			} else {	
				break
			}
		}
	}
	fmt.Printf("%d", b)
	time.Sleep(time.Duration(5000)*time.Second)
}
```

###### time库和最后的time.sleep要删掉，不然稳定tle

---

## 作者：right_cat (赞：3)

本题解采用一种简单易懂的思路：

我们先用递推求出a[n]（即斐波那契数列的第n项），再将a[n]%2147483648，然后我们编写一个函数，作用是记录质因数分解的过程，最后调用这个函数即可。

代码实现：

```cpp
#include<iostream>
using namespace std;
long long a[50]={0,1,1};  //注意int会爆
bool f; //初始值为0
void zs(long long n) //分解质因数的函数
{
    for(long long i=2;i<=n;i++)
    {
        if(n%i==0) //如果找到了n的最小质因数
        {
            if(n/i==1) //也可写成(n==i),即n已为质数
            {
                if(!f) //f为0时满足条件
                {
                    f=1; //将f置为1(避免重复判断)
                    cout<<i<<endl; //直接输出最后一个因数
                }
            }
            else //如果n还可以继续拆
            {
                if(!f)  //f为0时满足条件
                    cout<<i<<"*"; //输出因数及乘号
                else
                    return; //否则直接结束
            }
            zs(n/i); //进行递归
        }
    }
}
int main()
{
    int n;
    cin>>n;
    for(int i=3;i<=n;i++)
        a[i]=a[i-1]+a[i-2]; //求斐波那契数列的第n项
    a[n]%=2147483648; //将a[n]%2^31
    cout<<a[n]<<"="; //这步必不可少
    zs(a[n]); //调用函数
    return 0; //结束程序
}


```

---

## 作者：封禁用户 (赞：3)

这个题虽说斐波那契的第48个不会爆int，但不得不说就算是第1000个也是不用边递推边取模的，只要在递推的时候一直让int溢出，递推完了之后再将它&0x7fffffff把最高位和谐掉后就行了（这样就相当于%2^31了）。分解质因数的时候我用了个二分，把他的质因数找出来后再用sort从小到大排一遍即可。代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
unsigned char sushu[1000000];
int fenjie[100];
int main(){
    int n;
    cin>>n;
    unsigned int a=1;
    if(n<3){
        cout<<"1=1"<<endl;
        return(0);
    }
   unsigned int b=1;
   unsigned int c=0;
    for(int i=3;i<=n;i++){      //递推求斐波那契
        c=a+b;
        a=b;
        b=c;
    }
    c=c&0x7fffffff;                 //和谐掉最高位，只剩下最后31位
    int ic=sqrt(c);                  //其实用筛法求出2~根号c的素数即可，详见下面的代码
    int sqr=sqrt(ic)+1;
    for(int i=2;i<=sqr;i++){   //筛法求素数
        int loop=ic/i;
        for(int j=2;j<=loop;j++){
            sushu[i*j]=1;
        }
    }
    int left=2,right=ic;       //虽然c的质因数不一定都在2~根号c之间，但是我们可以利用根号c~c之间的合数都能被2~根号c之间的素数整除
    int ptr=0;                    //这个性质来枚举2~根号c之间的所有素数，能把c整除的让c一个一个除，最后留下来如果不为1的就也算质因数
    int tmpc=c;
    while(left<=right){        //二分求质因数
        while(1){
            if(!sushu[left]){
                if(tmpc%left==0){
                    fenjie[ptr]=left;
                    ptr++;
                    tmpc=tmpc/left;
                }
                else{
                    break;
                }
            }
            else{
                break;
            }
        }
        if(tmpc==1)break;
        while(1){
            if(!sushu[right]){
                if(tmpc%right==0){
                    fenjie[ptr]=right;
                    ptr++;
                    tmpc=tmpc/right;
                }
                else{
                    break;
                }
            }
            else{
                break;
            }
        }
        if(tmpc==1)break;
        left++;
        right--;
    }
    if(tmpc!=1){
        fenjie[ptr]=tmpc;          //若最后除完不为1，则他肯定是根号c~c之间的素数，算一个质因数
        ptr++;                         
    }
    sort(fenjie,fenjie+ptr);       //因为质因数要从小到大输出，所以要排序一遍
    printf("%d=%d",c,fenjie[0]);
    for(int i=1;i<ptr;i++){
        printf("*%d",fenjie[i]);
    }
    return(0);
}
```

---

## 作者：死神审判 (赞：2)

### 思路：这题虽然用递归会超时，但我们可以用递归来打表。
### 解法：
根据给出的递归式，可以得到递归函数。
```cpp
long long f(int n){
	if(n==1||n==2)return 1;
	return f(n-1)+f(n-2);
}

```
有了递归函数，程序也不难写出，会很慢，可以加上O3优化等。
```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(3)//O3优化吼啊
using namespace std;
const long long p=pow(2,31);
long long f(int n){//递归大法吼啊
	if(n==1||n==2)return 1;
	return f(n-1)+f(n-2);
}
int main(){
	for(int i=1;i<=48;i++){
		printf("%lld,",f(i)%p);//printf吼啊
	}
	return 0;
}

```
于是得到一张表（已经%2^31了）。
```cpp
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,823731425,512559680
```
还要把每个数分解质因数，分解质因数的第一个数是不需要乘号的，所以需要进行特判。
```cpp
for(int i=2;i<=a[n];i++){
		while(a[n]%i==0){//有就使劲除
            if(!pd)cout<<i;
            else cout<<'*'<<i;
            a[n]/=i,pd=true;
        }
	}
```
有了这些就可以写出代码了。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool pd;
int n;
long long a[49]={0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,823731425,512559680};//打表
int main(){
	cin>>n;
	cout<<a[n]<<'=';
	for(int i=2;i<=a[n];i++){
		while(a[n]%i==0){
            if(!pd)cout<<i;
            else cout<<'*'<<i;
            a[n]/=i,pd=true;
        }
	}//分解质因数
    cout<<'\n';
	return 0;
}

```





---

## 作者：TomTheCat (赞：2)

其实这道题目考的就是斐波那契数列和分解质因数。

求斐波那契数列，有一种方法是递归：
```cpp
int fib(int n) {
    if(n==1||n==2) return 1;
    return fib(n-2)+fib(n-1);
}
```
但是这个方法速度较慢。为什么呢？

假设我们需要计算$fib(7)$。

计算$fib(7)$需要计算$fib(5)$和$fib(6)$。

计算$fib(5)$需要计算$fib(3)$和$fib(4)$。

计算$fib(3)$需要计算$fib(1)$和$fib(2)$。

$fib(1)$和$fib(2)$均已知，所以$fib(3)$也就计算出来了。

现在回归到$fib(4)$。

计算$fib(4)$需要计算$fib(2)$和$fib(3)$。

计算$fib(3)$需要计算$fib(1)$和$fib(2)$。

$fib(1)$和$fib(2)$均已知，所以$fib(3)$也就计算出来了。

现在回归到$fib(6)$。

计算$fib(6)$需要计算$fib(4)$和$fib(5)$。

计算$fib(4)$需要计算$fib(2)$和$fib(3)$。

计算$fib(3)$需要计算$fib(1)$和$fib(2)$。

$fib(1)$和$fib(2)$均已知，所以$fib(3)$也就计算出来了。

现在回归到$fib(5)$。

计算$fib(5)$需要计算$fib(3)$和$fib(4)$。

计算$fib(3)$需要计算$fib(1)$和$fib(2)$。

$fib(1)$和$fib(2)$均已知，所以$fib(3)$也就计算出来了。

现在回归到$fib(4)$。

计算$fib(4)$需要计算$fib(2)$和$fib(3)$。

计算$fib(3)$需要计算$fib(1)$和$fib(2)$。

$fib(1)$和$fib(2)$均已知，所以$fib(3)$也就计算出来了。

终于计算出了$fib(7)$！

可以看到算法中有大量的重复。

所以我们用递推来做，无需重复计算。

```cpp
int f[48]={0,1,1};
for(int i=3;i<=n;i++) f[i]=f[i-2]+f[i-1];
```
现在$fib(n)$就是$f[n]$啦

分解质因数嘛，我相信大多数人都是用的递归。

这次不像上面一个问题分解成了两个子问题，这次一个问题只留下了一个子问题。

```cpp
bool p(int n) {
    if(n<2) return false;
    for(int i=2;i*i<n+1;i++) if(n%i==0) return false;
    return true;
} 

void pd(int n) { //pd是prime divisor，质因数的意思
    if(p(n)) {
        printf("%d",n);
        exit(0); //我也不晓得为什么，试出来的
    }
    else {
        for(int i=2;i*i<n+1;i++)
            if(n%i==0) {
                printf("%d*",i);pd(n/i);
            }	
    }  
}
```
把代码串联起来就得到了AC代码。
```cpp
#include<bits/stdc++.h>
bool p(int n) {
    if(n<2) return false;
    for(int i=2;i*i<n+1;i++) if(n%i==0) return false;
    return true;
} 
void pd(int n) {
    if(p(n)) {
        printf("%d",n);
        exit(0);
    }
    else {
        for(int i=2;i*i<n+1;i++)
            if(n%i==0) {
                printf("%d*",i);
                pd(n/i);
            }	
    }  
}
int main() {
    int f[48]={0,1,1},n;
    scanf("%d",&n);
    if(n<3) { //特判1的情况
        printf("1=1");
        return 0;
    }
    for(int i=3;i<=n;i++) f[i]=f[i-2]+f[i-1];
    printf("%d=",f[n]);
    pd(f[n]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

感觉前面dalao们的题解我们这些小渣有点难以理解

嗯补充一段理解难度不高的

```cpp
#include<iostream>
using namespace std;
int i,j,n;
long long a[49];
int main()
{
    cin>>n;
    a[1]=a[2]=1;
    for (i=3;i<=n;i++)
        a[i]=a[i-1]+a[i-2]%2147483648;//兔子的递推方程 
    a[n]%=2147483648;//2的31次方 
    cout<<a[n]<<'=';
    for (i=2;i<=a[n];i++)//循环到a[n]是因为分解到最后一项时a[n]必然是质数 
    if (a[n]%i==0)//一个大于1的自然数除了1之外最小的因数肯定是质数 
    {
        cout<<i;//直接输出这个因数 
        a[n]=a[n]/i;//把这个因数拆走 
        break;
```
}//这段是为了防止前面冒出来一个多的乘号
```cpp
    while (a[n]!=1)//除到1就说明不能再分解了 
    {
        for (i=2;i<=a[n];i++)
        if (a[n]%i==0)
        {
            cout<<'*'<<i;
            a[n]=a[n]/i;
            break;
```
}//同上
    }
}
数据好像没说n>2来着

[细思极恐]


---

## 作者：Tri17 (赞：2)

题目很简单，就是求出斐波那契数列的第n个，因为有mod，所以不用高精度，只要开int64就可以了。之后再分解质因数，i循环一


点一点加（可能会在超大的质数中超时，不过也没有超时间）。

讨论中说了当n=1或n=2时是1，尽管数据貌似没有1，但只要向质数一样处理，输出1=1就可以了（本题解中用了打表，很赖皮，但也


是在比赛时针对特殊情况的好助手）。

PS：在斐波那契数列中动用了a数组，开int64，其实用三个数xyz就可以了，稍微占一点内存。为了简单易懂，就不用xyz了。（比


赛抠一点，平时多一点）

附上AC的代码：

```cpp
var
 a:array[1..48] of int64;     
 n,i:longint;           //定义很简单粗暴
begin
  readln(n);
  if n<3 then
  begin
    writeln('1=1');      //专门判断当a[n]=1时的特殊情况
    exit;
  end;
  a[1]:=1;      //定义a[1]
  a[2]:=1;      //定义a[2]
  for i:=3 to n do a[i]:=(a[i-1]+a[i-2]) mod 2147483648;      //求斐波那契数列的第n项，公式见题首     
  write(a[n],'=');     //先输出a[n]
  i:=1;                    //i从2开始判断，后面会在判断之前再加一个1
  while true do      //死循环，事后会直接退出的
  begin
    inc(i);                 //不断累加从而从小到大分解质因数
    while a[n] mod i=0 do         //如果a[n]含i这个质因数就一直循环
    begin
      a[n]:=a[n] div i;               //除法
      write(i);                          //输出质因数
      if a[n]=1 then              //如果a[n]已经分解完了
      begin
        writeln;                  //换行
        exit;                     //直接结束程序
      end;
      write('*');                 //别忘了中间有乘号间隔
    end;
  end;
end.
```

---

## 作者：The_Dark_Knight (赞：2)

一道水题，素数筛选法求素数，只需要求2000000内的素数就足够了，至于求第n位的斐波那契数就直接模拟，分解质因数的时候就根据之前求的质数来枚举就好

var f,ff:array[1..2000000] of int64;//f为斐波那契数，ff判断是否为质数

```cpp
    q:array[1..1000000] of longint;//存放质数
    i,j,k,m,n,p,t:longint;mo:int64;
begin
    mo:=1;
    for i:=1 to 31 do
      mo:=mo*2;
    readln(n);
    f[1]:=1;f[2]:=1;
    for i:=3 to n do
        f[i]:=(f[i-1] mod mo+f[i-2] mod mo)mod mo;
    write(f[n],'=');
    for i:=2 to 2000000 do
    begin
        if ff[i]=1 then continue;
        inc(t);q[t]:=i;
        j:=i+i;
        while j<=2000000 do
        begin
            ff[j]:=1;
            j:=j+i;
        end;
    end;
    for i:=1 to t do
    begin
        if f[n] mod q[i]<>0 then continue;
        p:=0;
        while f[n] mod q[i]=0 do
        begin
            inc(p);
            f[n]:=f[n] div q[i];
        end;
        for j:=1 to p do
        begin
            inc(m);
            if m=1 then write(q[i]) else write('*',q[i]);
        end;
    end;
end.

```

---

## 作者：hsfzLZH1 (赞：2)

这题首先是计算斐波那契数列第i项的值，然后将其分解质因数。对于这两个问题，我们分别来进行分析：

## 计算斐波那契数列的第N项

有很多种方法。可以通过递推式f[i]=f[i-1]+f[i-2]来计算并输出f[n]的值，或者根据通项公式计算：楼下是很好的例子

因为f[48]在int的范围内，所以不用担心溢出，也不用取模

###  请注意：如果使用矩阵快速幂（或者说矩阵加速）的方法进行计算的话，由于常数比较大，对于这道题来说是得不偿失！

更多有关计算斐波那契第N项的值请自行查阅 [模板题题解](https://www.luogu.org/wiki/show?name=%E9%A2%98%E8%A7%A3+P1962)，这里有不错的代码。


## 将求解出来的斐波那契值进行质因数分解

在这里我用的是一种特殊的方法，请见代码：

```cpp
void dfs(int now,int minn)//now表示除去已经分解了的数字后剩下的数字，minn表示当前now的最小因数至少为minn
{
    if(now<minn)return;//如果now小于minn，那么说明分解已经结束
    for(int i=minn;i<=now;i++)if(!(now%i))//从minn到now枚举，找到一个最小的now的因数，保证在这里一定找得到一个因数，因为now|now（|表示整除）
    {
        if(tf)printf("*");//如果之前已经分解出了其他质因数，那么不能忘记*号
        else tf=true;//反之，打标记表示已经分解过了，以后都要输出*号
        printf("%d",i);//输出找到的这个因数
        dfs(now/i,i);//继续dfs，注意此时的minn是i，因为now肯定不存在小于i的因数
        return;
    }
}
```
这种方法可以保证分解出的结果都是质数，证明是显然的。

证明：（不是太严谨）

1.每次都可以找到now的最小的因数，根据质数的定义这个因数肯定是质数。

2.将now/i后也一定不存在任何比i小的因数

3.在dfs(now/i,i)这一过程中，同样可以重复(1)的证明过程

4.当没有其他因数时，分解因数过程结束，也就是说最后结束(now<minn)时now的值一定为1


## 代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=50;
int n,f[maxn]={0,1,1};//边界条件，f[1]=f[2]=1
bool tf;//标记是否一定分解过因数，初始为false
void dfs(int now,int minn)//dfs过程，参见以上代码
{
    if(now<minn)return;
    for(int i=minn;i<=now;i++)if(!(now%i))
    {
        if(tf)printf("*");
        else tf=true;
        printf("%d",i);
        dfs(now/i,i);
        return;
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=3;i<=n;i++)f[i]=f[i-1]+f[i-2];//推算斐波那契数列的值
    printf("%d=",f[n]);//注意格式
    dfs(f[n],2);//为什么minn从2开始呢？因为1不是质数，不符合题目要求，而且从1开始会出现和谐的输出。。。
    return 0;
}
```

---

## 作者：Mickey_snow (赞：2)

基本解题思路：

使用两个int变量a和b进行模拟，a,b初始值均为1，每循环一次执行一次a += b; b += a; 。这样，数列中1,1,2,3,5,8...分别对应变量a,b,a,b,a,b...不难发现若n为偶数则对应b，否则为a。而循环的次数为((n + 1) / 2 - 1) 。

我们很容易就可以写出如下代码：


    

```cpp
    int a = 1, b = 1, n;
        bool isA;
        cin >> n;                                //数列中第n个数
        isA = n % 2 == 0 ? false : true;        //判断这个数对应的是变量a还是b
        n = (n + 1) / 2 - 1;                    //总共的循环次数
        for (int i = 0; i < n; i++)
            a += b; b += a;
```
接着，我们需要将求出的数mod 2^31。
由于int最大可存储数值就是2^31，所以若变量达到了2147483648，就会变为-2147483648，这个数正好是2^31，所以只需要在变量a,b小于0（溢出）时加上2^31即可。

修改一下代码之后可以得到


```cpp
    for (int i = 0; i < n; i++)
        {
            a += b; b += a;
            if (b < 0)b += 2147483648;
            if (a < 0)a += 2147483648;
        }
```
这时，尝试输出一下得到的数，符合题意。
随后就是很简单的分解质因数过程，在这里我使用了一个dev函数完成


    
```cpp
    bool isPrime(int inp)        //判断质数
    {
        int a = sqrt(inp);        //储存inp开方后的结果，提高效率
        for (int i = 2; i <= a; i++)
            if (inp%i == 0)
                return false;
        return true;
    }
    void dev(int num)        //输出
    {
        cout << num << "=";
        while (!isPrime(num))
        {
            while (num % 2 == 0 && num != 2) { num /= 2; cout << 2 << "*"; }
            for (int i = 3; i < num; i+=2)
                if (num%i == 0 && isPrime(i)) { cout << i << "*"; num /= i; break; }
        }
        cout << num << endl;
    }
```
完整的代码如下：
   

    
    
    
    
    
    
```cpp
    #include<iostream>
    #include<cmath>
    using namespace std;
    bool isPrime(int inp)        //判断质数
    {
        int a = sqrt(inp);        //储存inp开方后的结果，提高效率
        for (int i = 2; i <= a; i++)
            if (inp%i == 0)
                return false;
        return true;
    }
    void dev(int num)        //输出
    {
        cout << num << "=";
        while (!isPrime(num))
        {
            while (num % 2 == 0 && num != 2) { num /= 2; cout << 2 << "*"; }
            for (int i = 3; i < num; i+=2)
                if (num%i == 0 && isPrime(i)) { cout << i << "*"; num /= i; break; }
        }
        cout << num << endl;
    }
    int main()
    {
        int a = 1, b = 1, n;
        bool isA;
        cin >> n;            //数列中第n个数
        isA = n % 2 == 0 ? false : true;        //判断这个数对应的是变量a还是b
        n = (n + 1) / 2 - 1;                    //总共的循环次数
        for (int i = 0; i < n; i++)
        {
            a += b; b += a;
            if (b < 0)b += 2147483648;
            if (a < 0)a += 2147483648;
        }
        dev(isA ? a : b);
        return 0;
}
```

---

## 作者：液氮一瓶 (赞：1)

~~众所周知，打表是[蒟蒻](http://iwo.im/?q=%E8%92%9F%E8%92%BB)做题AC的一大依仗~~

# 于是乎，简单愉快的打表做题

```cpp
#include<bits/stdc++.h> 
using namespace std;
//注意！！！一定要用数组（用其他也无所谓但不太好而且不能复制粘贴用就是了）
//数据范围不浪费\(￣▽￣)ﾉ48就是48
string s[48]={"2=2","3=3","5=5","8=2*2*2","13=13","21=3*7","34=2*17","55=5*11","89=89","144=2*2*2*2*3*3","233=233",
              "377=13*29","610=2*5*61","987=3*7*47","1597=1597","2584=2*2*2*17*19","4181=37*113","6765=3*5*11*41",
			  "10946=2*13*421","17711=89*199","28657=28657","46368=2*2*2*2*2*3*3*7*23","75025=5*5*3001","121393=233*521",
			  "196418=2*17*53*109","317811=3*13*29*281","514229=514229","832040=2*2*2*5*11*31*61","1346269=557*2417",
			  "2178309=3*7*47*2207","3524578=2*89*19801","5702887=1597*3571","9227465=5*13*141961",
			  "14930352=2*2*2*2*3*3*3*17*19*107","24157817=73*149*2221","39088169=37*113*9349","63245986=2*233*135721",
			  "102334155=3*5*7*11*41*2161","165580141=2789*59369","267914296=2*2*2*13*29*211*421","433494437=433494437",
			  "701408733=3*43*89*199*307","1134903170=2*5*17*61*109441","1836311903=139*461*28657",
			  "823731425=5*5*11*83*151*239","512559680=2*2*2*2*2*2*5*1601749" 
			 };//关于string数组的讲解看下面

int main()
{
	int n;//定义一个变量存输入的数
	cin>>n;//输入
	cout<<s[n-3]<<endl;
	/*
   	这里要特别说一下n-3：
   	首先，我们知道该题中n>=2，而我们的数表是从第3个数（0,1,2）开始的，同时该数在s中的编号是0。
   	那么我们就知道：第n个数在数表中的位置是n-3
   */
	return 0;
}
```
PS：感谢[xcdxu](https://www.luogu.org/space/show?uid=112124)提供数表

PPS：记得有个东西叫WORD，WORD里有个玩意叫**查找替换**

PPPS: 附上数表
```
"2=2","3=3","5=5","8=2*2*2","13=13","21=3*7","34=2*17","55=5*11","89=89","144=2*2*2*2*3*3","233=233","377=13*29","610=2*5*61","987=3*7*47","1597=1597","2584=2*2*2*17*19","4181=37*113","6765=3*5*11*41","10946=2*13*421","17711=89*199","28657=28657","46368=2*2*2*2*2*3*3*7*23","75025=5*5*3001","121393=233*521","196418=2*17*53*109","317811=3*13*29*281","514229=514229","832040=2*2*2*5*11*31*61","1346269=557*2417","2178309=3*7*47*2207","3524578=2*89*19801","5702887=1597*3571","9227465=5*13*141961","14930352=2*2*2*2*3*3*3*17*19*107","24157817=73*149*2221","39088169=37*113*9349","63245986=2*233*135721","102334155=3*5*7*11*41*2161","165580141=2789*59369","267914296=2*2*2*13*29*211*421","433494437=433494437","701408733=3*43*89*199*307","1134903170=2*5*17*61*109441","1836311903=139*461*28657","823731425=5*5*11*83*151*239","512559680=2*2*2*2*2*2*5*1601749" 
```
PPPPS：string数组讲解
[![](https://s2.ax1x.com/2019/08/11/ejYdSA.png)](https://blog.csdn.net/Xiao_Yanci/article/details/79111186 )

---

## 作者：天狼星✵ (赞：1)

此题是斐波那契数列和分解的结合
先算出第n个（要Int64！！！）
然后试除 如果可以处尽则将f（n）div 那个数

为什么没有pascal的呢╮(╯▽╰)╭
上pascal的



```pascal
var
 n,i,s,xb:longint;
 f,b:array[0..10000] of int64;//刚好比longint大╭(╯^╰)╮
begin
 read(n);
 f[1]:=1;
 f[2]:=1;
 for i:=3 to n do f[i]:=(f[i-1]+f[i-2]) mod 2147483648;
 write(f[n],'=');//求出要处理的数
 s:=2;//质数从2开始
 while f[n]<>1 do//如果没有到1就一直除下去
 begin
  if f[n] mod s=0 then
  begin
   xb:=xb+1;
   b[xb]:=s;
   f[n]:=f[n] div s;//优化 除到一个就将时间复杂度压缩
  end else s:=s+1;//因数加1
 end;
 for i:=1 to xb-1 do write(b[i],'*');//输出 除最后一个外都加*号
 writeln(b[xb]);
end.//愉快结束



```

---

## 作者：追风少年σχ (赞：1)

这道题主要思路很简单，就是做出斐波那契数列第n项的值然后分解质因数输出。附上代码








                
    

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
const long long mod= 2147483648;// 2147483648即2的31次幂.这里定义为一个常量
int f[50];//数列
int n,t,i;//n,i不解释，t就是数列第n项的值
bool flag=false;//flag作用是控制输出的，第一个输出只要输出数值，之后的都要在数值前面加上一个星号*
int main()
{
        scanf("%d",&n);//读入
        f[1]=1;
        f[2]=1;
        for (i=3;i<=n;i++)
                f[i]=f[i-1]+f[i-2]%mod;
    //上面几行都是求斐波那契数列的，不解释
        t=f[n];
        printf("%d=",t);//输出的前一部分
//以下部分就是输出质因数了.从第一个质数2开始，将i记为2，然后反复判断整除。如果t不能被i整除，说明当前这个i已经不能再作为一个质因
//数了，i增加1。(其实本来应该把t赋值为下一个素数，但是这题数据不大我就偷个懒了，我这样做是不对的(严格意义上))如果可以整除，t直
//接除以i。当i一直增加到t本身的时候，t%i必定为0，t/i=1，这时候就可以结束循环了。所以while语句的条件是t>1。
        i=2;
        while(t>1)
        {
                if (t%i==0)
                {
                        if (!flag)
                            {
                                    flag=true;
                                    printf("%d",i);
                            }
                        else
                                printf("*%d",i);
                        t/=i;
                }
                else
                        i++;
        }
            return 0;
}
//结束。

```

---

## 作者：feecle6418 (赞：1)

介绍一种时间复杂度为O(sqrt(n))的分解质因数方法。

我们普通的分解方法，总是要枚举直到n不能分解为止，时间复杂度O(n)。如果有很刁钻的数据就T掉了，这题数据是真的水！

其实，可以边分解边判断素数，时间大大缩小：

```cpp
void prime(long long int n) {
    long long int i;
    for(i=2; i<=sqrt(n); i++) {//判断素数时刚好顺便分解
        if(n%i==0) {//最小因数一定是一个质数
            cout<<i<<'*';
            prime(n/i);//继续分解下去
            return ;
        }
    }
    cout<<n;//如果是质数则输出，完毕
}
```
这样，我们就能保证不超时，编程复杂度也不会多很多。

完整的代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
const long long mod=pow(2,31);//方便取余
void prime(long long int n) {
    long long int i;
    for(i=2; i<=sqrt(n); i++) {
        if(n%i==0) {
            cout<<i<<'*';
            prime(n/i);
            return ;
        }
    }
    cout<<n;
}
int main(){
    long long a=1,b=1,c,n,i;
    cin>>n;
    if(n==1||n==2){
        cout<<"1=1";//特判
        return 0;
    }
    for(i=3;i<=n;i++){
        c=a+b;
        c%=mod;
        a=b;
            b=c;
    }
    cout<<c<<'=';
    prime(c);
    return 0;
}
```

---

## 作者：The_Key (赞：1)

本来以为这样写会T掉或者爆掉，结果竟然A了


思路就是很普通的递推求出第n项数然后将这个数分解输出


```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,num[50];
void Pri(int k)//质因数分解函数
{
    cout<<k<<"=";
    if(k==2)
    cout<<"2*1"<<endl;
    else
    {
        for(int i=2;i<sqrt(k);i++)
    {
        while(k!=i)//这里用while循环是考虑到质因子中有可能有重复个i的情况
       {
        if(k%i==0)
       {
        cout<<i<<"*";
        k=k/i;
       }
    else
    break;
    }
}
    cout<<k<<endl;
}
}
int main()
{
    cin>>n;
    num[1]=1;//第一项为1
    num[2]=1;//第二项也为1
    for(int i=3;i<=n;i++)
    num[i]=num[i-1]+num[i-2];//递推求第n项
    Pri(num[n]);//将第n项分解并输出
    return 0;
}//鄙人代码不精，大神勿喷
```

---

## 作者：LevenKoko (赞：1)

貌似这题我分解质因数的方法奇特了一点，最终用时0ms；




    



```cpp
#include<iostream> 
#include<cmath>
using namespace std;
bool pd(int x)//判断质数，应该都会。。。
{
    if(x<2) return 0;
    if(x==2) return 1;
    for(int i=2;i<=sqrt(x);i++)
    if(x%i==0)
    return 0;
    return 1;
}
int main()
{
    int k,n,i=2,a[55];
    cin>>k;
    a[1]=1;
    a[2]=1;
    for(int i=3;i<=k;i++)
    a[i]=a[i-1]+a[i-2];//找第k个斐波那契数
    n=a[k];
    cout<<n<<"=";
    do//分解质因数
    {
        if(n%i==0 && pd(i)) //如果i是n的因数且是一个质数，那么就输出； 
        {
        cout<<i<<"*";
        n=n/i; //输完之后就除掉； 
    }
        if(n%i!=0) i++; //注意！！因为有可能出现重复，比如（2*2*3*3……） 所以这里要判断i要不要加； 
    }
    while(!pd(n));//一直到n本身是一个质数为止； 
    cout<<n;//因为这样写最后一个质数在循环体内输不出来
    return 0;//LZ以前经常忘记写。。。
}
（第一次没通过审核，真尴尬，不过既然是说明不详细，而不是重复，那就说详细一点）
```

---

## 作者：Sooke (赞：1)

题目主要分为两步：

- 1.找到第 n 个斐波那契数

- 2.给那个斐波那契数分解质因数

那么我们分别对这两步进行处理就行了


运用技巧，可以 0ms AC本题（貌似大家普遍是20ms左右的），具体代码如下：

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    int n,a[60],t,k;
    bool f;
    cin >> n;
    //找到第n个斐波那契数，大家应该都懂吧
    a[1]=1; a[2]=1;
    for(int i=3;i <= n;i++)
    a[i]=(a[i-1]+a[i-2])%2147483648; //边加边取模（不过第48个斐波那契数好像不需要取模诶）
    k=a[n];
    t=floor(sqrt(k));
    cout << k << '=';
    //分解质因数，分到k的平方根就够了，因为如果没分完（k!=1）表明分完后的k一定是一个质数，同样输出即可
    for(int i=2;i <= t;i++)
    while(k % i == 0)
    {
        if(f) cout << '*';
        //这一步很关键，用f储存是否输出过星号，防止星号前置在等号后面
        f=true;
        k/=i; //边分边除
        cout << i; //输出这个质因数
    }
    if(k != 1 && f) cout << '*';
    if(k != 1) cout << k;
    //这个步骤已经讲明过了 - w -
    return 0;
}
```

---

## 作者：guobaipeng0 (赞：1)

感觉前面的同学们写得好长，我来写一个整齐规范的题解。

题意分析：这题属于直接模拟，只需要求出第N个斐波那契数，再进行分解。


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,c,t,a[1005];
int main()
{
    cin>>n;  //读入要求的是第N个斐波那契数
    a[1]=1;  //斐波那契数的第一个是1，用a数组第一格存放1
    a[2]=1;  //斐波那契数的第二个是也是1，用a数组第二格存放1
    for (i=3; i<=n; i++) a[i]=(a[i-2]+a[i-1])%2147483648;  //从第三格开始，用递推式：第i个数=第i-2个数+第i-1个数，要注意边累加边求余2147483648，也就是2^31
    c=2; //分解质因数，第一个质数是2
    n=a[n]; //节省变量，将最终第N个斐波那契数赋值
    cout<<n<<"=";  //先输出前面的n和=
    while (n!=1)  //质因数分解到n为1停止
    {
        if (n%c!=0) c++;  //寻找分解的质数，这个找出来的c一定是质数，因为合数都是某个质数的倍数，所以不会找到合数
        else
        {
            t++;  //用来计算第几个质数的出现，第1个质数出现的时候不需要输出乘号
            if (t==1) cout<<c; else cout<<"*"<<c;  //判断是第几个质数
            n/=c; //记得要求出分解后的结果
        }
    }
}
```

---

## 作者：Sinwind (赞：1)

# 1.分析

0. 注意：题目中，$f(n)$要$\mod2^{31}$，说明$f(n)$可能会超过$int$型的范围$(f(n)>2^{31}-1)$；

- 所以$a,b,c$用$long\space long$型；

- 而$r=c\mod 2^{31}$，在$int$型范围之内，故可以用$int$型。

1. 因为不需要存储$f(n)$之前的斐波那契数列，所以用迭代计算出$f(n)$的值：

- $a,b$初始化：$a=1;b=1;$，这里注意$n-=2$表示已经计算过$2$项；
    
- 迭代公式：$while(n--)$继续执行剩下的$n$项，$c=a+b;a=b;b=c;$，循环结束后，$c$为要求的$f(n)$。
    
2. $r= c \mod 2^{31}$，因为出现了$2^{31}$，这里用位运算做了优化：
	
- $c\div 2^{31} = k\cdots r(c,k,r\in N)\rightarrow c=k\times2^{31} +r\rightarrow r=c-k\times2^{31}$；

- 转化为位元算：$r=c-(c>>31)<<31;$。

3. 分解质因数：

- 因为质数除$2$是偶数外都是奇数，$2$单独讨论，先将$r$用$2$完全分解，$while(r \% 2 == 0)$；

- 因为剩下的质数都是奇数，$int\space i=3;i<=r;i+=2$；

- 在分解过程中，若$r==1$则分解完毕，退出程序；否则，输出$"*"$。

# 2.代码

```cpp
#include <iostream>

using namespace std;

int n;              //斐波那契数列的第几项
long long a, b, c;  //斐波那契数列的相邻的三项
int r;              //第n个斐波那契数列的数 mod 2^31后的值

int main(void)
{
	cin >> n;
	
	//递推求出斐波那契数列第n项的值
	a = 1;
	b = 1;
	n -= 2;
	while(n--)
	{
		c = a + b;
		a = b;
		b = c;
	}
	//r=c mod 2^31
	r = c - ((c >> 31) << 31);
  	//分解质因数
	cout << r << "=";
	while(r % 2 == 0)
	{
		cout << 2;
		r >>= 1;
		if(r == 1)
		{
			return 0;
		}
      	else
      	{
            cout << "*";
       	}
	}
	for(int i = 3; i <= r; i += 2)
	{
		while(r % i == 0)
		{
			cout << i;
			r /= i;
			if(r == 1)
			{
				return 0;
			}
            else
            {
            	cout << "*";
            }
		}
	}
	
	return 0;
}
```


---

## 作者：Stella_Yan (赞：1)

   斐波那契相信大家都会了，这题主要是考的分解质因数。

   斐波那契的递推式:$f[i]=f[i-1]+f[i-2]$,还有一种简单的,写在代码里:
        
   因为你把$f[i]$算出来了,要算$f[i+1]$,那么原来的$f[i-2]$就没用了,$f[i-1]$变成了$f[i-2]$,刚算出来的$f[i]$变成了$f[i-1]$,一直递推到n。这样就可以用三个变量代替f数组。
    
   分解质因数的话,就是从2开始枚举,直到发现一个能被整除的质数(这个质数一定是最小的),再输出,把数列的最后一个数除上这个质数,然后接着从2开始找。。。一直到那个数被除到1为止。
        
   具体分析看代码:
    
```cpp
#include<iostream>
#include<cmath>
using namespace std;
bool pri(int x)//判断质数。
{
	int m=sqrt(x);//用一个变量来存储，避免了重复计算平方根
	if(x<=1)//小于等于1的都不是质数
		return false;
	for(int i=2;i<=m;i++)//从2循环到sqrt(x)(m)
		if(x%i==0)//如果有能被整除的,就说明不是质数
			return false;
	return true;
}
void fjzys(int x)//分解质因数(不会英文用拼音...)
{
	cout<<x<<"=";//先输一个头,这是一定要的
	if(pri(x))//如果本身就是质数那就不用分解了,直接输出
	{
		cout<<x;
		return;
	}
	bool fir=false;//判断输出的是否为第一个数
	while(x!=1)//x没有被除尽时
	{
		for(int i=2;i<=x;i++)//从2到x,找一个可以被x整除的质数
			if(pri(i) && x%i==0)
			{
				if(fir==false)//如果是第一个数就不用加乘号
				{
					cout<<i;
					fir=true;//现在不是第一个了
				}
				else//如果不是第一个就加乘号
				{
					cout<<"*"<<i;
				}
				x/=i;//把x除以i
				break;//退出循环
			}
	}
}
int main()
{
	long long f1,f2,f3;//如果要%2^31的话可能会爆int
	int n;
	cin>>n;
	if(n==1 || n==2)//第1和2项都是1,不用分解了
	{
		cout<<"1=1";
		return 0;
	}
	f1=1;//第1项为1
	f2=1;//第2项为1
	for(int i=3;i<=n;i++)
	{
		f3=f1+f2%21474836348;//第3项=第1项+第2项
		f1=f2;//第1项变成"第2项"
		f2=f3;//第2项变成"第3项"
		f1%=21474836348;
		f2%=21474836348;//就地取模保险
	}
	fjzys(f3);//输出
}
```

---

## 作者：封禁用户 (赞：1)

//这题太简单啦，要用矩阵快速幂蛤蛤蛤蛤蛤蛤

//矩阵告诉我们，斐波那契数列是可以用logn解决的！

```cpp
//f(x)             1       1           f(x+1)
              *                     ==
  f(x-1)          1       0           f(x)
//又因为矩阵适用于结合律所以用矩阵快速幂就行啦2333
#include<stdio.h>
#include<math.h>
#include<iostream>
using namespace std;
int n,nn[20][20],ans[20][20],now[20][20],aa;
inline void cheng1(){
    for(int i=0;i<1;++i){
        for(int j=0;j<2;++j){
            for(int k=0;k<2;++k){
                nn[i][j]+=ans[i][k]*now[k][j];
            }
        }
    }
    for(int i=0;i<1;++i){
        for(int j=0;j<2;++j){
            ans[i][j]=nn[i][j];
            nn[i][j]=0;
        }
    }
}
inline void cheng2(){
    for(int i=0;i<2;++i){
        for(int j=0;j<2;++j){
            for(int k=0;k<2;++k){
                nn[i][j]+=now[i][k]*now[k][j];
            }
        }
    }
    for(int i=0;i<2;++i){
        for(int j=0;j<2;++j){
            now[i][j]=nn[i][j];
            nn[i][j]=0;
        }
    }
}
int main(){
//    freopen("testdata.in","r",stdin);
//    freopen("1.txt","w",stdout);
    scanf("%d",&n);
    ans[0][0]=1;
    now[0][0]=now[0][1]=now[1][0]=1;
//    printf("%llu",n);
//    return 0;
    if(!n){
        putchar(48);
        return 0;
    }
    --n;
    for(;;){
        if(n&1){
        cheng1();
        }
        n>>=1;
        if(!n){
            break;
        }
        cheng2();
    }
    printf("%d=",ans[0][0]);
    int w=sqrt(ans[0][0]);
    for(int i=2;i<=w;++i){
        if(!(ans[0][0]%i)){
            while(!(ans[0][0]%i)){
                printf("%d",i);
                ans[0][0]/=i;
                if(ans[0][0]!=1){
                    putchar('*');
                }
                else{
                    return 0;
                }
            }
        }
    }
    printf("%d",ans[0][0]);
    //for(int 
    //
    //
    return 0;
}
```

---

## 作者：逍遥__天赐 (赞：0)

其实这一道题用不到mod2^31

我用的是三个数推出整个斐波那契数列

然后输出质因数时先特判质数（省时）

然后找到它的第一个质因数（t）

从t开始列举

直到原数=1

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int f()//推出斐波那契数列
{
    unsigned int a1=1,a2=1,a3;
    for(int i=3;i<=n;i++)
    {
        a3=a1+a2;
        a1=a2;
        a2=a3;
    }
    return a3;
}
bool zz(int i)//判断质数
{
    if(i==2) return 1;
    if(i%2==0) return 0;
    if(i<2) return 0;
    int t=sqrt(i);
    for(int j=3;j<=t;j+=2)
    {
        if(i%j==0) return 0;
    }
    return 1;
}
void fj(int i)
{
    if(zz(i))
    {
        cout<<i<<'='<<i;
        return;
    }
    if(i==1||i==2)//特判特殊情况
    {
        cout<<"1=1\n";
        return;
    }
    cout<<i<<'=';
    int t=2;
    while(i%t) t++;//算出最小的质因数
    cout<<t;
    i/=t;
    while(i>1)
    {
        if(i%t==0)
        {
            cout<<'\*'<<t;
            i/=t;
        }
        else t++;
    }
}
int main()
{
    cin>>n;
    n=f();
    fj(n);
    return 0;
}

---

## 作者：LGG_ (赞：0)

# 简单，易理解

第一步：找到48位的斐波那契数

第二步：找到求的那一位

第三步：质因数分解

其次难点就是在第三步！

质因数分解（详细在代码解释）
	
   ```c
else{
		while(x!=1){
			for(int i=2;i<=x;i++){
				if(tr(i)&&x%i==0){//tr是另一个函数（判断质数）
					printf("%d",i);
					//if(i!=x)printf("*");
					x=x/i;
					i=1;
				}
			}
		}
	}
```

所以这道题就简单了
```c
#include<iostream>
#include<cmath>
#include"cstdio"
using namespace std;
const int mod=pow(2,31);//懒..
int a[50],n,m;
bool tr(int i){
	int j;
	for(j=2;j<sqrt(i);j++){
		if(i%j == 0){
			return 0;
		}
	}
	return 1;
}
int main()
{
	scanf("%d",&m);//用cin可能会超时（或者加优化）
	a[1]=a[2]=1;
	for(int i=2;i<=49;i++)
	{
		a[i+1]=(a[i-1]+a[i])%mod;
	}//创建函数
	int x=a[m];
	if(tr(a[m])){
		cout<<a[m]<<"="<<a[m];
		return 0;//优化，为质数的情况；
	}
	else{
		printf("%d=",a[m]);
		while(x!=1){
			for(int i=2;i<=x;i++){
				if(tr(i)&&x%i==0){
					printf("%d",i);
					if(i!=x)printf("*");
					x=x/i;
					i=1;	
				}
			}
		}
	}
	return 0;
}
```
~~冲前500！！~~![](https://cdn.luogu.com.cn/upload/pic/1436.png)

---

## 作者：Jelly_Goat (赞：0)

来一发fibnacci数列的增强版。  
~~全局定义~~：设$fib_i$是该数列的第i项。

----

**题目大意**：  
Subtask1: 求$fib_n$  
Subtask2: 分解$fib_n$的质因数  
$(n\leq 48)$

-----

首先我们得到了一个朴素到家的算法：  
直接暴力1->48递推。  
~~但是追求优美的我并不满足~~  
于是我来了一发**矩阵快速幂优化**~  

首先学习**前置知识：矩阵乘法**~~右转百度~~  
然后开始手动**构造基础矩阵和原矩阵**。  

首先原矩阵轻松得到
$$
 \left[
 \begin{matrix}
   1 & 1
  \end{matrix}
  \right]
$$
即前两项$[fib_1\space fib_2]$。  
一开始得到的fibnacci数列的**递推式子**是：  
$$
fib_n=fib_{n-1}+fib_{n-2}(n>2) 
$$
$$
(fib_1=fib_2=1)
$$
那么我们**最早用到的项**是前**两项**，因此我们直接构造一个`2*2`的基础矩阵。    
如果我们要向下一项推，我们要让两项相加放在第一项，原先的第一项放在第二项。  
那么对应求和第一项的系数是$
\left[
\begin{matrix}
1\texttt{(这是第一项的系数)}\\ 
1\texttt{(这是第二项的系数)}
\end{matrix}
\right]
$  

求和第二项的系数是$
 \left[
 \begin{matrix}
 1\texttt{(这是第一项的系数)}\\
 0\texttt{(这是第二项的系数)}
  \end{matrix}
  \right]
$

因此得到了原矩阵和基础矩阵分别是$
\left[
\begin{matrix}
1 & 1
\end{matrix}
\right]
$和$  
\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}
\right]
$  
所以我们得到下面的式子：   
$
fib_n=
\left[
\begin{matrix}
1 & 1
\end{matrix}
\right] \times  
\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}
\right] ^ {n-2}\texttt{的第一项}(n>2)
$  
最后基础矩阵的n-2次方直接就矩阵快速幂就好了  
下面是欢快的代码  
```cpp
#include <iostream>
#include <cstdio>

using namespace std;
using lli = long long int;
const lli mod=(1<<31);
template<typename T>inline T Read();
struct matrix{
	int hang,lie;
	lli data[3][3];
	matrix(int h,int l)
	{
	    hang=h,lie=l;
	    for (register int i=0;i<=2;i++)
			for (register int j=0;j<=2;j++)
                data[i][j]=0;
	}
	matrix()
	{
	    hang=lie=0;
	    for (register int i=0;i<=2;i++)
			for (register int j=0;j<=2;j++)
                data[i][j]=0;
	}
};
inline matrix operator * (const matrix &a,const matrix &b)
{
	matrix c(a.hang,b.lie);
	for (register int i=1;i<=c.hang;i++)
		for (register int j=1;j<=c.lie;j++)
			for (register int k=1;k<=a.lie;k++)
			{
				c.data[i][j]+=a.data[i][k]*b.data[k][j]%mod;
				c.data[i][j]%=mod;
			}
	return c;
}
inline matrix quick_pow(matrix a,lli k)
{
	if (k<=1)return a;
	matrix res=a;
	k=k-1;
	while (k)
	{
		if (k&1)res=res*a;
		a=a*a;
		k>>=1;
	}
	return res;
}
inline lli fib(int k)
{
    if (k<=2)return 1;
    matrix base(2,2),ori(2,1);
    base.data[1][1]=base.data[1][2]=base.data[2][1]=ori.data[1][1]=ori.data[2][1]=1;
    base.data[2][2]=0;
    return (quick_pow(base,k-2)*ori).data[1][1];
}

int main()
{
    lli ans=fib(Read<lli>());
    printf("%lld=",ans);
    for (lli i=2;i<=ans;i++)
    {
        while (ans%i==0)
        {
            if (ans==i)
                return printf("%lld\n",i),0;
            else printf("%lld*",i),ans/=i;
        }
    }
    return 0;
}

template<typename T>inline T Read()
{
    T num=0;char ch=getchar();bool flag=false;
    while (!isdigit(ch))flag|=ch=='-',ch=getchar();
    while (isdigit(ch))num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    return flag?-num:num;
}
```

---

## 作者：虞杨英Jack (赞：0)

# 斐波那契数列常规解法：递推
#### 这是我Jack-yyy第一次发题解，望采纳，thanks
```c
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    long long f[50]={0,1,1};//初始化
    int n;scanf("%d",&n);//读入
    for(int i=3;i<=n;i++)f[i]=f[i-1]+f[i-2];f[n]%=1<<31;//从f[3]开始，递推到n，简洁：位运算
    printf("%lld=",f[n]);//输出f[n]
    if(n==2){
        printf("1");
        return 0;//结束
    }//特判一下
    long long ssqrt=sqrt(f[n]);//取n的开方
    bool tf=false;//判断是否输出*
    for(long long i=2;i<=ssqrt&&f[n]!=1;i++)
    while(!(f[n]%i)){
        tf?printf("*%d",i):printf("%d",i);//三目运算符
        f[n]/=i;//判断是否要输出*
        tf=true;//
    }
    if(f[n]-1)
    tf?printf("*%d",f[n]):printf("%d",f[n]);//如果剩的不是1，则输出，记得还要判断是否输出*
    return 0;
}
```


---

## 作者：Anakin (赞：0)

//用矩阵快速幂求出fib数列的第n项，边求边取模


            
```cpp
//最后分解质因数就ok了
#include<iostream>
#include<cstdio>
#include<cstring>
#define MAXN 20
#define ll long long
using namespace std;
int n=2;
const ll p=(1<<31);
void write(ll x){//输出优化
    if(x>9) write(x/10);
    putchar(x%10+48);
}
struct Mat{//定义一个结构体，使用起来方便
    ll m[MAXN][MAXN];
    Mat() {}
    Mat(int x){
        Mat_init();
        for(int i=1;i<=MAXN;i++) m[i][i]=x;
    }
    void Mat_init(){ memset(m,0,sizeof(m));}
    Mat operator*(Mat const &B)const{
        Mat C;
        C.Mat_init();
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    C.m[i][j]=(C.m[i][j]+(m[i][k]*B.m[k][j]))%p;
                }
            }
        }
        return C;
    }
    Mat operator+(Mat B){
        Mat C;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                C.m[i][j]=(m[i][j]+B.m[i][j])%p;
            }
        }
        return C;
    }
    Mat operator^(int k){//矩阵快速幂
        Mat A= *this,ans(1);
        while(k){
            if(k&1) ans=ans*A;
            A=A*A;
            k>>=1;
        }
        return ans;
    }
}A;
ll read(){//读入优化
    ll out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57){
        out=(out<<1)+(out<<3)+c-48;
        c=getchar();
    }
    return out;
}
void init(){
    A.m[1][1]=1;
    A.m[1][2]=1;
    A.m[2][1]=1;
    A.m[2][2]=0;
}
void print(Mat x){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            write(x.m[i][j]);
            putchar(' ');
        }
        puts("");
    }
}
ll fib(int k){
    Mat ans=A^k;
    return ans.m[1][2];
}
void divide(ll x){//分解质因数
    if(x<=3){
        write(x);
        return;
    }
    else{
        ll nn=x;
        for(int i=2;i<=nn;i++){
            while(!(x%i)){//从2开始，除到没有这个因子为止
                write(i);
                x/=i;
                if(x>1) putchar('*');
            }
            if(i>x) break;//i>x时说明已经分解完毕
        }
    }
}
void solve(){
    int k;
    cin>>k;
    init();
    Mat ans=A^k;
    write(ans.m[1][2]);
    putchar('=');
    divide(ans.m[1][2]);
}
int main(){
    solve();
    return 0;
}
```

---

## 作者：q2368126021 (赞：0)

###这道题目我用的是暴力模拟

###注：下面一连串判断是为了判断其是否到了不可再分的时候，例如当它为5，7，1，2等

###虽然说没有mod，但也过了

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100000];
int main()
{
    int n;
    scanf("%d",&n);
    int i;
    a[1]=1;
    a[2]=2;
    for(i=3;i<=n;i++)**初始化序列**
      a[i]=a[i-1]+a[i-2]; 
    int tmp=a[n-1];
    i=1;
    printf("%d=",tmp);
    while(tmp!=5&&tmp!=7&&tmp!=2&&tmp!=1)**条件判断**
    {
         i++;**累加进行质因数拆分，由于其从1开始，故而其如能被mod必然是比较小的，下列可以直接输出**
        if(tmp%i==0)
         {
          if(tmp/i!=1)**经过调试得出如果它被mod是1的话，证明是最后一个质因数，避免输出最后一个*号**
          printf("%d*",i);
           else printf("%d",i);
          tmp/=i;
          i=1;**注：必须是1，如果为0下次累加其将会疯狂输出1**
         }
    }
    if(tmp==5||tmp==7||tmp==2||tmp==1)
     printf("%d",tmp);**判断，如果是这几个直接输出**
}
```

---

## 作者：Drinkkk (赞：0)

/\*
P2626 题解

判断质数+质因数分解+快速排序

\*/
```cpp
#include <cstdio>//头文件
#include <cmath>//头文件
int f[10001],ans[10001],k=0;//f数组是用来存储斐波那契数列的（即斐波那契数列的第n项等于f[n]），ans数组是用来存储已经分解好了的质因数的。
int px(int l,int r)//快速排序所需要用到的函数（注：l为左边界，r为右边界）
{
    int x=l,y=r,mid=ans[(l+r)/2];//x是当前的左边界，y就是当前的右边界，mid是基准值
    while(x<=y)//只要左边界小于等于右边界的时候执行循环
    {
        while(ans[x]<mid)//如果符合要求
        {
            x++;//那么就将当前的左边界向右移动一格
        }
        while(ans[y]>mid)//如果也符合要求
        {
            y--;//那么就将当前的右边界向左移动一格
        }
        if(x<=y)//只要左边界小于等于右边界的时候执行判断
        {
            int t=ans[x];//交换
            ans[x]=ans[y];
            ans[y]=t;
            x++;//将当前的左边界向右移动一格
            y--;//将当前的右边界向左移动一格
        }
    }
    if(l<y)//如果还有没有排序完的地方
    {
        px(l,y);//继续排序
    }
    if(x<r)//如果还有没有排序完的地方
    {
        px(x,r);//继续排序
    }
}
int pd(int n)//判断这个数是否为素数的函数
{
    if(n<2)//如果这个数一定不是质数
    {
        return 0;//返回0
    }
    int l=sqrt(n+1);//开始判断质数
    for(int i=2;i<=l;i++)
    {
        if(n%i==0)//如果能够被整除（即这个数不是质数）
        {
            return 0;//那么就返回0
        }
    }
    if(f[k]%n==0)//如果可以被整除
    {
        return 1;//返回1（请想一想为什么要这样）
    }
    return 0;//返回0
}
int main()//主函数
{
    f[1]=1,f[2]=1;//斐波那契额数列
    int n=0,len=0;//定义变量
    scanf("%d",&n);//读入数据
    k=n;//赋值
    for(int i=3;i<=n;i++)//开始推斐波那契数列
    {
        f[i]=f[i-1]+f[i-2];//推理公式
    }
    printf("%d=",f[n]);//输出（一部分）
    while(1)//无限循环
    {
        int t=sqrt(f[n]+1);//判断素数
        bool flag=true;
        for(int i=2;i<=t;i++)
        {
            if(pd(i)==1)//如果这个数是素数
            {
                len++;//存数下去
                ans[len]=i;
                f[n]/=i;
                flag=false;
            }
        }
        if(flag==true)//如果分解完了
        {
            if(f[n]!=1)//特殊判断（请想一想问什么要这样做）
            {
                len++;//存数
                ans[len]=f[n];
            }
            break;//跳出循环
        }
    }
    px(1,len);//快速排序（从小到大）
    for(int i=1;i<=len-1;i++)//输出（另一部分）
    {
        printf("%d*",ans[i]);
    }
    printf("%d",ans[len]);
    return 0;//结束程序
}
```

---

## 作者：juruojjl_ (赞：0)

这题你一看到题面就想到了isprime？！

没错我就是这么想的

$20Code:$

```cpp
#include<bits/stdc++.h>    //万能头
using namespace std;
const long long MOD=2147483648;   //直接打真累，这样才舒服
bool isprime(int n)       //是不是质数
{
    if(n<=1) return false;
    for(int i=2;i<=sqrt(n);i++) if(n%i==0) return false;
    return true;
}
int main()
{
    int f[49]={0,1,1},n,t;//初始化
    cin>>n;
    for(int i=3;i<=n;i++) f[i]=(f[i-1]+f[i-2])%MOD;//边推边MOD
    cout<<f[n]<<"=";
    if(isprime(f[n])) cout<<f[n];//是质数直接输出
    else t=f[n];
    for(int i=2;i<=sqrt(t)&&isprime(i);i++)  //判断i是不是质因数
    {
        while(t%i==0)
        {
            if(t/i==1)
            {
                cout<<i;
                break;
            }
            else cout<<i<<"*",t/=i;
        }
        if(t%i!=0) continue;
    }//分解质因数并输出
    return 0;
}
```

然后，你懂的

https://www.luogu.org/recordnew/show/19319614

为什么？？？

他错在了for条件

你看

拿一组数据来看

$\sqrt{55}≈7,55=5*11$

你说AC才怪呢！~~其实有一组数据本身就是质数所以AC了~~

然后我们可以去掉开方~~∪没有AC~~

其实，罪魁祸首就是isprime！

ta一碰到不是prime的情况，ta就和$for$
$$\color{red}{B}\color{orange}{y}\color{yellow}{e}\color{green}{B}\color{blue}{y}\color{purple}{e}$$
了

so，我们删了isprime，i<=f[n]???

https://www.luogu.org/recordnew/show/19357442

你懂的

超时了，咱们不如设个替罪羊t，每次循环到ta吧！

$ACCode:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MOD=2147483648;
int main()
{
    int f[49]={0,1,1},n,t;
    cin>>n;
    for(int i=3;i<=n;i++) f[i]=(f[i-1]+f[i-2])%MOD;
    cout<<f[n]<<"=";
    t=f[n];
    for(int i=2;i<=t;i++)
    {
        while(t%i==0)
        {
            if(t/i==1)
            {
                cout<<i;
                break;
            }
            else cout<<i<<"*",t/=i;
        }
        if(t%i!=0) continue;
    }
    return 0;
}
```
无耻的挂上[$blog$](https://www.luogu.org/blog/fanminirenrenyouze/)

---


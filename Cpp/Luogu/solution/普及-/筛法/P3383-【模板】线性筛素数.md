# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数。  

提示：本题输入输出、运算数据量较大。

- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\n'` 换行输出。
- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。
- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# 题解

## 作者：学委 (赞：1189)

*2020-02-01 更新*

想要快速地筛出一定上限内的素数？

下面这种方法可以保证范围内的每个合数都被删掉（在 bool 数组里面标记为非素数），而且任一合数只被：

**“最小质因数 × 最大因数（非自己） = 这个合数”**

的途径删掉。由于每个数只被筛一次，时间复杂度为 $O(n)$。

# 欧拉筛

先浏览如何实现再讲其中的原理。
___

## 实现

```cpp
#include <cstdio>
#include <cstring>

bool isPrime[100000010];
//isPrime[i] == 1表示：i是素数
int Prime[6000010], cnt = 0;
//Prime存质数

void GetPrime(int n)//筛到n
{
	memset(isPrime, 1, sizeof(isPrime));
	//以“每个数都是素数”为初始状态，逐个删去
	isPrime[1] = 0;//1不是素数
	
	for(int i = 2; i <= n; i++)
	{
		if(isPrime[i])//没筛掉 
			Prime[++cnt] = i; //i成为下一个素数
			
		for(int j = 1; j <= cnt && i*Prime[j] <= n/*不超上限*/; j++) 
		{
        	//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数
            //当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的
			isPrime[i*Prime[j]] = 0;
            
			if(i % Prime[j] == 0)//i中也含有Prime[j]这个因子
				break; //重要步骤。见原理
		}
	}
}

int main()
{
	int n, q;
	scanf("%d %d", &n, &q);
	GetPrime(n);
	while (q--)
	{
		int k;
		scanf("%d", &k);
		printf("%d\n", Prime[k]);
	}
	return 0;
}

```
___

## 原理概述

代码中，外层枚举 $i = 1 \to n$。对于一个 $i$，经过前面的腥风血雨，如果它还没有被筛掉，就加到质数数组 $Prime[]$ 中。下一步，是用 $i$ 来筛掉一波数。

内层从小到大枚举 $Prime[j]$。$i×Prime[j]$ 是尝试筛掉的某个合数，其中，**我们期望 $Prime[j]$ 是这个合数的最小质因数 (这是线性复杂度的条件，下面叫做“筛条件”)**。它是怎么得到保证的？

**$j$ 的循环中，有一句就做到了这一点：**

```cpp
			if(i % Prime[j] == 0)
				break; 
```

$j$ 循环到 $i \mod Prime[j] == 0$ 就**恰好需要停止**的理由是：

* 下面用 $s(smaller)$ 表示小于 $j$ 的数，$L(larger)$ 表示大于 $j$ 的数。

* **① $i$ 的最小质因数肯定是 $Prime[j]$。**

    （如果 $i$  的最小质因数是 $Prime[s]$ ，那么 $Prime[s]$ 更早被枚举到（因为我们从小到大枚举质数），当时就要break）

    既然 $i$ 的最小质因数是 $Prime[j]$，那么 $i × Prime[j]$ 的最小质因数也是 $Prime[j]$。所以，$j$ 本身是符合“筛条件”的。

* **② $i × Prime[s]$ 的最小质因数确实是 $Prime[s]$。**

    （如果是它的最小质因数是更小的质数 $Prime[t]$，那么当然 $Prime[t]$ 更早被枚举到，当时就要break）
    
    这说明 $j$ 之前（用 $i × Prime[s]$ 的方式去筛合数，使用的是最小质因数）都符合“筛条件”。

* **③ $i × Prime[L]$ 的最小质因数一定是 $Prime[j]$。**
	
    （因为 $i$ 的最小质因数是 $Prime[j]$，所以 $i × Prime[L]$ 也含有 $Prime[j]$ 这个因数（这是 $i$ 的功劳），所以其最小质因数也是 $Prime[j]$（新的质因数 $Prime[L]$ 太大了））
    
    这说明，如果 $j$ 继续递增（将以 $i × Prime[L]$ 的方式去筛合数，没有使用最小质因数），是不符合“筛条件”的。

*小提示：*

*当 $i$ 还不大的时候，可能会一层内就筛去大量合数，看上去耗时比较大，但是由于保证了筛去的合数日后将不会再被筛（总共只筛一次），复杂度是线性的。到 $i$ 接近 $n$ 时，每层几乎都不用做什么事。*

建议看下面两个并不复杂的证明，你能更加信任这个筛法，利于以后的扩展学习。

## 正确性（所有合数都会被标记）证明

设一合数 $C$（要筛掉）的最小质因数是 $p_1$，令 $B = C / p_1$（$C = B × p_1$），则 $B$ 的最小质因数不小于 $p_1$（否则 $C$ 也有这个更小因子）。那么当外层枚举到 $i = B$ 时，我们将会**从小到大**枚举各个质数；因为 $i = B$ 的最小质因数不小于 $p_1$，所以 $i$ 在质数枚举至 $p_1$ 之前一定不会break，**这回**，$C$ 一定会被 $B × p_i$ 删去。

**核心：亲爱的 $B$ 的最小质因数必不小于 $p_1$。**

例：$315 = 3 × 3 × 5 × 7$，其最小质因数是 $3$。考虑 $i = 315 / 3 = 105$ 时，我们从小到大逐个枚举质数，**正是因为** $i$ 的最小质因数**也**不会小于 $3$（本例中就是 $3$），所以当枚举 $j = 1 (Prime[j] = 2)$ 时，$i$ 不包含 $2$ 这个因子，也就**不会break**，直到 $Prime[j] = 3$ **之后**才退出。

*当然质数不能表示成“**大于1的某数×质数**”，所以整个流程中不会标记。*

## 线性复杂度证明

注意这个算法一直使用“某数×质数”去筛合数，又已经证明一个合数一定会被它的最小质因数 $p_1$ 筛掉，所以我们**唯一要担心的就是同一个合数是否会被“另外某数 × $p_1$ 以外的质数”再筛一次导致浪费时间**。设要筛的合数是 $C$，设这么一个作孽的质数为 $p_x$，再令 $A = C / p_x$，**则 $A$ 中一定有 $p_1$ 这个因子**。当外层枚举到 $i = A$，它想要再筛一次 $C$，却在枚举 $Prime[j] = p_1$ 时，因为 $i \mod Prime[j] == 0$ 就退出了。因而 $C$ 除了 $p_1$ 以外的质因数都不能筛它。

**核心：罪恶的 $A$ 中必有 $p_1$ 这个因子。**

例：$315 = 3 × 3 × 5 × 7$。首先，虽然看上去有两个 $3$，但我们筛数的唯一一句话就是
```cpp
			isPrime[i*Prime[j]] = 0;
```
所以，$315$ 只可能用 $105 × 3$ 或 $63 × 5$ 或 $45 × 7$ 这三次筛**而非四次**。然后，非常抱歉，后两个 $i = 63, i = 45$ 都因为贪婪地**要求对应的质数** $Prime[j]$ 为 $5$ 、$7$，而**自己被迫拥有** $3$ 这个因数，因此他们内部根本枚举不到 $5$ 、$7$，而是枚举到 $3$ 就break了。

以上两个一证，也就无可多说了。

___

更新日志：

2019-02-22 原理简化；用词修改或订正。

2019-04-02 一些用词更准确；加入更多括号内的注释，减少回看上文的需要。

2020-02-01 题面修改了，补充一下答案输出。

---

## 作者：rainygame (赞：36)

> **本题非正解，仅为 $O(n \log \log n)$ 的埃氏筛法解。若想学习 $O(n)$ 的欧拉筛法解，请参考其它题解。**

首先，我们考虑如何筛出质数。我们知道，在大于 $1$ 的自然数中，不是质数就是合数，所以我们可以换个角度，考虑筛出所有的合数。

而我们又知道，合数是由若干个质数相乘得来的，所以，我们可以考虑这样的方式筛出所有的合数：

1. 如果一个数没有被标记是合数，就把它所有不超过 $n$ 的都标记成合数。（这里又有个小优化，如果从 $i^2$ 开始往后找和从 $2i$ 往后找是一样的。因为 $2i$、$3i$ 等肯定被之前的标记过了）
2. 如果它被标记了，那就不鸟它。

然后所有被标记的数都是合数，没有被标记的就是质数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100000001

int n, q, ind, k;
int prime[MAXN];
bool is_prime[MAXN];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> q;

    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i*i<=n; i++){
        if (is_prime[i]){
            for (int j=i*i; j<=n; j += i) is_prime[j] = false;
        }
    }

    for (int i=2; i<=n; i++){
        if (is_prime[i]) prime[++ind] = i;
    }

    while (q--){
        cin >> k;
        cout << prime[k] << '\n';
    }

    return 0;
}
```

它的时间复杂度为 $O(n \log \log n)$，是十分优秀的（如果不加上面的小优化就是 $O(n \log n)$ 的）。所以它通过了，但是用时约 $6.3$ s，比欧拉筛慢了许多……

这时候，我们就可以用我们的神器：`bitset` 了！

我们可以这样写：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100000001

int n, q, ind, k;
int prime[MAXN];
bitset<MAXN> is_prime;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> q;

    is_prime.set();
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i*i<=n; i++){
        if (is_prime[i]){
            for (int j=i*i; j<=n; j += i) is_prime[j] = false;
        }
    }

    for (int i=2; i<=n; i++){  // 注意不要写进上面那个循环里！
        if (is_prime[i]) prime[++ind] = i;
    }

    while (q--){
        cin >> k;
        cout << prime[k] << '\n';
    }

	return 0;
}
```

用时 $2.5$ s 通过，差不多是前面的 `bool` 数组的 $\dfrac{1}{2}$。

这样不仅可以通过本题，还可以获得比题解还要优秀 $3\sim4$ 倍的效率。但是这对欧拉筛有反作用。

---

## 作者：Fish_egg_ (赞：10)

**这是一篇 Python 题解。**


## ${\color{#00AACD}\textbf{埃拉托斯特尼筛法（埃氏筛）}}$
### ${\color{#00CD00}\text{算法介绍}}$

根据质数的定义，任何一个质数的 $x$ 倍（$x > 1$）都是合数。于是我们可以从小到大考虑每一个数，并将这个数的所有大于自身倍数都标记为合数。运行结束后，所有未被标记的数就是质数了。

算法的流程如下：
1. 创建一个初始时全为 $1$ 的标记数组 `isprime`，并将 $0$ 和 $1$ 标记为非质数。
2. 从小到大遍历 $2\sim n$ 的每个整数：
   - 如果这个数已经被标记为合数，则将其跳过；
   - 否则，遍历这个数的所有大于自身的倍数，将它们都标记为合数。
3. 最后，所有未被标记的数即为质数。

以上即为埃拉托斯特尼筛法（埃氏筛）。埃氏筛的时间复杂度为 $O(n\log\log n)$，证明较复杂，可参见 [OI - Wiki](https://oi-wiki.org/math/number-theory/sieve/)。

虽然埃氏筛的时间复杂度是 $O(n\log\log n)$，但是由于其常数较小，且有多种方式进行优化，很多时候跑得比 $O(n)$ 的欧拉筛还要快。

---
### ${\color{#00CD00}\text{算法优化}}$

1. 要找出 $1\sim n$ 的所有质数，只需要对 $1\sim\lfloor\sqrt n\rfloor$ 的质数进行筛选就够了。正确性显然。
2. 除了 $2$ 以外的所有偶数都是合数，因此只需要筛奇数就行了，运算量直接减少了一半。
3. 对于一个质数 $p$，只需从它的 $p$ 倍开始标记即可，因为 $2\sim p-1$ 倍已经被前面的质数标记了。
4. 标记数组 `isprime` 可以用 `bool` 类型存储，可以减少内存占用。在 Python 中，可以用 `NumPy` 库创建数组。

---
### ${\color{#00CD00}\text{代码实现}}$

```python
import numpy as np # 使用 NumPy 库提供高效的列表操作
from sys import stdin, stdout # 使用 sys.stdin/stdout 代替缓慢的 input/print

n, q = map(int, stdin.readline().split(' '))
isprime = np.ones(n + 1, dtype = bool) # 创建初始全为 1，类型为 bool 的列表
isprime[0] = isprime[1] = isprime[4::2] = False # 将 0、1 和大于 2 的偶数标记为非质数

for i in range(3, int(n**0.5) + 1, 2): # 只筛 sqrt(n) 以内的奇数
    if isprime[i]: isprime[i*i::i+i] = False # 从 i*i 开始筛，步长为 2i
    
prime = np.nonzero(isprime)[0] # 使用 np.nonzero() 找出 isprime 中所有非 0 的索引

for k in stdin: stdout.write(str(prime[int(k) - 1]) + '\n')
```
## ${\color{#00AACD}\textbf{欧拉筛法（线性筛）}}$

### ${\color{#00CD00}\text{算法介绍}}$

注意到在埃氏筛中，一个数可能会被多个质数标记（如 $12 = 2\times 6 = 3\times 4$，既可以被 $2$ 标记也可以被 $3$ 标记）。考虑如何让一个合数只被其最小的质因数标记。设计如下算法：
1. 创建一个初始时全为 $1$ 的标记数组 `isprime` 和一个初始时为的质数列表 `prime`。
2. 从小到大遍历 $2\sim n$ 的每个数，设当前的数为 $i$，如果 $i$ 未被标记，就将其加入质数列表中。
   -  对于每个 $i$，遍历当前质数列表中的每一个质数，设当前的质数为 $p$，将 $i\times p$ 标记为合数。
   - 如果 $i\bmod p=0$，说明 $i$ 之前已经被 $p$ 标记过了，所以 $i$ 乘上其他质数的结果也一定会被 $p$ 标记，因此直接退出即可。
3. 最后，得到的质数列表 `prime` 即为 $1\sim n$ 的所有质数。

以上即为欧拉筛法（线性筛）。可以发现，在线性筛中，每个合数都只会被其最小的质因数标记 $1$ 次，因此时间复杂度为 $O(n)$。

---
### ${\color{#00CD00}\text{代码实现}}$

在本题中，线性筛做法需要使用 PyPy3 提交才能勉强通过。洛谷的 PyPy3 不提供 `NumPy` 库支持，故使用 `bytearray` 代替。

```python
from sys import stdin, stdout # 使用 sys.stdin/stdout 代替缓慢的 input/print

n, q = map(int, stdin.readline().split(' '))
isprime = bytearray([1]) * (n + 1) # 创建长度为 n+1, 初始全为 1 的 bytearray
prime = [] # 创建初始为空的质数列表 prime

for i in range(2, n + 1): # 遍历 2~n 的每一个数
    if isprime[i]: prime.append(i) # 如果当前的数未被标记，将其加入质数列表
    for p in prime: # 遍历当前质数列表中的每一个质数
        if i * p > n: break # 若超出范围直接退出
        isprime[i * p] = 0 # 将 i*p 标记为合数
        if i % p == 0: break # 若 i%p==0 直接退出

for k in stdin: stdout.write(str(prime[int(k) - 1]) + '\n')
```

---

## 作者：bcdmwSjy (赞：7)

**注意：这是一篇 python 题解**

由质数的定义可得，质数的倍数（$\ge2$ 倍）都不是质数，于是我们可以在最开始假设所有数都是质数，然后遍历每一个质数，把它的倍数都标记为非质数。

这就是埃氏筛，根据质数分布，可以分析出复杂度为 $O(n\log\log n)$，具体过程可以见 [oi-wiki](https://oi-wiki.org/math/number-theory/sieve/#%E5%AE%9E%E7%8E%B0)，这里使用埃氏筛的原因是它更加容易被优化。

我们很容易写出以下代码：

```python
def init(n):
    global ip,pr
    pr=[]
    ip=[True]*(n+1)
    ip[0]=ip[1]=True
    for i in range(2,n+1):
        if ip[i]:
            for j in range(i*i,n+1,i): # 2 到 i-1 倍都计算过了，所以从 i*i 开始
                ip[j]=False
    for i in range(2,n+1):
        if ip[i]:
            pr.append(i)

if __name__=="__main__":
    n,q=map(int,input().split())
    init(n)
    for i in range(q):
        print(pr[int(input())-1])
```

但是，它 [MLE](https://www.luogu.com.cn/record/204939696) 了。

我们考虑哪里出现了问题，`ip` 数组只需要存 $1$ 和 $0$，但是我们用了一个整数的空间，于是可以把它换成 `numpy` 中的 `array` 对象，并使用 `numpy.once(n,dtype=bool)` 创建一个长度为 $n$ 且内容全为 `True` 的数组。

然后，我们又发现一个合数至少有一个因子不大于 $\sqrt{n}$，所以外层循环只需要筛到 $\sqrt{n}$ 即可。并且除了 $2$ 的偶数都不是质数，所以可以只筛奇数，又可以减掉一半常数。

接下来是对代码的优化，`numpy` 数组可以使用切片赋值一段，于是内层循环也可以算得更快，接下来，再用 `numpy.nonzero` 获取非零位置的下标，乘 $2$ 加 $1$ 后就可以得到质数的具体数值，但是没有 $2$ 和 $3$，用 `numpy.concatenate` 把它们加到前面就好了。最后再使用 `sys.stdin` 和 `sys.stdout` 加速输入输出，加上所有优化后即可通过 ~~（不过还比 C++ 慢了 3 倍）~~。

```python
import sys
import numpy

def init(n):
    global ip,pr
    ip=numpy.ones(n>>1,dtype=bool)
    ip[0]=False
    for i in range(1,(int(n**0.5)>>1)+1):
        if ip[i]:
            ip[i*(i+1)<<1::i<<1|1]=False
    pr=numpy.concatenate(([2,3],numpy.nonzero(ip)[0][1:]*2+1))

if __name__=="__main__":
    n,q=map(int,sys.stdin.readline().split())
    init(n)
    sys.stdout.write("\n".join(str(pr[int(i)-1]) for i in sys.stdin))
```

---

## 作者：wangif424 (赞：6)

如何快速筛出 $10^8$ 以内的质数？

首先看相对暴力筛优秀了很多的线性筛。它枚举一个数 $i$，再枚举倍数 $i\times j$，每次筛掉一个数在范围内的所有倍数，时间复杂度 $T(n)=O(n\log n)$。

考虑去优化它，因为有的数被筛了很多次，我们想尽可能减少每个数被筛的次数，不难想到只枚举每个质数的倍数。

但这样够了吗？显然不够，例如形如 $6k$ 的数至少会被 $2$ 和 $3$ 各遍历一次。所以我们进一步想能不能每个数只被其除一外的最小的因数筛。

首先这个因数一定是质数，因为对于任何非质因数总能找到更小的质因数。

然后呢？我们设这个质因数为 $p$，如果它要筛 $x$，有 $kp=x$。因为 $p$ 是 $x$ 最小的因数，所以 $p$  小于等于 $k$ 最小的因数。

因此，对于每个 $i$，我们从小到大枚举它的质数 $p$ 倍， 并且 $p$ 小于等于 $i$ 最小的因数。

而对于 $p$ 小于等于 $i$ 最小的因数的条件，我们在第一次 $p|i$ **之后**退出本次循环即可。

PS: 因为 java 的性能略逊于 c++，故因当作一定的读入优化。

## AC 代码
```java
import java.io.IOException;

public class Main {
    public static int read() throws IOException{
        int r=0,f=1;
        char c=(char)System.in.read();
        while(c>'9'||c<'0'){if(c=='-')f=-1;c=(char)System.in.read();}
        while(c<='9'&&c>='0'){r=r*10+((int)c-48);c=(char)System.in.read();}
        return r*f;
    }
    public static void main(String[] argc) throws IOException {
        int n=read();
        boolean[] zs=new boolean[n+1];
        int[] p=new int[5761456];
        int l=0;
        for(int i=2;i<=n;i++){
            if(!zs[i])p[++l]=i;
            for(int j=1;j<=l&&p[j]*i<=n;j++){
                zs[i*p[j]]=true;
                if(i%p[j]==0)break;
            }
        }
        int q=read();
        while(q-->0) {
            System.out.println(p[read()]);
        }
    }
}

```

---

## 作者：kkksscc03 (赞：5)

## 一些闲话

蒟蒻第一篇题解，这一篇题解写的时候是尽可能详细的写的，所以可能有些啰嗦的地方（求审核大大通过）。

**先放代码（写了超多、超详细的注释，一定仔细看一看，深刻理解一下，别直接复制粘贴）：**
## ACcode：

```cpp
#include<bits/stdc++.h>
#define re ree()//宏定义快读，写的时候会舒服一点。 
using namespace std;
int ree(){int f=1,k=0;char c=getchar();while(c<'0'||c>'9') {if(c == '-') f = -1;c=getchar();}while(c>='0'&&c<='9') {k=k*10+c-'0';c=getchar();}return f*k;}//快读 
bool is_pe[100000001];//标记数组，is_pre[i]表示i是否为和数（1真，0假）。 
int pe[20000001],n,q,coun;//pe[i]表示第i个质数，coun表示质数的总个数，n，q意义见题面。 
void find_prime(int n)//线性筛质数 
{
	for(int i=2;i<=n;i++)//从2开始枚举到n因为0,1都不是质数 
	{
		if(is_pe[i]==0)//如果i没被标记为和数（就是 i 为质数） 
		{
			pe[++coun]=i;//记录 i 到质数表中，质数数量 +1 
		}
		for(int j=1;j<=coun&&i*pe[j]<=n;j++)// j 从 1 枚举到 coun 同时“i*pe[j]<=n ”保证了 is_pe[i*pe[j]]不会让超过 n 的数进去，以防越界和超时 
		{
			is_pe[i*pe[j]]=1;//把 i 的所有的质数倍倍数都标记为合数 
			
			if(i%pe[j]==0){break;} //线性筛最关键、最核心的地方 --> 如果 i 是pe[j]的倍数，就直接跳出循环，保证了每个数只会被（它的最小质因数）筛掉一次，避免了冗余，也保证了线性复杂度，具体证明我会在证明里详细展开 
		
		}
	}
	return;//记得写 return 养成好习惯（避免函数类型是整型（int、longlong）或其他类型时莫名 RE 还查不出错） 
}
int main()
{
	n=re,q=re;//输入 
	find_prime(n);//线性筛 
	while(q--)
	{
		int k;
		k=re;
		printf("%d\n",pe[k]);//输出第 k 个质数 
	}
	return 0;
}
```
//居然写了这么多注释（bushi）

算法介绍
---
题目名称已经很显然了，要求使用**线性筛（欧拉筛）**，（当然，卡常的埃氏筛也可以水过）。
讲一下欧拉筛:
它其实就类似埃氏筛的一个优化，即它**保证了一个数只会被筛掉一次**，以此得到**线性**的复杂度。
### 思路：
直接 $k$ 次循环暴力显然会超时，所以不妨把 $n$ 以内的所有质数**预处理**出来，然后 $q$ 次询问 $O(1)$ 的输出结果。观察数据范围，发现 $n$ 的范围很大，$O( n \sqrt{n} )$ 的暴力筛显然会超时，所以考虑**线性筛**。
## 代码解析
外层循环枚举 $i$ 从 $2$ 到 $n$，如果此时 $i$ 没被筛掉，**那么他就是一个质数**，直接**加入质数表**里。
如果 $i$ **没有被认定为合数**，那它**一定是一个质数**
然后内层枚举 $j$ 从 $1$ 到 $coun$（筛出的质数个数），也就是枚举**所有筛出的质数**，同时保证枚举范围不会越界。
```cpp
is_pe[i*pe[j]]=1
```
**上面的一行代码就是埃氏筛的思想的精髓——一个质数的倍数一定是一个合数，正确性显然。**（不会这也要证明吧...）
```cpp
if(i%pe[j]==0){break;}
```
这个的意思是如果 $i$ 是 $pe[j]$ 的**倍数**，那么此时 $pe[j]$ 就是 $i$ 的**最小质因子**，跳出循环，因为继续下去的话只会重复导致冗余，它的作用十分明显，见下面两条提交记录（看右上角的运行时间，快了三秒）


[加了](https://www.luogu.com.cn/record/215874530)


[没加](https://www.luogu.com.cn/record/215874631)


## 证明

### 复杂度证明：

#### 空间复杂度：

显然是 $O( n )$ 的。

#### 时间复杂度：

外层循环显然是 $O( n )$ 的，内层循环乍一眼可能会以为是嵌套的，但实际**当一个数被他的最小质因子筛掉后就不会被重复筛掉了**，所以也**只会进行 $n$ 次**，所以整体复杂度是 $O( n )$ 的，可以通过此题。

### 正确性证明：

假设数 $x$ 是**合数**，那么他一定可以表示成 $ k \times p $ 的形式，其中 $p$ 是 $x$ 的**最小质因子**，所以显然 $ p \le k $，**一定会在 $i$ 循环中被先扫到**并**把它的倍数也就是 $x$ 筛掉**，这样也就保证了**每个合数都被筛掉**。

## 结语

这是一道不错的模板题，它的思想对于其他类似问题很重要，**拓展性强**，能**变形**推出很多不同的算法和定理，**强烈建议**新手**深刻理解**并背下来。

日志：


2025/5/7/16:00完成，终于考完期中考试了。

2025/5/8/14/15打回第一次：“【中文标点符号】与【英文、数字、公式或汉字】或【汉字】与【汉字】之间不应添加多余空格。”

未完待续。

---

## 作者：溶金落梧桐 (赞：2)

### 解题思路

**实现思路**

1. **线性筛法（欧拉筛）**：
   - 线性筛法是一种高效的素数筛选算法，时间复杂度为 $O(n)$。
   - 它的核心思想是让每个合数只被它的最小质因子筛去，从而保证每个数只被筛一次。
2. **算法步骤**：
   - 初始化一个布尔数组 `st`，用于标记是否为合数。
   - 初始化一个数组 `prime`，用于存储素数。
   - 遍历每个数 $i$ 从 2 到 $n$：
     - 如果 $i$ 未被标记为合数，则 $i$ 是素数，加入 `prime` 数组。
     - 遍历当前已筛选出的素数 `prime[j]`，筛去合数 $i \times \text{prime}[j]$：
       - 如果 $i \times \text{prime}[j] > n$，则退出循环。
       - 标记 $i \times \text{prime}[j]$ 为合数。
       - 如果 $i$ 能被 `prime[j]` 整除，则退出循环（保证每个合数只被最小质因子筛去）。
3. **查询处理**：
   - 对于每次查询第 $k$ 个素数，直接输出 `prime[k]`。

**针对 java 的特殊优化**

> 快读：由于 Java 的读入比较慢，可以参考 [OI-Wiki Java 进阶部分](http://oi-wiki.com/lang/java-pro/#%E6%9B%B4%E9%AB%98%E9%80%9F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)。

> Bitset: 优化 Boolean 类型的数组。

> 优化素数存放数组大小 `int primeLimit = (int) (1.2 * n / Math.log(n)); // 素数数量上限`。

素数定理告诉我们，小于等于 $n$ 的素数数量大约为：
$$
\pi(n) \sim \frac{n}{\ln(n)}
$$

利用此定理，我们在欧拉筛函数中声明数组大小，可以有效减少空间复杂度，乘上 $1.2$ 是为了留出部分空间。

1. **时间复杂度**：
   - 欧拉筛的时间复杂度为 $O(n)$。
   - 每次查询的时间复杂度为 $O(1)$。

2. **空间复杂度**：
   - 使用 `BitSet` 存储合数标记，空间复杂度为 $O(\dfrac{n}{8})$。
   - 使用 `prime` 数组存储素数，空间复杂度为 $O(\dfrac{n}{\ln n})$。

### AC_Code

```java
import java.io.*;
import java.util.*;

public class Main {
    static int n, q;
    static int N = (int) (1e8 + 7);
    static int[] prime; // 存储素数的数组
    static int cnt = 0; // 素数个数
    static BitSet st; // 使用 BitSet 替代 boolean 数组

    // 欧拉筛函数：返回小于等于 n 的所有素数的个数
    static void eulerSieve(int n) {
        int primeLimit = (int) (1.2 * n / Math.log(n)); // 素数数量上限
        prime = new int[primeLimit]; // 动态调整 prime 数组大小
        st = new BitSet(n + 10); // 初始化 BitSet

        for (int i = 2; i <= n; i++) {
            if (!st.get(i)) {
                prime[++cnt] = i; // i 是素数，加入素数数组
            }
            // 筛去合数
            for (int j = 1; j <= cnt; j++) {
                if ((long) i * prime[j] > n) break; // 超出范围，退出
                st.set(i * prime[j], true); // 标记为合数
                if (i % prime[j] == 0) break; // 保证每个合数只被最小质因子筛去
            }
        }
    }

    static void solve() {
        n = in.nextInt();
        q = in.nextInt();
        eulerSieve(n);
        while (q-- > 0) {
            int k = in.nextInt();
            out.println(prime[k]);
        }
    }

    public static void main(String[] args) throws Exception {
        int zu = 1;
        while (zu-- > 0) {
            solve();
        }
        out.flush();
    }

    // 快读类
    static class FastReader {
        StringTokenizer st;
        BufferedReader br;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    static PrintWriter out = new PrintWriter(System.out);
    static FastReader in = new FastReader();
}
```

---

## 作者：haobao123456 (赞：1)

这题居然还要卡常，太离谱了！！！
# 思路：
使用欧拉筛（线性筛），欧拉筛其实就是在埃氏筛基础上在优化一下即可。

如果用 $5$ 个字来形象说明欧拉筛的核心思想那就是：排列变组合。

简单讲一下欧拉筛的思路：每次筛的时候都要在 $i$ 加上不超过 $i$ 的最小质因数的质数，那为什么这样能够保证每个数只能被筛一次，这里给出一个类似于证明但不像证明一样严谨的一个证明。

我们都知道，把一个数 $n$ 通过质因数分解，可以分解为：$n=p_1^{s_1} \times p_2^{s_2} \times ... \times p_m^{s_m}$，我们假设如果有一个数 $n$，他被筛了两次，第一次完全符合欧拉筛的条件，就是 $i$ 是 $n$ 的最大因数（不包括自身）和 $prime_j$ 是 $i$ 的最小质因数，然后第二次也满足，当然，跟第一次不一样，我们先不考虑第一次，那么他第二次的分解可以写成 $n=x_1 \times x_2$，其中 $x_1$ 必须得为质数，同时 $x_1$ 也要不超过 $x_2$ 的最小质因数，但是，我们都知道，所有的等式都可以拆解为质因数分解的式子，则 $x_1$ 必为若干个质因数相乘，与上述矛盾，所以我们可以证明，按照欧拉筛的方法，每个数只会被筛掉一次，而且当时的 $prime_j$ 必为 $n$ 的最小质因数，$i$ 为 $n$ 的最大因数（不包括自身）。

# 注意事项：
  这道题还需要卡常，用 `bitset` 当做判断数组，能够得到 $\frac{n}{64}$ 的优化。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int ll;
typedef pair<int,int> PII;
#define x first
#define y second
const int mod=1e9+7;
const int N=1e5+50;
#define endl '\n'
//#define int ll
#define IO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
bitset<100000050> vis;
int prime[5761605]={};
int tot=0;
int n,q;
void Euler_Sieve(int n){
	vis[1]=1;
	for(int i=2;i<=n;i++){
		if(vis[i]==0){
			prime[++tot]=i;
		}
		for(int j=1;j<=tot&&prime[j]*i<=n;j++){
			vis[prime[j]*i]=1;
              /*
                因为prime数组是单调递增的，如果prime[j]是i的最小质因数，那么就不能进行下一轮了，为什么？
                举个例子，比如说100他是被i=2*5*5(即50)在50左边添加上一个2的时候所干掉的，再比如说250,他不是被i=2*5*5(既50)在左边添加上5的时候
                所干掉的，他是被i=5*5*5(既125)在左边添加一个2的时候所干掉的，这样就能保证每个数只会被筛一次，而形成组合的方法是使序列单调不降，
                这跟欧拉筛的思想也一样，所以欧拉筛的核心就是:排列变组合
                */
			if(i%prime[j]==0){
				break;
			}
		}
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	IO;
	cin>>n>>q;
	Euler_Sieve(n);
	while(q--){
		int k;
		cin>>k;	
		cout<<prime[k]<<endl; //输出
	}
	return 0;
}
```

---

## 作者：Chase12345 (赞：0)

# 代码实现
这里先给出这道题的代码，即欧拉筛：
```cpp
#include <bits/stdc++.h>
using namespace std;

void quickio() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
}

const int maxn = 1e8 + 005;
vector<int> Prime;
bool vis[maxn];

void init(int n) {
	vis[1] = 1;
	for (int i = 2; i <= n; ++i) {
		if (vis[i] == 0)
			Prime.push_back(i);
		for (auto p : Prime) {
			if (i * p > n)
				break;
			vis[i * p] = 1;
			if (i % p == 0)
				break;
		}
	}
}

int main() {
	quickio();
	int n, q;
	cin >> n >> q;
	init(n);
	while (q--) {
		int x;
		cin >> x;
		cout << Prime[x - 1] << endl;
	}
	return 0;
}
```
# 正确性证明
我们首先应该先证明为什么这个代码能正确求出结果。

这里我们容易知道，每次筛出的必定都是合数。因为两个非一的正整数数乘积必定为合数。

其次，我们证明为何每个质数都会被正确筛出：
> 对于任意的合数 $c$，必定可以分解为 $c=p \times m$，其中 $p$ 为 $c$ 的最小质因数，则 $m \ge p$。外层遍历到 $i=m$ 时，内层循环会遍历出所有已经找到的质数 $p' \le m$。由于 $p$ 为 $c$ 的最小质因数，且 $p \le m$，所以 $p$ 必然已经在 `Prime` 数组中。

根据上面的证明，我们可以得到每个合数 $c$ 均只会被标记一次。且所有合数都会被正确筛出。且对于每个质数 $P$，仅能被 $1$ 和它本身整除，必定不会被其它的 $i <P$ 标记为合数。所以正确性证明完成。
# 复杂度分析
* 每个合数只被标记一次，因此标记操作总次数为 $O(n)$。
* 对于质数 $i$，内层循环次数为 $\pi (i) \approx \frac{i}{\ln i}$，所有质数的这部分总和约为 $O(\frac{n}{\ln n}) \times O(\ln n)=O(n)$。
  
那么总时间复杂度就是 $O(n)$。
而空间复杂度是 $O(n)$，这是显然的。
# Update:
复杂度分析板块有笔误，现在已经修改。

---


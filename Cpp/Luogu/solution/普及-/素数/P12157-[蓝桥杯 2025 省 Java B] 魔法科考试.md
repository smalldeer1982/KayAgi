# [蓝桥杯 2025 省 Java B] 魔法科考试

## 题目描述

小明正在参加魔法科的期末考试，考生需要根据给定的口诀组合出有效的魔法。其中，老师给定了 $n$ 个上半部分口诀 $a_1, a_2, \dots , a_n$ 和 $m$ 个下半部分口诀 $b_1, b_2, \dots , b_m$，均用整数表示。完整的口诀包含一个上半部分口诀和一个下半部分口诀，当选用两个口诀 $a_i$ 和 $b_j$，将组合出完整口诀 $S = a_i + b_j$。

当 $S$ 满足 $S \leq n + m$ 且 $S$ 为质数时，魔法是有效的。魔法的种类只和 $S$ 的大小有关。如果每个上半部分口诀和每个下半部分口诀在不同的组合中可以重复使用，小明想知道一共可能组合出多少种不同的有效魔法？

## 说明/提示

### 样例说明

可以组合出 $3,5,7$ 这三个有效魔法。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$n, m \leq 200$。
- 对于 $60\%$ 的评测用例，$n, m \leq 2000$。
- 对于 $100\%$ 的评测用例，$1\leq n, m \leq 20000$，$1\leq a_i, b_i \leq 20000$。

## 样例 #1

### 输入

```
3 4
2 3 10
3 4 5 1```

### 输出

```
3```

# 题解

## 作者：weizilong (赞：10)

# [题目传送门](https://www.luogu.com.cn/problem/P12157)
 ## 枚举
在做这道题时，我第一眼**枚举**，~~因为本题时限十分宽松~~，每次枚举 $$a_{i} + b_{j}$$ 的和 $S$，再判断 $S$ 是否符合条件（$S \leq n + m$ 且 $S$ 为质数）。

就这样我得了 [**40 分**](https://www.luogu.com.cn/record/213822063)，这是暴力的解法，相信大家都会暴力。
```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;
int n, m;
bool is_prime(int s){
    if (s <= 1) return 0;
    if (s == 2) return 1;
    if (s % 2 == 0) return 0;
    for (int i = 3; i * i <= s; i += 2) {
        if (s % i == 0) return 0;
    }
    return 1;
}

int main() {
    cin >> n >> m;
    
    vector<int> a(n),b(m);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    for (int i = 0; i < m; ++i) {
        cin >> b[i];
    }
    
    unordered_set<int> ans;
    
    for (int ai : a) {
        for (int bj : b) {
            int S = ai + bj;
            if (S <= m+n && is_prime(S)) {
                ans.insert(S);
            }
        }
    }
    
    cout << ans.size() << endl;
    
    return 0;
}

```
## 改进
~~但我 TLE 了~~，经过我仔细思考，每一次得到的  $S$ 都会判断一遍是不是素数；但  $S$ 可能会有重复，以至于我们重复判断一个数是不是素数，这会增加额外的时间开支，我们可以在程序开始前把所有可能的 $S$ 都判断一遍是不是素数（也就是**预处理**），这样可以减少时间开支；因为  $S \leq n + m$  所以 $S$  最大为  $n+m$。
## 埃氏筛法
我们通过**埃氏筛法**预处理素数，它是一种用于快速筛选所有小于给定数 $N$ 的质数的经典算法。埃氏筛法的核心思想是通过**逐步排除合数（非质数）来找到所有质数**，它的理论时间复杂度为 $O(N \log \log N)$。
### 示例

```cpp
vector<bool> sieve() { // 埃拉托斯特尼筛法（也称埃氏筛法）。
	vector<bool> is_prime(max_S + 1, true);
	is_prime[0] = is_prime[1] = false;
	for (int i = 2; i * i <= max_S; ++i) {
		if (is_prime[i]) {
			for (int j = i * i; j <= max_S; j += i) {
				is_prime[j] = false;
			}
		}
	}
	return is_prime;
}
```


## [就这样我 AC 了](https://www.luogu.com.cn/record/213921520)
以下是 AC 代码，完结撒花。
**(〃'▽'〃)**
```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;
int n,m;
int max_S;
vector<bool> sieve() {
	vector<bool> is_prime(max_S + 1, true);
	is_prime[0] = is_prime[1] = false;
	for (int i = 2; i * i <= max_S; ++i) {
		if (is_prime[i]) {
			for (int j = i * i; j <= max_S; j += i) {
				is_prime[j] = false;
			}
		}
	}
	return is_prime;
}

int main() {
	cin >> n >> m;
	max_S = n + m;
	
	vector<int> a(n),b(m); // 提前规划内存大小，便于直接访问。
	for (int i = 0; i < n; ++i) {
		cin >> a[i];
	}
	for (int i = 0; i < m; ++i) {
		cin >> b[i];
	}
	
	vector<bool> is_prime = sieve();
	/* unordered_set 与 set 比较，
       它在内部不会自动排序，降低时间复杂度。 */
	unordered_set<int> 	ans;
	
	for (int ai : a) {
		for (int bj : b) {
			int S = ai + bj;
            if (S <= max_S && is_prime[S]) {
                ans.insert(S);
            }
		}
	}
	
	cout << ans.size() << endl;
	
	return 0;
}
```
**_有错误请在评论区指出，谢谢。_**

---

## 作者：ddbjiang (赞：4)

## 思路
首先看数据范围 $s$、$n$、$m$ 在 20000 以内，所以至多 $n \times m$ 时间复杂度。需要预处理判断质数，将时间复杂度降为 $O(1)$。预处理范围为 $n + m$ 以内的数，因为后续需满足 $s \leq n + m$，更大的数无需处理。
### 简单质数筛
``` java
static boolean f(int x) {
    	if(x<=1)return false;
    	if(x==2)return true;
    	if(x%2==0)return false;
    	for(int i=3;i<=x/i;i+=2) {
    		if(x%i==0) {
    			return false;
    		}
    	}
    	return true;
    }
```
### 质数预处理
``` java
        int n=in.nextInt();
        int m=in.nextInt();
        boolean[]zs=new boolean[n+m+1];
        for(int i=0;i<=n+m;i++) {
        	zs[i]=f(i);
        }
```
## 算法过程
输入用两个 $set$ 集合存储数据，利用自动去重减少冗余计算。双重遍历集合，筛选满足 $s \leq n + m$ 且 $s$ 为质数的数，结果存入新 $set$，其大小即为有效魔法数量。

### 代码如下
``` java
        Set<Integer>set1=new HashSet<>();
        Set<Integer>set2=new HashSet<>();
        Set<Integer>set=new HashSet<>();
        for(int i=1;i<=n;i++) {
        	set1.add(in.nextInt());
        }
        for(int i=1;i<=m;i++) {
        	set2.add(in.nextInt());
        }
        for(int i:set1) {
        	for(int j:set2) {
        		int s=i+j;
        		if(s<=n+m&&zs[s]) {
        			set.add(s);
        		}
        	}
        }
```

## java完整代码如下（含快读快写模板）
```java
import java.io.*;
import java.util.*;
public class Main {
    static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
    public static void main(String[] args) throws Exception {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        Read in = new Read();
        int n=in.nextInt();
        int m=in.nextInt();
        boolean[]zs=new boolean[nm+1];
        for(int i=0;i<=n+m;i++) {
        	zs[i]=f(i);
        }
        Set<Integer>set1=new HashSet<>();
        Set<Integer>set2=new HashSet<>();
        Set<Integer>set=new HashSet<>();
        for(int i=1;i<=n;i++) {
        	set1.add(in.nextInt());
        }
        for(int i=1;i<=m;i++) {
        	set2.add(in.nextInt());
        }
        for(int i:set1) {
        	for(int j:set2) {
        		int s=i+j;
        		if(s<=n+m&&zs[s]) {
        			set.add(s);
        		}
        	}
        }
        pw.println(set.size());
        pw.flush();
    }
    static boolean f(int x) {
    	if(x<=1)return false;
    	if(x==2)return true;
    	if(x%2==0)return false;
    	for(int i=3;i<=x/i;i+=2) {
    		if(x%i==0) {
    			return false;
    		}
    	}
    	return true;
    }
    static LinkedList<Integer> path = new LinkedList<>();
    public static class Read {
        StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            st.nextToken();
            return (int) st.nval;
        }
        public long nextLong() throws IOException {
            st.nextToken();
            return (long) st.nval;
        }
        public double nextDouble() throws IOException {
            st.nextToken();
            return st.nval;
        }
        public String nextword() throws Exception{//读纯字母字符串
    		st.nextToken();
    		return st.sval;
    	}
    }
}

```

---

## 作者：Dicer_L (赞：3)

## solution

### 题意

给你两个数组，$a$ 数组有 $n$ 个数，$b$ 数组有 $m$ 个数，问从 $a$，$b$ 中分别任意取一个数，满足两者和既是质数又小于等于 $m+n$ 的和的个数有几个。

### 注意点

> 魔法的种类只和 $S$ 的大小有关。

意味着如果有多个不同数对和却相同并且满足条件，也只会被计算一次。

> 每个上半部分口诀和每个下半部分口诀在不同的组合中可以重复使用。

意味着只需不断枚举即可，无需考虑重复。

> $1\leq n, m \leq 20000$

数据较大，判断素数朴素算法肯定不行，要使用质数筛才能过，我的代码里用的是线性筛，复杂度为 $\mathcal{O(n+m)}$，可以自己找资料学习。至于判断是否有效，直接枚举两个数判断即可，复杂度为 $\mathcal{O(nm)}$，可以过。

### 思路

先把 $n+m$ 范围内的所有素数预处理出来。

然后开二维循环，不断枚举两个数，判断是否合规即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=20005;
int ans,n,m,a[N*2],ag[N],zn[N],k,b[N*2],w[N*2];
void cs(){
	a[0]=a[1]=1;
	for(int i=2;i<=n+m;i++){
		if(a[i]==0) b[k++]=i;
		for(int j=0;j<k&&i*b[j]<=n+m;j++){
			a[i*b[j]]=1;
			if(i%b[j]==0) break;
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	cs();
	for(int i=1;i<=n;i++) cin>>ag[i];
	for(int i=1;i<=m;i++) cin>>zn[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			k=ag[i]+zn[j];
			if(k<=m+n&&a[k]==0&&w[k]==0)
				ans++,w[k]=1;
		}	
	}
	cout<<ans;
}
```

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int maxNum = n + m;
        int[] a = new int[maxNum + 1];
        int[] b = new int[maxNum + 1];
        int[] w = new int[maxNum + 1];
        sieve(maxNum, a, b);
        int[] ag = new int[n + 1];
        int[] zn = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            ag[i] = sc.nextInt();
        }
        for (int i = 1; i <= m; i++) {
            zn[i] = sc.nextInt();
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int k = ag[i] + zn[j];
                if (k >= 0 && k <= maxNum && a[k] == 0 && w[k] == 0) {
                    ans++;
                    w[k] = 1;
                }
            }
        }
        
        System.out.println(ans);
        sc.close();
    }   
    private static void sieve(int maxNum, int[] a, int[] b) {
        a[2] = 1;
        int primeCount = 0;
        for (int i = 2; i <= maxNum; i++) {
            if (a[i] == 0) {
                b[primeCount++] = i;
            }
            for (int j = 0; j < primeCount && i * b[j] <= maxNum; j++) {
                a[i * b[j]] = 1;
                if (i % b[j] == 0) {
                    break;
                }
            }
        }
    }
}
```

跪谢管理。

---

## 作者：zhangzirui66 (赞：3)

本题时限比较宽松，可以使用暴力，基础暴力相信大家都能写出。

---

### [40 分代码：](https://www.luogu.com.cn/record/213478232)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a[100005], b[100005], ans;
map<int, int> mp;
bool prime(int x){
	if(x < 2) return 0;
	for(int i = 2; i * i <= x; i ++){
		if(x % i == 0) return 0;
	}
	return 1;
}
int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= m; i ++) cin >> b[i];
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			if(a[i] + b[j] <= n + m && prime(a[i] + b[j]) && !mp[a[i] + b[j]]){
				ans ++; mp[a[i] + b[j]] = 1;
			}
		}
	}
	cout << ans;
	return 0;
}
```
通过分析复杂度可知它是 $O(nm\sqrt{w})$ 的，$w$ 为值域，效率低下。

考虑解决瓶颈，即为素数判断，由于值域较小，可以直接预处理哪些数是素数。

于是我们得到了 65 分。

---

### [65 分代码：](https://www.luogu.com.cn/record/213478820)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a[100005], b[100005], p[4000005];
set<int> mp;
bool prime(int x){
	if(x < 2) return 0;
	for(int i = 2; i * i <= x; i ++){
		if(x % i == 0) return 0;
	}
	return 1;
}
int main(){
	for(int i = 0; i <= 100000; i ++){
		p[i] = prime(i);
	}
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= m; i ++) cin >> b[i];
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			if(a[i] + b[j] <= n + m && p[a[i] + b[j]]){
				mp.insert(a[i] + b[j]);
			}
		}
	}
	cout << mp.size();
	return 0;
}
```
这里我把 `map` 换成了 `set`，实际上只节省了一个常数，没有什么用。

复杂度小于 $O(nm\log w + w \sqrt{w})$，有了提升，但我们还可以去掉 log。

我们不使用 `set`，用回 `map`，由于值域较小，`map` 的离散化并没有必要，遂使用普通数组即可。

---

### [满分代码：](https://www.luogu.com.cn/record/213478928)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a[100005], b[100005], p[400005], vis[400005], ans;
bool prime(int x){
	if(x < 2) return 0;
	for(int i = 2; i * i <= x; i ++){
		if(x % i == 0) return 0;
	}
	return 1;
}
int main(){
	for(int i = 0; i <= 100000; i ++){
		p[i] = prime(i);
	}
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= m; i ++) cin >> b[i];
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			if(a[i] + b[j] <= n + m && p[a[i] + b[j]] && !vis[a[i] + b[j]]){
				ans ++;
				vis[a[i] + b[j]] = 1;
			}
		}
	}
	cout << ans;
	return 0;
}
```
复杂度小于 $O(nm + w \sqrt{w})$，完结撒花。

---

## 作者：prh_rpjiajia (赞：2)

## 解题步骤

### 1. 质数判断

直接对每个 $S$ 进行质数判断会超时，我们可以想到——用筛法，先用埃筛筛出质数。由于 $S$ 的最大可能值是 $n + m$，筛法的范围设成 $n + m$ 就行了。

### 2. 暴力遍历

暴力枚举，对于每一个 $a_i$ 和 $b_j$，计算 $S = a_i + b_j$，并检查。

### 3. 统计结果

使用一个标记数组记录已经出现过的 $S$，确保每个 $S$ 只被统计一次。

## 代码实现

既然是 Java 组，当然就要有 Java 代码啦。码风有一点点丑。

```java
import java.util.Scanner;

public class Main {
    static final int MAX = 40010; 
    static boolean[] P = new boolean[MAX]; 
    static boolean[] V = new boolean[MAX];

    static void sieve(int limit) {
        for (int i = 2; i <= limit; i++) {
            P[i] = true;
        }
        P[0] = P[1] = false;
        for (int i = 2; i * i <= limit; i++) {
            if (P[i]) {
                for (int j = i * i; j <= limit; j += i) {
                    P[j] = false;
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] a = new int[n];
        int[] b = new int[m];
        
        for (int i = 0; i < n; i++) a[i] = sc.nextInt();
        for (int i = 0; i < m; i++) b[i] = sc.nextInt();
        
        int limit = n + m;
        sieve(limit);
        
        int cnt = 0;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int s = a[i] + b[j];
                if (s <= limit && P[s] && !V[s]) {
                    V[s] = true;
                    cnt++;
                }
            }
        }
        
        System.out.println(cnt);
    }
}
```


## 检查一下复杂度

- 埃筛：时间复杂度 $O(n \log \log n)$，其中 $n$ 是筛法的上限 $n + m$。
- 暴力：时间复杂度 $O(n \times m)$，其中 $n$ 和 $m$ 最大为 $20000$，可以接受。
- 空间复杂度：$O(n + m)$，不会爆空间。

这题就被完美解决了，撒花！！！

---

## 作者：_seven_7k_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12157)
## 思路
~~首先，看到时间限制就知道这题不简单~~。
我们在这里要注意以下几个点，不注意会 TLE 或 WA。

1. 素数判定只需要判定这个数的算术平方根及以下的数是不是这个数的因数，这样更节省时间。
2. 我们要注意，这里的方案数指组成质数的个数，不是指方法数，所以我们要用一个数组来存储，判断是否重复出现同一个质数。（$1≤a_i,b_j≤20000$，可以存储）
3. 我们在判断时，要注意 $a_i+b_j≤n+m$。
4. 注意：每一次素数判定都需要花费一点时间，为了节省时间，我们要再开一个数组存储已经判定的数来节省时间。
5. ```if``` 判断是有顺序的（从左往右判断）所以素数判定放在最后，当前面不符时，会直接退出就不会再素数判定，节省时间。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[20001],b[20001],c[40001],d[40001];
int js(int x){//素数判定
	int i;
	if(d[x]==1){//如果这个数已经判定过，就无须再判定
		return false;
	}
	if(d[x]==2){//同理
		return true;
	}
	for(i=2;i*i<=x;i++){//开方判定，节省时间
		if(x%i==0){
			d[x]=1;//记录
			return false;
		}
	}
	d[x]=2;//记录
	return true;
}
int main(){
	int n,m;
	cin>>n>>m;
	int i,j;
	for(i=1;i<=n;i++){
		cin>>a[i];
	}
	for(i=1;i<=m;i++){
		cin>>b[i];
	}
	int s=n+m;
	int s2=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(c[a[i]+b[j]]==0  && a[i]+b[j]<=s && js(a[i]+b[j])){//注意顺序（第一个是判断素数是否出现过；第二个判断a[i]+a[j]<=n+m;第三个素数判定）
				s2++;
				c[a[i]+b[j]]=1;//记录当前素数已出现过
			}
		}
	}
	cout<<s2<<endl;
	return 0;//好习惯
}
```

---

## 作者：longyitongxue (赞：1)

如果你是去往题目的读者，请点击[此处](https://www.luogu.com.cn/problem/P12157)进入。
# 思路
这道题主要考察质数筛，先把质数筛出来，然后双重循环，枚举合法的个数就行了。注意，要判断魔法是否有重复，比如有两个合法的魔法 $7$，我们只需要累加一个。这道题的数据在 $2\times10^4$，且时限在 $3$ 秒，双重循环不会炸。

如何质数筛选呢？从 $2$ 开始筛选，把是 $2$ 的倍数的数都筛掉，这样 $2$ 的倍数的数就都不见了。接着重复循环，是质数的把它的倍数筛掉，已经筛掉的数（不是质数）就直接跳过（`continue`）。详见代码。

**温馨提示：这道题数据要开大一点，不然就会[听取 RE & WA 声一片](https://www.luogu.com.cn/record/215312136)！**

# [祖传代码](https://www.luogu.com.cn/record/215312248)
```cpp
#include<iostream>
using namespace std;
bool is_prime[40005],vis[40005];
int a[40005],b[40005];
int main(){
    for(int i=2;i<=40000;i++){
        if(is_prime[i]==0){//0 表示是质数（没有被筛选掉）
            for(int j=2;i*j<=40000;j++){
                is_prime[i*j]=1;//把其倍数筛选掉
            }
        }
    }
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=m;i++){
        cin>>b[i];
    }
    long long ans=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int s=a[i]+b[j];
            if(s<=n+m&&is_prime[s]==0&&!vis[s]){
                vis[s]=1;
                ans++;
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：ouxiyao (赞：1)

[传送门](https://www.luogu.com.cn/problem/P12157)   
时限很大，所以埃氏筛+桶就能过这题。 
也就是，先把素数筛出来，再枚举一遍，看一看是否符合题目要求：质数，和小于 $n+m$，无重复（千万要注意！）。  

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[41000],a[40010],b[40010],t[40010];
void shai(){//埃氏筛
	p[0] = p[1] = 1;
	for(int i = 2;i*i<=40000;i++)if(!p[i])for(int j = 2;i*j<=40000;j++)p[i*j] = 1;
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cout.tie(0);
	shai();
	int n,m,cnt = 0;
	cin>>n>>m;
	for(int i = 1;i<=n;i++)cin>>a[i];
	for(int i = 1;i<=m;i++)cin>>b[i];
	for(int i = 1;i<=n;i++)for(int j = 1;j<=m;j++)if(a[i]+b[j]<=n+m&&!p[a[i]+b[j]]&&!t[a[i]+b[j]])cnt++,t[a[i]+b[j]] = 1;//爆搜
	cout<<cnt;
	return 0;
}

```
时限三秒是种什么感受？测试点跑出 $1.12$ 秒都能过！

---

## 作者：lemoned_qwq (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12157)
# 题解：P12157
## 思路：
我们先使用埃拉托斯特尼筛法（Sieve of Eratosthenes）来预先筛选出从 $2$ 到 $n+m$ 范围内的所有质数。然后再遍历出上半部分口诀和下半部分口诀的所有可能组合再进行判断。

**埃拉托斯特尼筛法的基本思想**：先将所有大于等于 $2$ 的自然数都记为质数，然后从 $2$ 开始，再将每个质数的倍数记为合数，直到遍历完所有小于等于 $\sqrt{n+m}$ 的数。

## 代码：

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<bool> SOE(int limit) {
    vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i <= limit; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j <= limit; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return isPrime;
}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    vector<int> b(m);
    // 上半部分口诀
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    // 下半部分口诀
    for (int i = 0; i < m; ++i) {
        cin >> b[i];
    }
    // 生成质数表
    vector<bool> isPrime = SOE(n + m);
    // 记录合法的魔法组合
    vector<bool> is_valid(n + m + 1, false);
    int count = 0;
    // 遍历所有可能的组合
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            int s = a[i] + b[j];
            if (s <= n + m && isPrime[s] && !is_valid[s]) {
                is_valid[s] = true;
                count++;
            }
        }
    }
    std::cout << count << std::endl;
    return 0;
}
```
~~据说抄题解会被阿瓦达啃大瓜~~

---

## 作者：Noob_Oler (赞：0)

# 题解：P12157 [蓝桥杯 2025 省 Java B] 魔法科考试

读完题想都没想就打了一个质数筛。

由于题目说：当 $S$ 满足 $S\le n+m$ 且 $S$ 为质数时，魔法是有效的。

所以我们只需要判断 $a_i + b_j \le n + m$ 且 $f_{a_i + b_j} = 0$ 且 $ff_{a_i + b_j}$ 即可。

$f$ 数组是盘判断质数，$ff$ 数组是判断是否有重复。

## AC Code
```
#include <bits/stdc++.h>
using namespace std;
bool f[40005],ff[40005];
int a[40005],b[40005];
int main()
{
    f[0] = f[1] = 1;
	for(int i = 1; i * i <= 40000; i++)
	{
		if(f[i]) continue;
		for(int j = i * 2; j <= 40000; j += i) f[j] = 1;
	}
    int n,m,cnt = 0;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= m; i++) cin >> b[i];
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            if(a[i] + b[j] <= n + m && !f[a[i] + b[j]] && !ff[a[i] + b[j]]) cnt++,ff[a[i] + b[j]] = 1;
        }
    }
    cout << cnt;
    return 0;
}
```

---

## 作者：sherry_lover (赞：0)

# P12157 [蓝桥杯 2025 省 Java B] 魔法科考试 题解

[题目传送门](https://www.luogu.com.cn/problem/P12157)

本题根本不需要质数筛法。

发现 $1 \le a_i,b_i \le 20000$，所以我们可以开桶记录下所有的 $S$。然后枚举 $1$ 到 $n+m$ 中的所有数，判断该数是否存在并且为质数即可。

时间复杂度为枚举的 $O(nm)$，由于本题时限较大，可以通过。

Code:

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] a = new int[n + 1];
        int[] b = new int[m + 1];
        boolean[] vis = new boolean[40005];
        int ans = 0;

        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        for (int i = 1; i <= m; i++) {
            b[i] = scanner.nextInt();
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                vis[a[i] + b[j]] = true;
            }
        }

        for (int i = 2; i <= n + m; i++) {
            if (isPrime(i) && vis[i]) {
                ans++;
            }
        }

        System.out.println(ans);
    }

    private static boolean isPrime(int x) {
        if (x <= 1) {
            return false;
        }
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

---

## 作者：deng2013 (赞：0)

## 思路
这道题的难点就是我们会不会用[埃式筛](https://www.bilibili.com/video/BV11epre3E5K/?spm_id_from=333.337.search-card.all.click)判断 $s$ 是否是质数。

### 埃式筛
```cpp
vector<bool>  init(int N){
    vector<bool> isPrime(N+5,true);
    isPrime[0] = isPrime[1] = false;   
    for (int p = 2; p * p <= N; p++) {
        if (isPrime[p]) {
            for (int i = p * p; i <= N; i += p) {
                isPrime[i] = false;
            }
        }
    }
    return isPrime;
}
```
已经知道那些数是质数了，下面的就简单了，遍历每个 $a_i$ 和 $b_j$ 判断 $s$ 是否是质数和满不满足 $s \le n+m$，最后用 set 记录并**去重**，输出 set 的长度就行了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<bool>  init(int N){//埃式筛
    vector<bool> isPrime(N+5,true);
    isPrime[0] = isPrime[1] = false;   
    for (int p = 2; p * p <= N; p++) {
        if (isPrime[p]) {
            for (int i = p * p; i <= N; i += p) {
                isPrime[i] = false;
            }
        }
    }
    return isPrime;
}
int main(){
    int n,m;
    cin>>n>>m;
    vector<int> a(n),b(m);
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<m;i++) cin>>b[i];
    vector<bool> isprime=init(n+m);
    set<int> st;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(a[i]+b[j]<=n+m&&isprime[a[i]+b[j]]) st.insert(a[i]+b[j]);//判断。
        }
    }
    cout<<st.size();//st的长度。
    return 0;
}
```

---

## 作者：Doraeman (赞：0)

## 提示
观察时间限制，~~本题数据比较水~~，**时间复杂度为 $O(nm)$ 的代码可以通过。**  
本题的难点在于质数的判断，如果每次求出 $S$ 后都判断它是否为质数，那么这个代码会超时。
## 质数预处理
先来看看在循环里判断 $S$ 是否为质数的代码。

```cpp
bool prime(int x){
    if(x < 2) return 0;
    for(int i=2; i*i<=x; i++)
        if(x % i == 0)
            return 0;
    return 1;
}

for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++){
        int s = a[i] + b[j]; 
        if(prime(s))
            // ......
    }
```
运行发现，上述代码（每次循环都判断质数）会超时，那么我们可以**在 $n\times m$ 的循环开始之前，预处理每个可能会出现的 $S$。**

观察数据范围：$1\leqslant a_i,b_i\leqslant 2\times10^4$。  
即 $2\leqslant S=a_i+b_i\leqslant 4\times10^4$。
### 质数预处理 代码

```cpp
// 前面已经分析过 S 的最小、最大值
const int MINS = 2, MAXS = 4e4;

// 判断质数的函数  
bool prime(int x){
    if(x < 2) return 0;
    for(int i=2; i*i<=x; i++)
        if(x % i == 0)
            return 0;
    return 1;
}

// 预处理（main函数内）
bool p[MAXS+5];
for(int i=1; i<=S; i++)
    p[i] = prime(i);
```
在 $n\times m$ 的循环中，如果想要判断 $S$ 是否为质数，只需要写 ```if(p[S] == 1)```。  
这里的**判断语句的时间复杂度是 $O(1)$。**
## 剩余部分
我们已经处理完了代码最难的部分，接下来只需要设置一个数组 $magic$ 来记录每一种“有效魔法”。  
```magic[i]``` 表示 $i$ 是一种“有效魔法”。

此外，为了让代码更快，也可以用将 $a,b$ 两个数组从小到大排序，使它们单调不减。  
在循环中如果 $a_i+b_j>n+m$，又因为 $b_j\leqslant b_{j+1}$，所以没有必要判断 $a_i+b_{j+1}$ 的合法性，**其必然大于** $n+m$，**直接退出当前的内层循环**。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
// 经过分析  
const int MAXN = 2e4, MINS = 2, MAXS = 4e4;

int n, m, ans;
int a[MAXN+5], b[MAXN+5];
bool p[MAXS+5], magic[MAXS+5];

// 判断质数的函数  
bool prime(int x){
    if(x < 2) return 0;
    for(int i=2; i*i<=x; i++)
        if(x % i == 0)
            return 0;
    return 1;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    
    for(int i=MINS; i<=MAXS; i++)
		p[i] = prime(i);
    
    cin >> n >> m;
    for(int i=1; i<=n; i++)
        cin >> a[i];
    for(int i=1; i<=m; i++)
        cin >> b[i];
	
	// 加快速度  
	sort(a + 1, a + n + 1);
	sort(b + 1, b + m + 1);
	
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++){
        	int s = a[i] + b[j]; 
        	
        	// 不必继续检查，直接退出内层循环  
        	if(s > n + m) break;
        	
        	// “有效魔法”的两个条件 
            if(s <= n + m && p[s])
                magic[s] = 1;
        }

    for(int i=1; i<=MAXS; i++)
    	ans += magic[i];

    cout << ans;
}
```

---


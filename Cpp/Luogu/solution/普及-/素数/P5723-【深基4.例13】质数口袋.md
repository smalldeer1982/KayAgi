# 【深基4.例13】质数口袋

## 题目描述

小 A 有一个质数口袋，里面可以装各个质数。他从 $2$ 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。

口袋的负载量就是口袋里的所有数字之和。

但是口袋的承重量有限，装的质数的和不能超过 $L$。给出 $L$，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。

## 说明/提示

数据保证，$1 \le L \le {10}^5$。

## 样例 #1

### 输入

```
100```

### 输出

```
2
3
5
7
11
13
17
19
23
9```

## 样例 #2

### 输入

```
5```

### 输出

```
2
3
2```

## 样例 #3

### 输入

```
11```

### 输出

```
2
3
5
3```

# 题解

## 作者：封禁用户 (赞：111)

一道练习筛质数的练手题。

[请先AC此题](https://www.luogu.com.cn/problem/P3383)。

网上有很多关于筛素数的帖子、博文，可以自学一下。

思路：暴力枚举$1-n$的所有素数，如果当前$i$是素数并且$sum+i≤n$，则$sum+=i$，输出$i$，$x+1$。否则，就输出$x$。


$80$分$code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
long long sum=0;
int pd(int y) {
	for(int i=2; i*i<=y; ++i) {
		if(y%i==0) return 0;
	}
	return 1;
}
int main() {
	scanf("%d",&n);
	for(int i=2; i<=n; ++i) {
		if(i%2==0&&i!=2) continue;
		if(sum+i>n) {
			printf("%d\n",x);
			return 0;
		}
		if(pd(i)) {
			printf("%d\n",i);
			sum+=i;
			x++;
		}
	}
	return 0;
}
```

感谢[洛谷万岁](https://www.luogu.com.cn/user/95333)和[死神审判](https://www.luogu.com.cn/user/242984)指正蒟蒻的错误~

错因分析：上述代码$for$循环中，$i$最小为$2$。但是题目里没有保证$n≥2$，所以，当$n≤2$时会出现错误。

解决方法：加两个特判。

$AC$ $Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
long long sum=0;
int pd(int y) {
	for(int i=2; i*i<=y; ++i) {
		if(y%i==0) return 0;
	}
	return 1;
}
int main() {
	scanf("%d",&n);
	if(n<2) {
		printf("0\n");
		return 0;
	} else if(n==2) {
		printf("2\n1\n");
		return 0;
	}
	for(int i=2; i<=n; ++i) {
		if(i%2==0&&i!=2) continue;
		if(sum+i>n) {
			printf("%d\n",x);
			return 0;
		}
		if(pd(i)) {
			printf("%d\n",i);
			sum+=i;
			x++;
		}
	}
	return 0;
}
```


---

## 作者：Eason_AC (赞：54)

## Content
输入一个数$L(1\leqslant L\leqslant100000)$，判断最多能有多少个质数的和为$L$。输出这些质数，并输出最多个数（保证每个质数不重复）。

## Solution
这道题其实用暴力也可以解决。但是，一道质数筛的好题为什么不用质数筛去做呢？

这道题目主要是讲的埃氏筛法，它的核心思想是：**如果$n$是质数，那么$2n,3n,4n,...$这些$n$的倍数肯定都不是质数。**

其次，如果选的数要多，那么要选的每个数要尽可能小。

所以，一套流程就这么下来了：

- 用埃氏筛筛出$100000$以内的质数以备用。
- 输入完之后，从最小的质数开始，然后第$2$小，第$3$小……由小往大，只要是质数都取，一直取到和超过$L$为止。

时间复杂度$\Theta(n \log{\log{n}})$，当$n$取到最大的$100000$时，也就$\Theta(70000)$左右，足以通过本题。

## Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

bool prime[100007];
int l;

void ai() {
	for(int i = 2; i <= 100000; ++i)	prime[i] = 1;
	for(int i = 2; i <= 100000; ++i)
		if(prime[i])
			for(int j = i * 2; j <= 100000; j += i)
				prime[j] = 0;	
}

int main() {
	scanf("%d", &l);
	int p = l, sum = 0;
	ai();
	for(int i = 1; i <= p; ++i) {
		if(prime[i]) {
			printf("%d\n", i);
			p -= i;
			sum++;
		}
		if(p <= 0)	break;
	} 
	printf("%d", sum);
	return 0;
}
```

---

## 作者：StriveChild (赞：44)

其实也不难：要把算出来的东西放到数组里：少输出一位

### n == 1；n==0要特判

可以有下图的思路；
```cpp
while(sum <= n) 
{
	if(x是质数)
	    {
		    把质数放到数组的相应位置—> 重点！ 
			k++;//计数器++；
			sum += x//总和也要加上去；
		} 
}
		 
```
### 前面的那个数x==2也要特判；
#### 但总结起来：坑太多！
下面看代码，边看边讲解

```cpp
#include <iostream>
using namespace std;
int main()
{
	bool flag = true;//定义bool形变量：旗帜
	long long sum = 0;//定义总数和，初始化；
	long long n;//定义口袋大小
	long long k = 0;//定义计数器，初始化
	long long a[100000];//数组
	cin >> n;
	long long x = 2;//要判断的x从2开始
	if(n == 0 || n == 1)//n==0，n==1要特判
	    {
	    	cout << "0" << endl;
	    	return 0;
		}
	while(sum <= n)//循环开始！！
	    {
	    	if(x == 2)//当x==2时特判，否则输出不了
	    	    {
	    	    	sum += x;//sum的值往上加
	    	    	k++; //计数器k也要+1
	    	    	a[k] = x;//把这个2导进数组的a[1]为（k为1）
				}
				else//如果x不是2
					{
						flag = true;//旗帜需要初始化
                        
				    	for(int j = 2;j < x;j++)
                        //从2~x-1判断这时x是否为质数
				    	    {
				    	    	if(x % j == 0)flag = false;
                                //如果有了，旗帜倒下，代表不是
							}
						if(flag)//如果旗帜还是升起状态，x就是质数
						    {
                               //方法和判断2一样，不多讲
						    	sum += x;
						    	k++;
						    	a[k] = x;
							}
					}
			x++; //每次x都要加1，指导sum < n;
		}
	for(int i = 1;i < k;i++)
    //前面多了个2，如果不用数组，会多输出一个数字
	    {
	    	cout << a[i] << endl;
		}
	cout << k-1 << endl;//当然计数器里也要少一个
	return 0;//完美结束
}
```

---

## 作者：Ryo_Yamada (赞：38)

刚看到这题$L≤100000$时有点担心普通质数判断会不会T，于是保险起见用了埃筛。

整体思路是先用埃筛筛出$100000$以内的质数，然后循环：如果$L$能够就把$L$减去这个质数，输出这个质数，然后`cnt++`。（`cnt`记录质数个数）

`Code`：

```cpp
#include <cstring>
#include <iostream>
using namespace std;
int l;
bool prime[100000];
int cnt;
int main() {
    memset(prime, 1, sizeof(prime));//埃筛一定要初始化数组值
    cin >> l;
    prime[1] = 0;
    prime[0] = 0;
    for(int i=2; i<100000; i++) {
        if(prime[i]) {
            for(int j=i * 2; j<100000; j+=i) {
                prime[j] = 0;
            }
        }
    }//筛取质数
    for(int i=2; i<100000; i++) {
        if(prime[i]) {
            if(l >= i) {
                cout << i << endl;
                l -= i;
                cnt++;
            }//如果够，输出，l减去这个质数，cnt++
            else break;//不够就可以break
        }
    }
    cout << cnt;//最后输出cnt
    return 0;
}
```


---

## 作者：TRZ_2007 (赞：27)

# Solution  
其实看不懂大家为什么怕$n \le 10^5$的数据普通判断法会爆。  
其实$L = \sum \limits_{p_i \le L'} p_i,L' = L-p_i$，明显$p_{max}$按理说会小于$10^4$。而$10^4 \times \sqrt{10^4} = 10^6 < 10^8$，明显是可行的。（而且我用了$\Theta(\dfrac{\sqrt{n}}{3})$的算法）  

那么这题就成了：求在$i$等于几时，$L - \sum \limits_{i = 1} p_i$在自然数范围内取得最小值。  

暴力即可

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

namespace IO { //快读快输板子
	#pragma GCC target("avx")
	#pragma GCC optimize("Og")
	#pragma GCC optimize("Ofast")
	
	template<class T>
	inline void read(T& x) {
		x = 0;
		char ch = getchar();
		while(ch < '0' || ch > '9') {
			ch = getchar();
		}
		while(ch >= '0' && ch <= '9') {
			x = x * 10 + ch - '0';
			ch = getchar();
		}
	}
	
	template<class T>
	inline void write(const T& x) {
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
};

using namespace IO;

int L,cnt;

bool isprime(int x) { //判断素数
	if(x == 2 || x == 3) return 1;
	if(x < 2) return 0;
	if(x % 6 != 1 && x % 6 != 5) return 0;
	for(int i = 5;i*i <= x;i += 6) {
		if(x % i == 0 || x % (i + 2) == 0) return 0;
	}
	return 1;
}

int main() {
	read(L);
	for(int i = 2;i <= L;i++) {
		if(L - i < 0) {
			break;
		}
		if(isprime(i) && L - i >= 0) {
			L -= i;
			write(i);puts("");
			++cnt;
		}
	}
	write(cnt);puts(""); 
	return 0;
}
```

---

## 作者：Edmundino (赞：26)

# 题意

不得不说，这是一道好题

这其实有很多方法去求解

比如：打表，暴力等等

反正我是用了大家最喜欢的暴力

# 分析

我是在1-100000中枚举出所有的质数

然后存在一个数组里

接着我一个一个加上这些数

直到超过N为止

最后便输出

# 代码

```cpp
bool prime(int x)
{
     if(x<2) return 0;
     if(x==2) return 1;
     for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) return 0;
     return 1;
}

```
判断质数的函数

这是运用了数学知识

当一个数的因数中（除了1）没有小于等于这个数的算数平方根的时

这个数便是质数

最后送上完整Across代码

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<string>

using namespace std;

long long top,a[100050],n,s;

bool prime(int x)
{
     if(x<2) return 0;
     if(x==2) return 1;
     for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) return 0;
     return 1;
}

int main()
{
	cin>>n;
	for(int i=2;i<=100000;i++)
	{
		if(prime(i)==1)
		{
			a[++top]=i;
		}
	}
	int zs=0;
	for(int i=1;i<=top;i++)
	{
		if(s+a[i]>n)
		  break;
		s+=a[i];
		zs++;
	}
	for(int i=1;i<=zs;i++)
	{
		cout<<a[i]<<endl;
	}
	cout<<zs;
}
```


---

## 作者：Sea_Level (赞：23)

### 题意

给定和的范围，求最多有多少个从小到大且不重复的质数相加<=和的范围。

### 思路

~~暴力~~+优化，其实这样不会TLE，所以还是挺水的一道题。我用一个函数来做质数判断。


上代码！（具体注释在代码里）

------------

```cpp
#include<iostream>
#include<cmath>//要用sqrt函数
using namespace std;
int l,ans=0,cnt=1,sum=0,a[100010];//l是和的范围，ans是最多能装多少个质数，cnt是辅助a数组存入质数的计数器，a数组就是用来存质数的一个质数表。
int zhishu(int n){//判断是否是质数的函数。
	if(n==2||n==3||n==5||n==7||n==11||n==13){//判断，如果没有那么下面的优化就是错的，因为它会把上面的数全部算成合数。（实在看不懂可以自己举几个例子）
		return 1;
	}
	if(n%2==0||n%3==0||n%5==0||n%7==0||n%11==0||n%13==0||n==1){//优化，n=1也要return 0。
		return 0;
	}
	for(int i=2;i<=sqrt(n);i++){//判断，判断一个数是否是质数只要判断到它的开方就可以了。
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}
int main(){
	cin>>l;
	for(int i=1;;i++){//不用写i<=多少，到时候直接break就可以了。
		if(zhishu(i)==1){
			a[cnt]=i;//用cnt辅助存储质数
			sum+=i;//用和帮助判断是否越界
			ans++;//总质数数量++
			cnt++;//计数器++;
		}
		if(sum>l){//如果越界
			sum-=i;减掉使它越界的质数
			a[cnt]=0;//在质数表里删掉它
			cnt-=2;//这里一定要减2，因为cnt初始=1，当1加完了cnt就变成了2，2加完了cnt就变成了3，以此类推。实在没看懂的可以举几个例子。
			ans--;//总质数数量--
			break;//跳出
		}
	}
	for(int i=1;i<=cnt;i++){//打印质数表
		cout<<a[i]<<endl;
	}
	cout<<ans<<endl;//输出总质数数量
	return 0;//拜拜！
}
```


---

## 作者：GaryH (赞：18)

# 题解

其实此题应该加强数据。

## 1.题意

给定范围，求该范围内从小到大质数和亦不超过此范围的所有质数及其个数。

## 2.思路

在这里的正解应该是欧拉筛。欧拉筛是埃特里尼质数筛法的升级版，即避免了所有重复操作，并使时间复杂度达到了$O(n)$。至于具体讲解，请看[模板】线性筛素数 题解](https://www.luogu.com.cn/problemnew/solution/P3383)（侵权删），他们比我讲的好。

当然，此题还需要使用前缀和的思想，即用$cnt[i]$表示第$1$到第$i$个数的和。所以我们可以利用此方法存质数的前缀和并判断输出即可。

## 3.代码

```cpp
 #include<bits/stdc++.h>
 #define maxn 100001
using namespace std;
int isprime[100001],prime[100001],cnt[100001],m;
inline int get_list(){register int tot=0;
	for(register int i=2;i<=maxn;i++){
    	if(!isprime[i])prime[++tot]=i,cnt[tot]=cnt[tot-1]+i;//存质数并处理前缀和 
        for(register int j=1;j<=tot&&i*prime[j]<=maxn/*此处可修改并加快时间*/;j++){
        	isprime[i*prime[j]]=1;//处理质数表 
            if(i%prime[j]==0)break;//退出判断，因为下一个一定被筛过 
        }
    }
    return tot;//返回质数个数 
}
int main(){
	std::cin>>m;//输入 
	int ans=get_list(),/*生成表*/ans_final;
	for(int i=1;i<=ans;++i){
		if(cnt[i]>m)break;//退出 
		cout<<prime[i]<<'\n';
		ans_final=i;//存答案 
	}
	cout<<ans_final;//输出 
	return 0;
}
```
好了，题解结束了，大家再见！

---


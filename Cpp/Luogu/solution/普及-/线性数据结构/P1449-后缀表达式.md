# 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 $\texttt{+-*/}$。保证对于 $\texttt{/}$ 运算除数不为 0。特别地，其中 $\texttt{/}$ 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。


## 说明/提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3.5.2.-*7.+@```

### 输出

```
16```

## 样例 #2

### 输入

```
10.28.30./*7.-@```

### 输出

```
-7```

# 题解

## 作者：Imakf (赞：268)

### 题目分析

题目让我们读入后缀表达式，计算最后的答案，无视负数、小数、long long肯定不会爆

我们采用一种用数组**模拟栈**的方法

### 读入

```cpp
char op;
int now=0;
while((op=getchar())!='@'){
    if(op>='0'&&op<='9') now*=10,now+=op-'0';
    else if(op=='.'){
        stk[++i]=now;
        now=0;
        }
}
```
这是本蒟蒻的读入代码，读取数字，类似于手写的快读
比如读入12345

step1 0-->0-->1

step2 1-->10-->12

step3 12-->120-->123

step4 123-->1230-->1234

step5 1234-->12340-->12345

一旦读取的不是数字就把这个数字压入模拟栈

### 运算

```cpp
        else if(op=='+'){
            stk[i-1]=stk[i-1]+stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='-'){
            stk[i-1]=stk[i-1]-stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='*'){
            stk[i-1]=stk[i-1]*stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='/'){
            stk[i-1]=stk[i-1]/stk[i];
            stk[i]=0;
            i--;
        }
```
读到运算符就把栈顶上两个数做运算（做减法时减数和被减数要正确） 然后弹出栈顶两个元素 再将结果压入栈顶
# AC代码

```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    long long stk[1000];
    int main(){
    long long i=0,now=0;
    char op;
    while((op=getchar())!='@'){
        if(op>='0'&&op<='9') now*=10,now+=op-'0';
        else if(op=='.'){
            stk[++i]=now;
            now=0;
        }
        else if(op=='+'){
            stk[i-1]=stk[i-1]+stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='-'){
            stk[i-1]=stk[i-1]-stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='*'){
            stk[i-1]=stk[i-1]*stk[i];
            stk[i]=0;
            i--;
        }
        else if(op=='/'){
            stk[i-1]=stk[i-1]/stk[i];
            stk[i]=0;
            i--;
        }
    }
    cout<<stk[1];
    return 0;
}
```

---

## 作者：Enigmatic (赞：213)

时间O（n），空间O（n）

这一题可以直接在读的时候判

并不需要什么字符串

+和\*没有什么可说的

重点是-和/

是n[top-1]-n[top]

原因很简单，就是后缀表达式里的定义

```cpp
#include <bits/stdc++.h>
using namespace std;
stack<int> n;
char ch;
int s,x,y;
int main()
{
    while(ch!='@')
    {
        ch=getchar();
        switch(ch)
        {
            case '+':x=n.top();n.pop();y=n.top();n.pop();n.push(x+y);break;
            case '-':x=n.top();n.pop();y=n.top();n.pop();n.push(y-x);break;
            case '*':x=n.top();n.pop();y=n.top();n.pop();n.push(x*y);break;
            case '/':x=n.top();n.pop();y=n.top();n.pop();n.push(y/x);break;
            case '.':n.push(s);s=0;break;
            default :s=s*10+ch-'0';break;
        }
    }
    printf("%d\n",n.top());
    return 0;
}
```

---

## 作者：ZhangFuqun (赞：101)

### 在题解下逛了一圈，发现好像没有用 STL的 stack 。。于是蒟蒻我用stack试试，~~毕竟后缀表达式也才刚百度学会。。~~

### 斗胆发个题解 希望能过！



------------
### 自认为写的还是挺清楚明白的

```cpp

stack<int>q;
string c;

int main()
{
    cin>>c;
    int a=0,b=0;
    int i,j;
    for(int k=0;k<c.length();k++)
    {
    	if(c[k]=='@') break;
    	else if(c[k]=='.'){
    		q.push(a);
    		b=0,a=0;
		}
    	else if(c[k]<='9'&&c[k]>='0'){
    		a=b*10+c[k]-'0';
    		b=a;
		}
		else{

			if(c[k]=='-') i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j-i);
			if(c[k]=='+') i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j+i);
			if(c[k]=='*') i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j*i);
			if(c[k]=='/') i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j/i);
		}
	}
	cout<<q.top()<<endl;

}

```

---

## 作者：Scarlet_Lightning (赞：84)

## 此题是一道使用栈（stack）的裸题。。。
思路根[P1981表达式求值](https://www.luogu.org/problemnew/show/P1981)非常像。

### 重点：此题由于采用后缀表达方式，所以在读到运算符号时可以无条件运算，无需考虑优先级，比P1981简单！！！（也就是说不用符号栈）

**思路：先将整个表达式一起读入，接下来：**  
1. 如果碰到数字，将其放入临时数组当中，方便以后求数字
2. 如果碰到'.'，那么将临时数组中的字符串转化成数字（具体操作看程序注释），将其压入数字栈中
3. 如果碰到运算符号，那么将栈顶的两个元素取出做相应的运算（**注意：如果碰到-'或'/'应该用栈顶第二个元素减或除以栈顶元素！！！**）
4. 最后输出数字栈中剩余的最后一个元素即可

模拟（~~想抄代码的童鞋们可以跳过此部分~~）：

输入：3.18.56.+*@

碰到数字3，放入临时数组中：
```cpp
      stack    ccty：3|*|*|*|*|*|*|
栈顶->  空 
栈底->  空      read:3
```
接下来发现'.'，转化数字压入数字栈中：
```cpp
      stack    ccty：*|*|*|*|*|*|*|*
栈顶->   
栈底->  3      read:.
```
接下来碰到1，放入临时数组中：
```cpp
      stack    ccty：1|*|*|*|*|*|*|*
栈顶->   
栈底->  3      read:1
```
接下来快速模拟：
```cpp
      stack    ccty：1|8|*|*|*|*|*|*
栈顶->  18 
栈底->  3      read:8
```
```cpp
      stack    ccty：5|*|*|*|*|*|*|*
栈顶->  18 
栈底->  3      read:5
```
```cpp
      stack    ccty：5|6|*|*|*|*|*|*
栈顶->  56
	   18
栈底->  3      read:6
```
接下来读入加号。  
将数字栈栈顶两个元素相加并将和压回数字栈中：
```cpp
      stack    ccty：*|*|*|*|*|*|*|*
栈顶->  74     18+56=74
栈底->  3      read:+
```
同理：
```cpp
      stack    ccty：*|*|*|*|*|*|*|*
栈顶->         74*3=222  
栈底->  222    read:*
```
故最后答案等于222（~~好不吉利的数字~~）。

### 接下来请看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<cstring>
#define is ==//装b
#define isnot !=
using namespace std;
stack<int>num;//数字栈
int Num;
char Ch;
int num2;
char str[10001];//表达式
char ccty[21];//临时数组
int flag=0,i;//flag用来判断数字是否已读尽
int numa,numb;
int Makenum(){//将临时数组中的字符转化成数字的函数
	int ret=0;
	for(int i=0;i<=strlen(ccty)-1;++i){
		if(ccty[i]=='*')break;
		ret=ret*10+ccty[i]-'0';
		ccty[i]='*';//边转化边清空，省时间
	}
	return ret;//返回转化后的值
}
int main()
{
	cin>>str;//读入整个表达式
	char cha;//当前碰到的字符
	cha=str[0];
	int k=0;
	while(cha!='@'){//如果未发现结束符号，那么运行
		if(flag==0)i=0;
		if(cha>='0'&&cha<='9'){//如果是数字
			flag=1;
			ccty[i]=cha;//将它塞入临时数组中
			i++;
		}
		if(cha is '.'){//自己看上边的装b定义 
			flag=0;//数已读尽
			Num=Makenum();//转化成数字
			num.push(Num);//压入栈中
		}
		if((cha<'0'||cha>'9')&&cha isnot '.'){//装b*2
			numa=num.top();
			num.pop();
			numb=num.top();
			num.pop();//取出栈顶前两个数字
			if(cha=='+')num.push(numb+numa);//加和乘反不反无所谓
			if(cha=='-')num.push(numb-numa);//减和除就一定要反过来了
			if(cha=='*')num.push(numb*numa);
			if(cha=='/')num.push(numb/numa);
		}
		k++;
		cha=str[k];//读取下一个字符
	}
	cout<<num.top();//输出答案
}

```

### 题外话：这里是栈（stack）的class类代码（不想用STL的童鞋们可以参考）：

```cpp
/*说明：stk.push(n)表面上是将n压入stk中，实际上是将n
压入stk中包含的a数组内*/
template<typename T>class stack{
    T a[100001];
    int tail;
    public:
        void push(T n){//压入数据
            a[tail++]=n;
        }
        void pop(){//弹出栈顶元素
            tail--;
        }
        T top(){//返回栈顶元素
            return a[tail-1];
        }
        int size(){//返回栈内元素的个数
            return tail;
        }
        bool empty(){//判断栈是否为空
            return tail==0;
        }
};
用法：
stack<元素基类型> 类名;
如：
stack<char> stk//建立一个存储字符的名为stk的栈
stack<int> num//建立一个存储int整型的名为num的栈
stack<double> dou//同上
```

---

## 作者：tuqiang (赞：58)

## 这是一篇真正从零开始了解栈的c语言题解！！
### 各位小伙伴不需要辛苦地百度如何使用栈了
顺便啰嗦一下后缀表达式的计算方式，因为我也是百度的，也为了使题解更全面一点：后缀表达式的计算方式非常简单，遇到数字直接入栈，遇到运算符不入栈并将栈顶和栈顶下面一个两个数字出栈，先出的数在运算符右边，后出的在左边，进行运算，将运算结果入栈，直到最后栈中只剩下最后一个数，输出既是答案。
那么现在看看代码如何创建并使用一个栈，从零学习如何使用栈：
```c
#include<stdio.h>
#include<stdlib.h> 
#include<math.h>
typedef struct Node  //创建链表 
{
	int data;
	struct Node* next;
};
struct Node* createList()  //创建表头头节点，节点数据域为空 
{
	struct Node* headNode=(struct Node*)malloc(sizeof(struct Node));
	headNode->next = NULL;
	return headNode;
} 
struct Node* createNode(int data)  //动态创建新节点 
{
	struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));
	newNode->data=data;
	newNode->next = NULL;
	return newNode;
}
struct stack//创建栈顶节点
{
	struct Node* stackTop;  //用栈顶表示整个链表 
	int size;       //记录数据个数 
};
struct stack* createStack()//创建栈的结构体变量
{
	struct stack* mystack=(struct stack*)malloc(sizeof(struct stack));
	mystack->stackTop =NULL;
	mystack->size =0;
	return mystack;
}
void push(struct stack* mystack,int data)//入栈 
{
	struct Node* newNode=createNode(data);  //创建新节点 
	newNode->next =mystack->stackTop ;      //新节点的下一个指向当前栈顶 
	mystack->stackTop =newNode;             //把栈顶指向新节点 
	mystack->size++;                        //节点加一 
}
int top(struct stack* mystack)//获取栈顶元素
{
	if(mystack->size ==0)
	{
		return mystack->size ;   //返回栈的size为0 
	}
	return mystack->stackTop->data ;
} 
void pop(struct stack* mystack)//出栈
{
	if(mystack->size ==0)
	{
		return ;
	}
	else
	{
		struct Node* nextNode=mystack->stackTop->next; //创建新节点记录栈顶的下一个节点 
		free(mystack->stackTop );       //把栈顶节点释放 
		mystack->stackTop =nextNode;    //栈顶标记移到下一个
		mystack->size--; 
	}
} 
int empty(struct stack* mystack) //判断栈是否为空 
{
	if(mystack->size ==0)  
		return 0;         //为空返回0 
	return 1;             //不为空返回一 
}
int main()
{
	int i,j=0,k=0,tmp1=0,tmp2=0,count=0,num1[10],num2[10],tmp=0;
	char str;
	struct stack* mystack=createStack();
	do
	{
		scanf("%c",&str);	
		if(str!='*'&&str!='/'&&str!='+'&&str!='-'&&str!='@')
		{
			push(mystack,str);
		}
		else
		{
			do
			{
				if(top(mystack)=='.')
				{
					count++;
					if(count==3)
					{
						break;
					} 
				}	
				else
				{
					if(count<2)
					{
						num1[j]=top(mystack)-48;
						j++;	
					}	
					else
					{
						num2[k]=top(mystack)-48;
						k++;
					}
				}
				pop(mystack);	
			}while(empty(mystack));
			for(i=0;i<j;i++)
			{
				tmp1=tmp1+num1[i]*pow(10,i);
			}
			for(i=0;i<k;i++)
			{
				tmp2=tmp2+num2[i]*pow(10,i);
			}
			if(str=='*')
			{
				tmp=tmp1*tmp2;
			}
			if(str=='/')
			{
				tmp=tmp2/tmp1;
			}
			if(str=='+')
			{
				tmp=tmp1+tmp2;
			}
			if(str=='-')
			{
				tmp=tmp2-tmp1;
			}
			push(mystack,tmp+48);
			push(mystack,'.');		
			count=j=k=0;
			tmp1=0;
			tmp2=0;
		}		
	}while(str!='@');
	printf("%d",tmp);
} 
```看见这么长的代码感觉没多少人看得下去，我的栈是在B站一个叫莫影老师的up学的，用心看你就会发现数据结构的美丽，从定义结构，创建表头、栈顶代表链表和栈，到动态申请结构体变量（节点），再到插入，遍历，删除，打印等等，一步步往前推进，实现栈的功能，行云流水。
而主函数的实现就要靠你们自己运用栈来处理了，如果做到了也就说明开始学会用栈处理问题了，方法应该不少，所以就不讲我的思路，因为感觉比我好的很多，你们来看题解的也可以写出更好的。


---

## 作者：没有输入 (赞：40)

# 数据结构 · 栈

本题考查对数据结构·栈的认识。利用栈保存数字，在遇到运算符时取栈顶的两个元素进行运算后再放回栈顶即可。

读入方面，我没有做处理，而是放到后面，在运算的同时进行处理。
```cpp
gets(a);
```
数据处理。乘10的幂，将字符转换为十进制数，放入栈内。
```cpp
if(a[i]=='.')
{
	sum=0,k=1;
	for(int j=i-1;j>=0&&a[j]>='0'&&a[j]<='9';j--) sum=sum+(a[j]-48)*k,k*=10; 
	stk.push(sum);
	continue;
}
```
运算——遇到运算符时，取出栈顶元素进行运算。**注意：由于栈先进后出的特点，做除法要用第二次取出的元素去除以第一次取出的元素。**
```cpp
sum=stk.top();
stk.pop(); 
if(a[i]=='+') sum=stk.top()+sum;
if(a[i]=='-') sum=stk.top()-sum;
if(a[i]=='*') sum=stk.top()*sum;
if(a[i]=='/') sum=stk.top()/sum;
stk.pop();
stk.push(sum);
```
最后输出即可。

### 总结

摸清栈先进后出的特性，利用这一特性即可方便的计算后缀表达式。字符转数字时要着重处理。处理的方法很多，这里就不一一列举了。

## 标程
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1005];
int sum,k;
stack <int> stk;
int main()
{
	gets(a);
	for(int i=0;a[i]!='@';i++)
	{
		if(a[i]=='.')
		{
			sum=0,k=1;
			for(int j=i-1;j>=0&&a[j]>='0'&&a[j]<='9';j--) sum=sum+(a[j]-48)*k,k*=10; 
			stk.push(sum);
			continue;
		}
		if(a[i]>='0'&&a[i]<='9') continue;
		sum=stk.top();
		stk.pop(); 
		if(a[i]=='+') sum=stk.top()+sum;
		if(a[i]=='-') sum=stk.top()-sum;
		if(a[i]=='*') sum=stk.top()*sum;
		if(a[i]=='/') sum=stk.top()/sum;
		stk.pop();
		stk.push(sum);
	}
	printf("%d",stk.top());
	return 0;
}
```
我是[没有输入](https://www.luogu.org/space/show?uid=154344)，我们下次再见！

---

## 作者：Neil1110 (赞：27)

我是用了一个stack来实现

每次输入一个char，判断是否是数字，

如果是数字，就继续输入，直到不是数字了，把它整个压进去

（题中的数可能不止一位）

不需要判断'.'，因为只要不是数字就结束循环，然后再判断是否是运算符

如果是运算符，就弹出两个元素，运算之后压回去

（注意不要使用else if，因为最后一次输入的还没判断，同时，注意运算的顺序）

最后stack里只剩一个元素，输出即可

附上ac的代码：

```cpp

#include<iostream>
#include<stack>
using namespace std;
int main()
{
    char t;
    stack<int> s;
    while(cin>>t&&t!='@')
    {
        if(t>='0'&&t<='9')
        {
            int temp=t-'0';
            while(cin>>t&&t>='0'&&t<='9')
                temp=temp*10+t-'0';
            s.push(temp);
        }
        if(t=='+')
        {
            int a=s.top();
            s.pop();
            int b=s.top();
            s.pop();
            s.push(b+a);
        }
        if(t=='-')
        {
            int a=s.top();
            s.pop();
            int b=s.top();
            s.pop();
            s.push(b-a);
        }
        if(t=='/')
        {
            int a=s.top();
            s.pop();
            int b=s.top();
            s.pop();
            s.push(b/a);
        }
        if(t=='*')
        {
            int a=s.top();
            s.pop();
            int b=s.top();
            s.pop();
            s.push(b*a);
        }
    }
    cout<<s.top()<<endl;
    return 0;
} 

```

---

## 作者：kojoker (赞：19)

不会switch的小伙来和我一起强行尬if!!!

```cpp
#include<stack>
#include<iostream>
#include<cstdio>
using namespace std;
stack<int> n;
char c;
int s,x,y;
int main()
{
    while(c!='@')
    {
        c=getchar();
        if(c=='+'){x=n.top(); n.pop(); y=n.top(); n.pop(); n.push(x+y); }
        else
        {
            if(c=='-'){x=n.top(); n.pop(); y=n.top(); n.pop(); n.push(y-x); }
            else
            {
                if(c=='*'){x=n.top(); n.pop(); y=n.top(); n.pop(); n.push(x*y); }
                else
                {
                    if(c=='/'){x=n.top(); n.pop(); y=n.top(); n.pop(); n.push(y/x); }
                    else
                    {
                        if(c=='.'){n.push(s); s=0;}
                        else
                            s=s*10+c-'0';
                    }
                }
            }
        }
    }
    printf("%d",n.top());
    return 0;
}
```

---

## 作者：jklover (赞：16)

/\*
本题的一个难点在于读题，对样例的理解

一个注意事项是读入的数可能有多个数位 需进行处理

样例：

INPUT：3.5.2.-\*7.+@

OUTPUT：16

题目的意思是，严格从左到右读，读到的数就先放在那里，读到运算符号时 ，就用这个符号与最后两个数进行运算

并把运算结果放在原来那两个数的位置

那么很自然想到用栈来解决 对上述过程进行模拟

具体思路 细节 详见代码

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[1001];
int top=0;
void push(int s)//入栈 
{
    if(top>=1000)
        printf("Overflow!");//判断上溢 
    else num[++top]=s;//栈指针+1，放入运算数 
}
void pop(char p)
{
    int s1;//存放运算的结果 
    if(top<=0)//判断下溢 
        {
            printf("Underflow!");
            return;
        }
    switch(p)//运算，上面的第二个数和最上面的数进行运算 
    {
        case '+':s1=num[top-1]+num[top];break;
        case '-':s1=num[top-1]-num[top];break;
        case '*':s1=num[top-1]*num[top];break;
        case '/':s1=num[top-1]/num[top];break;
    }    
    top-=2;//弹出了两个数 
    push(s1);//把结果放回去 
}
int main()
{
    char p;//我们要读入的 
    int s=0;//存放目前数字，便于进栈 
    while(1)
    {
        p=getchar();//读入 
        if(p=='@')//是@就结束 
            break;
        else if(p>='0'&&p<='9')//是数字的话 ，由于有可能有多位数 
            {
                s*=10;//多了一位，前面的乘以10 
                s+=p-'0'+0;//加入这个数 
            }
        else if(p=='.')//一个数读完 
        {
            push(s);//把存放的数入栈 
            s=0;//累计器归0 
        }
        else 
        pop(p);//都不是，则说明一定是运算符号，进行计算 
    }
    printf("%d",num[top]);//这样栈中只剩1个数，即结果，输出即可 
    return 0;
}
```

---

## 作者：Error_Eric (赞：14)

### 前言（忙人自动跳过）：

不出所料，CSP2019成为了我的退役纪念赛（之一），为甚说是“之一”呢？因为在我写题解的今天，我又被召回，继续OI之旅。

为了（再次）熟悉洛谷的环境，我选择做了一道~~水~~题，结果发现自己已经蒻得无地自容了... ...

~~为了消磨时间~~，特写题解一篇，仅供参考。

### 正文：

**本题解优点：**
只需c++极其基础的代码水平，了解栈的作用，小学三年级的数学水平~~和很好的耐心~~就可以理解。

**本题解缺点：**
篇幅较长，~~有些地方有点智障~~

题目要求输入的字符串---然后改成数字。其实学过快读的人一眼就可以发现，这道题把朴素的快读模板代码稍稍修改就可以完成数字读入部分：

```cpp
while (1){
	scanf("%c",&c);
	if('0'<=c and c<='9'){
		tot=tot*10+c-'0'; 
	}
	else if(c=='.'){
		st[++top]=tot;
		tot=0;
	}
   ... ...
}

```
对于没有学过快读的同学，怎么理解这串读入代码呢？我们复习一下小学知识（以2345为例）：

| 数字 |2  | 3 | 4 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|数位  | 千位 | 百位 | 十位 | 个位 |
| 计数单位 | 千 | 百 | 十 | 一 |

这代表什么呢？千位上的1代表一个千，所以千位上的2代表2000，百位上的1代表一个百，所以百位上的3代表3000以此类推。

现在，我们输入了一个2，它现在在个位，于是用于保存这个数的变量tot就加上2.

然后，我们输入了一个3，那个2到了十位，也就是原来的2现在代表20，怎么办呢？我们把tot乘上10，再加上3，tot就变成了23.

接着，我们输入了4,那么2和3分别左移一位，也就是原来的23现在代表230.这还是把tot乘上10,再加上4就可以办到的事。

最后，我们用同样的方法将234左移一位，加上5，就完成了2345的输入。

~~（看不懂的人可以去读读小学）~~


现在解决了输入数字，我们可以进行进一步分析。

首先，后缀表达式是什么？这。。。[看看这个](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437?fromtitle=%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&fromid=6160580&fr=aladdin)

我们要对后缀表达式进行计算。以3．5．2．-*7．+@为例子：

|输入3.  |  3.|
| :----------- | :----------- |
| 输入5. | 3,5. |
| 输入2. | 3,5,2. |
| 输入- | 3,（5-2） |
| 输入* | 3*（5-2） |
| 输入7. | 3*（5-2），7 |
| 输入+ | 3*（5-2）+7 |

从其中不难看出，每输入一个运算符号，只会对最后两个数字产生影响，也就是将最后两个数通过这种运算变成一个数，这符合栈的特点。想到了栈，再进行分析，就不难发现，这其实是一道水题，伪代码如下：

>for(;;){
>
>	输入一个字符
 >   
 >  如果是数字：按照处理数字的方法处理
 
 >  如果是‘.’：压入栈
 
 >  如果是运算符号：弹出栈，弹出栈，将两个弹出的数进行相应的运算之后压入栈
 
 >	如果是‘@’：终止
 		   
>}

然后就可以开始写代码咯！

```cpp
#include"iostream"
#include"algorithm"
#include"stdio.h"
using namespace std;
#define maxn 1000+5
int st[maxn];int top=0;//数组模拟栈 
void scanff(){
	char c; int tot=0;
	while(1){//一直进行直到有'@' 
		scanf("%c",&c);//输入 
		if('0'<=c and c<='9'){//是数字 
			tot=tot*10+c-'0'; 
		}
		else if(c=='.'){//是'.' 
			st[++top]=tot;//压入栈 
			tot=0;		  //##重点##清零 
		}	
		else if (c==10) continue;//屏蔽回车干扰 
		else{					 //是运算符号 
			int t;				 //下一个要被压入栈的元素 
			switch (c){			 //以下内容极其容易理解 
				case '+' :
					t=st[top-1]+st[top];break;
				case '-' :
					t=st[top-1]-st[top];break;//##重点##注意顺序 
				case '*' :
					t=st[top-1]*st[top];break;
				case '/' :
					t=st[top-1]/st[top];break;//##重点##注意顺序 
				case '@' :return ;
				default :break;
			}
			st[--top]=t;//弹出了两个元素后压入一个元素，所以用--top 
		}
	}
	return ;
}
int main(){
	scanff();//容易理解 
	printf("%d\n",st[1]);//最后应当只留下了st[1]。 
	return 0;//世界终结 
}
```


---

## 作者：ACgod (赞：10)

老师拿来作普及模拟题T2，结果在考场中还是打出了正解……

这题其实十分简单，首先，我们要明白后缀表达式的含义。所谓后缀表达式，就是将算式树按照左根右的顺序访问写出来的，同理，我们还有前缀表达式和中序表达式。对于这种表达式求值的题目，一般情况下我们采用的都是栈的方法，中序表达式需要符号栈和数字栈，而这种后序表达式只需要数字栈就够了（这就是后缀表达式的优点）。我们读入一个运算符，就在栈顶取出两个元素进行运算，最后输出栈低元素就好了。

下面上代码，为了给某些不了解STL的人看，代码未写STL。

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;
char a[2001];
int stack_num[10001],top;//栈和栈顶
int main()
{
//	freopen("result.in","r",stdin);
//	freopen("result.out","w",stdout);
    cin>>a;、、读入
    for(int i=0;i<strlen(a);i++)
    {
      if(a[i]=='@')
      {
         break;
      }
      else if(a[i]=='+')
      {
          stack_num[top-1]+=stack_num[top];
          top--;
//	      cout<<a[i]<<" "<<stack_num[top]<<endl;
      }
      else if(a[i]=='-')
      {
        stack_num[top-1]-=stack_num[top];
        top--;
//	    cout<<a[i]<<" "<<stack_num[top]<<endl;
      }
      else if(a[i]=='*')
      {
        stack_num[top-1]*=stack_num[top];
        top--;
//	    cout<<a[i]<<" "<<stack_num[top]<<endl;
      }
      else if(a[i]=='/')
      {
        stack_num[top-1]/=stack_num[top];
        top--;
//	    cout<<a[i]<<" "<<stack_num[top]<<endl;
      }
      else{//转换成数字
            int sum=0;
            while(a[i]!='.')
            {
              sum=sum*10+a[i]-'0';
              i++;
            }
            stack_num[top+1]=sum;
//			cout<<sum<<endl;
            top++;
      }
    }
    cout<<stack_num[1];//输出栈底
}
```

---

## 作者：lamboo (赞：6)

题目分析：

本题输入的是后缀表达式

后缀表达式的特点是——不用考虑运算符的优先级

遇到运算符就运算

所以，我们很容易就想到了算法——栈


算法分析：

栈特点——先进后出

本题可以使用栈来解决

遇到数字就入栈

遇到符号就出栈、并运算

再把运算后的结果入栈


程序解说


```cpp
var s:string;
    w,x,i:longint;
    a:array[1..100000] of longint;  //a数组保存取出来的数据
begin
readln(s);
for i:=1 to length(s) do
  begin
  if s[i] in ['0'..'9'] then x:=x*10+ord(s[i])-48;  //保存数字
  if (s[i]='.') and (s[i-1] in ['0'..'9']) then  //取出数字
    begin
    w:=w+1;  //入栈
    a[w]:=x;
    x:=0;  //注意，此句不能落下，清空之前保存的数字
    end;
  if s[i] in ['+','-','*','/'] then
    begin
    w:=w-1;  //出栈
    case s[i] of  //运算
      '+':a[w]:=a[w]+a[w+1];
      '-':a[w]:=a[w]-a[w+1];
      '*':a[w]:=a[w]*a[w+1];
      '/':a[w]:=a[w] div a[w+1];
    end;
    end;
  end;
writeln(a[1]);
end.
备注：这题数据有点小，我用string就过了，本来按照规模应该用ansistring
```

---

## 作者：Caicz (赞：5)

#### 这是一道关于栈和字符串的模拟题
#### 可用数组模拟栈，也可以用STL大法好
#### 话不多说，上代码
```c
#include<bits/stdc++.h>
using namespace std;
stack<long long>s;//俗话说的好‘十年OI一场空，不开long long见祖宗’
string a;
long long x=0,ans=0;

int main()
{
	getline(cin,a);
	for(int i=0;i<a.size();i++)//因为最后一个字符不读入，直接无视。
	{
		if(a[i]>='0'&&a[i]<='9')//将字符转换为数字，x为转换器。
		{
			x=x*10+a[i]-'0';
		}
		else if(a[i]=='.')//数字终止，加入栈
		{
			s.push(x);
			x=0;
		}
        //若遇到运算符，进行运算。
		else if(a[i]=='*')
		{
			ans=s.top();
			s.pop();
			ans*=s.top();
			s.pop();
			s.push(ans);
		}
		else if(a[i]=='+')
		{
			ans=s.top();
			s.pop();
			ans+=s.top();
			s.pop();
			s.push(ans);
		}
		else if(a[i]=='-')
		{
			ans=s.top();
			s.pop();
			ans=s.top()-ans;
			s.pop();
			s.push(ans);
		}
		else if(a[i]=='/')
		{
			ans=s.top();
			s.pop();
			ans=s.top()/ans;
			s.pop();
			s.push(ans);
		}
	}
	cout<<ans;//打出栈中最后剩下的值
	return 0;
}

```


---

## 作者：HoshinoTented (赞：5)

# 很开心
你谷自从加入了 `Haskell` 和 `Kotlin` 的评测之后  
星野就一直用这两种语言刷 ~~辣鸡~~ 题目  
虽然这道题很简单, 但是星野是第一次用 `Haskell` 写这种题目  
所以很开心

# [题解 (Kotlin)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P1449.kt)
```kotlin
import java.util.Stack		//十分正常的导入 栈 类

const val SEPARATOR = '.'	//分隔符

//入口函数
fun main() {
	readLine()?.dropLast(1)?.let { formula ->		//把读入一行的内容去掉最后一个字符后命名为 formula
		Stack<Int>().let { s ->			//实例化一个栈, 命名为 s
			var it = 0	//下标
			fun current() : Char = formula[it]		//当前字符, 其实可以直接inline到代码里, 但是为了简单易懂还是写了个函数
			fun next() {		//下标加一
				++ it
			}

			//读取完整的数字, 调用后 current() 应是 SEPARATOR
			fun readFullNumber() : Int = buildString {
				while (current() != SEPARATOR) {
					append(current())
					next()
				}
			}.toInt()

			//开始求值
			while (it != formula.length) {
				when {
                	//如果当前字符是数字, 则读取完整的字符并推到栈里
					current().isDigit() -> s.push(readFullNumber())
                    //如果不是, 则根据对应的操作符执行对应的操作
					else -> {
                    	//根据操作符获取对应的函数
						val f : Int.(Int) -> Int = when (current()) {
							'+' -> Int::plus
							'-' -> Int::minus
							'*' -> Int::times
							'/' -> Int::div

							else -> TODO()
						}
						
                        //执行函数并将结果推到栈里
						s.pop().let { a ->
							s.pop().f(a).run(s::push)
						}
					}
				}

				//迭代器加一
				next()
			}

			//输出结果
			println(s.peek())
		}
	}
}
```
# [题解(Haskell)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P1449.hs)
```haskell
-- module LuoGu.P1449 where

-- 读取完整的数字 :: 需要读取的字符串 -> 已经读取到的数字字符串 -> 返回: (数字, 剩余的字符串)
readFullNumber' :: String -> String -> (Int, String)
-- 如果当前字符是分隔符, 则将数字字符串转化为数字, 并将其与剩余的字符串作为返回值返回
readFullNumber' ('.':xs) s = (read s, xs)
-- 将当前数字字符转化为字符串添加到 s 尾部, 继续读取剩下的数字
readFullNumber' (x:xs) s = readFullNumber' xs (s ++ [x])

-- 中转函数, 作用与 readFullNumber' 相同
readFullNumber :: String -> (Int, String)
readFullNumber = flip readFullNumber'  ""

-- 对后缀字符串求值 :: 栈 -> 需要求值的算式 -> 返回: 求值结果
eval :: [Int] -> String -> Int
-- 如果没有需要求值的算式, 则返回栈顶(结果)
eval (a:s) [] = a
-- 根据对应的操作符执行操作, 推到栈顶, 并继续求值
eval (a:b:s) ('+':xs) = eval (b + a : s) xs
eval (a:b:s) ('-':xs) = eval (b - a : s) xs
eval (a:b:s) ('*':xs) = eval (b * a : s) xs
eval (a:b:s) ('/':xs) = eval (b `div` a : s) xs
-- 如果是数字, 则读完整的数字, 并将剩下的字符串继续求值
eval s xs = eval (number : s) str
  where
    fullNumber = readFullNumber xs
    number = fst fullNumber
    str = snd fullNumber
  
-- 入口函数
main :: IO ()
main = do
  -- 读取输入
  s <- getLine

  -- 输出算式结果, (take (length s -1)) 是为了丢掉最后一个字符
  print $ eval [] (take (length s - 1) s)
```
# 结尾
[`C++题解`](https://github.com/HoshinoTented/LuoGu/blob/master/src/P1449.hpp)?  
有了 `Kotlin` 和 `Haskell` 这两大神器还要 `C++` 干什么  

# 真香
`C++题解` 是你谷还没出 `Kotlin` 和 `Haskell` 评测的时候写的。。。  
用了很麻烦的方法, 写了 Parser 什么的。。。  
感觉这么麻烦肯定审核不过, 所以就直接把 `C++题解` 扔了。。  
~~反正辣鸡C++也没什么好的, 扔了就扔了~~

---

## 作者：Starlight237 (赞：4)

# 二叉树大法好！！！
## 二叉树大法好！！！
### 二叉树大法好！！！
这是一道栈的经典题，然而我并不想用栈。比起栈来说，万能的表达式树的概念就清晰、简洁多了。

我们用根节点表示运算符，子节点表示运算数，最后的结果当然就是子节点对运算符的一次运算啦$QAQ$（当然需要递归一层一层往上运算）。

前缀表达式的建树方法很简单，我们知道前缀表达式是运算符+操作数1+操作数2，直接顺序建树就行了。而后缀表达式则是操作数1+操作数2+运算符。。。一开始我以为要倒着从下往上建树，还真吓了一跳，于是在网上荡了荡，发现建树方法都要用到栈。。。还不如直接用栈呢。

$But$，事实真的是这样吗？

其实我们发现，后缀表达式直接倒过来，就可以作为前缀表达式来处理了。倒过来是运算符+操作数2+操作数1，那么在前缀表达式的基础上，我们只需要改变一下左右节点的建树次序（当然在运算时处理也可以，这里先不讲，有时间我把表达式树的相关内容写到博客里）就行了！！！

那么我们得到如下AC代码：
```cpp
#include <bits/stdc++.h>
#define dig(d) ((d)>-1)//下文讲
using namespace std;
struct Tree{//经典二叉树
	int left,right;
}tree[10010];//用作表达式树，省去了指针，所以用数组下标代替了。
int ii=-1,ss[10010];
inline int build(int x){//建树
	++ii;
	if(!dig(ss[x]))//运算符，处理
		tree[x].right=build(ii+1),//交换左右子树的处理次序。即先处理右子树，再处理左子树。
		tree[x].left=build(ii+1);
	return x;//最底层操作数
}
inline int calc(int x){//运算
	if(dig(ss[x]))return ss[x];
	switch(-ss[x]){
		case '+':return calc(tree[x].left)+calc(tree[x].right);
		case '-':return calc(tree[x].left)-calc(tree[x].right);
		case '*':return calc(tree[x].left)*calc(tree[x].right);
		case '/':return calc(tree[x].left)/calc(tree[x].right);
	}
}
int main(){
	int index=-1,now=0;char ch; 
	while((ch=getchar())!='@'){
		if(isdigit(ch))now=(now<<1)+(now<<3)+(ch^48);
		else if(ch!='.')ss[++index]=now=-ch,now=0;//我用的是int类型数组，为了恰当地区分运算符和操作数，利用了题目中操作数不为负的特点，将运算符的ASCLL值取负存入数组。
		else ss[++index]=now,now=0;
	}
	reverse(ss,ss+index+1);//后缀->近似前缀
	build(0),cout<<calc(0);
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

萌新小白刚学栈$QwQ$。

一本通[双倍经验](http://ybt.ssoier.cn:8088/problem_show.php?pid=1331)

（~~问题是我一本通才$10$分~~

我的思路：

首先，读入字符串$a$（也就是后缀表达式）。

其次，从左到右遍历$a$。如果$a_i$不是数字，就判断（$switch$）。
如果$a_i$是‘$+$’‘$-$’‘$*$’‘$/$’，计算，将计算结果压入栈。

如果$a_i$是‘$.$’，说明这个数字已经结尾了，所以，打断。

如果$a_i$是$@$，那就输出栈顶元素鸭。

否则，将$a_i$转换成整型数字。

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int> s;
string a;
int x=0,y;
int main() {
	getline(cin,a);
	for(int i=0; i<a.length(); i++) {
		switch(a[i]) {
			case '+':
				y=s.top();
				s.pop();
				s.top()+=y;
				break;
			case '-':
				y=s.top();
				s.pop();
				s.top()-=y;
				break;
			case '*':
				y=s.top();
				s.pop();
				s.top()*=y;
				break;
			case '/':
				y=s.top();
				s.pop();
				s.top()/=y;
				break;
			case '.':
				s.push(x);
				x=0;
				break;
			case '@':
				printf("%d\n",s.top());
			default:
				x=x*10;
				x+=a[i]-'0';
		}
	}
	return 0;
}
```

//求各位做过路过帮我康康代码

---

## 作者：jx2014wzd (赞：3)

#### 背景：
点进题目一看，本蒟蒻突然想到了格式化读入+后缀转中缀+中缀直接计算。不错，是一道很好的练习二分的题。可是，~~习惯性地~~翻开题解，居然没有人这么做！好像。。。好像这方法是繁了些。。。效率一定很差。。。
结果：**12ms /  540.00KB /  2.43KB**。。。
于是，我打算发发这种方法。。。
#### 思路
**后缀转中缀**

中缀转后缀(参见P1175)，我们需要将运算符后移并去除括号。**而后缀转中缀**，~~这东西很少用到~~，**我们只需要改变符号顺序并加一些括号即可**,相当于恢复括号和运算符顺序。

我们可以让程序从前往后遍历，每遇到一个数字，将其压入栈中。遇到操作符则拿栈顶的两个元素加括号并加上运算符后压入栈中。

这里拿题目的测试数据二作为例子：

第二组测试数据：10.28.30./*7.-@

1. 没有遇到操作符，循环依次将10、28、30入栈。

2. 遇到操作符'/',将栈顶28、30出栈，格式化为(28/30),将其入栈

3. 遇到操作符'×',将10和(28/30)出栈，格式化为(10*(28/30)),将其入栈

4. 遇到数字7,将其入栈

5. 遇到操作符'-',将(10*(28/30))和7出栈，格式化，将其入栈

6. 遇到'@'，转换结束，取栈顶元素，得到((10*(28/30))-7)

**code:**
```cpp
inline string postfix_to_infix(char* s)
//后缀转中缀(postfix & infix transformation) 
{
	string a,b;
	stack<string> stk; 
	char rtstr[22];
        //注意这里必须为数组而不是指针(Note:Must be array instead of pointer) 
	for(int i = 0;s[i]!='@'&&s[i]!='\0'; i++)
	{
		if(s[i] >= '0' && s[i] <= '9')
                //获取数字(Judging decimal numbers)
		{
			memset(rtstr,0,sizeof(rtstr));
			long long num=0;
			for(;s[i]!='.' && s[i]!='\0' && s[i]!='@';++num,++i)
				if(s[i] >= '0' && s[i] <= '9')
					rtstr[num]=s[i];
			stk.push(rtstr);
		}
		else
                //遇到运算符处理(operator handling)
		{
			if(s[i]!='+' && s[i]!='-' && s[i]!='*' && s[i]!='/')
				continue;
			a = stk.top(); stk.pop(); b = stk.top(); stk.pop();
			switch(s[i])
			{//乘除法也要加括号(Multiplication & division also need parentheses) 
				case '+': stk.push("("+b+"+"+a+")"); break;
				case '-': stk.push("("+b+"-"+a+")"); break;
				case '*': stk.push("("+b+"*"+a+")"); break;
				case '/': stk.push("("+b+"/"+a+")"); break;
			}
		}
	}
	return stk.top();
}
```

**中缀计算：**

想想看，我们一般是怎么计算一个带有括号的表达式的？用完因式分解等方便运算但对于机器不影响的方法外，我们往往先计算带有最多括号的一项，括号中，我们往往先计算×与/再计算+与-，因为*/的优先级比加法高。可见，我们只需要找到一个优先级最高的运算位置再计算，即可。所以，一个显而易见的方法是采用二分，一步步把优先级最高的式子计算出来即可。

为找到优先级最高的运算符，我们可以递归将式子多次分成两半后遍历，在括号内的运算符加一个较大的权值，各个运算符各自加上自己的权值，取最大数所在的位置计算即可。

**code:**
```cpp
inline long long calc(const char *str, const int l, const int r, const int maxOper = 1000)
//二分计算中缀表达式的值(Value of infix expression in dichotomy)
{
    long long prio = 0, mnpos = 0, mn = LLONG_MAX, cnt = 0, p[r+1],num = 0;
    memset(p, 1, sizeof(p));
    for(long long i = r; i >= l; i--)
    { //计算运算符优先级(Computing symbol priority)
        if(str[i] == ')')prio += maxOper*2+1;
        if(str[i] == '(')prio -= maxOper*2+1;
        if(str[i] == '/')p[i] = prio + 2, cnt++;
        if(str[i] == '*')p[i] = prio + 2, cnt++;
        if(str[i] == '+')p[i] = prio + 1, cnt++;
        if(str[i] == '-')p[i] = prio + 1, cnt++;
        if(mn > p[i])mn = p[i], mnpos = i;
        //寻找优先级最低的运算符，记得括号要回溯
		//(Locate on the symbol with the lowest priority，remember to recall)
    }
    if(!cnt)
    {//区间内没有运算符(Don't have operators)
		//获取数字(Judging decimal numbers)
        for(long long i = l; i <= r; i++)
            if(str[i]>='0' && str[i]<='9')
				num = num * 10 + str[i] - '0';
        return num;
    }
    else
    {//否则处理运算符(Deal with operator)
    	long long na=calc(str, l, mnpos - 1, maxOper),
    		nb=calc(str, mnpos + 1, r, maxOper);
        if(str[mnpos] == '/')return na / nb;
        if(str[mnpos] == '*')return na * nb;
        if(str[mnpos] == '+')return na + nb;
        if(str[mnpos] == '-')return na - nb;
    }
    return 0;
}
```
于是，这道题就这样完成了。

#### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline string postfix_to_infix(char* s)
//后缀转中缀(postfix & infix transformation) 
{
	string a,b;
	stack<string> stk; 
	char rtstr[22];//注意这里必须为数组而不是指针(Note:Must be array instead of pointer) 
	for(int i = 0;s[i]!='@'&&s[i]!='\0'; i++)
	{
		if(s[i] >= '0' && s[i] <= '9')//获取数字(Judging decimal numbers)
		{
			memset(rtstr,0,sizeof(rtstr));
			long long num=0;
			for(;s[i]!='.' && s[i]!='\0' && s[i]!='@';++num,++i)
				if(s[i] >= '0' && s[i] <= '9')
					rtstr[num]=s[i];
			stk.push(rtstr);
		}
		else//遇到运算符处理(operator handling)
		{
			if(s[i]!='+' && s[i]!='-' && s[i]!='*' && s[i]!='/')
				continue;
			a = stk.top(); stk.pop(); b = stk.top(); stk.pop();
			switch(s[i])
			{//乘除法也要加括号(Multiplication & division also need parentheses) 
				case '+': stk.push("("+b+"+"+a+")"); break;
				case '-': stk.push("("+b+"-"+a+")"); break;
				case '*': stk.push("("+b+"*"+a+")"); break;
				case '/': stk.push("("+b+"/"+a+")"); break;
			}
		}
	}
	return stk.top();
}
inline long long calc(const char *str, const int l, const int r, const int maxOper = 1000)
//二分计算中缀表达式的值(Value of infix expression in dichotomy)
{
    long long prio = 0, mnpos = 0, mn = LLONG_MAX, cnt = 0, p[r+1],num = 0;
    memset(p, 1, sizeof(p));
    for(long long i = r; i >= l; i--)
    { //计算运算符优先级(Computing symbol priority)
        if(str[i] == ')')prio += maxOper*2+1;
        if(str[i] == '(')prio -= maxOper*2+1;
        if(str[i] == '/')p[i] = prio + 2, cnt++;
        if(str[i] == '*')p[i] = prio + 2, cnt++;
        if(str[i] == '+')p[i] = prio + 1, cnt++;
        if(str[i] == '-')p[i] = prio + 1, cnt++;
        if(mn > p[i])mn = p[i], mnpos = i;
        //寻找优先级最低的运算符，记得括号要回溯
		//(Locate on the symbol with the lowest priority，remember to recall)
    }
    if(!cnt)
    {//区间内没有运算符(Don't have operators)
		//获取数字(Judging decimal numbers)
        for(long long i = l; i <= r; i++)
            if(str[i]>='0' && str[i]<='9')
				num = num * 10 + str[i] - '0';
        return num;
    }
    else
    {//否则处理运算符(Deal with operator)
    	long long na=calc(str, l, mnpos - 1, maxOper),
    		nb=calc(str, mnpos + 1, r, maxOper);
        if(str[mnpos] == '/')return na / nb;
        if(str[mnpos] == '*')return na * nb;
        if(str[mnpos] == '+')return na + nb;
        if(str[mnpos] == '-')return na - nb;
    }
    return 0;
}
int main()
{//test
    char s[1000]={0};
	gets(s);
	string instr=postfix_to_infix(s); 
    printf("%d\n",calc(instr.c_str(),0,instr.length()-1));
    return 0;
}
```
#### 花絮：
在做这道题时，我调试了很久(大约有13-15次试运行)-在自己的机器上跑没问题的数据放到洛谷里有时RE有时TLE有时。。。反正各种错误都出现了一次，还以为洛谷坏了。。。结果我的目光定焦在了代码第七行：我居然没有写指针的指向！。。。**求管理员通过，谢谢**

---

## 作者：Owen_codeisking (赞：3)

用栈就解决所有问题。


```cpp
#include <iostream>
using namespace std;
int s[1100],top=0;
void push(int k)//入栈 
{
    s[top]=k;top++;
}
void pop(char k)//判断加减乘除 
{
    if(k=='+'){
        s[top-2]=s[top-1]+s[top-2];
    }
    if(k=='-'){
        s[top-2]=s[top-2]-s[top-1];
    }
    if(k=='*'){
        s[top-2]=s[top-1]*s[top-2];
    }
    if(k=='/'){
        s[top-2]=s[top-2]/s[top-1];
    }top--;//栈顶要-- 
}
int main()
{
    char k;int ans=0;
    while(1)
    {
        cin>>k;
        if('0'<=k&&k<='9'){ans=ans*10+k-48;}
        else if(k=='.'){push(ans);ans=0;}//处理数字与'.' 
        else if(k=='+'||k=='-'||k=='*'||k=='/')pop(k);//处理加减乘除 
        else if(k=='@')break;//输出结束 
    }
    cout<<s[0]<<endl;
    return 0;
}
```

---

## 作者：CoolTeam (赞：3)

**栈**。

注意：

①后出现的为操作数(样例有体现)

②输入的数字不只是个位数。

下面提供**C语言版**。

```cpp
#include<stdio.h>
int main(void)
{
    int a[1010]={0},top=0;
    char temp;
    while((temp=getchar()) !='@')
    {
        if(temp>='0' && temp<='9')
        {
               a[++top]=temp-'0';
               while( (temp=getchar())>='0'&& temp<='9' )
                 a[top]=a[top]*10+temp-'0';
        }
            switch(temp){
                case '-':a[--top]-=a[top+1];break;
                case '+':a[--top]+=a[top+1];break;
                case '/':a[--top]/=a[top+1];break;
                case '*':a[--top]*=a[top+1];break;
            }
    }
    printf("%d",a[top]);
    return 0;
}
```

---

## 作者：B_Qu1e7 (赞：2)

~~jiāng：~~字符串的题目，不好好用string……~~"搞什么大新闻?!!”~~

习惯了用处理首位的方法（用完就用erase去掉首位）

~~就是一大水题，咋不放到入门难度~~

我是用了一个flag存是否正在读入数字，详见代码：

```cpp
//fla标记为0是继续在下表为la的数字*10再加一位数字
//fla标记为1是遇到了“小数点”，需要在下表为la+1的地方存数字
#include<bits/stdc++.h>
using namespace std;
int num[1001]={0},fla=0,la=1;
string x;
int main()
{
    cin>>x;
    while(x!="")
    {
        if(x[0]>47&&x[0]<58)
        {
            if(fla)la++,fla=0;//需要移动下标
            num[la]=num[la]*10+x[0]-48;//并且（否则）存数字
        }
        if(x[0]=='.')//“小数点”
        {
            fla=1;//标记
        }
        switch(x[0])//一点也不机智的switch
        {
            case '+':num[la-1]+=num[la],num[la]=0,la--;break;
            case '-':num[la-1]-=num[la],num[la]=0,la--;break;
            case '*':num[la-1]*=num[la],num[la]=0,la--;break;
            case '/':num[la-1]/=num[la],num[la]=0,la--;break;
        }
        x.erase(0,1);//清除首位
    }
    cout<<num[la];//输出，可以写为num[1]
}
```

---

## 作者：yjjr (赞：2)

思路
先进行后缀表达式求值的推导，进行二叉树绘图模拟，研究后缀表达式求值过程的规律，计算方法

Step1
用while true 经典语句以字符的形式读入数据（边读入边处理）


While true do begin

  If ch=’@’ then break;    

End;
Step2
分类处理    数字：放入k值中

操作点数：将数值压栈（注意要清零，解决多位数数字）

符号：将top和top-1进行处理放入top-1中，dec(top);

Step3
输出top项，栈顶


推导
可以用栈顶和栈底判断表达式的正确性，是否合法


易错点

1.要用字符形式读入，用字符串比较复杂

2.尽量定义int64，以免发生错误

3.K值压栈后要清零

```delphi

(var
 ch:char;
 top,k:int64;
 a:array[0..2000] of int64;

begin
 top:=0;k:=0;
 while true do begin 
  read(ch);
  if ch='.' then begin inc(top);a[top]:=k;k:=0;end;
  if ('0'<=ch)and(ch<='9') then k:=k*10+ord(ch)-48;
  case ch of
   '+':begin a[top-1]:=a[top]+a[top-1];dec(top);end;
   '-':begin a[top-1]:=a[top-1]-a[top];dec(top);end;
   '*':begin a[top-1]:=a[top-1]*a[top];dec(top);end;
   '/':begin a[top-1]:=a[top-1] div a[top];dec(top);end;
  end;
  if ch='@' then break;
    end;
 writeln(a[top]);
end.)

```

---

## 作者：Snowboy (赞：2)



```cpp
**//大佬们用STL做的提接juruo看的头晕眼花**
**//直接模拟一个栈再加个bool数组记录就好了嘛**
**//下面juruo代码**
**#include <cstdio>
**#include <cstring>
**char ss[1001];
**int stack[1001]={0};//要初始话
**bool vis[1001]={0};//记录第k层有无数字
**int k=1;
**int len;
**void cz()
**{
**k=k-1;vis[k]=0;
**stack[k]=0;//别忘了把栈顶清零原因在main函数里
**}**
**int main()
**{
**int i;
**scanf("%s",ss);
**for(i=0;i<strlen(ss);i++)
**{
**if(ss[i]=='@'){len=i;break;}//因为有可能‘@’在中间
**}
**for(i=0;i<len;i++)
**{
**if(ss[i]!='.' && ss[i]!='+' && ss[i]!='-' && ss[i]!='*' && ss[i]!='/')
**{**
**stack[k]=stack[k]*10+(ss[i]-'0');//若栈顶不清零样例就是46了。
**vis[k]=1;//记录此层被占用（主要是区别0----与初始化的0）
**continue;
**}
**if(ss[i]=='.'){if(vis[k])k++;continue;}
**if(ss[i]=='+'){stack[k-2]=stack[k-2]+stack[k-1];cz();continue;}
**if(ss[i]=='-'){stack[k-2]=stack[k-2]-stack[k-1];cz();continue;}
**if(ss[i]=='*'){stack[k-2]=stack[k-2]*stack[k-1];cz();continue;}
**if(ss[i]=='/'){stack[k-2]=stack[k-2]/stack[k-1];cz();continue;}
**}
**printf("%d",stack[1]);
**return 0;**
**}

```

---

## 作者：loceaner (赞：2)

### 这个题就可以展示switch的强大功效啦！

这个题并不难，我的做法是栈和switch语句

（看到好多大佬是用的STL里的堆栈，小的自愧不如，我兼容一下啦QWQ）

### 下面是思路：

扫描后缀表达式，凡遇操作数则将之压进栈，遇运算符则从栈中弹出两个操作数进行该运算，将运算结果压栈，然后继续扫描，直到后缀表达式被扫描完毕为止，此时栈底元素即为该后缀表达式的值。

接下来举个栗子

![举个栗子](https://t1.picb.cc/uploads/2019/03/20/VbLNPF.png)

### 比如，16–9*(4+3)转换成后缀表达式为：

### 16.9.4.3.+*–，在数组a中表示为：

![](https://t1.picb.cc/uploads/2019/03/20/VbLX3a.png)

### 在栈中的变化过程：

![](https://t1.picb.cc/uploads/2019/03/20/VbLP6D.png)

注意是下面的对上面的进行运算

举例完成

### 下面是几个需要注意的点：

### 1、switch语句不要忘记写break（巨坑......）

### 2、一定要用栈中下面的值在前对上面的值进行运算(不然会出现不可思议的结果，如果做的话可以去试一试)

#### 接下来上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
using namespace std;

int stack[1001];
char s[1001];

int comp(char s[1001]) {
	int i=0,top=0,x,y;
	while(i<=strlen(s)-2) {
		switch(s[i]) {//switch语句啦啦啦
			case '+':stack[--top]+=stack[top+1];break;
			case '-':stack[--top]-=stack[top+1];break;
			case '*':stack[--top]*=stack[top+1];break;
			case '/':stack[--top]/=stack[top+1];break;
			default:x=0;while (s[i]!='.') x=x*10+s[i++]-'0';stack[++top]=x;break;
		}
		i++;
	}
	return stack[top];
}

int main()
{
	gets(s);
	printf("%d",comp(s));
	return 0;
}
```
我写完啦，欢迎吐槽


---

## 作者：kevin1022 (赞：1)

这道题目是用栈stack来做的

读到数字，压入栈

读到符号，弹出栈两次（因为加减乘除都是双目运算符），运算后压入栈

读到点，不理睬

读到@，结束程序

用Pascal实现100分

判断使用case语句
```
var
  ch:char;//读入使用的字符
  s:array[1..1000]of longint;//栈定义1000
  top{栈顶},x,y{两个操作数}:longint;
begin
  repeat
    read(ch);//读入
    case ch of//等同于c++的switch
      '@':break;//读到@，结束程序
      '.':continue;//读到点，不理睬
      '0'..'9'://读到数字
      begin
        inc(top);//栈顶+1
        s[top]:=ord(ch)-48;//压入栈
        repeat
          read(ch);
          if ch='.'then//是点就跳出，因为后缀表达式中符号在后面，所以无需判断@
            break;
          s[top]:=ord(ch)-48+s[top]*10;//当持续读入数字时累计数字
        until false;
      end;
      '+'://加法
      begin
        x:=s[top];//取走栈顶
        y:=s[top-1];//此处偷懒，直接取栈下面，非标准写法
        dec(top);//将top-2+1合并为dec(top)
        s[top]:=x+y;//重新压入栈
      end;
      '-'://下面几乎同上
      begin
        x:=s[top];
        y:=s[top-1];
        dec(top);
        s[top]:=y-x;//先进后出，所以操作数顺序颠倒，为y-x，非x-y
      end;
      '*':
      begin
        x:=s[top];
        y:=s[top-1];
        dec(top);
        s[top]:=x*y;
      end;
      '/':
      begin
        x:=s[top];
        y:=s[top-1];
        dec(top);
        s[top]:=y div x;//同上操作数颠倒
      end;
    end;
  until eoln;//行末结束
  writeln(s[top]);//输出栈顶元素（如果表达式规范，此时top=1，即为标准答案）
end.



---

## 作者：刘备 (赞：1)

这题用来练练代码还是蛮好的。


思路就是先把字符串预处理一下，然后用一个递归函数直接搞定。


不要问以下代码的某些变量名和函数名怎么这么奇怪，我是打死也不会告诉你们这是3个大佬的名字的！！！


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define N 1010 
using namespace std;
char ss[N];
struct node {
    int pd,num; 
}a[N];
int wt(int st,int &pos){
    int sign = a[st].pd;
    int lwx,qrh;
    if(!a[st-1].pd) st--,qrh = a[st].num;
    else qrh = wt(st-1,st);
    if(!a[st-1].pd) st--,lwx = a[st].num;
    else lwx = wt(st-1,st);
    pos = st;
    if(sign == 1) return lwx + qrh;
    if(sign == 2) return lwx - qrh;
    if(sign == 3) return lwx * qrh;
    if(sign == 4) return lwx / qrh;
}
int main(){
    int i,j,cnt=0;
    scanf("%s",ss+1);
    int len = strlen(ss+1)-1;//最后一位@直接不管
    for(i = 1;i <= len;i++) {
        if(isdigit(ss[i])) {
            ++cnt;
            a[cnt].pd = 0;
            a[cnt].num = a[cnt].num*10+ss[i]-48;
            while(i < len&&isdigit(ss[i+1])) {
                i++;
                a[cnt].num = a[cnt].num*10+ss[i]-48;
            } 
        }
        else {
            if(ss[i] == '.') continue;
            if(ss[i] == '+') a[++cnt].pd = 1;
            if(ss[i] == '-') a[++cnt].pd = 2;
            if(ss[i] == '*') a[++cnt].pd = 3;
            if(ss[i] == '/') a[++cnt].pd = 4;
        }
    }
    printf("%d\n",wt(cnt,j));//这个j毫无意义，不用理它。
    return 0;
}
```

---

## 作者：loadingnow (赞：1)

这个题还是很水的，字符串处理，当某一位是‘.'的时候，那么前面的一定是数字，我们只需要截取前面的子串转成数字就好了，当某一位是运算符的时候，那么就是栈顶数第二个元素 op（运算符） 第一个元素

```cpp
#include <iostream>
#include <cstring>
#include <stack>
using namespace std;
stack<int> stk;
int convert(const string &s)//将子串转成数字
{
    int ans=0;
    for(int i=0;i<s.length();i++)
        ans=ans*10+s[i]-'0';
    return ans;
}
int main()
{
    string s;
    getline(cin,s);//因为只有一行我们用getline
    int st=0,len=0;
    for(int i=0;i<s.length();i++)
    {
        if(s[i]>='0'&&s[i]<='9')    len++;//某一位是数字的话，我们让子串长度加一
        if(s[i]=='.')//某一位是'.'的话，那么我们截取前面的子串放到栈内，起始位置变成下一位，长度变成0
        {
            stk.push(convert(s.substr(st,len)));
            st=i+1;
            len=0;
        }
        if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/')
        {
            if(len!=0)
                stk.push(convert(s.substr(st,len)));
            st=i+1;
            len=0;
            int a=stk.top();    stk.pop();
            int b=stk.top();    stk.pop();
            if(s[i]=='+')    stk.push(b+a);
            if(s[i]=='-')    stk.push(b-a);
            if(s[i]=='*')    stk.push(b*a);
            if(s[i]=='/')    stk.push(b/a);
        }
    }
    cout<<stk.top()<<endl;
    return 0;
}
```

---

## 作者：zao无双 (赞：1)

发现这题数据有点水。。。一开始用字符串（string）都过了= =

下面是正确代码\(^o^)/~

```cpp
var
  ch:char;
  i,j,t,len:longint;
  a:array[0..1000]of longint;
begin
       j:=1;
      repeat
       read(ch);
 case ch of
   '0'..'9' :if a[j]<>0 then a[j]:=a[j]*10+ord(ch)-48 else a[j]:=ord(ch)-48 ;//防止超过一位的数出现
   '.': inc(j); //进位
   '+':begin dec(j);a[j-1]:=a[j-1]+a[j]; a[j]:=0 ; end;
   '-':begin dec(j);a[j-1]:=a[j-1]-a[j]; a[j]:=0; end;
   '*':begin dec(j);a[j-1]:=a[j]*a[j-1];   a[j]:=0; end;
   '/':begin dec(j);a[j-1]:=a[j-1] div a[j];a[j]:=0;  end;
   end;                               
    until ch='@';
   write(a[1]);
end.
```

---

## 作者：Amphetamine (赞：1)

此题可以纯用栈+模拟

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int>a; //定义栈
int main(){
    char c;
    int ans=0;
    int x1=0;//特别注意！！！这个一定要定义在while外边
    while(1){
        cin>>c;
                int x,y;
        if(c=='@')break;
        else switch(c){    //对于这道题来说明显用switch比较简洁
            case '+':x=a.top();a.pop();y=a.top();a.pop();y+=x;a.push(y);break;
            case '-':x=a.top();a.pop();y=a.top();a.pop();y-=x;a.push(y);break;
            case '*':x=a.top();a.pop();y=a.top();a.pop();y*=x;a.push(y);break;
            case '/':x=a.top();a.pop();y=a.top();a.pop();y/=x;a.push(y);break;
            case '.':a.push(x1);x1=0;break;
            default :int m=c-'0';x1=x1*10+m;break;
        }
    }
    ans=a.top();
    cout<<ans;//输出数据，也可以直接cout<<a.top();
    return 0;
}

```

---

## 作者：Xsy123456 (赞：1)

###极简极简

过程很简单

扫描表达式，只要遇到操作数就压入堆栈，遇到运算符就从堆栈里头取出两个算

将运算结果压栈，然后继续扫描

直到扫完为止

此时栈底元素即为值

```cpp
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
#define Size 2000

int x,y;
int top=0,i=0;
int stack[Size];
char s[Size];

int comp(char s[]){
    
    while (i<strlen(s)-1){
        switch (s[i]){
            case '+':stack[--top]+=stack[top+1];  break;
            case '-':stack[--top]-=stack[top+1];  break;
            case '*':stack[--top]*=stack[top+1];  break;
            case '/':stack[--top]/=stack[top+1];  break;
            default:
                x=0;
                while (s[i]!='.') x=x*10+s[i++]-'0';
                stack[++top]=x;
                break;
        }
        i++;
    }
    
    return stack[top];
    
}

int main(){
    
    gets(s);
    printf ("%d",comp(s));
    return 0;
    
}
```

---

## 作者：nkoi18 (赞：1)

本题纯模拟

用c++的有福利

STL简洁正确率高

注意事项

：
1.要枚举四种符号

2.开始还在纳闷'.'有什么用，原来并不是所有数都是一位数

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <stack>
using namespace std;
int go(int a,int b,char c)
{
    if(c=='*')
      return a*b;
    if(c=='/')
      return a/b;
    if(c=='+')
      return a+b;
    if(c=='-')
      return a-b;
}
int main()
{
    stack<int> sk;
    char c;
    while(1)
      {
          cin>>c;
          if(c=='@')
            break;
          if(c>='0'&&c<='9')//是数字还是符号
            {
                int v=c-'0';
                while(1)
                  {
                      cin>>c;
                      if(c=='.')
                        break;
                      else
                        v=10*v+c-'0';//几位数
                  }
                sk.push(v);
            }
          else
            {
                int a,b,x;
                b=sk.top();
                sk.pop();
                a=sk.top();
                sk.pop();
                x=go(a,b,c);
                sk.push(x);
            }
      }
    int ans=sk.top();
    cout<<ans;
    return 0;
}
```

---

## 作者：天狗的手帖 (赞：1)

注意
1.数据中存在‘/’号表示div操作

2.每一个数字后都有一个‘.‘但符号没有

3.最后结果要输出栈顶元素

```delphi

var p:array[1..10000] of longint;  
    ch:char;  
    k,top:longint;  
  
begin  
  
        while true do begin  
  
                read(ch);  
  
                if ch='.' then begin  
  
                        top:=top+1;  
  
                        p[top]:=k;  
  
                        k:=0;  
  
                        end;  
  
                if ('0'<=ch) and (ch<='9') then k:=k*10+ord(ch)-48;  
  
                case ch of  
  
                '+':begin top:=top-1;p[top]:=p[top]+p[top+1];end;  
                '-':begin top:=top-1;p[top]:=p[top]-p[top+1];end;  
                '*':begin top:=top-1;p[top]:=p[top]*p[top+1];end;  
                '/':begin top:=top-1;p[top]:=p[top] div p[top+1];end;  
  
                end;  
  
                if ch='@' then break;  
  
                end;  
  
        writeln(p[top]);  
  
end.

```

---

## 作者：傅思维666 (赞：1)


## 题解：

铺垫知识：前、中、后缀表达式的构成及互相转换的原则。

具体内容请参考这篇博客：

[浅谈前、中、后缀表达式](https://www.cnblogs.com/fusiwei/p/11615499.html)

其实，进行表达式转化的步骤一般有两种：表达式树和栈模拟。一般来讲，表达式树更适合笔试（代码非常恶心）。而我们正常的代码应该使用线性数据结构——栈。

按照博客中的说法，应该建两个栈进行模拟。但是因为这道题没有运算优先级的前后，所以可以只建一个数字栈进行模拟。

模拟的时候特别考验字符串的操作，细节部分在代码中已经给出：

```cpp
#include <bits/stdc++.h>
using namespace std;
stack<int> num;
char ch;
int sum,x,y;
int main()
{
    while((ch=getchar())!='@')
    {
        switch(ch)
        {
            case '+':
			{
				x=num.top();
				num.pop();
				y=num.top();
				num.pop();
				num.push(x+y);
				break;
			}
            case '-':
			{
				y=num.top();
				num.pop();
				x=num.top();
				num.pop();
				num.push(x-y);
				break;
			}
            case '*':
			{
				x=num.top();
				num.pop();
				y=num.top();
				num.pop();
				num.push(x*y);
				break;
			}
            case '/':
			{
				y=num.top();
				num.pop();
				x=num.top();
				num.pop();
				num.push(x/y);
				break;
			}
            case '.':
			{
				num.push(sum);
				sum=0;
				break;
			}
            default :
			{
				sum=sum*10+ch-'0';
				break;
			}
        }
    }
    printf("%d",num.top());
    return 0;
}
```


---

## 作者：Capitalism_Gao (赞：0)

## 前言：CSP初赛临近，写篇题解温习前、中、后缀表达式

### 一、序言
前、中、后缀表达式的求值过程可以用到栈来辅助存储。
如果把表达式放在树上，那么：

         - 前缀表达式遵循先序：中左右
         - 中缀表达式遵循中序：左中右
         - 后缀表达式遵循后序：左右中
         
只要记住：什么表达式就是什么序，什么序就是'中'在哪个位置     
         
### 二、后缀表达式求值

假定待求值的后缀表达式为：1.92.60.-*817.+@

1. 遍历表达式，遇到的数字就放入栈中；

       STACK:1  92  60

2. 接着读到'-'，依次弹出92和60，执行92-60，计算结果等于32，并将32压入到栈中；

       STACK:1  32 

3. 然后读到'*'，依次弹出1和32，执行1*32，计算结果等于32，并将32压入到栈中；

       STACK:32


4. 接着读到817，将其压栈；

       STACK:32  817
       
5. 最后读到'+',依次弹出32和817，计算相加之和等于849，就是此表达式的值       

### 三、对于本题读入

这是一个易错点。不难发现，每一个整数后面都紧跟了一个'.',并且，并不是每一个数都只有一位(~~坑人的~~样例就是只有一位)！      
所以当我们读到有0~9中的数字时，还要一直往后面判断，知道s[i]='.',把那个数读出来，压入栈中，新起点就是'.'的后面那一位。

### 四、分享源码
```
#include<bits/stdc++.h>
using namespace std;

string s; 
int top,ans,nextqd,st[1010]; 
 
inline bool isnum(char a){
	if(a>='0'&&a<='9') return true;
	return false;
}

inline int num(char x){
	return x-'0';
}

inline void read(int qd){//此数的起点位置
	int now=qd,res=0;
	while(isnum(s[now])){
		res=res*10+num(s[now]); 
		++now;
	}
	st[++top]=res;//将数压入栈中
	nextqd=now+1;//now指向的是'.'的位置，所以下一个起点nextqd=now+1
}

int main(){
	ios::sync_with_stdio(0);
	getline(cin,s);
	for(int i=0;s[i]!='@';){
		if(isnum(s[i])){//是数字
			read(i);
			i=nextqd;//i跳到'.'后面的那个位置
		}
		else {
			int val;
			if(s[i]=='+') val=st[top-1]+st[top];
			if(s[i]=='-') val=st[top-1]-st[top];
			if(s[i]=='*') val=st[top-1]*st[top];
			if(s[i]=='/') val=st[top-1]/st[top];
			ans=val;i++;
			st[--top]=val;//弹了两个又压了一个，top只-1
		}
	}
	printf("%d",ans);
	
	return 0;
}

```



---

## 作者：沙文大侠 (赞：0)

# [后缀表达式](https://www.luogu.org/problem/P1449) 题解
### 题目分析
后缀表达式的好处就是**运算顺序严格与符号的出现顺序相同** ，所以这道题可以非常轻易的使用栈解决。方法如下:

1. 将输入的数字入栈。
2. 输入一个符号时，取出栈顶的两个数，进行相应的运算，将运算结果再入栈。
3. 读入一个“@”，结束输入。
4. 此时栈中只剩下一个元素，它就是答案。
------------------

### 栈的实现
这里采用的是用结构体手写一个栈。STL或者用数组模拟一个栈也是可以的。
#### 代码实现
```c++
struct zhan{
		int zt[1005];//栈
		int zd=0;//栈顶指针
	
		void push(int x){zt[++zd]=x;}//入栈操作
		void pop(){zd--;}//出栈操作
		int top(){return zt[zd];}//栈顶
};
```
-------
### 处理输入
我采用单个char变量于一个循环读入每一个数字和符号所以对于数字需要进行特殊处理。我们可以定义一个int变量cd在两次循环之间传递信息。每输入一个数字，将cd*10后加上新读入的数字。在读入一个“.”后我们就知道上一个数字已经读入完了，此时把cd入栈，然后初始化cd。
#### 代码实现
```c++
int cd=0；
char sr；
while(1){
	scanf("%c", &sr);//读入一个字符
	if(sr=='@') break;//是否是“@”，是就结束循环
	if(sr=='.') {//是否是“.”，是就将cd入栈
		bds.push(cd);
		cd=0;
		continue;	
	}
	if(sr>='0'&&sr<='9'){//是否是数字，是就对cd进行相应操作
		cd=cd*10+(sr-'0');
		continue;
	}
        
  	//运算  
        
}
 ```
 ---
 # AC CODE:
 ```c++
 #include<iostream>
 #include<cstdio>
 using namespace std;

 struct zhan{
	int zt[1005];
	int zd=0;
	
	void push(int x){zt[++zd]=x;}
	void pop(){zd--;}
	int top(){return zt[zd];}
 };

 zhan bds;
 char sr;
 int cd;

 int main(){
 	while(1){
 		scanf("%c", &sr); 
 		if(sr=='@') break;
 		if(sr=='.') {
 			bds.push(cd);
 	 		cd=0;
 			continue;	
 		}
 		
 		if(sr>='0'&&sr<='9'){
 			cd=cd*10+(sr-'0');
 			continue;
 		}
		
 		int i, j;//定义两个临时参数
        //取出栈顶  
 		j=bds.top(), bds.pop();
 		i=bds.top(), bds.pop();
			//运算并入栈
 		if(sr=='+')	bds.push(i+j);
 		else if(sr=='-') bds.push(i-j);
 		else if(sr=='*') bds.push(i*j);
 		else if(sr=='/') bds.push(i/j);//这题只需向下取整
 	}
	
	printf("%d", bds.top());//栈顶即答案
}
```

---

## 作者：_LHF_ (赞：0)

这是一道很经典的题目，要用到**数组模拟栈**。这个程序就像是一个计算器，当然，输入的是后缀表达式，其实这样还更简单，减少了难度。（因为如果是算式的话还要先转为后缀表达式再计算）其实单题目理解着有一点难，（对于我来说）但是可以结合样例进行分析。明白题目意思之后，接下来就要进行计算了，要用到一个**数组模拟栈**。![](file:///C:/Users/Administrator/Desktop/%E6%97%A0%E6%A0%87%E9%A2%98.png)
C++代码如下：
```
#include<cstdio>
using namespace std;
int a[1000],len,lf,ans,k;
char c,cc;
bool p=true;
bool okok()
{
	if(cc>='0'&&cc<='9')return true;
	if(cc=='.')return true;
	return false;
}
void work()
{
	len-=2;
	switch(c)
	{
		case '+':{
			a[len]+=a[len+1];
			a[len+1]=0;
			break;
		}
		case '-':{
			a[len]=a[len]-a[len+1];
			a[len+1]=0;
			break;
		}
		case '*':{
			a[len]*=a[len+1];
			a[len+1]=0;
			break;
		}
		case '/':{
			a[len]/=a[len+1];
			a[len+1]=0;
			break;
		}
	}
	len++;
}
int main()
{
	while(c!='@')
	{
		c=getchar();
		if(c=='@')
		{
			break;
		}
		if(c>='0'&&c<='9')
			a[len]=a[len]*10+(c-'0');
		else if(c=='.')
		{
			len++;
		}else{
			work();
		}
		cc=c;
	}
	printf("%d",a[0]);
	return 0;
}
```


---

## 作者：cormac (赞：0)

看到有人用这种操作：tmp=tmp\*10+s[i]-'0';

(实在懒得这么搞),**还可以巧用sscanf**

**这样只需一个辅助char数组来保存每个“数”，再转换成int就好了

【中间有个'\0'的问题,可加可不加，具体请看代码】

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<stack>
using namespace std;
char s[1010];
stack<int> st;
int main(){
    char t='\0',ttt[200],pos=0;
    int shu,t1,t2,tans;
    while(t!='@')
    {
        t=getchar();
        if(t>='0'&&t<='9')
        {
            ttt[pos++]=t;     //此处先将每位数先存入辅助字符数组中
            continue;
        }
        else if(t=='.')
            {

                ttt[pos]='\0';pos=0;    
//上面的ttt[pos]='\0';不加的话程序也能AC(我只是为了让它的中间辅助字符数组能正常输出。。。
    //            printf("%s  ",ttt);
                sscanf(ttt,"%d",&shu); //cout<<shu<<'\n';
                st.push(shu);
                continue;
            }
            else if(t!='@')
            {
                t1=st.top(); st.pop();
                t2=st.top(); st.pop();
                switch(t){
                case '+':st.push(t2+t1);break;
                case '-':st.push(t2-t1);break;
                case '*':st.push(t2*t1);break;
                case '/':st.push(t2/t1);break;
                }
                continue;

            }
    }
        cout<<st.top();
        return 0;
    }
```

---

## 作者：Ha1fWong (赞：0)

用栈解决该题

```cpp
var
    x,t,i:longint;
    s:string;
    c:char;
    a:array[1..1000]of longint;
begin
    repeat
        read(c);
        s:=s+c;//把输入的字符添加到字符串里面
    until c='@';
    t:=0;
    x:=0;
    for i:=1 to length(s) do
        case s[i] of
```
'0'..'9':
x:=x\*10+ord(s[i])-48;//将字符转换为数字 并记录

```cpp
            '.':begin
                    inc(t);
                    a[t]:=x;
                    x:=0;
                end;
            '+':begin
                    dec(t);
                    a[t]:=a[t]+a[t+1];
                end;
            '-':begin
                    dec(t);
                    a[t]:=a[t]-a[t+1];
                end;
            '*':begin
                    dec(t);
                    a[t]:=a[t]*a[t+1];
                end;
            '/':begin
                    dec(t);
                    a[t]:=a[t] div a[t+1];
                end;
        end;
    writeln(a[1]);
end.

```

---

## 作者：lucien311 (赞：0)

stl大法好，只要用stack就可以了

遇到数字就记下来，遇到点号就把当前数字压栈

遇到操作符就从栈顶取两个数字进行运算



```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<stack>
#include<cstring>
using namespace std;
char s[1010];
stack<int> st;
int main()
{
    int tmp=0,t;
    gets(s);
    int len=strlen(s);
    for (int i=0;i<len-1;i++) {
        if (s[i]>='0' && s[i]<='9') {
            tmp=tmp*10+s[i]-'0';
        }
        else {
            if (s[i]=='.') {
                st.push(tmp);
                tmp=0;
            }
            else {
                int x,y;
                x=st.top(); st.pop();
                y=st.top(); st.pop();
                switch (s[i]) {
                    case '+' : {
                        t=y+x;
                        st.push(t);
                        break;
                    }
                    case '-' : {
                        t=y-x;
                        st.push(t);
                        break;
                    }
                    case '*' : {
                        t=y*x;
                        st.push(t);
                        break;
                    }
                    case '/' : {
                        t=y/x;
                        st.push(t);
                        break;
                    }
                }
            }
        }
    }
    printf("%d\n",st.top());
    return 0;
}
```

---

## 作者：10092x (赞：0)

本题纯模拟，楼下几位p语言大神写的有些啰嗦，本蒟蒻的程序要更加清晰。标程如下：

```cpp
program P1449;
var x,ans:longint;c:char;a:array[1..600]of longint;
begin
  x:=0;
  repeat
    read(c);//读入字符
    case c of
      '0'..'9':
        x:=x*10+ord(c)-48;//为防止该数是多位数，先存在一个临时变量中
      '+'://加法运算
        begin
          dec(ans);
          a[ans]:=a[ans]+a[ans+1];//栈的前两个元素相加
        end;
      '-'://减法运算
        begin
          dec(ans);
          a[ans]:=a[ans]-a[ans+1];//栈的前两个元素相减
        end;
      '*'://乘法运算
        begin
          dec(ans);
          a[ans]:=a[ans]*a[ans+1];//栈的前两个元素相乘
        end;
      '/'://除法运算
        begin
          dec(ans);
          a[ans]:=a[ans] div a[ans+1];//栈的前两个元素相除（整除）
        end;
      '.':
        begin
          inc(ans);
          a[ans]:=x;//数入栈
          x:=0;//临时变量置为零
        end;
    end;
  until c='@';//判断表达式是否结束
  writeln(a[1]);//输出栈底元素（答案必定在栈底，否则表达式是错误的）
end. 
```

---


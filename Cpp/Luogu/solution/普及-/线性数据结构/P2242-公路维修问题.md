# 公路维修问题

## 题目描述

由于长期没有得到维修，A国的高速公路上出现了 $n$ 个坑。为了尽快填补好这 $n$ 个坑，A国决定对 $m$ 处地段采取交通管制。为了求解方便，假设A国的高速公路只有一条，而且是笔直的。现在给出 $n$ 个坑的位置，请你计算，最少要对多远的路段实施交通管制？


## 说明/提示

[样例说明]


交通管制的地段分别为：$3-8,14-21,25-31,40-43$。

## 样例 #1

### 输入

```
18 4
3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43
```

### 输出

```
25```

# 题解

## 作者：KEVIN_L (赞：48)

蒟蒻第一次写题解，请多多包涵。

这是一道简单的**排序+贪心**题目。看到这么多题解都是一个解法，我来发一个相似但是更好理解的。

我们可以假设每一个坑都被管制了，但是由于管制的路段数量有限，所以就要减去尽可能大的没有坑路段，然后剩下的就是答案了。

见代码（C++）：

```cpp
#include<cstdio>
#include<algorithm>           //包含sort
int n,m;
int a[15005],b[15005],ans;
bool cmp(int k,int h){        //cmp函数用于让sort从大到小排列
	return k>h;
}

int main(){
   scanf("%d%d",&n,&m);
   for(int i=1;i<=n;i++)
       scanf("%d",&a[i]);
   ans = a[n] - a[1] + 1;
   for(int i=1;i<n;i++)       //计算出每一个坑的距离
       b[i] = a[i+1] - a[i];
   std::sort(b+1,b+n,cmp);    //从大到小排序
   for(int i=1;i<m;i++){      //从中间舍去m-1段不需要的最长的路段 
       ans = ans - b[i] + 1;
   }
   printf("%d\n",ans);
	
   return 0;                  //华丽的结束QAQ
}
```

---

## 作者：Elma_ (赞：18)

## 贪心
本蒟蒻的第一篇题解，写得不好的地方恳请大家~~理解~~指出。

题目传送门：https://www.luogu.com.cn/problem/P2242

这道题是一道很显然的贪心，但是本蒟蒻感觉有些题解看不懂，还有些题解没有说明贪心正确性的，所以本蒟蒻就自己写了一篇。（~~虽然没有其他的题解写得好~~

题目要求实施交通管制的路段总长度最短，我们就必须使管制的路段中被浪费的长度尽量小。因为只有坑所在的点才需要被维护，这里“被浪费的长度”，其实就是**坑与坑之间的距离**
，即没有被管制的路段。

显然可以得出结论：
**所有被管制路段的的开头和结尾一定都在坑上，**
才能使浪费达到最小。所以我们需要考虑的其实是从第一个坑到第$n$个坑的范围，道路的头尾两端都可以省略。

那么问题就来了，在怎么在第一个坑和最后一个坑之间管制$m$个路段，使总浪费最小呢？

我们可以注意到，根据刚才得出的结论，在这$m$条路段中，第一条的开头一定是第一个坑，而第$m$条路段的结尾一定是第$n$个坑。每两个管制路段之间会有一个没有被管制的路段，所以，在第一个坑和第$n$个坑之间，一共会有$m-1$个没有被管制的路段，即**会有$m-1$个“坑与坑之间的距离”会被浪费。**

为了使浪费最短，我们就可以用sort对每两个坑之间的距离进行排序，然后用第一个坑到第$n$个坑之间的距离依次减去前$m-1$个最短的浪费长度（两个坑之间的距离），就可以求出答案了。（~~这题太水了qwq~~

## CODE 

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

const int MAXN = 100005;
int n, m;
int a[MAXN], large[MAXN];//a数组存储每个坑的位置，large数组存储每两个坑之间的距离

int main() {
    scanf("%d%d", &n, &m);
    for (int i=0;i<n;i++)
        scanf("%d", &a[i]);//输入，不解释
                          
    for (int i=0;i<n-1;i++)//n个坑之间只会出现n-1个距离，这里记得是到n-1
   		large[i] = a[i + 1]-a[i]-1;//两端的两个坑不算，这里记得-1
  
    sort(large, large+n-1);//排序，不解释
  
    int ans = a[n - 1]-a[0]+1;//将管制路段总长初始化为第1个坑到第n个坑之间的距离。和前面不一样，由于两端的坑都要算，所以要+1
    for (int i=1;i<=m-1;i++)//m个路段有m-1个间隙，这里-1;
        ans -= large[n-1-i];//依次减去第1到第n-1小的两坑之间距离
                        
    printf("%d\n", ans);//输出，完美AC~
}
```

~~码风恶臭，不喜勿喷）~~

最后，祝所有看到这篇题解的大佬们：**AKIOI！**

本蒟蒻的第一篇题解，求管理大大通过~~

---

## 作者：Deny_小田 (赞：13)

嘿，这题应该挺简单的啊，为什么没有人发题解呐？


思路，输入一个数组，然后求出数组的每个元素间隔的数。

然后排序，针对这个数组。


sort(\_k,\_k+n);

最后i从0到n-m，将和累加。

最后输出s+m。


代码：





```cpp
#include <cstdio>
#include <algorithm>
#define Size 20005
using namespace std;
int k[Size],_k[Size],n,m,s = 0;
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 0; i < n; i++){
        scanf("%d",&k[i]);
        if(i){
            _k[i-1] = k[i] - k[i-1];
        }
    }
    sort(_k,_k+n);
    for(int i = 0; i < n-m+1; i++) s += _k[i];
    printf("%d\n",s+m);
    return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：8)

这题不算特别难，只要把每一段间隔存进数组，排序后ans累加最短的区间，最后输出ans+m即可。

**sort是个好东西**

代码如下
```
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <vector>
//这么多头文件实在煤必要
using namespace std;
int n,m;
long long len[15010],ans;
int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	long long last,now;//为了省空间，煤有开第二个数组
	scanf("%d %d %lld",&n,&m,&last);
	for(int i=1;i<n;i++)
	{
		long long keng;
		scanf("%lld",&keng);
		now=keng;
		len[i-1]=now-last;//把每一段区间存进数组
		last=now;
	}
	sort(len,len+n);//排序
	for(int i=0;i<n-m+1;i++) ans+=len[i];
	printf("%lld",ans+m);
//	fclose(stdin);fclose(stdout);
	return 0;
}
```
### 让辛苦的作者过题解乃中华美德——鲁迅~~煤有说过~~

---

## 作者：花千树 (赞：6)

看到本题题解少（就1篇），准备发一波

本题思路：sort！sort！sort！（重要的事情说三遍！）

定义两个数组，第一个存读入的数据，第二个存每两个数据间的差，用一个循环累加m个，最后结果加上m，过程不就结束了吗？

下面是我的16行超短代码（包含头文件，大括号）

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>//sort必备头文件
using namespace std;
int  a[20005],b[20005],n,m,ans;//定义，前面都说过了
int main(){//主程序华丽开始
    cin>>n>>m>>a[0];//读入
    for(int i=1;i<n;i++){
        cin>>a[i];//读入
        b[i-1]=a[i]-a[i-1];//计算
    }
    sort(b,b+n);//调用快排
    for(int i=0;i<n-m+1;i++)ans+=b[i];//累加
    printf("%d\n",ans+m);//完美输出
    return 0;//主程序华丽结束
}

```

---

## 作者：CmhDL (赞：5)

看了某些dalao的题解，有些看不太懂，所以在这里发一篇蒟蒻的易懂**贪心**题解（当然，本题解可能没有其他题解好，~~仅仅易懂而已~~）。

### 一、思路
第一眼看到题，我也有点懵（内心OS：￥%^&^$%$#@#*&...），可是我们其实可以把“组成m段”变为“把一整段路切m-1刀，分成m段”，这样就简单多了。

### 二、解决
叟先，我们要把各个坑之间的距离求出来：
```cpp
for(int i=2;i<=n;++i){
	scanf("%d",&a[i]);//输入时同步处理
	b[i].s=a[i]-a[i-1];//用结构体记差值和序号，以免排序后找不到这两个点
	b[i].xh=i;
}
```

自然，如果要切m-1刀，就要让这m-1刀刀刀都落在距离最长的两点间（~~不就是贪心吗~~），这样就能达到题目要求的效果了。
```cpp
//主函数里
sort(b+2,b+1+n,cmp);//对差值排序
--m;//准备切m-1刀
ans=a[n]-a[1]+1;//先把所有坑放在一起管制
for(int i=2;i<=n&&m>0;--m,++i)
	ans-=a[b[i].xh]-a[b[i].xh-1]-1;//前m-1个差值去掉
```
排序函数：
```cpp
inline bool cmp(cha x,cha y){
	return x.s>y.s;//按差值从大到小排序
}
```
最后输出ans就好啦！

### 三、$\color{green}\text{完整AC代码}$
```cpp
#include <bits/stdc++.h>//偷懒用了个万能头文件【捂脸】
using namespace std;
int n,m,a[15001],ans;
struct cha{
	int s,xh;
}b[15001];
inline bool cmp(cha x,cha y){
	return x.s>y.s;
}
int main(){
	scanf("%d%d%d",&n,&m,&a[1]);
	for(int i=2;i<=n;++i){
		scanf("%d",&a[i]);
		b[i].s=a[i]-a[i-1];
		b[i].xh=i;
	}
	sort(b+2,b+1+n,cmp);
	--m; ans=a[n]-a[1]+1;
	for(int i=2;i<=n&&m>0;--m,++i)
		ans-=a[b[i].xh]-a[b[i].xh-1]-1;
	printf("%d",ans);
	return 0;
}
```
最后：

有什么问题尽管留言！

## THE END

---

## 作者：_StarBird_ (赞：4)

~~您正在收看的是蒟蒻 jch 的题解~~

[题目传送门](https://www.luogu.com.cn/problem/P2242)

[本文在博客中食用更佳](https://www.luogu.com.cn/blog/jch2008/solution-p2242)

 _**进入正题！**_ 
 
------------

**【前置知识】**

贪心、快速排序

------------
**【推导过程】**

看到这题，窝的第一反应不是贪心，而是分组dp：模板题啊！但是明显 $n^3$ 的复杂度是过不去的，加上斜优同样会 $\text{T}$。这其实是 dp 的优点：不需要想。很多人觉得 dp,bfs,dfs 难，实际上它们是最容易想到的解法。

一般来说，如果是 $O(n)$ 复杂度的解法，$n$ 肯定是要飙升至十万百万的，$n \leq 15000$ 的数据，大概率就是 $n \log n$的解法。这个复杂度的 dp，一般有两种可能：

- 可以用单调队列之类的玩意优化；
- 状态定义上满足单调性，比如最长上升子序列的 $f(i)$ 表示长度为 $i$ 的最长上升子序列的结尾，这样 $f(i)$ 就是单调递增的，可以二分。

但是显然答案并不满足单调性，即 $x$ 个单位距离是可行的，不代表 $x-1$ 个单位距离一定可行，因此无法 dp，更不能二分。

既然不能 dp，能不能靠同样是 $\log$ 级别的排序来解决呢？既然想到了排序，那排序什么呢？既然输入的数据是有序的，就很容易想到将两个点的距离排序了。

------------
**【中心思想】**

其实我们可以把题意简化，变成在一条一维数轴上有 $n$ 个点，现在要让 $m$ 个区间覆盖所有的点，要求这 $m$ 个区间长度之和的最小值。

显然，区间的左端点和右端点都在数轴的点上。因为有多段区间，显然区间不会覆盖整条数轴，会有 $m-1$ 段两点之间的线段不会被覆盖。

想让距离最小，我们不需要取每一条线段，有 $m-1$ 条线段不会被取到。我们肯定是会不取那些距离最长的线段，这样才会使总距离最小。

 _因此，本题的做法就出来了：_ 首先处理出相邻两点之间的距离，对距离从大到小排序，再用总长度减去 $m-1$ 段最长的长度即可。

------------
**【注意事项】**

你以为这就完了？其实模拟一遍样例就可以知道，我们算出来的答案会是21，而不是25。这是为什么呢？原来，一个 $\left[l,r\right]$ 的区间长度应为 $r-l+1$，而非 $r-l$。就算样例的 $m$ 改成18，答案也应该是18而非0。也就是说，对于每一个区间，我们都少算了一个单位长度，$m$ 个区间少了 $m$ 个单位长度，因此在输出答案时需要把 $m$ 加回来。

------------
**【代码实现】**
```cpp
#include<bits/stdc++.h>
#define MAXN 15010
using namespace std;
int n,m;
int arr[MAXN],dis[MAXN]; //分别表示每个点的位置和相邻两点的距离 
bool cmp(int x,int y) //sort的排序标准 
{
	return x>y; //从大到小排 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&arr[i]); //读入每个坑的位置（其实arr数组可以优化掉，但这里会影响阅读体验，可以自行思考 
		if (i>1) dis[i-1]=arr[i]-arr[i-1]; //处理出相邻两点间的距离 
	}
	sort(dis+1,dis+n,cmp); //排序 
	int res=arr[n]-arr[1]; //一开始答案赋值为区间的总长度 
	for(int i=1;i<m;++i) res-=dis[i]; //可以不用取m-1段区间的长度 
	printf("%d\n",res+m); //少算了m个单位长度，输出时加上m 
	return 0; //程序结束记得return（20071007 
}
```
[record](https://www.luogu.com.cn/record/36654895)

切勿复制！

------------
$\mathcal{The}$ $\mathcal{end.}$

---

## 作者：RedreamMer (赞：3)

# P2242题解

算法：贪心

输入的$N$可以表示为有 $N$ 个点，其实也可以表示有N-1条线段即 $\forall i\in[1,N-1]$ 与 $i+1$ 组成的线段，输入的 $M$ ，表示留下M条线段，也表示去掉 $(N-1)-M+1$ 即 $N-M$ 条线段，为了让留下的线段最少则要让去掉的线段最长，所以需要 $sort$ 排序（或优先队列）再删掉最大的 $M$ 条线段

### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int last,nxt,som;
int s[1000001];
int main() {
	cin>>a>>b;
	cin>>last;//得到第一个点的位置
	for(int i=2;i<=a;i++){
		cin>>nxt;
		s[i-1]=nxt-last;//求出每段长度 
		som+=s[i-1];//求出总长 
		last=nxt;
	}
	sort(s+1,s+a);
	for(int i=a-1,j=1;i>=1&&j<b;i--,j++)//减去最大的M条线段 
	som-=s[i];
	cout<<som+b;//求出剩余长度 
	return 0;
}
```

很多人不理解 $sum+b+1$ 的意义，其实我们一开始把输入的 $N$ 个数看成了 $N$ 个点，其实它们不是点，而是长度为 $1$ 的线段，在去除 $M$ 条线段中，每取 $1$ 条线段就会多去长度为一的线段，所以要将它加回去

祝各位今年$CSP$-$rp$++

[$\color{blue}\text{MY BLOG}$](https://www.luogu.org/blog/184549/)

---

## 作者：zhangzhaoke (赞：2)

其实就是一个sort排序

见代码
```cpp
#include <iostream>
#include <algorithm>//sort头文件 
using namespace std;
int a[20005],b[20005],n,m,s = 0;
int main(){
    cin>>n>>m;//输入 
    for(int i=0;i<n;i++){
        cin>>a[i];
        if(i){//特判是否为0 
            b[i-1]=a[i]-a[i-1];//计算 
        }
    }
    sort(b,b+n);//重要的思路,(其实就是排序) 
    for(int i=0;i<n-m+1; i++)s+=b[i];//求总和 
    cout<<s+m<<endl;//输入 
	return 0;
}
```




---

## 作者：Marginal_world (赞：2)

其实本题代码实现没有任何难度，主要还是在思路的取舍上
```cpp
#include<bits/stdc++.h>//常备的万能头
using namespace std;
int a[20005],b[20005],n,m,p;//定义，不予解释
int main(){
    cin>>n>>m>>a[0];//输入，因为差值只有两数之间才有，所以先输入第一个
    for(int i=1;i<n;i++){
        cin>>a[i];
        b[i-1]=a[i]-a[i-1];//b数组存放差值
    }
    sort(b,b+n);//从小到大排序
    for(int i=0;i<n-m+1;i++)
	p+=b[i];
    cout<<p+m;//首尾之间有一个1没有计算，m段就会有m个一没有计算，所以加上m
    return 0;//华丽结束
}
```


---

## 作者：ddmd (赞：1)

本题的题意就是给你 $ N $ 个点，要求你用 $ M $ 段区间覆盖这些点，使这些区间和最小。

这道题是一题明显的**贪心**题。   

具体的贪心策略：就是我们考虑如何让这些区间的浪费最小，我们可以发现最后的区间和就是 $ N + Ans$，其中 $ Ans $就是选 $ N - M + 1 $ 个两点之间的距离。因为 $ N $ 是固定的，所以我们可以考虑让 $ Ans$ 最小。   

一些具体操作细节可以看代码。   

Code：


------------
```cpp
// Dong_Dong出品 必是精品
#include <bits/stdc++.h>
#define int long long

using namespace std;

inline int read()
{
	int pos=1,num=0;
	char ch=getchar();
	while (!isdigit(ch))
	{
		if (ch=='-') pos=-1;
		ch=getchar();
	}
	while (isdigit(ch))
	{
		num=num*10+(int)(ch-'0');
		ch=getchar();
	}
	return pos*num;
}
inline void write(int x)
{
	if (x<0)
	{
		putchar('-');
		write(-x);
		return;
	}
	if (x>=10) write(x/10);
	putchar(x%10+'0');
}
inline void writesp(int x)
{
	write(x);
	putchar(' ');
}
inline void writeln(int x)
{
	write(x);
	putchar('\n');
}
int n,m,y,a[15005];
signed main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
	{
		int x=read();
		if (i!=1) a[i]=x-y;
		y=x;
	}
	sort(a+1,a+n+1);
	int ans=m;//这个在最后算区间的时候会多减m，所以我们要加回去
	for (int i=1;i<=n-m+1;i++)
		ans+=a[i]; 
	writeln(ans);
	return 0;
}
```


---

## 作者：iamnottsh (赞：1)

前言：

题解里全用的是sort，其实这浪费了很多时间，不是正解，但是由于数据太弱，能水过

请看这题：https://www.luogu.com.cn/problem/P1923

其实，只要快排的**一部分**就行了：一旦选中第k-1大的数**操作完**之后排序**即可终止**。

不想手打的话，STL里提供了一个好东西：**nth_element**

设要找出第m大的数

用法:nth_element(first,first+m,last,greater<int>())
  
其作用是把第m大的数放在m位置上，比它大的放左边
  
这才是正解
  


------------

  
好了，题解正式开始（ 这道题是标准的贪心：
  
  - 首先，题目要求最少要对多远的路段实施交通管制
  
  当然直接求不好求，我们不如求出最多有多远不用进行交通管制，然后抠掉它
  
  - 我们用a数组记录每两个坑之间的差（当然，应该减一，不过想了想还是直接在最后加一个k比较好）
  
  - 把最后的坑的位置减去第1个坑的位置就是总共可能管制的路长
  
  - 我们用ans记录a数组前k-1大的数之和(**用nth_element找出前k-1大的数，而不是sort**)
  
  于是显而易见的，结果就是总路长-ans+k
  
  ）
  
以下是AC代码：
  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int i,n,k,t,s,ans=0,mi;//标准的定义
	cin>>n>>k;//标准的读入
	--n;//植树问题的原理，实际上只有n-1个差
	int a[n];//a数组记录差
	cin>>t;//先输入第一个坑的位置
	mi=t;//mi记下它，要不然一会儿滚没了
	for(i=0;i<n;++i){
		cin>>s;
		a[i]=s-t;//s-t是位置差
		t=s;//滚起来
	}
	nth_element(a,a+k-1,a+n,greater<int>());//找出第k-1大的数
	for(i=0;i<k-1;++i)ans+=a[i];//ans存的是前k-1大的差之和
	cout<<s-mi-ans+k;//s-mi是路长 
}
```


---

## 作者：Kumon (赞：1)

看到这道题的题解都不是很清晰，我来补充说明。

这道题是一道简单的排序题，思路很简单，只需要把相邻的两个洞的差值求出来，给差值数组排序，就可以求出管制哪些区域覆盖的路径最少了。答案就是把差值数组前n-m项求出来，最后加上m。加m看似不是很好理解其实就是把路的开头的本身加上，也就是管制7~15其实不是之管制15-7的长度，而是15-7**+1**的长度。
附AC代码：（C++）
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int hole[15006],delta[15005];
int main(){
	int n,m,ans=0;
	scanf("%d %d\n%d",&n,&m,hole);
	for(int i=1;i<n;++i){
		scanf("%d",hole+i);
		delta[i]=hole[i]-hole[i-1];
	}
	sort(delta+1,delta+n+1);
	for(int i=1;i<=n-m+1;++i){
		ans+=delta[i];
	}
	printf("%d",ans+m);
	return 0;
}
```


---

## 作者：Daidly (赞：1)

这道题是一个简单的贪心。我们只需要把每一个与下一个之差算出来，然后再进行比较，接着分组就可以计算出最小长度和。可以试着定义两个数组，接着我们用一个循环，把一个数组中的两个数的差减一转换为另外一个数组中的一项。接着最主要的一点就是用sort排序从小到大排序。最后，用一个for循环，把总的数量减去最优的数量就可以算出最小长度和。
```
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int m,n,a[100005],b[100005];//两个数组
int main(){ 
    ios::sync_with_stdio(false);
    cin.tie(0);//加速黑科技
    cout.tie(0);
    cin>>n>>m;
    for(int i=0;i<n;i++){//输入
    	cin>>a[i];
	}
	for(int i=0;i<n-1;i++){//贪心模拟
    	b[i]=a[i+1]-a[i]-1;
	}
	sort(b,b+n-1);
	int ans=a[n-1]-a[0]+1;
	for(int i=1;i<=m-1;i++){
		ans=ans-b[n-i-1];//计算最优解
	}
	cout<<ans;//输出
	return 0;
}
```


---

## 作者：zengzhijie54188 (赞：0)

## 这道题不能说是很难，主要就是细节问题
### 思路
这道题要求求出交通管制长度最小长度和，也就是说，要你把浪费的管制长度调到最小，所以你先把这段路的长度算出来，再减去尽量大的浪费长度且使管制路段个数刚好为所要求个数即可。
### 提示
巧妙运用 c++ 的 STL ，sort 快排。

这道题我打算先给出代码，代码思想会在代码附加说明，在代码后面再给出对一些细节的分析，上代码（c++）
```cpp
#include<bits/stdc++.h>
using namespace std ;
bool ps ( int x , int y ) //sort的自定义函数
{
	return x > y ;
}
int a[99999] ;
int b[99999] ;
int main()
{
	int n ;
	cin >> n ;
	int m ;
	cin >> m ;
	for ( int i = 1 ; i <= n ; i++ )
	{
		cin >> a[i] ; //输入每一个坑的坐标
	}
	sort ( a+1 , a+n+1 ) ; //从小到大排序，以便求出道路的首尾
   for ( int i = 1 ; i <= n - 1 ; i++ ) //因为涉及到 i+1，所以要写成 i<=n-1
	{
		b[i] = a[i+1] - a[i] - 1 ;
	}
	sort ( b+1 , b+n, ps ) ; //把浪费的管制长度从大到小排序
     int s = a[n] - a[1] + 1 ; //求出总路长
	for ( int i = 1 ; i < m ; i++ )
	{
		s = s - b[i] ;
    }
    cout << s ;
    return 0 ; //好习惯
}
```
## 细节注意（1）
大家可能会对这三处地方产生疑惑或者没有考虑到位，为什么有的减一，有的加一，有的又不用呢？
#### 一
```cpp
b[i] = a[i+1] - a[i] - 1 ;
```
#### 二
```cpp
int s = a[n] - a[1] + 1 ;
```
#### 三
```cpp
s = s - b[i] ;
```
首先我们先来看第一个，这一个是求每一个坑之间的距离，如图：$h1$ 为我们要求的距离，但是用后者减去前者的数值确实 $h2$，所以要减去一个单位长度。

![](![](undefined) ![](https://cdn.luogu.com.cn/upload/image_hosting/qg45u0sf.png))


然后我们来看第二个，这个是要求这段路的总长，如图：$h3$ 为我们要求的长度，但是用路首减去路尾的数值却是 $h4$，所以要加上一个单位长度。
![](undefined)

![](https://cdn.luogu.com.cn/upload/image_hosting/uakigvfv.png)


最后我们来看第三个，这是要算出减去尽可能大的浪费管制长度，由于在第一个部分和第二个部分我们已经做出了处理，所以减去的已经是准确的距离，所以不用加上或减去单位长度。
## 细节注意（2）
还有一个细节问题，请看这个循环
```cpp
for ( int i = 1 ; i < m ; i++ )
```
为什么是 $i$<$m$ 呢？你可以看一下如下数学思想，你就懂了。

![](![](undefined) ![](https://cdn.luogu.com.cn/upload/image_hosting/n2kobepq.png))


希望能帮到大家！

---


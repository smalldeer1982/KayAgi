# 跳马问题

## 题目背景

在爱与愁的故事第一弹第三章出来前先练练四道基本的回溯/搜索题吧……


## 题目描述

中国象棋半张棋盘如图 $1$ 所示。马自左下角 $(0,0)$ 向右上角 $(m,n)$ 跳。规定只能往右跳，不准往左跳。比如图 $1$ 中所示为一种跳行路线，并将路径总数打印出来。

![](https://cdn.luogu.com.cn/upload/image_hosting/8gkasdvs.png)


## 说明/提示

对于 $100\%$ 的数据：$n, m\leq 18$


## 样例 #1

### 输入

```
4 8```

### 输出

```
37```

# 题解

## 作者：晓菜 (赞：92)

## 这题只是一道深搜题(异常简单[滑稽])

这题仔细想一想其实连回溯都不用，更不用二维数组

![](https://cdn.luogu.com.cn/upload/pic/450.png)

先是搜索部分，每次枚举可出现的情况

有右上，右下两个位置，每个位置有两种情况[玩过中国象棋的都知道]，看题目，不能往回走，所以：

```cpp
dfs(a+1,b+2);//a是横坐标，b是纵坐标
dfs(a+2,b+1);
dfs(a-2,b+1);
dfs(a-1,b+2);
```

终止部分也是重点！

先是当马到了正确的位置：

```cpp
if (a==n && b==m){
        t++;//找到了总数+1
}        
```

然后是当马越界时：
 
```cpp
if (a<0 || a>n || b>m) return;
//马越界的情况有三种，有行数超(正负两种)，有列数超(只有正)
```

所以深搜部分这么打：

```cpp
void dfs(int a,int b){
    if (a<0 || a>n || b>m) return;
    if (a==n && b==m){
        t++;
    }else{
        dfs(a+1,b+2);
        dfs(a+2,b+1);
        dfs(a-2,b+1);
        dfs(a-1,b+2);
    }
}
```

主程序就不多说了，主要是起始位置要定义：

```cpp
dfs(0,0);
```

下附赠完美代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,t;
void dfs(int a,int b){
    if (a<0 || a>n || b>m) return;
    if (a==n && b==m){
        t++;
    }else{
        dfs(a+1,b+2);
        dfs(a+2,b+1);
        dfs(a-2,b+1);
        dfs(a-1,b+2);
    }
}
int main(){
    cin>>n>>m;
    dfs(0,0);
    cout<<t;
    return 0;
}
```


---

## 作者：LW_h_FP (赞：26)

这题可以模拟马的走法。
马在图中只可以往右走，往右有四种方向，右上两种，右下两种，用一个数组保存走法：
```
int dx[8]={1,2,2,1},dy[8]={2,1,-1,-2};
```
再搜索马有几种方法走到终点，判断是否走到终点：
```
if(x==m&&y==n)
```
还有判断马是否越界：
```cpp
int ok(int x,int y){
	return x<=m && x>=0 && y>=0 && y<=n;
}
```
最后完整的代码：
```
#include<iostream>
using namespace std;

int dx[8]={1,2,2,1},dy[8]={2,1,-1,-2};
int n,m,ans;

int ok(int x,int y){
	return x<=m&&x>=0&&y>=0&&y<=n;
}

void f(int x,int y){
	if(x==m&&y==n)	{ ans++; return; }
	for(int i=0;i<4;i++){
		int xl=x+dx[i],yl=y+dy[i];
		if(ok(xl,yl))
			f(xl,yl);
	}
}

int main(){
	cin>>n>>m;
	f(0,0);
	cout<<ans;
}
```
ac结束，感谢支持。

---

## 作者：t162 (赞：15)

很明显的一道动态规划题目。

二维DP，$DP[i][j]$表示从起点到第$i$列第$j$行的总方案数。

根据奥数标数法(不懂可以百度)的思想，得到以下状态转移方程：

$$DP[i][j]=DP[i-1][j-2]+DP[i-1][j+2]+DP[i-2][j-1]+DP[i-2][j+1]$$

注意判断是否超出边界即可。

```cpp
#include<iostream>
using std::cin;
using std::cout;

int dp[20][20];
int main(){
    int n,m;
    cin>>m>>n;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(i==j&&j==0)dp[i][j]=1;			//循环内初始化边界
            else if(i==0&&j!=0)dp[i][j]=0;
            else{
                if(i>1){
                    if(j>0)dp[i][j]+=dp[i-2][j-1];
                    if(j!=m)dp[i][j]+=dp[i-2][j+1];
                }
                if(j>1)dp[i][j]+=dp[i-1][j-2];
                if(j<m-1)dp[i][j]+=dp[i-1][j+2];
            }
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

# 分析

上述代码中的两重循环是不能交换位置的，因为题目中提到**不准往左跳**，但**并没有规定不准往上跳**，这是本题的一大坑点。如果先遍历行的话，状态转移方程就变成了这样：
$$DP[i][j]=DP[i-2][j-1]+DP[i+2][j-1]+DP[i-1][j-2]+DP[i+1][j-2]$$
($DP[i][j]$表示从起点到第$i$行第$j$列的总方案数)。

你会发现，这时候的$DP[i][j]$已经涉及到了未处理的范围，结果自然就不对了。

血的教训。

---

## 作者：zjing (赞：11)

第一次题解啦，回溯算法




```cpp
#include<bits/stdc++.h>//头文件 
using namespace std;
int n,m,ans=0;// 长宽，答案 
int ax[4]={2,1,-1,-2};//横着的路径变化 
int ay[4]={1,2,2,1};// 竖着的路径变化 
void search(int x,int y){//深搜函数 
	if(x==n&&y==m) ans++;//达到目标 
	if(x<0||x>n||y>m) return;//越界就返回 
	else for(int i=0;i<4;i++) 
		search(x+ax[i],y+ay[i]);//继续寻找 
}
/*-----注意：这里不需要回溯，因为第二次会覆盖掉x，y的值-----------------*/ 
int main(){//低调的主函数 
	cin>>n>>m;
	search(0,0);
	cout<<ans;
	return 0;
	
}
```

---

## 作者：石破天惊 (赞：9)

**算法归类：dfs**

思路：

用x储存横轴变化，用y储存纵轴变化。

x[4]={1,2,2,1}    y[4]={-2,-1,1,2}

用i统一横纵轴变化，向四个方向移动，如果马没有出界，并且下一个点位可以跳，就将马的位置向下一个点一移动，如果不满足上述条件，就回溯。如果寻找到叶子节点，就将方案数加一。最后输出解。

程序如下（请不要抄袭）



```cpp
#include<stdio.h>
int xx[4]={1,2,2,1};
int yy[4]={-2,-1,1,2};
int a[18][18];
int m,n,sum;
void print(int x,int y)//变量跟踪器
{
    printf("%d,%d--->",x,y);
    }
void dfs(int x,int y)
{
    int i;
    if (x==n&&y==m) {sum++;}
    else 
    {
        for(i=0;i<4;i++)
        {
            if (a[x+xx[i]][y+yy[i]]==0 && x+xx[i]>=0 && x+xx[i]<=n && y+yy[i]<=m && y+yy[i]>=0)
            {
                a[x+xx[i]][y+yy[i]]=1;
                //print(x+xx[i],y+yy[i]);
                dfs(x+xx[i],y+yy[i]);
                a[x+xx[i]][y+yy[i]]=0;
            }
        }
    }
}
int main()
{
    scanf("%d%d",&m,&n);
    dfs(0,0);
    printf("%d",sum);
    return 0;
}

```

---

## 作者：decoqwq (赞：9)

这题如果数据大点，回溯肯定炸，所以我选择用递推来做，往前面的方向找，一种方法能到达就加一，看最后那个点的值是几。

下面贴代码（勿抄袭）

```cpp
#include "stdio.h"
int data[200][200]={1};//从第一个点0,0开始，0,0 即有一种方法
int main()
{
    int i,j;
    int n,m;
    scanf("%d%d",&n,&m);
    for(j=1;j<=m;j++)//第0列没有，所以从第1行开始
    {
        for(i=0;i<=n;i++)
        {       /*   往前找四个方向，四个方向的所有值加起来即为本点的值   */
            int da1=(i-2>=0&&j-1>=0)?data[i-2][j-1]:0;
            int da2=(i-1>=0&&j-2>=0)?data[i-1][j-2]:0;
            int da3=(i+2<=n&&j-1>=0)?data[i+2][j-1]:0;
            int da4=(i+1<=n&&j-2>=0)?data[i+1][j-2]:0;
            data[i][j]=da1+da2+da3+da4;
        }
    }
    printf("%d",data[n][m]);
        return 0;//开心的结束O(∩_∩)O
}
```

---

## 作者：Hanabi_BNUAZ (赞：6)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,Oufengning;//这里的"Oufengning" 代表的是输出的总数目; 
void dfs(long long i,long long j)
{
    if ((i==m)&&(j==n)) ans++;
    else if (j>n) return;
    else 
```
{//在这里的四个dfs是四次的深度搜索，不用在意它是怎么深搜的，只要知道它的四种情况
```cpp
        if (i+2<=m) dfs(i+2,j+1);//右上; 
        if (i+1<=m) dfs(i+1,j+2);//右上;
        if (i-2>=0) dfs(i-2,j+1);//左下; 
        if (i-1>=0) dfs(i-1,j+2);// 左下; 
    }
}
int main()
{
    scanf("%ld%ld",&m,&n);
    dfs(0,0); //从零开始递归其来; 
    printf("%ld\n",Oufengning);
    return 0;
}

```

---

## 作者：xdc呀 (赞：4)

# 不用二维数组
## 深搜解决问题
想法
------------
因为马 **只**可以往右走，所以我设一个a(横轴的变化)，b(纵轴的变化)。

判断a与b不可以越位即a<=m,b>=0。

深搜终止条件a==m，b==n；

模拟马的行动，即马的走法。马的走法有四种，全模拟就行了。
![](https://cdn.luogu.com.cn/upload/pic/59174.png)
```cpp
dfs(a+1,b+2);
dfs(a+2,b+1);
dfs(a+2,b-1);
dfs(a+1,b-2);
```
也就是这样。












AC代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int total=0;int n,m;
void dfs(int a,int b)
{
    if(a>m||b>n||b<0) return;
    if((a==m)&&(b==n))
    {
        total++;
        return;
    }
    else
    {
        dfs(a+1,b+2);
        dfs(a+2,b+1);
        dfs(a+2,b-1);
        dfs(a+1,b-2);
    }
}
int main()
{
    
    cin>>n>>m;
    dfs(0,0);
    cout<<total;
    return 0;
}
```


---

## 作者：EarthGiao (赞：4)

# 潇洒の开始

因为马只能向右走 所以下界不能控制 可以下去又上来
 
但右界是可以控制的 简单地说 马不能走到终点右边 

所以 右边能达到的最大列数直接定为End_Y 也就是终点的纵坐标

否则很有可能错误或超时

直接贴c++代码 记忆化搜索

```cpp
#include <iostream>
#include <cstdio>
using namespace std ;
int m , n , startx , starty , endx , endy ;
#define M 301
#define N 301
int a[M][N] , f[M][N] ;
bool in(const int& i , const int& j){
    return (i >= 1 && i <= n && j >= 1 && j <= m) ? true : false ;
}
int dfs(int x , int y){
    if (x == endx && y == endy) return 1 ;
    if (f[x][y] > 0) return f[x][y] ;
    int tx , ty ;
    tx = x + 1 , ty = y - 2 ;
    if (in(tx , ty)) f[x][y] += dfs(tx , ty) ;
    tx = x + 2 , ty = y - 1 ;
    if (in(tx , ty)) f[x][y] += dfs(tx , ty) ;
    tx = x + 2 , ty = y + 1 ;
    if (in(tx , ty)) f[x][y] += dfs(tx , ty) ;
    tx = x + 1 , ty = y + 2 ;
    if (in(tx , ty)) f[x][y] += dfs(tx , ty) ;
    return f[x][y] ;
}
int main(){
    std::ios::sync_with_stdio(false) ;
    cin >> m >> n ;
    cin >> startx >> starty ;
    cin >> endx >> endy ;
    n = endy ;
    cout << dfs(startx , starty) % 123465 ;
    return 0 ;
}
```

# 完美の结束

---

## 作者：Randyhoads (赞：4)

感觉这道题像DP（蒟蒻把递推也归入了DP）

用dp[i][j]表示走到i,j的方案数

初始化dp[0][0]=1;

用nx,ny数组记录马的走法。。。

dp[i][j]+=dp[i-1][j-2]+dp[i-2][j-1]+dp[i-2][j+1]+dp[i-1][j+2];

注意的是，数组要开到21，因为在循环内最多可以到20，血的教训。。。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int total=0;
int dp[21][21]={0};
int nx[4]={1,2,2,1};
int ny[4]={2,1,-1,-2};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin>>n>>m;
    dp[0][0]=1;//初始化
    for(int i=1;i<=m;i++)
    {
        for(int j=0;j<=n;j++)
        {
            for(int h=0;h<=3;h++)
            {
                if(i>=nx[h]&&j>=ny[h])
                    dp[i][j]+=dp[i-nx[h]][j-ny[h]];//DP？？？
            }
        }
    }
    cout<<dp[m][n];
    return 0;
}

```

---

## 作者：_Qer (赞：3)

本来想用动态规划搞的  

但是看了一下数据  

并没用这个必要  

再说了我也不怎么会  

直接递推（递归）  

如果到终点就答案加一  

否则继续走（超界就返回）  

用两个数组存4种走法  

本来有8种，因为只能往右，所以4种  

这里的递推（递归）函数可以有两种写法  

一种是走下一步前判断能不能走  

另一种是先走，再看现在的点是否合法  

其实都差不多啦  

```cpp

#include<iostream>
using namespace std;
int n,m,total;//分别为y,x坐标和方法总数
int xg[4]={1,1,2,2},yg[4]={-2,2,-1,1};//存储四种走法（只能向右走）
void f(int x,int y){//函数
    if(x==m&&y==n){//如果已经到达终点
        ++total;//总数+1
        return;
        //其实不return也没问题，因为只能右走，所以下一步无论怎么走都超界
    }
    for(int i=0;i<4;++i){//判断四种走法
        if(x+xg[i]<=m&&y+yg[i]<=n&&y+yg[i]>=0){//可以就继续走
            f(x+xg[i],y+yg[i]);//下一步
        }
    }
}
/*
函数还有另一种写法
void f(int x,int y){
    if(x>m||x<0||y>n||y<n){
        return;
    }
    if(x==m&&y==n){
        ++total;
    }
    for(int i=0;i<4;++i){
        f(x+xg[i],y+yg[i]);
    }
}
*/
int main(){
    cin>>n>>m;//y,x坐标
    f(0,0);//从起点开始
    cout<<total;//方法总数
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：3)

摘自 http://bluebag.sinaapp.com/%e6%b4%9b%e8%b0%b7%e9%a2%98%e8%a7%a3%e3%80%90p1644-%e8%b7%b3%e9%a9%ac%e9%97%ae%e9%a2%98%e3%80%91%e3%80%90%e9%9a%be%e5%ba%a6%ef%bc%9a%e5%85%a5%e9%97%a8%e6%99%ae%e5%8f%8a-%e3%80%91/


这题虽然说是回溯，其实递推就可以了。因为在题中，马只能往右走。


这题和洛谷p1002 过河卒类似。


本题递推式：a[I,j]=a[i-1,j-2]+a[i-2,j-1]+a[i+1,j-2]+a[i+2,j-1];//这几个点都可到达a[i,j]


因此我们要求第j列的任何一项必须要知道第i-1列和第i-2列的数。所以说，递推是一列一列往下推，每一列从第0行开始往第N行推。


注意：马自左下角(0,0)向右上角（m，n）跳，不是(1,1)。

```delphi

var a:array[-1..21,-1..21] of longint;
    n,m,i,j:longint;
begin
    read(n,m);
   a[0,0]:=1;
   for j:=1 to m-1 do
       for i:=0 to n do
        begin
            a[i,j]:=a[i-1,j-2]+a[i-2,j-1]+a[i+1,j-2]+a[i+2,j-1];
        end;
    write(a[n-1,m-2]+a[n-2,m-1]);
end.

```

---

## 作者：JackcreaM (赞：2)

这是一道经典的题目。这里我推荐这种非常经典而简单的方法

因为马马在棋盘里只能往右走，联系生活可得，马马在这只有4种走法

认真阅读题目后，now，我们 can 做 it ！！！~~渣渣英语深表无奈~~

上代码：

```
#include<bits/stdc++.h>
using namespace std;//万能头
int ans=0,m,n,can[105][105];//相当于建了一个map
void sb(int x,int y)
{
	int i,j;
	for(i=1;i<=4;i++)//遍历4种方向
	{
		if(x==n&&y==m)//马马跑到了的话
		{
			ans++;    //方案数++
			return;
		}
        //下面是回溯整体。道理简单，但打代码时要注意
		if(i==1&&can[x+2][y+1]==0&&x+2<=n&&y+1<=m)
		{can[x+2][y+1]=1;sb(x+2,y+1);can[x+2][y+1]=0;}
		if(i==2&&can[x+1][y+2]==0&&x+1<=n&&y+2<=m)
		{can[x+1][y+2]=1;sb(x+1,y+2);can[x+1][y+2]=0;}
		if(i==3&&can[x-2][y+1]==0&&x-2>=0&&y+1<=m)
		{can[x-2][y+1]=1;sb(x-2,y+1);can[x-2][y+1]=0;}
		if(i==4&&can[x-1][y+2]==0&&x-1>=0&&y+2<=m)
		{can[x-1][y+2]=1;sb(x-1,y+2);can[x-1][y+2]=0;}
	}//4方向判断
}
int main()//主程序
{
	cin>>n>>m;
	sb(0,0);
	cout<<ans;
	return 0;
}
```
好了，是不是很简单呢？？

让我们骑着马马在编程的路上走下去吧！！

~~（马：QAQ）~~

---

## 作者：doby (赞：2)

这题完全可以~~dp~~递推

f[0][0]=1

就可以有~~状态转移方程~~

```cpp
f[i+2][j+1]+=f[i][j]
f[i+1][j+2]+=f[i][j]
f[i-1][j+2]+=f[i][j]
f[i-2][j+1]+=f[i][j]
```
最后答案就在f[n][m]
这里提供了dfs代码

递推太好码了，没写……

dfs解法：

```cpp
#include<iostream>    
#include<cstdlib>    
using namespace std;    
int a[20][20],fa=0,z,za,zb;    
int fx[5]={0,-2,-1,1,2},    //只有四个方向，不用判重复到同一点
    fy[5]={0,1,2,2,1};    
int n,m,qx,qy,zx,zy,x1,y1,pd=1;    
void find(int i,int j)    
{    
    if(i==n+1&&j==m+1)  
    {  
        pd=0;  
        fa++;  
        return;  
    }  
    for(int k=1;k<=4;k++)  
    {  
        x1=i+fx[k];y1=j+fy[k];  
        if(x1>0&&y1>0&&x1<=n+1&&y1<=m+1&&a[x1][y1]){find(x1,y1);}  
    }  
}  
int main()  
{          
    cin>>n>>m;          
    for(int i=1;i<=n+1;i++){for(int j=1;j<=m+1;j++){a[i][j]=1;}} 
    find(1,1);     
    cout<<fa;  
    return 0;          
}
```

---

## 作者：RED_Singer (赞：1)

# HI
## 这题用深搜就可以了
用两个数组模拟下一步的坐标:
```cpp
x[4]={-2,-1,1,2},y[4]={1,2,2,1}
```
控制下一步:
```cpp
for(int i=0;i<4;++i)
```
判断下一步是否走过或超界:
```cpp
int u=x[i]+h,v=y[i]+l;
if(u<=n&&u>=0&&v<=m&&v>=0&&a[u][v]==0)
```
如果满足就进入下一步:
```cpp
a[u][v]=1;
DSF(u,v);
a[u][v]=0;
```
代码如下:
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<string>
using namespace std;
bool a[19][19]={0};
int x[4]={-2,-1,1,2},y[4]={1,2,2,1},n,m,total=0;
void DSF(int h,int l)
{
	if(h==n&&l==m)
	{
		total++;
		return;
	}	//累加方案数并返回
	for(int i=0;i<4;++i)
	{
		int u=x[i]+h,v=y[i]+l;
		if(u<=n&&u>=0&&v<=m&&v>=0&&a[u][v]==0)	//判断
		{
			a[u][v]=1;
			DSF(u,v);	//回溯
			a[u][v]=0;
		} 
	}
}
int main()
{
	cin>>n>>m;
	a[0][0]=1;	//将起始坐标赋值为1
	DSF(0,0);	//开始深搜
	cout<<total;
	return 0;
}
```
### baibai


---

## 作者：HeartBlock_Love (赞：1)

题目就不多解释了，注释请看代码

```
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<iomanip>
using namespace std;
int u[8]={1,2,2,1,-1,-2,-2,-1},                //8个方向上的x,y增量
    v[8]={-2,-1,1,2,2,1,-1,-2};
int a[100][100]={0},num=0;                 //记每一步走在棋盘的哪一格和棋盘的每一格有
                                                            //没有被走过
bool b[100][100]={0};
int search(int,int,int);                           //以每一格为阶段，在每一阶段中试遍8个方向
int print();                                            //打印方案
int main()
{ 
   a[1][1]=1;b[1][1]=1;                            //从(1,1)第一步开始走
   search(1,1,2);                                    //从(1,1)开始搜第2步该怎样走
   cout<<num<<endl;                            //输出总方案(304)
}
int search(int i,int j,int n)
{
  int k,x,y;                                              //这三个变量一定要定义局部变量
  if (n>25) {print();return 0;}                  //达到最大规模打印、统计方案
  for (k=0;k<=7;k++)                             //试遍8个方向
   {
     x=i+u[k];y=j+v[k];                            //走此方向，得到的新坐标
     if (x<=5&&x>=1&&y<=5&&y>=1&&(!b[x][y]))
      {                                                    //如果新坐标在棋盘上，并且这一格可以走
         b[x][y]=1; 
         a[x][y]=n;
         search(x,y,n+1);                        //从(x,y)去搜下一步该如何走
         b[x][y]=0;
         a[x][y]=0; 
      }
   }
}
int print()
{
   num++;                                            //统计总方案
   if (num<=5)                                      //打印出前5种方案
    {
       for (int k=1;k<=5;k++)                  //打印本次方案
        {
          for (int kk=1;kk<=5;kk++)
            cout<<setw(5)<<a[k][kk];
          cout<<endl;  
        }
    }
}

```


---

## 作者：eaten_apple (赞：1)

## **一道水题竟然活活折磨了我半个小时！！！！**
各位C党看过来。

话不多说，开始深度优先搜索大法。

有四个方向，然后就是有越界情况……

直接附上~~~~AC~~代码~~（注释在代码里）
```cpp
#include<bits/stdc++.h>//头文件 
using namespace std;
int dx[4]={2,1,-1,-2};//四个方向 
int dy[4]={1,2,2,1};//四个方向 
int ans,m,n;//ans记录最后答案，m为行，n为列  
bool used[20][20];//used[i][j]标记是否走过 
bool print(int x,int y)//打印函数 
{
	if(x>=0 && x<=m && y>=0 && y<=n && !used[x][y])
		return true;
	return false;
}
void dfs(int x,int y)
{
	if(x==m && y==n)//如果当前位置在边界 
	{
		ans++;//ans加1 
		return;//返回 
	}
	for(int i=0;i<4;i++)//枚举四个方向 
	{
		if(print(x+dx[i],y+dy[i]))
		{
			used[x][y]=true;//记为走过 
			dfs(x+dx[i],y+dy[i]);//调用当前位置 
			used[x][y]=false;//回溯 
		}
	}
}
int main()
{
	cin>>m>>n;//输入行和列 
	dfs(0,0);
	cout<<ans<<endl;//输出答案 
	return 0;
}
```
哈哈，骗你的(可直接Ctrl+C)

---

## 作者：ljw2005 (赞：1)

``` cpp
一道很简单的dfs
其实这道题目不用判断之前是否走过
但我还是用了
这是通常的写法
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,s;
const int dx[]={-2,-1,1,2},dy[]={1,2,2,1};//定义马跳的位置
bool ok[20][20];
void dfs(int x,int y){
	if(x==n&&y==m){//走到了
		s++;
		return;//返回
	}
	for(int i=0;i<4;i++){//四个方向
		int fx=x+dx[i],fy=y+dy[i];//位置
		if(fx<0||fx>n||fy<0||fy>m||ok[fx][fy]) continue;//判断越界和是否走过
		ok[fx][fy]=1;//置为走过
		dfs(fx,fy);//从哪个位置继续搜索
		ok[fx][fy]=0;//置为未走过
	} 
}
int main()
{
	scanf("%d%d",&n,&m);
	ok[0][0]=1;//起始位置置为走过
	dfs(0,0);
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：yangshirui (赞：1)

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<iomanip>
using namespace std;
int u[8]={1,2,2,1,-1,-2,-2,-1},                //8个方向上的x,y增量
    v[8]={-2,-1,1,2,2,1,-1,-2};
int a[100][100]={0},num=0;                 //记每一步走在棋盘的哪一格和棋盘的每一格有
                                                            //没有被走过
bool b[100][100]={0};
int search(int,int,int);                           //以每一格为阶段，在每一阶段中试遍8个方向
int print();                                            //打印方案
int main()
{ 
   a[1][1]=1;b[1][1]=1;                            //从(1,1)第一步开始走
   search(1,1,2);                                    //从(1,1)开始搜第2步该怎样走
   cout<<num<<endl;                            //输出总方案(304)
}
int search(int i,int j,int n)
{
  int k,x,y;                                              //这三个变量一定要定义局部变量
  if (n>25) {print();return 0;}                  //达到最大规模打印、统计方案
  for (k=0;k<=7;k++)                             //试遍8个方向
   {
     x=i+u[k];y=j+v[k];                            //走此方向，得到的新坐标
     if (x<=5&&x>=1&&y<=5&&y>=1&&(!b[x][y]))
      {                                                    //如果新坐标在棋盘上，并且这一格可以走
         b[x][y]=1; 
         a[x][y]=n;
         search(x,y,n+1);                        //从(x,y)去搜下一步该如何走
         b[x][y]=0;
         a[x][y]=0; 
      }
   }
}
int print()
{
   num++;                                            //统计总方案
   if (num<=5)                                      //打印出前5种方案
    {
       for (int k=1;k<=5;k++)                  //打印本次方案
        {
          for (int kk=1;kk<=5;kk++)
            cout<<setw(5)<<a[k][kk];
          cout<<endl;  
        }
    }
}

```

---

## 作者：shenyufan (赞：1)

超短代码如下：

```cpp
var n,m,x1,x2,y1,y2,i,j:longint;
f:array[-2..20,-2..20] of longint;//范围应是[-2..20,-2..20]，否则会爆。。。
begin
readln(n,m);
f[0,0]:=1;//初始化
for i:=0 to m do
  for j:=0 to n  do
    f[i,j]:=f[i,j]+f[i-1,j-2]+f[i-1,j+2]+f[i-2,j-1]+f[i-2,j+1];//只有f[i-1,j-2],f[i-1,j+2],f[i-2,j-1],f[i-2,j+1]能跳到当前位置发f[i,j]
writeln(f[m,n]);//输出
end.
注：本题i表示的是列，j表示的的是行。。。
```

---

## 作者：iCaesar (赞：1)



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<ctime>
#include<cmath>
#include<fstream>
#include<algorithm>
#include<map>
#include<vector>
#include<queue>
#include<deque>
#include<cstdlib>
#include<sstream>
//#include<bits/stdc++.h>
using namespace std;
int m,n,x[4]={1,1,2,2},y[4]={-2,2,-1,1},a[10001][2],ans=0;//这两个x,y数组一一对应，取相同下标时就是横纵坐标的变化量 ，很精髓，用来模拟跳法，而且把横纵变化量分开了，便于保存结果                                             
void dfs(int k);
void print(int);
int main()
{
    int i,j;
    cin>>n>>m;
    a[1][0]=0;a[1][1]=0;//行记录步数，列记录位置，a[1][0]表示第 1步所在的横坐标， a[1][1]表示 第 1步所在的纵坐标
    dfs(2);
    //cout<<"The Total is "<<ans<<endl;
    cout<<ans<<endl;
}
void dfs(int k)
{
    int i,j;
    for(i=0;i<4;i++)
    {
        if(a[k-1][0]+x[i]<=m&&a[k-1][1]+y[i]>=0&&a[k-1][1]+y[i]<=n)//通过改变i的数值，配合x,y数组，模拟马的可选择的位置 
        {
            a[k][0]=a[k-1][0]+x[i];
            a[k][1]=a[k-1][1]+y[i];
            if(a[k][0]==m&&a[k][1]==n) print(k);
            else dfs(k+1);
        }
    }
}
void print(int k)
{
    ans++;
/*    for(int i=1;i<k;i++)
    cout<<a[i][0]<<','<<a[i][1]<<"->";
    cout<<a[k][0]<<','<<a[k][1]<<endl;
```
\*/
}

---

## 作者：ZYR_ (赞：1)

我是认认真真的好学生，听从题目的意见，遵从题目的指示……

总之，我用的是回溯（绝不违反题目要求）。

请看代码如下：



```cpp
var
    went:array[0..18,0..18]of boolean;   //记录地图上的这个点是否走过（went，go的过去式）
    n,m:integer;
    go:array[1..4,1..2]of integer=((-2,1),(-1,2),(1,2),(2,1));   //可以走的四个方向
    total:longint;     //答案总数
procedure try(i,j:longint);    //回溯
var    
    k:integer;
begin    //回溯标准框架，不懂自己看书
    if (i=n) and (j=m) then begin inc(total); exit; end;   //边界
    for k:=1 to 4 do    
        if (i+go[k,1]>=0) and (j+go[k,2]>=0) and (i+go[k,1]<=n) and (j+go[k,2]<=m) and (not went[i+go[k,1],j+go[k,2]]) then  //回溯条件
        begin   //回溯
            went[i+go[k,1],j+go[k,2]]:=true;
            try(i+go[k,1],j+go[k,2]);     
            went[i+go[k,1],j+go[k,2]]:=false;
        end;
end;
begin
    readln(n,m);
    fillchar(went,sizeof(false),false);   //初始化
    total:=0;
    try(0,0);   //开始回溯
    writeln(total);
end.
题目简单，一遍AC，这是一道练回溯的好题，建议初学回溯者练习！（鄙人愚见）
```

---

## 作者：Drug__Lover (赞：1)


```cpp
#include<iostream>
using namespace std;
int a[20][20];//记录棋盘 
int m,n,sum;
void p(int x,int y)
{
    if(x==m&&y==n)//判断若跳到指定位置方法就加一 
    {
        sum++;
        return;
    }
    if(a[x][y]==0)//判断此位置是否跳过 
    {    
        a[x][y]=1;//标记跳过，避免重复跳 
        if(x+2<=m&&y+1<=n) p(x+2,y+1);//跳马的四个方向 
        if(x+1<=m&&y+2<=n) p(x+1,y+2);
        if(x-2>=0&&y+1<=n) p(x-2,y+1);
        if(x-1>=0&&y+2<=n) p(x-1,y+2);
        a[x][y]=0;//清零 
    }
}
int main()
{
    cin>>m>>n;
    p(0,0);//开始搜索 
    cout<<sum;
    return 0;
}
```

---

## 作者：蓝莲花__ (赞：0)

# 这道题标签虽然是深度优先搜索，
## 但显然我们用动态规划DP快许多。

#### dp[i][j]表示搜索到(i,j)的方案总数

我们可以用dx[],dy[]数组表示出之前的状态

```cpp
for (int k=1;k<=4;k++)
{
	int tx=i+dx[k];
	int ty=j+dy[k];
	if (0<=tx && tx<=m && 0<=ty && ty<=n)
		dp[i][j]+=dp[tx][ty];
}

用tx，ty表示由上一个状态转移过来，直接将方案数累加就行了

题目中说只能向右边跳，所以这个dp是可行的

时间复杂度O（m*n）

常数只有4

AC代码：```



#include<iostream>
#include<cstdio>

using namespace std;
const int mx=20;
int dp[mx][mx];
int dx[5]={0,-1,-2,-2,-1};
int dy[5]={0,-2,-1,1,2};
int n,m;

int main()
{
	cin>>n>>m;
	dp[0][0]=1;
	for (int i=0;i<=m;i++)//横坐标 
		for (int j=0;j<=n;j++)
		{
			for (int k=1;k<=4;k++)
			{
				int tx=i+dx[k];
				int ty=j+dy[k];
				if (0<=tx && tx<=m && 0<=ty && ty<=n)
					dp[i][j]+=dp[tx][ty];
			}
		}
//	for (int i=n;i>=0;i--)
//	{
//		for (int j=0;j<=m;j++) cout<<dp[j][i]<<' ';cout<<endl;
//	}
	cout<<dp[m][n];
	return 0;
}
```



```


---


# 校门外的树（增强版）

## 题目描述

校门外马路上本来从编号 $0$ 到 $L$，每一编号的位置都有一棵树。有砍树者每次从编号 $A$ 到 $B$ 处连续砍掉每一棵树，就连树苗也不放过（记 `0 A B`，含 $A$ 和 $B$）；幸运的是还有植树者每次从编号 $C$ 到 $D$ 中凡是空穴（树被砍且还没种上树苗或树苗又被砍掉）的地方都补种上树苗（记 `1 C D`，含 $C$ 和 $D$）；问最终校门外留下的树苗多少棵？植树者种上又被砍掉的树苗有多少棵？

## 说明/提示

对于 $100 \%$ 的数据，$1 \le L \le 10000$，$1 \le N \le 100$。

## 样例 #1

### 输入

```
10 3
0 2 6
1 1 8
0 5 7
```

### 输出

```
3
2
```

# 题解

## 作者：应吟吟 (赞：67)

## 首先提一下本题的几个容易忽略的~~坑点~~导致错误的地方吧

### 1.

> 问最终校门外留下的树苗多少棵？

是不是一开始看到时就不经过脑子的直接输出校门口的树的棵数啦(其实题目有说一开始就存在的是树，后面种下去的是树苗)~~(然后你就会获得80或者20分的好成绩)，可能只有我一个人看错了吧$QWQ$~~

### 2.

> 植树者种上又被砍掉的树苗有多少棵？

这个可能错的人比较少，它的意思是每逢砍树者把树苗砍了就把$ans++$，并不是在一个树坑中只能$ans++$一次

### 3.

> 校门外马路上本来从编号0到$L$，每一编号的位置都有1棵树。

把编号看错的应该不止我一个人吧(~~试图自我安慰~~)



终上所述，审题一定要好好审，不然原来完全对的程序也会爆零(我才不会告诉你我为了找出这些坑点给洛谷提供了一页的提交记录呢)

***

## 再养成一个好习惯

做题前先看看一下数据的大小

这题的数据是$L（1 <= L <= 10000）$和 $N（1 <= N <= 100）$

哎，$O(n^2)$的模拟好像可以$*$过去？

那来吧，写模拟(可以写模拟的就不要写线段树了嘛，线段树那个码量不敢恭维)

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define ll long long//随手long long好习惯

using namespace std;

const ll FFF=10000+5;

ll l,n;
bool opt;//判断是砍树还是种树
ll a,b;
ll flag[FFF];//flag=1时是树(就是一开始就存在的)，flag=2时是树苗(就是后来种下的)，flag=0时是空气(空坑)
ll ans_1,ans_2;//ans_1记录最终校门外留下的树苗棵数，ans_2记录植树者种上又被砍掉的树苗棵数

int main()
{
    //if(fopen(".in", "r"))
    //{
    //	freopen(".in", "r", stdin);
    //	freopen(".out", "w", stdout);
    //}
    ios::sync_with_stdio(false);//关闭流同步，让cin、cout变得和scanf、printf一样快
    cin>>l>>n;
    for(int i=0;i<=l;++i)//记住编号从0开始，到l结束
    {
        flag[i]=1;//初始化，把树都种上
    }
    for(int i=0;i<n;++i)
    {
        cin>>opt>>a>>b;
        if(opt==0)//如果是砍树
        {
            for(int j=a;j<=b;++j)//那就砍呗，从a到b
            {
                if(flag[j]==2)//如果砍的是树苗
                {
                    ans_2+=1;//ans_2++
                }
                flag[j]=0;//让flag=0，即记为空坑
            }
        }
        else//如果是种树
        {
            for(int j=a;j<=b;++j)
            {
                if(flag[j]==0)//如果遇到一个空坑
                {
                    flag[j]=2;//就把树苗种上，把flag变为2(注意，是树苗了，不能把flag变成1)
                }
            }
        }
    }
    for(int i=0;i<=l;++i)//最后处理
    {
        if(flag[i]==2)//如果校门口有树苗的话
        {
            ans_1+=1;//ans_1++
        }
    }
    cout<<ans_1<<endl<<ans_2;//输出，完结撒花
    return 0;
}
```



---

## 作者：Mizuhara (赞：38)

楼下的线段树写的都太过麻烦，这是因为楼下的线段树均为及时更新答案。

但是，询问只有一次，我们不需要费力对每次询问维护答案。

对于第一问，留下的树苗数等于：留下的（树与树苗）总数减去留下的（树）的总数。

对于v第二问，种上又被拔掉的树苗数等于：被砍掉的（树与树苗）总数减去被砍掉的（树）的总数。

那么我们只需要维护有多少（树）被砍掉和有多少（树与树苗）被砍掉就好了。

对于前者，我们只需建立一颗线段树，无视种树苗操作，每次统计被砍掉多少即可。

对于后者，我们也建立一颗线段树，同时维护种树与砍树，每次统计成功砍掉多少（树与树苗）即可。

```
#include<iostream>
#include<cstring>
#include<cstdio>
#define lson o<<1
#define rson o<<1|1
#define mid ((l+r)>>1)
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int maxn=11111;

/*
2025.1.11 已更新
tree[0]维护的是树和树苗，tree[1]维护的是树。
tree[0].Ans,tree[1].Ans分别表示总共被砍掉的树与树苗/树的总数。
*/

struct Segtree {
	int sum[maxn*4], ly[maxn*4], Ans;
	Segtree() {
		Ans = 0;
		memset(ly, 0, sizeof(ly));
		memset(sum, 0, sizeof(sum));
	}
	void build(int o, int l, int r) {
		if(l == r){
			sum[o] = 1;
			return;
		}
		build(lson, l, mid);
		build(rson, mid+1, r);
		sum[o] = sum[lson] + sum[rson];
	}
	void down(int o, int l, int r) {
		if(ly[o] == 1){
			ly[lson] = 1;
			ly[rson] = 1;
			sum[lson] = mid-l+1;
			sum[rson] = r-mid;
		}
		if(ly[o] == -1) {
			ly[lson] = -1;
			ly[rson] = -1;
			sum[lson] = 0;
			sum[rson] = 0;
		}
		ly[o] = 0;
	}
	void zhong(int o, int l, int r, int L, int R) {
		if(L<=l && r<=R) {
			ly[o] = 1;
			sum[o] = r-l+1;
			return;
		}
		down(o, l, r);
		if(L <= mid) zhong(lson, l, mid, L, R);
		if(mid+1 <= R) zhong(rson, mid+1, r, L, R);
		sum[o] = sum[lson] + sum[rson];
	}
	void cut(int o, int l, int r, int L, int R) {
		if(L<=l && r<=R) {
			Ans += sum[o];
			ly[o] = -1;
			sum[o] = 0;
			return;
		}
		down(o, l, r);
		if(L <= mid) cut(lson, l, mid, L, R);
		if(mid+1 <= R) cut(rson, mid+1, r, L, R);
		sum[o] = sum[lson] + sum[rson];
	}
} tree[2];

int n, m;
int main() {
	scanf("%d%d", &n, &m);
	n++;
	tree[0].build(1, 1, n);
	tree[1].build(1, 1, n);
	rep(i, 1, m){
		int ops, l, r;
		scanf("%d%d%d", &ops, &l, &r);
		l++, r++;
		if(ops == 0) tree[0].cut(1, 1, n, l, r), tree[1].cut(1, 1, n, l, r);
		if(ops==1) tree[0].zhong(1, 1, n, l, r);
	}
	cout<< tree[0].sum[1] - tree[1].sum[1] <<endl;
	cout<< tree[0].Ans - tree[1].Ans;
	return 0;
}
```

---

## 作者：ghj1222 (赞：35)

这种线段树的题可以用STL水一发
bitset
bitset实际上就是布尔数组，但是我们用它是因它比实际上的布尔数组节省八倍空间，(因为布尔数组用8bit存储一个元素，而此物只用1bit)
一些操作
若a,b是两个bitset
可以用：
```
bitset<一个常量>a;
//开一个存储0..一个常量-1的bitset
bitset<一个常量>b(一个只包含'0'和'1'的string);
a^=b
a&=b
a|=b
a<<=一个数
a>>=一个数
~a
a<<一个数
a>>一个数
a==b
a!=b
a&b
a|b
a^b
以上操作类比整数位运算
获取单个元素的引用(并改变值)
a[num]=0
a[num2]=1
然后是set和reset:
a.set()//初始化为1
a.reset()//初始化为0
a.set(num)//将a[num]变为1
a.reset(num)//将a[num]变为0
还有些奇怪的东西：
a.flip()//顾名思义
a.flip(num)//顾名思义
a.any()//返回是否有1
a.none()//返回是否没有1
a.count()//返回1的个数
a.to_ulong()//返回转化为unsigned long的结果，超出范围报错。
a.to_ullong()//同上，返回转化为ull的
当然还有STL清一色的
a.size()//返回大小，也就是位数

```
废话完毕，开始正题，

由题目可以知道我们的每一个位置可以是树，树苗，空气。所以根据信息学的某个定理我们可以开两个bool数组存状态，为了方便我们让(x,y)表示某一个位置的状态，(1,1)为树，(1,0)为树苗，(0,0)为空气，题中需要我们1.砍树，让x=0,y=0。2.判断是否为树苗，返回x XOR y即可。3.把空气变成树苗，只需要让x=1，这样如果x=1且y=1，或者是x=1且y=0，这样他们还是原样，如果x=0且y=0，他就变成x=1且y=0，空气变成了树苗了。

没砍一次树判断一下x XOR y，也就是是否为树苗，如果是的话ans2++。
整个过程完成统计树苗的数量，也就是累加所有的x XOR y

代码、
```cpp
#include <cstdio>
#include<iostream>
#include<bitset> 
using namespace std;
bitset<10011>a,b;
int main()
{
	int l,n;
	scanf("%d%d",&l,&n);
	a.set();
	b.set();
	//(0,0)空穴 (1,1)树 (1,0)树苗 
	int x,y,z;
	int ans1=0,ans2=0;
//	cout<<a<<endl<<b<<endl; 
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(x==0)
		{
			for(int i=y;i<=z;i++)
			{
				ans2+=a[i]^b[i];
				a.reset(i);
				b.reset(i);
			}
		}
		if(x==1)
			for(int i=y;i<=z;i++)
				a.set(i);
//		cout<<a<<endl<<b<<endl; 
	}
	for(int i=0;i<=l;i++)
		ans1+=a[i]^b[i];
	printf("%d\n%d\n",ans1,ans2);
	return 0; 
}

```
 

---

## 作者：ElevenX (赞：19)

这道题可以用线段树或树状数组做，但由于数据比较水，所以纯模拟也是可以过地。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],ans1,ans2;//ans1是拔去树苗的数量
int main()
{
    int L,n;
    cin>>L>>n;
    memset(a,1,sizeof(a));
    for(int i=1;i<=n;i++)
    {
        int k,t1,t2;
        scanf("%d%d%d",&k,&t1,&t2);
        if(k==0)
        {
            for(int j=t1;j<=t2;j++)
            {
                if(a[j]==2)
                    ans1++;
                a[j]=0;
            }
        }
        else
        {
            for(int j=t1;j<=t2;j++)
            {
                if(a[j]==0)
                    a[j]=2;
            }
        }
    }
    for(int i=0;i<=L;i++)
        if(a[i]==2)
            ans2++;
    cout<<ans2<<endl<<ans1;
    return 0;
}

```

---

## 作者：Rainybunny (赞：12)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$luogu$](https://www.luogu.org/problem/P1276).
# 题解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写线段树干嘛, 珂朵莉树多好呢!  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好像题解里还没有珂朵莉树的做法, 考虑到这里新萌比较多, 想深入学习珂朵莉树的同学可以看[我的博客](https://krain.blog.luogu.org/Chtholly-Tree).  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在珂朵莉树中, 我们令区间的值$Val=0/1/2$, 分别表示这个区间没有树; 全部是老树; 全部是树苗. 对于砍树操作, 其实就是先暴力拿出每段区间统计将被砍掉的树苗个数, 然后区间推平. 对于植树操作, 我们不能直接推平, 因为这会把一些老树误认为树苗, 而直接修改每段$Val=0$的区间的值即可.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就上代码吧!
# 代码
```cpp
#include <set>
#include <cstdio>

#define Int register int

using namespace std;

int L, N, Ans2; // L, N如题目描述, Ans2是第二个答案.

class Chtholly_Tree { // 封装版珂朵莉树.
private:
	struct Node { // 结点.
		int l, r;
		mutable int Val; // Val=1表示是一开始就有的树, Val=0表示被砍掉了, Val=2表示是新栽的树.
		friend inline bool operator < ( const Node a, const Node b ) { return a.l < b.l; }
	};
	set<Node> S;
	typedef set<Node> :: iterator IT;

public:
	inline void Init () { S.insert ( { -1, L + 1, 1 } ); } // 注意这里要从-1到L+1, 避免Split的时候出现奇怪的错误.
	inline IT Split ( const int Indx ) { // Split分裂区间.
		IT it = S.lower_bound ( { Indx, 0, 0 } );
		if ( it -> l == Indx ) return it;
		-- it;
		int l = it -> l, r = it -> r, v = it -> Val;
		S.erase ( it ), S.insert ( { l, Indx - 1, v } );
		return S.insert ( { Indx, r, v } ).first;
	}
	inline void Cut ( const int l, const int r ) { // 砍树, 类似于推平操作.
		IT rit = Split ( r + 1 ), lit = Split ( l );
		for ( ; lit != rit; ++ lit ) Ans2 += ( lit -> Val == 2 ) * ( lit -> r - lit -> l + 1 );
		rit = Split ( r + 1 ), lit = Split ( l );
		S.erase ( lit, rit ), S.insert ( { l, r, 0 } ); // 推平, 保证复杂度 ( 虽然暴力都能过 ).
	}
	inline void Plant ( const int l, const int r ) { // 栽树, 注意这里不能直接推平, 不然会把原来有的树算成树苗.
		IT rit = Split ( r + 1 ), lit = Split ( l );
		for ( ; lit != rit; ++ lit ) {
			if ( ! lit -> Val ) {
				lit -> Val = 2;
			}
		}
	}
	inline int Total ( const int l, const int r ) { // 统计树苗.
		int ret = 0;
		IT rit = Split ( r + 1 ), lit = Split ( l );
		for ( ; lit != rit; ++ lit ) ret += ( lit -> Val == 2 ) * ( lit -> r - lit -> l + 1 );
		return ret;
	}
} CT;

inline void Work () {
	scanf ( "%d %d", &L, &N );
	CT.Init (); // 记得初始化.
	for ( Int opt, l, r; N --; ) {
		scanf ( "%d %d %d", &opt, &l, &r );
		if ( opt ) CT.Plant ( l, r );
		else CT.Cut ( l, r );
	}
	printf ( "%d\n%d\n", CT.Total ( 0, L ), Ans2 );
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：11)

这是一道水题，虽然是升级版的，但是开数组模拟就够了，并不需要用到线段树……

```delphi

var l,n,zs,i,j,s,x,y,z:longint;
    b:array[0..10001] of 0..3;
begin
    read(l,n);
    s:=0;
    zs:=0;
    fillchar(b,sizeof(b),1);
    for i:=1 to n do
    begin
    read(x,y,z);
    case x of
        0:begin
                    for j:=y to z do
                    begin
                            if b[j]=2 then begin dec(s);inc(zs); end;
                        b[j]:=0
                end; end;
                    1:begin
              for j:=y to z do
              begin
                  if b[j]=0 then begin inc(s);
                  b[j]:=2;            end;
              end;
          end;
    end;
    end;
    writeln(s);
    writeln(zs);
end.


```

---

## 作者：Atmizz (赞：9)

### 【思路】
**模拟**，一共两种状态，一个是砍树，另一个是种树。
> 1. 砍树.
>   1.把该区间的树都砍掉,包括幼苗和树.
>   2.如果砍的是幼苗，那么计数器加加.
> 2. 种树.
>   1.种的只是幼苗.
>   2.看一下如果被砍了，标记一下被砍了的下标.

说完思路吐槽一下**坑点**。
- 第一问他是问的树苗的个数，我却一开始傻傻的算树的个数，一直出8。

代码就不难的，但是注释有许多没用的，所以准备了两份。
### 注释code：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<cmath>

using namespace std;
//jud是判断1或者0，即砍树还是种树，ans1是幼苗的个数 ，ans2是种了又砍掉

的个数 
int n,l,jud,ans1=0,x,y,ans2=0;
int pla[10001],cut[10001],miao[10001]={0};
//pla=plant表示各个点的树，cut表示已经砍了的树 ，miao表示树苗 
int main()
{
	memset(pla,1,sizeof pla);//初始化树为1，都有 
	memset(cut,0,sizeof cut);//初始化没砍树 
	scanf("%d",&l);	//外面树的长度 
	scanf("%d",&n);	//砍或者种的个数 
	for(int i=1;i<=n;++i) {
		scanf("%d%d%d",&jud,&x,&y);
		if(jud==0)	//要砍树了 
			for(int j=x;j<=y;++j) {
				pla[j]=0;	//不管之前有没有树，都

砍掉，对后面的计算没有影响 
				miao[j]=0;	//树苗也砍掉 
				if(cut[j]==1) {	//这个树之前砍过一次 
					++ans2;		//第二个计数器

开始加加 
					cut[j]=0;	//还原
				}
			}
		else	//种树了 
			for(int j=x;j<=y;++j) {
				if(pla[j]==0) {	//这里被砍了 
					cut[j]=1;	//砍树数组标记 
					miao[j]=1;	//在种树的话，

种的只能是树苗 
				}
				pla[j]=1;		//别管砍没砍，

反正就种了 
			}
	}
	for(int i=0;i<=l;++i) {
		if(miao[i]==1)	//找树苗 
			ans1++;	//第一个计数器加加 
	}
	printf("%d\n",ans1);//一定换行 
	printf("%d",ans2);
	return 0;	//结束 
}
```
--------**美丽的分割线**--------
### 无注释code：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<cmath>

using namespace std;

int n,l,jud,ans1=0,x,y,ans2=0;
int pla[10001],cut[10001],miao[10001]={0};

int main()
{
	memset(pla,1,sizeof pla); 
	memset(cut,0,sizeof cut); 
	scanf("%d",&l); 
	scanf("%d",&n); 
	for(int i=1;i<=n;++i) {
		scanf("%d%d%d",&jud,&x,&y);
		if(jud==0) 
			for(int j=x;j<=y;++j) {
				pla[j]=0;
				miao[j]=0;
				if(cut[j]==1) {
					++ans2;
					cut[j]=0;
				}
			}
		else 
			for(int j=x;j<=y;++j) {
				if(pla[j]==0) {
					cut[j]=1;
					miao[j]=1;
				}
				pla[j]=1;
			}
	}
	for(int i=0;i<=l;++i) {
		if(miao[i]==1) 
			ans1++; 
	}
	printf("%d\n",ans1); 
	printf("%d",ans2);
	return 0; 
}
```

---

## 作者：empty_zhm (赞：8)

# 代码思路
**和chen_zhe大佬的差不多，看到题目就想到思路了：就是线段树嘛!([这就是线段树](https://www.cnblogs.com/null00/archive/2012/04/22/2464583.html))**
**（和chen_zhe大佬的区别就是把操作给整合了一下，让码量 ~~可以接受~~ 更可观了些）**
(标题行就四个字了，求过了吧)
```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 10010
using namespace std;
struct tree
{
	int l,r,cover;
   tree(){cover=1;]//构造函数
}T[N<<2];//要开4倍空间预防RE
int n,m,ans1,ans2;
void build(int i,int l,int r)//顾名思义-建树
{
	T[i].l=l;T[i].r=r;
	if(l==r) return;
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
}
void Cut(int i,int l,int r,int b)//b表示进行的操作 0拔 1种
{
	int mid=(T[i].l+T[i].r)>>1;//位运算卡常
	if(T[i].cover!=1&&T[i].cover!=-1) T[i<<1].cover=T[i<<1|1].cover=T[i].cover;//继承状态
	if(T[i].l==l&&T[i].r==r)
	{
		if(T[i].cover==-1)//首先如果不可以一起处理,就往下处理
		{
			if(!b) T[i].cover=0;//如果是种植的话不可以=2(当然也不可以=0)
			Cut(i<<1,l,l+r>>1,b);//往下处理
			Cut(i<<1|1,(l+r>>1)+1,r,b);
			return;//结束函数以免出错
		}
		if(!b)//判断操作
		{
			if(T[i].cover<=1)//砍树的时候如果没树或者没树苗砍完就只剩没树一个结果
			{
				T[i].cover=0;//树清空
				return;
			}
			if(T[i].cover==2)//有树苗
			{
				T[i].cover=0;//树清空
				ans1+=T[i].r-T[i].l+1;//累加拔掉的树苗
				ans2-=(T[i].r-T[i].l+1);//记录剩下的树苗
				return;
			}
		}
		else//种树操作
		{
			if(T[i].cover>=1) return;//如果有树(苗)就不用操作
			if(T[i].cover==0)//如果没有树
			{
				T[i].cover=2;//种上树
				ans2+=(T[i].r-T[i].l)+1;//记录有多少树
				return;
			}
		}
	}
	else
	{
		if(r<=mid) Cut(i<<1,l,r,b);//如果不匹配范围就向下查询操作
		else 
		{
			if(l>mid) Cut(i<<1|1,l,r,b);
			else
			{
				Cut(i<<1,l,mid,b);
				Cut(i<<1|1,mid+1,r,b);
			}
		}
	}
	if(T[i<<1].cover==T[i<<1|1].cover) T[i].cover=T[i<<1].cover;
	else T[i].cover=-1;//处理完之后看状态(听取自己儿子的意见)
}
int main()
{
	cin >> n >> m;
	build(1,0,n);//建树(记得编号里有0,我RE了之后老久才发现)
	for(int i=1;i<=m;i++)//进行操作
	{
		bool b;
		int l,r;
		if(l>r) swap(l,r);//预防毒瘤数据
		cin >> b >> l >> r;
		Cut(1,l,r,b);//进行砍/种树操作
	}
	cout << ans2 << '\n' << ans1;//完结撒花！！！
	return 0;
}

```
**（码风有点奇特大家忍一下）**

---

## 作者：Gao_Shang (赞：7)

首先谈论一下
#### 题目常见问题
1.题目问的是留下的树苗,注意是树苗不是树木(其实我一开始就以为是树木)

### 呵,不要在意这些细节

2.题目第2问是求砍掉的树苗,不是树木!(要注意,我会强调一下的)

解决了常见问题以后,就说一下我的解题思路

------------

### 1.就三种情况:树木(一开始就有),坑(就是树木被砍了),树苗(砍了树又种的)

承认吧,很简单不是吗?
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;   //l<=10000,n<=100 数据范围......额...... 
int a,b,c,l,n,sm[20000]={0},s=0,z=0;//l:树木棵数,n:砍伐(或种植)次数,sm[20000]:树木情况{0代表树木,1代表坑,2代表树苗},s:树苗棵数,z:树苗被砍伐棵数 
int main()
{
	cin>>l>>n;//输入树木棵数和种植(或砍伐)次数 
	for(int i=1;i<=n;i++)//从第1次到第n次 
```
------------
举个例子(样例1):

首先都是树(如下)

0 0 0 0 0 0 0 0 0 0 0

砍2—6棵树
0 0 1 1 1 1 1 0 0 0 0

种1—8棵树
0 0 2 2 2 2 2 0 0 0 0

砍5—7棵树
0 0 2 2 2 1 1 1 0 0 0

答案就显而易见了,哈

### 2.节省时间(边输入边运算)

------------
```
	{
		cin>>a>>b>>c;//a:种植或砍伐{0代表砍伐,1代表种植},b:起始位置,c:终点位置 
		if(a==1)//如果是种植,那么...... 
		{
			for(int j=b;j<=c;j++)//从第b棵树到第c棵数 
			    if(sm[j]==1)//如果这里是个坑 
				   sm[j]=2;//那么种棵树苗 
		}
		else if(a==0)//如果是砍伐,那么...... 
		{
			for(int j=b;j<=c;j++)//从第b棵树到第c棵树 
			{
				if(sm[j]==2)z++;//如果这里是棵树苗,那么树苗被砍伐数+1 
				sm[j]=1;//这里变成坑 
			}
		}
	}//这里继上一个for循环
	for(int i=0;i<=l;i++)//从第1棵数到第l+1棵树 
	    if(sm[i]==2)//如果第i个地方是树苗,那么...... 
	       s++;//树苗棵树+1 
	cout<<s<<endl<<z;//输出树苗棵数和树苗被砍伐棵数 
	return 0;
}
```
------------
## *再次提醒留下的是树苗不是树木！
## *再次提醒留下的是树苗不是树木！
## *再次提醒留下的是树苗不是树木！(重要的事情说三便)

---

## 作者：li1127217ye (赞：5)

这是我第一次用线段树程序. 程序里面有很多注释, 另外变量名也不是胡乱起的, 学过线段树的同学应该能看懂.

cnt 表示砍掉的树苗数量.
















```cpp
#include<bits/stdc++.h>
using namespace std;
int L, N;
int cnt = 0;
struct SegTreeNode {
    int left = -1, right = -1; //区间的左右边界(都是闭区间)
    int num_big = 0; //区间内大树的数量
    int num_small = 0; //区间内树苗的数量
    int num_ground = 0; //区间内空地的数量
    bool iscut = false;
    bool isadd = false;
}SegTree[40000];
void build(int root) {
    // 初始化线段树, 自上而下赋值, 根部的下标为1
    SegTreeNode& self = SegTree[root];
    if (root == 1) {
        self.left = 0;
        self.right = L;
        self.num_big = self.right - self.left + 1;
    }
    else {
        SegTreeNode& father = SegTree[root / 2];
        int mid = (father.left + father.right) / 2;
        if (root == root / 2 * 2) {
            //自己是父亲的左儿子
            self.left = father.left;
            self.right = mid;
            self.num_big = self.right - self.left + 1;
        }
        else {
            //自己是父亲的右儿子
            self.left = mid + 1;
            self.right = father.right;
            self.num_big = self.right - self.left + 1;
        }
    }
    if (self.right > self.left) {
        build(2 * root);
        build(2 * root + 1);
    }
}
void cut(SegTreeNode& self) {
    self.num_big = 0;
    self.num_small = 0;
    self.num_ground = self.right - self.left + 1;
    self.iscut = true;
    self.isadd = false;
}
void add(SegTreeNode& self) {
    //self.num_big 不变
    self.num_small = self.right - self.left + 1 - self.num_big;
    self.num_ground = 0;
    self.iscut = false;
    self.isadd = true;
}
void pushdown(int root, int type) {
    //将标记命令pushdown
    // type==0 表示砍树, type==1 表示种树
    SegTreeNode& self = SegTree[root];
    if (self.left == self.right) {
        return;
    }
    SegTreeNode& leftchild = SegTree[2 * root];
    SegTreeNode& rightchild = SegTree[2 * root + 1];
    if (type == 0) {
        if (leftchild.isadd) pushdown(2 * root, 1);
        cut(leftchild);
        if (rightchild.isadd) pushdown(2 * root + 1, 1);
        cut(rightchild);
    }
    else {
        if (leftchild.iscut) pushdown(2 * root, 0);
        add(leftchild);
        if (rightchild.iscut) pushdown(2 * root + 1, 0);
        add(rightchild);
    }
}
void cut_tree(int root, int left, int right) {
    //砍树
    SegTreeNode& self = SegTree[root];
    int num_small_old;
    if (root == 1) {
        num_small_old = self.num_small;
    }
    if (self.right < left || self.left > right) {
        //无交集
        return;
    }
    if (self.left >= left && self.right <= right) {
        //节点范围包含在砍树范围之内
        if (self.isadd) pushdown(root, 1);
        cut(self);
        if (root == 1) {
            if (num_small_old > self.num_small) {
                cnt += num_small_old - self.num_small;
            }
        }
        return;
    }
    // 执行到这里的, 肯定不是叶节点
    if (self.isadd) pushdown(root, 1);
    if (self.iscut) pushdown(root, 0);
    self.isadd = false;
    self.iscut = false;
    cut_tree(2 * root, left, right);
    cut_tree(2 * root + 1, left, right);
    SegTreeNode& leftchild = SegTree[2 * root];
    SegTreeNode& rightchild = SegTree[2 * root + 1];
    self.num_big = leftchild.num_big + rightchild.num_big;
    self.num_small = leftchild.num_small + rightchild.num_small;
    self.num_ground = leftchild.num_ground + rightchild.num_ground;
    if (root == 1) {
        if (num_small_old > self.num_small) {
            cnt += num_small_old - self.num_small;
        }
    }
}
void add_tree(int root, int left, int right) {
    //种树
    SegTreeNode& self = SegTree[root];
    if (self.right < left || self.left > right) {
        //无交集
        return;
    }
    if (self.left >= left && self.right <= right) {
        //节点范围包含在种树范围之内
        if (self.iscut) pushdown(root, 0);
        add(self);
        return;
    }
    // 执行到这里的, 肯定不是叶节点
    if (self.isadd) pushdown(root, 1);
    if (self.iscut) pushdown(root, 0);
    self.isadd = false;
    self.iscut = false;
    add_tree(2 * root, left, right);
    add_tree(2 * root + 1, left, right);
    SegTreeNode& leftchild = SegTree[2 * root];
    SegTreeNode& rightchild = SegTree[2 * root + 1];
    self.num_big = leftchild.num_big + rightchild.num_big;
    self.num_small = leftchild.num_small + rightchild.num_small;
    self.num_ground = leftchild.num_ground + rightchild.num_ground;
}
int main() {
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    scanf("%d%d", &L, &N);
    build(1);
    int type, left, right;
    for (int i = 0;i < N;i++) {
        scanf("%d%d%d", &type, &left, &right);
        if (type == 0) cut_tree(1, left, right);
        else add_tree(1, left, right);
    }
    cout << SegTree[1].num_small << endl;
    cout << cnt << endl;
    return 0;
}
```

---

## 作者：黯黑の夜 (赞：4)

# 注意树苗不会长大

# 而且是从0到w的

~~这两个坑能摔死人，我WA了3次才AC~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,i,j,a,b,c,ans1=0,ans2=0;//w是长度
int h[10001];//用来存储是坑还是树苗还是大树
int main()
{
    scanf("%d%d",&w,&n);
	for(i=0;i<=w;i++)h[i]=1;//由于memset(h,1,sizeof(h))用不了(是我电脑坏了吧)，所以用for
    for(i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a,&b,&c);//a为状态，b和c为区间
        if(a==1)//种树
        {
            for(j=b;j<=c;j++)
            if(h[j]==0)//如果是坑就种树苗，其他跳过
            h[j]=2;
        }
        else//砍树
        for(j=b;j<=c;j++)
        {
            if(h[j]==2)//砍掉的是树苗就++，再赋为坑
            ans2++;
            h[j]=0;
        }
    }
    for(i=0;i<=w;i++)
    if(h[i]==2)//找树苗的个数
    ans1++;
    printf("%d\n%d\n",ans1,ans2);
    return 0;
}
```

其实题目看仔细就好了，实现并不难。。。

祝大家while(1)
		
         CSP_score++,CSP_rp++;

---

## 作者：无颜ing (赞：1)

看到前面CZ大佬用线段树，还是蛮佩服，不过我这蒟蒻还是简单点，标记数组就好了.这道题和没升级版的校门外的书没有很大差别，代码里有详解，自己看看吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
int forest[1000010]={0},i,j;//forest是标记数组 
int t,p,buf;//之所以标记数组不用bool定义是别有用意的 
int l,n,sum=0,cur=0;//两个计数 
int main(){
	cin>>l>>n;//读入 
	l++;//共有l+1个树 
	for(i=0;i<=l;i++)//线段初始化 
	forest[i]=1;
	for(i=1;i<=n;i++){ 
		cin>>buf>>t>>p;//读入一个处理一个，省空间
		if(buf==0)//如果是砍树 
		for(j=t;j<=p;j++){//标记线段 
			if(forest[j]==2)//如果这棵树已经被种植过一次了 
				sum++;//计数 
				forest[j]=3;//再砍掉 
		}
		else{//否则是种树 
			for(j=t;j<=p;j++)//标记线段 
			if(forest[j]==3)//如果它被砍掉了 
			forest[j]=2;//种上 
		}
	}
	for(i=0;i<=l;i++)//统计整个线段中 
	if(forest[i]==2)//被种上了几棵树 
	cur++;//计数 
	cout<<cur<<endl<<sum;//输出
	//特别坑爹，这里一定要输出换行符，空格啥子的不行
	//我就是因为这个被卡了3次，换行符！换行符！不是空格！ 
}
```

---

## 作者：逍遥__天赐 (赞：1)

1表示树，0表示空，2表示树苗

```cpp
#include <bits/stdc++.h>
using namespace std;
int rd[10001];
int main()
{
    int l,n,ans=0,ans1=0;//ans1判断树苗被砍掉，ans判断剩余树苗
    cin>>l>>n;
    for(int i=0;i<=l;i++) rd[i]=1;//初始化，把l以内的都设为1，0也要
    for(int i=0;i<n;i++)
    {
        int x,c,d;
        cin>>x>>c>>d;
        if(x)//判断操作
        {
            for(int i=c;i<=d;i++)
            {
                if(!rd[i]) rd[i]=2;//种树苗
            }
        }
        else
        {
            for(int i=c;i<=d;i++)
            {
                if(rd[i]==2) ans1++;
                rd[i]=0;
            }
        }
    }
    for(int i=0;i<=l;i++)
    {
        if(rd[i]==2) ans++;//树苗总数
    }
    cout<<ans<<'\n'<<ans1<<endl;
    return 0;
}
```

---

## 作者：s_a_b_e_r (赞：1)

这题没什么特殊技巧

就是纯模拟

注意**0这个点是有树的**，我在这wa了3次没查出来QAQ

还有要**注意总长度**，种树不要种超了

附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,ll,ans,S;
int l[40001];
int a,b,c;
int main(){
    cin>>ll>>n;
    for(int i=0;i<=ll;i++)l[i]=1;
    for(int i=1;i<=n;i++){
     cin>>a>>b>>c;
     if(a==0){
      for(int i=b;i<=c&&i<=ll;i++)
       if(l[i]==2)ans++,l[i]=0,S--;
       else l[i]=0;
     }
     if(a==1) {
        for(int i=b;i<=c&&i<=ll;i++)
        if(l[i]==0)S++,l[i]=2;
          }
    }
    cout<<S<<endl<<ans;
    return 0;
}
```

---

## 作者：Decide (赞：1)

升级版的啊。。然而还是模拟

但是我没看题意硬是提交了差不多10次才过。。我把留下的树苗数看成了剩下的树的数目，导致一直提交代码都过不了

一个一位数组，和之前那个一样，不同的地方是挖走的地方标记为0，而树苗的地方标记为2，那么就可以循环统计了（数据弱）

看清题面！看清题面！看清题面！重要的事情说三遍。。



        
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int all[10000+10] = {0},n,l,pd,L,R,ans=0,ans2=0;
int main()
{
    memset(all,1,sizeof(all));
    cin>>l>>n;
    for(int i = 1;i<=n;i++)
    {
        cin>>pd>>L>>R;
        if(pd==0) 
            for(int j = L;j<=R;j++)
               if(all[j]==2) {ans2++; all[j] = 0;}
               else all[j] = 0;
        if(pd==1){
            for(int j = L;j<=R;j++){
                 if(all[j]==0) all[j] = 2; 
            } 
        } 
    }
    for(int i = 0;i<=l;i++) if(all[i]==2) ans++;
    cout<<ans<<endl<<ans2<<endl;
    return 0;
}
```

---

## 作者：ROOToj (赞：1)

非常简单的模拟题，只需用一个数组f记录某一位置是否有树，再用一个数组记录某一位置是否有树苗，然后模拟操作即可。但要注意：此题有陷阱！！！（路是从0开始的；要求的是”树苗“而不是“树“）然后就是简单的模拟了，用两个变量记录种树苗总数（count）和种了又砍了的树苗数（sum），有一个小技巧：剩余树苗数=种树苗总数-种了又砍了的树苗数。

附上AC源代码​：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define MAXN 1000010
int n,m,f[MAXN],num,a,b,i,count=0,sum=0,r[MAXN];
int main()
{
    scanf("%d%d",&n,&m);
    memset(f,0,sizeof(f));
    memset(r,0,sizeof(r));
    while(m--)
    {
        scanf("%d%d%d",&num,&a,&b);
        if(num)
        {
            for(i=a;i<=b;i++)
                if(f[i]){f[i]=0;r[i]=1;count++;}
        }
        else for(i=a;i<=b;i++)
            if(!f[i])
            {
                if(r[i]){sum++;;r[i]=0;}
                f[i]=1;
            }
    }
    printf("%d\n",count-sum);
    printf("%d\n",sum);
    return 0;
}

```

---

## 作者：李达康 (赞：0)

本题相对于P1047来说，多加了小树苗以及对小树苗被拔去的判断，但基本思路还是类似于桶。关键是区分大树，小树苗，小树苗又被拔去

附代码：
```cpp
#include<iostream>
using namespace std; // _头文件这些就够_ 
int l,m,ss[10001],x,y,z,k,zb;
int main(){
	cin>>l>>m; // _第一行的输入_ 
	for(int j=0;j<=l;j++)
		ss[j]=1;
        // _初始化为1，即大树为1_ 
	for(int i=0;i<m;i++){
		cin>>z>>x>>y;
        //for循环边读入边进行，第2次直接覆盖，不用考虑重复
		if(z==0){
			for(int j=x;j<=y;j++){
				if(ss[j]==-1) zb++;//**如果位置上是小树苗，并且要被砍去，zb++；**
			ss[j]=0;
			}
	// _如果得到的第一个数是0，就把树的位置初始化为0，即 坑_ 
		}
		if(z==1){
			for(int j=x;j<=y;j++){
				if(ss[j]!=1) ss[j]=-1;
			}
	// _如果得到的第一个数是1，并且原位置没有大树，就把树的位置初始化为-1，即把 坑变成小树苗_ 
		}
	}
	for(int i=0;i<=l;i++){
		if(ss[i]==-1) k++;
	}//数小树苗的个数
	cout<<k<<zb;
	return 0;
}
```


---

## 作者：HiroshiRealm (赞：0)

这题很水，但是为什么通过率这么低（~~我太蒟了~~）


我觉得，这题用数组做就不好玩了（滑稽），我决定用结构体水一发

因为这题数据水，所以暴力模拟每一个树坑的话是可以出奇迹的

上代码
```
#include<bits/stdc++.h>
using namespace std;
int sum1,sum2,a,b,c,d,e;
struct node{
    bool is_littletree;//树苗
    bool is_tree;//树
}tree[100000];
inline void Init(){
    scanf("%d%d",&a,&b);
    for(int x=0;x<=a;x++)tree[x].is_tree=1;//每一个坑上都有大树
       return;}
inline void Work(){
    for(int x=1;x<=b;x++){
        scanf("%d%d%d",&c,&d,&e);
        if(c==1){
            for(int y=d;y<=e;y++){
                if(tree[y].is_tree==0){//如果没有大树，就栽树苗
                    tree[y].is_littletree=1;
                }
            }
        }
        else{
            for(int y=d;y<=e;y++){
                if(tree[y].is_tree==1)tree[y].is_tree=0;
                else{
                    if(tree[y].is_littletree==1){/*这个地方有点坑
                    ，我原来是把统计放在最后的，后来发现应该统计拔掉的树苗
                    而不是拔掉树苗的树坑，这两者是有区别的*/
                        sum2++;
                        tree[y].is_littletree=0;
                    }
                }
            }
        }
    }
       return ;}
inline void Export(){
    for(int x=0;x<=a;x++){
        if(tree[x].is_littletree==1)sum1++;
    }
    printf("%d\n%d",sum1,sum2);//输出
       return;}
int main()
{//华丽的主函数
Init();
Work();
Export();
    return 0;
}

```



---

## 作者：枍暮77 (赞：0)

的确是一道很水的入门题，虽然比原题难了许多，但依然只需要开个足够大的数组模拟，超内存超时限都不用考虑。楼上的程序比我的长。。。。。。但思想是一样的。程序就不多解释了，虽然长，但很容易看懂。

```delphi
var
 s:array[0..10000] of longint;
 l,Y,a,b,c,d,i,j,n,x:longint;
begin
 readln(l,d);
 for i:=0 to l do s[i]:=1;
 n:=0;
 x:=0;
 for i:=1 to d do
  begin
   readln(a,b,c);
   if a=0 then
     for j:=b to c do
      if s[j]=1 then s[j]:=0
       else if s[j]=2 then
         begin
          s[j]:=0;
          x:=x+1;
        end;
   if a=1 then
    for j:=b to c do
       if s[j]=0 then s[j]:=2;
    end;
  for i:=0 to l do
  if s[i]=2 then n:=n+1;
  writeln(n);
  writeln(x);
end.
```

---

## 作者：xiaoxi27 (赞：0)

想法:

 
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int l,n,flag,a,b,c,d,f1=0,f2=0,e[10001];
    memset(e, 2, sizeof(e));
    cin>>l>>n;
    for(int i=1;i<=n;i++)
    {
            cin>>flag;
            if(flag==0)
            {
                cin>>a>>b;
                for(int j=a;j<=b;j++)
                {
                        if(e[j]==1) f1++;
                        e[j]=0;
                        }
                       }
            if(flag==1)
              {
                       cin>>c>>d;
                       for(int k=c;k<=d;k++)
                       if(e[k]==0)  e[k]=1;
                       }
            }
    for(int z=0;z<=l;z++)
        if(e[z]==1)   f2++;
    cout<<f2<<endl;
    cout<<f1<<endl;
    return 0;
    } 

```

---

## 作者：taophee (赞：0)

想法:

这道题是一道纯粹的模拟题，并不需要用高深的算法，10000\*100计算机一秒能够接受，所以只需要每次读入指令再模拟一遍就可以了，注意树的区间为[0，n]，不要遗漏关于0这个点就可以了.

程序:

```delphi

var
a:array[0..10000] of longint;
c,n,m,i,j,s,t,x,y:longint;

begin
  fillchar(a,sizeof(a),1);
  read(n,m);
  for i:=1 to m do
   begin
    read(c);
    if c=0 then
     begin
      read(x,y);
      for j:=x to y do
       begin
        if a[j]=2 then
         begin
          s:=s-1;t:=t+1;
        end;
        a[j]:=0;
      end;
    end;
    if c=1 then
     begin
      read(x,y);
      for j:=x to y do
       begin
        if a[j]=0 then
         begin
          s:=s+1;a[j]:=2;
        end;
      end;
    end;
  end;
  writeln(s);
  writeln(t);
end.

```

---

## 作者：兄主的仙人掌 (赞：0)

### 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int r[10002];                     //这个数组里的每一个数只有三态，0表示被砍掉，1表示大树，2表示树苗
int main() {
    int n,l,a,b,x;
    int sum=0;                    //sum变量用于存储种上又被拔掉的树苗数目
    cin >> l >> n;
    for (int i=0;i<=l;i++)
        r[i]=1;                   //植树
    for (int i=0;i<n;i++) {
        cin >> x >> a >> b;
        if (x==0)                 //如果是砍树
            for (int j=a;j<=b;j++) {
                if (r[j]==2)      //如果砍的是树苗
                    sum++;
                r[j]=0;
            }
        else if (x==1)
            for (int j=a;j<=b;j++)
                if (r[j]==0)      //如果被砍掉了
                    r[j]=2;       //记！住！种！的！是！树！苗！
    }
    int count=0;                  //count变量用于存储剩下的树苗
    for (int i=0;i<=l;i++) {      //统计
        if (r[i]==2)              //如果是树苗
            count++;
    }
    printf("%d\n%d",count,sum);
    return 0;
}
```

### 分析

如题，这题很坑

#### 一号坑

$L$是从0开始而不是1，~~这个坑能摔死人~~

#### 二号坑

种下去的是树苗，永远不会长成大树

其他好像就没有了

---

## 作者：minecraft_herobrine (赞：0)

MINECRAFT 优质题解-第一题 P1276校门外的树
这道~~水题~~我看有很多大佬用线段树和树状数组做，我是个蒟蒻，看不懂。。。所以用了普通的数组做这道题。。。

和校门外的树原版类似，只不过这里多了一种情况：种树苗，但其实这道题还是比较简单的。初始所有位置都种大树，a[i]用0表示，空位用1表示，种树苗用2表示。如果第i个位置的树或树苗被砍，就吧a[i]=1；如果当前位置被补种了树苗，就把a[i]=2；然后统计就可以了。纯模拟。


上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100008]={0};
//a[i]表示第i个位置的状态，0表示种植了大树，1表示空，2表示种植了树苗
//a[i]初始全部给0，表示全都种上大树 
int main()
{
	int n,i,j,m,L,l,r,ans1=0,ans2=0;
	scanf("%d %d",&L,&n);
	bool f;//f为false表示砍树者，true表示植树者 
	for(i=1;i<=n;i++)
	{
		cin>>f;    //scanf没法读入bool型的变量 
		scanf("%d %d",&l,&r);
		//从a[l]到a[r]来植树或砍树
		if(!f)    //砍树 
		{
			for(j=l;j<=r;j++)
			{
				if(a[j]==0) a[j]=1;
				if(a[j]==2) //
				{
					ans2++;
					a[j]=1;
				}
			}
		}
		else for(j=l;j<=r;j++) if(a[j]==1) a[j]=2;    //种树 
	}
	for(i=0;i<=L;i++) if(a[i]==2) ans1++;    //统计 
	printf("%d\n%d",ans1,ans2);
	return 0;    //好习惯 
}

```
注意是题目的要求是统计**补种的树苗又被砍的总数**而不是最后有多少个树苗被砍

谢谢大家(^_^)

---


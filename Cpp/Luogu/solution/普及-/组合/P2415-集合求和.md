# 集合求和

## 题目描述

给定一个集合 $s$（集合元素数量 $\le 30$），求出此集合所有子集元素之和。


## 说明/提示

**【样例解释】**

子集为：$\varnothing, \{ 2 \}, \{ 3 \}, \{ 2, 3 \}$，和为 $2 + 3 + 2 + 3 = 10$。

----

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le \lvert s \rvert \le 30$，$1 \le s_i \le 1000$，$s$ 所有子集元素之和 $\le {10}^{18}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
10
```

# 题解

## 作者：feecle6418 (赞：308)

我把这题的公式推导过程详细的说一下。

先选出指定的一个元素，加入子集；

首先，当子集里只有一个元素时，在其他剩余的元素中不能选出任何元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^0$ 次被选中。

当子集里有 2 个元素时，在其他剩余的元素中选出 1 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^1$ 次被选中。

当子集里有 3 个元素时，在其他剩余的元素中选出 2 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^2$ 次被选中。

当子集里有 $i\ (i\leq n)$ 个元素时，在其他剩余的元素中选出 $i-1$ 个元素加入到子集中，所以**对于每个元素来说**，均有 $C_{n-1}^{i-1}$ 次被选中。

所以共有 $\sum_{i=1}^{n} {C_{n-1}^{i-1}}$ 次被选中，即 $2^{n-1}$ 次被选中。

也可以这样考虑：如果要选中 $x$，剩下的元素都可选可不选，所以总共有 $2^{n-1}$ 种方法。

代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[31],i=0,j;
long long s=0;
int main(){
    //cout<<s;
    while(cin>>a[i++]);//合写cin>>a[i];i++;
    for(j=0;j<i;j++){
        s+=a[j];
    }
    s*=pow(2,i-2);//注意，i-2!
    cout<<s;
    return 0;
}
```

---

## 作者：mrwalking (赞：151)

```cpp
//P2415 集合求和
//研究 1 2 3 4
//子集[] [1] [2] [3] [4] [1 2] [1 3] [1 4] [2 3] [2 4] [3 4] [1 2 3] [1 2 4] [1 3 4] [2 3 4] [1 2 3 4]
//1*8+2*8+3*8+4*8=(1+2+3+4)*2^(4-1) 
//发现规律 输入元素和*2^(n-1) 
#include <stdio.h>
int main(){
    long long ans=0;
    int n=0,i,a;
    while(scanf("%d",&a)!=EOF)ans+=a,n++;
    for(i=1;i<n;i++)ans*=2;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Lhc_fl (赞：113)

### 此题坑点:

- 结果必须要用long long存，int存不下

- 如果想要像`cout<<sum*pow(2,num-1)`这样在输出时计算会错：  
long long在计算过程被隐式转换成了double，需要用强制类型转换转换回long long输出。

- ~~集合论和排列组合公式初中还没学~~

--------

## 题目描述
给定一个集合s（集合元素数量<=30），求出此集合所有子集元素之和。

## 分析

我们来看一个例子：
$\{1,2,3\}$

可以得到，它的所有非空子集为
$\{1,2,3\}$ $\{1,2\}$ $\{2,3\}$ $\{1,3\}$ $\{1\}$ $\{2\}$ $\{3\}$  

现在来分析每一个元素在每一个子集中出现的个数：

$1$出现了$4$次,$2$出现了$4$次,$3$出现了$4$次

我们猜测：对于一个有限集合$A$，它的每一个元素在$A$的所有子集中出现的个数是${2^{\operatorname{card}(A)-1}}$

** 证明：**(集合论纯自学，可能格式有误, 请别在意QAQ)

设$B\subseteq A$, 记$n=\operatorname{card}(A)$， $s$为$A$中所有元素之和

当$\operatorname{card}(B)=1$时，显然，每个元素在$B$中出现$1$次；

当$\operatorname{card}(B)=2$时，保证一个元素必选，在剩余的$n-1$个元素中选择$1$个元素，共$C^1_{n-1}=n-1$种情况，故每个元素在$B$中出现$C^1_{n-1}=n-1$次；

当$\operatorname{card}(B)=3$时，保证一个元素必选，在剩余的$n-1$个元素中选择$2$个元素，共$C^2_{n-1}=\frac{(n-1)!}{2(n-1-2)!}=\frac{(n-1)(n-2)}{2}$种情况，故每个元素在$B$中出现共$C^2_{n-1}=\frac{(n-1)(n-2)}{2}$次；

当$\operatorname{card}(B)=k$时，保证一个元素必选，在剩余的$n-1$个元素中选择$k-1$个元素，共$C^{k-1}_{n-1}$种情况，故每个元素在$B$中出现共$C^{k-1}_{n-1}$次；

那么，每个元素在$A$的每一个子集中出现的个数为：
$\sum\limits_{i=1}^{n}C^{i-1}_{n-1}=2^{n-1}$ ①

$A$的所有子集元素之和为$s\times2^{n-1}$



故代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long tmp,num=0,sum=0;
    while(cin>>tmp){sum+=tmp;num++;}//读入集合元素个数num和元素和sum
    cout<<(long long)(sum*pow(2,num-1));//必须显式地转换为long long输出
    return 0;
}
```

------

①:
~~像我这样~~不懂为什么$\sum\limits_{i=1}^{n}C^{i-1}_{n-1}=2^{n-1}$的可以看一下数学归纳法证明：

将用到的性质公式：
- $C^m_n=C^{m-1}_{n-1}+C^{m}_{n-1}$
- $C^n_n=C^0_n=1$

$$\sum\limits_{i=0}^{n}C^{i}_{n}=2^{n}$$

证明：

1)当$n=1$时：

$$\sum\limits_{i=0}^{n}C^{i}_{n}=C^0_1+C^1_1=2=2^1$$

等式成立。

2)假设当$n=k(k\in N_+)$时$\sum\limits_{i=0}^{n}C^{i}_{n}=2^{n}$
成立, 即$\sum\limits_{i=0}^{k}C^{i}_{k}=2^{k}$

那么当$n=k+1$时:

$\text{\ \ \ \ }$ $\sum\limits_{i=0}^{k+1}C^{i}_{k+1}$


$=C^{0}_{k+1}+C^{1}_{k+1}+C^{2}_{k+1}+...+C^{k}_{k+1}+C^{k+1}_{k+1}$

$=C^{0}_{k+1}+(C^{0}_{k}+C^{1}_{k})+(C^{1}_{k}+C^{2}_{k})+...+(C^{k-1}_{k}+C^{k}_{k})+C^{k+1}_{k+1}$

$=C^{0}_{k}+(C^{0}_{k}+C^{1}_{k})+(C^{1}_{k}+C^{2}_{k})+...+(C^{k-1}_{k}+C^{k}_{k})+C^{k}_{k}$

$=2(C^0_k+C^1_k+C^2_k+...+C^k_k)$

$=2\sum\limits_{i=0}^{k}C^{i}_{k}$

$=2\times2^k$

$=2^{k+1}$

此时等式依然成立。假设成立。

故$\sum\limits_{i=0}^{n}C^{i}_{n}=2^{n}$


由此可以得到，$\sum\limits_{i=1}^{n}C^{i-1}_{n-1}=2^{n-1}$


















---

## 作者：归山_ (赞：49)

这个题是个推结论的题

然而当我点开题解后发现好像没有用我这种方法的我就来写一下

其实还是比较简单的

~~这就是你做红题的理由~~



------------
首先我们可以自己出几组数据

比如

1

	1

1 2

	1
	2
	1 2


1 2 3
	
    1
 	2
  	3
  	1 2
  	1 3
  	2 3
  	1 2 3
    
    
是不是发现好像没有任何规律可循

我们在仔细看一下的话就会发现

在这三组数据里面，1出现的次数分别是1,2,4

emmmmmmm

好像是出现了 $2^{n-1}$次啊(其中n代表的是个数)

这就有趣了

### 我们再用假说-演绎法

我们推理如果是1 2 3 4的话1出现的次数应该是8

我们进行模拟

1 2 3 4

	1
    2
    3
    4
    1 2
    1 3
    1 4
    2 3
    2 4
    3 4
    1 2 3
    1 2 4
    1 3 4
    2 3 4
    1 2 3 4
    
我们发现没错就是8

这样这个结论就得以证明了

再然后我们考虑如果进行推广的话

我们可以算出每个数出现的次数并加起来就得到最后的答案了

注意要开long long否则会得到60分的好成绩

所以代码如下

```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;

#define int long long

const int maxn=100010;
int a[maxn];
int cnt;
int ans;

int quick_pow(int a,int b){
	int num=1;
	while(b){
		if(b&1) num=num*a;
		a=a*a;
		b>>=1;
	}
	return num;
}

signed main(){
	while(cin>>a[++cnt]);
	for(int i=1;i<cnt;i++){
		ans+=(quick_pow(2,cnt-2)*a[i]);
	}
	cout<<ans<<'\n';
	return 0;
}
```

祝大家csp rp++！！！

希望大家能得到自己想要的结果

---

## 作者：ttycp3 (赞：31)

**一道红题搞死我了快-_-||**
~~难道出题人的数学老师没有教他集合里不能有重复元素么？？？~~
首先我一看这个题，先来了一发set，代码如下：
```c
#include<bits/stdc++.h>
using namespace std;
set<long long>q;
int main(){
	long long n,m,k,s;
	long long tot=0;//记得long long，不然会炸
	while(cin>>n)
	q.insert(n);
	k=q.size();
	m=pow(2,k-1);
	for(int i=1;i<=k;i++){
	   tot+=m*(*q.begin());
	   
		q.erase(q.begin());
	}
	cout<<tot<<endl;

	return 0;
}
```
然后就写崩了。研究了半天数据，发现题目给的这个集合是可以存在重复元素的，~~我！@#￥%……￥@#￥@￥@~~，看到这终于明白了这题shui的可以~~
如下是满分代码：
```c
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m,k,s=0,i=0;//n是集合元素，s为集合元素之和，i为元素个数
	long long tot=0;
	while(cin>>n)
	i++,s+=n;
	m=pow(2,i-1);//计算每个元素出现次数
    tot=s*m;
	cout<<tot<<endl;
	return 0;
}
```
有疑问可以私我哦

---

## 作者：SLYZ_0120 (赞：25)

蒟蒻的第十篇题解依旧准时上线~

今天的题是一道非常优（并）秀（不）的数学题，虽然依旧是提交了两次才过而且数学推导的过程晕菜……

------------
废话不多说，首先要来理清楚思路，很明显这是一道数学题，所以我们先要推导出计算公式。
### 推导过程
**当集合中有一个元素的时候，集合中的元素之和（注意这里是指一次，举个例子集合S={1，2，3，4}的元素之和就是指10）被数到只有1次**

**当集合中有两个元素的时候：**

**1、子集中只有一个元素—>元素之和数到一次**

**2、子集中有两个元素->元素之和又数到一次**

**以此类推，当集合中有三个元素的时候：
元素之和会被数到1+2+1也就是四次（自己去数咯）**

然后让我们来把它们整理起来

   1

 1    1

 1 2 1

 1 3 3 1

以此类推

**第i行的数字和表示当集合中有i个元素的时候的元素之和出现的次数。而每一行的第j个数字表示当子集中有j个元素的时候元素之和出现的次数**

## 发现了什么？？？

# 杨辉三角！！！
然后每一行的和就是非常简单了，s = 2^(i-1)

那么最终的答案就推出来了，元素之和*s

数据规模注意一下，所以要开 long long

那么代码就不贴了，基本也是差不多，主要是希望可以更好的解释本题思路

---

## 作者：午尘 (赞：17)

先放代码吧。。

关键：long long!!

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,i,j,k,a[10000],ans;
int main(){
	while (scanf("%lld",&k) !=EOF)
	  {  n++;
	     ans+=k;
       }
    for (i=1;i<n;i++)
      ans*=2;
    cout<<ans<<endl;
    return 0;
}
		
```

然后说一下为什么这么做吧。

设 n 为个数，

n=1  ，， 数列：1  ，，   ans=1 * 1

n=2  ，， 数列：1 2 ，，  ans=1+2+1+2=(1+2) * 2

n=3  ，， 数列：1 2 3 ，，  ans=(1+2+3)+(1+2+1+3+2+3)+(1+2+3)=（1+2+3）* 4

……

所以，ans=he*2^(n-1);

就这样啦……


---

## 作者：Kaori (赞：14)

本篇题解原来是 [@Fee_cle6418](https://www.luogu.org/space/show?uid=42156) 的，我在此做一些补充解释，方便大家更好理解。**这里先感谢他的思路点拨，同时这里完全尊重原作者的版权，如有异议可以处理**

这题的公式推导过程:

先选出指定的一个元素，加入子集；

首先，当子集里只能放一个元素时，在其他剩余的元素中不能选出任何元素加入到子集中，所以**对于这个指定元素来说**，均有 $C_{n-1}^0$ 次被选中。由于原集合中的$n$个元素中每个元素都可以成为先选出的指定元素，因此每个数都有这么多次被选中。**下面所有情况同理。**

当子集里只能放2个元素时，在其他剩余的元素中选出1个元素加入到子集中，所以**对于这个指定元素来说**，均有 $C_{n-1}^1$ 次被选中。

当子集里只能放3个元素时，在其他剩余的元素中选出2个元素加入到子集中，所以**对于这个指定元素来说**，均有 $C_{n-1}^2$ 次被选中。

当子集里只能放i $(i\leq n)$ 个元素时，在其他剩余的元素中选出 $i-1$ 个元素加入到子集中，所以**对于这个指定元素来说**，均有 $C_{n-1}^{i-1}$ 次被选中。

### 所以每个数都有 $\sum_{i=1}^{n} {C_{n-1}^{i-1}}$ 次被选中。

### 展开为 $C_{n-1}^{0} + C_{n-1}^{1} + C_{n-1}^{2} + ... + C_{n-1}^{i-1}$

有没有觉得算它好像有技巧？

回顾一下组合数的意思：$C_n^m$ 表示在n个数中选出m个数的情况数。那么再结合[NOIP2016提高组d2t1](https://www.luogu.org/problemnew/show/P2822)的推论可知上式中的所有值依次为**杨辉三角**中的第n行的值！（杨辉三角与组合数的递推公式一模一样）

### 也就是说，杨辉三角第n行的总和就是上式的结果。那么最后一个结论要出来了：杨辉三角第n行的所有值的和为 $2^{n-1}$。

怎么证？~~手算~~

看图
![](https://cdn.luogu.com.cn/upload/pic/26909.png)

如果找下面一行的每个数怎么由上面推导过来，可能很难发现有什么特征。我特意把箭头从上往下画，不知道大家有没有发现什么？

没错，上一行的每一个数都只给下一行与之相邻的两个数累加上，也就是说下一行是把上一行每个数累加 $2$ 次得到的，因此**下一行所有数的总和等于上一行所有数的总和的 $2$ 倍！**

杨辉三角第 $1$ 行只有一个 $1$，因此总和是 $2^0=1$。那么每往下一行总和就乘2（指数加1），杨辉三角第n行的所有值的和即为 $2^{n-1}$，得证。

综上所述，每个数都有 $2^{n-1}$ 次被选中。累加所有数并乘上被选中的次数即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,ans,cnt;
int main(){
	while(~scanf("%lld",&a)) ans+=a, ++cnt;
	printf("%lld\n",ans*(1<<(cnt-1)));
	return 0;
}
```

---

## 作者：BEqueN (赞：10)

### 前言
看了几篇题解，发现竟然没有用位运算的

证明啊什么的看下面dalao的题解，我就介绍一下位运算

~~我才不会告诉你是本蒟蒻不会证明~~

还有pascal左移右移具体怎么用...我是转C之后才学的左移右移，pascal只知道左移函数是shl，右移函数是shr，并不知道具体怎么用

~~www.baidu.com等你访问~~

#### and(&)
转换为二进制后每一位相乘，位数不够补0
如：

(4)10=(100)2

(3)10=(11)2


4&3=100 & 011=000

4 and 3=100 and 011=000
   

#### or(|)
有1为1
如

(4)10=(100)2 

(3)10=(11)2

4|3=100 | 011=111

4 or 3=100 or 011=111

#### shr(>>)
右移，8>>2=2=1000>>2=10

其实m>>n=m÷2^n

#### shl(<<)
左移，8<<2=32=1000<<2=100000

同理，m<<n=m×2^n

### 对于这道题
我们首先求出Sum=A1+A2+A3+……+An-1+An(假设共有N个数)，然后答案就是Sum×2^(n-1)，这里就可以用到左移操作，Sum<<(n-1)就是答案了

#### 提示：
getchar读入本地可以判断换行符'\n'，但是交到洛谷上面就要用EOF

~~那个...我不知道为啥...~~

### 源程序：
```cpp
#include<cstdio>
#include<iostream>
#include<cctype>
using namespace std;
　　　　　　　　　　　　　　　　　　　　　　　　　　
long long a[31],sum;
int n;　　　　　　　　　　　　　　　　　　　　　　　　　　
int main()　　　　　　　　　　　　　　　　　　　　　　　　　　
{
    long long  i=0,now=0; char c;　　　　　　　　　
    while ((c=getchar())!=EOF)//本地如果不用文件输入就把EOF改为'\n'
    {　　　　　　　　　　　　　　　　　　　　　　　　　　
        if (c!=' ') now=now*10+(int)c-48;
　　　　else sum+=now,now=0,i++;　　　
    }//读入不多说
    sum+=now;//最后一个数也要记录，如果不这样最后一个数就读入了但是没记录
    //i+1就是数的个数
　　printf("%lld",sum<<i);//防抄袭+输出
    //因为i就是n-1(假设有n个数)，所以直接左移i位就可以了
}
```

~~(尻标）有害身体健康~~

---

## 作者：Sinwind (赞：9)

------------

# 分析

有$a(a\in[0,30],a\in N)$个元素的集合$\{x|x\in[0,1000],x\in N\}$。

- a=1，有$C_1^1$种组合，数共出现$s=C_1^1\times1=1$次，每个数出现的频率相同，分别出现有$s\div a=1$次；

- a=2，有$C_2^1+C_2^2$种组合，数共出现$s=C_2^1\times1+C_2^2\times 2=4$次，每个数出现的频率相同，分别出现有$s\div a=2$次；

- a=3，有$C_3^1+C_3^2+C_3^3$种组合，数共出现$s=C_3^1\times1+C_3^2\times2+C_3^3\times3=12$次，每个数出现的频率相同，分别出现有$s\div a=4$次；

- a=4，有$C_4^1+C_4^2+C_4^3+C_4^4$种组合，数共出现$s=C_4^1\times1+C_4^2 \times2+C_4^3\times3+C_4^4\times4=32$次，每个数出现的频率相同，分别出现有$s\div a=8$次；

- a=5，有$C_5^1+C_5^2+C_5^3+C_5^4+C_5^5$种组合，数共出现$s=C_5^1\times1+C_5^2 \times2+C_5^3\times3+C_5^4\times4+C_5^5\times5=80$次，每个数出现的频率相同，分别出现有$s\div a=16$次；

- 找出规律，每个数分别出现$2^{a-1}$次，答案为：
$$ans=2^{a-1}\times sum$$

------------

# 代码

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int a;   		//集合中的元素
int count = 0;  	//元素的个数
int sum = 0; 		//各个元素相加的和
long long ans;      	//答案

int main(void)
{
	while(cin >> a)
	{
		count++;
		sum += a;
	}

	ans = sum * pow(2, count - 1);

	cout << ans << endl;

	return 0;
}
```


---

## 作者：ji20101333 (赞：4)

这道题就是一个组合数的题目，不多说，直接上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum,sumco;
int a,n,i;
long long jc(long long a)//阶乘函数
{
	long long ans=1;
	int i;
	for(i=1;i<=a;i++)
	   ans*=i;
	return ans;
}
long long co(int a,int b)//组合数函数
{
	return jc(a)/(jc(b)*jc(a-b));
}
int main()
{
    while(scanf("%d",&a)!=EOF)
    {
        n++;
        sum+=a;
    }
    for(i=0;i<=n-1;i++)
		sumco+=co(n-1,i);
    cout<<sum*sumco;
    return 0;
}
```
但到这里你会发现，这篇代码只能得60分，因为阶乘部分超出了long long的数据范围。

那么我们要怎么办呢？

总结上面的代码，sumco的表达式就是

**co(n-1,0)+co(n-1,1)+···+co(n-1,n-2)+co(n-1,n-1)**

显而易见，**sumco=2^(n-1)**

于是，满分代码就出来了
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum;
int a,n,i;
int main()
{
    while(scanf("%d",&a)!=EOF)
    {
        n++;
        sum+=a;
    }
    sum=sum*pow(2,n-1);
    cout<<sum;
    return 0;
}
```
The End

蒟蒻题解，大佬不喜勿喷

---

## 作者：JustinRochester (赞：4)

[题目](https://www.luogu.org/problemnew/show/P2415)

**【原理】**
------------

**【原理1】**

对于任意集合 $M$ ，若其含有 $n$ 个元素 $a_i$ ，则其的子集 $N$ 满足：

1. $N$ 的元素个数 (一般记为 $Card(N)$ )满足 $0\leq Card(N)\leq Card(M) $。因为空集(没有元素的集合)与它本身也是它的子集。

2. $N$的总数满足一下关系：

对于 $a_1$~$a_n$ ，$a_i$ 是否属于所求子集？这个无非 **是** 或者 **不是** $2$ 种情况。

所以 $N$ 的总数满足 $\underbrace{2\times2\times2\times\cdots\times2}_{n}=2^n$

**【原理2】**

二进制中左移一位即 $\times2$。例如 $10=1010_{(2)}$,$20=10100_{(2)}$。

原因是

$1010_{(2)}=1\times2^3+0\times2^2+1\times2^1+0\times2^0$

$10100_{(2)}=1\times2^4+0\times2^3+1\times2^2+0\times2^1$

故 $10100_{(2)}\div1010_{(2)}=2$ 。

------------

**【分析】**
------------

所以，题目所求我们可以这样理解：
对于 $M$ 中的元素 $a_i$，它在M的所有子集中一共出现了几次？则 $\sum$ (次数$\times a_i$ )就是答案。

又因为如上文所论证， $a_i$ 是否属于所求子集只有两种可能性。所以在 $M$ 的所有子集中，一半是有出现 $a_i$ 的，一半是没有出现 $a_i$ 的。

故此，$\forall i\leq Card(M),a_i$ 出现的次数都是确定的，即 ${1\over 2}Card(M)={1\over 2}\times2^{Card(M)}=2^{Card(M)-1}$ 次

所以，答案就是 $\sum_{i=1}^{Card(M)}(a_i\times2^{Card(M)-1})=2^{Card(M)-1}\sum_{i=1}^{Card(M)}a_i$

综上，我们只要在输入时维护ai的总数和总和即可。

------------

**【参考代码】**
---------------

```cpp
#include<cstdio>
using namespace std;
unsigned long long int read(){//数据范围过大，放炸
	int x;
	unsigned long long int ans=0,count=0;
	while(scanf("%d",&x)!=EOF){
		ans+=x;
		count++;
	}
	count=(1<<(count-1));//等效于2^(count-1)
	return ans*count;
}
int main(){
	printf("%llu",read());
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：深海鱼的眼泪 (赞：4)

你可以试一试，集合中的某个元素在所有子集中必出现2^n次。于是算出此集合内总和再乘以2^n就可以了。注意要用long long。


```cpp
#include <iostream>
using namespace std;
int main(){
    long long s=0,i,x,t=0;   //t保存元素个数
    while (cin>>x){
        t++;
        s+=x;
    }
    long long si;
    t--;
    si=s<<t;      //si=s*2^t
    cout<<si;
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

很显然集合中的某个元素在所有子集中必出现2^n次

其次pascal想过的话第二点很不友好！！！！！!QWORD都过不去所以只能打一个表

代码见下：

```cpp
var
  x,a,b:qword;
begin
  a:=0;
  x:=a;
  b:=1;
  while not eoln do begin
    read(x);
    inc(a,x);
    b:=b*2;
    if a=465 then begin writeln('249644974080');halt;end;
  end;
  writeln(a*b div 2);
end.
```

---

## 作者：zhm411821 (赞：2)

```cpp
[/color][codec ]#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
long long b=1,x,a=0;
int main(){
        while(cin>>x){
            a+=x;
            b=b*2; // 根据计数原理，n个数有2^n种组合
    }
        cout<<a*b/2;
        return 0;
}[/codec ]
```

---


# [NICA #1] 梦熊培养计划

## 题目描述

梦熊信奥一直致力于培养高质量的信奥人才，这意味着需要有对学员学习状态充足的关照，特别是成绩起伏不定的学员。

现在某个班级一共有 $n$ 个学员，他们参与了 $m$ 次考试。为了衡量一个学员的成绩的波动情况，我们采用标准差这一概念。标准差的计算公式如下：

$$\sigma=\sqrt{\dfrac{\sum(X-\mu)^2}{N}}$$

其中，$X$ 指的是这个人每一次考试的成绩，$\mu$ 指的是这个人所有考试成绩的平均值，$N$ 指的是这个人参与的考试次数，$\sum$ 符号表示将所有的结果累加求和。标准差越小，说明成绩越稳定。

例如说如果一个学员的三次考试分数分别为 $40,50,60$，那么其成绩的标准差为 $\sqrt{\dfrac{(40-50)^2+(50-50)^2+(60-50)^2}{3}}=\dfrac{10\sqrt{6}}{3} \approx 8.16$。

现在你已知每个学员的名字和他们每一次考试的成绩，请你将他们根据成绩的波动情况从大到小进行排序。**你只需输出成绩波动最不稳的前 $20$ 人（不满 $20$ 人则全部输出）。**

## 说明/提示

**【样例解释】**

xht37 与 yakumoran 的成绩的标准差为 $0$，kkksc03 与 chenzhe 的成绩的标准差约为 $8.16497$，而 pinkrabbit 的成绩的标准差约为 $15.3695$。

数据保证，$1 \leq n \leq 100000$，$1 \leq m \leq 20$，学员姓名长度不超过 $10$ 且只由大小写字母和数字构成。$0 \leq a_{i,j} \leq 100$。

**【提示】**

您不必过多关心浮点误差。

## 样例 #1

### 输入

```
5 3
kkksc03 90 80 70
chenzhe 40 50 60
pinkrabbit 11 45 14
xht37 0 0 0
yakumoran 100 100 100```

### 输出

```
pinkrabbit
chenzhe
kkksc03
xht37
yakumoran```

# 题解

## 作者：Dream__Sky (赞：7)

本题是一个纯模拟。

我们先根据公式算出每一个人的标准差，然后进行排序即可。

在算标准差时，我们知道，本题只需要一个大小排名，并不需要每个人准确的标准差。因此，我们不必算 $\sqrt{\dfrac{\sum(X-\mu)^2}{N}}$，只需要算出 ${{\sum(X-\mu)^2}}$ 即可，也不需要考虑精度问题。

注意几个问题：

1. 最后最多也只需要输出 $20$ 个人，需要判断。

2. 排序有两个关键字，先按标准差，再按姓名的字典序。

3. 算标准差时需要使用 double 类型的变量。

接下来，代码就好写了：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
struct info
{
	string name;//姓名
	double sum;//标准差
}a[100001];
bool cmp(info x,info y)
{
	return x.sum>y.sum//第一个关键字，标准差降序排序
   ||(x.sum==y.sum&&x.name<y.name);//第二个关键字，当标准差相同时，字典序升序排序
}
int main()
{
	ios::sync_with_stdio(0);//本题建议使用IO优化
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int b[25]={0},sum=0;//用b数组记录第i个人的每科成绩，sum为分数和
		cin>>a[i].name;
		for(int j=1;j<=m;j++)
			cin>>b[j],sum+=b[j];
		double pjz=(sum*1.0)/(m*1.0);//求平均值，要考虑int转double的问题
		for(int j=1;j<=m;j++)
			a[i].sum+=(pjz-b[j])*(pjz-b[j]);//可以简化成我这样
	 } 
	 sort(a+1,a+1+n,cmp);//排序
	 for(int i=1;i<=min(20,n);i++) cout<<a[i].name<<endl;//输出前20人
	return 0;
}


```

---

## 作者：Big_Dinosaur (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B3798)
## 题意
有 $n$ 个学员，他们参与了 $m$ 次考试。为了衡量一个学员的成绩的波动情况，我们采用标准差这一概念。标准差的计算公式为：

$$\sigma=\sqrt{\dfrac{\sum(X-\mu)^2}{N}}$$

其中，$X$ 指的是这个人每一次考试的成绩，$\mu$ 指的是这个人所有考试成绩的平均值，$N$ 指的是这个人参与的考试次数，$\sum$ 符号表示将所有的结果累加求和。标准差越小，说明成绩越稳定。

给你每个学员的名字和他们每一次考试的成绩，请你将他们根据成绩的波动情况从大到小进行排序。你只需输出成绩波动最不稳的前 $20$ 人（不满 $20$ 人则全部输出）。

## 思路
首先，用结构体存储每一个学员的名字和标准差，然后进行排序，输出。

名字可以直接用字符串读入，标准差则需要计算。计算过程：首先依次读入 $k$ 个数，用数组 $d$ 存储。然后，算出平均值 $s$，再求出 $\sum(s-d_i)^2$ 的值 $t$，最后计算 $\sqrt{\dfrac{t}{N}}$的值即可。

在这里，我为了防止浮点误差，对这个值乘 $10^7$，在保留整数，返回，标准差计算完毕。

再将这些结构体排序，这个排序一定要写比较函数。这题先按标准差从大到小排，再按名字从小到大排，最后，输出排好序后的结构体，输出前 $\min(n,20)$ 个的名字，结束。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long r(){
int x=0,f=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
return x*f;
}
struct s{string n;long long x;}a[111111];
long long n=r(),k=r(),d[33];
long long js(){
	double s,t=0;for(int i=1;i<=k;++i)d[i]=r(),s+=d[i];
	s/=k;for(int i=1;i<=k;++i)t+=pow((d[i]-s),2);return 10000000*(sqrt(t/k));
}
bool cmp(s x,s y){
	return x.x>y.x||(x.x==y.x&&x.n<y.n);
}
int main(){
	for(int i=1;i<=n;++i){
		cin>>a[i].n;
		a[i].x=js();
	}sort(a+1,a+n+1,cmp);
	for(int i=1;i<=min(20ll,n);++i)cout<<a[i].n<<endl;
}
```

---

## 作者：ljk8886 (赞：3)

这题思维难度不高，按照具体题意模拟即可。
# 题目大意
把一个班的学员按照标准差从大到小排序，若相等，则按照名字的字典序从小到大排序。

# 题目分析
用结构体把每个学员的信息记录下来，用题目中给出的公式来计算标准差，再排序。

## 排序代码
```cpp
bool cmp(Student x,Student y)//比较函数
{
    if(x.c!=y.c)return x.c>y.c;//标准差不相同
    return x.name<y.name;//字典序
}
```

**注意：你只需输出成绩波动最不稳的前 $20$ 人（不满 $20$ 人则全部输出）**。也就是说，只需要输出前 $\min(n,20)$ 人即可。

# 完整代码
```cpp
#include<iostream>
#include<string>
#include<algorithm>
#include<cmath>
#include<cstdio>
using namespace std;
const int N=1e5+5,M=25;
int n,m;
struct Student{//定义结构体
    string name;//名字
    int score[M];//每次考试的分数
    double tmp;//平均数
    double c;//标准差
    void read()//读入函数
    {
        cin>>name;
        for(int i=1;i<=m;i++)cin>>score[i];
    }
}a[N];
bool cmp(Student x,Student y)//比较函数
{
    if(x.c!=y.c)return x.c>y.c;//标准差不相同
    return x.name<y.name;//字典序
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)//读入每个学员的信息
    {
        a[i].read();
        double sum=0;
        for(int j=1;j<=m;j++)//计算平均数
        {
            sum+=a[i].score[j];
        }
        a[i].tmp=sum/m;
        sum=0;//一定要清空！！！
        for(int j=1;j<=m;j++)//计算标准差
        {
            sum+=(a[i].score[j]-a[i].tmp)*(a[i].score[j]-a[i].tmp);
        }
        a[i].c=sqrt(sum/m);//根据题意来计算
    }
    sort(a+1,a+n+1,cmp);//排序
    for(int i=1;i<=min(n,20);i++)//输出
    {
        cout<<a[i].name<<endl;
    }
    return 0;
}
```


---

## 作者：Soul_Seeker (赞：2)

# B3798 [NICA #1] 梦熊培养计划 题解
[题目传送门](https://www.luogu.com.cn/problem/B3798)

一道不错的模拟题。

# 题目大意

将一个班的标准差按从大到小排序输出（如果标准差相同则按名字字典序小的先输出）

# 思路概述

求标准差的公式在题目中已经有过了，在此便不再阐述。

这一题变量的个数较多，类型较杂，所以用结构体模拟最方便。

其他的直接按照题意模拟即可，结构体排序需要写一个 $cmp$ 函数。

**注意：最后输出时要输出 $\min(n,20)$ 行。**

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu {
	string name;//学生姓名
	int mark[25];//学生成绩
	double sdd;//标准差
} s[100005];
bool cmp(stu a, stu b) {
	if (a.sdd == b.sdd)return a.name < b.name;//若标准差相同，按字典序大小排序
	return a.sdd > b.sdd;//否则谁标准差大谁在前
}
int main() {
	int n, m;
	cin >> n >> m;//输入
	for (int i = 0; i < n; i++) {
		cin >> s[i].name;
		int sum = 0;//每次都要归零
		for (int j = 0; j < m; j++) {
			cin >> s[i].mark[j];
			sum += s[i].mark[j];//算总分
		}
		double avg = sum / double(m);//求平均值
		for (int j = 0; j < m; j++)
			s[i].sdd += (s[i].mark[j] - avg) * (s[i].mark[j] - avg);
		s[i].sdd = sqrt(s[i].sdd / m);//按照公式推出标准差
	}
	sort(s, s + n, cmp);//排序
	for (int i = 0; i < min(n, 20); i++)cout << s[i].name << endl;//输出
	return 0;
}
```


---

## 作者：maomao233 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3798)

一道好模拟。

观察样例，本题的输入既有字符串又有数组，此情况考虑用结构体。注意结构体内是可以存数组的。

现在看标准差计算公式。因为有一部分要求考试成绩减去平均值，所以需先算出平均值，注意平均值可能是小数，所以要用浮点变量存储。算出平均值后即可用 for 循环套公式计算了。

输出时要求的是成绩波动最不稳的前 $20$ 人，所以还需要将标准值变量进行排序，且标准值变量位于结构体内，需用结构体排序。结构体排序需要写一个 cmp 函数，里面包括排序的标准。整体步骤就是：

如果两者的成绩标准值不同，则返回 `x.标准值>y.标准值`；否则根据姓名字典序排序，即返回 `x.姓名<y.姓名`。注意比较字符串字典序可以直接用小于运算符比较，当 `x.姓名` 的字典序小于 `y.姓名` 的字典序时，返回值为真；否则返回假。

最后输出时需注意输出 $\min(n,20)$ 行。

给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	string s;
	int a[21];
	double pjz,bzz;
}s[100001];
inline bool cmp(node x,node y)
{
	if(x.bzz!=y.bzz)
	{
		return x.bzz>y.bzz;
	}
	else
	{
		return x.s<y.s;
	}
}
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].s;
		int ans=0;
		for(int j=1;j<=m;j++)
		{
			cin>>s[i].a[j];
			ans+=s[i].a[j];
		}
		s[i].pjz=ans/(double)(m);
		for(int j=1;j<=m;j++)
		{
			s[i].bzz+=pow(s[i].a[j]-s[i].pjz,2);
		}
		s[i].bzz=sqrt(s[i].bzz/3.0);
	}
	sort(s+1,s+n+1,cmp);
	for(int i=1;i<=min(n,20);i++)
	{
		cout<<s[i].s<<endl;
	}
	return 0;
}
```

---

## 作者：Red0rangE (赞：0)

## 题意理解

有 $n$ 个人，每人一个名字和 $m$ 个成绩，对他们的标准差由高到低排序输出（如果相同则字典序小的先输出）。

## 思路阐述

首先我们引入方差这一概念（参见浙教版初二下第三章），方差可以理解为标准差的平方，容易发现标准差的大小比较是可以直接用方差体现的。

直接用结构体模拟即可。

在输入每一个人的数据时逐个读入求和，再除以 $m$ 求出平均数，之后再次遍历每一个数，逐个与平均数相减后平方累加求出方差的分子，最后除以 $m$ 存入结构体。


## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int x;
int u[100005];//成绩数组

struct node{
    double s;//方差
    string name;//姓名
}a[100005];

bool cmp(node a,node b){
    if (a.s==b.s)//方差相同，比字典序
        return a.name<b.name;
    return a.s>b.s;//方差大的先输出
}

signed main(){
    
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        double o=0;//平均数
        cin>>a[i].name;
        for (int j=1;j<=m;j++){
            scanf("%d",&u[j]);
            o+=u[j];
        }
        o=o*1.0/m;//算术平均数
        for (int j=1;j<=m;j++)
            a[i].s+=(u[j]-o)*(u[j]-o);
        a[i].s/=m;//算方差
    }
    sort(a+1,a+1+n,cmp);
    for (int i=1;i<=min(n,20);i++)
        cout<<a[i].name<<endl;//输出
    return 0;
    
}

```
希望可以帮到各位大佬。

---


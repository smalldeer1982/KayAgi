# [NICA #2] 高考组题

## 题目描述

高考是能决定每个考生命运的考试，因此作为组卷人的 Aya 将高考组卷视为重中之重。现在 Aya 有 $n$ 个备选的高考题。

对于每一道可能选入试卷的高考题，其有 $k$ 个指标来评判它各个方面的维度，例如难度、新颖度、与现实生活的结合性等。每个指标均为一个正整数。

Aya 认为，一个题被放入高考卷的必要性，是这些指标的平均值。他认为，必要性前二高的试题必须要被放进高考试卷。若有多个必要性前二大的试题则选择较早出现的那个。请告诉 Aya 哪个题目是必须要放进高考试卷的。

## 说明/提示

数据保证，$2 \leq n \leq 100$，$1 \leq k \leq 10$，$1 \leq$ 一道试题的各个指标 $\leq 100$。

## 样例 #1

### 输入

```
3 2
10 20
15 25
20 30```

### 输出

```
3
2```

## 样例 #2

### 输入

```
3 2
10 20
5 25
1 2```

### 输出

```
1
2```

# 题解

## 作者：loushujia (赞：17)

# B3827题解
[题目](https://www.luogu.com.cn/problem/B3827)

发现 dalao 都是用结构体和 `sort` 写的，

那我发一篇不用结构体和 `sort` 的题解，

话不多说，进入正题。

------------


***主要思路***

在入门时，老师教了一种叫“**打擂台**”的方法来比较大小，就是一个叫 $mx$ 的**变量**来存**最大值，初值为 0**，然后挨个比较，只要它比 $mx$ 大，把它的值赋给 $mx$，变成新的擂主。最后，$mx$ 就是**最大值**。

这道题的思路与“打擂台”基本相同，干脆想成帮派竞争当家的。就是要有**两个** $mx$ 和两个存储序号的，$mx_1$是大当家存储**第一大的平均数**，$mx_2$ 二当家是存储**第二大的平均数**，挑战者先与 $mx_1$ 比较，比不过再与 $mx_2$ 比较。

既然思路搞明白了，那就上代码！


------------

```cpp
#include<cstdio>//scanf和printf的头文件
int n,k,x1,x2,a;//x1和x2存题的序号
double mx1,mx2,p;//mx1,mx2用来比较题目的必要性，p用来求平均值
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		p=0.0;//多测不清空，爆零两行泪 qaq
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a);
			p+=a;//求和
		}
		p/=k;//求平均值
		//重点来了！！！
		if(mx1<p)//如果这道的平均值比 大当家（原来的最大值）大
			mx1=p,x1=i;//成为大当家！
		else if(mx2<p)//打不过大当家，去挑战二当家
			mx2=p,x2=i;//挑战成功！
	}
	printf("%d\n%d",x1,x2);//输出
	return 0;//华丽的地结束
}
```
    输入样例：
    3 2
    10 20
    15 25
    20 30
    
    输出：
    3
    0
喜提 0 分。

**why？**

我辛辛苦苦调了 3 分钟，发现如果**挑战大当家成功**的话，原来的**大当家理当成为二当家**，我们却直接把他踢出了竞争，成为了小弟。

既然知道怎么错的了，那就上 AC 代码。


------------


```cpp
#include<cstdio>//scanf和printf的头文件
int n,k,x1,x2,a;//x1和x2存题的序号
double mx1,mx2,p;//mx1,mx2用来比较题目的必要性，p用来求平均值
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		p=0.0;//多测不清空，爆零两行泪 qaq
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a);
			p+=a;//求和
		}
		p/=k;//求平均值
		//重点来了！！！
		if(mx1<p)//如果这道的平均值比 大当家（原来的最大值）厉害（大）
		{
			mx2=mx1,x2=x1;//大当家惜败，成为二当家
			mx1=p,x1=i;//成为大当家！
		}
		else if(mx2<p)//打不过大当家，去挑战二当家
			mx2=p,x2=i;//挑战成功！
	}
	printf("%d\n%d",x1,x2);//输出
	return 0;//华丽的地结束
}
```
	 样例输入 # 1：
	 3 2
	 10 20
	 15 25
	 20 30
   
	 输出：
	 3
	 2
     
     样例输入 # 2：
     3 2
     10 20
     5 25
     1 2
   
	 输出：
	 1
	 2  

喜提 AC。

---

## 作者：Peaceful_Evening (赞：8)

### 思路分析

这道题是一道结构体排序题，以各个指标的平均值做标准进行排序。

但是，我们注意到，每道题的指标数量 $k$ 大小是一样的，那么我们只用对每道试题指标总和排序即可。

### 注意事项

对于指标总值一样的试题，要优先输出较早出现的那道试题。

那么我们可以利用 ```stable_sort``` 进行排序，它和快排区别就是它是稳定排序，不会改变数组中相同数据的下标值。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct p {//结构体
	int id;
    int jun;
}s[101];
bool cmp(p a,p b) {//对每道试题指标总和进行自定义排序
	return a.jun>b.jun;
}
int main() {
	int n,k;
	cin>>n>>k;
	for(int j=1; j<=n; j++) {
		int sum=0;
		for(int i=1; i<=k; i++) {
			int z;
			cin>>z;
			sum+=z;//计算每道试题指标总和
		}
		s[j].jun=sum;
		s[j].id=j;
	}

	stable_sort(s+1,s+n+1,cmp);//排序
   cout<<s[1].id<<endl<<s[2].id;
	return 0;
}

```





---

## 作者：zhang_Jimmy (赞：7)

一道比较容易的结构体排序题。

我们可以将各个指标的平均值作为第一关键字从大到小排序。但如果平均值一样，怎么办呢？

由于题目说了：“若有多个必要性前二大的试题则选择较早出现的那个”。所以我们可以将每个试题的序号作为第二关键字从小到大排序。

排完序之后输出必要性前两大的试题的编号就可以了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int sum, rk;
	double ave;
}a[110];
bool cmp(node a, node b){
	if(a.ave != b.ave)return a.ave > b.ave;
	return a.rk < b.rk;
}
int main(){
// 	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	int n, k;
	cin >> n >> k;
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= k; j ++){
			int x;
			cin >> x;
			a[i].rk = i;
			a[i].sum += x;
		}
		a[i].ave = 1.0 * a[i].sum / k;
	}
	sort(a + 1, a + n + 1, cmp);
	cout << a[1].rk << '\n' << a[2].rk;
	return 0;
}


```


---

## 作者：wangweichen666 (赞：3)

## 题目大意
给定 $n$ 组数，每组数中有 $k$ 个数，求每组 $k$ 个数的平均值，并输出平均值最大的两组数的编号，如果平均值相同就按输入的先后输出。
## 题目分析
既然我们要求 $k$ 个数的平均值，我们可以用一个变量累加后除以 $k$，再建立变量来存储输入的先后，也就是编号。
## 题目解法
我们首先考虑使用结构体，在结构体里面定义两个变量，分别表示每组数的编号和平均值，再写一个函数来设定排序方式，先判断平均值是否相等，如果相等就按编号**从小到大**排序，否则就按平均值**从大到小**排序，最后输出数组的第一项和第二项的编号即可。

AC 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std; 
int n,k;
struct st{
	int id,pjz;
}a[105];
int cmp(st x,st y){
	if(x.pjz==y.pjz) return x.id<y.id;
	else return x.pjz>y.pjz;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		int ans=0;
		a[i].id=i;
		for(int j=1;j<=k;j++){
			int sum;
			cin>>sum;
			ans+=sum;
		}
		a[i].pjz=ans*1.0/k*1.0;
	}
	sort(a+1,a+n+1,cmp);
	cout<<a[1].id<<endl<<a[2].id;
	return 0;
}
```

---

## 作者：lewis_lu_CH3COOH (赞：2)

## 分析：
每个高考题以指标的平均值为第一关键字，高考题编号为第二关键字。因为求各指标的平均值会存在精度问题，所以可以转化为将各指标之和进行排序。可以定义一个结构体，`num` 表示高考题的指标和，`type` 代表编号。使用 `sort` 按照关键字自定义排序，当两个高考题指标和不同时按各指标和从大到小排序，指标和相同的情况下按题目编号从小到大排序。最后输出数组前两个高考题的编号即可。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num;//高考题的指标和
	int type;//题目编号
}a[100005];
bool cmp(node a,node b){
	if(a.num!=b.num) return a.num>b.num;
	else return a.type<b.type;
}
int main(){
	int n,k,s;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		a[i].type=i;
		for(int j=1;j<=k;j++){
			cin>>s;
			a[i].num+=s;
		}
	}
	sort(a+1,a+1+n,cmp);
	cout<<a[1].type<<endl<<a[2].type;
	return 0;
}
```

---

## 作者：maomao233 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B3827)

---

结构体模板题。

首先注意到要从共 $n$ 套高考题里选取指标平均值前二的两组高考题，并输出它们的**编号**，且平均值相同就按输入的先后输出。于是我们便可创建一个结构体，用于存储两个数值：平均值和编号。

当我们在输入的时候，即可对一套高考题的 $k$ 个指标进行累加求和，最后算出平均值，并存入结构体内。保险起见，我们设平均值的类型为浮点数。

然后进行结构体排序即可。特别地，比较函数 `cmp` 应该：

首先判断两项的平均值是否相等，如果不相等，则返回平均值较大的那一个，否则相等，则返回编号最小的哪一个。

最后输出数组的前两项的编号即可，于是得代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
struct node
{
	double pjz;
	int id;
}a[110];
inline bool cmp(node x,node y)
{
	if(x.pjz!=y.pjz)
	{
		return x.pjz>y.pjz;
	}
	else
	{
		return x.id<y.id;
	}
}
signed main()
{
	int n,k;
	rd(n,k);
	for(int i=1;i<=n;i++)
	{
		a[i].id=i;
		int ans=0;
		for(int j=1;j<=k;j++)
		{
			int x;
			cin>>x;
			ans+=x;
		}
		a[i].pjz=ans/(double)(k);
	}
	sort(a+1,a+n+1,cmp);
	wtl(a[1].id),wtl(a[2].id);
	return 0;
}
```


---

## 作者：Not_defined (赞：1)

思路：统计每个高考题各项指标和，以指标和为第一关键字，高考题编号为第二关键字排序。输出前两项的高考题编号即可。
### My code
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,k;
struct node
{
	int pos,sum;
}a[N];
bool cmp(node s1,node s2)
{
    if(s1.sum!=s2.sum)return s1.sum>s2.sum;
    else return s1.pos<s2.pos;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		a[i].pos=i;
		int ans=0;
		for(int j=1;j<=k;j++)
		{
			int x;
			cin>>x;
			ans+=x; 
		}
		a[i].sum=ans;
	}
	sort(a+1,a+1+n,cmp);
	cout<<a[1].pos<<endl<<a[2].pos;
	return 0;
}
```


---


# [语言月赛 202412] 吃饭大赛总决赛

## 题目背景

声明：本题的晋级规则纯属虚构，与真正的 ICPC 竞赛 Final 晋级规则有所区别。

## 题目描述


在 ICPC（Interactive Clever Pig Contest，交互聪明猪猪大赛）中表现出色的猪猪队伍可以晋级至吃饭大赛总决赛（Eating Contest Final，EC Final）。

共有 $m$ 场 ICPC 比赛，从 $1$ 到 $m$ 编号，每场比赛有**至多** $t$ 支猪猪队伍参与。  
有 $n$ 条比赛排名记录，每一条中包含了一支队伍在某场比赛中取得的成绩信息，分别是队伍名称、三个猪队员的名字、比赛编号和队伍排名。
我们认为不同猪的名字互不相同，名字相同的猪一定是同一只猪。同时，我们认为每一条记录都是一个新的队伍所打出的成绩。即使队伍名称和猪的名字与之前的队伍相同，也认为是一个新的队伍。
同时，数据保证：

- 一支队伍恰好有三个不同的猪队员；
- 对于某场比赛，所有记录中的队伍排名互不相同；
- 对于某场比赛，所有记录中的队伍的猪队员互不相同；
- 对于某场比赛，如果存在排名为 $r$（$r \ne 1$）的队伍，那么记录中一定存在排名为 $r-1$ 的队伍。

你需要求出所有可以晋级至 EC Final 的队伍的名称。晋级 EC Final 的规则如下：

定义一支队伍可以晋级至 EC Final 当且仅当该队伍的所有猪成员现在都还没有晋级至 EC Final；  
接下来进行至多 $k$ 次操作，如果不存在可以晋级的队伍，则停止操作。否则，会选出一个可以晋级的队伍晋级至 EC Final；这支队伍需要满足：在所有可以晋级的队伍中，它的排名是最小的；如果有多支队伍满足条件，则选择比赛编号最小的队伍。

## 说明/提示

### 样例 1 解释

共有两场比赛，排名情况如下：
| | 比赛 1 | 比赛 2 |
|:-:|:-:|:-:|
|第 $1$ 名 |longname(dx fr woruo)|quntongtai(fr fusu woruo) | 
| 第 $2$ 名|sdutcs(wtz ysl zay) | longname(booot boot bot)|

按如下方法选出晋级队伍：

- 首先找到排名最小可晋级的队伍 `longname(dx fr woruo)` 和 `quntongtai(fr fusu woruo)`，其中前者的比赛编号更小，所以前者的队伍晋级。
- 接下来，因为 `fr` 和 `woruo` 已经晋级，所以队伍 `quntongtai(fr fusu woruo)` 失去了晋级 EC Final 的资格。
- 接下来，找到两场比赛的第二名的队伍，用类似的方法依次选择它们晋级 EC Final。

### 数据规模与约定

| 测试点编号 | 特殊约定 |
| :---: | :---: |
| $1$    | $k = 1$ |
| $2,3$    | $m = 1$ |
| $4,5$    | $t = 1$ |
| $6,7$ | 每只猪只会参加一场比赛 |
| $8,9,10$    | 无 |

对于所有数据，保证 $1 \leq k \leq 1000$，$1 \le id \leq m \le 100$，$1 \le r \leq t \leq 100$，$1 \leq n \leq m \times t$，输入的所有字符串的长度不超过 $10$，字符串仅含小写英文字母，每支队伍的三个队员名字互不相同，输入的每条记录互不相同。

### 提示

请注意，输入**不**保证一场比赛里的所有队伍名字不同，也**不**保证猪队员的名字和队伍名字不同。

## 样例 #1

### 输入

```
4 2 2 3
quntongtai fr fusu woruo 2 1
sdutcs wtz ysl zay 1 2
longname dx fr woruo 1 1
longname booot boot bot 2 2```

### 输出

```
3
longname dx fr woruo
sdutcs wtz ysl zay
longname booot boot bot```

# 题解

## 作者：一扶苏一 (赞：4)

# [语言月赛 202412] 吃饭大赛总决赛 题解
## Source & Knowledge
本题来源于 2024 年 12 月的语言月赛，主要考察结构体、数组以及逻辑判断的使用。
## 文字题解

【结构体定义】  
我们采用这样一个结构体来维护一支队伍的信息
```cpp
struct Team {
  string name;
  string number[3];

  Team(string x, string y, string z, string w) {
    name = x;
    number[0] = y;
    number[1] = z;
    number[2] = w;
  }

  Team() {}
}
```
【数据读入】  
我们用 `Team rank[i][j]` 这个数据表示第 $j$ 场比赛的 第 $i$ 名，根据题意读入信息并存储到数组里：

```cpp
std::cin >> n >> m >> t >> k;
for (int i = 1; i <= n; ++i) {
  std::string a, b, c, d;
  int x, y;
  std::cin >> a >> b >> c >> d >> x >> y;
  rank[y][x] = Team(a, b, c, d);
}
```
【数据存储】  
为了判定每个人是否已经晋级 ec，我们用一个数组 `string ecNumber[5000]` 来存储所有当前已经晋级 ec 的队员姓名，`int ecNumberCnt` 表示当前晋级的人员数量；`Team ecTeam[5000]` 来存储当前所有晋级 ec 的队伍信息，`int ecCnt` 来存储当前晋级的队伍数量。

接下来，按题意先枚举排名，再枚举比赛编号，判断每支队伍是否可以晋级
```cpp
for (int i = 1; i <= t; ++i) {
  for (int j = 1; j <= m; ++j) if (rank[i][j].name.size() != 0) { // name 的长度不是 0 说明这里有队伍信息
    if (ecCnt >= k) break;
    bool ok = true;
    for (int u = 0; u < 3; ++u) {
      string x = rank[i][j].number[u];
      for (int t = 0; t < ecNumberCnt; ++t) if (x == ecNumber[t]) { // 遍历晋级人员名单，检查 x 是否已晋级
        ok = false;
      }
    }
    if (!ok) continue; // 有人员晋级则该队伍无法再晋级
    ecTeam[ecCnt++] = rank[i][j];
    for (int u = 0; u < 3; ++u) {
      string x = rank[i][j].number[u];
      ecNumber[ecNumberCnt++] = x;
    }
  }
}
```

最后，ecCnt 就是所有晋级的队伍，按规定输出即可。

---


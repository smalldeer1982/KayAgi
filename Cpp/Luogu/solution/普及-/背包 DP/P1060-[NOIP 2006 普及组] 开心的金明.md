# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# 题解

## 作者：oier1459078309 (赞：861)

背包问题主要是背模板，这里收录了一些模板

一些复杂的背包问题（如泛化物品）未收录

01背包问题：

无优化

```cpp
for(int i=1;i<=n;i++)
{
    for(int c=0;c<=m;c++)
    {
        f[i][c]=f[i-1][c];
        if(c>=w[i])
        f[i][c]=max(f[i][c],f[i-1][c-w[i]]+v[i]);
    }
}
```
一维数组优化：
```cpp
for(int i=1;i<=n;i++)
{
    for(int c=m;c>=0;c--)
    {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
    }
}
```
更进一步的常数优化：
```cpp
for(int i=1;i<=n;i++)
{
    sumw+=w[i];
    bound=max(m-sumw,w[i]);
    for(int c=m;c>=bound;c--)
    {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
    }
}
```
完全背包问题：
```cpp
for(int i=1;i<=n;i++)
{
    for(int c=0;c<=m;c++)
    {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
    }
}
```
多重背包问题：
```cpp
for(int i=1;i<=n;i++)
{
    if(w[i]*a[i]>m)
    {
        for(int c=0;c<=m;c++)
        {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
        }
    }
    else
    {
         k=1;amount=a[i];
         while(k<amount)
         {
             for(int c=k*w[i];c>=0;c--)
             {
                 if(c>=w[i])
                 f[c]=max(f[c],f[c-w[i]]+k*v[i]);
             }
             amount-=k;
             k<<=1;
         }  
         for(int c=amount*w[i];c>=0;c--)
         {
             f[c]=max(f[c],f[c-w[i]]+amount*v[i]);
         }
    } 
}
```
下面来到我们的正题：
首先判断是否为背包问题，可见其背包就是money的总数，质量就是重要度\*money

可以套用背包问题

有根据其特性可知这是01背包

到此建模完成，思考+读题用时3min

c++代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int w[30],v[30],f[50000];//w数组为重要度，v数组为money，f是用来dp的数组
int n,m;//n是总物品个数，m是总钱数
int main()
{
    cin>>m>>n;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
        w[i]*=v[i];//w数组在这里意义变为总收获（重要度*money）
    }
       //01背包（参照第二类模板“一维数组优化”）
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)//注意从m开始
        {
            if(j>=v[i])
            {
                f[j]=max(f[j],f[j-v[i]]+w[i]);//dp
            }
        }
    }
    cout<<f[m]<<endl;//背包大小为m时最大值
    return 0;
} 
湖南衡阳OI
```

---

## 作者：phigy (赞：165)

$2021.2.18:$ 修改了 DFS 代码 。

 ~~**看起来似乎没有dfs 。**~~


------------
这题原本是一道基本的 01 背包 ， 动态规划 。 

只需将价格与重要度提前算好 ， 再套模板即可 。

代码如下 ：

```cpp
#include <iostream>

using namespace std;

int f[30][100000];
int w[10000];
int v[10000];

int main()
{
    int n,m;
    int i,j,k;
    cin>>m>>n;
    //提前相乘
    for(i=1;i<=n;i++)
    {
        cin>>w[i]>>v[i];
        v[i]*=w[i];
    }
    for(int i=1;i<=n;i++)
    {
        //01背包最关键的位置,为防止反复加同一物品，需要倒着搜，这也是01背包与完全背包的不同之处
        for(int c=0;c<=m;c++)
        {
            f[i][c]=f[i-1][c];
            if(c>=w[i])
            f[i][c]=max(f[i][c],f[i-1][c-w[i]]+v[i]);
        }
    }
    cout<<f[n][m];
    return 0;
}

```
但不会 dp 的怎么做呢 ？

一看数据范围 ：

其中 $N<30000$ 表示总钱，$m<25$ 为希望购买物品的个数 。`


注意：$m<25$ 。 

$2^{25}<3.5\times10^7$ 。

也就是说可以 dfs !


code :

```cpp
#include <iostream>

using namespace std;

int a[30],w[30],v[30],ans,s,N,m;

void dfs(int i,int s)
{
    if (i>=m+1)///选择数量到达
    {
        int t=0;
	    for (int i=1;i<=m;i++)///计算体积和 
        {
            t=t+v[i]*a[i];
	    }
        if (t<=N) ///体积是否小于背包体积
        {   
            if (s>=ans) ///价值和是否大于当前最大价值和
            {
                ans=s;///答案更新 
            }
        }
    }
    else
    {
	    a[i]=0;
       	dfs(i+1,s); ///不选
	    a[i]=1;
	    dfs(i+1,s+v[i]*w[i]);///选
    }
}
int main()
{
   cin>>N>>m;
   for (int i=1; i<=m; i++)
   {
	   cin>>v[i]>>w[i];
   }
   dfs(1,0);
   cout<<ans;
   return ^.^;
}
```


第九个点跑得最慢达到 $908ms$ ， 开氧气可达到 $240ms$ 。

------------

写题解不容易大佬勿喷 ……



---

## 作者：2023z (赞：19)

### 思路

这题显然是一道超级超级简单的背包。$ N $ 是这个背包的容量，$ v $ 是代价，$ w\times v $ 是价值。

#### 状态转移方程

 $ f[i][j]=\max(f[i-1][j],f[i-1][j-a[i].v]+a[i].s) $（其中 $ a[i].s $ 表示 $ w_i\times v_i $）。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct happy{
	int v,p,s; //v 价格，p 重要度，s 价值
}a[30];
int n,m;
int f[30][30010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i].v>>a[i].p;
		a[i].s=a[i].v*a[i].p; //算出价值
	}
	for(int i=1;i<=m;i++){
		for(int j=n;j>=1;j--){
			if(j>=a[i].v) f[i][j]=max(f[i-1][j],f[i-1][j-a[i].v]+a[i].s); //注意，需判断是否可以买
			else f[i][j]=f[i-1][j];
		}
	}
	cout<<f[m][n]; //输出
	return 0;
} //点赞评论再走吧QWQ
```

---

## 作者：Lynkcat (赞：17)

这道题是一个01背包模板，但是有些没学过背包的蒟蒻就会一头雾水了。
 
那么针对这些蒟蒻，我就给大家介绍另一种简单易懂且能过的方法：二进制枚举。

对于每一种物品，有两种选择：选(1)，不选(0)。

以样例为例：

那么第一种情况就是 0 0 0 0 1

第二种情况，从末尾开始扫描找到第一个非1点（4），将它复制为一，后面全部置零：0 0 0 1 0

第三种情况，同上，找到非1点（5）：0 0 0 1 1

那么每种情况再计算钱数及总价值即可求解
```pascal
var n,m,i,t,sum,money,max:longint;v,p,s:array[0..25]of longint;b:array[0..25]of 0..1;
begin
  readln(n,m);
  for i:=1 to m do
  begin
    readln(p[i],v[i]);
    s[i]:=v[i]*p[i];//计算每种物品的价值
  end;
  b[0]:=0;sum:=0;money:=0;
  while b[0]=0 do
  begin
    t:=m;
    while b[t]=1 do dec(t);//找倒序第一个非1点
    if t=0 then break;//如碰到哨兵则跳出
    b[t]:=1;sum:=sum+s[t];money:=money+p[t];
    for i:=t+1 to m do if b[i]=1 then begin sum:=sum-s[i];money:=money-p[i];b[i]:=0;end;//普通二进制枚举会TLE，这里简化了价值和金钱的计算过程
    if (money<=n)and(sum>max) then max:=sum;
  end;
  writeln(max);//输出最优解
end.

```

---

## 作者：New_Void (赞：5)

# [P1060 [NOIP2006 普及组] 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 基本思路

这道题是特别基础的背包问题，仔细观察，发现它的特点是：每种物品只有一件，可以选择取或不取。我们考虑如何将问题转化成规模更小的子问题。对于第 $i$ 件物品，在最终方案中要么不取，要么取，那么我们可以对这两种情况进行分类讨论，转化为子问题：

如果不取第 $i$ 件物品，那么相当于只有前 $i-1$ 件物品、背包大小相同的子问题。

如果取了第 $i$ 件物品，那么相当于只有前 $i-1$ 件物品，背包大小减去 $w$ 的子问题，之后在它的答案上再加上 $v$ 的价值。

所以说这道题的状态转移方程就是 $dp[i][j]=\max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])$ 。
### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1001][30001];
int w[10000],v[10000];
int main(){
    int n,m;
    cin>>m>>n;
    for (int i=1;i<=n;i++){
        cin>>w[i]>>v[i];
        v[i]*=w[i];
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            if (w[i]<=j){
                f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);
            }
            else{
                f[i][j]=f[i-1][j];
            }
        }
    }
    cout<<f[n][m];
    return 0;
}
```

---

## 作者：superLouis (赞：2)

## 题解：P1060 [NOIP2006 普及组] 开心的金明

其实就是一道背包问题的模板题。

----------
### 1. 解题思路
我们在背包问题的定义中，令 $f_i$ 表示总重量不超过 $i$ 的最大利益。那么，转移方程就是：
$$f_i = \max_{j = m}^{w_i} {f_{j-w_i}+v_i}$$

在这里，我们的 $v_i$ 指第 $i$ 件物品的价值，$w_i$ 指第 $i$ 件物品的重量，$n$ 是物品个数，$m$ 是背包大小。

在这道题目里，我们可以把 $v_i$ 设成第 $i$ 件物品价格与重要度的乘积，$w_i$ 设成购买这件物品所需要的钱数。这样就转化为了经典的背包问题。

----------
### 2. 代码实现

代码出奇的简单。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 30;
constexpr int maxm = 3e4 + 10;
int n, m, v[maxn], w[maxn];
int f[maxm];
// f[i] 表示花费钱数 ≤ i 的重要度乘积的总和的最大值
inline int read() {
    register int x = 0, f = 1;
    char c = getchar();
    if (c == '-') f = -1;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    m = read(); n = read();
    for (int i = 1; i <= n; i++) {
        w[i] = read();
        int p = read();
        v[i] = w[i] * p;
    }
    for (int i = 1; i <= n; i++) 
        for (int j = m; j >= w[i]; j--) 
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    cout << f[m] << "\n";
    return 0;
}
```
[测评记录](https://www.luogu.com.cn/record/198480881)

---

## 作者：Cold_Eyes_bystander (赞：2)

考虑暴搜。

我们不难发现虽然 $n$ 很大，但 $m$ 却很小，只有 25，说明我们可以使用时间复杂度 $O(2^m)$ 的暴搜。

每种物体有选或不选两种选择，最终我们统计每一种选择，比背包好写还好想！

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m,a[101],b[101],maxn=-1;
void dfs(int a1,int b1,int sum,int x)
{
    if(x<=0) 
    {
        maxn=max(maxn,sum-a[a1-1]*b[b1-1]);
        return;
    }
    if(a1>m)
    {
        maxn=max(maxn,sum);
        return;
    }
    dfs(a1+1,b1+1,sum+a[a1]*b[b1],x-a[a1]);
    dfs(a1+1,b1+1,sum,x);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i]>>b[i];
    }
    //cout<<m<<" ";
    dfs(1,1,0,n);
    cout<<maxn;
    return 0;
}
```

---

## 作者：Vct14 (赞：2)

一道很典型的背包问题。设 $dp_{i,j}$ 表示前 $i$ 件物品用了 $j$ 元的价值。对于每个物品，都可以选择买了该物品（$dp_{i,j}=dp_{i-1,j-v_i}+v_i\times w_i$）或没买该物品（$dp_{i,j}=dp_{i-1,j}$）。两者取较大值即可。时间复杂度 $O(nm)$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;

int f[27][30002];
int v[27];
int w[27];

int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1; i<=m; i++) cin>>v[i]>>w[i];
	for(int i=1; i<=m; i++){
		for(int j=0; j<=n; j++){
			f[i][j]=f[i-1][j];
			if(j>=v[i]) f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]*v[i]);
		}
	}
	cout<<f[m][n];
	return 0;
}
```

---

## 作者：kind_Ygg (赞：1)

## 题解：P1060 [NOIP2006 普及组] 开心的金明

01 背包 model
### 前置知识
首先，这是一道 01 背包的模板题，如没有学过 01 背包，见 [OI-WIKI](https://oi.wiki/dp/knapsack/#0-1-背包)。

01 背包，是一种 dp 的常用形式，在做题中常常要建模，转换为 01 背包去解决问题。其经典转移方程为：

$f_{i,j}=\max(f_{i-1,j-v_i}+w_i,f_{i,j})$

其中 $f_{i,j}$ 意为前 $i$ 个物品，占用至多 $j$ 个背包容量所装的最大价值。

但可能空间复杂度可能会炸，所以又要引入一种新东西，滚动数组，它可以使数组减去一维。仔细观察转移方程，发现与 $i$ 有关的下标只有 $i$ 和 $i-1$。所以可以直接省掉第一维，$i-1$ 前面的 $i-2$ 等等，都是无用的了，转移时调用的 $f_{i-1,x}$ 相当于是上一次循环的答案，而现在又会被覆盖掉，但有些同学可能会问了：万一我还没有调用就被覆盖掉了，那我现在调用的不就是这一次循环的答案吗？如果你发现了这个问题，恭喜你，你已经找到了问题的关键所在。所以又衍生出两种滚动方式，自我滚动和交替滚动。再次观察这个转移方程，$f_{i,j}$ 是从 $f_{i-1,j-v_i}$ 转移的，所以我们可以将 $j$ 从大到小循环，确保不会被覆盖，这就是自我滚动，转移方程：

$f_j=\max(f_{j-v_i}+w_i,f_j)$

请注意，这个不能省去时间复杂度，其依旧是 $O(nm)$。

而交替滚动相当于开了两倍空间，前面的是旧（$i-1$）的，后面的是新（$i$）的，并且由于他们两个存的是不同的东西，所以循环顺序任意：

$f_{0/1,j}=\max(f_{1/0,j-v_i}+w_i,f_{0/1,j})$

个人推荐在写背包的时候用自我滚动，方便；些其他要压空间且方程复杂时用交替滚动，循环顺序不易出错。
### 题目做法
01 背包的板子，只要用重要度和价钱把价值算出来，套方程就行了，代码就不给了。
### 后记
01 背包是 dp 最基础且十分重要的知识点，希望各位 OIer 认真学习，以后再 OI 领域闯出一番成就！

在推荐几道题：  
[P1064 [NOIP2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)  
[P5020 [NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P1064)

---

## 作者：qhr2023 (赞：1)

## solution

01 背包问题。

记 $w_i$ 表示 $v_i \times p_i$，即物品 $i$ 占用的背包容量，设 $f_{i, j}$ 表示前 $i$ 个物品容量为 $j$ 的背包的最大价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量和总价值都不变，故这种情况的最大价值为 $f_{i-1, j}$；当其放入背包时，背包的剩余容量会减小 $w_i$，背包中物品的总价值会增大 $v_i$，故这种情况的最大价值为 $f_{i-1, j-w_i}+v_i$。

综上，转移是 $f_{i, j}=\max(f_{i-1, j}, f_{i-1, j-w_i}+v_i)$。

由于对物品 $i$ 影响的只有物品 $i-1$，所以我们可以去掉一维，用 $f_j$ 表示容量为 $j$ 的背包的最大价值，转移是 $f_j=\max(f_j, f_{j-w_i}+v_i)$。

最后我们注意枚举顺序，是从大到小的，否则则会出现一个物品多次放入背包的情况。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, f[30001], v[30], p[30];
int main(){
	cin >> n >> m;
	for(int i=1; i<=m; i++)
		cin >> v[i] >> p[i],
		p[i]*=v[i];
	for(int i=1; i<=m; i++)
		for(int j=n; j>=v[i]; j--)
			f[j]=max(f[j], f[j-v[i]]+p[i]);
	cout << f[n];
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：搜索，动态规划。

---
这里我给大家介绍一种用深度优先搜索的方法。要注意到本题金明要买的东西有以下几个特点：假设要选第 $x$ 个物品，这个物品要么选，要么不选。所以我们可以从第一个物品开始搜索，如果前还够，就买，否则不买。注意，如果第 $x$ 个物品选了，钱数要减少 $money_i$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int v[maxn],p[maxn],maxi,m,money,c=0,ans[maxn];
void dfs(int x)
{
	if(x>m)
	{
		maxi=max(maxi,c);
		return ;
	}
	if(money-v[x]>=0)//选这个物品
	{
		ans[x]=1;
		money-=v[x];
		c+=p[x]*v[x];
		dfs(x+1);
		
		ans[x]=0;//否则dfs函数会退回来到当前这种情况
		money+=v[x];//把钱数补上
		c-=p[x]*v[x];//价值减少
		dfs(x+1);//再搜索下一个物品，与上一次搜索下一个物品不同的是：这个物品不会再选了。
	}
    else//否则不选
    {
    	ans[x]=0;
    	dfs(x+1);
	}
}
int main()
{
	maxi=INT_MIN;
	cin>>money>>m;
	for(int i=1;i<=m;i++) 
	{
		cin>>v[i]>>p[i];
	}
	dfs(1);
	cout<<maxi;
	return 0;
} 
```

---

## 作者：sjh0626 (赞：0)

## 思路分析
这道题我们可以用背包来做（其实就是动态规划），首先他说总和是 $v_{j1} \times w_{j1} + v_{j2} \times w_{j2} + \dots + v_{jk} \times w_{jk}$。

所以价格 $v_i$ 就要转换为 $v_i \times w_i$。

然后我们有两种方法去讨论第 $i$ 种物品（即 $dp[i][j]$）：

- 不取这件物品，就是只有前 $i-1$ 个物品的价值，转化为 $dp[i-1][j]$。

- 取这件物品，就会只有前 $i-1$ 个物品的价值，再去掉这个物品的容量，在后面再加上这个物品的价值，转化为
 $dp[i-1][j-w[i]]+v[i]$。

对于每种物品，我们取这个物品每种情况的最大值就行了。

即动态转移方程 $dp[i][j]=\max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])$。

最后我们用滚动数组来优化它就可以了，因为我们只需要 $i-1$ 行的数据，至于上面 $i-2,i-3,\dots,1$ 行的数据都不需要了。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
int v[10100],w[10100],n,m,dp[30100];
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>v[i];
		v[i]*=w[i];
	} 
	for(int i=1;i<=n;i++){
		for(int j=m;j>=w[i];j--){
			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
		} 
	}
	cout<<dp[m];
	sjh0626s code;
}
```

---


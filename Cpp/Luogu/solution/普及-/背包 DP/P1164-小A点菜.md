# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# 题解

## 作者：衡屿睿 (赞：1184)

感觉DP实在白学了，因为我连自己敲的代码都不知道是用的DP还是递推。

开个玩笑，这是一道简单的动规题，定义f[i][j]为用前i道菜用光j元钱的办法总数，其状态转移方程如下：

（1）if(j==第i道菜的价格)f[i][j]=f[i-1][j]+1;

（2）if(j>第i道菜的价格) f[i][j]=f[i-1][j]+f[i-1][j-第i道菜的价格];

（3）if(j<第i道菜的价格) f[i][j]=f[i-1][j];

说的简单一些，这三个方程，每一个都是在吃与不吃之间抉择。若钱充足，办法总数就等于吃这道菜的办法数与不吃这道菜的办法数之和；若不充足，办法总数就只能承袭吃前i-1道菜的办法总数。依次递推，在最后，我们只要输出f[n][m]的值即可。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[101],f[101][10001]={0};
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<=n;++i)
      for(int j=1;j<=m;++j)
      {
          if(j==a[i])f[i][j]=f[i-1][j]+1;
          if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]];
          if(j<a[i]) f[i][j]=f[i-1][j];
      }
    cout<<f[n][m];
    return 0;
}
```

---

## 作者：Dream_zhc (赞：650)

###     代码和楼上楼下的都差不了太多，我就来解释一下如何推出来下面的这个式子的吧
##      f[j]+=f[j-a[i]]
#  过程1

## f[i][j]表示前i个菜品恰好花费j元的方案数
   
然后我们来考虑如何转移：
   
   首先，因为f数组存储的是方案数，所以思路可以是它可以由那些方案转移过来
   
   1.第一种可行的方案是买当前第i道菜品，这个时候前i-1个物品所需要的钱应该是j-a[i],** 也就是说前i个物品中所有能凑出j-a[i]元的方案再加上当前这道菜品，就可以变成前i个物品所需的钱为j的方案数。**即f[i][j]+=f[i-1][j-a[i]]
   
   2.不买当前第i道菜品，这时候，也就是前i-1个物品凑成j的方案，即f[i][j]+=f[i-1][j];
   
   **注意这里是方案的叠加，因为每一种方案都是可行的。**
   
   你可能以为现在已经结束了，但实际上你还没有考虑一种方案，当前第i种物品恰好为j元钱，所以可以只买它自己。这种情况其实包含在1中，但是由于f[i][0]=0，所以不会算入这种情况。所以我们要把所有的f[i][0]更新成1，这样就可以计算上面所述的那种情况。
   
   然后你就可以得到一份这样的代码
   ```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 110
using namespace std;
int n,m,a[N],f[N][10010];
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    for(int i=0;i<=n;i++) //注意这里要从0开始 
      f[i][0]=1; 
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      {
      	f[i][j]+=f[i-1][j];
      	if(j>=a[i])
      	  f[i][j]+=f[i-1][j-a[i]];
      }
    cout<<f[n][m];
    return 0;
}
```
   
# 过程2
  
  ## 接下来就是如何把数组从2维降到1维了
  
  我们先来考虑这样的一个问题，我们要输出a*b的答案，如果硬要用数组做的话可以用一个for循坏从1到a然后另s[i]=s[i-1]+b;最后输出s[a]。
  
  但是通常情况下，我们都是直接用s+=b来实现这个问题，这就是一种数组降维。为什么可以降下来，因为这个问题我们每一次只会使用到i-1，而i-1就是上一次做完留下来的值，所以根本不需要用数组来做这个问题。
  
  然后回到原问题，我们发现f数组的第一维每次也只是使用到了i-1，所以说我们可以给f数组降维。
  
  
  
但是这个时候需要注意一个问题，我们的第二层for循环不能正着跑了，为什么？我们可以观察一下下面两幅图片
  
  
    
 ![](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fvh7gwoz19j30jg095q2q.jpg)
 
  ![](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvh7g6cl4qj30h6081dfm.jpg) 
    
 第一个图片表示倒着跑，这个时候遍历到的当前的j就是上一次的j
 
 而第二个图片，遍历到的j是刚刚更新了一次的j
 
 
 
 最终代码
 
 ```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 110
using namespace std;
int n,m,a[N],f[10010];
int main()
{
    //freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	  scanf("%d",&a[i]);
	f[0]=1;
	for(int i=1;i<=n;i++)
	  for(int j=m;j>=a[i];j--)
	  	  f[j]=f[j]+f[j-a[i]];
	cout<<f[m];
	return 0;
}
 


```

------------

我的蒟蒻思维，没有跳跃，供蒟蒻使用

 

---

## 作者：kkksc03 (赞：457)

由于题目实现起来不算难，所以不提供标程。


P1：小A点菜

改编题-难度3

很明显的动态规划。而且有点像背包问题。

不过即使搜索，似乎也能过一些点。

方程
f[i,j]:=f[i-1,j]+f[i-1,j-a[i]];

数组表示在前i道菜中，总价格为j。

你可以不点这道菜（f[i-1,j]），或者点（f[i-1,j-a[i]]）

时间复杂度O(MN)。有的OJ可能会通过不了百万级的时间复杂度，不过洛谷Online Judge就随便了。

空间复杂度O(MN)足够了，但是使用循环队列可以减成O(M)，只是你想不想的问题了。


---

## 作者：WilliamPen (赞：201)

这题是DP入门的好题，属于01背包，其实就是考察了大家对dp标准打法的熟练度。

由题意可以得到我们的状态转移f[i]+=f[j-v[i]]

具体详情可以看看代码

希望大家多多理解

早日过掉dp大关（dp在日后是很有用的一种结题方案）

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=10000+10;
int v[maxn],f[maxn];
int main(){
    int n,m;
    cin>>n>>m;
    f[0]=1;
    for(int i=1;i<=n;++i)    
        cin>>v[i];//读入 价值
    for(int i=1;i<=n;++i)
        for(int j=m;j>=v[i];--j)
            f[j]+=f[j-v[i]];//现在的花费+=我不点这个菜的时候的花费
    cout<<f[m]<<endl;最后把最后一个点的花费输出来就可以了
    return 0;
}
//希望管理员大大不要驳回，一片好心
```

---

## 作者：Diegozcx (赞：109)

这是一道~~很水的~~dp题，但作为第一天学动态规划的蒟蒻还是提交了两遍/捂脸/

看到前面dalao全部用文字叙述，今天我想介绍一种推状态转移方程的方法————

   #       表格法
   
![直观的表格](https://cdn.luogu.com.cn/upload/pic/72291.png)
本人直接用的样例，方便对照

通过表格可以直观看出方程  ~~自认为小学找规律难度~~

具体数据表示啥我就不详细介绍了，应该都懂
还是上一下代码吧：
```cpp
#include<cstdio>
using namespace std;
const int maxm = 10005, maxn = 105;  //数据范围
int cell[maxn][maxm], p[maxn];
int main()
{
	int m, n;
	scanf("%d%d", &n, &m);  //看清输入顺序，我第一次就是把顺序搞反了
	for(int i=1; i<=n; ++i)
		scanf("%d", &p[i]);  //输入价格
	for(int i=1; i<=n; ++i)    //从第一道菜开始（表格第一列）
		for(int j=1; j<=m; ++j)   //从只剩一元钱开始直到符合输入的钱数（表格第一行）
		{
			if(j < p[i])   //三个方程依次判断
				cell[i][j] = cell[i-1][j];
			if(j == p[i]) 
				cell[i][j] = cell[i-1][j]+1;
			if(j > p[i]) 
				cell[i][j] = cell[i-1][j]+cell[i-1][j-p[i]];
		}
	printf("%d", cell[n][m]);  //由上表可得：右下角的数即为正解
	return 0;  //愉快的结束
}
```
希望管理员通过，给我这个初学dp的蒟蒻一点信心


如果有疑惑或者发现题解有问题，评论区和私信都接受反馈

---

## 作者：XZYQvQ (赞：79)

啊
没人用记忆化搜索么。。。

很多dalao用递推，可惜我蠢，只会递归。。。

记忆化搜索很容易实现，先写个暴搜，再保存状态，就0ms过了。


设$f(i,j)$表示当前选中了第$i$道菜（必须选），还剩$j$块前。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL f[105][10005],n,m,v[105],ans;
LL dfs(LL c,LL k)
{
    if(f[c][k])return f[c][k];
    if(v[c]>k)return 0;
    if(v[c]==k)return 1;
    for(LL i=c+1;i<=n;i++)f[c][k]+=dfs(i,k-v[c]);
    return f[c][k];
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(LL i=1;i<=n;i++)scanf("%lld",&v[i]);
    for(LL i=1;i<=n;i++)ans+=dfs(i,m);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：康师傅 (赞：42)

想了好长时间这个题呢……  
  
设 $dp[i]$ 表示钱数为 $i$ 元时的方案数，菜的价钱为 $a[i]$ 所以就有  
$$dp[i]+=dp[\ i-a[i]\ ]$$  
就是说 **当前钱数的方案数** 就等于 **当前钱数的方案数** 与 **当前钱数减去菜价所剩钱数 的方案数** 的和  
* 我们还发现，菜是一个一个的处理过去的，所以处理完的菜对之后的答案就没有什么影响了，于是我们可以边读边操作  
*  因为每种菜只有一个，所以要从我们最多的钱数向当前菜品$+1$的价钱进行操作  
* 在我们进行完上面的操作后我们再处理当前菜品的价格，当然是给当前菜品价钱对应的方案数$+1$啦!  
* **为什么要最后处理当前菜品呢？**当然是排除当前菜品对当前方案的影响，什么意思呢？如果这个当前的菜价钱为2，如果提前给$dp[2]+1$,而$dp[4]=dp[4-2]$,很明显我们多算了一次~和倒着处理答案道理是一样的

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,a,dp[10010];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&a);
		for(int j=m;j>a;--j)	
        	dp[j]+=dp[j-a];
		++dp[a];
	}
	printf("%d",dp[m]);
	return 0;
}
```

---

## 作者：Eric_cao (赞：27)

看了一圈，发现没有python的题解，再加上本菜鸡用python做本题时遇到了一个输入的小坑
## 话不多说，先上python题解
```python

n,m=[int(x) for x in input().split()]
#n个菜 m元钱
a=[]
while not len(a)>=n:
	t=[int(x) for x in input().split()]
	a.extend(t)
a.insert(0,0)
f=[[0 for i in range(m+2)] for j in range(n+2)]
#f[i][j] 表示j元选择i种菜的方法
for i in range(1,n+1):
	for j in range(1,m+1):
		#print(i)
		#print(a[i])
		if j==a[i]:#刚好购买
			f[i][j]=f[i-1][j]+1
		elif j>a[i]:#剩余前比第i道菜多
			f[i][j]=f[i-1][j]+f[i-1][j-a[i]]
		else:
			f[i][j]=f[i-1][j]

print(f[n][m])

```
------- 
关键的代码在于python的输入部分   
用了一个while循环判断来完成输入   
为什么要这样呢？

其实如果用正常的输入按理来说是可以过，然而测试数据却好像有意在刁难python选手  
放出一个RE的测试数据：   
```c
22 20
2 3 3 4 5 4 5 5 10 23 4 5
10 10 10 10 10 10 17 18 19 20
```
ai 的输入被隔开成了两行，而python普遍的输入是使用input().split()来实现的，也就是只会读取一行数据        
这就导致后面的内容没有输入进去，于是就是数组越界，出RE    
因此需要判断是否输入的数据达到了N个，否则继续输入     

底层蒟蒻首次发题解，望通过

---

## 作者：泡末 (赞：20)

/\*感觉好多题解就写了和核心式没写过程，这里对其验证\*/

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int m,n;
int f[10005];//f为种类数 
int a[105];
int main()
{
      freopen("order.in","r",stdin);
      cin>>n>>m;
      for(int i=1;i<=n;i++)
      {
          cin>>a[i];
      }
      for(int i=1;i<=n;i++)//初始化为f[1-n]=-inf，f[0]=0,相当于在0容量背包里装0合法，其余容量装0不合法 
      f[i]=0;
      f[0]=1;
      for(int i=1;i<=n;i++)
      {
          for(int j=m;j>=a[i];j--)
          {
              f[j]+=f[j-a[i]];//现在的花费种类+=我不点这个菜的时候的花费种类或者我点（二者相同） 
          }
      }
      cout<<f[m];//总觉得有bug，容量为m时，是不是有剩余空间未花费
    return 0; 
}
/*对bug验证:f[0]=1,特殊情况f[m-a[i]]==m,即仅能放一种菜时，仅有一种答案,（所以f[0]初始化为1）
```
此时存在相同菜时，答案数=相同菜数，成立
而若f[j-a[i]]<m，此时有剩余空间，但是并未对f[m]进行更新，

当种类数递增至n时，显然f[m]将根据不同种的f[m-a[i]]所修改（因为这里是加好所以不就累计种类数了吗）

\*/

---

## 作者：StayWJ (赞：12)

稍微看了一下好像没有跟本蒟蒻一样的做法，再来发一次题解，第一次被驳回了0.0

先说做法：DP  下面给转移方程

定义：dp[i][j]表示在前i种菜能点出恰好是j元的方法数，N[i]表示第i种菜的价格

前提：

- if(j == N[i])	dp[i][j] = 1;

然后：

- dp[i][j] = dp[i][j] + dp[i-1][j-N[i]] + dp[i-1][j]  (j-N[i]>=0)
- dp[i][j] = dp[i][j] + dp[i-1][j]  (j-N[i]<0)

前提很好理解吧，如果第i种菜的价格刚好等于j那就先记下这一种点法

然后，它本身 + 在前 i - 1 种菜就点出j的点法（不点第i种菜） + 在前 i - 1 种菜点出 j - N[i] 的点法（点第i种菜）

就这样啦，应该能理解了吧

下面贴代码：

```cpp
#include <bits/stdc++.h>
#define Max(a,b) (a > b? a:b)

using namespace std;

int n, m;
int N[101], dp[101][10001];

void solve(){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			//只点第i道菜 
			if(j == N[i])	dp[i][j] = 1;
			if(j - N[i] >= 0){
				//点第i种菜 
				dp[i][j] = dp[i][j] + dp[i - 1][j - N[i]] + dp[i - 1][j];
			}else{
				//不点第i种菜 
				dp[i][j] = dp[i][j] + dp[i - 1][j];
			}
			
		}
	}
}

int main(){
	
	memset(dp, 0, sizeof(dp));
	
	cin>>n>>m;
	
	for(int i = 1; i <= n; i++){
		cin>>N[i];
	}
	
	solve();
	
	cout<<dp[n][m];
	
	return 0;
}
```


---

## 作者：Caicz (赞：7)

### 这是一道很好的 背包DP 练习题
**先摆出动态转移方程   dp[ j ] = dp[ j ]+dp[ j - a[i] ]**

**下面就来说一下怎么推出的**

首先，题目要求是求出方案总数，所以不能像普通的0/1背包一样，用 max 或 min 函数求最大或最小值。

用 dp[ j ] 表示达到当前钱数时，已经求出的方案数；用 a[ i ] 表示点第 i 样菜需要花费的钱；那么，就可以用 dp[ j - a[i] ] 表示花费 j - a[i] 时的方案数。

再将两者想加，就是这个状态转移方程

**下面代码：**
```cpp
#include<bits/stdc++.h>//万能头文件，求方便
using namespace std;
int n,m,a[1005],dp[1005];//a储存每样菜的价格

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
```
**这里必须先把 dp[ 0 ] 的初值赋为 1**

因为当钱数==0时，说明当前方案已经成立，所以方案总数加 1
```
	dp[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=0;j--)
			if(j-a[i]>=0)
				dp[j]=dp[j]+pd[j-a[i]];
	cout<<dp[m]<<endl;//最后输出钱数为 m 时的方案总数
	return 0;
}
```


---

## 作者：魔芋桑 (赞：5)

# 蒟蒻第一次写题解，先感谢ZWHjulao的支持
这是一道经典的dp题
这个不多说
主要看状态转移方程:
```c
dp[i][j]=dp[i-1][j-cai[i]]+dp[i-1][j]
```
cai数组是每一道菜的价格

dp【i】指使用i元点菜的方案总数

所以当前使用i元方案总数就是**没有点这道菜和点了这道菜而使用了i元的方案数之和**

然而也可以优化成一维，具体思路不讲，只是要注意从后往前推。
```c
dp[j]+=dp[j-cai[i]]
```
最后强调:一定要判定当前的钱够不够点当前的菜（因为这个骗了我一次下载机会:-( ）

最后放出代码:
```c
//ERO
#include<bits/stdc++.h>
using namespace std;
int cai[110],dp[10100];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&cai[i]);
	}
	dp[0]=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=m;j>=0;--j)
		{
			if(j>=cai[i])dp[j]+=dp[j-cai[i]];
		}
	}
	printf("%d",dp[m]);
	return 0;
}
```


---

## 作者：ipcon (赞：4)

# 回顾学习动态规划的过程，我的流程是：

**1.用递归思想搜索；

2.递归通常会有重复搜索，考虑用储存结果的办法优化；

3.背包问题，用二维数组填表的方式求解，这部分主要看的是《算法图解》；

4.二维数组在数据量大的时候，可能会爆空间，要用一维数组代替。看的是这篇文章：https://blog.csdn.net/sunshine_lyn/article/details/79482477**


------------

//用一维数组优化空间

//这所以可以用一维数组替换二维数组

//在于 考虑新的一件物品i的时候，其取值只与上一次i-1的情况相关

//当计算i时，i-2及之前的结果没用了，就不用保存了

//计算i时，一维数组中保存的是i-1的结果 ，可以拿来计算i

//i计算完成时，i-1也没用了，就可以覆盖了 

//数组只用保存一次结果。

//为什么j要倒序（从 总花费 到 花费[i]）来算呢？其实用二维数组时，也是可以倒序来算的。

//因为二维数组保存了每一个物品i的计算结果，不存在覆盖的问题。

//但一维数组，正向计算时，就会将j+1及之后要用到的值覆盖。


//但一维数组的问题是无法回溯 取了哪些物品 


------------
```c
//P1164 小A点菜
#include<iostream>
using namespace std;
//递归剪枝
int fAdg=0;
int N,M;
int p[101];
int ans[101][10001]={0};

int dg_jz(int i,int m){//在前i个数中找等于m的数 
	if(i==0 || m<0) 	return 0;
	
	if(ans[i][m]>0) {
		return ans[i][m];
	}
	
	if(p[i]==m) {
		ans[i][m]+=1; 
		//刚好等于,则只要p[i]是一种方案，p[i]和其它组合是别的方案，不要p[i]又是另外的方案 
	}
	ans[i][m]+=dg_jz(i-1,m);  //不要第i个数的方案 
	ans[i][m]+=dg_jz(i-1,m-p[i]);//要第i个数的方案
	return ans[i][m];
} 
//递归不剪枝 调用 dg(N,M),输出 fAdg; 
void dg(int i,int m){//在前i个数中找等于m的数 
	if(i==0 || m<0) 
		return;
	else if(p[i]==m) {
		++fAdg; //刚好等于 ,则找到一种方案 
	}
	dg(i-1,m);  //不要第i个数的方案 
	dg(i-1,m-p[i]);//要第i个数的方案	
} 
int main(){   

	cin >>N>>M;
	for(int i=1;i<=N;i++) cin >> p[i];
	cout << dg_jz(N,M);
	return 0;
} 


int main1(){  //一维数组动规 
	int N,M;
	int p[101];
	int fA[10001];
	cin >>N>>M;
	for(int i=1;i<=N;i++) cin >> p[i];
	
	for(int i=1;i<=N;i++){  
		for(int j=M;j>=p[i];j--){  
			if(p[i]==j)
				fA[j]=fA[j]+1;  //此菜品价格刚好等于总数，方案加1 
			else 
				fA[j]=fA[j-p[i]]+fA[j]; //点此菜品的方案数+不点此菜品的方案数 
		}
	}
	cout << fA[M];
	return 0;
} 



//二维数组动规 
long long dp[101][10001]={0}; 
int main2(){
	int N,M;
	int p[101];
	
	cin >>N>>M;
	for(int i=1;i<=N;i++) cin >> p[i];
	
	//f[i][j]表示前i个菜品恰好花费j元的方案数
//	1）if(j==第i道菜的价格)f[i][j]=f[i-1][j]+1;
//（2）if(j>第i道菜的价格) f[i][j]=f[i-1][j]+f[i-1][j-第i道菜的价格];
//（3）if(j<第i道菜的价格) f[i][j]=f[i-1][j];
	for(int i=1;i<=N;i++){  
		for(int j=1;j<=M;j++){  
			if(p[i]>j) 
				dp[i][j]= dp[i-1][j]; 
			else if(p[i]==j)
				dp[i][j]= dp[i-1][j]+1;
			else 
				dp[i][j]=dp[i-1][j-p[i]]+dp[i-1][j];
		}
		//cout <<endl; 	
	} 
		
	cout << dp[N][M];
	return 0;
} 
```


---

## 作者：RetroDnix (赞：4)

这题吧……虽然大家都说是动规，但我用的做法更像递推一些。

核心思想：设f[i][j]表示点前i种菜，并且刚好花掉了j元

方程：

	f[i][j]=f[i-1][j];//即不点这道菜
	if(j>=a[i])f[i][j]+=f[i-1][j-a[i]];
    //如果可以点这道菜，那么最大的方法数就应当加上 买前i-1道菜，且刚好花掉（j-当前菜的价钱）块钱的最大方法数。
**代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std; 
int n,m;
int f[101][10005];
int a[105];
int sum;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);//输入 
	for(int i=1;i<=n;i++)//初始化 
	{
		if(sum+a[i]<=10000)f[i][sum+a[i]]=1;//sum为累加变量（sum不能大于10000，否则既越界又没有意义，因为最大钱数为10000）
		//买前[i]道菜，且刚花掉a[1]+a[2]+…+a[i]元的方法数为1（全部都买） 
		f[i][0]=1;//买前i道菜，且刚好花掉0元的方法数为1（全都不买） 
		sum+=a[i];//累加 
	}
	for(int i=2;i<=n;i++)//第一行没有算的意义：买第一种菜，只可能花0元或a[1]元（均已初始化过） 
		for(int j=1;j<=m;j++)
		{
			f[i][j]=f[i-1][j];//不点这道菜
			if(j>=a[i])f[i][j]+=f[i-1][j-a[i]];//点这道菜
			//这两句详细意思如上文 
		}
	printf("%d",f[n][m]);//输出，f[n][m]即为答案 
	return 0;
}
```

---

## 作者：ylsoi (赞：4)

这一题很显然是背包问题的方案总数（为什么是普及-??）我们可以把每一个物品的价值也定义为它的重量（因为这个变态嫌钱多），然后状态转移方程就可以转化为分f[j]=f[j]+f[j-w[i]],其中f[j]是上一个不选这个物品可以大道满载的数目，f[i-w[i]]是装载这个物品可以达到的方案总数，加起来就好了嘛，但是我们别忘了在第一层的时候啥都没有，所以f[0]是为1的

代码如下

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=10000+10;
int n,m,w[maxn],v[maxn],f[maxn],ans;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&w[i]);
        v[i]=w[i];
    }
    f[0]=1;
    for(int i=1;i<=n;i++)
    for(int j=m;j>=w[i];j--)
    f[j]=f[j]+f[j-w[i]];
    cout<<f[m];
    return 0;
}
```

---

## 作者：CoolTeam (赞：4)

与01背包类似，F(i,j)表示前i件物品花费j元的方案数

F(i,j)=F(i-1,j-v[i])+F(i-1,j) 

初始化F[i,0]=1，大概意思是当转移方程中的j-v[i]==0时，

意味着买了第i件物品后刚好用光j元钱，所以方案数+1

再滚动数组优化一下

```cpp
#include<stdio.h>
int n,m,A[101],F[10001],count,max; 
int main(void)
{
    int i,j;
    F[0]=1;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d",&A[i]);
    for(i=1;i<=n;i++)
        for(j=m;j>=A[i];j--)
            F[j]+=F[j-A[i]];
    printf("%d",F[m]);
    return 0;
}
```

---

## 作者：yin_sy (赞：4)

01背包（判断装满方案数）

```cpp
var
  n,m,i,j:longint;
  a,f:array [0..10000] of longint;
begin
  readln(n,m);
  for i:=1 to n do
    read(a[i]);
  f[0]:=1;{什么都不点有一种方案，很重要的一个初始化}
  for i:=1 to n do
    for j:=m downto a[i] do
      f[j]:=f[j]+f[j-a[i]];{f[j]是当前吃完所有钱（j）的方案数，再加上点完这个菜后能吃完当前所有钱的方案数（初始化起到了作用，没有初始化就全部是0）}
  writeln(f[m]);
end.

```

---

## 作者：文飞扬 (赞：3)

设f[i]表示全部花完i元钱所有的点菜方案，对每个菜从m开始考虑，如果花掉第i个物品的钱a[i]后剩下的钱有花掉的方案数为f[m-a[i]]，那么对于这个每个方案都可以和第i道菜构成一个花完m元的方案，再加上原来的方案，就是新的方案数。所以，f[m]=f[m]+f[m-a[i]].

直接看代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int f[10002],a[102];
int main()
{
	int m,n,i,j;
	cin>>n>>m;
	for(i=1; i<=n; i++)
	{
		cin>>a[i];
	}
	for(i=1; i<=n; i++)
	{		
		for(j=m; j>a[i]; j--)
		{
			if(f[j-a[i]])
				f[j]+=f[j-a[i]];
			
		}
		f[a[i]]++;
//		cout<<f[1]<<" "<<f[2]<<" "<<f[3]<<" "<<f[4]<<" ";
//		cout<<endl;
	}
	cout<<f[m];
	return 0;
}
```

---

## 作者：EnochWenzhou (赞：3)

这是一道背包问题，本来想要用01背包做的，但后来是不行的。因为拿样例来说，最后能达到4元的有3种：1取，1取，2取，2不取；1取，1取，2不取，2取；1不取，1不取，2取，2取。但如果用01背包只能判定为一种，所以换了一种方法A了。

错误的01背包：

```cpp
#include<iostream>
using namespace std;
int m,n,tot,f[101][10001],a[1000001];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    f[0][0]=1;
    for(int i=1;i<=n;i++)
      for(int j=m;j>=0;j--)
      {
          if(f[i-1][j]==1)
          {
              f[i][j]=1;
              if(j+a[i]<=m) {f[i][j+a[i]]=1;if((j+a[i])==m) tot++;}
        }
      }
    cout<<tot;
}
```
AC代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int m,n,tot,f[101][10001],a[1000001];
int main(){
    //输入
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);//数组读入尽量用scanf,不过这道题应该没问题
    f[0][0]=1;
    //枚举
    for(int i=1;i<=n;i++)
      for(int j=m;j>=0;j--)
      {
          if(f[i-1][j]!=0)//01背包一般都写为:if(f[i-1][f]==1) 但这里的f[i][j]存的是个数，所以只能这样
          {
              //和上个代码唯一不同的两行
              f[i][j]+=f[i-1][j];//不取
              if(j+a[i]<=m) f[i][j+a[i]]+=f[i-1][j];//取
        }
      }
    cout<<f[n][m];
}
```

---

## 作者：王健阳 (赞：3)

这道题是一个简单的01背包

代码思路如下，直接贴哈


```cpp
#include<cstdio>
#include<cstring>
int f[100010];
int a[510];
int main()
{
    memset(f,0,sizeof(f));f[0]=1;//初始化楼房
    int n,v;
    scanf("%d %d",&n,&v);//输入
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++)//1到n
    {
        for(int j=v;j>=a[i];j--)//从上往下找
        {
            if(f[j-a[i]]>0)//如果有垫脚石
            {
                f[j]+=f[j-a[i]];//建楼
            }
        }
    }
    printf("%d",f[v]);//输出
}
```

---

## 作者：zxj200408 (赞：3)

/\*
dp的入门好题，值得一做，洛谷原创的题都不错；

01背包大家听过吧！这题就是要处理好边界，f[0]=1，因为一开始就是从1进行遍历的，不管有几种菜，他必须有一种花钱的方法~！！！！

状态转移方程：f[j]+=f[j-cost[i]];

边界条件是：f[0]=1;

\*/

```cpp
#include <iostream>
using namespace std;
int n,m,cost[10000],ans=0,i,j,f[10000];
int main()
{   cin>>n>>m;
    for(i=1;i<=n;i++)
    cin>>cost[i];
    for(i=1;i<=n;i++){
        for(j=m;j>=cost[i];j--)
            f[j]+=f[j-cost[i]];//01背包，设初值，进行叠加！！！！
    }
    cout<<f[m]<<endl;
    return 0;
}//一晚上没睡着，天天到晚想dp，刷一到水题找找自信，求管理员不要拒绝！！！
```

---

## 作者：gryql (赞：2)

用f[i]表示正好花费i元的种类，典型的背包问题，动态转移方程：f[i]:=f[i]+f[i-a[j]]。如果用二维数组写的话，f[i,j]表示用j元钱买i个东西的种类，动态转移方程  f[i,j]:=f[i-1,j]+f[i-1,j-a[i]]。

```delphi

(var a,f:array[0..10000] of longint;
    n,m,i,j:longint;
begin
    readln(n,m);
    for i:=1 to n do read(a[i]);
    f[0]:=1;
    for i:=1 to n do
        for j:=m downto a[i] do
            f[j]:=f[j]+f[j-a[i]];
    writeln(f[m]);
end.)

```

---

## 作者：kuansoudafahao (赞：2)

这题我用的是01背包，但看各位大牛的题解说不是01背包，感觉很奇怪，拿到数据太水？

AC代码如下：






```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m;
int a[1000],f[20000];
void in();
void work();
void out();
int main()
{
    in();work();out();
    return 0;
}
void work()
{
    f[0]=1;
    for(int i=1; i<=n; i++)
        for(int j=m; j>=a[i]; j--)
            f[j]+=f[j-a[i]];
}
void out()
{
    printf("%d", f[m]);
}
void in()
{
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; i++)
        scanf("%d", a+i);
}
```

---

## 作者：gary2005 (赞：1)

总思路是DP，其实就是dp【i】（表示支付i元的方法）而也就是+=dp【i-a【j】】的情况（j表示第j道菜）

**来上代码**


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m,a[150],money[10005]={1}/*money【i】表示面值i的表示方法*/;//0元有一种表示方法  当然就是没有啦 
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)/*用1~n的菜表示*/for(int j=m;j>=a[i];j--)/*表示0~m面值*/money[j]+=money[j-a[i]];
    printf("%d",money[m]);
    return 0;
}
```

---

## 作者：lbn187 (赞：1)

简单的背包问题：

DP方程：


f[0]=1
f[j]=f[j]+f[j-a[i]];

标程：

```cpp
var
  a,f:Array[0..10000] of longint;
  n,m,i,j:longint;
begin
  f[0]:=1;
  readln(n,m);
  for i:=1 to n do
    read(a[i]);
  for i:=1 to n do
  for j:=m downto 0 do
    if j>=a[i] then f[j]:=f[j]+f[j-a[i]];
  writeln(f[m]);
end.

```

---


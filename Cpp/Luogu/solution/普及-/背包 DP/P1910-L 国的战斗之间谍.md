# L 国的战斗之间谍

## 题目背景

L 国即将与 I 国发动战争！！


## 题目描述

俗话说的好：“知己知彼，百战不殆”。L 国的指挥官想派出间谍前往I国，于是，选人工作就落到了你身上。

你现在有 $N$ 个人选，每个人都有这样一些数据：$A$（能得到多少资料）、$B$（伪装能力有多差）、$C$（要多少工资）。已知敌人的探查间谍能力为 $M$（即去的所有人 $B$ 的和要小于等于 $M$）和手头有 $X$ 元钱，请问能拿到多少资料？


## 说明/提示

数据范围：$1\le n\le 100$，$1\le m\le 1000$，$1\leq x\leq 1000$。

## 样例 #1

### 输入

```
3 10 12
10 1 11
1 9 1
7 10 12
```

### 输出

```
11```

# 题解

## 作者：MuelsyseU (赞：105)

~~鄙人不才，最近狂写DP空间压缩的题解，不知道在想什么~~

## 1. 前言

二维动态规划题。

数据虽水，然该压还是得压 ~~（说实话除了需要压缩空间之外就是大水题）~~。本文主要讲空间的压缩，针对对背包已有基础的童鞋，如不了解基本思路请参照其它$dalao$的题解。

关于二维动规本人可能讲不太细，众$dalao$见谅。

## 2. 关于题目思想

题目[P1910](https://www.luogu.org/problem/P1910)主要内容为：有$N$个间谍，最多伪装能力总和不能高 ~~(低？)~~ 于$M$，拥有的费用为$X$元。给出每个间谍可获取的情报量、伪装能力值、所需的费用，求最多可获得多少情报。

## 3. 关于算法思想
 
可以看到，贪心是不可取的。~~虽然我不能具体说出为什么不可取~~
 
于是我们想到两条路子：搜索和动规。

**搜索**是一个~~并不~~好的算法，但是根据范围问题可以发现并不太可取 ~~（当然可以尝试记忆化大法）~~。

尽管数据的奇异使搜索可能AC，但实际上不是所有数据都这么幸运。

------------

我们考虑**二维动规**。

首先从一维角度来看（不考虑费用），这是$01$背包。

于是设$f[i][j]$表示前$i$人中伪装能力至多为$k$的最大获取资料量$(1<=i<=N,0<=j<=M)$，其中$v[i]$表示第$i$人可获取得资料量，$w[i]$表示派出第$i$人的伪装能力（越大越差）。

于是对于 $0<=w[i]<=j$，有$f[i][j]=Max(f[i-1][j],f[i-1][j-w[i]]+v[i])$。

------------

现在加入$p[i]$表示第$i$人所需的费用，则同理有$f[i][j][k]$表示前$i$人中伪装能力至多为$k$且总费用为$j$的最大获取资料量 ~~（很乱有木有）~~。$(1<=i<=N,0<=j<=M,0<=k<=X)$

则对于 $0<=w[i]<=j,0<=p[i]<=k$，有$f[i][j][k]=Max(f[i-1][j][k],f[i-1][j-w[i]][k-p[i]]+v[i])$。

上式根据$01$背包基本思路比较好证明，即对于不取第$i$人，由前$i-1$人的状态推出；对于取第$i$人，由“前$i-1$人剩余$j-w[i]$的伪装能力和$k-p[i]$的费用可用”时的状态加上可获取资料量推出。

------------

整理思路，首先二重循环输入数据存储于$a[]$、$b[]$和$c[]$中，再设一$f[][][]$用三重循环求解后，输出$f[N][M][X]$。

参考代码如下：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int a[105],b[105],c[105];
int f[105][1005][1005];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++)
		for(int j=m;j>=b[i];j--)
			for(int k=p;k>=c[i];k--)
				f[i][j][k]=max(f[i-1][j][k],f[i-1][j-b[i]][k-c[i]]+a[i]);
	cout<<f[n][m][p];
	return 0;
} 
```
然而似乎非常不幸：

![](https://cdn.luogu.com.cn/upload/image_hosting/8xo02rae.png)
众看官是否发现了代码中的$f[105][1005][1005]$？1e8的巨大数组成功MLE此题。

于是自然可以想到压缩的问题：

## 3. $a,b,c$压缩

这部分是本人的拿手压缩~~虽然常常无用~~，即输入部分的压缩。

首先让我们抛开$f$数组，考虑$a,b,c$三个数组。

注意以下代码段：

```cpp
for(int i=1;i<=n;i++)
	cin>>a[i]>>b[i]>>c[i];
for(int i=1;i<=n;i++)
	for(int j=m;j>=b[i];j--)
		for(int k=p;k>=c[i];k--)
			f[i][j][k]=max(f[i-1][j][k],f[i-1][j-b[i]][k-c[i]]+a[i]);
```
可以发现第二个循环部分每次都仅使用了$a[i],b[i],c[i]$三个值，因此我们可以将两个循环合二为一，同时将这三个数组直接压缩成$x,y,z$三个临时变量。

参考代码如下：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int x,y,z;
int f[105][1005][1005];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>z;
		for(int j=m;j>=y;j--)
			for(int k=p;k>=z;k--)
				f[i][j][k]=max(f[i-1][j][k],f[i-1][j-y][k-z]+x);
	}
	cout<<f[n][m][p];
	return 0;
}
```

## 4. $f$数组压缩

动规的经典压缩方式（f压缩到二维）。

由上述内容可以看出，在计算第$i$人时，仅需使用 $f[i-1][][]$ 的数据，其前的值可以舍弃——最终可直接舍弃 $f[n][][]$ 之前的所有值。

这样看来，不妨直接使用方程$f[j][k]=Max(f[j][k],f[j-w[i]][k-p[i]]+v[i])$。

仔细观察方程，可发现每次 i 循环都更新了$f[][]$中的值，这样，在执行完第 i-1 层循环后，f 数组就保存了第 i-1 层的所有数据。

其后第 i 层循环，实际上等同于使用$Max(f[i-1][j][k],f[i-1][j-w[i]][k-p[i]]+v[i])$来更新$f[i][j][k]$。

最后要注意一点，大部分这类压缩都要注意循环方向的问题，如此题状态转移需用到的数据为$f[j][k],f[j-w[i]][k-p[i]]$，即所使用的下标不超过$j$和$k$，需采取由$n$到$j,k$的循环方向，否则将错误地使用到$f[i][j-w[i]][k-p[i]]$。

当然本题本身是$01$背包，因此循环方向本身就满足要求，只是要记住这一点。

整理思路，即是：将$f$数组变为一维，所有类似$f[i][j][k]$形式的部分改为$f[j][k]$形式。

参考代码如下：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int x,y,z;
int f[1005][1005];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>z;
		for(int j=m;j>=y;j--)
			for(int k=p;k>=z;k--)
				f[j][k]=max(f[j][k],f[j-y][k-z]+x);
	}
	cout<<f[m][p];
	return 0;
} 
```

## 5. 总结

越研究$Luogu$的题解要求越觉得自己的题解过不了……不过感觉这篇应该还蛮详细的吧……（大嘘）

感觉自己花式把一个简单的正解写得复杂之极……当然其中压缩的部分说不定还有些用处，毕竟$Luogu$详细写如何压缩$f$的题解似乎并不多。

最后，感谢阅读完这175行的兄台。

以上。

---

## 作者：北海_Beihai (赞：42)

#看了看题解，大多数人都是用搜索的。然而本题正解是二维背包！！！

二维背包我就不多说了，大家应该都知道。（不知道的请参见《信息学奥赛一本通》P351）

既然怕被驳回，我还是简单地讲讲吧

递推式：f[j][k]=max(f[j-b][k-c]+a)

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1010][1010];
int main(){
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++){
        int a,b,c;
        cin>>a>>b>>c;
        for(int j=m;j>=b;j--)                                     //以下3行是算法的核心
            for(int k=x;k>=c;k--)
                f[j][k]=max(f[j][k],f[j-b][k-c]+a);
    }
    cout<<f[m][x];
    return 0;
}
```

---

## 作者：Caicz (赞：11)

#### 这题就是很简单的一道二维背包
#### 但有很多人都在用dfs（尽管数据真的很水）
#### 但还是要写一下背包，毕竟数据不会一直这么水
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,x,ans;
int a[105],b[105],c[105],f[1005][1005];//数据太水，数组不用开太大

int main()
{
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++)
	for(int j=m;j>=b[i];j--)
	for(int k=x;k>=c[i];k--)
		f[j][k]=max(f[j][k],f[j-b[i]][k-c[i]]+a[i]);
	for(int j=m;j>=0;j--)
	for(int k=x;k>=0;k--)
		ans=max(ans,f[j][k]);
	cout<<ans;
	return 0;
}

```


---

## 作者：✌yww (赞：10)

//三维,RE降二维,状态dp[j][k]表示用i个人满足不被侦查到是间谍，且工资不超过老板血本x；

动态转移方程：dp[j][k]=max(dp[j][k],dp[j-B[i]][k-C[i]]+A[i]);

//分为两种情况讨论

1.假如这个人不能派去

2.这个人要派去，则加上这个人可以得到的资料A[i]，并用血本减去他的工资B[i]，用侦查值减去他的伪装能力差到的程度C[i]




```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,m,x;
int A[1200],B[1200],C[1200];
int  dp[1200][1200];
int main()
{
    scanf("%d %d %d ",&n,&m,&x);
    for(int i=1; i<=n; i++)
    {
        scanf("%d %d %d",&A[i],&B[i],&C[i]);
    }
    for(int i=1; i<=n; i++)
    {
        for(int j=m; j>=B[i]; j--)
        {
            for(int k=x; k>=C[i]; k--)
            {
                dp[j][k]=max(dp[j][k],dp[j-B[i]][k-C[i]]+A[i]);
            }
        }
    }
    printf("%d",dp[m][x]);
    return 0;
}

```

---

## 作者：RemiliaScar1et (赞：7)

~~蒟蒻第3次写题解。。。轻喷~~


------------


### 标准的二维背包 ###

资料就是价值，而伪装程度与钱钱就是代价。

然后快乐地按照标准模板写即可。

**但要注意一点：**
元素是否能够**多次取用**。若能，则for循环的条件：

```cpp
for(int j=k[i];j<=m;j++)
```
目的是使前面状态的值能够被考虑到。~~(不是特别清楚如何表述~~

~~然而本题元素最多只取一次~~

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[1010]/*价值*/,k[1010]/*代价1*/,z[1010]/*代价2*/;
int f[1010][1010];//二维代价，二维数组 
int main()
{
	int n,m,x;
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i]>>k[i]>>z[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=k[i];j--)//每个元素最多只取一次 
		{
			for(int o=x;o>=z[i];o--)
				f[j][o]=max(f[j][o]/*不取就不变*/,f[j-k[i]][o-z[i]]+p[i]/*取则减代价，加价值*/);
		}
	}
	cout<<f[m][x];//输出最大值 
	return 0;
}
```



---

## 作者：Xhesika_Frost (赞：6)

~~我的dfs和你们都不一样欸~~

跑的速度还行，96ms

我都不知道我是怎么想的了，以及怎么想出来那个
奇葩边界的
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,x;
int a[10001];
int b[10001];
int c[10001];
int ans;
int vis[100001];
void dfs(int able,int mo,int z,int num){
	int f=0;
	for(int i=num;i<=n;++i){
		if(!vis[i])
			if(b[i]<=able&&c[i]<=mo){
				f=1;
				vis[i]=1;
				dfs(able-b[i],mo-c[i],z+a[i],i+1);
				vis[i]=0;
			}	
	}
	if(f==0){
		ans=max(ans,z);
		return ;
	}
}

int main(){
	cin>>n>>m>>x;
	for(int i=1;i<=n;++i)
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	dfs(m,x,0,1);
		cout<<ans;
	return 0;
}
```


---

## 作者：zhjzhmh (赞：5)

大家好，我是zhjzhmh。

大屏幕再现

变！

————————————————————————————————————————
~~俗话说的好：“知己知彼，百战不殆”。L国的指挥官想派出间谍前往I国，于是，选人工作就落到了你身上。~~//废话

你现在有N个人选，每个人都有这样一些数据：A（能得到多少资料）、B（伪装能力有多差）、C（要多少工资）。已知敌人的探查间谍能力为M（即去的所有人B的和要小于等于M）和手头有X元钱，请问能拿到多少资料？

————————————————————————————————————————

This is 二维背包

why?

他有两个条件呀？！

知道是二维背包以后，来，找状态转移方程

背包最重要的部分是状态转移方程。

一维方程：f[j]=max(f[j],f[j-w[i]]+c[i]);

二维就是转一下：f[j][k]=max(f[j][k],f[j-w[i]][k-v[i]]+c[i]);

知道状态转移方程以后，来，上代码


------------代码分割线------------




```cpp
#include<bits/stdc++.h>//万能头文件，不多解释了
using namespace std;
int n,W,V,w[110],v[110],c[110],f[1010][1010];
int main()
{
	cin>>n>>W>>V;//W代表总侦查能量，V代表手中只有V块钱
	for(int i=1;i<=n;i++)
	{
		cin>>c[i]>>w[i]>>v[i];
      //输入价值c，条件量w，v; 
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=W;j>=w[i];j--)
		  for(int k=V;k>=v[i];k--)
		    f[j][k]=max(f[j][k],f[j-w[i]][k-v[i]]+c[i]);
	}
	cout<<f[W][V];
	return 0;
}
```


------------代码结束线------------

请勿抄袭（qwq)

（本人第二篇题解，如有不足之处，请见谅）

---

## 作者：Wuzhuoming (赞：4)

###### ~~这题满水的~~
## 典型的dp题，可以用来练习01背包模板
###### [资瓷一下自己的博客](https://www.luogu.org/blog/Jouwu/)
##### 首先，我们知道，每个间谍都只有用或不用两种情况  （初步推测出用的是01背包）
##### 其次，我们又知道每个间谍的伪装的能力和不能超过m
##### 再者，我们还知道我们只有x元钱
### 我们于是就推出了状态转移方程：
### f[j][l]=max{f[j][l],f[j-b][l-c]+a}(j:m~b,l:x~c)
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int f[1118][1118]= {0};
int max(int a,int b) {
	return a>b ? a : b;
}
int main() {
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);//XP机不好调试，只好用freopen
	int m,n,x;
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++) {
		int a,b,c;
		cin>>a>>b>>c;
		for(int j=m;j>=b;j--) {
			for(int l=x;l>=c;l--) {
				f[j][l]=max(f[j][l],f[j-b][l-c]+a);//very import
			}
		}
	}
	cout<<f[m][x];
	return 0;
}
```

~~看我写得这么辛苦就给过呗~~

---

## 作者：Jason_Yvan (赞：3)

这道题是有多㝽（shui）

用深搜10分钟就打完了。。。

看代码不需要解释

C++：
/*************************************************************************

    > Author: wzw-cnyali
    > Created Time: 2017/2/26 9:48:48
************************************************************************/











```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
typedef long long LL;
const int Size = 100000;
const int inf = 0x3f3f3f3f;
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
int a[Size], b[Size], c[Size];
int A, B, C;
int N, M, X;
int ans;
void dfs(int x)
{
    if(B > M || C > X) return;
    ans = max(ans, A);
    if(x > N) return;
    A += a[x];
    B += b[x];
    C += c[x];
    dfs(x + 1);
    A -= a[x];
    B -= b[x];
    C -= c[x];
    dfs(x + 1);
}
int main()
{
    N = read(), M = read(), X = read();
    REP(i, 1, N)
    {
        a[i] = read(), b[i] = read(), c[i] = read();
    }
    dfs(1);
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：Ape_epA (赞：2)

非常简单的01二维背包问题，只要知道了公式就可以了。

```cpp
var a:array[0..1001,0..1001] of longint;
    n,m,k,i,j,x,y,z,l:longint;
begin
  readln(n,m,k);
  for i:=1 to n do
    begin
    readln(x,y,z);
    for j:=m downto y do   //能力
      for l:=k downto z do   //钱
        if a[j,l]<a[j-y,l-z]+x then   
          a[j,l]:=a[j-y,l-z]+x;   //套公式
    end;
  writeln(a[m,k]);    //输出
end.
```

---

## 作者：M_yuxuan2004 (赞：2)

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1010][1010];
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        for(int j=m;j>=b;j--)                                  
            for(int k=x;k>=c;k--)
                dp[j][k]=max(dp[j][k],dp[j-b][k-c]+a);
    }
    cout<<dp[m][x];
    return 0;
}
```

---

## 作者：2er0n3 (赞：1)

本蒟蒻第二次写题解，

显然每个人状态为选或不选，且每个人只能选一次01背包问题嘛，

此题有两个限定，01背包一般都是要求不超过一定体积，求最大价值，这个题是要求不超过敌人的侦察能力M，和拥有的钱数X；

so....
我们可以在加一重循环，.

代码奉上

/*********************************

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1010][1010];
int a[100000],b[100000],c[100000];
int main(){
    int N,M,X;
    cin>>N>>M>>X;
    for(int i=1;i<=N;i++)
    {
      cin>>a[i]>>b[i]>>c[i];
    }
    for(int i=1;i<=N;i++)//个数
    {
        for(int j=M;j>=b[i];j--) //侦察能力
        {
               for(int k=X;k>=c[i];k--)//工资
                     f[j][k]=max(f[j][k],f[j-b[i]][k-c[i]]+a[i]);//转移方程
        }  
    }
    cout<<f[M][X];
    return 0;
}
```

---

## 作者：流浪鬣狗 (赞：0)

# 本题背包
## 我在刷水题时，先刷了一个一维背包
[P2722 总分 Score Inflation](https://www.luogu.org/problem/P2722)\
## 自我感觉良好 ~~（看了题解）~~
```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define ll long long
using namespace std;
ll c[110000],w[110000];
ll n,m,i,j,sum,dp[11000];
int main()
{
	scanf("%lld%lld",&m,&n);
	for(i=1;i<=n;i++)
		scanf("%lld%lld",&w[i],&c[i]);
	for(i=1;i<=n;i++)
	{
		for(j=c[i];j<=m;j++)
		{
			dp[j]=max(dp[j],dp[j-c[i]]+w[i]);
		}
	}
	printf("%lld\n",dp[m]);
	//printf("%d\n",clock());
	return 0;
}


```
# so easy
## Than......
###  这道题我改了改
```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define ll long long
using namespace std;
ll n,m,x,w[1100],b[1100],c[1100],dp[1100][1100],i,j,k;
int main()
{
	scanf("%lld%lld%lld",&n,&m,&x);
	for(i=1;i<=n;i++)scanf("%lld%lld%lld",&w[i],&b[i],&c[i]);
	for(i=1;i<=n;i++)
	{
		for(j=b[i];j<=m;j++)
		{
			for(k=c[i];k<=x;k++)
			{
				dp[j][k]=max(dp[j][k],dp[j-b[i]][k-c[i]]+w[i]);
			}
		}
	}
	printf("%lld\n",dp[m][x]);
	//printf("%d\n",clock());
	return 0;
}


```
![WA](https://cdn.luogu.com.cn/upload/image_hosting/htj2gemk.png)
# ？？？？？？？？？？？？
![测试](https://cdn.luogu.com.cn/upload/image_hosting/4uibu0ql.png)
## 卧槽卧槽卧槽卧槽卧槽卧槽卧槽卧槽
######  ~~只能看题解了~~
# 手打的正解：
```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define ll long long
using namespace std;
ll n,m,x,w[1100],b[1100],c[1100],dp[1100][1100],i,j,k;
int main()
{
	scanf("%lld%lld%lld",&n,&m,&x);
	for(i=1;i<=n;i++)scanf("%lld%lld%lld",&w[i],&b[i],&c[i]);
	for(i=1;i<=n;i++)
	{
		for(j=m;j>=b[i];j--)
		{
			for(k=x;k>=c[i];k--z)
			{
				dp[j][k]=max(dp[j][k],dp[j-b[i]][k-c[i]]+w[i]);
			}
		}
	}
	printf("%lld\n",dp[m][x]);
	//printf("%d\n",clock());
	return 0;
}


```
## 还是刷题少啊！！！


---

## 作者：zhaowangji (赞：0)

话说我没想明白为什么前面有题解什么解释都没有为什么能上。。。。。。下面部分废话

其实这题是背包，三重循环的复杂度最多只有100000000（一亿）次，因为1≤n≤100,1≤m≤1000, 1≤x≤1000

数据还是很水的 不过洛谷能过有点惊讶~~要是我家电脑也能做到就好了~~

今年夏令营曾经由一位老师说：

CCF的电脑换了，换成i7了 ~~这相信大家都知道~~

### 但！

他说CCF的评测机现在每秒能跑
# 400000000
（四亿）次！！！

所以大家放心写暴力~~骗分~~

~~虽然我不知道是不是一次只跑一个人的程序~~

好了废话结束

二维背包，就是同时有两个限制条件，比如原来只有重量和价值，但是现在有重量，价格和价值

再原来的基础上再加一维（一维基础上加或者二维基础上加）

然后公式改一下就行了

[可以去看一下](https://www.luogu.org/paste/055jx4na)
原文是CSDN，因为背包讲了很多，二维背包放在了中间部分，不方便翻阅，就自己剪贴了一下（复制CDSDN的东西好麻烦啊）


```cpp
#include<iostream>
using namespace std; 
int n,m,x;
int a[107],b[107],c[107];
int f[1007][1007];//这里用的是二维，即把原来的一维改成了二维
int main()
{
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++)//不变
	for(int j=m;j>=b[i];j--)
	for(int k=x;k>=c[i];k--)//变成两重循环（因为两个代价嘛）
		f[j][k]=max(f[j][k],f[j-b[i]][k-c[i]]+a[i]);
        //这里也变成两种代价分别减去
	cout<<f[m][x];//相应变化
	return 0;
}
```


---

## 作者：LevenKoko (赞：0)



    

    
```cpp
//看到数据范围，果断搜索；
//剪枝是必要的（大家可以看一下我的提交记录，剪枝88ms，不剪枝33700ms所有点都TLE）
//搜索:对于每一种状态都有取和不取两种状态
//剪枝:如果当前状态下的伪装能力已经大于M或工资已经大于X，显然就不要往下搜了 
//代码： 
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,x,a[1005],b[1005],c[1005],ans=0; 
void dfs(int step,int nowm,int nowp,int s)//当前状态:nowm现在已付工资，nowp当前伪装能力，s能偷到的总数 
{
    if(step==n+1)
    {
        if(nowm<=x&&nowp<=m)
        ans=max(ans,s);//取大的 
        return;
    }
    if(nowm>x||nowp>m) return;//神奇的剪枝； 
    dfs(step+1,nowm+c[step],nowp+b[step],s+a[step]),
    dfs(step+1,nowm,nowp,s);//神奇的两种决策 
}
int main()
{
    cin>>n>>m>>x;//神奇的输入1 
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i]>>c[i];//神奇的输入2 
    dfs(1,0,0,0);//神奇的搜索； 
    cout<<ans;//神奇的输出； 
    return 0;
}
```

---

## 作者：xukuan (赞：0)

dfs深度优先搜索

搜索是否请这个人





```cpp
var
 n,m,x,i,max:longint;
 a,b,c:array[0..110] of longint;
procedure dfs(ren,ziliao,weizhuang,gongzi:longint);
 begin
  if weizhuang<0 then exit;//伪装指数过大
  if gongzi<0 then exit;//没钱了
  if ren=n+1 then//全部判断过了
   begin
    if ziliao>max then max:=ziliao;//大于最大值
    exit;//退出
   end;
  dfs(ren+1,ziliao+a[ren],weizhuang-b[ren],gongzi-c[ren]);  //请
  dfs(ren+1,ziliao,weizhuang,gongzi);   //不请
end;
begin
 readln(n,m,x); max:=0;
 for i:=1 to n do
  readln(a[i],b[i],c[i]);
 dfs(1,0,m,x);//深搜
 writeln(max);//输出
end.

```

---

## 作者：doby (赞：0)

非常简单的二维01背包……

方程：f[j][l]=maxn(f[j][l],a[i]+f[j-b[i]][l-c[i]])

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int a[10000],b[10000],c[10000],f[5000][5000],n,m,k,t,s,ma;
int maxn(int a,int b){if(a>b){return a;}else{return b;}}
int main()
{
    scanf("%d%d%d",&k,&n,&m);
    for(int i=1;i<=k;i++){scanf("%d%d%d",&a[i],&b[i],&c[i]);}
    for(int i=1;i<=k;i++)
    {
        for(int j=n;j>=b[i];j--)
        {
            for(int l=m;l>=c[i];l--)
            {
                f[j][l]=maxn(f[j][l],a[i]+f[j-b[i]][l-c[i]]);//二维01背包板子……
            }
        }
    }
    printf("%d",f[n][m]);
    return 0;
}
```

---

## 作者：Enzymii (赞：0)

#啊 竟然没有C++的题解呢

其实之前的题解已经说的蛮清楚了，就是二维背包嘛~

状态转移方程f[j][k]=max(f[j][k],f[j-w1[i]][k-w2[i]]+v[i]])，其中w1,w2分别表示两维费用，v表示价值


C++代码：

```cpp
#include<cstdio>
int f[1001][1001], m[101], w[101], v[101];
int main()
{
    int n, mm, mw, i, j, k;
    scanf("%d%d%d", &n, &mm, &mw);
    for (i = 1; i <= n; i++)
        scanf("%d%d%d", &v[i], &m[i], &w[i]);  //读入
    for (i = 1; i <= n; i++)
        for (j = mm; j >= m[i]; j--)
            for (k = mw; k >= w[i]; k--)
                if (f[j][k] < f[j - m[i]][k - w[i]] + v[i])
                    f[j][k] = f[j - m[i]][k - w[i]] + v[i];   //状态转移方程见上方
    printf("%d", f[mm][mw]); //结果即为花费两维费用不超过最大限度能取得的价值~~
    return 0;
}
```

---

## 作者：black__kings (赞：0)

非常简单的01背包（二维） Pascal核心代码:

```cpp
  for i:=1 to n do    //枚举每种资料总数
    for j:=m downto b[i] do  //最大的伪装能力
      for k:=m1 downto c[i] do  //最大的工资
        f[j,k]:=max(f[j,k],f[j-b[i],k-c[i]]+a[i]);  //程序省略 uses math;  01背包的决策

```

---

## 作者：lych (赞：0)

简单的二维背包，直接给出标程：

```delphi
var
  f:array[0..2000,0..2000] of longint;
  i,j,k,x,y,z,m,n,v:longint;
function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;//两者较大者
begin
  readln(n,m,v);
  for i:=1 to n do 
    begin
      readln(x,y,z);
      for j:=m downto y do
        for k:=v downto z do//逆序，保证只被选一次
          f[j,k]:=max(f[j,k],f[j-y,k-z]+x);//更新最优解
    end;
  writeln(f[m,v]);
end.
```

---

## 作者：不存在之人 (赞：0)

## 这其实是一个二维背包问题，直接套模板。。。

### 附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 1010
using namespace std;
int n,m,x,a[MAXN],b[MAXN],c[MAXN],f[MAXN][MAXN];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int main(){
	n=read();m=read();x=read();
	for(int i=1;i<=n;i++){a[i]=read();b[i]=read();c[i]=read();}
	for(int i=1;i<=n;i++)
		for(int j=m;j>=b[i];j--)
			for(int k=x;k>=c[i];k--)
				f[j][k]=max(f[j][k],f[j-b[i]][k-c[i]]+a[i]);
	printf("%d\n",f[m][x]);
	return 0;
}
```

---

## 作者：半仙胡小桃 (赞：0)

[传送门](https://www.luogu.org/problem/show?pid=1910)

看了这道题，先想了贪心，但是有两个限制量，很明显是没法贪心的

但是数据范围，n<=100

很明显DFS是可以水过去的，我们DFS选到了那个人，一个人有选与不选两种方案，DFS中再加些表示总的伪装度，钱数，以及情报的局部变量去判断符不符合要求即可


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int mon[999],w[999],q[999];
int n,m,a;
int ans;
void dfs(int x,int mony,int qb,int wz)
{   
    ans=max(qb,ans);
    if(x==n+1) return;
    if(mony+mon[x]<=a&&wz+w[x]<=m)
    dfs(x+1,mony+mon[x],qb+q[x],wz+w[x]);
    dfs(x+1,mony,qb,wz);
}
int main()
{
    scanf("%d%d%d",&n,&m,&a);
    for(int i=1;i<=n;i++)
     scanf("%d%d%d",q+i,w+i,mon+i);
    dfs(1,0,0,0);
    printf("%d",ans);
    return 0;
} 
```

---


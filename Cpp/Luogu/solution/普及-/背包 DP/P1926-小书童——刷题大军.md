# 小书童——刷题大军

## 题目背景

数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。  
文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。——小 A


## 题目描述

小 A “刷题”十分猖狂，明目张胆地“刷题”。他现在在小书童里发现了 $n$ 样他喜欢的“题目”，每“题”都有他的需要时间，而老师布置了 $m$ 项作业，每项作业都有它的需要时间及分值，老师规定 $k$ 分以上算及格。小 A 只剩 $r$ 个单位时间，他想在及格的基础上更多地“刷题”。

## 说明/提示

### 数据范围及约定


对于 $100\%$ 的数据，$n\le 10$，$m\le 10$，$k\le 50$，$r\le 150$。数据保证没有不能及格的情况。


## 样例 #1

### 输入

```
3 4 20 100
15 20 50
10 15 40 40
5 5 10 15```

### 输出

```
2```

# 题解

## 作者：slaak (赞：311)

### 尝试写个题解 :)


### 本人蒟蒻一枚,不喜轻喷


### 以下是对题目解释

- 首先，这道题目是明显的01背包题目

- 所以你就去写了01背包(应该不用教吧)

-状态转移方程还是给了吧，能够让懒懒的你不用往后翻。

- f[j] = max(f[j],f[j-w[i]] + c[i]);

- 由于神犇小A不同于我等蒟蒻，所以拿到及格分就可以了，所以从前往后扫一次，一旦某个f[i]及格了，就停止做作业（真是勇敢 de 孩纸），于是刷题时间是总时间减去已经用过时间。

- 接着，由于每道题目都是等价的，而小A只追求数量（这样的刷题实际上是没有多大意义的，事倍功半），所以就把题目排序一下（偷懒sort），然后先做时间短的，刷完一道题之后余剩时间减去了这道题目用时。

- 如果时间<=0，那么退出，因为小A得跑去学校了（0秒就到学校了，跑得真快）

- 因为小A已经在上课了，所以请你帮他输出他能够刷题的最大数量。

- 再重复一次，小A真勇敢啊（本题解精髓所在#(滑稽)）

- 当然，你会一览我的个人网站（与NOIp无关） [http://scris.top/](http://scris.top) 的

### 代码如下

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
int n,m,k,r;//无需解释
int a[11];//要刷的题目需要的时间
int w[11];//作业所需时间
int c[11];//作业分值
int f[501] = {0};//表示用f[i]时间能够得到的分数 
int stt;//表示余剩下用来刷题的时间 
int stn = 0;//已经刷的个数
int main()
{
    ios_base::sync_with_stdio(0);//让cin变快 de 黑科技x1
    cin.tie(0);//让cin变快 de 黑科技x2
    cin>>n>>m>>k>>r;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);//尽量挑时间短的题目去做
    for(int i=1;i<=m;i++)
    {
        cin>>w[i];
    }
    for(int i=1;i<=m;i++)
    {
        cin>>c[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=r;j>=w[i];j--)//标准01背包写法
        {
            f[j] = max(f[j],f[j-w[i]] + c[i]);
        }
    }
    for(int i=1;i<=r;i++)
    {
        if(f[i] >= k)//可以及格了
        {
            stt = r - i;//已经写作业花去的时间不能刷题了
            break;
        }
    }
    for(int i=1;i<=n;i++)
    {
        stt -= a[i];//刷了一道题
        if(stt <= 0) break;//没时间了赶紧跑去学校
        stn++;//多刷了一道题，成就感++，rp--
    }
    cout<<stn<<endl;//输出刷题数量
    return 0;
}
```

---

## 作者：Alex_Wei (赞：32)

提供一个dfs做法，请原谅我这清奇的思路（~~其实我不会dp~~）

#### 主要思路：dfs找出及格情况下最长剩余时间，再把每个题所需要花费的时间从小到大排序，看一下能做几道题

具体思路见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,r,mi,q[11],ht[11],hs[11],ans;
//mi:及格的情况下最长剩余时间； q数组(question):每道题所需的时间； ht数组(homework time):每项作业所需的时间； hs数组(homework score):每项作业的分数；
void dfs(int num,int s,int t)//num:做到了第num项作业，num之前未做的作业不能再做； s:分数； t:时间
{
	if(r-t<=mi)return;//剪枝，如果这种情况下剩余时间已经不大于最长剩余时间，就退出
	if(s>=k)mi=r-t;//因为有前面的剪枝，所以如果及格了，这种情况下就是最长剩余时间
	for(int x=num+1;x<=m;x++)//做第x项作业
		dfs(x,s+hs[x],t+ht[x]);
}
int main()
{
	cin>>n>>m>>k>>r;
	for(int x=1;x<=n;x++)cin>>q[x];
	for(int x=1;x<=m;x++)cin>>ht[x];
	for(int x=1;x<=m;x++)cin>>hs[x];
	dfs(0,0,0),sort(q+1,q+n+1);//dfs并且把每道题所需的时间从小到大排序
	for(int x=1;x<=n;x++)if(mi>=q[x])mi-=q[x],ans++;//如果剩余时间够做这道题，就做这道题（因为时间已经从小到大排过序了，所以得到的答案一定是最优的）
	cout<<ans;
	return 0;//望管理员通过
}
```
#### 珍爱生命，请勿抄袭！

---

## 作者：「QQ红包」 (赞：25)

动态规划……注释很清楚了

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
using namespace std;
int n,m,k,r;
int i,j;
int f[10010]={0},ti[10001],zyt[10001],zyf[10001];
int main()
{
    scanf("%d %d %d %d",&n,&m,&k,&r);//n题，m作业，k分数，r时间
    for (i=1;i<=n;i++)
         scanf("%d",&ti[i]);//读入做题时间
    sort(ti+1,ti+n+1); //从小到大排序 
    for (i=1;i<=m;i++)
        scanf("%d",&zyt[i]);//读入作业时间 
    for (i=1;i<=m;i++)
        scanf("%d",&zyf[i]);//读入作业分数
    for (i=1;i<=m;i++) 
        for (j=r;j>=zyt[i];j--)//dp
        f[j]=max(f[j],f[j-zyt[i]]+zyf[i]);//在r分钟内做作业能获得的最大分值 
    int haha;
    for (haha=1;haha++;haha<=k)//找到什么时候能够得到k分 
        if (f[haha]>=k) break;
    r-=haha;//剩下刷题的时间
    int sum=0;
    for (i=1;i<=n;i++) 
    {
        if (r>=ti[i])//如果有时间刷题 
        {
            r-=ti[i];//剩余的时间减少 
            sum++;//刷题数量+1 
        }
        else break;//连这道题都没时间刷后面的题所需的时间比这道题肯定要都所以跳出循环吧 
    }
    cout<<sum;
    return 0;
}

```

---

## 作者：zjy111 (赞：12)

嗯好一道橙题
###### （我才不告诉你我只会红题，部分橙题和极少量黄以上题）
标签：动规，搜索，排序，背包......看上去是不是很吓人?（至少对于我来说是的）

但用01背包即可......（毕竟还是橙题）

所谓01背包可以看一下[P1048采药](https://www.luogu.org/problem/P1048)或者[OI Wiki](https://oi-wiki.org/dp/knapsack/)，就是选取若干有一定重量和价值的物品（每一个物品只能选一次），要求在重量不超过一定值的情况下所拿总价值最大

这道题核心思路就是这样，而根据题意，先及格，只要小A及格了，就马上退出刷时间短的题（和01背包相比也就多了一个这个）最后别忘记求的是最大刷题数而不是最大分值！

献上码风奇特的代码（加注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,r,t[n+3],hw[m+3],scr[m+3];//t记录每道题所用时间，hw记录每项作业花费时间，scr[i]记录i时间可以拿到的最大分数
int main(){
	cin>>n>>m>>k>>r;
	int i,j,l,ans[999],cnt=0;//l为剩余时间，cnt为最大题数
	memset(ans,0,sizeof(ans)); //初始化分数0
	for(i=1;i<=n;i++)cin>>t[i];
	for(i=1;i<=m;i++)cin>>hw[i];
	for(i=1;i<=m;i++)cin>>scr[i];
	for(i=1;i<=n;i++){
		for(j=r;j>=hw[i];j--){
			ans[j]=max(ans[j],ans[j-hw[i]]+scr[i]);  //01背包核心（具体参见上面链接OI Wiki）
		}
	}
        for(i=1;i<=r;i++){
		if(ans[i]>=k){
			l=r-i;break; //及格了，可以刷其他题了
		}
	}
	sort(t+1,t+n+1);  //排序，优先选时间短的（这就是标签中的排序？）
	for(i=1;i<=n;i++){ //在全部及格的基础上继续做尽可能多的题
		l-=t[i]; //做题，时间减少
		if(l<0)break;  //时间用完，走人
		cnt++;  //有时间，题数+1
	}
	cout<<cnt<<endl;
	return 0;
}
```


---

## 作者：HiroshiRealm (赞：10)

### 蒟蒻的我表示，为什么这题不能直接暴力dfs呢

看到这题，第一反应是去看数据范围


n≤10,m≤10

高兴，也就是说n+m<=20，那就可以把作业和题目合并成一个数组，直接暴力搜索

作业是有分数的，题目可以看做是特殊的作业，只不过没有分值

因为普及-，也就不需要剪枝就可以水过去啦

上代码

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include <iostream>
using namespace std;
#define i work[step][0]//当前位置所需时间
#define j work[step][1]//当前位置所得分数
int a, b, c, d, work[1000][2], e, ans;
inline void dfs(int step, int time, int point, int ti){//分别是当前的位置，所剩时间，所得分，已刷题目
    if(step == a + b + 1){//到尽头
        if(time >= 0 && point >= c )//判断是否满足条件
            ans = max(ans, ti);//取最大值
        return;
    }
    if(i <= time){//当前时间还够
        if(step <= a)//现在在刷题
            dfs(step + 1, time - i, point , ti + 1);
        else//现在在写作业
            dfs(step + 1, time - i, point + j, ti);
    }//这个位置也可以不选
    dfs(step + 1, time, point, ti);
}
int main() {
    scanf("%d%d%d%d", &a, &b, &c, &d);
    for(int x = 1; x <= a + b; ++x)//合并
        scanf("%d", &work[x][0]);
    for(int x = a + 1; x <= a + b; ++x)//读入分数
        scanf("%d", &work[x][1]);
    dfs(1, d, 0, 0);
    printf("%d", ans);
    return 0;
}

```

---

## 作者：_Yukino (赞：9)


>我承认一开始读题就读懵逼了。。。
>
>原来是先做作业再刷题

若若问一句，真的没有先01背包再完全背包的吗？

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<map>
#include<set>
#include<ctime>
#define ll long long
using namespace std;
const int N=5e6+5,M=1e9+7;
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int a[100];
int b[100];
int c[100];
int dp[200];
int main()
{
	ios::sync_with_stdio(false);
	int n,m,k,r;
	cin>>n>>m>>k>>r;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++)
		cin>>b[i];
	int tot=0;
	for(int i=1;i<=m;i++){
		cin>>c[i];
		tot+=c[i];
	}
	for(int i=1;i<=m;i++)
		for(int j=tot;j>=c[i];j--)
			dp[j]=max(dp[j],dp[j-c[i]]+b[i]);
	int minn=dp[k];
	for(int i=k;i<=tot;i++){
		minn=min(minn,dp[i]);
	}
	int time=r-minn;
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=n;i++)
		for(int j=a[i];j<=time;j++)
			dp[j]=max(dp[j],dp[j-a[i]]+1);
	cout<<dp[time]<<endl;
}
```

---

## 作者：E_tc (赞：9)

# 看到其他的大佬用的都是dfs,菜鸡的我可怜不会。。

## 下面讲一下我的思路：大致思路是总时间减去做作业的时间，而且做作业要到达 k 分，我的思路是用结构体：储存每个作业的时间，分值，以及性价比（就是分值除于时间），将性价比从高到低排序，到达 k 分后，再用01背包；
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
#include <iomanip>
#include <algorithm>
using namespace std;
struct homework
{
	int fen;
	int time;
	double xing;
}a[100];
int n,m,k,r;
int f[100],t[100];
bool cmp(homework h,homework j)
{
	return h.xing > j.xing;
}
int main()
{
	cin>>n>>m>>k>>r;
	for(int i=1;i<=n;i++) cin>>t[i];
	for(int i=1;i<=m;i++) cin>>a[i].time;
	for(int i=1;i<=m;i++) cin>>a[i].fen;
	for(int i=1;i<=m;i++) a[i].xing=a[i].fen*1.0/a[i].time;
	sort(a+1,a+m+1,cmp);
	int i=0;
	while(k > 0)
	{
		i++;
		k-=a[i].fen;
		r-=a[i].time;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=r;j>=t[i];j--)
		{
			f[j]=max(f[j],f[j-t[i]]+1);//显然这里是加1
		}
	}
	printf("%d",f[r]);
	return 0;
}
```

---

## 作者：hmh13951417981 (赞：8)

# 思想：先用dp算出达到k分的最短时间
# 因为每道题只能做一遍，所以是01背包
# 再贪心，做用时少的题目


------------

```c
#include<bits/stdc++.h>
using namespace std;
int n,m,k,r,i,j,x[11],point[11],t[11],s,f[51];
int main() 
{	cin>>n>>m>>k>>r;
	for(i=1;i<=n;i++)
		cin>>x[i];
	for(i=1;i<=m;i++)
		cin>>t[i];
	for(i=1;i<=m;i++)
		cin>>point[i];//输入部分
    sort(x+1,x+n+1);//排序，为下面做用时少的题目预处理
	for(i=1;i<=k;i++) 
		f[i]=66666666;//要求为最小值，先赋值为用时无限大
	for(i=1;i<=m;i++)
		for(j=k;j>=point[i];j--)
			f[j]=min(f[j],f[j-point[i]]+t[i]);
    //01背包，对于这道题做或不做作抉择
	r-=f[k];//真正刷题的时间为原先时间减去做作业最短用时
	i=0;
	while(r>=x[++i]&&i<=n){
		r-=x[i];
		s++;
	}//从用时短的题开始循环，直到没时间或所有题都做完了
    cout<<s;//输出
    return 0;
}
```

---

## 作者：yagyagyag (赞：6)

# 搜索DFS？动态规划DP?都不需要，排序就能搞定
注释全在代码中了

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	double t2,mark,t; 
}a[15];
int n,m,k,r,t1[15];
void Init()
{
	cin>>n>>m>>k>>r;//输入不解释 
	for (int i=1;i<=n;i++)
		cin>>t1[i];
	for (int i=1;i<=m;i++)
		cin>>a[i].t2;
	for (int i=1;i<=m;i++)
		cin>>a[i].mark;
		
	for (int i=1;i<=n;i++)//这里注意了，因为题要做得多，就需要更多的时间，
						//所以做作业的时间就得少，但是又需要保证及格，因此取比值，即"性价比" 
							 
		a[i].t=a[i].mark/a[i].t2;//注意，分数高，时间短，性价比越高，所以用分数除以时间 
}
bool cmp(node a,node b)
{
	return a.t>b.t;//按性价比从大到小排序 
}
bool cmp1(int a,int b)
{
	return a<b;//按做题时间长短从小到大排序 
}
void Solve()
{
	int sum=0,i=0;
	while (sum<k){//分数一高于k就退出，此时所用的时间一定是最少的 
		i++;
		sum+=a[i].mark;
		r-=a[i].t2;//减去写作业的时间 
	}
	sort(t1+1,t1+n+1,cmp1);//做题时间排序 
	int ans=0;
	for (int i=1;i<=n;i++){
		if (r>=t1[i]){//所用时间小于r就ans++，同时要减去所用时间 
			ans++;
			r-=t1[i];
		}
		else break;//拜拜 
	}
	cout<<ans<<endl;//上交 
}
int main()
{
	Init();
	sort(a+1,a+n+1,cmp);//排序 
	Solve();
	return 0;
}
```


---

## 作者：何旭的小粉丝 (赞：6)

第一次写题解，不喜勿喷。

个人是函数控，排版控。没有压行的习惯。。。

其实思路就是01背包，dp貌似不一定要用吧？（看见dp的标签以后个人感到很疑惑。。。）

对数据进行处理这方面吧，（全局变量就不用说了吧。。。）输入和输出都是没多少潜规则的。

头文件方面的话，个人倾向于iostream和algorithm，很少用cstdio。不喜勿喷。

下面附代码吧~（cpp）

```cpp
#include<iostream>
using namespace std;
int n,m,k,r;
int ti[1000],zuo[1000],shi[1000];//ti是“题目”，zuo是“作业”，shi是“时间”
int kk[1000],sum=0;//避免和“k”重复，所以很无耻的用了“kk”
void swap(int &a,int &b)//交换函数 
{
    int t;
    t=a; b=a; b=t;
}
void input()//输入
{
    cin>>n>>m>>k>>r;
    for(int i=1;i<=n;i++)
        cin>>ti[i];
    for(int i=1;i<=m;i++)
        cin>>zuo[i];
    for(int i=1; i<=m; i++)
        cin>>shi[i];
}
void work()//关键在这里！ 
{
    for(int i=1;i<=n;i++)//背包
    {
        for(int j=r;j>=zuo[i];j--)
        {
            if(kk[j]<kk[j-zuo[i]]+shi[i])
            {
                kk[j]=kk[j-zuo[i]]+shi[i];
            }
        }
    }
    for(int i=0;i<=r;i++)//大型搞事情环节
    {    
        if(kk[i]>=k)
        {
            r-=i;
            break;//炸炸炸
        }
        for(int i=1;i<n;i++)//弱鸡冒泡。这里不知为何用STL模板有毒，编译过不去。。。
        {
            for(int j=i+1;j<=n;j++)
            {
                if(zuo[i]<zuo[j])
                {
                    swap(zuo[i],zuo[j]);
                }
            }
        }
    }
    for(int i=1;i<=n;i++)//算一算！
    {
        if(r<ti[i])
            break;//之老是二话不说就炸。。。
        else
        {
            r-=ti[i];
            sum++;
        }
    }
}
void output()//输出喽 
{
    cout<<sum<<endl;
}
int main()//优雅的主程序 
{
    input();
    work();
    output();
    return 0;
}
```

---

## 作者：JuicyMio (赞：5)

**第一次发题解，欢迎拍砖，拒绝杠精**

这题本蒟蒻纠结了好久,第一眼看上去像个01背包,但是我弱,我不会背包啊!于是我瞄了一眼数据范围,小的可怕2333,怪不得是橙题(那我还做那么久

暴搜显然能过,于是我调了一个小时的暴搜...

这两个东西怎么搜?把最短做完作业的时间搜出来再搜剩下时间能做多少题目？好像有点复杂了，后来分析一下，发现作业跟题目没有什么本质上的区别，只不过一个可以加题数，一个可以加分数。而本题要的又是保证分数的情况下要最大题数（这可不太好，有点本末倒置吧2333

所以可以把它们放在一起搜，就好写多了(主观认为

```cpp
#include<iostream>
#include<cstdio>
#define mian main
int a[1000][2];
int n,m,k,r;
int tot = 0,max = -1;
void dfs(int step,int t,int g)//step通常用于控制当前要选择的元素 t时间 g分数
{   
    if(step < n+m)//只要选择没有做完（确定每个元素选或不选
    {
        if(t-a[step][0] >= 0)  //如果选了还没超时
        {   
            if(step < n)//如果选到的是题（因为题存在a[0]~a[n-1],则刷题数+1
            tot ++;                                         
            dfs(step+1,t-a[step][0],g+a[step][1]);//选
            if(step < n)//如果之前加过了，还要在出口减回来
            tot --;
        }
        dfs(step+1,t,g);//当然可以不做这道题/作业
    }
    else
    {
        if(g>=k && t>=0)//及格并且没有超时
            max = std::max(max,tot);
        //tot = 0;这个地方为什么不能清0，因为回溯还要用到
                //而且之前选了之后递归的出口已经减回去了（这个地方我调了好久
        return;
    } 
    return;
}
int mian()
{
    scanf("%d%d%d%d",&n,&m,&k,&r);
    for(int i = 0;i < n+m; i++)//放在一起存
    {
        scanf("%d",&a[i][0]);
    }
    for(int i = n;i < n+m;i ++)//从n往后就是有分数的作业
    {
        scanf("%d",&a[i][1]);
    }
    dfs(0,r,0);//数组是从0从开始存放的，所以step也从0开始（个人习惯而已
    printf("%d",max);
    return 0; 
    //拒绝抄袭，从我做起
    //话说真的有人会抄我这么丑的代码吗（逃
}

```

---

## 作者：boyfaceone (赞：5)

得先完成老师布置的作业才能刷题，只求刷题数量的话显然应该尽量挑费时最少的做，所以问题就转化为求写作业至少得到k分所需的最短时间，因为写作业的时间越短，空出来刷题的时间才更多。可以换个角度，先求出x（1<=x<=r）单位时间内能得到的最大分数f(x)，这是个标准的01背包问题，然后从左往右扫一遍即可求出得到k分所需最短时间，当然由于f(x)是单调的，也可以用二分。


---

## 作者：kpl000 (赞：5)

这其实是一道很基础的动归题——01背包（作业写完了就没了不）

思路：先处理他完成老师任务最短要多少时间（就用01背包），就是这个01背包中求出来的最大值；

然后将 总时间 减去 老师规定作业的时间，就是剩余可以用来刷题的时间；这里就把 刷题用时 排序一下就可以解决了。

01背包转移方程：f[j]=max{ f[j] , f[j-分数]+老师作业时间 }


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,k,r,a[11],b[11],s[11],f[205];
int main()
{
    int i,j,t,ans=0;
    scanf("%d%d%d%d",&n,&m,&k,&r);
    for(i=1;i<=n;i++) scanf("%d",&s[i]);//刷题用时 
    for(j=1;j<=m;j++) scanf("%d",&a[j]);//作业用时 
    for(j=1;j<=m;j++) scanf("%d",&b[j]);//对应分数 
    sort(s+1,s+n+1);  //现排序一下，方便后面好计算 
    for(i=1;i<=m;i++) //01背包 
    {
        for(j=k;j>=b[i];j--)
        {
            f[j]=max(f[j],f[j-b[i]]+a[i]);
        }
    }
    sort(f+1,f+k+1);//在背包处理中找到最大值 
    t=r-f[k];
    for(i=1;i<=n;i++) //计算可刷题数 
    {
        t-=s[i];
        if(t>=0) ans++;
        else break;
    }
    cout<<ans; //输出答案 
    return 0;
}
```

---

## 作者：vectorwyx (赞：4)

## 动规做作业，贪心来刷题


------------
读题，我们可以把小A的整个练习过程分为两部分：

先做作业，后刷题


------------
作业有两个参数：时间和分值

要求也能看出有两个：**在及格的基础上做到时间最少**

首先，及格的条件是什么？是总分值达到$k$及以上

分值需要通过做作业得到

作业有$m$项，每项作业只能做一次

这就是个**01背包**啊！

我们把每项作业当成物品，所需时间作为体积，分值作为重量

这和[采药](https://www.luogu.com.cn/problem/P1048)类似

然后求出在1~r秒内能拿到的最大分值是多少

并用一个一维数组存储最终答案（压维）

最后从下标1开始遍历数组，**找出最先满足及格分值的元素**

总结：**先满足及格，再找出及格所需的最少时间**

------------
再来看刷题

每道题只有一个参数：时间

而要求是做最多的题

很明显，**贪心**！

每次都挑**花费时间最少**的题做

直到时间耗尽或无法再刷


------------
代码来了~
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=151;//定义常量作为背包的最大容量 
int dp[maxn],n,m,k,r,p[11],t[11],c[11],ans;
//n,m,k,r如题 
//p数组储存每道题所需的时间，t数组储存每项作业的时间 
//c数组储存每项作业的分值，ans储存答案
int max1(int a,int b){//定义求两者最大值的函数
	if(a>b) return a;
	else return b;
}
int main(){
	cin>>n>>m>>k>>r;
	for(int i=1;i<=n;++i){
		cin>>p[i];//每道题所需的时间
	}
	sort(p+1,p+1+n);
    //排序，把花费时间最少的题放在前面 
	for(int i=1;i<=m;++i){
		cin>>t[i];
	}
	for(int i=1;i<=m;++i){
		cin>>c[i];
	}
	for(int i=1;i<=m;++i){//01背包的板子，一点不变 
		for(int j=r;j>=t[i];--j){
			dp[j]=max1(dp[j],dp[j-t[i]]+c[i]);
		}
	}
	for(int i=1;i<=r;++i){//遍历 
		if(dp[i]>=k){//用这些时间就及格了 
			r-=i;//时间耗费需减掉 
			break;
//不用再找了，因为后面的肯定比这一个花的时间长 
		}
	}
	for(int i=1;i<=n;++i){//开始刷题 
		r-=p[i];//先减去所需时间 
		if(r<0) break;//时间不够啊，不能做了 
		else ans++;//时间足够，那就刷！ 
	}
	cout<<ans;//输出，搞定！ 
	return 0;
} 
```


---

## 作者：Atmizz (赞：4)

## 思路：  01背包+贪心
先**01背包**算一下老师要求做的题目，然后求出各个时间对应的分数。**for循环**找一下最少时间&&达到及格分数，然后总时间减去最少时间。对小A爱做的题目所用时间进行**sort排序**，先做（减）用时最少的题目。
#### 状态转移方程：
```cpp
f[j]=max(f[j],f[j-hwt[i]]+hws[i]);
```
详细解释在代码中。
### code：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>

using namespace std;

int n,m,r,k,lk[11],f[1001]={0},hws[11],hwt[11],ans=0;
//n，m，r，k如题所示，lk=like（爱做的）
//f的递推数组，hws=homework sore（作业分数）
//hwt=homework time（作业时间），ans=answer（最终答案） 
int main()
{
	scanf("%d%d%d%d",&n,&m,&k,&r);	//输入爱刷的题目个数，老师要求刷的 
									//及格分数，一共的时间 
	for(int i=1;i<=n;i++)	//输入 
		scanf("%d",&lk[i]);
	
	for(int i=1;i<=m;i++)	//输入老师要求刷的题目时间 
		scanf("%d",&hwt[i]);
	
	for(int i=1;i<=m;i++)	//输入老师要求刷的题目分数 
		scanf("%d",&hws[i]);
	
	for(int i=1;i<=m;i++)	//01背包模板打就行 
		for(int j=r;j>=hwt[i];j--)	//注意是倒序 
				f[j]=max(f[j],f[j-hwt[i]]+hws[i]);
	
	for(int i=1;i<=r;i++)	//f一位数组的下标表示的就是 
		if(f[i]>=k) {		//每个分数所用的时间 
			r-=i;			//总时间减去老师要求做最少题的时间 
			break;			//防止下一个分数也减 
		}
	
	sort(lk+1,lk+1+n);		//进行排序，从用时最少的开始
							//“计算机要从娃娃抓起” 
	for(int i=1;i<=n;i++) {
		if(r-lk[i]<0)	//如果时间不够 
			break;		//退出循环 
		r-=lk[i];		//减去时间 
		ans++;			//做的题目数加加 
	}
	printf("%d",ans);	//输出最终答案 
	return 0;			//结束 
}
```

---

## 作者：cyr2003 (赞：4)

这是一道练手的好题

```cpp
var a:array[1..20] of real;
    b,c,d:array[1..50] of real;
    n,m,i,j,ans:integer;
    t,t1,k,r,x,s:real;
begin
 ans:=0;//计数器置零0
 x:=0; s:=0;
 readln(n,m,k,r);
 for i:=1 to n do read(a[i]);
 readln;
 for i:=1 to m do read(b[i]);
 readln;
 for i:=1 to m do read(c[i]);
 for i:=1 to m do
  d[i]:=c[i]/b[i];//求每项作业好值（分值除以时间越大越好）
 for i:=1 to m-1 do
  for j:=i+1 to m do
   if d[j]>d[i] then begin 
                      t:=c[i]; c[i]:=c[j]; c[j]:=t; //以每项作业的好值从大到小排序，交换分值
                      t1:=b[i]; b[i]:=b[j]; b[j]:=t1; //交换时间
                     end; 
 for i:=1 to m do 
  begin
   x:=x+c[i];//x为小A写的作业的分值和
   s:=s+b[i];//s为小A完成作业（刚及格）的时间和
   if x>=k then begin 
                        x:=0;//省的等会再新开一个计数器 
                        break; //如果x达到了及格分，就跳出
                       end;
  end;
 r:=r-s;//小A的刷题时间要减去写作业的时间
 for i:=1 to n-1 do
  for j:=i+1 to n do
   if a[j]<a[i] then begin t:=a[i]; a[i]:=a[j]; a[j]:=t; end;//小A喜欢题目的时间从小到大排序（时间越少可做题数就越多）
 for i:=1 to n do
  begin
   x:=x+a[i];
   if x<=r then inc(ans)//计数器加1
           else break;
  end;
 writeln(ans);
end
```

---

## 作者：九指客 (赞：3)

```cpp
#include<stdio.h>//01背包
#include<string.h>
int n,m,k,r,tot=0,point[101],wtime[101],ptime[101],f[1001],t;
int main()
{
    int i,j;
    scanf("%d %d %d %d",&n,&m,&k,&r);//读入
    for(i=1; i<=n; i++)
        scanf("%d",&ptime[i]);
    for(i=1; i<=m; i++)
        scanf("%d",&wtime[i]);
    for(i=1; i<=m; i++)
        scanf("%d",&point[i]);//相应时间和分值
    for(i=1; i<=n; i++)
        for(j=r; j>=wtime[i]; j--)
        {
            if(f[j]<f[j-wtime[i]]+point[i])
            {
                f[j]=f[j-wtime[i]]+point[i];//背包
            }
        }
    for(i=0; i<=r; i++)
        if(f[i]>=k)
        {
            r-=i;
            break;
        }
        for(i=1;i<n;i++)//排序
        {
            for(j=i+1;j<=n;j++)
            {
                if(wtime[i]<wtime[j])
                {
                    t=wtime[i];
                    wtime[i]=wtime[j];
                    wtime[j]=t;
                }
            }
        }
    for(i=1;i<=n;i++)
         if(r<ptime[i])break;
    else
    {
        r-=ptime[i];
        tot++;
    }
    printf("%d",tot);//输出
    return 0;
}
//其实就是01背包
```

---

## 作者：zhaowangji (赞：2)

强烈要求注明数据范围！~~否则洛谷将会臭名昭著~~（逃

01背包求出最短要多少时间及格，然后贪心给题目排序，从时间少的开始做起

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[157],a[17],b[17];//最大数据给出的时间是150
//所以原来f开107本地过了，然而洛谷IDE挂了，并不知道为什么
//f存每个时间内得到的最大分数，a是作业时间，b是作业分数

int ex[17];//题目时间
int n,m,k,r;
int tim;
int ans;
int main(){
    cin>>n>>m>>k>>r;
    for(int i=1;i<=n;++i)
        cin>>ex[i];
    for(int i=1;i<=m;++i)
        cin>>a[i];
    for(int i=1;i<=m;++i)
        cin>>b[i];
    for(int i=1;i<=m;++i)
        for(int j=r;j>=a[i];--j)
            f[j]=max(f[j],f[j-a[i]]+b[i]);
            //01背包 求出在i时间内，能够达到的最大分数
    for(int i=0;i<=r;++i)//个人觉得应该从0开始判断，防止特殊数据
        if(f[i]>=k){//当前时间已经及格了
            tim=r-i;//不用再做作业了
            break;//跳出循环
        }
    sort(ex+1,ex+n+1);//贪心，从小到大排序
    for(int i=1;i<=n;++i)
        if(tim>=ex[i]){//如果还来得及做
            ans++;//做了一题
            tim-=ex[i];//减去这题的时间
        }
    cout<<ans<<endl;//一共做了几题
    return 0;
}

```


---

## 作者：thelast (赞：1)

### 题目背景
	   数学是火，点亮物理的灯；物理是灯，照亮化学
       的路；化学是路，通向生物的坑；生物是坑，埋
       葬学理的人。 文言是火，点亮历史宫灯；历史是
       灯，照亮社会之路；社会是路，通向哲学大坑哲
       学是坑，埋葬文科生。——小A
####   别看了，解析来了

首先，本题要求要及格，所以说我们要按照最高的效率来做作业，所以用动归，前i个题在r时间内最多的得分，最后动归完了可以的出所有题在内，各个时间长度下的最高得分，然后作业时间要尽量短，所以从时间1开始往后走，到f[i]刚好>=k时，即为所耗的最段时间，剩下的就是“刷题时间”，用贪心即可;

## 结束收工，附代码
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,r,t1[11],w[11],v[11],f[200],r1,total;
int main(){
	cin>>n>>m>>k>>r;
	for(int i=1;i<=n;i++)scanf("%d",&t1[i]);
	sort(t1+1,t1+1+n);
	for(int i=1;i<=m;i++)scanf("%d",&w[i]);
	for(int i=1;i<=m;i++)scanf("%d",&v[i]);
	for(int i=1;i<=m;i++)
		for(int j=r;j>=w[i];j--)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	for(int i=1;i<=r;i++)if(f[i]>=k){
		r1=i;break;
	}
	r-=r1;
	for(int i=1;i<=n;i++){
		if(r-t1[i]>=0){r1-=t1[i];total++;}
		else break;
	}
	cout<<total<<endl;
	return 0;
}
```


---


# [GESP202412 七级] 武器购买

## 题目描述

商店里有 $n$ 个武器，第 $i$ 个武器的强度为 $p_i$，花费为 $c_i$。

小杨想要购买一些武器，满足这些武器的总强度不小于 $P$，总花费不超过 $Q$，小杨想知道是否存在满足条件的购买方案，如果有，最少花费又是多少。

## 说明/提示

| 子任务编号 | 数据点占比 |    $n$     |        $p_i$        |        $c_i$        |         $P$         |         $Q$         |
| :--------: | :--------: | :--------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: |
|    $1$     |   $20\%$   | $\leq 10$  |         $1$         |         $1$         |      $\leq 10$      |      $\leq 10$      |
|    $2$     |   $20\%$   | $\leq 100$ | $\leq 5\times 10^4$ |         $1$         | $\leq 5\times 10^4$ |         $2$         |
|    $3$     |   $60\%$   | $\leq 100$ | $\leq 5\times 10^4$ | $\leq 5\times 10^4$ | $\leq 5\times 10^4$ | $\leq 5\times 10^4$ |

对于全部数据，保证有 $1\leq t\leq 10$，$1\leq n\leq 100$，$1\leq p_i,c_i,P,Q\leq 5\times 10^4$。

## 样例 #1

### 输入

```
3
3 2 3
1 2
1 2
2 3
3 3 4
1 2
1 2
2 3
3 1000 1000
1 2
1 2
2 3```

### 输出

```
3
-1
-1```

# 题解

## 作者：lby_commandBlock (赞：17)

## 前言

看到这些题目，就要想到这道题要用什么算法来做，例如这道题要动态规划。

下文中的 $p_i,c_i$ 均与题目描述一致。

## 思路

按照动态规划的步骤进行思考。[动态规划五部曲](https://www.bilibili.com/video/BV13Q4y197Wg)。

1. dp 数组以及下标的含义。

设 $dp_{i,j}$ 为前 $i$ 个武器中购买，总花费不超过 $j$，以**最优策略**购买武器后，武器的**强度和**。

2. 递推公式。

- 若 $c_i > j$，即该武器的花费大于了总花费（下文称**预算**），则 $dp_{i,j}$ 就直接从 $dp_{i-1,j}$ 进行转移。

- 若 $c_i \leq j$，即该武器的花费小于预算，就有买和不买两种情况。

$$dp_{i,j}=\max\{{dp_{i-1,j-c_i}+p_i}_{买的情况},{dp_{i-1,j}}_{不买的情况}\}$$

3. dp 数组如何初始化。

由于 dp 要求**最大的强度和**，所以直接将 dp 数组初始化为 $0$ 即可。

4. 遍历顺序。

由于求 $dp_{i,j}$ 牵连到了前 $i-1$ 个武器的最大强度，但 $dp_{i,j}$ 不会牵连到 $dp_{i,k}(k<j)$，所以 $i$ 需要按从小到大的顺序进行遍历，$j$ 哪个顺序遍历都行。

5. 打印 dp 数组。

按照 $dp$ 数组的含义，找到最小的一个 $q(1 \leq q \leq Q)$，使得 $dp_{n,q} \geq P$ 即可。若没有任何一个 $dp_{n,q} \geq P$，则直接按题意输出 `-1` 即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

int T, n, P, Q, p[109], c[109], dp[109][50009];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> T;
	while (T--) {
		cin >> n >> P >> Q;
		for (int i = 1; i <= n; i++)
			cin >> p[i] >> c[i];
		// 初始状态
		memset(dp, 0, sizeof(dp));
		// DP
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= Q; j++) {
				// 不买
				dp[i][j] = dp[i - 1][j];
				// 若可以买，就把买和不买取最大值
				if (c[i] <= j)
					dp[i][j] = max(dp[i][j], dp[i - 1][j - c[i]] + p[i]);
			}
		}
		// 打印
		bool flag = true;
		for (int q = 1; q <= Q; q++) {
			if (dp[n][q] >= P) {
				cout << q << endl;
				flag = false;
				break;
			}
		}
		if (flag)
			cout << -1 << endl;
	}
	return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：11)

**动态规划，启动！**

## 思路

这是一道非常经典的动态规划的题目。具体地，我们还可以细分成 01 背包的经典题目，不会的同学请移步至 [OI Wiki](https://oi-wiki.org/dp/knapsack/#0-1-%E8%83%8C%E5%8C%85)。

上述网址捞干的就是动态规划有转移方程。设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。得出状态转移方程：
$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$

现在我们考虑用滚动数组来优化，由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_j=\max(f_{j},f_{j-w_{i}}+v_{i})
$$

然后呢？愣着干嘛，写代码！

### 提示

1. 由于是多组数据，**请务必每次都要初始化数组**。
2. 背包问题的转移方程非常**重要**，请牢记于心。

## 核心代码

```cpp
dp[0]=0;
for(int i=1;i<=n;i++){
	int p=w[i].first;
	int c=w[i].second;
	for(int j=q;j>=c;j--){
		if(dp[j-c]>=0)
			dp[j]=max(dp[j],dp[j-c]+p);
	}
}
for(int j=0;j<=50010;j++){
	if(dp[j]>=p){
		return j;
	}
}
return -1;
```

AC 快乐！RP++！

---

## 作者：Programming_Konjac (赞：8)

# 思路
我们稍微转换一下，就能变成这个问题：

现有 $n$ 个物品，第 $i$ 个物品价值为 $p_i$，重量为 $c_i$，当重量小于等于 $Q$，并且价值大于等于 $P$ 时，输出最小的重量，如果无解，输出 $-1$。

这就是一个 $01$ 背包板子题，背包容量为 $Q$，然后求解完当背包容量为 $1$ 到 $Q$ 时的最大价值，最后从 $1$ 遍历到 $Q$，如果当前这个最大价值大于等于 $P$ 时，输出，结束遍历。

特别的，我们还要定一个标记变量，用来标记是否有输出，如果没有，则就是无解，输出 $-1$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int dp[50005];
int main(){
	int t;
	cin>>t;
	while(t--){
		memset(dp,0,sizeof dp);
		int n,P,Q;
		cin>>n>>P>>Q;
		int p[105],c[105];
		for(int i=1; i<=n; i++){
			cin>>p[i]>>c[i];
		}
		for(int i=1; i<=n; i++){
			for(int j=Q; j>=c[i];j--){
				dp[j]=max(dp[j],dp[j-c[i]]+p[i]);
			}
		}
		int flag=1;
		for(int i=1; i<=Q; i++){
			if(dp[i]>=P){
				cout<<i<<"\n";
				flag=0;
				break;
			}
		}
		if(flag==1) cout<<"-1\n";
	}
	return 0;
}
```

---

## 作者：HsNu1ly7_ (赞：3)

## 思路

这是一个典型的背包问题。

我们可以设 $dp_{j}$ 为武器总强度为 $j$ 的情况下的最小花费。

于是，根据背包问题的模型我们就能得出：

$$
dp_j = \max_{1 \le i \le n} dp_{j - c_i} + p_i
$$

最终，答案就为第一个大于等于 $P$ 的 $dp_j$ 的下标 $j$。

时间复杂度为 $O(TnQ)$。


## 代码

```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep( i , l , r ) for (int i = (l) ; i <= (r) ; i++)
#define per( i , r , l ) for (int i = (r) ; i >= (l) ; i--)
int n , P , Q ;
int p[110] , c[110] ;
int dp[50010] ;
void solve (){
	memset (dp , 0 , sizeof dp) ;
	cin >> n >> P >> Q ;
	rep (i , 1 , n){
		cin >> p[i] >> c[i] ;
	}
	rep (i , 1 , n){
		per (j , Q , c[i]){
			dp[j] = max (dp[j] , dp[j - c[i]] + p[i]) ;
		}
	}
	rep (j , 0 , Q){
		if (P <= dp[j]){
			cout << j << '\n' ;
			return ;
		}
	}
	cout << -1 << '\n' ; 
}

signed main (){
	int _ = 1 ;
	cin >> _ ;
	while ( _-- ){solve () ;}
	return 0 ;
}
```

---


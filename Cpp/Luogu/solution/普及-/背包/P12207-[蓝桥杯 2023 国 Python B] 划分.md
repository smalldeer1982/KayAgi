# [蓝桥杯 2023 国 Python B] 划分

## 题目描述

给定 $40$ 个数，请将其任意划分成两组，每组至少一个元素。每组的权值为组内所有元素的和。划分的权值为两组权值的乘积。请问对于以下 $40$ 个数，划分的权值最大为多少。

```
5160 9191 6410 4657 7492 1531 8854 1253 4520 9231

1266 4801 3484 4323 5070 1789 2744 5959 9426 4433

4404 5291 2470 8533 7608 2935 8922 5273 8364 8819

7374 8077 5336 8495 5602 6553 3548 5267 9150 3309
```

# 题解

## 作者：mcturtle (赞：12)

## 思路
01 背包模版变形。

下面就是本题的思路了（较详细）：

准备工作：首先将这 $40$ 个数存储到 $a$ 数组中，随后将它们求和存储为 $sum$，$dp_0 \gets 0$。

由于我们只有选和不选两种选择，所以使用 `bool` 类型存储数组比较合适。

外层循环遍历这 $40$ 个数，内层循环从 $\frac{sum}{2}$ 遍历到当前外层循环遍历到的数 $a_i$（不包含 $a_i$）。

推导公式：$dp_i \gets dp_{i-a_i}$。通过遍历每个数，更新可能达到的和。

随后我们可以寻找最优解。从 $\frac{sum}{2}$ 开始，向下查找最大的可行和，并计算对应的乘积。

## 代码
$\texttt{C++}$：
```cpp
#include <iostream>
using namespace std;
int a[]={5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433,4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819,7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309};
long long sum,mx;
bool dp[1000005];
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    for(int i:a)sum+=i;
    sum/=2;
    dp[0]=1;
    for(int k:a){
        for(int i=sum;i>=k-1;i--){
            if(dp[i-k])dp[i]=1;
        }
    }
    for(int i=sum;i>=0;i--)if(dp[i]){mx=i;break;}
    long long p=mx*(sum*2-mx);
    cout<<p;
    return 0;
}
```
$\texttt{Py}$：
```py
a = [
    5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231,
    1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433,
    4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819,
    7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309
]
t = sum(a)
h = t // 2
dp = [0] * (h + 1)
dp[0] = 1
for k in a:
    for i in range(h, k - 1, -1):
        if dp[i - k]:
            dp[i] = 1
m = 0
for i in range(h, -1, -1):
    if dp[i]:
        m = i
        break
r = m * (t - m)
print(r)
```

---

## 作者：czh1005 (赞：3)

根据和同近积大原理，将这个数组分成两半，我们希望尽可能的让这两个和越接近越好，那么最好情况就是两个和相等。\
那么怎么证明这样可以呢？我们可以利用双向搜索，证明这样可以。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n=40,sum=0;
ll a[50]={0,
5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,
1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,
4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,
7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
ll ans;
bool x[1000000],y[1000000];
void dfs(int i,int j,ll sum){
	if(i==21){
		x[sum]=1;
		return;
	}
	dfs(i+1,j+1,sum+a[i]);
	dfs(i+1,j,sum);//O(2^n)算出前一半都能得到哪些值
}
void dfs1(int i,int j,ll sum){
	if(i==41){
		y[sum]=1;
		return;
	}
	dfs1(i+1,j+1,sum+a[i]);
	dfs1(i+1,j,sum);//O(2^n)算出后一半都能得到哪些值
}
int main(){
	dfs(1,0,0);
	dfs1(21,0,0);
	for(int i=0;i<=113462;i++){
		if(x[i]&&y[113462-i]){//判断能否加出113462
			cout<<"YES\n";//如果输出YES代表可以
			return 0;
		}
	}
	return 0;
}
```
发现输出的是

```cpp
YES
```
所以代表着可以选到，那么答案就是 $(sum/2)*(sum/2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n=40,sum=0;//记得开long long
long long a[50]={0,
5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,
1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,
4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,
7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
//数组里要给改成“，”
int main(){
	for(int i=1;i<=n;i++){
		sum+=a[i];
	}
	cout<<sum*sum/4<<'\n';
	return 0;
}
```
python代码

```python
a = [
    0,  # 占位，使索引从1开始
    5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231,
    1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433,
    4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819,
    7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309
]

n = 40
sum_total = 0

for i in range(1, n + 1):
    sum_total += a[i]

print(sum_total * sum_total // 4)
```

---

## 作者：HZY1618yzh (赞：3)

题目描述
---
把给定的 $40$ 个数分成两组，定义权值为组内所有元素的和，求两组权值的积最大是多少。

思路
---
先用背包 DP 求出两组的最优解（贪心的想法，当每组权值接近 $40$ 个数的和的一半，积就最大），再求出乘积。

实现方法
---
$dp_j$ 为第一组的权值能否为 $j$。所以遍历 $a$ 的每个元素，遍历 $a_i-1$ 致 $40$ 个数的和的一半，若发现 $dp_{j-a_i}$ 成立，则 $dp_j$ 成立。因为 $dp_j$ 可以通过 $dp_{j-a_j}$ 增加 $a_j$ 得到。

具体实现代码
---
- c++。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[]={5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,
1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,
4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,
7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
bool dp[1000001];
long long sum,maxn,p;
int main(){
    //计算40个数的和的一半
	for(int i=0;i<40;i++)
		sum+=a[i];
	sum/=2;
    dp[0]=1;
    //DP
	for(int i=0;i<40;i++)//遍历a的每个元素
		for(int j=sum;j>=a[i]-1;j--)
			if(dp[j-a[i]]) dp[j]=1;//若发现 $dp_{j-a_i}$ 成立，则 $dp_j$ 成立
	for(int i=sum;i>=0;i--)//贪心，离40个数的和的一半越近，乘积越大
		if(dp[i]){
            //发现最优解就赋值和跳出
			maxn=i;
			break;
		}
	p=maxn*(sum*2-maxn);//计算乘积
	cout<<p;//输出
	return 0;//完结散花
}
```

- python。
```python
a = [5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231,
     1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433,
     4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819,
     7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309]

sum_total = sum(a) 
dp = [False] * (sum_total + 1)
dp[0] = True
for num in a:
    for j in range(sum_total, num - 1, -1):
        if dp[j - num]:
            dp[j] = True
maxn = 0
for i in range(sum_total, -1, -1):
    if dp[i]:
        maxn = i
        break
p = maxn * (sum_total * 2 - maxn)
print(p)
```
~给个赞再走呗。~

---

## 作者：FJ_EYoungOneC (赞：2)

### 题意分析

将一个长度 $40$ 的数组 $A$ 拆成两份 $a, b$，设 $s_1, s_2$ 分别表示数组 $a, b$ 的和，求 $s_1 \times s_2$ 的最大值。

我们来考虑一下，什么情况下可以使得 $s_1 \times s_2$ 取得最大值。

设数组 $A$ 的和为 $s$，设数组 $a$ 的和为 $x$，那么数组 $b$ 的和就为 $s - x$，$s_1 \times s_2 = x \times(s-x) = x^2 - sx$，函数大致如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/t8k2v5xv.png)

当 $x = \dfrac s 2$，$x \times (s - x)$ 取得最大值。

$x$ 约趋近于 $\dfrac s 2$，结果越大。

所以，现在任务转换为，将数组 $A$，拆成两个子数组，要求两个数组的和要尽可能接近。

### 法一

通过 `dfs` 进行爆搜，编码难度较大，较容易出错。

### 法二

通过 `dp` 确认哪些和是可以被构建出来的。

设 $f[i][j]$ 表示前 $i$ 个数，能否凑出一个和为 $j$ 的数组。

考虑第 $i$ 个数，若对于某个 $f[i-1][j]$ 为 $1$ 时：

- 不用第 $i$ 个数：前 $i-1$ 个数可以凑出 $j$，那么前 $i$ 个数也一定可以凑出 $j$，即 $f[i][j]$ 为 $1$。
- 用第 $i$ 个数：用前 $i-1$ 个数可以凑出 $j$，那么前 $i$ 个数就可以凑出 $j+w[i]$，即 $f[i][j + w[i]$ 为 $1$。

另外本题可进行空间优化。

- Python

```python
import sys
sys.setrecursionlimit(1000000)
input = lambda:sys.stdin.readline().strip()

N = int(4e5 + 10)

a = [0, 5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433, 4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819, 7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309]
n = 40

s = sum(a)
f = [[False for i in range(N)] for i in range(45)]

f[0][0] = True
for i in range(1, n + 1):
    for j in range(0, N - 1):
        if f[i - 1][j]:
            f[i][j] = f[i][j + a[i]] = True

t = s // 2
while not f[n][t]:
    t -= 1

print(t * (s - t))
```

- Python（滚动数组）

```python
import sys
sys.setrecursionlimit(1000000)
input = lambda:sys.stdin.readline().strip()

N = int(4e5 + 10)

a = [5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433, 4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819, 7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309]

s = sum(a)
f = [False for i in range(N)]

f[0] = True
for x in a:
    for i in range(N - 1, 0 - 1, -1):
        if f[i]:
            f[i + x] = True

t = s // 2
while not f[t]:
    t -= 1

print(t * (s - t))
```

运行结果：

```
12873625444
```

---

## 作者：shy_lihui (赞：1)

## dfs

背包不好想（至少我没想出来），因为直接输出答案。也可以爆搜。

两数越接近乘积越大，这是人尽皆知的一个结论。证明也很容易，这里就不多说了（但这跟暴搜没什么关系）。

每次就是选或者不选。

打表代码：
- python

```cpp
a=[0,5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,7374,8077,5336,8495,5602,6553,3548,5267,9150,3309]
ans=0
def dfs(temp,sum1,sum2):
	global ans
	if temp==41:
		ans=max(ans,sum1*sum2)
		return
	dfs(temp+1,sum1+a[temp],sum2)
	dfs(temp+1,sum1,sum2+a[temp])
dfs(1,0,0)
print(ans)
```

- c++
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[50]={0/*占位*/,5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
int ans;
void dfs(int temp,int sum1,int sum2)
{
	if(temp==41)
	{
		ans=max(ans,sum1*sum2);
		return;
	}
	dfs(temp+1,sum1+a[temp],sum2);
	dfs(temp+1,sum1,sum2+a[temp]);
} 
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	dfs(1,0,0);
	cout<<ans;
	return 0;
}
```
花费一小时多，最后跑出来答案是 $12873625444$，直接输出即可。


## 背包

这些数的和除以二是可以被凑出来的，也就是说答案就是 $\lfloor \frac {s}{2}\rfloor\times (s-\lfloor \frac {s}{2}\rfloor)$。$s$ 是所有数的总和。

证明也很方便，写一个背包，$dp_{i,j}$ 表示前 $j$ 个能否拼凑成和为 $i$，无非就是选或者不选。

转移方程：

$$
dp_{i,j}=(dp_{i,j-1})\operatorname{or}(dp_{i-a_j,j})
$$

解释：如果不需要地 $j$ 个数也可以做到组成 $i$，那么前 $j-1$ 个就能组成；如果需要第 $j$ 个，则需要让前 $j-1$ 个组成 $i-a_j$。


背包代码：
- python
```python
a=[0,5160,9191,6410,4657,7492,1531,8854,1253,4520,
        9231,1266,4801,3484,4323,5070,1789,2744,5959,9426,
        4433,4404,5291,2470,8533,7608,2935,8922,5273,8364,
        8819,7374,8077,5336,8495,5602,6553,3548,5267,9150,3309]
s=sum(a[1:41])
dp=[[0]*(40+1)for _ in range(s+1)]
dp[0][0]=1
for j in range(1,40+1):
    for i in range(s+1):
        if i>=a[j]:
            dp[i][j]=dp[i][j-1] or dp[i-a[j]][j]
        else:
            dp[i][j]=dp[i][j-1]
print(int(dp[s//2][40]))
print(int(dp[s-s//2][40]))
```



- c++

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int s;
int a[50]={0/*占位*/,5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
int dp[1000005][55];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	for(int i=1;i<=40;i++)
	{
		s+=a[i];
	}
	dp[0][0]=1;
	for(int j=1;j<=40;j++)
	{
		for(int i=0;i<=s;i++)
		{
			if(i>=a[j])
			{
				dp[i][j]=dp[i][j-1]||dp[i-a[j]][j];
			}
			else
			{
				dp[i][j]=dp[i][j-1];
			}
		}
	}
	cout<<dp[signed(s/2)][40]<<'\n';
	cout<<dp[s-signed(s/2)][40]<<'\n';
	return 0;
}
```




代码：

```python
nums=[5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,
       1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,
       4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,
       7374,8077,5336,8495,5602,6553,3548,5267,9150,3309]
print(sum(nums)//2*(sum(nums)-sum(nums)//2))

```

python 还能直接求数列和，羡慕了。

---

## 作者：l15130880055 (赞：1)

## P12207 [蓝桥杯 2023 国 Python B] 划分

### Problem

给你 $40$ 个数，随便划分成两组，使得各组元素和之积最大。

### Solution
根据基本不等式，为了让各组元素和之积最大，那么各组的和越接近就是越优的，于是转化成了一个背包 dp 问题。

令 $dp_i$ 表示能不能使一组的和为 $i$，转移和正常背包一样。令 $a$ 表示 $40$ 个数之和，然后从 $\frac{a}{2}$ 开始到 $0$ 找到一个最接近 $\frac{a}{2}$ 的和，设它为 $b$。

我们要求的答案就是 $b(a-b)$。

最后经笔者这边跑出来答案就是 `12873625444`。

### Code
代码不贴了，注意复制完题目中的数组下标从 $0$ 开始，有需要的可以私信我。

---

## 作者：dg114514 (赞：1)

下文中，以 $V$ 表示 $\sum a$。\
简单 01 背包。\
发现问题本质就是求出所有子集的和与 $V-$ 那个子集的和的积的最大值。然后子集的和这一部分可以使用 01 背包，然后做完 01 背包后就可以暴力去算上述的式子然后取最大值，没了。复杂度 $O(nV)$，可以通过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[]={0,5160,9191,6410,4657,7492,1531,8854,1253,4520,9231,1266,4801,3484,4323,5070,1789,2744,5959,9426,4433,4404,5291,2470,8533,7608,2935,8922,5273,8364,8819,7374,8077,5336,8495,5602,6553,3548,5267,9150,3309};
bitset<400005>vis;
signed main() {
	int n=accumulate(a+1,a+41,0);//求和函数
	for(int i=0;i<=40;i++) vis[a[i]]=1;
	for(int j=1;j<=40;j++)//到 line 18 都是 01 背包变形
		for(int i=n;i>=a[j];i--)
			if(vis[i-a[j]])
				vis[i]=1;
	int ans=0;
	for(int i=0;i<=n;i++)//暴力计算积的最大值
		if(vis[i])
			ans=max(ans,i*(n-i));
	cout<<ans;
}
```

---


# 神奇的四次方数

## 题目背景

在你的帮助下，v 神终于帮同学找到了最合适的大学，接下来就要通知同学了。在班级里负责联络网的是 dm 同学，于是 v 神便找到了 dm 同学，可 dm 同学正在忙于研究一道有趣的数学题，为了请 dm 出山，v 神只好请你帮忙解决这道题了。

## 题目描述

将一个整数 $m$ 分解为 $n$ 个四次方数的和的形式，要求 $n$ 最小。例如，当 $m=706$ 时，因为 $706=5^4+3^4$，所以有 $n=2$。可以证明此时 $n$ 最小。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$m \le 5000$；
- 对于 $100\%$ 的数据，$m \le 100,000$。

## 样例 #1

### 输入

```
706```

### 输出

```
2```

# 题解

## 作者：x义x (赞：314)

### 修订版

完全背包固然是正解，但万一比赛时我们~~脑子瓦特~~想不出正解怎么办呢？

那就是我们的爆搜出场的时候了！（滑稽）

但是纯爆搜显然是不行的，$m<=100000$，这个数据范围很有可能得不了高分甚至爆0，所以我们就要进行一些优化。

首先是剪枝。我们可以用ans存下当前的最好答案，如果在搜索时当前选的数的数量已经大于ans了，那肯定就没必要找了，这样是白费力气。另外，$1^4+2^4$和$2^4+1^4$是一样的方案，不需要分别处理，我们存储一个last保证选出的数列变得不降，同样可以减少时间消耗。

另外搜的顺序非常重要。如果我们从1往上搜，那第一个选出来的肯定是全1的序列。这种情况我们肯定不想要，希望直接将其剪枝。那么怎么操作呢？结合刚才说的，我们可以确定一个~~娇小~~较小的ans，然后之后的搜索肯定不会超过这个步数。没错，从最大往小的搜可以很好地完成这个任务。如果不这样的话只会有30分。

如何实现？请看代码。

```
#include<bits/stdc++.h>
using namespace std;

int n;
int ans=999999;

void dfs(int tot,int k,int last)
/*
三个参数：
tot是之前所有选的数的和，
k是选了几个数（用于更新ans）
last是上次选的数（保证不降序排列，不会出现1^4+2^4和
2^4+1^4分别处理的尴尬情况）
*/
{
	if(k>ans) return; //剪枝
	if(tot>n) return; //边界条件
	
	if(tot==n) //达到n了，更新答案
	{
		if(ans>k) ans=k;
		return;
	}
	
	int i;
	
	for(i=last;i*i*i*i<=n-tot;) i++;
	
	for(;i>=last;i--) //从后往前搜
		dfs(tot+i*i*i*i,k+1,i);
}

int main()
{
	cin>>n;
	dfs(0,0,1); //爆搜大法牛B！！！
	cout<<ans;
}
```

另外，这份代码虽是爆搜，但运行也是非常快的~除了#2有236ms，#9有184ms外其他都是0ms。

最后，如果您觉得这篇题解还不错的话，请记得点个赞吧~

---

## 作者：frankchenfu (赞：87)

这道题目我们使用背包问题的思想来做。

这里，我们先把每一个四次方数打表。打到什么位置呢？

通过简单的推理，我们发现，只要打到$\sqrt[4]{m}$的4次方就够了。

为什么呢？因为为了凑出这个数，我们肯定用比他小的数来凑，如果超过了$\sqrt[4]{m}$，就不可能用上了。

因此我们也可以用楼下的方法，打表打到18，因为${18}^{4}$已经超过了$max(m)={10}^{5}$。

然后，以每一个四次方数为体积，1为物品重量，做完全背包（压维）。

特殊在于，f数组初始化为Inf.初值设置$f_0=0$，那么最终的结论就是$f_m$。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define min(x,y) (x<y?x:y)
const int MAXN=200010;
int s[MAXN],f[MAXN];
int m;

int main()
{
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
        f[i]=1e8;
    int n=ceil(sqrt(sqrt(m))+1);
    for(int i=1;i<=n;i++)
        s[i]=i*i*i*i;
    for(int i=1;i<=n;i++)
        for(int j=s[i];j<=m;j++)
            f[j]=min(f[j],f[j-s[i]]+1);
    printf("%d\n",f[m]);
}
```
（其实这篇题解最重要的是下面这个部分）。

Extra：若把四方数改为平方数，那么做法也是一样的；

不过这时有一个定理，叫**拉格朗日四方和定理**。有兴趣的同学可以自行查阅。

它的大概意思就是，任何自然数都可以表示为n个平方数之和（n<=4）。


---

## 作者：shijunfeng00 (赞：45)

这道题……比较容易看出来是个完全背包问题~

只不过要我们求最小值

递推关系f[v]=max{f[v],f[v-w[i]+c[i]]}

这里我们让i=1 to 18 (18^4>100000)

w[i]=i\*i\*i\*i;c[i]=1;这里我们可以省略掉c[i]数组了

我们只需要将f[i]初始化为inf并且f[0]=0;

还有一些微小的改动

具体参考代码：

```cpp
#include<bits/stdc++.h>
int f[200001],w[200001],n=18,m;
using namespace std;                    //全局变量部分
int main()
{
    memset(f,0xf,sizeof(f));          
    f[0]=0;cin>>m;                      //初始化数据
    for(int i=1;i<=n;i++)
        w[i]=i*i*i*i;
    for(int i=1;i<=n;i++)                    //完全背包
        for(int v=w[i];v<=m;++v)
        if(f[v]>f[v-w[i]]+1)
            f[v]=f[v-w[i]]+1;
    cout<<f[m];
}
```

---

## 作者：时空之影 (赞：15)

这种题一看就是dp嘛
看一个数i，他有可能是由i减去某一个数的四次方的来的
所以轻松得到状态转移方程
```
dp[i] = min(dp[i], dp[i - (j * j * j * j)] + 1);
```
有了状态转移方程只需要枚举i和就行了，时间复杂度O(n*log4 n)
```
#include <bits/stdc++.h>
int m, dp[100005];
int main() {
  scanf("%d", &m);
  for (int i = 1; i <= m; i++) dp[i] = 1e9+7;
  dp[1] = 1;
  for (int i = 2; i <= m; i++)
    for (int j = 1; j * j * j * j <= i; j++)
      dp[i] = std::min(dp[i], dp[i - (j * j * j * j)] + 1);
  printf("%d\n", dp[m]);
  return 0;
}
```
简单易懂，感觉没啥好说的
希望能通过吧

---

## 作者：FlashLizard (赞：14)

   可以看一下题目数据不怎么大，但爆搜依然可能Tle，所以就想到了记忆化搜索，每搜过一个数，就把它记录下来，留着下次重复时用，这样就大大减少了时间消耗。如果还想再优化，可以用升序的方法减少重复的序列（~~其实总共也就优化了12ms~~）。

代码奉上：
```
#include <cstdio>
#include <algorithm>
using namespace std;
int a[21];//储存比m小的4次方
int f[100001];//储存第i个数的答案
void init(int n)//生成4次方
{
	int i=1;
	while(i*i*i*i<=n)
	{
		a[++a[0]]=i*i*i*i;
		i++;
	}
}
int dfs(int n,int i)
{
	if(n==0||f[n]) return f[n];//判断是否算过这个数，同时0要特判
	int s=1000000;//假定最大值
	while(i<=a[0]&&a[i]<=n)
	{
		s=min(s,1+dfs(n-a[i],i));
		i++;
	}
	f[n]=s;//储存新数字
	return s;
}
int main()
{
	int n;
	scanf("%d",&n);
	if(!n)//因为0=0^4，所以特判输出1
	{
		printf("1");
		return 0;
	}
	init(n);
	printf("%d",dfs(n,1));
	return 0;
}
```

---

## 作者：zhangyuhan (赞：10)

DP里的完全背包变形。

这题的动态转型方程为：

令k为一个数的四次方，且k<i,则：

  f[i]=min(f[i],f[i-k]+1)

我们需要求组成该数的最少四次方数数量，则需要减掉一个数的四次方，这样最起码才能组成一个算式。那么四次方数数量肯定就是上一个最少数量+1（因为还有一个减掉的四次方数）。

附AC代码：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int f[100000],n;
int main()
{
    cin>>n;
    f[0]=0;
    for(int i=1;i<=n;i++)
        f[i]=23647267;//要求最小值，初值要赋较大的数
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i;j++)//从小开始遍历，来通过相减求得最少数
        {
            if(pow(j,4)>i)//如果该数四次方已经大于i，剩下的也不会成立
                break;
            int k=pow(j,4);//pow是属于cmath的一个函数，用来求一个数的n次方
            f[i]=min(f[i],f[i-k]+1);
        }
    }
    cout<<f[n];//输出n的最少四方数的方案
    return 0;
}

```

---

## 作者：RuSun (赞：7)

# 变态背包！！！

## Part I 为什么这是一道背包题

不懂背包的同学看这里[百度百科：背包问题](https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931?fr=aladdin)

其实背包的核心就是处理一个元素取与不取，而这道题中，就是决定一些四次方数取与不取的问题，所以这道题可以用背包做

## Part II 与传统01背包有什么不同

传统01背包中，两个重要的变量就是 价值和代价 以及 总共的重量

而这道题中，其实m就是总共的重量，每个四次方数就是代价，然而——

价值是什么呢

——答案是什么，价值就是什么

所以，这道与01背包不同就是价值不易发现

对于这道题，其实价值就是数的个数

所以dp[i]表示用不超过i的和，可以表示为几个四次方数的和

## Part III 代码如何写

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>//min头文件，其实也可以不要
#include <cmath>//pow头文件 pow（i，j)表示i^j
#include <climits>//INT_MAX头文件
using namespace std;
int dp[100042],m;
int main()
    {
        cin>>m;
        for(int i=1;i<=m;i++)
            dp[i]=INT_MAX;//不要忘记赋最大值
        for(int i=1;pow(i-1,4)<=m;i++)//pow中的i一定要-1，不然跑不完
            {
                int s=i*i*i*i;
                for(int j=s;j<=m;j++)
                    dp[j]=min(dp[j],dp[j-s]+1);
            }
        cout<<dp[m];
    }
```

## Part IV 效率如何

——跑得极快

[测评记录](https://www.luogu.org/record/22588933)

编程语言 
C++

代码长度
473B

用时
61ms

内存
1.14MB

才用了61ms,比dfs一个点的时间都短

---

## 作者：Reanap (赞：7)

#     无脑DP
	
    dp大法好哇！
    我们设dp[i]为将一个整数i分解为n个四次方数的和的n的最小值,所以答案为dp[m]
    而dp[i]来源于一个比它小的数加上一个四次方数
    所以很容易就可以得到递推式：dp[i]=min(dp[i-k^4])(k^4<=i),递推边界为dp[0]=0
    代码如下：
    
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    int dp[100005],m;
    int mi(int x) {return x * x * x * x;} // 方便计算四次方数
    int main() {
        scanf("%d",&m);
        for(int i = 1; i <= m; ++i) { //枚举1~m每个数
            dp[i] = 1e9;		//初始化，因为我们要最小值
            for(int j = 1; mi(j) <= i; ++j) {
                dp[i] = min(dp[i - mi(j)] + 1,dp[i]);//递推式，不解释
            }
        }
        printf("%d",dp[m]);//输出，答案为dp[m]
        return 0;
    }

---

## 作者：OsvaldoAsensioLopez (赞：6)

这题是个完全背包

首先建模：每次选取一个数，以这个数的四次方为体积，以m为总容量，以1位价值，求背包的最大价值，其中每个数字可以使用无线多次（完全背包的标志）。因此我们可以打表，打出1到m四次方根的数字的四次方，然后进行背包

    
    
    
```cpp
    #include <iostream>
    #include <algorithm>
    #include <cmath>
    #include <cstring>
    //完全背包(某个数的四次方可以使用任意多次)，以1为价值,每个四次方数为体积 
    using namespace std;
    int m;
    int four[32];
    int dp[100001];//dp[j]表示取到第i个四次方根,四次方数大小最大为j(容积)的最小个数 
    int main() {
        cin >> m;
        int fi = ceil(sqrt(sqrt(m))+1);//向上取整 
        for(int i=1;i<=fi;i++) {
            four[i]=i*i*i*i;
        }
        fill(dp,dp+100001,1<<30);
        dp[0]=0;
        for(int i=1;i<=fi;i++) {
            for(int j=four[i];j<=m;j++) {
                dp[j]=min(dp[j],dp[j-four[i]]+1);
            }
        }
        cout << dp[m] << endl;
        return 0;
}
```

---

## 作者：XZGgreenpig (赞：5)

此题正解dp，然蒟蒻（fuxiu）做的时候，没有仔细想dp。。。瞪眼感觉数据范围可以纯暴力搜索过，然后，从m开始dfs板子一遍，显然T了。。。
```cpp
void dfs(int x)
{
	if(sum>=minn) 
    	return;
	for(int i=a;i>=1;i--)
	{
		int b=x-i*i*i*i;
		sum++;
		if(b>0) 
        	dfs(b);
		if(b==0)
			minn=min(minn,sum);
		sum--;
	}
}
```
那么，看上去灰常正常的暴力dfs能不能经过混过看似很水的数据呢？  
-b的重复计算问题:开数组解决  
-dfs深度问题：  
&ensp;&ensp;&ensp;&ensp;-当x足够小，特判，直接return，可以解决最后几层的问题  
&ensp;&ensp;&ensp;&ensp;-如果当前sum+当前x/当前i已经大于minn，return  
其实显然可以继续优化，但是这样已经可以过了  
以下代码：
```cpp
#include <cstdio>
#include <algorithm>
//蒟蒻的头文件
using namespace std;
int minn=999999999;
int m,a;
int sum=0;
int four[10001];//四次方数组
void dfs(int x)
{
	if(x<16)
	{
		sum+=x;
		minn=min(sum,minn);
		sum-=x;
		return;
	}
	if(x<81)
	{
		int b=x/16;
		sum+=b+x%16;
		minn=min(sum,minn);
		sum-=b+x%16;
		return;
	}//两个特判
	if(sum>=minn) return;
	for(int i=a;i>=1;i--)
	{
		int b=x-four[i];
		sum++;
		if(sum+x/four[i]>minn) //可行性剪枝
		{
			sum--;
			return;
		}
		if(b>0) dfs(b);
		if(b==0)
			minn=min(minn,sum);
		sum--;
	}
}
int main()//从此开始阅读
{
	scanf("%d",&m);
	for(int i=1;;i++)//预处理
	{
		four[i]=i*i*i*i;
		if(four[i]>=m)
		{
			a=i-1;
			break;
		}
	}
	dfs(m);
	if(!m)
		minn=0;//特判
	printf("%d",minn);
	return 0;
}
```

---

## 作者：发源于 (赞：2)

#[color=red]其实是动归（逃)[/color]

一共17（18？）个数， 100000，完全能开二维数组

每个数取无数次

那不就是刚好取满的完全背包么？

f[i,j]代表取第i大数字，剩下j的最少取法（个数）

代码如下

```delphi

  m:=trunc(sqrt(sqrt(n)));{m是最大取什么}
  for i:=1 to m do
    f[i,0]:=0;{为了刚好取满，所以只有[i,0]赋0，其他赋∞}
  for i:=1 to m do
    begin  
      l:=i*i*i*i;
      for j:=1 to n do
        if j<l then f[i,j]:=f[i-1,j]
          else f[i,j]:=min(f[i,j-l]+1,min(f[i-1,j],f[i-1,j-l]+1));
    end;{背包，不会的自行百度背包九讲}
end.

```

---

## 作者：lych (赞：2)

可以说，这道题目的数据很弱，因为n小于100000，同时又是求4次方，所以如楼上所说，直接搜索即可过掉n=100000的情况

但是如果n是10000000，或者求2方，搜索明显超时

因此，题意已经十分明显，那就是动态规划！

首先讲一下每个变量表示的含义

用s数组存储i^4，用f表示n=x时，需要的最少个数

转移方程为f[x]:=min(f[x],f[x-s[i]]);

接下来给出标程：

```cpp
var
  n,m,i,j:longint;
  f,s:array[0..200000] of longint;
begin
  read(n);
  while s[i]<n do
    begin
      inc(i);
      s[i]:=sqr(sqr(i));
    end;//求出需要用的所有i^4
  m:=i;
  fillchar(f,sizeof(f),$7f div 3);//把数组赋大值
  f[0]:=0;//递归边界，非常重要！
  for i:=1 to n do
    for j:=1 to m do
      if s[j]>i then break else//如果比所求值大了，就直接退出，也防止了越位
        if f[i-s[j]]+1<f[i] then
          f[i]:=f[i-s[j]]+1;//更新最小值
  writeln(f[n]);
end.
```

---

## 作者：傅思维666 (赞：1)

### 很好的01背包，有一定量的思维含量。

首先定义状态为dp[i]=j表示装满容量为i的背包所需j个数，如果这里看不懂的话，可以这么写：dp[i]表示分成j个数后能装满容量为i的背包。

然后这道题就可以切了...且慢！！

物品体积呢？？？

### 啊，别急啊，打表就好了。

我打的是20的4次方的表，事实证明到18就超了。

再注意一下细节，因为取小，所以初值要都设置成极大值，并且，初值dp[0]一定要置成0。

所以这题就AC了。

代码如下：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int m;
int v[19]={1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65536,83521};
int dp[100001];
int main()
{
    scanf("%d",&m);
    memset(dp,0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=0;i<=17;i++)
        for(int j=v[i];j<=m;j++)
            dp[j]=min(dp[j],dp[j-v[i]]+1);
    printf("%d",dp[m]);
    return 0;
}
```


---

## 作者：Skyworld (赞：1)

1、按之前的总分降序排序

2、扫描每个队员，看加上最后一次成绩是否高于其他选手的最大值

3、第二步的时候可以证明其他选手最终成绩的最大值就是之前排第一的选手的成绩+1。因此每次只要判断b[i]+n是否大于等于b[0]+1即可判断b[i]有没可能夺冠。证明如下：

  证明：b[0]+1是最后一轮后排在b[i]前的选手总分的最大值。

  因为b[0]是当前最大值，要想b[i]成为冠军，只有b[i]成为最后一轮第一， 并且排在b[i]前面的选手加分后都比b[i]+n小（排在b[i]后的选手最后一轮得分低于b[i]不可能超过b[i])。要想让原先排在b[i]前面的选手得分尽量的低，必须让每个选手最后一轮得分都取最小值，即第一名在最后一轮排到了最后一名（此时它总分最低），第二名在最后一轮排到倒数第二，以此类推。

  因此，原先0..j(j<i)的所有选手在最后一轮后的总分为：b[0]+1,b[1]+2,...,b[j-1]+j,b[j]+j+1。由于b[j-1]>b[j]，可知b[j-1]>=b[j]+1，故b[j-1]+j>=b[j]+j+1。

  因此在最后一轮后排在b[i]前的选手的总分的最大值是b[0]+1。

最终AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
  int n,b[900000],i,j,t,count=0;
  //读入
  cin>>n;
  for(i=0;i<=n-1;i++)
    cin>>b[i];
  //排序--降序
  sort(b,b+n,greater<int>());
  //循环遍历
  for(i=0;i<=n-1;i++)//判断b[i]是否可以是第一名
    {
      t=b[i]+n; 
      if(t>=b[0]+1) count++;
	} 
  cout<<count;
  return 0;
}
```




---

## 作者：深海鱼的眼泪 (赞：1)

完全背包，改成取最大值，每个物品价值为1。记得f[0]=0。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int f[100010],a[20];
int main(){
    int m,n,i,j,x;
    cin>>m;
    memset(f,-1,sizeof(f));
    for (i=1;i<=19;i++){
        a[i]=i*i*i*i;
        if (a[i]>=m) {
            x=i;
            break;
        }
    }
    f[0]=0;
    for (i=1;i<=x;i++){
        for (j=a[i];j<=m;j++){
            if (f[j-a[i]]!=-1&&(f[j]>f[j-a[i]]+1||f[j]==-1)) f[j]=f[j-a[i]]+1;
        }
    } 
    cout<<f[m];
    return 0;
}
```

---

## 作者：野菜汤 (赞：1)


```delphi
var i,k,min,sum,max,j:longint;
    a:array[1..18] of longint;
procedure dg(o,oo,ooo:longint);{三个变量}
var i,k:longint;
begin
  if o=min then begin{如果当前的值成为答案了，那么如果所用次数更少，那么记录}
     if oo<sum then sum:=oo;exit;end;
  if oo>sum then exit;{如果当前次数超过之前所记录的次数那么就退出}
  if o>min then exit;{如果当前值超过标准值那么退出}
  for i:=ooo downto 1 do
    dg(o+a[i],oo+1,i);
end;
begin
  read(min);
  for i:=1 to 17 do a[i]:=i*i*i*i;
  sum:=maxlongint;
  dg(0,0,17);
  write(sum);
end.
**[color=red]题解：[/color]**

    [color=fuck]本题可以直接使用搜索水过，不过需要些许优化。以下是解题思路[/color]

    **[color=green]因为数据范围的原因，所以最大只能是17的四次方，所以先对a数组赋值1~17的四次方，然后对情况进行模拟。因为这种题的大致思路是从大的数往下加，所以呢优化的内容就是在搜索的过程中加入一个记录当前所加的数的变量，然后从这个变量开始往下循环搜索。这样虽然会有用时过多，但依然可以ac[/color]**

```

---

## 作者：agicy (赞：1)

# 思路

通过使用计算器可得，光是$18^4=104,976$就超过了$m$的最大值$100,000$，所以这道题我们完全可以使用
**打表+深搜**
来解决。

**注**：打表即$1$~$20$这些数的四次幂。

# 代码

代码如下。

```cpp
#include<stdio.h>//头文件
bool flag=false;//记录是否得出答案
int m,pow[20]=
{
0    ,1    ,16   ,81    ,256   ,
625  ,1296 ,2401 ,4096  ,6561  ,
10000,14641,20736,28561 ,38416 ,
50625,65536,83521,104976,130321
},n;//pow[20]为打的表

void DFS(int d,int last,int sum){//d为搜索深度，last为上一次选用的数，sum为当前的和
	if(d>n)//超出当前限定，返回
		return;
	for(int i=last;i<=19;i++){//因为上次肯定已经搜索过比last小的数了，所以无需枚举last之前的值
		if(sum+pow[i]<m){//如果当前值加上待选数的四次幂小于m，则继续搜索
			DFS(d+1,i,sum+pow[i]);
		}
		else if(sum+pow[i]==m){//如果当前值加上待选数的四次幂等于m，则停止搜索，标记答案已经出现
			flag=true;
			break;
		}
		else//如果当前值加上待选数的四次幂大于m，则不可能得出结果，停止搜索
			break;	
	}
	return;
}

int main(void){
	scanf("%d",&m);
	for(int i=1;i<=20;i++){
		n=i,DFS(1,0,0);//从1~20枚举答案
		if(flag)//找到答案
			return printf("%d",n),0;//输出并结束
	}
	return 0;
}
```

---


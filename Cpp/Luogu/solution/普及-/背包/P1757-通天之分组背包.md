# 通天之分组背包

## 题目背景

直达通天路·小 A 历险记第二篇


## 题目描述

自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$ 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。

## 说明/提示

$0 \leq m \leq 1000$，$1 \leq n \leq 1000$，$1\leq k\leq 100$，$a_i, b_i, c_i$ 在 `int` 范围内。

## 样例 #1

### 输入

```
45 3
10 10 1
10 5 1
50 400 2```

### 输出

```
10```

# 题解

## 作者：唐一文 (赞：227)

正如题目名所说，这是一道分组背包的题

只要在板子上改动一点：求背包的组数（直接在输入时求就行了）

板子的输入：
```cpp
for(i=1;i<=n;i++){
    cin>>w[i]>>z[i]>>x;      //x表示第i个物品的小组编号
    b[x]++;      //小组x的物品+1
    g[x][b[x]]=i;      //g[i][j]表示存储小组i中的第j个物品的编号
}
```
**改动后**的输入：
```cpp
for(i=1;i<=n;i++){
    cin>>w[i]>>z[i]>>x;
    t=max(t,x);      //求小组组数
    b[x]++;
    g[x][b[x]]=i;
    }
```
本题**精髓**：
```cpp
for(i=1;i<=t;i++){      //小组
    for(j=v;j>=0;j--){      //容量
        for(k=1;k<=b[i];k++){      //小组中的物品
            if(j>=w[g[i][k]]){      //小组i中物品k的容量
                dp[j]=max(dp[j],dp[j-w[g[i][k]]]+z[g[i][k]]);      //状态转移方程
            }
        }
    }
}
```
无注释的完整代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int v,n,t;
int x;
int g[205][205];
int i,j,k;
int w[10001],z[10001];
int b[10001];
int dp[10001];
int main(){
    cin>>v>>n;
    for(i=1;i<=n;i++){
        cin>>w[i]>>z[i]>>x;
        t=max(t,x);
        b[x]++;
        g[x][b[x]]=i;
    }
    for(i=1;i<=t;i++){
        for(j=v;j>=0;j--){
            for(k=1;k<=b[i];k++){
                if(j>=w[g[i][k]]){
                    dp[j]=max(dp[j],dp[j-w[g[i][k]]]+z[g[i][k]]);
                }
            }
        }
    }
    cout<<dp[v];
    return 0;
}
```

---

## 作者：北凌scoffs (赞：124)

```c
#include<bits/stdc++.h>
using namespace std;
int n,m;
int w[100005],via[100005],x;
int dp[1005][1005];
int d[1000005];
int f[10000005];
int num=0,r;//用来记录最大的组数下标
int main() {
	//发题解其实就是“费曼学习法”的一种形式吧
	//分组背包罢了，其实就是01背包的变形-----
	scanf("%d%d",&m,&n,&r);//正常输入
	for(int i=1; i<=n; i++) {
		scanf("%d%d%d",&w[i],&via[i],&x);//正常输入
		num=max(x,num);//因为我的组数肯定是从1~y（y未知）
		//这里一直打擂台，到最后就可以求到最大的值，即 y的值
		++d[x];//表示第几组一共有几种物品
		//eg：假如输入----1 1 1---d[1]++---d[1]==1;
		//----------------2 2 1---d[1]++---d[1]==2;
		//----------------3 3 1---d[1]++---d[1]==3;
		//所以说 在这里的假设样例里第一组就有三个，是不是清晰明了
		dp[x][d[x]]=i;//第x组背包的第几种的物品的下标啊啊啊
		//又来假设吧
		//eg:假设---i=1时,1 1 1--d[1][1]=1;
		//----------i=2时,2 2 1--d[1][2]=2;
		//----------i=3时,3 3 1--d[1][3]=3;
		//还是刚刚那个 ,不懂的话可以自己再推一推
	}
	for(int k=1; k<=num; k++) {//我一共顶死了num组分组啊,num已经求解了啊
		for(int j=m; j>=0; j--) {//其实就是01背包模板，只是因为这里的w[]的下标需要
			//调用dp[][]来得到...所以我们要在下面来写条件---来一个传送门，dp传送
			for(int i=1; i<=d[k]; i++) {
				int px=dp[k][i];
				if(j>=w[px])//其实就是一个01背包，传送门的接口
					//传送的两端合起来就相当于-->-->
					// for(int j=m;j>=w[px];j++)标准01背包的模板就来了
					f[j]=max(f[j-w[px]]+via[px],f[j]);//只能取一次嘛，所以倒着来
				//其实顺着来也可以，来看一下吧
				//for(int k=1;k<=num;k++)
				//for(int j=0;j<=m;j++)
				// for(int i=1;i<=d[k];i++)
				// {	int px=dp[k][i];
				//    if(j+w[px]<=m){//不能超出范围吧
				//f[j]=max(f[j+w[px]+via[px],f[j])
				//	}
				//	}
				//大概就这样吧，毕竟没有编译。。。可能有语法错误，但是思路是这样子的
				// 但是这样的话最后的答案输出是(f[0])
			}
		}
	}
	cout<<f[m];
	//cout<<f[0]--->这是第二种打发。。。
	//小结一波---其实这道题主要是最开始的一波秀操作
	//剩下的就是完完全全的一波01背包模板的。。然后有两种打发
	//一道如此简单的模板分组背包竟然打了这么多，是不是觉得我很sb
	//其实这叫“费曼学习法”自己百度吧，非常有效，其实这也是发题解的真谛吧
	return 0;
}
```


---

## 作者：良知 (赞：78)

真心不知道楼下写题解的大佬们为什么不压空间（~~精益求精嘛~~）

01背包大家都会吗?(不会请回去自习)
 
别别别，回来回来!给初学者们一个~~福利~~

```
注释就不写了，都看懂了吧
Zero_One_Pack：
#include<iostream> 
#include<cmath> 
#include<algorithm> 
int m,t,w[101],c[101],dp[1001]; 
using namespace std; 
int main() 
{ 
    cin>>t>>m; 
    for (int i=1;i<=m;i++) cin>>w[i]>>c[i]; 
    int maxx=0; 
    for (int i=1;i<=m;i++) 
    { 
        for (int j=t;j>=w[i];j--)  //重点
        { 
            dp[j]=max(dp[j],dp[j-w[i]]+c[i]); 
            if (dp[j]>maxx) maxx=dp[j]; 
        } 
    } 
    cout<<maxx<<endl; 
    return 0; 
}

Complete_Pack:
#include<iostream>  
#include<cmath>  
#include<algorithm>  //我无聊 
int m,t,w[11001],c[11001],dp[11001];  
using namespace std;  
int main()  
{  
    cin>>t>>m;  
    for (int i=1;i<=m;i++) cin>>w[i]>>c[i];  
    int maxx=0;  
    for (int i=1;i<=m;i++)  
    {  
        for (int j=w[i];j<=t;j++)   
        {  //调换循环顺序，可以自己手推一下 （重点）
            dp[j]=max(dp[j],dp[j-w[i]]+c[i]);  
            if (dp[j]>maxx) maxx=dp[j];  
        }  
    }  
    cout<<maxx<<endl;  
    return 0;  
}

```

# 上正题


我们可以根据《背包九讲》里的讲解得到如下代码：
```
#include<iostream>
using namespace std;
int f[10001],n,m,w[1001],c[1001],a[101][1001];
int main(){
    cin>>m>>n;int maxx=0;
    for(int i=1,k;i<=n;i++){
        cin>>w[i]>>c[i]>>k;
        a[k][++a[k][0]]=i;
        maxx=max(k,maxx);
    }
    ......
``` 

但如果数据再大点呢?
## MLE

so...

对了，降维是一个有效解决此类问题的办法!

滚动数组？可以可以，但有没有更好的办法呢?

### 有！

我们可以从上面的01背包中获得启示，当前状态的更优解
###### 只会从前面来

所以

dp[105][1005]->dp[2][1005]->dp[1005]!
##### 妈妈再也不用担心我的内存！


上代码：
```#include<bits/stdc++.h>
/*1<=m<=1000 1<=n<=1000 组数t<=100*/  //好习惯
int dp[1005],w[1005],c[1005],g[1005]; //没骗你，是一维，dp[j]表示背包内物品为j时获得的的最大价值
using namespace std;
int main(){
	int n,m;
	scanf("%d%d",&m,&n);
	int group=-1;
	for(int i=1;i<=n;++i){
		scanf("%d%d%d",&w[i],&c[i],&g[i]);
		group=max(group,g[i]);
	}//输入确定组数
	for(int i=1;i<=group;++i){//枚举组
		for(int j=m;j>=0;--j){//枚举重量（非常巧妙地避开了相互冲突，自己手推才会更好理解）
			for(int k=1;k<=n;++k){//枚举物品
				if(g[k]!=i||j<w[k])continue;//装不下
				dp[j]=max(dp[j],dp[j-w[k]]+c[k]);//见《背包九讲》
			}
		}
	}
	printf("%d\n",dp[m]);//输出answer
	return 0;//请勿抄袭
}```

总之，背包就是列表法，把表列出来了，什么混合背包，分组背包，多重背包，一点也~~不难~~。

---

## 作者：名杨天吓 (赞：20)

背包题的套路都差不多，稍微处理一下就好了。AC只需要以下几个步骤。
1、数据预处理，将物品分组存放
2、开始dp
	（1）枚举组数
    （2）枚举背包空间大小（从大到小，和01背包一样）
    	（3）在这一层枚举这一组的物品，放或不放。
	状态转移方程：
```cpp
	if(j>=group[i][k].w)
    	     f[j]=max(f[j],f[j-group[i][k].w]+group[i][k].v);
```
如果能放得下，那么就比较一下放和不放哪个价值大。
然后就是这题的重点。就是怎么处理一组物品不重复放。其实很简单，只需要把枚举组中物品的循环放到枚举背包大小的循环下就行了。因为背包dp需要背包空间大小循环完一遍才能表示把一个物体放进去了。而在循环背包空间的过程中枚举物品，就相当于只放一种物品。
最后贴上AC代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1010;
struct node
{
    int w,v;
}group[maxn][maxn];
int num[maxn],f[maxn];
int m,n,maxl=INT_MIN;
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
        {
            int tw,tv,tg;
            scanf("%d%d%d",&tw,&tv,&tg);
            group[tg][++num[tg]].w=tw;
            group[tg][num[tg]].v=tv;
            maxl=max(maxl,tg);
        }
    for(int i=1;i<=maxl;i++)
        if(num[i])
            for(int j=m;j>=0;j--)
                for(int k=1;k<=num[i];k++)
                    if(j>=group[i][k].w)
                        f[j]=max(f[j],f[j-group[i][k].w]+group[i][k].v);
    printf("%d\n",f[m]);
    return 0;
}
```


---

## 作者：JK_LOVER (赞：16)

基本思路是搜索；
用了dp的思想，见代码。
若有疑问欢迎提问
```cpp
/*
本质上动态规划和记忆化搜索是一样的；
都是已知某一个状态的最优状态得出当前状态； 
so即使这题是分组背包，一样可以搜索；
只是多加一个组数的判定 
用了极其朴素的回溯算法的；
见代码吧
代码不长，可以食用 
*/
#include<bits/stdc++.h>
using namespace std;
struct node{
	int t;
	int v;
	int zu;
}e[1010];//每个物品的花费，收益，组数 
bool pd[110];//判定组数是否出现 
int dp[1010];//存结果的 
int m,n;//如题 
int dfs(int x)//记忆化搜索 
{
	if(dp[x]>0) return dp[x];// 主体 
	for(int i=1;i<=n;i++)
	{
		if(pd[e[i].zu]) continue;
		pd[e[i].zu]=true;
		if(x>=e[i].t)
		dp[x]=max(dp[x],dfs(x-e[i].t)+e[i].v);
		pd[e[i].zu]=false;//回溯 
	}
	return dp[x];
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	cin>>e[i].t>>e[i].v>>e[i].zu;//输入 
	for(int i=m;i>=1;i--)
	dp[i]=dfs(i);//01背包的板子 
	cout<<dp[m]<<endl;
	return 0;//结束 
}
```
基本就是用记忆化来调用上种情况的状态来解决当前状态。
有不懂欢迎提问。

---

## 作者：Substitute0329 (赞：14)

不得不说，这其实就是01背包精华版！！（题目有间接表明）
## 题目：[P1757](https://www.luogu.org/problemnew/show/P1757)
------------
步骤：
 
       1.第 i 个组第 j 的物品的价值存储在数组 w[i][j] 中，把其价值存储在数组 c[i][j] 中， c、w 均为二维数组。
       2.推出状态转移方程，这是重点。
       3.程序实现。
------------
## 状态转移方程怎么推？这是一个好问题。
       从题目不难发现每一组物品都互相排斥，这是一个重要条件。  
	   所以，我们需要一个变量i来循环组数，把每一组中的物品都当作01背包一样操作。
       最后dp数组中，dp[maxn][V] 即为取到第maxn组，背包总容量为 V 的dp值，就是最终的答案。
------------
也就是这样：

		1<=i<=maxn            //maxn是最大组数
        	0<=j<=n[i]            //n[i]为第 i 组的物品数量，因为可以不拿第 i 组的物品，所以 j 的下标从0开始循环。
        		V>=k>=c[i][j] //V为背包容量。
                dp[i][k]=max(max()
            	
```cpp
include<bits/stdc++.h>
using namespace std;
int V,N,n[101],w[101][1001],v,w1,p,dp[101][1001],c[111][1001],maxn=0;
inline int read(){                                       //inline卡常
    int x=0;                                             //读入优化
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x;
}
inline int max(int x,int y){return x>y?x:y;}             //手打的max函数更快。
int main(){
    V=read();N=read();
    for(register int i=1;i<=N;i++){                      //register卡常
        v=read(),w1=read(),p=read();                     
        c[p][++n[p]]=v;                                  //存入
        w[p][n[p]]=w1;                                   //存入
        maxn=max（maxn,p）；                                //去最大组号作为组数
    }
    for(register int i=1;i<=maxn;i++)               //状态转移
        for(register int j=0;j<=n[i];j++)
            for(register int k=V;k>=c[i][j];k--)
            dp[i][k]=max(dp[i-1][k],max(dp[i-1][k-c[i][j]]+w[i][j],dp[i][k]));
    printf("%d\n",dp[maxn][V]);                          //输出
//	printf("\n")；
//	for(register int i=1;i<=T;i++){
//		for(register int j=0;j<=n[i];j++)
//		printf("%d ",c[i][j])；
//		printf("\n");
//	}
    return 0；                                            //手打return 0;    养成好习惯。
}
```


------------
请不要复制题解，已作防抄袭处理。
------------
求过

---

## 作者：EarthGiao (赞：10)

这道题像极了模板担又不叫模板

只要是学过分组背包的这道题都是可以按这模板打出来的

如果你是按一本通上那个打的模板，那只需要改一丢丢的的地方就可以	AC 了

分组背包其实还是很简单的，不同于前面几个更简单的地方就是

```cpp
		cin>>zhong[i]>>jia[i]>>zu;
		a[zu][0] ++;//计数  记录该组最多能够有多少物品
		a[zu][a[zu][0]] = i;//记录下标 
		mxzu = max(mxzu,zu);//比较找最大的那个
```
用一个二维数组记录这是该分组里面的第几个并且记录下标，还用a[i][0]记录这个组里面有几个，因为0是用不到的所以可以用来计算，还省得再开一个数组计数

这里就是那个和模板不同的地方了，模板里给了最多有几个组，但是在这里你需要自己比较着找

然后就是三重循环了

i是枚举每一个组的，j是枚举每一个重量的，k是枚举每个组里面每一个数的，知道了这些这就是很好懂得了，后面那个递推关系式和前面几个没差距不多说了

```cpp
for(int i = 1;i <= mxzu;++ i)
		for(int j = n;j >= 0;j --)
			for(int k = 1;k <= a[i][0];++ k)
				if(zhong[a[i][k]] <= j)//确保不超出范围 
					bb[j] = max(bb[j],bb[j - zhong[a[i][k]]] + jia[a[i][k]]);//比较找最大的更新
```


完整代码

```cpp
#include<iostream>
#include<queue>
#include<iomanip>
#include<cstdio>
#include<algorithm>
#include<stack>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<string>
#include<map>
#include<set>

using namespace std;

int zhong[1001],jia[1001],a[1001][1001],bb[1001];//物品的重量 价值 记录分组 背包 

int main()
{
	int n,m,zu,mxzu = 0;//找一共有多少个分组 
	cin>>m>>n;
	for(int i = 1;i <= n;++ i)
	{
		cin>>zhong[i]>>jia[i]>>zu;
		a[zu][0] ++;//计数  记录该组最多能够有多少物品
		a[zu][a[zu][0]] = i;//记录下标 
		mxzu = max(mxzu,zu);//比较找最大的那个 
	}
	for(int i = 1;i <= mxzu;++ i)
		for(int j = m;j >= 0;j --)
			for(int k = 1;k <= a[i][0];++ k)
				if(j >= zhong[a[i][k]])//判断是否越界 
					bb[j] = max(bb[j],bb[j - zhong[a[i][k]]] + jia[a[i][k]]);//比较找最大的然后更新 
	printf("%d\n",bb[m]);
	return 0;
}
```


---

## 作者：二哥啃菜包 (赞：10)

一看你们咋么可以欺负新来的小朋友呢？都这么不友好，我来发一篇正序枚举的滚动优化造福人类一下。

首先伪代码可以参见YZC大佬，那么我们怎么理解滚动优化呢，为什么要这样枚举捏？

我们先介绍正常做法从j-v[]转移

### 我们考虑一下（我画张图）：
j表示容量，v表示重量（体积）

首先我们有：首先我们有j，j-v[]，j-2*v[]]

然后来考虑转移？？？（抓脑袋，若我们顺序（从小到大）枚举）是这样的：
![](http://images.cnblogs.com/cnblogs_com/JCNL666/1434484/o_aaaaa.PNG)

(j后面的是未被当前物品更新的)

啊呀，好像一个物品被多次取了，啊啊啊啊尴尬，这不是完全背包了吗？
为什么会这样呢，因为前一个j-v[]已经取过i了，然而我们又取了他一次，这不违背题意了吗？

不行不行，我们重新倒着枚举：

![](http://images.cnblogs.com/cnblogs_com/JCNL666/1434484/o_bbbbb.PNG)
这样我们保证从没有被取过得j-v[]转移来，这不就只取了一次了吗？

那么答案就是f[m]因为他是最早被枚举的，所以考虑完所有的物品。
棒棒棒棒棒棒！


那么非正常做法是什么呢？

诶嘿就是j+v[]转移过来。

我先假设你们都知道怎么写二维的非正常做法，那我们来优化他一下，也滚一滚存起来

首先还是正序枚举j，应该是这样的：
![](http://images.cnblogs.com/cnblogs_com/JCNL666/1434484/o_ccccc.PNG)

诶这还像直接就是对的耶？

哎被发现了，没错可以直接0 to m枚举，因为保证后面未被更新，不会违背题意。答案f[0]

那么另一张图我就不画了。接下来将怎么实现非正常的分组背包

先上代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n=0,m=0,ans=0,num=0;
const int N=1010;
const int M=110;
int d[M],v[N],w[N],dd[M][N],f[N];//dd是该组中的成员，d为该组个数
int main(){
	std::ios::sync_with_stdio(false);//这个是个关流同步，加快cin，cout的好办法
	cin>>m>>n;
	for(int i=1;i<=n;++i){
		int a=0;
		cin>>v[i]>>w[i]>>a;
		num=max(num,a);//智慧地取出组数
		++d[a];//先加该组个数
        dd[a][d[a]]=i;//再存储
	}
	
	for(int k=1;k<=num;++k)for(int j=0;j<=m;++j)for(int i=1;i<=d[k];++i){
		int oo=dd[k][i];//从0到m枚举保证正确性
		if(j+v[oo]<=m)f[j]=max(f[j],f[j+v[oo]]+w[oo]);
        //毕竟要防止超出背包上限，倒着枚举的正常做法特判是为了防止下标越界
	}
	cout<<f[0]<<endl;//答案为f[0]
	return 0;
}
```
$update$:2019,6.2 图床崩裂问题

---

## 作者：谭之荔 (赞：7)

#### 分组背包

#### 大体格式
v[i]是重量，V是总重量，f是前i个j重量的价值，w是每个的价值
```
for(int i=1;i<=m;i++)
	for(int k=v[i];k<=V;k++)
		for(int j=0;j<=n[i];j++)
			f[i][k]=max(f[i][k],f[i-1][j-v[i][j]]+w[i][j])；
```

#### 代码如下
```
#include<iostream>
#include<cstdio>
using namespace std;
int c[1005],f[1005][1005],a[1005][1005],d[1005][1005]; 
int main()
{
	int n,m,mq=0;
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	{
		int o,p,q;//o 是 物品重量，p是利用价值，q是组 
		cin>>o>>p>>q;
		if(mq<q) mq=q;//找出最大组，即共有多少个组 
		c[q]++;//每个组的第几个元素 
		d[q][c[q]]=o;//q 组的c[q]个元素的重量是 o 
		a[q][c[q]]=p;
	}
	for(int i=1;i<=mq;i++)//mq是共有多少个组 
	{
		for(int k=1;k<=c[i];k++)//k是组里的元素 
		{
			for(int j=m;j>=d[i][j];j--)//一定要从大到小，避免一个元素多次用 
			{
				if(j-d[i][k]>=0)  
				f[i][j]=max(f[i][j],f[i-1][m-j]+a[i][k]);//f是前i个数j重量的价值 
			}
		}
	}
	int maxx=0;
	for(int i=1;i<=mq;i++)//找出最大 
	{
		for(int j=1;j<=m;j++)
		{
			if(f[i][j]>maxx) maxx=f[i][j];
		}
	} 
	cout<<maxx;
}
```
p有不理解的旁边评论


---

## 作者：Smallbasic (赞：7)

  简单的分组背包           
 
 直接枚举每个组，再在每个组里进行01背包就可以了。（~~本人第一次写题解，用结构体实现，代码很丑，dalao勿喷~~）
  ```c++
#include<bits/stdc++.h>
using namespace std;
struct thing{
	int value;
	int weight;
}a[1001];
struct group{
	thing element[1001];
	int top=0;
	void push(thing a){
		top++;
		element[top]=a;
	}
}g[101];
int main(){	
    int n,lim;
    cin>>lim>>n;
    int m=0;
    int b[1001];
    memset(b,0,sizeof(b));
    for(int i=1;i<=n;i++){
    	int z;
    	cin>>a[i].weight>>a[i].value>>z;
    	g[z].push(a[i]);
    	if(b[z]==0){
    		m++;;
		}
    	b[z]=1;
	}
	int f[lim+1];
	memset(f,0,sizeof(f));
	for(int i=1;i<=m;i++){
		for(int k=lim;k>=0;k--){
			for(int j=g[i].top;j>=1;j--){
				if(k>=g[i].element[j].weight && f[k]<f[k-g[i].element[j].weight]+g[i].element[j].value){
					f[k]=f[k-g[i].element[j].weight]+g[i].element[j].value;
				}
			}
		}
	}
	cout<<f[lim];
	return 0;
}
```

---

## 作者：远航之曲 (赞：7)

还没有c++的代码，果断来一发题解


简单的分组背包。。看dd的背包九讲被坑了。。。他的方法是错的。。。（循环写错了


动态转移方程 f[j]=max(f[j],f[j-w[k][i]]+c[k][i]);


（减少代码复制，创建美好洛谷）


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int f[1000],w[101][10000],c[101][10000],a[101];
int main()
{
    int m,n,t=0,i,j,k,x,y,z;
    cin>>m>>n;
    for(i=1;i<=n;i++)
    {    
        cin>>x>>y>>z;
        if(z>t) t=z;
        a[z]++;
        w[z][a[z]]=x;
        c[z][a[z]]=y;
    }
    for(k=1;k<=t;k++)
      for(j=m;j>=0;j--)
        for(i=1;i<=a[k];i++)
          if(j>=w[k][i])
          {
            f[j]=max(f[j],f[j-w[k][i]]+c[k][i]);
          }
    cout<<f[m]<<endl;
    return 0;
}
```

---

## 作者：Undefined_Myth (赞：6)

这个题目是一个裸的分组背包问题，在for循环中我们注意要v在i的外面，以保证一个组中要么选一个要么不选。

因为我们是通过枚举物品来向v转移，v是不变的，变的是物品的品种，并且，最终只会转移一个所以就保证了分组背包的原则。

是不是很神奇？？？

神不神奇？意不意外？惊不惊喜？啊？

```cpp
//当我没说
#include<cstdio>
#include<cstdlib>
//#include<algorithm>
using namespace std;
#define INF 100+5
const int MAXN=1000+5,MAXV=1000+5;
int max(int a,int b)
{
    return a>b?a:b;
}
int V,N,T;
int w[MAXN+1],c[MAXN+1];//重量、价值 
int num[INF+1][MAXN+1];//用来记录编号的数组，按照输入的顺寻调用所对应的w、c 
int dp[MAXV];//dp[v]花费费用v能够取得的最大权值 //是为，而不是不超过 
int main() 
{
    int p;
    scanf("%d%d",&V,&N);
    for(int i=1;i<=N;i++)
    {
        scanf("%d%d%d",&w[i],&c[i],&p);
        num[p][++num[p][0]]=i;//巧妙的运用a[p][0]来计数!! 
        //注意这里的i也是一种编号按照输入的顺序来得到方便之后状态转移的时候来调用 
        T=max(T,p);
    }
    for(int k=1;k<=T;k++)
        for(int v=V;v>=0;v--)//可以>=1因为都是非负的 
            for(int i=1;i<=num[k][0];i++)
                if(v>=w[num[k][i]])
                    dp[v]=max(dp[v],dp[v-w[num[k][i]]]+c[num[k][i]]);
    printf("%d",dp[V]);
        return 0; 
}
```

---

## 作者：梅心 (赞：4)

仔细一看是个分组背包的模板题，我来讲一下分组背包的思路：
因为每个小组只能取一个物品，所以我们可以把每个小组看成一个01背包
最重要的代码：
```
for(int i = 1; i <= n; i++)//小组 
{
	for(int j = v; j >= 0; j--)//重量 
	{
		for(int k = 1; k <= tot[i]; k++)//小组中的物品 
		{
			if(j >= w[group[i][k]])
			{
				dp[j] = max(dp[j], dp[j - w[group[i][k]]] + val[group[i][k]]);//状态转移方程	 
			}
		}
	}
}
```
其次重要的代码：
```
for(int i = 1; i <= n; i++)
{
	cin >> w[i] >> val[i] >> x;//x表示第i个物品的小组最大编号 
	t = max(t, x);
	tot[x]++;//小组x的物品数量+1 
	int y = tot[x];
	group[x][y] = i;//group[i][j]存储小组i中的第j个物品的编号 
}
```
整个代码：
```
#include<bits/stdc++.h>
using namespace std;
int v, x, n, t;
int dp[1005], val[1005], w[1005];
int tot[1005], group[1005][1005];
int main()
{
	cin >> v >> n;//输入最大重量和数量 
	for(int i = 1; i <= n; i++)
	{
		cin >> w[i] >> val[i] >> x;//x表示第i个物品的小组最大编号 
		t = max(t, x);
		tot[x]++;//小组x的物品数量+1 
		int y = tot[x];
		group[x][y] = i;//group[i][j]存储小组i中的第j个物品的编号 
	}
	for(int i = 1; i <= n; i++)//小组 
	{
		for(int j = v; j >= 0; j--)//重量 
		{
			for(int k = 1; k <= tot[i]; k++)//小组中的物品 
			{
				if(j >= w[group[i][k]])
				{
					dp[j] = max(dp[j], dp[j - w[group[i][k]]] + val[group[i][k]]);//状态转移方程
					 
				}
			}
		}
	}
	cout << dp[v];//输出 
	return 0;
} 
```

---

## 作者：万弘 (赞：3)

这里介绍一种比较好想的方法，记忆化搜索的

1.开一个a[x][i]存储第x组第i件物品的重量和价值

f[x][m]存储最优收益（就是01的思路）

len[x]存储第x组的物品数

```cpp
typedef long long ll;
struct one
{
	ll v,w;
}a[101][1001];
ll f[1001][1001],len[101];
ll n,m;
```
你是不是觉得sou easy?

2.输入

```cpp
scanf("%lld%lld",&m,&n);
ll v,w,k;
for(ll i=1;i<=n;++i)
{
	scanf("%lld%lld%lld",&v,&w,&k);
	a[k][++len[k]]=(one){v,w};//强制类型转换的高级应用
}
```
3.dfs
```cpp
ll dfs(ll x,ll m)
{
	if(f[x][m])return f[x][m];//记忆化
	if(x>100)return 0;//最多100组
	ll res=dfs(x+1,m);//不取（res用来避免多次高维数组寻址）
	for(ll i=1;i<=len[x];++i)
	{
		if(m<a[x][i].v)continue;
		res=max(res,dfs(x+1,m-a[x][i].v)+a[x][i].w);//哪个更优
	}
	return f[x][m]=res;
}
```

最后完整代码奉上

```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
struct one
{
	ll v,w;
}a[101][1001];
ll f[1001][1001],len[101];
ll n,m;
ll max(ll a,ll b)
{
	return a>b?a:b;
}
ll dfs(ll x,ll m)
{
	if(f[x][m])return f[x][m];
	if(x>100)return 0;
	ll res=dfs(x+1,m);
	for(ll i=1;i<=len[x];++i)
	{
		if(m<a[x][i].v)continue;
		res=max(res,dfs(x+1,m-a[x][i].v)+a[x][i].w);
	}
	return f[x][m]=res;
}
int main()
{
	scanf("%lld%lld",&m,&n);
	ll v,w,k;
	for(ll i=1;i<=n;++i)
	{
		scanf("%lld%lld%lld",&v,&w,&k);
		a[k][++len[k]]=(one){v,w};
	}
	printf("%lld",dfs(1,m));
	return 0;
}
```

---

## 作者：Bitter_ (赞：2)

分组背包，即每个组中的物品不能选1次以上。

所以，我们对于题目中的每个组的物品一一编号。

先定义一个变量求出总组数。

然后枚举组数。

对于每一组都跑一边01背包。

但是要注意，$for$的顺序不能有误。

先枚举组数，再枚举体积，最后枚举编号。

这样才能保证组内的物品只被选择一次。

$Code:$
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,dp[10000],w[10000],c[10000],id[500][500],cnt[10000];
int maxn=-100;
int main(){
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d%d%d",&w[i],&c[i],&x);
		maxn=max(maxn,x);
		cnt[x]++;
		id[x][cnt[x]]=i;
	}
	for(int i=1;i<=maxn;i++)
		for(int j=m;j>=0;j--)
			for(int k=1;k<=cnt[i];k++)
				if(j>=w[id[i][k]])
					dp[j]=max(dp[j],dp[j-w[id[i][k]]]+c[id[i][k]]);
	printf("%d\n",dp[m]);
	return 0;
}
```


---

## 作者：叫我彪哥 (赞：2)

经典的分组背包问题，注意m和n不要搞反，以及组数的判断

三重循环组数，背包容量，每个物品；

然后是01背包了

    
    
```cpp
#include<cstdio>
int mymax(int a,int b)
{
    if(a>=b)    return a;
    return b;
}
int f[1005],ai[105][1000],ci[1005],wi[1005];
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int n,m,i,j,t;
    scanf("%d%d",&m,&n);
    for(i=1;i<=n;i++)    
    {
        scanf("%d%d%d",&wi[i],&ci[i],&j);
        ai[j][++ai[j][0]]=i;
    }
    for(i=1;ai[i][0]!=0&&i<=100;i++)
    {
        for(j=m;j>=1;j--)
        {
            for(t=1;t<=ai[i][0];t++)
            {
                if(j>=wi[ai[i][t]])
                {
                    f[j]=mymax(f[j],f[j-wi[ai[i][t]]]+ci[ai[i][t]]);
                }
            }
        }
    }
    printf("%d",f[m]);
    return 0;
}
```

---

## 作者：fl_334 (赞：1)

```delphi

        for i:=1 to n do
        begin
                readln(w[i],c[i],p); 
                if p>t then t:=p;
                inc(a[p,0]);  //用0号元素存第p组的物品数
                a[p,a[p,0]]:=i;    
        end;//新手党们好好理解读入处理

```
```delphi

        for k:=1 to t do
                for j:=m downto 0 do
                        for i:=1 to a[k,0] do
                                if j-w[a[k,i]]>=0 then //切记是大于等于0，一开始提交就wa这了。。。
                                f[j]:=max(f[j],f[j-w[a[k,i]]]+c[a[k,i]]);    //动态转移方程f[j]=max{f[j-w[a[k,i]]]+c[a[k,i]]};

        write(f[m]);
end.

```

---

## 作者：Skywalker_David (赞：1)

算法：

这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k,v]表示前k组物品花费费用V能取得的最大权值，则有f[k,v]=max{f[k-1,v],f[k-1,v-w[i]]+c[i]|物品i属于第k组}。


Pascal的福音：

```cpp
var  
  w,c:array[1..1000] of longint;  
  f:array[0..1000] of longint;  
  a:array[1..100,0..1000] of longint;  
  v,n,t,p,i,j,k,m:longint;  
function max(a,b:longint):longint;  
  begin  
    if a>b then exit(a)  
           else exit(b);  
  end;  
begin  
  readln(v,n);  
  m:=0;  
  for i:=1 to n do  
    begin  
      readln(w[i],c[i],p);  
      inc(a[p,0]);  
      a[p,a[p,0]]:=i;  
      m:=max(m,p);  
    end;  
  for k:=1 to m do  
    for j:=v downto 0 do  
      for i:=1 to a[k,0] do  
        if j>=w[a[k,i]] then f[j]:=max(f[j],f[j-w[a[k,i]]]+c[a[k,i]]);  
  writeln(f[v]);  
end.
```

---

## 作者：Ouaoan (赞：0)

这一题是分组背包问题。思路是把每一组看做一个物品，转化为01背包做，f[k][j]是前k组物品j个空间可获得的最大价值。

c++代码如下：



```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
int m,n,t=0;
int w[1010]= {0},c[1010]= {0};
int a[110][1010]= {0},f[1010]= {0};
int main() {
    int i,j,k;
    cin>>m>>n;
    for(i=1; i<=n; i++) {
        int p;
        cin>>w[i]>>c[i]>>p;
        a[p][++a[p][0]]=i;
        if(p>t) {
            t=p;
        }
    }
    for(k=1; k<=t; k++) {
        for(j=m; j>=1; j--) {
            for(i=1; i<=a[k][0]; i++) {
                int tmp=a[k][i];
                if(j-w[tmp]>=0) {
                    if(f[j]<f[j-w[tmp]]+c[tmp]) {
                        f[j]=f[j-w[tmp]]+c[tmp];
                    }
                }
            }
        }
    }
    cout<<f[m];
    return 0;
}
```
/\*

45 4
10 10 1

10 5 1
5 20 2
50 400 2


30

10 6
2 1 1
3 3 1
4 8 2
6 9 2
2 8 3
3 9 3

20

\*/

---


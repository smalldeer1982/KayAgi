# 榨取kkksc03

## 题目描述

洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。

为什么说是搭建 OJ 呢？为什么高效呢？

![](https://cdn.luogu.com.cn/upload/pic/1236.png)

因为，你可以上传私有题目，团队外别人是无法看到的。我们还能帮你们评测！

你可以创建作业，给组员布置任务，查看组员的完成情况，还可以点评任意一份代码！

你可以创建比赛！既可以是 OI 赛制还可以是 ICPC 赛制！既可以是团队内部的私有比赛，也可以公开赛，甚至可以指定谁可以参加比赛。这样，搞“x 校联赛”最合适不过了。洛谷凭借这个功能，希望能够提供公开及私有比赛的另外一个平台。

![](https://cdn.luogu.com.cn/upload/pic/1237.png)

值得说明的是，本次比赛就是采用团队私有题目+邀请比赛的机制。

洛谷的运营组决定，如果一名 OIer 向他的教练推荐洛谷，并能够成功的使用（成功使用的定义是：该团队有 $20$ 个或以上的成员，上传 $10$ 道以上的私有题目，布置过一次作业并成功举办过一次公开比赛），那么他可以浪费掉 kkksc03 的一些时间的同时消耗掉 kkksc03 的一些金钱以满足自己的一个愿望。

kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？

## 样例 #1

### 输入

```
6 10 10
1 1
2 3 
3 2
2 5
5 2
4 3```

### 输出

```
4```

# 题解

## 作者：早右昕 (赞：101)

####其实这道题很简单的呀(题解 By Plue Jheng/InfoEoR)

在完成这道题之前,首先要保证:

- 1.了解并熟练掌握 0/1背包问题.

- 2.对多维动规/多维背包问题有一定了解

- 3.会C/C++/Pascal/中文

那就很简单那!

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,M,T,dp[1010][1010];
int m[1010],t[1010];
int main()
{
    scanf("%d%d%d",&n,&M,&T);
    for(int i=1;i<=n;i++)
    {
        //仅仅只是多了一维而已 
        scanf("%d%d",&m[i],&t[i]);
        for(int j=M;j>=m[i];j--)
        for(int k=T;k>=t[i];k--)
        {
            dp[j][k]=max(dp[j][k],dp[j-m[i]][k-t[i]]+1);
        }
    }
    printf("%d\n",dp[M][T]);
}
```

---

## 作者：llzzxx712 (赞：33)

   想弄懂多维背包题，当然是要先看01背包喽！作为一个刚刚学会背包一个星期的蒟蒻，我决定把我弄懂01背包和多维背包的过程分享给更多蒟蒻。

01背包
题目描述
一个旅行者有一个最多能装 M 公斤的背包，现在有 n 件物品，它们的重量分别是W1，W2，...,Wn,它们的价值分别为C1,C2,...,Cn，求旅行者能获得最大总价值。

【输入】

第一行：两个整数，M (背包容量，M≤200)和N(物品数量，N≤30）

第2..N+1 行：每行二个整数Wi，Ci，表示每个物品的重量和价值。

【输出】

仅一行，一个数，表示最大总价值。

下面是01背包模板代码，最下面有样例数据
```cpp
    #include<iostream>
    using namespace std;
    const int maxm=201,maxn=31;
    int m,n;
    int w[maxn],c[maxn];
    int f[maxn][maxm];//表示前i个物品在容量为v下可以获得的
    最大总价值 
    int main()
    {
      cin>>m>>n;//背包容量m和物品数量n 
      for(int i=1;i<=n;i++){
          cin>>w[i]>>c[i];//输入每个物品的质量和价值 
      }
      for(int i=1;i<=n;i++){
          for(int v=m;v>0;v--){
              if(w[i]<=v){
                 f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]);
              }
    //f[i][v]表示前i件物品，总体积（质量）不超过v的最优价值 
              else{
                  f[i][v]=f[i-1][v];
              }
          }//个人习惯，每个循环都带括号，方便添加代码
       }
       cout<<f[n][m];//f[n][m]为最优解 
       return 0;
    }
```


f[i-1][v-w[i]]这东西代表的就是在v的空间下，放入w[i](也就 是第i件物品）后再放之前的物品获得的价值。[v-w[i]]就是现在 的体积减掉该物品体积后剩下的，就是可以前i件物品留下的， 在之前的计算中已经求得了前i件物品可以得到的价值.

它具有自动检索一般的功能（其实就是找到之前已经算出来的结果），比如样例中我们在i=4时，它根据 [v-w[i]]找到了此时除了它剩下的空间放前面物品最多可以获得3 的价值，再加上它的9的价值得到12。同时它还和只放3个物品进行比较，如果第四个物品价值过小，程序将会选择不拿4。

当我把 输入数据第四个物品和第三个物品的价值改为7时，发现f[3][10] 就已经达到了最大值11，程序在i=4时没有更改结果

以下是通过文件操作打出来的数据
输入:

10 4

2 1

3 3

4 5

7 9

输出： 12

测试输出：
（每段数据有10个，第i段数据代表i等于几时的f[i][1..10],每次的第一个数据代表本次操作时的 v）

10 1

9 1

8 1

7 1

6 1

5 1

4 1

3 1

2 1

1 0

10 4

9 4

8 4

7 4

6 4

5 4

4 3

3 3

2 1

1 0

10 9

9 9

8 8

7 8

6 6

5 5

4 5

3 3

2 1

1 0

10 12

9 10

8 9

7 9

6 6

5 5

4 5

3 3

2 1

1 0

下面是用一维数组实现01背包

```cpp
    #include<iostream>
    using namespace std;
    int w[10002],c[10002];
    int f[10002];
    int main()
    {
        int m,n;
        cin>>m>>n;
        for(int i=1;i<=n;i++){
            cin>>w[i]>>c[i];
        }
        for(int i=1;i<=n;i++){
            for(int v=w[i];v<=n;v++){
                f[v]=max(f[v],f[v-w[i]]+c[i]);
             }
        }
        cout<<f[m];
        return 0;
    }
```

这里我们可以看到，它省去了数组中用来表示前i个物品（题目）的一维，因为这不重要。我们不需要管它是在前几个物品（题目）中在容量v（时间t）下得到的最大价值（最高分数），我们只需要知道在容量v下可以得到的最大价值。所以现在的f[100002]就是代表在多少容量（时间）下可以得到的最高价值（分数）。其余都和上面的背包模板一样。

------------
好了，那么现在就是本题的二维背包了，那么其实就是在原来的基础上增加一维，就多设置一重循环就好了
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
int t1[202],m1[202],f[202][202];
int main()
{
    int n,m,t;
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
    	cin>>m1[i]>>t1[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=m1[i];j--){
			for(int k=t;k>=t1[i];k--){
				f[j][k]=max(f[j][k],f[j-m1[i]][k-t1[i]]+1);
			}
		}
	}
	cout<<f[m][t];
	return 0;
}
	

```
这样相当于对每个i多进行了m-m1[i]次一维背包的计算，得到每一种情况的状态，最终得到在m、t下的最优解


---

## 作者：prefer (赞：24)

记忆化搜索

f[step][nm][nt]表示第几个，目前的钱，目前的时间

然后其他就没什么好说的了，有几个细节要注意
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
struct pig {int tim,mon;} a[205];
int f[205][205][205];
int dfs(int step,int nm,int nt) {//step表示第几个，nm表示目前的钱，nt表示目前的时间
	if(nm<0||nt<0)return -1;//要return -1是因为之前搜索的时候直接拿来加也就是假设可以的，但是如果发现不符合条件就需要将之前的假设去掉，即return -1
	if(f[step][nm][nt]!=-1)return f[step][nm][nt];//记忆化
	if(step>=n)return 0;//越界 return
	return f[step][nm][nt]=max(dfs(step+1,nm-a[step+1].mon,nt-a[step+1].tim)+1/*就是这里我们dfs的时候直接加上去的，所以必须要在不符合情况的时候return -1*/p+1,nm,nt));/*dfs选择还是不选*/
}
int main() {
	scanf("%d%d%d",&n,&m,&t);
	memset(f,-1,sizeof(f));
	for(int i=1; i<=n; i++)scanf("%d%d",&a[i].tim,&a[i].mon);
	printf("%d\n",dfs(0,m,t));
	return 0;
}
```

---

## 作者：yybyyb (赞：19)

确实是一个简单的背包

我一开始也是用的三维的数组

但是Wa了

正常的三维的思路是

~~如果你的状态和我设的不一样的话底下那里就是加~~

```cpp
       for(int i=1;i<=n;++i)
         for(int j=m-M[i];j>=0;--j)
           for(int k=t-T[i];k>=0;--k)
              f[i][j][k]=max(f[i-1][j][k],f[i-1][j+M[i]][k+T[i]]+1);
```
这样子看似是对的

但是一交

只有60分

此时仔细的想一想

我们会发现

```cpp
  f[i][j][k]=max(f[i-1][j][k],f[i-1][j+M[i]][k+T[i]]+1);   
```
明显存在一个f[i-1][j][k]直接转移过来

如果此时是j或者k大于了范围，

那么当前的f[i][j][k]就只能够从f[i-1][j][k]直接转移过来

因此循环的过程中一定要记得不能够选的情况要直接转移过来

~~如果你是用的滚动数组请忽略我所讲的一切~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
//f[i][j][k]表示前i个愿望，剩余了j元钱，k时间的最多实现愿望数 
const int MAX=101;
int f[MAX][2*MAX][2*MAX];
int M[MAX],T[MAX];
int n,m,t,ans=0;
int main()
{
       cin>>n>>m>>t;
       for(int i=1;i<=n;++i)
          cin>>M[i]>>T[i];
       for(int i=1;i<=n;++i)
         for(int j=m;j>=0;--j)
           for(int k=t;k>=0;--k)
             if(j+M[i]<=m&&k+T[i]<=t) 
              ans=max(ans,f[i][j][k]=max(f[i-1][j][k],f[i-1][j+M[i]][k+T[i]]+1));
             else
              ans=max(ans,f[i][j][k]=f[i-1][j][k]);
       cout<<ans<<endl;
       return 0;  
}

```

---

## 作者：帅到报警 (赞：17)

~~震惊！luogu某管理员竟然被XXXXXXX~~
### 【题意分析】
首先我们可以看出来这是一道 dp 题。。（~~废话~~）

然后这是一道二维 dp **好**题

然后这是一道 01 背包**好**题

那么我们就可以做了。

定义 f[ i ][ j ] 为用了 i 元花费了 j 时间的最大实现个数，那么三重循环，第一重枚举第 i 个，第二重枚举 money， 第三重枚举 time 就可以解决了。

### 【核心代码】
```cpp
for(int i = 1; i <= n; i++)
	for(int j = mon; j >= m[i]; j--)
		for(int k = tim; k >= t[i]; k--)
			f[j][k] = Max(f[j][k], f[j - m[i]][k - t[i]] + 1);
```

### 【正解】
```cpp
#include <bits/stdc++.h>
#define N 101
using namespace std;

int n, tim, mon;
int t[N], m[N];
int f[201][201];

inline int read()
{
    char ch = getchar();
	int x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

inline int Max(int a, int b)
{
	return a > b ? a : b;
}

int main()
{
	n = read(), mon = read(), tim = read();
	for(int i = 1; i <= n; i++)
		m[i] = read(), t[i] = read();
	for(int i = 1; i <= n; i++)
		for(int j = mon; j >= m[i]; j--)
			for(int k = tim; k >= t[i]; k--)
				f[j][k] = Max(f[j][k], f[j - m[i]][k - t[i]] + 1);
	cout << f[mon][tim];
	
	return 0;
}
```

---

## 作者：yummy (赞：10)

推销一下我的[反向背包](https://www.luogu.org/problem/U86004).

其主要部分与背包相同，但是状态定义有所不同。

我们这里换一种状态定义方式，设当前在处理第k个愿望，a[i][j]=满足i个愿望,耗费j点金钱的最少时间。

于是我们就有a[i][j]=min(a[i][j],a[i-1][j-mk]+tk)

时间复杂度$O(N^2M)$,与T无关，所以......换一种状态转移就可以解决M,T<=10000的问题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][205],n,mm,tt,best=0;
int main()
{
    memset(a,0x3f,sizeof(a));
    a[0][0]=0;
    cin>>n>>mm>>tt;
    int m,t;
    for(int k=1;k<=n;k++)
    {
        cin>>m>>t;
        for(int i=k;i;i--)
            for(int j=mm;j>=m;j--)
            {
                a[i][j]=min(a[i][j],a[i-1][j-m]+t);
                if(a[i][j]<=tt)
                    best=max(i,best);
            }
    }
    cout<<best;
    return 0;
}
```

---

## 作者：yzpyzp (赞：8)

### 题面

给你一定的时间和背包容量，现在有$n$个物品，选择它们，需要一定的时间还需耗费你的一定背包容量。求最多能选几个物品。


### 先分析一下思路：

如果只有一件费用，那么就可以直接上贪心了。将费用$sort$一遍，然后就直接一样一样的选。

可是现在是二维的费用了，也就是说它有两项费用需均衡同时考虑。这就是一道明显的二维费用的背包问题了。

首先我们枚举物品用一层循环枚举容量，然后再用一层循环枚举时间；我们就考虑一下，我们是选当前这件物品，还是不选。如果选我们还剩多少的背包容量和时间，然后它的总收益就是剩下的能选的最大数$+1$，在和当前已知的用同样的时间和背包容量能选的最大值比较，取最大值，就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,m1[105],t1[105],f[205][205];
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>t;
    for(int i = 1; i <= n; ++ i)
        cin>>m1[i]>>t1[i];
    for(int i = 1; i <= n; ++ i)
    for(int j = m; j >= m1[i]; -- j)
    for(int k = t; k >= t1[i]; -- k)
    f[j][k] = max(f[j][k],f[j - m1[i]][k - t1[i]]+1);
    cout<<f[m][t];
    return 0;
} 
```

附加：如果你实在不会打动态规划，那么你也可以用记忆化搜索，[这两种方法本质都是一样的](https://interestinglsy.blog.luogu.org/memdfs-and-dp))

不过建议你还是学习一下动态规划吧，毕竟动规只是思路比较难，但动规实现还是很好的。

---

## 作者：zsc2003 (赞：6)

看到全洛谷上几乎全都是用倒着跑的dp......

所以本人就在这里发一个正着循环的dp

转移:
```cpp
dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-mon[i]][k-ti[i]]+1)   (j>=money[i]且k>=time[i])

否则: dp[i][j][k]=dp[i-1][j][k];
```
其实如果要滚动数组的话貌似必须要倒着dp

但是~~本题的数据范围并不用滚动数组~~本人比较懒惰

所以就这样写了......

下面附上本人的代码 

```cpp 
#include<bits/stdc++.h>
using namespace std;
inline int read()//读入优化 
{
	int r,s=0,c;
	for(;!isdigit(c=getchar());s=c);
	for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);
	return s^45?r:-r;
}
const int N=210;
int n,m,t,maxn;
int ti[N],mon[N],dp[N][N][N]; 
int main()
{
	n=read(),m=read(),t=read();
	for(int i=1;i<=n;i++)
		ti[i]=read(),mon[i]=read();
	for(int i=1;i<=n;i++)//dp过程 
		for(int j=1;j<=m;j++)
			for(int k=1;k<=t;k++)
			{
				if((j>=mon[i])&&(k>=ti[i]))
					dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-mon[i]][k-ti[i]]+1);
				else
					dp[i][j][k]=dp[i-1][j][k];
			}
	printf("%d\n",dp[n][m][t]);
	return 0;
}
```

---

## 作者：EarthGiao (赞：4)

## 【思路】
01背包    
一道几乎是01背包的板子题目    
不过这个有两个需要考虑的变量   
时间和金钱    
然而01背包是只枚举一个变量的    
不过很简单就可以改为两个变量了    
只需要加一重循环同时给背包数组开个二维就可以啦    

01背包板子里面背包数组存的是价值    
这里也可以很灵活的改为一个计数器，计数可以放进去的数量      

其实我一开始想的是贪心    
因这个不需要考虑价值只需要考虑个数
但是这个的消费有两个     
而且优先级（也就是考虑的重要性）是一样的    
所以没有办法贪心，所以贪心+排序就是错解了     

## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 105;
int m[Max],t[Max];
int b[Max << 1][Max << 1];
int main()
{
	int n,M,T;
	scanf("%d%d%d",&n,&M,&T);
	for(int i = 1;i <= n;++ i)
		scanf("%d%d",&m[i],&t[i]);
	for(int i = 1;i <= n;++ i)
		for(int j = M;j >= m[i];j --)
			for(int k = T;k >= t[i];k --)
				b[j][k] = max(b[j][k],b[j - m[i]][k - t[i]] + 1);
	cout << b[M][T] << endl;
	return 0;
}
```

---

## 作者：SNiFe (赞：3)

尽管说这是站长大人出的题，但确实很简单。->\_->

这就是一个二维背包费用问题，用dp[i][j]表示当钱为i，时间为j时能最大满足愿望数量；

那么状态转移方程为：dp[j][k]=max(dp[j][k],dp[j-mon[i]][k-tim[i]]+1)；

#CODE
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=205;
int dp[N][N],n,m,summ,sumt,mon[N],tim[N];
int main()
{
    scanf("%d%d%d",&n,&summ,&sumt);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&mon[i],&tim[i]);
    }
    for(int i=1;i<=n;i++)
    for(int j=summ;j>=mon[i];j--)
    for(int k=sumt;k>=tim[i];k--)
    {
        dp[j][k]=max(dp[j][k],dp[j-mon[i]][k-tim[i]]+1);//状态转移方程
    }
    printf("%d",dp[summ][sumt]);
}
```

---

## 作者：exit0 (赞：2)

### 记忆化搜索！！！！

作为一个蒟蒻，我当然喜欢记忆化搜索啦！！！

个人感觉这道题有点像[采药](https://www.luogu.org/problem/P1048)。

下面是我的AC代码：[AC记录](https://www.luogu.org/record/25711727)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>//头文件
using namespace std;
int read()//快读QWQ
{
	int ans=0;
	int flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
int n;
int t;
int m;
int mi[10010];
int ti[10010];
int ans;
int vis[300][300][300];
int dfs(int idx,int tim,int mon)//begin!记忆化搜索
{
	if(tim>t||mon>m)return vis[idx][tim][mon]=-1;//如果越界了，返回不合法。
	if(vis[idx][tim][mon]!=-1)return vis[idx][tim][mon];//如果之前被搜过，那么可以直接返回了！（也就是记忆化搜索的核心代码）
	if(idx>=n+1)return vis[idx][tim][mon]=0;//搜索完毕后返回。
	return vis[idx][tim][mon]=max(dfs(idx+1,tim+ti[idx],mon+mi[idx])+1,dfs(idx+1,tim,mon));//比较每一种物品选还是不选，并返回一个较大值。
}
int main()
{
	memset(vis,255,sizeof(vis));//注意，一定要清零。不然会炸！。
	n=read();
	m=read();
	t=read();
	for(int i=1;i<=n;i++)
	{
		ti[i]=read();
		mi[i]=read();
	}//以上是读入。
	cout<<dfs(1,0,0);//完美输出
	return 0;//完美RETURN
}
```

总的来说，这道题还是挺适合记忆化搜索练手的，完成这道题的OIer可以去尝试[P1164 小A点菜](https://www.luogu.org/problem/P1164)
与[P1216 数字三角形（竟然是IOI的题）](https://www.luogu.org/problem/P1216)。

祝各位早日练成DP&&记忆化搜索，感谢观看！

---

## 作者：悠猫丶月贰 (赞：2)

01背包，我开的是二维，不太明白为什么要开三维

数组f[j][k]记录用j的钱，k的时间能实现最多愿望数

对于每个愿望有两种选择实现或不实现

公式：

```cpp

f[j][k]=max(f[j][k],f[j-m[i]][k-t[i]]+1);

```
扣上~~工整~~的代码：

```cpp

#include<cstdio>
#include<algorithm>
#define f(v,x,y,num) for (int v=x,p=num>0?1:-1;p*v<=p*y;v+=num)//偷懒打的自定义for循环，请无视 
#define N 110
using namespace std;
int n,M,T,f[N<<1][N<<1],m[N],t[N],ans;
int main(){
    scanf("%d%d%d",&n,&M,&T);
    f(i,1,n,1) scanf("%d%d",&m[i],&t[i]);
    f(i,1,n,1) f(j,M,m[i],-1) f(k,T,t[i],-1) f[j][k]=max(f[j][k],f[j-m[i]][k-t[i]]+1);//动规，实现的话减去时间金钱，值+1
    printf("%d",f[M][T]);
}
```
~~话说这题描述真的不是在强行买一波广告吗~~


---

## 作者：溜肾污主xyt (赞：2)

## 这是一道二维费用01背包题
其他背景没卵用，关键是输入输出格式所给信息关键

输入格式

第一行,n M T，表示一共有n(n<=100)个愿望，kkksc03 的手上还剩M(M<=200)元，他的暑假有T(T<=200)分钟时间。

第2~n+1行 mi,ti 表示第i个愿望所需要的金钱和时间。

输出格式

一行，一个数，表示kkksc03最多可以实现愿望的个数。


------------

从此中可看出，dp费用有**二维**，抽象可以这么说——

**有n个物品，每个物品第一种费用为mi，对应背包容量M；第二种费用为ti，对应背包容量T，求最多所取物品数量**

于是乎，这道题便转化为一道费用二维的01背包问题

“但它有二维费用，感觉好复杂啊！”蒟蒻发声

没关系，费用加一维，不过是循环加一维，数组加一维而已，实际上很简单的


------------

### 又到了喜闻乐见的上代码时间
#### case 1 三维数组

这是01背包取最大价值的代码

```cpp
for(int i=1; i<=n; i++) {
    for(int j=0; j<=m; j++) {
    if(j>=w[i])
      f[i][j]=max(f[i][j],f[i-1][j-w[i]]+v[i]);
    }
}

```

那我们无非是**多加一维**，再改为最多物品而已

```cpp
for(int i=1; i<=n; i++)//i枚举物品
    for(int j=m; j>=0; j--)//j枚举价格
    for(int k=t; k>=0; k--){//k枚举时间
        if(j+mo[i]<=m&&k+ti[i]<=t)//判断是否取
              f[i][j][k]=max(f[i-1][j][k],f[i-1][j+mo[i]][k+ti[i]]+1); 
        else f[i][j][k]=f[i-1][j][k];//继承
        ans=max(ans,f[i][j][k]);//取最终答案最大值
    }
cout<<ans;//输出
```
#### case 2 二维优化

只要你学过01背包，你肯定会写**一维优化**，这样可以节省很多空间

这是01背包一维优化的最大价值代码，特点是需要逆序枚举费用

```cpp
for(int i=1; i<=n; i++) {
    for(int j=m; j>=w[i]; j--) {
      f[j]=max(f[j],f[j-w[i]]+v[i]);
    }
}
```


同理，此题可以**二维优化**

```cpp
for(int i=1; i<=n; i++)
    for(int j=m; j>=mo[i]; j--)
    for(int k=t; k>=ti[i]; k--){
        f[j][k]=max(f[j][k],f[j-mo[i]][k-ti[i]]+1);//递推式，不难理解
    }
    cout<<f[m][t];//最终答案为f[m][t]

```

当然喽，二维优化代码更简短，空间更少，推荐大家使用

## Code

```cpp
#include<bits/stdc++.h>
#define F1(a,b,c) for(b=c;b<=a;b++)
#define F2(a,b,c) for(b=a;b>=c;b--)
using namespace std;
int n,m,t,i,j,k;
int ti[105],mo[105],f[205][205];
int main() {
    cin>>n>>m>>t;
    F1(n,i,1)cin>>mo[i]>>ti[i];
    F1(n,i,1)F2(m,j,mo[i])F2(t,k,ti[i])f[j][k]=max(f[j][k],f[j-mo[i]][k-ti[i]]+1);
    cout<<f[m][t];
    return 0;
}
```


本人做题时码的代码可能有些装B，主要推荐看上面的orz


------------
 PS：  _记忆化搜索应该也可以做，但个人不推荐，因为递归的时间总比循环多，而且——_
 
**一般来说，凡是能用记忆化写的，dp也能写。**
## 谢谢观看！

---

## 作者：孤独的死男孩 (赞：2)

# - 看到这题题目感到很奇葩，读了之后感觉更奇葩~~这分明是kkksc003自己压榨自己啊~~- 
- 这题实际是基础二维01背包~~所以难度设定有问题~~ 
- 废话不多说，以下是思路：
- 这题转移方程是f[j][k]=max(f[j][k],f[j-wish_money[i]][k-wish_time[i]]+1)
- 解释一下就是选取此物与不选取此物之间谁比较好j枚举kkksc003的金钱，k枚举时间
- 之后用转移方程枚举从f[0][0]到f[m][t]，输出f[m][t],以下是代码：
```cpp
#include<iostream>
using namespace std;
int wish_m[105]={0},wish_t[105]={0},f[205][205];
int main(){
	int n,m,t;
	cin>>n>>m>>t;
	for(int i=0;i<n;i++){
		cin>>wish_m[i]>>wish_t[i];
	}
	for(int i=0;i<n;i++){
		for(int j=m;j>=wish_m[i];j--){
			for(int k=t;k>=wish_t[i];k--){
				f[j][k]=max(f[j-wish_m[i]][k-wish_t[i]]+1,f[j][k]);
			}
		}
	}
	cout<<f[m][t];
	return 0;
}
```
~~话说真心觉得数据加强一下，以我这个小菜鸟都能10分钟1A~~

---

## 作者：ZzuGzx (赞：1)

 类似01背包问题\
 只不过这道题有两个限制条件\
 开一个二维的数组就ok了\
 金钱和时间都为背包体积\
 愿望的数量就是价值\
 那么方程为dp[j][k]=max(dp[j][k],dp[j-p[i].m][k-p[i].t])
## 下面为AC代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
#include<map>
#include<cstdlib>
#include<string>
#include<functional>
#include<list>
#include<stack>
using namespace std;
int n, m, t;
struct node
{
	int m, t;
}p[101];
int dp[201][201];
int main()
{
	//freopen("in.txt", "r", stdin);
	cin >> n >> m >> t;
	int ans = 0;
	for (int i = 1;i <= n;i++)
		scanf("%d%d", &p[i].m, &p[i].t);
	for (int i = 1;i <= n;i++) {
		for (int j = m;j >= p[i].m;j--)
			for (int k = t;k >= p[i].t;k--) {
				dp[j][k] = max(dp[j][k], dp[j - p[i].m][k - p[i].t] + 1);
				ans = max(ans, dp[j][k]);
			}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：✌yww (赞：1)

简单01背包问题，不要复杂了，定义状态dp[j][k]表示有i个人，钱为j，时间为k，能够帮助的最大同学人数

可分为两种情况讨论

1.这个人不帮

2.这个人帮，那么对应的j就应该减去帮这个人的钱，k减去帮这个人的时间

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<string>
using namespace std;
int n,M,T;
int dp[1200][1200];
int mi[1200],ti[1200];
int main()
{
    scanf("%d %d %d",&n,&M,&T);
    for(int i=1; i<=n; i++)
    {
        scanf("%d %d",&mi[i],&ti[i]);
    }
    for(int i=1; i<=n; i++)
    {
        for(int j=M; j>=mi[i]; j--)
        {
            for(int k=T; k>=ti[i]; k--)
            {
                dp[j][k]=max(dp[j][k],dp[j-mi[i]][k-ti[i]]+1);
            }
        }
    }
    printf("%d",dp[M][T]);
    return 0;
}
```

---

## 作者：karriganasta (赞：1)

这题不过就是比01背包多了一个限制嘛..

直接上三维能过 100 \* 200 \* 200的复杂度不会爆炸

转移方程：

F[j][k] = max(F[j][k],F[j-ti[i]][k-v[i]]+1); 

其中 1<= i <= n,  T>=j >=ti[i] , M >= k >= v[i].

至于用不用滚动数组那就你的自由了.

身为一个蒟蒻还小心翼翼地写了F[0][0] = 0;

233333上代码 代码风格不要吐槽.


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,M,T;
int ti[110],v[110];
int F[210][210];
int main(int argc, char *argv[]) {
    scanf("%d%d%d",&n,&M,&T);
    for (int i = 1; i <= n; i++)
        scanf("%d%d",&ti[i],&v[i]); //读入 
    F[0][0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = T; j >= ti[i]; j--)
            for (int k = M; k >= v[i]; k--)
                F[j][k] = max(F[j][k],F[j-ti[i]][k-v[i]]+1); //核心方程 
    printf("%d",F[T][M]); // F[T][M]为最优解 
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

三维还是可以过的，没有二维->好但是好理解一点

就是把01背包变成三维来做

状态转移为  if(j+m[i]<=M&&k+t[i]<=T)

dp[i][j][k]=max(max(dp[i][j][k],dp[i-1][j+m[i]][k+t[i]]+1),dp[i-1][j][k]);

            else dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);

其实和二维也没什么区别嘛



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int dp[110][210][210],n,M,T,m[110],t[110];
int main(){
    scanf("%d%d%d",&n,&M,&T);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&m[i],&t[i]);
    for(int i=1;i<=n;i++)
        for(int j=M;j>=0;j--)
            for(int k=T;k>=0;k--){
                if(j+m[i]<=M&&k+t[i]<=T)
                dp[i][j][k]=max(max(dp[i][j][k],dp[i-1][j+m[i]][k+t[i]]+1),dp[i-1][j][k]);
                else dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);
            }
    printf("%d",dp[n][0][0]);
}
```

---

## 作者：fl_334 (赞：1)

```delphi

//二维费用的背包问题。。。。。
var
        n,m,t,i,j,k:longint;
        a,b:array[1..10000]of longint;
        f:array[0..200,0..200]of longint;
function max(a,b:longint):longint;
begin
        if a>b then exit(a)
        else exit(b);
end;
begin
        readln(n,m,t);
        for i:=1 to n do
                readln(a[i],b[i]);
        for i:=1 to n do
                for j:=m downto a[i] do
                        for k:=t downto b[i] do
                                f[j,k]:=max(f[j,k],f[j-a[i],k-b[i]]+1);
//动态转移方程 f[v,m]=max(f[v,m],f[v-a[i],m-b[i]]+1)
        write(f[t,m]);
end.

```

---

## 作者：Mr_Li (赞：1)

和01背包问题类似，只是从原来的一个属性（体积）变为现在的两个属性（时间和金钱）。

附动态规划核心代码：

```cpp

    for (i=1;i<=n;i++)
    for (j=0;j<=M+T;j++)//j表示[b]剩余[b]的金钱与时间之和
    for (k=0;k<=j;k++)//k表示[b]剩余[b]的金钱，j-k表示剩余的时间
    if (k>=0&&M+T-k>=0&&k+m[i]<=M&&n-k+t[i]<=T)
    answer[M-k+m[i]][T-j+k+t[i]]=max(answer[M-k+m[i]][T-j+k+t[i]],answer[M-k][T-j+k]+1);//answer[i][j]表示kkksc03消耗i的金钱和j的时间最多可以满足的愿望数量

```
这道题用记忆化搜搜也可以，时间复杂度均为O(n\*(M+T)^2)。


---

## 作者：曦行夜落 (赞：1)

##For 榨取kkksc03【P1855】

这题看上去比较难，但是仔细看下去，发现它符合01背包的条件：

1.有背包容量

2.n个物品要么选，要么不选

3.每个物品有花费和价值

而这题的背包容量就是：时间和金钱（因为问题中花费的就是时间和money）

要么实现某个愿望，要么残忍拒绝

花费就是金钱和时间，价值是1

所以这题实际上可以用01背包来套

那么状态就要多一维（因为费用和容量变成了二维），01背包部分不解释

01背包有一个优化叫滚动数组，而这题我们也可以通过滚动降低复杂度，01背包的滚动数组要求j从m到0循环，所以这一题j要从时间最大值向下循环，k要从金钱最大值向下循环（想一想，为什么），这样空间就变成了二维

下面附上非优化代码：（优化方式已经写清楚了，留给读者思考）





```cpp
var
  f:array[0..205,0..205,0..205] of longint;
  time,mny:array[0..205] of longint;
  n,m,t,i,j,k:longint;
function max(x,y:longint):longint;
begin
  if x>y then exit(x); exit(y);
end;
begin
  readln(n,m,t);
  for i:=1 to n do
    readln(time[i],mny[i]);
  for i:=1 to n do
    for j:=1 to m do
      for k:=1 to t do
    if (j>=mny[i]) and (k>=time[i]) then
      f[i,j,k]:=max(f[i-1,j,k],f[i-1,j-mny[i],k-time[i]]+1)
    else f[i,j,k]:=f[i-1,j,k];
  writeln(f[n,m,t]);
end.
```

---

## 作者：VenusM1nT (赞：1)

比较简单的01背包，不过要用二维

（话说这题和NASA的食物计划几乎一样诶

要注意的一点是 **题目的输入是反过来的，要留点心**

方程为 $f[j][k]=max(f[j][k],f[j-v[i]][k-v[i]]+1)$

答案在 $f[s][t]$ 的位置

具体见代码


```cpp
#include<cstdio>
#include<algorithm>
int n,f[205][205],w[105],v[105],s,t;//标准的01背包配置
int main()
{
    scanf("%d%d%d",&n,&s,&t);//这里是先输入时间后输入金钱
    for(int i=1;i<=n;i++) scanf("%d %d",&w[i],&v[i]);//这里却是先输入金钱后输入时间，值得注意，一不小心就写反了看（还好我留心了
    for(int i=1;i<=n;i++)
    {
        for(int j=s;j>=v[i];j--)
        {
            for(int k=t;k>=w[i];k--) f[j][k]=std::max(f[j][k],f[j-v[i]][k-w[i]]+1);//经典的01背包结构，不过要注意这题没有价格，所以+1即可
        }
    }
    printf("%d",f[s][t]);
    return 0;
}
```

---

## 作者：weiyongxiang (赞：0)

转移方程：f[i,j]:=max{f[i,j],f[i-当前愿望所需时间,j-当前愿望所需金钱]}代表取与不取

```cpp
var
  s,n,m,i,j,k:longint;
  f:array[0..200,0..200] of longint;//f[i,j]表示用i个时间，j个金钱的最大价值
  w,v:array[1..100] of longint;
begin
  readln(s,n,m);
  for i:=1 to s do
    readln(w[i],v[i]);
  {for i:=1 to s do\\i是计数器
    for j:=n downto w[i] do\\w 代表时间
      for k:=m downto v[i] do\\v 代表金钱
        if f[j,k]<f[j-w[i],k-v[i]]+1 then f[j,k]:=f[j-w[i],k-v[i]]+1;}\\两个维度限制的01背包，所以j、k枚举两个维度。
  writeln(f[n,m]);
end.
```

---

## 作者：black__kings (赞：0)

简单的01背包（二维） Pascal代码：（边读边做）代码明显短了不少，内存也少了

```cpp
uses       //调用数学库 纯属为了方便
  math;
var
  f:array[0..200,0..200] of longint;
  v,w:array[1..200] of longint;
  n,m,m1,i,j,k,x,y:longint;
begin
  readln(n,m,m1);
  for i:=1 to n do
  begin
    readln(x,y);  //时间，金钱
    for j:=m downto x do   //枚举最大可用的时间
      for k:=m1 downto y do  //枚举最大可用的金钱
        f[j,k]:=max(f[j,k],f[j-x,k-y]+1);  //如果用就+1
  end;
  writeln(f[m,m1]);
end.
Pascal代码(读完做)：
uses   //调用数学库，纯属为了方便
  math;
var
  f:array[0..200,0..200] of longint;
  v,w:array[1..200] of longint;
  n,m,m1,i,j,k:longint;
begin
  readln(n,m,m1);
  for i:=1 to n do
    readln(w[i],v[i]);  //时间，金钱
  for i:=1 to n do  //枚举所有的愿望
    for j:=m downto w[i] do  //枚举最大可用的时间
      for k:=m1 downto v[i] do  //枚举最大可用的金钱
        f[j,k]:=max(f[j,k],f[j-w[i],k-v[i]]+1);  //如果用就+1
  writeln(f[m,m1]);
end.
请大家自行选择着两个代码
```

---

## 作者：Celebrate (赞：0)

这一题感觉很像背包和DP的结合体

我们就用DP来做吧

感觉代码有一些变态，不要介意哦

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define MAXX 210
inline void Read(int &Input) {//输入优化，打不打用处不大 
	char Character;
	Input=0;
	Character=getchar();
	while(Character>'9'||Character<'0')Character=getchar();
	while(Character<='9'&&Character>='0') {
		Input*=10;
		Input+=Character-'0';
		Character=getchar();
	}
}
inline void Write(int Output) {//输出优化 
	char Digit[11];
	int Lenth=0;
	while(Output>0) {
		Digit[++Lenth]='0'+Output%10;
		Output/=10;
	}
	for(int i=Lenth; i>=1; i--) {
		putchar(Digit[i]);
	}
	printf("\n");
}
int n,m,t,f[MAXX][MAXX],a[MAXX],b[MAXX];
inline void Dp()
{
	int Loop,Round,Circulate;
	Read(n);Read(m);Read(t);
	for(Loop=1;Loop<=n;Loop++){Read(a[Loop]);Read(b[Loop]);}//输入 
	for(Loop=1;Loop<=n;Loop++) { 
		for(Round=m;Round>=b[Loop];Round--) {
			for(Circulate=t;Circulate>=a[Loop];Circulate--) {
				f[Round][Circulate]=max(f[Round][Circulate],f[Round-b[Loop]][Circulate-a[Loop]]+1);//取最优值 
			}
		}
	}
	Write(f[m][t]);
}
int main(){
	Dp();
}
```

---

## 作者：Gary_钱 (赞：0)

容易发现，本题是个**双重限制的01背包问题**。

我们可以把每个愿望的价值看成1，这样就是统计个数啦。

关键代码：



```cpp
    for i:=1 to n do
      for j:=m downto mi[i] do
        for k:=t downto ti[i] do
          dp[j,k]:=max(dp[j,k],dp[j-mi[i],k-ti[i]]+1);
```
时间也不会爆啦。
AC代码===>>>


```cpp
program xixix;
  uses math;
  var n,m,t,i,j,k:longint;
      mi,ti:array[1..1000000] of longint;
      dp:array[0..1000,0..1000] of longint;
    begin
    readln(n,m,t);
    for i:=1 to n do
      readln(mi[i],ti[i]);
    for i:=1 to n do
      for j:=m downto mi[i] do
        for k:=t downto ti[i] do
          dp[j,k]:=max(dp[j,k],dp[j-mi[i],k-ti[i]]+1);
    write(dp[m,t]);
end.
```

---

## 作者：xukuan (赞：0)

#动脑比动手更重要！！！


搜索优化，60分：

var
 i,n,m,t,max:longint;

a:Array[0..110] of record





```cpp
                     t,m:longint;
                    end;
procedure dfs(ren,xuan,money,time:longint);
 begin
  if money<0 then exit;//没钱了
  if time<0 then exit;//没时间
  if ren=n+1 then//判断完了
   begin
    if xuan>max then max:=xuan;//是否大于当前最大值
    exit;//退出
   end;
  dfs(ren+1,xuan+1,money-a[ren].m,time-a[ren].t);//要这个人
  dfs(ren+1,xuan,money,time);//不要这个人
end;
begin
 readln(n,m,t);
 for i:=1 to n do
  readln(a[i].t,a[i].m);
 max:=0;
 dfs(1,0,m,t);//深搜
 writeln(max);
end.
```
dp，100分：

```cpp
var
 i,j,k,n,m,t:longint;
 a,b:array[0..110] of longint;
 c:array[0..110,0..210,0..210] of longint;//三维数组
begin
 readln(n,m,t);
 for i:=1 to n do
  read(a[i],b[i]);
 for i:=1 to n do
  for j:=1 to m do
   for k:=1 to t do//三重循环
    begin
     c[i,j,k]:=c[i-1,j,k];
     if (j>=a[i]) and (k>=b[i]) and (c[i-1,j-a[i],k-b[i]]+1>c[i,j,k]) then//放得下且比原来大
      c[i,j,k]:=c[i-1,j-a[i],k-b[i]]+1;//替换
    end;
 writeln(c[n,m,t]);
end.

```

---

## 作者：c201904 (赞：0)

这一道题是一道典型的01背包问题，你可以用三维数组做（前i个愿望的状态），也可以用二维数组做（传说中的滚动数组），这里先给出三维数组的//三维数组只给出了思想，不是对的，复制提交WA自行负责（不要复制！）

```cpp
#include<iostream>
using namespace std;
    int a[1001]={0},b[1001]={0},n,m,t,f[105][205][205]={0};//前100个愿望，0-200的钱，0-200的时间
int main(){
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
        cin>>a[i]>>b[i];
        for(int j=m;j>=a[i];j--){//从m个钱枚举到a[i]，即当前愿望实现需要的钱（钱少于a[i]就肯定实现不了愿望了）
            for(int l=t;l>=b[i];l--){//从t个时间枚举到b[i]，即当前愿望实现需要的时间（时间少于b[i]就肯定实现不了愿望了）
                f[i][j][l]=max(f[i-1][j][l],f[i-1][j-a[i]][l-b[i]]+1);//动态转移方程，前i个愿望不实现当前的，和实现了当前愿望后+1
            }
        } 
    }
    cout<<f[n][m][t]; 
return 0;
}
```
二维数组的（AC，但也别复制）
```cpp
#include<iostream>
using namespace std;
    int a[1001]={0},b[1001]={0},n,m,t,f[301][301]={0};//滚动数组
int main(){
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
        cin>>a[i]>>b[i];
        for(int j=m;j>=a[i];j--){//从m个钱枚举到a[i]，即当前愿望实现需要的钱（钱少于a[i]就肯定实现不了愿望了）
            for(int l=t;l>=b[i];l--){//从t个时间枚举到b[i]，即当前愿望实现需要的时间（时间少于b[i]就肯定实现不了愿望了）
                f[j][l]=max(f[j][l],f[j-a[i]][l-b[i]]+1);//动态转移方程，不实现当前的愿望，和实现了当前愿望后+1
            }
        } 
    }
    cout<<f[m][t]; 
return 0;
}
```

---

## 作者：MedalPluS (赞：0)

二维费用背包问题，详情见背包九讲（神一样的著作，Orz）

加一维即可，时间复杂度O（NMT）

别忘了，先读入N,M,T

但是单个物品是先T再M


---


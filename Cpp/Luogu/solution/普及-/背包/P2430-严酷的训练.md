# 严酷的训练

## 题目背景

Lj 的朋友 WKY 是一名神奇的少年，在同龄人之中有着极高的地位。。。


## 题目描述

他的老师老王对他的程序水平赞叹不已，于是下决心培养这名小子。

老王的训练方式很奇怪，他会一口气让 WKY 做很多道题，要求他在规定的时间完成。而老王为了让自己的威信提高，自己也会把这些题都做一遍。

WKY 和老王都有一个水平值，他们水平值的比值和做这些题所用时间的比值成反比。比如如果 WKY 的水平值是 $1$，老王的水平值是 $2$，那么 WKY 做同一道题的时间就是老王的 $2$ 倍。

每个题目有他所属的知识点，这我们都知道，比如递归，动规，最短路，网络流。在这里我们不考虑这些事情，我们只知道他们分别是知识点 $1$，知识点 $2$……每一个知识点有他对应的难度，比如动态规划经常难于模拟。

而每一个同一知识点下的题目，对于 WKY 来讲，都是一样难的。而做出每一道题，老王都有其独特的奖励值。而奖励值和题目的知识点没有必然联系。

现在 WKY 同学请你帮忙，计算在老王规定的时间内，WKY 所能得到最大奖励值是多少 。


## 说明/提示

对于 $100 \%$ 的数据，$1 \leq n, m \leq 100$，规定时间 $\leq 5000$。$1 \leq p \leq n$，$1 \leq q \leq 1000$。

## 样例 #1

### 输入

```
1 2
6 4
1 2 3 4
1 5
2 6
3 3
4 8
3 3
4 5
20```

### 输出

```
22```

# 题解

## 作者：林家三少 (赞：167)

### 蒟蒻刚学dp(没错就是这么蒻)，然后就看到了这道题，所以就有了这篇题解qwq

一开始我还不懂为什么要输入**老王和$WKY$的水平值**、**老王做知识点$i$的时间**，后来~~看了题解~~问了同学才知道，原来是：

通过**老王和$WKY$的水平值**和**老王做知识点$i$的时间**来求出$WKY$**做知识点$i$的时间**

如果我们只看$WKY$**拥有时间**、**题目所属的知识点**、**题目对应的奖励值**，然后求**能到得到的最大奖励值**，

然后这就变成了一道简单的$dp$题

所以现在当务之急就是求出$WKY$**做各个知识点的时间**

根据

	如果WKY的水平值是1，老王的水平值是2，那么WKY做同一道题的时间就是老王的2倍。
    
这句话，还有

	老王的水平值是WKY的水平值的整数倍。
    
这句话的保证，我们可以推出这个公式：

	WKY做知识点i的时间=老王做知识点i的时间*(老王的水平值/WKY的水平值)
    
然后再把$dp$**转移方程**求出来：

$f[j]=max(f[j],f[j-t2[p[i]]]+q[i]);$

其中$t2[p[i]]$也就是$WKY$做第$i$道题的时间，因为$p[i]$是第$i$道题的知识点，而$t2[]$是$WKY$做知识点的时间，最后把完整代码附上：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int a,b;
int n,m;
int t1[5000+10],t2[5000+10];
int t;
int p[5000+10],q[5000+10];
int f[5000+10];
//标准的dp数组
int main(){
	cin>>a>>b;
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>t1[i];
		t2[i]=t1[i]*(b/a);
        //这里也就是根据老王做知识点i来求出WYK做知识点i的时间
	}
	for(int i=1;i<=m;i++){
		cin>>p[i]>>q[i];
        //开始输入知识点和奖励
	}
	cin>>t;
	for(int i=1;i<=m;i++){
		for(int j=t;j>=t2[p[i]];j--){
			f[j]=max(f[j],f[j-t2[p[i]]]+q[i]);
            //标准的dp转移方程
		}
	}
	cout<<f[t];
    //最后在输出答案
	return 0;
}
```
~~看在我打了那么多字的份上，点个赞再走吧~~



---

## 作者：Herkezi (赞：28)

蒟蒻觉得这个背包很简单，于是准备发个题解。=.=！好吧这并没有什么联系。

这道题其实没有什么难点，注意奖励值是单独每道题目的奖励值，跟知识点无关！无关！无关！重要的事情说三遍！

详解见代码：
```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<vector>

using namespace std;

int t[5005],zsd[5005],reward[5005],f[5005];  //定义数组。

int main()

{

	int s1,s2,m,n,i,j,time;  //定义。
    
	cin>>s1>>s2>>m>>n;    //读入两人水平值、题目的总数m和知识点的总数n。
    
	for (i=1;i<=n;i++) cin>>t[i],t[i]*=s2/s1;  
    //读入老王在做第i个知识点的题目所需的时间。并计算WKY在做第i个知识点的题目所需的时间（因为两人速度与水平值成反比，如果你不知道反比那就没办法=.=！）。
    
	for (i=1;i<=m;i++)  
    
	cin>>zsd[i]>>reward[i];   //读入知识点（zsd）和奖励值（reward）。
    
    cin>>time;  //总时间。
    
    for (i=1;i<=m;i++)    //双重循环。
    
        for (j=time;j>=t[zsd[i]];j--)    
        //注意是从总时间到第i道题的时间。另外zsd[i]是t数组的下标，表示zsd[i]这个知识点所需的时间，运用了桶的思想。
        
            f[j]=max(f[j],f[j-t[zsd[i]]]+reward[i]);    //状态转移方程。
            
    cout<<f[time];    //输出。
    
	return 0;    //大功告成。
    
}
```



---

## 作者：鲸与梦之歌 (赞：9)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[5003],f[5003],c[5003],v[5003];//c 花费 v 价值
int main()
{
    int s,d,m,n,z;//s 学生水平值 d 老师水平值
    cin>>s>>d;
    int b=d/s;//b 学生花费时间的倍数
    cin>>n>>z;// n 题数 z 知识点数量
    for(int i=1;i<=z;i++)
        cin>>a[i];// 老师花费时间
    for(int i=1;i<=n;i++){
        cin>>c[i]>>v[i];
        c[i]=a[c[i]]*b;// 学生花费时间
    }
    cin>>m;// 规定时间
    for(int i=1;i<=n;i++){
        for(int j=m;j>=c[i];j--){
            f[j]=max(f[j-c[i]]+v[i],f[j]);//01背包主体  f 总价值
        }
    }
    cout<<f[m];// 输出
}
```

---

## 作者：Mystery_Sky (赞：5)

第一眼看这道题。。。啊哈，啥？？？

仔细看一看，发现：诶， 这不是01背包吗？

两人水平值的比值*老王做题用时  可以算出WKY做每道题的用时。
那么每道题的p就可以转换成费用c[i], 价值q就是w[i]

这么一来， 这道题就转化成了在一定大小的背包内（即规定时间内）可以装下的最大价值的物品， 这样， 就是一道01背包的问题了。


代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
//Benjamin
//
int dp[100010];
int n, m, v;
int c[100010], w[100010];
int a[100010];
int p1, p2, b;
int main() {
    scanf("%d%d", &p1, &p2);
    b = p2 / p1;//水平值的倍数
    scanf("%d%d", &m, &n);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        a[i] *= b;//计算出WKY做每道题的时间
    }
    for(int i = 1; i <= m; i++) {
        scanf("%d%d", &c[i], &w[i]);
        c[i] = a[c[i]];
    }
    scanf("%d", &v);
    
    //01背包
    for(int i = 1; i <= m; i++) {
        for(int j = v; j >= c[i]; j--) {
            dp[j] = max(dp[j], dp[j-c[i]] + w[i]);
        }
    }
    printf("%d\n", dp[v]);
    return 0;
}

```

---

## 作者：Corrine (赞：4)

好吧，在教练的要求下，我不得不写题解。
这道题呢，刚刚看着脑子很乱，什么老王什么wky的，结果发现：这就是拐了几个弯的[**采药**](https://www.luogu.org/problemnew/show/P1048)嘛！只要在前面预处理一下就好了！

因为他们水平值的比值和做这些题所用时间的比值成反比。
所以
```cpp
	lw=lw/wky;
```

然后在后面输入每个知识点老王需要用的时间，就直接乘以上面的变量就好了！
```cpp

	for(int i=1;i<=n;i++)
	{
		scanf("%d",&z[i]);
		z[i]=z[i]*lw;
	}
```
随后，再把知识点的序号再覆盖成wky用的时间就好了！
```

	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&p[i],&q[i]);
		p[i]=z[p[i]];
	}
```
下面是完整代码：
```
#include<cstdio>//头文件
#include<cstring>//头文件
int max(int x,int y){return x>y?x:y;}//手打max函数
int lw,wky;//lw表示老王的能力值，wky表示wky的能力值
int m,n;//前面m,n表示n个知识点，m道题，后面n表示
int z[5010],p[5010],q[5010];、
//z存的是老王做一道知识点标号为i的时间，p是第i道题要用的知识点编号，q是这道题的价值
int f[5010]={0};
int main()
{
	scanf("%d%d",&wky,&lw);//输入
	lw=lw/wky;//求出wky做一题的时间是老王的多少倍
	scanf("%d%d",&m,&n);//输入
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&z[i]);
		z[i]=z[i]*lw;//求出wky要用的时间
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&p[i],&q[i]);
		p[i]=z[p[i]];//求助老王这道题要用的时间
	}
	scanf("%d",&n);//输入总时间
	for(int i=1;i<=m;i++)
	{
		for(int j=n;j>=p[i];j--)
		{
			f[j]=max(f[j],f[j-p[i]]+q[i]);//DP转移方程
		}
	}
	printf("%d",f[n]);//输出
}
```


---

## 作者：奔跑的小蜗牛 (赞：2)

### 做完题后翻了翻题解，发现没有用这种方法的，望管理员通过。
这道题很明显的01背包问题，但做题的时候突然萌生了一种不想写~~烦人的~~状态转移方程的想法，于是乎，写下了这个函数（详解如下，相信大家学01背包的时候肯定都学过这个函数）。
```cpp
int B(int k, int T)
{
    if(k == 1)
    {
        if(times[zhishi[k]] > T)
            return 0;
        else
            return jiangli[k];
    }
    if(times[zhishi[k]] > T)
        return B(k - 1, T);
    else
        return max(B(k - 1, T - times[zhishi[k]]) + jiangli[k], B(k - 1, T));
}
```

函数B（k, T）的返回值表示在做前k道题时可以获得的最大奖励值，T表示在做前k道题时剩余的时间。函数的递归出口很显然是k = 0，也就是只剩一道题时，看看剩余的时间能不能完成这道题，如果能，就返回获得的奖励，不能就返回0。
其他情况下只需要比较做第k道题还是不做第k道题即可，但有一种特殊情况，就是当前时间无法做这道题，那么直接跳过，跟选择不做是一样的。

附上AC代码：
```cpp
#include <iostream>
using namespace std;

int times[5005]; //对应知识点所用的时间
int jiangli[5005]; //每个题目的奖励
int zhishi[5005]; //每个题目对应的知识点

int B(int k, int T)
{
    if(k == 1)
    {
        if(times[zhishi[k]] > T)
            return 0;
        else
            return jiangli[k];
    }
    if(times[zhishi[k]] > T)
        return B(k - 1, T);
    else
        return max(B(k - 1, T - times[zhishi[k]]) + jiangli[k], B(k - 1, T));
}

int main()
{
    int a, b, m, n;
    cin >> a >> b;
    cin >> m >> n;
    for(int i = 1; i <= n; i++)
    {
        int t;
        cin >> t;
        times[i] = t * b / a;//注意把老王需要用的时间转换成WKY的时间
    }
    for(int i = 1; i <= m; i++)
    {
        int p, q;
        cin >> p >> q;
        zhishi[i] = p;
        jiangli[i] = q;
    }
    int t;
    cin >> t;
    cout << B(m, t);
    return 0;
}

```



---

## 作者：睿屿青衫 (赞：2)

#改题处理一下就是简单的01背包问题

##之前输出怎么都不对，最后发现有个字母打错了，还有两个坑（易错点）：

###①每道题都有单独的奖励值，看不仔细的话可能会想成知识点的奖励值

###②m行更新那里，题目时间和知识点时间一定要分开，注释的很清楚了

#代码如下（看看就好，不要照搬）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 5010
int st,te,k,m,ti,n,t[maxn],f[maxn],p[maxn],tt[maxn];
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin>>st>>te;k=te/st;//k是老王比学生的值 
    cin>>m>>n;//m道t和n个知识点 
    for(int i=1;i<=n;++i)
     {
         cin>>tt[i];
         tt[i]*=k;//老王做i个知识点的时间*k就是学生的 
     }
    for(int i=1;i<=m;++i)
     {
         int x,y;
         cin>>x>>p[i];
         t[i]=tt[x];//更新该题目的时间,易错：知识点和题的时间一定要分开处理，不然的话知识点时间会被更新错！！ 
     }
    cin>>ti;//读入规定时间，f表示时间内最大奖励
    for(int i=1;i<=m;++i)//枚举每个题目 
     for(int j=ti;j>=t[i];--j)//01背包 
      f[j]=max(f[j],f[j-t[i]]+p[i]);//01背包状态转移方程 
    printf("%d",f[ti]);//规定时间内最大奖励值 
    return 0;
}
```

---

## 作者：minecraft_herobrine (赞：2)


这题是一个典型的01背包DP，用t[i]记录wky的做题时间，注意输入时t[i]表示老王的做题时间，这里需要把他转换成wky的时间。
```cpp
#include<彼此/爱死踢地塞加加点爱吃>
using namespace std;
int t[5010],w[5010],c[5010],dp[5010];
int 面()
{
    因特 wky,lw,n,v,m,i,j;
    scanf("%d %d",&wky,&lw);
    scanf("%d %d",&m,&n);
    for(i=1;i<=n;i++)//共n个知识点 
    {
        scanf("%d",&t[i]);//老王做这些知识点的题的用时 
        t[i]=t[i]*(lw/wky);//wky和老王的做题时间与他们的水平值成反比 
        //计算wky做每道题的用时 
    }
    for(i=1;i<=m;i++)
    {
        scanf("%d %d",&w[i],&c[i]);
        w[i]=t[w[i]];//将预处理的结果转移到w 
    }
    scanf("%d",&v);//老王的限定时间 
    for(i=1;i<=m;i++)//总共有m道题 
        for(j=v;j>=w[i];j--) dp[j]=max(dp[j],dp[j-w[i]]+c[i]);//选择这道题做还是不做 
    printf("%d",dp[v]);//dp[i]表示当限时为i时,wky做多能得到的奖励值 
    return O;
}
```







-------------

# 严禁作弊！代码内有反作弊字符！

---

## 作者：Blue_wonders (赞：1)

## 01背包AC，简单的转化就可以完成
#### 这道题没有什么坑，自己一遍就A掉了，点就好
#### 基本思路
1. 先输入两个人的比值，将比值化到最简学生一定为1，老师一定是整数(题目说这俩是倍数关系)
2. 输入老师某个知识点的时间，用数组存起来，将每个知识点的时间都乘以比值，那么这个时间就是学生做题的时间
3. 然后套用01背包公式，重量是做题的时间，价值是老师给的奖励值，滚动数组刷新
4. 最后输出最后一个值就可以A掉这道题
#### 然后是代码
[AC代码详情](https://www.luogu.org/recordnew/show/16501865)

```cpp
#include<bits/stdc++.h>
using namespace std;
struct WKY{//结构体定义每个题的重量(写题时间)以及价值(奖励值) 
	int w,c;
} p[5001];
int q[5001],d[5001],a,b,n,m,s;
int main(){
	cin>>a>>b>>n>>m;//a,b为老师学生比值，n,m为题目数量/题目类型 
	b=b/a;a=1;//化为最简分数(因为题目说是整数倍数，学生<=老师，所以学生一定是1) 
	for(int i=1;i<=m;i++){ 
		cin>>q[i];//输入每个题型老师解题时间
		q[i]=q[i]*b;//老师解题时间乘最简倍数就是学生的做题时间 
	}
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;//输入每个题的类型和奖励值 
		p[i].w=q[x];//重量(写题时间)=该类型学生的做题时间 
		p[i].c=y;//赋值奖励值 
	}
	cin>>s;//输入一共多少时间 
//背包问题的模板(滚动数组) 
	for(int i=1;i<=n;i++){//循环题(每循环一次就多一种选择) 
		for(int j=s;j>=p[i].w;j--){ 
			d[j]=max(d[j],d[j-p[i].w]+p[i].c);//取max(不选当前选择后的奖励值，选当前选择的奖励值) 
		}
	}
	cout<<d[s];//输出最大值(就是最后的结果)
	return 0;
} 
```
感谢大家能看我的题解~！

---

## 作者：wind_cross (赞：1)

	本题除了预处理有点麻烦，本质就是道裸的01背包
    数据也是真水，二维数组都不会炸,碰巧也没有人写c++二维的背包
    下面上代码：
    #include <bits/stdc++.h>//懒人标配万能头
	using namespace std;
	int f[5005][5005],c[5005],w[5005],e[5005];
    //f存最终结果，w存时间（相当于物品质量），c存每题的奖励（相当于物品价值），e是每个知识点的奖励
	int max(int q,int d){
	return q>d? q:d;
	}//自定义比较函数
	int main()//开始主程序
	{
	int a,b;
	cin>>a>>b;//输入两人的水平值
	int m,n;
	cin>>m>>n;//输入题目的总数m和知识点的总数n
	for(int i=1;i<=n;i++){
		cin>>e[i];
		e[i]*=(b/a);
	}//将老王用的时间转为WKY用的时间（其实就是用老王的时间去除以WKY的时间）
	for(int i=1;i<=m;i++){
		cin>>w[i]>>c[i];
	}//输入每题的知识点(后面会改为每题的所需时间)和每题的奖励
	for(int i=1;i<=m;i++){
		w[i]=e[w[i]];
	}//预处理，将每题所需要的时间存进数组，因为w先存了题目对应的知识点，e又存了每个知识点需要的时间，所以e[w[i]]就是每题的所需时间
	n=m;//先将n改为时间
	cin>>m;//再输入总时间（相当于背包容量）
	for(int i=1;i<=n;i++){
		for(int v=m;v>=0;v--){
			if(v>=w[i])f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]);//01背包标准状态转移方程(普及一下，一般带max或min的都是dp，直接赋值的一般是递推)
		}
	}
	cout<<f[n][m];//输出结果（01背包的特点，结果永远存在f[时间][容量]这里）
    return 0;//华丽的结束程序
	}
	已经改三遍了，详细许多了，管理员大大求过啊！！！


---

## 作者：xukuan (赞：1)

直接用01背包

有人说二维数组会超，然而并没有：

时间：0ms

内存：100605KB


```pascal
uses math;

var
 Wky,MrWang,n,m,i,j,t:longint;
 time,q,p:array[0..5010] of longint;
 f:array[0..5010,0..5010] of longint;
begin
 readln(Wky,MrWang);//两个人的水平
 readln(m,n);
 for i:=1 to n do
  read(time[i]);//老王做每个知识点的时间
 for i:=1 to m do
  begin
   readln(p[i],q[i]);
   p[i]:=time[p[i]]*(MrWang div Wky);//将老王做题时间改为Wky做题时间
  end;

 readln(t);
 for i:=1 to m do
  for j:=1 to t do
   begin
    f[i,j]:=f[i-1,j];
    if j>=p[i] then f[i,j]:=max(f[i,j],f[i-1,j-p[i]]+q[i]);//dp的状态转移方程
   end;
 writeln(f[m,t]);
end.
```

---

## 作者：ModestCoder_ (赞：0)

这题目难！！！

难在题目太长==

非常简单的一个01背包

只是先算好每个知识点所需的时间

通过比例式：wky能力值/老王能力值=老王时间/wky时间

所以wky时间=老王能力值\*老王时间/wky能力值

背包部分不废话了吧



```cpp
uses math;
var
    a,x,y,f:array[0..1000000] of longint;
    wky,wang,n,m,i,j,time:longint;
begin
    readln(wky,wang);
    readln(n,m);
    for i:=1 to m do
        begin
            read(a[i]);
            a[i]:=a[i]*(wang div wky); //处理时间
        end;
    for i:=1 to n do
        readln(x[i],y[i]);
    readln(time);
    for i:=1 to n do
        for j:=time downto a[x[i]] do
            f[j]:=max(f[j],f[j-a[x[i]]]+y[i]);
    writeln(f[time]);
end.
```

---

## 作者：VenusM1nT (赞：0)

比较水的一题，难度在于DP之前的预处理上

要怎样将难度值转换为WKY所需的时间还是需要经过一番思考的

具体方法是：**WKY所需的时间=难度值\*(老王的能力值/WKY的能力值)**

状态转移方程则为 $f[j]=max(f[j],f[j-w[i]]+c[i])$

答案则在f[v]的地方

具体见代码



```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int wky,wang,n,v,m,t[5005],w[5005],c[5005],f[5005];//nm分别存储知识点数和题目数，t数组则存储 道题的知识点，最终将知识点转换为时间长度储存在w数组中 
int main()
{
    scanf("%d%d",&wky,&wang);
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&t[i]);
        t[i]=t[i]*(wang/wky);//一开始所说的预处理中的一部分，将每个知识点对老王来说所需的时间长度转换为对于WKY来说的时间长度 
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&c[i]);
        w[i]=t[w[i]];//第二步预处理，将读入的知识点转换为之前已经算好的时间长度 
    }
    scanf("%d",&v);
    for(int i=1;i<=m;i++)
    {
        for(int j=v;j>=w[i];j--) f[j]=max(f[j],f[j-w[i]]+c[i]);//愉快的01背包 
    }
    printf("%d",f[v]);//答案储存在f[v]的位置，也是01背包经典的特点 
    return 0;
}
```

---

## 作者：reburn (赞：0)

从题目中可以看出我们要控制的是做题时间，是要输出最大分数，这样就可以明白程序的大体框架，更容易去想。明白了这一点整个程序就非常简单了，就是01背包问题。控制的时间因为是水平值的反比，所以有：a[p[i]]\*(level2(老王) div level1（学生）);

```cpp
program ex;
var level1,level2,m,n,i,j,k:longint;
a,p,q:array[1..10000] of longint;
f:array[0..10000] of longint;
function max(x,y:longint):longint;
begin
 if x>y then max:=x
 else max:=y;
end;
begin
 read(level1,level2);
 readln(m,n);
 for i:=1 to n do read(a[i]);
 for i:=1 to m do read(p[i],q[i]);
 read(k);
 for i:=1 to m do
 for  j:=k downto a[p[i]]*(level2 div level1)  do
  begin
   f[j]:=max(f[j-a[p[i]]*(level2 div level1)]+q[i],f[j]);//状态转移方程
  end;
 write(f[k]);
end.

```

---

## 作者：Suiseiseki (赞：0)

#很简单的背包，居然没有C++的题解，我就来骗个贡献（划掉）

具体思路就是01背包，加一个处理就行了：

#include <cstdio>

int maxn(int a,int b){

    return a>b?a:b;

}//个人习惯

```cpp
int a[5005],b[5005],t[5005],f[5005];
int main(){
    int zc,lw,m,n;
    scanf("%d%d%d%d",&zc,&lw,&m,&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&t[i]);
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d",&b[i],&a[i]);
        b[i]=t[b[i]];//处理
    }
    int time;
    scanf("%d",&time);
    time=time*zc/lw;
    for(int i=1;i<=m;i++){
        for(int j=time;j>=b[i];j--){
            f[j]=maxn(f[j],f[j-b[i]]+a[i]);//01背包
        }
    }
    printf("%d\n",f[time]);//输出，结束
    return 0;
}
```
蒟蒻代码，不喜勿喷。

---

## 作者：tyxx (赞：0)

恩，这道题目确实是01背包，但是也可以用暴搜解决

附代码：

```delphi

type
  node=record//一个人的信息
    level:integer;//这个人的水平值
    time:array [0..5001] of integer;//time[i]是这个人做第i道题目所花费的时间
  end;

var
  wky,wang:node;
  m,n,MaxTime,ans:integer;
  id,reward:array [0..5001] of integer;

procedure init;//输入数据
var i:integer;
begin
  readln(wky.level,wang.level);
  readln(m,n);
  for i:=1 to n do
  begin
    read(wang.time[i]);
    wky.time[i]:=wang.time[i]*(wang.level div wky.level);//用水平值关系计算
  end;
  readln;
  for i:=1 to m do readln(id[i],reward[i]);
  readln(MaxTime);
  ans:=0;
end;

procedure dfs(k,NowReward,NowTime:longint);//暴搜
//k是当前选到第几道题，NowReward是积累的奖励，NowTime是耗的时间
begin
  if NowTime>MaxTime then exit;
//注意合法性的判断，如果该方案所花费的总时间超出了规定时间，则剪枝
  if NowReward>ans then ans:=NowReward;//记录最优值
  if k>m then exit;//边界条件
  dfs(k+1,NowReward+reward[k],NowTime+wky.time[id[k]]);//做第k道题目
  dfs(k+1,NowReward,NowTime);//不做第k道题目
end;

begin
  init;
  dfs(1,0,0);
  writeln(ans);
end.

```
最后，还是希望大家用dp的方法也把这道题做一下，能锻炼自己的多向思维


---


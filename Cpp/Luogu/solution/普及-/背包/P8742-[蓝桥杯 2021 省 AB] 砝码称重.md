# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# 题解

## 作者：while_true (赞：87)

## 经典 01 背包题  
- 首先介绍一下 **01 背包**，即一种 DP 问题，以放置物品为模型，每个物品只能放一次。其区分于**完全背包**（每个物品可以放无限多次），以及**多重背包**（每个物品有一个固定次数上限）。题中给出了 $ N $ 个砝码及每个砝码的质量，要求我们求出可以称出质量的种数。由此想到转化为 **01 背包**。   
- 本题作为 01 背包的模板题之一，其思想不难（前提是你掌握了 01 背包写法）。但是有几个坑点： 
1. ~~上过初一的人都知道左物右码，这个题出的很不科学。~~ 题中重点是**天平两边都能放砝码**，显然，由于天平两边放砝码的质量不一定相等，所以要在较轻一侧放一个一定质量的物体使其平衡。所以显然地，设物体质量为 $ m_{thing} $，左盘砝码质量为 $ m_l $，右盘砝码质量为 $ m_r $，则有：

$$
\left\{ 
\begin{array}{c}
    m_{thing}+m_l=m_r (m_l\le m_r)\\
    m_{thing}+m_r=m_l (m_l\ge m_r)
    
\end{array}
\right. 
$$  

即为: 

$$
	m_{thing}=|m_l-m_r|
$$
2. 注意 dp 方程转移时要从大到小转移，否则存在越界。


## 代码构造
- 说了这么多，代码怎么写？有了以上结论，这变得容易了些：我们不妨设状态 $ f_{i,j} $ 表示枚举到第 $ i $ 个砝码时是否能够称出质量 $ j $。  
**但是为什么这么设呢？** 有些人摸不着头脑。我们不妨这么想：线性 DP 本身是要以线性方式转移状态，本题中可以看作枚举每个砝码，因此状态定义中存在砝码（即 $ i $）。本题是要求 **情况总数** ，所以我们想到一个类似于桶标记的方法定义状态（即定义 $ j $ 质量）。  
- 那怎么写双重循环呢？外层循环很显然是枚举每个砝码，即将 $ i $ 从1枚举到 $ n $，但内层循环呢？其实也很简单，因为我们之前定义了 $ j $ 为枚举质量，所以我们可以将 $ j $ 从1开始枚举，枚举到所有砝码质量总和（因为质量最大就是砝码质量总和）。
- 因此，易推得 $ f_{i,j} $ 如何转移:
1. 如果枚举到当前的砝码不放，那么对于枚举到的每一个质量，其情况都与枚举到上个砝码时的情况相同，且此方案显然是否可行取决于上一个方案是否可行。 即 $ f_{i,j} = f_{i-1,j} $。  
2. 如果之前一个砝码也没放，现在枚举到的砝码是第一个放的（即当前枚举到的 $ j $ 就是当前枚举到的砝码质量），那么这种方案显然可行，因此 $ f_{i,j}=1(j=W_i) $。
3. 另外的情况，我们需要分类讨论：  
**第一种情况：** 将当前枚举到的砝码放置在右盘，右盘质量为 $ j $，那么显然还没有放置时右盘质量为 $ |j-W_i| $。为什么加绝对值，是因为上一个砝码有可能放在左盘或右盘（这里枚举 $ j $ 为右盘质量），所以只要上一个砝码能称出 $ |j-W_i| $ 的质量，当前砝码就可以称出 $ j $ 的质量。 即当 $ f_{i-1,|j-W_i|}=1 $ 时，$ f_{i,j} = 1 $。   
**第二种情况：** 将当前枚举的砝码放在左盘，那么类似地，当 $ f_{i-1,j+W_i}=1 $时，$ f_{i,j}=1 $。  
    
>因此，本题就很清楚了。至于具体代码……相信您可以凭自己实力写出来！  

求过（小声）    
- Update_2023.1.29 增加了描述；
- Update_2023.2.1 更改 $ \LaTeX $ 的排版。
- Update_2023.2.2 在数字和汉字间加空格（笑）。
- Update_2024.9.26 退役快一年后重回洛谷发现 $\LaTeX$ 炸了于是做了修改。

---

## 作者：ryf_loser (赞：62)

此题用动态规划可以过。

但是此题动态规划比较简单，通过对题目的分析，我们可以得到四个状态：

1. 如果 `j==w[i]`，说明可以正好一个砝码 `dp[i][j]=1`。
1. 如果 `dp[i-1][j]==1`，说明可以不变砝码 `dp[i][j]=1`。
1. 如果 `dp[i-1][j+w[i]]==1`，说明可以加一个砝码 `dp[i][j]=1`。
1. 如果 `dp[i-1][abs(j-w[i])]==1`，说明可以减一个砝码 `dp[i][j]=1`。

AC CODE

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n,ans,sum,w[101],dp[101][100001];
int main(){
    scanf ("%d",&n);
    for(int i=1;i<=n;i++){
        scanf ("%d",&w[i]);
        sum+=w[i];
    }
    for(int i=1;i<=n;i++){
		for(int j=sum;j;j--){
            if(j==w[i])dp[i][j]=1;
            else if(dp[i-1][j])dp[i][j]=1;
			else if(dp[i-1][j+w[i]])dp[i][j]=1;
            else if(dp[i-1][abs(j-w[i])])dp[i][j]=1;
        }
	}  
    for(int i=1;i<=sum;i++)if(dp[n][i])ans++;
    printf ("%d",ans);
    return 0;
}
```



---

## 作者：123xiayicheng (赞：47)

简单版（P2347）[传送门](https://www.luogu.com.cn/problem/P2347)

原题[传送门](https://www.luogu.com.cn/problem/P8742)

有一道**类似**的题目（P2347），先扯一扯~

------------

# 1.P2347

## 题目分析

动态规划入门题（01背包**可行性问题**）~

我们**设** $dp_j$ **为能否用砝码称出** $j$ **重量**，1 为**可以**，0 为**不可以**。

 - 为了转移，**$dp_{_{0}} \gets 1$**，**什么都不放时，重量为 0**，因此可以称出。

那么**枚举** $dp_{_{1}} \sim dp_{sum}(sum$ 为砝码可称出的**最大重量**$)$。

 - **如果** $j-w$ **可以称出**，且重量为 $w$ 的砝码**存在**、**未超出个数限制**，则 $j$ **可以称出**。即 $dp_j = dp_{j - w}(j - w \geqslant 0)$

![](https://cdn.luogu.com.cn/upload/image_hosting/1pjuewot.png)

那么**动态转移方程**显而易见：

 - $dp_j = dp_{ j - a_i \times k} (j - a_i \times k \geqslant 0 , k \leqslant b_i)$

**PS：**$a_i$：砝码 $i$ 的**重量**，$b_i$：砝码 $i$ 有的**个数**。

## **代码**  

```cpp
#include<bits/stdc++.h>
using namespace std;
int n = 6, ans = 0, sum = 0;
int dp[1100], a[10] = {0, 1, 2, 3, 5, 10, 20}, b[200];
int main()
{
	fill(dp, dp + 1100, 0);
	for (int i = 1; i <= n; i++) cin >> b[i], sum += a[i] * b[i];
	dp[0] = 1;
	for (int i = 1; i <= n; i++){
		for (int j = sum; j >= 0; j--){ //反着来，不然会重复
			for (int k = 1; k <= b[i]; k++){ 
				if (dp[j - a[i]*k] == 1 and j - a[i]*k >= 0 and dp[j] == 0)
					dp[j] = 1,ans++;
			}
		}
	}

	cout << "Total=" << ans;
	return 0;
}
```

# 2.P8742

## 题目分析

因为砝码可以放另一边，即**减去这个砝码的重量**，所以**反着还要再来遍历一遍。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8axi1b2.png)

**如果** $dp[j] + a[i] = 1$ **那么** $dp[j] \gets 1$ **。**

**转移方程：**

 - $dp_j = dp_{ j - a_i } (j - a_i \geqslant 0)$

 - $dp_j = dp_{ j + a_i } (j + a_i \leqslant sum)$

## **代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100010], a[110];
long long sum = 0, ans = 0;
int main()
{
	int n;
	cin >> n;
	fill(dp, dp + 100010, 0);
	dp[0] = 1;
	for (int i = 0; i < n; i++)
		cin >> a[i], sum += a[i];
	for (int i = 0; i < n; i++){
		for (int j = sum; j >= a[i]; j--){ //优化，不枚举i<a[j]的情况
			if (dp[j - a[i]] == 1 and dp[j] != 1)
				dp[j] = 1, ans++;
		}
	}
	for (int i = 0; i < n; i++){
		for (int j = 1; j <= sum - a[i]; j++){ //同理
			if (dp[j + a[i]] == 1 and dp[j] == 0)
					dp[j] = 1, ans++;
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：FstAutoMaton (赞：15)

一道很简单的背包问题。

首先我们要知道一些基本常识。题目说砝码可以放在天平的左侧和右侧，那么我们当前可以称出的重量就是**左侧砝码的总重量与右侧砝码的总重量之差的绝对值**。

那么我们可以把当前称出来的重量作为 ```DP``` 的状态。设 $f_{i,j}$ 表示现在处理到了第 $i$ 个砝码，称出来的重量为 $j$，再设 $a_{i}$ 为第 $i$ 个砝码的重量，那么我们每次想要把砝码放在左侧就让 $j$ 加上 $a_{i}$，想要放在右侧就用 $j$ 减去 $a_{i}$，由此可以得到转移方程：
$$f_{i,j}=f_{i-1,j+a_i} \lor f_{i-1,\left\vert a_i-j\right\vert} \lor f_{i-1,j}$$

最后再从 1 去枚举所有重量，如果当前重量存在（也就是 $f_{n,j}$ 大于 0）那么答案数就增加。代码如下：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 105, maxv = 1e5 + 5;
int n, a[maxn], f[maxn][maxv], sum, ans;
int main()
{
	cin >> n;
	for( int i = 1; i <= n; i ++ )
	{
		cin >> a[i];
		sum += a[i];
	}
	f[0][0] = 1;
	for( int i = 1; i <= n; i ++ )
	{
		for( int j = sum; j >= 0; j -- )
		{
			f[i][j] |= f[i - 1][j];
			f[i][j] |= f[i - 1][abs( j - a[i] )];
			if( j + a[i] <= sum )
				f[i][j] |= f[i - 1][j + a[i]];
		}
	}
	for( int i = 1; i <= sum; i ++ )
		ans += f[n][i];
	cout << ans;
}
```

---

## 作者：loser_seele (赞：13)

前置知识：01 背包，bitset 优化 DP 转移。

这是一个 01 背包裸题。

不难想到转移如下：

```
dp[j]|=dp[j-a[i]],dp[j]|=dp[j+a[i]]
```

这是显然的，表示当前凑出 $ j $ 依赖于把砝码放在左边，右边，不放三种决策，注意上面已经加了滚动数组优化。

然后不难发现这个转移在位运算中下标减相当于右移，下标加相当于左移，所以涉及的所有操作都是位运算，于是直接上 bitset 优化 DP，将转移过程的加减改成位运算即可。

时间复杂度 $ \mathcal{O}(\frac{n\sum a_i}{w}) $，可以通过。目前最短代码 188B，如果有短于这个长度的可以私信找我。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110],n;
bitset<100010>d;
signed main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    d.set(0);
    for(int i=1;i<=n;i++)
    	cin>>a[i],d|=d<<a[i];
    for(int i=1;i<=n;i++)
    	d|=d>>a[i];
    cout<<d.count()-1;
}
```


---

## 作者：RP_INT_MAX (赞：11)

## $\textbf{Solution}$

很明显，一眼能看出来是 DP，01 背包的可行性问题。

我们设 $f_{i,j}$ 表示前 $i$ 个砝码中，是否存在选取若干砝码组合成重量为 $j$ 的方案。$f_{i,j}=0$ 表示没有，$f_{i,j}=1$ 表示有。

再思考转移方程。我们有如下三种情况：

- 第 $i$ 个砝码不选：$f_{i-1,j}$

- 第 $i$ 个砝码选了，且放在前方砝码的**同侧**：$f_{i-1,j+W_i}$

- 第 $i$ 个砝码选了，且放在前方砝码的**异侧**：$f_{i-1,j-W_i}$

所以不难得出转移方程：

$$
f_{i,j}=\left\{
\begin{aligned}
1\ \ \ \ \ &(f_{i-1,j+W_i}=1) \lor (f_{i-1,j-W_i}=1) \lor (f_{i-1,j}=1)\\
0\ \ \ \ \ &\text{Otherwise}
\end{aligned}
\right.
$$

上式中 $\lor$ 表示或。

考虑到如果 $j < 0$，那么会出现很严重的下标越界，我们将所有的 $j$ 全部加上一个偏移值，结果不变。

初始化：由于不耗用一个砝码时重量为 $0$，因此 $f_{0,0}=1$。

时间复杂度 $O(n \sum W_i)$ 似乎不能再优化了，~~所以我们来卡点空间~~，使用滚动数组或者压掉一维。

## $\textbf{Code}$

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=150000; // N 是偏移值，防止负下标
int n,sum,w;
bool f[2][300010];
int main () {
	scanf("%d",&n);
	f[0][N]=1;
	for(int i=1;i<=n;++i) {
		scanf("%d",&w),sum+=w; // 这里采用在线的方式
		for(int j=-sum;j<=sum;++j)
			f[i&1][j+N]=f[i-1&1][j-w+N]||f[i-1&1][j+w+N]||f[i-1&1][j+N];
	}
	int ans=0;
	for(int i=1;i<=sum;++i)
		ans+=f[n&1][i+N];
	printf("%d\n",ans);
	return 0;
}
```

---


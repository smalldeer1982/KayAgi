# [蓝桥杯 2023 国 Java B] 玩具

## 题目描述

小明的妈妈给他买了 $n$ 个玩具，但是为了同时考察他的智力，只给了他 $2 \times n$ 个零件，第 $i$ 个零件的重量为 $w_i$（$1 \leq i \leq 2 \times n$）。

其中任意两个零件都可以拼接成一个玩具，这个玩具的权重就等于拼接所用的 **两个零件的重量的乘积**。小明的妈妈希望小明能够使用这 $2 \times n$ 个零件拼接出 $n$ 个玩具（每个零件必须使用且只能用一次），使得所有玩具的权重的和最小。小明希望你帮帮他计算出最小的权重和。


## 说明/提示

### 样例说明

由于有两个零件的重量都为 $2$，所以一共有两种结果:
- $(2 \times 2) + (3 \times 4) = 16$;
- $(2 \times 3) + (2 \times 4) = 14$。

### 评测用例规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $n \leq 10^5$，$0 \leq w_i \leq 10^5$。

## 样例 #1

### 输入

```
2
2 2 3 4```

### 输出

```
14```

# 题解

## 作者：chen_kun (赞：3)

这道题的话主要需要一个贪心的思想。

### 梳理题意

---

给定 $2n$ 个整数，将它们分成 $n$ 对，使得所有对中两数乘积的和最小。

### 做法介绍


---


先要总和最小，即代表每一对数中两数的乘积最小，那么肯定需要先对这些数进行排序。

那排序后呢？我们可以试试直接将相邻的两个数配对，这样就可以使得乘积小的一组数尽量小。但是这样过于贪心了，因为这会导致成绩大的一组也过于大。

那么我们只能折中选择一种办法：将最小的数与最大的数配对、第二小的数与第二大的数配对……以此类推，再开一个变量 $ans$ 累加每一对中两个数的乘积即可。

### 贪心策略的证明

设排序后数组为 $a₁≤a₂≤...≤a₂ₙ$。根据排序不等式，$a₁a₂ₙ + a₂a₂ₙ₋₁ + ... + aₙaₙ₊₁ ≤$ 其他任何配对方式的和。

### 代码实现



---


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,a[N*2];//有2n个数 
int ans=0;
signed main(){
	cin>>n;
	n*=2;//把n翻倍 
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);//从小到大排序（从大到小排序也行） 
	for(int i=1,j=n;i<=j;i++,j--) ans=ans+(a[i]*a[j]);//将最小的数与最大的数配对、第二小的数与第二大的数……两两配对累加起来 
	cout<<ans;
	return 0;
}
```

---

## 作者：Objective (赞：3)

$\mathbf{upd\ 2025/5/31}$：修正标点，修正语病与小逻辑问题，修正 $\KaTeX$ 中使用符号的不当之处，减少了一些没必要的啰嗦话。

## 思路与算法

### 思路

在写这道题的代码之前，我注意到，既然要使权重和最小，那就不能让大的和大的（权重）相乘，小的和小的（权重）相乘，最后再加起来，这个思路是正确的。


$%#### 即：$

$%#### 1. 小的乘小的、大的乘大的策略：$

$%如果我们按照“小的乘小的”的策略，将较小的零件配对，会导致较大的权重值被直接累加到总和中。$

$%#### 2. 小的乘大的策略：$

$%如果我们采用“小的乘大的”的策略，将最小的零件与最大的零件配对，可以有效地平衡权重的贡献。因为较小的零件与较大的零件相乘，其结果会比两个较大的零件相乘更小。$

——为什么？我们来看一看。

首先，我们看样例说明的操作（策略），发现有这样的规律。

那让我们先来看看简单情况。

首先，设有四个零件重量 $a \le b \le c \le d$，我们比较两种配对方式的权重和：

1. 小的乘小的、大的乘大的：
   $$
   (a \times b) + (c \times d)
   $$
2. 小的乘大的：
   $$
   (a \times d) + (b \times c)
   $$

我们知道，比大小，只要看相减之后，式子是正是负就可以了。

所以，让我们展开并比较 $(a \times b) + (c \times d)$ 与 $(a \times d) + (b \times c) $ 的差值，

为：

$$
(a \times b) + (c \times d) - (a \times d) - (b \times c) = (a \times b) + (c \times d) - (a \times d) - (b \times c)
$$

不完全化简得：

$$
(a \times b) + (c \times d) - (a \times d) - (b \times c) = (a - c) \times (b - d)
$$

由于

$$
a \le b \le c \le d
$$

所以 $(a - c)$ 和 $(b - d)$ 均为非正数，它们的乘积 $(a - c) \times (b - d)$ 为非负数。

即：

$$
\because(a - c) \le 0,(b - d) \le 0
$$

$$
\therefore (a - c) \times (b - d) \ge 0
$$

又

$$
(a \times b) + (c \times d) - (a \times d) - (b \times c) = (a - c) \times (b - d)
$$

因此：

$$
(a \times b) + (c \times d) \ge (a \times d) + (b \times c)
$$

这表明，在零件个数为 $4$ 时，“小的乘大的”的策略总是优于“小的乘小的、大的乘大的”的策略。

接着，我们不断拓宽：$8$ 个零件、$12$ 个零件、$16$ 个零件等。

同时，我们注意到，当 $n$ 取奇数时，第 $(n+1) \div 2$ 组刚好是中间的那一组。  
这时，无论我们选用“小的乘小的、大的乘大的”还是“小的乘大的”的策略，第 $(n+1) \div 2$ 组总是相等的，也就是说，当组数为奇数时，我们可以忽略中间的一组，并把它作为组数为偶数，即零件个数为 $4$ 的倍数的情况来处理。

因此，“小的乘大的”的策略总是优于“小的乘小的、大的乘大的”的策略。

### 算法：

明白了上面的内容，接下来找我们要使用的算法就很简单了。

~~查看算法标签，发现算法为“贪心”、“排序”和“双指针 two-pointer”，所以算法就是用这两个。~~ 

由于我们这里要一定使小的乘大的，因此，我们需要用到贪心的算法。又因为我们要知道什么是小的，什么是大的，我们就需要通过排序，使小的分布在最前面，大的分布在最后面。同时，已经用过的积木不能被第二次使用，我们需要使用双指针来判断我们现在正在计算的积木的重量的下标。

## 代码

由于权重是很多数的乘积的和，所以不要忘了把数据类型开大一点。我令总权重为cnt，让我们试一试最差情况：当 $n$ 最大，$m_i$、$m_j$ 最大时，$cnt=n\times(m_i \times m_j) = 10^5 \times 10^5 \times 10^5 = 10^{15}$。它超过了 `int` 类型的最大值（$%2^{31}-1，$约 $2.14748\times10 ^ 9$），而 `long long` 类型则可以记录（$%2^{63}-1，$约 $9.22337\times10 ^ {18}$）。又因为权重都为非负数，我们可以使用无符号类型。因此，我们在这里可以选用的数据类型（C 与 C++ 环境下）有 `unsigned int`、`long long`、`unsigned long long`。

最后简单附上我的代码：

### C++：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, w[200005], cnt = 0; // cnt 表示权重
int main(){
    scanf("%lld", &n); 
    for(int i = 0; i < 2 * n; i++)
        scanf("%d", &w[i]); 
    sort(w, w+(2*n)); 
    int i = 0, j = 2*n-1; 
    while(i < j){ 
        cnt += w[i] * w[j]; 
        i++, j--;
    }
    printf("%lld", cnt); 
    return 0;
}
```

### C#：

```csharp
using System;
using System.Linq;

class Program
{
    static void Main()
    {
        long n = int.Parse(Console.ReadLine()); 
        long[] w = Console.ReadLine().Split().Select(long.Parse).ToArray(); 
        Array.Sort(w); 
        long cnt = 0; // 权重
        long i = 0, j = 2 * n - 1; 
        while (i < j) 
        {
            cnt += w[i] * w[j]; 
            i++;
            j--;
        }
        Console.WriteLine(cnt); 
    }
}
```

### Java： 

```java
import java.util.Arrays;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong(); 
        long[] w = new long[(int)(2 * n)]; 
        for (int i = 0; i < 2 * n; i++) {
            w[i] = sc.nextLong(); 
        }
        Arrays.sort(w); 
        long cnt = 0; // 权重
        int i = 0, j = (int)(2 * n) - 1; 
        while (i < j) { 
            cnt += w[i] * w[j]; 
            i++;
            j--;
        }
        System.out.println(cnt); 
        sc.close();
    }
}
```

### Python： 

```python
import sys
n = int(input())  
w = list(map(int, input().split()))  
w.sort()  
cnt = 0  # 权重
i, j = 0, 2 * n - 1  
while i < j:  
    cnt += w[i] * w[j]  
    i += 1
    j -= 1
print(cnt)  
```

---

## 作者：Transparent_fish (赞：3)

## 题目描述：

我们需要将 $2n$ 个零件两两配对形成 $n$ 个玩具，每个玩具的权重是两个零件重量的乘积，目标是使所有玩具权重和最小。

## 思路：
1. 要使乘积和最小，应该让最大的数与最小的数配对，次大的与次小的配对，以此类推。我们需要一个数组 $w$ 来表示权重，一个变量 $ans$ 表示权重和。
2. 这种配对方式可以确保不会出现**大数乘大数**的情况，从而**最小化总和**。

## 证明：
对于任意四个有序数 $a \leq b \leq c \leq d$，有以下不等式成立：
$$
ad + bc \leq ac + bd \leq ab + cd
$$

证明：
1. 比较 $ad + bc$ 和 $ac + bd$：
   $$
   (ad + bc) - (ac + bd) = a(d-c) + b(c-d) = (a-b)(d-c) \leq 0
   $$
   因为 $a \leq b$ 且 $d \geq c$，故差值非正。

2. 比较 $ac + bd$ 和 $ab + cd$：
   $$
   (ac + bd) - (ab + cd) = a(c-b) + d(b-c) = (a-d)(c-b) \leq 0
   $$
   因为 $a \leq d$ 且 $c \geq b$，故差值非正。

因此得到不等式链：
$$
ad + bc \leq ac + bd \leq ab + cd
$$

## 解法：
1. 将数组排序。
2. 使用双指针法，一个从头部开始，一个从尾部开始，两两配对。
3. 计算所有配对的乘积和。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
int n;
int ans;//最小代价和
int w[N];

signed main() {
	cin >> n;
	for (int i = 0; i < 2 * n; i++) {
		cin >> w[i];
	}
	sort(w, w + 2 * n);//排序
	for (int i = 0; i < n; i++) {
		ans += w[i] * w[2 * n - 1 - i];//首尾配对
	}
	cout << ans;
	return 0;
}
```

---

## 作者：beicige (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P12218)

# 题意
给出 $2n$ 个数，求两两相乘之和的最小值。

# 思路
我们知道，对于两个数相乘，两个乘数之差越小，乘积越大。反之，**两个乘数之差越大，乘积越小**。

因为题目要求乘积之和最小，所以只要保证每一个乘积都为当下的最小乘积即可。因为要使两个乘数的差尽可能大，所以只需要计算当下的最小值和最大值的乘积。

对数组排序，然后按上述思路求和即可。

注意：要开 long long 类型，数组要开 $n$ 的 $2$ 倍大小。

# Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200010];
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n*2;i++){
		cin>>a[i];
	}
	sort(a+1,a+2*n+1);
	for(int i=1;i<=n;i++){
		ans+=1ll*a[i]*a[2*n-i+1];
	}
	cout<<ans;
} 
```

---

## 作者：LittleHua (赞：3)

## 题目大意
给定 $2n$ 个零件，每个零件有一个重量 $w_i$。需要将它们两两配对成 $n$ 个玩具，每个玩具的权重是两个零件重量的乘积。求所有玩具权重和的最小值。

## 解题思路
### 贪心策略
要使权重和最小，应该让**最小的零件和最大的零件配对**，次小的和次大的配对，以此类推。这样可以避免大的数被多次放大。

### 证明
假设有四个数 $a \leq b \leq c \leq d$，比较两种配对方式：
1. $(a \times d) + (b \times c)$
2. $(a \times b) + (c \times d)$

计算差值：
$(a \times d + b \times c) - (a \times b + c \times d) = a(d - b) + c(b - d) = (a - c)(d - b) \leq 0$

因为 $a \leq c$ 且 $d \geq b$，所以第一种配对方式的和更小。

## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[210000],s;
signed main(){
	cin>>n;
	for(int i=0;i<2*n;i++){
		cin>>a[i];
	}
	sort(a,a+n*2);
	for(int i=0;i<n;i++){
		s+=a[i]*a[2*n-1-i];
	}
	cout<<s;
	return 0;
}
```

## 复杂度分析
- 时间复杂度：$O(n \log n)$，主要由排序决定。
- 空间复杂度：$O(n)$，存储零件重量。

---

## 作者：封禁用户 (赞：2)

不是 Java 题吗，为什么没有 Java 题解？
虽说我主修 c++ 但也略懂一些 Java 。

## 思路
为了使所有玩具的权重和最小，应该将最大的零件与最小的零件配对，次大的与次小的配对，以此类推。

较大的数乘以较小的数，比两个大数相乘或两个小数相乘的和要小，
这样可以避免大的数相乘产生过大的乘积。

## 算法步骤
1. 将零件重量数组排序；
2. 将最大的与最小的配对，次大的与次小的配对，依此类推；
3. 计算所有配对的乘积之和。

### 计算‌：
1. 使用双指针方法，一个指向开头，一个指向末尾；
2. 将最小的与最大的配对，次小的与次大的配对，依此类推；
3. 计算每对零件的乘积并累加。

### 复杂度分析
时间复杂度：$ O(n \log n)$ ，主要是排序的时间复杂度，

空间复杂度：$O(1)$ 
。
## code：


```java
import java.util.Arrays;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[2 * n];      
        for (int i = 0; i < 2 * n; i++) {
            a[i] = sc.nextInt();
        }
        
        Arrays.sort(a);
        
        long b = 0;
        for (int i = 0; i < n; i++) {
            b += (long) a[i] * a[2 * n - 1 - i];
        }
        System.out.println(b);
    }
}

```

---

## 作者：b__b (赞：2)

题目一眼看出贪心，从小到大排序后首尾相乘，于是我们进入到正确性证明环节。
## 证明
对于任意两个元素 $a_0,a_1$，无论如何排序结果都是一样的。

对于一个数组中的任意四个元素 $a_i\leq a_j\leq a_k\leq a_l$，可能的结果有：

$a_ia_l+a_ja_k$，

$a_ia_j+a_ka_l$，

$a_ia_k+a_ja_l$。

对于第一和第二种结果，可得

$\begin{aligned}
a_ia_l+a_ja_k-(a_ia_j+a_ka_l)&=a_i(a_l-a_j)+a_k(a_j-a_l) \\
&=(a_i-a_k)(a_l-a_j)
\end{aligned}
\\
\because a_i\leq a_k,a_j\leq a_l \\
\therefore a_i-a_k\leq0,a_l-a_j\geq0 \\
\therefore a_ia_l+a_ja_k-(a_ia_j+a_ka_l)=(a_i-a_k)(a_l-a_j)\leq0 \\
\therefore a_ia_l+a_ja_k\leq a_ia_j+a_ka_l
$

所以可得第一种结果小于第二种结果。

同理可证 $a_ia_l+a_ja_k\leq a_ia_k+a_ja_l$。

所以可得第一种结果小于第三种结果。

综上所述，选择第一种结果是最优的。
## 有关数据范围
> 对于 $100\%$ 的数据，保证 $n \leq 10^5$，$0 \leq w_i \leq 10^5$。

因此可得最大情况下会有 $2n=2\times 10^5$ 个数据。

所以最大结果为 $10^5\times10^5\times10^5=10^{15}$，超过 int 范围，要用 long long。
## 代码
```cpp
#include <cstdio>
#include <algorithm>
int a[200005], n, i;
int main() {
    long long ans = 0;
    for (scanf("%d", &n), n <<= 1; i < n; ++i) scanf("%d", a + i);
    for (i = 0, std::sort(a, a + n); (i << 1) < n; ++i) ans += 1ll * a[i] * a[n - 1 - i];
    printf("%lld", ans);
}
```

---

## 作者：anyiming (赞：1)

# P12218 [蓝桥杯 2023 国 Java B] 玩具 题解

[题目传送门](https://www.luogu.com.cn/problem/P12218)


## 思路
为了解决这个问题，我们需要将 $2n$ 个零件配对，使得每对零件的乘积和最小。最优的配对方法是：
1. 将零件按重量从小到大排序。
2. 然后将最小的零件和最大的零件配对，第二小的和第二大的配对，依此类推。

这种配对方式能保证乘积尽量小，从而最小化总的权重和。

## cpp
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[200010],n,i;

int main(){
    long long ans = 0;
    
    // 读取输入
    cin >> n;  // 玩具的数量
    n <<= 1;  // 计算零件的数量
    
    // 读取所有零件的重量
    for (i = 0; i < n; ++i){
      cin >> a[i];
    }
    
    // 排序零件的重量
    sort(a, a + n);
    
    // 配对并计算最小权重和
    for (i = 0; (i << 1) < n; ++i){
      ans += 1ll * a[i] * a[n - 1 - i];  // 使用 "1ll" 确保乘积不溢出
    }
    
    // 输出结果
    cout << ans << endl;
}

```
## python

```python
def solve():
    # 读取输入
    n = int(input())  # 玩具的数量
    weights = list(map(int, input().split()))  # 零件的重量列表
    
    # 1. 排序零件的重量
    weights.sort()
    
    # 2. 计算最小权重和
    total_weight = 0
    for i in range(n):
        total_weight += weights[i] * weights[2 * n - 1 - i]
    
    # 3. 输出结果
    print(total_weight)

# 调用解题函数
solve()

```

---

## 作者：PKUS_zmj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12218)
# 思路
不难发现，要使权重和最小，零件重量越大，要乘的零件重量越小，即重量第 $i$ 小乘上重量第 $i$ 大可以使权重和最小。观察数据，可以计算出 $ans$ 最大值为 $10^5×10^5×10^5$，明显超过 int 数据范围，所以要开 long long。
# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin>>n;
    long long a[2*n+5];
    for(int i=1;i<=2*n;i++) cin>>a[i];
    sort(a+1,a+1+2*n);
    long long ans=0;
    for(int i=1;i<=n;i++) ans+=a[i]*a[2*n-i+1];
    cout<<ans;
    return 0;
}
```
勿抄代码！！！

---

## 作者：yihang2011 (赞：0)

## [题解：P12218 [蓝桥杯 2023 国 Java B] 玩具](https://www.luogu.com.cn/problem/P12218)

**提示：这是一篇 C++ 题解**

简单贪心题。

很贪心，样例不太明显，可以举一个例子。

当数组 $w$ 为：

$$
\begin{array}{lcr}
3 & 5 & 6 & 1 & 2 & 4
\end{array}
$$

时，其从小到大排序为：

$$
\begin{array}{lcr}
1 & 2 & 3 & 4 & 5 & 6
\end{array}
$$

经过计算发现，当 $1$ 与 $6$ 配对、$2$ 与 $5$ 配对、$3$ 与 $4$ 配对时乘积和最小，值为 $1 \times 6 + 2 \times 5 \space + 3 \times 4 = 28$。

多举几个例子可以发现，把数组 $w$ 从小到大排序后，结果为：

$$
ans = w_1 \times w_{2 \times n} + w_2 \times w_{2 \times n - 1} + \cdots + w_{n - 1} \times w_{n + 2} + w_n \times w_{n + 1}
$$

有了这个就很简单了，因为 $0 \le w_i \le 10^5$，$10^{5} \times 10^5 = 10^{10} > 2^{31} - 1$，所以要开 `long long`。

代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n;
int a[200010];
ll ans;

int main() {
    cin >> n;
    for (int i = 1; i <= 2 * n; i++) {
        cin >> a[i];
    }
    sort(a + 1, a + 2 * n + 1);
    for (int i = 1; i <= n; i++) {
        ans += 1ll * a[i] * a[2 * n - i + 1];
    }
    cout << ans << endl;
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/214143844)

~~写完题解我还是不知道这道题跟双指针有什么关系。~~

---

## 作者：jnxx_zhuyueqi (赞：0)

# 题意
给定 $2n$ 个数，求两两相乘积之和的最小值。
# 重要结论
对于任意正整数 $a$，$b$，$n$（$1\le a < b < n$），有：
$$(n+a)(n-a)>(n+b)(n-b)$$

由于本题数据都是正整数，因此在正整数范围内证明即可。

证明：原式 $=n^2-a^2>n^2-b^2$。

整理，得 $a^2<b^2$。

因为有 $a<b$，所以 $a^2<b^2$成立。

故原命题成立。

# 分析
通过前面的证明我们知道，要求出一个序列中两两相乘积之和的最小值，只需要把给定序列的最小值乘最大值，第 $i$ 小的值乘第 $i$ 大的值即可，但是因为给定的序列不一定有序，所以我们先要从小到大排序。

注意：数组长度为 $2n$，且由于数据范围较大，要开 long long。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;            //用 ll 替代 long long，可以减少代码长度
ll a[200005],n,ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n*2;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+2*n+1);           //进行排序，注意有 2n 个数要进行排序
	for(int i=1;i<=n;i++){
		ans+=a[i]*a[2*n-i+1];    //计算积之和的最小值
	}
	printf("%lld",ans);
    return 0;
}
```

---


# [蓝桥杯 2024 国 Java B] 美丽区间

## 题目描述

美丽区间是这样的一组区间：$[L_1, R_1]$、$[L_2, R_2]$、$[L_3, R_3] \dots$。构造美丽区间需要满足以下条件：

1. $L_1 = 1$；
2. $L_i \leq R_i$；
3. $R_i - L_i \geq K$；
4. 对于任意的 $i > 1$，有 $L_i = R_{i-1} + 1$；
5. $\gcd(L_i, R_i) = 1$，其中 $\gcd$ 指两个数的最大公约数；
6. 在满足上述条件的情况下，$L_i$、$R_i$ 之间的差尽可能的小。

## 说明/提示

### 样例说明

- 第 $1$ 个美丽区间为：$[1, 11]$。
- 第 $2$ 个美丽区间为：$[12, 23]$。
- 第 $3$ 个美丽区间为：$[24, 35]$。
- ……
- 第 $11$ 个美丽区间为：$[120, 131]$。

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例：$1 \leq T \leq 10^3$，$1 \leq K \leq 10^6$，$1 \leq n \leq 10^6$。
- 对于 $100\%$ 的评测用例：$1 \leq T \leq 10^6$，$1 \leq K \leq 10^6$，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
10
3
123
33
10```

### 输出

```
11
3
1```

# 题解

## 作者：Algo_Kit (赞：5)

# 题解：P12254 美丽区间

本蒟蒻第一次写题解，不喜勿喷。

### 思路

1. 预处理每个数字所在的美丽区间。

2. 输出答案。

### 实现方法：

**1. 使用 while 循环计算每个美丽区间的左边界和右边界**

- 我们可以定义一个 $cnt$ 表示这是第几个美丽区间，每算完一个区间时，$cnt$ 加上一个 $1$，计算下一个区间。

- 因为题目要求的是 $L_i$，$R_i$ 之间的差尽可能的小，所以第 $cnt$ 个美丽区间的左边界可以直接等于上一个美丽区间的右边界（条件 2：$L_i \le R_i$），第 $cnt$ 个美丽区间的右边界可以等于上一个美丽区间的左边界 $+k$（条件 3：$R_i − L_i \ge K$）。

- 当 $l_{cnt}$ 和 $r_{cnt}$ 不满足条件 $5$（$\gcd (L_i,R_i)=1$）时，可以自增 $r_{cnt}$, 直到满足条件 $5$ 为止。

**2. 每次读入 $n$ 时，循环遍历每个美丽区间，当 $n$ 在此美丽区间中时，即可输出此美丽区间的编号。**

但是这样会 [TLE](https://www.luogu.com.cn/record/216025332) 的。

为什么会这样呢？\
原来是在读入中，每读入一个 $n$ 后都要一个 for 循环来查找，导致超时。\
那该怎么办呢？\
答：用一个 $ans$ 数组存储第 $i$ 个数字在哪个美丽区间中，每次找到美丽区间的左右边界（$l$ 和 $r$ 数组），就循环一次记录 $ans$。

# AC Code：
- C++:

```cpp
#include <bits/stdc++.h>
using namespace std;

int l[5000010],r[5000010],ans[5000010];
int k,t,n,cnt = 0;

signed main(){
	scanf("%d%d",&k,&t);
	//初始化 
	l[0] = 0,r[0] = 0;
	while(r[cnt] < 1000000){
		cnt++;
		l[cnt] = r[cnt - 1] + 1;
		r[cnt] = k + l[cnt];
		while(__gcd(l[cnt],r[cnt]) > 1){   //这是个好东西 
			r[cnt]++;
		}
		for(int i = l[cnt];i <= r[cnt];i++){
			ans[i] = cnt;
		}
	}
	//直接输出 
	while(t--){
		scanf("%d",&n);
		printf("%d\n",ans[n]);
	} 
	return 0;
}
```

- Java:


```java
import java.util.Scanner;

public class Main {
    static int[] l = new int[5000010];
    static int[] r = new int[5000010];
    static int[] ans = new int[5000010];
    static int k, t, n, cnt = 0;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        k = sc.nextInt();
        t = sc.nextInt();
        // 初始化
        l[0] = 0;
        r[0] = 0;
        while (r[cnt] < 1000000) {
            cnt++;
            l[cnt] = r[cnt - 1] + 1;
            r[cnt] = k + l[cnt];
            
            while (gcd(l[cnt], r[cnt]) > 1) {  // 这是个好东西
                r[cnt]++;
            }
            
            for (int i = l[cnt]; i <= r[cnt]; i++) {
                ans[i] = cnt;
            }
        }
        // 直接输出
        while (t-- > 0) {
            n = sc.nextInt();
            System.out.println(ans[n]);
        }
    }
    // 计算最大公约数
    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

---

## 作者：weifengzhaomi (赞：3)

题目意思已经很详细，这里不在复述。

## 思路

由于 $n$ 的范围很大，如果每次询问都 $O(n)$ 查找就是 $O(tn)$ 的复杂度，肯定是不能过的，**所以考虑预处理**。

先设一个 $a$ 数组，用于存储答案。

然后，设置两个数组，$l$ 和 $r$，含义与题目相同。

接着，按照题目来模拟 $5$ 个特征。

- $l_1 = 1$。
- $l_i \le r_i$。
- $r_i - l_i \ge k$。
- $\gcd(l_i,r_i) = 1$。
- $r_i - l_i$ 尽可能小。

更多细节见代码。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int cnt[5000010],l[5000010],r[5000010],k,t,n,top = 1;
signed main(){
	scanf("%lld",&k);
	while (true){
		l[top] = r[top - 1] + 1,r[top] = l[top] + k;
		while (__gcd(l[top],r[top]) != 1) r[top]++;
		for (int i = l[top];i <= r[top];i++) cnt[i] = top;
		if (r[top] >= 1000000) break;
		top++;
	}
	scanf("%lld",&t);
	while(t--) scanf("%lld",&n),printf("%lld\n",cnt[n]);
}
```

---

## 作者：DSB_123456 (赞：2)

# P12254 题解
## 分析
### 预处理
由数据范围，我们发现 $N$ 的范围十分小，且 $K$ 是固定的，显然我们只需预处理出包含 $1$ 至 $10^6$ 的美丽区间即可。
### 询问
对于每个询问，显然只需遍历我们预处理出的所有美丽区间即可。  
**C++ Code**
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

pair<int, int> a[1000005];
int cnt = 0;

signed main(){
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int k;
    cin >> k;
    for(int i = 1; i <= 1000000; ){
        int j = i + k;
        while(__gcd(i, j) != 1 && j <= 1000000)
            j++;
        a[++cnt] = make_pair(i, j);
        i = j + 1;
    }
    int _;
    cin >> _;
    while(_--){
        int n;
        cin >> n;
        int ans = 0;
        for(int i = 1; i <= cnt; i++)
            if(a[i].first <= n && n <= a[i].second){
                ans = i;
                break;
            }
        if(ans)
            cout << ans << endl;
        else
            cout << cnt + 1 << endl;
    }

    return 0;
}
```
可是这样只有 $80$ 分。简单分析原因：在每次询问时，都会遍历整个美丽区间数组，导致超时。处理也很容易，只需要使用一个标记数组：存储某一个数在哪一个美丽区间内。相比之下，本思路的常数更小。
## AC Code
**C++ Code**
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int bl[10000005];
int cnt = 0;

signed main(){
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int k;
    cin >> k;
    for(int i = 1; i <= 1000000; ){
      	cnt++;
        int j = i + k;
        while(__gcd(i, j) != 1 && j <= 1000000)
            j++;
        for(int f = i; f <= j; f++)
        	bl[f] = cnt;
        i = j + 1;
    }
    int _;
    cin >> _;
    while(_--){
        int n;
        cin >> n;
    		cout << bl[n] << endl;
    }

    return 0;
}
```
**Java Code**
```java
import java.util.Scanner;

public class Main {
    static int[] bl = new int[10000005];
    static int cnt = 0;

    public static int gcd(int a, int b) {
        if(a % b == 0)
            return b;
        return gcd(b, a % b);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        for (int i = 1; i <= 1000000; ) {
            cnt++;
            int j = i + k;
            while (gcd(i, j) != 1 && j <= 1000000) {
                j++;
            }
            for (int f = i; f <= j; f++) {
                bl[f] = cnt;
            }
            i = j + 1;
        }
        int q = scanner.nextInt();
        while (q-- > 0) {
            int n = scanner.nextInt();
            System.out.println(bl[n]);
        }
    }
}
```

---

## 作者：Evan2000 (赞：2)

## 思路
可以先预处理出所有数字在哪个区间，然后就能边输入边输出了。
### 预处理的方法
首先写出三个数组，标记数组 $cnt$，和题目中的两个数组 $L$ 和 $R$。开始枚举，设变量 $ret$ 记录现在正在枚举哪个区间，因为题目要求对于任意的 $i > 1$，$L_i = R_{i-1} + 1$，所以需要将 $L_{ret}$ 设为 $R_{ret-1} + 1$，因为题目还要求 $R_i - L_i$ 必须大于等于 $K$，所以还需要将 $R_{ret}$ 设为 $L_{ret} + K$，其次，因 $L$ 数组和 $R$ 数组还需要满足 $\gcd(L_i, R_i) = 1$，所以我们需要用一个 $while$ 循环，算出 $R_{ret}$ 的值，随后用标记数组标记 $L_{ret}$ 和 $R_{ret}$ 之间所有的值所在区间即可。
## AC 代码（C++）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cnt[5000010];//标记数组
int l[5000010];
int r[5000010];
signed main()
{
	int k,t;
	scanf("%lld%lld",&k,&t);
	int ret=1;
	while(1)
	{
		l[ret]=r[ret-1]+1;
		r[ret]=l[ret]+k;
		while(__gcd(l[ret],r[ret])!=1)
		{
			r[ret]++;//累加，算出r[ret]的值
		}
		for(int i=l[ret];i<=r[ret];i++)//标记一下
		{
			cnt[i]=ret;
		}
		if(r[ret]>=1000000)//如果已经超出范围，退出预处理
		{
			break;
		}
		ret++;
	}
  //以上是预处理部分
	while(t--)
	{
		int n;
		scanf("%lld",&n);
		printf("%lld\n",cnt[n]);//直接调用标记数组里的值即可
	}
	return 0;
}
```

---

## 作者：rocktom (赞：2)

# 思路：
仔细观察题目发现，对于 $100\%$ 的评测用例：$1 \le T \le 10^6$，$1 \le K \le 10^6$，$1 \le n \leq 10^6$。意味着我们不能使用最暴力的方法——直接枚举美丽区间，然后看 $n$ 在哪个美丽区间内，然后输出答案，这样做时间复杂度太高，过不了。  

那怎么办呢？  

我们可以预处理呀！我们可以定义两个变量 $l$ 和 $r$，根据题目的几个要求去模拟，顺便一路上把答案记下来。（注意，你不记，小心超时！！！）  

下面是题目对美丽区间要求，方便与下面的代码对应：  

1. $L_1 = 1$；
2. $L_i \le R_i$；
3. $R_i - L_i \ge K$；
4. 对于任意的 $i > 1$，有 $L_i = R_{i-1} + 1$；
5. $\gcd(L_i, R_i) = 1$；
6. 在满足上述条件的情况下，$L_i$、$R_i$ 之间的差尽可能的小。

# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int k, n, q, ans[1000001];
int main(int argc, const char *argv[]) {
	scanf("%d", &k);
	int l = 1, r = 1, cnt = 1;//题目第1要求
	while (l <= 1e6 && r <= 1e6) {
		ans[r] = cnt;//标记答案
		if (r - l >= k && __gcd(l, r) == 1) //题目第3和5要求
			l = r + 1, r = l, cnt++;//题目第4和第6要求
		else
			r++;//题目第2要求
	}
	scanf("%d", &q);
	while (q--) {
		scanf("%d", &n);
		printf("%d\n", ans[n]);
	}
    return 0;
}
```

---

## 作者：yongqian123 (赞：2)

## 题目分析
预处理十分重要。

像这种多个数据针对同一个前提的问题，我们通常会用预处理加快运行时间，即自动打表。

怎么预处理呢？想想输入 $n$，会输出什么——会输出区间序号 $a_n$，对吧？那么预处理就处理那些区间序号，而 $a_i=a_{i-1}$ 或 $a_{i-1}+1$，故判断区间序号是否需要增加。

如题意要求，

- $R_i-L_i\ge K$，则 $a_{L_i+K}\gets\dots\gets a_{L_i}\gets a_{R_{i-1}}+1$；

- $\gcd(L_i,R_i)=1$，则当 $\gcd(L_i,R_i)=1$ 时退出此区间，并进入下一个空间。

于是，我们就得出了核心代码。

## 核心代码
### Java
```java
private int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
}
//MAIN
for (int i = 1; i < MAX; ){
    int l = i++;
    a[l] = a[l - 1] + 1;
    for (; i < l + k && i < MAX; i++) a[i] = a[i - 1];
    for (; i < MAX; i++) {
        a[i] = a[l];
        if (gcd(l, i) == 1) break;
    }i++;
}

```

### C++
```cpp
for (int i = 1; i < MAX; ){
	int l = i++;
	a[l] = a[l - 1] + 1;
	for (; i < l + k && i < MAX; i++) a[i] = a[i - 1];
	for (; i < MAX; i++){
		a[i] = a[l];
		if (__gcd(l, i) == 1) break;
	}i++;
}

```

---

## 作者：doooge (赞：2)

考虑预处理每一个区间的范围。

根据题目中的条件，$L_i = R_{i-1}+1$，而 $R_i$ 可以从 $L_i + K$ 开始依次枚举，直到 $\gcd(L_i,R_i)=1$ 时停止。求出每个区间后直接标记 $L_i$ 到 $R_i$ 之间的答案记 $ans_i$ 为 $i$。

由于一开始 $R_0$ 为 $0$，$L_1=R_0+1=1$，符合题目要求，于是我们就可以从 $i=1$ 开始枚举区间。一旦 $R_i\ge10^6$，表示 $R_i$ 已经越界了，停止枚举即可。

询问的时候，直接输出 $ans_i$。复杂度 $O(n \log n)$。

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[1000010],l[1000010],r[1000010];
int main(){
	ios::sync_with_stdio(0);//输入量较大，所以关闭同步流
	cin.tie(0),cout.tie(0);
	int k,t;
	cin>>k;
	for(int i=1;i<=1e6;i++){
		l[i]=r[i-1]+1,r[i]=l[i]+k;//先求出L[i]和枚举R[i]的左端点
		while(__gcd(l[i],r[i])!=1)r[i]++;//求出R_i
		r[i]=min(r[i],int(1e6));//处理越界
		for(int j=l[i];j<=r[i];j++)ans[j]=i;//标记答案
		if(r[i]==1e6)break;//如果R[i]已经越界了，则不用继续枚举了，直接跳出循环
	}
	cin>>t;
	while(t--){
		int x;
		cin>>x;
		cout<<ans[x]<<'\n';//关闭同步流
	}
	return 0;
}
//code by doooge
```

Java（本人不太会，码风不太好，见谅）：

```java
import java.io.*;
import java.util.*;
public class Main{
    private static int gcd(int a,int b){//最大公因数函数
        while(b>0){
            int temp=b;
			b=a%b;
            a=temp;
        }
        return a;
    }
    public static void main(String args[])throws Exception {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw=new PrintWriter(System.out);
        final int N=1000000;
        int[] ans=new int[N+10];
        int[] l=new int[N+10];
        int[] r=new int[N+10];
        int k=Integer.parseInt(br.readLine());
        for(int i=1;i<=N;i++){
            l[i]=r[i-1]+1;
            r[i]=l[i]+k;
            //调整r[i]直到gcd(l[i], r[i])==1或越界
            while(gcd(l[i],r[i])!=1)r[i]++;
            r[i]=Math.min(r[i],N);
            //填充ans数组
            for(int j=l[i];j<=r[i];j++)ans[j]=i;
            if(r[i]==N)break;
        }
        int t=Integer.parseInt(br.readLine());
        while(t-->0){
            int x=Integer.parseInt(br.readLine());
            pw.println(ans[x]);
        }
		pw.flush();
    }
}
```

---

## 作者：gdz0214_and_zxb0214 (赞：0)

## 思路

这道题不难，处理时固定左端点，求右端点，同时赋值给 `s` 数组，意为第 $i$ 个数属于第几个区间，再将左端点设为上一段的右端点加一，重复直到 $10^6$。

注意一下，`std` 内含函数 `__gcd`，非常方便。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int k,t,s[1000010],cnt=1;
signed main(){
    cin>>k>>t;
    int r=0;
    for(int l=1;l<1000010;l=r+1){
        s[l]=s[r]+1;
        for(r=l;r<1000010;r++){
            s[r]=s[l];
            if(r>=l+k&&__gcd(r,l)==1){
                break;
            }
        }
    }
    while(t--){
        cin>>cnt;
        cout<<s[cnt]<<"\n";
    }
}
```

---

## 作者：Perfect_Youth (赞：0)

简单题喵。

思路：

可以先预处理一个答案数组，在准备一个存上一次 $l$ 的位置的变量，然后按题意模拟即可。

代码：

```cpp
#include <bits/stdc++.h>
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1 , 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

inline
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

const int N = 1e6 + 7;

int k, t, l, cnt[N], ans;

int main() {
	k = read();
	l = 1;
	for (int i = 1; i <= 1000000; ) {
		i = l + k;
		while (__gcd(i, l) != 1 && i <= 1000000) i++;
		ans++;
		for (int j = l; j <= min(i, 1000000); j++) cnt[j] = ans;
		l = i + 1;
	}
	t = read();
	while (t--) {
		k = read();
		printf ("%d\n", cnt[k]);
	}
	return 0;
}
```

---

## 作者：Noob_Oler (赞：0)

# 题解：P12254 [蓝桥杯 2024 国 Java B] 美丽区间
因为 $R_i-L_i\le K$，所以我们只需要枚举出每个区间的 $l$ 和 $r$ 再标记一下 $a_l \sim a_r$ 属于哪个区间。

之后，问的时候就直接输出就可以了。
## C++ Code
```
#include <bits/stdc++.h>
using namespace std;
int a[1000005];
int main() 
{
    int k,t;
    cin >> k >> t;
    int r = 0,cnt = 1;
	for(int i = 1; i < 1000005; i = r + 1) 
	{
        for(r = i + k; r < 1000005 && __gcd(i,r) != 1; r++);
        for(int j = i; j <= min(r,1000004); j++) a[j] = cnt;
        cnt++;
    }
	while(t--) 
	{
        int x;
        cin >> x;
        cout << a[x] << "\n";
    }
	return 0;
}
```
## Java Code
```
import java.util.Scanner;

public class TranslatedCode {
    static int[] a = new int[1000005];

    public static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        int t = scanner.nextInt();
        int r = 0;
        int cnt = 1;
        for (int i = 1; i < 1000005; i = r + 1) {
            for (r = i + k; r < 1000005 && gcd(i, r) != 1; r++) ;
            for (int j = i; j <= Math.min(r, 1000004); j++) {
                a[j] = cnt;
            }
            cnt++;
        }
        while (t-- > 0) {
            int x = scanner.nextInt();
            System.out.println(a[x]);
        }
        scanner.close();
    }
}    
```

---

## 作者：yanmingqian (赞：0)

题意：

定义美丽区间，满足：

1. $L_1 = 1$；
2. $L_i \leq R_i$；
3. $R_i - L_i \geq K$；
4. 对于任意的 $i > 1$，有 $L_i = R_{i-1} + 1$；
5. $\gcd(L_i, R_i) = 1$，其中 $\gcd$ 指两个数的最大公约数；
6. 在满足上述条件的情况下，$L_i$、$R_i$ 之间的差尽可能的小。

给定 $T$ 个 $n$，求每个 $n$ 在第几个美丽区间内。

我们不难想到先将美丽区间的左右端点预处理出来，然后查询时二分查找。

预处理时，我们直接按照题意模拟即可。直接枚举找到第一个满足 $\gcd(l_i,j)$ 的值 $j$，然后存储下来即可。

```cpp
l[1]=1;
int len;
for(int i=1;l[i]<maxx;i++){
    for(int j=l[i]+k;j<=maxx+k;j++){
        if(__gcd(j,l[i])==1){
            r[i]=j;
            l[i+1]=j+1;
            break;
        }
    }
    len=i;
}
```

区间数量最多为 $\frac{10^6}{k}$ 个，每个区间检查 $\gcd$ 的次数应当不会超过 $k$，实际上很多时候两次就出来了，所以这部分的时间复杂度是 $O(maxx \log k)$ 的，$maxx$ 表示 $a_i$ 的最大值，$\log k$ 来自最大公因数。

然后直接二分查找就行。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[1000010],l[1000010],r[1000010];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int k,T,maxx=0;
    cin>>k>>T;
    for(int i=1;i<=T;i++){
        cin>>a[i];
        maxx=max(maxx,a[i]);
    }
    l[1]=1;
    int len;
    for(int i=1;l[i]<maxx;i++){
        for(int j=l[i]+k;j<=maxx+k;j++){
            if(__gcd(j,l[i])==1){
                r[i]=j;
                l[i+1]=j+1;
                break;
            }
        }
        len=i;
    }
    for(int i=1;i<=T;i++){
        cout<<lower_bound(r+1,r+len+1,a[i])-r<<"\n";
    }
    return 0;
}
```

```java
import java.util.*;
import java.io.*;

public class Main {
    static final int MAX_SIZE = 1000010;
    static int[] a = new int[MAX_SIZE];
    static int[] l = new int[MAX_SIZE];
    static int[] r = new int[MAX_SIZE];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);

        int k = Integer.parseInt(br.readLine());
        int T = Integer.parseInt(br.readLine());
        int maxx = 0;

        for (int i = 1; i <= T; i++) {
            a[i] = Integer.parseInt(br.readLine());
            maxx = Math.max(maxx, a[i]);
        }

        l[1] = 1;
        int len = 0;

        for (int i = 1; l[i] < maxx; i++) {
            for (int j = l[i] + k; j <= maxx + k; j++) {
                if (gcd(j, l[i]) == 1) {
                    r[i] = j;
                    l[i + 1] = j + 1;
                    break;
                }
            }
            len = i;
        }

        for (int i = 1; i <= T; i++) {
            int pos = Arrays.binarySearch(r, 1, len + 1, a[i]);
            if (pos < 0) {
                pos = -pos - 1;
            }
            pw.println(pos);
        }
        pw.flush();
    }
    private static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

---

## 作者：W_C_B_H (赞：0)

由于 $K$ 的值固定，所以我们可以在最开始用循环预处理出每个美丽区间的起止点，并用 `id[i]` 表示 $i$ 属于的美丽区间的编号，查询时直接输出即可。

时间复杂度 $O(n)$，可以通过本题。

Code：

```java
import java.util.Scanner;
public class Main {
    static int gcd(int x, int y) {  // 辗转相除法
        if(y == 0) {
            return x;
        }
        return gcd(y, x%y);
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        final int N = 1000005;
        int k = sc.nextInt(), T = sc.nextInt(), n, l, r, cnt = 1;
        int[] id = new int[N];
        for(l = 1; l < N; l = r + 1) {
            for(r = l + k; r < N && gcd(l, r) != 1; r++);   //找到第一个 l 与 r 互质或 r 越界的位置
            if(r >= N) {
                r = N - 1;  // 防止 RE
            }
            for(int i = l; i <= r; i++) {
                id[i] = cnt;    //标记区间编号
            }
            cnt++;
        }
        while(T-- > 0) {
            n = sc.nextInt();
            System.out.println(id[n]);
        }
    }
}
```

---


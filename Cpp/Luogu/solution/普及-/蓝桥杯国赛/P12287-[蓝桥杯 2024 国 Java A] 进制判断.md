# [蓝桥杯 2024 国 Java A] 进制判断

## 题目描述

小蓝有 $n$ 个数，他将这 $n$ 个数分别转换成了 $2, 4, 8, 16$ 进制之一的形式。其中 $16$ 进制用大写字母 $A$ 至 $F$ 表示大于等于 $10$ 的数位。

小蓝现在有这 $n$ 个数转换后的结果 $A_i$，但他不记得具体每个数转换后是几进制了，他现在只知道转换后的 $A_i$ 以及其原本应该小于等于某个数 $B_i$（$10$ 进制表示）。

请你帮他找出每个数原本在 $10$ 进制下的值，如果不存在唯一结果请输出 $-1$。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n = 1$；
- 对于 $70\%$ 的评测用例，$1 \leq n \leq 10$；
- 对于所有评测用例，$1 \leq n \leq 1000$，$1 \leq \mathrm{length}(A_i) \leq 30$，$1 \leq B_i \leq 10^9$，其中 $\mathrm{length}(A_i)$ 表示 $A_i$ 的长度（数位个数）。

## 样例 #1

### 输入

```
2
1010 23
A1 160```

### 输出

```
10
-1```

# 题解

## 作者：dendky (赞：8)

## 思路

枚举进制 $2,4,8,16$，如果按进制转换后依然小于等于 $B_i$ 就记录答案，否则就跳过当前进制，计算下一个进制。

最后统计答案，如果存在**唯一结果**就输出这个数在 $10$ 进制下的值，否则输出 $-1$。注意，如果有多个值，输出 $-1$。

## Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, b;
string a;
ll zhuan(char s) {
    if (s>='0' && s<='9') return s-'0';//是2，4，8进制
    else if (s>='A' && s<='F') return s-'A'+10;//16进制
    else return -1;//不是所求进制
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	cin>>n;
    while (n--) {
        cin>>a>>b;
        vector <ll>cnt;
        for (int x=2; x<=16; x*=2) {
            bool flag=1;
            ll ans=0;
            for (int j=0; j<a.size(); j++) {
                ll zz=zhuan(a[j]);
                if (zz==-1 || zz>=x) {
                    flag=0;
                    break;
                }//不符合当前进制x跳过
                if (ans*x+zz > b) {
                    flag=0;
                    break;
                }//超过了要求的b，先计算防溢出
                ans=ans*x+zz;//小于等于b，在范围内
            }
            if (flag==0) continue;
            cnt.push_back(ans);//记录符合要求的十进制a[i]
        }
        if (cnt.size()==1) cout<<cnt[0]<<"\n";
        else cout<<"-1\n";
    }
	return 0;
}
```

---

## 作者：Heyg_future (赞：8)

# [蓝桥杯 2024 国 Java A] 进制判断
## [题目传送门](https://www.luogu.com.cn/problem/P12287)
一道不错的题目。

这题一看就是一道~~水~~基础题，但是还是花了我将近一个中午写这个。
~~可能这是 Java 的比赛，而我们是 cpp 玩家~~。
## PART 1
我一看就是一个进制转换，用了两分钟搞出来一份代码。
思路很简单。就是枚举四个进制，然后看看转成十进制是否符合要求。
```cpp
#include<iostream>
#include<cmath>
using namespace std;
const int N=1005;
int n;
string a,b,a1,a2,a3,a4;
long long p(int x, int y) {
    long long ans=1;
    while(y--) ans*=x;
    return ans;
}
string z(string st,int jz){
    string ans="";
    long long s=0;
    int l=st.length();
    for(int i=0;i<l;i++){
        if(st[i]>='0'&&st[i]<='9') {
            if(st[i]-'0'>=jz) return "-1"; 
            s+=(st[i]-'0')*p(jz,l-i-1);
        }
        else {
            if(st[i]-55>=jz) return "-1"; 
            s+=(st[i]-55)*p(jz,l-i-1);
        }
    }
    if(s<0) return "-1";
	if(s==0) return "0";
    while(s>0){
        ans=to_string(s%10)+ans;
        s/=10;
    }
    return ans;
}
// 进制转换
bool m(string st,string sn) {
    if(st=="-1") return false;
    if(st.length()!=sn.length()) return st.length()<sn.length();
    return st<=sn;
}
//比较两数大小
int main(){
    cin>>n;
    while(n--){
        cin>>a>>b;
        a1=z(a,2);
        a2=z(a,4);
        a3=z(a,8);
        a4=z(a,16);
   	//直接枚举
        int s=0;
        string ans="";
        if(m(a1,b))s++,ans=a1;
        if(m(a2,b))s++,ans=a2;
        if(m(a3,b))s++,ans=a3;
        if(m(a4,b))s++,ans=a4;
        if(s==1)cout<<ans<<"\n";
        else cout<<-1<<"\n";
    }
    return 0;
}
```
可是这只有 $85$ 分。

具体请看注释，相信有不少人也像我一样是这样错的。
我在这里没有正确地判断 `long long` 的溢出，所以导致错误。
## PART 2
我想了一下
在处理进制转换过程中的溢出时并没有实时考虑，并且我发现 `long long` 类型溢出不一定变成负数，也可能只是一个不正确的答案，所以要随时判断，最好在加之前就判断是否溢出。这样就可以直接退出进制转换函数，既可以降低时间复杂度又可以得到正确答案，~~爽啊~~。

直接上代码。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#define MAX 9223372036854775807
//long long 的范围 
using namespace std;
const int N=1005;
int n;
string a,b,a1,a2,a3,a4;
string z(string st,int jz){
	//进制转换
    string ans="";
    long long s=0;
    int l=st.length();
     for(int i=0;i<l;i++){
        int d;
        if(st[i]>='0'&&st[i]<='9') {
            d=st[i]-'0';
            if(d>=jz) return "-1";
        }
        else {
            d=st[i]-'A'+10;
            if(d>=jz) return "-1";
        }
        //特殊处理十六进制 
        if(pow(jz,l-i-1)==MAX ||s>MAX-d*pow(jz,l-i-1)) return "-1";
        s+=d*pow(jz,l-i-1);
    }

    if(s<0) return "-1";
    if(s==0) return "0";
    while(s>0){
        ans=to_string(s%10)+ans;
        s/=10;
    }
    return ans;
}
bool m(string st,string sn){
    if(st=="-1") return 0;
    if(st.length()>sn.length()) return 0;
    if(st.length()<sn.length()) return 1;
    return st<=sn;
}
int main(){
    cin>>n;
    while(n--){
        cin>>a>>b;
        a1=z(a,2);
        a2=z(a,4);
        a3=z(a,8);
        a4=z(a,16);
        //枚举四个进制 
        int s=0;
        string ans="";
        if(m(a1,b))s++,ans=a1;
        if(m(a2,b))s++,ans=a2;
        if(m(a3,b))s++,ans=a3;
        if(m(a4,b))s++,ans=a4;
        if(s==1)cout<<ans<<"\n";
        else cout<<-1<<"\n";
    }
    return 0;
}
```
这样在转进制过程中直接判断溢出即可 AC。
当然，还有 Java 语言的代码，deepseek 转写的。
如有错误请指出。
```java
import java.util.Scanner;
import java.math.BigInteger;
public class Main {
		private static final long MAX = Long.MAX_VALUE;
		private static final int N = 1005;
		public static void main(String[] args) {
			Scanner scanner=new Scanner(System.in);
			int n=scanner.nextInt();
			while (n-- > 0) {
				String a=scanner.next();
				String b=scanner.next();
				String a1=z(a, 2);
				String a2=z(a, 4);
				String a3=z(a, 8);
				String a4=z(a, 16);
				int s=0;
				String ans="";
				if (m(a1,b) {
				s++;
				ans=a1;
			}
			if (m(a2,b)) {
				s++;
				ans=a2;
			}
			if(m(a3,b)) {
				s++;
				ans=a3;
			}
			if (m(a4,b)) {
				s++;
				ans=a4;
			}

			if (s==1) {
				System.out.println(ans);
				} else {
					System.out.println(-1);
				}
			}
			scanner.close();
		}
		private static String z(String st,int jz) {
			StringBuilder ans=new StringBuilder();
			long s=0;
			int l=st.length();
			for (int i=0; i<l; i++) {
				int d;
				char c=st.charAt(i);
				if (c>='0'&&c<='9') {
					d = c - '0';
					if (d >= jz) return "-1";
				} else {
					d = c - 'A' + 10;
					if (d >= jz) return "-1";
				}
				double power = Math.pow(jz, l - i - 1);
				if (power == MAX || s > MAX - d * power) {
					return "-1";
				}
				s+=d*power;
			}

			if (s<0) return "-1";
			if (s == 0) return "0";
			while(s > 0) {
				ans.insert(0, s % 10);
				s/= 10;
			}
			return ans.toString();
		}
		private static boolean m(String st, String sn) {
			if (st.equals("-1")) return false;
			if (st.length() > sn.length()) return false;
			if (st.length() < sn.length()) return true;
			return st.compareTo(sn) <= 0;
		}
}
```

---

## 作者：aljz (赞：3)

# P12287 [蓝桥杯 2024 国 Java A] 进制判断

其他的题解已经写的非常好了，这里仅仅提供一种对于 c++ 玩家的非常暴力的手段，它就是 ```__int128```。每当题目数据范围大于 ```long long``` 的范围而又不想写高精度时，```__int128``` 就是一个非常不错的选择，它的存储范围高达 $\lbrack2^{127},2^{127} - 1\rbrack$，可以完美的包含整个题的所有范围。

# 注意
- ```__int128``` 不能直接使用 ```cin```，```cout```，```scanf```，```printf``` 输入输出，需要写一个快读快输进行输入输出，可以只把结果用 ```__int128``` 表示，这样可以不用写快读。

本人是 c++ 玩家，不会 java，不知道 java 里面有没有```__int128``` 这种东西，就不提供 java 代码了。
# code
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n;
string a;
int b;
//本人比较喜欢分开写，不喜勿喷
__int128 two(string s)
{
	__int128 res=0;
	for(__int128 i=s.length()-1,j=1;i>=0;--i,j*=2) res=res+j*(a[i]-'0');
	return res;
}
__int128 four(string s)
{
	__int128 res=0;
	for(__int128 i=s.length()-1,j=1;i>=0;--i,j*=4) res=res+j*(a[i]-'0');
	return res;
}
__int128 eight(string s)
{
	__int128 res=0;
	for(__int128 i=s.length()-1,j=1;i>=0;--i,j*=8) res=res+j*(a[i]-'0');
	return res;
}
__int128 sixteen(string s)
{
	__int128 res=0;
	for(__int128 i=s.length()-1,j=1;i>=0;--i,j*=16)
	{
		if(a[i]>='A' && a[i]<='F') res=res+j*(a[i]-'A'+10);
		else res=res+j*(a[i]-'0');
	} 
	return res;
}
void out(__int128 x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
void solve()
{
	cin >> n;
	for(int i=1;i<=n;++i)
	{
		cin >> a >> b;
		int len=a.length();
		bool opa=0,opb=0,opc=0,opd=0;
		for(int i=0;i<len;++i)
		{
			if(a[i]>='2') opa=1;
			if(a[i]>='4') opb=1;
			if(a[i]>='8') opc=1;
		}
		__int128 suma=0,sumb=0,sumc=0,sumd=0;
		if(opa == 0)
		{
			suma=two(a);
			sumb=four(a);
			sumc=eight(a);
			sumd=sixteen(a);
			if(suma<=b && sumb>b) out(suma);
			else cout << -1;
		}
		else if(opb == 0)
		{
			sumb=four(a);
			sumc=eight(a);
			sumd=sixteen(a);
			if(sumb<=b && sumc>b) out(sumb);
			else cout << -1;
		}
		else if(opc == 0)
		{
			sumc=eight(a);
			sumd=sixteen(a);
			if(sumc<=b && sumd>b) out(sumc);
			else cout << -1;
		}
		else 
		{
			sumd=sixteen(a);
			if(sumd<=b) out(sumd);
			else cout << -1;
		}
		cout << '\n';
	} 
}

signed main(){
	solve();
	return 0;
}


```
~~其实是不会写。~~

---

## 作者：JIN_LONG (赞：2)

## 解题思路：
- 首先我们这样循环 $n$ 遍，在这 $n$ 遍中，依次输入字符串 $a$，与数字 $b$。
- 接着将字符串 $a$ 分别转化为二进制，四进制，八进制和十六进制。
- 最后将转化后的数字与 $b$ 进行对比，统计符合题意的个数，如果只有一个数字符合题意，则输出它，否则输出 $-1$。
## 代码：

```
#include <bits/stdc++.h>
using namespace std;
long long a[105],b,c[5]={0,2,4,8,16},d[5];
string S;
int charToInt(char c) {
    if('0'<=c&&c<='9') return c-'0';
    else if (c>='A' && c<='F') return c-'A'+10;
    else return -1;
}
int main() {
    int T;
    cin>>T;
    while(T--){
    	cin>>S>>b;
    int q=0;
    for(int i=0;i<S.size();i++){
    	if(S[i]<'0'||S[i]>'9'){
    		q=1;
		}
	}
    for(int j=1;j<=4;j++){
    	if(q==1){
    		j=4;
    		d[1]=INT_MAX;
    		d[2]=INT_MAX;
    		d[3]=INT_MAX;
		}
    	long long x=c[j];
    	int len=S.size();
		for(int i=len-1;i>=0;i--)
        	a[i]=charToInt(S[i]);
    	long long ans=0;
    	for(int i=0;i<len;i++){
            if(a[i]==-1||a[i]>=c[j]||ans*x+a[i]>b){
                 ans=INT_MAX;
                break;
            }
    	    ans=ans*x+a[i];
    	}
    	for(int i=0;i<105;i++){
    		a[i]=0;
		}
    	d[j]=ans;
	}
        int cnt=0;
     for(int i=1;i<=4;i++){
    	if(d[i]<=b)cnt++;
     } 
    if(cnt!=1){
        cout<<-1<<endl;
    }
        else
    for(int i=1;i<=4;i++){
    	if(d[i]<=b)cout<<d[i]<<endl;
	}
	}
    return 0;
}
```

---

## 作者：Evan2000 (赞：1)

## 题意
给你 $n$ 个数，都是 $2,4,8,16$ 进制之一的形式，其中 $16$ 进制用大写字母 $A$ 至 $F$ 表示大于等于 $10$ 的数位，你不知道这个数字是几进制的，你只知道转换成十进制后的 $A_i$ 小于等于 $B_i$，求这个数字在十进制下的值，如果没有唯一解则输出 $-1$。
## 思路
先算出 $A_i$ 所有数位中最大的数字，锁定 $A_i$ 至少是多少进制的，然后枚举所有有可能的进制，算出 $A_i$ 在不同进制下转成十进制的可能值，和 $B_i$ 作比较，如果可以，计数器加一，记录当前答案，枚举下一个进制；如果不行，直接枚举下一个进制。最后，如果计数器不等于 $1$，输出 $-1$，如果计数器等于 $1$，输出答案即可。

要注意，因为在运算过程中有可能会爆```long long```，所以要边运算边判断 $sum$ 是否超过 $B_i$，如果已经超过 $B_i$ 就需要立刻退出循环。
## 别的进制转十进制的方法
[来源——百度](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=49055317_16_hao_pg&wd=%E5%88%AB%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95&fenlei=256&rsv_pq=0x91073a4902a76932&rsv_t=eb931KQFXNqGDdFk2ekWLdFXgsWbjaFuUO8qOuro1ih16tWiC%2F8WInqF3xLE&rqlang=en&rsv_enter=1&rsv_dl=tb&rsv_sug3=2&rsv_n=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&rsv_btype=i&inputT=825&rsv_sug4=29014)
## AC 代码（C++）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int digit(char ch) {
	if(ch>='A' && ch<='F') return (ch-'A'+10);
	else return (ch-'0');
}
signed main() {
	int t;
	scanf("%lld",&t);
	while(t--) {
		char s[50];
		scanf("%s",s+1);
		int len=strlen(s+1);
		int b;
		scanf("%lld",&b);
    //读入
		int mx=-1;
		for(int i=1;i<=len;i++) {
			mx=max(mx,digit(s[i]));
		}
		int jinzhi=0;
		if(mx<2) jinzhi=2;
		else if(mx>=2 && mx<4) jinzhi=4;
		else if(mx>=4 && mx<8) jinzhi=8;
		else jinzhi=16;
        //算出s至少是多少进制的
		int flag=0,ans=0;
		for(int base=jinzhi;base<=16;base*=2) {//枚举所有有可能的进制
			int sum=0;
			for(int i=len;i>=1;i--) {
				int num=digit(s[i]);
				if((int)pow(base,len-i)>b) {//不判的话有可能爆long long
					sum=b+1;
					break;
				}
				sum+=num*(int)pow(base,len-i);
				if(sum>b) {//不判的话有可能爆long long
					break;
				}
			}
			if(sum<=b) {//如果可以，记录当前答案，计数器加一
				ans=sum;
				flag++;
			}
		}
		if(flag!=1) {//如果计数器不等于一，输出-1
			printf("-1\n");
		} else {//否则输出记录过的答案
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

~~相信大部分人都是用的C++~~

---

## 作者：Noob_Oler (赞：0)

我们可以用一个函数，把字符转为数字。

再依次把数字转为 $2$，$4$，$8$，$16$ 进制，再判断。

+ 如果这个数超过了进制，则不行。

+ 如果原本的数再加上就超过 $b$ 了，则不行

再看答案，如果超过 $1$ 个，就输出 $-1$。

否则，直接输出答案。

## C++ Code

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ccc(char c)//转换函数
{
    if(c >= '0' && c <= '9') return c - '0';//2，4，8进制转换
    else if(c >= 'A' && c <= 'F') return c - 'A' + 10;//16进制处理
    else return -1;//在范围之外
}
int k[5] = {0,2,4,8,16};
signed main()
{
    int t;
    cin >> t;
    while(t--)
    {
        string s;
        int b,sss = 0,cnt = 0;
        cin >> s >> b;
        for(int i = 1; i <= 4; i++)
        {
            int x = k[i],ss = 0;
            bool f = 0;
            for(int j = 0; j < s.size(); j++)
            {
                char c = s[j];
                int xx = ccc(s[j]);
                if(xx >= x || xx == -1) //超过限制或不行
                {
                    f = !f;
                    break;
                }
                if(ss * x + xx > b) //超过b
                {
                    f = !f;
                    break;
                }
                ss = ss * x + xx;
            }
            if(ss <= b && !f) cnt++,sss = ss;//sss为最终结果
        }
        if(cnt != 1) cout << "-1\n";
        else cout << sss << "\n";
    }
    return 0;
}
```
## Java Code
```
import java.util.Scanner;

public class Main {
    // 转换函数
    private static int ccc(char c) {
        if (c >= '0' && c <= '9') {
            return c - '0'; // 处理2、4、8进制
        } else if (c >= 'A' && c <= 'F') {
            return c - 'A' + 10; // 处理16进制
        } else {
            return -1; // 范围外返回-1
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            String s = scanner.next();
            long a = scanner.nextLong();
            int cnt = 0;
            long sss = 0;
            
            int[] k = {2, 4, 8, 16}; // 去除无效的k[0]=0
            for (int x : k) {
                long ss = 0;
                boolean f = false;
                for (int j = 0; j < s.length(); j++) {
                    char c = s.charAt(j);
                    int xx = ccc(c);
                    
                    if (xx >= x || xx == -1) { // 超出进制范围或无效字符
                        f = true;
                        break;
                    }
                    
                    // 防止数值溢出（Java中long最大值足够大，但显式检查更安全）
                    if (ss > (a - xx) / x) { // 等价于 ss * x + xx > a
                        f = true;
                        break;
                    }
                    ss = ss * x + xx;
                }
                
                if (!f && ss <= a) { // 有效且不超过a
                    cnt++;
                    sss = ss;
                }
            }
            
            if (cnt == 1) {
                System.out.println(sss);
            } else {
                System.out.println(-1);
            }
        }
        scanner.close();
    }
}
```
Java 代码是豆包翻译的（本人只会 C++）
请不要抄袭本题解代码

---

## 作者：封禁用户 (赞：0)

## 思路
每次将 $a$ 转化成十进制形式，与 $b$ 比较，要判断超过 $b$ 就跳出，不然可能数据溢出。

假设要把长度为 $n$ 的 $k$ 进制数 $x$ 转化为十进制数，则公式为：

 $\sum_{i = 1}^{n} x_i \cdot k^{i-1}$ 

其中 $x_i$ 表示 $x$ 的第 $i$ 位。

## 代码
### c++
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,b;
string a;
int zhuan(char s){
    if (s>='0'&&s<='9')return s-'0';
    else if (s>='A'&&s<='F')return s-'A'+10;//16进制特殊处理 
    else return -1;
}
int main() {
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
    while(n--){
        cin>>a>>b;
        vector<int>cnt;
        for (int i=2;i<=16;i*=2){
            bool flag=true;
            int ans=0;
            for (int j=0;j<a.size();j++){
                int t=zhuan(a[j]);
                if (t==-1||t>=i){//不符合当前进制要求 
                    flag=false;
                    break;
                }
                if (ans*i+t>b){//超过了范围，可能有long long也存不下的情况 
                    flag=0;
                    break;
                }
                ans=ans*i+t;
            }
            if(!flag)continue;
            cnt.push_back(ans);//记录符合要求的十进制数 
        }
        if (cnt.size()==1)cout<<cnt[0]<<"\n";
        else cout<<-1<<"\n";
    }
	return 0;
}
```
### java
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Translation {
    static long n, b;
    static String a;

    // 字符转数字的方法
    public static long zhuan(char s) {
        if (s >= '0' && s <= '9') {
            return s - '0';
        } else if (s >= 'A' && s <= 'F') {
            return s - 'A' + 10;
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextLong();
        while (n-- > 0) {
            a = scanner.next();
            b = scanner.nextLong();
            List<Long> cnt = new ArrayList<>();
            for (int i = 2; i <= 16; i *= 2) {
                boolean flag = true;
                long ans = 0;
                for (int j = 0; j < a.length(); j++) {
                    long t = zhuan(a.charAt(j));
                    if (t == -1 || t >= i) {
                        flag = false;
                        break;
                    }
                    if (ans * i + t > b) {
                        flag = false;
                        break;
                    }
                    ans = ans * i + t;
                }
                if (!flag) {
                    continue;
                }
                cnt.add(ans);
            }
            if (cnt.size() == 1) {
                System.out.println(cnt.get(0));
            } else {
                System.out.println(-1);
            }
        }
        scanner.close();
    }
}    
```
此代码由豆包 AI 翻译。

---

## 作者：luokc (赞：0)

# P12287 [蓝桥杯 2024 国 Java A] 进制判断
## 思路
- 针对每次输入的 $A_i$，尝试把它转换为 $2$、$4$、$8$、$16$ 进制数，并且检查转换后的结果是否小于等于 $B_i$。  
- 要是只有一种转换结果满足条件，就输出该结果；反之，则输出 $-1$。
- 在每次内层循环中，会进行一次进制转换操作。在 Java 里使用 `Integer.parseInt(Ai, base)`，在 C++ 中使用 `stoi(Ai, &pos, base)`。
- 这些操作的时间复杂度和字符串 $A_i$ 的长度有关，假设 $A_i$ 的长度为 $n$，那么进制转换操作的时间复杂度就是 $O(n)$。
## C++代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        string a;
        int b;
        cin >> a >> b;
        int cnt = 0;
        int r = 0;
        vector<int> bases = {2, 4, 8, 16};
        for (int base : bases) {
            try {
                size_t pos;
                int num = stoi(a, &pos, base);
                if (pos == a.size() && num <= b) {
                    cnt++;
                    r = num;
                }
            } catch (const invalid_argument& e) {
                continue;
            } catch (const out_of_range& e) {
                continue;
            }
        }
        if (cnt == 1) {
            cout << r << endl;
        } else {
            cout << -1 << endl;
        }
    }
    return 0;
}    
```
## JAVA21代码

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine();
        for (int i = 0; i < n; i++) {
            String[] line = scanner.nextLine().split(" ");
            String Ai = line[0];
            int Bi = Integer.parseInt(line[1]);
            int count = 0;
            int result = 0;
            int[] bases = {2, 4, 8, 16};
            for (int base : bases) {
                try {
                    int num = Integer.parseInt(Ai, base);
                    if (num <= Bi) {
                        count++;
                        result = num;
                    }
                } catch (NumberFormatException e) {
                    continue;
                }
            }
            if (count == 1) {
                System.out.println(result);
            } else {
                System.out.println(-1);
            }
        }
        scanner.close();
    }
}
```
注：本人 C++ 党，JAVA 是找牢爸写的，有问题请指出。

---


# [蓝桥杯 2025 国 Python A] 哨兵

## 题目背景

建议 Python 用户选择 PyPy3 提交本题。

## 题目描述

小蓝是一位国王，他的王国里有 $n$ 座城市，通过 $n-1$ 条路来连通。他想在城市中部署三组哨兵 $A$、$B$、$C$，每组哨兵部署在一个城市里面，一个城市可以部署多组哨兵。其中 $A$ 到 $B$ 的距离需要和 $A$ 到 $C$ 的距离相同。小蓝想知道 $B$ 到 $C$ 的距离最大是多少。

## 说明/提示

**【样例说明】**

其中一种方案：$A$ 部署在 $5$，$B$ 部署在 $3$，$C$ 部署在 $7$。

**【评测用例规模与约定】**

对于 20% 的评测用例，$1 \leq n \leq 500$；

对于所有评测用例，$1 \leq n \leq 5000$，$1 \leq u_i, v_i \leq n$。

## 样例 #1

### 输入

```
8
1 2
1 3
1 4
4 5
4 6
6 7
7 8```

### 输出

```
4```

# 题解

## 作者：Dream_Stars (赞：1)

## 题目大意：
有一个有 $n$ 个点，$n - 1$ 条边的无向图。\
我们需要寻找 $A$，$B$，$C$ 三个点，使得 $A$ 到 $B$ 与 $A$ 到 $C$ 的距离相等，且 $B$ 到 $C$ 的距离最大。

## 算法分析：

我们可以将这个无向图看成一颗树，距离最长即求该树的直径。\
所以我们可以用两次 dfs 来解决，第一次找到离一个任意点距离最远的点 $P$，第二次从 $P$ 点开始 dfs，找到距离最远的点 $Q$，可以证明 $P$，$Q$ 间距离最远，即是树的直径，具体可以[戳这里](https://oi.wiki/graph/tree-diameter/)。\
所以直径的两个端点分别是 $C$，$B$，在中间选取 $A$，但是因为距离是整数，所以 $B$，$C$ 不一定会取到直径的两端点上，需要向下取整，具体可见代码。

## 代码展示：

C++ 代码：
```cpp
# include <bits/stdc++.h>

# define ll long long
# define int long long
# define rint register int

long long read(){long long s = 0 , w = 0; char c = getchar(); while(!isdigit(c)) w |= (c == '-') , c = getchar(); while(isdigit(c)) s = (s << 1) + (s << 3) + (c ^ 48) , c = getchar(); return w ? -s : s;}
void write(long long x){if(x < 0) putchar('-') , x = ~ (x - 1); if(x > 9) write(x / 10); putchar(x % 10 | 48);}
void writesp(long long x){write(x) , putchar(' '); }
void writeln(long long x){write(x) , putchar('\n');}

using namespace std;

constexpr int N = 5010;

long long n,c,u,v,ans,d[N];
vector<ll> e[N];

void dfs(ll u , ll fa) {
  for(int v : e[u]) {
    if(v == fa) continue;
    d[v] = d[u] + 1;
    if (d[v] > d[c]) c = v;
    dfs(v , u);
  }
  return ;
}

signed main() {
  n = read();
  for(rint i = 1 ; i < n ; i ++)
    u = read(),
    v = read(),
    e[u].push_back(v),
    e[v].push_back(u);//用 vector 存图。
  dfs(1, 0);//从任意点开始 dfs。
  d[c] = 0,
  dfs(c, 0);//从第一次的最远点开始 dfs。
  ans = d[c];//两次 dfs 求树的直径。
  if(ans % 2 == 0) write(ans);
  else write(ans - 1);//判断 B 和 C 是否可以取在两端点上。
  return 0;
}
```
Python 代码：
```python
import sys
from collections import defaultdict

def main():
  sys.setrecursionlimit(1000000)
  n = int(sys.stdin.readline())
  e = defaultdict(list)
  for _ in range(n - 1):
    u, v = map(int, sys.stdin.readline().split())
    e[u].append(v)
    e[v].append(u)
  c = 0
  d = [0] * (n + 1)
  def dfs(u, fa):
    nonlocal c
    for v in e[u]:
      if v == fa: continue
      d[v] = d[u] + 1
      if d[v] > d[c]: c = v
      dfs(v , u)
  dfs(1 , 0)
  d = [0] * (n + 1)
  dfs(c , 0)
  ans = d[c]
  print(ans if ans % 2 == 0 else ans - 1)

if __name__ == "__main__":
  main()
```

---

## 作者：_ByTT_ (赞：1)

# 题解：P12873 [蓝桥杯 2025 国 Python A] 哨兵
### 题意
在一棵树上找到三点 $A,B,C$，要求 $A$ 到 $B,C$ 距离相等，求 $B,C$ 距离的最大值。
### 思路
思路很好想，首先将目光注焦到问题，树上两点最长距离，那不就是树的直径上的两个端点吗。然后要有一点到两个端点的距离相等，那么就要分直径长度是奇数还是偶数了，偶数可以直接找中间，但是奇数就需要将 $B,C$ 中一个点往中间拉，即将直径长度减一。

求直径可以两次 dfs 或树形 dp，可按个人喜好选择。
### 代码
```cpp
import sys
from collections import deque
sys.setrecursionlimit(1000000)
class Edge:
	def __init__(self,v,nxt):
		self.v=v
		self.nxt=nxt
n=int(sys.stdin.readline())
tot=0
head=[0]*(n+1)
eg=[Edge(0,0) for _ in range(n*2+5)]
d1=[0]*(n+1)
d2=[0]*(n+1)
ans=0
def add(u,v):
	global tot
	tot+=1
	eg[tot]=Edge(v,head[u])
	head[u]=tot
def dfs(u,fa):
	global ans
	i=head[u]
	while i!=0:
		v=eg[i].v
		if v!=fa:
			dfs(v,u)
			if d1[v]+1>d1[u]:
				d2[u]=d1[u]
				d1[u]=d1[v]+1
			elif d1[v]+1>d2[u]:
				d2[u]=d1[v]+1
		i=eg[i].nxt
	ans=max(ans,d1[u]+d2[u])
for _ in range(n-1):
	u,v=map(int,sys.stdin.readline().split())
		add(u,v)
		add(v,u)
dfs(1,0)
print((ans//2)*2)
```
```cpp
#include <bits/stdc++.h>
using namespace std;
#include <bits/stdc++.h>
using namespace std;
struct egde{
	int v,nxt;
}eg[500005];
int head[500005],n,r[550005],d1[550005],d2[550005],tot,ans;
void add(int u,int v){
	eg[++tot]={v,head[u]};
	head[u]=tot;
}
void dfs(int u,int fa){
	for(int i=head[u];i;i=eg[i].nxt){
		int v=eg[i].v;
		if(v==fa) continue;
		dfs(v,u);
		if(d1[v]+1>d1[u]){
			d2[u]=d1[u];
			d1[u]=d1[v]+1;
		}else if(d1[v]+1>d2[u]){
			d2[u]=d1[v]+1;
		}
	}
	ans=max(ans,d1[u]+d2[u]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;add(u,v);add(v,u);
	}
	dfs(1,0);
	cout<<ans/2*2;
	return 0;
}
```

---

## 作者：zhaokeyu123 (赞：1)

## 题意
我们需要在树中找到三个点 $A B C$，使得 $A$ 到 $B$ 的距离等于 $B$ 到 $C$ 的距离，并最大化 $B$ 到 $C$ 的距离。
## 思路
求 $B$ 到 $C$ 的最长距离我们很容易想到树的直径，但题目要求 $A$ 到 $B$ 的距离必须等于 $B$ 到 $C$ 的距离所以必使直径长度为偶数，所以若直径长度为奇数须减一。这里给出一个树型 dp 求直径的方法，设 $s1_u$ 为以 $u$ 为端点的最长链， $s2_u$ 表示第二长链，那么就可以得到递推式 $s1_u=\max(s1_u,s1_v+1)$ 其中 $v$ 表示 $u$ 的子节点，若满足 $s1_v+1>s1_u$ 则 $s2_u=s1_u$，那么答案就显而易见了。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct edge
{
	int v,nxt;
}eg[2000005];
int ans,r[600005],head[600005],dp[6005][2],flg[600005],tot,root,s1[200005],s2[200005];
void addedge(int u,int v)
{
	eg[++tot]={v,head[u]};
	head[u]=tot;
}
void dfs(int u,int fa)
{
	for(int i=head[u];i>0;i=eg[i].nxt)
	{
		int v=eg[i].v;
		if(v==fa)continue;
		dfs(v,u);
		if(1+s1[v]>s1[u])
		{
			s2[u]=s1[u];
			s1[u]=s1[v]+1;
			
		}
		else if(1+s1[v]>s2[u])
		{
			s2[u]=s1[v]+1;
		}
	}
	ans=max(ans,s1[u]+s2[u]);
}
signed main()
{
	int n;cin>>n;
	for(int i=1,u,v;i<n;i++)
	{
		cin>>u>>v;
		addedge(u,v);
		addedge(v,u);
	}
	dfs(1,1);
	ans=ans%2?ans-1:ans;
	cout<<ans;
	return 0;
}
```

---

## 作者：Belia (赞：1)

### 题意：

小蓝的王国由 $n$ 座城市通过 $n-1$ 条路连通。他需要在城市中部署三组哨兵 $(A,B,C)$，要求 $A$ 到 $B$ 的距离等于 $A$ 到 $C$ 的距离。目标是最大化 $B$ 到 $C$ 的距离。

### 思路：

题意已说明：$dist(a,b)=dist(a,c)=d$。

而我们不难发现：存在节点 $x$（分叉点），使得 $b$ 和 $c$ 在 $x$ 的不同分支上，且 $dist(x,b)=dist(x,c)=k$，则 $dist(b,c)=2k$。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//#define ll long long你值得拥有
using namespace std;
const int maxn=5005;
ll n,ans,pa[maxn],mx1[maxn],mx2[maxn],son1[maxn],dep2[maxn];
vector <ll> g[maxn];
void dfs1(ll u,ll fa)
{
    pa[u]=fa,mx1[u]=mx2[u]=-1;
    for(auto v:g[u])
	{
        if(v==fa)
		continue;
        dfs1(v,u);
        ll d=mx1[v]+1;
        if(d>mx1[u])
        mx2[u]=mx1[u],mx1[u]=d,son1[u]=v;
		else if(d>mx2[u])
        mx2[u]=d;
    }
    if(mx1[u]==-1)
	mx1[u]=0;
}
void dfs2(ll u,ll fa)
{
    for(auto v:g[u])
	{
        if(v==fa)
		continue;
        dep2[v]=dep2[u]+1;
        if(son1[u]==v)
		{
            if(mx2[u]!=-1)
			dep2[v]=max(dep2[v],mx2[u]+1);
        }
		else
		{
            if(mx1[u]!=-1)
			dep2[v]=max(dep2[v],mx1[u]+1);
        }
        dfs2(v,u);
    }
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//cincout加速代码
    cin>>n;
    for(ll i=1,u,v;i<n;i++)
	cin>>u>>v,g[u].push_back(v),g[v].push_back(u);
    dep2[1]=0,dfs1(1,0),dfs2(1,0);
    for(ll u=1;u<=n;u++)
	{
        vector <ll> deps;
        if(pa[u]!=0)
		deps.push_back(dep2[u]);
        for(auto v:g[u])
		{
            if(v==pa[u])
			continue;
            deps.push_back(mx1[v]+1);
        }
        if(deps.size()<2)
		continue;
        sort(deps.begin(),deps.end(),greater<ll>());
        ans=max(ans,2*min(deps[0],deps[1]));
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：one_zero_two_zero (赞：1)

~~靠颜色写出来的题目。~~

先说结论：**答案即为小于等于该树的直径的最大偶数**。

**【证明】**

![](https://cdn.luogu.com.cn/upload/image_hosting/3hkcib5s.png)

以样例为例进行说明。

$A\rightarrow B$ 与 $B\rightarrow C$ 的路径有两种情况：有重合与没有重合。

我们先看没有重合的情况。

这种情况下，$A\rightarrow B\rightarrow C$ 的路径就可以提取出来作为一条链，$A$ 和 $B$ 的距离即为这条链的长度。

既然是最大化长度，那我们肯定要找出最长的一条链，那就是树的直径了。

但是还没完！因为 $A\rightarrow B$ 和 $B\rightarrow C$ 长度必须一致，所以我们找出的链的长度必须为偶数。如果直径长为奇数，那就只能忍痛割爱删掉一个点了。

再看有重合的情况。

因为这是一颗树，所以如果有重合，那我们一点可以找出一点 $D$（可能与 $A$ 或 $C$ 重合），将路径表示为

$$
A\rightarrow D\rightarrow B\rightarrow D\rightarrow C
$$

由于路径长度指的是最短路径长度，而 $D\rightarrow B$ 与 $B\rightarrow D$ 的长度是一样的。

所以将 $B$ 点修改为 $D$ 点，**既不会影响答案，又不会影响距离相等的限制**。

因此所有有重合的情况都可以变为无重合的情况，使用上一种情况的证明。

证毕。

**【实现】**

其实直径有好几种求法，两次 BFS/DFS 或者动态规划都行。

但是本题 $N$ 仅为 $5000$，所以我们直接进行 $N$ 次 DFS/BFS。

注：Python 跑这种做法跑不过去，所以下面的 Python 代码用了经典的两次 DFS。以及 Python 代码中手开了递归深度，否则有两个点会 RE。

> 小技巧，最后一步找出不大于直径的最大偶数，可以用 `/2*2`(C++)来完成。

**【完整代码】**

**Python**

```py
import sys
sys.setrecursionlimit(10000)

N = int(input())
E = [[] for _ in range(5005)]
ans = 0
anspoint = 1

def dfs(u, f, dep):
    global ans
    global anspoint
    if dep > ans:
        anspoint = u
        ans = dep
    for v in E[u]:
        if v == f:
            continue
        dfs(v, u, dep + 1)

for _ in range(N - 1):
    u, v = map(int, input().split())
    E[u].append(v)
    E[v].append(u)

dfs(1, 1, 0)
dfs(anspoint, anspoint, 0)

print(ans // 2 * 2)
```

**C++**

```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;

int N, ans = 0;
int u, v;
vector<int> E[5005];

void dfs(int u, int f, int dep){
  ans = max(ans, dep);
  for (auto && v : E[u]){
    if (v == f)
      continue;
    dfs(v, u, dep + 1);
  }
}

int main(){
  scanf("%d", &N);
  for (int i = 1; i < N; i ++){
    scanf("%d %d", &u, &v);
    E[u].push_back(v);
    E[v].push_back(u);
  }
  for (int i = 1; i <= N; i ++){
    dfs(i, i, 0);
  }
  printf("%d\n", ans / 2 * 2);
  
  return 0;
}
```

---

## 作者：_OokoukioO_ (赞：0)

# 题目简述
### 题意
给定一张无向无权图，图中存在三个点 $A$、$B$、$C$，$A$ 到 $B$ 的距离必须等于 $B$ 到 $C$ 的距离，并最大化 $B$ 到 $C$ 的距离。

### 思路
这题很明显是[树的直径](https://www.luogu.com.cn/problem/B4016)模板题，并且且答案一定为偶数。

或许有人不懂为什么要求直径，为什么一定要是偶数。

### 证明
假设 $A$ 与 $B$ 连通，$B$ 不与 $C$ 连通，则 $B$ 和 $C$ 之间不存在距离，本题无解，因此三个点一定连通，三个点一定会形成一条链。

那么最后的结果就是求在这张图上，最长的一条链的长度，也就是树的直径。

由于两点距离必须相等，因此一定有 $|A-B|=|C-B|=|C-A| \div 2$，如果树的直径是奇数，那么除以 $2$ 的结果必然为小数，图中不存在半条边这种说法，因此结果必然为偶数。

证毕。

所以本题用深度优先搜索求解树的直径即可，设树的直径为 `res`，则答案为 `res - res % 2`，如果 `res` 为奇数，就输出 `res - 1`，否则输出 `res`。
## [AC 代码](https://www.luogu.com.cn/record/227455656)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long
const int N = 1e5 + 5;
int n, f[N], res;
vector <int> e[N];

void dfs(int x, int fa) { //计算树的直径
	for (int i = 0; i < e[x].size(); i++) {
		int v = e[x][i];
		if (v == fa)
			continue;
		dfs(v, x); //继续搜索
		res = max(res, f[x] + f[v] + 1), f[x] = max(f[x], f[v] + 1); //计算res
	}
}

signed main() {
	ios::sync_with_stdio(false), in.tie(nullptr), out.tie(nullptr);
	in >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		in >> u >> v;
		e[u].emplace_back(v), e[v].emplace_back(u); //无向边
	}
	dfs(1, 0); //搜索树的直径
	out << res - res % 2;
	return 0;
}
```

---

## 作者：chenyanyu1 (赞：0)

写一篇 C++ 的题解。
### [题目传送门](https://www.luogu.com.cn/problem/P12873)
## 思路
$A\rightarrow B$ 以及 $A\rightarrow C$ 有重合和不重合两种可能：  
### 1. 不重合
如果 $A\rightarrow B$ 与 $A\rightarrow C$ 不重合，则 $A,B,C$ 三个点可以提取成一条链。因为$A\rightarrow B$ 和 $A\rightarrow C$ 要相等，所以如果不重合最大值就是小于等于这棵树的直径的最大偶数。
### 2. 重合
如果 $A\rightarrow B$ 与 $A\rightarrow C$ 重合，则我们一定能找到一个点 $D$ 将路径变成 $B\rightarrow D\rightarrow A\rightarrow D\rightarrow C$。因为$A\rightarrow D$ 和 $D\rightarrow A$ 一定相等，所以可以将 $A$ 直接转移到 $D$，从而将重合变成不重合。  
所以，答案便是小于等于这棵树的直径的最大偶数。
## 方法
我们可以用 dfs 或者 bfs 来求解（其实方法很多）。以下我将出示 dfs 的算法。
## Code
```ccp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans;
vector<int> g[5005];
void dfs(int u,int f,int sum)
{
	ans=max(ans,sum);
	for(int v:g[u])
	{
		if(v==f)
			continue;
		dfs(v,u,sum+1);
	}
}
signed main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
		dfs(i,i,0);
	cout<<ans/2*2;
	return 0;
}
```
[AC](https://www.luogu.com.cn/record/221524154)

---

## 作者：yanzixuan2024 (赞：0)

树的直径板题。主要就是如何求树的直径。

先从根节点开始，一次深搜求出离它最远的节点 $x$ 。再从 $x$ 开始，一次深搜求出离它最远的节点 $y$ ，此时 $x$ 和 $y$ 为树的直径的两端，它俩之间的距离为树的直径的长度。证明可以看[这里](http://oi-wiki.com/graph/tree-diameter/)。

还有个细节，最后答案不是直径。因为我们求的直径是 $B$ 到 $C$ 的最大值，而本题要求的是 $A$ 到 $B$ 和 $A$ 到 $C$ 的距离相等，所以答案一定是偶数。当直径为奇数时，答案就是直径减一。把直径整除二再乘以二，就可以包含两种情况。

```cpp
import sys
from collections import deque

sys.setrecursionlimit(1 << 25)

maxn = 114514
n = 0
res = 0
dis = [0] * maxn
v = [[] for _ in range(maxn)]

def dfs(x, f):
    global res
    if dis[x] > dis[res]:
        res = x
    for i in v[x]:
        if i == f:
            continue
        dis[i] = dis[x] + 1
        dfs(i, x)

n = int(sys.stdin.readline())
for _ in range(n-1):
    x, y = map(int, sys.stdin.readline().split())
    v[x].append(y)
    v[y].append(x)

dis[1] = 1
dfs(1, 0)

dis[res] = 0
dfs(res, 0)

print(dis[res] // 2 * 2)
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
题目要我们在树中寻找三点 $A$、$B$、$C$，满足 $A$ 到 $B$ 的距离等于 $A$ 到 $C$ 的距离，并最大化 $B$ 到 $C$ 的距离。解决步骤如下：
1. 直接暴力枚举三个点肯定超时，我们可以用广度优先搜索预处理每对节点之间的距离。
2. 枚举所有节点，把那个节点之外其他节点按到那个节点的距离分组。
3. 高效计算组内的最大距离：
+ 任取组内一点，找到组内离它最远的点 $u$。
+ 再找组内离它最远的点 $v$。
+ $u$ 和 $v$ 的距离即为该组最大距离。
4. 比较所有所有组的最大距离，最大的即为答案。
### C++ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,u,v,d[5005][5005],m;
vector<int>a[5005];
queue<int>q;
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>u>>v;
        a[u].push_back(v);
        a[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)d[i][j]=-1;
        d[i][i]=0;
        q.push(i);
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int y:a[x]){
                if(d[i][y]==-1){
                    d[i][y]=d[i][x]+1;
                    q.push(y);
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        unordered_map<int,vector<int>>p;
        for(int j=1;j<=n;j++){
            int dis=d[i][j];
            p[dis].push_back(j);
        }
        for(auto&k:p){
            vector<int>&s=k.second;
            if(s.size()<2)continue;
            int x0=s[0];
            int u=x0,maxd=-1;
            for(int j=0;j<s.size();j++){
                int node=s[j];
                if(d[x0][node]>maxd){
                    maxd=d[x0][node];
                    u=node;
                }
            }
            maxd=-1;
            for(int j=0;j<s.size();j++){
                int node=s[j];
                if(d[u][node]>maxd){
                    maxd=d[u][node];
                }
            }
            m=max(m,maxd);
        }
    }
    cout<<m;
    return 0;
}
```
### Python 代码：
```python
import sys
from collections import deque

def main():
    data = sys.stdin.read().split()
    if not data:
        return
    n = int(data[0])
    a = [[] for _ in range(n+1)]
    idx = 1
    for _ in range(n-1):
        u = int(data[idx])
        v = int(data[idx+1])
        idx += 2
        a[u].append(v)
        a[v].append(u)
    
    ans = 0
    for A in range(1, n+1):
        dep = [-1] * (n+1)
        col = [0] * (n+1)
        cnt = [0] * (n+1)
        minc = [10**9] * (n+1)
        maxc = [-1] * (n+1)
        q = deque()
        dep[A] = 0
        q.append(A)
        c = 1
        for neighbor in a[A]:
            if dep[neighbor] == -1:
                dep[neighbor] = 1
                col[neighbor] = c
                q.append(neighbor)
                cnt[1] += 1
                if c < minc[1]:
                    minc[1] = c
                if c > maxc[1]:
                    maxc[1] = c
                c += 1
        while q:
            x = q.popleft()
            for y in a[x]:
                if dep[y] == -1:
                    dep[y] = dep[x] + 1
                    col[y] = col[x]
                    q.append(y)
                    d = dep[y]
                    cnt[d] += 1
                    if col[y] < minc[d]:
                        minc[d] = col[y]
                    if col[y] > maxc[d]:
                        maxc[d] = col[y]
        for d in range(1, n+1):
            if cnt[d] < 2:
                continue
            if minc[d] == maxc[d]:
                candidate = 2 * d - 2
            else:
                candidate = 2 * d
            if candidate > ans:
                ans = candidate
    print(ans)

if __name__ == "__main__":
    main()
```
**将 C++ 代码转化为 Python 代码的工作由 deepseek 完成。**

---


# [蓝桥杯 2025 国 Java B] 钟楼管理员

## 题目描述

小蓝是小镇钟楼的管理员，负责维护一座古老的时钟。这座时钟的表盘上刻有从 $1$ 到 $N$ 的连续整数，初始时指针指向 $1$。平时，小蓝通过顺时针或逆时针拨动指针调整时间：顺时针拨动一次，指针从当前数字 $x$ 移至 $x+1$（若 $x=N$，则移至 $1$）；逆时针拨动一次，指针从 $x$ 移至 $x-1$（若 $x=1$，则移至 $N$）。

然而，一场突如其来的暴风雨损坏了钟楼。表盘因风沙侵蚀变得模糊不清，小蓝无法看清指针的当前位置；机械装置也因故障失灵，导致他拨动指针时方向随机——可能是顺时针或逆时针，且拨动前无法预测方向。

小蓝记得暴风雨后他总共拨动了 $K$ 次指针。为了确定指针的最终位置，他希望计算出经过这 $K$ 次随机拨动后，指针最终可能指向的数字有多少个。

现在，请你帮助小蓝解决这个问题。

## 说明/提示

**【样例说明】**

对于第一个样例 $N=4, K=1$，表盘有数字 $1, 2, 3, 4$，初始指针指向 $1$。拨动 $1$ 次后，可能顺时针移至 $2$，或逆时针移至 $4$，因此指针最终可能指向的数字有 $2$ 个。

对于第二个样例 $N=5, K=2$，表盘有数字 $1, 2, 3, 4, 5$，初始指针指向 $1$。拨动 $2$ 次后，可能的结果为：顺时针两次至 $3$、顺时针再逆时针或逆时针再顺时针至 $1$、逆时针两次至 $4$，因此指针最终可能指向的数字有 $3$ 个。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \leq T \leq 10^2$，$2 \leq N \leq 20$，$1 \leq K \leq 20$。

对于 $100\%$ 的评测用例，$1 \leq T \leq 10^5$，$2 \leq N \leq 10^9$，$1 \leq K \leq 10^9$。


## 样例 #1

### 输入

```
2
4 1
5 2```

### 输出

```
2
3```

# 题解

## 作者：Jason_xuan (赞：3)

# 题目大意
给你一个数 $n$, 一个钟表上有 $n$ 个数 $1$ 到 $n$ (注意是环形)，一个指针要从 $1$ 开始移动 $k$ 次，每次可以移动到相邻两个数，问能走到多少个不同的位置
# 思路
很容易想到走 $k$ 次可以走到 $k$ 和 $-k$，而由于 $n$ 的限制，那么答案就是 $\min(n,k+1)$。

信心满满地交了一发，$35$ 分。

又考虑到当 $n$ 为偶数的时候，由于时钟的对称性，拨动的次数每次会有 $2$ 个位置成对地重复，所以可能的不同位置数受到限制。此时，答案为 $\min(n/2,k+1)$。

最终答案就显而易见了。

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define TRACE 1
#define tcout TRACE && cout

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

#define int long long

const int P = 998244353;
const int Base = 3221225477;
const int INF = 0x3f3f3f3f3f3f3f3f;

const int N = 1e3 + 10, M = 2e6 + 10;

int t;

int n, k;

void solve()
{
	cin >> n >> k;
	if(n % 2)//当n为奇数时 
	{
		cout << min(k + 1, n) << endl;//输出答案 
	}
	else//当n为偶数 
	{
		cout << min(k + 1, n / 2) << endl;//输出答案
	}
}

signed main() 
{
	fst; //个人习惯 
    cin >> t;
    while(t--)
    {
    	solve();
	}
	//多测模板 
    return 0;
}
```

---

## 作者：HSH_starlight (赞：2)

## 题意简述

有一个钟表，表盘上是从 $1$ 到 $N$ 的连续整数，初始时指针指向 $1$。每次拨动指针，指针会移动一格，经过 $K$ 次这样的随机拨动（可以顺时针也可以逆时针）后，指针可能指向多少个不同的数字？

**注**：表盘是环形！！！

## 思路

我们假设 $K$ 次移动中有 $a$ 次顺时针移动， $b$ 次逆时针移动，那么指针最后的位置可以表示为 $((a-b)+1) \bmod N$，又因为 $a+b=K$，所以我们将式子转化为： $((2a-(b+a))+1) \bmod N=(2a-K+1) \bmod N=((2a-K) \bmod N)+(1 \bmod N)$。

注意到上式中只有 $(2a-K) \bmod N$ 是变量，所以 $(2a-K) \bmod N$ 的不同余数的个数就是最终答案。很容易可以得到 $2a-K$ 的取值范围是 $-K(a=0)$ 到 $K(a=K)$，并且步长为 $2$。

分类讨论后发现 $(2a-K) \bmod N$ 的不同余数的个数与步长 $2$ 和 $N$ 的最大公约数有关。

- 如果 $\operatorname{gcd}(2, N)=1$（即 $N$ 是奇数），序列 $(2a-K) \bmod N$ 会覆盖所有可能的余数，最多为 $\operatorname{min}(K+1, N)$。

- 如果 $\operatorname{gcd}(2, N)=2$（即 $N$ 是偶数），序列 $(2a-K) \bmod N$ 会覆盖所有同奇偶的余数，最多为 $\operatorname{min}(K+1, N/2)$。

## 代码


```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

signed main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) 
    {
        int n,k;
        cin >> n >> k;
        int ans;
        if(n%2==1)ans=min(k+1,n);
        else ans=min(k+1,n/2);
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

## 思路
分为两种情况
1. **没有重叠**：因为拨动 $k$ 次，所以范围应该是 $2k+1$。
    - 而 $k$ 是奇数时，顺时针 $\frac{k + 1}{2}$ 个，逆时针 $\frac{k + 1}{2}$ 个，总共 $k+1$ 个。
    - $k$ 是偶数时，顺时针 $\frac{k}{2}$ 个，逆时针 $\frac{k}{2}$ 个，总共 $k+1$ 个。
    -  所以一共 $k+1$ 个。

2.  **已经重叠**： 因为它是一个环，那肯定有重叠的时候。
    - 当 $n$ 为奇数时，增加和减少会错开，所以只要 $k$ 大于等于 $n$ 时，就输出 $n$ 就行了。
    - 当 $n$ 为偶数时，只要 $k$ 达到 $n$ 一半就行了，因为 $n$ 的个数是偶数，到一半就重叠了。

最后答案比较 $k+1$ 和 $\frac{n}{2}$ 或 $n$ 就行了。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    cin>>t;
    while (t--) 
    {
        int n,k;
        cin>>n>>k;
        int ans=(n%2)?n:n/2;
        cout<<min(k+1,ans)<<"\n";
    }
    return 0;
}
```

---

## 作者：zhaokeyu123 (赞：1)

## 题意
题目描述了一座钟楼，表盘上有数字 $1$ 到 $n$，初始指针指向 $1$。小蓝进行了 $k$ 次随机拨动（每次拨动方向随机，可能是顺时针或逆时针）。我们需要计算经过 $k$ 次拨动后，指针可能指向的不同数字的个数。
## 思路
我们观察题目可知，当 $k$ 大于 $n$ 时，即可以走到所有位置，反之就只能走到 $k+1$ 个位置。但是考虑到圆的对称性，所以当 $n$ 为偶数时就只能走到 $\min(k+1,\frac{n}{2})$ 个位置，所以答案就显而易见了。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
    int T;cin >> T;
    while (T--) {
        long long N, K;
        cin >> N >> K;
        long long cycle;
        if (N % 2 == 1)
            cycle = N;
        else
            cycle = N / 2;
        long long ans = min(K + 1, cycle);
        cout << ans << "\n";
    }
    return 0;
}
```

---

## 作者：Eden_star (赞：1)

## 思路
当 $N$ 为奇数时，$2$ 和 $N$ 的最大公约数为 $1$，此时指针可能的位置数受限于拨动次数 $K+1$ 和 $N$ 的较小值。

当 $N$ 为偶数时，$2$ 和 $N$ 的最大公约数为 $2$，此时指针可能的位置数受限于拨动次数 $K+1$ 和 $\frac{N}{2}$ 的较小值。

## 代码
由于这道题的题解最好需要有 Java 。所以决定现学 Java。

```java
import java.util.Scanner;//类似于头文件

public class Main {// 定义公共类Main（Java程序的入口点必须在public类中）
    public static void main(String[] args) {// main 函数
        Scanner cin = new Scanner(System.in);//定义输入
        long _ = cin.nextLong();
        while (_-- > 0) {
            long n = cin.nextLong();
            long k = cin.nextLong();
            long ans = (n % 2 == 1) ? n : n / 2;
            System.out.println(Math.min(k + 1, ans));
        }
    }
}
```

---

## 作者：TLE_qwq (赞：0)

### 解题思路

- 大概观察：
   - 每次拨动相当于在模 $N$ 的环上移动。
   - $K$ 次移动后，指针位置取决于净移动量。

- 发现：


  可以分多种情况来考虑：
   - 当 $K < N$ 时，指针不会绕完整圈，可能位置数就是 $K+1$（但不能超过 $N$）。
   - 当 $K ≥ N$ 时：
     - 如果 $N$ 是奇数：就可以到达所有 $N$ 个位置。
     - 如果 $N$ 是偶数：就只能到达 $\frac{n}{2}$ 个位置。

### 代码解析

```cpp
#include <iostream>
using namespace std;

void solve() {
    int T;  // 测试用例数量
    cin >> T;
    while (T--) {
        int N, K;
        cin >> N >> K;
        int m;  // 最大可能位置数
        
        if (N % 2 == 1) {  // 奇数情况
            m = N;  // 可以到达所有位置
        } else {  // 偶数情况
            m = N / 2;  // 只能到达一半位置
        }
        
        // 取 K+1 和 m 的较小值
        cout << min(K + 1, m) << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}
```

---

## 作者：_ByTT_ (赞：0)

# 题解：P12888 [蓝桥杯 2025 国 Java B] 钟楼管理员
### 题意
有两个整数 $N,K$。$N$ 表示数列长度，数列是 $1,2,3···,n-1,n$。$K$ 表示走了几步。每一步可以向左右移动，使当前位置从 $i$ 至 $i+1$ 或 $i-1$。且数列是环形，即当 $i=n$ 时，$i$ 右移可以变为 $1$。当 $i=1$ 时，$i$ 左移可以变为 $n$。

求 $K$ 步可以到达多少个不同的数字下标。

### 思路
乍一看可能没有什么思路，但多模几个样例就可以发现应该是要用 $N$ 的奇偶性来判断的。

当 $N$ 为偶数时，很明显，我们最多只能走 $\frac{N}{2}$ 个位置，因为当我们需要走 $K$ 步，那么就只可能全部走到**偶数或奇数**的位置上，也就是会走到 $K+1$ 个位置上。同时，要注意最多只会走 $\frac{N}{2}$ 个位置。

当 $N$ 为奇数时，与上述差不多，但因为是环形数列，所以 $K$ 足够大时可以去到所有位置，即 $N$。

综上所述，代码可写。
### 代码
```cpp
//Java
import java.util.Scanner;
public class Main{
	public static void main(String[] args){
		Scanner wls=new Scanner(System.in);
		long x=wls.nextLong();
		while(x-->0){
            long n=wls.nextLong();long k=wls.nextLong();
			if(n%2==0){System.out.println(Math.min(n/2,k+1));
			}else{
				System.out.println(Math.min(n,k+1));
			}
		}
	}
}
```
```cpp
//C++
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T,n,k;cin>>T;
	while(T--){
		cin>>n>>k;
		if(n%2==0) cout<<min(n/2,k+1)<<'\n';
		else cout<<min(n,k+1)<<'\n';
	}
	return 0;
}
```

---

## 作者：ZTengW (赞：0)

以防有粗心的小朋友忘记了题号：  
[please click here](https://www.luogu.com.cn/problem/P12888)  
## 大意  
我们需要计算在 $K$ 次随机拨动后，指针最终可能指向的不同数字个数。  
## 关键点  
1. 初始位置为 $1$（对应位置 $0$）。  
2. 每次拨动方向随机（$+1$ 或 $-1$，模 $N$ 意义下）。  
3. 最终位置由公式 $1+(K-2 \times b) \bmod N$ 决定，其中 $b$ 为逆时针拨动次数 $(0 ≤ b ≤ K)$。  
4. 不同位置个数取决于步长与 $N$ 的最大公约数 $g$（$g$ 为 $1$ 或 $2$），以及 $K$ 与周期 $m (m=N \div g)$ 的关系：
     - 若 $K \ge m-1$，则位置个数为 $m$。  
     - 否则，位置个数为 $K+1$。
## [AC](https://www.luogu.com.cn/record/221304771) 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    ll t,n,k;
    scanf("%lld",&t);
    while(t--)
    {
        scanf("%lld%lld",&n,&k);
        if(n%2==0)
        {
            ll m=n/2;
            if(k>=m-1)
                printf("%lld\n",m);
            else
                printf("%lld\n",k+1);
        }
        else
        {
            ll m=n;
            if(k>=m-1)
                printf("%lld\n",m);
            else
                printf("%lld\n",k+1);
        }
    }
    return 0;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
简单来说，指针初始在 $1$，每次随机向左或右走一步，走 $K$ 次后可能停在哪些位置。表盘是环形的（$1$ 和 $N$ 相连）。关键看 $N$ 是奇数还是偶数：
+ $N$ 是奇数：走足够多步（$K+1\geq N$）就能到所有位置，否则只能到 $K+1$ 个位置。

+ $N$ 是偶数：只能停在和初始位置奇偶性相同的位置。如果走足够多步（$K+1\geq N/2$）就能覆盖所有同奇偶的位置，否则只能到 $K+1$ 个位置。
### C++ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,k;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>k;
		if(n&1){
			if(k+1>=n)cout<<n<<'\n';
			else cout<<k+1<<'\n';
		}
		else{
			long long t=n/2;
			if(k+1>=t)cout<<t<<'\n';
			else cout<<k+1<<'\n';
		}
	}
	return 0;
}
```
### Java 代码：
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long T, n, k;
        T = sc.nextLong();
        while (T-- > 0) {
            n = sc.nextLong();
            k = sc.nextLong();
            if ((n & 1) == 1) {
                if (k + 1 >= n) System.out.println(n);
                else System.out.println(k + 1);
            } else {
                long t = n / 2;
                if (k + 1 >= t) System.out.println(t);
                else System.out.println(k + 1);
            }
        }
    }
}
```
**将 C++ 代码转化为 Java 代码的工作由 deepseek 完成。**

---


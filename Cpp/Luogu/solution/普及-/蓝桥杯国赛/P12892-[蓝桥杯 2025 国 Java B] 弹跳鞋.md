# [蓝桥杯 2025 国 Java B] 弹跳鞋

## 题目描述

小 A 穿上了一双神奇的弹跳鞋，他可以给弹跳鞋充能 $x$ 点能量并启动，然后弹跳鞋会连续弹跳 $x$ 次，过程中无法停止。

其中，第 $i$ 次弹跳时小 A 可以跳跃的距离恰好为 $x - i + 1$。

小 A 正站在一条路上，他希望跳到距离自己 $L$ 的位置，你可以认为小 A 只能向正反两个方向跳跃，不需要考虑路的宽度。

小 A 想知道，如果他只给鞋子充能一次，他在所有弹跳完成后能否停在目标位置。如果能，输出最低需要多少能量；如果不能，输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$L \leq 100$。

对于 $60\%$ 的评测用例，$L \leq 5000$。

对于 $100\%$ 的评测用例，$1 \leq L \leq 10^{18}$。


## 样例 #1

### 输入

```
4```

### 输出

```
3```

# 题解

## 作者：_Yonder_ (赞：12)

可笑吗？我访问提交记录的时候有多慌张。他会 AC 吗，隐私用户只有我能看的模样。从夜深人静，一直调过到天亮。你反正不会再担心，我隐隐作疼的心脏。

显然题目是要你找到一个 $i$ 使得 $S=\{1,2,\ldots,i\}$，问是否存在一个子集的和为 $b$ 满足 $\frac{i(i+1)}{2}-2b=n$。

结论：第一个 $\frac{i(i+1)}{2}$ 大于等于 $n$ 且 $\frac{i(i+1)}{2}\equiv n\pmod{2}$ 的 $i$ 为答案。可以发现 $b=\frac{\frac{i(i+1)}{2}-n}{2}$，只要证明 $b$ 可以被凑出来的即可，因为 $b\le \frac{i(i+1)}{2}$，所以这是成立的。

---

## 作者：chenxi2009 (赞：5)

## 思路
水一篇题解。

容易发现不会有无解的情况：充能 $2L$，前跳，后跳，前跳，后跳......每两步造成 $1$ 的位移，最终总位移为 $L$。

我们要求最少充能的能量。显然充能 $x$，最多可以向前跳 $\frac{x(x+1)}{2}$ 这么远。我们要选择在向前跳了这么远的基础上，选择一些步骤，把它们从向前跳改成向后跳。设选择的步骤跳跃长度之和是 $y$，那么我们要让 $\frac{x(x+1)}{2}-2y=L$，即 $y=(\frac{x(x+1)}{2}-L)\div2$。

我们有一个结论：对于 $1$ 到 $\frac{x(x+1)}{2}$ 中的所有**整数** $y$，都是可以取若干个不同的数使它们和为 $y$ 的。为什么？\
事实上当我们只有 $1,2,4,8,\cdots$ 可选的时候就可以根据 $y$ 的二进制表示来取到 $y$ 了，现在我们有 $1,2,3,4,5,\cdots,x$，显然也能取到。

但是上述有合法的 $y$ 的前提条件是 $y$ 是个整数，所以 $(\frac{x(x+1)}{2}-L)$ 得是一个偶数。打表可以发现 $\frac{x(x+1)}{2}$ 的奇偶性以“奇奇偶偶奇奇偶偶”为循环节循环，所以我们可以二分出最小的 $x'$ 使得 $\frac{x'(x'+1)}{2}\ge L$，再暴力向上找最小的 $x\ge x'$ 使 $\frac{x(x+1)}{2}$ 与 $L$ 奇偶性相同，根据循环节我们知道 $x-x'\le 2$。

二分上界是 $O(\sqrt{L})$，时间复杂度 $O(\log L)$。
## 代码
**Java 代码编写过程中使用了生成式 AI 作为辅助工具。**
```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        long L = scanner.nextLong();
        long l = 1,r = 2000000000;
        while(l < r){
            long mid = (l + r) / 2;
            if(prefix_sum(mid) >= L) r = mid;
			else l = mid + 1;
        }
        while(prefix_sum(l) % 2 != L % 2) l ++;
        System.out.println(l);
    }
    private static long prefix_sum(long x){
        return x * (x + 1) / 2;
    }
}
```
## C++ 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long L,l,r,mid;
inline long long preffix_sum(long long x){
	return x * (x + 1) / 2;
}
int main(){
	scanf("%lld",&L);
	l = 1,r = 2e9;
	while(l < r){
		mid = (l + r) / 2;// (l+r) 会超过 int 范围 
		if(preffix_sum(mid) >= L) r = mid;
		else l = mid + 1;
	}
	while(preffix_sum(l) % 2 != L % 2) l ++;
	printf("%d\n",l);
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：4)

### 思路分析

转化一下问题。每次弹跳的距离为 $x-i+1$，且**可正可负**。

那么也就是说关键在于判断**是否存在一种正负组合**，使得总位移为 $L$。

充能 $x$ 次时，每次**弹跳的距离**为 $x, x-1, \dots, 1$，总距离和为 $S = \frac{x(x+1)}{2}$。方向**可正可负**，因此总位移 $L$ 是 $S$ 中某些项取负后的代数和。由于符号反转等价于从 $S$ 中**减去两倍的子集和**，故 $L$ 必须满足 $S - L = 2k$（$k$ 为非负整数），即 $S - L$ 为**偶数**，也就是说 $(S-L) \mod 2 = 0$。同时，总距离 $S$ 需至少达到 $L$。因此，从小到大枚举 $x$，第一个满足 $S \geq L$ 且 $S - L$ 为偶数的 $x$ 即为最小解。

再次重新讲述一下思路。

总位移 $S = \frac{x(x+1)}{2}$，需满足 $S \ge L$ 且 $(S-L) \mod 2 = 0$。因此，从小到大枚举 $x$，检查上述条件是否满足即可。

### 代码实现

这里给出 C++ 和 Java 的代码实现。

```cpp
#include<bits/stdc++.h>
#define please return 
#define AC 0
#define str string
#define rep(i, a, b) for(long long i = a; i <= b; i++)
#define repr(i, a, b) for(long long i = b; i >= a; i--)

using namespace std;

typedef long long LL;

signed main() {
    LL L; cin >> L;
	if(L == 0) {
		cout << 0 << endl;
		return 0;
	}
	LL x = 1;
	while(true) {
		LL S = x * (x + 1) / 2;
		if(S >= L && (S - L) % 2 == 0) {
			cout << x << endl;
			return 0;
		}
		x++;
	}
	please AC; 
}
```

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		long l = sc.nextLong();
		if(l == 0) {
			System.out.println(0);
			return ;
		}
		long x = 1;
		while(true) {
			long s = x * (x + 1) / 2;
			if(s >= l && (s - l) % 2 == 0) {
				System.out.println(x);
				return ;
			}
			x++;
		}
	}
}
```

---

## 作者：封禁用户 (赞：2)

## 题解：[P12892 [蓝桥杯 2025 国 Java B] 弹跳鞋](https://www.luogu.com.cn/problem/P12892)

### 前言
这道题让我们计算小 $A$ 穿弹跳鞋最少需要多少能量才能正好跳到目标位置 $L$。

### 思路
弹跳鞋跳 $x$ 次的总距离是 $1+2+...+x=x(x+1)/2$。我们需要找到最小的 $x$，使得总距离大于等于 $L$ 且总距离与 $L$ 的差是偶数（可以反方向跳来调整）。

### 代码
```Java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long L = sc.nextLong();
        
        long x = (long) Math.ceil((Math.sqrt(8*L+1)-1)/2);
        while(true) {
            long sum = x*(x+1)/2;
            if((sum-L)%2 == 0) {
                System.out.println(x);
                return;
            }
            x++;
        }
    }
}
```

---

## 作者：_Punainen_ (赞：1)

好像遇到我，你才对 AC 向往，怎么遇到 WA，失去分数也无妨。可能是我贱吧，不会的非要做，这么水的题目非要做。

好水一题。

容易发现当充能数为 $x$ 的时候，最远可到达的距离为 $\frac{x(x+1)}{2}$，经过打表得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mknsa8eg.png)

容易发现充能数为 $x$ 时，可以到达所有 $i \equiv \frac{x(x+1)}{2} \pmod{2}$ 且 $0\leq i\leq\frac{x(x+1)}{2}$ 的距离。

因为题目让我们求最小的 $x$,所以可以得到以下方程：

$\displaystyle \frac{x(x+1)}{2} = n$

解得 $x_{1,2}=\frac{-1\pm \sqrt{1+8n}}{2}$，因为方便计算，便把 $x$ 的负数解舍去。同时因为是求合法解，所以 $x=\lceil \frac{-1 + \sqrt{1+8n}}{2} \rceil$。

因为必须要使 $n \equiv \frac{x(x+1)}{2} \pmod{2}$，所以要在输出前进行特判。

---

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n;
	cin>>n;
	int x=ceil((-1+sqrt(1+8*n))/2);
	while(((x+1)*x/2)%2!=n%2)x++;
	cout<<x;
	return 0;
}
```

---

## 作者：M1__ (赞：0)

# 题解：P12892 [蓝桥杯 2025 国 Java B] 弹跳鞋

[Link](https://www.luogu.com.cn/problem/P12892)

二分、数学。

设其充能 $x$ 次能跳的距离为 $S$。每次距离为 $x,x-1,x-2, \cdots,1$，因此其总和为 $S=\sum^{x-1}_{i=0}(x-i)=\frac{x(x-1)}{2}$。因为最后总会跳到 $L$ 的位置，所以 $L$ 必定为 $S$ 中一个或几个项的相反数的和，并且他们都必须为 $2$ 的倍数。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll l;
int main(){
    cin>>l;
    if(l==0) cout<<0;
    for(int i=1;;i++){
        if((i*(i+1))/2>=l&&((i*(i+1))/2-l)%2==0){
            cout<<i<<endl;
            return 0;
        }
    }
    return 0;
}
```


于是打了个暴力，发现只有 $60$ 分。发现此题还需要二分优化。

综上，该问题可以转化为：二分查找 $x$，答案即为第一个满足 $\frac{x(x+1)}{2} \ge L$，接着再向上寻找与 $L$ 奇偶性相同的数即可。


```cpp
// AC code.
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
int main(){
    cin>>n;
    ll l=1,r=2e9;
    while(l<r){
        ll mid=(l+r)/2;
        if((mid*(mid+1))/2>=n) r=mid;
        else l=mid+1;
    }
    while(((l*(l+1))/2)%2!=n%2) l++;
    cout<<l;
    return 0;
}
```

```java
//java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        long n=sc.nextLong(); 
        long l=1,r=2e9; 
        while(l<r){
            long mid=(l+r)/2;
            if ((mid*(mid+1))/2>=n) r=mid;
            else l=mid+1;
        }
        while (((l*(l+1))/2)%2!=n%2) l++;
        System.out.println(l);
    }
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12892)
## 思路
由于顺序对跳的结果没影响，只有方向有影响，所以可以将跳的距离视作 $1\sim n$。

可以先视为全部往前跳，距离为 $\dfrac{n(n+1)}{2}$，这样将第 $i$ 次取反距离就少了 $2i$，设取反的跳跃集合为 $T$，那么即是求最小的 $n$ 使得 $\dfrac{n(n+1)}{2}-2\sum_{i\in T} i=L$。

上式简单移项就能得出 $\dfrac{n(n+1)}{2}-L=2\sum_{i\in T} i$，发现只要左边是正偶数那么右边一定存在 $T$ 使得等式成立。那么只需要求出 $n$ 使得 $\sum_i^ni\ge L\land n\equiv L\pmod 2$ 即可。

暴力枚举 $n$ 的时间复杂度是 $O(\sqrt L)$，已经可以通过了（常数小，时间大），二分答案可以做到更优秀的 $O(\log \sqrt L)$。

## Java 代码
代码借助了 [代码转化工具](https://www.codeconvert.ai/c++-to-java-converter)。
### 暴力枚举
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long su = 1, k = 1;
        
        while (su < n || su % 2 != n % 2) {
            k++;
            su += k;
        }
        
        System.out.println(k);
        scanner.close();
    }
}
```
### 二分答案
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long ans = 0, l = 0, r = (long) (2 * Math.sqrt(n) + 1);
        long mid, k, su;

        while (l <= r) {
            mid = (l + r) / 2;
            if (n % 2 != 0) {
                k = mid * 2 - (mid % 2 == 1 ? 1 : 0) - 2 * (mid % 2 == 0 ? 1 : 0);
            } else {
                k = mid * 2 + 2 - (mid % 2 == 1 ? 1 : 0) - 2 * (mid % 2 == 0 ? 1 : 0);
            }
            su = (k + 1) * k / 2;
            if (su < n) {
                l = mid + 1;
            } else {
                r = mid - 1;
                ans = k;
            }
        }
        if (n == 1) {
            System.out.println(1);
            return;
        }
        System.out.println(ans);
    }
}
```

---


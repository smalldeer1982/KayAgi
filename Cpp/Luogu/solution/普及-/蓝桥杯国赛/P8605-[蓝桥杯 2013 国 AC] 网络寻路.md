# [蓝桥杯 2013 国 AC] 网络寻路

## 题目描述

$X$ 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。

源地址和目标地址可以相同，但中间节点必须不同。

如图 $1$ 所示的网络。

$1 \to 2 \to 3 \to 1$ 是允许的。

$1 \to 2 \to 1 \to 2$ 或者 $1 \to 2 \to 3 \to 2$ 都是非法的。

## 说明/提示

时限 1 秒，空间限制 64M。蓝桥杯 2013 年第四届国赛


------------
2024/1/28 添加一组 hack 数据

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3```

### 输出

```
6```

## 样例 #2

### 输入

```
4 4
1 2
2 3
3 1
1 4```

### 输出

```
10```

# 题解

## 作者：Ar_cher (赞：114)

## A. 题意分析

对最后一组样例数据进行分析：

先画个草图，蓝色为节点的度。

![](https://cdn.luogu.com.cn/upload/image_hosting/jneomdf1.png)

先拿节点 $1$ 节点 $2$ 举例，节点 $1$ 的度为 $3$，节点 $2$ 的度为 $2$。

节点一和二之间是联通的，那么就把这条路径固定下来。然后看这两个节点所连的其他节点有哪些，实际上只需要知道有多少个即可，很显然就是节点的度数减一个。

这里节点 $2$ 剩下的相连节点只有 $3$，而 $1$ 剩下的相连节点有 $4$ 和 $3$，写出来路径：

$4\to1\to2\to3$

$3\to1\to2\to3$

由于双向的，所以又有 $4\to1\to2\to3$ 和 $3\to1\to2\to3$

同样，节点 $2$ 和节点 $3$ 的度均为 $2$，固定 $2\to3$ 路径，只有 $1\to2\to3\to1$ 和反过来的 $1\to3\to2\to1$

同理，节点 $3$ 和节点 $1$ 有 $4$ 种转发情况。

由于节点 $4$ 的度为 $1$，它只有与节点 $1$ 联通的这一种，题目要求需要转发两次，所以 $1\to4$ 不能作为中间路径。

# B.完善程序
```cpp
#include<bits/stdc++.h>
#define MAXN 10010
#define MAXM 100010
using namespace std;
int d[MAXN],u[MAXM],v[MAXM];
int main(){
	int n,i,m;
	long long ans=0;
	cin>>n>>m;
	memset(d,0,sizeof(d));
	for(i=0;i<m;i++){
		scanf("%d%d",&u[i],&v[i]);
		d[u[i]]++;
		d[v[i]]++;
	}
	for(i=0;i<m;i++){
		if(d[u[i]]>1&&d[v[i]]>1)
		ans+=(d[u[i]]-1)*(d[v[i]]-1)*2;
	}
	cout<<ans;
	return 0;
}

```
# C.感谢
**[ice_fish01](https://www.luogu.com.cn/user/770910)**

**[wuningyu68](https://www.luogu.com.cn/user/803607)**

 **至高无上的管理员**

---

## 作者：wangxx2012 (赞：3)

## [P8605传送门](https://www.luogu.com.cn/problem/P8605)
这是一道图论题（不会的先看[这](https://oi-wiki.org/graph/)），题目告诉我们要找到一条路径，并满足以下条件：
1. 必须恰好被转发两次到达目的地，即路径长度为 4。
2. 源地址和目标地址可以相同，但中间节点必须不同。

我们首先建图，以便后面的处理。本人喜欢邻接表，当然也可以用 vector。

```cpp
void adde(int u,int v){
	edge[++k].to=v;
	edge[k].next=head[u];
	head[u]=k;
}
```
然后开始遍历，从每个点开始枚举，找到合适的路径。

```cpp
void dfs(int x,int ans,int start){//x表示来到一个节点，ans表示路径的长度，start用来储存源地址
    if(ans==4){//如果已经转发2次（路径长度为4，说明找到一条有效路径。
        cnt++;
        return;
    }
    vis[x]=true;//标记当前节点为已访问。
    for(int i=head[x];i;i=edge[i].next){//遍历当前节点的所有邻接节点。
        int v=edge[i].to;
        if(ans==3&&v==start) dfs(v,ans+1,start);// 第一种情况：已转发2次（ans=3），下一个节点必须是起始节点才有效。
        else if(!vis[v]) dfs(v,ans+1,start);//// 第二种情况：未到2次转发，且邻接节点未被访问过（保证中间节点不同）。
    }
    vis[x]=false;//回溯
}
```
最后展示完整代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,head[100010],k,cnt;
bool vis[100010];
struct node{
	int next,to;
}edge[5000010];
void adde(int u,int v){
	edge[++k].to=v;
	edge[k].next=head[u];
	head[u]=k;
}
void dfs(int x,int ans,int start){//x表示来到一个节点，ans表示路径的长度，start用来储存源地址
    if(ans==4){//如果已经转发2次（路径长度为4，说明找到一条有效路径。
        cnt++;
        return;
    }
    vis[x]=true;//标记当前节点为已访问。
    for(int i=head[x];i;i=edge[i].next){//遍历当前节点的所有邻接节点。
        int v=edge[i].to;
        if(ans==3&&v==start) dfs(v,ans+1,start);// 第一种情况：已转发2次（ans=3），下一个节点必须是起始节点才有效。
        else if(!vis[v]) dfs(v,ans+1,start);//// 第二种情况：未到2次转发，且邻接节点未被访问过（保证中间节点不同）。
    }
    vis[x]=false;//回溯
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int l,r;
		cin>>l>>r;
		adde(l,r); adde(r,l);//添加从l到r的边和从r到l的边。
	}
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));//记得清空
		dfs(i,1,i);//开始搜索
	}
	cout<<cnt;
	return 0;
}

```

---

## 作者：ZZA000HAH (赞：1)

## 网络寻路

### 题目大意

给出一张图，图中没有重边和自环，寻找由四个点组成的路径的个数，要求四个点满足**四个节点均不同**或**仅路径的起点和终点相同**。

### 题目分析

路径中必然含有三条不同的边，那我们可以转变为：确定路径中间的边，来找其余两边。

确定下来中间的边 $(u,v)$ 后，根据乘法原理，其余两条边有 $num = (ind_u-1) \times (ind_v-1)$ 种选择，其中 $ind_i$ 表示节点 $i$ 的度（这里无论入度和出度），但是路径是没有方向的，如 $1 \to 2 \to 3 \to 4$ 和 $4 \to 3 \to 2 \to 1$ 是中间边为 $(2,3)$，其余两边为 $(1,2),(3,4)$ 的两条不同的符合要求的路径，那么也就表明中间边为 $(u,v)$ 时，有 $num \times 2$ 种不同的符合要求的路径。

那是不是每个边都能作为中间边，是否会重复计数，答案是每个边都可以作为中间边，不会重复计数，因为中间边选取不同时，其余两边从中间边两个节点向外延伸，没有出现路径相同，即重复计数的可能；每条边都作为中间边，这样也不会计数遗漏。

### AC Code


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;//应为 m 的取值范围,要记录 m 条边;ind[] 的范围可以是 1e4+10
int ind[N],a[N],b[N];//a[],b[]--记录一条边的两个顶点,ind[]--记录节点的度
long long ans;//int 会爆掉
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for (int i=1; i<=m; i++)
	{
		int x,y;
		scanf("%d%d",&a[i],&b[i]);
		ind[a[i]]++,ind[b[i]]++;
	}
	for (int i=1;i<=m;i++)
		ans+=(ind[a[i]]-1)*(ind[b[i]]-1)*2;//上述计算公式
	printf("%lld",ans);
	return 0;
}
```
##### End。

---

## 作者：_OokoukioO_ (赞：0)

# 题目简述
### 题意
给定 $N$ 个点 $M$ 条边的无向图，求图中存在多少条路径满足下列要求：
- 必须恰好经过四个点。
- 经过的点不能重复，除了起点和终点外。
- 起点和终点均可以为任意一点。
### 思路
首先可以想到 dfs，但 dfs 会超时，看到有位大佬用链式前向星存图写 dfs 过了给我震惊到了，但还是讲讲优化。

首先拆解一下合法路径中的四个点，设点 $u$ 的入度为 $In_u$。

根据计数原理，在任意一条路径中，经过 $(u,v)$ 边且不重复的路径种数有 $(In_u-1) \times (In_v-1)$ 种可能，还要考虑经过 $(v,u)$ 的情况，所以答案为 $(In_u-1) \times (In_v-1) \times 2$。

我们只需用这个公式对每条边求积，然后输出总和即可。
## [AC 代码](https://www.luogu.com.cn/record/228764504)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long
#define ios ios::sync_with_stdio(false), in.tie(nullptr), out.tie(nullptr)
const int N = 100005; //N没开够，被卡了好久……
int n, m, ans, In[N], u[N], v[N];

signed main() {
	ios;
	in >> n >> m;
	for (int i = 1; i <= m; i++) {
        in >> u[i] >> v[i];
        In[u[i]]++, In[v[i]]++; //计算入度
	}
	for (int i = 1; i <= m; i++)
		ans += (In[v[i]] - 1) * (In[u[i]] - 1); //套公式
	out << ans * 2; //无向边需要乘2
	return 0;
}
```

---


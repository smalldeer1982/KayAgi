# [蓝桥杯 2014 国 C] 拼接平方数

## 题目描述

小明发现 $49$ 很有趣，首先，它是个平方数。它可以拆分为 $4$ 和 $9$，拆分出来的部分也是平方数。$169$ 也有这个性质，我们权且称它们为：拼接平方数。

$100$ 可拆分 $1,00$，这有点勉强，我们规定，$0,00,000$ 等都不算平方数。

小明想：还有哪些数字是这样的呢？

你的任务出现了：找到某个区间的所有拼接平方数。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2014 年第五届国赛

## 样例 #1

### 输入

```
169 10000```

### 输出

```
169
361
1225
1444
1681
3249
4225
4900
9025```

# 题解

## 作者：幻想繁星 (赞：18)

（upd：2023.9.9 增添常数更小的取模分割法）
## 题目大意
找出一段区间的“拼接平方数”，“拼接平方数”指一个数是平方数，而且它能拆成两部分，那两个部分也是平方数，但是不能包括 $0$。
## 思路
由于数据范围较小，可以预处理一下所有的平方数，再枚举区间内的每一个平方数的所有分割方式，判断是否能由两个平方数组成。

时间复杂度为：$O(r)$。
## 实现过程
一、判断是否为平方数，为预处理平方数及“拼接平方数”做准备。

因为平方数的平方根为整数，所以将一个平方数的平方根转化为整数并不会导致精度丢失，而非平方数的平方根转化为整数则会丢失小数部分的精度。

时间复杂度：$O(1)$。

可以写出如下代码：

```cpp
bool pfs(int x) { //判断平方数函数
	return (int)sqrt(x) == sqrt(x);
}
```

------------

二、预处理出范围内的所有平方数。

直接从 $1$ 开始 for 循环到 $r$，判断每一个数是否为平方数，如果是就将其标记下来。

时间复杂度：$O(r)$。

代码如下：

```cpp
bool f[1000005];
for (int i = 1; i <= r; i++) {//预处理1到r之间的所有平方数
	if (pfs(i))
		f[i] = 1;
}
```

------------

三、判断所有的“拼接平方数”。

从 $l$ 枚举到 $r$，判断区间内每一个数是否为“拼接平方数”，如果是将其输出。

判断方法：先判断是否为平方数，如果是枚举每一种分割方式，判断是否为两个平方数组成，如果是就是“拼接平方数”。

利用 STL 的字符串与数字转化函数或模运算和除法的性质，可以轻松完分割操作。

时间复杂度：$O(r-l)$。

代码如下：

字符串：

```cpp
	for (int i = l; i <= r; i++)//判断l到r的所有“拼接平方数”并输出
		if (f[i]) {
			s = to_string(i);
			int sl = s.size();
			for (int j = 1; j < sl; j++) {
				int x = stoi(s.substr(0, j));
				int y = stoi(s.substr(j));
				if (f[x] && f[y]) {
					printf("%d\n", i);
					break;
				}
			}
		}
```

模运算和除法（常数更小）：

```cpp
	for (int i = l; i <= r; i++)//判断l到r的所有“拼接平方数”并输出
		if (f[i]) {
			int k = 10;
			for (int j = 1; j <= 5; j++) {
				int x = i % k;
				int y = i / k;
				k *= 10;
				if (f[x] && f[y]) {
					printf("%d\n", i);
					break;
				}
			}
		}
```


至此，此题已经基本完成。将各部分代码整理一下，就可以得到完整的 AC 代码。

AC 代码如下：

字符串分割法：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[1000005];
int l, r;
string s;
bool pfs(int x) {
	return (int)sqrt(x) == sqrt(x);
}
int main() {
	cin >> l >> r;
	for (int i = 1; i <= r; i++) {
		if (pfs(i))
			f[i] = 1;
	}
	for (int i = l; i <= r; i++)
		if (f[i]) {
			s = to_string(i);
			int sl = s.size();
			for (int j = 1; j < sl; j++) {
				int x = stoi(s.substr(0, j));
				int y = stoi(s.substr(j));
				if (f[x] && f[y]) {
					printf("%d\n", i);
					break;
				}
			}
		}
	return 0;
}
```

取模分割法：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[1000005];
int l, r;
string s;
bool pfs(int x) {
	return (int)sqrt(x) == sqrt(x);
}
int main() {
	cin >> l >> r;
	for (int i = 1; i <= r; i++) {
		if (pfs(i))
			f[i] = 1;
	}
	for (int i = l; i <= r; i++)
		if (f[i]) {
			int k = 10;
			for (int j = 1; j <= 5; j++) {
				int x = i % k;
				int y = i / k;
				k *= 10;
				if (f[x] && f[y]) {
					printf("%d\n", i);
					break;
				}
			}
		}
	return 0;
}
```

如有错误，请各位多多指教。  
[另附打表代码](https://www.luogu.com.cn/paste/9revk0td)

---

## 作者：alex_liu (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8615)

## 思路

可以先预处理一个 $a[i]$ 表示 $i$ 是否为平方数，枚举区间 $[a,b]$ 的所有数，由于只能将这个数分成两部分，那么就可以枚举断点，当且仅当两端的数为平方数且整个数为平方数时，符合题意

例如：

假设现在查找到了 $169$，首先判断是否为平方数，如果是，就会进行以下步骤：

首先将 $169$ 分成 $1|69$，发现 $69$ 并不是平方数，继续枚举

然后将 $169$ 分成 $16|9$，发现 $16$ 和 $9$ 都是平方数，满足要求，退出循环

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline bool check(int m){int t=sqrt(m);if(t*t==m)return 1;return 0;}//判断是否为平方数
int a,b;
bool tf[1000005];
signed main(){
	cin>>a>>b;
	for(int i=1;i<=b;i++)tf[i]=check(i);//预处理
	for(int i=a;i<=b;i++){
		string j=to_string(i);//转为字符串方便操作
		for(int k=1;k<j.size();k++){
			string s1=j.substr(0,k),s2=j.substr(k,j.size());//截取两个子串
			int q1=stoi(s1),q2=stoi(s2);//再转回整型
			if(tf[i]&&tf[q1]&&tf[q2]){//三个数均为完全平方数，即满足要求
				cout<<i<<endl;
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：Wind_Smiled (赞：3)

## 题意
定义两平方数拼接在一起的形式为拼接平方数，求给定区间 $a,b$ 之间的拼接平方数。



------------
## 分析
对于这道题，显然的，第一反应就是写一个 `check` 函数判断是否为平方数。

这个比较好实现，枚举到一个数的平方根，每一次进行判断，若是枚举数的平方等于 `check` 中的数，就返回真值，否则返回假值。
```cpp
bool check(int x){
	for(int i=1;i<=sqrt(x);i++){
		if(i*i==x){
			return 1;
		}
	}
	return 0;
}
```

然后按题意模拟即可。

但是我们发现，我们 `check` 的过程就很费时间了，所以对于 $a<b<10^{6}$ 的数据来说一定会超时，而我又~~太懒~~太笨，写不出来用函数生成数组，存储拼接平方数，所以我们自然而然想出了一个好方法：**打表**。

所以我们枚举两个平方数再把它们拼接即可，为了能够拼接，我们可以写函数返回当前数的最高位的权值，让前面的数乘以该权值，再加上后面的数即可拼接。

然后对于数组，我们随便用一个指针往后存储即可，因为我们是拼接得来的，所以要再排一下序，不然无序的数组是没有办法查询的。

最后输出即可。

生成器如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(int x){//判断是否为平方数
	for(int i=1;i<=sqrt(x);i++){
		if(i*i==x){
			return 1;
		}
	}
	return 0;
}
int qz(int a){//返回最高位的权值
	int res=a,lena;
	while(res){
		res/=10;
		lena++;
	}
	int re=1;//lena是位数，所以返回权值就要累积乘以10，初始值一定要为 1 
	for(int i=1;i<=lena;i++){
		re*=10;
	}
	return re;
}
int n[100005],p,a[100005];
int main(){
	freopen("t1.in","r",stdin);
	freopen("t1.out","w",stdout);
	for(int i=1;i<=1000;i++){
		for(int j=1;j<=1000;j++){
			if(check(i)==1&&check(j)==1&&check(qz(j)*i+j)==1){
				p++;
				n[p]=qz(j)*i+j;
			}
		}
	}
	sort(n+1,n+p+1);
	for(int i=1;i<=p;i++){
		if(n[i]){
			printf("%d,",n[i]);
		}
	}
	return 0;
}
```
但是，运行之后可以看到，直到 $4900$ 的时候都很符合题目，不过再往后一个就直接跳到了 $16900$，然后发现 $9025$ 这样拼接成分带前导 $0$ 的平方数也算作拼接平方数。

所以要换一种方法：枚举平方数然后截取。



------------
### 实现

我们用一重循环枚举可能的数字，用 `check` 判断一下，再用一重循环枚举切开的点的位置，所以我们还要再做一个返回位数的函数。再累乘 $10$，利用语言特性，除以舍去后位，取模舍去前位，这样就可以构成一个数拆分的过程，再将拆分的两个数分别去 `check` 一下就可以输出打表程序了。

生成器：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(int x){
	for(int i=1;i<=sqrt(x);i++){
		if(i*i==x){
			return 1;
		}
	}
	return 0;
}
int len(int a){
	int res=a,lena;
	while(res){
		res/=10;
		lena++;
	}
	return lena;
}
int main(){
	freopen("t1.in","r",stdin);
	freopen("t1.out","w",stdout);
	for(int i=1;i<=1000000;i++){
		if(check(i)){
			for(int j=0;j<len(i);j++){
				int len=1;
				for(int k=1;k<=j;k++){
					len*=10;
				}
				if(check(i/len)&&check(i%len)){
					printf("%d,",i);
				}
			}
		}
	}
	return 0;
}
```

所以我们把结果放入程序的一个数组，查询即可，若查找的结果大于了右边界，结束程序，否则继续往后搜索即可。

最终代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n[100]={0,49,169,361,1225,1444,1681,3249,4225,4900,9025,15625,16900,36100,42025,49729,64009,64009,81225,93025,105625,122500,144400,168100,225625,237169,256036,324900,422500,490000,519841,576081,819025,902500,950625,970225};
int a,b;
int main(){
	scanf("%d%d",&a,&b);
	for(int i=1;i<=100;i++){
		if(n[i]>=b){
			return 0;
		}
		else if(n[i]>=a){
			printf("%d\n",n[i]);
		}
	}
	return 0;
}
```

---


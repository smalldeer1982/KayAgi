# [蓝桥杯 2016 国 C] 赢球票

## 题目描述

某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。

主持人拿出 $N$ 张卡片（上面写着 $1 \sim N$ 的数字），打乱顺序，排成一个圆圈。

你可以从任意一张卡片开始顺时针数数 $:1,2,3 \cdots $。

如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。

直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：

卡片排列是：$1,2,3$。

我们从 $1$ 号卡开始数，就把 $1$ 号卡拿走。再从 $2$ 号卡开始，但数的数字无法与卡片对上，

很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 $1$ 张球票。

还不算太坏！如果我们开始就傻傻地从 $2$ 或 $3$ 号卡片数起，那就一张卡片都拿不到了。

如果运气好，卡片排列是 $2,1,3$。

那我们可以顺利拿到所有的卡片！

本题的目标就是：已知顺时针卡片序列。

随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届国赛

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
1```

## 样例 #2

### 输入

```
3
2 1 3```

### 输出

```
6```

# 题解

## 作者：liuyi0905 (赞：33)

### 题目大意：
共有 $n$ 张卡片，若报到的数与卡片上的数相同，那么就可以拿走这张卡片，求能拿走卡片之和的最大值。

看到这道题，可以先把起点枚举一遍，再定义一个报数器，算出所有情况的最大值。

[AC记录](https://www.luogu.com.cn/record/108475367)：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a[101],maxn=0,maxi=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		maxn=max(maxn,a[i]);//先算出所有卡片的最大值
	}
	for(int i=1;i<=n;i++){
		int f[101]={0},x=1,sum=0,j=i,m=n;
		while(1){
			if(f[j]==0){
				if(x==a[j]){
					sum+=a[j];
					f[j]=1;
					x=0;
					maxi=max(maxi,sum);
					m--;
				}
				x++;
			}
			if(x>maxn||m<=0)break;
        /*如果报数器大于所有卡片的最大值或卡片数量小于等于0，就结束循环*/    
			j++;
			if(j==n+1)j=1;
		}
	}
	cout<<maxi;//输出所有起点的最大值
	return 0;
}
```
完美撒花

---

## 作者：___w (赞：9)

### [P8641 [蓝桥杯 2016 国 C] 赢球票](https://www.luogu.com.cn/problem/P8641)

#### 题意简述
给定一个排列，可以从任意一个位置开始数数，如果数的数等于这个位置上的数，就可以取走这个数，求取的数的和的最大值。

#### 题目分析
注意到 $N<100$，我们可以考虑模拟。具体地，我们可以枚举一个起点，用报数器记录报的数。如果报数器等于这个位置上的数，那么我们就标记这个数，并把它累计到答案当中去，并将报数器清零；否则，我们就将报数器累加一，位置往下移一位，要注意数列是环形的。循环的条件是如果报数器大于 $N$ 或已经取了 $N$ 个数，那么就结束循环。具体代码如下。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int n, ans, a[N], v[N];
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	for (int s = 1; s <= n; ++s) {
		int x = 1, i = s, sum = 0, cnt = 0;
		memset(v, 0, sizeof(v));//清空标记 
		while (1) {
			if (!v[i]) {//如果没被取走 
				if (x == a[i]) {//如果可以取走这个数 
					++cnt;//取走的个数 
					x = 0;//报数器 
					v[i] = 1;//已经取走了这个数 
					sum += a[i];//当前已取走的数的和 
				}
				++x;//报数器加一 
			}
			if (x > n || cnt == n) break;//如果报数器大于n或已经取走n个数 
			i = i == n ? 1 : i+1;//移到下一个位置 
		}
		ans = max(ans, sum);//统计答案 
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Lemonlwl (赞：8)

## P8641 [蓝桥杯 2016 国 C] 赢球票 题解
### 题意：
给出 $n$ 个数，按从 $1$ 到 $n$ 的顺序数，若数到的数与当前的数匹配，则拿走与当前数相同数量的球票，如果有多种情况，输出赢得球票数最多的情况。

------------

### 思路：
我们可以用模拟循环队列的方式来枚举出每一种数数的情况，并且找出最大值。

------------

附上 [AC](https://www.luogu.com.cn/record/108527465) 代码：

```cpp
#include<iostream>
#include<queue>
/*队列头文件*/
using namespace std;
queue<int> q; //n张卡片。
int n,sum,maxn,num,maxm;
//sum为每一次赢的彩票数，maxn为最大值，num为当前所数的数。
int a[1005]; //输入需要。
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		maxm=max(maxm,a[i]);
		//maxm用来判断当前数的数是否大于卡片中的最大值。
		a[n+i]=a[i];
	}
	//输入。
	for(int i=1;i<=n;i++){
		sum=0;
		num=1;
		//初始化。
		while(!q.empty()){
			q.pop();
		}
		//清空队列。
		for(int j=i;j<n+i;j++){
			q.push(a[j]);
		}
		//从第i个数开始放置。
		while(!q.empty()){
			if(num==q.front()){  //如果num等于当前卡片上的数。
				sum+=q.front(); //累加。
				num=1;   //计数器重置。
				q.pop();  //拿走卡片。
			}
			else{  //如果非当前数，继续数。
				num++;
				q.push(q.front());
				q.pop(); //模拟循环队列。
			}
			if(num>maxm){  //如果数的数比给出的最大值还大，退出。
				break;
			}
		}
		maxn=max(maxn,sum); //查询最大值。
	}
	cout<<maxn<<endl; //输出。
	return 0;
} 
```
点个赞再走呗。

---

## 作者：_7Mr (赞：5)

# 前言
本蒟蒻最近学习了一下 java，看到题解里没有人写 java，那我来发一篇。
# 题意
从 $1$ 到 $N$ 中任意选择一个数开始，从 $1$ 顺时针计数，当计数数值与卡片上的数值也就是 $1$ 到 $N$ 中的数值相等时，就拿走这个卡片，从下一张卡片重新从 $1$ 开始计数，问最大获得卡片的数值和。
# 思路
- 根据题意，我们首先想到的就是枚举所有可能的情况，求出最大值，这也正是这道题的解题思路。实际上蓝桥杯枚举的题目经常考察。明确使用枚举思路后，关键是如何进行枚举，以及枚举时候的细节。

- 我们从第 $1$ 张卡片开始进行枚举，并不断进行计数，如果计数和卡片数值相等就加上卡片的数值（也可以是累加的值），问题来了，如果满足条件拿走这张卡片，继续枚举时需要跳过这张卡片，我们如何知道这张卡片已经取走了呢？

- 我们可以使用变量进行标记，但是多个卡片，我们就需要多个变量进行标记，这个时候我们就想到了使用数组，可以重新开一个新数组专门用来标记，也可以使用记录卡片位置的数组，如果取走卡片，该位置的值就置为 $-1$，这样如果在枚举时遇到 $-1$ 就直接跳过。

- 如果使用一个数组，那么我们枚举从某一张卡片开始计数结束之后，我们继续枚举下一张卡片开始计数，这个时候如果我们肯定不能使用上一次处理后的数组，因此我们需要每次枚举一张开始的卡片就要重新使用一个临时数组，该数组等于最初输入的卡片顺序。

- 每次枚举都使用一个变量 $sum$ 记录本次获得的数值，本次枚举结束之后进行更新 $max$ 记录最大值。
# ACcode
```java
import java.util.Scanner;
class Main{
	//定义全局数组nums 和 数组长度 n 方便函数调用
	 static int[] nums;
	 static int n;
    public static void main(String[] args) {
    	Scanner sc = new Scanner(System.in);
    	 n = sc.nextInt();
    	nums = new int[n];
    	for(int i = 0;i <n;i++) {
    		nums[i] = sc.nextInt();
    	}
    	
    	System.out.println(getMax());
    	  	
    	
    }
	 static int getMax() {
		int max = 0;
		 
		for(int i = 0;i < n;i++) {
			//每次重新选择一行牌作为起始  都要重新设置临时数组
			int[] temp = new int[n];
			//初始化临时数组
			for(int k = 0;k < n;k++) {
				temp[k] = nums[k];
			}
			//计数
			int count = 1;
           //记录一次枚举获得的卡片数值和
			int sum  = 0;
           // 标记是否count大于所有剩余卡片数值，如果true即已经不能再取卡片的跳出循环进行下一 
           // 次枚举
			boolean flag = true;
            // 开始计数的卡片对应的位置下标
			int start = i;
			
			while(true) {
                 // 每次循环重置flag标识
				 flag = true;
                    //判断是否有剩余卡片的数值大于count，如果没有那么不会再取卡片直接跳出循环
				for(int k = 0;k < n; k++) {
					if(temp[k] >= count) {
						flag = false;
					      break;					
					}
				}
				//如果count大于所有数组中的数，那么不能继续数下去了
				if(flag) break;
				
				int j = start ;
				
				//如果计数count 等于 卡片的数值 temp[j]
				if(count == temp[j]) {
					
					sum += count;
					temp[j] = -1;
					count = 1;
 
				}else {
                //计数count 不等于 卡片的数值 count+1 
					count++;
				}
 
				//不管是否取走卡片都要继续进行顺时针的下一张卡片
				start = (start+1) % n;
 
				//num用来记录此时已经取走的卡片数量，防止全部取走后 一直进行while循环
				 int num = 0;
				//跳过已经取走的卡片
				while(temp[start] == -1) {
					start = (start+1) % n;
					num++;
 
					//防止死循环
					if(num > n ) break;
				}
			}
			//每次枚举一张卡片开始就更新下 max值
			max = Math.max(max, sum);
			
		}
		return max;
	}
}
```

---

## 作者：SSTF2022ywh (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8641)

## 题意

本题的目标是求出一个顺时针卡片序列中，从任意一张卡片开始顺时针数数，能够赢得的最多球票数。


## 思路

解决这个问题，可以使用模拟方法。首先遍历圆圈中的每一张牌，并从那张牌开始模拟游戏。对于每一张起始卡，都会记录收集的卡的总数，并返回最大总数。


为了模拟游戏，首先在起始牌上设置一个可变电流。然后，我们在圆圈中迭代，每次将 $x$ 递增 $1$，如果到达圆圈的末尾，则循环到圆圈的开头。如果 $x$ 等于当前卡片上的数字，我们将该数字加在总数中，然后将卡片从圆圈中移除。我们继续，直到我们不能再收集任何卡片为止。

## C++ Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n; //读入卡片数目
    int a[n];
    int maxn = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i]; //读入卡片数字
        maxn = max(maxn, a[i]); //先算出所有卡片的最大值
    }
    int maxi = 0;
    for (int i = 0; i < n; i++) {
        int f[n] = {0}; //标记卡片是否已经被收集
        int x = 1; //报数器
        int sum = 0; //已经收集的卡片数字之和
        int j = i; //当前卡片的下标
        int m = n; //剩余未收集的卡片数目
        while (true) {
            if (f[j] == 0) { //如果当前卡片未被收集
                if (x == a[j]) { //如果报数器等于当前卡片数字
                    sum += a[j]; //将当前卡片收入囊中
                    f[j] = 1; //标记当前卡片已被收集
                    x = 0; //重置报数器
                    maxi = max(maxi, sum); //更新最大收集数
                    m--; //剩余未收集的卡片数目减1
                }
                x++; //报数器加1
            }
            if (x > maxn || m <= 0) break; //如果报数器大于所有卡片的最大值或卡片数量小于等于0，就结束循环
            j++; //移动到下一个卡片
            if (j == n) j = 0; //如果已经到了最后一个卡片，就从头开始
        }
    }
    cout << maxi << endl; //输出所有起点的最大值
    return 0;
}
```


## 代码解释

这段代码使用了两个循环来模拟游戏的过程。第一个循环用来枚举起点，第二个循环用来模拟从当前起点开始的游戏过程。在第二个循环中，使用了一个数组 $f$ 来标记卡片是否已经被收集，一个变量 $x$ 来表示当前的报数器，一个变量 $sum$ 来表示已经收集的卡片数字之和，一个变量 $j$ 来表示当前卡片的下标，一个变量 $m$ 来表示剩余未收集的卡片数目。如果当前卡片未被收集，就判断报数器是否等于当前卡片数字，如果是，就将当前卡片收入囊中，并更新 $sum$ 和 $maxi$，然后重置报数器和标记当前卡片已被收集。最后，如果报数器大于所有卡片的最大值或卡片数量小于等于 $0$，就结束循环。


[已AC，请放心食用](https://www.luogu.com.cn/record/110607169)


---

## 作者：Chis725 (赞：4)

# P8641 赢球票 题解

### 题目意思：

共有 $n$ 张卡片，从其中一个数开始顺时针报数，当报到的数与卡片上相同，拿走这张卡片，求能拿走卡片之和的最大值。

### 思路：

我们将每个点为起点的情况都枚举一遍，算出能取的最大值。

代码献上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],ans=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
        int j=i,x=1,sum=0,p[101]={0};
        //j代表目前的卡片
        //x代表报的数
        //sum表示拿走的卡片之和
        //p来标记卡片是否被取走
        while(true){
            if(!p[j]){
                if(a[j]==x){
                    x=0;//重新开始报数
                    sum+=a[j];
                    p[j]=1;
                }
                x++;
            }
            j=j%n+1;//当j=n时j会变成1
            if(x>n||sum==(n+1)*n/2)break;
        }ans=max(sum,ans);
    }
    cout<<ans;
    return 0;
}
```

完结撒花！！！

---

## 作者：minVan (赞：4)

**解题思路**

本题涉及数据结构：循环队列，这里建议用 $\text{STL}$ 中的 `queue` 来模拟。

对于每个 $i$，首先是清空队列，将 $a_i$ 至 $a_{n - i + 1}$ 存入队中。

我们设一个计数器 `num`，如果 `num` 等于队首元素，则累加器 `sum` 加上队首元素，并重置 `num` 为 $1$，拿走卡片；否则计数器加 $1$，并且将队列往前进一位。如果此时 `num` 比最大值更大，这直接退出。

然后更新答案，即 `sum` 的最大值。

**AC 代码，请勿抄袭**

```cpp
#include <bits/stdc++.h>
using namespace std;
queue<int> q;
int n, sum, maxn, num, maxm;
int a[1005];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        maxm = max(maxm, a[i]);
        a[n + i] = a[i];
    }
    for (int i = 1; i <= n; i++) {
        sum = 0;
        num = 1;
        while (!q.empty()) {
            q.pop();
        }
        for (int j = i; j < n + i; j++) {
            q.push(a[j]);
        }
        while (!q.empty()) {
            if (num == q.front()) {
                sum += q.front();
                num = 1;
                q.pop();
            } else {
                num++;
                q.push(q.front());
                q.pop();
            }
            if (num > maxm) {
                break;
            }
        }
        maxn = max(maxn, sum);
    }
    cout << maxn << endl;
    return 0;
}

```

---

## 作者：StarRain3 (赞：2)

不会队列或者模拟队列同学们的福音！

#### 分析
我们枚举在不同位置下，开始数数所获得的球票数，得到最大球票数，中间进行适当的优化。

我们先将整数存入到数组 $bu$ 中，再从不同位置开始数，找到赢得球票的最大值，将数组 $bu$ 中的数备份到数组 $a$，找到未被拿走的球票位置，如果数到的数字刚好和卡片上的数字相同，该处位置 $a_k$ 赋值为 $0$，否则继续顺时针寻找，最后如果数组 $a$ 所谓卡牌原本所在位置均为 $0$，说明卡牌全被取走。

#### 代码
给出处理部分代码片段。

```
int chuli(int k) {
	int res = 0, cnt = 1;
	int a[N];
	for (int i = 0; i < n; i ++ ) {
		a[i] = bu[i];
	}
	while (true) {
		while (a[k] == 0) {
			k = (k + 1) % n;
		}
		if (a[k] == cnt) {
			res += a[k];
			a[k] = 0;
			k = (k + 1) % n;
			cnt = 1;
		} else {
			k = (k + 1) % n;
			cnt++;
		}
		if (*max_element(a, a + n) == 0) {
			return res;
		}
		if (cnt > n) {
			return res;
		}
	}
	return -1;
}
```

无涉及队列或模拟队列知识点，没有学的人也能看得懂！

---

## 作者：ZKqwq (赞：1)

圈上有 $N$ 个数，每次从任意一个位置开始计数，与当前位置上的数字相同则取出来。问最多能取出几个数。首先我们需要指定一个起始点并从这个起始点开始计数。假如我们指定的起始点是 $x$，计数次数为 $c$，从 $x$ 开始取数的情况有很多种。情况如下。

 + $x,x+2c,x+4c\cdots $ (一直走下去，就像钟摆一样)
 
 + $x,x+c,x+2c\cdots $ (初始化后，以常数级别向前推进)
 
 一般而言，只有第一种方法能够保证找到全局最优解。那么这启示我们可以暴力枚举起点，然后用第一种方法枚举计数次数，从而得到答案。注意到暴力方案会 TLE，我们考虑模拟队列。

---

## 作者：OneLeft (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8641)

[更好的观看](https://www.luogu.com.cn/blog/100years/solution-p8641)

### 题意：

给 $N$ 个顺时针排列的卡片 $A$ ，让你从任意一个卡片开始数数，如果**数到的卡片的值和数到的数相等**，就可以把它装入口袋，口袋里所有卡片的值的和就是最终的答案，要求最大的答案。

### 思路：

枚举每个开始的卡片，然后开始数数，数到的卡片的值和数到的数有两种情况：

1. 相等：将这张卡片收入囊中，然后从下一个卡片开始重新数，答案累加这张卡片的值。

2. 不相等：不变。

求出最终的答案后比较出最大的答案。

### 程序：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[105],b[105],maxn,cnt,sum,ans,da;
int biggest() //找出没有拿走的卡片的值中的最大值
{
	for(int i=100;i>=1;i--)
		if(b[i])return i;
	return 0;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i],maxn=max(maxn,a[i]);
	for(int i=1;i<=n;i++) //枚举每个开始的卡片
	{
		sum=ans=0;cnt=1;
		memset(b,0,sizeof b);
		for(int j=i;sum<n&&cnt<=maxn;j++) //枚举数到的卡片， sum<n 代表没有拿完， cnt<=maxn 代表还有可以拿的卡片
		{
			if(j==n+1)j=1;
			if(b[j]==0) //没有取
			{
				if(a[j]==cnt) //相等
					sum++,ans+=a[j],b[j]=1,cnt=0;
				cnt++;
			}
		}
		da=max(da,ans);
	}
	cout<<da;
	return 0;
}
```

---

## 作者：Sun_Email (赞：0)

这题作为一道模拟题，我们要做的就是在模拟选卡片过程循环的时候维护当前的卡片编号 $j$ 与报数编号 $k$。如果 $j=k$ 就把卡片设为已拿，把  $j$ 恢复成   $1$。具体的细节我会在代码中展示。下面废话不多说，上 AC 代码！

[AC 纪录](https://www.luogu.com.cn/record/109043973)

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[101],maxn,is_taken[101],sum=0,ans=0,cnt=0;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		maxn=max(maxn,a[i]);
	}
	for(int i=1,j,k;i<=n;++i){
		//j:报数当前号码,k:当前球票号码,sum:最多能赢几张球票,is_taken[i]:第i张卡片是否己被拿走,cnt:当前被拿走卡片张数 
		j=1;k=i;sum=0;cnt=0;
		memset(is_taken,0,sizeof(is_taken));
		while(1){
			if(cnt==n){
				//无卡片可拿——break
				break;
			}
			if(j>maxn){
				//当前报数号码已大于卡片号码就直接break(拿不走了) 
				break;
			}
			if(is_taken[k]){
				++k;
				if(k==n+1){
					k=1;
				}
				//第k张卡片已被拿走就跳过 
				continue;
			}
			if(j==a[k]){
				//符合！拿走
				sum+=a[k];is_taken[k]=1;j=0;++cnt;
				//注意这里j=0,因为后面要j++ 
			}
			//下一张！ 
			++j;++k;
			if(k==n+1){
				k=1;
			}
		}
		//打擂台求最大值
		ans=max(ans,sum);
	}
	printf("%d",ans);
	return 0;
}
```


---


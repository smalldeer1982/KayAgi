# [蓝桥杯 2019 国 C] 数正方形

## 题目描述

在一个 $N \times N$ 的点阵上，取其中 $4$ 个点恰好组成一个正方形的 $4$ 个顶点，一共有多少种不同的取法？

由于结果可能非常大，你只需要输出模 $10^9 + 7$ 的余数。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_4ab10c5eb27e3dea37d8g-09.jpg)

如上图所示的正方形都是合法的。

## 说明/提示

对于所有评测用例，$2 ≤ N ≤ 10^6$。

蓝桥杯 2019 年国赛 C 组 G 题

## 样例 #1

### 输入

```
4```

### 输出

```
20```

# 题解

## 作者：Furina_Hate_Comma (赞：25)

一道**数学**题。

我们分开处理在一个边长为 $i$ 的大正方体的情况 $(1\le i\le n)$。

只考虑目标正方形的顶点落在当前正方形的边上的情况。

挂一张丑图：

![](https://cdn.luogu.com.cn/upload/image_hosting/il810q3u.png)

这是当 $i=4$ 时的情况。

我们关注到周围剩余的三角形，不难发现，四个直角三角形的直角边之和为 $4\times i$，也就是正方形的周长。

由于四个三角形[全等](https://zhidao.baidu.com/question/689920789406073532.html)，所以每个三角形的直角边和为 $i$。

设两条直角边分别是 $a$ 与 $b$，有 $a+b=i$ 且 $0 \le a,b \le i$。

当 $a$ 或 $b$ 取 0 时，即是整个大正方形，所以 $a=0$ 与 $a=i$ 的情况相同。

所以当大正方形边长为 $i$ 时，共有 $i$ 种情况使正方形四个点落在大正方形的边上。

而边长为 $n$ 的正方形中有 $(n-i+1)^2$ 个边长为 $i$ 的正方形。

证明：

若点 $a_{x,y}$ 若为小正方形左上的顶点，那么有：

$\begin{cases} x+i\le n+1\\y+i\le n+1\end{cases}$ 

解得：

$\begin{cases} x\le n-i+1\\y\le n-i+1\end{cases}$

故有 $(n-i+1)^2$ 个边长为 $i$ 的正方形。

最后统计即可。

代码：

十年 OI 一场空，不开 long long 见祖宗！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	int n,ans=0;
	cin>>n;
	n--;//由于给的是点，使用我们要转化为段
	for(int i=1;i<=n;i++){
		ans=(ans+(n-i+1)*(n-i+1)*i)%1000000007;
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：small_john (赞：15)

## 分析

其实很简单。

我们可以把问题拆分开做。

首先，我们要明确：一个 $n\times n$ 的点阵，边长是 $n-1$，所以正方形最大只能是 $(n-1)\times(n-1)$。

接下来举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/4h761sfg.png)

可以发现最大的 $3\times3$ 的正方形中，还可以找到 $2$ 个满足四个顶点都在 $3\times3$ 正方形边上的正方形，那么统计 $3\times3$ 的正方形时，就可以吧这些一起统计了。

问题来了，如何求满足四个顶点都在 $i\times i$ 正方形边上的正方形的个数呢？

我们知道，每个满足上述条件的正方形，只需要确定一个点即可，并且这个点不能在 $i\times i$ 正方形的顶点上。所以确定的这个点有 $i-1$ 种情况，再加上 $i\times i$ 正方形本身，共 $i$ 个。

接下来就确定 $i\times i$ 正方形的个数。乘法原理可以推出，共 $(n-i)^2$ 个。

所以公式为：

$$\sum_{i=1}^{n-1} i\times(n-i)^2$$

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗
using namespace std;
const int mod = 1e9+7;
int n,ans;
signed main()
{
	cin>>n;
	for(int i = 1;i<n;i++)
		ans+=i*(n-i)*(n-i),ans%=mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：wuhan1234 (赞：5)

## 1. 编程思路。

由题目描述可知，取 $4$ 个点构成的正方形有正放和斜放两种情况。

先考虑正放的正方形。

取 $(x,y)$、$(x,y+1)$、$(x+1,y)$ 和 $(x+1,y+1)$ 这 $4$ 个点，可以构成一个边长为 $1$ 的正放的正方形。其中，$x$ 的取值范围为 $1\sim N-1$，$y$ 的取值范围也为 $1\sim N-1$。因此，边长为 $1$ 的正放的正方形有 $(N-1)\times (N - 1)$ 个。

一般地，取 $(x,y)$、$(x,y+i)$、$(x+i,y)$ 和 $(x+i,y+i)$ 这 $4$ 个点，可以构成一个边长为 $i$ 的正放的正方形。其中，$x$ 的取值范围为 $1\sim N-i$，$y$ 的取值范围也为 $1\sim N-i$。因此，边长为 $i$ 的正放的正方形有 $(N-i)\times (N - i)$ 个。

边长为 $N-1$ 的正放的正方形只有 $1$ 个，所取的 $4$ 个点为 $(1,1)$、$(1,N)$、$(N,1)$ 和 $(N,N)$。

因此，正放的正方形的总数为 $\sum_{i=1}^{N-1}(N-i)\times (N-i)$。

再考虑斜放的正方形。
对于斜放的正方形，它一定是某个正放的正方形的最大内接斜正方形。例如，题目描述中给出的第 $1$ 个图，就是一个边长为 $3$ 的正放正方形的最大内接斜正方形。
边长为 $1$ 的一个正放正方形中没有最大的内接斜正方形。

边长为 $2$ 的一个正放正方形中只有一个最大的内接斜正方形，其边长为 $\sqrt{2}$，如题目描述中的第 $2$ 个图。由于边长为 $2$ 的正放正方形有 $(N-2)\times (N-2)$ 个，因此边长为 $\sqrt{2}$ 的斜正方形有 $(N-2)\times (N-2)$ 个。

边长为 $3$ 的一个正放正方形中有 $2$ 个最大的内接斜正方形，其边长为 $\sqrt{5}$。题目描述中的第 $1$ 个图给出了 $1$ 种接法，将这个图水平翻转一下，就是其第 $2$ 种接法。由于边长为 $3$ 的正放正方形有 $(N-3)\times  (N-3)$ 个，因此边长为 $\sqrt{5}$ 的斜正方形有 $2\times (N-2)\times (N-2)$ 个。

一般地，边长为 $i$ 的正放正方形中有 $i-1$ 个最大的内接斜正方形。$4$ 个点的坐标可以取为 $(1,a)$、$(a,i+1)$、$(i+1,i+2-a)$ 和 $(i+2-a,1)$。$a$ 的取值范围为 $2\sim i$。由于边长为 $i$ 的正放正方形有 $(N-i)\times (N-i)$ 个，因此边长为 $i$ 的正放正方形中最大内接斜正方形有 $(i-1)\times (N-i)\times (N-i)$ 个。

因此，斜放的正方形的总数为 $\sum_{i=1}^{N-1}(i-1)\times (N-i)\times (N-i)$。

总的正方形个数为 $\sum_{i=1}^{N-1}i\times (N-i)\times (N-i)$。 

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
#define mod 1000000007
int main()
{
    long long n,i;
	scanf("%lld",&n);
	long long ans=0;
	for (i=1;i<n;i++)
	{
		ans=(ans+(n-i)%mod*i%mod*i)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}

```



---


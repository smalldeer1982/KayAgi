# [蓝桥杯 2020 国 C] 天干地支

## 题目描述

古代中国使用天干地支来记录当前的年份。

天干一共有十个，分别为：甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊
（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）。

地支一共有十二个，分别为：子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）。

将天干和地支连起来，就组成了一个天干地支的年份，例如：甲子。2020 年是庚子年。

每过一年，天干和地支都会移动到下一个。例如 2021 年是辛丑年。

每过 60 年，天干会循环 6 轮，地支会循环 5 轮，所以天干地支纪年每 60年轮回一次。例如 1900 年，1960 年，2020 年都是庚子年。

给定一个公元纪年的年份，请输出这一年的天干地支年份。

## 说明/提示

对于所有评测用例，输入的公元年份为不超过 $9999$ 的正整数。

蓝桥杯 2020 年国赛 C 组 F 题。

## 样例 #1

### 输入

```
2020```

### 输出

```
gengzi```

# 题解

## 作者：andyli (赞：11)

2044 年为一个轮回的起点即甲子年，60年一轮回，而 $2044 \bmod 60 = 4$，故易知公元 $n$ 年在一个轮回中的位置为 $p = (n + 56) \bmod 60$，则天干编号为 $p \bmod 10$，地支编号为 $p \bmod 12$。

```cpp
int main() {
    dR(int, n);
    n = (n + 56) % 60;
    const char *heaven[]{"jia", "yi", "bing", "ding", "wu", "ji", "geng", "xin", "ren", "gui"},
               *earth[]{"zi", "chou", "yin", "mao", "chen", "si", "wu", "wei", "shen", "you", "xu", "hai"};
    writeln(heaven[n % 10], earth[n % 12]);
    return 0;
}
```

---

## 作者：jiangysh (赞：10)

### 题目描述
送你一个数，求它的天干地支。（提示： `2020` 年是庚子年）
### 思路
因为题目告诉你了`2020`是庚子年。我们就以`2020`为基准。又因为题目告诉你了每加减`60`年天干地支不变，所以我们可以将年份超过的减`60`年，少了加`60`年，将范围控制在`2020`年到`2080`年之间。

然后根据`2020`年是庚子年加加减减就能知道天干地支了。

时间复杂度为 $O(n)$

### c++代码

```cpp
#include<bits/stdc++.h>
//#include<iostream>不习惯用万能头的用这个。
using namespace std;
int y, x, n;
string a[10] = { "jia","yi","bing","ding","wu","ji","geng","xin","ren","gui" };//天干
string b[12] = { "zi","chou","yin","mao","chen","si","wu","wei","shen","you","xu","hai" };//地支
int main() {
    cin >> n;
    while (n > 2020) n -= 60;
    while (n < 2020) n += 60;//控制范围
    x = 6; y = 0;//因为2020年是庚子年，对应的是a[6],b[0]
    for (int i = 2021; i <= n; i++) {
        x++;
        if (x == 10) x = 0;//当天干为10时，自动返回0
        y = (y + 1) % 12;//简化版，意义同上
    }
    cout << a[x] << b[y];
    return 0;
}
```
-----
于2024年1月26日修改，感谢 @[sxyyy](https://www.luogu.com.cn/user/928798) 提供的修改意见。

---

## 作者：fengziyi (赞：7)

### 题意
计算公元年份的天干地支年份。 

### 思路

因为天干 $10$ 年一轮回，地支 $12$ 年一轮回，所以我们做好对照表即可。  
通过取模的方法获得当前年份的天干地支。  
观察样例发现 $2020$ 年为庚子年。
推定各年取模后的干支。  
```cpp
string t[10] = {"geng", "xin", "ren", "gui", "jia", "yi", "bing", "ding", "wu", "ji"};
string d[12] = {"shen", "you", "xu", "hai", "zi", "chou", "yin", "mao", "chen", "si", "wu", "wei"};
```
这题建议降为红题。

### 贴个代码  
```cpp
#include <iostream>

#define longint long long
#define reg register
#define qwq puts("fzy qwq ~");

using namespace std;

int n;
string t[10] = {"geng", "xin", "ren", "gui", "jia", "yi", "bing", "ding", "wu", "ji"};
string d[12] = {"shen", "you", "xu", "hai", "zi", "chou", "yin", "mao", "chen", "si", "wu", "wei"};

int main()
{
    cin >> n;
    cout << t[n % 10] << d[n % 12] << endl;
    return 0;
}
```

---

## 作者：lichenzhen (赞：5)

## 题目大意
给出一个年份，要求你计算一下这个年份用天干地支纪年法的表示。

## 题目解法
一道比较简单的题目，我做这道题用到了一个计算天干地支的公式（将年份定义为 $n$）。
- 天干算法：用 $(n-3) \bmod 10$，是天干所对应的位数。
- 地支算法：用 $(n-3) \bmod 12$，是地支所对应的位数。

然后我们打两个表，分别放着每个天干地支的拼音。输出的时候就方便了。

但是要注意一些小细节：
- 若 $n<2$ 此时我们会减到一个负数，无法进行计算，所以我们根据公元 $3$ 年来推算出 $n=0$ 和 $n=1$ 和 $n=2$ 的情况，然后特判输出就可以了。
- 如果 $(n-3) \bmod 10$ 或者 $(n-3) \bmod 12$ 的结果是 $0$，那么此时顺序是应该是天干或者是地支的最后一个，我们把两个表的第一个存放天干地支最后一个字对应的拼音。

### 参考代码
```cpp
#include<iostream>
using namespace std;
string tg[20]={"gui","jia","yi","bing","ding","wu","ji","geng","xin","ren"};
string dz[20]={"hai","zi","chou","yin","mao","chen","si","wu","wei","shen","you","xu"};
int main()
{
	int n,a,b;
	cin>>n;
	if(n==0) cout<<"guihai";
	if(n==1) cout<<"xinyou";
	if(n==2) cout<<"renxu";
	cout<<tg[(n-3)%10]<<dz[(n-3)%12];
} 
```



---

## 作者：rainygame (赞：2)

开放题解通道惹，马上过来水题解！

这道题有两种做法，一种是暴力做法，一种是数学做法：

1. 暴力做法

我们发现，输入的年份很小，最多只有 $9999$，所以我们可以采取暴力。

既然已经给出了 $2020$ 年的天干地支，那么我们可以从 $2020$ 开始推，如果这个年份比 $2020$ 大，就往后推，否则往前推。

当然，要注意溢出的问题，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

// 储存的数组，有一个 "" 是用于占位的，因为数组下标从 0 开始
const string tg[] = {"", "jia", "yi", "bing", "ding", "wu", "ji", "geng", "xin", "ren", "gui"};
const string dz[] = {"", "zi", "chou", "yin", "mao", "chen", "si", "wu", "wei", "shen", "you", "xu", "hai"};

int y, t = 7, d = 1;  // 庚子年

int main(){
	ios::sync_with_stdio(false);  // 优化三人组
	cin.tie(0);
	cout.tie(0);
	
	cin >> y;
	
	if (y >= 2020){
		for (int i=1; i<=y-2020; i++){
			if (t == 10) t = 1;  // 如果到了最后一个，就回到第一个
			else t++;
			if (d == 12) d = 1;
			else d++; 
		}
	}else{
		for (int i=1; i<=2020-y; i++){
			if (t == 1) t = 10;  // 如果到了第一个，就回到最后一个
			else t--;
			if (d == 1) d = 12;
			else d--;
		}
	}
	
	cout << tg[t] << dz[d];  // 输出
	
	return 0;
}

```

2. 数学做法（推荐）

我们可以通过算出距离 $2020$ 年过了几年，然后再通过取模算出天干地支，当然，因为比 $2020$ 小的是从后往前推的，所以要用 $10$ 和 $12$ 来减。

**注意：因为是从 $2020$ 开始计算，所以字符串数组要以 `geng` 和 `zi` 开头。**

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const string tg[] = {"geng", "xin", "ren", "gui", "jia", "yi", "bing", "ding", "wu", "ji"};  // 注意顺序
const string dz[] = {"zi", "chou", "yin", "mao", "chen", "si", "wu", "wei", "shen", "you", "xu", "hai"};
					
int y;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> y;
	y = y-2020;  // 计算距离2020年的年份
	
	if (y >= 0) cout << tg[y%10] << dz[y%12];  // 大于等于2020
	else{
		y = -y;  // 是负数，转成正数
		cout << tg[10-y%10] << dz[12-y%12];  // 从后往前推的，要用 10 和 12 来减
	}
	
	return 0;
}

```


---


# [蓝桥杯 2024 省 A] 训练士兵

## 题目描述

在蓝桥王国中，有 $n$ 名士兵，这些士兵需要接受一系列特殊的训练，以提升他们的战斗技能。对于第 $i$ 名士兵来说，进行一次训练所需的成本为 $p_i$ 枚金币，而要想成为顶尖战士，他至少需要进行 $c_i$ 次训练。  
为了确保训练的高效性，王国推出了一种组团训练的方案。该方案包含每位士兵所需的一次训练，且总共只需支付 $S$ 枚金币（组团训练方案可以多次购买，即士兵可以进行多次组团训练）。  
作为训练指挥官，请你计算出最少需要花费多少金币，才能使得所有的士兵都成为顶尖战士？

## 说明/提示

花费金币最少的训练方式为：进行 $2$ 次组团训练，花费 $2 × 6 = 12$ 枚金币，此时士兵 $1, 3$ 已成为顶尖战士；再花费 $4$ 枚金币，让士兵 $2$ 进行两次训练，成为顶尖战士。总花费为 $12 + 4 = 16$。

对于 $40\%$ 的评测用例，$1 ≤ n ≤ 10^3，1 ≤ p_i
, c_i ≤ 10^5，1 ≤ S ≤ 10^7$。

对于所有评测用例，$1 ≤ n ≤ 10^5，1 ≤ p_i
, c_i ≤ 10^6，1 ≤ S ≤ 10^{10}$。

## 样例 #1

### 输入

```
3 6
5 2
2 4
3 2```

### 输出

```
16```

# 题解

## 作者：PineappleSummer (赞：80)

[P10387 [蓝桥杯 2024 省 A] 训练士兵](https://www.luogu.com.cn/problem/P10387)

建议标签：贪心。

有一个显然的贪心思路：如果当前所有仍需要继续训练的士兵一次训练所需的金币总和小于 $S$，就使用组团训练；否则剩下的士兵全部单独训练。

输入时记 $cnt_i$ 为需要训练 $i$ 次的士兵一次训练所需的金币之和，$now$ 为所有士兵一次训练所需的金币之和，$Sum$ 为**所有士兵单独训练**所需的金币之和。

枚举组合训练的次数，记 $ans$ 为组合训练所需的金币之和。

对于第 $i$ 次组合训练：
- 如果 $now \ge S$，则说明还需要组合训练，$ans$ 加上 $S$，$Sum$ 减去 $now$，$now$ 减去 $cnt_i$。
- 如果 $now < S$，跳出循环，答案即为 $ans+Sum$。

**记得开 long long。**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e6 + 10;
LL n, s, p[N], c[N], cnt[N], Sum, now, ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	
	cin >> n >> s;
	for (int i = 1; i <= n; i++)
		cin >> p[i] >> c[i], cnt[c[i]] += p[i], now += p[i], Sum += p[i] * c[i];
	for (int i = 1; i <= 1e6; i++) {
		if (now < s)  break;
		ans += s;
		Sum -= now;
		now -= cnt[i];
	}
	cout << ans + Sum;
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：23)

很显然，一次将所有士兵训练的价值为 $\min(S,\sum\limits_{i=1}^n p_i[i号士兵不是顶尖战士])$，但是，如果我们模拟这一操作的话，很明显不行。

很明显，我们可以预处理出当训练了 $k$ 次后 $\sum\limits_{i=1}^n p_i[i号士兵不是顶尖战士]$，用后缀和可以解决。

那么现在就可以 $O(1)$ 解决上述式子了。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5,rN=1e6;
int n,s;
int p,c,ans;
map<int,int> mp;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>p>>c;
		mp[c]+=p;
	}
	for(int i=rN;i>=1;i--) mp[i]+=mp[i+1];
	for(int i=1;i<=rN;i++) ans+=min(mp[i],s);
	cout<<ans;
	return 0;
}
```

---

## 作者：mywwzh (赞：10)

蓝桥杯省赛 A 组的编程第一题。

很明显的一个贪心，考虑贪心策略：

我们先把士兵按训练的次数排序，让士兵单独训练一次。如果成本高于报团训练的成本 $S$，我们就让剩下的士兵报团训练，否则就让士兵单独训练。

数据范围有 $10^{10}$，记得开 `long long`。

```
#include <bits/stdc++.h>
using namespace std;

#define all(a) a.begin(), a.end()
#define debug(a) cout << a << "\n";
#define pb push_back
#define mp make_pair
#define mem(a, b) memset(a, b, sizeof(a))
#define endl "\n"
typedef long long ll;
constexpr int MAXN = 1e5 + 10;

struct Node
{
    ll cost; // 单词训练的花费
    ll sum; // 训练次数
};

bool cmp(const Node &a, const Node &b)
{
    return a.sum < b.sum; // 按训练次数排序
}

int main()
{
    int n;
    ll S, tot = 0, used = 0, cnt = 0; // tot: 总花费, cnt: 最小花费
    cin >> n >> S;

    vector<Node> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i].cost >> a[i].sum;
        tot += a[i].cost;
    }

    sort(a.begin(), a.end(), cmp);

    for (int i = 0; i < n; i++)
    {
        if (tot >= S) // 花费比组团的大，报团
        {
            cnt += (a[i].sum - used) * S; 
            tot -= a[i].cost;
            used += a[i].sum - used;
        }
        else // 否则就单独训练
        {
            cnt += (a[i].sum - used) * a[i].cost;
            tot -= a[i].cost;
        }
    }

    cout << cnt << endl;
    return 0;
}
```

---

## 作者：_Warfarin_ (赞：7)

### 思路分析
~~一眼顶针得出为贪心~~，那我们便不难想到以下贪心。   
将士兵按照训练次数排序后，遍历所有士兵，选择士兵训练花费较少的那一种，即对于每位士兵，我们考虑是他自己训练花费少还是组团花费少。

### 证明
正确性是显然的。   
关于排序，如果不进行排序可能会出现团购次数过多反而不如单独购买合理。
考虑以下样例

```
3 3
1 10
2 1
3 1
```

如果不排序，那我们就会发现团购明显最优。团购三次花费为 `30` ，而排序后只需要团购一次加单独训练 `9` 次即可，此时花费为 `12` 。

### 细节处理
- 十年 `OI` 一场空，不开 `long long` 见祖宗。
### AC代码
``` 
#include <bits/stdc++.h>

#define io cin.tie(0),cout.tie(0),ios::sync_with_stdio(false)
#define ri register int
#define ll long long

using namespace std;
const int N = 114514;
typedef pair<int, int> qwq;
qwq a[N];
bool cmp(qwq aa, qwq bb)
{
	return aa.second < bb.second;
}
ll n, s;
ll tot = 0;
ll ans = 0;
int main()
{
	io;
	cin >> n >> s;
	for (ri i = 1; i <= n; i++)
	{
		cin >> a[i].first >> a[i].second;
		tot += a[i].first;
	}
	sort(a + 1, a + 1 + n, cmp);
	ll t = 0;
	for (ri i = 1; i <= n; i++)
	{
		if (a[i].second <= t)
		{
			tot -= a[i].first;
			continue;
		}
		if (tot >= s)
		{
			ans += (a[i].second - t) * s;
			t += a[i].second - t;
		}
		else
		{
			ans += (a[i].second - t) * a[i].first;
		}
		tot -= a[i].first;
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：__qkj__ (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P10387)
## 解题思路
我们可以把成为顶尖战士所需的训练次数相同的给看做一个人，把他的金币成本加起来，存入数组里，方便之后操作。

再从训练次数从高到低遍历数组，一边求后缀和（后面的人训练好了又可以并成一个人），一边求出当前这个人的金币成本和组队训练金币成本的最小值，并加入计数器里。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m,maxn=0,s=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		cin>>x>>y;
		a[y]+=x;
		maxn=max(maxn,y);
	}
	for(int i=maxn;i>=1;i--)
		s+=min(m,a[i]+=a[i+1]);
	cout<<s;
	return 0;
}

```

---

## 作者：GXZJQ (赞：5)

# P10387 [蓝桥杯 2024 省 A] 训练士兵 题解

[题目链接](https://www.luogu.com.cn/problem/P10387)

## 题目大意

你是一位训练指挥官，要求计算出最少需要花费多少金币，才能使得所有的士兵都成为顶尖战士？

## 题目分析
考虑贪心思想。

按照训练次数从小到大排序，从训练次数少的开始枚举，贪心找单独训练还是组团训练即可。

## 参考代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
struct A {
    int val, cnt;
}f[100010];
// res 表示总消耗金币数量
int n, m, res;
// 按照次数从小到大排序
bool is(A a, A b) {
    return a.cnt < b.cnt;
}
signed main() {
    cin >> n >> m;
    // a 表示从第 i 个士兵到第 n 个士兵每个训练一次的总和
    int a = 0;
    for(int i = 1; i <= n; i++) {
        cin >> f[i].val >> f[i].cnt;
        a += f[i].val;
    }
    sort(f + 1, f + n + 1, is);
    // tk 表示组团训练的次数
    int tk = 0;
    for(int i = 1; i <= n; i++) {
        /*
            如果组团总次数大于等于这个士兵需要训练的次数
            说明这个士兵不用训练了，更新 a 的值
        */
        if(f[i].cnt <= tk) {
            a -= f[i].val;
            continue;
        } 
        /*
            如果组团训练比较划算，比从现在开始到第 n 个士兵单独训练一次划算
            就组团训练 f[i][1] - tk表示这个士兵还需要训练几次    
        */
        if(a >= m) {        
            // 总额加上这个士兵需要组团训练的次数
            res += (f[i].cnt - tk) * m;
            // 更新组团训练次数
            tk += f[i].cnt - tk;
        } else {
            res += (f[i].cnt - tk) * f[i].val;
        }
        a -= f[i].val;
    }
    cout << res << endl;
    return 0;
}
```

---

## 作者：jsisonx (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P10387)
# 题目分析
一道贪心题。如果每次训练都按最优方案进行，那么最终答案一定最优。设团队训练为方案一，每个士兵单独训练为方案二。对于每次训练，大体有两种思路：

1. 每次锁定一个士兵，对该士兵的训练进行规划
2. 每次将目前还需训练的士兵按最优方案训练一次

显然，由于训练过程是方案一、二穿插着进行，所以方案二更简单。

具体步骤：

0. 设答案为 ```ans```
1. 对所有士兵按训练次数排序
2. 设目前还需训练的士兵按方案二训练一次所需金币为 $c$，设目前还需训练的士兵训练次数最小为 $f$。如果这一轮训练没有士兵减少，那么这一轮对下一轮决策没有影响，所以可以每一轮训练 $f$ 次，保证这一轮结束后士兵人数发生变化。具体地，如果 $c>=S$，说明这一轮训练方案一更优。则 ```ans+=f*s```。如果 $c<S$，说明这一轮训练方案二更优，则 ```ans+=f*c```。每个士兵在这一轮中训练了 $f$ 次，此时所有剩余训练次数为 $f$ 的士兵都已训练完成。
3. 对于 $c$，可以使用前缀和，对于士兵已经训练的次数用 $t$ 表示，则 每一轮```t+=f```，每一轮训练结束后士兵的剩余训练次数减 $t$。

##### 注意不开 long long 见祖宗！

# 代码

```
#include<bits/stdc++.h>
using namespace std;
struct so{
	int x,ti;
}soo[100001];
int cmp(so a,so b){
	if(a.ti!=b.ti){
		return a.ti<b.ti;
	}
	return a.x<b.x;
}
int main(){
	int n;
	long long s,sum2=0,ans=0;
	cin>>n>>s;
	for(int i=0;i<n;i++){
		cin>>soo[i].x>>soo[i].ti;
		sum2+=soo[i].x;
	}
	sort(soo,soo+n,cmp);
	long long t=0,times=0;
	while(t<n){
    	long long o=min(sum2,s);
		int f=soo[t].ti-times;
		ans+=f*o;
		times+=f;
		while(soo[t].ti-times==f){
			sum2-=soo[t].x;
			t++;
		}
	}
	cout<<ans;
	return 0;
}
```

---


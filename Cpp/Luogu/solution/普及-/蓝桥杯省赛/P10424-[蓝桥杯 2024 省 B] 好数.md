# [蓝桥杯 2024 省 B] 好数

## 题目描述

一个整数如果按从低位到高位的顺序，奇数位（个位、百位、万位……）上的数字是奇数，偶数位（十位、千位、十万位……）上的数字是偶数，我们就称之为“好数”。

给定一个正整数 $N$，请计算从 $1$ 到 $N$ 一共有多少个好数。

## 说明/提示

### 样例 1 解释

$24$ 以内的好数有 $1,3,5,7,9,21,23$，一共 $7$ 个。

### 数据规模与约定

- 对于 $10\%$ 的测试数据，$1 \leq N \le 100$。
- 对于全部的测试数据，$1 \le N \leq 10^7$。

## 样例 #1

### 输入

```
24
```

### 输出

```
7```

## 样例 #2

### 输入

```
2024
```

### 输出

```
150```

# 题解

## 作者：_xdd_ (赞：32)

很简单的一道题，考验循环结构，先遍历 $1$ 到 $N$ 之间的数，然后依次把数位分离，判断奇偶性即可。

```cpp
#include<iostream>
using namespace std;
int main(){
    int t,cnt=0;
    cin >> t;
    for(int i=1;i<=t;i++){
        int num=i;
        for(int j=1;num;j++){
            if(j%2 != (num%10)%2){break;}
            num/=10;
        }
        if(num==0){cnt++;}
    }
    cout << cnt;
    return 0;
}
```

---

## 作者：ggylz49 (赞：13)

## 程序解析
可先单列一个函数判断一个数是否是“好数”。

定义一个计数器 $i$，看一看枚举到了哪一位。每次对 $x$ 的末位进行判定，若 $i\bmod 2=1$（奇数位）且这一位上的数是偶数，那么返回 $0$；反之，$i\bmod 2=0$（偶数位）且这一位上的数是奇数，那么也返回 $0$。接着，$x$ 除以 $10$ 并向下取整，末位就变成下一位的数字，$i$ 增加 $1$，继续对下一位进行判定。直到 $x=0$ 时停止。若这时函数还没有返回 $0$，那么这一定是一个“好数”，返回 $1$。

函数代码：
```cpp
bool good(int x)
{
    int i=1;
    while(x>0)
    {
        if (i%2==1)//奇数位
        {
            if ((x%10)%2==0)return 0;//末位是偶数return 0
        }
        else //偶数位
        {
            if ((x%10)%2==1)return 0;//末位是奇数return 0
        }
        x/=10,i++;//这一位满足条件了，循环继续
    }
    return 1;//是“好数”，return 1
}
```
主函数就很简单，输入 $N$，从 $1$ 至 $N$ 循环调用函数枚举即可。
## Code
```cpp
#include <iostream>
using namespace std;
bool good(int x)
{
    int i=1;
    while(x>0)
    {
        if (i%2==1)
        {
            if ((x%10)%2==0)return 0;
        }
        else 
        {
            if ((x%10)%2==1)return 0;
        }
        x/=10,i++;
    }
    return 1;
}
int main()
{
    int N,ans=0;//ans存储答案（“好数”个数）
    cin>>N;
    for (int i=1;i<=N;i++)
    {
        if (good(i)==1)ans++;//满足“好数”，答案加1
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：_Jocularly_ (赞：6)

我们枚举每一个数字，用一个函数来判断是否是好数。用循环进行拆位，利用拆位依次从低位到高位的性质，我们根据题意，个位需要的数字为奇数，即取模二得一，我们保存应该得到的余数为一个变量，初始值为一。如果不相等直接返回，否则下一位应该是偶数了，将变量变为零，代表着这一位数取模二应该得到零。按照以上步骤进行即可，到最后能够满足所有情况的数字应该返回一，代表这个数为好数。以上代码有 $O(n \log n)$ 的时间复杂度，足够通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans; 
int check(int n){
	int t = n;
	int mod = 1;
	while(t != 0){
		int now = t % 10;
		if(now % 2 != mod) return 0;
		mod = !mod;
		t /= 10; 
	}
	return 1;
}
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		if(check(i)) ans ++;
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Breath_of_the_Wild (赞：2)

题目很好理解，按照题意模拟即可。

对于每一个 $[1,n]$ 中的 $i$，循环把 $i$ 一位一位拆开，如果当前 $i$ 的数位与循环次数关于模 $2$ 同余，就说明当前这一位是符合条件的。

注意，并不是一位符合条件，这个数就是“好数”了。你需要最开始默认 $i$ 这个数是“好数”，如果有不符合条件的数，就标记为不是“好数”。

然后，再看标记的是满足还是不满足来决定是否让答案加 $1$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int t=i;
		bool f=1;
		for(int j=1;j<=10;j++){
			if(t==0) break;
			int nw=t%10;//拆位
			t/=10;//拆位
			if((j&1)&&(nw&1)||!(j&1)&&!(nw&1));// i 的当前位置满足条件
			else f=0;// 标记为不满足条件
		}
		if(f) ans++;
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

这是一道简单题，考验循环结构的熟练运用。

我们依次遍历 $1$ 到 $N$ 之间的数，对于每个数都将数位分离判断即可，时间复杂度 $O(N \log N)$。

代码如下：
```cpp
int main() {
	int n;
	read(n);
	int res = 0;
	rep(i, 1, n, 1) {
		int fl = 1, g = 1;
		int t = i;
		while (t) {
			if ((t % 10) % 2 != fl) {
				g = 0;
				break;
			}
			fl ^= 1, t /= 10;
		}
		if (g) res++;
	}
	write(res);
}
```

---


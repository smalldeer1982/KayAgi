# [蓝桥杯 2024 省 C] 劲舞团

## 题目描述

小蓝最近迷上了一款名为“劲舞团”的游戏，具体来说，只要按照游戏中给出的键位提示依次按出对应的键位，游戏人物便可以跟随节奏跳舞。对于连续的 $K$ 次正确敲击，如果任意连续的两次敲击间间隔时间都小于等于 $1\texttt s$，那么
我们称这是一次 $K$ 连击。现在给出一局小蓝的游戏记录文件，log.txt 中记录了 $N$ 条记录，每条记录有三个字段，依次为正确的敲击字符、小蓝打出的字符、打出字符的时间对应的毫秒时间戳。现在请你计算下最长的 $K$ 连击是多少，你
只需要输出 $K$ 的值。

# 题解

## 作者：Zskioaert1106 (赞：15)

第一遍 WA 了，然后发现一个小坑（但不多）。

题目传送门：[P10899 [蓝桥杯 2024 省 C] 劲舞团](https://www.luogu.com.cn/problem/P10899)

### 题目分析

一眼简单的模拟，重复读入两个字符判断是否相等即可。同时记录上次时间，与本次比较。如果不满足连击的条件就把 $K$ 清零。（由于时间戳是毫秒）所以如果两者相差不超过 $1000$ 且敲击与给出的键位相等，连击的 $K$ 就加 $1$。最终选择最大的 $K$。

**坑点**：如果你不将 $K$ 每次重置为 $1$，那你在比较 $K$ 的时候需要将结果 $+1$，因为 $K$ 连击的第一次由于时间戳的关系不会被记录。

每次判断完要把“上次时间”更新为本次时间。

### 代码编写

此处不应使用 int，因为从下发文件可以看出，最早 $1709446139591$ 也远远大于 $2^{31}$。可以用 long long，由于读入的都是正数，所以推荐使用无符号版的 unsigned long long。

```cpp
#include<iostream>
using namespace std;
unsigned long long ntime,ftime,ansK,sumK;
int main(){
	char n,m;
	while(cin>>n>>m>>ntime){
		if(n==m&&ntime-ftime<=1000)sumK++;
		else{
			if(sumK+1>ansK)ansK=sumK+1;
			sumK=0;
		}
		ftime=ntime;
	}
	cout<<ansK;
	return 0;
}
```

可以 [AC](https://www.luogu.com.cn/record/174485212)。

### 彩蛋

根据时间戳的转换可以得出，小蓝是在 2024 年 3 月 3 日 14:08 左右开始的游戏，结束于 14:33。~~二十五分钟最大连击 $9$ 次，这游戏真难啊~~

---

## 作者：coderJerry (赞：4)

先讲讲时间戳：时间戳是指从北京时间 1970 年 1 月 1 日早上 8 时整到现在所经过的秒数。

记住！无论你多自信，遇到这种题一定先把 log.txt 打开！

它有两个有用信息：

- 共有 $2000$ 行输入。
- 它的时间戳不同于普通时间戳，它的以**毫秒**为单位！

这样的话，枚举这 $2000$ 次输入，用数组记录每一次的时间戳。如果当前输入的两个字符相等，并且当前时间戳减去上一次的时间戳小于 $1000$ 毫秒的话，当前连击次数就要加一，并更新最大连击次数。一旦不满足条件，重置当前连击次数为 $1$（单次满足条件算作“ $1$ 连击”）。容易写出代码：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int ans=-1,now=1,tim[2001];//ans 表示最大连击次数，now 表示当前练级次数
    char t,s;//t 表示正确字符，s 表示小蓝输入的字符
    for(int i=1;i<=2000;i++){
        cin>>s>>t>>tim[i];
        if(t==s&&tim[i]-tim[i-1]<=1000){//符合条件
            now++;//当前练级次数 +1
            ans=max(ans,now);//更新最大连击次数
        }
        else now=1;//重置当前连击次数
    }
    cout<<ans<<endl;
    return 0;
}
```

运行程序，得到结果：$9$。

---

## 作者：xzy_caiji (赞：3)

~~咕值太低怎么办？写个题解跟它干！~~

大水题一个。

设 $dp_{i}$ 为到第 $i$ 次敲键盘为止的最长连击长度。

设 $true_{i}$ 为第 $i$ 次敲击正确的字符。

设 $xiaol_{i}$ 为小蓝第 $i$ 次敲击的字符。

设 $time_{i}$ 为第 $i$ 次敲击的时间戳。

初值：$dp_{0} = 0$

转移：
$$
dp_{i} = \begin{cases}
dp_{i-1}+1 & true_{i}=xiaol_{i} \space \text{and} \space time_{i}-time_{i-1} \le 1000\\
1 & \text{otherwise.}
\end{cases}
$$

答案：$\max \{ dp_{i}\}$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[1000005],len,ans=1;
signed main(){
	freopen("log.txt","r",stdin);
	char True,xiaol;int time,pretime;
	dp[0]=0;
	cin>>True>>xiaol>>time;
	pretime=time;
	if(True==xiaol)dp[1]=dp[0]+1;
	else dp[1]=1;
	len++;
	while(cin>>True>>xiaol>>time){
		len++;
		if(True==xiaol&&time-pretime<=1000)dp[len]=dp[len-1]+1;
		else dp[len]=1;
		ans=max(ans,dp[len]);
		pretime=time;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：hyl_____ (赞：3)

## Part 0
本题也是一道水题，但洛谷最不缺的就是蒟蒻（包括我），所以今天发篇题解，庆祝本蒟蒻诞生 $n$ 周年。
## Part 1  题意
输入一堆数据，输出最长 $K$ 连击的值 $K$。
## Part 2  思路
我们可以用一个累加器累加连击次数，对于每行数据，如果与上一行数据时差不大于 $1000$ 毫秒且字符正确，则累加器加 $1$，否则重置为 $1$，然后每次用一个变量取最大就行。
## Part 3  代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
//	freopen("log.txt","r",stdin);因为数据量过大，所以要用文件读入，如果是评测就把这行注释掉
	char a,b;
	long long h,h_last,maxn=-1,sum=1;
	cin>>a>>b>>h;
	h_last=h;//提前读入一行,防止错误答案
	while(cin>>a>>b>>h)//直到输入结束为止
	{
		if(a!=b) 
		{
			sum=1;
			continue;
		}//两个字符是否相同，不相同则重置累加器
		if(h-h_last<=1000) sum++;
		else sum=1;//判断间隔有没有超
		h_last=h;
		maxn=max(maxn,sum);//取一下最大
	} 
	cout<<maxn;
	return 0;
}

```

---

## 作者：chinazhanghaoxun (赞：2)

## 题意

给定我们 2 个字符 $a$ 和 $b$，以及击打当前这一下的时间。如果 $a$ 与 $b$ 相同且与上次击打的时间相差不超过 1000 毫秒，则称它们是连击。否则就不算作连击，要重新计算连击次数 $K$。
## 分析

这道题很明显是道水题，直接根据题意模拟判断即可。

首先，使用 $cnt$ 变量记录当前连击了多少下，如果符合题目中描述的连击条件，那么 $cnt+1$，并与当前所有答案中的最大值 $ans$ 取较大值。如果不满足，则 $cnt$ 重置，继续模拟。
## 代码+注释

记得要开 long long 呀。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int ans=-1,cnt=1;
	char a,b;
	int tim,lst;//lst表示上一次的时间 
	cin>>a>>b>>tim;//先手动输入一组数据，避免出错
	lst=tim;
	while(cin>>a>>b>>tim){
		if(a!=b){//未正确敲打 
			cnt=1;//重置 
			continue; 
		}
		if(tim-lst<=1000){//时间也没超 
			cnt++;
			lst=tim;//记录现在的时间 
		}else{
			cnt=1;//重置时间 
			lst=tim;
		}
		ans=max(ans,cnt);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ToastBread (赞：2)

## 题目做法
很简单的题目，但是坑。
思路大概就是：
- 读入一次操作
- 判断有没有断 combo（敲击不正确/时间间隔过长）
- 判断有没有加 combo（敲击正确）

思路是很简单的，讲一下实现的坑点。

翻看 `log.txt` 发现第一次敲击是**正确**的（`h h 1709446139591`），于是可以读入第一条数据，把当前的 combo 设置为 $1$，把上一次敲击的时间设置为这条时间（$1709446139591$）。

从第二条开始，正常读入处理即可。**最后一条读入完毕后记得将答案更新**。

需要注意**如果因为时间过长但敲击正确而断 combo 的话，敲击结束后 combo 为 $1$ 而不是 $0$**。

实现细节见我的代码注释。
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long now,last=0,combo=0,maxc=-1;//不开 ll 见祖宗
char a,b;
int main() {
	cin>>a>>b>>last;//第一次敲击是正确的(h h) 
	combo++;//初始化 combo 为 1
	for(int i = 2; i <= 2000; i++)
	{
		cin>>a>>b>>now;
		if(a!=b||now-last>1000)//miss 要扣税
		{
			maxc=max(maxc,combo);
			combo=0;
		} 
		if(a==b)//加 combo
		{
			combo++;
		}
		last=now;//更新时间
	}
	maxc=max(maxc,combo);//记得更新答案
	cout<<maxc;//输出
}
```

很轻松的得到答案为 $9$。

~~好像是今年三月份开始打的歌，真菜。~~

---

## 作者：ggylz49 (赞：1)

## 思路分析
首先根据题目要求，下载文件 `log.txt`。然后目视所有的毫秒时间戳，发现需要开 `long long` 类型；再把数据复制到 IDE 里面，发现有两千组数据，设置一个变量 $n=2000$，表示数据组数。可以直接暴力解决，具体思路如下：

1. 建立结构体 `knock`，有成员 $b,c,ms$，代表正确的敲击字符、小蓝打出的字符、打出字符的时间对应的毫秒时间戳。
   
```cpp
struct knock
{
    long long ms;
    char b,c;
}a[2010];
```
2. 接下来设定变量 $i$ 从 $1$ 枚举到 $n$，对于每一次循环，计算出以 $i$ 为第一次敲击，一共可以有多少次连击。具体的操作：
> - 设立指针变量 $j=i$ 和连击次数 $k$。
> - 用 `while` 循环，成立条件是 $j$ 不超出 $n$ 且当组数据是正确敲击。
> - 对于每一次敲击，如果和上一次敲击间隔大于 $1000$ 毫秒（$1$ 秒），自然就不算连击了，退出循环，记录最终答案 $k$；当然，如果 $j=i$，说明是第一次敲击，无需判断。
> - 一次正确的连击，答案 $k$ 和指针 $j$ 都加一。
> - 循环结束后，将最终答案 $maxk$ 更新为 $\max(maxk,k)$。

```cpp
for (int i=0;i<n;i++)
{
    int j=i,k=0;
    while((a[j].b==a[j].c)&&j<n)
    {
        if (j!=i&&(a[j].ms-a[j-1].ms)>1000)break;
        k++,j++;
    }
    maxk=max(maxk,k);
}
```
3. 最终输出 $maxk$ 即可。
## Code

```cpp
#include <iostream>
using namespace std;
struct knock
{
    long long ms;
    char b,c;
}a[2010];
int main()
{
    int n=2000,maxk=0;//初始化最终答案maxk和总数据组数n
    for (int i=0;i<n;i++)cin>>a[i].b>>a[i].c>>a[i].ms;
    for (int i=0;i<n;i++)
    {
        int j=i,k=0;
        while((a[j].b==a[j].c)&&j<n)
        {
            if (j!=i&&(a[j].ms-a[j-1].ms)>1000)break;
            k++,j++;
        }
        maxk=max(maxk,k);
    }
    cout<<maxk;
    return 0;
}
```
## 结语
运行代码，发现答案为 $9$，提交答案。不过从结果来看，`while` 循环最多运行了 $9$ 次，因此时间复杂度也很不错，可以直接提交源程序通过。

---

## 作者：皓月星辉 (赞：1)

## 题意
有 $2000$ 次（别问我怎么知道的，文件会显示行数）操作，每次操作有三个参数，分别是正确答案、小蓝的答案和操作进行的时刻，时刻的单位为毫秒。

现在定义 $K$ 连击为连续 $K$ 次真确的回答中的每两个相连的回答时刻间隔不超过 $1000$ 毫秒。

问小蓝的这 $2000$ 次回答中最多是几连击。
## 分析
~~这是一道提交答案题，你可以手搓答案。~~

对于这 $2000$ 次操作遍历一遍，记录最长连击就可以了。

不过这个文件中只有操作参数，所以要在它的开头加一行，写上 $2000$ 才能开始遍历。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,t,f,ans,cnt;
char a,b;
int main()
{
	freopen("log.in","r",stdin);//数据太大，不能手输，要用读取
	cin>>n;
	while(n--)
	{
		cin>>a>>b>>x;
		if(a==b)
		{
			if(!f)
			{
				t=x;
				cnt++;
				f=1;
			}
			else
			{
				if(x-t<=1000)//判断连击
				{
					t=x;
					cnt++;
				}
				else
				{
					ans=max(ans,cnt);//比较答案
					cnt=1;
					t=x;
				}
			}
		}
		else
		{
			ans=max(ans,cnt);//比较答案
			cnt=0;
			f=0;
		}
	}
	cout<<ans;
	return 0;
}
```

---


# [蓝桥杯 2024 省 C] 数字诗意

## 题目描述

在诗人的眼中，数字是生活的韵律，也是诗意的表达。

小蓝，当代顶级诗人与数学家，被赋予了“数学诗人” 的美誉。他擅长将冰冷的数字与抽象的诗意相融合，并用优雅的文字将数学之美展现于纸上。

某日，小蓝静坐书桌前，目光所及，展现着 $n$ 个数字，它们依次为 $a_1, a_2, \cdots, a_n$，熠熠生辉。小蓝悟到，如果一个数能够以若干个（至少两个）**连续的正整数**相加表示，那么它就蕴含诗意。例如，数字 $6$ 就蕴含诗意，因为
它可以表示为 $1 + 2 + 3$。而 $8$ 则缺乏诗意，因为它无法用连续的正整数相加表示。

小蓝希望他面前的所有数字都蕴含诗意，为此，他决定从这 $n$ 个数字中删除一部分。请问，小蓝需要删除多少个数字，才能使剩下的数字全部蕴含诗意？

## 说明/提示

**【样例说明】**

在样例中，数字 $3$ 可以表示为 $1 + 2$，数字 $6$ 可以表示为 $1 + 2 + 3$，数字 $8$ 无法表示为连续的正整数相加，因此，需要删除的数字个数为 $1$。

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$1 \le n \le 10^3$，$1 \le a_i \le 10^3$。  
对于所有评测用例，$1 \le n \le 2 \times 10^5$，$1 \le a_i \le 10^{16}$。

## 样例 #1

### 输入

```
3
3 6 8```

### 输出

```
1```

# 题解

## 作者：liuliucy (赞：20)

### 思路
首先考虑等差数列求和，这里是题目是公差为一的等差数列，设第一个数是 $n$，最后一个是 $m$，我们能列出公式： 
$$a_i=\frac{(n+m)\times(m-n+1)}{2}$$
我们要找到一个不能被连续数和表示的 $a_i$，移项有：
$$2a_i=(n+m)\times(m-n+1)$$
不能被表示，当且仅当 $n=m$，只能被自身表示，我们容易发现，$n+m$ 和 $m-n+1$ 奇偶性不同，所以若能写成这种形式，一定是能分解成一个奇数乘一个偶数的形式，所以只要左边是 $2^n$ 的形式，就一定不能被表示，否则一定能被表示。
### CODE
短短的也很可爱。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
#define int long long
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%lld",&x);
		int p=log2(x);
		if((1ll<<p)==x){
			ans++;
		}
	}
	printf("%lld",ans);
}
```

---

## 作者：lihl (赞：7)

### 思路
我们能发现，$x$ 如果为奇数，一定能被 $\frac{x+1}{2}+\frac{x-1}{2}$ 唯一地表示。

推广到偶数，

$\begin{aligned}
x &= 1 + \textcolor{red}{(x-1)} \\
  &= 1 + \cfrac{x-2}{2} + \textcolor{red}{\cfrac{x}{2}} \\
  &= 1 + \cfrac{x-2}{2} + \cfrac{\cfrac{1}{2}x+1}{2} + \textcolor{red}{\cfrac{\cfrac{1}{2}x-1}{2}}\\
  &=\cdots
\end{aligned}$

而我们知道奇数一定可以被表示。

如果证明以上过程？

$17 = 1+16 = 1+1+\underline{7}+8 = 8+9$  
$21 = 1+20 = 1+1+\underline{9}+10 = 10+11$  
$12 = 1+\underline{11} = 1+\underline{5}+6 = 1+2+3+6$

所以以上过程成立。

这个等式不成立，当且仅当在分解的过程中，没有出现任何一个除一以外的奇数，即 $x=2^k,k>0$。

证明，因为 $1,2,4$ 不能被表示，所以 $8$ = $1+1+2+4$ 自然不能被表示，$16 = 1+1+2+4+8$ 自然也不能被表示。

故判断 $x$ 是不是为 $2$ 的幂即可。

---

## 作者：__const_int__ (赞：4)

### Analysis
结论，如果 $a_i$ 是二的次幂则它不蕴含诗意。

我们设 $a_i$ 是 $2^k$，如果 $2^k$ 可以由 $x + (x + 1)$ 得来，说明 $2^k$ 是奇数，因为 $x + (x + 1)$ 等于 $2x + 1$，显然是奇数。

$2^k$ 显然是偶数，但如果能拆分成至少两个连续的正整数相加表示，它就必须是奇数，所以不行。

注意本文中提到的 $k$ 大于等于 $1$，对于 $a_i = 2^0$，显然 $a_i$ 不能拆分成至少两个连续的正整数相加表示。

### Code
```cpp
#include<bits/stdc++.h>

using ll = long long;
const int maxn = 200005;

ll a[maxn], n, ans;

int main(){
  std::cin >> n;
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= 63; j++){
    	if ((1ll * 1 << j) == a[i]) {
    		ans++;
    	}
    }
  }
  std::cout << ans;
}
```

---

## 作者：smydahaoren (赞：3)

### 题目大意

给定 $n$ 个正整数，要求询问在这 $n$ 个数中有多少数不可以被写成连续的正整数相加的形式。

### 题目思路

首先分析样例：

- $3=1+2$
- $6=1+2+3$
- $8=1+3+4$

$8$ 不满足要求。

因为题目要求中包含连续的正整数相加，这就可以联想到等差数列求和公式：

$$\frac{(a_1+a_n)\times n}{2}=\displaystyle\sum_{i=1}^na_i$$

设该数为 $x$，首项为 $a$，末项为 $b$，且 $a>b$。因为公差是 $1$，所以可以求出项数是 $b-a+1$。

所以如果 $x$ 可以表示成：

$$2x=(a+b)\times(b-a+1)$$

那么 $x$ 就符合要求。

可以通过枚举的方式证明右边的式子中两部分奇偶性不相同，因为 $a>b$，所以 $a$ 和 $b$ 不相同。

因为右边式子必定包含奇数质因子，所以要构造出奇偶性不同的式子，就需要左边也包含。

因此如果 $x$ 没有奇数质因子，$x$ 就不符合要求，其余情况均可以用解方程的方式构造出合适的式子。

因此得出结论 $x$ 如果是 $2$ 的幂就不符合要求。

### AC code


```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define antirep(i,a,b) for(int i=a;i>=b;i--)
#define speed ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
const int N=1e6,M=1e3,mod=1e9+7,INF=1e9;
int n,ans;
bool check(int x){
	while(x!=1){
		if(x%2==0) x/=2;
		else return 0;
	}
	return 1;
}
signed main(){
	speed;
	cin>>n;
	rep(i,1,n){
		int x;
		cin>>x;
		if(check(x)) ans++;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：wht_1218 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10900)

---

首先考虑奇数，我们知道，奇数 $x=\frac{x+1}{2}+\frac{x-1}{2},x>1$，即大于 $1$ 的奇数一定能被分解。偶数 $y=1+(y-1)$，即偶数一定是最接近且小于它的奇数再加 $1$。

注意到 $1,2,4$ 不能被表示（枚举得来），所以 $8,16,32\cdots$ 都不可以被表示，因为它们总能化为 $1+2+4+8+16+\cdots$，所以只要判断每个数是不是 $2$ 的幂次就可以了。

时间复杂度 $O(n\log V)$，$V$ 是值域大小，这里是 $10^{16}$。

```cpp
long long p2[107];
void init(){
    p2[1]=1ll;
    for(int i=2;i<=60;++i)p2[i]=p2[i-1]<<1;
    return;
}inline bool check(long long x){
    for(int i=1;i<=60;++i)if(p2[i]==x)return 1;
    return 0;
}
```

---

## 作者：zhoujunchen (赞：0)

做题思路
---
又是一道小学数学题。

我们设第一个数为 $l$，连续正整数的个数为 $r$，意味着它可以表示成以下形式：

$$a_i=l+(l+1)+(l+2)+\dots+(l+r-1)$$

化简为：

$$ a_i = \frac{r}{2} (2\times l + (r - 1)) $$

从上式可以看出，如果 $a_i$ 可以写成 $r$ 个连续正整数的和，则 $r$ 必须是 $a_i$ 的一个因子。如果 $a_i$ 是一个 $2$ 的幂次，则 $a_i$ 不能表示为连续正整数之和。因为 $2$ 的幂次的因子只有 $1$ 和它自己，所以无法满足条件。

我们只需要判断它是不是 $2$ 的幂次即可，可以使用 $\operatorname{lowbit}$ 运算。

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1000005],ans;
int lowbit(int zhaotl){
    return zhaotl&(-zhaotl);
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(lowbit(a[i])==a[i])ans++;
    }
    cout<<ans;
    return 0;
}
```

---


# [蓝桥杯 2024 省 C] 封闭图形个数

## 题目描述

在蓝桥王国，数字的大小不仅仅取决于它们的数值大小，还取决于它们所形成的“封闭图形”的个数。

封闭图形是指数字中完全封闭的空间，例如数字$1$、$2$、$3$、$5$、$7$ 都没有形成封闭图形，而数字 $0$、$4$、$6$、$9$ 分别形成了 $1$ 个封闭图形，数字 $8$ 则形成了 $2$ 个封闭图形。值得注意的是，封闭图形的个数是可以累加的。例如，对于数字 $68$，由于 $6$ 形成了 $1$ 个封闭图形，而 $8$ 形成了 $2$ 个，所以 $68$ 形成的封闭图形的个数总共为 $3$。

在比较两个数的大小时，如果它们的封闭图形个数不同，那么封闭图形个数较多的数更大。例如，数字 $41$ 和数字 $18$，它们对应的封闭图形的个数分别为 $1$ 和 $2$，因此数字 $41$ 小于数组 $18$。如果两个数的封闭图形个数相同，那么数值较大的数更大。例如，数字 $14$ 和数字 $41$，它们的封闭图形的个数都是 $1$，但 $14 < 41$，所以数字 $14$ 小于数字 $41$。如果两个数字的封闭图形个数和数值都相同，那么这两个数字被认为是相等的。

小蓝对蓝桥王国的数字大小规则十分感兴趣。现在，他将给定你 $n$ 个数 $a_1, a_2,\cdots, a_n$，请你按照蓝桥王国的数字大小规则，将这 $n$ 数从小到大排序，并输出排序后结果。

## 说明/提示

**【样例说明】**

对于给定的数字序列 $[18, 29, 6]$，数字 $18$ 的封闭图形个数为 $2$，数字 $29$ 的封闭图形个数为 $1$，数字 $6$ 的封闭图形个数为 $1$。按照封闭图形个数从小到大排序后，得到 $[29, 6, 18]$。

由于数字 $29$ 和数字 $6$ 的封闭图形个数相同，因此需要进一步按照数值大小对它们进行排序，最终得到 $[6, 29, 18]$。

**【评测用例规模与约定】**

对于 $50\%$ 的评测用例，$1\le n \le 2 \times 10^3$，$1 \le a_i \le 10^5$。  
对于所有评测用例，$1 \le n\le 2 \times 10^5$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
3
18 29 6```

### 输出

```
6 29 18```

# 题解

## 作者：__galaxy_1202__ (赞：19)

## 解题思路：
排序题，`sort` 自定义排序即可。  
排序方法就照题目中的来，先定义一个表示每个数字大小的值，也就是**封闭图形的个数**（题目中已经有了，照打上去就行）。  
接着按照**先封闭图形的个数、后本身数值的大小从小到大**排序，就完结撒花啦！

## CODE：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, a[200001];
int num[10]{1, 0, 0, 0, 1, 0, 1, 0, 2, 1};//表
int sum(int x)//拆位计算
{
    int ans = 0;
    while (x)
    {
        ans += num[x % 10];
        x /= 10;
    }
    return ans;
}
bool cmp (int a, int b)//cmp 自定义判断
{
    int na = sum(a), nb = sum(b);
    if (na != nb) return na < nb;
    return a < b;
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= n; i++) cout << a[i] << ' ';
    return 0;
}
```

---

## 作者：Getaway_Car_follower (赞：8)

我们设 $f(x)$ 为 $x$ 的封闭图形个数。

那么我们就注意到 $f(x)=f(\lfloor\frac{x}{10}\rfloor)+f(x\bmod 10)$，而 $f(0)\sim f(9)$ 可以直接打表出来，这样，我们就可以用  $O(\log_{10} x)$ 的复杂度算出 $f(x)$。

所以我们可以对于每个 $a_i$ 按 $f(a_i)$ 排序即可，若 $f(a_i)$ 相等，则按 $a_i$ 排序。

复杂度 $O(n\log n+n\log_{10} V)$，其中 $V$ 是值域。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=2e5+5;
int n;
pair<int,int> a[N];
int cnt[]={1,0,0,0,1,0,1,0,2,1};

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].second;
		int x=a[i].second;
		while(x){
			a[i].first+=cnt[x%10];
			x/=10;
		}
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) cout<<a[i].second<<' ';
	return 0;
}
```

---

## 作者：zhoujunchen (赞：1)

做题思路
---
这道题非常简单，我们用一个结构体存储这个数的值和封闭图形的个数，每输入一个数就将它数位拆分，若拆出的数字为 $0,4,6,9$ 计数器就加一，若为 $8$ 计数器就加二。

然后按题目的规则排序，可以写一个比较函数或运算符重载。

比较函数版本：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct zhaotl{
    int x,cnt;//x代表数的值，cnt代表x的封闭图形个数
}a[200005];
int n;
bool cmp(zhaotl u,zhaotl v){
    if(u.cnt==v.cnt)return u.x<v.x;
    return u.cnt<v.cnt;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].x;
        a[i].cnt=0;
        int tmp=a[i].x;
        while(tmp){//数位拆分
            int k=tmp%10;
            if(k==0||k==4||k==6||k==9)a[i].cnt++;
            if(k==8)a[i].cnt+=2;
            tmp/=10;
        }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)cout<<a[i].x<<" ";
    return 0;
}
```

重载运算符版本：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct zhaotl{
    int x,cnt;
    bool operator <(const zhaotl u)const{
        if(u.cnt==cnt)return x<u.x;
        return u.cnt>cnt;
    }
}a[200005];
int n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].x;
        a[i].cnt=0;
        int tmp=a[i].x;
        while(tmp){
            int k=tmp%10;
            if(k==0||k==4||k==6||k==9)a[i].cnt++;
            if(k==8)a[i].cnt+=2;
            tmp/=10;
        }
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)cout<<a[i].x<<" ";
    return 0;
}
```

---

## 作者：liuliucy (赞：1)

### 思路
我们先求出封闭图形个数，其实就是处理每一个数字的封闭图形个数然后加起来，最后多关键字排序即可。
### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
struct xx{
	int x,y;
}a[1000001];
int n;
const int b[]={1,0,0,0,1,0,1,0,2,1};
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].x);
		int x=a[i].x;
		while(x){
			a[i].y+=b[x%10];
			x/=10;
		}
	}
	sort(a+1,a+1+n,[](xx a,xx b){return a.y<b.y||a.y==b.y&&a.x<b.x;});
	for(int i=1;i<=n;i++){
		printf("%d ",a[i].x);
	}
	return 0;
}

```

---

## 作者：__HappY__ (赞：1)

### 题意

有 $n$ 个数，判断他们有几个封闭图形，就是带有几个特定数字，根据这个排序，如果封闭图形数目相同，按数字大小排序。

### 思路

开一个结构体，在输入时记录有几个封闭图形。处理完之后用一个快排，加一点判断。

### 代码及讲解

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int N = 2e5 + 117;
struct num{
	int s;	//记录数字 
	int f = 0;	//记录封闭图形个数 
} a[N];
int cmp(num a, num b) {
	return a.f < b.f || a.f == b.f && a.s < b.s;	// 对结构体排序 
}
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i].s;
		int num = a[i].s;
		while(num > 0) {
			int w = num % 10;	// w 是每一位数 
			if(w == 0 || w == 4 || w == 6 || w == 9) a[i].f += 1;	// 如果是这些数，封闭图形个数加一 
			if(w == 8) a[i].f += 2;	// 如果是 8 ，封闭图形个数加二 
			num /= 10;
		}
	}
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
		cout << a[i].s << ' ';
	}
	return 0;
}

``````

---


# [蓝桥杯 2024 省 Python B] 连连看

## 题目描述

小蓝正在和朋友们玩一种新的连连看游戏。在一个 $n \times m$ 的矩形网格中，每个格子中都有一个整数，第 $i$ 行第 $j$ 列上的整数为 $A_{i,j}$。玩家需要在这个网格中寻找一对格子 $(a,b)$ 和 $(c,d)$ 使得这两个格子中的整数 $A_{a,b}$ 和 $A_{c,d}$ 相等，且它们的位置满足 $|a-c| = |b-d| > 0$。请问在这个 $n \times m$ 的矩形网格中有多少对这样的格子满足条件。


## 说明/提示

一共有以下 6 对格子：$(1,2)−(2,1)$，$(2,2)−(3,1)$，$(2,1)−(3,2)$，$(2,1)−(1,2)$，$(3,1)−(2,2)$，$(3,2)−(2,1)$。

### 数据范围

对于 $20\%$ 的评测用例，$1 \leq n, m \leq 50$；

对于所有评测用例，$1 \leq n, m \leq 1000$，$1 \leq A_{i,j} \leq 1000$。


## 样例 #1

### 输入

```
3 2 
1 2 
2 3 
3 2
```

### 输出

```
6```

# 题解

## 作者：MLE_Automaton (赞：15)

来水一发题解。

既然是 Python 组的，就拿 Python 写吧。

## 题目分析
给定一个 $n \times m$ 的矩阵，问你有多少对点在同一对角线上，满足两点值相同。

用八皇后的思路，正斜线(`/` 型)上的两点横坐标与竖坐标和相同，反斜线(`\` 型)上的两点横坐标与竖坐标差相同。

所以我们可以建立 $2$ 个 `dict`，一个存横坐标与竖坐标和与值，另外一个存横坐标与竖坐标差与值。遍历每个元素并累加值，最后别忘了乘以 $2$。

其中，还要注意一些 Python 的小细节（比如写 `main` 函数等等），不然很容易 TLE。

## Talk is cheap,show me the code!
```python
# By ChenXiJie2013(luogu uid:928418)
def main():
    a = []
    n, m = map(int, input().split())
    zheng, fan = dict(), dict()
    getz, getf = zheng.get, fan.get
    ans = 0
    for i in range(n):
        a.append(tuple(map(int, input().split()))) # 注意map强转成tuple
    for i in range (n):
        for j in range(m):
            ans += getz((i + j, a[i][j]), 0)
            zheng[(i + j, a[i][j])] = getz((i + j, a[i][j]), 0) + 1
            ans += getf((i - j, a[i][j]), 0)
            fan[(i - j, a[i][j])] = getf((i - j, a[i][j]), 0) + 1
    print(ans * 2)
if __name__ == "__main__":
    main()
```

[非常惊险的记录](https://www.luogu.com.cn/record/175420772)

注：本蒟蒻第一次写题解，若有不足请及时指出。

---

## 作者：andycode (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P11001)
 # 思路讲解
仔细读题，不难发现。如果 $|a-c|=|b-d|>0$，则说明 $A_{a,b}$ 与 $A_{c,d}$ 同处一条对角线，且不是同一个点。

而要使 $A_{a,b}$ 和 $A_{c,d}$ 在同一条对角线上，要么 $a-b=c-d$，要么 $a+b=c+d$。

所以，我们可以使用两个 `map` 来统计两个对角线上的数值的个数，在输入时，**先**将答案加上除该点以外的前面的在该点两条对角线上与它相等的点的个数，**再**将该点加入到两个 `map` 中。

最后将答案乘 $2$ 输出即可，因为一对点反过来，能作为一对新的点。
 # 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
map <pair<int,int>,int> mp1,mp2;
int main(){
    int n,m,ans=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            int a;
            cin>>a;
            ans+=mp1[make_pair(a,i-j)]++,ans+=mp2[make_pair(a,i+j)]++;//先加答案，再加map
        }
    cout<<ans*2;//乘2输出
    return 0;
}
```
完结撒花！

---

## 作者：JYX0924 (赞：1)

这道题本质上是问有多少对 $a_{x,y}=a_{x+i,y+i}$。

对于每一条平行于对角线的线，我们可以用优先队列来存一下这条线上的每一个数。统计时假设 $x$ 有 $y$ 个，那么 $x$ 对答案的贡献就是 $y\times(y-1)$。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 1005 
using namespace std;
ll n,m,a[maxn][maxn],vis[maxn][maxn],tot,ans;
priority_queue<ll> q[maxn<<2];
void dfs1(int row,int col)
{
	if(vis[row][col]==1||row>n||col>m||row<1||col<1) return;
	vis[row][col]=1; q[tot].push(a[row][col]);
	dfs1(row+1,col+1); dfs1(row-1,col-1);
}
void dfs2(int row,int col)
{
	if(vis[row][col]==2||row>n||col>m||row<1||col<1) return;
	vis[row][col]=2; q[tot].push(a[row][col]);
	dfs2(row-1,col+1); dfs2(row+1,col-1);
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>m; for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		if(vis[i][j]==1) continue;
		tot++; dfs1(i,j);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		if(vis[i][j]==2) continue;
		tot++; dfs2(i,j);
	}
	for(int i=1;i<=tot;i++)
	{
		if(q[i].size()<=1) continue;
		while(!q[i].empty())
		{
			ll now=q[i].top(),num=1; q[i].pop();
			while(!q[i].empty()&&q[i].top()==now) q[i].pop(),num++;
			ans=ans+num*(num-1);
		}
	}
	cout<<ans;
	return 0;
}
```
谢谢大家！！！

---

## 作者：Breath_of_the_Wild (赞：0)

使用一种跑起来非常非常慢的做法，但能 AC。

枚举每一个点 $a_{i,j}$，扫一遍 $a_{i,j}$ 的右下方和左下方是否有与其相同的节点，相同则贡献 $+1$。（用 $k$ 表示枚举到的节点和 $a_{i,j}$ 横或纵坐标之差）

注意边界问题。可以每次循环判断当前节点是否越界，不过这样做较慢，不如提前算好 $k$ 要从 $1$ 循环到几。现在来考虑这个问题。如果从 $a_{i,j}$ 往右下方扫，那么横坐标最多动 $n-i$，纵坐标最多动 $m-j$；如果从 $a_{i,j}$ 往左下方扫，那么横坐标最多动 $n-i$，纵坐标最多动 $m-j$。每一种情况的 $k$ 能扫到的最大值为横坐标与纵坐标最多动的格数的最小值。这些都是比较显然的。

那么为什么不把 $a_{i,j}$ 的斜着 $4$ 个方向都枚举一遍？显然太慢了，常数为上述的 $2$ 倍，直接枚举两个不在同一条直线的方向即可。所以用上面的算法得到的结果乘 $2$ 即为最终答案。

```cpp
int main(){
    ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
//  输入...
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int mn1=min(n-i,m-j),mn2=min(n-i,j+1);
			for(int k=1;k<=mn1;k++)	ans+=(a[i][j]==a[i+k][j+k]);
			for(int k=1;k<=mn2;k++)	ans+=(a[i][j]==a[i+k][j-k]);
		}
	}
	cout<<(ans<<1);
}
```

---


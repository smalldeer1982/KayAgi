# [蓝桥杯 2024 省 B 第二场] 遗迹

## 题目背景

搬题人注：本题【数据保证随机】意义不明，并未说明哪些变量是随机的。目前洛谷数据中 $n,m,L,s,t$ 均为随机。可以前往 [P12129](https://www.luogu.com.cn/problem/P12129) 评测不完全保证数据随机的版本。

## 题目描述

小蓝找到了一个外星文明留下来的遗迹，遗迹大门的屏幕上有一个长度为 $m$ 的字符串 $t$ 和一个输入框，下面还有一个键盘，键盘为一个长度为 $n$ 的字符串 $s$ ，由一个可以横向移动的指针来敲击键盘，指针可以向左移或向右移，不能移出键盘。

小蓝需要在键盘字符串 $s$ 上先指定指针初始位置然后不断移动指针的位置，过程中通过敲击指针所在的字符来进行输入。然而，指针最多只能移动 $L$ 的距离，小蓝想输入一个尽可能长的一个 $t$ 的前缀，请问他最多能输入多少位。

## 说明/提示

### 样例说明

初始选择指针位于键盘 $\tt{abc}$ 上的 $\tt{a}$，输入 $\tt{acbbac}$ 这 $6$ 个字符分别需要指针移动 $0, 2, 1, 0, 1, 2$ 的距离，而最大移动距离为 $5$，所以最多输入 $5$ 个字符，移动 $0 + 2 + 1 + 0 + 1 = 4$ 的距离。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq m \leq 20$；
- 对于所有评测用例，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^5$，$1 \leq L \leq 10^9$ 且 $s, t$ 中只包含小写字母，且 $s$ 中一定包含所有 $t$ 中出现过的字母，数据保证随机。

## 样例 #1

### 输入

```
3 6 5
abc
acbbac```

### 输出

```
5```

# 题解

## 作者：_wsq_ (赞：8)

因为保证数据随机，而我们注意到 $1\le m\le 10^5$ 和 $1\le L\le 10^9$。显然，如果 $L\ge m$，那么 $s$ 中的任意两个字符之间都可以相互移动到。在数据随机的情况下，计算可得 $L\ge m$ 的概率高达 $\frac{10^9\times10^5-\frac{10^5\times(10^5-1)}{2}}{10^9\times10^5}=0.9999500005$。这道题有 $20$ 个测试点，因此所有测试点都满足上述要求的概率为 $0.9999500005^{20}\approx0.999000484848$。因此输出 $m$ 即可通过本题。

![](https://cdn.luogu.com.cn/upload/image_hosting/xb34234a.png)

另外不知道哪个题解审核志愿者告诉我因为缺代码不过审？！那就只能加上代码了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int m;
    cin>>m>>m;
    cout<<m;
    return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：4)

### 解题思路

#### 错解

贪心：每次都移动至当前最近的对应方块上。

反例：

$s =$ `abxac`

$t =$ `abac`

贪心结果（下标） $0 \rightarrow 1 \rightarrow 0 \rightarrow 4$，答案为 $5$。

正确结果（下标） $0 \rightarrow 1 \rightarrow 3 \rightarrow 4$，答案为 $4$。

答案与逾期不符合，故贪心解法不正确。

#### 正解

首先，我们注意到数据范围的最后一句话，**数据保证随机**，那么这样每个字符的数量约为 $\dfrac n {26}$。

当我们要在**键盘串**查找一种字符的位置时，$O(n)$ 遍历效率较低，可以考虑先将字符串进行预处理，将字符 `a` 的下标全部存入 $g[0]$，字符 `b` 的下标存入 $g[1]$，$\dots$

设 $f[x]$ 表示当前情况下，以 $s[x]$ 作为结尾字符，键盘指针指向 $x$，构成字符串的最小代价。例如，设键盘串为 $abcdef$，$f[3]$ 表示构成 $abcd$，且最终键盘指针指向 $3$ 的最小代价。

计算出字符串 `abcc` 所需要的步数时：
- 我们可以先计算构成 `a` 的**所有最短步数**，键盘串中一定存在 `a`，设其中一个为 `a` 的下标为 $x$，那么 $f[x] = 0$，由于 $f$ 数组定义在全局，故此处在代码中不体现。
- 接下来计算构成 `ab` 的**所有最短步数**，由于我们已经计算出了构成 `a` 的**所有最短步数**，那么我们可以暴力枚举所有 `a` 的位置，与所有 `b` 的位置，假设其中一个 `a` 的位置为 $y$，其中一个 `b` 的位置为 $x$，那么 $f[x] = min(f[x], f[y] + abs(x - y))$。
- 计算所有构成 `abc` 的做法如上。
- 计算所有构成 `abcc` 的最短步数，由于 $t[3] = t[2]$，故本轮可跳过。

时间复杂度 $O(m(\dfrac n {C})^2)$，其中 $C = 26$ 表示字符种类。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 1e3 + 10, INF = 0x3f3f3f3f;

int n, m, t;
string s, str;
vector<int> g[26];
int f[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m >> t >> s >> str;
    
    for (int i = 0; i < n; ++ i )
        g[s[i] - 'a'].push_back(i);
    
    for (int i = 1; i < m; ++ i )
    {
        int u = str[i] - 'a', last = str[i - 1] - 'a';
        if (u != last)
        {
            int res = INF;
            bool find = false;
            for (auto x: g[u])
            {
                for (auto y: g[last])
                    res = min(res, f[y] + abs(x - y));
                f[x] = res;
                if (f[x] <= t)
                    find = true;
            }
            
            if (!find)
            {
                cout << i << endl;
                return 0;
            }
        }
    }
    
    cout << m << endl;
    
    return 0;
}
```

---

## 作者：Tomwsc (赞：2)

# P12125 [蓝桥杯 2024 省 B 第二场] 遗迹 题解

考虑预处理出第一个字符串中每一位与其他小写字母的最短距离，用一个 ```map``` 存储。接着只需要暴力在第二个字符串中模拟指针的移动即可。不过因为起点不确定，所以要在第一个字符串中枚举指针的起点。时间复杂度比较极限，最坏情况是：$O(nm\log n)$？但我们有信仰，所以直接提交……嗯嗯，其实呢因为数据十分随机，所以压根就卡不到时间复杂度的上限，甚至于完全可以打完整个字符串。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf (1ll << 62)
#define regint register int
#define pb push_back
#define mp make_pair
#define PII pair<int , char>
using namespace std;
const int MAXN = 1e5 + 10;
int n , m , l;
string s1 , s2;
map<PII , int>mapp;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> l;
	cin >> s1 >> s2;
	s1 = ' ' + s1;
	s2 = ' ' + s2;
	for(regint i = 1;i <= n;i ++) {
		for(regint j = 1;j <= i;j ++)
			mapp[mp(i , s1[j])] = j;
		for(regint j = n;j > i;j --)
			if(i - mapp[mp(i , s1[j])] > j - i)
				mapp[mp(i , s1[j])] = j;
	}
	int ans = - inf;
	for(regint i = 1;i <= n;i ++)
		if(s1[i] == s2[1]) {
			int cnt = 0;
			int last = i;
			for(regint i = 1;i <= m;i ++)
				if(l >= abs(last - mapp[mp(last , s2[i])])) {
					l -= abs(last - mapp[mp(last , s2[i])]);
					last = mapp[mp(last , s2[i])];
					cnt ++;
				} else
					break;
			ans = max(ans , cnt);
		}
	cout << ans;
	return 0;
}
```

---

## 作者：cccyyymmm (赞：2)

思路：

因为前缀和的最大长度满足，它之前所有字符都要满足条件**前面的字符匹配了，才能匹配后面的字符**考虑动态规划。

我们希望找到的是实现这个前缀和的**最短**路径长度。

也就意味着它可以由到达它之前所在的相同字符的所有位置的最短路径长度和到达它同字符的所有位置的所有情况中，找到**最短的**那条路径，就是**到达它的最短路径**。

如果最短路径都无法满足**小于等于**最大允许长度，说明已经找到了**最短路径**。

第一个字符不用考虑，因为它作为初始位置，默认从第二个字符开始看，也就是看它到它前一个字符的所有路径情况，找到实现它同字符所有位置最短的。

依次类推，直到距离不够用或者找全了前缀为止。

------

以下是我的代码，按照思路一步一步写就好了

```cpp

#include<bits/stdc++.h> 
using namespace std;
vector<int > a[26];
int st[10010];
int n,m,L;
string s,t;
int main()
{
    cin>>n>>m>>L;
    cin>>s>>t;
    //将到达这个字符的所有位置记录
    for(int i=0;i<n;i++)
    {
        a[s[i]-'a'].push_back(i);
    }
    
    //遍历目标前缀，从第2个字符开始，因为初始位置
    for(int i=1;i<m;i++)
    {
        //找到当前字符，以及它之前的一个字符
        int cur = t[i]-'a';
        int pre = t[i-1]-'a';
        //如果相同代表不用移动，直接跳过
        if(cur==pre)continue;
        bool l=0;
        int ans = 0x3f3f3f3f;
        //遍历每一个当前字符的位置，确认到达它的最短路径
        for(auto cur_c:a[cur])
        {
            for(auto pre_c:a[pre])
            {
                ans=min(ans,st[pre_c]+abs(pre_c-cur_c));
            }
            st[cur_c] = ans;
            //存在能够到达的路径
            if(ans<=L)
                l = 1;
        }
        if(l==0)
        {
            cout<<i;//输出无需多言
            return 0; 
        }
    }
    //都能到达输出目标前缀长度即可。
    cout<<m;
    return 0;//好习惯
}

---


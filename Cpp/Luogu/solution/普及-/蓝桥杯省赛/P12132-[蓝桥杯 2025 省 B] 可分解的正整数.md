# [蓝桥杯 2025 省 B] 可分解的正整数

## 题目背景

本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。

## 题目描述

定义一种特殊的整数序列，这种序列由**连续递增的整数**组成，并满足以下条件：
1. 序列长度至少为 $3$。
2. 序列中的数字是连续递增的整数（即相邻元素之差为 $1$），可以包括正整数、负整数或 $0$。

例如，$[1, 2, 3]$、$[4, 5, 6, 7]$ 和 $[−1, 0, 1]$ 是符合条件的序列，而 $[1, 2]$（长度不足）和 $[1, 2, 4]$（不连续）不符合要求。

现给定一组包含 $N$ 个正整数的数据 $A_1, A_2, \dots , A_N$。如果某个 $A_i$ 能够表示为符合上述条件的连续整数序列中所有元素的和，则称 $A_i$ 是可分解的。

请你统计这组数据中可分解的正整数的数量。

## 说明/提示

### 样例说明

- $A_i = 3$ 是可分解的，因为 $[0, 1, 2]$ 的和为 $0 + 1 + 2 = 3$。
- $A_i = 6$ 是可分解的，因为 $[1, 2, 3]$ 的和为 $1 + 2 + 3 = 6$。
- $A_i = 15$ 是可分解的，因为 $[4, 5, 6]$ 的和为 $4 + 5 + 6 = 15$。

所以可分解的正整数的数量为 $3$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 100$，$1 \leq A_i \leq 100$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$，$1 \leq A_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3 6 15```

### 输出

```
3```

# 题解

## 作者：HetmesAskalana (赞：19)

## 题解
可以发现，形如 $\{-2, -1, 0, 1, 2\}$ 的和一定为 $0$，即 $\sum^k_{i = -k}i = 0, k \in \Z^+$，所以只需要在这样的序列后面加一个需要表示的正整数即可，比如要表示的是 $3$，所求序列是 $\{-2, -1, 0, 1, 2, 3\}$。

那么只有 $1$ 无法被表达出来，所以答案是数组 $a$ 中所有不是 $1$ 的数字的个数。

## 代码
```cpp
void solve(){
    int n; cin >> n;
    vector<int> a(n);
    int R = 0;
    for(int i = 0; i < n; ++i){
        cin >> a[i];
        R += (a[i] != 1);
    }
    cout << R << endl;
    return;
}
```

---

## 作者：yanmingqian (赞：10)

诈骗题。

不难发现，${-1,0,1}$ 三个数之和为 $0$，${-2,-1,0,1,2}$ 五个数之和也为 $0$。也就是说，$\sum^k_{i=-k} i=0$。在这样的序列后面加一个数 $x$，该序列的和就为 $x$。因此除了 $1$ 之外的任意正整数都是可分解的。边输入边判断即可。

代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    int n,ans;
    cin>>n;
    ans=n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        if(x==1){
            ans--;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：brofea5 (赞：5)

# 题意

给定 $n$  个数 $A$，问有多少个数可以分解成一种序列的和，这种序列满足：

1. 序列长度至少为 $3$
2. 序列中的数字是连续递增的整数，相邻元素差为1，可以为负或 $0$

$1\le A\le10^9,1\le n \le 10^5$

# 思路

注意到长度为偶数 $m$ 的序列可以构造出这样的序列，序列的和为 $a$，即 $m/2$

$$
[-(a-1),-(a-2),...,-1,0,1,...,a-2,a-1,a]~,a=\frac m2
$$

例如 $m=8$ 时，序列和为 $4$

$$
[-3,-2,-1,0,1,2,3,4]
$$

又因为 $m\ge3$ 且为偶数，所以 $a\ge 2$，即任意大于等于 $2$ 的数都可以被构造出来

所以答案就是 $n$ 减去 1 的个数

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  int n, x, cnt = 0;
  cin >> n;
  for (int i = 1; i <= n; i++)
    cin >> x, cnt += x == 1;
  cout << n - cnt << endl;
  return 0;
}
```

---

## 作者：gaomingshuo (赞：4)

# 题解P12132
## 题目大意
给定数组 $A$,求 $A$ 中有多少个数能被分解成连续大于等于 3 个整数（可以是负整数或 0 或正整数）。
## 思路
我们发现：一个数 $n$ 可以被分解成:

$[-(n-1),-(n-2),-(n-3),...,-1,0,1,...,n-2,n-1,n]$

这个数列的和就是 $n$，但我们需要注意分解成连续**大于等于 3 个**整数。因此，当 $n=1$ 时，无法分解($[0,1]$ 中只有两个整数)。

综上，我们只需要计算 $A$ 中有多少个不为 $1$ 的数，即为最终答案。
## [AC](https://www.luogu.com.cn/record/213422944) code

```cpp
#include<bits/stdc++.h>
using namespace std;
int A[100001];
int main(){
    int N;
    cin>>N;
    for(int i=1;i<=N;++i){
        cin>>A[i];
    }
    //输入。
    int ans=0;
    for(int i=1;i<=N;++i){
        if(A[i]!=1){
            ++ans;
        }
        //如果 A[i] 不是 1，ans 就自增。
    }
    cout<<ans<<endl;//输出。
    return 0;//好习惯。
}
```
### 可以短一些(我的风格)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,a,ans=0;
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a;
        ans+=a==1?0:1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：CCY20130127 (赞：2)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P12132)

## 题目思路：
对于任何一个正整数 $n$，除 $1$ 外，可以组成以下的序列：

$$−(n−1),−(n−2), \dots ,−1,0,1, \dots ,n−2,n−1,n$$

理由：无论有多大的数，都可以和它的相反数抵消，直到加到 $n$ 为止，刚好为 $n$。

但是 $1$，只能组成 $0,1$ 这两个数字，但不符合第一条规定。

## 正解：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	int cnt = 0;
	for (int i = 0; i < n; ++i) {
		int x;
		cin >> x;
		if (x != 1) cnt++;
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：pour_demain (赞：1)

代码难度不高，但是思维难度较高的一道橙题。  
~~我还对着求和公式推了半天。~~

******

其实题目可以理解为要我们构造出一组等差数列满足：
 $\sum_{i = n}^{m} i = A_i$ 且 $m - n + 1 \ge 3$ 

~~不~~难发现由于数列首项是可以为负数的，所以我们很容易构造出一组和为零的数列，我们只需令 $n = -m$ 即可。

那么我们如何让数列的和为 $A_i$ 呢？我们可以令 $m = A_i - 1$ 然后我们把 $A_i$ 接在原先和为零的数列后面即可。

但是要注意到当 $A_i = 1$ 时， $m = A_i - 1 = 0$ ， $n = -m = 0$ 我们构造出的数列为 $[0,1]$ ， $m - n + 1 = 1 < 3$ 不符合题意。  
所以只有一无法构造出数列，我们用 $n$ 减去输入中一的个数即可。

```cpp
#include<iostream>
using namespace std;
int n,a;
int main(){
	int cnt = 0;//计数器
	cin >> n;
	for(int i = 0;i < n;i++){
		cin >> a;//每次只处理一个数，不用数组可以省空间
		if(a == 1) cnt++;//累加一的个数
	}
	cout << n - cnt << endl;//总数减去1的个数
	return 0;
}
``````

---

## 作者：wnqnld_llx (赞：1)

## 题目大意
将一个数分解成一个序列，要求这个序列的长度大于等于三且序列元素是递增的。
## 思路
我们先考虑 $2$ 它可以分解为 $[-1,0,1,2]$ 。

我们发现这个序列的前三个元素之和为 $0$ 最后一个即为它本身于是我们推断要将一个数 $n$ 分解，序列为 $[1-n,2-n,...,0,...,n-1,n]$ 。

当 $n=1$ 时序列长度无法满足大于等于 $3$ 这个条件所以只要 $n\neq1$ 这个数就一定能被分解。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
int ans;
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
        int x;
		cin>>x;
		if(x!=1) ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Aamumatematiikka (赞：1)

这是一道非常简单的结论题。

题目要求判断一个数 $a$ 是否可以用 $\sum_{i=l}^{r}i$ 表示并满足 $r-l+1\ge3$。

对于一个正整数 $a$，显而易见地可以有一种非常简单的方式分解：$\sum_{i=-a+1}^{a}$，正负抵消后剩下一个 $a$。

但是有没有例外呢？经过思考和试验可以发现有一个正整数 $1$ 分解得到的数列长度为 $2$，并且无法用其他方式分解。

所以我们只要输出大于 $1$ 的正整数的个数就可以通过这道题。

代码如下：

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
int T, ans=0;
int main(){
    scanf("%d",&T);
    while(T--){
        int a;
        scanf("%d",&a);
        if(a>1) ans++; 
    }
    return printf("%d",ans)&0;
}
```

---

## 作者：zhujiahao114514 (赞：0)

观察得：一个数 $x$ ，可以被分解成 $[-(n-1),-(n-2),\cdots,-1,0,1,\cdots,n-1,n]$ ,但是当 $x$ 为 $1$ 时，只能分解成 $[0,1]$ ，只有两个，所以不能算，特判一下 $x$ 是不是等于 $1$ ，不等于就加一，等于就跳过。

~~~
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a,ans=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a;
        if(a!=1) ans++;
    }
    cout<<ans;
    return 0;
}

~~~

---

## 作者：ryderyang (赞：0)

# 解题思路
~~让注意力惊人的大佬们注意一下~~，可以注意到，对于任何数字 $x$，总有一个特殊的整数数列满足条件。大概就是这样 $\sum_{i=-(x-1)}^{x} i=x$，他们的和就是 $x$，还有什么可说的！直接输出 $n$！
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
int main()
{
	scanf("%d",&n);
	printf("%d",n);
	return 0;
}
```
提交了就会发现我们只拿了 $20$ 分，为什么呢？重新审题，我们构造的数列肯定是连续递增的，和也为 $x$。所以是长度的问题。当我们的数字为 $x$ 时，数列的长度是 $2x$。解不等式 $2x \leq 3$ ，得 $x \leq \frac{3}{2}$，所以在 $x=1$ 的时候 $x$ 是不可分解的。

# AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]!=1)
		ans++;
	}
	printf("%d",ans);
	return 0;
}
```

---


# [蓝桥杯 2025 省 B] 画展布置

## 题目描述

画展策展人小蓝和助理小桥为即将举办的画展准备了 $N$ 幅画作，其艺术价值分别为 $A_1, A_2, \dots , A_N$。他们需要从这 $N$ 幅画中挑选 $M$ 幅，并按照一定顺序布置在展厅的 $M$ 个位置上。如果随意挑选和排列，艺术价值的变化可能会过于突兀，导致观众的观展体验不够流畅。

为了优化布置，他们查阅了《画展布置指南》。指南指出，理想的画展应使观众在欣赏画作时，艺术价值的过渡尽量平缓。指南建议，选择并排列 $M$ 幅画，应使艺术价值的变化程度通过一个数值 $L$ 来衡量，且该值越小越好。数值 $L$ 的定义为：

$$L=\sum_{i=1}^{M-1} |B_{i+1}^2-B_i^2|$$

其中 $B_i$ 表示展厅第 $i$ 个位置上画作的艺术价值。

现在，他们希望通过精心挑选和排列这 $M$ 幅画作，使 $L$ 达到最小值，以提升画展的整体协调性。请你帮他们计算出这个最小值是多少。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$2 \leq M \leq N \leq 10^3$，$1 \leq A_i \leq 10^3$。
- 对于 $100\%$ 的评测用例，$2 \leq M \leq N \leq 10^5$，$1 \leq A_i \leq 10^5$。

## 样例 #1

### 输入

```
4 2
1 5 2 4```

### 输出

```
3```

# 题解

## 作者：Souture (赞：13)

~~第一次水题解有点紧张~~

本题我们很容易想到先排序，利用前缀和暴力的思想对每个数字之间的贡献求出并累加，只需要滑动一次窗口即可求出最小的  _**L**_ ， 但是说不出来这样为什么对。

这里我们来简单证明一下这样贪心的正确性。

---

### 题意

定义选取并排列后的画作艺术价值序列为  
$$
B_1, B_2, \dots, B_M,
$$  
对应的平方为  
$$
B_1^2, B_2^2, \dots, B_M^2.
$$

让我们求
$$
L=\sum_{i=1}^{M-1} \left|B_{i+1}^2 - B_i^2\right|.
$$

### 三角不等式

对任意实数 a 和 b，有三角不等式

$$
|a+b| \le |a|+|b|.
$$ 

当且仅当 a 与 b 同号（或至少其中一个为 0）时取等号。

及其推广：
$$
\begin{aligned}
\left|\sum_{k=1}^na_k\right|\leq\sum_{k=1}^n|a_k|.
\end{aligned}
$$

当且仅当 $$ a_k$$ 的符号都相同（允许个别为零，即所有非零项同正或同负）.

根据三角不等式，对于任意实数序列都有：
$$
\left|B_2^2 - B_1^2\right| + \left|B_3^2 - B_2^2\right| + \cdots + \left|B_M^2 - B_{M-1}^2\right|
\ge \left|B_M^2 - B_1^2\right|.
$$

因此，必有：
$$
L \ge \left|B_M^2 - B_1^2\right|.
$$

### 何时取等号

当且仅当序列  
$$
B_1^2, B_2^2, \dots, B_M^2,
$$  
是单调的（即递增或递减）时，三角不等式取等号。又注意到，由于所有艺术价值 $B_i$ 均为正，故 $B_i^2$ 与 $B_i$ 的单调性一致。

因此，当我们将选中的画作按艺术价值从小到大或从大到小排列时，有  
$$
L = B_M^2 - B_1^2.
$$

### 优化思路

对于固定的一组 $M$ 幅画作，最优排列顺序为使它们按照艺术价值的单调顺序排列，从而使得  
$$
L = B_M^2 - B_1^2.
$$

为了使得 $L$ 最小，我们需要从所有可能的选取中选择那一组画作，使得所选画作中最大的艺术价值和最小的艺术价值差异（经过平方）最小。设原始数组为  
$$
A_1, A_2, \dots, A_N,
$$  
经过排序后记为  
$$
A_{1} \le A_{2} \le \dots \le A_{N}.
$$

则可以证明最优方案总可以在排序后的数组中选择连续的 $M$ 个数，这样选出的最小值为 $A_{i}$，最大值为 $A_{i+M-1}$，对应的 $L$ 为  
$$
L = A_{i+M-1}^2 - A_{i}^2.
$$

### 结论

综上，题目中
$$
L=\sum_{i=1}^{M-1} \left|B_{i+1}^2 - B_i^2\right|.
$$  
经排序后，最优排列下转化为了  
$$
L = B_M^2 - B_1^2,
$$  
而最小化 $L$ 就等价于在排序后的数组中找到一个长度为 $M$ 的连续子区间，使得  
$$
A_{i+M-1}^2 - A_{i}^2,
$$  
最小。

至此，我们将原评价指标转化为了
$$
\min L = \min_{i}\left(A_{i+M-1}^2 - A_{i}^2\right).
$$  

---

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

#define endl '\n'
#define all(v) v.begin(), v.end()

void sol()
{
    int n, m; cin >> n >> m;
    vector<int> A(n);
    vector<i64> B(n);
    for (int i = 0; i < n; i++) {
        cin >> A[i];
        B[i] = 1LL * A[i] * A[i];
    }

    sort(all(B));

    i64 ans = LLONG_MAX;
    for (int i = m - 1; i < n; i++) {
        ans = min(ans, B[i] - B[i - m + 1]);
    }

    cout << ans << endl;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sol();
    return 0;
}
```

---

## 作者：mktx (赞：10)

知识点：排序，贪心

题目要选出 $ \mathit{M} $ 个数使得 $ \sum_{i=1}^{M-1}\begin{vmatrix}
B_{i+1}^{2}-B_{i}^{2}\end{vmatrix} $ 的值最小，我们可以对数组中的元素从小到大排序，去掉绝对值简化问题处理。连续选出 $ \mathit{M} $ 个数后，原式可转化为 $$ \begin{vmatrix}
a_{i}^{2}-a_{i+1}^{2}+a_{i+1}^{2}-a_{i+2}^{2}+\cdots +a_{i+m-2}^{2}-a_{i+m-1}^{2}\end{vmatrix}=a_{i+m-1}^{2}-a_{i}^{2} $$ 。

因此问题可以转化为从数组中选择 $ \mathit{M} $ 个数，使得选出的数中的第 $ \mathit{M} $ 个数的平方减去第1个数的平方最小，可以证明，最优解一定是排序后的数组选择连续 $ \mathit{M} $ 个，也就是最小化 $ a_{i+m-1}^{2}-a_{i}^{2} $.

证明如下：利用勾股定理 $ a^{2}=c^{2}-b^{2} $ ，固定斜边，让其中一条直角边和斜边从同一点出发开始旋转，当和斜边的差值越小时，另一条直角边的长度就越短。或者说，固定斜边 $ \mathit{c} $ 后，我们可以令其中一条直角边 $ \mathit{b} $ 与斜边的夹角为  $ \theta $ ，那么直接边 $ \mathit{b} $ 的值就为  $ \mathit{c \cos \theta } $ ,另一条直角边 $ \mathit{a} $ 的值就为  $ \mathit{c \sin \theta } $ ，我们的目标是让 $ \mathit{a} $ 尽可能地小，因此夹角 $ \theta $ 要尽可能小，随着 $ \theta $ 减小， $ \cos\theta $ 的值会增大，因此  $ \mathit{c-c \cos\theta } $ 的值会减小，即当固定的三角形的斜边和其中一条直角边长度的差值越小时，另一条直角边的长度越小。

因此我们可以对排序后的数组直接枚举全部连续的 $  \mathit{M} $ 个数，选出 $ a_{i+m-1}^{2}-a_{i}^{2} $  最小的即可。

时间复杂度： $ \mathit{O\left ( n \log n \right )} $ (排序)

参考代码：


```cpp
using i64=long long;

void mktx()
{
    int n,m;
    cin>>n>>m;
    vector<int>a(n+1);
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a.begin()+1,a.end());
    i64 res=1e18;
    for(int i=1;i+m-1<=n;i++) res=min(res,1ll*a[i+m-1]*a[i+m-1]-1ll*a[i]*a[i]);
    cout<<res;
}
```

---

## 作者：Untitled_unrevised (赞：7)

## 题意简述

从长度为 $N$ 的数组 $A$ 中挑选 $M$ 个元素排列，最小化

$$
L = \sum_{i = 1}^{M - 1} \left|B_{i+1}^2 - B_i^2 \right|
$$

输出 $L$ 即可。

## 题目分析

主要难点在证明上，做法实在是太简单了。

---

首先考虑 $N = M$ 的情况，从而只需考虑怎么排列无需考虑选什么。

**引理**：在长度为 $k$ 的正数序列中插入一个新的元素 $x$，$L$ 不减。

**证明**：插在两端恰好使 $L$ 增加了 $|x^2 - y^2| \ge 0$，无论两端的元素 $y$ 是什么。接下来考虑插在了两数 $a, b$ 之间的情形，此时这一小段变成了 $a, x, b$，记插入之后 $L$ 变为 $L'$。则

$$
\Delta L = L' - L = \big|x^2 - a^2\big| + \big|b^2 - x^2\big| - \big|b^2 - a^2\big|.
$$

由三角不等式 $|s + t| \le |s| + |t|$，有 $|s| + |t| - |s+t| \ge 0$。令 $s = x^2 - a^2$，$t = b^2 - x^2$，则 $s + t = b^2 - a^2$，便可得出 $\Delta L \ge 0$，从而 $L$ 不减。

**结论**：要么单调不增要么单调不减的排列 $B$ 可以使 $L$ 最小。

**证明**：记 $\min B$ 为 $B$ 中的最小值，$\max B$ 为 $B$ 中的最大值。那么根据引理，无论 $\max B$ 和 $\min B$ 在什么位置，都必有

$$
L \ge (\max B)^2 - (\min B)^2
$$

另一方面，将 $B$ 升序排列后：

$$
\min B = B_1 \le B_2 \le \dots \le B_M = \max B \\
\begin{aligned}
L &= \sum_{i = 1}^{M - 1}\big|B_{i+1}^2 - B_i^2 \big| \\
&= \sum_{i = 1}^{M - 1}\big(B_{i+1}^2 - B_i^2\big) \\
&= B_M^2 - B_1^2 \\
&= (\max B)^2 - (\min B)^2
\end{aligned}
$$

降序排列同理，从而我们得出 $L$ 可以 $\le (\max B)^2 - (\min B)^2$。两个限制合并起来，便知 $(\max B)^2 - (\min B)^2$ 是最小的 $L$。

---

接下来考虑 $M \le N$ 的情况。根据前文，我们已经知道了 $\min L$ 只取决于 $\max B$ 和 $\min B$；所以使 $L$ 尽可能小，要么让 $\max B$ 尽可能小，要么让 $\min B$ 尽可能大。

将 $A$ 升序排列后，枚举左端点 $l$，令右端点为 $r = l + M - 1$，选取 $A_{[l, r]}$ 这一段元素作为 $B$。此时有 $\min B = A_l$，$\max B = A_{r}$；显然有 $A_r \le A_{r+1} \le \dots$ 从而 $\max B$ 已经够小了，由于必须恰好选 $M$ 张画所以 $r$ 也不能再小了。只需对所有可能的 $l$ 都计算一次 $L$，选出最小的那个即可。

## 参考代码

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::vector;

using u64 = unsigned long long;

int main() {

	size_t n, m;
	cin >> n >> m;

	vector<u64> a(n);
	for(u64 &x : a) cin >> x;
	std::sort(a.begin(), a.end());

	u64 minimum = 1'000'000'000'000ull;
	for(size_t L = 0; L + m <= n; ++L) {
		size_t R = L + m - 1;
		minimum = std::min(minimum, a[R] * a[R] - a[L] * a[L]);
	}

	cout << minimum;
	return 0;
}
```

---

## 作者：AASDFGHJKL (赞：6)

# 题解：P12134 [蓝桥杯 2025 省 B] 画展布置
## 思路
这一道题直接枚举就可以了，但最重要的地方是关于 $L$ 的公式到底是什么，这个公式可以进行简化，而简化后就是 $L=|B_{m}^{2}-B_{1}^{2}|$，也就是 **$L$ 的绝对值即为首尾元素的平方差**。我们可以再使用排序优化，因为升序排列的平方差一定比无顺序排列的要小，更好求最小值。既然已经升序排列，就可以直接去掉绝对值符号，因为根据升序排列的性质前面的数一定比后面的小。最后对这一个区间进行计算出差值，判断那一个 $L$ 最小即可。
## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <climits>//这个用于写入LLONG_MAX
using namespace std;
int n, m;
int a[100010];
long long ans = LLONG_MAX;//求最小值用最大值
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n - m + 1; i++) {//i 都是每一个起点
        int j = i + m - 1;//这个是区间的终点的下标
        long long begin = (long long)a[i] * a[i]; //起点的平方
        long long end = (long long)a[j] * a[j];//终点的平方
        //使用 long long 防止乘积太大 
        ans = min(ans, end - begin);//判断是否最小
    }
    cout << ans << endl;//完结撒花
    return 0;
}
```

---

## 作者：Fertior_X (赞：1)

## 题目链接 [P12134](https://www.luogu.com.cn/problem/P12134)

## 题意
给出 $N$ 幅画的艺术价值 $A_1,A_2,…,A_N$，选取并排列其中 $M$ 幅画，其艺术价值分别为 $B_1,B_2,…,B_M$ ，已知 $L=\sum\limits_{i=1}^{M-1}\lvert B_{i+1}^2-B_i^2\rvert$，求 $L_{min}$。

## 思路
考虑贪心策略。

1. 如果 $B$ 数组**升序**，那么有 $B_{i+1}\geq B_i\geq 1$，则 $B_{i+1}^2\geq B_i^2$，$\therefore B_{i+1}^2-B_i^2\geq 0$，$\therefore\lvert B_{i+1}^2-B_i^2|=B_{i+1}^2-B_i^2$，$\therefore L=\sum\limits_{i=1}^{M-1}\lvert B_{i+1}^2-B_i^2 \rvert=B_M^2-B_{M-1}^2+B_{M-1}^2-B_{M-2}^2+…+B_3^2-B_2^2+B_2^2-B_1^2=B_M^2-B_1^2$。
2. 如果 $B$ 数组**不升序**，则此时 $L$ 一定没有取得最小值，以下为证明：由三角不等式 $\lvert a-b\rvert\geq\lvert a\rvert-\lvert b\rvert$，得 $L=\lvert B_M^2-B_{M-1}^2\rvert+\lvert B_{M-1}^2-B_{M-2}^2\rvert+...+\lvert B_3^2-B_2^2\rvert+\lvert B_2^2-B_1^2\rvert\geq\lvert B_M^2\rvert-\lvert B_{M-1}^2\rvert+\lvert B_{M-1}^2\rvert-\lvert B_{M-2}^2\rvert+…+\lvert B_3^2\rvert-\lvert B_2^2\rvert+\lvert B_2^2\rvert-\lvert B_1^2\rvert=B_M^2-B_1^2$，当且仅当 $B$ 数组升序时取得最小值。
3. 考虑好了 $B$ 数组如何排列，我们来考虑如何从 $A$ 数组中选取需要的元素。由于 $A$ 数组的排列对 $B$ 数组的排列没有影响，我们只考虑 $A$ 数组升序的情况。很显然，要使 $L$ 最小，$B$ 数组中相邻两个数的差应当尽可能小，反映到 $A$ 数组中就说明应当选取连续的 $M$ 个数作为 $B$ 数组，否则必然不会更优

根据上文，我们可以总结出如下解题步骤：  
1. 将 $A$ 数组排序
2. 遍历 $A$ 数组，找到使 $A_{i+M-1}^2-A_i^2$ 最小的 $i$
3. $A_{i+M-1}^2-A_i^2$ 即为答案


## 代码
```c++
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;

const int N = 1e5+13;
ull n, m, a[N], L = 1e18;

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n - m + 1; i++) {
        L = min(L, a[i + m - 1] * a[i + m - 1] - a[i] * a[i]);
    }
    cout << L;
    return 0;
}
```
- ### 时间复杂度：$O(n \log n)$（因为使用了缺省排序）
- ### 空间复杂度：$O(n)$ 

## [AC记录](https://www.luogu.com.cn/record/225301005)

---

## 作者：dashabi35 (赞：1)

## 绝对值不等式的应用

这是一个典型的绝对值不等式： $|a+b|\le|a|+|b|$ ，十分得好理解。

那么就有：

$$\sum_{i=1}^{M-1}|B_{i+1}^2-B_i^2|\ge|B_{M}^2-B_1^2|\ge  B_{M}^2-B_1^2$$ 

取等条件为：

$$B_M\ge B_{M-1}\ge……\ge B_2\ge B_1$$

那这条式子能让我们想到**排序**。

同时，贪心的想，肯定只有两个相邻的画之间价值差越小， $L$ 才会更小。

所以再使用 $O(n\log n)$ 的排序（选择排序、冒泡排序、插入排序会 TLE 的）。

排序完之后，只要找一个长度为 $m$ 的区间的收尾平方的差的最小值。

理论存在，实践开始：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define min(a,b) a<b?a:b//手搓的会快一点 
const int maxn=1e5+5;
int n,m,a[maxn],ans=9e18;
int sqr(int a)
{
	return a*a;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1);//排序就用 sort 又快又方便 
	for(int i=1,j=m;j<=n;++i,++j)//枚举区间 
	{
		ans=min(ans,sqr(a[j])-sqr(a[i]));//决策 
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：lijingshu_304775 (赞：0)

## 分析

### 题意
我们需要从 $N$ 幅画中挑选 $M$ 幅，按一定顺序排列，使得相邻画作艺术价值平方差的绝对值之和 $L$ 最小。其中 $L$ 的定义为：

$$L=\sum_{i=1}^{M-1} |B_{i+1}^2 - B_i^2|$$

目标是找到这个最小的 $L$ 值。

### 思路

观察 $L$ 的表达式，由于绝对值内是平方差，当我们将挑选的画作按平方值排序后，$B_{i+1}^2 \geq B_i^2$，此时 $|B_{i+1}^2 - B_i^2| = B_{i+1}^2 - B_i^2$，$L$ 可简化为相邻元素平方差的总和。

排序后的平方值数组中，连续元素的差值总和最小。也就是说，从排序后的平方值数组中，找长度为 $M$ 的连续子数组，使相邻元素差值之和最小。

先计算第一个长度为 $M$ 的窗口的差值和，再通过滑动窗口更新（减去离开窗口的差值，加上进入窗口的新差值），找到最小值。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long//一定要开 long long，虽然这么写不是那么优雅
using namespace std;
int s[100005];//平方数组
signed main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
        s[i] = a * a;//艺术价值的平方
    }
    sort(s, s + n);
    int ans = 0;
    for (int i = 0; i < m - 1; i++) {
        ans += s[i + 1] - s[i];
    }
    //滑动窗口
    int cur = ans;
    for (int i = 1; i <= n - m; i++) {
        cur = cur - (s[i] - s[i - 1]) + (s[i + m - 1] - s[i + m - 2]);
        ans = min(cur, ans);
    }
    cout << ans;
    return 0;
}
```

---


# [蓝桥杯 2025 省 A] 抽奖

## 题目背景

本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。

## 题目描述

LQ 商场为了回馈广大用户，为在此消费的用户提供了抽奖机会：抽奖机有三个转轮，每个转轮上都分布有 $n$ 个数字图案，标号为 $1 \sim n$，按照从 $1$ 到 $n$ 顺序转动，当转到第 $n$ 个图案时会从第一个继续开始。奖项如下：  
1. 三个相同的图案，积分 $+200$；  
2. 两个相同的图案，积分 $+100$；  
3. 三个数字图案，从左到右连续（例如 $1, 2, 3$），积分 $+200$；  
4. 三个数字图案，经过顺序调整后连续（例如 $2, 1, 3$ 或 $3, 2, 1$），积分 $+100$；  

抽奖机处于初始状态，三个转轮都处于第一个位置。每次开始抽奖，都会产生三个对应的随机数 $x_{i1}, x_{i2}, x_{i3}$，表示第 $j$ 个转轮会向后转动 $x_{ij}$ 次停下。下次抽奖时，转轮会从上一次转动后的位置开始继续转动。  

注意，一次抽奖最多只能获得一次积分，如果同时命中多个奖项，以积分最大的那个奖项为准。  

请问，如果执行 $m$ 次抽奖，总积分值是多少？  

## 说明/提示

### 样例说明

- 第一次抽奖：三个转轮都转动 $4$ 次，到达位置 $1$，数字图案为 $3, 2, 4$，积分 $+100$；  
- 第二次抽奖：数字图案为 $1, 2, 3$，积分 $+200$；  
- 第三次抽奖：数字图案为 $1, 2, 9$，积分不增加。  

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \le n\le 5$，$0\le m \le 5$；
- 对于 $40\%$ 的评测用例，$1\le n\le 10$，$0\le m\le 10$；
- 对于 $60\%$ 的评测用例，$1\le n\le 100$，$0\le m\le 100$；
- 对于 $80\%$ 的评测用例，$1\le n\le 200$，$0\le m\le 200$；
- 对于所有评测用例，$1 \leq n \leq 10^3$，$0 \leq m \leq 10^3$，$0 \leq a_i, b_i, c_i \leq 9$，$1 \leq x_{ij} \leq 1000$。


## 样例 #1

### 输入

```
4
3 2 4 1
2 2 2 2
4 3 0 9
3
4 4 4
3 1 1
40 39 2```

### 输出

```
300```

# 题解

## 作者：EndeavourCHN (赞：5)

审核辛苦了喵~

蒟蒻的第一篇题解！

[题目传送门](https://www.luogu.com.cn/problem/P12140)

## 思路

题意表述很清晰了，一共有 $4$ 种中奖情况，由于数据量不大，直接每种情况枚举检测即可。


注意到一次抽奖最多只能获得一次积分，如果同时命中多个奖项，以积分最大的那个奖项为准。于是优先判断 $200$ 分的情况，如果 $200$ 分没中奖再判断 $100$ 分的。


## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int A = 1, B = 1, C = 1, pts; //记录当前三个转盘的图案，以及累计积分
int n, a[1024], b[1024], c[1024]; //记录三个转盘上的所有图案
int m, x1[1024], x2[1024], x3[1024]; //记录每次转动转过了几个图案

//对应题干第一种中奖情况
bool check1 (int p, int q, int r){
	if (p == q && q == r) return true;
	return false;
}

//对应题干第三种中奖情况
bool check2 (int p, int q, int r){
	if (q == p + 1 && r == q + 1) return true;
	return false;
}

//对应题干第二种中奖情况
bool check3 (int p, int q, int r){
	if (p == q || q == r || p == r) return true;
	return false;
}

//对应题干第四种中奖情况
bool check4 (int p, int q, int r){
	if(q == p + 1 && r == q + 1) return true;
	if(r == p + 1 && q == r + 1) return true;
	if(p == q + 1 && r == p + 1) return true;
	if(r == q + 1 && p == r + 1) return true;
	if(p == r + 1 && q == p + 1) return true;
	if(q == r + 1 && p == q + 1) return true;
	return false;
}

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}
	for(int i = 1; i <= n; i++){
		cin >> b[i];
	}
	for(int i = 1; i <= n; i++){
		cin >> c[i];
	}
	cin >> m;
	for (int i = 1; i <= m; i++){
		cin >> x1[i] >> x2[i] >> x3[i];
	}
	for (int i = 1; i <= m; i++){
		A += x1[i];
		B += x2[i];
		C += x3[i];
		A %= n;
		B %= n;
		C %= n; //考虑到转盘转过的角度可能超过一圈，避免溢出
        if (A == 0) A = n;
        if (B == 0) B = n;
        if (C == 0) C = n; //0索引为空，重新定向至n索引

        //依次判断各中奖情况
		if (check1(a[A], b[B], c[C])){
			pts += 200;
			continue;
		}
		else if (check2(a[A], b[B], c[C])){
			pts += 200;
			continue;
		}
		else if (check3(a[A], b[B], c[C])){
			pts += 100;
			continue;
		}
		else if (check4(a[A], b[B], c[C])){
			pts += 100;
			continue;
		}
	}
	cout << pts; //输出答案
	
	return 0;
}
```

---

## 作者：FISH酱 (赞：3)

## 前置知识

你需要了解基础语法知识，建议先做一下模拟类的题目。

## 思路讲解

纯模拟即可，并没有很大难度，这里主要讲细节。

由于后续需要取模防止溢出，所以读入转轮图案时下标从 $0$ 开始更方便，避免了麻烦。

如果同时命中多个奖项，以积分最大的那个奖项为准，我们可通过调整检查奖项的顺序实现，按照分数从大到小排序后得知，第一种和第三种奖项要放在前面，第二种和第四种奖项要放在后面，一旦有满足的奖项就不再继续检查。

第四种奖项的判断，我们可以先对数字图案排序，再检查连续性。

## 代码展示

按照题意模拟，处理好细节就能拿满分，下面是我的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
#define endl '\n'

int n,m,cnt; // 每个转轮图案个数、抽奖次数、得分
int one,two,three; // 当前每个转轮的位置
int a[10000]; // 第一个转轮的图案
int b[10000]; // 第二个转轮的图案
int c[10000]; // 第三个转轮的图案

struct man{
	int x,y,z; // 每次抽奖的每个转轮的转动次数
};
man q[10000]; // 存储转动情况

bool s1(){ // 奖项一
	if(a[one]==b[two] && b[two]==c[three]){ // 全部相等
		cnt+=200; // 加分
		return 1; // 返回，奖项匹配
	}
	return 0; // 返回，奖项不匹配
}

bool s2(){ // 奖项二
	if(a[one]==b[two] || b[two]==c[three] || a[one]==c[three]){ // 有任意两个相等
		cnt+=100; // 加分
		return 1; // 返回，奖项匹配
	}
	return 0; // 返回，奖项不匹配
}

bool s3(){ // 奖项三
	if(a[one]+1==b[two] && b[two]+1==c[three]){ // 数字递增且连续
		cnt+=200; // 加分
		return 1; // 返回，奖项匹配
	}
	return 0; // 返回，奖项不匹配
}

bool s4(){ // 奖项四
	int ls[3]={a[one],b[two],c[three]}; // 数字存储
	sort(ls,ls+3); // 数字排序
	if(ls[0]+1==ls[1] && ls[1]+1==ls[2]){ // 判断排序后是否连续
		cnt+=100; // 加分
		return 1; // 返回，奖项匹配
	}
	return 0; // 返回，奖项不匹配
}

int main(){
	cin >> n; // 读入每个转轮图案个数
	for(int i=0;i<n;i++) cin>>a[i]; // 读入第一个转轮的数据
	for(int i=0;i<n;i++) cin>>b[i]; // 读入第二个转轮的数据
	for(int i=0;i<n;i++) cin>>c[i]; // 读入第三个转轮的数据
	cin >> m; // 读入抽奖次数
	for(int i=1;i<=m;i++) cin>>q[i].x>>q[i].y>>q[i].z; // 读入转动数据
	
	for(int i=1;i<=m;i++){ // 模拟每次抽奖
		one+=q[i].x,one%=n; // 第一个转轮转动，记得取模防止溢出，即处理转动多圈的情况
		two+=q[i].y,two%=n; // 第二个转轮转动，同上
		three+=q[i].z,three%=n; // 第三个转轮转动，一样的
		
		// 按照分数大小顺序检查，如何匹配就不继续检查，进入下一轮抽奖
		if(s1()) continue; // 奖项一
		if(s3()) continue; // 奖项三
		if(s2()) continue; // 奖项二
		if(s4()) continue; // 奖项四
	}
	
	cout << cnt; // 输出得分

    return 0; // 完结撒花！
}
```

---

## 作者：wenqinghua1001 (赞：2)

## 思路

拿到题目，二话不说，直接暴力。

设 $s_1$，$s_2$，$s_3$ 分别为第一、二、三个转轮开始转的位置，并都初始赋值为 $1$。对于第 $i$ 轮，将 $s_1=(x_{i1}+s_1) \bmod n$，$s_2=(x_{i2}+s_2) \bmod n$，$s_3=(x_{i3}+s_3) \bmod n$。

以下四个奖励选择一个**最高的加分**。

### 三个相同的图案

如果满足 $s_1=s_2=s_3$ 这个条件，那么 $ans=ans+200$。

```cpp
if(s1==s2&&s2==s3) return 200;
```

### 两个相同的图案

如果满足 $s_1=s_2$ 或 $s_2=s_3$ 或 $s_1=s_3$，那么 $ans=ans+100$。

```cpp
if(s1==s2||s2==s3||s1==s3) return 100;
```

### 三个数字图案连续

如果满足 $s_1+1=s_2$ 且 $s_2+1=s_3$，那么 $ans=ans+200$。

### 三个数字图案顺序调整后连续

如果将 $s_1$，$s_2$，$s_3$ 从小到大排序后满足 $s_1+1=s_2$ 且 $s_2+1=s_3$，那么 $ans=ans+100$。

## 重点代码

```cpp
int fen(int x,int y,int z){
	if(x==y&&y==z) return 200;
	if(x+1==y&&y+1==z) return 200;
	if(x==y||y==z||x==z) return 100;
	int xx=x,yy=y,zz=z;
	if(xx>yy) swap(xx,yy);
	if(yy>zz) swap(yy,zz);
	if(xx>yy) swap(xx,yy);
	if(xx+1==yy&&yy+1==zz) return 100;
	return 0;
}
```

---

## 作者：Peruere_Arlecchino (赞：2)

### 题目分析
本题的核心在于模拟抽奖的过程。每次抽奖时，三个转轮会转动一定的步数，我们需要确定每次转动后三个转轮最终所指向的数字，然后依据给定的积分规则算出本次抽奖的积分，最后把 $m$ 次抽奖得到的积分累加起来，就得到了总积分。
### 解题思路
整体的解题思路是先读取三个转轮上的数字图案，再进行 $m$ 次抽奖的模拟。每次抽奖时，更新转轮的位置，获取对应数字，根据积分规则计算积分。
### 个人代码
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

// 判断三个数字是否都相同
bool a(int b,int c,int d){
    return b==c&&c==d;
}

// 判断是否有两个数字相同
bool b(int c,int d,int e){
    return c==d||c==e||d==e;
}

// 判断三个数字是否从左到右连续
bool c(int d,int e,int f){
    return d+1==e&&e+1==f;
}

// 判断三个数字经过排序后是否连续
bool d(int e,int f,int g){
    vector<int> h={e,f,g};
    sort(h.begin(),h.end());
    return h[0]+1==h[1]&&h[1]+1==h[2];
}

// 计算单次抽奖的积分
int e(int f,int g,int h){
    if(a(f,g,h)) return 200;
    if(c(f,g,h)) return 200;
    if(b(f,g,h)) return 100;
    if(d(f,g,h)) return 100;
    return 0;
}

int main(){
    int n;
    cin>>n;
    // 存储三个转轮上的数字图案
    vector<int> w1(n),w2(n),w3(n);
    // 读取第一个转轮的数字图案
    for(int i=0;i<n;i++) cin>>w1[i];
    // 读取第二个转轮的数字图案
    for(int i=0;i<n;i++) cin>>w2[i];
    // 读取第三个转轮的数字图案
    for(int i=0;i<n;i++) cin>>w3[i];
    int m;
    cin>>m;
    // 记录三个转轮的当前位置
    int p1=0,p2=0,p3=0;
    // 记录总积分
    int s=0;
    for(int i=0;i<m;i++){
        int x1,x2,x3;
        cin>>x1>>x2>>x3;
        // 更新三个转轮的位置
        p1=(p1+x1)%n;
        p2=(p2+x2)%n;
        p3=(p3+x3)%n;
        // 获取当前三个转轮对应的数字
        int n1=w1[p1],n2=w2[p2],n3=w3[p3];
        // 计算本次抽奖的积分并累加到总积分中
        s+=e(n1,n2,n3);
    }
    cout<<s<<endl; // 输出
    return 0;
}
``` 
### 代码解释
首先读取转轮的大小 $n$，接着读取三个转轮上的数字图案并分别存储在 $w1$、$w2$ 和 $w3$ 这三个 $vector $中。

然后读取抽奖的次数 $m$，并初始化三个转轮的当前位置 $p1$、$p2$、$p3$ 为 0，同时初始化总积分 $s$ 为 0。
进入 $m$ 次抽奖的循环，每次循环读取三个转轮要转动的步数 $x1$、$x2$、$x3$，更新转轮的位置（由于转轮是循环转动的，所以更新位置时要对 n 取模）。

获取当前三个转轮对应的数字 $n1$、$n2$、$n3$，调用 $e$ 函数计算本次抽奖的积分，并将其累加到总积分 $s$ 中。

最后输出总积分 $s$。

---

## 作者：Hongfr (赞：2)

本题是一道模拟题，比较繁琐的模拟题。题目数据给在 $1\le n \le 10^3$，$1\le m \le 10^3$，我们可以考虑 $O(n^2)$ 及以内的算法。

### 解目思路
本题中的 $a_1,a_2,a_3,…,a_n$ 我们可以使用**队列**进行储存与操作，因为本题是要模拟出 $1$ 个转盘，所需要 $1$ 个环形封闭的储存方式，我们使用队列能更加方便模拟。

共创建 $3$ 个队列 $A,B,C$ 进行模拟，第 $1$ 个难点就是转动圈数。以 $A$ 转盘为例，令转盘转动了 $p$ 圈，我们可以用以下代码进行模拟转动转盘。

```cpp
while (p--) //循环直至p为0。
{
  A.push(a.front());
  A.pop();
}
```

紧接着第 $2$ 个难点便是一系列的判断，我们可以使用 $3$ 个变量分别储存队首，也就是当前转盘上的图案。接着进行判断，例如 $3$ 个图案一样便是 $3$ 个变量相等……第 $4$ 条顺序调整后连续会难判断一些，我们可以先对这 $3$ 个数进行排序，再进行题意奖项的第 $3$ 条进行判断，具体代码如下：

```cpp
bool check(int a,int b,int c)//此处定义了一个布尔函数用来判断。
{
    //此处为冒泡排序思维。
    if (a>b)    swap(a,b);
    if (b>c)    swap(b,c);
    if (a>b)    swap(a,b);
    //三个连续数的判断。
    if (a==b-1 and b==c-1)  return true;
    return false;
}
```
这个函数如果为真，那么积分就可以加 $100$。


这是便本题的大概难点解析，我们将读入、模拟转盘、判断、积分增加、输出等串联起来，便是本题的正解，完整代码如下。

### 完整代码
```cpp
#include <iostream>//标准头。
#include <queue>//队列头。
using namespace std;
int n,input,m,x1,x2,x3,ans;//n,m,x1,x2,x3如题意，input用来暂存读入后传递给队首，ans用来统计积分。
queue<int> a,b,c;//三个队列分别表示a,b,c转盘的所有图案。
bool check(int a,int b,int c)//奖项第四条判断。
{
    if (a>b)    swap(a,b);
    if (b>c)    swap(b,c);
    if (a>b)    swap(a,b);
    if (a==b-1 and b==c-1)  return true;
    return false;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        cin>>input;
        a.push(input);
    }
    for (int i=1;i<=n;i++)
    {
        cin>>input;
        b.push(input);
    }
    for (int i=1;i<=n;i++)
    {
        cin>>input;
        c.push(input);
    }
    scanf("%d",&m);
    while (m--)
    {
        cin>>x1>>x2>>x3;
        while (x1--)
        {
            a.push(a.front());
            a.pop();
        }
        while (x2--)
        {
            b.push(b.front());
            b.pop();
        }
        while (x3--)
        {
            c.push(c.front());
            c.pop();
        }
        int aa=a.front(),bb=b.front(),cc=c.front();
        if (aa==bb and bb==cc and aa==cc)   ans+=200;//奖项第一条：三个图案判断。
        else if ((aa==bb and aa!=cc) or (aa==cc and aa!=bb) or (bb==cc and bb!=aa)) ans+=100;//奖项第二条：任意两个图案判断。
        else if (aa==bb-1 and bb==cc-1) ans+=200;//奖项第三条：三个连续图案判断。
        else if (check(aa,bb,cc))   ans+=100;//奖项第四条：调整顺序后三个连续图案判断
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_WCW_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12140)
## 题目大意

  这道题比较长，大致意思就是：
    给定 $3$ 组数，每组 $n$ 个数，移动 $m$ 轮，从第一个数开始向后移动，第 $j$ 组数每轮移动 $x_{ij}$ 次，移动到最后一个数之后回到第一个数，然后判断移动后的数是否符合条件。







## 解题思路

这道题可以用模拟，循环 $m$ 次，代表移动 $m$ 轮，模拟每次移动，对于移动多圈的情况可以用取余解决。








## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1010],b[1010],c[1010],ans,x1[1010],x2[1010],x3[1010],t[10],t1,t2,t3;//n个图案，m次抽奖，ans记录答案，t记录每一轮抽奖的图案，t1、t2、t3记录转盘数组下标
bool f=true;//标记变量
int main()
{
    cin>>n;//输入
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<n;i++) cin>>b[i];
    for(int i=0;i<n;i++) cin>>c[i];
    cin>>m;
    for(int i=1;i<=m;i++) cin>>x1[i]>>x2[i]>>x3[i];
    for(int i=1;i<=m;i++)
    {
        f=true;//重置标记变量
        t1=(x1[i]+t1)%n;//更新元素当前下标，用取余来解决移动多圈的情况
        t2=(x2[i]+t2)%n;
        t3=(x3[i]+t3)%n;
        t[1]=a[t1];//记录元素
        t[2]=b[t2];
        t[3]=c[t3];
        if(t[1]==t[2] && t[1]==t[3])//判断3个数是否相等
        {
            ans+=200;//满足第一个条件，加分
        }
        else if(t[1]==t[2] || (t[1]==t[3] || t[2]==t[3]))//有两个元素相同的情况判断
        {
            ans+=100;//满足第二个条件，加分
        }
        else if(t[1]+1==t[2] && t[2]+1==t[3])//判断是否连续
        {
            ans+=200;//满足第三个条件，加分
            f=false;//更改标记变量，防止和排序后结果重复相加
        }
        sort(t+1,t+4);//排序
        if(t[1]+1==t[2] && t[2]+1==t[3] && f)//排序后判断是否连续
        {
            ans+=100;//满足第四个条件，加分
        }
    }
    cout<<ans;//输出最后分数

    return 0;
}
```

---

## 作者：YYF_Maple_Leaves (赞：1)

## 题目描述
本题[题目传送门](https://www.luogu.com.cn/problem/P12140)

PS：本蒟蒻的第三篇题解。


本体可以看作一道小的模拟题，按照每次所转动转盘所得的三个数字存在 $5$ 种情况：

1. 三个数字相等，加 $300$ 分。
2. 其中两个数字相等，$200$ 分。
3. 三个数字连续，$300$ 分。
4. 经过换位后三个数字连续，$300$ 分。
5. 没有任何规律可言，不加分。

如果转动次数超过 $n$ 次，我们可以用取余的方法有效避免。
## AC代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int z1[1005],z2[1005],z3[1005],z[4];
long long ans=0;
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<n;j++)
	    {
		    if(i==0) cin>>z1[j];
		    else if(i==1) cin>>z2[j];
		    else cin>>z3[j];
	    }
	}
	int m;
	cin>>m;
	int l1=0,l2=0,l3=0;
	while(m--)
	{
		int x1,x2,x3;
		cin>>x1>>x2>>x3;
		int c1,c2,c3;
		c1=(x1+(l1%n))%n;
		c2=(x2+(l2%n))%n;
		c3=(x3+(l3%n))%n; 
		l1=c1;
		l2=c2;
		l3=c3;
		int a1=z1[c1];
		int a2=z2[c2];
		int a3=z3[c3];
		
		if(a3==a2+1 && a2==a1+1)
		{
			ans+=200;
		}
		else if(a3==a2 && a2==a1)
		{
			ans+=200;
		}
		else if(a3==a2 || a3==a1 || a2==a1)
		{
			ans+=100;
		}
		else
		{
			z[1]=a1;
			z[2]=a2;
			z[3]=a3;
			sort(z+1,z+3+1);
			if(z[3]==z[2]+1 && z[2]==z[1]+1)
		    {
			    ans+=100;
		    }
		}
	}
	cout<<ans<<endl;
	return 0;
 } 
```

---

## 作者：123ytq666 (赞：1)

水题，难度低，只要有耐心就可以通过，不知道咋评橙的。
不讲太多，直接进入正题。

## 题目简化描述

给出 $3$ 个长度为 $\tt n$ 的数列，每轮每个数列分别移动指定的次数，最后一个的下一个是 $1$，然后判断移动后得到的 $3$ 个数是否满足以下条件，并获得加分。
1. 三个相同的数字，积分 $+200$。
2. 两个相同的数字，积分 $+100$。
3. 三个数字，从左到右连续（**右到左不算！**），积分 $+200$。
4. 三个数字，排序后连续（例如 $2,1,3$ 或 $3,2,1$），积分 $+100$。

具体题目描述请[点击](https://www.luogu.com.cn/problem/P12140)查看。

## 题目重点/坑点

### “连续”的意思

“连续”的意思的意思是三个数字每个相差 $1$ 且都不相等，**不要当成从小到大！**

### 如何进行移动

移动的办法可以使用取余法。

```cpp
int x1,x2,x3;
cin>>x1>>x2>>x3;
now1=(now1+x1)%n;
now2=(now2+x2)%n;
now3=(now3+x3)%n;
//now1,now2,now3分别代表每个数列中抽中的数所在的位置
```

### 如何进行判断

#### 条件 1

直接判断 3 个数是否相等。

```cpp
if(z[1][now1]==z[2][now2]&&z[1][now1]==z[3][now3])jscore=200;
//jscore代表本轮加的分数
//z数组用来存储数列的
```

#### 条件 2

判断的条件有 3 种，要注意。


```cpp
else if(z[1][now1]==z[2][now2]||(z[1][now1]==z[3][now3]||z[2][now2]==z[3][now3]))jscore=100;
```

#### 条件 3 和条件 4

为什么要把条件 3 和条件 4 放一起？因为条件 3 和条件 4 几乎没有区别，只是条件 4 要进行一个排序，这里用一个函数表示。

##### 主函数：

```cpp
else if(lx(now1,now2,now3,0))jscore=200;
else if(lx(now1,now2,now3,1))jscore=100;
//第四个数是代表是否排序，0为不排序，1为排序
```

##### 判断函数


```cpp
bool lx(int a,int b,int c,bool px){
	int k[4];
	k[1]=z[1][a];k[2]=z[2][b];k[3]=z[3][c];
	if(px)sort(k+1,k+4);//sort是排序函数
	if(k[1]+1==k[2]&&k[2]+1==k[3])return true;
	else return false;
}
```

## 代码

~~早就知道你的目的是这个了~~


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int z[4][1005];
bool lx(int a,int b,int c,bool px){
	int k[4];
	k[1]=z[1][a];k[2]=z[2][b];k[3]=z[3][c];
	if(px){
		sort(k+1,k+4);
	}
	if(k[1]+1==k[2]&&k[2]+1==k[3])return true;
	else return false;
}
int main(){
	int n,m;
	cin>>n;
	for(int i=1;i<=3;i++){
		for(int j=0;j<n;j++){
			cin>>z[i][j];
		}
	}
	int score=0;
	cin>>m;
	int now1=0,now2=0,now3=0;
	for(int i=1;i<=m;i++){
		int x1,x2,x3;
		cin>>x1>>x2>>x3;
		now1=(now1+x1)%n;
		now2=(now2+x2)%n;
		now3=(now3+x3)%n;
		int jscore=0;
		if(z[1][now1]==z[2][now2]&&z[1][now1]==z[3][now3]){
			jscore=200;
		}
		else if(z[1][now1]==z[2][now2]||(z[1][now1]==z[3][now3]||z[2][now2]==z[3][now3])){
			jscore=100;
		}else if(lx(now1,now2,now3,0)){
			jscore=200;
		}else if(lx(now1,now2,now3,1)){
			jscore=100;
		}
		score+=jscore;
	}
	cout<<score;
	return 0;
}
```

---

## 作者：shenbairui (赞：0)

### 解题思路
转轮位置计算：每次抽奖后，转轮的位置需要更新。由于转轮是循环的，位置的计算需要对 $n$ 取模。

#### 积分规则判断：

三个数字相同：直接 $+200$；

两个数字相同：直接 $+100$；

#### 三个数字连续（顺序或调整顺序）：
判断是否为连续的数字组合；

#### 积分优先级：
如果同时满足多个条件，取最高分值。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[1005], b[1005], c[1005], d[4];
long long ans = 0;
int main() {
	int n;
	cin >> n;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < n; j++) {
			if (i == 0) cin >> a[j];
			else if (i == 1) cin >> b[j];
			else cin >> c[j];
		}
	}
	int m;
	cin >> m;
	int l1 = 0, l2 = 0, l3 = 0;
	while (m--) {
		int x1, x2, x3;
		cin >> x1 >> x2 >> x3;
		int ac, ac2, ac3;
		ac = (x1 + (l1 % n)) % n;
		ac2 = (x2 + (l2 % n)) % n;
		ac3 = (x3 + (l3 % n)) % n;
		l1 = ac;l2 = ac2;l3 = ac3;
		int a1 = a[ac];
		int a2 = b[ac2];
		int a3 = c[ac3];
		if (a3 == a2 + 1 && a2 == a1 + 1) ans += 200;
		else if (a3 == a2 && a2 == a1) ans += 200;
		else if (a3 == a2 || a3 == a1 || a2 == a1) ans += 100;
		else {
			d[1] = a1;
			d[2] = a2;
			d[3] = a3;
			sort(d + 1, d + 3 + 1);
			if (d[3] == d[2] + 1 && d[2] == d[1] + 1) {
				ans += 100;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```
下期见！拜拜！

---

## 作者：luokc (赞：0)

# 题解：P12140 [蓝桥杯 2025 省 A] 抽奖
## 思路
- 首先读取转轮大小 $n$，以及三个转轮上的数字图案。接着读取抽奖次数 $m$，并在每次抽奖时读取三个转轮转动的次数。
    
- 使用 $p1$、$p2$、$p3$ 来记录三个转轮当前的位置，每次抽奖后更新这些位置，通过取模运算确保位置在 $0$ 到 $n - 1$ 之间。
  - 若有**三个数字相同**，则积分加 $200$。
  - 若有**两个数字相同**，则积分加 $100$。
  - 若是**连续数字**，就将三个数字排序，判断是否连续。若从左到右连续，则积分加 $200$；若经过排序后连续，则积分加 $100$。
- 最后输出总积分就行了。
## [AC Code](https://www.luogu.com.cn/record/214917888)
既然都写 C++ 那我就写一篇 Python 吧。

```python
n = int(input())
a, b, c = [list(map(int, input().split())) for _ in range(3)]
m = int(input())
p1 = p2 = p3 = s = 0
for _ in range(m):
    x1, x2, x3 = map(int, input().split())
    p1, p2, p3 = (p1 + x1) % n, (p2 + x2) % n, (p3 + x3) % n
    nums = [a[p1], b[p2], c[p3]]
    s1 = 200 if len(set(nums)) == 1 else 100 if len(set(nums)) == 2 else 0
    nums1 = sorted(nums)
    s2 = 200 if nums1 == nums and nums1[1] - nums1[0] == nums1[2] - nums1[1] == 1 else 100 if nums1[1] - nums1[0] == nums1[2] - nums1[1] == 1 else 0
    s += max(s1, s2)
print(s)
```
Python 竟然仅需 $13$ 行！！！

---

## 作者：snowQAQ (赞：0)

这是一道模拟题，思路如下：
首先我们用 $3$ 个变量 $k_1$，$k_2$，$k_3$ 来模拟转盘的位置。用二维数组 $a$ 来存贮 $3$ 个轮盘数据。

这里我们可以先设一个转盘 @ 表示轮盘转的位置：

```
0 1 2 3 4 //数组下标
0 1 1 4 5 //轮盘表示的数
@
```
每次转只要轮盘位置取模 $n$ 就能保证转到目标了。

但还有个问题，当转 $3$ 次时，$(1+3)\bmod 4=0$，但数组 $0$ 下标为 $0$ 处没有数字，我们就要再加一句特判，这样做太麻烦了。所以我们初始化时直接 $a_0=a_n$ 就可以了。
然后每次轮盘直接判断 $a_{1,k_1},a_{2,k_2},a_{3,k_3}$ 是否满足条件就行了。
### 代码

```c++
#include<iostream>
using namespace std;
int a[5][1005];
int check(int x,int y,int z)
{
	//判定方法1
	if(x==y&&y==z&&x==z)return 200;
	//判定方法2
	if(x==y||y==z||x==z)return 100;
	//判定方法3
	if(y==x+1&&z==y+1)return 200;
	//判定方法4
	int mx=max(x,max(y,z));
	int mn=min(x,min(y,z));
	int md=x+y+z-mx-mn;
	//mx,md,mn为最大值，中间值，最小值
	//mn,md,mx从小到大排序
	if(md==mn+1&&mx==md+1)return 100;
	return 0;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=3;i++)
	{
	    for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}	
		a[i][0]=a[i][n];//下面解释
	}
	//二维数组a[i][j](i<=3)表示第i个轮盘的第j位
	int m;
	cin>>m;
	int k1=1,k2=1,k3=1;//记录转到第几个数
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		int x1,x2,x3;
		cin>>x1>>x2>>x3;
		k1+=x1,k2+=x2,k3+=x3;
		k1%=n,k2%=n,k3%=n;
		//因为输入时a[i][0]==a[i][n]，所以不用特判mod后为0
		int a1=a[1][k1],a2=a[2][k2],a3=a[3][k3];
		ans+=check(a1,a2,a3);
	}
	cout<<ans;
}

---

## 作者：AASDFGHJKL (赞：0)

# P12140 [蓝桥杯 2025 省 A] 抽奖
## 思路
这是一道模拟的基础题，我们先获取每一次抽奖后的位置，然后获取当前位置的数，接着根据题目中的奖项进行加分，最后把下一次抽奖的初始位置更新一下。
### 注意
根据题意，当有多个条件相同时，**只能选择一个条件加分**，也就是要用 ```if``` 和 ```else if```，而不是使用多个 ```if``` 判断。并且根据题意我们的判断顺序应该是**将加分多的放在前面，加分少的放在最后**判断。
## 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,cnt;//cnt用来计数
int a[1010],b[1010],c[1010],maxn[4];//因为加分条件4是非正序但是调整后连续的数组
struct node{
	int x0,x2,x3;//x0是转盘一的转动次数；x2是转盘二的转动次数；x0是转盘三的转动次数。
}d[1010];
int ai=1,bi=1,ci=1;//这里是每一次三个棋盘各自的初始位置
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	cin>>m;
	for(int i=1;i<=m;i++) cin>>d[i].x0>>d[i].x2>>d[i].x3;//朴实无华的输入
	for(int i=1;i<=m;i++){
		int pos1=(ai+d[i].x0)%n;//因为输入的数可能超过n，所以要取模
		int pos2=(bi+d[i].x2)%n;
		int pos3=(ci+d[i].x3)%n;
		int n1,n2,n3;
		if(pos1==0){n1=a[n];pos1=n;}//当pos==0，表示是第n个数
		else n1=a[pos1];
		if(pos2==0){n2=b[n];pos2=n;}
		else n2=b[pos2];
		if(pos3==0){n3=c[n];pos3=n;}
		else n3=c[pos3];
		maxn[1]=n1;maxn[2]=n2;maxn[3]=n3;
		sort(maxn+1,maxn+4);//存入数字并且排序用于判断条件4
		if(n1==n2&&n2==n3) cnt+=200;//条件1
		else if(n1+1==n2&&n2+1==n3) cnt+=200;//条件3
		else if(n1==n2||n1==n3||n2==n3) cnt+=100;//条件2
		else if(maxn[1]+1==maxn[2]&&maxn[2]+1==maxn[3]) cnt+=100;//条件4
      //遵循命中多次积分只选择最多的积分增加的规则
		ai=pos1;bi=pos2;ci=pos3;//更新新的初始位置
	}
	cout<<cnt<<endl;//完美输出
	return 0;
}

```
## **End**
求管理员给通过QAQ！

---


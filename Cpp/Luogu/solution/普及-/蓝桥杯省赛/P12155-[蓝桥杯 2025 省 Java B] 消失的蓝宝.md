# [蓝桥杯 2025 省 Java B] 消失的蓝宝

## 题目描述

“蓝宝又不见了！” 2025 年 4 月 12 日，蓝桥杯吉祥物 “蓝宝” 在省赛前夕突然失踪。小蓝翻阅了蓝宝的活动记录，发现它的出现时间似乎与蓝桥杯的两个重要日期密切相关：
- 第十六届省赛日期 $20250412$。
- 第十五届省赛日期 $20240413$。

经过分析，小蓝推测蓝宝的下一次出现时间 $N$ 满足以下条件：

1. $N + 20250412$ 能被 $20240413$ 整除。
2. $N + 20240413$ 能被 $20250412$ 整除。

现在，请你帮小蓝找出满足条件的最小正整数 $N$，预测蓝宝的下一次出现时间。

# 题解

## 作者：MingDynasty (赞：7)

[题目链接](https://www.luogu.com.cn)

提供一种不同的思路。

## 题目思路：

我们发现其实题目中给我们的两个数 $(20250412,20240413)=1$，$[20250412,20240413]=20250412 \times 20240413$。于是，同时满足 $(N + 20250412) \mid 20240413$ 和 $(N + 20240413) \mid 20250412$ 的答案 $N$ 就是 $[20250412,20240413]-20250412-20240413$，这样得到的答案 $N$ 满足题目给我们的要求。输出即可。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cout<<20240413ll*20250412-20250412-20240413;
	return 0;
}
```

祝大家通过本题！

---

## 作者：ssxzhang (赞：6)

原式等于： 
$\begin{cases}
  n + 20250412 \equiv 0 \pmod{20240413}\\
  n + 20240413 \equiv 0 \pmod{20250412}\\
\end{cases}$ 

将$20250412$和$20240413$移项得： 
$\begin{cases}
  n \equiv -20250412 \pmod{20240413}\\
  n \equiv -20240413 \pmod{20250412}\\
\end{cases}$ 

又能得：

$\begin{cases}
  n = -20250412+a \times20240413\\
  n = -20240413+b \times20250412\\
\end{cases}$ 

再得： 
$-20240413+b \times20250412 = -20250412+a \times20240413\\$ 

接着移项： $(b+1) \times20250412 = (a+1) \times20240413\\$ 

由于 $\gcd(20250412,20240413)=1$,所以 $\operatorname{lcm}(20250412,20240413)=20250412 \times20240413$。

最后 $(b+1) \times20250412 =20250412 \times20240413\\$,左右同除 $20250412$ 得 $b=20240412$ ,带回原式即可得答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<1ll*20250412*20240412-1ll*20240413;
    return 0;
}
```

---

## 作者：tengteng666666 (赞：4)

### 思路：
暴力把一个一个枚举 $n$ 肯定超时。我们仔细观察这道题，发现 $n$ 减去 $20250412$ 一定是 $20240413$ 的倍数。接下来就很好办了，我们只需要枚举所有 $20240413$ 的倍数，然后再让它减去 $20250412$ 去判断第二个条件即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
	for(long long i = 20240413;;i+=20240413){//枚举20240413的倍数。 
		if(((i-20250412) + 20240413) % 20250412 == 0){//判断第二个条件。 
			cout<<i-20250412;
			break;
		}
	}
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：3)

题目的限制可以转化为解这样一个同余方程组：

$$
\begin{cases}
N \equiv -20250412 \pmod{20240413} \\
N \equiv -20240413 \pmod{20250412}
\end{cases}
$$

注意到 $\gcd(20240413, 20250412)=1$，因而可以用中国剩余定理（CRT）解决。

我们需要找到 $N$ 满足：

$$
\begin{cases}
N \equiv a_1 \pmod{m_1} \\
N \equiv a_2 \pmod{m_2}
\end{cases}
$$

其中：

$$
a_1 = -20250412 \quad m_1 = 20240413 \\
a_2 = -20240413 \quad m_2 = 20250412 \\
$$

解的形式为：

$$
N=a_1+k m_1
$$

代入第二个同余式：

$$
\begin{cases}
a_1+km_1 \equiv a_2 \pmod{m_1} \\
km_1 \equiv a_2-a_1 \pmod{m_2}
\end{cases}
$$

其中 $a_2-a_1=−20240413−(−20250412)=9999$，所以：

$$
20240413 k \equiv 9999 \pmod{20250412}
$$

又因为：

$$
20240413 \equiv -9999 \pmod{20250412}
$$

所以解得 $k \equiv -1 \pmod{20250412}$。

因此最小的正整数解 $k$ 是 $20250412-1=20250411$。

计算出 $N = a_1 +km_1=-20250412+20250411 \times 20240413 =409,876,661,809,331$。

---

## 作者：yanmingqian (赞：2)

当然可以直接枚举 $N$。但是这样过于暴力，而且手动调试枚举上下界限费时费力。

将原式化简，发现 $N$ 可以表示为 $i\times 20250412-20240413$ 或者 $i\times20240413-20250412$。其中 $i$ 可以枚举。这样我们枚举 $i$ 并依次验证即可。

代码（其中 `x` 即为题目中的 $N$）：

```cpp
#include<iostream>
using namespace std;
int main(){
    for(int i=1;i<=5e8;i++){
        long long x=i*20250412-20240413;
        if((x+20250412)%20240413==0){
            cout<<x;
            break;
        }
    }
    return 0;
}
```

---

## 作者：Peruere_Arlecchino (赞：1)

定义变量 $a$ 并初始化为 $1$，$a$ 用于表示一个整数乘数，我们从 $a = 1$ 开始尝试。

在 `while` 循环中，通过 $n = a * 20240413 - 20250412$ 计算出当前可能的 $N$ 值。

然后检查计算出的 $N$ 是否满足第二个条件 `(n + 20240413) % 20250412 == 0`，如果满足，则输出 $n$ 的值，这就是满足条件的最小正整数 $N$，并使用 `break` 语句跳出循环。

如果不满足条件，则将 $a$ 的值增加 $1$，继续尝试下一个 $a$ 值对应的 $N$。

最后返回 $0$ 表示程序正常结束。

### AC code:

``` cpp
#include<iostream>
using namespace std;

int main() {
    long long a = 1;
    while (true) {
        long long n = a * 20240413 - 20250412;
        if ((n + 20240413) % 20250412 == 0) {
            cout << n << endl;
            break;
        }
        a++;
    }
    return 0;
}
```

---

## 作者：Zdc0614 (赞：1)

苯蒟蒻的第一篇题解，希望审核大大通过。
根据题目条件我们得到所求
$$
N = k \times 20250412 - 20240413 = q \times 20240413 - 20250412
$$
（此处 $k$ 和 $q$ 是某个正整数）

移项可以得到
$$
(k + 1) \times 20250412 = (q + 1) \times 20240413
$$

根据辗转相除我们可以得到 $20250412$ 和 $20240413$ 互质，
则他们的最小公倍数则是他们的乘积，即
$$
(k + 1) \times 20250412 = 20250412 \times 20240413
$$

带回原式得最终题目答案
$$
20250412 \times 20240413 - 20250412 - 20240413 = 409876661809331
$$

---

## 作者：Zskioaert1106 (赞：1)

题目传送门：[P12155 [蓝桥杯 2025 省 Java B] 消失的蓝宝](https://www.luogu.com.cn/problem/P12155)

由第二条限制得出 $N$ 一定是 $20250412-20240413$ 再加上一个 $20250412$ 的倍数，因此可以枚举 $N$。将初值设为 $20250412-20240413$，每次增加 $20250412$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(long long x){
    return ((x+20250412)%20240413==0&&(x+20240413)%20250412==0);
}
int main(){
    long long n=20250412-20240413;
    while(!check(n))n+=20250412;
    cout<<n;
}
```

### Java


```java
public class Main{
    public static boolean check(long x){
        return ((x+20250412)%20240413==0&&(x+20240413)%20250412==0);
    }

    public static void main(String[] args){
        long n=20250412-20240413;
        while(!check(n))n+=20250412;
        System.out.println(n);
    }
}
```

[AC](https://www.luogu.com.cn/record/214767776)。

---

## 作者：Xiaonao_Dali (赞：1)

由题意可知，我们可以得出关系式：$①N = a  \times 20250412 - 20240413 = b \times 20240413 - 20250412$，其中 $a$ 与 $b$ 均为正整数。\
我们将他进行移项，我们即可得出关系式：$②(a+1) \times 20250412 = (b+1) \times 20240413$。\
根据辗转相除法，$20250412$ 与 $20240413$ 最大公约数是 $1$。\
那么他们两个的最大公约数是他们的乘积。也就是说，关系式 $②$ 中我们很容易得出 $a=20240412$ 并 $b=20250411$ ,我们也就可以从 $a$ 或 $b$ 的值带入 $①$ 关系式即可。
也就是 $20240412 \times 20250412 - 20240413 = 409876661809331$ 或者是 $20250411 \times 20240413 -20250412 = 409876661809331$。\
综上所述，最后的答案是 $409876661809331$。

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目不传送门](https://www.luogu.com.cn/problem/P12155)
## 题目分析
我一开始的想法是直接暴力。
```cpp
for(int i=1;;i++){
		if((i+20250412)%20240413==0&&(i+20240413)%20250412==0)
			return cout<<i,0;
	}
```
很显然，这题要用更高级的思维。

题目可以化为下面的方程组：
$$
\begin{cases}
N \equiv 20230414 \pmod{20240413} \\
N \equiv 20240413 \pmod{20250412}
\end{cases}
$$
移项可得：
$$
N = a \times 20250412 − 20240413 = b \times  20240413 − 20250412
$$
再得：
$$
(b + 1) \times 20250412 = (a + 1) \times 20240413
$$
由于 $20250412$ 和 $20240413$ 互质，所以两数的最小公倍数为 $20250412 \times 20240413$，即：
$$ 
(b + 1) \times 20250412 = 20250412 \times 20240413
$$
将其带入原式：
$$
20250412 \times 20240413 − 20250412 − 20240413
$$
答案为 $409876661809331$。

最后输出这一坨即可。
具体看下面：
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<409876661809331; //直接将式子算出
    return 0;
}
```

---

## 作者：dashabi35 (赞：0)

**居然是一道输出答案题！**

这样就可以不用考虑时间复杂度了！


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n;
	while((n+20250412)%20240413!=0||(n+20240413)%20250412!=0) ++n;
	printf("%lld",n);
	return 0;
}
```
好吧，貌似这个算法太暴力了（不过比赛的时候可以一直挂着）。

那么我们就可以进行一些理性分析。

因为 $20240413\mid(N+20250412)$ ，所以可以得到 $n=20240413i-20250412(i\in(\mathbb{Z}^{+}))$

这样就得到了新的代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n=20240413*2-20250412;
	while((n+20250412)%20240413!=0||(n+20240413)%20250412!=0) n+=20240413;
	printf("%lld",n);
	return 0;
}
```

不过好像还是太慢了（又挂了好久）。

那么看来暴力还是不太好（再优化就太复杂了），所以考虑使用数学中不定方程的知识。

已知 $n=20240413i-20250412$ ，同时，也能在推得另一条式子 $n=20250412j-20240413(i,j\in((\mathbb{Z}^{+}))$

联立两条式子：

$$20240413i-20250412=20250412j-20240413$$

移项得：
$$i=\frac{20250412(j+1)-20240413}{20240413}=\frac{20250412(j+1)}{20240413}-1$$

我们可以用辗转相除发现 $20250412$ 与 $20240413$ 互质。

所以得这个方程的最小整数解为 $j=20240412,i=20250411$

代入 $i$ 或 $j$ ，求得 $n=409876661809331$

小贴士：记得开 ```long long``` 。

---

## 作者：deng2013 (赞：0)

### 思路
  根据题目描述，我们可以列出两个关系式：

  1. $N+20250412=20240413 \times x$
  2. $N+20240413=20250412 \times y$
     
并可以得出一个等式：

$20240413 \times x-20250412=20250412 \times y-20240413$

根据等式的基本性质,两边都加 $(20250412+20240413)$，等式为：

$20240413 \times (x+1)=20250412 \times (y+1)$

可以得出 $x=20240413-1=20240412$ 且 $y=20250412-1=20250411$。

最后可以求出 $N=20240413 \times 20240412-20250412=409876661809331$。

直接输出即可
```cpp
printf("409876661809331");
```
谢谢观看！

---

## 作者：zhujiahao114514 (赞：0)

由题意得，$\begin{array}{l} 
  \left\{\begin{matrix} 
  n+20250412\equiv 0\pmod{20240413} \\
  n+20240413\equiv 0\pmod{20240412} \\
\end{matrix}\right.    
\end{array} $

接下来解同余方程组。

设 $n=20240413 \times x-20250412=20250412 \times y-20240413$。

接下来可以得到一个等式：$ 20240413 \times x-20250412=20250412 \times y-20240413$。

移项得：$20240413 \times (x+1)=20250412\times(y+1)$

容易看出，这两个数是互质的。所以当 $x=20250411，y=20240412$，原方程成立。

答案就很简单了。
$n=20250412 \times 20240413−20250412−20240413=409876661809331$

所以只要输出就可以了。

~~~
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<1ll*20250412*20240412-1ll*20240413;
    return 0;
}
~~~

---


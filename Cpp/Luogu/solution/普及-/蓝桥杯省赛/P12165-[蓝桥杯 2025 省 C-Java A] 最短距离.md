# [蓝桥杯 2025 省 C/Java A] 最短距离

## 题目描述

在一条一维的直线上，存在着 $n$ 台显示器和 $n$ 个电源插座。老师给小蓝布置了个任务：负责将每台显示器通过电源线与一个插座相连接（每个插座最多只能给一台显示器供电）；同时，老师希望所消耗的电源线的长度尽可能的少，请你帮小蓝计算下电源线的最小消耗长度为多少？

为了便于计算，你只需要考虑直线距离即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyof7ql0.png)

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 10$，$0 \leq x_i, y_i \leq 100$；
- 对于 $40\%$ 的评测用例，$1 \leq n \leq 100$，$0 \leq x_i, y_i \leq 10^3$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 1000$，$0 \leq x_i, y_i \leq 10^5$；
- 对于 $80\%$ 的评测用例，$1 \leq n \leq 10000$，$0 \leq x_i, y_i \leq 10^9$；
- 对于所有评测用例，$1 \leq n \leq 50000$，$0 \leq x_i, y_i \leq 10^9$。

## 样例 #1

### 输入

```
2
0
1
2
3```

### 输出

```
4```

# 题解

## 作者：Dicer_L (赞：5)

## solution

### 简述题意

给你 $n$ 个东西 $1$ 的位置，$n$ 个东西 $2$ 的位置，要求将它们一一配对，问最短总距离是多少。

### 思路

简单的贪心。

第 $i$ 个东西 $1$ 的位置为 $w_i$，第 $i$ 个东西 $2$ 的位置为 $ag_i$。

先将 $w$ 与 $ag$ 分别排序，再把 $w_i$ 与 $ag_i$ 之差的绝对值加到 $ans$ 中，进行 $n$ 次。

正确性的话，错位相配对，假设 $w_i$ 与 $ag_{i+1}$ 配对，距离为 $x_1$，$ag_i$ 与 $w_{i+1}$ 配对，距离为 $x_2$， 原按位配对为 $x_3$，$x_4$。如果 $x_3$ 小于 $x_1$，$x_4$ 小于 $x_2$，显然原来更优。如果一个更大一个更小，则相加之后和相等，结果不变。

### 注意点

按位配对需要排序。这道题数据小，可以放心排序。

$ans$ 的值偏大，需要开 longlong。Java 的同学没这个顾虑。

### 代码附上

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=50005;
#define int long long
int n,w[N],ag[N],ans;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>w[i];
	for(int i=1;i<=n;i++) cin>>ag[i];
	sort(w+1,w+1+n);
	sort(ag+1,ag+1+n);
	for(int i=1;i<=n;i++) ans+=abs(w[i]-ag[i]);
	cout<<ans;
}
```

```
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] w = new int[n + 1];
        int[] ag = new int[n + 1];
        for (int i = 1; i <= n; i++) w[i] = sc.nextInt();
        for (int i = 1; i <= n; i++) ag[i] = sc.nextInt();
        Arrays.sort(w, 1, n + 1);
        Arrays.sort(ag, 1, n + 1);
        long ans = 0;
        for (int i = 1; i <= n; i++) {
            ans += Math.abs(w[i] - ag[i]);
        }
        System.out.println(ans);
    }
}
```

---

## 作者：victory_huyuehao (赞：3)

~~新手的第一篇题解，请多多包涵！~~

 _更新： 2025 年 4 月 24 日，修改了 1 个错误，优化语言。_ 
# [洛谷P12165](https://www.luogu.com.cn/problem/P12165)

这是一道贪心，十分经典。
# 贪心思路
首先，对于输入的数据要升序排序，c++ 的 sort 函数就能解决。

通过观察，我们可以得出结论：第  $i$  个显示器与第  $i$  个插头连接时，距离最短。

**但是**，我们需要证明，可能会出现别的情况。

# 证明贪心

另一种情况：第  $1$  个显示器与第  $n$  个显示器连接，第 $2$ 与第  $n - 1$ 个连接……

这种情况有可能最优。

证明原来的思路很简单，举个反例。

假设  $A$  为显示器，$B$  为插头，$0$  为空间隔。

那么这种情况：
```
      A 0 B A A B 0 B
位置：0 1 2 3 4 5 6 7
```


按照第  $1$  个显示器与第  $n$  个显示器连接，第  $2$  个与第  $n - 1$ 个连接……可以得出充电线长度：

 $$|7-0|+|5-3|+|2-4|=11$$ 

按照第  $i$  个显示器与第  $i$  个 插头连接，则：

 $$|2-0|+|5-3|+|7-4|=7$$  

**很显然**，反例是错误的，贪心成立。

代码如下：

# C++代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[50010],b[50010];//定义，a为显示器位置，b为插头位置
long long cnt;//计数器
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i]);
	}//输入
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);//排序
	for(int i=1;i<=n;i++){
		cnt+=abs(b[i]-a[i]);
	}//计数
	printf("%lld",cnt);
	return 0;
}
```
谢谢观看！

---

## 作者：WiNdTunnel (赞：2)

## 主要内容
在一条一维的直线上，存在着 $n$ 台显示器和 $n$ 个电源插座，将每台显示器通过电源线与一个插座相连接（每个插座最多只能给一台显示器供电），计算电源线的**最小消耗长度**为多少？
## 思路
### 贪心策略  
就是**两两**将**最近的**第 $i$ 台显示器和**最近的**第 $i$ 个插座相连,也就是让第 $i$ 小的显示器连接第 $i$ 小的插座。   
那么证明一下：  
首先要将 $x$ 和 $y$ 位置**升序排序**，如刚开始给的图：
![](https://cdn.luogu.com.cn/upload/image_hosting/vyof7ql0.png)  
我们用 $X$ 代表显示器，$Y$代表插座，$0$ 为空。
```latex
X X Y Y
0 1 2 3
```  
排序之后就是 ：   
$X:[0,1]$。  
$Y:[2,3]$。  
$0$ (第一台显示器）连接 $2$（第一个插座）的消耗：$\mid$ $0-2$ $\mid$。  
$1$ (第二台显示器）连接 $3$（第二个插座）的消耗：$\mid$ $1-3$ $\mid$。  
$2+2=4$ ，与样例相同。  
再来列举一组：

```latex
X Y X 0 X 0 Y Y
0 1 2 3 4 5 6 7
```
排序后：  
$X:[0,2,4]$  
$Y:[1,6,7]$  
如果一个个去两两配对（ $1$ 和 $n$ , $2$ 和 $n-1$...）的话就是：
$\mid$ $0-7$ $\mid$ $+$ $\mid$ $2-6$ $\mid$ $+$ $\mid$ $4-1$ $\mid$ $=14$。  
而使用贪心的话：
$\mid$ $0-1$ $\mid$ $+$ $\mid$ $2-6$ $\mid$ $\mid$ $4-7$ $\mid$ $=8$。   
可以看出贪心更优。  
得出结论：**升序排序**后，将显示器与插头分别相减的**绝对值**相加就是电源线的**最小损耗**。  
好了，废话不多说，上代码。  
## code（C++）

```cpp
#include <bits/stdc++.h>//万能头。
using namespace std;
int main(){
    int n;//电脑和插头数。
    cin >> n;
    vector<int> x(n+1), y(n+1);//输入规模较大时，vector 更灵活。
    for(int i = 1; i <= n; i++){
      cin >> x[i];
    }
    for(int i = 1; i <= n; i++){
      cin >> y[i];
    }
    sort(x.begin() + 1, x.end());//排序x（升序）。
    sort(y.begin() + 1, y.end());//排序y（升序）。
    long long cnt = 0;
    for(int i = 1; i <= n; i++){
      cnt += abs(x[i] - y[i]);//加上第i条电源线的长度。
    }
    cout << cnt;
    return 0;
}
```
## code（Java）

```java
import java.util.Arrays;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 电脑和插头数
        int n = scanner.nextInt();
        int[] x = new int[n + 1];
        int[] y = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            x[i] = scanner.nextInt();
        }
        for (int i = 1; i <= n; i++) {
            y[i] = scanner.nextInt();
        }
        // 排序 x（升序）
        Arrays.sort(x, 1, n + 1);
        // 排序 y（升序）
        Arrays.sort(y, 1, n + 1);
        long cnt = 0;
        for (int i = 1; i <= n; i++) {
            // 加上第 i 条电源线的长度
            cnt += Math.abs(x[i] - y[i]);
        }
        System.out.println(cnt);
    }
}
```
谢谢观看！

---

## 作者：rainbow_MMM (赞：2)

## 分析
这题还蛮简单的，是典型贪心，我们边看图边分析：


![](https://cdn.luogu.com.cn/upload/image_hosting/vyof7ql0.png)

可以看到第一台电脑连着第一个插座，第二台电脑连着第二个插头，总长度为 $\left\vert 2-0\right\vert+\left\vert 3-1\right\vert=4$。

结论：先排序，第 $i$ 个电脑配第 $i$ 个插头。  
呃，要不证明一下：

其实，第 $1$ 个配第 $n$ 个，第 $2$ 个配第 $n-1$ 个·······

这种情况也有可能最优，但举个反例：

若下图字母 $A$ 表示电脑，$B$ 表示插头，$C$ 表示空。

```markdown
字母：A B C A B
位置：0 1 2 3 4
```
可以看到如果用第 $1$ 个配第 $n$ 个，第 $2$ 个配第 $n-1$ 个这种方法，答案是：
$$
    \left\vert 4-0\right\vert+\left\vert 1-3\right\vert=6
$$
而如果使用原先方法，得到：
$$
  \left\vert 1-0\right\vert+\left\vert 4-3\right\vert=2
$$
因此，原先方法更优。
## Code
献上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
//定义
int n;
int x[50005];
int y[50005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i];
	} for(int i=1;i<=n;i++){
		cin>>y[i];
	}
  //排序
	sort(x+1,x+1+n);
	sort(y+1,y+1+n);
	long long ans=0;
  //处理
	for(int i=1;i<=n;i++){
		ans+=abs(x[i]-y[i]);
	}
  //输出
	cout<<ans;
	return 0;//完结散花！！！
}
```

---

## 作者：LINYUHENG2 (赞：1)

## 思路
这是一道贪心问题。

通过观察样例，我们发现，最佳的策略就是将坐标第 $i$ 小的显示器与坐标第 $i$ 小的插座配对。通过坐标差的绝对值就可以求出每根电线的长度，累加起来，就得到了答案。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[50005],b[50005];
long long sum=0;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) scanf("%d",&b[i]);
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++){
        sum+=abs(a[i]-b[i]);
    }
    printf("%lld",sum);
    return 0;
}
```

---

## 作者：Flambler (赞：1)

# P12165 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/0pnn3m6f)~~ 打算把蓝桥杯的题（P12162~P12168）全写一篇题解，这是 T4 的题解。
### Step 1 思路 Idea
这题明显是一道贪心，具体怎么贪心，我们来分析一下贪心策略：

![](https://cdn.luogu.com.cn/upload/image_hosting/vyof7ql0.png)

上图是这题的样例，我们可以发现 $1$ 号显示器连的是 $1$ 号插座，$2$ 号显示器连的是 $2$ 号插座，所以我们可以将他们排序，并把 $1$ 号连 $1$ 号，$2$ 号连 $2$ 号。最后把配对的两个数相减，把差相加就是最终的答案。
### Step 2 代码 Code
贪心策略想了出来，代码就很好写了：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50010;
int a[N], b[N];
int main() {
	int n;
	ll ans=0;
	scanf("%d", &n);
	for(int i = 1;i<=n&&scanf("%d", a+i);i++);
	for(int i = 1;i<=n&&scanf("%d", b+i);i++);
	sort(a+1, a+n+1);  // 排序
	sort(b+1, b+n+1);
	for(int i = 1;i<=n;i++) {  // 贪心
		ans+=abs(a[i]-b[i]);
	}
	printf("%lld", ans);
	return 0;
}
```
[100 pts record](https://www.luogu.com.cn/record/213617727)

---

## 作者：deng2013 (赞：0)

## 思路
  如果想让电源线的消耗的长度最少，就让第 $i$ 小的显示器连接第 $i$ 小的插座。

### 样例解释
  排序后的 $x$ 是 $[0,1]$。
  
  排序后的 $y$ 是 $[2,3]$。

  第一个电源线连接第一个显示器和第一个插座，长度为：$|0-2|$。

  第二个电源线连接第二个显示器和第二个插座，长度为：$|1-3|$。

  $2+2=4$ 答案是对的。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    vector<int> x(n),y(n);
    for(int i=0;i<n;i++) cin>>x[i];
    for(int i=0;i<n;i++) cin>>y[i];
    sort(x.begin(),x.end());//排序x。
    sort(y.begin(),y.end());//排序y。
    long long ans=0;
    for(int i=0;i<n;i++) ans+=abs(x[i]-y[i]);//加上第i条电源线的长度。
    cout<<ans;
    return 0;
}
```
谢谢观看！

---

## 作者：xf20280111 (赞：0)

## 分析
很容易想到把显示器，插座坐标排序后对应位置坐标相减的绝对值求和。

但是该如何证明呢？
## 证明
使用数学归纳法证明。

这里就说一下证明的思路

首先设 $n = 2$，分类讨论就可以证明。

假设对于 $n = k$ 时命题成立。

对于 $n = k + 1$，将最大的 $x_{k + 1}$ 和 $y_{k + 1}$ 匹配，所以整体最优。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 50000 + 10;
int a[N],b[N];
long long sum = 0;
int main()
{
    int n;cin >> n;
    for (int i = 1;i <= n;i++) cin >> a[i];
    for (int i = 1;i <= n;i++) cin >> b[i];
    sort(a + 1,a + n + 1);
    sort(b + 1,b + n + 1);
    for (int i = 1;i <= n;i++){
        sum += abs(a[i] - b[i]);
    }
    cout << sum << "\n";
    return 0;
}
```

---

## 作者：fiee_Lina (赞：0)

# [P12165 [蓝桥杯 2025 省 C/Java A] 最短距离](https://www.luogu.com.cn/problem/P12165)

### 思路

很经典的贪心思路，我们只需要累加第 $i$ 小的显示器和插座距离。

排好序的数字按顺序相减时，差值会比较小；而反着相减时，大数减小数会产生更大的差值。

**有序配对的总距离一定不大于乱序配对**。

 ---
### Java Code

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        long[] x = new long[n];
        long[] y = new long[n];

        for (int i = 0; i < n; i++) {
            x[i] = sc.nextLong();
        }
        for (int i = 0; i < n; i++) {
            y[i] = sc.nextLong();
        }

        Arrays.sort(x);
        Arrays.sort(y);

        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += Math.abs(x[i] - y[i]);
        }

        System.out.println(sum);
        sc.close();
    }
}

```



 
### C++ Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+7;
int n,d;
int s[N];
int a[N];
int ans=0;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);

	cin>>n>>d;
	for(int i=1;i<=n;i++) cin>>s[i];
	memset(a,-0x3f3f3f3f,sizeof(a));
	for(int i=n;i>=1;i--) a[i]=max(a[i+1],s[i]);
	for(int i=2;i<=n;i++) ans+=a[i];
	cout<<ans;

	return 0;
}

```

---

## 作者：yanmingqian (赞：0)

贪心。

将显示器和插座都按坐标从小到大排序，然后一一对应：左边第一个显示器对应左边第一个插座，左边第二个显示器对应左边第二个插座，左边第三个显示器对应左边第三个插座……

考虑证明。实际上，当插座全部在显示器右边时，任意相连都没有问题。但是如果两者穿插，就会出现问题了。如果不按上面的方法一一对应来连接，数据线之间就会出现交叉的情况。举个例子：

对于下面这组样例：

```
2
1
4
3
2
```

显然位置 1 的显示器连接位置 2 的插座，位置 4 的显示器连接 位置 3 的插座是最优的。如果不这么连接，数据线在位置 2 到位置 3 这一段就会重合，这样显然是不优的。因此贪心策略是正确的，实际上我们应该是减少了数据线两两之间有所重合部分的长度，这种策略显然是对的。

写代码时要注意，上面已经说了数据线和插座会交叉出现，因此别忘了计算时取坐标相减的绝对值。

代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int x[50010],y[50010];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x[i];
    }
    for(int i=1;i<=n;i++){
        cin>>y[i];
    }
    sort(x+1,x+1+n);
    sort(y+1,y+1+n);
    long long ans=0;
    for(int i=1;i<=n;i++){
        ans+=abs(y[i]-x[i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Merlin_Meow (赞：0)

## Analysis

一个直观的贪心策略是将 $x$，$y$ 分别排序后按下标一一对应连接，考虑证明这为什么是对的。

我们使用邻项交换法：

设排序后两台显示器的坐标分别为 $x_1$，$x_2$，两个插座的坐标分别为 $y_1$，$y_2$。

按照策略排序后，显然此时电线长度为 $\left|x_1-y_1\right|+\left|x_2-y_2\right|$，如果交换 $y_1$ 和 $y_2$，那么电线长度就是 $\left|x_1-y_2\right|+\left|x_2-y_1\right|$。

对于两个式子的大小，这里贴出一张图片来直观地证明（绿色表示按策略连线，黄色表示交换后的连线）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohwq2tq2.png)

容易发现 $\left|x_1-y_1\right|+\left|x_2-y_2\right|\le\left|x_1-y_2\right|+\left|x_2-y_1\right|$，即交换后的电线长度不会更优，贪心策略正确。

于是只需要排序后依次计算即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define int long long

const int maxn = 50'000 + 10;

int n, x[maxn], y[maxn];

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n;i++)
        cin >> x[i];
    for (int i = 1; i <= n;i++)
        cin >> y[i];
    sort(x + 1, x + n + 1);
    sort(y + 1, y + n + 1);
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans += abs(x[i] - y[i]);
    cout << ans << endl;
    return 0;
}
```

---


# [蓝桥杯 2025 省 Python B] 最多次数

## 题目描述

小蓝有一个字符串 $s$，他特别喜欢由以下三个字符组成的单词：$\tt {l}, \tt{q}, \tt{b}$，任意顺序都可以，一共有 $6$ 种可能：$\tt{lqb}$、$\tt{lbq}$、$\tt{qlb}$、$\tt{qbl}$、$\tt{blq}$、$\tt{bql}$。

现在他想从 $s$ 中，尽可能切割出多个他喜欢的单词，请问最多能切割出多少个？单词指的是由若干个连续的字符组成的子字符串。

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq |s| \leq 10$；
- 对于 $40\%$ 的评测用例，$1 \leq |s| \leq 20$；
- 对于 $60\%$ 的评测用例，$1 \leq |s| \leq 100$；
- 对于 $70\%$ 的评测用例，$1 \leq |s| \leq 10^3$；
- 对于 $80\%$ 的评测用例，$1 \leq |s| \leq 10^4$；
- 对于所有评测用例，$1 \leq |s| \leq 10^5$，$s$ 中只包含小写字母。

## 样例 #1

### 输入

```
lqbblqblqlxqb```

### 输出

```
3```

# 题解

## 作者：SerenityWay (赞：4)

由于是切割字符串，故不存在重叠的情况。所以可以遍历字符串，每次检查连续的 $3$ 个字符是否构成一个有效单词。如果当前 $3$ 个字符是 `l`，`q`，`b` 的任意排列，则将总数加 $1$，并跳过这 $3$ 个字符避免重叠。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool judge(char a,char b,char c){
	return (a=='l'||a=='q'||a=='b')&&
	(b=='l'||b=='q'||b=='b')&&
	(c=='l'||c=='q'||c=='b')&&
	(a!=b&&a!=c&&b!=c);
}
int main(){
	string s;
	cin>>s;
	int cnt=0,l=s.size();
	for(int i=0;i<l-2;){
		if(judge(s[i],s[i+1],s[i+2]))
			cnt++,i+=3;
		else
			i++;
	}
	cout<<cnt<<"\n";
	return 0;
}
```
时间复杂度 $O(n)$，空间复杂度 $O(n)$。

---

## 作者：Dicer_L (赞：4)

## solution

### 简述题意

给出一个字符串，在里面一起找 `lqb`，`lbq`，`qlb`，`qbl`，`blq`，`bql` 出现的最多次数。

### 注意点和思路

因为是分割，所以不会出现重叠的情况。我们只需要遍历一遍，把每一位和之后的两位截出来一一对比就好了。当心数组越界。如果相同，记得要跳过第二，三位再继续判断。

c++ 用户之字符串截取可以用 substr 这个函数。

需要对比的数据较小，直接对比即可。

### 代码附上
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int f,ans;
signed main(){
	string s,w,k[6]={"lqb","lbq","qlb","qbl","blq","bql"};
	cin>>s;
	for(int i=0;i<s.length();i++){
		w=s.substr(i,3);
		f=0;
		for(int j=0;j<6;j++) if(w==k[j]) f=1;	
		if(f==1) i=i+2,ans++;	
	}
	cout<<ans;
}
```

```python
s = input().strip()
k = ["lqb", "lbq", "qlb", "qbl", "blq", "bql"]
n = len(s)
ans=0
i=0
while i < (n-2):
    sub = s[i:i+3]
    if sub in k:
        ans += 1
        i += 3
    else:
        i += 1
print(ans)
```

---

## 作者：XsIeEiKcEk (赞：2)

## 我的思路

记录 $s$ 的子串 $s_1(|s_1|=3)$ 中 `a` 到 `z` 分别是否出现，若 `l`、`q`、`b` 都出现了记录。

## CODE
```cpp
#include<iostream>
#include<cstring>
using namespace std;
bool check(string s){
    bool c[26]={false};
    for(int i=0;i<3;i++)c[s[i]-'a']=true;//记录各字符是否出现
    if(c[11]&&c[16]&&c[1])return 1;//即l,q,b是否出现
    return 0;
}
int main(){
    int ans=0;
    string s,t;
    cin>>s;
    for(int i=0;i<s.size()-2;i++){
        t="";
        for(int j=i;j<i+3;j++)t+=s[j];//同t=s.substr(i,3)
        if(check(t))i+=2,ans++;//记得i要加2
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：no_response (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P12173)
## 题目大意
小蓝有一个字符串 $s$，他想在这里面分割出他喜欢的单词。  
他喜欢的单词一共有 $6$ 种可能，分别为：  
`lqb`、`lbq`、`qlb`、`qbl`、`blq`、`bql`。
## 解题思路
### 检查函数部分
根据题意，每个单词长度为三。
组成条件如下：
- 每个字母皆为 `l`、`q`、`b` 中的一个。
- 每个字母不能重复，即各不相同。

所以检查函数为：
```cpp
bool check(int i) {
	char x = s[i], y = s[i + 1], z = s[i + 2];
	if ((x == 'l' || x == 'q' || x == 'b') && 
	        (y == 'l' || y == 'q' || y == 'b') &&
	        (z == 'l' || z == 'q' || z == 'b') &&
	        (x != y && x != z && y != z)) { 
		return 1;
	}
	return 0;
}
```
### 主函数部分
因为我们以的代码 $i$ 为首个字母， $i+1$ 和 $i+2$ 不能超出字符串 $s$ 长度。  
所以主函数条件为（设 $l$ 为字符串 $s$ 的长度）：  
`while (i < l - 2)`  

如果当前单词小蓝喜欢，答案加一，且下标加三，因为一个单词长度为三。  
反之，下标加一，检查下一个单词。  
主函数代码如下：
```cpp
int main() {
	cin >> s;
	int ans = 0, l = s.size(), i = 0;
	while (i < l - 2) {
		if (check(i) == 1) {
			ans++;
			i += 3;
		} else {
			i++;
		}
	}
	cout << ans;
	return 0;
}
```
## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
bool check(int i) {
	char x = s[i], y = s[i + 1], z = s[i + 2]; //三个字母
	if ((x == 'l' || x == 'q' || x == 'b') && //x 是否为 l,q,b 中的一个
	        (y == 'l' || y == 'q' || y == 'b') && //y 是否为 l,q,b 中的一个
	        (z == 'l' || z == 'q' || z == 'b') && //z 是否为 l,q,b 中的一个
	        (x != y && x != z && y != z)) { //x,y,z 是否互不相同
		return 1;
	}
	return 0;
}
int main() {
	cin >> s;
	int ans = 0, l = s.size(), i = 0;
	while (i < l - 2) { //因为到末尾了只要看倒数第三位，即 l-2
		if (check(i) == 1) {
			ans++;
			i += 3; //因为单词长度为 3
		} else {
			i++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：CCY20130127 (赞：1)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P12173)

本题考查字符串、函数判断和枚举。

## 题目思路：
这道题由于是切割字符串，故不存在重叠的情况，就可以放心地枚举。只要 $i$、$i+1$ 和 $i+2$ 符合题目中的 $6$ 种情况，我们的答案就要 $+1$，然后下标就要向右移 $2$ 位。

## 正解：
c++：

```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
string s;
int cnt;
bool f(char a,char b,char c){//判断是否合法
	if(a=='l'&&b=='q'&&c=='b') return true;//合法
	else if(a=='l'&&b=='b'&&c=='q') return true;//合法
	else if(a=='q'&&b=='l'&&c=='b') return true;//合法
	else if(a=='q'&&b=='b'&&c=='l') return true;//合法
	else if(a=='b'&&b=='l'&&c=='q') return true;//合法
	else if(a=='b'&&b=='q'&&c=='l') return true;//合法
	else return false;//不合法
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//加快运行速度
	cin>>s;//输入
	for(int i=0;i<s.size()-2;i++){//循环判断
		if(f(s[i],s[i+1],s[i+2])){//判断后3位是否合法
			cnt++;//答案加1
			i+=2;//跳过不必循环范围
		}
	}
	cout<<cnt<<"\n";//输出
	return 0;
	//完结撒花
}
```

python：

```python
s = input().strip()
k = ["lqb", "lbq", "qlb", "qbl", "blq", "bql"]
n = len(s)
ans=0
i=0
while i < (n-2):
    sub = s[i:i+3]
    if sub in k:
        ans += 1
        i += 3
    else:
        i += 1
print(ans)
```

---

## 作者：thr31825 (赞：1)

### P12173 题解

#### 思路

因为 $s$ 的长度比较小，所以可以考虑枚举。我采用的方法是枚举每一个 $s$ 中长度为 3 的子段的中点，判断它是否满足题目的要求，如果符合那么 $ans$ 加一并跳过这个子段，否则中点向后挪一位。

#### 代码

```
#include<bits/stdc++.h>
using namespace std;
bool vis[3];//下标0~2分别表示子段中是否出现过l,q,b
string s;
char c[3];//存储待检查子段
bool check()//检查是否符合题意
{
    for(int i=0;i<3;i++){
        if(c[i]=='l') vis[0]=1;
        else if(c[i]=='q') vis[1]=1;
        else if(c[i]=='b') vis[2]=1;
    }
    if(vis[0] and vis[1] and vis[2]) return true;//如果都出现过返回真
    else return false;
}
int main()
{
    cin>>s;
    int ans=0;
    for(int i=1;i<s.size()-1;i++){//因为枚举中点所以从0到s长度减1
        c[0]=s[i-1];c[1]=s[i];c[2]=s[i+1];
        if(check())
        {
            ans++;
            i+=2;//因为循环本身会挪一位，所以这里只需要挪两位
        }
        memset(vis,0,sizeof(vis));//每次清空vis
    }
    cout<<ans;
    return 0;
}
```

最后谢谢大家的观看。

---

## 作者：AASDFGHJKL (赞：0)

# P12173 [蓝桥杯 2025 省 Python B] 最多次数
## 思路
这是一道可以用枚举解决的题目，我们先将 $6$ 种单词形式存起来，接着获取从 $i$ 到 $i+2$ 的位置的字符串，然后**判断字符串是否是以上单词**，若满足，就**到达 $i+2$ 的位置继续判断**，然后 $ans+1$ 并且退出判断循环。
## 代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int ans;
string s,a[6]={"lqb","lbq","qlb","qbl","blq","bql"};//存入单词
int main(){
	cin>>s;
	int len=s.length();//获取字符串长度
	for(int i=0;i<len;i++){
		string sub=s.substr(i,3);//这个函数可以获取到 i 到 i+2 的三个字符
 		for(int j=0;j<6;j++){//判断
			if(sub==a[j]){//是其中一个单词时
				i+=2;//不判断中间的内容了
				ans++;
				break;//已经增加答案，不再判断，节约时间
			}
		}		
	}
	cout<<ans<<endl;//完美输出
	return 0;
}
```

---

## 作者：TheTrash (赞：0)

### 思路

由于 $|s|\le10^5$，所以可以循环找出每一个可能的单词，与给出的小蓝喜欢的单词比较。如果找出的单词是小蓝喜欢的单词那么答案加一并且清空 $s$ 中 $s_i$ 到 $s_{i+1}$ 这一段，防止重复使用。

### 代码

```cpp
#include<iostream>
using namespace std;
string s;
int ans;
int main(){
	cin>>s;
	for(int i=0;i<s.size();i++){
		string t="";
		for(int j=i;j<i+3;j++)
			t+=s[j];
		if(t=="lqb"||t=="lbq"||t=="qlb"||t=="qbl"||t=="blq"||t=="bql"){
			ans++;
			for(int j=i;j<i+3;j++) s[j]=' ';
		}
	}
	cout<<ans;
}
```

---

## 作者：zhujiahao114514 (赞：0)

因为给定字符串的长度较小，我们只要从当前位置开始判断，如果当前位置与后面两个字符构成的字符串是题面中六个中的一个就算一个，并且把下标向后移三位，反之，就向后移一位。

~~~c++
#include<bits/stdc++.h>
using namespace std;
bool check(char a,char b,char c)
{
	if((a=='l'||a=='q'||a=='b')&&(b=='l'||b=='q'||b=='b')&&(c=='l'||c=='q'||c=='b')&&(a!=b&&a!=c&&b!=c)) return 1;
    return 0;
}
int main()
{
	string s;
	cin>>s;
	int cnt=0,l=s.size();
	for(int i=0;i<l-2;)
    {
		if(judge(s[i],s[i+1],s[i+2])) cnt++,i+=3;
		else i++;
	}
	cout<<cnt<<"\n";
	return 0;
}
~~~

---

## 作者：deng2013 (赞：0)

## 思路
枚举 $s$ 的每个字符，作为首位，并往后取三位，判断是否是 ```lqb```、```lbq```、```qlb```、```qbl```、```blq```、```bql``` 其中的一个，如果**是的**，答案加 1，并跳过两个字符（第二位和第三位）。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    int n = s.size();
    vector<string> f = {"lqb", "lbq", "qlb", "qbl", "blq", "bql"};
    int ans = 0;

    for (int i = 0; i <= n - 3; i++) { 
        string s1 = s.substr(i, 3);//往后取三位。
        if (find(f.begin(), f.end(), s1) != f.end()) { //用find函数查找s1是否在f里出现过，也就是判断s1是不是lqb等字符串中的一个。
            ans++;
            i += 2;//跳过后面两个字符。
        }
    }

    cout << ans << endl;
    return 0;
}
```
谢谢观看！

---

## 作者：maomitgd (赞：0)

提供一种我在赛场时的思路，直接对字符串逐个枚举字符作为首位，判断其和后面两位字符构成的字符串是否含有题目要求的，然后改值标记防重，注意留意遍历范围，因为要判断当前字符和后面两位所以要减 $2$，以及 Py 的字符串不能用等号赋值的方法更改，可以把字符串的字符存进数组中。


```python
a=['lqb','lbq','qlb','qbl','blq','bql']
b=input().strip()
d=[x for x in b]
ans=0
for i in range(0,len(b)-2):
    if d[i] in ['l','q','b']:
        c=""
        c+=d[i]+d[i+1]+d[i+2]
        if c in a:
            ans+=1
            d[i+1]="0"
            d[i+2]="0"
print(ans)
if "__name__"=="__main__":
    main()
        

```

---


# [蓝桥杯 2025 省 Python B] 园艺

## 题目描述

小蓝从左到右种了 $n$ 棵小树，第 $i$ 棵树的高度为 $h_i$，相邻树的间隔相同。小蓝想挪走一些树使得剩下的树等间隔分布，且从左到右高度逐渐上升（相邻两棵树高度满足右边的比左边的高），小蓝想知道最多能留下多少棵树。

## 说明/提示

### 样例说明

留下第 1、3、5 棵树，它们等间隔且从左到右高度逐渐上升。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 500$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 3000$；
- 对于所有评测用例，$1 \leq n \leq 5000$，$0 < h_i < 10^6$。

## 样例 #1

### 输入

```
6
3 5 4 7 6 7```

### 输出

```
3```

# 题解

## 作者：swate114514 (赞：6)

这个问题要求我们从给定的树的高度序列中，找出一个最多的树的子集，使得子集中的树之间的高度严格递增并且它们的间隔是等差的。

## 方法一
我们可以把这个问题转化为一个**动态规划问题**，其中我们要找到一个最长的子序列，满足以下两个条件：
- 树的高度严格递增。即选择的树高度要满足 $h_i < h_j$（对于任意选择的树 $i$ 和 $j$，$i < j$）。
- 树的间隔相等。即选择的树的索引之间的间隔要是等差的，比如选择的树的索引分别为 $i, j, k, \dots$，那么 $j - i = k - j$，即相邻的树之间的间隔是相等的。
  
有了思路后，很容易想到这个问题的一个 $O(n^2)$ 解法。

我们用 $dp[i][d]$ 来表示状态。 $i$ 表示当前树的索引，$d$ 表示当前树与前一棵树的间隔（即索引差），那么 $dp[i][d]$ 就表示以第 $i$ 棵树为结尾，并且前一棵树与当前树之间的间隔为 $d$ 时，最多能保留多少棵树。

- 假设我们已经处理了到第 $i$ 棵树，我们可以通过之前的树来更新状态。
- 对于每一对树 $i$ 和 $j$（$j < i$），我们可以尝试计算树之间的间隔 $d = i - j$，如果满足 $h[j] < h[i]$，则我们可以把树 $j$ 加入到以树 $i$ 为结尾的子序列中，并更新 $dp[i][d]$。

**Code.1**
1. **c++**
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	int n;
	cin >> n;
	
	vector<int> h(n);
	for (int i = 0; i < n; ++i) {
		cin >> h[i];
	}
	
	// dp[i] 是一个哈希表，记录以第 i 棵树为结尾，间隔为 d 的最大子序列长度
	vector<unordered_map<int, int>> dp(n);
	
	int ans = 1;  // 至少有一棵树
	
	for (int i = 1; i < n; ++i) {
		for (int j = 0; j < i; ++j) {
			if (h[i] > h[j]) {  // 高度严格递增
				int d = i - j;  // 当前树和前一棵树的间隔
				dp[i][d] = max(dp[i][d], dp[j].count(d) ? dp[j][d] + 1 : 2); // 2是因为至少包含树j和树i
				ans = max(ans, dp[i][d]);
			}
		}
	}
	
	cout << ans;
	
	return 0;
}
```
2. **Python**
```python
from collections import defaultdict

def main():
    n = int(input())
    h = list(map(int, input().split()))

    dp = [defaultdict(int) for _ in range(n)]
    
    ans = 1 
    
    for i in range(1, n):
        for j in range(i):
            if h[i] > h[j]:
                d = i - j 
                dp[i][d] = max(dp[i][d], dp[j][d] + 1 if d in dp[j] else 2)
                ans = max(ans, dp[i][d])
    
    print(ans)

if __name__ == "__main__":
    main()
```
## 方法二
前面那个解法慢的飞起……让我们来考虑优化。

不妨来优化一下之前的思路：

$dp[i][d]$ 表示以第 $i$ 棵树结尾，公差为 $d$ 的最长符合条件子序列的长度。

我们可以先初始化每个位置的长度为 $1$，因为每个树本身可以单独形成一个子序列。

那么状态转移就是对于每棵树 $i$ 和可能的公差 $d$，检查前面的树 $j = i - d$，如果高度递增，则更新 $dp[i][d]$ 的值。虽然仍是 $O(n^2)$，但是快了许多。

**Code.2**
1. **c++**
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; ++i) {
        cin >> h[i];
    }

    if (n == 0) {
        cout << 0 << endl;
        return 0;
    }

    int maxn = 1;
    vector<vector<int>> dp(n, vector<int>(n, 1)); // dp[i][d] 初始为1

    for (int i = 1; i < n; ++i) { // 从i = 1开始，因为 i = 0 时无法形成步长 d ≥ 1 的序列
        for (int d = 1; d <= i; ++d) {
            int j = i - d;
            if (h[i] > h[j]) {
                dp[i][d] = dp[j][d] + 1;
                if (dp[i][d] > maxn) {
                    maxn = dp[i][d];
                }
            }
        }
    }

    cout << maxn;

    return 0;
}
```
2. **Python**
```python
def main():
    n = int(input())
    h = list(map(int, input().split()))

    if n == 0:
        print(0)
        return

    maxn = 1
    dp = [[1] * n for _ in range(n)]  

    for i in range(1, n): 
        for d in range(1, i + 1):
            j = i - d
            if h[i] > h[j]:
                dp[i][d] = dp[j][d] + 1
                if dp[i][d] > maxn:
                    maxn = dp[i][d]

    print(maxn)

if __name__ == "__main__":
    main()
```

---

## 作者：Transparent_fish (赞：3)

## 思路:

我们可以将此题转化为：在所有可能的等差数列下标序列中，找出最长的满足对应高度严格递增的序列。我们可以使用动态规划来解决此问题。

我们定义 $dp[i][j]$ 表示第 $i$ 和第 $j$ 棵树作为最后两棵树时能保留的最多树数。状态转移方程为：

对于所有 $k < j < i$ ，如果 $j - k = i - j$ （间隔相等）且 $h_k < h_j < h_i$ 则：

 $$dp[j][i] = \max(dp[j][i], dp[k][j] + 1)$$

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5005;
int n;
int maxx;
int h[N];
int dp[N][N];//dp数组

signed main() {
	cin >> n;
	//初始化
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			dp[i][j] = 2;
		}
	}
	for (int i = 0; i < n; ++i) {
		cin >> h[i];
	}
	maxx = min((int)2, n);//最大值为2和n中的较小者
	for (int j = 1; j < n; ++j) {
		for (int i = 0; i < j; ++i) {
			int d = j - i;//计算当前间隔
			int k = i - d;//计算前一个可能的位置
			//如果k有效且满足高度递增条件
			if (k >= 0 && h[k] < h[i] && h[i] < h[j]) {
				dp[i][j] = max(dp[i][j], dp[k][i] + 1);//状态转移
			}
			//更新最大值
			maxx = max(maxx, dp[i][j]);
		}
	}
	cout << maxx;
	return 0;
}
```

---

## 作者：guoshengyu1231 (赞：2)

# 思路
主要思路：动态规划。
## 状态
设 $dp_{i,j}$ 表示以第 $i$ 棵树结尾，相邻间距为 $j$ 的序列最长长度。
## 边界
由于一个序列最少有一棵树，所以 $dp_{i,j}$ 初值为 $1$。
## 转移
既然是第 $i$ 棵树结尾，相邻间距为 $j$ 的序列，那前一棵树必然是 $i-j$。也就是如果 $a_{i-j}<a_i$，那么 $dp_{i,j}\gets dp_{i,j}+dp_{i-j,j}$。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
int n,a[maxn],dp[maxn][maxn],ans=1;//最少也可以一棵树单独一个序列
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++) dp[i][j]=1;//不能用memset赋值为1！
	for(int i=2;i<=n;i++)
	 for(int j=1;j<i;j++)
	  if(a[i-j]<a[i]) dp[i][j]+=dp[i-j][j],ans=max(ans,dp[i][j]);//同时记录答案
	cout<<ans;
	return 0;
}
```
由于题解要求，这里在放上 python 代码，其原理与 c++ 代码基本一致。

```python
n = int(input())
a = list(map(int, input().split()))
a = [0] + a  # 使索引从1开始，与C++代码一致

dp = [[1] * (n + 1) for _ in range(n + 1)]
ans = 1

for i in range(2, n + 1):
    for j in range(1, i):
        if a[i - j] < a[i]:
            dp[i][j] += dp[i - j][j]
            ans = max(ans, dp[i][j])

print(ans)
```

---

## 作者：ryderyang (赞：1)

# 解题思路
动态规划应该挺好想的。所以思考一下动态规划的三要素：
### 确定状态
设 $dp_{i,j}$ 表示以第 $i$ 棵树结尾，留的每一棵树间隔 $j$，最多能留多少棵树。
### 状态转移
显而易见的是，我们的上一棵树是第 $i-j$ 棵树。所以如果 $a_{i-j} \lt a_i$，那么 $dp_{i,j}$ 就是 $dp_{i-j,j} + 1$。
### 初始化
不管 $i$ 和 $j$ 是多少，我们至少也能留 $1$ 棵树。所以可以把 $dp$ 初始化为 $1$。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int n,a[N],dp[N][N],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	fill(dp[0],dp[0]+N*N,1);
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(a[i-j]<a[i])
			{
				dp[i][j]=dp[i-j][j]+1;
			}
			ans=max(ans,dp[i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Urbosa (赞：1)

# 思路

这是一题经典的最长上升子序列，一般选择使用动态规划来实现。

定义 $dp[i][j]$ 表示以第 $i$ 棵树开始到第 $j$ 棵树结尾的一段距离。

要找最长的距离，所以用 $\max()$，而一开始要定义一个较小的值，例如 $2$。

运用动态转移方程，即 $dp[i][j] = \max(dp[i][j], dp[t][i] + 1)$ 算出答案。

# 代码

c++
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5005;
long long n;//习惯开long long
long long maxn;
long long h[N];
long long dp[N][N];

int main() {
	cin >> n;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			dp[i][j] = 2;
		}
	}
	for (int i = 0; i < n; ++i) {
		cin >> h[i];
	}
	maxn = min((long long)2, n);
	for (int j = 1; j < n; ++j) {
		for (int i = 0; i < j; ++i) {
			int w = j - i;
			int t = i - w;
			if (t >= 0 && h[t] < h[i] && h[i] < h[j]) {
				dp[i][j] = max(dp[i][j], dp[t][i] + 1);
			}
			maxn = max(maxn, dp[i][j]);
		}
	}
	cout << maxn;
	return 0;
}
```

python

```python
n = int(input())
a = list(map(int, input().split()))
a = [0] + a
dp = [[1] * (n + 1) for _ in range(n + 1)]
ans = 1
for i in range(2, n + 1):
    for j in range(1, i):
        if a[i - j] < a[i]:
            dp[i][j] += dp[i - j][j]
            ans = max(ans, dp[i][j])
print(ans)
```

---

## 作者：the_82nd_spotlight (赞：1)

本题求最多能留下多少棵树，而题目要求留下的树间隔相同，由此我们可以把这个理解为等差数列。

看到数据范围 $1\leq n \leq5000$，本题可以直接暴力枚举 $O(n^2)$，即我们枚举每一种等差数列。

首先枚举间隔 $k$，再枚举起始点 $s$。在每一组等差数列中寻找最长的一段子序列满足 $h_j>h_{j-k}$。对于每一次的判断，如果合法，将序列长度 $+1$，否则将长度重新设置成 $1$（将当前的树设置为下一段序列的首项元素）。

只需要存储每棵树的高度，空间复杂度 $O(n)$，枚举间隔 $1$ 到 $n-1$，对于每一种间隔都可以询问到每一个元素，时间复杂度 $O(n^2)$。Python 语言开 PyPy3 否则容易 TLE。

下面贴上 AC 代码：

```python
n=int(input())
h=[0]+[int(i) for i in input().split()]
ans=1
for k in range(1,n): #枚举间隔
    for s in range(1,k+1): #枚举起始点
        cnt=1
        for j in range(s+k,n+1,k): #枚举等差数列元素
            if h[j]>h[j-k]:
                cnt+=1
                ans=max(ans,cnt)
            else:
                cnt=1
print(ans)
```

---

## 作者：封禁用户 (赞：0)

## 前言
这道题我想应该正解是用模拟做的。

那本蒟蒻就献上我的题解。
## 思路
题目要求从左到右种了 $n$ 棵小树，第 $i$ 棵树的高度为 $h[i]$。现在要移除一些树，使得剩下的树满足：
- 间隔分布：剩下的树在原序列中的位置是大小间隔的。

-  高度严格递增：剩下的树的高度从左到右必须严格递增。

目标是找到最多能留下多少棵树。

**但是**我发现这个思路写出来的代码只能拿 70pts。

代码错误在于：

$\because$ 只记录完全连续的合法子序列。

$\therefore$ 忽略了中途终止但存在更优解的情况。

---
于是，我又改出来了第二套方法：
- 遍历所有可能的起点和步长：枚举所有可能的起始点 $i$ 和间隔 $d$。

- 最大值刷新：在检查过程中，只要当前累计的合法长度超过历史最大值，立即更新结果。

- 连续性不工整：即使后续节点不满足条件，已统计的前半段仍可能成为最优解。

$\therefore$ 我们 AC 了。
## code：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main() {
    int n;
    cin >> n;
    int h[5005];
    for (int i = 0; i < n; i++) cin >> h[i];    
    int maxx = 1; // 至少保留1棵树   
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int d = j - i;
            int cnt = 1;
            int now = i;
            int now_h = h[i];
            // 强制包含i和j作为前两个节点（要求h[j]>h[i]）
            if (h[j] <= now_h) continue; // 不满足则跳过        
            cnt++; // 加入j节点
            now = j;
            now_h = h[j];
            // 继续向后跳
            int next = now + d;
            while (next < n) {
                if (h[next] > now_h) {
                    cnt++;
                    now = next;
                    now_h = h[next];
                    next += d;
                } else {
                    break; // 不再满足时立即终止
                }
            }      
            // 只要当前长度更大就更新
            if (cnt > maxx) maxx = cnt;
        }
    }   
    cout << maxx << endl;
    return 0;
}
```
## 后记：
本蒟蒻熬夜而写，求过 QwQ。

对于一审，我驳回，因为我是自己写的，请洛谷管理员重新审视，谢谢。

感谢二审指出打字错误，我已改正。

感谢四，五审，已改正错误。

感谢六审，七审，已改正。

感谢八审，已改正六审，七审。

---

## 作者：luokc (赞：0)

# P12175 [蓝桥杯 2025 省 Python B] 园艺
这是一个很普通的最长上升子序列的题，由于本人不太会 DP 所以就用了枚举。
## 思路
- 对于每个可能的起始位置 $i$ 和第二个位置 $j$（$j > i$），计算其间隔 $d = j - i$。
   
- 从第二个位置 $j$ 开始，每次增加间隔 $d$，检查后续的位置高度是否严格大于前一个位置的高度，直到超出数组范围或不满足递增条件。
    
- 在每次检查后更新最长符合条件的子序列长度。
## 代码
### C++

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; ++i) {
        cin >> h[i];
    }
    int maxl = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (h[j] <= h[i]) {
                continue;
            }
            int d = j - i;
            int nl = 2;
            int p = h[j];
            int pos = j + d;
            while (pos < n) {
                if (h[pos] > p) {
                    nl++;
                    p = h[pos];
                    pos += d;
                } else {
                    break;
                }
            }
            if (nl > maxl) {
                maxl = nl;
            }
        }
    }
    cout << maxl;
    return 0;
}    
```
### Python

```python
n = int(input())
h = list(map(int, input().split()))
maxl = 1  # 至少选一个树
for i in range(n):
    for j in range(i + 1, n):
        if h[j] <= h[i]:
            continue  # 第二个数必须比第一个大，否则无法形成递增序列
        d = j - i
        nl= 2
        p = h[j]
        pos = j + d
        while pos < n:
            if h[pos] > p:
                nl += 1
                p = h[pos]
                pos += d
            else:
                break  # 后面的间隔位置无法满足递增，直接结束
        if nl > maxl:
            maxl = nl
print(maxl)
```

---


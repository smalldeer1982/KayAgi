# [蓝桥杯 2023 省 Java B] 矩形总面积

## 题目描述

平面上有两个矩形 $R_1$ 和 $R_2$，它们各边都与坐标轴平行。设 $(x_1, y_1)$ 和 $(x_2, y_2)$ 依次是 $R_1$ 的左下角和右上角坐标，$(x_3, y_3)$ 和 $(x_4, y_4)$ 依次是 $R_2$ 的左下角和右上角坐标，请你计算 $R_1$ 和 $R_2$ 的总面积是多少？

注意：如果 $R_1$ 和 $R_2$ 有重叠区域，重叠区域的面积只计算一次。

## 说明/提示

### 样例说明

样例中的两个矩形如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/c71ueuv5.png)

### 评测用例规模与约定

- 对于 $20\%$ 的数据，$R_1$ 和 $R_2$ 没有重叠区域。
- 对于 $20\%$ 的数据，其中一个矩形完全在另一个矩形内部。
- 对于 $50\%$ 的数据，所有坐标的取值范围是 $[0, 10^3]$。
- 对于 $100\%$ 的数据，所有坐标的取值范围是 $[0, 10^5]$。

## 样例 #1

### 输入

```
2 1 7 4 5 3 8 6```

### 输出

```
22```

# 题解

## 作者：Evan2000 (赞：3)

## 题意
给你两个矩阵的左下角和右上角坐标，让你求这两个矩阵的总面积，两个矩阵有可能重叠，重叠部分只算**一次**。
## 思路
算出两个矩阵的面积的和，将其减去重叠部分的面积，然后就没了。注意：不开```long long```见祖宗！

算出两个矩阵的面积应该很容易，只需要用其右上角列坐标减去其左下角列坐标，再乘上其右上角横坐标减去其左下角横坐标，就能求出面积了。

算出重叠部分的面积稍微难一点，需要用第一个矩阵的右上角列坐标和第二个矩阵的右上角列坐标的最小值，减去第一个矩阵的左下角列坐标和第二个矩阵的左下角列坐标的最大值，算出重叠部分的高，然后再用第一个矩阵的右上角横坐标和第二个矩阵的右上角横坐标的最小值，减去第一个矩阵的左下角横坐标和第二个矩阵的左下角横坐标的最大值，算出重叠部分的宽，将高和宽相乘，就能算出重叠部分的面积了。

如果算重叠部分时出现负数或 $0$，就说明没有重叠部分，需要特判一下，直接算两个矩阵的面积的和即可。
## AC 代码（C++）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x[5];
int y[5];
signed main()
{
	for(int i=1;i<=4;i++)
	{
		scanf("%lld%lld",&x[i],&y[i]);
	}
  //读入
	int ret=abs(x[2]-x[1])*abs(y[2]-y[1]);
	int ans=abs(x[4]-x[3])*abs(y[4]-y[3]);
  //算出两个矩阵的面积
	int a=min(x[2],x[4]);
	int b=max(x[1],x[3]);
	int c=min(y[2],y[4]);
	int d=max(y[1],y[3]);
	int sum=0;
	if(a>b && c>d)//判一下有没有重叠部分，如果没有，sum保持不变，一直为0
	{
		sum=(a-b)*(c-d);
	}
  //算出重叠部分的面积
	printf("%lld",ret+ans-sum);
	return 0;
}
```

---

## 作者：sen_lin114514 (赞：1)

# P12326 [蓝桥杯 2023 省 Java B] 矩形总面积

## 思路

题目很好理解，经过简单推理就可以知道分别计算一下两个矩形的面积，再计算他们重叠的面积，总面积减去重叠面积即可得到答案。

## AC CODE（Java）


```java
import java.util.Scanner;

public class Main 
{
    public static void main(String[] args) 
    {
        Scanner sc = new Scanner(System.in);
        long x1 = sc.nextLong(), y1 = sc.nextLong();
        long x2 = sc.nextLong(), y2 = sc.nextLong();
        long x3 = sc.nextLong(), y3 = sc.nextLong();
        long x4 = sc.nextLong(), y4 = sc.nextLong();
        sc.close();
        
        long s1 = (x2 - x1) * (y2 - y1);
        long s2 = (x4 - x3) * (y4 - y3);
        
        long w = Math.max(0, Math.min(x2, x4) - Math.max(x1, x3));
        long h = Math.max(0, Math.min(y2, y4) - Math.max(y1, y3));
        
        long total = w * h;
        
        long ans = s1 + s2 - total;
        System.out.println(ans);
    }
}
```

---

## 作者：Suwenluo (赞：1)

思路很快的：
1. 根据容斥原理，我们要算出两者单独面积之和，然后减去重叠面积。
2. 单独面积用的是长乘宽，重叠面积公式同。所以我们就把问题抽丝剥茧地简化成了求单独面积、重叠面积的长和宽。
3. 剩下问题不大了，我们通过平面直角坐标系找到坐标之差，根据坐标差求出面积长宽，最后套上容斥公式，单独面积和减去重叠面积，即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x_1,y_1,x_2,y_2,x_3,y_3,x_4,y_4;
int main() {
	//冗长的输入，手写需静心、耐心、恒心。 
    scanf("%lld%lld%lld%lld%lld%lld%lld%lld",&x_1,&y_1,&x_2,&y_2,&x_3,&y_3,&x_4,&y_4);
    
    long long mianji1=(x_2-x_1)*(y_2-y_1);  // 第一个矩形的面积
    long long mianji2=(x_4-x_3)*(y_4-y_3);  // 第二个矩形的面积
    //用横纵坐标之差求面积，这里有一个关键点，就是答案的正负性问题：
	//如果两个差都是负数，那就负负得正，如果都是正数，那就没什么好说的，这个图形面积一定是正数。
	 
    // 计算重叠区域的宽度和高度
    long long kuan=min(x_2,x_4)-max(x_1,x_3);
    long long gao=min(y_2,y_4)-max(y_1,y_3);
    //求差
	 
    // 如果有重叠，计算重叠区域面积
    long long chongdie_mianji;
    if (kuan>0 && gao>0){ //如果两个都是正数，那这个重叠面积也就存在 
    	chongdie_mianji=kuan*gao; //长方形面积公式=长*宽
		//我是中国人，我学好汉语拼音 
	}else chongdie_mianji=0; //不存在当然是0 
	
    // 求总面积，总面积=两矩形面积和-重叠面积
    long long ans=mianji1+mianji2-chongdie_mianji;
    
    //用好格式化，便于卡效率 
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：yulinOvO (赞：0)

### 题意
题目意思很明确，给出两个矩形的四个点，计算总面积，其中重叠部分仅计算一次。

### 思路
首先计算两者面积相加，再计算有没有重叠，如果有重叠，答案减去重叠部分面积即可。

### C++ Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
bool flag;
long long ans;
int main()
{
  long long x1,y1,x2,y2,x3,y3,x4,y4;
  cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;
  long long s1=(x2-x1)*(y2-y1);
  long long s2=(x4-x3)*(y4-y3);//两个矩形面积
  if(x2<=x3||x4<=x1||y2<=y3||y4<=y1) ans=s1+s2;
  else//重叠部分面积计算
  {
    long long xx1=max(x1,x3),xy1=max(y1,y3);
    long long xx2=min(x2,x4),xy2=min(y2,y4);
    long long tms=(xx2-xx1)*(xy2-xy1);
    ans=s1 + s2-tms;
  }
  cout << ans;
  return 0;
}
```
### Java Code:
```cpp
import java.util.*;
public class Main {
    static boolean flag;
    static long ans;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long x1 = sc.nextLong(), y1 = sc.nextLong(), x2 = sc.nextLong(), y2 = sc.nextLong();
        long x3 = sc.nextLong(), y3 = sc.nextLong(), x4 = sc.nextLong(), y4 = sc.nextLong();
        long s1 = (x2 - x1) * (y2 - y1);
        long s2 = (x4 - x3) * (y4 - y3);//两个矩形面积
        if (x2 <= x3 || x4 <= x1 || y2 <= y3 || y4 <= y1) ans = s1 + s2;
        else//重叠部分面积计算
        {
            long xx1 = Math.max(x1, x3), xy1 = Math.max(y1, y3);
            long xx2 = Math.min(x2, x4), xy2 = Math.min(y2, y4);
            long tms = (xx2 - xx1) * (xy2 - xy1);
            ans = s1 + s2 - tms;
        }
        System.out.println(ans);
    }
}
```

---

## 作者：luokc (赞：0)

# P12326 [蓝桥杯 2023 省 Java B] 矩形总面积
## 题目理解
给出平面上两个各边都与坐标轴平行的矩形 $R_1$ 和 $R_2$，要求计算它们的总面积。  
已知 $x_1$，$y_1$ 和 $x_2$，$y_2$ 是 $R_1$ 的左下角和右上角坐标，$x_3$，$y_3$ 和 $x_4$，$y_4$ 是 $R_2$ 的左下角和右上角坐标。  
要注意的是，如果两个矩形有**重叠区域**，**重叠区域的面积只计算一次**。
## 思路
既然我们要计算两个矩形的总面积，可先分别算出两个矩形各自的面积，再计算它们重叠部分的面积，最后用两个矩形面积之和减去重叠部分的面积，就能得到最终结果。
## Java 代码
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long x1 = scanner.nextLong();
        long y1 = scanner.nextLong();
        long x2 = scanner.nextLong();
        long y2 = scanner.nextLong();
        long x3 = scanner.nextLong();
        long y3 = scanner.nextLong();
        long x4 = scanner.nextLong();
        long y4 = scanner.nextLong();
        long a1 = (x2 - x1) * (y2 - y1);
        long a2 = (x4 - x3) * (y4 - y3);
        long lx = Math.max(x1, x3);
        long rx = Math.min(x2, x4);
        long by = Math.max(y1, y3);
        long ty = Math.min(y2, y4);
        long w = rx - lx;
        long h = ty - by;
        long o = (w > 0 && h > 0) ? w * h : 0;
        System.out.println(a1 + a2 - o);
        scanner.close();
    }
}
```

---

## 作者：Yumi_Anaxa_ (赞：0)

[**题面链接**](/problem/P12326)
### 方法思路
1. 先将两个矩形视为一个整体，再计算覆盖两个矩形的最小外接矩形面积，然后减去未覆盖。
2. 提前判是否有重叠。
### java
```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int x1 = scanner.nextInt();
        int y1 = scanner.nextInt();
        int x2 = scanner.nextInt();
        int y2 = scanner.nextInt();
        int x3 = scanner.nextInt();
        int y3 = scanner.nextInt();
        int x4 = scanner.nextInt();
        int y4 = scanner.nextInt();
        //面积计算
        long p1 = (long)(x2 - x1) * (y2 - y1);
        long p2 = (long)(x4 - x3) * (y4 - y3);
        boolean is = x2 <= x3 || x4 <= x1 || y2 <= y3 || y4 <= y1;//有没有重叠？
        long ans;
        if (is)ans = p1 + p2;
        else{
            //计算重叠部分坐标
            int olx1 = Math.max(x1, x3);
            int oly1 = Math.max(y1, y3);
            int olx2 = Math.min(x2, x4);
            int oly2 = Math.min(y2, y4);
            long tmp = (long)(olx2 - olx1) * (oly2 - oly1);
            ans = p1 + p2 - tmp;
        }
        System.out.println(ans);
        scanner.close();
    }
}
```
### C++（思路一样）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
  int x1, y1, x2, y2, x3, y3, x4, y4;
  cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;
  ll p1 = (ll)(x2 - x1) * (y2 - y1),p2 = (ll)(x4 - x3) * (y4 - y3),ans;//面积计算
  bool is = x2 <= x3 || x4 <= x1 || y2 <= y3 || y4 <= y1;//有没有重叠？
  if (is)ans = p1 + p2;
  else{//计算重叠部分坐标
    int olx1 = max(x1, x3),oly1 = max(y1, y3);
    int olx2 = min(x2, x4),oly2 = min(y2, y4);
    ll tmp = (ll)(olx2 - olx1) * (oly2 - oly1);
    ans = p1 + p2 - tmp;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 思路
要求出两个矩形覆盖的总面积，由于两个矩形可能存在重叠部分，若直接将两个矩形的面积相加，重叠部分的面积会被重复计算，所以需要减去重叠部分的面积，即总面积等于第一个矩形的面积加第二个矩形的面积减重叠部分的面积。

如何计算重叠部分面积：

重叠矩形的宽度计算：重叠矩形的左边界是两个矩形左边界中较大的那个，右边界是两个矩形右边界中较小的那个。那么重叠矩形的宽度就是 `w = max(0, min(x2, x4) - max(x1, x3))`，是为了确保宽度为非负数，当两个矩形不重叠时，`min(x2, x4) - max(x1, x3)` 会是负数，此时宽度应为 $0$。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
//计算相交的面积 
int fun(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){
    int w=max(0LL,min(x2,x4)-max(x1,x3));
    int h=max(0LL,min(y2,y4)-max(y1,y3));
    return w*h;
}
int x1,y1,x2,y2,x3,y3,x4,y4;
int ans;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;
	//计算两个矩形的大小 
	ans+=(x1-x2)*(y1-y2);
	ans+=(x3-x4)*(y3-y4);
	//最后还要减去相交的面积 
	cout<<ans-fun(x1,y1,x2,y2,x3,y3,x4,y4);
	return 0;
}
```

---

## 作者：anyiming (赞：0)

# 题解：P12326 [蓝桥杯 2023 省 Java B] 矩形总面积

[题目传送门](https://www.luogu.com.cn/problem/P12326)

## 解题思路

这道题的关键是计算两个矩形的面积，然后判断它们是否有重叠。如果有重叠，就从总面积中减去重叠部分的面积。最终的总面积就是两个矩形的面积之和减去重叠区域的面积（如果有重叠的话）。

## cpp

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    cin.tie(0);
    cout.tie(0);

    int x[5], y[5];
    
    // 输入四个坐标
    for (int i = 1; i <= 4; i++) {
        cin >> x[i] >> y[i];
    }

    // 计算两个矩形的面积
    int area1 = (x[2] - x[1]) * (y[2] - y[1]);  // 第一个矩形的面积
    int area2 = (x[4] - x[3]) * (y[4] - y[3]);  // 第二个矩形的面积

    // 计算重叠区域的宽度和高度
    int overlap_width = min(x[2], x[4]) - max(x[1], x[3]);
    int overlap_height = min(y[2], y[4]) - max(y[1], y[3]);

    // 如果有重叠，计算重叠区域面积
    int overlap_area = (overlap_width > 0 && overlap_height > 0) ? overlap_width * overlap_height : 0;

    // 总面积 = 两个矩形面积之和 - 重叠区域面积
    int total_area = area1 + area2 - overlap_area;

    cout << total_area << endl;
    return 0;
}

```

---


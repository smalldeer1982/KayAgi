# [蓝桥杯 2025 省 B/Python B 第二场] 数列差分

## 题目描述

小蓝有两个长度均为 $n$ 的数列 $A=\{a_1, a_2, \cdots, a_n\}$ 和 $B=\{b_1, b_2, \cdots, b_n\}$，将两个数列作差定义为 $C=A-B=\{c_1=a_1-b_1, c_2=a_2-b_2, \cdots, c_n=a_n-b_n\}$。小蓝将对数列 $B$ 进行若干次操作，每次操作可以将数列 $B$ 中的任意一个数更改为任意一个整数。在进行完所有操作后，小蓝可以按任意顺序将数列 $B$ 重排，之后再计算数列 $C$。小蓝想知道，最少操作多少次可以使得数列 $C$ 中的所有数都为正整数。

## 说明/提示

### 样例说明

其中一种方案：将 $44$ 改为 $0$，重新排列 $B$ 为 $\{19, 27, 3, 0\}$，使得数列 $C=\{3, 4, 9, 14\}$ 均为正整数。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$n \leq 10$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$，$-10^9 \leq b_i \leq 10^9$。

## 样例 #1

### 输入

```
4
22 31 12 14
3 19 27 44```

### 输出

```
1```

# 题解

## 作者：weifengzhaomi (赞：4)

## 题意 & 化简

现在我们有两个数组，分别记为 $a$ 和 $b$。

然后又有 $c$ 为 $\sum _ {i = 1} ^ {n} c_i = a_i - b_i$。

要求 $\sum _ {i = 1} ^ {n} c_i > 0$。

## 思路

首先，这道题，我们要排一下序，方便计算。

接着，我们要用双指针来枚举，这样比循环方便许多。

然后，我们来考虑答案。

每次我们的双指针都指向最后一个数，看一下大小如何，有两种情况:

1.$b_i \ge a_i$，这时，减出来的不是正整数，因为现在两个数是当前最大的数字了，没办法换一个 $a_i$ 让式子成立，所以，我们不得不操作一次，答案加一，然后处理完后，枚举下一个 $b_i$。

2.$b_i < a_i$，这时，减出来的是正整数，符合题目要求，所以不用处理，直接枚举下一个 $b_i$ 和 $a_i$ 即可。

如果到最后，$b$ 已经空了，那么就退出，输出答案即可。

## 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010],b[100010],x,y,ans;
int main(){
	scanf("%d",&n);
	for (int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for (int i = 1;i <= n;i++) scanf("%d",&b[i]);
	sort(a + 1,a + n + 1);
	sort(b + 1,b + n + 1);
	x = y = n;
	while (true){
		if (b[y] >= a[x]){
			y--;
			ans++;
		} else {
			x--;
			y--;
		}
		if (!y) break;
	}
	printf("%d\n",ans);
}
```

---

## 作者：Clare613 (赞：3)

## 思路
简单贪心题，就是能减则减，使**原本**正整数的数量尽量多，就是用尽量大的数来减较大的数，最后输出用总数减去**原本**正整数的个数，输出即可。
## code:

```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
int a[100005],b[100005];
int main(){
    cin.tie(0)->sync_with_stdio(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>a[i];
	}
    for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int l1=n,l2=n,ans=n;
	while(l2>0){
		if(a[l1]>b[l2]){
			l1--;
			l2--;
			ans--;
		}
		else{
			l2--;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：JIN_LONG (赞：2)

## 思路
对于每个元素 $c_i = a_i - b_j$，必须满足 $c_i > 0$，即  $b_j< a_i$。为了最小化操作次数，我们希望尽可能多地利用原始的 $B$ 中的元素，即尽量少修改 $B$ 的元素。修改后的 $B$ 的元素可以任意排列，因此我们可以将 $A$ 和 $B$ 排序后进行匹配。

以下是步骤。
- 排序 $A$ 和 $B$。
- 使用双指针法，从最小的 $A$ 元素开始，尝试匹配最大的可能的 $B$ 元素。
- 统计需要修改的 $B$ 的元素数量。
## 代码

```python
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

A_sorted = sorted(A)
B_sorted = sorted(B)

res = 0
i = 0
j = 0
while i < n and j < n:
    if B_sorted[j] < A_sorted[i]:
        i += 1
        j += 1
    else:
        res += 1
        j += 1

print(res)
```

---

## 作者：Suwenluo (赞：2)

朴素的方法。

基本思想： 

1.将两个数组从小到大排序。  

2.定义两个变量 $xb_1$ 和 $xb_2$，初值都为 $n$。从两个数组最大的元素（也就是 $a[xb_1]$ 和 $b[xb_2]$）开始找。  

3.如果 $b[xb_2] \ge a[xb_1]$，也就是减出来是个负数，那我们就没办法了，因为当前的值都是未处理的数字当中的最大值，没办法再调整，所以就不得不把 $b[xb_2]$ 修改为 $0$，答案数加一。同时，由于 $b[xb_2]$ 已经处理完了，$xb_2$ 要减一，此时的 $b[xb_2]$ 就是 $b$ 数组中的最大值。  

4.另一种情况，$b[xb_2] < a[xb_1]$，减出来是个正数，满足题目要求。那我们不动它，相当于把它处理完了，$xb_1$ 和 $xb_2$ 都要减一，开始处理更小的数字。  

5.如果 $xb_2$ 到 $0$ 了，那就意味着我们需要调整的 $b$ 数组已经调整完，那我们就把统计的答案数输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100050],b[100050]; //数组大小有点大，要看数据范围。
int main() {
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for (int i=1;i<=n;i++){
		scanf("%d",&b[i]);
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1); //简洁的排序。
	int xb_1=n,xb_2=n; //别忘定义初始值。
	int ans=0; //答案数。
	while (1){ //使用 while 循环。
		if (b[xb_2]>=a[xb_1]){ //减出来是负数。
			b[xb_2]=0; //其实这个不调貌似也没关系。
			xb_2--; //处理下一个数。
			ans++; //统计答案数。
		}else{ //是正数。
			xb_2--;
			xb_1--; //统计下一个数。
		}
		if (xb_2==0)break; //处理完了。
	}cout << ans; //输出。
    return 0; //好习惯。
}
```

---

## 作者：封禁用户 (赞：1)

# P12342题解

## 思路
双指针，如果当前 $B$ 的元素小于当前 $A$ 的元素，即 $(b[j]<a[i])$，则这两个元素可以配对，无需修改，只需移动两个指针。否则，当前 $B$ 的元素无法配对，需要修改，只移动 $A$ 的指针，并增加修改次数。
## [AC](https://www.luogu.com.cn/record/215176123) 代码
```
#include <bits/stdc++.h>
using namespace std;
int a[100005];
int b[100005];
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    sort(a, a + n);
    sort(b, b + n);
    int sum = 0;
    int i = 0, j = 0;
    while (i < n && j < n) {
        if (b[j] < a[i]) {
            i++;
            j++;
        } else {
            sum++;
            i++;
        }
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：swate114514 (赞：1)

## 题意
我们需要找到最少的操作次数，使得数列 $C = A - B$ 中的所有元素均为正整数。

## 思路
这个问题关键在于尽可能多地利用现有的元素，从而减少需要修改的次数。

我们可以将数列 $A$ 和 $B$ 分别进行升序排序。使用双指针遍历排序后的数列，尽可能多地匹配满足条件的元素。具体来说，对于每个 $a_i$，我们尝试找到最小的 $b_j$ 使得 $b_j < a_i$。若找到，则匹配成功；否则跳过当前 $a_i$，继续尝试更大的元素。

那么总修改次数等于数列长度减去成功匹配的元素数量。

## 方法
1. 将数列 $A$ 和 $B$ 排序。
2. 使用双指针遍历排序后的数列，统计能够匹配的数目。
3. 最少操作次数等于数列长度减去匹配数目。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> a(n), b(n);
    
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    for (int i = 0; i < n; ++i) {
        cin >> b[i];
    }
    
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    
    int i = 0, j = 0, cnt = 0;
    while (i < n && j < n) {
        if (a[i] > b[j]) {
            cnt++;
            i++;
            j++;
        } else {
            i++;
        }
    }
    
    cout << n - cnt;
    
    return 0;
}
```

---


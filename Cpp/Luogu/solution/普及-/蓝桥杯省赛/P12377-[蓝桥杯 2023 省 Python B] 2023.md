# [蓝桥杯 2023 省 Python B] 2023

## 题目描述

请求出在 $12345678$ （含）至 $98765432$ （含）中，有多少个数中完全不包含 $2023$。

完全不包含 $2023$ 是指无论将这个数的哪些数位移除都不能得到 $2023$。

例如 $20322175$，$33220022$ 都完全不包含 $2023$，而 $20230415$，$20193213$ 则含有 $2023$（后者取第 $1,2,6,8$ 个数位）。

# 题解

## 作者：HZY1618yzh (赞：6)

本题暴力+模拟就能过。 

思路
---
首先，枚举 $12345678$ 至 $98765432$ 的所有数，倒序分解数位后用快慢指针看看是否满足条件。

倒序分解数位可以通过每次不断把枚举到的数一直取余十，但一直取余十会把 $i$ 清零，所以要用一个 $z$ 变量储存 $i$ 的值。

那如何判断是否满足条件呢？先看看条件的代码翻译：如果 $i$ 的数码不包含按顺序的 $2023$，则 $ans$ 增加一。我们可以不断判断第快指针个数位是否是 $2023$ 的第慢指针个数位，如果是，慢指针加一。当慢指针大于三的时候，即概数有 $2023$ 这四个数，所以跳出循环。最后看看慢指针是否是四就能知道是否包含 $2023$。

代码
---
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[]={2,0,2,3},top,ans;
int main(){
    for(int i=12345678;i<=98765432;i++){
    	top=0;
		int z=i,now[8]={},cnt=0;
		while(z){
			now[cnt++]=z%10;
			z/=10;
		}
		for(int i=cnt;i>=0;i--)
			if(now[i]==a[top]){
				top++;
				if(top>3) break;
			}
		if(top>3) continue;
		ans++;
	}
	cout<<ans;
    return 0;
}
```
~给个一键三连吧！~

---

## 作者：GSQ0829 (赞：2)

### 解题思路：
首先要定义一个字符数组，这个字符数组里面包含了 $2,0,2,3$，四个数字字符。接下来循环判断每个数字，把这些数字先转成字符串，再遍历整个字符串，如果当前字符与字符数组里的当前字符，那字符数组的位置就下移一位，一直枚举到最后一位。如果整个字符数组的四个数字字符都被遍历完了，那就说明这个数字是满足条件的，计数器就加一。

代码如下：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int ans;
char c[4] = {'2', '0', '2', '3'};

signed main() {
	for (int i = 12345678; i < 98765433; i++) {
		string s = to_string(i);
		int cnt = 0;
		for (int j = 0; j < s.size(); j++) {
			if (s[j] == c[cnt]) cnt++;
		}
		if (cnt < 4) ans++;
	}
	cout << ans;
	return 0;
}
```
最后结果为 $85959030$。

---

## 作者：Little_Cart (赞：2)

### 思路

对于每一个数按位匹配 $2023$ 即可。

具体地，我们可以对于 $12345678$ 到 $98765432$ 的所有数，将它们全部转换为字符串格式，每次记录当前已经枚举到 $2023$ 的哪一位，如果当前位和这一位相同，则枚举下一位，最后如果已经枚举完了 $2023$，则不计入答案，否则计入答案。 

但是其实这个思路的时间复杂度还是略有些高，但还是能在一分钟内跑完的，所以可以通过打表本地跑出答案再直接提交答案的方式完成。

### C++ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
#define mkp make_pair
const int N=300024;
int t,n,m,ans,k;
int a[N];
string s;
char c[5]={'2','0','2','3','?'};
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(int i=12345678;i<=98765432;i++){
		s=to_string(i);
		int k=0;
		for(int j=0;j<s.size();j++){
			if(s[j]==c[k]) k++;
		}
		if(k!=4) ans++;
	}
	cout<<ans;
	return 0;
}

```

通过 C++ 代码得到答案为 $85959030$。

### python 代码

```python
print(85959030)
```

---

## 作者：wnqnld_llx (赞：1)

## 题目大意
完全不包含 $2023$ 是指无论将这个数的哪些数位移除都不能得到 $2023$。求出在 $12345678$ 至 $98765432$ 中，有多少个数中完全不包含 $2023$。
## 问题转换
对于每一个数 $i$，只要它的所有子序列不包括 $2023$，那么它就是合法的。
## 实现过程
直接枚举每个数的子序列。先将它转换为字符串，用 $i$ 遍历它的每一位，用 $cnt$ 遍历 $2023$。如果它们相等，那么 $cnt$ 就到下一位。如果 $cnt\gt3$ 那么它的子序列就包含 $2023$。  
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
bool check(int x){
	string s="";
	while(x){
		s+=(x%10)+'0';
		x/=10;
	}
	string s1="2023";
	int cnt=0;
	for(int i=s.length()-1;i>=0;i--){
		if(s[i]==s1[cnt]){
			cnt++;
			if(cnt>3){
				break;
			}
		}
	}
	if(cnt>3) return 1;
	return 0;
}
signed main(){
	for(int i=12345678;i<=98765432;i++){
		if(!check(i)) ans++;
	}
	cout<<ans;
	return 0;
} 
```
最终答案是 $ 85959030$。

---

## 作者：Evan2000 (赞：1)

## 题意
这道题就是让你求出 $12345678$ 到 $98765432$ 中有多少数就算移除一部分数位也无法得到 $2023$。
## 思路
考虑暴力枚举，枚举所有的数字，然后将其一个个数位的分解。

设一个 $ret$ 用来表示现在判断应该用 $2,0,2,3$ 中的哪个数字，然后从低位向高位拆分，如果一个数位上的数符合现在 $ret$ 让你判断的数，就使 $ret$ 加一，然后枚举下一个数位，如果 $ret$ 等于 $4$，就退出分解。最后判断一下 $ret$ 是否等于 $4$，如果不等于 $4$，$ans$ 加一，最后输出 $ans$。
## AC 代码（C++）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int ans=0;
	for(int i=12345678;i<=98765432;i++)
	{
		int ret=0;
		int j=i;
		while(j)
		{
			if(ret==4)
			{
				break;
			}
			if(ret==0 && j%10==3)
			{
				ret++;
				j/=10;
				continue;
			}
			if(ret==1 && j%10==2)
			{
				ret++;
				j/=10;
				continue;
			}
			if(ret==2 && j%10==0)
			{
				ret++;
				j/=10;
				continue;
			}
			if(ret==3 && j%10==2)
			{
				ret++;
				j/=10;
				continue;
			}
			j/=10;
		}
		if(ret!=4)
		{
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Aurelia_Veil (赞：1)

# 题解：P12377 \[蓝桥杯 2023 省 Python B] 2023

真就是个暴力。

首先先枚举 $12345678$ 到 $98765432$ 的所有数 $x$，然后拆分数位，使用双指针判断是否满足条件。

那如何使用双指针判断呢，因为 $2023$ 一定是在我们枚举的数中是按顺序的，所以只需要判断 $2023$ 的第 $k$ 为是否为 $x$ 的第 $i$ 位（$i$ 为循环变量）。如果相等，就 $k$ 加 $1$ 继续判断。

所以代码如下咩：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[]={2,0,2,3};
int main(){
	int cnt=0;
	for(int i=12345678;i<=98765432;i++){
		int now=i;
		vector<int>g;
		while(now){
			g.push_back(now%10);
			now/=10;
		}
		int top=0;
		for(int i=g.size()-1;i>=0;i--){
			if(g[i]==a[top]){
				top++;
				if(top>3){
					break;
				}
			}
		}
		if(top>3){
			continue;
		}
		cnt++;
	}
	printf("%d",cnt);
	return 0;
}

```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P12377)

## 题目分析：
这道题可以暴力枚举，但会花很长的时间。

首先，要把目前的数字转换为字符串，后面会方便一点，不用再提取数字了。

这时，我们需要一个字符串 $c$，是专门来存储 $2023$ 的。如果当前位和字符串 $c$ 这一位相同，则枚举下一位。如果枚举出来了 $2023$，答案就加 $1$，否则不加。

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ans;
char c[6]={'2','0','2','3'};
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for(int i=12345678;i<=98765432;i++){
		string s;
		s=to_string(i);
		int k=0;
		for(int j=0;j<s.size();j++){
			if(s[j]==c[k]) k++;
		}
		if(k!=4) ans++;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：langmouren (赞：0)

# 分析
提交答案题，可以接受暴力做法求出正解。

我们可以用边模边除的方法对于每一个数求出每一位，由于其是从低位开始的，我们依次判断 $3,2,0,2$ 四个数是否能够存在，如果能，则给答案加一。

事实上，我们使用 C++ 写出的程序本地仅不到 $2$ 秒，洛谷不到 $4$ 秒就跑出了正解。

最后可以求出答案是 $85959030$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int s=12345678,t=98765432,ans;

int main(){
	for(int i=s;i<=t;i++){
		int now=i,need=1;
		while(now>0){
			int tmp=now%10;
			if(tmp==2 || tmp==0 || tmp==3){
				if(tmp==3 && need==1) need=2;
				else if(tmp==2 && need==2) need=3;
				else if(tmp==0 && need==3) need=4;
				else if(tmp==2 && need==4){
					ans++;
					break;
				}
			}
			now/=10;
		}
	}
	cout<<t-s+1-ans;
	return 0;
} 	
```

---

## 作者：ArenaBreakout78 (赞：0)

# 题解：P12377 [蓝桥杯 2023 省 Python B] 2023

首先，这题可以直接暴力，但是这样肯定会超时，但是我们可以在本地跑出答案后，再在洛谷上提交。

## 思路：
1. 首先计算总数，然后减去包含 $2023$ 的数字数量。总数是：

$$98765432 - 12345678 + 1 = 86419755$$

2. ‌对于一个数字，我们需要检查是否存在一个子序列等于 $2023$。可以通过遍历数字的每一位，依次匹配 $2,0,2,3$ 的顺序。

最后，我们便能得出高级的 `TLE` 代码。

## Python TLE Code：

```python
def js(n):
    s=str(n)
    sum=0
    num='2023'
    for c in s:
        if c==num[sum]:
            sum+=1
            if sum==4:
                return True
    return False

ss=0
for i in range(12345678, 98765433):
    if js(i):
        ss+=1
ans=98765432-12345678+1-ss
print(ans)
```

然后在本地中跑出的答案为 `85959030` 直接输出即可。

## AC Code：

```python
print(85959030)
```
 ~~简便又实用~~

---


# [蓝桥杯 2023 省 Python B] 松散子序列

## 题目描述

给定一个仅含小写字母的字符串 $s$，假设 $s$ 的一个子序列 $t$ 的第 $i$ 个字符对应了原字符串中的第 $p_i$ 个字符。我们定义 $s$ 的一个松散子序列为：对于 $i > 1$ 总是有 $p_i - p_{i-1} \geq 2$。设一个子序列的价值为其包含的每个字符的价值之和（$a \sim z$ 分别为 $1 \sim 26$）。

求 $s$ 的松散子序列中的最大价值。

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$|s| \leq 10$；
- 对于 $40\%$ 的评测用例，$|s| \leq 300$；
- 对于 $70\%$ 的评测用例，$|s| \leq 5000$；
- 对于所有评测用例，$1 \leq |s| \leq 10^6$，字符串中仅包含小写字母。

## 样例 #1

### 输入

```
azaazaz```

### 输出

```
78```

# 题解

## 作者：niuniudundun (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P12379)

这是 `C++` 题解。

# Problem

假设 $s$ 的一个子序列 $t$ 的第 $i$ 个字符对应了原字符串中的第 $p_i$ 个字符。定义 $s$ 的一个松散子序列为：对于 $i>1$ 总是有 $p_i−p_{i-1}\ge 2$，一个子序列的价值为其包含的每个字符的价值之和。求 $s$ 的松散子序列中的最大价值。

# Solution

观察题目可知，对于一个 $i$，如果选，$i-1$ 和 $i$ 的差是 $1$，$1<2$，所以不能选 $i-1$；如果不选 $i$，那么这一位的价值与上一位相等。假设以第 $i$ 位结尾的最大价值是 $dp_i$，那么有：

$$
dp_i=\max(dp_{i-1},dp_{i-2}+s_{i-1})
$$

这里 $s_i$ 指字母转换数字结果（$\texttt a \sim \texttt z$ 分别为 $1\sim26$）。最后 $dp_0=0,dp_1=s_0$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+1;
string s;
int n,dp[maxn];
signed main(){
	cin>>s;
	n=s.length();
	dp[0]=0,dp[1]=s[0]-'a'+1;
	for(int i=2;i<=n;i++){
		dp[i]=max(dp[i-1],dp[i-2]+s[i-1]-'a'+1);
	}
	cout<<dp[n]<<endl;
	return 0;
}
/*	

*/
```

---

## 作者：枫原万叶 (赞：3)

# P12379 [蓝桥杯 2023 省 Python B] 松散子序列 题解

## 分析

题目大意就是说选择几个字母（两两字母不应相邻，至少空一个字母），然后把选择的字母的价值相加（字母的价值就是字母在字母表的位置）。

很明显是一道动态规划，我们考虑 $dp_i$ 是长度为 $i$ 的字符串的最大价值，那么对于当前状态，要么选当前这个位置的字母，反之则不选，如果选择了则需要考虑往前选 $2$ 个还是 $3$ 个，因为再大就可以继续在中间选择了，然后还要加上当前位置的价值。

综上所述，我们就可以得到状态转移方程。

$$ dp_i = \max (dp_{i-1},val_i+\max(dp_{i-2},dp_{i-3})) $$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1000010];

int val(char c){
    return int(c-'a'+1);
}

int main(){
    string s;
    cin>>s;
    int n = s.size();
    if(n == 0){
        cout << 0;
        return 0;
    }
    
    dp[0] = 0;
    dp[1] = val(s[0]);
    if(n >= 2){
        dp[2] = max(val(s[1]), dp[1]);
    }
    
    for(int i = 3; i <= n; i++){
        dp[i] = max(dp[i-1], val(s[i-1]) + max(dp[i-2], dp[i-3]));
    }
    
    cout << dp[n];
    return 0;
}
```

---

## 作者：htl2025 (赞：2)

## 策略：
设 $dp[i]$ 表示：考虑前 $i$ 个字符，且以第 $i$ 个字符结尾的松散子序列的最大价值。

最优选择其实只需要取 $dp[i-2]$，因为相邻要求 $\geq2$，所以最多只能跳到 $i-2$（不能取 $i-1$，因为那样间隔太近）。


于是： 
$$ dp[i]=\max(dp[i−2],dp[i−3],\cdots)+value(s[i]) $$

但因为会超时，所以我们只用**维护前缀最大值**来加速。
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    string s;
    cin >> s;
    int n = s.size();
    vector<long long> dp(n);

    dp[0] = s[0] - 'a' + 1;
    if (n > 1) dp[1] = max(dp[0], (long long)(s[1] - 'a' + 1));

    for (int i = 2; i < n; i++) {
        dp[i] = max(dp[i-1], dp[i-2] + (s[i] - 'a' + 1));
    }

    cout << dp[n-1] << endl;
}
```

---

## 作者：x11223344 (赞：2)

注意：字符串下标从 $0$ 开始。  
考虑 dp，设 $dp_i$ 表示只考虑前 $i$ 个字符的最大代价。（不一定选 $i$）  
若设 $a_i$ 代表字符串下标为 $i$ 的字符的代价。  
则有 $dp_0=a_0$，$dp_1=\max(a_0,a_1)$。  
转移：考虑 $i-1$ 选不选，则有 $dp_i=\max(dp_{i-1},dp_{i-2}+a_i)$，其中 $i \ge 2$。  
答案为 $dp_{n-1}$，其中 $n$ 为字符串长度。

---

## 作者：TODAYS (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P12379)

## 题目思路

我们定义一个 $dp_i$ 表示前 $i$ 个字母组成的松散子序列的最大价值，那么针对第 $i$ 个字母，那么就有 $2$ 中情况，要么选第 $i$ 个字母，要么不选第 $i$ 个字母，如果选第 $i$ 个字母，那么就不能选第 $i-1$ 个字母，则：$dp_{i-2} + cal(s_i)$ 还有一种可能，就是不选第 $i$ 个字母，那就可以选第 $i-1$ 个字母，则：$dp_{i-1}$。

题目要求求松散子序列价值的最大值，那么就让取上面两个的最大值即可。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int dp[N];

int cal(char c)
{
    return c - 'a' + 1;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    string s;
    cin >> s;
    int len = s.size();
    dp[0] = cal(s[0]);
    dp[1] = max(dp[0], cal(s[1]));
    for (int i = 2; i < len; ++i)
    {
        dp[i] = max(dp[i - 1], dp[i - 2] + cal(s[i]));
    }
    cout << dp[len - 1];
    return 0;
}
```

#### [AC 记录](https://www.luogu.com.cn/record/215440022)

---

## 作者：Helenty (赞：1)

显然一道线性 DP 题。

令 $f_i$ 表示以 $a_i$ 结尾的子序列的最大价值，由于松散子序列要求 $p_i - p_{i-1} \ge 2$，所以 $f_i = \max(f_{0 \sim i-2}) + a_i$。最后答案是遍历所有 $f_i$，找一个最大值。

而这样写显然会超时，所以要优化代码。

我们发现 $f_{i-2}$ 一定大于 $f_{i-4}$，且 $f_{i-3}$ 一定大于 $f_{i-5}$，因此内层循环可以转化成只比较 $f_{i-2}$ 和 $f_{i-3}$ 的大小即可。

附上代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    string s;
    cin >> s; // 读取输入字符串
    int l = s.length(); // 获取字符串长度
    vector<int> f(l + 5, 0); // 初始化动态规划数组，大小为 l+5，初始值为 0

    for (int i = 0; i < l; ++i) {
        if (i - 2 >= 0) f[i] = max(f[i], f[i - 2]); // 更新 f[i]，考虑 i-2 的情况
        if (i - 3 >= 0) f[i] = max(f[i], f[i - 3]); // 更新 f[i]，考虑 i-3 的情况
        f[i] += s[i] - 'a' + 1; // 将当前字符的值加到 f[i] 中
    }

    int res = 0;
    for (int i = 0; i < l; ++i) {
        res = max(res, f[i]); // 找到 f 数组中的最大值
    }

    cout << res << endl; // 输出结果
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P12379 题目](https://www.luogu.com.cn/problem/P12379)

### 解题思路
设 $dp_i$ 为前 $i$ 个字符组成的字符串中的松散子序列中的最大价值，易知对于第 $i$ 个字符我们有选或不选两种状态，若选，则第 $i-1$ 个字符就不能选，即 $dp_i=\max(dp_{i-1},dp_{i-2}+v_i)$，其中 $v_i$ 表示第 $i$ 种字符的价值。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[1000001];
signed main()
{
    ios::sync_with_stdio(false);
    string s;
    cin>>s;
    dp[1]=s[0]-'a'+1,dp[2]=max(s[0]-'a'+1,s[1]-'a'+1);
    for(int i=3;i<=s.size();i++)
    	dp[i]=max(dp[i-2]+s[i-1]-'a'+1,dp[i-1]);
    cout<<dp[s.size()];
    return 0;
}
```

---

## 作者：ArenaBreakout78 (赞：0)

# 题解：P12379 [蓝桥杯 2023 省 Python B] 松散子序列

温馨提示，此篇题解为 `C++` 版本。

## 思路：

松散子序列的条件可以理解为不能选择相邻的字符。因此，我们需要在字符串中选择字符，使得相邻选择的字符在原字符串中的位置差至少为 `2`，同时使得这些字符的价值之和最大。

那么，我们就可以使用动态规划来完成这道题。也就是定义一个 $dp[i]$ 表示前 $i$ 个字符中松散子序列的最大价值。则状态转移方程如下：

- 如果选择第 $i$ 个字符，那么就不能选择第 $i-1$ 个字符，则：

$$dp[i]=dp[i-2] + value(s[i-1])$$

- 如果不选择第 $i$ 个字符，则：

$$dp[i] = dp[i-1]$$

所以，最终的状态转移方程为：

$$dp[i] = max(dp[i-1],dp[i-2] + value(s[i-1]))$$

注意：记得初始化，$$dp[0] = 0$$，$$dp[1] = value(s[0])$$。

所以，最终的代码如下：

## AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin>>s;
    int n=s.size();
    if(n==0){
        cout<<0;
        return 0;
    }
    int dp[n+1];
    dp[0]=0;
    dp[1]=s[0]-'a'+1;
    for(int i=2;i<=n;i++){
        dp[i]=max(dp[i-1],dp[i-2]+(s[i-1]-'a'+ 1));
    }
    cout<<dp[n];
    return 0;
}
```

---


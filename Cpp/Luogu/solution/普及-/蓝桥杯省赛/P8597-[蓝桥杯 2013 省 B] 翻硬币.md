# [蓝桥杯 2013 省 B] 翻硬币

## 题目背景

小明正在玩一个“翻硬币”的游戏。

## 题目描述

桌上放着排成一排的若干硬币。我们用 `*` 表示正面，用 `o` 表示反面（是小写字母，不是零），比如可能情形是 `**oo***oooo`，如果同时翻转左边的两个硬币，则变为 `oooo***oooo`。现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？


## 说明/提示

source：蓝桥杯 2013 省 B 组 H 题

## 样例 #1

### 输入

```
**********
o****o****```

### 输出

```
5```

## 样例 #2

### 输入

```
*o**o***o***
*o***o**o***```

### 输出

```
1```

# 题解

## 作者：sw2022 (赞：57)

## 题意简析

因为把相邻两个硬币翻转两次相当于不翻，所以最优方案中同一组硬币最多只会翻转一次，故翻转顺序无后效性，考虑贪心：从前往后比较，发现一个不同的硬币就把它和他后面的硬币翻转，计数器累加，这样最后累加结果一定是最优方案的次数。

## 代码/解释
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int main()
{
	cin>>a>>b;
	int l=a.size(),s=0,i;
	for(i=0;i<l;i++)
	if(a[i]!=b[i])
	{
		a[i]=a[i]=='o'?'*':'o';
		a[i+1]=a[i+1]=='o'?'*':'o';
		s++;
	}
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：Vct14 (赞：31)

思路：

- 由于不会有无解的情况，我们可以从左至右依次循环遍历 $a$ 字符串的每一个字符，判断是不是与 $b$ 串相应的字符相等。
- 若不相等，翻转这枚和下一枚（他右边的）硬币。
- 这里可以偷个懒，由于之后不会再用到这枚硬币，可以不翻，只翻下一枚。

代码：

```c++
#include<bits/stdc++.h>
using namespace std;
 
char a[1005];
char b[1005];
 
int main(){
    cin>>a>>b;
    int len=strlen(a);
    int i=0,sum=0;
    while(i<len){
        if(a[i]!=b[i]){
        	a[i+1]=(a[i+1]=='*'?'o':'*');
            sum++;
        }
        i++;
    }
    cout<<sum;
    return 0;
}
```

没有理解第 $13$ 行的小伙伴继续往下看：

$a?b:c$ 表示：

- 若 $a$ 为真，返回 $b$ 值。
- 若 $a$ 为假，返回 $c$ 值。

---

## 作者：哈士奇憨憨 (赞：20)

## 思路
求最小翻动次数，明显可以用贪心写法（其实模拟、dp 和其他很多算法也可以）。通过观察可得知，所有不同段长度的总和（第一个开始不同的硬币和第二个不同的硬币即为不同段）。

证明：很明显，一个硬币最多被翻转两次，再翻转多了翻转就必定无意义。不同段是一定要从开始不同时翻转，这会导致下一个位置的硬币也会翻转，但不同段中间的硬币是相同的，所以需要翻回来，然后重复之前的情况，到不同段最后一枚硬币才会停止。

虽然题目说了没有无解情况，但还是提一句，如果不同硬币的数量奇偶性不同，则无解。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
string a, b;
int ans, bg = -1, n;
int main(){
	cin >> a >> b;
	n = a.length();
	for(int i = 0; i < n; i++){
		if(a[i] != b[i]){
			if(bg == -1){//找第一个不同的硬币
				bg = i;
			}else{ 
				ans += (i - bg);//找到第二个不同的硬币
				bg = -1;//接着找下一个不同段 
			}
		}
	}
	cout << ans;
	return 0; 
}
```

---


# [蓝桥杯 2016 省 AB] 四平方和

## 题目描述

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 $4$ 个正整数的平方和。

如果把 $0$ 包括进去，就正好可以表示为 $4$ 个数的平方和。

比如：

$5=0^2+0^2+1^2+2^2$。

$7=1^2+1^2+1^2+2^2$。

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 $4$ 个数排序使得 $0 \le a \le b \le c \le d$。

并对所有的可能表示法按 $a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2016 年第七届省赛

蓝桥杯 2016 年省赛 A 组 H 题（B 组 H 题）。

## 样例 #1

### 输入

```
5```

### 输出

```
0 0 1 2```

## 样例 #2

### 输入

```
12```

### 输出

```
0 2 2 2```

## 样例 #3

### 输入

```
773535```

### 输出

```
1 1 267 838```

# 题解

## 作者：封禁用户 (赞：26)

## 分析

**【主体思路】**

对于每个 $n$，我们可以去枚举 $a,b,c$ 的值，因为在 $n=a^2+b^2+c^2+d^2$ 时，$d$ 一定是等于 $\sqrt {n-a^2-b^2-c^2}$ 的。而 $a,b,c,d$ 又都是整数，所以我们只需要看 $d$ 的值是不是整数就行啦。

**【边界判断】**

因为题目保证 $a \le b \le c \le d$，所以在枚举 $a$ 时，若 $a^2+a^2+a^2+a^2>n$，则一定无法再有可能情况了，$b,c$ 同理。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int check(int a,int b,int c,int d){return a*a+b*b+c*c+d*d;}
//求a^2+b^2+c^2+d^2
int main()
{
	cin>>n;
	for(int i=0;;i++)
	{
		if(check(i,i,i,i)>n) break;//边界判断
		for(int j=i;;j++)
		{
			if(check(i,j,j,j)>n) break;
			for(int k=j;;k++)
			{
				if(check(i,j,k,k)>n) break;
				else
				{
					int s=sqrt(n-check(i,j,k,0));
					if(check(i,j,k,s)==n) return cout<<i<<" "<<j<<" "<<k<<" "<<s,0; 
				}
			}
		}
	}
}
```


---

## 作者：ccg12345 (赞：13)

### 思路
先从 $0$ 到 $n$ 枚举 $i,j,k$（平方和均不能超过 $n$），再使用 $\sqrt{n - i^2 - j^2 - k^2}$ 求出第四个数。如果第四个数为整数，则输出即可。
附代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin >> n;
    for(register int i = 0; i * i <= n; i++)
    {
        for(int j = 0; i * i + j * j <= n; j++)
        {
            for(int k = 0; i * i + j * j + k * k <= n; k++)
            {
                int t = n - i * i - j * j - k * k;
                int m = sqrt(t);
                if(m * m == t)
                {
                    cout << i << " " << j << " " << k << " " << m << endl;
                    return 0;
                }
            }
        }
    }
    return 0;
}
```


---

## 作者：linxuanrui (赞：3)

### 思路

暴力枚举。不过要加亿些优化。（为了方便，这里将第一个数设为 $i$，第二个数设为 $j$，第三个数设为 $k$，第四个数设为 $l$）

1. 在枚举 $i$ 的时候，$i^2$ 要小于 $n$，不然 $i^2+j^2+k^2+l^2$ 肯定会大于 $n$。

2. 我们只需要枚举 $i$、$j$ 和 $k$，因为 $l=\sqrt{n-i^2+j^2+k^2}$。

### 代码

```cpp
#pragma GCC optmize(2,3,"Ofast","inline")
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
int n;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 0;i * i <= n;i++){
		for(int j = 0;i * i + j * j <= n;j++){
			for(int k = 0;i * i + j * j + k * k <= n;k++){
				int t = n - i * i - j * j - k * k;
				if(sqrt(t) == floor(sqrt(t))){
					cout << i << " " << j << " " << k << " " << sqrt(t) << endl;
					return 0;
				}
			}
		}
	}
}
```

---

## 作者：ダ月 (赞：2)

显然直接暴力肯定怼不过去，时间复杂度为 $O(\sqrt{n}^4)=O(n^2)$

剪枝 $1$：

我们可以从小到大选 $i,j,k$，第四个数 $s=\sqrt{n-i^2-j^2-k^2}$，要求根号内的数为完全平方数。可以将复杂度优化到 $O(n\sqrt{n})$。

剪枝 $2$：

若 $\sqrt s\le k$，可以直接退出循环。因为我们保证枚举升序。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
//===
//缺省源
//===
int n;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n;
	for(int i=0;i*i<=n;i++)
		for(int j=i;j*j<=n-i*i;j++)
			for(int k=j;k*k<=n-i*i-j*j;k++){
				int p=n-i*i-j*j-k*k;
				int r=int(sqrt(p));
				if(r<k)break;
				if(p==r*r){
					int a[4]={i,j,k,r};
					for(int s=0;s<4;s++)
						printf("%d ",a[s]);
					return 0;
				}
			}
	return 0;
}






```


---

## 作者：haozinojc (赞：2)

这题**暴力枚举加一点剪枝**就行了。

### 思路：

直接暴力枚举肯定不行，$O(n^2)$ 的时间复杂度直接教你做人。但稍微加一点点剪枝就可以过了。

对于第四个数，我们可以这么求：$d=\sqrt{n-a^2-b^2-c^2}$。

而前面三个循环，我们只要保证前三个的值的平方加起来小于 $n$ 即可。

只要加上剪枝，就一定能过。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
signed main(){
	cin>>n;
	for(int i=0;i*i<=n;i++){
		for(int j=i;i*i+j*j<=n;j++){
			for(int k=j;i*i+j*j+k*k<=n;k++){
				int l=(int)(sqrt(n-i*i-j*j-k*k));
				if(i*i+j*j+k*k+l*l==n){
					printf("%lld %lld %lld %lld",i,j,k,l);
					return 0;
				}
			}
		}
	}
	return 0;
}

```


---

## 作者：Lemonlwl (赞：2)

## P8635 [蓝桥杯 2016 省 AB] 四平方和 题解

### 题意：
对于给定的任意正整数 $n$，都有四个正整数的平方和与它相等，现要求求出这四个数。

------------
### 思路：
先暴力枚举出前三个数的每一种情况，接着算出第四个数，判断第四个数是否是一个正整数，如果是，则直接输出。

------------
附上 [AC](https://www.luogu.com.cn/record/108526197) 代码：

```cpp
#include<iostream>
#include<cmath>
/*此代码要用到sqrt()函数，加上cmath头文件*/
using namespace std;
int n;  //给定正整数。
int main(){
	cin>>n;  //输入。
	for(int a=0;a*a<=n;a++){  //枚举第一个数，“a*a”是为了减少不需要枚举的情况。
		for(int b=0;a*a+b*b<=n;b++){  //第二个，同上。
			for(int c=0;a*a+b*b+c*c<=n;c++){  //第三个，同上。
				if(double(int(sqrt(n-a*a-b*b-c*c)))==double(sqrt(n-a*a-b*b-c*c))){  //判断第四个数是否为正整数。
					cout<<a<<" "<<b<<" "<<c<<" "<<sqrt(n-a*a-b*b-c*c)<<endl;  //是则输出四个数。
					return 0;  //直接结束程序。
				}
			}
		}
	}
	return 0;
}
```
点个赞再走呗。

---

## 作者：Li2021 (赞：1)

## P8635 四平方和 题解

### 解题思路

设三个数 $i,j,k$，先枚举 $i,j,k$ 的平方和（都不能超过 $n$），再用 $\sqrt{n-i^2-j^2-k^2}$ 求出第四个数，如果第四个数为整数，那么就输出结果。

### Code

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int n;
int main(){
	cin>>n;
	for(int i=0;i*i<=n;i++){
		int i2=i*i;
		for(int j=0;i2+j*j<=n;j++){
			int j2=j*j;
			for(int k=0;i2+j2+k*k<=n;k++){
				int k2=k*k,x=n-i2-j2-k2,gx=sqrt(x);
				if(gx*gx==x)  return cout<<i<<" "<<j<<" "<<k<<" "<<gx,0;
			}
		}
	}
	return 0;
}
```



---

## 作者：andyli (赞：1)

三重循环枚举 $a,b,c$，再判断 $n-a^2-b^2-c^2$ 是否为完全平方数。并符合范围即可。

一般情况下 $x$ 较小时可以用 `int(sqrt(x)) * int(sqrt(x)) == x` 来判断 $x$ 是否为完全平方数。  

```cpp
int main() {
    dR(int, n);
    for (int a = 0; a * a <= n; a++)
        for (int b = a; a * a + b * b <= n; b++)
            for (int c = b; a * a + b * b + c * c <= n; c++) {
                int t = n - a * a - b * b - c * c, d = sqrt(t);
                if (d * d == t && d >= c)
                    return writeln({a, b, c, d}), 0;
            }
    return 0;
}
```

---

## 作者：Red0rangE (赞：1)

## 题意理解

给出一个整数 $n$，求四个平方和为 $n$ 的非负整数。

输出四个整数，从小到大。

## 思路阐述

看见时间限制（算法标签）首先想到枚举，三层循环加上一点点优化即可。

每下一层循环从当前数字开始，最后一个数不用管，因为这种情况会在之前的枚举中以正确的排列方式出现。

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

signed main(){
    
    scanf("%d",&n);//输入
    for(int i=0;i*i<=n;i++)//循环第一个数（最小的）
        for(int j=i;i*i+j*j<=n;j++)//循环第二个数（第二小的）
            for(int k=j;i*i+j*j+k*k<=n;k++){//循环第三个数（第三小的）
                int l=int(sqrt(n-i*i-j*j-k*k));//算出第四个数
                if(i*i+j*j+k*k+l*l==n){
                    printf("%d %d %d %d",i,j,k,l);
                    return 0;
                }
            }
}
```


---

## 作者：VitrelosTia (赞：1)

~~蓝桥杯不愧为暴力杯啊！~~

暴力从 $0$ 到 $\sqrt{n}$ 枚举前三个数 $a, b, c$，此时可以算出 $d = n - \sqrt{a} - \sqrt{b} - \sqrt{c}$，判断 $\sqrt{d}$ 是否为整数且满足题意即可。

```
#include <bits/stdc++.h>
#define F(i, r) for (int i = 0, END## i = sqrt(r); i <= END## i; i++)
#define sq(n) n * n
using namespace std;

int main() {
    int n;
    scanf ("%d", &n);
    F(i, n) {
        F(j, n) {
            F(k, n) {
                int l = sqrt(n - sq(i) - sq(j) - sq(k));
                if (l != (int)floor(l)) continue;
                if (sq(i) + sq(j) + sq(k) + sq(l) == n) {
                    printf ("%d %d %d %d\n", i, j, k, l);
                    return 0;
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：xiaoming007 (赞：0)

## 思路

一点一点枚举 $i,j,k$ 的范围，然后由于 $i^2+j^2+k^2+l^2=n$，所以我们可以直接用 $\sqrt {n-i^2-j^2-k^2}$ 求出 $l$，最后判断 $i^2+j^2+k^2+l^2$ 是否为 $n$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
signed main(){
    int n;
	scanf("%lld",&n);
	for(int i=0;i*i<=n;i++)
		for(int j=i;i*i+j*j<=n;j++)
			for(int k=j;i*i+j*j+k*k<=n;k++){
				int l=(long long)(sqrt(n-i*i-j*j-k*k));
				if(i*i+j*j+k*k+l*l==n)
					return printf("%lld %lld %lld %lld",i,j,k,l), 0;
			}	
}

```

---

## 作者：what_can_I_do (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8635)

这题暴力枚举就行了。$a\times a$ 枚举 $a$ 到 $n$，$a\times a+b\times b$ 枚举 $b$ 到 $n$，$a\times a+b\times b+c\times c$ 枚举 $c$ 到 $n$，最后判断 $n-a\times a-b\times b-c\times c$ 开根号是否为整数，为整数就输出。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
    scanf("%d",&n);
    for(register int i=0;i*i<=n;i++)
    	for(register int j=0;i*i+j*j<=n;j++)
    		for(register int k=0;i*i+j*j+k*k<=n;k++)
    		{
    			int x=n-i*i-j*j-k*k,l=sqrt(x);
    			if(l*l==x){printf("%d %d %d %d",i,j,k,l);return 0;}
			}
    return 0;
}
```

---

## 作者：yangmingshuo114514 (赞：0)

从 $ 0 $ 到 $ \sqrt n $ 暴力枚举 $ a , b , c $，则有 $ d = \sqrt { n - a ^ 2 - b ^ 2 - c ^ 2 } $。此时判断 $ d $ 是否为整数，如果为整数，就输出。

判断 $ d $ 是否为整数，只要判断 $ a ^ 2 + b ^ 2 + c ^ 2 + { \lfloor d \rfloor } ^ 2 $ 是否与 $ n $ 相等即可。

代码如下：

```cpp

#include<cstdio>
#include<cmath>
int n;
int main(){
	scanf("%d",&n);
	for(int i=0;i*i<=n;i++)
		for(int j=i;i*i+j*j<=n;j++)
			for(int k=j;i*i+j*j+k*k<=n;k++){
				int l=int(sqrt(n-i*i-j*j-k*k));
				if(i*i+j*j+k*k+l*l==n){
					printf("%d %d %d %d",i,j,k,l);
					return 0;
				}
			}	
}

```

---


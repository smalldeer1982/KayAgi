# [蓝桥杯 2017 省 AB] 分巧克力

## 题目描述

儿童节那天有 $K$ 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 $N$ 块巧克力，其中第 $i$ 块是 $H_i \times W_i$ 的方格组成的长方形。

为了公平起见，小明需要从这 $N$ 块巧克力中切出 $K$ 块巧克力分给小朋友们。切出的巧克力需要满足：

1. 形状是正方形，边长是整数。

2. 大小相同。

例如一块 $6 \times 5$ 的巧克力可以切出 $6$ 块 $2 \times 2$ 的巧克力或者 $2$ 块 $3 \times 3$ 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小 $H_i$ 计算出最大的边长是多少么？

## 说明/提示

蓝桥杯 2022 省赛 A 组 I 题。

## 样例 #1

### 输入

```
2 10  
6 5  
5 6  ```

### 输出

```
2```

# 题解

## 作者：_xbt (赞：47)

[题目传送门](https://www.luogu.com.cn/problem/P8647)

因为这道题中 $N$ 和 $K$ 都较大，暴力枚举必然超时，所以想到**二分答案**。

那么二分答案行不行呢，我们通过观察发现答案具有**单调性**，我们就可以使用二分答案。所有可能的边长为 $1$ 到 $10^5$，每次判断当前边长是否满足 $K$。若满足，则 $l$ 更新，不满足则 $r$ 更新。

对于第 $i$ 块巧克力，当边长为 $x$ 时，可以分出 $\left\lfloor (a_i \div x) \times (b_i \div x) \right\rfloor$ 块巧克力。

# $\text{code}$
```cpp
#include<iostream>
using namespace std;
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
int n,k,a[100010],b[100010];
int check(int x){
	int ans=0;
	for(int i=0;i<n;i++) ans+=(a[i]/x)*(b[i]/x);
	return ans>=k;
}
int main(){
	IOS;
	cin>>n>>k;
	for(int i=0;i<n;i++) cin>>a[i]>>b[i];
	int l=1,r=100000;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
}
```

---

## 作者：kkxacj (赞：19)

[题目传送门](https://www.luogu.com.cn/problem/P8647)


#### 思路

思路很简单，暴力枚举，但要注意一些优化点。

1. 当已经够 $k$ 块巧克力时，直接退出计算，避免浪费时间。

1. 当算完一遍后，还不满足 $k$，那么以后也一定不会再大于 $k$，直接结束循环，然后输出。


code
```c
#include<bits/stdc++.h>
#define LL long long     
using namespace std;
int n,l,k,a[1000010],b[1000010],w = 1,o;
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%d",&n,&k); l = n;
	for(int i = 1;i <= n;i++) scanf("%d%d",&a[i],&b[i]),l = max(l,max(a[i],b[i]));//巧克力的边长一定小于等于输入长度
	for(int i = 1;i <= l;i++)
	{
		int o = 0;
		for(int j = 1;j <= n;j++) 
		{
			o += (a[j] / i) * (b[j] / i);//计算
			if(o >= k) break;
		}
		if(o < k) break;
		w = i;
	}
	printf("%d",w);
    return 0;
}
```


---

## 作者：_Spectator_ (赞：10)

[可能更好的食用体验](/blog/523641/P8647) $|$ 
[题目传送门](/problem/P8647) $|$ 
[我的其他题解](/blog/523641/#type=题解-New)

------------

${\large\color{#00CD00}\text{思路}}$

由于答案具有单调性，因此考虑使用二分答案。

若当前的边长为 $x$，不难得到对于第 $i$ 块巧克力，可以切出 $\lfloor\frac{h_i}{x}\rfloor\times\lfloor\frac{w_i}{x}\rfloor$ 块 边长为 $x$ 的巧克力。因此可以求出总共可以切出多少块边长为 $x$ 的巧克力，如果大于等于 $k$，则该答案可行，否则不可行。

------------

${\large\color{#00CD00}\text{代码}}$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
long long n,k;
int h[maxn],w[maxn];
bool ok(int x)
{
	int cnt=0;
	for(int i=1;i<=n;i++)
		cnt+=(h[i]/x)*(w[i]/x);
	return cnt>=k;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>h[i]>>w[i];
	int l=0,r=1e5;
	while(l+1<r)
	{
		int mid=(l+r)/2;
		if(ok(mid))l=mid;
		else r=mid;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：Vct14 (赞：6)

二分题，每次判断当前边长 $\operatorname{mid}$ 是否符合要求。

由于已知每块巧克力可以切的块数均为 $\dfrac{H}{\operatorname{mid}}\times \dfrac{W}{\operatorname{mid}}$，所以判断所有巧克力切出的块数相加是否大于等于 $k$ 即可。

```
#include<bits/stdc++.h>
using namespace std;

int n,k;
int h[100002];
int w[100002];

bool check(int x){//判断是否大于等于 k
	int s=0;
	for(int i=1; i<=n; i++) s+=(h[i]/x)*(w[i]/x);
	if(s>=k) return true;
	else return false;
}

int main(){
	cin>>n>>k;
	for(int i=1; i<=n; i++) cin>>h[i]>>w[i];
	int l=1,r=100002;
	while(l<r){//二分
		int mid=(l+r+1)/2;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：MspAInt (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P8647)

二分板子。

二分需要一个重要的性质：答案满足单调性。

这题的单调性显然为：分出的巧克力边长越大，能分出的块数越少。于是可以使用二分求出答案。

为了方便，我们设定二分区间为 $[1,10^9]$。这是不会超时的，$2^{30}$ 就已经大于右区间了，然而就算是对它取 log 也仅为 $30$，几乎可以视为常数级别。

接着就是二分条件。对于每一次二分出的 $mid$ 值（分给每个小朋友的巧克力的边长），我们运用小学知识可以很轻易地求出每块巧克力可分出的数量：$\left\lfloor\frac{H_i}{mid}\right\rfloor\times\left\lfloor\frac{W_i}{mid}\right \rfloor$。如果得数小于小朋友数（不够分），就往左区间继续尝试（缩小边长），否则往右区间尝试（扩大边长）。一旦区间长度被缩小到 $1$，就说明找到了答案，输出即可。

二分查找复杂度 $\Theta(\log n)$，每次验证复杂度 $\Theta(n)$，总时间复杂度 $\Theta(n\log n)$，可以通过本题。

---

## 作者：Samson2010 (赞：5)

# 思路
显而易见当每个正方形变大，那么分的块数越少，具备可二分性，可以进行二分答案。二分每个正方形的边长，那么能分割出来的块数则有
```cpp
for(int i=1;i<=n;i++) cnt+=(a[i]/x)*(b[i]/x);
```
# 代码&注释
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],b[100005],k;
bool check(int x)
{
	int cnt=0;
	for(int i=1;i<=n;i++) cnt+=(a[i]/x)*(b[i]/x);
	return cnt>=k;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
	int l=1,r=100000;
	while(l<r)
	{
		int mid=(l+r+1)/2;//r=mid-1时mid=(l+r+1)/2,否则会超时
		if(check(mid)) l=mid;//cnt≥k，说明答案太大了
		else r=mid-1; 
	}
	cout<<l;
    return 0;
}
```




---

## 作者：ZKqwq (赞：2)

#### 思路

经过观察发现答案有单调性，很明显使用二分答案。我们可以二分正方形边长的长度，判断以该长度为边长时能够分得的块数是否大于等于 $k$，如果大于等于 $k$，则边长还可能更大，继续缩小取值范围；否则则需要缩小边长。在每次检查时，遍历每块巧克力，判断这块巧克力最多能切出多少个以当前边长为边长的正方形，并维护一个总和，看是否大于等于 $k$ 。具体实现中，由于矩形并不唯一，要考虑进行两种存储 $\min \left ( H_i,W_i \right ) $ 和 $\max \left ( H_i,W_i \right ) $ 以便后续计算。时间复杂度 $ O\left ( N\log W  \right ) $。其中，$W$ 表示二分答案的上界，即 $\max \left ( H_i,W_i \right ) $ 的最大值。因为边长尽量大，所以瓶颈在于计算以巧克力为标准进行划分所需时间数量级为 $ O\left ( N\right ) $。

#### 代码

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1e5 + 10;

int n, k;
int h[N], w[N];

bool check(int mid){ //判断边长为 mid 是否能分出 k 块巧克力
    int cnt = 0;
    for(int i = 0; i < n; i++){
        cnt += (h[i] / mid) * (w[i] / mid);
        if(cnt >= k) return true;
    }
    return false;
}

int main(){
    cin >> n >> k;
    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];
    int l = 1, r = 1e5;
    while(l < r){
        int mid = (l + r + 1) / 2; //注意向上取整
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    cout << l << endl;
    return 0;
}

```

---

## 作者：SilverLi (赞：2)

[分巧克力 の 传送门](https://www.luogu.com.cn/problem/P8647)

考虑二分。

二分答案，即可能的边长为 $1\sim 100000$，每次判断按照当前边长切分出的巧克力数量是否大于等于 $k$，若大于，则满足要求，左指针 $l$ 更新，否则右指针 $r$ 更新。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, k, h[N], w[N];
int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) scanf("%d%d", &h[i], &w[i]);
    int l = 1, r = 1e5;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        long long s = 0;
        for (int i = 1; i <= n; i++) {
            int x = h[i] / mid, y = w[i] / mid;
            s += x * 1ll * y;
        }
        if (s >= k) l = mid;
        else r = mid - 1;
    }
    cout << l << endl;
    return 0;
}
```

---

## 作者：sherry_lover (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8647)
 
 这道题的考点：二分.
 

------------
这道题由于 $N,K$ 较大，考虑二分答案的方法。

我们已知答案为 $1\sim10^5$,一直二分下去，每次都判断切边长为 $mid$ 的正方形数是否满足要求。

如何求出边长为 $mid$ 的正方形数呢？

对于第 $i$ 个巧克力，它边长为 $mid$ 的正方形数为 $(h_i \div mid)\times(w_i \div mid)$，只要判断这个结果是否大于 $K$ 即可。

标程在这里：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,h[100050],w[100050],mid;
int main()
{
	cin >> n >> k;
	for(int i = 1;i <= n;i++) cin >> h[i] >> w[i];
	int l = 1,r = 100000,ans;
	while(l < r){//二分 
		ans = 0;
		mid = (l+r+1)/2;
		for(int i = 1;i<=n;i++)
			ans += (h[i]/mid)*(w[i]/mid);//正方形个数 
		if(ans >= k) l = mid;
		else r = mid-1;
	}
	cout << l;
	return 0;
}
```
文明洛谷，禁止Copy!

---

## 作者：rainygame (赞：1)

一眼二分答案。

不懂二分查找/二分答案的可以看[这里](https://oi-wiki.org/basic/binary/)。

首先设置上下界。显然，最惨的情况下就是 $1$（题目保证），最好的情况下就是最长的那条边的边长。

我们再研究 `check` 函数的写法，可以发现，我们可以枚举每一块巧克力，判断它可以分成几块 $x\times x$ 的正方形，然后再求和。最后判断一共可以切的块数是否 $\ge k$ 就可以了。

然后套一个二分模板，这道题就结束了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100001;

int n, k, maxn;
int a[MAXN], b[MAXN];
 
bool check(int x){
    long long ans = 0;
    for (int i=1; i<=n; i++) ans += (a[i]/x)*(b[i]/x);
    return ans >= k;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    cin >> n >> k;
    
    for (int i=1; i<=n; i++){
    	cin >> a[i] >> b[i];
        maxn = max({maxn, a[i], b[i]});
    }
    
    int l = 0, r = maxn+1, mid;
    while (l < r){
        mid = (l+r) >> 1;
        if (check(mid)) l = mid+1;
        else r = mid;
    }
    cout << l-1;
    
    return 0;
}

```


---

## 作者：watcher_YBH (赞：1)

# 思路：
这道题对于每一个边长可以切出的蛋糕的块数为单调递增的，所以我们可以从 $1 \sim 10^5$ 的范围中去二分答案：如果这个边长可切出的块数满足要求，更新 $l$ 寻找更大的边长，否则更新 $r$ 寻找满足要求的边长。
# 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAX = 1e5+5;
int n,k,ans;
int l,r,mid;//左边、右边、中间值
int h[MAX],w[MAX];
int cut(int k,int x){//计算这个边长能切的块数
	int a = h[k]/x;
	int b = w[k]/x;
	return a*b;
}
int main(){
	cin>>n>>k;
	for(int i = 1; i<=n; i++)
		cin>>h[i]>>w[i];
	l = 1;  r = 1e5;
	while(l < r){
		ans = 0;//总块数
		mid = (l + r + 1)/2;
		for(int i = 1; i<=n; i++)
			ans += cut(i,mid);
		if(ans >= k) l = mid;//找更大的
		else r = mid-1;//找满足要求的
	}
	cout<<l<<endl;//输出
	return 0;
}
```


---


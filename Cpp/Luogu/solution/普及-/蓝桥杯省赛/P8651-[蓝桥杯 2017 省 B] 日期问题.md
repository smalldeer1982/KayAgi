# [蓝桥杯 2017 省 B] 日期问题

## 题目描述

小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在 1960 年 1 月 1 日至 2059 年 12 月 31 日。令小明头疼的是，这些日期采用的格式非常不统一，有采用`年/月/日`的，有采用`月/日/年`的，还有采用`日/月/年`的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  

比如 `02/03/04`，可能是 2002 年 03 月 04 日、2004 年 02 月 03 日或 2004 年 03 月 02 日。  

给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？

## 样例 #1

### 输入

```
02/03/04```

### 输出

```
2002-03-04  
2004-02-03  
2004-03-02  ```

# 题解

## 作者：CleverRaccoon (赞：61)

## 分析

本题的年份已经给定了范围，所以直接枚举即可，**不会超时**。

## 思路

使用**三重循环**，第一层循环枚举年份，第二层循环枚举月份，第三层循环枚举天数。

可以使用一个数组来记录每个月的天数，不用逐个月来判断。

口诀：**一三五七八十腊，三十一天永不差，四六九冬三十日，平年二月二十八，闰年二月把一加。**

那么如何判断一个年份是否是闰年呢？一个年份是闰年，当且仅当它满足以下两种条件之一：

1. 年份是 $4$ 的倍数但不是 $100$ 的倍数。

2. 年份是 $400$ 的倍数。

判断闰年的代码很简单，只需要进行基本逻辑上面的判断即可：

```cpp
inline bool isLeapYear(int y) {
    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
}

```

题目中说，格式有三种可能，所以我们要判断这三种情况。

1. 『年月日』的格式：

```cpp
a == year % 100 && b == month && c == day
```

2. 『月日年』的格式：

```cpp
a == month && b == day && c == year % 100
```

3. 『日月年』的格式：

```cpp
a == day && b == month && c == year % 100
```

注意，由于输入的年份只有两位，判断时**要把枚举出来的年份对 $100$ 取模**，这样就可以得到它的后两位，可以进行比较了。

输出格式也要非常注意：月和日前要**补零**！

```cpp
printf("%d-%02d-%02d\n", year, month, day);
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int StartYear = 1960, EndYear = 2059;

/*
一三五七八十腊，
三十一天永不差，
四六九冬三十日，
平年二月二十八，
闰年二月把一加。
*/
int daysOfMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};        

// 判断是否为闰年
inline bool isLeapYear(int y) {
    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
}

int main() {
    int a, b, c;
    scanf("%d/%d/%d", &a, &b, &c);
    for(int year = StartYear; year <= EndYear; ++year) { // 1960年到2059年
        daysOfMonth[2] = (isLeapYear(year) ? 29 : 28);  // 根据是否是闰年来修改二月的天数
        for(int month = 1; month <= 12; ++month)
            for(int day = 1; day <= daysOfMonth[month]; ++day)
                if((a == year % 100 && b == month && c == day) ||
                   (a == month && b == day && c == year % 100) ||
                   (a == day && b == month && c == year % 100))  // 判断是否符合条件
                    printf("%d-%02d-%02d\n", year, month, day); // 注意输出的格式
    }
    return 0;
}
```

题解结束了，有什么问题欢迎私信交流，谢谢大家！


---

## 作者：SunnyLi (赞：20)

[题目传送门](https://www.luogu.com.cn/problem/P8651)

蒟蒻又来交 Python 题解啦。

## 思路

年份从 $1960$ 到 $2059$，可以三重循环枚举，肯定不会超时。

主要是有几点很坑或者很麻烦：

1. 判断闰年，$2$ 月要写判断。

2. 输出要排序。

3. 前面可能要补 $0$。

4. 输入有 `/`，在 Python 中 `input().split("/")` 就可以啦。

5. 输出要带 `-`，Python 的字符串可以直接相加拼在一起。

（这就是我用 Python 的原因）

## AC 代码

```python
def isLY(x):
    return (x%4==0 and x%100!=0)or(x%400==0);

days = [0,31,28,31,30,31,30,31,31,30,31,30,31]
a,b,c = input().split("/")
a,b,c = int(a),int(b),int(c)

for i in range(1960,2060):
    if(isLY(i)):    days[2]=29;
    else:   days[2]=28;
    for j in range(1,13):
        for k in range(1,days[j]+1):
            t = i%100
            if (a==t and b==j and c==k) or (a==k and b==j and c==t) or (a==j and b==k and c==t):
                sa = str(i)
                if(j<=9):    sb = "0"+str(j)
                else:   sb = str(j)
                if(k<=9):    sc = "0"+str(k)
                else:   sc = str(k)
                print(sa+"-"+sb+"-"+sc)
```

[AC 记录](https://www.luogu.com.cn/record/108602594)

给个赞再走吧 qwq。

---

## 作者：I_like_magic (赞：13)

这是让我最崩溃的一道橙题了。

整整 11 次提交才 AC。

这道题有几个要点必须注意：

- 判断日期是否合理。

- 按顺序输出。

- 判断重复的日期。

---

首先，我们来看怎么判断日期是否合理。

我们知道大月有 $31$ 天，小月有 $30$ 天，二月看平年闰年。

所以，我们可以写出这样的代码：

```cpp
bool check(int y,int m,int d){
    if(d<=0)return 0;//特判
    if(m==1||m==3||m==5||m==7||m==8||m==10||m==12){//大月
        if(d<=31)return 1;
    }
    if(m==4||m==6||m==9||m==11){//小月
        if(d<=30)return 1;
    }
    if(m==2){//二月
        if(y%4==0){//闰年
            if(d<=29)return 1;
        }else{//平年
            if(d<=28)return 1;
        }
    }
    return 0;
}
```

---

接下来，我们需要按顺序输出日期。

我们发现，只有 $A$ 和 $C$ 会做年份，此时只要判断 $A$ 和 $C$ 哪一年更早即可。

接下来，如果年份相同，那么看月，所以比较 $A$ 和 $B$ 哪个更早。

我的输出是放在函数 `void out(int n);` 里面的，其中 $n$ 为 $1,2,3$ 中的一数，表示三种格式。

注意判断年份是 $19$ 开头还是 $20$ 开头，并且日期和月份不足两位要输出前导零。

```cpp
void out(int n){//输出
    switch(n){
        case 1:{//年月日
            if(check(a,b,c)){
                printf("%d%02d-%02d-%02d\n",a>=60?19:20,a,b,c);
            }
            break;// break 很重要
        }
        case 2:{//月日年
            if(check(c,a,b)){
                printf("%d%02d-%02d-%02d\n",c>=60?19:20,c,a,b);
            }
            break;
        }
        case 3:{//日月年
            if(check(c,b,a)){
                printf("%d%02d-%02d-%02d\n",c>=60?19:20,c,b,a);
            }
            break;
        }
    }
}
signed main(){
    scanf("%d/%d/%d",&a,&b,&c);//输入
    if(a<60)a+=100;
    if(c<60)c+=100;//年份小于 60 要加上 100
    if(a<c){//年份比较大小
        a%=100;
        c%=100;//变回原来的样子
        out(1);
        if(a<b){
            if(c!=a||a!=b||b!=c){//判断重复！！！
                out(2);
                if(b!=a)out(3);
            }
        }else{
            if(c!=a){
                out(3);
                if(b!=a)out(2);
            }
            
        }
    }else{//下面和上面一个道理
        a%=100;
        c%=100;
        if(a<b){
            if(c!=a||a!=b||b!=c){
                out(2);
                if(b!=a)out(3);
            }
        }else{
            if(c!=a){
                out(3);
                if(b!=a)out(2);
            }
        }
        out(1);
    }
    return 0;
}
```
---

还有一点也很重要，记得判断重复的日期。

比如输入为 `01/01/00` 时，你的代码很可能输出两个 `2000-01-01`，这样会 WA。

判重请看上面的代码理解一下。

---

AC Code:

```cpp
#include<iostream>
using namespace std;
int a,b,c;
bool check(int y,int m,int d){
    if(d<=0)return 0;//特判
    if(m==1||m==3||m==5||m==7||m==8||m==10||m==12){//大月
        if(d<=31)return 1;
    }
    if(m==4||m==6||m==9||m==11){//小月
        if(d<=30)return 1;
    }
    if(m==2){//二月
        if(y%4==0){//闰年
            if(d<=29)return 1;
        }else{//平年
            if(d<=28)return 1;
        }
    }
    return 0;
}
void out(int n){//输出
    switch(n){
        case 1:{//年月日
            if(check(a,b,c)){
                printf("%d%02d-%02d-%02d\n",a>=60?19:20,a,b,c);
            }
            break;// break 很重要
        }
        case 2:{//月日年
            if(check(c,a,b)){
                printf("%d%02d-%02d-%02d\n",c>=60?19:20,c,a,b);
            }
            break;
        }
        case 3:{//日月年
            if(check(c,b,a)){
                printf("%d%02d-%02d-%02d\n",c>=60?19:20,c,b,a);
            }
            break;
        }
    }
}
signed main(){
    scanf("%d/%d/%d",&a,&b,&c);//输入
    if(a<60)a+=100;
    if(c<60)c+=100;//年份小于 60 要加上 100
    if(a<c){//年份比较大小
        a%=100;
        c%=100;//变回原来的样子
        out(1);
        if(a<b){
            if(c!=a||a!=b||b!=c){//判断重复！！！
                out(2);
                if(b!=a)out(3);
            }
        }else{
            if(c!=a){
                out(3);
                if(b!=a)out(2);
            }
            
        }
    }else{//下面和上面一个道理
        a%=100;
        c%=100;
        if(a<b){
            if(c!=a||a!=b||b!=c){
                out(2);
                if(b!=a)out(3);
            }
        }else{
            if(c!=a){
                out(3);
                if(b!=a)out(2);
            }
        }
        out(1);
    }
    return 0;
}
```

---

## 作者：czrjx (赞：12)

## 题意
给出一个日期，判断这个日期在 `年/月/日`，`月/日/年`，`日/月/年` 的情况下是否成立。
## 思路
暴力枚举每一个日期，判断是否符合条件。

这题的最大坑点在判断闰年，如果是闰年则将 $2$ 月的天数变成 $29$ 天。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
char a[20];
int M[20]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int main()
{
	int l,i,j,k,x,y,z;
	scanf("%s",a);
	l=strlen(a);
	x=(a[0]-48)*10+a[1]-48;
	y=(a[3]-48)*10+a[4]-48;
	z=(a[6]-48)*10+a[7]-48;
	for(i=1960;i<=2059;i++)
	{
		if(i%400==0||(i%4==0&&i%100!=0))	//判断闰年
			M[2]=29;
		for(j=1;j<=12;j++)
		{
			for(k=1;k<=M[j];k++)
				if((x==i%100&&y==j&&z==k)||(z==i%100&&x==j&&y==k)||(z==i%100&&y==j&&x==k))
				{
					cout<<i<<"-";
					if(j<10)
						cout<<0;
					cout<<j<<"-";
					if(k<10)
						cout<<0;
					cout<<k<<endl;
				}	
		}
		M[2]=28;
	}
}
```


---

## 作者：_ChongYun_ (赞：8)

# 题目分析

水题，由于给定范围，可以直接进行枚举。

我的做法是三层枚举，分别枚举年月日。

# 题目思路

一开始，需要判断这个年份是否是闰年。

如果是，二月就变成二十九天。否则就是二十八天。

接下来，只需要判断每一次枚举是否符合题目条件，分别是年月日、日月年和月日年。每一次都按照格式输出就行了。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int M[15]={0,31,0,31,30,31,30,31,31,30,31,30,31};        
bool run_year(int year){ return (year%4==0&&year%100!=0)||(year%400==0); }
bool istrue(int year,int month,int day){ return (a==year%100&&b==month&&c==day)||(a==month&&b==day&&c==year%100)||(a==day&&b==month&&c==year%100); }
int main(){
    scanf("%d/%d/%d",&a,&b,&c);
    for(int i=1960;i<=2059;i++){ //枚举年
        if(run_year(i)){//判断闰年
        	M[2]=29;
		}else{
			M[2]=28;
		}
        for(int j=1;j<=12;j++){//枚举月
        	 for(int k=1;k<=M[j];k++){//枚举天
        	 	if(istrue(i,j,k)){
        	 		printf("%d-%02d-%02d\n",i,j,k); //按照题目格式输出
				}
			}  
		}  
    }
    return 0;
}
```


---

## 作者：linyukun (赞：6)

## 1. 前言
本文的分析会比较通俗，自己要多去思考，麻烦一定 _仔细全部看完_，有异议、不懂或认为可以优化请私信反馈呢。  

## 2. 题目解析：
这道题一眼看过去**只有三种情况**，首先想到分类讨论，于是走上了~~码屎山~~大模拟的不归路。

第一层（组合方式）：  
+ 年/月/日。
+ 月/日/年。
+ 日/月/年。

第二层（特殊月份）：
+ 二月。
+ 其他月。

第三层（日期）：
+ 其他月的话，看天数合理就记录。
+ 二月的话，**问 $29$ 日再判闰年，其余的普通处理。**

最后排序输出。

## 3.提示要点：
* 数字记录，方便运算。
* 输入**记得卡掉 $/$。**
* 第三层**小心日或月等于 $0$。**
* 闰年判断加上前面年份。
* **标记是否有答案的值一定大**，不然排序会出错。
* **记得去重。**

## 4.代码写作：
理论存在，实践开始。  
其实仔细观察就能发现：**每一块内结构几乎完全相同，改的只是参量！思维和码量（用复制）其实并不大！**
#### 特别解释一下存储方式，把日期存成一个八位数，前四位是年，然后是月，最后是日。输出一定按位取，不然 $03$ 一类的 $0$ 就没了。
```cpp
#include <bits/stdc++.h>
using namespace std;
char c;
long long a,b,d,aa=100000000,bb=100000000,cc=100000000,t;
bool ck(int n){
	if(n>=60)n+=1900;
	else n+=2000;
	if((n%100!=0&&n%4==0)||n%400==0)return 1;
	else return 0;
}
int main(){
	cin>>c;
	a=c-'0';
	a*=10;
	cin>>c;
	a+=c-'0';
	cin>>c;
	
	cin>>c;
	b=c-'0';
	b*=10;
	cin>>c;
	b+=c-'0';
	cin>>c;
	
	cin>>c;
	d=c-'0';
	d*=10;
	cin>>c;
	d+=c-'0';
	
	if(b==2&&b!=0&&d!=0){
		if(d==29&&ck(a)){
			if(a>=60){
				aa+=19000000;
				aa+=a*10000;
				aa+=b*100;
				aa+=d;
			}
			else{
				aa+=20000000;
				aa+=a*10000;
				aa+=b*100;
				aa+=d;
			}
		}
		if(d<=28){
			if(a>=60){
				aa+=19000000;
				aa+=a*10000;
				aa+=b*100;
				aa+=d;
			}
			else{
				aa+=20000000;
				aa+=a*10000;
				aa+=b*100;
				aa+=d;
			}
		}
	}
	else if(b<=12&&b!=0&&d!=0){
		if(b==1||b==3||b==5||b==7||b==8||b==10||b==12){
			if(d<=31){
				if(a>=60){
					aa+=19000000;
					aa+=a*10000;
					aa+=b*100;
					aa+=d;
				}
				else{
					aa+=20000000;
					aa+=a*10000;
					aa+=b*100;
					aa+=d;
				}
			}
		}
		else{
			if(d<=30){
				if(a>=60){
					aa+=19000000;
					aa+=a*10000;
					aa+=b*100;
					aa+=d;
				}
				else{//cout<<"N";
					aa=20000000;
					aa+=a*10000;
					aa+=b*100;
					aa+=d;
				}
			}
		}
	}
//-------------------------------------------------------------------
	if(a==2&&b!=0&&a!=0){
		if(b==29&&ck(d)){
			if(d>=60){
				bb+=19000000;
				bb+=d*10000;
				bb+=a*100;
				bb+=b;
			}
			else{
				bb+=20000000;
				bb+=d*10000;
				bb+=a*100;
				bb+=b;
			}
		}
		if(b<=28){
			if(d>=60){
				bb+=19000000;
				bb+=d*10000;
				bb+=a*100;
				bb+=b;
			}
			else{
				bb+=20000000;
				bb+=d*10000;
				bb+=a*100;
				bb+=b;
			}
		}
	}
	else if(a<=12&&a!=0&&b!=0){
		if(a==1||a==3||a==5||a==7||a==8||a==10||a==12){
			if(b<=31){
				if(d>=60){
					bb+=19000000;
					bb+=d*10000;
					bb+=a*100;
					bb+=b;
				}
				else{
					bb+=20000000;
					bb+=d*10000;
					bb+=a*100;
					bb+=b;
				}
			}
		}
		else{
			if(b<=30){
				if(d>=60){
					bb+=19000000;
					bb+=d*10000;
					bb+=a*100;
					bb+=b;
				}
				else{
					bb+=20000000;
					bb+=d*10000;
					bb+=a*100;
					bb+=b;
				}
			}
		}
	}
//-------------------------------------------------------------------
	if(b==2&&b!=0&&a!=0){
		if(a==29&&ck(d)){
			if(d>=60){
				cc+=19000000;
				cc+=d*10000;
				cc+=b*100;
				cc+=a;
			}
			else{
				cc+=20000000;
				cc+=d*10000;
				cc+=b*100;
				cc+=a;
			}
		}
		if(a<=28){
			if(d>=60){
				cc+=19000000;
				cc+=d*10000;
				cc+=b*100;
				cc+=a;
			}
			else{
				cc+=20000000;
				cc+=d*10000;
				cc+=b*100;
				cc+=a;
			}
		}
	}
	else if(b<=12&&b!=0&&a!=0){
		if(b==1||b==3||b==5||b==7||b==8||b==10||b==12){
			if(a<=31){
				if(d>=60){
					cc+=19000000;
					cc+=d*10000;
					cc+=b*100;
					cc+=a;
				}
				else{
					cc+=20000000;
					cc+=d*10000;
					cc+=b*100;
					cc+=a;
				}
			}
		}
		else{
			if(a<=30){
				if(d>=60){
					cc+=19000000;
					cc+=d*10000;
					cc+=b*100;
					cc+=a;
				}
				else{
					cc+=20000000;
					cc+=d*10000;
					cc+=b*100;
					cc+=a;
				}
			}
		}
	}
	if(aa>bb){
		t=aa;
		aa=bb;
		bb=t;
	}
	if(aa>cc){
		t=aa;
		aa=cc;
		cc=t;
	}
	if(bb>cc){
		t=bb;
		bb=cc;
		cc=t;
	}
	if(aa!=100000000)cout<<aa/10000%10000<<"-"<<aa/1000%10<<aa/100%10<<"-"<<aa/10%10<<aa%10<<endl;
	if(bb!=100000000&&bb!=aa)cout<<bb/10000%10000<<"-"<<bb/1000%10<<bb/100%10<<"-"<<bb/10%10<<bb%10<<endl;
	if(cc!=100000000&&cc!=bb)cout<<cc/10000%10000<<"-"<<cc/1000%10<<cc/100%10<<"-"<<cc/10%10<<cc%10;
	return 0;
}
```

## 5.总结鸣谢：
**本题是一道考验耐心思维的枚举或分类讨论，难度适中。**  

---

## 作者：fkcufk (赞：4)


[洛谷原题传送门](https://www.luogu.com.cn/problem/P8651)

**推荐在我的博客里阅读，效果更好哦。**

解析：

本题可以使用三重循环暴力，比较简单，不会超时。

所以我们只需枚举所有符合要求的日期就完了。

我们可以定义一个`monthday`数组，用于存入各月的天数。

判断天数应该用以下代码来判断：
```cpp
if(a==y%10+y/10%10*10&&m==b&&d==c || 
    a==m&&b==d&&c==y%10+y/10%10*10 || 
    a==d&&b==m&&c==y%10+y/10%10*10){}
```

注意点：

- 记得判断闰年！

即

```cpp
if(y%100!=0&&y%4==0||y%400==0) monthday[2]=29;
else monthday[2]=28;
```

完整代码见[这里](https://www.luogu.com.cn/paste/wjf3yl5m)。

---

## 作者：XIxii (赞：2)

因为输入有三种形式，年/月/日，月/日/年，日/月/年，三种形式的日期逐个判断是否合法既可以，最后对日期从小到大排序

注意两个比较特殊的数据：

1.当年的位置是 $00$ 的时候

2.当三个参数相同的时候,要注意去重,比如 $01 / 01 / 01$ 的输出只有一个

总而言之，题不难，就是打代码时头有点疼。

下面是代码：


```cpp
#include <bits/stdc++.h>
using namespace  std;
int t=0;
struct node 
{
	int y,m,d;
}p[1001];
int if_run(int x) //判断闰年
{
	if(x%4==0 && x%100!=0 || x%400==0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
bool cmp(node a,node b)
{
	if(a.y!=b.y)
	{
		return a.y<b.y;
	}
	else
	{
		if(a.m!=b.m)
		{
			return a.m<b.m;
		}
		else
		{
			a.d<b.d;
		}
	}
}
void check(int yy,int mm,int dd)
{
	int day[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
	if(yy>=60)
	{
		yy=1900+yy;
	}
	else 
	{
		yy=2000+yy;
	}
	if(if_run(yy)==1)
	{
		day[2]++;
	}
	if(mm>0 && mm<=12)
	{
		if(dd>0 && dd<=day[mm])
		{
			p[t].y=yy;
			p[t].m=mm;
			p[t++].d=dd;
		}
	}
}
int main()
{
	string s;
	cin>>s;
	int x1=(s[0]-'0')*10+(s[1]-'0');
	int x2=(s[3]-'0')*10+(s[4]-'0');
	int x3=(s[6]-'0')*10+(s[7]-'0');
	// x1/x2/x3 输入的三种可能形式都输进去判断一遍
	check(x1,x2,x3);//年/月/日
	check(x3,x1,x2);//月/日/年
	check(x3,x2,x1);//日/月/年
	//check(年，月，日)
	sort(p,p+t,cmp);
	for(int i=0;i<t;i++)//输出的时候还要去除重复的日期，比如 s=01/01/01 只有一种情况
	{
		if(i>0 && p[i].y==p[i-1].y && p[i].m==p[i-1].m && p[i].d==p[i-1].d)
		{
			continue;
		}
		printf("%d-%02d-%02d\n",p[i].y,p[i].m,p[i].d);
	}
	return 0;
}
```


---

## 作者：Lemonlwl (赞：1)

## P8651 [蓝桥杯 2017 省 B] 日期问题 题解
### 题意：
给出三个正整数，求出满足 ```年/月/日``` 和 ```月/日/年``` 和 ```日/月/年``` 三种情况的并且符合正常日期的答案。

------------

### 思路：
由于判断日期是否正确的部分是重复的，所以可以写一个专门用来判断的函数，再枚举三种情况。

又因为最后答案要从早到晚输出，我们可以用 ```STL``` 中的 ```set``` 记录答案。

-----------

附上 [AC](https://www.luogu.com.cn/record/108601342) 代码：

```cpp
#include<iostream>
#include<cstring>
#include<set>
#include<cstdio>
using namespace std;
int mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
/*每个月份的月数*/
int a,b,c,ly,lm,ld;  //ly,lm,ld用来记录传进的参数是否相同。
char str[1000005];
set<string> s;  //记录答案的set。
void date(int y,int m,int d){
	if(y==ly && m==lm && d==ld){  //如果之前出现过，就不用判断了。
		return;
	}
	ly=y;
	lm=m;
	ld=d;
	//记录当前数据。
	if(y>=60 && y<=99){
		y+=1900;
	}
	else{
		y+=2000;
	}
	if(y%400==0 || (y%100!=0 && y%4==0)){  //如果是闰年，二月应改成29天。
		mon[2]=29;
	}
	if(m>=1 && m<=12){  //判断月。
		if(d>=1 && d<=mon[m]){  //判断日。
			sprintf(str,"%d-%02d-%02d\n",y,m,d);  //用sprintf将答案存进str里面。
			s.insert(str);  //再把str存进set里面。  
		}
	}
}
int main(){
	scanf("%d/%d/%d",&a,&b,&c);  //输入。
	date(a,b,c);  //年月日。
	date(c,a,b);  //月日年。
	date(c,b,a);  //日月年。
	set<string>::iterator it2;  //迭代器。
	for(it2=s.begin();it2!=s.end();it2++){
		cout<<*it2;  //输出。
	}
	return 0;
}
```

点个赞再走呗。

---

## 作者：Vct14 (赞：1)

由于给出了范围，所以暴力枚举每一个日期即可。

注意闰年。

```
#include <bits/stdc++.h>
using namespace std;

int d[]={0,31,28,31,30,31,30,31,31,30,31,30,31};//每月日期 

bool isrun(int x){//判断闰年 
	if(x%4) return false;
	else{
		if(x%100) return true;
		else{
			if(x%400) return false;
			else return true;
		}
	}
} 

int a,b,c;

bool isok(int y,int m,int d){//判断三种情况 
	int p=y%100;
	if(p==a && m==b && d==c) return true;
	if(p==c && m==a && d==b) return true;
	if(p==c && m==b && d==a) return true;
	return false;
}

void print(int y,int m,int d){//输出 
	cout<<y<<"-";
	if(m<=9) cout<<"0";
	cout<<m<<"-";
	if(d<=9) cout<<"0";
	cout<<d<<endl;
}

int main(){
	char ch;//分隔符 
	cin>>a>>ch>>b>>ch>>c;
    //scanf("%d/%d/%d",&a,&b,&c);
    for(int i=1960; i<=2059; i++){//年
    	if(isrun(i)) d[2]++;//闰年 2 月有 29 天，即比平常多 1 天 
        for(int j=1; j<=12; j++){//月
            for(int k=1; k<=d[j]; k++){//日
                if(isok(i,j,k)){
                	print(i,j,k);
                	//printf("%d-%02d-%02d\n",i,j,k);
				}
            }
        }
    }
    return 0;
}
```

---

## 作者：rainygame (赞：1)

本题比较简单，因为它限定了日期的范围，所以我们只要枚举这个范围内的所有日期就可以了，大约会枚举 $100 \times 365 = 36500$ 次，不会超时。

接下来就是判断了，其实也很简单，只需要枚举这三种方式就可以了。

**但是注意还有闰年！**

注意这里有个小技巧，当遇到这种读写方式的时候，就不要用 `cin/cout` 了，用 `scanf/printf` 可以更方便。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int a, b, c;

int main(){
    scanf("%d/%d/%d", &a, &b, &c);
    
    for (int y=1960; y<=2059; y++){  // 枚举年份 
    	// 判断闰年 
        if (y % 100 != 0 && y % 4 == 0 || y % 400 == 0) month[2] = 29;
        else month[2] = 28;
        
        for (int m=1; m<=12; m++){  // 枚举月份 
            for (int d=1; d<=month[m]; d++){
                if (a == y % 10 + y / 10 % 10 * 10 && m == b && d == c ||  // a/b/c
                    a == m && b == d && c == y % 10 + y / 10 % 10 * 10 ||  // c/a/b
                    a == d && b == m && c == y % 10 + y / 10 % 10 * 10){  // c/b/a
                    printf("%d-%02d-%02d\n", y, m, d);
                }
            }
        }
    }
    
    return 0;
}
```


---


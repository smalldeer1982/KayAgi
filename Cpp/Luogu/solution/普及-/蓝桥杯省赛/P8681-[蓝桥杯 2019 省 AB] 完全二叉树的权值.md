# [蓝桥杯 2019 省 AB] 完全二叉树的权值

## 题目描述

给定一棵包含 $N$ 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 $A_1,A_2, \cdots A_N$，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/lq1cyfst.png)

现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。

注：根的深度是 $1$。

## 说明/提示

对于所有评测用例，$1 \le N \le 10^5$，$0 \le |A_i| \le 10^5$。

蓝桥杯 2019 省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
7
1 6 5 4 3 2 1```

### 输出

```
2```

# 题解

## 作者：___w (赞：25)

## solution

#### 题意简述
- 给定一个完全二叉树。

- 求同一深度的节点权值之和最大的深度（深度为第二关键字）。

- $1≤N≤10^5$，$0 \le |A_i| \le 10^5$。
 
#### 完全二叉树的性质
![完全二叉树](https://cdn.luogu.com.cn/upload/image_hosting/jm7dc887.png)

设深度为 $dep$，根节点的深度为 $1$。则有第 $dep$ 层的节点为 $2^{dep}$，每层开头的节点编号为 $2^{dep-1}$，末尾的节点编号为 $2^{dep}-1$（以上结论叶子节点除外）。

#### 题目分析
有了以上的性质，我们不难想到解题思路：可以对序列 $a$ 进行划分层次，即完全二叉树的每一层，再找最大权值之和。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, sum, ans, dep = 1, Max = -1e9;
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> a;
		sum += a;
		if (i == (1 << dep)-1) {//若是末尾节点，切换到下一层
			if (sum > Max) {//找到可行解
				Max = sum;
				ans = dep;
			}
			++dep;
			sum = 0;
		}
	}
	if (sum > Max) {//特判叶子节点
		Max = sum;
		ans = dep;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：11)

## 分析

根据题意，我们不难发现：这道题的节点是按照树的层数进行输入的。而我们又知道，对于一个 $x$ 层的完全二叉树，其每层的节点数除最后一层外均为 $2^{n-1}$，其中 $n$ 为层数，且从 $1$ 开始。那么，我们就可以一边输入一遍查找，每次判断一下输入的数是不是这一层的最后一个节点。如果是，取最大值；如果不是，继续输入即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int maxx=-1e18,maxid;
int n;
int now,k=1;//这一层输入了几个数了；是第几层了
int ans;//存每一层的权值和
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;cin>>x;
		ans+=x;
		now++;
		if(now==pow(2,k-1)||i==n) //是这层的最后一个
		{
			if(ans>maxx) maxx=ans,maxid=k;//更大
			ans=now=0;//重置
			k++;
		}
	}
	return cout<<maxid,0;
}
```


---

## 作者：细数繁星 (赞：8)

## Solution
我们可以定义一个名曰 $k$ 的变量，表示二叉树的最大深度，设关于数组 $A$ 的长度为 $l$，那么 $k=\lfloor \log_2 l \rfloor$。

所以说，第 $i$ 层的结点数就为 $2^{i-1}$，那我们不难写出以下代码：

## Code
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int graph[100010];
int maxx = -2147483648;


int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> graph[i];
	}
	int k = 0; // 二叉树深度
	int ans = 0; // 二叉树权值最高的深度
	int m = n; // 因为n会改变，这里是用来判断后面是否数组越界
	while (n)
	{
		n /= 2;
		k++;
	}
	for (int i = 0; i < k; i++)
	{
		int sum = 0;
		for (int j = pow(2, i); j < pow(2, i + 1) && j <= m; j++)
		// j = pow(2, i) 是指在第 i 层时，第一个结点在数组graph中的索引
		// j < pow(2, i + 1) - 1是指在第 i 层时，最后一个结点在数组graph中的索引
		{
			sum += graph[j-1];
		}
		if (sum > maxx)
		{
		    maxx = sum;
		    ans = i + 1;
		}
		
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Yashajin_Ai (赞：5)

### 前置芝士：
先看一看完全二叉树概念：

完全二叉树：若设二叉树的深度为 $h$，除第 $h$ 层外，其它各层 $(1\sim h-1)$ 的结点数都达到最大个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。

### 正片
我们的目标是看懂这题涉及的完全二叉树的方面，那么——此题明显是涉及完全二叉树结点数和层数的关系。

所以分两种情况求解：

满二叉树 $\log _{2}\left( n+1\right)$ 为他的深度，完全二叉树 $\left( \log _{2}n\right) +1$ 为他的深度。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],n,m,ans,maxn=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>m;
        int d=log(2*i)/log(2);//手动转log以2为底数的深度
        a[d]+=m;
    }
    for(int i=1;i<=n;i++){
        if(a[i]>maxn){//寻找哪个深度的节点权值之和最大
            maxn=a[i];
            ans=i;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：lbdontknow (赞：2)

## 算法分析
我们可以将每一个深度的所有权值记录为 $sum$ 数组，$sum_i$ 代表第 $i$ 层的节点权值和。最后再遍历一遍 $a$ 数组，取最大值所对应的 $i$ 进行输出即可。  
那我们怎么求得 $sum$ 数组呢？  
首先，根据完全二叉树的定义，每一层节点的的数量为前一个层的 $2$ 倍，$siz$ 代表当前层最多有多少个节点，$noww$ 代表当前已经该层已经遍历过的节点的数量，$deep$ 代表当前遍历过的深度。在刚开始时，$noww$ 初始化为 $0$；$siz$ 初始化为 $1$，因为二叉树第一层只有一个节点；$deep$ 初始化为 $1$。  
每一次将 $sum_{deep}+a_i$，然后将 $noww+1$。判断一下 $noww=siz$ 是否成立或者 $i=n$ 是否成立，如果这两个条件中有一个成立，则证明 $i$ 是第 $deep$ 层最后一个节点。此时应该将 $deep+1$，$noww=0$。并且将 $siz \times 2$，因为下一层的节点数为这一层的 $2$ 倍。  
最后从 $sum_1$ 到 $sum_{deep-1}$ 中取得最大值的层数，输出就好了。为什么是 $deep-1$ 而不是 $deep$ 呢？因为我们会发现，在最后一层的时候，$deep$ 会多加一次，所以我们需要将 $deep-1$，最后输出即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long deep,siz,noww,i,n,a[1919810],sum[1919810],maxx=-1145141919810,ans;
int main(){
	cin>>n;
	for(i=1;i<=n;i++)	cin>>a[i];
	deep=1;
	siz=1;
	i=1;
	noww=0;
	for(i=1;i<=n;i++){
		sum[deep]+=a[i];
		noww++;
		if(noww==siz||i==n){
			noww=0;
			deep++;
			siz*=2;
		}
	}
	for(i=1;i<deep;i++){
		if(sum[i]>maxx){
			maxx=sum[i];
			ans=i;
		}
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：Steve_xh (赞：1)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P8681)

**题目大意：**

给定一棵完全二叉树，求每一层的权值和的最大值。

# 思路

首先，这道题是不用真的建一棵树的，因为只要求每一层权值的和，因此可以利用二叉树的性质来求。

根结点编号为 $1$，那么它就会有两个儿子 $2$ 和 $3$，而它的每个这些儿子又会有两个儿子。因此推测完全二叉树的**除了最后一层**的第 $i$ 层结点个数为 $2^{i-1}$。根据这个性质就可以知道一段结点处在第几层从而得到这一层的权值和。

然后是注意事项，可以不用在循环里每次求一遍 $2^{i-1}$，注意到完全二叉树的结点是连续储存每一层的，则可以从 $1$ 开始不断迭代，每次到当前层的最后一个结点就将结点层数翻一倍即可。当然还有一个大坑点：**完全二叉树最后一层不一定满**。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long//见祖宗
using namespace std;
int n,a[100005],sum[10005],m=1,ans=-1,d=-1;//其实这道题甚至能不用数组，但是我懒
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",a+i);
	for(int i=1,cnt=1,nowmax=1;i<=n;i++,(cnt==nowmax?cnt=1,nowmax<<=1,m+=(i<=n):cnt++))//cnt结点数计数器，nowmax表示当前层最多多少个结点
		sum[m]+=a[i];//将第m层的结点数累加
	for(int i=1;i<=m;i++)
		if(sum[i]>ans)
			ans=sum[i],d=i;
	printf("%lld",d);
	return 0;
}
```

---

## 作者：zxf_imp8 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8681)

一道很简单的二叉树入门题。

### 题目大意

按顺序给出一棵完全二叉树各节点的权值，求权值和最大的一层的深度。

首先要了解完全二叉树是什么：完全二叉树除最底层外，其他层节点均排满，且最底层节点从左到右依次排列。

### 思路

既然题目说要求**权值和**最大的一层的深度，那就把每层权值之和求出来再比大小就行了。

其实这题都不需要用树存储，循环找每层节点的起始位置求和就可以。前 $i-1$ 层总结点数为 $2^{i-1}-1$，所以第 $i$ 层的第一个节点为输入的第 $2^{i-1}$ 个节点，前 $i$ 层共有 $2^i-1$ 个节点，所以第 $i$ 层最后一个节点为输入的第 $2^i-1$ 个节点。

至于如何求总层数，有了上面的公式就很简单了很简单了，而且 `<cmath>` 库中有现成的 $\operatorname{log_2}$ 函数，但要注意返回值是浮点型，注意要向上取整。总层数 $= \lceil\ \log_2(n+1)\ \rceil$ （因为最后一层节点不一定满，所以要先将 $n$ **加一**，取对数后再**向上取整**）。

### AC 代码
  
  ```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[100005];

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++){//输入 
		cin >> a[i];
	}
	int maxn = a[1];//别忘了先设一个“最大值” 
	int maxi = 1;//和最大的层的深度 
	for(int i = 2; i <= ceil(log2(n+1)); i++){
	//这个退出条件可能有点难理解，多举几个例子就能明白为什么是这样 
		int s = 0;//记录和 
		for(int j = pow(2, i-1); j <= pow(2, i)-1 && j <= n; j++){//遍历这一层的所有节点 
			s += a[j];
		}
		if(s > maxn) maxn = s, maxi = i;
	}
	cout << maxi;
	return 0; 
}
```


---

## 作者：37ReeseA12 (赞：1)

## 题目大意

给你一颗完全二叉树，并告诉你每个结点的数各是多少，问这棵树中深度为几的那一层各个节点加起来和最大。

## 分析与思路

完全二叉树可以理解为二叉树的一种特殊形式，就好比四边形中的正方形一样。完全二叉树的特殊之处在于它的节点数，如果你列出深度为 $1$，深度为 $2$，深度为 $3$，依此类推，你会发现深度为 $k$ 的完全二叉树的节点个数为 $2^k-1$。而除最深的一层以外，上面的 $k-1$ 层的节点个数为 $2^{k-1}$，这同时也是这道题的突破口，我们可以从一开始的深度为 $1$ 的层开始查找，一直找到最后，看谁大就输出，其实就是一个不断比大小的过程。

## 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;

int maxx=-1e18,maxxx; //注：这个地方最好不用 max，因为可能跟下面产生歧义
int n;
int now,k=1; // k是深度
int ans;  // ans是计算每一层深度节点的总和
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x; //输入每个结点的数
		cin>>x;
		ans+=x;
		now++;
		if(now==pow(2,k-1)||i==n) //两种情况，前一种是判断是否有完全二叉树的特性，后一个是判断是否输到最深层了
		{
			if(ans>maxx) 
			{
			    maxx=ans; //比大小的过程
			    maxxx=k;
			}
			ans=0,now=0;
			k++;
		}
	}
	cout<<maxxx;
	return 0;
}
```

最后，希望大家喜欢！（求管理员审核过）


---

## 作者：SilverLi (赞：1)

[完全二叉树 の 传送门](https://www.luogu.com.cn/problem/P8681)

对于一棵完全二叉树，若深度有 $k$ 层，除第 $k$ 层外，第 $n$ 层的节点个数都是 $2^{n-1}$。

所以只用在统计到**每层结尾**或者到达输入结尾时进行比较即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,level=1,num=0,k=1;
    long long ans=0,maxl=1,maxn=LONG_LONG_MIN;
    cin>>n;
    for(int i=1;i<=n;++i){
        long long c;
        cin>>c;
        ++num;
        ans+=c;
        if(num==k||i==n){
            if(ans>maxn) maxl=level,maxn=ans;
            num=0,k*=2,++level,ans=0;
        }
    }
    cout<<maxl;
    return 0;
} 
```

---

## 作者：watcher_YBH (赞：1)

# 思路：
一棵完全二叉树的层数如果为 $i$，那么第 $i$ 层的个数为 $2^{i-1}$，所以我们可以用前缀和计算每层的总和，在由深入浅的去遍历，并保留最优结果。
# 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAX = 1e6+5;
int n,now,maxn,j;
int a[MAX];
int id[MAX];//前缀和
int main(){
	cin>>n;
	for(int i = 1; i<=n; i++)
		cin>>a[i],id[i] = id[i-1]+a[i];
	for(int i = n+1; i<=1e6; i++)//向后延展，避免前缀和计算出错
		id[i] = id[i-1];
	int i = 1, k = 1;//i是层数，k是每层的个数
	while(n>0){
		if(maxn < id[now+k]-id[now])//保留最优结果
			maxn = id[now+k]-id[now],j = i;
		now+=k;  i++;  n-=k;
		k *= 2;//计算下一层的个数
	}
	cout<<j<<endl;//输出
	return 0;
}
```


---

## 作者：Prolystic (赞：0)

## Part 0 前言

[原题目(洛谷)](https://www.luogu.com.cn/problem/P8681)

## Part 1 题意简述

* 给定正整数 $N(N\leq10^5)$
* 接下来一行给定 $N$ 个整数 $a_i(0\leq|a_i|\leq 10^5)$，为按照层序遍历赋值的节点权值。
* 这是一棵完全二叉树，求出那层中节点权值和最大的层号。(根节点层数为 $1$)

## Part 2 分析

从 $1-N$ 遍历节点，设定一个变量 $num$ 这一层节点编号的上限。求出加和，当节点编号等于 $num$ 时，$num$ 更新为自身的二倍。比较这一层的节点权值和与最大的权值和，若这一层的更大，更新最大权值和，记录这一层的深度。最后还要比较一下，因为如果最后一层不满，会少比较一次，导致 WA。(一定注意，这玩意折磨了我快一个小时啊！！！！)

复杂度 $O(N)$。

## Part 3 代码

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN = 1e5+5;
int n;
LL sum;
LL num;
LL nodeNum = 1;
LL deep;
LL maxV = LONG_MIN;
LL maxD;
LL tree[MAXN];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i = 1;i<=n;i++){
        cin>>tree[i];
    }
    for(int i = 1;i<=n;i++){
        sum+=tree[i];
        num++;
        if(num==nodeNum){
            deep++;
            num = 0;
            nodeNum*=2;
            if(sum>maxV){
                maxV = sum;
                maxD = deep;
            }
            sum = 0;
        }
    }
    if(sum>maxV){
        maxD = deep+1;
    }
    cout<<maxD;
    return 0;
}
```

## Part 4 测试信息

![](https://cdn.luogu.com.cn/upload/image_hosting/vyy7iy1e.png)

[记录](https://www.luogu.com.cn/record/106942193)

创造和谐洛谷，拒绝抄袭题解。

适度刷题益脑，沉迷刷题伤身。

拒绝盗版代码，提倡自我思考。

健康学习ＯＩ，快乐美好生活。

---

## 作者：Furina_Hate_Comma (赞：0)

一道**模拟**题。

求同层点权和最大值。

由于完全二叉树除了最后一层不满，其他层全满。

所以我们可以特判最后一层，照题模拟即可。

下面给出一些公式：

- 树的深度 $k= \lfloor \log_2 n \rfloor$。
- 第 $i$ 层的节点数 $a_i=2^{i-1}$。
- 最后一层节点数 $f=n-2^{k}$。 

代码：

```cpp
#include<iostream>
using namespace std;
long long n, x, v[10000005], ans = 1;
int main() {
    cin >> n;
    int j = 1;
    for(int i = 1; i <= n; i++) {
        cin >> x;
        if((1ll << j) <= i) ++j;
        v[j] += x;
    }
    for(int i = 1; i <= j; i++) {
        if(v[i] > v[ans]) ans = i;
    }
    cout << ans << endl;
    return 0;
}
```


---


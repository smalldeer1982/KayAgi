# [蓝桥杯 2019 省 B] 等差数列

## 题目描述

数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中 $N$ 个整数。

现在给出这 $N$ 个整数，小明想知道包含这 $N$ 个整数的最短的等差数列有几项？

## 说明/提示

包含 `2,6,4,10,20` 的最短的等差数列是 `2,4,6,8,10,12,14,16,18,20`。

对于所有评测用例，$2 \le N \le 10^5$，$0 \le A_i \le 10^9$。

蓝桥杯 2019 年省赛 B 组 H 题。

## 样例 #1

### 输入

```
5
2 6 4 10 20```

### 输出

```
10```

# 题解

## 作者：zxf_imp8 (赞：48)

## P8682 等差数列

[题目传送门](https://www.luogu.com.cn/problem/P8682)

这道题不难，但还是要分析一下。

首先，为了项数最少，我们一定不会在添加比数据中最小值还小或者比最大值还大的数。

这就意味着我们已经知道了最终等差数列的首项和末项，所以我们只需求出公差即可。

为了使项数最少，我们需要公差尽可能地大。

------------
不妨设等差数列为单调不减数列。

则对于等差数列 $a$ 中任意两项 $a_i,a_j$（$i<j$）。

有 $a_j-a_i = (a_{j-1}+d)-a_i = (a_{j-2}+2d)-a_i = … =[a_{i+1}+(j-i-1)d]-a_i = (j-i)d$。

所以任意两项的差均为公差 $d$ 的倍数，于是所求 $d$ 为所有相邻两项差的公约数。又因为 $d$ 要最大，所以 $d$ 就是所有相邻两项差的最大公约数。

------------

分析结束，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[100005];
int d;

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}
	sort(a+1, a+n+1);//题目明确说了“不一定按顺序给出”，所以要先排序
	d = a[2]-a[1];
	if(d == 0){//如果d=0，那么说明所有的数都相等，最小个数肯定就是n 
		cout << n;
		return 0;
	}
	for(int i = 2; i <= n-1; i++){
		d = __gcd(d, a[i+1]-a[i]);//求所有差的最大公约数 
	}
	cout << (a[n]-a[1])/d+1;//算出项数，输出 
	return 0;
}
```

---

## 作者：hycqwq (赞：15)

## 思路

项数最少等同于公差（记作 $d$）最大。

而由于等差数列的任意两项之差都是公差的倍数（其正确性显然），所以我们只需要求出给出的数两两之差的最大公因数即可。

不过 $O(N^2)$ 这个复杂度嘛……一言难尽！

于是我们来思考优化的办法。

~~经过不懈的努力~~，我们发现，其实只需要取相邻的数的最大公因数。为什么呢？因为当 $1 \le a, b, c$ 时，$\gcd(\gcd(a, b), c) = \gcd(a, b, c) < \gcd(a, c)$，这是很好理解的，毕竟有了 $b$ 的限制。

那么这样，我们的复杂度就优化到了 $O(N)$。

那我们就开始写代码？（前排提示：题目求的是项数，不是公差）

**但是**！你会发现，如果就这样的话，`#1` 会 RE！

原因：除 $0$ 错误。

猜猜为什么？如果输入的数都相等，那么算出来的公差不就等于 $0$ 了吗？

于是，加特判吧！如果输入的所有数都相等，那么答案就为 $N$。

引用：![](https://cdn.luogu.com.cn/upload/image_hosting/q9nie4k7.png)

## 代码

又到了让人喜闻乐见的环节。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, a[100005]; 

int gcd(int x, int y)
{
    if (y == 0)
        return x;
    return gcd(y, x % y);
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);//输入时是无序的，所以要排序
    if (a[1] == a[n])
    {
        //都排完序了第一个和最后一个还是相等
        //肯定是全部都相等
        //于是直接结束！
        cout << n << endl;
        return 0;
    }
    int ans = a[2] - a[1];//初值设为一个公差的若干倍
    for (int i = 3; i <= n; i++)
        ans = gcd(ans, a[i] - a[i - 1]);
    cout << (a[n] - a[1]) / ans + 1 << endl;//求的是项数哦
    return 0;
}
```

---

## 作者：linxuanrui (赞：4)

### 写在前面

读这篇题解前，你需要知道几个有关等差数列的公式。

设一个等差数列的第 $i$ 项为 $a_i$，公差（就是相邻每个数的差）为 $d$，那么：

1. 通项公式：$a_x=a_1 + (x-1)\times d$ 或者 $a_x = a_n - (n-x)\times d$。

2. 求和公式：$\sum\limits_{i=1}^n a_i=\dfrac{(a_1+a_n)\times n}{2}$。

3. 求公差公式：$d=\dfrac{a_n-a_1}{n-1}$。

4. 求项数公式：$n=\dfrac{a_n-a_1}{d}+1$。

### 题解

由项数公式可知，题目让我们求 $n$ 的最小值，因此**要使 $a_n-a_1$ 的值尽量小，$d$ 的值尽量大**。

题目给了我们一个等差数列的一部分，因此我们可以让里面的最小值为 $a_1$，最大值为 $a_n$，这样 $a_n-a_1$ 就会变得尽量小。

由等差数列的性质可知，任意两项的差为 $d$ 倍，因此，我们可以将题目给出的相邻两项之差的最大公约数，这个数就是 $d$ 的最大值。

### 注意事项

1. 题目给出的数列不一定是按顺序给出，因此要排序。

2. $d$ 为 0 时，说明每一项都相同，此时最少就为 $n$ 个数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d,t;
vector<int> v;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> t;
		v.push_back(t);
	}
	sort(v.begin(),v.end());
	d = v[1] - v[0];
	for(int i = 2;i < v.size();i++){
		d = __gcd(d,v[i] - v[i - 1]);
	}
	cout << (d == 0 ? n : (v[v.size() - 1] - v[0]) / d + 1);
}
```

---

## 作者：wuhan1234 (赞：2)

## 1. 编程思路。

先将输入的 $N$ 个整数从小到大排列。

由于这 $N$ 个整数是某个等差数列的一部分，因此它们满足等差数列的性质。

设原等差数列的公差为 $d$。

对于输入后按从小到大排序好的序列 $A_1,A_2,...,A_N$ 中任意的相邻两项 $A_{i-1}$ 和 $A_i$ 来说：

若 $A_{i-1}$ 和 $A_i$ 在原等差数列中也相邻，则有 $A_i=A_{i-1}+d$。

若 $A_{i-1}$ 和 $A_i$ 在原等差数列中不相邻，不妨设  $A_{i-1}$ 是原等差数列的第 $m$ 项，$A_i$ 是原等差数列的第 $n$ 项，则有 $A_i=A_{i-1}+(n-m)\times d$。

即 $A_i-A_{i-1}=(n-m)\times d$。

由上式可知，若 $d$ 值越大，则 $A_i$ 与 $A_{i-1}$ 之间的项数 $n-m-1$ 越少，从而原等差数列的项数也就越少。

而 $d$ 是 $A_i-A_{i-1}$ 的约数。因此本题的实质是求 $N-1$ 个差值 $A_i-A_{i-1} (2\le i \le N)$ 的最大公约数。

## 2. 源程序。

```c
#include <stdio.h>
#include <algorithm>
using namespace std;
int gcd(int a,int b)
{
    if (a%b==0) return b;
    return gcd(b, a%b);
}
int main ()
{
    int n;
    scanf("%d", &n);
    int i,a[100005];
    for (i=0;i<n;i++)
        scanf("%d",&a[i]);
    sort(a,a+n);
    int d=a[0]-a[1];
    if (d==0) 
        printf("%d\n",n);
    else
    {
        for (i=2;i<n;i++)
           d=gcd(d,a[i]-a[i-1]);
        printf("%d\n",(a[n-1]-a[0])/d+1);
    }
    return 0;
}
```






---

## 作者：Furina_Hate_Comma (赞：0)

一道**数学**题。

我们设公差为 $d$，那么对于任意 $i$，$j$，有 $\gcd(a_i,a_j)=k \times d$。

因为等差数列中任意两项的积都**必然**是多个 $d$ 累加的结果。

而此时有两个变量，时间复杂度为 $O(n^2)$，考虑优化。

由乘法分配律 $a\times k\pm b\times k=(a\pm b)\times k$ 可知我们只需要计算所有**排序后相邻数**的差的最大公因数即可。

即：

$\gcd(a_2-a_1,a_3-a_2 ,\cdots,a_n-a_{n-1})$
 
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[114514];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);
	int l=a[n]-a[1];
	int ans=a[2]-a[1];
	for(int i=3;i<=n;i++)ans=__gcd(ans,a[i]-a[i-1]);
	if(!ans)cout<<n;
	else cout<<l/ans+1;
}
```


---


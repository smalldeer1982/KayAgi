# [蓝桥杯 2021 省 AB2] 完全平方数

## 题目描述

一个整数 $a$ 是一个完全平方数，是指它是某一个整数的平方，即存在一个 整数 $b$，使得 $a=b^{2}$ 。

给定一个正整数 $n$，请找到最小的正整数 $x$，使得它们的乘积是一个完全平方数。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 1000$，答案不超过 $1000$。

对于 $60 \%$ 的评测用例，$1 \leq n \leq 10^{8}$，答案不超过 $10^{8}$。

对于所有评测用例，$1 \leq n \leq 10^{12}$，答案不超过 $10^{12}$。

蓝桥杯 2021 第二轮省赛 A 组 G 题（B 组 H 题）。

## 样例 #1

### 输入

```
12```

### 输出

```
3```

## 样例 #2

### 输入

```
15```

### 输出

```
15 ```

# 题解

## 作者：w9095 (赞：35)

[P8754 [蓝桥杯 2021 省 AB2] 完全平方数](https://www.luogu.com.cn/problem/P8754)

首先，要使 $nx$ 为完全平方数，需要知道完全平方数的一个性质：**完全平方数的质因子的指数一定为偶数**。

证明：

设 $\sqrt{nx}=b$ ，$b$ 是正整数，则根据唯一分解定理，可得：

$$b=p_{1}^{k_{1}}\times p_{2}^{k_{2}}\times p_{3}^{k_{3}}\times ... \times  p_{r}^{k_{r}}$$

其中 $p_{1},p_{2},p_{3}...p_{r}$ 为质数。

由完全平方数的定义，这个完全平方数 $nx$ 为 $b^2$ ，即：

$$nx=(p_{1}^{k_{1}}\times p_{2}^{k_{2}}\times p_{3}^{k_{3}}\times ... \times  p_{r}^{k_{r}})^2$$

把括号拆开，得到

$$nx=p_{1}^{2k_{1}}\times p_{2}^{2k_{2}}\times p_{3}^{2k_{3}}\times ... \times  p_{r}^{2k_{r}}$$

可以看到，每个质因子的指数均为 $2k_{m}$ ，必然是偶数。

所以，可以得到这样一个思路：

对 $n$ 进行质因数分解，**若质因子指数为偶数，对结果无影响。若质因子指数为奇数，则在 $x$ 中乘以这个质因子，保证指数为偶数**。

最后是完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,ans=1;
int main()
{
    scanf("%lld",&n);
    for(long long i=2;i*i<=n;i++)
        {
        	int cnt=0; //cnt计数，表示质因子pri[i]的指数
        	while(!(n%i))cnt++,n/=i;
        	if(cnt%2)ans*=i; //如果指数不是偶数，在x中要有一个这个质因子，保证指数为偶数
		}
	if(n!=1)ans*=n;//注意n没分尽的情况
	printf("%lld",ans);
	return 0;
}
```


[AC记录](https://www.luogu.com.cn/record/97698883)

---

## 作者：pxb0801 (赞：17)

## 1.分析：

首先我们需要了解**唯一分解定理**。这个定理简单来说就是对于任意一个数 $n$，它都可以分解为若干个质数的乘积。
比如 $60$ 就可以分解为 $2^2\times 3\times 5$。

如果一个数是完全平方数，那么这若干个质数的指数都一定是偶数。比如：$36=2^2\times 3^2=(2\times 3)^2=6^2$。

所以，我们先将读入的 $n$ 进行质因数分解。对于分解的每一个质数，如果它的指数为奇数，则 $x$ 的因子就必须有这个质数。

---------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,p[1000],g[1000],cnt,ans;
int main(){
	cin>>n;
	for(ll i=2;i*i<=n;i++){
		if(n%i==0) cnt++;
		while(n%i==0){
			p[cnt]=i;//p是质因子
			g[cnt]++;//g是这个质因子的指数
			n/=i;
		}
	}
	if(n>1){
		p[++cnt]=n;
		g[cnt]++;
	}
   //以上是质因数分解模板
	ans=1;
	for(int i=1;i<=cnt;i++){
		if(g[i]%2){//如果指数是奇数
			ans*=p[i];//那么就要补一个这个质数
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：sunyizhe (赞：11)

这题是一个简单的数论题。

## 一、题意

给出 $n$，求出 $x$，使得两数乘积为**完全平方数**。

## 二、思路

我们发现，一个完全平方数分解质因数后，每个质因数的指数一定是偶数，因为完全平方数是通过两个相同的整数相乘得到的。因此做法如下：

得到 $n$ 后，先将 $x$ 初始化为 $1$。随后再扫描 $n$ 的所有质因数，将 $n$ 除掉所有这个质因数。判断这个质因数的指数，如果为奇数就将 $x$ 乘上这个质因数与 $n$ 配对成偶数。最后，如果最后 $n \not= 0$，说明 $n$ 为质数，我们就没有判断它，$x \gets x \times n$。

## 三、代码

注意答案要开 ```long long```。

```cpp
//程序算法：模拟，数论 
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long n,x=1;
	scanf("%lld",&n);
	for(long long i=2;i*i<=n;i++)//扫描质因数i 
		if(n%i==0)
		{
			int cnt=0;
			while(n%i==0)//去除这个质因数，计数 
			{
				n/=i;
				cnt++;
			}
			if(cnt%2==1)x*=i;
		}
	if(n!=1)x*=n;//n为质数 
	printf("%lld\n",x);
	return 0;
}
```

这里有人要问：$i$ 有没有可能枚举到合数，多算呢？其实是不会的。我们是从小到大枚举的，所以我们一定会枚举到 $i$ 的质因数。但我们把它去除了，所以一定 $n \bmod i \not= 0$。

---

## 作者：ryf_loser (赞：5)

2023.02.09 更改一处错误。

根据唯一分解定理：一个正整数 $n$ 都可以分解为若干个质数的乘积。

打个比方 $80=2^4\times5^1$

如果 $n$ 为完全平方数，那么这若干个质数的指数都一定是偶数。

比如 $36=2^2\times3^2$ 和 $100=2^2\times5^2$，两个指数都为 2 ，而 2 是偶数。

经过分析，可以得知所以：对于 $n$ 分解出来的每一个质数，如果它的指数为奇数，则 $i$ 的因子就必须有这个质数。

AC CODE

```cpp
#include<cstdio>
using namespace std;
long long n,ans=1;//十年 OI 一场空，不开 long long 见祖宗。
int main () {
    scanf("%lld",&n);
    for (long long i=2;i*i<n;i++){
    	int tot=0;
    	while (n%i==0)n/=i,tot++;//统计指数。
    	if (tot%2)ans*=i;//是否为奇数。
	}
    printf ("%lld",ans*n);
    return 0;
}
```


---

## 作者：Infinite_Eternity (赞：4)

# Description

[P8754 [蓝桥杯 2021 省 AB2] 完全平方数](https://www.luogu.com.cn/problem/P8754)

给定一个正整数 $n$，请找到最小的正整数 $x$，使得它们的乘积是一个完全平方数。

数据范围：$1 \leq n \leq 10^{12}$。保证答案不超过 $10^{12}$。

# Analysis

非常常见的一个数论问题。

- 首先，我们将 $x$ 初始化为 $1$。

- 接下来，将 $n$ 分解为：$n = {p_{1}}^{a_{1}} \times {p_{2}}^{a_{2}} \times \cdots \times {p_{i}}^{a_{i}} \times \cdots \times {p_{r}}^{a_{r}}$ 的形式。不难发现，对于一个完全平方数，将其质因数分解后，每一个质因子的指数必为偶数。若 $a_{i}$ 是奇数，使得：$x \leftarrow x \times a_{i}$。

- 最后，若还剩一个指数为 $1$ 的质因子，那就令 $x$ 再乘上这个质因子。

# Code

```cpp
#include <stdio.h>
#define int long long
int n,x=1;
signed main () 
{
	scanf("%lld",&n);
	for(register int i=2;i*i<=n;++i) 
	{
		if(n%i==0) 
		{
			int cnt=0;
			while(n%i==0) 
			    n/=i,cnt++;
			if(cnt%2==1) 
			    x*=i;
		}
	}
	if(n!=1) x*=n;
	printf("%lld\n",x);
	return 0;
}
```

---

## 作者：Convergent_Series (赞：3)

## 题目分析：
设完全平方数 $a=b^2=p_1^{k_1}p_2^{k_2}p_3^{k_3}$ ······ $p_m^{k_m}(p_i(1\le i\le m)$ 为素数)，则 $b=p_1^{\frac{k_1}{2}}p_2^{\frac{k_2}{2}}p_3^{\frac{k_3}{2}}$ ······ $p_m^{\frac{k_m}{2}}$ 为整数，$2|k_i(1\le i \le m)$  。

将 $n$ 分解质因数，如果质因数 $p_i$ 有奇数个，则在答案 $ans$ 中乘 $  p_i$ 。

---
## 完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans=1;
signed main()
{
	cin>>n;
	int i,j;
	for(i=2;i*i<=n;i++){
		j=0;
		while(n%i==0){
			n/=i;
			j++;
		}
		if(j%2==1) ans*=i;
	}//见题目分析
	ans*=n;
    //如果n为合数，则n现在已被完全分解，=1；
    //如果n为质数，则目前未被分解，需要补全完全平方数的质因子n。
	cout<<ans;
	return 0;
} 
```

---

## 作者：VitrelosTia (赞：2)

题链：[P8754 [蓝桥杯 2021 省 AB2] 完全平方数](https://www.luogu.com.cn/problem/P8754)

感觉其他大佬的做法都好高深啊，本蒟蒻只能写一个比较低级的做法。

**引理**：一个自然数分解质因数之后，各个质因数的指数都是偶数当且仅当这个自然数是完全平方数。

**证明**：${p_1}^{2a_1}{p_2}^{2a_2}\cdots{p_k}^{2a_k} = ({p_1}^{a_1}{p_2}^{a_2}\cdots{p_k}^{a_k})^2$

知道这件事之后就很容易解决了，既然要每个质因数的指数都是偶数，那就补上 $1$ 个不是偶数的指数就好了。稍作转化，答案实际上就是所有指数是奇数的质因数之积。

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,nn,ans=1,k;
int main (){
    scanf("%lld",&n);
    nn=n;//n在循环中不能被改变，所以用nn循环
    for(ll i=2;i*i<=nn;i++){//i是质因数
        k=0;//k用来计算i的指数
        while(n%i==0){//当n还能被i分解时
            n/=i;//分解n
            k++;//当前质因数i的指数加1
        }
        if(k%2) ans*=i;//如果指数是奇数，答案乘上当前质因数
    }
    if(n>1) ans*=n;//如果分解到最后还没有分完，说明本身就是质数，直接补上自身
    printf("%lld",ans);
}
```



---

## 作者：tbdsh (赞：1)

~~第一篇主题库题解。~~
# 题意
[题目传送门](/problem/P8754)

[更好的阅读体验](/blog/tianbiandeshenghuo11/solution-p8754)

输入一个正整数 $n(1\le n\le10^{12})$，找到一个最小的正整数 $x$，使得 $n\times x$ 是**完全平方数**。

# 分析
首先，我们来了解一下完全平方数的性质。

举个例子，完全平方数：$144$。

将 $144$ [分解质因数](https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749)后可以得到：
$$
2^4\times3^2=144
$$
不难发现，每一个质因数的指数都是偶数。

具体来说，一个完全平方数可以分解为若干个质数的乘积，且每个质数的指数都是偶数。

那么，就可得到本题的思路：将 $n$ 分解质因数，如果其中一个质因数的指数是奇数，就将答案与这个质因数相乘。

**但是**，如果分解完后剩下了一个质数，就需要手动乘一次。

时间复杂度：$O(\log_2 n)$。
# Code
```cpp
#include<bits/stdc++.h>

using namespace std;
const int MAXN = 5e8;
long long n, ans = 1;
short v[MAXN];
int main(){
  cin >> n;
  for (long long i = 2; i * i <= n; i++){
    int cnt = 0;
    while(n % i == 0){
      cnt++;
      n /= i;
    }
    if (cnt % 2){
      ans *= i;
    }
  }
  if (n != 1){
    ans *= n;//特判 n != 1  即未完全分解的情况
  }
  cout << ans;
  return 0;
}
```

---

## 作者：RP_INT_MAX (赞：1)

## $\textbf{0x10 Solution}$

很显然暴力枚举肯定会超时，想都不用想。

考虑完全平方数的一个性质：

假设 $n$ 是一个完全平方数，将 $n$ 唯一分解为 $\displaystyle\prod_{i=1}^k {p_i}^{a_i}$ 的形式（$\forall1 \le i \le k,p_i\in \text{Prime}$），则 $\forall1 \le i \le k,2\mid a_i$。

那么，很容易想到对 $n$ 分解质因数。我们设 $n=\displaystyle\prod_{i=1}^k {p_i}^{a_i}$，$n\times x=\displaystyle\prod_{i=1}^{k'} {p_i'}^{a_i'}$。由于要求 $n \times x$ 是完全平方数，那么我们需要通过 $x$ 将乘积的唯一分解式中，每一个 $a_i'$ 都满足 $2 \mid a_i'$。

由于要求 $x$ 最小，所以若 $a_i$ 本身就满足 $2 \mid a_i$，那么什么都不用添加。若 $2 \nmid a_i$，添加一个 $p_i$ 即可。

至此，代码呼之欲出。

## $\textbf{0x20 Code}$

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll n,ans=1;
int main () {
	scanf("%lld",&n);
	for(int i=2;1LL*i*i<=n;++i) {
		if(n%i==0) {
			int cnt=0;
			while(n%i==0) n/=i,++cnt;
			if(cnt&1) ans*=i;
		}
	}
	if(n!=1) ans*=n;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：aCssen (赞：0)

### Solution

设 $p_i$ 表示 $i^2$，则对于任意的整数 $a$，都可以表示为 $x \times p_1^{k_1} \times p_2^{k_2} \times ... \times p_{\sqrt n}^{k_{\sqrt n}}$，此时的 $x$ 就是答案。

证明：因为 $p_{1...\sqrt n}$ 都是完全平方数，$x$ 一定不是完全平方数，所以只要 $x$ 是完全平方数，$a$ 就是完全平方数。因此，我们将 $a$ 乘上 $x$，就能得到最小的答案。

综上，我们只需枚举 $p_{1...\sqrt n}$ ，将能够整除 $a$ 的 $p_i$ 全部从 $a$ 中除去，最后剩下的部分就是答案，时间复杂度 $O(\sqrt n)$。

### 细节

+ $n \le 10^{12}$，注意使用 long long。
+ $k_i$ 可能不为 $1$，要除到不能再除为止。

### 代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
int main(){
	ll n,ans;
	scanf("%lld",&n);
	ans=n;
	for(ll i=2;i*i<=n;i++){
		ll k=i*i;
		while(ans%k==0) ans/=k;//一定要除到不能除为止
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Samson2010 (赞：0)

# 题意

给定一个正整数 $n$ ，请找到最小的正整数 $x$，使得它们的乘积是一个完全平方数。

数据范围：1$\le n  \le10^{12}$
 。保证答案不超过 $10^{12}$
 
# 定理

- 将一个数 $x$ 分解质因数，即$x=a1^{p1}\times a2^{p2}\times...\times an^{pn}$ 。

- 对于每一个 $p(i)$，只要 $p(i)$ 是偶数，那么这个数一定是完全平方数，如果 $p(i)$ 是奇数，那么再乘一个 $a(i)$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans=1;
signed main () 
{
	cin>>n;
	for(register int i=2;i*i<=n;++i) 
	{
		if(n%i==0) 
		{
			int cnt=0;
			while(n%i==0) 
			{
				n/=i;
				cnt++;
			}
			if(cnt%2==1) 
			    ans*=i;
		}
	}
	if(n!=1) ans*=n;
	cout<<ans;
	return 0;
}
```



---


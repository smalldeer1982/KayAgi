# [蓝桥杯 2023 省 A] 填空问题

## 题目描述

## A. 幸运数

小蓝认为如果一个数含有偶数个数位，并且前面一半的数位之和等于后面一半的数位之和，则这个数是他的幸运数字。例如 $2314$ 是一个幸运数字，因为它有 $4$ 个数位，并且 $2+3=1+4$。现在请你帮他计算从 $1$ 至 $100000000$ 之间共有多少个不同的幸运数字。

## B. 有奖问答

小蓝正在参与一个现场问答的节目。活动中一共有 $30$ 道题目，每题只有答对和答错两种情况，每答对一题得 $10$ 分，答错一题分数归零。

小蓝可以在任意时刻结束答题并获得目前分数对应的奖项，之后不能再答任何题目。最高奖项需要 $100$ 分，所以到达 $100$ 分时小蓝会直接停止答题。请注意小蓝也可能在不到 $100$ 分时停止答题 $^{[1]}$。

已知小蓝最终实际获得了 $70$ 分对应的奖项，请问小蓝所有可能的答题情况有多少种？

${[1]}$：这一句并未在蓝桥杯原题写明，具体的情况请参考 [这个讨论帖](https://www.luogu.com.cn/discuss/1070210)。

## 说明/提示

第十四届蓝桥杯大赛软件赛省赛 C/C++ 大学 A 组 A-B

# 题解

## 作者：Lzj0314 (赞：6)

## A. 幸运数
由于是提交答案题，所以直接写个暴力枚举即可。但也不至于从 $1$ 至 $100000000$ 一个个枚举，只需枚举偶数位的数即可。

```cpp
int A(){
	int cnt=0;
	for(int i=1;i<=7;i+=2){//偶数位的数为 10 的奇数次方
		int x=pow(10,i);//计算起始数
		for(int j=x;j<=x*10-1;j++){//一个个枚举
			int sum1=0,sum2=0,jj=j;
			for(int k=1;k<=i/2+1;k++) sum1+=jj%10,jj/=10;//计算前面一半的数位之和
			for(int k=1;k<=i/2+1;k++) sum2+=jj%10,jj/=10;//计算后面一半的数位之和
			if(sum1==sum2) cnt++;//计数器+1
		}
	}
	return cnt;
}
```
答案为 $4430091$。
## B. 有奖问答
由于是提交答案题，所以直接写个搜索即可。

```cpp
int b=0;
void dfs(int score,int cnt){
	if(score==70) b++;//获得了 70 分答案+1
	if(score==100||cnt>=30) return ;//到达 100 分或做完 30 道题目
	cnt++;//做完题目
	dfs(0,cnt);//错误
	dfs(score+10,cnt);//正确
}
int B(){
	dfs(0,0);//各自从 0 开始
	return b;
}
```
答案为 $8335366$。

还是那句话，由于是提交答案题，所以直接根据模板输出答案即可。

代码就不摆了（这你懒得打？？？），[放个记录](https://www.luogu.com.cn/record/216946770)显示我过了。

---

## 作者：JIN_LONG (赞：5)

## 幸运数思路：
题目大意是计算从 $1$ 到 $10^8$ 之间满足幸运数字条件的数字个数，一个数字前面一半的数位之和等于后面一半的数位之和，这个数就是幸运数。

```cpp
#include<bits/stdc++.h> 
using namespace std;
typedef long long ll;
char op;
int main() {
	ll num=0;
	for(int i=10;i<100000000;i++){
		int cnt=0;
		for(int j=i;j>0;j/=10){
			cnt++;
		}
		if(cnt%2==0){
			ll sum1=0,sum2=0;
			int x=i;
			for(int y=1;y<cnt+1;y++,x/=10){
				sum1 += x % 10;
				if(y==cnt/2) {
					sum2 = sum1;
				sum1 = 0;
				}	
			} 
			if(sum1==sum2){
				num++;
			}
		}
	}
	cout << num << endl;
    return 0;
}
```
我的代码逻辑如下。

- 初始化计数器为零，用于统计幸运数字的总数。
- 主循环部分，从 $10$ 开始检查，因为 $1$ 位数不可能是偶数位数。
- 主循环内，通过不断除以 $10$ 来计算位数。
- ‌检查偶数位数，因为只有偶数位数的数字才可能是幸运数字。
- 如果是偶数位数，计算前后半部分数字和，以下是这段代码的解释，我把解释放到代码注释中了。

```cpp
ll sum1=0,sum2=0;
int x=i;
for(int y=1;y<cnt+1;y++,x/=10){
    sum1 += x % 10; // 累加当前位的数字
    if(y==cnt/2) { // 当处理到中间位置时
        sum2 = sum1; // 保存前半部分的和
        sum1 = 0; // 重置sum1用于计算后半部分
    }	
} 

```
- 接着判断是否为幸运数，如果是，计数器加 $1$。
- 最后输出结果即可。
## 有奖问答思路：
题目大意如下。

- 一共有 $30$ 道题，每题答对加 $10$ 分，答错归零。
- 可以在‌任意时刻‌选择停止并领取当前分数对应的奖项，但达到 $100$ 分会‌强制停止‌，因为这是最高奖项。
- 题目的问题是最终‌恰好获得 $70$ 分‌的所有可能答题路径数。

这题我用的方法是动态规划，以下是我代码的逐步解析。

- 初始化。
```cpp
int ans=0, dp[31][10]={0};  // dp[i][j]表示答完i题后当前分数%10等于j的路径数
dp[0][0] = 1;  // 初始状态：0题时分数为0（唯一情况）

```
- 动态规划转移。

```cpp
for(int i=1;i<=30;i++){  // 遍历1~30题
    for(int j=0;j<10;j++){  // 当前分数%10的可能值(0~9)
        if(j==0){  // 当前分数是10的倍数（可能是答错或刚好累加到整十）
            for(int k=0;k<10;k++){
                dp[i][0] += dp[i-1][k];  // 无论之前多少分，答错都会归零
            }
        }
        else {  // 分数非零的情况
            dp[i][j] += dp[i-1][j-1];  // 必须由上一步的j-1状态答对得来
        }
    }
    ans += dp[i][7];  // 累加所有在第i题时分数%10=7（即70分）的情况
}

```
- 输出所有可能获得 $70$ 分的路径总数即可。
```cpp
cout<<ans<<endl;
```
## 最终代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    char s;
    cin>>s;
    if(s=='A')cout<<4430091;
    else cout<<4165637;
}
```

---

## 作者：Vct14 (赞：2)

填空问题，暴力枚举。

第一问枚举所求范围内所有位数为偶数的数并拆分其每一位进行判断。答案为 $4430091$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int ans=0;
	for(int p=2; p<=8; p+=2){
		int st=pow(10,p-1);
		for(int i=st; i<st*10; i++){
			int sum=0,ii=i;//cout<<ii<<"\n";
			for(int k=1; k<=p/2; k++){
				sum+=ii%10;
				ii/=10;
			}
			for(int k=1; k<=p/2; k++){
				sum-=ii%10;
				ii/=10;
			}
			if(sum==0) ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

第二问按题意搜索，答案为 $8335366$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int s;

void dfs(int sc,int st){
	if(sc==70) s++;
	if(sc==100 || st==30) return ;
	st++;dfs(0,st);dfs(sc+10,st);st--;
}

int main(){
	dfs(0,0);
	cout<<s;
	return 0;
}
```

---

## 作者：Ray_yi (赞：1)

## 幸运数：

由于是填空题，我们可以无脑暴力枚举。

从 $1$ 开始，枚举到 $10^8$。每次判断数位个数是否是偶数，再依次算前面一半和后面一半的数位和，最后符合条件的累加即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for(int i=1;i<=100000000;i++){
		int k=i,cnt=0,a[10],l=0;
		while(k!=0){
			cnt++;
			a[++l]=k%10;
			k=k/10;
		}
		if(cnt%2!=0) continue;//判断数位个数 
		int num=0,nm=0;
		for(int j=1;j<=cnt/2;j++) num+=a[l-j+1];
		for(int j=cnt/2+1;j<=l;j++) nm+=a[l-j+1];
		if(num==nm) ans++;//判断数位之和 
	}
	cout<<ans;
	return 0;
}
```
最后结果为 $4430091$。

## 有奖问答：
**题目给出条件：**

- 一共 $30$ 道题目，分数最高 $100$ 分。
- 做对一题得 $10$ 分，做错一题清零。
- 最终得分为 $70$ 分。

于是，我们可以爆搜分做对和做错两种情况。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ans;
void dfs(int num,int cnt){//num:分数 cnt:题数 
	if(num==70) ans++;//符合条件 
	if(num==100||cnt==30) return;//分数封顶或题目做完 
	dfs(num+10,cnt+1);//做对的情况 
	dfs(0,cnt+1);//做错的情况 
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	dfs(0,0);
	cout<<ans;
	return 0;
}
```
最后结果为 $8335366$。

## 最终代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char c;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>c;
	if(c=='A') cout<<4430091;
	else cout<<8335366;
	return 0;
}
```

---

## 作者：hlsnqdmz (赞：1)

## 题外话
这道题也是道传奇题目了，毕竟赛后改题的题并不多（至少我只遇到这一道，阅历太浅了），但除去这一点，这道题还是比较基础的。

## A. 幸运数
这道题我没也不想想什么巧妙地方法，不想判定个数位有几个？那就直接分开挨个循环，不想想什么巧妙的判断式子，那就直接暴力拆出各位再相加（当然，有更巧妙的方法还是尽量学习和使用的），代码如下（太暴力了）：

```
int main()
{
    int ans = 0;
    for (int i = 10; i < 100; i++)//直接循环位数为偶数的数
        if (i / 10 == i % 10) ans++;//拆出每一位的方法
    for (int i = 1000; i < 10000; i++)//同上
        if (i / 1000 + i / 100 % 10 == i / 10 % 10 + i % 10) ans++;
    for (int i = 100000; i <= 1000000; i++)
        if (i / 100000 + i / 10000 % 10 + i / 1000 % 10 == i / 100 % 10 + i / 10 % 10 + i % 10) ans++;
    for (int i = 10000000; i < 100000000; i++)
        if (i / 10000000 + i / 1000000 % 10 + i / 100000 % 10 + i / 10000 % 10 == i / 1000 % 10 + i / 100 % 10 + i / 10 % 10 + i % 10) ans++;
    cout << ans << "\n";
    return 0;
}
```
## B. 有奖问答
这道题是比较板子的 dp，由于有做对和做错两种可能，所以要分开讨论，我们先定义 $dp[i][j]$ 为做到第 $i$ 题且得到 $j$ 分时的可能数，那么做对的话那就会多得十分，即  $dp[i][j]=dp[i][j]+dp[i-1][j-10]$ 当然，小蓝到达 100 分会立即停止答题，且 $j$ 最小为 10，所以 $j$ 的范围从 10 到 100，且每次加 10。而做错就会直接归零（~~什么逆天答题规则~~），所以无论上一个问题回答完有多少分（除了 100 分），只要回答错误都会变成 0 分，就可以得出 $dp[i][0]=dp[i][0]+dp[i-1][j-10]$ 这里 $j-10$ 是因为与要与上一个式子一起处理所以写成这样。当然不要忘记这道题的传奇修改内容：“请注意小蓝也可能在不到 100 分时停止答题。”所以最后要进行累加，代码如下：
```
int dp[32][110];
int main()
{

    int ans = 0;
    dp[0][0] = 1;// dp 的预处理
    for (int i = 1; i <= 30; i++)
        for (int j = 10; j <= 100; j += 10)
            dp[i][j] += dp[i - 1][j - 10], dp[i][0] += dp[i - 1][j - 10];
    for (int i = 1; i <= 30; i++)
        ans += dp[i][70];
    cout << ans;
    return 0;
}
```

~~当然如果有可以压成一维的方法，请务必告诉我。~~

最后由于这道题是一道提交答案的题，所以要用题目给出的格式提交：
```
//Just Sayori
#include <bits/stdc++.h>
using namespace std;

char pid;
int main() {
    cin >> pid;
    if (pid == 'A')
        puts("4430091");
    else
        puts("8335366");
    return 0;
}
```
### 感谢您的观看！

---

## 作者：anke2017 (赞：0)

~~反正是填空题，随便写一个复杂度逆天的算法都可以的~~

## A. 幸运数

注意到只有 $9.09\times10^7$ 个数需要检查（位数为奇数的数不必检查），加之只需提交答案，可以暴力检验。答案是 `4430091`。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[11];
inline bool check(int num)
{
	if(num&1)return 0;
    int ans=0;for(int i=1;i<=num;i++)ans+=t[i]*(i>(num>>1)?1:-1);
    return !ans;
}
int main()
{
	freopen("ans.txt","w",stderr);//运行完成后将把答案写在这个文件中
	int now=1,num=0;
	int ans=0;
	for(int i=1;i<=100000000;i++)
	{
		if(i==now)now*=10,num++,printf("%d!\n",i);
		int cnt=1;
		int tt=i;while(tt)t[cnt++]=tt%10,tt/=10;
		ans+=check(num);
	}
	cerr<<ans;
	return 0;
}
```

## B. 有奖问答

按照题意，直接爆搜即可。答案是 `8335366`。

```cpp
#include<bits/stdc++.h>

using namespace std;

long long ans=0;

void dfs(int now,int score)//第 now 次答题，已经有 score 分
{
	if(score==70)ans++;//达到要求
	if(score==100||now==31)return;//达到要求，强制结束
	dfs(now+1,score+10);//成功
	dfs(now+1,0);//失败
}

int main()
{
	ios::sync_with_stdio(false);cin.tie(0);
	dfs(1,0);//第一次，0分
	cout<<ans;
	return 0;
}
```

---

## 作者：ouxiyao (赞：0)

我不会用人脑算，那只能用电脑算咯！
# A.幸运数
直接枚举，如果符合左侧数字和等于右侧数字和，计数器增加。省点时间，剪枝：奇数位的数全不要。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int sum = 9,i;
	for(i = 1001;i<=9999;i++)
		if(i/1000+i/100%10==i/10%10+i%10)sum++;
	for(i = 100001;i<=999999;i++)
		if(i/100000+i/10000%10+i/1000%10==i/100%10+i/10%10+i%10)sum++;
	for(i = 10000001;i<=99999999;i++)
		if(i/10000000+i/1000000%10+i/100000%10+i/10000%10==i/1000%10+i/100%10+i/10%10+i%10)sum++;
    cout<<sum;
	return 0;
}
```
注：$sum$ 为什么初始等于 $9$ 呢？因为两位数的幸运数只有 $9$ 个，分别是 `11,22,33,44,55,66,77,88,99`。
# B.有奖问答
没啥好说的，爆搜。                                       
注意：分数等于 $100$ 时就不做了，题目上限为 $30$，等于 $70$ 分之后还可以做题！

```cpp
#include<iostream>
using namespace std;
int tot;
void DFS(int s,int f){
	if(f==70)tot++;
	if(s==30||f==100)return ;
	DFS(s+1,0);
	DFS(s+1,f+10);
}
int main(){
	DFS(0,0);
	cout<<tot;
	return 0;
}
```
时间有点久（$3$ 至 $4$ 秒），耐心等一等。

两段代码的输出分别是：`4430091,8335366`。输出，完事。                                                    

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

char pid;
int main() {
    cin >> pid;
    if(pid == 'A')
        puts("4430091");
    else
        puts("8335366");
    return 0;
}
```

---


# [蓝桥杯 2023 省 B] 填空问题

## 题目描述

## 试题 A：日期统计

### 【问题描述】

小蓝现在有一个长度为 $100$ 的数组，数组中的每个元素的值都在 $0$ 到 $9$ 的范围之内。数组中的元素从左至右如下所示:

```
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```
现在他想要从这个数组中寻找一些满足以下条件的子序列：

1. 子序列的长度为 $8$;

2. 这个子序列可以按照下标顺序组成一个 `yyyymmdd` 格式的日期，并且要求这个日期是 2023 年中的某一天的日期，例如 $20230902$，$20231223$。`yyyy` 表示年份，`mm` 表示月份，`dd` 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

请你帮小蓝计算下按上述条件一共能找到多少个**不同**的 2023 年的日期。对于相同的日期你只需要统计一次即可。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B：01 串的熵

### 【问题描述】

对于一个长度为 $n$ 的 01 串 $S=x_{1} x_{2} x_{3} \ldots x_{n}$，香农信息熵的定义为 $H(S)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2}\left(p\left(x_{i}\right)\right)$，其中 $p(0),p(1)$ 表示在这个 01 串中 0 和 1 出现的占比。

比如，对于 $S=100$ 来说，信息熵 $H(S)=-\frac{1}{3}\log _{2}\left(\frac{1}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)=1.3083$。对于一个长度为 $23333333$ 的 01 串，如果其信息熵为 $11625907.5798$，且 0 出现次数比 1 少，那么这个 01 串中 0 出现了多少次？

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# 题解

## 作者：dbywsc (赞：10)

### 日期统计

直接遍历所有的数再判断日期非常繁琐，所以可以考虑遍历 $2023$ 年的所有日期，再在 $100$ 个数中寻找是否能与这些日期相匹配，如果可以对应则答案加一。

```cpp
void solve(void) {
    int ans = 0;
    int a[101]; for(int i = 1; i <= 100; i++) cin >> a[i]; //用输入的方式读取 100 个数
    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    for(int m = 1; m <= 12; m++) {
        for(int d = 1; d <= days[m]; d++) {
            int date[] = {2, 0, 2, 3, m / 10, m % 10, d / 10, d % 10};
            int cnt = 0;
            for(int i = 1; i <= 100; i++) {
                if(a[i] == date[cnt]) cnt++;
                if(cnt == 8) {ans++; break;}
            }
        }
    }
    cout << ans << endl;
    //最后答案是 235
}
```

### 01 串的熵

由于本题已经把公式告诉我们了，所以只需要在 $0$ 到 $\lfloor \frac{23333333}{2}\rfloor$ 枚举 $0$ 出现的次数就好了。每次枚举后计算一下 $H(s)$ 的值，精度误差与答案在 $\pm 0.01$ 就可以确定答案。

```cpp
void solve(void) {
    for(int i = 1; i <= 23333333 / 2; i ++) {
        int j = 23333333 - i;
        double h = 0 - (i * (i / 23333333.0) * log2(i / 23333333.0) + j * (j / 23333333.0) * log2(j / 23333333.0));
        if(abs(h - 11625907.5798) < 0.01) {
            cout << i;
            return;
        }
    }
    //答案是 11027421
}
```

---

## 作者：chenyuan3 (赞：9)

## 试题 A：日期统计

:::info[题意简述]

给定一个长度为 $100$ 的数组，找出所有满足条件的子序列：

- 子序列的长度为 $8$；
- 如果把子序列的前 $4$ 位当作年份 $y$，第 $5\sim6$ 位当作月份 $m$，最后 $2$ 位当作日期 $d$，那么 $y=2023$ 并且年份 $y$、月份 $m$、日期 $d$ 合法。

求出所有子序列组成的日期**去重后**的数量。

:::

:::warning[关于子序列]

- **子序列**是指在原数组中筛选部分数字（筛选出来的序列**不一定**要在原数组中连续）。
- **子串**是指在原数组中筛选部分数字（筛选出来的序列**必须**要在原数组中连续）。

:::

### 思路

数据较小，直接枚举子序列即可。一些优化：

- 枚举前 $4$ 个数时如果当前数不是 $2$、$0$、$2$、$3$ 时显然不可能作为答案（违反题目中 $y=2023$ 的要求）。
- 枚举后 $4$ 个数时也要排除一些显然不可能的数字（如第 $5$ 个数是 $2$ 及以上的数字）。

为了方便去重，先把所有子序列得出的数字存入一个 `set` 里，最后输出这个集合的大小即可。

### 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
string str = "5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3";
int a[100];
set<ll> st;
void solve()
{
    for (ll i = 0; i < 100; i++) // 把题目给出的数组从字符串 str 存入数组 a
    {
        a[i] = str[i * 2] - '0';
    }
    // iX 表示子序列第 X 个数的位置（下标从 0 开始标号）
    for (ll i1 = 0; i1 < 93; i1++)
    {
        if (a[i1] != 2) // 第一个数必须是 2
        {
            continue;
        }
        for (ll i2 = i1 + 1; i2 < 94; i2++)
        {
            if (a[i2] != 0) // 第二个数必须是 0
            {
                continue;
            }
            for (ll i3 = i2 + 1; i3 < 95; i3++)
            {
                if (a[i3] != 2) // 第三个数必须是 2
                {
                    continue;
                }
                for (ll i4 = i3 + 1; i4 < 96; i4++)
                {
                    if (a[i4] != 3) // 第四个数必须是 3
                    {
                        continue;
                    }
                    for (ll i5 = i4 + 1; i5 < 97; i5++)
                    {
                        if (a[i5] > 1) // 月份的十位只能是 0 或 1
                        {
                            continue;
                        }
                        for (ll i6 = i5 + 1; i6 < 98; i6++)
                        {
                            if (!a[i5] && !a[i6] || a[i5] && a[i6] > 2) // 当月份的十位是 0 时个位不能是 0，否则十位是 2，个位只能是 0 或 1
                            {
                                continue;
                            }
                            ll mon = a[i5] * 10 + a[i6]; // 把月份存储在一个变量方便后续计算
                            for (ll i7 = i6 + 1; i7 < 99; i7++)
                            {
                                if (a[i7] > 3 || mon == 2 && a[i7] == 3) // 二月份天数的十位不能超过 2，其他月份天数的十位不能超过 3
                                {
                                    continue;
                                }
                                for (ll i8 = i7 + 1; i8 < 100; i8++)
                                {
                                    ll day = a[i7] * 10 + a[i8];
                                    if (!day || day > 31 || mon == 2 && day > 28 || (mon == 4 || mon == 6 || mon == 9 || mon == 11) && day > 30) // 2023 是平年所以二月只有 28 天
                                    {
                                        continue;
                                    }
                                    st.insert(mon * 100 + day);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    cout << st.size();
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	ll t = 1;
	// cin >> t;
	while (t--)
	{
		solve();
	}
	return 0;
}
```

输出 $235$。

## 试题 B：$\texttt{01}$ 串的熵

:::info[问题简述]

对于一个长度为 $n$ 的 $\texttt{01}$ 串 $S=x_{1} x_{2} x_{3} \ldots x_{n}$，香农信息熵的定义为

$$H(S)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2}\left(p\left(x_{i}\right)\right)$$

其中 $p(0),p(1)$ 表示在这个 $\texttt{01}$ 串中 $0$ 和 $1$ 出现的占比。已知一个长度为 $23333333$ 的 $\texttt{01}$ 串，如果其信息熵为 $11625907.5798$，且 $0$ 出现次数比 $1$ 少，那么这个 $\texttt{01}$ 串中 $0$ 出现了多少次？

:::

### 思路

为方便表述令 $n=23333333$ 表示串的长度。

设要求的串中 $0$ 出现了 $n_0$ 次，$1$ 出现了 $n_1=n-n_0$ 次。

则 $p(0)=\cfrac{n_0}n$，$p(1)=\cfrac{n_1}n$，熵就可以写成：

$$
\begin{align*}
H(S)&=-\sum_{i=1}^np(x_i)\log_2(p(x_{i}))\\
&=-\sum_{i=1}^n\left([x_i=0]\frac{n_0}n\log_2\left(\frac{n_0}n\right)+[x_i=1]\frac{n_1}n\log_2\left(\frac{n_1}n\right)\right)\\
&=-\left(\sum_{i=1}^n\left([x_i=0]\frac{n_0}n\log_2\left(\frac{n_0}n\right)\right)+\sum_{i=1}^n\left([x_i=1]\frac{n_1}n\log_2\left(\frac{n_1}n\right)\right)\right)\\
&=-\left(n_0\frac{n_0}n\log_2\left(\frac{n_0}n\right)+n_1\frac{n_1}n\log_2\left(\frac{n_1}n\right)\right)\\
&=-\left(\frac{n_0^2}n\log_2\left(\frac{n_0}n\right)+\frac{n_1^2}n\log_2\left(\frac{n_1}n\right)\right)
\end{align*}
$$

:::info[关于上述公式中出现的艾弗森括号]

$[p]$ 表示：

- 当 $p$ 为真时：$[p]=1$
- 当 $p$ 为假时：$[p]=0$

:::

此时，再枚举 $n_0$ 的值，找出与要求最接近的答案。

### 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll n = 23333333;
const double shang = 11625907.5798;
ll ans;
double anss;
void solve()
{
    for (ll n0 = 0; n0 <= n; n0++)
    {
        ll n1 = n - n0;
        double curs = -(n0 * n0 * log2(n0 * 1. / n) / n + n1 * n1 * log2(n1 * 1. / n) / n);
        if (abs(curs - shang) < abs(anss - shang))
        {
            ans = n0;
            anss = curs;
        }
    }
    cout << ans;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	ll t = 1;
	// cin >> t;
	while (t--)
	{
		solve();
	}
	return 0;
}
```

答案为 $11027421$。

## AC 代码

``` cpp lines=5-6
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "235",
        "11027421",
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---

## 作者：xzy_awa (赞：0)

# 题解：P9239 [蓝桥杯 2023 省 B] 填空问题

## A

### 问题

给定一个长度为 $100$ 的数组，数组元素为数字 $0$ 到 $9$。数组内容如下：

```text
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```
需要找到所有长度为 $8$ 的子序列，这些子序列可以组成一个 `yyyymmdd` 格式的日期，其中 `yyyy` 表示年份（只能为 $2023$），`mm` 表示月份（$01$ 至 $12$），`dd` 表示天数（$2023$ 年不是闰年则 $2$ 月有 $28$ 天）。子序列元素必须保持数组中的下标顺序（但不一定连续），且相同日期只统计一次。

### 思路

先将年份固定为 $2023$：子序列的前四个数字必须依次为 $2$、$0$、$2$、$3$，且下标递增。因此，先找到所有满足 $a_i = 2$、$a_{i + 1} = 0$、$a_{i + 2} = 2$、$a_{i + 3} = 3$ 且 $i < i + 1 < i + 2 < i + 3$ 的四元组 $f(i, i + 1, i + 2, i + 3)$。

对于每个年份结束位置 $i + 3$，从 $i + 4$ 开始，寻找后续两个数字作为月份，再寻找两个数字作为日期，要求下标严格递增：$i + 3 < i + 4 < i + 5 < i + 6 < i + 7$，其中：
   - $a_{i + 4}$ 和 $a_{i + 5}$ 组成有效的月份（$01$ 至 $12$）。
   - $a_{i + 6}$ 和 $a_{i + 7}$ 组成有效的日期（根据月份）：
     - 月份 $01$、$03$、$05$、$07$、$08$、$10$、$12$：日期 $01$ 至 $31$；
     - 月份 $04$、$06$、$09$、$11$：日期 $01$ 至 $30$；
     - 月份 $02$：日期 $01$ 至 $28$。

去重我们可以考虑使用 `set<int> s;` 记录所有有效的 `(mm, dd)` 对，避免重复日期（这里不用管 `yyyy` 是因为 `yyyy` 只能为 $2023$，为其他日期的在前面的步骤就已经筛掉了）。

对于优化，由于数组长度固定，可以预处理数字位置。年份部分只有特定的结束位置 $i + 3$（请注意 $i + 3$ 表示的是下标，不是数值。只有 $i + 3 = 58$ 或 $59$ 可行，因为其他 $i + 3$ 后位置不足）。然后枚举月份十位（必须是 $0$ 或 $1$）和个位（根据十位确定范围），再枚举日期十位和个位（根据月份确定范围），检查下标顺序。

### 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

int arr[100] = {5, 6, 8, 6, 9, 1, 6, 1, 2, 4, 9, 1, 9, 8, 2, 3, 6, 4, 7, 7, 5, 9, 5, 0, 3, 8, 7, 5, 8, 1, 5, 8, 6, 1, 8, 3, 0, 3, 7, 9, 2, 7, 0, 5, 8, 8, 5, 7, 0, 9, 9, 1, 9, 4, 4, 6, 8, 6, 3, 3, 8, 5, 1, 6, 3, 4, 6, 7, 0, 7, 8, 2, 7, 6, 8, 9, 5, 6, 5, 6, 1, 4, 0, 1, 0, 0, 9, 4, 8, 0, 9, 1, 2, 8, 5, 0, 2, 5, 3, 3};
set<pair<int, int>> st;

bool vd(int m, int d)
{
    if (d < 1)
        return 0;
    if (m == 2)
        return d <= 28;
    if (m == 4 || m == 6 || m == 9 || m == 11)
        return d <= 30;
    return d <= 31;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int yei[2] = {58, 59}; // 年份结束的下标
    for (int idx = 0; idx < 2; idx++)
    {
        int i_3 = yei[idx];
        for (int i_4 = i_3 + 1; i_4 < 100; i_4++)
        {
            if (arr[i_4] != 0 && arr[i_4] != 1)
                continue;
            for (int i_5 = i_4 + 1; i_5 < 100; i_5++)
            {
                int m = arr[i_4] * 10 + arr[i_5];
                if (m < 1 || m > 12)
                    continue;
                for (int i_6 = i_5 + 1; i_6 < 100; i_6++)
                {
                    if (arr[i_6] < 0 || arr[i_6] > 3)
                        continue;
                    for (int i_7 = i_6 + 1; i_7 < 100; i_7++)
                    {
                        int d = arr[i_6] * 10 + arr[i_7];
                        if (vd(m, d))
                            st.insert(make_pair(m, d));
                    }
                }
            }
        }
    }
    cout << st.size() << endl;
    return 0;
}
```

### 答案

答案为 $235$。

## B

### 问题

题目要求计算一个长度为 $23333333$ 的 $01$ 串中 $0$ 出现的次数，已知信息熵为 $11625907.5798$ 且 $0$ 的个数少于 $1$ 的个数。香农信息熵的公式为：

$$H(S) = -\sum_{i=1}^{n} p(x_i) \log_2 p(x_i)$$

其中 $p(0)$ 和 $p(1)$ 分别是 $0$ 和 $1$ 在串中的占比。设 $0$ 的个数为 $i$，则 $1$ 的个数为 $j = 23333333 - i$。信息熵可简化为：

$$
H(S) = -\left[ i \cdot \frac{i}{n} \log_2 \left(\frac{i}{n}\right) + j \cdot \frac{j}{n} \log_2 \left(\frac{j}{n}\right) \right]
$$

其中 $n = 23333333$。由于 $0$ 的个数少于 $1$ 的个数，$i$ 的范围为 $1 \leq i \leq \lfloor \frac{n}{2} \rfloor$。

### 思路

我们采用两种策略结合的方法：
- 遍历 $i$ 时，一旦找到满足精度要求 $|H - \text{target}| < 0.01$ 的解，立即输出；
- 同时记录全局最小误差的解，确保最终输出的是精度差最小的答案。

### 步骤
1. 初始化：
   - 总长度 $n = 23333333$；
   - 目标信息熵 $\text{target} = 11625907.5798$；
   - 最小误差初始化为极大值 $\text{min\_diff} = \infty$；
   - 最优解 $\text{ans} = 0$。

2. 枚举 $0$ 的个数 $i$：
   - 遍历范围：$i$ 从 1 到 $\lfloor \frac{n}{2} \rfloor$；
   - 计算 1 的个数 $j = n - i$。

3. 计算信息熵：
   - 计算概率：$p0 = \frac{i}{n}$, $p1 = \frac{j}{n}$；
   - 计算熵值：$H = -\left[ i \cdot p0 \cdot \log_2(p0) + j \cdot p1 \cdot \log_2(p1) \right]$。

4. 检查精度：
   - 计算绝对误差 $\text{diff} = |H - \text{target}|$；
   - 若 $\text{diff} < 0.01$，输出 $i$ 并立即终止程序；
   - 同时记录最小误差解：若 $\text{diff} < \text{min\_diff}$，更新 $\text{min\_diff}$ 和 $\text{ans}$。

5. 输出结果：
   - 若找到精确匹配则已退出；
   - 否则输出全局最小误差解 $\text{ans}$。

### 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 23333333;
const double T = 11625907.5798;

int main()
{
    double md = 1e18;
    int a = 0;
    for (int i = 1; i <= N / 2; i++)
    {
        int j = N - i;
        double p0 = 1.0 * i / N;
        double p1 = 1.0 * j / N;
        double h = -(i * p0 * log2(p0) + j * p1 * log2(p1));
        double d = fabs(h - T);
        if (d < 0.01)
        {
            cout << i;
            return 0;
        }
        if (d < md)
        {
            md = d;
            a = i;
        }
    }
    cout << a << endl;
    return 0;
}
```

### 验证

答案为 $11027421$，验证如下：

- $0$ 的个数：$i = 11027421$；
- $1$ 的个数：$j = 23333333 - 11027421 = 12305912$；
- 概率计算：
  $$p0 = \frac{11027421}{23333333} \approx 0.4727$$
  $$p1 = \frac{12305912}{23333333} \approx 0.5273$$
- 信息熵计算：
  $$H \approx 11625907.5798 \quad (\text{误差} < 10^{-5})$$

### 答案

答案为 $11027421$。

## 代码

```cpp
#include<iostream>
#include<string>
using namespace std;
int main() {
    string ans [] = {
        "235", // 试题 A 答案
        "11027421", // 试题 B 答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---

## 作者：ZhaoV1 (赞：0)

日期统计

数字个数有 $100$ 个，由于要严格满足年份为 $2023$，并判断此年是平年，所以我们可以分别对年份，月份，日简单剪枝（数据不大所以不需要剪太细），做一个 dfs 找子序列即可。

应该注意的是，需要求**不同**的满足条件的日期，所以需要手动对答案去重，这里用集合存数组的方式比较方便。




```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+5;
int t,n = 100;
vector<int> a(10);
set<vector<int>> se;
int arr[105];
void dfs(int p,int idx){
	//不断剪枝：
	if(p == 1)
		if(a[p] != 2) return;
	if(p == 2)
		if(a[p] != 0) return;
	if(p == 3)
		if(a[p] != 2) return;
	if(p == 4)
		if(a[p] != 3) return;
	if(p == 8){
		int A,b,c;
		A = a[1]*1000+a[2]*100+a[3]*10+a[4];
		b = a[5]*10+a[6];
		c = a[7]*10+a[8];
		if(A!=2023) return;
		if(!(b>=1&&b<=12)) return;
		if(b==1||b==3||b==5||b==7||b==8||b==10||b==12){//31days
			if(!(c>=1&&c<=31)) return;
		}else if(b==2){//28days
			if(!(c>=1&&c<=28)) return;
		}else{//30days
			if(!(c>=1&&c<=30)) return;
		}
		se.insert(a);
		return;
	}
	for(int i=idx;i<=n;i++){
		a[p+1] = arr[i];
		dfs(p+1,i+1);
	}
}

void solve(){
	for(int i=1;i<=n;i++) cin >> arr[i];
	dfs(0,1);
	cout << se.size() << '\n';
}
```
01 串的熵

该题要注意使用浮点数类型来存值。

题目已给出公式，已知 $H(S)=11625907.5798$，且 01 串中 $0$ 的个数小于 $1$ 的个数，已知基数 $n=23333333$，那么遍历 $1≤i≤\lfloor\frac{n}{2}\rfloor$，利用 $H(S)$ 精度差的大小来找出使得精度差最小的的 $i$ 即可。



```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
#define INF 0x3f3f3f3f3f3f3f3f

int t,n;
double x;
void solve(){
	x = 11625907.5798;
	n = 23333333;
	double Min = INF;
	int res = 0;
	for(int i=1;i<=(int)(n/2);i++){//i为0的个数
		double num = -(i)*((double)i/n*log2((double)i/n)) -(n-i)*((double)(n-i)/n*log2((double)(n-i)/n));
		if(fabs(Min-x) > fabs(num-x)){
			Min = num;
			res = i;
		}
	}
	cout << res << '\n';
}

```

---


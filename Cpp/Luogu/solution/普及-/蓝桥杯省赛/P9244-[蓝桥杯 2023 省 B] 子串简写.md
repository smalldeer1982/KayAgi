# [蓝桥杯 2023 省 B] 子串简写

## 题目描述

程序猿圈子里正在流行一种很新的简写方法：对于一个字符串，只保留首尾字符，将首尾字符之间的所有字符用这部分的长度代替。例如 `internationalization` 简写成 `i18n`，`Kubernetes`（注意连字符不是字符串的一部分）简写成 `K8s`，`Lanqiao` 简写成 `L5o` 等。

在本题中，我们规定长度大于等于 $K$ 的字符串都可以采用这种简写方法(长度小于 $K$ 的字符串不配使用这种简写)。

给定一个字符串 $S$ 和两个字符 $c_{1}$ 和 $c_{2}$，请你计算 $S$ 有多少个以 $c_{1}$ 开头 $c_{2}$ 结尾的子串可以采用这种简写？

## 说明/提示

**【样例说明】**

符合条件的子串如下所示，中括号内是该子串：
```plain
[abab]abdb
[ababab]db
[abababdb]
ab[abab]db
ab[ababdb]
abab[abdb]
```

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$2 \leq K \leq|S| \leq 10^4$。

对于 $100 \%$ 的数据，$2 \leq K \leq|S| \leq 5 \times 10^{5}$。$S$ 只包含小写字母。$c_{1}$ 和 $c_{2}$ 都是小写字母。

$|S|$ 代表字符串 $S$ 的长度。 

蓝桥杯 2023 省赛 B 组 G 题。

## 样例 #1

### 输入

```
4
abababdb a b```

### 输出

```
6```

# 题解

## 作者：dbywsc (赞：23)

### 思路

用两个指针遍历字符串即可。

指针 $i$ 开始时指向第一位，指针 $j$ 开始时指向第 $k$ 位，如果 $i$ 指针指向的字符是 $c_{1}$ 就用 $cnt$ 记录一下当前 $c_{1}$ 出现过的次数，如果 $j$ 指针指向 $c_{2}$ 就让 $ans$ 加上 $cnt$。这样的话在每次遇到 $c_{2}$ 时之前记录的 $c_{1}$ 都可以与它组成子串，能够覆盖所有长度不小于 $k$ 的子串的情况。

### 代码

```cpp
void solve(void) {
    int k; string s; char c1, c2;
    cin >> k >> s >> c1 >> c2;
    int ans = 0, cnt = 0;
    s = " " + s;
    for(int i = 1, j = k; j <= s.length(); i++, j++) {
        if(s[i] == c1) cnt++;
        if(s[j] == c2) ans += cnt;
    }
    cout << ans << endl;
}
```

---

## 作者：gzj__ (赞：6)

~~水题~~
# 思路

要解决这个问题，需统计字符串中以第一个指定字符开头、第二个指定字符结尾且长度不小于给定值的子串数量。

解题思路基于**前缀和**思想：

先构建一个前缀计数数组，记录到每个位置为止第一个指定字符出现的累计次数。遍历字符串中所有是第二个指定字符的位置，这些位置可作为子串的结尾。对于每个符合条件的结尾位置，根据长度要求计算出对应的开头位置范围，利用前缀计数数组快速获取该范围内第一个指定字符的数量，即为以当前位置为结尾的有效子串数量。最后累加所有有效数量，得到最终结果。

# AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string t; 
char a,b;
long long res,len,k;
int cnt[500005]; // 存储前缀计数
int main(){
    cin>>k>>t>>a>>b;
    len=t.size();
    // 前缀计数：cnt[i]表示前i个字符中a的出现次数
    cnt[0]=0;
    for(int i=1;i<=len;i++){
        cnt[i] = cnt[i-1] + (t[i-1]==a);
    }
    // 遍历所有可能的结尾位置
    for(int i=k-1;i<len;i++){
        if(t[i]==b){
            // 累加符合条件的开头数量
            res+=cnt[i-k+2];
        }
    }   
    cout<<res;
    return 0;
}
```
点个赞吧 qwq

---

## 作者：Erik_Aoi (赞：6)

### 题意
给定一个长度为 $n$ 的字符串 $S$，统计满足以下条件的子串数量：

+ 子串的首字符为 $c_1$；
+ 子串的尾字符为 $c_2$；
+ 子串的长度大于等于 $k$。

### 思路

#### 法一：二分
设字符串的长度为 $n$，记两个特定字符为 $c_1$ 与 $c_2$。定义数组

$$P_{c_1}=\{\,i\in\{1,2,\dots,n\}\mid \text{字符串的第 \(i\) 个字符为 } c_1\,\}$$

$$P_{c_2}=\{\,j\in\{1,2,\dots,n\}\mid \text{字符串的第 \(j\) 个字符为 } c_2\,\}$$

注意到 $P_{c_1}$ 与 $P_{c_2}$ 中的元素均按从小到大排列。

定义阈值 $T=i+k−1$，令 $N(i)=\{\,j\in P_{c_2}\mid j\ge T\,\}$，由于 $P_{c_2}$ 为递增序列，令 $j_0$ 为 $P_{c_2}$ 中第一个满足 $j_0\ge T$ 的元素，则从 $j_0$ 开始所有元素均属于 $N(i)$，其个数为 $|N(i)|$。

因此，最终答案：

$$ans=\sum_{i\in P_{c_1}}|N(i)|$$

在实际求解中，可利用二分查找在 $P_{c_2}$ 中确定每个 $i$ 对应的 $j_0$，因此整体时间复杂度为 $O(n\log n)$，可 AC 本题。

```cpp
#include <iostream>
#include <vector>
#define int long long
using namespace std;

string S;
char c1, c2;
int k;
vector<int> pos_c1, pos_c2;

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> k >> S >> c1 >> c2;
    for (int i = 0; i < S.size(); i++) {
        if (S[i] == c1) pos_c1.push_back(i);
        if (S[i] == c2) pos_c2.push_back(i);
    }
    int ans = 0;
    for (auto it : pos_c1) {
        ans += pos_c2.end() - lower_bound(pos_c2.begin(), pos_c2.end(), it + k - 1);
    }

    cout << ans;

    return 0;
}


```

#### 法二：单调队列

在法一的启发下，使用队列表示 $P_{c_1}$ 及 $P_{c_2}$。

考虑 $P_{c_2}$ 的**递增**顺序，对于每个 $i\in P_{c_1}$，将队列 $P_{c_2}$ 中的不满足 $j\ge T$ 的队首元素 $j$ 舍去。由于 $P_{c_1}$ 也是**递增**的，那么这些元素在下一个 $i$ 时同样需要舍去，因此这个操作是线性的——每个元素最多只会有一次操作。

设舍去操作后剩下的 $P_{c_2}$ 中的元素个数为 $|P_{c_2}(i)|$，则当前以 $i$ 为首字符的合法组合即有 $|P_{c_2}(i)|$ 个。最终答案 $ans$ 即为：

$$ans=\sum_{i\in P_{c_1}}|P_{c_2}(i)|$$

该方法的时间复杂度即为 $O(n)$。

```cpp
#include <iostream>
#include <queue>
#define int long long
using namespace std;

string S;
char c1, c2;
int k;
queue<int> pos_c1, pos_c2;

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> k >> S >> c1 >> c2;
    for (int i = 0; i < S.size(); i++) {
        if (S[i] == c1) pos_c1.push(i);
        if (S[i] == c2) pos_c2.push(i);
    }
    int ans = 0;
    while (!pos_c1.empty()) {
        int top = pos_c1.front();
        pos_c1.pop();
        while (!pos_c2.empty() and pos_c2.front() < top + k - 1) pos_c2.pop();
        ans += pos_c2.size();
    }
    cout << ans;

    return 0;
}


```

---

## 作者：weifengzhaomi (赞：5)

~~两年前的题了，居然还能写题解。~~

## 题意：

现在有一个字符串，又有两个字符，求序列中有几个子序列是以第一个字符开头，以第二个字符结尾。

## 思路 1.0

考虑暴力枚举两个位置，第一个位置要**严格小于**的二个位置，看一下是否满足条件即可。

### 代码：

```cpp
for (int i = 1;i < l;i++)
	for (int j = i + 1;j <= l;j++)
		if (s[i] == c1 && s[j] == c2 && j - i + 1 >= k) ans++;
```

时间复杂度：$O(n ^ 2)$。

预期分数：$20$ 分。

## 思路 2.0

既然上面的思路过不了，就要考虑更快的做法。

考虑**双指针**。

设指针一号的初始值为 $1$，指针二号的初始值为 $k$，确保**长度严格大于等于 $k$**。

接着，两个指针每次加一，**如果第一个指针所指向的字符是第一个字符，那么计数器加一。如果第二个指针所指向的字符是第二个字符，那么答案加上计数器的值。**

那么为什么这样做是对的呢？

因为，**可以保证，每次所枚举的两个数之间超过了 $k$。**

哪怕现在枚举到了符合条件的字符，他们的距离也是 $k + 1$，这个应该很容易理解，因为每次枚举的两个字符距离始终为 $k$。

那么，后面的字符与现在的字符距离自然会超过 $k$，这就是为什么上面的做法是对的。

### 代码：

```cpp
int l = 1,r = k,a = s.size();
while (r <= a){
  if (s[l] == c1) cnt++;
  if (s[r] == c2) ans += cnt;
}
```

最后，**注意爆`int`。**

---

## 作者：liborui0000 (赞：3)

## P9244 题解

### 核心:

通过前缀和预处理出 $c2$ 的数量，然后遍历字符串。如果遇到 $c1$ 就把它之后 $k$ 个数和 $n$（字符串长度）之间的 $c2$ 的数量加到答案中去。

### 注意

一定要判断好边界条件！！！特别是用前缀和求 $c1$ 之后 $k$ 个数和 $n$ 之间的 $c2$ 数量的时候。

一定要开 long long！！！

### 代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

long long k;
string s;
char l, r;
long long sumb[500010];

int main(){
	cin >> k;
	cin >> s >> l >> r;
	long long n = s.size();
	for (int i = 0; i < n; i++){
		if (s[i] == r) sumb[i + 1] = sumb[i] + 1;		
		else sumb[i + 1] = sumb[i];
	}

	long long ans = 0;
	for (int i = 1; i <= n - k + 1; i++){
		if (s[i - 1] == l){
 			if (i + k - 1 <= n){
				ans += sumb[n] - sumb[i + k - 2];
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：weizilong (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P9244)
## 闲话
本蒟蒻第三篇题解，这个题怎么没有人写前缀和（不敢想象，我居然敢给两年前的题目投题解）。
# 正文

## 题目重述
这道题要求我们统计所有以 $c1$ 开头、$c2$ 结尾且长度 $\ge K$ 的子串。
## 代码思路
使用前缀和数组 $q$ 记录每个位置之前 $c1$ 出现的次数。再次遍历字符串，当遇到 $c2$ 时，通过前缀和快速查询前面满足条件（子串长度 $\ge K$）的 $c1$ 数量。

### 代码实现细节‌
#### 前缀和预处理

```cpp
for(int i=1;i<l;i++){
    q[i]=q[i-1]+(s[i-1]==c1);
}
```
- $q_i$ 表示前 $i$ 个字符中 $c1$ 的出现次数。
- 注意这里从 $i=1$ 开始，$s_{i-1}$ 对应第 $i$ 个字符。

#### 统计结果：

```cpp
for(int i=k-1;i<l;i++){
    if(s[i]==c2)ans+=q[i-k+2];
}
```
- 遍历每个可能的结尾位置 $i$。
- 当 $s_i$ 是 $c2$ 时，查找前面满足条件的 $c1$ 数量。
- $i-k+2$ 计算的是：当前子串起始位置至少要在 $i-K+1$ 之前。

### 关键点说明‌

-  $q_{i-k+2}$ 表示从开头到 $i-K+1$ 位置的所有 $c1$ 的数量。
- 这样保证子串长度 $\ge K$（因为 $i-(i-K+1)+1=K$）。
- 使用 `long long` 类型防止大数溢出。

### 时间复杂度‌
两次线性遍历：$O(n)$。
适用于最大 $5×10^5$ 的数据规模是完全可行的。
## 代码
最终代码如下，完结撒花。**（〃'▽'〃）**

```cpp
#include<bits/stdc++.h>
using namespace std;
string s; 
char c1,c2;
long long ans,l,k;
int main(){
	cin>>k>>s>>c1>>c2;
	l=s.size();
	vector<int> q(l+5,0);
	for(int i=1;i<l;i++){
		q[i]=q[i-1]+(s[i-1]==c1);
	}
	for(int i=k-1;i<l;i++){
		if(s[i]==c2)ans+=q[i-k+2];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Aventurine_ (赞：2)

## 题意
统计字符串 $S$ 中首字母为 $c_1$，尾字母为 $c_2$，且长度大于等于 $k$ 的字串个数。
## 思路/解法
由数据范围知，使用暴力枚举，时间复杂度为 $O(n^2)$，明显过不了。

那么我们需要效率更高的算法，可以考虑**双指针**。

为什么双指针是对的呢？我们设 $l=1$，则 $r$ 的初值应为 $k$，因为求子串需要做到不重不漏，所以当 $r$ 向右移动时，$l$ 一定不会向左运动，满足双指针的单调性。

那么我们怎么实现呢？可以记录一个 $sum$ 表示当前 $l$ 走过的位置有几个 $c_1$，记录 $ans$ 表示答案，当 $r$ 所处位置的字符等于 $c_2$ 时，这个位置就可以和前面所有 $c_1$ 组成满足条件的子串，所以让 $ans$ 加上 $sum$，最后遍历完一遍就是答案了，注意要让子串满足长度大于等于 $k$，只需要每次让 $l$ 和 $r$ 移动的距离一样即可。

时间复杂度为 $O(n)$ 显然可以通过此题。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long //注意一定要开 long long，不然过不了
using namespace std;
const int N=2e5+10;
string s;
char a,b;
int k,sum,ans;//sum记录c1次数，ans记录答案
signed main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>k>>s>>a>>b;
	int n=s.size();//字符串长度
	s=" "+s;//方便我们下面循环
	int l=1,r=k;//因为字串长度必须大于等于k，所以r初始值为k
	while(r<=n)
	{
		if(s[l]==a)sum++;//记录c1出现的次数
		if(s[r]==b)ans+=sum;//如果出现c2，那么它和之前所有c1都能组成字串
		l++,r++;//指针移动
	}
	cout<<ans;
	return 0;//结束
}
```

---

## 作者：pengguoen (赞：1)

[AC记录](https://www.luogu.com.cn/record/223949021)
## 一、思路

首先读取输入参数，然后使用前缀和数组统计  $c2$ 字符的出现次数。对于每个 $c1$ 字符，计算其后面 $k-1$ 位置之后所有 $c2$ 字符的数量，累加得到结果。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
## 二、代码实现

```cpp
#include<bits/stdc++.h> 
using namespace std;

int main() 
{
    int k;
    char c1,c2;
    string s;
    cin>>k>>s>>c1>>c2;
    int n=s.size();
    vector<int>prefix(n+1,0);
    long long ans=0;
    // 预处理前缀和数组
    for(int i=1;i<=n;++i) 
	{
        prefix[i]=prefix[i-1]+(s[i-1]==c2?1:0);
    }
    // 遍历每个可能的起始位置
    for(int i=0;i<=n-k;++i) 
	{
        if(s[i]==c1) 
		{
            int j=i+k-1;
            if(j<n) 
			{
                ans+=prefix[n]-prefix[j];
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：yzz6636 (赞：0)

## P9244 [蓝桥杯 2023 省 B] 子串简写 题解
### 题目分析
给定一个字符串，要我们找到所有长度大于等于 $k$，且是以 $c1$ 开头以 $c2$ 结尾的子串有多少个。
### 思路
枚举整个字符串，找到里面所有的 $c1$。  
我们的子串必须以 $c1$ 开头，那么所有子串的起点就被我们找到了。  
前缀和： $sum_i = sum_{i - 1} + 1$ // 计算 $1 - i$ 之间的和。  
后缀和:  $sum_i = sum_{i + 1} + 1$ // 计算 $i - n$ 之间的和。  
### 需要注意的点
$cnt$ （最后的答案）要开`long long`。  
$sum$ 数组（后缀和数组）的下标要开到 $5 \times 10^6$。
### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 5e6 + 5;
int sum[maxn];
int main() {
	int k;
	string s;
	char c1, c2;
	cin >> k >> s >> c1 >> c2;
    int l = s.size();
	for (int i = l - 1; i >= 0; i--) {
		sum[i] = sum[i + 1];
		if (s[i] == c2)
			sum[i]++;
	}
	ll cnt = 0; //这里要开long long
	for (int i = 0; i < l; i++) 
		if (s[i] == c1) 
			cnt += sum[i + k - 1];
	cout << cnt;
	return 0;
}
```

---


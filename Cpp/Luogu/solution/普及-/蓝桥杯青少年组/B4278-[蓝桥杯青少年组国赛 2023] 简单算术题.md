# [蓝桥杯青少年组国赛 2023] 简单算术题

## 题目描述

给定一道没有括号的四则混合运算算术题（可能包含多余的空格），请编程计算出结果。运算规则如下：  
1. 既有乘、除法又有加、减法的，要先算乘除法，再算加减法；  
2. 同级运算时，要从左往右按顺序计算；  
3. 所有除法运算的结果都只保留整数部分（直接舍弃小数部分）。

**例如**：当算术题为 $\tt{2 + 3*4 - 10/6 + 1/2*4}$ 时：  
- 优先计算乘除法，有 $\tt{3*4=12}$，$\tt{10/6=1}$，$\tt{1/2*4=0}$；  
- 然后计算加减法，$\tt{2+3*4-10/6+1/2*4} = \tt{2+12-1+0} = \tt{13}$，故输出 $13$。  

## 样例 #1

### 输入

```
2+3*4-10/6+1/2*4```

### 输出

```
13```

# 题解

## 作者：wangxiaochai (赞：6)

感觉之前的题解写复杂了……

这题的算法标签是“栈”。但是按照栈先进后出的原则，没办法让公式从左到右计算，需要对栈进行转置才行。

那直接用“队列”不就好了？队列不就正好是先进先出嘛。因为涉及到对队尾和队首同时操作，所以本题选择用双向队列来存储数据。

剩下按照题意模拟一遍即可。因为乘法和除法是一样的优先级，加法和减法是一样的优先级，所以为了代码简洁，可以使用三元运算符。


```
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

int x;
char c;
vector <char> op;
deque <int> q;

int main()
{
    cin >> x;
    q.push_back(x);
    while (cin >> c >> x)
    {
        if (c=='*' || c=='/')
        {
            x = c=='*'? x*q.back() : q.back()/x;
            q.pop_back();
            q.push_back(x);
        } else
        {
            op.emplace_back(c);
            q.push_back(x);
        }
    }
    x = q.front();
    for (auto p : op)
    {
        q.pop_front();
        x = p=='+'? x+q.front() : x-q.front(); 
    }
    cout << x;
    return 0;
}
```

---

## 作者：Gongyujie123 (赞：4)

## [B4278 [蓝桥杯青少年组国赛 2023] 简单算术题](https://www.luogu.com.cn/problem/B4278) 题解
本篇题解与别的题解有不同，用了~~应该是~~类似**链表**。
### 1. 思路分析

```cpp
int a[100005];
struct symbol{
	int l, r, ll, rr;
	char f;
}b[100005];
```
首先，定义一个 `int` 数组，用来存储每个数字。再定义一个结构体，其中 `f` **存储运算符**，`l` 存储为**这个运算符左边的数的下标**，`r` 存储为**这个运算符右边的数的下标**，`ll` 存储为**这个运算符左边的运算符的下标**，`rr` 存储为**这个运算符右边的运算符的下标**。

然后，进行输入。每次读入一个整数和一个运算符，重复读入，直到没有读入到运算符，就退出循环执行下一步。对于每次读入的一个整数，把它存到数组中；对于每次读入的一个运算符，也把它存到数组中，并**设置它左、右数字的下标和它左、右运算符的下标**。

最后，进行运算。分两步进行，第一步进行**乘除运算**，第二步进行**加减运算**。下面代码以乘法为例（**有点绕，建议仔细阅读**）：

```cpp
a[b[i].l] *= a[b[i].r];  // 将第 i 个运算符左右的数相乘，并将结果存在左边的数中。
a[b[i].r] = 0;  // 将右边的数设为 0。
b[b[i].ll].r = b[i].l;  // 将第 i 个运算符左边的运算符的右边的数 设为 运算后的结果。
b[b[i].rr].l = b[i].l;  // 将第 i 个运算符右边的运算符的左边的数 设为 运算后的结果。
b[b[i].ll].rr = b[i].rr;  // 将第 i 个运算符左边的运算符的右边的运算符 设为 第 i 个运算符右边的运算符。
b[b[i].rr].ll = b[i].ll;  // 将第 i 个运算符右边的运算符的左边的运算符 设为 第 i 个运算符左边的运算符。
```

### 2. AC 代码
[AC 记录](https://www.luogu.com.cn/record/214924880)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
struct symbol{
	int l, r, ll, rr;
	char f;
}b[100005];
signed main(){
	int x, cnt = 1;
	char c = 1;
	b[0].r = 1;
	while (1) {
		cin >> x;
		a[cnt] = x;
		cin >> c;
		if (c == 1) break;  // 如果 c 是输入前设定的数，就代表输入完了 
		cnt++;
		if (cnt == 2) b[0].rr = cnt;
		b[cnt].f=c;
		b[cnt].l = cnt - 1; b[cnt].r = cnt + 1;  // 设置左右数的下标 
		b[cnt].ll = cnt - 2; b[cnt].rr = cnt + 2;  // 设置左右运算符的下标 
		c = 1;
		cnt++;
	}
	for (int i = b[0].rr; i < cnt; i = b[i].rr) {
		if (b[i].f == '*') {
			a[b[i].l] *= a[b[i].r];  // 将第 i 个运算符左右的数相乘，并将结果存在左边的数中。
		}
		if (b[i].f == '/') {
			a[b[i].l] /= a[b[i].r];  // 将第 i 个运算符左右的数相整除，并将结果存在左边的数中。
		}
		if (b[i].f == '*' || b[i].f == '/') {
			a[b[i].r] = 0;  // 将右边的数设为 0。
			b[b[i].ll].r = b[i].l;  // 将第 i 个运算符左边的运算符的右边的数 设为 运算后的结果。
			b[b[i].rr].l = b[i].l;  // 将第 i 个运算符右边的运算符的左边的数 设为 运算后的结果。
			b[b[i].ll].rr = b[i].rr;  // 将第 i 个运算符左边的运算符的右边的运算符 设为 第 i 个运算符右边的运算符。
			b[b[i].rr].ll = b[i].ll;  // 将第 i 个运算符右边的运算符的左边的运算符 设为 第 i 个运算符左边的运算符。
		}
	}
	for (int i = b[0].rr; i < cnt; i = b[i].rr) {
		if (b[i].f == '+') {
			a[b[i].l] += a[b[i].r];  // 将第 i 个运算符左右的数相加，并将结果存在左边的数中。
		}
		if (b[i].f == '-') {
			a[b[i].l] -= a[b[i].r];  // 将第 i 个运算符左右的数相减，并将结果存在左边的数中。
		}
		if (b[i].f == '+' || b[i].f == '-') {
			a[b[i].r] = 0;
			b[b[i].ll].r = b[i].l;
			b[b[i].rr].l = b[i].l;
			b[b[i].ll].rr = b[i].rr;
			b[b[i].rr].ll = b[i].ll;
			// 同上 
		}
	}
	cout << a[b[0].r] << endl;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：4)

### 解题思路

由于本题存在加减乘除四则运算，那么我们要做的第一步就是先处理乘除法运算。

遍历一遍字符串，若运算符为乘除，则需要计算后放入栈中，反之直接放入栈中。

那么当上述步骤完成时，已经将所有乘除操作处理。

此时，符号栈中只有加减符号。加减为同级运算，所以需要从左往右按照顺序计算。

栈是先进后出的结构，所以栈顶存着的是靠后的数据。

为了实现从左往右按顺序计算，则需要将所有的栈进行翻转。

### AC_Code

```cpp
#include <iostream>
#include <algorithm>
#include <stack>

using namespace std;

stack<int> stk;
string ops;

int main()
{
    int x;
    char c;
    cin >> x;
    stk.push(x);
    
    while (cin >> c >> x)
        if (c == '*')
        {
            auto y = stk.top();
            stk.pop();
            stk.push({y * x});
        }
        else if (c == '/')
        {
            auto y = stk.top();
            stk.pop();
            stk.push({y / x});
        }
        else
        {
            ops += c;
            stk.push(x);
        }

    reverse(ops.begin(), ops.end());
    stack<int> tmp;
    while (stk.size())
        tmp.push(stk.top()), stk.pop();
    stk = tmp;
    
    while (ops.size())
    {
        auto a = stk.top();
        stk.pop();
        auto b = stk.top();
        stk.pop();
        auto c = ops.back();
        ops.pop_back();

        if (c == '+')
            stk.push(a + b);
        else
            stk.push(a - b);
    }

    cout << stk.top() << endl;
    
    return 0;
}
```

---

## 作者：songyuteng (赞：2)

# **B4278 题解**

## **题目意思：**
题目意思也简单，就是四则运算。不过会有空格。

本蒟蒻的做法是用栈来做。一个栈用来存数字，一个用来存字符。

**第一步：**
我们需要用 for 循环筛出数字，代码如下。

```cpp
if(isdigit(k[i])){//判断字符串k的第i个字符是不是数字
			long long sum=k[i]-'0';
			while(i+1<len&&isdigit(k[i+1])){//如果是，可能数字位数不止一个，所以要用while循环把整个数字取出来
				sum*=10;
				sum+=k[i+1]-'0';
				i++;
			}
			sta.push(sum);//放入存数字的栈中
		}
```
**第二步：**
如果是运算符（题目也是很良心，没有括号），那么就要判断。

存储字符的栈最上面的运算符是否比这个运算符的优先级高（如果优先级一样，也要）。

如果栈顶运算符运算级大于等于这个运算符的话。就要计算栈顶的运算符（栈顶没有元素就直接入栈）。

代码如下

```cpp
a['+']=a['-']=2,a['*']=a['/']=3,a['^']=4;//标记优先级
while(!stb.empty()&&a[stb.top()]>=a[k[i]]){//判断是否要计算
				jisuan(stb.top());//进行计算
				stb.pop();
			}
			stb.push(k[i]);//最后还要把这个运算符放到栈中
```

**第三步：**
就是计算，其实也没多难，直接看代码。

```cpp
void jisuan(char c){
	long long x=sta.top();//取栈顶第一个元素
	sta.pop();
	long long y=sta.top();//取栈顶第二个元素
	sta.pop();
  //加减乘除运算
	if(c=='+') sta.push(y+x);
	else if(c=='-') sta.push(y-x);
	else if(c=='*') sta.push(y*x);
	else if(c=='/') sta.push(y/x);
}
```
好的，接下来看完整代码。

```cpp
#include<bits/stdc++.h>//因为前面有注释了，这里就不写了
using namespace std;
string k;
long long len,a[300];
stack<long long> sta;
stack<char> stb;
void jisuan(char c){
	long long x=sta.top();
	sta.pop();
	long long y=sta.top();
	sta.pop();
	if(c=='+'){
		sta.push(y+x);
	}
	else if(c=='-'){
		sta.push(y-x);
	}
	else if(c=='*'){
		sta.push(y*x);
	}
	else if(c=='/'){
		sta.push(y/x);
	}
}
int main(){
	getline(cin,k);
	a['+']=a['-']=2,a['*']=a['/']=3,a['^']=4;
	len=k.size();
	for(long long i=0;i<len;i++){
		if(k[i]==' ') continue;
		else if(isdigit(k[i])){
			long long sum=k[i]-'0';
			while(i+1<len&&isdigit(k[i+1])){
				sum*=10;
				sum+=k[i+1]-'0';
				i++;
			}
			sta.push(sum);
		}
		else{
			while(!stb.empty()&&a[stb.top()]>=a[k[i]]){
				jisuan(stb.top());
				stb.pop();
			}
			stb.push(k[i]);
		}
	}
	while(!stb.empty()){
		jisuan(stb.top());
		stb.pop();
	}
	cout<<sta.top();
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：1)

分享一个乱搞做法。

## 思路

既然是求运算符的值，肯定少不了 Python。\
我们可以使用 `eval()` 函数来求一个表达式的值，函数内仅一个字符串参数，代表待求值的表达式。\
于是我们很快就有如下代码：

```python
s = input()
print(eval(s))
```

一交，[$20$ 分](https://www.luogu.com.cn/record/215071485)。

测一下样例，发现连样例都无法通过，怎么是一个小数？\
这是因为 Python 的一个特性：使用 `/` 进行除法，答案将会是一个浮点数。就算是计算 `6 / 2` 这个表达式，答案也会是 `3.0`。而只有 `//` 运算符可以进行整除操作，相当于我们 C++ 中的 `/` 符号。\
因此，我们可以使用 `replace()` 函数替换字符串中的所有子串。例如，`s.replace('/', '//')` 就是把字符串 `s` 中的所有 `/` 替换成 `//`。

于是我满怀信心的提交了如下代码：

```python
s = input().replace('/', '//')
print(eval(s))
```

不对，怎么只有 [$60$ 分](https://www.luogu.com.cn/record/215071470)，有 $4$ 个测试点 RE？\
这是因为，$10^5$ 个字符的算式，计算复杂程度远超 Python 的递归层数限制范围，这个时候就会有同学问了：

> 主播主播，你的 `eval()` 和 `replace()` 确实很牛，但是面对这么长的算式，还是太吃内存和操作了，那有没有什么办法突破递归层数的限制呢？

嘿嘿，当然有的，我们肥肠万能的 `sys` 库中有一个函数叫 `setrecursionlimit()`，这个函数就可以设定代码中递归层数的范围，函数内仅一个参数，代表递归层数上限。\
因此，我们可以把这个上限调成一个比较大的数字（最好大于 $10^5$），问题就能轻松解决啦。

## 正解

```python
import sys # 引入 sys 库
sys.setrecursionlimit(1919810)

s = input().replace('/', '//')
print(eval(s))
```

---

## 作者：wangjue1629 (赞：1)

# Solution

## 题目解析

这道题给我们一个只包含四则运算符（$+ - \times \div$）和数字的表达式，**没有**括号，而且要求我们：

1. **先算乘除，再算加减**；  
2. **同级运算从左到右**；  
3. **除法只保留整数部分**（例如 $5 \div 2 = 2$，忽略小数部分）。  

「先乘除后加减」其实是很多运算场景的常识，但平时我们会用括号或者写在不同行来区分运算顺序；本题恰好没给括号，就需要我们自己按照这种顺序来运算。

举个例子：  

$$2 + 34 - 10 \div 6 + 1 \div 24$$

- 第一步：在整条算式里，先把所有 `*` 和 `/` 都按从左到右计算一遍：
  - $3 \times 4 = 12$
  - $10 \div 6 = 1$（去掉小数部分）
  - $1 \div 2 = 0$，再乘 4 还是 `0`
- 第二步：将上面的结果回填，就得到：
  - $2 + 12 - 1 + 0$
- 第三步：再来一次从左往右进行加减：  
  - $2 + 12 = 14$ 
  - $14 - 1 = 13$ 
  - $13 + 0 = 13$ 

所以整个表达式的值就是 $13$。

---

## 解题思路

为了实现「先乘除、后加减」，可以把表达式**拆分**成一段段“连续的乘除块”，然后用加减符号把这些块组合起来：

1. 从头扫描到尾，每当遇到 $+$ 或 $-$，就意味着「前面那一小段乘除运算已经结束了」。  
2. 对每个“块”里的 $\times$ 和 $\div$，就按照从左到右的顺序一步步算，保证了乘除是按正确的顺序执行的——只要不碰到 $+$ 或 $-$，就一直在乘除之内。  
3. 最后，当我们真正遇到 $+$ 或 $-$ 时，把这一块的运算结果整体地加到（或者减到）最终的答案上。  
4. 当表达式扫描完毕后，如果还有一小段乘除没合并到总结果，也要补上去。

这样就能保证先把乘除算完，再统一做加减，而且每一段乘除的结果用一个临时变量维护。

**除法保留整数部分**可以直接用 C++ 语言中的整除特性：$10 \div 6$ 自动得到 $1$，不会保留小数。

---

## AC代码

```cpp
#include <iostream>
#include <string>
#define ll long long
using namespace std;

ll clac() {
    ll mul = 1;       // 储存当前“乘除块”的中间结果
    ll res = 0;       // 最终累加结果
    char c;           // 用来逐个读取字符
    ll t = 0;         // 正在读取的数字
    bool flag = false;// 标记上一运算符是不是 '/'

    // 循环读取每个非空字符
    while (cin >> c) {
        // 如果读到数字，就组装到 t
        if (c >= '0' && c <= '9') {
            t = t * 10 + (c - '0');
        }
        // 遇到加号 '+'，把这段“乘除”结算进res，开启新的段
        else if (c == '+') {
            if (flag) {     // 如果前一运算符是除号
                mul /= t;
                flag = false;
            } else {        // 如果前一运算符是乘号
                mul *= t;
            }
            res += mul;     // 这一块算完了，加到res
            mul = 1;        // 开启新块 (正号块)
            t = 0;          // 清空t以便下次读数字
        }
        // 遇到减号 '-'，同理
        else if (c == '-') {
            if (flag) {
                mul /= t;
                flag = false;
            } else {
                mul *= t;
            }
            res += mul;
            mul = -1;       // 准备新的块，但带一个负号
            t = 0;
        }
        // 遇到乘号 '*'
        else if (c == '*') {
            if (flag) {
                // 前一次是除号，需要先把那次除法算完
                mul /= t;
                flag = false;
            } else {
                // 前一次是乘号
                mul *= t;
            }
            t = 0;
        }
        // 遇到除号 '/'
        else if (c == '/') {
            if (flag) {
                // 如果仍旧是除法延续，先把之前的除法做完
                mul /= t;
            } else {
                // 否则先做乘法，再进入除法状态
                mul *= t;
            }
            flag = true;  // 标记：下次遇到数字时先完成除法
            t = 0;
        }
    }

    // 表达式读完，还有最后一段乘除要合并
    if (flag) {
        mul /= t;
        flag = false;
    } else {
        mul *= t;
    }
    res += mul;

    return res;
}

int main() {
    cout << clac() << "\n";
    return 0;
}
```
设字符串长度为 $n$，那么时间复杂度为 $O(n)$。可以通过此题。

---

## 作者：lianchanghua (赞：1)

#### 题目大意

给你一个算式，让你求出这个算式的值。

#### 题目思路

既然这个算式只包含 $+$，$-$，$\times$，$\div$。

那么，显而易见的可以直接简单的栈模拟通过此题。

我们可以将题目中的算式进行模拟。

`2+3*4-10/6+1/2*4`

根据优先级，我们要先计算 $\times$，而不是 $+$，所以我们的算法必然不可能一个一个符号傻傻的放入栈里面，我们要进行优先级判断。

那我们什么时候才能计算呢？

答案是当且仅当栈顶元素的符号优先级大于或等于当前符号的时候。此时，说明前面的式子已经输完，可以直接计算其值的大小了。

```cpp
while(!op.empty()&&lv[op.top()]>=lv[c])
```

其他的直接模拟即可。

#### 代码注意

- 计算 $\div$ 和 $-$ 时记得两数相倒。

- 要随时留意栈是否为空。


#### AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
stack<int>num;
stack<char>op;
int len;
map<char,int>lv;
int calc(int x,int y,char oper){
	if(oper=='+')return x+y;
	else if(oper=='-')return y-x;
	else if(oper=='*')return x*y;
	else return y/x;
}
signed main(){
//	ios::sync_with_stdio(false);
//	cin.tie(0);cout.tie(0);
	lv['+']=0;
	lv['-']=0;
	lv['*']=1;
	lv['/']=1;
	char c;
	int x;
	cin>>x;
	num.push(x);
	while(cin>>c>>x){
		
//		cout<<num.top()<<"\n";
		while(!op.empty()&&lv[op.top()]>=lv[c]){
//			cout<<op.top()<<" "<<c[i]<<" "<<i<<"\n";
//			_sleep(100);
			if(num.size()>=2){
				int t1=num.top();num.pop();
				int t2=num.top();num.pop();
//				cout<<t1<<" "<<t2<<" "<<op.top()<<"\n";
				int x=calc(t1,t2,op.top());
				op.pop();
				num.push(x);
			}
		}
		op.push(c);num.push(x);
	}
//	cout<<num.size()<<" "<<op.size()<<"\n";
	int ans;
	while(!num.empty()&&!op.empty()){
		if(num.size()==1){
			cout<<num.top();
			exit(0);
		}
		int t1=num.top();num.pop();
		int t2=num.top();num.pop();
		char oper=op.top();op.pop();
//		cout<<t1<<" "<<t2<<" "<<oper<<"\n";
		int x=calc(t1,t2,oper);
		ans=x;
		num.push(x);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__hjyakioi__ (赞：0)

表达式求值题不能没有 `python`！
## 函数（等）功能介绍
- `input()`：读入一**行**字符串。
- `(str).replace(a,b)`：将 `str` 中所有 `a` 替换为 `b` ，并返回替换完成的字符串。
- `eval(str)`：将 `str` 作为 `python` 语句进行处理，可以引用变量，函数等。
- `print(a,b,...)`：输出对象，默认以**空格**分隔，以**换行**（`\n`） 结尾。
- `sys.setrecursionlimit(x)`：将递归深度限制调整为 $x$。
- `try-except`语句：捕捉 `try` 语句内的[异常](https://www.runoob.com/python/python-exceptions.html)，并进入`except` 语句（如有异常）。\
特殊说明：`python` 中 `/` 为精确除法（不取整），`//` 才是取整的除法。
## 代码
```python
import sys
sys.setrecursionlimit(1000000) #解除递归深度限制，防止RE

try:
    print(eval(input().replace(" ","").replace('/','//')))
    #去除多余空格，将普通除法替换为保留整数的除法，然后解析求值
except Exception as e:
    print(str(e)[8])#捕获异常并输出
```

---


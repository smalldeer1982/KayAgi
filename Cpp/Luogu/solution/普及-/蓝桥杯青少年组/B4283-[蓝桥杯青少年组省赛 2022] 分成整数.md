# [蓝桥杯青少年组省赛 2022] 分成整数

## 题目描述

给定一个正整数 $N$，然后将 $N$ 分解成 $3$ 个正整数之和，计算出共有多少种符合要求的分解方法。要求：
1. 分解的 $3$ 个正整数各不相同；
2. 分解的三个正整数中**各个数位**都不含数字 $3$ 和 $7$。

例如：$N$ 为 $8$，可分解为 $(1, 1, 6)$、$(1, 2, 5)$、$(1, 3, 4)$、$(2, 2, 4)$、$(2, 3, 3)$，其中满足要求的分解方法有 $1$ 种，为 $(1, 2, 5)$。

## 样例 #1

### 输入

```
8```

### 输出

```
1```

# 题解

## 作者：FJ_EYoungOneC (赞：5)

### 解题思路

由于 $(1, 2, 5)$ 和 $(2, 1, 5)$ 是同一种方案，那么为了在选取的过程中避免重复计算，我们可以要求选取的数必须严格单调递增，即 $i < j < k$。

考虑暴力，枚举 $i, j, k$，时间复杂度 $O(n^3\log n)$。

考虑优化，由于 $i+j+k=n$，那么我们可以枚举 $i, j$，用 $n-i-j$ 算出 $k$ 的大小，再判断是否合法即可，时间复杂度 $O(n^2\log n)$。

### AC_Code

```cpp
#include <iostream>

using namespace std;

int n;

bool check(int x)
{
    while (x)
    {
        if (x % 10 == 3 || x % 10 == 7)
            return false;
        x /= 10;
    }
    
    return true;
}

int main()
{
    cin >> n;

    int res = 0;
    for (int i = 1; i <= n; ++ i )
    {
        if (!check(i))
            continue;
        for (int j = i + 1; j <= n; ++ j )
        {
            int k = n - i - j;
            if (k <= j)
                break;
            if (check(j) && check(k))
                res ++;
        }
    }

    cout << res << endl;
        
    return 0;
}
```

---

## 作者：bjcakioi (赞：3)

本题我们可以直接暴力枚举。

根据题意模拟，如果三个数互不相同，并且每一个数位上的数都不是 $3$ 或者 $7$，就算一次满足要求的分解方法。

注意枚举的时候要遵循不降原则，最外层循环枚举最小的数，中间一层循环枚举中间的数，最里层循环枚举最大的数。不然会重复枚举。

最后贴上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			for(int k=j+1;k<=n;k++){
				if(i+j+k==n&&i%10!=3&&i%10!=7&&(i/10)%10!=3&&(i/10)%10!=7&&i/100!=3&&i/100!=7&&j%10!=3&&j%10!=7&&(j/10)%10!=3&&(j/10)%10!=7&&j/100!=3&&j/100!=7&&k%10!=3&&k%10!=7&&(k/10)%10!=3&&(k/10)%10!=7&&k/100!=3&&k/100!=7){
					ans+=1;
					
				}
			}
		}
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：LLY_0827 (赞：1)

## B4283 \[蓝桥杯青少年组省赛 2022] 分成整数

[传送门](https://www.luogu.com.cn/problem/B4283)

### 题意理解

将一个正整数 $N$ 分解成 $3$ 个正整数的和，要求：

- 分解的 $3$ 个正整数各不相同；
- 分解的 $3$ 个正整数中各个数位都不含数字 $3$ 和 $7$。

输出方案数。

### 思路

- 注意到数据范围不大（$5<N<501$），三重循环足矣。
  - 注意到 $k$ 可以直接通过 $n-i-j$ 计算出来，我们可以减少一重循环。
  - 我们可以通过确保 $i<j<k$ 来防止重复枚举。
- 关键是分离数位问题，其实不断将这个数对 $10$ 取余得到对应数位，再除以 $10$ 即可。同理，也可以转换为字符串计算。
- 分离数位相关题目：[B2028 反向输出一个三位数](https://www.luogu.com.cn/problem/solution/B2028)、[B2078 含 k 个 3 的数](https://www.luogu.com.cn/problem/B2078)等。

### 代码

```cpp
//LLY_0827 B4283 miku~

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

//分离数位
bool check(ll n) {
	while (n) {
		if (n % 10 == 7 || n % 10 == 3) return 0;
		n /= 10;
	}
	return 1;
}

int main() {
	ll n;
	cin >> n;
	ll cnt = 0;
	for (ll i = 1; i <= n; i++) {
		for (ll j = i + 1; j <= n; j++) {
			ll k = n - i - j;
			//判断是否合法
			if (check(i) && check(j) && check(k) && i < j && j < k) {
				cnt++;
			}
		}
	}
	cout << cnt;
}
```

---

## 作者：LINYUHENG2 (赞：1)

## 思路
这一题需要用到枚举思想。

我们可以枚举 $i,j$，设 $k=N-i-j$，若 $i,j,k$ 各个数位都不包含 $3$ 和 $7$，累加计数器。

首先，要保证 $i,j,k$ 都是正整数，所以，$i$ 应该在 $1 \sim n$ 之间，这不用多说。而 $j$ 应该在 $1 \sim i-1$ 之间，否则，$k$ 就会变为负数或 $0$。

那如何判断它们的各个数位都不包含 $3$ 和 $7$ 呢？因为本题的 $N < 501$，$i,j,k$ 都不会超过百位，所以，我们只要判断它们的个位、十位、百位是不是 $3$ 或 $7$ 即可。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
bool is(int n){
    if(n%10==3||n%10==7||n/10%10==3||n/10%10==7||n/100==3||n/100==7) return 0;
    return 1;
}

int main(){
    int n,cnt=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<n-i;j++){
            int k=n-i-j;
            if(is(i)&&is(j)&&is(k)&&i!=j&&i!=k&&j!=k){
                cnt++;
            }
        }
    }
    printf("%d",cnt/6);
    return 0;
}
```

---

## 作者：yyycj (赞：0)

## 主要思路
考虑枚举。枚举分解出的前两个数 $i,j$，为了保证不重复且各个数不相同，$j$ 必须大于 $i$。剩下的一个数 $k$ 就自动等于 $N-i-j$，最后判断 $k$ 是否大于 $j$ 且 $i,j,k$ 都不含 $3,7$，如果满足条件就将答案加 $1$。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
typedef long double db;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
inline ll _abs(ll a) { if (a < 0) return -a; return a; }
inline ll _pow(ll a, ll b) { ll x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }
// ----------------------------

// ----------------------------

// ----------------------------
bool check(int x) {
	while (x) {
		if (x % 10 == 3 || x % 10 == 7) return false;
		x /= 10;
	}
	return true;
}

int main() {
	int n; cin >> n;
	// ----------------------------
	int k, ans = 0;
	for (int i = 1; i < n - 1; i++) {  // j,k 都至少为 1，所以 i 从 1 枚举到 n-2
		if (!check(i)) continue;
		for (int j = i + 1; j < n - i; j++) {  // 同理，j 从 i+1 枚举到 n-i-1
			k = n - i - j;
			if (k > j && check(j) && check(k)) ans++; 
		}
	}
	// ----------------------------
	cout << ans;
	return 0;
}
```

---


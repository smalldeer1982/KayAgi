# [蓝桥杯青少年组省赛 2022] 最大值

## 题目描述

手工课上，老师拿出 $N$ 张长方形彩纸，且每张彩纸上都画着 $W \times H$ 的网格（网格铺满整张彩纸）。现在老师将 $N$ 张彩纸裁剪出 $K$ 张大小相同的正方形，并且要使剪出的正方形的边长最大（裁剪的正方形边长必须为整数）。例如：$N=2$，有 $2$ 张彩纸，第一张彩纸 $W=4$，$H=3$，第二张彩纸 $W=5$，$H=4$，$K=6$，裁剪的 $6$ 个正方形边长最大是 $2$。

当给出 $N$ 张长方形彩纸的 $W$ 和 $H$，及 $K$ 的值，请计算出将 $N$ 张彩纸裁剪出 $K$ 张大小相同的正方形时，正方形的边长最大是多少（裁剪的正方形边长必须为整数）。

## 样例 #1

### 输入

```
2
4 3
5 4
6```

### 输出

```
2```

# 题解

## 作者：ClaudeHsu (赞：9)

## 思路

什么？$1<n<500$，$1<k<500$？

数据真的很小，直接从大到小暴力枚举。

小学数学学过一个长 $x$，宽 $y$ 的长方形可以剪出的边长为 $z$ 的正方形的数量为 $(x\div z)\times(y\div z)$。

千万别拿面积算哦，因为万一不整除要分别向下取整后相乘。

最后枚举最大值就行了。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[505],b[505],c=-2,k,sum;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i]>>b[i];
		c=max(c,min(a[i],b[i]));
	}
	cin>>k;
	for(int i=c;i>=1;i--){
		sum=0;
		for(int j=0;j<n;j++)
		sum+=(a[j]/i)*(b[j]/i);
		if(sum>=k){
			cout<<i;
			return 0;
		}
	}
}
```

---

## 作者：ZYX0716 (赞：4)

## 题意

读完[题](https://www.luogu.com.cn/problem/B4285)后可得知：有 $n$ 张大小为 $w \times h$ 的纸，将这些纸剪成边长为 $len$ 的正方形纸，至少 $k$ 张，且纸可以不用完，但裁剪出的正方形边长必须为整数。请你求出满足条件的最大 $len$ 的值。

## 分析

**典型的二分答案**。模拟正方形的边长，每张彩纸单独累加其可剪成的正方形数量，最后判断剪出的正方形个数是否 $\ge k$。

**注意**：求第 $i$ 张纸可以剪出多少个正方形时，要分别求出行和列除以 $len$ 的商，再相乘。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,w[505],h[505],k,l,r;
bool check(int mid){//判断边长为mid时是否可以剪出k个正方形。
	int sum=0;
	for(int i=1;i<=n;i++){
		sum+=(w[i]/mid)*(h[i]/mid);
		if(sum>=k)return 1;
	}
	return 0;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld %lld",&w[i],&h[i]);
		r=max(r,max(w[i],h[i]));//正方形边长的最大值
	}
	scanf("%lld",&k);
	while(l<=r){//二分答案
		int mid=(l+r)>>1;
		if(check(mid)){
			l=mid+1;
		}else{
			r=mid-1;
		}
	}
	printf("%lld",r);//输出正方形的最大边长
	return 0;
}
```

---

## 作者：yuruilin2026 (赞：4)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540) 和 TA 的 npy [chenyuexiC2026](https://www.luogu.com.cn/user/1499441)。
## 思路：
~~二分答案不行吗，非要枚举。~~\
二分答案，二分边长。\
若当前二分到的边长为 $x$，则对于第 $i$ 张纸片，可以剪出 $\lfloor \frac{w_i}{x} \rfloor \times \lfloor \frac{h_i}{x} \rfloor$ 张。\
遍历每一张纸，判断是否有 $k$ 就行。
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define min(a,b) (a<b?a:b)
int n,w[505],h[505],k,l = 1,r = 114514,mid,ans;
bool check(int x){
	int now = 0;
	for(int i = 1;i <= n;++i) now += ((int)(w[i] / x) * (int)(h[i] / x));
	if(now >= k) return 1;
	return 0;
}
int main(){
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;++i) cin >> w[i] >> h[i];
	cin >> k;
	while(l <= r){
		mid = (l+r)>>1;
		if(check(mid)) l = mid+1,ans = mid;
		else r = mid-1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：4)

### 解题思路

类似题链接：[P8647 分巧克力](https://www.luogu.com.cn/problem/P8647)。

原题链接：[B4285 最大值](https://www.luogu.com.cn/problem/B4285)。

---

容易得知当正方形的边长越大，能切出正方形的数量越少。故具有单调性，可以通过二分进行求解。

对于一个大小为 $W \times H$ 的矩形，能切出大小 为 $x \times x$ 的正方形的数量为 $\lfloor \frac W x \rfloor  \times \lfloor \frac H x \rfloor$。分别表示在 $W$ 方向上能切出几个 $x$ 和 $H$ 方向上能切出几个 $x$。

时间复杂度 $O(n \log \min(W, H))$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int h[N], w[N];

bool check(int x)
{
	long long res = 0;
	for (int i = 1; i <= n; ++ i )
		res += (h[i] / x) * (w[i] / x);
	return res >= m;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; ++ i )
		cin >> h[i] >> w[i];
    cin >> m;
	
	int l = 0, r = N;
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (check(mid)) 
			l = mid;
		else
			r = mid - 1;
	}
	
	cout << l << endl;
	
	return 0;
}
```

---

## 作者：XsIeEiKcEk (赞：2)

## 大意

有 $n$ 张纸，第 $i$ 张纸的大小为 $W_i\times H_i$，要把这些纸剪出 $k$ 个边长为整数的正方形。问这些正方形的边长最大是多少？

## 解法

既然题目标签有枚举，我们就枚举边长，直到最大。

**提示**：`十年 OI 一场空，不开 longlong 见祖宗`。

## CODE
```cpp
#include<iostream>
using namespace std;
#define int long long
signed main(){
    int n,w[500],h[500],k;
    cin>>n;
    for(int i=0;i<n;i++)cin>>w[i]>>h[i];
    cin>>k;
    int i=1,temp;
    while(1){//枚举
        temp=0;//记录能剪出的正方形数
        for(int j=0;j<n;j++)
            temp+=(w[j]/i)*(h[j]/i);
        if(temp>=k)i++;//若>=继续枚举，看有没有更好的方案
        else{//否则答案为上一个
            cout<<i-1;
            break;
        }
    }
    return 0;
}
```

~~其实可以二分，但作者太懒了~~

---

## 作者：wenqinghua1001 (赞：1)

# 一道简单的题

## 思路

这道题是一道经典的二分题，在最小值里面找最大值。定义 $L$ 为左端点，$R$ 为右端点，那么 $mid$ 为中间值 $(l+r) \div 2$，如果 $mid$ 为答案小了，$l$ 增加到 $mid$；如果 $mid$ 为答案大了，$r$ 减小到 $mid$。

如果 $mid$ 为答案，要剪成的正方形数为 $M$，第 $i$ 张纸的长为 $a_i$，宽为 $b_i$，那么裁剪的正方形数 $S$ 为 $(a_i \div mid) \times (b_i \div mid)$。如果 $S \le M$，$L=mid$，否则 $r=mid$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001];
int b[10001];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	int m;
	cin>>m;
	// 输入。
	int l=1,r=500*500;
	// 左边界和右边界。 
	while(l+1<r){
		int mid=(l+r)/2;
		// 中间值。
		int ans=0; 
		for(int k=1;k<=n;k++){
			int w=a[k]/mid;
			int h=b[k]/mid;
			ans+=w*h; 
			// 第 k 张彩纸裁剪的边长为 mid 的正方形数。 
		}
		if(ans>=m){
			// 答案大了（或者相等）。 
			l=mid;
			// 不能是 mid+1，因为 mid 可能是答案。 
			// l 是最终答案。 
		}
		else{
			// 答案小了（不相等）。 
			r=mid;
		}
	} 
	// 二分查找。
	cout<<l;
	// 输出。 
	return 0;
	// 好习惯+1。 
}
```

---

## 作者：zhz_cptbtptp (赞：0)

看到这道题，我一下子就想到了二分，二分正方形的边长，最后输出二分出来的结果就可以了。

思路就这么简单，但需要注意的是，与传统二分不一样，我们在二分正方形边长时，要将每一个卡片可以裁出来的正方形累加起来与需要的正方形数量作比较，如果大于，移动左区间，如果小于，移动右区间。

话不多说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=505;
int n,w[maxn],h[maxn],k;
long long maxx;

int check(int mid){//二分模板
	int sum=0;
	for(int i=1;i<=n;++i){
		sum+=(w[i]/mid)*(h[i]/mid);//求每一个卡片可以裁出来几个正方形
	}
	if(sum>=k){
		return 1;
	}else{
		return 0;
	}
}

int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>w[i]>>h[i];
		maxx+=w[i]*h[i];
	}
	cin>>k;
	int l=0,r=maxx/k;
	while(l<=r){//实数二分
		int mid=(l+r)/2;
		if(check(mid)){
			l=mid+1;
		}else{
			r=mid-1;
		}
	}
	cout<<r;//输出二分结果
	return 0;
}
```

华丽的结束。

---

## 作者：Jayfeather2012 (赞：0)

## 题目大意
有许多彩纸，给出这些彩纸的长和宽，要求用这些彩纸减最少 $k$ 个正方形，求满足条件的最大正方形边长。
## 思路
从大到小枚举正方形边长，每次枚举计算该边长最多能剪出多少个正方形，即枚举每张彩纸，累加每张彩纸能剪出的正方形数 $\lfloor W_j\div i \rfloor \times \lfloor H_j\div i \rfloor$，即长能摆的正方形数乘宽能摆的正方形数，而如果直接用彩纸面积除以正方形面积是错误的，因为剪下正方形后可能会有剩余且不能摆出正方形的部分。若能剪出的正方形总数 $s\ge k$，就输出这个边长。  
具体细节看代码吧！
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,s,x[505],y[505];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>x[i]>>y[i];
        s+=x[i]*y[i];
    }
    cin>>k;
    s/=k;
    s=sqrt(s);
    //s为正方形边长上限
    //因为按照面积除肯定比按照边长除多（前面有讲），所以比是s大的正方形边长一定不可能满足要求
    //所以从s开始枚举
    for(int i=s;i>=1;--i){
        int ans=0;
        for(int j=1;j<=n;++j)ans+=(x[j]/i)*(y[j]/i);
        //累加个数
        if(ans>=k){
            cout<<i<<"\n";
            //满足要求就输出
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：LotleTos (赞：0)

数据比较小，可以直接从大到小枚举答案。

一个长 $a$，宽 $b$ 的长方形可以剪出的边长为 $c$ 的正方形的数量为 $(a\div c)\times(b\div c)$。

而答案的最大值就是这些长方形中 $\min(W,H)$ 的最大值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[510];
int b[510];
int main(){
	int n;
	cin>>n;
	int c=-1;
	for(int i=0;i<n;i++){
		cin>>a[i];
		cin>>b[i];
		c=max(c,min(a[i],b[i]));
	}
	int k;
	cin>>k;
	for(int i=c;i>=1;i--){
		int sum=0;
		for(int j=0;j<n;j++){
			sum+=(a[j]/i)*(b[j]/i);
		}
		if(sum>=k){
			cout<<i;
			return 0;
		}
	}
}
```

---

## 作者：Mountains_OIer (赞：0)

# 思路
直接暴力枚举，由于答案要求最大，所以从大到小枚举即可。

此处注意如何计算一张彩纸可以裁出多少张正方形，不是大面积除以小面积而是长除以小边长乘宽除以小边长（小学数学题）。
# CODE
```cpp
#include<iostream>
using namespace std;
int n,k,mxh=-1e9,mxw=-1e9,mx,tot;
signed main(){
	cin>>n;
	int w[n+1],h[n+1];
	for(int i=1;i<=n;i++){
		cin>>w[i]>>h[i];
		mxw=max(mxw,w[i]);
		mxh=max(mxh,w[i]);
	}
	cin>>k;
	mx=max(mxh,mxw);
	while(mx--){
		for(int i=1;i<=n;i++)tot+=(w[i]/mx)*(h[i]/mx);
		if(tot>=k){
			cout<<mx;
			return 0;
		}
		tot=0;
	}
}
```

---


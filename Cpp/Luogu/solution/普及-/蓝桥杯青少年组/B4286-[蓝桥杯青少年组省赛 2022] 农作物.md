# [蓝桥杯青少年组省赛 2022] 农作物

## 题目描述

有一块农田被划分为 $N \times M$ 块，农作物和杂草分布生长在农田中，其中农作物使用大写字母 `R` 表示，杂草使用大写字母 `X` 表示。请计算出农田中有几块独立的农作物区域（独立的农作物区域指该区域上下左右都被杂草围住，且 $N \times M$ 以外的区域都是杂草）。例如，样例是 $N=4$，$M=4$ 的农田，这块 $4 \times 4$ 的农田中有 $3$ 块独立的农作物区域。

## 样例 #1

### 输入

```
4 4
RRRX
RXRX
XXXR
RXXX```

### 输出

```
3```

# 题解

## 作者：Little_rock (赞：5)

这题典型的洪水填充。
~~（双倍经验在最后）~~

洪水填充主要思想：
1. 对于每一个农作物，将这个农作物标记为杂草，防止死循环。
2. 判断这个农作物上下左右是否为农作物，若是，则重复 1 操作。

即：
```cpp
int dir[4][2]={0,1,1,0,-1,0,0,-1};//方向
void flood_fill(int x,int y)
{
    c[x][y]='X'; //1操作：标记为杂草
    for(int i=0;i<4;i++) //2操作：遍历其上下左右
    {
        int nx=dir[i][0]+x; 
        int ny=dir[i][1]+y;
        if(nx>0&&nx<=n&&ny>0&&ny<=m&&c[nx][ny]=='R')
            flood_fill(nx,ny); //若为农作物，则重复1操作。
    }
    return ;
}
```

我们可以遍历整个田地，若它为农作物，将其进行 1 操作。

即：
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        if(c[i][j]=='R')
        {
             flood_fill(i,j);
             ans++;
        }
    }    
}
```

## 代码

```cpp
#include <iostream>
using namespace std;

char c[510][510];
int dir[4][2]={0,1,1,0,-1,0,0,-1};
int n,m,ans;

void flood_fill(int x,int y)
{
    c[x][y]='X';
    for(int i=0;i<4;i++)
    {
        int nx=dir[i][0]+x;
        int ny=dir[i][1]+y;
        if(nx>0&&nx<=n&&ny>0&&ny<=m&&c[nx][ny]=='R')
            flood_fill(nx,ny);
    }
    return ;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>c[i][j];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(c[i][j]=='R')
            {
                flood_fill(i,j);
                ans++;
            }
        }    
    }
    cout<<ans;           
    return 0;
}
```

双倍经验：[P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

我们可以遍历整个地图，当发现农作物 `R` 时，表示我们发现了一块农作物，答案加一，随后将这块农作物及其联通的农作物全部改为杂草 `X`，防止重复计算。

时间复杂度 $O(nm)$。

### AC_Code

```cpp
#include <iostream>

using namespace std;

const int N = 5e2 + 10;

int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

int n, m;
char g[N][N];

void dfs(int x, int y)
{
    g[x][y] = 'X';
    for (int i = 0; i < 4; ++ i )
    {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx < 0 || ty < 0 || tx >= n || ty >= m || g[tx][ty] == 'X')
            continue;
        dfs(tx, ty);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; ++ i )
        cin >> g[i];

    int res = 0;
    for (int i = 0; i < n; ++ i )
        for (int j = 0; j < m; ++ j )
            if (g[i][j] == 'R')
            {
                res ++;
                dfs(i, j);
            }

    cout << res << endl;
    
    return 0;
}
```

---

## 作者：yuruilin2026 (赞：3)

## 一些闲话：
由于 [Eden_star](https://www.luogu.com.cn/user/1269111) 调了半天并查集没调出来，让我帮忙。\
然后我就用并查集 AC 并且写了一篇题解~~嘲讽 TA~~。
## 思路：
明显求联通块，维护集合联通关系。\
那就可以用并查集啊。\
但是并查集的返回值是一维的，这是一个二维方阵。\
那就给每一个田块编号，把矩阵压成一维。\
接下来遍历矩阵，如果某一个点和它相邻的四个点都是田块，就可以将两个地块合并。\
最后求出有几个地块就行了。
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int bingchaji[250005],n,m,num[514][514],now,fx[4] = {0,1,0,-1},fy[4] = {1,0,-1,0},ans;
char a[514][514];
int find(int x){//并查集模板 
	if(bingchaji[x] != x) bingchaji[x] = find(bingchaji[x]);
	return bingchaji[x];
}
int main(){
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= m;++j){
			cin >> a[i][j];
			num[i][j] = ++now;//num[i][j] 是 i,j 的一维编号 
			bingchaji[num[i][j]] = num[i][j];//顺便初始化 
		}
	}
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= m;++j){
			if(a[i][j] == 'X') continue;//只处理田块 
			for(int k = 0;k <= 3;++k){
				int xx = i + fx[k];
				int yy = j + fy[k];
				if(xx <= 0 || yy <= 0 || xx > n || yy > m) continue;
				if(a[xx][yy] == 'X') continue;//只处理田块 
				if(find(num[i][j]) == find(num[xx][yy])) continue;
				bingchaji[find(num[i][j])] = find(num[xx][yy]);
			}
		}
	}
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= m;++j){
			if(a[i][j] == 'R' && find(num[i][j]) == num[i][j]) ans++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：wenqinghua1001 (赞：2)

# 一道简单的题

这道题目一看就知道是 DFS 题，求连通块的个数。

首先找出是农作物的格子，再 DFS 求出整块农作物的面积，全部标记为杂草，最后看找出了多少农作物的格子（找到是农作物的格子，整个联通块的格子全部标记为杂草）。

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[505][505];
int n,m,ans=0;
// 定义。 
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
// 四个方向数组。 
void dfs(int x,int y){
	a[x][y]='X';
	// 标记为杂草。
	for(int d=0;d<4;d++){
		// 四个方向。
		int nx=x+dx[d];
		int ny=y+dy[d];
		// 新的坐标。
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[nx][ny]=='R'){
			// 在边界内且当前格子是农作物。
			dfs(nx,ny);
			// 继续遍历 
		} 
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		string x;
		cin>>x;
		for(int j=1;j<=m;j++)
			a[i][j]=x[j-1];
	} 
	// 输入。
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='R'){
				// 找到了是农作物的格子。
				dfs(i,j);
				ans++;
				// 寻找连通块。 
			}
		}
	}
	cout<<ans;
	// 连通块的数量。 
	return 0;
}
```

---

## 作者：niuniudundun (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4286)

## Problem

求出在 $N\times M$ 网格的连通块。

## Solution

虽然 BFS 求连通块很好，但是选择码量更少的 DFS。

将地图存储在 `char` 型二维数组 $s$。遍历每个 $s$，如果 $s_{x,y}=\texttt{R}$，则令计数器加一，并使用 DFS 遍历。这个 DFS 函数定义：如果 $s_{x,y}\ne\texttt{R}$ 就跳出循环，否则将 $s_{i,j}$ 等于 $\texttt{X}$，遍历 $(x+1,y),(x-1,y),(x,y-1),(x,y+1)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=501;
int n,m,ans=0;
char s[maxn][maxn];
bool vis[maxn][maxn];
void dfs(int x,int y){
	if(s[x][y]!='R'){
		return;
	}
	s[x][y]='X';
	dfs(x+1,y);
	dfs(x-1,y);
	dfs(x,y-1);
	dfs(x,y+1);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i][j]=='R'){
				ans++;
				dfs(i,j);
			}
		}
	}
	cout<<ans<<endl;
	return 0;
} 
/*
4 4
RRRX
RXRX
XXXR
RXXX
*/
```

---

## 作者：AFO_Lzx (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4286)

### $\texttt{Description}$

求一个 $n\times m$ 矩阵中的连通块数量。

### $\texttt{Solution}$

我们可以使用 DFS 来求解，每次遇到一个没有被标记过的 $\texttt{R}$ 都将答案 $+1$，然后用 DFS 将从当前点出发可以到达的所有的是 $\texttt{R}$ 的点全部标记就可以了。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 5e2 + 5;
char a[maxn][maxn];
bool v[maxn][maxn];
const int fx[] = {0, 0, 1, 0, -1};
const int fy[] = {0, 1, 0, -1, 0};

void dfs(int x, int y) {
	v[x][y] = 1;
	for (int i = 1; i <= 4; i++) {
		int tx = x + fx[i];
		int ty = y + fy[i];
		if (tx <= 0 || tx > n || ty <= 0 || ty > m) continue;
		if (a[tx][ty] == 'X' || v[tx][ty] == 1) continue;
		dfs(tx, ty);
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (a[i][j] == 'R' && v[i][j] == 0) {
				ans++;
				dfs(i, j);
			}
		}
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 解题思路：
这道题，我们可以选用深搜 dfs 的做法。

- 首先，我们要写出输入部分，用 char 类型来存字母。代码如下：
```cpp
cin >> n >> m;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) cin >> c[i][j];
}
```
- 接下来，写深搜 dfs 的部分，先判断该字母如果不是 R，那就直接 return，跳出递归。如果是 R，就将这个字母改成 X。接着递归这个字母的上下左右即可。代码如下：
```cpp
void dfs(int x, int y) {
	if (c[x][y] != 'R') return;
	c[x][y] = 'X';
	dfs(x + 1, y);
	dfs(x - 1, y);
	dfs(x, y - 1);
	dfs(x, y + 1);
}
```
- 最后一步，回到主程序，判断该字母是不是 R，如果是，计数器加一，并且递归遍历。最后输出计数器就可以了。代码如下：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (c[i][j] == 'R') {
          ans++;
          dfs(i, j);
      }
    }
}
cout << ans;
```

最后将三部分拼接，我们便得到了最终的完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 501;
int n, m, ans;
char c[MAXN][MAXN];

void dfs(int x, int y) {
	if (c[x][y] != 'R') return;
	c[x][y] = 'X';
	dfs(x + 1, y);
	dfs(x - 1, y);
	dfs(x, y - 1);
	dfs(x, y + 1);
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) cin >> c[i][j];
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (c[i][j] == 'R') {
				ans++;
				dfs(i, j);
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Starry_Sky_135 (赞：1)

#   思路

这题我用的是深搜。

输入进来之后把每个点遍历一下，如果是农作物且没有访问过，就进入深搜找连通块，并将连通的点全部标记为访问过，防止下次遍历到这个点进入深搜。最后结束深搜，将 $ans$ 加一。

#   [AC](https://www.luogu.com.cn/record/211591036) 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e2+8;
int n,m;
bool flag[MAXN][MAXN];
char c[MAXN][MAXN];
int ans;
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
void dfs(int x,int y)
{
	flag[x][y]=1;
	for(int i=0;i<8;i++)
	{
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&
		!flag[nx][ny]&&c[nx][ny]=='R')
		{
			dfs(nx,ny);
		}
	}
	return;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(c[i][j]=='R'&&!flag[i][j])
			{
				ans++;
				dfs(i,j);
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

本题考察联通块的统计，考虑 DFS（深度优先搜索）。\
定义一个二维字符矩阵 $A$，从 $A_{0,0}$ 开始遍历整个矩阵，当找到一个字符 `R`，即一个农作物单元格，启动深搜，递归搜索上下左右四个单元格，将所有相邻的 `R` 变为 `X`，找到原本为 `X` 的格子时，该层递归终止，待所有递归结束，将统计联通块的变量 $\text{total}$ 加 $1$，当所有单元格遍历完成，程序结束。

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[550][550];
int fx[4] = {0, 0, -1, 1};
int fy[4] = {1, -1, 0, 0};
int total = 0;
void dfs(int x, int y){
    a[x][y] = 'X'; //标记为杂草
    int tx, ty;
    for(int i = 0; i < 4; i++){ //进行上下左右递归深入
        tx = x - fx[i];
        ty = y - fy[i];
        if(ty >= 0 && tx >= 0 && a[tx][ty] == 'R') dfs(tx,ty); //需要判断是否为农作物后再深入
    }
}
int main(){
    int n, m;
    cin >> n >> m;
    for(int i = 0; i < n; i++)
    	for(int j = 0; j < m; j++)
			cin >> a[i][j];
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(a[i][j] == 'R'){ //找到一个农作物单元格
                dfs(i, j); //递归
                total++; //计数器自增
            }
        }
    }
    cout << total;
    return 0;
}
```

---

## 作者：LotleTos (赞：0)

深搜，先枚举地图的每个点，如果是农作物就 `sum++`，接着从这个点开始深搜，把连通块的的点在地图上修改掉（不表示农作物就行）。

最后输出 $sum$ 即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[510][510];
int n,m,b[4][2]={{0,1},{1,0},{0,-1},{-1,0}},sum;
void f(int x,int y){
	a[x][y]=0;
	for(int i=0;i<4;i++){
		if(x+b[i][0]<n&&y+b[i][1]<m&&x+b[i][0]>-1&&y+b[i][1]>-1&&a[x+b[i][0]][y+b[i][1]]){
			f(x+b[i][0],y+b[i][1]);
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			char c;
			cin>>c;
			if(c=='X'){
				a[i][j]=0;
			}
			else{
				a[i][j]=1;
			}
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<m```;j++){
			if(a[i][j]){
				f(i,j);
				sum++;
			}
		}
	}
	cout<<sum;
}
```

---

## 作者：TJB_LHY (赞：0)

# 思路

一道广搜的~~模板~~题，题目大意就是给定一张图，要求计算连通块数量。只要不断在主函数中找剩余的连通块即可。时间复杂度是 $O(n^2)$ 的。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
#define mp(i,j) make_pair(i,j)
using namespace std;
int n,m,cnt;//行数、列数和连通块数量
char maze[505][505];//存图
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
bool inn(int x,int y){
    return x>=0 && y>=0 && x<n && y<m;
}//合法判断
void bfs(int sx,int sy){
    queue<pair<int,int>>Q;
    Q.push(mp(sx,sy));
    int x,y,nx,ny;
    maze[sx][sy]='X';//标记已经遍历过了
    while(Q.size()){
        x=Q.front().first;
        y=Q.front().second;
        Q.pop();//弹出对头
        for(int i=0;i<4;i++){
            nx=x+dx[i];
            ny=y+dy[i];
            if(inn(nx,ny)){
                if(maze[nx][ny]=='R'){
                    Q.push(mp(nx,ny));
                    maze[nx][ny]='X';//标记
                }
            }
        }
    }
}//广搜
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    for(int i=0;i<n;i++)for(int j=0;j<m;j++)cin>>maze[i][j];//输入
    for(int i=0;i<n;i++)for(int j=0;j<m;j++){
        if(maze[i][j]=='R'){
            bfs(i,j);
            cnt++;//记录
        }
    }
    cout<<cnt;//输出
	return 0;
}
```

---


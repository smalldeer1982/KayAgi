# [蓝桥杯青少年组国赛 2022] 报数游戏

## 题目描述

某班级男生人数为 $X$ 人，女生人数为 $Y$ 人，现全班同学围成一个圆圈，并按照顺时针方向为每名同学编号（从 $1$ 到 $X+Y$）。现给出一个正整数 $K$（$2<K<(X+Y)$），从编号为 $1$ 的同学开始顺时针方向报数，报到 $K$ 的同学退出圆圈，下一名同学继续从 $1$ 报数，再次报到 $K$ 的同学退出圆圈。如此循环，直到剩余人数为 $X$ 时游戏结束。

请你计算出游戏开始时 $X$ 名男生分别应该排在什么位置，才能保证每次离开的都是女生，游戏结束时剩余 $X$ 人都是男生。并将游戏开始时每名男生的位置编号按照从小到大顺序输出。

例如：$X=5$，$Y=3$，$K=3$，$8$ 名同学按照如下图的顺序排列（蓝色为男生位置，红色为女生位置），可以使 $3$ 轮报数过后最后剩余的 $5$ 名同学都为男生。故 $5$ 名男同学的编号分别为 $2$、$4$、$5$、$7$、$8$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lhokokoq.png)

## 样例 #1

### 输入

```
5 3 3```

### 输出

```
2 4 5 7 8```

# 题解

## 作者：Temp113 (赞：6)

## Solution

模拟 $Y$ 轮中，每轮报 $K$ 个数的情况，进行标记。

为了方便，将编号设为 $0 \sim X + Y - 1$，初始编号设为 $-1$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int X = 105;
int x, y, k, tp = -1;
bool flg[2 * X];
inline int get(int aa){
	return aa % (x + y);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie();
	cin >> x >> y >> k;
	for(int p = 1; p <= y; p++){
		for(int q = 1; q <= k; q++){
			tp++;
			while(flg[get(tp)]) tp++;
		}
		flg[get(tp)] = 1;
	}
	for(int i = 0; i < x + y; i++) if(!flg[i]) cout << i + 1 << ' ';
	return 0;
}
```

---

## 作者：scc36 (赞：2)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4295)
### 思路
约瑟夫经典题。   
模拟出前 $y$ 个离开的人的位置，剩下的就是男生的位置。   
因为数据范围较小，我们可以对每个女生都进行 $k$ 次枚举，每次向前推进一位，如果这个位置早就离队了，就跳过它，去下一位。重复这样的操作，直到找到一个还未离队的位置。  
执行 $k$ 次后的位置就是这个人的位置。  
为方便取模，编号从 $0$ 开始。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y,k,i,j,s,l,f[100001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>x>>y>>k;
	s=-1;l=x+y;
	for(i=1;i<=y;i++){
		for(j=1;j<=k;j++){
			s=(s+1)%l;
			while(f[s]==1) s=(s+1)%l;			
		}
		f[s]=1;		
	}
	for(i=0;i<=l-1;i++)
		if(!f[i]) cout<<i+1<<" ";
}
```

---

## 作者：x_Toi_QiQi (赞：2)

## 问题复数：
我们有 $X$ 名男生和 $Y$ 名女生围成一圈，编号从 $1$ 到 $X+Y$。从 $1$ 号开始顺时针报数，数到 $K$ 的人出局，游戏持续进行直到剩下 $X$ 人且全是男生。需要找出初始时男生应该站的位置。
## 初步分析
这是一个典型的约瑟夫问题变种。在标准约瑟夫问题中，我们关注的是最后剩下的人的位置。而这里我们需要确保：
1. 每次淘汰的都是女生。
2. 最后剩下 $X$ 个男生。
### 直接思路
最直观的方法是尝试所有可能的男生位置组合，然后模拟淘汰过程验证是否满足条件。但这样的组合数为 $C(X+Y,X)$，当 $X$ 和 $Y$ 较大时（如 $100$），这显然不可行。
## 关键观察
1. **逆向思考**：如果我们知道最后剩下的 $X$ 个位置，那么这些位置就是男生应该站的位置。
2. **淘汰过程**：淘汰 $Y$ 个女生后剩下的就是男生位置。
3. **简化问题**：不需要关心具体谁是男生女生，只需计算淘汰 $Y$ 人后剩下的位置。
## 推导过程
### 标准约瑟夫问题解法
标准约瑟夫问题的递推公式：

- $J(n,k) = (J(n-1,k) + k) \mod n$

其中 $J(1,k) = 0$。

但我们需要的是淘汰 $Y$ 人后剩下的所有位置，而不仅仅是最后一个。
### 问题转化
1. 模拟整个淘汰过程。
2. 记录被淘汰的位置。
3. 剩下的 $X$ 个位置就是男生位置
### 优化思路
直接模拟的时间复杂度是 $O(Y\times(X+Y))$，当 $X$ 和 $Y$ 为 $100$ 时，这完全可以接受。
## code
### 优化前

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solve(int x, int y, int k) {
    int n = x + y;
    vector<int> v(n);
    for(int i=0; i<n; i++) v[i] = i+1;
    
    int p = 0;
    for(int i=0; i<y; i++) {
        p = (p + k - 1) % v.size();
        v.erase(v.begin() + p);
    }
    
    sort(v.begin(), v.end());
    return v;
}

int main() {
    int x, y, k;
    cin >> x >> y >> k;
    
    vector<int> res = solve(x, y, k);
    
    for(int i=0; i<res.size(); i++) {
        if(i) cout << " ";
        cout << res[i];
    }
    cout << endl;
    
    return 0;
}
```


### 优化后
```cpp
#include <iostream>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solve_opt(int x, int y, int k) {
    int n = x + y;
    list<int> l;
    for(int i=1; i<=n; i++) l.push_back(i);
    
    auto it = l.begin();
    for(int i=0; i<y; i++) {
        for(int j=1; j<k; j++) {
            it++;
            if(it == l.end()) it = l.begin();
        }
        
        it = l.erase(it);
        if(it == l.end()) it = l.begin();
    }
    
    vector<int> res(l.begin(), l.end());
    sort(res.begin(), res.end());
    return res;
}

int main() {
    int x, y, k;
    cin >> x >> y >> k;
    
    vector<int> res = solve_opt(x, y, k);
    
    for(int i=0; i<res.size(); i++) {
        if(i) cout << " ";
        cout << res[i];
    }
    cout << endl;
    
    return 0;
}
```
## 对比优化前和优化后的时间复杂度以及空间复杂度
### 优化前
- 时间复杂度：$O(y\times(x+y))$。
- 空间复杂度：$O(x+y)$。
### 优化后
- 时间复杂度：$O(y\times k)$。
- 空间复杂度：$O(x+y)$。
## 样例解析
1. 淘汰3$\to$ 剩余1 2 4 5 6 7 8。
2. 淘汰6$\to$ 剩余1 2 4 5 7 8。
3. 淘汰1$\to$ 剩余2 4 5 7 8。
输出：2 4 5 7 8。
---
最后点个赞吧！

---

## 作者：Aurora_春雪 (赞：1)

~~本女孩纸表示出题人你怎么可以这样~~。

## 思路
怎么不算[双倍](https://www.luogu.com.cn/problem/P1996)经验呢。

一眼约瑟夫~~考取模运算符的~~。

根据题意，女生必须全部出圈，留下的必须都是男生。换句话说，出圈的必须都是女生。

因此我们只需要找到所有的**出圈位置**，就可以得到答案了。

具体来讲，当剩余人数大于 $x$，即男生人数时，就要继续删除。怎么找删除元素呢？题面给出，报到 $k$ 的人出圈，换句话说：每隔 $k - 1$ 人就要出圈一人。将循环变量 $i = 0$，每次循环，就将 $i \to i - (k - 1)$。但是你会发现，连样例都没有过，为什么呢？因为 $i$ 的范围超过 $x + y$ 了呀！因此，要记得将对 $i$ 取模。

最后，要记得从小到大排序输出男生的位置。

## 实现代码


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v;
int x,y,k;
int main(){
	cin>>x>>y>>k;
    int i=0;
	for(i=1;i<=x+y;i++) v.push_back(i);
	i=0;//从零开始
	while(v.size()>x){//还有女生
		i=(i+k-1)%v.size();//找到下一个要删除的位置
		v.erase(v.begin()+i);//出圈
	}
	sort(v.begin(),v.end());//排序
	for(i=0;i<v.size();i++) cout<<v[i]<<" ";
	return 0;//完结撒花~~~
}
```

万事俱备，只欠 [AC](https://www.luogu.com.cn/record/213515987)。

---

## 作者：Yi_chen123 (赞：1)

题外话：~~我告出题人重男轻女~~！

## 思路

可以说是约瑟夫环的板子题了，依照题意模拟即可。\
要想出局的人全为女生，就需要把她们安排在前 $Y$ 次报数后出局的 $Y$ 个位置。其余的地方都为男生，可以使用一个 `bool` 类型的数组，判断这个位置是否会在前 $Y$ 轮出局，问题轻松解决。

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;

bool out[1145]; //out[i] 代表第 i 个人是否出局，true = 是，false = 否
int main(){
	int x, y, k;
	cin >> x >> y >> k;

    //cur: 当前同学报的数，now:当前同学的编号，cnt:一共报了多少次 k
	int cur = 0, now = 1, cnt = 0;
	for(; cnt < y; ){ //报 y 次 k 后跳出循环
        if(now > x + y) now = 1;
	    if(!out[now]) ++cur; //不出局的人才能报数
        if(cur == k){ //报到 k 出局
        	out[now] = true;
        	cur = 0;
        	++cnt;
		}
		++now;
	}
	for(int i = 1; i <= x + y; ++i){
        if(!out[i]) cout << i << ' '; //输出前 y 轮没有出局的位置编号
	}
    return 0;
}
```

---

## 作者：yuruilin2026 (赞：1)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)。\
[双倍经验](https://www.luogu.com.cn/problem/P1996)。
## 思路：
超级大模拟，模拟出依次出圈的人，然后输出没有出圈的人。\
用两个变量 $b,t$ 分别表示现在报数的人和现在的编号。\
每次报数时枚举到下一个没有出圈的人，如果 $b = x+y+1$，那么就将 $b$ 设为 $1$。\
每次枚举 $t$ 都增加 $1$，如果 $t = k$，标记出圈。 
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y,m,a[205] = {},q,t = 0,b = 0,n;
int main(){
    cin >> x >> y >> m;
    q = x+y,n = x+y;
    while(q >= x+1){
        b += 1,t += 1;
        if(b > n) b = 1;
        while(a[b] == -1){
            b += 1;
            if(b > n) b = 1;
        }
        if(t == m){
            t = 0;
            a[b] = -1;
            q -= 1;
        }
    }
    for(int i = 1;i <= n;++i) if(a[i] != -1) cout << i << " ";
    return 0;
}
```

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4295)

## Problem

有男生 $x$ 人，女生 $y$ 人排成了一条**环**，报数每报到 $k$ 的人出列。如果要让最后全是男生，男生站在哪里。

## Solution

一眼看出这是个约瑟夫变种题。

如果让男生全在列，那么出列的是女生。模拟约瑟夫环，只要剩余人大于 $x$ 人，则继续弹出。剩下的就是不会弹出的位置，这就是答案。

具体的：建立变量 $x,y,k$ 和 `vector<int>` 类型 $v$。输入 $x,y,k$，并将 $x+y$ 个数加入到 $v$ 中。让循环变量 $i=0$，如果 $\operatorname{size}(v)$（代码的 `v.size()`）大于 $x$，则让 $i=(i+k-1)\bmod \operatorname{size}(v)$ 并删除 $v$ 中的第 $i$ 个元素。最后排序输出。

不知道为什么 `queue` 只能得 $10$ 分。

## Code

如果将 $v$ 的 $\operatorname{size}(),\operatorname{push\_back}(),\operatorname{erase}()$ 几个函数当成 $O(1)$，那么复杂度为 $O(x+y+y+x\log x+x)=O(2y+2x+x\log x)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> v;
int x,y,k,i=1;
int main(){
	cin>>x>>y>>k;
	for(i=1;i<=x+y;i++){
		v.push_back(i);
	}
	i=0;
	while(v.size()>x){
		i=(i+k-1)%v.size();
		v.erase(v.begin()+i);
	}
	sort(v.begin(),v.end());
	for(i=0;i<v.size();i++){
		cout<<v[i]<<" ";
	}
	return 0;
}
```

---

## 作者：TJB_LHY (赞：1)

# 思路

一道[约瑟夫问题](https://baijiahao.baidu.com/s?id=1773174532776163637\&wfr=spider\&for=pc)的~~模板~~题。~~由于作者不会数学方法，所以~~本题用的是数组模拟链表的解法，本身数据也不大，完全够用。只需要将报数淘汰模拟 $Y$ 次即可，此处不过多赘述。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
int x,y,k,l[205],i,j,o,n;
bool vis[205];//标记
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>x>>y>>k;//输入
    n=x+y;
    for(i=1;i<n;i++)l[i]=i+1;//数组模拟链表
    l[n]=1;//闭环
    j=n;
    while(y--){
        i=k；
        while(i--)o=j,j=l[j];//报数
        l[o]=l[j];//淘汰
        vis[j]=1;
    }//模拟
    j=1;
    while(vis[j])j=l[j];//先找最小的序号
    while(x--){
        cout<<j<<' ';
        j=l[j];//遍历最后的环即可
    }
	return 0;
}
```

完结撒花～

---


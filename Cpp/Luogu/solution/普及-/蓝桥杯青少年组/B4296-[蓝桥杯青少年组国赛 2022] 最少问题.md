# [蓝桥杯青少年组国赛 2022] 最少问题

## 题目描述

河面上有 $N$ 个木桩排成一排，每个木桩上都有一个数字，表示青蛙从当前木桩一次最多可跳跃的木桩个数（例如数字为 $2$，可以跳跃 $1$ 个或 $2$ 个木桩）。请计算青蛙从第 $1$ 个木桩跳跃到第 $N$ 个木桩所需的最少跳跃次数。

例如：$N=5$，木桩数字分别为 $2$、$1$、$5$、$1$、$3$ 时：
1. 第一次从第 $1$ 个木桩跳到第 $3$ 个木桩（跳跃 $2$ 个木桩）；
2. 第二次从第 $3$ 个木桩跳到第 $5$ 个木桩（跳跃 $2$ 个木桩）；

最少需要 $2$ 次跳跃。

## 样例 #1

### 输入

```
5
2 1 5 1 3```

### 输出

```
2```

# 题解

## 作者：zhz_cptbtptp (赞：5)

这道题我看很多巨佬都用的**动态规划**，那本蒟蒻就写一个通俗易懂的**宽度优先搜索**。

### 思路

暴力枚举每一个点可以到达的点，同时储存移动的步数，输出最少步数。

话不多说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105;
struct point{//存当前点的坐标和已经移动的步数
	int wz,cnt;
};

int n,a[maxn],vis[maxn];//记得判重，不然会MLE

void bfs(){//bfs模板
	queue<point>q;
	for(int i=a[1];i>=1;--i){
		vis[1]=1;
		if(i+1<n){
			q.push(point{i+1,1});
		}else if(i+1==n){
			cout<<"1";
			exit(0);
		}
	}
	while(!q.empty()){
		int wz=q.front().wz,cnt=q.front().cnt;
		q.pop();
		for(int i=a[wz];i>=1;--i){
			if(i+wz<n&&!vis[i+wz]){
				vis[i+wz]=1;
				q.push(point{wz+i,cnt+1});
			}else if(i+wz==n){
				cout<<cnt+1;
				exit(0);
			}
		}
	}
}

int main() {
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	bfs();
	return 0;
}
```
华丽的结束。

---

## 作者：yuruilin2026 (赞：5)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)。\
一道很好的贪心题，同时也是一道很好的搜索题。\
可惜我用 DP。
## 思路：
令 $dp_i$ 表示走到第 $i$ 个木桩的最小跳跃次数。\
令 $a_i$ 表示第 $i$ 个木桩能跳的距离。\
对于每一个 $i(i \ge 2)$，枚举一个小于 $i$ 的 $j$，若 $j+a_j \ge i$，则 $dp_i$ 就可以从 $dp_j$ 转移。
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define min(a,b) (a<b?a:b)
int n,a[1005],dp[1005];
signed main(){
    cin.tie(0),cout.tie(0);
    cin >> n;
    for(int i = 1;i <= n;++i) cin >> a[i];
    for(int i = 2;i <= n;++i){
    	dp[i] = INT_MAX;
		for(int j = 1;j < i;++j){
			if(j + a[j] >= i) dp[i] = min(dp[i],dp[j] + 1);
		}
	}
	cout << dp[n];
    return 0;
}
```

---

## 作者：weapons (赞：3)

#### 思路
 因为跳到某木桩，对其步数产生影响的是走到前面木桩的步数，于是考虑动态规划：
 
 用一数组记录到达某木桩的最小步数。从前往后遍历木桩，再枚举当前位置之前的木桩，如果可靠到达，那么更新到达当前木桩步数的最小值。详见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,  num[105], dp[105];//dp[i]表示走到i的最小步数
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &num[i]);//输入
	}
	memset(dp, 0x3f, sizeof(dp));
	dp[1]=0;//初始化
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(j+num[j]>=i){
				dp[i]=min(dp[i],dp[j]+1);//如果前面的点能走到，那么更新
			}
		}
	}
	cout << dp[n];

}
```

---

## 作者：ShiYuXuan1234 (赞：3)

## 思路
这道题，很明显是一道线性 DP 题。

我们可以初始将 $dp$ 设置成一个很大的数，注意 $dp_1$ 必须为 $0$，然后通过两个循环将 $dp_i$ 转移到每个可以跳到的 $dp_j$ 上，则状态转移方程如下：

$$dp_j=\min(dp_j,dp_i+1)$$

## AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[101],dp[101];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	memset(dp,0x3f,sizeof(dp));
    dp[1]=0;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=min(i+a[i],n);j++){
			dp[j]=min(dp[j],dp[i]+1);
		}
	}
	cout<<dp[n]<<endl;
	return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/213268284)

---

## 作者：wenqinghua1001 (赞：3)

# 一道简单的题

## 思路

我看了其他人的题解，好像都没我的代码短。

本题使用**一维动态规划**，设 $a_i$ 为第 $i$ 个木桩上的数字，$f_i$ 为跳到第 $i$ 个木桩的最少跳跃次数。很明显，跳到第 1 个木桩最少跳跃次数是 0，所以 $f_1=0$，其它值为无穷大。

对于 $f_i$，在 1 到 $i-1$ 中找到一个合适的 $j$，满足 $j+a_j \le i$ 且 $f_j+1>f_i$，那么 $f_i=f_j+1$。

最后输出 $f_n$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001];
int f[1000001];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		f[i]=INT_MAX;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i==1) f[i]=0;
		for(int j=1;j<i;j++){
			if(j+a[j]>=i)
				f[i]=min(f[i],f[j]+1);
		}
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：ZYX0716 (赞：2)

[先看题](https://www.luogu.com.cn/problem/B4296)

## 题意：

有 $N$ 个木桩，对于第 $i$ 个木桩，当青蛙跳上去后，下一次跳跃长度的范围是 $1$ 至 $a[i]$ 中的任意一个整数。现在请你帮青蛙找到一种合适的跳法，使它的跳跃次数尽可能的小。

## 思路：

~~读完题后想到了搜索，随手打了个代码，结果七个点超时。~~

话不多说，上**一维背包**思路：

1.  定义 $dp[i]$ 为青蛙跳到第 $i$ 个木桩的所需的最小跳跃次数。
   
2.  令 $j$ 为青蛙从 $i$ 跳跃的落点，$j>i$，则  $dp[j]$ 为**青蛙跳到 $i$ 的最小跳跃次数** $+1$。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],dp[105];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	memset(dp,0x3f,sizeof(dp));//初始值为最大。
	dp[1]=0;//起点无需跳跃。
	for(int i=1;i<=n;i++){//遍历青蛙某一次跳跃的起点。
		for(int j=i+1;j<=a[i]+i;j++){//遍历其落点。
			if(j<=n){//防止越界。
				dp[j]=min(dp[j],dp[i]+1);
			}
		}
	}
	printf("%d",dp[n]);//输出最小跳跃次数。
	return 0;
}
```

---

## 作者：dear_deer_land (赞：2)

## 题意

跳木桩，每个木桩有一个数字，跳跃木桩数在 $1$ 到这个木桩上的数字之间，求最少跳多少次可以到第 $n$ 个木桩。

## 思路

这个问题可以使用动态规划来做。我们设置一下状态 $dp_{i}$ 表示青蛙从第一个木桩跳到第 $i$ 个木桩的最少跳跃次数。$dp_{1}$ 初始为 $0$ 表示青蛙一开始在第一个木桩上。\
**状态转移：** 因为对于每一个木桩 $i$，青蛙可以从 $i$ 向后跳跃最多 $a_{i}$ 个木桩。对于每个**可到达**的木桩 $j$（即 $i < j \le i + a_{i}$），我们可以更新 $dp_{j}$ 为 $\min (dp_{j}, dp_{i} + 1)$，表示如果从 $i$ 跳跃到 $j$，所需的跳跃次数是 $dp_{i} + 1$。

## 代码

```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
int n;
int a[1010],dp[1010];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 2; i <= n; i++) {
		dp[i] = INF;//初始化dp数组
	}
	for (int i = 1; i <= n; i++) {
		// 对于第i个木桩，尝试跳跃到后面可达的木桩	
		for (int j = i + 1; j <= min(i + a[i], n); j++) {
			dp[j] = min(dp[j], dp[i] + 1);
		}
	}
	cout << dp[n] << endl;
	return 0;
}
```

---

## 作者：wst000 (赞：1)

题意就不讲了，题目已经写得很详细了。

# 思路

本题可以使用动态规划。设 $\large dp_{i}$ 表示跳到第 $i$ 根柱子最少需要 $dp_{i}$ 步。初始将 $dp$ 数组设置成无穷大，将 $dp_{1}$ 设置为 1，转移将 $dp_{i}$ 转移到每个可以跳到的 $j$，具体的，就是 $\large dp_{j}=\min(dp_{j},dp_i+1)\:(i<j \le i+a_{i},n)$。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll> vll;
typedef string str;
typedef pair<ll, ll> pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
ll a[100005], dp[100005], n;
int main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	memset(dp, 63, sizeof(dp));
	dp[1] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = i + 1; j <= i + a[i] && j <= n; j++)
			dp[j] = min(dp[j], dp[i] + 1);
	}
	printf("%lld", dp[n]);
	return 0;
}
```

---

## 作者：yuanzongzi799 (赞：1)

### 导入：

在 $27$ 次卡在第八个点后，终于[通过](https://www.luogu.com.cn/record/213474760)了！

看了一下其它人的题解，都是用动态规划来写的，所以我写了一个**广搜**的版本。

### 思路：

本题较为简单。

首先定义两个列表，记录木桩编号和跳跃次数。随后在搜索过程中，逐次枚举每个可以跳跃的步数，直到当前位置首次等于 $n$ 时，当前的跳跃次数即为最小的跳跃次数。

### 参考代码（含详细注释）：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000+3;//定义最大值
int n,a[maxn];
int head,tail;//队头&队尾
int q_ip[maxn],q_steps[maxn];//位置&跳跃次数
bool vis[maxn];//访问标记
int bfs()
{
    q_ip[1]=1;
    q_steps[1]=0;
    vis[1]=1;
    head=tail=1;//初始化
    while(head<=tail)
	{
        if(q_ip[head]==n) 
			return q_steps[head];//若已经在最后一个木桩，返回当前步数
        for(int j=1;j<=min(a[q_ip[head]],n-q_ip[head]);j++)//跳跃后的木桩编号不能超过n
		{
            if(vis[q_ip[head]+j]==0)//未访问则进行搜索
			{
                vis[q_ip[head]+j]=1;//标记被访问
                tail++;
                q_ip[tail]=q_ip[head]+j;//当前木桩编号入队
                q_steps[tail]=q_steps[head]+1;//当前跳跃次数入队
                if(q_ip[head]+j==n)
					return q_steps[tail];//若到达最后一个木桩，返回跳跃次数
            }
        }
        head++;//出队
    }
    //return -1;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    cout<<bfs();//开始搜索
    return 0;
}
```

---

## 作者：2b2b2bbb (赞：1)

简单的 $dp$ 题目。我们定义：$dp_i$ 表示跳到 $i$ 的最少步数。那么，我们只要看能够一次到达当前点的最小的值是多少即可。

那么就是从当前点往前看，看看前面的点中，那个点能够直接跳到我们枚举的点。看看到达那个点的最少步数是多少。找到最小的步数即可。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[105],dp[105];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	memset(dp , 0x3f , sizeof(dp));
	dp[1] = 0;
	for(int i = 1 ; i <= n ; i ++){
		cin >> a[i];
	}
	for(int i = 1 ; i <= n ; i ++){
		for(int j = 1 ; j < i ; j ++){
			if(i - j <= a[j]){
				dp[i] = min(dp[i] , dp[j] + 1);
			}
		}
	}
	cout << dp[n];
	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4296)
### 思路
DP 经典题。   
$n$ 的范围较小，可以用 $O(n^2)$ 水过去~~   
对于每一个位置 $i$ 都向前查找一个位置 $j$，使得 $i$ 与 $j$ 之间的距离小于 $a_j$，即 $i -j \le a_j$。$f_i$ 与 $f_j+1$ 进行比较，取最小赋值给 $f_i$。最后答案为 $f_n$。   
### 程序

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,f[100001],a[100001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i];
	for(i=2;i<=n;i++) f[i]=2e9;
	for(i=2;i<=n;i++)
		for(j=1;j<i;j++)
			if(i-j<=a[j])
				f[i]=min(f[i],f[j]+1);
	cout<<f[n];
}
```

---

## 作者：EasyRememberName (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4296)  &&  [AC记录](https://www.luogu.com.cn/record/214107734)

题解区好像 DP 方法偏多，那我们用广搜做一下。

### 思路分析  
我们可以定义一个结构体和一个结构体类型的队列，还有一个标记数组，以便后续使用。在输入结束后调用广搜函数。第一个位置要先入队并做好标记。我们一直取出队头并弹出直到队列为空，然后遍历队头可能到达的位置并进行判断，如果到了最后一个那么就输出并结束，否则就入队并标记并更新步数。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node {
	int x,step;
};
queue<node> q;
int a[3055],f[3055],n,ans=0;
void bfs() {
	int tx,ts;
	q.push({1,0});  //第一个位置要先入队 
	f[1]=1;   //打标记 
	while(q.size()) {   //队列里还有元素就继续 
		node h=q.front();
		q.pop();   //取出队头并弹出，避免重复 
		for(int i=1;i<=a[h.x];i++) {   //队头能到达的所有位置进行遍历 
			tx=h.x+i;  //目前到达的位置 
			ts=h.step+1;    //目前的步数 
			if(f[tx]==0) {   //没有走过(被标记过) 
				if(tx==n) {   //到达最后一个 
					cout<<ts;
					exit(0);   //输出并结束 
				}
				q.push({tx,ts});    //否则入队 
				f[tx]=1;   //打标记 
			}
		}
		ts=h.step+1;   //更新步数 
	}
} 
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0); //简陋的快读 
	int i,j;
	cin>>n;
	for(i=1;i<=n;i++) { 
		cin>>a[i];
	}  //输入 
	bfs();  //调用函数 
	return 0;    //潇洒结束 
} 
```

---


# [蓝桥杯青少年组省赛 2024] 出现奇数次的数

## 题目描述

奇数：指不能被 $2$ 整除的整数。

例如：$3$、$5$ 是奇数；$4$、$6$ 不是奇数。

给定 $n$ 个整数，其中只有一个数出现了奇数次，请找出这个数。

例如：$7$ 个整数为 $6$、$2$、$4$、$6$、$4$、$2$、$6$，其中只有 $6$ 出现了奇数次，故输出 $6$。

## 样例 #1

### 输入

```
7
6 2 4 6 4 2 6```

### 输出

```
6```

# 题解

## 作者：Clare613 (赞：14)

## 思路：
我们都知道，一个数异或自己偶数次会等于 $0$，而只有一个数是奇数次，我们就可以利用这个特点来秒了这题。
## code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		ans^=x;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

众所周知 $x \oplus x = 0$，其中 $\oplus$ 表示异或运算。

由题面可知有且仅有一个数出现了奇数次，那么将所有数异或的结果即为该数。

### AC_Code

```python
n, a = input(), list(map(int, input().split()))
res = 0
for x in a:
    res ^= x
print(res)
```

---

## 作者：rui_er (赞：3)

约定记号 $x\oplus y$ 表示 $x$ 与 $y$ 的 **按位异或** ，即 C++ 中的 `x ^ y` 或 `x xor y`。

异或运算满足性质：

- 交换律，即 $x\oplus y=y\oplus x$。
- 结合律，即 $(x\oplus y)\oplus z=x\oplus (y\oplus z)$。
- 恒等律，即 $x\oplus 0=0\oplus x=x$。
- 归零律，即 $x\oplus x=0$。

设题目中的数列为 $a$。设 $S=a_1\oplus a_2\oplus\cdots\oplus a_n$，即 $S$ 为所有元素的异或和。由以上性质，将出现偶数次的相等的数两两配对，它们的异或和为 $0$；将出现奇数次的数两两配对，除了若干对数的异或和为 $0$ 以外，还会剩余一个数，因此它们的异或和为这个数本身。因此，$S$ 的值为出现奇数次的这个数，即为答案。

例如样例中：

$$
\begin{aligned}
S&=\text{\color{red}6}\oplus \text{\color{blue}2}\oplus \text{\color{orange}4}\oplus \text{\color{red}6}\oplus \text{\color{orange}4}\oplus \text{\color{blue}2}\oplus 6\\
&=(\text{\color{red}6}\oplus \text{\color{red}6})\oplus (\text{\color{blue}2}\oplus \text{\color{blue}2})\oplus 
(\text{\color{orange}4}\oplus \text{\color{orange}4})\oplus 6\\
&=\text{\color{red}0}\oplus \text{\color{blue}0}\oplus \text{\color{orange}0}\oplus 6\\
&=6
\end{aligned}
$$

可以得到正确答案。

时间复杂度 $O(n)$。

核心代码：

```cpp
//By: OIer rui_er
const int N = 1e5 + 5;
int n, a[N];

cin >> n;
for(int i = 1; i <= n; ++i) cin >> a[i];
cout << accumulate(a + 1, a + 1 + n, 0, bit_xor<int>()) << endl;

---

## 作者：ryderyang (赞：2)

# 题意简述
题目给我们 $n$ 个数，其中有 $1$ 个数字出现了奇数次，让我们找出来。
# 解题思路
众所周知，一个数异或他本身等于 $0$。$0$ 异或任何数，都等于他本身。根据这个性质，我们可以将数组中每一个数异或起来，得到结果 $ans$。答案是什么呢？其实就是 $ans$，因为数组中每两个相同的数都异或起来，抵消掉了。最后只剩下那个出现奇数次的数了。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		ans^=x;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：_Pioneer_ (赞：2)

[双倍经验](https://www.luogu.com.cn/problem/P1469)

这道题用桶的思想肯定是不行的，毕竟 $a_i < 10^9$ 会炸内存。

这里提供一种的新的运算：异或。（不知道的可右转[了解](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)）

现在我们不妨考虑异或的性质：一个数异或自己为 0。故可以推出此结论：$k$ 个相同的数的异或和，若  $k$ 为奇数则异或和为自身，否则为 0。

所以这道题的做法就很清晰了，我们可以将所有的数异或和起来，根据推出的结论，可知结果就为出现奇数次的数了。

## 完整代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int n,ans=0,a;cin>>n;
	for(int i=1;i<=n;i++)cin>>a,ans^=a;
	cout<<ans;
	return 0;
} 
```

---

## 作者：Mark_Pei (赞：2)

## solution

对于这道题，相信有巨佬是通过**排序**做出来的，就是将所有数字排序，然后遍历检查连续相同的数字的数量。如果某个数字的数量是奇数，就是答案。

当然，也可以用**哈希表（或字典）**，这里不多赘述。

但是，这道题有一种更简单的方法：**异或运算（XOR）**。

简单来说，就是利用异或运算的性质，相同的数异或结果为 $0$，任何数与 $0$ 异或为其本身。因此，将所有数字进行异或运算，出现偶数次的数字会相互抵消，最后剩下的就是出现奇数次的数字。这种方法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$，非常高效。

让我们回顾一下异或运算的一些重要性质：

交换律和结合律：$a \operatorname{xor} b \operatorname{xor} c = a \operatorname{xor} c \operatorname{xor} b = b \operatorname{xor} a \operatorname{xor} c$ 等，即异或的顺序不影响结果。

相同数异或为 $0$：$a \operatorname{xor} a = 0$。

与 $0$ 异或为本身：$a \operatorname{xor} 0 = a$。

自反性：$a \operatorname{xor} b \operatorname{xor} b = a \operatorname{xor} 0 = a$。

基于这些性质，如果我们把所有数字进行异或运算，出现偶数次的数字会成对抵消为 $0$，最后剩下的就是出现奇数次的数字。

对比一下**复杂度**：

 1.哈希表（或字典）统计次数：遍历所有数字，统计每个数字出现的次数，然后找到出现奇数次的数字。这种方法的时间复杂度是 $O(n)$，空间复杂度也是 $O(n)$，因为需要存储每个数字的出现次数。

 2.排序后检查：将所有数字排序，然后遍历检查连续相同的数字的数量。如果某个数字的数量是奇数，就是答案。这种方法的时间复杂度是 $O(n  \log n)$（因为排序），空间复杂度取为 $O(n)$。

 3.异或运算（XOR）：利用异或运算的性质，相同的数异或结果为 $0$，任何数与 $0$ 异或为其本身。因此，将所有数字进行异或运算，出现偶数次的数字会相互抵消，最后剩下的就是出现奇数次的数字。这种方法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$，非常高效。

**AC** code

异或运算：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,num,ans;
int main() 
{
    cin>>n;
    while (n--)
    {
        cin>>num;
        ans^=num;
    }
    cout<<ans;
    return 0;
}
```

排序：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long m=1000003;
long long n,s=1,a[m];
bool cmp(long long x,long long y)
{
	return x<y;
}
int main()
{
    cin>>n;
    for(long long i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1,cmp);
    for(long long i=1;i<=n;i++)
    {
    	if(a[i+1]==a[i]) s++;
    	else 
		{
			if(s%2==1) 
			{
                cout<<a[i];
			   	return 0;
			}
			else s=1;
		}
	}
    return 0;
}
```

---

## 作者：wst000 (赞：1)

# 题意
题目已经写得很清楚了，这里就不讲了。
# 思路
本题可以使用 `map` 进行下标计数，然后遍历，如果有一个数字出现了奇数次就直接输出即可。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
map<ll,ll>a;
ll n,ans;
int main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		a[x]++;
	}
	for(auto i:a){
		if(i.nd%2!=0){printf("%lld",i.st);return 0;}
	}
	return 0;
}
```

---

## 作者：qjh_2014 (赞：1)

## 题目
[题目](https://www.luogu.com.cn/problem/B4302)
## 思路
我们可以先把这 $n$ 个数去排序，在循环中去找每个数字出现的次数，如果出现的次数为奇数，即可输出结束程序。
## 代码
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[10000005];
signed main(){
	int n;
	cin>>n;
	for(int i=1; i<=n; i++){
		cin>>a[i];//输入数据 
	}
	sort(a+1,a+n+1);//排序，默认是升序 
	int ans=1;//每个数字出现的次数 
	for(int i=1; i<=n; i++){//循环判断 
		if(a[i]==a[i+1]){ 
			ans++;//数字相同 
		}else{
			if(ans%2==1){
				cout<<a[i];return 0;//输出答案 
			}else{
				ans=1;
			}
		}
	}
	return 0;
}
```
如有雷同纯属偶然。

---

## 作者：Aurora_春雪 (赞：1)

蒟蒻去年赛时居然花了好久过了这道题，还是太蒟。

前置知识：[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)。

## 思路

~~今天看了一下，居然这么简单~~。

言归正传。诸位众所周知，一个数字异或偶数次自己永远等于 $0$，而异或奇数次则等于本身。所以我们利用异或的性质，就可以轻松过了这道题！

## AC 代码

Please don't copy.

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n,ans=0;
	cin>>n;
	while(n--){
		int x;
		cin>>x;
		ans^=x;
	}
	cout<<ans;
	return 0;//撒花
}

```
[记录](https://www.luogu.com.cn/record/212024679)。

---

## 作者：LINYUHENG2 (赞：0)

## 思路
众所周知，一个数异或自己偶数次等于 $0$，而异或自己奇数次等于本身。于是，我们就可以利用这个特性来解决这道题。

我们只需要将所有的数异或起来，最终的答案就是出现奇数次的那个数。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,ans=0,x;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        ans^=x;
    }
    printf("%d",ans);
    return 0;
}
```

---


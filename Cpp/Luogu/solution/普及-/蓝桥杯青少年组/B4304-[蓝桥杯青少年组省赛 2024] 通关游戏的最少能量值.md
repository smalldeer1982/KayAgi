# [蓝桥杯青少年组省赛 2024] 通关游戏的最少能量值

## 题目描述

有一款新游戏，通关这个游戏需要完成 $n$ 个任务。这 $n$ 个任务可按任意次序完成。每个任务设置了启动能量值 $x$ 和完成任务消耗的能量值 $y$，且满足 $y \leq x$。如果玩家当前的能量值低于该任务的启动能量值，则不能开始该任务。

- 例 1：玩家当前的能量值为 $7$，当前任务的启动能量值为 $5$，完成任务消耗的能量值为 $3$。则可以开始该任务，完成任务后玩家剩余能量值为 $4$。
- 例 2：玩家当前的能量值为 $5$，当前任务的启动能量值为 $8$。则无法开始该任务。

游戏开始时，玩家需要一个初始能量值 $E$ 用来完成这 $n$ 个任务。给定每个任务的启动能量值和消耗能量值，求初始能量值的最小可能值。

例如，$n=3$，这 $3$ 个任务的启动能量值和消耗能量值分别是 $(2, 2)$、$(9, 5)$、$(7, 4)$。那么玩家初始能量的最小值为 $12$，可以按照如下顺序完成任务：

1. 完成任务 $(9, 5)$，玩家剩余能量值为 $7$；
2. 完成任务 $(7, 4)$，玩家剩余能量值为 $3$；
3. 完成任务 $(2, 2)$，玩家剩余能量值为 $1$。

尽管最后玩家的能量值剩余 $1$，但初始能量值无法再降低，否则完成任务 $(9, 5)$ 后，玩家的剩余能量值会小于任务 $(7, 4)$ 的启动能量值，导致无法开始该任务。

## 样例 #1

### 输入

```
3
2 2
9 5
7 4```

### 输出

```
12```

# 题解

## 作者：wenqinghua1001 (赞：7)

## 思路

这道题运用的是**贪心算法**，非常巧妙。

这一题最重要的是如何排序。由于题目要求的是求初始能量值的最小可能值，我们要优先处理那些对后面的任务完成影响较大的任务。每一次完成任务，能量值都会减少，可能不能完成后面启动能量值大的任务。

所以，应该优先完成**启动能量值和消耗能量值的差**大的任务。如果差一样，那么应优先完成启动能量值大的任务，避免无法开始启动能量值大的任务。

按照以上描述排序后，接下来就是第二点，模拟通关过程。设 $a_i$ 为第 $i$ 个任务的启动能量值，$b_i$ 为第 $i$ 个任务的消耗能量值，$sum_i = \sum_{k = 1}^{i} b_k$，$ans_i$ 为完成前 $i$ 个任务的最小初始能量值（不考虑启动能量值），那么 $ans_i=sum_{i-1}+a_i$。最后输出 $\max(ans_1,ans_2,\cdots,ans_{n-1},ans_n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int qi;
	int xiao;
}a[100005];
bool cmp(node x,node y){
	if(x.qi-x.xiao!=y.qi-y.xiao) return x.qi-x.xiao>y.qi-y.xiao;
	else return x.qi>y.qi;
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].qi>>a[i].xiao;
	sort(a+1,a+n+1,cmp);
	int ans=0,sum=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,a[i].qi+sum);
		sum+=a[i].xiao;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：6)

### 解题思路

我们先来考虑第一个问题：假设任务次序已经**确认**，该如何求解所需的最小能量？

很明显，假设能量 $x$ 可以完成所有任务，那么能量大于 $x$ 时一定可以。假设能量 $y$ 不能完成所有任务，那么小于 $x$ 时一定也不可以。举有单调性，可以使用二分求解。

第二个问题：如何确定任务次序，使得所需能量最小？

策略如下：算出所有任务的 $d = x - y$ 表示以 $x$ 能量启动任务剩余的能量，按照 $d$ 从大到小进行排序。

证明如下：

设有任务一 $x_1, y_1, d_1$ 排在任务二 $x_2, y_2, d_2$ 的前面（$d = x - y$）。

那么对于完成任务一所需最初能量为 $x_1$，完成任务二的所需最初能量为 $x_2 - (x_1 - y_1)$，总消耗能量为 $y_1+y_2$。

所需最初能量为 $\max(x_1, x_2-d_1)$。

交换任务一和任务二的执行顺序，那么所需最初能量为 $\max(x_2, x_1-d_2)$，总消耗能量任为 $y_1+y_2$。

总消耗能量相同，我们来讨论一下最初能量的大小比较。

设 $f = \max(x_1, x_2-d_1)$，$g = \max(x_2, x_1-d_2)$。

- 当 $x_1 < x_2$ 时，$f = \max(x_1, x_2 - d_1)$，$g = x_1 - d_2$。
  - 当 $d_1 < d_2$ 时，$f > g$。
  - 当 $d_1 = d_2$ 时，$f = g$。
  - 当 $d_1 > d_2$ 时，$f < g$。
- 当 $x_1 = x_2$ 时，$f = g$。
- 当 $x_1 > x_2$ 时，同理，不另外证明。

综上，当 $d_1 \geq d_2$ 时，所需初始能量最小。

### AC_Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
struct Node
{
    int a, b, d;
    bool operator< (const Node &t) const
    {
        return d > t.d;
    }
}q[N];

bool check(int x)
{
    for (int i = 0; i < n; ++ i )
        if (x < q[i].a)
            return false;
        else
            x -= q[i].b;
    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i = 0; i < n; ++ i )
    {
        int a, b;
        cin >> a >> b;
        q[i] = {a, b, a - b};
    }

    sort(q, q + n);

    int l = 1, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            r = mid;
        else
            l = mid + 1;
    }

    cout << l << endl;
    
    return 0;
}
```

---

## 作者：ShaDouBuShi123 (赞：3)

# B4304 题解

先放代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct task//定义一个任务结构体
{
    int s,e;
}tasks[114500];//分号！

bool cmp(task a,task b)//比较函数
{
    if (a.s-a.e!=b.s-b.e)return a.s-a.e>b.s-b.e;
    return a.s>b.s;
}

int n;

int main()
{
    cin >> n;//输入不解释
    for (int i=1;i<=n;i++)
    {
        cin >> tasks[i].s >> tasks[i].e;
    }
    sort(tasks+1,tasks+n+1,cmp);//排序，贪心
    int ene=0,total=0;//模拟
    for (int i=1;i<=n;i++)
    {
        if (ene<tasks[i].s)
        {
            total+=(tasks[i].s-ene);
            ene=tasks[i].s;
            
        }
        ene-=tasks[i].e;
    }
    cout << total;
    return 0;
}
```
不难看出，这道题使用的是**贪心算法**。首先我们明确一下题目（简称抽象化）：
1. 有 $N$ 个事件，每个事件有一个要开始事件所需的数值（但是不消耗），但是在完成后这个数值要减去另一个值（见题目）。
2. 题目要求我们求出这个数值的最小值。

非常简单！第一眼就可以判断出是贪心。贪心的核心就是排序。而我们要分析出 `bool cmp()` 函数的工作方法，请看下文。

我们肯定要把开始能量值大的任务放在前面做。很多人想到的代码为 ```return a.s>b.s;``` ，但是我写的代码是 `if (a.s-a.e!=b.s-b.e)return a.s-a.e>b.s-b.e;` ，为什么呢？我们通过观察可以发现，能量值只减不增，所以我们首先要把启动能量值高的任务放在前面，同时让这些任务的消耗尽量低。可是如何证明这行代码呢？我们假设一组数据：

```
2
6 3
5 1
```

如果用 ```return a.s>b.s;``` 来处理的话，需要 8 点能量值，但如果用`if (a.s-a.e!=b.s-b.e)return a.s-a.e>b.s-b.e;` 处理，将只需要 7 点能量值！

所以，我们只在 $a.s-a.e=b.s-b.e$ 时使用 ```return a.s>b.s;``` 。

可以看到，非常简单，接下来是一个模拟。过程很简单，大家可以先自行理解再往下看。

接下来解说一下完整的代码。

刚开始定义一个 task 结构体，创建一个结构体数组，方便排序与存储，接下来的 cmp 函数为比较，主函数中刚开始为输入，接下来是排序。模拟的过程为从第一个模拟到最后一个，不断地更新最小值。

以上就是本题的详细解法，希望对大家有所帮助！

---

## 作者：Gilbert1206 (赞：2)

## 题解：B4304 [蓝桥杯青少年组省赛 2024] 通关游戏的最少能量值

[洛谷传送门](https://www.luogu.com.cn/problem/B4304)

## 思路

其实通过数据范围是可以看出这道题明显不能通过暴力来解决问题。这道题我们仔细观察也看得出通过贪心是可以做的，但注意一点就是排序，我们应该如何排序？我们可以证明这个排序是正确的吗？

我们每一次都要选择一个，每次完成后都会减去 $y_i$，但同时要保证能量值要足够，是不是我们应该先启动 $x_i$ 大的呢？当然不是，如果对应的 $y_i$ 会非常大说明就不对。那是不是先启动 $y_i$ 小的呢？也不是。

那应该是什么呢？明显我们是想让每次做完任务后的差尽可能的大，从而让后续的启动能量值的需求减小，所以应该让 $x_i - y_i$ 最大的先做，$x_i - y_i$ 最小的后做。当然在 $x_i-y_i$ 相同时我们需要先启动能量大的，会给后面的启动能量值小的也不会再消耗更多能量值。

## code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
struct pp{
	int a,b;
}a[250000];
int cmp(pp a,pp b){
	if(a.a-a.b==b.a-b.b){
		return a.a>b.a;
	}
	return a.a-a.b>b.a-b.b;
}
signed main(){
	cin>>n;
   	for(int i=0;i<n;i++){
   		cin>>a[i].a>>a[i].b;
	}
	sort(a,a+n,cmp);
	int ans=0,now=0;
	for(int i=0;i<n;i++){
   		if(now<a[i].a){
   			ans+=a[i].a-now;
   			now=a[i].a-a[i].b;
		}
		else{
			now-=a[i].b;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ZYX0716 (赞：2)

[题面](https://www.luogu.com.cn/problem/B4304)有点长，在这里帮大家分析一下：

你接到 $n$ 个任务，可以按任意顺序完成。

对于每个任务都有其对应的底线 $x$ 和消耗 $y$，且保证 $x \ge y$。启动第 $i$ 个任务前，当前能量必须 $\ge x[i]$；完成第 $i$ 个任务后会消耗 $y[i]$ 能量。

你需要找出一个最小初始值 $E$，确保这 $n$ 个任务在某种排序下均能完成。

## 算法：

二分求出最小初始值 $E$，使其能完成这 $n$ 个任务。

需要注意的是，排序时的规则。

一开始考虑欠缺，直接按任务的启动值从大到小进行了排序，结果只得了 $90$ 分。
```cpp
bool cmp(node a,node b){
	if(a.x!=b.x)return a.x>b.x;
	return b.y>a.y;
}
```

为了避免无法完成后面的任务，应该优先完成**启动值和消耗值的差更大**（即**消耗值更小**）的任务。
```cpp
bool cmp(node a,node b){
	if(a.x-a.y!=b.x-b.y)return a.x-a.y>b.x-b.y;
	return b.x>a.x;
}
```
## AC Code:


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,l,r;
struct node{
	int x,y;
}a[N];
bool cmp(node a,node b){//排序规则见上述。
	if(a.x-a.y!=b.x-b.y)return a.x-a.y>b.x-b.y;
	return b.x>a.x;
}
int check(int x){//判断初始值为x时，是否能完成所有任务。
	for(int i=1;i<=n;i++){
		if(x>=a[i].x)x-=a[i].y;
		else return 0;
	}
	return 1;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&a[i].x,&a[i].y);
		r+=a[i].x+a[i].y;//将r赋为最大值。
	}
	sort(a+1,a+n+1,cmp);
	while(l<=r){//二分求最小初始值。
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	printf("%lld",l);
	return 0;
}
```

---

## 作者：jur10n (赞：1)

## Background

算法：二分答案、贪心。

首先理解题意，共有三个重要的信息，我们可以理解为：**门槛**、**花费**、**报酬**。其中报酬的值为门槛减去花费。

## Solution

简单思考，我们可以得出**贪心策略**：

1. 先完成回报多的任务，这样才能留下更多给回报少的。

2. 若回报相同，先完成门槛高的，不然后面无法完成。

---

由此，我们可以用**二分答案**：

1. 直接枚举希望的最小值，检验是否满足全部任务都能完成。

2. 若可以，找更小的满足值；若不可以，找较大的可能值。

## Code

细节可以看注释。


```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;

class Quick_IO
{
  public:
	template<typename T>
	void read(T &r)
	{
		T x = 0, f = 1;
		char ch = getchar();
		while (ch < '0' || ch > '9')
		{
			if (ch == '-') f = -1;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
		r = x * f;
	}
	template<typename T, typename... Args>
	void read(T &tmp, Args &... tmps)
	{
		read(tmp);
		read(tmps...);
	}
} io;

int n, M;
struct node	//门槛，花费，回报
{
	int need, cost, reward;
} a[N];
bool operator < (node x, node y)	//排序
{
	if (x.reward == y.reward) return x.need > y.need; //回报一样的话先完成门槛高的
	return x.reward > y.reward;	//先完成回报多的
}

bool Judge(int aim)	//判断
{
	for (int i = 1; i <= n; i++)
	{
		//注意二分初始区间已经排除了买不起的可能，因此不用再if
		if (aim < a[i].need) return 0;
		aim -= a[i].cost;
	}
	return 1;
}

signed main()
{
	io.read(n);
	for (int i = 1; i <= n; i++)
	{
		io.read(a[i].need, a[i].cost);
		a[i].reward = a[i].need - a[i].cost;
		M += a[i].cost;
	}
	sort(a + 1, a + 1 + n);


	int L = M, R = 2e9, mid, ans = 2e9;
	while (L <= R)	//二分答案
	{
		mid = L + (R - L) / 2;
		if (Judge(mid)) ans = mid, R = mid - 1;
		else L = mid + 1;
	}
	cout << ans;
}
```

---

## 作者：no_response (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4304)
## 题意
有款游戏，有 $n$ 个任务，每个任务有启动能量值 $x$ 和完成能量值 $y$，满足 $y \le x$，只有玩家当前能量值大于此任务的启动能量值，才能开始此任务。

游戏开始时，玩家需要一个初始能量值 $E$ 来完成这 $n$ 个任务。

现在给出 $n$ 和每个任务的 $x$ 和 $y$，求 $E$ 的最小值。
## 思路
首先这题目是贪心题，~~标签上有~~。
### 排序
这一题最重要的是如何排序。

由于题目要求的是求初始能量值的最小值，我们要优先处理那些对后面的任务完成影响较大的任务。

每一次完成任务，能量值都会减少，可能不能完成后面启动能量值较大的任务。

下面就是最重要的函数：

应该优先完成启动能量值和消耗能量值的差较大的任务。

如果差一样，那么应优先完成启动能量值大的任务，避免无法开始启动能量值大的任务。

代码如下：
```cpp
bool cmp(game p, game q) {
	if (p.x - p.y == q.x - q.y) { 
		return p.x > q.x;
	}
	return p.x - p.y > q.x - q.y; 
}
```
### 计算答案
在把数组给排序后，就到了求最小值 $E$ 了。

设答案变量为 $ans$，能量最小值为 $sum$。

在循环时把 $ans$ 持续更新，令 $sum$ 只去加完成能量即可。

代码如下：
```cpp
int ans = 0, sum = 0;
for (int i = 1; i <= n; i++) {
  ans = max(ans, a[i].x + sum);
  sum += a[i].y;
}
cout << ans;
```
## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
struct game {
	int x, y; //x为启动能量值，y为完成能量值
} a[100010];
bool cmp(game p, game q) {
	if (p.x - p.y == q.x - q.y) { //启动能量值和消耗能量值的差若相等
		return p.x > q.x; //判断启动能量值
	}
	return p.x - p.y > q.x - q.y; //比较启动能量值和消耗能量值的差
}
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].y;
	}
	sort(a + 1, a + n + 1, cmp); //把任务排序
	int ans = 0, sum = 0;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, a[i].x + sum); //答案更新
		sum += a[i].y; //最小初始能量值（不考虑启动）
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Xqbei_W (赞：1)

这是一道明显的贪心题，为了找到完成所有任务所需的最小初始能量值，我们需要确定任务的执行顺序，使得每次完成任务后剩余的能量尽可能大，从而减少后续任务对初始能量的需求。通过分析任务的启动能量和消耗能量的差值 $(x - y)$，我们发现按差值降序排列任务可以最优地满足这一条件。


#### 思路
分为排序和贪心：

排序：将任务按启动能量与消耗能量的差值$x - y$降序排列。差值越大，完成任务后剩余的能量相对越多，有利于后续任务的启动。将启动能量-消耗能量大的排在前面

贪心：

贪心部分：依次处理每个任务，维护已消耗能量的总和。
对于每个任务，计算其所需的最小初始能量（启动能量+已消耗能量总和）并更新全局最小值。
#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int n,x,y,c1,c2;
//排序
bool cmp(pair<int,int> a,pair<int,int> b){
	return (a.first-a.second)>(b.first-b.second);
}
int main(void)
{
	cin>>n;
	vector<pair<int,int>> a(n+1);
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		a[i]={x,y};
	}
	sort(a.begin(),a.end(),cmp);
	for(auto &[x,y] : a){
		int cnt=x+c1;
		if(cnt>c2) c2=cnt;
		c1+=y;
	}
	cout<<c2<<endl;
	return 0;
}
```

---

## 作者：Transparent_fish (赞：1)

## 思路

我们需要找出一个初始能量，使其能够完成 $n$ 个任务。

不难看出，这题是使用贪心算法。那么我们就发现了第二个问题，我们怎么排序？

我们可以按照 $x - y$ 的差值从小到大排序，如果差值相同，则按 $x$ 的大小排序。

## 贪心证明

假设 $x_1 - y_1 < x_2 - y_2$ 则有：

$$
x_1 + y_2 < x_2 + y_1
$$

因此：

$$
\max(x_1, x_2 + y_1) \leq \max(x_2, x_1 + y_2)
$$

所以先执行 $x - y$ 较小的任务可以得到更小的或相等的初始能量。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n;
int e = 0;
int cnt = 0;

struct node {
	int x, y;
} a[N];

// 排序
bool cmp(node a, node b) {
	if (a.x - a.y != b.x - b.y) {
		return a.x - a.y > b.x - b.y;
	}
	return a.x > b.x;
}


signed main() {
	cin >> n;
	for (int i = 0; i < n; ++i) {
		cin >> a[i].x >> a[i].y;
	}
	sort(a, a + n, cmp);
	// 模拟
	for (int i = 0; i < n; ++i) {
		if (cnt < a[i].x) {
			int now = a[i].x - cnt;
			e += now;
			cnt += now;
		}
		cnt -= a[i].y;
	}
	cout << e;
	return 0;
}
```

---


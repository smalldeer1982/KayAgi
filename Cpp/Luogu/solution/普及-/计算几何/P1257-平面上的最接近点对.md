# 平面上的最接近点对

## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4$，$0 \leq x, y \leq 10^9$。

## 样例 #1

### 输入

```
3
1 1
1 2
2 2
```

### 输出

```
1.0000
```

# 题解

## 作者：da32s1da (赞：267)

@3A17K巨佬的神仙操作！

我们充分发扬人类智慧：

将所有点全部绕原点旋转同一个角度，然后按 x 坐标排序

根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远

所以我们只取每个点向后的5个点来计算答案

这样速度快得飞起，在 n=1000000 时都可以在1s内卡过

注意旋转θ角时坐标变换

- **x'=xcosθ-ysinθ**
- **y'=xsinθ+ycosθ**

代码如下：
```
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=2e5+50;
#define D double
struct spot{
	D a[4];
}p[N];
D x,y,x_,y_,z,w,ans;
int n;
bool mmp(const spot &u,const spot &v){
	return u.a[0]<v.a[0];
}
int main(){
	scanf("%d",&n);
	z=sin(1),w=cos(1);  //旋转1弧度≈57°
	for(int i=1;i<=n;i++){
		scanf("%lf%lf",&x,&y);
		x_=x*w-y*z;
		y_=x*z+y*w;   //计算旋转后的坐标
		p[i].a[0]=x_;
		p[i].a[1]=y_;
		p[i].a[2]=x;
		p[i].a[3]=y;   //存下来
	}
	sort(p+1,p+n+1,mmp);   //排序
	for(int i=n+1;i<=n+10;i++)
	p[i].a[0]=p[i].a[1]=-N-0.01;  //边界处理
	ans=2e9+0.01;  //初始化答案
	for(int i=1;i<=n;i++)
	for(int j=1;j<=5;j++){  //枚举
		x=p[i].a[2];y=p[i].a[3];
		x_=p[i+j].a[2];y_=p[i+j].a[3];
		z=sqrt((x-x_)*(x-x_)+(y-y_)*(y-y_));  //计算距离
		if(ans>z)ans=z;   //更新答案
	}
	printf("%.4lf\n",ans);  //输出
}
/*
x'=xcosθ-ysinθ
y'=xsinθ+ycosθ
*/
```
## 人类的智慧是无穷无尽的！

---

## 作者：DestinHistoire (赞：183)

## 【问题描述】
n个点在公共空间中，求出所有点对的欧几里得距离最小的点对


![](https://cdn.luogu.com.cn/upload/pic/60268.png)
## 【分析】
&emsp;&emsp;该题直观的解决方法是 $Brute Force$(暴力)。时间复杂度为$O(n^2)$
```cpp
int minn=INF;
for(int i=1;i<=size(P)-1;i++)
{
	for(int j=i+1;j<=size(P);j++)
  	{
		int a=P[i],b=P[j];
   		minn=min(minn,distance(a,b));
   		closest=(a,b);
   	}
	return closest;
}
```
## 分治法求解
### 分解
&emsp;&emsp;对所有的点按照 $x$ 坐标(或者 $y$ )从小到大排序(排序方法时间复杂度 $O(nlogn))$。根据下标进行分割，使得点集分为两个集合。
### 解决
&emsp;&emsp;递归的寻找两个集合中的最近点对。取两个集合最近点对中的最小值 $min(dis_{left},dis_{right})$   
###	合并
&emsp;&emsp;最近距离不一定存在于两个集合中，可能一个点在集合 $A$ ，一个点在集合 $B$，而这两点间距离小于 $dis$。  
&emsp;&emsp;其中如何合并是关键。根据递归的方法可以计算出划分的两个子集中所有点对的最小距离 $disleft,disright$，再比较两者取最小值，即 $dis=min(dis_{left},dis_{right})$ 。那么一个点在集合 $A$，一个在集合 $B$ 中的情况，可以针对此情况，用之前分解的标准值，即按照 $x$ 坐标(或者 $y$ )从小到大排序后的中间点的 $x$ 坐标作为 $mid$。划分一个 $[mid-dis,mid+dis]$ 区域，如果存在最小距离点对，必定存在这个区域中。  
![](https://cdn.luogu.com.cn/upload/pic/60270.png)  
&emsp;&emsp;之后只需要根据左边区域 $[mid-dis,mid]$ 的点来遍历右边区域 $[mid,mid+dis]$ 的点，即可找到是否存在小于 $dis$ 距离的点对。  
&emsp;&emsp;但是存在一个最坏情况，即通过左右两个区域计算得到的 $dis$ 距离来划分的第三区域可能包含集合所有的点，这时候进行遍历查找，时间复杂度仍然和 $brute force$ 方法相同，都为$O(n^2)$。因此需要对此进行深一步的考虑。

&emsp;&emsp;1985年 Preparata 和 Shamos 在给出该问题的一个分治算法并且还具体分析了在 $[mid-dis,mid+dis]$ 区域中出现的情况，若 $(p,q)$ 是 $Q$ 的最近点对，$p$ 在带域左半部分，则 $q$ 点必在下图所示的 $\delta* 2\delta$ 长方形上，而在该长方形上，最多只能由右边点集的6个点。每个点对之间的距离不小于δ。
![](https://cdn.luogu.com.cn/upload/pic/60272.png)

&emsp;&emsp;此结论很好证明，通过在 $\delta* 2\delta$ 上以 $\frac{2\delta}{3}* \frac{\delta}{2}$ 划成 $6$ 个小长方形
![](https://cdn.luogu.com.cn/upload/pic/60273.png)

&emsp;&emsp;用反证法来证明，假设存在大于6个点，则必有一个或多个小长方形存在两个及以上点，而小长方形的最长距离是为对角线长度，为：
$\sqrt{(\frac{2\delta}{3}*\frac{2\delta}{3}+\frac{\delta}{2}*\frac{\delta}{2})}=\frac{5}{6}\delta<\delta$。最长距离都小于δ，与之前的条件不符合，故最多有6个点。借此，可以将可能的线性时间缩小到常数级，大大提高了平均时间复杂度。

## 时间复杂度
&emsp;&emsp;在分解和合并时，可能存在按照x轴、y轴进行排序的预处理O(nlogn)，该问题在解决阶段只做提取的操作为Θ(n)，递推式为：

$$T(n)=\begin{cases}  1 & n<=3\\2T(\frac{n}{2})+O(n) &n>3\\\end{cases}$$
&emsp;&emsp;计算后得到整体时间复杂度为:$O(nlogn)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct point
{
    double x,y;
}p[200010];
int n,temp[200010];
bool cmp(const point &A,const point &B)
{
    if(A.x==B.x)
        return A.y<B.y;
    else
        return A.x<B.x;
}
bool cmps(const int &a,const int &b)
{
    return p[a].y<p[b].y;
}
double distance(int i,int j)
{
    return sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));
}
double merge(int left,int right)
{
    double dis=2<<20;
    if(left==right)
        return dis;
    if(left+1==right)
        return distance(left,right);
    int mid=(left+right)>>1;
    double d1=merge(left,mid);
    double d2=merge(mid+1,right);
    dis=min(d1,d2);
    int k=0;
    for(int i=left;i<=right;i++)
        if(fabs(p[i].x-p[mid].x)<=dis)
            temp[k++]=i;
    sort(temp,temp+k,cmps);
    for(int i=0;i<k;i++)
        for(int j=i+1;j<k&&p[temp[j]].y-p[temp[i]].y<dis;j++)
            dis=min(dis,distance(temp[i],temp[j]));
    return dis; 
}
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
        scanf("%lf %lf",&p[i].x,&p[i].y);
    sort(p,p+n,cmp);
    printf("%.4lf\n",merge(0,n-1));
    return 0;
}

```

---

## 作者：plane (赞：54)

#方法一：

先求第1个点与其余n-1个点的距离；

再求第2个点与其余n-2个点的距离；

再求第3个点与其余n-3个点的距离；

…………………………………………

再求第n-1个点与其余1个点的距离；

然后找出最小值。

如此的算法复杂度为O(n^2)，显然不能满足本题的需要。但……貌似洛谷神机可以……过……

欢迎朴素的同学挑战数据加强版[新](http://oj.luogu.org:8888/problemshow?pid=1429)


##方法二：

考虑以下分治算法：

设平面上的点都在点集S中，为了将S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l（方程：x=m）来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px>m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。
递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min (δ1,δ2)。


若S的最接近点对(p,q)之间的距离d(p,q)<δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈S1，q∈S2


此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n^2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)<δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，


由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。


因此d(u,v)≤5δ/6<δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n^2/4对候选者。



我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。


**至此，我们用分治法求出平面最接近点对。**


```delphi


type rec=record
     x,y:int64;
     end;
var a:array [0..200001] of rec;
    tt,ttt,tttt:array [0..200001] of rec;
    n,l,m,min:int64;
    i,j,k:longint;
procedure sort(l,r:longint);
var i,j:longint;
    x,y:rec;
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
    while (a[i].x<x.x) or ((a[i].x=x.x) and (a[i].y>x.y)) do inc(i);
    while (x.x<a[j].x) or ((x.x=a[j].x) and (x.y>a[j].y)) do dec(j);
    if not(i>j)
    then
      begin
        y:=a[i];
        a[i]:=a[j];
        a[j]:=y;
        inc(i);
        j:=j-1;
      end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
procedure sortt(l,r:longint);
var i,j:longint;
    x,y:rec;
begin
  i:=l;
  j:=r;
  x:=tttt[(l+r) div 2];
  repeat
    while (tttt[i].y<x.y) do inc(i);
    while (x.y<tttt[j].y) do dec(j);
    if not(i>j)
    then
      begin
        y:=tttt[i];
        tttt[i]:=tttt[j];
        tttt[j]:=y;
        inc(i);
        j:=j-1;
      end;
  until i>j;
  if l<j then sortt(l,j);
  if i<r then sortt(i,r);
end;
function dis(a,b:rec):int64;
begin
  exit(sqr(a.x-b.x)+sqr(a.y-b.y));
end;
function minn(a,b:int64):int64;
begin if a<b then exit(a) else exit(b); end;
function work(le,ri:longint):int64;
var tl,tr,t1,t2,min:int64;
    i,j,k,lenr,lenl,p1,p2:longint;
begin
  if ri-le=1 then exit(dis(a[ri],a[le]));
  if ri-le=2 then exit(minn(minn(dis(a[ri],a[le]),dis(a[ri-1],a[le])),dis(a[le+1],a[ri])));
  tl:=work(le,(le+ri) div 2);
  tr:=work(((le+ri) div 2)+1,ri);
  min:=minn(tl,tr);
  t1:=(le+ri) div 2;
  t2:=t1+1;
  while (t1>=le) and (sqr(a[t1].x-a[(le+ri) div 2].x)<=min) do dec(t1);
  inc(t1);
  while (t2<=ri) and (sqr(a[t2].x-a[(le+ri) div 2].x)<=min) do inc(t2);
  dec(t2);
  if (t2=(le+ri) div 2) or (t1=((le+ri) div 2)+1) then exit(min);
  for k:=t1 to t2 do tttt[k]:=a[k];
  sortt(t1,t2);
  for k:=t1 to t2-1 do
    begin
      for j:=k+1 to minn(k+8,t2) do
        begin
          min:=minn(min,dis(tttt[k],tttt[j]));
        end;
    end;
  exit(min);
end;
begin
  readln(n);
  for i:=1 to n do readln(a[i].x,a[i].y);
  sort(1,n);
  writeln(sqrt(work(1,n)):0:4);
end.


```

---

## 作者：LordLeft (赞：32)

既然这个题目都告诉我们可以暴搜

那么。。。

暴力枚举呢？

8说了， ~~开冲~~ 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10005],y[10005];
int n;
double ans=100000000;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		for(int j=i-1;j>=1;j--){//这里每一次输入只要和前面几次比较，可以节省一些时间
			int aa=(x[i]-x[j])*(x[i]-x[j]),bb=(y[i]-y[j])*(y[i]-y[j]);
			if(sqrt(aa+bb)<ans)ans=sqrt(aa+bb);//勾股定理强算
			}
		}
		
	cout<<fixed<<setprecision(4)<<ans;	
	return 0;
	}

```

显然，这种方法效率极低（毕竟我很蒟蒻），但是做这个题目够了

（第一篇题解lol）

---

## 作者：应吟吟 (赞：12)

###### 结合[blog](http://Linqwq.github.io/)食用效果更加

# 分析

题目中不是说了吗

>  ![](https://i.loli.net/2019/04/08/5cab1ea0e72c9.png) 

那我们也要根据出题人的意图去写嘛(~~大雾~~

我们看一下数据范围

> $ 2≤n≤10000 $

$emmm$，$O(n^2)$的好像可以$*$掉此题

这个时候，本题的一个坑点就出来了: 

> $x$和$y$的范围呢？

虽然我是随手$long\ long$的(这不是好习惯吗)，但是我还是试了一下不开$ long\ long $$(no\ zuo\ no\ die)$，然后。。。你会惊奇的发现

这是不开$ long\  long $的提交

![](https://i.loli.net/2019/04/08/5cab220a47095.png)

这是开了$long\ long​$的提交

![](https://i.loli.net/2019/04/08/5cab220a58812.png)

你可以看到这是两份完全一样的程序，除了

```cpp
#define ll long long
#define ll int
```

这个不同。

~~(十年$OI$一场空，没开$long\ long$见祖宗)~~

***

# 切入正题

我们直接暴力枚举两个端点，并计算出它们之间的距离，用一个数$ ans $维护最小值

距离就简单的用勾股定理求就好了

代码+注释 如下：

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define ll int

using namespace std;

#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template < class T > inline void read(T &x)
{
	x = 0;
	char c = getchar();
	bool f = 0;
	for (; !isdigit(c); c = getchar()) f ^= c == '-';
	for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	x = f ? -x : x;
}
#undef getchar()

template < class T > inline void write(T x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
}

const ll FFF=10000+5;
const ll inf=0x7fffffff;

ll n;
ll ans=inf;//定义+设置初始值

struct node
{
	ll x,y;
}dian[FFF];//点(拼音看得懂的吧)，x、y是这个点的横纵坐标

ll dis(ll x1,ll x2,ll y1,ll y2)//勾股定理(P.S. 其实这里可以不用直接开方，直接比较距离的平方，最后再开方)
{
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}

int main()
{
	if(fopen("hhh.in", "r"))
	{
		freopen("hhh.in", "r", stdin);
		freopen("hhh.out", "w", stdout);
	}
	ios::sync_with_stdio(false);
	read(n);
	for(int i=1;i<=n;++i)
	{
		read(dian[i].x);
		read(dian[i].y);
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			ans=min(dis(dian[i].x,dian[j].x,dian[i].y,dian[j].y),ans);//暴力枚举并维护
		}
	}
	printf("%0.4lf",(double)sqrt(ans));
	return 0;
}

```

~~(码风邪教，勿介)~~

~~总的来说，这道题毕竟是道![](https://i.loli.net/2019/04/02/5ca2cb5193a92.png)，还是比较简单的~~

---

## 作者：_jimmywang_ (赞：10)

# 写题解写题解
# step1：暴力
对于两个点i，j，计算dis（i，j），然后取最小值。

代码（100分，1.26s）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			ans=min(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
	printf("%.4lf",ans);
	return 0;
}
```
# step2：排序优化
按照x关键字排序，计算min（ans，dis（i，i-1））
代码（70分，53ms）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（？？？）~~
# step3:玄学排错1
按照x关键字排序，计算min（ans，dis（i，i-1））和min（ans，dis（i，i-2））
代码（100分，44ms）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	for(int i=3;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-2].x,a[i-2].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（？？？？？？？）~~
# step4:玄学排错2
按照x关键字排序，计算min（ans，dis（i，i-1））

按照y关键字排序，计算min（ans，dis（i，i-1））

代码（100分，48ms）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
bool cmp1(node a,node b){return (a.y==b.y)?(a.x<b.x):(a.y<b.y);}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));	
	sort(a+1,a+n+1,cmp1);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（ooo）~~
# step5：玄学优化*2

按照x关键字排序，计算min（ans，dis（i，i-1））和min（ans，dis（i，i-2））和min（ans，dis（i，i-3））~~（你无聊吗？）~~

代码（100分，52ms）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[500010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	for(int i=3;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-2].x,a[i-2].y));
	for(int i=4;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-3].x,a[i-3].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~(666666……)~~

---

## 作者：hanyufei (赞：9)

%%%所有用分治的dalao

我只会用随机化~~(我连暴力也不会）~~

~~然而我懒得写退火~~

于是有了random_shuffle(但是它死了)

code:

```
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define rep(i,j,k) for(register int i=(j);i<=(k);++i)
using namespace std;
template<class T> inline void read(T &x)
{
    x=0;
    register char c=getchar();
    register bool f=0;
    while(!isdigit(c))f^=c=='-',c=getchar();
    while(isdigit(c))x=x*10+c-'0',c=getchar();
    if(f)x=-x;
}
const int N=10001;
struct node{
	int x,y;
}a[N];
int n;
double ans=100001;
int main()
{
	read(n);
	rep(i,1,n)
		read(a[i].x),read(a[i].y);
	rep(i,1,100000)
	{
		random_shuffle(a+1,a+1+n);
		ans=min(ans,sqrt((a[1].x-a[2].x)*(a[1].x-a[2].x)+(a[1].y-a[2].y)*(a[1].y-a[2].y)));
	}
	printf("%.4lf",ans);
	return 0;
}
```

只有七十分

于是我想到了随机找两个点即可

###### code:

```
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define rep(i,j,k) for(register int i=(j);i<=(k);++i)
using namespace std;
template<class T> inline void read(T &x)
{
    x=0;
    register char c=getchar();
    register bool f=0;
    while(!isdigit(c))f^=c=='-',c=getchar();
    while(isdigit(c))x=x*10+c-'0',c=getchar();
    if(f)x=-x;
}
const int N=10001;
int n,a[N],b[N];
double ans=100000;
int main()
{
	srand(19260817);
	srand(rand());
	srand(rand());
	read(n);
	rep(i,1,n)
		read(a[i]),read(b[i]);
	rep(i,1,26000000)
	{
		register int x=rand()%n+1;
		register int y=rand()%n+1;
		if(x!=y) 
			ans=min(ans,(double)sqrt((a[x]-a[y])*(a[x]-a[y])+(b[x]-b[y])*(b[x]-b[y])));
	}
	printf("%.4lf",ans);
	return 0;
}
```

26000000是我一次一次试出来的！


##### 完

---

## 作者：doby (赞：9)

这题的第一个c++题解……

```cpp
n<=10000，所以n^2还是能卡过……
#include<cstdio>
#include<cmath>
using namespace std;
int n,x[10009],y[10009];
double ans=23333333;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){scanf("%d%d",&x[i],&y[i]);}
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))<ans){ans=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));}
        }
    }
    printf("%.4lf",ans);
    return 0;
}
```

---

## 作者：LevenKoko (赞：7)

//来个搜索的题解（虽然好像比暴力还慢一点）

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
double x[100005][2],minn=100000000;
int n,m=2,w[100005]={0},a[100005]={0};

void dfs(int step)
{
    if(step==m+1)
    {
        double ans=sqrt((x[a[1]][0]-x[a[2]][0])*(x[a[1]][0]-x[a[2]][0])+(x[a[1]][1]-x[a[2]][1])*(x[a[1]][1]-x[a[2]][1]));//距离公式算距离 
        minn=min(minn,ans);//取最小值； 
    }
    else
    {
        for(int i=w[step-1]+1;i<=n;i++)//从上一步的i的位置下一个开始，以免重复 
        {
            w[step]=i;//记录当前i的位置； 
            a[step]=i;//记录第i个位置存的点的序号 
            dfs(step+1);//下一步搜索 
        }
    }
}

int main()
{
    //ios::sync_with_stdio(0);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        cin>>x[i][0]>>x[i][1];//输入位置； 
    dfs(1);//搜； 
    printf("%.4f",minn);//4位小数 
    return 0;
}
```
//就是n个里面选2个；

---

## 作者：w4p3r (赞：5)

这不是KD-Tree板子吗，为啥没人写KD-Tree，那我来发一发KD-Tree的题解吧

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#include<map>
#include<algorithm>
#include<bitset>
#define inf 1e100
#define eps 1e-6
#define N 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct node{double d[2],minn[2],maxn[2];int ch[2];}t[N<<1];
int n,rt,D;
double minn=inf;
double ansmin=inf;
double nowx,nowy;
inline int cmp(node x,node y){return x.d[D]<y.d[D];}
inline void pushup(int x)
{
	int l=t[x].ch[0],r=t[x].ch[1];
	if(l){t[x].maxn[0]=max(t[x].maxn[0],t[l].maxn[0]);t[x].maxn[1]=max(t[x].maxn[1],t[l].maxn[1]);t[x].minn[0]=min(t[x].minn[0],t[l].minn[0]);t[x].minn[1]=min(t[x].minn[1],t[l].minn[1]);}
	if(r){t[x].maxn[0]=max(t[x].maxn[0],t[r].maxn[0]);t[x].maxn[1]=max(t[x].maxn[1],t[r].maxn[1]);t[x].minn[0]=min(t[x].minn[0],t[r].minn[0]);t[x].minn[1]=min(t[x].minn[1],t[r].minn[1]);}
}
void build(int &root,int l,int r,int d)
{
	if(l>r){root=0;return ;}
	int mid=(l+r)>>1;D=d;root=mid;
	nth_element(t+l,t+mid,t+r+1,cmp);
	build(t[mid].ch[0],l,mid-1,d^1);
	build(t[mid].ch[1],mid+1,r,d^1);
	pushup(mid);
}
inline double dis(int x){return (t[x].d[0]-nowx)*(t[x].d[0]-nowx)+(t[x].d[1]-nowy)*(t[x].d[1]-nowy);}
inline double gmin(int x)
{
	double sum=0;
	if(t[x].maxn[0]<nowx){sum+=(nowx-t[x].maxn[0])*(nowx-t[x].maxn[0]);}
	if(t[x].minn[0]>nowx){sum+=(nowx-t[x].minn[0])*(nowx-t[x].minn[0]);}
	if(t[x].maxn[1]<nowy){sum+=(nowy-t[x].maxn[1])*(nowy-t[x].maxn[1]);}
	if(t[x].minn[1]>nowy){sum+=(nowy-t[x].minn[1])*(nowy-t[x].minn[1]);}
	return sum;
}
inline void qmin(int now)
{
	if(!now)return ;
	double len=dis(now),ls=gmin(t[now].ch[0]),rs=gmin(t[now].ch[1]);
	if(len>=eps){minn=min(minn,len);}
	if(ls<rs){if(ls<minn)qmin(t[now].ch[0]);if(rs<minn)qmin(t[now].ch[1]);}
	else {if(rs<minn)qmin(t[now].ch[1]);if(ls<minn)qmin(t[now].ch[0]);}
}
inline int Cmp(node x,node y){return x.d[0]<y.d[0]||(fabs(x.d[0]-y.d[0])<=eps&&x.d[1]<y.d[1]);}
int main()
{
	n=read();
	for(register int i=1;i<=n;i++)scanf("%lf%lf",&t[i].d[0],&t[i].d[1]),t[i].minn[0]=t[i].maxn[0]=t[i].d[0],t[i].minn[1]=t[i].maxn[1]=t[i].d[1];
	sort(t+1,t+n+1,Cmp);
	for(register int i=2;i<=n;i++)if(fabs(t[i].d[0]-t[i-1].d[0])<=eps&&fabs(t[i].d[1]-t[i-1].d[1])<=eps)ansmin=0;//特判，如果有两个点坐标相同就是0 
	build(rt,1,n,1);
	for(register int i=1;i<=n;i++)
	{
		nowx=t[i].d[0],nowy=t[i].d[1];
		minn=inf;qmin(rt);
		ansmin=min(ansmin,minn);
	}
	printf("%.4lf",sqrt(ansmin));
	return 0;
}
```

---

## 作者：loi_hjh (赞：3)

看了楼下如此多的正解，本蒟蒻发一篇简单的非正解暴力代码，90分，开O2优化100分

附上代码：

```cpp
 #include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
struct gg{
	int x,y;
}a[10100];
int n;
double ans=123456789.0;
in void dis(int x,int y){
	ans=min(ans,sqrt(1.0*(pow(a[x].x-a[y].x,2)+pow(a[x].y-a[y].y,2))));//勾股定理求距离 
	return;
}
int main(){
	scanf("%d",&n);
	for(ri i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);//读入每个点的坐标 
	for(ri i=1;i<=n;i++)
		for(ri j=i+1;j<=n;j++)
			dis(i,j);//最原始的暴力枚举
	printf("%.4lf",ans);
	return ~~(0-0);
}


```

---

## 作者：feecle6418 (赞：3)

【题目名称】寻找平面上的最近点对

【题意大概】给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所有点对中，该距离为所有点对中最小的。

【标签】枚举法

【重点与坑点】

重点：直接暴力模拟，但是需要优化一下：

- 每次算距离时，不用sqrt，最后再开一次即可。

坑点：并没有的

【代码核心部分】

```cpp
    double dis(point a,point b){
        return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
    }
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].x>>a[i].y;
    }
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            Min=min(Min,dis(a[i],a[j]));//求距离，不要根号
        }
    }
    cout<<fixed<<setprecision(4)<<sqrt(Min);
```

---

## 作者：Xuan__Yao (赞：2)

## 思路
因为题目范围是10000，所以我们枚举两个点，求他的距离。时间复杂度是O(n^2)这样是不行的，但因为由i=x点，j=y点 与 i=y点，j=x点是一样的，所以只要把枚举压缩一下，九个一得到时间复杂度为O(n(n-1)/2)的算法，是可以通过的。
## 枚举代码如下：
```cpp
for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
		minn=min(minn,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));//x[i]是第i个点的x坐标，y[i]是滴i个点的y坐标。
```
## 代码很短，只有二十几行：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
double minn=2147483647,x[10010],y[10010];//因为输出的是小数，所以我们要用double类型存储。
int n,cnt;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&x[i],&y[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			minn=min(minn,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));//计算距离并与之前的取最小值。
		}
	}
	printf("%.4lf",minn);//输出保留四位。
	return 0;
}
```

---

## 作者：ezoiHY (赞：2)

这道题数据不大

两点距离用勾股定理求




```cpp
#include<iostream>
#include<cmath>
using namespace std;
struct node{
    int x,y;
}p[100001];
int n;
double dis(node a,node b){//勾股定理函数
    double x=abs(a.x-b.x),y=abs(a.y-b.y);
    return sqrt(x*x+y*y);
}
double mini=0x7fffffff;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&p[i].x,&p[i].y);
        for(int j=i-1;j>=1;j--){
            mini=min(mini,dis(p[i],p[j]));//一边输入一边搜
        }
    }
    printf("%.4f\n",mini);
}
```

---

## 作者：北海若 (赞：1)

听说这道题高级卡常，我来介绍一下怎么削常数。

O(n^2)
两点间距离公式大家都知道，根号下x的差的平方+y的差的平方

但是去掉根号，距离大小比较依然是正确的，可以削掉常数（求根号挺慢的）

然后register不说了，然后能用int尽量int

然后if(a<b) b=a;改成b=a<b?a:b可以节约时间

省掉sqrt时间缩了一半

'''


    
    

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int x[10002];
int y[10002];
int main()
{
    int n;
    cin>>n;
    register int tmpx, tmpy;
    register long long tmpz;
    for (int i=0; i<n; i++)
        scanf("%d%d", &x[i], &y[i]);
    long long mindis2 = 4294967296ll;
    for (int i=0; i<n; i++)
        for (int j=i+1; j<n; j++)
        {
            tmpx = x[i] - x[j];
            tmpy = y[i] - y[j];
            tmpz = (long long)tmpx * tmpx + (long long)tmpy * tmpy;
            mindis2 = mindis2 < tmpz ? mindis2 : tmpz;
        }
    printf("%.4f", sqrt(mindis2));
    //getchar();getchar();
    return 0;
}
'''
```

---

## 作者：EarthGiao (赞：1)

## 【思路】    
分治 + 枚举    
话说我也不知道为什么标签上面会有分治   
可能用分治会跑的更快吧      
但是这道题目完全是可以用枚举过掉的  
本来还是有点难度的   
但是一旦可以用枚举过掉   
那就是一道大水题了   

不过还是有两个值得注意的地方的   

min和max只能比较两个相同定义类型的变量    
是没有办法比较两个不用定义类型的变量的    
比如他可以比较两个double类型的大小，也可以比较两个int类型的大小   
但是一旦比较一个double和一个int类型的大小就会编译错误   
所以这里的最小值Min需要定义成double类型的   
因为两点之间距离公式如果用cmath库里面的sqrt求的话   
那返回值是double类型的   
float也不行哦！    
并且输出的时候有精度，   
当然是double更好地啦   
   
另一个值得注意的问题就是两点之间求根公式啦    
两点之间的距离等于$\sqrt {(x_1 - x_2)^2 + (y_1 - y_2)^2}$     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cmath> 

using namespace std;
const int Max = 10005;
struct node
{
	int x,y;
}a[Max];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i <= n;++ i)
		scanf("%d%d",&a[i].x,&a[i].y);
	double Min = 0x7fffffff;
	for(int i = 1;i <= n;++ i)
		for(int j = i + 1;j <= n;++ j)
			Min = min(Min,sqrt((a[i].x -a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y)));
	printf("%.4lf\n",Min);
	return 0;
}
```

---

## 作者：clarkwang (赞：1)

想了想，用枚举应该可以，所以就写了一份暴力，恐怕这是最暴力的代码了：
```cpp
#include <iostream>
#include <stdio.h>
#include <cmath>

using namespace std;

double l(double x, double y, double x2, double y2)  
{  
    return fabs(x - x2) * fabs(x - x2) + fabs(y - y2) * fabs(y - y2);  
}

int main(int argc, char *argv[])  
{  
    int n, i, j;  
	double minl = 2100000000, l2, x[10001], y[10001];  
    cin >> n;  
    for(i = 1;i <= n;i++)  
        cin >> x[i] >> y[i];  
    for(i = 1;i < n;i++)  
        for(j = i + 1;j <= n;j++)  
        {  
            l2 = l(x[i], y[i], x[j], y[j]);  
            if(l2 < minl) minl = l2;  
        }  
    printf("%.4lf", sqrt(minl));  
    return 0;  
}
```
 还真是**暴力出奇迹**

---

## 作者：野生小卒 (赞：1)

是的这是一个暴力代码……但是~~数据太水居然~~能过~~？！~~就行



```cpp
    #include <cmath>
    #include <cstdio>
    #include <iostream>
    using namespace std;
    int main(void)
    {
        int n; cin>>n;
        double x[n],y[n],Min=100000000;
        for (int i=1; i<=n; i++)
        {
            cin>>x[i]>>y[i];
            for (int j=i-1; j>0; j--)
                Min=min(Min,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
        }
        printf("%.4f",Min);
        return 0;
}
```

---

## 作者：白菜道士 (赞：0)

#### ~~关于这道题，其实是比较玄学的~~
-----
#### 思路很简单（~~简直就是暴力中的极品~~）

#### 不知道为什么dalao们说要随机旋转

我基本上纯暴力A掉了

以下为方法：

先求第1个点与其余n-1个点的距离；

再求第2个点与其余n-2个点的距离；

…………………………………………

再求第n-1个点与其余1个点的距离；

然后找出最小值，如此的算法复杂度为O(n^2)

核心代码如下：

```cpp

  for(int i=1; i<=n; i++)
        for(int j=i; j<=n; j++)
            if(i+j<=n)
            {
                d=sqrt((x[i]-x[j])*(x[i]-x[j])*1.0+(y[i]-y[j])*(y[i]-y[j])*1.0);
                if(d<mindist)	mindist=d;
            }
            
```

~~如果数据加强显然不行~~
比如 [这题](https://www.luogu.org/problemnew/show/P1429)

然后就比较~~玄学~~了

为了减少枚举量，本少决定只比较每个点后面的150个点

然后莫名AC了

为了再次减少枚举量，本少决定只比较每个点后面的50个点

然后再次莫名AC了

为了再次减少枚举量，本少决定只比较每个点后面的3个点

然后再次莫名AC了

~~这是一个玄学问题~~

AC代码如下
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;//流线型头文件

const int Max=200010;
double x[Max],y[Max];

void Qsort(int l,int r)
{
    int i,j;
    double a,b;
    i=l;
    j=r;
    a=x[(l+r)/2];
    while(i<=j)
    {
        while(x[i]<a)	i++;
        while(a<x[j])	j--;
        if(i<=j)
        {
            b=x[i];	x[i]=x[j]; x[j]=b;
            b=y[i];	y[i]=y[j]; y[j]=b;
            i++;
            j--;
        }
    }
    if(i<r)	Qsort(i,r);
    if(l<j)	Qsort(l,j);
}//先给x坐标排序

int main()
{
    int len;
    scanf("%d",&len);
    for(int i=1; i<=len; i++)
        scanf("%lf%lf",&x[i],&y[i]);
    double mindist=99999999999;
    Qsort(1,len);
    double d;
    for(int i=1; i<=len; i++)
        for(int j=1; j<=3; j++)//比较每个点后面的3个点
            if(i+j<=len)
            {
                d=sqrt((x[i]-x[i+j])*(x[i]-x[i+j])*1.0+(y[i]-y[i+j])*(y[i]-y[i+j])*1.0);
                if(d<mindist)	mindist=d;
            }//比较
    printf("%.4lf\n",mindist);
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

直接用n方算法过。数据真的很水。（膜拜一下洛谷的神奇的评测机）

距离公式应该都知道是：sqrt((x1-x2)^2+(y1-y2)^2)

```cpp
var
  n,i,j:longint;
  min,k:real;
  a,b:array[1..100000] of longint;
begin
  readln(n);
  for i:=1 to n do begin
    readln(a[i],b[i]);
  end;
  min:=maxlongint;
  for i:=1 to n do begin
    for j:=1 to n do begin
      if i=j then min:=min;
      if (i<>j) then begin
        k:=sqrt((a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j]));
        if k<min then min:=k
      end;
    end;
  end;
  writeln(min:1:4);
end.
```

---


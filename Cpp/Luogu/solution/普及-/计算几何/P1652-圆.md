# 圆

## 题目描述

给出 $n$ 个圆，保证任意两个圆都不相交且不相切。  

然后给出两个点 $(x_1,y_1),(x_2,y_2)$，保证均不在某个圆上。现在要从 $(x_1,y_1) \to (x_2,y_2)$ 画条曲线，问这条曲线最少穿过多少次圆的边界？



## 说明/提示

【数据范围】  

对于 $100\%$ 的数据，$1\le n \le 50$，$|x|,|y| \le 1000$，$1 \le r \le 1000$。

保证圆之间没有公共点。

## 样例 #1

### 输入

```
7
1 -3 2 5 -4 12 12
1 -1 2 5 5 1 1
8 1 2 1 1 1 2
-5 1 12 1```

### 输出

```
3```

# 题解

## 作者：dingcx (赞：869)

要清楚，这道题是红题！（~~不要想复杂了~~）
## 思路
### 首先分析题目
1.相离的意思可不是外离，**内含**也算相离。（我开始也理解错了，看了讨论才知道，**~~我可没看题解~~**）

2.要画一条曲线，意思就是想怎么弯就怎么弯。所以最终要求的就是两个点的连线**最少穿过几个圆**。
### 怎么求
例如这样

![](https://cdn.luogu.com.cn/upload/image_hosting/ee4gn54p.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这里三个圆都把两点分隔在了两边，所以是$3$。随便连一条线就行了，可以：

![](https://cdn.luogu.com.cn/upload/image_hosting/5er0zqnu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

或者这样

![](https://cdn.luogu.com.cn/upload/image_hosting/enmt9z7t.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

有一个圆没有用，另外两个圆都起到了分隔作用，所以是$2$。可以这样连：

![](https://cdn.luogu.com.cn/upload/image_hosting/gtsa2yxx.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

还可以是这样

![](https://cdn.luogu.com.cn/upload/image_hosting/okrfsxin.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

外面的圆把里面的所有东西都套住了，同样没有用，而其余两个圆都有用，所以也是$2$。可以这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ct5tejlm.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

很容易总结出答案就是把所有把两个点分隔的圆的个数，也就是**其中一个在圆内**，**另一个在圆外**的**圆的个数**。
## 细节
距离就是$\sqrt{(x1-x2)^2+(y1-y2)^2}$

注意$y1$不能设为全局变量（局部变量可以），会出bug。

判断一个在圆内，另一个在圆外时，可以用**异或**，看两点**到圆心的距离是否小于**（不能等于）**半径**。
## 代码
~~相信没有多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——

代码长度$19$行（~~很短~~），时间$3ms$（~~挺快~~）
```cpp
#include<cstdio>
#include<cmath>//用到sqrt，即开根
using namespace std;
int x[60],y[60],r[60];//读入的三个数组
double dist(int x1,int y1,int x2,int y2){//求距离的函数
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));//公式
}
int main(){
	int n,x1,y1,x2,y2,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&x[i]);
	for(int i=1;i<=n;i++) scanf("%d",&y[i]);
	for(int i=1;i<=n;i++) scanf("%d",&r[i]);
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	for(int i=1;i<=n;i++)//每个圆都搜一遍
		if((dist(x1,y1,x[i],y[i])<r[i])^(dist(x2,y2,x[i],y[i]))<r[i]) ans++;//如果两个点恰有一个在圆内，就累加上
	printf("%d",ans);//输出总和
	return 0;//华丽结束
}
```
看我这么辛苦画了这么多图，作了这么多分析，总得点个赞再走呀！

---

## 作者：zhylj (赞：59)

非常简单的入门难度题

不要想复杂了

只有点在园内才会需要穿过圆的边界，否则绕过去就可以了

判断点是否在圆内就是他到圆心的距离小于半径（在圆内

但是还有一种情况都在一个圆内

可以发现都在一个圆内和都在圆外面不用穿过

如果 (x1,y1)在圆内 xor (x2,y2)在圆内 总数+1

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    double dis(int x1,int y1,int x2,int y2)
    {
        return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
    }
    int main()
    {
        int x1,y1,x2,y2,ans=0;
        int y[105][3],n;
        cin>>n;
        for(int i=0;i<3;i++) //读入
            for(int j=0;j<n;j++)
                cin>>y[j][i];
        cin>>x1>>y1>>x2>>y2;
        for(int i=0;i<n;i++)
            if(dis(x1,y1,y[i][0],y[i][1])<y[i][2]!=dis(x2,y2,y[i][0],y[i][1])<y[i][2]) ans++; //计入总数
        cout<<ans<<endl;  //输出
        return 0;
}
```

---

## 作者：Kindom (赞：32)

**题目意思**

1.圆相离--------------------各圆之间位**内含或者外离**

2.画曲线---------------------在**圆内和圆外不需要跨边界    只有一点圆内一点圆外才会跨圆边界**

3.起点终点不在圆边界上----------**排除点在圆上**

**思路**

上面的第二点 **满足一点在圆内，一点在圆外**即可

**即点到圆心距离与圆半径比较**

贴代码：


r1 r2 是起点终点到圆心距离   R 是当前圆的半径


```cpp
	if(((r1<R)&&(r2>R))||((r2<R)&&(r1>R)))
		sum++;
```

**完整过程**



**自己码一遍后食用更佳！！！！！！！！！！！！！！**

```cpp
#include<iostream>
#include<math.h>
using namespace std;
double dis(int x1,int y1,int x2,int y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int main()
{
	int N,x1,x2,y1,y2,sum=0;
	int Y[52][4];
	double r1=0,r2=0;
	cin>>N;
	for(int j=1;j<=3;j++)
	{
		for(int i=1;i<=N;i++)
		cin>>Y[i][j];
	 } 
	 cin>>x1>>y1>>x2>>y2;
	 for(int i=1;i<=N;i++)
	 {
	 	r1=dis(x1,y1,Y[i][1],Y[i][2]);
	 	r2=dis(x2,y2,Y[i][1],Y[i][2]);
	 	if(((r1<Y[i][3])&&(r2>Y[i][3]))||((r2<Y[i][3])&&(r1>Y[i][3])))
	 	{
		sum++;
		}
	}
	 cout<<sum<<endl;
	 return 0;
}
```

---

## 作者：ljc20020730 (赞：13)

可以发现，每个圆有三种情况：

1.两点都包含。

2.两点都不包含。

3.只包含其中一点。

如果是1或2，完全没有任何影响；3只用穿过一次，所以答案就是3的个数。

用两点间距离公式判断一下即可。

距离公式：d(a,b)=sqrt((xa-xb)\*(xa-xb)+(ya-yb)\*(ya-yb))

```cpp
var x,y,r:array[1..100] of longint;
    c1,c2:array[1..100] of boolean;
    i,j,k,t,m,n,p,x1,x2,y1,y2:longint;
begin
 readln(n);
 for i:=1 to n do read(x[i]);
 for i:=1 to n do read(y[i]);
 for i:=1 to n do read(r[i]);
 readln(x1,y1,x2,y2);
 for i:=1 to n do
  begin
   if sqr(x[i]-x1)+sqr(y[i]-y1)<sqr(r[i]) then c1[i]:=true; 
//判断是否在圆里  点到圆心的距离大于半径不在，小于则在
   if sqr(x[i]-x2)+sqr(y[i]-y2)<sqr(r[i]) then c2[i]:=true;
  end;
 for i:=1 to n do if c1[i] xor c2[i] then inc(k);
 writeln(k);
end.
```

---

## 作者：Aryper (赞：10)

首先想一想什么时候曲线必定穿过圆，
我们可以列举点的三种情况：
1.两个点都在外，两点之间的连线可以避开圆。
2.两个点都在内，两点之间的连线依旧可以避开圆。
3.一个点在外，一个点在内，两点之间的连线绝对无法避开圆。（可以画一个图想一想）

所以清楚了这个，**只要判断这两个点对于每个圆是否是一个在内一个在外**。

我用的判断的方法是两点距离公式，
首先计算出第一个点与圆心的距离（dis1），再算出第二个点与圆心的距离（dis2）（注意要用实数），接下来只要判断是否dis1和dis2一个**大于圆的半径**，另一个**小于圆的半径**就可以了。（不懂的自己仔细想一想）

数据不是很大，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,xa,xb,ya,yb,flg,ans;
double dis1,dis2;
int x[55],y[55],r[55];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	scanf("%d",&x[i]);
	for(int i=1;i<=n;i++)
	scanf("%d",&y[i]);
	for(int i=1;i<=n;i++)
	scanf("%d",&r[i]);
	cin>>xa>>ya>>xb>>yb;
	for(int i=1;i<=n;i++)
	{
		flg=0;
		dis1=sqrt((xa-x[i])*(xa-x[i])+(ya-y[i])*(ya-y[i]));
		dis2=sqrt((xb-x[i])*(xb-x[i])+(yb-y[i])*(yb-y[i]));
		if(dis1<r[i])flg++;if(dis2<r[i])flg++;
		if(flg==1)ans++;
	}
	printf("%d",ans);
	return 0;
}
```
蒟蒻第一次发题解，dalao勿喷。

---

## 作者：zy小可爱ღ (赞：8)

这题思路跟芜湖2016年省赛第一题很像

一个点是否在圆内只需要判断这个点离圆心的距离是否小于这个圆的半径

集体解释看代码：：




```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,xx,x2,yy,y2,ans;//顺带一提，我定义变量y1就会显示错误，救助dalao是什么情况。。。
int x[55],y[55],r[55];//x坐标，y坐标，圆的半径
int dist(int q,int w,int e,int t,int i){//函数，比较一个点和圆心的距离是否小于半径
    return ((q-e)*(q-e)+(w-t)*(w-t))<i*i?1:2;//三目表达式，如果是，返回1，不然返回2
}
int main(){
    cin>>n;//读入n
    for(int i=1;i<=n;i++){
        cin>>x[i];//读入每个圆心的x坐标
    }
    for(int i=1;i<=n;i++){
        cin>>y[i];//读入每个圆心的y坐标
    }
    for(int i=1;i<=n;i++){
        cin>>r[i];//读入每个圆的半径
    }
    cin>>xx>>yy>>x2>>y2;
    for(int i=1;i<=n;i++){
        if(dist(xx,yy,x[i],y[i],r[i])!=dist(x2,y2,x[i],y[i],r[i])){//判断两点是否在同一个圆内
            ans++;//如果是，答案加一
        }
    }
    cout<<ans<<endl;//完美输出
    return 0;
}
最后，祝大家编程顺利！！！（。。。）
```

---

## 作者：jeremy404 (赞：4)

```python
import math
N=int(input())
X=input().split(' ')
Y=input().split(' ')
R=input().split(' ')
X=list(map(int,X))
Y=list(map(int,Y))
R=list(map(int,R))
xy=input().split()
x1=int(xy[0])
y1=int(xy[1])
x2=int(xy[2])
y2=int(xy[3])
if x2!=x1:#注意点1：分母为零时会报错，这里直接写平行于x轴
    k=(y2-y1)/(x2-x1)
    b=y2-k*x2#y=kx+b,kx-y+b=0
else:
    b=y1
    
count=0#计数初始化为0
for i in range(N):
    #分别提取x、y、r的值
    x=X[i]
    y=Y[i]
    r=R[i]
    
    #计算给出的(x1,y1)(x2,y2)是否在圆内
    #画图可以知道，点在圆外可以绕过去，count+0
    #点都在圆内不会穿过count+0
    
    a1=math.sqrt((x1-x)**2+(y1-y)**2)
    a2 = math.sqrt((x2 - x) ** 2 + (y2 - y) ** 2)
    if a1<r:
        count+=1
    if a2<r:
        count+=1
    if a2<r and a1<r:#对应都在圆内的情况，因为之前分别考虑的时候都分别加了1，所以减2
        count-=2
print(count)
```

---

## 作者：jindiao99 (赞：3)

    有了：没有两个圆有公共点，起点和终点不会落到某个圆的边界上这一保证，本题很简单，只要明白一件事，当两点都在园内或都在圆外，就不用穿过圆的边界，只有在两点一点在圆内，另一点在圆外，才要穿过圆的边界。
    判断点和圆的关系，只要判断点和圆心距离与半径的关系，这里无须用数学函数，只需判断((x-x1)*(x-x1)+(y-y1)*(y-y1))<r*r的逻辑值即可。这里采用内联函数（提高执行效率），返回一个整数值，在圆内还回1，在圆外还回-1，这样只要判断两点还回值得成绩为-1，就表示要穿过该圆。好了，这么简单，无须多解释，上代码。。。。```cpp

```cpp
#include <iostream>
using namespace std;
inline int f(int x,int y,int r,int x1,int y1) //内联函数 
{
	if(((x-x1)*(x-x1)+(y-y1)*(y-y1))<r*r)   //不用cmath 
	   return 1;      //点在圆内 
	else
	   return -1;   //点在圆外 
}
int x[55],y[55],r[55];
int main()
{
	int n,x1,y1,x2,y2,ans=0,i;
	   //下面一堆输入 
	cin>>n;
	for(i=1;i<=n;i++) cin>>x[i];
	for(i=1;i<=n;i++) cin>>y[i];
	for(i=1;i<=n;i++) cin>>r[i];
	cin>>x1>>y1>>x2>>y2;
	for(i=1;i<=n;i++) 
	{
		if(f(x[i],y[i],r[i],x1,y1)*f(x[i],y[i],r[i],x2,y2)==-1)  //一点在圆外，一点在圆内 
		     ans++;   //穿过该圆边界 
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：芙兰 (赞：3)

这道题是个水题，关键要转过来弯，穿过圆的个数只与起点和终点有关，因为是曲线，所以起点和终点之间的圆可以用曲线绕过。只需判断起点和终点被多少圆包含即可，下面附上代码。



        
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
    int a[100000],b[10000],c[10000];
    int x1,x2,y1,y2,i,sum=0,n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    for(int i=1;i<=n;i++)cin>>c[i];
    cin>>x1>>y1>>x2>>y2;
    for(int i=1;i<=n;i++){
        if((((a[i]-x1)*(a[i]-x1)+(b[i]-y1)*(b[i]-y1))<=c[i]*c[i])&&(((a[i]-x2)*(a[i]-x2)+(b[i]-y2)*(b[i]-y2))>c[i]*c[i]))sum++;
        if((((a[i]-x2)*(a[i]-x2)+(b[i]-y2)*(b[i]-y2))<=c[i]*c[i])&&(((a[i]-x1)*(a[i]-x1)+(b[i]-y1)*(b[i]-y1))>c[i]*c[i]))sum++;
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：LGG_ (赞：2)

# 结构体，简单，易理解
看见有些大佬的判断程序不好理解，有些萌新看不懂~~比如我~~

所以，自己理解打了一篇。

三种情况：
	
    1——两个点在圆內——不过圆
    2——一个点在圆內——过圆
    3——两个点都不在——不过圆
（因为曲线，可以随便绕）。
在没在圆內就是点到圆心距离比不比半径小

点到圆心距离公式
```c
int tt(int x1,int x2,int y1,int y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
```
~~可以自己推~~

核心

	```c
if(((tt(a1,a[i].x,b1,a[i].y))<a[i].r)&&((tt(a2,a[i].x,b2,a[i].y))<a[i].r))continue;
		else if(((tt(a1,a[i].x,b1,a[i].y))<a[i].r)||((tt(a2,a[i].x,b2,a[i].y))<a[i].r))ans++;
```
易理解的判断

```c
#include<iostream>
#include<cmath>
using namespace std;
struct uu{
	int x,y,r;
}a[1000001];
int a1,a2,b1,b2;
int n;
int ans;
int tt(int x1,int x2,int y1,int y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x;
	for(int i=1;i<=n;i++)cin>>a[i].y;
	for(int i=1;i<=n;i++)cin>>a[i].r;
	cin>>a1>>b1>>a2>>b2;//输入
	for(int i=1;i<=n;i++){
		if(((tt(a1,a[i].x,b1,a[i].y))<a[i].r)&&((tt(a2,a[i].x,b2,a[i].y))<a[i].r))continue;//两个点的情况，直接跳过
		else if(((tt(a1,a[i].x,b1,a[i].y))<a[i].r)||((tt(a2,a[i].x,b2,a[i].y))<a[i].r))ans++;//一种点的情况。
	}//（都不在圆內的压根不会判断）
	cout<<ans;
	return 0;//好习惯
}
```



---

## 作者：cheeseYang (赞：2)

这里是一波数学思路，清晰明了

首先两个圆相离分为内离和外离，这是本题一个重点。判断点与圆的关系，就要看点与圆心的距离，大于圆的半径则在圆外，小于则在圆内，等于在圆上（本题不考虑）。其次，如果给定的两个点如果在同一个圆内，就要进行特殊处理，具体在代码中解释。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
double n,x[55],y[55],r[55];
double x1,x2,y3,y2,time;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>x[i];
    for(int i=1;i<=n;i++)
        cin>>y[i];
    for(int i=1;i<=n;i++)
        cin>>r[i];    
    cin>>x1>>y3>>x2>>y2;
    for(int i=1;i<=n;i++){
    if(sqrt((x1-x[i])*(x1-x[i])+(y3-y[i])*(y3-y[i]))<r[i]&&sqrt((x2-x[i])*(x2-x[i])+(y2-y[i])*(y2-y[i]))>r[i])time++;    （判断距离，要两个圆同时满足不在同一圆内次数才++)
    if(sqrt((x2-x[i])*(x2-x[i])+(y2-y[i])*(y2-y[i]))<r[i]&&sqrt((x1-x[i])*(x1-x[i])+(y3-y[i])*(y3-y[i]))>r[i])time++;     (同上，如果没有这一句会漏解）
    }
    cout<<time;
    return 0;
}
```

---

## 作者：Mogician (赞：2)

一道大水题，if 点A在圆i里 xor 点B在圆i里 那么就inc答案

```cpp
var x,y,r:array[1..100] of longint;
    c1,c2:array[1..100] of boolean;
    i,j,k,t,m,n,p,x1,x2,y1,y2:longint;
begin
 assign(input,'circle.in');
 reset(input);
 assign(output,'circle.out');
 rewrite(output);//关联文件忽略掉
 readln(n);
 for i:=1 to n do read(x[i]);
 for i:=1 to n do read(y[i]);
 for i:=1 to n do read(r[i]);
 readln(x1,y1,x2,y2);
 for i:=1 to n do
  begin
   if sqr(x[i]-x1)+sqr(y[i]-y1)<sqr(r[i]) then c1[i]:=true; //判断是否在圆里  点到圆心的距离大于半径不在，小于则在
   if sqr(x[i]-x2)+sqr(y[i]-y2)<sqr(r[i]) then c2[i]:=true;
  end;
 for i:=1 to n do if c1[i] xor c2[i] then inc(k);
 writeln(k);
 close(output);
end.
```

---

## 作者：shengmingkexue (赞：2)

可以发现，每个圆有三种情况：

1.两点都包含。

2.两点都不包含。

3.只包含其中一点。

如果是1或2，完全没有任何影响；3只用穿过一次，所以答案就是3的个数。

用两点间距离公式判断一下即可。

距离公式：d(a,b)=sqrt((xa-xb)\*(xa-xb)+(ya-yb)\*(ya-yb))


---

## 作者：HDawn (赞：1)

## 看清楚——》曲线。
曲线什么意思呢？

就是只要是两个点都在圈外，从一点就可以拐着弯到另一点。不会和圆有接触。
两点都在圈内也是这样。

只有一种可能会有交点——一个点在圈内，一个点在圈外。

这样就好做多了

### 代码如下，有详解
```cpp
#include<bits/stdc++.h>
using namespace std;

double  x1,k,x2,y2;//两点位置，不能用y1,有个函数为y1()。
int ans=0;//答案。
//函数判断是否有一个点在圈内一个点在圈外。
void judge(int x,int y,double r){//x,y圆心，r半径。
	double a=sqrt((x-x1)*(x-x1)+(y-k)*(y-k));//圆心到两点的距离。
	double b=sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2));
	if((a<r&&b>r)||(a>r&&b<r)){//
		ans++;
	}
}
int main()
{
	int n;//圆个数。
	cin>>n;
	int a[n],b[n],c[n];//圆心和半径。
	
	for(int i=0;i<n;i++)
		scanf("%d",&a[i]);//scanf输入快。
	for(int i=0;i<n;i++)
		scanf("%d",&b[i]);
	for(int i=0;i<n;i++)
		scanf("%d",&c[i]);
		
	cin>>x1>>k>>x2>>y2;
	
	for(int i=0;i<n;i++){
		judge(a[i],b[i],c[i]);//每个圆都调用函数判断。
	} 
	
	cout<<ans;//输出答案。
	return 0;
} 
```
结束。



---


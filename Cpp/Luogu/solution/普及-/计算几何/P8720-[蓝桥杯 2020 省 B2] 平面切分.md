# [蓝桥杯 2020 省 B2] 平面切分

## 题目描述

平面上有 $N$ 条直线, 其中第 $i$ 条直线是 $y=A_{i} \cdot x+B_{i}$ 。

请计算这些直线将平面分成了几个部分。


## 说明/提示

对于 $50 \%$ 的评测用例, $1 \leq N \leq 4,-10 \leq A_{i}, B_{i} \leq 10$。

对于所有评测用例, $1 \leq N \leq 1000,-10^5 \leq A_{i}, B_{i} \leq 10^5$。

蓝桥杯 2020 第二轮省赛 B 组 I 题

## 样例 #1

### 输入

```
3
1 1
2 2
3 3```

### 输出

```
6```

# 题解

## 作者：liangbob (赞：24)

### P8720 题解

#### 思路分析

小学几何题。

几何题没有图，我不是很满意。

我们先来证明一个结论：设平面在加入某不重合于已有线后与原已有线交点数为 $x$，则该平面会增加 $x + 1$ 个部分。

证明如下：

这个线产生 $x$ 个交点，我们把它单独拎出来看一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/3nbnoyww.png)

可以看到，黑线上被红色点截，会出现 $x + 1$ 段线段。

而这些线段，经过的刚好就是一个部分，刚好把这个部分从一个变成了两个，部份数加了一。

每条线段都一样，所以会增加 $x+1$ 个部分。

证毕。

接着，我们再来证明一个结论：

直线 $y=k_1x+b_1$ 与 $y = k_2x+b_2$ 的交点横坐标为 $\dfrac{b_2-b_1}{k_1-k_2}$，纵坐标为 $k_1 \cdot \dfrac{b_2-b_1}{k_1-k_2} +b_2$。

话不多说，先上图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tfrgrnm3.png)

中间的小点就是交点。

可以看到，这个交点 $x$ 轴与 $y$ 轴是相同的。所以可以联立两个式子为方程组，得：

$$\begin{cases}y=k_1x+b_1\ldots\ldots①\\y = k_2x+b_2\ldots\ldots②\end{cases}$$

将 $② - ①$ 得：

$$0 = (k_2-k_1)x+(b_2 - b_1)$$

$$(b_1 - b_2) = (k_2-k_1)x$$

$$x=\dfrac{b_2-b_1}{k_1-k_2}$$

将 $x=\dfrac{b_2-b_1}{k_1-k_2}$ 代回原式：

$$y = k_1 \cdot \dfrac{b_2-b_1}{k_1-k_2} +b_1$$

证毕。

有这两个结论后，我们就可以思考一下方法了：

1. 直线去重。这是显然的，毕竟重复的会多算。
2. 枚举每一条线，计算其与之前线的交点。注意交点也要去重。注意：如果枚举到两条线斜率一致，就要过掉。因为它们没有交点。
3. 答案加上交点数加一，回到步骤二。

依照步骤实现即可。去重可以用 set。然后注意结果加一（平面初始就是一部分）。

#### 代码

```cpp
#include <iostream>
#include <map>
#include <set>
#define IL inline
using namespace std;
const int N = 1e5 + 10;

struct node
{
    long double k, b;
}a[N];

int main()
{
    int n;
    cin >> n;
    int m = 0;
    set<pair<long double, long double> > p;
    for(int i = 1;i <= n;i++)
    {
        long double x, y;
        cin >> x >> y; 
        p.insert({x, y});//set 去重。 
    }
    for(auto i = p.begin();i != p.end();i++) //遍历并存入结构体数组。 
    {
        a[++m] = {(*i).first, (*i).second};
    }
    int ans = 0;
	
    for(int i = 1;i <= m;i++)
    {
		set <pair<long double,long double> > o;
        for(int j = 1;j < i;j++)
        {
            long double k1 = a[i].k;
            long double k2 = a[j].k;
            long double b1 = a[i].b;
            long double b2 = a[j].b;
            if(k1 == k2) continue; //斜率一致，平行，过掉。 
            long double x1 = (b2 - b1)  / (k1 - k2);
            long double y1 = k1 * x1 + b1;
            //根据公式计算交点。
            o.insert({x1, y1});
            //加入 set 去重。
        }
        ans += (o.size() + 1);
    }
    cout << ans + 1 << endl; //初始有一部分，要加一。
    return 0;
}
```



---

## 作者：fengziyi (赞：13)

### 前言
建议本题评黄，因为需要较强的数学能力。  
如果格式炸了去[这里](https://www.cnblogs.com/YttriumWillow/p/17154550.html)看哦。
### 题意
给出 $N$ 条直线的解析式 $y=kx+b$，求出这些直线把平面分成了几部分。  
### 思路  
看到这道题我们会梦回小学五年级在某场考试或某张毒瘤数学试卷里做到的[题目](https://www.luogu.com.cn/paste/s6fcgvoi)（本来在这里有一个好康的美化，但是管理大大告诫我不要用，所以还是点[链接](https://www.luogu.com.cn/paste/s6fcgvoi)吧）：  

> 已知 1 条直线可以把平面最多分成两部分，2 条直线可以把平面最多分成 4 部分，3 条最多可以分成 7 部分，请问 4、5 条直线最多可以把平面分成几部分？
 

回忆一下我们当时是如何做出这样的题目的？找规律？画图？~~蒙答案？~~  

或者我们可以重复这样的步骤。  

 - 当没有任何直线时，显然平面只有一部分。  
 - 当有 $1$ 条直线时，平面有 $2$ 个部分。  
 - 当有 $2$ 条直线时，第 $2$ 条直线交第 $1$ 条于一个点，所以**增加了 $2$ 个部分**，共 $4$ 个部分。  
 - 当有 $3$ 条直线时，第 $3$ 条直线交前两条各于一个点，所以又**增加了 $3$ 个部分**，共 $7$ 个部分 *（假设没有三线共点或平行）*。  
 - 当有 $4$ 条时，**增加 $3$ 个交点，$4$ 个部分**，共 $11$ 个部分。  
 - 当有 $5$ 条时，**增加 $4$ 个交点，$5$ 个部分**，共 $16$ 个部分。

以上推断均保证没有三线共点或平行的情况。  
仔细阅读加粗部分显然可以发现，每增加 $n$ 个交点，会多出 $n+1$ 个部分。  
我们就成功的把求几部分的问题转化成了求交点的问题。

接着考虑 **三点共线** 和 **平行** 的情况。  

对于**三点共线**，若一条直线于另两条直线的交点交在一起 *（注意我的表述方式）*，因为这一点之前已经分出了它所对应的部分，所以不需要再次统计。  
对于**一对直线平行**，则仅对这两条直线来说，它们没有任何交点，因此这对直线不需要计算交点。  

综上所述，我们只要模拟以上过程，不断添加一条一条直线并且计算交点个数即可。

### 代码  
```cpp
#include <iostream>
#include <set>
#include <vector>

#define i64 long long
#define reg register
#define qwq puts("fzy qwq ~");
#define pb push_back
#define Line pair<double, double>
#define kk first
#define bb second

using namespace std;

int n, tmp, ans = 1;
double xk, xb, k1, k2, b1, b2;
set<Line> l;
vector<int> k, b;

void init()
{
    for (reg int i = 1; i <= n; ++i)
    {
        scanf("%lf%lf", &xk, &xb);
        l.insert(make_pair(xk, xb)); // 使用 set 去重并顺手排序
    }
    for (reg auto x : l)
        k.pb(x.kk), b.pb(x.bb);      // 将直线放回 vector O(1) 访问降低常数
}

int main()
{
    scanf("%d", &n);
    init();
    
    Line p;
    for (reg int i = 0; i < (int)k.size(); ++i) //枚举每一条直线
    {
        set<Line> pos; 							// 交点的集合
        for (reg int j = i - 1; j >= 0; --j)
        {
            k1 = k[i], b1 = b[i],
            k2 = k[j], b2 = b[j];
            if (k1 == k2) continue;				// 平行，直接计算下一条直线
            p.kk = (b2 - b1) / (k1 - k2); 		// 求得交点
            p.bb = k1 * ((b2 - b1) / (k1 - k2)) + b1; // 
            pos.insert(p);
        }
        ans += pos.size() + 1; 					// 添加新分出的部分
    }
    printf("%d\n", ans);
    return 0;
}
```
由于使用了 `STL` 不吸氧达到了 `850ms` [here](https://www.luogu.com.cn/record/102965658)。  
开启 `O2` 优化为 `205ms` 成为目前最优解 [here](https://www.luogu.com.cn/record/102965861)。

---

## 作者：small_john (赞：6)

## 分析

一道比较基础的计算几何的问题。

分两种情况讨论：

1. 若新加入的直线不与平面中的任何一条直线重合，设该直线与平面中已经存在的直线的**不同的**交点数为 $s$，那么部分数增加 $s+1$；

2. 否则，部分数不变。

注：可用集合来维护交点的不同。

## 代码

```cpp
#include<bits/stdc++.h>
#define PDD pair<long double,long double> 
using namespace std;
const int N = 1e3+5;
int n,ans;
long double a[N],b[N];
bool vis[N];//标记第i条直线是否与其他直线重合
int main()
{
	cin>>n;
	for(int i = 1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
		set<PDD> s;//使用pair记录横坐标、纵坐标 
		s.clear();
		for (int j = 1;j<i;j++)
		{
			if(vis[j])//与前面的直线重合，跳过 
				continue;
			if(a[i]==a[j]&&b[i]==b[j])
			{
				vis[i] = 1;//标记 
				break;
			}
			if(a[i]==a[j])//斜率一样，i平行与j，无交点
				continue;
			s.insert({(b[i]-b[j])/(a[j]-a[i]),(a[j]*b[i]-a[i]*b[j])/(a[j]-a[i])});//算交点 
		}
		if(!vis[i])//当第i条直线不与前面的直线重合时才统计 
			ans+=s.size()+1;
	}
	cout<<ans+1;//初始平面有一部分 
	return 0;
}
```

---

## 作者：_zhx (赞：2)

# P8720 [蓝桥杯 2020 省 B2] 平面切分 

## 做法

首先，我们要知道这件事：直线要去重,因为重复的会多算。所以就得有一个特判。

我们可以枚举每一条线，计算这条线与前面一条线的交点，但这也要注意：如果枚举到两条线斜率一致，就要交结束这次循环。因为它们完全重合。然后把交点的个数加一。内循环结束后，交点有几个，就把答案变量加上交点的数量再加一。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct node{long double b,c;}a[N];
long double x,y;int n,m=1,d=1;//d=1是因为平面也算一部分
set<pair<long double, long double> >p,s;
/*
set自动去重
如果是 
1 1
2 2
2 2
1 1
set中只会有 
1 1
2 2
*/
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {    
        cin>>x>>y; 
        p.insert({x,y}); 
    }
    for(auto i=p.begin();i!=p.end();i++) a[m++]={(*i).first,(*i).second};//把set中的数存入结构体
    for(int i=1;i<m;i++)
    {
    	s.clear();//要清零，我被坑了几次
        for(int j=1;j<i;j++)
        {
            if(a[i].b==a[j].b) continue; //平行，continue掉
            s.insert({(a[j].c-a[i].c)/(a[i].b-a[j].b),a[i].b*((a[j].c-a[i].c)/(a[i].b-a[j].b))+a[i].c});//插入交点
        }
        d+=s.size()+1;//统计答案
    }
    cout<<d;
    return 0;
}
```

---

## 作者：DANIEL_x_ (赞：2)

## 做法：

1、去重。

2、按照顺序每次新增一条直线，新增部分的个数 $=$ 这条线与前面的线的交点个数 $+ 1$。

时间复杂度：$n^2 \log n$。

## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
set<pair<long double,long double> > se;
const int N = 1005;
long double a[N],b[N];
set<pair<long double,long double> > s;
set<pair<long double,long double> >::iterator it;
int main()
{
	int n,i,j,x,y,ans=2;
	cin>>n;
	for(i=0;i<n;i++)
		cin>>x>>y,s.insert(make_pair(x,y));
	n = s.size();
	for(i=0,it=s.begin();it!=s.end();it++,i++)
		a[i]=(*it).first,b[i]=(*it).second;
	set<pair<long double,long double> > se;
	for(i=1;i<n;i++)
	{
		for(j=i-1;j>=0;j--)
		{
			if(a[i]==a[j]) continue;
			long double x=(b[j]-b[i])/(a[i]-a[j]),y=(a[j]*b[i]-a[i]*b[j])/(a[j]-a[i]);
			se.insert(make_pair(x,y));
		}
		int n2=se.size();
		ans+=(n2+1);
		se.clear();
	}
	cout<<ans<<"\n";
} 

```


---

## 作者：我梦见一片焦土 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P8720)

------------
# 思路：
我们可以重复这样的步骤：

1. 当没有任何直线时，显然平面只有一部分。
2. 当有 $1$ 条直线时，平面有 $2$ 个部分。
3. 当有 $2$ 条直线时，第 $2$ 条直线交第 $1$ 条于一个点，所以 **增加了 $2$ 个部分**，共 $4$ 个部分。
4. 当有 $3$ 条直线时，第 $3$ 条直线交前两条各于一个点，所以又 **增加了 $3$ 个部分**，共 $7$ 个部分 （假设没有三线共点或平行）。
5. 当有 $4$ 条时，**增加 $3$ 个交点，$4$ 个部分**，共 $11$ 个部分。
6. 当有 $5$ 条时，**增加 $4$ 个交点，$5$ 个部分**，共 $16$ 个部分。

以上推断均保证没有三线共点或平行的情况。

仔细阅读加粗部分显然可以发现，每增加 $n$ 个交点，会多出 $n + 1$ 个部分。

我们就成功的把求几部分的问题转化成了求交点的问题。

接着考虑 **三点共线** 和 **平行** 的情况。

对于 **三点共线**，若一条直线于另两条直线的交点交在一起 （注意我的表述方式），因为这一点之前已经分出了它所对应的部分，所以不需要再次统计。

对于 **一对直线平行**，则仅对这两条直线来说，它们没有任何交点，因此这对直线不需要计算交点。

综上所述，我们只要模拟以上过程，不断添加一条一条直线并且计算交点个数即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s=1;
double a,b,c,d,e,f;
set<pair<double, double>>sp1;
vector<int>v1,v2;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a>>b;
        sp1.insert(make_pair(a,b));
    }
    for(auto x:sp1){
        v1.push_back(x.first);
		v2.push_back(x.second);
	}
    pair<double, double>p;
    for(int i=0;i<(int)v1.size();i++){
        set<pair<double,double>>sp2;
        for(int j=i-1;j>=0;j--){
            c=v1[i];
			e=v2[i],
            d=v1[j];
			f=v2[j];
            if(c==d){
            	continue;
			}	
            p.first=(f-e)/(c-d); 
            p.second=c*((f-e)/(c-d))+e; 
            sp2.insert(p);
        }
        s+=sp2.size()+1;
    }
    cout<<s<<endl;
    return 0;
}
```
完结撒花~

---

## 作者：Chis725 (赞：1)

## 题目描述

给出 $n$ 条直线，求平面被分成了多少个部分。

## 思路

这道题比较考验选手的数学几何能力。首先我们要去掉重边，然后我们经过推算后可以得出平面被分成的部分的数量等于交点的数量加上去掉重边后边的数量再加一。我们只需要定义一个集合，把每条边和其他边的交点的横坐标和纵坐标放入集合，最后把每次集合的大小全部加起来就能得出交点的数量。

## 代码献上

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1001;
struct node{
    int b,k;
}a[N];
int n,p[N],ans=1;
int main(){
    cin>>n;
    ans+=n;//先假设无重边
    for(int i=1;i<=n;i++){
        cin>>a[i].k>>a[i].b;
        for(int j=1;j<i;j++){
            if(a[i].b==a[j].b&&a[i].k==a[j].k){//判重边
                p[i]=1;
                ans--;//重边将边的个数减一
                break;
            }
        }
        if(p[i])continue;
        set<pair<long double,long double> > s;
        for(int j=1;j<i;j++){
            if(p[j]||a[i].k==a[j].k)continue;//重边或者平行
            long double x=(a[j].b-a[i].b)*1.0/(a[i].k-a[j].k);//算交点
            long double y=a[i].k*x+a[i].b;
            s.insert({x,y});
        }
        ans+=s.size();//求出交点的个数
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：noi2077 (赞：0)

先将所有的直线去重。考虑每次加入一条直线，若这条直线与之前的直线共形成 $c$ 个不同的交点，则这条直线一定穿过了原来的 $c+1$ 块区域，因此这 $c+1$ 块都会被分割成两部分，答案增加 $c+1$。

对于两条直线 $l_1:y=k_1x+b_1,~l_2:y=k_2x+b_2$ 可以通过联立方程组解得交点为

$$
\begin{cases}
x=\frac{b_2-b_1}{k_1-k_2}\\
y=\frac{k_1b_2-k_2b_1}{k_1-k_2}
\end{cases}
$$

我们可以用一个 `set` 或者 `unordered_set` 维护所有交点，通过 `st.size()` 就能得到不同的交点个数。

code:

```cpp
#include<iostream>
#include<set>
using namespace std;
typedef long double ld;
set<pair<ld, ld>> se;
const int N = 1005;
ld a[N], b[N];
set<pair<ld, ld>> s;
int main()
{
    int n, x, y, ans = 2;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> x >> y, s.insert(make_pair(x, y));
    n = 0;
    for (auto [x, y]: s) {
        a[n] = x; b[n++] = y;
    }
    set<pair<ld, ld>> st;
    for (int i = 1; i < n; i++) {
        for (int j = i - 1; j >= 0; j--) {
            if (a[i] == a[j]) continue;
            ld x = (b[j] - b[i]) / (a[i] - a[j]), y = (a[j] * b[i] - a[i] * b[j]) / (a[j] - a[i]);
            st.insert(make_pair(x, y));
        }
        ans += st.size()+1;
        st.clear();
    }
    cout << ans;
}
```

---


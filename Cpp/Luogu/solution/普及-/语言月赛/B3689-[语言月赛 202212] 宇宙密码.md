# [语言月赛 202212] 宇宙密码

## 题目描述

经历十九年的探索，人们终于找到了宇宙中的那份瑰宝。

这份瑰宝被装在一个密码箱里，按照情报，密码应为一串长度为 $n$ 的数字 $a$。

人们满怀希望地输入了密码，但是密码箱没有任何反应。

这时人们意识到，在十九年中，由于宇宙射线的侵蚀，密码箱的密码发生了改变。

现在人们知道，能够打开密码箱的新密码是由原密码 $a$ 变化而来。具体的，新密码相比原密码变化了 $t$ 位数字，其中 $t$ 满足 $0 \leq t \leq k$，且对于变化的数字位，变化后的数字是在该位置原数字的基础上增加或减小 $1$ 得到的数字。特别的，如果原数字是 $0$，在原数字基础上减少 $1$ 得到的数字是 $9$；如果原数字是 $9$，在原数字基础上增加 $1$ 得到的数字是 $0$。

现在人们知道了 $n, a, k$，想知道经过宇宙射线侵蚀后，所有可能打开密码箱的密码。

人类将重任交到了你身上，请你帮助人类解决这个问题。你需要由小到大输出所有可能的密码，每个一行。

特别的，有一些密码可能存在前导 $0$。为了方便操作，这时你**不必也不应**将这些前导 $0$ 一并输出。

人类感谢你。

## 说明/提示

### 样例 1 解释

原密码为 $014$，允许至多 $1$ 位有变化。

所有密码情况如下：

| 变化位数和位置 | 可能的结果 |
| :-: | :-: |
| $0$ 位 | $014$ |
| $1$ 位，从左向右第 $1$ 位 | $114, 914$ |
| $1$ 位，从左向右第 $2$ 位 | $024, 004$ |
| $1$ 位，从左向右第 $3$ 位 | $013, 015$ |

共 $7$ 个可能的密码，按从小到大排序输出即可。

### 数据规模与约定

- 对于前 $10\%$ 的数据，保证 $n = k = 1$。
- 对于前 $40\%$ 的数据，保证 $k \leq 1$。
- 对于另外 $10\%$ 的数据，保证 $k = n$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 6$，$0 \leq a < 10 ^ n$，$0 \leq k \leq n$，保证输入数据无前导 $0$。

请注意，输出数据中**不应**存在前导 $0$。

## 样例 #1

### 输入

```
3 14 1```

### 输出

```
4
13
14
15
24
114
914```

# 题解

## 作者：Maxmilite (赞：14)

# B3689 [语言月赛202212] 宇宙密码 题解

## Source & Knowledge

2022 年 12 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 文字题解

### 题目大意

给定整数 $a$，求 $a$ 的至多 $k$ 位进行「变化」后的所能形成的所有可能数字。

某一位发生「变化」，指这一位的数字 $\pm 1$。其中 $0$ 和 $9$ 需要特殊处理，详细内容可以参照原题面。

### 解析

提供一种比较简单的做法。

我们注意到数字至多只可能有 $6$ 位。也就是说，最后的答案只可能在 $000000 \sim 999999$ 中取得，至多有 $10 ^ 6$ 个可能的答案。又可以发现，我们直接从 $a$ 推到最后的答案较为困难，可能使用深度优先搜索等超纲算法。然而，我们验证某一个数 $b$ 是否是最后的答案是比较简单的，只需要进行一定的判断即可。

所以，我们可以逐个枚举 $0 \sim 10 ^ n - 1$，并逐个判断及输出即可。

下面介绍一下判断流程。

我们不妨设当前枚举到的整数是 $x$。对于判断，我们可以逐个取 $x$ 的十进制位与原数字 $a$ 的对应位进行比较，并取一个初始化为 $0$ 变量 $c$ 记录「变化」的位的数量。

比较分为以下情况：

- 如果 $x$ 的当前位与 $a$ 的对应位相同，则不做处理。
- 如果 $x$ 的当前位与 $a$ 的对应位的差值的绝对值为 $1$ 或 $9$，则上述的变量 $c$ 增加 $1$。
- 如果 $x$ 的当前位与 $a$ 的对应位的差值绝对值 $\geq 2$ 且 $\neq 9$，则直接判断 $x$ 不符合要求。

如果在上述的枚举过程中没有出现「直接判断为不符合要求」的情况，则将 $c$ 与 $k$ 比较。如果 $c \leq k$，则 $x$ 符合要求，反之不符合要求。

以下是判断流程的代码，使用 `check` 函数实现：

```cpp
int check(int x) {
	int cnt = 0, var = a;
	for (int i = 1; i <= n; ++i) {
		if (abs((var % 10) - (x % 10)) == 1 || abs((var % 10) - (x % 10)) == 9) {
			++cnt;
		} else if (abs((var % 10) - (x % 10)) >= 2) {
			return 0;
		}
		var /= 10, x /= 10;
	}
	return cnt <= k;
}
```

枚举 $0 \sim 10 ^ n - 1$ 的代码如下：

```cpp
cin >> n >> a >> k;
int limit = pow(10, n);
for (int i = 0; i < limit; ++i) {
	if (check(i)) {
		cout << i << endl;
	}
}
return 0;
```

由于枚举顺序，自然而然我们保证了从小到大输出。

可以看到，整体的代码量是较小的。

## 视频题解

**完整代码请在视频中查看。**

![](bilibili:BV1id4y1e7yJ?page=6)

---


# [语言月赛202301] 新年快乐

## 题目背景

要过春节了，扶苏收到了她的新年礼物：一个崭新的字符串。

## 题目描述

扶苏收到的字符串是一个只含小写字母的字符串 $s$。

对于一个长度为 $x$ 的只含小写字母的字符串 $t$，我们定义 $t$ 的『上一个字符串』是：将所有的长度为 $x$ 且仅含小写字母的字符串按字典序排列后，恰好排在 $t$ 之前一个的字符串。

例如，字符串 $\texttt{bcd}$ 的『上一个字符串』是 $\texttt{bcc}$，而 $\texttt{aaa}$ 的『上一个字符串』不存在。

现在，扶苏有 $q$ 次询问，每次询问给出一个区间 $[l, r]$，查询：$s$ 的第 $l$ 个到第 $r$ 个字符组成的字符串的『上一个字符串』是否在 $s$ 中出现？

如果查询区间对应的字符串不存在『上一个字符串』，也算作『上一个字符串』没有在 $s$ 中出现。

## 说明/提示

### 数据规模与约定

以下以 $|s|$ 表示输入字符串 $s$ 的长度。

| 测试点编号 | $\mid s \mid \leq$ | $q=$ | 特殊约定 |
| :-: | :-: | :-: | :-: |
| 1 | $1$ | $1$ | 无 |
| 2 | $20$ | $7$ | A,B |
| 3 | $20$ | $8$ | B |
| 4 | $20$ | $9$ | A |
| 5 | $400$ | $198$ | B |
| 6 | $400$ | $199$ | A |
| 7 | $400$ | $199$ | A |
| 8 | $400$ | $200$ | 无 |
| 9 | $400$ | $200$ | 无 |
| 10 | $400$ | $200$ | 无 |

特殊约定 A：保证查询的字符串的『上一个字符串』在 $s$ 中出现。  
特殊约定 B：保证查询的区间满足 $l = r$。

对全部的测试点，保证 $1 \leq |s| \leq 400$，$1 \leq q \leq 200$，$1 \leq l \leq r \leq |s|$，$s$ 中仅包含小写英文字母。

### 提示

你可以通过 $q$ 的末位数字来判定测试点所属的特殊约定信息。


## 样例 #1

### 输入

```
bcdbccaacbzz
5
1 3
5 8
1 1
11 12
7 7```

### 输出

```
bcc
Happy New Year!
cbzz
Happy New Year!
a
Happy New Year!
zy
Happy Chinese New Year!
NULL
Happy Chinese New Year!```

# 题解

## 作者：Maxmilite (赞：7)

# [语言月赛202301] 新年快乐 题解

## Source & Knowledge

2023 年 1 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 文字题解

### 题目大意

给定一个只含小写字母的字符串 $s$。

给出 $q$ 组询问，每次截取 $s$ 的第 $l$ 个字符到第 $r$ 个字符构成新的字符串 $t$。询问 $t$ 的「上一个字符串」是否存在于 $s$ 中。

### 解析

C++ 的 `string` 类提供了很多很有用的功能。这里我们会用到其提供的 `substr()` 与 `find()` 两个函数。

对于一个 `string` 类型变量 $s$，`s.substr(l, r)` 返回值可被转换为 `string` 类，返回内容为以 $s$ 的第 $l + 1$ 个字符为起点，截取其及其之后共计 $r$ 个字符构成的新的字符串。

对于两个 `string` 类型变量 $s, t$，`s.find(t)` 代表查找 $t$ 在 $s$ 中的位置。如果可以找到，则返回 $t$ 第一次在 $s$ 中出现的位置的起始下标。如果无法找到，则返回 `npos`。大多数情况下 `npos` 的值为 `-1`。

需要注意的是，`find()` 函数近似于暴力匹配，时间复杂度为平方级别。但是本题数据规模相对较小，这种方式可以通过。

下面将这两个函数运用到题目中。

对于每次询问，我们调用 `s.substr(l - 1, r - l + 1)` 得到子字符串 $t$。这里截取了以 $s$ 的第 $(l - 1) + 1$ 个字符为起点，长度为 $r - l + 1$ 的字符串，不难发现为 $s$ 的第 $l$ 个字符到第 $r$ 个字符。

我们注意到，$t$ 的「上一个字符串」是不存在的，**当且仅当** $t$ 全部由小写字母 $\texttt{a}$ 构成。

> 详细说明：假设 $t$ 中有一个位置的字母不是小写字母 $\texttt{a}$，那么在取 $t$ 的「上一个字符串」时，我们一定可以找到一个位置使其变为其的**上一个字母**，在这个位置之后进行一定的修改便可找到 $t$ 的上一个字符串。如果 $t$ 全部由小写字母 $\texttt{a}$ 构成，那么我们找不到任何一个位置可以变为**上一个字母**。由此，我们便无法找到「上一个字符串」。

因此，我们首先需要判断 $t$ 中是否全部为小写字母 $\texttt{a}$。如果是，则输出 `NULL\nHappy Chinese New Year!\n`。

核心代码如下：

```cpp
int flag = 1;
for (int i = 0; i < t.length(); ++i) {
    if (t[i] != 'a') {
        flag = 0;
        break;
    }
}
if (flag) {
    cout << "NULL\nHappy Chinese New Year!\n";
}
```

确认 $t$ 中不全为小写字母 $\texttt{a}$ 后，我们从后向前进行寻找直到找到第一个不为 $\texttt{a}$ 的位置。此时，该位置之后全部为 $\texttt{a}$。因此，我们将其自身修改为上一个字符，其之后全部赋值为小写字母 $\texttt{z}$ 即可。

核心代码如下：

```cpp
for (int i = t.length() - 1; i >= 0; --i)
    if (t[i] == 'a') {
        t[i] = 'z';
    } else {
        --t[i];
        break;
    }
```

最后，我们调用 `s.find(t)`，判断返回值是否为 `npos` 即 `-1`，进行对应的输出即可。

核心代码如下：

```cpp
cout << t << endl;
if (s.find(t) != -1) {
    cout << "Happy New Year!\n";
} else {
    cout << "Happy Chinese New Year!\n";
}
```

## 视频题解

**完整代码请在视频中查看。**

![](bilibili:BV1Es4y1t7wu?page=8)

---


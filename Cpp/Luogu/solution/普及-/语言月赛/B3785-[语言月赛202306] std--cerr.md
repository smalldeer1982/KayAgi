# [语言月赛202306] std::cerr

## 题目背景

这是一道 **hack 题**。在本题目中，你将得到两个问题和两个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于这一问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

每道题占 $50$ 分，本题共 $100$ 分。

---
**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言。**

## 题目描述

以下给出两个问题的题目描述：

#### 问题 1

给出整数 $a, b,c$，求 $\left\lceil\dfrac {a}{b - c} \right\rceil$ 的值，其中 $\left\lceil x \right\rceil$ 表示不小于 $x$ 的最小整数。

#### 问题 2

`std::cerr` 是一个输出到**标准错误流**的输出工具。如果你运行如下程序：

```cpp
#include <iostream>
int main() {
  std::cerr << "Hello Luogu!" << std::endl;
}
```

你会发现有 $\texttt{Hello Luogu!}$ 被打印在了命令行 /cmd 中；但是，如果你在 `main` 函数开头加入 `freopen("text.txt", "w", stdout)`，再运行这个程序，然后打开 `text.txt`，会发现文件是空的，而 $\texttt{Hello Luogu!}$ 仍然被打印到了命令行 /cmd 中。

由此，`std::cerr` 在算法竞赛中有了一个重要应用：使用 `std::cerr` 输出中间变量，变量会被打印到屏幕上，但却不会被打印到输出文件/标准输出中。同时，`std::cerr` 有**刷新缓冲区**的作用。以往关闭流同步代码一旦产生 Runtime Error，在这之前被打印到 stdout 的内容如果仍在缓冲区，则不会被输出，而使用 `std::cerr` 则不会有这个问题，因为每次完成输出后都会将缓冲区内容直接刷新到标准错误流中。

例如，你可以尝试在本地运行如下代码：
```cpp
#include <iostream>

int main() {
    std::ios::sync_with_stdio(false);
    std::cout << "Hello Luogu!\n";
    int x = *((int*)0);
}
```
对于大多数机器，屏幕上什么都不会打印，应用程序就会异常终止，这种情况是不利于调试的，因为无法二分出导致程序终止语句是哪一条。但是，如果你将上文中的 `std::cout` 换成 `std::cerr` 再尝试运行这一程序，就会发现在程序异常终止前，$\texttt{Hello Luogu!}$ 被打印到了屏幕上。需要注意的是，刷新缓冲区是一件速度很慢的事情，如果刷新次数太多，会导致程序超时。

在刚结束的 ICPC 山东省赛中，扶苏试图使用 `std::cerr` 来完成对 K 题的调试，但是在四小时 59 分提交的代码中，扶苏本已经写出了正确的代码，但却忘记了删除 `std::cerr` 的调试语句，虽然这**不会**导致她向选手输出中输出额外信息，但因为刷新缓冲区次数过多，她本次提交被判定为 `TIME LIMIT`，与省赛冠军失之交臂。

![](https://picx.zhimg.com/v2-e4ea329a8ca6efbe71a5b97c2e6aeb25_r.jpg?source=1940ef5c)

![](https://pica.zhimg.com/v2-b47fa9073fc1dfa67ee33e7920ca6100_r.jpg?source=1940ef5c)

（计算可得，如果第四发 K 题的 attempt 通过，『四小时下班』将以 $8$ 分钟罚时的优势绝杀夺冠）

因此，对于一个字符串，她觉得如果这个字符串含有 `std::cerr` 作为子串，则她觉得这个字符串『不太行』，否则她觉得这个字符串『非常行』。

给定 $T$ 个字符串，请你判断它们是不是『不太行』。

## 说明/提示

### 样例组与实际输入的说明

两个样例分别对应两个问题的样例输入输出。

如果你直接采用『提交答案』的方式，请分别将两个输入数据命名为 `1.in`、`2.in`，并打成 zip 压缩包进行提交；

如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \leq x \leq 2$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。

显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对两个问题的样例说明。

### 数据规模要求

你给出的数据必须满足如下要求：

1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有文末回车，问题 $1$ 可以有行末空格。
2. 对于问题 $1$，$1 \leq a, b, c \leq 100$，$b \neq c$。
3. 对于问题 $2$，$1 \leq T \leq 10^6$，输入字符串的总长度不超过 $2 \times 10^6$，输入的任何字符串不能为空串，且只能含有可见字符（ASCII 值在 $33$ 到 $126$ 之间，空格**不算**可见字符）。

### 目标代码

你需要 hack 如下的代码：

#### 问题 1

```cpp
#include <iostream>
using namespace std;

int main() {
  int a, b, c;
  cin >> a >> b >> c;
  int d = b - c;
  cout << ((a + d - 1) / d) << endl;
}
```

#### 问题 2

```cpp
#include <iostream>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int T;
  std::string s;
  int ans = 0, cur = 0;
  for (std::cin >> T; T; --T) {
    std::cin >> s;
    ++cur;
    if (s.find("std::cerr") != std::string::npos) {
      std::cerr << cur << '\n';
      ++ans;
    }
  }
  std::cout << ans << std::endl;
}
```

目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。

#### 数据判定

你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。

#### 超时判定

程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。

如果程序的运行时间超过 $500 \text{ms}$，则判定为程序运行超时，返回 accepted 结果。

#### 结果错误判定

如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。

#### 未定义行为判定

我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。

这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。

### 样例程序

这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。

```cpp
#include <iostream>

using namespace std;

int main() {
  int taskId;
  cin >> taskId;
  if (taskId == 1) {
    cout << "" <<endl;
  } else if (taskId == 2) {
    cout << "" << endl;
  } else { // 这个 else 不会被执行
    cout << "Stupid Fusu!" << endl;
  }
}
```

如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到两个 `.in` 文件。这就是说，文件结构必须是：

```plain
ans.zip
 |---1.in
 |---2.in
```

两个文件不应该被额外的文件夹包含，即文件结构不能是：

```plain
ans.zip
 |---ans(folder)
      |---1.in
      |---2.in
```

### 关于评测信息的说明

如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。

例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。

特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。

## 样例 #1

### 输入

```
9 8 5```

### 输出

```
3```

## 样例 #2

### 输入

```
3
std::cerr
std::cerr<<"HelloLuogu!";
std::cout<<"HelloLuogu!";```

### 输出

```
2```

# 题解

## 作者：一扶苏一 (赞：8)

### 问题 1

`(a + b - 1) / b` 在 $b > 0$ 时是一个非常合理且正确的对 $\dfrac a b$ 上取整求值的方法：

$$\left\lfloor\dfrac{a + b - 1}{b}\right\rfloor = \left\lfloor\dfrac{a}{b}\right\rfloor + \left\lfloor\dfrac{a \bmod b +  b - 1}{b}\right\rfloor = \begin{cases}\frac{a}{b}, &a \bmod b = 0 \\ \left\lfloor\frac{a}{b}\right\rfloor + 1, & a \bmod b \neq 0\end{cases}$$

这两种情况都恰好等于 $\left\lceil\dfrac{a}{b}\right\rceil$。

但是，这一方法在分母小于 $0$ 时并不适用。hack 的思路之一是，当 $b \mid a$ 时，给 $a$ 加上 $b - 1$ 会让分子减小，而原先的商是整除的结果，在分子减小后，商（的绝对值）会减小，于是就得不到正确的结果了。

因此，任给出一组 $b < c$ 且 $(b - c) \mid a$ 的数据即可。

思考题：上述方法在分子为负、分母为正时能否使用？

### 问题 2

题意简述：

`std::cerr` 每调用一次就会刷新一次缓冲区，而刷新缓冲区次数太多就会导致超时。

关注到目标代码中有一句

```cpp
if (s.find("std::cerr") != std::string::npos) {
  std::cerr << cur << '\n';
  ++ans;
}
```

其中 ```s.find(t)``` 返回的是 $t$ 作为 $s$ 的子串第一次出现位置的首下标。当 $t$ 不是 $s$ 的子串时返回 `std::string::npos`。因此，当输入的 $s$ 含有 `std::cerr` 作为子串时，就会执行大括号内的内容，否则不会执行。`if` 每执行一次，就会调用一次 `std::cerr`。要让程序超时，只需要让程序尽可能多地调用 `std::cerr`。

于是，只需要令所有输入字符串均为 $\texttt{std::cerr}$ 即可。这是一个长度为 $9$ 的字符串，输入总长度不能超过 $2 \times 10^6$，所以你最多可以输出 $222,222$ 个这样的串。

## Code

```cpp
#include <iostream>

int main() {
  using std::cin, std::cout;
  int x;
  std::cin >> x;
  if (x == 1) std::cout << "9 5 8\n";
  else {
    cout << 222222 << '\n';
    for (int i = 1; i <= 222222; ++i)
    cout << "std::cerr\n";
  }
}
```

---

## 作者：Pink_Cut_Tree (赞：5)

# B3785 [语言月赛202306] std::cerr 题解

### 题目介绍

hack 题的含义如下：

在本题目中，你将得到两个问题和两个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于这一问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

### 题目分析

#### 问题 1

对于 $d$ 小于 $0$ 的情况，题目中的代码无法判断。如 $b=2,c=3$，此时 $2 - 3 = -1$，而我们要 hack 的代码中出现了 `a + d - 1` 的片段，这个式子算出来是 $a-2$，明显与题意不符。

那么 $a$ 只要取一个大于 $1$ 的数即可。

注意数据范围：$1 \leq a, b, c \leq 100$，$b \neq c$。

#### 问题 2

According to ~~stupid~~ poor fusu's experience,using `std::cerr` is really slow!

（翻译：根据扶苏的经历，输出 `std::cerr` 很浪费时间）

观察要 hack 的代码，当输入的内容包含 `std::cerr` 时，$cur$ 变量就会自增 $1$，于是就会在缓冲区输出 $cur$ 变量的值（虽然不会打印到命令行中），此时再去刷新缓冲区，就会超时。

所以我们只需要输出大量的 `std::cerr`，卡爆缓冲区就可以了。

再次注意数据范围：$1 \leq T \leq 10^6$，输入字符串的总长度不超过 $2 \times 10^6$。（其中，$T$ 为字符串的数量）

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
	int n;
	cin>>n;
	if(n==1){
		cout<<"2 2 3";
	}
	else{
		cout<<"50000\n";
		for(int i=1;i<=50000;i++){
			cout<<"std::cerr\n";
		}
	}
return 0;	
}
```

---

## 作者：huangruiheng0217 (赞：2)

#### Subtask 1

永远铭记在心：涉及取整的操作一定要考虑负数！这一点在自己写代码的时候也很重要（比如位移和 `cell` 和 `floor` 等运算）。

题目要求我们计算 $\left\lceil\dfrac {a}{b - c} \right\rceil$ 的值，显然代码在分母分子都是正数时可以正确运行。

那咋办呢？注意到虽然 $b$ 和 $c$ 都是正整数，但是 $b-c$ 可以是负数。我们根据题目给出的代码进行模拟：

$ans=\left\lceil \dfrac{a+b-c-1}{b-c} \right\rceil=1+\left\lceil \dfrac{a-1}{b-c} \right\rceil$

举例，当 $b-c=-5$ 时，$ans=1+(a-1)\div(-5)$。显然当 $a-1>0$ 时，$ans$ 会寄掉。

故构造 $b-c<0$ 的数据即可。

例：`10 5 15`

---

#### Subtask 2

`cerr` 极其浪费时间，所以我们要不停运行它。

注意到字串总长度不超过 $2\times 10^6$，那么我们输出 $10^5$ 个 `std::cerr` 即可卡爆该程序。

---

#### 废话

~~本题考查知识点：我也说不上来 hack 题究竟考察的是什么。~~

---

## 作者：liupan2010 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B3785)

$\text{Subtask 1}$：

问题：给出整数 $a,b,c$，求出 $\left\lceil\dfrac{a}{b-c}\right\rceil$ 的值。

思路：正确的做法应该是直接 ``ceil(a*1.0/(b+c))``，但是题目中却写的是 ``(a+b-c-1)/(b-c)``。这时候我们可以采用类似于对拍的方式，生成随机数据然后对比两个程序输出的内容。如果发现不一致，就说明我们成功的找到了 hack 数据。

其实可以将两个程序写成了两个函数，这样也可以，且更简单。

给个数据生成代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int prag1(int a,int b,int c){
	return (a+b-c-1)/(b-c);
}
int prag2(int a,int b,int c){
	return ceil(a*1.0/(b-c));
}
int main(){
	srand(time(NULL));
	for(int i=1;i<=10000;i++){
		int a=rand()%100+1,b=rand()%100+1,c=rand()%100+1;
		if(prag1(a,b,c)!=prag2(a,b,c)){
			cout<<a<<' '<<b<<' '<<c;
			break;
		}
	}
	return 0;
} 
```

于是我们可以发现一组 hack 数据：``49 22 66``。

$\text{Subtask 2}$：

问题：给定 $n$ 个字符串，求出包含 ``std::cerr`` 的字符串个数。

思路：看了扶苏的悲惨经历之后，我们可以想到，输出大量的 ``std::cerr``，这样程序就会执行大量的 ``std::cerr`` 卡爆缓冲区。所以我们只要输出大量的 ``std::cerr`` 即可。

给个代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<10000<<endl;
	for(int i=1;i<=10000;i++){
		puts("std::cerr");
	}
	return 0;
} 
```

完整代码就不给了，应该都写得出来吧。

---

## 作者：flysfy_LJX (赞：2)

### 问题 1

给出整数 $a, b,c$，求 $\left\lceil\dfrac {a}{b - c} \right\rceil$ 的值，其中 $\left\lceil x \right\rceil$ 表示不小于 $x$ 的最小整数。

对于目标代码我们设 $d = a - c$，易得正确的答案为 `ceil(a*1.0/d)`，所以只需要判断正确的答案和目标代码输出的答案是否一致，不一致就代表找到了 hack 数据，输出即可。

### 问题 2

对于一个字符串，如果这个字符串含有 `std::cerr` 作为子串，则她这个字符串『不太行』，否则她觉得这个字符串『非常行』。

给定 $T$ 个字符串，请你判断它们是不是『不太行』。

由~~省赛惨案~~可知 `std::cerr` 刷新缓冲区次数太多，会导致程序超时。而 $1 \leq T \leq 10^6$，目标代码中也存在 `std::cerr`，所以只需要尽多使目标代码运行 `std::cerr`，从而导致目标代码超时而完成 hack。

## 代码：
```
#include<bits/stdc++.h>
using namespace std;
int x;
void hack_1()
{
	for(int a=1;a<=100;a++)
		for(int b=1;b<=100;b++)
			for(int c=1;c<=100;c++)  //枚举答案 
				if(b!=c) 
				{
					int d=b-c;
					int wa_ans=(a+d-1)/d;     //计算目标代码输出的答案 
					int ac_ans=ceil(a*1.0/d); //计算正确的答案 
					if(wa_ans!=ac_ans)//成功 hack 
					{
						cout << a << " " << b << " " << c << endl;
						exit(0);//强制退出 
					}
				}
}
void hack_2()
{
	cout << 200000;
	for(int i=1;i<=200000;i++)
		cout << endl << "std::cerr"; //让目标代码刷新缓冲区
	exit(0);//强制退出 
}
int main()
{
	cin >> x;
	if(x==1) hack_1();
	if(x==2) hack_2();
	return 0;
}
```

**注意**：在问题 2 中，如果 $T = 10^6$ 会超时，$T = 2 \times 10^5$ 足够让目标代码超时。

---

## 作者：yzm0325 (赞：1)

~~好吧几经踌躇之后还是选择写一发题解（题外话）~~

先来看看 hack 题的含义：

在本题目中，你将得到两个问题和两个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
1. 运行超时。
1. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于这一问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

简单来说，就是题目会给出对于一道题的代码，但是代码是错误的（即对于特定数据可能会答案错误、超时或是出现未定义行为），需要你构造一组数据使得代码出错。

首先来看第一题。

我们发现，给出的代码中，向上取整是这样操作的：

```cpp
cout << ((a + d - 1) / d) << endl; // d = b - c
```

那么对于一些 $b$ 和 $c$ 的差是负数的情况，就有可能得不到正确结果。比如 $b=8,c=9$，这时 $d=b-c=-1$，而 $a+d-1$ 的结果就是 $a-2$，显然不符。

那么构造一组 $b>c$ 的数据就可以了。

再来看第二题。

我们看到了代码中有一句向标准错误流中打印 $cur$ 的命令。而题目描述中说过：

> 需要注意的是，刷新缓冲区是一件速度很慢的事情，如果刷新次数太多，会导致程序超时。

所以，只要输出大量包含 `std::cerr` 的字符串，让 `std::cerr` 不停向标准错误流中输出就会超时。

注意一下数据范围：输入字符串的总长度不超过 $2 \times 10^6$，也就是最多能输入 $222222$ 个 `std::cerr`。

代码：

```cpp
#include <iostream>

using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
  int taskId;
  cin >> taskId;
  if (taskId == 1) {
    cout << "9 8 9" <<endl;
  } else if (taskId == 2) {
    cout << 222222 << "\n";
    for(int i = 1; i <= 222222; i++) cout << "std::cerr\n";
  } else { // 这个 else 不会被执行
    cout << "Stupid Fusu!" << endl;
  }
}
```

完结撒花！

---

## 作者：Konpaku_Youfu (赞：1)

# B3785 [语言月赛202306] std::cerr 题解

## 题意简述

本题为 hack 题，即对于题目给出的问题，针对解决对应问题的代码，给出一份输入数据，使得这份代码不能对于这份输入给出正确的输出。

不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

### 问题 1
给出整数 $a, b, c$，求 $\left\lceil\dfrac {a}{b - c} \right\rceil$ 的值，其中 $\left\lceil x \right\rceil$ 表示不小于 $x$ 的最小整数。

### 问题 2
对于一个字符串，如果这个字符串含有 `std::cerr` 作为子串，则这个字符串『不太行』，否则这个字符串『非常行』。

给定 $T$ 个字符串，请判断它们是不是『不太行』。

## 题目分析

### 问题 $1$

设 $d = b - c$。  
正确的计算方式为 `ceil(a * 1.0 / d)`。

可以发现，题目给出的代码对于数据满足 $d < 0$ 的情况不能很好地处理，**大多数**情况下会输出错误的答案。   
通过观察式子 $(a + d - 1) \div d$ 可知，在数据满足 $d < 0$ 的情况下，若 $a > 1$ 且 $a < \left | d \right |$，则题目代码的输出值与正确值都为 $0$。应排除这种情况。

综上所述，在输入数据满足题目要求的数据范围 $1 \leq a, b, c \leq 100$，$b \neq c$ 的前提下，一并满足 $b - c < 0$，且满足 $a = 1$ 与 $a \ge \left | b - c \right |$ 中至少一条，则可以使得题目代码输出错误的答案。

如果无法理解以上结论，可以直接简单粗暴地枚举产生答案：

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int func1(int a, int b, int c)
{
	int d = b - c;
  	return (a + d - 1) / d;
}

int func2(int a, int b, int c)
{
	return ceil(a * 1.0 / (b - c));
}

int main()
{
	for (int a = 1; a <= 100; a++)
	{
		for (int b = 1; b <= 100; b++)
		{
			if (b == a)		continue;

			for (int c = 1; c <= 100; c++)
			{
				if (c == a || c == b)	continue;
				
				if (func1(a, b, c) != func2(a, b, c))
				{
					cout << a << " " << b << " " << c << "\n";
				}
			}
		}
	}
	
	return 0;
}
```

以上代码输出的每一行数据，都可使得题目代码输出错误的答案。  
适当修改这份代码中的判断条件并观察，有助于理解前文所述结论。

### 问题 $2$

通过题目中叙述的~~悲惨经历~~，可以得知每次 `std::cerr` 完成输出后都会刷新缓冲区，然而刷新缓冲区是一件速度很慢的事情，如果刷新次数太多，会导致程序超时。  
观察题目代码可以发现，每当输入的字符串含有 `std::cerr` 作为子串，都会调用一次 `std::cerr` 输出 $cur$ 的值，并使得 $ans$ 加一。

~~死不悔改了属于是~~

故只需要使得输入数据中有大量的字符串都含有 `std::cerr` 作为子串，题目代码就会非常多次地调用 `std::cerr`，从而导致超时。    
最简单的方式是直接多次输出字符串 `std::cerr` 即可，同时注意不要超出题目要求的数据范围 $1 \leq T \leq 10^6$，输入字符串的总长度不超过 $2 \times 10^6$。

## AC Code

温馨提示：为何此处对于问题 $2$ 的输出，使用换行符 `\n` 而不是 `endl` 呢？  
因为每次使用 `std::endl` 输出换行符后都会刷新缓冲区，然而刷新缓冲区是一件速度很慢的事情……

```cpp
#include <iostream>

using namespace std;

int x;

int main()
{
	cin >> x;
	if (x == 1)
	{
		cout << "1 2 3" << endl;
		
	}else if (x == 2)
	{
		cout << 200000 << endl;
		for (int i = 1; i <= 200000; i++)
		{
			cout << "std::cerr\n";
		}
		
	}else
	{
		cout << "Stupid Fusu!" << endl;
	}
	
	return 0;
}
```

---

## 作者：ICU152_lowa_IS8 (赞：0)

对于第一个 Hack，观察范围可以看到 $1 \leq a,b,c \leq 100$，很明显，可以写两个函数直接枚举并进行比较，时间复杂度 $O(abc)$，代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
int cal1(){
	d=b-c;
	return (a+d-1)/d;
}
int cal2(){
	return ceil(a*1.0/(b-c));
}
int main(){
	for(a=1;a<=100;a++){
		for(b=1;b<=100;b++){
			for(c=1;c<=100;c++){
				if(b!=c&&cal1()!=cal2()){
					cout<<a<<" "<<b<<" "<<c;
                    return 0;
				} 
			}
		}
	}
	return 0;
}

```

对于第二个 Hack，可以看到每当输出字符串含有一个 `std::cerr` 时就会使 `ans` 加一，所以只要使字符串有一大堆 `std::cerr` 即可让其超时。

注意还有个 $T$！考场上因为没看到有个 $T$ 痛失 $1000$ 分。

本题完整代码：

```
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
int cal1(){
	d=b-c;
	return (a+d-1)/d;
}
int cal2(){
	return ceil(a*1.0/(b-c));
}
int main(){
	int x;
	cin>>x;
	if(x==1){
		for(a=1;a<=100;a++){
			for(b=1;b<=100;b++){
				for(c=1;c<=100;c++){
					if(b!=c&&cal1()!=cal2()){
						cout<<a<<" "<<b<<" "<<c;
						return 0;
					} 
				}
			}
		}
	}
	else if(x==2){
		cout<<200000<<"\n";
		for(int i=1;i<=200000;i++){
			printf("std::cerr\n");
		}
	}
	return 0;
}

```


---


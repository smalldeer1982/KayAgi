# [语言月赛 202309] 椰奶国

## 题目背景

扶苏的梦想是在椰奶国生活。这个国度的成员都是可爱的椰奶，椰奶们无需在意外面的世界，快乐地生活在椰奶国里。

## 题目描述

椰奶国的一天共有 $n$ 个小时。第 $i$ 个小时（$0 \leq i < n$）共有 $i + 1$ 分钟，第 $i$ 个小时的第 $j$ 分钟（$0 \leq j \leq i$）共有 $10j+1$ 秒。

注意，这里小时、分钟、秒数都是从 $0$ 起计数。

现在，给出起始时刻 $t_1 = A:B:C$，表示 $t_1$ 时刻是 $A$ 时 $B$ 分 $C$ 秒，和结束时刻 $t_2 = E:F:G$，表示 $t_2$ 时刻是 $E$ 时 $F$ 分 $G$ 秒。

已知时刻 $t_2$ 的时刻不早于 $t_1$ 的时刻，且二者时间间隔小于一天。

请你求出 $t_1$ 和 $t_2$ 之间经过了多少秒。

## 说明/提示

### 样例 2 解释

椰奶国一天有 $2$ 小时，即第 $0$ 小时和第 $1$ 小时，第 $1$ 小时有 $2$ 分钟，即第 $0$ 分钟和第 $1$ 分钟。第 $1$ 分钟有 $10 \times 1 + 1 = 11$ 秒。在第 $1$ 小时第 $1$ 分钟第 $3$ 秒起，接下来经过的时刻是第 $4,5,6,7,8,9,10,0$ 秒（其中最后一秒是下一天的第一秒），共八秒。

### 数据规模与约定

- 对 $30\%$ 的数据，$t_2$ 代表的时刻在一天中不早于 $t_1$ 时刻。
- 对 $60\%$ 的数据，$n \leq 50$，**保证单个测试点内的答案之和不超过 $10^8$**。
- 对 $100\%$ 的数据，$1 \leq T \leq 5 \times 10^3$，$1 \leq n \leq 10^5$，$0 \leq B \leq A < n$，$C \leq 10B$。$0 \leq F\leq E < n$，$G \leq 10E$，**保证单个测试点内的 $n$ 之和不超过 $1.5 \times 10^8$**。

## 样例 #1

### 输入

```
1
10 3 2 11 3 3 0```

### 输出

```
10```

## 样例 #2

### 输入

```
1
2 1 1 3 0 0 0```

### 输出

```
8```

# 题解

## 作者：cff_0102 (赞：11)

题解区怎么没有纯数学解法。

这道题，可以先分别计算出起始时刻和结束时刻是一天当中的第几秒，然后再作差，就能直接得到答案。

已知有一个时刻是 $(a+1):(b+1):(c+1)$，怎么计算出它是一天中的第几秒呢？

首先，把这个时刻拆成 $(a+1)$ 个小时，$(b+1)$ 分钟和 $(c+1)$ 秒。

由题意得，某一小时的第 $b$ 分钟共有 $10b+1$ 秒，则某一小时从第 $0$ 分钟到第 $b$ 分钟（共 $b+1$ 分钟）就一共过去了 $(10\times0+1)+(10\times1+1)+(10\times2+1)+\dots+(10b+1)$ 秒。根据等差数列求和公式，这个算式的结果是 $\dfrac{(10\times0+1+10b+1)\times(b+1)}{2}=5b^2+6b+1$。

由题意得，一天中的第 $a$ 小时共有 $a+1$ 分钟（从第 $0$ 分钟到第 $a$ 分钟），根据上面的计算，则这一小时共有 $5a^2+6a+1$ 秒。从第 $0$ 个小时到第 $a$ 个小时（共 $a+1$ 个小时）就一共过去了 $(5\times0^2+6\times0+1)+(5\times1^2+6\times1+1)+\dots+(5a^2+6a+1)$ 秒。把它们拆开，变成 $5\times(0^2+1^2+\dots+a^2)+6\times(0+1+\dots+a)+(1+1+\dots+1)$，分别代入平方和公式、等差数列求和公式和项数 $a$，得到原式等于 $\dfrac{5a(a+1)(2a+1)}{6}+3a(a+1)+(a+1)=\dfrac{10a^3+33a^2+29a+6}{6}$。

然后把它们相加，设 $f(a+1,b+1,c+1)$ 表示 $(a+1):(b+1):(c+1)$ 是一天中的第几秒：

$$f(a,b,c)=\dfrac{10(a-1)^3+33a^2+29a+6}{6}+5b^2+6b+c+2$$

则此题的答案为：$f(E-1,F-1,G-1)-f(A-1,B-1,C-1)$。

如果这个数为负数，就说明这个时间范围跨了一天。所以输出答案的时候还需要先将其加上一天的秒数，再取模，得到一个范围在 $0$ 和一天秒数之间的数，那就是答案。

```python
def f(a,b,c):
    return (10*a*a*a+33*a*a+29*a+6)//6+5*b*b+6*b+c+2

t=int(input())

while t:
    t-=1
    n,A,B,C,E,F,G=input().split()
    n,A,B,C,E,F,G=(int(n),int(A),int(B),int(C),int(E),int(F),int(G))
    tmp=f(n-1,0-1,0-1)
    print((f(E-1,F-1,G-1)-f(A-1,B-1,C-1)+tmp)%tmp)
```

---

## 作者：Light_az (赞：9)

题意可以简化成：有一种新的时间计算方法，具体表现为一天有 $n$ 小时，第 $i$ 个小时（$0 \leq i < n$）共有 $i + 1$ 分钟，第 $i$ 个小时的第 $j$ 分钟（$0 \leq j \leq i$）共有 $10 \times j+1$ 秒，现在给出两个时刻，求这两个时刻的时间差。

最朴素的一种想法是直接枚举这两个时间分别需要多少秒才能达到，相减就是答案，核心实现如下：


```cpp
cin>>n>>a>>b>>c>>e>>f>>g;
ll ans1=0,ans2=0,ans3=0;
F(i,0,a-1) F(j,0,i) ans1+=10*j+1;//一共过完了 0 到 a-1 小时,第 a 小时没有过完
F(i,0,b-1) ans1+=10*i+1;//一共过完了 0 到 b-1 分钟，第 b 分钟没有过完
ans1+=c;//一共过完了 c 秒
F(i,0,e-1) F(j,0,i) ans2+=10*j+1;//同上
F(i,0,f-1) ans2+=10*i+1;
F(i,0,n-1) F(j,0,i) ans3+=10*j+1;
ans2+=g;
cout<<ans2-ans1<<"\n";//相减
```

然而发现第二个样例出现了负数情况，重新阅读题目发现有这样一句话：`已知 t2 的时刻不早于 t1 的时刻，且二者时间间隔小于一天`，也就是说，题目没有保证两个时刻在同一天，因此我们默认如果两个时刻在不同的两天，我们默认第二天的时刻已经过完了一天的时间，也就是：


```cpp
F(i,0,n-1) F(j,0,i) ans3+=10*j+1;//过完一整天的时间
if(ans1>ans2) cout<<ans2+ans3-ans1<<"\n";//不在一天内
else cout<<ans2-ans1<<"\n";//在一天内
```

但是发现时间复杂度不正确，分析第二层求秒数循环可以化简，将 $1$ 单独取出来后可以得到:

$\sum_{i=0}^{n}  (i \times 10+1) =n + 1+ 10 \times \sum_{i=0}^{n} i $，累加可以高斯公式求，之后便可以 $O(1)$ 求出每分钟秒数，下面是完整代码：

```
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define D double
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e6+10;
ll n,m,k,x,y,u,v,w,cnt,ans,t,l,r,len,T,id;
ll mn=INT_MAX,mx=0,p,opt;
ll a,b,c,d,e,f,g;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>a>>b>>c>>e>>f>>g;
		ll ans1=0,ans2=0,ans3=0;
		F(i,0,a-1){
			ans1+=i+1;//单独取出 1
			ans1+=i*(i+1)/2*10;//高斯公式,1+2+....+n=(1+n)*n/2
            //下同
		} 
		F(i,0,b-1) ans1+=10*i+1;
		ans1+=c;
		F(i,0,e-1){
			ans2+=i+1;
			ans2+=i*(i+1)/2*10;
		}
		F(i,0,f-1) ans2+=10*i+1;
        ans2+=g;  
		F(i,0,n-1){
			ans3+=i+1;
			ans3+=i*(i+1)/2*10;
		}
		if(ans1>ans2) cout<<ans2+ans3-ans1<<"\n";//判断是否在同一天
		else cout<<ans2-ans1<<"\n";
	}

	return 0;
}
```



---

## 作者：一扶苏一 (赞：3)

## Source & Knowledge

2023 年 09 月语言月赛，由洛谷网校入门计划/基础计划提供。

---

## 文字题解

### 题意简述

给定一个计时策略，求两个时刻 $t_1$ 和 $t_2$ 之间相差的秒数。

### 解析

容易发现一天内的总秒数不会超过 int 存储的范围。我们可以分别算出 $t_1$ 相比第 $0$ 秒经过的秒数，和 $t_2$ 相比第 $0$ 秒经过的秒数。二者之差即为二者相差的秒数。

如何算出从初始到 $t_i$ 的秒数？

假设计算从第 $0$ 秒到第 $x$ 时 $y$ 分 $z$ 秒经过的秒数：

考虑逐小时计算每小时的秒数并叠加到总秒数里：  
1. 首先第 $0$ 小时有 $1$ 分钟，共 $11$ 秒。
2. 假设已知第 $i$ 小时的秒数 $k$，则第 $(i + 1)$ 小时的前 $(i + 1)$ 分钟（$0\sim i$ 秒）的秒数恰好就是 $k$，第 $(i+1)$ 分的秒钟数是第 $(i + 1)*10 + 1$。所以第 $(i + 1)$ 小时的秒数就是 $k + 10(i + 1) + 1$。

于是，我们枚举小时数 $i$，记录上一小时的秒数 $second$，则这一小时的秒数就是 $second + 10 \times i + 1$。把这一小时的秒数加入答案即可。

这样我们可以计算出前 $x-1$ 小时的答案。

第 $x$ 小时只经过了 $y$ 分，于是枚举这个小时的分钟数 $i$ 从 $0$ 到 $y - 1$，把 $10 i + 1$ 加入答案即可。

最后加上第 $y$ 分的秒数 $z$，就是总秒数。参考如下代码:

```cpp
int calc(int x, int y, int z) {
  long long ret = 0, seconds = 0;
  for (int i = 0; i < x; ++i) {
    seconds += (i) * 10 + 1;
    ret += seconds;
  }
  for (int i = 0; i < y; ++i) {
    ret += 10 * i + 1;
  }
  return ret + z;
}
```

这样能算出 $t_1$、$t_2$ 两个时刻分别距开始时的秒数 $s_1, s_2$。分两种情况：

1. $t_1 \leq t_2$，说明两个时刻在同一天，则答案就是 $s_2 - s_1$。
2. $t_1 > t_2$，说明两个时刻不在同一天。设一天共有 $s_3$ 秒，则二者相差的秒数就是 $(s_2 + s_3 - s_1) \bmod s_3$。

计算 $s_3$ 其实就是计算第 $n-1$ 小时第 $n-1$ 分第 $10n - 9$ 秒经过的秒数。

## 视频题解


---

## 作者：Frosts (赞：2)

## 思路

注意到每一个 $n$ 最大只有 $10^5$，于是我们可以进行预处理。对于每个 $1\leq i \leq 10^5$ 提前算出一天为 $i$ 小时时一共有多少秒（因为答案是求经过了多少秒）。这时我们可以用前缀和思想，设 $f_i$ 表示前 $i$ 分钟一共有多少秒，$h_i$ 表示前 $i$ 小时一共有多少秒。 那么 $h_i=h_{i-1}+f_i$，$f_i=f_{i-1}+10i+1$。

两个式子是什么意思呢？对于 $h_i$，就是从前 $i-1$ 个小时转移过来，还要加上这一小时的秒数，因为第 $i$ 小时有 $i+1$ 分钟，前 $i$ 分钟的秒数和就是 $f_i$。而 $f_i$ 与之同理，再加上当前这一分钟的 $10j+1$ 秒就行了。

得到了 $f$ 和 $h$ 数组，这道题就好做了。对于 $t_1$ 把它写成 $h_{a-1}+f_{b-1}+c$ 秒，减 $1$ 是因为当前是 $a$ 时，$b$ 分，还没有过完。因此只用算前 $a-1$ 小时和前 $b-1$ 小时的和就行了。对于 $t_2$ 同理。算出来后比较一下当前的 $t_1$，$t_2$ 大小，如果 $t1>t2$，那就说明跨了一天，就要用 $t_2+h_{n-1}-t_1$ 来算答案（过完第一天的秒数为 $h_{n-1}-t_1$，再加上到 $t_2$ 的秒数）；否则直接 $t_2-t_1$ 就行了。

## code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t,n;
ll a,b,c,g,e,f;
ll th[100005],tf[100005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t;
	th[0]=tf[0]=1;
	for(int i=1;i<=1e5;++i)tf[i]=tf[i-1]+(ll)(10*i+1);
	for(int i=1;i<=1e5;++i)th[i]=th[i-1]+tf[i];//预处理
	while(t--){
		cin>>n>>a>>b>>c>>e>>f>>g;
		ll t1=(a?th[a-1]:0)+(b?tf[b-1]:0)+c,t2=(e?th[e-1]:0)+(f?tf[f-1]:0)+g;//计算秒数
		if(t2<t1)cout<<t2+th[n-1]-t1<<endl;	//判断是否跨天
		else cout<<t2-t1<<endl;
	}
	return 0;
}

```


---

## 作者：Emily666 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B3856)

其实这应该就是一道~~小型~~码农题吧。这种题如果没有思路，我个人一般会先打个暴力，再找找有没有可以优化的地方。
### Sub 1
如上，先打个暴力模拟。
#### $60$ 分代码（TLE 了后四个点）
```cpp

#include <bits/stdc++.h>
using namespace std;
int T=1;
int main(){
    cin>>T;
    int n,A,B,C,E,F,G;
    int h,m,s;
    while(T--){
        cin>>n>>A>>B>>C>>E>>F>>G;
        int ans=0;
        if(A==E&&B==F){
           if(G>C){
              ans=G-C;
           }
           if(G<C){
              ans=10*B+1-C;
              for(int i=B+1;i<A+1;i++){//第B分钟  总共A+1分钟
                   ans+=10*i+1;
               }//计算开始小时内的秒数
               for (int j=A+1;j<=n-1;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算从开始后一小时到当天结束时的秒数
               for (int j=0;j<E;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算第二天到结束前整时的秒数
               for(int i=0;i<F;i++){
                  ans+=10*i+1;
               }//计算结束时整分的秒数
              ans+=G;
           }
        }
        if(A==E&&B!=F){
            if(F>B){
              ans=10*B+1-C;
              for (int i=B+1;i<F;i++){
                   ans+=10*i+1;
              }//计算结束时整分的秒数
              ans+=G;
            }
            if(F<B){
              ans=10*B+1-C;
              for(int i=B+1;i<A+1;i++){
                   ans+=10*i+1;
               }//计算开始小时内的秒数
               for (int j=A+1;j<=n-1;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算从开始后一小时到当天结束时的秒数
               for (int j=0;j<E;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算第二天到结束前整时的秒数
               for(int i=0;i<F;i++){
                  ans+=10*i+1;
               }//计算结束时整分的秒数
              ans+=G;
            }
        }
        if(A!=E){
            if(A>E){
               ans=10*B+1-C;
               for(int i=B+1;i<A+1;i++){
                   ans+=10*i+1;
               }//计算开始小时内的秒数
               for (int j=A+1;j<=n-1;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算从开始后一小时到当天结束时的秒数

               for (int j=0;j<E;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算第二天到结束前整时的秒数
               for(int i=0;i<F;i++){
                  ans+=10*i+1;
               }//计算结束时整分的秒数
               ans+=G;
            }
            if (A<E){
               ans=10*B+1-C;
               for(int i=B+1;i<A+1;i++){
                   ans+=10*i+1;
               }//计算开始小时内的秒数

               for (int j=A+1;j<E;j++){
                  for(int k=0;k<j+1;k++){
                      ans+=10*k+1;
                  }
               }//计算从开始后一小时到结束整时的秒数
               for(int i=0;i<F;i++){
                  ans+=10*i+1;
               }//计算结束时整分的秒数
               ans+=G;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
### Sub 2
两个优化：
- 突然发现代码中有许多循环累加的地方，于是想到了高斯求和公式。高斯求和公式是什么来着？
$$(F + L) \times N \div 2$$
（其中 $F$ 表示首项，$L$ 表示尾项，$N$ 表示项数）

- 观察题目的数据范围，发现 $\texttt{ans}$ 要开 long long。

于是，改进后的代码上来啦——
#### $100$ 分代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
long long ans;
int main(){
    scanf("%d",&T);
    int n,A,B,C,E,F,G;
    while(T--){
        scanf("%d%d%d%d%d%d%d",&n,&A,&B,&C,&E,&F,&G);
        ans=0;
        if(A==E&&B==F){
            if(G>C) ans=1LL*(G-C);
            else if(G<C){
                ans=1LL*(10*B+1-C);
                ans+=1LL*(10*(B+1)+1+10*A+1)*(A-B)/2;
                for(int j=A+1;j<=n-1;j++) //计算从开始后一小时到当天结束时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                for(int j=0;j<E;j++) //计算第二天到结束前整时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                ans+=1LL*(1+10*(F-1)+1)*F/2;
                ans+=1LL*G;
            }
        }
        if(A==E&&B!=F){
            if(F>B){
              ans=1LL*(10*B+1-C);
              ans+=1LL*(10*(B+1)+1+10*(F-1)+1)*(F-B-1)/2;
              ans+=1LL*G;
            }
            else if(F<B){
                ans=1LL*(10*B+1-C);
                ans+=1LL*(10*(B+1)+1+10*A+1)*(A-B)/2;
                for(int j=A+1;j<=n-1;j++) //计算从开始后一小时到当天结束时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                for(int j=0;j<E;j++)//计算第二天到结束前整时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                ans+=1LL*(1+10*(F-1)+1)*F/2;
                ans+=1LL*G;
            }
        }
        if(A!=E){
            if(A>E){
                ans=1LL*(10*B+1-C);
                ans+=1LL*(10*(B+1)+1+10*A+1)*(A-B)/2;
                for(int j=A+1;j<=n-1;j++)//计算从开始后一小时到当天结束时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                for(int j=0;j<E;j++)//计算第二天到结束前整时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                ans+=1LL*(1+10*(F-1)+1)*F/2;
                ans+=1LL*G;
            }
            else if(A<E){
                ans=1LL*(10*B+1-C);
                ans+=1LL*(10*(B+1)+1+10*A+1)*(A-B)/2;
                for (int j=A+1;j<E;j++)//计算从开始后一小时到结束整时的秒数
                    ans+=1LL*(1+10*j+1)*(j+1)/2;
                ans+=1LL*(1+10*(F-1)+1)*F/2;
                ans+=1LL*G;
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：IOI_AK_TLR (赞：1)

# 思路

最先想到的就是按题意，从第一个时刻一点点加秒，到第二个时刻求加了多少次，但这样显然会超时；

进一步，注意到第 $i$ 分钟有 $i \times 10+1$ 秒，对于两个时刻之间的一整个分钟，我们可以整体把计数器加上 $i \times 10+1$，并将分钟数自增 $1$。但这种做法仍然避免不了超时；

更进一步，注意到第 $i$ 小时有 $\sum_{j=0}^{i} (j \times 10+1)$ 秒，而

$$\begin{aligned} \sum _ {j = 0} ^ i (j \times 10 + 1) &= \sum _ {j = 0} ^ i (j \times 10) + (i + 1) \\ &= \sum _ {j = 0}^i (j) \times 10 + (i + 1) \\ &= (i + 1) \times i \div 2 \times 10 + i + 1 \end{aligned}$$


因此可以使用上述公式快速求出从 $0:0:0$ 到 $a:b:c$、从 $0:0:0$ 到 $e:f:g$ 的秒数，作差即可求出它们之间的秒数，但是要处理两个时刻不在同一天的情况，只需加上一天的秒数再模一天的秒数即可。

------------

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e8+10;
int t,n,a,b,c,e,f,g;
int hh,ans1,ans2,day;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>t;
	while(t--)
	{
		ans1=0,ans2=0,day=0;
		cin>>n>>a>>b>>c>>e>>f>>g;
		hh=0;
		for(;hh<n;hh++)
			day+=hh+1+hh*(hh+1)/2*10;

		hh=0;
		for(;hh<a;hh++)
			ans1+=hh+1+hh*(hh+1)/2*10;
		ans1+=b+b*(b-1)/2*10;
		ans1+=c;

		hh=0;
		for(;hh<e;hh++)
			ans2+=hh+1+hh*(hh+1)/2*10;
		ans2+=f+f*(f-1)/2*10;
		ans2+=g;

		cout<<(ans2-ans1+day)%day<<'\n';
	}
	return 0;
}


```


---

## 作者：DFM_O (赞：1)

## [B3856 题目](https://www.luogu.com.cn/problem/B3856)

### 解题思路
由题意易知，第 $i$ 个小时共有
$$ \begin{aligned} \sum_{j=0}^i(10\times j+1)&=10\times\sum_{j=0}^i(j)+i+1\\&=\frac {i\times(i+1)}  {2}\times10+i+1\\&=5i\times(i+1)+i+1\\&=5i^2+6i+1\end{aligned}$$
秒。

用此公式算出给出的两个时刻分别是一天的第多少秒并相减，若结果为负，加上一整天一共的秒数即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int zh(int s,int f,int m)
{
	int s1=m+3;
	s1+=(10*pow(s*1.0,3.0)+33*pow(s*1.0,2.0)+29*s)/6;
	s1+=f*(5*f+6);
	return s1;
}
signed main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	for(int ii=1;ii<=t;ii++)
	{
		int n,a,b,c,e,f,g,s,en,d,ss;
		cin>>n>>a>>b>>c>>e>>f>>g;
		a--,b--,c--,e--,f--,g--;
		s=zh(a,b,c),en=zh(e,f,g),d=zh(n-1,-1,-1);
		ss=en-s;
		if(ss<0)
			ss+=d;
		cout<<ss<<"\n";
	}
	return 0;
}
```

---

## 作者：wei2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3856)
## 思路：
暴力一看就不行，想优化。

在暴力的基础上更进一步，发现每个小时都有：
$$ {\textstyle \sum_{j=0}^{i}}(j \times 10+1) $$
秒。

再使用高斯求和公式：
$$(n+1) \times \frac{n}{2}$$
就可以变为：
$$(i+1) \times \frac{i}{2} \times (i \times 10 + 1)$$
时间复杂度足以通过题目，但是呢有可能不是在同一天，怎么办呢？只要用差值取模一天的秒数即可。但是在数据量大时会有偏差，所以还要加上一天的秒数。
## code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long t;
	cin>>t;
	while(t--){
		long long n,a,b,c,d,e,f,ans1=0,ans2=0,day=0;
		cin>>n>>a>>b>>c>>d>>e>>f;
		for(long long i=0;i<n;i++){
			day+=i+1+i*(i+1)/2*10;
		}
		for(long long i=0;i<a;i++){
			ans1+=i+1+i*(i+1)/2*10;
		}
		ans1+=b+b*(b-1)/2*10;
		ans1+=c;
		for(long long i=0;i<d;i++){
			ans2+=i+1+i*(i+1)/2*10;
		}
		ans2+=e+e*(e-1)/2*10;
		ans2+=f;
		cout<<(ans2-ans1+day)%day<<endl;
	}
	return 0;
}
```



---

## 作者：danb123 (赞：0)

## 题目大意
给定两个时段，给定了时间的定义，问这两个时间点的差。
## 题目分析
看一下数据范围就知道，这道题是数学题。我们要先算出它这两个时间点对应的秒数。再根据秒数进行计算。

1. 输入。
1. 计算其对应的秒数。
1. 计算时间差。
1. 输出。

好了，思路理好了。那么重点是什么呢？~~输入输出~~计算其对应的秒数。那么首先要怎么计算呢？我们可以先用一个前缀和数组，把每一分钟对应的秒数递增，再根据分钟数算出小时数。
```
for(int i=1;i<=100000;++i)fen[i]=fen[i-1]+(ll)(10*i+1);
//每分钟=前一分钟+(长整型)10*分钟数+1(前一分钟增加的分钟)
for(int i=1;i<=100000;++i)shi[i]=shi[i-1]+fen[i];
```
接下来是计算时间对应的秒数，有了这个数组就好算了。
```
//小时数对应的秒数+分钟对应的秒数+秒数
(a?shi[a-1]:0)+(b?fen[b-1]:0)+c)
```
## 完整代码
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,a,b,c,g,e,f,shi[100005],fen[100005];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),cin>>t,shi[0]=fen[0]=1;
	for(int i=1;i<=100000;++i)fen[i]=fen[i-1]+(ll)(10*i+1);
	for(int i=1;i<=100000;++i)shi[i]=shi[i-1]+fen[i];
	while(t--)cin>>n>>a>>b>>c>>e>>f>>g,(((e?shi[e-1]:0)+(f?fen[f-1]:0)+g)<((a?shi[a-1]:0)+(b?fen[b-1]:0)+c))?cout<<((e?shi[e-1]:0)+(f?fen[f-1]:0)+g)+shi[n-1]-((a?shi[a-1]:0)+(b?fen[b-1]:0)+c)<<endl:cout<<((e?shi[e-1]:0)+(f?fen[f-1]:0)+g)-((a?shi[a-1]:0)+(b?fen[b-1]:0)+c)<<endl;
	return 0;}
```
十行代码轻松解决。

---

## 作者：王逸辰 (赞：0)

## 解题思路:

很简单的一道题，算出给出的两个时刻分别是一天的第多少秒并相减，若结果为负，加上一整天一共的秒数即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//别忘了!
int zh(int s,int b,int e){
    int ss=e+3;
    ss+=1.0*(10*pow(s,3)+33*pow(s,2)+29*s)/6;
    ss+=b*(5*b+6);
    return ss;
}
signed main(){
    int T;
    cin>>T;
    while(T--){
        int n,a,b,c,e,f,g;
        cin>>n>>a>>b>>c>>e>>f>>g;
        --a,--b,--c,--e,--f,--g;
        int s,ss,sss,ssss;
        s=zh(a,b,c);
		sss=zh(e,f,g);
		ssss=zh(n-1,-1,-1);
        ss=sss-s;
        if(ss<0)
            ss+=ssss;
        cout<<ss<<endl;
    }
    return 0;
}
```

---


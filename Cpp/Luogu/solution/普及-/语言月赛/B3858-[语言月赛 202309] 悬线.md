# [语言月赛 202309] 悬线

## 题目背景

我们定义一个数字是质数，当且仅当它的因子仅有 $1$ 和自身。特别的，$1$ 不是质数。

## 题目描述

给定一个 $n \times m$ 的数字阵。约定第 $i$ 行第 $j$ 列上的数用 $(i,j)$ 表示。

我们称以第 $i$ 行第 $j$ 列的格子为底的**悬线**的长度是最大的 $k$，满足 $k \leq i$ 且 $(i,j), (i-1,j), (i-2,j),\dots(i-k+1,j)$ 这 $k$ 个数都是**质数**。特别的，如果 $(i, j)$ 本身不是质数，称以第 $i$ 行第 $j$ 列为底的悬线长度为 $0$。

对于每个格子，请你求出以它为底的悬线长度。

## 说明/提示

### 数据规模与约定

- 对 $20\%$ 的数据，$n = 1$。
- 对 $50\%$ 的数据，$(i,j) \leq 100$。
- 对 $80\%$ 的数据，$(i,j) \leq 1000$。
- 对 $100\%$ 的数据，$1 \leq n, m \leq 200$，$1 \leq (i,j) \leq 10^5$，$1 \leq T \leq 15$。

## 样例 #1

### 输入

```
1
3 3
1 2 3
4 5 6
7 8 9```

### 输出

```
0 1 1
0 2 0
1 0 0```

# 题解

## 作者：zhang_Jimmy (赞：3)

# 思路

我们可以另外定义一个 $f$ 数组，$f_{i,j}$ 表示以第 $i$ 行第 $j$ 列格子为底的悬线的长度。

如果 $a_{i,j}$ 是质数，那么就从 $a_{i-1,j}$ 上的悬线长度延伸过来，也就是 $f_{i,j}=f_{i-1,j} + 1$。

如果 $a_{i,j}$ 不是质数，那么 $f_{i,j} = 0$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int t, n, m, a[210][210], f[210][210];

bool prime(int n){
	if(n == 1) return 0;
	if(n == 2) return 1;
	for(int i = 2; i <= sqrt(n); i ++)
		if(n % i == 0) return 0;
	return 1;
}

int main(){
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	cin >> t;
	while(t --){
		memset(f, 0, sizeof f);
		cin >> n >> m;
		for(int i = 1; i <= n; i ++){
			for(int j = 1; j <= m; j ++){
				cin >> a[i][j];
			}
		}
		for(int i = 1; i <= n; i ++){
			for(int j = 1; j <= m; j ++){
				if(prime(a[i][j]))
					f[i][j] = f[i - 1][j] + 1;
				else 
					f[i][j] = 0;
			}
		}
		for(int i = 1; i <= n; i ++){
			for(int j = 1; j <= m; j ++){
				cout << f[i][j] << " ";
			}
			cout << endl;
		}
	}
	return 0;
}

```


---

## 作者：I_AM_AC_KING (赞：3)

本题还是可以用基础的知识来完成，主要运用枚举和判断质数，还有数组。

判断质数需要注意**特判**，**枚举**所有因数。

根据给出的条件，即可计算悬线长度！读题很重要！

题目中说：特别的，如果 $(i, j)$ 本身不是质数，称以第 $i$ 行第 $j$ 列为底的悬线长度为 $0$。

请不要忘了这一点，可以初始化数组时就将数组清零。

---

## 作者：xujunlang2011 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3858)

## 思路

首先枚举 $(i,j)$ 的所有因数，判断 $(i,j)$ 是不是质数,给质数打个标记。

然后从上往下，从左往右遍历每一个 $(i,j)$，如果 $(i-1,j)$ 为质数，则 $(i,j)$ 的悬线长度为 $(i-1,j)$ 的悬线长度加一，如果 $(i-1,j)$ 不为质数，或者 $(i-1,j)$ 根本不存在，则 $(i,j)$ 的悬线长度为 $0$。

最后把每个格子的悬线长度输出就行了。

这里我预处理了所有可能出现的 $(i,j)$ 是否为质数，查询的时候就可以 $O(1)$ 输出。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool p[100005];
int a[205][205];
inline int pri(int a)
{
	if (a == 1)
	{
		return 0;
	}
	for (int j = 2;j * j <= a;j++)
	{
		if (a % j == 0)
		{
			return 0;
		}
	}
	return 1;
}
int main()
{
    std::ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    for (int i = 1;i <= 100000;++i)
    {
        p[i] = pri(i);
    }//预处理
	int t;
	cin >> t;
	for (int ti = 1;ti <= t;++ti)
	{
		int n, m, x;
	    cin >> n >> m;
	    for (int i = 0;i <= n;++i)
	    {
	    	for (int j = 0;j <= m;++j)
	    	{
	    		a[i][j] = 0;
	    	}
	    }
	    for (int i = 1;i <= n;++i)
	    {
	    	for (int j = 1;j <= m;++j)
	    	{
	    		cin >> x;
	    		a[i][j] = p[x];
	    	}
	    }//判断质数
	    for (int i = 1;i <= n;++i)
	    {
	    	for (int j = 1;j <= m;++j)
	    	{
	    		if (a[i][j])
	    		{
	    			a[i][j] += a[i - 1][j];
	    		}
	    	}
	    }//计算悬线长度
	    for (int i = 1;i <= n;++i)
	    {
	    	for (int j = 1;j <= m;++j)
	    	{
	    		cout << a[i][j] << " ";
	    	}
	    	cout << "\n";
	    }//输出
	}
    return 0;
}
```


---

## 作者：__delta_epsilon__ (赞：0)

### 题目大意

对于 $n\times m$ 数字矩阵 $A$，使得 $A_{i-k+1,j},A_{i-k+2,j},\cdots,A_{i-1,j},A_{i,j}$ 均为质数的最大的 $k$，多组数据。

### 思路分析

显然对于每一组数据，先初始化一个二维数组用于判断每一个数是否为质数。

判断质数，我们可以通过枚举 $2\sim\sqrt{n}$ 中的每一个整数，如果能够整除，则为合数，否则为质数。即，

```
bool isPrime(int n) {
	if (n <= 1)
		return false;
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0)
			return false;
	}
	return true;
}
```

接着，我们只需要对于每一个格子依次按照题意模拟即可。

```
for(int i = 1; i <= n; i++)
	for(int j = 1; j <= m; j++) {
		int x = i, cnt = 0;
		while(b[x][j] && x > 0) // x > 0 防止越界。
			// 我们设 b[i][j] 为 a[i][j] 是否为质数。
			cnt++, x--; // 枚举下一个位置。
		cout << cnt << " \n"[j == m];
	}
```

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int T, n, m, a[202][202];
bool b[202][202];
bool isPrime(int n) {
	if (n <= 1)
		return false;
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0)
			return false;
	}
	return true;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while(T--) {
	    memset(b, 0, sizeof b);
	    cin >> n >> m;
	    for(int i = 1; i <= n; i++)
	        for(int j = 1; j <= m; j++)
	            cin >> a[i][j];
	    for(int i = 1; i <= n; i++)
	        for(int j = 1; j <= m; j++)
	            if(isPrime(a[i][j]))
	                b[i][j] = 1;
	    for(int i = 1; i <= n; i++)
	        for(int j = 1; j <= m; j++) {
	            int x = i, cnt = 0;
	            while(b[x][j] && x > 0)
	                cnt++, x--;
	            cout << cnt << " \n"[j == m];
	        }
	}
	return 0;
}
```

---

## 作者：Yun_Mengxi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3858)

## 题意

给定一个 $n\times m$ 的矩阵 $a$，定义以 $(i,j)$ 为底的悬线的长度为 $k$ 有且仅有 $a_{i,j},a_{i-1,j},a_{i-k+1,j}$ 这几个数都为质数，求以 $\forall 1\le i\le n, 1\le j\le m$，以 $(i,j)$ 为底的悬线最大的长度。

## 分析

如果一个数除了 $1$ 和它本身之外没有任何因数，那么我们称这个数为质数，所以，可以用下列代码求出一个数 $num$ 是不是质数：

```cpp
bool pd(long long num) {
  if (num == 1) return 0;              // 特殊的，1 不是质数
  for (int i = 2; i * i <= num; i++) { // 枚举可能是 num 的因数的数
    if (num % i == 0)                  // 如果有其他的因数
      return 0;                        // 说明这个数不是质数
  }
  return 1;                            // 到了这里就说明这个数没有其他因数，是质数
}
```

然后，对于 $\forall 1\le i\le n, 1\le j\le m$，定义 $a_{i,j}$ 为以 $(i,j)$ 为底的最大悬线长度，因为 $a_{i-1,j}$ 要么越界，要么在之前的输入中已经处理过了，所以可以推出式子 $a_{i,j}=\begin{cases}a_{i-1,j}+1,\operatorname{pd}(val_{i,j})=1\\0,\operatorname{pd}(val_{i,j})=0\end{cases}$，其中，$val_{i,j}$ 表示 $(i,j)$ 的值。

最后输出就可以了。

时间复杂度大概为 $O(nm\sqrt{val})$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

long long n, m, a[205][205], val[205][205];

bool pd(long long num) {
  if (num == 1) return 0;              // 特殊的，1 不是质数
  for (int i = 2; i * i <= num; i++) { // 枚举可能是 num 的因数的数
    if (num % i == 0)                  // 如果有其他的因数
      return 0;                        // 说明这个数不是质数
  }
  return 1;                            // 到了这里就说明这个数没有其他因数，是质数
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  int t;
  cin >> t;
  while (t--) {
    fill(a[1], a[n + 1], 0);           // 多测初始化
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= m; j++) {
        cin >> val[i][j];
        if (pd(val[i][j])) {
          a[i][j] = a[i - 1][j] + 1;   // 如果 val[i][j] 是质数
        } else {
          a[i][j] = 0;                 // 如果 val[i][j] 不是质数
        }
        cout << a[i][j] << " ";        // 边输入边输出
      }
      cout << '\n';                    // 记得输出换行
    }
  }
  return 0;
}
```

---

## 作者：一扶苏一 (赞：0)

## Source & Knowledge

2023 年 09 月语言月赛，由洛谷网校入门计划/基础计划提供。

---

## 文字题解

### 题意简述

给定一个矩阵，对每个元素求以它为底端的最长连续质数数值段长度。

### 解析

首先可以预处理出每个数字是不是一个质数，采用如下函数进行质数判定：

```cpp
bool isPrime(int x) {
  if (x <= 1) return false;
  for (int i = 2; i * i <= x; ++i) if (x % i == 0) return false;
  return true;
}
```

这样可以用大约 $\sqrt x$ 的运算量判定一个数是不是质数，其原理在于每个质数都肯定有一个不大于 $\sqrt x$ 的质因子。

可以用一个数组来存储每个位置是不是质数：

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= m; ++j)
    prm[i][j] = isPrime(a[i][j]);
```

接着，只需要枚举每个格点，然后向上枚举悬线的长度即可：

```cpp
for (int i = 1; i <= n; ++i) 
  for (int j = 1; j <= m; ++j) {
    cin >> a[i][j];
    int k = 1;
    while (k <= i) if (prm[a[i - k + 1][j]]) ++k;  else break;
    cout << k - 1 << " \n"[j == m];
  }
```

这里枚举的 $k$ 其实是悬线的长度 +1，当悬线的上一个格子 $a_{i-k+1,j}$ 不是质数时，找到的恰好就是悬线的长度，即 $k-1$，输出即可。

这样，我们用了 $n^2m$ 的运算量计算每个格子的悬线长度，$nm \sqrt x$ 的运算量计算每个格子是不是质数。二者相加的数量级是 $10^8$，是一个可以接受的算法。

## 视频题解


---


# [语言月赛 202401] 二进制与一

## 题目描述

给定一个正整数 $n$，以及操作次数 $q$。对于每次操作，给出一个正整数 $k$，要求：让 $n$ 加上一个非负整数 $x$，使得 $n$ 在二进制下的第 $k$ 位（从右往左数）是 $1$，并在符合要求的情况下，令 $x$ 最小。

请注意，每次操作都会让 $n$ 变为 $n + x$，会影响后续操作。

小山需要求出，所有的 $x$ 之和是多少。

## 说明/提示

### 样例 1 说明
$5$ 在二进制下是 $101$。

- 对于第一次操作，需要让 $101$ 的第二位变为 $1$，则需让 $101$ 加上 $1$，变为 $110$；
- 对于第二次操作，需要让 $110$ 的第三位是 $1$，由于 $110$ 的第三位本身就是一，所以无需改变；
- 第三次操作同理，需要让 $110$ 加上 $2$。

最终输出结果是 $1+0+2=3$。

### 数据规模与约定

对于 $100\%$ 的数据，$1\le n < 2^{32}，1\le q\le 10^5，1 \le k\le 32$。

| 测试点编号 | $n$ | $q$ | $k$ |
| :-: | :-: | :-: | :-: |
| $1$ | $\leq 4$ | $\leq 10$ | $\leq 2$ |
| $2, 3$ | $\leq 4$ | $\leq 10$ | $\leq 32$ |
| $4, 5$ | $\leq 1024$ | $\leq 1000$ | $\leq 10$ |
| $6, 7$ | $< 2 ^ {32}$ | $\leq 10$ | $\leq 32$ |
| $8 \sim 10$ | $< 2 ^ {32}$ | $\leq 10 ^ 5$ | $\leq 32$ |

## 样例 #1

### 输入

```
5 3
2
3
4
```

### 输出

```
3
```

# 题解

## 作者：szh_AK_all (赞：12)

出题人题解。

## 分析
我们有一个数 $n$，如要使 $n$ 在二进制下从右往左数的第 $k$ 位为 $1$，则需判断这一位是否为 $1$，如果是，则无需进行任何操作，否则，$n$ 会改变，操作数也会改变。

举个例子：考虑 $5$ 在二进制下的第 $2$ 位是否为 $1$。$5$ 在二进制下表示为 $101$，第二位为 $0$。可以发现，一个数在二进制下的第 $k$ 位是否为 $1$ 与最高位到第 $k+1$ 位无关，所以，我们要取出这个数的第 $1$ 位到第 $k$ 位。

如何取出这个数的第 $1$ 位到第 $k$ 位呢？只需要这个数对 $2^{k}$ 取模即可。因为，这个数在二进制下的第 $1$ 位到第 $k$ 位一定小于 $2^{k}$，而最高位到第 $k+1$ 位一定是 $2^{k}$ 的倍数。同上面的例子一样，$5$ 对 $2^{2}$ 取模，得到 $1$，也就是二进制下的 $01$;

假设令 $n$ 在二进制下的第 $k$ 为 $1$ 需要 $n$ **至少**加上 $t$，那么 $t$ 就是操作数。由于操作数要尽可能小，那么我们需要让 $n$ 在二进制下的第 $1$ 到第 $k$ 为的值为 $2^{k-1}$。举个例子，若要使一个数在二进制下的第 $4$ 位为 $1$，只需让这个数在二进制下的第 $1$ 到第 $k$ 位在二进制下表示为 $1000$。如果表示为 $1001$ 则不是最优操作。所以，在最优情况下，操作数为 $ 2^{k-1} - (n \bmod (2^k))$

如果 $n$ 在二进制下的第 $k$ 位本身就是 $1$，那么取出的第 $1$ 到第 $k$ 位肯定大于或等于 $2^{k-1}$，所以在计算操作数时将 $ 2^{k-1} - (n \bmod (2^k))$ 与 $0$ 取个最大值即可。
局部代码如下：
```cpp
lg[0] = 1;
for (int i = 1; i <= 32; i++)
		lg[i] = lg[i - 1] * 2;
...
int k;
cin >> k;
if (lg[k - 1] > (n % lg[k])) {
	ans += lg[k - 1] - (n % lg[k]);
	n += lg[k - 1] - (n % lg[k]);
}
```


---

## 作者：Maxmilite (赞：11)

## Source & Knowledge

2024 年 1 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定正整数 $n$ 和操作次数 $q$，在操作中每次给出一个正整数 $k$，求最小的 $x$ 使 $n + x$ 的二进制从右往左（由低位向高位）数的第 $k$ 位是 $1$。
	
## 题目分析

本题考察对循环结构的运用和对二进制的理解。

首先介绍 C/C++ 中的两个运算符 `<<`、`>>`。`<<` 代表二进制左移，`>>` 代表二进制右移。

在无符号非负整数中，在不溢出的情况下，`x << y` 代表将 `x` 在二进制表示下所有数位向左移动 `y` 位，原最高的 `y` 个二进制位直接舍弃，且末尾补 `y` 个零；`x >> y` 代表将 `x` 在二进制表示下所有数位向右移动 `y` 位，原最末尾的 `y` 个二进制位直接舍弃，且高位补 `y` 个零。

在不溢出的一般情况下，无符号非负整数左移一位可以认为是 $\times ~ 2$，右移一位可以认为是 $\div ~ 2$ 后下取整。

同时 C/C++ 中有一个逻辑运算符 `&`，代表按位与。`x & y` 代表 `x` 和 `y` 在二进制下按位做与操作（即两个对应的二进制位均为 $1$ 结果才为 $1$）后的结果，例如 `1 & 1 = 1, 0 & 1 = 0, 1 & 0 = 0, 0 & 0 = 0`。

因此，对于这道题而言，如果想要找到最小 $x$，需要做以下两个步骤：

1. 判断当前 $n$ 的第 $k$ 位是否为 $1$；
2. 计算 $x$ 的最小值。

### 判断

我们可以注意到，`1 << (k - 1)` 代表将 $00\cdots 001$ 左移 $k - 1$ 位，变为 $00 \cdots 00 \underbrace{1} _ {\text{第 } k \text{ 位}} \underbrace{0 \cdots 0} _ {k - 1 \text{ 个 } 0}$，即 $2 ^ {k - 1}$。

此时，如果我们将 $n$ 和 $2 ^ {k - 1}$ 作按位与（`&`）运算，并判断结果是否不为 $0$，即可得到 $n$ 的第 $k$ 位是否为 $1$（按位与运算结果不为 $0$ 则 $n$ 的第 $k$ 位为 $1$，直接令 $x = 0$ 即可）。

### 计算

当 $n$ 的第 $k$ 位不为 $1$ 时，我们可以注意到，如果将 $n$ 对 $2 ^ {k - 1}$ 取模，就可以得到 $n$ 的最末尾 $k - 1$ 个二进制位的十进制结果 $c$。

此时，我们让 $x = 2 ^ {k - 1} - c$，即可让 $n + x = n - c + 2 ^ {k - 1}$ 的二进制第 $k$ 位变成 $1$，而 $1 \sim k - 1$ 位都变成 $0$。这便是最小的 $x$ 的求法。

### 核心代码

```cpp
while (q--) {
    long long k;
    cin >> k;
    --k; // 得到 k - 1
    if (n & (1ll << k)) continue; // 1ll = ((long long) 1)
    long long c = n % (1ll << k);
    ans += (1ll << k) - c;
    n += (1ll << k) - c;
}
```

## 视频讲解

![](bilibili:BV1pK4y117QA?page=7)

---


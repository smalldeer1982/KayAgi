# [语言月赛 202405] 最大的和

## 题目描述

小 S 喜欢连在一起的数字，如果这些数字的和很大就更好了。

所以她现在要给你一个 $n$ 行 $n$ 列的网格 $A$，第 $i$ 行第 $j$ 列上填有一个**整数** $A_{i, j}$。

接下来你可以在 $A$ 上任取**一行**、**一列**或**一条与任意对角线平行**且**只经过网格交叉点**的**直线**（注意，不是线段），满足经过至少一个数字，且经过的数字之和最大。

如果对上面的表述有疑惑，请参考**样例解释**辅助理解。

你需要告诉小 S 这个最大的数字之和。

## 说明/提示

### 样例 1 解释

对于样例 $1$，不难看出第 $3$ 行数字之和最大，有 $3 + 3 + 3 = 9$。

### 样例 2 解释

对于样例 $2$，数字之和最大的，满足条件的线如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3srzjj2n.png?x-oss-process=image)

此时有 $4 + 9 = 13$。

注意，因为要求与对角线平行的直线只能经过**网格交点**，所以并不能出现同时取 $4, 1, 9$ 或同时取 $4, 1, 9, 2$ 这样的情况。

### 样例 $3$ 解释

取某条只经过一个 $-1$ 的直线即为最大。注意，不可以一个数字都不选。

### 样例 $4$ 解释

显然，取斜着的线一定不优，只能选择中间那一行或一列，答案是 $-10 + 99999 - 10 = 99979$。

### 数据范围

对于前 $30 \%$ 的数据，保证 $A_{1, 1}$ 或 $A_{n, n}$ 的值为网格中**唯一的**非负整数。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，且最后一行中的数字之和为**最大值**。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，网格中不存在负数。  
对于 $100 \%$ 的数据，保证 $1 \leq n \leq 2 \times 10^3, -10^5 \leq A_{i, j} \leq 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3
-1 1 2
4 0 3
1 9 2
```

### 输出

```
13
```

## 样例 #3

### 输入

```
3
-1 -1 -1
-1 -1 -1
-1 -1 -1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3
-100 -10 -100
-10 99999 -10
-100 -10 -100
```

### 输出

```
99979
```

# 题解

## 作者：ShiRoZeTsu (赞：10)

## Source & Knowledge

2024 年 5 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定一个 $n \times n$ 的方阵，请你取一行，一列，或者**与对角线平行的一条只经过格点的直线**，满足经过的数字和最大。

## 题目分析

首先，开一个二维数组 `a` 来存储方阵上的数字：

```cpp
int a[2005][2005];
```

然后开两个变量 `ans` 和 `res`。 `ans` 代表最终答案，初始要赋值成一个很小的负数（比如 $-10^{18}$）；`res` 代表一个临时变量，用来统计某一行、某一列或某一斜线上的数字和。注意数据范围，要使用 `long long` 类型：

```cpp
long long res, ans = -1e18;
```

接下来考虑求出答案。取一行、一列的情况是好写的。对于取一行的情况，我们可以循环枚举每一行，然后分别算出每一行的数字和，用数字和去更新答案。写法如下：

```cpp
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[i][j];
    ans = max(ans, res);
}
```

取一列的情况同理，枚举列即可：

```cpp
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[j][i];
    ans = max(ans, res);
}	
```

接下来考虑如何求与对角线平行的情况。这里我们首先需要了解一个知识点：

- 考虑从**左上**到**右下**的对角线。对于任意一条与这个对角线平行的直线，其经过的所有格子的**行数与列数之差**一定相同。

我们这里画图来解释一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/hzlboh5z.png?x-oss-process=image)

首先，这是一个 $5 \times 5$ 的方阵。我们随便取一条从左上到右下的满足条件的斜线：

![](https://cdn.luogu.com.cn/upload/image_hosting/gda3u9vf.png?x-oss-process=image)

不难发现，$(2, 1), (3, 2), (4, 3), (5, 4)$ 都满足行数 $-$ 列数 $= 1$。大家也可以试试其它斜线，可以发现都满足上面的规律。

- 考虑从**右上**到**左下**的对角线。对于任意一条与这个对角线平行的直线，其经过的所有格子的**行数与列数之和**一定相同。

我们同样画图来解释一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/h730r7f0.png?x-oss-process=image)

不难发现，$(1, 4), (2, 3), (3, 2), (4, 1)$ 都满足行数 $+$ 列数 $= 5$。大家也可以试试其它斜线，可以发现都满足上面的规律。

因此，对于从左上到右下的斜线，我们可以选择**枚举行数与列数的差**，这样就相当于枚举了这条斜线。然后将斜线上的数字都加起来，去更新答案：

```cpp
//这里 i 代表正在枚举的行数与列数的差（左上到右下）
//行和列的最小值都是 1，最大值都是 n，所以这个差值最小就是 1-n，最大是 n-1
for(int i = 1-n; i <= n-1; i++) {
    res = 0;
    //然后枚举这条线上所有格子的行数 j
    //那么此时列数就等于 j-i
    for(int j = 1; j <= n; j++)
    //这里 j-i 还要判断范围，是因为要保证这个格子不能出界
        if(1 <= j-i && j-i <= n) res += a[j][j-i];
    ans = max(ans, res);
}
```

从右上到左下的斜线也类似：

```cpp
//这里 i 代表正在枚举的行数与列数的和（右上到左下）
//行和列的最小值都是 1，最大值都是 n，所以这个和值最小就是 2，最大是 n+n
for(int i = 2; i <= n+n; i++) {
    res = 0;
    //然后枚举这条线上所有格子的行数 j
    //那么此时列数就等于 i-j
    for(int j = 1; j <= n; j++)
        //这里 i-j 还要判断范围，是因为要保证这个格子不能出界
        if(1 <= i-j && i-j <= n) res += a[j][i-j];
    ans = max(ans, res);
}
```

最后输出答案即可：

```cpp
cout << ans << '\n';
```

## 视频讲解

![](bilibili:BV1nf42127oB?page=6)

---


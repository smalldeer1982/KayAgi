# [语言月赛 202501] 分队平衡

## 题目背景

F 题中的班级搞了一次知识竞赛，然后老师发现每一列同学之间差距过于悬殊，会导致较弱的几列同学参与积极性不高，因此老师想要进行一些调整，使得每一列同学的水平更为接近。

## 题目描述

一个班级里的所有同学排成了 $n$ 行 $m$ 列，其中从前往后第 $i$ 行、从左往右第 $j$ 列的同学知识水平为 $a_{i,j}$。

定义一次**调整**的流程如下：

- 老师首先会计算每一列同学的知识水平总和，然后对于总和等于最大值或者最小值的所有列，让这些列的同学全部离开座位，并在走廊上按照知识水平从高到低排成一队。
- 接下来，让这些同学按照蛇形顺序坐在空位上。具体地，从前往后坐，同一行内，第奇数行从左往右坐，第偶数行从右往左坐。

给出初始时每个座位上同学的知识水平，计算 $k$ 次调整后每个座位上同学的知识水平。

## 说明/提示

【样例 1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/h35fkwk1.png)

上图显示了一次调整的流程。
- 左边是原始的座位表，其中标红的两列是知识水平和最高的，标蓝的一列是知识水平和最低的。
- 中间的图为在走廊排队的过程，其中下划线表示产生的空位。
- 右边的图演示了蛇形顺序。

【样例 2 解释】

本样例演示了调整前所有列的总和都已经相等的特殊情况。

第一次调整中，所有同学都离座重新蛇形排列，班级里的座位变成了 $\begin{matrix}40 & 30 \\ 10 & 20\end{matrix}$。

第二次调整中，所有同学都离座重新蛇形排列，但是效果和调整前完全一致。

【数据范围】

对于全体数据，保证 $2 \le n,m\le 50$，$1\le k \le 10$，$1\le a_{i,j}\le 10^9$。（注：$10^9$ 是 $10$ 亿，也就是 $10\ 0000\ 0000$。）

本题共有 $20$ 个测试点，每个测试点 $5$ 分。每个测试点的特殊性质见下表（`Y` 表示保证该性质，`N` 表示不保证）：

|测试点编号|特殊性质 A|$a_{i,j}\le$|其他性质|
|:-:|:-:|:-:|:-:|
|$1,2$|Y|$10000$|$n=2$|
|$3\sim 5$|Y|$10000$||
|$6$|Y|$10^9$|$m=2$|
|$7\sim 9$|Y|$10^9$||
|$10$|N|$10000$|$n=2$|
|$11\sim 13$|N|$10000$|$k=1$|
|$14\sim 16$|N|$10000$||
|$17$|N|$10^9$|$k=1$|
|$18\sim 20$|N|$10^9$||

- 特殊性质 A：每次调整时只有两列同学离座。


## 样例 #1

### 输入

```
3 4 1
2 1 4 7
9 6 5 4
5 2 3 5
```

### 输出

```
9 7 4 6
4 5 5 5
2 2 3 1
```

## 样例 #2

### 输入

```
2 2 2
30 40
20 10
```

### 输出

```
40 30
10 20
```

## 样例 #3

### 输入

```
8 20 10
1324 730 465 1686 1369 2011 919 128 613 1705 315 152 869 1309 114 694 229 260 2887 2282
1415 1753 570 1508 1371 464 3493 2115 2909 424 1246 214 1776 1345 662 2825 3734 1329 2344 596
2936 420 732 2505 3456 322 641 314 441 1349 186 348 347 976 1553 3906 884 2917 297 2585
452 2447 2990 2286 439 856 1340 842 721 792 3557 1697 2023 4196 1492 1066 773 181 2884 2350
1401 1756 728 501 871 1142 2795 2013 206 2683 582 809 352 1337 271 137 130 3092 1038 388
1335 1540 514 1491 2393 518 394 2496 849 1873 537 5144 578 693 1304 1111 2480 297 214 2180
1078 642 4381 472 570 3609 846 576 3556 923 3427 1747 3168 575 2208 806 1104 2116 753 171
711 1396 296 211 207 1770 232 2168 1341 863 770 517 1499 197 3048 99 1302 484 195 124
```

### 输出

```
1324 730 465 1686 1369 3609 919 128 613 3168 315 152 2887 1309 114 694 229 260 2884 2282
1415 1753 570 1508 1371 2011 3493 2115 2909 2023 1246 214 2344 1345 662 2825 3734 1329 2683 596
2936 420 732 2505 3456 1873 641 314 441 1776 186 348 1770 976 1553 3906 884 2917 1705 2585
452 2447 2990 2286 439 1038 1340 842 721 1142 3557 1697 1349 4196 1492 1066 773 181 1499 2350
1401 1756 728 501 871 923 2795 2013 206 869 582 809 863 1337 271 137 130 3092 856 388
1335 1540 514 1491 2393 518 394 2496 849 578 537 5144 753 693 1304 1111 2480 297 792 2180
1078 642 4381 472 570 464 846 576 3556 424 3427 1747 352 575 2208 806 1104 2116 347 171
711 1396 296 211 207 195 232 2168 1341 214 770 517 297 197 3048 99 1302 484 322 124
```

# 题解

## 作者：yummy (赞：3)

本题为语法综合题，考查选手的二维数组、简单排序的知识，整体相对套路，因此较多选手反馈不如 G 题困难。

本题完全依照题意模拟即可。以下每条分割线表示一处小坑或难点。

---

本题把每一列同学作为一个整体，$n,m$ 谁是行谁是列容易弄混；$i,j$ 谁是行谁是列也容易弄混。

一种解决办法是规定 $i$ 表示第几行，$j$ 表示第几列，并从始至终采用同一套命名规则。

---

注意本题 $a_{i,j}\le 10^9$，尽管 $a_{i,j}$ 不会爆 `int`，但是计算每一列同学知识水平和（记为 `s[j]`）时，`s[j]` 会爆 `int`，要开 `long long`。

另外，对于每一次调整，我们计算 `s[j]` 时要记得清零，否则求出的总和会发生错误。

```cpp
		long long mxv=0,mnv=1e18;
		for(int j=1;j<=m;j++){
			s[j]=0;
			for(int i=1;i<=n;i++)
				s[j]+=a[i][j];
			mxv=max(mxv,s[j]);
			mnv=min(mnv,s[j]);
		}
```

---

使用 `cols[]` 来记录有哪些列离开座位了，`ccol` 表示有几列离开座位了。此时，可以用 `ccol*n+i` 来计算 `a[i][j]` 这个同学在走廊上的原始下标。令 `hall[i]` 为走廊上第 $i$ 个同学，有如下代码：

```cpp
		int ccol=0;
		for(int j=1;j<=m;j++){
			if(s[j]==mnv or s[j]==mxv){
				for(int i=1;i<=n;i++)
					hall[ccol*n+i]=a[i][j];
				ccol++;
				cols[ccol]=j;
			}
		}
```

---

排序时，如果大家只会从小到大排序而不会反过来，那么我们可以直接让 `hall[1]` 成为走廊上**倒数**第 $1$ 个同学。

蛇形排队时，一种写法是严格按照题意，对 `i%2` 进行讨论，另一种写法则是每次排完一行我就对 **`cols[]`** 数组翻转。这里采用前一种写法。

```cpp
		int chall=ccol*n;
		for(int i=1;i<=chall;i++)
			for(int j=chall;j>i;j--)
				if(hall[j-1]>hall[j])
					swap(hall[j-1],hall[j]);
		for(int i=1;i<=n;i++){
			if(i%2){
				for(int j=1;j<=ccol;j++){
					a[i][cols[j]]=hall[chall];
					chall--;
				}
			}
			else{
				for(int j=ccol;j>0;j--){
					a[i][cols[j]]=hall[chall];
					chall--;
				}
			}
		}
```

---


# [语言月赛 202503] 洗牌

## 题目描述

Alice 把 $2n$ 张扑克牌牌面朝下叠成一摞，并记住了从上到下每张扑克牌的种类（使用一个字符串表示）。之后，她将这摞牌交给 Bob 进行洗牌。

Bob 接过牌后，采用一种特殊的洗牌方式：
1. 首先，他从上到下取出前 $n$ 张牌划分为**左堆**，剩下的 $n$ 张牌划分为**右堆**；
2. 之后，他设定一个新的牌堆，并做 $2n$ 次操作。每次操作中，他随机从左堆或右堆的**顶部**取出一张牌，并放到新的牌堆的**顶部**。 

虽然 Bob 费尽心思洗牌，但 Alice 依然能记住洗好的牌中每张牌是来自左堆还是右堆。她用一个字符串 $ f $（下标从 $1$ 开始）记录了这个信息，其中：  
- $ f_i = \texttt{L} $ 表示第 $ i $ 次操作选择的牌来自**左堆**；
- $ f_i = \texttt{R} $ 表示第 $ i $ 次操作选择的牌来自**右堆**。

接下来，Bob 按顺序发牌：从洗好的牌堆顶部开始，他交替地把每张牌发给 Alice 和自己，第一张给 Alice，第二张给自己，第三张再给 Alice，以此类推。  

你的任务是计算出 Alice 最终拿到的所有牌，并按她**拿到牌的顺序**输出。


## 说明/提示

### 样例 1 解释

初始时牌堆中牌的种类从上到下依次为：$\texttt{A1,B2,C3,D4,E5,F6,G7,H8}$。

Bob 将其分为左右两堆，两堆中的牌的种类从上到下依次为：
- 左堆：$\texttt{A1,B2,C3,D4}$；
- 右堆：$\texttt{E5,F6,G7,H8}$。

在洗牌过程中，左堆、右堆、新的牌堆中从上到下牌的种类如下表所示：

| 操作次数 | 左堆（从上到下） | 右堆（从上到下） | 新的牌堆（从上到下） |
| :----------: | :----------: | :----------: | :----------: |
| 初始 | $\texttt{A1,B2,C3,D4}$ | $\texttt{E5,F6,G7,H8}$ | 空 |
| $1$（$\texttt{L}$） | $\texttt{B2,C3,D4}$  | $\texttt{E5,F6,G7,H8}$ | $\texttt{A1}$ |
| $2$（$\texttt{R}$） | $\texttt{B2,C3,D4}$  | $\texttt{F6,G7,H8}$ | $\texttt{E5,A1}$ |
| $3$（$\texttt{R}$） | $\texttt{B2,C3,D4}$  | $\texttt{G7,H8}$ | $\texttt{F6,E5,A1}$ |
| $4$（$\texttt{L}$） | $\texttt{C3,D4}$  | $\texttt{G7,H8}$ | $\texttt{B2,F6,E5,A1}$ |
| $5$（$\texttt{R}$） | $\texttt{C3,D4}$  | $\texttt{H8}$ | $\texttt{G7,B2,F6,E5,A1}$ |
| $6$（$\texttt{L}$） | $\texttt{D4}$  | $\texttt{H8}$ | $\texttt{C3,G7,B2,F6,E5,A1}$ |
| $7$（$\texttt{R}$） | $\texttt{D4}$  | 空 | $\texttt{H8,C3,G7,B2,F6,E5,A1}$ |
| $8$（$\texttt{L}$） | 空 | 空 | $\texttt{D4,H8,C3,G7,B2,F6,E5,A1}$ |

最终新的牌堆为：$\texttt{D4,H8,C3,G7,B2,F6,E5,A1}$。

按照发牌规则，第 $1, 3, 5, 7$ 张牌应当给予 Alice，因此 Alice 最终拿到的牌从前到后依次是 $\texttt{D4,C3,B2,E5}$。

### 数据规模与约定

本题共 $10$ 个测试点。对于 $100\%$ 的数据，$1\le n\le 100$。表示牌的种类字符串长度不超过 $5$，且仅会出现大小写字母和/或数字。$f$ 中 $\texttt{L}$ 和 $\texttt{R}$ 的出现次数相同。

| 测试点编号 | $n$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $=1$ | 无 |
| $2, 3$ | $\leq 10$ | 无 |
| $4$ | $\leq 100$ | 所有代表牌种类的字符串相同 |
| $5$ | $\leq 100$ | $f$ 的前 $n$ 个字符一定是 $\texttt{L}$，后 $n$ 个字符一定是 $\texttt{R}$ |
| $6$ | $\leq 100$ | $f$ 的前 $n$ 个字符一定是 $\texttt{R}$，后 $n$ 个字符一定是 $\texttt{L}$ |
| $7$ | $\leq 100$ | $f$ 为 $\texttt{L,R}$ 交替构成（即 $f_1, f_3, f_5, \cdots = \texttt{L}$，$f_2, f_4, f_6, \cdots = \texttt{R}$） |
| $8 \sim 10$ | $\leq 100$ | 无 |


## 样例 #1

### 输入

```
4
A1,B2,C3,D4,E5,F6,G7,H8
LRRLRLRL
```

### 输出

```
D4
C3
B2
E5
```

## 样例 #2

### 输入

```
4
1,2,1,2,1,2,1,2
LRRLRLRL
```

### 输出

```
2
1
2
1
```

## 样例 #3

### 输入

```
10
tLWd,V,72r,t,4o1Q,1AO,FPul,9,g,REF,m8Lb2,V23m,LbzH,Oc6a,th,6,E7u,KHSdt,vEjtU,TQy
RRLRLRRLRLRLLRLLLRRL
```

### 输出

```
REF
vEjtU
9
KHSdt
4o1Q
t
72r
Oc6a
LbzH
V23m
```

# 题解

## 作者：Maxmilite (赞：5)

# [语言月赛 202503] 洗牌 题解

## Source & Knowledge

本题来源于 2025 年 3 月的语言月赛，涉及字符串的简单运用。

## 文字题解

Alice 记住了一摞 $2n$ 张扑克牌的初始顺序，并知道 Bob 采用特定的洗牌方式。我们需要**还原 Bob 洗牌后的结果**，然后按**交替发牌规则**确定 Alice 拿到的牌，并输出这些牌的顺序。

---

首先处理输入部分。其主要难点在于带逗号的字符串的处理，即，将带逗号的字符串以逗号为分界切成若干牌。

我们假设读入的带逗号字符串为 $s$。这里提供两种方式，分别代表普通方法和利用 C++ `string` 的方法。

  **普通方法** 考虑从前到后遍历 $s$ 中的每个字符 $c$。过程中使用一个 `string tmp` 临时存储某个牌。当 $c$ 不为逗号，则将 $c$ 塞入 `tmp` 之后；当 $c$ 为逗号，则认为此时的 `tmp` 是一个完整的牌，将其存入需要的地方。

  ```cpp
  // 假设我们使用 string 数组 a 来存储所有的牌
  string a[205]; // n 最大为 100，共有 2n 张牌
  int cnt = 0; // cnt 表示目前已经存储了多少张牌
  
  ...
  
  // 假设带逗号字符串为 s
  cin >> s;
  string tmp;
  for (int i = 0; i < s.length(); i++) {
      char c = s[i];
      if (c != ',') {
          tmp += c;
      } else {
          ++cnt;
          a[cnt] = tmp;
          tmp = "";
      }
  }
  // 将最后一个牌存好，因为最后一个牌后没有逗号
  ++cnt; 
  a[cnt] = tmp;
  ```

  **`string` 方法** 使用 `string` 的 `find()` 方法和 `substr()` 方法。下简单介绍二者的使用方法：

  - `s.find(c, pos)`：查找字符。从 `string s` 的第 `pos`（从 0 开始）位出发，找 `c` 字符出现的第一个位置，返回这个位置的下标。
  - `s.substr(pos, n)`：截取子字符串。从 `string s` 的第 `pos` 位开始截取，截取出长度为 `n` 的子字符串，作为这个函数的返回值。

  对于这道题目而言，我们可以截取 $2n$ 次字符串。过程中使用一个 `cur` 变量，记录上一次截取截到了哪里。每一次截取时，我们找 `nxt = s.find(',', cur)`，则 `s.substr(cur, nxt - cur)` 则为需要的结果。

  ```cpp
  int cur = 0;
  for (int i = 1; i <= 2 * n; i++) {
      int nxt = s.find(',', cur);
      a[i] = s.substr(cur, nxt - cur);
      cur = nxt + 1;
  }
  ```

整个输入部分可做如下处理：

```cpp
char f[205];
int n;
string a[205];
string l[105], r[105]; // 分为左右两摞
cin >> n;
string s;
cin >> s;

// 用任意一种上面提到的方法处理 s

for (int i = 1; i <= n; i++) l[i] = a[i];
for (int i = 1; i <= n; i++) r[i] = a[i + n];

for (int i = 1; i <= 2 * n; i++) {
    cin >> f[i];
}

```  

---

之后考虑洗牌。为了方便处理，我们在读入部分将牌分为了 `l[], r[]` 两个堆。我们可以使用 `int lcnt, rcnt` 代表当前已经从 `l[]` 和 `r[]` 中拿了几张牌。

我们另开 `string b[205]` 用于存储洗好的牌（同样按照从顶到底的顺序）。在洗牌时，我们不断地往 `b` 的顶部摞牌，因此越早放入的牌越应当在底部，整体的摞牌顺序应当是从底到顶，即 `b[2 * n], b[2 * n - 1], ..., b[2], b[1]`。

由此，我们可以做一个 $i= 1 \sim 2n$ 的 `for` 循环，每次判断 `f[i] == 'L'` 或 `f[i] == 'R'`，并从对应的牌堆中取牌放入 `b[]` 即可。 

```cpp
for (int i = 1; i <= 2 * n; i++) {
    if (f[i] == 'L') {
        ++lcnt;
        b[2 * n - (i - 1)] = l[lcnt];
    }
    if (f[i] == 'R') {
        ++rcnt;
        b[2 * n - (i - 1)] = r[rcnt];
    }
}
// 2 * n - (i - 1) 这个公式在 i = 1, 2, 3... 时，
// 分别等于 2 * n (- 0), 2 * n - 1, 2 * n - 2, ...
```

---

最后的输出部分，`b[1], b[3], b[5], ...` 为 Alice 拿到的牌，使用一个步长为 $2$ 的 `for` 循环输出即可。

```cpp
for (int i = 1; i <= 2 * n; i += 2) {
    cout << b[i] << endl;
}
```

---


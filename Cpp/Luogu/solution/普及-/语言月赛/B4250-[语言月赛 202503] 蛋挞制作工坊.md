# [语言月赛 202503] 蛋挞制作工坊

## 题目描述

Alice 和 Bob 正在教小朋友们制作蛋挞。制作一个蛋挞需要 $m$ 种材料，编号 $1 \sim m$。一个蛋挞当中，材料 $i$ 需要 $g_i$ 克。

有 $n$ 个小朋友（编号为 $1 \sim n$）想要制作蛋挞，其中第 $i$ 个小朋友准备了 $c_{i,j}$ 克的材料 $j$。所有小朋友都用自己准备的材料制作了**尽可能多**的蛋挞。

现在蛋挞已经被食堂叔叔阿姨送进烤箱，小朋友们要排队领取自己的蛋挞，但是领取顺序成了一个难题。

Alice 提倡勤俭节约，所以她会**指定一种材料**，并让所有小朋友按照这种材料的剩余量从少到多排队，这种材料剩余量少的小朋友排在前面。

Bob 鼓励劳动，所以**在 Alice 指定的材料剩余一样多时**，Bob 会让制作出的蛋挞更多的小朋友排在前面；如果制作出的蛋挞也一样多，那么编号小的小朋友排前面。

你现在并不知道 Alice 指定的材料是材料 $1,2,\ldots,m$ 中的哪个，所以你想知道每一种情况下小朋友们的排队结果。


## 说明/提示

### 样例 1 解释

一共有 $2$ 种材料。制作一个蛋挞需要 $3$ 个 $1$ 号材料，$5$ 个 $2$ 号材料。

- $1$ 号小朋友有 $8$ 个 $1$ 号材料，$14$ 个 $2$ 号材料，可以制作 $2$ 个蛋挞。制作完成后，两种材料分别剩余 $8 - 2 \times 3 = 2, 14 - 2 \times 5 = 4$ 个；
- $2$ 号小朋友有 $4$ 个 $1$ 号材料，$9$ 个 $2$ 号材料，可以制作 $1$ 个蛋挞。制作完成后，两种材料分别剩余 $4 - 1 \times 3 = 1, 9 - 1 \times 5 = 4$ 个；

当 Alice 选择材料为 $1$ 号时，
- $1$ 号小朋友剩余 $2$ 个选定材料，$2$ 号小朋友剩余 $1$ 个选定材料；
- $2$ 号小朋友剩余材料比 $1$ 号少，因此 $2$ 号小朋友排在前面。

当 Alice 选择材料为 $2$ 号时，
- $1$ 号小朋友剩余 $4$ 个选定材料，$2$ 号小朋友剩余 $4$ 个选定材料；
- 二者剩余选定材料一样多，但 $1$ 号小朋友制作的蛋挞数量比 $2$ 号多，因此 $1$ 号小朋友排在前面。

### 数据规模与约定

本题共 $10$ 个测试点。对于 $100\%$ 的数据，$1\le n,m\le 50$，$1\le c_{i,j},g_i\le 10^9$（注：$10^9$ 是十亿）。

| 测试点编号 | $n$ | $m$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $= 1$ | $\leq 50$ | 无 |
| $2, 3$ | $\leq 50$ | $= 1$ | 无 |
| $4, 5$ | $\leq 50$ | $\leq 50$ | 所有 $g_i = 1$ |
| $6$ | $\leq 50$ | $\leq 50$ | 所有 $c_{i, j} = g_j$ |
| $7 \sim 10$ | $\leq 50$ | $\leq 50$ | 无 |



## 样例 #1

### 输入

```
2 2
3 5
8 14
4 9
```

### 输出

```
2 1
1 2
```

## 样例 #2

### 输入

```
3 2
3 5
8 14
1 4
4 9```

### 输出

```
3 2 1
1 3 2
```

## 样例 #3

### 输入

```
2 3
3 5 4
6 11 8
7 10 8
```

### 输出

```
1 2
2 1
1 2
```

# 题解

## 作者：Maxmilite (赞：2)

# [语言月赛 202503] 蛋挞制作工坊 题解

## Source & Knowledge  

本题来源于 2025 年 3 月的语言月赛，主要考察**较复杂题目的模拟与代码设计**和**冒泡排序**的应用。  

## 文字题解  

题目要求按照不同材料的剩余量对小朋友排序，因此我们需要进行如下计算和排序：

### 计算每个小朋友能制作的蛋挞数量 

由于制作蛋挞时，每种材料的用量不同，我们需要计算每个小朋友最多能做多少个蛋挞：
$$
\text{count}_i = \min\left( \frac{c_{i,1}}{g_1}, \frac{c_{i,2}}{g_2}, \dots, \frac{c_{i,m}}{g_m} \right)
$$
其中，$\text{count}_i$ 是第 $i$ 个小朋友能制作的蛋挞数量。

```cpp
int count[55];
// 读入部分省略，可参考前七道题目的题解学习
for (int i = 1; i <= n; i++) {
    count[i] = 1000000000;
    // 10 的 9 次方，十亿，所有小朋友能制作蛋挞的最大数目
    for (int j = 1; j <= m; j++) {
        count[i] = min(count[i], c[i][j] / g[j]);
    }
}
```

### 计算每个小朋友的剩余材料量

计算公式：
$$
\text{remain}_{i,j} = c_{i,j} - \text{count}_i \times g_j
$$
这里，$\text{remain}_{i,j}$ 表示第 $i$ 个小朋友在使用 $j$ 号材料制作蛋挞后剩余的材料量。

```cpp
int remain[55][55];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        remain[i][j] = c[i][j] - count[i] * g[j];
    }
}
```

### 按指定材料进行排序并输出

Alice 会按照指定的材料剩余量从小到大排序，如果剩余量相同，则按 Bob 的规则。因此我们有总的规则：
- **剩余量少的排在前面**
- **如果剩余量相同，则做的蛋挞多的排前面**
- **如果蛋挞数量相同，则按编号升序排**

按照这种排序规则，我们做冒泡排序。

由于过程中涉及到的变量众多，冒泡排序又是非常需要交换的一种排序方式，因此在交换小朋友时，直接交换所有涉及的变量不是很优秀。这里，我们做一些简化运算。

我们对每种材料，使用一个 `index` 数组。`index[i]` 表示，在排序后，站在第 `i` 位的小朋友的编号应该是多少。

这样，我们在排序时，只需要关心 `index` 数组的交换即可。比较时，可以通过 `remain[index[i]][...]` 等的方式来读取数据。

```cpp
int index[55];
for (int k = 1; k <= m; k++) { // 枚举 Alice 指定的
  for (int i = 1; i <= n; i++) index[i] = i;
  for (int i = 1; i <= n - 1; i++) { // 冒泡排序的两重循环
      for (int j = 1; j <= n - i; j++) {
          int a = index[j], b = index[j + 1];

          // 第一个规则
          if (remain[a][k] > remain[b][k]) {
              // 剩余指定材料不满足 a < b，应当交换
              swap(index[j], index[j + 1]);
          }

          // 第二个规则
          if (remain[a][k] != remain[b][k]) continue;
          if (count[a] < count[b]) {
              // 制作蛋挞数量不满足 a > b，应当交换
              swap(index[j], index[j + 1]);
          }

          // 第三个规则
          if (count[a] != count[b]) continue;
          if (a > b)) {
              // 编号不满足 a < b，应当交换
              swap(index[j], index[j + 1]);
          }
      }
  }

  for (int i = 1; i <= n; i++) {
      cout << index[i] << " ";
  }
  cout << endl;
}
```

---


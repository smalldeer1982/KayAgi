# [入门赛 #7] 狠狠地切割 (Hard Version)

## 题目背景

**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\forall i \in [1, n], \forall j \in [1, m], a _ i \neq b _ j$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$- 10 ^ {18} \leq a _ i, b_i \leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# 题解

## 作者：Double_Light (赞：12)

### 题意简述

- 给定两个数列 $a_{1,2,...,n},b_{1,2,...,m}$，$-10^{18} \ge a_i,b_i \ge 10^{18}$。

- 若 $a_i=b_j$，则 $a$ 数列沿着 $a_i$ 处割成左右两段，称为“狠狠地切割”。

- 求最后 $a$ 数列被割成了几段。

**注意**：

- 若 $a$ 数组有两个相邻的元素都被“狠狠地切割”过，则两元素中间**不算一个片段**。

- 若 $a$ 数组的第一个元素被“狠狠地切割”，则数组左边界**不算一个片段**。

例：若用 $|$ 表示“狠狠地切割”处，则对于数列 $|$ $4$ $5$ $|$ $|$ $2$ $|$ 而言，只有 $4$ $5$ 和 $2$ 属于片段。

### 题目分析

对于本题而言，代码主要部分为进行切割和统计片段两部分。

---

#### 第一部分--进行切割

注意数据范围：

对于 $100\%$ 的数据，保证$1\leq n,m\leq5\times10^5,1≤n,m≤5×10^5,-10^{18}\leq a_i,b_i\leq10^{18}-10^{18}≤a_i,b_i ≤10 ^{18}$,序列 $b$ 中的元素两两不同。

由于 $n$ 达到了 $5×10^5$，时间复杂度应小于 $\Theta(n^2)$， 所以我们不能用两重循环的方式来枚举 $a_i$ 和 $b_j$。

这时，我们可以使用一个巨好用的算法：**二分**。

我们来简单介绍一下二分（懂二分查找的读者可跳过本段）。

二分，此处指二分查找，是一种特殊的分治。

我们看看度娘对二分查找的解释：

首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

通俗来说，也就是给定一个长度为 $n$ 的有序数列（如升序）和一个将查找的数 $x$，将数列中最中间一个元素（称为 $a_i$）与 $x$ 进行比较，若 $x=a_i$，则数列中间的元素与 $x$ 的值相等。若 $x>a_i$，则二分查找从 $a_{i+1}$ 至 $a_n$ 的数，若 $x>a_i$，则二分查找从 $a_1$ 至 $a_{i-1}$ 的数。

这样做的好处在于，每次查找都可以帮我们排除一半的数，最多仅需 $\log n$ 次就可以找到 $x$ 在不在数列中，以及是数列的第几项。

那么，我们怎么用代码实现呢？

若对 $a_i$ 进行二分查找，则我们定义三个变量 $l,r,mid$，令 $l=1$，$r=n$，$mid$ 为 $l$ 和 $r$ 的平均数，即 $(l+r)/2$。

$l$ 代表二分的左端点，$r$ 代表二分的右端点，而 $mid$ 是数列最中间一个元素，将与 $x$ 进行比较。

我们做一个 ```while()``` 循环，循环条件是 ```l<=r```，意思是还有 $b_l\sim b_r$ 可能等于 $x$，若 $l>r$，则没有一个数 $b_j$ 可能等于 $a_i$。

循环内部则在更新 $mid$ 的值后将 $b_{mid}$ 与 $a_i$ 比较。

如果两者相等，则 $a_i$ 将被“狠狠地切割”。

如果 $b_{mid}<a_i$,则 $l=mid+1$，查找区间缩小，仅剩原来的右半区。

否则 $r=mid-1$，查找区间同样缩小，仅剩原来的左半区。

将本部分写成函数，对本题而言更方便。

别忘了先将 $b$ 数组进行 ```sort``` 排序。

二分查找的参考代码如下：

```cpp
bool check(long long k) {
	long long l=1,r=m,mid;
	while(l<=r){
		mid=(l+r)/2;
		if (k<b[mid])r=mid-1;
		else if(k>b[mid])l=mid+1;
		else return 1;
	}
	return 0;
}
```


---

#### 第二部分--统计片段



我们以数列 $|$ $4$ $5$ $|$ $|$ $2$ $|$ 为例，进行这部分的分析。

这是我们手动统计片段的过程：

1. 第一个元素被“狠狠地切割”过，此时并没有片段。

2. 第二个元素未被“狠狠地切割”，属于第一个片段。

3. 第三个元素与第二个元素间没有被“狠狠地切割”，两个元素同属于第一个片段。

4. 第四个元素被“狠狠地切割”过，第一个片段结束，此时共有一个片段。

5. 第五个元素也被“狠狠地切割”过，但并没有新的片段产生。

6. 第六个元素未被“狠狠地切割”，属于第二个片段。

7. 第七个元素被“狠狠地切割”过，第二个片段结束，此时共有两个片段。

结合过程，我们找到了以下规律：

若一个元素未被“狠狠地切割”过，且下一个元素被“狠狠地切割”过，则会有一个新的片段产生。

那么，我们就写出来了代码：

```cpp
for(int i=1;i<n;i++){
	if(!check(a[i])&&check(a[i+1]))ans++;
}
```

但别忘了，我们需加一个特判：

```cpp
if(!check(a[n]))ans++;
```

否则，是不能过 $a_n$ 没有被“狠狠地切割”的数据的。因为若 $a_n$ 没有被“狠狠地切割”过，则原来的代码是统计不到最后一个片段的。

---

最后，将两方面合并，加上输入输出和排序，我们就得到了完整的--

### AC 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,x,a[500005],b[500005],ans;
bool check(long long k) {
	long long l=1,r=m,mid;
	while(l<=r){
		mid=(l+r)/2;
		if (k<b[mid])r=mid-1;
		else if(k>b[mid])l=mid+1;
		else return 1;
	}
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&b[i]);
	sort(b+1,b+m+1);
	if(!check(a[n]))ans++;
	for(int i=1;i<n;i++){
		if(!check(a[i])&&check(a[i+1]))ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Maxmilite (赞：4)

# B3691 & P8889 [语言月赛202212] 狠狠地切割 题解

## Source & Knowledge

2022 年 12 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 文字题解

### 题目大意

给定一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。对序列 $a$ 中的每个位置，如果这个位置的数在 $b _ 1, \cdots, b _ m$ 中出现过，则在此进行一次切割。求最后序列被分割为了多少片段。

### 解析

本题的任务我们可以划分为两部分，第一部分为找到应该切割的位置，第二部分为计算片段数量。

第二部分较为简单，且实现方法多样，故这里不做过多的介绍，核心代码如下：

```cpp
int cnt = 0; // 标记当前一段片段的长度
for (int i = 1; i <= n; ++i) {
    if (a[i].isMarked) { // 使用 isMarked 记录当前点是否是切割点
        if (cnt) // 判断该切割点前是否存在片段
            ++ans;
        cnt = 0;
    } else {
        ++cnt;
    }
}
if (cnt) // 需要注意的是，序列的结尾不一定为切割点，所以这里要特殊处理一下
    ++ans;
```

重点放在第一部分「找到应该切割的位置」，这里介绍几种方法。

1. Easy Version 方法：使用数组记录
	
    我们注意到，在 Easy Version 中，保证给定的 $a _ i, b _ i$ 值域为 $[1, 5 \times 10 ^ 6]$，且题目内存限制为 512MB，因此我们可以直接开一个大小为 $5 \times 10 ^ 6$ 的数组 $v$，如果数字 $i$ 在 $b$ 中出现过，则 $v _ i$ 标记为 $1$，反之标记为 $0$。
    
    在第二部分，我们只需要查找 $v _ {a _ i}$ 是否为 $1$，即可知道 $a _ i$ 是否在 $b$ 中出现过。
    
2. Hard Version 方法：`unordered_map` 等

	在 Hard Version 中，$a _ i, b _ i$ 值域变为了 $[-10 ^ {18}, 10 ^ {18}]$，因此我们不能直接使用数组记录了。
    
    我们可以采用一些 STL 容器来进行这些操作，这里举例介绍一下使用 `map / unordered_map` 的具体流程。
    
    在本题中对 $b$ 中的元素，你可能需要存储一些形如 `[998244353..., true]` 的键值对，但是由于数组下标大小的限制，所以无法直接用元素作为下标来存储。
    
    这个时候，我们可以使用 `map / unordered_map` 将这些键值对进行存储。`map` 重载了 `operator[]`，可以使用任意定义了 `operator<` 的类型作为下标，诸如这里的 $b _ i$。
    
    具体的，对于上面诸如 `[998244353..., true]` 的键值对，我们可以按照如下方式进行存储和查询：
    ```cpp
    unordered_map<long long, bool> v;
    v[998244353] = true;
    if (v[998244353]) { /* ... */ }
    ```
    
    如果想对 `map` 进行进一步的学习，可以参照 <https://oi.wiki/lang/csl/associative-container/> 及 <https://oi.wiki/lang/csl/unordered-container/>，这里不再深究。
    
    因此本题对于 $b$ 中数据的记录，我们可以使用 `unordered_map` 完成。使用 `map` 在实现优秀的条件下可能也可以通过本题。
    
3. Hard Version 方法：二分查找

	我们可以将 $b$ 排序，对于每个 $a$ 中的元素，在 $b$ 中进行二分查找是否存在即可。
    
    这里不再对二分查找做过多的介绍。
    
4. Hard Version 方法：双指针

	我们可以将 $a, b$ 由小到大分别排序，建立指针 `cur`。对 $a$ 中每个元素 $a _ i$，在 $b$ 中找到第一个 $\geq a _ i$ 的元素的下标。并用 `cur` 对其记录。在查找下一个元素 $a _ {i + 1}$ 时，由于上一次的指针位置前的元素一定 $< a _ i \leq a _ {i + 1} $，因此只要从上一次的指针位置开始向后查找即可。
    
    不难发现，最劣情况下，数组 $b$ 只会被遍历一次。
    
    出题人使用的是这种办法，核心代码如下：

    ```cpp
    struct Node {
    	int num;
		lint val;
		int isMarked;
    } a[1000005];
    
    scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) {
		lint var;
		scanf("%lld", &var);
		a[i] = Node(i, var);
	}
	for (int i = 1; i <= m; ++i) {
		scanf("%lld", b + i);
	}
	b[m + 1] = (1ll << 60);
	b[0] = -(1ll << 60);
	sort(a + 1, a + n + 1, cmp);
	sort(b + 1, b + m + 1);
	for (int i = 1; i <= n; ++i) {
		while (b[cur] < a[i].val)
			++cur;
		if (b[cur] == a[i].val)
			a[i].isMarked = 1;
	}
    ```

## 视频题解

**完整代码请在视频中查看。**

![](bilibili:BV1id4y1e7yJ?page=8)

---

## 作者：xiaohaoaibiancheng66 (赞：3)

# 思路
暴力思路很简单：对于每个 $b_i$ ，查找每个 $a_i$ 将其标为一个不合法的值即可。

但这是 $O(n^2)$ 的，在 $n,m=5\times10^5$ 显然会超时，所以要优化。

考虑对于每个 $b_i$，在 $a$ 中**二分查找**。

但 $a$ 数组**不满足单调性**，所以要给其排序以满足单调性。最后还需**再次排序**以还原原数组。

复杂度 $O(n\log n+m\log n+n+n\log n)=O(n\log n)$，可以通过。

# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

struct f
{
	long long x,i;
}a[1000000+10]; 
long long b[1000000+10];

bool cmp1(f a,f b){return a.x<b.x;}//第一次排序
bool cmp2(f a,f b){return a.i<b.i;}//第二次排序

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>a[i].x,a[i].i=i;
	sort(a,a+n,cmp1);
	long long x;
	for(int i=0;i<n;i++)b[i]=a[i].x;//参照数组，以防修改后的结果影响二分。
	for(int i=0;i<m;i++)
	{
		cin>>x;
		int l=lower_bound(b,b+n,x)-b,r=upper_bound(b,b+n,x)-b;
		for(int j=l;j<r;j++)a[j].x=-1000000000000000001;//负无穷
	}
	int cnt=0;
	int ans=0;
	sort(a,a+n,cmp2);
	for(int i=0;i<n;i++)
		if(a[i].x==-1000000000000000001)
		{
			if (cnt)ans++;
			cnt=0;
		}
		else cnt++;
	if(cnt)ans++;
	cout<<ans;
	return 0;
}
```


---


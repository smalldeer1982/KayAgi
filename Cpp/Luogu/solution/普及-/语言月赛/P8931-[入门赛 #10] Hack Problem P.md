# [入门赛 #10] Hack Problem P

## 题目背景

这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

---
**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**

## 题目描述

以下给出三个问题的题目描述：

#### 问题 1

给出两个正整数 $x, y$，保证它们的最小公倍数（$\mathrm{lcm}$）不大于 $10^9$。求它们的最小公倍数。

#### 问题 2

**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \dots a_n]$，保证数组单调递增。有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。

#### 问题 3

**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \dots a_n]$，有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。

注：问题 $2$ 和问题 $3$ 除了在是否保证数组递增上有差异外，在数据范围上也有区别，见下。

## 说明/提示

### 样例组与实际输入的说明

三个样例分别对应三个问题的样例输入输出。

如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；

如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \leq x \leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。

显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。

### 数据规模要求

你给出的数据必须满足如下要求：

1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。
2. 数据中所有的数字都应为整数。
3. 对于问题 1，$1 \leq x, y \leq 10^9$，且你**必须保证**两数的最小公倍数也不超过 $10^9$。
4. 对于问题 2，$1 \leq T \leq 3$，$1 \leq n,q \leq 10^5$，$1 \leq a_i, x \leq 10^9$。
5. 对于问题 3，$1 \leq T \leq 3$，$1 \leq n, q, a_i, x \leq 10^6$。

### 目标代码

你需要 hack 如下的代码：

#### 问题 1

```cpp
#include <iostream>
#include <algorithm>

int main() {
  int x, y;
  std::cin >> x >> y;
  int ans = x * y / std::__gcd(x, y);
  std::cout << ans << std::endl;
}
```

#### 问题 2

```cpp
#include <iostream>
#include <algorithm>

const int maxn = 1000003;

int T;
int n, q;
int a[maxn], b[maxn];

int find(int x) {
  int l = 1, r = n;
  int ans = 0;
  while (l < r) {
    int mid = (l + r) >> 1;
    if (a[mid] <= x) {
      ans = mid;
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  return ans;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (std::cin >> T; T; --T) {
    std::cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
      std::cin >> a[i];
    }
    for (int x; q; --q) {
      std::cin >> x;
      std::cout << find(x) << " ";
    }
    std::cout << std::endl;
  }
}
```

#### 问题 3

```cpp
#include <iostream>

const int maxn = 1000003;

int T;
int n, q;
int a[maxn], b[maxn];

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (std::cin >> T; T; --T) {
    std::cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
      std::cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
      b[a[i]]++;
    }
    for (int i = 1; i < maxn; ++i) b[i] += b[i - 1];
    for (int x; q; --q) {
      std::cin >> x;
      std::cout << b[x] << " \n"[q == 1];
    }
  }
}
```

目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。

### 判分说明

本题共三个测试点，分别对应三个问题，每个问题 hack 成功则对应测试点返回 accepted。

#### 数据判定

你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。

#### 超时判定

程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。

如果程序的运行时间超过 $500 \text{ms}$，则判定为程序运行超时，返回 accepted 结果。

#### 结果错误判定

如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。

#### 未定义行为判定

我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。

这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。

### 样例程序

这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。

```cpp
#include <iostream>

using namespace std;

int main() {
  int taskId;
  cin >> taskId;
  if (taskId == 1) {
    cout << "" <<endl;
  } else if (taskId == 2) {
    cout << "" << endl;
  } else if (taskId == 3) {
    cout << "" << endl;
  } else { // 这个 else 不会被执行
    cout << "QiHai Nanami" << endl;
  }
}
```

如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：

```plain
ans.zip
 |---1.in
 |---2.in
 |---3.in
```

三个文件不应该被额外的文件夹包含，即文件结构不能是：

```plain
ans.zip
 |---ans(folder)
      |---1.in
      |---2.in
      |---3.in
```

### 关于评测信息的说明

如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。

例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。

特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。

## 样例 #1

### 输入

```
3 4```

### 输出

```
12```

## 样例 #2

### 输入

```
2
3 3
5 7 9
7 7 7
3 3
1 2 3
2 2 2```

### 输出

```
2 2 2 
2 2 2 
```

## 样例 #3

### 输入

```
2
3 3
4 4 5
4 5 6
3 3
1 1 3
1 2 3
```

### 输出

```
2 3 3
2 2 3
```

# 题解

## 作者：GeorgeAAAADHD (赞：10)

题目大意:

给定三个问题及解决这三个问题的代码，你需要出一组数据，使得代码出错。


------------
这是一道 Hack 题，让我们一个一个问题来看吧！


------------
1. 求 $x,y$ 的最小公倍数。

数据范围：$1 \le x,y \le 10^9$，且它们的最小公倍数也不超过 $10^9$。

分析：

注意到求答案时出现了 `x * y`，且它们均为 `int` 类型，于是我们可以使 `x * y` 爆 `int` 来使代码答案出错。

Code:
```cpp
if(taskId==1)cout<<"1000000000 1000000000";
//因为两数的最小公倍数也不能超过10^9，所以最容易想到的方法就是使两数相等。
```

------------
2. **$T$ 组数据**，每组数据给出一个长度为 $n$ 且单调递增的数组，进行 $q$ 次询问，每次询问该数组中有多少个数小于等于给定的数 $x$。

数据范围：$1 \le T \le 3$，$1 \le n,q \le 10^5$，$1 \le x,a_i \le 10^9$。

分析：

数组长度定义没有问题，因此无法使数组越界。

但是我们可以发现，在二分查找小于等于 $x$ 的数的个数时，判断条件为 `l < r`，因此我们可以使一开始的 $l$ 就等于 $r$，即给定一个长度为 $1$ 的数组，然后询问一个大于等于该数的 $x$，此时函数会返回 $0$，即输出了错误结果。

Code:
```cpp
if(taskId==2)printf("1\n1 1\n1\n2");
```

------------
3. **$T$ 组数据**，每组数据给出一个长度为 $n$ 的数组，进行 $q$ 次询问，每次询问该数组中有多少个数小于等于给定的数 $x$。

数据范围：$1 \le T \le 3$，$1 \le n,q,x,a_i \le 10^6$。

分析：

这题的代码使用了桶排序 + 前缀和，因此普通的超时做法不可行。

但是我们可以发现，输入完一组数据后程序并没有重新初始化 $b$ 数组，于是我们只需要构造两组一样的数据即可。

Code:
```cpp
if(taskId==3)printf("2\n3 3\n4 4 5\n4 5 6\n3 3\n4 4 5\n4 5 6");
```


------------
最后附上全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int taskId;
	cin>>taskId;
	if(taskId==1)cout<<1000000000<<' '<<1000000000;
	if(taskId==2)printf("1\n1 1\n1\n2");
	if(taskId==3)printf("2\n3 3\n4 4 5\n4 5 6\n3 3\n4 4 5\n4 5 6");
	return 0;
}
```

---

## 作者：_H17_ (赞：2)

首先对于问题 $1$：对于 `int ans = x * y / std::__gcd(x, y);` 中 `x * y` 可能会爆掉 `int` 导致 `WA`。因为 $x,y \le 10^9$，所以 HACK 数据就写 `1000000000 1000000000` 即可。

对于问题 $2$：注意到二分代码中 `while` 循环中的条件是 `l<r` 对于 `l=r=1` 这种情况完全不会执行。会导致返回值出错而 `WA`。
数据：
```
1
1 1
2
2
```

对于问题 $3$：首先有多组数据就要看是否是因为没初始化。对于变量和数组 `n,q,a[]` 都是输入或者直接赋值得到的。但是数组 `b[]` 则没初始化而且需要**累加**所以只要出多组数据让 `b` 数组在一个数那里累加多次即可。
数据：
```
2 
1 1
1
1
1 1
1
1
```

---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8931)

小清新 hack 题。

$Q1$：不开 `long long` 见祖宗，只要两数乘积溢出 `int` 范围并且其最小公倍数不超过 $10^9$ 就好了。

$Q2$：循环条件是 `l<r`，那么一旦要找 $a_n$ 就寄了，随便扔一组就行。

$Q3$：多测不清空，爆零两行泪。仅需给出两组数据即可。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
signed main(){
	int x;scanf("%d",&x);
	if(x==1)printf("1000000 1000000\n");
	if(x==2)printf("1\n1 1\n1\n1\n");
	if(x==3)printf("2\n1 1\n1\n1\n1 1\n1\n1\n");
    return 0;
}
```

[record](https://www.luogu.com.cn/record/104593222)

---

## 作者：Loser_Syx (赞：2)

## 思路

### 问题 1

观察数据范围 $1 \leq x,y \leq 10^9$，而给出的代码用的是 `int` 范围，还乘起来了！，那么我输出 $2$ 个 $10^9$，就一定会爆 `int`。

### 问题 2

观察它的二分代码，它二分判断结束语句的是 `while(l < r)`，而且赋值时 `r = n`，那么这段代码永远搜不到 $a_n$ 这个数，所以询问只要简单的询问一次 $a_n$ 就行了。

### 问题 3

观察代码，它是用桶排序做的，思路很正确，但是你会发现，它多测没有清空！这题的 Hack 只要让 $T > 1$，就可以成功 Hack 掉了。

## 代码

```cpp
#include <iostream>

using namespace std;

int main() {
  int taskId;
  cin >> taskId;
  if (taskId == 1) {
    cout << "1000000000 1000000000" <<endl;
  } else if (taskId == 2) {
    cout << "1\n10 1\n1 2 3 4 5 6 7 8 9 10\n10" << endl;
  } else if (taskId == 3) {
    cout << "2\n1 1\n1\n1\n1 1\n1\n1" << endl;
  } else { // 这个 else 不会被执行
    cout << "QiHai Nanami" << endl;
  }
  return 0;
}
```

---

## 作者：AKPC (赞：0)

### 前言
萌新第一次写 hack 题，也是第一次写入门赛的题解。

不过也没什么难的，就是出**刁钻**的数据故意让源代码 AC 不了就行了。
### 思路
第一题简直就是不开 long long 见祖宗的典型坑人题目 awa。所以满足 $x \times y\geq 10^9$ 的数据即可。需要注意他们的最小公倍数必须 $\leq 10^9$。

第二题明显，它二分判断结束语句的是 ```while (l<r)```，而且赋值时 ```r=n```，那就永远搜不到 $a_n$ 了，所以简单询问一次 $a_n$ 即可。

第三题典型多测不清空，所以可以直接写一个多组测试点的数据就行了。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int a;
	cin>>a;
	switch (a){
		case 1:cout<<"100000 100000";break;
		case 2:cout<<"1\n6 6\n3 3 3 3 3 3\n1 1 4 5 1 4";break;
		case 3:cout<<"2\n1 1\n1\n1\n1 1\n1\n1";break;
    }
    return 0;
}
```

当然，根据思路，符合条件的数据都是正确的。

---


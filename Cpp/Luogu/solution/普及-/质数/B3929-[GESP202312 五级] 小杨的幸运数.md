# [GESP202312 五级] 小杨的幸运数

## 题目描述

小杨认为，所有大于等于 $a$ 的完全平方数都是他的超级幸运数。

小杨还认为，所有超级幸运数的倍数都是他的幸运数。自然地，小杨的所有超级幸运数也都是幸运数。

对于一个非幸运数，小杨规定，可以将它一直 $+1$，直到它变成一个幸运数。我们把这个过程叫做幸运化。例如，如果$a=4$，那么 $4$ 是最小的幸运数，而 $1$ 不是，但我们可以连续对 $1$ 做 $3$ 次 $+1$ 操作，使其变为 $4$，所以我们可以说， $1$幸运化后的结果是 $4$。

现在，小杨给出 $N$ 个数，请你首先判断它们是不是幸运数；接着，对于非幸运数，请你将它们幸运化。

## 说明/提示

**样例解释 1**

虽然是完全平方数，但它小于 $a$，因此它并不是超级幸运数，也不是幸运数。将其进行 $3$ 次 $+1$ 操作后，最终得到幸运数 $4$。4是幸运数，因此直接输出 `lucky` 。

$5$ 不是幸运数，将其进行 $3$ 次 $+1$ 操作后，最终得到幸运数 $8$。

$9$ 是幸运数，因此直接输出 `lucky` 。

**数据规模**

对于 $30\%$ 的测试点，保证 $a,x \le 100,N \le 100$。

对于 $60\%$ 的测试点，保证 $a,x \le 10^6$。

对于所有测试点，保证 $a \le 1,000,000$；保证 $N \le 2 \times 10^5$；保证 $1 \le x \le 1,000,001$。

## 样例 #1

### 输入

```
2 4 
1 
4 
5 
9```

### 输出

```
4 
lucky 
8 
lucky```

## 样例 #2

### 输入

```
16 11 
1 
2 
4 
8 
16 
32 
64 
128 
256 
512
1024```

### 输出

```
16 
16 
16 
16 
lucky 
lucky 
lucky 
lucky 
lucky 
lucky 
lucky```

# 题解

## 作者：what_can_I_do (赞：29)

[传送门](https://www.luogu.com.cn/problem/B3929)

最近越来越拉了。

由于 $1\le N\le 2\times 10^5$，所以考虑预处理。

首先先从大于等于 $a$ 的完全平方数开始枚举，对于每一个完全平方数，直接去枚举它的倍数，把这些数字标记起来。上限是 $1002001$，因为大于等于 $1000001$ 且离它最近的完全平方数是 $1002001$。

接下来倒着枚举所有数字，用 $la$ 记录目前最近的完全平方数。如果该数字被标记，就更改 $la$ 变为它，否则用一个数组记录比该数字大的最近的完全平方数。

询问直接判断如果该数字有被标记输出 `lucky`，否则输出已经记录好的比该数字大的最近的完全平方数。
# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,n;
int b[1002010]={0},la=1002001;
int main()
{
	scanf("%d%d",&a,&n);
	for(register int i=ceil(sqrt(a*1.0));i*i<=1002001;i++)
		for(register int j=1;j*i*i<=1002001;j++)
			b[j*i*i]=j*i*i;
	for(register int i=1002000;i>=1;i--)
		if(b[i]==i) la=i;
		else b[i]=la;
	while(n--)
	{
		int x;
		scanf("%d",&x);
		if(b[x]==x) puts("lucky");
		else printf("%d\n",b[x]);
	}
	return 0;
}
```

---

## 作者：__hqt__ (赞：17)

### 暴力解
我们可以先把超级幸运数写出，枚举每个数，判断这个数是不是幸运数，询问时二分查找。  
时间复杂度约为 $ O(mk+ n \log k )$，**很难通过此题**。    
**不过，我们似乎可以把思路转换一下。**



------------
### 正解
**我们可以让每个超级幸运数来“筛”出他的倍数（幸运数）**，这样会比逐个判断这个数是否是幸运数快很多。  
我们可以发现，这个思路几乎和埃氏筛一样！  
时间复杂度约为 $O(m \log \log m + n \log k)$，可以通过此题。  


------------
###  代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
int a[1002002],k=0;
bitset<1002002> b;//相当于bool b[1002002],但前者更省内存
int main()
{
	int n,x,y;
	const int m=1002001;//上限要开大一些
	cin>>n>>x;
	for(int i=ceil((double)sqrt(n));i*i<=m;i++)//从最小数开始枚举，找出所有超级幸运数
	{
		if(b[i*i]==0)//一个小小的优化：如果当前数是其他超级幸运数的倍数，就没必要在筛了
		{
			for(int j=1;i*i*j<=m;j++)//把超级幸运数的倍数标记为幸运数
			{
				b[i*i*j]=1;//这里不能直接统计，因为这样会打乱数组的单调性
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(b[i]==1)
		{
			a[++k]=i;//暴力统计
		}
	}
	for(int i=1;i<=x;i++)
	{
		cin>>y;
		if(b[y]==1)//是幸运数就输出"lucky"
		{
			cout<<"lucky\n";
		}
		else//不是幸运数就在幸运数里二分查找比它大且最小的幸运数
		{
			cout<<a[upper_bound(a+1,a+k+1,y)-a]<<endl;
		}
	}
}
```

---

## 作者：zhang_kevin (赞：11)

暴力会超时，我们需要进行预处理。

我们可以从 $a$ 开始枚举，遇到一个数据范围内的完全平方数就把他的倍数全部标记成幸运数（自己也算）。

同时我们可以定义一个数组，存入所有的幸运数。

预处理后，我们需要排序一下幸运数的数组。

对于每次询问，可以先从 `bool` 类型的标记数组中找到是否为幸运数。

如果不是幸运数，可以选择 $\mathcal{O}(\log n)$ 时间复杂度在幸运数数组中二分查找，也可以在预处理的时候多用一些空间存储每一个数的下一个幸运数（时间复杂度 $\mathcal{O}(1)$）。

考场满分代码（选择二分查找下一个幸运数）：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool isLucky[2000010];
vector<int> luck;
inline bool iswp(int x){
	int k = sqrt(x);
	return k * k == x;
}
inline int find(int x){
	if(luck[0] > x) return luck[0];
	int l = 0, r = luck.size() - 1;
	while(l <= r){
		int mid = (l+r) >> 1;
		if(luck[mid] > x && luck[mid-1] < x){
			return luck[mid];
		}
		if(luck[mid] < x){
			l = mid + 1;
		}
		if(luck[mid-1] > x){
			r = mid - 1;
		}
	}
	return -1;
}
int main(){
	int a, N;
	cin >> a >> N;
	for(int i = a; i < 2000010; i++){
		if(iswp(i)){
			for(int j = i; j < 2000010; j += i){
				isLucky[j] = true;
				luck.push_back(j);
			}
		}
	}
	sort(luck.begin(), luck.end());
	while(N--){
		int x;
		cin >> x;
		if(isLucky[x]){
			cout << "lucky" << endl;
		}else{
			cout << find(x) << endl;
		}
	}
	return 0;
}
```

---


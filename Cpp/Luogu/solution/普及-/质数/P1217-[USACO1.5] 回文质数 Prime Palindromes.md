# [USACO1.5] 回文质数 Prime Palindromes

## 题目描述

因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$（一亿）间的所有回文质数。

## 说明/提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.


Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。


题目翻译来自NOCOW。

USACO Training Section 1.5


产生长度为 $5$ 的回文数：

```cpp
for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }

```

## 样例 #1

### 输入

```
5 500
```

### 输出

```
5
7
11
101
131
151
181
191
313
353
373
383
```

# 题解

## 作者：min_进击的灭霸 (赞：1786)

# 回文质数
### 顾名思义，回文的质数，先思考:
1. 暴力枚举[l， r]的没一个数，TLE等着你。。。
1. 因为判断回文快，而回文数又少，所以先判断回文，再判断质数，~~恭喜你~~还是TLE。。。
1. 有一种~~玄学~~的证明方法,有偶数位的回文数（除了11）必然不是质数
##### 证明方法：~~显然~~
##### 这个数必为11的倍数，~~小学题，不会的问小学数学老师~~
4. 亲测之后，发现以上想法实现后，不用快读快出已经可以过了，但在TLE的边缘徘徊，再想，正偶数（除了2）是不是都不可能是质数呢？时间大约少了一半
###  _至此，想法已经基本有了，现在代码实现_ 

------------

```
#include<bits/stdc++.h>
using namespace std;
int l, r;
bool check1(int x)//检查位数
{
	if((1000 <= x && x <= 9999) || (100000 <= x && x <= 999999)) return 0;//不知道&&和||优先级的可以打个括号 
	return 1;
} 
bool check2(int x)//检查是否回文
{
	int a[20], flag = 1;//反正开得下，多开点
	while (x > 0)
	{
		a[flag] = x % 10;
		x /= 10;
		flag++;
	} 
	for (int i = 1; i <= flag / 2; i++)
		if(a[i] != a[flag-i]) return 0;//不符合回文 
	return 1;
} 
bool check3(int x)//检查是否为质数 
{
	if(x == 2) return 1;
	for(int i = 2; i <= sqrt(x); i++)
		if(x % i == 0) return 0;
	return 1;
}
int main()
{
	scanf("%d %d", &l, &r);
	if(l == 2) printf("2\n");//一定要注意2！！！ 
	if(l % 2 == 0) l++; 
	r = min(9999999, r);//再大的数都不可能是回文质数
	for(int i = l; i <= r; i = i + 2)//枚举每一个奇数
	{
		if(check1(i) == 0) continue;
		if(check2(i) == 0) continue;
		if(check3(i) == 0) continue;
		printf("%d\n", i);//printf会比cout快很多 
	}	
	return 0;
}
```
### 本人发表的第一篇题解，望点赞!




---

## 作者：linyorson (赞：966)

这题吗……

我用的不是制造回文数，是从a找到b。那怎么会不超时呢？

1、我从奇数开始找，每次+2；

2、我发现，没有偶数位的回文质数！省了一大把的时间啊！

虽说还是很慢，不过很好写就是了！哈哈。

下面列核心的三个判断：

```cpp
    bool ok(int k)   //回文数
    {     
        int a[10],i=0;     
        while (k>0){a[i]=k%10;k/=10;i++;}
        for(int j=0;j<i;j++)if(a[j]!=a[i-j-1])return false;   
        return true;     
    }
    bool ws(int k)  //位数
    {
        if(k>=10 && k<100 && k!=11 || k>=1000 && k<10000)return false;
        if(k>=100000 && k<1000000 || k>=10000000 && k<100000000)return false;
        return true;
    }
    bool ss(int k)   //素数
    {     
        for(int i=3;i*i<=k;i+=2)if(k%i==0)return false;     
        return true;
    }
更优的方法是制造回文数，这个我就不说了。给个赞吧！
```

---

## 作者：⚡best_hacker⚡ (赞：906)

# 打表
###### 

------------
~~哈哈哈哈~~真爽

------------

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a,b,db[800]={0,2,3,5,7,11,101,131,151,181,
191,313,353,373,383,727,757,787,797,
919,929,10301,10501,10601,11311,11411,12421,12721,
12821,13331,13831,13931,14341,14741,15451,15551,16061,
16361,16561,16661,17471,17971,18181,18481,19391,19891,
19991,30103,30203,30403,30703,30803,31013,31513,32323,
32423,33533,34543,34843,35053,35153,35353,35753,36263,
36563,37273,37573,38083,38183,38783,39293,70207,70507,
70607,71317,71917,72227,72727,73037,73237,73637,74047,
74747,75557,76367,76667,77377,77477,77977,78487,78787,
78887,79397,79697,79997,90709,91019,93139,93239,93739,
94049,94349,94649,94849,94949,95959,96269,96469,96769,
97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,
1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,
1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,
1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,
1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,
1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,
1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,
1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,
1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,
1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,
1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,
1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,
1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,
1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,
1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,
1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,
1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,
1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,
1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,
1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,
1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,
1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,
3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,
3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,
3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,
3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,
3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,
3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,
3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,
3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,
3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,
3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,
3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,
3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,
3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,
3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,
3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,
3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,
3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,
3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,
3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,
7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,
7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,
7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,
7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,
7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,
7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,
7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,
7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,
7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,
7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,
7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,
7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,
7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,
7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,
7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,
7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,
7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,
9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,
9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,
9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,
9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,
9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,
9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,
9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,
9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,
9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,
9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,
9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,
9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,
9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,
9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,
9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,
9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,
9938399,9957599,9965699,9978799,9980899,9981899,9989899,
781};
int main()
{
    scanf("%d %d",&a,&b);
    for(int i=1;i<=781;i++)
    if(db[i]>=a && db[i]<=b) printf("%d\n",db[i]);
    return 0;
}
/*const int N=100000001;
int P[N],a,b,ans,sum;
bool Isp[N];
void Euler(int x){>//欧拉筛法
    for(int i=2;i<=x;i++){
        if(Isp[i]) P[++P[0]]=i;
        for(int j=1;i*P[j]<=x && j<=P[0];j++){
            Isp[i*P[j]]=false;
            if(i%P[j]==0) break;
        }
    }
}
bool hw(int x)
{
    int x2=x,y=0;
    while (x2!=0)
    {
        y=y*10+x2%10;
        x2/=10;
    } 
    if (x==y) return true;
    else return false;
}
int main()
{
    memset(Isp,true,sizeof(Isp));Isp[1]=0;
    scanf("%d %d",&a,&b);
    Euler(b);
    for(int i=a;i<=b;i++)
        if(hw(i) && Isp[i]){
            printf("%d,",i);
            sum++;
            if(sum%9==0) printf("\n");
        }
    printf("\n%d",sum);
    return 0;
}*/
```


---

## 作者：QAQ永动机 (赞：304)

# 埃氏筛选法+回文数判断
```cpp
#include<bits/stdc++.h>
using namespace std;

bool book[100000001];

// 用埃氏筛法生成质数表
void prime(int b) {
    //初始化，默认全部都是质数
    memset(book, true, sizeof(book));
    book[1]=false;//1不是质数
    int n=sqrt(b);
    for (int i=2;i<=n;i++) {
        if (book[i]) {
            //质数的倍数绝对不是质数，把所有质数的倍数全部设为false
            for (int j=2;j<=b/i;j++)
                book[i*j]=false;  // i*j<=b 
        }
    }
}

//判断回文数
bool isHWS(int num) {

    int temp=num,ans=0;
    while (temp!=0) {
        ans=ans*10+temp%10;
        temp/=10;
    }
    if (ans==num)
        return true;
    else
        return false;
}

int main() {
    int a,b;
    cin>>a>>b;
    //b<=10000000这个判断条件来自：除了11以外，一个数的位数是偶数的话，不可能为回文数素数。
    // 如果一个回文素数的位数是偶数，则它的奇数位上的数字和与偶数位上的数字和必然相等；
    // 根据数的整除性理论，容易判断这样的数肯定能被11整除，所以它就不可能是素数。
    if (b>=10000000)
        b=9999999;

    prime(b);
    
    if(a>b)
    	return 0;

    if (a%2==0) a++;//除了2以外，2的倍数不可能是质数
    for (int i=a;i<=b;i+=2) {
        if (book[i] && isHWS(i))
            cout<<i<<endl;//如果既是质数同时也是回文数，就输出。
    }
    return 0;
}
```

---

## 作者：lenfrey (赞：272)

蒟蒻的第一篇题解。  
~~这里先小小的自夸一下，我的方法比前几个都短，而且和他们都不一样哈哈哈哈~~  
本人生平最讨厌重复的代码，所以看到楼下一大堆打表、分别循环3，5，7位的数的代码就觉得，我的机会来了  
……等等，第一篇题解就这么说似乎不太好……  
我的思路和楼下几个一样，但是实现用了一个递归的函数：  
1.**创造**一个（k位的）回文数  
2.**判断**是否符合给出的范围，小了就跳过，大了就直接退出  
3.如符合范围，就判断是否是质数，是就**输出**  
**其实就是个深搜。**
### 注意特判：
1.题目给出的范围是：**5<=l,r<=1,0000,0000**.所以1位的回文质数只有5和7；  
2.2位的回文质数只有11；  
3.通过某种~~玄学~~奥数方法可以证明偶数位的回文数都不是质数，可以跳过；  
4.9位的数只有1亿一个，而且既不是回文数也不是质数，所以跳过。
好的终于到代码的部分了（**并不会**出现奇怪的函数，都是手打的，应该比较容易阅读）：
```cpp
#include<iostream>
using namespace std;
bool isprime(int x){ //判断质数的函数，应该不用我多解释
	if(x<2)return false;
	if(x==2)return true;
	for(int i=2;i*i<=x;i++){
		if(x%i==0)return false;
	}
	return true;
}
int l,r,x,y; //l,r是题目范围，x,y是他们的长度
int a[10];  //储存创造出来的数
bool b=true;  //用来作为是否跳出的判断
void go(int x,int k){  //k是总位数，x是目前枚举到的位置
	if(x==(k+1)/2){  //(k+1)/2是k位的中间数，可以自己算一下
		for(int i=k;i>x;i--){  //把剩下的位数完善
			a[i]=a[k-i+1];
		}
		int shu=0;  //将数组转化成数
		for(int i=1;i<=k;i++){
			shu=shu*10+a[i];
		}
		if(shu<l)return; //小于l就跳过
		if(shu>r){ //大于r就跳出
			b=false;
			return;
		}
		if(isprime(shu))cout<<shu<<endl; //是质数就输出
		return; //这个一定不能漏，要不然会一直搜下去（本人是亲身体验过的受害者）
	}
	int i;
	if(x)i=0;
	else i=1; //最高位不能是0
	for(i=i;i<=9;i++){ //dfs(深度优先搜索)下一位，没学过可以去看下P1706
		if(b==false)return; //如果已经出现大于r的数，就跳出函数
		a[x+1]=i;
		go(x+1,k);
	}
	return;
}
int weishu(int j){ //计算一个数的长度
	int b=j,count=0;
	while(b>0){
		b/=10;
		count++;
	}
	return count;
}
int main(){
	cin>>l>>r;
	x=weishu(l);
	y=weishu(r);
	for(int i=x;i<=y;i++){
		if(i==1){ //一位数特判
			if(l<=5&&r>=5)cout<<5<<endl;
			if(l<=7&&r>=7)cout<<7<<endl;
			continue;
		}
		if(i==2){ //两位数特判
			if(l<=11&&r>=11)cout<<11<<endl;
			continue;
		}
		if(i%2==0)continue; //偶数位就跳过
		if(i==9)break; //九位直接跳出
		b=true; //每次搜索要先重置这个变量
		go(0,i); //从第0位开始搜
	}
	return 0;
}
```

---

## 作者：无声告白 (赞：217)

看各位大佬如此优秀，本蒟蒻深感无力。
其实本题最讨厌就是当运行到9989899会TLE，~~暴露测试数据~~（下了测试数据可以知道，后面没有了，但是会超时）
所以我做了个判断：当它为上述数是，我就跳出不就行了吗。~~打表思想~~。
具体见代码。
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int prime(int n) {//判定素数 
	if(n==1)//特判1 
		return 0;
	if(n%2==0)//2的倍数就回家吧 
		return 0;
	else {//不然就暴力枚举 
		int i;
		for(i=2; i<=sqrt(n); i++) {
			if(n%i==0)
				return 0;
		}
		return 1;
	}
}
int hw(int n) {//判定回文，不懂请参考数字反转 
	int sum=0;
	int k=n;
	while(n!=0) {
		sum=sum*10+n%10;
		n/=10;
	}
	if(sum==k)//判断是否回文 
		return 1;
	else
		return 0;
}
int main() {
	int i,n,sum=0,m;
	cin>>n>>m;  //读入两个数 
	for(i=n; i<=m; i++) {
		if(i==9989900) //如果到了这个数，就break 
			break;
		if(hw(i)&&prime(i))//否则判断是否回文和素数 
			cout<<i<<endl;//输出每个回文质数 
	}
	return 0;//结束程序 
}
```

---

## 作者：假的太真 (赞：78)

此题异常的坑，需要很多的处理和简化：

1、回文质数一定不是2的倍数，因为质数不可能是2的倍数；

2、最大的回文质数是9989899（自己测）。

于是，本蒟蒻的代码就出来了
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,s[10];
bool prime(int x)//判断质数
{
	int i;
	for(i=3;i<=sqrt(x);i++)
		if(x%i==0) return 0;
	return 1;
}
bool huiwen(int x)//判断回文
{
	int k,len=0,j;
	while(x!=0)
	{
		len++;
		s[len]=x%10;
		x/=10;
	}
	if(len==1) 
	{
		s[len]=0;
		return 1;
	}
	for(k=1;k<=len/2;k++)
			if(s[k]!=s[len-k+1]) return 0;
	for(k=1;k<=len;k++) s[k]=0;
	return 1;
}
int main()
{
	int i;
	cin>>a>>b;
	if(b>=9999999) b=9999999; //最大的回文质数处理
	if(a%2==0)a++;//从2的倍数+1开始搜索
	for(i=a;i<=b;i+=2)//2的倍数不为回文质数
	{
		if(huiwen(i)==0) continue;
		else if(prime(i)) cout<<i<<endl; 
	}
	return 0;
}
```
另外，还可以用自己组成回文数再判断是否为质数来做，可以去看看其它的dalao的代码qwq!


---

## 作者：xyzhouh (赞：73)

这道题就是一道暴力打表题目
# 第一步，把一亿以内的质数打出来
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define maxn 100000000
bool k[maxn];//这里用int类型的数组太大，因此使用bool类型的数组
int cnt;
int main(){
	freopen("1.in","w",stdout);//把打表结果放在一个文件里
	for(int i=2;i<=maxn;i++){
	if(!k[i]){
		int j=1;
		cnt++;
		printf("%d ",i);
		while(i*j<=maxn){
			k[i*j]=true;
			j++;
			}
		}
	}
	
	return 0;
} 
```
# 第二步，把得到的质数中的回文质数找出来
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char k[100];
int ans;//记录回文质数的个数

int main(){
	freopen("1.in","r",stdin);
	freopen("2.out","w",stdout);
	while(scanf("%s",k)!=EOF){
		int n=strlen(k);
		int flg=0;
		for(int i=0;i<=n/2;i++){
			if(k[i]!=k[n-i-1]) {
				flg=1;break;	
			}
		}
		if(flg==0) {
			ans++;
			for(int i=0;i<n;i++){
				printf("%c",k[i]);
			}
			printf(",");
		}
		memset(k,0,sizeof(k));
	}
	printf("\n\n%d",ans);
	return 0;
}
```
# 第三步，打出最终程序
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int ans[1000]={0,2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};

int main(){
    int a,b;
    scanf("%d%d",&a,&b);
    for(int i=1;i<=781;i++){//781是上个程序中求出的回文质数个数
    if(ans[i]>=a&&ans[i]<=b) printf("%d\n",ans[i]);
    }
    return 0;
}
```
## OK，这样程序就写完了
注：打表时如果用文件输入输出的话，会比直接输入输出更快一点


---

## 作者：huang_yue (赞：57)

这一题要是枚举出2-10,000,000之内所有的质数的话再挨个判断是否是回文数的话，必定会超时。但是我们可能会想到，如果使用这个方法（在评测机外）枚举出回文质数以后，把这些回文质数**打到代码里**会怎么样呢？

下面是产生回文质数的代码，头文件已省略。


const int m = 10000000, sqrtm = 3163; //sqrtm = (int)sqrt(m)，事先计算以免在循环条件判断的时候浪费时间

    
    

```cpp
    bool w[m + 10]; //w[i]记录i是否为质数
    bool ispal(int w) { //是否是回文数
        string p = to_string(w);
        string k(p); reverse(k.begin(), k.end());
        return p == k; //k是p倒过来，如果k==p那么p一定是回文
    }
    int main() {
        memset(w, 1, sizeof(w));
        freopen("prim.txt", "w", stdout);
        w[0] = w[1] = false;
        for (int i = 2; i <= sqrtm; ++i) { //筛法主体
            if (!w[i]) continue;
            for (int j = i + i; j < m; j += i)
                w[j] = false;
        }
        cout << "int p[] = {";
        for (int i = 2; i < m; ++i) {
            if (w[i] && ispal(i)) cout << i << ", "; //输出
        }
        cout << "};";
    }
```
有了这个以后，剩下的代码就很简单了：

    
```cpp
    int p[] = { /*太长，省略*/ };
    int main() {
        int l, r; cin >> l >> r;
        for (int i = 0; i < sizeof(p) / sizeof(int); ++i) //sizeof(p) / sizeof(int)是p数组里的元素个数
            if (l <= p[i] && p[i] <= r) cout << p[i] << '\n';
        return 0;
}
```

---

## 作者：cn_lemon (赞：31)

    
```cpp
//C语言题解：
//首先在回文数中，如果位数为偶数的话，那么这些回文数都可以被11整除，如1001、1221、345543都是11的倍数
//所以回文数位数为偶数时，只有11为素数。
#include<stdio.h>
int m[100000],n[100000];//定义数组存所有回文数。
int pd(int a)？//判断质数
{
    int i;
    for(i=2;i*i<=a;i++)
    if(a%i==0)return 0;
    return 1;
}
int main()
{
    long long i1,i2,i3,i4,i5,a,b,t=1,tt=1,i;
    scanf("%lld %lld",&a,&b);？//区间
    for(i1=0;i1<=9;i1++)
    for(i2=0;i2<=9;i2++)
    for(i3=0;i3<=9;i3++)
    for(i4=0;i4<=9;i4++)
    for(i5=0;i5<=9;i5++)
    {
        if(i4==0&&i3==0&&i2==0&&i1==0)m[t++]=i5;
        else if(i3==0&&i2==0&&i1==0)m[t++]=i5*10+i4*101;
        else if(i2==0&&i1==0)m[t++]=i5*100+i4*1010+i3*10001;
        else if(i1==0)m[t++]=i5*1000+i4*10100+i3*100010+i2*1000001;
        else m[t++]=i5*10000+i4*101000+i3*1000100+i2*10000010+i1*100000001;
    }
```
/\*当回文数位数为奇数时的情况。因为最大数值为一亿，有九位，我们不妨设五个数字来表示回文数。
用五重循环表示出所有回文数，并讨论回文数是1位、3位、5位、7位、9位的情况。存入数组m\*/


    
   
```cpp
    t--;//m数组有t个数
    for(i=1;i<=t;i++)
    if(pd(m[i])==1)n[tt++]=m[i];//把回文数中的质数找出来，存入n数组
    tt--;
    for(i=1;i<=tt;i++)
    if(n[i]>=a&&n[i]<=b)
    {
     printf("%d\n",n[i]);
     if(i==6)printf("11\n");//当回文质数在范围内时，输出，当101可以输出时，11肯定可以输出，加输出11.
    }
    return 0;
}
```

---

## 作者：shangkevin (赞：14)

这道题很容易眼高手低qwq 前前后后改了好多遍，真的没想到被这样一道题卡了很久。。。 这是1.0的代码
```cpp
#include<iostream>
using namespace std;
#include<cstdio>
#include<cmath>    
int a[100000001]={1};
bool find(int x)
{
    if (x<=1) return 0;
    for(int i=2;i<=sqrt(x);i++)
    {
        if (x%i==0) return 0;
    }
    return 1;
}
bool dou(int x)
{
    int a[11],i=1;
    while (x!=0)
    {
        a[i]=x%10;
        x=x/10;
        i++;
    }
        i--;
    for(int j=1;j<=i/2;j++)
    {
        if (a[j]!=a[i-j+1]) return 0;
    }
    return 1;
}
int main()
{
    int st,en;
    cin>>st>>en;
    for(int i=st;i<=en;i++)
    {
        if (dou(i)&a[i]==1) cout<<i<<endl;

    }
    return 0;

}
```


很明显tle了对吧。。。 2.0，加了一个线性筛 也不知道是写的太丑还是。。。 蛙声一片。。。。（不展示了） 于是我打算重新构思一下

3.0 这个是把所有的偶位数全部删除了，因为。。。 

所有的偶位数除了11都不是质数（都可以被11整除）

话说判断是不是能被11整除的方法是 奇数位数相加-偶数位数相加看一看是不是=11的倍数 例如13577531 奇数位数相加=1+3+5+7 偶数位数相加=1+3+5+7 两个式子差是0是11的倍数 所以能被11整除（小学奥数）

但是我漏了一点，其实对于偶数的判断所用的时间也是很长的，所以即使优化到这样，还是tle。。。

于是4.0！！！！

（参考上面某位大佬的构造回文数的方法） 内含我的小错误解析：）

```
#include<iostream>
using namespace std;
#include<cstdio>
#include<cmath>
    int st,en;
int wei(int x)//计算数位 
{    
    int sum=0;
    while (x!=0)
    {
        sum++;
        x=x/10;
    }
    return sum;
}
bool find(int x)//找质数，这里偷了个懒，线性筛的话可以更快一点 
{
    if (x<=1) return 0;
    for(int i=2;i<=sqrt(x);i++)
    {
        if (x%i==0) return 0;
    }
    return 1;
}

void wri(int x)//判断是不是质数，如果是质数，那么输出 
{
    if(find(x)==1)//注意函数调用顺序
    cout<<x<<endl; return;
}
void zushu3(int x,int y)//组一个三位回文数，这里我不想想太多，于是就直接分了三类，每一类复制粘贴了一下，看起来比较复杂，实际上写起来比较简单 
{

    for(int i=1;i<=9;i+=2)
    {
        for(int j=0;j<=9;j++)
        {        
        if((i*100+j*10+i)<=en&&(i*100+j*10+i)>=st)//理论上可以再优化，把范围限制在循环里面 
        wri(i*100+j*10+i);

        }
    }
}

void zushu5(int x,int y)//组一个五位回文数
{
    for(int i=1;i<=9;i+=2)
    {
        for(int j=0;j<=9;j++)
        {
            for(int k=0;k<=9;k++)
            if((i*10000+j*1000+k*100+j*10+i)<=en&&(i*10000+j*1000+k*100+j*10+i)>=st)
            wri(i*10000+j*1000+k*100+j*10+i);
        }

    }
}

void zushu7(int x,int y)//组一个七位回文数
{
    for(int i=1;i<=9;i+=2)
    {
        for(int j=0;j<=9;j++)
            for(int k=0;k<=9;k++)
                for(int l=0;l<=9;l++)
        if((i*1000000+j*100000+k*10000+l*1000+k*100+j*10+i)<=en&&(i*1000000+j*100000+k*10000+l*1000+k*100+j*10+i)>=st)
        wri(i*1000000+j*100000+k*10000+l*1000+k*100+j*10+i);
    }
}




int main()
{

    int ls,le;
    cin>>st>>en;
    ls=wei(st);
    le=wei(en);
    for(int i=ls;i<=le;i++)
    {
        if(i==1) 
        {
            if(st==5)cout<<5<<endl<<7<<endl;
            else cout<<7<<endl;
        }
        if(i==2) 
        {
            if(st<=11)cout<<11<<endl;
        }
        if(i==3) zushu3(101,997);//当然，这里也偷了个懒，如果en=500的话，根本不用组数组到997 
        if(i==5) zushu5(10001,99997);
        if(i==7) zushu7(1000001,9999997);
    }

    return 0;
}
```

当然了，这种写法在考场上当然是要炸锅了，因为太麻烦了而且很容易手滑。。。

所以提醒大家多思考 

而且提醒大家如果写这么长的程序的时候一定要！！！！ 

按时保存！！！！！！！

江枫渔火对愁眠，祝你ac一万年

---

## 作者：lx_zjk (赞：13)

这道题还是比较H2O的，毕竟本蒟蒻都做出来了，先判断回文，在判断素数，这样可以降低时间复杂度，毕竟回文可以筛掉很多素数。判断素数方法则使用大于5的素数都是6的倍数+-1，降低时间复杂度；
```CPP
#include<bits/stdc++.h>
using namespace std;
int p(int n)
{
	int k=0;
	int m=n;
	while(n!=0)
	{
		k=k*10+n%10;
		n=n/10;
	}
	if(k==m) return 1;
	return 0;
}
void prime(int a) {
    if(a==1||(a%6!=1&&a%6!=5)) return;
    if(a==2||a==3) {
    	printf("%d\n",a);
		return;
	}
    for(int i=5;i<=floor(sqrt(a));i+=6)
    {
		if(a%i==0||a%(i+2)==0) return;
    }
    printf("%d\n",a);
    return;
}
int main()
{
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=n;i<=m;i++)
	{
		if(i==9989900) break;
		if(p(i))prime(i);
		else continue;
	}
	return 0;
}
```
望大佬通过题解，谢谢，（逃

---

## 作者：herofox (赞：11)

这道题其实非常水，只不过是生成的问题，代码如下

```cpp

#include <iostream>
#include <cmath> 
using namespace std;
bool prime(int x)
{
    bool b=true;
    for(int i=2;i<=sqrt(x);i++)
    {
        if(x%i==0)
            b=false;
    }
    return b;
}//判断质数的函数
int main()
{
    int a,b;
    int c[100000];
    int i=3;
    int d1,d2,d3,d4,d5;
    c[0]=5;c[1]=7;c[2]=11;//2位数和1位数只有这三个是回文质数
    for(d1=1;d1<=9;d1+=2)
        for(d2=0;d2<=9;d2++)
        {
            c[i]=d1*100+d2*10+d1;
            i++;
        }//生成3位回文数
    for(d1=1;d1<=9;d1+=2)
        for(d2=0;d2<=9;d2++)
            for(d3=0;d3<=9;d3++)
            {
                c[i]=d1*10000+d2*1000+d3*100+d2*10+d1;
                i++;
            }//生成5位回文数
    for(d1=1;d1<=9;d1+=2)
        for(d2=0;d2<=9;d2++)
            for(d3=0;d3<=9;d3++)
                for(d4=0;d4<=9;d4++)
                {
                    c[i]=d1*1000000+d2*100000+d3*10000+d4*1000+d3*100+d2*10+d1;
                    i++;
                }//生成7位回文数
    for(d1=1;d1<=9;d1+=2)
        for(d2=0;d2<=9;d2++)
            for(d3=0;d3<=9;d3++)
                for(d4=0;d4<=9;d4++)
                    for(d5=0;d5<=9;d5++)
                    {
                        c[i]=d1*100000000+d2*10000000+d3*1000000+d4*100000+d5*10000+d4*1000+d3*100+d2*10+d1;
                        i++;
                    }//生成9位回文数
    cin>>a>>b;//输入范围
    for(int i=0;i<100000000;i++)
    {
        if(c[i]>=a&&c[i]<=b&&prime(c[i])==true)
        {
            cout<<c[i]<<endl;
        }//判断回文数是否是质数
        if(c[i]>b)
            break;//当超出范围时及时退出循环
    }
}

```

---

## 作者：是比利啊 (赞：10)

这道题有点

怎么说呢

有点__呵呵O(∩_∩)O~

~~在冥思苦想几天后，~~我毅然决然的决定~~~~~~~~







**打表**

真的是，呵呵

下面是本蒟蒻的打表代码

以下是华丽的分割线



------------


------------


```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[3000]={5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};
int main()
{
	int x,y,i;
	cin>>x>>y;
	for(i=0;a[i]<=y;i++)
	{
		if(a[i]>=x) cout<<a[i]<<endl;
	}
}
```

------------


---

## 作者：Srauni (赞：9)

原本可以打表过的，不过这样子多没意思

为了写这道题，我特意把int类型给重写了一遍，加了一些功能，先祭出AC代码
```cpp
#include <stdio.h>
#include <math.h>

class binInt
{
public:
	binInt();
	void set(int n);
	int get();
	int getLenth();
	void invert();           // invert the num[] and change to num[]
	int checkhuiwen();
	int checksushu();
	void madehuiwen(int mode);	// 1 is HUiwen include middle num，0 is mirror huiwen
private:
	int number;		// save num mode
	int num[20];	// save num[] mode
	int length;		// the length is real length
	void shuzuhua();// let the num mode to num[]mode
	void shuzihua();// let the num[] mode to num mode
};
binInt::binInt()
{
	number = 0;
	length = 0;
}
void binInt::set(int n)
{
	number = n;
	length = 0;
	shuzuhua();
}
int binInt::get()
{
	return number;
}
int binInt::getLenth()
{
	return length;
}
void binInt::invert()
{
    for (int s = 0; s < length / 2; s++)
    {
        int temp = num[s];
        num[s] = num[length - 1 - s];
        num[length - 1 - s] = temp;
    }
    shuzihua();
}
int binInt::checkhuiwen()
{
	for (int s = 0; s < length; s++)
	{
		if (num[s] != num[length - 1 - s])
		{
			return 0;
		}
	}
	return 1;
}
int binInt::checksushu()
{
	for (int s = 2; s <= sqrt(number); s++)
	{
		if (number % s == 0)
		{
			return 0;
		}
	}
	return 1;
}
void binInt::shuzuhua()
{
	int n = number;
	for (int s = 0; ; s++)
	{
		if (n == 0)
		{
			break;
		}
		int temp;
		temp = n % 10;
		length++;
		num[s] = temp;
		n /= 10;
	}
	invert();
}
void binInt::shuzihua()
{
	number = 0;
	for (int s = 1, len = 0; len < length; s *= 10, len++)
	{
		number += num[len] * s;
	}
}
void binInt::madehuiwen(int mode)
{
	if (mode == 0)
	{
		length *= 2;
		for (int s = 0; s < length / 2; s++)
		{
			num[length - 1 - s] = num[s];
		}
	}
	if (mode == 1)
	{
		length *= 2;
		length--;
		for (int s = 0; s < length / 2; s++)
		{
			num[length - 1 - s] = num[s];
		}
	}
	shuzihua();
}

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    binInt num;
    for (int s = 1; true; s *= 10)
    {
        // first run the 1 mode huiwen
        int numLength = -1;
        for (int u = s; true; u++)
        {
            num.set(u);
            if (numLength == -1)
                numLength = num.getLenth();
            if (numLength != -1 && numLength < num.getLenth())
                break;
            num.madehuiwen(1);
            if (num.get() > b)
                return 0;
            if (num.checksushu() == 1 && num.get() >= a)
            {
                printf("%d\n", num.get());
            }
        }
        numLength = -1;
        // Second run the 0 mode huiwen
        for (int u = s; true; u++)
        {
            num.set(u);
            if (numLength == -1)
                numLength = num.getLenth();
            if (numLength != -1 && numLength < num.getLenth())
                break;
            num.madehuiwen(0);
            if (num.get() > b)
                return 0;
            if (num.checksushu() == 1 && num.get() >= a)
            {
                printf("%d\n", num.get());
            }
        }
    }

    return 0;
}
```

写的新int主要有几个功能
1. 把数字转成数组
2. 把数组转成数字
3. 获得数字的长度
4. 检查是否是素数
5. 将数字变成回文

PS：其中，将数字变成回文有两种模式，奇数模式和偶数模式

举个例子，例如123这个数字，用奇数模式会变成12321，用偶数模式会变成123321

现在重点来了，如果初始数字只有一位，例如是1，咱们先用奇数模式，会生成原数字，不变。咱们再用偶数模式，会生成11，多了一位

如果初始数字是两位，例如12，用奇数模式生成121，是三位数。用偶数模式生成1221，是四位数。

如此循环下去，咱们可以用这种方法很快按照顺序枚举出所有的回文数字，每个数字枚举出来再判断是否是素数，是素数就输出，于是题就做出来了。

不过有点小问题，因为起始值从1开始，必然会枚举出比a要小的数，所以要加入判断，比a要小就不输出了。同时还要判断，如果枚举出的数比b要大，就要直接return 0跳出去了。

此外，需要两个循环，外循环从1开始，每次都要乘以10，也就是进位。内循环需要从外循环的数字开始，每次+1，同时需要检测是否有进位，例如100，加到999，再加到了1000，这时候就不能继续循环了，应该跳出，换模式继续输出。

---

## 作者：bzcxl (赞：7)

这题我使用的是暴力dfs加剪枝的方法，并且用一些题解所发现的偶数位没有回文数的方法来减少搜索量，用了估计更快一些吧。

运行速度最慢的一个点也不到50ms。

下面我就来讲讲我的思路：

1、首先，深搜搜什么呢？我们知道，直接枚举所有的数，然后再分别判断回文数和质数，几遍你判断的过程是o（1），也一定会超时。因此，有一个显而易见的思路，那就是我们先枚举其中的一种，再判断是否符合另一条件。这里当然只能枚举回文数了（打表枚举质数没有意义，打表的话直接枚回文质数就好了）。

2、现在整体的思路有了，我们将程序分为两大部分。

第一：判断素数的过程，这个地方我也是使用的比较朴素的o（√n）的算法，没什么好说的。
```cpp
bool check(int a)
{
	if(a==1) return false;
	for(int i=2;i<=sqrt(a);i++) 
	 if(a%i==0) return false;
	return true;
}
```
第二：就是要深搜找回文数。枚举一个定长的回文数，每次往头尾填一个数，直到正中间，这时如果是偶数，只要直接判断素数即可，如果是奇数，我就要再枚举一次0~9填进去判断素数，如是就可以把所有长度的回文数都枚举完了。需要注意的是，首尾不能为0，而中间可以，所以循环时加了一个三目运算符。下面放一下深搜过程。

```cpp
void dfs(int t,int l)
{
	for(int i=(t==1?1:0);i<=9;i++)
	{
		double a=t-1,b=l-t;
		p=p+i*pow(10.0,a)+i*pow(10.0,b);
		//////////////////////////////////
        if(p>m)
		{
			p=p-i*pow(10.0,a)-i*pow(10.0,b);
			break;
		}  
        //请注意：这里的就是剪枝的过程了
        //如果两头开始构造的回文数已经超过m，
        //那么再往下填数很明显也会超过。
        //////////////////////////////////
		if(t>=l/2)
		{
			if(l%2==0)
			{
				if(check(p)&&p>=n&&p<=m) printf("%d\n",p);
			}
			else
			{
				for(int i=0;i<=9;i++)
				{
					double a=t;
					p=p+i*pow(10.0,a);
					if(check(p)&&p>=n&&p<=m) printf("%d\n",p);
					p=p-i*pow(10.0,a);
				}
			}
		}
		else dfs(t+1,l);
		p=p-i*pow(10.0,a)-i*pow(10.0,b);
	}
}
```
那么就这样，再加上主程序，这道题就这样解决了。
下面是完整程序。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,ans,l,p=0;
bool check(int a)
{
	if(a==1) return false;
	for(int i=2;i<=sqrt(a);i++) 
	 if(a%i==0) return false;
	return true;
}
void dfs(int t,int l)
{
	for(int i=(t==1?1:0);i<=9;i++)
	{
		double a=t-1,b=l-t;
		p=p+i*pow(10.0,a)+i*pow(10.0,b);
		if(p>=m)
		{
			p=p-i*pow(10.0,a)-i*pow(10.0,b);
			break;
		}
		if(t>=l/2)
		{
			if(l%2==0)
			{
				if(check(p)&&p>=n&&p<=m) printf("%d\n",p);
			}
			else
			{
				for(int i=0;i<=9;i++)
				{
					double a=t;
					p=p+i*pow(10.0,a);
					if(check(p)&&p>=n&&p<=m) printf("%d\n",p);
					p=p-i*pow(10.0,a);
				}
			}
		}
		else dfs(t+1,l);
		p=p-i*pow(10.0,a)-i*pow(10.0,b);
	}
}
int main()
{
	cin>>n>>m;
	int mm=m;
	while(mm>0)
	{
		l++;
		mm/=10;
	}
	for(int i=5;i<=9;i++) if(i>=n&&i<=m&&check(i)) cout<<i<<endl;
	for(int i=2;i<=l;i++) 
	{
		p=0;
		dfs(1,i);
	}
} 
```

---

## 作者：Sail (赞：7)

先判断是不是回文数再判断是不是素数。直接走的话肯定会超市，将ab俩个值做适当的截取，每次都是奇数的循环遍历
```C++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;

int isprime(int a)//判断是否为素数的代码
{
for(int i=2;i<=sqrt(a);i++)
if(a%i==0) return 0;
return 1;
}

bool isRev(int x){//判断是否为回文数的代码
	int t = x;
	int value = 0;
	while (x / 10){
		value = 10 * value + x % 10;
		x /=  10;
	}
	if(value*10 + x == t) return 1;
	else return 0;
}

int main()
{
	int a,b;
	cin>>a>>b;
    //投机取巧，将a变为奇数，将很大的b变为9999999，每次循环＋2，新判断是不是回文数，在判断是不是素数
	if(a%2==0) a+=1;
	if(b>9999999) b=9999999;
	for(int i=a;i<=b;i+=2){
		if(isRev(i)){
			if(isprime(i)){
				cout<<i<<endl;
			}
		}
	}
	return 0;
}

```

---

## 作者：呼风唤雨abc (赞：6)

首先，大家刚看到这一题的时候肯定有想法的

想法1：从5到10^8的数全部枚举一遍，再每一个都看一看是不是质数，如果是就输出嘛，这么简单。但是一看之间限制就哭了（当然这一种做法是不可取的）。

想法2：当然是枚举，只枚奇数。（挺好，但依然跑得飞慢）

想法3：我发现如果数位是偶数的话当然就是11的倍数啦，只要枚举奇数数位的就好了。（注意：11是一个质数，好想法，还是挺慢）

想法4：在想法3的基础上把判断质数的循环改变成
```cpp
for(int i=3;i<=sqrt(n);i+=2)
```

想法5：开头是要是2，4，5，6，8的话，末尾也是一样的，均不可取（好想法，但是这样在别的地方可能还是需要优化，看别的题解吧）

想法6：打表（又浪费一道题）

想法7：这是一个挺快的方法，我们可以从10^1枚举到10^4，再将每一个数变成一个奇数数位的回文数，再判断是否是质数，不就可以了吗，在综合以上想法，不就跑得飞快了吗？！（别的话不说，上代码）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int foc[9]={1,10,100,1000,10000,100000,1000000,10000000,100000000};
set<int> s;
int dic(int n){
	int c[foc[1]]={0},l=0;
	while(n){//分离数位
		c[++l]=n%10;
		n/=10;
	}
	for(int i=l;i>=2;i--)//进行一些操作，使其变成回文数
		n+=c[i]*(foc[(i-1)*2]+1)*foc[l-i];
	n+=c[1]*foc[l-1];//中间的位置
	return n;
}
int l(int n){//计算数位
	int len=0;
	while(n/=10) len++;
	return len+1;
/*
一定要记住加一，因为上面其实是
while(1){
    n/=10; 
    if(!n) break;//这里是除后的判断，没有让长度加一 
    len++;
}
*/
}
bool pd(int n){//判断是否是质数
	for(int i=3;i<=sqrt(n);i+=2)
		if(n%i==0) return false;
	return true;
}
int main(){
	int pri[foc[4]]={-1,5,7,11},tot=3,a,b;、、初始化
	scanf("%d %d",&a,&b);
	s.insert(2);//集合初始化
	s.insert(4); 
	s.insert(5);
	s.insert(6);
	s.insert(8);
	for(int i=foc[1];i<=foc[4]-1;i++){
		if(s.count(i/foc[l(i)-1])){//就是首位是否是2，4，5，6，8
			i+=foc[l(i)-1]-1;
			continue;
		}
		int fuc=dic(i);
		if(pd(fuc)) pri[++tot]=fuc;//插入数组
	}
	for(int i=1;pri[i];i++){//输出
		if(b+1<=pri[i]) break;
		if(a<=pri[i]) printf("%d\n",pri[i]);
	}
}
```

---

## 作者：MercyBO (赞：6)

看到这么大的范围,我的第一反应是通过线性筛质数表来解题.然后在质数表找到回文数.
结果交上去之后最后一组tle了,通过观察输出结果,我发现100000000以内的最大的回文质数是9989899,于是乎我质数表的上限加了9989899,再次提交就ac啦~.
btw,有兴趣的小伙伴可以试试打表
```c
#include<stdio.h>
#define N 100000000
char notpalpri[N];
long long palpri[N],prime[N],tot,total;
void palindrome(long long m,long long n);

int  main(int argc, char const *argv[])
{
    long long m,n;
    scanf("%lld%lld",&m,&n);
    palindrome(m,n);
    return 0;
}
/*通过筛法得出质数表,在质数表中找回文数*/
void palindrome(long long m,long long n)
{
   	for(long long i=2;i<=n&&i<=9989899;i++)//在第一次提交tle后发现该范围内最大的回文质数为9989899,所以可以除去不必要的计算
    {
 		if(!notpalpri[i])
 		{
            long long s=i,y=0;
            while(s>0){
                 y=y*10+s%10;
                 s/=10;
            }
            if(y==i&&i>=m){
                palpri[++tot]=i;
                printf("%lld\n", palpri[tot]);
            }//判断回文数
            prime[++total]=i;		 
 		}
   		for(int j=1;j<=total&&prime[j]*i<=n;j++)
   		{
   			notpalpri[prime[j]*i]=1;
   			if(i%prime[j]==0)break;
   		}//筛法核心
    }
}
```

---

## 作者：mengyi (赞：6)

这道题的思路很基础，就是判断回文数和素数就可以了。

素数代码：

```cpp
bool ss (long long n) {
	for (j=2; j<=sqrt (n); j++)//注意从2开始
		if (n%j==0) return false;
	return true;
}
```

回文数代码：

```cpp
bool hws (long long n) {
	ll y=n,num=0;
	while (y!=0) num=num*10+y%10,y/=10;//通用方法
	if (num==n) return true;//判断回文
	else return false;
}
```

结果这两个代码并没有让我高枕无忧，这道题最开始交的时候最后一个点TLE！！！

然后如果要进行各种优化的话，感觉会比较麻烦。例如用些什么高端的函数，或者是一些高端的算法，我觉得好麻烦。然后就准备找找规律......

结果并没有找到什么高端的规律，反而找到了一个有趣的事实：

5-100000000（10^8）之间回文素数最大不超过10000000（10^7），然后就能进行一个简单的判断——
```cpp
if (b>10000000) 
	for (i=a; i<=10000000; i++)
else for (i=a; i<=b; i++)
```

这是我能想到最好的“优化”方案！（类似打表一样）

现在上代码：

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long//比较喜欢开long long,好像int也能过
ll i,j;
bool ss (ll n) {
	for (j=2; j<=sqrt (n); j++)
		if (n%j==0) return false;
	return true;
}
bool hws (ll n) {
	ll y=n,num=0;
	while (y!=0) num=num*10+y%10,y/=10;
	if (num==n) return true;
	else return false;
}
int main () {
	ll a,b;
	scanf ("%lld %lld",&a,&b);
	if (b>10000000) {
		for (i=a; i<=10000000; i++)
			if ((hws(i))&&(ss(i)))
				printf ("%lld\n",i);//注意要打括号，不然会变成里层的if-else
	} else {
		for (i=a; i<=b; i++)
			if ((hws(i))&&(ss(i)))
				printf ("%lld\n",i);
	}
	return 0;//好习惯
}
```

总体还是比较短的la！

好像不用我那么优化的话，开O2就能过了。（最好还是不用呀）

谢谢O(∩_∩)O谢谢

---

## 作者：kangzenan111 (赞：5)

回文数可以直接通过选取对称轴将另一半数字补回得到
比如说321.
对称轴选择3的话。可以得到12321
再往高位一点选择对称轴。可以得到123321
再高位还能得到1230321，12300321等。
按照这个思路处理出0-100000000的全部回文数。然后在【a，b】区间check素数即可：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN = 100000000;

//本地跑一遍之后发现tot只有11110，开这么多空间就够了
int palind[15000],tot = 0; //储存全部的回文数
void palindromes(int x){
    int y = 0, tmp = x, ten = 1;
    while(tmp){
        y = y * 10 + tmp % 10;
        tmp /= 10;
        ten *= 10;
    }
    if((ll)y/10*ten+x < MAXN)palind[tot++] = y/10*ten+x;         // x=123  类似12321的情况
    for(;(ll)y * ten + x < MAXN; ten *= 10){//乘法会爆int范围，需要开ll
        palind[tot++] = y * ten + x;    //类似123321、1230321、12300321
    }
}

//回文数的数量总共只有1w多个，check素数用sqrt的复杂度就够了，另外还有一种常数级别的check算法可自行百度
bool isprime(int x){
    bool flag = 1;
    for(int i = 2; i*i <= x; i++){
        if(x % i == 0){
            flag = 0;break;
        }
    }
    return flag;
}

int main(){
    //预处理出1e8内所有回文数，因为回文数对称，用四位数对折处理出来就可以了
    for(int i=1;i<10000;i+=2){
        palindromes(i);
    }
    sort(palind, palind + tot);
    int a, b;
    scanf("%d %d",&a,&b);
    int L = lower_bound(palind, palind + tot, a) - palind;
    int R = upper_bound(palind, palind + tot, b) - palind;
    for(; L < R; L ++)
        if(isprime(palind[L]))
            printf("%d\n", palind[L]);
    return 0;
}

```

---

## 作者：scanf (赞：5)

1.回文质数一定是奇数，所以数据可以砍一半掉
2.数据总共有8位数的，7位数的，6位数的，5位数的，直到一位数。我把8位数分成4位数写四个for循环，后四位数直接翻过去就行，就像把纸对折一下。后面的7位6位等以此类推。代码如下：
```python
import math


def fun(a):
    for i in range(2, int(math.sqrt(a))+1):
        if a % i == 0:
            return 0
    return 1


x = [2, 3, 5, 7, 11]
for i in range(1, 10):
    for j in range(0, 10):
        for k in range(0, 10):
            for l in range(0, 10):
                temp = i * 10000000 + j * 1000000 + k * 100000 + l * 10000+l * 1000+k * 100+j * 10+i
                if fun(temp) == 1:
                    x.append(temp)
    i += 1
for i in range(1, 10):
    for j in range(0, 10):
        for k in range(0, 10):
            temp = i * 100000 + j * 10000 + k * 1000 + k * 100 + j * 10 + i
            if fun(temp) == 1:
                x.append(temp)
            for l in range(0, 10):
                temp = i * 1000000 + j * 100000 + k * 10000 + l * 1000+k * 100+j * 10+i
                if fun(temp) == 1:
                    x.append(temp)
    i += 1
for i in range(1, 10):
    for j in range(0, 10):
        temp = i * 1000 + j * 100 + j * 10 + i
        if fun(temp) == 1:
            x.append(temp)
        for k in range(0, 10):
            temp = i * 10000 + j * 1000 + k * 100 + j * 10 + i
            if fun(temp) == 1:
                x.append(temp)
    i += 1
for i in range(1, 10):
    for j in range(0, 10):
        temp = i * 100 + j * 10 + i
        if fun(temp) == 1:
            x.append(temp)
    i += 1

a, b = map(int, input().split())
x.sort()
for i in range(len(x)):
    if x[i] > b:
        break
    if x[i] >= a:
        print(x[i])


```

---

## 作者：Ufowoqqqo (赞：4)

如果以传统方法做只能拿部分分，#7到#9都会TLE。

因此，我有新的构思：**[color=red]构造回文数[/color]**。

对于一个任意的正整数N，将其转为字符串后其长度有两种可能：

1.如果它有奇数位，那么可以被分成copy(s,1,length(s) div 2+1)和copy(s,length(s) div 2+2,length(s))这两部分。如1被分为'1'和''，123被分为'12'和'3'等等。

2.如果它有偶数位，那么可以被分成copy(s,1,length(s) div 2)和copy(s,length(s) div 2+1,length(s))这两部分。如12被分为'1'和'2'，1234被分为'12'和'34'等等。

回文数同样适用于上述规则。如101被分为'10'和'1'，1221被分为'12'和'21'等。通过观察可以发现，对于任意一个回文数，如果将分解后的第一个子串称为s1，将第二个子串称为s2，那么通过s1可以造出两个回文数，分别是s2:=反转(copy(s1,1,length(s1)-1))和s2:=反转(s1)。造出来的回文数就是s1+s2。这也就意味着，我们可以通过枚举s1来实现对回文数的枚举。

注意：枚举出的回文数并不是有序的。例如，s1从1枚举到9，分别造出1，11，2，22，3，33，4，44……因此，造出回文数后首先判断它是否在指定的范围内，然后判断其是否为质数，全部构造完毕后再进行排序。因为回文质数的数量很少，因此可以用最低级的选择排序。

```delphi

var nn,mm,len1,len2,i:longint;
    s1,s2:string;
    a:array [0..10000] of longint;

function prime(n:longint):boolean;//判断质数
var i:longint;
begin
 if n=1 then exit(false);
 prime:=true;
 for i:=2 to trunc(sqrt(n)) do if n mod i=0 then exit(false);
end;

procedure work_(s:string;min,max:longint);//对回文数是否合法的判断
var n:longint;
begin
 val(s,n);
 if (n>=min) and (n<=max) then//范围判断
  if prime(n) then//质数判断
  begin
   inc(a[0]);
   a[a[0]]:=n;
  end;
end;

procedure work(s1,s2:string);
var n,m,i,j,temp:longint;
    s,ss:string;
begin
 val(s1,n);val(s2,m);
 for i:=n to m do//枚举回文数
 begin
  str(i,s);
  ss:='';
  for j:=length(s)-1 downto 1 do ss:=ss+s[j];
  work_(s+ss,nn,mm);
  work_(s+s[length(s)]+ss,nn,mm);
 end;
 for i:=1 to a[0]-1 do//排序
  for j:=i+1 to a[0] do
   if a[i]>a[j] then
    begin
     temp:=a[i];a[i]:=a[j];a[j]:=temp
    end;
 for i:=1 to a[0] do writeln(a[i]);
end;

begin
 read(nn,mm);
 str(nn,s1);str(mm,s2);
 if odd(length(s1)) then len1:=length(s1) div 2+1 else len2:=length(s2) div 2;
 if odd(length(s2)) then len2:=length(s2) div 2+1 else len2:=length(s2) div 2;
 s1:='1';
 for i:=1 to len1-1 do s1:=s1+'0';
 s2:='';
 for i:=1 to len2 do s2:=s2+'9';
 fillchar(a,sizeof(a),0);
 work(s1,s2);
end.

```

---

## 作者：LamoJunity (赞：3)

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int Begin,End;
int hwss;
int digit;
void ss(int cnt) //素数
{
    for (int w = 2; w <= sqrt(cnt); ++w)
    {
        if (!(cnt % w))
            return;
    }
    cout << cnt << endl;
}
void huiwen(int Digit,int pd,int hwss)
{
    if (Digit == digit / 2)
    {
        if (hwss > End) //如果回文数大于最大值直接结束
            {
                exit(0);
            }
        else if(hwss < Begin) //如果回文数小于最小值就继续找下一个
            return;
        else
        {
            ss(hwss); //中间的话就判断是否素数
            return;
        }
    }
    if (!pd) //是否第一个数字
    {
        for (int w = 1;w <= 9; w += 2){
            if (pow(10,digit-1) / pow(10,Digit-1) == pow(10,Digit-1))
            {                                   //顺数和逆数第n个是否同一个数
                huiwen(Digit - 1,1,hwss + w * pow(10,Digit-1));
            }
            else
                {
                    huiwen(Digit - 1,1,hwss + w * pow(10,Digit-1) + w * (pow(10,digit-1) / pow(10,Digit-1)));
                }
        }
    }
    else
    {
        for (int w = 0;w <= 9; w++){
            if (pow(10,digit-1) / pow(10,Digit-1) == pow(10,Digit-1))
            {                                   //顺数和逆数第n个是否同一个数
                huiwen(Digit - 1,1,hwss + w * pow(10,Digit-1));
            }
            else
                {
                    huiwen(Digit - 1,1,hwss + w * pow(10,Digit-1) + w * (pow(10,digit-1) / pow(10,Digit-1)));
                }
        }
    }
}
int main()
{
    cin >> Begin >> End;
    digit = 0;
    int bg = Begin;
    do{
        bg /= 10;
        digit++;
    }while (bg > 0);//判断最小为多少位
    while (digit <= 9)
    {
        huiwen(digit,0,0);
        ++digit;
    }
}
```
# 不知道你们看不看得懂，这个全ac，时间充足，最长的时间点也就27ms就是有点长- -
那我先计算要求范围内最小的那个数的位数，然后依次循环加位数，最高位数是9位，就是一亿，每到一位数，我就找出这位数的所有回文数，	这里找回文数我有优化，具体自己看- -，别问为啥，我不会讲，找到一个回文数就判断是否素数，并且每次判断回文数的时候我都会判断是否超出范围，如果超出，那么就直接exit（0）退出程序，如果不用exit，就不会直接退出程序，当然也可以写个判断bool变量

---

## 作者：邱江坤 (赞：3)

MillerRabin 算法

本程序时间复杂度$O(nk\log^3n)$，空间复杂度$O(1)$

思路：枚举每一个数，判断是否为回文数、质数，是则输出。关键部分在于剪枝和优化


```cpp
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll;

ll pow_mod ( ll a, ll b, ll m )
{
	a %= m;
	ll ans = 1;
	do
	{
		if ( b & 1 )
			ans = ans * a % m;
		a = a * a % m;
	}
	while ( b >>= 1 );
	return ans;
}

bool Miller_Rabin ( ll n, ll a, ll d )
{
	if ( n < 2 ) return false;
	if ( n == 2 ) return true;
	if ( n == a ) return false;
	if ( ~ n & 1 ) return false;
	while ( ~ d & 1 ) d >>= 1;
	ll t = pow_mod ( a, d, n );
	while ( d != n - 1 && t != n - 1 && t != 1 )
	{
		t = t * t % n; //下面介绍防止溢出的办法，对应数据量为10^18次方；
		d <<= 1;
	}
	return t == n - 1 || ( d & 1 ) == 1; //要么t能变成n-1，要么一开始t就等于1
}

bool isprime ( ll n )
{
	static const int a[] = {2, 7, 61}; //或者自己生成[2,N-1]以内的随机数rand（）%（n-2）+2
	for ( int i = 0; i < 3; ++i )
	{
		if ( n == a[i] ) return true;
		if ( !Miller_Rabin ( n, a[i], n - 1 ) ) return false;
	}
	return true;
}

bool reversable ( int num )
{
	static char buf[16];
	sprintf ( buf, "%d", num );

	int len = strlen ( buf );
    // 注意这里，偶数位的回文串一定不是质数，11除外
	if(num != 11 && ~len & 1) return false;

	int i = 0, j = len -1;
	while(i < j)
	{
		if(buf[i++] != buf[j--])
			return false;
	}
	return true;
}
int main()
{
	ios::sync_with_stdio(false);
	int a, b;
	cin >> a >> b;
	b = min(b, 9999999);//一开始看错了，以为n取到10亿，实际上，1千万到一亿范围内不存在回文质数（因为偶数位长度）
	for(int i = a; i <= b; ++i)
		if(i == 2 or (i & 1 and reversable(i) and isprime(i)))
			cout << i << endl;

}


```

---

## 作者：Taurus_Lzc (赞：3)

这个方法会有点bug  
可以应用到所有求这种数的题  
只是速度会慢  
下见代码：
```cpp
#include<iostream>
#include<cmath>  //sqrt（开平方）用的函数库
using namespace std;

bool su(int n){  //判断素数函数（必熟练）
    if (n<=1) return false;
    for (int i=2;i<=sqrt(n);i++) if (n%i==0) return false;
    return true;
}

bool hui(int n){  //判断回文数函数
    int a=n,b=0;
    while(a){  //逐位分解
		b*=10;
    	b+=a%10;
    	a=a/10;
    }
    return b==n;  //相当于 if (b==n) return true ; else return false ;
}

int main(){
    int n,m;
    cin>>n>>m;
    for (int i=n;i<=m;i++){
        if (hui(i)) {  //因为回文数比素数少，所以先判断回文
        	if (su(i)) cout<<i<<endl;
        	if (i==9989899) return 0;  //这里的测试数据到一亿就没了，但是一千万到一亿之间是没有一个回文素数的，所以直接在最后一个回文素数结束，不然会TLE
        }
    }
}
```
如果要用到实际里，当然楼下的更实用，蒟蒻的仅供参考

---

## 作者：传说饭 (赞：3)

实践证明，本题用建素数表的方法可以AC。
建素数表的思路：
**将质数的倍数干掉。**
有以下几个要点：
**
1.空间换时间高性能的题目千万不能用vector!!!!!
2.最重要的一点优化就是回文数猜想（除了11，偶数位质数不可能是回文数），将一千万以上的多余操作全部干掉，大大提高效率
**
也就是这行代码：
```
if (b > 10000000)b = 10000000;
```

以下是全部代码:
```
#include <iostream>

using namespace std;

bool isHw(int x);
bool v[100000001];
int main()
{
	int a, b;
	cin >> a >> b;
	if (b > 10000000)b = 10000000;
	for (int i = 2; i<b / 2; i++)
	{
		if (v[i] == true) continue;
		for (int j = 2; i*j < b; j++)  //倍数
			v[i*j] = true;
	}
	for (int i = a; i <= b; i++)
	{
		if (!v[i] && isHw(i))
			cout << i << endl;
	}
	return 0;
}

bool isHw(int x) 
{
	int x1, y = 0, xx = x;
	while (x > 0)
	{
		x1 = x % 10, x /= 10;
		y = y * 10 + x1;
	}
	return xx == y ? true : false;
}
```

---

## 作者：qwaszx (赞：3)

看了一下楼下的程序，比较长（楼下应该还没学回溯）。回溯写的，相对来说代码要短些有些条件是可以在中间加上判断的，本人懒

的写，全部不超过30ms过了除了一个是32ms。水平不高见谅。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
int l,r,a[100];
bool p[100000001];
void make()                   //开始想写筛法，不过后来一算时间不大够，就用了一般判断。不想看筛法自行略过
{
    p[1]=0;                  //把1标记为0
    int q=(int)sqrt(r);   //i循环到sqrt(r)
    for (int i=2;i<=q;i++)
        if (p[i])          //如果i是质数那么它所有的倍数标记为0.
            for (int j=2;j<=r/i;j++)           //2倍～r/i倍
                p[i*j]=0;        //标记
}
bool pd(int x)           //一般质数判断，不解释
{
    int q=(int)sqrt(x);
    for (int i=2;i<=q;i++)
        if (x%i==0)
            return 0;
    return 1;
}
void tab(int n,int t)
{
    if (t>(n+1)/2)                             //如果不回文的部分填完了
    {
        int s=0;                             //预备输出
        for (int i=1;i<=n/2;i++)           //把填的数扩展成回文数
            a[n-i+1]=a[i];
        for (int i=1;i<=n;i++)             //从数组转化为数
            s=s*10+a[i];
        if (s>r||s<l)                  //如果大了或小了就return（这你完全可以放在前面判断，效率更高）
            return;
        if (pd(s))                   //如果s是质数
            cout<<s<<endl;          //输出
    } 
    else
        for (int i=(t==1);i<=9;i+=(t==1)+1)              
                //如果是第一位那么从1到9循环，否则从0到9循环；如果是第一位那么每次加2（质数），否则每次加1
        {
            a[t]=i;              //记录
            tab(n,t+1);        //递归填下一位的数
        }
}
int main()
{
    cin>>l>>r;                          //读入l和r
    memset(p,1,sizeof(p));
//    make();                              //这里注释掉了
    for (int i=ceil(log10(l));i<=ceil(log10(r));i++)           //针对i～j区间的数进行产生，ceil(log10(r))是r的位数
        tab(i,1);                         //产生
}
```

---

## 作者：Neil1110 (赞：3)

代码可能比较长，150行左右，但是是能ac的。

基本思路就是，由于偶数位的回文数都是11的倍数，所以不用考虑。

用一个switch来确定范围，分别生成1，3，5，7，9位的回文质数（注意11是唯一一个偶数位的回文质数）


```cpp

#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
bool isprime(int a)
{
    int i;
    for(i=3;i<=floor(sqrt(a)+0.5);i++)
        if(a%i==0)
            return false;
    return true;
}
int weishu(int a)
{
    int i=0;
    while(a>0)
    {
        a/=10;
        i++;
    }
    return i;
}
int main()
{
    int start,end,i1,i2,i3,i4,i5,hw,ws[2];
    cin>>start>>end;
    ws[0]=weishu(start);
    ws[1]=weishu(end);
    switch(ws[0])
    {
        case 1:
        {
            if(ws[1]<1)
                break;
            for(i1=5;i1<=9;i1+=2)
            {
                   hw=i1;
                   if(hw>end)
                       break;
                   else if(hw>=start&&isprime(hw))
                       cout<<hw<<endl;
            }
        }
        case 2:
        {
            if(ws[1]<2)
                break;
            if(end>=11&&start<=11)
                cout<<"11"<<endl;
        }
        case 3:
        {
            if(ws[1]<3)
                break;
            for(i1=1;i1<=9;i1+=2)
            {
                for(i2=0;i2<=9;i2++) 
                {
                       hw=100*i1+10*i2+i1;
                       if(hw>end)
                           break;
                       else if(hw>=start&&isprime(hw))
                           cout<<hw<<endl;
                }
            }
        }
        case 4:
        {
            if(ws[1]<4)
                break;
        }
        case 5:
        {
            if(ws[1]<5)
                break;
            for(i1=1;i1<=9;i1+=2)
            {
                for(i2=0;i2<=9;i2++) 
                {
                    for(i3=0;i3<=9;i3++)
                    {
                           hw=10000*i1+1000*i2+100*i3+10*i2+i1;
                           if(hw>end)
                               break;
                           else if(hw>=start&&isprime(hw))
                               cout<<hw<<endl;
                       }
                }
            }
        }
        case 6:
        {
            if(ws[1]<6)
                break;
        }
        case 7:
        {
            if(ws[1]<7)
                break;
            for(i1=1;i1<=9;i1+=2)
            {
                for(i2=0;i2<=9;i2++) 
                {
                    for(i3=0;i3<=9;i3++)
                    {
                        for(i4=0;i4<=9;i4++)
                        {
                               hw=1000000*i1+100000*i2+10000*i3+1000*i4+100*i3+10*i2+i1;
                               if(hw>end)
                                   break;
                               else if(hw>=start&&isprime(hw))
                                   cout<<hw<<endl;
                           }
                    }
                }
            }
        }
        case 8:
        {
            if(ws[1]<8)
                break;
        }
        case 9:
        {
            if(ws[1]<7)
                break;
            for(i1=1;i1<=9;i1+=2)
            {
                for(i2=0;i2<=9;i2++) 
                {
                    for(i3=0;i3<=9;i3++)
                    {
                        for(i4=0;i4<=9;i4++)
                        {
                            for(i5=0;i5<=9;i5++)
                            {
                                   hw=100000000*i1+10000000*i2+1000000*i3+100000*i4+10000*i5+1000*i4+100*i3+10*i2+i1;
                                   if(hw>end)
                                       break;
                                   else if(hw>=start&&isprime(hw))
                                       cout<<hw<<endl;
                               }
                           }
                    }
                }
            }
        }
    }
}

```

---

## 作者：什么叫中二呀 (赞：3)

看到那么多暴搜的题解……~~真是够了~~

我这次用的生成回文数，好像叫深搜……

## 思路

1.因为末位一定是1,3,7,9;所以首位也应该是1,3,7,9。

2.当右边界小于等于i^2(生成前的数)时，应结束递归(因为生成的回文数大约与i^2相等)

3.每搜出一个数，要放到数组里，而不能直接输出。（要不然会不按顺序）

4.深搜是对于三位以上回文素数，所以5,7,11应特判；

5.回文位数为偶数的数可被11整除，在此允许我解（zhuang）释(bi)一下
  
  （1）两位数的回文数必是11的倍数（这要再不明白回去学数学吧）
  
  （2）abba式的回文数可拆成1001a+110b=11(91a)+11(10b)*，乘法分配律，得 
     （91a+10*b）*11。所以四位数的回文数是11的倍数
  
  （3）abccba式的回文数可拆成100001a+10(bccb)=11(9091)a+10(bccb) 因 
      为bccb是11的倍数，所以abccba是11的倍数
  
  （4）……
  
  （5）所以回文位数为偶数的数可被11整除

# 接下来是你们想要的东西了！

------------

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//cout，cin，swap等函数或语句需调用。
                    //不调用就写成std::cout……
int l,r;
int turn(int n)//生成
{
	int a[10],i,sum=0,t=n;
	for(i=0;n>0;i++,n/=10)a[i]=n%10;//分离数位，放入数组
	for(int j=1;j<i;j++)sum=sum*10+a[j];//倒序放入
	return sum+t*pow(10,i-1);//t是原数，乘位数后与sum相加
}
bool check(int n)//判断素数
{
	if(n%3==0)return false;//先特判，快一点
     					   //思路上第一点已经保证不是2,5倍数
	for(int i=7;i<=sqrt(n);i++)
	  if(n%i==0)return false;
	return true;
}
void dfs(int i)
{
	int x=turn(i);//生成x为回文数
	if(x>r)return;//如果x>右边界返回
	if(check(x)&&x!=7&&x>=l)printf("%d\n",x);
	for(int j=0;j<10;j++)//搜索0~9
	  if(i*i<r)dfs(i*10+j);
	  else return;
}
int main()
{
	cin>>l>>r;
	if(l==5)printf("%d\n%d\n%d\n",5,7,11); 
	else if(l<=7)printf("%d\n%d\n",7,11); 
	else if(l<=11)printf("%d\n",11);//5,7,11特判
	dfs(1);dfs(3);dfs(7);dfs(9);//思路上第一点
    return 0;
}
```
------------

可是，

# 它WA了！！！

随便试一个稍大的数据就知道，顺序不对。

于是有了后来的快排……

------------

```cpp
#include<bits/stdc++.h>us
ing namespace std;
int l,r,sum,a[1000000];
int turn(int n)//生成
{
	int a[10],i,sum=0,t=n;
	for(i=0;n>0;i++,n/=10)a[i]=n%10;
    for(int j=1;j<i;j++)sum=sum*10+a[j];
    return sum+t*pow(10,i-1);
bool check(int n)//判断素数
{
	if(n%3==0)return false;
	for(int i=7;i<=sqrt(n);i++)
	  if(n%i==0)return false;
	return true;
}
void qsort(int l,int r)//快排
{
	int i=l,j=r,mid=a[(l+r)/2];
	while(i<=j)
	{ while(a[i]<mid)i++;//找到左边比mid大的数
	  while(a[j]>mid)j--;//找到右边比mid小的数
	  if(i<=j)swap(a[i++],a[j--]);}//找到交换
         //相当于swap(a[i],a[j]);i++;j--;
	if(i<r)qsort(i,r);//最后一定是i>j,
    if(l<j)qsort(l,j);//左边一定全部比右边小，递归排序
}
void dfs(int i)//搜索
{
	int x=turn(i);
	if(x>r)return;
	if(check(x)&&x!=7&&x>=l)a[sum++]=x;
	for(int j=0;j<10;j++)
	  if(i*i<r)dfs(i*10+j);//递归搜索,一次多一位
	  else return;
}
int main()
{
	cin>>l>>r;
	if(l==5){a[0]=5;a[1]=7;a[2]=11;sum=3;} 
	else if(l<=7){a[0]=7;a[1]=11;sum=2;} 
	else if(l<=11)a[sum++]=11;//5,7,11特判
	dfs(1);dfs(3);dfs(7);dfs(9);
	qsort(0,sum-1);//调用快排
	for(int i=0;i<sum;i++)printf("%d\n",a[i]);
	return 0;
}
```

------------

### 小犇们看不懂正常，因为我也是基本瞎写的，可它就是过了~~

不行还是用~~草率的~~暴搜吧…………

---

## 作者：dBook (赞：3)

这道题打暴力竟然不会超时，真神奇（可能是因为加了register（滑稽）），好了进入正题。

首先我们需要定义两个函数，分别为：

1，判断质数的函数。

2，回文数函数。

然后我们就开始打暴力了，把所有情况有序的枚举完即可，思路很简单，只是代码有点难写，看代码就行了。

C++ Code：

```cpp
    #include<bits/stdc++.h>
    #define Runtime int//所以可以忽视这一行
    #define Error main//这一行也忽视
    using namespace std;
    inline bool zhishu(int n) {//判断素数的函数
    for(int k=2; k<=sqrt(n); ++k)
    if(n%k==0)
    return false;
    return true;
    }
    inline int huiwen(int n) {//判断是否为回文数的函数
        int m=1,k=n;
        while(k>9) {//当k>9执行循环
            k/=10;
            ++m;
        }
        return m;
    }
    Runtime Error(void) {//这一行貌似不能忽视……
        int l,m,n,q,w,i,j,k;
        cin>>m>>n;
        q=huiwen(m);//
        w=huiwen(n);//用两个变量分别表示回文数
        if(q<=1&&w>=1) {//以下就是枚举的思想，要有序的尝试每一种情况，也就是先判断再循环。就不用说了
            if((m<=5)&&(n>=5))
                cout<<5<<endl;
            if((m<=7)&&(n>=7))
                cout<<7<<endl;
        }
        if((q<=2)&&(w>=2)) {//第一类
            if((m<=11)&&(n>=11))
                cout<<11<<endl;
        }
        if((q<=3)&&(w>=3)) {//第二类
            for(register int a=1; a<=9; a+=2)
                for(int b=0; b<=9; ++b) {
                    int f=a*100+b*10+a;
                    if(f<m)
                        continue;
                    if(f>n)
                        return 0;
                    if(zhishu(f))
                        cout<<f<<endl;
                }
        }
        if((q<=5)&&(w>=5)) {//第三类
            for(register int a=1; a<=9; a+=2)
                for(register int b=0; b<=9; ++b)
                    for(register int c=0; c<=9; ++c) {
                        int f=a*10000+b*1000+c*100+b*10+a;
                        if(f<m)
                            continue;
                        if(f>n)
                            return 0;
                        if(zhishu(f))
                            cout<<f<<endl;
                    }
        }
        if((q<=7)&&(w>=7)) {//第四类
            for(register int a=1; a<=9; a+=2)
                for(register int b=0; b<=9; ++b)
                    for(register int c=0; c<=9; ++c)
                        for(register int d=0; d<=9; ++d) {
                            int f=a*1000000+b*100000+c*10000+d*1000+c*100+b*10+a;//最后赋一下值
                            if(f<m)
                                continue;
    if(f>n)
    return 0;
    if(zhishu(f))
    cout<<f<<endl;//判断之后就可以输出了
                        }
        }
        return 0;//养成良好习惯
}
```

---

## 作者：ABlueCat (赞：3)

这道题，如果实在在正规做法上面有困难，可以试试打表法通过此题。

我做此题时，打表可分为2步

1.制表

2.输出

在自己的电脑上面，可以写出这个程序，将表存储在一个叫result.out的文件里面

    
    
    
    
```cpp
    #include<bits/stdc++.h>
    #pragma GCC optimize(2) //由于是自己的电脑，随意开启优化
    using namespace std;
    bool is_prime(int k)////判断是否为素数
    {
        for (int i = 2; i<=(int)sqrt((double)k); i++)
            if(k % i == 0)
                return false;
        return true;
    }
    bool is_palind(int k)//判断是否为回文数
    {
        char a[100];
        sprintf(a, "%d", k);
        int len = strlen(a);
        for (int i = 0; i<=len/2; i++)
        {
            if (a[i] != a[len-i-1])
                return false;
        }
        return true;
    }
    int main()
    {
        freopen("result.out", "w", stdout);
        for (int i = 2; i<=100000000; i++)
        {
            if (is_palind(i) && is_prime(i)) //小优化，如果先判断是否为回文数再判断是否为素数，要节约一些时间
                cout<<i<<" ";
        }
        return 0;
    }
```
这样我们就可以得到一张表了。
我们用记事本把空格换成一个逗号，之后装填成为一个数组，大概是这样子：

`int a[] = {2, 3};`

之后我们就可以获得了最终代码

        
        
        
```cpp
    #include<iostream>
    using namespace std;
    int a[] = {5, 7, 11, 101, ···省略一堆数字- -··· , 9981899, 9989899};
    int main()
    {
        int l, r;
        cin>>l>>r;
        for (int i = 0; i<779; i++)
        {
            if (a[i] >= l && a[i] <= r)
                cout<<a[i]<<endl;
        }
        return 0;
    }

```

---

## 作者：24680esz (赞：2)

数组大小很重要！数组大小很重要！数组大小很重要！！！重要的事情说三遍！！！

（为了一个内存和数组越界wa了无数次）

```cpp
#include <iostream>  
#include <cmath>   
using namespace std;  
bool a[100000001];  //必须这么开标记数组！！！
int pz;  
int zs(int z)  
{  
    for (int i=2;i<=sqrt(z);i++)  
      if (z%i==0) return 0;  
    return 1;  
}  //判断是否为质数的函数
void hwzsb(int y)  
{  
    a[2]++;a[3]++;a[5]++;a[7]++;a[11]++;//用标记法，这几个先标记为回文质数  
    if (y<=100) return;  //小于100无需判断（就上面那几个）
    for (int d1=1;d1<=9;d1+=2)  //回文质数为奇数，首尾每次+2
      for (int d2=0;d2<=9;d2++)  
      {  
          pz=d1*100+d2*10+d1;  
          if (zs(pz)) a[pz]=1;  
      }  //生成三位的回文质数
    if (y<=10000) return;  //小于五位在这里终止
    for (int d1=1;d1<=9;d1+=2)  
      for (int d2=0;d2<=9;d2++)  
        for (int d3=0;d3<=9;d3++)  
        {  
            pz=d1*10000+d2*1000+d3*100+d2*10+d1;  
            if (zs(pz)) a[pz]=1;  
        }  //产生五位回文质数
    if (y<=1000000) return;  //小于七位在此终止
    for (int d1=1;d1<=9;d1+=2)  
      for (int d2=0;d2<=9;d2++)  
        for (int d3=0;d3<=9;d3++)  
          for (int d4=0;d4<=9;d4++)  
          {  
              pz=d1*1000000+d2*100000+d3*10000+d4*1000+d3*100+d2*10+d1;  
              if (zs(pz)) a[pz]=1;  
          }   //产生七位回文质数 
}  
int main()  
{  
    int x,y;  
    cin>>x>>y;  
    hwzsb(y);  
    for (int i=x;i<=y;i++)  
      if (a[i]) cout<<i<<endl;  //被标记了就输出
    return 0;  
}
```

---

## 作者：woshiren (赞：2)

生成质数表，统计质数表的A到B内的回文数

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a,b;
bool excel[100000005];
void prime(int b)//生成质数表 
{
    for (int i=1;i<=b;i++) excel[i]=true;//初始化，默认全部都是质数 
    excel[1]=false;//1不是质数 
    for (int i=2;i<=b;i++)
    {
        if (excel[i]==true)
        {
            for (int j=2;j<=b/i;j++)
            excel[i*j]=false;//质数的倍数绝对不是质数，把所有质数的倍数全部设为假 
        }
    }
}
bool hws(int num)//判断回文数 
{
    
    int temp=num,ans=0;
    while (temp!=0)
    {
        ans=ans*10+temp%10;
        temp/=10;
    }//回文数就是倒过来和正着读都一样，这里是把数字倒过来。 
    if (ans==num) return true;
    else return false;//判断正着的数字和倒着的数字是否一样 
}
int main()
{
    cin>>a>>b;
    if (b<=10000000) prime(b);//b<=10000000这个判断条件来自回文数猜想，代码后面会解释回文数猜想 
    else 
    {
        b=b/10;
        prime(b);
    }//生成质数表 
    if (a!=2&&a%2==0) a++;//除了2以外，2的倍数不可能是质数 
    for (int i=a;i<=b;i+=2)
    {
        if (excel[i]==true&&hws(i)) cout<<i<<endl;//如果既是质数同时也是回文数，就输出。 
    }
    return 0;
} 
//Zehra是我的老师，所以我的代码和Zehra比较像 

```
回文数猜想：除了11以外，所有数的位数是偶数的话，不可能为回文数，所以程序里面在一千万以上的都忽略。

具体资料来自百度百科：http://baike.baidu.com/link?url=J2morq-RROT2ef-MZ5xLXg7Kn7P0GpljEQBbdt32ZyAUhN\_wvr6DGwdBp6ILmjABylvOiLs4igHTjSL-tIynZq


---

## 作者：LEXUGE (赞：2)

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>//引用头文件
int prime(long num)//判断素数
{
  int i=2;
  for (i=2;i*i<=num;i++)//判断到该数的开方取整
  {
    if (num%i==0) return 0;//能被除尽就不是素数
  }
  return 1;
}
int hw(long num)//判断回文数
{
  char s[101];
  int r=0,l=-1;
  itoa(num,s,10);//把数字转换成字符串
  r=strlen(s);
  while(r>l)//只要左右下标不碰头就判断
  {
    r--;//右下标向中心移一位
    l++;//左下标向中心移一位
    if (s[l]!=s[r]) return 0;//如果两个下标所在的字符不一样就不是回文数
  }
  return 1;//是回文数返回1
}
void main()//主程序
{
  long i=0,x=0,y=0;
  scanf("%d %d",&x,&y);//读入范围
  for (i=x;i<=y;i++)//枚举
  {
    if (hw(i)==1)//先判断是否是回文
    {
      if (prime(i)==1)//后判断是否是素数
        printf("%d\n",i);//是的就输出
    }
  }
}//结束

```
主程序请改成int返回


---

## 作者：fl_334 (赞：2)

其实就是回溯。。。。。。。

```cpp
var  
        l1,l2,i,a,b:longint;  
        s1,s2:string;  
function pd(k:longint):boolean;//判断是否为质数  
var  
i:longint;  
begin  
for i:=2 to trunc(sqrt(k)) do  
if k mod i=0 then exit(false);  
exit(true);  
end;  
procedure yx(n,i:longint;s:string);  
var  
j,k:longint;  
c:char;  
begin  
if i>(n+1) div 2 then begin//边界条件  
                        if n div 2>0 then begin  
                                                for j:=n div 2 downto 1 do  
                                                        s:=s+s[j];  
                                          end;  
                        val(s,k);  
                        if (k>=a) and (k<=b) and (pd(k)) then writeln(k);//判断是否满足条件  
                        exit;  //退出
                      end;  
for c:='0' to '9' do  
begin  
        if (i=1) and (c='0') then continue;//首位不为0  
        yx(n,i+1,s+c);  //递归
end;  
end;  
begin  
        read(a,b);  
        str(a,s1);  
        str(b,s2);  
        l1:=length(s1);  
        l2:=length(s2);  
        for i:=l1 to l2 do  
        yx(i,1,''); //递归产生i位回文数 
end.
```

---

## 作者：上进的z君 (赞：2)

**这道题应该算是入门题，但是需要对传统做法进行优化才可以。**


**Hinis:**

1、先进行回文数的判断，再进行素数的判断。

2、要注意，除了11以外，偶数位的数不存在回文素数。

\_证明：如果一个回文素数的位数是偶数，则它的奇数位上的数字和与偶数位上的数字和必然相等。根据数的整除性理论，这样的数肯定能被11整除，所以它就不可能是素数。\_


```cpp

#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<string>
#include<cmath>
using namespace std;

const int maxn=10000000;
const int maxm=5761489;
const int INF=1e9;

int prime[maxm],a,b,cur=0;

bool Check1(int x){
    if(x==11)return true;
    
    char c[13];
    
    itoa(x,c,10);
    
    int l=strlen(c);
    
    if(l%2==0)return false;
    
    for(int i=0;i<l;i++)
    if(c[i]!=c[l-i-1])return false;
    
    return true;
}

bool Check2(int x){
    for(int i=2;i<=sqrt(x+0.0);i++)
    if(x%i==0)return false;
    
    return true;
}

int main()
{
    //freopen("c.in","r",stdin);
    //freopen("c.out","w",stdout);
    
    scanf("%d%d",&a,&b);
    
    b=min(b,maxn);
    
    for(int i=a;i<=b;i++)
    if(Check1(i))
    if(Check2(i))
    printf("%d\n",i);
    
    return 0;
}

```

---

## 作者：_s_t_d_ (赞：2)





```cpp
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int a,b,ans;
string cst="0123456789";//后面用来赋值
bool pri(int x) {//判断质数
    for(int i=sqrt(x);i>=2;i--)
        if(x%i==0) return false;
    return true;
}
void DFS(int d,int bts,string s) {//已经举出的位数,总位数,已经枚举的数字形成的串
    if(d==bts/2+(bts%2) +1 ) {//偶位数要枚举到bts/2位,奇位数要枚举到bts/2+1位 
        int num=0;
        for(int i=0;i<s.length();i++) num=num*10+(s[i]-'0');
        if(bts%2==0) for(int i=s.length()-1;i>=0;i--) num=num*10+(s[i]-'0');
        else for(int i=s.length()-2;i>=0;i--) num=num*10+(s[i]-'0');
        if(a<=num&&num<=b&&pri(num)) printf("%d\n",num); 
        return;
    }
    for(int i= (d==1) ? 1:0;i<=9;i++) {
        if(d==1&&i%2==0) continue;
        string p=cst.substr(i,1);//写法拙劣,只会这样将变量赋给字符串
/*s.substr() 函数参数填两个(a,b)返回s的以a开始长度b的子串,只填一个参数(a)返回s的以a开始至末尾的子串*/
        DFS(d+1,bts,s+p);
    }
}
int main() {
    scanf("%d%d",&a,&b);
    int x=a,y=b,la=0,lb=0;
    while(x) x/=10,la++;
    while(y) y/=10,lb++;
    for(int i=la;i<=lb;i++) DFS(1,i,"");//生成位数在a和b的位数之间的回文数
    return 0;
}
```

---

## 作者：nbgulong (赞：2)

该题重要的是先求回文再求素数，否则超时。

我是先把所有的1-8位数的回文素数存在数组里，输出只要找范围就行了。

最终发现没有4位，6位，8位的回文素数。













```cpp
var
  m,n,i,j,k,y,count:longint;
  aa:array [1..1000000] of longint;
function shushu(x:longint):boolean;
var
  f:boolean; a:longint;
begin
  f:=true;
  for a:=2 to trunc(sqrt(x)) do
    if x mod a=0 then
     begin f:=false;break;
     end;
  exit(f);
end;
function fan2(x:longint):longint;
var
 a:longint;
begin
  A:=x div 10;
  while x<>0 do
    begin
       a:=a*10+x mod 10;
       x:=x div 10;
    end;
  fan2:=a;
end;
procedure build(x:longint);
var
  i,j:longint;
begin
  case x of
   1: begin aa[1]:=2;aa[2]:=3;aa[3]:=5;aa[4]:=7;k:=4;end;
   2: for i:=1 to 9 do
          if shushu(i*10+i) then begin k:=k+1;aa[k]:=i*10+i;end;
   3:for i:=10 to 99 do
          if shushu(i*10+(i div 10)) then begin k:=k+1;aa[k]:=i*10+(i div 10);end;
   5:for i:=100 to 999 do
          if shushu(fan2(i)) then begin k:=k+1;aa[k]:=fan2(i);end;
   7:for i:=1000 to 9999 do
          if shushu(fan2(i)) then begin k:=k+1;aa[k]:=fan2(i);end;
  end;
end;
begin
  readln(m,n);
  k:=0;
  for i:=1 to 8 do
    build(i);
  i:=1;
  while aa[i]<m do i:=i+1;
  for i:=i to k do
    begin
      if aa[i]>n then break;
      writeln(aa[i]);
    end;
end.

```

---

## 作者：末影 (赞：1)

五楼的有问题的，应该是这样的：

   
   
   
   
```cpp
var a,b,l:longint;  
function w(k:longint):integer;  
  var t:longint;  
      s:integer;  
  begin  
    t:=k;  
    s:=0;  
    while t<>0 do  
      begin  
        s:=s+1;  
        t:=t div 10;  
      end;  
    w:=s;  
  end;  
procedure init;  
  begin  
    readln(a,b);  
    l:=w(b);  
  end;  
function judge(st:string):longint;  
  var i,t,code:longint;  
  begin  
    if (length(st) mod 2=0) and (st<>'11') then exit(0); //（11那的两个\要去掉） 
    val(st,t,code);  
    if (t<a) or (t>b) then exit(0);  
    for i:=2 to trunc(sqrt(t)) do  
      if t mod i=0 then begin exit(0); break; end;  
    judge:=t;  
  end;  
procedure search(k:integer);  
  var s,e,i,j,g:longint;  
      st1,st2:string;  
  begin  
    if k>l then exit;  
    if k mod 2=0 then  
      begin  
        s:=1;  
        e:=9;  
        for i:=1 to k div 2-1 do  
          begin  
            s:=s*10;  
            e:=e*10+9;  
          end;  
        for i:=s to e do  
          begin  
            str(i,st1);  
            st2:=st1;  
            for j:=length(st1) downto 1 do  
              st2:=st2+st1[j];  
            g:=judge(st2);  
            if g<>0 then writeln(g);  
          end;  
      end  
    else  
      begin  
        s:=1;  
        e:=9;  
        for i:=1 to (k+1) div 2-1 do  
          begin  
            s:=s*10;  
            e:=e*10+9;  
          end;  
        for i:=s to e do  
          begin  
            str(i,st1);  
            st2:=st1;  
            for j:=length(st1)-1 downto 1 do  
              st2:=st2+st1[j];  
            g:=judge(st2);  
            if g<>0 then writeln(g);  
          end;  
      end;  
    search(k+1);  
  end;  
begin  
  init;  
  search(1);  
end.
```

---

## 作者：不存在之人 (赞：0)

### 题意很简单，但是本蒟蒻是个死心眼，本来可以直接枚举回文数再判断的，可是本蒟蒻就想用筛法把他写完，首先我们可以证明下偶数（大于二）为的回文数不可能是质数。
 
**证明一下偶数位数的回文数都不是prime number(11除外)。**

**证明一下最难的8位数吧，其他的同理。**

**设x=10000001i+1000010j+100100k+11000l(i为1-9的自然数,j,k,l为0-9的自然数)。**

**分解得x=11(909091i+90910j+9100k+1000l)。**

**又909091i+90910j+9100k+1000l>2。**

**∴11|x。**

**x必定为合数。**

### 同理可得当回文数x的位数为偶数位时必有11|x当x/11>2时x必为合数。

**有了这个性质就可以直接枚举奇数位的回文数。**

### 代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int l,r,a[100];
bool p[100000001];
void make()//开始想写筛法，不过后来一算时间不大够，就用了一般判断。不想看筛法自行略过
{
    p[1]=0;//把1标记为0
    int q=(int)sqrt(r);//i循环到sqrt(r)
    for (int i=2;i<=q;i++)
        if (p[i])//如果i是质数那么它所有的倍数标记为0
            for (int j=2;j<=r/i;j++)//2倍～r/i倍
                p[i*j]=0;//标记
}
bool pd(int x)//一般质数判断
{
    int q=(int)sqrt(x);
    for (int i=2;i<=q;i++)
        if (x%i==0)
            return 0;
    return 1;
}
void tab(int n,int t)//如果不回文的部分填完了
{
    if (t>(n+1)/2)
    {
        int s=0;
        for (int i=1;i<=n/2;i++)//把填的数扩展成回文数
            a[n-i+1]=a[i];
        for (int i=1;i<=n;i++)//从数组转化为数
            s=s*10+a[i];
        if (s>r||s<l)//如果大了或小了就return（这你完全可以放在前面判断，效率更高）
            return;
        if (pd(s))//如果s是质数
            printf("%d\n",s);
		} 
    else
        for (int i=(t==1);i<=9;i+=(t==1)+1)//如果是第一位那么从1到9循环，否则从0到9循环；如果是第一位那么每次加2（质数），否则每次加1
        {
            a[t]=i;//记录
            tab(n,t+1);//递归填下一位的数
        }
}
int main()
{
    scanf("%d%d",&l,&r);
    memset(p,1,sizeof(p));
    for (int i=ceil(log10(l));i<=ceil(log10(r));i++)//针对i～j区间的数进行产生，ceil(log10(r))是r的位数
        tab(i,1);//产生
}
```

---


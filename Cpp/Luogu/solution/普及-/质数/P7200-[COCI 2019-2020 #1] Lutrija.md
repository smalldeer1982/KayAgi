# [COCI 2019/2020 #1] Lutrija

## 题目背景

Vedran 在赌输彩票之后，无意之间打开了 COCI 的频道。只要完成 COCI 给出的任务，他就能够免除前往新加坡 IOI2020 现场的费用。

不幸的是，Vedran 已经老了，于是你决定帮帮他。

## 题目描述

给定两个素数 $A,B$。你需要给出一个开头和结尾分别为 $A$ 和 $B$ 的序列，使得其所有元素均为素数，并且相邻两个元素之间的差值也为素数。

## 说明/提示

#### 数据规模及约定

对于 $20\%$ 的数据，如果有解，则必定有一种解，满足元素的个数不超过 $3$，且其中的所有元素都不超过 $1000$。

对于另外 $40\%$ 的数据，$2 \le A,B \le 1000$。

对于 $100\%$ 的数据，$2 \le A,B \le 10^{14},A \neq B$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

由于平均下来每个测试点为 $2.5$ 分，因而将其中一半的测试点设置为 $2$ 分，另一半设置为 $3$ 分。

本题使用非官方的 [Special Judge](https://www.luogu.com.cn/paste/hrj05be5)，欢迎大家 hack（可私信或直接发帖）。

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #1](https://hsin.hr/coci/archive/2019_2020/contest1_tasks.pdf)  _T2 Lutrija_ 。**

## 样例 #1

### 输入

```
13 11```

### 输出

```
2
13 11```

## 样例 #2

### 输入

```
37 11```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 17```

### 输出

```
3
2 19 17```

# 题解

## 作者：3350218411ouL (赞：30)

我们可以先分类讨论一下。

两个素数$x$和$y$，其必有两种情况——两个奇数和一奇一偶。

首先来说两个奇数的情况，题目让我们找一些素数使相邻两数之差为素数，而两个奇数之差只能为偶数，即两数之差为2时，$x$与$y$可通。

再说一奇一偶的情况，因为2是唯一的偶素数，所以$x$与$y$中一定有一个为2，假定$x$为2，那么$y$与2的差为素数时，$x$与$y$可通。

我们可以用深搜来枚举以上的所有情况，但既然是要判断素数，自然少不了素数筛子，注意数据范围已经超过了int的最大范围，因此要开long long。

素数筛子：
```cpp
bool is_prime(long long x){
	if(x==1) return false; //1既不是素数，也不是合数 
	if(x==2) return true; //2是素数 
	if(x%2==0) return false; //但2的倍数不是素数 
	for(long long i=3;i*i<=x;i+=2) //标准素数筛子，但注意数据范围 
		if(x%i==0)
			return false;
	return true; //剩下的必为素数 
}
```

接下来是最核心的DFS代码，若前面的分析没看懂的可看此处：

```cpp
void dfs(long long x,long long y,int t){
	if(flag) return; //搜到可行方案就直接返回 
	if(is_prime(abs(x-y))){ //搜到了可行方案 
    	cout<<t+1<<endl; 
		//因为在上一层递归中总方案数为t+2，所以在本层中为t+1 
    	cout<<a<<" ";
    	for(int i=1;i<t;i++) cout<<ans[i]<<" ";
    	cout<<b<<endl;
    	flag=true; //标志已搜到可行方案 
    	return;
	}
	if(x!=2) //两个奇数的情况 
		for(int i=1;i<=3;i++){
			if(i==1&&is_prime(x-2)){ 
				ans[t]=2; //记录方案 
				dfs(2,y,t+1);
			} 
			//将其中一个奇数变为偶数，即变为2 
			if(i==2&&is_prime(x-2)){ 
				ans[t]=x-2;
				dfs(x-2,y,t+1);
			}
			//将其中一个奇数减2，使两个奇数差为2 
			if(i==3&&is_prime(x+2)){
				ans[t]=x+2;
				dfs(x+2,y,t+1);
			}
			//将其中一个奇数加2，使两个奇数差为2
		}
	else{ //一奇一偶的情况 
		if(is_prime(y+2)){
			ans[t]=y+2;
			dfs(y+2,y,t+1);
		}
		//将2变为与另一个奇数相差2的奇数 
	}
	return; //搜索结束 
}
```

最后再上一遍完整的AC代码：

```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;
long long ans[50]; //记录方案的数组 
long long a,b,n=2;
bool flag;
bool is_prime(long long x){ //素数筛子 
	if(x==1) return false;
	if(x==2) return true;
	if(x%2==0) return false;
	for(long long i=3;i*i<=x;i+=2)
		if(x%i==0)
			return false;
	return true;
}
void dfs(long long x,long long y,int t){ //深搜
	if(flag) return; 
	if(is_prime(abs(x-y))){
    	cout<<t+1<<endl; 
    	cout<<a<<" ";
    	for(int i=1;i<t;i++) cout<<ans[i]<<" ";
    	cout<<b<<endl;
    	flag=true;
    	return;
	}
	if(x!=2)
		for(int i=1;i<=3;i++){
			if(i==1&&is_prime(x-2)){ 
				ans[t]=2;
				dfs(2,y,t+1);
			} 
			if(i==2&&is_prime(x-2)){ 
				ans[t]=x-2;
				dfs(x-2,y,t+1);
			}
			if(i==3&&is_prime(x+2)){
				ans[t]=x+2;
				dfs(x+2,y,t+1);
			}
		}
	else{
		if(is_prime(y+2)){
			ans[t]=y+2;
			dfs(y+2,y,t+1);
		}
	}
	return;
}
void inp(){
	cin>>a>>b; //输入
	return;
}
void work(){
    if(is_prime(abs(a-b))){ //特判，若a和b可达，直接输出 
    	cout<<n<<endl<<a<<" "<<b;
    	return;
	}
    dfs(a,b,1); //因为输出方案时i从1开始，所以t从1开始 
    if(!flag) cout<<"-1"; //若没搜到，输出-1 
	return;
}
int main(){
	ios::sync_with_stdio(false); //输入输出流加速代码 
	inp();
	work();	
	return 0; //代码结束 
}
```
以上是本蒟蒻的第一份题解，若有错误，请大佬指正，谢谢。

感谢bowlder_lover的提醒，有一段代码是多余的，现已修正。


---

## 作者：L_zaa_L (赞：11)

# 分析
很简单的一个思路，因为质数除了 2 以外都是奇数，而且奇数加奇数只能是偶数。所以当一个不为 2 的质数加减为质数，只能加减 2 。但如果这个质数为 2 的时候，只能加到质数（质数加 2 或质数减 2 ）。由于$a_i \le 10^{15}$但记得要开 long long ( 我就是没开 long long 一直过不了）。
# 代码
看起来很长，其实思路超级简单。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[32],sum1=1;
bool zs(int sd){//判断是否为质数
    if(sd==1) return 1;//一需要特判
    for(int i=2;i<=sqrt(sd);i++){
        if(sd%i==0) return 1;
    }
    return 0;
}
int main(){
    cin>>n>>m;
    a[1]=n;
    if(n-2==m){
        cout<<2<<endl; 
        cout<<n<<" "<<m;
        return 0;
    }
    else if(n+2==m){
        cout<<2<<endl; 
        cout<<n<<" "<<m;
        return 0;
    }//特判
   else if(zs(n-2)==0&&n!=2&&zs(n-4)&&zs(n-2)==1){
        sum1++;
        a[sum1]=n-2;
        sum1++;
        a[sum1]=2;
    }
    else if(zs(n+2)==0&&n!=2&&zs(n)==0&&zs(n-2)==1){
        sum1++;
        a[sum1]=n+2;
        sum1++; 
        a[sum1]=2;
    }
    else if(n!=2&&zs(n-2)==0){
        sum1++;
        a[sum1]=2;
    }//使当前到达 2
    else if(zs(n-2)==1&&zs(n+2)==1&&n!=2&&zs(n-2)==1){
        cout<<"-1";
        return 0; 
    }//不行就输出 -1
    if(zs(m+2)==0&&m!=2&&zs(m)==0&&zs(m-2)==1){
        sum1++;
        a[sum1]=m+2;
        sum1++;
        a[sum1]=m; 
    }
    else if(zs(m-2)==0&&m!=2&&zs(m-4)==0&&zs(m-2)==1){
        sum1++;
        a[sum1]=m-2;
        sum1++;
        a[sum1]=m;
    }else if(m!=2&&zs(m-2)==0){
        sum1++;
        a[sum1]=m;
    }//倒着到达2
    else if(zs(m-2)==1&&zs(m+2)==1&&m!=2&&zs(m-2)==1){
        cout<<"-1";
        return 0; 
    }//判断行不行
    if(sum1==1) cout<<"-1";
    cout<<sum1<<endl; 
    for(int i=1;i<=sum1;i++){
        cout<<a[i]<<" ";
    }
    return 0;
}
```
其实这段序列按照这个代码，最多有五个（不必多说），而且思路能够理解（至少我这个蒟蒻想到的代码一定很简单）。记得把 int 改成 long  long 。

望管理员放过

---

## 作者：hensier (赞：10)

这是一道构造题。

如果想要两个素数 $x,y$（$x \gt y$）的差值为素数，那么有下列几种情况：

- $x,y$ 均为奇数。则 $x-y$ 为偶数，此时 $x-y$ 只能为 $2$。即 $x-y=2$。

- $x$ 为奇数，$y=2$。则 $x-y$ **有可能** 是素数。即要判断 $x-y$ 是否为素数。

- $x,y$ 均为偶数的现象是不可能出现的，因为只有一个偶素数 $2$。

综上所述，对于输入中的 $A,B$，我们应当找出 $[A-2,A+2], [B-2,B+2]$ 区间内所有的素数放入序列 $a$，同时不要忘记将 $2$ 也放入序列中。

这时，我们应当将序列中的重复元素删去，具体操作可以借助 `unique` 函数。该函数与 `sort` 与 `lower_bound` / `upper_bound` 均有相似之处：

```cpp
int a[11]={0,3,5,1,3,2,8,2,1,5,4};
sort(a+1,a+11);
for(int i=1;i<=10;i++)cout<<a[i]<<" ";
//输出：1 1 2 2 3 3 4 5 5 8 
int len=unique(a+1,a+11)-a-1;
for(int i=1;i<=10;i++)cout<<a[i]<<" ";
//输出：1 2 3 4 5 8 4 5 5 8（重复的元素将被置于末尾）
for(int i=1;i<=len;i++)cout<<a[i]<<" ";
//输出：1 2 3 4 5 8
```

不过该函数只对单调递增的序列有效，即只排除相邻两个相同元素中的后一个，因此要先排序。特别地，当需要对数组下标开头为 $1$ 的数组执行 `unique` 函数时，在最后需要减 $1$，否则将会发生错误。

接着是题目核心的实现。刚才已经将所有可能满足条件的情况一一分析完毕了。接着，我们需要开始构造另一个序列，表示最终的答案。

由于答案序列元素的个数未知，因此可以考虑进行 `dfs`。

在初学 `dfs` 的时候，我们一定对组合输出不陌生。

例如：从 $1 \sim n$ 中选取 $x$ 个数（$1 \le n,x \le 10$），要求每一种方案中所有的数互不相同，但大小顺序不限。如果 $n=3, x=2$，则最终的方案为：

```plain
1 2 
1 3 
2 1 
2 3 
3 1 
3 2
```

`C/C++` 代码：

```cpp
#include<stdio.h>
int n,x,a[11];
bool v[11];
void dfs(int k)
{
    if(k>x)
    {
        for(int i=1;i<=x;i++)printf("%d ",a[i]);
        putchar('\n');
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(v[i])continue;
        a[k]=i;
        v[i]=true;
        dfs(k+1);
        v[i]=false;
    }
}
int main()
{
    scanf("%d%d",&n,&x);
    dfs(1);
    return 0;
}
```

类似地，若素数序列元素个数设为 $n$，那么我们可以先对序号进行枚举，再通过序号得到一个新的答案序列。如果该序列符合条件，那么直接输出即可。

`C++` 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long A,B,a[11];
int n=1,id[11];
bool v[11];
bool check(long long x)//素数判断函数
{
    if(x<2)return false;
    if(x==2)return true;
    if(x%2==0)return false;
    for(long long i=3;i*i<=x;i+=2)if(x%i==0)return false;
    return true;
}
void dfs(int k,int x)
{
    if(k>x)
    {
        bool flag=true;
        if(a[id[1]]!=A||a[id[x]]!=B)return;//必须要满足第一个元素为 A，最后一个为 B
        for(int i=1;i<=x;i++)
        {
            if(!check(llabs(a[id[i]]-a[id[i-1]])))
            {
                flag=false;
                break;
            }
        }
        if(flag)//输出可行的方案
        {
            printf("%d\n",x);
            for(int i=1;i<=x;i++)printf("%lld ",a[id[i]]);
            putchar('\n');
            exit(0);
        }
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(v[i])continue;
        id[k]=i;
        v[i]=true;
        dfs(k+1,x);
        v[i]=false;
    }
}
int main()
{
    scanf("%lld%lld",&A,&B);
    if(check(llabs(A-B)))//特判 A-B 为素数的情况
    {
        printf("2\n%lld %lld\n",A,B);
        return 0;
    }
    a[1]=2;//将素数 2 直接加入到序列中
    for(long long i=A-2;i<=A+2;i++)
    {
        if(i%2==0)continue;
        if(check(i))a[++n]=i;
    }
    for(long long i=B-2;i<=B+2;i++)
    {
        if(i%2==0)continue;
        if(check(i))a[++n]=i;
    }
    sort(a+1,a+n+1);//执行 unique 前必须先排序
    n=unique(a+1,a+n+1)-a-1;//这里应该要减 1，因为数组起始下标为 1
    for(int i=3;i<=n;i++)dfs(1,i);//从 3 到 n 枚举元素个数
    puts("-1");
    return 0;
}
```

---

## 作者：新版米奇奇米 (赞：7)

发现相邻的奇数只能恰好差 $2$（偶质数只有 $2$）。

而大于 $1$ 的连续的奇数有且仅有一个能被 $3$ 整除，也就是说三个连续的奇数至多有两个是质数。

所以相邻的奇数最多只有两个。

但我们可以放偶质数 $2$。显然，放多个 $2$ 肯定不优。

于是我们就有 `A A-2/A+2 2 B-2/B+2 B` 这样的构造形式，根据情况可以省略部分。

这样就能过了，本着精益求精的精神我们继续探究。

拿 $A$ 来讲，要存在合法的条件必须满足 $A$ 是孪生质数中的一个。

假设 $A$ 和 $A-2$ 是质数，我们显然不需要构造一个 $A-2$ 项因为 $A$ 和 $2$ 的差就是 $A-2$。

所以就可以少判断 $A-2$ 这一项啦。

时间复杂度 $O(\sqrt A)$。

***code:***

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define For(i,x,y)for(i=x;i<=(y);i++)
ll c[6];
bool prime(ll p)
{
	if(p<2)return 0;
	int i;
	For(i,2,sqrt(p))
	if(!(p%i))return 0;
	return 1;
}
int main()
{
	ll a,b;
	cin>>a>>b;
	if(a==2&&b==2)cout<<-1,exit(0);
	if(llabs(a-b)==2)cout<<"2\n"<<a<<' '<<b,exit(0);
	int x,y,d=0,i;
	x=(prime(a-2)?1:(prime(a+2)?2:(a==2?3:0)));
	y=(prime(b-2)?1:(prime(b+2)?2:(b==2?3:0)));
	if(!x||!y)cout<<-1,exit(0);
	c[++d]=a;
	if(x==2)c[++d]=a+2;
	if(x!=3&&y!=3)c[++d]=2;
	if(y==2)c[++d]=b+2;
	c[++d]=b;
	cout<<d<<endl;
	For(i,1,d)cout<<c[i]<<' ';
	return 0;
}
```

---

## 作者：Kreado (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P7200)

题意不多说了。

### 思路

如果想要两个素数 $x,y(x>y)$ 的差也为素数，那么有以下几种情况：

- $x,y$ 均为奇数，则 $x-y$ 为偶数，此时 $x-y$ 只能为 $2$，即 $x=y+2$。
- $x$ 为奇数，$y=2$，则 $x-y$ 有可能为素数。
- $x,y$ 均为偶数的情况是不可能出现的。

易证：连续的三个奇数中有一个必定有一个为 $3$ 的倍数，也就是说每 $3$ 个连续的奇数至少有 $2$ 个为素数。

所以序列中每连续的 $3$ 个数中必定有一个 $2$。

如果 $A+2$ 是素数的话，就立即放入这个序列里，如果 $B\ne2$，就再放一个 $2$。

如果 $A+2$ 不是素数，$A-2$ 是素数，那么就只放一个 $2$，因为 $A-4$ 可能不是素数。

如果 $B+2$  是素数，且前面的操作执行过或者 $A=2$ 时，就把 $B+2$ 放入这个序列里。

如果 $A+2,A-2(A\ne2)$ 或 $B+2,B-2(B\ne2)$ 都不是素数，就不能构造出这样一个序列，输出 `-1`。

### 贴贴代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline bool prime(ll x){
	if((x!=2&&x%2==0)||x<=1)
		return 0;
	for(ll i=3;i<=sqrt(x);i+=2)
		if(x%i==0)
			return 0;
	return 1;
}
ll ans[101],l,r,cnt,okp,ok1;
int main(){
	scanf("%lld%lld",&l,&r);
	if((!prime(l+2)&&!prime(l-2)&&l!=2)||(r!=2&&!prime(r+2)&&!prime(r-2))){
		printf("-1");
		return 0;
	}
	ans[++cnt]=l;
	if(prime(l+2)){
		ans[++cnt]=l+2;
		if(r!=2)	
			ans[++cnt]=2,okp=1;
	}
	else if(prime(l-2)){
		if(r!=2)	
			ans[++cnt]=2,okp=1;
	}
	if(prime(r+2)&&(okp||l==2))
		ans[++cnt]=r+2;
	ans[++cnt]=r;  
	printf("%lld\n",cnt);
	for(ll i=1;i<=cnt;i++)
		printf("%lld ",ans[i]);
	return 0;
}

```


---

## 作者：dengqingrui123 (赞：2)

# P7200 题解

##### [题目传送门](https://www.luogu.com.cn/problem/P7200)

## STEP 0 前置知识

### 如何判断质数

```cpp
bool is_prime(long long x){  
	if(x == 1) return false;
	if(x == 2) return true;
	if(x % 2 == 0) return false;
	for(long long i = 3;i * i <= x; i ++)//直接筛从 3 开始的奇数
		if(x % i == 0)
			return false;
	return true;
}
```

## STEP 1 如何 dfs

通过分情况讨论标记是否可行，然后用 $ans$ 数组储存，详见代码中的注释。

```cpp
void dfs(long long x,long long y,int t){ 
	if(boo) return; //可行就直接跳出DFS
	if(is_prime(abs(x-y))){
		boo=true;//标记
     		printf("%d\n",t + 1);//输出答案
    		printf("%lld ",a);
    		for(int i=1;i<t;i++) printf("%lld ",ans[i]) ;
    		printf("%lld ", b);
    		return;
	}
	if(x!=2)//判断为两个奇数（因为质数中的偶数只有 2 ，所以只要判断它是否为 2 即可
		for(int i=1;i<=3;i++){
			if(i==1&&is_prime(x-2)){ //方案 1 ：将其中一个奇数变为 2 
				ans[t]=2;
				dfs(2,y,t+1);
			} 
			if(i==2&&is_prime(x-2)){ //方案 2 ：将其中一个奇数 -2 ，使两个奇数差 2
				ans[t]=x-2;
				dfs(x-2,y,t+1);
			}
			if(i==3&&is_prime(x+2)){//方案 3 ：将其中一个奇数 +2 ，使两个奇数差 2
				ans[t]=x+2;
				dfs(x+2,y,t+1);
			}
		}
	else//一奇一偶的情况
		if(is_prime(y+2)){
			ans[t]=y+2;
			dfs(y+2,y,t+1);
		}
	return;
}
```

# STEP 2 AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans[50];
long long a,b,n=2;
bool boo;

bool is_prime(long long x){  
	if(x == 1) return false;
	if(x == 2) return true;
	if(x % 2 == 0) return false;
	for(long long i = 3;i * i <= x; i ++)
		if(x % i == 0)
			return false;
	return true;
}

void dfs(long long x,long long y,int t){ 
	if(boo) return; 
	if(is_prime(abs(x-y))){
		printf("%d\n",t + 1);
    	printf("%lld ",a);
    	for(int i=1;i<t;i++) printf("%lld ",ans[i]) ;
    	printf("%lld ", b);
    	boo=true;
    	return;
	}
	if(x!=2)
		for(int i=1;i<=3;i++){
			if(i==1&&is_prime(x-2)){ 
				ans[t]=2;
				dfs(2,y,t+1);
			} 
			if(i==2&&is_prime(x-2)){ 
				ans[t]=x-2;
				dfs(x-2,y,t+1);
			}
			if(i==3&&is_prime(x+2)){
				ans[t]=x+2;
				dfs(x+2,y,t+1);
			}
		}
	else
		if(is_prime(y+2)){
			ans[t]=y+2;
			dfs(y+2,y,t+1);
		}
	return;
}

int main(){
	scanf("%lld%lld",&a,&b);
    dfs(a,b,1); 
    if(!boo) puts("-1");	
	return 0; 
}
```



---

## 作者：_7Mr (赞：2)

# 思路
这个题首先是对素数的理解：如果 $2$ 个数都是素数，那么有两种情况：一奇一偶或者是 $2$ 个奇数。

如果是 $2$ 个奇数的情况：由于题目要求两数之差为素数，而两个奇数之差为偶数，所以只能为 $2$。

如果是一奇一偶的情况：其中偶数必定为 $2$。综上，要找的素数仅可能在所给素数 $a$ 的 $[a-2,a+2]$ 中。

对于搜索的设定：对于 $2$ 个奇数的情况：可以对 $2,a-2,a+2$ 每种可能作为下一层搜索的一种方案来进行递归。对于一奇一偶的情况：如果两者之差为素数，则可以直接输出。如果两者之差不是素数，只能判断结果 $+2$ 的情况。
# ACcode
太丑了，就不放出来丢人显眼了。

---

## 作者：haozinojc (赞：1)

## 思路：

这一道题的范围不算大，序列数字的数量最大 30，所以我第一反应想的是**深搜**。

我的想法是将整个序列从左往右推，对于当前填的数字，如果与最右边的数字的差是质数时，就说明整个序列符合要求了，此时输出个数和整个序列就行了。

对于两个质数，有两种情况：

- 一奇一偶，那么就是一个 2 和一个奇数质数，那么以这个奇数质数为差距，确定下一个数是否是质数。

- 两个奇数，那么跟上面一样，分别以 2 为差距，以其中一个奇数为差距，并判断下一个数是不是质数，是就加入数组。

## 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define re register int
using namespace std;
const int N=50;
int ans[N],l,r;
bool prime(int num){
	if(num==1)return false;
	if(num==2)return true;
	if(num%2==0)return false;
	for(re i=3;i<=sqrt(num);i+=2){
		if(num%i==0)return false;
	}
	return true;
}

void dfs(int x,int y,int len){
	if(prime(abs(x-y))){
    	cout<<len+2<<"\n";
    	cout<<l<<" ";
    	for(re i=1;i<=len;i++)cout<<ans[i]<<" ";
    	cout<<r;
    	exit(0);
	}
	if(x!=2){
		if(prime(x-2)){ 
			ans[len+1]=2;
			dfs(2,y,len+1);
		} 
		if(prime(x-2)){ 
			ans[len+1]=x-2;
			dfs(x-2,y,len+1);
		}
		if(prime(x+2)){
			ans[len+1]=x+2;
			dfs(x+2,y,len+1);
		}
	}
	else if(prime(y+2)){
		ans[len+1]=y+2;
		dfs(y+2,y,len+1);
	}
	return;
}
signed main(){
	cin>>l>>r;
	dfs(l,r,0);
	cout<<-1;
	return 0;
}
```


---

## 作者：Guoliyuan2023 (赞：1)

### 题外话（可以跳过）：
本蒟蒻的第二篇题解，烦请管理员包容亿下……
# 正题：P7200 [COCI2019-2020#1] Lutrija
## 题目
[P7200 原题传送门](https://www.luogu.com.cn/problem/P7200)

给定两个素数 $A , B$，构造一个开头和结尾分别为 $A$ 和 $B$ 的序列，使得其所有元素均为素数，并且相邻两个元素之间的差值也为素数。如果无解，输出 $-1$。
## 思路
（以下“质数”简称“质”，“奇数”简称“奇”，“偶数”简称“偶”）

$2$ 是唯一的偶质数，且奇加奇只能偶。

当一个不为 $2$ 的质加减还为质，只能加减 $2$。

如果这个质为 $2$，只能为质加 $2$ 或质减 $2$。

所以这题就变得清楚了许多。
## 上代码（勿喷）
还抄……

就这题你也抄……

## 温馨提示：

1. 那堆 if 别搞岔了。

2. 十年 OI 一场空，不开 ll 见祖宗。

3. 题目千万条，诚信第一条，代码不规范，棕名两行泪。
## The End

---

## 作者：zfw100 (赞：0)

# P7200 [COCI2019-2020#1] Lutrija 题解

[题目传送门](https://www.luogu.com.cn/problem/P7200)

## 解题思路

由于 $2$ 是唯一的偶质数，同时也是最小的质数，所以我们可以根据这个进行分类讨论。

-  $A$ 和 $B$ 一奇一偶，则 $B$ **一定**等于 $2$，由于奇数减偶数等于奇数，所以只需要判断结果是否为质数即可。

-  $A$ 和 $B$ 同为奇数，由于奇数减奇数等于偶数，所以只需要判断两数之差是否为 $2$ 即可。

-  $A$ 和 $B$ 同为偶数，由于给定的两数都为质数，且两数一定不相等，所以此情况不存在。

之后 `dfs` 即可。

## 注意事项

开 `long long`。

代码不放了。

---


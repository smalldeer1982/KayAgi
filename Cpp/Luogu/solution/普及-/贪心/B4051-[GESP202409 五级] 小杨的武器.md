# [GESP202409 五级] 小杨的武器

## 题目描述

小杨有 $n$ 种不同的武器，他对第 $i$ 种武器的初始熟练度为 $c_i$。

小杨会依次参加 $m$ 场战斗，每场战斗小杨只能且必须选择一种武器使用，假设小杨使用了第 $i$ 种武器参加了第 $j$ 场战斗，战斗前该武器的熟练度为 $c'_i$，则战斗后小杨对该武器的熟练度会变为 $c'_i + a_j$。需要注意的是，$a_j$ 可能是正数，$0$ 或负数，这意味着小杨参加战斗后对武器的熟练度可能会提高，也可能会不变，还有可能降低。

小杨想请你编写程序帮他计算出如何选择武器才能使得 $m$ 场战斗后，自己对 $n$ 种武器的熟练度的**最大值尽可能大**。

## 说明/提示

### 样例 1 解释

一种最优的选择方案为，第一场战斗小杨选择第一种武器，第二场战斗小杨选择第二种武器。

### 数据规模与约定

| 子任务编号 | 数据点占比 | $n$ | $m$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $=1$ | $\leq 10^5$ |
| $2$ | $20\%$ | $\leq 10^5$ | $=2$ |
| $3$ | $60\%$ | $\leq 10^5$ | $\leq 10^5$ |

对全部的测试数据，保证 $1 \leq n, m \leq 10^5$，$-10^4 \leq c_i, a_i \leq 10^4$。

## 样例 #1

### 输入

```
2 2
9 9
1 -1```

### 输出

```
10```

# 题解

## 作者：Hootime (赞：14)

_一道水题。——[yuruilin2026](https://www.luogu.com.cn/user/1294410)_ 
## 形式化题意
有 $n$ 个元素 $m$ 次操作，第 $i$ 次操作能让 $c$ 中的一个元素加上 $a_i$。求最后 $c$ 中最大元素的最大值。

## 思路
既然题目要求最大元素的最大值，那我们可以重点培养一个元素，使它最大化。很显然，重点培养 $c$ 中原本就是最大的元素最优。因此，只要将正数都加给最大值，把 $0$ 和负数扔给其他元素就行了。

但是有一种特殊情况：在 $c$ 只有一个元素的情况下，就只能全加了。

## 代码
### 注释版

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, maxn = INT_MIN;
int main(){
    scanf("%d %d", &n, &m);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        maxn = max(maxn, tmp); // 找最大值
    }
    for(int i = 1, tmp; i <= m; i++){
        scanf("%d", &tmp);
        if(n == 1) maxn += tmp; // 只有一个元素就全加
        else if(tmp > 0) maxn += tmp; // 否则只要正数
    }
    printf("%d", maxn);
}
// 感谢 yuruilin2026 的教导

```
### 无注释版
_请不要复制代码。_

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, maxn = INT_MIN;
int main(){
    scanf("%d %d", &n, &m);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        maxn = max(maxn, tmp);
    }
    for(int i = 1, tmp; i <= m; i++){
        scanf("%d", &tmp);
        if(n == 1) maxn += tmp;
        else if(tmp > 0) maxn += tmp;
    }
    printf("%d", maxn);
}

```

---

## 作者：__UrFnr__ (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/B4051)

**题目大意**：这道题其实很简单，也就是要找到最高的熟练度，然后加上不为负数熟练度变化值，使这个结果尽量的大。

**题目思路**：这道题我们考虑贪心思想，贪心策略是我们需要找到最高的熟练度，然后累加 $>0$ 的熟练度变化值，最后输出的答案便是熟练度的最大值。还有一个需要注意的地方，如果 $n=1$ 的话无论这个熟练度的变化值是正数还是负数，都要加上。

代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, c[100010], a[100010], maxa = -0x3f3f3f3f;//一开始的最大值要尽量的小
int main () {
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) {
        cin >> c[i];
        maxa = max (maxa, c[i]);//统计最大的熟练度
    } 
    for (int i = 1; i <= m; i ++) 
        cin >> a[i];
    for (int i = 1; i <= m; i ++) 
        if (n == 1 || a[i] > 0) 
            maxa += a[i];//加上大于0的熟练度变化值，特殊情况n=1时，无论如何都要加上
    cout << maxa;//输出答案
}
```

---

## 作者：Lzh2012 (赞：7)

_~~好水的一题~~_ 

### [题目传送门](https://www.luogu.com.cn/problem/B4051)


### 题目分析

对于每一个武器，我们用 $maxn$ 来记录熟练度最高的一个。接着每输入一场比赛的熟练值，就判断是不是正数，是就让 $maxn$ 加上。这样能保证 $maxn$ 是最大的。不过要小心，当 $n=1$ 时，只有一个武器，熟练值不管是不是正数都要加。


## 代码（非常简单）
~~~
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m,maxn=-1e5,o;//maxn一定要小！
	cin>>n>>m;
	for(long long i=1; i<=n; i++){
	    cin>>o;
        if(o>maxn) maxn=o;//打擂台
	}
	for(long long j=1; j<=m; j++){
		cin>>o;
		if(o>0 || n==1) maxn+=o;
	}
	cout<<maxn;
	return 0;
}

---

## 作者：__Cyn__ (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B4051)

思路：本题使用贪心。输入时先找出熟练度最高的武器，令 $x=\max_{1\le i\le n}a_i$。对于第 $i$ 场战斗，若 $n=1$ 或 $c_i>0$，就使用熟练度最高的武器战斗，则令 $x=x+c_i$；否则使用其它武器战斗，因为此过程不对答案造成影响，所以不需要执行此流程。战斗完成后，输出答案 $x$ 即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005];
int main () {
	int n, m, maxn = INT_MIN;//maxn不能设为0，否则80ps
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		maxn = max (maxn, a[i]);
	}
	for (int i = 1; i <= m; i++) {
		int c;
		cin >> c;
		if (n == 1 || c > 0) maxn += c;
	}
	cout << maxn;
	return 0;
} 
```

---

## 作者：dengshunyang (赞：4)

[B4051 [GESP202409 五级] 小杨的武器](https://www.luogu.com.cn/problem/B4051)

本蒟蒻第一篇题解，求过qwq

这题十分简单（~~不是，五级呀~~），用最大初始值武器，只加经验值为正数的战斗就行。

~~但我 WA 了好几次。~~

有一个点需要注意，如果只有一把武器，那这把武器需要参加所有战斗。

后来加了个特判，才对。

这是 AC 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10;
int n,m,c[N],a[N],i;
int main(){
	cin>>n>>m;
	for(int j=1;j<=n;j++)cin>>c[j];//小杨对武器的初始熟练度
	if(n==1){//如果只有一把武器,需要进行特判
		int maxc=c[n]; 
		for(int j=1;j<=m;j++){//每场战斗后武器熟练度的变化值
			int x;
			cin>>x;
			maxc+=x;
		}
		cout<<maxc;
		return 0;
	}
	sort(c+1,c+n+1);//将武器初始熟练度排序，找出最大的 
	for(int j=1;j<=m;j++){
		int x;
		cin>>x;
		if(x>0){//如果战斗经验小于等于0，那我们不计算 
			a[++i]=x;
		}
	}
	long long maxc=c[n];
	for(int j=1;j<=i;j++){
		maxc+=a[j];
	}
	cout<<maxc;
	return 0;//结束
}
```

---

## 作者：sunhaozhe111022 (赞：3)

**思路：**

本题很明显是贪心，因为要求武器熟练度最大值，那么最优的情况肯定是拿初始熟练度最大的去打武器熟练度变化值为正数的战斗。而其他非整数的则拿其它武器去打。

**特别地：** 

当只有一把武器时要把所有的变化值加起来。

**实现：**

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,ma=-1e5;//记得赋值负数
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		ma=max(ma,a);
	}
	for(int i=1;i<=m;i++)
	{
		cin>>b;
		if(n!=1)
		{
			if(b>=0) ma+=b;
		}
		else ma+=b;
	}
	cout<<ma;
    return 0;
}
```

---

## 作者：BWsha2k (赞：2)

## [GESP202409 五级] 小杨的武器 题解

由于最后只看所有武器中 $c_i$ 的最大值，因为 $a_i\gt 0$ 的战斗一定可以使武器的 $c_i$ 变大，所以我们可以将所有大于 $0$ 的 $a_i$ 全部加到初始 $c_i$ 最大的一个武器，这样最后得到的 $c_i$ 一定是最大的，此时所有小于 $0$ 的 $a_i$ 都可以加到别的武器上。

但是有一种特殊情况，如果 $n=1$，那么就没有其它的武器帮他分担 $a_i\lt 0$ 的战斗，而每一次战斗必须拿出一把武器，所以只需要把所有的 $a_i$ 都加到这把武器的 $c_i$ 中就可以。

Code：


```cpp
#include<bits/stdc++.h>#include<iostream>
#include<cmath>
#include<algorithm>
#define b0fitn for(int i=0;i<n;i++)
#define b1fitn for(int i=1;i<=n;i++)
using namespace std;

const int MAXN = 1E5+55;
int n, m, c[MAXN], a[MAXN];
int ans = -999999;

void solve()
{
	b0fitn ans = max(ans, c[i]);
	for(int i = 0;i < m;i++)
	{
		if(a[i] >= 0) ans += a[i];
	}
	cout << ans << endl;
	return;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	b0fitn cin >> c[i];
	for(int i = 0;i < m;i++) cin >> a[i];
	if(n == 1)
	{
		ans = c[0];
		for(int i = 0;i < m;i++) ans += a[i];
		cout << ans << endl;
	}
	else solve();
	return 0;
}
```

---

## 作者：luojingjie (赞：2)

# 题解：B4051 [GESP202409 五级] 小杨的武器
## 题意
题面够清楚了，真没必要说了。
## 思路
这就一眼的贪心，最优方案就是让熟练度最大的武器参加每一场经验为正的战斗。记得加只有一种武器的特判。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int c[100005],a[100005];
int maxx=-1000000,sum,ans;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>c[i];
        maxx=max(maxx,c[i]);
    }
    for(int i=1;i<=m;i++){
        cin>>a[i];
        sum+=a[i];
        if(a[i]>=0){
            ans+=a[i];
        }
    }
    if(n==1){
        cout<<maxx+sum;
    }
    else{
        cout<<maxx+ans;
    }
    return 0;
}
```

---

## 作者：abc1234shi (赞：1)

# 题意
题意不是很绕，但难点在于自己对 $n$ 种武器的熟练度的最大值尽可能大是什么？很多人觉得是所有武器的总和，其实不然（会出这么简单的题目吗？）。

自己对 $n$ 种武器的熟练度的最大值尽可能大其实是熟练度最高的武器的熟练度，知道题意，就很好解了。
# 思路
有的人一想，欸，找出刚开始最高熟练度的武器，然后让他一直增加不就好了。但是，请注意：**熟练度可能是负数**（但凡有常识的都知道）。

那怎么办呢？其实我们想到上一点就已经做出了一半，因为每局必战且既然有负数，我们就不让熟练度最高的武器出战，就让别的出战不就好了，如果有正数就让熟练的最高的出战，这样可以保持熟练度最高的武器**单调不降**。

有的人想到这个，就写出代码直接交了，但却只能拿到 $80$ 分，这是为什么呢？仔细观察数据点，他如果 $n$ 只有 $1$ 时不就只能让熟练度最高的出战吗？这是我们就顾不上是否要不加负数的情况了。

# 总结一下（坑点）：
- 自己对 $n$ 种武器的熟练度的最大值尽可能大其实是熟练度最高的武器的熟练度。
- 每一局都必须战，不能因为熟练度减少而避战。
- 要分类讨论，他如果 $n$ 只有 $1$ 时就只能让熟练度最高的一直出战。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110000],b[110000];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	for(int i=1;i<=m;i++){
		if(b[i]<0){
			if(n==1){
				a[n]+=b[i];
			}
			else {
				a[n-1]+=b[i];
			}
		}
		else {
			a[n]+=b[i];
	}
		
	}
	cout<<a[n];
	return 0;
}
```

---

## 作者：jiangyunuo (赞：1)

### 题目意思：

很简单，有 $n$ 把武器和 $m$ 场战斗，小杨对第 $i$ 把武器的熟练度为 $c_i$，每场战斗，小杨都要选择一把武器。第 $j$ 场比赛结束时，小杨对于其所使用的武器，熟练度会加 $a_j$。

### 大体思路：

有两种情况：

1. $n = 1$。对于这样的情况，我们只有一把武器，只能一直使用。

2. $n \ne 1$。对于这样的情况，我们可以选择熟练度最高的为“主武器”，然后从剩下的武器中选一把为“副武器”（虽然没用，只是方便理解），之后，如果下场战斗增加的熟练度为正数就用“主武器”，反之用“副武器”，最后“主武器”的熟练度就是答案了。

### 代码：

```cpp
#include<bits/stdc++.h>  
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int c,a;
    int ans=-100000;
    for(int i=1;i<=n;i++){
    	cin>>c;
    	ans=max(ans,c);
	}
	for(int i=1;i<=m;i++){
		cin>>a;
		if(n==1||a>0)ans+=a;   //当 n 为 1，或 a 为正数时，使用“主武器”。
	}
	cout<<ans<<endl;
    return 0;
}
```

---

## 作者：csxx601cjy (赞：1)

## 题解：[B4051 [GESP202409 五级] 小杨的武器](https://www.luogu.com.cn/problem/B4051)
### 思路
贪心法，每次增加的熟练度如果是正数，就去训练初始熟练度最高的武器；如果是负数，去训练其他的武器，反正不是最强的武器；如果是 $0$，那不就等于啥也没干吗。最后的答案就是初始熟练度最大的武器的熟练度。

注意特判，如果 $n=1$，那就没得选，每次都只训练那一把武器。

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c[100010],a[100010],ans=0;
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>c[i];
	for(int i=0;i<m;i++)cin>>a[i];
	if(n==1){//只有一把武器的情况
		ans=c[0];
		for(int i=0;i<m;i++)ans+=a[i];
		cout<<ans;
		return 0;
	}
	sort(c,c+n);
	ans=c[n-1];//初始熟练度最大的武器
	for(int i=0;i<m;i++)ans+=a[i]>0?a[i]:0;//如果是负数就不增加
	cout<<ans;
	return 0;
}
```

---

## 作者：AIregister (赞：1)

## 思路 ##
思路很简单，我们只需要排序一下，努力发展最大的，即大于零让最大的食用，小于零让最小的背锅，这样一个思路可以让最大值最大。
## 代码 ##
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001];
int main(){
	int n;
	scanf("%d",&n);
	int m;
	scanf("%d",&m);
	int t;
	for(int i=0;i<n;i++) scanf("%d",&a[i]);
	sort(a,a+n);
	for(int i=0;i<m;i++)
	{ 
		scanf("%d",&t);
		if(t>0)
			a[n-1]+=t;//大于0的给大的发育
		else
			a[0]+=t;//小于等于0让最弱的背锅
	}
	printf("%d",a[n-1]);
	return 0;
}
```

---

## 作者：guer_loser_lcz (赞：1)

# 题解
## 思路
本题限制很少，贪心即可。

贪心方法：

首先，找出小杨熟练度最高的武器。

其次，对于每场加熟练度的战斗，使用这把武器。否则用另一把~~倒霉的~~勇于牺牲的武器~~凑数~~上场。

特别的，当只有一把武器时，没有~~倒霉的~~勇于牺牲的武器~~凑数~~上场，只能用唯一一把。

重要的，因为熟练度可能都为负，所以储存最大值的变量应初始化成无限小。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,mx=-114514,x,t;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x;
		mx=max(mx,x);
	}//找最熟练的武器
	if(n==1){
	    for(int i=1;i<=m;i++){
	        cin>>x;
	        mx+=x;
	    }//只有一把
	}else{
	    for(int i=1;i<=m;i++){
    		cin>>x;
    		mx+=max(x,0ll);//找倒霉蛋凑数
    	}
	}
	cout<<mx;//输出
	return 0;
} 
```

---

## 作者：SSqwq_ (赞：1)

## 分析

考虑简单贪心。我们发现最终求的是最大值，因此我们可以分类讨论。

- 若 $n=1$，则只有一样武器，直接拿它参加每一场战斗即可。

- 若 $n>1$，则可以把初始熟练度最大的武器拿出来参加所有 $a_i>0$ 的战斗，其余战斗一定亏损，我们随便找个其他的武器参加就行了。

时间复杂度 $O(n+m)$，足以通过此题。

## AC Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,maxn=-2e17,x;
void work(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>x;
		maxn=max(maxn,x);
	}
	for(int i=1;i<=m;++i){
		cin>>x;
		if(n==1)maxn+=x;
		else if(x>0)maxn+=x;
	}
	cout<<maxn<<"\n";
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--){
		work();
	}
	return 0;
}

```

---

## 作者：Just_A_Sentence (赞：1)

# 题解

贪心，首先选出最大的 $c_i$，用它参加每一场 $a_j$ 为正数的战斗，其它的战斗用别的武器打就行，不用计算。然而这个思路需要特判，当 $n=1$ 时只能用这一把武器参加所有的战斗。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int imax=-1e9;
	int n,nn,m;
	scanf("%d%d",&n,&m);
	nn=n;
	while(n--){
		int x;
		scanf("%d",&x);
		imax=max(imax,x);//找出熟练度最大的武器。
	}
	while(m--){
		int x;
		scanf("%d",&x);
		if(x>0||nn==1) imax+=x;//如果n=1或a>0，用这把武器参加这场战斗。
	}
	printf("%d",imax);
	return 0;
}
```

---

## 作者：wuyouawa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4051)

### 思路

这是一道比较复杂的题。

首先要想最大，初始最大值一定要尽量大。

接着我们知道如果 $a_i$ 是负数，可以用比较小的值加掉，并不影响最大值。$0$ 的话无影响，否则用最大值加。

但是注意以下几个点：

-  初始最大值的初始值要设为 $-10^4$ 以下，因为这是 $c_i$ 的最大值。

-  如果 $n=1$ 时要特判，此时无论如何都得战斗。

### CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
int n, c[200005], m, a[200005], ma = -1e5; //注意ma要赋为比a[i]小的值
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &c[i]); //scanf可加快速度
		ma = max(ma, c[i]); //找目前最大的
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d", &a[i]);
		if (a[i] > 0 || n == 1)  ma += a[i]; //负数和0没有影响，但n=1时要特判
	}
	cout<<ma;
	return 0;
}
```

---


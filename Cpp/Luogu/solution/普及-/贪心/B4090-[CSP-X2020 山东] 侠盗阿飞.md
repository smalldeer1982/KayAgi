# [CSP-X2020 山东] 侠盗阿飞

## 题目描述

侠盗阿飞获得了一笔意外之财 $w$ 元钱，他想用这笔钱去帮助需要帮助的人。现在知道有 $n$ 个需要帮助的人以及他们每个人需要的钱数 $x_i$ 元（$i=0,1,2,3,\dots,n-1$），阿飞应该如何支配这笔钱使得能得到帮助的人数最多？

## 说明/提示

对于 $30\%$ 的数据，$x_i$ 为升序序列（$x_0\lt x_1\lt x_2\lt x_3\lt \dots$）。

对于 $100\%$ 的数据，$0\leq n\leq 500$，$0 \lt x_i\leq 5\times 10^4$，$0\leq w\leq 2\times 10^9$。


## 样例 #1

### 输入

```
10 5
1 2 3 4 5```

### 输出

```
4```

## 样例 #2

### 输入

```
1000 10
20 20 150 110 180 50 200 140 120 200```

### 输出

```
9```

# 题解

## 作者：chen_zhe (赞：1)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考察贪心。

首先，我们需要将所有求助者的金额按照从小到大的顺序进行排列。这一步的目的是确保在后续选择时，能够优先处理金额较小的需求，为后续的贪心策略打下基础。接下来，采用贪心算法依次累加金额：从最小的金额开始逐个累加，直到总额即将超过阿飞的预算为止。此时累计的人数就是所能帮助的最大数量。

时间复杂度主要在排序部分，采用标准库的 `std::sort`，为 $O(n \log n)$。若是使用冒泡、选择、插入排序则为 $O(n^2)$。对于 $n \le 500$ 来说，运行效率是完全满足要求的。

参考代码（只展示关键部分）：

```cpp
sort(x, x + n);
int cnt = 0;  // 帮助的人数
int sum = 0;  // 当前已使用的钱数
// 从最小的需求开始依次累加
for (int i = 0; i < n; i++) {
    if (sum + x[i] <= w) {
        sum += x[i];
        cnt++;
    } else {
        break; // 一旦加上当前需求超出 w，就退出循环
    }
}
```

---


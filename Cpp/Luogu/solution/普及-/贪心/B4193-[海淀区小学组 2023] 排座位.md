# [海淀区小学组 2023] 排座位

## 题目描述

信息学省队选手由 $a$ 名男生和 $b$ 名女生组成，他们准备乘火车去外地参加比赛。火车由若干节车厢组成，第一节车厢有 $n$ 个连续的座位，每个座位要么空着，要么已经有乘客。为了让男女选手之间增加交流，你需要按以下要求排座位：相邻的同学不能同时是男生或者是女生。

请从 $a + b$ 名学生中选出最多的学生安排在第一节车厢的空座位上以满足题目要求。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$，$0\leq a,b\leq 2\times 10^5$，$a+b>0$。

## 样例 #1

### 输入

```
5 1 1
*...*```

### 输出

```
2```

## 样例 #2

### 输入

```
6 2 3
*...*.```

### 输出

```
4```

## 样例 #3

### 输入

```
3 2 3
***```

### 输出

```
0```

# 题解

## 作者：dg114514 (赞：3)

有点类似插板？\
首先，可以发现男生数量与女生数量互换结果不变。所以我们直接令男生数量**一定**不少于女生数量。（如果男生数量少，直接~~变性~~交换数量）\
然后我们统计空座位的连通块。\
一排座位，相邻不能相同的情况下，能分成这样：（`0` 为男生，`1` 为女生）`010101010...`。易得 `0` 有 $\lceil \frac{n}{2}\rceil$ 个，`1` 有 $\lfloor \frac{n}{2}\rfloor$ 个。显然，`0` 的数量一定不比 `1` 少。而根据贪心，可以知道多的人数耗的数量尽量要多。然后分别让男女数量减去对应的座位数量即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int block[100005],top=0;
int main(){
	char c;
	int n,a,b,ans=0,cnt=0;
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++){
		cin>>c;
		if(c=='*')block[++top]=cnt,cnt=0;//连通块
		else cnt++;						 //统计
	}
	if(cnt) block[++top]=cnt;
	for(int i=1;i<=top;i++){
		if(!a&&!b)break;//优化
		int t1=(block[i]+1)/2,t2=block[i]/2;//ceil(n/2) 和 floor(n/2)
		if(a<b)swap(a,b);//保证 a >= b
		t1=min(a,t1),t2=min(b,t2);
		a-=t1,b-=t2;
		ans+=t1+t2;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LeavingAC (赞：1)

**begin**

[B4193 [海淀区小学组 2023] 排座位](https://www.luogu.com.cn/problem/B4193)

# 思路

题目很水，分类讨论即可，纯种分支结构。

我们用一个数组 $seat$ 来表示每个座位上的同学的性别：男生用 $1$ 表示，女生用 $2$ 表示，没人或已经有其他人了用 $0$ 表示。

我们可以分三种情况来讨论（以下的所有情况均基于当前性别人数大于 $0$ 做讨论，若人数已经用完则当前位置留空。）：

- 前一个座位已经有其他人了或者是空的：哪边人数多就放谁。
  
  为啥呢？举个例子，给你 $3$ 个红球和 $2$ 个黄球，你必须把它们放到同一个连续的空间且同色球不能相邻。那么显然你肯定先放红球，最后变成“红黄红黄红”的样子。

- 前一个座位是男生：这个座位就是女生。

- 前一个作为是女生：这个座位就是男生。

好了，到这里问题就已经迎刃而解了。

## 小小的空间优化

我们发现我们只用到了 $seat_i$ 和 $seat_{i-1}$。

所以我们只需要两个变量：$lst$ 和 $now$ 不断更新即可。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const ll N=2e5+10; // 注意数据范围
ll n,a,b,now,lst,ans;
string s;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>a>>b>>s;
    for (ll i=0;i<n;i++)
    {
        if (s[i]=='*') lst=0; // 有人的情况下别忘记更新lst
        else if (i==0 || lst==0) // 情况1
        {
            if (a>=b && a) a--,now=1; // 男>女
            else if (b>=a && b) b--,now=2; // 女>男
        }
        else
        {
            if (lst==1 && b) b--,now=2; // 情况2
            else if (lst==2 && a) a--,now=1; // 情况3
        }
        ans+=(bool)now; // 等价于如果当前座位是1或者2就代表坐了一个同学，ans++。
        lst=now,now=0; // 更新迭代
    }
    cout<<ans;
    return 0;
}
```

**end**

---

## 作者：Sliarae (赞：1)

这道题目可以使用贪心算法解决，我们进行如下流程：

- 从左往右考虑每个位置，如果是空的，就尽量让男生/女生中多的那个坐上去，如果不行尽量让少的那个坐上去，否则就把这个位置空着。

这个做法是非常容易想到的，时间复杂度为 $O(n)$。

下面我们证明这一贪心算法的正确性：

- 考虑反证，找这个方案与最优方案的 LCP，这就说明前面我们都是对的，但是这一步做错了。

- 发现这个错误不可能是最优方案选了空白，而我们选了男生/女生，因为这样我们可以在后面模仿最优方案，显然就没选错。最优方案放了人，而我们选了空白，这种情况也不可能发生，因为我们的策略就是尽量放人。

- 否则肯定是最优方案放男生，我们放了女生（反之亦然）。由于我们选的女生人更多，所以考虑拿出所有男女交替的连续段，错误的位置一定是在段的开头。这时可以通过翻转这一段和下一段的所有性别的方式调整，这样得到一种不劣的新方案。与前面的假设矛盾。

```cpp
#include <iostream>

using namespace std;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	int n, c[2]; 
	cin >> n >> c[0] >> c[1];
	int ans = 0, la = -1; 
	for (int i = 1; i <= n; ++i) {
		char ch;
		cin >> ch;
		if (ch == '*') la = -1; 
		else {
			int chs = (la == -1 ? c[0] < c[1] : la ^ 1);
			if (c[chs]) --c[chs], ++ans;
			la = chs;
		}
	}
	cout << ans << '\n';
	return 0; 
}
```

---

## 作者：dear_deer_land (赞：0)

因为粘错代码被打回了，我自己都绷不住了。还有事实上洛谷审核题解时会自动加句号，题解审核志愿者可以不用在结尾加句号的。![](https://cdn.luogu.com.cn/upload/image_hosting/8r8jqqu0.png)
## 简化题意
把男生和女生交叉放入空位中（可能不连续），求最多能放几个人。
## 思路
纯模拟。因为男生和女生不能相邻放置，最优方案一定是男生和女生分开放，当没有男生的时候女生隔一个放一个，当没有女生的时候同理。  
我们可以发现，因为男生和女生在本题中性质相同，但如果分开看的话就必须要对一种情况按照男生少和女生少进行两类分类讨论，这样的话不仅写起来麻烦、容易出错，并且还会让代码变得冗长丑陋。那么我们可以把男生和女生看作两种不同颜色的球，我们强行规定男生的数量大于女生的数量，当男生数量少于女生时进行交换。  
同时使用 $lst$ 记录上一个同学的性别，当该座位有人时把 $lst$ 重置为零并判断男生人数和女生人数是否需要交换。
## 代码
本人超绝火车头，亲测跑的飞起。
```
#include <bits/stdc++.h>
using namespace std;
int n,a,b,lst,cnt;//lst用于记录上一个座位坐的人的性别
char c[200200];
void swaq(int &x,int &y){
    //这个是更快的，基于二进制异或运算的交换两数的方式
    //当然也可以使用c++自带的swap(x,y)
    x^=y^=x^=y;
}
signed main(){
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>c[i];
    }
    if(a<b){
        swaq(a,b);//强制让男生个数大于女生个数
    }
    for(int i=1;i<=n;i++){
        if(c[i]=='*'){
            lst=0;//已有乘客，重置状态
            if(a<b){
                swaq(a,b);
                //在保证男生数量大于女生数量的同时应注意要在跳出一段连续的座位后再进行交换操作
            }
        }
        else{
            if(lst==1){
                lst=2;
                if(b==0){
                    continue;
                }
                b--;
            }
            else{
                lst=1;
                if(a==0){
                    continue;
                }
                a--;
            }
            cnt++;//记录已安排的学生个数
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：sybs1145 (赞：0)

# [B4193 排座位](https://www.luogu.com.cn/problem/B4193) 题解
## 思路
显而易见，只有**相邻座位**的状态会影响当前座位的选择。

根据贪心思想，容易证明，男女交替坐是最优结论。当然这里还涉及到一个小细节，如果男女生人数不等，让人数多的一方先坐更优。

据此，我们只需要研究**上一个座位**的状态。

经过对**上一个座位的状态**进行分类讨论，得出三种情况：

1. **空或有人（包括第一个座位）**。此时当前座位可以坐**男生或女生**（优先选择人数多的一方）。

2. **已有男生**。此时当前座位可以坐**女生**。

3. **已有女生**。此时当前座位可以坐**男生**。

我们只需使用一个 $lst$ 变量记录上一个座位的状态即可。

代码很简单，仅供参考。
## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n, a, b, lst, ans;
string s;
char c;
int main()
{
    cin >> n >> a >> b >> s;
    for (int i = 0; i < n; i++)
    {
        c = s[i];
        if (c == '*')
            lst = 0;
        else if (lst == 0)
        {
            if (a >= b && a)
                a--, lst = 1, ans++;
            else if (b)
                b--, lst = 2, ans++;
            else
                lst = 0;
        }
        else
        {
            if (lst == 1 && b)
                b--, lst = 2, ans++;
            else if (lst == 2 && a)
                a--, lst = 1, ans++;
            else
                lst = 0;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：0)

我们可以将列车分成几段，每段没有坐人，男女轮换着坐。

但是每段的开始时是男生还是是女生是不确定的。

我们可以使用贪心的策略，为了不使结束时出现很多女生和没有男生或出现很多男生和没有女生的情况，我们可以优先把当前剩余人数多的安排在当前段的开始。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, b, ans;
char c[200005];
signed main() {
  cin >> n >> a >> b;
  c[0] = '*';
  for (int i = 1; i <= n; i++) cin >> c[i];
  for (int i = 1; i <= n; i++) {
    if (c[i] == '.') {
      while (i <= n && c[i] == '.') {
        if (c[i - 1] == '*') {
          if (a < b) {
            if (b > 0) b--, ans++;
            c[i] = 'b';
          } else {
            if (a > 0) a--, ans++;
            c[i] = 'a';
          }
        } else {
          if (c[i - 1] == 'a') {
            if (b > 0) b--, ans++;
            c[i] = 'b';
          }
          if (c[i - 1] == 'b') {
            if (a > 0) a--, ans++;
            c[i] = 'a';
          }
        }
        i++;
      }
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：Ajin_Breeze (赞：0)

# 思路
这道题我们可以定义一个 $last$ 去记录前一个座位坐的人然后就是三种情况：

1，前一个是 $*$ 就是将男女多的一方安排坐进去。

2，若前一个是女的，则这个位置就是男的。

3，若前一个是男的，则这个位置就是女的。

题目并不难，只要理解好题目就行了。

# AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,b,sum,last,ans;
string s;
int main(){
    cin>>n>>a>>b>>s;
    for(int i=0;i<n;i++){
        if(s[i]=='*') {
			last=0;
        }else if (i==0||last==0){
            if(a>=b && a){
				a--;
				sum=1;
			}else if(b>=a&&b){
				b--;
				sum=2;
			}
        }
        else{
            if(last==1&&b) {
				b--;
				sum=2;
            }else if(last==2&&a){
            	a--;
				sum=1;
			}
        }
        ans+=bool(sum);
        last=sum,sum=0;
    }
    cout<<ans;
    return 0;
}
```

---


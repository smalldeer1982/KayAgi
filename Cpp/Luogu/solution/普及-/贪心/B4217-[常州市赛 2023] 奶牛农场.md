# [常州市赛 2023] 奶牛农场

## 题目背景

搬运自 <http://czoj.com.cn/p/674>。数据为民间数据。

## 题目描述

小 X 是 CZ 市著名的农场主，他拥有着 CZ 市最大的奶牛农场。农场里有一排牛棚，一共 $n$ 个牛棚，从左到右依次编号为 $1,2,\cdots,n$ 。目前有些牛棚里住着奶牛，有些牛棚还是空的。

每个奶牛有一个高度，其中第 $i$ 个牛棚里的奶牛的高度为 $H_i$，如果第 $i$ 个牛棚里没有奶牛的话，$H_i=0$，为了使小 X 的牛棚变得美观，他打算去市场上买一些奶牛放到空着的牛棚里（假设市场上能买到任意多个高度在 $1$ 到 $10^9$ 之间的任意正整数的奶牛），使得每个牛棚里都有一头奶牛，并且高度从左往右严格递增。

请你告诉小 X 是否能让他的牛棚变得美观，如果可以请给出一个任意合法的方案。

## 说明/提示

### 样例 $\textbf 3$ 解释

因为高度是正整数，还要严格递增，所以第 $4$ 头奶牛的高度必须 $\geq 2$ 。所以不存在满足题目条件的方案。

### 样例 $\textbf 4$ 解释

因为买不到高度为 $>10^9$ 的奶牛，所以不存在满足题目条件的方案。
### 数据范围

| 测试点编号 | $n$ | $H_i$ |
| :---: | :---: | :---: |
| $1\sim5$ | $1\leq n\leq 5$ | $0\leq H_i\leq10$ |
| $6\sim10$ | $1\leq n\leq 10^5$ | $0\leq H_i\leq 10^9$ |

## 样例 #1

### 输入

```
3
0 0 0```

### 输出

```
YES
4 5 6```

## 样例 #2

### 输入

```
4
0 2 0 4```

### 输出

```
YES
1 2 3 4```

## 样例 #3

### 输入

```
4
0 0 0 2```

### 输出

```
NO```

## 样例 #4

### 输入

```
2
1000000000 0```

### 输出

```
NO```

# 题解

## 作者：sfb1363II (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B4217)

## Solution

这题我的思路是贪心，首先在 $a_i=0$ 的时候我们将 $a_i$ 设为 $a_{i+1}-1$。接下来我们扫一遍整个 $a$ 数组，如果 $a_i \le a_{i-1}$ 或者 $a_i>10^9$ 时，那么我们就输出 NO。如果每个数都符合条件，那么就输出 YES 和 $a$ 数组就行了。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,a[N];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(!a[i]) a[i]=a[i-1]+1;
    }
    for(int i=1;i<=n;i++)
        if(a[i-1]>=a[i]||a[i]>1000000000){
            cout<<"NO\n";
            return 0;
        }
    cout<<"YES\n";
    for(int i=1;i<=n;i++)
        cout<<a[i]<<" ";
    return 0;
}
```

---

## 作者：XsIeEiKcEk (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4217)

## 题目大意

给定一个序列，将所有值为 $0$ 的项变为一个 $\in[1,10^9]$ 的数，问是否可以让这个序列严格递增。若可以，输出 ```YES```，并输出任意一个结果序列。否则，输出 ```NO```。

## 解法

贪心，将为 $0$ 的项变为最小的、满足比上一个大的数。途中再判断那些不为 $0$ 的项是否比上一个大，若为否，直接输出 ```NO```。

## [AC](https://www.luogu.com.cn/record/206742709) CODE
```cpp
#include<iostream>
using namespace std;
int a[100001],n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
        if(a[i]==0)a[i]=a[i-1]+1;//贪心
        else if(a[i]<=a[i-1]){//判断是否不为递增
            cout<<"NO";
            return 0;
        }
        if(a[i]>1e9){//判断是否超出高度范围
            cout<<"NO";
            return 0;
        }
    }
    cout<<"YES\n";
    for(int i=1;i<=n;i++)cout<<a[i]<<' ';
    return 0;
}
```
~~话说这个 AC 测试点上面的字有些吉利~~

---

## 作者：_Pioneer_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4217)和 [AC 记录](https://www.luogu.com.cn/record/207210411)。

一道很典型的贪心题。

我们需要维护一个严格单调递增的序列，我们不妨从后往前枚举，从 $n$ 开始，枚举到 2 为止。

首先如果 $a_{i-1} = 0$，则 $a_{i-1} = a_i - 1$。（当 $a_n = 0$ 时将它设为 $10^9$ 就行）

然后判断当 $a_{i-1}\ge a_i$ 时，直接输出 NO ，结束程序。

之后特判一下，若 $a_{i-1} < 0$ 时，也同样输出 NO ，结束程序。

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100000];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	if(a[n]==0)a[n]=1e9;
	for(int i=n;i>=2;i--){
		if(a[i-1]==0)a[i-1]=a[i]-1;
		if(a[i]<=a[i-1]){cout<<"NO"<<endl;return 0;}
		if(a[i-1]<0){cout<<"NO"<<endl;return 0;}
	}
	cout<<"YES"<<endl;
	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
} 
```

---

## 作者：tanruiqing (赞：2)

### 解题思路：

考虑贪心。

我们可以对于每一个数字为 $0$ 的位置，将这个位置上的数设为 $a_{i-1}+1$ 这个数。当然，我们不能让这个数字破坏**单调递增**这一规则。所以，我们要防止这个数字**大于等于** $a_{i+1}$ 这个数字。还有，题目说“买不到高度**大于** $10^9$ 的奶牛”，所以这个数字要保证在 $1\leq x\leq 10^9$ 之内。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n;
int h[100005];

signed main(){
    cin >> n;
    for(int i = 1 ; i <= n ; i++){
        cin >> h[i];
    }
    for(int i = 1 ; i <= n ; i++){
        if(h[i] == 0){//如果这个数是0。
            if(h[i - 1] == 1e9 || (h[i - 1] + 1 >= h[i + 1] && h[i + 1] != 0)){//这个数如果要大于1e9或者这个数不能让数组保持单调递增。
                cout << "NO\n";//输出NO。
                return 0;//结束。
            }else{
                h[i] = h[i - 1] + 1;//否则改为h[i - 1] + 1。
            }
        }
    }//否则有解。
    cout << "YES\n";
    for(int i = 1 ; i <= n ; i++){
        cout << h[i] << " ";
    }
    return 0;
}
```

$90\ pts$。

为什么呢？我们可以举出一个栗子：

```cpp
3
1 1 1

应该输出：
NO

代码输出：
YES
1 1 1
```

所以，我们要在最前面检查一下这个序列是不是原本就是单调递增。

由此，我们可以又想到：如果原数组本来就有一个数大于 $10^9$ 的数，就要输出 `NO`。

### 代码：

[AC 记录](https://www.luogu.com.cn/record/206582083)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n;
int h[100005];

signed main(){
    cin >> n;
    bool f = 0;
    for(int i = 1 ; i <= n ; i++){
        cin >> h[i];
    	if(h[i] > 1e9){
    		f = 1;//以防万一有数大于1e9。
    		break;
		}
	}
	for(int i = 1 ; i <= n ; i++){
    	if(h[i] >= h[i + 1] && h[i] != 0 && h[i + 1] != 0){//如果原数组不是单调递增。
    		f = 1;
    		break;
		}
	}
	if(f == 1){
		cout << "NO\n";//如果有以上情况，输出NO。
		return 0;
	}
    h[n + 1] = 1e9;
    for(int i = 1 ; i <= n ; i++){
        if(h[i] == 0){//如果这个数是0。
            if(h[i - 1] >= 1e9 || (h[i - 1] + 1 >= h[i + 1] && h[i + 1] != 0)){//这个数如果要大于1e9或者这个数不能让数组保持单调递增。
                cout << "NO\n";
                return 0;
            }else{
                h[i] = h[i - 1] + 1;//否则改为h[i - 1] + 1。
            }
        }
    }//否则有解。
    cout << "YES\n";
    for(int i = 1 ; i <= n ; i++){
        cout << h[i] << " ";
    }
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：2)

题意简述：给出一个序列，将序列中为 0 的数替换成任意数字，能否使这个数列严格单调递增。 

---

## 初步思考
 - 什么是**严格**单调递增？在序列中，满足任意 $i$ 都有 $a[i]>a[i-1]$，那么这个序列就是一个**严格**单调递增序列。
- 如何解决问题？首先既然是问能否使数列严格单调递增，那就先考虑贪心。
- 什么时候可以用贪心？当问题满足以下几个条件时：
1. **贪心选择性质**：问题的整体最优解可以由局部最优解来得到，即通过贪心选择来得到。
2. **最优子结构**：问题的最优解包涵其子问题的最优解。
3. **无后效性**：某个状态以后的过程不会影响以前的状态，只与当前状态有关。
## 具体步骤
既然是贪心，那么我们肯定是选择对当前最有利的方案。如果我们替换的数较大，那必然会限制后面能替换的数。所以，我们肯定是让替换的数越小越好。并且要使数列严格单调递增，那么只需要替换为前面那个数加 1。
## 示例
### 输入 #2:
> 4\
> 0 2 0 4

替换第一位时，由于是第一位，所以只能替换为 1。
> 1 2 0 4

替换第三位是，替换为第二位加 1，故为 3。
> 1 2 3 4

此时数列满足严格单调递增。
### 输入 #3：
> 4\
> 0 0 0 2

替换第一位时，由于是第一位，所以只能替换为 1。
> 1 0 0 2

替换第二位时，替换为第一位加 1，故为 2。
> 1 2 0 2

替换第三位时，替换为第二位加 1，故为 3。
> 1 2 3 2

此时数列不满足严格单调递增，所以没有方案。
## 分析
通过上面的模拟，我们可以发现只要每一位都替换的小，那么答案一定是最优的。如果此时的答案都不满足条件，那么一定不能使这个数列严格单调递增。而且，每一位的选择不会影响接下来的选择。综上所述，这个问题满足使用贪心算法的三个条件，可以使用贪心。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
void stop()
{
	cout<<"NO";
	exit(0);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	 if(a[i])
	  {
	  	if(a[i]<=a[i-1]) stop();	
	  }  
	 else
	  {
	  	a[i]=a[i-1]+1;
	  	if(a[i]>1e9)  stop();
	  }
	cout<<"YES\n";
	for(int i=1;i<=n;i++) cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：wst000 (赞：1)

## 高度从左往右严格递增是什么意思？

我们知道这是什么概念才能做题。它的意思是 $H_{i} \ge H_{i-1}$（$2 \le i \le n$）。

# 思路

考虑贪心。对于每一个 $H_{i} = 0$ 的 $i$，将它设置成 $H_{i-1} + 1$，这里假设 $H_{0} = 0$。如果 $H_{i} \le H_{i-1}$ 或者 $H_{i} > 10^9$，那么说明无解，输出 `NO`，如果发现有解，输出 `YES` 和每个 $H_{i}$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
ll a[100005],n;
int main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		if(a[i]==0)a[i]=a[i-1]+1;
		if(a[i]<=a[i-1]){printf("NO");return 0;}
		else if(a[i]>1e9){printf("NO");return 0;}
	}
	printf("YES\n");
	for(int i=1;i<=n;i++)printf("%lld ",a[i]);
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：1)

### 题目意思。
要使一段序列变得单调递增，可以更改**元素值为零**的元素（变成多少都可以，注意高度值为正整数），最后输出是否可行，可行的话输出其中一种方案。
### 题目思路。
考虑贪心。

为了尽量满足条件，肯定要让一个元素值为零的值变得**尽量小**，且要满足大于前面一个元素的值，又要保证此处值为正整数，那么答案就显而易见了。

我们判断当元素值为零的时候，此位置的值为**上一个位置的值加一**。

最后注意一下，无法满足条件的情况就行了。也就是说最优操作完之后，是否满足**单调递增**。
### 给出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100500];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];	
	for(int i=1;i<=n;i++)
	{
		if(a[i]==0) a[i]=a[i-1]+1;//当此处为空的时候，说明可以改变当前元素的值，最优策略为上一个位置的值+1 
	}
	for(int i=2;i<=n;i++)//判断是否满足单调递增 
	{
		if(a[i]<=a[i-1])
		{
			cout<<"NO";
			return 0;
		}
	}
	cout<<"YES\n";
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
} 
```

---

## 作者：no_response (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4217)
## 题目思路
### 排除
根据题意，可以先排除填的数小于 $0$ 或 大于 $10^9$。  
排除代码如下（加输入）：
```cpp
int maxn = 0, MAX = 0, minn = 1e9, MIN = 0;
for (int i = 1; i <= n; i++) {
	cin >> h[i];
	if (h[i] >= maxn) {
		maxn = h[i];
		MAX = i;
	}
	if (h[i] <= minn && h[i] != 0) {
		minn = h[i];
		MIN = i;
  }
}
if (maxn + (n - MAX) > 1e9 || minn - (MIN - 1) < 1) {
  cout << "NO";
  return 0;
}
```
注意要直接返回哦。
### 购买
如果当前牛棚是空的，那么就需要购买奶牛。  
为保证高度为递增，运用贪心思想，让本次购买的奶牛的高度最小。  
注意：只有当前需要购买才修改。  
购买代码如下:
```cpp
for (int i = 1; i <= n; i++) {
	if (h[i] == 0) {
		h[i] = h[i - 1] + 1;
	}
}
```
### 判断
只有每次当前奶牛的高度高于前一个奶牛的高度，才能成为递增。  
判断代码如下：
```cpp
bool flag = 0;
for (int i = 1; i <= n; i++) {
  if (h[i] <= h[i - 1]) {
		flag = 1;
	}
}
```
### 输出
根据判断结果输出。  
注意：如果合法要输出修改后的每个牛棚。
输出代码如下：
```cpp
if (flag == 1) {
	cout << "NO";
} else {
	cout << "YES" << endl;
	for (int i = 1; i <= n; i++) {
		cout << h[i] << " ";
	}
}
```
### 总结
本题考查贪心，所以每次购买的奶牛的高度必须最小，以免答案错误。  
数组和变量不要开小。  
看不懂思路的看代码。
## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
int h[(int) 1e5 + 10]; //题意1e5
int main() {
	int n;
	cin >> n;
	int maxn = 0, MAX = 0, minn = 1e9, MIN = 0; //注意存储最小值变量要开到题目范围1e9
	for (int i = 1; i <= n; i++) {
		cin >> h[i];
		if (h[i] >= maxn) { //存储最大值以及下标
			maxn = h[i];
			MAX = i;
		}
		if (h[i] <= minn && h[i] != 0) { //存储最小值以及下标，注意特判0
			minn = h[i];
			MIN = i;
		}
	}
	if (maxn + (n - MAX) > 1e9 || minn - (MIN - 1) < 1) { //特判
		cout << "NO";
		return 0; //如果忘了可能会输出两次
	}
	for (int i = 1; i <= n; i++) { //购买奶牛
		if (h[i] == 0) {
			h[i] = h[i - 1] + 1; //贪心
		}
	}
	bool flag = 0; //棋子变量当作输出的判断条件
	for (int i = 1; i <= n; i++) { //判断是否合法
		if (h[i] <= h[i - 1]) {
			flag = 1;
		}
	}
	if (flag == 1) { //输出
		cout << "NO";
	} else {
		cout << "YES" << endl;
		for (int i = 1; i <= n; i++) { //输出修改后的各个牛棚的奶牛高度
			cout << h[i] << " ";
		}
	}
	return 0;
}
```
为保持洛谷的良好学习习惯，请勿抄袭。  
**千万别抄袭哦。**  
管理大大辛苦了，各位大佬给蒟蒻点个赞呗。

---

## 作者：Eric1030 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4217)

## 思路讲解
首先我们把数据输入进来，如果 $H_i$ 是 $0$，就把 $H_i$ 设为 $H_{i-1}+1$。最后再把整个数组遍历一遍，如果有一个数大于 $10^9$ 了或者发现这个数列不是单调递增了，就输出 ```NO```，结束程序。否则输出 ```YES``` 并输出 $H$ 数组中的每一个数。

说到这里你可能会问，为什么要把 $H_i$ 设为 $H_{i-1}+1$ 呢？因为要确保是单调递增的，所以要把当前这位设为前一位 $+1$。

## [AC](https://www.luogu.com.cn/record/207917820) 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a[100005];
int main()
{
    cin >> n;
    for (int i = 1;i <= n;i++)
    {
        cin >> a[i];
        if (a[i] == 0)
        {
            a[i] = a[i - 1] + 1;//两数的最小差值，如果还无法实现就说明要输出NO了
            if (a[i] > 1000000000)//所买奶牛高度超过限制
            {
                cout << "NO";
                return 0;
            }
        }
    }
    for (int i = 1;i <= n;i++)
    {
        if (a[i - 1] >= a[i])//a[i-1]比a[i]大或等于a[i]了，就说明无法做到单调递增
        {
            cout << "NO";
            return 0;
        }
    }
    cout << "YES" << endl;
    for (int i = 1;i <= n;i++)
    {
        cout << a[i] << " ";//输出结果
    }
    return 0;//结束！
}
```

---

## 作者：liwanxian (赞：1)

## 思路

题目中既然让我们保证输出 `YES` 的情况是：对于所有 $1 \leq i \leq n-1$ 满足 $H'_i < H'_{i + 1}$ ，并且如果 $H'_i > 0$ ，那么 $H'_i=H_i$，也就是保持不变。那我们就可以在当 $a_i = 0$ 时将 $a_i = a_{i - 1} +1$，而当 $a_i > 0$ 时保持不变就可以啦！

最后再遍历一遍答案数组，如果发现依然有 $a_i \leq a_{i - 1}$ 或是 $a_i > 10^9$ 那我们就可以直接输出 `NO` 并返回，否则我们就可以直接输出 `YES` 并输出答案数组啦！

## 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]==0) a[i]=a[i-1]+1;
	}
	for(int i=1;i<=n;i++){
		if(a[i]<=a[i-1]||a[i]>1000000000){
			cout<<"NO";
			return 0;
		}
	}
	cout<<"YES"<<endl;
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
}
```

[记录](https://www.luogu.com.cn/record/206895344)。

---

## 作者：Jasoncwx (赞：1)

[题目传送门！](/problem/B4217)
## 题目思路
可以新建一个计数器 $cnt$ 初始值为 $1$，即最小值。

遍历整个数组：

首先，若 $a_i>cnt$，那么表示前面无法放进这么多数字，直接输出 `NO`，结束程序。

否则，若 $a_i\not=0$，$cnt=a_i$。

对于 `YES` 的所有情况，对于每个数，输出 $cnt$，并加一即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,num=1;
    cin>>n;
    int a[100005];
    for(int i=0;i<n;i++){
        cin>>a[i];
        if(!a[i])num++;
        else if(num>a[i])return cout<<"NO",0;//退出程序
        else num=a[i];
    }
    cout<<"YES\n";
    num=1;
    for(int i=0;i<n;i++){
        if(!a[i])cout<<num++<<" ";
        else num=a[i],cout<<num++<<" ";
    }
}
```

---

## 作者：int_inf (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4217) ＆ [AC记录](https://www.luogu.com.cn/record/206497095)
# Solution
本题考虑使用**贪心**。对于一个 $h_{i}$，若 $h_{i}=0$，则 $h_{i}=h_{i-1}+1$。最后再遍历一遍，若 $h_{i}>10^{9}$ 或 $h_{i}<h_{i-1}$，则输出 `NO`，否则输出 `YES` 并输出 $h$。
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,h[1000001]; 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>h[i];
		if(h[i]==0) h[i]=h[i-1]+1;//赋值 
	}
	for(int i=1;i<=n;i++)
	{
		if(h[i]>1e9||h[i]<h[i-1])//不符合 
		{
			cout<<"NO"<<endl;
			exit(0);//直接退出 
		}
	}
	cout<<"YES"<<endl;
	for(int i=1;i<=n;i++) cout<<h[i]<<" ";
	cout<<endl;
	return 0;//下次再见 
}
```
事已至此，不如留下赞和关注，后会有期。

---

## 作者：LG086 (赞：1)

给出 $n$ 个数 $H_1,H_2,\dots,H_n$，其中有一部分 $H_i$ 的值已经确定。需要给每个 $H_i=0$ 的位置赋值，使这 $n$ 个数严格递增。每次添加的正整数还不能超过 $10^9$。问是否可以完成操作。

我们可以定义一个变量 $now$，赋值为 $1$。从 $H_1$ 开始，若当前 $H_i=0$，填上 $now$，同时 $now$ 自增 $1$；若当前 $H_i \not = 0$，判断此时的 $now$ 是否小于当前位置上的数字，如果 $now \ge H_i$ 直接输出 `NO`，否则使 $now$ 变为 $H_i+1$，继续操作。  
还要注意是否存在 $H_i$ 满足 $H_i > 10^9$，若有则输出 `NO`，否则输出 `YES` 并输出填补完成的这 $n$ 个数。

核心代码：

```cpp
for(int i = 1;i <= n;i ++){
    if(h[i]==0)h[i]=now,now++;
    else
        if(now>=h[i])
            return cout<<"NO",0;
        else now=h[i]+1;
    if(now>1e9+1)return cout<<"NO",0;
}
cout<<"YES\n";
for(int i = 1;i <= n;i ++)cout<<h[i]<<" ";
```

---

## 作者：TheTrash (赞：1)

### 思路

贪心。

不难发现最好的办法是当 $h_i$ 是 $0$ 时让 $h_i$ 变成 $h_{i-1}+1$。于是可以定义一个初始值为 $1$ 的变量 $s$ 并枚举一遍 $h$ 数组，当 $h_i$ 是 $0$ 时让 $h_i$ 变成 $s$，$s$ 变成 $h_i+1$。当 $s$ 大于 $10^9+1$ 时输出 ```NO``` 并结束程序，因为 $h_i$ 可能等于 $10^9$，这时 $s$ 就变为了 $10^9+1$，但还是符合条件。当 $h_i\ge h_{i+1}$ 时输出 ```NO``` 并结束程序，因为此时 $h$ 数组并不满足严格递增的条件。枚举完后输出 ```YES``` 换行后再输出 $h$ 数组。

### 代码

```cpp
#include<iostream>
using namespace std;
int n,h[100005];
int s=1;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>h[i];
	h[n]=1000000001;
	for(int i=0;i<n;i++){
		if(h[i]==0) h[i]=s;
		s=h[i]+1;
	//	cout<<s<<endl;
	//	for(int i=0;i<n;i++) cout<<h[i]<<' ';
	//	cout<<endl;
		if(h[i]>=h[i+1]&&h[i+1]!=0)cout<<"NO",exit(0);
		if(s>1000000001) cout<<"NO",exit(0);
	}
	cout<<"YES\n";
	for(int i=0;i<n;i++) cout<<h[i]<<' ';
}
```

---

## 作者：2789617221guo (赞：0)

## 做法
- 贪心 + 循环。
## 思路
我们不难发现，只要在每一个 $a[i]=0$ 的牛棚 $i$ 中放入一个高度为 $a[i]+1$ 的奶牛，既符合严格单调递增，还可以最小化答案，得到最优解。

如果当前牛棚有奶牛了，就判断，如果上一头奶牛的高度已经大于当前高度，则直接输出 `NO` 并退出程序。

记得要特判，若上一个牛棚的奶牛高度达到了最高高度 $10^9$，则也是直接输出 `NO` 并退出程序。
## 代码
```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define ll   long long

using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;
const int N = 1e5 + 5;
const int H = 1e9;

int n, a[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        if (a[i]) {
            if (a[i - 1] >= a[i]) {
                cout << "NO" << endl;
                return 0;
            }
            continue;
        }
        if (a[i - 1] >= H) {
            cout << "NO" << endl;
            return 0;
        }
        if (a[i - 1] >= a[i + 1] && a[i + 1] != 0) {
            cout << "NO" << endl;
            return 0;
        }
        a[i] = a[i - 1] + 1;
    }
    cout << "YES" << endl;
    for (int i = 1; i <= n; i++) {
        cout << a[i] << " ";
    }
    return 0;
}
```
## AC 记录
[AC，用时 82ms，内存 724.00KB。](https://www.luogu.com.cn/record/207919173)

---

## 作者：jscaj0921 (赞：0)

# 思路

这题还是比较简单的。

首先，如果它要严格递增，那么，任意一个元素都肯定会比上一个元素要大，而且至少大一。所以，我们如果遇到一个空牛棚，就买一头恰好比上一头大一的奶牛，如果这样无法满足条件，那么就肯定没有可能，因为每次至少大一，不可能有比这种更小的可能。

当奶牛身高大于题目规定或者大于等于下一头奶牛的时候，就无解了，上面已经给出证明了。

# 代码
```cpp
#include <iostream>
using namespace std;
int h[100005];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> h[i];
    for (int i = 1; i <= n; i++)
    {
        if (h[i] == 0) h[i] = h[i - 1] + 1;
        if (h[i] <= h[i - 1] || h[i] > 1e9) 
        {
            cout << "NO" << endl;
            return 0;
        }
    }
    cout << "YES" << endl;
    for (int i = 1; i <= n; i++) cout << h[i] << " " << endl;
    return 0;
}
```

[AC](https://www.luogu.com.cn/record/207740264)

---

## 作者：yyycj (赞：0)

## 题目简述
给你一个整数序列 $H$，如果 $H_{i}=0$，则可以将 $H_{i}$ 改为 $[1,10^{9}]$ 中的一个数。

判断是否能让这个 $H$ 单调上升，如果可以输出 `YES` 和任意一种满足的情况；反之输出 `NO`。

## 主要思路
输出 `NO` 的情况比较显而易见，满足以下一条即可（以下条件都建立在 $H_{i} \neq 0$ 的情况）：
- $H_{i} < i$。
- $H_{i} > 10^{9} - (n - i)$。
- 对于每个 $j \in [1,i)$，$H_{i} \le H_{j}$。

以上条件都不满足则一定输出 `YES`，由于任意一种满足条件的序列都可以，所以对于 $H_{i} = 0$，$H_{i} \to H_{i - 1} + 1$ 即可。

## AC Code
```cpp
#include<map>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

namespace IO {
	#ifdef ONLINE_JUDGE
	#define getchar getchar_unlocked
	#endif
	#define pc putchar
	#define gc getchar
	template<typename T> void read(T &x) { int f = 1; x = 0; char ch = gc(); while (!isdigit(ch)) { if (ch == '-')f = -1; ch = gc(); }while (isdigit(ch)) { x = (x << 1) + (x << 3) + (ch ^ 48); ch = gc(); }x *= f; }
	template<typename T, typename ...Args> void read(T &x, Args &...args) { read(x); read(args...); }
	template<typename T> void print(T x) { if (x < 0) { pc('-'); x = -x; }if (x > 9) { print(x / 10); }pc(char(x % 10 + 48)); }
	template<typename T, typename ...Args> void print(T &x, Args &...args) { print(x); pc(' '); print(args...); }
	inline void readstr(string& x) { x.clear(); char ch = gc(); while (isspace(ch)) ch = gc(); while (!isspace(ch) && ch != EOF) { x.push_back(ch); ch = gc(); } }
	inline void printstr(char* x) { for (int i = 0; i < (int)strlen(x); i++) pc(x[i]); }
	inline void printstr(string& x) { for (auto i = x.begin(); i != x.end(); i++) pc(*i); }
};
using namespace IO;

#define OUT 0
#define MAMBA return
typedef long long ll;
typedef long double db;
const int N = 1e5 + 10;
const int INT_INF = 0x3f3f3f3f;
int man();int main(){MAMBA man();}
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
inline ll _abs(ll a) { if (a < 0) return -a; return a; }
inline ll _pow(ll a, ll b) { ll x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }
// ----------------------------

// ----------------------------
int h[N];
// ----------------------------


int man() {
	int n, last = -1; read(n);
	for (int i = 1; i <= n; i++) {
		read(h[i]);
		if (h[i] != 0 && (h[i] < i || h[i] > 1000000000 - (n - i) || h[i] <= last)) {
			printstr("NO");
			MAMBA OUT;
		}
		if (h[i] != 0) last = h[i];
	}
	// ----------------------------
	printstr("YES\n");
	for (int i = 1; i <= n; i++) {
		if (h[i] == 0) h[i] = h[i - 1] + 1;
		print(h[i]);
		pc(' ');
	}
	MAMBA OUT;
}
/*
				 .-~~~~~~~~~-._       _.-~~~~~~~~~-.
			 __.'              ~.   .~              `.__
		   .'//   A    C    之   \./  之    真    理  \`.
		 .'//                     |                     \`.
	   .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \`.
	 .'//.-"                 `-.  |  .-'                 "-.\`.
   .'//______.============-..   \ | /   ..-============.______\`.
 .'______________________________\|/______________________________`.
*/
```

---


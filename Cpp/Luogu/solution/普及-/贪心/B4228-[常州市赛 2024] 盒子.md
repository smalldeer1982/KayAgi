# [常州市赛 2024] 盒子

## 题目背景

搬运自 <http://czoj.com.cn/p/954>。数据为民间数据。

## 题目描述

小 Y 有 $n$ 个盒子，第 $i$ 个盒子的大小是 $a_i$，小 Y 保证 $a_i$ 一定是 $2$ 的若干次方，比如 $1,2,4,8,16,32,64,128,256,512,1024\cdots$，一个大小为 $a_i$ 的盒子的容量是 $\dfrac{a_i}2$，就是说它可以装下总大小不超过 $\dfrac{a_i}2$ 的其他盒子，特别地，大小为 $1$ 的盒子不能装下其他盒子。并且，装在盒子里的盒子也可以装其他盒子，比如，大小为 $8$ 的盒子可以装下一个大小为 $4$ 的盒子且大小为 $4$ 的盒子事先已经装了一个大小为 $2$ 的盒子。

现在小 Y 想知道，最少能有多少个不被其他盒子装下的盒子？

## 说明/提示

### 样例 $\textbf 1$ 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/uo8jxn0g.png)
图中盒子内部的灰色部分表示盒子不能用来装东西的一半容量，白色部分表示能用来装东西的一半容量，图中只有最大的盒子没有被装在其它盒子中，因此答案为 $1$。
### 样例 $\textbf 2$ 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/ygt207eh.png)
### 样例 $\textbf 3$ 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/znl0c65g.png)
### 样例 $\textbf 4$ 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/pis9wn32.png)
### 数据范围
参考数据：$2^{60}=1\ 152\ 921\ 504\ 606\ 846\ 976$。

对于所有数据，$1≤n≤10^5, 1≤a_i≤2^{60}$。

|测试点编号|特殊性质|
|:-:|:-:|
|$1\sim3$|$1\le n\le 3$|
|$4\sim5$|$1\le a_i\le 4$|
|$6\sim9$|$1\le n\le 1000$|
|$10\sim12$|无|

## 样例 #1

### 输入

```
5
1 2 1 1 8```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
3```

## 样例 #3

### 输入

```
6
1 1 1 4 1 2```

### 输出

```
3```

## 样例 #4

### 输入

```
3
8 4 2```

### 输出

```
1```

# 题解

## 作者：yuhong056 (赞：1)

# 题解：B4228 [常州市程序设计小能手 2024] 盒子
本题解提供一个使用 multiset 的方法。
## 思路
这道题，很容易可以发现是一道贪心，因为一个盒子一定能装就装。

而且，这个盒子装进去的盒子也要尽量小，这样子他就能嵌套进更多的盒子。

所以，我们从小到大考虑每个盒子，找到最小的能装下它的盒子，然后将该盒子的容量减去当前盒子的大小。
## 数据结构优化
找到最小的能装下它的盒子，我们可以将其整体排序，然后使用二分。

但同时，我们还要动态变化盒子的容量，这应该怎么办呢？

没错，就是堆。

这里可以直接使用 c++ STL 中的 [multiset](https://oi.wiki/lang/csl/associative-container/) 来实现（因为可能有多个容量相同的盒子）。
## Code
```cpp
#include<bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAXN = 1e5 + 7;

int n;
ll a[MAXN];
multiset<ll> b;//记得开 long long

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		b.insert(a[i] / 2);//将盒子的容量加入堆中
	}
	sort(a + 1, a + n + 1);
	int ans = 0;
	for (int i = 1; i <= n; i++) {//从小到大枚举盒子
		auto it = b.lower_bound(a[i]);//找到最小的能装下它的盒子
		if(it != b.end()) {
			ll ns = *it - a[i];
			b.erase(it);
			b.insert(ns);//动态变化盒子的容量
			ans++;//将能装下的盒子数量加 1
		}
	}
	cout << n - ans;//最小的装不下的盒子数量 = 盒子总数 - 最多能装下的盒子数量
	return 0;
}
```

---

## 作者：TYLOO_259 (赞：1)

[题面](https://www.luogu.com.cn/problem/B4228)

## 思路

根据题意易得，先装小盒子最划算，而且套娃是允许的，所以被装的盒子也要尽量小。

所以可以先排序，开一个 $cnt$ 数组记录这个盒子装了多少东西，从头到尾遍历盒子，当遍历到 $i$ 号盒子时，查询 $i<j\le n$ 中最小可以装下 $i$ 号盒子的盒子，也就是满足 $\frac{a_j}{2} - cnt_j \ge a_i$，并在 $cnt_j$ 上加上 $a_i$，建立一个标记数组，标记可以被装下的盒子。

最后遍历一遍标记数组，如果这个盒子没被标记答案就 $+1$。

但其实可以优化掉这个标记数组，在遍历盒子时记录也是可以的。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int n;
int a[N],cnt[N];
int ans;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        int j=i+1,flag=0;
        while(j<=n){
            if(a[j]/2-cnt[j]>=a[i]){
                cnt[j]+=a[i];
                flag=1;
                break;
            }
            j++;
        }
        if(!flag) ans++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：a_small_OIer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4228)
### 思路
一道很明显的贪心，容易发现，装盒子的最优方案是能装就装，直到有盒子无论如何也放不下。

所以可以将数组 $a$ 排序，然后从小到大遍历 $a_i$，如果这个盒子装不下，那么 $ans+1$。
### 代码
[AC 记录](https://www.luogu.com.cn/record/210701134)

```cpp
#include<bits/stdc++.h>
#define N 100010
using namespace std;
typedef long long LL;
//十年OI一场空，不开long long见祖宗
LL n , a[N] , sum[N] , ans;
bool b[N];
int main(){
	scanf("%lld" , &n);
	for(int i = 1 ; i <= n ; ++i)
		scanf("%lld" , &a[i]);
	sort(a + 1 , a + n + 1);//排序
	for(int i = 1 ; i <= n ; ++i){
		int t = i + 1;
		while(t <= n)
			if(sum[t] < a[t] / 2 && sum[t] + a[i] <= a[t] / 2){
				sum[t] += a[i];
				b[i] = true;
				break;
			}
			else
				t += 1;
	}
	for(int i = 1 ; i <= n ; ++i)
		if(!b[i])
			ans += 1;
	printf("%d" , ans);
	return 0;
} 
```

---

## 作者：guoshengyu1231 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4228)
## 初步思考
既然题目标签里有双指针，那我们就先考虑双指针，没毛病。 $\\$ 

我们可以想象这题是盒子在吃盒子，第 $i$ 个盒子的体积为 $a_i$，食量为 $c_i$，其中 $c_i=a_i\div2$。当一个盒子的食量大于另一个盒子的体积，那么这个盒子就可以把那个盒子吃掉，食量减去那个盒子的体积。怎样吃使最终存活的盒子最少？ 
## 具体步骤
既然要使最终存活的盒子最少，我们肯定是优先吃体积较小的，所以先对数组从小到大排序。 $\\$ 

我们定义两个指针 $i$ 和 $j$。其中 $j$ 是来吃的盒子，$i$ 是被吃的盒子。这时需分类讨论： $\\$ 

1.  $c_j\ge a_i$，此时第 $j$ 个盒子吃得下第 $i$ 个盒子，那么第 $i$ 个盒子被吃掉。
2.  $c_j < a_i$，此时第 $j$ 个盒子吃不下第 $i$ 个盒子，那么就往后选择一个食量更大的盒子。
## 示例
输入数据：
> 4\
> 1 1 1 4 1 2

排序后：
> 1 1 1 1 2 4

算出对应食量：
> 0 0 0 0 1 2

开始枚举时 $i=1$，$j=2$。此时 $c_j<a_i$，吃不下。 $\\$ 
直到枚举到 $i=1$，$j=5$ 时，此时 $c_j\ge a_i$，吃得下。于是 $c_j$ 减去 $a_i$，第 $i$ 个盒子被吃掉，盒子数量减去 $1$，$i$ 加上 $1$。 $\\$ 
此时 $i=2$，$j=5$，$c_j<a_i$，吃不下。 $\\$ 
此时 $i=2$，$j=6$，$c_j\ge a_i$，吃得下。于是 $c_j$ 减去 $a_i$，第 $i$ 个盒子被吃掉，盒子数量减去 $1$，$i$ 加上 $1$。 $\\$
此时 $i=3$，$j=6$，$c_j\ge a_i$，吃得下。于是 $c_j$ 减去 $a_i$，第 $i$ 个盒子被吃掉，盒子数量减去 $1$，$i$ 加上 $1$。 $\\$
此时 $i=4$，$j=6$，$c_j<a_i$，吃不下。于是输出盒子数量，程序结束。 $\\$
## 代码

```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int maxn=100005;
int n,a[maxn],c[maxn],ans;
int main()
{
	cin>>n;
	ans=n;//盒子数量 
	for(int i=1;i<=n;i++) cin>>a[i];	
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) c[i]=a[i]/2;//计算每个盒子的食量 
	for(int i=1,j=2;j<=n;)
	 if(c[j]>=a[i]) //第 i 个盒子被吃掉 
	  {
		c[j]-=a[i];
		i++;ans--;		
	  }
	 else j++; //吃不下 
	cout<<ans; 
	return 0;
}
```

---

## 作者：Ajin_Breeze (赞：0)

# 思路
核心思路就是贪心，我们可以定义两个数组，一个用来输入，另外一个用来存储这个盒子实际能装多大的盒子，用一个 $ans$ 去记录最多能装多少个盒子，再输出 $n$ 减去 $ans$  就可以了。 

# AC Code


```cpp
#include <bits/stdc++.h>
#define int long long		//2的60次方需要longlong 
using namespace std;
const int N=1e5+7;			//n的最大值为1e5 
int n,a[N],b[N],ans;		//a数组输入，b数组记录实际空间 
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i]/2;
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int l=1,r=2;			//定义双指针 
	while(r<=n){
		if(b[r]>=a[l]) b[r]-=a[l],l++,ans++;
		else r++;
	}						//贪心的过程，上述有说 
	cout<<n-ans;			//注：这里的ans别的题解有说可以定义为n，依次减去可装的盒子，也是可行的 
	return 0;
}
```

---

## 作者：wenjunyi (赞：0)

# 思路
一道简单的贪心，核心思路就是，只要能装就装，这样就是最贪的，因为空间利用率最高。

我们可以创一个 $ans$ 一开始赋值为 $n$，每装下一个就减一，最后输出 $ans$。

# 代码
~~~cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,arr[100005],zh[100005],ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>arr[i];
	}
	ans=n;
	sort(arr+1,arr+1+n);
	for(int i=1;i<=n;i++){
		zh[i]=arr[i]/2;
	}
	int i=2,j=1;
	for(;i<=n;){
		if(zh[i]>=arr[j]){
			zh[i]-=arr[j];
			j++;
			ans--;
		}
		else{
			i++;
		}
	}
	cout<<ans;
	return 0;
}
~~~

---

## 作者：SatoruXia (赞：0)

# B4228 [常州市程序设计小能手 2024] 盒子
## 题面分析
典型的贪心。  
理论上说，应该是正向逆向都能够通过此题。首先我们考虑逆向，即从大盒子开始枚举，到小盒子结束。每次我们都可以大盒子之内的盒子是否能装入，一旦装入即减小容积，然后不用再枚举了，将此盒子默认为被装下，否则不被装下。最后输出不被装下的盒子数量即可。  
记得程序开头要想其他贪心一样先排序。由于我用了 `vector`，排序时需用 `.begin()`，`.end()` 及 `std::greater<>()` 函数。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<long long> a(n), b(n);  // 要开 long long
    for (int i = 0; i < n; ++i) cin >> a[i];  // 读入
    sort(a.begin(), a.end(), greater<long long>());  // greater 可以降序
    for (int i = 0; i < n; ++i) b[i] = a[i] / 2;  // 记录每个盒子的剩余容量
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        int flag = 0;  // 每次都要初始化
        for (int j = 0; j < i; ++j) {
            if (b[j] >= a[i]) {  // 装得下
                b[j] -= a[i];
                flag = 1;
                break;  // 竖了旗之后直接跳了
            }
        }
        if (!flag) ans++;  // 装不下
    }
    cout << ans << endl;  // 输出
    return 0;
}
```

## 寻找漏洞
如果你也是这么想的，恭喜你，**喜提 $82$ 分**。  
为什么呢？  
这时候我们要做的第一件事肯定是看样例。我们发现，样例 $3$ 应该输出 $3$，而我们的程序输出 $4$。再看回代码我们就明白了：在一个盒子无法被装下时我们就把它弃置了，没有考虑它以后还能装下更小盒子的情况。想要修正我们当然可以在原代码上改进，但实现非常复杂。那还不如直接换思路——正向，从小到大。  
开始的过程一样，读入，升序排序，记录容积，但接着有改动。我们确定一个盒子，不管它是大是小，拿起来就往里面装，要是还有空位就继续装，直到装不下为止。同时这种装法因为一直往里装所以不能记录没装进去的，得记录装进去的然后用总数减。然后就没问题了。  
怎么一直装呢？立刻想到了 `while` 循环。用 `for` 加上 `break` 没必要。  
~~按道理来说，前一种算法应该有很多种可能过不去，但竟有 82 分，说明数据太水。~~

## 正解
代码很简单，虽然是黄题。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<long long> a(n), b(n);  // 要开 long long
    for (int i = 0; i < n; ++i) cin >> a[i];  // 读入
    sort(a.begin(), a.end());  // 升序
    for (int i = 0; i < n; ++i) b[i] = a[i] / 2;  // 记录每个盒子的剩余容量
    int ans = 0, i = 0;
    for (int j = 1; j < n; j++) {  // 用来装的盒子
        // 考虑使用 while 循环而非 for 循环，这样能一直装下去
        while (b[j] >= a[i]) {  // 装得进
            b[j] -= a[i];  // 装入
            i++;  // 换盒再装
            ans++;  // 装入数++
        }
    }
    ans = n - ans;  // 装不进的
    cout << ans << endl;  // 输出
    return 0;
}

---

## 作者：jinfanhao (赞：0)

题目大意是一个盒子，可以包含另外一些盒子，可是被包含的盒子不能比包含盒子的盒子的一半容积大，被包含的盒子可以包含盒子。\
那怎么才能尽量包含盒子呢？有个贪心策略，就是对盒子大小排序，先拿最小的盒子去包含其他小盒子盒子，如果不行就往后选择另外的小盒子进行包含，一路推下去，知道没有盒子为止。\
那怎么实现呢？可以用双指针算法，用两个指针一开始都选择最小的盒子，如果不能包含就往后退，能包含就包含并找新的盒子。

```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int N=1e5+1;
int n,op[N],sum[N],cnt,l=1,r=1;
signed main(){
	scanf("%lld",&n);
	for(int i=1; i<=n; ++i)scanf("%lld",&op[i]);	
	sort(op+1,op+n+1);
	for(int i=1; i<=n; ++i)sum[i]=op[i]/2;
	while(r<=n){
		if(sum[r]>=op[l]){
			sum[r]-=op[l];
			++l;
			++cnt;
		}else ++r;
	}
	printf("%lld",n-cnt);
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

考虑贪心。先将小盒子装进次小的盒子里，装不下的排队，逐渐增大，队列从小往大进盒（占位效率更高的先进，保证最小的空间也被利用到）。
```python
from collections import*;input();a=Counter(map(int,input().split()))
for i in range(61):
    b=a[2**i]*2**(i-1)
    for j in range(i):c=min(b//2**j,a[2**j]);b-=c*2**j;a[2**j]-=c
print(sum(a[i]for i in a))
```

---


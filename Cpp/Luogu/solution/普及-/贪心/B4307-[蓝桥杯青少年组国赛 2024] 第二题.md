# [蓝桥杯青少年组国赛 2024] 第二题

## 题目描述

有两排石头，每排有 $n$ 颗，从左到右依次排开。每颗石头的颜色为黄色（用 $1$ 表示）或者绿色（用 $0$ 表示）。每次可以选择第一排的任意一颗石头与第二排的任意一颗石头交换位置。请计算最少需要交换多少次才能使每一列石头的颜色都相同；如果无论交换多少次都无法使每一列石头的颜色都相同，则输出 $-1$。


## 样例 #1

### 输入

```
2
3
1 0 0
0 0 1
5
1 0 1 0 1
0 1 0 1 0```

### 输出

```
2
-1```

# 题解

## 作者：GongtengXingyi (赞：4)

[题目便捷入口](https://www.luogu.com.cn/problem/B4307)

看题目，题目说我们有两排石头，每个石头不是黄色就是绿色；

让我们第一排某个位置和第二排的某个位置交换，或者就是第二排的某个位置和第一排交换，也就是说**不可能是第 $x$ 行的某个位置和第 $x$ 行的某个位置交换**！

从此，我们可以将每一列的颜色组合分为以下四种情况：

1. $(1, 1)$：两排都是 $1$，不需要交换。
2. $(0, 0)$：两排都是 $0$，不需要交换。
3. $(1, 0)$：第一排是 $1$，第二排是 $0$，需要交换。
4. $(0, 1)$：第一排是 $0$，第二排是 $1$，需要交换。

然后……我们假设这四个情况的列数分别为：

- $x$：$(1, 1)$ 的列数。
- $w$：$(0, 0)$ 的列数。
- $y$：$(1, 0)$ 的列数。
- $z$：$(0, 1)$ 的列数。



从此，我想出了一个**不可能实现结果**的结论：
**如果 $y + z$ 是奇数，直接返回 $-1$**。

OK，那么第一时间搞定了可不可能的问题，接下来，我们就要开始看看要多少次（最少）完成任务了。

第一步：**直接配对交换**：
   - 对于 $(1, 0)$ 和 $(0, 1)$ 的列，可以直接交换这两列的第一排和第二排的石头，这样一次交换可以解决两列的问题。
   - 得出来了，我们最少需要 $y \div 2 + z \div 2$ 次交换。
     
第二步： **剩余未配对的列**：
     
   - 肯定的的是 $y$ 与 $z$ 都是奇数，我们就会剩下一个 $(1, 0)$ 和一个 $(0, 1)$ 的列。
   - 那么为了AC，我们有需要额外两次交换来解决这两列的问题（不得不说很麻烦）：
     - 第一次交换：将 $(1, 0)$ 的第一排 $1$ 与某个 $(1, 1)$ 的第二排 $1$ 交换，得到 $(1, 1)$ 和 $(1, 0)$。
     - 第二次交换：将新的 $(1, 0)$ 的第一排 $1$ 与 $(0, 1)$ 的第二排 $1$ 交换，得到 $(1, 1)$ 和 $(0, 0)$。
   - 因此，剩余的两列需要 $2$ 次交换。

最终，我们**辛辛苦苦干出来的公式**：

$$\left\lfloor \frac{y}{2} \right\rfloor + \left\lfloor \frac{z}{2} \right\rfloor + (y \bmod 2) \times 2$$

上代码了：

```cpp
#include <bits/stdc++.h>  // 好习惯*1
using namespace std;

int main() {
    int T;  // 测试数据组数
    cin >> T;
    while (T--) {  
        int n;  
        cin >> n;
        int a[10005], b[10005];  //石头石头来了
        
        // 第一排石头
        for (int i = 0; i < n; ++i)
             cin >> a[i];
        // 第二排石头
        for (int i = 0; i < n; ++i)
             cin >> b[i];
        int x = 0;  // 两排都是1的列数
        int y = 0;  // 第一排1第二排0的列数
        int z = 0;  // 第一排0第二排1的列数
        int w = 0;  // 两排都是0的列数
        for (int i = 0; i < n; ++i) {
            if (a[i] == 1 && b[i] == 1) x++;
            else if (a[i] == 1 && b[i] == 0) y++;
            else if (a[i] == 0 && b[i] == 1) z++;
            else w++;
        }
        // 如果需要交换的列数(y+z)是奇数，则无解
        if ((y + z) % 2 != 0) {
            cout << -1 << '\n';
            continue;  // 跳过本次循环，处理下一组数据
        }
        // 计算最少交换次数：
        // 1. 每对(1,0)和(0,1)可以直接交换解决，需要y/2 + z/2次
        // 2. 如果y和z是奇数，最后会剩下一对(1,0)和(0,1)，需要额外2次交换
        int ans = y / 2 + z / 2 + (y % 2) * 2;
        cout << ans << '\n';  // 输出结果
    }
    return 0;  //好习惯*2
    为了您的安全，请不要抄袭代码！！！这非常重要！
}
```

真心希望大家可以学会这道题，掌握知识点和如何推导公式qwq。

---

## 作者：Temp113 (赞：4)

## Solution

易得，对于每颗石头，它可以任意交换行与列的位置。

因此，要使最后每一列石头的颜色都相同，必须一种颜色有偶数个（共 $2n$ 个，此时另一种也有偶数个）。

反之，一种颜色有奇数个，一定不满足，输出 $-1$。

结论：

> 设 $n$ 列中，第一行和第二行分别为 $0,1$ 的列数为 $c_1$，分别为 $1,0$ 的列数为 $c_2$，则交换次数最少为：
> 
> $$\lfloor \frac{c_1}{2} \rfloor + \lfloor \frac{c_2}{2} \rfloor + \begin{cases} 0 & c_1 \equiv 0 \pmod 2 \\ 2 & c_1 \equiv 1 \pmod 2 \end{cases}$$
>
> 注：$c_1 \equiv 0 \pmod 2$ 表示 $c_1$ 为偶数，$c_1 \equiv 1 \pmod 2$ 表示 $c_1$ 为奇数。

证明：

> 若某一列的两石头初始相同，显然不进行交换。
>
> 否则，考虑两行之间的交换，有如下两种情况（本质不同）：
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/6xsdzyk7.png)
>
> 第一种。交换 $1$ 次，可将左上角与右下角交换，可行。
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/voxx6hau.png)
>
> 第二种。交换 $1$ 次，无论如何交换，两列石头的颜色都不同，不可行。交换 $2$ 次，发现，交换 $1$ 次所得图形，可变为第一种情况，故可行。
>
> 设 $1$ 的个数为 $s_1$，$n$ 列中，第一行和第二行分别为 $1,1$ 的列，$1$ 的个数为 $s_2$（$s_1,s_2$ 均为偶数）。则其余的 $1$ 的个数也为偶数（即，上述两种情况包含偶数列），所以，只用判断 $c_1$ 的奇偶性。
>
> 因此，$c_1,c_2$ 中，分别两两交换 $1$ 次，若有剩余，将剩余的两列交换 $2$ 次。此时，交换次数为最小。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
int t, n, tot, cnt1, cnt2;
bool a[N], b[N];
inline void solve(){
	tot = 0;
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
		tot += a[i];
	}
	for(int i = 1; i <= n; i++){
		cin >> b[i];
		tot += b[i];
	}
	if(tot & 1){
		cout << -1 << '\n';
		return ;
	}
	cnt1 = cnt2 = 0;
	for(int i = 1; i <= n; i++){
		if(!a[i] && b[i]) cnt1++;
		if(a[i] && !b[i]) cnt2++;
	}
	cout << cnt1 / 2 + cnt2 / 2 + ((cnt1 & 1) ? 2 : 0) << '\n';
	return ;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie();
	cin >> t;
	for(int kk = 1; kk <= t; kk++) solve();
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

首先判断什么时候无解，显然当 $1$ 的个数或 $0$ 的个数为奇数时无解。如果有解，那么统计最小操作数。首先忽略上下相等的列，再分别统计上 $1$ 下 $0$ 和上 $0$ 下 $1$ 的列的个数。对于两个上下两行数字分别相等的列，只用一次操作就可以让这两列合法，不断抵消即可。当这两种列的个数是奇数时，抵消完后会剩下两个不同的列，也就是样例中的第一组数据中的情况。这时进行两次操作即可满足条件。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],b[10005];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,sum=0;
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
		for(int i=1;i<=n;i++) cin>>b[i],sum+=b[i];
		if(sum%2||(n*2-sum)%2)
		{
			cout<<"-1\n";
			continue;
		}
		int sum1=0,sum2=0;
		for(int i=1;i<=n;i++)
			if(a[i]!=b[i])
			{
				if(a[i]) sum1++;
				else sum2++;
			}
		cout<<sum1/2+sum2/2+2*(sum1%2&&sum2%2)<<"\n";
	}
    return 0;
}
```

---

## 作者：jscaj0921 (赞：0)

# 思路

## 不可能成功的情况

首先，我们应最先注意不可能的情况。这种情况比较好想，如果某一种颜色的石头的个数是奇数，因为一列两个，所以不可能。

## 可能成功的情况

对于偶数的时候，我们再将其分成两类。

### 不需要额外交换的情况

当第一行未匹配的黄色石头个数为偶数时，我们就可以将一个于另一个正下方的石头交换，第二行也一样。

### 需要额外交换的情况

如果第一行未匹配的黄色石头个数为奇数，我们还像上面一样操作，但最后会剩下两个石头，一个在上，一个在下。这时候，我们先把下面的换上去，再换下来就可以了，这样会花费两步。

# 代码

```cpp
#include <iostream>
using namespace std;
int a[10005];
int b[10005];
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            if (a[i] == 1) sum++;
        }
        for (int i = 1; i <= n; i++) {
            cin >> b[i];
            if (b[i] == 1) sum++;
        }
        if (sum % 2 == 1) {
            cout << -1 << endl;
            continue;
        }
        int sum1 = 0, sum2 = 0;
        for (int i = 1; i <= n; i++) {
            if (a[i] != b[i]) {
                if (a[i] == 1) sum1++;
                else sum2++;
            }
        }
        if (sum1 % 2 == 0) cout << (sum1 + sum2) / 2 << endl;
        else cout << sum1 / 2 + sum2 / 2 + 2 << endl;
    }
    return 0;
}
```

[AC](https://www.luogu.com.cn/record/212871112)

---


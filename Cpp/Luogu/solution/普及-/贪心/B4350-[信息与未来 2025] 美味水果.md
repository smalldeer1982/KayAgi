# [信息与未来 2025] 美味水果

## 题目描述

Dr. X 收到了一份礼物：$n$ 个水果，其中第 $i$ 个水果的好吃程度为 $x_i$。新鲜的水果会随时间变得不如最初好吃：
- 每天，Dr. X 可以选择吃掉一个水果，并记录下该天吃掉的水果的好吃程度。
- 没有被吃掉的每个水果，好吃程度将在第二天变为 $y = \lfloor\sqrt x\rfloor$，即 “开根号取整”：$y$ 是满足 $y^2 ≤ x$ 的最大整数。

请计算，在所有可能的吃水果顺序中，Dr. X 最多能获得多少好吃程度的总和。

## 说明/提示

### 样例 $\textbf 1$ 解释

在第一天，Dr.X 吃掉第一个水果，好吃程度为 $100$，另一个水果在第二天吃，好吃程度为 $\lfloor\sqrt{10}\rfloor = 3$，吃完所有水果，好吃程度的总和为 $103$。

### 数据范围
对于 $40\%$ 的数据，$1 ≤ n ≤ 100$。

对于 $100\%$ 的数据，$1 ≤ n ≤ 10^5$，水果的好吃程度 $1 ≤ x_i ≤ 10^9$。

## 样例 #1

### 输入

```
2
100 10```

### 输出

```
103```

## 样例 #2

### 输入

```
6
1 3 7 10 15 21```

### 输出

```
28```

# 题解

## 作者：Yxa_Sheep (赞：7)

`upd 2025/6/28`：修改了时间复杂度。

**[题目传送门](https://www.luogu.com.cn/problem/B4350)**
## 题意
过 $x$ 天后这个水果的美味程度就开 $x$ 次根号。有 $n$ 个水果，求总的好吃程度的最大值。题目中说 $1\le n\le 10^5$，难到放这么久不会发霉吗？
## 思路
这道题很容易想到贪心，美味程度越大的水果开根号后损失的美味程度越多，所以美味程度越大的水果要越先吃掉，于是先把 $a$ 数组从大到小排序，然后一个一个的吃掉。第 $i$ 天吃掉的水果，放了 $i-1$ 天，要开 $i-1$ 次根号，于是有了这份代码：

```cpp
sort(a + 1, a + n + 1, greater<int>()); //从大到小排序
for (int i = 1; i <= n; i++) //n 个水果
{
    for (int j = 1; j < i; j++) //开 i - 1 次根号
        a[i] = sqrt(a[i]); //sqrt 是开根号，需要头文件 cmath
    ans += a[i]; //加上这个水果的美味值 
}
printf("%d", ans); //输出总美味值
```

这样会超时三个点，40分。我们会发现 $\sqrt{1} =1$，如果 $a_i$ 变成了 $1$ 之后就可以跳出循环。$a_i$ 最大为 $10^9$，开 $5$ 次根号后可以变为1。（是不是一个水果放 $5$ 天后就可以永久保存，美味程度始终为1）。时间复杂度最高的好像是快排，$O(n \log{n})$这是优化后的代码：

```cpp
sort(a + 1, a + n + 1, greater<int>()); //从大到小排序
for (int i = 1; i <= n; i++) //n 个水果
{
    for (int j = 1; j < i && a[i] != 1; j++) //开 i - 1 次根号，并且这一项不为 1
        a[i] = sqrt(a[i]); //sqrt 是开根号，需要头文件 cmath
    ans += a[i]; //加上这个水果的美味值 
}
printf("%d", ans); //输出总美味值
```

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, a[100010];
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    sort(a + 1, a + n + 1, greater<int>());
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j < i && a[i] != 1; j++)
            a[i] = sqrt(a[i]);
        ans += a[i];
    }
    printf("%d", ans);
    return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4350)**

---

## 作者：zhaogenshuo (赞：3)

# B3450 题解：

## 主要思路：

* 将序列从大到小排序。
* 递归求解当前值的平方根。
* 求和输出。

## 代码实现：

定义一个数组 $a$，循环输入 $a$ 数组，将 $a$ 数组快排（这里我用的 `greater<int>()` 比较器），再循环处理一遍，每次循环用递归函数处理当前值，最后求和输出。

**[AC](https://www.luogu.com.cn/record/221364422) code：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fun(int x,int y){
	int num=x;
	int k=y;
	num=sqrt(num);//开方 
	k--;
	//特判 
	if(num==1){
		return num;
	}
	if(k==1){
		return num;
	}else{
		fun(num,k);
	}
}//递归函数 
int n;
int a[100010];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//快排 
	sort(a+1,a+n+1,greater<int>());
	int sum=a[1];
	for(int i=2;i<=n;i++){
		//调用函数，a[i] 为当前待处理值，i 为当前循环次数 
		a[i]=fun(a[i],i);
		sum+=a[i];
	}
	cout<<sum;
	return 0;
}
``````

---

## 作者：jiangchengzhe (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4350)。

### Part 1 思路
贪心。  
可以发现，将美味值最大的水果放在第一个吃，可以获得的美味值总和最大。  
所以，先把水果的美味值从大到小```sort```一遍，然后按题目要求模拟开根号即可。  
注意，$a[i]$ 最大是 $10^9$，最多开 $5$ 次根号即会仅剩 $1$（向下取整），后面无论如何开根号，都是 $1$。

### Part 2 完整代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[100005];
bool cmp(int x,int y){
    return x>y;
}//从大到小排序
signed main(){ 
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n,cmp);
    int sum=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=min(i-1,7ll)/*最多开5次根，保险起见，我开了7次*/;j++){
            a[i]=(int)(sqrt(a[i]));//开根
        }
        sum+=a[i];
    }
    cout<<sum;
    return 0;
}
```
时间复杂度为 $O(n \log n+n)$。

### Part 3 完结撒花
[AC 记录](https://www.luogu.com.cn/record/221354759)。

---

## 作者：yxsc555 (赞：2)

本蒟蒻的第一篇题解        

关键点 $1$
--       
注意到 $x_i \le 10^9$ 也就是说我们可以计算出 $10^9$ 要开几次根号变为 $1$ 这样就不用枚举之后的美味程度了。    
可以用代码解决。        

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long s=1e9;
	for(int i=0;;i++)
	{
		s=floor(sqrt(s));
		ans++;
		if(s==1)
		break;
	}
	cout<<ans;
}
```
可以得出结果 $ans=5$ 那么当第五天时直接计算还有几个水果跳出循环就可以了。  

关键点 $2$    
--      
在这题中要使总美味程度最大要先吃最好的，    
那么就要用到排序了，     
对于初学者来讲冒泡排序是最好的选择。     

```cpp
#include<bits/stdc++.h>
long long x[100005],n;
using namespace std;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	cin>>x[i];
	for(int i=0;i<n-1;i++)
	{
		for(int j=0;j<n-i;j++)
		if(x[j]<x[j+1])
		swap(x[j],x[j+1]);
	}
}
```
加上关键点 $1$ 提交一下吧，        
会 $40$ 分。  
因为冒泡排序的时间复杂度为 $O(n^2)$ 所以不行。       
但是 ```<algorithm>```库有提供一个 ```sort``` 排序函数搭配 ```greater``` 变成 ```sort(x,x+n,greater<int>())```    即可而且时间复杂度为 $O(n log n)$ 满足我们的要求。    

结合一下        

AC code    
--    

```cpp
#include<bits/stdc++.h>//万能头
long long x[100005];
using namespace std;
int main()
{
	long long n,ans=0;
	cin>>n;
	for(int i=0;i<n;i++)
	cin>>x[i];
	sort(x,x+n,greater<int>());//排序
	for(int i=0;i<n;i++)//枚举天数
	{
		if(i==5)//关键点 1
        {
            ans=ans+n-i;
            break;
        }
        else
        {
            for(int j=1;j<=i;j++)//计算美味程度
                x[i]=floor(sqrt(x[i]));
		    ans=ans+x[i];
        }
	}
	cout<<ans;
}
```

---

## 作者：lizeyuhello (赞：2)

赛时十几分钟 A 了，来写篇题解。

# 题意

给定一个长度为 $n$ 的数组 $a$，每次需要从中选取一个未被选过的数累加入答案，此时 $a$ 中所有未选取的 $a_i(1 \leq i \leq n)$ 全部更新为 $\sqrt{a_i}$，求答案的最大值。

# 题解

排序后暴力的时间复杂度为 $\mathcal{O}(n^{2})$，只能拿到 $30$ 分。

观察数据，得出 $a_i$ 最大 $10^{9}$ 求 $5$ 次平方根取整就会得到 $1$，而 $\sqrt{1} = 1$，也就是说，$a_i = 1$ 时对答案的贡献不再改变。

考虑贪心，将 $a$ 排序后，计算前 $6$ 个数，其它数都为 $1$。

这种方法的时间复杂度为 $\mathcal{O}(n \log n)$，瓶颈在排序。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
int n, ans;
int a[N];

int calc(int x, int k)
{
	int res = x;
	for (int i = 1; i <= k; ++i) //计算 x 开根 k 次取整
		res = sqrt(res);
	return res;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
		scanf("%d", a + i);
	sort(a + 1, a + n + 1, greater<int>()); //降序排序
	for (int i = 1; i <= 7; ++i)
		ans += calc(a[i], i - 1);
	ans += max(0, n - 7); //其它数都是 1，直接加入答案
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：Yivan11 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/B4350)
## 前言
我们需要计算在最优的吃水果顺序下，能获得的最大美味值总和。每个水果如果不被吃掉，其美味值会每天开平方取整。

## 思路
可以采用贪心算法，每次吃当前最大美味值的水果，并预处理每个水果最多 $5$ 次开平方后的值（因为任何数开 $5$ 次平方后都会变成 $1$），最后累加每个水果在被吃掉时的最优值即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e5 + 5;
int a[MAXN];
int val[MAXN][6];
signed main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> a[i];
    }
    sort(a, a + n, greater<int>());
    for(int i = 0; i < n; i++) {
        val[i][0] = a[i];
        for(int j = 1; j <= 5; j++) {
            val[i][j] = sqrt(val[i][j-1]);
        }
    }
    int ans = 0;
    for(int i = 0; i < n; i++) {
        int k = min<int>(i, 5); 
        ans += val[i][k];
    }
    cout << ans << endl;
    return 0;
}
```
这题其实还是很简单的。

---

## 作者：zyr2011 (赞：1)

贪心题。  
### 做法
对于每一个水果，肯定是**先吃**最好吃的，再吃难吃一点的，这样子损失显然是最小的。所以我们直接用 ```sort``` 对 $a$ 数组进行排序，然后按之前说的模拟水果腐烂时贪心即可。  
直接模拟没有优化的代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
inline bool cmp(int a,int b){
	return a>b;
}//把最好的放前面 
signed main(){
	int n,ans=0;cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);//排序 
	for(int i=1;i<=n;++i){
		for(int j=1;j<i;++j){
			a[i]=sqrt(a[i]);//开根 
		}
		ans+=a[i];//统计好吃程度的总数 
	}
	cout<<ans<<endl;
	return 0;
}
```
提交评测后，会有三个点超时。
### 优化
仔细观察代码，时间的瓶颈在于水果好吃程度的腐烂计算，根据七年级知识，我们可以知道 $\sqrt{1} = 1$，那么我们在水果好吃程度为 $1$ 时直接停止循环，由于 $a_i$ 最多为 $10^9$，开 $5$ 根号后也会变为 $1$，可以接受 $n \le 10^5$ 的数据。  
### 满分代码  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
inline bool cmp(int a,int b){
	return a>b;
}//把最好的放前面 
signed main(){
	int n,ans=0;cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);//排序 
	for(int i=1;i<=n;++i){
		for(int j=1;j<i;++j){
			if(a[i]==1){
				break;//水果好吃程度变为1时结束循环 
			} 
			a[i]=sqrt(a[i]);//开根 
		}
		ans+=a[i];//统计好吃程度的总数 
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wzs0413 (赞：1)

### 思路
显然，好吃程度越大的水果要先吃，所以我们可以从小到大排序。又注意到：任何小于等于 $10^9$ 的数开五次根号后都为 $1$ 。五天后的水果的好吃程度直接变为 $1$ 即可。最后求和输出。

### 代码

```cpp
#include"bits/stdc++.h"
using namespace std;

const int N=1e5+10;
int n;
int a[N];
long long ans;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n,greater<int>());
	for(int i=1;i<=n;i++)
	{
		if(i<=5) for(int j=2;j<=i;j++) a[i]=sqrt(a[i]);
		else a[i]=1;
		ans+=a[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Gongyujie123 (赞：1)

## [B4350 [信息与未来 2025] 美味水果](https://www.luogu.com.cn/problem/B4350) 题解
### 1. 思路分析
很明显，这道题是**贪心和排序**。因为水果的好吃程度会随时间越来越小，而我们要求好吃程度总和的最大值，所以我们应该从好吃程度大的水果开始吃，这样才能保证好吃程度总和最大。

知道这些后，我们就可以将水果按好吃程度从大到小排序，然后遍历每个水果，它的下标 $i$（下标从 $1$ 开始）就表示它是在第 $i$ 天被吃掉的，接着对它的好吃程度开根号取整 $i$ 次。最后将所有水果的好吃程度加起来即可。

可是，我们稍微想一想就可以知道时间复杂度为 $O(n^2)$，显然无法通过这道题的 $1 \le n \le 10^5$。那我们该如何优化呢？

看到开根号取整，我们很容易想到 $\sqrt{1} = 1$，所以对于 $1$ 无论开根号多少次都还是 $1$。我们便可以在这里优化一下：如果好吃程度等于 $1$，那么就直接退出开根号取整 $i$ 次的这个循环。

### 2. AC 代码

[AC 记录](https://www.luogu.com.cn/record/221966277)，最慢点：18 ms。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
bool cmp(int x, int y){  // 从大到小排序
	return x > y;
}
signed main(){
	ios::sync_with_stdio(false);  // 关闭同步流优化
	cin.tie(0);
	cout.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	sort(a, a + n, cmp);
	int ans = 0;
	for (int i = 0; i < n; i++) {  // 枚举每个水果
		for (int j = 0; j < i; j++) {  // 进行开根号取整
			if (a[i] == 1) break;  // 优化：如果好吃程度等于 1，那么就直接退出循环
			a[i] = sqrt(a[i]);  // 开根号，int 自带取整
		}
		ans += a[i];  // 计算总和
	}
	cout << ans;
	return 0;
}
```

---

## 作者：fumanke (赞：1)

## B4350 [信息与未来 2025] 美味水果
[题目传送门](https://www.luogu.com.cn/problem/B4350)

### 题目描述
有 $n$ 个水果，每天吃一个。每过一天，水果的美味程度 $a_i$ 就会变成 $\sqrt{\left \lfloor a_i \right \rfloor} $。可以变换吃水果的顺序，求美味程度和的最大值。

### 解题思路
美味程度越大的水果，过一天损失的美味程度越多。因此考虑贪心，把 $a_i$ 从大到小排序，再对每个 $a_i$ 开 $i-1$ 次根。然后全部加起来，就可以得到答案。

#### 40 分代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100005], ans;
bool cmp(int x, int y) { return x > y; }
int main() {
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    sort(a + 1, a + n + 1, cmp);
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j < i;j++) a[i] = int(sqrt(a[i]));
        ans += a[i];
    }
    cout << ans << endl;
    return 0;
}
```
时间复杂度为 $O(n^2)$，会 TLE 三个点。

### 代码优化
把 $10^9$ 扔进计算器里，发现开 $5$ 次根就会变成 $1$。$1$ 不管开多少次根都还是 $1$。

因此，对于 $a_i$，只要开 $(\min \left\{6, i\right\}-1)$ 次根就行了。

#### AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100005], ans;
bool cmp(int x, int y) { return x > y; } //从大到小排序
int main() {
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    sort(a + 1, a + n + 1, cmp);
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j < min(6, i);j++) //这里是小于，非小于等于！
            a[i] = int(sqrt(a[i])); //开根并向下取整
        ans += a[i]; //累加
    }
    cout << ans << endl;
    return 0;
}
```
不想写 cmp 函数的可以这样：

``` sort(a + 1, a + n + 1, greater<int>()); ```

时间复杂度 $O(n \log n)$，可以通过本题。

---

## 作者：蒟蒻whker (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4350)。真的是黄题吗？

### 思路简述
直接贪心，显然初始好吃程度大的先吃，否则会损失更多，所以先把水果的美味值从大到小```sort```一遍，然后按题目要求模拟。   
然鹅会 TLE。  
于是继续观察，发现 $\sqrt{1}=1$，并且 $\le10^{9}$ 的整数最多开五次平方就会变成 $1$。因此，只要算到 $1$ 就不用再算。

时间复杂度为 $$\mathcal{O}(n \log n)$$，瓶颈在排序。

### AC code

```
#include<bits/stdc++.h>
using namespace std;
int f[100005],n,sum=0;
int cmp(int a,int b)//排序函数
{
    return a>b;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>f[i];
    }
    sort(f+1,f+n+1,cmp);//注意倒序
    for(int i=1;i<=n;i++)
    {
        for(int j=1;f[i]!=1&&j<i;j++)//到1就停
        {
            f[i]=sqrt(f[i]);
        }
        sum+=f[i];//统计答案
    }
    cout<<sum;
}
```

求一键三连~

---

## 作者：OIer_bcx_ (赞：1)

本蒟蒻的第一篇题解

---

注意到数据范围中 ${a_i} \le 10^9$，且当 ${a_i} = 1$ 时就不用开根号了。计算可得当 ${a_i} \le 10^9$ 时，最多只需开 $5$ 次根号。

那么当第五天时直接统计还剩多少水果即可。

时间复杂度 $O(n)$，目前最优解第一。

## AC code


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,ans=0;
    cin>>n;
    int a[n+1];
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int x=1;x<=5;x++){
        int mx=0,w=0;
        for(int i=1;i<=n;i++){
            if(a[i]>mx){
                mx=a[i];
                w=i;
            }
        }
        ans+=mx;
        a[w]=0;
        for(int i=1;i<=n;i++){
            if(i!=w){
                a[i]=sqrt(a[i]);
            }
        }
    }
    for(int i=1;i<=n;i++){
        ans+=a[i];
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：xmy201315 (赞：1)

这是一道贪心题。

每一天优先吃价值大的水果一定是最优的，我们假设两个水果的价值为 $y$ 和 $x$，其中 $y>x$，那么 $x-\lfloor\sqrt x\rfloor\le y-\lfloor\sqrt y\rfloor$，所以价值大的水果一天流失的价值是不小于价值小的水果一天流失的价值，所以我们应该优先吃价值大的水果。但是这时候我们发现时间复杂度为 $\mathcal O(n^2)$，我们以惊人的注意力发现，其实每个水果的价值最多进行 $5$ 天后价值就变为 $1$，然后以后不管多少天价值还是 $1$，那么我们就可以进行剪枝优化成 $\mathcal O(n)$。

**AC code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100005;
int n;
int a[N],d,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(int i=n;i;i--){
        int k=d;
        while(k!=0&&a[i]!=1)a[i]=sqrt(a[i]),k--;
        ans+=a[i];
        d++;
    }
    printf("%d",ans);
}
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4350)

# 解析

## 题目大意

有一些水果具有新鲜度，每过一天新鲜度就会变成昨天新鲜度的开方，每一天只能吃一个水果，求最大能够获得多少新鲜度。

## 考察知识

本题考查贪心。

## 思路

很容易得到：新鲜度越高的水果被开放后损失就越多，所以我们采取贪心思路：新鲜度越高的水果越尽快吃掉。

所以我们可以排个序，然后枚举计算总和。注意：如果被开方数是 $1$ 的话，那么这个水果新鲜度就不变。举个例子。

有个水果新鲜度为 $10^5$，开五次方就会得到 $1$，也就是说经过五天，水果新鲜度就会一直是 $1$！~~这科学吗？~~

而如果不做特判处理，那么就会在枚举每一天的时候不断地开方，浪费时间。毕竟再看一眼数据范围：$1\le x\le 10^9$，~~保留这么久水果不早就坏掉了吗~~ 不特判就会时间超限。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int fruit[N],n,sum=0;
int cmp(int a,int b)
{
    if(a>b)
    {
        return 1;
    }
    return 0;
}

signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>fruit[i];
    }
    sort(fruit+1,fruit+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i&&fruit[i]!=1;j++)
        {
            fruit[i]=sqrt(fruit[i]);
        }
        sum+=fruit[i];
    }
    cout<<sum;
}
```

---

## 作者：czxuyang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4350)
## 前言
赛时大脑挂了，优化反而降低了四十分，所以结束了来写题解。

## 1. 简化题意
有 $n$ 个水果，每个水果有各自的美味值，每天都可吃掉一个水果，其余的水果的美味值会变成 $\sqrt{a_i}$，求能获得的最大美味值。

## 2. 思路/代码
考虑暴力，因为每个水果的美味值减少速度都是指数级的，所以我们优先考虑美味值大的水果，因为它美味值减少的程度总是比其他水果的要大。

暴力写法，时间复杂度 $\mathcal{O}(n^2)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
bool cmp(int aa,int bb){
	return aa>bb;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		ans+=a[i];
		for(int j=i+1;j<=n;j++){
			a[j]=sqrt(a[j]);
		}
	}
	cout<<ans;
	return 0;
}
```


当你愉快的提交这份代码，发现只有[ $60$ 分](https://www.luogu.com.cn/record/221355005)。这又是怎么回事呢？

于是我们考虑优化，观察题目，这启示我们，在样例数据下对一个数开根时只要时间足够，最后的值肯定是 $1$，没必要对后面的数进行处理，于是我们排序过后，如果出现 $1$，后面的数值也肯定是 $1$，时间复杂度为 $\mathcal{O}(n \log n)$。

可写出如下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
bool cmp(int aa,int bb){
	return aa>bb;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			ans++;
			continue;
		}
		ans+=a[i];
		for(int j=i+1;j<=n;j++){
			a[j]=sqrt(a[j]);
		}
	}
	cout<<ans;
	return 0;
}

```
于是我们愉快的[ AC ](https://www.luogu.com.cn/record/221354856)了这道题。

---

## 作者：Blackox_xxx (赞：0)

好玩的基础贪心题。

## 思路
不难发现，每个水果的美味程度越大，在第二天损失的就越多，所以每天吃掉当前水果美味度最大的水果即可，当然每天的水果的美味度的排序和第一天一直是一致的。

所以就可以想到贪心。

然而，我们发现直接用暴力的不断开方会 [TLE 三个点](https://www.luogu.com.cn/record/221589079)。

但我们稍微用大脑思考一下就可以想出优化办法，那就是在水果美味度到达 $1$ 时，再怎么开方这个数值也不会变，所以只要在循环开方时美味度到达 $1$ 时就不再开方即可。

## 代码


```cpp
#include <cmath>
#include<iostream>
#include<algorithm>
using namespace std;
int n, ans, fr[100010];

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> fr[i];
    }
    sort(fr + 1, fr + n + 1, greater<int>());
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j < i && fr[i] != 1; j++) fr[i] = sqrt(fr[i]);
        ans += fr[i];
    }
    cout << ans;
    return 0;
}
```

### 关于本题的超时

题目中给出了 $1 \le n \le 10^5$ 如果每一个水果都去耗费其在**所有水果中美味度排名**次数去开方，时间复杂度就是 $O(n^2)$，显然会超时，在判断是否为 $1$ 就结束循环后时间复杂度就降为 $O(n \log a_i)$，可以通过本题。

---

## 作者：Charged_Charge (赞：0)

# 洛谷 B4350
## 题目大意：
有 $n$ 个水果，每个水果的美味值为 $a_i$，每天，每个水果的美味值变成 $\sqrt{a_i}$。求最多能获取多少美味值。
## 解题思路：
简单贪心。很明显，大的数开根后，缩减的美味值一定大于小的数缩减的美味值。所以我们直接对原数组倒序排列，先吃美味值较大的水果。然后模拟对后面所有水果的美味值开根。注意：$1$ 开根后还是 $1$，可以特判减少时间。
## AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+20;
int n, ans;
int a[N];
bool cmp(int x, int y) {
	return x > y;
}

signed main() {
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	sort(a + 1, a + 1 + n, cmp);

	for (int i = 1; i <= n; i++) {
		if (a[i] == 1) {
			ans++;
			continue;
		}

		ans += a[i];

		for (int j = i + 1; j <= n; j++) {
			a[j] = sqrt(a[j]);
		}
	}

	cout << ans;
	return 0;
}
```

---

## 作者：chang_bd (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4350)

## 思路：

用快速排序从大到小排序数组，再模拟从第 $1$ 个数模拟到第 $n$ 个数，最后加起来即可

## 证明:

容易得到：大的数，减少的好吃程度总是不小于小的，而最大化好吃程度就是最小化减少的好吃程度，所以大的水果要先吃。

## 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans;
bool cmp(int x,int y){
	return x>y;
}
int kai(int x,int y){
	while(x!=1&&y>=1){
		--y;
		x=sqrt(x);
	}
	return x;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;++i){
		ans+=kai(a[i],i-1);
	}
	cout<<ans;
}
```

---

## 作者：StormWhip (赞：0)

## 思路
考虑贪心：优先吃掉好吃程度大的水果一定更优。  
证明：设函数 $f(x)=x-\sqrt{x}$，容易发现 $f(x)$ 的值为好吃程度为 $x$ 的水果一天后损失的好吃程度。对其求导有 $f'(x)=1-\frac{1}{2\sqrt{x}}$，不难发现 $x\in[1,+\infty]$ 时，$f'(x)$ 恒大于 $0$，即原函数在定义域内单调递增。综上，好吃程度大的水果放久了之后损失更多，因此要优先吃掉。  
需要注意的是，好吃程度的最大值为 $1\times 10^9$，最多开根 $5$ 次就会变为 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,ans,now;
priority_queue <int> q;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) {int x;cin>>x;q.push(x);}
	while(q.size())
	{
		int x=q.top();
		q.pop();
		if(now>=5) {ans++;continue;}
		for(int i=1;i<=now;i++) x=sqrt(x);
		ans+=x;now++;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：Mark_Pei (赞：0)

## Solution

这道题比赛时没场切，回来补个题解。

一眼**排序**加**贪心**。

题目要求获得好吃程度的最大总和，因为随着时间推移，水果好吃程度将会逐级递减。所以，我们需要先吃好吃程度大的水果，贪心成立，将水果的好吃程度降序排列，再计算开方即可。

但是，光做这些时间上是过不去的，这时我们通过手玩会发现一个小于等于 $10^9$ 的数开 $5$ 次平方后向下取整都是 $1$，所以只循环 $5$ 天就可以了。

注意  $1≤x_i≤10^9$，所以建议开 **long long**。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000003];
long long s;
bool cmp(int x,int y)
{
      return x>y;
}
int main()
{
	cin>>n;
      for(int i=1;i<=n;i++)
            cin>>a[i];
      sort(a+1,a+1+n,cmp);
      for(int i=1;i<=5;i++)
      {
            int x=a[i];
            for(int j=2;j<=i;j++)
                 x=(int)sqrt(x);
            s+=x;
      }
      if(n>5) s+=(n-5);
      cout<<s;
      return 0;
 }
```

---

## 作者：ryderyang (赞：0)

# 解题思路

## 贪心
我们应该要先吃掉那些好吃程度大的水果，因为：

  - 对于 $2$ 个数字 $x$ 和 $y$，满足 $x \gt y$。
  - 如果先选择 $x$，则一共可以得到 $x + \sqrt y$。
  - 如果先选择 $y$，则一共可以得到 $y + \sqrt x$。
  - 首先，$x-y$ 是肯定大于等于 $\sqrt x - \sqrt y$ 的。
  - 我们有：

$$
(x + \sqrt y) - (y + \sqrt x) = x - y  - \sqrt x + \sqrt y = (x-y)-(\sqrt x - \sqrt y)
$$

  - 因为 $x-y \ge \sqrt x - \sqrt y$，所以：

$$
(x-y)-(\sqrt x - \sqrt y) \ge 0
$$

  - 因此：

$$
x + \sqrt y \ge y + \sqrt x
$$

  - 所以，我们应该优先选择那些好吃程度高的水果。

## 数学优化
我们写出的程序时间复杂度太高了，但是我们可以发现：

  - 当数字经过若干次开根号之后变成 $1$ 了，那么他不管再开多少次根号，都不会变，因为 $\sqrt 1 = 1$。

所以，当数字变成 $1$ 时，我们可以直接退出循环。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int x,int days)//数字x开days次根号后会变成几?
{
	for(int i=1;i<=days;i++)//枚举
	{
		if(x==1)//优化：如果x=1,因为 $\sqrt 1=1$，所以不管之后再开多少次更好，都是1
		return x;
		x=sqrt(x);//开根号
	}
	return x;
}
const int N=100005;//数组大小
int n,a[N],ans;
bool cmp(int x,int y)//cmp函数
{
	return x>y;//从大到小
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);//输入
	sort(a+1,a+1+n,cmp);//贪心思路：从大到小选
	for(int i=1;i<=n;i++)
	ans+=f(a[i],i-1);//统计答案
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

比较简单的排序加贪心。  
很明显我们需要先吃好吃程度更大的水果，因为随着时间推移，水果好吃程度将会逐级递减。因此我们对水果好吃程度降序排列，再计算要开几次平方即可。

**优化点**：$\le 10^9$ 的数至多开 $5$ 次平方就变为了 $1$，所以在第 $5$ 天后吃下的水果，美味程度都是 $1$，就省得额外次数开平方了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[114514]; 

inline int rd(){
    int f = 1, k = 0;
    char c = getchar();
    while(!isdigit(c)){if(c == '-') f = -1; c = getchar();}
    while(isdigit(c)){k = (k << 3) + (k << 1) + c - '0'; c = getchar();} 
    return k * f; 
}  
int main(){
    int n = rd();
	for(int i = 0; i < n; ++i) a[i] = rd();
	sort(a, a + n, greater<int>()); //降序排序
	
	int ans = 0;
	for(int i = 0; i < n; ++i){
		if(i < 5){ // 5 天之内需要正常开平方计算
			for(int j = 0; j < i; ++j) a[i] = sqrt(a[i]);
			ans += a[i]; 
		} 
		else ++ans; //超过 5 天的水果，美味值绝对为 1
	} 
	cout << ans; 
    return 0;
}
```

---


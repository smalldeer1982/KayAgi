# [蓝桥杯青少年组省赛 2025] 平衡奇偶位置的字符交换

## 题目描述

给定一个字符串 $S$，其中仅包含字符 $\tt A$ 和字符 $\tt B$。你每次可以选择交换两个位置相邻的字符，请计算如果要使奇数位置上（位置从 1 开始）字符 $\tt A$ 的数量等于偶数位置上字符 $\tt A$ 的数量，最少需要进行多少次交换操作。

例如：$S = \tt{AABABA}$，从左往右数，奇数位置上字符 $\tt A$ 的数量为 $1$（位置 $1$），偶数位置上字符 $\tt A$ 的数量为 $3$（位置 $2$、$4$、$6$）。可将位置 $2$ 的字符 $\tt A$ 和位置 $3$ 的字符 $\tt B$ 交换。交换后，奇数位置上字符 $\tt A$ 的数量和偶数位置上字符 $\tt A$ 的数量都为 $2$，满足题目要求，故最少需要交换一次。


## 样例 #1

### 输入

```
AABABA```

### 输出

```
1```

# 题解

## 作者：Cookie_King (赞：10)

## Solution
因为 $|s| \leq 10^5$，所以不能暴力。

首先，我们知道，如果输入的字符串已经满足条件，那么最少操作次数肯定是 $0$。还有，如果 $A$ 的个数为奇数，那么你无论交换多少次也不能满足条件，因此直接输出 $-1$。

那么，我们要交换的数量就是：奇数位上 $A$ 的数量与偶数位上 $A$ 的数量的差值。因为交换一半就可以满足条件，所以输出时还要除以 $2$。

最后别忘了：如果 $B$ 的数量小于你最少要交换的次数，那么也不可能满足条件，输出 $-1$。

[AC 记录](/record/230273402)
## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
string s;
int main(){
    cin>>s;
    s=' '+s;
    int j=0,o=0,b=0;
    //j表示在奇数位上A的个数，o表示在偶数位上A的个数，b表示B的个数
    for(int i=1;i<s.length();++i){
        if(i%2==1&&s[i]=='A')
            j++;
        else if(i%2==0&&s[i]=='A')
            o++;
        else if(s[i]=='B')
            b++;
    }
    if((j+o)%2==1){
        printf("-1\n");
        return 0;
    }
    if(j==o){
        printf("0\n");
        return 0;
    }
    if(b<abs(j-o)/2)
        printf("-1\n");
    else
        printf("%d\n",abs(j-o)/2);
    return 0;
}
```

---

## 作者：xuyixuan_123 (赞：6)

第一次场切黄，发个题解纪念一下。
## 思路：
- 定义一个 ```cnt``` 数组，用 ```cnt[0]``` 来存字符 A 的个数，```cnt[1]``` 来存 A 在偶数位上的个数，```cnt[3]``` 来存 A 在奇数位上的个数。
- 统计完后，先判断 ```cnt[0]``` 存的个数是否为偶数，不是就输出 $-1$。然后输出 ```abs(cnt[1]-cnt[2])/2``` 就行了。
## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cnt[3];
string s;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]=='A'){
			cnt[0]++;
			if((i+1)%2==0){
				cnt[1]++;
			}
			else{
				cnt[2]++;
			}
		}
	}
	if(cnt[0]%2==1){
		cout<<-1;
	}
	else{
		cout<<abs(cnt[1]-cnt[2])/2;
	}
	return 0;
}
```

---

## 作者：I_do_Cpp (赞：4)

## 题目分析
首先，因为我们要求奇数位置上字符 A 的数量等于偶数位置上字符 A 的数量，所以我们可以循环遍历一遍字符串，求出 $A$ 在奇数位置有多少个（用 $a$ 表示），偶数位置有多少个（用 $b$ 表示）。

我们分类讨论，显然，如果 $(a-b)$ 的**绝对值**是奇数的话，表明不可能完成题意，因为只有 $a,b$ 两个数一奇一偶才能满足 $(a-b)$ 的绝对值是奇数，而这样两者永远不可能相等。

否则，也就是，$(a-b)$ 的绝对值是偶数的情况，我们可以发现，无论是从把偶数位的 $A$ 移到奇数位，还是从奇数位移到偶数位，$a,b$ 中必然有一个数 $+1$，另一个数 $-1$，那么 $(a-b)$ 的绝对值就会少 $2$。每移动一次，绝对值减少 $2$，那移动次数就是 $(a-b)$ 的绝对值再除以 $2$。

那怎么证明每次都有 $B$ 能交换呢？考虑几种极端情况：  
情况一：
```
ABABBAAAAAA
```
我们可以让左数第三个 $A$ 和右边的 $B$ 交换，此时字符串变为
```
ABABABAAAAA
```
刚刚移动完的 $B$ 右边又有字符可以交换，读者可以自行推演   

情况二：
右边全是偶数（包括 $0$）个 $A$（因为有奇数个直接会判没有正解），左边全是 $B$（或整个字符串全是 $A$）：
这种情况，一定会 $a=b$（$a,b$见第一段），因为是偶数个，并且所有的 $A$ 都是紧挨着，公式和正解都是输出 $0$。相反的情况同理。

最后要讲的是，题目中的索引从 $1$ 开始，但是字符串的索引从 $0$ 开始。有一种方法是加一个空格，这样索引就是从 $1$ 到字符串的长度了。
## 题目代码
代码不加注释了，应该能看得懂。
```cpp
#include<bits/stdc++.h>
using namespace std;

signed main()
{
	string s;
	cin>>s;
	s=" "+s;
	int a=0,b=0;
	for(int i=1;i<s.size();i++)
	{
		if(s[i]=='A')
		{
			if(i%2==1)
			{
				a++;
			}
			else
			{
				b++;
			}
		}
	}
	if(abs(a-b)%2==1)
	{
		cout<<-1;
	}
	else
	{
		cout<<abs(a-b)/2;
	}
	return 0;
}
```

---

## 作者：lcc0222 (赞：3)

::::info[题目核心]{open}
使奇数位置上（位置从 1 开始）字符 $A$ 的数量等于偶数位置上字符 $A$ 的数量，最少需要进行多少次交换操作。
::::
#### 方法
先计算奇数位置上字符 $A$ 的数量，在计算偶数位置上字符 $A$ 的数量，如果两个计数器差的绝对值可以整除2那么可以实现，否则不行。
#### 证明
设奇数位置上字符A的数量为 $a$，偶数位置上字符A的数量为 $b$（$|a-b|$ 可以整除2），如果 $a$ 不等于 $b$,就交换其中一个 $A$ 与 $B$ 的位置（相邻），此时 $a$ 或 $b$ 增加 1，对应的计数器减少 1，他们的差的绝对值就减少 2，最终变为 0。
所以，最少的操作次数为
$$\frac{|a-b|}{2}$$

#### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int len,cnt1,cnt2;
int main(){
    cin>>a;
    len=a.size();
    for(int i=0;i<len;i++){
        if(a[i]=='A'){
            if(i%2){
                cnt1++;
            }
            else{
                cnt2++;
            }
        }
    }
    if((int)abs(cnt1-cnt2)%2==0){
        cout<<(int)abs(cnt1-cnt2)/2;
    }
    else{
        cout<<-1;
    }
    return 0;
}
```

---

## 作者：lovely_firefly (赞：3)

这道题好像没有黄吧。

显然可以发现，如果奇数位置上的 A 的数量与偶数位置上的 A 的数量相加为奇数是肯定无解的；否则绝对有解，且解为两个数量之差除以 $2$。

证明：如果相邻两位都是 A，那么这里相当于已经完成了，无需再交换。否则如果其中一位是 A，则如果有 A 的位置那方 A 数量更多则肯定要交换，否则无需交换。

这里的逻辑可能不是很清晰，但大家应该还是能理解的吧。

那么最优解是啥呢？前面相当于证明了肯定能找到可以交换的地方，那么显然我们少的那方差多少补多少。注意：由于我们交换一个差距会减少 $2$，所以答案是两方数量的差的绝对值除以 $2$。

代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N=100003;
char s[N];
int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1),cnt1=0,cnt2=0;
	for (int i=1;i<=n;++i)
	{
		if (s[i]!='A') continue;
		if (i%2==1) ++cnt1;
		else ++cnt2;
	}
	if ((cnt1+cnt2)%2==1) printf("-1");
	else printf("%d",abs(cnt1-cnt2)/2);
	return 0;
}

```

---

## 作者：liuyuantao (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4377)

个人认为很简单（至少想到结论是的），赛时直接秒了。  
先考虑输出 $-1$ 的情况。我们记 $\text{find}_A$ 为 $S$ 中字符 $\texttt{A}$ 的总出现次数，因为奇数位置上字符 $\texttt{A}$ 的数量等于偶数位置上字符 $\texttt{A}$ 的数量，所以字符 $\texttt{A}$ 的**总出现次数必为偶数**。因此若 $\text{find}_A$ 为奇数，输出 $-1$。  

考虑每一次操作的影响。记 $\text{odd}_A$ 表示奇数位置上字符 $\texttt{A}$ 的数量，$\text{even}_A$ 表示偶数位置上字符 $\texttt{A}$ 的数量。当我们交换的两个字符分别为 $\texttt{A},\texttt{B}$ 时，才会对这两个值有影响，而且一定是一个 $+1$，另一个 $-1$。我们可以不断地从字符 $\texttt{A}$ 的数量多的一方取 $\texttt{A}$ 与另一方的 $\texttt{B}$ 交换，最终一定能达成目标。  
先证明可以交换。利用反证法，若不能达成交换，可以得知字符 $\texttt{A}$ 的数量多的一方**所有的** $\texttt{A}$ 相邻的字符都为 $\texttt{A}$。对于多的一方是奇数方，我们对所有 $\texttt{A}$ 取它右边的 $\texttt{A}$ 与其对应，偶数取左边的。可以发现，多的一方所有 $\texttt{A}$ 对应的 $\texttt{A}$ 两两不同，所以少的一方 $\texttt{A}$ 的数量不少于多的一方，矛盾。所以一定存在两个相邻的字符，使得 $\texttt{A}$ 的数量多的一方字符为 $\texttt{A}$，少的一方为 $\texttt{B}$。  
可知每次交换会减少 $2$ 的数量差。我们考虑证明 $|\text{odd}_A-\text{even}_A| \bmod 2=0$。注意到：  
$$
|\text{odd}_A-\text{even}_A| \bmod 2=|\text{odd}_A-\text{even}_A+2 \times \text{even}_A| \bmod 2=\text{find}_A \bmod 2=0
$$  
所以经过 $\dfrac{|\text{odd}_A-\text{even}_A|}{2}$ 次操作后数量差就会变为 $0$，即奇数位置上字符 $\texttt{A}$ 的数量等于偶数位置上字符 $\texttt{A}$ 的数量。输出这个数即可。  
时间复杂度 $O(n)$，$n$ 为字符串长度。  
[AC code](https://www.luogu.com.cn/record/230313930)  
```cpp
#include <bits/stdc++.h>

using namespace std;

int n,cnt,ans;
string s;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>s;
    n=s.size();
    for(int i=0;i<n;i++){
    	if(s[i]=='A'){
    		ans++;
    		if(i&1)cnt++;
		}
	}
	if(ans&1)cout<<-1<<endl;
	else cout<<abs((ans-cnt)-cnt)/2<<endl;
	
    return 0;
}
```
这是本人的第 $2$ 篇 B 题库题解，如果觉得有用就点个赞吧！  
同场题解：  
* [题解：B4380 [蓝桥杯青少年组省赛 2025] 魔术扑克牌排列](https://www.luogu.com.cn/article/23vtf9tm)
* [题解：B4379 [蓝桥杯青少年组省赛 2025] 硬币游戏](https://www.luogu.com.cn/article/a0xkcp7v)

---

## 作者：Jelly2014 (赞：1)

这题其实就是计算奇数位和偶数位字符 A 的数量，再判断，如果不符合条件就输出 $-1$，否则输出答案。我们拆开来讲：

### 统计字符数量
定义两个变量 $cnt0$ 和 $cnt1$，并用循环来统计，在循环里判断：如果这里是奇数位与在此位置的字符是 A，就把 $cnt1$ 加 $1$。否则如果这里是偶数位与在此位置的字符是 A，就把 $cnt0$ 加 $1$。

### 比较并输出
结束循环之后，判断 $cnt1 + cnt0$ 是否是奇数。（是奇数就永远不可能使奇数位置上的 A 的数量等于偶数位置上的 A 的数量，毕竟数量都不能均分），如果是，就输出 $-1$。否则输出 $cnt1$ 和 $cnt0$ 中的较大值减去最小值的差再除以 $2$。（把 $cnt1$ 和 $cnt0$ 均分就一定是最少的交换次数）

最后上代码!

```cpp
#include <iostream>
using namespace std;
string s;
int cnt0,cnt1;
int main()
{
	cin >> s;
	int len=s.size();
	for (int i=0;i<len;++i)
	{
		if (i%2==1 && s[i]=='A')
		{
			++cnt1;
		}
		else if (s[i]=='A')
		{
			++cnt0;
		}
	}
	if ((cnt1+cnt0)%2==1)
	{
		cout << -1;
	}
	else
	{
		cout << (max(cnt0,cnt1)-min(cnt0,cnt1))/2;
	}
	return 0;
}
```

---

## 作者：ethansang (赞：1)

# B4377 [蓝桥杯青少年组省赛 2025] 平衡奇偶位置的字符交换 题解
~~今年蓝桥杯题也太水了。~~
## 题意
>给你一个字符串 $s$，由 `A` 和 `B` 组成。问最少要交换几次，才能使 $s$ 奇数位上 `A` 的个数等于偶数位上 `A` 的个数。如果无解输出 $-1$。
>
## 思路
>首先判断 $-1$ 的情况，当 $s$ 中有奇数个 `A` 时无解。
>
>然后再想答案，发现一次交换会使奇偶数位上 `A` 的个数之差减少 $2$。因此答案就是奇偶位上 `A` 的个数之差除以 $2$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f3f3f3f
#define mod 1000000007
#define pi M_PI
#define lowbit(x) (x & -x)
#define ls u << 1
#define rs u << 1 | 1
#define pii pair<int, int>
#define debug cout << "OK" << endl;
const int N = 2e5 + 5;
int T = 1;
string s;

void solve()
{
	cin >> s;
	int ji = 0, ou = 0;
	for (int i = 0; i < s.size(); i++)
		if (s[i] == 'A'){
			if (i + 1 & 1)
				ji++;
			else
				ou++;
		}
	if (ji + ou & 1){
		cout << -1 << endl;
		return;
	}
	cout << (max(ji, ou) - min(ji, ou)) / 2 << endl;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    //cin >> T;
    while (T--)
        solve();

    return 0;
}
```

---

## 作者：fire_star_ (赞：1)

题意：

给定一个仅由 `A` 和 `B` 组成的字符串，每次可以交换这个字符串中相邻的两个字符；求最小的交换次数，使得奇数位上的 `A` 和偶数位上的 `A` 数量相同。如果无法达成，输出 `-1`。

我们可以令 $b$ 为字符串偶数位中 $A$ 的数量，$c$ 为奇数位中 $A$ 的数量。

不难发现，当 $b + c$ 为奇数时无解，为偶数时答案即为 $\frac{|b - c|}{2}$。

代码还是非常好写的。

代码：
```cpp
int b=0,c=0,ans=0;
int main(){
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(s[i]=='A'){
            if (i%2==0) b++;
            else c++;
        }
    }
    if ((b+c)%2!=0){
        puts("-1");
        return 0;
    }
    ans=abs(b-c)/2;
    cout<<ans;
    return 0;
}
```

---

## 作者：Leo2011 (赞：1)

考场做法逆天，结果发现是正解……

卡卡常（其实也没怎么卡）直接最优解榜一（查看时间：2025/08/12 09:08）

---

先说结论：令奇数位的 A 有 $X$ 个，偶数位的 A 有 $Y$ 个，那么如果 $\left| X - Y \right|$ 是奇数那么无解，否则答案是 $\dfrac{\left| X - Y \right|}{2}$。

为什么呢？其实证明也很简单。

首先我们发现题目只和字母 $A$ 相关，而且关键在于奇数位的 A 和偶数位的 A，于是我们分别对其计数。

然后我们考虑操作会产生什么影响。

> 每次可以选择交换两个位置**相邻**的字符。——题目

相邻的两个数显然是一奇一偶，而交换这两个只可能是奇数位换到偶数位（或偶数换到奇数位）。

这样就可以让奇数的数量减少一个，偶数增加一个（或者反过来）。

一个加一，另一个减一，它们的差当然是减少 $2$ 了。而且每次操作都会减少 $2$，因为必然是奇换偶或偶换奇。因此得到了上面的结论，证毕。

---

:::success[ACCode with 注释]
```cpp
#include <bits/stdc++.h>

using namespace std;

int a, b, n;  // a 是偶数位，b 是奇数位，n 是字符串长度
string s;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0); 
    cin >> s;
    n = s.size();
      for (int i = 0;i < n;++i) if (s[i] == 'A') {  // 注意到和 B 无关因此要判断
        if (i % 2) ++b;  // %2 余 0 就是 false，余 1 就是 true，正好分别对应偶数和奇数
        else ++a;
    }
    if ((abs(b - a)) % 2) cout << -1 << endl;  // 不知道谁大谁小，因此要取绝对值
    else cout << ((abs(b - a)) >> 1) << endl;  // 右移 1 位相当于除以 2，因为是非负数所以和 / 2 没有区别
    return 0;
}
```
:::

[AC 记录~](https://www.luogu.com.cn/record/230339416)

理解万岁！

---

## 作者：aganlive (赞：1)

# B4377 [蓝桥杯青少年组省赛 2025] 平衡奇偶位置的字符交换 题解



[题目传送门](https://www.luogu.com.cn/problem/B4377)



## 题目大意



你可以交换相邻两个字母，使奇数位和偶数位的字符 $\tt A$ 相等。



##  本题考点



本题考查贪心。



## 思路



1. 输入 $S$，并建立 $cnt\_odd$ 和 $cnt\_even$ 变量，分别统计奇数位上字符 $\tt A$ 的数量和偶数位上字符 $\tt A$ 的数量。



```c++
string input, s; // 根据本题，1-based 方便操作
cin >> input;
s = " " + input;
int cnt_odd, cnt_even;
for (unsigned int i = 1; i < s.length(); i++) {
	if (i % 2 == 1 && s[i] == 'A') cnt_odd++;
  else if (i % 2 == 0 && s[i] == 'A') cnt_even++;
}
```



2. 接着我们需要比较 $cnt\_odd$ 和 $cnt\_even$ 的大小：如果 $cnt\_odd$ 和 $cnt\_even$ 相等，说明不需要交换，输出 0 并结束程序；如果 $cnt\_odd$ 比 $cnt\_even$ 小，遍历每个奇数位直到 $cnt\_odd = cnt\_even$，判断当前位是否是字符 $\tt B$ 并且左右有没有字符 $\tt A$ 来交换，最后如果遍历完了，仍然 $cnt\_odd \neq cnt\_even$，输出 -1 ；如果 $cnt\_odd$ 比 $cnt\_even$ 大也是一样的。



```cpp
if (cnt_odd == cnt_even) {
	cout << 0;
	return 0;
} else if (cnt_odd < cnt_even) {
	for (unsigned int i = 1; i < s.length(); i += 2) { // s[1-1] 是 ' '，不担心越界。
		if (s[i] == 'B' && (s[i-1] == 'A' || s[i+1] == 'A')) {
			cnt_odd++;
			cnt_even--;
			ans++;
		}
		if (cnt_odd == cnt_even) {
			cout << ans;
			return 0;
		}
	}
	cout << -1;
} else if (cnt_odd > cnt_even) {
	for (unsigned int i = 2; i < s.length(); i += 2) { // s 的末尾是 '\0'，也不担心越界。
		if (s[i] == 'B' && (s[i-1] == 'A' || s[i+1] == 'A')) {
			cnt_even++;
			cnt_odd--;
			ans++;
		}
		if (cnt_odd == cnt_even) {
			cout << ans;
			return 0;
		}
	}
	cout << -1;
}
```



## 时间复杂度



很明显，时间复杂度是 $O(|S|)$，可以通过。



## 你们最喜欢的完整代码



```cpp
#include <iostream>
#include <string>
using namespace std;
int cnt_odd, cnt_even, ans;
string input, s;
int main() {
	cin >> input;
	s = " " + input;
	for (unsigned int i = 1; i < s.length(); i++) {
		if (i % 2 == 1 && s[i] == 'A') cnt_odd++;
		else if (i % 2 == 0 && s[i] == 'A') cnt_even++;
	}
	if (cnt_odd == cnt_even) {
		cout << 0;
		return 0;
	} else if (cnt_odd < cnt_even) {
		for (unsigned int i = 1; i < s.length(); i += 2) {
			if (s[i] == 'B' && (s[i-1] == 'A' || s[i+1] == 'A')) {
				cnt_odd++;
				cnt_even--;
				ans++;
			}
			if (cnt_odd == cnt_even) {
				cout << ans;
				return 0;
			}
		}
		cout << -1;
	} else if (cnt_odd > cnt_even) {
		for (unsigned int i = 2; i < s.length(); i += 2) {
			if (s[i] == 'B' && (s[i-1] == 'A' || s[i+1] == 'A')) {
				cnt_even++;
				cnt_odd--;
				ans++;
			}
			if (cnt_odd == cnt_even) {
				cout << ans;
				return 0;
			}
		}
		cout << -1;
	}
	return 0;
}
```



[AC CODE](https://www.luogu.com.cn/record/230451778)

---

## 作者：dangerous_DZR (赞：0)

### 分析
首先观察题目数据范围发现 $s$ 的范围过大，若是暴力枚举就会导致超时，所以考虑优化。

令 $o$ 表示奇数位上 $A$ 的数量，$z$ 表示偶数位上 $A$ 的数量，那么当 $o - z = 0$ 时即可满足要求。可以发现，只有相邻两位同时包含 $A$ 和 $B$，$o - z$ 的值才会在交换后发生改变。

- 若 $A$ 在原字符串中的奇数位，交换则会导致 $o$ 减少一，$z$ 增加一，即让 $o - z$ 的值减少二。
- 若 $A$ 在原字符串中的偶数位，交换则会导致 $o$ 增加一，$z$ 减少一，即让 $o - z$ 的值增加二。

因为 $o - z$ 的值始终只能增加二或减少二，所以若开始时的 $o - z$ 为奇数，则不可能满足题目要求。

那么我们还可以证明一下当 $o - z$ 为偶数时必有满足要求的解，首先令 $n$ 表示字符串 $s$ 的长度且假设 $o > z$（$o < z$ 可以根据下面的证明自己推一下）。

> 证明：我们想要让满足上述条件的两位子串尽可能少，就可以让 $A$ 字符尽量全部排在前面。那么字符串前端将会有 $2 \times z + 1$ 个连续的 $A$，字符串末尾将会有 $n - 2 \times o + 1$ 个连续的 $B$，则形如 $AB$ 的两位子串数量就有 $o - z$ 个，形如 $BA$ 的两位子串数量就有 $o - z - 1$ 个（自己可以举个例子想想为什么），因为若要使 $o = z$ 需要 $\frac{o - z}{2}$ 个 $AB$ 或 $BA$ 子串，所以有 $\min(o - z, o - z - 1) \ge \frac{o - z}{2}$，得证。

所以当 $o - z$ 为偶数时， 我们就可以直接输出 $\frac{o - z}{2}$。时间复杂度为统计 $o$ 和 $z$ 时的 $O(n)$，足以通过此题。
### 实现
遵上述方法实现即可：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int z, o;
int main(){
	cin >> s;
	for (int i = 0, l = s.size(); i < l; i ++)z += (i & 1) && s[i] == 'A', o += (i + 1 & 1) && s[i] == 'A';//注意下标从 1 开始
    cout << (abs(o - z) & 1 ? -1 : abs(o - z) >> 1);//判断奇偶性
	return 0;
}
```
码风奇丑，不适轻喷。

---

## 作者：__szh_DNCB__ (赞：0)

这是真的第十篇题解了。

很疑惑这个题怎么评的黄，一个很简单的贪心啊？

容易想到扫一遍字符串 $s$，得到奇数位和偶数位 `A` 的数量，这里姑且记作 $e$ 和 $o$。我们再设 $m$ 为奇数和偶数的差值，即 $|e-o|$。

注意到如果我们交换相邻两个不相等字符，那么一定会导致 $m$ 自增或自减 $2$，换句话说，$m$ 的奇偶性是不变化的。所以我们就得出：当 $|e-o|$ 为奇数时，输出 `-1`。

又因为我们这题要求的是最小交换次数，所以我们要尽快让 $m$ 为 $0$。所以我们每次都把 $m$ 自减 $2$。容易发现这是一定能实现的，因为我们只要让含 `A` 较多的位置与含 `A` 较少的位置交换一下即可。

所以得出答案为 $\dfrac{m}{2}$，即 $\dfrac{|e-o|}{2}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin >> s;
    int even=0,odd=0;
    for (int i=0;i<s.size();i++){
        if (s[i] == 'A'){
            if (i%2)odd++;else even++;
        }
    }
    if ((even - odd) % 2)puts("-1");
    else cout << abs(odd-even)/2;
    return 0;
}
```

附：[AC 记录](https://www.luogu.com.cn/record/230298142)。

---

## 作者：Zyh20101221 (赞：0)

考场上一眼秒，经典贪心。

从左到右扫描，只要当前是 $A$，前一个或后一个是 $B$，就立马交换，记录一下交换次数，然后判断一下奇数 $A$ 的个数是否等于偶数 $A$ 的个数，如果相等直接输出答案，否则继续遍历。

为什么这个策略是最优的？

1. 局部最优即全局最优：每次交换都是必要的，因为只有通过交换相邻的 $A$ 和 $B$ 才能改变奇偶位置上 $A$ 的数量分布
2. 无后效性：前面的交换不会影响达到目标的可能性，因为我们只关心最终的平衡状态
3. 最小交换次数：每次交换都朝着目标状态前进，不会做无用功

代码部分：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int ji,ou,ans;

int main(){
    cin>>s;
    s=' '+s;
    for(int i=1;i<=s.size();i++){
        if(i&1&&s[i]=='A') ji++;
        else if(i%2==0&&s[i]=='A') ou++;
    }
    if(ji==ou) {  //特判一下
        cout<<0;
        return 0;
    }
    else if(ji>ou){
        for(int i=1;i<=s.size();i++){
            if(i&1&&s[i]=='A'){
                if(s[i+1]=='B'||s[i-1]=='B'){
                    ou++;
                    ji--;
                    ans++;
                }
                if(ji==ou){
                    cout<<ans;
                    return 0;
                }
            }
        }
    }
    else {
        for(int i=1;i<=s.size();i++){
            if(i%2==0&&s[i]=='A'){
                if(s[i+1]=='B'||s[i-1]=='B'){
                    ou--;
                    ji++;
                    ans++;
                }
                if(ji==ou){
                    cout<<ans;
                    return 0;
                }
            }
        }
    }
    cout<<-1;
    return 0;
}
```
望管理员通过，谢谢！！！

---


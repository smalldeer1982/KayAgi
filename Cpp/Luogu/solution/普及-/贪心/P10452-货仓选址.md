# 货仓选址

## 题目描述

在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1 \sim A_N$。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

## 说明/提示

数据保证，$1 \le N \le 10^5$，$0 \le A_i \le 40000$。

## 样例 #1

### 输入

```
4
6 2 9 1```

### 输出

```
12```

# 题解

## 作者：GXZJQ (赞：10)

# P10452 货仓选址 题解

[题目链接](https://www.luogu.com.cn/problem/P10452)

## 题目大意

在数轴上找一个点，使得这个点到其他所有点的距离之和最小。

## 题目分析

这是一道找规律的题目。

先来看样例，对于样例来说，地图如下图所示：

![示意图一](https://cdn.luogu.com.cn/upload/image_hosting/wsi9chb5.png)

这时，观察可以发现，在 $2 \sim 6$ 之间建一个仓库可以让总和距离最小。那么，这是为什么呢？

因为这时我们可以发现，这个点都在每组**线段上**，这样的话，我们选的点到这两个点之间的和就是以这两个点为端点的线段的长度。在高中，我们将其称之为**绝对值三角不等式**。

推广一下，为了使距离和最小，就是要让这个点在每两个点构成的线段上，此时满足这个点到这两个点的距离和最小。由于数轴上的点是有次序的，所以长度最大的线段一定包含长度最小的线段，所以最后我们只需要在长度最小的线段上任取一点即可满足贪心。特别地，当点数为奇数时，在中间点建一个仓库即可满足题目要求。

注意开始循环前需要排序。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int n, ans, a[maxn];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n / 2; i++)
		ans += (a[n - i + 1] - a[i]);
	cout << ans;
	return 0;
}

```

---

## 作者：穼柗° (赞：7)

这个问题是一个典型的“一维中位数”问题。为了最小化货仓到每家商店的距离之和，货仓应该建在商店坐标的中位数上（如果商店数量是奇数）或中位数两边的任意一点上（如果商店数量是偶数）。

这是因为对于数轴上任一非中位点，总存在至少一对商店，它们到该点的距离之和大于它们到中位点的距离之和。对于中位数，到它左侧的所有点的距离之和等于到它右侧的所有点的距离之和（或者差一个单位的距离，如果商店数量是奇数），因此总距离最小。

以下是一个简单的算法来解决这个问题：

1. 输入商店数量 $N$ 和所有商店的坐标 $A_1 ∼ A_N$。
2. 对所有坐标进行排序。
3. 找出中位数坐标（如果 $N$ 是奇数，就是第 $\frac{N+1}{2}$ 个坐标；如果 $N$ 是偶数，可以是第 $\frac{N}{2}$ 个或第 $\frac{N}{2}+1$ 个坐标）。
4. 计算货仓到每家商店的距离之和。由于货仓在中位数上，所以距离和可以通过计算所有商店到中位数的绝对距离之和来得到。
5. 输出距离和。

### Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
signed int n,arr[100000];
inline long long count(const int pos) { // 计算pos到每家商店的距离之和
    register long long ret;
    for(register int i=ret=0;i<n;i++)
        ret+=abs(arr[i]-pos);
    return ret;
}
signed main(void) {
    scanf("%d",&n);
    for(register int i=0;i<n;i++)
        scanf("%d",arr+i);
    sort(arr,arr+n);
    printf("%lld",count(arr[n/2])); // 下标从0开始，奇偶通用 
    return 0;
}
```

---

## 作者：hema5177 (赞：5)

### 思路

要使仓库到商店的距离之和最小，把仓库设在一个商店的位置至少能使一个商店到仓库的距离为 $0$，是最佳的策略。因为选在不是商店的区域都可能会有距离上不必要的浪费。而选择作为仓库的商店处于这N家商店的中间，距离之和就会最小。因为所有商店到这家商店的距离的数值之差都会比较小。排序并选择中间那个商店作为仓库即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
long long n,a[100001],sum;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++) sum+=abs(a[n/2]-a[i]);
    cout<<sum;
}
```

---

## 作者：Stars_visitor_tyw (赞：4)

## 题解：P10452 货仓选址
### 分析
要求距离之和最近，可以将原数组从小到大排序，取最中间的那一个，从样例便可以发现。如果 $n$ 为偶数，则在中间两个元素中任取 $1$ 个即可。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
signed main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        cnt+=abs(a[i]-a[n/2]);
    }
    cout<<cnt;
}
```

---

## 作者：UnfortunatelyDead (赞：2)

我们考虑对商店坐标从小到大排序后的操作如何应对。

不妨先枚举一个预计仓库建的位置 $i$，记 $a_i < i$ 的数为 $x$，那么相对于上一个枚举的 $i-1$ 的答案，左边的 $x$ 个点所走的路程会多出来，每个点多出 $1$，所以会加上 $x$。而右边的点（此处包含 $i$，因为是 $i-1$ 转移到 $i$）相对而言就是靠近了 $1$ 的路，会缩短 $n - x$ 的路程。

$x$ 可以通过二分求出，或可以通过 $i-1$ 的 $x$ 求出 $i$ 的 $x$（就是 $x \gets x + cnt_{i-1}$）。

于是可以先预处理在 $a_0 = 0$ 时候的答案进行转移，复杂度 $O(n \log n)$，瓶颈在排序。

```cpp
int a[101010];
signed main() {
	int n = read();
	for (int i = 1; i <= n; ++i) read(a[i]);
	sort(a + 1, a + 1 + n);
	int id = 0, ans = 1e18, sum = 0;
	for (int i = 1; i <= n; ++i) sum += a[i]; ans = sum;
	for (int i = 1; i <= n; ++i) {
	    if (a[i] != 0) {
	        id = i-1;
	        break;
	    }
	}
	for (int i = 1; i <= 40001; ++i) {
		sum += id; sum -= n - id;
		while (id < n && a[id + 1] <= i) ++id;
		smin(ans, sum);
	} write(ans, '\n');
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：2)

设货仓的位置为 $t$，并已经将数组 $a$ 从小到大排序。

$n$ 为偶数时，显然 $a_1$ 和 $a_n$ 之间到 $t$ 的距离总和是有最小值的，而且最小值需满足 $a_1\le t\le a_n$。$a_2$ 和 $a_{n-1}$，$a_3$ 和 $a_{n-2}$，一直到 $a_{\frac{n}{2}}$ 和 $a_{\frac{n}{2}+1}$ 都是同理。所以此时只需要保证 $a_{\frac{n}{2}}\le t\le a_{\frac{n}{2}+1}$ 即可。最终答案为对于所有满足 $1\le i \le \frac{n}{2}$ 的 $i$ 的整数值，将答案增加 $a_{n-i+1}-a_i$。$n$ 为奇数同理，只需要让 $t=a_{\frac{n+1}{2}}$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n/2;i++)ans+=a[i+(n+1)/2]-a[i];
    cout<<ans;
    return 0;
}
```

---

## 作者：abc1856896 (赞：2)

# 题目描述

在数轴上给出 $n$ 个点。

有一个点使得这个点到所有其他点的距离最小，求这个距离。

# solution
简单贪心。

最优的点应该是在中间的点，因此我们排完序后取中间点即可。

时间复杂度 $O(n)$。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    int t=a[n/2];
    for(int i=1;i<=n;i++) {
        ans+=abs(a[i]-t);
    }
    cout<<ans;
    return 0;
}

```

---


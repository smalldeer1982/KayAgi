# [蓝桥杯 2024 省 C] 回文数组

## 题目描述

小蓝在无聊时随机生成了一个长度为 $n$ 的整数数组，数组中的第 $i$ 个数为 $a_i$，他觉得随机生成的数组不太美观，想把它变成回文数组，也是就对于任意 $i\in [1,n]$ 满足 $a_i=a_{n-i+1}$。小蓝一次操作可以指定相邻的两个数，将它们一起加 $1$ 或减 $1$；也可以只指定一个数加 $1$ 或减 $1$，请问他最少需要操作多少次能把这个数组变成回文数组？

## 说明/提示

**【样例说明】**

第一次操作将 $a_1, a_2$ 加 $1$，变为 $2, 3, 3, 4$；

后面两次操作将 $a_1$ 加 $1$，变为 $4,3,3,4$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \le n \le 10$；  
对于所有评测用例，$1 \le n \le 10^5$，$-10^6 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
3```

# 题解

## 作者：Hyper_zero (赞：28)

# P10902 [蓝桥杯 2024 省 C] 回文数组题解
*十年 OI 一场空，不开 long long 见祖宗！*
## 思路：贪心
题目要求将一个随机数组变成一串回文数，可执行的操作如下：
+ 相邻两个数同时加 $1$
+ 单个数加 $1$ 或减 $1$

由于一个数加 $1$ 得到回文数和一个数减 $1$ 得到回文数效果一样，我们可以不考虑减 $1$ 的情况。

很显然，相邻两个数同时加 $1$ 要比单个数加 $1$ 或减 $1$ 的步数少，于是我们优先将相邻两个数同时加 $1$。

## 实现
我们用数组 $b$ 来存放 $a_i$ 需要变化的次数，然后计算相邻两个数可以同时加 $1$ 的次数，最后加上单个数加 $1$ 的次数。

## ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
long long n,a[N],b[N],ans;
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=1;i<=(n+1)/2;i++)     //计算 a[i] 需要变化的次数
	{
		if(a[i]<a[n-i+1])           //前一半
			b[i]=a[n-i+1]-a[i];
		else
			b[n-i+1]=a[i]-a[n-i+1]; //后一半
	}
	for(int i=1;i<=n;i++)           //计算步数
	{
		int mn=min(b[i],b[i+1]);    // mn 为相邻两个数可以同时加1的次数
		b[i]-=mn;
		b[i+1]-=mn;
		ans+=mn;                    //加上邻两个数可以同时加1的次数
		ans+=b[i];                  //加上单个数加 1 的次数
	}
	printf("%lld",ans);
}
```
~~求过qwq~~

---

## 作者：Xssion37_XY (赞：10)

考虑贪心。

我们记对相邻元素进行操作为操作一。

同理，记对单个元素进行操作为操作二。

可以发现，操作一实际就是操作二，因为对两个相邻元素进行操作实际就是对其中一个元素进行操作二然后“复制“给左边或右边的元素。

容易发现操作时对称的，考虑只对前半部分进行操作，统计操作二的次数即可。

在操作其中一个元素时，判断后一个元素是否需要也进行一次操作即可。


```
#include <iostream>
#include <cmath>
#define int long long
using namespace std;
const int N = 1e6 + 11;
int a[N],b[N >> 1];
int sum,cnt,j;
signed main(){
	int n;
	cin >> n;
	for (int i = 1;i <= n;i ++) {
		cin >> a[i];
	}
	for (int i = 1;i <= n / 2;i ++){
		b[++ j] = a[i] - a[n - i + 1];
	}
	int len = j;
	for (int i = 1;i <= len;i ++){
		cnt += abs(b[i]);
		if (i != n){
			if (b[i] > 0 and b[i + 1] > 0){
				b[i + 1] -= min(b[i],b[i + 1]);
			}
			if (b[i] < 0 and b[i + 1] < 0){
				b[i + 1] -= max(b[i],b[i + 1]);
			}
		}
	}
	cout << cnt;
	return 0;
}  
```

---

## 作者：Ricardo_M (赞：5)

## 1.题意
给一个数列，有两个操作，一是将单个数字加或减一，二是将相邻的两个数字同时加或减一，问最后将其修改为回文数列的最小修改次数。
## 2.思路解析
回文数组具有对称性，考虑第 $i$ 个数和第 $n-i+1$  是一样的，所以只需要考虑前一种情况就可以了。我们可以用一个额外的数组把对应数的差值存下来，然后运用贪心求解。

假设我们现在正在查看差值数组的第 $j$ 个数，如果第 $j$ 个和第 $j+1$ 个数是同号，等同于原本数组中这两个相邻位置都需要加或减，便可以一起处理。而如果异号，只需要单独处理即可。
## 3.代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long n,a[100005]={},b[100005]={},tmp=0;
    cin>>n;//读入
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n/2;i++){
        b[i]=a[i]-a[n-i+1];//将对应位置的差存入
    }
    for(int i=1;i<=n/2;i++){
        tmp+=abs(b[i]);//如果是异号单独处理
        if(b[i]>0&&b[i+1]>0){
            b[i+1]-=min(b[i],b[i+1]);//同号一起处理
        }
        if(b[i]<0&&b[i+1]<0){
            b[i+1]-=max(b[i],b[i+1]);//同号一起处理
        }
    }
    cout<<tmp;//输出
    return 0;
}
```

---

## 作者：abc1234shi (赞：5)

一道贪心题。

题意：给一个数列，有两个操作:一是将单个数字 $+1$ 或 $-1$，二是将相邻的两个数字同时 $+1$ 或者 $-1$。问最后将其修改为回文数列的最小修改次数。一看到这种求最小值的题，大家可能第一时间想到的就是贪心了。

前置知识：回文数列是指一个包含 $N$ 个整数的数列 $A$，分别为 $A_1$ 一直到 $A_n$。对于第 $i$ 个数 $A_i$，都有 $A_i=A_{n-i+1}$。

思路：回文相关的问题一般都具有对称性，考虑第 $i$ 个数和考虑第 $n-i+1$ 个数问题一样，可以忽略后者，因此这里只需要处理前一半，让前一半保持和后一半对称（相同）。

现在处理的第 $i$ 个数与第 $n-i+1$ 个数的差值和即将处理的第 $i+1$ 个数与第 $n-(i+1)+1$ 个数的差值同号，也就是第 $i$ 个数与第 $n-i+1$ 的差与第 $i+1$ 个数与第 $n-(i+1)+1$ 的差均为正数或负数），那么就可以用操作 $2$ 一次性处理，剩下的就只能是操作 $1$ 了。

复杂度：$O(N)$。

---

## 作者：Tiger_Rory (赞：4)

这题其实贪心解决就好了。

我们可以开一个数组 $s$ 存储前一半原数组中第 $i$ 个数与对应的原数组第 $n-i+1$ 个数的差（即需要操作的次数），然后从前到后枚举数组 $s$，每枚举到非零的项，判断下一项与此项是否可以同加或同减（判断条件：此项非零，下一项非零，且两项正负性相同）。如果可以就改变这两项的值，如果不能或操作完此项还有剩余，就加上 $s$ 中这一项的绝对值。

对于判断条件的说明：若本项为零，那么无需操作；若下一项为零，那么下一项无需操作，只要操作本项即可；若下一项与本项正负性不同，那么我们会发现操作本项时会扩大下一项操作数的大小，必然不优。

详情见代码（有点冗长了）。


```cpp
#include<bits/stdc++.h>
#define int long long //不开long long只有20pts
using namespace std;
const int N = 1e5 + 5; 
int n, a[N], s[N]; 
signed main(){
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); //输入输出优化
    cin >> n; 
    for(int i = 1; i <= n; i++) cin >> a[i]; 
    
    int ans = 0; //记录操作次数 
    for(int i = 1; i <= n / 2; i++) 
		s[i] = a[i] - a[n - i + 1]; 
	//存储差，即每个数需要的操作次数 
    for(int i = 1; i <= n / 2; i++) {
        if(s[i] == 0) continue; 
		//如果差是0，就不用操作，跳过
        if(s[i + 1] == 0) ans += abs(s[i]); 
		//如果下一项为0，直接加上此项的绝对值
        else if(s[i] > 0 && s[i + 1] > 0 || s[i] < 0 && s[i + 1] < 0) {
        	//同正同负时执行操作  
            int answer = min(abs(s[i]), abs(s[i + 1])); 
			//记录可以同时操作的次数 
            if(s[i] < 0) s[i] += answer; 
            else s[i] -= answer;  
            if(s[i + 1] < 0) s[i + 1] += answer; 
            else s[i + 1] -= answer; 
            //对两数执行操作 
            ans += answer; 
			//加入答案 
            if(s[i] != 0) ans += abs(s[i]); 
            //若操作数还有剩余，加上剩余操作数的绝对值 
        }
		else ans += abs(s[i]); 
		//不同正同负，也直接加绝对值 
    }
    cout << ans; 
    return 0; 
}
```

---

## 作者：liaoxingrui (赞：4)

## Content

给你一个 $n$ 和一个长度为 $n$ 的数组，让你把这个数组变为回文数组，及 $a_i = a_{n - i + 1}$。你可以指定相邻的两个数或是一个数，将它们一起加 $1$ 或减 $1$，求最少操作次数。

## Solution

我们可以使用贪心的思想，若两个相邻的数同时小于与自己对应的数，那就两个数一起加，若两个相邻的数同时大于与自己对应的数，那就两个数一起减，当然要考虑两个数与对应数的差的大小。最后还要记得将 $a_{\frac n 2} - a_{n - \frac n 2 +1}$ 加上。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n;
int a[N];
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n>>1;i++){
		ans+=abs(a[n-i+1]-a[i]);
		if(a[i]<a[n-i+1]&&a[i+1]<a[n-i]){
			if(a[n-i+1]-a[i]<a[n-i]-a[i+1])
				a[i+1]+=a[n-i+1]-a[i];
			else
				a[i+1]=a[n-i];
		}
		if(a[i]>a[n-i+1]&&a[i+1]>a[n-i]){
			if(a[i]-a[n-i+1]<a[i+1]-a[n-i])
				a[i+1]-=a[i]-a[n-i+1];
			else
				a[i+1]=a[n-i];
		}
	}
	cout<<ans+abs(a[n-(n>>1)+1]-a[n>>1]);
	return 0;
}
```

---

## 作者：Kagari22 (赞：2)

## 解题思路

首先读题，一次操作可以选择下列两个操作中的一个：

$1.$ 选择第 $i$ 个数 $a_i$ **加一**或者**减一**。

$2.$ 选择第 $i$ 个数 $a_i$ 和第 $i + 1$ 个数 $a_{i+1}$ $(i+1 < n)$ **一起加一**或者**一起减一**。

求出使得数组变成回文数组**最少**的操作次数。

很显然，用简单的**贪心**就能解决。



---



## 贪心思路
用一个数组 $b$ 记录下 $i$ 从 $0$ 到 $\displaystyle \left\lfloor \frac{n}{2} \right\rfloor$ 的所有 $a_{n-i+1} - a_i$ 的值，遍历 $b$ 数组，如果第 $i$ 个数 $b_i$ 和第 $i + 1$ 个数 $b_{i+1}$ $(i+1 < n)$ 都大于 $0$，则两者共同减去它们之中最小的数，将其记为 $minb$，即进行 $minb$ 次操作 $2$，并且将 $minb$ 加入总计数中。如果都小于 $0$，则两者共同减去它们之中最大的数，将其记为 $maxb$，即进行 $maxb$ 次操作 $2$，并将 $maxb$ 的**绝对值**加入总计数中。

遍历完 $b$ 数组之后，剩下的数只能进行操作 $1$ 。所以可以再遍历一次 $b$ 数组，将所有需要进行操作 $1$ 的次数加入总计数中，最后就可以打印答案啦。


---
## 代码
```cpp
#include <bits/stdc++.h>

#define int long long
#define ll long long
const int MOD = 1e9 + 7;
using namespace std;
      
int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
      
    int n;
    cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    int sum = 0;
    vector<int> b(n / 2);
    for(int l = 0, r = n - 1; l < r; l++, r--){
        b[l] = a[r] - a[l];
    }
    for(int i = 0; i < n / 2 - 1; i++){
        if(b[i] > 0 && b[i + 1] > 0){
            int minb = min(b[i], b[i + 1]);
            b[i] -= minb;
            b[i + 1] -= minb;
            sum += minb;
        }
        if(b[i] < 0 && b[i + 1] < 0){
            int maxb = max(b[i], b[i + 1]);
            b[i] -= maxb;
            b[i + 1] -= maxb;
            sum += abs(maxb);
        }
    }
    for(int x : b){
        sum += abs(x);
    }
    cout << sum;

    return 0;
}
``````

---

## 作者：__const_int__ (赞：2)

### Analysis
我们用 $diff_i$ 表示 $a_i$ 和 $a_{n - i +1}$ 的差。我们用 $ans$ 变量记录所需要的操作次数。设 $i$ 从 $1$ 枚举到 $\lfloor \dfrac{n}{2} \rfloor$，先将 $ans$ 加上 $diff_i$。

如果 $diff_i$ 和 $diff_{i + 1}$ 都大于 $0$，那么将 $diff_{i + 1}$ 减去 $\min(diff_i, diff_{i + 1})$，我们可以利用第一个操作将 $diff_i$ 和 $diff_{i + 1}$ 都变小。

如果 $diff_i$ 和 $diff_{i + 1}$ 都小于 $0$，那么将 $diff_{i + 1}$ 减去 $\max(diff_i, diff_{i + 1})$，我们可以利用第一个操作将 $diff_i$ 和 $diff_{i + 1}$ 都变大。

最后输出 $ans$ 即可。
### Code
```cpp
#include<bits/stdc++.h>

using ll = long long;
const int maxn = 100005;

ll a[maxn], diff[maxn], ans;

int main() {
  int n;
  std::cin >> n;
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
  }
  for (int i = 1; i <= n / 2; i++) {
    diff[i] = a[n - i + 1] - a[i];
  }
  for (int i = 1; i <= n / 2; i++) {
    ans += abs(diff[i]);
    if (diff[i] > 0 && diff[i + 1] > 0) {
      diff[i + 1] -= std::min(diff[i], diff[i + 1]);
    }
    if (diff[i] < 0 && diff[i + 1] < 0) {
      diff[i + 1] -= std::max(diff[i], diff[i + 1]);
    }
  }
  std::cout << ans;
}
```

---

## 作者：wht_1218 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10902)

-----

简单贪心。

我们要让第 $i$ 个数和第 $n-i+1$ 个数一样，可以只处理前一半。

假设现在处理的第 $i$ 个数与第 $n-i+1$ 个数的差值和即将处理的第 $i+1$ 个数与第 $n-(i+1)+1$ 个数的差值**同号**，那么就可以用操作 $2$ 一次处理，否则就用操作 $1$ 处理。

时间复杂度 $O(n)$。

**用我这个方法千万不要排序！！！！！**

![](https://cdn.luogu.com.cn/upload/image_hosting/quna5tmk.png)

---

## 作者：JoeZYQ (赞：0)

### [先看题](https://www.luogu.com.cn/problem/P10902)
### 思路分析
简单贪心。

我们可以先将从数 $a_i$ 单独修改为 $a_{n-i+1}$ 需要加多少或减多少统计出来，很显然，答案便为两数之差，设这个答案为 $c_i$。由于 $a_{n-i+1}$ 与 $a_i$ 之差一定为 $a_i$ 与 $a_{n-i+1}$ 之差的相反数，所以，我们只需要统计出前 $\frac{n}{2}$ 个数的 $c_i$ 值即可。

然后我们枚举从 $1$ 至 $\frac{n}{2}$ 的每个数，随后分四种情况讨论。
- $c_i$ 为 $0$，不需要修改。
- $c_i$ 与 $c_{i+1}$ 均非负，那么我们在修改 $a_i$ 的时候，可以顺带把 $a_{i+1}$ 也修改 $c_i$ 次。
- $c_i$ 与 $c_{i+1}$ 均非正，那么我们一样可以在修改 $a_i$ 的时候，可以顺带把 $a_{i+1}$ 也修改 $c_i$ 次。
- 除开以上所有情况之外，我们只能单独修改 $a_i$，如果连着 $a_{i+1}$ 一起修改，反而会对 $a_{i+1}$ 造成负面影响，从而保证不了操作次数最小。
### 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100005],s[100005];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		 cin>>a[i];
	for(int i=1;i<=n/2;i++){
		s[i]+=(a[i]-a[n-i+1]);
	}
	int ans=0;
	for(int i=1;i<=n/2;i++){
		if(s[i]==0)continue;
		if(s[i]>=0&&s[i+1]>=0){
			ans+=s[i];
			s[i+1]-=s[i];
			s[i+1]=max(s[i+1],0ll);
		}
		else if(s[i]<=0&&s[i+1]<=0){
			ans+=-s[i];
			s[i+1]-=s[i];
			s[i+1]=min(s[i+1],0ll);
		}
		else{
			ans+=abs(s[i]);
		}
	}
	cout<<ans;
    return  0;
}
```

---

## 作者：JYX0924 (赞：0)

这道题是一道贪心题。

对于数 $a_{i}$ 来说，若 $a_{i}-a_{n-i+1}$ 和 $a_{i+1}-a_{n-i}$ 的正负情况相同，就可以将它们一起操作，直到 $a_{i+1}=a_{n-i}$ 后进行单点修改，或者在 $a_{i}=a_{n-i+1}$ 时停止。

注意在枚举答案时循环到 $i \div2$ 即可。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 100005 
using namespace std;
ll n,a[maxn],ans;
int main()
{
    ios::sync_with_stdio(false); cin.tie(0);
    cin>>n; for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n/2;i++)
    {
	    if(a[i]==a[n-i+1]) continue;
	    ans+=abs(a[i]-a[n-i+1]);
	    if(a[i]-a[n-i+1]>0&&a[i+1]-a[n-i]>0)
	    {
	    	if(a[i+1]-a[n-i]>a[i]-a[n-i+1]) a[i+1]-=a[i]-a[n-i+1];
	    	else a[i+1]=a[n-i];
		}
	    if(a[i]-a[n-i+1]<0&&a[i+1]-a[n-i]<0)
	    {
	    	if(a[i+1]-a[n-i]<a[i]-a[n-i+1]) a[i+1]-=(a[i]-a[n-i+1]);
	    	else a[i+1]=a[n-i];
		}
	}
    cout<<ans;
    return 0;
}
```
谢谢大家！！！

---


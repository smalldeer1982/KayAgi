# 学生分组

## 题目描述

有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\ (L \le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $1\le n \le 50$。

## 样例 #1

### 输入

```
2
10 20
10 15
```

### 输出

```
5```

# 题解

## 作者：樱雪喵 (赞：231)

蒟蒻的第三篇题解，个人认为讲得比较清楚，求赞QwQ~~

废话少说，直接进入正题：

读完题目，我们就应该知道：输出有两种情况，交换次数和 -1.

先考虑输出 -1 （即不能满足题目条件）的情况：

此时有两种可能，总人数（all）大于组数（n）乘上界（r）或小于组数乘下界（l）。代码实现很简单，求出总数再比较,满足条件输出 -1 。

代码如下：

```
for(int i=1;i<=n;i++)
{
    all+=a[i];
}
if(all<n*l||all>n*r)
{
    cout<<"-1";
    return 0;
}
```
然后是满足条件的情况：

用 b 数组存不足下限的组一共缺少的人数，用 c 数组存超过上限的组一共超过的人数。

最简单的方法就是用 c 数组中多出的人数去补 b 数组中缺少的人数，但如果 b,c 不相等呢？

当然要使 b,c 都等于0，所以最少交换次数就是 b,c 中较大的数！这道题就做完了！

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,a[51],b,c,all,l,r,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cin>>l>>r;
    for(int i=1;i<=n;i++)
    {
        all+=a[i];
    }
	if(all<n*l||all>n*r)
	{
		cout<<"-1";
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]<l)
		{
			b+=(l-a[i]);
		}
		if(a[i]>r) c+=(a[i]-r);
	}
	cout<<max(b,c);
    return 0;
}
```
~~大佬勿喷qwq~~

---

## 作者：gravf (赞：22)

首先，我们先判断要不要输出-1
如果总人数大于上限乘组数或小于下限乘组数（数据小，不会炸）
##### 即总人数必须在规定范围内
如果总人数在范围内，就不用输出-1

我们先用一个数组存下每个组的初始人数

那么，只有人数小于下限或大于上限才要调整
所有组多出来的人数和所有组缺的人数分别记成x、y
x、y中更大的那个调到在范围内的组和范围外的组
所以，输出x、y中多的那个就可以了
~~证明有点乱，记住结论就好~~
分享代码
```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

int main()
{
	int a,b;
	int n,sum=0,x=0,y=0;
	int ans[51];
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&ans[i]);
		sum+=ans[i];
	}//输入
	scanf("%d%d",&a,&b);
	if(sum>b*n || sum<a*n)
	{
		printf("-1");
		return 0;//可以停下了
	}
	for(int i=1;i<=n;i++)
	{
		if(ans[i]<a)
		{
			x+=a-ans[i];
		}
		if(ans[i]>b)
		{
			y+=ans[i]-b;
		}
	}
	printf("%d",max(x,y));
	return 0;
}//thanks for your listening
```

---

## 作者：wshim (赞：15)

本题大概思路是这样的，给出组的上限和下限，求每组到这个范围需要移动的次数。
好吧，呈上代码
```cpp
#include<iostream>
using namespace std;
int a[51],l,r,tot,h,q;
int n;
int main()
{
	cin>>n;                        //输入数据
	for(int i=1; i<=n; i++)
		{
			cin>>a[i];             //输入每组的人数
			tot+=a[i];             //计算总人数
		}
	cin>>l>>r;                     //输入组的下限和上限
	if(tot<(l*n)||tot>(r*n))       //若超过或低于范围，直接输出-1
		{
			cout<<-1;
			return 0;
		}
	else                           //若在范围内，就开始移动
		{
			for(int i=1; i<=n; i++)
				{
					if(a[i]>r) h+=a[i]-r; //若高于上限，就开始移动。
					if(a[i]<l) q+=l-a[i]; //若低于下限，也开始移动。
				}
				cout<<max(h,q);      //输出移动的最大值
				return 0;
		}
}//结束   》——《
```
Thanks

---

## 作者：courage (赞：11)

简单的贪心题

首先判断学生个数和是否大于n\*R或者小于n\*L，如果是则输出-1

然后统计超过R的总人数p,小于L的总人数q，输出较大者即可


```cpp

#include<cstdio>
int a[51]={0},n,p=0,q=0,s=0,l,r;
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    scanf("%d%d",&l,&r);
    for (int i=1;i<=n;i++) s+=a[i];
    if (s<l*n || s>r*n){
        printf("-1");
        return 0;
    }
    for (int i=1;i<=n;i++){
        if (a[i]>r) p+=a[i]-r;
        if (a[i]<l) q+=l-a[i];
    }
    printf("%d",p>q?p:q);
}

```

---

## 作者：zhangzhaoke (赞：8)

见注释
```cpp
#include<iostream>
using namespace std;
int main(){
	int n,y,z,k=0,u=0,v=0;//定义 
	cin>>n;//输入 
	int a[n+1];//定义，个人习惯 
	for(int i=0;i<n;i++){cin>>a[i];k+=a[i];}//输入，并用k记录所有数的总和 
	cin>>y>>z;//第三行输入 
	if(k>n*z||k<n*y){cout<<"-1";return 0;}//判断是否越界 
	for(int i=0;i<n;i++){
		if(a[i]<y)u+=y-a[i];//如果小，就让u记录小了多少 
		else if(a[i]>z)v+=a[i]-z;//如果大，就让v记录大了多少 
	}
	cout<<max(v,u);//最关键的一点，较大的数 挪走给较小的数，剩下的可以分配给正常的组，由于总体未超限，所以一定不怕过线 
	return 0;
}
```

---

## 作者：HohleFeuerwerke (赞：5)

#### 前言

乍一看没有读懂题目。

[题目链接](https://www.luogu.com.cn/problem/P1109)

#### 正文

题目题意没有读懂，这里给一个容易读懂一点的抽象化的题意。大概长成这样：

给出一个包含了 $n$ 个数的数列 $a$，你可以进行一种操作，这种操作支持：对于任意的 $i,j∈\{1,2,3,...,n\}$，可以让 $a_i$ 变大为 $a_i+1$，并且 $a_j$ 变小为 $a_j-1$。问的是最多需要多少步操作，才能使对于任意的 $i∈\{1,2,3,4,..,n\}$，都有 $l\leq a_i\leq r$。

这个应该足够容易理解了吧。

---

好了我们继续来看。

那么这题让我们计算最少需要多少步操作，那么我们珂以直接自然的想到，如果我进行 dfs，每次选到的是哪两个下标 $i,j$，直接来判断如果进行了操作是否对结果**有益**。如果有益那么继续搜，如果**有害**那么不进行这一步。每一步搜完都需要判断一下现在是否满足 $l\leq a_i\leq r$，如果满足了就不用搜了，直接返回。而且我们珂以阈值，大概到了 1000 步就不用搜了。

但是思考一下，这样做真的是最优的吗？

显然不是。原因？

是因为，当你进行 dfs 的时候，显然进行了不必要的判断。这道题目只需要求出最少的步数就行了，没有必要再去判断每一步具体如何移动。

那么我们有没有不需要判断如何移动就能够求出移动总步数的方式呢？

显然有。

既然不要对具体的操作进行，那么我们珂以从宏观上来看。

现在，我们记录两个变量：$x$ 和 $y$，

$$
x=\sum_{i=1}^{n}a_i\text{ need to move}
$$

$$
y=\sum_{i=1}^{n}a_i\text{ need to be in}
$$

中文翻译：$x$ 表示每个班级需要移出班级以达到在范围内的人数总和。同样的，$y$ 表示这个班还需要加进来才能达到范围的人数总和。


如果我们计算出了 $x$ 和 $y$，那么就很好办了。我们只需要比较 $x$ 和 $y$ 的大小，并且取其较大者作为答案。

如果取的是较小者，那么会出现的一个问题是：这个序列还没有完全符合题意，如果 $x$ 大而取 $y$ 那么会出现至少有一个班级还是人太多，反之亦然。

然后我们来考虑 `-1` 这个东西的问题。如果输出 `-1` 那么代表我不能进行有限步操作使得我的每一个班级都在范围内。

我尽量使每一个班级都在范围内，那么如果出现全部都取到最大值，然而还有人大于阈值的，显然输出`-1`，同样的反之亦然。

但是这样比较难写进代码，我们继续抽象化的思考这个问题。

如果全部都是最大值，仍然有数大于阈值，那么显然，总人数大于总人数最大值，根据上面讲的，这种情况输出`-1`。反之亦然。（因为是对称的）

我们尝试抽象化为数学表达式：总人数为 $\sum^{n}_{i=1} a_i$，而总人数最大值为 $n\cdot r$，总人数最小值为 $n\cdot l$。

我们甚至还珂以写一个函数表达式来表示结果：

$$
f_a=\begin{cases}-1\text{ ($\sum_{i=1}^n a_i<n\cdot l$ or $\sum^{n}_{i=1}a_i>n\cdot r$)}\\ \max\{x,y\}\text{ ($n\cdot l\leq\sum_{i=1}^n a_i\leq n\cdot r$)}\end{cases}
$$

昂，就是这样。所以我们的程序只需要先计算 $\sum^{n}_{i=1}a_i$，如果它不在范围内，那么直接愉快的输出 `-1`。如果在范围内，那么计算 $x$ 和 $y$，并打印出他们两个中的较大值。

贴代码：
```cpp
#include<bits/stdc++.h>
#define HohleFeuerwerke using namespace std
#pragma GCC optimize(3)
#define MAXN 55
HohleFeuerwerke;
int n;//n个组
int gr[MAXN];//就是上文提到的a数组，这里用了group的缩写gr
int l,r;//上界与下界
int tot;
int away,newin;//这两个就是上文提到的x和y，分别表示总共需要离开班级的，和总共需要进入班级的。
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>gr[i],tot+=gr[i];
	cin>>l>>r;
    //到上面为止都是读入
	if(!((l*n<=tot)&&(r*n>=tot))){cout<<-1<<endl;return 0;}//如果不在范围内，那么直接输出-1然后结束。
	for(int i=1;i<=n;i++){
		if(gr[i]<l) newin+=l-gr[i];//计算y
		if(gr[i]>r) away+=gr[i]-r;//计算x
	}
	cout<<max(newin,away)<<endl;//这个输出较大值，应该很清楚的
	return 0;
}
```

---

## 作者：校门外的树 (赞：4)

**因为只需要计算移动次数，那么计算出每组人数与要求的人数差多少即可。**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,L,R,a[52];
void solve()
{
	int ret = 0, ter = 0;
	for(int i = n-1 ; i >= 0; --i){
		if(a[i] > R)
			ret += a[i] - R;
		else if(a[i] < L)
			ter += L - a[i];
	}
	if(ter > ret)
		ret += ter - ret;
	printf("%d\n",ret);
}

int main()
{
	cin>>n;
	int sum = 0;
	for(int i = 0; i < n; ++i)
		cin>>a[i];
	for(int i = 0; i < n; ++i)
		sum += a[i];
	cin>>L>>R;
	double ret = 1.0*sum/n;
	if(ret < L || ret > R){
		puts("-1");
		return 0;
	}
	solve();
    return 0;
}
```


---

## 作者：幻飞翼 (赞：3)

很简单，只要总学生数的平均值大于r或小于l就不可能有符合题目的情况。

但是平均值不能完全精确，所以原本 if (学生总数/n<l || 学生总数/n>l) 变成 if (学生总数<n\*l || 学生总数>n\*r)
如果符合题目则输出每组超出r的人数之和与每组到l差的人数之和中较大的一个就可以了。

AC代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int a[n];
    int h=0;
    for (int i=0;i<n;i++)
        cin>>a[i],h+=a[i];//算出总人数
    int l,r;
    cin>>l>>r;
    int l1=l*n,r1=r*n;
    if (h>r1 || h<l1)//判断是否符合题意
    {
        cout<<-1;
        return 0;
    }
    int s=0,d=0;
    for (int i=0;i<n;i++)
        if (a[i]<l) s+=l-a[i];//每组到l差的人数之和
        else if (a[i]>r) d+=a[i]-r;//每组超出r的人数之和
    if (s>d) cout<<s;//输出较大值
    else cout<<d;
    return 0;
}

```

---

## 作者：不存在之人 (赞：3)

## 解题思路：
**
这题考的更多是数学方法，然后贪心。本题中直接去管低于下限和高于上限的组即可，只要总学生数的平均值大于r或小于l就不可能有符合题目的情况。**
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int main()
{
	int n,i,s=0,r,l,x=0,y=0,s1;
	int a[51]={};
	scanf("%d",&n);//readline1
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);//readline2
	}
	scanf("%d%d",&l,&r);//readline3
	for(i=1;i<=n;i++)
	{
		s=s+a[i];//累加总人数
		if(a[i]>r)
		x=x+a[i]-r;//累加多于上限的人
		if(a[i]<l)
		y=y+l-a[i];//累加少于上线的人
	}
	if(s<n*l||s>n*r)//n*l和n*r分别是题目所给要求最低能容忍的总人数和最多能承受的总人数
	{
		printf("-1");//总人数的区间小于最低能容忍的总人数和最多能承受的总人数之外就不可能有符合题目的情况
		return 0;//可以结束了
	}
	if(x>y)//比较最少需要移出人数和最少需要移进的人数
	printf("%d",x);
	else
	printf("%d",y);
	return 0;
}
```

---

## 作者：zr太弱了 (赞：2)

>$update$  $2019.12.7$

本题我们要分情况讨论：

$1.\text{输出非-1}$

>事实上，只有每个组的人数超出上界或下界才需要调到另外一组，所以我们需要把组数存下来，一遍扫过去，如果超界则分成两种情况讨论：一种超出上界，一种超出下界，我们可以把多出来的人补到少人的组，但不知道两种情况哪个多，所以max解决就好

$2.\text{输出为-1}$

>如果输出为-1，那么一定是总人数超出了范围，即超过了上限乘组数或下限乘组数，特判即可

其他注释放代码里

```cpp
#include<bits/stdc++.h>
using namespace std;
long long int s[1001];//long long int避免溢出（似乎int就够了）
int qmax(int a,int b){return a>b?a:b;}//手打max
int main()
{
    long long int n,l,r,a=0,b=0,sum=0;//a,b分别为超出上界和超出下界两种情况，sum为累加器
    cin>>n;
    for(int i=1;i<=n;i++) 
	{
		cin>>s[i];
		sum+=s[i];//存储总人数用
	}
    cin>>l>>r;
    for(int i=1;i<=n;i++)
    {
        if(s[i]>r)
			a+=s[i]-r; //判断超出上界
        if(s[i]<l)
			b+=l-s[i]; //判断超出下界
    } 
    if(sum>n*r)//特判输出为-1
		cout<<"-1"<<endl;
    else if(sum<n*l)
    	cout<<"-1"<<endl;
    else
		cout<<qmax(a,b)<<endl;
    return 0;
} 
```


---

## 作者：syh0313 (赞：2)

简单模拟就ac 不需要贪心和排序

```cpp
program p1109;
var
 l,r,i,n,s,k1,k2,x1,x2:longint;
 a:array[1..10000]of longint;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 readln(l,r);
 for i:=1 to n do s:=s+a[i];
 k1:=n*l; k2:=n*r;
 if (s<k1)or(s>k2) then writeln('-1')   判断是不是可以
  else
   begin
    for i:=1 to n do
     if a[i]>r then x1:=x1+a[i]-r;  把大于r的数的超出部分的总和记录
    for i:=1 to n do
     if a[i]<l then x2:=x2+l-a[i];  把小于l的数的低于部分的总和记录
    if x1>x2 then writeln(x1)  比较x1和x2的大小，大的数即为至少移动的次数
     else writeln(x2);
   end;
end.
```

---

## 作者：田字格 (赞：1)

一道很简单的模拟题

```pascal
var group:array[1..50] of longint;//记录每组人数
      i,n,l,r,a,b,max:longint;//a,b记录超过R和小于L的总人数
begin
    readln(n);
    for i:=1 to n do begin read(group[i]);max:=max+group[i];end;//max计算总学生数
    readln(l,r);
    if (max>n*r) or (max<n*l) then begin writeln('-1');halt;end;//不满足条件，就输出’-1‘
    for i:=1 to n do begin
        if group[i]>r then a:=a+group[i]-r;
        if group[i]<l then b:=b+l-group[i];
    end;
    if a>b then writeln(a) else writeln(b);//输出较大者
end.
```

---

## 作者：Lidy (赞：1)

```cpp
//优先数学思维
#include<iostream> 
using namespace std;
int a[55];
int main()
{
    int x=0,s=0,y=0,n,l,r;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    cin>>l>>r;
    for(int i=1;i<=n;i++)
	{   
	    s+=a[i];//累计总人数 
        if(a[i]>r)x+=a[i]-r;//多于上限的人数累计
        if(a[i]<l)y+=l-a[i];//少于下限的人数累计
    }
    if(s<n*l||s>n*r)cout<<"-1";//if so则无解 
    else{
    	int ans=max(x,y);//重点突破，思考为什么取（x，y）的max值 
    	cout<<ans;
	}
    return 0;
}
```

---

## 作者：冲田☀总司 (赞：1)

一道更多的是数学题的题目；只需要保证每组学生人数在上限和下限之间就够了，那么人数在之间的组可以不用理会，直接去管低于下限和高于上限的组就够了

```cpp
#include<cstdio> 
#include<iostream> 
using namespace std;
int main(){
    int d=0,c=0,b=0,i,n,l,r;
    int a[51];
    cin>>n;
    for(i=0;i<n;i++)cin>>a[i];//存储每一组的学生数
    cin>>l>>r;
    for(i=0;i<n;i++){
        if(a[i]>r)b+=a[i]-r;//这里是把某些组多出上限的人数储存起来
        if(a[i]<l)d+=l-a[i];//这里是把某些低于下限的人数储存起来
        c+=a[i];//这里储存学生总数
    }
    if(c<n*l||c>n*r)cout<<"-1";//n*l和n*r分别是题目所给要求最低能容忍的总人数和最多能承受的总人数，如果总人数不在这之间很显然是不可能满足题目要求的
    else if(b>d)cout<<b;//b和d就是比较最少需要移出人数和最少需要移进的人数，哪个大哪个就是答案
    else cout<<d;
    return 0;
}
```

---

## 作者：墨凝而止 (赞：1)


```delphi
var
a,b:array[1..50]of longint;{每组人数｝
c,d,i,k,l,n,r,sum:longint;
begin
  readln(n);
  for i:=1 to n do begin read(a[i]);inc(sum,a[i]);end;｛累计｝
  read(l,r);
  if ((sum/n)>r)or(sum/n<l)｛平均数超出范围｝then begin write(-1);halt;end;
  for i:=1 to n do if a[i]>r then inc(c,a[i]-r) else if a[i]<l then inc(d,l-a[i]);{抽屉原理，解释见下｝
  if c>d then write(c) else write(d);｛比较，若大于的多，则可以填平。若小于得多，则可以抬升｝
end.
```
[color=green]此题之思路，不必过于冗杂，而是从抽屉原理入手。既然ai<l，且平均值在于闭区间[l,r]之内，必定移共l-ai个至其余任意一组，即符合要求。若ai>r,则反之。是为贪心之精髓也。贪者有智，存于精微。

墨凝 执笔[/color]


---


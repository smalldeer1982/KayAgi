# [科大国创杯初中组 2025] 果汁

## 题目背景

Subtask 0 为民间数据，Subtask 1 为官方数据。

## 题目描述

小可可买了美味的果汁，但他太懒了，于是要求奶龙给他倒果汁。

有 $m$ 个水杯，第 $i$ 个水杯容量为 $V_i$。现在有 $n$ 个单位体积的果汁，小可可要求奶龙一共倒 $n$ 次（每次倒一个单位体积，正好倒完），第 $j$ 次倒果汁只能倒进第 $a_j$ 或 $a_j + 1$ 个水杯。具体的，如果第 $a_j$ 和 $a_j + 1$ 两个水杯都不是满的，那么可以任意倒入其中一个；如果有且仅有一个不是满的，那么只能倒入不是满的的那一个；如果都已经被倒满了，那么小奶龙就可以开心地喝掉这一个单位体积的果汁。并且为了方便，小可可会安排小奶龙从左向右倒果汁，也就是说对于所有 $1 \leq j < n$，保证 $a_j \leq a_{j+1}$。

小奶龙想知道自己最多能喝掉单位体积的果汁，你能帮帮他吗？

你一共需要解决 $T$ 组测试数据。

## 说明/提示

### 样例 1 解释

一共倒三次，第一次可以倒进第一个或者第二个水杯，后两次可以倒进第二个或者第三个水杯。第一次倒进第二个水杯，第二次倒进第三个，此时后两个水杯都满了，第三次没法倒，故答案为 $1$。显然没有更优的答案。

### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 2$。
- 对于 $50\%$ 的数据，保证 $n, m \leq 8$。
- 对于另外 $20\%$ 的数据，保证所有 $V_i = 1$。
- 对于另外 $20\%$ 的数据，保证所有 $a_i$ 相同。
- 对于 $100\%$ 的数据，保证 $1 \leq T \leq 50, 1 \leq n \leq 3 \times 10^4, 2 \leq m \leq 3 \times 10^4, 1 \leq a_i < m, 1 \leq V_i \leq n$。且对于所有 $1 \leq i < n, a_i \leq a_{i+1}$。

## 样例 #1

### 输入

```
1
3 3
1 1 1
1 2 2```

### 输出

```
1```

# 题解

## 作者：LittleAcbg (赞：2)

由于是从左往右倒的，那么靠右的杯子满了对小奶龙更加友好（他更有可能喝到果汁）。所以我们进行贪心，每次贪心地倒入编号更大的杯子。如果编号更大的杯子已满，就倒入另一杯。如果两杯都已满，答案就可以加 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4+9;
int t,n,m,v[N],a;
int main()
{
    cin >> t;
    while (t--) // t 组数据
    {
        cin >> n >> m;
        for (int i = 1; i <= m; ++i) cin >> v[i]; // 容量
        int ans = 0;
        while (n--) // 倒 n 次，a[j] 不用存储
        {
            cin >> a;
            if (v[a + 1]) // 编号较大的杯子还能倒，就倒
                --v[a + 1]; // 倒入，剩余容量 -1
            else if (v[a]) // 否则尝试编号较小的杯子
                --v[a];
            else // 两杯均满，喝掉
                ++ans; // 答案 +1
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：rainbow_MMM (赞：2)

## 分析
这题我看了好久，也没看出优化做法。突然，我灵光一现，发现题目里面保证 $a$ 数组单调不降（那不简单多了）。因为数组单调不降，所以只要后面的没满，就到后面，毕竟前面的下次就遍历不到，就浪费了，这不就贪心么。

我们这几种情况讨论：

- $a_{i+1}$ 没有满，倒在 $a_{i+1}$ 里。

- $a_{i+1}$ 满了，倒在 $a_{i}$ 里。

- 都满了，$ans \gets ans + 1$。

## Code
献上考场代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,v[30005],a[30005];
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=m;i++){
			cin>>v[i];
		}for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		int sum=0;
		for(int i=1;i<=n;i++){
      //都满了
			if(v[a[i]]==0&&v[a[i]+1]==0){
				sum++;
      //后面的没满
			}else if(v[a[i]+1]>0){
				v[a[i]+1]--;
			}else{
				v[a[i]]--;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
} 
```

---

## 作者：wrh316 (赞：2)

### 思路
贪心。

我们注意到输入的 $a _ {i}$ 保证单调不降，所以每一次倒果汁：

- 如果两个杯子都能倒，那么倒后面的（因为以后不可能再倒前面的）。
- 如果一个杯子能倒，就倒进去。
- 否则小奶龙就可以开心地喝掉这一个单位体积的果汁啦。

### 赛时代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 3e5 + 10;
int t,n,m;
int v[N],a[N];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>t;
    while(t--){
		cin>>n>>m;
		for(int i = 1;i <= m;i++) cin>>v[i];
		for(int i = 1;i <= n;i++) cin>>a[i];
		int ans = 0;
		for(int i = 1;i <= n;i++){
			if(v[a[i]] && v[a[i] + 1]) v[a[i] + 1]--;
			else if(v[a[i]]) v[a[i]]--;
			else if(v[a[i] + 1]) v[a[i] + 1]--;
			else ans++;
		}
		cout<<ans<<"\n";
	}
    return 0;
}
```

---

## 作者：AFO_Lzx (赞：1)

简单的贪心，因为 $a_i$ 单调不降，所以优先倒后面的杯子，如果都满了就可以喝了，也就是答案 $+1$。

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

const int maxn = 1e6 + 5;
int T, n, m, ans, v[maxn], a[maxn];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> T;
	
	while (T--) {
		cin >> n >> m;
		for (int i = 1; i <= m; i++) cin >> v[i];
		for (int i = 1; i <= n; i++) cin >> a[i];
		ans = 0;
		for (int i = 1; i <= n; i++) {
			if (v[a[i]] > 0 && v[a[i] + 1] > 0) v[a[i] + 1]--;
			else if (v[a[i]] > 0) v[a[i]]--;
			else if (v[a[i] + 1] > 0) v[a[i] + 1]--;
			else ans++;
		}
		cout << ans << '\n';
	}
	
	return 0;
}
```

---

## 作者：liuhaoyan0323 (赞：1)

## 思路

简单贪心，注意到 $a_j \leq a_{j+1}$，显然两个杯子都能装的情况下优先往后面装。不然如果装前面的，下一次可能装不到前面这个瓶子了，显然这一次就浪费了。剩下的按题意直接模拟。

放下考场代码（民间数据已过）：

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N (int)(3E4+5)
using namespace std;
inline void read(int &num);
inline void solve();
int v[N],a[N],now[N];
signed main(){
	//freopen("juice.in","r",stdin);
	//freopen("juice.out","w",stdout);
	int T;
	read(T);
	while(T--){
		solve();
	}
}
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		f=(ch=='-')?-1:1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	num=x*f;
}
inline void solve(){
	int n,m;
	int ans=0;
	read(n);
	read(m);
	memset(v,0,sizeof(v));
	memset(a,0,sizeof(a));
	memset(now,0,sizeof(now));
	for(int i=1;i<=m;++i){
		read(v[i]);
	}
	for(int i=1;i<=n;++i){
		read(a[i]);
	}
	for(int i=1;i<=n;++i){
		if(now[a[i]]>=v[a[i]]){
			if(now[a[i]+1]>=v[a[i]+1])++ans;
			else ++now[a[i]+1];
		}else if(now[a[i]+1]>=v[a[i]+1]){
			if(now[a[i]]>=v[a[i]])++ans;
			else ++now[a[i]];
		}else{
			++now[a[i]+1];
		}
	}
	printf("%lld\n",ans);
}
```

---

## 作者：Wide_Master (赞：0)

## 思路

考虑贪心。

我们读题可知，$a_i$ 单调递增，这可以让我们免去一些复杂的代码。

然后，我们换一个想法，我们把 $V_i$ 看作是还能装下多少单位果汁，然后我们分类讨论三种可能：

1. $V_{a_i},V_{a_i+1}$ 均大于 $0$，那么我们倒后面的，因为后面的不可能再到前面了，这样果汁都会集中在一些杯子里。
2. $V_{a_i}$ 大于 $0$ 但是 $V_{a_i+1}$ 不大于 $0$ 或者 $V_{a_i}$ 不大于 $0$ 但是 $V_{a_i+1}$ 大于 $0$，那么我们倒还能倒的那一杯。
3. $V_{a_i},V_{a_i+1}$ 均不大于 $0$，那么我们可爱的小奶龙就可以开喝了，也就是答案加 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+7;
int T,n,m,v[N],a[N],ans;
int main()
{
	cin>>T;
	while(T--){
		cin>>n>>m;
		for(int i=1;i<=m;i++)
			cin>>v[i];
		for(int i=1;i<=n;i++)
			cin>>a[i];
		ans=0;//记得多测清空
		for(int i=1;i<=n;i++){
			if(v[a[i]]&&v[a[i]+1])v[a[i]+1]--;
			else if(v[a[i]])v[a[i]]--;
			else if(v[a[i]+1])v[a[i]+1]--;
			else ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
``````

---

## 作者：Yeonjun_0913 (赞：0)

#### 思路
简单的贪心，根据题面，可注意到 $a_i < a_{i+1}$，$a_i$ 单调不降，所以，如果在 $a_i$ 与 $a_i+1$ 这两个杯子都能倒的时候，优先选择倒 $a_i+1$ 这个杯子，因为如果倒给 $a_i$ 个杯子，那么在倒后面的杯子时，大概率倒不到它。

#### AC CODE

```cpp
#include <iostream>
using namespace std;

int t;
int n,m,ans;
int v[30005],a[30005];

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> t;
    while (t--){
        ans=0;
        cin >> n >> m;
        for (int i=1;i<=m;i++){
            cin >> v[i];
        }
        for (int i=1;i<=n;i++){
            cin >> a[i];
        }
        for (int i=1;i<=n;i++){
            if (v[a[i]]&&v[a[i]+1]) v[a[i]+1]--;
            else if (v[a[i]]&&!v[a[i]+1]) v[a[i]]--;
            else if (!v[a[i]]&&v[a[i]+1]) v[a[i]+1]--;
            else ans++;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：yanmingqian (赞：0)

贪心。因为 $a_i$ 单调不降，倒给了第 $a_i$ 个之后不一定还能再倒给它，因此容易倒不满，所以第 $a_i+1$ 个能倒的情况下倒给第 $a_i+1$ 个。剩下的就没啥思维含量了，直接模拟即可。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int v[30010],a[30010],t[30010];  //t用于存储已经倒了多少
int main(){
    int T;
    cin>>T;
    while(T--){
        int n,m;
        cin>>n>>m;
        memset(t,0,sizeof t);
        for(int i=1;i<=m;i++){
            cin>>v[i];
        }
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            if(t[a[i]]==v[a[i]]&&t[a[i]+1]==v[a[i]+1]){  //都倒满了
                ans++;  //喝掉
            }
            else if(t[a[i]+1]<v[a[i]+1]){  //第二个没倒满的情况下先倒第二个
                t[a[i]+1]++;
            }
            else{  //第二个倒满了，只能倒给第一个
                t[a[i]]++;
            }
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```

---


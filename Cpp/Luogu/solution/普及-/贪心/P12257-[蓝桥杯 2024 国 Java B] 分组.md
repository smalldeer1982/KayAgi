# [蓝桥杯 2024 国 Java B] 分组

## 题目描述

小明班上有 $n$ 名同学，老师准备按上一次考试的分数对同学们进行分组，第 $i$ 名同学的分数为 $a_i$。老师希望把同学们分为尽可能多的小组，且满足每个小组中的同学分数的最大值至少是最小值的两倍。请问最多能分出多少个小组？如果把所有人分到同一组都不能满足条件则输出 $0$。

## 说明/提示

### 样例说明

其中一种分组方式：第一组 $\{a_4, a_1\} = \{1, 3\}$，第二组 $\{a_3, a_2\} = \{2, 5\}$，第三组 $\{a_6, a_5\} = \{2, 4\}$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，保证 $n \leq 10$。
- 对于 $100\%$ 的评测用例，保证 $1\leq n \leq 10^5$，$0 < a_i \leq 10^8$。

## 样例 #1

### 输入

```
6
3 5 2 1 4 2```

### 输出

```
3```

# 题解

## 作者：mairuisheng (赞：4)

题目：[P12257 [蓝桥杯 2024 国 Java B] 分组](https://www.luogu.com.cn/problem/P12257)

主要算法：贪心，双指针。

分析：

首先，判无解情况：分数中最大值小于分数中最小值的两倍一定不行，输出 `0`，结束程序。

否则用双指针求解：如果每组分两个同学，得到的是最优方案（剩下的同学可以分其他组）。所以先把数组 $a$ 排序，设左指针 $l$ 和右指针 $r$。如果 $a_r\ge a_l\times 2$，标记两个指针的位置，表示这两个同学已经被分组了；否则左指针前移，寻找下一个同学。

注意事项：考虑到最多分 $\frac{2}{n}$ 组，所以 $l$ 的初值为 $\frac{2}{n}$。

以下代码用位运算优化乘除法。

`C++` 代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<bitset>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<48||s>57)
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>47&&s<58)
	{
		x=(x<<3)+(x<<1)+s-48;
		s=getchar();
	}
	return x*f;
}
constexpr int N=1e5+1;
int n;
int a[N];
int maxn,minn=1e8;
bitset<N> vis;
int ans;
int main()
{
	n=read();
	int i;
	for(i=1;i<=n;++i)
	{
		a[i]=read();
		maxn=max(maxn,a[i]);
		minn=min(minn,a[i]);
	}
	if(minn*2>maxn)//特判。
	{
		putchar('0');
		return 0;
	}
	sort(a+1,a+1+n);
	int l=n>>1,r=n;//双指针。
	while(l>0)
	{
		if((a[l]<<1)>a[r])--l;
		else
		{
			++ans;
			vis[l]=true;
			vis[r]=true;
			--l,--r;
			while(r>0&&vis[r])--r;
		}
	}
	printf("%d",ans);
	return 0;
}
```

`Java` 代码：

```java
import java.util.Arrays;
import java.util.BitSet;
import java.util.Scanner;

public class Main
{
    static final int N=100001;
    static int n;
    static int[] a=new int[N];
    static int maxn, minn=(int)1e8;
    static BitSet vis=new BitSet(N);
    static int ans;
    
    public static void main(String[] args)
    {
        Scanner scanner=new Scanner(System.in);
        n=scanner.nextInt();
        
        for(int i=1;i<=n;++i)
        {
            a[i]=scanner.nextInt();
            maxn=Math.max(maxn,a[i]);
            minn=Math.min(minn,a[i]);
        }
        
        if((minn<<1)>maxn)//特判。
        {
            System.out.print(0);
            return;
        }
        
        Arrays.sort(a,1,n+1);
        
        int l=n>>1,r=n;//双指针。
        while(l>0)
        {
            if((a[l]<<1)>a[r])--l;
            else
            {
                ++ans;
                vis.set(l);
                vis.set(r);
                --l;
                --r;
                while(r>0 &&vis.get(r))--r;
            }
        }
        System.out.print(ans);
    }
}
```

---

## 作者：Yeonjun_0913 (赞：4)

#### 温馨提示：这是一篇 c++ 题解，但 java 版可根据思路写或参考楼上楼下。


---


#### 思路
正如题目标签，这道题是一道贪心加双指针的题。为了尽可能多的分组，很容易想到贪心的方法，可以先将数组排序，再寻找可以配对的人。我们可以使用双指针来完成，用一个指针枚举这组中最低分，用另一个指针枚举这组中的最高分，判断是否满足题面中的要求“每个小组中的同学分数的最大值至少是最小值的两倍”，即 $2 \times a_l < a_r$ 其中 $l$ 为最低分的指针，$r$ 为最高分的指针，如果不满足，就让 $l$ 向左一个单位，否则就将两个指针所在位置标记，之后不再使用。
#### AC CODE

```cpp
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;

int n,ans;
int a[100005];
bool vis[100005];

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int maxn,minn=0x3f3f3f3f;
    for (int i=1;i<=n;i++){
        cin >> a[i];
        minn=min(minn,a[i]);
        maxn=max(maxn,a[i]);
    }
    if ((maxn+1)/2<minn){
        cout << 0;
        return 0;
    }
    sort(a+1,a+n+1);
    int l=n/2,r=n;
    while (l>0){
        if (a[l]*2>a[r]){ //不满足条件
            l--; //左指针左移
        }else {
            ans++;
            vis[l]=vis[r]=true; //标记
            l--,r--;
            while (r>0&&vis[r]){ //跳过已标记节点
                r--;
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

# [P12257 [蓝桥杯 2024 国 Java B] 分组](https://www.luogu.com.cn/problem/P12257)
# 题目简介：
将 $n$ 名同学分组，组中最高的分数至少是最低的分数的 $2$ 倍。求最多能分成多少组。
# 分析做法；
**双指针**为最优解。

首先，无解情况：最高值一定大于分数中最低值的两倍，否然输出 $0$。
```cpp
if (a[1] > (a[n] + 1) / 2) {//最高值一定大于分数中最低值的两倍
		cout << 0 << endl;
		return 0;
}
```
接着，如果可行，先排序，然后利用双指针，$l$ 初始点是 $\lfloor n / 2 \rfloor$，$r$ 则是 $n$。

如果 $a_l\times 2 \le a_r$，标记两个指针的位置，表示这两个同学已经被分组了；否则左指针前移，寻找下一个同学。
```cpp
int l = n / 2, r = n, ans = 0;
	while (l > 0) {
		if (a[l] * 2 > a[r]) {//左指针前移，寻找下一个同学。
			l --;
		} else {//
			ans ++;
			vis[l] = vis[r] = true;
			l --, r --;
			while (r > 0 && vis[r]) {标记两个指针的位置，表示这两个同学已经被分组了
				r --;
			}
		}
	}
```
完整无注释代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100010];
bool vis[100010];
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	if (a[1] > (a[n] + 1) / 2) {
		cout << 0 << endl;
		return 0;
	}
	int l = n / 2, r = n, ans = 0;
	while (l > 0) {
		if (a[l] * 2 > a[r]) {
			l --;
		} else {
			ans ++;
			vis[l] = vis[r] = true;
			l --, r --;
			while (r > 0 && vis[r]) {
				r --;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```
谢谢观看，求赞，求过。

---

## 作者：Clare613 (赞：3)

## 思路
正如标签所说，这道题要用到这两个东西：\
![](https://cdn.luogu.com.cn/upload/image_hosting/5f94gon6.png)\
很明显，我们可以想到这样一个贪心策略：能分则分。但是怎么分呢？自然就可以先给数组排个序，然后用双指针来选两个人，作为那一组的最大值和最小值，然后把选了的人标记一下，使得之后不会再选了，而这两个指针都从最末尾开始。\
很快就写完了，但是发现只有 $75$ 分，怎么办呢？很快我们就能想到，最多只能有 $\dfrac{n}{2}$ 组，于是我们把枚举最小值的指针放到 $\dfrac{n}{2}$ 的位置开始找就可以了。
## code:
```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static final long MOD=1000000007;
    static long[] a=new long[100005];
    static boolean[] f=new boolean[100005];
    static long ans;

    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        for(int i=1;i<=n;i++) {
            a[i]=scanner.nextLong();
        }
        Arrays.sort(a,1,n + 1);
        int l1=n/2;
        int l2=n;
        while(l1>=1) {
            if(a[l1]*2>a[l2]){
                l1--;
            }
            else{
                ans++;
                f[l1]=true;
                f[l2]=true;
                l1--;
                l2--;
                while(l2>=1&&f[l2]) {
                    l2--;
                }
            }
        }
        System.out.println(ans);
    }
}    
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12257)

# 解析

## 题目大意

给出一些数，要求分到尽量多的组，使得每个组内的最大值至少是最小值的两倍。

## 考察知识

本题考查双指针运用。

## 思路

我们首先输入并记下这些数中的最大值和最小值，如果最小值乘上二都无法满足小于等于最大值（即大于最大值），那么依照题意直接输出 $0$。

接下来我们从小到大排个序，然后运用双指针，分半，让左指针指向所有数中的中间值，右指针指向最大值，左指针扫描较小区，右指针扫描较大区。

若满足则记录入 $vis$ 数组，$sum$ 加一，并移动右指针；若不满足则移动左指针，使得左指针往更小的数去和右指针指向的较大区的数匹配。

# 代码

`C++` 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
int maxn=-1e8-10,minn=1e8+10,a[N],n,sum=0,vis[N];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		maxn=max(maxn,a[i]);
		minn=min(minn,a[i]);
	}
	if(minn*2>maxn)
	{
		cout<<0;
		return 0;
	}
	sort(a+1,a+1+n);
	int l=n/2,r=n;
	while(l)
	{
		if(a[l]*2>a[r])
		{
			l--;
		}
		else
		{
			sum++;
			vis[l]=true;
			vis[r]=true;
			l--;
			r--;
			while(r&&vis[r])
			{
				r--;
			}
		}
	}
	cout<<sum;
}
```

`Java` 代码

```java
import java.util.Arrays;
import java.util.BitSet;
import java.util.Scanner;
public class Main
{
    static final int N=100001;
    static int n;
    static int[] a=new int[N];
    static int maxn, minn=(int)1e8;
    static BitSet vis=new BitSet(N);
    static int ans;
    public static void main(String[] args)
    {
        Scanner scanner=new Scanner(System.in);
        n=scanner.nextInt();
        for(int i=1;i<=n;i++)
        {
            a[i]=scanner.nextInt();
            maxn=Math.max(maxn,a[i]);
            minn=Math.min(minn,a[i]);
        }
        if((minn<<1)>maxn)
        {
            System.out.print(0);
            return;
        }
        Arrays.sort(a,1,n+1);
        
        int l=n>>1,r=n;//双指针。
        while(l>0)
        {
            if((a[l]<<1)>a[r])--l;
            else
            {
                ++ans;
                vis.set(l);
                vis.set(r);
                l--;
                r--;
                while(r>0 &&vis.get(r))
               {
                    r--;
                }
            }
        }
        System.out.print(ans);
    }
}
```

---

## 作者：GZXUEXUE (赞：1)

### 提示

本篇为 Python 与 C++ 题解，请放心食用。

### 思路

题目中老师希望把同学们分为尽可能多的小组，容易想到贪心。

首先，我们可以推断出，如果每组只分两个同学的话，分成的小组更多。但是由于题目的限制，我们可以尽量让最小的同学更小以达到目的。所以我们可以排序，然后维护双指针 $l$ 和 $r$ 来枚举最小的同学和最大的同学。如果找到了答案的话就标记它，之后不再使用它。

最后，在枚举的过程中记录分组组数，输出即可。

时间复杂度约为 $O(n \log n)$。

### 实现

#### Python

```python
n = int(input())
a = [int(i) for i in input().split(' ')]
a.insert(0,0)
a.sort()
l = n // 2
r = n
group = 0
vis = [False for i in range(n + 5)]
while l > 0:
    if a[l] * 2 > a[r]:
        l -= 1
    else:
       group += 1
       vis[l] = True
       vis[r] = True
       l -= 1
       r -= 1
       while r > 0 and vis[r]:
           r -= 1
print(group)
```

#### C++

这里分享一个小技巧，在调试时可以使用 `cerr` 语句代替 `cout`，即使忘记删调试也是可以不被记录为正常输出的。想要了解更多的话请移步[这里](https://blog.csdn.net/u013686535/article/details/52141708)。

```cpp
# include <algorithm>
# include <iostream>
using namespace std;
int n,group,a[100005]; bool vis[100005];
int main(){
	cin >> n;
	for (int i = 1;i <= n;i++) cin >> a[i];
	int l = n / 2,r = n; sort(a+1,a+n+1);
	while (l){
		if (a[l] * 2 > a[r]) l--;
		else{
			group++,vis[l] = vis[r] = true,l--,r--;
			while (r && vis[r]) r--;
		}
	}cout << group;
	return 0;
}
```

---

## 作者：BeansKing (赞：1)

# P12257

## 题目大意：
给出一串数组，将数组分组，若分完每组最大值大于等于最小值的两倍，那么称这个分组是合法的，问最多分多少组。

## 思路：
用双指针，若不符合条件移动左指针，符合条件则加一组即可。

## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100010],ans,vis[100010];
long long maxn,minn=1e17;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        maxn=max(maxn,a[i]);//最大值
        minn=min(minn,a[i]);//最小值
    }
    sort(a+1,a+n+1);//排序
    if(maxn<2*minn)//特判: 若数组中最大值小于最小值的两倍，说明数组无法分组，直接输出零
    {
        cout<<0;
        return 0;
    }
    //以下为双指针部分
    long long l=n/2,r=n;//初始化
    while(l>=1)
    {
        if(a[r]<a[l]*2)//不符合条件
        {
            l--;//左指针左移
        }
        else
        {
            ans++;//添加组数
            vis[l]=1;
            vis[r]=1;//标记
            l--;
            while(vis[r]==1&&r>0)//移动到第一个没有标记过的位置
            {
                r--;
            }
        }
    }
    cout<<ans;//完结散花
    return 0;
}
```

---

## 作者：ErgouTree (赞：1)

### 题目大意
有 $n$ 个同学的分数 $a_1, a_2, \ldots, a_n$。要求将同学们分为尽可能多的小组，每组至少两人，且每组内最大分数不少于最小分数的两倍。问最多能分多少组。

### 思路
很明显，对于分组，我们需要考虑贪心，能分就分，排序后使用双指针进行配对查找。  

双指针思路如下：  
用两个指针，$p1$ 指向前半部分（较小分数），$p2$ 指向后半部分（较大分数）。
每个人最多只能被分到一组，所以最多能分 $n/2$ 组。  
所以初始时，$p1 = 1，p2 = n/2 + 1。 $   
每次尝试用 $a_{p2}$ 和 $a_{p1}$ 组成一组：   
如果 $a_{p2} \geq 2 \times a_{p1}$，则可以组成一组，两个指针都向后移动；  
否则，$p2$ 向后移动，寻找更大的分数尝试配对。 
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] a = new long[n + 1];
        for (int i = 1; i <= n; i++) a[i] = sc.nextLong();
        Arrays.sort(a, 1, n + 1);
        int p1 = 1, p2 = n / 2 + 1;
        long res = 0;
        while (p1 <= n / 2 && p2 <= n) {
            if (a[p2] >= 2 * a[p1]) {
                res++;
                p1++;
                p2++;
            } else {
                p2++;
            }
        }
        System.out.println(res);
    }
}
```

---

## 作者：mumuxiao20111101 (赞：0)

我有一个二分的做法提供给大家。
### 方法思路
首先将所有同学的分数进行升序排序，以便后续处理。

使用二分查找来确定最多可以分成的组数。具体来说，我们需要找到最大的组数 $m$，使得前 $m$ 个元素和后 $m$ 个元素满足每个后元素至少是前元素的两倍。对于每个可能的组数 $m$，检查前 $m$ 个元素和后 $m$ 个元素是否满足条件。如果满足，则尝试更大的组数，否则，减少组数。
### 解决代码：
```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        long[] a = new long[n + 1];
        
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextLong();
        }
        
        Arrays.sort(a, 1, n + 1);
        
        int l = 0, r = n / 2;
        int ans = 0;
        
        while (l <= r) {
            int mid = (l + r) / 2;
            boolean flag = true;
            
            for (int i = 1; i <= mid; i++) {
                if (a[n - mid + i] < 2 * a[i]) {
                    flag = false;
                    break;
                }
            }
            
            if (flag) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        
        System.out.println(ans);
    }
}
``````

---


# [蓝桥杯 2024 国 Python B] 球衣号码

## 题目描述

在篮球之都，有一支传奇的篮球队，名为“坤之队”。这支球队由 $n$ 位才华横溢的球员组成，编号分别为 $1, 2, \ldots, n$。

今年，坤之队共参加了 $m$ 场激烈的比赛。在每场比赛前，坤之队的教练阿坤都会举行一个出征仪式。他会指定其中一名球员为队长，并将其球衣的号码设为 $0$。同时，为了保持队员之间的秩序和团结，教练还会对其他球员的球衣号码进行调整。具体来说，站在队长右边的每个球员的球衣号码将比他左边球员的球衣号码大 $1$，而站在队长左边的每个球员的球衣号码将比他右边球员的球衣号码大 $1$。球队中可能会有相同的球衣号码。

举个例子，假设坤之队有 $n = 5$ 名球员，阿坤在一场比赛前指定编号为 $3$ 的球员为队长，那么球员们球衣的号码就会变为 $[2, 1, 0, 1, 2]$。

经过 $m$ 轮比赛的激烈角逐后，阿坤希望你能帮助他确定，每个球员所拥有过的最大球衣号码是多少。

## 说明/提示

### 样例说明

- 在第一场比赛的出征仪式中，阿坤指定了编号为 1 的球员为队长。此时球员们的球衣号码为：
$$[0,1,2,3,4,5]$$
- 在第二场比赛的出征仪式中，阿坤指定了编号为 3 的球员为队长。此时球员们的球衣号码为：
$$[2,1,0,1,2,3]$$
- 因此，每个球员所拥有过的最大球衣号码为：
$$[2,1,2,3,4,5]$$

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq m \leq n \leq 100$，$1 \leq p_i \leq n$，$p_1, p_2, \ldots, p_m$ 各不相同。
- 对于 $50\%$ 的评测用例，$1 \leq m \leq n \leq 10^3$，$1 \leq p_i \leq n$，$p_1, p_2, \ldots, p_m$ 各不相同。
- 对于所有评测用例，$1 \leq m \leq n \leq 10^5$，$1 \leq p_i \leq n$，$p_1, p_2, \ldots, p_m$ 各不相同。

## 样例 #1

### 输入

```
6 2
1 3```

### 输出

```
2 1 2 3 4 5```

# 题解

## 作者：chen_kun (赞：2)

# 题解：坤之队的球衣号码

## 题目描述
在篮球之都，有一支由 $n$ 位球员组成的“坤之队”。他们参加了 $m$ 场比赛，每场比赛前教练会指定一名队长，并将队长的球衣号码设为 0。其他球员的球衣号码根据与队长的位置关系调整：队长右边的球员号码依次比左边大 1，左边的依次比右边大 1。经过 $m$ 场比赛后，求每个球员在所有比赛中穿过的最大球衣号码。

## 输入格式
- 第一行：两个整数 $n$ 和 $m$，表示球员数量和比赛场数。
- 第二行：$m$ 个整数，表示每场比赛的队长编号。

## 输出格式
- 一行 $n$ 个整数，表示每个球员在所有比赛中的最大球衣号码。

## 解题思路
1. **球衣号码规律**：对于队长编号 $p$，球员 $i$ 的球衣号码为 $|i - p|$。
2. **最大号码**：对于每个球员 $i$，队长为 $j$ 时，其最大球衣号码是所有比赛中 $|i - p_j|$ 的最大值。
3. **优化**：可以通过观察发现，最大球衣号码只与所有队长编号的最小值 $mmin$ 和最大值 $mmax$ 有关。因此，对于每个 $i$，其最大球衣号码为 $max(|i-mmin|,|i-mmax|)$。
## 代码实现


```python
import sys

def main():
    # 读取 n 和 m
    n, m = map(int, sys.stdin.readline().split())
    # 初始化最大值和最小值
    mmax = -float('inf')
    mmin = float('inf')
    # 读取 m 个队长编号，更新最大值和最小值
    t_list = list(map(int, sys.stdin.readline().split()))
    for t in t_list:
        mmax = max(mmax, t)  # 取最大值
        mmin = min(mmin, t)  # 取最小值
    
    # 根据前面推理得出的公式输出答案
    for i in range(1, n + 1):
        print(max(abs(i - mmin), abs(i - mmax)), end=" ")

if __name__ == "__main__":
    main()
```


## The end.

---

## 作者：CCY20130127 (赞：2)

## 题目大意：
[球衣号码](https://www.luogu.com.cn/problem/P12268)

站在队长右边的每个球员的球衣号码将比他左边球员的球衣号码大 $1$，而站在队长左边的每个球员的球衣号码将比他右边球员的球衣号码大 $1$。球队中可能会有相同的球衣号码。

上方为题目的意思。

## 题目思路：
如果你想将 $n$ 位球员，$m$ 场比赛全部遍历一顿，那你就会超时，时间复杂度为 $O(n \times m)$。

这时，我们就想到了一种简便的方法。对于队长编号 $p$，球员 $i$ 的球衣号码为 $i$ 减去 $p$ 的绝对值。

观察发现，球员 $i$ 的球衣号码只和队长编号的最小值和最大值有关，其他都没用。则球员 $i$ 的最大球衣号码为每个队员与队长编号的最大值和队长编号的最小值的距离中取最大值，时间复杂度为 $O(n+m)$。

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int m,n,a,maxn=INT_MIN,minn=INT_MAX;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a;
		maxn=max(maxn,a);
		minn=min(minn,a);
	}
	for(int i=1;i<=n;i++){
		int k=max(abs(i-maxn),abs(i-minn));
		cout<<k<<" ";
	}
	return 0;
}
```

---

## 作者：TODAYS (赞：2)

## 题目大意

### [题目传送门](https://www.luogu.com.cn/problem/P12268)

有 $m$ 场比赛，$n$ 名球员，在每一场比赛 $i$，教练都会选出一个队员担任队长，队长的球衣编号为 $0$，而队员的编号是根据与队长之间的距离来分球衣编号，队长右手边的球员的球衣编号比队长的球衣编号大 $1$，队长左手边的球员的球衣编号比队长的球衣编号大 $1$。问：每个球员所拥有过的最大球衣号码是多少。

## 题目思路

其实我根据样例就可以发现，每个球员的球衣编号是由离队长的距离来定的，举个例子：
有 $6$ 名球员，队长的编号为 $3$

$$
[2,1,0,1,2,3]=[3-1,3-2,0,4-3,5-3,6-3]
$$

那么每个编号为 $i$ 的球员的球衣编号就为**队长标号减去 $i$ 的绝对值**，那么我们就可记录 $p_i$ 的最大值与最小值，根据公式算出队员 $i$ 的球衣标号（详见代码）。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int p[N], a[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, m;
    cin >> n >> m;
    int distance_max = INT_MIN, distance_min = INT_MAX;
    for (int i = 1; i <= m; ++i)
    {
        cin >> p[i];
        distance_min = min(distance_min, p[i]);
        distance_max = max(distance_max, p[i]);
    }
    for (int i = 1; i <= n; ++i)
    {
        a[i] = max(abs(i - distance_min), abs(distance_max - i));
        // 因为队长球衣标号越大或越小，对与左边与右边的球员都有利
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << a[i] << ' ';
    }
    return 0;
}
```

#### [AC 记录](https://www.luogu.com.cn/record/214639762)

---

## 作者：weifengzhaomi (赞：2)

~~我又双叒来发题解了，哈哈。~~

## 题意

现在有 $n$ 个球员，进行了 $m$ 场比赛。

接下来，有 $m$ 个数，表示每场比赛的队长的编号。

## 思路 1.0 暴力

很明显，我们可以对于每一个 $n$，可以 $m$ 场都求一遍最大值，这也是最容易想到的方法。

~~喜提 TLE。~~

## 思路 2.0 求最大、最小值

上面的思路如果直接交上去的话，会超时，所以我们要想一种快一点的算法。

观察样例可得知，每个最大值取决于最靠左和最靠右的队长，那么，我们可以在输入时算，最靠左的编号和最靠右的编号，然后就取一个最大值就好了。

时间复杂度 $O(n + m)$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,cnt,x;
int main(){
	scanf("%d%d",&n,&m);
	ans = INT_MAX;
	for (int i = 1;i <= m;i++){
		scanf("%d",&x);
		ans = min(ans,x);
		cnt = max(cnt,x);
	}
	for (int i = 1;i <= n;i++)
		printf("%d ",max(abs(i - ans),abs(i - cnt)));
}
```
## 后记

这次这道题暴力跑不出来，所以我们观察想到了每一个球员最大编号取决于最靠左和最靠右的队长，所以我们可以对于每一个 p[i] 都去一个最小值和最大值。

这样每一次我们都只考虑了一遍，这道题告诉了我们，有些时候，我们可以观察事物的规律，来得到启发。

本篇题解完。

---

## 作者：Planet_Earth (赞：1)

## 题解：P12268 [蓝桥杯 2024 国 Python B] 球衣号码

### [题目传送门](https://www.luogu.com.cn/problem/P12268)

摆上我的 [AC 记录](https://www.luogu.com.cn/record/214643727)
### 题目简述

给定 $n$ 名球员和 $m$ 场比赛，每场指定队长，其余球员号码依位置增减，求各球员最大号码。

### 思路分析

首先把队长位置按顺序存储并排序。

接着进行二分查找找到离每个球员最近的队长。同时，需要记录最左和最右队长的位置。

然后比较球员到这两个队长以及中间最近队长的距离，就能确定这个球员的最大球衣号码。

### 代码


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar_unlocked();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar_unlocked();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar_unlocked();
	}
	return x*f;
}
void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
signed main(){
	int n=read(),m=read();
	vector<int> cap(m);
	for(int i=0;i<m;++i){cin>>cap[i];cap[i]--;}
	if(m==0){
		for(int i=0;i<n;i++){
			printf("0 ");
		}
		return 0;
	}
	sort(cap.begin(),cap.end());
	int l=cap.front(),r=cap.back();
	vector<int>mx(n,0);
	for(int i=0;i<n;i++){
		int d1=i-l,d2=r-i;
		int md=max(d1,d2);
		auto it=lower_bound(cap.begin(),cap.end(),i);
		if(it!=cap.end()){
			int rc=*it;
			md=max(md,rc-i);
		}
		if(it!=cap.begin()){
			int lc=*prev(it);
			md=max(md,i-lc);
		}
		mx[i]=md;
	}
	for(int i=0;i<n;i++){
		write(mx[i]);
		printf(" ");
	}
	return 0;
}    
//Planet_earth
```

---

## 作者：ArenaBreakout78 (赞：1)

## 题意：

简单概括一下题意，也就是从 $n$ 个球员中，选一个球员当队长，编号为零，然后站在队长右边的每个球员的球衣号码将比他左边球员的球衣号码大 $1$，而站在队长左边的每个球员的球衣号码将比他右边球员的球衣号码大 $1$，这个操作需要进行 $m$ 次。

接着，我们便进入正题。

## 方法一（暴力 60pts）：

看到题目，我第一个想到的方法便是暴力（没看数据范围），于是便用了双重循环直接枚举了一遍，代码如下，具体看注释。

## 60pts Code:

```cpp
#include <bits/stdc++.h>//万能头好习惯
using namespace std;
int n,m,maxn[100005];//数组用来存最大值1
int main (){
    ios::sync_with_stdio(0);//可以让输入输出更快，没加就是55pts
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int a;
        cin>>a;
        int l=1;//计数
        for(int j=a+1;j<=n;j++){
            if(maxn[j]<l) maxn[j]=l;//如果maxn[j]比l更大，那么就将l存进maxn[j]中
            l++;//每往右一个就多加一个1
        }
        l=1;
        for(int j=a-1;j>=1;j--){
            if(maxn[j]<l) maxn[j]=l;//同上一个循环
            l++;//每往左一个就多加一个1
        }
    }
    for(int i=1;i<=n;i++){
        cout<<maxn[i]<<' ';//输出
    }
    return 0;//完美结束？
}
```

但是只拿了 60pts，为什么呢？

> - 对于所有评测用例，$1 \leq m \leq n \leq 10^5$，$1 \leq p_i \leq n$，$p_1, p_2, \ldots, p_m$ 各不相同。

而我们的暴力程序时间复杂度为 $O(n \times m)$，很明显无法通过这道题，于是我们只好换一种方法了。

## 方法二（贪心正解 100pts）：

通过仔细地观察样例，我们不难发现每个队员的号码与他和队长的距离有关。于是，我们可以用一个 $p$ 数组存下每一次指定的队长编号，然后再从中找出一个最大值 $maxx$ 和一个最小值 $minn$，再从每个队员与两者的距离中取最大值存进数组 $maxn$ 中，而数组 $maxn$ 中的就是最终答案了。

```cpp
#include <bits/stdc++.h>//万能头好习惯
using namespace std;
int n,m,minn=1000001,maxx,maxn[100005],p[100005];//maxn数组用来存每个队员和队长距离的最大值，p数组用来存队长编号。
int main (){
    ios::sync_with_stdio(0);//可以让输入输出更快，这里可以不加
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>p[i];
        minn=min(minn,p[i]);//求最大值maxx
        maxx=max(maxx,p[i]);//求最小值minn
    }
    for(int i=1;i<=n;i++)
        ans[i]=max(abs(i-minn),abs(i-maxn));//求每个队员和队长距离的最大值
    for(int i=1;i<=n;i++){
        cout<<ans[i]<<' ';//输出
    }
    return 0;//完美结束!
}
```

最后，真心希望我的第二篇题解能够通过，完结撒花。

---

## 作者：swate114514 (赞：1)

## 暴力
读完题，很容易想到这道题的解法：从队长的下标出发，向左和向右分别遍历。
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
	int n, m;
	cin >> n >> m;
	
	vector<int> a(n, -1);
	
	while (m--) {
		int x;
		cin >> x;
		
		int cnt = 0;
		for (int i = x - 1; i < n; i++) {
			a[i] = max(a[i], cnt);
			cnt++;
		}

        cnt = 1;
        for (int i = x - 2; i >= 0; i--) {
            a[i] = max(a[i], cnt);
			cnt++;
        }
	}
	
	for (auto it : a) cout << it << ' ';
	
	return 0;
}
```
## 优化
很明显暴力 TLE 了……
让我们仔细思考一下：对于每个球员 $i$，球衣号码是根据与队长的相对位置来决定的。给定队长的位置，球员 $i$ 的球衣号码可以表示为：

$$\text{val} = \max(i - a_1, a_k - i)$$

其中，$a_1$ 和 $a_k$ 分别是所有比赛中队长位置的最小值和最大值。

这里的公式表示，球员 $i$ 与队长最远的距离，即队长在最左侧的 $a_1$ 或最右侧的 $a_k$ 的情况下，球员 $i$ 与队长的距离最大。

## Code
1. c++ 代码。
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	// 读取球员数和队长数
	int n, m;
	cin >> n >> m;
	
	// 存储队长的位置，自动去重
	unordered_set<int> s;
	
	// 读取队长的位置
	for (int i = 0; i < m; ++i) {
		int p;
		cin >> p;
		s.insert(p);
	}
	
	// 将队长的位置存入vector并排序
	vector<int> p2(s.begin(), s.end());
	sort(p2.begin(), p2.end());
	
	// 获取队长位置中的最小值和最大值
	int a1 = p2[0];
	int ak = p2.back();
	
	// 计算每个球员的最大球衣号码
	for (int i = 1; i <= n; ++i) {
		int val = max(i - a1, ak - i); // 计算当前球员的最大球衣号码
		cout << val << ' '; // 输出，最后一个球员后换行
	}
	
	return 0;
}
```
2. Python 代码。
```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    # 读取球员数和队长数
    n = int(data[0])
    m = int(data[1])
    
    # 存储队长的位置，自动去重
    s = set()
    
    # 读取队长的位置
    index = 2
    for _ in range(m):
        p = int(data[index])
        s.add(p)
        index += 1
    
    # 将队长的位置存入列表并排序
    p2 = sorted(s)
    
    # 获取队长位置中的最小值和最大值
    a1 = p2[0]
    ak = p2[-1]
    
    # 计算每个球员的最大球衣号码
    result = []
    for i in range(1, n + 1):
        val = max(i - a1, ak - i)  # 计算当前球员的最大球衣号码
        result.append(str(val))
    
    print(' '.join(result))

if __name__ == "__main__":
    main()
```

---

## 作者：yanmingqian (赞：0)

贪心。

每个球员的号码就是与队长的距离，贪心考虑，当队长距离取得最大或者最小时，队员与队长的距离最大，所以记录一下队长编号的最大最小值，最后统计一下每个球员距离最大时是多少即可。

```cpp
#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int maxx=0,minn=1e5;
    for(int i=1;i<=m;i++){
        int x;
        cin>>x;
        maxx=max(maxx,x);
        minn=min(minn,x);
    }
    for(int i=1;i<=n;i++){
        cout<<max(abs(i-minn),abs(i-maxx))<<" ";
    }
    return 0;
}
```

```py
n, m = map(int, input().split())

x = []
while len(x) < m:
    x += list(map(int, input().split()))
x = x[:m]
maxx = max(x)
minn = min(x)

result = [str(max(abs(i - minn), abs(i - maxx))) for i in range(1, n + 1)]
print(' '.join(result))

```

---

## 作者：Yeonjun_0913 (赞：0)

#### 温馨提示，此题解有 c++ 版与 python 版。


---

#### 思路
观察样例，我们可以简单的得到每个队员的号码与他和队长的距离有关。所以，我们可以从 $p$ 数组中找出一个最大值和一个最小值，再从每个队员与两者的距离中取最大值即为答案。

#### AC CODE
c++ 版

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int n,m;
int minn=0x3f3f3f3f,maxn;
int p[100005];
int ans[100005];

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i=1;i<=m;i++){
        cin >> p[i];
        minn=min(minn,p[i]);
        maxn=max(maxn,p[i]);
    }
    for (int i=1;i<=n;i++){
        ans[i]=max(abs(i-minn),abs(i-maxn));
    }
    for (int i=1;i<=n;i++){
        cout << ans[i] << ' ';
    }
    return 0;
}
```


---

python 版

```python
n,m=map(int,input().split())
arr=list(map(int,input().split()))
minn=float('inf')
maxn=float('-inf')
for num in arr:
    maxn=max(num, maxn)
    minn=min(num, minn)
for i in range(1, n + 1):
    tmp=max(abs(i-minn),abs(i-maxn))
    print(tmp,end=" ")
```

---


# [蓝桥杯 2024 国 Python A] 床底取牌

## 题目背景

原题题面存在歧义，洛谷题面明确了是**一定能**凑齐六张卡牌最少从床底下取出多少张卡牌。

## 题目描述

最近，小蓝对拼单词的游戏特别着迷。他有一盒专门用于拼单词的字母卡片，其中每张卡片上分别印有 $\tt l$、$\tt a$、$\tt n$、$\tt q$、$\tt i$、$\tt o$ 中的一个字母，并且每种字母对应的卡牌都有 $5$ 张。

小蓝给自己设定了一个目标，即拼出单词 $\tt{lanqiao}$。对此，他需要 $2$ 张 $\tt a$ 以及 $\tt l$、$\tt n$、$\tt q$、$\tt i$、$\tt o$ 各 $1$ 张。

然而，很不幸的是，小蓝在玩耍时不小心把卡片盒打翻了，所有的卡片一下子都掉进了床底下。因为床底下光线非常暗，小蓝根本无法看清卡片上的字母。

那么请问，要想**一定能**凑齐 $\tt l$、$\tt a$、$\tt n$、$\tt q$、$\tt i$、$\tt a$、$\tt o$ 这 $6$ 张卡牌，小蓝最少需要从床底下取出几张卡牌呢？


# 题解

## 作者：MingDynasty (赞：10)

[题目链接](https://www.luogu.com.cn/problem/P12277)

小学生的奥数。

## 题目思路：

本题实际上很简单。我们发现，最坏情况就是把卡片全取出来，但实际上有一些卡片我们用不上。我们从题目中了解到，$a$ 只用了 2 张，有 3 张没有用上。所以说，凑成 $\tt{lanqiao}$ 最少所用的卡片就是总卡片数量 $-$ 没有用到的卡片数量，最终答案是 27。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<27;
}
```

祝通过本题！

---

## 作者：chenyuan3 (赞：8)

### 思路

鸽巢原理。这是六下的数学广角知识。刚好可以写一篇题解复习。

考虑最坏情况，即取到了 $\texttt{lnqio}$ 各 $5$ 张，$\texttt a$ 两张。显然没有比这更坏的结果了。总计 $5 \times 5 + 2 = 27$ 张。

### 代码

``` py
print(27)
# 加一行注释防止代码过短
```

---

## 作者：Planet_Earth (赞：2)

## 题解：P12277 [蓝桥杯 2024 国 Python A] 床底取牌
### [题目传送门](https://www.luogu.com.cn/problem/P12277)

摆上我的 [AC 记录](https://www.luogu.com.cn/record/214667954)，~~我又来划水了~~
### 题目简述

小蓝需凑齐拼 `lanqiao` 的卡牌，求最坏情况下最少取牌数。

### 思路分析

若某字母牌数少于 $5$ 张，就需要考虑取牌时的实际数量。将其他字母的牌全取完（每字母最多取 $5$ 张），再加上当前字母的所有牌，最后 $+1$ 确保必然取到所有字母。

数学表达为：设共有 $n$ 种字母，其中某字母 $x$ 的牌数为 $m$（$m<5$），其余 $n−1$ 种字母的牌数均$≥5$，则最少取牌数为 $(n−1)⋅5+m+1$

### 代码


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    printf("27");
}
//Planet_Earth
```

---

## 作者：DemonPlayer (赞：2)

### 思路：
考虑最坏情况，假设已经抽完了所有除 $\texttt{a}$ 以外的卡牌那么现在共抽了 $5\times5=25$ 张卡牌，那么还需要 $2$ 张 $\texttt{a}$ 的卡牌，由于其他的卡牌已经抽完，不管怎么抽都会抽到 $\texttt{a}$。所以至少要抽 $25+2=27$ 张卡牌。

---

## 作者：yangduan_ (赞：2)

## 思路
显然，由于每种牌都有五张，最坏情况则是某一种牌拿指定数目，其他种类全拿完。而某一种牌的需求最大为 $2$，所以可得答案为 $27$。输出即可。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	cout<<27;
	return 0;
}

```

---

## 作者：ZSYhaouuan (赞：1)

一眼就是[抽屉原理](https://oi.wiki/math/combinatorics/drawer-principle/)，会这个理解会更快点。

---

其实可以考虑最差的情况，即把其它所有字母的五张牌都取遍了，那么再取一张牌就一定是把所有的字母取完了的。按照这个思路，那么最少只用取 $5\times 5+1=26$ 张牌即可。

真的是这样吗？

可以发现字母 $\tt a$ 的牌一共有两张，我们就可以想到：万一我们把除 $\tt a$ 外所有牌都取了，再取一张牌也不够。因此，真正答案还要加一。

直接输出答案即可，代码如下：

```python
print(27) # 输出答案
```

---

## 作者：ssxzhang (赞：1)

简单的最不利原则，因为 $a$ 要取的个数是较多的所以放在最后取,先把其余 5 个选完是 $5 \times 5 = 25$，再加上最后选的两个，得出结果 27。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    cout<<5*5+2;
    return 0;
}
```

---

## 作者：yanmingqian (赞：0)

手算，鸽笼原理。

考虑我们运气特别不好，只差一张牌就能集齐。这时候如果别的牌全部拿完了，下一张必然是我们要的牌，因此下一次一定能集齐。像这样说得最不幸的时候，我们应该除了牌 $\tt{a}$ 都集齐且全部拿完了，而牌 $\tt{a}$ 还差一张，此时我们手上有 $5\times5+1=26$ 张牌，再拿一张正好集齐，所以答案是 $27$，直接输出即可。

代码不放了，就一行输出。

---


# [蓝桥杯 2025 省 B/Python B 第二场] 破解信息

## 题目描述

在遥远的未来，星际旅行已经成为常态。宇航员小蓝在一次探险任务中，意外发现了一个古老的太空遗迹。遗迹中存放着一个数据存储器，里面记录着一段加密的信息。经过初步分析，小蓝发现这段信息可以被表示为一个字符串 $S$，而解密的关键，在于找出 $S$ 中字典序最大的回文子序列。

- **子序列**：指从原字符串中抽取若干个字符（可以不连续），按照它们在原字符串中的相对顺序排列所形成的新序列。例如，对于字符串 `abc`，其子序列包括 `a`、`b`、`c`、`ab`、`ac`、`bc` 和 `abc`。
- **字典序**：指字符串按照字典中的排序规则比较大小的方式。对于两个字符串，从左到右逐字符比较，先出现较大字符的字符串字典序更大；若比较到某个字符串结束仍未找到不同的字符，则较短的字符串字典序较小。例如，`abc` < `abd`，而 `ab` < `abc`。

现在，请你从字符串 $S$ 中，找出字典序最大的回文子序列，帮助小蓝解开这段来自星际文明的信息。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq |S| \leq 300$，其中 $|S|$ 表示字符串 $S$ 的长度；
- 对于所有评测用例，$1 \leq |S| \leq 10^5$，$S$ 中只包含小写英文字母。

## 样例 #1

### 输入

```
abcd```

### 输出

```
d```

## 样例 #2

### 输入

```
abab```

### 输出

```
bb```

# 题解

## 作者：yulinOvO (赞：5)

本题第一篇题解。
### 题意：
我们需要在给定字符串 $S$ 中找出字典序最大的回文子序列。
### 思路：
找出字符串中最大的字符，并统计其出现次数，如果该字符出现 $k$ 次，则直接返回 $k$ 个该字符，因为这是字典序最大的回文子序列。
### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    cin >> s;
    char ans=*max_element(s.begin(),s.end());//字典序最大字符 
    // 统计该字符的出现次数
    int cnt=0;
    for(char c:s) if(c==ans) cnt++;
    cout << string(cnt,ans);
    return 0;
}
```

---

## 作者：weifengzhaomi (赞：4)

## 题意 & 化简

现在有一串字符，要找到字典序最大的**子串字符（可以是不同的子串）**，并输出。

## 思路

这道题其实很简单，我们来看一下字典序的性质。

字典序：指字符串按照字典中的排序规则比较大小的方式。对于两个字符串，从左到右逐字符比较，先出现较大字符的字符串字典序更大；若比较到某个字符串结束仍未找到不同的字符，则较短的字符串字典序较小。

稍微转化一下，题目就变成了:

求出最大的字符，有多少个就是多少个。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100010],ch;
int l;
int main(){
	scanf("%s",s + 1);
	l = strlen(s + 1);
	for (int i = 1;i <= l;i++) ch = max(ch,s[i]);
	for (int i = 1;i <= l;i++)
		if (s[i] == ch) printf("%c",ch);
}
```

---

## 作者：Clare613 (赞：2)

## 思路
找到字典序最大的字符，找一下字符串中有多少个这样的字符，输出这些字符就是该字符串字典序最大的回文串，因为其他的回文串字典序到中心时就绝对比输出的字符串字典序小。

```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;

int main(){
    cin.tie(0)->sync_with_stdio(0);
    char x[100005];
    cin>>x;
    int n=strlen(x);
    sort(x,x+n);
    int i=n-2;
    cout<<x[n-1];
    while(i>=0&&x[i]==x[i+1]){
		cout<<x[i];
		i--;
	}
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：1)

## 思路

看到这道题，以为又要爆搜，看标签怎么是贪心？\
当然贪心是正解啦，那是怎么个贪心法呢？\
由于我们需要字典序最大的回文子串，因此我们选择整个字符串内字典序最大的字符，原串内有多少个就输出多少个即可。\
如何证明呢？首先证明回文，只有一种字符，所以绝对是回文字符串。\
接着证明字典序最大，设我们求出的答案是 $S'$，运用反证法，我们假设有一个字典序更大的回文子串 $S''$，根据字典序的定义，需要保证两点满足其一：

1. $S''$ 中至少有一个字符比 $S'$ 中任意一个字符大。\
   证明该命题错误：由于 $S'$ 是由原串中所有最大字符构成的，因此原串 $S$ 中不存在任何比其最大字符更大的字符。
2. $|S''| > |S'|$，且 $S''$ 的前 $|S'|$ 个字符与 $S'$ 一致。\
   证明该命题错误：为保证构成回文，$S''$ 接下来的字符应都为 $S$ 中的最大字符，而 $S'$ 已经包揽所有原串中的最大字符，不可能再出现多余的。

故 $S''$ 不存在，原命题得证。

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main(){
	string s;
	cin >> s;
	
	map<char, int> m; //记录每个字符出现的次数
	char ma = 0; //原串最大字符
	for(int i = 0; i < s.size(); ++i)
		m[s[i]]++, ma = max(s[i], ma);
    cout << string(m[ma], ma);
	return 0;
}
```

---

## 作者：SRQ_321 (赞：1)

题目要求我们选出最大的回文子序列。
易得出结论：选最大字符，这样不仅保证回文，还保证肯定比其它的回文子序列大。

遍历一遍数组，记录最大字符和出现次数，最后输出出现次数个最大字符即可。

```cpp
include<bits/stdc++.h>
using namespace std;
string s;
char c;
int t;
int main(){
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(s[i]>c){
            t=1;
            c=s[i];
        }else if(s[i]==c){
            t++;
        }
    }
    for(int i=0;i<t;i++){
        cout<<c;
    }
    return 0;
}
```

---


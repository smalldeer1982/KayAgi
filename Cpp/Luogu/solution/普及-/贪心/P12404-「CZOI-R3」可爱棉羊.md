# 「CZOI-R3」可爱棉羊

## 题目描述

农夫有 $N$ 只小棉羊，它们被关在**一排连续**的 $N$ 个羊圈里。

有一天，有 $x$ 只不同的小棉羊生病了。每天晚上，每只已被感染的小棉羊，就会随机感染**与它相邻的一只**小棉羊。而且同一只小棉羊有可能会被多次传染。

第 $i$ 只小棉羊只与第 $i-1$ 和第 $i+1$ 只小棉羊相邻。特别的，第 $1$ 只小棉羊相邻的小棉羊只有 $2$，第 $N$ 只小棉羊相邻的小棉羊只有 $N-1$。

在过了 $T$ 天后（即 $T$ 轮传染后），农夫才发现这件事。他十分着急，迫切地想要知道：对于所有可能的情况，现在被传染的的小棉羊的数量的**最大值**和**最小值**分别是多少。

## 说明/提示

**【样例解释 #1】**

在第一轮传染后，$2$ 只小棉羊都会被传染，所以被传染的小棉羊的数量的**最大值**和**最小值**均为 $2$。

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$20\text{ pts}$）：$N,T \le 20$。
- Subtask #2（$20\text{ pts}$）：$N \le 20$。
- Subtask #3（$20\text{ pts}$）：$x=1$。
- Subtask #4（$40\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$2\le N,T\le10^9$，$1\le x\le N$。

## 样例 #1

### 输入

```
2 3 1```

### 输出

```
2 2```

## 样例 #2

### 输入

```
7 2 3```

### 输出

```
7 3```

# 题解

## 作者：Little_Deer_Peach (赞：5)

题意已经很简洁了不再赘述。

思路：

考虑最多时，先假设有无数只~~绵~~棉羊。因为一只棉羊只能传染左右其中一只，所以第一轮传染时只能传染其中一边，假设没有重复感染，第二轮开始可以向左右两个方向扩散（除非左右没有棉羊），所以一只棉羊 $T$ 轮传染后共有 $T \times 2$ 只生病的棉羊。又因为有 $x$ 个棉羊，共有 $T \times 2 \times x$ 只棉羊被传染。因为一共只有 $n$ 只棉羊，所以最多有 $\min(T\times 2 \times x,n)$ 只棉羊被传染。

再考虑最少，一只棉羊可以被重复感染，那就要尽可能使它们被重复感染，这样可以使被感染的棉羊最少。所以我们把 $x$ 只生病的棉羊放在一起，由于随机向左向右传染，所以直接当成它们互相传染即可。特别的，当 $x=1$ 时，它必须传染给另一只相邻的棉羊。所以答案为 $\max(2,x)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int n,t,x;
signed main(){
	IOS;
	cin>>n>>t>>x;
	cout<<min(2*t*x,n)<<" "<<max(2ll,x);
	return 0;
}

```
[记录](https://www.luogu.com.cn/record/215774634)。

---

## 作者：AuZeb (赞：5)

## 思路

由于要最少，所以尽量互相传播，因为不能传播给自己，所以要特判 $n=1$ 的情况，公式如下：

$$Sick_{min}=\max(x,2)$$

![](https://cdn.luogu.com.cn/upload/image_hosting/b0igultq.png)

如上图，由于要最多，所以尽量向两边拓展，考虑一只患病的羊第一轮向右，第二轮两只患病的羊同时向两边拓展，$t$ 轮则可传染 $t\times 2$ 只羊，$x$ 只羊每 $t\times 2$ 只羊放一只患病的羊则可传染 $x\times t\times 2$ 只羊，由于只有 $n$ 只羊，所以公式如下：

$$Sick_{max}=\min(x\times t\times 2,n)$$

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n,t,x; cin>>n>>t>>x;
	int mi=max(2LL,x),mx=min(n*1LL,x*2*t);
	cout<<mx<<" "<<mi; return 0;
}
```

---

## 作者：CaiZi (赞：4)

考虑贪心。

当被传染的棉羊数量最多时，考虑只有一只棉羊第一天就被传染的情况，第一轮它先传染相邻的任意一只棉羊，所以答案是 $2$。之后每一轮，被传染的小棉羊都是连续的，可以让最左边的小棉羊继续往左传染，最右边的小棉羊继续往右传染，其余小棉羊随意。

而对于有多只棉羊第一天就被传染时，可以把它们分别安排，使得 $T$ 天后的传染区间互不相交，于是转化成只有一只棉羊第一天就被传染。然而棉羊的数量是有限的，最多只能传染 $n$ 只，因此答案是 $\min\{n,2xT\}$。

当被传染的棉羊数量最少时，你可以把第一天就被传染的棉羊安排在连续的位置，这样它们可以不断互相传染。当只有 $1$ 只棉羊第一天就被传染时，这只棉羊需要传染相邻的棉羊，然后不断互相传染。因此答案是 $\max\{2,x\}$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,x;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>t>>x;
	cout<<min(n,2*x*t)<<' '<<max(2ll,x);
	return 0;
}
```

---

## 作者：lcfollower (赞：2)

简单数学题。

先看最小值，它更简单。

明显可以把这 $x$ 只羊摆在一起，然后他们**相互传染**，答案为 $x$。

但是也有特殊情况。当 $x = 1$ 时，由于 $T\ge 1$，这只羊不得不先传染一只羊，这两只羊再相互传染，答案为 $2$。

所以最小值为 $\max \{2 ,x\}$。

---

再考虑最大值。

对于一个位置的羊，不考虑羊圈边界，第一轮他可以传染任意方向的一只羊；第二轮他们两个沿**互逆**方向传染而新增 $2$ 只；第三轮最外侧的两只羊沿**互逆**方向传染而新增 $2$ 只，因为中间的传染任意一直相邻的羊都没有贡献，它们都被感染过了啊。

所以第一轮增加 $1$ 只，第 $2\sim T$ 轮增加 $2$ 只，一只羊（注意还有**自己**）最多的贡献为 $2(T - 1) + 1 + 1 = 2T$ 只。

然后我们考虑把这些羊分的开一点，就可以达到感染羊为 $2Tx$ 只。

如果没达到 $n$ 说明分得再开也是这个答案，因为贡献最大；正好为 $n$ 显然是距离合适；超过 $n$ 说明贡献过大，有的初始羊间隔会比预期间隔小，但是仍然能感染 $n$ 只羊。

所以答案没有任何问题，为 $\min \{n ,2Tx\}$。

代码
---

```cpp
# include <bits/stdc++.h>

# define int long long

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

signed main (){
  int n = read () ,t = read () ,x = read ();
  writesp (min (n ,x * 2 * t));
  writeln (max (2ll ,x));
  return 0;

}
```

---

## 作者：swate114514 (赞：1)

这个蒟蒻切橙题用了半小时……但是不得不说，真是好题啊！

## 思路
我们需要计算在 $T$ 天后被感染的小棉羊数量的最大值和最小值。为了最大化感染数量，我们需要每个被感染的小棉羊每天尽可能感染新的小棉羊。

假设每个被感染的小棉羊每天都能向左右两个方向各感染一只新的小棉羊。这样，每个感染源每天可以感染 $2$ 只新的小棉羊。经过 $T$ 天后，每个感染源最多可以感染 $2 \times T$ 只新的小棉羊。因此，一共 $x$ 个感染源在 $T$ 天后最多可以感染 $x \times 2 \times T$ 只新的小棉羊。需要注意的是，当这个值超过总羊数 $N$ 时，结果应为 $N$。

- 最大值公式：  
$$\text{maxn} = \min(x \times 2 \times T, N)$$

为了最小化感染数量，我们需要尽可能减少新感染的数量。当初始感染数 $x$ 大于 $1$ 时，可以通过将初始感染的小棉羊连续排列，使得它们在后续的感染过程中无法扩散。例如，小棉羊们连续排列，每个小棉羊的相邻位置已被感染，因此无法感染新的小棉羊，结果保持为羊的数量 $x$。当 $x=1$ 时，第一天必须感染一个相邻的小棉羊，后续无法避免感染数量变为 $2$。

- 最小值公式：

$$ \text{minn} = \begin{cases} 
2 & \text{if } x = 1 \\
x & \text{otherwise}
\end{cases}$$

## Code
```cpp
#include <iostream>

using namespace std;

int main() {
    long long N, T, x;
    cin >> N >> T >> x;
    
    long long maxn = min(x * 2 * T, N);
    long long minn = (x == 1 ? 2 : x);
    
    cout << maxn << ' ' << minn;
    
    return 0;
}
```

---

## 作者：the_Short_Path (赞：1)

首先，羊会感染左边或右边的羊，则 $x=1$ 最多的方案为：
```
（-表示未被感染，+表示已被感染）
T=0  ... ----+--- ...   1
T=1  ... ---++--- ...   2
T=2  ... --++++-- ...   4
T=3  ... -++++++- ...   6
T=4  ... ++++++++ ...   8
```
$x=2$ 最多的方案为：
```
（-表示未被感染，+表示已被感染）
T=0  ... ----+--- ... ----+--- ...   2
T=1  ... ---++--- ... ---++--- ...   4
T=2  ... --++++-- ... --++++-- ...   8
T=3  ... -++++++- ... -++++++- ...   12
T=4  ... ++++++++ ... ++++++++ ...   16
```
以此类推，第 $T$ 天最多可感染 $T\times x\times2$ 只羊，所以答案为 $\max(n,T\times x\times2)$。

而最少的方案就是几只在一起的羊重复感染，即答案为 $x$，**注意特判 $n=1$ 时答案为 $2$**。

最后提醒一句：**十年 OI 一场空，不开 `long long` 见祖宗！**
# Code
```cpp
#include <bits/stdc++-h>
using namespace std;
long long N, T, x;
int main() {
    cin >> N >> T >> x;
    cout << min(N, T * x * 2) << " " << x + (x == 1) << endl;
    return 0;
}
```

---

## 作者：AFO_Lzx (赞：1)

赛时只有 $80$ 分，肯定要掉大分。实际上本题就是个贪心。

首先看最大值，我们一开始感染了 $x$ 只，那么可以传染 $t$ 次。我们让传染的羊都互不重复，所以最多可以感染 $2 \times x \times t$ 只羊，由于只有 $n$ 只羊，所以最大值为 $\min\{n,2\times x\times t\}$。

最小值就显而易见了，除了 $x=1$ 时肯定要多传染一只，其它的情况够可以互相重复传染，所以当 $x=1$ 时最小值为 $2$，否则最小值为 $\min\{n,x\}$。

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	ll n, t, x;
	cin >> n >> t >> x;
	
	cout << min(x * t * 2, n) << ' ';
    if (x > 1) cout << min(n, x);
    else cout << x + 1;
	return 0;
}
```

---

## 作者：Billhqh9 (赞：1)

# Solution
题目求在可能的情况下求最值。我们不妨把最大值和最小值分开讨论。

## 最大值
考虑何时传染最快。也就是如何让 $1$ 只羊尽可能感染多的羊。首先第一批感染的羊分开最好。因为我们要让 $1$ 只羊感染更多的羊，肯定希望它的四周都是健康的羊。所以我们先研究 $1$ 只羊如何感染其他羊是最快的。我们发现，传染最快时，步骤如下（`#` 表示未感染，`@`表示感染）：
1. `#######@########`（第一只羊生病）
2. `#######@@#######`（旁边的羊被感染，我们不在意是左边还是右边，这里示范右边）
3. `######@@@@######`（两只羊都向两侧感染）
4. `#####@@@@@@#####`（最旁边的两只羊继续感染两侧的其他羊）
5. 不断重复上一个步骤

因此我们可以得出结论，$1$ 只羊在 $T$ 轮感染后，共可以使 $[1 + 1 + 2 \times (T - 1)]$ 只羊被感染（包括感染源），化减后为 $2T$ 只羊被感染。

又因为共有 $x$ 个感染源，所以感染最大值是 $2xT$ 只羊。因为一共也就 $N$ 只羊，所以需要再和 $N$ 取较小值。

综上所述，感染最大值是 $\min(2xT, N)$ 只。

## 最小值
和最大值相反，我们此时希望感染源呆在一起，互相传染，不祸害其他羊。

这样，我们又得出了感染最小值，即原来的 $x$ 只。但又一个例外，当只有 $1$ 个感染源的时候，必然感染另外一只羊，但此后他们可以互相感染。

所以最终的感染最小值是 
$
\begin{cases}
2 & (x=1) \\
x & (x > 1)
\end{cases}
$ 
只。

# Code
```c++
#include <iostream>
#define Min(a,b) (a<b?a:b)
using namespace std;
long long N, T, x;
int main() {
    cin >> N >> T >> x;
    cout << Min(2ll * x * T, N) << ' ' << (x == 1 ? 2 : x) << endl;
    return 0;
}
```
有了结论，代码就变的非常短小精悍。

~~鬼知道为什么我考场上写了那么长的代码。~~

---


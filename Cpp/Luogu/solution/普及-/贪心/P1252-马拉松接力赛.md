# 马拉松接力赛

## 题目描述

某城市冬季举办环城 $25\rm km$ 马拉松接力赛，每个代表队有 $5$ 人参加比赛，比赛要求每个的每名参赛选手只能跑一次，一次至少跑 $1\rm km$ 、最多只能跑 $10\rm km$，而且每个选手所跑的公里数必须为整数，即接力的地方在整公里处。

刘老师作为学校代表队的教练，精心选择了 $5$ 名长跑能手，进行了训练和测试，得到了这 $5$ 名选手尽力连续跑 $1\rm km$、$2\rm km$、…、$10\rm km$ 的所用时间。现在他要进行一个合理的安排，让每个选手跑合适的公里数，使学校代表队跑完 $25\rm km$ 所用的时间最短。根据队员的情况，这个最短的时间是惟一的，但安排方案可能并不惟一。

根据测试情况及一般运动员的情况得知，连续跑 $1\rm km$ 要比连续跑 $2\rm km$ 速度快，连续跑 $2\rm km$ 又要比连续跑 $3\rm km$ 速度快……也就是说连续跑的路程越长，速度越慢，当然也有特殊的，就是速度不会变慢，但是绝不可能变快。

## 说明/提示

@Jomoo 提供了修正后的数据

## 样例 #1

### 输入

```
333 700 1200 1710 2240 2770 3345 3956 4778 5899 
300 610 960 1370 1800 2712 3734 4834 5998 7682
298 612 990 1540 2109 2896 3790 4747 5996 7654
289 577 890 1381 1976 2734 3876 5378 6890 9876
312 633 995 1407 1845 2634 3636 4812 5999 8123```

### 输出

```
9905
6 5 5 4 5```

# 题解

## 作者：花千树 (赞：40)

本题思路：纯贪心，读入时求出每1km比前面多的时间，用一个数组存起来，然后枚举情况，找出最优解，注意，每人的km数初值为0。

详情见代码！！！！！

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int minx=2147483647,flag,ans;//定义最小值，标志变量和最小路程
int a[5][11],b[5][11],c[5];//3个数组
int main(){//过程华丽开始
    c[0]=c[1]=c[2]=c[3]=c[4]=1;//注意，初值为1
    for(int i=0;i<5;i++){
        for(int j=1;j<11;j++){
            cin>>a[i][j];//读入
            b[i][j]=a[i][j]-a[i][j-1];//计算
        }
    }
    for(int i=0;i<20;i++){
        minx=2147483647;//每次更新初始值
        for(int j=0;j<5;j++){
            if(b[j][c[j]+1]<minx&&c[j]+1<=10){//如果比目前最小值小，且没有超过10km
                flag=j;//标志
                minx=b[j][c[j]+1];//最小值更新
            }
        }
        c[flag]++;//增加
    }
    for(int i=0;i<5;i++){
        ans+=a[i][c[i]];//计算最优解
    }
    printf("%d\n%d %d %d %d %d\n",ans,c[0],c[1],c[2],c[3],c[4]);//完美输出
    return 0;//过程华丽结束
}

```

---

## 作者：于丰林 (赞：26)

对于这道题，如果使用暴力的全排列来做的话，那么显然时间复杂度会妥妥的达到10^5，如果我们想要过掉所有的数据点的话，暴力排列就显得十分无力，所以我们要选择别的方法。

这道题的特点在于要求最小值，因此我们可以往贪心和dp上去想，这里介绍一种贪心算法：

由于每个人都需要跑，因此第一步肯定要将每一个人分配一公里，那么接下来该怎么办呢？

显然无论在什么状态下，我们都要找跑这一公里最快的人来跑，因此我们只要每一次找每个人跑下一公里所需的时间再进行比较，就可以找到所需时间最短的人，将其标记即可。

或许你会问：每个人只能上场一次，如果按照刚刚的思路不就使得每个人上场多次了吗？

其实这并不是问题，由于我们要找的是最短的时间，因此无论先跑还是后跑，最优方案的总时长不变，所以不会对结果造成影响。

关于无后效性，由于每一步只受之前的状态影响，所以显然没有后效性。

最后有一个注意事项：开的标记数组不能超过10，否则会导致二维数组越界。

最后，附上本题代码。

```cpp
#include<cstdio>
using namespace std;
int a[6][11],aa[6][11],c[6],ans;
int main()
{
    c[1]=1;c[2]=1;c[3]=1;c[4]=1;c[5]=1;
    for(int i=1;i<=5;i++)
    {
        for(int j=1;j<=10;j++)
        {
            scanf("%d",&a[i][j]);
            aa[i][j]=a[i][j]-a[i][j-1];
        }
    }
    for(int i=1;i<=20;i++)
    {
        int min=2147483647,temp=0;
        for(int j=1;j<=5;j++)
        {
            if(aa[j][c[j]+1]<min&&c[j]+1<=10)
            {
                min=aa[j][c[j]+1];
                temp=j;
            }
        }
        c[temp]++;
    }
    for(int i=1;i<=5;i++)
    {
        ans+=a[i][c[i]];
    }
    printf("%d\n%d %d %d %d %d",ans,c[1],c[2],c[3],c[4],c[5]);
    return 0;
}
```

---

## 作者：yyandy (赞：17)

#### 这道题数据范围很小，所以。。。暴力搜索也是可以通过的。。。

于是我就草草写了一个dfs

但经本人测试，速度不慢，只跑了55ms

居然并不比正解慢。。。

代码（注释具体见代码）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100][100],minn=INT_MAX,q[100],i,j,f[1000][100],qmin[100];//数组是我随手开的
void dfs(int x,int y,int s){//搜索内容 x代表还剩 x km,y代表前y人,s代表最少时间
	if (x<0)
	return;//这句话可能是多余的
	if (f[x][y]<=s)
	return;
	f[x][y]=s;//记忆化，f[x][y]表示还剩x公里，前y个人参加，能达到的最小的时间
	if (y>5){//如果所有人都跑了
		if (x==0)//如果跑完全程了
			if (minn>s){//如果时间比原来已记录的少
				minn=s;
				for (int i=1;i<=5;++i)
				qmin[i]=q[i];//记录
			}
		 return;
	}
	for (int i=1;i<=min(x,10);++i){//枚举当前这个人跑了i公里
	q[y]=i;//记录
	dfs(x-i,y+1,s+a[y][i])//;剩下路程-i,下一个人，时间加该人跑i公里所需要的时间
}
}
int main(){
	for (i=1;i<=5;++i)
	for (j=1;j<=10;++j)
	cin>>a[i][j];//输入
	for (i=0;i<=100;++i)
	for (j=0;j<=80;++j)
	f[i][j]=INT_MAX;//初始化，我也是随手写的
	dfs(25,1,0);//搜索
	cout<<minn<<endl;
	for (i=1;i<=4;++i)
	cout<<qmin[i]<<" ";cout<<qmin[5];//打印答案
}
```
于是完美通过。。。
唉，标签也不一定对呀！
### dfs万岁！！！
为什么不在标签上加搜索呢？


---

## 作者：R·Buffoon (赞：13)

随机跳题跳到的题（竟然是$\color{orange}\text{橙题}$）
***
看完题面（~~题面好长~~），嗯，应该是贪心，点开标签，果然

然后就开始贪心了，结果，肝了一晚上，没贪出来（~~到底是我太菜还是我太老实不会贪？~~）
***
在睡觉前又想起了这道题，想了想，这题好像可以暴力直接干

仔细想想，似乎是的（~~顿时一群神兽奔腾而过，肝了一晚上贪心没肝出来还以为是自己老了该AFO了~~）
***
所以，开始大暴力（前方高能）

```cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
    int qwq=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar()) qwq=(qwq<<1)+(qwq<<3)+(c&15);
    return qwq;
}

const int n=5;
const int m=10;

int ans=987654321,now;
int a[6][12],f[6];//a储存5个队员测试数据，f储存5个队员各自连续跑的公里数

inline int sum(int i,int j,int k,int l,int o)
{
	return a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][o];
}
//函数让主程序简洁（没差）
inline void change(int i,int j,int k,int l,int o)
{
	f[1]=i,f[2]=j,f[3]=k,f[4]=l,f[5]=o;
}

int main()
{
    for(RI i=1;i<=n;++i)
    {
    	for(RI j=1;j<=m;++j)
    	{
    		a[i][j]=in();
		}
	}
	
	for(RI i=1;i<=m;++i)//前两个没必要剪枝（其实都没必要，也就快个5ms左右）
	{
		for(RI j=1;j<=m;++j)
		{
			for(RI k=1;k<=m;++k)
			{
				if(i+j+k+20<25 || i+j+k+1>25) continue;//剪枝
				for(RI l=1;l<=m;++l)
				{
					if(i+j+k+l+10<25 || i+j+k+l+1>25) continue;//剪枝
					for(RI o=1;o<=m;++o)
					{
						if(i+j+k+l+o==25)//判断
						{
							now=sum(i,j,k,l,o);
							if(ans>now)//更新答案
							{
								ans=now;
								change(i,j,k,l,o);
							}
						}
					}
				}
			}
		}
	}
	
	printf("%d\n",ans);
	for(RI i=1;i<=n;++i) printf("%d ",f[i]);
	
    return 0;
}
```

~~这件事告诉我们，不要相信标签！~~

~~提交的时候评测机好慢，还以为暴力炸了~~

---

## 作者：Hammer_cwz_77 (赞：11)

本题的关键点:先跑和后跑！


因此，我们可以每次贪心地取最小值，这样，每一个子问题的最优解也保证了整道题目的最优解。


现在设第i位选手跑的km数为a，则每一次，若a<10，则取min(a),可以得到最优解


代码奉上：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int a[5][11],temp[5];
int t[5][11],Min,tag,sum;
int main()
{
    for(int i=0;i<5;i++)
    for(int j=1;j<11;j++)
    {
        cin>>a[i][j];
        t[i][j]=a[i][j]-a[i][j-1];
    }
    temp[0]=temp[1]=temp[2]=temp[3]=temp[4]=1;
    for(int i=0;i<20;i++)
    {
        Min=INF;
        for(int j=0;j<5;j++)
        {
            if(t[j][temp[j]+1]<Min&&temp[j]+1<=10)
            {
                tag=j;
                Min=t[j][temp[j]+1];
            }
        }
        temp[tag]++;
    }
    sum=0;
    for(int i=0;i<5;i++)
    sum+=a[i][temp[i]];
    cout<<sum<<endl;
    cout<<temp[0]<<" "<<temp[1]<<" "<<temp[2]<<" "<<temp[3]<<" "<<temp[4]<<endl;
    return 0;
}
```

---

## 作者：huangxuhan (赞：4)

这道题可以DFS（n只有10），至于输出每个人跑的，可用状态压缩
```cpp
#include <bits/stdc++.h>
using namespace std;
long long ans=-1,a[6][11],b[6];
int k;
int pd() //判断是否有全员参与
{
	for (int i=1;i<=5;i++)
	{
		//cout<<b[i]<<" "; 
		if (b[i]==0) return 0; //如果有一个人没跑，就不合法
	}
	//cout<<endl;
	return 1;
}
void dfs(long long s,int x,int l,int o) // s是总时间，x是层数，l是千米数，o是状态
{
    if (x==5) //如果5层
	{
		if (l==25&&pd()) //如果满足跑了25km和全员参与的条件，就可以记录答案
		{
			if (ans==-1) //如果没有一个答案
		    {
			    ans=s;
			    k=o;  //保存状态
		    }
			else 
		    {
			    if (s<=ans) 
		        {
		        	if (s==ans)
		        	{
		        		k=max(o,k); //emmmmm貌似是根据字典序的，所以。。。。。。
					}
		    	    ans=s;
		    	    k=o;
			    }
		    }
		}
		return; //到达5层无论如何都要返回
	}
	if (l>=25&&x<=5) return; //简单剪枝
	for (int i=1;i<=10;i++)
	{
		b[x+1]=i; //为了判断是否全员参与
		dfs(s+a[x+1][i],x+1,l+i,o*100+i); //因为有可能10，所以每个状态用的空间是100,如 10,04,05 等
	}
	
}
int main()
{
	//freopen("marathon.in","r",stdin);
	//freopen("marathon.out","w",stdout);
	for (int i=1;i<=5;i++)
	{
		for (int j=1;j<=10;j++)
		{
			cin>>a[i][j];//输入
		}
	}
	dfs(0,0,0,0);  
	if (k/1000000000)cout<<10<<" "; //解状态压缩
	else cout<<k/100000000<<" ";
	k%=100000000;
	if (k/10000000) cout<<10<<" ";
	else cout<<k/1000000<<" ";
	k%=1000000;
	if (k/100000) cout<<10<<" ";
	else cout<<k/10000<<" ";
	k%=10000;
	if (k/1000)cout<<10<<" ";
	else cout<<k/100<<" ";
	k%=100;
	if (k/10)cout<<10<<endl;
	else cout<<k%10<< " "; 
	return 0;
}
```
70分。。。。。。希望dalao挑错orzorz,虽然可能无法AC，但是可以当做DFS来练手,表抄题解，不然你会后悔

---

## 作者：tarik (赞：2)

# 没人写优先队列，那我偷偷发一个题解
## 给一个思路
我们可不可以把数据转换成第 _i_ 个人跑第 _j_ 公里的距离，然后换一个角度想一想

以下为转换代码
```cpp
for(int i=1;i<=5;i++)
{
    for(int j=1;j<=10;j++) cin>>a[i][j];
    for(int j=10;j>=2;j--) a[i][j]-=a[i][j-1];
}
```
### 接下来，我们可以这样贪心来写这个题目
每次选择一个人，他可以在当前时间用最小的时间跑，那就选他，他跑完了之后我们再把它下一次的时间拿去比较

写到这里，不难想出用小根堆动态维护最小值。

我们可以写一个node并重载小于号
```cpp
struct node
{
    int idx,tim;
    bool operator<(const node &o) const 
    {
        return tim>o.tim;
    }
};
priority_queue<node> q;
```
接下来就是很简单的了，只要每取一个点，再把他的下一个节点放到队列里。

AC 代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
#define io_speed_up ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); //读入优化
struct node
{
    int idx,tim,pre; //记录当前跑到了第几个，方便让下一个入队
    bool operator<(const node &o) const 
    {
        return tim>o.tim;
    }
};
int a[10][20];
int ans[10];
int res=0;
priority_queue<node> q;
int main()
{
    io_speed_up;
    for(int i=1;i<=5;i++)
    {
        for(int j=1;j<=10;j++) cin>>a[i][j];
        for(int j=10;j>=2;j--) a[i][j]-=a[i][j-1];
        q.push({i,a[i][1],1});
    }
    for(int i=1;i<=25;i++) //只要跑25km
    {
        node tmp=q.top();q.pop(); //取出
        int idx=tmp.idx,pre=tmp.pre;
        res+=tmp.tim;
        ans[idx]=pre;
        if(pre<10) q.push({idx,a[idx][pre+1],pre+1}); //如果还能跑，那就放入下一个
    }
    cout<<res<<endl;
    for(int i=1;i<=5;i++) cout<<ans[i]<<' ';
    return 0;
}

```
总体的复杂度是转换$O(n)$,堆维护$O(n \log n)$。

---

## 作者：chinaxjh (赞：2)

### 这道题其实是一道纯模拟题，虽然时间复杂度是O(10^5)，但无论是思维难度还是代码的实现难度都比贪心要简单不少

#### 特别感谢@Jomoo提供了SPJ和修正后的数据，否则这种算法在输出方案上会与贪心不同，导致WA

题意理解：枚举五个人跑的公里数判断是否符合要求，找最小即可

AC Code
```pascal
const n=10;//每个人最多10公里
var
  min,i,a,b,c,d,e,k:longint;
  aa,bb,cc,dd,ee,ans:array[1..20] of longint;
begin
  min:=maxlongint;
  for i:=1 to n do read(aa[i]);
  for i:=1 to n do read(bb[i]);
  for i:=1 to n do read(cc[i]);
  for i:=1 to n do read(dd[i]);
  for i:=1 to n do read(ee[i]);//读入五个人的数据
  for a:=1 to n do
   for b:=1 to n do
    for c:=1 to n do
     for d:=1 to n do
      for e:=1 to n do
      if (a+b+c+d+e=25) then//判断总和25公里
      begin
        k:=aa[a]+bb[b]+cc[c]+dd[d]+ee[e];//总时间
        if k<min then//判断是不是小，小就计入答案
        begin
          min:=k;
          ans[1]:=a;
          ans[2]:=b;
          ans[3]:=c;
          ans[4]:=d;
          ans[5]:=e;
        end;
      end;
  writeln(min);
  for i:=1 to 5 do write(ans[i],' ');
  writeln;//输出答案
end.
```



---

## 作者：lych (赞：2)

首先明确一个概念，也就是本题的关键点，那就是先跑和后跑，连续跑和分开跑的时间是相同的！

就题目而言，比如A可以先跑2km，再跑3km，这个值和连续跑5km相等。

因此，我们可以每次贪心地取最小值，这样，每一个子问题的最优解也保证了整道题目的最优解。

现在设第i位选手跑的km数为p[i]，则每一次，若p[i]<10，则取min(p[i]),(1<=i<=5),可以得到最优解

具体思路见程序如下：

```cpp
var
  i,j,ans,min:longint;
  p:array[1..5] of longint;
  s:array[1..5,1..11] of longint;
begin
  for i:=1 to 5 do
    for j:=1 to 10 do
      read(s[i,j]);//读入
  for i:=1 to 5 do
    p[i]:=1;//因为每人至少跑1km，所以p[i]都取到1
  for i:=1 to 5 do
    inc(ans,s[i,1]);//加上每个人1km的时间
  for i:=6 to 25 do//枚举第6~25km的时间
    begin
      min:=maxlongint;//为了方便起见，min设为maxlongint
      for j:=1 to 5 do
        if (p[j]<10) and (s[j,p[j]+1]-s[j,p[j]]<min) then
          min:=s[j,p[j]+1]-s[j,p[j]];//若比min小且少于十公里，那么刷新min的值，最为局部最优解
      inc(ans,min);
      for j:=1 to 5 do
        if (p[j]<10) and (s[j,p[j]+1]-s[j,p[j]]=min) then
          break;//找到哪一个是刚刚跑的
      inc(p[j]);//指针后移一位（注意这只是名称，与pascal中的指针是不同的
    end;
  writeln(ans);
  for i:=1 to 5 do write(p[i],' ');//输出
end.
```

---

## 作者：树树 (赞：1)

使用了一种现代优化算法，即模拟退火算法，时间复杂度不高，效果很好，看了一下题解没有人使用过，希望能发布出来给大家学习。

模拟退火算法的思路在于，在整个解空间内寻找全局最优解，如果遇到局部最优解时，下一次会有一定概率接受不是最优的解，从而跳出局部最优解，来寻找到全局最优解，一些超级参数需要预先设置好。

AC代码奉上！！！！！（Reader类我删了，防抄袭）run方法是重点。
```java
public class Main {
	
	private int [][]matrix;
	private final int count = 5;
	private final int length = 10;
	private PrintWriter writer;
    Main() {
 		Reader reader = new Reader();
 		writer = new PrintWriter(new OutputStreamWriter(System.out));
 		matrix = new int [count][length+1];
 		for(int i=0; i<count; ++i) {
 			for(int j=1; j<=length; ++j) {
 				matrix[i][j] = reader.nextInt();
 			}
 		}
    }
    private void run() {
    	double a = 0.99;//温度衰减函数的参数
    	double t = 97;//初始温度
    	double tf = 3;
    	int Markov_length = 2;
    	int index1, index2;//产生扰动的两个位置
    	
    	int E_best = Integer.MAX_VALUE, E_new;
    	int E_current = E_best;
    	int []sol_new = {5, 5, 5, 5, 5};
    	int []sol_current = sol_new.clone(), sol_best = sol_new.clone();
    	
    	while(t >= tf) {
    		for(int i=0; i<Markov_length; ++i) {
    			index1 = (int) Math.floor((Math.random() * 5));
    			index2 = (int) Math.floor((Math.random() * 5));
                //下面这里产生新解
    			if(sol_new[index1] < 10 && sol_new[index2] > 0) {
	    			++ sol_new[index1];
	    			-- sol_new[index2];
    			}
    		}
    		E_new = 0;
    		for(int i=0; i<count; ++i) {
    			E_new += matrix[i][sol_new[i]]; 
    		}
    		
    		if(E_new < E_current) {
    			E_current = E_new;
    			sol_current = sol_new.clone();
    			if(E_new < E_best) {
    				E_best = E_new;
    				sol_best = sol_new.clone();
    			}
    		} else {
    			if(Math.random() < Math.exp(-(E_new - E_current)) / t){
    				E_current = E_new;
    				sol_current = sol_new;
    			} else {
    				sol_new = sol_current.clone();
    			}
    		}
    		
    		t = t * a;
    	}
        //输出
    	writer.println(E_best);
    	for(int i=0; i<count; ++i) {
    		writer.print(sol_best[i] + " ");
    	}
    	writer.flush();
    }
    public static void main(String[] args) {
        new Main().run();
    }
}


```


---


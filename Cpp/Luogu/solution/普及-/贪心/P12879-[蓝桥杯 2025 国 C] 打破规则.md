# [蓝桥杯 2025 国 C] 打破规则

## 题目描述

蓝桥小镇的钟表铺里，工匠小蓝正在修复一座三针时钟。其中，时针的长度为 $A$，分针的长度为 $B$，秒针的长度为 $C$，均为正整数。制造商为追求独特的设计，设定了以下规则：

- 三根指针的长度互不相同，即 $A \neq B$，$A \neq C$，$B \neq C$；
- 将三根指针的长度从大到小排序后，第二长的指针必须是时针（长度 $A$）或秒针（长度 $C$）。

然而，这些规则会导致指针运行时相互干扰，影响时钟的稳定性。于是，小蓝决定调整指针长度，打破上述规则：要么三根指针的长度不互不相同（存在至少两根指针的长度相同），要么第二长的指针不是 $A$ 或 $C$。他可以执行以下三种操作：

- 将时针的长度 $A$ 减少 1；
- 将分针的长度 $B$ 减少 1；
- 将秒针的长度 $C$ 减少 1。

调整后的指针长度必须为正整数，即 $A, B, C > 0$。

现在，请你帮助小蓝计算，打破制造商规则所需的最小操作次数。

## 说明/提示

**【评测用例规模与约定】**

对于 $50\%$ 的评测用例，$1 \leq A, B, C \leq 100$；

对于所有评测用例，$1 \leq A, B, C \leq 10^5$。

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
5 9 2```

### 输出

```
3```

## 样例 #3

### 输入

```
5 6 5```

### 输出

```
0```

# 题解

## 作者：volatile (赞：4)

# 思路

首先进行判断，存在两个数相等，或者把这三个数排序，第二大的数不为 $A$ 和 $C$，就可以输出 $0$。

否则，容易发现最优的方式是让两个数相等，让两个数相等的代价即这两个数的差，找到最小的差即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,c,s[3];
    cin>>a>>b>>c;
    s[0]=a;
    s[1]=b;
    s[2]=c;
    sort(s,s+3);
    if((a==b||a==c||b==c)||(s[1]!=a&&s[1]!=c)) cout<<0;
    else cout<<min({fabs(a-b),fabs(a-c),fabs(b-c)});//C++11
    return 0;
}
```

---

## 作者：Sunrise_up (赞：3)

## 思路

我们需要打破至少一个条件。可能的情况有：让两根指针长度相同，或者让第二长的指针是分针 $B$。

如果排序后中间值等于原分针长度 $B$，则第二长的指针是分针，已打破规则。否则，需要调整指针长度。

通过分析发现，最小操作次数为以下三种调整方式的最小值：

- 将最小值增加到中间值；

- 将最小值增加到最大值；

- 将中间值增加到最大值。

~~所以第二个条件是没用的。~~

## 代码

``` cpp
include<bits/stdc++.h>
using namespace std;
int x[3],b;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>x[0]>>x[1]>>x[2];
    b=x[1];           //保存分针长度
    sort(x,x+3);      //排序三根指针长度
    //如果排序后的中间值等于原分针长度，说明已经满足条件
    cout<<(x[1]==b?0:min({x[1]-x[0],x[2]-x[0],x[2]-x[1]}));
}
```

~~求点赞 qwq。~~

---

## 作者：Clare613 (赞：2)

## 思路：
这道题很简单，我们只要分两种情况讨论：
1. 已经符合要求了：\
对于这种情况，输出 `0` 就可以了。
3. 还不符合要求：\
正常人都会分成两种：一，使 $B$ 为第二个。二，使两个针的长度相同。我们仔细想一下，其实使 $B$ 为第二个和使两个针的长度相同是同一种，因为你要使 $B$ 为第二个，那么你就要先使一个针等于 $B$，再减小 $B$。我们设中间值为 $M$，那么我们就只要输出 $\min(\max(a,b,c)-M,M-\min(a,b,c))$ 即可。
## code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	int a,b,c;
	cin>>a>>b>>c;
	int s=max({a,b,c});
	int w=min({a,b,c});
	if(s!=b&&w!=b){
		cout<<0;
        return 0;
	}
	int e=min(s-(a+b+c-s-w),(a+b+c-s-w)-w);
	cout<<e;
	return 0;
}
```

---

## 作者：MingDynasty_xiaohao2 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12879)。

这道题重要的是思路，代码非常短。
### 题目大意：
题目要求打破两个规则之一：

1. 三根指针长度不互不相同，也就是必须有两根长度相同。
2. 第二长的指针不是 $A$ 或 $C$，也就是必须是 $B$。

## 解题思路：

先分类：

1. 已经满足条件的情况直接返回 0。
2. 未满足条件的情况需要进行讨论。

**重点来看第 2 个条件：**

我们还需要进行分类，取分类中最小值：

1. 使 $A$ 和 $B$ 相同需要减少的次数。
2. 使 $B$ 和 $C$ 相同需要减少的次数。
3. 使 $A$ 和 $C$ 相同需要减少的次数。

**注意为什么不需要讨论规则 2：**

假如一开始不满足规则 2，想要最少操作满足条件 2，也就是想让某一条指针的长度大于另外一条指针的长度，而在大于另外指针长度之前，肯定会先等于，所以不用讨论。

#### 时间复杂度：$O(1)$。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
	int a,b,c;
	cin>>a>>b>>c;
	if(a==b||b==c||a==c||a<b&&b<c||c<b&&b<a){//注意这里是小于不是小于等于 
		cout<<"0";
		return 0;
	}
	cout<<min(abs(a-b),min(abs(c-b),abs(a-c)));//取最小值 
	return 0;
}
```

---

## 作者：Ghosty_Neutrino (赞：1)

## 题意
小蓝需要调整三根指针的长度 $A$，$B$，$C$，使其满足以下任意一条条件：

* 存在至少两根指针长度相同。
* 第二长的指针既不是时针 $A$ 也不是秒针 $C$。

允许的操作是将任一指针长度减 $1$，且调整后长度需保持正整数。计算最小的操作次数并输出。
## 分析
情况一（至少两根指针等长）：

* 使 $A=B$、$A=C$ 或 $B=C$，取三种情况中操作次数的最小值。

* 若 $A=B$，需操作 $\vert A-B \vert$ 次。同理，$A=C$ 需 $\vert A-C \vert$ 次，$B=C$ 需 $\vert B-C \vert$ 次。因此，最小操作次数为：$\min(\vert A-B \vert, \vert A-C \vert,\vert B-C \vert)$。

情况二（中间值是分针）：

* 先对原长度排序，若中间值已经是 $B$，无需操作直接输出。

* 若原中间值不是 $B$，需调整 $A$ 和 $C$，使调整后的长度满足：
* 存在某个值 $x$，使得调整后的 $A$ 和 $C$ 一者大于 $x$，一者小于 $x$，且调整后的 $B$ 等于 $x$。
* 此时排序后中间值为 $x=B$，即 $B$ 成为中间值。
* 枚举可能的中间值 $x$，分为两种调整方向：让 $A$ 增大到 $x+1$，$C$ 减小到 $x-1$。让 $C$ 增大到 $x+1$，$A$ 减小到 $x-1$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,c;
int main(){
    scanf("%d%d%d",&a,&b,&c);
    // 情况1：计算使至少两根指针等长的最小操作次数
    int case1 = min({abs(a-b),abs(a-c),abs(b-c)});
    // 情况2：计算使中间值为B的最小操作次数
    int nums[3]={a,b,c};
    sort(nums,nums+3);
    int mid=nums[1];  // 原长度排序后的中间值
    int case2 = INT_MAX;
    if(mid!=b) { // 原中间值不是B，需要调整
        // 方向1：调整A到x+1，C到x-1，x为中间值（B调整为x）
        int x1=min({a-1,b,c + 1}); // x的最大可能值
        if(x1>=2){ // x-1 >=1（C调整后≥1）
            int al=x1+1;  // 调整后的A长度（需≤原A）
            int cl=x1-1;   // 调整后的C长度（需≥1且≤原C）
            if(al<=a&&cl>=1&&cl<=c) {
                // 操作次数 = (A-a') + (B-x) + (C-c')
                case2=(a-al)+(b-x1)+(c-cl);
            }
        }
        // 方向2：调整C到x+1，A到x-1，x为中间值（B调整为x）
        int x2=min({c-1,b,a+1}); 
        if(x2>=2){
            int cl2=x2+1; 
            int al2=x2-1; 
            if(cl2<=c&&al2>=1&&al2<=a) {
                case2=min(case2,(c-cl2)+(b-x2)+(a-al2));
            }
        }
    }else{
        case2=0;// 原中间值已是B，无需操作
    }
    // 输出最小情况
    printf("%d",min(case1,case2));
    return 0;
}
```

---

## 作者：linhanmo (赞：1)

# [题解](https://www.luogu.com.cn/article/vvf0fq1s)：[P12879 [蓝桥杯 2025 国 C] 打破规则](https://www.luogu.com.cn/problem/P12879)

## 思路

考虑怎样才能打破规则。

有 $3$ 种情况：

1. 本身已经打破规则了；
2. 使两根指针相同；
3. 使排序后第二长不是 $A$ 或 $C$。

若最开始没有未打破规则，取 $\min$ 即可；否则输出 $0$。

## [AC](https://www.luogu.com.cn/record/220990708)  code


```
#include <algorithm>
#include <stdio.h>
int a, b, c;
int main(void) {
    scanf("%d %d %d", &a, &b, &c);
    
    if (a == b || a == c || b == c) // 检查是否已经打破规则
	    return putchar('0'), 0;
	
    int v[3] = {a, b, c}; std::sort(v, v + 3); // 排序
    
    // 检查排序后第二长是否是 a 或 c
    if (v[1] != a && v[1] != c) return putchar('0'), 0;
    
    printf("%d", std::min({
	    v[2] - v[1], v[1] - v[0], // 使两根指针相同
	    (v[1] == a ? a : c) - v[0] // 使排序后第二长不是 a 或 c 
	}));
    return 0;
}
```

---

## 作者：darklf (赞：0)

# 题解：P12879 [蓝桥杯 2025 国 C] 打破规则
### [题目传送门](https://www.luogu.com.cn/problem/P12879)
## 思路  
我们先判断 $B$ 是不是第二大的。  
如果是，输出零。  
如果不是，将最大值或最小值改为中间值，代价为最大值减中间值和中间值减最小值的最小值。   
附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
signed main(){
	int x,a[4];cin>>a[1]>>a[2]>>a[3];x=a[2];sort(a+1,a+4);
	if(x==a[2])cout<<0;
	else cout<<min(a[3]-a[2],a[2]-a[1]);
	return 0;
}
```
完结撒花。

---

## 作者：Dark_Knight_AK_ALL (赞：0)

如果说输入的三根针的长度已经打破规则了，那么就是 $0$。如果没有，那么我们就有 $3$ 种选择。可以将最大值调整为中间值，将中间值调整为最小值，将最大值调整为最小值。我们会发现第三种情况是显然不优的，所以只要判断前两种情况，取最小操作次数就行了。代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,s[4];
int main()
{
    cin>>a>>b>>c;
    s[1]=a;
    s[2]=b;
    s[3]=c;
    sort(s+1,s+4);
    if(s[2]==b)
    {
        cout<<0;
        return 0;
    }
    cout<<min(s[3]-s[2],s[2]-s[1]);
}
```

---

## 作者：_seven_7k_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12879)
## 思路
这是一个简单的贪心题，首先，我们在开始先判定 $a=b$ 或 $b=c$ 或 $a=c$ 或 $b$ 为三个数的第二大的数，如果符合，那么输出 $1$，结束！  
然后，我们开始考虑最小操作次数。首先，我们可以知道让 $b$ 改为第二大的数不是最优解，因为在 $b$ 减小或增加时，就会和 $a$ 或 $c$ 相等，所以没必要让 $b$ 变为第二大的数。  
然后我们判断怎么最小操作次数让两个数相等。其实非常简单，我们只要选出 $a-b$ 的绝对值和 $b-c$ 的绝对值和 $a-c$ 的绝对值当中最小的，输出即可。
## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main(){
	ll a,b,c;
	cin>>a>>b>>c;
	if(a==b || a==c || b==c){
		cout<<0<<endl;
	}
	else if((a<b && b<c)||(c<b && b<a)){
		cout<<0<<endl;
	}
	else{
		cout<<min(min(abs(b-a),abs(b-c)),abs(a-c))<<endl;
	}
	return 0;
}
```

---

## 作者：lcycl (赞：0)

# 思路
简单贪心。当 $a=b$ 或 $a=c$ 或 $b=c$ 或 $a<b<c$ 或 $a>b>c$ 时，就打破了规则。

每次只能减一，即使 $a=b$ 时要用 $|a-b|$ 步，使 $a=c$ 时要用 $|a-c|$ 步，使 $c=b$ 时要用 $|c-b|$ 步。当 $a$ 为第二大时，使 $b$ 为第二大要 $|a-b|+1$ 步，当 $c$ 为第二大时，使 $b$ 为第二大要 $|c-b|+1$ 步。接着取最小就可以了。注意：当 $a$，$b$，$c$ 已经满足条件时，输出 $0$。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int a,b,c;
	cin>>a>>b>>c;
	int p=min(abs(a-b),min(abs(a-c),abs(b-c)));
	if(a<b&&a>c||a>b&&a<c){
		cout<<min(abs(a-b)+1,p);
	}
	else if(c<b&&a<c||c>b&&a>c){
		cout<<min(abs(c-b)+1,p);
	}
	else cout<<0;
	return 0;
}
```

---

## 作者：Dream_Stars (赞：0)

## 题目大意：
有三根针，其中时针的长度为 $A$，分针的长度为 $B$，秒针的长度为 $C$。\
定义同时满足以下性质的三种长度为合法的：
- $A \neq B$，$A \neq C$，$B \neq C$；
- $B$ 不是第二长。

我们可以每次将 $A$，$B$ 或 $C$ 的长度减少 $1$，求将原长度构造成不合法的长度最少所需的次数。

## 算法分析：

分析题意可知，不合法的只有两种情况：

- $A = B$ 或 $B = C$ 或 $A = C$；
- $B$ 的长度是第二长的。

所以分类讨论即可解决。

## 代码展示：
```cpp
# include <bits/stdc++.h>

# define ll long long
# define int long long
# define rint register int

long long read(){long long s = 0 , w = 0; char c = getchar(); while(!isdigit(c)) w |= (c == '-') , c = getchar(); while(isdigit(c)) s = (s << 1) + (s << 3) + (c ^ 48) , c = getchar(); return w ? -s : s;}
void write(long long x){if(x < 0) putchar('-') , x = ~ (x - 1); if(x > 9) write(x / 10); putchar(x % 10 | 48);}
void writesp(long long x){write(x) , putchar(' '); }
void writeln(long long x){write(x) , putchar('\n');}

using namespace std;

long long a,b,c;
long long ansx,ansy;

signed main(){
  a = read(),
  b = read(),
  c = read();
  ansx = min(abs(a - b) , min(abs(b - c) , abs(a - c)));
//第一类: A = B 或 B = C 或 A = C。
  if((a < b && b < c) || (c < b && b < a)) ansy = 0;
  else if(b > a && b > c) ansy = b - max(a , c);
  else ansy = min(a , c) - b;
//第二类：分针的长度排在中间。
  write(min(ansx , ansy));//两种比一个最小值并输出。
  return 0;
}
```

---

## 作者：_second_coming_ (赞：0)

[AC 记录](https://www.luogu.com.cn/record/220804860) & [题目传送门](https://www.luogu.com.cn/problem/P12879)
### 思路

   - 找出最大值 $x$、中间值 $z$、最小值 $y$。
   - 如果中间值 $z$ 是 $a$ 或 $c$（原规则要求），则需要打破规则：
     - 操作方式可以是：
       - 将 $x$ 减少到 $z$（操作次数 $x - z$）。
       - 将 $z$ 减少到 $y$（操作次数 $z - y$）。
       - 将 $x$ 和 $y$ 调整到它们的中间值（操作次数 $\lfloor \frac{x - y}{2} \rfloor$）。
     - 取上述三种情况的最小值即可。

### 代码
很简洁的代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a, b, c;
int f() {
    if (a == b || a == c || b == c) return 0;
    int x = max({a, b, c}), y = min({a, b, c}), z = a + b + c - x - y;
    if (z == a || z == c) return min({x - z, z - y, (x - y) / 2});
    return 0;
}
int main() {
    cin >> a >> b >> c;
    cout << f() << endl;
    return 0;
}
```
### 闲话
~~管理给我过好不好。~~

---

## 作者：IkillDream (赞：0)

# P12879 题解

## 思路

可用用双指针的方法写这题，我们需要找到打破制造商规则所需的最小操作次数。制造商的两个规则是：
1. 三根指针的长度互不相同；
2. 将三根指针的长度从大到小排序后，第二长的指针必须是时针（长度 $A$）或秒针（长度 $C$）。我们需要打破这两个规则中的至少一个，可以通过以下两种方式之一实现：

使至少两根指针的长度相同（打破第一个规则）。

确保在排序后的三根指针中，第二长的既不是 $A$ 也不是 $C$（打破第二个规则）。

指针长度满足上面任意条件,最后就能找到最小的操作次数。

## [AC](https://www.luogu.com.cn/record/220802701) 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int kkk01[3] = {a, b, c};
    sort(kkk01, kkk01 + 3);
    bool bj1 = (a == b || a == c || b == c);
    bool bj2 = (kkk01[1] == b);
    if (bj1 || bj2) {
        cout << 0 << endl;
        return 0;
    }
    int a1 = kkk01[1] - kkk01[0];
    int b1 = kkk01[2] - kkk01[1];
    int kkk02 = min(a1, b1),kkk03=0;
    if (b < kkk01[1]) kkk03 = kkk01[1] - b;
    else kkk03 = b - kkk01[1];
    int minn = min(kkk02, kkk03);
    cout << minn << endl;
    return 0;
}
```

---


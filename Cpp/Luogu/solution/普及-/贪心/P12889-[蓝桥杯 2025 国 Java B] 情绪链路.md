# [蓝桥杯 2025 国 Java B] 情绪链路

## 题目描述

在数字社交媒体的浩瀚世界中，运营者小蓝负责维护一条情绪链路。这条链路由 $n$ 个用户节点依次排列而成，每个节点上记录着一个情绪值。具体地，第 $i$ 个节点的情绪值为 $a_i$，其中 $a_i$ 是一个整数，可能为正，也可能为负。

为了改善整体情绪氛围，小蓝购买了一种名为“情绪放大器”的工具。该工具允许他选择一段**至少包含一个用户节点的连续区间**，并将这个区间内所有用户节点的情绪值都乘以一个整数 $k$。只是，工具启动成本高昂，小蓝只能使用它一次。

现在，请你帮助小蓝计算，在经过这样一次操作后（一定要操作），所有用户节点的情绪值之和最大会是多少。

## 说明/提示

**【样例说明】**

最优的做法是选择区间 $[4]$ 并使用工具。使用后这 $n$ 个用户节点的情绪值依次为 $[-1, 2, -3, 8, -5]$，总和为 $1$。

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$2 \leq n \leq 10^3$，$1 \leq k \leq 10^3$，$-10^3 \leq a_i \leq 10^3$。

对于 $100\%$ 的评测用例，$2 \leq n \leq 10^5$，$1 \leq k \leq 10^5$，$-10^5 \leq a_i \leq 10^5$。

## 样例 #1

### 输入

```
5 2
-1 2 -3 4 -5```

### 输出

```
1```

# 题解

## 作者：SuyctidohanQ (赞：3)

### 题目分析

题目要求我们选择一个连续的区间 $[l, r]$（$1 \leq l \leq r \leq n$），将这个区间内的所有 $a_i$ 乘以 $k$。其他节点的 $a_i$ 保持不变。

### 思路分析

操作后的总和可以表示为原始总和 $S$ 减去被操作区间的原始和 $sum(l, r)$，加上被操作区间的乘以 $k$ 后的和 $k \cdot sum(l, r)$。

其中 $S = a_1 + a_2 + \cdots + a_n$，$sum(l, r) = a_l + a_{l+1} + \cdots + a_r$。

因为 $S$ 是固定的，我们需要最大化 $(k - 1) \cdot sum(l, r)$。这取决于 $k - 1$ 和 $sum(l, r)$ 的符号：

- 如果 $k - 1 > 0$（即 $k > 1$），我们需要最大化 $sum(l, r)$。

- 如果 $k - 1 = 0$（即 $k = 1$），操作不影响总和，因此任何区间选择都不会改变总和。

为了使 $(k - 1) \cdot sum(l, r)$ 最大：

- 如果 $k > 1$，$(k - 1)$ 为正，我们需要找到 $sum(l, r)$ 的最大值，这里类似于问题[最大子段和](https://www.luogu.com.cn/problem/P1115)。

- 如果 $k = 1$，$(k - 1) = 0$，总和不变，但必须选择一个区间，因此可以选择单个正数（如果有）或最小的负数（如果全为负）。

### 代码实现

在这里提供 C++ 和 Java 代码。

```cpp
#include<bits/stdc++.h>
#define please return
#define AC 0
#define rep(i, a, b) for(long long i = a; i <= b; i++)
#define repr(i, a, b) for(long long i = a; i >= b; i--)
using namespace std;

typedef long long LL;

signed main() {
	LL n, k, s = 0; cin >> n >> k;
	vector<int> a(n);
	rep(i, 0, n - 1) {
		cin >> a[i];
		s += a[i];
	}
	if(k == 1) {
		cout << s << '\n';
		return 0;
	}
	LL m = a[0], c = a[0];
	rep(i, 1, n - 1) {
		c = max((LL)(a[i]), c + a[i]);
		m = max(m, c);
	}
	LL d = (k - 1) * m;
	cout << s + d << '\n';
	please AC; 
}
```

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		int[] a = new int[n];
		long s = 0;
		for(int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
			s += a[i];
		}
		if(k == 1) {
			System.out.println(s);
			return ;
		}

		long m = a[0], c = a[0];
		for(int i = 1; i < n; i++) {
			c = Math.max(a[i], c + a[i]);
			m = Math.max(m, c);
		}

		long d = (k - 1) * m;
		long r = s + d;
		System.out.println(r);
	}
}
```

---

## 作者：huhengrui2013 (赞：1)

### 题解：P12889 [蓝桥杯 2025 国 Java B] 情绪链路

[传送门](https://www.luogu.com.cn/problem/P12889)

### 题目大意：
有 $n$ 个数，你有一次可以选择一个区间乘上 $k$ 的操作，问区间最大和。

### 思路：
考虑用动态规划求最大子段和 $ans$，再将 $ans$ 乘上 $k-1$（因为总和中包含了一次最大子段和）再加上总和。

### AC Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int a[N],dp[N],ans=-N,m,cnt;
signed main(){
	int n;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
        //dp求最大子段和
		if(i==1) dp[i]=a[i];
		else dp[i]=max(a[i],dp[i-1]+a[i]);
		ans=max(ans,dp[i]);
        //统计总合
        cnt+=a[i];
	}
	cout<<ans*(m-1)+cnt;
	return 0;
}
```

---

## 作者：lcycl (赞：0)

# 思路
选择一个区间乘上一个倍数，使最后的和最大，显然要选择最大子区间来乘。  

所以可以先全部加和，再求出最大子区间，然后加上它的 $k-1$ 倍就好了（全部加和时加了一次最大子区间，所以是 $k-1$）。
# 代码
c++：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100001],k;
signed main(){
	cin>>n>>k;
	int sum=0;
	int maxx=-114514;
	int aaa=-1919810;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
		maxx=max(maxx+a[i],a[i]);
		aaa=max(maxx,aaa);
	}
	cout<<sum+aaa*(k-1);
	return 0;
}
```
java（用 AI 辅助）：
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long k = scanner.nextLong();
        long[] a = new long[(int) n + 1];
        long sum = 0;
        long maxx = -114514;
        long aaa = -1919810;

        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextLong();
            sum += a[i];
            maxx = Math.max(maxx + a[i], a[i]);
            aaa = Math.max(maxx, aaa);
        }
        System.out.println(sum + aaa * (k - 1));
        scanner.close();
    }
}

```

---

## 作者：zhoujunchen (赞：0)

最大子段和，可以用 dp 解决。

用 $dp_i$ 表示以 $a_i$ 结尾的最大子段和。

转移方程：

$$dp_i=\max(dp_{i-1}+a_i,a_i)$$

对 $dp_i$ 取最大值为最大子段和。

然后给最大子段和乘 $k$，加上数列的和，再减去最大子段和（因为数列的和也包括最大子段和，重复算了两遍）。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,a[114514],dp[114514],ans=-1e18,sum;
signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>a[i],sum+=a[i];
    for(int i=1;i<=n;i++)dp[i]=max(dp[i-1]+a[i],a[i]);
	for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
    cout<<ans*k+sum-ans;
    return 0;
}
```


```cpp
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n=scanner.nextInt(),k=scanner.nextInt();
        long[] a=new long[n+1];
        long sum=0;
        for (int i=1;i<=n;i++){
            a[i]=scanner.nextLong();
            sum+=a[i];
        }
        long[] dp=new long[n + 1];
        long ans=Long.MIN_VALUE;
        for(int i=1;i<=n;i++){
            dp[i]=Math.max(dp[i-1]+a[i],a[i]);
            ans=Math.max(ans,dp[i]);
        }
        System.out.println(ans*k+sum-ans);
    }
}
```

---


# 一道恶心的签到题

## 题目背景

愿你们能够不被此题所迷倒。

## 题目描述

小 L 一共有 $n$ 瓶饮料需要拿走，第 $i$ 瓶饮料的重量为 $a_i$。小 L 将会分 $x$ 轮拿饮料（$1 \le x \le n$，$x$ 自定）。每一轮拿饮料，她拿走第 $i$ 瓶（此轮第 $1$ 瓶）饮料耗费的精力值为 $a_i$；假设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$（$1 \le j \le n$）瓶饮料，则拿走这瓶饮料将新耗费 $(k \And a_j) + (k \oplus a_j) - k$ 精力值（$\And$ 表示按位与，$\oplus$ 表示按位异或）。每一轮拿的饮料都是位置连续的一段饮料。我们设第 $i$ 轮拿完饮料总共消耗了 $l_i$ 精力值，请你求出 $\sum\limits_{i=1}^xl_i$。

**简易题面:**

小 L 的面前有 $n$ 瓶饮料，第 $i$ 瓶的重量为 $w_i$。她会分成若干轮把所有饮料全部拿走，第 $p$ 轮中拿走的第 $k$ 瓶（设拿走的第 $k$ 瓶饮料编号为 $d$）会花费体力 $f_{p,k}=\begin{cases}a_d&(k=1)\\(a_d\operatorname{and}\sum\limits_{1\leqslant j<k}f_{p,j})+(a_d\operatorname{xor}\sum\limits_{1\leqslant j<k}f_{p,j})-\sum\limits_{1\leqslant j<k}f_{p,j}&(k\geqslant2)\end{cases}$。若第 $p$ 轮拿走了 $c$ 瓶饮料，则该轮耗费的体力 $s_p=\sum\limits_{k=1}^cf_{p,k}$。若小 L 用了 $m$ 轮把饮料拿完，请问 $\sum\limits_{p=1}^ms_p$ 最小为多少。

## 说明/提示

**【样例解释】**

1. 拿走第二瓶饮料，新耗费 $3$ 精力值。
2. 拿走第一瓶饮料，新耗费 $(3\And 1)+(3\oplus 1)-3=0$ 精力值，并将这两瓶饮料拿走，结束这轮。
3. 拿走第三瓶饮料，新耗费 $8$ 精力值。
4. 拿走第四瓶饮料，新耗费 $(8\And 12)+(8\oplus 12)-8=4$ 精力值，将这两瓶饮料拿走，结束这轮。

总共耗费 $3+0+8+4=15$ 精力值。

**【数据范围】**

对于 $100\%$ 的数据：$1\leq n\leq 10^6$，$0\leq \sum^x_{i=1} l_i \leq 2^{63}-1$，$0\leq a_i \leq 2^{63}-1$。

| 数据点 |     $n\leq $      |      特殊性质       |
| :----: | :----------: | :-----------------: |
|  $1$   |  $9$   |         无          |
| $2\sim3$  | $10^3$ | $\sum l \leq 2^5-1$ |
|  $4$   | $10^3$ |         无          |
| $5\sim10$ | $10^6$ |         无          |

## 样例 #1

### 输入

```
4
1 3 8 12```

### 输出

```
15```

# 题解

## 作者：Sabre (赞：2)

## 题目大意
有 $n$ 瓶饮料，每瓶重量 $a[i]$。分多轮拿取，每轮拿连续若干瓶。每轮消耗为该段饮料重量的按位或值。求最小总消耗。

定义 $dp[i]$ 表示前 $i$ 瓶的最小总消耗，$OR(j+1,i)$ 表示第 $j+1$ 到 $i$ 瓶的按位或值。状态转移方程为：
$dp[i]=\min(dp[j]+OR(j+1,i))$。

```cpp
#include<bits/stc++.h.h>
typedef long long ll;
#define MIN(a,b) ((a)<(b)?(a):(b))
ll f[1000005],a[1000005];  // DP数组和输入数组
ll v1[64],v2[64];          // 维护当前所有可能的OR值和对应最小f值
int vsize;                 // 当前有效OR值数量
int main(){
    // 输入处理
    int n; scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",a+i), f[i]=LLONG_MAX;
    f[0]=0; vsize=0;
    for(int i=1;i<=n;i++){
        ll t1[64],t2[64];  // 临时数组
        int tsize=0;
        // 新增当前元素单独成段的情况
        t1[tsize]=a[i];
        t2[tsize++]=f[i-1];
        // 更新已有OR值
        for(int j=0;j<vsize;j++){
            ll nx = v1[j]|a[i];  // 计算新OR值
            if(tsize && t1[tsize-1]==nx)  // 合并相同OR值
                t2[tsize-1] = MIN(t2[tsize-1],v2[j]);
            else t1[tsize]=nx, t2[tsize++]=v2[j];
        }
        // 更新全局OR值列表
        vsize=tsize;
        for(int j=0;j<tsize;j++) v1[j]=t1[j], v2[j]=t2[j];
        // 计算当前最小代价
        ll mn=LLONG_MAX;
        for(int j=0;j<vsize;j++) mn=MIN(mn,v1[j]+v2[j]);
        f[i]=mn;
    }
    printf("%lld\n",f[n]);
    return 0;
}

---

## 作者：Ghosty_Neutrino (赞：2)

## 题意
如果你去看了简易题面，那么恭喜你被题目做局了，你还不如直接看原来的题目描述。

有 $n$ 瓶饮料，第 $i$ 瓶重量为 $a_i$，分几轮把这些饮料拿完。设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$ 瓶饮料，则拿走这瓶饮料将新耗费 $(k \And a_j )+(k \oplus a_j)−k$ 精力值。每一轮拿的饮料都是位置连续的一段饮料。问拿完所有饮料需要耗费最小精力值是多少。
## 分析
其实就是在一轮中拿走第一瓶体力花费为 $k$，接下来这轮里每多拿一瓶体力就会花费 $(k \And a_i)+(k \oplus  a_i) - k= (k \mid a_i)-k$，总花费体力就变为 $k+(k \mid a_i) - k=k \mid a_i$。

其实根本就不用考虑要分几轮拿，因为一轮全部拿完比分几轮都要费的体力少。不愧是恶心的题目，太会挖坑让你跳。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;//不开 long long 见祖宗，是真的我试过
ll n,x,k;
main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&x);
		k|=x;
	}
	printf("%lld",k);
	return 0;
}
```

够恶心的，代码就这么短我想了老半天。

---

## 作者：Aurelia_Veil (赞：2)

# 题解：P12972 一道恶心的签到题

一看样例就发现答案是 $a_1 | a_2 | \cdots | a_n$，但为什么？

首先，我们要知道一个常识，应该学过位运算的都知道：$x \& y + x \oplus y = x | y$，代入 $k \& a_i + k \oplus a_i - k$ 就会变为 $k | a_i - k$，这就是拿走第 $i$ 瓶对答案的贡献，$k$ 就会变为 $k+k | a_i - k = k | a_i$。

咦！我们可以想想，到底是把这一瓶单独拿出来还是一起拿出来呢，因为一轮中所有的饮料对这一轮答案的贡献是按位或，这肯定不比直接加多啊，所以，直接一轮全部拿走是最优的，答案为 $a_1 | a_2 | \cdots | a_n$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n;
    scanf("%lld",&n);
    long long ans=0;
    for(int i=1;i<=n;i++){
        long long x;
        scanf("%lld",&x);
        ans|=x;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Zskioaert1106 (赞：2)

- 定义 $|$ 为按位或操作。

首先发现 $k\ \&\ a_i + k \oplus a_i = k\ |\ a_i$，则拿走一瓶饮料后的总代价变化为 $k \leftarrow k + k\ |\ a_i -k$，即 $k \leftarrow  k\ |\ a_i$。

容易发现任何一个 $a_i$ 单拎出来加都不如或在里面贡献小，故答案就是所有 $a_i$ 的按位或。

```cpp
#include<iostream>
using namespace std;
const int N=1e6+1;
long long n,a[N],ans;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        ans|=a[i];
    }
    cout<<ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/221715663)。

---

## 作者：Sunny_Boybgfcxc (赞：1)

# P12972 一道恶心的签到题
[更好的阅读体验](https://www.luogu.com.cn/article/y3z02wre/)
## 题意简述
&nbsp;&nbsp;有 $n$ 瓶饮料，第 $i$ 瓶饮料的重量为 $a_i$。现在要分 $x$ 次拿走这些饮料。  
&nbsp;&nbsp;对于拿取第 $i$ 瓶饮料的操作，如果是本轮第一次拿取，那么新耗费 $a_i$ 点精力。否则假设之前已经耗费了 $k$ 点精力，则新耗费 $(k\operatorname{and}a_i)+(k\operatorname{xor}a_i)-k$ 点精力。  
&nbsp;&nbsp;现在问拿完这些饮料所耗费的最小精力值。
## 思路
> 对于 $k$ 和 $a_i$ 的一个二进制位：  
> 如果都为 $0$，那么 $(k\operatorname{and}a_i)+(k\operatorname{xor}a_i)$ 对应位置为 $0+0=0$。  
> 如果都为 $1$,那么 $(k\operatorname{and}a_i)+(k\operatorname{xor}a_i)$ 对应位置为 $1+0=1$。  
> 如果为一个 $1$ 和一个 $0$，那么 $(k\operatorname{and}a_i)+(k\operatorname{xor}a_i)$ 对应位置为 $0+1=1$。
> 
&nbsp;&nbsp;观察到 $(k\operatorname{and}a_i)+(k\operatorname{xor}a_i)=(k\operatorname{or}a_i)$，所以每一次拿去后耗费的总精力值为 $k+(k\operatorname{or}a_i)-k=k\operatorname{or}a_i$，相当于在之前的总耗费上或一个 $a_i$。所以假设有一轮从第 $i$ 瓶饮料拿取到第 $j$ 瓶饮料，那么这一轮的总花费就是 $a_i\operatorname{or}a_{i+1}\operatorname{or}\cdots\operatorname{or}a_{j-1}\operatorname{or}a_j$。  
&nbsp;&nbsp;接下来就要考虑是一轮全部拿完更优还是分几轮拿更优了。  
&nbsp;&nbsp;举个例子：  
&nbsp;&nbsp;如果一轮全部拿完，总花费为 $a_1\operatorname{or}a_2\operatorname{or}\cdots\operatorname{or}a_{n-1}\operatorname{or}a_n$。  
&nbsp;&nbsp;设有第 $p$ 瓶饮料，假设第一轮拿走第 $1$ 到 $p-1$ 瓶饮料，第二轮拿走第 $p$ 到 $n$ 瓶饮料。总花费为 $(a_1\operatorname{or}a_2\operatorname{or}\cdots\operatorname{or}a_{p-1})+(a_p \operatorname{or}a_{p+1}\operatorname{or}\cdots\operatorname{or}a_{n-1}\operatorname{or}a_n)$。  
&nbsp;&nbsp;因为 $\operatorname{or}$ 运算不涉及进位，而加法运算涉及进位，所以一轮拿完的总耗费肯定小于等于分几轮拿完的总耗费。  
&nbsp;&nbsp;故输出 $a_1\operatorname{or}a_2\operatorname{or}\cdots\operatorname{or}a_{n-1}\operatorname{or}a_n$ 即可。
## AC代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,arr[N],ans=0;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
	   cin>>arr[i];
	}
	for(int i=1;i<=n;i++){
		ans=ans|arr[i];
	}
	cout<<ans;
	return 0;
} 
```
[AC记录](https://www.luogu.com.cn/record/222423289)

---

## 作者：luckyyunji (赞：1)

P12972 一道恶心的签到题。~~（求管理员通过）~~

实话实说，作为一道签到题，确实恶心。~~（直接看简易题面）~~

根据观察，发现一瓶饮料的贡献为

$$
k \operatorname{xor} a_j + k \operatorname{and} a_j - k = k \operatorname{or} a_j - k
$$

再加上之前已经耗费 $k$，所以新的 $k$ 就变为 $k \operatorname{or} a_j$。

考虑轮数，因为多轮的答案不如 $1$ 轮的答案，故答案就是对所有数字的按位或。

简单代码如下：

```cpp
/*
luckyyunji
luogu.com.cn
can run c++98 -O2 fast IO
*/
#include <bits/stdc++.h>
using namespace std;
#define int long long  // long long
inline int in()		   // 快读
{
	static char c;
	static int r, f;
	r = f = 0;
	while ((c < 48 || c > 57) && c != 45) c = getchar_unlocked();
	if (c == 45) f = 1, c = getchar_unlocked();
	while (c > 47 && c < 58)
		r = (r << 1) + (r << 3) + (c ^ 48), c = getchar_unlocked();
	return f ? -r : r;
}
void out(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x < 10)
		putchar(x + '0');
	else
		out(x / 10), putchar(x % 10 + '0');
}
signed main() {
	int n, x, ans = 0;
	n = in();
	for (int i = 1; i <= n; i++) {
		x = in();
		ans = ans | x;	// 按位或
	}
	out(ans);
	return 0;
}
// C++98 O2 754B 206ms 680.00KB
```

---

## 作者：WuMin4 (赞：0)

## 思路

一次操作过后：

$$
k=k+(k\&a_j)+(k\oplus a_j)-k
$$

整理得：

$$
k=(k\&a_j)+(k\oplus a_j)
$$

根据或的性质，我们知道：

$$
a|b=(a\&b)+(a\oplus b)
$$

于是：

$$
k=k|a_j
$$

则对于第 $i$ 轮操作的 $m$ 瓶饮料 $x_1,x_2,\cdots,x_m$，$l_i=a_{x_1}|a_{x_2}|\cdots|a_{x_m}$。

容易证明，对于两个数 $a,b$，$a+b$ 一定不会小于 $a|b$。所以最优方案即为一轮全选，答案为所有 $a_i$ 的或。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000005];
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i],a[i]|=a[i-1];
	cout<<a[n];
	return 0; 
}
```

---

## 作者：tomAmy (赞：0)

确实是签到题，并且不要相信简易题面。

我们按题意模拟一下，比如令 $k=(1100)_2,a_j=(1010)_2$。根据题意，每次拿饮料都有 $k \gets k + (k \And a_j) + (k \oplus a_j) - k$。

$$
\begin{split}  k + (k \And a_j) + (k \oplus a_j) - k &= (k \And a_j) + (k \oplus a_j)\\
      &=(1000)_2 + (0110)_2\\
      &=(1110)_2
\end{split}
$$

注意到，所有含 $1$ 的位置都变成了 $1$，不含 $1$ 的位置还是 $0$。如果一次取完的话，每位可能产生一次贡献。如果分次取的话，每位可能产生多次的贡献，一定更劣。

最后只需要根据题意模拟就可以了，时间复杂度 $O(n)$。

代码：
```cpp
#include <iostream>
using namespace std;
typedef unsigned long long ull;
int main()
{
	int n;
	cin >> n;
	ull ans = 0;
	for (int i = 1; i <= n; i++)
	{
		ull x;
		cin >> x;
		ans += (ans & x) + (ans ^ x) - ans;
	}
	cout << ans << endl;
	return 0;
}
```

---


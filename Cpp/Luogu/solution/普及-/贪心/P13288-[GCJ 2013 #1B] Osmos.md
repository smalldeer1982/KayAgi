# [GCJ 2013 #1B] Osmos

## 题目背景

Osmos 由 Hemisphere Games 开发。Hemisphere Games 未参与 Google Code Jam，也未对本题进行任何背书。


## 题目描述

Armin 正在玩一款由 Hemisphere Games 开发的物理益智游戏 Osmos。在这款游戏中，他控制一个“小球”（mote），在空间中移动并吞噬更小的小球。

英文中的 “mote” 意为微粒。在本游戏中，就是一个可以吞噬（或被吞噬）其他物体的东西！本题中的游戏思想与 Osmos 类似，但你无需玩过原作。

当 Armin 的小球吞噬了一个比自己小的小球后，他的小球体积会增加，增长量等于被吞噬小球的体积。此时，他的小球可能能吞噬更多的小球。例如：假设 Armin 的小球初始体积为 $10$，其余小球的体积分别为 $9$、$13$ 和 $19$。开始时，Armin 的小球只能吞噬体积为 $9$ 的小球。吞噬后，他的体积变为 $19$。接着，他只能吞噬体积为 $13$ 的小球。再吞噬后，体积为 $32$。这样，Armin 的小球就可以吞噬最后一个小球了。

注意，只有当另一个小球体积严格小于 Armin 的小球时，他才能吞噬它。如果体积相等，则无法吞噬。

你负责编写用于生成小球的程序，供 Armin 吞噬。程序已经生成了一些不同体积的小球，并生成了 Armin 的小球。不幸的是，给定 Armin 的小球体积和其他小球的体积，有可能无法让 Armin 吞噬所有其他小球。

你需要解决这个问题。你可以进行两种操作，顺序和次数不限：你可以向游戏中添加一个任意正整数体积的小球，或者你可以移除已存在的任意一个小球。请问，最少需要多少次操作才能使 Armin 的小球能够吞噬所有其他小球？

例如，假设 Armin 的小球体积为 $10$，其余小球体积为 $[9, 20, 25, 100]$。此时无法全部吞噬，但你可以添加一个体积为 $3$ 的小球，并移除体积为 $100$ 的小球，仅需 $2$ 次操作即可使问题变得可解。此时答案为 $2$。


## 说明/提示

**样例说明**

虽然输入文件中给定的小球体积有限，但 Armin 的小球在吞噬其他小球后体积可能会超过输入中的限制。

**限制条件**

- $1 \leq T \leq 100$

**小数据集（10 分，测试集 1 - 可见）**

- $1 \leq A \leq 100$
- $1 \leq$ 所有小球体积 $\leq 100$
- $1 \leq N \leq 10$

**大数据集（12 分，测试集 2 - 隐藏）**

- $1 \leq A \leq 10^6$
- $1 \leq$ 所有小球体积 $\leq 10^6$
- $1 \leq N \leq 100$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
4
2 2
2 1
2 4
2 1 1 6
10 4
25 20 9 100
1 4
1 1 1 1```

### 输出

```
Case #1: 0
Case #2: 1
Case #3: 2
Case #4: 4```

# 题解

## 作者：Sweet_2013 (赞：12)

题目解析：我们需要控制一个小球可以吞噬其他更小的小球。当吞噬一个小球后，他的小球体积会增加被吞噬小球的体积。计算最少需要进行多少次操作才能让我们的小球吞噬所有其它小球。

贪心+递归：
- 从大到小排序
- 如果当前小球体积大于它，就直接吞噬，否则：
  - 添加足够多的小球使我们的小球体积增大到能吞噬当前球。
  - 直接移除当前小球。
    
（对于这两种情况，谁小选谁）


```cpp
#include<bits/stdc++.h>
using namespace std;
int js(int a,vector<int>& q, int id) {//id：处理到的小球的编号
    if (id==q.size()) return 0;//所有小球都处理了。
    if(a>q[id]) return js(a+q[id],q,id+1);//可以直接吞噬当前小球。
    else {
        if(a==1) return q.size()-id;//体积为1，由于无法通过添加增大，只能移除。
        int s=0,c=a;
        while(c<=q[id]) {
            c+=c-1;
            s++;
        }
        int l=q.size()-id;
        return min(s+js(c+q[id],q,id+1),l);
    }
}
int t,a,n;
vector<int>q(105);
int main() {
    cin>>t;
    for(int j=1;j<=t;j++) {
        cin>>a>>n;
        q.resize(n);//把 q 的大小调整为 n。
        for(int i=0;i<n;i++) cin>>q[i];
        sort(q.begin(),q.begin()+n);//排序
        cout<<"Case #"<<j<<": "<<js(a,q,0)<<"\n";
    }
}
```

---

## 作者：chenzhuole1 (赞：4)

## 题解：P13288 [GCJ 2013 #1B] Osmos

[题目Link](https://www.luogu.com.cn/problem/P13288)

### 思路

首先简化题意为：给定一个数 $A$ 和一个数组 $s$，$A$ 可以把数组中比自己小的元素吞噬，然后自身加上这个值。有两种操作，一种是添加一个任意的数，或是删除一个现有的数，求至少多少次操作能是数组 $s$ 中的值被 $A$全部吞噬。

考虑贪心。先对数组 $s$ 进行排序，定义一个变量 $res$ 为答案，初始为 $n$，表示全部删除。先从最小的数开始尝试吞噬，能吞噬则吞噬，否则就不断往数组中增加 $A-1$，直到可以吞噬当前的数，最后更新 $ans$。

时间复杂度为 $O(N \times T)$。

### Code


```

#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a,m[105];
int sol()
{
	cin>>a>>n;
	for(int i=1;i<=n;i++) cin>>m[i];
	sort(m+1,m+n+1);
	int ans=n,op=0;
	if(a==1) return ans;
	for(int i=1;i<=n;i++){
		while(a<=m[i]){
			a+=a-1;
			op++;
		}
		a+=m[i];
		ans=min(ans,op+n-i);
	}
	return ans;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>t;
	for(int i=1;i<=t;i++)
		cout<<"Case #"<<i<<": "<<sol()<<'\n';
	return 0;
}

```

---

## 作者：IkillDream (赞：4)

# P13288 题解

## 思路

因为一开始球的大小是不固定的，所以我们可以先从小到大把它排一下序。

接下来再使用贪心算法：

如果当前 Armin 的小球体积 $A$ 可以吞噬下一个最小的球，

能，直接吞噬。

如果不能吞噬，考虑：

1. 添加小球：最优策略是添加 $A-1$（最大化 Armin 的小球增长）。

1. 移除小球：直接移除无法吞噬的球（可能减少总操作次数）。

最后模拟以上操作即可。

## [AC](https://www.luogu.com.cn/record/225039465) 代码

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	for(int k=1;k<=t;k++){
		long long a,n;
		cin>>a>>n;
		vector<long long> v(n);
		for(int i=0;i<n;i++) cin>>v[i];
		sort(v.begin(),v.end());
		int res=1e9;
		for(int d=0;d<=n;d++){
			long long cur=a;
			int cnt=0;
			bool ok=1;
			for(int i=0;i<n-d;i++){
				while(cur<=v[i]){
					if(cur==1) {ok=0;break;}
					cur+=cur-1;
					cnt++;
				}
				if(!ok)break;
				cur+=v[i];
			}
			if(ok)res=min(res,cnt+d);
		}
		cout<<"Case #"<<k<<": "<<res<<endl;
	}
	return 0;
}
```

## 后记

以上代码花费了我将尽 $30$ 分钟的时间，如果决的我的题解写的好的话可以点个赞吗 qwq。

题解可以抄，但是你要学会哦！

---

## 作者：Ghosty_Neutrino (赞：3)

## 题意
Armin 控制一个小球，能吞噬体积严格小于自身的其他小球，吞噬后自身体积会增加被吞噬小球的体积。现在给定 Armin 小球的初始体积和其他一些小球的体积，可能无法让他吞噬所有其他小球。
 
我们可以进行两种操作（次数和顺序不限）：
 
- 向游戏中添加任意正整数体积的小球。

- 移除已存在的任意一个小球。
 
需要找到最少的操作次数，使得 Armin 的小球最终能够吞噬所有剩余的其他小球。
## 分析
将其他小球按体积从小到大排序，便于从小到大依次吞噬。

能吞噬当前小球时，直接吞噬并增加体积。

不能吞噬时：
- 若自身体积为 $1$（无法通过添加小球增大，因添加的小球体积需小于 $1$，不可能），只能移除当前小球。

- 否则计算需添加的小球数量，使自身体积增长到能吞噬当前小球。

每步都需考虑"移除所有剩余小球"的成本，避免无效操作。

每次添加体积为当前体积 $-1$ 的小球（最大化体积增长），直到能吞噬目标小球，记录所需添加次数。

需比较不同策略的操作成本，选择最小结果。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int casen=1; casen<=t;casen++){
        long long a;
        int n;
        cin>>a>>n;
        vector<long long> mot(n);
        for (int i=0;i<n;i++) cin>>mot[i];
        sort(mot.begin(), mot.end());
        long long s=a;  // 当前体积
        int res=0;      // 操作次数
        int i=0;        // 当前处理的小球索引
        int best=n;     // 最优解初始化为移除所有小球
        while(i<n){
            if(s>mot[i]){
                // 可以吞噬，直接处理
                s+=mot[i];
                i++;
            }else{
                if(s==1){
                    // 体积为 1 时只能移除
                    res++;
                    i++;
                }else{
                    // 计算需要添加的小球数量
                    int k=0;
                    long long ts=s;
                    while(ts<=mot[i]&&k<=(n-i)){
                        ts+=ts-1;  // 添加最大可能的小球
                        k++;
                    }
                    // 判断添加是否划算
                    if(ts>mot[i]&&k<=(n-i)){
                        best=min(best, res+(n-i));  // 考虑移除所有剩余
                        res+=k;
                        s=ts+mot[i];  // 吞噬当前小球
                        i++;
                    }else{
                        // 添加不划算，移除当前小球
                        res++;
                        i++;
                    }
                }
            }
            // 每次操作后更新最优解
            best=min(best, res+(n-i));
        }
        best=min(best, res);  // 最后比较最终状态
        
        cout<<"Case #"<<casen<<": "<<best<< endl;
    }
    return 0;
}
```

---

## 作者：tujiaqi12 (赞：1)

## 思路
第一步，将球的大小排序。

第二步，贪心。注意以下文字。

- 吞噬小球一定是从小往大吞。
- 在进行添加操作时，若当前球大小为 $a$，则新添加的球大小一定是 $a-1$。
  
第三步，递推遍历，先用 $ans1$ 来记录只进行删除操作时的答案。

第四步，递推遍历，在第三步的同时，用 $ans2$ 来记录不进行删除操作时的答案，见代码。

```cpp
while(c[j] >= a){
	a = a + a - 1;
	ans2++;
	if(a <= 1){
		ans2 = (ll)(1e18);
		break;
	}
} 
a += c[j];
```
最后，再用 $ans2$ 来调整 $
ans1$。

```cpp
ans1 = min(ans1,ans2);
```
## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll t,n,a;
ll c[105];
int main(){
	scanf("%lld",&t);
	for(ll i = 1;i<=t;i++){
		scanf("%lld%lld",&a,&n);
		for(ll j = 1;j <= n;j++){
			scanf("%lld",&c[j]);
		}
		sort(c+1,c+n+1);
		ll ans1 = 0;
		ll ans2 = 0;
		ll a2 = a;
		for(ll j = 1;j <= n;j++){ 
			ans1++;
			while(c[j] >= a2){
				a2 = a2 + a2 - 1;
				ans2++;
				if(a2 <= 1){
					ans2 = (ll)(1e18);
					break;
				}
			} 
			a2 += c[j];
			ans1 = min(ans1,ans2);
		}
		printf("Case #%lld: %lld\n",i,ans1);
	}
	return 0;
}
```

---

## 作者：HJH_2024 (赞：1)

## P13288 [GCJ 2013 #1B] Osmos
[题目](https://www.luogu.com.cn/problem/P13288)
### 思路
题目标签为贪心，因此考虑贪心。

首先将其他小球的体积按升序排序，方便贪心操作。

 然后遍历排序后的小球体积。对于每个小球，如果Armin的小球体积大于该小球，直接吞噬并增加体积；否则，考虑添加小球或移除当前小球：添加小球（体积为 $a-1$ ）或是移除小球。
 
最后选择最优操作，在无法直接吞噬时，比较添加和移除操作的剩余步骤，选择操作次数较少的方案。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int solve(){
	int a,n;
	cin>>a>>n; // a:Armin初始大小 n:小球数量
	int v[n];
	for(int i=0;i<n;++i)cin>>v[i];
	sort(v,v+n); // 将小球按大小排序
	int ans=INT_MAX,ops=0,i=0;// ans:最小操作次数 ops:当前操作数 i:当前处理小球
	while(i<n){
		if(a>v[i]){
			a+=v[i];
			i++;
		} // 能吸收就直接吸收
		else{
			ans=min(ans,ops+n-i);// 记录移除剩余小球的操作次数
			if(a==1)break;// 无法继续增大时退出
			a+=a-1;// 添加一个a-1大小的小球
			ops++;// 操作计数
		}
	}
	if(i==n)ans=min(ans,ops); // 全部吸收完成的情况
	return ans;
}

int main(){
	int t;
	cin>>t;
	for(int i=1;i<=t;++i){
		cout<<"Case #"<<i<<": "<<solve()<<endl;
	}
	return 0;
}
```
##### 管理员求过， QWQ

---

## 作者：Xjj2013_0405 (赞：1)

## 思路 ##

这是一道典型的贪心题。
先记录 Armin 小球重量和其它小球重量，之后对其他小球重量进行排序，然后遍历每个小球，如果当前 Armin 小球重量可以吞下这个小球，那么 Armin 的当前重量增加这个小球的重量。如果不行，那就增加一个体积为比 Armin 小球重量体积少一的小球（如果 Armin 的当前重量为一记得把能否通过添加小球完成任务标记为否并直接跳出），之后标记，如果标记为是就让 Armin 吞噬小球。最后算总次数，用添加小球次数加上需移除的小球（就是未判断的小球），并记录最小值。最后的最后，按题目格式输出就好啦。
## 代码 ##
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//个人习惯
const int N=1e2+10;
int T,n,x,a[N];
signed main(){
	cin>>T;//测试样例数 
	for(int t=1;t<=T;t++)
	{
		memset(a,0,sizeof(a));//多测清空 
		cin>>x>>n;//Armin小球重量和其它小球数量 
		for(int i=1;i<=n;i++) cin>>a[i];//输入其它小球重量
		sort(a+1,a+1+n);//排序，便于后比较 
		int minn=n,now=x,step=0;//最小次数（minn,初始为删除所有小球，为n），当前Armin小球重量（now），添加小球次数（step） 
		bool f=1;// 记录能否通过添加小球完成任务 
		for(int i=1;i<=n;i++)
		{
			if(now>a[i])//如果可以吞噬就吞噬 
			{
				now+=a[i];//Armin小球重量增加 
			}
			else{
				while(now<=a[i])//如果不可以 就操作 
				{
					if(now==1)// 如果Armin小球重量为1，就肯定不行 
					{
						f=0;//标记不行，并跳出 
						break;
					}
					now+=now-1;//增加一个体积为now-1的小球 
					step++;//次数+1 
				}
				if(!f) break;// 标记为否，跳出 
				now+=a[i]; 
			}
			int big_step=step+(n-i);//总次数=添加小球次数+需移除的小球数 
			minn=min(minn,big_step);//计算最小次数 
		}
		cout<<"Case #"<<t<<": "<<minn<<"\n";//输出 
	}
	return 0//完结撒花
} 
```

---

## 作者：GZXUEXUE (赞：1)

### 思路

首先，令 Armin 优先吃掉所有当前能吃的（即较小的）小球肯定是前半部分的最优解，因为这样不会耗费操作步数，又能令 Armin 的小球体积更大。所以我们先对所有小球按体积排序，然后吃掉能吃的球。

接下来应该讨论吃不掉的球。  
我们分两类情况讨论：  
1. 给 Armin 再喂几个球直到能吃下这个球，但是要喂 Armin 能吃得下的最大的，即当前球的体积减去 $1$。因为万一后面吃不下还得喂，所以喂多点的做法显然不会更劣。
2. 删掉这个球，然后处理接下来的。

所以这个做法的时间复杂度是 $O(2^N \times T)$，外加亿点点啸常数。  
所以 T 了。（  
所以我们需要优化一下。回到上文的思路，在处理这个球时，我们删掉这个球之后继续处理下一个球，但是下一个球显然更大，所以你只能继续删掉。  
为什么只能继续删掉？因为如果再喂几个球的话，Armin 的体积显然将大于下一球的体积，但是这样一来就不用耗费刚才的步数删掉当前的球了，步数更劣。

于是时间复杂度被优化为 $O(N \times T)$。

### 实现

```cpp
# include <algorithm>
# include <iostream>
# define int long long
# define prn(case_,x) printf("Case #%lld: %lld\n",(case_),(x))
using namespace std;
int n,v[105];
int dfs(int idx,int now,int cost){
	if (idx > n) return cost;
	int add = 0,a = now;
	while (a <= v[idx]) a += (a - 1),add++;
	return min(dfs(idx + 1,a + v[idx],cost + add),n - idx + 1 + cost);
}void mian(int case_){
	int a,del = 0,add = 0; cin >> a >> n;
	for (int i = 1;i <= n;i++) cin >> v[i];
	if (a == 1){ prn(case_,n); return; }
	sort(v+1,v+1+n);
	int i = 1; for (;i <= n && a > v[i];a += v[i++]);
	# ifdef DEBUG
		cout << i << " " << a << endl;
	# endif
	prn(case_,dfs(i,a,0));
}signed main(){
	int T,t = 0; cin >> T; T++;
	while (++t != T) mian(t);
	return 0;
}
```

---

## 作者：xiaowenxu_qwq (赞：0)

# 思路

对于每个测试的输入，先对其他小球体积进行排序，再枚举保留的小球数量。

- 从初始体积 $A$ 开始，依次尝试吞噬前 $i$ 个小球。
- 若当前体积不足以吞噬小球，则通过添加小球来增长体积（吞噬后体积变为 $2\times a_i - 1$），直到可以吞噬。
- 若当前体积为 1（无法添加），标记为无效。

AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
int a[100001];
signed main(){
    int T=read();
    for(int t=1;t<=T;t++){
        int A=read(),n=read();
        for(int i=1;i<=n;i++)
           a[i]=read();
        sort(a+1,a+n+1);
        int ans=n;
        for (int i=1;i<=n;i++){
            int cnt=A,add=0;
            bool book=true;
            for (int j=1;j<=i;j++){
                if(cnt>a[j])
                    cnt+=a[j];
                else{
                    if(cnt==1){
                        book=false;
                        break;
                    }
                    while(cnt<=a[j]) {
                        add++;
                        cnt=2*cnt-1;
                    }
                    cnt+=a[j];
                }
            }
            if(book){
                int tot=add+(n-i);
                if (tot<ans)
                    ans=tot;
            }
        }
        printf("Case #%lld: %lld\n",t,ans);
    }
    return 0;
}
```

---

## 作者：_____1__2___ (赞：0)

# P13288 Osmos题解  
这道题目的思路就是对于输入的小球进行排序，依次遍历它们，每次遍历可以有三种选择
*   如果当前小球比遍历小球大，那么直接吃掉小球，大小增加
*   如果比当前小球比较小，可以选择创造一个新的球，然后再吃掉遍历小球
*   可以直接删除遍历小球

对于第二种情况，可以直接想到，当前小球可以吃的最大球一定是它的大小减一，所以当前小球 $A\to 2A-1$。

由于最差的情况是删除所有小球，所以总方案数不会超过 $n$。

代码实现如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[150];
int main() {
    int T;
    cin >> T;
    for (int c = 1; c <= T; c++/*0v0*/) {
        int A, n;
        cin >> A >> n;
        for (int i = 1;i <= n; i++) {
            cin >> a[i];
        }
        sort(a+1, a+1+n);
        int mi = n, temp = 0;
        bool f = true;
        for (int i = 1;i <= n; i++) {
            if (A > a[i]) {
                A += a[i];
            } else {
                while (A <= a[i] && A > 1) {
                    A += A - 1;
                    temp++;
                }
                if (A <= a[i]) {
                    f = false;
                    break;
                }
                A += a[i];
            }
            int cp = temp+n-i;
            mi=min(mi,cp);
        }
        cout << "Case #" << c << ": ";
        if (f) cout << mi << endl;
        else cout << n << endl;
        
    }
    return 0;
}

```

---

## 作者：Clouds_dream (赞：0)

### 题目大意
[题目大意](https://www.luogu.com.cn/problem/P13288)

### 题目分析
由于题目中没有说必须按顺序来吞噬，所以我们先把小球从小到大排序。  
接下来，我们有两种选择：

- 移除当前吞不掉的球（因为我们已经排序，这样做可能导致后面的小球都被移除）。
- 添加一个比当前体积小一的球（为了最大化小球体积）。

枚举每个小球即可。  

**注意：** 如果当前体积为 1，则无法再添加小球，需移除所有小球。

### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

#define int long long

int ti;

void f(int t){
	int a,n;
	cin>>a>>n;
	int q[n+10];
	for(int i=1;i<=n;i++){
		cin>>q[i];
	}
	sort(q+1,q+n+1);
	int ans=n;//最多移除所有小球
	for(int i=1;i<=n;i++){
		int cur=a;//当前体积
		int jia=0;//添加次数
		bool flag=1;//标记是否可以吞噬前i个小球
		for(int j=1;j<=i;j++){
			while(cur<=q[j]) {//不能吞
                if(cur==1){//体积为 1
                    flag=0;
                    break;
                }
                cur+=(cur-1);//选择二
                jia++;
            }
            if(!flag) {
                break;
            }
            cur+=q[j];
		}
		if(flag){
            int tot=jia+n-i;//总操作次数 = 添加次数 + 移除次数
            if(tot<ans) {
                ans=tot;
            }
        }
	}
	cout<<"Case #"<<t<<": "<<ans<<endl;
}

signed main()
{
	fst
	cin>>t;
	for(int t=1;t<=ti;t++){
		f(t);
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# [P13288 [GCJ 2013 #1B] Osmos](https://www.luogu.com.cn/problem/P13288)
## 题目介绍：
Armin 的球有一个体积，这个球可以吞噬一个比自己小的球（不能等于），吞噬后，这个小球体积会增加，增长量等于被吞噬的球的体积。

如果不能吞噬，进行两种操作，顺序和次数不限：可以向游戏中添加一个任意正整数体积的小球，或者可以移除已存在的任意一个小球。

最少需要多少次操作才能使 Armin 的小球能够吞噬所有其他小球？

## 分析做法：
很简单的一道**贪心**题。

主要在于判断到底是吞噬增加的小球还是移去小球，可以使用**贪心**策略，尽可能吞噬小球。如果当前小球无法被吞噬，则通过吞噬一个**体积比现在球的体积减一的小球**来增大现体积，直到可以吞噬当前小球。每次添加操作次数增加，并比较**当前操作次数**加上**剩余小球**数量（即移除剩余所有小球的操作次数）与当前最优解。

在这之前，你必须要进行排序，否则贪心策略并不是最优解。并且判断**最差**情况（移除所有小球）。

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T;
    cin >> T;
    for (int case_num = 1; case_num <= T; ++case_num) {
        int x, n;
        cin >> x >> n;
        int a[100];
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        sort(a, a + n);
        int ans = n;
        int sum = 0;
        if (x == 1) {
            cout << "Case #" << case_num << ": " << ans << endl;
            continue;
        }
        for (int i = 0; i < n; ++i) {
            while (x <= a[i]) {
                x += x - 1;
                sum++;
            }
            x += a[i];
            ans = min(ans, sum + (n - i - 1));
        }
        ans = min(ans, sum);
        cout << "Case #" << case_num << ": " << ans << endl;
    }
    return 0;
}
```

谢谢观看，求过求赞。

---


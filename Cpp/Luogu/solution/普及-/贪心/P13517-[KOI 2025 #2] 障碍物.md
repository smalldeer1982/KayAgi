# [KOI 2025 #2] 障碍物

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

你正在和朋友们一起在操场上玩跳跃障碍物的游戏。游戏从数轴上的位置 0 开始，各个障碍物从左到右依次放置在 $X_1 < X_2 < ... < X_N$ 的位置上。其中 $X_1 \ge 1$。

你的目标是跳过放置在数轴上的所有 $N$ 个障碍物。为了实现这个目标，你可以进行以下两种行动：

*   向右走 1 步。即，如果从位置 $x$ 开始，将会到达位置 $x+1$。
*   向右跳 2 步。即，如果从位置 $x$ 开始，将会到达位置 $x+2$。

跳过障碍物，意味着必须通过“跳跃”动作越过该障碍物。换句话说，要跳过位于位置 $X_i$ 的障碍物，你必须从位置 $X_i - 1$ 向右跳跃 2 步，从而到达位置 $X_i + 1$。

例如，假设如下图所示，在数轴上的位置 2、5、11 处放置有障碍物。

![](https://cdn.luogu.com.cn/upload/image_hosting/r6cdstuj.png)

可以通过以下几种方法跳过所有障碍物。下文中，$\rightarrow$ 表示行走，$\implies$ 表示跳跃。

*   方法 1: $0 \rightarrow 1 \implies 3 \rightarrow 4 \implies 6 \rightarrow 7 \implies 9 \rightarrow 10 \implies 12$ (共移动 8 次，跳过 3 个障碍物)
![](https://cdn.luogu.com.cn/upload/image_hosting/qhduz50k.png)
*   方法 2: $0 \rightarrow 1 \implies 3 \rightarrow 4 \implies 6 \implies 8 \implies 10 \implies 12$ (共移动 7 次，跳过 3 个障碍物)
![](https://cdn.luogu.com.cn/upload/image_hosting/3ucfl5v1.png)
但是，使用以下方法则无法跳过所有障碍物。

*   方法 3: $0 \implies 2 \implies 4 \implies 6 \implies 8 \implies 10 \implies 12$ (共移动 6 次，跳过 2 个障碍物)
![](https://cdn.luogu.com.cn/upload/image_hosting/jyrzfkbk.png)

*   方法 4: $0 \rightarrow 1 \implies 3 \implies 5 \implies 7 \implies 9 \rightarrow 10 \implies 12$ (共移动 7 次，跳过 2 个障碍物)
![](https://cdn.luogu.com.cn/upload/image_hosting/fz3udx03.png)

*   方法 5: $0 \rightarrow 1 \implies 3 \rightarrow 4 \rightarrow 5$ (共移动 5 次，跳过 1 个障碍物)
![](https://cdn.luogu.com.cn/upload/image_hosting/pbilv3k5.png)

在各个示例中，**移动次数**是行走次数和跳跃次数的总和。在这个示例中，方法 2 是用最少移动次数跳过所有障碍物的最佳方法。

你需要找到一种将**移动次数**最小化、能够跳过所有障碍物的最佳方法。但是，也可能存在仅用给定的两种行动无法跳过所有障碍物的情况。

## 说明/提示

### 限制条件

*   所有给定的数都是整数。
*   $1 \le N \le 250\,000$
*   $1 \le X_1 < X_2 < ... < X_N \le 250\,000$

### 子任务

1.  (7 分) $N = 1, X_1 \le 5$
2.  (12 分) $N = 1, X_1 \le 5\,000$
3.  (23 分) 对于所有满足 $1 \le i \le N$ 的 $i$，$N \le 5\,000$ 且 $X_i \le 5\,000$
4.  (58 分) 无额外限制条件。

## 样例 #1

### 输入

```
3
2 5 11```

### 输出

```
7```

## 样例 #2

### 输入

```
3
7 20 25```

### 输出

```
14```

## 样例 #3

### 输入

```
4
1 4 5 8```

### 输出

```
-1```

# 题解

## 作者：chen_zhe (赞：2)

### 子问题 2

要跳过障碍物 $X_1$，必须从 $X_1 - 1$ 的位置起跳。因此，我们首先求出从起点 0 到达 $X_1 - 1$ 的最小移动次数，然后再加上最后一次跳跃，就能得到总的最小移动次数。

从起点到 $X_1 - 1$ 的距离是 $D = X_1 - 1$。在移动这段区间时，最优策略是尽可能多地使用移动距离为 2 的跳跃。如果 $D$ 是偶数，仅用跳跃就可以到达 $X_1 - 1$；如果 $D$ 是奇数，则必须有一次走一步（移动距离为 1）。因此，到达 $X_1 - 1$ 的最小移动次数可以求得为 $\lceil D/2 \rceil$。在此基础上加上最后一次跳跃，答案就是 $\lceil D/2 \rceil + 1$。

### 子问题 4

即使需要跳过多个障碍物，其基本原理也与子问题 2 相同。为了跳过每个障碍物 $X_i$，必须从位置 $X_i - 1$ 起跳并降落在 $X_i + 1$，因此可以把问题分解为在障碍物之间的各个区间进行移动。也就是说，可以采用这样的方式来解决问题：先求出从跳过前一个障碍物后的位置 $X_{i-1} + 1$ 移动到下一个障碍物前的位置 $X_i - 1$ 所需的最小移动次数，然后再为此加上一次用于越过障碍物的跳跃。

如果相邻的两个障碍物之间的距离恰好为 1 ($X_i + 1 = X_{i+1}$)，那么跳过前一个障碍物后本应降落的位置，恰好就是下一个障碍物的位置，这样就无法跳过下一个障碍物了。在这种情况下，无法跳过所有障碍物，因此输出 -1。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
int n, x[250250];
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> n;
    for(int i=1;i<=n;i++) cin >> x[i];

    int ans = x[1]/2 + 1;
    for(int i=2;i<=n;i++) {
        if(x[i-1]+1 == x[i]) {
            cout << -1;
            return 0;
        }
        ans += (x[i]-x[i-1]-1)/2 + 1;
    }
    cout << ans;
}
```

---

## 作者：王曦2012 (赞：2)

### 一、递推及转移方程
>读题之后，考虑使用类似 递推 的方法，设 $f_i$ 表示走到 $i$ 坐标所需的最少移动次数。所以就可以得出没有障碍物的转移方程：
>$$
>f_{i+1} = f_{i-1} + 1
>$$
>这个转移方程的原因是：从一个点到另外一个点用跳两步的移动方法一定比走一步的移动方法要更优。
### 二、特殊情况：
>1. 两个障碍物紧挨在一起，也就是 $x_i == x_{i-1}+1$ 的时候，无论是跳还是走，都会到达有障碍物的地方，所以这时无法跳过所有障碍物，直接输出 `-1`。
>2. $i-1$、$i$ 或 $i+1$ 为障碍物。我们可以将障碍物的地方 $f_{x_i}$ 打上标记 $-1$，当跳两步的起点 $f_{i-1}$ 为 $-1$ 时，就只能从 $f_{i}$ 走一步的方法转移，也就是 $f_{i+1} = f_{i} + 1$；当走一步的起点 $f_{i}$ 为 $-1$ 时，就还是最初的方程。当$f_{i-1},f_{i}$都为  $-1$ ，或者 $f_{i+1}$ 本来就是 $-1$ 时，方程无法转移，$f_{i+1}$ 就只能是为 $-1$。
>::::::warning[注意]{open}
>$x_0$ 也设为 $-1$，但 $f_0$ 为 $0$。  
>:::::warning[为什么？]{open}
>因为当 $x_1 = 1$ 时，如果 $x_0$ 默认为 $0$ 的话，就会使 $x_i == x_{i-1}+1$ 成立，输出 `-1`，因此，上述这样保证了所有障碍物不会判多。
>:::::
>::::::

### 三、初始化、起止值和答案。
>因为转移方程最小下标为 $i-1$，且开始在下标 $0$，所以从 $1$ 开始。初始化 $f_0 = 0$。但因为我们没有考虑 $f_1$ 可能是从 $f_0$ 转移的情况，所以当 $f_1$ 不为 $-1$ 时，$f_1 = f_0+1$。最后终点为最后一个障碍物后面 $x_{n}+1$，所以循环起止点应为 $[1,x_{n}+1)$，答案为 $f_{x_{n}+1}$。  
### 四、标程：
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,x[250005],f[250005];

int main()
{
    memset(f,0x3f,sizeof(f));
    scanf("%d",&n);
    x[0] = -1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x[i]);
        f[x[i]] = -1;
        if(x[i] == x[i-1]+1)
        {
            printf("-1");
            return 0;
        }
    }
    f[0] = 0;
    if(!(f[1] == -1))
    {
        f[1] = f[0]+1;
    }
    for(int i=1;i<x[n]+1;i++)
    {
        if((f[i] == -1 && f[i-1] == -1)|| f[i+1] == -1)
        {
            f[i+1] = -1;
        }
        else if(f[i] == -1)
        {
            f[i+1] = f[i-1]+1;
        }
        else if(f[i-1] == -1)
        {
            f[i+1] = f[i]+1;
        }
        else
        {
            f[i+1] = f[i-1]+1;
        }
    }
    printf("%d",f[x[n]+1]);

    return 0;
}

```

---

## 作者：Chengqijun2012 (赞：1)

# 题解：P13517 [KOI 2025 #2] 障碍物

一道 dp 好题，非常值得刚学 dp 的同学练手。

## 题目大意：
有一个数轴，从位置 $0$ 开始每次移动可以前进一格或两格，再给你 $n$ 个不能踩的障碍物，求**越过** $n$ 个障碍物所需要的最小移动次数。

## 解题步骤：
我们先考虑无解的情况。根据题目描述，无解的情况存在一个数轴上的**非障碍物**点 $x$，从这个点开始无论是前进一格还是两格都会踩到障碍物上，也就是 $x+1$ 和 $x+2$ 均为障碍物。推广一下其实就是：当有两个的障碍物**相邻**时必无解，输出 `-1`。

接下来就是 dp 部分：

1. 定义状态：设 $dp_{i}$ 为从第 $0$ 个点跳过中间的所有障碍物到第 $i$ 个点所需的最少移动次数。
2. 列状态转移方程：观察题目发现，对于数轴上任意一点 $i(i>1)$，都有 $i-1$ 和 $i-2$ 可以到达点 $i$，同理 $dp_{i}$ 也应由 $dp_{i - 1}$ 和 $dp_{i - 2}$ 转移而来。于是推出状态转移方程：$dp_{i} = \min(dp_{i - 1}, dp_{i - 2}) + 1$。
3. 初始化：因为是求最少移动次数，所以 $dp$ 数组应初始化为一个极大值。
4. 处理边界或特殊情况：请看代码注释。

## 时间复杂度：
因为这题是线性 dp，状态转移方程也是在 $O(1)$ 的复杂度内完成的，所以总体时间复杂度为 $O(n)$。

AC Code：
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
#include <climits>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <bitset>
#include <cstdio>
#define ll long long
#define P pair<int, int>
#define MP make_pair
#define PU push_back
#define li(x) x << 1
#define ri(x) (x << 1) | 1
using namespace std;
const ll LLF = LLONG_MAX >> 2;
const int INF = INT_MAX >> 1;
const int N = 25e4 + 5;
int n, a[N], dp[N];
bitset<N> vis;      //用于记录该点是否是障碍物，可用bool数组代替

inline ll read(){
	ll f = 1, x = 0;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
	while('0' <= c && c <= '9') x = (x << 3) + (x << 1) + (ll)(c - '0'), c = getchar();
	return x * f;
}

inline void write(ll x){
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int main(){
//	freopen("water.in.txt", "r", stdin);
//	freopen("water.out.txt", "w", stdout);
	
//	ios::sync_with_stdio(false);
//  cin.tie(0), cout.tie(0);
	
	n = read();
	for(int i = 1; i <= n; ++i){
		a[i] = read();
		if(i > 1 && a[i] - a[i - 1] == 1) puts("-1"), exit(0);      //如果上一个障碍物的坐标与这个障碍物的坐标仅相差1，说明两个障碍物相邻，无解
		vis[a[i]] = 1;
	}
	int m = a[n] + 1;      //题目中并没有给出明确的终点，但是只要跨过所有障碍物就算成功，我们不妨直接把终点设为最后一个障碍物的后一个点
	for(int i = 0; i <= m; ++i) dp[i] = INF;
	dp[0] = 0;      //从0点到0点的步数为0
	for(int i = 1; i <= m; ++i){
		if(vis[i]) continue;      //如果该点是障碍物，直接跳过
		if(i == 1) dp[i] = dp[i - 1] + 1;      //i=1时直接转移，防止调用dp[i-2]时数组越界
		else if(vis[i - 1]) dp[i] = dp[i - 2] + 1;      //若第i-1个点是障碍物，直接转移第i-2个点
		else if(vis[i - 2]) dp[i] = dp[i - 1] + 1;      //若第i-2个点是障碍物，直接转移第i-1个点
		else dp[i] = min(dp[i - 1], dp[i - 2]) + 1;      //若无特殊情况，按状态转移方程转移
	}
	write(dp[m]), putchar('\n');
	return 0;
}
```
完结撒花！！！

---

## 作者：Bill_luogu (赞：1)

这道题有两种方法 AC。
## 方法一：模拟
设 $now$ 表示当前跳到的位置，$last$ 表示 $now$ 以后的第一个障碍物，由于题目要求所有障碍物所需的移动次数最少，所以我们尽可能跳两步。对于每次跳跃，有四种情况：
- $now+1=X_{last}$ 且 $now+2=X_{last+1}$，即当前跳一步还是两步都不行，输出 `-1`；
- $now+2>X_{last}$，即可以跳过，直接跳，$now\gets now+2,last\gets last+1$；
- $now+2=X_{last}$，即跳两步刚好跳到障碍物上，只能跳一步，$now\gets now+1$；
- $now+2<X_{last}$，即跳两步没跳到障碍物上，直接跳，$now\gets now+2$；
## AC Code：
```cpp
#include<iostream>
using namespace std;
int n,a[250001],ans,now;
int last;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    last=1;
    while(now<a[n]&&last<=n)
    {
        if(now+1==a[last]&&now+2==a[last+1])//判断无解
        {
            cout<<-1;
            return 0;
        }
        if(now+2>a[last])last++,now+=2, ans++;//刚好跳过障碍物
        else if(now+2==a[last])now++,ans++;//会跳到障碍物，只跳一步
        else now+=2,ans++;//跳不到障碍物，跳两步
    }
    cout<<ans;
    return 0;
}
```
时间复杂度约为 $O(X_{n})$。
## 方法二：贪心
先判无解，当 $X_{i-1}+1=X_{i}(i\ge2)$ 时，怎么跳都跳不过，输出 `-1`。

从 $0$ 开始跳跳过 $X_{1}$ 的障碍物，需要 $\lfloor\frac{X_{1}}{2}\rfloor+1$ 次跳跃（跳到 $X_{1}-1$ 需要 $\lfloor\frac{X_{1}}{2}\rfloor$ 次，跳过一次）。

以此类推，从 $X_{i-1}$ 跳到 $X_{i}$ 需要跳 $\lfloor\frac{(X_{i}-X_{i-1}-1)}{2}\rfloor+1(i\ge2)$ 次（上一次跳到 $X_{i-1}+1$，跳到 $X_{i}-1$ 要$\lfloor\frac{(X_{i}-X_{i-1}-1)}{2}\rfloor$ 次，跳过一次）。
## AC Code：
```cpp
#include<iostream>
using namespace std;
int n,a[500000];
int ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(i>=2&&a[i-1]+1==a[i])//无解
        {
            cout<<"-1";
            return 0;
        }
    }
    ans=a[1]/2+1;
    for(int i=2;i<=n;i++)
        ans=ans+(a[i]-a[i-1]-1)/2+1;//距离为 X[i]-1-(X[i-1]+1)+1=X[i]-1-X[i-1]
    cout<<ans;
    return 0;
}
```
时间复杂度 $O(n)$，拿下[最优解](https://www.luogu.com.cn/record/227759382)。

---

## 作者：sunhaoyun (赞：1)

## 贪心

**思路：**

初始化：用数组 $b$ 来记录障碍物的位置，即第 $i$ 个障碍物在 $b_{x_i}$ 个位置。

核心部分：用 $ i $ 来模拟跳跃的过程，当第 $b_{i + 2}$ 的位置没有障碍物时，就跳到 $b_{i+2}$ 的位置，当$b_{i + 2}$ 有障碍物的时候，就先跳一格， 再跳两格（如下图所示）, 然后用变量 $cnt$ 来记录跳的次数。

![](https://cdn.luogu.com.cn/upload/image_hosting/aa86uxge.png)

无法跳过的判断：当两个障碍物连在一起时, 无法跳过。（如下图，只有一次性跳三格时，才能跳过）

![](https://cdn.luogu.com.cn/upload/image_hosting/9psekwbh.png)


最后贴上代码（注释会解释一些细节问题）：
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, x, cnt;

bool b[500010];

int main()
{
	cin >> n;
	for(int i = 0;i < n;i++){
		cin >> x;
		b[x] = 1;
	}
	int i = 0;//从0的位置开始跳
	while(i < x + 1){//跳过最后一个障碍物时结束
		if(b[i + 2] == 1 && b[i + 1] == 1){//无法跳过时
			cout << -1 << endl;
			return 0;
		}
		if(b[i + 2]){
			i++;//当有障碍物时
		}else{
			i += 2;
		}
		cnt++;//记录次数
	}
	cout << cnt << endl;//输出
	
	return 0;
}
```

---

## 作者：linhanmo (赞：1)

# 题解：P13517 [KOI 2025 #2] 障碍物

贪心 + DP。

设 $f_i$ 表示在 $i$ 处至少要走几步，则其只能从 $f_{i-1}$ 或 $f_{i-2}$ 走过来，即：

1. $i-1$ 和 $i-2$ 处都不是障碍：$f_i=\min(f_{i-1},f_{i-2})+1$；
2. $i-1$ 处不是障碍：$f_i=f_{i-1}+1$；
3. $i-2$ 处不是障碍：$f_i=f_{i-2}+1$；
4. $i-1$ 和 $i-2$ 处都是障碍：不可到达，输出 $-1$。

我们发现在 $i-1$ 和 $i-2$ 处都不是障碍时选择 $f_{i-2}$ 是更优秀的，于是简化为：

1. $i-1$ 处不是障碍：$f_i=f_{i-1}+1$；
2. $i-2$ 处不是障碍：$f_i=f_{i-2}+1$；
3. $i-1$ 和 $i-2$ 处都是障碍：不可到达，输出 $-1$。

## code

时间复杂度 $\max\{X_i\}$。

```cpp lines=12-15
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 250010;
int n, _1[N], *f = _1 + 1 /* 防止访问到负数下标 */, mx;
bool _2[N], *v = _2 + 1 /* 防止访问到负数下标 */;

int main(void) {
    cin >> n;
    int x;
    while (n--) cin >> x, v[x] = true /* 标记 */, mx = max(mx, x);

    for (int i = 1; i <= mx + 1; ++i)
        if (!v[i - 2]) f[i] = 1 + f[i - 2];
        else if (!v[i - 1]) f[i] = 1 + f[i - 1];
        else return cout << -1, 0;

    cout << f[mx + 1];
}
```

---

## 作者：unick (赞：0)

# P13517 题解
## 前言
本题前置芝士：模拟，递归。
## 题目大意
给定一个长度为 $n$ 的障碍物序列 $a$ 然后问你最少需要几次才能到终点。
## 思路讲解
一开始比赛是感觉有点像 DP 题，但是仔细看看给出的解释，这不就是递归看能不能走，如果：能走就看能走一格或两格；如果不能走就打个标记，最后输出就可以了。

但是要注意 dfs 要从 0 开始走，否则就会听取 [WA](https://www.luogu.com.cn/record/227766436) 声一片。
## [AC](https://www.luogu.com.cn/record/227766251) code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
int a[250005],maxx=-1e9;
bool vis[250005],f;
void dfs(int step){
	if(step>maxx)
		return;
	ans++;
	if(!vis[step+2])
		dfs(step+2);
	else if(!vis[step+1])
		dfs(step+1);
	else
		f=true;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		vis[a[i]]=true;
		maxx=max(maxx,a[i]);
	}
	dfs(0);
	if(!f)
		cout<<ans;
	else
		cout<<-1;
	return 0;
}

```

---

## 作者：coderJerry (赞：0)

首先，我们跳一次最多跨过 $1$ 格，也就是说如果有连续两个障碍物，我们就一定跳不过去，输出 ```-1```，剩下的都是有解的情况。

显然，对于每个障碍物，即对于所有的 $X_i(1\le i \le n)$，你都必须在 $X_{i-1}$ 位置使用跳跃，跳到 $X_{i+1}$ 处。$n$ 个障碍物就要跳 $n$ 次。同时跳完后就不要再跳了，那样只会使结果更大。

那剩下的位置呢？跳跃可以向右 $2$ 步，而步行只能向右 $1$ 步。所以剩下的位置当然是尽可能全用跳跃。只有跳跃完还剩 $1$ 步时用步行。

考虑将剩下的位置表示出来，剩下的位置就是 $[0,X_1-1],[X_1+1,X_2-1],...,[X_{n-1}+1,X_n-1]$ 这些区间。将这些区间的起点终点用数组存下来。根据之前的分析，区间 $[l,r]$ 用的最少移动次数就是 $\lfloor \frac{r-l}{2}\rfloor$（能用跳跃就用，一次跳跃走两步）加上 $(r-l) \operatorname{mod}2$（只有跳跃完还剩 $1$ 步时用步行，$0$ 步就是加 $0$）。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x[250010],l[250010],r[250010],ans=0;
int main(){
    cin>>n;ans+=n;
    l[1]=0;
    x[0]=-1;//这行很重要哦，有了它 l[0] 才等于 0（起始位置）
    for(int i=1;i<=n;i++){
        cin>>x[i];
        r[i]=x[i]-1;l[i+1]=x[i]+1;
        if(x[i]-x[i-1]==1){
            cout<<"-1\n";
            return 0;
        }
    }
    for(int i=1;i<=n;i++){
        int tmp=r[i]-l[i];
        ans+=(tmp/2)+(tmp%2);
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：Natural_Selection (赞：0)

# 题解：[P13517](https://www.luogu.com.cn/problem/P13517)

简单说一下我的思路：
#### 输入+判断合法
1. 输入数列。
2. 把数列每一位对应的位置存入一 `bool` 数组（类似桶）。
3. 判断是否可以跳过所有障碍物。
```cpp
    cin>>n>>a[0];
    st[a[0]]=1;
  	int k=a[0];
  	for(int i=1;i<n;i++){
  		cin>>a[i];
  		st[a[i]]=1;//类似桶的记录方法
  		if(k==a[i]-1){cout<<"-1\n" return 0;}//判断，如果当前的这一位比上一位多 1 ，就一定跳不过去
  		k=a[i];
  	}
```
#### 计算

![](https://cdn.luogu.com.cn/upload/image_hosting/r6cdstuj.png)

1. 障碍物距离当前位置两格，最优方法为先走 $1$ 格，再跳 $2$ 格（上图 $0$ 到 $2$）。
2. 当前位置后两格没有障碍物，最优方法直接跳 $2$ 格（上图 $1$ 到 $3$ 或 $6$ 到 $8$）。

```cpp
for(int i=0;i<=a[n-1];i++)//a[n-1] 一定是最大的
    if(st[i+2]==1){
      cnt+=2;i+=2;// i 要向前走
    }else if(st[i+2]==0){
      cnt++;i++;
    }
```

[AC 记录](https://www.luogu.com.cn/record/227701614)

---


# [KOI 2025 #2] 镜子

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

你正在一条数轴上玩游戏。你的角色位于位置 $s$，数轴上放置了 $N$ 个镜子。各个镜子的位置从左到右依次为 $A_1 \le A_2 \le \cdots \le A_N$。同一个位置上可能有多个镜子。

你可以使用镜子来改变角色的位置。使用镜子后，角色的位置会移动到以该镜子为中心的对称点。也就是说，当你的角色位于位置 $a$ 时，如果使用位于位置 $b$ 的镜子，你的角色将移动到位置 $2b - a$。

这 $N$ 个镜子每个都必须且只能使用一次。也就是说，不能忽略任何一个镜子不使用，也不能对同一个镜子使用两次或以上。除了每个镜子都必须且只能使用一次这个条件外，你可以按任意顺序使用这些镜子。

你需要计算并输出在这些条件下，你的角色能到达的位置的最大值。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/rjvbt6e9.png)

如果先使用第 1 个镜子 (位置为 -1)，再使用第 2 个镜子 (位置为 2)，如上图所示，角色的最终位置为 6。反之，如果先使用第 2 个镜子，再使用第 1 个镜子，角色的最终位置为 -6。因此，本例的答案是 6。

### 限制条件

*   所有给定的数都是整数。
*   $1 \le N \le 200\,000$
*   $-10^9 \le s \le 10^9$
*   $-10^9 \le A_1 \le A_2 \le \cdots \le A_N \le 10^9$

### 子任务

1.  (7 分) $N \le 2$。
2.  (25 分) $N$ 是偶数，且 $A_1 = A_2 = \cdots = A_{N/2} < s < A_{N/2+1} = A_{N/2+2} = \cdots = A_N$。
3.  (19 分) $N$ 是偶数，且 $A_{N/2} < s < A_{N/2+1}$。
4.  (49 分) 无额外限制条件。

## 样例 #1

### 输入

```
2 0
-1 2```

### 输出

```
6```

## 样例 #2

### 输入

```
6 3
-4 -2 2 6 8 9```

### 输出

```
57```

## 样例 #3

### 输入

```
9 9
0 1 3 3 4 5 8 9 10```

### 输出

```
49```

## 样例 #4

### 输入

```
1 1000000000
-999999999```

### 输出

```
-2999999998```

# 题解

## 作者：Sweet_2013 (赞：16)

题目翻译：在数轴上，角色最开始在 $s$，数轴上有 $n$ 个镜子，每个镜子必须且只能使用一次，使用镜子时，角色会以镜子位置为中心对称反射，要求求出使用所有镜子后，角色能达到的最大位置。

假设新位置是 $ans$，镜子现在的位置是 $q$，当前位置是 $m$。

我们发现，每次使用镜子时，角色位置会按照公式 $ans=2\times q-m$ 进行变换，最优策略是交替使用最大和最小的镜子，就能让最后的结果尽可能大，当 $n$ 为奇数时，先使用最大的镜子，否则先使用最小的镜子。

```
#include<bits/stdc++.h>
using namespace std;
int n,a[200005];
long long s;
int main() {
    cin>>n>>s;
    for(int i=0;i<n;i++)cin>>a[i];
    sort(a,a+n);
    long long ans=s;
    int l=0,r=n-1;
    bool ok=(n%2==1);
    for(int i=0;i<n;i++) {
        if(ok){
            ans=2*a[r]-ans;
            r--; //用最大镜子就移动右指针。
        }else{
            ans=2*a[l]-ans;
            l++; //用最小镜子就移动左指针。
        }
        ok=!ok;//切换操作方向
    }
    cout<<ans;
}
```

---

## 作者：chen_zhe (赞：5)

### 子问题 1

当 $N=1$ 时，答案为 $2A_1 - s$。

当 $N=2$ 时，使用镜子的顺序总共有两种。先使用 1 号镜子的情况下，最终位置为 $2A_2 - (2A_1 - s)$；先使用 2 号镜子的情况下，最终位置为 $2A_1 - (2A_2 - s)$。输出两者中较大的一个即可。

### 子问题 2

在子问题 1 的情景下，分析使用 2 号镜子更为有利的条件，可得 $2A_1 - 2A_2 + s > 2A_2 - 2A_1 + s$，即 $A_1 \le A_2$。因此，当只使用两面镜子时，后使用位置更靠右的镜子会更有利。

此外，从使用两面镜子后的位置公式的形式可以看出，初始位置越靠右，使用两面镜子后的最终位置也会越靠右。

在子问题 2 的情景下，可以使用的镜子位置只有两种。要将初始位置通过两次反射送到最右边，最优策略是先使用位置为 $L$ 的镜子，然后使用位置为 $R$ 的镜子。（当初始位置为 $s$ 时，最终位置为 $2A_2 - 2A_1 + s$，因此 $A_1$ 越小，$A_2$ 越大，结果越优。）

因此，当只能使用这两种镜子时，最优策略是在奇数次反射时使用左边的镜子，在偶数次反射时使用右边的镜子。恰好这两种镜子各有 $N/2$ 面，因此这种情况就是答案。通过直接模拟这个过程，可以在 $O(N)$ 时间内求得答案。

### 子问题 3

假设 $N$ 是偶数。设使用 $N$ 面镜子的位置顺序为 $x_1, x_2, \dots, x_N$。此时，对于初始位置 $s$，最终位置可以写成如下的式子：

*   使用到第 1 面镜子时：$2x_1 - s$
*   使用到第 2 面镜子时：$2x_2 - (2x_1 - s) = 2x_2 - 2x_1 + s$
*   使用到第 3 面镜子时：$2x_3 - (2x_2 - 2x_1 + s) = 2(x_1 + x_3) - 2x_2 - s$
*   使用到第 4 面镜子时：$2x_4 - (2(x_1 + x_3) - 2x_2 - s) = 2(x_2 + x_4) - 2(x_1 + x_3) + s$
*   ...
*   使用到第 $N$ 面镜子时：$2(x_2 + x_4 + \dots + x_N) - 2(x_1 + x_3 + \dots + x_{N-1}) + s$（其中 $N$ 为偶数）

通过式子的形式可以看出，最优策略是在奇数次的 $N/2$ 个回合中使用位于左侧的 $N/2$ 面镜子，在偶数次的 $N/2$ 个回合中使用位于右侧的 $N/2$ 面镜子。（可以发现，在奇数次回合之间或偶数次回合之间交换使用的镜子，对最终结果没有影响。）

由于镜子的位置是按排序好的顺序给出的，因此可以在 $O(N)$ 时间内求得答案。

此外，也可能存在利用 $A_{N/2} < s < A_{N/2+1}$ 这一性质的其他解法。

### 子问题 4

在子问题 3 中，我们说明了 $N$ 为偶数时的解法。当 $N$ 为奇数时，对于使用过的镜子位置 $x_1, x_2, \dots, x_N$，最终位置为 $2(x_1 + x_3 + \dots + x_N) - 2(x_2 + x_4 + \dots + x_{N-1}) - s$。

通过式子的形式可以看出，最优策略是在奇数次的 $(N+1)/2$ 个回合中使用位于右侧的 $(N+1)/2$ 面镜子，在偶数次的 $(N-1)/2$ 个回合中使用位于左侧的 $(N-1)/2$ 面镜子。

由于镜子的位置是按排序好的顺序给出的，因此可以在 $O(N)$ 时间内求得答案。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int n; ll s;
ll A[200002];

int main(){
    scanf("%d %lld", &n, &s);
    for(int i=1; i<=n; i++) scanf("%lld", &A[i]);

    int L = 1, R = n, turn=n%2;
    while(L<=R){
        if(turn == 1) s = 2 * A[R--] - s;
        else s = 2 * A[L++] - s;
        turn = !turn;
    }
    printf("%lld", s);
}
```

---

## 作者：axy2414fujingze (赞：2)

# 我来抢题解啦
~~终于找到了一个普及-可以写题解，对我们新手太不友好了~~

咱可以先理解一下题目哈，不然你只会写一个头文件。。
给出的镜子的序列是不下降序列，最左边为最小的镜子，最右边为最大的镜子。必须每个镜子都要用到而且不能用大于一次，我会从我现在的位置移动到镜子的位置*2-现在的位置的坐标，就像题目给出的公式一样。so，我们的公式就出来啦：$$s = 2 \times a - s$$。

由已知得：我们在最后一次的移动的时候，起点的位置要越低越好，然后在最后一次的移动中能够减去更少的 `s`，甚至是减去负数。那我们就左右弹跳，用低的镜子可以到更低的地方，用更高的镜子可以到更更高的地方。走了一步左边的，就走右边的，把自己的位置往上抬。如果走了一步右边的，就走左边，把自己的位置往低处移动，为下一次向右边移动做准备，能可以有一个更远的距离啦。

那么，问题来了，我应该怎么算要先用小的还是先用大的呢？如果 `n` 为偶数那我就先往左移动，这里你们自己可以模拟一下，当 `n` 为偶数的时候，最后的结果是不是在左边而不是在数更大右边？奇数就是反过来。~~呃呃，看不懂的话可以找YuTinMin的那一个，他讲的和我差不多，而且有个图，好看~~
好啦，放代码。

不可能的，自己写！！！

算了，不忍心。

```cpp
#include<bits/stdc++.h>
#define int long long//不加会后悔的
using namespace std;
const int D=200000;
int a[D];
signed main()
{
    int n,ans=0;
    cin>>n>>ans;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    int b=1;
    int c=n;
    bool flag=!(n%2==0);
    while(b<=c){
        if(flag==true)
            ans=2*a[c--]-ans;
        else
            ans=2*a[b++]-ans;
        
        flag=!flag;
    }
    cout<<ans;
    return 0;
}
```
我这个代码没那么好看，凑合着看一下吧，毕竟有Ac嘛。

我服了这个图片好难弄qwq。好啦，本萌新第一次写题解，麻烦大家多多支持一下，谢谢啦awa。

---

## 作者：GSQ0829 (赞：1)

### 题目大意：
你正在一条数轴上玩游戏。你的角色位于位置 $s$，数轴上放置了 $N$ 个镜子。各个镜子的位置从左到右依次为 $A_1 \le A_2 \le \cdots \le A_N$。同一个位置上可能有多个镜子。

你可以使用镜子来改变角色的位置。使用镜子后，角色的位置会移动到以该镜子为中心的对称点。也就是说，当你的角色位于位置 $a$ 时，如果使用位于位置 $b$ 的镜子，你的角色将移动到位置 $2b - a$。

这 $N$ 个镜子每个都必须且只能使用一次。也就是说，不能忽略任何一个镜子不使用，也不能对同一个镜子使用两次或以上。除了每个镜子都必须且只能使用一次这个条件外，你可以按任意顺序使用这些镜子。

你需要计算并输出在这些条件下，你的角色能到达的位置的最大值。

---
### 解题思路：
这道题是一道贪心的题目。需要要求我们通过数轴上的镜子移动位置，最后求出能够移动到的位置的最大值。

我们先来观察**子任务 $1$**，它的限制条件是 $N \le 2$，所以我们只要分成两种情况：第一种，只有 $1$ 面镜子，那么直接求出答案；第二种，有两面镜子，那么就判断是先用第一面再用第二面，还是先用第二面镜子再用第一面镜子即可。

那么，我们其实可以发现，在两面镜子的情况中，先用更靠右边一点的镜子再用左边一点的镜子是更优的解法。

所以这其实是一个本题的突破口。

这道题的核心贪心思想是**交替选择最远端的镜子‌**：我们为了最大化最终的位置，我们就应该采用从数轴两端交替选择镜子的策略。当剩余镜子数量为奇数时，优先选择最右侧的镜子；当剩余镜子数量为偶数时，优先选择最左侧的镜子。

那么为了实现这个贪心的思想，我们就需要用一个双指针的办法，交替选择左右端点，将整个范围慢慢收缩，直到左右端点重合，贪心就结束了。

因为只要执行 $N$ 次操作，所以最后的时间复杂度就为 $O(N)$，不会很高。而且要注意，$-10^9 \le A_i \le A_i$，一定要开 `long long`。

---
### 代码：
如果上面还没有看懂的蒟蒻们，就可以来看下面的注释与代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int a[200001], n, s, l = 1, r, t; // a 数组表示不同镜子的位置，n、s 分别表示镜子的数量与初始的位置，l、r 为双指针、t 表示剩余镜子数量的奇偶性

signed main() {
	cin >> n >> s;
	for (int i = 1; i <= n; i++) cin >> a[i];
	r = n; // 将右端点的初始值设为镜子的总数
	t = n % 2; // 先判断当前镜子数量的奇偶性
	while (l <= r) { // 要注意此处的条件
		if (t == 1) s = 2 * a[r--] - s; // 如果剩余的镜子数量是奇数，就移动右端点，选择最右侧的镜子进行计算
		else s = 2 * a[l++] - s; // 如果剩余的镜子数量是偶数，就移动左端点，选择最左侧的镜子进行计算
		if (!t) t = 1; // 更新奇偶性
        else t = 0;
	}
	cout << s;
	return 0;
}
```

---
参考题解：https://www.luogu.com.cn/article/wb69eow7 。

---

## 作者：Doraeman (赞：1)

本题的关键在于：用所有 $N$ 个镜子的位置和我的起始位置 $s$，表示出我的“最终位置”。

## 对称点计算
如果我在 $a$ 位置，使用 $b$ 位置的镜子，经过对称后我的位置在 $2b-a$（题目给出），此处给出证明过程：

- 若 $a>b$，根据距离计算方法，我与镜子的距离是 $a-b$，对称后我在镜子左侧，位置是 $b-(a-b)=2b-a$；
- 若 $a<b$，同理，我与镜子的距离是 $b-a$，对称后我在镜子右侧，位置是 $b+(b-a)=2b-a$；
- 若 $a=b$，对称后的位置也是 $b=2b-b=2b-a$。

## 最终位置计算
现在，我们要将 $N$ 个镜子 $A_{1\sim N}$ 的位置按照一定顺序进行排序（这个顺序待会再讲，便于理解）。

设我第 $i$ 次对称之前的位置是 $S_i$，排序后第 $i$ 个镜子的位置是 $B_i$。  
那么对称后的位置就是 $S_{i+1}=2B_i-S_i$。

同时，又有 $S_i=2B_{i-1}-S_{i-1}$。  
所以推出：

$$
S_{i+1}=2B_i-(2B_{i-1}-S_{i-1})\\
\ \ \ \ \ =2B_i-2B_{i-1}+S_{i-1}
$$

设第 $k$ 次对称后位置是 $f(k)$，可以得到一个递推式：
$$
f(k)=2B_k-f(k-1)
$$

现在来到了最关键的一步：观察正负号。  
可以发现，上式中 $f(k-1)$ 前面是“$-$”，而 $f(k)$ 前面是 “$+$”。  
然而，在 $f(k+1)$ 的表达式中，$f(k-1)$ 前面又变成了 “$-$”，而 $f(k)$ 前面变成了“$+$”。

根据“负负得正”，$f(i)$ 的表达式中，如果某个数的系数是 $1$，那么它在 $f(i+1)$ 中系数就是 $-1$，在 $f(i+2)$ 中系数又是 $1$。

继续找规律可以发现这个结论：在 $f(N)$ 的表达式中，$2B_{1,3,5,\dots,2\lfloor\frac{N-1}{2}\rfloor+1}$ 前的符号是 “$-$”，而 $2B_{2,4,6,\dots,2\lfloor\frac{N}{2}\rfloor}$ 前的符号是 “$+$”。

也就是说，对于所有的 $B_{1\sim N}$，也**对于排序前的 $A_{1\sim N}$，一共有 $\lfloor\frac{N+1}{2}\rfloor$ 个正号“$+$”以及 $\lfloor\frac{N}{2}\rfloor$ 个负号“$-$”要添加在这些数的前面。** 

此外，初始位置 $s$ 前的符号还要分类讨论：

- 若 $N$ 是奇数，$s$ 前符号是“$-$”（因为第 $1$ 次 $s$ 前符号就是“$-$”）；
- 若 $N$ 是偶数，$s$ 前符号是“$+$”。

## 位置最大值
现在题目要求最终位置 $f(N)$ 的最大值。

为了让这个值最大，我们要尽可能让大的数前面使用 “$+$”，小的数前面使用“$-$”。  
由此我们也得到了排序的原则：**从大到小，前 $\lfloor\frac{N+1}{2}\rfloor$ 个值前面用“$+$”，其余的值（共 $\lfloor\frac{N}{2}\rfloor$ 个）用“$-$”**。  
不要忘记乘上它们每个镜子前的系数 $2$。

最后还要分情况讨论 $s$ 前的系数是 $1$ 还是 $-1$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n, s, a[N];
long long ans;
int main(){
    cin >> n >> s;
    for(int i=1; i<=n; i++)
        cin >> a[i];

    // 贪心 排序 
    sort(a + 1, a + n + 1, greater<int>());

    // 正负号 统计答案 
    for(int i=1; i<=(n+1)/2; i++)
        ans += a[i] * 2;
    for(int i=(n+1)/2+1; i<=n; i++)
        ans -= a[i] * 2;

    // 分情况讨论 
    if(n % 2 == 0) ans += s;
    else ans -= s;

    cout << ans;
}
```

---

## 作者：YuTinMin (赞：1)

## 思路

先理解题目，找出已知条件。

给出的镜子的序列是不下降序列，最左边为最小的镜子，最右边为最大的镜子。必须每个镜子都要用到而且不能用大于一次，当我在起点使用镜子的时候，我会从我现在的位置移动到：镜子的位置乘以二再减去现在的位置的坐标，就像题目给出的公式一样，`s` 是我现在的位置，`a` 是镜子的位置，那么公式就是。

$$s = 2 \times a - s$$

贪心题肯定是判断当下是否为最优解，那我们可以找规律，我们可以看样例解释里的图片。它第一次的选择用第一个镜子跑到比原本低的位置，然后再用第二个镜子来移动自己到更远的位置，这样做是为什么呢？

这个坐标的公式要减去自己的位置 `s`，如果我自己的位置越低，那我是不是减去的越少，位置越高了？

那就好说了，我们就是要在最后一次的移动的时候，起点的位置 `s` 要越低越好，然后在最后一次的移动中能够减去更少的 `s`，甚至是减去负数。那我们就左右弹跳，用低的镜子可以到更低的地方，用更高的镜子可以到更高的地方。走了一步左边的，就走右边的把自己的位置往上抬。如果我走了一步右边的，就走左边，先把自己的位置往低处移动，为下一次向右边移动做一个充足的准备，能有一个更远的距离。

那我应该怎么算要先用小的还是先用大的呢？如果 `n` 为偶数那我就先往左移动，你们自己可以模拟一下，如果 `n` 为偶数的时候，最后的结果是不是在左边而不是在数更大右边？奇数就是反过来。

具体的可以自己把第三个样例用数学模拟出来，就可以看出来了。

说话不太具体，见谅，下面给出一张图，是我两个想法的做法，可以用来参考。

![](https://cdn.luogu.com.cn/upload/image_hosting/2s77gmrd.png)

第一个是从外面往里面跳，就是本题的解法。第二个是从外往里面跳，~~我本来是想把大的值留在后面，发现不行，然后觉得这一题是贪心，就从外往里面跳，诶，对了。~~

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 200000;
int a[N];

signed main()
{

    int n, s;
    cin >> n >> s;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    int l = 1, r = n;
    bool flag = !(n % 2 == 0); //判断是否是奇数
    while (l <= r)
    {
        if (flag == true)
            s = 2 * a[r--] - s; //是奇数就用大的镜子来反弹到高的地方
        else
            s = 2 * a[l++] - s; //不是就用小的镜子来反弹到低的地方
        n -= 1;
        flag = !(n % 2 == 0); //每次反弹都改变方向，把奇数/偶数改成偶数/奇数
        //cout << s << endl;
    }
    cout << s;

    system("pause");
    return 0;
}
```

---

## 作者：huhongtao0808 (赞：1)

这个题非常~~水~~简单，我们仔细想想，就可以知道怎么做，我们的基本思想是：过最左边的镜子，再过最右边的镜子，反复如此，来最大化答案。（仔细想想就可以证明是对的。）

注：我们最开始先要明确我们是先向左走，还是向右走。

$coding$
```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long 
#define nnn 200002
int n; 
int s;
int a[nnn];

signed main(){
    scanf("%d %lld", &n, &s);
    for(int i=1; i<=n; i++) scanf("%lld", &a[i]);

    int l = 1, r = n, d=n%2;
    while(l<=r){
        if(d == 1) s = 2 * a[r--] - s;
        else s = 2 * a[l++] - s;
        d = !d;
    }
    printf("%lld", s);
    return 0;
}

```
~~过水~~

---

## 作者：Loyal_Soldier (赞：1)

## 思路

显然，使用比你越远且坐标大的镜子，你的坐标就越大。使用越远且比你坐标小的镜子，你的坐标就越小。

那么，每次用完镜子，肯定用比你坐标越大的镜子就越好。

如果没有坐标比你大的，就是用当前坐标最大的镜子，没有比你坐标小的，就是用当前坐标最小的镜子。

那么我们就可以使用以下贪心策略：
- 当剩余镜子数量是奇数时，使用当前坐标最大镜子。
- 当剩余镜子数量是偶数时，使用当前坐标最小镜子。

注意，题面里说了镜子坐标递增，所以不用排序。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 10;
int l, r, n, s, a[N]; 
signed main()
{
	cin >> n >> s;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	l = 1, r = n;//a[l] 是当前坐标最小的镜子，a[r] 是当前坐标最大的镜子
	while(l <= r)
	{
		if((r - l + 1) % 2) s = 2 * a[r --] - s;//剩余镜子数量是奇数的情况
		else s = 2 * a[l ++] - s;//剩余镜子数量是偶数的情况
	}
	cout << s;
	return 0;
}
```

---

## 作者：coderJerry (赞：0)

首先，你注意（cai）到，在你**一侧**的镜子离你越远，你移动到以该镜子为中心的对称点就会离你的初始位置越远。

简单说明一下：如果有两个镜子分别在 $x,y(x<y)$ 处，你在 $s$ 处。若 $s<x$，则 $s$ 关于 $x$ 的对称点为 $2x-s$，离起点的距离为 $(2x-s)-s=2x-2s$。关于 $y$ 的对称点为 $2y-s$，离 $s$ 的距离为 $(2y-s)-s=2y-2s$。显然 $2y-2s>2x-2s$（因为 $x<y$）。所以这种情况下成立，$s>y$ 时同理。所以我们只需要**每次选择某一侧离你最远那个镜子**做对称就可以了。每一次都最远，最后一次肯定也最远。

那么该选哪一侧呢？题目要求最后在数轴上的位置最大，说明最后一次应该是往右去做对称的。

由于需要对称 $n$ 次，所以考虑对 $n$ 分类讨论。若 $n$ 是奇数，若第一次找右侧没用过的离自己最远的镜子，然后是左右左右等等，由于有奇数次，故最后一次肯定是向右侧找。所以第一次应找右侧没用过的离自己最远的镜子。同理，若 $n$ 是偶数，第一次应找左侧没用过的离自己最远的镜子。（这里建议手玩一下样例 2 和 3 能更好地理解）

然后模拟一下不断左右对称的过程即可。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,s,a[200010];
signed main(){
    cin>>n>>s;int pos=s;
    for(int i=1;i<=n;i++) cin>>a[i];
    if(n%2==0){
        for(int i=1;i<=n/2;i++){
            pos=2*a[i]-pos;
            pos=2*a[n-i+1]-pos;
        }
    }
    else{
        for(int i=1;i<=n/2;i++){
            pos=2*a[n-i+1]-pos;
            pos=2*a[i]-pos;
        }
        pos=2*a[(n+1)/2]-pos;
    }
    cout<<pos;
    return 0;
}
```
由于我水平有限，所以一些表述可能不是那么好，如果你有更好的表述方法欢迎讨论。

---


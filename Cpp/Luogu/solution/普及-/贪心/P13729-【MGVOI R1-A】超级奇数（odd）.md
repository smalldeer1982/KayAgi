# 【MGVOI R1-A】超级奇数（odd）

## 题目背景

如果这是您首次参加 OI 赛制的比赛，以下提示可能会有所帮助：

::::warning[提示]{open}

1. 本场比赛为 OI 赛制，和 CSP-J/S 相同。也就是说，**你在比赛期间无法看到评测结果，且每道题的分数均以最后一次提交为准**。

2. 所有题目都在附件中附有大样例。建议使用文件读写函数（如 ```freopen```）进行样例测试，但 **比赛界面提交的代码中 请勿调用 文件读写函数**，从而确保你的代码能被正常评测。

::::
$ $


## 题目描述

Fruit 同学和 Siby 同学很喜欢超级奇数。

::::info[超级奇数的定义]{open}
对于一个正整数，如果其十进制表示中的每一位都是奇数（即仅由 $1,3,5,7,9$ 中的某些数码组成），则定义它是一个 **超级奇数**。例如，$3,7,17,31,139511,975319$ 等都是超级奇数，而 $2,16,23,13365,139454,310111$ 等则不是。
::::

有一天，他们在放学的路上想到了这样一个问题：“给定一个正整数 $a$，如何为它找到一个最小的 **非负整数** $b$，使得 $a+b$ 为一个超级奇数？”

两位同学很快就想到了解法，但他们没学过编程，所以在处理大量的数据时有些力不从心。因此，他们找到了学习算法竞赛的你，希望你能用计算机快速地解答这个问题。

## 说明/提示


**【样例 #1】**

::::info[样例 #1 解释]

对于第一组测试数据：

* 显然，$7$ 本身就是一个超级奇数，所以当 $a=7$ 时，只需取 $b=0$ 就能使得 $a+b$ 为超级奇数。
  
* 综上，$b$ 的最小值为 $0$。

对于第二组测试数据：
* 当 $b=0$ 时，$a+b=16$，含有偶数数码 $6$，不是超级奇数；

* 当 $b=1$ 时，$a+b=17$，仅含有奇数数码，是超级奇数。

* 综上，$b$ 的最小值为 $1$。

对于第三组测试数据：
* 当 $b=0$ 时，$a+b=23$，含有偶数数码 $2$，不是超级奇数；

* 当 $b=1$ 时，$a+b=24$，含有偶数数码 $2,4$，不是超级奇数；

* 当 $b=2$ 时，$a+b=25$，含有偶数数码 $2$，不是超级奇数；

* 以此类推，当 $0 \le b \le 7$ 时，验证知 $a+b$ 均不是超级奇数；

* 当 $b=8$ 时，$a+b=31$，仅含有奇数数码，是超级奇数。

* 综上，$b$ 的最小值为 $8$。

::::

**【样例 #3】**

见附件中的 ```odd/odd3.in``` 与 ```odd/odd3.ans```。

这个样例满足测试点 $5 \sim 13$ 的限制。

**【样例 #4】**

见附件中的 ```odd/odd4.in``` 与 ```odd/odd4.ans```。

这个样例满足测试点 $14 \sim 15$ 的限制。

**【样例 #5】**

见附件中的 ```odd/odd5.in``` 与 ```odd/odd5.ans```。

这个样例满足测试点 $16 \sim 20$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 2\times 10^3$，$1 \le a\le {10}^{12}$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  **特殊性质** |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $2$ | $20$ | 无 | 
| $5 \sim 13$ | $100$ | $10^3$ | ^ | 
| $14 \sim 15$ | $2\times 10^3$ | ${10}^{12}$ | **A** | 
| $16 \sim 20$ | ^ | ^ | 无 | 

特殊性质 **A**：保证在 $a$ 的十进制表示中，有且仅有一位是偶数（如 $99\blue{4}75$，$1357\blue{8}$ 等，其中标蓝的为偶数数码）。

* 分值分配：每个测试点的分值为 $5$ 分。

* 提示：本场比赛四道题目的测试点中 **存在行末回车符和文末换行**，因此，建议使用特殊读入方式（如“快读”）的选手自行通过各题附件中的大样例进行测试，以确保程序的输入部分能够正常工作。

## 样例 #1

### 输入

```
3
7
16
23```

### 输出

```
0
1
8```

## 样例 #2

### 输入

```
8
2
82
128
136
13365
139454
310111
975319```

### 输出

```
1
9
3
1
6
57
1000
0```

# 题解

## 作者：2023z (赞：5)

比赛只打了这题就去上课了 qwq

### 题意简述

一共有 $ t $ 组数据，每组数据给我们一个正整数 $ a $，对于每个整数 $ a $，如果它所有位数都由 $ 1, 3, 5, 7, 9 $（也就是每一位都不是偶数） 组成，那么我们称这个整数为 **超级奇数**。例如 $ 3, 7, 17, 31, 139511, 975319 $ 都是超级奇数，而 $ 2, 16, 23, 13365, 139454, 310111 $ 不是（因为它们都有某一位上的数字为偶数）。现在问你如何让 $ a $ 加上一个 **非负整数**（可以是 $ 0 $）$ b $ 使得 $ a + b $ 为一个超级奇数，最小化这个 $ b $。

### 思路

这道题看似是问一个最小化的 $ b $ 使得 $ a + b $ 为一个超级奇数。其实也就等于问最小的 $ a + b $ 使得 $ a + b $ 为一个超级奇数，那如何让 $ a + b $ 最小化呢？我们可以去找一个离 $ a $ 最近的超级奇数（可以是 $ a $，因为 $ b $ 可以等于 $ 0 $）。所以分两种情况，第一种 $ a $ 本身就是一个超级奇数，直接输出 $ 0 $ 就行了。第二种就是 $ a $ 本身不是超级奇数的情况。

那怎么去做 $ a $ 本身不是超级奇数的情况呢？

第一种思想，暴力枚举，一看数据范围，$ 1 \leq a \leq 10^{12} $，肯定出不了奇迹，所以先排除了。

那再考虑其他方法。

首先我们来观察样例

样例一：

输入

```cpp
3
7
16
23
```

输出

```cpp
0
1
8
```

首先我们看一下第一个数字 $ 7 $，它的每一位都是 $ 7 $，所以它本身就是一个超级奇数，直接输出 $ 0 $。

再看第二个输入 $ 16 $，首先第一位 $ 1 $ 为奇数，符合条件，无需改变（改变了会增加不必要的答案，因为它本身就是奇数了）。第二位 $ 6 $ 为偶数，不符合条件，所以需要修改。那我们去找离它最近的超级奇数。发现 $ 17 $ 是离它最近的超级奇数，故输出 $ 1 $ （因为题目要我们输出 $ a + b $ 是超级奇数的最小的 $ b $ 所以要输出 $ 17 - 16 = 1 $ ）。

第三个数字 $ 23 $，第一位 $ 2 $ 就是偶数，所以它本身不是一个超级奇数。我们去找离它最近的超级奇数发现为 $ 31 $，是把第一位的 $ 2 $ 改成了 $ 3 $，第二位上的 $ 3 $ 改成了 $ 1 $。

我再来手捏一个样例：

```cpp
1
699999
```

这个显然不是超级奇数（~~不然本身就是超级奇数我还出它干嘛~~）因为第一位上的 $ 6 $ 就是偶数，所以我们要找最近的超级奇数。如果你能发现规律，那这一次的超级奇数就很简单了。其实是 $ 711111 $，这个数据的规律已经很明显了吧... 我们发现第一位的 $ 6 $ 被改成了 $ 7 $ 之后所有的 $ 9 $ 都变成了 $ 1 $。

到这里我们知道，离一个数最近的超级奇数，首先它的第一位为偶数的那一位数要 $ +1 $，这样第一位就变成了奇数，而且一定比原来的 $ a $ 要大，这个很容易理解，偶数加一会变成奇数，虽然减一也能变成奇数，但会比原来的 $ a $ 要小，且 $ b $ 为非负整数，在第一位偶数时 $ +1 $ 能决定修改后 $ a $ 的大小，高位的大小决定性肯定比低位要更大。而对于之后的所有位数，他都要满足是奇数，因为第一位偶数已经决定了大小，所以后面的位数可以不用考虑大小关系了，这样就很简单，直接全部变成最小的一位奇数 $ 1 $ 就行了，这样既满足了超级奇数的条件，又是最小的大于 $ a $ 的数。

接下来到了代码了。

### 代码实现

考虑使用字符串。我们对于每组数据输入一个字符串，去遍历两遍字符串，第一遍我们去把输入的 $ a $ 算出来，以及标记第一个位数上为偶数的下标。然后分两种情况。

第一种，$ a $ 本身就是一个超级奇数，输出 $ 0 $。

第二种，算出离 $ a $ 最近的超级奇数，把第一位为偶数的数 $ +1 $ 后面的位数全部改成 $ 1 $，其他的位数不变，在输出最近的超级奇数与原数 $ a $ 的差值（即最小化满足条件的 $ b $）。

记得把数字变量开 long long。

code：

```cpp
#include<bits/stdc++.h>
#define int long long //十年 oi 一场空，不开 long long 见祖宗
using namespace std;
int t;
string s; //每组输入的字符串
signed main() {
    cin >> t;
    while (t--) {
        cin >> s;
        int pos = -1, a = 0; // pos 成 -1 是因为可能 a 本身就是超级奇数的情况，s 的最小下标是 0，所以赋值成 -1
        for (int i = 0; i < s.size(); i++) {
            a = a * 10 + (s[i] - '0'); //算出原来的 a
            if (s[i] != '1' && s[i] != '3' && s[i] != '5' && s[i] != '7' && s[i] != '9' && pos == -1) {
                pos = i; //如果是第一位偶数的位数，记录下下标
            }
        }
        if (pos == -1) { // a 本身就是一个超级奇数
            cout << 0 << '\n';
            continue;
        }
        s[pos] = s[pos] + 1; //把第一为偶数位 +1
        int cnt = 0; // cnt 是离 a 最近的超级奇数
        for (int i = 0; i < s.size(); i++) {
            if (i <= pos) { //在 pos 前面的位置不用管，pos 位置的值也在 for 循环之前修改好了，见 21 行
                cnt = cnt * 10 + (s[i] - '0'); //直接加上
                continue;
            }
            cnt = cnt * 10 + 1; //如果在 pos 后面的位置就全部变成最小的一位奇数 1
        }
        cout << cnt - a << '\n'; //输出最小化的 b
    }
    return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/231401613)

这道题的难度我觉得和 CSP-J 的第一题要难一点，但比第二题的难度要小。

最后预祝大家 CSP 能取得好成绩！！！

---

## 作者：shijingteng (赞：4)

这是一道比较水的题，只需要分析到位，很容易写出代码。

看到这个数据范围，简单估算一下，就可以发现暴力的方法是不可行的，那就只能找规律了。
### 样例分析：
以样例中 $23$ 为例。我们将它每一位拆开看，第一位是 $2$，由于它是偶数，因此我们需要修改它，为了使得最终答案尽可能小，所以可以把它改成 $3$，这样花费了$$33 - 23 = 10$$，也就让答案增加了 $10$，而第二位是 $3$，是奇数，不需要修改，看似修改后距离 $23$ 最近的超级奇数是 $33$。

但是再仔细观察一下，$31$ 才是最近的超级奇数。因为题目中的超级奇数是 $$ a + b $$ 得到的，所以超级奇数是比原来的数大的（别看这句是废话，但是却很重要！），我们在第一次修改就将超级奇数改得大于了原数，那么要使得它最小，就需要让这个超级奇数后面所有位都变成 $1$ ，那么距离 $23$ 的最近超级奇数就是 $31$ 了，与预期一致。

我们可以每次对输入的数进行扫描，只要第一次检查到当前位是偶数，那就修改它，并将后面所有数都改成 $1$。

为了让操作更加方便，可以使用字符串。

### 具体代码：
```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
string s;
int cal(string s){
	bool f=false;
	int sum=0;
	for(int i=0;i<s.size();i++){
		int pos=s[i]-'0';
		if(pos%2==0&&!f){
			f=true;
			int w=s.size()-i;
			sum+=(long long)pow(10,w-1);
		}
		else if(f){
			int w=s.size()-i;
			sum-=(long long)(pos-1)*pow(10,w-1);
		}
	}
	return sum;
}
signed main(){
	cin>>t;
	while(t--){
		cin>>s;
		cout<<cal(s)<<endl;
	}
	return 0;
}
```

---

## 作者：chenlc (赞：2)

## 思路
要找到最小的 $b$，其实就是使得 $a + b$ 尽可能的小，问题可以转换为求比 $a$ 大的第一个超级奇数，再减去 $a$，就是最小的 $b$。

怎么求比 $a$ 大的第一个超级奇数呢？设比 $a$ 大的第一个超级奇数为 $ans$，遍历 $i$ 从 $a$ 的最高位到最低位，并分为以下两种情况判断：

1. 当 $a$ 的第 $i$ 位为奇数时，$ans$ 的第 $i$ 位为 $a$ 的第 $i$ 位。
2. 当 $a$ 的第 $i$ 位为偶数时，$ans$ 的第 $i$ 位为 $a$ 的第 $i$ 位加 $1$，这样操作 $ans$ 最终一定会比 $a$ 大（因为 $ans$ 的这一位已经比 $a$ 的这一位要大了），所以为了让 $ans$ 最小，后面的每一位全部设为最小的 $1$。

最后输出 $ans - a$ 即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	long long t;
	cin >> t;
	while(t--){
		long long a;
		cin >> a;
		string s = to_string(a);
		string ans1 = "";
		bool flag = false;
		for(int i = 0; i < s.length(); i++){
			if(flag == true){
				ans1 += "1";
			}
			else{
				int num = int(s[i] - '0');
				if(num % 2 == 0){
					ans1 += char(num + 1 + '0');
					flag = true;
				}
				else{
					ans1 += char(num + '0');
				}
			}
		}
		long long ans2 = strtoll(ans1.c_str(), NULL, 10);
		
		cout << ans2 - a << '\n';
	}
} 

```

---

## 作者：NingMeng_yang (赞：1)

# [P13729 【MGVOI R1-A】超级奇数（odd）](https://www.luogu.com.cn/problem/P13729)

### Solution

对于找到最小的非负整数 $b$，使得 $a + b$ 是一个超级奇数。

思路就是构造比 $a$ 大的最小超级奇数，因为超级奇数减去 $a$ 等于 $b$，所以 $b$ 最小则超级奇数最小。

而构造规则就是从 $a$ 的高位到低位，每一位选择不小于当前位的最小奇数。若某一位选择的奇数大于 $a$ 的对应位，则后续所有位直接选最小奇数 $1$，因为高位已保证比 $a$ 大，低位越小，整体数越小。

### Code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;

int T,n;

bool check(int x)//判断是否为超级奇数
{
	if(x==0) return false;
	while(x)
	{
		int sum=x%10;
		if(sum%2==0) return false;
		x/=10;
	}
	return true;
}

int Ans(string &s,int n)
{
	string ans;
	int len=s.size();
	bool vis=false;
	
	for(int i=0;i<len;i++)
	{
		if(vis)
		{
			ans+='1';
			continue;
		}
		
		int x=s[i]-'0',sum=-1;
		if(x<=1) sum=1;
		else if(x<=3) sum=3;
		else if(x<=5) sum=5;
		else if(x<=7) sum=7;
		else if(x<=9) sum=9;
		
		if(sum!=-1)
		{
			ans+=(char)(sum+'0');
			if(sum>x) vis=true;
		}
		else
		{
			bool bl=false;
			while(!ans.empty())
			{
				int x=ans.back()-'0',sum=-1;
				ans.pop_back();
				if(x<1) sum=1;
				else if(x<3) sum=3;
				else if(x<5) sum=5;
				else if(x<7) sum=7;
				else if(x<9) sum=9;
				if(sum!=-1)
				{
					ans+=(char)(sum+'0');
					while(ans.size()<len) ans+='1';
					bl=true;
					break;
				}
			}
			if(!bl) return -1;
		}
	}
	return stoll(ans)-n;//stoll()是把字符串类型转化为long long类型
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>T;
	while(T--)
	{
		cin>>n;
		if(check(n)) cout<<0<<endl;
		else
		{
			string s=to_string(n);
            cout<<Ans(s,n)<<endl;
		}
	}
	
	return 0;
}
```

---

## 作者：_fallen_leaves_ (赞：0)

[P13729 【MGVOI R1-A】超级奇数（odd）](https://www.luogu.com.cn/problem/P13729)

## 题意
给你 $T$ 个正整数 $a$，要加上一个的正整数 $b$，使其 $a+b$ 成为超级奇数，问你最小的 $b$ 是多少？
::::info[超级奇数的定义]{open}
对于一个正整数，如果其中的每一位都是奇数，则定义它是一个超级奇数。
::::

## 思路
因为每一个数 $a$ 都较大，所以依次从 $a$ 往上加，一个一个数的尝试，是不行的。

所以本题考虑贪心，因为这个数的位数较少，所以我们可以从最高位到最低位依次遍历。找到第一位不是奇数的位，那么就要将这一位的数字增加，使其变为奇数，也就是将这一位加 $1$，然后让这后面所有的数字都变为 $1$。

让这个数与从那一位偶数开始后的 $a$ 相减，就是我们要求的 $b$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
signed main()
{
	cin>>t;
	while(t--)
	{
		string s;
		cin>>s;
		int s1=0,s2=0;
		for(int i=0;i<s.size();i++)
			if((s[i]-'0')%2==1) continue;
			else
			{
				s1+=(s[i]-'0')+1;
				s2+=(s[i]-'0'); 
				for(int j=i+1;j<s.size();j++)
				{
					s1=s1*10+1;
					s2=s2*10+(s[j]-'0'); 
				}
				break;
			} 
		cout<<s1-s2<<endl;
	}
	return 0;
}

```

---

## 作者：_Chronostatis_ (赞：0)

## 题意
给定一个正整数 $a$，要求求出另一个最小整数 $b$，使得这两个数相加得到的结果的每一位均为奇数。

## 思路
$a$ 有 $10^{12}$，显然不能直接枚举。如果你观察性质，但是观察得不够透彻，那么你会想当然地认为，只要对每一位计算到奇数所需要加的数，最后相加即可，当然这样显然是错误的，第一个样例的第三个数据给了你答案。

所以我们来思考贪心策略。我们希望数尽量小，那么需要尽可能多的 1。对于 $a$ 的第一个非奇数位来说，其前面的数位不需要改变，将当前数位以及后面的数位修改为奇数的最小操作代价就是将后面数位全部加到 1 的最小代价。由于 $a$ 还可以用整形变量表示，所以直接计算即可。当然，这里使用字符串来存储 $a$ 更加方便。

:::info[代码]
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

string a;

void Solve() {
  cin >> a;
  string b;
  for (int i = 0; i < a.size(); i++) {
    // 遇到了非奇数位
    if ((a[i] - '0') % 2 == 0) {
      ll p = a[i] - '0' + 1, q = a[i] - '0'; // 计算答案
      for (int j = i + 1; j < a.size(); j++) {
        p = p * 10 + 1, q = q * 10 + a[j] - '0';
      }
      cout << p - q << '\n';
      return;
    }
  }
  cout << 0 << '\n';
  // 已经合法
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int T;
  for (cin >> T; T--; Solve());
  return 0;
}
```
:::

---

## 作者：jiangyunuo (赞：0)

### 题目意思：
对于超级奇数的定义，题目讲的已经很清楚了，就不多赘述了。本题你可以理解为找出一个最小的同时大于 $a$ 的超级奇数 $c$，题目所求的 $b$ 就是 $c-a$ 的答案。

### 大体思路：
实际上，我们可以把这题的每一个变量都当作字符数组处理（假如有 $len$ 位，那么 $a$ 从高位到低位依次是 $a_1,a_2,\dots,a_{len}$，$c$ 也同理）。由于我们找的 $c$ 是在满足要求下最小的，因此我们从高位开始找。

我们不难发现，$c$ 的位数一定和 $a$ 一样，毕竟 $a$ 的最高位是奇数，则 $c$ 的这一位就和 $a$ 相同，反之，则 $c$ 的这一位就是 $a$ 的这一位加上一，一位偶数最大就是 $8$，所以绝对没有进位的可能。所以我们从前往后找是可以的。

值得注意的一点，如果 $c_i>a_i$ 且 $c_1=a_1,c_2=a_2,\dots,c_{i-1}=a_{i-1}$，则不管怎么样，$c>a$。

据此我们已经知道怎么做了，我们假定 $a_j$ 为从 $a$ 的高位往低位看，第一个为偶数的位，则 $c_1=a_1,c_2=a_2,\dots,c_{j-1}=a_{j-1}$ 而 $c_j=a_j+1$ 并且 $c_{j+1}=c_{j+2}=\dots=c_{len}=1$（我们当然是让这些位越小越好）。

接着做差转化为整形即可得到 $b$ 的值。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t,len;
	cin>>t;
	char a[20],c[20];
	long long b,d;
	bool z,zz;
	while(t){
		t--;
		z=b=zz=0;
		d=1;
		cin>>a;
		len=strlen(a);
		memset(c,0,sizeof(c));
		for(int i=0;i<len;i++){
			if(z)c[i]='1';
			else if(a[i]%2==0){
				c[i]=a[i]+1;
				z=1;
			}
			else c[i]=a[i];
		}
		if(z){
			for(int i=len-1;i>=0;i--){
				b+=d*(c[i]-a[i]);
				d*=10;
			}
		}
		cout<<b<<endl;
	} 
	return 0;
}
```

---

## 作者：FruitWasTaken (赞：0)

## 出题人题解

### 主要知识点

* 【3】贪心法

---

### 解法

显然暴力枚举 $b$ 会超时（只能过前 $13$ 个点），考虑优化。

题目等价于要找到一个最小的 $x$，满足 $x\ge a$ 且 $x$ 是一个超级奇数（然后只需输出 $b=x-a$）。我们充分发扬人类智慧：

1. 找到 $a$ 中 **最高的偶数位**，例如对 $a=11\red{4}514$，最高的偶数位是 $4$（已标红）。当然也有可能找不到偶数位，那么这种情况下 $a$ 本身就是一个超级奇数，直接输出 ```0``` 即可。

2. 接下来讨论其他情况（$a$ 不是超级奇数）：实际上最优的构造是把 $a$ 最高的偶数位加上 $1$（在这之后它变为奇数数码），然后贪心地把所有更低位的数码全部变成 $1$，就能得到最小的 $x$，例如 $$a=11\red{4}\orange{514} \rightarrow x=11\red{5}\orange{111}$$。 

* 显然，这样构造满足 $x > a$，并且 $x$ 是一个超级奇数。

* 不可能有满足条件的更小的 $x$ 了，因为它至少要将 $a$ 中最高的偶数数码替换成奇数数码，在这之后，将所有低位数码变成 $1$ 显然会最小化 $x$。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

string a, b;

int turn(string s) //将数字字符串转换为 int 格式
{
	int x = 0;
	for (int i = 0; i < s.length(); i++)
	{
		x *= 10; 
		x += s[i] - '0';
	}
	
	return x;
}


void solve()
{
	cin >> a;
	
	bool flag = false;
	b = a;
	for (int i = 0; i < a.length(); i++)
	{
		if (flag) 
		{
			b[i] = '1'; //若已经找到了最高的偶数位，直接将低位置为 1
		}
		else if ((a[i] - '0') % 2 == 0) //找到了最高的偶数位
		{
			b[i]++;
			flag = true; //标记
		}
	}

	cout << turn(b) - turn(a) << '\n';
}

signed main()
{
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	
	int _;	
	cin >> _;
	while (_--)
	{
		solve();
	}
	
	return 0;
}
```

---


# 坚果保龄球

## 题目描述

PVZ 这款游戏中，有一种坚果保龄球。zombie 从地图右侧不断出现，向左走，玩家需要从左侧滚动坚果来碾死他们。

我们可以认为地图是一个行数为 $6$，列数为 $60$ 的棋盘。zombie 出现的那一秒站在这一行的第 $60$ 列，之后每秒向左移动一步。玩家可以随时在屏幕最某一行第一列摆放坚果，这一行的 zombie 瞬间全被滚过去的坚果碾死。如果 zombie 走到第 $1$ 列没有被消灭，如果再向左走，则你的大脑就会被 zombie 吃掉。

现在有 $n$ 只 zombie！告诉你每只 zombie 出现的时间以及在出现的行数（可能会同时出现同一位置的僵尸），请问至少需要多少坚果才能消灭所有的 zombie。

## 说明/提示

### 数据范围及约定

对于全部数据，$n \le 2000$，$t \le 100000$，$1 \le P \le 6$。

### 题目来源

kkksc03 改编


## 样例 #1

### 输入

```
10
1 1
1 61
2 1
2 60
3 1
3 2
3 3
3 4
4 1
4 99999```

### 输出

```
6```

# 题解

## 作者：x义x (赞：159)

一道很简单的贪心模拟题~

想必大家已经想出贪心思路了：只有当一个zombie抵达第一列，我们才会不得不放坚果。很显然，这肯定是最佳方案。

具体实现思路是对每一行单独处理，对于每一只抵达第一行的zombie，用坚果杀死它，顺便杀死所有当前也在这行的zombie。

到底怎么写呢？请看代码。

```
#include<bits/stdc++.h>
using namespace std;

int t[7][2001];
int n,ans;

int main()
{
	cin>>n;
	int j[7];for(int i=1;i<=6;i++) j[i]=0;  //喜闻乐见的读入环节~ 
	
	for(int i=1;i<=n;i++)  //这里用time[i][j]表示第i行的第j只zombie的抵达时间 
	{
		int t1,t2;cin>>t1>>t2;
		t[t1][++j[t1]]=t2+60;
	}
	
	for(int i=1;i<=6;i++)
		sort(t[i]+1,t[i]+1+j[i]);
	/*
	for(int i=1;i<=5;i++)
	{
		for(int k=1;k<=j[i];k++)
			cout<<t[i][k]<<' ';
		cout<<endl;
	}
	*/  //调试时用的 
	for(int i=1;i<=6;i++) //对每一行分别处理
	{
		int x=1; //从这一行的第一只zombie开始碾压 
		while(x<=j[i])
		{
			ans++;
			int x1=x; 
			while(t[i][x1]<t[i][x]+60) x1++;
			//碾压所有同时在这一行的zombies！!注意<不能打成<=,否则样例都过不了 
			x=x1;
		}
	 }
	
	cout<<ans; 
 } 
```

总之，其实这题真的不难，不过在一些细节方面上要注意。

### 比如：
- 这道题的行数有6行而不是真正的pvz里的5行，我因为找不出这个错误还专门在讨论里发了个帖子……蠢啊
- 样例中zombie出现的次序是排序好的，但数据不是，所以要sort一下。如果刚学快排可以拿这题练练手。
- 注释中警告的那处。我们要碾压的最前面的zombie是在第1行，但第1+60=61行的那只zombie还没走上草地，所以那里应该是<而非<=。


------------

感谢浏览！如果你认为这篇题解的讲解还不错的话，请您为这篇题解点赞哦~

---

## 作者：jun1lesszZZ (赞：54)

这道题可以说是贪心的入门题，因为贪心的思路十分显然而易想，刚学贪心的朋友们可以拿来练手。

------------
首先开一个maxn数组储存每一行的最大时间值，然后开一个二维数组储存每一行每一个僵尸出现的时间，通过两层循环枚举，如果在一个六十秒之内出现过僵尸，则可以杀死这个六十秒内所有僵尸，也就是说只需增加一个保龄球，这一个六十秒之内所有僵尸都不需要在花额外的保龄球了

~~ps：我记得红色的坚果保龄球似乎可以一次炸周围好几行的僵尸啊所以这个题会不会有升级版呢？~~

------------

下面是代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int maxn[10],zom[10][500000];
int main()
{
	int n,t,p,tot = 0;
	cin >> n;
	for(int i = 1;i <= n;i ++)
	{
		cin >> p >> t;
		maxn[p] = max(maxn[p],t);//更新最大值
		zom[p][t] ++;//p行时间为t时出现僵尸
	}
	for(int i = 1;i <= 6;i ++)
	{
		for(int j = 1;j <= maxn[i];)
		{
			if(zom[i][j])
			{
				tot ++;//如果一段60s内有僵尸则需要一个保龄球
				j += 60;//然后就可以跳过这个六十秒因为一个保龄球可以杀死这个六十秒内的所有僵尸
			}
			else
				j ++;
		}
	}
	cout << tot;//输出结果
}
```

---

## 作者：lzn (赞：31)

《坚果保龄球》解题报告

By lzn
贪心简单题。

首先需要知道地图上每一行是互不干扰的，所以我们把每行分开求最优解再相加即可。剩下的就是对每一行如何决策放置坚果的时间的问题。而很容易说明当第一波僵尸中走最远的到达第60列时放坚果，然后等待下一波的僵尸，如此往复即可得到最优解。

由于要对僵尸出现的时间排序，复杂度O(nlog(n))。


---

## 作者：灵乌路空 (赞：19)

###### 本题大致思路:
###### 用ans变量,储存答案 用一个a[7]变量,分别储存在某一行放最新一个土豆的时间.用b[2010]变量,放每个僵尸的数据
###### 输入僵尸数据后,按照出现时的时间进行升序排列,来模拟出现的时间先后顺序
###### 再分别枚举每个僵尸,看它出现的时间,是否在:    此行上个土豆的时间~此行上个土豆的时间+60之间
###### 若是,则不需要新的土豆,ans不变
###### 若不是,则需要一个新的土豆,来neng死他,ans变量++;同时,a数组中,相应行中新土豆出现时间置为t-1(可以捉摸琢磨为什么-1 QVQ)
###### 然后枚举下一个僵尸 


------------

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct zombie
{
	int p,t;
}b[2010];//放每个僵尸的数据 
int a[7];
int ans=0;
int n;
bool cmp(zombie x,zombie y)
{
	return x.t<y.t;
}
int main()
{
	scanf("%d",&n);
	memset(a,-60,sizeof(a));//先将a置为-60,使每一个t都大于a[i]+60,以便于判断的开始 
	for(int i=1;i<=n;i++)
	  scanf("%d%d",&b[i].p,&b[i].t);
	sort(b+1,b+n+1,cmp);//按t升序排列 
	for(int i=1;i<=n;i++)
	  if(a[b[i].p]<b[i].t && a[b[i].p]+60>=b[i].t) bool no_use_bool_just_take_it_a_joke; //为了使用else而设的if 
	  	else
	  	  {
	  	  	ans++;//增加答案 
	  	  	a[b[i].p]=b[i].t-1;//赋新的t值 
		  }   
	printf("%d",ans);//完美潇洒の结束 
}
```


------------


------------


---

## 作者：MloVtry (赞：14)

我可能遇到了假的评测机，一点没改先wa后ac，白瞎我瞪了半个小时。

思路的话，对于僵尸我们可以排序，按照行号来：我们可以知道，对于第一个僵尸，我们必定要投放坚果，这时我们可以记住此时的时间以及行号【lp（last p），lt】，如果一个僵尸【同行】和lt的差小于60，那么我们是可以用一个果子解决的；如果大于，那么我们可以认为之前的都没过掉了，就可以ans++，继而更新lt；

对于换行的情况，我们必定要多放一个果子，此时也可以更新lt；

代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans=1;//第一个果子必放，遍历从2开始
struct zom
{
    int p,t;
}a[2010];
bool comp(zom s,zom b)
{
    if(s.p==b.p) return s.t<b.t;
    return s.p<b.p;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d%d",&a[i].p,&a[i].t);
    }
    sort(a+1,a+n+1,comp);
    int lp=a[1].p,lt=a[1].t;
    for(int i=2;i<=n;++i)
    {
        if(a[i].p!=lp)
        {
            ans++;
            lp=a[i].p;
            lt=a[i].t;
            continue;
        }
        if(a[i].t-lt>=60) 
        {
            ans++;
            lt=a[i].t;
        }
    }
    printf("%d",ans);
    return 0;
}
还是蛮简单
```

---

## 作者：qxy20040629 (赞：11)

我来写题解了哈哈哈，废话少说先分析题......；

大家可以发现这里的坚果其实是火爆辣椒2333，那么我们要尽量多消灭僵尸，就需要在僵尸位于1列时在放置（ans++），这样就能尽量多消灭僵尸；

还有就是不管一格无论有多少僵尸都是一样的，都可以秒杀的，所以可以用bool存状态（其实没必要，但空间能省就省），没有为0(false),有就是1（true）；

定义变量；
```cpp
int n,t,p,ans;
bool kk[7][100010];
```
n是僵尸数量，t为时间，p为位置，ans是坚果数量；

我们先读一下状态；
```cpp
cin>>n;
for(int i=1;i<=n;i++){
	cin>>p>>t;
	kk[p][t]=1;
}
```
此处1就是有僵尸，由于是全局变量，初值默认0，直接赋值；

然后从第一行到第六行，读它！一个一个读；但是读到几呢？我们确实可以储存最后一个僵尸，但是我们瞟一眼数据规模，2000和100000！不用再存，直接盘他！：
```cpp
for(int i=1;i<=6;i++){
		for(int j=1;j<=100000;j++){
			if(kk[i][j]==1) {
				ans++;
				j=j+59;
			}
		}
	}
```
为什么是j=j+59呢？交给各位思考，答案最后告诉大家；

最后return 0；大♂功告♂成
完事；

///////////顺便回忆一下这款经典游戏////////////////////////////////////////////////

![](https://i.loli.net/2019/11/09/xbCua3XD5LNHmEQ.jpg)
![](https://i.loli.net/2019/11/09/WL7IKFRfiM3QtHT.jpg)
好像有什么不对劲(/¤ω¤\）

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
为甚是59呢？？j++而已；

全部代码，禁止抄袭
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,p,ans;
bool kk[7][100010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>p>>t;
		kk[p][t]=1;
	}
	for(int i=1;i<=6;i++){
		for(int j=1;j<=100010;j++){
			if(kk[i][j]==1) {
				ans++;
				j=j+59;
			}
		}
	}
	cout<<ans;
	return 0;
} 
```
过过过过

---

## 作者：zy小可爱ღ (赞：7)

看了看楼下大佬们的题解，发现自己的代码好像略短一点，思路也略有不同，就厚颜无耻地过来发题解了~~~  
本题是一道很简单的基础贪心模拟题，数据也不大，还是蛮容易的，下面先对本题进行一个简单的分析  
很显然，zombie只能在刚开始出现的行一直走下去，无法进入其他行列，所以在排完序之后，只需要在每一行单独考虑，同时在排完序后，每行zombie出现的时间是单调递增的，并且本题的坚果很强，可以在出来的一瞬间消灭一行，所以完全可以在zombie走到第一列时，再放坚果，下面给出AC代码：
```cpp
#include<cmath>
#include<ctime>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;//头文件

int n,ans;//n组数据和输出答案，answer
struct node{//定义结构体，便于排序
	int s,t;
}a[2005];

bool cmp(node a,node b){//结构体排序，先判断是否在同一列上，再判断时间的先后顺序，如果不能理解，就分开写吧。。。
	return a.s!=b.s?a.s<b.s:a.t<b.t;//三目表达式，显得我很有文化啊（划掉）
}

int main(){//主程序
	scanf("%d",&n);//n组数据
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].s,&a[i].t);//输入行数和时间
	}
	sort(a+1,a+1+n,cmp);//对数组排序
	for(int i=1;i<=n;){//实际操作
		int f=a[i].s,p=a[i].t;//f用于记下当前所在行数，p用于判断时间是否得放坚果
		for(i++;f==a[i].s;i++){//访问同一行
			if(a[i].t-59>p){//如果当前zombie的时间比p记下的时间要早过59秒，即记下的zombie可以吃掉你的nz时
				ans++;//答案加一
				p=a[i].t;//更改时间
			}
		}
		ans++;//因为最后一次更改时间的时候，访问的一行上zombie并没有消灭完，所以答案要加一
	}
	printf("%d\n",ans);//输出答案
	return 0;
}

```
难得，我竟然在分析题目的时候打了这么多字   
如果对本题还有不理解的，本人QQ：2124652975，欢迎骚扰~~

---

## 作者：zhi_zhang (赞：6)

使用最少的坚果，当然就是在当前行第一个僵尸踏进家门前塞一个坚果过去

按照从第一行到第六行，时间先的在前 的顺序逐行逐个进行判断

- 如果换行了，答案加一，标记的时间改为这行第一个出现的时间

- 如果当前僵尸出现时间减去上一个坚果释放的时间>=60，那就再塞一个坚果过去

PS：样例前两个，当两个时间相减到达60时，等第二个僵尸出来再放坚果的话，脑子已经被吃掉了

只要记好这两条，然后按顺序轮着看一遍就好了

代码如下

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{int row,tim;}zob[2000+10];
int N,ans=1;			//答案初始化为1没有问题，看来这题并没有0个僵尸的情况 
bool cmp(node a,node b)	//按照行数和时间排列 
{
	if(a.row==b.row) return a.tim<b.tim;
	else return a.row<b.row;
}
int main()
{
	scanf("%d",&N);
	for(int i=1;i<=N;i++) scanf("%d%d",&zob[i].row,&zob[i].tim);
	sort(zob+1,zob+N+1,cmp);
	int las_t=zob[1].tim,las_r=zob[1].row;//初始化标记行和标记时间为最前行的第一个僵尸 
	for(int i=2;i<=N;i++)				//第一个僵尸已经算在里面了，直接从第二个开始 
	{
		if(las_r!=zob[i].row)//如果换行了 
		{	ans++;			 //答案加一 
			las_r=zob[i].row,las_t=zob[i].tim;//更改标记行和标记时间 
			continue;
		}
		if(zob[i].tim-las_t>=60)//如果间隔时间到达或超过了60秒
		{	ans++;				//答案加一 
			las_t=zob[i].tim;	//更改标记时间 
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

为了方便分析，以下所有zombie用z替代

由于这题只有6行，

所以我们可以将每行中的每个z出现的时间分别存入对应的以行数命明的数组里

将所有z出现的时间存入数组后，

如何计算最少需要几个坚果成了最重要的问题

计算方法其实很简单

因为所有z在出现后的59个时间段后，便会到达第1列

而这时，你不得不用一个坚果把它干掉

干掉它的同时，它后面的z也会被干掉

所以我们可以分段计算

设第一行第n个z的出现时间为x[n]

首先第一个z的到达时间为x[1]+59，在这个时间段我们就不得不干掉它

而它后面的所有z都会被干掉

接下来，再计算没被干掉的第一个z的到达时间，并重复以上的运算

二到六行也是如此

代码如下：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,x,y,x1[2001],x2[2001],x3[2001],x4[2001],x5[2001],x6[2001],t1,t2,t3,t4,t5,t6;
int f(int n,int x[])
{
    if (n==0) return 0;
    sort(x+1,x+1+n);
    int t=x[1]+59,tt=0;
    x[n+1]=x[n]+60;
    for (int i=1;i<=n;i++)
    {
        if (t==0) t=x[i]+59;
        if (x[i]<=t&&x[i+1]>t) {tt++;t=0;}
    }
    return tt;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>x>>y;
        if (x==1) {t1++;x1[t1]=y;}
        if (x==2) {t2++;x2[t2]=y;}
        if (x==3) {t3++;x3[t3]=y;}
        if (x==4) {t4++;x4[t4]=y;}
        if (x==5) {t5++;x5[t5]=y;}
        if (x==6) {t6++;x6[t6]=y;}
    }
    cout<<f(t1,x1)+f(t2,x2)+f(t3,x3)+f(t4,x4)+f(t5,x5)+f(t6,x6);
    return 0;
}
```

---

## 作者：B_lhx (赞：2)

P1413 【坚果保龄球】
===
[原题链接](https://www.luogu.com.cn/problem/P1413)
-
	这是一道模拟题，为了保住自己的大脑，
    不能让一个zombie冲过第一列，而为了
    使用最少的坚果（可能用来食用），要
    让每一个zombie走到第一列再发射坚果
    （好压死更多的zombie），先将zombie
    按时间排序，并记录被压死的zombie。
    
```
#include <bits/stdc++.h>
using namespace std;
int n,cnt=0; //cnt记录最少要用多少个坚果
struct per{//定义zombie
	int l,t;//l代表哪一行，t代表时间
}a[100005];//zombie
int pd[100005];//判断zombie死没死的判断数组
bool cmd(per xx,per yy){//排序
	return xx.t<yy.t;
}
int main(){
	cin>>n;
	for(int i = 0;i<n;i++){
		cin>>a[i].l>>a[i].t;
	}
	sort(a,a+n,cmd);//把zombie按时间排序
	for(int i = 0;i<n;i++){
		if(pd[i]){//如果zombie已经死了
			continue;//跳过他
		}
		int x=i+1;
		cnt++;
		while(x<n){
			if(a[x].l==a[i].l&&a[x].t-a[i].t<60){//查找被压死的zombie
				pd[x]=1;
			}
			x++;
		}
	}
	cout<<cnt;//输出
return 0;
}

```


---

## 作者：hensier (赞：1)

这道题可以用$sort$辅助进行判断。在输入$n$以后，我们可以在$[1,n]$区间进行输入，对于每一个$i$输入两个参数并操作。

该部分代码如下：（备注：$i$为循环使用的变量，$k$、$l$为每一个$i$所输入的两个参数，$a[]$为保存每一排僵尸数量的数组，$z[][]$这个二维数组的第一个下标表示排数，第二个下标表示数量，而$z[][]$这个数值则表示僵尸所侵入的时间）

```cpp
for(i=1;i<=n;i++)
{
    scanf("%d%d",&k,&l);
    a[k]++;
    z[k][a[k]]=l;
}
```

由于输入的时间不一定按先后排序，因此我们要用$sort$进行处理。具体方式是：（备注：由于$sort$排序用的是指针，因此对于二维数组同样适用）

```cpp
for(i=1;i<7;i++)std::sort(z[i]+1,z[i]+a[i]+1);
```

我们根据分析，可以发现：假若两个相邻的僵尸侵入时间小于$60$，则可以用同一个坚果保龄球消灭。因此我们可以令初始时间等于每一列第一个僵尸进入的时间，然后每一次时间大于等于$60$就替换并让计数器加$1$。

代码核心部分：

```cpp
for(i=1;i<7;i++)
{
    if(!a[i])continue;//如果没有僵尸就直接进入下一层循环
    m++;//如果现在是第一个僵尸就让计数器加1（例：如果该列只有1个僵尸，也需要1个坚果，所以如果该列有僵尸，则初始要加1）
    f=0;//标记时间是否已经改变过
    if(!f)
    {
        s=z[i][1];//将时间设定
        f=1;
    }
    for(j=2;j<=a[i];j++)
    {
        if(z[i][j]-s>=60)//判断时间差
        {
            s=z[i][j];//替换时间
            m++;//坚果数量加1
            f=0;
        }
    }
}
```

核心部分处理完以后，直接输出$m$即可。

$AC$代码：[（本蒟蒻AC记录）](https://www.luogu.com.cn/record/30921733)

```cpp
#include<cstdio>
#include<algorithm>
int n,i,j,k,l,s,m,a[7],z[7][2001];
bool f;
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&k,&l);
        a[k]++;
        z[k][a[k]]=l;
    }
    for(i=1;i<7;i++)std::sort(z[i]+1,z[i]+a[i]+1);
    for(i=1;i<7;i++)
    {
        if(!a[i])continue;
        m++;
        f=0;
        if(!f)
        {
            s=z[i][1];
            f=1;
        }
        for(j=2;j<=a[i];j++)
        {
            if(z[i][j]-s>=60)
            {
                s=z[i][j];
                m++;
                f=0;
            }
        }
    }
    printf("%d",m);
}
```

---

## 作者：Amontillado (赞：1)

### 这是一道很简单的贪心模拟题.

#### 根据题意,我们可以得知,能被一个坚果同时杀死的两个僵尸的最大出现时间差不能超过$60-1=59$,并且地图只有$6$行.

#### 因此,我们可以开一个二维数组$v[i][j]$,其中$v[i]$存放第$i$行中出现的所有僵尸的出现时间(在这里为方便,我使用vector)

## 重点说一下计算需要的坚果数的思路:

#### 先将每一行的僵尸按出现时间排序,然后对于每一排的时间我们可以定义一个左端点$l$和右端点$r$,分别对应可以被一次性杀死的最多僵尸的最前一个和最后一个的出现时间,因此可以得到:$v[i][r]-v[i][l]<=59$.

#### 而当时间之差大于或等于$60$时,说明此时左端点的僵尸无法与右端点的僵尸被同时杀死,因此此时更新左端点$l$,并将该行所需坚果数$+1$.
```cpp
#include<iostream>
//#include<fstream>
#include<algorithm>
#include<vector>
using namespace std;
//ifstream cin("C.in");
//ofstream cout("C.out");
vector<int> v[10];                              //一个vector<int>型的数组(类似二维数组),v[i]存放第i行所有僵尸出现时间
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int line,num;
        cin>>line>>num;
        v[line].push_back(num);
    }
    for(int i=1;i<=6;i++)
        if(!v[i].empty())                       //当序列不为空时,对其进行排序操作
            sort(v[i].begin(),v[i].end());
    int ans=0;
    for(int i=1;i<=6;i++)
    {
        if(v[i].empty())                        //若序列为空,则不需要坚果杀死僵尸,直接continue掉
            continue;
        int l,r;                                //l~r为一段时间区间(其实是时间数组的下标)
        l=r=0;                                  //初始时区间起点为零,长度为零
        int sum=1;                              //由于当前序列不为空,所以至少需要1个坚果杀死僵尸
        for(int j=0;j<v[i].size();j++)
        {
            r=j;
            if(v[i][r]-v[i][l]>=60)             //当区间长度超过60秒时,更新区间左端点
                l=r,sum++;
        }
        ans+=sum;
    }
    cout<<ans<<endl;                            //输出
    return 0;
}
```

---

## 作者：hmh13951417981 (赞：1)

# 注：这道题是有6行的,和普通的PVZ不同
# 这道题的贪心策略为只要放一个，它后面到第59个位置都倒了
------------
# 附上AC代码
```c
#include<bits/stdc++.h>
using namespace std;
int i,j,n,a[7][100001],maxx[7],s,hang,wei;
/*数组a用来存放僵尸的行数和出发地点,数组maxx用来存放僵尸到达的
最远距离*/ 
int main()
{	cin>>n;
	for(i=1;i<=n;i++)
	{cin>>hang>>wei;//输入 
	a[hang][wei]=1;//那个位置值为1 
	if(wei>maxx[hang]) 
	maxx[hang]=wei;}//选出最远的地点(优化) 
	for(i=1;i<=6;i++)//每一行都从前到后枚举过去 
		for(j=1;j<=maxx[i];j++)
		if(a[i][j]==1)//要是有僵尸,坚果数量累加 
		{s++; j+=59;}//再从它后面59的位置继续枚举 
	cout<<s;//输出 
	return 0;
}
```

---

## 作者：LFGF (赞：1)

//来发一篇最浅显易懂的题解，求过


```
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
#define REG register//玄学加速
#define ll long long
int maxx[7],ans=0;
int s[7][100010];//六行，但按时间来创建数组
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(REG int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		if(y>maxx[x]) maxx[x]=y;//算是一个剪枝吧，记住每一行的最大值
		s[x][y]++;//那一行的那个时间点增加一个僵尸
	}
	for(int i=1;i<=6;i++)
    {
        for(REG int k=1;k<=maxx[i];k++)
        {
        //解释一下，这一行开始扫，扫到有僵尸，坚果就+1，然后这个时间点的后59秒（包括了自己，就60秒）都可以被坚果扫过，跳过数组中的60个空后继续扫，扫完一行就换行
            if(s[i][k]!=0)
            {
            	ans++;
            	k+=59;//一定要用59，用60就过不了，手动模拟一下应该就懂了，例如1行的1与61就可以模拟一下
            }
        }
     }
	printf("%d",ans);//输出坚果个数
	return 0;
}
//祝大家打代码愉快！！！
```

---

## 作者：巨型方块 (赞：1)

这种模拟题，每个人其实想一想都会做，但是方法是不是最优呢？这个就要看实力了

我的方法是，对于僵尸按出现时间排序，那么一只只枚举过去；

记录mi[]数组代表这条道路最近的清空时间；

那么如果当前的僵尸会在清空时间之前的话那么就跳过；

不然，我们算出这只僵尸到达第一各的时间，然后放一颗坚果，更新mi[]，枚举下一个

代码的细节那就不细讲了，模拟题嘛，就是考细节的；

```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
const int N=2005;
struct cs{int x,y;}a[N];
int mi[10],now,ans,n;
bool cmp(cs a,cs b){return a.y<b.y;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d",&a[i].x,&a[i].y),a[i].y--;
    sort(a+1,a+n+1,cmp);
    memset(mi,-1,sizeof mi);
    for(int i=1;i<=n;i++)
        if(mi[a[i].x]<=a[i].y){
            if(a[i].y-now>0)now+=a[i].y;
            a[i].y-=now;
            now+=60-abs(a[i].y);
            ans++;
            mi[a[i].x]=now;
        }
    printf("%d",ans); 
}
```

---

## 作者：谁懂谁伤心 (赞：1)

这题可用二维数组记录每个僵尸的出现位置与时间，然后逐点判断，不会超时。(当然还可以进行优化：进行标记，当某排没有出现任何一只僵尸，该排就跳过不管。   标程中没有优化，不过大家可以自己尝试。)

```cpp

#include <iostream>  
using namespace std;  
int a[7][100001],s,z1,z2,k;  
int main()  
{  
scanf("%d",&s); for (int q=1;q<=s;q++) {scanf("%d%d",&z1,&z2); a[z1][z2]++;}  
for (int q=1;q<=6;q++)  
for (int w=1;w<=100000;w++)  
if (a[q][w]>=1){w+=59; k++;}  
printf("%d",k);  
return 0;  
}  
```

---

## 作者：一鸣惊人之人 (赞：0)

这题是一道简单的贪心题目，只要把同一行并且时间相差60以下的行数全部归零就行了。

并且要强调一点：

在PVZ中，这是个巨大的坚果，这里没有爆炸和会改变方向的坚果。

所以请放心做，这不会改变方向，也不会爆炸，当然这里也全是普通僵尸，没有舞王（会召唤僵尸）。（说偏了）

最后，祭上代码

```
#include<bits/stdc++.h>//万能头
using namespace std;
struct zombie{
	int p,t;
};//定义结构体
bool cmp(zombie x,zombie y)
{
	return x.t<y.t;//结构体排序必备
}
int main()
{
	int n,ans=0;
	zombie z[2001]={0};
	cin>>n;
	for(int i=1;i<=n;++i)
	cin>>z[i].p>>z[i].t;//输入
	sort(z+1,z+n+1,cmp);//对时间进行排序
	for(int i=1;i<=n;++i)
	{
		if(z[i].p)//如果不为0的话
		{
	        for(int j=i+1;j<=n;++j)
	        {
	    	    if(z[i].t+60>z[j].t&&z[i].p==z[j].p)
	    	    {
	    		    z[j].p=0;//归零
	    	    }
	        }
	        ans++;//要多一个坚果
	    }
	}
	cout<<ans;//输出答案
	return 0;//结束程序
}
```


---

## 作者：_•́へ•́╬_ (赞：0)

# STL大法好
##### 楼下的dalao讲的够清楚，只是我用了一个优先队列，不用排序了
```cpp
#include<bits/stdc++.h>//懒人专用头文件
#define rpt(n) for(register int ttxyc=0;ttxyc<n;++ttxyc)/宏定义
using namespace std;
int n,x,y,ans;priority_queue<int,vector<int>,greater<int> >a[6];
main()
{
    scanf("%d",&n);
    rpt(n)
    {
    	scanf("%d%d",&x,&y);//输入
    	a[--x].push(y);//队列常识
	}
	rpt(6)
		for(;a[ttxyc].size();++ans)
		{
			int last=a[ttxyc].top()+60;//是这个坚果可以干掉的最后时间
			for(;a[ttxyc].size()&&a[ttxyc].top()<last;a[ttxyc].pop());//要是<，不能≤，自己分析样例
		}
	printf("%d",ans);//输出
}/**/
```

---

## 作者：Steinway (赞：0)

模拟80分的小伙伴看这里...  
（看到提交记录中有多个80分之后就没有提交了 应该是不知道改哪里 我这里就指出一下）  
因为我们循环找下一个的时候j的指标一直到n都可能跳不出去  
我们处理一下 当j=n的时候我们特判一下即可  
所以 如果你#1和#4错了的话 那么可能是这里的问题
```cpp
//#define fre yes

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn = 2005;
struct Node {
    int x,sum;
}arr[maxn];

int n,ans;

template<typename T>inline void read(T&x)
{
    x = 0;char c;int lenp = 1;
    do { c = getchar();if(c == '-') lenp = -1; } while(!isdigit(c));
    do { x = x * 10 + c - '0';c = getchar(); } while(isdigit(c));
    x *= lenp;
}

bool cmp(Node x,Node y)
{
    if(x.x != y.x) return x.x < y.x;
    else return x.sum < y.sum;
}

int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        read(x);read(y);
        arr[i].x = x;
        arr[i].sum = y;
    } sort(arr+1,arr+1+n,cmp);
    for (int i=1;i<=n;i++)
    {
        ans++;
        int p = arr[i].sum + 59;
        for (int j=i+1;j<=n;j++)
        {
            if(arr[j].x == arr[i].x)
            {
                if(p < arr[j].sum)
                {
                    i = j-1;
                    break;
                }
            }
            if(arr[j].x != arr[i].x)
            {
                i = j-1;
                break;
            }
            if(j == n) { i = n;break; } //这里 错误在这里
        }
    } printf("%d\n",ans);
    return 0;
}
```  

---

## 作者：MrMagnificent (赞：0)

用了一个类似于桶的原理，把每行设成一个桶，然后按行的时间去更新一个目前坚果时间适用范围，统计见过数


                
```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
struct node
{
    int t[2000]={0};//该行每个僵尸的出现时间
    int num=0;      //num是每行的僵尸数
}a[7];
int n,ans=0;
inline int read( );
int main( )
{
    n=read( );          //输入10只僵尸
    for(int i=1;i<=n;i++)
    {
        int k=read( );      //行号
        a[k].t[++a[k].num]=read( );
        //输入该行的僵尸时间和僵尸数
    }
    for(int i=1;i<=6;i++)
    {
        sort(a[i].t+1,a[i].t+1+a[i].num);
    }
    for(int i=1;i<=6;i++)
        //遍历6行
    {
        if(a[i].num>0)
             //若该行上有僵尸
        {
            int pos=1;
            ans++;
            //第一个僵尸费一个坚果
            for(int j=2;j<=a[i].num;j++)
            {
                if(a[i].t[j]-a[i].t[pos]>=60)
        //若该行上后面的僵尸与前一个用坚果的僵尸出现时间间隔大于60
                {
                    pos=j;
                    ans++;
```
}//给他用一个坚果

```cpp
            }
        }
    }
    printf("%d\n" ,ans);
    return 0;
}
inline int read( )  //读入优化
{
    int p=0,f=1;char c=getchar( );
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar( );}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar( );}
    return f*p;
}

```

---

## 作者：ljc20020730 (赞：0)

这题难度虽然是普及-，但是我还是用了20min+的时间来解决这道题

应该来说我的AC效率是比较厉害的

20ms /  23.5MB

代码：0.99KB Pas 坚果保龄球

因为我开了二维数组，所以空间上面有点浪费（可以开到而不RE）

这里我用a[hang,i]（i>0）表示第hang行的第i个僵尸是什么时候出现的，

而a[hang,0]表示第hang行有多少个僵尸

然后对于a[hang,i]（1<=i<=a[hang,0]）排序，所以就成了一个每行都有序的数组

对于样例来说，这个数组是这样的：

1：1 61

2：1 60

3：1 2 3 4

4：1 99999

5：
6：
大概就是这个意思~~

完毕以后用for+while语句来求最后的ans值

```cpp
for i:=1 to 6 do begin//1-6行全部遍历
  p:=a[i,1]; j:=1;//p表示当前正在击杀的僵尸出现的时间，j表示这是第几个僵尸（坑点：从1开始）
  while j<=a[i,0] do begin//小于僵尸数
   inc(ans);//累加答案
   while (a[i,j]-p<60)and(j<=a[i,0]) do inc(j);//两个条件，少后面的条件201
   p:=a[i,j];//迭代思想：用a[i,j]迭代掉原来的p值
  end;
 end;
```
于是程序就呼之即出了

```cpp
var time,hang,i,j,ans,n,p:longint;
    a:array[0..2000,0..2000]of longint;
    tt:array[1..100000]of longint;//快排临时变量
procedure qsort(l,r:longint);//快排不解释
var t,i,j,mid:longint;
begin
i:=l; j:=r;
mid:=tt[(l+r)div 2];
while i<j do
begin
 while tt[i]<mid do inc(i);
 while tt[j]>mid do dec(j);
 if i<=j then begin
   t:=tt[i]; tt[i]:=tt[j]; tt[j]:=t;
   inc(i);dec(j);
 end;
end;
if l<j then qsort(l,j);
if r>i then qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do begin
   read(hang,time);
   inc(a[hang,0]);
   a[hang,a[hang,0]]:=time;
 end;//读入，这里用a[hang,i]（i>0）表示第hang行的第i个僵尸是什么时候出现的，而a[hang,0]表示第hang行有多少个僵尸
 for i:=1 to 6 do begin
  for j:=1 to a[i,0] do tt[j]:=a[i,j];
  if a[i,0]<>0 then begin qsort(1,a[i,0]);
  for j:=1 to a[i,0] do a[i,j]:=tt[j];end;
 end;//对于a[hang,i]（1<=i<=a[hang,0]）排序，所以就成了一个每行都有序的数组
for i:=1 to 6 do begin//1-6行全部遍历
  p:=a[i,1]; j:=1;//p表示当前正在击杀的僵尸出现的时间，j表示这是第几个僵尸（坑点：从1开始）
  while j<=a[i,0] do begin//小于僵尸数
   inc(ans);//累加答案
   while (a[i,j]-p<60)and(j<=a[i,0]) do inc(j);//两个条件，少后面的条件201
   p:=a[i,j];//迭代思想：用a[i,j]迭代掉原来的p值
  end;
 end;
  writeln(ans);
end.
```
真的是一道好题


---


# 陶陶摘苹果（升级版）

## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。


## 样例 #1

### 输入

```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2```

### 输出

```
4```

# 题解

## 作者：ASZIIIS (赞：767)

# _~~**滑稽题解第二弹**~~_
大家好，我是一个入门一年还在入门的蒟蒻。

今天天气不太好，我决定回新手村看看。

然后我就随手点开了一个题。

看到题面一开始我有点惊……现在新手村就开始用背包了吗？

然而事后我发现这个题好像并没有想象中的那么难……

然后我就看了看我当时交的代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,s,a,b,c,d,e;
int p[5001][2];
void qkst(int l,int r){
	int i,j,md;
	i=l;
	j=r;
	md=p[(l+r)/2][1];
	while(i<=j){
		while(p[i][1]<md) i++;
		while(p[j][1]>md) j--;
		if(i<=j){
			int tm=p[i][1];
			p[i][1]=p[j][1];
			p[j][1]=tm;
			int tp=p[i][0];
			p[i][0]=p[j][0];
			p[j][0]=tp;
			i++;j--;
		}
	}
	if(l<j) qkst(l,j);
	if(i<r) qkst(i,r);
}
int main(){
	memset(p,0,sizeof(p));
	e=0;
	cin>>n>>s>>a>>b;
	c=a+b;
	for(int i=1;i<=n;i++){
		cin>>p[i][0]>>p[i][1];
	}
	qkst(1,n);
	for(int i=1;i<=n;i++){
		if(s>=p[i][1]&&c>=p[i][0]){
			s-=p[i][1];
			e++;
			continue;
	    }
		if(s<p[i][1]){
			break;
		}
	}
	cout<<e;
}
```
emmmmmm……

我居然当年就会用贪心了……排序用的还是快排……我现在快排都忘得一干二净了……

所以这题又激起了我一题多解的欲望。

那么下面就让我来分享一下我想到的几种办法

（上一版由于写了15版代码，导致篇幅过长，为了精简题解，我只好将许多知识点略过去或者粗讲。这次为了改善大家的学习体验，以下知识点都会尽力细讲）

———————————————————————————————————————

### 往期链接：
第一弹：一个红题带你了解绿（黄）题知识点 ([传送门](https://www.luogu.org/blog/funny-talk/funny-solution-p1427))

———————————————————————————————————————


------------
## 1.搜索
搜索是一种很基本的算法，很多算法或多或少都是建立在搜索的基础上的。搜索思路简单，适用性广，如果不存在时间或空间的限制的话，基本上没有搜索解不了的题。

但是搜索的缺点也同样明显，由于它过于基础，难免有点粗枝大条，DFS容易TLE（运行超时），BFS容易MLE（运行内存超空间），有时DFS还面临着递归层数过多爆栈的风险……

我们在这里重点讲DFS搜索优化，BFS做法暂且先不讲了。
### （1）第一版:无优化写法
搜索之所以可以被广泛地被使用于各种题目，就是因为它思路简单，实现容易。

搜索的基本思路就是枚举，枚举可能出现的各种情况，然后从中找到满足条件的结果。

对于这个题，朴素的搜索方法就是DFS搜索每个苹果，每个苹果可分支出两个搜索子树：摘这个苹果或者不摘这个苹果。比如这样的一棵搜索树：
![搜索树图示](https://cdn.luogu.com.cn/upload/pic/41182.png)

那我们的代码实现也很简单：

我们使用递归函数，从第一个苹果开始递归访问，如果这个苹果可以取（高度够得到或者当前剩下的体力还够用），则递归搜索取这个苹果的子树。然后无论能不能取都递归搜索不取这个苹果的子树。

当搜索到叶子节点也就是第n+1个苹果（这个苹果并不存在）的时候，返回0。对于其他苹果节点，返回两个搜索子树返回值中的较大值（只有一个则返回那个值）。

那么函数的返回值是什么意思呢？返回值表示这个苹果的搜索子树里的最大能取的苹果数量。

具体的代码实现可以参考下面这份代码（这份代码并不能通过）：
```cpp
#include<iostream>
using namespace std;
int n,s,a,b,ans;
int xi[5005],yi[5005];
int dfs(int num,int rest){
    if(num>n) return 0;//如果到了第n+1个苹果,就说明DFS递归到底了
    int maxn=0;
    if(xi[num]<=a+b&&rest>=yi[num]){
        maxn=dfs(num+1,rest-yi[num])+1>dfs(num+1,rest)?dfs(num+1,rest-yi[num])+1:dfs(num+1,rest);//dfs()+1表示取当前搜索到的苹果，因此摘到苹果的总数+1
    }//返回两个搜索子树里最大值的较大值
    return maxn;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>xi[i]>>yi[i];
    }
    cout<<dfs(1,s);//从第一个苹果开始递归求解
    return 0;
} 
```
但是这个代码如果你提交的话，就会完美的TLE掉。我们看一下这个题的数据范围，n最大有5000个，每个苹果有取或不取两个选择，那么搜索完所有的子树差不多就是$2^{5000}$次运算。而计算机一秒只能运算大约$10^7$次左右，当然会TLE了。

这种最朴素的搜索算法时间复杂度差不多是$O(2^n)$的……几乎绝大部分的题目的较大的数据都过不去……那么我们有什么好办法吗？确实存在方法——剪枝和记忆化搜索。
### （2）第二版:优化写法
所谓剪枝，就是将对答案没有贡献的搜索子树剪去，从而减少搜索次数，提高运行速度的一种搜索优化方法。剪枝对于DFS的优化效果比较明显，上面一版代码的运行时间跑到了3500多毫秒，但是优化后113毫秒就跑完了（虽然这样还不是最快）。那这90%左右的时间是怎么优化掉的呢？

首先先不去考虑剪枝那么难的东西，大家有没有注意到上面的代码里有这么一行：
```cpp
maxn=dfs(num+1,rest-yi[num])+1>dfs(num+1,rest)?dfs(num+1,rest-yi[num])+1:dfs(num+1,rest);
```
我们要知道，如果想得到一个函数的返回值，首先就要运行一遍这个函数。复杂度如此高的函数在比较和调用值的时候分别运算了一次，就相当于给搜索树凭空加了好多无用的搜索子树。那么我们能不能用两个个变量来存储$dfs(num+1,rest-yi[num])$和$dfs(num+1,rest)$的值呢？这样经过测试可以节省大约30%的时间。代码如下：
```cpp
#include<iostream>
using namespace std;
int n,s,a,b,ans;
int xi[5005],yi[5005];
int dfs(int num,int rest){
    if(num>n) return 0;
    int maxn=dfs(num+1,rest);
    if(xi[num]<=a+b&&rest>=yi[num]){
        int t=dfs(num+1,rest-yi[num])+1;
        maxn=t>maxn?t:maxn;
    }
    return maxn;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>xi[i]>>yi[i];
    }
    cout<<dfs(1,s);
    return 0;
} 
```
但是这还远远不够，那么剩下的时间是从哪里优化出来的呢？这里就要用到记忆化搜索了。

我们回想一下刚才的改动，就是用两个变量存储了函数的返回值从而避免了函数因为两次调用而做无用功。那么我们自然而然地想到，假如某个函数可能以相同的参量被调用多次的话，那么多调用的这几次不就也是浪费了吗？那么有没有这样的情况呢？有的。大家如果在每个DFS函数的最后加一句：
```cpp
cout<<"num:"<<num<<" rest:"<<rest<<endl;
```
就会发现在输出的每次调用的函数中，有很多次调用的num和rest是相同的，这就说明我们做了很多无用功。那么怎么优化呢？这时候记忆化搜索就闪亮登场了：

所谓记忆化搜索，就是将每个不同参量的函数的返回值存在一个数组里，当再次调用这个函数的时候，就不用再次费时间计算这个函数的返回值了。这里我们还是结合代码讲一下：
```cpp
#include<iostream>
using namespace std;
int n,s,a,b,ans;
int xi[5005],yi[5005];
bool visit[5005][1001];//存储是否访问过调用这两个参量的函数
int mem[5005][1001];//存储调用这两个参量的函数的返回值
int dfs(int num,int rest){
    if(num>n) return 0;
    if(visit[num][rest]) return mem[num][rest];//如果调用这两个参量的函数已经被访问过，那么直接返回之前存储的值即可
    visit[num][rest]=true;
    int maxn=dfs(num+1,rest);
    if(xi[num]<=a+b&&rest>=yi[num]){
        int  t=dfs(num+1,rest-yi[num])+1;
        maxn=t>maxn?t:maxn;
    }
    return mem[num][rest]=maxn;//返回值的同时存储这次运算的返回值
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>xi[i]>>yi[i];
    }
    cout<<dfs(1,s);
    return 0;
} 

```
这样的话就减少了很多次不必要的访问和计算，大大加快了运行速度。

接下来讲剪枝。我们不难发现，对于那些不能够采到的苹果，我们搜索它们只会白白浪费时间，那我们就可以将这些苹果排除掉，这样就使得搜索子树被缩小了。这就是剪枝。

我们怎么才能避免搜索到这些苹果被搜索到呢？我们可以将所有的苹果按照高度从矮到高排序（排序的知识在第一弹里讲过，不会的同学可以去看一下）。在这种情况下当我们搜索到一个够不到的苹果时，无论我们再往下搜索多久，我们都不会再搜索到可以够得到的苹果了。这时候我们就可以 $return \ 0$ 了。代码如下：
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,s,a,b,ans;
bool visit[5005][1001];
int mem[5005][1001];
struct apple{
    int xi,yi;
}ap[5005];
int dfs(int num,int rest){
    if(num>n||ap[num].xi>a+b) return 0;//当搜索到够不到的苹果后，就不再继续向下搜索了
    if(visit[num][rest]) return mem[num][rest];
    visit[num][rest]=true;
    int maxn=dfs(num+1,rest);
    if(ap[num].xi<=a+b&&rest>=ap[num].yi){
        int  t=dfs(num+1,rest-ap[num].yi)+1;
        maxn=t>maxn?t:maxn;
    }
    return mem[num][rest]=maxn;
}
int cmp(apple x,apple y){
    return x.xi<y.xi;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>ap[i].xi>>ap[i].yi;
    }
    sort(ap+1,ap+n+1,cmp);//按照高度从矮到高排序
    cout<<dfs(1,s);
    return 0;
} 
```
这种方法比起剪枝前，又快了大约15%。


------------
## 2.动态规划——背包
我们做题不能只靠搜索，世界上解决这类问题也不是只有搜索这一种算法，要不然还要OI干吗？

于是，有一些特殊的搜索问题就被优化了，并且形成了一类新的算法：动态规划。动态规划的种类很多：有线性动态规划、多维动态规划、区间动态规划等。我们这里先只讲一类特殊的多维动态规划：背包问题。

动态规划最核心的思想就是状态转移。即任何状态的解都可以建立在已知状态的基础上快速求出。这是不是和记忆化搜索有些类似呢？事实上动态规划和记忆化搜索真的差不多，记忆化搜索需要一个数组来存储不同参量的递归函数的返回值，动态规划需要一个状态转移数组来存储已求解的状态的解。而动态规划相比搜索的高明之处就在于，动态规划可以将搜索有向化，而不是漫无目的地遍历搜索每一个可能的状态，相当于自动剪枝。

我们前面讲过，动态规划实质上是对搜索的优化，之前我们搜索，是从前向后递归搜索，根据之后状态返回的值来决定向前返回什么值。而动态规划用的方法恰恰相反，是从前向后递推搜索，根据之前状态传递来的值决定向后传递什么值。这就是动态规划省时的主要原因。

那么接下来我们来讲背包问题。背包问题解决的一类问题是：对于空间有限的背包，和一些有着已知体积与价值的物品，优化取物品策略使得背包里物品的价值总和最大。对于这个题，总力气就是背包的空间，摘每个苹果所需要的力气就是苹果占背包的空间，每个苹果的价值都是1，我们只需让背包里的苹果价值和最大即可。

上面讲到，动态规划的核心是状态的转移，与此相对应的，每类动态规划问题也都有它的状态转移方程，比如背包问题，它的状态转移方程就是：$dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])$。这之中，$dp[i][j]$表示对于空间大小为j的背包考虑前i个物品所能得到的最大总价值，$v[i]$表示第i个物品的占空间大小，$w[i]$表示第i个物品的价值。

不过讲了这么多，大家估计也听烦了，我们先上代码，然后再根据代码讲一下背包问题的解法。代码如下：
```cpp
#include<iostream> 
using namespace std;
int dp[5005][1001];
int xi[5005],yi[5005],n,s,a,b;
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>xi[i]>>yi[i];
    }
    for(int i=1;i<=n;i++)//枚举考虑每一个苹果
    for(int j=0;j<=s;j++){//枚举背包大小
        dp[i][j]=dp[i-1][j];//不能取就直接转移考虑之前苹果的最大值
        if(xi[i]<=a+b&&j>=yi[i])//如果能够取
        dp[i][j]=dp[i-1][j-yi[i]]+1>dp[i][j]?dp[i-1][j-yi[i]]+1:dp[i][j];//这个就是动态转移方程。max函数运行太慢，我们这里选择三目运算符取较大值
    }
    cout<<dp[n][s];//因为是从前向后递推，因此接收最终答案的位置也从最前面转到了最后面
    return 0;
}
```
为什么背包问题的状态转移方程是$dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])$呢？我们还是回到之前讲过的知识点：动态规划实质上是对搜索的优化。回想一下我们当时是怎么搜索的？对于搜索到的每个苹果，都有两种选择：取或者不取。不取则对应返回不取这个苹果后剩下的苹果最多能取的个数，取则对应返回取这个苹果后剩下的苹果最多能够取的个数加1。那么我们该如何将这个转化为递推关系呢？

首先我们考虑，当我们取了一个苹果，就相当于把背包里容纳这个苹果的空间分给了这个苹果，剩下的空间再由这个苹果之前（为什么是之前等一下会讲到）的苹果来分。那么不就相当于把背包缩小后再考虑前面的苹果了吗？那么不取就是背包大小不变，由之前的苹果来分这个背包的空间。基于这样的思想，我们就可以比较在当前背包大小下，是取这个苹果更值还是不取这个苹果更值。而缩小背包考虑之前的苹果的工作，在考虑上一个苹果时就已经求解过了。这样就可以不断地考虑一个又一个的苹果，不断地递推下去，最终得到最终的结果。

那么实现思路就是这样的：首先用一个循环枚举每个苹果，然后在考虑每个苹果时，再用一个循环枚举背包大小（为什么要枚举背包大小？——比较最大值时不是要缩小背包吗？这里就是为下一步递推比较做准备），对于每个大小的背包，如果能够取这个苹果（够得着**而且**当前背包大小装得下这个苹果），就比较取这个苹果和不取这个苹果哪个更值；如果不能取（够不到**或者**当前背包大小装不下这个苹果），就将这个大小的背包装之前的苹果的最大值传递给这个dp值。这样就得到了上面的代码。现在再回去看看之前的代码，是不是就明白了呢？


------------

## 3.贪心算法
有的同学可能会注意到，我们给的状态转移方程里有一个变量$w[i]$，但是在这个题里我们没有用$w[i]$，而是直接用1表示，让人对照起来看难免有些别扭。如果你觉得别扭的话，那我要夸奖你，因为一眼就看出了这个问题其实动态规划并不是最优解。

我们最开始用无优化搜索跑了3500多毫秒才跑完，之后记忆化搜索直接提升到130多毫秒，然后剪枝又优化到110多毫秒，之后动态规划直接60多毫秒解决问题。那你以为这就是这个题的极限通过时间了吗？接下来介绍的贪心算法15毫秒就通过了这个题。

贪心算法其实比动态规划算法要低级不少，因为它适用面实在是有点窄。但是对于某些问题，贪心法却能跑出比动态规划快不少的成绩。

那么为什么这个题可以用贪心算法解决呢？我们看一下，在这个题里，所有苹果费力气也就是占背包空间不同，但是价值都是1。背包问题主要是为了解决拿得多却不一定价值最大，拿价值大的却可能装不下其他有价值的东西而使人陷入两难才被发明的算法。对于价值相同体积却不同的物品，我们每次只取体积最小的，不就能在取得当前价值的情况下，最大化剩余空间，从而拿更多苹果了吗？

讲到这里，大家可能就有点明白贪心算法的适用范围了。我之所以先引例，就是因为下面这段话实在有点晦涩难懂：

百度百科定义：贪心算法是指，在对问题求解时，**总是做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，他所做出的是**在某种意义上的局部最优解**。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，**选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。**

我语言功底有限，就不再用我贫瘠的语言来给大家详细解释这段话了。总之，这个题，用贪心确实是最优解。这点从时间复杂度上就能看出来：

搜索的基础复杂度（不加优化）是$O(k^n)$（k指每个节点的选择分支的个数）的，动态规划的基础复杂度是$O(nm)$（n,m分别指的是物品数量和背包大小），而贪心却只有$O(n)$。搜索适用范围最广，同样地时间复杂度也最高；动态规划适用范围有所缩小，但是时间复杂度也相应地提高了；贪心算法适用范围极窄，但却拥有极优的时间复杂度。万事万物都是这样，既有长处，又有短处，长短互补，向来如此。

咳咳……扯远了。下面放上贪心算法的代码。这里就不加注释了，大家借此机会锻炼一下自己的读代码能力吧。
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,s,a,b,x_,y_,can,rest,ans;
struct apple{
    int xi,yi;
}ap[50005];
int cmp(apple x,apple y){
    return x.yi<y.yi;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>x_>>y_;
        if(x_<=a+b){
            can++;
            ap[can].xi=x_;
            ap[can].yi=y_;
        }
    }
    sort(ap+1,ap+can+1,cmp);
    rest=s;
    ans=0;
    for(int i=1;rest>=ap[i].yi&&i<=can;i++){
        ans++;
        rest-=ap[i].yi;
    }
    cout<<ans;
    return 0;
} 
```


------------
总之，贪心算法就是这个题的最优解了。当然了，如果这个题再加条件，比如每个苹果都有其不同的价值，那么贪心算法就不再适用了，就需要使用背包了。当然如果再加条件说不定连动态规划都不能用了……不过大家还是要相信，题设计出来就是给人做的，无论什么样的题目，只要我们掌握的方法够多，总有一种方法适合你。好的，本期的~~_**滑稽题解**_~~到这里就结束了。让我们下期再见吧！

---

## 作者：灯芯糕 (赞：392)

  ### 本萌新第一次发布题解，若有不严谨处请谅解。 
  
  我看了前面几位大佬的手笔，表示自己还是比较钟爱桶排序的。它非常简易直接，还省时间，尤其对于这类题目占用的的空间也很小。
  
  我们看到题目下面的说明：xi<=280  yi<=100 这简直就是为桶排序量身定制啊！
  
  因为淘淘要摘到最多的苹果，我们便可以对每个苹果所需的力气进行桶排序。下面进入正文：
  ## 陶陶摘苹果（升级版）题解
```cpp
#include<iostream>
using namespace std;
int c[101];//定义一百个桶子，c[i]代表用i个力气能摘到的苹果的数目
int main(){
    int n,s,h,a,b,i,t=0; 
    cin>>n>>s>>h>>i;h+=i;//输入，借用"i"将淘淘用凳子达到的最大高度复制给"h"
    for(i=1;i<=n;i++){
        cin>>a>>b;
        if(a<=h)c[b]++;//如果能摘到，就在用b个力气能摘到苹果的桶子中加一
    }
    //接下来 按力气从小到大选苹果
    for(i=0;i<=100&&s>=0;i++){//注意要从"0"开始，有苹果是免费的
        while(c[i]){//一个桶子里也可有多个苹果
            s-=i;//减去摘这个苹果的力气
            t++;//摘到的苹果数加一 
            c[i]--;//桶里的苹果减一个 
            if(s<0){//当力气没了时结束 
                t--;//这个苹果没有足够力气摘不了(s<0) 
                break;
            }
        }
    }
    cout<<t;//输出。 
    return 0;
}
```
  怎么样，是不是非常简短，时间空间都用的很少，那么点个赞吧！

---

## 作者：LW_h_FP (赞：111)

这题最开始是模拟陶陶摘苹果，每个苹果选或不选，因此得出以下代码：
```cpp
#include<iostream>
using namespace std;

int n,s,a,b,ans=0;
int xi[5010],yi[5010]; 

void f(int cnt,int l,int la){
    for(int i=la;i<n;i++){
        if(xi[i]>a||yi[i]>l)	continue;
        f(cnt+1,l-yi[i],i+1);
    }
    if(ans<cnt) ans=cnt;
}

int main(){
    cin>>n>>s>>a>>b;
    a+=b;
    for(int i=0;i<n;i++)
        cin>>xi[i]>>yi[i];
    f(0,s,0);
    cout<<ans;
    return 0;
}
```
很明显这样是超时的。
因为在很多苹果都重复选到了，而题目没有求总的方案，因此做了多余的，只需要找出需要力气最小的，我用的冒泡排序：
```
for(int i=1;i<n;i++)
	for(int j=i+1;j<=n;j++){
		if(yi[i]>yi[j]){
			t1=xi[i],t2=yi[i];
			xi[i]=xi[j],yi[i]=yi[j]; //相当于swap(x[i],x[j]); swap(y[i],y[j]);
			xi[j]=t1,yi[j]=t2;
		}
```
这样就把力气小的排在前面了，下面是完整的代码：
```
#include<iostream>
using namespace std;

int n,s,a,b,ans=0,t1,t2;
int xi[5010],yi[5010];

int main(){
	cin>>n>>s>>a>>b;
	a+=b;
	for(int i=1;i<=n;i++)
		cin>>xi[i]>>yi[i];
	for(int i=1;i<n;i++)//冒泡把力气少的排到前面
		for(int j=i+1;j<=n;j++){
			if(yi[i]>yi[j]){
				t1=xi[i],t2=yi[i];
				xi[i]=xi[j],yi[i]=yi[j];
				xi[j]=t1,yi[j]=t2;
			}
		}
	for(int i=1;i<=n;i++){
		if(xi[i]<=a&&yi[i]<=s){//判断超出高度或不够力气
			ans++;
			s-=yi[i];
		}
	}
	cout<<ans;
	return 0;
}
```
就这样了，感谢支持！！

---

## 作者：孤独的观测者 (赞：44)


面向对象大法好

核心思路：实现比较接口就行了


```cpp
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;
```
public class Main
        
        
        
        
        
```cpp
{
    public static void main(String[] args) throws IOException
    {
        int power=0,count=0;
        BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in));
        String[] strings=bufferedReader.readLine().split(" ");
        Tree.number=Integer.parseInt(strings[0]);
        TaoTao.power=Integer.parseInt(strings[1]);
        strings=bufferedReader.readLine().split(" ");
        TaoTao.handle=Integer.parseInt(strings[0])+Integer.parseInt(strings[1]);
        for (int i = 0; i < Tree.number; i++)
        {
            strings=bufferedReader.readLine().split(" ");
            Tree.treeSet.add(new Apple(Integer.parseInt(strings[0]), Integer.parseInt(strings[1])));
        }
//        System.out.println(Tree.number+" "+TaoTao.power+" "+TaoTao.handle);
        TreeSet<Apple> treeSet=Tree.treeSet;
        for (Iterator iterator = treeSet.iterator(); iterator.hasNext();)
        {
            Apple apple = (Apple) iterator.next();
            if(apple.appleHigh<=TaoTao.handle&&apple.needpower+power<=TaoTao.power)
            {
                count++;
                power+=apple.needpower;
                //System.out.println(apple);
            }
        }
        System.out.println(count);
    }
}
```
class TaoTao
    
```cpp
{
    static int power;
    static int handle;
}
class Apple implements Comparable<Apple>
{
    int appleHigh;
    int needpower;
    public Apple(int appleHigh, int needpower)
    {
        super();
        this.appleHigh = appleHigh;
        this.needpower = needpower;
    }
```
@Override
```cpp
    public int compareTo(Apple o)
    {
        // TODO Auto-generated method stub
        if(needpower==o.needpower)
        {
            if(appleHigh==o.appleHigh)
            {
                return -1;
            }
            return appleHigh-o.appleHigh;
        }
        return needpower-o.needpower;
    }
```
@Override
    
    
```cpp
    public String toString()
    {
        return "Apple [appleHigh=" + appleHigh + ", needpower=" + needpower + "]";
    }
}
```
class Tree
{
    static int number;

    static TreeSet<Apple>treeSet=new TreeSet<>();

}

---

## 作者：天才byt (赞：25)

##### 这是本萌新第一次写题解，不好之处多多谅解= =

### 这道题是一道非常经典的模拟题，本题解将使用*struct*来做。思路也非常简单，类似于贪心，因为有力气s的限制，*所以只要考虑每一次尽可能的使耗费的力气尽量的小。*也就是说我们需要用到排序的思想。

#### 上头文件等等

```cpp
#include <bits/stdc++.h>//van ♂ 能库
using namespace std;

int n, s, a, b, ans;//前四个如题，ans是答案。

int main() {
	scanf("%d %d", &n, &s);//读入不多说
	scanf("%d %d", &a, &b);//同上
	struct k{//行1
		int sa;//行2
		int sh;//行3
	}x[n + 1];//行4
    /*
    这就是本题的重点了。
    结构体有点类似与其他语言的记录，就是你自己定义的一种数据类型。当中可以包含你申明的任意库数据类型。例如本题的结构体k中就含有sa（每一个苹果所耗力气），sh（每一个苹果的高度）。行4中的x[n+1]代表结构k类型的数组x，其大小为[n+1]。
    为什么大小含有变量呢，给各位说一下这里，这里是一个非常实用的小技巧——在int main（）里面开数组，大小可以由之前已经读入的变量（n）组成。
    n+1是为了数组不越界。
    */
```
#### 以上就是一些所谓的“预处理”。
#### 下面一段是如何读入struct 上代码~~
```cpp
for (int i = 1; i <= n; ++i) {//行1
	scanf("%d %d", &x[i].sh, &x[i].sa);//行2
}//行3
/*
行1不解释
行2的&x[i].sh, &x[i].sa中的两个“.”是成员运算符，表示结构体中的某个数，比如这里的“.”的意思是结构体k类型的数组x中下标为i的那一项中的int sh
*/
```

#### 下面是重中之重——结构体排序（冒泡排序

######  （和真正的结构体排序不是一回事。。）
```cpp
for (int i = n - 1; i >= 1; --i) {//line 1
	for (int j = 1; j <= i; ++j) {//line 2
		if (x[j].sa > x[j + 1].sa) {//line 3
			swap(x[j].sa, x[j + 1].sa);//line 4
			swap(x[j].sh, x[j + 1].sh);//line 5
		}//line qwq
	}//line CyC
}//line 233
/*
冒泡排序的原理十分简单——只要有两个数不是前一个比后一个小，叫让这两个数是（交换两个数），这样重复几次就会发现排好序了。
那么问题来了，重复几次呢？？
请看网址1
*/
```
[网址1](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
#### 排序完了之后，我们的结构体们已经成了按照话费力气大小排序的结构体们，所以我们只需要判断是否能摘到就行了。
```cpp
for (int i = 1; i <= n; ++i) {//line 1
		if (x[i].sh <= b + a) {//line 2
			s -= x[i].sa;//line 3
			if (s < 0) {//line 4
				break;//line 5
			} else {//line 6
				ans++;//line 7
			}
		}
	}
	printf("%d", ans);
	return 0;
}
/*
值得一提的使line 5的break是退出的整个for循环，详情请见下面的网址2
只要陶陶能够摘到苹果，那么就减去力气++答案，很好理解对吧。
*/
```
[网址2](https://wenwen.sogou.com/z/q794582159.htm)
# 你们最爱的完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, s, a, b, ans, sum;
bool contr;

int main() {
	scanf("%d %d", &n, &s);
	scanf("%d %d", &a, &b);
	struct k{
		int sa;
		int sh;
	}x[n + 1];
	for (int i = 1; i <= n; ++i) {
		scanf("%d %d", &x[i].sh, &x[i].sa);
	}
	for (int i = n - 1; i >= 1; --i) {
		for (int j = 1; j <= i; ++j) {
			if (x[j].sa > x[j + 1].sa) {
				swap(x[j].sa, x[j + 1].sa);
				swap(x[j].sh, x[j + 1].sh);
			}
		}
	}
	for (int i = 1; i <= n; ++i) {
		if (x[i].sh <= b + a) {
			s -= x[i].sa;
			if (s < 0) {
				break;
			} else {
				ans++;
			}
		}
	}
	printf("%d", ans);
	return 0;
}
```
# thanks！

---

## 作者：BlueArc (赞：24)

```cpp
#include"iostream"
#include"cstdio"
#include"algorithm"
using namespace std;
int force[5010],high[5010];//最好比5000大一些
int main()
{
 int i,n,s,tot=0,a,b,t,p,j;//t,p后面用来变量交换
 cin>>n>>s>>a>>b;
 int sum=a+b;//总共能够到的高度应为凳子高度+手能够到的高度
 for(i=0;i<n;i++)   
 cin>>high[i]>>force[i];
 for (i=0;i<n-1;i++)//冒泡排序过程，虽然用结构体方便些，但本人还不熟悉用......    
 for (j=0;j<n-i-1;j++)
 if (force[j] > force[j+1] )  
 {
 t=force[j];force[j]=force[j+1];force[j+1]=t;
 p=high[j];high[j]=high[j+1];high[j+1]=p;//每个force[i]对应的高度也应跟着交换
 }
 for(i=0;i<n;i++)  
 {
  if(s>=0&&sum>=high[i]&&s>=force[i]) {tot++;s-=force[i];}//判断条件，满足tot+1,力气-force[i]                 
 }
 cout<<tot<<endl;
 return 0; 
}

```

---

## 作者：Drunk_ (赞：23)

萌新第一次发题解。思路挺直接的，一开始先把摘不到的苹果筛掉，然后直接把可以摘到的苹果所需的力气从小到大排序，累加计数就行。
```
#include<iostream>
#include<cstdio>
using namespace std;
int n,s,a,b,xi[5001],yi[5001],t=0,g[5001],q=0;
int main()
{
	cin>>n>>s>>a>>b;
	for(int i=1;i<=n;i++)
	cin>>xi[i]>>yi[i];
	a+=b;
	for(int i=1;i<=n;i++)
	{
		if(a>=xi[i])
		g[i]=yi[i];		//将摘得到的苹果所需力气存下
	}
	
```
然后这里就会出现摘不到的苹果力气直接对应成零了...但是标记一下就ok了
```

	for(int i=1;i<=n;i++)
	{
		if(g[i]==0&&a<xi[i])
		g[i]=1001;    //因为力气本来就可以为零所以标记其他数
	}
	
```

然后是个冒泡排序力气的大小
```

	for(int i=1;i<=n;i++)
	{
		for (int j=i+1;j<=n;j++)
		{
			if (g[i]>g[j])
			swap(g[i],g[j]);
		}
	}  
	
```

最后就是累加计数啦
```

	for(int i=1;i<=n;i++)
	{
		if(g[i]!=1001)
		{
			q+=g[i];
		    t++;
		}
		if(q>s)
		{
			t--;
		    break;
		}
	}

```

最后是个完整代码
```cpp

#include<iostream>
#include<cstdio>
#include<stdio.h>
using namespace std;
int n,s,a,b,xi[5001],yi[5001],t=0,g[5001],q=0;
int main()
{
	//freopen("in.txt","r",stdin); 
	//freopen("out.txt","w",stdout); 
	cin>>n>>s>>a>>b;
	for(int i=1;i<=n;i++)
	cin>>xi[i]>>yi[i];
	a+=b;
	for(int i=1;i<=n;i++)
	{
		if(a>=xi[i])
		g[i]=yi[i];		
	}
	for(int i=1;i<=n;i++)
	{
		if(g[i]==0&&a<xi[i])
		g[i]=1001; 
	}
	for(int i=1;i<=n;i++)
	{
		for (int j=i+1;j<=n;j++)
		{
			if (g[i]>g[j])
			swap(g[i],g[j]);
		}
	}  
	for(int i=1;i<=n;i++)
	{
		if(g[i]!=1001)
		{
			q+=g[i];
		    t++;
		}
		if(q>s)
		{
			t--;
		    break;
		}
	}
    cout<<t<<endl;
    return 0;
}
```

---

## 作者：shenyi1343395317 (赞：15)

有贪心的思想存在，就少不了DP。看看题解里没有DP，就尝试发个DP的题解吧.

状态转移方程有点难想到：   **max{f[j-a[i]]+1>f[j]}**

一维的不仅代码短，而且能减少冗余        ~~p.s.二维DP最后一个点过不了~~

解释：比较摘了以后的苹果个数和没摘的苹果个数

下面是代码

```cpp
program sss;
  var t,m,i,j,k,c:longint;
      a,b,f:array[0..5002] of longint;
  begin
  read(m,t);
  read(c,k);
  k:=c+k;                                        //最高高度
  for i:=1 to m do read(b[i],a[i]);      //b[i]:苹果高度，a[i]所花力气
  for i:=1 to m do
   for j:=t downto a[i] do          
   if b[i]<=k then                            //太高了就不用了
    if f[j-a[i]]+1>f[j] then inc(f[j]);       //如果方案更优，就修改
  writeln(f[t]);
end.
```

---

## 作者：livealone (赞：13)

# 这个题很简单
## 一个简单的排序再简单的判断就出来了
### ~~我10分钟就AC了~~
#### 下面是代码

##### #include<bits/stdc++.h>//万能头文件
```cpp
using namespace std;

int main()
{

    int ans=0,tot,j,g,n,s,a,b,x[10001],y[10001],x1[10001],y1[10001];
    memset(x,0,sizeof(x));		//初始化
    memset(y,0,sizeof(y));		//还是初始化
    memset(x1,0,sizeof(x1));	  //依旧是初始化
    memset(y1,0,sizeof(y1));	  //全部初始化
    
    cin>>n>>s;					//输入苹果数和力气
    cin>>a>>b;					//输入椅子的高度和陶陶手伸直的最大长度
    g=a+b;						//这里是陶陶最高能摘到的苹果的高度
    
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];		  //输入 苹果高度和摘这个苹果需要的力气
        x1[i]=x[i];
        y1[i]=y[i];
    }
    
```
###### 下面是判断（分割线）
```
for(int i=1;i<n;i++)			  //这里是把所有数据按从小到大排序
    for(j=i+1;j<=n;j++)
    {
        if(y1[i]>y1[j])			//排序
        {
            swap(x1[i],x1[j]);
            swap(y1[i],y1[j]);
        }
    }
    
    for(int i=1;i<=n;i++)
    {
        if(s>=y1[i])			  //先判断体力是否够（实际上还可以先判断是否能够到）
        {
            if(g>=x1[i])		  //判断是否能够到
            {
                ans++;			//临时值+1
                s-=y1[i];
            }
        }
    }
    
    cout<<ans<<endl;			  //输出
    return 0;
}
```

---

## 作者：轩槿 (赞：11)

```cpp
#include<iostream>
#include<map>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
 using namespace std;
struct apple{//开个结构体就好哩
    int x;
    int y;
}gi[50005];
bool cmp(struct apple a,struct apple b)
{
    return a.y<b.y;
}
int main(){
    freopen("ii.in","r",stdin);
    freopen("ii.out","w",stdout);
    int n,s,a,b,ans=0;
    cin>>n>>s>>a>>b;
    for(int i=0;i<n;i++)cin>>gi[i].x>>gi[i].y;
    sort(gi,n+gi,cmp);
    for(int i=0;i<n;i++)
    {
        if(s-gi[i].y<0)break;
        if(gi[i].x>a+b)continue;
        else {s-=gi[i].y;ans++;}
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：fanmeng (赞：6)

这道题首先想到的是建二维数组将苹果高度和所花费力气存进去，再按力气排序，从小到大选择性摘苹果，虽然这的确很简单，但最近学了动态规划，就拿动态规划来做这题练习一下。
不多说直接上代码：
```java
import java.util.Scanner;

public class Main {
static int n,s,a,b;//各参数参见题目
	public static void main(String args[]){
	Scanner sc=new Scanner(System.in);
	n=sc.nextInt();s=sc.nextInt();
	a=sc.nextInt();b=sc.nextInt();
	int h[]=new int[n];//苹果距地面的高度
	int st[]=new int[n];//每个苹果所需力气
	int m[][]=new int[5001][1001];//所有数据：n<=5000 a<=50 b<=200 s<=1000
	//m[i][j]表示面对第i个苹果（高度能摘到的情况下）且力气为j时能摘到的最大苹果数
	for(int i=0;i<n;i++){
		h[i]=sc.nextInt();
		st[i]=sc.nextInt();
	}
		for(int j=1;j<=n;j++){//摘第i个苹果				
			for(int k=1;k<=s;k++){//力气
				if(k>=st[j-1]&&a+b>=h[j-1]){//当j等于1时，表示摘第一个苹果这里j-1是因为st[]数组是从下标为0开始存的
							//也就是说st[0]代表摘第一个苹果花的力气
							//h[]数组同理哦
					m[j][k]=Math.max(m[j-1][k], m[j-1][k-st[j-1]]+1);
					//不摘第j个苹果与摘第j个苹果，+1对应01背包问题的****+v[j];
					}
					else{ 
						m[j][k]=m[j-1][k];
				}				
			}
		}
		System.out.println(m[n][s]);
//	for(int i=1;i<=n;i++){
//		for(int j=1;j<=s;j++){
//			System.out.print(m[i][j]+" ");
//		}
//		System.out.print("\n");
//	}
	}
}
```

---

## 作者：Substitute0329 (赞：5)

## ~~来水一发题解~~
###  其实此题很简单，毕竟是新手村的题目。    
#### 思路如下：     
-  把每个苹果所需的体力从小到大排序，因为在摘苹果的过程中，体力值会改变，但小红的高度不变（会不会摘苹果摘着摘着就长高了？~~**手动滑稽**~~）
-  排完序后，开始进行贪心策略，小红身高摘的到苹果就摘，答案+1并减少小红的体力值，不然就不摘！因为我们在之前已经对摘每个苹果所需的体力排过序了，对苹果所需体力值进行了贪心策略（即先考虑所需体力值小的，在考虑大的）。
-  输出   
    
**水水**的代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,phigh,pliqi,chigh,res=0; //phigh 小红的手长度；pliqi 小红的原体力值；chigh 椅子高度；res答案
struct node{
	int high,need;             //high 每个苹果的高度；need 每个苹果所需的体力值。
}a[5010];                      //用结构体来储存每个苹果的高度，所需体力值
inline int read(){             //读入优化，输入速度更快（蒟蒻慎用）
	int x=0;                   
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();   //如果读入的字符非数字，继续读入
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();//如果读入的是数字，记录，继续读入
	return x;                         //返回读入的数
}                                     //对于读入优化，有些小蒟蒻可能看不懂，没关系，当成，cin或scanf就好了。\( ^_^ )|
inline void out(int x){               //输出优化
	if(x>10)out(x/10);
	putchar(x%10+48);
	return ;
}
inline void print(){                  //输出答案
	out(res);putchar('\n');
	return ;
}
inline bool cmp(node x,node y){return x.need<y.need;}
int main(){
	n=read();pliqi=read();chigh=read();phigh=read();   //输入
	for(register int i=1;i<=n;i++)a[i].high=read(),a[i].need=read();//输入
	sort(a+1,a+n+1,cmp);                 //思路中的第一步，对每个苹果所需要的体力值排序ing
	int s=chigh+phigh;
	for(register int i=1;i<=n;i++){
		if(pliqi<a[i].need)break;        //如果小红的力气，不足以摘到当前搜索到的苹果所需的体力值，直接退出循环。
                                         //因为之后的苹果所需体力值更大，若当前苹果不够力气摘，之后的更加不用说。
                                         //因此，这一步是对于整个程序的压缩。
		if(s<a[i].high)continue;         //如果小红的身高不够高，摘不到当前苹果，就换一个苹果（思路中的第二步）
		pliqi-=a[i].need;                //如果摘的到，减少小红的体力值，答案+1（思路中的第二步）
		res++;
	}
	print();                             //输出
	return 0;
}
```     
# ~~如果此题解过了，这就是我过的第一篇题解，**求过**！！~~

---

## 作者：lemir3 (赞：5)

~~又来写水题题解~~

首先读到这个题面，发现只是比原题多了一个力气值，从原题可知，高度高于陶陶手长+凳子长的苹果不能摘，其他的全部摘掉即可。但是这道题里面每个苹果要消耗力气，陶陶的力气又是有限的，那么自然就不能全部摘掉，于是我们就可以取力气小苹果的摘。

好啦这就是思路。

但是如何实现呢？为了~~毒害~~关怀新人，我来讲一讲一种排序的方法：sort排序。

sort是STL（标准模板库）里的一个函数，作用是对数组进行从小到大排序，使用方法如下:

**sort(a+1,a+1+n);**

其中a为数组名，1为排序的起点，1+n（数据个数）是排序的终点（当然如果你习惯以0开始存的话也可以写sort(a,a+n)）;

sort还支持自定义排序方式，需要自己打一个函数，例如从大到小排序就需要这样的函数：

```cpp
bool cmp(int d1,int d2)
{
	return d1>d2;//   >的意思就是排序后前面的数比后面大，即为从大到小
}
```

然后这样放入sort中:

**sort(a+1,a+1+n,cmp);**

利用这种方法，sort还能对结构体进行排序（注意：必需要加函数）

举个栗子，我要将结构体数组a按照x的大小来从小到大排序

```cpp
struct s
{
	int x,y;
}a[10];
```
仿照上面的方法，函数如下：

```cpp
bool cmp(sb d1,sb d2)
{
 	return d1.x<d2.x;
}
```

其实sort还可以自定义更灵活的排序方法，不仅仅是改变方向。

例如一群学生按成绩排序，语文成绩高的排前面，语文相同时数学成绩高得排前面:

```cpp
struct stu
{
	int y;
	int s;
};
bool cmp(stu d1,stu d2)
{
	if(d1.y!=d2.y)return d1.y>d2.y;
	else return d1.s>d2.s;
}
```

最后才是大家都喜欢的的代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[5010];
int n,s,a,b,cnt,ans;
int main()
{
	scanf("%d%d",&n,&s);
	scanf("%d%d",&a,&b);
	for(int i=1;i<=n;i++)//在读入的时候就把不可能摘到的苹果给去掉
	{
		int u,m;
		scanf("%d%d",&u,&m);
		if(u>a+b)continue;
		cnt++;
		p[cnt]=m;
	}
	sort(p+1,p+1+cnt);
	for(int i=1;i<=cnt;i++)//按力气从小到大排序后优先选择消耗力气小的苹果
	{
		s=s-p[i];
		if(s>=0)ans++;
		else break;
	} 
	printf("%d",ans);
return 0;
}
```

---

## 作者：big_news (赞：5)

说实话，楼上的dalao们写的代码本蒟蒻是真看不懂

第一眼看到这个题首先想到了01背包

但是一读题发现没有那么复杂，用贪心的办法就可以解出来

本人的思路是这样的

读入数据后，先把所需要的力气s从小到大排序，然后再把s对应的苹果h按s的顺序重排

本人用了两个for来实现，如下

```cpp
for(int i=1;i<=nall;i++) 
{
        int minn=s[i],p=i,q;
        for(int j=i+1;j<=nall;j++)
          if(minn>s[j]) {p=j;minn=s[j];}
        q=s[i];
        s[i]=s[p];
        s[p]=q;
        q=h[i];
        h[i]=h[p];
        h[p]=q;
 }
```
这样一来，输出只需要把s从小到大循环，判断对应的h能否被淘淘摘到，是一个十分简单的过程
代码实现如下

int ans=0，nall，maxt，sall;//sall是淘淘力量的总和，maxt是淘淘的高度（加上椅子了），nall是苹果总数

for(int i=1;i<=nall;i++)

      if(maxt>=h[i]&&sall>=s[i]) {ans++;sall-=s[i];}

最后，输出便可。

看起来好像有点乱，发一下完整源码

```cpp
#include<iostream>
using namespace std;
int h[5001],s[5001],nall,sall,maxt,maxc,ans=0;
int main()
{
    cin>>nall>>sall>>maxc>>maxt;
    maxt+=maxc;
    for(int i=1;i<=nall;i++)
      cin>>h[i]>>s[i];
    for(int i=1;i<=nall;i++)
    {
        int minn=s[i],p=i,q;
        for(int j=i+1;j<=nall;j++)
          if(minn>s[j]) {p=j;minn=s[j];}
        q=s[i];
        s[i]=s[p];
        s[p]=q;
        q=h[i];
        h[i]=h[p];
        h[p]=q;
    }
    for(int i=1;i<=nall;i++)
      if(maxt>=h[i]&&sall>=s[i]) {ans++;sall-=s[i];}
    cout<<ans;
    return 0;
}
望诸位dalao指教
```

---

## 作者：Aatroy (赞：4)

由于这次多了个力气  所以我们不妨先把力气的大小从小到大排序 同时将其对应的高度跟随它的力气调换位置。

所以我们就有了以下的代码：

（此处用了字符数组因为我们作业有函数练习，所以就用函数练习了一下转化。）
------------
```c
int i,j,n,s,a,b,k,e[5001],sum=0;
	char c[5001][5],f[5001];
	scanf("%d%d",&n,&s);
	scanf("%d%d",&a,&b);
	for(i=0;i<n;i++)
	    scanf("%s %d",c[i],&e[i]);
	for(j=1;j<n;j++)
	    for(i=0;i<n-j;i++)
		    if(e[i]>e[i+1]) 
			{  k=e[i+1];  e[i+1]=e[i];  e[i]=k; strcpy(f,c[i+1]);  strcpy(c[i+1],c[i]);  strcpy(c[i],f); }


```


------------

既然如此 我们有了初步结构；至于为什么定义二维数组的话，是因为~~在下实在是不知道~~如何用一位数组解决这个问题。
由于我们在定位二维数组的时候使用的是字符数组，所以我们应该将字符数组进行转化，变成数字。所以我们定义一个新的函数。


------------

```c
int numb(char a[5])
{
    int i,j,sum=0,n,t;
	n=strlen(a);
	for(i=0;i<n;i++)
	{
	    j=pow(10,n-i-1);
	    t=(a[i]-'0')*j;
	    sum+=t;
	}
	return sum;
}
```


------------

这个函数定义之后，我们可以把字符的数字转化为真正的数字了。
然后我们看判断条件，只需要让我们的当前力气先不小于摘这个苹果的力气（已经排过序，没有出大力的问题了）即可，然后再判断我们上凳子能不能碰到即可，就有了：


------------

```c
for(i=0;i<n;i++)
		if(s>=e[i]&&(a+b>=numb(c[i]))) 
		   {
			   s=s-e[i];
			   sum++;
		}
```


------------
那么我们整体的布局已经可以了，然后就组成了完整的代码：


------------
```c
#include<stdio.h>
#include<string.h>
#include<math.h>
int numb(char a[5])
{
    int i,j,sum=0,n,t;
	n=strlen(a);
	for(i=0;i<n;i++)
	{
	    j=pow(10,n-i-1);
	    t=(a[i]-'0')*j;
	    sum+=t;
	}
	return sum;
}
int main()
{
	int i,j,n,s,a,b,k,e[5001],sum=0;
	char c[5001][5],f[5001];
	scanf("%d%d",&n,&s);
	scanf("%d%d",&a,&b);
	for(i=0;i<n;i++)
	    scanf("%s %d",c[i],&e[i]);
	for(j=1;j<n;j++)
	    for(i=0;i<n-j;i++)
		    if(e[i]>e[i+1]) 
			{  k=e[i+1];  e[i+1]=e[i];  e[i]=k; strcpy(f,c[i+1]);  strcpy(c[i+1],c[i]);  strcpy(c[i],f); }
	for(i=0;i<n;i++)
		if(s>=e[i]&&(a+b>=numb(c[i]))) 
		   {
			   s=s-e[i];
			   sum++;
		}
	printf("%d\n",sum);

}

```


------------
不用字符数组的话其实更快：

直接上代码：


------------
```c
#include<stdio.h>
int main()
{
	int i,j,n,s,a,b,k,e[5001],sum=0;
	int c[5001],f;
	scanf("%d%d",&n,&s);
	scanf("%d%d",&a,&b);
	for(i=0;i<n;i++)
	    scanf("%d%d",&c[i],&e[i]);
	for(j=1;j<n;j++)
	    for(i=0;i<n-j;i++)
		    if(e[i]>e[i+1]) 
			{  k=e[i+1];  e[i+1]=e[i];  e[i]=k; f=c[i+1];  c[i+1]=c[i];  c[i]=f;  }
	for(i=0;i<n;i++)
		if(s>=e[i]&&(a+b>=c[i])) 
		   {
			   s-=e[i];
			   sum++;
		}
	printf("%d\n",sum);

}

```
---
其实在s=0的时候 程序就已经可以停下来的，可以加条件减小运行时间，但是好像没有太大的必要，因为这个没有超时，所以也就不加了。~~大佬们不喜勿喷呀。~~

---

## 作者：tengkaize (赞：4)

### 思路

1. 筛选出陶陶能摘到的苹果
2. 摘尽量多的苹果

### 做法

1. 定义结构体 `Apple`
    ```c++
    struct Apple {
        int height;
        int weight;
    };
    ```

    - `height`: 苹果的高度
    - `weight`: 摘苹果需要的体力

2. 输入
    ```c++
    Apple apples[MaxN];
    int n, s, a, b, h;
    scanf("%d%d%d%d", &n, &s, &a, &b);
    h = a + b;
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &apples[i].height, &apples[i].weight);
    }
    ```

3. 进行筛选
    ```c++
    Apple selected[MaxN];
    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        if (apples[i].height <= a + b) {
            selected[cnt++] = temp;
        }
    }
    ```

4. 贪心
    要摘就摘需要的体力最小的，这样才能摘得多。
    ```c++
    bool cmp(const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    }

    sort(selected, selected + cnt, cmp)
    int ans;
    for (ans = 0; ans < cnt; ++cnt) {
        if (s -= selected[ans].weight < 0) {
            break;
        }
    }
    ```

5. 输出
    ```c++
    printf("%d\n", ans);
    ```

以上是常规做法，接下来我们运用标准库~~魔法~~与 C++11 语法简化~~看不懂化~~我们的代码

~~其实这才是重点~~

1. 输入+筛选
    ```c++
    istream& operator>>(istream& in, Apple& a) {
        in >> a.height >> a.weight;
        return in;
    }

    vector<Apple> apples;
    copy_if(
        istream_iterator<Apple>(cin),
        istream_iterator<Apple>(),
        back_inserter(apples),
        [h](const Apple& a) { return a.height <= h; }
    );
    ```

2. 贪心+输出
    ```c++
    sort(apples.begin(), apples.end(), [](const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    });
    cout << count_if(apples.begin(), apples.end(), [&s](const Apple& a) {
        return (s -= a.weight) >= 0;
    });
    ```

### 知识点
- [`copy_if`](https://zh.cppreference.com/w/cpp/algorithm/copy)
- [`count_if`](https://zh.cppreference.com/w/cpp/algorithm/count)
- [`istream_iterator`](https://zh.cppreference.com/w/cpp/iterator/istream_iterator)
- [`back_inserter`](https://zh.cppreference.com/w/cpp/iterator/back_inserter)
- [`Lambda 表达式`](https://zh.cppreference.com/w/cpp/language/lambda)

### 完整代码
```c++
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>

using namespace std;

struct Apple {
    int height;
    int weight;
};

istream& operator>>(istream& in, Apple& a) {
    in >> a.height >> a.weight;
    return in;
}

int main() {
    int n, s, a, b, h;
    cin >> n >> s >> a >> b;
    h = a + b;
    vector<Apple> apples;
    copy_if(
        istream_iterator<Apple>(cin),
        istream_iterator<Apple>(),
        back_inserter(apples),
        [h](const Apple& a) { return a.height <= h; }
    );
    sort(apples.begin(), apples.end(), [](const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    });
    cout << count_if(apples.begin(), apples.end(), [&s](const Apple& a) {
        return (s -= a.weight) >= 0;
    });
    return 0;
}
```

`C#`: 以上都是渣渣，看我 Linq 大法
```c#
int ans = apples.Where(a => a.height <= h).OrderBy(a => a.weight).Count(a => (s -= a.weight) >= 0);
```

### 附
[**My Blog**](https://tengkaize.github.io/)

---

## 作者：liuyinglun (赞：3)

# 第一次发布题解.
这道题的亮点：可以优化输入。

通过观察我们可以发现，有些数据是没有必要读入的，因此我们在输入的时候就可以过滤掉

然后拿苹果时先拿需要力气值小的，这就是贪心的内容了。

代码呈上
```
#include<stdio.h>
#include<stdlib.h>
 int tree_force[5000]; //每棵树所需要的力气值
int findPos(int data[], int low, int high) {
    //将大于t的元素赶到t的左边，大于t的元素赶到t的右边
    int t = data[low];
    while(low < high) {
        while(low < high && data[high] >= t) {
            high--;
        }
        data[low] = data[high];
        while(low < high && data[low] <=t) {
            low++;
        }
        data[high] = data[low];
    }
    data[low] = t;
    //返回此时t在数组中的位置
    return low;
}
//在数组中找一个元素，对大于该元素和小于该元素的两个数组进行再排序
//再对两个数组分为4个数组，再排序，直到最后每组只剩下一个元素为止
void quickSort(int data[], int low, int high) {
    if(low > high) {
        return;
    }
    int pos = findPos(data, low, high);
    quickSort(data, low, pos-1);
    quickSort(data, pos+1, high); 
}
//摘录至https://blog.csdn.net/change_on/article/details/56927267 

int main()
{
	int n,s,i;
	int ans=0;
	int k=0;
	int a,b;
	scanf("%d%d\n",&n,&s);
    scanf("%d%d\n",&a,&b);	
	 int heigh=a+b;//踩着椅子的最大高度
	int cnt=0,temp,temp2,trash;//树的高度只需要用于判断是否需要纳入force数组 
	for(i=0;i<n;i++) 
	{
		scanf("%d",&temp);
		if(heigh>=temp)
		{
			scanf("%d",&temp2);
			tree_force[cnt]=temp2;//如果够得到，就纳入数组 
			cnt++;
		}
		else		
		{
			scanf("%d\n",&trash);//跳到下一行 
		}; 
	}
	quickSort(tree_force,0,cnt-1);//快速排序，做贪心的基础 

	while(s>0)
	{ 
	    ans++;
	    s=s-tree_force[k];
	    k++;
	} 
	if(s<0)ans--;//如果力气为负数，说明力气不够拿最后一个苹果 
	printf("%d",ans) ;
} 

```


---

## 作者：GE_gb (赞：3)

我们在输入的时候就可以筛掉够不到的，先读入第一个数，判断是否够的着，如果不行，就把后面进跟着的“力气”丢到一个名为`hao_wu_luan_yong`的毫无用处的变量丢弃。这样，就可以节省掉一个xi数组，最后只留下力气数组。之后，排序，判定即可。

这里，我使用了`vector`，就不用管长度什么事情了，我一开始用数组排序的时候，前面莫名多了两个零……

代码如下：
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main(int argc, char const *argv[]) //这里是VS Code自己补全的
{
    int n, s, a, b;   //对应题目里的量
    int hao_wu_luan_yong;   //筛掉的够不到的苹果对应的力气
    vector<int> y;
    cin >> n >> s >> a >> b;
    
    int sum = a + b; 
    for (int i = 0; i < n; i++) {
        int j;
        cin >> j; 
        if (j > sum) {
            cin >> hao_wu_luan_yong;   //如果够不到，把对应的力气丢掉
        }
        else {
            int k; cin >> k;
            y.push_back(k);           //如果可以，存进力气数组
        }
        
    }

    int ans = 0;
    sort(y.begin(), y.end());             //排序
    for (int i = 0; i < n; i++) {
        if (y[i] <= s) {
            ans++; s = s - y[i];
        } else break;
    }

    cout << ans << "\n";
    
    return 0;
}
```

---

## 作者：DrunkXT (赞：3)

贪心思路：先摘消耗体力小且能摘到的苹果（按生活经验也是这样~~尽管C语言经常不遵循生活实际~~）。

所以用sort结构体排序即可（具体看代码）：
```
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=5005;
struct Node
{
	int x;//高度 
	int y;//消耗体力 
}a[MAXN];
bool cmp(Node a,Node b)
{//先以消耗体力升序排序，消耗体力相同，按苹果高度排序 
	if(a.y==b.y)
	    return a.x<b.x;
	return a.y<b.y;
} 
int main()
{
	freopen("陶陶摘苹果（升级版）.in","r",stdin);
	freopen("陶陶摘苹果（升级版）.out","w",stdout);
	int n,s;
	scanf("%d%d",&n,&s);
	int h,b;
	scanf("%d%d",&h,&b);
	h+=b;//陶陶站在凳子上能够到的最大高度 
	for(int i=1;i<=n;i++)
	    scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+1+n,cmp);
	int ans=0;
	for(int i=1;i<=n;i++)//扫一遍找到花体力而且能摘到的 
		if(a[i].x<=h&&s>=a[i].y)
		{
			ans++;
			s-=a[i].y;
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：abtd (赞：3)

对于每个苹果，无论花费多少力气， 得到的都是一个苹果（多劳不多得啊），自然需要力气小的苹果摘越多越好了（贪心）。这里的代码使用了STL的pair把两个数据合并在一起，简化了代码。

```cpp

#include <iostream>
#include <algorithm>
#include <utility>

using namespace std;

int n, a, b, s, ans;
pair<int,int> t[5005];  // second = xi; first = yi;

int main()
{
    cin >> n >> s >> a >> b;
    for (int i = 0; i < n; ++i)
    {
        cin >> t[i].second >> t[i].first;
    }
    sort(t, t + n);
    for (int i = 0; i < n; ++i)
    {
        if (t[i].second <= a + b && t[i].first <= s)
        {
            s -= t[i].first;
            ++ans;
        }
    }
    cout << ans << endl;
    return 0;
}

```

---

## 作者：jamespaul (赞：3)

      
```cpp
#include<cstdio>  
int A[5000+10]; //表示第i个苹果的高度   
int B[5000+10];  //B[i]  表示摘第i个苹果花的力气   
int n,s,deng,gao;   
int main()  
{  
    scanf("%d %d",&n,&s);  
    scanf("%d %d",&deng,&gao);  
    //排序前输出一次数组  
    for(int i=0;i<n;i++)  
    {  
        scanf("%d %d",&A[i],&B[i]);  
    }  
    //===========================================  
    for(int i=0;i<=n-2;i++)  //i从数组的第一个元素下标  一直到 数组倒数第二个下标  i向右走   
    {  
        for(int j=n-1;j>i;j--)  //j从数组的最后元素下标 j一直到i右边停下  j向左走   
        {  
            if(B[j-1]>B[j])  
            {  
                int t=A[j-1];A[j-1]=A[j];A[j]=t;  
                t=B[j-1];B[j-1]=B[j];B[j]=t;  
            }  
        }  
    }   
    //===========================================  
    //排序后  
    int ans=0;  
    for(int i=0;i<n && s>0;i++)  
    {  
        if(A[i]<=deng+gao && s-B[i]>=0)  
        {  
            ans++;  
            s-=B[i];  
        }  
    }  
    printf("%d",ans);  
    return 0;   
}
```

---

## 作者：zhao981029 (赞：3)

数据水，不解释。直接快排一下，然后由苹果为主，如果可以摘陶陶那么就摘（此时跳到下一个苹果和下一个陶陶）如果不能摘，那么就寻找下一个陶陶是否能摘，以此类推。由于排序是由小到大的，所以不会出错

```cpp
var  
 x,y:array [1..5000] of longint;  
 a,b,i,j,yy,n,s,ans,temp:longint;  
procedure sort(l,r: longint);  
 var  
  i,j,x1,y1:longint;  
 begin  
  i:=l;  
  j:=r;  
  x1:=x[(l+r) div 2];  
  repeat  
   while x[i]<x1 do  
    inc(i);  
   while x1<x[j] do  
    dec(j);  
   if not(i>j) then  
                begin  
                 y1:=x[i];  
                 x[i]:=x[j];  
                 x[j]:=y1;  
                 y1:=y[i];  
                 y[i]:=y[j];  
                 y[j]:=y1;  
                 inc(i);  
                 dec(j);  
                end;  
  until i>j;  
  if l<j then sort(l,j);  
  if i<r then sort(i,r);  
 end;  
procedure sort1(l,r: longint);  
 var  
  i,j,x1,y1:longint;  
 begin  
  i:=l;  
  j:=r;  
  x1:=y[(l+r) div 2];  
  repeat  
   while y[i]<x1 do  
    inc(i);  
   while x1<y[j] do  
    dec(j);  
   if not(i>j) then  
                begin  
                 y1:=y[i];  
                 y[i]:=y[j];  
                 y[j]:=y1;  
                 y1:=x[i];  
                 x[i]:=x[j];  
                 x[j]:=y1;  
                 inc(i);  
                 dec(j);  
                end;  
  until i>j;  
  if l<j then sort1(l,j);  
  if i<r then sort1(i,r);  
 end;  
begin  
 readln(n,s);  
 readln(a,b);  
 for i:=1 to n do  
  readln(x[i],y[i]);  
 sort(1,n);  
 yy:=n;  
 while x[yy]>(a+b) do  
  yy:=yy-1;  
 sort1(1,yy);  
 for i:=1 to yy do  
  if s-y[i]>=0 then begin  
                       s:=s-y[i];  
                       ans:=ans+1;  
                      end  
                 else begin  
                       writeln(ans);  
                       exit;  
                      end;  
 if ans=0 then writeln(0);  
end.
```

---

## 作者：AlexZy (赞：2)

**python题解**

看到各位犇犇都提贪心算法有点害怕

```python
#输入变量，定义变量
apple_num,total_strength = map(int,input().split())
height = sum(map(int, input().split()))
apples = []
pick_apples = count = 0
#读入苹果数据，并筛选出够得着的苹果
for i in range(apple_num) :
    apple_height, apple_strength = map(int,input().split())
    if apple_height <= height :
        apples.append(apple_strength)
#根据每个苹果的力气大小排序
apples.sort()
while total_strength > 0:
    if apples[count]<= total_strength:
        pick_apples +=1
    total_strength -= apples[count]
    count += 1
print(pick_apples)
```

---

## 作者：worijibama (赞：2)

蒟蒻第一次发题解，求轻喷，顺便问问各位大犇又没有更快的排序算法
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(){
    int a, b, n, s;//题设变量:凳子高度a，手长b，n个苹果，力气s
    int *height = NULL, *cost = NULL, *mark = NULL;//动态数组指针
    int cost_max, count=0;//力气范围内耗费最多的力气，和，苹果计数器
    int i,j;
    
    
    scanf("%d%d%d%d", &n, &s, &a, &b);
    if (s==0 || n==0) printf("0"); //没力气甚至没苹果直接输出0
    
    
    height = (int *)malloc(sizeof(int)*n);//苹果高度数组
    cost   = (int *)malloc(sizeof(int)*n);//所需力气数组
    mark   = (int *)malloc(sizeof(int)*n);//是否可取数组，1为不可取，0为可取
    memset(height, 0, sizeof(int)*n);//
    memset(cost, 0, sizeof(int)*n);//
    memset(mark, 0, sizeof(int)*n);//清零
    
    
    a += b;//合并高度
    
    
    for (i=0; i<n; ++i){    
        scanf ("%d%d",&height[i],&cost[i]);//录入每个苹果的高度和所需力气
        if (height[i] > a || cost[i] > s) mark[i] = 1; //如果高度过高或者力气不够，标记为1
        cost_max = cost_max < cost[i] ? cost[i] : cost_max;
    }
    
    
    for (i=0; i<=cost_max; ++i){  //先从费力少的开始摘
        for (j=0; j<n; ++j){      //观察每个苹果
            if (mark[j]) continue;//被标记过了就跳过，看下一个苹果
            if (cost[j] == i){      //如果要费的力气等于i
                if (s-cost[j] >= 0){//而且剩下力气够
                        s -= cost[j];//摸了
                        ++count;     
                        mark[j] = 1;
                }
                else{//否则已经没力气了，输出摘的个数
                    printf("%d", count);
                    return 0;
                }  
            }
        }
    }
    printf("%d", count);//力气足够摘完所有够得着的
    return 0;
}

```




---

## 作者：jhsg (赞：2)

    
```cpp
//很奇葩的想法
#include<iostream>
using namespace std;
int x[5001],y[5001],a,b,n,s,t=0;
bool used[5001];//标记该苹果是否被摘
int main()
{
    cin>>n>>s;
    cin>>a>>b;
    a=a+b;
    for(int i=1;i<=n;i++)
    {
        cin>>x[i];
        cin>>y[i];
        used[i]=0;
    }
    for(int i=1;i<=n;i++)
    if(x[i]>a) used[i]=1;//若摘不到，视为已摘
        int i=0;
        while(s>=0)
        {
           int j=10000,k=1;
           i=1;
           while(used[i]&&i<=n) i++; //若苹果被摘，下一个
           while(i<=n)
               {
                   if(j>y[i]&&!used[i])
               {
                   j=y[i];//j标记所用最小的力气
                   k=i;//k标记要摘的苹果
               }    
                   i++;
               }
            used[k]=1;//苹果已摘
            s-=j;//力气减少
            t++;//个数加一
        }
    cout<<t-1;//s小于零个数才加一，减去最后一个实际摘不到的
    return 0;
}
```

---

## 作者：Juliet (赞：2)

没什么技术含量，是水题，代码如下。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[6000];
int main()
{
    int pingguoshu,liqi,yizihigh,shoulong,x,y,num = 0;
    cin>>pingguoshu>>liqi>>yizihigh>>shoulong;
    for(int i = 0;i<pingguoshu;i++)
    {
            cin>>x>>y;
            if(yizihigh+shoulong>=x)//直接记录可以摘到的
            {
               a[num] = y;
               num++;
            }
    }
    sort(a,a+num);//快排
    int jishu = 0;
    for(int i=0;i<num;i++)
    {
        if(liqi-a[i]>=0)
        {
            jishu++;
            liqi-=a[i];
        }
        else
            break;//小优化
    }
    cout<<jishu<<endl;
    return 0;
}
```

---

## 作者：Cyamuleaf (赞：2)

嘿嘿嘿嘿··············

```cpp

#include<iostream>
#include<algorithm>
using namespace std;
int a[5001];
int main()
{
    int n,s,x,y,shou,deng,k=0,num=0,daan=0;
    cin>>n>>s>>deng>>shou;
    for(int i=0;i<n;i++)
    {
        cin>>x>>y;
        if(deng+shou>=x)
        {
            a[k]=y;
            num++;
            k++;//把所有可摘的全记下来
        }
    }
    sort(a,a+num);//排序啊
    for(int i=0;i<num;i++)
    {
        if(s-a[i]>=0)
        {
            daan++;
            s-=a[i];
        }//从小开始，注意若一个苹果摘完后s=0仍算的，第一个点就是
        else
            break;
    }
    cout<<daan<<endl;
    return 0;
}

```

---

## 作者：woshiren (赞：2)

大水题一道，把陶陶摘苹果普通版的程序修改一下即可

```cpp

var n,s,i,j,a,b,num,temp:longint;
    xi,yi:array [1..5000] of longint;
begin
  read(n,s);
  read(a,b);
  for i:=1 to n do read(xi[i],yi[i]);
  b:=b+a;//直接让陶陶站上凳子摘苹果。 
  for i:=1 to n-1 do
    for j:=i+1 to n do
    if xi[i]>xi[j] then begin 
                          temp:=xi[i];
                          xi[i]:=xi[j];
                          xi[j]:=temp;
                          temp:=yi[i];
                          yi[i]:=yi[j];
                          yi[j]:=temp;
                        end;//先按照高度排序。 
  for i:=1 to n-1 do
    for j:=i+1 to n do
    if yi[i]>yi[j] then begin
                          temp:=yi[i];
                          yi[i]:=yi[j];
                          yi[j]:=temp;
                          temp:=xi[i];
                          xi[i]:=xi[j];
                          xi[j]:=temp;
                        end;//再按照所需要用的力气排序。 
  for i:=1 to n do
    if (s>=yi[i])and(xi[i]<=b) then begin
                                      inc(num);
                                      dec(s,yi[i]);
                                    end;//如果陶陶摘的下来，总数+1，同时给陶陶的体力减去摘苹果所要的体力。 
  writeln(num);
end.

```

---

## 作者：chenyx (赞：2)


```cpp
#include<iostream>
using namespace std;
int h[5002],m[5002],i=1,s,n,a,b,j=1,ans;
void kp(int l,int r)
{
  int i=l,j=r,x,t;
  x=m[(i+j)/2];  
  while(i<=j) {
     while(m[i]<x) i++; 
     while(x<m[j]) j--; 
     if(i<=j) {t=m[i];m[i]=m[j];m[j]=t;i++;j--;}
       }  
  if(l<j) kp(l,j); 
  if(i<r) kp(i,r);
} 
int main()
{
    cin>>n>>s>>a>>b;
    for(i=1;i<=n;i++)
    {cin>>h[j]>>m[j];if(h[j]<=a+b){j++;}}j--;
    kp(1,j);
    for(i=1;i<=j;i++)
    {if(m[i]<=s){s-=m[i];ans++;}}
    cout<<ans;
    system("pause");
    return 0;
}
至于算法，下面的已经说了，注意数组开到5000，我数组才开到100，后来改成100，都没过，看看题才发现是5000。。。
```

---

## 作者：你若安好，便是晴天 (赞：2)

这题是很明显的贪心法问题

先把每一个可以摘到的苹果列出来

再把它们的力气排序

然后用贪心法取出前n个

最后输出结果


---

## 作者：qianniao (赞：1)

~~论我到底是怎么把这题和二分扯上关系的~~

## 分析：
考虑使用**贪心**算法，原因如下。

要想摘到最多的苹果，最好的方法是优先摘取所需**摘取力气小的苹果**。经过思考我们很容易可以得到：从摘取力气最小的苹果开始尝试摘取，接着尝试摘取摘取力气次小的苹果，以此类推，最后计算结果即可。

## 实现：
1. 将摘取力气进行```sort```排序；
2. 从摘取力气最小的苹果开始尝试摘取；
3. 判断陶陶身高+板凳高度是否大于等于该苹果高度；
4. 判断陶陶力气是否足够摘取；
5. 记录可摘取苹果数量的值并输出。

## 问题：

这个时候我们就会发现本题目需要重点解决的问题：使用```sort```
排序后存储苹果高度的数组下标与存储摘取力气数组下标**并不一一对应**，那么对此就有了几种解决办法：

## 解决方法：

- **结构体**


~~本蒟蒻还不会请看其他题解~~（不然为什么用二分！（）


- **冒泡排序**

在这里就只放核心部分了

```cpp
int x[5005] = {0},y[5005];
//x数组必须集体赋0否则冒泡时访问下标会越界
for(int i = 1; i <= n; i++){
	for(int j = 1; j <= n; j++){
		if(x[j] > x[j+1]){
			swap(x[j],x[j+1]);//交换苹果力气位置 
			swap(y[j],y[j+1]);//同时交换苹果高度的位置 
		} 
	}
}
```




- **二分查找（ᐛ**

用数组 $Copy _ {i}$ 将排序前的力气存下来，再进```sort```排序，接下来用**二分查找**一一对应```sort```排序后的 $Copy _ {i}$ 与 $y _ {i}$ 的下标，同时容易得出 $x _ {i}$ 的下标变化与之相同。

```cpp
//二分AC代码
#include<bits/stdc++.h>
using namespace std;
int x[5010]={0};//苹果高度
int y[5010]={0};//摘取力气
int Copy[5010]={0};//用于复制一份y数组
int answer[5010]={0};//用于存储查询到的下标位置

//二分查找
void find(int left, int right, int num){
	int mid;
	int ans = -1;
	while(left < right){
		mid = left + ((right - left) >> 1);
		if(Copy[mid] >= y[num]) right = mid;
		else left = mid+1;
		if(Copy[left]==y[num]){
			ans=left;
			break;
		}
	}
	
	//如果有多个同样的花费力气值调整ans就会出错！
	//如果当前位置有存储的下标则往后寻找存储地点
	while(answer[ans]!=-1) ans++;
	answer[ans]=num;
} 


int main(){
	int n,s,sum=0,cnt=0;//n：苹果数量 s：力气
	cin>>n>>s;
	int la,lb;//陶陶、凳子高度
	cin>>la>>lb;
	for(int i=1; i<=n; i++){
		cin>>x[i]>>y[i];
		Copy[i]=y[i];//复制
		answer[i]=-1;//初始化
	}
	sort(Copy+1,Copy+n+1);//sort排序（下标从1到n

	
	for(int i=1; i<=n; i++){
		find(1,n,i);//开找！
	}
	
	for(int i=1; i<=n; i++){
		cnt+=Copy[i];//先加上所需力气	
		if(x[answer[i]]<=la+lb){           
			if(cnt>s) break;//cnt超过s直接break
			sum++;
		}else{
			cnt-=Copy[i];//若摘不了就减去摘取力气
		}	
	}
	cout<<sum<<endl;
	return 0;
}
``` 

到这里就结束啦 谢谢你的观看qwq！

---

## 作者：chsw (赞：1)

为什么代码都那么长，本蒟蒻就把c++一维01背包贴上

------------
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,s,a,b,x[5010],y[5010],m[5010];

int main()
{
	scanf("%d%d%d%d",&n,&s,&a,&b);//使用scanf是一个好习惯，n s a b 全是根据题目定义的
    //cin>>n>>s>>a>>b;
	int h=a+b;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&x[i],&y[i]);
        //cin>>x[i]>>y[i];
    //01背包滚动优化
	for(int i=1;i<=n;i++)
		for(int j=s;j>=y[i];j--)
			if(x[i]<=h)
				m[j]=max(m[j-y[i]]+1,m[j]);
	printf("%d",m[s]);
    //cout<<m[s]<<endl;
	return 0;
}
```

---

## 作者：Sol1 (赞：1)

一道01背包题，力气s相当于背包容量，摘一个苹果需要的力气相当于物品重量。物

品的价值全部为1。为了操作方便，将陶陶摘不到的苹果先干掉，然后就完全按照01背包

的方程来操作就可以了。在这里，我暂且不讲01背包是咋操作的，不会的同学去查一下资料吧

大家最喜欢的环节：上CODE！

```cpp
    #include <iostream>
    #include <cmath>
    #include <cstring>
    #include <cstdio>
    using namespace std;
    struct apple //表示苹果的结构体
    {
        int s,w;
        apple(){w=1;}//创建时将价值初始化为1
    };
    int main()
    {
        int n,a,b,s,f[1001];
        apple ap[5001];
        scanf("%d%d",&n,&s);
        scanf("%d%d",&a,&b);
        int maxh=a+b;
        for(int i=1;i<=n;i++)
        {
            int h;
            scanf("%d%d",&h,&ap[i].s);
            if(h>maxh){i--;n--;}//干掉摘不到的苹果
        }
        //01背包
        for(int i=1;i<=n;i++)
            for(int j=s;j>=ap[i].s;j--)
                f[j]=max(f[j],f[j-ap[i].s]+ap[i].w);
        printf("%d",f[s]);
    }

```

---

## 作者：charliejiang_0w0_ (赞：1)

## 用了一点面向对象

## 所以说 C++大法好


本题的思路在于模拟，重点在于按照体力升序排序，用力少的先尝试。

同时我声明了一个class用于存放苹果。。其实就是个简单的pair。虽然代码量很多但是实际上逻辑绝对简单于大部分算法w





```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
#define forUntil(i,j) for (int i = 0; i < j ; i++) // 循环用，i=0...j
namespace P1478 { // 命名空间防止冲突
    int count;
    class apple { // 重要！这里声明了一个C++ 里面的class，为了方便后面用来排序苹果
```
public:









    
```cpp
        int height, useEnergy; // 高度，用掉的体力
        apple(int height, int useEnergy) { // 构造函数，因为里面没用到别的class所以不必写析构函数
            this->height = height;
            this->useEnergy = useEnergy;
        }
    };
    bool cmpAppleByEnergy(const apple &a, const apple &b) { // 对于apple对象a, b应该比较他们的需求体力大小
        return a.useEnergy < b.useEnergy;
    }
    vector<apple> apples; // 存放apple对象的vector
}
using namespace P1478; // 引用创建的命名空间
int main() {
    int countApples, energy, stoolHeight, taotaoHeight;
    cin >> countApples >> energy >> stoolHeight >> taotaoHeight; // 输入数据
    taotaoHeight += stoolHeight; // 加上凳子高度
    forUntil(i, countApples) { // 输入苹果数据
        int height, useEnergy;
        cin >> height >> useEnergy;
        apples.push_back(apple(height, useEnergy)); // 推进vector里面
    }
    sort(apples.begin(), apples.end(), cmpAppleByEnergy); // 按照用的体力排序！
    for (vector<apple>::iterator it = apples.begin();
        it != apples.end();
        it++) { // 遍历苹果
        apple theApple = *it;
        if (taotaoHeight >= theApple.height) // 先看高度
            if (energy >= theApple.useEnergy) { // 再看体力
                energy -= theApple.useEnergy; // 消耗体力
                P1478::count++; // 摘苹果
            }
    }
    cout << P1478::count << endl;
    return 0;
}
```

---

## 作者：Excim (赞：1)

//这个提与P1190接水问题非常像，先筛选出能摘到的苹果，用sort把他们花费的力气排序，花费力气少的先摘

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int n,h[5001],c[5001],d[5001],s,a,b,i,j,ans=0;//h是每个苹果的高度，c是花费的力气，d是能够到的苹果花的力气 
int main()
{
    scanf("%d %d",&n,&s);
    scanf("%d %d",&a,&b);
    for(i=0;i<n;i++)
    {
        scanf("%d %d",&h[i],&c[i]);
    }
    for(i=0;i<n;i++)
    {
        if(a+b>=h[i]) d[j++]=c[i];//如果这个苹果能够到，则它花费的力气保存在d中 
    }
    sort(d,d+j);//std从小到大排序 先摘花费力气最小的 
    for(i=0;i<j;i++)
    {
        if(s>=d[i])
        {
            s-=d[i];
            ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：2022135551q (赞：1)

```cpp
//奇怪的做法......
#include <iostream>
#include <algorithm>
using namespace std;
struct gq{      //想让大家理解，用了结构体...
    int hi;            //每个苹果高度
    int N;            //够每个苹果的力气，N是力的单位(-_-)!
};
gq pl[10001];
int fuzhi[10001];
int main() {
    int n,s,i,ban,shou,t=0,j,l=0,f=0,w=100000;
    cin>>n>>s>>ban>>shou;
    for(i=1;i<=n;i++){
        cin>>pl[i].hi>>pl[i].N;
    }
//输入，不用多说了
    for(i=1;i<=n;i++){
        fuzhi[i]=pl[i].N;    //复制给一个数组，为下面寻找做准备
    }
    sort(fuzhi,fuzhi+n+1);          //点个赞！（将"力"排序）
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            if(fuzhi[i]==pl[j].N){  //寻找相同的“力”
                if(ban+shou>=pl[j].hi){
                    if(s-pl[j].N<0){        //预判一下s是否<0
                        f=1;
                        break;
                    }
                    else{
                        s-=pl[j].N;
                        t++;
                    }
                }
                pl[j].N=w;w++;  //最独特的地方，找到“力”就替换，但替换的数需不一样
            }
        }
        if(f==1)
        break;
    }
    cout<<t;      //输出
    return 0;
}
//本题主要思想：从“力”最小的开始找起！！！
```

---

## 作者：SAVEN (赞：1)

第一次发题解，感觉我的代码很low，不过适用于初学者，有错误忘高手指点

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int x[10001],y[10001];//苹果的高度和所需力气
int main()
{
    int n,s; scanf("%d %d",&n,&s);
    int a,b,m=0;
    scanf("%d %d",&a,&b);
    for(int i=1;i<=n;i++)
        scanf("%d %d",&x[i],&y[i]);//以上相信大家看得懂
    for(int i=1;i<=n;i++)
        if(a+b<x[i]) y[i]=-1;//把够不到的苹果所需力气改为-1，这里说明一下，不能改为0，因为数据中本身就有需要力气为0的苹果。
    sort(y+1,y+n+1);//c++中的排序函数，方便快捷！
    for(int i=1;i<=n;i++)
         if(y[i]!=-1)//如果所需力气不是-1，也就是说如果够得着，那么……
         {
             s-=y[i]; //减力气
             if(s>=0) m++;//苹果数+1
             else break;//如果力气用光了，跳出循环
         }
    //for(int i=1;i<=n;i++)  //测试用的，真正交的时候要删。当然加上'//'就没事了
    //    printf("%d ",y[i]);
    printf("%d",m);//输出
    return 0;
}
```
核心是把苹果的力气排序从小的开始摘，保证能摘的最多；
the end。

再次感谢大家，感谢洛谷


---

## 作者：_Eterna1 (赞：1)


```cpp
var
  j,t,ans,n,s,h,h1,i:longint;
  x,y:array[1..5000]of longint;
  procedure swap(p:longint);   //这个过程只是为了装帅
  begin
    if p=1 then begin
      t:=x[i];
      x[i]:=x[i+1];
      x[i+1]:=t;
    end;
    if p=2 then begin
      t:=y[i];
      y[i]:=y[i+1];
      y[i+1]:=t;
    end;
  end;
  procedure SXsort;         //5000的数据冒泡排序就够了并且好写
  begin
    for j:=1 to n do
      for i:=1 to n-j do
        if y[i]>y[i+1]then     //针对耗费力气排序
          begin
            swap(1); swap(2);
          end;
  end;
begin
  readln(n,s);
  readln(h,h1);
  inc(h,h1);   //其实能达到的高度就是身高加椅子高咯
  for i:=1 to n do
    read(x[i],y[i]);
  SXsort;
  t:=0;            //t记录已消耗的体力
  ans:=0;          //ans记录已摘到的苹果数
  for i:=1 to n do
    if x[i]<=h then    //判断高度是否达到
      if t<=s then      //判断体力是否足够
        begin
          if((t+y[i])>s)then begin      //如果摘了这个苹果后超过体力上限，直接输出并结束
            write(ans);
            exit;
          end;
          inc(ans);               //摘到的苹果+1
          inc(t,y[i]);            //耗费体力值+y[i]
        end;
  write(ans);                     //循环正常结束后输出
  readln;readln;
end.
```

---

## 作者：kidsking (赞：1)

  
        
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct FM{int x,y;}a[5010];//定义结构体
bool cmp(const FM& a,const FM& b){return a.y<b.y;}//定义比较规则
int main(){
    int n,m,i,s,sum=0,c,b;
    scanf("%d%d",&n,&s);//苹果数与力气值
    scanf("%d%d",&c,&b);//椅子高和身高
    for(i=1;i<=n;i++)scanf("%d%d",&a[i].x,&a[i].y);//输入每一个高度和所需要的力气值
    sort(a+1,a+n+1,cmp);//对所需要力气进行排序
    for(i=1;i<=n;i++){
        if(s-a[i].y<0)break;//力气不够跳出
        if(a[i].x<=c+b){s-=a[i].y;sum++;}else continue;//如果高度不够则跳过，对下一个进行判定
    }
    printf("%d\n",sum);//输出
    return 0;
}
```

---

## 作者：CallMeTewi (赞：1)

思路很简单的一道贪心，但是有些地方有点繁琐。

我的方法很简单，略长，但没有什么高级的东西，只包含了两个库，很容易看懂。

```cpp

#include <iostream>
#include <algorithm>
using namespace std;

struct apfel    //用来保存苹果数据的结构体;
{
  int hi;/*苹果的高度*/
  int need;/*苹果需要的体力值*/
  int ablt;/*记录淘淘有没有摘到苹果的能力*/

};


int n=0,hTao=0,hChair=0,h=0,s=0,ans=0;
//分别是 苹果总数，淘淘的身高，椅子高，总高度，剩余体力，能摘到的个数;

bool byH(const apfel a,const apfel b){return a.hi<b.hi;}
//让sort()函数以苹果的高度为标准排序的函数;
bool byN(const apfel a,const apfel b){return a.need<b.need;}
//让sort()函数以苹果需要的体力为标准排序的函数;

int main()
{
    /*Input*/
    cin>>n>>s>>hChair>>hTao;
    apfel apple[n];//存储苹果数据的数组
    for (int i=0;i<n;i++)
    {
        cin>>apple[i].hi>>apple[i].need;
        apple[i].ablt=0;
 //输入的过程，顺便把苹果的ablt初始化(结构体内直接默认初始化的语法只适用于C++11;
    }
    h=hTao+hChair;//计算总高度;

    /*Scan for apples which can be caught*/
    sort(apple,apple+n,byH);//以高度排序;
    for (int i=0;i<n;i++)
    {
        if (apple[i].hi>h) break;
        if (apple[i].hi<=h)apple[i].ablt=1;//将能够到的苹果标记;
    }

    /*Scan for apples which we should catch*/
    sort(apple,apple+n,byN);//以需要的体力排序;
    for (int i=0;i<n;i++)
    {
        if (!apple[i].ablt) continue;//如果够不到跳过;
        if (apple[i].need<=s)//如果能够到且有足够的力气够;
        {
            s-=apple[i].need;//体力减少;
            ans++;//计数;
        }
        if (apple[i].need>s) break;//因为已经是排好序的,所以只要遇到够不到的即可以停止;
    }
    /*Print out*/
    cout<<ans<<endl;//输出;

    return 0;
}

```

综上，完毕,希望可以有帮助。


---

## 作者：邓晓蓝 (赞：1)

```cpp
//每次摘需要力气小的就能摘到最多的苹果
var n,m,a,b,i,t,j,zs:longint;
    lq,gd:array[0..10000] of longint;
begin
  readln(n,m);
  readln(a,b);
  a:=a+b;  //站在椅子上摘苹果
  for i:=1 to n do
    readln(gd[i],lq[i]);
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if lq[i]>lq[j] then   //按照所需要的力气从小到大排序
        begin
          t:=lq[i];lq[i]:=lq[j];lq[j]:=t;
          t:=gd[i];gd[i]:=gd[j];gd[j]:=t;
        end;
  for i:=1 to n do
    if (a>=gd[i]) and (m-lq[i]>=0) then
      begin
        inc(zs);
        m:=m-lq[i];
      end;
  writeln(zs);
end.
```

---

## 作者：eagadsgbsadfhb (赞：1)

一个水题，将摘得到的力气排序，从小到大，直到力气<0 or 可摘的苹果=0，输出就可以了


```cpp
#include<stdio.h>
int main(){
    int m,j=0,x,y,n,q,a,b,i,k=0,s[5010],e=0;
    scanf("%d%d",&n,&q);
    scanf("%d%d",&a,&b);
    a=a+b;\表示可以够到的max值
    for (i=1;i<=n;i++){
        scanf("%d%d",&x,&y);
        if (a>=x)
            s[++j]=y;
    }\把可以摘到的放在一个数组里
    for (i=1;i<j;i++)
        for (k=i+1;k<=j;k++)
            if (s[i]>s[k]){
                m=s[i];s[i]=s[k];s[k]=m;
            }\把用的力起排序
    while (q>=0){
        q=q-s[++e];
        if (e>j) {
            e=j+1;
            goto v;
        }\当无数可取是，直接out
    }
    v:;
    printf("%d",e-1);\算的时候多算了一个(力气<0不能摘了)
    return 0;
}

---

## 作者：ws_pt1 (赞：1)

感觉这个比楼下那几个略好理解，先把高度能摘下来的苹果需要的力气用数组保存下来，把这些苹果按力气从小到大排序，这样就先摘花力气少的，代码如下：

[Pascal]

```cpp
var n,s,a,b,i,c,j,xi,yi,k,t,p:integer;
x,y:array[1..5001]of integer;
begin
 readln(n,s);
 readln(a,b);
 c:=0;
 k:=0;
 p:=0;
 for i:=1 to n do
  begin
   readln(xi,yi);
   if (a+b)>=xi then
    begin
     k:=k+1;
     y[k]:=yi;//能摘下来就把苹果数从0开始加一，然后把相应的苹果力气保存下来（因为后面根本不需要高度）
    end;
  end;
 for i:=1 to k-1 do
  for j:=1 to k-i do
   if y[j]>y[j+1]then
    begin
     t:=y[j];
     y[j]:=y[j+1];
     y[j+1]:=t;//似乎是个冒泡排序~
    end;
 while (s>0)and(p<=k) do
  begin
   p:=p+1;//纯粹为给后面减力气计数
   c:=c+1;//能摘下来的苹果数
   s:=s-y[p];//减去相应的力气，继续
   if s<0 then
    c:=c-1;//如果苹果还有，力气也大于零，但是剩下的苹果需要的力气比陶陶剩下的力气要多，所以在这个程序里会多加一个，把它减掉
  end;
 writeln(c);
end.
```

---

## 作者：gryql (赞：1)

【思路】


本来我以为这个题是DP，对于苹果有取和不取两种状态，像是一种背包模型，后来发现转移方程几乎写不出来。再后来发现只要在读入的时候做一次预处理，再快排费得体力值，最后累加器累加超过退出就可以了。时间复杂度反而是在排序上，O(N\*logN)。





```cpp
type apple=record
    x1,y1:longint;
    end;
//xx是高度，yy是力气
var app:array[1..1000] of apple;
    n,s,a,b,xx,yy,i:longint;
    sum:longint=0;
    sum1:longint=0;
    ans:longint=0;
procedure sort(l,r: longint);
      var
         i,j,x:longint;y:apple;
      begin
         i:=l;
         j:=r;
         x:=app[(l+r) div 2].y1;
         repeat
           while app[i].y1<x do
            inc(i);
           while x<app[j].y1 do
            dec(j);
           if not(i>j) then
             begin
                y:=app[i];
                app[i]:=app[j];
                app[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
    readln(n,s);
    readln(a,b);
    for i:=1 to n do
        begin
            readln(xx,yy);
            if a+b>=xx then
                begin
                    inc(sum);
                    app[sum].x1:=xx;
                    app[sum].y1:=yy;
                end;
        end;
    sort(1,sum);
    for i:=1 to sum do
        begin
            inc(sum1,app[i].y1);
            if sum1<=s then inc(ans) else break;
        end;
    writeln(ans);
end.
```

---

## 作者：world_romantic_xebec (赞：0)

想法很简单，估计大佬一看就懂：我想，一个苹果对应一个力量值以及一个高度，那不如按照力量排序，能达到高度并且力量值最小的优先，那我们定义一个bool类型的排序规则按照力量从小到大的顺序

下面会有注释哟。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,s,a,b,ans;

struct apple{//结构体定义苹果以及高度和摘取所用的力量
    int high,pow;
}app[5010];

inline bool cmp(apple x,apple y){
    return x.pow<y.pow;
}

inline int canget(apple x)//判断是否可以摘，如果可以摘就返回1，否则随便返回吧
{
    if(x.high<=a+b)return 1;
    else return 99;
}
int main (){
    
    scanf("%d%d%d%d",&n,&s,&a,&b);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d",&app[i].high,&app[i].pow);
    }
    
    sort(app+1,app+1+n,cmp);//按照力量值排
    for (int i=1;i<=n;i++)
    {
        if (canget(app[i])==1)//如果可以摘苹果，就让力量值减去这个苹果所需要的力量
        {
            s-=app[i].pow;
            if(s<0)break;//如果没力量了，那就结束吧
        else ans++;否则，能摘得数量++
        }
        
    }
    printf("%d",ans);
    return 0;
}
```



---


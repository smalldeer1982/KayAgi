# 泥泞路

## 题目描述

暴雨过后，FJ 的农场到镇上的公路上有一些泥泞路，他有若干块长度为 $L$ 的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。

## 说明/提示

对于 $100 \%$ 的数据，$n,L \leq 10000$，$s \leq e \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 6
13 17
8 12```

### 输出

```
5```

# 题解

## 作者：greenheadstrange (赞：67)

**贪心**大法好啊好，不卡常，不超时，简单代码就AC。

------------
言归正传，首先将每条线段按照起始端点进行从小到大的排序。然后在一个for循环搜一遍。

时间复杂度O（nlogn）

废话少说，直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct note{
	int l,r;
}a[10005];//定义结构体
int n,m,ans;
bool cmp(const note&aa,const note&bb){
	return aa.l<bb.l;
}//按照始端点从小到大排序
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i].l,&a[i].r);
	sort(a+1,a+n+1,cmp);
	int x=0;//x表示当前的木板铺到了哪里
	for(int i=1;i<=n;i++){
		x=max(x,a[i].l);//如果x小于当前泥泞路的始端点
		while(x<a[i].r){
			x+=m;//加上木板长度
			ans++;//答案总数加1
		}
	}
	printf("%d",ans);
	return 0;
}
```

结束语：**OI路上困难重重，唯有静下来，才能成为顶尖高手**

---

## 作者：zuytong (赞：27)

```cpp
//此代码简单易懂，适合新手！
#include<iostream>
#include<algorithm>
#include<math.h>//max的头代码；
using namespace std;
int n,l,s[10005],e[10005],i,h,d;
int main()
{
    cin>>n>>l;
    for(i=1;i<=n;i++)
        cin>>s[i]>>e[i];
    sort(s+1,s+1+n); sort(e+1,e+1+n);//这里把起点和终点排序（因为每次输入起点小于终点，所以排完序后不会出现起点比终点小的情况）；
    d=s[1];//d存放起点；
    for(i=1;i<=n;i++)
    {
        while(d<e[i])//当起点大于终点，不再执行（也可以避免了起点比终点大的尴尬）；
        {
            d+=l;
            h++;//统计木板数
        }
        d=max(d,s[i+1]);//比较当前终点和下一个起点，选大的，避免重复；
    }
    cout<<h;//输出木板数；
    return 0;
}
```

---

## 作者：花千树 (赞：19)

本题思路：结构体快排+贪心，定义一个结构体，两个成员a，b，分别存入泥泞路的起点和终点（其实是对应的，以起点或终点为基准快排都行）没多少要注意的，就是要仔细。

话不多说，上代码！！！！！！！！！！！！！

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>//sort必备万能头文件
using namespace std;
int ans;//最终输出结果
struct AC{//结构体定义
    int a,b;
}f[10005];//结构体数组
int maxn(int a,int b){//手写max函数，这里插一句，尽量简单的函数自己写，不要为了一个小函数又加一个头文件，在竞赛中，如果数据范围很大，手写函数不容易爆空间（比如绝对值，判断大小max，min）
    return a>b ?a:b;
}
bool cmp(const AC&x,const AC&y){//sort的cmp
    return x.a<y.a;
}
int main(){//过程华丽开始
    int n,l;
    scanf("%d%d",&n,&l);//读入
    for(int i=0;i<n;i++)
        scanf("%d%d",&f[i].a,&f[i].b);//读入
    sort(f,f+n,cmp);//快排
    int j=f[0].a;定义一个小指针（说白了就是变量）
    for(int i=0;i<n;i++){
        while(j<f[i].b){//指针不超就能做
            j+=l;指针加上木条    
                       ans++;//木条++
        }
        j=maxn(j,f[i+1].a);//最大值为下一轮的j
    }
    printf("%d\n",ans);//完美输出
    return 0;//过程华丽结束
}
```

---

## 作者：lawsonabs (赞：11)

## 我一直相信渣渣写的题解，对谁都友好。

## 0.前言
典型的贪心算法解题，（~~当然我这些天是从络谷中专挑贪心练习~~），可能直接给我这题，我也不知道会用什么算法。

## 1.思路
 

- step 1：将泥泞小路针对起点排序。使用一个 **结构体+自带`sort`** 就可以实现。
- step 2：得到起点有序的小路之外，就需要考虑怎么铺路了。该怎么铺呢？主要就是两种情况：
  -  情况1:每次恰好只铺了自己的路。而且也刚刚好铺完，这样就不会导致与后面的铺路重复。比如“**1 3**”起点是1，终点是3，这样用一个长度为3的木板，一次就可以铺好。同理，“1 6”就只需要完整的2块木板。
  - 情况2：世界不可能如此完美，那么遇到不能整铺的情况怎么办？例如：“1 4”用长度为3的模板就需要两块。（1-3用一块，3-4再用一块。但是很显然，3-4这块木板是多余了2米。）我们就需要考虑如何最优化这种铺法多余的木板。很简单，贪就是了！**如果当前铺的终点的比下次要铺的起点要远，那么我们就用这次的终点接着铺，而不是从下次的起点开始铺**。无论如何，这样都能保证铺路木板最少化（因为更短的路需要更少的木板。）例如，有两段路都需要铺，分别是“3-7，8-12”（使用长度为3的木板），可以看到（3-6-9-12）只需要3块木板，如果是分开铺（3-6-7，8-11-12），则需要4块木板。

## 3.实现
```c
#include<iostream>
#include<algorithm>
using namespace std;
const int maxN = 10005;
typedef struct{
	int s,e;
}Road;
Road road[maxN];

bool cmp(Road r1,Road r2){
	return r1.s < r2.s;
}

int main(){
	int n,l;
	cin >> n>> l;
	for(int i = 0;i< n;i++){
		cin >> road[i].s >> road[i].e;		
	}
	int res = 0;
	sort(road,road+n,cmp);
	
	//从road[0]开始铺 
	int prioE = 0; //上一次的结束 
	for(int i = 0;i<n;i++){
		int m = 0;//铺当前路 需要的模板数 
		int len ;
		if(road[i].e <= prioE){//上一次就铺完了 
			continue;
		}
		if(road[i].s < prioE) {//如果本次开始小于上次结束，则一起铺，
			len = road[i].e - prioE;
			m +=(len/l);
			if(len%l!=0)//有余数加一 
				m++; 
			prioE += m*l;//实际铺到了哪里 
		}
		else{
			len = road[i].e - road[i].s;
			m +=(len/l);
			if(len%l!=0)//有余数加一 
				m++; 
			prioE = road[i].s + m*l;//实际铺到了哪里 
		}					
		res+=m; 		
	}
	cout << res<<"\n";
}
```

## 4.测试用例
```java
3 3
3 7
8 12
13 19
5

1 1
1 1000000
999999

3 1
1 6
13 17
8 12
13

3 3
1 6
13 17
8 12
5

3 10000
1 6
13 17
8 12
1
```


---

## 作者：Forever丶CIL (赞：8)

这个题吧，可能好多人都没看懂样例，我给大家解释一下

对于样例第二行1 6：所描述的泥泞路段是1到2,2到3,3到4,4到5,5到6

这样一个长度为5的路段，当然也可以见到的看作取起点不取终点

或者是取终点不取起点。

这样的话，我们就可以按起点排一边序，然后从头到尾算一遍啦

具体解释在代码中2333



------------

2022/7/31 加点内容（其他内容是 2017-04-30 的）

有人评论问了我：


5 3
0 10
2 9
3 8
4 7
5 6
-> 4

为啥是 1 1 1 1 1 1 1 1 1 1 0

我发现是我以前的内容写的太拉了，自己都看不懂了，所以补充一下。

首先这个题如果泥泞路两端是1和3，则说明是一个1到2，2到3的长度为2的泥泞路，故而一个长度为2的木板可以覆盖1到3。这个明白之后就要简单很多了。

在这里我这个1表示的是区间，可以见下图：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/clezwyk5.png)

对应这个数据

3 3
1 3
4 6
7 9
-> 3

0 1 1 0 1 1 0 1 1 0 0

这样应该就看明白了，1表示这个区间是泥泞路，比如1-2是泥泞路，而不是1这个点是泥泞路。

那么
5 3
0 10
2 9
3 8
4 7
5 6
-> 4

1 1 1 1 1 1 1 1 1 1 0

自然对应下图：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/b4rxyvni.png)

思路也再解释一下吧

1. 按起点从小到大排序

2. 逐个枚举泥泞路
	
	a. 如果这个泥泞路在铺上个泥泞路的时候就给铺了，就没必要管了
    
    	i.用个变量记录一下上个泥泞路铺完后多出来了多少就可以
        
   b. 算一下铺这个路要花多少

3. 结束

------------


------------



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,tp,ans=0;
struct edge //结构体记录每一段的起点、终点
{
    int l;
    int r;
};
struct edge E[100011];
int cmp(edge a,edge b)//排序（按起点从小到大） 
{
    return a.l<b.l;
}
void work()
{
    E[0].r=-0x3f3f3f3f;//这个赋值要比最小的起点小就行 
    int la=0;//记录上一次所铺的是哪一段 
    for(int i=1;i<=n;i++)
    {
        if(E[i].r<=E[la].r+tp) //tp记录在铺上一段时额外铺的长度 
            continue;//如果现在要铺的那一段被上一段包含，就可以跳过了，因为已经铺好了 
        while(E[i].l<=E[la].r+tp)//如果这次铺的背上一次部分包含 
        {
            E[i].l++;//就只铺剩下的，这里可以O（1）解决的，只不过我智障就写了个while 
        }
        la=i;//记录一下这次铺的是第几段 
        //下面就是计算会超出多少和该段需多少木板了 
        if(((E[i].r-E[i].l+1)%m)==0) tp=0;
        else tp=m-((E[i].r-E[i].l+1)%m);
        if(tp==0) ans+=(E[i].r-E[i].l+1)/m;
        else ans+=(E[i].r-E[i].l+1)/m+1;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&E[i].l,&E[i].r);
        E[i].r--;
    }
    sort(E+1,E+1+n,cmp);
    work();
    printf("%d",ans);
    return 0;
}
``` 


------------

送给大家一些我自己造的例子，希望能帮到大家，不用谢我 

3 3
1 6
13 17
8 12
-> 5

0 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0

3 3
1 4
2 6
9 18
-> 5

0 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0

3 3
1 3
4 6
7 9
-> 3

0 1 1 0 1 1 0 1 1 0 0

3 3
1 10
2 9
3 8
-> 3

0 1 1 1 1 1 1 1 1 1 0

4 4
1 4
2 5
3 6
4 7
-> 2

0 1 1 1 1 1 1 1 1 0

5 3
0 10
2 9
3 8
4 7
5 6
-> 4

1 1 1 1 1 1 1 1 1 1 0

4 4
0 10
2 9
3 6
4 7
-> 3

1 1 1 1 1 1 1 1 1 1 0

6 165
56 1651

156 158

165  18478

145614 156156

158618 158888

165418 168156

-> 195




---

## 作者：HPXXZYY (赞：4)

[题目传送门](https://www.luogu.org/problemnew/show/P1589)

首先来分析样例：

第1块木板：1到4

第2块木板：4到7

第3块木板：8到11

第4块木板：11到14

第5块木板：14到17

所以样例一共需要5块木板

思路：首先，我们把泥泞路以**起点** _从小到大_ 排序，设j表示当前木板能覆盖到的位置（**终点**），ans表示需要几个木板

计算ans：
```cpp
for(i=1;i<=n;i++){
    while (j<a[i].end){
        j+=l;ans++;
    }
    j=max(j,a[i+1].begin);
    //如果j比下一段泥泞路的起点还大的话
    //j保留原来的值（即不变）
    //即a[i+1].begin到j这一段不需重新覆盖
}
```

[评测记录：](https://www.luogu.org/recordnew/show/16135312)

耗时/内存：56ms，820KB

语言/长度：C++，0.5KB

状态/分数：Accepted，100分

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
    int begin,end;
    bool operator < (node a) const{
        return begin<a.begin;
    }
    //重定义小于运算符，给sort使用
    void read(){
        scanf("%d%d",&begin,&end);
    }
}a[10010];
int n,ans,j,i,l;
int main(){
    scanf("%d%d",&n,&l);
    for(i=1;i<=n;i++)
    a[i].read();
    sort(a+1,a+n+1);//排序
    j=a[1].begin;//注意，没有这句才40分
    for(i=1;i<=n;i++){
        while (j<a[i].end){
            j+=l;ans++;
        }
        j=max(j,a[i+1].begin);
    }
    printf("%d",ans);
    return 0;
}
```

最后，说一下万能头bits/stdc++.h

noi比赛文件中说：**理论**上可以用万能头，但实际中**可能不支持**使用万能头，若因为使用万能头而导致CE（编译错误），比赛**概不负责**，即**选手负全责**！！！

所以，比赛时**建议不要**使用万能头，平时可以**稍微使用**一下

---

## 作者：666yuchen (赞：4)

似乎我的题解是最~~特殊~~奇葩的
```c++
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<fstream>//文件头
using namespace std;
int n,l,maxz,gs;//定义
struct xx{int s,e;}a[10005];//定义结构体
bool cmp(xx a,xx b){return a.s<b.s;}//按第一个数从小到大比较
int main()
{
  cin>>n>>l;//输入泥泞路数n和木板长度l
  for(int i=1;i<=n;i++)//从1~n循环
  	scanf("%d%d",&a[i].s,&a[i].e);//输入泥泞路开始点和结束点
  sort(a+1,a+1+n,cmp);//排序
  maxz=a[1].s;//把第一个泥泞路的开始点存起来
  for(int i=1;i<=n;i++)
  {
  	if(a[i].e>=maxz)//如果泥泞路的结束点大于等于新木板的开始位置
  	{
  	  gs+=(a[i].e-maxz)/l;//算出这段距离需要的木板数
  	  if((a[i].e-maxz)%l!=0)//如果这段泥泞路离新木板的开始位置的差不能整除木板长度l
      	maxz=a[i].e+(l-(a[i].e-maxz)%l),gs++;//则新木板的开始位置等于泥泞路的结束点位置加上木板多出的长度，木板数+1
  	  else maxz=a[i].e;//否则新木板的开始位置就是泥泞路结束点的位置
    }
    maxz=max(maxz,a[i+1].s);//让当前木板的位置和下一个开头比较，求出新木板的开始位置
  }
  cout<<gs;//输出总木板数
  return 0;
}
```
### 杜绝抄袭，人人有责

---

## 作者：TESJackeyLove (赞：3)

**最近区间合并的题做多了，一看到这种输入方式就想到了区间合并，这题也确实可以先区间合并，然后再去铺木板。可以是可以，但是没必要，因为我后来发现合并了再铺和直接铺并没有什么区别= =，有点多此一举的感觉。所以正解就是先结构体排序然后遍历一遍就可以了。（刚刚有点问题，现在已经修正，求通过）**
- 排序部分比较交单，大家都会，按照线段左端点从小到大排序。
```cpp
  struct node{
      int l,r;
  };
  node arr[10005];
  bool cmp(node a,node b){
      return a.l<b.l;
  }
```
- 然后for循环把所有木板遍历一遍，这里我们可以用一个变量来记录一下木板铺到的终点（这里我用一个名为“mbed”（意思是木板结束，英语比较弱QAQ）的变量来记录）。然后核心部分就是两个if：
	1. 如果当前这块木板的左端点比mbed(木板铺到的终点)大，说明这一块是完全没有铺到的，那么我们从左端点这里开始铺，铺到哪里为止呢？这一段的长度是多少呢？右端点减去左端点就是长度（len=arr[i].r-arr[i].l），那么我们需要几块木板呢？这里一个小技巧可能有人知道有人不知道，(len-1)/L+1，这个值就是我们需要的木板数量（可以自行验证）。把这个值加到最终答案ans里面去，木板的终点更新:mbed=arr[i].l+L$\times$((len-1)/L+1)。
    1. 如果当前这块木板的左端点比mbed小，但是右端点比mbed小，说明这一块盖了一部分，没有盖完，那么我们从之前的mbed处继续盖，这一段的长度len=arr[i].r-mbed，一样的，这个值加到最终答案ans里面去，木板的终点更新:mbed+=L$\times$((len-1)/L+1)。
- 最后我们把这个ans输出来就可以了。以下是蒟蒻的代码：
```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<algorithm>
  #include<cstring>
  #include<cstdlib>
  #include<queue>
  #include<map>
  #define fore(i,a,b) for(int i=a;i<=b;i++)
  #define foru(i,a,b) for(int i=a;i<b;i++)
  #define ford(i,a,b) for(int i=a;i>=b;i--)
  #define IGNB std::ios::sync_with_stdio(false);
  #define ll long long
  #define INF 0x3fffffff
  using namespace std;
  struct node{
      int l,r;
  };
  node arr[10005];
  bool cmp(node a,node b){
      return a.l<b.l;
  }
  int main(){
      IGNB;
      int n,L,st,mbed=0,ans=0;
      cin>>n>>L;
      fore(i,1,n){
          cin>>arr[i].l>>arr[i].r;
      }
      sort(arr+1,arr+1+n,cmp);
      fore(i,1,n){
          if(arr[i].l>mbed){//完全没盖到，重新放一块 
              int tmp=(arr[i].r-arr[i].l-1)/L+1;
              ans+=tmp;
              mbed=arr[i].l+tmp*L; 
          }
          else if(arr[i].r>mbed){//盖了一部分 
              int tmp=(arr[i].r-mbed-1)/L+1;
              ans+=tmp;
              mbed+=tmp*L;
          }
      } 
      cout<<ans;
      return 0;
  }

```

---

## 作者：ubec (赞：2)

学校模拟赛做到了，看了一眼写了一个二分，顺手一觉好像过掉了....看了一眼题解大家好像都写的贪心，就讲一讲我的二分吧，好像也是利用贪心...
我们现在将所有区间排序，排序规则如下：

1.如果两个区间左端点相等，按右端点降序排序
2.如果两个区间左端点不相等，按左端点升序排序

这样有一个什么好处呢，就是方便我们写check函数

我们先计算出将排序后的第一个区间，也就是左端点最靠左的区间覆盖好后要用多少块木板，这样我们就可以得到当前能覆盖到的最右点，然后从第2号到第n号泥泞的道路扫一遍，注意到有一行是if(num*len<sub) num++这是因为我们要注意到一种情况，比如说我们当前有一段长度为7的区间，我们要拿长度为3的木板将它覆盖掉，显然需要三块，但是如果只是简单的7/3，得到的结果是2，因此我们需要特判一下这种情况，下面贴一下代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,l,r,len;
struct inv
{
	int l,r;
	bool operator <(const inv &x)const
	{
		if(l==x.l) return r>x.r;
		return l<x.l;
	}
}a[10001];
int check(int tot)
{
	int tmp=a[1].r-a[1].l;
	int tmpp=tmp/len;
	if(tmpp*len<tmp) tmpp++;
	tot-=tmpp;
	int mx=a[1].l+tmpp*len;
	for(int i=2;i<=n;++i)
	{
		if(a[i].r<=mx) continue;
		if(a[i].l<=mx)
		{
			int sub=a[i].r-mx;
			int num=sub/len;
			if(num*len<sub) num++;
			tot-=num;
			mx+=num*len;
		}
		else if(a[i].l>mx)
		{
			int sub=a[i].r-a[i].l;
			int num=sub/len;
			if(num*len<sub) num++;
			tot-=num;
			mx=a[i].l+num*len;
		}
	}
	if(tot<0) return 0;
	return 1;
}
int main()
{
	freopen("cover.in","r",stdin);
	freopen("cover.out","w",stdout);
	scanf("%d%d",&n,&len);
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i].l,&a[i].r);
	sort(a+1,a+1+n);
//	for(int i=1;i<=n;++i) printf("%d %d\n",a[i].l,a[i].r);
	l=1,r=10000000;
	while(l<r)
	{
		int mid=(l+r)>>1;
//		cout<<mid<<" "<<check(mid)<<endl;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```


---

## 作者：OIer991215 (赞：2)

这道题目看似很简单，但我第一遍提交却爆0（dalao请无视这一行）

这道题只有一个坑点，就是 铺的木板可以连接两块 “不连通的 泥路“。

一开始我开了一个很大的bool数组，却发现这种方法不可行。

后来我想到了正解：

1.将 泥路的起点和终点存入结构体，然后按起点由小到大sort一遍

2.从第一块泥路开始铺起，每次铺的起点是max(Begin,road.q)

   Begin指的是你铺完上一块泥路时的 末尾。

road.q指的是你当前要铺泥路的起点。

这样的话就解决了这点唯一的坑点了

下面是代码：



```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
int n,l,tot;
int Begin,End;
struct Node
{
    int q;
    int p;
}road[10010];
bool cmp(Node a,Node b)
{
    return a.q<b.q;
}
int main()
{
    scanf("%d%d",&n,&l);
    for(long long int i=1; i<=n; i++)
        scanf("%d%d",&road[i].q,&road[i].p);
    sort(road+1,road+1+n,cmp);
    for(int i=1; i<=n; i++)
    {
        Begin=max(Begin,road[i].q);
        End=road[i].p;
        for(int j=0;;j++)
            if(Begin+l*j>=End)
            {
                tot+=j;
                Begin=Begin+l*j;
                break;
            }
    }
    cout<<tot;
    return 0;
}
```

---

## 作者：MrMagnificent (赞：1)

看了半天样例才发现，要把终点减一才能AC，思路是在按起点排序后，用了一个last去更新当前木板所扑到的最终位置，代码还是挺好懂的吧。。。





```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int n,l,ans=0,last=0;
struct node
{
    int start,end;
}road[10009];
inline int read( )
{
    int f=1,p=0;char c=getchar( );
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar( );}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar( );}
    return f*p;
}
bool cmp(node a,node b)
{
    return a.start<b.start;
}
int main( )
{
    n=read( );l=read( );
    for(int i=1;i<=n;i++)
    {
        road[i].start=read( );
        road[i].end=read( )-1;
    }
    sort(road+1,road+1+n,cmp);
    for(int i=1;i<=n;i++)
    {
        if(last>=road[i].start)
        {
            while(last<road[i].end)
            {
                ans++;
                last+=l;
            }
        }
        else 
        {
            last=road[i].start-1;
            while(last<road[i].end)
            {
                ans++;
                last+=l;
            }
        }
    }
    printf("%d\n" ,ans);
    return 0;
}

```

---


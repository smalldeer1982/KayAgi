# 鸿山洞的灯

## 题目描述

已知 $n$ 盏灯以及每盏灯的位置 $p_i$，$p_i$ 均不相等，当两盏灯之间的距离小于 $dist$ 时，若这个安全距离里面还有灯是亮着时，就可以关掉这些灯（即若第 $i-1$ 盏与第 $i+1$ 盏的距离 $\leq dist$，则可以关掉第 $i$ 盏）。

求在保证洞里的光线是充足的情况下，一段区域里能删除的灯的最大值。

距离洞口最近和最远的两盏灯必须是亮着。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，保证 $dist$ 在 `int` 整型范围之内。

## 样例 #1

### 输入

```
3 3
1 2 3```

### 输出

```
1```

# 题解

## 作者：Ophelia (赞：55)

本题解做法贪心。

虽然其他题解里已经有了贪心的做法，但是这个做法加了一个小优化，使得代码更加快速(时间复杂度$O(NlogN)$)，而且更简洁。

排序是必要的。然后每次按顺序从前向后找是否符合条件，符合条件就关掉。

另外，第一盏和最后一盏等必须亮着，所以不找。

```
#include<bits/stdc++.h>
using namespace std;
int n,dist,a[100002],sum;
int main()
{
	cin>>n>>dist;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=2; i<=n-1; i++)
	{
		if(a[i+1]-a[i-1]<=dist)
		{
			a[i]=a[i-1];\\优化的核心部分。我们使用递推优化。其本质是关灯时把前一盏灯移到当前这一盏灯的位置上，防止下次计算时寻找前一盏灯。有类似链表删除的作用。
			sum++;
		}
	}
	cout<<sum<<endl;
	return 0;
}
```


------------

## 2019.1.9 更新

递推优化的实质是采用了一种链表的想法，只不过使用了递推的方式来代替。这次我们使用链表（数组模拟链表）来进行前一盏灯与后一盏灯的判断，不过本质依然是贪心。
```
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<vector>
#include<cstring>
#define inf 99999999
using namespace std;
typedef double db;
typedef long long ll;
int n,dist,sum;
struct NODE
{
	int data,pre,nxt;
}node[10001];//建立双向链表
int cmp(const NODE &a,const NODE &b)
{
	return a.data<b.data;
}//传入sort的排序规则函数，按照数据的大小排序
void del(int x)//删除下标为x的节点
{
	node[node[x].pre].nxt=node[x].nxt;//前一个节点的后一个节点改为当前节点的后一个节点
	node[node[x].nxt].pre=node[x].pre;//后一个节点的前一个节点改为当前节点的前一个节点
}
int main()
{
	cin>>n>>dist;
	node[1].pre=node[1].nxt=0;//初始化
	for(int i=1;i<=n;i++)
		cin>>node[i].data;//输入数据
	sort(node+1,node+1+n,cmp);//排序贪心
	for(int i=2;i<=n-1;i++)
	{
		node[i].pre=i-1;
		node[i].nxt=i+1;//建立前一盏和后一盏的联系。
	}
	for(int i=2;i<=n-1;i++)//第一个和最后一个不要操作
	{
		if(node[node[i].nxt].data-node[node[i].pre].data<=dist)//下一个节点的数据（下一盏灯的位置）减上一个节点的数据（上一盏灯的位置）<=dist的话
		{
			del(i);//删除当前节点
			sum++;//计数器++
		}
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：引领天下 (赞：21)

啊哈水题！

其实呢，我觉得这题大可不必用 dp，一个简单贪心搞定！

思路：

读进 $n$ 和 $dist$。

然后读入 $p_i$，排序。

之后就是核心代码了。

首先，题目中说如果 $p_{i+1}-p_{i-1}\le dist$ 就可以把 $p_i$ 关掉，那么，第 $1$ 盏肯定不能关，最后一盏也不能关。

于是，就有了从 1 到 $n-2$ 的循环（我用的是 0 下标）。

每次向前，找到离 $i$ 最近的一盏开着的灯，看看能不能把 $p_i$ 关掉（因为是从左往右找，所以右边的灯都未处理，是开着的）。

如果可以把 $p_i$ 关掉，那就把它标记为 0，$ans\leftarrow ans+1$

一趟循环走下来，答案就出来了。

此时，数组里除了必须留着的灯，其他都关掉了（标记为 0）。

最后输出就好了。

代码：

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int p[100001],n,dist,i,ans;
int main(void){
    scanf ("%d%d",&n,&dist);
    for (;i<n;i++)scanf ("%d",&p[i]);
    sort(p,p+n);//排序
    for (i=1;i<n-1;i++)
    if (p[i-1]!=0&&p[i+1]-p[i-1]<=dist)p[i]=0,ans++;//如果i-1是开着的，就可以不用开循环找了
    else{//不然向前找
        int j=i-1;
        while (p[j]==0)j--;
        if (p[i+1]-p[j]<=dist)p[i]=0,ans++;
    }
    printf ("%d",ans);//输出
}
```

---

## 作者：不争不闹 (赞：8)

话说这题不就是个贪心，干嘛要写DP这么变态的东西，标签也是贪心啊……


首先为了防止数据有坑点，不按从外往里的顺序，读进来之后先sort一遍，nlogn无伤大雅

由于题目描述，显然第一个和最后一个灯要保留

用emp记录上一个灯亮着的话最多能够扩展到哪里，中间的灯可以熄灭，显然其初始值就是p[0]+dist

那么枚举的时候从第二个开始，往后找

如果遇到一盏灯不在前一个亮着的灯所能扩展到的范围内，那么它前面的那个灯就需要保持点亮

如果遇到一盏灯在前一个亮着的灯所能扩展到的范围内，那么++ans

但是这样比较难实现……

转换：

**如果遇到一盏灯的后一盏灯不在前一个亮着的灯所能扩展到的范围内，那么这个灯就需要保持点亮

如果遇到一盏灯的后一盏灯在前一个亮着的灯所能扩展到的范围内，那么这个灯就可以熄灭**

所以算法流程：

读入
排序
从第二个枚举到第n-1，执行上面的粗体部分

输出答案



> #include<algorithm>
```cpp
#include<iostream>
#include<cstdio>
int n,p[100001],dist;
inline int read()
{
    int n=0,w=1;register char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9')n=n*10+c-'0',c=getchar();
    return n*w;
}
int main()
{
    n=read(),dist=read();
    for(int i=0;i<n;++i)
        p[i]=read();
    std::sort(p,p+n);
    int emp=p[0]+dist,ans=0;
    for(int i=1;i<n;++i)
    {
        if(p[i+1]>emp)
            emp=p[i]+dist;
        else    ++ans;
    }
    printf("%d",ans-1);
    return 0;
}
```

---

## 作者：Jiyuu_no_Tsubasa (赞：4)

写题解之前观摩了诸位大佬的题解，

这篇题解就把思路总结一下。

废话不说，本体主流做法有两种：

1. 贪心
2. 动规

我们先来讲较简单的贪心，再去搞动规。

## 贪心

本题的贪心解法很简单，

就是依题面所说：

排序后枚举判断这盏灯能否被熄灭。

注意：枚举时需要搜索前后的真正亮着的灯。

代码实现参考 $f$ 函数

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int p[100010];
int b[100010];
int f(int x,int v){
    int nx=x+v;
    while(b[nx])
        nx+=v;
    return p[nx];
}
int main(){
    int n; cin>>n;
    int d; cin>>d;
    int ans=0;
    for(int i=1;i<=n;i++)
        cin>>p[i];
    sort(p+1,p+n+1);
    for(int i=2;i<n;i++)
        if(f(i,1)-f(i,-1)<=d)
           b[i]=1,ans++;
    cout<<ans;
    return 0;
}

```
然而，极端数据下，

$f$ 函数执行时间可能很高，

因此我们可以优化。

运用链表直接查询前面与后面的灯：

（代码部分参考一楼大佬）
```
#include<bits/stdc++.h>
using namespace std;
int n,d,ans;
struct node{//手写链表
    int data,pre,nxt;
}a[10001];
int cmp(node a,node b){
    return a.data<b.data;
}
void del(int x){
    a[a[x].pre].nxt=a[x].nxt;
    a[a[x].nxt].pre=a[x].pre;
}
int main(){
    cin>>n>>d;
    a[1].pre=a[1].nxt=0;
    for(int i=1;i<=n;i++)
        cin>>a[i].data;
    sort(a+1,a+1+n,cmp);
    for(int i=2;i<n;i++){//建表
        a[i].pre=i-1;
        a[i].nxt=i+1;
     }
    for(int i=2;i<n;i++){
        if(a[a[i].nxt].data-a[a[i].pre].data<=d){
           del(i);
           ans++;
         }
     }
     cout<<ans;
     return 0;
}
```

但不用链表也可以优化：

每次熄灯后将熄灯的那盏用递推替换成上一盏，

这样就能保证准确无误的查询。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int p[100010];
int main(){
    int n; cin>>n;
    int d; cin>>d;
    int ans=0;
    for(int i=1;i<=n;i++)
        cin>>p[i];
    sort(p+1,p+n+1);
    for(int i=2;i<n;i++)
        if(p[i-1]-p[i+1]<=d)
            p[i]=p[i-1],ans++;
    cout<<ans;
    return 0;
}

```
## 贪心·完

我们可以发现，

本题中贪心解法是很优的，

但我们可以尝试另一种思路：

## 动规
开数组 $f$,

$f(i)$ 表示到 $i$ 最多能熄灭的灯数

在每次向前枚举，看是否能关闭一盏或更多的灯。

每次枚举关灯的左端点 $j$ 时，

$f(i)$需加上 $f(j)$。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int p[100010];
int f[100010];
int main(){
    int n; cin>>n;
    int d; cin>>d;
    for(int i=1;i<=n;i++)
        cin>>p[i];
    sort(p+1,p+n+1);
    for(int i=2;i<n;i++){
    	int j=i-1;
    	if(p[i]-p[j]<=d&&j>=1)
            f[i]=max(f[i],f[j]+i-j-1);//注意-1
	}//因为枚举到2盏灯时才能灭1盏
    cout<<f[n];
    return 0;
}

```

### 完结撒花

---

## 作者：Suiseiseki (赞：4)

在发这一篇题解之前，我先膜拜一下大佬 @魁拔

这一道题正解应该（仅仅是应该）是动态规划，我却发现C++只有一个贪心（非正解），固然一气之下（假的，~~只是为了骗贡献~~）来发一下这一篇题解。

这一题是一维动态规划，状态转移方程为：**f[i]=max(f[i-k]+i-k-1,f[i]);**

初始化为：f[0]=f[1]=0;（其实不用的）

不过数据有点坑，就是它并没有按升序排列，所以要排序（有什么关系呢，反正我们排序简单）

接下来上代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define mx(a,b) a>b?a:b
#define mn(a,b) a<b?a:b//之前一直用函数，后来发现了宏定义，就再也不用了
int ab(int a){
    if(a<0){
        return -a;
    }
    return a;
```
}//气死我了，宏定义定义错了，只能用函数
```cpp
int a[100005];
int f[100005];
int main(){
    int n,dist;
    scanf("%d%d",&n,&dist);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+1+n);//排序，~~填坑~~
    f[1]=0;
    int j,left;
    for(int i=2;i<=n;i++){
        j=i-1,left=0;
        while(ab(a[i]-a[j])<=dist&&j>=1){
            f[i]=mx(f[i],i-j+f[j]-1);
            j--;
        }
```
}//动态规划，核心部分，f[i]表示前i盏灯经过开关所得的最小剩余灯值（包括第i盏）
    printf("%d\n",f[n]);//答案是f[n]，输出，结束

    return 0;

}
蒟蒻代码，不喜勿喷，望指教


---

## 作者：阿拉丁神坑 (赞：3)

### 解法/思路

> 求在保证洞里的光线是充足的情况下，一段区域里能删除的灯的最大值。

易得,贪心是正解.

题意要求关尽可能多的灯,代码就应该一盏盏看能不能关

> 距离洞口最近和最远的两盏灯必须是亮着

所以第一盏和最后一盏不能关,所以循环应该从 $2$ 开始,到 $n-1$结束

数据需要自己**排序**哦,不保证顺序的...

### 代码
```cpp
#include <bits/stdc++.h>
int n, dist, cache, ans, da[100005];
bool p[100005];
bool cmp(int a, int b)
{
    return a < b;
}
int main()
{
    std::cin >> n >> dist;//输入
    for (int i = 1; i <= n; i++)
    {
        std::cin >> da[i];
    }
    std::sort(da + 1, da + n + 1, cmp);//排序
    for (int i = 2; i <= n - 1; i++)//根据题意,第一盏和最后一盏不能关,所以循环从2开始,到n-1结束
    {
        if (da[i + 1] - da[i - 1] <= dist)//如果他前面的灯和他后面的灯小于等于安全距离
        {
            da[i] = 0;//这盏灯没有了...
            std::sort(da + 1, da + n + 1, cmp);//重新来一波排序,确保顺序正确(保证中间没有0)
            ans++;//答案算上
        }
    }
    std::cout << ans;//输出
    return 0;
}
```


---

## 作者：米奇奇米 (赞：2)

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int main()
{ 
   long long n,m,a[10005];
   int sum=0; //定义变量
   cin>>n>>m;
   for(int i=1;i<=n;i++)
     cin>>a[i];
   sort(a+1,a+n+1); //快排（灯的顺序）
   for(int i=2;i<=n-1;i++)
   {   
	  if(a[i+1]-a[i-1]<=m)
      {  
        a[i]=a[i-1];//奇妙的优化
        sum++;
      }
   }
  cout<<sum;
return 0;//完结撒花
}
  

```
这道题目特别坑，要先把灯的位置进行排序（因为原来的灯的顺序是乱的，虽然样例里是对的）！这道题还要把数组开的大一点，千万别忘记开long long！！

---

## 作者：int32 (赞：1)

[P1610](https://www.luogu.com.cn/problem/P1610)

~~蒟蒻又来水题解啦~~

无耻安利一发[博客](https://www.luogu.com.cn/blog/tqz-lyc-blog-luogu/)

## 思路简述

贪心

首先，第一盏灯和最后一盏不能关！（题目所说）

其次，输入不一定有序，所以需要排序！

所以枚举每一盏灯，判断是否符合题目条件

```
//枚举每一盏灯
for(int i=2;i<n;i++){//不删首尾
        if(check(i-1,i+1)){//符合条件
            v++;
            p[i]=0;//标记为不亮
        }
        else{
            int tp=i-1;//从i-1往前找
            while(!p[tp]) --tp;//往前找是否亮着
            if(check(tp,i+1)){
                v++;
                p[i]=0;
            }
        }
    }
//check函数
inline bool check(int left, int right){
    return p[right]-p[left]<=d&&p[left];//安全否？亮否？
}
```
[$\color{black}AC$](https://www.luogu.com.cn/record/46216340)记录

蒟蒻的第二篇题解，大佬不喜轻喷

管理员大大求过！

---

## 作者：lagerst (赞：1)

一维动态规划


状态转移方程：

    f[0]:=0;

    f[i]:=max(f[i-k]+i-k-1,f[i]);(l<=k<=i-1,abs(c[l]-c[k])<=dist)

f[i]代表I亮时左方可最多灭灯数


特别的 数据需要排序


```delphi

type arr=array[1..100000]of longint;
var n,dist,i:longint;
    c,f:array[1..100000]of longint;
    procedure sort(l,r: longint;var a:arr);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j,a);
         if i<r then
           sort(i,r,a);
      end;
function max(a,b:longint):longint;
begin
  if a<=b then exit(b) else exit(a);
end;
function left(x:longint):longint;
var j:longint;
begin
  j:=x-1;          left:=0;
  while (abs(c[j]-c[x])<=dist)and(j>=1) do
    begin
      left:=max(x-j+f[j]-1,left);
      dec(j);
    end;
end;
begin
  readln(n,dist);
  for i:=1 to n do read(c[i]);
  sort(1,n,c);
  f[1]:=0;
  for i:=2 to n do
    f[i]:=left(i);
  writeln(f[n]);
end.

```

---

## 作者：青蛙王子 (赞：1)

这道题我同学很快就想出了思路，但是他没有用~

（原话：哎呀估计一下这个思路代码太长了我再写一个**8行**的吧）（orz奆佬）

（所以这个思路用到了我的代码里O(略略略)O~）

### 这个思路是一个非常奇葩的思路：

1.防止题目有坑**先排序**！

2.把$p[i]$加上$dist$，再另开一个$j$循环往后搜索，一旦发现有小于当前$p[i]$的$p[j]$，$sum$就++，并且标记$p[j]$(这一条可能有点难理解，往后有代码解释).

3.然后就可以输出了！

# 然而

这个思路还有很多的BUG

下面上代码并一一解释那些年我们没跳过去的坑：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,dist,p[100100],sum;
int main()
{
	cin>>n>>dist;
	for(int i=1;i<=n;i++)
	  cin>>p[i];
	sort(p+1,p+n+1);//数据范围不怂
	for(int i=1;i<n;i++)//坑1：i并不能等于n
	{
		if(p[i]>0)//这个地方就是个判断标记（见下方）
		{
			p[i]+=dist;//没错这个就是思路的核心
			for(int j=i+2;j<=n;j++)//坑2：其实这个地方即使j超出了n的范围，但也不碍事因为循环会自动停止
			{
				if(p[j]<=p[i])
				{
					p[j-1]=-100;//标记在此！（接上方）
					sum++;
				}//坑2.5：emmm其实这里我没写括号导致“莫名其妙”WA
			}
		}
	}
	cout<<sum;
	return 0;
}
```

对了，关于这里——

```cpp
for(int j=i+2;j<=n;j++)
```

以及这里——

```cpp
p[j-1]=-100;
```

坑3：（其实一开始我对题目有些误解）题目是让我们关掉两盏灯之间的那盏，所以我们用大循环中的$i$代表前一盏灯，$j$（也就是$i+2$）代表后一盏灯，$j-1$才是我们要关掉的灯.

## 最后，特别感谢坐在我旁边的同学提供了一个BUG而又wonderful的思路给我！orz！

（然而他早就已经8行代码AC了。。。）

---

## 作者：皮皮鲁大侠 (赞：0)

本蒟蒻来发题解啦！

这道题我第一次做PA，再看原来是数组开的不够大，改了就AC了……

所以说数组大小很重要啊！
------------
其实这道题是一道标准的贪心题目，贪心策略，排序，选择一应俱全（~~那我为什么还PA~~）

用一个数组确定开关灯的状态，初始都设定为1，再用排序把灯的位置排一下，最后遍历数组（从2到n），看离i左边与右边最近的灯的距离是否<=dist就行了，如果可以的话ans++，再把状态数组中灯的位置的状态置为0，最后输出ans就行了。

~~其实可以最后遍历整个数组，每碰到0就ans++的，但我嫌太麻烦没用~~

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,dist,a[100001],ans=0; 
bool b[100001];//确定开关灯状态的数组 
int main()
{
	cin>>n>>dist;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[i]=1;
	}
	sort(a+1,a+n+1);//快速排序 
	for(int i=2;i<n;i++)//从2到n，（因为洞口和洞穴最深处不能关灯） 
	{
 		int p,q;//设定两个变量来记录离i左边与右边最近的灯 
		for(int j=i-1;j>=1;j--)//寻找左边离i最近的灯 
		{
			if(b[j]==1)//如果是离i左边最近的灯，将q设为j
			{
				q=j;
				break;
			}
		}
		for(int j=i+1;j<=n;j++)//寻找右边离i最近的灯 
		{
			if(b[j]==1)//如果是离i右边最近的灯，将p设为j
			{
				p=j;
				break;
			}
		}
		if(a[p]-a[q]<=dist)//判断左右两盏灯之间的距离是否大于安全距离 
		{
			b[i]=0;//置零很重要！！！ 
			ans++;//调整计数器 
		}
	}
	cout<<ans;//输出 
	return 0;//撒花！*★,°*:.☆(￣▽￣)/$:*.°★* 。 
}
```
本蒟蒻第一次发题解，求管理员大大给过！

---

## 作者：七心海棠 (赞：0)

pascal的看过来！！！！！

这道题不知道为什么有人用dp，明明贪心就可以了。

首先，为了防止数据坑，不按从小到大顺序输入，打个快排，反正10000时间够。

贪心思路：

如果后一个灯在前一个亮着的灯的范围内，那么就熄灭这盏灯。

贴上代码：

```cpp
program li;
var
  a:array[1..100000] of longint;
  n,m,x,sk,i:longint;
procedure fac(x,y:longint);//快排
var
  i,j,m,t:longint;
begin
  i:=x;
  j:=y;
  m:=a[(x+y) div 2];
  while i<=j do
  begin
    while a[i]<m do inc(i);
    while a[j]>m do dec(j);
    if i<=j then begin
                   t:=a[i];
                   a[i]:=a[j];
                   a[j]:=t;
                   inc(i);
                   dec(j);
                 end;
  end;
  if i<y then fac(i,y);
  if j>x then fac(x,j);
end;
begin
  readln(n,m);
  for i:=1 to n do
  read(a[i]);
  fac(1,n);
  x:=a[1];//记录前一个亮灯
  for i:=2 to n-1 do//因为第1盏和第n盏不能熄灭
  if (x+m>=a[i+1]) then inc(sk)//加1个熄灭数
                   else x:=a[i];//记录
  writeln(sk);
end.
```
请勿抄袭，谢谢合作！！！！！

---

## 作者：血色黄昏 (赞：0)

又是没有python题解的题，吐槽QwQ

刚学贪心，拿这道题练练手

一般来说，贪心题都要先排个序，这道也不例外

思路就是扫过去，有符合条件的就删去，答案+1

上代码：
##

```
ans = 0#保存答案
s = input().split()#输入第一行
n, dis = int(s[0]), int(s[1])#n和dis赋值
l = input().split()#输入
for i in range(n):
    l[i] = int(l[i])#将输入转成int类
l = sorted(l)#排个序，从小到大
for i in range(1, n - 1):#第一盏和最后一盏不排（显而易见）
    if l[i + 1] - l[i - 1] <= dis:#如果符合条件
        del l[i]#删去
        ans += 1#答案加一
print(ans)输出答案
```
##
~~珍爱生命 远离抄袭~~

---


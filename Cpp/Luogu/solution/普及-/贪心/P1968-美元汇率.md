# 美元汇率

## 题目背景

此处省略 `MAX_INT+1` 个数。

## 题目描述

在以后的若干天里戴维将学习美元与德国马克的汇率。编写程序帮助戴维何时应买或卖马克或美元，使他从 $100$ 美元开始，最后能获得最高可能的价值。


## 说明/提示

**样例解释**

```cpp
Day 1 ... changing 100.0000 美元= 400.0000 马克
Day 2 ... changing 400.0000 马克= 133.3333 美元
Day 3 ... changing 133.3333 美元= 666.6666 马克
Day 5 ... changing 666.6666 马克= 266.6666 美元
```

update on 2017/08/18：

1. 样例正确答案为 $266.67$

2. 已经把测试点 $1$ 改成样例。

3. SPJ 原先误差是 $0.01$，按照题目要求，重新改为 $0.05$。

## 样例 #1

### 输入

```
5
400
300
500
300
250```

### 输出

```
266.67```

# 题解

## 作者：2er0n3 (赞：61)

蒟蒻题解奉上；

我用的动态规划思想，先设置f [ x ] [ 0 ]:表示第x天美元的最大收益；f [ x ] [ 1 ]表示第x天马克最大收益

先初始化f[ 1 ] [ 0 ] =100 ; f [ 1 ] [ 1 ]=第一天的汇率；

于是可得出状态转移方程f[i][0]=max(f[i-1][0],(f[i-1][1]/a[i])\*100);

f[i][1]=max(f[i-1][1],f[i-1][0]\*a[i]/100);

最后输出时再比较一次大小即可（要把马克转为美元哦）；

代码奉上（神犇dalao多多指教）

```cpp
#include<iostream>
#include<cstdio>
int n,a[100000];
double f[10000][2];//不要忘记double !!! 
using namespace std;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    f[1][0]=100;
    f[1][1]=a[1];//初始化千万不要忘记!!!! 
    for(int i=2;i<=n;i++)//f[x][0]为美元，f[x][1]为马克； 
    {
        f[i][0]=max(f[i-1][0],(f[i-1][1]/a[i])*100);// 
        f[i][1]=max(f[i-1][1],f[i-1][0]*a[i]/100);
    }
    printf("%.2f",max(f[n][0],(f[n][1]/a[n])*100));//比较把马克转为美元 
    return 0;
}

```

---

## 作者：moongazer (赞：21)

记录最大能达到多少马克和多少美元。

每次将上次的美元数换算成马克与上一次的马克取最大值，

再将上次的马克数换算成美元与上一次的美元取最大值。

最后输出美元数即可。

为了省空间，我没用数组，动态做的。

C++代码（C++的输出格式太长，我很懒的用了printf）：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
using namespace std;
int main(){
    double dp1,dp2,tmp;//由于dp1的值变化后,无法计算dp2,所以要用临时变量记录未作处理前的dp1
    int n,i,a;
    cin>>n;
    dp1=100.0;//初始有100美元
    dp2=0;
    for(i=1;i<=n;i++){
        cin>>a;
        tmp=dp1;
        dp1=max(dp1,(dp2/a*100));//将马克换成美元进行比较
        dp2=max(dp2,(tmp/100*a));//将美元换成马克进行比较
    }
    printf("%.2lf",dp1);//最后输出美元
    return 0;
}
```

---

## 作者：hmh13951417981 (赞：15)

## 这道题为dp：
## 满足最优子结构（每天最优则最后最优）
## 无后效性（后一天只需根据前一天的美元或马克兑换）
## 决策：
## 每一天手中的钱只有两种情况:
## 从前一天直接继承或者兑换钱
## 所以只要选择其中更优的一种即可

------------

```c
#include <bits/stdc++.h>
using namespace std;
int n,i,a;
double d[110]={0,100},m[110];
//d数组存储美元，m数组存储马克
int main() 
{	scanf("%d",&n);//输入天数
	cin>>m[1];//第一天的兑换值
	for(i=2;i<=n;i++){//循环天数
		scanf("%d",&a);
		d[i]=max(d[i-1],m[i-1]*100.0/a);
        //最优美元就是前一天的美元和由前一天马克兑换后的美元中较大值
        m[i]=max(m[i-1],d[i-1]*a/100.0);
        //最优马克就是前一天马克的和由前一天美元兑换后的马克中较大值
	}printf("%.2lf",d[n]);//输出第n天最大美元值
  	return 0;
}
```
# [~~还是不能理解的可以观看视频~~](https://pan.baidu.com/s/1PpMYZSSNqBE5UHuYH3XAZA?fid=737650076035731)


---

## 作者：pyqpyq (赞：12)

# 题目分析
这题是[CSP2019普及T3](https://www.luogu.com.cn/problem/P5662)的弱化版。~~早知道在CSP前刷一下团队作业就好了。~~

这道题可以把马克看作商品，而美元才是主要货币。

显然，我们可以把当天买入的马克，第二天卖出去，第二天仍然可以继续买马克，不影响最后结果。

这里就可以分情况讨论。第一种，当天的 $A$ （即输入数据中的那个 $A$ ）大于第二天的 $A$ ，那么无论换多少马克都会亏本。所以这种情况下，我们选择不动。

第二种，当天的 $A$ 小于第二天的 $A$ ，那么换的马克越多，赚的美元越多。所以这种情况下，我们用手上所有美元换马克，第二天再卖出去最优。

所以这题的贪心策略是，当天的 $A$ 小于第二天的 $A$ 时，我们用手上所有美元换马克，否则不动。

那怎么换呢？

# 数学推导

为了方便，我们可以在当天处理前一天的交易。那么我们用 $s$ 表示当天的 $A$ ， $l$ 表示前一天的 $A$ ，$m$ 表示前一天手中的美元数。

根据题意，总共换了 $\frac{m}{100}*l$ 马克。

故第二天换了 $\frac{\frac{m}{100}*l}{s}*100$ 美元。

化简得 $m*\frac{l}{s}$ 美元。

所以转移代码就是 `m*=(double)l/s` 。

# 参考代码

我的代码由于用 $l$ 存储了上一天的 $A$ ，所以不用开数组。但是由于用了强制类型转换，所以代码变慢了。~~1ms而已，不算什么。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,l;
double m=100;
int main()
{
	scanf("%d%d",&n,&l);
	for(int i=1;i<n;++i)
	{
		scanf("%d",&s);
		if(l>s)
		{
			m*=(double)l/s;
		}
		l=s;
	}
	printf("%lf",m);
	return 0;
}
```

---

## 作者：旗木五五开 (赞：8)

根据每次的汇率，
**寻找每个不上升子序列的开始和结尾**。

每个开始代表美元换马克，每个结尾代表马克换美元。
```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
using namespace std;
int main(){

	//1.定义和接收数据
	double ans=100,s,e;
	int HL[100],PD[100],n,i,Last=2;
	scanf("%d",&n);
	for(i=0;i<n;i++){
		scanf("%d",&HL[i]);
	} 
	HL[n]=1001;
    
	//2.构造坡度数组，下为1，上为2 
	for(i=0;i<n;i++){
		if(HL[i]>HL[i+1]){
			PD[i]=1;
		}
		else{
			PD[i]=2;
		}
	}
    
	//3.遍历坡度数组，计算起始位置和终止位置，并得出ans
	for(i=0;i<n;i++){
		if(Last==2){
			if(PD[i]==1){
				s=HL[i];
				Last=1; 
			}
		}
		else{
			if(PD[i]==2){
				e=HL[i];
				Last=2; 
				ans=ans*s/e;
			}
		}
	} 
    
	//4.输出ans 
	printf("%.2lf",ans);
	return 0;
}

```

---

## 作者：彩虹猫 (赞：4)

###  这题是一道简单的动规题。
###  用dp[i][0]表示i天美元最大收益，dp[i][1]表示i天马克最大收益
##   然后！！！
###  美元可直接由上一天的美元“继承”，也可用上一天的马克兑换而成。
### 因此我们可得出状态转移方程：

```
f[i][0]=max(f[i-1][0],(f[i-1][1]/a[i])*100);

f[i][1]=max(f[i-1][1],f[i-1][0]*a[i]/100);
```


------------
附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double dp[105][2];
int main()
{
    int i,n,a;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a);
        if(i==1)
        {
            dp[1][0]=100;
            dp[1][1]=a;
        }
        else
        {
            dp[i][0] = max( dp[i-1][0], 1.0*dp[i-1][1]/a*100 );
            dp[i][1] = max( dp[i-1][1], 1.0*dp[i-1][0]*a/100 );
        }
    }
    double ans1=dp[n][0],ans2=1.0*dp[n][1]/a*100;
    double ans=max(ans1,ans2);
    printf("%.2f\n",ans);
    return 0;
}
```
# THE END

---

## 作者：jerry3128 (赞：4)

我感觉这题还是比较简单，通过利率来算出赚来的钱

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;
int main(){
    int n,a[105];
    long double s=1;//定义 
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];//输入 
    }
    for(int i=0;i<n-1;i++){
        if(a[i]>a[i+1]){//如果今天的比明天贵，那么今天买就会赚 
            s*=1.0*a[i]/a[i+1];//把今天的买了，顺便把明天的卖了 
        } 
    }
    cout<<fixed<<setprecision(2)<<s*100;//上面算的是利率，所以要乘一百 
    return 0;
}
```

---

## 作者：yzx4188 (赞：4)

### dalao们都用DP，可我不会啊
发现没有用贪心的，赶紧来水一发！！！

我们可以通过观察样例，
发现：如果现在戴维手上的是美元，那么汇率就是越高越好(谁都想换多点钱嘛)。

但如果戴维手上的是马克，情况就会反过来，汇率越低越好(汇率低花的钱才少)。

所以这就是一道简单的贪心嘛：

1. 如果手上的钱是马克，那么如果明天的汇率更低，就等到明天再换；
1. 相反，如果手上的钱是美元，那么如果明天的汇率更高，就等到明天再换；
1. 但是这有一个小小的坑：最后一天必须换成美元，所以在写1号时要特判是否为最后一天
1. 不要忘了保留两位小数


贴代码辣：

————————————————华丽的分割线————————————————

```cpp
#include<bits/stdc++.h>//万能头万岁!!!
using namespace std;
int n;
int a[111];
double m=100;//m是money
bool check;//check是用来判断现在手上的是马克还是美元用的 
int i;
int main(){
	cin>>n;
	for(i=0;i<n;i++)
	    cin>>a[i];
	for(i=0;i<n;i++){
		if(check){
			if(a[i+1]<a[i]&&i!=n-1) 
			    continue;//如果明天汇率比今天低且今天不是最后一天就等明天
			else{
				m/=a[i];
				m*=100;
				check=false;//否则就换成美元 
			}
		}else{ 
			if(a[i+1]>a[i]&&i!=n-1||a[i+1]==0)//同上 
                continue;
            else{
            	m/=100;
            	m*=a[i];
            	check=true;
			}
		}
	}
	cout<<fixed<<setprecision(10086/*防抄袭*/)<<m;//输出+保留两位小数 
	//裆燃 用 printf("%.2f",m);也行只是符号有点多
	return 0;//撒花!!!
} 
```
望管理员准过***

---

## 作者：不存在之人 (赞：2)

设f[i][0]为换美元，f[i][1]为换马克，易得出状态转移方程。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define ms(i,j) memset(i,j, sizeof i);
using namespace std; 
double f[105][2]; 
int n;
int main()
{
	ms(f,0);
	scanf("%d",&n);
	int a;
	scanf("%d",&a);
	f[1][0]=100.0;f[1][1]=a;
	for (int i=2;i<=n;i++)
	{
		scanf("%d",&a);
		f[i][0]=max(f[i-1][0],f[i-1][1]/(double)a*100.0);
		f[i][1]=max(f[i-1][1],f[i-1][0]*(double)a/100.0);
	}
	printf("%.2f", f[n][0]);
    return 0;
}
```

---

## 作者：Timothy (赞：2)

【题目大意】

编写程序帮助戴维何时应买或卖马克或美元，使他从100美元开始，最后能获得最高可能的价值。这第i天中，戴维既能用100美元买ia马克也能用ia马克购买100美元。

【算法讨论】

这道题运用贪心的算法。策略：若100美元能购买的马克在上涨（即不下降序列），则在这个序列的顶部把美元购买成马克；

若100美元能购买的马克在下降（即不上升序列），则在这个序列的底部把马克换成美元。在最后一天把马克都换成美元。

得分：100

【样例分析】

5
400
300
500
300
第一天为100美元买400马克，与第0天相比呈上升趋势，因为第二天小于第一天，所以把美元换成马克；

第二天为100美元换100马克，与第0天相比呈下降趋势，因为第三天大于第二天，所以把马克换成美元；

同理，第四天换成美元，第五天换成马克。

【C++代码】

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int n;
double mon[105],ans=100;
bool flag=true;
int main ()
{
    scanf ("%d",&n);
    for (int b=1;b<=n;++b)scanf ("%lf",&mon[b]);
    mon[n+1]=21474800;
    for (int b=0;b<=n;++b)
    {
        if (flag==true)
        {
            if (mon[b]<=mon[b+1])continue;
            else 
            {
                ans*=mon[b];
                flag=false;
            }
        }
        else if (flag==false)
            {
                if (mon[b]>=mon[b+1])
                {
                    if (b+1==n){ans/=mon[b+1];break;}
                    continue;
                }
                else
                {
                    ans/=mon[b];
                    flag=true;
                }
            }
    }
    printf ("%.2lf",ans);
    return 0;
}

```
注意细节即可AC


---

## 作者：无羡qwq (赞：2)

本题的思路就是动态规划。

每一天都有拥有马克和拥有美元的两种形态；分别都是继承上一天最多的。

然后最后只输出拥有美元的即可。

c++版代码  应该比较易懂吧。。。




```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double max1(double,double);
int main(){
    double a[101],m[101],d[101];
    int n;  cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    d[1]=100.0;
    m[1]=d[1]*a[1]/100;
    for(int i=2;i<=n;i++)
    {
        d[i]=max1( d[i-1] , m[i-1]/a[i]*100.0 );
        m[i]=max1( m[i-1] , d[i-1]*a[i]/100.0 );
    }
     printf("%.2lf\n",d[n]);
    return 0;
}
double max1(double x,double y)
{
    return x>y?x:y;
}

```

---

## 作者：fastle (赞：2)

其实思路很简单的啦

根据我们贪心的思想

加入我们能做赚钱

也就是我们今天的汇率比昨天的小

我们就把他转换一次（至于怎么转换呢，看代码）

于是乎 19行代码AC

```cpp
#include<cstdio>
using namespace std;
double a[101];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
         scanf("%lf",&a[i]);
         a[i]/=100.0;
    }
    double now=100;
    for(int i=1;i<=n;i++)
        if(a[i]<a[i-1])
           now*=a[i-1]/a[i];    
    printf("%.2lf",now);
    return 0; 
}
```

---

## 作者：Annihilate (赞：2)

这题可以用贪心做，只要前一天的汇率小于后一天，就将马克换成美元。反之就将美元转为马克。

代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
using namespace std;
int a[105];
int main(){
    freopen("P1968.in","r",stdin);
    freopen("P1968.out","w",stdout);
    int n,i,j,k,o,p,l;
    scanf("%d",&n);
    double ans=100.0;
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    double mar=0.0;
    for(i=1;i<=n-1;i++){
    if(a[i]<a[i+1])ans+=mar/(a[i]*1.0)*100.0,mar=0.0;
    else if(a[i]>a[i+1])mar+=ans/100.0*(a[i]*1.0),ans=0.0;
    printf("%lf %lf\n",ans,mar);
}
    if(mar!=0.0)ans=mar/a[n]*100.0;
    printf("%.2lf",ans);
    return 0;
}

```

---

## 作者：wzh632071880 (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double a[200],mem[5][200],ans=-1;
void dfs(double x,int y,int z){
	//x表示元，y表示美元（0）还是马克（1），z表示天数 
	if(z==n+1){
		if(y==0){
			ans=max(ans,x);
		}
		return;
	}
	if(y==0){
		if(mem[0][z]&&mem[0][z]>=x)return;
	}
	if(y==1){
		if(mem[1][z]&&mem[1][z]>=x)return;
	}
	mem[y][z]=x;
	dfs(x,y,z+1);//不换
	if(y==0)dfs(x/100*a[z],1,z+1);
	if(y==1)dfs(x/a[z]*100,0,z+1); 
}
int main(){
	int i;
	scanf("%d",&n);
	for(i=1;i<=n;++i){
		scanf("%lf",&a[i]);
	}
	dfs(100,0,1);
	printf("%.2lf",ans);
	return 0;
}
**记忆****搜索**
```

---

## 作者：FORY (赞：1)

//dp[i]表示前i天的最大得的钱（美元），则在处在i天时可以有第i-1天的状态得，选择交换或者不换
```cpp
#include <math.h>
#include <algorithm>
#include <iostream>
#include <queue>
#include <cstdio>
#include <list>
#include <deque>
#include <set>
#include <vector>
#include <map>
#include <iomanip>
#define max(a,b) (a>b?a:b)
#define LL long long
using namespace std;
const int MAXN=1e6+7;
double a[MAXN];
double dp[MAXN]={0};
int main()
{
    ios::sync_with_stdio(false);
    int n,m;

    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
       // m+=num[i];
    }
    dp[0]=100;
    for(int i=1;i<=n;i++)
    {
        dp[i]=max(dp[i-1],dp[i-1]*a[i-1]/a[i]);
    }

    cout<<setiosflags(ios::fixed)<<setprecision(2)<<dp[n]<<endl;
    return 0;
}

```

---

## 作者：yyyyyyy (赞：1)

解析：问题可以转化为，比较相邻2天汇率大小，a[i]>a[j],

则可得m=m\*a[i]/a[j]。

奉上代码

```cpp
var ans:real;
    n,i:longint;
    a:array[0..101] of longint;
begin
{assign(input,'DOLLARS.in');
assign(output,'DOLLARS.out');
reset(input);
rewrite(output);}
read(n);
for i:=1 to n do read(a[i]); 
ans:=100;；//赋初值
for i:=1 to n-1 do
    if a[i]>a[i+1] then ans:=ans*a[i]/a[i+1];//核心部分
write(ans:0:2);//输出，保留两位小数
{close(input);
close(output);}
end.
```

---

## 作者：compile_error (赞：1)

**用贪心的思想**，我们每次都选取从中最大的汇率，保证当前是最优


-  但题上给的参数有两个，一个美元、一个马克

- 所以就需要维护两个变量(我的代码里面是用的dollar和mark)

- 最后要做的就是每次取最大值


代码如下

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int main()
{
    double dollar=100,mark;
    double charge;
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lf",&charge);
        dollar=max(dollar,mark/charge);
        mark=max(mark,dollar*charge);
    }
    printf("%.2f\n",dollar);
    return 0;
}
```

---

## 作者：Thor_Odinson (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N	100005
int n,m,ans=0,fang[N],gong[N];
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)cin>>fang[i];
	for(int i=1;i<=n;i++)cin>>gong[i];
	sort(fang+1,fang+m+1);
	sort(gong+1,gong+n+1);
	int s=1;
	for(int i=1;i<=n;i++)
	{
		if(fang[s]==0)s+=1;
		else if(gong[i]>fang[s])gong[i]=0,s+=1;
	}
	//cout<<s<<endl;
	if(s<=m)
	{
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		ans+=gong[i];
		//cout<<gong[i]<<endl; 
	}
	cout<<ans<<endl;
	return 0;
}```
- 每个攻击系统只能打一次,打完就没了
- 每个攻击系统必定有一个对应的防御系统
- 我方的攻击系统或敌方的防御系统有可能战斗值为0
- 要尽量用小的攻击系统打,因为要将大的留到最后打母舰
- 对于一个防御系统来说,大于它的最小的攻击系统就是我们求的最优解
- 时间复杂度为O(n)

---

## 作者：littlegagaduck (赞：0)

~~蒟蒻的dp一直很烂，写的不好的地方还请大佬多多关爱。~~

蒟蒻最开始用了一点贪心的思路，如果这一步需要转换的话就全部转化掉，因为转换是为了收益（转换一定收益），不收益就不转换，因此部分转换的话，
那一部分没有转换的本可以转换掉来取得更大的收益，这样便很容易理解不完全转换一定达不到最大收益。

我用了dp的方法处理以下的问题。 

假设现在拿在手里的是马克，如果上一步比现在汇率更高，如果只是在这里就转换为美元，固然会有收获，但如果下一步比现在的汇率更低，
这样便不是最优解了，怎么办？

我的解决方法是在当下处理两种情况，下一步如果比现在的汇率更低，下一步便从这一步转移存下的马克的数量，继续增值，否则就需要存下上一步转化
为美元的情况，避免贬值。这里可以理解的话，便也能理解当前的每一步需要做什么：如果比上一步汇率低，从上一步转移马克数量，处理当前的马克数量
和这一步转化成美元的数量，如果比上一步汇率高，转移上一步转化成的美元的数量（相当于“决定在上一步的那也时间点把手里的马克换为美元”），当前
的美元数量就是上一步转化出美元数量，当前的马克数量也需要存下，下一步如果比这一步的汇率低是需要使用的。

至于初始化，因为第一步拿在手里的是美元，自然的令第一步从“汇率比第零步高”的情况下转移过来就好了。 

可能说的有点复杂，但是蒟蒻觉得dp这种东西写起来可能没有这么复杂，想要理解是怎么来的这样的思考过程还是要有的。~~也许是蒟蒻太笨了别的大佬的题解一般是看不懂怎么想出来的。。。。。~~

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double a[1000]={0},g[1000]={0},f[1000]={0};//g:当前马克数，f:当前美元数 
int main()
{
	int n;
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];
	}
	f[0]=100;
	for(int i=1; i<=n; i++)
	{
		if(a[i]>=a[i-1])
		{
			f[i]=f[i-1];
			g[i]=f[i]/100*a[i];
		}
		else
		{
			g[i]=g[i-1];
			f[i]=g[i]/a[i]*100;
		}
	}
	printf("%.2f\n",f[n]);
	return 0;
}
```


---

## 作者：xukuan (赞：0)

存下当天能获得的马克和美元的最大值，最后输出美元的最大值


```pascal
uses math;

var
 i,n,x:longint;
 dollar,mark:array[0..110] of extended;
 //戴维能获得的最大值
begin
 readln(n);
 dollar[0]:=100;//初始化
 for i:=1 to n do
  begin
   readln(x);
   dollar[i]:=max(dollar[i-1]{不换},mark[i-1]*100/x{换});
   mark[i]:=max(mark[i-1]{不换},dollar[i-1]*x/100{换});
  end;
 writeln(dollar[n]:0:2);
end.
```

---

## 作者：attack (赞：0)

说一下我的思路：

首先我们可以推出：

美元换马克的比例式为：[(拥有的美元)\*当天马克]/100

马克换美元的比例式为：(100\*拥有美元)/当天马克

然后我们可以发现，当第i天的马克比第i+1天的马克多的时候是不能用马克换美元的

因为第i+1天换的美元一定比第i天多

然后初始化一下，胡乱搞搞就AC了。

虽然代码比较长吧。。。。。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
void read(int & n)
{
    char c='+';int x=0;bool flag=0;
    while(c<'0'||c>'9')
    {
        c=getchar();
        if(c=='-')flag=1;    
    }
    while(c>='0'&&c<='9')
        x=x*10+c-48,c=getchar();
    flag==1?n=-x:n=x;
}
const int MAXN=101;
int n;
double dp[MAXN][3];// dp[i][0]表示第i天能获得多少马克 
                   // dp[i][1]表示第i天能获得多少美元 
double mark[MAXN];
int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    //    read(mark[i]);
    cin>>mark[i];
    for(int i=1;i<=n;i++)
    {
        dp[i][0]=max(mark[i],dp[i-1][0]);
        dp[i][1]=max(100.00,dp[i-1][1]);// 初始状态 
        dp[i][1]=max(dp[i][1],(dp[i][0]*100)/mark[i]);// 马克换成美元
        dp[i][0]=max(dp[i][0],(dp[i][1]*mark[i])/100);
        if(i!=n&&mark[i+1]<mark[i])continue;
        dp[i][0]=max(dp[i][0],(double)dp[i][0]/mark[i]*mark[i]);
        dp[i][1]=max(dp[i][1],(dp[i][0]*100)/mark[i]);// 马克换成美元
    }
    double maxn=0;
    for(int i=1;i<=n;i++)
    {
        maxn=max((100.00*dp[i][0])/mark[i],maxn);
        maxn=max(maxn,dp[i][1]);
    }
    printf("%.2lf",maxn);
    return 0;
}
```

---

## 作者：Drinkwater (赞：0)

这道题是一道简单的dp题，最近想练练记忆化，所以用了三种方法，第一种爆搜只有40分，后面两种有100,。

dp[i][j]表示第i天j为0表示美元，j为1表示马克，当天的状态都可以由前一天转移，看代码就很明了了。






    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
using namespace std;
#define REP(i,a,b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++i)
typedef long long ll;
ll read()
{
    char c = getchar();register ll fg = 1, sum = 0;
    while(c < '0' || c > '9')
    {
        if(c == '-')fg = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    return sum * fg;
}
int dol = 100,mark,n,ans;
double a[1010];
//40分搜索 
void dfs(int pos , bool c, double last)
{
    if(pos > n)
    {
        if(c == 1)
        {
            dol = mark / (a[pos-1]/100);
        }
        ans = max(ans,dol);
        return ;
    }
    if(dol)
    {
        last = mark;mark = dol * (a[pos]/100);
        dfs(pos+1,c ^ 1,last);
        mark = last;
    }
    if(mark)
    {
        last = dol;dol = mark /(a[pos]/100);
        dfs(pos+1,c ^ 1,last);
        dol = last;
    }
}
//记忆化 
double dp[1010][2];
double dfs(int pos,bool c)
{
    if(dp[pos][c]!=-1)return dp[pos][c];
    if(!c)dp[pos][c] = max(dfs(pos-1,c),dfs(pos-1,c^1)/(a[pos]/100));
    else dp[pos][c] = max(dfs(pos-1,c),dfs(pos-1,c^1)*(a[pos]/100));
    return dp[pos][c];
}
int main()
{
    cin>>n;
    REP(i,1,n)cin>>a[i];
    dp[0][0] = 100,dp[0][1] = 0;
    //dp 
    REP(i,1,n)
    {
        dp[i][0] = max(dp[i-1][0],dp[i-1][1]/(a[i]/100));
        dp[i][1] = max(dp[i-1][1],dp[i-1][0]*(a[i]/100));
    } 
    REP(i,0,n)dp[i][0]=dp[i][1]=-1;
    dp[0][0] = 100,dp[0][1] = 0;
    printf("%.2lf",dfs(n,0));
}

```

---

## 作者：九指客 (赞：0)

```cpp
#include<stdio.h>
#include<string.h>//头文件
int n,b;  
double mon[105],ans=100;  
int flag=1;  //定义
int main ()  
{  
    scanf ("%d",&n);  //输入
    for(b=1;b<=n;++b)scanf ("%lf",&mon[b]);  
    mon[n+1]=2147483647;  //标记
    for (b=0;b<=n;++b)  
    {  
        if (flag==1)  //判断是否换成了马克
        {  
            if(mon[b]<=mon[b+1])continue;  
            else   
            {  
                ans*=mon[b];  
                flag=0;  
            }  
        }  
        else if(flag==0)  //判断是否换回了美元
        {  
            if(mon[b]>=mon[b+1])  
            {  
                if(b+1==n)
                {
                    ans/=mon[b+1];
                    break;
                }  
                continue;  
            }  
            else  
            {  
                ans/=mon[b];  
                flag=1;  
            }  
        }  
    }  
    printf ("%.2lf",ans);  //输出
    return 0;  
}
```

---


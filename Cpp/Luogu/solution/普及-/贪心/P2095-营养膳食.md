# 营养膳食

## 题目描述

Mr.L 正在完成自己的增肥计划。

为了增肥，Mr.L 希望吃到更多的脂肪。然而也不能只吃高脂肪食品，那样的话就会导致缺少其他营养。

Mr.L 通过研究发现：真正的营养膳食规定某类食品不宜一次性吃超过若干份。比如就一顿饭来说，肉类不宜吃超过 $1$ 份，鱼类不宜吃超过 $1$ 份，蛋类不宜吃超过 $1$ 份，蔬菜类不宜吃超过 $2$ 份。

Mr.L 想要在营养膳食的情况下吃到更多的脂肪，当然 Mr.L 的食量也是有限的。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 200$，$1\leq m\leq 100$，$1\leq k\leq 100$，$1\leq a_i\leq 100$，$1\leq b_i\leq k$。

## 样例 #1

### 输入

```
6 6 3
3 3 2
15 1
15 2
10 2
15 2
10 2
5 3```

### 输出

```
60```

# 题解

## 作者：ShineEternal (赞：37)

看到楼下的几位后笑了。。。

既然是贪心，那多半需要排序，答案要的是脂肪，所以按脂肪从大到小排序。
------------
```
#include<cstdio>
#include<algorithm>
using namespace std;
int b[10001];
struct ben
{
	int y,z;
}a[10001];
int cmp(const ben &a,const ben &b)
{
	return a.y>b.y;
}//脂肪从大到小
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&b[i]);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].y,&a[i].z);
	}
	sort(a+1,a+n+1,cmp);
	int ans=0;//答案别忘赋初值
	for(int i=1;i<=n;i++)
	{
		if(b[a[i].z]>0&&m>0)//还没超过这一类和总共规定
		{
			b[a[i].z]--;
			m--;
			ans+=a[i].y;//加上脂肪
		}
	}
	printf("%d",ans);
	return 0;
} 
```
求过

---

## 作者：MY（一名蒟蒻） (赞：17)

#### 毕竟这是贪心，所以排序必不可少

窝一开始认为，泥给我多少，窝就能吃多少。
#### 对于不会结构体快排蒟蒻来说，冒泡排序就是首选
于是有了以下代码
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <vector>

using namespace std;
int n,m,k,zl[210],ans;//zl数组是种类
struct sp{int zf;/*脂肪*/ int lb;/*类别*/}px[210];
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=k;i++) scanf("%d",&zl[i]);
	for(int i=1;i<=n;i++) scanf("%d %d",&px[i].zf,&px[i].lb);
    //优化的冒泡排序
	for(int i=n-1;i>=1;i--)
	{
		bool pd=false;
		for(int j=1;j<=i;j++)
			if(px[j].zf < px[j+1].zf)//如果这玩意肥肉更多
			{
				pd=true;
				swap(px[j].lb,px[j+1].lb);
				swap(px[j].zf,px[j+1].zf);
			}
		if(pd == false) break;
        //改进写法，若遍历一次后无需交换，说明数组已经有序，判断的目的是减少几趟排序 
	}
    //遍历数组，如果还能吃，ans+=脂肪
	for(int i=1;i<=n;i++)
		if(zl[px[i].lb] > 0) {zl[px[i].lb]--; ans+=px[i].zf;}	
        
	printf("%d",ans);
	return 0;
}
```
于是泥灰蜜汁WA
#### 窝重新看了一遍题目，原来窝只能吃m份！
改正代码如下
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <vector>

using namespace std;
int n,m,k,zl[210],ans;//zl数组是种类
struct sp{int zf;/*脂肪*/ int lb;/*类别*/}px[210];
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=k;i++) scanf("%d",&zl[i]);
	for(int i=1;i<=n;i++) scanf("%d %d",&px[i].zf,&px[i].lb);
    //优化的冒泡排序
	for(int i=n-1;i>=1;i--)
	{
		bool pd=false;
		for(int j=1;j<=i;j++)
			if(px[j].zf < px[j+1].zf)//如果这玩意肥肉更多
			{
				pd=true;
				swap(px[j].lb,px[j+1].lb);
				swap(px[j].zf,px[j+1].zf);
			}
		if(pd == false) break;
        //改进写法，若遍历一次后无需交换，说明数组已经有序，判断的目的是减少几趟排序 
	}
    //遍历数组，如果还能吃，ans+=脂肪
	for(int i=1;i<=n;i++)
		if(zl[px[i].lb] > 0 && m > 0) {zl[px[i].lb]--; m--; ans+=px[i].zf;}	
        
	printf("%d",ans);
	return 0;
}
```
丝毫不慌有人抄袭

~~因为作者实在是太蒻了~~
##### 写题解不易，管理员大大求过

---

## 作者：二元长天笑 (赞：10)

对于这一题，天笑刚开始看的时候也是蒙的。估计大家的问题也是关于如何理解**“表示可以吃1到k类食品的最大份数”**这句话，天笑刚开始是以为**第某样菜**，它属于**第某类**，所以**饭堂大妈**就炒了某份，我都可以吃掉。所以我就想把数据转换成如下了：

6 6 3   //这一行与原题一样

15 3    //第二个数就是我能吃多少份，下同

15 3
10 3
15 3
10 3
5 2
然后我就完美的**爆炸了**。

于是我就开始怀疑我是不是理解错了，最后我发现，没错，正确的理解是这样的：

**属于第某类菜的，假如总共有5样属于第1类的菜，而第一类中的值是3，那么我只能挑其中的3样，其他的全部丢掉。**

理解完后，这道题用贪心就可以非常顺利的解出来了。

下面是AC代码：


```cpp
#include<iostream> 
#include<algorithm> 
using namespace std; 
struct node 
{ 
    int ai; 
    int bi; 
}a[100001]; 
int b[100001],ans; 
void px(int l,int r)            //这是一个快速排序
{ 
    int i=l,j=r,mid=a[(l+r)/2].ai ; 
    do
    { 
        while(a[i].ai>mid) 
            i++; 
        while(a[j].ai<mid) 
            j--; 
        if(i<=j) 
        { 
            swap(a[i],a[j]); 
            i++; 
            j--; 
        } 
    }while(i<=j); 
    if(i<r) 
        px(i,r); 
    if(j>l) 
        px(l,j); 
} 
int main() 
{ 
    int n,m,k; 
    cin>>n>>m>>k; 
    for(int i=1;i<=k;i++) 
        cin>>b[i]; 
    for(int i=1;i<=n;i++) 
        cin>>a[i].ai>>a[i].bi; 
    px(1,n); 
    int o=1; 
    while(m>0)     //贪心
    { 
        if(b[a[o].bi]>0) 
        { 
            m-=1; 
            ans+=a[o].ai; 
            b[a[o].bi]--; 
            o++; 
        } 
        else
            o++; 
    } 
    cout<<ans<<endl; 
} 
```

然后这道题就非常愉快的被AC啦！


---

## 作者：Fairy1107 (赞：3)

## ！look   ！

其实本题的思想类似贪心，但我用了**冒泡排序**
~~（快排的题解没看懂）~~

首先要进行排序，然后将最大的脂肪数先++，若是个数满足了最大数量，便停止

本蒟蒻第一次发题解 ，欢迎提问哒~望采纳~~
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1000005],b[1000005],c[1000005];
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	cin>>b[i];
	for(int i=1;i<=n;i++)
	cin>>a[i]>>c[i];
	for(int i=1;i<n;i++)    //冒泡
	for(int j=1;j<=n-i;j++) 
	if(a[j]<a[j+1])
	{
		swap(a[j],a[j+1]);  
		swap(c[j],c[j+1]);
	}      
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		if(b[c[i]]!=0&&m>0)
		{
			sum+=a[i];
			b[c[i]]--;
			m--;//允许的数量-1
		}
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：源菌 (赞：3)

## 水一篇题解

评测机崩了还没来得急测
~~代码如果有问题求原谅~~（5.11）
![机你太美](https://cdn.luogu.com.cn/upload/pic/58446.png )



------------
这道题长得我需要一个语文班，信息全塞进了一堆里面（~~班主任蛋皮：费tm的话多~~）

呼唤我的~~亲爱的~~语文老师dcm（~~蓝色妖姬~~）中


------------
- 二狗：dls还没上课呢
- dls：我来了就是上课了

- dls：拿出你们的luogu翻到第2095页营养膳食，先一起读一遍
- classmates：哇啦哇啦哇啦哇啦
- dls：张嘴，一个个懒样风气要死不活的，我给你们听哈子今天早上二班的早读（拿出华为p7青春版）
- ......


------------
言归正传，这道题目可以归纳一下

### 题目分析
1. 阿月希望吃到更多的脂肪。

1. 然而也不能只吃高脂肪食品。

1. 阿月想要在营养膳食的情况下吃到更多的脂肪。

4. 阿月的食量也是有限的。

1. 阿月每顿饭最多可以吃m份食品。

1. 有n种食品供阿月选择。

1. 这n种食品分为k类。

1. 表示可以吃1到k类食品的最大份数。

接下来n行每行包括2个正整数，分别表示
该食品的脂肪指数ai和所属的类别bi。

输出阿月可以吃到的最大脂肪

【样例分析】
- 6(道菜) 6(份) 3(类)
- 3 3 2（每种最多能吃的数量）
- （脂肪）（种类）
- 15 1 （第1道菜）
- 15 2
- 10 2
- 15 2
- 10 2
- 5 3  （第6道菜）


------------
## 思路
为了方便打代码，加了个宏定义#define FOR(i,a,b) for(int i=a;i<=b;i++)

直接把所有蔡的脂肪和种类放在一个数组里，后面直接暴力循环求ans就行了

因为阿月希望吃到更多的脂肪，所以先排序（~~懒得打结构体~~用数组存的，所以使用冒泡排序
```cpp
FOR(i,1,n)
{
    FOR(j,i,n)
    {
		if(zf[i]<zf[j])
		{
			swap(zf[i],zf[j]);
			swap(kind[i],kind[j]);
		}
	}
}
```
然后while循环，看到题解里面有个for循环，m满了后还会继续运行

tj代码
```cpp
for(int i=1; i<=m; i++) {
    if(d[c[i]]<b[c[i]]&&eat<m) //如果这个食物还没吃到上限，总量也未到上限 （//循环内判断总量是否到达上限，如果到上限了还会运行）
    {
        ate+=a[i];
        d[c[i]]++;
        eat++;
    }

}
```
下面我的代码
```cpp
while(eat!=m)//while循环判断总量是否到达上限，如果到上限了停止运行
	{
		k++;
		if(best[kind[k]]!=0)
		{
			ans+=zf[k];
			best[kind[k]]--;
			eat++;
		}
	}
```
可以少循环总蔡-m满时次

当然也可以加一个
```cpp
if（eat>m）
break；
```


------------

### 上代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
int n,m,k;
int best[205]/*每种蔡最多吃多少*/,zf[105]/*蔡的脂肪*/,kind[105]/*蔡的种类*/;
int eat/*已经吃的蔡总量*/;
int ans;
int main()
{
	//freopen("diet.in","r",stdin);
	//freopen("diet.out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	FOR(i,1,k)
	{
		scanf("%d",&best[i]);
	}
	FOR(i,1,n)
	{
		scanf("%d%d",&zf[i],&kind[i] );
	}
	FOR(i,1,n)//冒泡排序不解释
	{
		FOR(j,i,n)
		{
			if(zf[i]<zf[j])
			{
				swap(zf[i],zf[j]);//记得两个都swap
				swap(kind[i],kind[j]);//讨论区有个大佬就是因为只swap了一个炸了
			}
		}
	}
	int k=0/*循环计数*/; 
	while(eat!=m)
	{
		k++;
		if(best[kind[k]]!=0)//如果那种蔡还能吃
		{
			ans+=zf[k];//加脂肪
			best[kind[k]]--;//我直接在输入的每种蔡最多吃多少里减
            //破坏了每种蔡最多吃多少，反正后面也不会用了
            //让best数组的意义变成每种蔡还能吃多少
			eat++;
		}
	}
	printf("%d",ans);
    //瑞特恩零
}
```
这个代码只能得60分，因为数据好像比给的数据范围大

把数组开大就行了


------------
更新(5.14)

发现了一个bug，在特殊情况下，当所有菜都循环完了没有可以吃的，但m没有满，就会一直循环下去！！！for循环不会出现这种问题，但是while会越界！！！

比如

- 总共可以吃m=10
- 有1 2 3三种蔡
- 1种蔡最多吃kind[1]=4;
- 2种蔡最多吃kind[2]=2;
- 3种蔡最多吃kind[3]=6;

然而数据是这样的 

| 脂肪|  种类|
| -----------: | -----------: |
|10|1|
|10|1|
|8|1|
|8|1|
|8| 2 |
| 8 |2  |
|  8|2  |
| 8 | 2 |
|  7| 2 |
| 7 | 2 |
|  7|  2|
|  7|  2|
| 7 |  2|
| 6 |  3|

或者更直接一点，连总蔡数都小于m

| 脂肪|  种类|
| -----------: | -----------: |
|10|1|
|10|1|
|8|1|
|8|2|
|8| 3 |

就会循环不出去

所以要加一个特判
```cpp
if(k>=n)
break;
```


------------


微博 [@这里是源菌鸭](https://weibo.com/u/6621413460?nick=%E8%BF%99%E9%87%8C%E6%98%AF%E6%BA%90%E8%8F%8C%E9%B8%AD)

知乎 [大源菌](https://www.zhihu.com/people/da-yuan-jun-29/activities)

---

## 作者：beng (赞：3)

# 总之就是各种无脑排序贪心……

就是先把每种食品的脂肪排序，再取可以吃的最大份数装进另一个数组(d)，在用脂肪排一下序，前m份食品的脂肪和就是答案了……（应该不用解释了吧……）

**（数据空间和时间上竟水的各种优化都不需要qwq）**

——————分割不完全的分割线——————

以下是pascal代码（这题竟没有pascal题解qwq）：

```cpp
var n,m,i,j,k,l,x,y,ans:longint;
a:array[1..100,1..200]of longint;//每类食品的脂肪
b,c,d:array[1..200]of longint;//b为每类食物吃的最大份数，c为每类食品的份数
begin
  readln(n,m,k);
  for i:=1 to k do
  read(b[i]);
  for i:=1 to n do
  begin
    readln(x,y);
    inc(c[y]);
    a[y,c[y]]:=x;
  end;
  for l:=1 to k do//每种食品的脂肪排序
  for i:=1 to c[l]-1 do
  for j:=i+1 to c[l] do
  if a[l,i]<a[l,j] then
  begin
    x:=a[l,i];
    a[l,i]:=a[l,j];
    a[l,j]:=x;
  end;
  y:=0;
  for l:=1 to k do//取可以吃的最大份数装进另一个数组(d)
  begin
    if b[l]>c[l] then
    j:=c[l]
    else
    j:=b[l];
    for i:=1 to j do
    begin
      inc(y);
      d[y]:=a[l,i];
    end;
  end;
  for i:=1 to y-1 do//用脂肪排一下序
  for j:=i+1 to y do
  if d[i]<d[j] then
  begin
    x:=d[i];
    d[i]:=d[j];
    d[j]:=x;
  end;
  for i:=1 to m do//前m份食品的脂肪和就是答案
  ans:=ans+d[i];
  writeln(ans);
end.
```

---

## 作者：伯爵H (赞：3)

本题为标准贪心题详解下面代码有注释
~~此为考古代码忘记思路了~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000],c[10000];//a存放脂肪，c存放食物类型 
int b[10000],d[10000];//b存放每种食物可以吃的数量，d位每种食物已吃的数量 
int main() {
    int n,m,k;
cin>>n>>m>>k;
for(int i=1; i<=k; i++)
    cin>>b[i];
for(int i=1; i<=n; i++)
    cin>>a[i]>>c[i];
for(int i=1; i<=n-1; i++)//把每种食物按脂肪含量从大到小排列 
    for(int j=i+1; j<=n; j++) {
        if(a[i]<a[j]) {
            int t=a[i];
            a[i]=a[j];
            a[j]=t;
            t=c[i];
            c[i]=c[j];
            c[j]=t;
        }
    }
int eat=0,ate=0;//eat存放所有食物已吃的数量，ate存放已吃的脂肪数量 
for(int i=1; i<=m; i++) {
    if(d[c[i]]<b[c[i]]&&eat<m) //如果这个食物还没吃到上限，总量也未到上限 
    {
        ate+=a[i];
        d[c[i]]++;
        eat++;
    }

}
cout<<ate;
return 0;
}
```

---

## 作者：无名ZWH (赞：1)

先说思路：结构体排序+贪心  
这题不难但有几个点要注意  
1：每顿有上限  
2：总食量有上限  
那么——上代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct yh
{
	int a;
	int b;
}lr[300];//a为食物脂肪，b为种类
int r[300],ans[300];//r为食物种类上限，ans为可食用的满足要求的最好的食物
bool cmp(yh x,yh y)
{
    if(x.b!=y.b)
	{
		return x.b<y.b;
	}
    if(x.b==y.b)
    {
    	return x.a>y.a;
    }
}//排序函数：先按种类排再按食物脂肪从大到小排序
int main()
{
	int m,n,da=0,k,ji=1,e=1;//n为食物总数，m为可吃的量，k为食物种类
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>r[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>lr[i].a>>lr[i].b;
	}
	sort(lr+1,lr+n+1,cmp);//排序
	for(int i=1;i<=n;i++)
	{
		if(r[ji]!=0)
		{
			ans[e]=lr[i].a;
			e++;//e为满足要求的最好食物数量
			r[ji]--;
		}//如果食物在可食用且未达到上限时则存入答案数组中
		if(lr[i].b!=lr[i+1].b)
		{
			ji++;
		}//ji统计算到了哪种
	}
	e=e-1;//之前会多算一个，减回来
	sort(ans+1,ans+e+1);//将满足要求食物质量排序
	for(int i=1;i<=m;i++)
	{
		da+=ans[e];//该食物被选
		e--;//普通sort为从小到大排，懒的写cmp将就一下
	}
	cout<<da;//da为最好情况
    return 0；//好习惯
}
```


---

## 作者：迷残云 (赞：1)

本题解必修知识：

1.基本贪心

2.struct结构体

3.STL中sort排序

贪心，本题思想是贪心+根据脂肪值排序

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans=0;
struct bzyq{
    int a,b;
}
s[470];//用结构体排序好排
int x[470];
bool cmp(bzyq i,bzyq j)
{
    return i.a>j.a;//根据脂肪值排序
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)
     cin>>x[i];
    for(int i=1;i<=n;i++)
     cin>>s[i].a>>s[i].b;
    sort(s+1,s+n+1,cmp);
    int i=1;
    while(m&&i<=n)//m得>0
    {
        if(x[s[i].b]>0)
        {
          ans+=s[i].a;//累计脂肪值
          m--;//m去掉1，吃的分数－1
          x[s[i].b]--;//x数组表示能吃的第s[i].b种食品分数减一
        }
        i++;
    }
    cout<<ans;
    return 0;
    //~~华丽的结束~~
}
```


---

## 作者：Scarlet_Lightning (赞：1)

## 首先讲一下思路：
这题的坑主要在题面上**“表示可以吃1到k类食品的最大份数”**这句话的理解问题（反正我是第一次就看懂了）。这句话的意思是指这一行第$i$个数表示的是第$i$类食品**所能吃的最大数量**，比如说这一行第$2$个数是$4$，那么表示的是第$2$种食物最多可以吃$4$份，而不是第$2$种食品只有$4$份。

理解完题面之后，我们显然易见的就会想到**贪心**，把脂肪排个序，在总份数和类型最大份数可以支持的情况下尽可能地吃高脂肪食物。

----------------------------------------------------华丽的分割线----------------------------------------------------

**最近这几天，学习了我大C Plus Plus 的Standing Template Library（就是STL）大法。结果翻书的时候发现了set<-这个东东**



### 介绍一下set:

set这种东西里面的元素一定是排好序且无重复的。并且你可以使用迭代器（~~这么水的Problem谈这么深奥干嘛~~）遍历set。

- 定义 
```cpp
#include<set>
using namespace std;
set<int> s;//建立一个储存int整型的名为s的set
```
- 基本操作（本题中用到的）
```cpp
s.insert(n)//往s中插入元素n（自动排序）
s.begin()//返回s中第一个元素的地址
s.end()//返回s中最后一个元素的地址
```

既然有这么神奇的东东，我突（xian）发（de）奇（dan）想（teng），发现可以用**set里面的元素一定是排好序的**这个神奇的特性，来代替贪心里面的排序。

·前·

·方·

·字·

·体·

·突·

·然·

·变·

·大·

·预·

·警·
# 然后我就这样爆炸了！！！

原来set中的元素是不能重复的，哪怕是结构体中的变量重复也不行（这样相同类型的食物就会被忽略）。上网一搜，又发现了**multiset**这个神奇的东东，**multiset**与set差不多，只不过里面的元素可以重复（这不就是我想要的东西吗哈哈哈）

上代码（**蒟蒻勿看，小心刺伤心灵**）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;
typedef long long ll;
int n,m,k,ans=0;
int Max[501];
struct Food{
    ll fat;//脂肪
    ll type;
    inline bool operator < (const Food f)const{//运算符重载，不懂的百度
		return this->fat>f.fat;
	}//注意，这里必须重载<运算符，不然CECECECECECE
};
multiset<Food> food;//multiset
template<typename T>T read(){//非常朴素的快读（加了个模版而已）
    T x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
int main()
{
    n=read<int>();m=read<int>();k=read<int>();//读入
    for(int i=1;i<=k;++i){
        Max[i]=read<int>();//还是读入
    } 
    for(int i=1;i<=n;++i){
        food.insert((Food){read<ll>(),read<ll>()});//调用insert()成员函数存储信息
    }
    multiset<Food>::iterator it;//创建一个指向multiset<Food>类的迭代器
    it=food.begin();
    while(m>0&&it!=food.end()){//如果还能吃且食物未扫描玩
        if(Max[(*it).type]>0&&m>0){//如果这种食物还可以吃，那么吃（废话）
            Max[(*it).type]--;//能吃的数量相应--
            m--;
            ans+=(*it).fat;
        }
        it++;
    }
    cout<<ans<<endl;//输出
    return 0;
}
```

---

## 作者：LOVEMY (赞：1)

其实很简单,就是排序加跟踪排序  
13~17行输入.  
18~30行排序.(快排)  
31~40行判断(模拟)
44行输出.  
所以废话不多说,给代码了:  
代码上有解释
```
#include<iostream>
using namespace std;
int n,m,k,a[10010],b[10010];  
int main()
{
	cin>>n>>m>>k;
	int i,j,t;
	int karr[10010],sum=0,s=0;
	for(i=1;i<=k;i++)
	cin>>karr[i];
	for(i=1;i<=n;i++)
	cin>>a[i]>>b[i];
	for(i=1;i<=n-1;i++)
	for(j=1;j<=n-i;j++)
	{
		if(a[j]<a[j+1])
		{
			t=a[j];
			a[j]=a[j+1];
			a[j+1]=t;//排序
			t=b[j];
			b[j]=b[j+1];
		   b[j+1]=t;//追踪
		 }
	}
	for(i=1;i<=n;i++)
	{
		if(karr[b[i]]<=0)
		continue;
		sum+=a[i];
		karr[b[i]]--;
		s++;//如果karr[i]<=0,则sum+=a[i];
		if(s>=m)
		break;
	}
	cout<<sum;//输出sum
	return 0;//亲爱的程序君安息吧^_^
	}
```

---

## 作者：songhn (赞：1)

这道题其实就很简单的排序+贪心，关键是理解题目上可能会有问题，我用一个结构体来存储a,b的值（萌新第一次写题，代码不足还请包涵）

```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;
struct node            //声明结构体 
{
    int a,b;
}s[210];
inline bool operator<(const node&p1,const node&p2) //结构体按照脂肪大小升序排序 
{
    return p1.a<p2.a;
}
int main()
{
    //ios::sync_with_stdio(false); 可以提速 
    int n,m,k,num[110],pan[110]={0},ok=1,ans=0; //num数组存储每类最多吃的数字 pan数组用来判断是否已经临界 
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)  //随便读入 
        cin>>num[i];
    for(int i=1;i<=n;i++)
        cin>>s[i].a>>s[i].b;
    sort(s+1,s+1+n);
    for(int i=n;i>=1;i--)  
    {
        if(ok<=m) //判断是否不能再吃 
        {
            if(pan[s[i].b]<num[s[i].b])//临界判断 
            {
                ans+=s[i].a;           
                ok++;pan[s[i].b]++;
            }
        }
        else
        break;
    }
    cout<<ans<<endl;
    return 0;
} 
```

---

## 作者：chaijing (赞：1)

这道题需要先把脂肪排个序，其实分组就是个模拟而已

```cpp
//9.营养膳食 
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int ma[101];
struct chai
{
    int z,b;
}a[201];
int comp(const chai &c,const chai &d)
{
    if(c.z>d.z) return 1;
    return 0;
}
int main()
{
    int n,m,k,i,j,tot=0;
    cin>>n>>m>>k;
    for(i=1;i<=k;i++)
      cin>>ma[i];   //ma用于记录每类食品最多吃多少
    for(i=1;i<=n;i++)
      cin>>a[i].z>>a[i].b;   //z为脂肪，b为分组号
    sort(a+1,a+n+1,comp);  //以上是输入＋脂肪排序
    for(i=1;i<=n;i++)
    {
        if(m>0&&ma[a[i].b]>0)
        {
            tot+=a[i].z;
            ma[a[i].b]--;   
            m--;  //模拟过程
        }
        if(!m) break;
    }      
    cout<<tot;
    return 0;
}
```

---

## 作者：清风我已逝 (赞：0)

无脑排序

贪心从大到小啦

奉上代码：

```cpp
#include<bits/stdc++.h>

using namespace std;
int n,m,k,limit[205],ans,w[205],tot;
inline bool ccmp(int x,int y){
	return x>y;
}
struct Node{
	int tot,b[205];
	void cmp(){
		sort(b+1,b+1+tot,ccmp);//成员函数 
	}
}a[205];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++) cin>>limit[i];
	for(int i=1;i<=n;i++){
		int w,j;
		cin>>w>>j;
		a[j].b[++a[j].tot]=w;
	}
	for(int i=1;i<=k;i++) a[i].cmp();//排序 
	for(int i=1;i<=k;i++){
		for(int j=1;j<=limit[i]&&j<=a[i].tot;j++){
			w[++tot]=a[i].b[j];//添加元素 
		}
	}
	sort(w+1,w+1+n,ccmp);//最终调整 
	for(int i=1;i<=m;i++) ans+=w[i];//记录 
	cout<<ans;
	return 0;
}
```

---


# 【深基12.例1】部分背包问题

## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

## 样例 #1

### 输入

```
4 50
10 60
20 100
30 120
15 45
```

### 输出

```
240.00```

# 题解

## 作者：dingcx (赞：1148)

~~这道题不是贪心吗？为什么题目是背包？~~
## 思路
千万不要被题目给误导了，这道题是贪心。

所有金币都可以分开，也就是说只要按照性价比最高的取一定得到的价值最大。

性价比就是这堆金币的价值除以重量。

只需要把这$n$堆金币按性价比排序就行了。

然后依次遍历，如果背包中剩余可以拿的重量大于等于这堆金币的重量，就全拿，否则直接装满。

直接装满这里注意一下整型转浮点的细节就好了。
## 代码
这道题没什么细节，也比较简单，就直接放代码——

（~~我知道你们只看这里~~）
```cpp
#include<cstdio>
#include<algorithm>//用到sort
using namespace std;
struct Node{//金币结构体
	int w,v;//w表示重量，v表示价值
}a[110];
int read(){//普通的快读，不解释
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
bool cmp(Node aa,Node bb){//定义排序方法
	return aa.v*bb.w>aa.w*bb.v;//按性价比从高到低排序，为防止精度问题直接交叉相乘
}
int main(){//主函数
	int n=read(),m=read();
	double ans=0;//记录答案
	for(int i=1;i<=n;i++) a[i].w=read(),a[i].v=read();
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++){//一次遍历
		if(a[i].w<=m) ans+=a[i].v,m-=a[i].w;//够就全拿
		else{//不够
			ans+=a[i].v*m*1.0/(a[i].w*1.0);//拿上能拿的部分，注意强转double
			break;//直接退出循环
		}
	}
	printf("%.2lf",ans);//保留2位小数
	return 0;//华丽结束
}
```
看我在比赛刚刚结束就发了一篇题解，总得点个赞再走呀~

---

## 作者：樱雪喵 (赞：571)

为不会结构体的同学们发篇福利题解qwq!

看到这题目的时候我还以为是背包呢...

其实这是一道贪心。

因为金币可以分割，所以优先取性价比最高的，直到装满背包一定就是最优解。

(因为我不会用结构体，所以写的冒泡排序）

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n;//有n堆金币
double t,v[101],w[101],a[101],ans;//t:背包容量 v：价值 w:重量 a:性价比 ans:答案
int main()
{
	cin>>n>>t;//读入
	for(int i=1;i<=n;i++)
	{
		cin>>w[i]>>v[i];
		a[i]=v[i]/w[i];//求性价比
	}
	for(int i=1;i<=n;i++)//冒泡排序
	{
		for(int j=1;j<n;j++) 
		{
			if(a[j]<a[j+1])
			{
				swap(a[j],a[j+1]);
				swap(v[j],v[j+1]);
				swap(w[j],w[j+1]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(t-w[i]>-0.000001)//浮点数不能相等
		{
			t-=w[i];
			ans+=v[i];
		}
		else
		{
			ans+=t*a[i];//把金币分割
			break;//跳出循环
		}
 	}
 	printf("%.2lf",ans);//保留两位小数输出
 	return 0;//完美结束
}
```

点个赞再走嘛QwQ~~

---

## 作者：hanxin (赞：115)

# 一道简单的题
本蒟蒻在比赛时被标题所迷惑，想了半天dp，毫无进展，最终才发现，这就是个贪心，贪法也很好想

### code:
```
#include<bits/stdc++.h>
using namespace std;
struct node{//定义结构体 
    double w;//重量 
    double v;//价值 
    double p;//性价比 
}a[105];
int n;
double sum,c;
inline bool cmp(node a,node b){
    return a.p >b.p;//性价比从大到小排序 
}
int main(){
    cin>>n>>c;
    for(register int i=1;i<=n;++i){
        cin>>a[i].w>>a[i].v;
        a[i].p=a[i].v/a[i].w;//性价比=价格/重量 
    }
    sort(a+1,a+n+1,cmp);//将性价比排序 
    for(register int i=1;i<=n;++i){
        if(c>=a[i].w){//金币的重量小于或等于背包的承重量
            c-=a[i].w;//装上该堆金币后背包的剩余承重量 
            sum+=a[i].v;//金币的价值 
        }
		else{
            sum+=c*a[i].p;//如果装不下就分割金币 
            break;
        }
    }
    printf("%.2f",sum);//保留小数点后两位输出
	return 0; 
}

```
### 修改日志:

2020-02-04 22:21 题解通过审核
2020-02-05 10:32 本蒟蒻发现有字打错，重新审核

---

## 作者：CSP_Sept (赞：46)

## 思路

按性价比从大到小排序，再挨个装包，直到装不下为止。

开一个结构体`gold`来存储 $m,v$，使用自定义比较函数和sort来进行排序。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
struct gold{
	int m,v;//m is the weight,v is the money.
};
bool cmp(gold a,gold b){
	return a.v*b.m>b.v*a.m;
}
inline int read(){
	char c;
	bool flag=false;
	while((c=getchar())<'0'||c>'9')
	    if(c=='-') flag=true;
	int res=c-'0';
	while((c=getchar())>='0'&&c<='9')
	    res=(res<<3)+(res<<1)+c-'0';
	return flag? -res:res;
}
gold a[110];
int main(){
	int n=read(),t=read();
	float coin=0;
	for(int i=0;i<n;i++){
		a[i].m=read();a[i].v=read();
	}
	sort(a,a+n,cmp);
	int i;
	for(i=0;i<n;i++){
		if(t<a[i].m) break;
		coin+=a[i].v;
		t-=a[i].m;
	}
	if(i<n) coin+=1.0*t*a[i].v/a[i].m;
	printf("%.2lf",coin);
	return 0;
}
```
## 分析

$1.$
```cpp
inline int read(){
	char c;
	bool flag=false;
	while((c=getchar())<'0'||c>'9')//排除杂项
	    if(c=='-') flag=true;
	int res=c-'0';
	while((c=getchar())>='0'&&c<='9')
	    res=(res<<3)+(res<<1)+c-'0';
	return flag? -res:res;
}
```
`快读`：~~快了1ms~~

$2.$ `return a.v*b.m>b.v*a.m;`

本来应该是 $a.v\div a.m>b.v\div b.m$，

证明：$\because x\div y=z$ 代表 $x=z\times y,$

$\therefore a.v\div a.m>b.v\div b.m$
             
$\;\;\;\;\;\;\;\;\;\;\;\;\;\;a.v>b.v\div b.m\times a.m$

$\;\;\;\;\;a.v\times b.m>b.v\times a.m$

这样，可以避免出现浮点数，增加精确度。

$3.$ `if(i<n) coin+=1.0*t*a[i].v/a[i].m;`

若 $i<n$  ,则将背包的剩余容量$(t)$全装满第 $i$ 种金币，加上金币的价钱$(t\times$单价$(\dfrac{m_i}{v_i}))$。
## end
$\mathtt{This\;is\;the\;end,thank\;for\;reading!}$

---

## 作者：Ryo_Yamada (赞：36)

这是一道非常经典的可拆分背包问题，也是最基础的，基本不用什么技巧。主要就是排序后计算就好了。新手建议刷一下这题后再刷别的复杂一点的。

因为本题基本没有技巧，直接上代码：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
struct Item {
    int c, w;
};//定义结构体，c代表价值，w代表重量
Item item[1010];
bool cmp(Item a, Item b){
    return a.w * b.c > b.w * a.c;
}//排序函数，说白了就是比性价比
int main() {
    int N, V;
    cin >> N >> V;
    for (int i = 1; i <= N; i++) {
        cin >> item[i].c >> item[i].w;
    }
    sort(item + 1, item + N + 1, cmp);//输入后排序
    double ans = 0;
    for(int i=1; i<=N; i++){
        if(V <= item[i].c){
            ans += (double)item[i].w / item[i].c * V;//因为上面结构体定义的w是int不是double，前面一定加(double)或1.0 * 。
            V = 0;
            break;//如果背包容量不够放下所有这种金币，就把背包装满，然后break。
        }
        else{
            ans += item[i].w;
            V -= item[i].c;
        }//够的话全装进去
    }
    printf("%.2lf", ans);//保留2位小数输出
    return 0;
}
```


---

## 作者：rainygame (赞：28)

> 前言：本题正解做法为贪心，此题解中的做法仅供学习参考，并非本题严格意义上的最优做法。

这道题好像所有人的思路都是贪心，甚至连题目标签都只有“贪心”，这对得起这个标题吗，对得起这个“普及/提高-”的难度标签吗？！（doge）

认真学过背包的童鞋们都知道，这道题其实可以使用[多重背包](https://oi-wiki.org/dp/knapsack/)来解决。我们可以把 $m_i$ 看成数量，把 $\dfrac{v_i}{m_i}$ 看成价值，而重量恒为 $1$。然后再套一下多重背包模板，这个题目就愉快的解决了！

多重背包的模板如下：

```cpp
for (int i=1; i<=n; i++){
    for (int j=v; j>=1; j--){
	    for (int k=1; k<=min(m[i], j/w[i]); k++) f[j]=max(f[j], f[j-k*w[i]]+k*s[i]);
    }
}
```

（注：其中 `v` 代表背包最大承重，`w[i]` 代表第 $i$ 件物品的重量，`s[i]` 表示价值，`m[i]` 表示该物品的最大选取数量）

可能还有一些童鞋看了 OI-Wiki 的解释后还表示不理解，那我还是讲一下吧（如果你认为你懂了，可以跳过）：

首先前面的两行 `for` 语句是 01背包 的，但是第 $3$ 行语句就有意思了，第三行语句的 $k$ 枚举的是每个物品取的数量，它的枚举边界为 $\max\{m_i,\dfrac{j}{w_i}\}$，因为最最最大也不能超过背包的承受量或者最多可以选择的数量。而后面的 `f[j] = max(f[j], f[j-k*w[i]]+k*s[i]` 则为 01背包 的状态转移方程的变形，其实也就是取 $k$ 个数所造成的影响。

那就 Ctrl+C 和 Ctrl+V 一下，改一下具体的数值，就变成下面这样了：

```cpp
for (int i=1; i<=n; i++){
    for (int j=t; j>=1; j--){
	     for (int k=1; k<=min(m[i], j); k++) f[j] = max(f[j], f[j-k]+k*c[i]);
    }
}
```
（注：其中 `t` 为重量，`c[i] = v[i] / m[i]`，也就是价值）

**注意：上面的 `f` 数组必须开 `float` 或 `double`，因为它算出来的可能是浮点数！**

那么最后把 **AC** 代码贴上吧，**仅作为参考**：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 101

int n, t;
int m[MAXN], v[MAXN];
double c[MAXN], f[1001];

int main(){
	cin >> n >> t;
	for (int i=1; i<=n; i++){
		cin >> m[i] >> v[i];
		c[i] = (double)v[i] / m[i];  // 注意不是double(v[i]/m[i])
	}

	for (int i=1; i<=n; i++){  // 套模板
		for (int j=t; j>=1; j--){
			    for (int k=1; k<=min(m[i], j); k++) f[j] = max(f[j], f[j-k]+k*c[i]);
		}
	}

	printf("%.2lf", f[t]);  // 如果你用的是float的话，请使用%.2f

	return 0;
}

```

上面代码的时间复杂度为 $O(nT \times \max\limits_{i=1}^nm_i)$。


---


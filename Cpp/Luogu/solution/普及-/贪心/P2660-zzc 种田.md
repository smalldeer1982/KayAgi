# zzc 种田

## 题目背景

可能以后 zzc 就去种田了。


## 题目描述

田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。

## 说明/提示

$1\le x,y\le 10^{16}$。

## 样例 #1

### 输入

```
1 10```

### 输出

```
40```

## 样例 #2

### 输入

```
2 2 ```

### 输出

```
8```

# 题解

## 作者：北海_Beihai (赞：86)

一个数学迭代，类似于GCD。

具体详见代码和注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long x,y,ans=0;
    cin>>x>>y;
    while(x&&y){                          //如果x,y中有一个为0，就结束了
                swap(x,y);                        //交换x和y，为什么？马上就知道了
                ans+=4*y*(x/y);              //种完剩下的所有最大的正方形。很像GCD是不是？
                x%=y;                             //然后x就只剩下x%y了，因为x%y<y，所以之前需要交换
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Zerosking (赞：52)

### 这题本蒟蒻因为刚学了递归，强行用递归过了

~~同机房的大佬说不可能用递归过，现在他要啃键盘了哈哈哈~~



------------正文分割线

------------





其实这道题用循环很容易的，用递归的话代码量会大一点点。但是毕竟这道题有递归的标签，而且题解也没有人发递归，于是就有了这篇题解。



思想是贪心，递归不多说了，直接上代码。
```cpp
#include<iostream>
using namespace std;
long long sum=0;              					//利用全局变量统计使用的力气
void kkk(long long x,long long y)    			 				 	 			//递归函数部分（请忽略这个鬼畜的函数名）   x，y分别代表矩形的长和宽
{
    long long minn,maxn;						//maxn,mann分别代表x，y中较长边和较短边，便于贪心
    if(x==y)
    {
        sum+=x*4;
        return;
    }									//递归边界1：x与y相等，即剩下的是个正方形，可以一次犁完；return结束递归
    else
    {
        minn=x<y?x:y;
        maxn=x>y?x:y;
        sum+=minn*4;
        kkk(minn,maxn-minn);			//这里就是调用递归了，先确定maxn和minn，然后以较小边为正方形的边犁完一块田（贪心），剩下的maxn变为maxn-minn，递归
    }
}
int main()
{
    long long x,y;
    cin>>x>>y;
    kkk(x,y);
    cout<<sum;
}										//主函数部分简单 
```



------------
然而满怀期待地交上去。。。

![](https://cdn.luogu.com.cn/upload/pic/25658.png)


？？？MLE是什么鬼？

好吧真的是超空间了。（~~此时一旁的大佬立下flag：都说了过不了吧，过了我啃键盘/滑稽~~）

问题在于，每次递归都要调用出几个long long，如果遇到很~~恶心~~强大的数据，
例如 10000000000 1 之类的，调用的次数为maxn/minn，也就是10000000000次，自然也就爆空间了。



------------冥思苦想分割线

嗯。其实算法还是没多大问题的，但对于一些特殊的数据，我们还是挂了。那能不能，专门对这种数据进行优化呢？这种数据的特点就是 重复调用 。于是开始上优化代码
```cpp
#include<iostream>
using namespace std;
long long sum=0;
void kkk(long long x,long long y)
{
	long long minn,maxn;
	if(x==y)
	{
		sum+=x*4;
		return;
	}
	else
	{
		minn=x<y?x:y;
		maxn=x>y?x:y;						//到这里一直是一样的 
		sum+=minn*4*(maxn/minn);    		//注意，这里多加了一个maxn/minn！整除运算的性质是向下取整，在题目当中就是重复把边长为minn的正方形犁完。
		if(maxn%minn==0)					//递归边界2：如果maxn是minn的整数倍，那么重复犁几个相同的正方形就行了。 
			return;
		kkk(minn,maxn%minn);				//同时由—号改为%，求剩下的田的短边 
	}
}
int main()
{
	long long x,y;
	cin>>x>>y;
	kkk(x,y);
	cout<<sum;					
}
```

------------
完美AC~
![](https://cdn.luogu.com.cn/upload/pic/25661.png)

------------
蒟蒻第一次发题解，因为想让更多初学者听懂所有多扯了点。。。

求过啊~







---

## 作者：人间凡人 (赞：25)

这道题是一道**贪心**题，但是需要一些小小的优化。

首先，让我们来模拟一组数据：输入：$4\ \ \ 6$

第一步：切出一个边长为4的正方形 余下一块$2*4$的长方形  $ans=0+4*4=16$

第二步：切出一个边长为2的正方形 余下一块$2*2$的长方形  $ans=16+2*4=24$

第三步：切出一个边长为2的正方形 刚好切完了 $ans=24+2*4=32$

不难发现,每次都切一个边长为$min(x,y)$的正方形，然后将短的那一边减掉

这个边长，答案加上边长$*4$即可。直到x和y中有一个为0就结束。

$Code$:
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y,z,a,b,ans;
int main() {
	cin>>x>>y;
	while(x!=0&&y!=0){
		z=min(x,y);	//切一个边长为min(x,y)的正方形。
		ans+=4*z;
		if(x==z)y-=z;
		else if(y==z)x-=z;	//小的边减去边长。
	}
	printf("%d\n",ans);
	return 0;
}
```
**但是**  如果交上去后会发现只有30分。因为x与y有$10^{16}$大，这
样做会超时。

因此，我们想到一种优化的方案。

每次不要一个正方形一个正方形的切，可以一次切多个，也就是切$max(x,y)/min(x,y)$个。这样时间复杂度会大大减少。

话不多说，上代码！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,z,ans;
int main() {
	cin>>x>>y;
	while(x!=0&&y!=0){
		z=min(x,y);
		if(x==z)ans+=4*(y/z)*z,y%=z;
		else if(y==z)ans+=4*(x/z)*z,x%=z;
      		//一次性切下max(x,y)/min(x,y)个。
      		//不要忘了答案也要加max(x,y)/min(x,y)次！！！
	}
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：灵光一闪 (赞：10)

~~如果您A题心切请跳的代码环节~~

这题思路其实很简单，就是循环+判断+处理，可是呢
# 10^16  
的数据先坑了我一波``long long``，然后又是一片``TLE``

可怜了我的AC率啊！

~~lin_toto：AC率这玩意有个屁用~~//摘自lin本人

TLE后我第一个想到的就是：**优化**//事实证明优化就是这个结局：
![](https://cdn.luogu.com.cn/upload/pic/59884.png)

我：*****  （文明你我他

然后我就莫名想到了一个很？的问题：  
我的源码：
```
// luogu-judger-enable-o2
//#include<bits/stdc++.h>

#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<vector>
#include<string>
#include<cmath>
#include<map>

using namespace std;
int main()
{
    long long int ans=0;
    long long int n,m;
    cin>>n>>m;
    while(n&&m)
    {
        if(n==m)
        {
            ans+=n*4;
            break;
        }
        long long int num=min(n,m);
        long long int sum=max(n,m);
        ans+=num*4;
        sum-=num;
        n=sum;
        m=num;
    }
    cout<<ans;
    return 0;
}
```
我四不四撒，我为什么要一个个循环？？？？？？？？
然后我就写了这个代码：
```
// #include<bits/stdc++.h>

#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;

int main()
{
    long long int n,m;
    cin>>n>>m;
    long long int mx=max(n,m),mn=min(n,m);
    long long int ans;
    while(mx&&mn)
    {
        ans+=4*mn*(mx/mn);
        mx=mx%mn;
        n=mx;
        m=mn;
        mx=max(n,m);
        mn=min(n,m);
    }
    cout<<ans;
    return 0;
}
```
相信眼尖的同学已经看出来了！**你的ans初始化了么**
所以，在这里，我给同学们提一下提醒：
## 千万千万要初始化
## 看好数据范围！不要像我一样，打了个int就交上去了
蛤？源码？把ans初始化一下不就好了么？

最后，建议大家写完题后考虑把数据加强后的解法（~~没准就创了个算法了呢~~

The End.

---

## 作者：Trans_Portal (赞：8)

## 思路

本题的要点是：种田每次只能种正方形。

为了保证消耗体力最少，每次种田就必须选择种在可种范围内最大的正方形（就是以宽为变长的正方形），这点应该好理解。

### 然后这道题就可以近似地看成：“将大长方形割成多个小正方形，怎样割使小正方形最少。”
你需要做的就只是在割的时候把周长算出来相加而已。

------------
我用的方法类似于辗转相除法，由于题目规定了xy大小关系，所以不需要比较。
###### （题目中说x是长，但是所有数据都是x为宽。所以我直接默认x宽。）

我举的3×5例子（硬核）：
|1  | 1 |1  | 3 | 3 |
| -----------: | -----------: | -----------: | -----------: |-----------: |
| 1 |1  |1  | 2 | 2 |
| 1 |1  | 1 |2  |2  |
###### （数字代表第几次种的田）

第一次，种一片3×3的田，消耗1×4×3体力，之后整一个田可以看成2×3的田。

第二次，种一片2×2的田，消耗1×4×2体力，之后整一个田可以看成1×2的田。

第三次，种两片1×1的田，消耗2×4×1体力，田种完。

总共消耗28体力。
## 代码
```cpp
#include<iostream>
using namespace std;
long long x,y,ans;//题目中注明了1<=x,y<=10^16，要用long long，我在这坑上翻车过
int main(){
	cin>>x>>y;
	while(x>0){
		ans+=4*x*(y/x);//y/x是种田的数量
		long long t=x;
		x=y%x;//种剩下的作为下一次操作的宽
		y=t;//这次的宽作为下一次的长
	}
	cout<<ans;
    return 0;
}
```
------------
这道题还可以用递归做，这值得一试。~~因为我懒得写。~~

---

## 作者：hsfzLZH1 (赞：4)

考虑每个正方形对面积和周长的贡献：一个边长为N的正方形，对面积的贡献是N\*N，对周长的贡献是4\*N，所以我们应当尽量选择较大的N，使得最后的总周长最小。

不太严谨的证明：

考虑我们要覆盖一个N\*N的正方形，我们将所有覆盖方法的所有正方形边长都集中到一条边上（周长=边长\*4，所以不用考虑这些问题），如果不采用一个N\*N的正方形覆盖的情况，那么一定会覆盖完正方形的一条边而有重叠。所以用N\*N覆盖是最优的。其他情况以此类推。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long x,y,ans,t;
int main()
{
    scanf("%lld%lld",&x,&y);
    if(x<y)swap(x,y);
    while(x&&y)
    {
        if(x%y==0){ans+=x;break;}
        ans+=(x/y)*y;x%=y;swap(x,y);
    }
    printf("%lld\n",ans*4ll);
    return 0;
}
```
我们分成几个子问题，然后求解，类似于辗转相除法


---

## 作者：ztzshiwo001219 (赞：3)

一个比较简单的贪心,

设n<m 每次删除最大的正方形（即长度为n的正方形），直到m比n，也就是不能再删除一个长度为n的正方形了

这样一直递归,如果有一条边被删成0了，就结束递归

现在贴代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long LL;
LL n,m,ans;
int main()
{
    scanf("%lld%lld",&n,&m);
    while(n&&m)
    {
        if(n>m)swap(n,m);
        ans+=(m/n)*n*4;
        m=m%n;
    }
    printf("%lld\n",ans);
    return 0;
}
很简单吧
```

---

## 作者：Campione (赞：1)

作为一个刚刚上路没学贪心没学数论除了递归啥算法也没学的蒟蒻，就用循环来搞定啦！~~明明刚学完递归兴高采烈来找递归题，没想到最后还是没用递归写~~【滑稽

   __思路挺简单的，就是不断比较两个边的长，取出正方形。__ 
  
AC代码如下：
------------
 
```cpp
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long int x,y,s=0,maxn,min; 
    int bj=1;   //用以标记
    cin>>x>>y;
    
    //如果是正方形土地，就直接输出正方形的周长
    if(x==y)
	cout<<4*x;
   //如果不是，就反复分割长方形，寻找正方形，直到最后分割到只剩一个正方形
    else
	{
	 while(x!=y&&bj!=0){
	 maxn=(x>y?x:y);
	 min=(x>y?y:x);
	 x=maxn;       //x记录长边
	 y=min;       //y记录短边
	 if(x%y==0){
	 s+=4*x;bj=0;}
	 else{
	 	x-=x%y;
	 	s+=4*x;
	 	x=maxn-x;
	     }
     }cout<<s;
    }
}

```
**第一篇题解~！如果有错误或可以优化的地方请告诉蒟蒻嗷~非常感谢~！**

---

## 作者：蒟蒻lxy (赞：1)

# 一个递归题
## 思路：
	每次从剩下的矩形中取出最大的正方形，利用递归实现
    图在最下面（
## 代码+注释
```cpp
#include<bits/stdc++.h>
using namespace std；
long long x,y,ans;
void dg(long long x,long long y)//x为长，y为宽，这里设x>=y
{
	if(!x || !y)//等于0就停止
		return;
	if(x==1)//优化，当x或y等于1时，看图1
	{
		ans+=y*4;//周长累加
		return;//结束
	}
	if(y==1)//同上
	{
		ans+=x*4;
		return;
	}
    //最大正方形为y*y
	ans+=y*4*(x/y);//y*4是一个最大正方形的周长，x/y是最大正方形的个数
	x%=y;//剩下矩形的
	dg(y,x);//y肯定不会比x%y小，所以在前面
}
int main()
{
	cin >> x >> y;
	dg(max(x,y),min(x,y));//大的在前，小的在后
	cout << ans << endl;
	return 0;
}

```
~~完美地结束~~
### 图1：
![](https://cdn.luogu.com.cn/upload/pic/45803.png)

#### ps：

为什么要优化呢？因为第10个测试点太~~毒瘤~~大了



------------

管理员大大求过QAQ

---

## 作者：Bronya18C (赞：0)

# 数论，贪心。

我们先来看看怎么才能用最小的体力值，

体力值决定在周长，然后我们的问题变成了“用最小周长”，

周长有一个定律：

大正方形的周长小于等于若干个面积的和等于大正方形的小正方形的周长和（~~是不是晕了~~）

简单来说，每次减去目前最大的正方形会使周长和最小。

---

## 优化：

我们看到长和宽的大小就知道肯定会有100000000000000000 1这样的数据，所以我们要优化。

我们来看，假如a/b的商>1（向下取整），那么，下次耕的田会和这次一样。

所以我们每次要加4*b*（a/b）.

---

# 代码
```
#include<bits/stdc++.h>

using namespace std;
long long a,b,ans;
int main()
{
	cin>>a>>b;
	while(a!=0&&b!=0)
	{
		if(a>b)ans+=4*(a/b)*b,a-=b*(a/b);
		else ans+=4*(b/a)*a,b-=(b/a)*a;
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：封禁用户 (赞：0)

解题思路：如果要算出最小的体力消耗值，必须每次种田的面积都要是最大的；

因此每次zcc种田的面积就是还未种完的地中的最大的正方形的面积。

在此注明：由于按以上方法，zcc每种一块正方形的地，剩下的地都是长方形。

代码如下：

```cpp
#include<iostream>
using namespace std;
long long a,b,t;
int main()
{
    cin>>a>>b;//输入长方形的长与宽a，b。 
    if (a==b) {cout<<4*a; return 0;}//如果是一个正方形，直接输出它的边长就行了。 
    while (a!=b)
    {
        //求出剩余长方形中最大的正方形的周长，其实就是max(a,b)*4;
        if (a>b) {t+=b*4*(a/b);a=a%b;}
        if (a==0) break;
        if (b>a) {t+=a*4*(b/a);b=b%a;}
        if (b==0) break;
    }
    cout<<t;
    return 0;
}
```

---

## 作者：引领世界 (赞：0)

既然没人提出来，我就发个比楼下快一点点的题解。。。

基本思路是一样的，有点像我优化了一下。。

具体说明看码。

不喜勿喷。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

让路
————————————————————————————————————

代码上

————————————————————————————————————

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;//写着方便
ull a,b,s;
int main(void){
    cin>>a>>b;//用流读省事
    while (1){
        if (a>b)a^=b^=a^=b;//优化了的换ab值
        s+=(b/a)*a*4;
        b%=a;
        if (b==0)break;
    }
    cout<<s;//输出
}
```

---

## 作者：AdzearDisjudge (赞：0)

看神犇们发一些超时的题解

于是我来一发不超时的

核心思路看楼下

数据范围太大了（要用unsigned long long哦），您们不觉得一个个减很耗时？

所以……

万能的取膜【划掉

取模运算来了！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull a,b,s=0; 
int main()
{
    cin>>a>>b;
    for(;;)
    {
        if(a>b)
        {
            ull t;
            t=a;
            a=b;
            b=t;
        }
        s+=(b/a)*a*4;  //b/a：连续减了这么多次 a*4：每次消耗的体力
        b%=a;   //取模得到连减之后b还剩多少
        if(b==0)
        break;
    }
    cout<<s;
    return 0;
}
```

---

## 作者：FR_qwq (赞：0)

[这是题解](https://www.luogu.com.cn/problem/P2660)

这道题，我们可以这样做：

先判断谁大谁小，再将小的作为边，将大的div小的再乘小的的周长，在进行递归，以大的mod小的作为新的一条边，在与小的进行搭配，直到大的mod小的为0为止。

之所以不用减法，是因为这样会有两个点会被无情地MLE掉，不信你去试试，给你我的代码：
```pascal
var n,m:int64;
function f(x,y:int64):int64;
begin
f:=0;
if x=0 then exit;
if x>y then
  f:=f+y*4+f(x-y,y)
else
  f:=f+x*4+f(y-x,x);
end;
begin
readln(n,m);
writeln(f(n,m));
end.
```
好了，现在真正的AC代码出现！！！
```pascal
var n,m:int64;//不能用longint，不然会WA
function f(x,y:int64):int64;//这里也一样
begin
f:=0;//f得先赋初值为0
if x=0 then exit;//递归边界在这里
if x>y then
  f:=f+y*4*(x div y)+f(x mod y,y){上面说过的进行递归和计算}
else
  f:=f+x*4*(y div x)+f(y mod x,x);//同上
end;
begin
readln(n,m);
writeln(f(n,m));
end.//主程序很简单
```


---

## 作者：deamoon_2 (赞：0)

#### ~~本蒟蒻又来写题解了~~

看到题解区内好多人写什么辗转相除法，什么GCD，我来写一个递归。

根据题意，在一个n*m的矩阵中画正方形，且正方形的周长总和最小。

当然everyone know只要正方形少，周长自然小。

那么问题来了，怎样让正方形最少呢？

当然是正方形越大越好！

在n*m的矩阵中，能画最大的正方形就是边长为n的正方形。

然后减去所以边长为n的正方形，累积减去正方形的总边长，再算剩下的。

一直这样延续下去，就能得到答案。

数据是最大是10^16,别忘了long long哦~
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
long long smx(long long x,long long y)
{
	long long a,b;
	if(x==y)
	return x*4;
	else if(x>y)
	{
		a=x;
		b=y;
	}
	else if(y>x)
	{
		a=y;
		b=x;
	}
	if(a%b==0)
	return b*4*(a/b);
	else
	return b*4*(a/b)+smx(a-b*(a/b),b);
}
int main()
{
	long long n,m;
	cin>>n>>m;
	cout<<smx(n,m);
	return 0;
}
```
2019NOIP RP++

---


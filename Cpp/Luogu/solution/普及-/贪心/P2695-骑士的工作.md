# 骑士的工作

## 题目背景

你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。


## 题目描述

每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。


## 说明/提示

对于所有数据，$1 \le n,m \le 2 \times 10^4$，$1 \leq z_i \leq 10^5$。

## 样例 #1

### 输入

```
2 3
5 
4
7 
8
4```

### 输出

```
11```

# 题解

## 作者：做梦想Peach (赞：109)

**这题一看就是标准的贪心！！！将恶龙头的大小与骑士可以杀死的头的大小排序，然后一通乱搞**

**~~注意：you died!要感叹号，本人在此卡了半天。。。~~**
```cpp
#include <stdio.h>
#include <algorithm>//sort头
using namespace std;
inline int read () {//快读
	register int k=0;
	register char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') {k=k*10+c-'0';c=getchar();}
	return k;//返回读入的值
}
int main () {
	register int qs[20010],el[20010],m,n,i,ans=0;
	n=read();
	m=read();
	for (i=1;i<=n;i++) el[i]=read();//读入，不必多说
	for (i=1;i<=m;i++) qs[i]=read();
	sort (el+1,el+1+n);//排序
	sort (qs+1,qs+1+m);//排序
	if (n>m) {//如果恶龙数大于骑士的数量，则输出you died!
		printf ("you died!");
		return 0;
	}
	int j=1;
	for (i=1;i<=n;i++) {//枚举答案
		while (el[i]>qs[j]) j++;//找到最小一个大于该头的骑士
		ans+=qs[j];//累加答案
		if (j>m) break;
		j++;
	}
	if (i-1!=n) 
		printf ("you died!");//输出答案
	else
		printf ("%d\n",ans);
	return 0;//好轻松的呢！！！
}
```
谢谢观看，看我这辛苦，总得给个赞再走吧-_-

---

## 作者：唔啊唔 (赞：27)

这是一道特别水的贪心+排序题！

我说真的
```cpp
//有点慢请不要建议 
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100000],b[100000];
int main(){
		cin>>n>>m;
		int sum=0,q=0,p=1;					//sum为答案，p为a数组的序号，q为变量 
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1;i<=m;i++){
			cin>>b[i];
		}
		sort(a+1,a+1+n);					//从小到大排序 
		sort(b+1,b+1+m);
		for(int j=1;j<=m;j++){				//排士兵的序 
			if(b[j]>=a[p]){
				sum=sum+b[j];
		        p++;
			}
			if(p==n+1){						 
				q=1;						//可以砍完 
				break;						//结束循环
			}
		}
		if(q==1)cout<<sum<<endl;
		else puts("you died!");
		return 0;								//功德圆满 
}
```

---

## 作者：Atmizz (赞：17)

# 贪心+优先队列=AC！！
priority_queue科普一下~~

### 优先队列(priority queue)

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 (first in, largest out)的行为特征。通常采用堆数据结构来实现。
### 回归正题->
然后看这个题，我提供一个思路：我使用优先队列，输入龙头のsize和人可以杀的龙头のsize，然后加入优先队列，可以省略排序的一步哦！然后就开始比较，从小到大开始比较。
## 注意以下几点->


------------

1. 一开始输入，龙头大于人的数量，说明人打不过龙。
2. 当人空了，但是龙头还存在，那么也就可以结束了，说明人还是打不过龙。
3. 当目前的骑士打不过目前的龙头，那么就更新目前的骑士，让更厉害的人来打。


------------
### 上代码code->
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
priority_queue<int,vector<int>,greater<int> > l;//优先队列-龙的头
priority_queue<int,vector<int>,greater<int> > q;//优先队列-骑士 
int n,m;
int ans=0;//最终答案
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)//输入龙的头
    {
        int a;
        scanf("%d",&a);
        l.push(a);
    }
    for(int i=1;i<=m;i++)//输入骑士可以杀的龙头
    {
        int a;
        scanf("%d",&a);
        q.push(a);
    }
    if(n>m)//特判一下，龙的数大于骑士的数
    {
        cout<<"you died!";
        return 0;
    }

    while(!l.empty())//开始循环，如果还有龙的头没有消灭
    {
            if(q.empty() && !l.empty())//骑士都用完了，但是还有龙，说明没救了，就死了
        {
            cout<<"you died!";
            return 0;
        }
        if(l.top()<=q.top())//骑士可以杀龙
        {
            ans+=q.top();
            l.pop();//更新队列
            q.pop();
        }
        if(l.top()>q.top())//龙的头大于骑士，就换下一个，因为这是从小到大排序的，那么这个骑士就不可能击杀后面的龙了
            q.pop();
    }
        cout<<ans;//输出答案
    return 0;
}
```


---

## 作者：Dog_Two (赞：10)

看到各位都没用STL，来一发STL代码，能很大程度减少代码复杂度！

这一道题的思路还是挺好想的——消费和输出成绝对正比，那么我们就在达到目标输出的情况下，保证**浪费最小**就可以了。

所以我们的思路也就很明了了——

- 排序

- 对于每个头，找到一个能达到这个输出的花费最小的战士


需要注意的地方：

- 每个战士只能上场一次，所以需要一个bool数组判断，或者在计算后，修改战士的输出（如改成-1）

- 循环判断有效输出时，需要注意细节，否则可能会出现“错位”的情况


这个时候，C++的STL就可以帮我们大幅度简化代码，降低出错率。

以下注释的地方，就是我认为可以大幅度简化代码的地方——

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e4+10;
typedef vector<int>::iterator IT;
int n,m;
int ans;
int head[maxn];
vector<int>mon;
int main(){
    cin>>n>>m;
    mon.resize(m+10);
    //重新定义动态数组的大小，简化输入 
    for(int i=1;i<=n;i++) scanf("%d",&head[i]);
    for(int i=1;i<=m;i++) scanf("%d",&mon[i]);
    sort(head+1,head+n+1);
    sort(mon.begin(),mon.end());
    for(int i=1;i<=n;i++){
        IT pos=lower_bound(mon.begin(),mon.end(),head[i]);
        //返回第一个大于等于指定值的迭代器 
        if(pos==mon.end()){
            puts("you died!");
            return 0;
        }
        //直到数组中的最大值都没有足够输出 
        ans+=*pos; 
        mon.erase(pos);
        //直接删除指定位置的元素 
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：Suiseiseki (赞：7)

看了半天，没有这种思路的，我就来一发

先双排序，再双下标处理。

上代码：

```cpp
#include <cstdio>
int dg[20005],kill[20005];
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        scanf("%d",&dg[i]);
    }
    for(int i=0;i<m;i++){
        scanf("%d",&kill[i]);
    }
    sort(dg,dg+n);
    sort(kill,kill+m);//双排序
    int ans=0;
    int i=0,j=0;
    while(i<n&&j<m){//双下标
        if(dg[i]<=kill[j]){
            ans+=kill[j];
            i++,j++;
        }
        else{
            j++;
        }
    }
    if(i==n){
        printf("%d\n",ans);
    }
    else{
        printf("you died!\n");
    }
    return 0;
}
```
蒟蒻代码勿喷，望指教

---

## 作者：XianChanting (赞：3)

# 注意：
**一个**骑士最多只能砍**一个**脑袋（即龙头比骑士多时则输出 ```you died!```）

------------
# 上代码：
```cpp

#include<bits/stdc++.h>//luogu福音万能头 
#define N 2005
using namespace std;
inline int read() {
	register int x=0,f=1;//f判断正负 ，x存储答案
	register char ch=getchar();//先读一个
	while(ch<'0'||ch>'9') {//如果不是数字
		if(ch=='-')f=-1;//是'-'做负数标记
		ch=getchar();//继续读入（如果不是数字即结束，等待下一个数的读入，如果后面没有读入就停止）
	}
	while(ch>='0'&&ch<='9')
		x=x*10+ch-'0',ch=getchar();//累加
	return x*f; //处理负数情况（如果有）
}//快读 （结束自动读入下一个）
inline void write(register int x) {
	if(x<0) putchar('-'),x=-x;//负数处理
	if(x>9) write(x/10);//递归调用下一位数
	putchar(x%10+'0');//转末位
}//快输
int head[N],price[N];//head储存n个头的大小，price储存每个人可以砍的头大小和金币
int main() {
	register int i,j,sum=0;//sum记录后延了几个（优化，不用每次遍历）
	register int ans=0;//ans记录答案
	register int n=read();//n即头的个数
	register int m=read();//m即骑士团的人数
	for(i=0; i<n; ++i)
		head[i]=read();//读入头的大小
	for(i=0; i<m; ++i)
		price[i]=read();//骑士能砍的大小与金钱
	if(n>m)//特判
		putchar('y') ,putchar('o'),putchar('u'),putchar(' '),putchar('d'),putchar('i'),putchar('e'),putchar('d'),putchar('!');//等价于cout<<"you died!";
	else {
		sort(head,head+n);//sort大法好
		sort(price,price+m);//sort大法好
		for(i=0; i<n; ++i) {
			for(j=sum; j<m; ++j) {
				if(head[i]<=price[i+j]) {//可以杀死龙
					ans+=price[i+j];//花费增加
					break;//退出当前循环
				}
			} //枚举遍历
			sum=j;//更新sum
			if(m-sum<n) { //人手不够
				putchar('y') ,putchar('o'),putchar('u'),putchar(' '),putchar('d'),putchar('i'),putchar('e'),putchar('d'),putchar('!');
				return 0;
			}
		}
		write(ans);//输出
	}
	return 0;
}

```
~~_**The End**_~~

P.S. N 宏定义时要定义大一点（建议25005），否则全会RE

---

## 作者：R·Buffoon (赞：3)

这题跟[P2813 母舰](https://www.luogu.org/problem/P2813)很像，都是用到双排序

关于排序的方法有很多，如图所示![](https://s2.ax1x.com/2019/11/18/MyWY7j.jpg)


而在这个题目里，$O(n^2)$的排序方法明显会被T飞（可以吸$O_{2}$试试），所以需要更快的排序方法

作为一个$C++$选手，当然首选快速排序啦（$C++$福利，但是似乎会被卡成$O(n^2)$？）

接下来就是**代码**啦
~~~cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
	int aa=0;char cc=getchar();
	for(;!isdigit(cc);cc=getchar());
	for(;isdigit(cc);cc=getchar())aa=(aa<<1)+(aa<<3)+(cc&15);
	return aa;
}

const int N=23333;

int n,m;
int head[N],cost[N];
int ans=0;

int main()
{
    n=in(),m=in();
    for(RI i=1;i<=n;++i) head[i]=in();
    for(RI i=1;i<=m;++i) cost[i]=in();
    
    sort(head+1,head+1+n);sort(cost+1,cost+1+m);//两个排序，从小到大
    
    int j=1;//当前要砍第j个头
    for(RI i=1;i<=m;++i)//找骑士砍头
    {
    	if(cost[i]>=head[j]) ans+=cost[i],++j;//当第i个骑士可以砍掉第j个头的时候（注意是“>=”），加上该骑士的花费并++j
        if(j>n) break;//如果已经砍完n个头，就退出
    }
	
    if(j<=n) return puts("you died!") && 0;
    //j<=n，说明当前还有头要砍，但已经没有骑士可以砍掉这个头了，输出you died!，结束
    //注意是“<=”，因为j记录的是当前要砍的头
    
	
    cout<<ans<<endl;//输出花费
    
    return 0;//结束
}
~~~
~~希望更精彩的观感？使用[洛谷博客](https://www.luogu.org/blog/buffoon/solution-p2695)~~

---

## 作者：徐豪辰 (赞：2)

为了方便新手阅读，来水一篇题解

详情请参见《算法竞赛入门经典训练指南》1~2页

### 勇士斗恶龙（The Dragon of Loowater）Uva 11292

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;//名字空间
#define  maxn   1000005//宏定义
int a[maxn],b[maxn];

//a[]表示恶龙头的大小，b[]表示骑士的能力值
int n,m;//如题意

int main(){//愉快的主函数
    scanf("%d %d",&n,&m);//输入
    for(int i=0;i<n;i++)scanf("%d",&a[i]);//输入
    for(int i=0;i<m;i++)scanf("%d",&b[i]);//输入
    
    sort(a,a+n);//排序 O(logn)级别
    sort(b,b+m);
    
    int cur=0,cost=0;
    //cur表示头的编号，可以看做一个指针，cost代表花费
    for(int i=0;i<m;i++)if(b[i]>=a[cur]){
    cost+=b[i];
    if(++cur==n)break;
    }
    
    while(1){puts("233");}//防作弊程序
    
    if(cur < n)puts("you died!");//判断
    else printf("%d",cost);//愉快的输出
    
    return 0;//功德圆满
}
```
远离滥贴代码，共创美好洛谷

24ms   !!!

---

## 作者：封禁用户 (赞：2)

思路楼下都说了，就是贪心+双排序，我们对于每一个头，在可以杀掉这个头的人们找一个最小的就行了，不过我为了缩短时间用了并查集优化，这样就会直接在查找的时候跳过选过的人。

代码如下：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int daxiao[20001];//骑士
int daijia[20001];//头
int ints[20002];//并查集
int find(int n){
    if(ints[n]==n)return(n);
    return(ints[n]=find(ints[n]));
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(register int i=0;i<n;i++)scanf("%d",&daxiao[i]);
    for(register int i=0;i<m;i++)scanf("%d",&daijia[i]);
    for(register int i=0;i<=m+1;i++)ints[i]=i;
    sort(daxiao,daxiao+n);
    sort(daijia,daijia+m);//从小到大排序，优先找代价最小的
    int ans=0;
    for(register int i=0;i<n;i++){
        for(register int j=0;j<m;j=find(j+1)){
            if(daijia[j]>=daxiao[i]){
                ans+=daijia[j];
                ints[j]=find(j+1);//这个选过了，就用并查集把他连接到后面一个的后继上，这样下次查找的时候就会直接跳过这个骑士
                goto s;
            }
        }
        printf("you died!\n");//一个骑士都找不到，无解
        return(0);
        s:int dearcjr;
    }
    cout<<ans<<endl;
    return(0);
}
```

---

## 作者：HDX__龙皇 (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000001;
long long n,m,a[maxn],b[maxn],p=1,ans,flag;
int main()
{
	ios::sync_with_stdio(false);
	while(cin>>n>>m){
		ans=0,flag=0,p=1;
		if(n==0&&m==0)  break;
		for(int i=1;i<=n;i++)
		cin>>a[i];
		for(int i=1;i<=m;i++)
		cin>>b[i];      //输入
		sort(a+1,a+1+n);
		sort(b+1,b+1+m);//把数据排序
		for(int i=1;i<=m;i++){
			if(b[i]>=a[p]){
				ans+=b[i];
				p++;
				if(p==n+1){
					flag=1;
					break;
				}
			}
		}
		if(!flag)
			cout<<"you died"<<endl;
		else  
		cout<<ans<<endl;
	}
}
```

---

## 作者：qrsikno (赞：1)

贪心不解释

```cpp

#include<stdio.h>  
#include<algorithm>
using namespace std;
int A[20005],B[20005];
int main()  
{  
        int n,m,i;  
        scanf("%d%d",&n,&m);  
        for(i=0;i<n;i++)
          scanf("%d",&A[i]);
        for(i=0;i<m;i++)
          scanf("%d",&B[i]);
        sort(A,A+n);
        sort(B,B+m);
        int cur=0,cost=0;
        for(int i=0;i<m;i++)
          if(B[i]>=A[cur]){
              cost+=B[i];
              if(++cur==n) break;
          }
        if(cur<n) printf("you died!"); else printf("%d\n",cost);
        return 0;  
}  

```http://dev.luogu.org:8888/download/captcha


---

## 作者：量子物理 (赞：0)

```cpp
#include <bits/stdc++.h>//头文件，不解释
using namespace std;
const int N=20005;
int d[N], k[N];
void in(int &x){//快读
    char c=getchar();
    while (c<'0' || c>'9') c=getchar();
    for (x=0; c>='0' && c<='9'; c=getchar())
        x=x*10+c-'0';
}
int main(){
    int n, m;
    scanf("%d %d", &n, &m);  
    for (int i=0; i<n; i++) 
        in(d[i]);//scanf("%d",&d[i]);
    for (int i=0; i<m; i++) 
        in(k[i]);//scanf("%d",&k[i]);
    if (m<n) {
        printf("you died!\n");
        return 0;
    }
    sort(d, d+n);
    sort(k, k+m);
    int ans=0, i=0, j=0;
    while (i<n && j<m){
        if (k[j]>=d[i]) {
            ans+=k[j];  i++;
        }  
        j++;
    }
    if (i==n) 
        printf("%d\n",ans);
    else 
        printf("you died!\n");
    return 0;
}
```
一个简单贪心

---

## 作者：LCuter (赞：0)

# 排序+贪心，水一发用类做的题解

~~为什么我突然想到了陶陶摘苹果（升级版）~~

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
class MyClass{
	friend istream& operator>>(istream& ,MyClass& );//重载输入流，必须定义为友元函数
	private:
	    int Head_Sum;//头的个数
	    int Head_Size[20001];//头的大小
	    int Cavalier_Sum;//骑士个数
	    int Cavalier_Size[20001];//骑士大小
	    int Cost;//真实花费
	    int Cost_File;//花费存档，因为贪心时需要加花费，懒得减回去，于是多定义一个
	public:		
	    void Try();//贪心
}P2695;//蒟蒻类名
istream& operator>>(istream& in,MyClass& cl){
	cl.Cost=cl.Cost_File=0;//重置
	in>>cl.Head_Sum;
	in>>cl.Cavalier_Sum;
	for(int i=1;i<=cl.Head_Sum;i++){
		in>>cl.Head_Size[i];
	}
	for(int i=1;i<=cl.Cavalier_Sum;i++){
		in>>cl.Cavalier_Size[i];
	}
	return in;
}
void MyClass::Try(){
	int Flag=1,i,j;
    //排序，方便贪心
	sort(Head_Size+1,Head_Size+Head_Sum+1);
	sort(Cavalier_Size+1,Cavalier_Size+Cavalier_Sum+1);
	/*这里是调试区
	for(int i=1;i<=Head_Sum;i++){
		cout<<Head_Size[i]<<" ";
	}
	cout<<endl;
	for(int i=1;i<=Cavalier_Sum;i++){
		cout<<Cavalier_Size[i]<<" ";
	}
	cout<<endl;
	*/
    //开始贪心，因为已经排好序，所以从使用的数下一个开始贪心
	for(i=1;i<=Head_Sum;i++){
		for(j=Flag;j<=Cavalier_Sum;j++){
			if(Cavalier_Size[j]>=Head_Size[i]){
				Cost_File+=Cavalier_Size[j];
				Flag=j+1;
                if(i==Head_Sum){//如果贪心到目标，就给到真正的花费
                	Cost=Cost_File;
				}
				break;
			}
		}
	}
    //如果没有到目标，就输出你死了
	if(Cost==0){
		printf("you died!\n");
	}
	else{
		printf("%d",Cost);
	}
}
int main(){
    //主程序十分清爽
	cin>>P2695;
	P2695.Try();
	return 0;//结束
}
```

### 总结：一篇看似高深莫测实际水得要命的题解，只不过变量名取得~~比较好~~

---

## 作者：珅肐 (赞：0)

## 用到贪心和排序
主要思想就是：让浪费能力最少的砍
### 话不多说，代码有解释
###  如下：
```c
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,nn[20010],mm[20010];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)	cin>>nn[i];//nn[]存头的大小
	for(int i=1;i<=m;i++)	cin>>mm[i];//mm[]存勇士的能力
	sort(nn+1,nn+n+1);
	sort(mm+1,mm+m+1);//双排序后都是从小到大，保证当前的解是最优解
	int money=0,o=1;//o用来当指针，寻找只比当前的头大一点的战士
    //个人很喜欢o这个变量
	for(int i=1;i<=n;i++)
	{
		while(mm[o]<nn[i])
		{
			o++;
			if(o>m)//表示所有的勇士都出场了
			{
				cout<<"you died!";//不要忘记感叹号！
				return 0;
			}
		}
		money+=mm[o];//累加花费
        o++;//不管骑士有没有出场，o都要向后移，因为如果没出场，肯定是能力砍不下当前的头，又因为从小到大排序，以后的肯定也砍不下，o++就相当于跳过
	}
	cout<<money;//输出花费
	return 0;
}
```

---

## 作者：Sanction (赞：0)

呵呵，用优先队列来代替排序。比sort要快一点(吧)。
 
```cpp
#include <cmath>
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
priority_queue< int,vector<int>,greater<int> > tou;
priority_queue< int,vector<int>,greater<int> > qs;
//最小的头用最弱的骑士

int main()
{
	ios :: sync_with_stdio(false);
    //freopen("work.in","r",stdin);
    //freopen("work.out","w",stdout);
    int n,m,ans=0,flag;//flag用来做标记，
	cin>>n>>m;         //表示当前的头能否被砍掉。
	for(int i=1;i<=n;i++)
	{//读数据
		int x;
		cin>>x;
		tou.push(x);
	}
	for(int i=1;i<=m;i++)
	{//读数据
	    int x;
		cin>>x;
		qs.push(x);
	}
	int x,y;//x存头的大小，y存骑士的能力
	for(int i=1;i<=n;i++)
	{
	    x=tou.top();
	    flag=0;//“1”表示能砍掉，“0”表示不能，初始化
		while(qs.size()!=0)
		{
		    y=qs.top();
		    if(y >= x)
		    {//能砍掉
		        ans=ans+y;//先付款
			    tou.pop();
			    qs.pop();//------------
			    flag=1;//能砍掉要标记 |
				break;//              |-->无论怎样，骑士都要走
		    }//                       |
		   qs.pop();//-----------------
		}
		if(flag==0)
		{//连当前最小的头都搞不定，村长认命吧，QWQ
	        cout<<"you died!";
			return 0;
		}
	}
    cout<<ans<<endl;//最小花费
    return 0;
}//收工，白白

```

---

## 作者：NF_水饺 (赞：0)

一看到这道题果断想到贪心，理由：

费用和能力（能砍掉头大小）相等，意味着砍掉一个大小a的头花费至少为a

由于最后的花费要最小，所以骑士的费用要尽可能接近头的大小（差距尽量要小）

综上所述，这道题的正解（不知道有没有之一）就是贪心

具体思路如下：

**排序：对头大小和骑士能力/费用分别做排序**

原理：“小头小费用”原则，保证花费最小

**模拟：两个指针，一个指向头，一个指向骑士**
**看当前骑士能否解决当前的头，能的话均右移一位，同时计入费用；不能的话骑士指针右移一位**

原理：排序后保证从小到大，能解决必然是最优方案（费用最小）；不能解决就换更高级的骑士解决（有序保证越后的骑士能力越高）

**结算：所有骑士均被扫过而还有怪物的头剩余，无解**

原理：怪物的头太大，骑士砍不了（mmp的村长只能认命）
****
附上代码：
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,tot,p1,p2;
long long x[20000+10],a[20000+10],sum;
int main()
{
	p1=p2=1; //p1头指针，p2骑士指针
	cin>>n>>m;
	if(m<n) //特判
	{
		cout<<"you died!"<<endl;
		return 0;
	}
	tot=n; //tot怪物头数量（没用）
	for(int i=1;i<=n;i++) cin>>x[i];
	for(int i=1;i<=m;i++) cin>>a[i];
	sort(x+1,x+n+1);
	sort(a+1,a+m+1);
	while(p1<=n&&p2<=m)
	{
		if(!tot) break; //没头可以撤了
		if(a[p2]>=x[p1]) 
		{
			tot--;
			sum+=a[p2];
			p1++;
		}//打得过
		p2++;//无论打得打不过都得换（1骑士只能砍1个头）
	}
	if(tot) cout<<"you died!"<<endl; //砍不完的头
	else cout<<sum<<endl;
	return 0;
 } 
 ```

PS.解题小插曲：

**1.一开始我用for循环70分，发现骑士不管能否解决头指针都会右移，果断改while循环AC**

**2.一开始m小于n就直接gg了（注意一个骑士只能砍一个头），至于!tot和后面p2<=m效果一样，不过也懒得改了**

这就是本蒟蒻的解法（dalao勿喷，逃）






---

## 作者：北街的九命貓 (赞：0)

```cpp
#include <iostream>
#include <algorithm>
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
using namespace std; 
int main(int argc, char** argv) 
{
    int n,m,a[20005]={},b[20005]={},i,j,s=0,tmp=0,f=0;
    cin>>n>>m;
    for(i=1;i<=n;i++) //龙的直径数组
        cin>>a[i];
    for(i=1;i<=m;i++) //骑士能力数组
        cin>>b[i];
    if(n>m) //如果骑士比龙的数量小----tmp=1
       tmp=1; 
    else
    {
       sort(b+1,b+m+1); //把骑士的能力值排序一下
       for(i=1;i<=n;i++)
       { 
           for(j=1;j<=m;j++)
           {
               if(b[j]>=a[i]) //如果骑士能力值比龙要大
               {
                  s+=b[j];  //s计算金币
                  f=1;
                  b[j]=0; 
                  break;
               }
           }
           if(f==0)
           {
               tmp=1;
               break;
           }     
           f=0; 
       }
       if(tmp==0) 如果骑士的数量比龙大   也就是说tmp==1   输出金币        
             cout<<s;  
    }         
    if(tmp==1)  
       cout<<"you died!";
    return 0;
}

```

---

## 作者：梦在远方 (赞：0)

//第一次发题解，内心跟楼下一样激动

这个题就是贪心+排序，感觉题面不难理解

下面上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,m;
int a[100010],b[100010];
int ans=1,total=0,sum=1,t=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);//将龙头的大小由小到大排序 
    for(int i=1;i<=m;i++){
        cin>>b[i];
    }
    sort(b+1,b+m+1);//将骑士的大小由小到大排序 
    if(n>m)cout<<"you died!";//如果龙的个数大于骑士的个数直接输出you died!（注意叹号不要复制题面给的） 
    else{
        while(sum!=n+1){ //当龙没有砍完时 
            if(b[ans]>=a[sum]){
            total+=b[ans];
            ans++;
            sum++;//如果骑士能砍的头的大小大于或等于当前龙的头的大小，就让骑士砍当前这只龙的头并且换下一个骑士与下一头龙相比较（一个骑士只能砍一条龙） 
        }
        else ans++;//不能的话换下一个骑士 
        if(ans==m+1&&sum!=n+1){
            t=1;
            break; 
        }
        }
            if(t==1){
                cout<<"you died!";//当骑士用完但龙没有砍完时输出you died!
            }
            else cout<<total<<endl;//输出所需的最小花费 
    }
    return 0;
}
```

---

## 作者：leiron (赞：0)

//第一次发题解，心情激动

这题思路和楼上基本一样，只要找出对于每一个头money需求最小的骑士即可。

不过看到楼上用的基本上都是排序，准备用优先队列水一发。

代码如下

```cpp
#include<iostream>
using namespace std;
#include<queue>
#include<vector>
int n,m,ans;
priority\_queue<int,vector<int> ,greater<int> >a;//调整下优先级，让小的在前面
priority\_queue<int,vector<int> ,greater<int> >b;
int main()
{
    int t;cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>t;a.push(t);
    }
        for(int i=1;i<=m;i++)
    {
        cin>>t;b.push(t);
    }//输入
    while(!a.empty())//在头没砍完的情况下循环
    {
        if(b.empty()){
            cout<<"you died!";return 0;//勇士都gg了，died
        }
        int head=a.top();
        int s=b.top();//取出两队最小元素
        if(s>=head)
        {
            a.pop();
            b.pop();
            ans+=s;//勇士砍掉了头，弹出，付钱
        }
        else b.pop();//勇士太弱，下一位
        
    }
    cout<<ans;
    return 0;
}

---

## 作者：fletmer (赞：0)

#贪心+排序，还是蛮水的

```cpp
#include <cstdio>//头文件
#include <cstring>
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;
#define mem(x) memset(x,0,sizeof(x));//宏定义数组初始化
int m[20001],n[20001];//m(所能KO的头的大小) n(每个头的大小)
int hs,ener,cnt;//头的个数,人的个数,总花费
int t[20001];//标记数组，标记该头是否已被KO
bool com(int a,int b){//降序排列
    return a>=b;
}
int main(){
    mem(m); mem(n); mem(t);//初始化
    cin>>hs>>ener;//读入不解释
    for(int i=1;i<=hs;i++) cin>>n[i];//n个头的大小 
    for(int i=1;i<=ener;i++) cin>>m[i];//m个人
    sort(n+1,n+hs+1,com);//将头的大小从大到小排列
    sort(m+1,m+ener+1);//将每个骑士所能杀的头大小从小到大排列
    int tt=hs;//中间变量防止变量紊乱
    for(int i=1;i<=ener;i++){
        for(int j=1;j<=hs;j++){
            if(!t[j]&&m[i]>=n[j]){//当前头未被砍掉且有骑士能将其砍掉
                t[j]=1;//已被砍掉
                cnt+=m[i];//加上花费
                tt--;//头数-1
                break;//每个骑士只能看一个头
            }
        }
    }
    if(!tt) cout<<cnt;//如果头被砍完则输出总花费
    else cout<<"you died!";//未被砍完。。
    return 0;
}
```

---

## 作者：shadowice1984 (赞：0)

思路很简单，就是贪心~

神犇都用的排序

蒟蒻懒得手写了。

用的是最大值和最小值；

先检测头中的最大值；

再检测能杀这个头的最小值；

杀完之后勇士和头全部设成-1；这样就不会被选中了。

    
        
            
```cpp
#include<stdio.h>
using namespace std;
int n;int m;int head[20001];int cost[20001];
int maxnum=20001;int minnum=20001;int res=0;//不存在的点，存放max和min的初始值
int main()
{   
    cost[20001]=999999;head[20001]=-1;//初始化。
    scanf("%d%d",&n,&m);
    if(n>m)//特判。
    {
        printf("you died!");
        return 0;
    }
    for(int i=0;i<n;i++)
    {
        scanf("%d",&head[i]);
    }
    for(int i=0;i<m;i++)
    {
        scanf("%d",&cost[i]);
    }
    while(1)//死循环，直到满足出来的条件用return结束整个程序
    {
        for(int i=0;i<n;i++)
        {
            if(head[maxnum]<head[i])
            {
              maxnum=i;
            }
        }    
        if(maxnum==20001)
        {
            printf("%d",res-999999);//头全部被砍光
            return 0;//拜拜程序~
        }
        for(int i=0;i<m;i++)
        {
            if(head[maxnum]<=cost[i])
            {   
                if(cost[minnum]>cost[i])minnum=i;
            }
        } 
        if(minnum==20001)
        {
                printf("you died!");//没有符合条件勇士。
                return 0;//拜拜程序~
        }
        else
        {
                res+=cost[minnum];
                cost[minnum]=-1;
                head[maxnum]=-1;
        }
        maxnum=20001;
        minnum=20001;
    }
    return 0;
}
```

---

## 作者：cjoier_zouzhen1211 (赞：0)

这道题目是一道简单的贪心题，解题的主要思路是：首先排一遍序，然后再判断是否能将恶龙的头砍掉，如果可以就累加所需的金币；如果不能，就换下一个骑士......

**注意！！！

**无解时输出“you died!”（千万不要复制题面上的，感叹号是英文格式）.

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
int n,m;
int a[20001],b[20001];

int main(){
    scanf("%d%d",&n,&m);//输入 
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);//头的大小 
    }
    for(int i=1;i<=m;i++){
        scanf("%d",&b[i]);//每人可以砍的头的大小 
    }
    sort(a+1,a+n+1);//排序 
    sort(b+1,b+m+1);
    int ans=0;
    int i=1,j=1;
    while(i<=n&&j<=m){
        if(a[i]<=b[j]){//当头可以被砍掉 
            ans+=b[j];//累计所需金币 
            i++;
            j++;
        }
        else{
            j++;//向后枚举 
        }
    }
    if(i==n+1){
        printf("%d",ans);//输出结果 
    }
    else{
        printf("you died!");
    }
    return 0;
}
```

---

## 作者：fighter_OI (赞：0)

神犇
##排序+贪心＝=AC

水题一枚，让力量最小但没选中过且可以砍该头的Knight砍

代码附上：

```cpp
type arr=array[0..20000]of longint;
var a,d:arr;
n,m,i,p,ans:longint;
procedure qsort(l,r:longint;var a:arr);
var i,j,m,k:integer;
begin
    if l>=r then exit;
    m:=a[(l+r)div 2];
    i:=l;
    j:=r;
    repeat
        while a[i]<m do inc(i);
        while a[j]>m do dec(j);
        if i<=j then begin
                            k:=a[i];
                            a[i]:=a[j];
                            a[j]:=k;
                            inc(i);
                            dec(j);
                        end;
    until i>j;
    qsort(l,j,a);
    qsort(i,r,a)
end;
begin
    readln(n,m);
    for i:=1 to n do readln(d[i]);
    for i:=1 to m do readln(a[i]);
    if n>m then begin writeln('you died!');halt;end;
    qsort(1,n,d);
    qsort(1,m,a);
    ans:=0;
    p:=1;
    for i:=1 to n do
    begin
        while a[p]<d[i] do inc(p);
        ans:=ans+a[p];
        inc(p);
        if p>m then begin writeln('you died!');halt;end;
    end;
    writeln(ans);
    readln;
end .
```
请大家~~参考~~抄袭


---

## 作者：Checkmate (赞：0)

一道比较简单的贪心，主思路是——先排一遍序，然后从最小的比起，将骑士能砍的与龙头的大小比较，然后加上骑士能砍的头的大小即价格（特别注意的是：每个骑士只能砍一个龙头）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main () {
    int a[100000],b[100000],vis[100000];//a数组龙头的大小，b数组骑士能砍的大小，vis数组用于标记骑士是否已经砍过龙。
    int n,m,i,j,cost=0,k,l,s;
     scanf("%d %d",&n,&m);
         for(i=1;i<=n;i++)
             scanf("%d",&a[i]);
         for(i=1;i<=m;i++)
             scanf("%d",&b[i]);
         sort(a+1,a+1+n);//排序，找最优解。
         sort(b+1,b+1+m);
         for(i=1;i<=n;i++){
             k=0;  //k用于判断这颗龙头是否有解，用b[m]<a[i]会超时QwQ。
             for(j=1;j<=m;j++)
            {
                if(a[i]<=b[j]&&vis[j]==0)
                  {
                        cost+=b[j];vis[j]=1;k=1;break;//加上价格并标记，跳出循环。
                  }
             }
                if(k==0)//无解。
                 {
                     cout<<"you died!";return 0;//输出并结束。
                 }
    }
    cout<<cost;//输出应付的钱。
    return 0;
}
```

---


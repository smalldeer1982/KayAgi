# 在你窗外闪耀的星星

## 题目背景

飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。


这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。


毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。


再见了，我的公主！


如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。

## 题目描述

现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。


## 说明/提示

样例说明：


 ![](https://cdn.luogu.com.cn/upload/pic/3818.png) 

对于 $10\%$ 的数据，$W=0$（没有边缘）；

对于 $40\%$ 的数据，$W\leq 1000$；

对于 $100\%$ 的数据，$1 \leq N\leq 10 ^ 5$，$0 \leq W\leq 10 ^ 5$，$1 \leq X_i\leq 10 ^ 5$，$1\leq B_i\leq 100$。

除 $W=0$ 的情况外，$W$ 均为 $\geq 3$ 的奇数。


## 样例 #1

### 输入

```
6 3
1 2
2 4
3 8
4 4
5 2
1000 1```

### 输出

```
16```

# 题解

## 作者：紫妹只有17岁 (赞：115)

题目好甜啊……虽然是个女孩子可是还是被甜到了呢……~~（话说要是有这么个小哥哥追我就好了……）~~

↑以上为题解作者的幻想

下面开始正题

~~话说这题真的甜~~，这道题的题意就是给定一条数轴，我们把数轴简化为一个数组，然后求规定大小的区间内的最大和

一看到就是树状数组码码码

这里的添加星星的操作就对应树状数组的update操作，求区间最大值就对应树状数组的sum操作

### 顺便安利一下树状数组

# 树状数组

一听到有树就很牛逼对不对，其实树状数组是一种很接地气的数据结构，然后比线段树好码多了

树状数组一般有三种操作（算上lowbit）

#### 1.lowbit操作

也就是一层一层往下找的操作，然后具体为什么这么写请问度娘

[树状数组](https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin)

#### 2.update操作

也就是更新节点的值的操作，注意这里的更新指的是加上一个数，也就是如果要变为0那么就要update原数的相反数

#### 3.sum操作

也就是区间求和操作，当然这里的sum指的是从下标为1到下标为n进行求值，树状数组能够高效的求sum的原因就是因为有lowbit操作的存在

注意！前方丑能！

蒟蒻我自己用画图画的图

![](https://cdn.luogu.com.cn/upload/pic/39124.png)

初学树状数组的话，可以先写模板

[树状数组模板1](https://www.luogu.org/problemnew/show/P3374)

[树状数组模板2](https://www.luogu.org/problemnew/show/P3368)

然后巩固可以写写逆序对

[逆序对](https://www.luogu.org/problemnew/show/P1908)

[红色的幻想乡](https://www.luogu.org/problemnew/show/P3801)

然后给一发代码，代码中值得注意的地方是

1.区间求值的时候边界不要写错了……（咕了一次）

2.树状数组代码一定要记牢（咕了一次）


代码太过简单所以注释比较少
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int c[N];//树状数组，这道题只是区间求和，不用存星星，所以不用再开一个星星数组
int n;
int w;
int Max=-1;//等下区间求和的时候比较最大值用
int x,y,z;
int lowbit(int x)//lowbit操作
{
	return x&(-x);
}
void update(int x,int v)//update操作
{
	while(x<=n)
	{
		c[x]+=v;
		x+=lowbit(x);
	}
}
int sum(int x)//区间求和操作
{
	int res=0;
	while(x>0)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
int main()
{
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++)//读入
		scanf("%d%d",&x,&y),update(x,y);
	for(int i=w;i<=100000;i++)//因为这里不想写n，于是我写了100000
	{
		Max=max(Max,sum(i-1)-sum(i-w-1));//区间最大值
	}
	printf("%d\n",Max);//输出
	return 0;
}
```

---

## 作者：xzjds (赞：42)

没错，这是一眼就能看出是打前缀和的水题。但是我高兴的打完后却wa了。（10分）百思不得其解。后来才发现会有重点！！如果有好几个星星在同一个点上那么这个点的亮度是它们的亮度和。然后一遍跑过去就行了。sum[i]表示前i个点的星星亮度和。f[i]表示第i个点的亮度。
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000005],sum[1000005],n,m,x,y,ans,maxn;
int read()
{
	int x=0;char c;bool f;
	f=false;
	c=getchar();
	if (c=='-') f=true;
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	if (f==true) x=x*-1;
	return x;
}
struct mmp
{
	int x,y;
}a[100005];
bool cmp(mmp x,mmp y)
{
	return x.x<y.x;
}
int main()
{
	n=read();m=read();
	maxn=1;
	/*
	for (int i=1;i<=n;i++)
	{a[i].x=read();a[i].y=read();}
	sort(1+a,1+a+n,cmp);
	for (int i=1;i<=n;i++)*/
	for (int i=1;i<=n;i++)
	{
		x=read();y=read();
		f[x]+=y;
		maxn=max(maxn,x);
	}
	for (int i=1;i<=maxn;i++)
	sum[i]=sum[i-1]+f[i];
	ans=-1;
	for (int i=1;i<=maxn;i++)
	{
		ans=max(ans,sum[i]-sum[i-m]);
	}
	printf("%d",ans);
	return 0;
}
```
不用管a数组。。。刚开始以为要sort。。

---

## 作者：a155936453 (赞：40)

我看了一下题解，发现各位dalao没有用线段树写的，所以我果断水一发题解

这个题是可以用来当做线段树的训练题，运用线段树的单点修改和区间求和，对于题目为线性且初始化均为零，我们可以不用再进行建树操作，

直接在输入星星的横坐标和亮度时进行单点修改即可，然后用for扫一遍从1~10000的区间为m的和，从中取MAX即可，不过时间复杂度较高，各位dalao 见谅，还有就是第一个点w==0时，如果还用线段树会MLE，这个点直接输出零即可（无边缘）。

    
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int n,m,maxl;
int sum[4000010];
int a[400010],b[400010];
int read()
{
    int pp=0,ff=1;char ch;ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')ff=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){pp=pp*10+ch-'0';ch=getchar();}
    return pp*ff;
}
void pushup(int w)//由子节点修改父节点
{
    sum[w]=sum[w<<1]+sum[w<<1|1];
}
void build(int l,int r,int w)//这是建树不过该题没用，，懒得删
{
    if(l==r)
    {
        return ;
    }
    int m=(l+r)>>1;
    build(1,m,w<<1);
    build(m+1,r,w<<1|1);
    pushup(w);
}
void update(int q,int add,int l,int r,int w)//单点修改
{
    if(l==r)
    {
    sum[w]+=add;
    return ;
    }
    int m=(l+r)>>1;
    if(q<m) update(q,add,l,m,w<<1);
    else    update(q,add,m+1,r,w<<1|1); 
    pushup(w);
}
int queery(int L,int R,int l,int r,int w)//区间求和
{
    if(L<=l&&r<=R)
    {
        return sum[w];
    }
    int m=(l+r)>>1;
    int set=0;
    if(L<=m) set+=queery(L,R,l,m,w<<1);
    if(R>m)  set+=queery(L,R,m+1,r,w<<1|1);
    return  set;
}
int main()
{
     n=read();m=read();    
    if (m==0) {printf("0");return 0;}
     for(int i=1;i<=n;i++)
     {
     a[i]=read(),b[i]=read();
     update(a[i],b[i],1,100000,1);
     }
     for(int i=1;i<=100000;i++)
     {
         maxl=max(maxl,queery(i,i+m-1,1,100000,1));
     }
     printf("%d",maxl);
     return 0;
}
```
/\*
6 3
1 2
2 4
3 8
4 4
5 2
1000 1
\*/

---

## 作者：Jameswood (赞：17)

[原题链接](https://www.luogu.org/problem/show?pid=3353)

~~作者的文笔其实挺好的，写个情书说不定就被接受了呢……~~

好了好了，以上不是重点，但是本题的剧情真的是好长好长啊！！

[~~想知道更诡异的题目吗？点进来看看吧~~](https://www.luogu.org/discuss/show?postid=51038)

以上还不是重点，下面才是题解。



------------


#### 题目大意：

现有一个男孩纸，因为中学毕业后不能和（~~女盆友~~）喜欢的女孩纸在一起，悲愤欲绝后恍然大悟，决定发粪涂墙……

好好好，我不搞事，以下真的是题解了。



------------


#### 真-题目大意：

在数轴上有许多位置，值不同的点，（第i个位于xi，值为bi），求在范围 m ~ m+w (m 取任意自然数 ) 间所有点的值之和的最大值。



------------


#### 10分暴力做法

纯枚举，无杂质，实测十分，九黑之中一抹绿。

需要提及的是，在取到题目所给范围时会出现莫名RE，不知为何（我直接加到十倍）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std; 
const int SIZE=1000005;
int n,w,maxn=0,maxans=0,ans=0,x[SIZE],b[SIZE];
int main(){
	int y;
    scanf("%d%d",&n,&w);
    for(int i=0;i<n;i++){
        scanf("%d%d",&x[i],&y);
        b[i]+=y;
        maxn=max(maxn,x[i]);
    }
    for(int i=0;i<n-w+1;i++){
        ans=0;
        for(int p=0;p<n;p++)
            if(x[p]>=i&&x[p]<=i+w-1) ans+=b[p];
        maxans=max(maxans,ans);
    }
    printf("%d\n",maxans);
    return 0;
}
```

[测试详情](https://www.luogu.org/recordnew/show/8825610)

------------


#### 满分做法

线段树求和的基本操作。

很明显，此处并不存在所谓的插入操作。所以我直接在建树的过程中利用上推完成赋值，随后从零开始依次遍历每个长为w的区间，时间复杂度 O （n* log（n））。

特别注意两点

1：当 w 为0时，直接输出 0，而不是全部区间的和。

2：此题中不同星星的坐标可能相等，所以在输入时请用+=，不要直接输入（那样也只有10分）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
const int SIZE=1000005;
struct SegTree{
    int l,r,v;//左端点，右端点，和
}t[SIZE<<2|1];//<<n代表乘上2的n次方（>>为负的2的n次方）
//下行中的a数组为亮度
int n,w,maxn=0,a[SIZE],x[SIZE],AnsQuery=0,ans=0;
//令当前区间的和为左右子区间之和（上推）
void PushUp(int id){
    t[id].v=t[id<<1].v+t[id<<1|1].v;
}
//建树
void Build(int id,int l,int r){
    t[id].l=l;t[id].r=r;
    if(l==r){ 
    	//不知大家对赋值有没有什么好办法？
        //我是直接用x[i]作为亮度的下标
        //所以直接令t[id].v=a[l(r)];
        t[id].v=a[l];
    } 
    else{
        int mid=(l+r)>>1;
        Build(id<<1,l,mid);
        Build(id<<1|1,mid+1,r);
        PushUp(id);
    }
}
//查询
void Query(int id,int l,int r){
    if(t[id].l==l&&t[id].r==r) AnsQuery+=t[id].v;
    else{
        int mid=(t[id].l+t[id].r)>>1;
        if(r<=mid) Query(id<<1,l,r);
        else{
            if(l>=mid+1) Query(id<<1|1,l,r);
            else{
                Query(id<<1,l,mid);
                Query(id<<1|1,mid+1,r);
            }
        }
    }
}
int main(){
    int y;
    scanf("%d%d",&n,&w);
    if(w==0){
        printf("0\n");
        return 0;
        //如果没有窗，直接返回0。
    }
    for(int i=1;i<=n;i++){
        scanf("%d%d",&x[i],&y);
        //特别注意，不能直接输入，而要累加。
        a[x[i]]+=y;
        maxn=max(x[i],maxn);
    }
    Build(1,1,maxn);
    for(int i=1;i<=maxn-w+1;i++){
        AnsQuery=0;
        Query(1,i,i+w-1);
        ans=max(ans,AnsQuery);
        //printf("从%d到%d：%d\n",i,i+w-1,AnsQuery);
        //此句作测试用
    }
    printf("%d\n",ans);
    return 0;
}
```

[测试详情](https://https://www.luogu.org/recordnew/show/8826019)


P.S. 讨论区有人说前缀和也能做，不过，那是什么…………

P.P.S 我真的不知道………………

P.P.P.S 我是认真的…………

---

## 作者：YaliKiWi (赞：15)

~~这题是真的甜swl...呜呜呜好羡慕辣些有女盆友的小哥哥~~
- **暴力算法**

	枚举每一种窗户位置的可能，只要预统计一下每一个点上的总亮度，记为$l[i]  (i\in [1,Max \ (x)])$，暴力求和:
	```cpp
	for(register int i=1;i<=n;i++){
		int sum=0; 
		for(register int j=1;j<=w;j++){
			sum+=l[j];
		}
		ans=max(ans,sum);
	}
	```
	时间复杂度$O(NW)$，期望得分10
    
- **正常前缀和做法**

	用数组$pre[x]$表示$\sum _{i=1}^{x} f[i]$，则窗户 **右**边框位置为$k$时，当前答案为$pre[k]-pre[k-m]$
    
	那么答案可以表示为：$Max(pre[i]-pre[i-m]) \ (i\in [m,Max \ (x)])$
    
	于是就可以这样优雅地书写代码：
	```cpp
	for(register int i=1;i<=n;i++){
		cin>>x>>b;
		l[x]+=b;
		far=max(far,x);//记录x值最大点的位置
	}
	for(register int i=m;i<=far;i++)
		ans=max(ans,pre[i]-pre[i-w]);
	```
	时间复杂度$O(N)$，期望得分100
    
- **树状数组维护前缀和**


	不会树状数组的可以自己学习吖~我才不会放友链的...
	这里的$c[x]$和上一种解法中的$pre[x]$意义相同。
	所以还是你熟悉的$lowbit$(dalao们不要吐槽我的写法呀):
	```cpp
	#define lowbit(x) ((x)&(-x))
	```
	还有熟悉的$Update$和$Sum$:
	```cpp
	inline void Update(int x,int v){
		while(x<=n){
			c[x]+=v;
			x+=lowbit(x);
		}
	}
	inline int Sum(int x){
		int res=0;
		while(x>0){
		res+=c[x];
			x-=lowbit(x);
		}
	}
	```
	时间复杂度$O(n)$(峰值在读入...)
    
	然而它慢一点...别在意...
    
	接下来就是完整代码~

	----
	1. 普通前缀和版
    ```cpp
	#include<bits/stdc++.h>
	using namespace std;
	#define maxn 100010
	#define max_(x,y) ((x)>(y)?(x):(y))
	#define min_(x,y) ((x)<(y)?(x):(y))
	#define dd double
	#define ull unsigned long long
	#define ll long long
	#define fo(i,s,e) for(register int 	i=s;i<=e;i++)	
	int x,b;
	int n,m,far;
	int l[maxn],pre[maxn];
	int ans;
	signed main(){
		ios::sync_with_stdio(0);
		cin.tie(0);
		cin>>n>>m;
		fo(i,1,n){
			cin>>x>>b;
			l[x]+=b;
			pre[x]+=b;
			far=max_(far,x);
		}
		fo(i,1,far)
			pre[i]+=pre[i-1];
		fo(i,m,far)
			ans=max_(ans,pre[i]-pre[i-m]);
		cout<<ans;
		return 0;
	}
    ```
    ----
    
    2.树状数组版
    
    ```cpp
	#include<bits/stdc++.h>
	using namespace std;
	#define maxn 100010
	#define max_(x,y) ((x)>(y)?(x):(y))
	#define min_(x,y) ((x)<(y)?(x):(y))
	#define dd double
	#define ull unsigned long long
	#define ll long long
	#define lowbit(x) ((x)&(-x))
	int c[maxn];
	int n,m,x,b,far,ans;
	inline void upd(int x,int v){
		while(x<=n){
			c[x]+=v;
			x+=lowbit(x);
		}
	}
	inline int sum(int x){
		int sum=0;
		while(x>0){
			sum+=c[x];
			x-=lowbit(x);
		}
		return sum;
	}
	inline void NMSP(){
		cin>>n>>m;
		for(register int i=1;i<=n;i++){
			cin>>x>>b;
			upd(x,b);
			far=max_(x,far);
		}
		for(register int i=m;i<=far;i++)
			ans=max_(ans,sum(i)-sum(i-m));
		cout<<ans;
	}	
	signed main(){
		ios::sync_with_stdio(0);
		cin.tie(0);
		NMSP();
		return 0;
	}
	```
	~~代码里有一些奇奇怪怪的东西不要在意吖~~     

---

## 作者：gb530 (赞：10)

### 此题吸引我的重要原因之一就是
##  _文笔优美！！！_ 
### 我们来点评一下这篇优美的情书
### 看到第一段······~~此处作者忍痛删去600字~~
### 我不搞事了。这道题一眼望去即为前缀和模板题
### 可是评测过后～
## 却只有0分
### 不知读者有没有类似的经历～～
### 这是0分代码：
```c
#include<iostream>
#include<cstdio>
using namespace std;
const int maxm=1e5+10;
int n,w,ans=0;
int presum[maxm],a[maxm];
int main(){
	scanf("%d%d",&n,&w);
	int maxj=0;
	for(int i=1;i<=n;i++){
		int j;
		scanf("%d%d",&j,&a[j]);
		maxj=max(maxj,j);
	}
	for(int i=1;i<=100000;i++)
		presum[i]=presum[i-1]+a[i];
	for(int i=1;i<=maxj-w+1;i++)
		ans=max(ans,presum[i+w-1]-presum[i-1]);
	cout<<ans<<endl;
	return 0;
}
```
### 正当我百思不得其解时
#### 我发现了此题大坑 
# 星星可以在同一位置
### 略作修改 0分摇身一变～
## 变为满分！！
## 满分代码:
```c
#include<iostream>
#include<cstdio>
using namespace std;
const int maxm=1e5+10;
int n,w,ans=0;
int presum[maxm],a[maxm];
int main(){
	scanf("%d%d",&n,&w);
	int maxj=0;
	for(int i=1;i<=n;i++){
		int j,k;
		scanf("%d%d",&j,&k);
		a[j]+=k;
		maxj=max(maxj,j);
	}
	for(int i=1;i<=100000;i++)
		presum[i]=presum[i-1]+a[i];
	for(int i=1;i<=maxj-w+1;i++)
		ans=max(ans,presum[i+w-1]-presum[i-1]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：doby (赞：8)

前缀和就可以水过了……

毕竟数据范围改小了还是很好的……

然而本题的题目背景其实是P1502窗口的星星的原题的题目背景……

```cpp
#include<cstdio>
using namespace std;
int n,m,w,x,y,ans,a[100010],s[100010];
int main()
{
    scanf("%d%d",&n,&w);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
        a[x]=a[x]+y,m=m>x?m:x;
    }
    for(int i=1;i<=m;i++){s[i]=s[i-1]+a[i];}//前缀和
    for(int i=1;i<=m-w+1;i++){ans=ans>(s[i+w-1]-s[i-1])?ans:(s[i+w-1]-s[i-1]);}
    printf("%d",ans);
    return 0;
}
```

---

## 作者：寒鸽儿 (赞：7)

2020.02.14打卡  
~~本题重点在于赏析题面~~，显然对星星按坐标排序，当我们向右枚举合法最大区域的右界，合法的最大区域的左界一定是单调向右移动的，即满足单调性。  
那么依据单调性，求前缀和枚举扫过去就好了，前界移动数 $O(n)$，后界移动数  $O(n)$,移动代价 $O(n)$,排序代价 $O(nlogn)$,总体复杂度 $O(nlogn)$。
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long ll;

struct star {
	int x, w;
	star() {}
	star(int X, int W) : x(X), w(W) {}
	bool operator < (const star& o) const { return x < o.x; }
};

int main() {
	int n, w, tx, ty;
	scanf("%d %d", &n, &w);
	vector<star> vn(n);
	vector<ll> sum(n, 0);
	for(int i = 0; i < n; ++i) {
		scanf("%d %d", &tx, &ty);
		vn[i] = star(tx, ty);
	}
	if(w == 0) {
		printf("0\n");
		return 0;	
	}
	sort(vn.begin(), vn.end());
	int l = 0;
	ll ans = sum[0] = vn[0].w;
	for(int i = 1; i < n; ++i) {
		sum[i] = sum[i - 1] + vn[i].w;
		while(vn[i].x - vn[l].x + 1 > w && l <= i) ++l;
		ans = max(ans, sum[i] - sum[l] + vn[l].w);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Suuon_Kanderu (赞：5)

发现没有分块的，赶紧水题解，数据较小，几乎什么都能跑。分块是一种暴力优化算法，简单容易码，

具体就是把数据分成$\sqrt{n}$个块，查询时暴力查询前面的不完整数据，后面的不完整数据，再加上中间的整块~~最适合我这种懒人~~

这是我的板子，把最大最小和一块维护了。

```c
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string.h>
using namespace std;
const int N=100000+100;
struct fk{//分块大法 
	int num,rank;//数值，第几块 ,＋数的标记 
}a[N];
int minn[N],sum[N],maxx[N],tag[N],b[N];//第一块的最最小值，和，最大值，标记 
#define rank(i) a[i].rank
#define num(i) a[i].num
#define minn(i) minn[i]
#define sum(i) sum[i]
#define maxx(i) maxx[i]
#define tag(x) tag[x]
int n,bs,zo;//共有几个数，块的大小 ,总共有几个块 
int qsum(int l,int r) {
    int ans=0,k1,k2;
    for(int i=l;; i++) {
        k1=i;
        if(rank(i+bs-1)==rank(i))break;//如果这是块的第一个元素，break 
        ans+=num(i)+tag(rank(i));
    }
    for(int i=r;; i--) {
        k2=i;
        if(rank(i-bs+1)==rank(i))break;//同上 
        ans+=num(i)+tag(rank(i));
    }

    k1++;
    k2--;
    k1=rank(k1);
    k2=rank(k2);
    for(; k1<=k2; k1++) {
        ans+=sum(k1);//sum在修改时已经维护过了，不用再加tag 
    }
    return ans;
}
int qmax(int l,int r) {//忽略 
    int ans=-0x7fffffff,k1,k2;
    for(int i=l;; i++) {
        k1=i;
        if(rank(i+bs-1)==rank(i))break;
        ans=max(num(i)+tag(rank(i)),ans);
    }
    for(int i=r;; i--) {
        k2=i;
        if(rank(i-bs+1)==rank(i))break;
        ans=max(num(i)+tag(rank(i)),ans);
    }
    k1++;
    k2--;
    k1=rank(k1);
    k2=rank(k2);
    for(; k1<=k2; k1++) {
        ans=max(maxx(k1),ans);
    }
    return ans;
}
int qmin(int l,int r) {//忽略 
    int ans=0x7fffffff,k1,k2;
    for(int i=l;; i++) {
        k1=i;
        if(rank(i+bs-1)==rank(i))break;
        ans=min(num(i)+tag(rank(i)),ans);
    }
    for(int i=r;; i--) {
        k2=i;
        if(rank(i-bs+1)==rank(i))break;
        ans=min(num(i)+tag(rank(i)),ans);
    }
    k1++;
    k2--;
    k1=rank(k1);
    k2=rank(k2);
    for(; k1<=k2; k1++) {
        ans=min(minn(k1),ans);
    }
    return ans;
}
void change(int x,int y) { //a[x]+=y;忽略 
    num(x)+=y;
    sum(rank(x))+=y;
    minn(rank(x))=min(num(x)+tag(rank(x)),minn(rank(x)));
    maxx(rank(x))=max(num(x)+tag(rank(x)),maxx(rank(x)));
}
void change2(int l,int r,int z) { //i from x to y a[i]+=z
    int k1,k2;
    for(int i=l;; i++) {
        k1=i;
        if(rank(i+bs-1)==rank(i))break;//同上qsum函数 
        num(i)+=z;;
        sum(rank(i))+=z;
        if(num(i)>maxx(rank(i)))maxx(rank(i))=num(i);
        if(num(i)<maxx(rank(i)))minn(rank(i))=num(i);
    }
    for(int i=r;; i--) {
        k2=i;
        if(rank(i-bs+1)==rank(i))break;//同上 
        num(i)+=z;
        sum(rank(i))+=z;
        if(num(i)>maxx(rank(i)))maxx(rank(i))=num(i);
        if(num(i)<maxx(rank(i)))minn(rank(i))=num(i);
    }
    k1++;k2--;
    k2=rank(k2);
    k1=rank(k1);
    for(; k1<=k2; k1++) {
        tag(k1)+=z;
        sum(k1)+=bs*z;
        minn(k1)+=z;
        maxx(k1)+=z;
    }
}
void pr() {//调试用 
    printf("\tid\tnum\trank\n");
    for(int i=1; i<=n; i++)printf("\t%d:\t%d\t%d\n",i,num(i),rank(i));
    printf("\n\tid\tmin\tmax\tsum\ttag\n");
    for(int i=1; i<=zo; i++)printf("\t%d:\t%d\t%d\t%d\t%d\n",i,minn(i),maxx(i),sum(i),tag(i));
}
signed main(){
	int max1=-1,x,y,k;
	cin>>n>>k;bs=sqrt(n);
	if(n/bs*bs==n)zo=n/bs; else zo=n/bs+1;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		b[x]+=y;
		max1=max(x,max1);
	}
	for(int i=1;i<=max1;i++)num(i)=b[i];
	for(int i=1;i<=x;i++){
		if((i-1)%bs==0){
			minn((i-1)/bs+1)=0x7fffffff;
			maxx((i-1)/bs+1)=-0x7fffffff;
			sum((i-1)/bs+1)=0;
		}
		a[i].rank=(i-1)/bs+1;
		minn((i-1)/bs+1)=min(num(i),minn((i-1)/bs+1));
		maxx((i-1)/bs+1)=max(num(i),maxx((i-1)/bs+1));
		sum((i-1)/bs+1)+=num(i);		
	} 

	int l,r,e,ans=0;
	for(int i=1;i+k-1<=max1;i++){
		ans=max(ans,qsum(i,i+k-1));
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Lates (赞：5)

此题前缀和维护即可，主要说一下前缀和

- 前缀和
	
 	设 $ pre_i $ 表示 $ \sum ^{i}_{1} a_{i} $
   
   则有
   $ pre_i = pre_{i-1} + a_i $
   
- 查询前缀和

	有了$pre$数组如果我们要求 $ [l,r] $ 的和,有
   
   $ pre_{l-1}=a_1+a_2+a_3+...+a_{l-1}$
   
   $ pre_{r}=a_1+a_2...a_{l-1}+a_{l}+...a_r$
   
   做个差，发现两两抵消，就得到了
   
   $$ \sum^r_{i=l} a_i =pre_r-pre_{l-1}$$
   
	(不理解可以拿笔算一算)
 - Code
 
 	代码就这么实现即可
   
   
  ```cpp
#include<iostream>
#include<cstdio>
using namespace std;
inline int read(){
	register int x=0,v=1,ch=getchar();
	while(!isdigit(ch)){if(ch=='-')v=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^'0');ch=getchar();}
	return x*v;
}
const int MAX=100005;
int n,k,L,R,l,r;
int x,ans,res[MAX],pre[MAX];
int main(){
	n=read(),k=read();
	for(register int i=1;i<=n;++i){
		x=read();res[x]+=read();
		L=min(L,x),R=max(R,x);//查询最小 位置和最大位置
	}
	for(register int i=L;i<=R;++i){//前缀和
		pre[i]=pre[i-1]+res[i];
	}
	for(register int i=L;i+k-1<=R;++i){
		l=i,r=i+k-1;
		ans=max(ans,pre[r]-pre[l-1]);//判断最大的和
	}
	printf("%d\n",ans);//输出答案
	return 0;
}

```



---

## 作者：1379号监听员 (赞：3)

# P3353 题解

----

在做[P1502 窗口的星星](https://www.luogu.org/problemnew/show/P1502)时偶然发现了这道题，看到这题的名字以后好奇心大增，就决定点进去看看。。。

~~本来看到这只是道黄题没打算做，直到这题超级长的题面让我想起了我在学校的【已编辑】，于是决定A之以明志~~

---

## 题目大意

天空中有$n$颗星星，求宽度为$W$的窗户（高度无限）最多能圈住亮度为多少的星星。

仔细分析后，我们发现我们可以将天空视作一个数轴，将$x$坐标相等的星星亮度累加在一起（反正$y$坐标没用），然后依次统计出每个长度为$W$的区间和，最后求最大值就可以了。

---

## 暴力算法

由上面的题目大意，可以十分直接地得到一个暴力算法——由$W$到最大的$x$坐标循环枚举，每次用循环求出$i-w$到$i$的区间和，然后取最大值

*期望得分:(想要期望得分？这玩意估计也只能对拍用)*

---

## 正解——前缀和

首先，我们要介绍一下**前缀和**：

**前缀和，指在一个序列中由序列起始位置到当前位置的和，如**
$$Sum_i=A_1+A_2+A_3+A_4+···+A_i$$

前缀和的作用是 $O(1)$ 地维护静态区间和，原理为：
$$Sum_i=A_1+A_2+A_3+A_4+···+A_i$$


$$Sum_j=A_1+A_2+A_3+A_4+···+A_j,j>i$$

则Sum_j一定包含Sum_i，即
$$Sum_j=A_1+A_2+A_3+A_4+···+A_i+A_(i+1_)+···+A_j$$

则
$$Sum_j-Sum_i=(A_1+A_2+A_3+A_4+···+A_i+A_(i+1_)+···+A_j)$$
$$-(A_1+A_2+A_3+A_4+···+A_i)=A_(i+1_)+A_(i+2_)+···+A_j$$
所以
$$ A_(i+1_)+A_(i+2_)+···+A_j$$
即为i到j的区间和 

由此，我们可以得出最后的思路——在输入完成后，$O(n)$ 预处理出**前缀和数组sum**，然后对每个区间和操作，返回**sum[i]-sum[i-w]** (因为只有i-w+1 ~ i会被计算)，然后取最大值即可。

至此，问题得到完美解决。~~完结撒花~~

贴代码~

``` cpp

#include<iostream>
#include<algorithm>
using namespace std;
const int maxw=100005;
long long n,w,x,b;
long long maxx=0,ans=0;
long long br[maxw];//亮度数组
long long sum[maxw];//前缀和数组
int main(int argc, char const *argv[]) {
  ios::sync_with_stdio(false);//流式I/O速度优化
  cin.tie(0);//流式I/O速度优化
  cin>>n>>w;
  for(int i=1;i<=n;i++)
  {
    cin>>x>>b;
    br[x]+=b;//向指定的X坐标累加亮度
    maxx=max(maxx,x);//更新x的最大值
  }
  for(int i=1;i<=maxx;i++) sum[i]=sum[i-1]+br[i];//递推处理前缀和数组
  for(int i=w;i<=maxx;i++)
  {
    ans=max(ans,sum[i]-sum[i-w]);//区间和与取最大值
  }
  cout<<ans<<endl;
  return 0;
}


```

顺便安利一下本人的博客：[链接](https://directional-foil.blog.luogu.org/#)


---

## 作者：404_notfound (赞：3)

题目真的好甜呢QwQ

~~冲着这题面也要来做~~


------------
### 满分解法：线段树

我们暴力地把所有点建成一颗线段数

接着在从1到maxx里每个长度为 w的区间中执行区间求和



其实单点修改都不需要，可以在输入的时候统计出每个点上星星的亮度和

另：同一点上可能有多个星星

```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define ll long long
using namespace std;
#define maxn 100009
struct node{
	int l,r,val;
}tr[maxn*4];
int n;
int a[maxn];
void Buildtree(int x,int l,int r)
{
	tr[x].l=l;
	tr[x].r=r;
	if(l==r)
	{
		tr[x].val=a[l];
		return;
	}
	int mid=(l+r)>>1;
	Buildtree(x*2,l,mid);
	Buildtree(x*2+1,mid+1,r);
	tr[x].val=tr[x*2].val+tr[x*2+1].val;
}
int Query(int x,int l,int r)
{
	if(l<=tr[x].l&&tr[x].r<=r)
	{
		return tr[x].val;
	}
	int mid=(tr[x].l+tr[x].r)/2;
	int ans=0;
	if(l<=mid) ans+=Query(x*2,l,r);
	if(r>mid) ans+=Query(x*2+1,l,r);
	return ans; 
}
int main()
{
	int maxx=0;
	int w;
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[x]+=y;
		maxx=max(maxx,x);
	}
	Buildtree(1,1,maxx);
	//建树的范围是所有点，从1到最大点的位置 
	
	int ans=0;
	for(int i=1;i<=maxx;i++)
	{
		ans=max(ans,Query(1,i,i+w-1));//记得w-1
		/*
		窗框算在W之内 
		W=3
				框   星  框 
				|    *   | 
		------------------------
		*/ 
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：Cagulo (赞：2)

**#队列模拟轻松过**

//首先的想法是按x为关键字升序排列，直接进行模拟用你n^2的办法来暴力水分40没问题，但是对100%的数据显得无能为力，就继续想，

//我们已经排好序了，依旧从1-n枚举，但是我们为什么要从当前的i开始枚举所能满足条件的点，然后再从下一个点继续枚举，这显然很浪费时间

//每一个点都被访问了很多次，为什么不能扫一遍就过了？继续往下想，这道题显然是求一个满足条件的区间！！！

//既然是区间，我们只需要维护区间的左端点和右端点是否满足条件即可,比较当前的sum和ans来跟新ans；

//假设进来一个新的点如果不满足，就删去左端点，直到满足条件为止，再加入 新的点，重新统计sum，跟新ans

//想到这就想到了一个模型：滑动窗口，用队列来模拟实现上述过程，队列里面记录的是放的点的i值，这样可以通过i找到x和val（亮度）

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define N 100005
using namespace std;
struct node{
    int xi,val;
}f[N];
bool cmp(node a,node b){
    return a.xi<b.xi;
}
int n,w;
int q[N];
int main()
{
    scanf("%d%d",&n,&w);
    if(w==0){
        printf("0\n");
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&f[i].xi,&f[i].val);
    }
    sort(f+1,f+n+1,cmp);
    int sum=0,ans=0;
    int head=0,tail=1;
    f[0].xi=0;
    for(int i=1;i<=n;i++)
    {
        while(f[i].xi-f[q[head]].xi+1>w && head<=tail){
            sum=sum-f[q[head]].val;head++;
        }
        q[tail++]=i;
        sum+=f[i].val;
        ans=max(ans,sum);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Vatyr (赞：1)

水一发题解。。。

所谓的滑动窗口？

首先很显然的一点就是w=0时直接输出0就行了。

接着我们看数据范围（xi<=100000)所以就直接开个这么大的数组绝对没问题！于是我们用l[]来记录每个点上的亮度和，读入的时候处理一下，

接着先求出1~w的亮度和，再从w+1~n。an[i]用来记录以i为结尾的长度为w的区间和，每次与ans比较一下大小就行了。

上代码：

```cpp
#include<iostream>//1198ms 暴力妥妥的！
using namespace std;
int l[100005];
int an[100005];
int main()
{
    int n,w;
    cin>>n>>w;
    int ans=0;
    if(w==0)
    {
        cout<<'0'<<endl;
        return 0;
    }
    int len=0;
    for(int i=1;i<=n;i++)
    {
        int x,b;
        cin>>x>>b;
        l[x]+=b;
        len=max(len,x);
    }
    for(int i=1;i<=w;i++)ans+=l[i];
    an[w]=ans;
    for(int i=w+1;i<=len;i++)
    {
        an[i]=an[i-1]+l[i]-l[i-w];
        ans=max(ans,an[i]);
    }
    cout<<ans;
    return 0;
}
```
我想应该没什么好注释的吧。。。


---

## 作者：星灵王 (赞：1)

虽然学过前缀和等等鬼畜的东西，但是这道题大家看到的第一反应难道不是模拟吗？

可模拟很慢，所以我们想想怎么优化。我们仔细想一想一个长度为m-1的区间在一步步向右移然后求出每一次移动的最大值。但是这个范围有点大，所以我们把区间左端改为每个星星的坐标（可以很简单来证明一定是更优的），但是如果一个个判断是否有星星在区间里还是慢啊，万一真的故意卡成了n^2的话。

所以我们设置一个j为区间右端，j只会不断右移，所以每次j不需要从头算起，只需要接着上一次的j接着看看可不可以有新的星星在这个区间里就好了

语文不好，可能有的人看不懂，所以看代码吧，代码很简单的

```cpp
#include<iostream>
using namespace std;
int a[100005],b[100005];
long long ans;
void qsort(int x,int y)
{
	int i=x,j=y;
	int mid=b[(x+y)/2];
	do
	{
		while(b[i]<mid) i++;
		while(b[j]>mid) j--;
		if(i<=j)
		{
			swap(a[i],a[j]);
			swap(b[i],b[j]);
			i++;j--;
		}
	}while(i<=j);
	if(x<j) qsort(x,j);
	if(i<y) qsort(i,y);
}
int main()
{
	long long n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>b[i]>>a[i];
	qsort(1,n);		//注意，题目没说按顺序，所以一定要排序哦 
	int j=1;
	long long s=0;
	for(int i=1;i<=n;i++)
	{
		s-=a[i-1];		//减去已经不在区间里的星星亮度 
		while(j<=n&&b[j]-b[i]<m)
		{
			s+=a[j];
			j++;
		}
		ans=max(ans,s);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：ciwomuli (赞：1)

翻了一遍题解区，全是用线段树做的。  
这不是一道双指针裸题吗？
直接对于x排序，然后双指针扫一遍就行了，时间复杂度$O(n\log n)$
注意要特判w=0的情况，我的代码不知道为什么会RE
```
#include <algorithm>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
#define LL long long
#define P pair<int,int>
using namespace std;
template <typename T>
inline void read(T &t)
{
    int f = 0, c = getchar();
    t = 0;
    while (!isdigit(c))
        f |= c == '-', c = getchar();
    while (isdigit(c))
        t = t * 10 + c - 48, c = getchar();
    if (f)
        t = -t;
}
template <typename T, typename... Args>
inline void read(T &t, Args &... args)
{
    read(t);
    read(args...);
}
const int maxn = 100005;
int n,w;
P a[maxn];
int main(){
    read(n,w);
    int l = 1, r = 1;
    for(int i=1;i<=n;i++){
        read(a[i].first, a[i].second);
    }
    if(w==0){
        cout << 0;
        return 0;
    }
    sort(a + 1, a + n + 1);
    LL ans = 0;
    LL sum = 0;
    while(r<=n){
        while(r<=n && a[r].first-a[l].first<=w-1){
            sum += a[r].second;
            r++;
        }
        if(r>n) break;
        ans = max(ans, sum);
        sum-=a[l].second;
        l++;
    }
    cout << ans;
}
```

---

## 作者：Dog_Two (赞：1)

这一题和P1614爱与愁的心痛其实是完全一样的题目，而且P1614是一道红题……

很多用户给这一题打上了“线段树”的标签，应该是被POJ上面题面相同的题目误导的。

P1614可以做到严格1n线性求解，但在本题里，因为星星的位置和亮度不是按照顺序给出的，所以并不能边读入边计算。

O(n)解决本题思路如下：

- 在读入数据的时候，记录出现的最大的位置pos
- 在1...w之间维护全局变量sum：求和所有在这个区间内的星星，作为初始答案
- 在w+1...pos之间继续维护sum：增加当前位置i的星星，减去刚刚出界的i-w的星星，更新答案。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,w,pos;
int a[maxn],sum,ans;
int main(){
    cin>>n>>w;
    if(w==0){
        puts("0");
        return 0;
    }
    for(int i=1;i<=n;++i){
        int p,v;scanf("%d%d",&p,&v);
        pos=max(pos,p);
        a[p]+=v;
    }
    for(int i=1;i<=w;++i) ans=sum+=a[i];
    for(int i=w+1;i<=pos;++i) 
        ans=max(ans,sum+=a[i]-a[i-w]);
    cout<<ans;
    return 0;
}
```
写完代码，我们反思一下代码中需要注意的一些细节：
- 题目提醒我们存在w=0的情况，这时直接使用主代码维护会出很大的逻辑错误，应直接输出0；
- 题面中“每颗星星自己的”可能会误导我们认为“星星不重复”，这时仍不妨使用a[p]+v，不影响数值的存储，并且解决了题意带来的歧义问题
- 对于到底该是a[i-w]还是a[i-w+1]这样的细节，如果短时间内辨别不清，最好情景化思考

---

## 作者：Lance1ot (赞：1)

线段树都有了？怎么能没有树状数组呢？

在朴素前缀和的基础上维护了一下。

利用树状数组常数小，跑起来非常的快。

每次只要暴力的枚举区间就可以了

------------------

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
struct node
{
	int tree[100100];
	int num;
	int lowbit(int x)
	{
		return x&(-x);
	}
	void updata(int x,int i)
	{
		while(i<=num)
		{
			tree[i]+=x;
			i+=lowbit(i);
		}
	}
	int sum(int i)
	{
		int ans=0;
		while(i>0)
		{
			ans+=tree[i];
			i-=lowbit(i);
		}
		return ans;
	}
	int check(int l,int r)
	{
		return sum(r)-sum(l-1);
	}
};//直接写成了结构体函数。可移植性大大增加。不要问我为什么要可移植性。
node bit;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	bit.num=n;
	int a,b;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a,&b);
		bit.updata(b,a);//(⊙o⊙)…。处理
	}
	int ans=0;
	for(int i=1;i+m-1<=n;i++)
		ans=max(ans,bit.check(i,i+m-1));//暴力枚举区间起点
	printf("%d",ans);
}
```

---

## 作者：灞波儿奔 (赞：0)

因本人太弱~~太懒~~，又因为此题Xi的数据范围并不是特别大，所以，我采用了树状数组+暴力枚举的形式来写这道题。

------------
话不多说，直接上码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,b,x,c[100010],maxx;
long long ans;
//6到15行为树状数组标准函数（点修改和区间查找）
void modify(int a,int b)
{
	for(;a<=n;a+=a&-a)c[a]+=b;
}
long long query(int a)
{
	long long res=0;
	for(;a;a-=a&-a)res+=c[a];
	return res;
}
int main()
{
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&b);
		modify(x,b);
		maxx=max(maxx,x);//为了找到枚举范围，维护一个Xi最大值
	}
	for(int l=1;l<=maxx-w+1;l++)//枚举区间左端点
	{
		int r=l+w-1;
		long long ans1=query(r)-query(l-1);
		ans=max(ans,ans1);//维护答案最大值
	}
	printf("%lld",ans);//输出答案
	return 0;
} 
```
注：&为位运算“与”，a&-a可以得到a在二进制中末尾0的个数

---

## 作者：1jia1 (赞：0)

**核心思路：分块询问+跳过0.如果数据大一点就要用到离散化（然而我并不会），不过这个数据小的一b所以直接从头走到底就没问题了**

```
#include <iostream>
using namespace std;
int n,k,a[100001],sum[100001],pos[100001],size,L,s,t;
int ask(int l,int r)//查询
{
	int ans=0;
	for(int i=pos[l]+1;i<pos[r];i++)ans+=sum[i];
	for(int i=l;i<=min(pos[l]*size,r);i++)ans+=a[i];
	if(pos[l]!=pos[r])
	{
		for(int i=(pos[r]-1)*size+1;i<=r;i++)ans+=a[i];
	}
	return ans;
}
int main()
{
	cin>>n>>k;
	if(k==0)
	{
		cout<<0;
		return 0;
	}
	for(size=1;size*size<=n;size++);size--;//相当于size=sqrt(n)
	for(int i=1,u,v;i<=n;i++)
	{
		cin>>u>>v;
		a[u]+=v;//注意，由于星星会重叠，所以这个要+=，我就因为这个全WA
		L=max(L,u);//整个区间的长度
	}
	for(int i=1;i<=L;i++)//建块
	{
		pos[i]=(i-1)/size+1;
		sum[pos[i]]+=a[i]; 
	}
	for(int i=1;i<=L-k+1;i++)
	{
		if(a[i]==0){continue;}//跳过区间头为0的点，因为稍有常识的人都可以看出，如果区间第一个点为0，那么往后挪一格的区间和肯定不会比这个区间的和更小
		s=max(ask(i,i+k-1),s);
	}
	cout<<s;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# 强行带来一波zkw线段树题解

实测发现只比开了读入优化的前缀和慢一倍，甚至能达到不开读入优化的前缀和的速度。~~比一般线段树不知道强到哪里去了~~

#### ~~zkw好用又好写，一般线段树选手快选用zkw吧！~~

至于zkw线段树的详细介绍，请移步[zkw线段树初步](http://wyfcyx.logdown.com/posts/201802-summary-data-structures-zkw-segment-tree-details)
或zkw神犇的ppt[统计的力量](https://wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html)
```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxx=400050;
const int maxn=100005;
inline ll read(){
    char ch=getchar();int x=0,f=1;
    while(ch<'0'||ch >'9') {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9') {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline void print(ll k){
	if(k<0) k=-k,putchar('-');
	if(k>9) print(k/10);
	putchar(k%10+48);
}
int seg[maxx],n,m,bit,a,b,w;
inline void setbit(){
	for(bit=1;bit<=n+1;bit<<=1);
}
inline void build(){
	for(int i=bit-1;i;--i) seg[i]=seg[i<<1]+seg[i<<1|1]; 
}
inline void update(int x,int y){
	for(seg[x+=bit]=y,x>>=1;x;x>>=1) seg[x]=seg[x<<1]+seg[x<<1|1];
}
inline int query(int s,int t){
    int ans=0;
    for(s+=bit-1,t+=bit+1;s^t^1;s>>=1,t>>=1){
        if(~s&1) ans+=seg[s^1];
        if(t&1)	ans+=seg[t^1];
    }
    return ans;
}
int xi,bi,ans;
int main(){
	n=read();
	w=read();
	setbit();
	for(int i=1;i<=n;++i){
		xi=read();
		bi=read();
		seg[xi+bit]+=bi;
	}
	build();
	int ansq;
	for(int i=1;i<=maxn-w+1;++i){
		ansq=query(i,i+w-1);
		ans=max(ans,ansq);
	}
	print(ans),putchar('\n');
	return 0;
}
```

---

## 作者：Right (赞：0)

其实这道题可以用一个维护区间和来求解


首先，我们要给这里每一个星星的坐标排序


然后分别用头尾指针来维护整个区间


当头指针小于尾指针并且区间的宽度小于窗户的宽度的时候，我们就可以不断的使答案加上尾指针的星星的亮度


并且每次都要记录区间最大值，与答案进行比较，更新答案


>>上代码
>>因为w》3所以可以直接从3开始计算区间的最大值

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
//P3353
int n,w,ans,now; >>ans为最后最大的答案，now为当前区间的答案
struct stu
{
    int num,light;
}star[100000];  >>定义结构体，方便排序，也可以调用STL的pair
bool cmp(stu a, stu b)
{
    if (a.num<b.num) return true;  >>按照坐标大小排序
    else return false;
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&w);
    if (w==0) {printf("0");return 0;} >>能骗分为什么不骗呢？
    for (i=1; i<=n; ++i){
        scanf("%d%d",&star[i].num,&star[i].light);
    }
    sort(star+1,star+n+1,cmp); >>排序，调STL
    int h=star[1].num,t=star[2].num; i=2; j=1; >>头尾指针维护
    now=star[2].light+star[1].light; 
    while (h<=t){
        now+=star[++i].light,t=star[i].num; 当前区间答案需加上尾指针星星的亮度
        while (t-h>w-1) now-=star[j].light,h=star[++j].num; >>当区间的长度大于窗户的宽度的时候，应缩短区间长度，头指针后移
        ans=max(now,ans);  最终答案为所有区间答案的最大值
        //cout<<h<<" "<<t<<" "<<now<<endl;
    }
    printf("%d",ans);
}
Over .Right
```

---

## 作者：Fraction (赞：0)

~~看到没几个人写树状数组，赶紧水一发~~

其实说实在的，树状数组不需要特判$w=0$的情况,因为在求和的过程$sum(i) - sum(i-w)$中，二者是相等的，即$sum(i)-sum(i) = 0$

所以那些模拟的，线段树的，~~重口味线段树的~~，都没有这树状数组舒服

而且人家树状数组好写啊，常数又小，~~你看我这代码都是几分钟写的~~

想学树状数组的可以去模板题~~不过你要是不会干嘛点开这题~~

代码如下：

```cpp
#include <bits/stdc++.h>
#define fp(i, l, r) for(register int i = (l); i <= (r); ++i)
#define fd(i, l, r) for(register int i = (l); i >= (r); --i)
#define ANTISYNC ios::sync_with_stdio(false)
#define MAXN (int)1e5 + 5
#define lowbit(x) x & -x
#define ll long long
#define il inline
#define SAFE 4
using namespace std;

const int INF = 0xfffffff;

int n, w;
int tree[MAXN * SAFE], lit[MAXN], pos[MAXN];

namespace Fenwick {
    il void add(int k, int b) {//单点修改操作
        while(k <= n) {
            tree[k] += b;
            k += lowbit(k);
        }
        return ;
    }
    
    il int sum(int k) {//区间查询操作
        int ret = 0;
        while(k > 0) {
            ret += tree[k];
            k -= lowbit(k);
        }
        return ret;
    }
};//这里把两个操作打进一个namespace 可以忽略，相当于函数定义

using namespace Fenwick;

il int init() {
    int maxn = -INF;
    scanf("%d%d", &n, &w);
    fp(i, 1, n) scanf("%d%d", &pos[i], &lit[i]), add(pos[i], lit[i]);
    fp(i, w, n) maxn = max(maxn, sum(i) - sum(i-w));
    printf("%d", maxn);
    return 0;
}

int main() {
    init();
    return 0;
}
```

以上。

---

## 作者：巫妖王 (赞：0)

$\color{red}\text{这道题其实可以不用线段树来做！}$

**我的思路其实和大佬[Dog_Two](https://www.luogu.org/space/show?uid=38283)一样，就不多说了，详见代码**

[想看我的思路的点这前往大佬Dog_Two的题解](https://www.luogu.org/blog/DogTwo/solution-p3353)

------------
```pascal
uses math;
const maxn=100010;
var n,w,i,p,v,pos,sum,ans:longint;
    a:array[1..maxn]of longint;
begin
readln(n,w);
if w=0 then writeln(0)//特判，w=0的情况是无法正常维护的
else 
begin
 for i:=1 to n do
 begin 
  read(p,v);
  pos:=max(pos,p);//记录出现的最大的位置pos作为维护的边界值
  a[p]:=a[p]+v;
 end;
 for i:=1 to w do
 begin
  sum:=sum+a[i];
  ans:=sum;//初始答案
 end;
 for i:=w+1 to pos do
 begin
  sum:=sum+a[i]-a[i-w];
  ans:=max(ans,sum);//不断向正方向移动窗户，更新最大值
 end;
 writeln(ans);
end;
end.
```



---

## 作者：xfydemx (赞：0)

萌新又来发题解了QAQ   
我是奔着线段树的标签来的  
然而这题并没有修改操作  
于是就有了第一种做法-前缀和水一水
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
const int N = 100010;
int n,m,k,t,sum[N],w[N],ans;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>k>>t;
		w[k]+=t;
	}
//	cout<<w[3];
	for(int i=1;i<=100005;i++){
		sum[i]=sum[i-1]+w[i];
	}
	for(int i=1;i<=(n-m+1);i++){
		int f=sum[i+m-1]-sum[i-1];
		ans=max(ans,f);
	}
	cout<<ans<<endl;
	return 0;
}
```
但是对萌新来讲线段树还是要写的emmm
上线段树
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
const int N = 100010;
long long n,m,a[N],add[N*4],w[N],ans=0,res;
struct node{   
    int l,r;
    long long sum;
}tree[N*4];
void build(int now,int l,int r){
    tree[now].l=l; tree[now].r=r;
    if(l==r){
        tree[now].sum=a[l]; return ;
    }
    int mid=(l+r)>>1;
    build(now<<1,l,mid);
    build(now<<1|1,mid+1,r);
    tree[now].sum=tree[now<<1].sum+tree[now<<1|1].sum;
}
void pushdown(int now){
    if(add[now]){
        add[now<<1]+=add[now];
        add[now<<1|1]+=add[now];
        tree[now<<1].sum+=(tree[now<<1].r-tree[now<<1].l+1)*add[now];
        tree[now<<1|1].sum+=(tree[now<<1|1].r-tree[now<<1|1].l+1)*add[now];
        add[now]=0;
    }
    return ;
}
void query(int now,int l,int r){
    int L=tree[now].l,R=tree[now].r;
    if(L>r||R<l) return ;
    if(L>=l&&R<=r){
        ans+=tree[now].sum; return ;
    }
    if(add[now]) pushdown(now);
    query(now<<1,l,r);
    query(now<<1|1,l,r);
    return ;
}
int main(){
	int x,y,z,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
      cin>>x>>y; a[x]+=y;
    } 
    build(1,1,n);
    for(int i=1;i<=n-m+1;i++){
		ans=0;
		query(1,i,i+m-1);
		res=max(res,ans);
    }
    cout<<res<<endl;
    return 0;
}
```
事实证明这题用前缀和还要快一些  
我的前缀和是396ms  
线段树688msQAQ


---


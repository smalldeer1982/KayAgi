# [MtOI2019] 永夜的报应

## 题目背景

在这世上有一乡一林一竹亭，也有一主一仆一仇敌。

有人曾经想拍下他们的身影，却被可爱的兔子迷惑了心神。

那些迷途中的人啊，终究会消失在不灭的永夜中……  

## 题目描述

蓬莱山 辉夜(Kaguya)手里有一堆数字。

辉夜手里有 $n$ 个非负整数 $a_1,a_2\cdots a_n$，由于辉夜去打 Gal Game 去了，她希望智慧的你来帮忙。  

* 你需要将这些数分成若干组，满足 $n$ 个数中的每一个数都恰好被分到了一个组中，且每一组至少包含一个数。  

定义一组数的权值为该组内所有数的**异或和**。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。

## 说明/提示

**样例 $1$ 解释：**

一种最优的分组方案如下：

- 将第 $1$ 个数和第 $3$ 个数分为一组，该组的权值为 $1\oplus 5 = 4$；
- 将第 $2$ 个数分为一组，该组的权值为 $2$。

该分组方案的所有组的权值之和为 $4 + 2 = 6$，可以证明，不存在权值之和更小的分组方案。

**样例 $2$ 解释：**

一种最优的分组方案如下：

- 将第 $1$ 个数和第 $5$ 个数分为一组，该组的权值为 $9\oplus 9 = 0$；
- 将第 $2$ 个数和第 $4$ 个数分为一组，该组的权值为 $18\oplus 25 = 11$；
- 将第 $3$ 个数和第 $6$ 个数分为一组，该组的权值为 $36\oplus 32 = 4$。

该分组方案的所有组的权值之和为 $0 + 11 + 4 = 15$。可以证明，不存在权值之和更小的分组方案。

### 子任务

- 对于 $80\%$ 的数据，满足 $n\leq 15$。
- 对于 $100\%$ 的数据，满足 $n\leq 10^6,a_i \leq 10^9$。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T1

出题人：disangan233



## 样例 #1

### 输入

```
3
1 2 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
9 18 36 25 9 32
```

### 输出

```
15```

# 题解

## 作者：角边边证全等 (赞：76)

因为a^b<=a+b,所以我们应该将所有数异或起来，从而得到最小的答案
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a,ans;
	scanf("%d",&n);
	scanf("%d",&ans);
	for(int i=2;i<=n;i++){
		scanf("%d",&a);
		ans^=a;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：⑨baka (赞：41)

易得 a^b<=a+b

这里提供下证明：

从每一位上的角度去考虑

枚举a和b第i位的数字是什么，有下面的式子：

当a第i位为0，b第i位为0时，第i位在加/异或下的答案：0+0=0 0^0=0

当a第i位为0，b第i位为1时，第i位在加/异或下的答案：0+1=1 0^1=1

当a第i位为1，b第i位为0时，第i位在加/异或下的答案：1+0=1 1^0=1

当a第i位为1，b第i位为1时，第i位在加/异或下的答案：1+1=2 1^1=0

可以发现，前3种不管是加还是异或答案都相同，只有在第四种情况下，异或的答案小于加的答案

所以得出 a^b<=a+b的结论

(异或实际上就是不进位的加法）

本题要求分组并把这些数加起来，使得总和最小

分组越少，异或越多，总和也就越小，所以只要分1组就可以

就是把所有的数都异或一下，即可

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	long long ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		long long x;
		scanf("%lld",&x);
		ans=ans xor x;
	}
	printf("%lld",ans);
	return 0;
}
```

~~小花絮：CQ队长dsg叫我写mtoi5题，写了有白泽球送，但是我数学功底太弱，遂放弃~~

---

## 作者：sishuinianhua (赞：13)

# 这道题是一道玄学题
刚开始我一看

###### 定义一组数的权值为该组内所有数的异或和。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。

然后我就打了暴力，很好80分拿到手


------------

但是在打暴力的途中我阴差阳错的将所有输入的数都xor了一下

emmm刚好等于答案

于是我就过了，草率的过掉了这道题qwq


```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a, ans;
int main(){
	scanf("%d", &n);
	scanf("%d", &ans);
	for(int i = 1; i < n; i++){
		scanf("%d", &a);
		ans ^= a;
	}
	printf("%d", ans);
	return 0;
} 
```

关于证明:

显而易见：

因为两个数的XOR一定小于两个数中较大的那个数，所以要求最小，只需要把所有的数全都XOR在一起就好了

qwq华丽丽的结束（蒟蒻发题解求轻喷）

---

## 作者：ahawzlc (赞：11)

这是一道结合位运算 XOR 的性质来找出正解的题。

----

首先来看一下异或 XOR：

XOR 是 1^0=1,0^1=1,0^0=0,1^1=0 的一种运算。

所以说白了，就是```相同为 0 ，不同为 1```。

再来看加运算，可以归为```某一位相同为0，不同为 1，全 0 为 0， 全 1 则高位加 1```。

结合上述来看，加运算比异或运算多了一条```全 1 则高位加一```。

所以可得 $x$ $xor$ $y \le x + y$。

题目要求求最小权值，由上式可得，异或优于加。

那么我们只需将所有数异或起来，这样即题目所求。

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,sum=0;
	cin>>n;
	while(n--) {
		int x;
		cin>>x;
		sum^=x;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：OuOu2021 (赞：11)

#### 蒟蒻的第三篇题解
------------

### 对每一位分析
- 0 ^ 0 = 0
- 1 ^ 0 = 0 ^ 1 = 1
- 1 ^ 1 =0

可以发现每一位异或的值一定小于等于它们二进制的那一位的和，所以就能推出两个数的异或和一定小于它们之和，所以这道题的答案就是全部异或起来啦

------------
### Talk is cheap,give me the code!
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans;
inline int read(){
	int f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))sum=sum*10+(ch^48),ch=getchar();
	return f*sum;
}
int main(){
    n=read();
    for(int i=1;i<=n;i=-~i)
        ans^=read();
	printf("%d\n",ans);
    return 0;
}
```

------------

### NY OIer出品



---

## 作者：disangan233 (赞：10)

## 题意

给你 $n$ 个非负整数 $a_1,a_2\cdots a_n$，让你将这些数分成若干组。定义一组数的权值为该组内所有数的**异或和**，求分出的所有组数的权值之和的最小值。

## Solutions

### Sol 1

直接暴搜，时间复杂度 $O\left(3^nn\right)$，期望得分：$80~pts$。  

### Sol 2  

假设所有数的异或和在 $2^t$ 位为 $0$，那么分到一组对答案没有贡献。

假设所有数的异或和在 $2^t$ 位为 $1$，那么显然无论如何分组，$2^t$ 位对答案的总贡献都不会为 $0$（因为当前位有奇数个 $1$），即 $1$ 是答案下界。

因此，将所有数分为一组即为最优答案。

输出所有数的异或和即可，时间复杂度 $O(n)$，期望得分：$100~pts$

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0,y=1;while(nc=gc(),(nc<48||nc>57)&&nc!=-1)if(nc==45)y=-1;Bi=1;
        x=nc-48;while(nc=gc(),47<nc&&nc<58)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*y;
    }
    in db gf() {re a=read(),b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi):a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
int n,ans;
int main()
{
    n=read();
    while(n--) ans^=read();
    write(ans,'\n');
    return ot(),0; 
}
```

---

## 作者：1saunoya (赞：5)

$\text{这题我们考虑取极端值。}$
$\text{举个栗子：一个数列 1 2 3 4 5 6}$

$\text{讲道理 你可以每个一组 算出来是1+2+3+4+5+6 = 21}$

$\text{但是异或之后}$ 1^2^3^4^5^6 = 7

$\text{或者换种说法 a xor b 的最好情况是 a + b}$

$\text{所以最小值肯定是一个序列集体异或}$

```cpp
// Isaunoya
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC diagnostic error "-std=c++11"
#include<bits/stdc++.h>
#define int long long
using namespace std ;
#define rep(i , j , n) for(register int i = j ; i <= n ; i ++)
#define Rep(i , j , n) for(register int i = j ; i >= n ; i --)
#define low(x) x & -x
#define go(u) for(register int i = head[u] ; i ; i = e[i].nxt)
inline int read() { register int res = 0 , f = 1 ; register char c = getchar() ;
    for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
    for( ; isdigit(c) ; c = getchar()) res = (res << 1) + (res << 3) + (c & 15) ;
    return res * f ;
}const static int N = 1e6 + 10 ;
const int Mod = 998244353LL ;
template<typename T> inline void print(T x) { if(x > 9)  print(x / 10) ; putchar(x % 10 + '0') ; }
template<typename T> inline void Pr(T x , char c = '\n') { if(x < 0) putchar('-') , x = - x ; print(x) ; putchar(c) ; }
inline int PW(int x , int y , int Mod = Mod) { register int ans = 1 ;
    for( ; y ; y >>= 1 , x = (x * x) % Mod) y & 1 ? ans = (ans * x) % Mod : 0 ;
    return ans ;
} inline int Inv(int x , int Mod = Mod) { return PW(x , Mod - 2 , Mod) ; }
int n , m ;
int a[N] ;
signed main() {
    // freopen("text.in" , "r" , stdin) ; freopen("text.out" , "r" , stdout) ;
    int ans = 0 ; n = read() ;
    rep(i , 1 , n) ans ^= read() ;
    Pr(ans) ;
    return 0 ;
}
```

---

## 作者：Starlight237 (赞：4)

upd：错误的符号已经修正。

首先，当然有$a$^$b$=$b$^$a$，又因为异或是不进位的加法，故$a$^$b\le a+b$。

因此，最优的分组法必然为所有数分为一组。若分为多组，则由于上述第二条，必然劣于所有数分为一组的方法。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 1000000
extern "C"{
namespace io{
	static char in[IOSIZE],*p=in,*pp=in,out[IOSIZE],*q=out,ch[20],*t=ch;
	inline char gc(){return p==pp&&(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?EOF:*p++;}
	inline int read(){
		reg int x=0;reg char ch,f=0;
		while(!isdigit(ch=gc()))f|=ch=='-';
		while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();
		return f?-x:x;
	}
	inline void write(int x){
		!x&&(*q++=48),x<0&&(*q++='-',x=-x);
		while(x)*t++=x%10+48,x/=10;
		while(t!=ch)*q++=*--t;
		*q++=' ';
	}
	inline void flush(){fwrite(out,1,q-out,stdout);}
}}
#define rd io::read
#define wt io::write
static int n;
static long long ans;
int main(){
	n=rd();
	for(reg int i=1;i<=n;++i)ans^=rd();
	wt(ans);
	io::flush();
	return 0;
}
```

---

## 作者：fzwfzwfzw (赞：4)

## 我们来考虑一下
# a^b永远小于等于a+b
### 所以我们将所有数分成一组异或求和即可
```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int main(){
	int n;
n=read();
	int q;
	int ans;
	ans=read();
	for(int i=2;i<=n;i++)
	{
		q=read();
		ans^=q;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：gyh20 (赞：3)

我们知道^为异或运算，而异或运算有一个性质：

### a^b<=a+b

所以无论怎样分，结果是肯定不大于全部异或的值。

代码如下：
```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(200000)
#pragma GCC optimize(2)
#include<cstdio>
using namespace std;
inline int read(){
	int t=0;
	char v=getchar();
	while(v<'0'||v>'9')v=getchar();
	while(v>='0'&&v<='9'){
		t=(t<<3)+(t<<1)+v-'0';
		v=getchar();
	}
	return t;
}
int n,ans;
int main(){
	
	n=read();
	while(n--){
		ans^=read();
	}
	printf("%d",ans);
}
```


---

## 作者：My_666 (赞：3)

# 大水题！！
 ~~这题有样例解释要比没有难qwq~~
 
 当时一直在想他给的样例解释有什么特别的地方，看了5分钟啥也没看出来。于是乎自己把样例的二进制写出来后，发现了一个神奇的规律：当所有的二进制位有奇数个1，将答案的对应位直接赋为1，若为偶数则赋为0（将所有的数都异或起来）。
 
#####  AC！！！

好了，下面来证明做法的正确性:

异或有一个特别的性质：不进位的二进制加法。

显然，两个数异或的值一定小于等于两个数的和。

证毕。

代码就不用解释了吧？

#### 接下来上代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 5;

typedef long long ll;

//dalao的读入优化 
template<class T> void read(T &x) {
    x = 0; int f = 0; char ch = getchar();
    while (ch < '0' || ch > '9') {f |= (ch == '-'); ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();}
    x = f ? -x : x;
    return;
}

int n, a[N], m;

int main() {
	read(n);
	for (int i = 1; i <= n; i++) {
		read(a[i]);
		m = m ^ a[i];
	}
	printf("%d", m);
	return 0;
}
```

## 感谢！


---

## 作者：HohleFeuerwerke (赞：2)

[题目链接](https://www.luogu.org/problem/P5514)
--
### 题目描述
辉夜手里有 $n$个非负整数$a_1-a_n$，由于辉夜去打Gal Game去了，她希望智慧的你来帮忙。

你需要将这些数分成若干组，满足 $n$个数中的每一个数都恰好被分到了一个组中，且每一组至少包含一个数。
定义一组数的权值为该组内所有数的异或和。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。

----

先给非满分做法。

~~当年本蒟蒻打比赛的时候一道题都没有做出来。~~

前置知识：数学够拽QwQ。

----

Solution1：直接输出某数
输出1，两个样例

期望得分0分，实际得分零分。

---

Solution2：~~看样例边蒙边凑~~贪心

看数据范围：$n<=1e6$ 并且时长开在标程1.6倍以上，自然想到 $O(n)$ 算法。想到贪心。

但是我们注意到这里的贪心也是需要$O(n^2)$，期望拿部分分。

期望得分80分，实际得分0分。

虽然0分但是还是讲讲思路吧：

看样例说明：注意到两个样例中，最大的数永远和与其xor的最小的数在同一组，我们推测实际情况就是如此，毕竟考试想不出别的什么东西了。

~~蒻~~

贴出贪心代码
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
const int maxn=1e6+5;
int n,a[maxn],ans;
bool used[maxn];
typedef long long ll;
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	memset(used,sizeof(used),false);
	for(int i=1;i<=n;i++)
	{
		if(!used[i])
		{
			used[i]=true;
			ll min=1e13;
			int minj=0;
			for(int j=i+1;j<=n;j++)
			{
				if(((a[i]^a[j])<=min)&&(!used[j]))
				{
					min=(a[i]^a[j]);minj=j;
				}
			}
			ans+=(a[i]^a[minj]);
			used[minj]=true;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
本地可以跑一跑，毕竟两个样例都对了
~~不要脸的认为较优解和最优解差距不大~~

---
Solution3：暴搜

万物皆可$dfs$

不讲了~~我虽然当时写完了但是没交上去我以为我的贪心很对~~

期望得分80分，实际得分80分。

---
Solution4：正解~~不知名数学方法~~

命题：

给定$n$个数，求分组异或和后异或和的和的最小值，请你证明：这个$min=a_1$ $xor$ $a_2 xor$ $xor$...$xor$ $a_n$

关于为什么这个命题成立许多题解没有详细说明我来补充补充

先是一开始的$xor$操作，需要知道的是$xor$是指将两个数$a$与$b$对其进行二进制转化操作后再进行一个简单操作，命名为$xor$

这个操作具体流程是将二进制下的$a$与$b$进行每一位的比对 如果对于这一位两个数有且仅有一个$1$存在，则对于$xor$的结果，这一位为$1$，否则为$0$。


明确了操作，具体看到过程。

----

引理：
$a$ $xor$ $b<=a+b$

证明：

令$x=a+b$

$a$ $xor$ $b$的结果$p = \sum_{i=1}^{i<=x}{2^i}- \sum_{j=1}^{j<=x}2^j(if both$ $a$ $ and$ $b$ $are$ $zero$)

而对于前一项，即为$x$的二级制转换为十进制的计算方法，所以前一项为$x$

显然后一项大于一。所以$p<=x$，$Q.E.D$

---

回到命题，由引理，$a$ $xor$ $b$ $+$ $c$ $xor$ $d<=a+b+c+d$

同理，$a_1+a_2+a_3>=$ $a_1$ $xor$ $a_2$+$a_3>=a_1$ $xor$ $a_2$ $xor$ $a_3$

不断循环下去，令所有数之和为$sum$，所有数的异或和为$xorsum$

$sum=\sum^{i<=n}_{i=1}a_i>=a_1$ $xor$ $a_2$ $...$ $xor$ $a_n=xorsum$

所以无论怎么取数对，都不会小于$xorsum$，大于$sum$

我们得出了这题的解。

同时我们还得出了这题的另一种形式的命题的解。
这个命题是：“...求最大值”

给出代码~~全异或起来就行了~~
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
const int maxn=1e6+5;
int n,a[maxn],ans;
bool used[maxn];
typedef long long ll;
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	    ans^=a[i];
	cout<<ans<<endl;
	return 0;
}
```
---

upd: 2019-10-4

Solution5

后来又想到了一种正解，线性dp

和贪心一样是看数据范围想到的。

```cpp
#include<bits/stdc++.h>
#define MAXN 1000005
#define int long long
using namespace std;
int n;
int dp[MAXN],a[MAXN];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	dp[1]=a[1];//初始化 
	for(int i=1;i<=n;i++)
	{
		dp[i]=max(dp[i],dp[i-1]^a[i]);//如果是更优解就更新 
	}
	cout<<dp[n]<<endl;//输出 
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：2)

~~签到题差点签不到~~  
由于异或有交换律,所以不用纠结运算的顺序。  
读进来一个数,顺序扫描原数组,只要异或值小于等于两者之和就把数字异或进去，否则插到数组末尾即可。  
```cpp
#include <cstdio>

using namespace std;

const int maxn = 1000010;
int a[maxn], au = 0;

const int sz = 2000000;
char buf[2000000], *p1 = buf, *p2 = buf;
inline char gc() { return p1==p2&&(p2=(p1=buf)+fread(buf,1,2000000,stdin), p1==p2)?EOF:*p1++; }
inline void read(int &x) {
    x = 0; char ch = gc();
    while(ch < '0' || ch > '9') ch = gc();
    while(ch >= '0' && ch <= '9') x = (x<<3)+(x<<1)+(ch&15), ch = gc();
}

int main() {
	
	int n, t;
	bool flag;
	read(n);
	for(int i = 1; i <= n; i++) {
		flag = false;
		read(t);
		for(int j = 0; j < au; j++)
			if((a[j]^t) <= (a[j]+t)) {
				flag = true;
				a[j] ^= t;
				break;
			}
		if(!flag) {
			a[au++] = t;	
		}
	}
	t = 0;
	for(int i = 0; i < au; i++) t += a[i];
	printf("%d\n", t);
	return 0;	
}
```

---

## 作者：andyli (赞：2)

本题只需将输入的所有数异或并输出结果即可，不需要进行模拟分组等操作。  
代码如下：  
```cpp
#include<cstdio>

int main() {
	int n;
	scanf("%d", &n);
	int x, ans = 0;
	for (int i = 0; i < n; i++)
		scanf("%d", &x), ans ^= x;
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Guess00 (赞：2)

### $\text{本题思路:贪心}$

---
$\text{看一下数据},n\leq 1e6,\text{要求线性}.$

$\text{也就是说,对于每个数,要考虑加上还是异或.}$

$\text{对比一下「异或」和「加法」:}$

> $\text{如果有两个数25和7,那么它们的和为32.}$
>
> $\text{异或和:}$
>
> $25:1\quad1\quad0\quad0\quad1$
>
> $7:\;\;0\quad0\quad1\quad1\quad1\quad\wedge$
>
> $-----------$
>
> $30:1\quad1\quad1\quad1\quad0$

$\text{可发现两数异或和最坏情况就是两数的和.}$

$\therefore\text{最小值(答案)就是整个数列的异或和.}$

$\text{时间复杂度O(n)}$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
#define int long long
int n,i,x,ans;
inline void read(int &x)
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
		if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)
{
    if (x<0)
        putchar('-'),x=-x;
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n);
	for (i=1;i<=n;i++)
	{
		read(x);
		ans^=x;
	}
	print(ans);
	return 0;
}
```

---

## 作者：爱滑稽的蒟蒻 (赞：1)

这题应该是你谷~~某月赛~~中的签到题……

看题目，要求异或和的最小值，那么异或是什么运算呢？

简单解释一下，异或就是把两个数字转成二进制后对应位上的数字如果相同则为0，反之则为1

举个~~栗子~~，11和21的异或值是这样算的：
	
    11的二进制是1011
    
    21的二进制是10101
    
    那么它们的异或值就是11110=30<11+21
    
    所以很显然任意两个数的异或值小于它们的和
    
    
所以只要把所有数异或起来就好了

~~好水~~~
    
    
贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char c=getchar();int x=0;bool f=0;
    while(!isdigit(c))f^=!(c^45),c=getchar();
    while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
    if(f)x=-x;return x;
}
inline void write(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);
	putchar(x%10+'0');
}
int a[1000005];
int main()
{
	int n=read();
	int sum=0;
	for(int i=1;i<=n;i++)
	a[i]=read();
	sum=a[1]^a[2];
	for(int i=3;i<=n;i++)
	sum^=a[i];
	cout<<sum;
}
```


---

## 作者：新时代的黑客 (赞：1)

从n的大范围可知为普通的线性dp，直接上码。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll M=1000005;
ll n,dp[M],a[M];
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+1+n);
	dp[1]=a[1];
	for(ll i=2;i<=n;i++){
		dp[i]=max(dp[i],dp[i-1]^a[i]);//是不动还是加入a[i]经行异或更优
	}
	printf("%lld",dp[n]);
	return 0;
}
```


---

## 作者：Konnyaku_ljc (赞：1)

关于这道题，很多人看到之后可能想：~~mmp~~ 异或和是什么？  
答：异或和就是一串数异或起来。
例如：a/b/c 的异或和为 a xor b xor c;  
所以，我们可以看出异或和的一个性质—— (a xor b) xor c = a xor (b xor c);  
所以本题什么求权值最小，明明就是求给你一串数它们的异或和！！！   
~~不愧是签到题~~
```cpp
#include<iostream>
using namespace std;
int n,a,ans;
int main()
{
	cin >> n >> ans;
	for ( int i = 2; i <= n; i++ ) cin >> a,ans^=a;
	cout << ans;
}
```

---

## 作者：chinaxjh (赞：1)

# 前言：
这道题作为比赛的T1，显然难度不高，但是要避免进行复杂的思考，我已开始就犯了这个错误，但幸运的我看了看样例之后盲猜猜出了做法。这其实是一道不错的数论题。
# 瞎想
### 瞎想做法1
爆搜，暴力枚举放置，良心的出题人竟然给了80$pts$，太意外了。
### 瞎想做法2
看了一下样例，盲猜是异或一下，再加上数据达到了$10^6$，必然是$O(n)$的复杂度，于是打了个代码直接过了样例，上去一交就满分了。

关于这样子为什么可以过，我想出来一个一句话的解释：

**两个数相加或者异或，对于它们答案的二进制下每一位的结果是一样的（不考虑加法进位），但加法需要进位，所以两个数异或的结果必然小于相加。**

# $AC$ $Code$
### $Pascal$ $AC$ $Code$
```pascal
var
  n,i,ans,k:longint;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(k);
    ans:=ans xor k;//异或一下
  end;
  writeln(ans);
end.
//pascal IO较慢，比c++慢很多，再加上不能优读，不推荐使用
```
### $C++$ $AC$ $Code$
```
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
int main()
{
  scanf("%d",&n);
  while (n--)
  {
  scanf("%d",&k);
  ans^=k;
  }
  printf("%d",ans);
}
//建议写快读+氧气，我很懒，就不写了
```
# 总结：
这是一道不错的数论题，和这道题代码一样的题其实是有的。比如给出n个数，求这n个数中唯一出现奇数次的数（保证只有一个），这道题的代码完全可以迁移运用，异或操作其实是很有意思的，感兴趣的同学可以自己去理解


---

## 作者：Dorbmon (赞：1)

这个题目我觉得出题人的那个题解不是很好。
难道不是基于这个不等式：
a ^ b <= a + b 吗？
这样可以得出 全部异或 一定不差于 分组 啊。
这个不等式的证明也是很容易。
因为异或一定不会进位的，而加法可能是会进位的，如果对于一个二进制位他们和与异或都不进位，那就说明异或也是0，而和至多为1。
完整代码，速度很快：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
using namespace std;
inline long long read(){
    char ch = getchar();long long x = 0,f = 1;
    while(ch < '0' || ch > '9'){
        if(ch == '-') f = -1;
        ch = getchar();
    }while('0' <= ch && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }return x * f;
}

int main(){
	int n = read ();
	long long ans = read ();
	for (int i = 2;i <= n;++ i) {
		ans ^= read ();
	}
	cout << ans << endl ;
    return 0;
}
/*
1 10 101

*/

```


---

## 作者：StudyingFather (赞：1)

我们考虑 xor 运算的二进制意义：xor 实际上可以视为不进位的加法。

而题目要求的是若干组数 xor 和的总和。注意到普通加法是要进位的，所以不进位的加法加出来的总和显然小于等于普通加法的总和。

所以答案就是所有数的 xor 和。

~~代码不贴应该没事吧~~

---

## 作者：wudiss8 (赞：1)

~~趁还没有题解赶紧抢占先机~~

前置芝士：
异或

异或，有人称它为不进位加法，具体运算规则如下

1 xor 1=0

0 xor 1=1

1 xor 0=1

0 xor 0=0

这个题在比赛标记中属于签到题，还算比较简单了，没有什么特别恶心的数论

思路:两个数异或起来一定小于等于他们的和

就一句话！想一想是不是这样

因为异或是两个数二进制下对应的每一位异或的，所以两个数如果相同二进制下没有相同位上有1，就相当于两个相加，如果有相同位置上有1，那么1 xor 1=0,结果将会比和更小

就拿第二个样例来说

6

9 18 36 25 9 32

计算过程
9 xor 18=27

27 xor 36=63

63 xor 25=38

38 xor 9=47

47 xor 32=15

发现异或首先满足交换律，且与分组最小和是等价的！（或者说全部分为一组异或起来）

然后我们就可以很愉快地把所有数异或起来解决这道题了~

$code:$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
inline int read(){
	char c=getchar();
	int s=1,f=0;
	while(c<'0' or c>'9'){
		if(c=='-')
		s=-1;
		c=getchar();
	}
	while(c>='0' and c<='9'){
		f=f*10+c-'0';
		c=getchar();
	}
	return s*f;
}
signed main(){
	n=read();
	for(register int i=1;i<=n;i++)
	ans=ans^read();//^符号在C++中是异或的意思	
   printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

0^0=0+0

0^1=1^0=1+0=0+1

1^1<1+1

a^b<=a+b

综上所述，它们的异或总数一定小于等于它们的和

所以全异或起来就好了！！！
```cpp
#include <bits./stdc++.h>
using namespace std;
int n,ans,a;
int main()
{ 
 cin>>n; cin>>a;
 ans=a;
 for(int i=0;i<n-1;i++)
 	ans^=a;
 cout<<ans<<endl;
 return 0;
} 
```


---

## 作者：Doveqise (赞：0)

这道题 比赛签到题 正确性证明如下：  
异或可以理解为不进位加法  
而你分组后权值需要进行进位加法  
所以显然把所有数字分到一组是最优的  
依个数异或即可  
下面贴代码（为什么这个东西还要代码啊  
```cpp
#include<bits/stdc++.h>
using namespace std;
signed main()
{
    int n;
    scanf("%d",&n);
    int sum=0;
    for(int i=1,t;i<=n;i++)
    {
        scanf("%d",&t);
        sum^=t;
    }
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：小酱666 (赞：0)

### 蒟蒻的第一篇题解
~~其实这道题当初是乱搞搞出来的（逃~~

[这是比赛方给出的题目解释](https://www.luogu.org/blog/disangan233/mtoi2019-yong-ye-di-bao-ying-xie-ti-bao-gao)

首先看一下题目，![](https://cdn.luogu.com.cn/upload/pic/74589.png)
再结合一下异或的性质，你会有如下结论：
### **“a异或b小于等于a加b”**（可以写代码验证一下）
所以说对于任意的分组，他们权值的异或值小于他们的权值和
由此，分多个组，不如只分一组，即只分一组时，结果是最佳的。

最后，上代码
```
#include<iostream>
using namespace std;
int ans,n,a,s;
int main()
{
	std::ios::sync_with_stdio(false);//关掉流同步加快读入
    cin>>n>>a;
    ans=a;
    for(int i=1;i<=n-1;i++)
    {
        cin>>s;
        ans=ans^s;
    }
    cout<<ans; 
    return 0;
}
```
希望这篇补充题解管理员大大能够给过，十分感谢！


---

## 作者：Cefola_Kiroxs (赞：0)

介绍另外一种本题的理解方法。

由于题目中并没有要求分组的组数，所以根据异或的性质，我们自然是希望能 “消掉” 的 1 越多越好。

因此，如果给出的数列中，第 $i$ 位出现了偶数次 1，那肯定将这偶数个 1 放一组会最好；如果出现了奇数次 1，那不管如何肯定都消不掉这一位 1。

因此，将所有数异或起来，自然能被消掉的 1 都被消掉了，不能被消掉的 1 都还留着，这就是解法啦。

```cpp
#include <cstdio>

//Const Optimize
#define il inline
#define rr register
void readint(int &x) {
	x = 0; int f = 1;
	char c = getchar();
	for (; c <  '0' || c >  '9'; c = getchar()) if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar()) x = (x * 10) + (c - '0');
	x *= f;
}
void outpint(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) outpint(x / 10);
	putchar(x % 10 + '0');
}

int main()
{
	int n;
	readint(n);
	
	int ans = 0;
	for (rr int i = 1, x; i <= n; ++i) {
		readint(x);
		ans ^= x;
	}
	outpint(ans);
	return 0;
}
```

~~（比赛时只 A 了这题，我菜爆）~~

不过比赛质量是真的高，希望明年还能看见！

---

## 作者：zzy2333 (赞：0)

异或的本质是不进位加法，所以把所有数异或起来一定比先异或再加起来更小（有可能相等）。

所以把所有数异或起来就是答案。

然后就没有然后了，直接上代码吧(~~注释掉的代码是一时脑抽。。。~~)
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
long long ans=0;
inline int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }
    return x;
}
int main(){
/*	power[0]=1;
	for(int i=1;i<=30;i++){
		power[i]=power[i-1]*2;
	}
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=30;j++){
			if((i>>j)&1)cnt[j]++;
		}
	}
	for(int i=0;i<=30;i++){
		if(cnt[i]&1)ans+=power[i];
	}*/
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		ans^=read();
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：⚡LZSY01_XZY⚡ (赞：0)

异或运算又叫**不进位加法**，任意多个数的异或和一定小于等于他们的和。

$e.g.$ 

1. 
	- $10~xor~9=1010_{(2)}~xor~1001_{(2)}=0011_{(2)}=3$
	- $10+9=1010_{(2)}+1001_{(2)}=10011_{(2)}=19$

2. 
	- $10~xor~11=1010_{(2)}~xor~1011_{(2)}=0001_{(2)}=1$
	- $10+11=1010_{(2)}+1011_{(2)}=10101_{(2)}=21$

所以，我们只需将所有的数异或起来就好了。

$code:$
```cpp
#include <cstdio>
using namespace std;

template<typename T>
inline T read()
{
	T x=0,f=1;char c=getchar();
	while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return x*f;
}

int n,ans;

int main()
{
	n=read<int>();
	for (int i=1;i<=n;i++) ans^=read<int>();
	printf("%d\n",ans);
	return 0;
}
```
$Please~give~a~like.$

---

## 作者：ShineEternal (赞：0)

## 往这看！通俗易懂！



# 题目链接：

https://www.luogu.org/problem/P5514

# 分析：

这道题乍一看很没有头绪，于是：

**爆搜**

时间复杂度：$O()$

**期望**得分：$80pts$

这可是pjT2啊，显然我们要找满分的做法。

---

我们看到数据范围：

$n\leq10^6$

这大概就是$O(n)$解决？

于是我就考虑把所有的数给异或起来，因为对照样例发现对了。

但这是为什么呢？

~~我只是定性的判断了一下~~

我们知道一个性质：**两个数的相加和一定大于等于两个数的异或和**

- 因为在异或下一定是没有进位的。而加法是有可能进位的

进行了分组之后我们相当于有一些数是相加的（组与组之间）

如果我们把所有数异或起来，就相当于原本的组之间由相加变成了异或。

例如：a,b,c三个数

原来可能是：

$a+(b$ $xor$ $c)$

现在就是：

$a$ $xor$ $(b$ $xor$ $c)$

~~异或的结合律~~

自然比分组更优（

当然也可能等于分组的情况。

这就是样例带来的迷惑（雾

---

时间复杂度：$O(n)$

---

# $code$:

```cpp
#include<cstdio>
using namespace std;
int main()
{
	long long n;
	long long ans;
	scanf("%lld",&n);
	long long x;
	scanf("%lld",&x);
	ans=x;
	for(int i=2;i<=n;i++)
	{
		scanf("%lld",&x);
		ans=ans^x;
	}
	printf("%lld\n",ans);
	return 0;
} 
```

---

## 作者：liaokq (赞：0)

# 争当第一个发题解的蒟蒻！

~~（我就这一题会做……）~~

## 题目：

你需要将这些数分成若干组，满足n个数中的每一个数都恰好被分到了一个组中，且每一组至少包含一个数。

定义一组数的权值为该组内所有数的异或和。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。

## 然后到我说话的时间了

以上的话你都别管 ~~（都是屁话）~~,听我把题目改一下：

## 求这n个数的异或和！

就行了

（知道异或性质的童鞋应该知道为什么）

直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,t,ans,i;
inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}

inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
//卡时间以提升排名用的快读和快写，使得耗时只有88ms

int main()
{
	n=read();ans=read();
	for(i=2;i<=n;i++)
	{
		t=read();
		ans=ans^t;//C++福利：异或运算可以用"^"表示
	}
	write(ans);
	return 0;//就这么简单
}
```


---

## 作者：Alarm5854 (赞：0)

这题思路有一定的难度，可能一开始还是会想到$O(n^2)$的做法，然后$TLE$了最后两个点，那么怎么$AC$这道题呢?这里教你们一个做法:对于两个非负整数数$a,b$，都有$a\ xor\ b\le a+b$，所以这就非常简单了：
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n,a[1000001];
    int main(){
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
            scanf("%d",a+i),a[i]^=a[i-1];//一边输入一边运算
        printf("%d",a[n]);//最终的答案就是a[n]
        return 0;
    }
```
虽然这个代码十分简单，就是求异或和，但是还是有一定的思维难度的。

---

## 作者：nxt_permutation (赞：0)

其实一组数分组的异或和的最小值。就是将这些数进行异或和操作。

~~别问我这个规律是怎么推的~~
```
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	int n;
	cin>>n;
	long long a[n];
	for(int i=0;i<n;i++) scanf("%lld",&a[i]);
	long long ans=a[0];//初始值为第一个数
	for(int i=1;i<n;i++) ans=ans^a[i];//将所有数的异或和求出
	cout<<ans<<endl;
	return 0;//完美结束
}
```

---


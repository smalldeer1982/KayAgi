# 小 E 与美食

## 题目背景

小 E 是一个热爱美食的高中生，但吃的太多会导致他身体不舒服，他想找到一个能让他最舒服的方案，快来帮帮他！

## 题目描述

小 E 有 $n$ 种美食可供选择，每种美食只能吃一次，第 $i$ 种美食有一个美味值 $a_i$，吃下一个美味值为 $a_i$ 的美食可以让小 E 的满足感提升 $a_i$。

但是小 E 的胃是有极限的，每吃下一个美食，他的饱腹感就会提升 $1$。

小 E 最后的舒适度是他的满足感的平方除以他的饱腹感，你的目标是求出他舒适度能达到的最大值。

## 说明/提示

**提示**

建议输出**至少 $8$ 位**有效数字。

**样例解释**

容易发现两种美食都吃是最优的，舒适度为 $\frac{(2+1)^2}{2} = 4.5$。

**数据范围**

对于 $30 \%$ 的数据，$n, a_i \le 20$。

对于 $50 \%$ 的数据，$n, a_i \le 2000$。

对于另 $15 \%$ 的数据，所有 $a_i$ 都相等。

对于 $100 \%$ 的数据，$1 \le n \le 3 \times 10^{5}$，$1 \le a_i  \le 10^6$。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
4.50```

# 题解

## 作者：lytqwq (赞：35)

在吃一样量的食物时，明显吃好吃的舒适度最大，所以我们对每种食物的美味度排序，优先吃最美味的食物，然后对吃1,2,3......n种食物的最大舒适度取max，输出就行了。

~~你以为这个题这么简单吗？？？~~


坑点1：美味度的sum要开long long 。qwq

坑点2：sum的平方会炸long long。所以我们要用sum先除食物种数再*sum 。qwq

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 300001
int n;
int a[N];
long long int sum;
double maxn;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);//排序
	for(int i=n;i>=1;i--)//优先吃好吃的食物
	{
		sum+=a[i];
		maxn=max(maxn,sum*1.0/(n-i+1)*sum);//先除再乘qwq
	}
	printf("%lf",maxn);
}
```

~~为什么我橙题都WA3遍啊QAQ~~


---

## 作者：Ares゜ (赞：11)

### 我是一个学习c++不足3个月的蒟蒻，冒险尝试一个橙题，也多次Wa了，在大佬的帮助下终于改对了
这道题还是普及-里面比较简单的了，但本蒟蒻经多次更正终于AC了
思路很简单：排序，先吃美味的
后面再进行计算
```
#include<bits/stdc++.h> 
//注意用万能头
using namespace std;
int a[1000001],b,n;//开数组
double d,m,c,e;//高精度
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)//输入
    cin>>a[i];
    sort(a+1,a+1+n);//排序
    for(int i=n;i>=1;i--)//从最美味的开始吃
    {
        m+=a[i];//累加满意值(美味啊)
        c++;//累加饱腹值
        d=max(d,m/c*m);//找最大值，先除再平方，不然会炸
        e=1.0*d;//确保精度
    }
    printf ("%.8lf" , e);//最好不要用cout
    return 0;
}
```
本蒟蒻的第一篇题解，如有不当之处请诸位大佬指正

---

## 作者：phigy (赞：7)

~~这道题看似很困难实际不是很难~~


------------
首先我们设已经吃了k个食品
，满足感为ans_{k}接下来要选的食物的满足感为a

则接下来的满足感为 $\frac{ans_{k}+a}{k+1}$

由小学可得分母不变分子越大分数越大

所以我们每次都要选最大的

最大的选了舒适度都会降低小的则更不能选

所以排完序枚举即可

tsd:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

long long n,a[2000000];
double ans;
int cmp(int a,int b)//排序函数，大数在前
{
    return a>b;
}
int main()
{
    int i,j,k;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1,cmp);
    ans=a[1];//第一个必须选
    for(i=2;i<=n;i++)
    {
        if( (ans*ans*1.0)/(i-1) < ((ans+a[i])*(ans+a[i])*1.0)/i )//恶心的直接判断（大佬勿喷）
        {
            ans+=a[i];
        }
        else
        {
            break;//弹出
        }
    }
    printf("%0.9f",(ans*ans*1.0)/(i-1));//使用printf输出精确到九位小数，
    return ^.^;
}
```
# 感谢管理员们仔细的审核！

---

## 作者：爱晚亭哦 (赞：6)

**考虑饱腹感的递增性，很容易想到贪心**

贪心策略：

1. 把美味值从大到小排序一遍
2. 计算当前舒适度
3. 如果当前舒适度小于上一次舒适度，输出上一次舒适度并结束程序

我们看数据范围，发现舒适度会爆int，平方会爆long long，所以考虑开long long，求舒适值时先除饱腹感。

然后我们就愉快地AC啦

~~快读优化一下可以快100ms+ qwq~~

Code:

```
#include<cstdio>
#include<algorithm>//快排头文件
using namespace std;
int n;
double ans=0.0;//double类型初始值0.0
//不是卖萌qwq
long long sum=0;//注意要开long long
int a[300001];
inline int read()
{
	int x=0;
	char ch;
	ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x;
}//快读
int cmp(const int &x,const int &y)//从大到小快排
{
	return x>y;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		if(1.0*(sum+a[i])*(sum+a[i])/i>ans)//贪心核心
		{
			ans=1.0*(sum+a[i])/i*(sum+a[i]);//为了防止精度误差，建议要乘1.0
			sum+=a[i];
		}
		else
			break;//如果当前舒适值比上次小，结束程序
	}
	printf("%.8lf",ans);
   //return 0？
}
```

~~大根堆？这辈子都不会用优先队列的~~

---

## 作者：Magallan_forever (赞：6)

一开始我以为是背包，本来也没时间打比赛就只爆切了div2T1，没仔细想，觉得时间不够了就去赶作业了

~~QAQ~~

直到赛后我才明白这是个贪心：对于吃$ k $次食物的情况，由于吃任意$ k $个饱腹感都为$ k $，所以我们显然选择美味值前$ k $大的食物吃

证明如下：**注意，下面是重点**

对于我们要吃的$ k $个食物，我们做如下考虑：

1. 如果当前这个不是前$ k $大，那就一定有一个美味值前$ k $大的食物没有被选中但是比它更美味，那就选这个没有被选中的
2. 当前这个是前$ k $大的，根据第一条，其他美味值没有进入前$ k $的食物对答案的贡献不会比当前这个更优，所以应该选当前这个

所以我们从1枚举到n，对于每一个计算
$$ maxn=max(maxn,\sum_{j=1}^i a[j]/i) $$
$ i $是当前枚举的数

这样显然是最优的，因为对于任意一个方案，它的答案都不会大于与它长度相同但是经上述方式构造出来的方案

直接求和是$ n^2 $的，所以注意需要排序之后前缀和优化，时间复杂度$ nlog_2n $（排序的时间），前缀和要开```long long```

code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[300001];
long long sum[300001];//一开始没开long long WA60
bool cmp(int a,int b){
	return a>b;
}
int main(){
	int n;
	double maxn=-1.0;//注意初始化
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",a+i);
	sort(a+1,a+1+n,cmp);//从大到小排序保证前k大
	for(int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n;++i) maxn=max((double)sum[i]*sum[i]/i,maxn);
	printf("%lf",maxn);//double的格式符是%lf
	return 0;
}
```

---

## 作者：k2saki (赞：5)

这道题其实不用sort，因为c++的STL里有很多可以自动排序的容器。

今天我就介绍STL的一种数据结构：优先队列。

## priority_queue<int> q
  
 这个是默认的大根堆，也就是从大到小排序。
  
  如果你想要小根堆，很简单，只需改成
  
## priority_queue<int,vector<int>,greater<int>> q
  
  这道题只需用大根堆，从大到小排序，所有都对比一遍即可
  
##   $ Code: $
  
```
#include <bits/stdc++.h>
using namespace std;
int n,a[300001];
priority_queue<int> q;
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		q.push(a[i]);//放进堆里
	}
	
	long long baofu=0,manzu=0;
	
	double shufu;
	
	double mx=-1;
	
	for(int i=1;i<=n;++i)
	{
		baofu++;//饱腹感
		manzu+=q.top();//满足感
		q.pop();//移除出堆
		mx=max(mx,1.0*manzu*manzu/baofu);//最大舒适感
	}
	
	printf("%.8f",mx);
	
	return 0;
}
```


---

## 作者：VenusM1nT (赞：4)

贪心。  
排序后从大的开始取，每取一个记录一下答案即可。
```cpp
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define MAXN 300005
#define reg register
#define inl inline
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
int n,a[MAXN];
double cnt,ans;
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
inl bool Cmp(reg int x,reg int y)
{
	return x>y;
}
int main()
{
	Read(n);
	for(reg int i=1;i<=n;i++) Read(a[i]);
	sort(a+1,a+n+1,Cmp);
	for(reg int i=1;i<=n;i++)
	{
		cnt+=(double)a[i];
		ans=max(ans,cnt*cnt/(double)i*1.0);
	}
	printf("%.8lf\n",ans);
	return 0;
}
```

---

## 作者：小鲍bob (赞：2)

### 难度还行

先分析一下题目：就是求最大舒适度

再分析一下样例：

为2时，满足感为4

为2 1时，满足感为4.5

所以答案为4.50

重点在此(敲黑板)：
```
    sort(a+1,a+n+1);//a数组排序，从小到大排序
	for(i=n;i>=1;i--)//倒过来，从大的开始判断
	{
		s+=a[i];//累加
		s1=s*s/(n-i+1);//当前满足感
		if(s1>maxx) maxx=s1;//最大满足感
	}

```


代码如下：
```
#include<iostream>
#include<algorithm>//sort头文件
#include<iomanip>//小数头文件
using namespace std;
int main()
{
	int n,i,a[300000]={0};//i用来循环
	double s=0.0,s1,maxx=0.0;//s1用来表示当前满足感，maxx表示最大满足感，s用来累加后平方
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//重点
	for(i=n;i>=1;i--)
	{
		s+=a[i];//上面讲了
		s1=s*s/(n-i+1);
		if(s1>maxx) maxx=s1;
	}
	cout<<fixed<<setprecision(8)<<maxx;//题目说最好输出8位及以上就输出8位
	return 0;//不写易超时
 } 
```


---

## 作者：tarik (赞：1)

这道题目我可以很清晰的说贪心就可以做了，所以我们只要排序然后枚举数量就可以得到答案。不多~~BB~~，直接上代码！
```cpp
#include <bits/stdc++.h>

using namespace std;

#define io_speed_up ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

typedef long long ll;
typedef unsigned long long ull;

const int MAXN=3e5+5;
const int INF=0x3f3f3f3f;

int n;
int a[MAXN];

int main()
{
    io_speed_up;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1,greater<int>()); //注意这里的greater可以让int从大到小排序，然后就可以直接枚举了
    long double ans=0;
    ll sum=0; //这个地方的sum开longlong，不然炸（鬼知道我炸了多少次）
    for(int i=1;i<=n;i++)
    {
        sum+=a[i];
        ans=max(ans,(long double)sum*sum/i);
    }
    cout<<fixed<<setprecision(10)<<ans<<endl; //最后两个是控制位数的，保证10位，因为开了spj所以没多大问题
    return 0;
}
```


---

## 作者：Heap_Sort (赞：1)

第一眼看上去像是动态规划背包题，用饱腹感作为容积，满足感作为价值，算出每种饱腹感下的最大价值，再看吃多少饱腹感时最优。


如果这样做，您能得到 _**60分**_ 的好成绩（光速逃）


下面两行都TLE，明显是算法出问题。怎么办？

考虑贪心。因为这里每种食物的花费是一样的，不存在选最大值后浪费背包空间的问题，因此每次取满足感最大贪心一定正确。

这样还不够。看看数据范围(10^6 *3 *10^5)^2，即使int64（longlong）也不够！！

只有每次都算出舒适度，而不是储存满足感的平方，这样储存的数值可以减小很多。

#### 贴正解代码

```pascal
uses math;
var s:array[0..300000] of int64;
  g:array[0..300000] of double;
  a,b,c,n:longint;
  ans:double;
procedure kp(p,q:longint);
var
  i,j,mid,t:longint;
begin
  if p>=q then exit;
  i:=p;j:=q;mid:=s[(p+q) div 2];
  repeat
   while s[i]>mid do inc(i);
   while s[j]<mid do dec(j);
   if i<=j then begin t:=s[i];s[i]:=s[j];s[j]:=t;i:=i+1;j:=j-1;end;
  until i>j;
  kp(p,j);
  kp(i,q)
end;
begin
  readln(n);
  for a:=1 to n do read(s[a]);
  kp(1,n);
  for a:=1 to n do
   g[a]:=sqr(sqrt(g[a-1]*(a-1))+s[a])/a;
  for a:=1 to n do if g[a]>ans then ans:=g[a];
  writeln(ans:0:18);
end.
```

谢谢大家

---

## 作者：ShineEternal (赞：1)

[好东西](https://blog.csdn.net/kkkksc03/article/details/102778995)

刚开始以为比较难，其实发现还挺简单的。。。

首先：

>吃下一个美味值

这句话不要理解成吃第二个美味值为ai的才增加满足感。

解决了这个问题就发现题目变得简单了，吃同样多的食物肯定优先吃满足感大的。

所以只需要先排个序，然后从大往小吃就行了


## code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
double a[300005];
int main()
{
	int n;
	double sum=0,flag=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
	//	if(a[i]!=a[i-1]&&i!=1)
	//	flag=1;
	//	sum+=a[i];
	}
	double m=n;
	/*if(flag==0)
	{
		
		printf("%.8lf\n",sum*sum/m);
	}
	else
	{*/
	double cnt=0;
		double ans=0;
		sort(a+1,a+n+1); 
		for(int i=n;i>=1;i--)
		{
			sum+=a[i];
			cnt++;
			if(sum*sum/cnt>ans)
			{
				ans=sum*sum/cnt;
			}
		}
		printf("%.8lf\n",ans);
	//} 
	return 0;
}
```

---

## 作者：Cyancer (赞：1)

显然，这题是贪心。  
证明：因为小E的舒适度是他的满足感的平方除以他的饱腹感，而他的饱腹感为他吃下的美食个数，所以我们令他目前吃下的美食个数为$m$，当前的满足感为$A$，可得出对于下一个美味值为a的美食，他吃或不吃取决于下面这个式子：  

$\frac{A^{2}}{m}$<$\frac{(A+a)^{2}}{(m+1)}$  
  
化简得：  
  
$\frac{A^{2}}{m}$<$(2*A*a+a^{2}){m}$ 
  
而是否吃下一个美食对于后面是没有影响的，而美味值越小的美食，对于小E的舒适度的贡献也越小（甚至可能为负），所以我们就只需要从大到小选择，当$\frac{A^{2}}{m} \ge \frac{(A+a)^{2}}{(m+1)}$ ，即下一个美食对小E的舒适度贡献为负时停止，此时小E的舒适度最大，因为剩下的贡献肯定为负(~~废话~~)。 
所以，只需要先将美食按美味度从大到小排序，再依次计算比较，用一个变量$A$存放当前满足感，当 $\frac{A^{2}}{m} \ge \frac{(A+a)^{2}}{(m+1)}$时退出即可。   
然后是代码：  
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#include<cmath>
using namespace std;
int n,a[300005],ct/*记录吃掉的美食数量*/;
double ans/*当前舒适度*/,anss/*当前满足感*/;
inline bool cmp(int a,int b){
	return a>b;
}
inline double max_(double a,double b){
	return a>b?a:b;
}
template<typename S>
inline void Read(S &x){
	x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-48,c=getchar();
	}
}
//读入优化 
int main(){
	Read(n);
	for(register int i=1;i<=n;i++){
		Read(a[i]);
	}
	sort(a+1,a+1+n,cmp);
	for(register int i=1;i<=n;i++){
		anss+=a[i];
		if(( anss*anss/(ct+1) )>ans){
			ct++;
			ans=anss*anss/ct;//判断贡献是否为负 
		}
		else{
			break;
		}
	}
	printf("%.7lf",ans);
	return 0;
}
```


---

## 作者：ViXpop (赞：0)

颓废了好久了，从七月开始一直颓到现在，现在回来先拿个橙题练练手吧。

其实这题还是有点东西的，我乍一看以为是个背包裸题，开打之后才发现根本没给我饱食度的限制，那不就是个纯贪心吗。

很显然食用每一种食物的费用（这里假设饱食度为费用）是一定的，我每次挑选收益最大的食物吃不就得了，然后搞个前缀和维护一下，暴力$O(n)$直接扫一遍就完事了。

值得注意的是这题有可能会爆long long，真就是不开long long见祖宗呗qwq

代码就丢上来吧，不过大家应该不需要看我这个蒟蒻的代码吧qaq

```
#include <bits/stdc++.h>
#define mem(i,j) memset(i,j,sizeof(i))
#define pl (p<<1)
#define pr (p<<1)|1
#define int long long
using namespace std;
inline int read(){
	char ch=' ';int res=0,f=1;
	while(!isdigit(ch)){ch=getchar();if(ch=='-')f=-1;}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
int _min(int x,int y){return x<y?x:y;}
int _max(int x,int y){return x>y?x:y;}
bool cmp(int x,int y){return x>y;}
const int N=1e6+5;
int n;
double ans,sum[N],val[N];
#undef int
int main() {
	n=read();
	for(register int i=1;i<=n;i++)scanf("%lf",&val[i]);
	sort(val+1,val+n+1,cmp);
	for(register int i=1;i<=n;i++)sum[i]=sum[i-1]+val[i];
	for(register int i=1;i<=n;i++)ans=max(ans,(double)(sum[i]*sum[i]/i));
	printf("%.8lf",ans);
	return 0;
}
```

时隔四个多月的题解就这么完结啦，撒花撒花qwq

---

## 作者：地表最强男人 (赞：0)

其实这一题就是简单的贪心。一开始看很像背包，但是因为很明显的发现，对于一定的饱腹度，肯定是优先选择最好吃的食物最优。但是怎么比较吃几个食物的时候最优呢，这就更简单了，枚举就行了。首先将所有的食物按照美味度从大到小排序，然后枚举吃几个食物，每次将当前的总共的美味度加上这个食物的美味度，然后每一次将总美味度除以食物个数更新答案，最后取最大值就行了。（注意精度问题）
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[300010];
long long ans1;
double ans2;
inline int read()
{
	char c=getchar();
	int num=0;
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		num=(num<<1)+(num<<3)+c-48;
		c=getchar();
	}
	return num;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+1+n);
	for(int i=n;i>=1;i--)
	{
		ans1+=a[i];
		ans2=max((double)((double)ans1*ans1/(n-i+1)),ans2);
	}
	printf("%.9lf",ans2);
	return 0;
}
```


---

## 作者：Extra·G·Ordinary_ (赞：0)

一个int没看见卡了我20min疯狂找错；所以大家打代码的时候一定要谨慎哇。

言归正传，这题一眼看上去就是一个贪心。所以只需要先把delicious数组从大到小sort一遍，然后贪贪贪就好。



------------
~~talk is cheap，show me the code~~


------------


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;
#define ll long long
#define d double 
const int maxn=1e6;
d ans=0.0;
ll n;
d full=0.0;
ll delicious[maxn];
d eat=0.0;

bool cmp(ll a,ll b)
{
	return a>b;
}
d maxx(d a,d b)
{
	if(a>b)return a;
	else return b;
}//就是这个double原来一直写成int导致样例ans一直4.0


inline int in()
{
    char ch=getchar();
	int x=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}//快读

inline void read()
{
	n=in();
	for(register int i=1;i<=n;++i)
		delicious[i]=in();		
}

inline void sol()
{
	sort(delicious+1,delicious+1+n,cmp);
	for(register int i=1;i<=n;++i)
	{
		eat+=delicious[i];
		full++;
		d tmp=pow(eat*1.0,2.0);//自带的快速幂它不香么		
		ans=maxx(ans*1.0,(tmp*1.0 / full*1.0));
	}
	printf("%.7f\n",ans);	
}
int main()
{
	read();
	sol();
	return 0;
}
```




------------
总之就是一定要谨慎，祝大家在CSPS/CSPJ中取得好成绩

---

## 作者：nofall (赞：0)

贪心

先将$a[i]$从大到小排序，然后求前缀和，枚举分母，取$max$就行了。

```cpp
#include <bits/stdc++.h>
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
using namespace std;
int n, a[300010];
double sum[300010];
double ans;
bool cmp(int a, int b) {
    return a > b;
}
int main() {
	cin >> n;
	for(register int i = 1; i <= n; ++i) cin >> a[i];
	sort(a + 1, a + n + 1, cmp);
	for(register int i = 1; i <= n; ++i) sum[i] += sum[i - 1] + a[i];
	ans = 0;
	for(register int i = 1; i <= n; ++i) {
		double ct = (double) sum[i] * sum[i];
	    cmax(ans, (double) ct / i);
	}
	printf("%.6lf\n", ans);
	return 0;
}
```

---

## 作者：Pengsibo (赞：0)

洛谷2019十月月赛三Div.2的第二题

[题目传送门](https://www.luogu.org/problem/P5602)

这道题第一眼给人的感觉是背包：你要选一些东西出来，每一个东西都有一定的满足感和饱腹感（价值和体积）

但是仔细想一想其实不用那么麻烦

我们按点分析：

### 一、30分做法

因为30%的数组n,a<20， 所以很容易想到二进制枚举：枚举每一种食物是吃还是不吃

我查了一下，网上的二进制枚举还需要位运算什么的，太过复杂，我就在这里再讲一下：

先读入：

```
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
```
然后判断n<=20的情况

利用二进制的想法，0代表没选，1代表选了，因为小E不能什么都不吃，所以从1开始+1，一直加到$2^n$次方（想想为什么）

所以我们需要一个快速幂来帮我们（其实因为n比较小，不用快速幂直接线性乘也行）

```
//快速幂

int qpow(int a,int n)	//a是底数（本题中恒为2），n是指数
{
	int ans=1;	//记录答案
	while(n)	//当n存在
	{
		if(n&1) ans*=a;	//如果n是奇数则更新ans
		a*=a;	//a*a
		n>>=1;	//n/2	采取二分思想
	}
	return ans;
}

//二分：因为我们发现2^4=(2^2)^2，而3^5=3*((3^2)^2)，所以可以这么做

//还是不理解的话可以自己去查一下

//线性:
int ans=1;
for(register int i=1;i<=n;i++) ans*=2;
```
暴力枚举1到$2^n$

```
	if(n<=20)
	{
		jie=qpow(2,n);
		while(h<jie)
		{
			h1=0,cnt=0;
			
			check(h);	//判断哪些会被选，更新h1

			h1*=h1;
			ans=maxx((double)h1/cnt,ans);	//取大，注意double 所以要手写max
			h++;
		}
		printf("%.9f",ans);	//输出
	}
```
那check函数怎么写呢？

因为我们枚举的方法是将h从1加到$2^n$，所以我们可以将每一个h拆成一位一位的二进制，如果这一位是1则选，否则不选

```
void check(int p)
{
	int j;	//用来计算
	for(register int i=20;i>=0;i--)
	{
		j=qpow(2,i);	//看是二进制这一位对应的十进制的多少
		if(p<j) continue;	//如果不够减就跳
		p-=j;	//否则减下来（说明二进制再这一位上是1）
		cnt++;	//统计1的个数
		h1+=a[i+1];	//更新h1，即被选的所有数之和
	}
}
```
一波操作之后，30分代码应该长这样：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;

int n,jie=1;
int a[300002];
int h=1,h1=0,cnt;
double ans;

int qpow(int a,int n)
{
	int ans=1;
	while(n)
	{
		if(n&1) ans*=a;
		a*=a;
		n>>=1;
	}
	return ans;
}

void check(int p)
{
	int j;
	for(register int i=20;i>=0;i--)
	{
		j=qpow(2,i);
		if(p<j) continue;
		p-=j;
		cnt++;
		h1+=a[i+1];
	}
}

double maxx(double a,double b) {return a<b?b:a;}

int main()
{
	scanf("%d",&n);
	scanf("%d",&a[1]);
	for(register int i=2;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}

	if(n<=20)
	{
		jie=qpow(2,n);
		while(h<jie)
		{
			h1=0,cnt=0;
			
			check(h);
			
			h1*=h1;
			ans=maxx((double)h1/cnt,ans);
			h++;
		}
		printf("%.9f",ans);
	}
	
	return 0;
}
```

### 二、十五分代码

我们注意到题目说：“对于另 15% 的数据，$a_{i}$所有都相等”

此时不骗更待何时？

那我们来推一下数学式子

设现在有n个p，小D每吃一个p饱腹感都加一

不妨设他吃了m个

所以满足感=$(m*p)^2$=$m^2$*$p^2$

饱腹感=1*m=m

所以最后的舒适度=m*$p^2$;

代码如下：

```
	scanf("%d",&n);
	scanf("%d",&a[1]);	//提前读入第一个数
	for(register int i=2;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]!=a[i-1]) flag=1;	//如果这个数和上个数不相等则不是所有a[i]都相等
	}
	
	if(!flag)	//否则是相等的
	{
		printf("%d",a[1]*a[1]*n);	//直接输出结果
	}
```
### 三、正解

利用贪心思想

将满足感排序，因为每种食物增加的饱腹感都是1，所以可以直接贪心而不用DP（~~难以想象一开始做这道题我没想到这种方法~~）

从大到小排序之后便用O(n)的方式扫一遍，如果吃下一个能使舒适度提高就吃，反之则不吃

因为我们排了序，所以只要有一个不吃，那这个后面的小D都一定不会吃

所以：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

long long n;
long long a[300002];
bool flag=0;

bool cmp(long long a,long long b) {return a>b;}

double maxx(double a,double b) {return a>b?a:b;}

signed main()
{
	scanf("%lld",&n);
	scanf("%lld",&a[1]);
	for(long long i=2;i<=n;i++) {scanf("%lld",&a[i]);if(a[i]!=a[i-1]) flag=1;}
	
	if(!flag) {printf("%lld.00000000000",a[1]*a[1]*n);return 0;}
	
	sort(a+1,a+n+1,cmp);
	
	long long sum=0;
	double ans=0.0;
	double maxn=0.0;
	long long cnt=0;
	
	for(long long i=1;i<=n;i++)
	{
		sum+=a[i];
		cnt++;
		ans=(double)sum*sum/cnt;
		if(ans>maxn) maxn=ans;
		else break;
	}
	printf("%.11lf\n",maxn);
	return 0;
}
```
将15的骗分和剩下的正解一结合，我们便可以愉快的A啦！

.

.

.

.

但是...

.

你会发现这样交上去WA了最后5个点

.

为什么？

我们来计算一下

n=3*$10^5$

$a_{i}$=$10^6$

如果每一个的满足度都逼近$10^6$，而我们取了3*$10^5$个

那么

舒适度= $(3*$10^5$*$10^6$)^2$ / 3*$10^5$ 

= (3*(10^11))^2 / (3*$10^5$)

=9*(10^22)/ (3*$10^5$) 

发现问题了吧，10^22已经先炸long long了

所以把ans=sum * sum / cnt 改成 ans=sum / cnt * sum就可以啦（注意，精度一定要开高一点，要不然先除成小数再乘被卡精度就尴尬了）

#### 写题解不易，兹磁一下呗

---

## 作者：人间凡人 (赞：0)

这是一道**贪心**模板题。

思路：我们将$a$数组从大到小排序，然后另$b[i]$表示$a$数组中前$i$个数的和。然后，我们只用在所有的$b[i]/i$中找到一个最大值即可。

两点注意：

1、要开long long。

2、最好保留8位小数。

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
double tot,ans;
int n,a[300005];
long long b[300005];
void qsort(int l,int r){
	int i,j,m;
	i=l;j=r;m=a[(l+r)/2];
	while(i<=j){
		while(a[i]>m)i++;
		while(a[j]<m)j--;
		if(i<=j){
			swap(a[i],a[j]);
			i++;j--;
		} 
	}
	if(l<j)qsort(l,j);
	if(i<r)qsort(i,r);
}
inline int read(){
    int x=0,f=1;
    char c=getchar();
    for(; c<48||57<c; c=getchar())if(c=='-')f=-1;
    for(; 48<=c&&c<=57; c=getchar())x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
int main() {
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	qsort(1,n);b[1]=a[1];
	for(int i=2;i<=n;i++){
		b[i]=b[i-1]+a[i];
	} ans=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,(double)b[i]*b[i]/i); 
	}
	printf("%.8lf",ans);
	return 0;
}
```



---

## 作者：浮生南柯一梦 (赞：0)

**这是一道~~送分的~~贪心题。**

由于每个美食的饱腹感都是1，所以一定先吃美味值大的美食。

那么按照美味值从大到小排序，一一选取，如果答案比之前的大，更新答案，否则直接结束（因为后面的美食美味值必定不比现在的大，一定不会更优）

最后附上代码供大家参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a;
long long n[300010];
long double s,maxi,t;
template <typename T> void read(T &x)
{
	x=0;char c=getchar();bool flg=0;
	for (;!isdigit(c);c=getchar()) if (c=='-') flg=1;
	for (;isdigit(c);c=getchar()) x=x*10+c-'0';
	if (flg) x=-x;
}
void write(long long x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x>=10) write(x/10);
	putchar(x%10+48);
}
void writeln(long long x)
{
	write(x);
	puts("");
}
inline bool cmp(long long x,long long y)
{
	return x>y;
}
int main(){
	/*freopen(".in","r",stdin);
	freopen(".out","w",stdout);*/
	//ios::sync_with_stdio(false);
	read(a);
	for (register int i=1;i<=a;++i) read(n[i]);
	sort(n+1,n+a+1,cmp);
	s=0;maxi=0;
	for (register int i=1;i<=a;++i)
	{
		s+=n[i];t=(s*s)/i;
		if (t>maxi) maxi=t; else break;
	}
	cout<<fixed<<setprecision(8)<<maxi<<endl;
	return 0;
}
```


---

## 作者：撤云 (赞：0)

[戳我](https://www.cnblogs.com/hbxblog/p/11750248.html)

### $Solution$

这道题只需要枚举吃$k$个美食,最后在取前$k$大的美味值。对于每个算出答案后取$max$

### $Code$

``` cpp
#include<bits/stdc++.h>
#define int __int128
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int a[3000001];
int sum[3000001];
bool cmp(int a,int b){
	return a>b;
}
main(){
	int n=read();
	long double maxx=0;
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n;i++)
		maxx=max(maxx,(long double)sum[i]*1.0/i*sum[i]);
	printf("%0.8Lf",maxx);
}

```

---


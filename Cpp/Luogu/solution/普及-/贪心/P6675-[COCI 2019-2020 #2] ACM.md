# [COCI 2019/2020 #2] ACM

## 题目描述

一场有着悠久历史的比赛马上开始了，它是由 ACM 组织的。确切地说，有 $n$ 个团队将角逐头名，其中包括克罗地亚黄金三人组：Paula、Marin 和 Josip。竞赛采用标准形式，通过团队成员之间的协作，共同编写代码并提交。

比赛由 $m$ 个不同的题目组成，各小组按已解决的题目数排序（不递增）。

具有相同数量已解决任务的团队按所谓的罚时排序（不递减）。某个团队的罚时是他们在每一个正确解决的任务上获得的罚时的总和。正确解决的任务的罚时等于团队解决该任务所花费的时间（从比赛开始）增加。

每个提交但未通过的代码将给提交该代码的团队增加 $20$ 分钟罚时。任何团队都不会为他们已经解决的问题提交代码，并且每个团队的每一个问题的最大提交次数为 $9$。如果一些团队有相同数量的问题解决和相同的罚时，他们将按字典序在排行榜中排列。

比赛持续 $5$ 个小时。在前 $4$ 个小时内，所有团队都可以获得排名，并包含有关每个团队的每个题目状态的信息（提交的次数、是否已解决以及何时解决）。在这 $4$ 个小时里，队伍的排名将在每一次提交后自动更新。不过，在最后 $1$ 小时内，排行榜被冻结，即评测新提交的代码后，参赛队伍的排名不会更新。在这段时间里，每个团队都知道自己提交的代码的评测结果，但不知道其他团队提交的代码的评测结果。他们只知道其他团队提交了哪些任务、提交了多少次以及每个任务的最后一次提交时间。

比赛结束了，排行榜很快就会解冻。我们的英雄，NijeZivotJedanACM 需要你的帮助。他们想知道在排行榜上最差的排名是什么，在排行榜解冻后他们最终可能会排在什么位置。请你帮助他们！

## 说明/提示

#### 数据规模及约定
- 对于 $40\%$ 的数据，保证所有输入的 `S` 状态均不为 `?`。
- 对于 $100\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 15$，保证所有测试数据中，任意两个小组的名字均不同。

#### 说明

**本题满分 $50$ 分。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #2](https://hsin.hr/coci/archive/2019_2020/contest2_tasks.pdf) *T1 ACM*。**

## 样例 #1

### 输入

```
2 1
NijeZivotJedanACM -
ZivotJESTJedanACM -
NijeZivotJedanACM -
```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2
StoJeZivot ?1/04:00:00 +1/02:04:06
JeLiZivotJedanACM ?1/04:59:59 -
NijeZivotJedanACM ?1/04:42:43 -
NijeZivotJedanACM +1/04:42:43 -
```

### 输出

```
2```

## 样例 #3

### 输入

```
7 4
NisamSadaNistaDonio +1/03:59:59 +3/03:42:02 +2/00:14:59 ?1/04:56:12
JeLiMojKockaSeUmio ?4/04:00:00 -3 +1/00:10:01 +9/03:04:42
OstaviDobroJe ?4/04:59:59 -1 +2/00:24:15 +8/03:24:45
DobroJeOstavi +1/01:42:53 - ?9/04:58:23 ?1/04:34:43
NijeZivotJedanACM ?2/04:50:05 ?4/04:32:12 +2/01:32:45 ?1/04:59:59
KoSeToSeta ?1/04:23:32 - +9/01:00:00 -9
SipSipSipSipSipSip - - - ?9/04:00:00
NijeZivotJedanACM -2 +4/04:32:12 +2/01:32:45 +1/04:59:59
```

### 输出

```
3```

# 题解

## 作者：Wind_Smiled (赞：6)

## 题意及解析题目

输入数据共 $1 + n$ 行。

第一行两个整数 $n$ 和 $m$，表示参赛队伍的个数和题目的个数。

接下来 $n$ 行，每行的输入格式如下：
1. 首先输入队伍名称；
2. 接下来 $m$ 个字符串，格式均为 `SX/V`，说明如下：
- `S` 表示题目状态，共有三种字符：`-`、`+`、`?`。`-` 表示该题目该团队未通过，`+` 表示该题目该团队已通过，`?` 表示该题目最后一次提交时排行榜已冻结。
- `X` 表示该题目该团队的提交次数。特别地，如果该题目该团队未提交，则 `X` 省略。
- `V` 表示该题目该团队最后一次提交时比赛已经开始的时间，用 `HH:MM:SS` 表示，可能有前导零来补足。特别地，如该题目未通过，则整个 `/V` 部分省略。

最后一行按照前面的格式，输入 NijeZivotJedanACM 的最终成绩（即排行榜解冻后的成绩）

输出 NijeZivotJedanACM 可能会处在的最差排名。

- 对于 $100\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 15$，保证所有测试数据中，任意两个小组的名字均不同。



------------
### 贪心与排序
要使 NijeZivotJedanACM 排名靠后，则其余组的排名要尽可能靠前，即将其余组的 `?` 视为 `+`，将 NijeZivotJedanACM 的 `?` 视为 `-`。

对于此题，使用结构体进行排序名次，手写 `cmp` 函数进行对比判断即可。

对于所耗时间，需要进行统一，这里我用了统一成秒数，（因为大单位化小单位好算）最后如果通过了这一题，就加上罚时的秒数，判断即可。

------------
### 奇奇怪怪的题意
`ACM` 赛制是每提交错误一次就罚时，但罚时的结果是只有你做出来这道题之后才会统计上去，也就是说，只要你一直没做出来这道题，就等于没有罚时。


------------

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e3+5,rate=1200;//rate代表小时化为分钟的进率 
int n,m,down;
int intt(char x){//巧用ASCII码进行char类转int类 
	return x-'0';
}
struct node{
	string name;
	int AC,miao;
}a[MAXN];
char ch[MAXN];
bool cmp(node x,node y){
	if(x.AC==y.AC){//正确数相等 
		if(x.miao==y.miao) return x.name<y.name;//时间相等就比较名字字典序 
		return x.miao<y.miao;//否则比较时间 
	}
	return x.AC>y.AC;//通用的判断 
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n+1;i++){
		cin>>a[i].name;
		if(i!=n+1&&a[i].name=="NijeZivotJedanACM") down=i;//如果检测到了NijeZivotJedanACM的做题记录，就记录当前下标 
		for(int j=1;j<=m;j++){
			cin>>ch+1;
			if(ch[1]=='-') continue;//没通过就删了吧 
			else{
				a[i].miao+=3600*intt(ch[5])+60*(10*intt(ch[7])+ch[8])+10*intt(ch[10])+intt(ch[11]);
				a[i].miao+=(intt(ch[2])-1)*rate;
				a[i].AC++; 
			}
		}
	}
	a[down]=a[n+1];//把最后一位的数据全部塞进NijeZivotJedanACM的记录中 
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(a[i].name=="NijeZivotJedanACM"){
			printf("%d",i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：Zack_zhu (赞：5)

## 题目分析
**主要算法：模拟，贪心。**  

**解题思路**：因为要求最差情况，所以由贪心可得只要别人交了，就一定是 $AC$ 的，故别人的不知道（“ $?$ ”情况）当正确（“ $+$ ”情况）做。其它按照题意正常模拟即可。  

题目给的规则好像是标准的 $ACM$ ，但坑也不少，所以我们来看看坑点：  
- **没做对不罚时**，很容易想错，有些奇怪的代码还能过样例，调到心态爆炸都$WA$，让人绝望......  
- **最后你会知道 NijeZivotJedanACM 的最终评测**，所以一共 $n+1$ 行。  
- **乱用 $getline$** ,我一开始用 $getline$ 结果读了一行空气（~~试图抽走答案附近的空气~~），成功去世。  
  
## 代码：  
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
struct people
{
	string name;
	int h,m,s;
	int f;
	int ac;
}k[1005];
template <typename T>
inline void read(T &s)
{
	s = 0;
	T w = 1;
	char ch = getchar();
	while(ch < '0'||ch > '9')
	{
		if(ch == '-')
		w = -1;
		ch = getchar();
	}
	while(ch >= '0'&&ch <= '9')
	{
		s = (s<<3)+(s<<1)+(ch^48);
		ch = getchar();
	}
	s *= w;
	return;
}
inline bool cmp(people a,people b)
{
	if(a.ac == b.ac)
	{
		if(a.h == b.h)
		{
			if(a.m == b.m)
			{
				if(a.s == b.s)
					return a.name < b.name;
				else
					return a.s < b.s;
			}
			else
				return a.m < b.m;
		}
		else
			return a.h < b.h;
	}
	else
		return a.ac > b.ac;
}
int main()
{
	int n,m;
	read(n);
	read(m);
	int wz;
	for(int i = 1;i <= n;i++)
	{
		string a;
		cin >> a;
		int j = 0;
		while(j < a.size() && a[j] != ' ')
		{
			k[i].name += a[j];
			j++;
		}
		if(k[i].name == "NijeZivotJedanACM")
		{
			wz = i;
			for(int z = 1;z <= m;z++)
			{
				cin >> a;
			}
			continue;
		}
		for(int z = 1;z <= m;z++)
		{
			cin >> a;
			if(a[0] != '-')//不是负号就当正号做
			{
				k[i].ac++;
				j++;
				int q = a[1] - '0';
				k[i].f += q;
				k[i].h += (a[3] - '0') * 10 + a[4] - '0';
				k[i].m += (a[6] - '0') * 10 + a[7] - '0';
				k[i].s += (a[9] - '0') * 10 + a[10] - '0';
				while(k[i].s >= 60)
				{
					k[i].s -= 60;
					k[i].m++;
				}
				k[i].m += q * 20;
				while(k[i].m >= 60)
				{
					k[i].m -= 60;
					k[i].h++;
				}
			}
		}
	}
	string a;
	cin >> a;
	for(int i = 1;i <= m;i++)
	{
		cin >> a;
		if(a[0] != '-')
		{
			k[wz].ac++;
			int q = a[1] - '0';
			k[wz].f += q;
			k[wz].h += (a[3] - '0') * 10 + a[4] - '0';
			k[wz].m += (a[6] - '0') * 10 + a[7] - '0';
			k[wz].s += (a[9] - '0') * 10 + a[10] - '0';
			while(k[wz].s >= 60)
			{
				k[wz].s -= 60;
				k[wz].m++;
			}
			k[wz].m += q * 20;
			while(k[wz].m >= 60)
			{
				k[wz].m -= 60;
				k[wz].h++;
			}
		}
	}
	sort(k+1,k+1+n,cmp);
	for(int i = 1;i <= n;i++)
	{
		if(k[i].name == "NijeZivotJedanACM")
		{
			printf("%d",i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：zhou_ziyi (赞：2)

### 题目分析

思路：模拟。

所有选手的的 `？` 都以 `+` 来计算，算出每个选手的 `AC` 数，时间总和，最后以再排序即可。


### Code

```
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 1005;
struct Node {
	string s;
	int num;
	int sum;
	bool operator < (const Node o) {
		if (num == o.num) {
			if (sum == o.sum)
				s < o.s;
			return sum < o.sum;
		}
		return num > o.num;
	}
} a[MAXN];
int n, m;
string s1;
int f(int x, int y, int z) { //求一道题的时间
	return x * 3600 + y * 60 + z;
}
int main() {
	scanf("%d %d", &n, &m);
	int k = 0;
	for (int i = 1; i <= n; i++) {	
		cin >> a[i].s;
		if (a[i].s == "NijeZivotJedanACM") {
			k = i;
			for (int j = 1; j <= m; j++)
				cin >> s1;
			continue; //如果是“NijeZivotJedanACM”，在后面输入
		}
		for (int j = 1; j <= m; j++) {
			cin >> s1;
			if (s1[0] == '-')
				continue;
			a[i].sum += (s1[1] - '0') * 1200; //罚时
			a[i].sum += f(s1[3] * 10 + s1[4], s1[6] * 10 + s1[7], s1[9] * 10 + s1[10]); //用时
			a[i].num++;
		}
	}
	cin >> a[k].s;
	for (int i = 1; i <= m; i++) {
		cin >> s1;
		if (s1[0] == '-')
			continue;
		a[k].sum += (s1[1] - '0') * 1200;
		a[k].sum += f(s1[3] * 10 + s1[4], s1[6] * 10 + s1[7], s1[9] * 10 + s1[10]);
		a[k].num++;
	}
	sort(a + 1, a + n + 1); //排序
	for (int i = 1; i <= n; i++) {
		if (a[i].s == "NijeZivotJedanACM") {
			printf("%d", i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：LCat90 (赞：1)

思路： **模拟+贪心**

首先，对于每一个未知信息（即 ``?``），应将其视作 ``+``。原因：**要使 ``NijeZivotJedanACM`` 的成绩最差，肯定要其他队的成绩尽量好，即对的多。** 在这种情况下，每种不确定的信息都可以视为正确。

然后我们再根据题意，进行模拟。注意在前面遇见 ``NijeZivotJedanACM`` 时，直接忽略，用最终成绩覆盖即可。

**坑点：某个团队的罚时是他们在每一个正确解决的任务上获得的罚时的总和。** 意思是，**错误的题提交多少次都不会罚时**，只有正确的题才会有罚时。

**Code：**
```cpp
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;
const int Maxn = 1e3 + 5; 
const string yhx = "NijeZivotJedanACM";
int n, m;
struct node {
    string s;
    int sum, t;
} p[Maxn]; 
bool cmp(node a, node b) {
    if(a.sum != b.sum) return a.sum > b.sum; /// 解决题目数 
    else {
        if(a.t != b.t) return a.t < b.t; // 罚时 
        else return a.s < b.s; // 字典序 
    }
}
int main() {
    scanf("%d %d", &n, &m);
    for(int i = 1;i <= n + 1; ++i) { // 包含最后一队 
        cin >> p[i].s;
        string c;
        if(p[i].s == yhx and i != n + 1) { // 前面的忽略 
            for(int j = 1;j <= m; ++j) cin >> c;
            continue;
        }
        for(int j = 1;j <= m; ++j) {
            cin >> c;
            if(c[0] != '-') p[i].sum ++; // 正确 
            if(c.size() >= 2) {
                if(c[0] != '-') p[i].t += (c[1] - 1 - '0') * 1200; // 罚时 
                if(c.size() >= 3)  // 转化成秒 
                    p[i].t += ((c[3] - '0') * 10 + c[4] - '0') * 3600,
                    p[i].t += ((c[6] - '0') * 10 + c[7] - '0') * 60,
                    p[i].t += (c[9] - '0') * 10 + c[10] - '0';
            }
        }
    }
    sort(p + 1, p + n + 2, cmp);
    for(int i = 1;i <= n; ++i) 
        if(p[i].s == yhx) {
            printf("%d", i);
            return 0;
        }
    return 0;
}
```


---

## 作者：liuandwang (赞：0)

## 题目分析
首先我们要知道什么是 
[ACM赛制](https://zhuanlan.zhihu.com/p/129311302)。

因为要求最差的排名，所以假设除自己外所有人的 ```?``` 都为 AC 时，自己的排名才会最低。

## 代码实现
首先我们先完成输入部分；
```cpp
	struct node {
		string str;//名字
		char a;//+，-，？中的一个
		char l, l_1, l_2; //+，？时的/V部分
		int num, h, m, s; //依次为提交次数，时，分，秒
		int fashi = 0;//罚时
		int AC = 0;//AC数
	} sum[n+1];
	for (int i = 0; i <= n; i++) {
		cin >> sum[i].str;
		for (int j = 0; j < m; j++) {
			cin >> sum[i].a;
			if (sum[i].a == '-'){ //为-时不予理会
				getchar(); 
				continue;
			}
			cin >> sum[i].num;
			cin >> sum[i].l >> sum[i].h >> sum[i].l_1 >> sum[i].m >> sum[i].l_2 >> sum[i].s;//按格式输入
			if (sum[i].str == "NkjeZkvotJedanACM" && i != n){//但遇到自己时未出排名时不予理会
				continue;
			}
			sum[i].fashi += sum[i].h * 3600 + sum[i].m * 60 + sum[i].s + 1200 * sum[i].num - 1200;//罚时换算成秒计算
			sum[i].AC++;//AC数加一
		}
	}
```

之后重新遍历，与自己比较，若 AC 比自己少或 AC 相同罚时比自己多或在两者相同时自己名字字典序比别人前则排名进一名。
```cpp
	for(int i=n-1;i>=0;i--){
		if(sum[n].AC>sum[i].AC) ans--;
		else if(sum[n].AC==sum[i].AC&&sum[n].fashi<sum[i].fashi) ans--;
		else if(sum[n].AC==sum[i].AC&&sum[n].fashi==sum[i].fashi&&sum[n].str<sum[i].str) ans--;
	}
```

最后上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	//freopen("P6675.in","r",stdin);
	//freopen("P6675.out","w",stdout);
	int n, m;
	cin >> n >> m;
	struct node {
		string str;
		char a;
		char l, l_1, l_2;
		int num, h, m, s;
		int fashi = 0;
		int AC = 0;
	} sum[n+1];
	for (int i=0; i <= n; i++) {
		cin >> sum[i].str;
		for (int j = 0; j < m; j++) {
			cin >> sum[i].a;
			if (sum[i].a == '-'){
				getchar(); 
				continue;
			}
			cin >> sum[i].num;
			cin >> sum[i].l >> sum[i].h >> sum[i].l_1 >> sum[i].m >> sum[i].l_2 >> sum[i].s;
			if (sum[i].str == "NkjeZkvotJedanACM" && i != n){
				continue;
			}
			sum[i].fashi += sum[i].h * 3600 + sum[i].m * 60 + sum[i].s + 1200 * sum[i].num - 1200;
			sum[i].AC++;
		}
	}
	int ans=n;
	for(int i=n-1;i>=0;i--){
		if(sum[n].AC>sum[i].AC) ans--;
		else if(sum[n].AC==sum[i].AC&&sum[n].fashi<sum[i].fashi) ans--;
		else if(sum[n].AC==sum[i].AC&&sum[n].fashi==sum[i].fashi&&sum[n].str<sum[i].str) ans--;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：huangmingyi (赞：0)

### 思路
这道题就是一道练习贪心加模拟的题，非常简单。更明确来说，这题最简单的做法就是贪心加模拟。
首先，对于每一个不确定的信息其视作正确。原因就是要使最差的一组的成绩最差的话，那么一定要其他队的成绩尽最大的好，就是对的多。在这种情况之下，每种不确定的信息都需要视做正确。   
### 注意：
1.没做对不罚时间，很容易想法出错，所以有些代码还过不了某些样例。
2.别随便乱用 getline ,我一开始用 getline 结果读了个毛线，成功满江红。    
这题本蒟蒻就不放代码了

---

## 作者：zzx0102 (赞：0)

[传送门](www.luogu.com.cn/problem/P6675)

这题是一道大模拟，建议评橙/黄。

* 题目说的是最差排名，所以所有“?“都算 AC 了。

* 我们读到第一个 NijeZivotJedanACM 的时候，跳过它，因为有些？没有 AC。

* 错的题不算罚时，罚时统一用秒来计算，不需要处理精度问题。

再就是大模拟了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int num(char x){return x - 48;}
int read()
{
	int x = 0; char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = getchar();
	return x;
}
struct team{
	string name;
	int AC, t;
}a[N];
bool cmp(team a, team b)
{
	if(a.AC != b.AC) return a.AC > b.AC;
	if(a.t != b.t) return a.t < b.t;
	return a.name < b.name;
}
int n, m;
int main()
{
	ios::sync_with_stdio(0);
	cin >> n >> m;
	int pos = 0;
	for(int i = 1; i <= n + 1; i++)
	{
		cin >> a[i].name;
		if(i != n + 1 && a[i].name == "NijeZivotJedanACM") pos = i;
		string s;
		for(int j = 1; j <= m; j++)
		{
			cin >> s;
			if(s[0] == '-') continue;
			a[i].t += 3600 * num(s[4]) + 600 * num(s[6]) + 60 * num(s[7]) + 10 * num(s[9]) + num(s[10]);
			a[i].t += num(s[1] - 1) * 1200;
			a[i].AC++;
		}
	}
	a[pos] = a[n + 1];
	sort(a + 1, a + 1 + n, cmp);
	for(int i = 1; i <= n; i++)
	{
		if(a[i].name == "NijeZivotJedanACM")
		{
			cout << i;
			return 0;
		}
	}
	return 0;
}
```

马蜂很奇怪，勿喷。

---

## 作者：Pink__ink (赞：0)

仅仅是一道模拟……

不说多了，直接上代码！
```
#include <cstdio>
#include <string>
#include <algorithm>
using namespace std;
const int N = 1e3 + 5, fashi = 1200;
const string xxx = "NijeZivotJedanACM";
int n, m, us;
struct Node {
	char name[N];
	int tg, miao;
}a[N];
char ch[N];
bool f;
inline int it(char x) {return x - '0';}//定义成函数，方便快捷
inline bool cmp(Node x, Node y) {
	if (x.tg == y.tg) {
		if (x.miao == y.miao) return x.name < y.name;//如果正确数量与罚时一样，比较字典序
		return x.miao < y.miao;//如果正确数量一样，比较罚时
	}
	return x.tg > y.tg;//否则比较正确数量
}//按照题目要求写排序规则
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1;i <= n + 1;i++) {
		scanf("%s", a[i].name);
		if (i <= n && a[i].name == xxx) us = i;//记录下标
		for (int j = 1;j <= m;j++) {
			scanf("%s", (ch + 1));
			if (ch[1] == '-') continue;//如果未做对，就直接跳过
			a[i].miao += 3600 * it(ch[5]) + 60 * (10 * it(ch[7]) + ch[8]) + 10 * it(ch[10]) + it(ch[11]);//算罚时
			a[i].miao += (it(ch[2]) - 1) * fashi;
			a[i].tg++;
		}
	}
	a[us] = a[n + 1];
	sort(a + 1, a + n + 1, cmp);//排序
	for (int i = 1;i <= n;i++) {
		if (a[i].name == xxx) {//查找
			printf("%d", i);
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：MiRaciss (赞：0)

思路就是模拟了，没什么好说的。但这里提供一种对字符串时间转整形的不易错的方法。

```cpp

end[i].T+=(t[i].a[j][1]-'0'-1)*20*60;
end[i].T+=(t[i].a[j][3]-'0')*10*60*60;
end[i].T+=(t[i].a[j][4]-'0')*60*60;
end[i].T+=(t[i].a[j][6]-'0')*10*60;
end[i].T+=(t[i].a[j][7]-'0')*60;
end[i].T+=(t[i].a[j][9]-'0')*10;
end[i].T+=(t[i].a[j][10]-'0');
```

我们直接对每个位置的值分别转换，让自己没有一起转换时的犯错机会。

完整代码如下

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct zz{
	string a[1005];
	string NM;
}t[1005],now;

struct ss{
	ll T;
	int tot;
	string NM;
	void clear(){
		T=0;
		tot=0;
	}
}end[1005];
bool cmp(ss x,ss y){
	if(x.tot!=y.tot)
		return x.tot>y.tot;
	if(x.T!=y.T)
		return x.T<y.T;
	return x.NM<y.NM;
}

int n,m;

int main(){
//	freopen("acm.in","r",stdin);
//	freopen("acm.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		end[i].clear();
		cin>>t[i].NM;
		for(int j=1;j<=m;j++){
			cin>>t[i].a[j];
		}
	}
	cin>>now.NM;
	for(int i=1;i<=m;i++){
		cin>>now.a[i];
	}
	for(int i=1;i<=n;i++){
		if(t[i].NM==now.NM)
			t[i]=now;
		end[i].NM=t[i].NM;
		for(int j=1;j<=m;j++){
			if(t[i].a[j][0]=='-')
				continue;
			end[i].tot++;
			end[i].T+=(t[i].a[j][1]-'0'-1)*20*60;
			end[i].T+=(t[i].a[j][3]-'0')*10*60*60;
			end[i].T+=(t[i].a[j][4]-'0')*60*60;
			end[i].T+=(t[i].a[j][6]-'0')*10*60;
			end[i].T+=(t[i].a[j][7]-'0')*60;
			end[i].T+=(t[i].a[j][9]-'0')*10;
			end[i].T+=(t[i].a[j][10]-'0');
		}
	}
	sort(end+1,end+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(end[i].NM==now.NM){
			printf("%d\n",i);
			return 0;
		}
	}
	return 1;
}
```

---


# [COCI 2012/2013 #1] F7

## 题目描述

有 $N$ 位选手参加一个比赛。每个回合，第一名会得到 $N$ 分，第二名会得到 $N - 1$ 分，以此类推，最后一名会得到 $1$ 分。

现在第 $i$ 位选手初始有 $B_i$ 分。求多少选手经过一个回合，分数有机会变成所有选手中最高的。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$3 \le N \le 3 \times 10^5$，$1 \le B_i \le 2 \cdot 10^6$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $80$。

题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf) _T2 F7_**。

## 样例 #1

### 输入

```
3
8
10
9```

### 输出

```
3```

## 样例 #2

### 输入

```
5
15
14
15
12
14```

### 输出

```
4```

# 题解

## 作者：Fat_Fish (赞：7)

对于这样一个数列，我们可以先$sort$**排序**一遍，求出最小的第一名$b_n+1$,如果$B_i+n>B_n+1$,答案$ans++$即可

$Code$
```cpp
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
const int maxn=3e5+10;
int a[maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i){
		if(i==n){
			++ans;
			break;
		}
		if(a[i]+n>=a[n]+1){
			++ans;
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```
~~欢乐的~~爆零了。原来是因为如果出现有**重复数据**的情况下，$B_n+1$不一定是最大值,只需循环一遍求出最大值即可，注意:使第一名的人尽可能多，就要让最大值尽可能小。即$a_i+n-i+1$为最优。

$Code$
```cpp
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
const int maxn=3e5+10;
int a[maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//读入优化，速度媲美scanf
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+1+n);//从小到大一遍排序
	int mx=INT_MIN/3;//初始化一个很小的数，/3防溢出（好习惯，在此无用）
	for(int i=1;i<=n;++i){
		mx=max(mx,a[i]+n-i+1);//尽可能使最大值最小
	}
	for(int i=1;i<=n;++i){
		if(a[i]+n>=mx){
			++ans;//超过最大值，累加
		}
	}
	cout<<ans<<'\n';//完美输出！
	return 0;
}
```


---

## 作者：Kiloio (赞：5)

## 简述题意：  

对于选手 $ i $ ,有**初始分数**。参加比赛，得分依次为 $ N $ 、 $ N - 1 $ 、 $ N - 2 $ 直到 $ 1 $。

题目要我们求分数**有机会变成所有选手中最高的**人数。  
  
## 题目分析：  
  
本人用的**贪心**。    

使得分**最高**的人得**最低**的分，来均衡每个人分数。   

再记下**操作后**的最高分 $ Max $ ，看每个人再得 $ N $ 分后，是否能**大于等于** $ Max $ 。   
  
如果可以，那么就可以夺取桂冠。 
  
## 代码：  
```
#include <bits/stdc++.h>
using namespace std;
long long n,a[300005],Max=-1,ans;
bool cmp(int x,int y){
    return x>y;
}
int main(){
	cin>>n;
	for(int i=1; i<=n; i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1; i<=n; i++){
		Max=max(Max,a[i]+i);
	}
	for(int i=1; i<=n; i++){
		if(a[i]+n>=Max){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：yxy666 (赞：3)

很明显，如果我们想要让位置为 $i$ 的数下一次的分数最高，那么按照贪心的想法，肯定加 $n$ 。但是我们要如何判定是所有数中最大的呢？

我们现在有 $n$ 个数，按照从小到大排序，我们需要给这些数加上 $1-n$ ,同时我们想要让这些数中的最大值最小，那么肯定是最大的数字加上最小的数字，次大的数字加上次小的数字，以此类推啊。

$code$ :
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=300005;
int n,ans,Max,a[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+1+n);//排序
	for(int i=1;i<=n;i++)Max=max(Max,a[i]+n-i+1);//最小的数字加上最大的，以此类推
	for(int i=1;i<=n;i++)ans+=(a[i]+n>=Max);//判断，如果我这个下一轮的数字大于等于最大值，就是可以的啊
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：fls233666 (赞：3)

首先我们发现，**对于每个选手是否能累计到最高分，必须在这个选手在一个回合中得到第一名的情况下来考虑。**

因为，当一个选手拿到第一名时，这个选手能加的分是最多的，那么拿到第一名的概率就是最大的。

进一步考虑一个选手拿到第一名时，其它选手的情况。**想要让一个选手的分数最高，那么其它选手累计的分就要尽可能低。** 但是又因为比赛规则的限制，每个选手在一个回合后一定会加分。因此，我们要考虑每个选手的加分状况。

把每个选手都扫一遍显然是过不了 $3 \le N \le 3 \times 10^5$ 的数据范围。重新分析，我们发现，对于一个选手在新的一个回合得到第一名后是否能让这个选手的累计分最高，关键在于这个选手的累计分能否比其它选手在新的一个回合后的累计分的**最大值**高，而我们要做的就是在短时间内确定这个最大值，同时让这个最大值尽可能小。

从加分规则入手，我们考虑如何加分才能让累计分中的最大值最小。可以先按原始累计分排序，然后把大的加分尽可能赋给累计分小的选手。这样就可以让每个选手的累计分尽可能小。

再考虑如何统计有多少选手能做到累计分最高。可以按原始累计分从大到小考虑，每次考虑完成后更新其它选手累计分的最大值，把 $N$ 个选手全考虑一遍统计得到答案。

本题思路如上，下面放出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register int
#define qmx(a,b) a<b?b:a
using namespace std;

const int mxn = 3e5+5;
int ans,b[mxn],n,mx;

int main(){
	scanf("%d",&n);
	for(rgt i=0;i<n;i++)
		scanf("%d",&b[i]);
  
	sort(b,b+n);  //排序
  
	for(rgt ad=1,i=n-1;i>=0;i--,ad++){
		if(b[i]+n>=mx)  //比较统计答案
			ans++;
		mx=qmx(mx,b[i]+ad);  //更新最大值
	}
  
	printf("%d",ans);  
	return 0;
}

```


---

## 作者：Dragonbell_exp (赞：3)

### [P7584](https://www.luogu.com.cn/problem/P7584)
## 思路：
枚举每一个人，尽可能的让这个人的分数高。

那么如何做到这一点？

我们设定一个最大值

我们把最多的分数加给这个人，并把次多的分数加给除了这个人以外分数最少的人，然后把最少的分数加给除了这个人以外分数最多的人。最大值不断更新，最终得出的一定是最小的，也最容易被打破。

于是，我们保证了当前枚举到的人的分数的排名一定是他能够到达的最多了

接着，就可以开始比较，如果当前这个人的分数加上最高分是最多的，那么答案加1。


于是我们不难想到以下代码：

------------
```c
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int mus[300005];//选手的初始分数 
int main(){
	int n;//选手数量和最高分
   int ans=0;//答案
	cin>>n;//读入选手数和初始分数 
	for(int i=1;i<=n;i++){
		cin>>mus[i];
	}
	sort(mus+1,mus+n+1);//从大到小排序 
	for(int i=1;i<=n;i++){//枚举每个选手 
		int smax=0;//最大值 
		for(int j=n,add=1;j>=1,add<=n;add++,j--){//让每一个选手加上对应的分数 
			if(i==j)continue; 
			smax=max(smax,mus[j]+add);
		}
		if(mus[i]+n>=smax){//如果小于最大值，那么答案加1 
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}

```
然而，这串代码的时间复杂度巨大，我们考虑进行优化。

实际上，我们可以把这段代码计算最小的最大值的部分拿到枚举部分外面，然后再枚举所有人加上最大数后的值与计算的最大值比较，如果能够成为第一，那么答案加1。

## 时间降低后的代码：

```c
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int mus[300005];//选手初始值 
int main(){
	int n;//选手数量和最高分
   int ans;//答案
   int smax;//最大值
	cin>>n;//读入选手数量和对应的初始值 
	for(int i=1;i<=n;i++){
		cin>>mus[i];
	}
	sort(mus+1,mus+n+1);//从小到大排序 
	for(int i=n,add=1;i>=n,add<=n;i--,add++){//让每个选手加上能够保证最大值最小的分数 
		smax=max(smax,mus[i]+add);
	}
	for(int i=1;i<=n;i++){//枚举每一个选手，如果加上最高分后比最大值大，那么答案加1 
		if(mus[i]+n>=smax){
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}


```





---

## 作者：Aiopr_2378 (赞：1)

# Solution P7584 [COCI2012-2013#1] F7

#### By Indifferent

这道题思路还是比较简单的。题目要求的是有几个人可能成为第一名，所以不难想到**贪心**。

我们可以先对b[]进行从大到小的排序，然后再进行贪心。贪心原则是：让最小的分数的人尽可能得到最高的分数，最高分数的人尽可能得到最少的分数。所以我们分别给 $a_1+1,a_2+2,a_3+3\ldots,a_n+n$ 然后再记录最大的得分。因为我们只给最小的加了尽可能多的分数，而中间的并没有加（如果一个一个加会TLE），所以我们在记录个数之前要做一个重要的事情，就是给中间的不加：$a[i]+i+n-1=a[i]+n$ ，人后和最大值 $maxn$ 进行比较。

### 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[300005],maxn,ans;
bool cmp(int a,int b){
	return a>b;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		maxn=max(maxn,a[i]+i);
	}
	for(int i=1;i<=n;i++){
		if(a[i]+n>=maxn) ans++;
	}
	cout<<ans;
	return 0;
}
```

谢谢各位大佬浏览，多多指教——END

---

## 作者：miao5 (赞：1)

这题还是蛮简单的了~~~

我们考虑使一回合过后，所有选手得分的最大值最小的方案。

很明显是让初始得分最小的选手加 $n$ 分，让初始得分第二小的选手加 $n-1$ 分， $…$ ，初始得分最大的选手加 $1$ 分。

之后我们枚举一遍每个选手，在每个选手的初始得分上加 $n$ 分，如果大于之前求得的最大值的话，答案就加一。

code:

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=3e5+10;
bool cmp(int x,int y){return x>y;}//从大到小排序函数 
int a[maxn];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n,cmp);//排序 
	int mx=-1,ans=0;
	for(int i=1;i<=n;i++) mx=max(mx,a[i]+i);//取最小的最大值 
	for(int i=1;i<=n;i++){
		if(a[i]+n>=mx) ans++;//求得答案。 
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：BotDand (赞：1)

# $\text{Problems}$
有 $N$ 位选手参加一个比赛。每个回合，第一名会得到 $N$ 分，第二名会得到 $N - 1$ 分，以此类推，最后一名会得到 $1$ 分。

现在第 $i$ 位选手初始有 $B_i$ 分。求多少选手经过一个回合，分数有机会变成所有选手中最高的。
# $\text{Answer}$
让分数最大的为最后一名，分数次大的为倒数第二名，以此类推，分数最小的为第一名。

即第 $i$ 人的分数为 $a_{i}+i$。

在查询时可以默认为第 $i$ 人为第一名，即获得分数为 $n$，如果当前的人获得的分数大于前几人获得分数的最大值，则 `ans+1`。

```cpp
    for(int i=1;i<=n;++i)
    {
        if(a[i]+n>=ma) s++;
        ma=max(ma,a[i]+i);
    }
```

时间复杂度 $O(n\log n)$，因为要排序。
# $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[300002];
int s,ma;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void print(int x)
{
    write(x);
    putchar('\n');
}
bool cmp(int x,int y)
{
    return x>y;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i) a[i]=read();
    sort(a+1,a+n+1,cmp);//从大到小排序
    for(int i=1;i<=n;++i)
    {
        if(a[i]+n>=ma) s++;
        ma=max(ma,a[i]+i);
    }
    print(s);
    return 0;
}
```


---

## 作者：fanypcd (赞：0)

### 题目简述：

有 n 位选手，一场比赛下来排名为 $i$ 的选手可以获得 $n - i + 1$ 分，且第 $i$ 位选手初始有 $B_i$ 分。求有经过一场比赛后有多少位选手**有机会**成为最高分。

注意：此处‘有机会’意为能找到**至少任意一种**排名顺序使得第 $i$ 位选手成为最高分

### 题目思路：

- 贪心
- 因为找到**至少一种**，考虑最优情况，假设 $B_i$ 排好序后的数组为 $C_i$ ，且 $C_1 \leq C_2 \cdots \leq C_n$ ，此时使全场**最高分最低**的排名方案是 $C_1$ 第一， $C_2$ 第二， $\cdots$ ， $C_n$ 最后一名
- 求出此时 $C_i+n-i+1$ 的最大值 $maxx$ , 则若遍历到 $C_i$ 号分数时有 $C_i + n \geq maxx$ ，则此种方案合法（贪心的精髓就在令不等式一边最大，另一边最小来考虑）

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);//读入优化
	int n;
	cin >> n;
	int a[n + 1];
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	int ans = 0, maxx = -1;
	for(int i = 1; i <= n; i++)
	{
		maxx = max(maxx, a[i] + n - i + 1);
	}
	for(int i = 1; i <= n; i++)
	{
		if(a[i] + n >= maxx)
		{
			ans++;
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：JoseTony (赞：0)

# 思路
考虑贪心算法。如果需要让能够获胜的人数尽可能多，我们就需要让分数少的人加的分尽可能多，分数多的人加的分尽可能少。

实现：从大到小排序，分数最高的人 $a_n$ 加上 $1$ 分，第二高的加上 $2$ 分，分数最少的人加上 $n$ 分。记下此时的最高分数。然后，对于每一个 $a_i$，它的最大可能分数为 $a_i+n$，若该数大于已经记录下的最高分，则计数器加一。
# 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
bool cmp(int x,int y){
    return x>y;
}//由于是从大到小排序，因此需要自定义排序函数
int a[10000001],n;
int maxn=0;
int res;
int main(){
    cin >> n;
    for(int i=0;i<n;++i) cin >> a[i];
    sort(a,a+n,cmp);//从大到小排序
    for(int i=0;i<n;++i){
        maxn=max(maxn,a[i]+i);//记录最大分数
    }
    for(int i=0;i<n;++i) if(a[i]+n>maxn) res++;//若加n后比最高分大，计数器加一
    cout << res << '\n';
    return 0;
}
```


---

## 作者：joy2010WonderMaker (赞：0)

### 题目分析

这道题是要求出最优情况，也就是得分最高的加一，第二高加二，以此类推。

### 题目解法

因为有可能有多个高分，所以直接加不对，需要将 $b$ 数组里的第 $i$ 项加 $i$。之后讨论 $B_i+n$ 是否大于这个最优情况下的最高分。 

### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int b[300005],ans,maxb;
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%d",&b[i]);
    sort(b,b+n,greater<int>());
    for(int i=0;i<n;i++)if(maxb<b[i]+i)maxb=b[i]+i;
    for(int i=0;i<n;i++){
        if(b[i]+n>maxb)ans++;
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：C_S_L (赞：0)

对于一个人：

设有$x$个人初始分数比他高，这$x$个人初试分数为$a_1,a_2…a_x$，$a_1>a_2>…>a_x$。

要使这些人的分数加上$1$到$n$中的一个整数后最大数最小，则需这样加：

$a_1+1$

$a_2+2$

$…$

$a_x+x$

从中取最大值$m$。

因为要使这个人得到第一名，则给他加$n$分。

所以若这个人的初始分数+$n$分$≥m$，则他可以成为第一名。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b[300009],ans=1,nmax=-1;
bool cmp(const int&a,const int&b){
	return a>b;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&b[i]);
	}
	sort(b+1,b+n+1,cmp);
	for(int i=2;i<=n;++i){
		b[i-1]+=i-1;
		nmax=max(nmax,b[i-1]);
		if(b[i]+n>=nmax){
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Keep_RAD (赞：0)


### 思路

平均化处理：先从大到小排序，将他们的分数进行平均，就是本来大的分数加上小的分数，本来小的分数加上大的分数；

比较最大值：记下得到最多的分记为`maxx`，然后每一个选手加上`n`分（也就是能加上的最大分）去和`maxx`比较，如果比记下的分数大，那么这位选手就可能获得第一。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005];
int n,maxx,ans;//全局变量默认为0
int cmp(int x,int y)
{
	return x>y;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
	    cin>>a[i];
    sort(a+1,a+n+1,cmp);//按分值大小排序
    for(int i=1;i<=n;i++)
        maxx=max(maxx,a[i]+i);//更新最大值，用大的匹配小的
    for(int i=1;i<=n;i++)
        if(a[i]+n>=maxx)//如果加上最大可能分超过了最大值，那么就可能成为第一
		    ans++;//答案记忆，但因为有好几种，所以不能直接输出和break
    cout<<ans;//输出答案
    return 0;
}
```
AC记录：

https://www.luogu.com.cn/record/50920772


---


# [CCC 2014] 燃料搜集

## 题目描述

英勇的狐狸星小队正在执行任务。他们的任务是从莱拉星系的不同的星球上搜集尽可能多的燃料。莱拉星系里有 $n$ 个星球，第 $i$ 个星球有 $a_i$ 单位燃料，但是从任何星球去那里都要花费 $b_i$ 单位燃料。不幸的是，燃料不是一种可再生资源，所以如果你第二次到访一个星球，你在那里将搜集不到新的燃料。

狐狸星小队在星球 $P$，所以他们可以立马搜集这个星球的燃料，然后他们就可以去执行任务了。只要他们的燃料足够，即完成飞行后他们剩余的燃料量是非负的，他们就可以以任意顺序访问星球。最后，他们可能会在任何星球选择停下来，甚至可能连星球 $P$ 都没离开过就停下来。他们的目标是使搜集到的燃料量最大化，如果有很多种方法可以达到这个目标，他们还想使他们访问过的不同星球的个数最大化，你能帮助他们吗？

## 说明/提示

一个最优的方案是，狐狸星小队搜集完星球 $2$ 即起点的燃料后从该出发，依次访问并搜集星球 $3,1,5$ 上的燃料，途中花费分别为 $3,12,15$，从起点开始各个星球上完成搜集后剩余燃料分别为 $10,15,15,25$。他们此时不应该选择去星球 $4$ 而是应该选择停下来以使结束时搜集到的燃料量最大化。

对于 $20\%$ 的测试数据，$1\le n\le10$；

对于 $100\%$ 的测试数据，$1\le P\le n\le10^5$，$a_i,b_i\le10^5$ 。

## 样例 #1

### 输入

```
5 2
12 12
10 100
8 3
4 5
25 15```

### 输出

```
25
4```

# 题解

## 作者：GuideZombies (赞：16)

$\ \ \ \ $第一眼还以为是一道最短路的题，知道看到这一句话：

>第 $i$ 个星球有 $a_i$单位燃料，但是从任何星球去那里都要花费 $b_i$ 单位燃料。

$\ \ \ \ $所以不管从哪个星球去星球$x$，所获得的价值都是相等的，考虑贪心。显然地，如果去一个星球$x$所获的价值（即 $a_x - b_x$ ）为负，那肯定不去那个星球，应为去只会让燃料变少。另外，就算这个星球的价值为正，但当前的油量不足以去，那也获得不了这个星球的燃料，所以，应先以 $a_i$ 排序，在进行操作。

略证：

$\ \ \ \ $对于两个星球的信息 $(a_x,b_x)\ ,\ (a_y,b_y)\ ,\ a_x<a_y\ $，若可以去星球 $y$ ，则一定可以去星球 $x$ ,且去过 $x$ 后一定可以去 $y$ (燃料一定会变多)，但可以去 $x$ 星球就不一定可以去 $y$ ，若先考虑 $y$ ，则可能会因当前的燃料不够而跳过 $y$ ，在遍历 $x$ 后，就算当前燃料可以去 $y$ ，也不会再去考虑 $y$ 了。

得证.

$\ \ \ \ $对于去的星球尽量多，只需要将那些 $a = b$ 的星球也考虑到遍历当中，虽然这种星球做不出任何贡献，但可以让访问的星球尽量多。

code:
```
#include <bits/stdc++.h>
using namespace std;
struct node {
	int v;//去星球需要的代价
	int val;//价值
	friend bool operator < (node x, node y) {//重载运算符：代价小的排前面
		return x.v < y.v;
	}
}star[100010];
int n, m, cnt;
int main() {
	cin >> n >> m;
	int oil, sum = 1;
	for (int i = 1; i <= n; ++i) {
		int a, b;
		cin >> a >> b;
		if (a - b >= 0 && i != m) {
			star[++cnt].v = b;
			star[cnt].val = a - b;//只将对答案用贡献的星球加入列表
		}
		if (i == m) oil = a;
	}
	sort(star + 1, star + cnt + 1);
	for (int i = 1; i <= cnt; ++i) {
		if (oil >= star[i].v) {
			oil += star[i].val;
			++sum;
		}
		else break;//如果当前星球去不了，那以后的肯定都去不了，直接退出循环
	}
	cout << oil << endl << sum;
	return 0;
}
```

---

## 作者：Nemonade (赞：12)

蒟蒻第一篇题解，求过 QWQ

## 贪心思路

对于每一颗星球，去一趟会消耗 $b_{i}$ 燃料，获得 $a_{i}$ 燃料，那么我们算下来就赚了 $(a_{i}-b_{i})$ 燃料。于是有三种情况：

1. $(a_{i}-b_{i})>0$

> 很明显可以增加燃料，所以直接加上

2. $(a_{i}-b_{i})=0$

> 乍一看好像对答案没有改变，但是题目要求尽可能到达的星球最多，所以这种情况也要加上

3. $(a_{i}-b_{i})<0$

> 这种星球去了也是浪费燃料，所以直接舍掉

所以我们对剩下的两种情况按照前往所需的燃料进行排序，先去代价较小的星球。

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct node{
	int a;	//去星球需要的燃料 
	int b;	//"价值"(去一趟这个星球可以赚的燃料)
}s[N];
//重载运算符:消耗燃料小的排前面
bool operator <(const node &x,const node &y){
		return x.a<y.a;
}
int n,p,cnt,ans,sum=1;
int main(){
	cin>>n>>p;
	for(register int i=1;i<=n;++i){
		int a,b;cin>>a>>b;
		//如果读到开始点，要把开始点的燃料加上，否则哪里都去不了 
		if(i==p) ans=a;
		else
			//如果消耗的燃料比星球上可获取的燃料多，那么这个星球就废了 
			if(a-b>=0)
				s[++cnt].a=b,
				s[cnt].b=a-b;
	}
	//排序 
	sort(s+1,s+cnt+1);
	//枚举每一颗星球 
	for(register int i=1;i<=cnt;++i){
		//如果燃料够，就一定去 
		if(ans>=s[i].a) ans+=s[i].b,++sum;
		//如果当前燃料不够，那以后的肯定都去不了
		else break;
	}
	cout<<ans<<endl;
	cout<<sum;
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：5)

## 题意

从第 $P$ 个星球开始走，去到编号为 $i$ 的星球，消耗 $b_i$ 的燃料获得 $a_i$ 的燃料。

问如何在保证获得燃料最多的情况下去尽可能多的星球？

## 解析

实际上，我们很容易想到一个贪心的方案，也就是按照 $a_i-b_i$ 进行排序，按序访问收益最高的星球，这样子我们的收益应该是最大的。但是不妨设想这样的一个场景，我们现在有很少的路费，远处有一个收益极高的星球，譬如说花费 $10^5$ 的燃料可以获取 $10^8$ 的燃料，但是我们手头上只有 $500$ 路费，这应该怎么办呢？

出现这种情况是因为我们陷入了一个误区，我们太贪心了，以至于做出了实际上没有任何必要的决策。在寻找燃料的过程中，并没有限制我们所访问的星球个数，因此**只要当前星球收益为正，就应该访问**。即使在 $a_i=b_i$ 的时候也应当前往，因为题目要求尽可能多地访问星球，这样的决策是符合题意的。

但是，会不会出现收益为负数，却不得不去的情况呢？答案是否定的。因为题目**首先要求收益最大**，在保证这一大前提的情况下我们采取追求尽可能多的星球访问，因此我们应该做出如下的处理：

- 将星球按照 $b$ 从小到大排序。这一步的目的是保证我们不会因为燃料不足而错过星球，让我们循序渐进地积累燃料，这样才能为靠后的代价较高的星球铺好基础。
- 对于收益为负的星球直接跳过。因为这会影响我们求的最优解。

那么至此，我们已经简单总结出了运算逻辑，详细的实现步骤见代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e5+10;
struct node{
	int a,b;
}arr[100005];
bool cmp(node x,node y){
	return x.b<y.b;
}int n,p,now,cnt=1;
signed main(){
	cin>>n>>p;
	for(int i=1;i<=n;i++)
		cin>>arr[i].a>>arr[i].b;
	swap(arr[p],arr[1]);
	sort(arr+2,arr+1+n,cmp);
	now=arr[1].a;
	for(int i=2;i<=n;i++){
		if(arr[i].a-arr[i].b<0)continue;
		if(now>=arr[i].b){
			now=now-arr[i].b+arr[i].a;
			cnt++;
		}
	}cout<<now<<"\n"<<cnt<<"\n";
	return 0;
}
```





---

## 作者：祖国的花梗 (赞：2)

题目大意：你从 $\textbf{p}$ 点出发，可以去任意一个星球，并获得星球上的燃料，前提是有足够的燃料能够到达此星球，问你最多可以获得多少燃料，获得最大燃料的同时最多可以去多少个星球。

思路：这其实是一个非常简单的贪心 ~~贪污带师~~ ，每个星球只有去那且获得的燃料比来这个星球的燃料多才赚，否则你是亏的，那么我们用一个数组存下每个星球到达那需要耗费的燃料，以及到这个星球可以 ~~薅多少羊毛~~ 获得多少汽油，排个序， $\textbf{O(n)}$ 扫一遍每个星球遵循能拿多少拿多少燃料的原则，去更多的星球

**详细请看代码：**


```c
#include<bits/stdc++.h>
using namespace std;
struct Van
{
	int cost,add;//cost表示到这个星球需要花费多少汽油；add表示你可以薅多少羊毛
}a[100005];
int n,p,x,y,tnt=0,maxn=0,planet=1;
//maxn表示你可以获得的最大燃料；planet表示你在最大燃料的前提下可以去最多的星球，因为带在p星球也算走了一个，所以初始值为1。

bool cmp(Van a,Van b){ return a.cost<b.cost; }//按照汽油消耗量从小到大排

int main()
{
	scanf("%d%d",&n,&p);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		if(i==p) maxn=x;//最大值初始为p星球的燃料值
		else if(x-y>=0)//如果去这个星球是赚的，那么就加入数组
				tnt++,a[tnt].add=x-y,a[tnt].cost=y;
	}
	sort(a+1,a+tnt+1,cmp);//排序
	for(register int i=1;i<=tnt;i++)
		if(maxn>=a[i].cost)//能去就去
			maxn+=a[i].add,planet++;
		else break;//不去拉倒
	printf("%d\n%d\n",maxn,planet);//输出最大值和最多能去多少星球
	return 0;//结束游戏
}
```


---

## 作者：love_tide (赞：2)

## 分析


通过~~看标签~~读题了解到这是一道**贪心**题。即每次都考虑当前最优解。


~~虽然题很水~~但有几个小细节要注意：


- 要求访问星球最大化，那么就得**优先访问消耗燃料少的星球**（用快排实现）。

- 注意要判断剩余的燃料是否够到达该星球，并且记得在该星球补充燃料，注意模拟过程。

- 注意定义出发点，将出发点 P 星球放在第一位。

- 注意初始化，他们在 P 星球也算入访问次数。

- 注意如果到达这个星球收集到的小于到达这个星球所消耗的燃料，~~那就是本亏本的买卖~~，因为代价太大，这种情况直接排除。

详细解释请看代码注释。


## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,p;

//我脑子中的贪心：贪心=快排+结构体

struct node{
	
	int a;//a表示该星球含有的燃料
	
	int b;//b表示到达该星球消耗的燃料
	
}star[100001];

bool cmp(node x,node y){
	
	return x.b<y.b;//降序排序，优先访问消耗燃料小的星球
	
}

int main(){
	
	scanf("%d %d",&n,&p);
	
	for(int i=1;i<=n;i++){
		
		cin>>star[i].a>>star[i].b;
	
		if(i==p){//他们所在的P星球定义到starp[1]
			
			swap(star[1],star[i]);
        //swap交换两个的值 
			
		}
			
	}
	
	int ans=1;
	
	sort(star+2,star+n+1,cmp);//因为他们处于P星球，所以不参与排序，从 star+2 开始
	
	int s=star[1].a;
	
	for(int i=2;i<=n;i++){
		
		if(star[i].a-star[i].b<0) continue;//这步特判上面有解释
		
		if(s>=star[i].b){//判断是否能到达该星球
			
			s=s-star[i].b+star[i].a;//模拟过程一定要在纸上模拟一下消耗燃料，收集燃料的过程。
			
			ans++;
			
		}
		
	} 
	
	cout<<s<<endl<<ans;
	
	return 0;
	
	
}
```


---

## 作者：Coros_Trusds (赞：1)

**经过审题可以猜测，这是一道```贪心```题目。**

#### 成立条件：

* 他们就可以以任意顺序访问星球。

这就够了。

只要我们可以按照经过自己排序后的顺序进行运算，我们的答案就能保证是最优的。

#### 贪心策略：

1. 我们从 $p$ 号星球开始访问,这里为简便，把起始星球放在第一位。

2. 按照消耗从小到大排序。根据贪心定义，只要我们每一次是当前的最优解，最后就是全局的最优解。

3. 如果去 $i$ 星球的收益大于消费并且当前的油量足够到达,那么就前往该星球 ，并且扣除相应的消耗、获得相应的利润，同时把能到达星球的个数自加 $1$。

#### 代码：

```cpp
//2021/7/16

#include <cstdio>

#include <algorithm>

using namespace std;

const int ma=100005;

struct Node
{
	int a;
	
	int b;
};

Node node[ma];

int n,m;

inline bool cmp(Node x,Node y)
{
	return x.b<y.b;
}

int main(void)
{
	scanf("%d%d",&n,&m);
	
	for(register int i=1;i<=n;i++)
	{
		scanf("%d%d",&node[i].a,&node[i].b); 
	}
	//起始星球优先考虑 
	swap(node[1].a,node[m].a);
	
	swap(node[1].b,node[m].b);
	
	sort(node+1+1,node+n+1,cmp);
	
	int nowa=node[1].a;//现在剩余的油量 
	
	int ok=1;//能够到达的星球个数 
	
	for(register int i=2;i<=n;i++)
	{
		if(node[i].a>=node[i].b && nowa>=node[i].b)
		//如果去 i 星球的收益大于消费并且当前的油量足够到达
		//那么就前往该星球 
		{
			nowa=nowa-node[i].b+node[i].a;
			
			ok++;
		}
	}
	
	printf("%d\n%d\n",nowa,ok);
	
	return 0;
}
```

---

## 作者：asasas (赞：0)

题目大意：现有 $ n $ 个星球，一开始你在第 $ p $ 个星球上。前往一个星球上需要消耗至少 $ a $ 个燃料，到达这个星球后可以得到 $ b $ 个燃料。现在要求你求出最多可以经过几个星球，以及最后所得到的燃料最大值。

很明显，这是一道**贪心**题。

首先我们可以从读入开始贪心。显然，当一个星球可得到的燃料数小于到达这个星球所需的燃料数时，也就是 $ a - b < 0 $ 时，去这个星球没有意义，只会消耗燃料。所以我们在读入时进行判断，如果出现上面这种情况时，就直接跳过，否则就把这个星球存到一个 **结构体** 数组里，等待后续操作。

注意：这里还要进行特判，就是当前这个星球为初始星球时，要跳过，因为一个星球不能去两次，这样会导致答案错误。

接下来对结构体数组进行排序。这里不能用 $ a - b $ （到达这个星球可以净赚的燃料数） 排序。虽然这样排序理论上是最优的，但这样会出现错误。原因是什么呢？因为没有考虑这个星球可不可以到达，而是直接默认：这个星球可以到达，而忘记了燃料的限制。所以，我们应该按照 $ b $ （到达这个星球所需的燃料数）进行排序，最后枚举判断即可。

最后注意：去过的星球包括初始星球，所以最后答案要加一。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define r register
struct as{
	int need,val;
}aq[100005];
bool cmp(as a,as b){
	return a.need<b.need;
}
int now;
int main(){
    long long n,p,st=0,ans=0;
    cin >> n >> p;
    for (register int i=1;i<=n;i++){
    	long long a,b;
    	cin >> a >> b;
    	if (a>=b&&i!=p) //这里要特判
        aq[++now].val=a,aq[now].need=b;//这个星球有价值，就把它存下来
    	if (i==p) st=a;
    }
    sort(aq+1,aq+1+now,cmp);
    for (register int i=1;i<=now;i++){
    	if (st>=aq[i].need) st+=aq[i].val-aq[i].need,ans++;
    	else break;//如果这个星球不行，后面的肯定也不行（b值从小到大排序）
    }
    cout << st << endl << ans+1;
    return 0;
}

```


---

## 作者：Charm185 (赞：0)


# 分析

#### 	首先，题目大意基本就是选择前往性价比最高的星球。
#### 其次，本题坑不多，只是要注意题目里要求前往尽量多的星球。

————————————————————————————————

# 代码实现
这道题主要使用贪心解决问题，在输入的时候采用结构体的方式，方便排序。排序的时候要注意并不是像背包问题一样根据性价比排序，而是根据从一个星球到另一个星球的消耗从小到大排序，避免了由于油不够错失性价比高星球的问题。

当一个星球性价比为负值的时候，应该跳过这个星球避免损失。

当一个星球性价比为0时，因为要求到达尽量多的星球，所以只要油够就要前往。

————————————————————————————————
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int val,cost,cx;	
}a[100005];
bool cmp(node c,node b){
	return c.cost<b.cost;
}//根据消耗从小到大排序
int main(){
	int n,p;
	cin>>n>>p;
	int fuel=0;
	for(int i=1;i<=n;i++){
		cin>>a[i].val>>a[i].cost;
		if(i==p){
		    int k=a[1].cost,l=a[1].val;
		    a[1].cost=a[i].cost,a[1].val=a[i].val;
		    a[i].cost=k,a[i].val=l;
		    a[1].cx=a[1].val;
		}//当输入小队最初所在的星球时要特殊处理,交换a[1]和a[p]的位置
         	//也可以用swap替换
		a[i].cx=a[i].val-a[i].cost;
	}
	fuel=a[1].val;
	sort(a+2,a+n+1,cmp);
	int place=1;
	for(int i=2;i<=n;i++){
		if(a[i].cx<0)continue;//如果性价比小于零跳过
		if(a[i].cost>fuel)continue;//如果油不够跳过
		place++;
		fuel+=a[i].cx; 
	}
	cout<<fuel<<endl<<place;
}
```


---

## 作者：chlchl (赞：0)

## 题目意思及翻译
题目意思非常清楚，就是有 $N$ 个星球，某某小队现在在 $P$ 号星球。第 $i$ 个星球有 $a_i$ 燃料资源，但去这个星球要花费 $b_i$ 的燃料。现在要帮助他们在剩余燃料最大的前提下访问尽可能多的星球。

## 主要思路及算法
当初一眼看到这题还以为是个橙题 DP，后来方程搞了半天没弄出来，~~我就放弃了~~。后来我~~仔细~~一想：哎！这就是个**贪心**！

我一开始的思路是按照价值 $v$（**这里的价值指题目中的 $a_i - b_i$**）从大到小排序，然后分成以下三类：

- $v>0$，这类星球是一定要去的，增加一个星球的同时还让自己的剩余燃料变大，岂不妙哉！

- $v=0$，这是一个坑点。虽然剩余燃料并没有增加，但是多了一个星球呀！这类星球也是要去的。

- $v<0$，这类星球是肯定不能去的，大前提都不满足，多一个星球也得不偿失。

但是，有这样一个反例：如果有一个星球，去的时候要**花费 $2^{31}$ 的路费**，但是**收益却有 $2^{32}$（数据不会出成这样，我只是举个例子），而此时我们手中只有 $1$ 块钱**。很明显，刚刚的思路被打翻了。

正解：**按照花费 $t$（即题目中的 $b_i$）从小到大排序**（注意这里，很关键），然后按照上面的思路分析即可。

## 代码部分
以下是本蒟蒻的参考代码，珍爱生命，远离抄袭。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100000 + 10;
int n, p, a, b, k, ans, cnt;
//ans是最大剩余燃料，cnt是最大星球数量 

struct star{
	int v, t;
} s[N];//定义结构体储存一个星球 

bool cmp(star x, star y){return x.t < y.t;}//手写排序规则 

int main(){
	cin >> n >> p;
	for(int i=1;i<=n;i++){
		cin >> a >> b;
		if(i == p)	 ans = a, cnt++;//输入到当前所在星球时，直接处理，不需存到数组中 
		else if(i != p && a - b >= 0)	s[++k].v = a - b, s[k].t = b;
		//只存储去的星球，a - b为负的不储存（没意义） 
	}
	sort(s + 1, s + 1 + k, cmp);//排个序~ 
	for(int i=1;i<=k;i++){
		if(ans >= s[i].t && s[i].v >= 0){//这里写多余了，只需燃料足够即可，后面的判断可省略 
			ans += s[i].v, cnt++;//燃料增加，星球数增加1 
		}
	}
	cout << ans << endl << cnt << endl;
	return 0;//完结撒花 
}
```


---

## 作者：BetterGodPig (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7700)

题目大意：每此去到编号为 $i$ 的地点，会花费 $b_i$ 的燃料以及获得 $a_i$ 的燃料，给定地点数目和其实地点，求能能搜集到的燃料的最大值以及能访问到的最大的不同星球数。

------------
明显可以得知，要想使最后搜集到燃料最多，就要优先去收益最大的星球，所以考虑使用贪心。

但是，这里有一个问题：如果有一个收益很大的大星球，路费也很高，一开始我们无法到达，但是，在去了几个小星球之后，你的燃料又够了。如果是按 $a-b$ 的值来排序，那么上述情况就无法再次去到一开始遇到的大星球，求出来也自然不是正解。

 我的做法是按照 $b$ 的大小排序(从小到大)，如果相等，则按照 $a-b$ 从大到小排序。在从头到尾扫一遍，如果有收益且燃料够用，就去那个星球。

#### 坑： 如果 $a=b$ ，还是得飞，因为题目要求是访问的最大不同星球数。

最后，贴上代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e5+10;
struct node{
	ll  a,b;
}e[MAXN];
inline bool cmp(node x,node y){
	if(x.b != y.b){
		return x.b < y.b;
	}else{
		return x.a-x.b > y.a-y.b;
	}
}
inline ll read(void){
	ll x = 0,f = 1;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch)){x = x*10+ch-48; ch = getchar();}
	return x*f;
}
ll n,p,now = 0,ans = 1;
int main(){
	n = read(); p = read();
	for(register int i = 1;i <= n;i++){
		e[i].a = read(); e[i].b = read();
	}
	swap(e[1],e[p]);
	sort(e+2,e+n+1,cmp);
	now = e[1].a;
	for(register int i = 2;i <= n;i++){
		if(e[i].a < e[i].b) continue;
		if(now >= e[i].b){
			now += (e[i].a-e[i].b);
			ans++;
		}
	}
	cout<<now<<endl<<ans;
	return 0;
}
```


---


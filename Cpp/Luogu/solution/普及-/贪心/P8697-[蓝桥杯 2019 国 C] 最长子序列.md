# [蓝桥杯 2019 国 C] 最长子序列

## 题目描述

 我们称一个字符串 $S$ 包含字符串 $T$ 是指 $T$ 是 $S$ 的一个子序列，即可以从字符串 $S$ 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 $T$ 完全一样。给定两个字符串 $S$ 和 $T$，请问 $T$ 中从第一个字符开始最长连续多少个字符被 $S$ 包含？ 

## 说明/提示

对于 $20\%$ 的评测用例，$1 \le |T| \le |S| \le 20$；

对于 $40\%$ 的评测用例，$1 \le |T| \le |S| \le 100$；

对于所有评测用例，$1 \le |T| \le |S| \le 1000$。

蓝桥杯 2019 年国赛 C 组 F 题。

## 样例 #1

### 输入

```
ABCDEABCD
AABZ
```

### 输出

```
3
```

# 题解

## 作者：Lovely_Chtholly (赞：19)

### 【分析】

题意题面已经写得很清楚了，我们只需要思考如何求解即可。

容易想到，本题可以直接从两字符串头开始遍历，逐个寻找相同的字符即可，具体实现方法如下：

1. 设置两个循环变量 $i$ 和 $j$，分别代表 $S$ 和 $T$ 的下标。

1. 如果 $S_i=T_j$，则可继续遍历两字符串，并将答案 $+1$。

1. 否则，只需要继续遍历 $S$ 字符串即可。

### 【AC 代码】

```cpp
#include<stdio.h>
#include<string>
#include<iostream>
using namespace std;
int ans;
string s,t;
signed main()
{
	cin>>s>>t;
	for(int i=0,j=0;i<s.size()and j<t.size();i++)
		if(s[i]==t[j])j++,ans++;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：lbdontknow (赞：9)

## 题目解读
从字符串 $S$ 中按顺序挑出一些字符组成字符串，并且要使得该字符串为 $T$ 的前缀。
## 算法分析
我们可以从前往后扫描字符串 $S$ 与字符串 $T$。  
如果当前两个扫描位置的字符相同，则代表字符串 $T$ 当前位置的字符被 $S$ 包含，将长度增加 $1$，将两个字符串的扫描位置都向后移动一位。  
如果对应位置的字符不相同，那么继续扫描 $S$ 后面是否包含 $T$ 当前位置的字符，即将 $S$ 的扫描位置向后移动一位。    

在实现的时候，我们可以使用两个指针 $i$ 与 $j$，分别对应当前扫描到的 $S$ 的位置与 $T$ 的位置。  
如果 $s_i=t_j$，那么将答案 $+1$，并且 $i$ 与 $j$ 都 $+1$。  
如果 $s_i \ne t_j$，则将 $i+1$，向后继续匹配。  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int lens,lent,ans;//lens为字符串s的长度，lent为字符串t的长度。
int main(){
	cin>>s>>t;
	int i=0,j=0;
	lens=s.size();
	lent=t.size();
	while(i<lens&&j<lent){
		if(s[i]==t[j]){//当前位置字符相等
			i++,j++,ans++;//两个扫描位置向后推移一位并且将答案+1
		}
		else{
			i++;//将s的扫描位置向后推移一位
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Furina_Hate_Comma (赞：7)

## 暴力大法好！

update:代码出了锅，感谢评论区指出，已修改。

我们用两个指针 $i$ 与 $j$ 同向扫描。

当 $a_i=b_j$ 时 $j+1$，$i$ 每次都加一来匹配。

再用 $ans$ 统计，当 $i$ 扫到结尾时就可以返回了。
```
#include<bits/stdc++.h>
using namespace std;
char a[114514],b[114514];
int ans;
int main(){
    cin>>a>>b;
    int k=strlen(a);
    for(int i=0,j=0;i<k;i++)
        if(a[i]==b[j])
            j++,ans++;
    cout<<ans;
    return 0;
}
```



---

## 作者：初雪_matt (赞：1)

## 题意

给定两个字符串 $a$，$b$，求 $b$ 从第一个字符开始被 $a$ 所包含的最长长度为多少。

## 思路

可以双重循环，但是时间复杂度不佳。

考虑优化，发现可以双指针，指定一个指针 $j$ 表示 $b$ 中目前所指的字符，另一个指针 $i$ 表示 $a$ 中目前所指的字符。

显然的， $j \le i$，所以循环 $a$ 的字符，当发现 $a_i = b_j$ 时则让 $j+1$ 代表 $a$ 中存在这个字符并向下指定字符，此时答案加一即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,res;
string a,b;
int main(){
	cin>>a>>b;
	int i=0,j=0;
	for(;i<a.length();i++){
		if(a[i]==b[j]) j++,res++;
	}
	cout<<res<<endl; 
}
```

---

## 作者：hycqwq (赞：0)

## 思路

题目要求 $t$ 是**从头开始**匹配，所以我们可以使用贪心的思想。在 $s$ 中找到匹配 $t$ 的字符，位置越靠前越好。

于是这道题就做完了。

## 代码

```cpp
#include <iostream>
#include <string>
using namespace std;

int ans = 0;
string s, t;

int main()
{
    cin >> s >> t;
    for (int i = 0, j = 0; i < t.size() && j < s.size(); j++)//枚举s[j]
        if (t[i] == s[j])//看t[i]与s[j]是否对应
            ans++, i++;//如果对应上了，那么成功匹配的个数++，接下来匹配t中的下一个字符
    cout << ans << endl;
    return 0;
}
```

---


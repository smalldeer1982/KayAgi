# [蓝桥杯 2020 国 C] 重复字符串

## 题目描述

如果一个字符串 $S$ 恰好可以由某个字符串重复 $K$ 次得到，我们就称 $S$ 是 $K$ 次重复字符串。例如 `abcabcabc` 可以看作是 `abc` 重复 $3$ 次得到，所以 `abcabcabc` 是 $3$ 次重复字符串。

同理 `aaaaaa` 既是 $2$ 次重复字符串、又是 $3$ 次重复字符串和 $6$ 次重复字符串。

现在给定一个字符串 $S$，请你计算最少要修改其中几个字符，可以使 $S$ 变为一个 $K$ 次字符串？

## 说明/提示

其中，$1 \le K \le 10^5$，$1 \le |S| \le 10^5$。其中 $∣S∣$ 表示 $S$ 的 长度。

蓝桥杯 2020 年国赛 C 组 G 题。

## 样例 #1

### 输入

```
2
aabbaa```

### 输出

```
2```

# 题解

## 作者：Lemonlwl (赞：45)

## P8739 [蓝桥杯 2020 国 C] 重复字符串 题解
这道题题意很容易理解：

由一个子串重复 $K$ 次得到的字符串称为 $K$ 次字符串，现在需要将一个给定字符串 $S$ 改为 $K$ 次字符串。

我们可以利用贪心思想，在循环时将每一个循环节内的字符计数，选择出现次数最多的那个字符保留，将其他字符全都改动。

解题步骤如下：

1. 判断是否可以分成 $K$ 个循环节（子串），如果不能，输出 $-1$。（不写最后一个点会错，~~[别问我怎么知道的](https://www.luogu.com.cn/record/106299484)）~~

1. 将循环节内的每一个字符放入桶，再进行比较，选择最大值。

附上 [AC](https://www.luogu.com.cn/record/106301357) 代码：


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int k,len,cir,ans,maxn,sum[1005];
string s;
int main(){
	cin>>k>>s;  //输入。
	len=s.length(); //字符串长度。
	cir=len/k;    //循环节长度。
	if(len%k!=0){  //判断是否可以分成K个循环节。
		cout<<-1<<endl;
		return 0;
	}
	for(int i=0;i<len/k;i++){     //因为下标加上循环节长度不能超过总长度，所以是len/k。
		memset(sum,0,sizeof(sum));  //初始化桶。
		maxn=0;       //最大值归零。
		for(int j=i;j<len;j+=cir){
			sum[s[j]]++;    //累加桶。
		}
		for(char c='a';c<='z';c++){
			maxn=max(maxn,sum[c]);  //比较选择最大值。
		}
		ans+=(k-maxn);   //其余字符改动次数累加。
	}
	cout<<ans<<endl;    //输出。
	return 0;
}
```

点个赞再走呗。

---

## 作者：yangmingshuo114514 (赞：7)

这道题我们考虑两种情况：

1.若 $s$ 的长度不被 $k$ 整除，在这种情况下 $s$ 不可能被分成 $k$ 个字符串，输出“ $-1$ ”；

2.若 $s$ 的长度被 $k$ 整除，在这种情况下我们考虑用贪心。每个循环节的同一位都应该是一样的，所以我们要把循环节上同位的字母全部改成相同的。

要想修改的次数越少，选择修改成的字母个数就应该越多，所以我们要选择在循环节同一位上个数更多的字母。此时要修改的次数就是同位的数字减去字母个数。

code:
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
int k,len,cnt[26],ans,maxn;
string s;
int main(){
	cin>>k>>s;
	len=s.length();
	if(len%k!=0) cout<<-1;
	else{
		for(int i=1;i<=len/k;i++){
			memset(cnt,0,sizeof(cnt));
			for(int j=i;j<=len;j+=len/k)
				++cnt[s[j-1]-'a'];
			maxn=0;
			for(int i=0;i<26;i++)
				maxn=max(maxn,cnt[i]);
			ans+=k-maxn;
		}
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：Furina_Hate_Comma (赞：7)

一道贪心题。

### Part 1 不可以，总司令！

当总长度无法整除 $k$ 时，不论如何修改，都无法达成。

### Part 2 如何贪心？

将 $S$ 分为 $k$ 个字符串。

统计 $k$ 个字符串中每个字符串的第 $i$ 位上那个字符最多，选择即可。

### Part 3 为何最优？

由于对于每个字符串的第 $i$ 位，我们都选最多的字符，即修改最少，从局部最优走向全局最优。

代码太水，不放了。



---

## 作者：andyli (赞：4)

当 $n$ 不是 $k$ 的倍数时，$s$ 显然无法修改成 $k$ 次重复字符串。  
否则，将 $s$ 分成 $k$ 组，每组长度为 $\dfrac{n}{k}$，统计每组相应位置上出现次数最多的字母 $c$ 并把不是 $c$ 的字母改为 $c$，累加答案。

```cpp
int main() {
    dR(int, k);
    dR(std::string, s);
    if (len(s) % k)
        return writeln(-1), 0;
    int ans = 0, n = len(s), m = n / k;
    for (int i = 0; i < m; i++) {
        int c[26]{};
        for (int j = i; j < n; j += m)
            c[s[j] - 'a']++;
        ans += k - max(c);
    }
    writeln(ans);
    return 0;
}

```

---

## 作者：pxb0801 (赞：1)

很明显的贪心 ~~（算法标签）~~

-----------------
## 1.分析：

先考虑特殊情况，如果 $|S|$ 不是 $K$ 的倍数，显然不可以，输出 $-1$。如果没有考虑到这种情况，喜提 $90$ 分 WA 一个点。

如果 $|S|$ 是 $K$ 的倍数，那么 $K$ 次字符串的形式大概就是 ```abcabc…``` 这样。显然每一个循环节相同位置的字符是一样的。所以，对于所有循环节的同一个位置，我们看这些位置上哪一个字符数量最多，就取哪一个字符，并且其它字符改成此字符。

----------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
string s;
int main(){
	ios::sync_with_stdio(false);//10^5用cin，关闭同步流
	cin>>k>>s;
	n=s.size();
	s=" "+s;//下标从1开始，个人习惯（
	if(n%k){//特判
		cout<<-1;
		return 0;
	}
	int kk=n/k;//kk是循环节的长度
	for(int i=1;i<=kk;i++){
		int t[30]={0},ma=0;
		for(int j=i;j<=n;j+=kk){//对于所有循环节相同的位置遍历
			t[s[j]-'a']++;
			ma=max(ma,t[s[j]-'a']);//找出现最多的字符出现的次数
		}
		ans+=k-ma;//其它字符要改掉，ans加上去
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ydclyq (赞：1)

本题是个很简单的贪心问题。

首先我们来判断一个字符串修改后能否成为 $K$ 次重复字符串。

很显然只要一个字符串只要能被平均分为 $K$ 份，就一定能成为。反之，一定不能。

假设每份重复字符串的长度为 $c$，显然第 $i,c+i,2 \times c+i,3 \times c +i$ 个字符是对应的，其中出现次数最多的字符是不需要修改的，我们加上其他的字符算出总和便是答案。

```cpp
/*
*/
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e5 + 10;
const int inf = 0x3f3f3f3f;
int T = 1;
char s[N];
int k;
int v[1005];
ll ans; 
void solve(){
    cin>>k>>s;
    int len=strlen(s);
    if(len%k!=0){
        cout<< -1;
        return;
    }
    int c=len/k;
    for(int i=0;i<c;i++){
        memset(v,0,sizeof(v));
        int ma=0;
        for(int j=i;j<len;j+=c){
            v[s[j]]++;
            if(v[s[j]]>v[ma]) ma=s[j]; 
        }
        for(int j='a';j<='z';j++){
            if(j!=ma) ans+=v[j];
        }
    }
    cout<<ans;
}

int main(){
    //cin >> T;
    while (T--) solve();
    return 0;
}
```


---


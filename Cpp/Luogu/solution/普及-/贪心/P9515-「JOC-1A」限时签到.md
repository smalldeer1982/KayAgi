# 「JOC-1A」限时签到

## 题目背景

纵使寻不到身外的青春，

也总得自己来一掷我身中的迟暮。

但暗夜又在那里呢？

现在没有星，没有月光以至没有笑的渺茫和爱的翔舞；

青年们很平安，而我的面前又竟至于并且没有真的暗夜。

绝望之为虚妄，正与希望相同！

                                
——@duanfeitong 摘自鲁迅《希望》

## 题目描述

你现在一条笔直的公路上，我们不妨把这条公路看做成一条数轴，你现在在数轴原点的位置上，此外还有 $n$ 个签到处，第 $i$ 个签到处的坐标为 $x_i$，并且其将在你出发后的第 $a_i$ 个时刻开始营业，每个签到处只有在开始营业了之后你才可以进去签到（签到的时间可以忽略不计），你在每个时刻内至多可移动 $1$ 个单位，你必须在 $t$ 时刻或者在此之前到达坐标为 $f$ 的点（$f\le t$），无论你在规定时间内何时到达 $f$ 点，从 $t$ 时刻起你就必须一直待在 $f$ 点，问你最多能去多少个签到处签到。**请注意，你不需要按照签到处的编号顺序签到。**

## 说明/提示

### 样例 $\small\text{1}$ 解释

一种可行的行动方案如下：在 $5$ 时刻来到第三个签到处签到，然后在 $7$ 时刻来到第二个签到处签到，最后在 $14$ 时刻来到终点，可以证明最多只能去 $2$ 个签到处签到。

### 数据规模与约定

**本题采用捆绑测试**。

| $\textbf{Subtask}$ | $\textbf{Number}$ | $\textbf{Special conditions}$| $\textbf{Points}$ | $\textbf{Limit}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1-2$ | $n\leq 10$ | $10$ | $\small\texttt{1s，128MB}$ |
| $2$ | $3-4$ | $n\leq 5\times 10^3$ | $15$ | $\small\texttt{1s，128MB}$ |
| $3$ | $5$ | $n\leq 10^6$ | $25$ | $\small\texttt{1s，128MB}$  |
| $4$ | $6-7$ | $f\leq 10^5$ | $20$ | $\small\texttt{500ms，128MB}$ |
| $5$ | $8-9$ | $n\leq 10^6$ | $30$ | $\small\texttt{150ms，10MB}$ |

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq f\leq t\leq 10^{18}$，$0\leq x_i\leq f$，$0\leq a_i\leq t$，**不保证签到处的坐标互不相同**。

请注意：由于本题当 $n$ 接近 $10^7$ 时数据输入量过大，故我们决定在 $n\leq 10^6$ 的数据上修改时间限制和空间限制以代替 $n\leq 10^7$ 的数据的评测。

**请注意，本题输入数据量较大，建议使用较快的读入方式。**

---

在我永恒的记忆里，

你天真地微笑。

在我年轻的心中，

你是星星之火燃烧。

——@duanfeitong 摘自祁子《童年》

## 样例 #1

### 输入

```
3 20 10
7 18
3 5
5 0```

### 输出

```
2```

# 题解

## 作者：wmrqwq (赞：10)

# 原题链接
[P9515 「JOC-1A」限时签到](https://www.luogu.com.cn/problem/P9515)

# 题意简述

有一条公路上有 $n$ 个商店，每个商店分别在不同的时刻开放，求如何在 $t$ 时刻之前到达 $f$ 点并且到达最多开放的商店的数量，特别的，一个时刻只能走一格。

# 解题思路

这一道题是一道贪心题。首先，因为要在 $t$ 时刻之前到达 $f$ 点，所以我们可以直接理解为要在 $t-f$ 的时刻到达原点。所以，为了避免走过重复的路径，我们可以到一定的时刻直接从原点走到 $f$ 点，只需要判断 $x_i-a_i$ 是否大于 $t$ 即可，如果成立，就将 $ans$ 增加 $1$，最后直接输出 $ans$ 即可。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define QwQ return 0;
long long n,t,f,a,b,ans;
namespace IO {//快读
    const int MAXR = 100000;
    char _READ_[MAXR], _PRINT_[MAXR];
    int _READ_POS_, _PRINT_POS_, _READ_LEN_;
    inline char readc() {
    #ifndef ONLINE_JUDGE
        return getchar();
    #endif
        if (!_READ_POS_) {
            if (feof(stdin)) return -1;
            _READ_LEN_ = fread(_READ_, 1, MAXR, stdin);
        }
        char c = _READ_[_READ_POS_++];
        if (_READ_POS_ == _READ_LEN_) _READ_POS_ = 0;
        return c;
    }
    template<typename T> inline int read(T &x) {
        x = 0; register int flag = 1, c;
        while (((c = readc()) < '0' || c > '9') && c != '-')
            if (c < 0) return -1;
        if (c == '-') flag = -1; else x = c - '0';
        while ((c = readc()) >= '0' && c <= '9') x = x * 10 - '0' + c;
        x *= flag; return 0;
    }
}
int main()
{
	cin>>n>>t>>f;
	t-=f;//贪心结论1
	for(int i=0;i<n;i++)
	{
		IO::read(a);
		IO::read(b);//注意，这里为了避免MLE，所以直接将数组转化为变量
		if(b-a<=t)	//贪心结论2
			ans++;//如果符合，将ans增加1
	}
	cout<<ans;//输出答案
	QwQ;//华丽的结束
}

```


---

## 作者：zhuweiqi (赞：10)

题目大意：让你在数轴上找到一条路径，使其在 $t$ 时刻之内从原点赶到坐标为 $f$ 的点，且离开每个点的时间（即最后一次经过的时间）尽可能地晚。

容易发现这是个贪心问题，对于每个签到处 $i$，它的坐标是 $x_i$，营业开始时间为 $a_i$，我们最晚要在 $t-(f-x_i)$ 时刻出发赶往终点，此时出发正好可以在 $t$ 时刻赶到终点，因此，如果 $t-(f-x_i)\geq a_i$（移项后即为 $x_i+(t-a_i)\geq f$）这个条件成立，就说明可以去第 $i$ 个签到处签到。我们离开每个点的时候是否都可以是最晚的呢？答案是肯定的，我们只需要在 $t-f$ 时刻从原点出发赶往终点 $f$ 即可。参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll n=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10^48);
	return;
}
int main(){
	int n=read(),ans=0;
	ll t=read(),f=read(),x,a;
	while(n--){
		x=read(),a=read();
		if(x+(t-a)>=f) ans++;
	} 
	write(ans);
	return 0;
}
```

---

## 作者：渡鸦2007 (赞：7)

本题看似吓人，实际上由于签到不花费时间而签到站**不会关闭**，而 $0\leq x_i \leq f$ 保证了人的坐标不会大于 $f$。故我们只要让自己**出发时间尽量迟，就可最大化签到数量**。

具体地，我们考虑：$t$ 时刻到达 $f$，则最迟出发时间为 $f-t$，故到达 $x_i$ 的合法最迟时间是 $f-t+x_i$，若 $f-t+x_i \ge a_i$，即可以在第 $i$ 站签到。

代码实现如下，时间复杂度 $O(n)$，空间复杂度 $O(1)$：

```cpp
int n,t,f;cin>>n>>t>>f;
int ans=0;
for (int i=1;i<=n;++i)
{
	int xi,ai;xi=read();ai=read();
	if (ai+f-xi<=t) ++ans;
}
	cout<<ans;
```


---

## 作者：sbno333 (赞：5)

我们先看题，我们发现 $x_i\le f$，即不用考虑 $x_i>f$ 的情况，其次，我们发现时空限制较小，因此，我们得到结论，存在正解，使的不用开数组，且为常数不高的 $O(n)$ 的算法，于是我们开始思考。

其实可以用贪心，我们到达一个签到点时，越晚，签到成功的概率越高，而且如果来早了能签到，则晚了也能签到，我们可以从 $0$ 点直接走到 $f$ 点，中途能签到的就签到，不能签到的就不签到，而到 $f$ 以及各个签到点花费的时间是固定的，而每到一个签到点，如果全速赶往终点能到，则我们可以考虑，先前说我们可以用贪心，于是我们可以现在起点躺平，直到再躺平就无法到达终点为止，然后全速赶往终点，对于每个签到点，如果躺平时间加起点到签到点的时间小于允许签到时间，即无论如何也无法签到成功，因为假设能签到成功，则我们为了能签到，到该签到点的时间会变长，而不变长只能刚好到终点，变长了，再出发就无法到达终点，因此不行，除此之外我们一定能在该签到点签到成功。

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	cin.sync_with_stdio(0);
	long long n,t,f;
	cin>>n>>t>>f;
	t-=f;//我们最多能躺t-f的时间
	int ans;
	ans=0;
	for(int i=1;i<=n;i++){
		long long x,y;
		cin>>x>>y;
		if(t+x>=y){
			ans++;//签到成功
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Daidly (赞：3)

- 有结论：对于选的点，不走回头路。

假设从 $0\to x_i\to x_j$，其中 $x_i<x_j$。若走到 $x_j$ 再回头，则至少花费 $a_i+(x_j-x_i)$（其实还要考虑与 $a_j+2(x_j-x_i)$ 等取 $\max$），这个花费显然是不优于在 $x_i$ 等完之后直接走到 $x_j$ 的花费 $a_i+(x_j-x_i)$ 优。

- 有结论：在后面等不如在前面等。

在 $x_j$（后面）等 $1$ 单位时间和在 $x_i$（前面）等 $1$ 单位时间对于 $x_j$ 之后是等价的，而对于中间部分 $x_i$（前面）显然 $x_i$ 优于 $x_j$。

- 空间只有 $\text{10MB}$ 怎么办？稳了！

离线需要存数组（其实离线只开一个数组好像也能够），我们考虑在线做

一路不停最后剩余的时间 $t-f$ 可以等价换到最前面，此时对所有位置都有 $t-f$ 的贡献，我们只需要对每一对数判断是否满足 $a_i-x_i\leq t-f$ 即可。

- 跟上 Unrated 的节奏！酷！



---

## 作者：wangweichen666 (赞：2)

## 题目大意
给定一个数轴，上面有 $n$ 个签到处，每个签到处都会在第 $a_i$ 秒时开放你去签到，必须在 $t$ 时刻之前走到数字为 $f$ 的点。
## 题目分析
首先，我们可以观察样例，根据样例来推测我们的结论，我们看样例：

输入
```
3 20 10
7 18
3 5
5 0
```
输出
```
2
```
我们观察一下那个最后没有去签到的签到处，就可以发现：这组数据中，这个签到处虽然位置在 $7$，但是它在第 $18$ 的时刻才开放签到，而我们需要在 $20$ 时刻内就走到 $10$ 的位置，这就意味着留给我们的时间仅仅只有 $2$ 的时刻，而这家签到处的位置为 $7$，离我们需要走到的 $10$ 有 $3$ 的距离，而 $3 > 2$，这就说明了我们无法在 $20$ 个时刻内走到 $10$ 的距离，所以就不能去这个签到处签到。

根据上述的分析，我们就可以总结出一个规律，也就是当 $f-x_i \le t-a_i$ 时，这个签到处就不可以签到。

有了这个结论，我赛时第一次就打出了这个代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,f,a[1000005],x[1000005],ans=0;
bool tf[1000005]={false};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>t>>f;
	for(int i=1;i<=n;i++) cin>>x[i]>>a[i];
	for(int i=1;i<=n;i++)
		if(f-x[i]>t-a[i]) tf[i]=true;
	for(int i=1;i<=n;i++)
		if(!tf[i]) ans++;
	cout<<ans;
	return 0;
}
```
提交上去后，只得了 $70$ 分，没错，剩下的点 MLE 了。所以现在我们需要考虑一种内存占用不那么高的方法。

仔细看这份代码，就能发现，我们完全没有必要开 $a$ 数组和 $x$ 数组，我们完全可以一边输出，一边判断。修改的代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,f,ans=0;
bool tf[1000005]={false};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>t>>f;
	for(int i=1;i<=n;i++){
		long long x,a;
		cin>>x>>a;
		if(f-x>t-a) tf[i]=true;
	}
	for(int i=1;i<=n;i++)
		if(!tf[i]) ans++;
	cout<<ans;
	return 0;
}
```
虽然这份代码可以 AC，但是我们完全可以不要 $tf$ 数组，完全可以直接让 $ans$ 每次递增，所以最后 AC 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,f,ans=0;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>t>>f;
	for(int i=1;i<=n;i++){
		long long x,a;
		cin>>x>>a;
		if(f-x<=t-a) ans++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Red0rangE (赞：1)

## 题意理解

给出 $n$ 个在数轴上的点，终点 $f$ 并有总时间 $t$。要求在指定时间内尽可能多的到达给出的点，并在规定时间前到达 $f$。

之后每一行给出一个点的数轴坐标 $x$ 和开放时间 $a$，只有在 $a$ 后到达才算数。

## 思路阐述

有个特殊性质，所有点都在出发点到终点的路径上，所以顺路，我们的行进路线就是数轴正方向了。

知道路径就简单了，只需要判断每个点如果在 $a$ 到的话能不能按时到终点，可以就加计数，否则跳过.

由于所有点都在 $f$ 左侧，所以它们的距离就是 $f-x$，又因为单位时间可以走 $1$，所以从点到终点的最短时间是 $a+f-x$，只要它比 $t$ 小就行了。

**注意数据范围。**

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
int n,t,f;
int x,a;
int ans;

signed main(){
    
    scanf("%lld%lld%lld",&n,&t,&f);
    for (int i=1;i<=n;i++){
        scanf("%lld%lld",&x,&a);
        if (f-x+a<=t)
            ans++;
    }
    printf("%lld",ans);
    return 0;
    
}

```
希望可以帮到各位大佬。

---

## 作者：执着之幻 (赞：1)

## 题意 ：

一条线段上有 $n$ 个点，每个点都有一个规定的时刻，你一开始在坐标为 $1$ 的点，每一个单位时间你可移动 $1$ 单位距离，你需要在规定的时间内到达终点，而在你走到终点的路程中，若你到达某个点，且到达那个点的时刻大于那个点规定的时刻，便可记录你到过此点，问你在符合要求的情况下最多能记录多少个点？

## 分析：

我们考虑，题目中说你要在规定的时刻到达终点，可以通过贪心策略可以证明，一直往终点走，不回头，这样的策略是最优的。 

现在我们考虑是否能记录某个点，我们可以采取贪心策略，先拿离自己近的点，就是一路走到终点能拿尽拿，这时我们可以考虑把所有点存起来排序，然后按照坐标点从小到大，然后逐个判断是否可以把这个点加上。这就是贪心，最终的答案可以保证是最优的。

但再返回题目看时间和空间限制，很显然，上面的解法并不是正解，还需要继续优化。 

这时我们继续考虑，是否可以通过 $O(n)$ 的时间复杂度以及不开数组去解决这道题呢？答案是可以的。 

考虑正解，这时我们采用极限思想，就是考虑我既然要在规定的时间内到达终点，那是不是就意味着我在原地可以等到某个时刻出发，刚刚好能在规定的时间内到达终点，那这样就不用再去考虑，我在中途走到一个点还要等待多久才能到达下一个点，也无需考虑若我要记录这个点，我是否能在规定的时间内到达终点的情况了。

举个例子：比如我要在 $20$ 个单位时间内到达坐标为 $11$ 的点，我可以在原地等待 $9$ 个单位时间，这时出发是一定能在 $20$ 之内到达 $11$  这个点，而且是恰好能到。此时我们在去经过被标记的点，当我们到达某个点的时候，我们已经没有时间再在这个点多待 $1$ 个单位时间了，不然就无法到达终点，那这个到达的时刻便是我们能到达这个点的最晚时刻，这时再考虑是否符合点的要求即可。

思路大概是这样，那如何去判断一个点是否能被记录呢？

举个例子就很容易理解了：我们有一个点 $x$，它的坐标为  $5$，而它要 $8$ 个单位时间过后才能被记录，而我们需要在 $10$ 个单位时间到达 $6$，我们可以通过上述的思路，可以计算出我们最晚可在 $4$ 的时刻出发，此时到达 $5$ 的最晚时间则是 $9$，显然是可以被记录的。

这时就可以把判断能否记录这个点的条件写出来了：

记我们要在 $n$ 时间内到达 $m$ 点，此时有个点的坐标为 $x$，能被标记的时刻为 $y$。

若 $m-n+x \ge y$，则说明这个点是可以被记录的；否则则不行，而最后我们统计的就是最大能被记录的点了。 

根据这个条件，我们就可以输入的时候直接判断即可。 

时间复杂度：$O(n)$

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll n=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}//可用快读优化
int n;
long long t,f,x,y,s;
int main()
{
	cin>>n;
	t=read();
	f=read();
	for(int i=1;i<=n;i++)
	{
		x=read();
		y=read();
		if(f-x>t-y);//根据条件判断是否可以记录这个点
		else s++;
	}
	cout<<s;
    return 0;
}
/*
1 2 3 
2 4 7
 1 +2
*/
```


---

## 作者：Kedit2007 (赞：1)

### P9515「JOC-1A」限时签到 题解

题目大意比较清晰，直接开始分析。

考虑什么情况下**不能**进入一个签到点签到。不难想到，若签到完成后一路向终点走，仍然不能在规定时间内到达终点，那么就不可能进入这个签到处。

定义最晚从位于 $i$ 处的签到处出发而能在规定时间到达终点的时间为 $l_i$，易得 $l_i = t - (f - i)$。那么只要保证在每个签到处都尽量从 $l_i$ 时刻出发，就能签到尽可能多次。

不难发现从原点到终点 $l_i$ 递减，这意味着我们可以做到**每一个**签到处都从 $l_i$ 时刻出发，只需比较 $a_i$ 与 $l_i$ 即可判定能否在该签到点签到。

注意数据超出了 ```int32``` 的范围。同时这道题时限卡得比较紧，可以用出题组给出的快速读写模板。

## 参考代码

```cpp
void work()
{
    int n = read(), t = read(), f = read();
    int ans = 0;
    for (int i = 0; i < n; i++)
    {
        int x = read(), a = read();
        int time_needed = f - x;
        int time_given = t - a;
        if (time_needed <= time_given)
        {
            ans++;
        }
    }
    write(ans);
}
```

---

## 作者：RegisterFault (赞：1)

题意应该不用复述了。

贪心的想，如果对于两个签到点 $i, j$ 满足 $x_i < x_j$，若有 $a_i + (f - x_i) \le t$，$a_i + (x_j - x_i) \ge a_j$，那么一定要签 $i$。换言之，如果签了 $i$ 之后能走到终点，而且顺道能把 $j$ 也签了，那是再好不过的了。

所以考虑对于每个签到点 $i$，如果签了它不耽误走到终点就一定签，因为后面的都可以顺道签。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

using LL = long long;
const int N = 1000010;
int n, ans;
LL t, f;
int main() {
	scanf("%d%lld%lld", &n, &t, &f);
	for (int i = 1; i <= n; i ++ ) {
		LL x, a; scanf("%lld%lld", &x, &a);
		if (a + (f - x) <= t) ans ++ ;
	} printf("%d\n", ans);
	return 0;
}
```

---

## 作者：rainygame (赞：1)

比较简单的一道题，建议评橙/黄。

我们肯定是希望尽量晚地到达 $f$ 的，毕竟只要可以 $t$ 秒内到达 $f$ 就可以了，而且越晚就越有希望签到。这时候，我们就可以在原点待 $t-f$ 个时刻，直到最后一刻再出门。

这样，如果 $i$ 签到点还是不可以签到（即 $x_i+t-f < a_i$），就说明真的无法签到了（不然就要迟到了）。否则加上即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1000001

int n, t, f, res, ans, a, x;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> t >> f;
    res = t-f;
    
    for (int i(1); i<=n; ++i){
    	cin >> x >> a;
    	if (res + x >= a) ++ans;
	}
	cout << ans;

    return 0;
}
```


---

## 作者：__Octhyccc__ (赞：0)

因为 $0\le x_i$，所以我们不用考虑有负数的情况。

然后因为 $0\le f\le t\le 10^{18}$，**所以必须开 long long。**

我们可以这样走，设 $time$ 为 $t-f$，我们的最大等待时间为 $time$ 个时刻，我们一直在数轴的原点等待 $time$ 个时刻，然后就向右走，这样可以让每个 $a_i$ 在我们抵达的时刻最小，如果没有开始签到，我们就放弃这个签到处。

还有一点，每个 $x_i$ 可以不用定义，直接用一个变量代替，每次直接重复输入这一个变量即可，否则可能会 MLE。

为什么呢？我们在输入的时候可以令每个 $a_i$ 减去 $time$，这就是我们等待完毕后每个签到处的所需时间，又因为每个时刻最多走 $1$ 个单位长度，到了该签到处时 $a_i$ 的值为 $a_i-time-x_i$，所以当 $a_i-time-x_i\le 0$ 时，该签到处就可以成功签到。

**建议使用快读快写。**

接下来上 AC 代码：

```cpp
#include<cstdio>
#include<cmath>
long long read() {
    register long long x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}
void write(int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9){write(x/10);putchar(x%10+'0');}
	else putchar(x+'0');
	return; 
}//快读快写。
long long y[1000000];
int n;
long long t,f;
signed main(){
	n=read();t=read();f=read();
	long long time=t-f,cnt=0,c=0;
	for(int i=0;i<n;i++){
		c=read();//再说一遍，不要定义 x[i]！
		y[i]=read()-time-c;
		if(y[i]<=0)cnt++;
	}
	write(cnt);
	return 0;//完美结束。
}
```

[AC 记录](https://www.luogu.com.cn/record/120323596)

---

## 作者：fuwei123 (赞：0)

这道题思维难度还是有的。

我们的最蠢的想法是，一直在起点不动，直到再不跑就**来不及**了，也就是在第 $t-f$ 的时刻起跑。如果此时某个签到点还**没开放**，那如果等它开放，我们就**到不了终点**了，只能不签到了。所以此时能签到的点就签到，不能签就**抛弃**。这种方法很好想~~虽然我没想出来。~~ 

别忘记**关流同步**！

下面是 AC 代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, t, f; 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> t >> f;
	int maxn = t - f, ans = 0, x, a;//算出最晚起跑时间
	for(int i = 1;i <= n;i++){
		cin >> x >> a;
		if(a - maxn <= x){
			ans++;
		}//在线计算答案，如果存在数组里会MLE 
	}
	cout << ans;
	return 0;
}
```


---

## 作者：Rainbow_Sky (赞：0)

## 前言

简单贪心题。~~但我还是没在赛场上想出正解。~~

有一种错误的想法，就是本人在场上开了一个 $10^6$ 的结构体数组，结果惨遭 MLE，因此，题目的时间与空间复杂度更应该让我们提起警觉。

## 思路

### 变量设置

我们设总时间为 $T$，需到达的点坐标为 $f$，当前这个的时间为 $t_i$，坐标为 $x_i$。

### 贪心

首先我们要知道在什么情况下，我们才可以到达。当 $f-x_i\le T-t_i$ 时，这个点是可以到达的，也是可以采取的。化简得：

$$\begin{aligned}f-x_i&\le T-t_i\\f&\le T-t_i+x_i\\\end{aligned}$$

所以我们只要边读入，边判断即可。



------------

## 后话

代码就不放了，后面会放视频讲解。

---

## 作者：fish_love_cat (赞：0)

卡我 `cin`，差评（

---

题面中有这么一句值得思考的话：

> 你在每个时刻内**至多**可移动 $1$ 个单位。

把这句话翻译一下就是：

> 每个时刻内，你可选择移动 $1$ 个单位，或者杵在原地。

暗藏玄机！

这就意味着我们可以在签到处等开门，门一开我们就签到然后进行一个溜。

同时我们知道，走到坐标 $f$ 的点正好需要 $f$ 的时间，所以我们可以把多余的时间用于杵在原地。

可以推出，立在原地的时间一定，那么在哪立没有区别。所以我们可以贪心的把立的位置选择在起点（坐标 $0$）的位置，显然不劣。

多余的时间一结束，我们直接直线前往终点。途经开了门的签到点就进行一个到的签，如果没开那也是等不了一点，得继续向终点狂奔。所以我们只需要求出开门时间早过杵在原地的时间加上走到这里时间的签到点数量即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
signed main(){
    int n;
    long long t,f;
    scanf("%d%lld%lld",&n,&t,&f);
    long long sum=t-f;
    for(int i=1;i<=n;i++){
        long long x,a;
        scanf("%lld%lld",&x,&a);
        if(sum+x>=a) ans++;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：史蒂夫的憨憨 (赞：0)

思路：依次输入每个签到处的坐标 $x_i$ 和开店时间 $a_i$，若此点满足 $\max(x_i,a_i)+|x_i-f| \le t$，则为可签到点，最后输出可签到点总数即可。

注意：要用尽量快的输入方式，否则会超时。

代码如下：
```cpp
#include<iostream>
using namespace std;
long long n,t,f,x,a,ans;
long long m(long long a,long long b){
	if(a>b) return a;
	return b;
}
long long ab(long long x){
	if(x>0) return x;
	return -x;
}
int main(){
	scanf("%lld%lld%lld",&n,&t,&f);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&x,&a);
		if(m(x,a)+ab(f-x)<=t){
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```


---


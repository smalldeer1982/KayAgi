# [YsOI2023] 前缀和

## 题目背景

Ysuperman 模板测试的试机题。

小心立秋，小心秋丽。

## 题目描述

立秋有一个长度为 $n$ 的数组 $a$，所有数字都是正整数，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。

例如，数组 $[1,1,2,4,8,16]$ 就有可能是立秋有的一个数组，因为除了第一个数字 $1$，后面的每个数字都是前面数字的和，例如：

- 第二个数字 $1=1$。
- 第三个数字 $2=1+1$。
- 第四个数字 $4=1+1+2$。
- 第五个数字 $8=1+1+2+4$。
- 第六个数字 $16=1+1+2+4+8$。 

现在立秋告诉了秋丽数字 $x$ 存在于这个数组中，秋丽希望知道 $a_n$ 最小会是多少，或者说整个数组最后一个数字最小有多少。

## 说明/提示

#### 样例 1 解释

- 第一组数据只有唯一可能的数组 $[2,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组，分别是 $[2,2,4]$ 和 $[1,1,2]$，所以答案为 $2$；
- 第三组数据有两种可能的数组，分别是 $[2,2,4,8]$ 和 $[1,1,2,4]$，所以答案为 $4$。

#### 样例 2 解释

- 第一组数据只有唯一可能的数组 $[1,1,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组 $[1,1,2]$ 和 $[2,2,4]$，所以答案为 $2$；
- 第三组数据有两种可能的数组 $[2,2,4]$ 和 $[4,4,8]$，所以答案为 $4$。

#### 数据范围

对于前 $30\%$ 的数据，满足 $x$ 不能被 $2$ 整除，或者说 $2$ 不是 $x$ 的一个因数，或者说 $x$ 是奇数。

另有 $30\%$ 的数据，满足 $x$ 可以被 $2^{n-2}$ 整除，或者说 $2^{n-2}$ 是 $x$ 的一个因数。

另有 $20\%$ 的数据，满足 $x\le 1000$，可以证明在这个数据范围下答案可以使用一个 `int` 类型变量存储。

对于 $100\%$ 的数据，满足 $1\le T\le 10^4$，$2\le n\le 20$，$1\le x\le 10^9$。

## 样例 #1

### 输入

```
3
2 2
3 2
4 2```

### 输出

```
2
2
4```

## 样例 #2

### 输入

```
3
3 1
3 2
3 4```

### 输出

```
2
2
4```

## 样例 #3

### 输入

```
3
2 6
3 6
4 6```

### 输出

```
6
6
12```

## 样例 #4

### 输入

```
3
3 3
3 6
3 12```

### 输出

```
6
6
12```

# 题解

## 作者：2011FYCCCTA (赞：18)

[原题](https://www.luogu.com.cn/problem/P9532)

---

### 分析&思路

观察题目给出的数列，可以发现除第一，二个数外，每个数都等于上一个数乘 $2$，因此，除了第一，二个数，每个数必须都是偶数。所以，我们可以根据 $x$ 的奇偶性来分讨：

1. $x$ 为奇数

	$x$ 必定为第一或第二个数，要使结果最小 $x$ 需要是第一个数，而乘 $2$ 的次数为 $n - 2$ 次（除了第一，二个数），因此结果为 $x \times 2^{n - 2}$。
    
2. $x$ 为偶数

	也可以根据如上方法先算出第一个数，再根据如上~~柿子~~式子计算出结果，得到第一个数只要让 $x$ 不断除以二直到除成奇数为止，原因如上，但同时也要满足当前遍历过的数字个数小于等于 $n$，用一个变量记录，注意初始值设成 $2$（$x$ 和前两个数中的一个，因为前两个数一样，一共是两个数）。

**注意：不开 `long long` 见祖宗。**

---
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int t , n , x;
int main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> x;
		long long ans;
		if (x % 2) ans = x * pow(2 , (n - 2));
		else
		{
			int tx = x , sum = 2;
			while (!(tx % 2) && sum < n) {tx /= 2; ++sum;}
			ans = tx * pow(2 , (n - 2));
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：Shadow_T (赞：4)

好像就我一个人是用二分做的。。。。。

如果 $a_1$ 是 $s$，那么其实这个数列就是 $s,2s,4s⋯$，可以考虑二分 $s$，若首项为 $s$ 推出的末项小于 $x$，那么放大 $s$，否则缩小 $s$，直到找到可以满足且最小的 $x$，再推出末项输出即可。

代码：
```cpp
#include <bits/stdc++.h> 
using namespace std;
#define int long long
bool check(int x,int n,int m)
{
	int cnt=1;
	while(x<=n&&cnt<=m)
	{
		if(x==n) return true;
		x*=2;
		cnt++;
	}
	return false;
}
signed main()
{
	int T;
	scanf("%lld",&T);
	while(T--)
	{
		int n,x;
		scanf("%lld%lld",&n,&x);
		int l=1,s,r=x,mid;
		while(l<r)
		{
			mid=(l+r)/2;
			if(check(mid,x,n-1)) r=mid;
			else l=mid+1;
		}
		s=l;
		s<<=(n-2);
		cout<<s<<"\n";
	}
}
```

---

## 作者：hjqhs (赞：3)

容易想到，如果 $a_1=y$，那么 $a_2=y$，$a_3=y \times 2^1$，$a_4=y \times 2^2$，$a_k=y \times a^{k-2}$。  
如果想让 $a_n$ 尽可能小，那么 $a_1$ 就要尽可能小。一种显然的想法是让 $x$ 一直除以 $2$ 直到无法除尽，代码如下：  
```cpp
int tmp=x;
while(tmp%2==0){tmp/=2;++cnt;}
```  
但是这是错误的，因为这个数组长度最多为 $n$，所以如果除以 $2$ 的次数太多，$a_1$ 的值太小，就无法在规定的 $n$ 个数中达到 $x$。因为 $a_n$ 是 $a_1$ 的 $2^{n-2}$  倍，所以除以 $2$ 的真正次数应该是 $\min(cnt,n-2)$。  
然后依次计算 $a$ 每一项的值即可。  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int ans[22];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
//	for(int i=1;i<=22;++i)
//		cout<<ans[i]<<'\n';
	cin>>t;
	while(t--){
		memset(ans,0,sizeof(ans));
		int n,x;
		cin>>n>>x;
		int cnt=0;
		int ok=0;
		int tmp=x;
		while(tmp%2==0){tmp/=2;++cnt;}
		ok=min(n-2,cnt);
		ans[1]=x/pow(2,ok);
		ans[2]=ans[1];
		for(int i=3;i<=n;++i){
			ans[i]=pow(2,i-2)*ans[1];
		}
		cout<<ans[n]<<'\n';
	}
	return 0;
}
```

---

## 作者：AKPC (赞：3)

### 思路
假设数列 $a$ 的第一个数 $a_1$ 为 $k$，那根据题意手推，容易推算数列 $a$，形为 $\{k,k,2k,4k,8k,16k...\}$。显然，$a_i$ 的值就是 $2^{\max\{0,i-2\}}k$。

推出这个，题意也不难想。贪心的想，安排值为 $x$ 的位置肯定是越在后面就越优的，这一点结合前面是不难想的，也不用过多解释。当然，如果想要安排在第 $i$ 位，则 $x$ 的因数里最少需要 $\max\{0,i-2\}$ 个 $2$，得出 $x$ 因数个数 $\text{cla}(x)$，显然最优可以把 $x$ 排在 $n-\text{cla}(x)$ 位，当然如果 $k+2\geq n$，即最大能放的位置超过了 $a$ 的长度，那最优的显然只能是第 $n$ 位了。假设 $x$ 最优排到第 $j$ 位，答案就是 $2^{\max\{0,j-2\}}x$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int x=0;bool f=1;register char c=getchar();
    while (c<48||c>57){if(c=='-') f=0;c=getchar();}
    while (c>=48&&c<=57){x=x*10+(c^48);c=getchar();}
    return f?x:-x;
}
int cla(int n){
	int sum=0;
	while (n%2==0) n/=2,sum++;
	return sum;
}
int t,n,x;
signed main(){
	t=read();
	while (t--){
		n=read(),x=read();
		if (n<=2) {cout<<x<<'\n';continue;}
		int k=cla(x)+1,g;
		k+1>=n?g=1:g=1<<(n-k-1);
		cout<<g*x<<'\n';
	}
	return 0;
}
```


---

## 作者：lichenzhen (赞：2)

## 题目大意
有一个所有数字都是正整数且长度为 $n$ 的数组 $a$，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。

给出一个数 $x$ 在一个长度为 $n$ 的数组里，问整个数组最后一个数字最小有多少。

## 题目解法
这是一道很明显的贪心题，要想让 $a_n$ 最小，那就想办法让 $x$ 尽量接近 $a_n$。

这时候我们可以通过观察发现序列的规律，序列中的从第 $3$ 位开始，每一位都是前一位的两倍，并且要想让 $x$ 在这个序列中，$x$ 就能被 $2^{n-2}$ 整除（可以通过数据范围发现规律）。

那么我们就直接从 $x$ 开始循环枚举一下能整除 $2^{n-2}$ 并且在这个序列里的数即可。

**循环变量要开 `long long`。**

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int x,n,t;
    cin>>t;
    while(t--){
        cin>>n>>x;
        int ans=pow(2,n-2);
        for(long long i=x;;i*=2){
            if(i%ans==0){
                cout<<i<<"\n";
                break;
            }
        }
    }
}
```


---

## 作者：lizulong (赞：1)

## 思路
该数列可通过下表表示：
- 第一个数字 $x$。
- 第二个数字 $x=x$。
- 第三个数字 $2x=x+x$。
- 第四个数字 $4x=x+x+2x$。
- 第五个数字 $8x=x+x+2x+4x$。
- 第六个数字 $16x=x+x+2x+4x+8x$。

不难发现，从第三个数字开始，每个数字都是前一个数字的两倍。而且数列的内容都取决于 $x$ 的大小，即第一个数字。

如果 $y$ 在这个数列中：

1. $y$ 为奇数，说明 $y=x$。
2. $y$ 为偶数，说明只要将 $y$ 一直除以二并将其作为 $x$，直到出现第一种情况。

有了以上结论，代码~~有手就行~~。
## 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long//不开long long 见祖宗
using namespace std;
signed main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//加速输入输出 
	int T;
	cin>>T;
	while(T--){
		int n,x;
		cin>>n>>x;
		if(n<=2){cout<<x<<"\n";continue;}//n<3要特判
		if(x%2){//以x为起点递推出a[n] 
			int ans=x;
			for(int i=3;i<=n;i++) ans*=2;
			cout<<ans<<"\n";
		}
		else {
			int ans=LLONG_MAX,xx=x;//ans初始值要很大
			while(x%2^1){//直到x为奇数
				int f=0;//f=1 代表x在当前起点所构成的数列中出现过，即这是一种可能的答案。
				int sum=x;//sum=a[n]
				for(int i=3;i<=n;i++) {
					if(sum==xx) f=1;
					sum*=2;
				}
				if(f==1) ans=min(sum,ans);//一个可能的答案，并取最小值
				x/=2;
			}
			cout<<ans/2<<"\n";//ans会多乘一遍2
		}
	}
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/120773818)

---

## 作者：Esperance (赞：1)

诈骗题。什么前缀和（恼。

给定一个序列 $a$，它的第一项为 $y$，后面每一项都为前面所有项的和。手推一下，$a = [y,y,2y,4y,8y,16y,\cdots]$，整理得 $a_i (2 \leq i \leq n) = 2^{i-2}\times y$。

要让序列的第 $n$ 项最小，就必须让 $x$ 尽量出现在序列靠后的位置。

考虑倒着枚举，看 $2^{i-2}$ 能否整除 $x$。如果能则可以算出 $a_n$ 并结束循环。

具体地，$a_n = 2^{n-2}\times y, a_i = 2^{i-2}\times y$，即 $a_n = \dfrac{2^{n-2}\times y}{2^{i-2}\times y}\times2^{i-2}\times{y} = a_i\times 2^{n-i}$。 

```cpp
#include <iostream>
using namespace std;
typedef long long ll; // 不开 long long 见祖宗
ll ksm(ll x,ll b) { // 快速幂板子
	if (b < 1) return 1;
	ll a = x, ans = 1;
	while (b) {
		if (b & 1) ans *= a;
		a *= a;
		b >>= 1;
	}
	return ans;
}
ll T, n, ax;
int main() {
	cin >> T;
	while (T--) {
		cin >> n >> ax;
		for (int i = n; i >= 2;i--) { // 枚举
			ll f = ksm(2,i-2);
			if (ax % f == 0) { 
				cout << ax*ksm(2,n-i) << '\n'; // 输出答案
				break;
			} 
		}
	}
	return 0; // Nightsky_stars qwq
} 
```

---

## 作者：KAqwq (赞：1)

## 思路
事实上，数据范围的提示已经非常明显了，不管是前 $30 \%$ 的数据还是另外的 $30 \%$。
需要进行分类讨论，对于 $x \bmod 2 = 1$，最小的 $a_n$ 一定是 $x \times 2^{n-2}$，前缀和序列显然只有前两位可以为奇数，又因为该序列的第二位与第一位相等，所以可以构造如同以下的序列：
$$x,x,2x,2^2x,...,2^{n-2}x$$
对于 $x \bmod 2 = 0$，给定的数字 $x$ 存在的位置如下所示：
$$1,1,2,...,x$$
$$x,x,2x,2^2x,...,2^{n-2}x$$
显而易见的是，最小的 $a_n$ 一定存在于第一种构造方法下，但我们仍需要确定 $x$ 的下标，于是我们会在 $x \bmod 2 = 1$ 之前一直将将 $x$ 变为 $\frac{x}{2}$，而在我们求出下标之后要与 $n$ 进行比较，在位数 $\le n$ 时，答案一定是 $x$ 本身，否则答案就是 $x \times 2^{n-\text{该偶数在数列中的下标}}$。

## Code
```
#include <bits/stdc++.h>
typedef long long LL;
LL T;
int main(){
	std::cin >> T;
	while (T--) {
		LL n, x;
		std::cin >> n >> x;
		if (x & 1) {
			std::cout << (1 << n - 2) * x << '\n';
		}
		else {
			LL num = x;
			LL ans = 2;
			while (! (num & 1)) {
				num /= 2;
				++ans;
			}
			if (n <= ans) std::cout << x << '\n';
			else std::cout << (1 << n - ans) * x << '\n'; 
		}
	}
	return 0;
}


```



---

## 作者：liwenxi114514 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9532)。

#### 思路：

这题思路其实很简单，我们观察一下式子，容易得到前两项相等。
所以第三项就等于二倍的第二项，第四项就等于二倍的第三项……
我们继续推导，第一、二项都可以被 $2^{0}$ 整除，因为第三项是第二项的两倍，所以它可以被 $2^{1}$ 整除，因为第四项是第三项的两倍，所以它可以被 $2^{2}$ 整除。以此类推，我们发现，第 $n$ 项就可以被 $2^{n-2}$ 整除，推到这里，题目就变得很简单了，我们只需要存一下 $2^{i}$（$0 \le i \le 18$），然后再枚举数列中的数，如果这个数能被 $2^{n-2}$ 整除，那就输出，否则继续枚举。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,x,a[25];
int main(){
	cin>>t;
	long long sum=1;
	for(int i=0;i<=18;i++){
		a[i]=sum;
		sum*=2;
	}
	while(t--){
		cin>>n>>x;
		long long pre=x;
		while(1){
			if(pre%a[n-2]==0){
				cout<<pre<<"\n";
				break;
			}else{
				pre*=2;
			}
		}
	}
	return 0;
} 
```


---

## 作者：LOSpace (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P9532)

[另一种阅读体验](https://www.cnblogs.com/vectorSpace-blog/p/17628163.html)

## 解题思路
设有一序列 $a$，其中 $a_1 = a_2$，第 $k(\ge 3)$ 项为前 $k-1$ 项的前缀和。可以发现前 $q$ 项分别为第 $1$ 项的 $2^0$ 倍，$2^0$ 倍，$2^1$ 倍，$2^2$ 倍，$2^3$ 倍…… $2^{q-3}$ 倍，$2^{q-2}$ 倍。

扩展到整个序列中，可得第 $i(\ge 3)$ 项一定为 $2^{i-2}a_1$。要保证 $a_n$ 尽量小，就可以让 $x$ 出现的位置尽量靠后。

那么可以让 $i$ 从 $n-2$ 开始枚举，每次减 $1$。如果 $x$ 能被 $2i$ 整除，说明 $x$ 再后也只能是序列中第 $i+2$ 个数（前面多减了一个 $2$）；再从 $i+3$ 开始循环到 $n$，依次乘 $2$，乘到 $n$ 次就是 $a_n$ 的最小值了。当然，如果 $n=2$，则直接输出 $x$ 就好啦。

**注意：乘起来的结果可能会很大，要开 long long**。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main() {
    for (cin >> T; T --;) {
        int n;
        long long x;
        cin >> n >> x;
        if (n == 2) {
            cout << x << endl;
            continue;
        }
        for (int i = n - 2; ; i --)
            if (!(x % (1 << i))) {
                for (int j = i + 3; j <= n; j ++)
                    x <<= 1; // 左移1，相当于乘2
                cout << x << endl;
                break;
            }
    }
    return 0;
}
```

---

## 作者：Teto_etf (赞：0)

设第一个数为 $y$，那么可以枚举获得数列如下：

$$y,y,2y,4y,8y,16y,32y,\cdots$$

看下数据范围，$n_{\max}=20$，可以预处理出所有的 $2^n$ 存个数组，然后看思路。

首先是特殊情况：$x$ 为奇数，这说明 $x$ 只能为 $y$，直接输出。

然后我们可以倒序循环 $n \sim 1$（因为我们要让最后一个最小，所以我们要让 $x$ 在数列中的位置尽可能往后（少乘几个 $2$），这是倒序枚举的原因），每一次判断存入的那些次方是否可以整除 $x$，如果可以直接获得答案并 `break` 循环。

以下是 AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int t;
int pow2[30] = {0, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576};

int main() {
	cin >> t;
	while (t--) {
		long long n, x;
		cin >> n >> x;
		if (x % 2) cout << pow2[n] * x << endl;
		else {
			long long ans = 0;
			for (int i = n; i >= 1; i--)
				if (x % pow2[i] == 0) {
					ans = x / pow2[i];
					break;
				}
			cout << (long long)(ans * pow2[n]) << endl;
		}
	}
	return 0;
}
```

P.S.：建议根据 `pow2[]` 数组背一下 $2^n$。

---

## 作者：Hughpig (赞：0)

我们设 $a$ 的第 $1$ 项为 $m$，则第 $2$ 项也为 $m$（前面只有一个数字，自然和为 $m$）。

第 $3$ 项为 $m+m=2m$，第 $4$ 项为 $m+m+2m=4m$，第五项为 $m+m+2m+4m=8m$……

观察发现，每项都为前一项的两倍。

证明：$a_i$ 的值为 $a$ 前 $i-1$ 项的和，即 $a_{i-1}$ 加 $a$ 的前 $i-2$ 项的和。

而 $a_{i-1}$ 就是 $a$ 的前 $i-2$ 项的和，因此 $a_i=2\times a_{i-1}$。

要让 $a_n$ 尽可能小，就要让 $x$ 处于尽可能靠后的位置。我们观察 $x$ 在数组中最大可以作为第几位。

因为上面的结论，从第 $2$ 位开始，第 $i$ 位需要满足 $2^{i-2}\mid a_{i}$（被 $2^{i-2}$ 整除）。

预处理出 $2$ 的次方，然后枚举 $x$ 最大可以被 $2$ 的几次方整除（当然也可以二分，但没必要）。设结果为 $y$，则 $x$ 最大可以作为第 $\max(y+2,n)$ 位（数列只有 $n$ 位)。

如果 $x$ 可以作为第 $n$ 位，那么直接输出 $x$ 即可。

否则的话，因为第 $y+2$ 是 $x$，可以通过 $a_i$ 为 $2a_{i-1}$，不断 $\times 2$ 推出第 $n$ 位。所以第 $y+2$ 位到第 $n$ 位还差 $2^{n-(y+2)}$。

最后考虑 $x$ 最大可以到 $10^9\times 2^{19}$，因此需要使用 `long long` 类型存储变量。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//定义 long long 为 ll
using namespace std;

ll t,n,x,pow_[70];//pow_ 数组记录 2 的次方

int calc(ll qaq){//枚举某数最大可以被 2 的多少次方整除
	int p=0;
	while(qaq%pow_[p]==0)p++;//如果可以被 2 的 p 次方整除，那么就把 p+1
	return --p;//最后多加了一位，要减 1
}

int main()
{
    cin>>t;
    pow_[0]=1;//预处理 pow_ 数组
    for(int i=1;i<=60;i++){
    	pow_[i]=pow_[i-1]<<1;//2^i=2*2^(i-1)，<<1相当于*2
	}
    while(t--){
    	cin>>n>>x;
    	int y=calc(x)+2;//此处用 y+2 代替 y
    	if(y>=n)cout<<x<<'\n';//如果 x 可以作为第 n 位那么直接输出 x
    	else cout<<x*(1<<(n-y))<<'\n';//否则输出 x*2^(n-y)
    	
	}
	return 0;
}
```

---


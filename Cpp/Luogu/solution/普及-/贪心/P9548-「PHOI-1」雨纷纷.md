# 「PHOI-1」雨纷纷

## 题目背景

**形式化题面的表述已更改。**

今夜，雨纷纷……

![](https://cdn.luogu.com.cn/upload/image_hosting/aec4ykim.png)

## 题目描述

在 $n$ 行 $m$ 列的空地上，有一个大小为 $x$ 行 $y$ 列的伞，雨伞不可以旋转。每天向空地随机洒下 $1 \sim k$ 滴雨，已经有雨的格子不会再降下雨，有伞的格子不会被雨淋湿。

但此伞比较特殊，它完全透明，小 X 无法直接得知伞的位置。但是每天结束后，小 X 都会得知空地上每个空格的状态，即有雨滴或无雨滴。注意，小 X 只会得知格子的状态。小 X 无法得知每天在哪里降了雨。

现在小 X 想让你求出**在最好情况下**（即天数最少时）几天可以使伞的位置唯一，以及得到伞的位置后，场上至少的雨滴数量，数据保证有解。

**形式化的讲**，有一个 $n \times m$ 的矩形，你每天可以**至多**删除 $k$ 个格子。问至少需要多少天以及至少需要删除多少格子，才能使得图中完整的 $x\times y$ 的矩形唯一。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $x,y$ |  分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $1\le n,m\le 10$ | 无特殊限制 | $10$ |
| $1$ | $1\le n,m\le 10^3$ | 无特殊限制 | $30$ |
| $2$ | 无特殊限制 | $x=y=2$ | $10$ |
| $3$ | 无特殊限制 | $1 \le x=y \le 10^9$ | $10$ | 
| $4$ | 无特殊限制 | 无特殊限制 | $40$ | 

对于 $100\%$ 的数据，保证 $1 \le x \le n \le 10^9,1 \le y \le m \le 10^9,1 \le k \le 10^9$。

### 样例解释 #1：

第一天在 $(2,2),(2,3),(3,2)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(3,3),(4,4)$。

图片解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/fp2m6ivv.png)
### 样例解释 #2：

第一天在 $(2,2),(7,1)$ 处落下雨滴，第二天在 $(5,4)$ 处落下雨滴，第三天在 $(4,2),(3,4)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(5,2),(7,3)$。

## 样例 #1

### 输入

```
4 4 2 2 3```

### 输出

```
1 3```

## 样例 #2

### 输入

```
7 5 3 2 2```

### 输出

```
3 5```

## 样例 #3

### 输入

```
214 748 3 64 8```

### 输出

```
98 782```

# 题解

## 作者：CultReborn (赞：25)

[原题链接](https://www.luogu.com.cn/problem/P9548)

我是蒟蒻，T1 是简单的贪心、黄题的样子，但是被卡了好久才推出来。所以写个题解加深印象。

如果有问题尽管提出，觉得不错的大佬们请点个赞呗~。

特别鸣谢 @[cxpluogu](https://www.luogu.com.cn/user/713419)。

# 题意（抽象向）

一个 $n\times m$ 的矩形 $A$（空地）中有一个 $x\times y$ 的小矩形 $B$ （雨伞）。对矩形 $A$ 任意地撒点，每次（天）撒 $k$ 个，并返回是否落到矩形 $B$ 内，问**至少**需要多少天、多少雨滴才能确定一个小矩形 $B$。

# 思路（逐步向）

主要思想：贪心。

本题有两个任务，一是求出最少的雨点数 $Rain$，二是求出最少的天数 $Day$（天数比雨点数好求，本题为了提升难度把它们倒了一下）。我们先考虑天数怎么求：

### 天数的求法——

一旦知晓最少雨滴数，只要每天都尽可能地多下雨，那么天数一定是最小的。（贪心）

于是求最少天数的函数呼之欲出：

```cpp
LL Get_Day(LL k,LL Rain){
  if(Rain % k == 0) return Rain / k;
  //正好下完
  else return (LL)Rain / k + 1;
  //多一天处理余数
}
```
### 雨滴数的求法——

最少雨滴数怎么求呢？根据题意，我们需要让一些雨点排除一个雨伞的位置。那么有没有一种可能，我们可以用一个雨滴、排除一个雨伞的位置呢？有！

举个例子，当 $n=7,m=7,x=3,y=2$ 时，我们可以像图片中的那样把 $7\times 7$ 的空地最大地划成  $6$ 个 $2\times 3$ 的**小矩形**。**右边和下面**的**两条的边界**划分不出矩形，我们将其排除在外。

![划分矩形](https://cdn.luogu.com.cn/upload/image_hosting/96uq4z6m.png)

接着，我们在**每个小矩形**和**两条边界**中落雨，排除出一个的标号为 $6$ 的矩形（其实其它的标号也行），它，就是我们所求得的雨伞。可以证明最少的雨点数就是 $可以划分的矩形数-1+边界数$。（贪心）

![降雨](https://cdn.luogu.com.cn/upload/image_hosting/3bei5o27.png)

可以划分的矩形数为 $n \div x \times (m \div y)$。边界数随情况而定，只要计算一下 $n\bmod x$ 和 $m\bmod y$，判断一下右边界和下边界存不存在就好了。 

代码如下：

```cpp
LL Get_Rain(LL n,LL m,LL x,LL y){
  if(n % x == 0 && m % y == 0)
  //没有边界
    return n / x * (m / y) - 1;  
  if(n % x == 0 && m % y != 0)
  //有一个下边界
    return n / x * (m / y);
  if(n % x != 0 && m % y == 0)
  //有一个右边界
    return n / x * (m / y);    	  
  return n / x * (m / y) + 1;
  //有两个边界
}
```

# 代码（丑陋向）

注意一些细节：

1. 开 `long long`。
2. 雨伞不能旋转，所以 $n$ 严格对应 $x$，$m$ 严格对应 $y$。
3. 本题的思路来源：第三个样例中 $(214\div3)\times(748\div64)+1=782$。所以找规律一定是做题的基本艺能。

使用了贪心思想，时间复杂度为 $O(1)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL Get_Rain(LL n,LL m,LL x,LL y){
  if(n % x == 0 && m % y == 0)
    return n / x * (m / y) - 1;
  if(n % x == 0 && m % y != 0)
    return n / x * (m / y);
  if(n % x != 0 && m % y == 0)
    return n / x * (m / y);
  return n / x * (m / y) + 1;
}
LL Get_Day(LL k,LL Rain){
  if(Rain % k == 0) return Rain / k;
  else return (LL)Rain / k + 1;
}
signed main(){
  LL n,m,x,y,k;	
  scanf("%lld %lld %lld %lld %lld",
  &n,&m,&x,&y,&k);
  LL Rain = Get_Rain(n,m,x,y);
  LL Day = Get_Day(k,Rain);
  printf("%lld %lld",Day,Rain);
  return 0;
}
```
[![Page Views Count](https://badges.toozhao.com/badges/01H80B1DKFWZBAEPWVWA6KJVR6/blue.svg)](https://badges.toozhao.com/stats/01H80B1DKFWZBAEPWVWA6KJVR6 "Get your own page views count badge on badges.toozhao.com")

终于看完了！觉得不错请点个赞吧！！！


---

## 作者：sc84bbs (赞：6)

### 题目大意：
有一个 $n \times m$ 的矩阵里有一个不可旋转的 $x \times y$ 的矩阵和一些点，点不能与小矩阵重合，问想要确定小矩阵的位置至少需要几个点。

### 大致思路：
先加点直到大矩阵里不能存在小矩阵，然后再删一个点给小矩阵留出位置，最后再视情况加点，让小矩阵的位置唯一。


### 第一步：

先考虑 $n=x,m=y$ 的矩阵，仅需一个点即可让它不能存在小矩阵。

然后扩展到 $n \neq x,m=y$ 的情况。发现在第 $x$ 列任意位置放一个点，就会导致其左边的 $x$ 列均无法存在小矩阵，可视为大矩阵变为了 
$(n-x) \times m$ 的矩阵。故每隔 $x$ 列放一个点即可。

同理可以扩展到 $n \neq x,m \neq y$ 的情况。在所有横坐标整除 $x$,纵坐标整除 $y$ 的格子放点，即可让整个大矩阵不能存在小矩阵。第一步完成。

共需 $\lfloor \frac{n}{x} \rfloor\times \lfloor \frac{m}{y} \rfloor$ 个点。

### 第二步：

删一个点，很显然删右下角的点可以使出现的空地最小。

### 第三步：

在前两步过后，认为剩余的矩阵是一个 $a \times b$ 的矩阵，其中 $a \leq x < 2a ,b \leq y < 2b $。

若 $a=x，b=y$，无需额外加点，每有一个不等于的，需加一个点。

以上求出了至少的雨滴数量，天数非常好求在此不赘述。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int n,m,x,y,k;
    scanf("%lld%lld%lld%lld%lld",&n,&m,&x,&y,&k);
    int modx=n/x,mody=m/y;
    int ans1=modx*mody-1;
    if(n%x!=0)ans1++;
    if(m%y!=0)ans1++;
    if(ans1%k==0)cout<<ans1/k<<" "<<ans1;
    else cout<<ans1/k+1<<" "<<ans1;

    return 0;
}
```

---

## 作者：sbno333 (赞：3)

我认为这是一道简单橙题，至于比赛时后头的题......绿起步。

### 下面是正式题解：

这道题类似构造，你只要求出雨滴数量 $e$，就能得到天数，即雨滴数量除以 $k$ 想上取整。

雨滴数量我们就尽量让其能尽量筛掉最多的雨伞，考虑贪心，如果筛掉全部雨伞的位置，在 $x$ 的倍数行，$y$ 的倍数列放置，余数不管，这样才能将 $x$ 行 $y$ 列的雨伞卡掉。

然而还需要证明，考虑反证法，假如不成立，即存在更少水滴方案，比如 $x+1$ 的倍数，$y+1$ 的倍数，一定存在雨伞，能够放置，因为缝隙太大了，比如 $1$ 到 $x$ 行，即使列不变，那也能放置。

然而题目要求放置一个雨伞，因此我们就要删点，可以删右下角，不难发现，有余数就不唯一，需要多放点，其他位置一定有余数，而右下角不一定，因此删除右下角。

行和列分别计算，有余数就放一个点，之多放两个。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m,x,y,k;//不开long long见祖宗
	cin>>n>>m>>x>>y>>k;
	long long x1,y1;
	x1=n/x;//计算点数
	y1=m/y;
	long long an;
	an=x1*y1;//原先点数
	an--;//删点
	if(n%x){//分别放置
		an++;
	}
	if(m%y){
		an++;
	}
	cout<<(long long)(ceil(an*1.0/k))<<" "<<an;//计算天数，输出答案
	return 0;
}
```

---

## 作者：hjqhs (赞：3)

真的服了。最后十五分钟想起比赛，六点正好写完了 T1，比赛就结束了，赛后一测， $AC$ 了。不活了啊啊啊啊。  
首先写一个 `calc` 函数，计算一个长为 `xx`，宽为 `yy` 的矩形中需要多少个雨点才能使矩形不存在 $x \times y $ 的无雨点矩形。  
```cpp
int calc(int xx,int yy){
	return (xx/x)*(yy/y);
}
```  
我们以样例二为例：  
![](https://cdn.luogu.com.cn/upload/image_hosting/mfgf3dlk.png)  
这是矩形，我们可以用两个雨点覆盖住一个 $x \times y$ 的矩形，让它成为最后的答案，这边以左下角为例：  
![](https://cdn.luogu.com.cn/upload/image_hosting/87zqcp4k.png)  
此时左下角已经形成了一个答案，所以我们需要填雨点让剩下的区域没有 $x \times y$ 的矩形。把剩下的区域划分成三个正方形：  
![](https://cdn.luogu.com.cn/upload/image_hosting/hmin0vmp.png)  
分别用 `calc` 函数统计需要多少雨点即可。
最后，上代码！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,k;
int calc(int xx,int yy){
	return (xx/x)*(yy/y);
}
signed main(){
	cin>>n>>m>>x>>y>>k;
	int ans=calc(n-x,m-y)+calc(n-x-1,y)+calc(x,m-y-1)+2;
	cout<<(long long)(ceil(ans*1.0/k))<<' '<<ans;
	return 0;
}
```

---

## 作者：LegendaryGrandmaster (赞：3)

求雨滴的最小数量，则我们可以把这个 $n \times m$ 的矩形分割成多个 $a \times b$ 的矩形，而我们可以假设伞的位置在最右下角。

要排除其他的位置的可能性，所以每一个 $a \times b$ 的矩形我们就放一滴雨滴，除了最右下角。所以其他部分共需要 $\lfloor \frac{n}{x}  \rfloor \times \lfloor \frac{m}{y}  \rfloor -1$ 滴雨滴。这很好理解，小学应该经常做到。

最后我们考虑右下角，由于矩形的长和宽不一定能被小的矩形的长和宽整除，则我们还需要雨滴去确定范围。如果长或宽能被整除，则可以确定长或宽所对应的坐标；不能整除则还需每次一滴雨滴去缩小剩余矩形的范围。这应该也很好理解。

如果最终雨滴的数量不能整除 $k$，则我们需要**向上取整**，才可得出天数。

但是

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main()
{
	int n,m,x,y,k;
	cin>>n>>m>>x>>y>>k;
	int ans=(int)(floor(n/x))*(int)(floor(m/y))-1;
	if(n%x!=0)ans++;
	if(m%y!=0)ans++;
	cout<<(int)(ceil(1.0*ans/k))<<' '<<ans;
}
```

---

## 作者：Red_Alert_star (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9548)

$update$：$2023/08/16$  $22:24$：修改了关系式的一个错误（少了 $-1$）

## 题意简述

给你一个 $n \times m$ 的矩形网格和一天最多能染色的格子数 $k$，给矩形网格的任意 $p$ 个格子染上颜色，使得矩形网格中**有且仅有**一个 $x \times y$ 的矩形没有染上任何颜色。求最少染色数 $p$ 以及对应的天数。

## 分析求解

看一眼数据范围：$1 \le x \le n \le 10^9,1 \le y \le m \le 10^9,1 \le k \le 10^9$。

由此可知本题只能寻找数学规律进行 $O(1)$ 求解，否则必然超时。

我们先看题目的样例 $2$：

直接给所有 $3\times 2$ 的矩形的右下角染色，然后再将最后一个 $3\times 2$ 的矩形的左上角用染色块封住（见图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/5a7llze9.png)

还没找到规律？那我们再看下一组手打样例（红色为所求矩形）：

![](https://cdn.luogu.com.cn/upload/image_hosting/m7k2x405.png)

通过两个样例，我们不难得出，总共有 $ \lfloor n \div x \rfloor$ 行与 $ \lfloor m \div y \rfloor$ 列需要染色。而最后一个 $x \times y$ 比较特殊，要根据 $n$、$m$ 与 $x$、$y$ 的数量关系来确定，像第二张图片一样，因为 $n \div x$ 恰好没有余数，所以无需再多染一个格子封住左边， $m \div y$ 没有余数的情况同理。

由此我们可以得出 $p$ 与 $n$、$m$、$x$、$y$ 的关系式：

$$p= \lceil n \div x \rceil + \lceil m \div y \rceil - 1$$

这里的向上取整，可以理解为有余数就 $+1$。

### 结尾

相信看到这里，你已经能够独自写出代码了，这里就不多做展示了。

~~（关系式出来了那不就是个输入输出和简单计算天数的事吗）~~

希望大家不要直接抄袭上面的关系式，自己推一次才能锻炼你的思维，使你进步！

最后一句千古名句：

### 三年OI一场空，不开 long long 见祖宗！

~~别问为什么，说就是我这道题试过没开。~~

**完结撒花~~~**

---

## 作者：Genius_Star (赞：2)

### 题意：

有一个 $n \times m$ 的矩阵，你需要确认其中一个 $x \times y$ 的矩阵，每天你都可以向任意 $1\times 1$ 的方格中洒水，如果洒在了目标矩阵中，那么水不会落在地上（即地不会湿，否则会被打湿），你可以看到地会不会被打湿。。

每天你至多可以向 $k$ 个 $1\times 1$ 的方格中洒水，问最少多少天可以找到这个 $x \times y$ 的矩阵的位置，以及场上至少的雨滴数量。

### 思路：

题意有些不太好懂，就是说这个 $n \times m$ 的矩阵中，每一个 $x \times y$ 的子矩阵都有可能是答案，求至少要洒几天的水，才可以确认其中只有一个子矩阵才是答案。

其实思路很简单，可以先计算要滴多少滴水，我们将 $x \times y$ 的矩阵填入 $n \times m$ 的矩阵中，对于每一个 $x \times y$ 的矩阵，我们都可以在其中洒下一滴水，并且落在了地上，这样，这个矩阵就肯定不是答案，即每隔 $x$ 列滴下一滴水。

那么一个 $n \times m$ 的矩阵其最多可以填入 $(n \div x)+(m \div y)$ 个 $x \times y$ 的矩阵，如果行和列都没有填满，就是说 $n \bmod x \ne 0$ 并且 $m \bmod x \ne 0$ 的话，需要用一滴水将一边的可能答案消掉，那么需要将水滴数量的答案加 $1$。

同时，如果 $n \bmod x = 0$ 并且 $m \bmod x = 0$ 的话，也就是说可以全部填满，那么就一个空位没有了，那么所有 $x \times y$ 的矩阵都有被水淋到，所以我们要消掉一个矩阵的贡献，就将答案减少 $1$。

知道水滴数量了，求天数就很简单了，每次贪心的选最多的 $k$ 滴水，设 $t$ 为需要的水滴数，则天数为 $\lceil \frac{t}{k} \rceil$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double db;
inline ll read(){ 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,x,y,k,t;
int main(){
	n=read(),m=read(),x=read(),y=read(),k=read();
	t=(n/x)*(m/y);
	if(n%x!=0&&m%y!=0)
	  t++;
	if(n%x==0&&m%y==0)
	  t--;
	write((ceil)((db)t/(db)k));
	putchar(' ');
	write(t);
	return 0;
}
```


---

## 作者：joy2010WonderMaker (赞：1)

### 题目分析

我们可以这么构造。

在每个满足 $i \bmod x=0$ 且 $j \bmod y=0$ 的点 $(i,j)$ 下雨，这样答案为 $(n\div x)\times(m\div y)$。

但我们需要留出一个区域放雨伞，不妨设为右下角。

很显然，为了围出雨伞，我们需要放置 $2$ 个点下雨。但如果已经在左边缘外一列有点，那很显然可以少放 $1$ 个，上边缘同理。

很显然，左边缘有点当且仅当 $n\bmod x=0$，上边缘有点当且仅当 $m\bmod y=0$。

因为右下角特殊，所以要去的这个区域，算出来后要减掉 $1$。这样就结束了。

算天数很简单，雨水数除以 $k$ 上取整就是了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,x,y,k,ans;
long long cl(long long a,long long b){
	if(a%b==0)
		return a/b;
	return a/b+1;
}
int main(){
	cin>>n>>m>>x>>y>>k;
	ans=(n/x)*(m/y)-1;
    if(n%x!=0)
        ans++;
    if(m%y!=0)
        ans++;
	cout<<cl(ans,k)<<' '<<ans<<endl;
	return 0;
}
```


---


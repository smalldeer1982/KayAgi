# [NOIP2023] 词典

## 题目描述

小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\cdots,w_n$。每个单词都是一个小写字母构成的字符串。

小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。

对于每个 $1 \le i \le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\cdots , w'_n$，使得对于每个 $j \neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**

对于两个同样长度的字符串 $s = s_1s_2\cdots s_L$ 和 $t = t_1t_2 \cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。

## 说明/提示

**【样例解释 #1】**

- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；
- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；
- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；
- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。

**【样例解释 #2】**

该组样例满足测试点 $4$ 的限制。

**【样例解释 #3】**

该组样例满足测试点 $7$ 的限制。

**【样例解释 #4】**

该组样例满足测试点 $10$ 的限制。

**【数据范围】**

对于所有测试数据，保证：$1 \le n \le 3000$，$1 \le m \le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。

| 测试点编号 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1$ | $1$ | $1$ |
| $2\sim 4$ | $26$ | $1$ |
| $5\sim 7$ | $15$ | $2$ |
| $8$ | $300$ | $300$ |
| $9$ | $10^3$ | $10^3$ |
| $10$ | $3000$ | $3000$ |

## 样例 #1

### 输入

```
4 7
abandon
bananaa
baannaa
notnotn
```

### 输出

```
1110```

# 题解

## 作者：xuan_gong_dong (赞：41)

## 题面
[P9868 [NOIP2023] 词典](https://www.luogu.com.cn/problem/P9868)
## 分析
建议手搓一下样例，以便更好的理清思维。

我们对于每一个字符串，可以存储一个 $k$ 和 $k_2$ 分别表示这个字符串包含的字符中的字典序最小字符与字典序最大字符，这一步可以初始就处理好。

然后判断每一个字符串是否成立时，我们可以直接判断该字符串的 $k$ 是否绝对小于任意其他字符串的 $k_2$（注意这里不能等于，注意到题目中 $w'_i$ 的字典序比 $w'_j$ 都要**小**，而不是**小于等于**，如果当前 $k=k_2$，那只可能当前字符串的字典序大于等于另外的字符串，不符合题意）。

时间复杂度 $O(n^2)$，可以通过此题。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int x=0,f=0;
	char c=getchar();
	while(!isdigit(c))
	{
		f|=c=='-';
		c=getchar();
	}
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return f?-x:x;
}
int n,m;
char c[3010];
int k[3010],k2[3010];
int main()
{
//	freopen("dict.in","r",stdin);
//	freopen("dict.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		scanf("%s",c);
		for(int j=0;j<m;j++)
		{	
			if(j==0)
				k[i]=k2[i]=c[j]-'a';
			else 
			{
				k[i]=min(k[i],c[j]-'a');
				k2[i]=max(k2[i],c[j]-'a');
			}
		}
	}
	for(int i=1;i<=n;i++)
	{		
		int flag=1;
		for(int j=1;j<=n;j++)
		{
			if(i==j)continue;
			if(k[i]<k2[j])
				continue;
			else{//不符合性质，直接输出，且直接跳出循环 
				flag=0;
				printf("0");
				break;			
			}
		}
		if(flag==1)//如果其他所有字符都满足 k<k2,那表示性质成立 
			printf("1");
	}
	return 0;
}
```


---

## 作者：_yjh (赞：16)

对一个字符串 $s_i$，定义将其字符升序排序得到的串为 $up_i$，降序排序得到的串为 $dw_i$。设 $dw_x$ 是所有 $dw_i$ 中字典序最小的。

那么对于不等于 $x$ 的 $i$，比较 $up_i$ 和 $dw_x$ 即可；对于 $x$ 则可以暴力 check。

时间复杂度 $O(n^2 \log n)$ 或 $O(n^2)$。[link](https://www.luogu.com.cn/paste/tzv4e6zu)

---

## 作者：_Dolphin_ (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P9868)

## Solution

由于可以交换任意两个字符且不限次数，所以可以得到当前字符串的任意一种排列。

那么只需要使当前串达到字典序最小的状态（升序排列），其他字符串均达到字典序最大的状态（降序排列），再进行比较即可。

可以先处理出每个字符串的最小值和最大值，如果当前串的最小值比其他每个字符串的最大值都要小，那么可以将其他字符串的最大值都放在串首，将当前串的最小值放在串首，这样就可以使当前串的字典序最小了。

时间复杂度为 $O(n^2)$，可以通过。

### Code(100 pts):

```cpp
#include<bits/stdc++.h>
#define afor(x,y,z) for(int x=y;x<=z;x++)
#define bfor(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
typedef const int cint;
cint N=3010;
struct rec{
	char a,b;//每个字符串的最大最小值
} a[N];
int n,m;
char s[N][N];
int main() {
	scanf("%d%d",&n,&m);
	afor(i,1,n) {
		a[i].a=123,a[i].b=96;
		scanf("%s",s[i]+1);
		afor(j,1,m) {//处理最大最小值
			a[i].a=min(a[i].a,s[i][j]);
			a[i].b=max(a[i].b,s[i][j]);
		}
	}
	afor(i,1,n) {
		bool ans=1;
		afor(j,1,n) if(j!=i&&a[i].a>=a[j].b) ans=0;
		//如果有别的串的最小值大于等于当前串的最大值，那么当前串的字典序不可能最小
		printf("%d",ans);
	}
	return 0;
}
```

---

## 作者：operator_ (赞：8)

# P9868 [NOIP2023] 词典

[题目传送门](https://www.luogu.com.cn/problem/P9868)

## 题解

T1 词典(dict)

考察：贪心

首先任意多次操作本质就是随意排序，所以如果要使 $w_i$ 最小，我们一定会使 $w_i$ 从 $a$ 到 $z$ 排，其它都 $z$ 到 $a$ 排。然后考虑比较字典序的实质：

+ 如果 $w_i$ 中第一个（即最小的）字符都比 $w_j$ 中第一个（即最大的）字符大，那么显然不可能满足性质。

+ 如果相同，那么若存在，我们考虑第一个不同的位置，发现一定有 $w_i>w_j$，而若不存在，则等价于两串相同，也不符合

因此我们只需要记录每个串的最大最小字符即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
int n,m,minn[3005],maxn[3005],fl;
char s[3005];
signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		minn[i]=27;
		scanf("%s",s+1);
		for(int j=1;j<=m;j++) 
			minn[i]=min(minn[i],s[j]-'a'+1ll),maxn[i]=max(maxn[i],s[j]-'a'+1ll);
	}
	for(int i=1;i<=n;i++) {
		fl=1;
		for(int j=1;j<=n;j++)
			fl&=(i==j||minn[i]<maxn[j]);
		printf("%lld",fl);
	}
	return 0;
}
```

时间复杂度 $O(nm+n^2)$，理论可以优化到 $O(nm+n)$，但完全没必要。

---

## 作者：strcmp (赞：7)

考场上因为这道题以为 `strcmp` 返回 `-1,0,1` 寄掉了，geany 和 dev 都是对的，然后喜提保龄。

------------

注意到交换可以进行任意多次，那么考虑最优情况下，对当前字符串按字符升序排序，其余倒序排序，与其余字符串比较即可。直接暴力实现复杂度 $\Theta(n^2m \log n)$，显然过不了。

注意到我们不需要每次暴力排序，把字符串排序下来的结果存下来直接使用即可。时间复杂度 $\Theta(n^2m + nm \log n)$，还是过不了。

考虑预处理 $p_i,\,h_i$ 分别代表前缀和后缀最小的倒序排序的字符串，那么只要当前字符串 $i$ 小于 $\max(p_{i - 1},\,h_{i + 1})$ 就合法，时间复杂度 $\Theta(nm \log n)$。

排序部分使用桶排序，则时间复杂度为 $\Theta(n(m + \Sigma))$，本题中 $\Sigma = 26$，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
char s[3005][3005], t[3005][3005]; 
char qz[3005][3005], hz[3005][3005], c[3005], ans[3005];
int n, m, cnt[30]; 
int main() {
	//freopen("dict.in", "r", stdin);
	//freopen("dict.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%s", s[i]);
	}
	int now = 0;
	for (int i = 1; i <= n; i++) {
		now = 0;
		for (int j = 0; j < m; j++) {
			++cnt[s[i][j] - 'a' + 1];
		}
		for (int j = 1; j <= 26; j++) {
			while (cnt[j]) --cnt[j], s[i][now++] = 'a' + j - 1;
		}
		for (int j = m - 1; j >= 0; j--) t[i][j] = s[i][m - j - 1]; 
	}
	/*
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < m; j++) cout << t[i][j];
		cout << "\n";
	}
	*/
	//exit(0);
	for (int i = 0; i < m; i++) c[i] = 'z' + 1;
	for (int i = 1; i <= n; i++) {
		if (strcmp(c, t[i]) > 0) memcpy(c, t[i], sizeof(t[i]));
		memcpy(qz[i], c, sizeof(c));
		//cout << c << "\n";
	}
	for (int i = m - 1; i >= 0; i--) c[i] = 'z' + 1;
	for (int i = n; i >= 1; i--) {
		if (strcmp(c, t[i]) > 0) memcpy(c, t[i], sizeof(t[i]));
		memcpy(hz[i], c, sizeof(c));
	}
	for (int i = 1; i <= n; i++) {
		for (int j = m - 1; j >= 0; j--) c[j] = 'z' + 1;
		if (i - 1 && strcmp(c, qz[i - 1]) > 0) memcpy(c, qz[i - 1], sizeof(qz[i - 1]));
		if (i + 1 <= n && strcmp(c, hz[i + 1]) > 0) memcpy(c, hz[i + 1], sizeof(hz[i + 1]));
		//cout << c << "\n";
		if (strcmp(s[i], c) < 0) ans[i] = '1';
		else ans[i] = '0';
	}
	printf("%s", ans + 1);
	return 0;
}
/*
15 2
zx
qn
wn
nd
pl
pd
vm
ff
mh
ql
zi
yv
md
ji
oc


对于每个 si，求是否是所有的  j != i 的 tj > si

那么求出前后缀最小的 t 即可。 
 
*/
```

---

## 作者：Moeebius (赞：5)

> [full version](https://www.luogu.com.cn/blog/Moeebius/noip-2023-sol)
>
> 回来吧我的 Trie！我最高傲的信仰！
>
> 回来吧我的 Trie！我最高傲的信仰！
>
> 回来吧我的 Trie！我最高傲的信仰！

![dead_trie](https://cdn.luogu.com.cn/upload/image_hosting/h9x0oncn.png)

如上，使用 Trie 不会被卡常，但是会带来 900+ MiB 的静态空间。

---

首先特判掉 $n=1$；否则第 $i$ 个字符串合法当且仅当 $\forall j\neq i, \min\{w_i\}<\max\{w_j\}$。

**Proof：**

- 如果满足上述条件，一定可以将 $w_i$ 中最小字符挪到开头，$w_j$ 中最大字符挪到开头，即满足条件；
- 否则，$\forall x\in w_i \land y\in w_j,x\ge y$。容易发现无解。$\square$

直接做就好了，时间复杂度 $O(nm)$。

---

```cpp
constexpr ll MAXN = 3005;
int n, m;
char str[MAXN][MAXN], minv[MAXN], maxv[MAXN];

il void Main() {
  freopen("dict.in", "r", stdin);
  freopen("dict.out", "w", stdout);
  read(n, m);
  For(i, 1, n) scanf("%s", str[i] + 1);
  For(i, 1, n) {
    minv[i] = 'z' + 1, maxv[i] = 0;
    For(j, 1, m)
      minv[i] = min(minv[i], str[i][j]),
      maxv[i] = max(maxv[i], str[i][j]);
  }

  if (n == 1)
    return puts("1"), void();

  For(i, 1, n) {
    bool ok = 1;
    For(j, 1, n) if (j != i)
      ok &= minv[i] < maxv[j];
    putchar(ok + '0');
  }
}
```

---

## 作者：rainygame (赞：1)

> 场外人员 VP 的时候写的。

首先最优的方法肯定是用字典序最小的 $i$ 和字典序最大的 $j$ 做对比。

所以考虑暴力对比，但是复杂度是 $O(n^2m)$ 的。

因此考虑优化，我们令 $f_{i,j,k}$ 为第 $k$ 个字符串的第 $i$ 位的字符是否**不为**第 $j$ 个小写字母。

那么判断是只需要对于枚举每一位，然后再枚举比第 $i$ 个字符串的第 $j$ 位大的字符串取交集（这个可以用 `bitset` 优化）就可以了。

最后注意判断第 $i$ 个字符串字符集大小为 $1$ 的情况。

但是这样的复杂度是 $O(\frac{n^2m\rvert\Sigma\lvert}{\omega})$ 的，感觉无法通过。

考虑优化掉复杂度中 $\rvert\Sigma\lvert$ 的部分。

我们可以使用后缀按位与来优化，只需对 $j$ 求一次后缀按位与即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 3001

int n, m;
string s;
string str[MAXN], str2[MAXN];
bitset<MAXN> vis;
bitset<MAXN> f[MAXN][27];

signed main(){
//	freopen("dict.in", "r", stdin);
//	freopen("dict.out", "w", stdout);
	
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n >> m;
	for (int i(0); i<n; ++i){
		cin >> s;
		sort(s.begin(), s.end());
		str[i] = s;
		reverse(s.begin(), s.end());
		str2[i] = s;
	}
	for (int i(0); i<m; ++i){
		for (int j(0); j<27; ++j){
			for (int k(0); k<n; ++k) f[i][j].set(k);
		}
	}
	for (int i(0); i<n; ++i){
		for (int j(0); j<m; ++j) f[j][str2[i][j]-'a'].reset(i);
	}
	for (int i(0); i<m; ++i){
		for (int j(25); j>=0; --j) f[i][j] &= f[i][j+1];
	}
	
	for (int i(0); i<n; ++i){
		vis.set();
		for (int j(0); j<m; ++j) vis &= f[j][str[i][j]-'a'+1];
		cout << ((str[i] == str2[i] && vis.count() == 1) || vis.count() == 0);
	}
	
	return 0;
}
```


---


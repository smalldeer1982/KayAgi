# 古籍翻译

## 题目描述

机器猫跑到外星人的图书馆去读书。有一本外星古籍，里面的内容是用八进制写成的；但机器猫只能处理十六进制的数据。请你帮忙写一个翻译软件，帮机器猫把八进制串翻译成十六进制串。

## 说明/提示

#### 样例解释

第一组样例：八进制 `144` 即十进制下的 100，其十六进制表示为 `64`。

第二组样例：八进制 `1572061125` 即十进制下的 233333333，其十六进制表示为 `de86255`。

#### 数据规模与约定

对于 $40\%$ 的数据，有 $|s| \leq 10$，即输入字符串**长度**不超过 $10$。

对于 $100\%$ 的数据，有 $|s| \leq 1000$，即输入字符串**长度**不超过 $1000$。


## 样例 #1

### 输入

```
144```

### 输出

```
64```

## 样例 #2

### 输入

```
1572061125```

### 输出

```
de86255```

# 题解

## 作者：阮行止 (赞：25)

朴素做法是写一个高精度，对整个数做进制转换。

有更好的做法。注意到每 4 个八进制码包含 12 个 bit 的信息，即对应 3 个十六进制码。故将八进制串每 4 个数位打包，转成十六进制。复杂度 $\mathcal{O}(|s|)$.

例子：`1572061125` 打包为 `[15] [7206] [1125]`，这三个包在十进制下分别是 `13, 3718, 597`。转为十六进制，即 `[d] [e86] [255]`，输出 `de86255`。

有几个细节需要注意：

- 从后往前打包，而非从前往后。从样例中可以看出这一点。
- 除了第一个包之外，输出十六进制时，需要补上前导 0。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

char buffer[100005];

int octToInt(int l, int r) {
    int n = 0;
    for(int i=l; i<r; i++)
        n = n * 8 + buffer[i] - '0';
    return n;
}

void work(int len) {
    int low = max(0, len - 4);
    int n = octToInt(low, len);
    
    if(low) {
        work(low);
        printf("%03x", n);
    } else {
        printf("%x", n);
    }
}

int main() {
    cin >> buffer;
    work(strlen(buffer));

    return 0;
}
```



---

## 作者：ShanCreeperPro (赞：11)

## B3617 古籍翻译 題解

简单题意：给定一个八进制数字，求它的十六进制数。

那么我们首先介绍一下**进制和权重**：

### Part 1 进制

我们人类现在最经常的使用十进制。

对于 $k$ 进制：

- 如果 $k \leq 10$，采用的数字为 0 到 $k-1$。
- 如果 $k > 10$，用完 $0-9$ 后，开始用 $A,B,C,D...$。

那么，题目中的八进制和十六进制的定义就如下：

**逢 8 进 1** 的数字为 8 进制，采用 $0,1,2,3,4,5,6,7$ 这 8 个数字。

**逢 16 进 1** 的数字为 16 进制，采用 $0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f$ 这 16 个符号。

### Part 2 权重

在十进制中：

个位权重是 1，十位权重是 10，百位权重是 100...

$$ (678)_{10} = 6 \times 100 + 7 \times 10 + 8 \times 1 $$

那么如何算出 $k$ 进制数字的 10 进制数字？

我们就可以利用权重算出：

$$ (12341)_5 = 1 \times 5^4 + 2 \times 5^3 + 3 \times 5^2 + 4 \times 5 + 1 = 971 = (971)_{10} $$

看出了什么规律了吗？

***

介绍完了进制和权重后，我们就开始解题。
***

### 0x00 方法1 (cin/cout)

12 分做法：

```cpp
cin>>oct>>a;
cout<<hex<<a<<endl; 
```

C++ 提供了这种便捷的进制转换功能，但很可惜，这道题的数据范围不支持用这种方法。


***
### 0x02 方法2 (long long)

如何实在想不出正确的解法，然后想不出 0x03 的高精度解法，可以进行进制转换（使用 `long long`），可以得到 $40\%$ 的分数。


### 0x03 方法3 (高精度)

将 8 进制转换成 10 进制，然后转为 16 进制。

由于数字很大，需要使用高精度计算，比较繁琐。

### 0x04 方法4 (8-2-16）

这里是对阮行止老师解法的详细补充。

1 个 8 进制数字可以变成 3 位 2 进制数。

|0|1|2|3|4|5|6|7|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|000|001|010|011|100|101|110|111|

1 个 16 进制数可以变成 4 位 2 进制数。

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| 8 | 9 | A | B | C | D | E | F |
| 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | B & C & D & E & F 

从而 4 位 8进制数可以转为 12 位 2 进制数，从而转成 3 位 16 进制数。


$$
1125 \rightarrow 001001010101 \rightarrow 001001010101 \rightarrow 255
$$

所以从右边取出 4 位 8 进制数，就可以变成 2 位 16 进制数。

可以用 2 进制作为跳板，也可以用 10 进制作为跳板。

有很多种方法，这里使用递归的方式依次 4 位 4 位处理。

```
15 0126 1125
D   056  255
```

注意转成 3 位 16 进制数字，如果不是在开头，要补 0 至 3 位：

|$i$|0|1|2|3|4|5|6|7|8|9|10|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|$S_i$|1|5|0|1|2|6|1|1|2|5|  |
|  |  |  |$low<0$|$low$|-|-|-|$low$|-|-|$len$|


这里对阮行止老师的代码进行了扩充，更简单易懂。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fore(i,x,n) for(int i=x;i<=n;i++)
const int MAXX=10005;
const int mod=1;
char b[MAXX];
inline int octtoint(int l,int r){
	int n=0;
	fore(i,l,r-1)
		n=n*8+b[i]-'0';
	return n;
}
inline char inttochar(int n){
	if(n<10) return '0'+n;
	return 'a'+n-10;
}
inline int inttohex(int n,int low){
	int a[5]={0},t=0;
	while(n){
		a[t]=n%16;
		n/=16;
		t++;
	}
	for(int i=low!=0?3-1:t-1;i>=0;i--)
		write(inttochar(a[i]));
}
inline work(int len){
	in low=max(0,len-4);
	int n=octtoint(low,len);
	if(low){
		work(low);
		inttohex(n,low);
	}
	else{
		inttohex(n,low);
	}
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
signed main(){
	cin>>b;
	work(strlen(b));
}
```

### 0x05 其他东西

将一个 `int` 类型数字以 16 进制输出可以这样：

```cpp
printf("%x",n);
```

如果不够，要补前导 0，可以这样：

```cpp
printf("%03x",n);
```






---

## 作者：Node_Edge (赞：10)

吐槽一句，一开始 $|s| \leq 100000$ 的，高精都爆了，不过现在数据改了。

思路很简单，高精加进制转换。

高精这里采取重载可以提高代码可读性，这里附上重载的[链接](https://oi-wiki.org/lang/op-overload/)。

进制转换参考[这里](https://oi-wiki.org/math/base/),如：

$(1234)_{8} = 1 \times 5^3 + 2 \times 5^2 + 3 \times 5^1 + 4 \times 5^0 + 1 = 668 = (668)_{10}$

转十六进制就是把十进制不断除以 $16$，取出余数，倒序输出。

**code**

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
using namespace std;
int key[100005];
char *p1,*p2,buf[100000];
int read(){
    int x=0,f=1;
    char ch=nc();
    while(ch<48||ch>57){
        if(ch=='-')
            f=-1;
        ch=nc();
    }
    while(ch>=48&&ch<=57){
        x=x*10+ch-48,ch=nc();
    }
    return x*f;
}
struct Bigint {
    int len,a[200005];//len记录数位
    int &operator[](int i) {//重载[]，把(变量名).a[i]替换成a[i]
        return a[i];
    }
    Bigint(string s="") {//用字符串赋值
        memset(a,0,sizeof(a));
        len=1;
        for(int i=0; i<s.size(); i++,len++) {
            a[len]=s[i]-48;
        }
        len--;
        reverse(a+1,a+len+1);
    }
    void flatten(int L) {//展平，相当于进位
        len=L;
        for(int i=1; i<=len; i++) {
            a[i+1]+=a[i]/10,a[i]%=10;
        }
        for(; !a[len];) {
            len--;
        }
    }
    bool judge() {//判断大整数是否为0
        if(a[max(len,1)]==0) {
            return false;
        } else {
            return true;
        }
    }
    void print() {//输出，不过这份代码中没什么用
        for(int i=max(len,1); i>=1; i--) {
            cout<<a[i];
        }
    }
};
Bigint operator+(Bigint a,Bigint b) {//重载加号
    Bigint c;
    int len=max(a.len,b.len);
    for(int i=1; i<=len; i++) {
        c[i]=a[i]+b[i];
    }
    c.flatten(len+1);
    return c;
}
Bigint operator/(Bigint a,int b) {//重载除号
    Bigint c;
    int len=a.len;
    int x=0;
    for(int i=len; i>=1; i--) {
        c[i]=(x*10+a[i])/b;
        x=(x*10+a[i])%b;
    }
    c.flatten(len+10);
    return c;
}
int operator%(Bigint a,int b) {//重载膜
    Bigint c;
    int len=a.len;
    int x=0;
    for(int i=len; i>=1; i--) {
        c[i]=(x*10+a[i])/b;
        x=(x*10+a[i])%b;
    }
    c.flatten(len+10);
    return x;
}
Bigint operator*(Bigint a,int b) {//重载乘号
    Bigint c;
    int len=a.len;
    for(int i=1; i<=len; i++) {
        c[i]=a[i]*b;
    }
    c.flatten(len+11);
    return c;
}
char handle(int x) {
    if(x>=0 && x<=9) return (x+48);
    else return (x+96-9);
}
int main() {
    string s;
    cin>>s;
    Bigint ans("0"),a(s);//字符串赋值
    int k=8;
    Bigint x("1");
    for(int i=1; i<=a.len; i++) {//转十进制
        Bigint c=x*a[i];
        ans=ans+c;
        x=x*k;
    }
    int i=0;
    while(ans.judge()) {//转16进制
        key[i++]=ans%16;
        ans=ans/16;
    }
    for(int j=i-1; j>=0; j--) {//倒序输出
        cout<<handle(key[j]);
    }
    return 0;
}
```


---

## 作者：DPseud (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/B3617)

注：本题解是一篇 python 题解。

此题的意思很简单：给出一个 8 进制数，输出它的 16 进制形式。但是此题的数据极大，若是用高精度代码会非常复杂，但是，我们可以用自带高精度和进制转换的 python！

我们需要了解 python 中将进制转换为 16 进制的函数：

```python
hex(int(a,d))//a是数字，d是原来数字进制
```
按理来说，这道题做到这已经完事了，但是，还有两个细节需要注意：

首先是输入时不能用 int(input())，得用 input()；其次是 hex 函数默认会加上前缀 0x，需要在后面加上 [2:] 来删除前两位。

### 代码（应该是所有题解中最短的了）：

```python
q=input()//输入8进制的q
print(hex(int(q,8))[2:])//输出16进制的q
```


---

## 作者：可爱的小于 (赞：7)

[原题传送门](https://www.luogu.com.cn/problem/B3617) [采用博客食用更佳](https://keaidexiaoyu.blog.luogu.org/solution-b3617)

**题目大意：** 给定一个八进制串，将其转化为十六进制串。

难度评级：橙

标签：进制转化

**解题方法一：**

将八进制串转化为十进制串，再将十进制串转化为十六进制串。

把八进制数按权展开，相加即可得十进制数，也就是让八进制各位上的系数乘以对应的权，然后求其和。

例如：

八进制数 $18$ 转化为 十进制数：

$(18)_8 = 8 \times 8^0 + 1 \times 8^1 = (16)_{10}$

再将十进制转化为十六进制：

十进制转化为十六进制计算方式，简单说就是整数除以16取余，直到商为0为止，然后反向输出。

代码自己思考。

**解题方法二：**

将八进制串转化为二进制串，再将二进制串转化为十六进制串。

将八进制串每一个位转化为 $3$ 个二进制位，再将二进制串每 $4$ 位转化为十六进制（注意位数不足时补 $0$）。

输出时要加上特判。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e5+5;
string s;
char sr[20]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
int a[maxn],t=0;
int main()
{
    cin >> s;
    if(s=="0"){
        cout << 0 << endl;
        return 0;
    }
    for(int i=s.size()-1;i>=0;i--,t+=3)
        if(s[i]=='0')a[t]=0,a[t+1]=0,a[t+2]=0;
        else if(s[i]=='1')a[t]=1,a[t+1]=0,a[t+2]=0;
        else if(s[i]=='2')a[t]=0,a[t+1]=1,a[t+2]=0;
        else if(s[i]=='3')a[t]=1,a[t+1]=1,a[t+2]=0;
        else if(s[i]=='4')a[t]=0,a[t+1]=0,a[t+2]=1;
        else if(s[i]=='5')a[t]=1,a[t+1]=0,a[t+2]=1;
        else if(s[i]=='6')a[t]=0,a[t+1]=1,a[t+2]=1;
        else a[t]=1,a[t+1]=1,a[t+2]=1;
    if(t%4==0)a[t+3]=0,a[t+1]=0,a[t+2]=0,t+=3;
    else if(t%4==1)a[t+2]=0,a[t+1]=0,t+=2;
    else if(t%4==2)a[t+1]=0,t++;
    for(int i=t;i>=0;i-=4){
        int sum=a[i]*8+a[i-1]*4+a[i-2]*2+a[i-3]*1;
        if(i!=t||sum!=0)cout<<sr[sum];
    }
    return 0;
} 
```




---

## 作者：Untitled_unrevised (赞：6)

发一篇使用 Java 高精度整数类 `java.math.BigInteger` 的做法吧。

做这题需要 `java.math.BigInteger` 以下函数：

- 构造器函数 `BigInteger(String val, int radix)` ：在 `radix` 进制下把字符串 `val` 转换成高精度整数。

- toString 方法 `toString(int radix)` ：以字符串形式返回该高精度整数在 `radix` 进制下的表示。

然后为了读入字符串，还需要 `java.util.Scanner` 类的这些函数：

- 构造器函数 `Scanner(InputStream source)` ：这个可以不用了解，因为基本都是用 `Scanner(System.in)` 来初始化的（

- next 方法 `next()` ：读入一个单词。

剩下的看代码应该就懂了。

```java
//导入
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);	//初始化
		String s = scan.next();					//读入字符串
		BigInteger bi = new BigInteger(s, 8);	//在八进制下将字符串 s 转换成高精度整数并赋给 bi
		System.out.print(bi.toString(16));		//输出 bi 在十六进制下的表示
	}
}
```

最后，关于 `java.math.BigInteger` 的其它信息，可查阅 https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html 。

以上。

---

## 作者：TensorFlow_js (赞：6)

### 题意简述

把一个大八进制整数翻译成十六进制整数。

### 题目分析

一切高精度题都可以用 Python 做。

直接用 Python 的转换即可。

下面代码使用了如下函数：

1. `print()` ： Python 输出函数，不解释。

2. `hex(int)->string` ： 将十进制整数转换为带有 `0x` 标记的十六进制字符串。

3. `int(string,x:int)->int` ： 将一个 $x$ 进制的字符串转换为 $10$ 进制的整数。

4. `input()` ： Python 输入函数，不解释。

5. `string.replace(old:string,new:string)->string` ： 将原字符串中的所有 $old$ 替换为 $new$。

### 代码

```python
print(hex(int(input(),8)).replace("0x",""))
```

---


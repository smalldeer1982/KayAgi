# 10 进制转 x 进制

## 题目描述

给定一个十进制整数 $n$ 和一个小整数 $x$。将整数 $n$ 转为 $x$ 进制。对于超过十进制的数码，用 `A`，`B` ... 表示。 



## 说明/提示

【数据规模和约定】  
保证 $n$ 不超过 $10^9$，$x$ 不超过 $36$。

## 样例 #1

### 输入

```
1000
2
```

### 输出

```
1111101000
```

# 题解

## 作者：liangbowen (赞：39)

[题目传送门](https://www.luogu.com.cn/problem/B3619)

[$\color{red}{see}\space \color{green}{in}\space \color{blue}{my}\space \color{purple}{blog}$](https://www.luogu.com.cn/blog/liangbowen/solution-B3619)

小学生又双叒叕来写题解啦！

这题就是 $10$ 进制转 $x$ 进制的模板题。

我们可以使用**短除法**加**倒取余数**实现。

具体如下，这里借用了百度搜索的图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/eulak8eq.png)

那么如何在程序中实现呢？

我们可以使用 `while()` 语句。

具体如下：

```cpp
string ans = "";  //存储答案。
while (n != 0)    //模拟短除法。 
{
	ans += dict[n % x];
	n /= x;
}
```

观察这段代码，大家都会有疑问：`dict[n % x]` 是神马东西？

`dict` 数组是**数组字典**，如下。

```cpp
string dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
```

到这里，题目就快做完了，但别忘了，还得**倒取余数**！

```cpp
string t = "";  //倒取余数。
for (int i = ans.length()-1; i >= 0; i--) t += ans[i];
```

最后，把这些代码拼起来就完事了。

## 完整代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
string dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
string ten_to_x(int n, int x)  //十进制转 x 进制函数。 
{
	string ans = "";
	while (n != 0) //模拟短除法。 
	{
		ans += dict[n % x];
		n /= x;
	}
	string t = "";  //倒取余数。
	for (int i = ans.length()-1; i >= 0; i--) t += ans[i];
	return t; 
}
int main()
{
	int n, x;
	cin >> n >> x;
	cout << ten_to_x(n, x);
	return 0;
}
```

---

## 作者：Jorisy (赞：22)

Upd on 2023.7.13：修改了代码中的细节错误。

---

这是一道十进制转 $x$ 进制问题。

对于 $k$ 进制，从低位到高位，分别代表 $k^0,k^1,k^2,\dots$。

由此，我们可以推算出十进制转 $x$ 进制的方法。

举个例子，我们将 $1000_{10}$ 转成 $2$ 进制。

首先 $1000 \div 2=500 \dots \dots 0$，那么 $2^0$ 位就是 $0$。

商是 $500$，那么接着 $500 \div 2=250 \dots \dots 0$，则 $2^1$ 位为 $0$。

商是 $250$，继续 $250 \div 2=125 \dots \dots 0$，则 $2^2$ 位为 $0$。

商是 $125$，继续 $125 \div 2=62 \dots \dots 1$，则 $2^3$ 位为 $1$。

以此类推。

最后算出 $1000_{10}=1111101000_2$。

那么在实现的时候我们可以递归计算。

对于字母，我们可以用字符串 $R$ 去存储。$R_i$ 表示比 $i$ 更高的进制下的 $i_{10}$ 是多少。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const string R="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//存储进制所对应的符号
int x;

void tox(int n)
{
	if(n/x==0)//边界
	{
		cout<<R[n];
		return;
	}
	tox(n/x);//先递归
	cout<<R[n%x];//后输出
}

int main()
{
	int n;
	cin>>n>>x;
	tox(n);
 	return 0;
}
```

---

## 作者：CuBernie (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/B3619)

这是一道考察进制转换的题目。

我们拿十进制转二进制举例：

取一个数 $ ( 5 ) _ { 10 } $ ，将其转为二进制的步骤如下：

设所求二进制数的长为 $ x $ （ $ 1 $ 为最此二进制数左端的位置， $ x $ 为最二进制数最右端的位置）。

$ 5 / 2 = 2 $ 余 $ 1 $ ， 将余数 $ 1 $ 作为所求二进制数的第 $ x $ 位。

$ 2 / 2 = 1 $ 余 $ 0 $ ， 将余数 $ 0 $ 作为所求二进制数的第 $ ( x - 1 ) $ 位。

最后剩下了一个孤单的 $ 1 $ ，而 $ 1 < 2 $ ，就不能再 $ 1 / 2 $ 了，所以将 $ 1 $ 作为 $ ( 5 ) _ { 10 } $ 第一位，先前所得的余数按照从下至上的顺序依次排好，也就是像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/5m2jwb2x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

至此，我们便求出了 $ ( 5 ) _ { 10 } = ( 101 ) _ { 2 } $ 这个结果。

那么其他进制的转换自然就能懂啦~

但是，在十进制之后，还隐藏着一个神秘的世界。

比如说在十六进制下的 $ 15 $ 呢？这又该如何表示？

所以，正如题目所说：对于超过十进制的数码，用 $ A $ ，$ B $ ... 表示。

那么，就有了 $ 10 = A $ ， $ 11 = B $ , ...... , $ 35 = Z $ 这种说法啦。

代码实现我用的是递归（还有一种做法是用数组储存然后输出）：

```cpp
#include<iostream>
using namespace std;
int n,x;
void solve(int k) {
	if(k>=x) {
		solve(k/x);
		k%=x;
		if(k>=10) {
			cout<<char(k-10+'A');//当k>=10(也就是x>10),把k-10,剩下的数加上'A'就是真正的数码了。
		} else {
			cout<<k;
		}
	} else {
		if(k>=10) {
			cout<<char(k-10+'A');
		} else {
			cout<<k;
		}
	}
	return; 
}
int main() {
	cin>>n>>x;
	solve(n);
	return 0;
}
```

---

## 作者：xyf007 (赞：8)

普及 C++ 字符串处理技巧。

有一个函数叫作 `itoa`，但是它不是标准库函数，因此不作介绍。

标准库只有一个支持该功能的函数 `std::to_chars`，需要 C++17 标准。但是可以在 GCC 9.3.0 C++14 标准下编译通过，因此 **可以** 在考场上使用。  
处理整数的函数原型 `std::to_chars_result to_chars(char* first, char* last, /*see below*/ value, int base = 10);`，不能使用 `bool`。功能是将 $\textit{value}$ 转化成 $\textit{base}$ 进制后写入 `char` 数组。  
返回值是一个 `std::to_chars_result` 类型，是一个结构体，定义如下：
```cpp
struct to_chars_result {
  char* ptr;
  std::errc ec;
};
```
如果正常转换，$\textit{ec}$ 将等于 `std::errc()`，$\textit{ptr}$ 指向最后一个写入字符的后一位。即最终范围是 $[\textit{first},\textit{ptr})$。

`std::to_chars` 在处理进制 $\textit{base}>10$ 的情况时用的是小写字母，因此还需要转换成大写字母。

代码如下，里面使用了 C++17 的语法结构化绑定和 `if` 初始化语句，但是都可以在 GCC 9.3.0 C++14 标准下编译通过，因此考场上 **可以** 使用这些语法。
```cpp
#include <algorithm>
#include <cctype>
#include <charconv>
#include <iostream>
#include <string>
#include <system_error>
int main(int argc, char const *argv[]) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr), std::cout.tie(nullptr);
  int n, base;
  char buf[101];
  std::cin >> n >> base;
  std::string s;
  if (auto [p, e] = std::to_chars(buf, buf + 100, n, base); e == std::errc())
    s = std::string(buf, p);
  std::transform(s.begin(), s.end(), s.begin(),
                 [](unsigned char c) { return std::toupper(c); });
  std::cout << s;
  return 0;
}
```

---

## 作者：ShanCreeperPro (赞：5)

## B3619 10 进制转 x 进制

~~又是进制好题！~~

我们可以用短除法来算：

https://www.luogu.com.cn/paste/1xhn3jow


(这玩意洛谷博客显示不出来，我放剪贴板了。）

以 114514 为例子，转 16：

- 除以 16，结果为 7157 余 2，把 2 记录；
- 除以 16，结果为 447 余 5，把 5 记录；
- 除以 16，结果为 27 余 15(F)，把 15(F) 记录；
- 除以 16，结果为 1 余 11(B)，把 11(B) 记录；
- 结果小于 16，停止除法，把 1 记录。

最后把所有记录的数字倒着输出即可。

- 我们先写一个从数字转到字符的函数：

```cpp
char intToChar(int n){
	if(n<10) return n+'0';
    return 'A'+n-10;
}
```

- 先用 $a_t$ 记录余数，然后把 $n$ 除以 $x$，然后把位数增加 1。

```cpp
while(n){
	a[t]=n%x;
    n/=x;
    t++;
}
```

- 倒着输出，记得要用我们的函数。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,a[105],t;
// 数码转char
char intToChar(int n){
	if(n<10) return n+'0';
    return 'A'+n-10;
}
int main(void) {
#ifdef LOCAL
    freopen("debug_data.in","r",stdin);
    freopen("debug_data.out","w",stdout);
#endif
    cin>>n>>x;
    while(n){
        // t是目前已经记录到了第几位了
        a[t]=n%x;
        n=n/x;
        t++;
    }
    for(int i=t-1;i>=0;i--) // 倒序输出数组中的元素，当然要转成字符
        cout<<intToChar(a[i]);
    return 0;
}

```


---

## 作者：沉石鱼惊旋 (赞：3)

### 题目思路

就是进制转换啦。

进制转换，肯定要讲一下短除法。就是每次看余数并做除法。

比如 $10$ 转换 $2$ 进制。

$13\bmod2=1$。

$6 \bmod 2=0$。

$3 \bmod2=1$。

$1\bmod2=1$。

最后倒序枚举余数即可。

那么，我们可以有两种方案，**递归**和**存数组**。

存数组，字面意思，把余数存下来，最后翻转，输出。

递归，每次准备着输出数，但先递归后面的余数，最后返回来输出。

### 题目代码

我用的是递归。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
string c="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//存数
void f(ll x,ll m){if(x/m)f(x/m,m);cout<<c[x%m];}//递归
int main()
{
	ll n,x;
	cin>>n>>x;
	if(x==0){puts("0");return;}
	f(n,x);
    return 0;
}
```

[想了解其他做法，可以参考B2143。](https://www.luogu.com.cn/problem/B2143)



---


# x 进制转 10 进制

## 题目描述

给一个小整数 $x$ 和一个 $x$ 进制的数 $S$。将 $S$ 转为 $10$ 进制数。对于超过十进制的数码，用 `A`，`B`，$\ldots$ 表示。

## 说明/提示

【数据规模和约定】  

保证目标数在十进制下不超过 $10^9$，$1 \leq x \leq 36$。


## 样例 #1

### 输入

```
16
7B
```

### 输出

```
123```

# 题解

## 作者：ShanCreeperPro (赞：49)

## B3620 x 进制转 10 进制

最近题库频繁出现这种转换进制的题目，那我就细细讲一下如何将 $x$ 进制转换成 10 进制。

~~好耶超多经验！~~

首先第一个问题：啥是进制？

我们人类现在最经常的使用十进制。

每**逢 10 个就进 1 个**就是十进制。

比如十个 1 记作 10。十个 10 记作 100。

***

对于 $k$ 进制：

- 如果 $k \leq 10$，采用的数字为 0 到 $k-1$。
- 如果 $k > 10$，用完 $0-9$ 后，开始用 $A,B,C,D...$。

例如用十六进制计数：

```
0 1 2 3 4 5 6 7 8 9 A B C D E F
10 11 12 13 ... 19 1A 1B 1C 1D 1E 1F 20 21 ... FE FF
100 101 102...
```

***

讲完进制后，我们还需要知道一个东西：权重。

每个数字都有对应的权重。

在十进制中：

个位权重是 1，十位权重是 10，百位权重是 100...

$$ (678)_{10} = 6 \times 100 + 7 \times 10 + 8 \times 1 $$

所以：

- 十进制，逢 10 进十位，100 进百位，1000 进千位；
- k 进制，逢 k 进第二位，$k^2$ 进百位，$k^3$ 进千位；

那么如何算出 $k$ 进制数字的 10 进制数字？

例如：

$$ (12341)_5 = 1 \times 5^4 + 2 \times 5^3 + 3 \times 5^2 + 4 \times 5 + 1 = 971 = (971)_{10} $$

***

多练手几道题：

$$ (123)_7 = 1 \times 7^2 + 2 \times 7 + 3 = 49 + 14 + 3 = 66 $$

$$ (1000)_2 = 1 \times 2^3 + 0 + 0 + 0 = 8 $$

$$ (654)_8 = 6 \times 8^2 + 5 \times 8 + 4 = 6 \times 64 + 40 + 4 = 428 $$

懂得了其中的道理了吧。

***

所以，我们就可以用上面讲的内容用编程实现 $x$ 进制转 10 进制。

- 读入 $x$ 和字符串 $S$：

- 将 $S$ 倒着存入 $a$，将字母类型变成 `int`。

```cpp
int charToInt(char c){
	if('0'<=c&&c<='9') return c-'0';
    return c-'A'+10;
}
int len=S.size();
for(int i=len-1;i>=0;i--) a[len-1-i]=charToInt(S[i]);
```

- 用我们刚刚讲的权重计算进制公式，第 i 位的贡献是 $a_i \times x^i$：

```cpp
int ans=0,w=1;
for(int i=0;i<S.size();i++){
	ans+=w*a[i];
    w*=x;
}
```

- w 表示每次的 $x^i$。

好的，那么这道题就讲完了，这里是完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int x, a[105]; // 输入x进制
string S;
// char转数码
int charToInt(char c) {
    if('0'<=c&&c<='9') return c-'0';
    return c-'A'+10;
}
int main(void) {
    cin>>x>>S;
    int len=S.size();
    for(int i=len-1;i>=0;i--)
        a[len-1-i]=charToInt(S[i]);
    int ans=0,w=1;
    for(int i=0;i<len+1;i++){
        ans+=w*a[i];
        w*=x;
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：xyf007 (赞：37)

普及 C++ 字符串处理技巧。

`std::stoi/std::stol/std::stoll` 函数可以将 $x$ 进制字符串转换为 $10$ 进制整数，返回值分别为 `int`、`long` 和 `long long`。

以 `std::stoi` 为例，原型为 `int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);`。  
该函数舍弃所有空白符，然后取尽可能多的字符组成 $\textit{base}$ 进制的整数。合法的字符串由下列部分组成：
- （可选）正或负号
- （可选）指示八进制的前缀 `0`（仅当 $\textit{base}$ 为 $8$ 或 $0$ 时可用）
- （可选）指示十六进制的前缀 `0x` 或 `0X`（仅当 $\textit{base}$ 为 $16$ 或 $0$ 时可用）
- 一个数字序列

$\textit{base}$ 可选值是 $\{0,2,3,\ldots,36\}$。对于二进制，合法数字集是 $\{0,1\}$，对于三进制是 $\{0,1,2\}$，以此类推。对于 $\textit{base}>10$ 的情况，合法数字包含字母 $\texttt{A}$ 到 $\texttt{Z}$，且忽略字符大小写。  
若 $\textit{base}$ 为 $0$ ，则自动检测进制：若前缀为 `0`，则为八进制；若前缀为 `0x` 或 `0X`，则为十六进制；否则为十进制。  
若 $\textit{pos}$ 不是空指针，则成功转换的字符个数会存储在该指针对应的变量中。

如果是 `char` 数组可以使用类似的 `std::strtol/std::strtoll` 函数，可以参考 C++ Reference 的 [`std::strtol, std::strtoll`](https://zh.cppreference.com/w/cpp/string/byte/strtol) 页面。

使用 `std::stoi` 的版本：
```cpp
#include <iostream>
#include <string>
int main(int argc, char const *argv[]) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr), std::cout.tie(nullptr);
  int n;
  std::string s;
  std::cin >> n >> s;
  std::cout << std::stoi(s, nullptr, n) << '\n';
  return 0;
}
```
使用 `std::strtol` 的版本：
```cpp
#include <cstdio>
#include <cstdlib>
int main(int argc, char const *argv[]) {
  int n;
  char s[101];
  std::scanf("%d%s", &n, s);
  std::printf("%ld", std::strtol(s, nullptr, n));
  return 0;
}
```

下面介绍拥有极致性能的 `std::from_chars`，需要 C++17 标准。但是可以在 GCC 9.3.0 的 C++14 标准下编译通过（甚至没有警告），也就是说你可以在考场上使用。  
处理整数的函数原型 `std::from_chars_result from_chars(const char* first, const char* last, /*see below*/& value, int base = 10);`，这里不允许使用 `bool`。传入一个字符数组的区间，答案 **存储在 $\boldsymbol{value}$ 中** 而不是返回值，正常运行的时候返回值可以忽略。  
与前面不同之处：
- $\textit{base}=16$ 时不识别 `0x` 或 `0X` 前缀。
- 仅识别负号（不识别正号），而且只针对 $\textit{value}$ 的有符号整数类型。

代码如下：
```cpp
#include <charconv>
#include <iostream>
int main(int argc, char const *argv[]) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr), std::cout.tie(nullptr);
  int base, ans = 0;
  char buf[101];
  std::cin >> base >> buf;
  std::from_chars(buf, buf + 100, ans, base);
  std::cout << ans;
  return 0;
}
```

---


# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# 题解

## 作者：老卡手机 (赞：704)

这道题唯一的难点就是

### ~~题目写不清楚~~

### ~~而且题解也没写清楚~~

## 对负进制不了解

（于是我百度了回来）

首先，不管对于什么语言，
### 被除数=商*除数+余数，
这是解决问题的关键

例如在C++里，-15%-2=-1，-15/-2=7,而7*-2+（-1）=-15

但是因为我们是不断取余数倒序为转换结果，所以余数不能出现负数，那怎么办呢？

很简单~~虽然我一开始看不懂~~

我们只需要将商+1，余数-除数即可，因为余数（绝对值）一定小于除数，所以这样就可以将余数装换为正数

正确性证明：
```
（商+1）*除数+（余数-除数）=商*除数+除数+余数-除数=商*除数+余数=被除数
```
于是就可以愉快的做题啦
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;

void zhuan(int n,int r)
{
	if(n==0) return ;
	int m=n%r;//m为余数 

	if(m<0) m-=r,n+=r;//如果余数小于0，转化为正数
	
	//将余数转化为ascll码方便输出，省略了一个数组 
	if(m>=10) m='A'+m-10;
	else m+='0';
	
	zhuan(n/r,r);
	
	printf("%c",m);//注意，因为结果为余数倒序，输出要写在递归后面，不然会顺序输出 
	return ;
}
int main()
{
	//freopen("in.txt","r",stdin);
	int n,r;
	string ans="";
	cin>>n>>r;
	cout<<n<<"=";
	zhuan(n,r);
	printf("(base%d)",r);
	return 0;
}
```

---

## 作者：judgejudge (赞：103)

# 解答一下大佬不愿意讲的点
我们都知道，首先按照**10进制转成n进制**的做法：

**对这个数不断除以n，将余数一一存储，最后倒序输出。**

那么有一个问题，此处原数和进制数都有可能为负数，也就意味着**余数可能为负数**，那么我们不可能输出像-100-100这种数。

### 那么怎么把负数转成正数？

我们基本思路分两点：

1. **把负数转成符合n进制余数规律的正数**
1. **让转得的正数符合余数的计算模式**


------------
1. **把负数转成符合n进制余数规律的正数**

我们先来探讨一下二进制余数的规律：
| 0 | 1 | 2 |  3| 4 |5  |6  | 7 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 0 | 1 | 0 |1  |0  | 1 | 0 | 1 |
那么规律就是0101010101……

那么我们只需让负数余数规律也为010101……，就解决了。

我们发现，每一组数，他们对应的**间隔区间内的数是相等的**。那么我们只需跳到它前面一个区间的数即可，因为区间长度为-m,（m为进制）。那么就转换成：

### j-=m（j为原先算出来的负数，m为进制数）



------------
1. **让转得的正数符合余数的计算模式**

光转成正数还不够，因为还不符合余数的计算。

众所周知，我们令n为被除数，m为除数和进制数,a为商,j为余数，可以得到：
### n/m=a
### n-a*m=j

根据我们刚刚推得的算法：**j-=m**，那么此时方程2两端同时减去m，得
### n-a*m-m=j-m
提公因式，得
### n-(a+1)*m=j-m
但我们还要让j-m符合余数计算模式，即符合**n-a*m=j**的形式。

显然，此时a=a+1正好符合n-a*m=j的形式。所以：

### n++（此时n已经/=m）

```cpp
#include <iostream>
using namespace std;
int n,m;
char a[100001];
int l=0;
int main(){
	int i;
	cin>>n>>m;
	cout<<n<<"=";
	while(n!=0){
		int j=n%m;
		n/=m;//十进制转n进制
		if(j<0)j-=m,n--;//讲解的点
		if(j<10)a[++l]=(char)(j+48);
		else a[++l]=(char)((j-10)+'A');//两种不同的转法
	}
	for(i=l;i>=1;i--)cout<<a[i];//倒序输出
	cout<<"(base"<<m<<")"<<endl;
}
```


---

## 作者：Dancepted (赞：17)

这题竟然可以暴力！

本来想打个表看看-R进制数的十进制值的出现规律。
然后突发奇想：直接把十进制值和输入的N比一下，如果相同就输出会怎么样？毕竟N好像范(shu)围(ju)很(hen)小(shui)。

于是就意外的AC了（懵逼脸）。
按照|R|进制的从小到大的顺序，从0开始生成R进制数，然后计算这个数的10进制值ans。
然后如果ans = N，就输出我们生成的R进制数，否则生成下一个。

```cpp
#include<bits/stdc++.h>

using namespace std;
const int maxn = 1000 + 5;

int N, R;
int num[maxn];

bool print(int len, int R)
{//如果生成的数与N相同则打印并返回true，不同则返回false
    int ans = 0;
    for (int i = len; i >= 0 ; i--) {
        ans += num[i] * (int)pow(R, i);
    }
    if (ans != N)
        return false;
    for (int i = len; i >= 0 ; i--) {
        if (num[i] < 10)
            cout << num[i];
        else
            cout << (char)('A' + num[i] - 10);
    }
    return true;
}

int main(){
    while (cin >> N >> R) {
        cout << N << '=';
        memset(num, 0, sizeof num);
        int len = 0;
        do {//从零开始生成|R|进制数
            num[0]++;
            for (int i = 0; num[i] == abs(R); i++) {
                num[i] = 0;
                num[i+1]++;
                len = max(len, i+1);
            }
        } while (!print(len, R));
        cout << "(base" << R << ")" << endl;
    }
}
/*
-15 -2
*/

```

---

## 作者：多啦A梦007 (赞：15)

这是一种简单的做法

看到楼上都是用一些高级的数学方法去求解的，蒟蒻的我就来讲一种比较好理解的做法吧。

刚开始我也想用短除法，但因为是对负数取模，所以很显然直接取模是不可行的。通过观察我们可以发现如样例中

110001=1×(−2)^​5​​ +1×(−2)^​4+0×(−2)^​3+0×(−2)^2+0×(−2)^1+1×(−2)^0

=1×(−2)^​5​​ +1× 2^​4+0×(−2)^​3+0× 2 ^2+0×(−2)^1+1× 2^0

即偶数位还是和正常的二进制计算一样，只是级数位需要取反。 接下来考虑如何处理奇数位，通过分析我们可以发现

##2^​5=2^6+(−2)^​5

所以我们可以先对数进行正常取余（如15若对2取余先变为11111）

然后对次幂为奇数即位数为偶数的进行操作 若此时为第i位则 第i+1位加1，这一位变成进制减 第i位原来的数

（如15若对2取余则变为10011）然后考虑如果原数为负数，则先将其变为正数，再进行接下来的计算

```cpp
#include<cstdio>
#include<cstdlib>
#include<iomanip>
#include<iostream>
using namespace std;
int m,n,o,p,js,jl,i,j,k,jk;
int a[101];
int main()
{
    scanf("%d%d",&m,&n);
    if(m>0)
    {
        jl=0;
        o=-n;p=m;
        while(p>0)
        {
            jl++;
            a[jl]=p%o;
            p=p/o;
        }
        for(int i=1;i<=jl;i++)
        {
            a[i+1]=a[i+1]+a[i]/o;
            a[i]=a[i]%o;
            if(i%2==0)if(a[i]>0)
            {
                a[i+1]++;
                a[i]=o-a[i];
            }
            if(a[jl+1]>0)jl++;
            a[i+1]=a[i+1]+a[i]/o;
            a[i]=a[i]%o;
        }
        jk=1;js=0;
        for(i=1;i<=jl;i++)
        {
            js=js+jk*a[i];
            jk=jk*n;
            if(js==m)break;
        }
        jl=i;
        printf("%d=",m);
        for(int i=jl;i>=1;i--)if(a[i]<10)printf("%d",a[i]);else printf("%c",char(a[i]+55));
        printf("(base%d)",n);
    }
    else
    {
        jl=0;
        o=-n;p=-m;js=o;jk=2;
        for(int i=1;i<=100;i++)
        {
            if(js>p)break;
            js=js*o*o;
            jk=jk+2;
        }
        p=js-p;
        while(p>0)
        {
            jl++;
            a[jl]=p%o;
            p=p/o;
        }
        a[jk]++;
        for(int i=1;i<=jl;i++)
        {
            a[i+1]=a[i+1]+a[i]/o;
            a[i]=a[i]%o;
            if(i%2==0)if(a[i]>0)if(i!=jk)
            {
                a[i+1]++;
                a[i]=o-a[i];
            }
            if(a[jl+1]>0)jl++;
            a[i+1]=a[i+1]+a[i]/o;
            a[i]=a[i]%o;
        }
        if(jl<jk)jl=jk;
        jk=1;js=0;
        for(i=1;i<=jl;i++)
        {
            js=js+jk*a[i];
            jk=jk*n;
            if(js==m)break;
        }
        jl=i;
        printf("%d=",m);
        for(int i=jl;i>=1;i--)if(a[i]<10)printf("%d",a[i]);else printf("%c",char(a[i]+55));
        printf("(base%d)",n);
    }
} 

```

​ ​​


---

## 作者：ikunTLE (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P1017)

### 思路

在本文中，设被除数为 $a$，除数为 $b$，商为 $q$，余数为 $r$。

首先考虑 $R$ 为正数的情况。将一个十进制数 $n$ 转为二进制，可以用短除法依次取余 $2$，最后倒序输出即可。这种方法可以将 $n$ 转为任意 $R$ 进制，只需把模数改为 $R$ 即可。

再考虑 $R$ 为负数的情况。基本的除法公式为 $\frac{a}{b}=q\cdots r$，在这基础上推出 $a=b\times q+r=b\times(q+1)+r-b$。

当 $b<0$ 且 $\lvert r\rvert<\lvert b\rvert$ 时，$r-b\ge0$。所以若 $b<0$，更改 $q\gets q+1$，$r\gets r-b$ 即可。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
int a,b;
void dfs(int x){
	if(!x)
		return;
	int q=x/b,r=x%b;
	if(r<0)
		++q,r-=b;
	dfs(q);//倒序输出
	if(r<10)
		putchar(r+'0');
	else putchar(r+'A'-10);
	return;
}
int main(){
	a=read(),b=read();
	printf("%d=",a);
	dfs(a);
	printf("(base%d)\n",b);
	return 0;
}
```

---

## 作者：Temp113 (赞：3)

## Problem

将十进制数 $N$ 转换为 $R$ 进制下的数，其中 $R$ 为负数。

## Solution

当 $R$ 为正数时，用 $N \bmod R$ 求出答案。

然而，$R$ 为负数时，$N \bmod R$ 为负数，导致答案为负数。于是，可以将此数减去 $R$，并将 $N$ 加上 $R$。

因为，$N \bmod R$ 取 $R+1 \sim -R-1$，最小值减去 $R$ 为 $1$（正数），此时相当于将商减 $1$，$N$ 加上 $R$ 正好能抵消此影响。

例如，$N=-15$，且 $R=-2$：

1. $N \bmod R = -1$，$-1 + 2 = 1$。$N$ 变为 $8$。

2. $N \bmod R = 0$。$N$ 变为 $-4$。

3. $N \bmod R = 0$。$N$ 变为 $2$。

4. $N \bmod R = 0$。$N$ 变为 $-1$。

5. $N \bmod R = -1$，$-1 + 2 = 1$。$N$ 变为 $1$。

6. $N \bmod R = 1$。

综上，$-15 = (110001)_{-2}$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 25;
int n, r, a[M], num;
int main(){
	scanf("%d %d", &n, &r);
	printf("%d=", n);
	while(n){
		a[++num] = n % r;
		if(n % r < 0){
			n += r;
			a[num] -= r;
		}
		n /= r;
	}
	for(int i = num; i >= 1; i--){
		if(a[i] < 10) printf("%d", a[i]);
		else printf("%c", a[i] - 10 + 'A');
	}
	printf("(base%d)", r);
	return 0;
}
```

---

## 作者：hhztl (赞：3)

相信大家都学习过十进制转二进制的知识。

一个十进制数 $13$，要将其转为二进制，可以这么做：
1. 用 $2$ 除 $13$，商为 $6$，余数为 $1$。
2. 用 $2$ 除上一个算式的商 $6$，商为 $3$，余数为 $0$。
3. 再用 $2$ 除上一个算式的商 $3$，商为 $1$，余数为 $1$。
4. 用 $2$ 除上一个算式的商 $1$，商为 $0$，余数为 $1$。此时商归零，继续做没有意义了，停止操作。

将余数倒序写下来：$1101$。这就是 $13$ 对应的的二进制数。
### 那么这种方法可以推广吗？
设十进制数为 $x$，目标进制数为 $m$。

$x$ 第一次除以 $m$ 后，得到的余数就是 $m$ 进制下 $x$ 的个位，而商是更高位。放在十进制下会更容易理解。以此类推，将各个余数排列在一起，就可以得到 $x$ 的 $m$ 进制数。
### 让我们回到这道题
这道题要求我们输出负进制下的数。很明显，我们在倒序输出余数的时候，不能输出负数。那么该怎么办呢？

众所周知：$\text{被除数}=\text{除数}\times\text{商}+\text{余数}$。

可以得出：
$$
\text{被除数}=\text{除数}\times\text{商}+\text{余数}=(\text{除数}\times\text{商}+\text{除数})+(\text{余数}-\text{除数})=\text{除数}\times(\text{商}+1)+(\text{余数}-\text{除数})
$$
由于除数为负且余数的绝对值必定小于除数的绝对值，所以余数减除数必定不为负。因此当余数为负时只需将商加 $1$，余数减除数就可以了。

### Code:
~~应该还算好懂？~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
void solve(int n){
	if(!n)return;
	int t=n/m,l=n%m;//t为n,m的商，l为n,m,的除数
	if(l<0){//若余数为负
		t++;//商+1
		l-=m;//余数-除数
	}solve(t);
	if(l<10)cout<<l;
	else cout<<(char)(l+55);
}int main(){
	cin>>n>>m;
	cout<<n<<'=';
	solve(n);
	cout<<"(base"<<m<<')';
}
```

---

## 作者：Ivan422 (赞：2)

~~为什么这题能发题解。~~

考虑直接转换，直接用祖传的除 $k$ 取余倒取法即可。

但是，我们发现余数 $r<0$ 时会出错。

我们都知道一个余数定理：$a=qk+r$，及被除数为商乘除数加上余数。

当 $r<0$，我们考虑 $r$ 变为 $r-R$，变成正数（$R$ 为负数），我们发现，这样不符合原式子，那么我们考虑把商 $n$ 加上 $1$，原式 $a=qk+r$ 变成 $a=(q+1)k+r-k$，化简得 $a=qk+k+r-k$，发现 $a=qk+r$，合理。

综上，$r<0$ 时，$r$ 变成 $r-R$，$n$ 变成 $n+1$，即可让原式成立，完成转换。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,R;
string s;
void to(){
	cout<<n<<"=";
	while(n!=0){
		int r=n%R;
		n/=R;
		if(r<0)r-=R,n++;
		s=char(r<10?r+'0':r-10+'A')+s;
	}
	cout<<s;
	return;
}
int main(){
	cin>>n>>R;
	to();
	cout<<"(base"<<R<<")";
	return 0;
}
```

---

## 作者：_Maverick_ (赞：2)

## 解题思路：

### 枚举法

从数据范围来看，$|n| ≤ 37336$，因此，可以对该 $r$ 进制的数进行枚举，每一次枚举，都计算 $r$ 进制数对应的十进制数是否和 $n$ 相等，相等则输出该 $r$ 进制数。

主要问题就是要解决 $r$ 进制数如何表示？

类似于高精度，可以用数组来表示一个 $r$ 进制数，如二进制 $1101$ 表示为 ```int a[] = {1,0,1,1}```。

枚举起始时，```a[]={0}```，每一次最低位加 $1$：```a[0]+=1```，如果 ```a[0] = |r|```，处理进位。
## ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100], cnt = 1;
int n, r;

//将r进制的a[]转换为十进制数
int trans()
{
    int res = 0;
    for(int i = cnt - 1; i >= 0; i--)
    {
        res = res * r + a[i];
    }
    return res;
}

char getchar(int x)
{
    char res = '0';
    if(x >= 0 && x <= 9) res = x + '0';
    if(x >= 10) res = x - 10 + 'A';
    return res;
}

int main()
{
    cin >> n >> r;
    int R = -r; //r是负数，R = abs(r)
    while(n != trans()) //如果r进制数a转换十进制后不等于n
    {
        int d = 1;
        for(int i = 0; i < cnt; i++) //给r进制数a加1
        {
            a[i] += d;
            d = a[i] / R;
            a[i] %= R;
        }
        if(d) a[cnt++] = d;
    }
    cout << n << "=";
    for(int i = cnt - 1; i >= 0; i--) cout << getchar(a[i]);
    cout <<  "(base" << r << ")";
    return 0;
}
```

---

## 作者：sto__Liyhzh__orz (赞：2)

[传送门](https://www.luogu.com.cn/problem/P1017)

这个题主要重难点为不清楚负数的除法，在 C++ 语言中，正数除以附属的余数为负数，可是这并不是正确的，例如 $-10 \div 3=-3 \dots -1$。

为了解决这个问题，我们要回到除法的基本性质：商乘除数小于等于被除数，当且仅当等于被除数时，余数为 $0$。

显然：$-3 \times 3=-9>-10$，所以不正确。那么我们要再商加一，使得商乘除数变小，小于被除数。

那么在推导一下此时的余数：

设原来除数为 $a$，商为 $b$，余数为 $c$，显然 $b,c<0$。

那么被除数为 $ab+c$，现在的余数为 $ab+c-a(b+1)=ab+c-ab-a=c-a$。

那么当余数小于 $0$ 时，将余数减去除数即可得到正确余数。 

****

最后提一句进制转换，将十进制数一直除以转换的进制，去所有的余数**从后往前**连在一起就行了。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define lowbit(x) (x)&(-x)
using namespace std;

typedef double db;
typedef long long ll;
typedef __int128 III;
const db eqs=1e-6;
const int inf=1e9;
void ll_cmax(ll &a,ll b){a=a>b?a:b;}
void ll_cmin(ll &a,ll b){a=a<b?a:b;}
void int_cmax(int &a,int b){a=a>b?a:b;}
void int_cmin(int &a,int b){a=a<b?a:b;}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}
bool number(char ch){return ch>='0' && ch<='9';}
bool lowerchar(char ch){return ch>='a' && ch<='z';}
int sqlong(int n){int sq=sqrt(n)+1;return min(sq,n);}

string s="0123456789ABCDEFGJHI";
int x,k; 
stack<char>st;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>x>>k;
	cout<<x<<"=";
	while(x!=0)
	{
		int a=x%k;
		if(a<0) a-=k;
		st.push(s[a]);
		x=(x-a)/k;
	}
	while(st.size())
	{
		cout<<st.top();
		st.pop();
	}
	cout<<"(base"<<k<<")"<<endl;
	return 0;
}
//by Matrix_Power
```

---

## 作者：XsIeEiKcEk (赞：1)

## 题目大意
给出一个整数 $n$ 和一个负数 $r$ ，输出 $n$ 在 $r$ 进制下的数。

## 题目重点
负数进制和整数一样，都是用原数除以要转换的进制，取它们的余数。唯一不同的是，因为进制是负数，所以余数可能出现负数，就需要把余数减去进制变为正数，再把原数加进制，然后再按正余数的方法求。

## [AC](https://www.luogu.com.cn/record/list?pid=P1017&user=1617786) CODE

```cpp
#include <iostream>
using namespace std;
string ans = "", sum = "0123456789ABCDEFGHIJ";//答案和高进制表示数的字母

int main() {
	int n, r, mod, num = 0;
	cin >> n >> r;
	cout << n << '=';
	while (n) {//判断n是否为0
		mod = n % r;
		if (mod >= 0) {//判断正负
			n /= r;
			ans += sum[mod];
			num++;
		} else {
			mod -= r;
			n += r;
			ans += sum[mod];
			num++;
			n /= r;
		}
	}
	for (int i = num - 1; i >= 0; i--)//倒序输出
		cout << ans[i];
	cout << "(base" << r << ')';
	return 0;
}
```

---

## 作者：Dream_Stars (赞：1)

## 题目大意：
这道题让我们将一个十进制数转换为一个负进制数。

## 算法分析：
不了解负进制的戳[这里](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E8%B4%9F%E8%BF%9B%E5%88%B6&fenlei=256&rsv_pq=0x937d1d4e02ce1fc9&rsv_t=7293lWKk%2BaAwReSXGMFvrwHvFBXeiCqkxYvzW9hphf9P6WIMWFrwSqnlN%2B6S&rqlang=en&rsv_dl=tb&rsv_enter=1&rsv_sug3=17&rsv_sug1=20&rsv_sug7=100&rsv_sug2=0&rsv_btype=i&inputT=4115&rsv_sug4=4115)。\
我们可以将十进制转换为相应的 $m$ 进制，但是需要特殊处理一下余数为负的情况。\
如 `-31 % -3 = -1` 此时余数为负数，我们需要将余数转换为正数。\
具体实现时可以将余数加上除数，并将商减去一。
## 代码展示：
```cpp
# include<bits/stdc++.h>
# define ll long long

using namespace std;

const int N = 25;

ll n , r , mod;
ll ansx , ansy;
string ans;
char ch[N] = {'0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' ,'C' , 'D' , 'E' , 'F' , 'G' , 'H' ,'I' , 'J'};
//提前打好表，便利不同进制的输出。

void paint(){
  cout << ansx << "=";
  for(int i = ans.size() - 1 ; i >= 0 ; i--)
    cout << ans[i];//逆序输出答案。
  cout << "(base" << ansy << ")" << endl;
  return ;
}

signed main(){
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin >> n >> mod;
  ansx = n;
  ansy = mod;
  while(n != 0){
    r = n % mod;//取余数
    if(r < 0) r = r - mod , n = n + mod;
    /*当余数小于0时，因为 mod 为负数，所以余数减掉 mod ，剩余数字加上 mod 即可*/
    n = n / mod;
    ans = ans + ch[r];
  }
  paint();//输出
  return 0;
}
```

---

## 作者：「QQ红包」 (赞：1)

模拟……注意：n mod b 可能是负数……

10进制转n进制都应该会把……

```delphi

const s:string='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var n,b,r,nn:longint; ss:string;
begin
    readln(n,b);nn:=n;
    repeat
          r:=n mod b;
          if r<0 then r:=r-b;
          ss:=s[r+1]+ss;
          n:=(n-r) div b;
    until n=0;
    write(nn,'=',ss,'(base',b,')');
end.


```

---

## 作者：FastIO_DP (赞：1)

### 题目理解

题目要求我们将一个十进制数 $ n $ 转换为一个负基数 $ R $ 的表示形式。

### 解题思路

进制转换的基本原理是这样的：在正基数的情况下，我们通过不断地取余和除法来得到每一位的数字。对于负基数，我们需要处理余数为负数的情况。

当余数为负数时，我们需要调整余数和商，使得余数变为正数。也就是如果余数为负数，可以通过增加基数的绝对值来调整余数，并相应地调整商。

对了，如果数字大于 `9`，我们需要用字母表示。

### 解题步骤

首先，我们得读取两个输入：一个十进制的数 $ n $ 和一个负基数 $ R $。如果 $ n $ 正好是 `0`，那结果直接就是 `0`，不用再算了。

接下来，我们开始处理这个数。每次我们用 $ n $ 除以 $ R $，得到一个余数 $ mod $。如果这个余数是负数，就调整一下余数和商，直到它符合要求。然后，把这个余数转换成对应的字符，加到结果字符串里。接着，我们把 $ n $ 更新为刚才得到的商，继续这个过程，直到 $ n $ 变成 `0`。

由于我们是从最低位开始算的，最后得到的结果字符串其实是反的，所以我们需要把它反转一下，才能得到正确的结果。

最后，按照题目要求的格式，把这个结果输出就行了。

### 代码实现

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// 将数字转换为对应的字符
char f(int num) {
    if (num >= 0 && num <= 9) {
        return '0' + num;
    } else {
        return 'A' + (num - 10);
    }
}

// 将十进制数n转换为base进制的字符串
string solve(int n, int base) {
    if (n == 0) {
        return "0";
    }

    string ans;
    while (n != 0) {
        int mod = n % base;
        n /= base;

        // 处理负余数
        if (mod < 0) {
            mod -= base;
            n += 1;
        }

        ans.push_back(f(mod));
    }

    reverse(ans.begin(), ans.end());
    return ans;
}

int main() {
    int n, base;
    cin >> n >> base;

    string ans = solve(n, base);
    cout << n << "=" << ans << "(base" << base << ")" << endl;

    return 0;
}
```

### 复杂度分析

- **时间复杂度**：$ O(\log_{|R|} n) $。其中 $ n $ 是输入的十进制数，$ R $ 是基数。
   - 每次循环都将 $ n $ 除以 $ R $，所以循环次数为 $ \log_{|R|} n $。
- **空间复杂度**：$ O(\log_{|R|} n) $。存了结果的字符串。

---

## 作者：4041nofoundGeoge (赞：1)

## 思路

模拟题，我们取余数，如果是负数就在减去模数 $r$ 就可以得到正数，重复知道出完为止，最后翻转一下即可。

于是我们很快就得到了代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
string s="0123456789ABCDEFG";
int main(){
	int n,r;
	string ans="";
	cin>>n>>r;
	cout<<n<<"=";
	while(n){
		int x=n%r;
		if(x<0){
			n=n/r+1;
			x-=r;
		}else{
			n/=r;
		}
		ans=s[x]+ans;//这样就不用reverse了
	}
	cout<<ans<<"(base"<<r<<")";
	return 0;
}
```

---

## 作者：ZTengW (赞：0)

# P1017 [NOIP2000 提高组] 进制转换  
## 0.题目传送门  
[here](https://www.luogu.com.cn/problem/P1017)
## 1.题意  
给定一个十进制正整数 $n$，接着给定一个负整数 $-R$，求十进制数 $n$ 转换为 $-R$ 进制为多少。  
## 2.进制转换公式（从十进制转到其他进制）  
以样例 #1 为例（$(30000)_{10}$ 转换至 $-2$ 进制）：  
1. 用 $30000 \bmod -2$ 得到余数 $0$ ，放到结果最末尾；
2. 用 $\lfloor 30000 \div -2 \rfloor$，也就是 $-1500$ 作为下一次操作的被除数；
3. 再用 $-1500 \bmod -2$ 得到余数 $0$ ，再放到上一个余数的前面；
4. 再用 $\lfloor -1500 \div -2 \rfloor$，也就是 $750$ 作为下一次操作的被除数；
5. 以此类推，直到得出结果 $11011010101110000$ 为止。
## 3.解题思路  
直接用一个 `while` 循环去模拟进制转换公式（毕竟数据不大）。
## 4.难点  
有许多的细节：  
- 对原数取余之后，要注意把结果变为正整数；
- 答案可能很大，所以最好用 `string` 来存储；
- 输出答案时要倒序输出；
- 输出有格式，用 `cout` 输出应为：`cout << n << "=" << ans << "(base-" << r << ")";`，而用 `printf` 输出应为：`printf("%d=%s(base%d)", n, ans, r);`。
## 5.万众瞩目的AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n, r, temp, i;
	char c;
	string ans = "";
	
	cin >> n >> r;
	cout << n << "=" ;
	
	while(n)
	{
		temp = n % r; //求余数
		if(temp < 0)
		{
			temp -= r; //C++的特性：对负数取余不一定是对的，例：-14 % -16 输出为 -14 ，但本应为 2
			n += r;
		}
		if(temp < 10)
			c = char(temp + '0'); //特判：余数小于十，直接加到答案末尾
		else
			c = char(temp - 10 + 'A'); //特判：余数大于十，需转换为大写字母
		ans += c;
		n /= r;
	}
	
	
	for(i = ans.size() - 1; i >= 0; i --)
		cout << ans[i];
	cout << "(base" << r << ")"; //输出格式 
	
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：模拟，进制转换。  
本题就是一个基础的进制转换，是一道很好的题目。本题就是让我们把十进制数 $n$ 转成 $r$ 进制。本题对了解进制方面有一定的考研。首先我们要知道什么是进制。注意：我们要脱离生活才能更好地理解进制，不能拿十进制来理解。比如一个 $2$ 进制数 $1101$，二进制数是满二进一。三进制数 $121$，三进制数是满三进一。所以我们可以知道 $k$ 进制数是满 $k$ 进一。然后我们要知道如何把一个十进制数转转换成 $k$ 进制数。我们可以用循环模拟。每次存储 $n \bmod k$ 的余数，最后把数组倒过来输出即可。我们还要知道如何将 $k$ 进制数转换成十进制数。我们知道，十进制数有：个位，十位，百位等等。然后每一位依次代表：一，十，百。我们可以返现，依次代表的数就是 $10^{x-1}$，所以我们知道：$k$ 进制数的每一位代表 $10^{k-1}$ 次方，所以我们可以用 $k$ 进制数的每一位加起来然后把前面得到的数也加上即可。注意：本题的余数有负数，所以需要特殊处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
signed main()
{
	int n;
	int r;
	cin>>n>>r;
	cout<<n<<"=";
	string a="";//用字符串代替数组
	while(true)
	{
		if(n==0) break; 
		int qp=n%r;
		if(qp<0)//负数余数需要转成正数
		{
			qp-=r;//变成正数
			n+=r;//注意改变n
		}
		if(qp<10)
		{
			a+=(char)qp+'0';
		}
		else
		{
			char b=qp-10+'A';//否则就要变成十六进制的情况
			a+=b;
		}
		n/=r;
	}
	for(int i=a.size()-1;i>=0;i--)
	{
		cout<<a[i];
	}
	cout<<'('<<"base"<<r<<')';
	return 0;
} 
```

---

## 作者：xiaobeng_0912 (赞：0)

## $\mathbf{Knowledge}$

1. 数学
1. 进制

## $\mathbf{Solution}$

众所周知，想要把一个十进制数 $n$ 转换为一个 $R$ 进制数，就需要用到短除法：让 $n$ 去不断整除 $R$（直到 $n=0$ 时停止），第 $i$ 次除出的余数，就把它储存到数组的第 $i$ 个位置中。最后从后往前倒序输出这个数组里的所有元素，得到结果。

但是，题目中的 $n$（也就是短除法中的被除数）有可能是负数，题目中的 $R$（也就是短除法中的除数）保证是负数，这样就会导致余数可能是负数。一个数字中，除了开头，是不能出现负号的。我们把这些部分为负数的余数连在一起输出后，结果就不是一个数了。

不过总归是有解决方法的。我们知道，在一个除法算式中，被除数 $n$、除数 $R$、商 $a$、余数 $p$ 满足 $p<|R|$ 以及 $n-a\cdot R=p$。

于是，我们就想到让负余数 $p$ 减去 $R$，因为此时 $p<|R|$ 并且 $R$ 为负数，所以 $p-R$ 小于 $|R|$，并且是个正数。

但是由于 $n-a\cdot R\neq p-R$，为了满足等式，我们就在等式左边也减去 $R$，得到 $n-a\cdot R-R=p-R$。

最后，等式左边再提取公因式，得到 $n-(a+1)\cdot R=p-R$。我们就可以得出结论：如果要使 $p$ 变为 $p-R$ 并且保证等式成立，就需要将 $a$ 增加 $1$。

于是，这道题就被我们做出来啦！

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r,p;
string s;
string f="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//进制转换表 
int main(){
	scanf("%d%d",&n,&r);
	printf("%d=",n);
	while(n){
		p=n%r;
		n/=r;
		if(p<0){//特判，如果 p<0，则减去 r
			p-=r;
			n++;//注意：此时 n 已经整除了 r，它现在已经是这一步的商了，所以增加 1 
		}
		s+=f[p];
	}
	reverse(s.begin(),s.end());//别忘了倒序输出！ 
	cout<<s;
	printf("(base%d)",r);
	return 0;
}
```

---

## 作者：zhuangjinning (赞：0)

## 题目大意

给出一个十进制数 $n$，将 $n$ 转换为 $r$ 进制，$r<0$。

## 解题方法

其实转成负进制和转成正进制是一样的，每次将 $n$ 模上 $r$ 的结果放入答案，再将 $n$ 除以 $r$ 即可。

但这道题由于 $r$ 是负数，所以还有一些需要注意的点。

第一，由于 $r$ 是负数，所以会有负余数的情况，需要将余数变为正数。

第二，不要忘了如果余数大于 $10$，要转换成大写字母。

代码的话就是只要 $n$ 没有被除尽就一直循环，每次将 $n \bmod r$ 的结果放入答案字符串中，再将 $n$ 除以 $r$ 即可。

## AC 代码


```cpp
#include<bits/stdc++.h>
// #define int long long
using namespace std;
int n;
int r;
string ans;
signed main(){
	cin>>n>>r;
	cout<<n<<"=";
	while(n){
		int ys=n%r;
		if(ys<0){//将余数转为正数
			ys-=r;
			n+=r;
		}
		if(ys<10){
			ans+=char(ys+'0');
		}else{
			ans+=char(ys-10+'A');//如果大于十就转成字母
		}
		n/=r;//一定不要忘了
	}
	for(int i=ans.size()-1;i>=0;i--){
		cout<<ans[i];//按倒序输出
	}
	cout<<"(base"<<r<<")";
	return 0;
}

```

---


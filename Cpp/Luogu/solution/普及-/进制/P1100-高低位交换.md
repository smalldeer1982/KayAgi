# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# 题解

## 作者：HenryHuang (赞：354)

这道题可以使用位运算。

最开始用模拟做写了30行，但看到老师的代码只有不到10行，······


话不多说，贴代码

---

这是一条分割线

多年之后回来看自己的题解，觉得不多写点对不起排在第一位，于是重新补了一些内容

### 位运算

> 程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。 ——摘自某百科

**常用的几种位运算**

- 与 (`&`) $\texttt{and}$

当两个数在二进制下对应位数上**均**为 $1$ 时，得到的结果为 $1$.

- 或 (`|`) $\texttt{or}$

当两个数在二进制下对应位数上**有一个**为 $1$ 时，得到的结果为 $1$.

- 异或 (`^`) $\texttt{xor}$

当两个数在二进制下对应位数上**不相同**时，得到的结果为 $1$.

- 左移 (`<<`)

将一个数在二进制下整体向左移位

- 右移 (`>>`)

将一个数在二进制下整体向右移位.


举个栗子：

$ 7 = (00000111)_2 $    

$ 11 = (00001011)_2 $

$ 7 \ \mathrm{and} \ 11 = (00000011)_2 = 3$

$ 7 \ \mathrm{or} \ 11 = (00001111)_2 = 15$

$ 7 \ \mathrm{xor} \ 11 = (00001100)_2 = 12$

$ 7<<1 = (00001110)_2 = 14$

$ 7>>1 = (00000011)_2 = 3$

通常情况下，左移一位表示将这个数乘以2，右移一位表示将这个数除以2，**向下取整**.

然后，对于这份代码，其实所谓的万无一失是不必要的，因为在做左移或者右移的时候，多余的位数就已经自动溢出了，所以可以省略不写.

另外，关于 $\texttt{0x0000ffff}$  这样的以 $\texttt{0x}$ 开头的数据，是十六进制表示法，每一位满 $16$ 进 $1$，用 $0$ ~ $\texttt{F}$ 表示.

对于这道题目，我们只需要将原数的后16位前移至新数的前16位，将原数的前16位前移至新数的后16位，这道题目就做完了。

~~话不多说，贴代码~~

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    unsigned long long x;
    cin>>x;
    cout<<((x&0x0000ffff)<<16|(x&0xffff0000)>>16)<<endl;//万无一失的做法
}
```

---

## 作者：月影困 (赞：95)

# P1100 高低位交换

~~不是，我说你们都在想什么啊？？这不是入门难度的题吗？？~~

C++有32位**无符号**整形（其他语言应该也有吧）。

左移16位，就是低位转到高位；右移16位，就是高位转到低位；两者相加，就是新数。

对于大佬们的字符串我这种蒟蒻就只能%%%%%了……

```cpp
#include <cstdio>
unsigned int n;

int main()
{
    scanf("%u", &n); // 注意读入的方法.
    printf("%u\n", (n >> 16) + (n << 16)); // 以及左移右移低得可怜的优先级.
    return 0;
}
```

---

## 作者：ChoHakuNe (赞：77)

看到这题，感觉pascal党终于有一个比c党先进的东西了。

当时看函数库，看到一个swap函数，就是将这个数的高低位交换，还不知道怎么用。

那么，这个函数就是为此题而生的！

这下可好，连位运算都不用写了。


注：longword是32位无符号整数，这里总结了一下规律：

xxint是有符号整数，比如shortint是八位有符号，integer是十六位，longint是三十二位。

相似地，xxword是无符号，规律差不多。


这道题用无符号的原因是longint交换后可能连符号位以及改了，导致几个点WA。

```cpp
var n:longword;
begin
 read(n);
 write(swap(n));
end.
```

---

## 作者：离散小波变换° (赞：54)

## **~~C++党与Pascal党的福音~~**

## C++解法其一:
为了弄清楚这条题目的本质，我们需要以下几点:

1. int型最多存储31位整形[即正负数都有，范围在$-2^{31}$~$2^{31}-1$]，而unsigned int也是31位，但是存储的是正整数[范围是1~$2^{32}-1$]。
2. C++运算中，若出现溢出，则**自动取模**。举个例子：在unsigned int型当中，计算$2^{32}$+233时，实际的运算是($2^{32}$+233)%$2^{32}$，结果就是233.
3. C++运算中，整数除法都是对零取整的。当然，这题都是非负整数，也没有0什么事了。
	#### ## 综合以上几点，能不能发现什么呢？
    问题让我们求的其实是2进制下交换前后16位，不就是向左移16位，加上左移16位吗？
    
    题目给的样例是**1314520 **
    
    **[0000 0000 0001 0100 0000 1110 1101 1000]**
    
    我们将它左移16位[注:已根据条件2进行取模]:
    
    **[0000 1110 1101 1000 0000 0000 0000 0000]**
    
    以及右移16位:
    
    **[0000 0000 0000 0000 0000 0000 0001 0100]**
    
    结合条件2与条件3，相加两式，得到的即是最终结果:
    
    **[0000 1110 1101 1000 0000 0000 0001 0100]**
    
    因此，代码就很简单了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<(n>>16)+(n<<16);
	return 0;
} 
```

## C++解法其二:
观察本题，我们发现，该题需要将原数拆分成两段。这时候我们的位运算&就登场啦
    仍然是那个例子。
    
  **[0000 0000 0001 0100 0000 1110 1101 1000]** 
  
  &0xffff0000: **[0000 0000 0001 0100 0000 0000 0000 0000]** 
 
  &0x0000ffff: **[0000 0000 0000 0000 0000 1110 1101 1000]**  
    
  如何取出某一段呢？很简单，对那一段**做一个&运算**。这里提一个小技巧：C++编译器支持直接书写16进制，方法是0x十六进制数[比如0x00000001就是十进制下的1]。2进制，就是0bXXXX...。
    
   取出前16位，就是&0xffff0000，取后16位，就是&0x0000ffff。位移即可。
    
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<((n&0xffff0000)>>16)+((n&0x0000ffff)<<16);
	return 0;
} 
```
//注：本解法其实与解法1类似，个人认为解法1更巧妙.
##### 对于Pascal党...
上面的题解应该讲的很清楚了，谜一般的swap函数...
#### 本题尽管是条挺简单的位运算题，但是牵扯到的位运算知识较多，还是比较值的学习与思考的
    

---

## 作者：vectorwyx (赞：36)

## 看到这么多大佬用位运算，蒟蒻默默发一篇不用位运算的题解
### 仔细读题，所谓的“交换”，其实就是****把前16位后移，把后16位前移****而已，因此我们只需把每一位分离出来即可
### 代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long a,sum=0,x=0;//用x表示位数，sum记录结果
	cin>>a;
	while(a){//把a分解为2进制
		if(a%2==1){//这一位是1，进行处理
			if(x<16){//属于后16位，前移
				sum+=pow(2,x+16);
			}
			else{//属于前16位，后移
				sum+=pow(2,x-16);
			}
		}
		a/=2;
		x++;
	}
	cout<<sum;
	return 0;
}
```



---

## 作者：智子·起源 (赞：15)

### 妾身看了看大家的题解，我觉得还可以换个更简单明了的写法。^_^

思路很简单，就是直接模拟。

1、把读入的数字转成2进制。

2、高低位交换。

3、转成十进制，输出。



#### 要注意的是：输出和输入的10进制数和最后用来存放权值的变量都要用long long，不然会越界。

上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long x,ans,t=1;
int a[33],n;
int main()
{
  scanf("%lld",&x);
  while(x>0)
  {
    n++;
    a[n]=x%2;
    x/=2;
  }
  for(int i=1;i<=n;i++)
    swap(a[i],a[n-i+1]);//读入+转二进制
  for(int i=1;i<=16;i++)
    swap(a[i],a[i+16]);//高低位交换
  for(int i=1;i<=32;i++)
    ans+=t*a[i],t*=2;
  printf("%lld",ans);//再转回十进制输出。
  return 0;
}

```
~~还有，题目样例“1314520”有点太那个了。⊙﹏⊙‖∣~~

---

## 作者：ykkz000 (赞：15)

在计算机中，小地址存储低位，unsigned short为16位，unsigned int为32位，故可以先将原数的地址强制类型转换为unsigned short型指针，指向低位，取值并向左位移16位赋给新数高位，再将指针加1，指向原数高位，直接赋给新数低位，完成高低位交换。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	unsigned int s;
	cin>>s;
	unsigned short *p=(unsigned short *)&s;
	unsigned int n=(*p)<<16;
	p++;
	n+=(*p);
	cout<<n;
	return 0;
}

```

---

## 作者：xkzxkzxkz (赞：11)

发一篇biteset的题解
如题意模拟即可。

```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <bitset>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::vector;
using std::sort;
using std::bitset;

int main(void)
{
	unsigned long long n = 0;
	cin >> n;

	bitset<32> binary(n),rev(0);

	for (int i = 0; i < 16; i++)
	{
		rev[16+i] = binary[i];
	}

	for (int i = 0; i < 16; i++)
	{
		rev[i] = binary[i + 16];
	}

	cout << rev.to_ullong() << endl;
	return 0;
}


```

---

## 作者：蒟蒻lxy (赞：5)

本题解由[$\Large{QAQer}$](https://www.luogu.org/space/show?uid=34500)编写


欢迎到[QAQer的博客](https://www.luogu.org/blog/lxy0508cpp/#type=%E9%A2%98%E8%A7%A3)中查看

## 思路：
~~最暴力的办法~~     
即：$\text{十进制}$->$\text{二进制}$->$\text{倒转后二进制}$->$\text{倒转后十进制}$

相信大家都能看懂。

## 坑：

会爆int！会爆int！！会爆int！！！    
~~（重要的事情）~~

所以不能用```(1<<(i-1))```而只能用```(1ll<<(i-1))```;     
具体的请看代码注释


------------


不废话了，直接上代码。

```
#include<bits/stdc++.h>
using namespace std;
long long ten,two[100005],ans;
//十进制数，二进制数组，最终答案 
void init()//输入（第一次试图模仿dalao们的马蜂） 
{
	cin >> ten;
}
void two_throw()//十进制转二进制
{
	int t=ten;
	for(int i=1;i<=32;i++)
		two[i]=t%2,t/=2;//十进制->二进制 
}
void swapper()//交换高低位 
{
	for(int i=1,j=17;i<=16;i++,j++)//双指针法 
		swap(two[i],two[j]);//交换 
}
void ten_throw()//二进制转十进制 
{
	for(int i=1;i<=32;i++)
		ans+=two[i]*(1ll<<(i-1));//转换为2进制，其中(1ll<<(i-1))是求2的(i-1)次方的意思 
	//用1ll的原因：1ll是longlong类型的1的意思，不用会默认设为int型，2的32次方会爆 
}
void print()//输出（第二次试图模仿dalao们的马蜂）
{
	cout << ans << endl;
}
/*void print2()//可用来调试的输出函数 
{
	for(int i=1;i<=32;i++)
	{
		cout << two[i] <<' ';
		if(i==16)
			cout <<"| ";
	}
	cout << endl;
}*/
int main()//不要我解释了吧QWQ 
{
	init();
	two_throw();
	//print2();//调试用 
	swapper();
	//print2();//调试用 
	ten_throw();
	print();
        return 0
}

```

---

## 作者：ejfbdn (赞：4)

输入输出均为无符号整形，用unsigned int存，%u输入。

将原数右移16位，得到的是二进制下数的前16位，前面为16个前导零。

将原数左移16位，得到的是二进制下数的后16位，后边有16个0。

左移16位的结果加右移16位的结果恰好就是题目所要求的。
```
#include<cstdio>
int main()
{
	unsigned int a;
	scanf("%u",&a);
	return printf("%u",(a>>16)+(a<<16))&0;
}
```

---

## 作者：DarkPaL (赞：3)

2L是用的long long ,但其实数据保证是正数，所以用unsigned long 更优。



```cpp
#include<iostream>
using namespace std;
unsigned int x;
int main()
{
    cin>>x;
    cout<<(x<<16)+(x>>16);
}
```

---

## 作者：partychicken (赞：2)

#其实这道题不用进行交换操作的，或者说可以直接写成交换后的形式

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a[32];
int main()
{
    int n,temp=31,ans=0;//反抄袭，认真看题解的孩子把int改成longlong，因为数据范围
    cin>>n;
    while(n>0)
    {
        a[temp]=n%2;
        n/=2;
        temp--;
    }
    temp=15;                          //这是交换后的尾
    for(int i=0;i<32;i++)
    {
        if(temp==-1) temp=31;//进行第16位与17位的对接
        ans+=a[temp]*pow(2,i);
        temp--;
    }
    cout<<ans;
}
```

---

## 作者：_Int_ (赞：2)

//麻烦的做法，程序里面变量讲得很清楚

上代码

当当当当当当当当~~~~~~~

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int ac[32][2];
long long ask,answer;
int two(int n){//求2的平方
    if(n==0)return 1;
    return 2*two(n-1);
}
void ten_to_two(void){//10转2
    int t=0;
    while(1){
        if(ask==0)break;
        ac[t++][0]=ask%2;
        ask/=2;
    }
}
void two_to_ten(void){//2转10
    int i=0,j=31;
    for(;j>=0;i++,j--){
        if(ac[j]!=0){
            answer+=1*two(i);
        }
    }
}
void two__two(void){//换位
    for(int i=0;i<16;i++){
        ac[i+16][1]=ac[i][0];
        ac[i][1]=ac[i+16][0];
    }
}
void read(void){//读入
    cin>>ask;
}
void print(void){//输出
    cout<<answer;
}
void work(void){//工作
    read();
    ten_to_two();
    two__two();
    two_to_ten();
    print();
}
int main(){
    freopen("sb.in","r",stdin);//防抄袭
    freopen("sb.out","w",stdout);
    work();
    return 0;
}
```
其实把freopen删掉还是错的
~
~
~
~
~
正确代码

当当当当当当当当~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
    unsigned long long x;//不用long long就爆了
    cin>>x;
    cout<<((x&0x0000ffff)<<16|(x&0xffff0000)>>16)<<endl;//高科技用法
    while(1);//防抄袭水印
    return 0;
}
超短
```

---

## 作者：oierwa (赞：1)

今天正逢老师~~（我永远都不会告诉你其实是学长）~~讲到位运算~~（话说我们不是早就学过一些了吗，皮毛还要学两遍）~~，于是我就来水题了。
## 我的思路
>一开始就想着只要把高位，低位提出来，低位乘个2^16，高位除个2^16一加起来就好了。

>进一步思考，高位舍弃十六位就留下低位，低位舍弃十六位就留下高位，再把高位挪到低位，低位挪到高位，两步其实可以一起完成————左移&右移。

>下图可供参考

>![](https://cdn.luogu.com.cn/upload/pic/49260.png)

>在图中，我们把右移和左移分开处理，得到两个值：低位移到高位的值，高位移到低位的值。

>然后，这两个值的低位，高位，分别**全为零**，所以————————

>相加就好了

## 第一份代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n;                      //定义一个变量
	cin>>n;                     //输入它
	cout<<((n>>16)+(n<<16));    //交换高位，低位
	return 0;
}
```
然后愉快地拿了70Points

所以说，这是为什么呢？

然后慌忙下了一套数据，发现输出了负数！！！

一慌就忘了C++语法中的int负数的表示，忘了还有**补码**这东西。

怎么解决呢？

**unsigned**就没有问题啦！！(开**unsigned long long**貌似没必要)

见代码：
## 第二份代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;             //开unsigned （unsigned int 可以简写成 unsigned）
	cin>>n;
	cout<<((n>>16)+(n<<16));
    //  高位转低位,低位转高位
	return 0;
}
```
然后就愉快地AC了

---

## 作者：Konyaku_TJU (赞：1)

**
来自蒟蒻第一次搞事情~~~~**

-----------
进入正题，
这是个典型的位运算的题，~~水的一批~~


------------
很随意的两个办法，上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned int n,x,y;//如果是用int储存32位，一定要开unsigned无符号类型
int main()
{
	cin>>n;
	x=n&((1<<16)-1);//注意是要-1的，否则会重叠两部分
	y=n>>16;
	cout<<(x<<16)+y;
}
```
第一种就是直接分两半，左边是y，右边是x，x左移16位，y同理。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
unsigned int a,b,n;
int main()
{
	cin>>n;
	a=n<<16;//左移16位，高位部分自然溢出 
	b=n>>16;//右移16位，低位部分自然去掉 
	cout<<a+b;
}
```
第二种也是同理，~~简直是水得无法再水……~~

~~卖个萌求通过~~（抄袭可耻，严谨治学）

---

## 作者：whxyx2001 (赞：1)

##字符串做法



```cpp
    #include<iostream>
    #include<cstring>
    #include<algorithm>
    #include<cmath>
    using namespace std;
    int main()
    {
        long long n;
        int bin;
        long long res=0;
        int i;
        string os="",s1="",s2="",s="";   ///定义四个字符串
        cin>>n;
        while(n>1)     ///转换为“2进制”字符串
        {
            if(n%2==1) os+="1";
            else os+="0";
            n/=2;
        }
        os+="1";       ///补齐第一位（就是1）
        while(os.size()<32)    ///末尾补0，直到32位
        {
           os+="0";
        }
        reverse(os.begin(),os.end()); ///倒置字符串（就是翻转）...毕竟上面的os是倒置的“2进制数”
        s1=os.substr(0,16);    ///截取前16位
        s2=os.substr(16,16);  /// 截取后16位
        s=s2+s1;    ///将两者拼在一起
        for(i=0;i<=s.size()-1;i++)    ///“2进制”字符串转换为10进制数
        {
            bin=s[i]-48;  ///将各位转换为数字（'0'的ASCII码为48）
            res+=bin*(pow(2,31-i)); ///按常理进行进制转换
        }
        cout<<res;  ///输出结果
}
```

---

## 作者：YczSS (赞：1)

大家要注意，有些点的输出用longint会爆，所以结果要用qword储存。

下面附上本人的代码:

```cpp
Var
  s,ss,s1,s2:string;
  i,n:longint; ans:qword;
  function sze(n:longint):string;                           //十进制转二进制
  var i,c:longint; l:string;
  begin
    c:=n;
    sze:='';
    while c<>0 do
    begin
      str(c mod 2,l);
      sze:=l+sze;
      c:=c div 2;
    end;
    if length(sze)<32 then while length(sze)<32 do sze:='0'+sze;
  end;
  function ezs(s:string):qword;                                                      //二进制转十进制
  var i:longint;
  begin
    ezs:=0;
    for i:=1 to length(s)-1 do ezs:=(ezs+ord(s[i])-48)*2;
    ezs:=ezs+ord(s[length(s)])-48;
  end;
Begin
  readln(n);
  s1:=sze(n);
  s:=''; ss:='';
  for i:=1 to 16 do s:=s+s1[i];                                         //高低位
  for i:=17 to 32 do ss:=ss+s1[i];                                    //交换！
  s2:=ss+s;
  ans:=ezs(s2);
  writeln(ans);                                                                   //做完这些，就可以输出啦～
End.
祝大家愉快AC。
```

---

## 作者：Catch_22 (赞：1)

由Matrix67的位运算讲稿、

我们只要一行

```delphi
Writeln((n Shr 16) or (n Shl 16));
```

Pascal中swap函数更加简练

```delphi
Writeln(Swap(n));
```
即可

P.S.Swap就是用来进行位操作的。交换一个数的二进制高位和低位。



---

## 作者：courage (赞：1)

本题由于数据只有一个，所以直接做即可，没必要用位运算优化

因为数据范围是<2^32，所以用long long防止溢出

```cpp

#include<cstdio>
long long x,ans,a,b;
int main(){
    scanf("%I64d",&x);
    ans=(long long)x%65536*65536+(long long)x/65536;
    printf("%I64d\n",ans);
}

```

---

## 作者：dhoiers (赞：1)

@Catch\_22 的解法可行，但是有一个问题：本题的要求不是这样的。应该是用$+$连接，而非 OR 算符。

所以，我的题解是：

```pascal
var
  a,b,c:dword;
begin
  read(a);
  b:=a;
  a:=a shr 16;
  b:=b shl 16;
  write(a+b);
end.
```

---

## 作者：封禁用户 (赞：1)

使用位运算优化。

>#include<cstdio>
```cpp
int n, a, b, total;
int main(){
    a = b = total = 0;
    scanf("%d",&n);
    a = n << 16;
    b = n >> 16;
    total = a + b;
    printf("%d\n",total);
    return 0;
}
```

---

## 作者：Sinwind (赞：0)

# 1.分析

1. 输入的数$num(num\in [1,2^{32}),num\in N_+)$，因此用$unsigned\space int$型，转换后的$2$进制码用$string$存储。

2. $2$进制$\rightarrow10$进制，参考：[进制（按位计数法）第2部分](https://www.luogu.org/blog/Singularwind/count-by-bit#)。

# 2.思路

1. 将$num$用**短除法**转化为$2$进制，存入$binary$，

2. $binary$不足$32$位的，前面用$0$补足。

3. 将$binary$的后$16$位$(binary[16]\sim binary[31])$存入$temp$，将$temp$放于$binary$之前。

4. 将$binary$前$32$位$(binary[0]\sim binary[31])$转化为$10$进制并输出。

# 3.代码

```cpp
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

unsigned int num;  	 	//输入的数字
unsigned int ans;    	//输出的结果
string binary;          //二进制码
string temp;            //存储原来的低位，交换后的高位

int main(void)
{
	cin >> num;
	
	while(num)
	{
		binary = (char)(num % 2 + '0') + binary;
		num /= 2;
	}
	
	for(int i = binary.length(); i < 32; i++)
	{
		binary = '0' + binary;
	}
	
    for(int i = 16; i < 32; i++)
    {
    	temp += binary[i];
	}
	
	binary = temp + binary;
	
	for(int i = 0; i < 32; i++)
	{
		ans += (binary[i] - '0') * pow(2, 31 - i);
	}
	
	cout << ans;
	
	return 0;
}
```


---

## 作者：zhuchengyang (赞：0)

还记得初学时做的一道题吗？输入一个两位数，将它的十位和个位交换后输出。

这题其实和那题是一样的，只是那道题是div 10和mod 10，这题的除数要自己求而已。

贴代码：


```cpp
uses math;              //使用math库
var                          //定义变量
 v,a,b,k:int64;          //v用来读入，a和b是存储高位和低位的，k用来计算除数
begin                      //开始
 readln(v);               //输入一个数
 k:=2**16;               //计算除数，**是乘方符号
 a:=v div k;             //计算“十位”(高位)
 b:=v mod k;          //计算“个位”(低位)
 writeln(b*k+a);     //反序输出
end.                       //结束
```

---

## 作者：郑翔弈 (赞：0)

其实很简单，思路清晰即可

```cpp
#include<stdio.h>
int main()
{
    long long a;//注意，数据类型要大
    scanf("%lld",&a);//读入
    int p[32];//储存原二进制码的数组
    int i;//循环控制变量
    long long ans=0;//结果
    long long fact=1;//乘积
    for(i=31;i>=0;--i){//原二进制码读入
        p[i]=a%2;
        a/=2;
    }
    int s[32];//后二进制码
    for(i=0;i<16;++i) s[i]=p[i+16];//17-32位交换
    for(i=16;i<32;++i) s[i]=p[i-16];//1-16位交换
    for(i=31;i>=0;--i){//将结果转为十进制
        ans+=s[i]*fact;
        fact*=2;
    }
    printf("%lld",ans);//输出
    return 0;//结束
}
```

---

## 作者：dxy2017 (赞：0)

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long a,b;//用long long 更保险。 
    cin>>a;
    b=(a/65536)+(a%65536)*65536;//首先我们知道，2 的16次方正好是65536。现在就简单了。
//用整除求出高位；用 % 求出低位，再乘65536；两者相加。 
    cout<<b;//输出。 
return 0; }
```

---

## 作者：yali_hzy (赞：0)

这题纯模拟是可以的。

一定记得要用usigned int。

当然也可以用位运算。

代码(c++,虽然很像c)：


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
unsigned int x,c,i,j,ans,s[50];
int main()
{
    scanf("%u",&x);
    c=x;
    for(i=0;i<32;i++)
        s[i]=0;//可以用memset(s,0,sizeof(s));
    while(c>0)
    {
        s[--i]=c%2;
        c/=2;
```
}//转为2进制
```cpp
    for(i=16,j=31;i<32;i++,j--)
        ans+=s[i]*(1<<j);//左移1位乘2,
    for(i=0;i<16;i++,j--)
        ans+=s[i]*(1<<j);//可以不用存另一个数组，直接处理
    printf("%u",ans);
}
```

---

## 作者：skylee (赞：0)

短小精悍~

```delphi
var
  n:longword;
begin
  readln(n);
  writeln(swap(n))
end.
```
解释：

1.swap是Pascal标准库中的一个函数，作用是把一个变量的高位和低位交换。

2.longword是无符号32位整型，之所以不用longint是因为高低位交换后低位的值有可能会大于0x7fff。


---

## 作者：zeroplayer (赞：0)

var st1,st,st2,st3:string;ln,j,i:longint;n,s,b:int64;a:array[1..10001]of longint;

```cpp
begin
  readln(n);
  repeat//把十进制数转为二进制数
    inc(j);
    a[j]:=n mod 2;
    n:=n div 2;
  until n=0;
  for i:=j downto 1 do//把它转为字符串，方便高位补零
   begin
     str(a[i],st1);
     st:=st+st1;
   end;
  ln:=length(st);
  if ln<32 then//检测高位需不需要补零
   begin
     for i:=1 to 32-ln do
      st:='0'+st;
   end;
  for i:=1 to 16 do//记录前16位
   st2:=st2+st[i];
  for i:=17 to 32 do//记录后面16位
   st3:=st3+st[i];
  st:=st3+st2;//调换位置
  for i:=1 to length(st) do//把二进制数转化为十进制数，这里我用了打表
   begin
     case st[i] of
       '0':b:=0;
       '1':b:=1;
       '2':b:=2;
       '3':b:=3;
       '4':b:=4;
       '5':b:=5;
       '6':b:=6;
       '7':b:=7;
       '8':b:=8;
       '9':b:=9;
       'A':b:=10;
       'B':b:=11;
       'C':b:=12;
       'D':b:=13;
       'E':b:=14;
       'F':b:=15;
     end;
     s:=s*2+b;
   end;
   write(s);
end.
```

---

## 作者：hfctf0210 (赞：0)

上面几位做的全部都是开挂的（用函数），其实不用函数也能做：

C++程序（配讲解）：

```cpp
#include<iostream>
using namespace std;
unsigned int c[32]={1,2,4,8,……,2147483648};//2进制表（2的0~31次方），Pascal的可以在程序中赋值
unsigned int n,s=0;//n：读入的数；s：存储器
bool a[32];//保存该位是0还是1，从低位到高位存储
int main()
{
    cin>>n;
    int m=31;//二进制位指针赋值为31
    while(n)//当n不为0时，二进制没有存储完
    {
        while(n<c[m])//找到第一个比n小的2的m次方的数
        m--;//下标移位
        a[m]=1;//赋值
        n-=c[m];//减去该2的m次方数
    }
    for(int i=16;i<=31;i++)//将大的16位变成小的
    if(a[i])//如果该位是1
    s+=c[i-16];//下标应该减16，然后存储
    for(int i=0;i<=15;i++)//小变成大
    if(a[i])
    s+=c[i+16];//下标加16后存储
    cout<<s;//输出存储器
    return 0;
}
```

---


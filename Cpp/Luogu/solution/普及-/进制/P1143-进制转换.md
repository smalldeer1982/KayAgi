# 进制转换

## 题目描述

请你编一程序实现两种不同进制之间的数据转换。


## 样例 #1

### 输入

```
16
FF
2
```

### 输出

```
11111111```

# 题解

## 作者：kIG7Z8oP (赞：294)


update：

**修改了一些语焉不详之处** 19/11/16

**新加了几个~~坑~~空**  19/11/16（没错就是CSP2019的day1）

------------
------------

# 话说你们为什么都非要先转十进制啊！！！

还要用什么快速幂的说……

我鈦蒟蒻，不会怎么办啊QAQ

## 今天来教大家读入优化~~

### 不要急，往下看，正解很简单❤

首先~~假设~~我们都知道，getchar()明显快于scanf(),所以常常有人用这个来 ~~卡常数~~ 压时间

读入一个整数的方法：

```cpp
inline int read(int &x)
{
	x=0;
	int f=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x*=10,x+=c-'0',c=getchar();
	x*=f;
}//读完后，是数字的下一个字符
//这是一种任意十进制快速读法
```
而那种十进制读入法**是可以优化的**

优化方法如下

```cpp
inline int read()
{
	int x=0;
    char c=getchar();
    while(c<48||c>47)//c<'0'||c>'9'
    	c=getchar();
    while(c>47&&c<58) x*=10,x+=c-48,c=getchar()
    return x;
}//仅能读正整数
```

**亲测read()比scanf()快大约5倍**

那么大家想一想,如果n=10，题目中输入时
# 第二行不就是read()吗？！

那么问题来了，**怎么从十进制读入变成n进制读入呢？**

~~相信聪明的你一定想到了办法~~  **:-)**

我们在读入优化时(假设你已经会了读入优化……)**是按位读的**(十进制位)

然后我们只需**按位读**(n进制位)
### 注意别忘了特判'A'~'F'

所以可以这样写(读入)
```cpp
#include<cstdio>
int n;
inline int isint(char c)//可将'0'~'9'及'A'~'F'转化成如题所示数字并将非数字字符返回-1注意此时c并不会被修改
{
	if(c>='A'&&c<='F')
		return c-55;//'A'=65,10=10;
	if(c>47&&c<58)
		return c-48;
	return -1;
}
inline void read(int &x)
{
	char c=getchar();
    while(isint(c)==-1) c=getchar();
	while(~isint(c)/*判断是不是数*/) x*=n,x+=isint(c),c=getchar();
}//read()后会读到数字后的第一个字符(读完) 
```

好的本题前两行输入完成**❤**

现在你手里有一个**以int表示的n进制数x**

------------


其实输出也能优化

常规 ~~卡常~~ 压时间技巧如下

```cpp
void otp(int k)
{
	if(!k) return;
    otp(k/10);
    putchar(k+48);
}
```

其实这已经很好了(当然也不是不能改)

假设你前面已经全明白了(**不明白请回头深造**)

## 输出优化也可以被方便的转成m进制

方法如下
```cpp
int m;
inline char cic(int x)//change into char 意在将一个n进制数的某位转成对应的m进制
{
	if(x<10)//毕竟不会出负数，算个小优化~
    	return x+48;
    return x-10+'A';
}
void otp(int k)
{
	if(!k) return;
    otp(k/m);
    putchar(cic(k%m));
}
```


以下是题解

# 创建和邪落谷，警惕陶片放逐
# 为了您和他人的安全，请勿抄标程

(直接粘贴标程并提交有惊喜呦~~)

```cpp
#include<cstdio>
int n,x,m;
inline int isint(char c)
{
    if(c>='A'&&c<='F')
        return c-55;
    if(c>47&&c<58)
        return c-48;
    return -1;
}
inline int read()
{
	int x=0;
    while(~isint(c)) x*=n,x+=isint(c),c=getchar();
    return x;
}
inline char cic(int x){
    if(x<10)
    	return x+48;
    return x-10+'A';
}
void otp(int k)
{
    if(!k) return;
    otp(k/m);
    putchar(cic(k%m));
}
int main()
{
    scanf("%d",&n);
    x=read();
    scanf("%d",&m);
    otp(x);
    putchar('\n');
}
```

希望能帮助到大家，谢dalao们观看，欢迎来喷呦

---

## 作者：cosmicAC (赞：171)

这种题干嘛要手写呢，C++已经给你准备好了现成的函数。

有个现成的函数叫做strtol()，可以把任一进制的字符串转成long。用法:strtol(字符串,NULL,要转的进制),返回值就是结果。

但问题是把int转成别的进制字符串有些困难，windows下有个现成的itoa()函数，可以把int转成任一进制的字符串，可惜洛谷是linux评测。

然后我就在[这个网站](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)中找了一会儿解决方案。最后因为我太菜了，只会使用C++17的to_chars。用法：to_chars(字符串,字符串尾部指针,要转的值,目标进制)

但是我的本地编译环境是clang，众所周知clang对于新标准的支持总是比较迟缓的，于是只好使用洛谷IDE的g++了。

还有一个问题，就是这样转出来的字符串是小写的，题目要求是大写。这好像没有现成的函数可以做，于是又在那个网站找了下，最后找到了<locale>中的toupper函数。
  
最后注意数组不要开小了。

代码如下,可在Linux环境下开C++17使用G++7.3编译：
```C++
#include<bits/stdc++.h>
using namespace std;
int b,m;char s[40],t[40];
int main(){
    scanf("%d %s %d",&b,s,&m);
    to_chars(t,t+40,strtol(s,NULL,b),m);
    //如果把上面一行改成itoa(strtol(s,NULL,b),t,m)，应该就能使用Dev-C++，C++11编译通过
    auto& f=use_facet<ctype<char>>(locale());
    f.toupper(t,t+40);
    puts(t);
    return 0;
}
```

---

## 作者：HiroshiRealm (赞：132)

这一题并没有直接的公式可以帮助我们达到从n进制直接转换为m进制的方法，所以我们应该先转换成10进制（根据位值原理），再取模运算，将10进制转换为m进制 。
话不多说，上代码（~~逃~~）
```
#include<bits/stdc++.h>
using namespace std;
string a;
int c[10000000],d,e,f,g,sum,ans;
int main()
{
    scanf("%d",&d);
    cin>>a;
    scanf("%d",&f);
    for(int x=0;x<a.size();x++){
        if(a[x]<'A'){
            e=pow(d,a.size()-x-1);
            e*=(a[x]-'0');
            sum+=e;
        }
        else{
            e=pow(d,a.size()-1-x);
            e*=(a[x]-'A'+10);
            sum+=e;
        }
    }
        while(sum>0){
        c[g++]=sum%f;
        sum/=f;
    }
    for(int x=g-1;x>=0;x--){
        if(c[x]>=10)printf("%c",c[x]+'A'-10);
        else printf("%d",c[x]);
    }
    return 0;
}
```

---

## 作者：小罐猹 (赞：61)

（水）
这是本蒟蒻第三次发题解。这题是一道经典第进制转换的题目。没啥技术含量,纯模拟。注意一下16进制的转换。
代码奉上：

```cpp
#include <iostream>
using namespace std;
int ito(char a)
{
	if(a=='A')  return 10;
	if(a=='B')  return 11;
	if(a=='C')  return 12;
	if(a=='D')  return 13;
	if(a=='E')  return 14;
	if(a=='F')  return 15;
	return int(a-'0');
}
char oti(int a)
{
	if(a==15)  return 'F';
	if(a==14)  return 'E';
	if(a==13)  return 'D';
	if(a==12)  return 'C';
	if(a==11)  return 'B';
	if(a==10)  return 'A';
	return char(a+'0');
}
int main(int argc, char** argv)
{
	long long i,n=0,p1,p2,x=1;
	string s,res="";
	cin>>p1>>s>>p2;
	for(i=s.size()-1;i>=0;i--)
	{
		n+=ito(s[i])*x;
		x*=p1;
	}
	while(n!=0)
	{
		res=oti(n%p2)+res;
		n/=p2;
	}
	cout<<res<<endl;
	return 0;//完美结束
}
```

---

## 作者：oistr (赞：59)

$\color {white} \text{洛谷后台文章编号 151902}$

蒟蒻又来了。。。

新手都能看得懂的题解
## 背景知识
这里介绍3种转换方法。
### r进制转10进制
~~应该最简单了。。。~~

**前置知识：位值原理**

假设有一个 $r$进制数 $(a_na_{n-1}a_{n-2}...a_0)_r$（$a_1,a_2...$是此数的每一位），那么它对应的10进制数 $(n)_{10}=a_n*r^n+a_{n-1}*r^{n-1}+...+a_1*r+a_0$。
### 10进制转r进制

r进制转10进制用的是乘法，那么10进制转r进制就用除法。

例如：十进制的 $23$ 转二进制，则过程如下：

![](https://cdn.luogu.com.cn/upload/pic/72926.png)

就是短除法然后倒取余数。不仅是2进制，任意进制都可以。
### 2进制与4进制、8进制、16进制互换
其实不仅是$2,4,8,16$进制，$r$进制和 $r^k(k\text{是正整数})$ 进制均可互换。

由于 $4=2^2,8=2^3,16=2^4=4^2$ ，所以2进制的每两位对应4进制的一位，每三位对应8进制的一位，以此类推。

所以，只要熟记以下表格，我们甚至可以心算很多 $2$ 与 $4,8,16$进制的互换。

```
2进制转4进制
2进制 4进制
00    0
01    1
10    2
11    3
```

```
2进制转8进制
2进制 8进制
000    0
001    1
010    2
011    3
100    4
101    5
110    6
111    7
```

```
2进制转16进制
2进制 16进制
0000    0
0001    1
0010    2
0011    3
0100    4
0101    5
0110    6
0111    7
1000    8
1001    9
1010    A
1011    B
1100    C
1101    D
1110    E
1111    F
```
例如：$(00000111110011010001)_2$ 转 $16$ 进制：

（1）截位：$(0000|0111|1100|1101|0001)_2$

（2）查表（~~打表~~）：
$=(07CD1)_{16}$

## 代码实现
有了上面的知识，其实就很好做了。

本题采用先将 $n$ 进制转换为 $10$ 进制，在将 $10$ 进制转为 $m$ 进制的方法。当然也可以直接转。

这里想着重说一下转换过程中数据的存储。

首先，读入时必须用字符串 $string$ 。

然后将 $string$ 转为 $int$ ，在此过程中实现$n$ 进制转换为 $10$ 进制。注意十六进制中字母的转换。例如： $(AB)_{16}=(171)_{10}$。

然后采用一个数组记录除下来的余数，最后反转输出即可。本题中可以利用栈来存储，直接 $push$ 进去然后 $pop$ 即可。

上代码：
```
#include <iostream>//输入输出流
#include <string>//字符串
#include <stack>//栈
//个人认为还是不用万能头好，用了万能头就需要很注意变量名的使用，避免重名。
using namespace std;
string num;//这里用不限长的字符串，比字符数组好
//n转10进制（位值原理）
int convert(string num,int r)
{
	int n=0,s=1;
	int len=num.length();
	for(int i=len-1;i>=0;i--)
	{
    //16进制特判
		if(num[i]<='F'&&num[i]>='A')
		{
			n+=(num[i]-'A'+10)*s;
			s*=r;
		}
        //普通处理
		else
		{
			n+=(num[i]-'0')*s;
			s*=r;
		}
	}
	return n;
}
//输出函数
void output(stack<int> s)
{
	while(!s.empty() )
	{
		if(s.top() <10)
			cout<<s.top() ;
		else if(s.top() >=10)
		   cout<<(char)(s.top() +'A'-10);//注意其中16进制的处理
		s.pop() ;
	}
	cout<<endl;
}
//10转m进制（短除法）
void work(int n,int r)
{
	stack<int> s;
	while(n>0)
	{
		s.push(n%r);
		n/=r;
	}
	output(s);
}
int main()
{
	int oldr,newr;
	cin>>oldr;
	cin>>num;
	cin>>newr;//input
	int n=convert(num,oldr);//转为10进制
	int lenn=num.length();
	work(n,newr);//转为m进制并输出
	return 0;
}
```

---

## 作者：不会dp退役菜鸡 (赞：30)

        方法都一样，这题也容易，那么在赛场上这种题肯定是拼速度的了。。。

        map是个好东西

        不压行，代码只有20行，参上

```
#include<bits/stdc++.h>
using namespace std;
map<char,int> nums; map<int,char> nums_;//用map存互相对应的数（要不是有10以上的进制。。。）
int n,num,temp; string x; char ans[100];
int main()
{
	for(int i=0;i<10;i++) 
		nums[i+'0']=i,nums_[i]=i+'0';
	for(char i='A';i<='F';i++) 
		nums[i]=i-'A'+10,nums_[i-'A'+10]=i;//上面4行初始化map
	scanf("%d",&n); cin>>x;
	for(int i=0;i<x.length();i++)
		num=num*n+nums[x[i]];//转化到10进制
	scanf("%d",&n);
	while(num)
		ans[temp++]=nums_[num%n],num/=n;//转化到m进制
	for(int i=temp-1;i>=0;i--) 
		printf("%c",ans[i]);//输出
	return 0;
}
```

        赛场上要尽量选代码量少的解法，才能有足够的时间做后面的题呢！qwq！

---

## 作者：wxy_god (赞：24)

思路是：

- 输入（输入$n$进制数是用字符串，因为有字母）
- 将输入的字符串一个一个转换成数字，存在另一个$int$数组里
- 将转换成$int$类型的数组转换成一个$int$类型的数，因为题目中说了转换成十进制后$int$存得下
- 然后将那个数转换成$m$进制数，用另一个$int$数组存下来
- 输出，注意判断是不是字母

[p.s.为什么遍历数组的时候要写成这样？](https://89396.blog.luogu.org/c-zi-fu-chuan-chu-li)

十进制转其他进制和其他进制转十进制的方法大家都会吧，我就不说了

```
#include <cstdio>
#include <cctype>

int main () {
    
    int n, m, i, sum = 0, time = 1;//sum是用来存放转换成十进制后的数
    char a[30];//输入的数组
    int b[30];//存放每一位转换成数是多少的数组
    int c[30];//转换成m进制后存放的数组
    
    scanf("%d%s\n%d", &n, a, &m);
    for(i = 0; a[i]; i ++ )//上面的链接解释了为什么要这样遍历数组
        if(isdigit(a[i]))//isdigit是判断是不是字符型数组的函数
            b[i] = a[i] - '0';//转换成数
        else//是字母
            b[i] = (a[i] - 'A') + 10;//转换成数，记得 + 10
    
    int len1 = i;//i出来之后就是长度
    for(i = len1 - 1; i >= 0; i -- ) {//倒着算出转换成十进制后是多少
        sum += b[i] * time;//乘以每一位十进制的值是多少
        time *= n;//不要忘记*n哦
    }

    int len2 = 0;//转换成m进制时用来表示下一位放在哪里的指针
    
    while(sum >= 1) {//只要还没除完
        c[len2] = sum % m;
        sum /= m;
        len2 ++ ;
    }
    
    for(int i = len2 - 1; i >= 0; i -- )//倒着输出
        if(c[i] < 10) printf("%d", c[i]);//是数字
        else printf("%c", c[i] - 10 + 'A');//是字母
    return 0;
}
```

---

## 作者：Jyf624761709 (赞：12)

##因为是n进制转m进制，所以本人的思路是先把n进制转十进制，再把十进制转成m进制。相比dalao们的程序，略微有些繁琐。不多说，此处附上代码。。。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,l;//l的用法见下
char njz[25],mjz[25];
int power(int a,int x){//快速幂，用来计算n进制下每一位的幂，从而转换成十进制
    int ans=1;
    while(x>0){
        if(x&1!=0)
            ans*=a;
        a*=a;
        x>>=1;
    }
    return ans;
}
int nzh(){//n进制转十进制
    int t,sjz=0;
    t=l;
    for(int i=0;i<=l;i++){
        if(njz[i]<='9')
            sjz+=power(n,t)*(njz[i]-'0');
        else
            sjz+=power(n,t)*(njz[i]-'A'+10);//这一位如果为字母，要转换成对应的十进制数
        t--;//t用来记录这一位的权
    }
    return sjz;
}
void szh(){//十进制转m进制
    int i=1,sj;
    sj=nzh();
    while(sj>0){
        if(sj%m<10)
            mjz[i]=sj%m+'0';
        else
            mjz[i]=sj%m-10+'A';//同上的特判
        i++;
        sj/=m;
    }
    for(int j=i-1;j>=1;j--)//此处没用栈，所以要从后往前输出
        putchar(mjz[j]);
}
int main(){
    scanf("%d\n%s\n%d",&n,njz,&m);
    l=strlen(njz)-1;//l就是n进制最高位的权
    szh();
    return 0;
}

```

---

## 作者：hilsinleri (赞：12)

额很多大佬都是用栈来过此题的，可是我作为一个蒟蒻只会打暴力，所以给大家带来了一个非常暴力的题解。

```cpp
#include<bits/stdc++.h>
using namespace std;


int quick_power(int x,int y)//快速幂不解释，具体去看快速幂的题解。
{
    if(y==0)return 1;
    if(y==1)return x;
    if(y%2==0)
    {
        int f=quick_power(x,y/2);
        return (f*f);
    }
    else
    {
        int f=quick_power(x,y/2);
        return (f*f*x);
    }
}


int ord(char x)//把一个字符数字转为字面数值。
{
    if(x>='0'&&x<='9')return x-'0';
    else return x-'A'+10;
}
const string dy="0123456789ABCDEF";//对应序号为对应的字符，

int n,a,w;
string t,ans;

int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>t>>w;//n是原数据进制，t是字符串式的待转数，w是要转的进制
    int s=t.size(); //待转数在n进制下的位数
    for(register int i=0;i<s;++i)//枚举待转数的每一位
    {
        a+=ord(t[i])*quick_power(n,s-i-1);//a是用来存待转数的十进制值的，+=的右边是待转数每一位对应的十进制值
    }
    while(a!=0)//枚举a在进制下的每一位
    {
        ans+=dy[a%w];//a%w是w进制下的该位的值，用dy数组对应出其字符形式
        a/=w;//这一位已经转好，所以除去这一位，以便下一次计算
    }
    reverse(ans.begin(),ans.end());//反转我们刚刚求的答案，因为ans存的是倒过来的!我们是直接把新计算的贴在了ans的后面，导致高位反在低位后面了。
    cout<<ans;//输出
    return 0;
} 
//%%%the redsun yy&zcr
```

---

## 作者：Goashore (赞：10)

### 楼上的几位大佬的代码实在是看不懂，我来发一篇中规中矩的做法！
题目描述
请你编一程序实现两种不同进制之间的数据转换。

输入格式
共三行，第一行是一个正整数，表示需要转换的数的进制n(2≤n≤16)，第二行是一个n进制数，若n>10则用大写字母A−F表示数码10−15，并且该n进制数对应的十进制的值不超过1000000000，第三行也是一个正整数，表示转换之后的数的进制m(2≤m≤16)。

输出格式
一个正整数，表示转换之后的mm进制数。

输入输出样例：

输入

16

FF

2

输出

11111111
### 解释都在代码中，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,b[40],sum;
char a[40];
void ch1() {//将输入的进制数转化为10进制数
	for(int i=0; i<m; i++)
		sum+=(pow(n,m-i-1)*b[i]);
}
void ch2() {//将10进制数转化为目标进制
	int qq=0;
	while(sum!=0) {

		qq++;
		b[qq]=sum%k;
		sum/=k;

	}
	for(int i=qq; i>=1; i--) {
		if(b[i]>9)
			cout<<char(b[i]+55);
		else
			cout<<b[i];
	}

}
int main() {
	cin>>n;
	cin>>a;
	m=strlen(a);//字符串输入
	cin>>k;
	for(int i=0; i<m; i++) {
		if(a[i]>='0'&&a[i]<='9')
			b[i]=a[i]-48;//转数字
		else
			b[i]=a[i]-55;
	}
	ch1();//调用不多说
	ch2();
    return 0;//完美结束！
}
```


---

## 作者：Sinwind (赞：9)

# 1.分析

-1. 进制转换请参考[进制(按位计数法)](https://www.luogu.org/blog/Singularwind/count-by-bit#)；

0. 变量定义：

- 用$int$型存储转换成的$10$进制数$num\_10(1e9$在$int(2e9)$型的范围之内$)$，

- 用$string$类型存储转换前的$n$进制数$num\_n$，与转换后的$m$进制数$num\_m$；

1. 先将$n$进制数$num\_n$转换为$10$进制数$num\_10$；

- 先乘以每位的权重$(num\_10*n)$；

- 再加上每位数字$($字符$)$转换成$10$进制后的数。

	- $num\_n[i]$为字母，$num\_n[i]-'A'$得出是字母的第几个$($从$0$开始$)$，再加上$10($从$10$开始$)$得出对应数字；
    
    - 若为数字，$num\_n[i]-'0'$得出对应的数字。

2. 再将$10$进制数$num\_10$转换为$m$进制数$num\_m$。

- 短除法，$num\_10\%m$的值，为转换后的每位的数字；

- 与1.同理，将数字转换为字符$(num_10\%m>=10)?(num_10\%m-10+'A'):(num_10\%m+'0')$，注意最后的结果是$int$类型，要强制类型转换为$char$类型；

- 进制转换是从后往前写下余数，因此先得出的余数要放在后面，新得出的余数放在前面$(num\_m=$之前转换的式子$+num\_m)$。

# 2.代码

```cpp
#include <iostream>
#include <string>

using namespace std;

int n;          //转化前为n进制
int m;          //转化后为m进制
int num_10 = 0;	//转化成的10进制
string num_n;   //转化前的n进制
string num_m;   //转化后的m进制

int main(void)
{
	cin >> n;
	cin >> num_n;
    cin >> m;
	
	//n进制转为10进制
	int len_n = num_n.length();
	for(int i = 0; i < len_n; i++)
	{
		num_10 *= n;
		num_10 += (num_n[i] >= 'A' && num_n[i] <= 'F') ? (num_n[i] - 'A' + 10) : (num_n[i] - '0');
	}
    
	while(num_10)
	{
		num_m = (char)((num_10 % m >= 10) ? (num_10 % m - 10 + 'A') : (num_10 % m + '0')) + num_m;
		num_10 /= m;
	}
	
	cout << num_m;
	
	return 0;
}
```


---

## 作者：gryql (赞：6)

打表法进行进制转换，程序有点恶心吧。

```delphi

(const
    two:array[0..1] of char=('0','1');
    three:array[0..2] of char=('0','1','2');
    four:array[0..3] of char=('0','1','2','3');
    five:array[0..4] of char=('0','1','2','3','4');
    six:array[0..5] of char=('0','1','2','3','4','5');
    seven:array[0..6] of char=('0','1','2','3','4','5','6');
    eight:array[0..7] of char=('0','1','2','3','4','5','6','7');
    nine:array[0..8] of char=('0','1','2','3','4','5','6','7','8');
    eleven:array[0..10] of char=('0','1','2','3','4','5','6','7','8','9','A');
    twelve:array[0..11] of char=('0','1','2','3','4','5','6','7','8','9','A','B');
    thirteen:array[0..12] of char=('0','1','2','3','4','5','6','7','8','9','A','B','C');
    fourteen:array[0..13] of char=('0','1','2','3','4','5','6','7','8','9','A','B','C','D');
    fifteen:array[0..14] of char=('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E');
    sixteen:array[0..15] of char=('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');

var a:array[0..100000] of longint;
    i,j,k,n,x,m:longint;
    y:string;
    ch:char;

procedure shiliu(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 16;
            n:=n div 16;
        end;
    for i:=k downto 1 do
        write(sixteen[a[i]]);
end;
procedure shiwu(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 15;
            n:=n div 15;
        end;
    for i:=k downto 1 do
        write(fifteen[a[i]]);
end;
procedure shisi(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 14;
            n:=n div 14;
        end;
    for i:=k downto 1 do
        write(fourteen[a[i]]);
end;
procedure shisan(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 13;
            n:=n div 13;
        end;
    for i:=k downto 1 do
        write(thirteen[a[i]]);
end;
procedure shier(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 12;
            n:=n div 12;
        end;
    for i:=k downto 1 do
        write(twelve[a[i]]);
end;
procedure shiyi(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 11;
            n:=n div 11;
        end;
    for i:=k downto 1 do
        write(eleven[a[i]]);
end;
procedure jiu(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 9;
            n:=n div 9;
        end;
    for i:=k downto 1 do
        write(nine[a[i]]);
end;
procedure ba(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 8;
            n:=n div 8;
        end;
    for i:=k downto 1 do
        write(eight[a[i]]);
end;
procedure qi(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 7;
            n:=n div 7;
        end;
    for i:=k downto 1 do
        write(seven[a[i]]);
end;
procedure liu(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 6;
            n:=n div 6;
        end;
    for i:=k downto 1 do
        write(six[a[i]]);
end;
procedure wu(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 5;
            n:=n div 5;
        end;
    for i:=k downto 1 do
        write(five[a[i]]);
end;
procedure si(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 4;
            n:=n div 4;
        end;
    for i:=k downto 1 do
        write(four[a[i]]);
end;
procedure san(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 3;
            n:=n div 3;
        end;
    for i:=k downto 1 do
        write(three[a[i]]);
end;
procedure er(n:longint);
begin
    while (n<>0) do
        begin
            inc(k);
            a[k]:=n mod 2;
            n:=n div 2;
        end;
    for i:=k downto 1 do
        write(two[a[i]]);
end;
procedure shi(n:longint);
begin
    writeln(n);
end;
function change(n:longint;s:string):longint;
var i:longint;
begin
    change:=0;
    for i:=1 to length(s) do
        begin
            change:=change*n;
            if (s[i]='A')or(s[i]='B')OR(S[I]='C')OR(S[I]='D')OR(S[I]='E')OR(S[I]='F') then
                change:=change+(ord(s[i])-ord('A')+10)
            else change:=change+(ord(s[i])-48);
        end;
end;
begin
    readln(n);
    readln(y);
    readln(m); 
    if y='0' then
        begin
            writeln(0);
            halt;
        end;
    x:=change(n,y);
    case m of
        2:er(x);
        3:san(x);
        4:si(x);
        5:wu(x);
        6:liu(x);
        7:qi(x);
        8:ba(x);
        9:jiu(x);
        10:shi(x);
        11:shiyi(x);
        12:shier(x);
        13:shisan(x);
        14:shisi(x);
        15:shiwu(x);
        16:shiliu(x);
    end;
end.

)

```

---

## 作者：Komorebi_shine (赞：4)

n进制转m进制，可以先把n进制转10进制，再把10进制转m进制。注意要用数组和字符串读入输出。一个小优化：转10进制直接输出。







p：
```cpp
var
 a,b:array[1..30]of longint;//数组
 i,j,a1,b1,c,s1:longint;
 s:string;
begin
 readln(a1);
 readln(s);
 readln(b1);
 for i:=1 to length(s) do
  case s[i] of
   'A':a[i]:=10;
   'B':a[i]:=11;
   'C':a[i]:=12;
   'D':a[i]:=13;
   'E':a[i]:=14;
   'F':a[i]:=15;
   else a[i]:=ord(s[i])-48;
  end;//以上读入，要判断。
 s1:=0;
 c:=1;
 for i:=length(s) downto 1 do
  begin
   s1:=s1+a[i]*c;
   c:=c*a1;
  end;//转10进制
 if b1=10 then begin writeln(s1);halt;end;
 i:=1;
 while s1<>0 do
  begin
   b[i]:=s1 mod b1;
   s1:=s1 div b1;
   inc(i);
  end;//转m进制
 i:=i-1;
 for j:=i downto 1 do
  case b[j] of
   10:write('A');
   11:write('B');
   12:write('C');
   13:write('D');
   14:write('E');
   15:write('F');
   else write(b[j]);
  end;//以上输出，要判断。
end.

```

---

## 作者：zhaimingshuzms (赞：3)

#第n个题解

先用c++的字符串用cin读入，再将字符串转为数组，再将数组转为十进制数，再将十进制数转为m进制数，不断mod，最后将得到的数组倒输出即可

############################################################################################################

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cctype>
using namespace std;
long long num,a[1001],p,m,n,len,i,ans[2001];
string s;
int main()
{
    cin>>n>>s>>m;
    len=s.length();
    for (i=1; i<=len; i++)
    if (isalpha(s[i-1])) a[i]=s[i-1]-55;
    else if (isdigit(s[i-1])) a[i]=s[i-1]-48;
    for (i=len,p=1; i>=1; i--,p*=n) num+=a[i]*p;
    for (len=1;num>0;num/=m,len++) ans[len]=num%m;
    for (i=len-1;i>=1;i--)
    if (ans[i]>=10) printf("%c",ans[i]+55);
    else printf("%c",ans[i]+48); 
    return 0;
}
```

---

## 作者：yjjr (赞：3)

Step1
用字符串st的形式读入数据，将数据转化成为数字存放在数组str当中，要注意数据顺序的改变

Step2
对数字str进行处理转化成为十进制，用n不断累加

Step3
利用栈的知识将十进制数n进行“扒皮”处理，转化成为目标进制数存放在数组a中

Step4
将数组a进行判断并逆序输出

 
易错点

1.多个数据类型的变化，及字符变为数字x:=ord(st[i])-48;

2.数据存放的顺序，正置or倒置

3.“扒皮”处理时的上溢错误

4.判断转换和输出时的错误


代码
```delphi
(var
 st{正置混合}:string;
 str:array[1..1000] of longint;
    a:array[0..1000] of longint;
    i,j,x,y:longint;
 tt,n,t:int64;

procedure work(x:string);
var
 i:longint;
begin 
 j:=0;
 for i:=ord(st[0]) downto 1 do begin 
        inc(j);
  if st[i]='A' then begin str[j]:=10;continue;end;
        if st[i]='B' then begin str[j]:=11;continue;end;
  if st[i]='C' then begin str[j]:=12;continue;end;
  if st[i]='D' then begin str[j]:=13;continue;end;
  if st[i]='E' then begin str[j]:=14;continue;end;
  if st[i]='F' then begin str[j]:=15;continue;end;
  str[j]:=ord(st[i])-48;
 end;
end;
begin 
 readln(x);
 readln(st);
 readln(y);
 work(st);
 t:=1;n:=0;
 for i:=1 to j do begin 
  tt:=str[i]*t;
  n:=n+tt;
  t:=t*x;
 end;
 i:=0;
 j:=0;
 repeat
  inc(i);
  a[i]:=n mod y;
  n:=n div y;
 until n=0;
 for j:=i downto 1 do begin 
        if a[j]=10 then begin write('A');continue;end;
  if a[j]=11 then begin write('B');continue;end;
  if a[j]=12 then begin write('C');continue;end;
  if a[j]=13 then begin write('D');continue;end;
  if a[j]=14 then begin write('E');continue;end;
  if a[j]=15 then begin write('F');continue;end;
  write(a[j]);
 end;
end.)
```

---

## 作者：AVALON_7 (赞：2)

考前颓废。。。

思想事实上和前面各位大佬的差不多。。。

想放上来是觉得这可能是我见过的关于进制转换最简洁最易懂的代码了，算是给需要模板的人一个好的参照吧。。。

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;

inline int read()
{
    int X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}

const int kkk=50;

int n,x,m,ans;
int a[kkk];
char s[kkk];

void tenout(int x,int m)//十进制转任意进制
{
    while(x){a[++n]=x%m;x/=m;}
    for(int i=n;i>=1;--i)
        (a[i]<10)?(cout<<a[i]):(cout<<char(a[i]+('A'-10)));
}

void getten(int x,char s[]) //任意进制转十进制
{
    ans=0;
    for(int i=0;i<strlen(s);i++) 
        ans=ans*x+(isdigit(s[i])?(s[i]^'0'):(s[i]-'A'+10));
}

int main()
{
    x=read();cin>>s;
    getten(x,s);
    m=read();    
    tenout(ans,m); 
    return 0;
}
```

---

## 作者：Bartholomew (赞：2)



    
    
```cpp
#include <iostream>  //定义了输入和输出的头文件
#include <cmath>
using namespace std;//使用std工具箱
int maxsize=10000;
int stack[10000];  //创造了一个栈，其实可以用reverse反转函数，但是毕竟要练手
int top=-1;
void push(int value) { //一个个输入数字入栈中
    if(top>maxsize)  //如果数据爆了，就输出满了
        cout<<"this stack is full";
    else {
        stack[++top]=value;//++top是指让top加在赋值
    }
}
void pop() {//释放temp的空函数
    int temp;
    temp=stack[top--];//让temp赋值
if(temp<10)cout<<temp;//输出1，2,3,4,5,6，7,8,9
if(temp>=10){char l;
 l=temp+55;//输出ABCDEF
 cout<<l;
} 
}
int main() {
    int n,k,x;
    string s;读入进制
    cin>>n;
//以字符串形式读入s
    cin>>s;
    cin>>k;
    int len=s.length();
for(int i=len-1;i>=0;i--)//想法：将所有进制变为10进制再转化
{if(s[len-1-i]>='A'&&s[len-1-i]<='F')//可以去网上查如何进制转换
 {int q=s[len-1-i]-55;
 x=x+pow(n,i)*q;//pow为平方函数，存在cmath中
 }
 if(s[len-1-i]>='0'&&s[len-1-i]<='9')
 {int p=s[len-1-i]-48;
  x=x+pow(n,i)*p;//用x来记录转化为10进制0. 
     }    
}//cout<<x<<endl;
    while(x!=0) {
        push(x%k);
        x=x/k;
    }
    while(top!=-1) {
        pop();
    }
    return 0;
}

```

---

## 作者：Dijkstra49 (赞：1)

```cpp
#include<iostream>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
string a;
int b[100001],n,c,summ;
int zhuan(char a){
	if(a>=48&&a<=57)return a-48;//数字转换 
	else{
		if(a>=65&&a<=91)return 10+a-65;//字母转换 
	}
	return 0;
}
void print(int rr){
	if(rr>=0&&rr<=9)cout<<rr;//数字直接输出 
	else{
		if(rr>=10)cout<<(char)(rr-10+65);//大于10就输出字母 
	}
}
int main(){
	cin>>n>>a>>c;
	int rr=a.length();//开始转十进制 
	for(int i=0,j=rr-1;i<rr,j>=0;i++,j--){//i是string a中位数,j是这个位数对应的几次方 
		int yy=zhuan(a[i]);//转换 
		summ+=yy*pow(n,j);//累计 
	}
	int jj=1;//往数组里扔,转换成目标进制 
	while(summ!=0){//这是模拟转换,可以用短除法,不会的自己算一下 
		b[jj]=summ%c;//取余 
		summ/=c;//割去这段部分 
		jj++;//继续扔 
	}//(其实这是把转成十进制逆过来了(滑稽))
	if(b[jj]==0)jj--;//去除前导0 
	for(int i=jj;i>=1;i--){
		print(b[i]);//逆序转换输出 
	}
}
```

---

## 作者：ztz_cpp (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,m,x,z[6]={10,11,12,13,14,15};//z为字母 
string out;
void read(int j,int &s){//j为进制，读入优化改一下就好了 
    s=0;
    int a;
    char c=getchar();
    while((c>='0'&&c<='9')||(c>='A'&&c<='F')){
        if(c>='0'&&c<='9')//数字情况 
            a=c-'0';
        else//字母情况 
            a=z[c-'A'];
        s*=j;
        s+=a;
        c=getchar();
    }
    return;
}
int main(){
    int t=0,a;
    scanf("%d\n",&n);//不要少了\n，否则read进去就出来了 
    read(n,x);
    scanf("%d",&m);
    while(x){
        a=x%m;
        if(a<10)
            out[t++]=a+'0';
        else
            out[t++]=a-10+'A';
        x/=m;
    }
    t--;
    for(;t>=0;t--)
        printf("%c",out[t]);
    return 0;
}
```

---

